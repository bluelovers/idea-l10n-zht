// Jest Snapshot v1, https://jestjs.io/docs/snapshot-testing

exports[`dev inspectionDescriptions/LeakableMapKey.html 1`] = `
"<html>
<body>
報告在延伸模組程式碼中將 <code>Language</code> 或 <code>FileType</code> 用作映射鍵。
<p>
  此類別用法可能導致無法正確解除安裝延伸模組。
</p>
<p>
  請考慮使用 <code>String</code> 作為鍵。
</p>
<p>
  有關詳情，請參閱 SDK 文檔中的<a href="https://plugins.jetbrains.com/docs/intellij/dynamic-plugins.html">動態延伸模組</a>。
</p>
</body>
</html>"
`;

exports[`dev messages/ActionsBundle.properties 1`] = `
"MainToolbarQuickActions.BackForward.text=後退/前進
MainToolbarQuickActions.Build.text=建置
MainToolbarQuickActions.SaveAll.text=全部儲存
NewFile.popup.title=新
Vcs.VcsClone.Tabbed.Welcome.text=克隆儲存庫
Vcs.VcsClone.Welcome.text=從版本控制中獲取
action.$Copy.description=複製到剪貼簿
action.$Copy.text=複製(_C)
action.$Cut.description=剪下到剪貼簿
action.$Cut.text=剪下(_T)
action.$Delete.description=刪除所選條目
action.$Delete.text=刪除(_D)
action.$Paste.description=從剪貼簿貼上
action.$Paste.text=貼上(_P)
action.$Redo.text=重做
action.$SearchWeb.description=使用 Google 搜尋選區
action.$SearchWeb.text=使用 Google 搜尋(_S)
action.$SelectAll.description=全選
action.$SelectAll.text=全選(_A)
action.$Undo.text=撤消
action.About.description=顯示有關 IDE 的資訊
action.About.description.specialized=顯示有關 {0} 的資訊
action.About.text=關於(_A)
action.Actions.ActionsPlugin.GenerateToString.description=生成 toString() 方法
action.Actions.ActionsPlugin.GenerateToString.text=to_String()
action.ActivateDebugToolWindow.text=偵錯
action.ActivateFindToolWindow.text=尋找
action.ActivateHierarchyToolWindow.text=層次結構
action.ActivateMeetNewUIToolWindow.text=組態新 UI
action.ActivateRunToolWindow.text=執行
action.AddAnotherBookmark.text=將書籤新增到另一個列表
action.AddBom.text=新增 BOM
action.AddBreakpoint.text=新增中斷點
action.AddConditionalBreakpoint.text=新增條件中斷點…
action.AddFrameworkSupport.text=新增框架支援…
action.AddGroupToTestSchemeAction.description=允許來自組的所有資料。使用它在本地測試新的收集器。
action.AddGroupToTestSchemeAction.text=將組新增到事件測試方案
action.AddInlayBlockInternalAction.text=新增塊嵌入…
action.AddInlayInternalAction.text=新增嵌入…
action.AddLoggingBreakpoint.text=新增日誌記錄中斷點…
action.AddToScopeAction.text=新增到作用域
action.AllRunConfigurationsToggle.text=切換所有執行/偵錯組態
action.AnalyzeHeapDumpSnapshot.text=分析堆傾印
action.AnalyzePluginStartupPerformance.text=分析延伸模組啟動性能
action.AnimatorTestAction.text=測試 Animator
action.Annotate.description=顯示每行的最新修改日期和作者(也稱為“追溯”)
action.Annotate.synonym1=追溯
action.Annotate.text=註解(_N)
action.Annotate.with.Blame.text=使用 Git 追溯註解(_N)
action.AnnotateStackTraceAction.show.files.modification.info.text=顯示檔案修改資訊
action.AnonymousToInner.description=將匿名類別轉換為內部類別
action.AnonymousToInner.text=將匿名轉換成內部(_Y)…
action.ApplyFixedWindowSize.text=套用特定大小
action.AssociateWithFileType.description=將所選檔案關聯到某種檔案類型
action.AssociateWithFileType.text=與檔案類型關聯…
action.AttachDirectory.text=將目錄附加到專案…
action.AttachProject.text=附加專案…
action.AutoIndentLines.description=根據程式碼樣式設定縮排當前行或所選塊
action.AutoIndentLines.text=自動縮排行(_A)
action.AutoShowProcessWindow.description=啟動任何程序時顯示背景任務視窗
action.AutoShowProcessWindow.text=自動顯示
action.Back.description=撤消上次導覽動作
action.Back.text=後退(_B)
action.BookmarkOpenTabs.text=書籤開啟頁籤…
action.BookmarksView.AskBeforeDeletingLists.text=刪除多個書籤前詢問
action.BookmarksView.AutoscrollFromSource.text=始終選擇開啟的元素
action.BookmarksView.AutoscrollToSource.text=一鍵導覽
action.BookmarksView.ChooseType.text=更改助記符…
action.BookmarksView.Create.text=建立書籤列表…
action.BookmarksView.DefaultGroup.text=將列表標記為預設
action.BookmarksView.Delete.text=刪除
action.BookmarksView.DeleteType.text=移除助記鍵
action.BookmarksView.GroupLineBookmarks.text=按檔案將行書簽分組
action.BookmarksView.MoveDown.text=下移
action.BookmarksView.MoveUp.text=上移
action.BookmarksView.OpenInPreviewTab.text=啟用預覽頁籤
action.BookmarksView.Rename.text=編輯
action.BookmarksView.RewriteBookmarkType.text=覆寫助記鍵之前詢問
action.BookmarksView.ShowPreview.text=開啟編輯器預覽
action.BookmarksView.SortGroupBookmarks.text=按類型和名稱對書籤進行排序
action.BraceOrQuoteOut.text=跳到當前括號/引號
action.BrowseSpecialPaths.text=特殊檔案和目錄
action.BrowseWeb.text=瀏覽 Web…
action.BuildArtifact.description=選擇並建置專案中組態的工件
action.BuildArtifact.text=建置工件…
action.CallHierarchy.BaseOnThisMethod.text=基於此方法
action.CallHierarchy.description=瀏覽所選方法的呼叫層次結構
action.CallHierarchy.text=呼叫層次結構(_Y)
action.CallInlineCompletionAction.description=為當前游標位置生成建議，並將其顯示為內聯
action.CallInlineCompletionAction.text=呼叫內聯補全
action.CallSaul.description=執行快取診斷並嘗試恢復其狀態
action.CallSaul.on.file.text=修復{0, choice, 0#檔案|2#檔案}上的 IDE
action.CallSaul.text=修復 IDE
action.ChangeCodeStyleScheme.description=更改當前程式碼樣式方案
action.ChangeCodeStyleScheme.text=程式碼樣式方案
action.ChangeColorScheme.description=更改當前編輯器配色方案
action.ChangeColorScheme.text=編輯器配色方案
action.ChangeFileEncodingAction.description=更改檔案編碼
action.ChangeFileEncodingAction.text=檔案編碼
action.ChangeIdeScale.text=縮放
action.ChangeInspectionProfile.description=更改當前編輯器檢查組態檔案
action.ChangeInspectionProfile.text=錯誤醒目提示顯示
action.ChangeKeymap.description=更改當前按鍵映射
action.ChangeKeymap.text=按鍵映射
action.ChangeLaf.description=更改當前主題
action.ChangeLaf.text=主題
action.ChangeMainMenu.restart.dialog.title=更新“主選單”設定
action.ChangeSignature.description=更改所選方法或類別的簽名，並更正所有參照
action.ChangeSignature.text=更改簽名(_G)…
action.ChangeSortingAction.text=按名稱排序
action.ChangeSplitOrientation.description=更改拆分器方向
action.ChangeSplitOrientation.text=更改拆分器方向(_R)
action.ChangeTemplateDataLanguage.text=更改模板資料語言
action.ChangeToThisFileTypeAction.description=將檔案類型覆寫為 ''{0}''
action.ChangeToolWindowLayout.GoToAction.text=切換工具視窗布局
action.ChangeToolWindowLayout.text=布局
action.ChangeTypeSignature.description=更改方法、欄位、參數、變數或類別類型實參的返回值類型，並更正所有參照
action.ChangeTypeSignature.text=類型遷移(_Y)…
action.ChangeView.description=更改檢視模式
action.ChangeView.text=檢視模式
action.ChangesView.AddUnversioned.description=排定將所選檔案新增到 VCS 的時間表
action.ChangesView.AddUnversioned.text=新增到 VCS
action.ChangesView.ApplyPatch.description=將補丁套用到專案的源
action.ChangesView.ApplyPatch.text=套用補丁…
action.ChangesView.ApplyPatchFromClipboard.description=將補丁套用到專案的源
action.ChangesView.ApplyPatchFromClipboard.text=從剪貼簿套用補丁…
action.ChangesView.Browse.description=檢視已提交更改的歷史記錄
action.ChangesView.Browse.text=瀏覽更改…
action.ChangesView.CreatePatch.description=從所選更改建立更新檔
action.ChangesView.CreatePatch.text=從本地更改建立更新檔…
action.ChangesView.CreatePatchFromChanges.description=從所選更改建立更新檔
action.ChangesView.CreatePatchFromChanges.text=建立更新檔…
action.ChangesView.CreatePatchToClipboard.description=從更改建立更新檔並將其複製到剪貼簿
action.ChangesView.CreatePatchToClipboard.text=作為補丁複製到剪貼簿
action.ChangesView.Edit.description=簽出所選檔案進行編輯
action.ChangesView.Edit.text=簽出
action.ChangesView.GroupBy.Directory.text=目錄
action.ChangesView.GroupBy.Module.text=模組
action.ChangesView.GroupBy.Repository.text=儲存庫
action.ChangesView.Move.Files.text=將檔案移動到另一個更改列表…
action.ChangesView.Move.description=將所選更改移至另一個更改列表
action.ChangesView.Move.text=移至另一個更改列表…
action.ChangesView.NewChangeList.description=建立新的更改列表
action.ChangesView.NewChangeList.text=新增更改列表…
action.ChangesView.Refresh.MainMenu.text=重新整理 VCS 更改
action.ChangesView.Refresh.description=重新整理 VCS 更改
action.ChangesView.Refresh.text=重新整理
action.ChangesView.RemoveChangeList.description=移除更改列表並將所有更改移至其他更改列表
action.ChangesView.RemoveChangeList.description.template=移除{0,choice,0#更改列表|2#更改列表}和移動所有的改變到{1}
action.ChangesView.RemoveChangeList.text=刪除更改列表
action.ChangesView.RemoveChangeList.text.template=刪除{0,choice,0#更改列表|2#更改列表}
action.ChangesView.RemoveDeleted.description=排定將所選檔案從 VCS 移除的時間表
action.ChangesView.RemoveDeleted.text=從 VCS 移除
action.ChangesView.Rename.description=編輯所選更改列表的名稱和描述
action.ChangesView.Rename.text=編輯更改列表…
action.ChangesView.Revert.text=復原(_R)…
action.ChangesView.RevertFiles.text=復原檔案(_R)…
action.ChangesView.SaveToShelve.description=將所選更改複製到擱置的更改列表
action.ChangesView.SaveToShelve.text=儲存到擱置
action.ChangesView.SetDefault.description=設定預設情況下放置新更改的更改列表
action.ChangesView.SetDefault.text=設定活動更改列表
action.ChangesView.Shelve.description=將更改儲存到外部更新檔檔案，並將其從程式碼中移除
action.ChangesView.Shelve.text=擱置更改…
action.ChangesView.ShelveSilently.description=擱置對適當的已擱置更改列表的更改
action.ChangesView.ShelveSilently.text=無提示擱置
action.ChangesView.ShowCommitOptions.text=顯示提交選項
action.ChangesView.SingleClickPreview.text=預覽差異
action.ChangesView.ToggleCommitUi.text=切換提交 UI…
action.ChangesView.UnshelveSilently.description=取消擱置對相應更改列表的更改
action.ChangesView.UnshelveSilently.text=無提示取消擱置
action.CheckForUpdate.WelcomeScreen.text=檢查更新
action.CheckForUpdate.description=檢查可用的 IDE 和延伸模組更新
action.CheckForUpdate.description.plugins=檢查可用的延伸模組更新(IDE 更新在外部管理)
action.CheckForUpdate.text=檢查更新(_C)…
action.CheckIgnoredAndNotExcludedDirectories.description=檢查是否存在可以排除在索引和搜尋之外的已忽略目錄
action.CheckIgnoredAndNotExcludedDirectories.progress=正在檢查已忽略但未排除的目錄…
action.CheckIgnoredAndNotExcludedDirectories.text=檢查已忽略但未排除的目錄
action.CheckStatusForFiles.text=檢查狀態(_K)
action.CheckSuggestedPlugins.text=檢查推薦的延伸模組
action.CheckVfsSanity.progress=檢查 VFS 執行狀況(檢視日誌中的結果)
action.CheckVfsSanity.text=執行 VFS 執行狀況檢查
action.CheckinFiles.description=提交選中的檔案或目錄
action.CheckinFiles.text=提交檔案(_I)
action.CheckinProject.text=提交(_I)…
action.ChooseDebugConfiguration.description=選擇並偵錯組態
action.ChooseDebugConfiguration.text=偵錯…
action.ChooseRunConfiguration.description=選擇並執行組態
action.ChooseRunConfiguration.text=執行…
action.ChooseRuntime.text=選擇 IDE 的啟動 Java Runtime…
action.ClassNameCompletion.description=與雙擊基本補全快捷鍵相同(可用於補全非匯入類別名)
action.ClassNameCompletion.text=第二基本補全
action.CleanupEventsTestSchemeAction.description=移除測試方案中註冊的所有組
action.CleanupEventsTestSchemeAction.text=清理事件測試方案
action.ClearAllNotifications.text=清除所有通知
action.ClickLink.text=點擊連結
action.CloseActiveTab.description=關閉活動工具視窗頁籤
action.CloseActiveTab.text=關閉活動頁籤(_O)
action.CloseAllEditors.description=在活動頁籤組中關閉所有編輯視窗
action.CloseAllEditors.text=關閉所有頁籤(_A)
action.CloseAllEditorsButActive.description=除活動編輯視窗外關閉所有其他視窗
action.CloseAllEditorsButActive.text=關閉其他頁籤(_O)
action.CloseAllNotifications.text=關閉所有
action.CloseAllProjects.description=關閉所有專案
action.CloseAllProjects.text=關閉所有專案
action.CloseAllReadonly.description=關閉具有唯讀檔案的所有編輯器
action.CloseAllReadonly.text=關閉所有唯讀頁籤
action.CloseAllToTheLeft.description=關閉左邊的所有編輯器
action.CloseAllToTheLeft.text=關閉左側頁籤
action.CloseAllToTheRight.description=關閉右邊的所有編輯器
action.CloseAllToTheRight.text=關閉右側頁籤
action.CloseAllUnmodifiedEditors.description=關閉所有未修改的編輯視窗
action.CloseAllUnmodifiedEditors.text=關閉未修改頁籤(_U)
action.CloseAllUnpinnedEditors.description=關閉所有未固定的編輯器
action.CloseAllUnpinnedEditors.text=關閉所有未固定
action.CloseContent.EditorTabPopup.text=關閉(_C)
action.CloseContent.description=關閉當前焦點的內容
action.CloseContent.text=關閉頁籤(_C)
action.CloseDiffEditor.text=關閉差異編輯器
action.CloseEditor.EditorPopup.text=關閉 (_C)
action.CloseEditor.EditorTabPopup.text=關閉(_C)
action.CloseEditor.description=關閉活動編輯器
action.CloseEditor.text=關閉活動編輯器(_C)
action.CloseFirstNotification.text=關閉第一個
action.CloseGotItTooltip.text=關閉“知道了”工具提示
action.CloseOtherProjects.description=關閉其他專案
action.CloseOtherProjects.text=關閉其他專案
action.CloseProject.description=關閉當前專案
action.CloseProject.text=關閉專案(_J)
action.CodeCleanup.description=執行清理檢查並套用快速修復
action.CodeCleanup.text=程式碼清理(_C)…
action.CodeCompletion.description=補全程式碼
action.CodeCompletion.text=基本(_B)
action.CodeFloatingToolbar.GotoNextMenu.text=轉到下一個工具列選單
action.CodeFloatingToolbar.GotoPrevMenu.text=轉到上一個工具列選單
action.CodeInspection.OnEditor.text=使用編輯器設定檢查程式碼(_E)
action.CodeVisionToggleAction.description=切換當前項目的 Code Vision
action.CodeVisionToggleAction.text=切換專案的 Code Vision
action.CollapseAll.text=全部摺疊
action.CollapseAllRegions.description=摺疊所有折疊區域(選區中)
action.CollapseAllRegions.text=全部摺疊(_A)
action.CollapseBlock.description=折疊當前程式碼塊
action.CollapseBlock.text=折疊程式碼塊(_B)
action.CollapseDocComments.description=摺疊所有文檔註釋
action.CollapseDocComments.text=摺疊文檔註釋(_O)
action.CollapseExpandableComponent.text=摺疊元件
action.CollapseRegion.description=摺疊文字游標處的折疊區域
action.CollapseRegion.text=摺疊(_C)
action.CollapseRegionRecursively.description=遞迴摺疊文字游標處的塊
action.CollapseRegionRecursively.text=遞迴摺疊(_A)
action.CollapseSelection.description=折疊所選塊
action.CollapseSelection.text=折疊選區/移除區域(_S)
action.CollapseTreeNode.text=摺疊樹節點
action.CollapsiblePanel-toggle.text=展開/摺疊可折疊面板
action.CollectFUStatisticsAction.text=從收集器收集統計資訊…
action.CollectTroubleshootingInformation.text=收集故障排除資訊
action.CollectZippedLogs.description=將日誌和設定壓縮到檔案中
action.CollectZippedLogs.text=收集日誌和診斷資料
action.ColorBlindnessTest.text=測試色盲
action.ColoredHeaderAction.text=顯示專案漸變
action.CommentByBlockComment.description=使用塊註釋註釋/取消程式碼
action.CommentByBlockComment.text=使用塊註釋進行註釋(_B)
action.CommentByLineComment.description=使用行註釋註釋/取消註釋當前行或所選塊
action.CommentByLineComment.text=使用行註釋進行註釋(_L)
action.CommitView.ShowOnDoubleClick.EditorPreview.ToolwindowPopup.text=差異
action.CommitView.ShowOnDoubleClick.EditorPreview.text=雙擊時顯示差異
action.CommitView.ShowOnDoubleClick.Source.ToolwindowPopup.text=源
action.CommitView.ShowOnDoubleClick.Source.text=雙擊時顯示源
action.CommitView.SwitchToCommitDialog.text=切換到“提交”對話框
action.CommittedChanges.Clear.description=清除快取的修訂版本
action.CommittedChanges.Clear.text=清除
action.CommittedChanges.Details.description=檢視所選更改列表的完整資訊
action.CommittedChanges.Details.text=顯示詳細資訊
action.CommittedChanges.Filter.description=更改篩選條件
action.CommittedChanges.Filter.text=篩選
action.CommittedChanges.Refresh.description=重新整理已提交更改的列表
action.CommittedChanges.Refresh.text=重新整理
action.CommittedChanges.Revert.description=將所選更改的反向動作應用於工作副本
action.CommittedChanges.Revert.text=還原更改
action.Compare.LastVersion.text=與最新的儲存庫版本進行比較(_V)
action.Compare.SameVersion.text=與同一個儲存庫版本進行比較(_Y)
action.Compare.Selected.text=與修訂比較(_C)…
action.Compare.Specified.text=與指定修訂比較(_P)…
action.CompareClipboardWithSelection.description=將當前選區與剪貼簿進行比較
action.CompareClipboardWithSelection.text=與剪貼簿比較(_B)
action.CompareDirs.text=比較目錄
action.CompareFileWithEditor.description=將所選檔案與編輯器中的檔案進行比較
action.CompareFileWithEditor.text=與編輯器比較檔案(_M)
action.CompareKeymaps.text=比較按鍵映射…
action.CompareTwoFiles.description=比較兩個所選檔案或目錄
action.CompareTwoFiles.synonym1=將檔案與以下檔案比較…
action.CompareTwoFiles.synonym2=比較目錄
action.CompareTwoFiles.synonym3=將目錄與以下檔案比較…
action.CompareTwoFiles.text=比較檔案(_F)
action.Compile.description=強制重新編譯所選模組、檔案或軟體套件
action.Compile.text=重新建置(_E)
action.CompileDirty.description=編譯專案中的所有修改和相依檔案
action.CompileDirty.text=建置專案(_P)
action.CompileFile.text=重新編譯(_E)
action.CompileProject.description=重新編譯專案中的所有檔案
action.CompileProject.text=重新建置專案(_R)
action.CompletionQualityStats.text=補全品質統計資訊
action.ComponentPanelTestAction.text=顯示標準面板
action.ComputeVirtualFileNameStatAction.text=計算 VF 名稱統計資訊
action.ConfigureDefaultSize.text=組態預設大小…
action.ConfigureEditorTabs.description=組態編輯器頁籤的外觀，行為和順序
action.ConfigureEditorTabs.text=組態編輯器頁籤…
action.ConfigureEventsSchemeFileAction.description=載入自訂目錄中的事件方案
action.ConfigureEventsSchemeFileAction.text=組態事件方案檔案
action.ConfigureInspectionsAction.text=組態檢查…
action.ConfigureScopesAction.text=組態…
action.ConfigureSoftWraps.text=組態自動換行
action.ConfigureTemplatesAction.text=組態實時模板…
action.Console.Execute.Multiline.description=在多行主控台中執行當前語句
action.Console.Execute.Multiline.text=在多行主控台中執行當前語句
action.Console.Execute.description=在單行主控台中執行當前語句
action.Console.Execute.text=在單行主控台中執行當前語句
action.Console.History.Browse.description=瀏覽查詢歷史記錄
action.Console.History.Browse.text=瀏覽查詢歷史記錄
action.Console.History.Next.description=主控台歷史記錄中的下一個條目
action.Console.History.Next.text=主控台歷史記錄中的下一個條目
action.Console.History.Previous.description=主控台歷史記錄中的上一個條目
action.Console.History.Previous.text=主控台歷史記錄中的上一個條目
action.Console.Open.description=為所選實體開啟主控台
action.Console.Open.text=開啟主控台
action.Console.SplitLine.text=拆分行
action.ConsoleView.FoldLinesLikeThis.text=像這樣折疊行
action.ContextHelp.description=顯示上下文幫助
action.ContextHelp.text=上下文幫助(_X)
action.ConvertIndentsToSpaces.description=轉換檔案或所選塊中的縮排，以使用空格代替制表符
action.ConvertIndentsToSpaces.text=轉換為空格
action.ConvertIndentsToTabs.description=轉換檔案或所選塊中的縮排，以使用制表符代替空格
action.ConvertIndentsToTabs.text=轉換為制表符
action.ConvertToInstanceMethod.description=將 static 方法轉換為執行個體方法並更正所有參照
action.ConvertToInstanceMethod.text=轉換為執行個體方法(_O)…
action.CopyAbsolutePath.text=絕對路徑
action.CopyAsPlainText.description=將選區複製到剪貼簿作為純文本
action.CopyAsPlainText.text=複製為純文本
action.CopyAsRichText.description=將選區複製到剪貼簿作為富文本(以 RTF 和 HTML 格式)
action.CopyAsRichText.text=複製為富文本
action.CopyContentRootPath.text=來自內容根的路徑
action.CopyElement.description=建立所選類別、檔案或目錄的副本
action.CopyElement.text=複製(_O)…
action.CopyFileName.text=檔名
action.CopyPathWithLineNumber.text=帶行號的路徑
action.CopyPaths.description=將與所選檔案或目錄對應的路徑複製到剪貼簿
action.CopyPaths.text=複製路徑(_O)
action.CopyReference.description=複製對所選類別、方法或函式或者所選檔案相對路徑的參照
action.CopyReference.text=複製參照(_Y)
action.CopySettingsPath.description=複製所選可組態選項的相對路徑
action.CopySettingsPath.text=複製選項路徑
action.CopySettingsPath.text.template=複製 {0} 路徑
action.CopySourceRootPath.text=來自來來源根的路徑
action.CopyTBXReference.text=工具箱 URL
action.CopyUiLabel.text=複製 UI 標籤
action.CopyUrl.description=將文字游標下的 URL 複製到剪貼簿
action.CopyUrl.text=複製 URL
action.CreateDesktopEntry.description=建立桌面條目以與系統應用程式選單整合
action.CreateDesktopEntry.text=建立桌面條目…
action.CreateLauncherScript.description=使 IDE 可從命令行存取
action.CreateLauncherScript.text=建立命令行啟動器…
action.CreateLibraryFromFile.text=新增為庫…
action.CustomLayoutActionsGroup.Apply.text=套用(_A)
action.CustomLayoutActionsGroup.Delete.text=刪除(_D)…
action.CustomLayoutActionsGroup.Rename.description=重新命名當前布局(“{0}”)
action.CustomLayoutActionsGroup.Rename.text=重新命名(_E)
action.CustomLayoutActionsGroup.Restore.text=還原(_R)
action.CustomLayoutActionsGroup.Save.text=儲存更改(_S)
action.CustomizeMainToolbarAction.text=自訂工具…
action.CustomizeUIAction.text=自訂選單與工具列…
action.DSOpenConsole.text=開啟 Python 主控台
action.DebugBuildProcess.description=如果啟用，建置過程將在啟動時等待偵錯連線
action.DebugBuildProcess.text=偵錯建置過程
action.DebugListen.text=拋出偵錯異常
action.Debugger.AddInlineWatch.text=新增內聯監視
action.Debugger.AddSteppingFilter.text=新增步進篩選器…
action.Debugger.AddToWatch.text=新增到監視
action.Debugger.AdjustArrayRange.text=調整範圍…
action.Debugger.AutoRenderer.text=自動
action.Debugger.CallTracer.text=追蹤呼叫
action.Debugger.CopyStack.text=複製堆疊
action.Debugger.CreateRenderer.XDebuggerTreePopup.text=建立呈現器
action.Debugger.CreateRenderer.text=建立…
action.Debugger.CustomizeContextView.text=自訂資料檢視…
action.Debugger.CustomizeThreadsView.text=自訂執行緒檢視…
action.Debugger.EditArrayFilter.text=編輯…
action.Debugger.EditCustomField.text=編輯…
action.Debugger.EditFrameSource.text=EditFrameSource
action.Debugger.EvaluateInConsole.text=在主控台中求值
action.Debugger.FilterArray.text=篩選…
action.Debugger.FocusOnBreakpoint.description=到達中斷點時預設切換到此檢視
action.Debugger.FocusOnBreakpoint.text=在中斷點時獲取焦點
action.Debugger.FocusOnFinish.description=預設情況下，在偵錯會話結束時聚焦此檢視
action.Debugger.FocusOnFinish.text=完成後聚焦
action.Debugger.ForceEarlyReturn.description=強制方法在到達 return 語句之前返回
action.Debugger.ForceEarlyReturn.text=強制返回
action.Debugger.FreezeActiveThreadAction.description=執行緒執行將被掛起
action.Debugger.FreezeActiveThreadAction.synonym=凍結執行緒
action.Debugger.FreezeActiveThreadAction.text=掛起執行緒
action.Debugger.FreezeInactiveThreadsAction.description=其他執行緒上的執行緒執行將被掛起
action.Debugger.FreezeInactiveThreadsAction.synonym=凍結其他執行緒
action.Debugger.FreezeInactiveThreadsAction.text=掛起其他執行緒
action.Debugger.FreezeInactiveThreadsAmongSelected.description=掛起組中的停用執行緒
action.Debugger.FreezeInactiveThreadsAmongSelected.synonym=凍結組中的停用執行緒
action.Debugger.FreezeInactiveThreadsAmongSelected.text=掛起組中的停用執行緒
action.Debugger.FreezeSelectedThreads.description=掛起執行緒
action.Debugger.FreezeSelectedThreads.synonym=凍結執行緒
action.Debugger.FreezeSelectedThreads.text=掛起執行緒
action.Debugger.FreezeThread.text=掛起
action.Debugger.InterruptThread.text=中斷
action.Debugger.MarkObject.description=標記/取消標記物件，以便可以在偵錯器檢視中直觀區分
action.Debugger.MarkObject.text=標記物件…
action.Debugger.MarkObject.unmark.text=取消標記物件
action.Debugger.MuteRenderers.text=忽略呈現器
action.Debugger.NewCustomField.text=新增類別級別監視…
action.Debugger.PopFrame.description=將執行點移回方法呼叫，從堆疊中丟棄當前的方法幀
action.Debugger.PopFrame.text=重設幀(_F)
action.Debugger.ReloadFile.description=編譯檔案並熱交換所有已更改的類別
action.Debugger.ReloadFile.text=編譯並重新載入檔案
action.Debugger.RemoveAllBreakpoints.text=移除所有中斷點
action.Debugger.RemoveAllBreakpointsInFile.text=移除當前檔案中的所有中斷點
action.Debugger.RemoveArrayFilter.text=移除篩選器
action.Debugger.RemoveCustomField.text=移除監視
action.Debugger.RestoreBreakpoint.description=還原上次刪除的中斷點
action.Debugger.RestoreBreakpoint.text=還原中斷點
action.Debugger.ResumeThread.text=恢復
action.Debugger.ShowCollectionHistory.text=顯示集合歷史記錄
action.Debugger.ShowLibraryFrames.text=顯示/隱藏庫框架
action.Debugger.ShowReferring.text=顯示參照物件…
action.Debugger.ShowRelatedStack.text=顯示相關堆疊…
action.Debugger.ShowTypes.text=顯示類型
action.Debugger.SwitchToTheNextContext.text=切換到下一個停止的中斷點
action.Debugger.ThawActiveThreadAction.description=執行緒執行將被恢復
action.Debugger.ThawActiveThreadAction.synonym=取消凍結執行緒
action.Debugger.ThawActiveThreadAction.text=恢復執行緒
action.Debugger.ThawAllThreadsAction.description=其他執行緒上的執行緒執行將被恢復
action.Debugger.ThawAllThreadsAction.synonym=取消凍結所有執行緒
action.Debugger.ThawAllThreadsAction.text=恢復所有執行緒
action.Debugger.ThawSelectedThreads.description=恢復執行緒
action.Debugger.ThawSelectedThreads.synonym=取消凍結執行緒
action.Debugger.ThawSelectedThreads.text=恢復執行緒
action.Debugger.ThrowException.description=拋出一個異常
action.Debugger.ThrowException.text=拋出異常
action.Debugger.Tree.EvaluateInConsole.text=在主控台中求值
action.Debugger.ViewEditText.text=檢視/編輯文本
action.Debugger.ViewText.description=在單獨的窗格中檢視所選節點的文本值
action.Debugger.ViewText.text=檢視文本
action.Debugger.XDebuggerTextPopup.ShowAsObject.text=顯示為物件
action.DecrementWindowHeight.text=減小高度
action.DecrementWindowWidth.text=減小寬度
action.DelegateMethods.description=為欄位/getter 生成委託方法
action.DelegateMethods.text=委託方法(_D)…
action.DeleteMnemonicFromBookmark.text=移除助記鍵
action.DeleteNamedLayout.current.description=無法刪除有效布局
action.DeleteNamedLayout.description=刪除布局“{0}”
action.DeleteOldAppDirs.description=尋找以前 IDE 版本中的設定、快取和日誌目錄
action.DeleteOldAppDirs.text=刪除殘留的 IDE 目錄…
action.DeleteRecentFiles.description=從“最近的檔案”中刪除所選檔案或關閉所選工具視窗
action.DeleteRecentFiles.text=從最近的檔案中刪除
action.DeleteRecentFilesFallback.description=從“最近的檔案”中刪除所選檔案或關閉所選工具視窗
action.DeleteRecentFilesFallback.text=從“最近的檔案”中刪除
action.DeleteRunConfiguration.description=刪除執行組態
action.DeleteRunConfiguration.text=刪除
action.DetachDirectory.text=從專案中分離目錄…
action.DevKit.Bootstrap.synonym=安裝 Plugin DevKit
action.DevKit.Bootstrap.text=建立 IntelliJ IDEA 延伸模組…
action.Diff.AppendLeftSide.text=追加左側
action.Diff.AppendRightSide.text=追加右側
action.Diff.ApplyLeftSide.text=接受左側
action.Diff.ApplyNonConflicts.Left.text=從左側套用不衝突的更改
action.Diff.ApplyNonConflicts.Right.text=從右側套用不衝突的更改
action.Diff.ApplyNonConflicts.text=套用所有不衝突的更改
action.Diff.ApplyRightSide.text=接受右側
action.Diff.ComparePartial.Base.Left.text=左和中
action.Diff.ComparePartial.Base.Right.text=中和右
action.Diff.ComparePartial.Generic={0,choice,0#左|1#中|2#右} 和 {1,choice,0#左|1#中|2#右}
action.Diff.ComparePartial.Left.Right.text=左和右
action.Diff.CompareWithBase.Left.text=基礎和左
action.Diff.CompareWithBase.Result.text=基礎和中
action.Diff.CompareWithBase.Right.text=基礎和右
action.Diff.FocusOppositePane.description=在差異檢視中選擇相對窗格
action.Diff.FocusOppositePane.text=選擇相對差異窗格
action.Diff.FocusOppositePaneAndScroll.description=在差異檢視的相對窗格中選擇相同的位置
action.Diff.FocusOppositePaneAndScroll.text=在相對差異窗格中選擇位置
action.Diff.IgnoreLeftSide.text=忽略左側
action.Diff.IgnoreRightSide.text=忽略右側
action.Diff.MagicResolveConflicts.text=解決簡單的衝突
action.Diff.NextChange.text=比較下一個檔案
action.Diff.NextConflict.description=移至下一個未解決的衝突
action.Diff.NextConflict.text=下一個衝突
action.Diff.OpenDiffInEditor.text=作為編輯器頁籤開啟選定的差異請求
action.Diff.PrevChange.text=比較上一個檔案
action.Diff.PreviousConflict.description=移至上一個未解決的衝突
action.Diff.PreviousConflict.text=上一個衝突
action.Diff.ResolveConflict.text=自動解決
action.Diff.ShowDiff.description=比較檔案或修訂
action.Diff.ShowDiff.text=顯示差異
action.Diff.ShowDiffPreview.description=選區更改時取代差異內容
action.Diff.ShowInExternalTool.text=在外部工具中顯示差異
action.Diff.ShowSettingsPopup.text=顯示差異設定彈出視窗…
action.Diff.ShowStandaloneDiff.description=在新頁籤或視窗中開啟每個選區的差異
action.Diff.ShowStandaloneDiff.tab.description=在新頁籤中開啟每個選區的差異
action.Diff.ShowStandaloneDiff.tab.text=在新頁籤中顯示差異
action.Diff.ShowStandaloneDiff.text=在新頁籤或視窗中顯示差異
action.Diff.ShowStandaloneDiff.window.description=在新視窗中開啟每個選區的差異
action.Diff.ShowStandaloneDiff.window.text=在新視窗中顯示差異
action.DirDiffMenu.CancelComparingNewFilesWithEachOther.text=取消相互比較新檔案
action.DirDiffMenu.CompareNewFilesWithEachOtherAction.text=相互比較新檔案
action.DirDiffMenu.EnableEqual.text=顯示相同的檔案
action.DirDiffMenu.EnableLeft.text=在左側顯示新檔案
action.DirDiffMenu.EnableNotEqual.text=顯示差異
action.DirDiffMenu.EnableRight.text=在右側顯示新檔案
action.DirDiffMenu.Exclude.text=從結果中排除
action.DirDiffMenu.MirrorToLeft.text=設定鏡像到左側
action.DirDiffMenu.MirrorToRight.text=設定鏡像到右側
action.DirDiffMenu.SetCopyToLeft.text=設定複製到左側
action.DirDiffMenu.SetCopyToRight.text=設定複製到右側
action.DirDiffMenu.SetDefault.text=設定預設值
action.DirDiffMenu.SetDelete.text=設定刪除
action.DirDiffMenu.SetNoOperation.text=設定不執行任何動作
action.DirDiffMenu.SynchronizeDiff.All.text=全部同步
action.DirDiffMenu.SynchronizeDiff.text=同步選定項
action.DirDiffMenu.WarnOnDeletion.text=刪除時發出警告
action.DockPinnedMode.description=使工具視窗停靠並固定
action.DockPinnedMode.text=停靠固定(_P)
action.DockToolWindow.text=Dock
action.DockUnpinnedMode.description=使工具視窗停靠但焦點丟失時自動隱藏
action.DockUnpinnedMode.text=停靠不固定(_U)
action.Document2XSD.text=從 XSD 架構生成 XML 文檔…
action.Documentation.Back.text=後退
action.Documentation.EditSource.text=跳轉到源(_J)
action.Documentation.Forward.text=前進
action.Documentation.KeepTab.description=關閉當前頁籤中的所有更新，使下一個動作呼叫開啟新的頁籤
action.Documentation.KeepTab.text=保留此文檔
action.Documentation.ToggleAutoShow.description=切換是否使用補全彈出視窗自動顯示文檔
action.Documentation.ToggleAutoShow.text=在補全期間自動顯示
action.Documentation.ToggleAutoUpdate.description=選區更改時自動重新整理文檔
action.Documentation.ToggleAutoUpdate.text=從源自動更新
action.Documentation.ToggleShowInPopup.description=切換是否應在工具視窗之前顯示“文檔”彈出視窗
action.Documentation.ToggleShowInPopup.text=首先顯示“文檔”彈出視窗
action.Documentation.ViewExternal.text=檢視外部文檔
action.DumbMode.text=靜默模式
action.DumbModeTremble.text=Tremble Dumb 模式
action.DumpExtensions.text=傾印副檔名
action.DumpFeaturesAndTips.description=將有關功能和提示檔案的資訊複製到剪貼簿
action.DumpFeaturesAndTips.text=傾印功能和提示資訊(_D)
action.DumpFocusableComponentHierarchyAction.text=傾印可聚焦元件層次結構
action.DumpFormattingModel.text=傾印格式設定模型
action.DumpIElementTypesAction.text=傾印 IElementType 註冊表
action.DumpInspectionDescriptions.text=傾印檢查描述
action.DumpInspectionDescriptionsAction.text=傾印檢查描述
action.DumpIntentionsAction.text=傾印意圖
action.DumpIntentionsDescriptions.text=傾印意圖描述
action.DumpInvalidTipsOfTheDay.text=傾印無效的每日小技巧
action.DumpLibraryUsageStatistics.text=傾印庫用法的統計資訊
action.DumpLoadedInspectionsAction.text=傾印已初始化的檢查
action.DumpLookupElementWeights.text=將尋找元素權重傾印到日誌
action.DumpPluginDescriptorsAction.description=將有關已載入延伸模組的檔案描述子和類別載入器的資訊寫入日誌目錄中的 plugin-descriptors-data.json
action.DumpPluginDescriptorsAction.text=傾印延伸模組檔案描述子
action.DumpRunConfigurationTypesAction.text=傾印執行組態類型
action.DumpScreenConfiguration.text=傾印螢幕組態
action.DumpVfsInfoForExcludedFiles.text=傾印排除根下檔案的 VFS 內容
action.DumpVfsInfoForFsRoot.text=傾印以下根的 VFS 內容…
action.DumpWatchedRoots.text=顯示監視的 VFS 根
action.DupLocate.description=尋找專案中的重複程式碼
action.DupLocate.text=尋找重複項(_L)
action.EditBookmark.text=重新命名書籤…
action.EditBreakpoint.text=編輯中斷點
action.EditCustomProperties.description=開啟帶有自訂屬性檔案的編輯器頁籤
action.EditCustomProperties.text=編輯自定義屬性…
action.EditCustomVmOptions.description=開啟帶有自訂虛擬機選項檔案的編輯器頁籤
action.EditCustomVmOptions.text=編輯自定義虛擬機選項…
action.EditMacros.description=組態現有巨集
action.EditMacros.text=編輯巨集(_E)
action.EditSource.description=開啟所選條目的編輯器並使之獲得焦點
action.EditSource.text=跳轉到源(_J)
action.EditSourceInNewWindow.description=在新視窗開啟所選條目的編輯器並使之獲得焦點
action.EditSourceInNewWindow.text=在新視窗中開啟頁籤
action.EditSourceNotInEditor.text=編輯源(不在編輯器中)
action.EditTestSchemeAction.description=允許來自組的所有資料。使用它在本地測試新的收集器。
action.EditTestSchemeAction.text=編輯事件測試方案
action.EditorAddCaretPerSelectedLine.text=在所選行的末尾新增文字游標
action.EditorAddOrRemoveCaret.description=在當前檔案中設定多個游標，以同時編輯多行程式碼。
action.EditorAddOrRemoveCaret.text=新增或移除文字游標
action.EditorAddRectangularSelectionOnMouseDrag.text=拖動滑鼠時新增矩形選區
action.EditorBackSpace.text=退格
action.EditorBackwardParagraph.text=將文字游標後移一段
action.EditorBackwardParagraphWithSelection.text=在保持選區的情況下將文字游標後移一段
action.EditorBreadcrumbsHideBoth.description=隱藏路徑導覽列
action.EditorBreadcrumbsHideBoth.text=不顯示
action.EditorBreadcrumbsShowAbove.description=在文本編輯器上方顯示路徑導覽列
action.EditorBreadcrumbsShowAbove.text=頂部
action.EditorBreadcrumbsShowBelow.description=在文本編輯器下方顯示路徑導覽列
action.EditorBreadcrumbsShowBelow.text=底部
action.EditorCenterView.description=切換編輯器文本的左對齊和居中對齊
action.EditorCenterView.text=切換居中檢視
action.EditorChooseLookupItem.text=選擇查詢條目
action.EditorChooseLookupItemCompleteStatement.text=選擇查詢條目並呼叫語句補全
action.EditorChooseLookupItemDot.text=選擇查詢條目並插入點
action.EditorChooseLookupItemReplace.text=選擇查詢條目取代
action.EditorCloneCaretAbove.description=在上面的行中插入一個輔助游標，以同時編輯多行程式碼。
action.EditorCloneCaretAbove.text=在上方克隆文字游標
action.EditorCloneCaretBelow.description=在下面的行中插入一個輔助游標，以同時編輯多行程式碼。
action.EditorCloneCaretBelow.text=在下方克隆文字游標
action.EditorCodeBlockEnd.text=將文字游標移至程式碼塊結束
action.EditorCodeBlockEndWithSelection.text=在保持選區的情況下將文字游標移至程式碼塊結束
action.EditorCodeBlockStart.text=將文字游標移至程式碼塊開始
action.EditorCodeBlockStartWithSelection.text=在保持選區的情況下將文字游標移至程式碼塊開始
action.EditorCompleteStatement.text=補全當前語句
action.EditorConsoleScrollToTheEnd.text=滾動到末尾
action.EditorContextInfo.description=不可見時，顯示當前方法或類別宣告
action.EditorContextInfo.text=上下文資訊(_C)
action.EditorCopy.text=複製
action.EditorCreateRectangularSelection.text=建立矩形選區
action.EditorCreateRectangularSelectionOnMouseDrag.text=拖動滑鼠建立矩形選區
action.EditorCut.text=剪下
action.EditorCutLineBackward.text=反向剪下行
action.EditorCutLineEnd.text=剪下到行尾
action.EditorDecreaseFontSize.text=減小字體大小
action.EditorDecreaseFontSizeGlobal.text=在所有編輯器中減小字體大小
action.EditorDelete.text=刪除
action.EditorDeleteLine.text=刪除行
action.EditorDeleteToLineEnd.text=刪除到行尾
action.EditorDeleteToLineStart.text=刪除到行首
action.EditorDeleteToWordEnd.text=刪除到詞尾
action.EditorDeleteToWordEndInDifferentHumpsMode.text=在不同的 "CamelHumps" 模式下刪除到詞尾
action.EditorDeleteToWordStart.text=刪除到詞首
action.EditorDeleteToWordStartInDifferentHumpsMode.text=在不同的 "CamelHumps" 模式下刪除到詞首
action.EditorDown.text=下
action.EditorDownWithSelection.text=在保持選區的情況下向下
action.EditorDuplicate.text=重複行或選區
action.EditorDuplicateLines.text=重複整行
action.EditorEnter.text=Enter
action.EditorEscape.text=Esc
action.EditorFocusGutter.text=將裝訂區域設為焦點(無障礙功能)
action.EditorForwardParagraph.text=將文字游標前移一段
action.EditorForwardParagraphWithSelection.text=在保持選區的情況下將文字游標前移一段
action.EditorGutterToggleGlobalIndentLines.text=顯示縮排參考線
action.EditorGutterToggleGlobalLineNumbers.text=顯示行號
action.EditorGutterToggleGlobalStickyLines.description=顯示粘性行面板
action.EditorGutterToggleGlobalStickyLines.text=顯示粘性行
action.EditorGutterToggleLocalSoftWraps.gutterText=自動換行當前編輯器
action.EditorHungryBackSpace.description=與退格鍵的作用相同，但也會移除文字游標前的所有空白符號(如有)
action.EditorHungryBackSpace.text=飢餓退格
action.EditorIncreaseFontSize.text=增大字體大小
action.EditorIncreaseFontSizeGlobal.text=在所有編輯器中增加字體大小
action.EditorIndentLineOrSelection.text=縮排行或選區
action.EditorIndentSelection.text=縮排選區
action.EditorJoinLines.text=合併行
action.EditorKillRegion.text=終止所選區域
action.EditorKillRingSave.text=儲存至終止環
action.EditorKillToWordEnd.text=終止至詞尾
action.EditorKillToWordStart.text=終止至詞首
action.EditorLeft.text=左
action.EditorLeftWithSelection.text=在保持選區的情況下向左
action.EditorLineEnd.text=將文字游標移至行尾
action.EditorLineEndWithSelection.text=在保持選區的情況下將文字游標移至行尾
action.EditorLineStart.text=將文字游標移至行首
action.EditorLineStartWithSelection.text=在保持選區的情況下將文字游標移至行首
action.EditorLookupDown.text=向下尋找
action.EditorLookupSelectionDown.text=選擇下一個補全選項
action.EditorLookupSelectionUp.text=選擇上一個補全選項
action.EditorLookupUp.text=向上尋找
action.EditorMatchBrace.text=將文字游標移至符合的大括號
action.EditorMoveDownAndScroll.text=向下移動並滾動
action.EditorMoveDownAndScrollWithSelection.text=在保持選區的情況下向下移動並滾動
action.EditorMoveToPageBottom.text=將文字游標移至頁面底部
action.EditorMoveToPageBottomWithSelection.text=在保持選區的情況下將文字游標移至頁面底部
action.EditorMoveToPageTop.text=將文字游標移至頁面頂部
action.EditorMoveToPageTopWithSelection.text=在保持選區的情況下將文字游標移至頁面頂部
action.EditorMoveUpAndScroll.text=向上移動並滾動
action.EditorMoveUpAndScrollWithSelection.text=在保持選區的情況下向上移動並滾動
action.EditorNextWord.text=將文字游標移至下一個單詞
action.EditorNextWordInDifferentHumpsMode.text=在不同的 "CamelHumps" 模式下將文字游標移至下一個單詞
action.EditorNextWordInDifferentHumpsModeWithSelection.text=在不同的 "CamelHumps" 模式下保持選區的情況下將文字游標移至下一個單詞
action.EditorNextWordWithSelection.text=在保持選區的情況下將文字游標移至下一個單詞
action.EditorPageDown.text=向下翻頁
action.EditorPageDownWithSelection.text=在保持選區的情況下向下翻頁
action.EditorPageUp.text=向上翻頁
action.EditorPageUpWithSelection.text=在保持選區的情況下向上翻頁
action.EditorPaste.text=貼上
action.EditorPasteFromX11.text=從 X 剪貼簿貼上
action.EditorPasteSimple.description=貼上，不進行格式設定、自動匯入、字面量轉義等。
action.EditorPasteSimple.text=貼上為純文本(_L)
action.EditorPreviousWord.text=將文字游標移至上一個單詞
action.EditorPreviousWordInDifferentHumpsMode.text=在不同的 "CamelHumps" 模式下將文字游標移至上一個單詞
action.EditorPreviousWordInDifferentHumpsModeWithSelection.text=在不同的 "CamelHumps" 模式下保持選區的情況下將文字游標移至上一個單詞
action.EditorPreviousWordWithSelection.text=在保持選區的情況下將文字游標移至上一個單詞
action.EditorRenderingBenchmarkAction.text=編輯器渲染基準
action.EditorResetFontSize.text=重設字體大小
action.EditorResetFontSizeGlobal.text=在所有編輯器中重設字體大小
action.EditorReverseLines.text=反轉行
action.EditorRight.text=右
action.EditorRightWithSelection.text=在保持選區的情況下向右
action.EditorScrollBottom.text=滾動到底部
action.EditorScrollDown.text=向下滾動
action.EditorScrollDownAndMove.text=向下滾動並根據需要移動
action.EditorScrollLeft.text=向左滾動
action.EditorScrollRight.text=向右滾動
action.EditorScrollToCenter.text=滾動到中心
action.EditorScrollTop.text=滾動到頂部
action.EditorScrollUp.text=向上滾動
action.EditorScrollUpAndMove.text=向上滾動並根據需要移動
action.EditorSelectLine.text=擴展行選區
action.EditorSelectSingleLineAtCaret.text=選擇文字游標處的一行
action.EditorSelectWord.text=擴展選區
action.EditorSetContentBasedBidiTextDirection.description=方向由初始字元決定
action.EditorSetContentBasedBidiTextDirection.text=基於內容
action.EditorSetLtrBidiTextDirection.text=左到右
action.EditorSetRtlBidiTextDirection.text=右到左
action.EditorShowGutterIconTooltip.text=顯示裝訂區域圖示工具提示(無障礙功能)
action.EditorSortLines.text=對行排序
action.EditorSplitLine.text=拆分行
action.EditorStartNewLine.text=開始新行
action.EditorStartNewLineBefore.text=在當前行之前開始新行
action.EditorStickyConfigure.description=顯示粘性行設定對話框
action.EditorStickyConfigure.text=組態粘性行…
action.EditorStickyLinesDisable.description=隱藏粘性行面板
action.EditorStickyLinesDisable.text=停用
action.EditorStickyLinesDisableForLang.description=隱藏語言的粘性行面板
action.EditorStickyLinesDisableForLang.for.lang.text=對{0}停用
action.EditorStickyLinesDisableForLang.text=對語言停用
action.EditorSwapSelectionBoundaries.text=交換選區邊界
action.EditorTab.text=頁籤
action.EditorTextEnd.text=將文字游標移至文本結束
action.EditorTextEndWithSelection.text=在保持選區的情況下將文字游標移至文本結束
action.EditorTextStart.text=將文字游標移至文本開始
action.EditorTextStartWithSelection.text=在保持選區的情況下將文字游標移至文本開始
action.EditorToggleCase.synonym.lower=小寫
action.EditorToggleCase.synonym.upper=大寫
action.EditorToggleCase.text=切換大小寫
action.EditorToggleColumnMode.description=在當前編輯器中切換列選擇模式
action.EditorToggleColumnMode.text=列選擇模式(_M)
action.EditorToggleInsertState.text=切換插入/覆蓋
action.EditorToggleShowBreadcrumbs.description=在當前編輯器中切換顯示路徑導覽列
action.EditorToggleShowBreadcrumbs.text=顯示路徑導覽
action.EditorToggleShowGutterIcons.description=在當前編輯器中切換顯示裝訂區域圖示
action.EditorToggleShowGutterIcons.text=顯示裝訂區域圖示 (_O)
action.EditorToggleShowIndentLines.description=在當前編輯器中切換顯示縮排參考線
action.EditorToggleShowIndentLines.text=顯示縮排參考線(_O)
action.EditorToggleShowLineNumbers.description=在當前編輯器中切換顯示行號
action.EditorToggleShowLineNumbers.text=顯示行號(_I)
action.EditorToggleShowWhitespaces.description=在當前編輯器中切換顯示空格
action.EditorToggleShowWhitespaces.text=顯示空格(_O)
action.EditorToggleStickySelection.text=切換粘性選區
action.EditorToggleUseSoftWraps.description=在當前編輯器中切換使用自動換行
action.EditorToggleUseSoftWraps.text=自動換行
action.EditorToggleUseSoftWrapsInPreview.description=在預覽編輯器中切換使用自動換行
action.EditorToggleUseSoftWrapsInPreview.text=自動換行預覽編輯器
action.EditorTranspose.text=轉置
action.EditorUnSelectWord.text=收縮選區
action.EditorUnindentSelection.text=取消縮排行或選區
action.EditorUniqueLines.text=刪除重複行
action.EditorUp.text=上
action.EditorUpWithSelection.text=在保持選區的情況下向上
action.EmacsStyleIndent.text=Emacs 頁籤
action.EmmetNextEditPoint.description=轉到下一個 Emmet 編輯點
action.EmmetNextEditPoint.text=下一個 Emmet 編輯點
action.EmmetPreview.description=顯示 Emmet 縮寫的預覽
action.EmmetPreview.text=Emmet 預覽
action.EmmetPreviousEditPoint.description=轉到上一個 Emmet 編輯點
action.EmmetPreviousEditPoint.text=上一個 Emmet 編輯點
action.EmmetUpdateTag.description=使用 Emmet 縮寫更新現有 HTML 標記
action.EmmetUpdateTag.text=使用 Emmet 更新標記
action.EmojiAndSymbols.description=使用 macOS 系統調色板輸入特殊字元
action.EmojiAndSymbols.text=表情和符號
action.EnableMetalRendering.text=Metal 呈現管道
action.EncapsulateFields.description=使用存取器方法取代所選類別中欄位的直接存取
action.EncapsulateFields.text=封裝欄位(_E)…
action.EscapeEntities.description=使用實體轉義 XML/HTML 特殊字元
action.EscapeEntities.text=編碼 XML/HTML 特殊字元
action.EvaluateExpression.description=對任意表達式求值
action.EvaluateExpression.text=對表達式求值(_X)…
action.ExcludeFromProjectAction.text=從專案中排除
action.ExecutionTargets.text=目標
action.Exit.description=離開 IDE
action.Exit.text=離開(_X)
action.ExpandAll.text=全部展開
action.ExpandAllRegions.description=展開所有折疊區域(選區中)
action.ExpandAllRegions.text=全部展開(_E)
action.ExpandAllToLevel1.text=_1
action.ExpandAllToLevel2.text=_2
action.ExpandAllToLevel3.text=_3
action.ExpandAllToLevel4.text=_4
action.ExpandAllToLevel5.text=_5
action.ExpandCollapseToggleAction.description=展開或摺疊當前程式碼塊
action.ExpandCollapseToggleAction.text=切換折疊
action.ExpandDocComments.description=展開所有文檔註釋
action.ExpandDocComments.text=展開文檔註釋(_D)
action.ExpandExpandableComponent.text=展開元件
action.ExpandLiveTemplateByTab.text=按 Tab 展開實時模板
action.ExpandLiveTemplateCustom.description=使用在編輯器中輸入的前綴呼叫綁定到 '自訂快捷鍵' 的實時模板
action.ExpandLiveTemplateCustom.text=展開實時模板/Emmet 縮寫
action.ExpandRecursively.shortcutHint=按 {0} 展開所有節點
action.ExpandRecursively.text=擴展所選
action.ExpandRegion.description=展開文字游標處的折疊區域
action.ExpandRegion.text=展開(_X)
action.ExpandRegionRecursively.description=遞迴展開文字游標處的塊
action.ExpandRegionRecursively.text=遞迴展開(_R)
action.ExpandToLevel1.text=_1
action.ExpandToLevel2.text=_2
action.ExpandToLevel3.text=_3
action.ExpandToLevel4.text=_4
action.ExpandToLevel5.text=_5
action.ExpandTreeNode.text=展開樹節點
action.ExportSettings.description=匯出全域設定
action.ExportSettings.text=匯出設定(_E)…
action.ExportTestResults.description=將測試結果匯出到檔案
action.ExportTestResults.text=匯出測試結果…
action.ExportThreads.description=將所有執行緒資訊儲存到文本檔案或剪貼簿
action.ExportThreads.text=匯出執行緒(_H)…
action.ExportToEclipse.description=為每個模組建立 Eclipse 專案
action.ExportToEclipse.text=匯出到 Eclipse…
action.ExportToHTML.MainMenu.text=將檔案或選區匯出到 HTML(_H)…
action.ExportToHTML.description=以 HTML 格式儲存檔案內容，包括語法顏色
action.ExportToHTML.text=將檔案或選區匯出到 HTML(_H)…
action.ExportToTextFile.text=匯出到文本檔案
action.ExpressionStatistics.text=收集 Java 表達式統計資訊
action.ExpressionTypeInfo.description=顯示所選表達式的類型
action.ExpressionTypeInfo.text=類型資訊(_E)
action.ExternalJavaDoc.description=開啟包含所選條目文檔的瀏覽器
action.ExternalJavaDoc.text=外部文檔(_X)
action.ExternalSystem.AfterCompile.description=在建置後執行所選任務
action.ExternalSystem.AfterCompile.text=建置後執行
action.ExternalSystem.AfterRebuild.description=在完全重新建置後執行所選任務
action.ExternalSystem.AfterRebuild.text=重新建置後執行
action.ExternalSystem.AfterSync.description=在專案匯入後執行所選任務
action.ExternalSystem.AfterSync.text=同步後執行
action.ExternalSystem.AssignRunConfigurationShortcut.description=將快捷鍵指定至所選執行組態
action.ExternalSystem.AssignRunConfigurationShortcut.text=指定快捷鍵…
action.ExternalSystem.AssignShortcut.description=將快捷鍵指定至所選任務
action.ExternalSystem.AssignShortcut.text=指定快捷鍵…
action.ExternalSystem.BeforeCompile.description=在建置前執行所選任務
action.ExternalSystem.BeforeCompile.text=建置前執行
action.ExternalSystem.BeforeRebuild.description=在完全重新建置前執行所選任務
action.ExternalSystem.BeforeRebuild.text=重新建置前執行
action.ExternalSystem.BeforeRun.description=在啟動執行/偵錯組態之前執行所選任務
action.ExternalSystem.BeforeRun.text=在執行/偵錯之前執行…
action.ExternalSystem.BeforeSync.description=在專案匯入前執行所選任務
action.ExternalSystem.BeforeSync.text=同步前執行
action.ExternalSystem.CollapseAll.text=全部摺疊
action.ExternalSystem.EditRunConfiguration.text=編輯執行組態…
action.ExternalSystem.ExpandAll.text=全部展開
action.ExternalSystem.GroupModules.text=組模組
action.ExternalSystem.GroupTasks.text=組任務
action.ExternalSystem.RemoveRunConfiguration.text=移除執行組態
action.ExternalSystem.RunTask.description=執行選定任務
action.ExternalSystem.RunTask.text=執行任務(_R)
action.ExternalSystem.SelectProjectDataToImport.text=選擇要匯入的專案資料
action.ExternalSystem.ShowCommonSettings.description=為當前專案編輯建置工具設定
action.ExternalSystem.ShowCommonSettings.text=自動同步設定…
action.ExternalSystem.ShowIgnored.text=顯示忽略項
action.ExternalSystem.ShowInheritedTasks.text=顯示從子專案繼承的任務
action.ExtractClass.description=提取委託
action.ExtractClass.text=提取委託(_D)…
action.ExtractInclude.description=將所選程式碼段轉換為包含的檔案
action.ExtractInclude.text=包含檔案(_I)…
action.ExtractInterface.description=從所選類別提取接口
action.ExtractInterface.text=提取接口(_I)…
action.ExtractMethod.description=將所選程式碼段轉換為一個方法
action.ExtractMethod.text=提取方法(_M)…
action.ExtractModule.description=從所選類別提取模組
action.ExtractModule.text=提取模組(_M)…
action.ExtractModuleFromPackage.description=將軟體套件提取到單獨的模組
action.ExtractModuleFromPackage.text=提取模組…
action.ExtractSuperclass.description=從所選類別提取超類別
action.ExtractSuperclass.text=提取超類別(_U)…
action.FileChooser.Delete.description=刪除
action.FileChooser.Delete.text=刪除…
action.FileChooser.GoBackward.description=轉到之前存取過的目錄。
action.FileChooser.GoBackward.text=上一個目錄
action.FileChooser.GoForward.description=轉到之前存取過的目錄。
action.FileChooser.GoForward.text=下一個目錄
action.FileChooser.GoToParent.description=轉到父目錄
action.FileChooser.GoToParent.text=父目錄
action.FileChooser.GoToRoot.description=轉到根目錄或根目錄列表
action.FileChooser.GoToRoot.text=根目錄
action.FileChooser.GoToWslHome.description=轉到 WSL VM 中的主目錄
action.FileChooser.GoToWslHome.text=WSL 中的主目錄
action.FileChooser.GotoDesktop.description=轉到桌面目錄
action.FileChooser.GotoDesktop.text=桌面目錄
action.FileChooser.GotoHome.description=轉到主目錄
action.FileChooser.GotoHome.text=主目錄
action.FileChooser.GotoModule.description=轉到模組目錄
action.FileChooser.GotoModule.text=模組目錄
action.FileChooser.GotoProject.description=轉到專案目錄
action.FileChooser.GotoProject.text=專案目錄
action.FileChooser.LightEditGotoOpenedFile.text=選擇開啟的檔案
action.FileChooser.NewFile.description=建立一個新檔案
action.FileChooser.NewFile.text=新增檔案…
action.FileChooser.NewFolder.description=建立一個新目錄
action.FileChooser.NewFolder.text=新增目錄…
action.FileChooser.Refresh.description=重新整理檔案系統樹
action.FileChooser.Refresh.text=重新整理
action.FileChooser.ShowHidden.description=顯示隱藏的檔案和目錄
action.FileChooser.ShowHidden.text=顯示隱藏的檔案和目錄
action.FileChooser.ToggleDetection.description=允許 IDE 檢視內部以檢測專案目錄
action.FileChooser.ToggleDetection.text=檢測專案目錄
action.FileChooser.TogglePathBar.description=切換路徑輸入欄位的可見性
action.FileChooser.TogglePathBar.text=顯示/隱藏路徑輸入欄位
action.FileChooser.TogglePathShowing.text=顯示/隱藏路徑文本
action.FileStructurePopup.description=顯示帶有當前檔案結構的彈出視窗，以便快速導覽
action.FileStructurePopup.text=檔案結構(_I)
action.FillParagraph.description=重新設定字串字面量或註釋的格式以適應最大寬度(通常為80)
action.FillParagraph.text=填充段落
action.Find.description=在活動編輯器中尋找字串
action.Find.text=尋找(_F)…
action.FindInPath.description=在多個檔案中尋找字串
action.FindInPath.synonym1=在路徑中尋找
action.FindInPath.text=在檔案中尋找…
action.FindNext.MainMenu.text=尋找下一個符合項(_N)
action.FindNext.description=重複上一次尋找/取代動作，或移至所選文本的下一個符合項
action.FindNext.text=尋找下一個/移至下一個符合項(_N)
action.FindPrevWordAtCaret.description=尋找文字游標處單詞的上一個符合項
action.FindPrevWordAtCaret.text=文字游標處單詞的上一個符合項
action.FindPrevious.MainMenu.text=尋找上一個符合項(_V)
action.FindPrevious.description=反向重複上一次尋找/取代動作，或移至所選文本的上一個符合項
action.FindPrevious.text=尋找上一個/移至上一個符合項(_V)
action.FindSelectionInPath.text=在檔案中尋找
action.FindUsages.description=尋找文字游標處符號的用法
action.FindUsages.text=尋找用法(_U)
action.FindUsagesInFile.description=在活動編輯器中尋找文字游標處符號的用法
action.FindUsagesInFile.text=在檔案中尋找用法(_I)
action.FindUsedTestData.text=尋找未使用的測試資料
action.FindWordAtCaret.description=尋找文字游標處單詞的下一個符合項
action.FindWordAtCaret.text=尋找文字游標處的字
action.FixDocComment.description=生成或修正當前上下文的文檔註釋
action.FixDocComment.text=修正文檔註釋
action.FixLineSeparators.text=修復行分隔符
action.FloatMode.description=將工具視窗移至單獨的對話框
action.FloatMode.text=浮動(_F)
action.Floating.CodeToolbar.Customize.text=自訂工具列…
action.Floating.CodeToolbar.Disable.text=不顯示工具列
action.Floating.CodeToolbar.SurroundWithIf.text=if
action.Floating.CodeToolbar.SurroundWithTryCatch.text=try / catch
action.Floating.CodeToolbar.SurroundWithTryCatchFinally.text=try / catch / finally
action.FocusDebugger.text=啟動焦點偵錯器
action.FocusEditor.text=聚焦編輯器
action.FocusTracer.text=啟動焦點追蹤
action.ForceIndexRebuild.text=對所有內容重新編制索引
action.ForceIndexRebuild.warning=確定要重新索引所有檔案嗎?
action.ForceIndexRescanning.text=同步索引
action.ForceRefresh.text=強制重新整理
action.ForceRunToCursor.description=執行到文字游標所在的行，忽略任何中斷點
action.ForceRunToCursor.text=強制執行到游標(_S)
action.ForceStepInto.description=步入，忽略庫、建構函式等步進篩選器。
action.ForceStepInto.text=強制步入(_N)
action.ForceStepOver.description=步過，在步進前停用所有中斷點。
action.ForceStepOver.text=強制步過(_V)
action.Forward.description=恢復上次撤消的導覽動作
action.Forward.text=前進(_W)
action.Frontend.ChangesView.GroupBy.Directory.text=目錄
action.Frontend.ChangesView.GroupBy.Module.text=模組
action.Frontend.ChangesView.GroupBy.Repository.text=儲存庫
action.Frontend.ChangesView.Shelf.CreatePatchFromChanges.Clipboard.text=作為補丁複製到剪貼簿
action.Frontend.ChangesView.Shelf.CreatePatchFromChanges.text=建立更新檔…
action.Frontend.ChangesView.Shelf.ImportFromPatches.text=匯入更新檔…
action.Frontend.ChangesView.Shelf.Rename.text=重新命名…
action.Frontend.ChangesView.Shelf.Restore.text=還原
action.Frontend.ChangesView.ShowDiff.text=顯示差異
action.Frontend.ChangesView.UnshelveSilently.text=無提示取消擱置
action.Frontend.Delete.Action.text=刪除(_D)
action.Frontend.EditSource.text=跳轉到原始碼(_J)
action.Frontend.ShelveChanges.UnshelveWithDialog.text=取消擱置…
action.Frontend.Vcs.CompareWithLocal.text=與本地比較
action.Frontend.Vcs.ShowStandaloneDiff.window.text=在新視窗中顯示差異
action.FullyExpandTreeNode.text=完全展開樹節點
action.GatewayPluginsAction.text=管理提供程序
action.GemRequirements.ShowSettings.text=Ruby 解釋器
action.Generate.description=生成建構函式、getter 或 setter 方法等
action.Generate.text=生成…
action.GenerateAfterClassMethod.text=AfterClass 方法
action.GenerateBeforeClassMethod.text=BeforeClass 方法
action.GenerateConstructor.description=生成建構函式
action.GenerateConstructor.text=建構函式
action.GenerateCoverageReport.text=生成覆蓋率報告(_G)
action.GenerateCreateUI.description=生成 createUI(…)
action.GenerateCreateUI.text=createUI(…)
action.GenerateDTD.text=從 XML 檔案生成 DTD(_X)
action.GenerateDataMethod.text=參數方法
action.GenerateEquals.description=生成 equals() 和 hashCode()
action.GenerateEquals.text=equals() 和 hashCode()
action.GenerateEventsScheme.description=從正在執行的 IDE 執行個體中收集統計資訊收集器的方案
action.GenerateEventsScheme.text=顯示 FUS 收集器方案
action.GenerateGetter.description=生成 getter
action.GenerateGetter.text=Getter
action.GenerateGetterAndSetter.description=生成 getter 和 setter
action.GenerateGetterAndSetter.text=Getter 和 Setter
action.GenerateJavadoc.description=執行 Javadoc 工具
action.GenerateJavadoc.text=生成 Javadoc(_D)…
action.GenerateLogField.description=生成記錄器
action.GenerateLogField.text=記錄器
action.GenerateModuleDescriptors.description=為專案中的所有模組 module-info 檔案 (適用於 Java 9 及更高版本)
action.GenerateModuleDescriptors.text=生成 module-info 檔案描述子
action.GenerateProviderMethod.description=生成 provider 方法
action.GenerateProviderMethod.text=provider()
action.GenerateSetUpMethod.text=SetUp 方法
action.GenerateSetter.description=生成 setter
action.GenerateSetter.text=Setter
action.GenerateSuperMethodCall.description=生成 super 方法呼叫
action.GenerateSuperMethodCall.text=super 方法呼叫
action.GenerateTearDownMethod.text=TearDown 方法
action.GenerateTestDataPathFiles.text=@TestDataPath 檔案
action.GenerateTestDataPathMethods.text=@TestDataPath 方法
action.GenerateTestMethod.text=測試方法
action.GenerateVisitorByHierarchy.text=生成層次結構存取器…
action.GenerateXmlTag.description=根據架構資訊生成新的 XML 標記
action.GenerateXmlTag.text=XML 標記…
action.GoToLastTab.description=啟用最後一個頁籤
action.GoToLastTab.text=選擇最後一個頁籤
action.GoToLinkTarget.description=在專案檢視中開啟此符號連結的目標
action.GoToLinkTarget.text=轉到連結目標
action.GoToTab.description=啟用頁籤 #{0}
action.GoToTab.text=選擇頁籤 #{0}
action.GotoAction.description=通過名稱快速導覽到動作
action.GotoAction.text=尋找動作(_F)…
action.GotoChangedFile.description=通過名稱快速導覽到更改的檔案
action.GotoChangedFile.text=轉到更改的檔案…
action.GotoClass.description=通過名稱快速導覽到類別
action.GotoClass.text=轉到類別…
action.GotoCustomRegion.text=自訂折疊…
action.GotoDeclaration.MainMenu.text=宣告或用例(_D)
action.GotoDeclaration.description=導覽到文字游標處符號的宣告或顯示其用法
action.GotoDeclaration.text=前往宣告或用法
action.GotoDeclarationOnly.MainMenu.text=宣告
action.GotoDeclarationOnly.description=導覽到文字游標處符號的宣告
action.GotoDeclarationOnly.text=轉到宣告
action.GotoFile.MainMenu.text=檔案(_F)…
action.GotoFile.description=通過名稱快速導覽到檔案
action.GotoFile.text=轉到檔案…
action.GotoImplementation.MainMenu.text=實作(_M)
action.GotoImplementation.description=導覽到所選類別或方法的實作
action.GotoImplementation.text=轉到實作(_M)
action.GotoLine.MainMenu.text=行:列(_L)…
action.GotoLine.description=通過編號在編輯器中導覽到某一行(和/或列)
action.GotoLine.text=轉到行:列…
action.GotoNextBookmark.text=下一行書籤
action.GotoNextBookmarkInEditor.text=編輯器中的下一行書籤
action.GotoNextElementUnderCaretUsage.description=導覽到下一個醒目提示的元素用法
action.GotoNextElementUnderCaretUsage.text=下一個醒目提示用例
action.GotoNextError.description=在活動編輯器中導覽到下一個醒目提示的錯誤
action.GotoNextError.text=下一個醒目提示顯示錯誤(_N)
action.GotoPrevElementUnderCaretUsage.description=導覽到上一個醒目提示的元素用法
action.GotoPrevElementUnderCaretUsage.text=轉到上一個醒目提示的元素用法
action.GotoPreviousBookmark.text=上一行書籤
action.GotoPreviousBookmarkInEditor.text=編輯器中的上一行書籤
action.GotoPreviousError.description=在活動編輯器中導覽到上一個醒目提示的錯誤
action.GotoPreviousError.text=上一個醒目提示顯示錯誤(_P)
action.GotoRelated.description=導覽到一個相關或連結的符號
action.GotoRelated.text=相關符號(_R)…
action.GotoSuperMethod.MainMenu.text=super 方法(_U)
action.GotoSuperMethod.description=導覽到當前方法覆寫或實作的方法的宣告
action.GotoSuperMethod.text=轉到 Super 方法
action.GotoSymbol.MainMenu.text=符號(_S)…
action.GotoSymbol.description=通過名稱快速導覽到任意符號
action.GotoSymbol.text=轉到符號…
action.GotoTest.MainMenu.text=測試(_E)
action.GotoTest.description=導覽到所選類別的測試
action.GotoTest.text=轉到測試
action.GotoTest.text.subject=轉到測試主體
action.GotoTestSubject.MainMenu.text=測試主體(_E)
action.GotoTestSubject.description=導覽到所選測試的主體
action.GotoTestSubject.text=轉到測試主體(_E)
action.GotoTypeDeclaration.MainMenu.text=類型宣告(_T)
action.GotoTypeDeclaration.description=導覽到文字游標處符號類型的宣告
action.GotoTypeDeclaration.text=轉到類型宣告
action.Graph.ActualSize.text=實際尺寸
action.Graph.AlignNodes.Bottom.text=底部
action.Graph.AlignNodes.Center.text=中心
action.Graph.AlignNodes.Left.text=左側
action.Graph.AlignNodes.Middle.text=居中排列
action.Graph.AlignNodes.Right.text=右側
action.Graph.AlignNodes.Top.text=頂部
action.Graph.ApplyCurrentLayout.text=套用當前布局
action.Graph.CopyDiagramSelectionToClipboard.text=將選區複製到剪貼簿
action.Graph.CopyEntireDiagramToClipboard.text=將圖表複製到剪貼簿
action.Graph.Current.Node.Dependencies.Filter.text=顯示所選節點與相依關係
action.Graph.Delete.text=刪除選區
action.Graph.DistributeNodes.Horizontally.text=水平排列
action.Graph.DistributeNodes.Vertically.text=垂直排列
action.Graph.EdgeRealizer.ArcEdgeRealizer.text=弧形
action.Graph.EdgeRealizer.BezierEdgeRealizer.text=貝塞爾曲線
action.Graph.EdgeRealizer.QuadCurveEdgeRealizer.text=二次曲線
action.Graph.EdgeRealizer.SmoothedPolylineEdgeRealizer.text=平滑多段線
action.Graph.EdgeRealizer.SplineEdgeRealizer.text=樣條
action.Graph.EdgeRealizer.StraightPolylineEdgeRealizer.text=直多段線
action.Graph.ExportToFile.description=匯出為 PNG、JPG、GIF、SVG 或 SVGZ 檔案
action.Graph.ExportToFile.text=匯出到圖片…
action.Graph.FitContent.text=調整內容
action.Graph.Layout.ARTreeLayouter.text=緊湊
action.Graph.Layout.BalloonEdgeBundledLayouter.text=邊緣捆綁(氣球)
action.Graph.Layout.BalloonLayouter.text=氣球
action.Graph.Layout.ChannelLayouter.text=通道
action.Graph.Layout.CircularEdgeBundledLayouter.text=邊緣捆綁(圓形)
action.Graph.Layout.CircularLayouter.text=迴圈
action.Graph.Layout.CompactOrthogonalLayouter.text=緊湊
action.Graph.Layout.CustomLayouter.text=圖特定
action.Graph.Layout.FamilyLayouter.text=系列
action.Graph.Layout.Fit.Content.text=在布局後調整內容
action.Graph.Layout.GenericLayouter.text=泛型
action.Graph.Layout.HVTreeLayouter.text=寬
action.Graph.Layout.HierarchicGroupLayouter.text=層次結構組
action.Graph.Layout.HierarchicLayouter.text=分層
action.Graph.Layout.OrganicEdgeBundledLayouter.text=邊緣捆綁(有機)
action.Graph.Layout.OrganicLayouter.text=有機
action.Graph.Layout.OrthogonalGroupLayouter.text=正交群
action.Graph.Layout.RadialEdgeBundledLayouter.text=邊緣捆綁(徑向)
action.Graph.Layout.RadialLayouter.text=徑向
action.Graph.Layout.RandomLayouter.text=隨機
action.Graph.Layout.SeriesParallelLayouter.text=串並聯
action.Graph.Layout.SingleCycleLayouter.text=單迴圈
action.Graph.LayoutOrientation.BottomToTop.text=↑ 從下到上
action.Graph.LayoutOrientation.LeftToRight.text=→ 從左到右
action.Graph.LayoutOrientation.RightToLeft.text=← 從右到左
action.Graph.LayoutOrientation.TopToBottom.text=↓ 從上到下
action.Graph.MergeEdges.BySources.text=按源
action.Graph.MergeEdges.ByTargets.text=按目標
action.Graph.NeighborhoodViewPopup.CompactMode.text=緊湊地顯示節點
action.Graph.NeighborhoodViewPopup.SameAsModelLayouter.text=與 Main 相同
action.Graph.RouteEdges.text=自動路由邊緣
action.Graph.Show.Bridges.text=顯示連結橋
action.Graph.Show.Edge.Labels.text=顯示邊緣標籤
action.Graph.ShowHideGrid.text=顯示網格
action.Graph.ShowStructureViewForSelectedNode.text=顯示所選節點的結構檢視
action.Graph.SnapToGrid.text=對齊到網格
action.Graph.ZoomIn.text=放大
action.Graph.ZoomOut.text=縮小
action.Graph.print.reset=重設
action.GrayFilterConfig.text=灰色篩選器(&G)
action.Help.JetBrainsTV.description=檢視介紹 JetBrains 產品功能的簡短現場示範
action.Help.JetBrainsTV.templateText=YouTube 上的 {0}
action.Help.JetBrainsTV.text=展示與螢幕錄製
action.Help.KeymapReference.description=開啟帶有預設按鍵映射參考卡的 PDF 檔案
action.Help.KeymapReference.text=鍵盤快捷鍵 PDF(_K)
action.HelpTopics.description=顯示幫助內容
action.HelpTopics.text=幫助(_H)
action.HideActiveWindow.description=隱藏活動工具視窗
action.HideActiveWindow.text=隱藏活動工具視窗(_D)
action.HideAllWindows.description=隱藏所有工具視窗
action.HideAllWindows.text=隱藏所有工具視窗(_T)
action.HideSideWindows.description=隱藏本側所有視窗
action.HideSideWindows.text=隱藏本側工具視窗
action.HidpiInfo.text=顯示 HiDPI 資訊(&H)
action.HighlightUsagesInFile.description=在活動編輯器中醒目提示文字游標處符號的用法
action.HighlightUsagesInFile.not.ready=此用法搜尋需要索引，在索引建置之前無法執行
action.HighlightUsagesInFile.text=醒目提示檔案中的用法(_H)
action.HippieBackwardCompletion.description=迴圈擴展詞(向後)
action.HippieBackwardCompletion.text=迴圈擴展詞(向後)(_E)
action.HippieCompletion.description=迴圈擴展詞
action.HippieCompletion.text=迴圈擴展詞(_E)
action.Hotswap.and.compile.description=編譯專案並熱交換所有已更改的類別
action.Hotswap.and.compile.text=編譯專案並重新載入已更改的類別(_A)
action.Hotswap.description=熱交換所有已更改的類別
action.Hotswap.text=重新載入已更改的類別(_A)
action.IconScaleTestAction.text=顯示圖示比例測試對話框
action.IconsLoadTime.text=日誌圖示載入時間
action.IdeScriptingConsole.description=開啟 IDE 腳本主控台
action.IdeScriptingConsole.text=IDE 腳本主控台
action.ImageDuplicates.text=尋找圖片重複項
action.ImplementMethods.description=在當前類別中實作基接口/類別方法
action.ImplementMethods.text=實作方法(_I)…
action.ImportModule.description=從包含現有原始碼的目錄或者現有專案模型匯入模組
action.ImportModule.text=來自現有源的模組…
action.ImportModuleFromImlFile.description=將 iml 檔案作為一個模組匯入到專案
action.ImportModuleFromImlFile.text=匯入模組
action.ImportProject.description=為包含現有原始碼的目錄建立專案結構或者轉換現有專案模型
action.ImportProject.text=來自現有源的專案…
action.ImportSettings.description=匯入全域設定
action.ImportSettings.text=匯入設定…
action.ImportTestsFromFile.text=從檔案匯入測試
action.IncludeToProjectAction.text=包含到專案中
action.IncomingChanges.Refresh.description=重新整理傳入更改的列表
action.IncomingChanges.Refresh.text=重新整理
action.IncrementWindowHeight.text=增大高度
action.IncrementWindowWidth.text=增大寬度
action.IncrementalSearch.description=啟動增量搜尋(輸入時搜尋字串)，IntelliJ IDEA 6.0 實作。
action.IncrementalSearch.text=增量搜尋(_L)
action.InferNullity.description=推斷為 null 性
action.InferNullity.text=推斷為 null 性(_N)…
action.InheritanceToDelegation.description=將繼承取代為委託
action.InheritanceToDelegation.text=將繼承取代為委託(_I)…
action.Inline.description=內聯所選方法或變數
action.Inline.text=內聯(_N)…
action.InsertInlineCompletionAction.description=插入當前內聯補全提案
action.InsertInlineCompletionAction.text=插入內聯提案
action.InsertInlineCompletionLineAction.description=從當前內聯補全提案中插入下一行
action.InsertInlineCompletionLineAction.text=插入內聯提案的行
action.InsertInlineCompletionWordAction.description=從當前內聯補全提案中插入下一個單詞
action.InsertInlineCompletionWordAction.text=插入內聯提案的單詞
action.InsertLiveTemplate.description=顯示以指定前綴開頭的實時模板的彈出式列表
action.InsertLiveTemplate.text=插入實時模板(_T)…
action.InsertRubyInjection.description=在 Erb 檔案中插入 '<%= %>'
action.InsertRubyInjection.text=插入 '<%= %>'
action.InsertRubyInjectionWithoutOutput.description=在 Erb 檔案中插入 '<% %>'
action.InsertRubyInjectionWithoutOutput.text=插入 '<% %>'
action.InspectCode.description=檢查程式碼
action.InspectCode.text=檢查程式碼(_I)…
action.InspectionFilterAction.filter.by.language.text=按語言篩選
action.InspectionFilterAction.filter.inspections.text=篩選器檢查
action.IntegrateFiles.description=整合所選檔案或目錄
action.IntegrateFiles.text=整合
action.IntroduceConstant.description=將所選表達式取代為常數
action.IntroduceConstant.text=引入常數(_C)…
action.IntroduceField.description=將所選表達式的結果放入欄位中
action.IntroduceField.text=引入欄位(_F)…
action.IntroduceFunctionalParameter.description=通過呼叫新的函式方法參數來取代所選的語句
action.IntroduceFunctionalParameter.text=引入函式參數(_L)…
action.IntroduceFunctionalVariable.description=通過呼叫新的函式變數來取代所選的語句
action.IntroduceFunctionalVariable.text=引入函式變數…
action.IntroduceParameter.description=將所選表達式轉換為方法參數
action.IntroduceParameter.text=引入參數(_P)…
action.IntroduceParameterObject.description=將方法參數列表取代為物件
action.IntroduceParameterObject.text=引入參數物件(_J)…
action.IntroduceVariable.description=將所選表達式的結果放入變數中
action.IntroduceVariable.text=引入變數(_V)…
action.InvalidateCaches.description=在下次啟動時強制重新建置所有快取和索引
action.InvalidateCaches.text=使快取失效…
action.InvertBoolean.description=使方法返回值或變數包含相反的值並更正參照
action.InvertBoolean.text=反轉布林值(_B)…
action.JBCefOsrMeasureFps.text=測量 OSR JCEF FPS
action.JBCefTestApp.text=JCEF 測試套用
action.JBTabsDemo.text=JBTabs 示範
action.JShell.Console.description=啟動 JShell 主控台
action.JShell.Console.text=JShell 主控台…
action.JTabbedPaneDemo.text=JTabbedPane 示範
action.JsonCopyPointer.description=複製 JSON 指針
action.JsonCopyPointer.text=複製 JSON 指針
action.JumpToColorsAndFonts.description=跳轉到文字游標下的螢光筆的顏色選項
action.JumpToColorsAndFonts.text=跳轉到顏色和字體
action.JumpToLastChange.description=在最近的更改點中移動
action.JumpToLastChange.text=最後編輯位置(_O)
action.JumpToLastWindow.description=啟用上一個聚焦的工具視窗
action.JumpToLastWindow.text=跳轉到上一個工具視窗(_J)
action.JumpToNextChange.description=在最近的更改點中移動
action.JumpToNextChange.text=下一個編輯位置
action.KeepTabOpen.description=將預覽頁籤轉換為一般編輯器頁籤
action.KeepTabOpen.text=保持頁籤開啟
action.KeymapToCsv.text=將按鍵映射匯出到 CSV…
action.LabelSizeDemoAction.text=測試標籤大小
action.LaggingMode.text=滯後模式
action.LibrarySettings.navigate=開啟庫設定
action.LibraryUsageStatistics.text=顯示匯入的庫用法資訊
action.LightEditExitAction.text=離開(&X)
action.LightEditNewFileAction.text=新增(&N)
action.LightEditOpenFileInProjectAction.text=在專案中開啟檔案…
action.List-scrollDown.description=將周圍的可滾動區域向下滾動一頁，然後選擇相應的行
action.List-scrollDown.text=向下滾動頁面並選擇行
action.List-scrollDownExtendSelection.description=將周圍的可滾動區域向下滾動一頁，然後將相應的行新增到選區
action.List-scrollDownExtendSelection.text=向下滾動頁面並擴展選區
action.List-scrollUp.description=將周圍的可滾動區域向上滾動一頁，然後選擇相應的行
action.List-scrollUp.text=向上滾動頁面並選擇行
action.List-scrollUpExtendSelection.description=將周圍的可滾動區域向上滾動一頁，然後將相應的行新增到選區
action.List-scrollUpExtendSelection.text=向上滾動頁面並擴展選區
action.List-selectFirstRow.description=選擇第一行
action.List-selectFirstRow.text=選擇第一行
action.List-selectFirstRowExtendSelection.description=滾動到第一行並將相應行新增到選區
action.List-selectFirstRowExtendSelection.text=將選區擴展到第一行
action.List-selectLastRow.description=選擇最後一行
action.List-selectLastRow.text=選擇最後一行
action.List-selectLastRowExtendSelection.description=滾動到最後一行並將相應行新增到選區
action.List-selectLastRowExtendSelection.text=將選區擴展到最後一行
action.List-selectNextColumn.description=選擇下一列
action.List-selectNextColumn.text=選擇下一列
action.List-selectNextColumnExtendSelection.description=將下一列新增到選區
action.List-selectNextColumnExtendSelection.text=將選區擴展到下一列
action.List-selectNextRow.description=選擇下一行
action.List-selectNextRow.text=選擇下一行
action.List-selectNextRowExtendSelection.description=將下一行新增到選區
action.List-selectNextRowExtendSelection.text=將選區擴展到下一行
action.List-selectPreviousColumn.description=選擇上一列
action.List-selectPreviousColumn.text=選擇上一列
action.List-selectPreviousColumnExtendSelection.description=將上一列新增到選區。
action.List-selectPreviousColumnExtendSelection.text=將選區擴展到上一列
action.List-selectPreviousRow.description=選擇上一行
action.List-selectPreviousRow.text=選擇上一行
action.List-selectPreviousRowExtendSelection.description=將上一行新增到選區。
action.List-selectPreviousRowExtendSelection.text=將選區擴展到上一行
action.ListPersistentStateComponents.text=列出持久狀態元件
action.LoadAllContent.text=載入所有檔案內容
action.LoadAllVFSContent.text=載入所有 VFS 存儲的檔案內容
action.LoadDefaultYamlProfile.text=從 YAML 載入檢查組態檔案
action.LoadUnloadModules.text=載入/移除模組…
action.LogDebugConfigure.description=啟用或停用額外的日誌類別。允許通過請求向支援團隊提供更多資訊。
action.LogDebugConfigure.text=偵錯日誌設定(_E)…
action.LogFocusRequests.text=日誌焦點請求
action.LongBackgroundWriteAction.text=執行長時間背景寫入動作
action.MacMessagesTest.text=測試 Mac 訊息
action.MainMenuButton.ShowMenu.text=顯示折疊的主選單
action.MakeModule.description=編譯模組中的所有修改和相依檔案
action.MakeModule.text=建置模組(_M)
action.MakeStatic.description=將方法或內部類別轉換為 static 並更正所有參照
action.MakeStatic.text=設為 static(_T)…
action.ManageProjectTemplates.text=管理專案模板…
action.ManageRecentProjects.text=管理專案…
action.ManageSubscriptions.alias1=註冊
action.ManageSubscriptions.alias2=授權許可
action.ManageSubscriptions.alias3=授權
action.ManageSubscriptions.alias4=訂閱
action.ManageSubscriptions.alias5=訂閱
action.ManageSubscriptions.text=管理訂閱…
action.MarkAsContentRoot.description=取消所選目錄的排除，使其檔案可以被 IDE 的動作處理
action.MarkAsContentRoot.text=不排除
action.MarkExcludeRoot.text=已排除
action.MarkFileDirty.text=在 VCS 中將檔案標記為髒
action.MarkVfsCorrupted.text=將 VFS 標記為已損壞
action.MaximizeActiveDialog.text=最大化/還原活動對話框
action.MeetNewUIAction.text=組態新 UI
action.MemberPushDown.description=將類別成員向下推送到直接繼承子類別
action.MemberPushDown.text=向下推送成員(_S)…
action.MembersPullUp.description=將類別成員拉取至超類別或實作的接口
action.MembersPullUp.text=向上拉取成員(_L)…
action.MemoryView.EnableTrackingWithClosedWindow.text=啟用具有隱藏記憶體檢視的追蹤
action.MemoryView.JumpToTypeSource.text=跳轉到類型源
action.MemoryView.ShowAllocationStackTrace.text=跳轉到分配位置
action.MemoryView.ShowInstances.text=顯示執行個體
action.MemoryView.ShowNewInstances.text=顯示新執行個體
action.MemoryView.ShowOnlyTracked.text=僅顯示追蹤類別
action.MemoryView.ShowOnlyWithDiff.text=僅顯示非零差異
action.MemoryView.ShowOnlyWithInstances.text=僅顯示執行個體
action.MemoryView.SwitchUpdateMode.description=在偵錯器暫停時載入類別 (可能會增加偵錯器步進的開銷)
action.MemoryView.SwitchUpdateMode.text=在偵錯器停止時更新已載入的類別
action.MemoryView.TrackingAction.NewInstancesTracking.text=追蹤新執行個體
action.Merge3Files.text=合併
action.MergeAllWindowsAction.text=合併所有專案視窗
action.MergeMenuWithWindowTitleAction.text=將主選單與視窗標題合併…
action.MethodDown.description=在活動編輯器中導覽到下一個方法
action.MethodDown.text=下一個方法(_E)
action.MethodDuplicates.description=尋找所選作用域內可以轉換為所選方法/常數的呼叫的程式碼
action.MethodDuplicates.field.text=尋找欄位重複項並取代為參照…
action.MethodDuplicates.method.text=尋找方法重複項並取代為呼叫…
action.MethodDuplicates.text=尋找並取代程式碼重複項(_C)…
action.MethodHierarchy.BaseOnThisMethod.text=基於此方法
action.MethodHierarchy.ImplementMethodAction.description=實作方法(從方法層次結構)
action.MethodHierarchy.ImplementMethodAction.text=實作方法
action.MethodHierarchy.OverrideMethodAction.description=覆寫方法(從方法層次結構)
action.MethodHierarchy.OverrideMethodAction.text=覆寫方法
action.MethodHierarchy.description=瀏覽所選方法的方法層次結構
action.MethodHierarchy.text=方法層次結構(_M)
action.MethodOverloadSwitchDown.text=下一個方法多載
action.MethodOverloadSwitchUp.text=上一個方法多載
action.MethodUp.description=在活動編輯器中導覽到上一個方法
action.MethodUp.text=上一個方法(_I)
action.MinimizeCurrentWindow.description=最小化當前視窗
action.MinimizeCurrentWindow.text=最小化
action.ModuleSettings.description=為所選模組開啟設定對話框
action.ModuleSettings.navigate=開啟模組設定
action.ModuleSettings.text=模組設定(_S)
action.Move.description=將所選的類別、方法、軟體套件或 static 成員移動到另一個軟體套件或類別並更正所有參照
action.Move.text=移動(_M)…
action.MoveEditorToOppositeTabGroup.description=將編輯器移至相反的頁籤組
action.MoveEditorToOppositeTabGroup.text=移至相反的組(_M)
action.MoveElementLeft.description=將當前元素移至包含元素列表的上一個位置
action.MoveElementLeft.text=向左移動元素
action.MoveElementRight.description=將當前元素移至包含元素列表的下一個位置
action.MoveElementRight.text=向右移動元素
action.MoveFileToAnotherModule.text=將檔案移至另一個模組
action.MoveLineDown.description=將所選行向下移動一行
action.MoveLineDown.text=下移行(_W)
action.MoveLineUp.description=將所選行向上移動一行
action.MoveLineUp.text=上移行(_U)
action.MoveStatementDown.description=將所選語句向下移動一行
action.MoveStatementDown.text=向下移動語句(_W)
action.MoveStatementUp.description=將所選語句向上移動一行
action.MoveStatementUp.text=向上移動語句(_U)
action.MoveTabDown.description=將編輯器區域拆分為 2 個頁籤組，然後將當前頁籤移至底部組並關閉頂部編輯器
action.MoveTabDown.text=拆分並下移
action.MoveTabRight.description=將編輯器區域拆分為 2 個頁籤組，然後將當前頁籤移至右側組並關閉左側編輯器
action.MoveTabRight.text=拆分並右移
action.MoveToolWindowTabToEditorAction.description=作為編輯器頁籤開啟
action.MoveToolWindowTabToEditorAction.reverse.text=在工具視窗中還原
action.MoveToolWindowTabToEditorAction.text=作為編輯器頁籤開啟
action.MoveWindowBuiltinDisplayAction.description=將當前視窗移至內建螢幕
action.MoveWindowBuiltinDisplayAction.text=移至內建顯示屏
action.NavBarLocationBottom.description=在狀態列中顯示導覽列
action.NavBarLocationBottom.text=在狀態列中
action.NavBarLocationHide.description=隱藏導覽列
action.NavBarLocationHide.text=不顯示
action.NavBarLocationTop.description=在頂部顯示導覽列
action.NavBarLocationTop.text=頂部
action.NewClass.text=Java 類別
action.NewDatabaseProject.text=專案…
action.NewDir.GoToAction.text=建立新目錄或軟體套件
action.NewDir.text=目錄/軟體套件
action.NewDirectoryProject.cannot.create.dir=無法建立目錄 ''{0}''。
action.NewDirectoryProject.description=建立一個新項目
action.NewDirectoryProject.not.empty.dialog.create.new=從現有的源建立
action.NewDirectoryProject.not.empty.dialog.open.existing=開啟專案
action.NewDirectoryProject.not.empty.dialog.text=目錄 ''{0}'' 不為空。是否要從現有的原始碼建立專案?
action.NewDirectoryProject.not.empty.dialog.title=目錄不為空
action.NewDirectoryProject.text=新增專案…
action.NewDirectoryProject.title=建立專案
action.NewElement.ProjectView.text=新增檔案或目錄…
action.NewElement.description=建立新的類別、接口、檔案或目錄
action.NewElement.text=新增(_N)…
action.NewElementSamePlace.description=在此目錄中建立新的類別、接口、檔案或目錄
action.NewElementSamePlace.text=在當前目錄中新增(_N)…
action.NewFile.GoToAction.text=建立新檔案
action.NewFile.NewElementInProjectViewPopupEmptyTextLink.text=手動建立檔案
action.NewFile.description=建立一個新檔案
action.NewFile.text=檔案
action.NewHtmlFile.description=建立新的 HTML 檔案
action.NewHtmlFile.text=HTML 檔案
action.NewMigration.text=建立新遷移…
action.NewModule.description=從頭建立新模組並將其新增到專案
action.NewModule.text=模組(_M)…
action.NewModuleInGroup.text=模組
action.NewProject.ProjectWidgetPopup.text=新增專案…
action.NewProject.description=從頭建立一個新項目
action.NewProject.text=專案(_P)…
action.NewRubyMineDirectoryProject.ProjectWidgetPopup.text=新增專案…
action.NewRubyMineDirectoryProject.text=專案…
action.NewScratchBuffer.description=建立新的臨時緩衝區或重用現有的臨時緩衝區
action.NewScratchBuffer.text=新增臨時緩衝區
action.NewScratchFile.EditorPopup.text=建立新的臨時檔案
action.NewScratchFile.description=使用所選語言建立新的臨時檔案
action.NewScratchFile.text=臨時檔案
action.NewScratchFile.text.with.new=新增臨時檔案
action.NewSqlFile.description=建立新的 SQL 檔案
action.NewSqlFile.text=SQL 檔案
action.NewUiRunWidget.text=執行小工具
action.NextDiff.description=移至下一個差異
action.NextDiff.text=下一個差異
action.NextEditorTab.text=在多編輯器檔案中選擇下一個頁籤
action.NextInlineCompletionSuggestionAction.description=顯示下一個內聯補全提案
action.NextInlineCompletionSuggestionAction.text=下一個內聯提案
action.NextOccurence.description=導覽到下一個符合項
action.NextOccurence.text=下一個符合項(_X)
action.NextParameter.text=下一個參數
action.NextProjectWindow.description=切換到下一個專案視窗
action.NextProjectWindow.text=下一個專案視窗
action.NextSplitter.description=轉到下一個拆分視窗
action.NextSplitter.text=轉到下一個拆分器(_G)
action.NextTab.description=啟用下一個頁籤
action.NextTab.text=選擇下一個頁籤(_X)
action.NextTemplateParameter.text=下一個實時模板參數
action.NextTemplateVariable.text=下一個模板變數或完成就地重構
action.NextWindow.text=啟用下一個視窗
action.NotificationTestAction.text=新增測試通知
action.OnlineDocAction.description=顯示線上文檔
action.OnlineDocAction.text=入門指南(_G)
action.OpenBlankEditorInBlankDiffWindow.text=切換到空白編輯器
action.OpenBookmarkGroup.text=開啟所有已新增書籤的檔案
action.OpenEditorInOppositeTabGroup.description=在相反的頁籤組中開啟此編輯器的副本
action.OpenEditorInOppositeTabGroup.text=在相反的組中開啟(_O)
action.OpenElementInNewWindow.text=在新編輯器視窗中開啟
action.OpenEventsSchemeFileAction.description=開啟 IDE 事件日誌的方案
action.OpenEventsSchemeFileAction.text=開啟方案檔案
action.OpenEventsTestSchemeFileAction.description=開啟 IDE 事件日誌的測試方案
action.OpenEventsTestSchemeFileAction.text=開啟測試方案檔案
action.OpenFile.description=在編輯器中開啟專案或檔案
action.OpenFile.text=開啟(_O)…
action.OpenFileEditorInBlankDiffWindow.text=切換到檔案…
action.OpenInAssociatedApplication.description=在關聯的應用程式中開啟
action.OpenInAssociatedApplication.text=在關聯的應用程式中開啟
action.OpenInBrowser.description=在預設瀏覽器中開啟所選檔案
action.OpenInBrowser.text=在預設瀏覽器中開啟(_B)
action.OpenInRightSplit.description=將編輯器區域拆分為 2 個頁籤組，然後將當前檔案開啟到右側組
action.OpenInRightSplit.text=在右側拆分部分開啟
action.OpenLog.Show.text=在編輯器中顯示登入
action.OpenLog.text=在編輯器中開啟日誌
action.OpenModuleSettings.text=模組設定
action.OpenMouseWheelSmoothScrollSettings.text=平滑滾動選項
action.OpenStatisticsEventLogAction.description=開啟包含統計事件日誌的工具視窗
action.OpenStatisticsEventLogAction.text=開啟統計事件日誌
action.OptimizeImports.description=移除未使用的 import 並重新排列/重新組織 import
action.OptimizeImports.text=最佳化 import(_Z)
action.OverrideFileTypeAction.description=將當前檔案視為不同檔案類型的檔案
action.OverrideFileTypeAction.text=覆寫檔案類型
action.OverrideFileTypeAction.verbose.description=將檔案 ''{0}''{1,choice,0#|1# (和其他 {1} 個檔案)}視為不同檔案類型的檔案
action.OverrideMethods.description=在當前類別中覆寫基類別方法
action.OverrideMethods.text=覆寫方法(_O)…
action.PaintEditorLineStripeComponentAction.text=繪製編輯器文字游標條紋
action.ParameterInfo.description=顯示文字游標處方法的參數
action.ParameterInfo.text=參數資訊(_P)
action.PasteMultiple.description=從最近的剪貼簿貼上
action.PasteMultiple.text=從歷史記錄貼上(_E)…
action.Pause.description=掛起程序執行並啟用偵錯
action.Pause.text=暫停程序(_P)
action.PauseScanningAndIndexing.text=暫停掃描和索引
action.PerformGC.text=執行垃圾回收
action.Performance.ActivityMonitor.description=用於檢查哪些延伸模組和子系統使用了最多資源的工具
action.Performance.ActivityMonitor.text=活動監視器…
action.Performance.DumpThreads.text=傾印執行緒
action.Performance.MemTester.text=執行記憶體測試程序…
action.PinActiveEditorTab.description=固定活動編輯器頁籤
action.PinActiveEditorTab.text=固定活動頁籤(_I)
action.PinActiveTab.description=固定活動編輯器或工具視窗頁籤
action.PinActiveTab.text=固定活動頁籤(_I)
action.PinActiveTabToggle.description=固定活動編輯器或工具視窗頁籤
action.PinActiveTabToggle.text=固定活動頁籤
action.PinToolwindowTab.description=固定活動工具視窗頁籤
action.PinToolwindowTab.text=固定活動工具視窗頁籤(_I)
action.PlaySavedMacrosAction.description=播放儲存的巨集
action.PlaySavedMacrosAction.text=播放儲存的巨集…
action.PlaybackLastMacro.description=播放上次使用的巨集
action.PlaybackLastMacro.text=回放上一個巨集(_Y)
action.PluginManagerFiltersConfigureResetTrustDebugAction.text=Org 延伸模組篩選器: 重設
action.PluginManagerFiltersConfigureTrustOnlyJetBrainsDebugAction.text=Org 延伸模組篩選器: 僅信任 JetBrains
action.PopupHector.description=顯示面板來為當前檔案組態醒目提示模式
action.PopupHector.text=組態當前檔案分析…
action.PopupMenu-cancel.description=關閉右鍵選單。
action.PopupMenu-cancel.text=關閉右鍵選單
action.PopupMenu-return.description=開啟子選單或從所選選單項中呼叫動作
action.PopupMenu-return.text=呼叫選定動作
action.PopupMenu-selectChild.description=開啟子選單並在其中選擇相應的選單項
action.PopupMenu-selectChild.text=選擇子選單項
action.PopupMenu-selectNext.description=選擇下一個選單項
action.PopupMenu-selectNext.text=選擇下一個選單項
action.PopupMenu-selectParent.description=關閉子選單並在父選單中選擇相應的選單項
action.PopupMenu-selectParent.text=選擇父選單項
action.PopupMenu-selectPrevious.description=選擇上一個選單項
action.PopupMenu-selectPrevious.text=選擇上一個選單項
action.PositionTrackerTestAction.text=測試位置追蹤器
action.PrevInlineCompletionSuggestionAction.description=顯示上一個內聯補全提案
action.PrevInlineCompletionSuggestionAction.text=上一個內聯提案
action.PrevParameter.text=上一個參數
action.PrevSplitter.description=轉到上一個拆分視窗
action.PrevSplitter.text=轉到上一個拆分器
action.PrevTemplateParameter.text=上一個實時模板參數
action.PreviousDiff.description=移至上一個差異
action.PreviousDiff.text=上一個差異
action.PreviousEditorTab.text=在多編輯器檔案中選擇上一個頁籤
action.PreviousOccurence.description=導覽到上一個符合項
action.PreviousOccurence.text=上一個符合項(_O)
action.PreviousProjectWindow.description=切換到上一個專案視窗
action.PreviousProjectWindow.text=上一個專案視窗
action.PreviousTab.description=啟用上一個頁籤
action.PreviousTab.text=選擇上一個頁籤(_L)
action.PreviousTemplateVariable.text=上一個模板變數
action.PreviousWindow.text=啟用上一個視窗
action.Print.description=列印檔案
action.Print.text=列印(_P)…
action.ProblemsView.AutoscrollToSource.description=為所選檔案開啟編輯器，並在選區更改後導覽到所選問題
action.ProblemsView.AutoscrollToSource.text=一鍵開啟檔案
action.ProblemsView.CopyProblemDescription.description=將問題描述複製到剪貼簿
action.ProblemsView.CopyProblemDescription.text=複製問題描述
action.ProblemsView.GroupByToolId.description=允許通過檢查對問題進行分組
action.ProblemsView.GroupByToolId.text=按檢查分組
action.ProblemsView.OpenInPreviewTab.text=啟用預覽頁籤
action.ProblemsView.QuickFixes.description=顯示所選問題的可用快速修復
action.ProblemsView.QuickFixes.text=顯示快速修復
action.ProblemsView.ShowPreview.description=點擊所選問題以開啟其預覽
action.ProblemsView.ShowPreview.text=開啟編輯器預覽
action.ProblemsView.SortByName.description=允許按名稱對問題進行排序
action.ProblemsView.SortByName.text=名稱
action.ProblemsView.SortBySeverity.description=允許按嚴重性對問題進行排序
action.ProblemsView.SortBySeverity.text=嚴重性
action.ProblemsView.SortFoldersFirst.description=單獨對檔案和目錄排序
action.ProblemsView.SortFoldersFirst.text=目錄總在最前面
action.ProductivityGuide.description=顯示生產力功能使用情況統計資訊
action.ProductivityGuide.text=我的工作效率(_P)
action.ProgressIconShowcaseAction.text=進度圖示展示
action.ProjectFromVersionControl.ProjectWidgetPopup.text=克隆儲存庫…
action.ProjectFromVersionControl.text=來自版本控制的專案…
action.ProjectView.AbbreviatePackageNames.description=以縮寫形式顯示合格的軟體套件名稱
action.ProjectView.AbbreviatePackageNames.text=縮寫限定名稱
action.ProjectView.AutoscrollFromSource.description=選擇編輯器頁籤後，在“專案”檢視中選擇相應的檔案
action.ProjectView.AutoscrollFromSource.text=始終選擇開啟的檔案
action.ProjectView.AutoscrollToSource.description=選擇檔案後，將其開啟進行編輯
action.ProjectView.AutoscrollToSource.text=一鍵開啟檔案
action.ProjectView.CompactDirectories.description=如果第一個目錄僅包含第二個目錄，則將兩個相似的目錄合併到單個節點
action.ProjectView.CompactDirectories.text=壓縮目錄
action.ProjectView.CustomizeTrees.text=自訂樹檢視…
action.ProjectView.FileNesting.description=組態檔案嵌套
action.ProjectView.FileNesting.text=檔案嵌套…
action.ProjectView.FlattenModules.description=以簡單列表顯示模組
action.ProjectView.FlattenModules.text=平展模組
action.ProjectView.FlattenPackages.description=以簡單列表顯示包
action.ProjectView.FlattenPackages.text=平展軟體套件
action.ProjectView.FoldersAlwaysOnTop.description=單獨對檔案和目錄排序
action.ProjectView.FoldersAlwaysOnTop.text=目錄總在最前
action.ProjectView.HideEmptyMiddlePackages.description=隱藏空的中間軟體套件
action.ProjectView.HideEmptyMiddlePackages.text=隱藏空的中間軟體套件
action.ProjectView.ManualOrder.description=手動對檔案排序
action.ProjectView.ManualOrder.text=手動排序
action.ProjectView.OpenDirectoriesWithSingleClick.text=一鍵開啟目錄
action.ProjectView.OpenInPreviewTab.text=啟用預覽頁籤
action.ProjectView.ShowExcludedFiles.ToolwindowPopup.text=排除的檔案
action.ProjectView.ShowExcludedFiles.description=顯示排除的檔案
action.ProjectView.ShowExcludedFiles.text=顯示排除的檔案
action.ProjectView.ShowLibraryContents.ToolwindowPopup.text=庫內容
action.ProjectView.ShowLibraryContents.description=顯示庫內容
action.ProjectView.ShowLibraryContents.text=顯示庫內容
action.ProjectView.ShowMembers.ToolwindowPopup.text=成員
action.ProjectView.ShowMembers.description=顯示類別成員
action.ProjectView.ShowMembers.text=顯示成員
action.ProjectView.ShowModules.ToolwindowPopup.text=模組
action.ProjectView.ShowModules.description=顯示相應根的模組名稱
action.ProjectView.ShowModules.text=顯示模組
action.ProjectView.ShowScratchesAndConsoles.ToolwindowPopup.text=臨時檔案和主控台
action.ProjectView.ShowScratchesAndConsoles.description=顯示臨時檔案和主控台
action.ProjectView.ShowScratchesAndConsoles.text=顯示臨時檔案和主控台
action.ProjectView.ShowVisibilityIcons.ToolwindowPopup.text=可見性圖示
action.ProjectView.ShowVisibilityIcons.description=在元素名稱前顯示元素可見性圖示
action.ProjectView.ShowVisibilityIcons.text=顯示可見性圖示
action.ProjectView.SortByName.ToolwindowPopup.text=名稱
action.ProjectView.SortByName.description=按檔名對檔案進行排序
action.ProjectView.SortByName.text=按名稱排序
action.ProjectView.SortByTimeAscending.ToolwindowPopup.text=修改時間(從舊到新)
action.ProjectView.SortByTimeAscending.description=按最後修改時間對檔案進行排序，從舊到新
action.ProjectView.SortByTimeAscending.text=按修改時間排序(從舊到新)
action.ProjectView.SortByTimeDescending.ToolwindowPopup.text=修改時間(從新到舊)
action.ProjectView.SortByTimeDescending.description=按最後修改時間對檔案進行排序，從新到舊
action.ProjectView.SortByTimeDescending.text=按修改時間排序(從新到舊)
action.ProjectView.SortByType.ToolwindowPopup.text=類型
action.ProjectView.SortByType.description=單獨對不同類型的檔案排序
action.ProjectView.SortByType.text=按類型排序
action.ProjectViewEditSource.text=編輯源
action.ProjectViewExpandAll.text=全部展開
action.PruneEmptyDirectories.text=刪除空目錄
action.QuickActionPopup.text=顯示快速動作彈出視窗
action.QuickChangeScheme.description=更改當前的程式碼樣式方案、顏色與字體方案、按鍵映射或外觀
action.QuickChangeScheme.text=快速切換方案(_Q)…
action.QuickDocCopy.text=複製快速文檔
action.QuickImplementations.description=顯示包含符號(及其實作)內容的彈出視窗
action.QuickImplementations.text=快速定義(_K)
action.QuickJavaDoc.description=顯示包含文字游標處符號的文檔的彈出視窗
action.QuickJavaDoc.text=快速文檔(_D)
action.QuickPreview.text=快速預覽
action.QuickTypeDefinition.description=顯示包含文字游標處符號的類型定義的彈出視窗
action.QuickTypeDefinition.text=快速類型定義
action.RearrangeCode.description=重新排列程式碼
action.RearrangeCode.text=重新排列程式碼
action.RecentChangedFiles.description=顯示最近更改的檔案的列表
action.RecentChangedFiles.text=最近更改的檔案
action.RecentChangedFilesFallback.description=顯示最近更改的檔案的列表
action.RecentChangedFilesFallback.text=最近更改的檔案
action.RecentFiles.description=顯示最近檢視的檔案的列表
action.RecentFiles.text=最近的檔案(_N)
action.RecentFilesFallback.description=顯示最近檢視的檔案的列表
action.RecentFilesFallback.text=最近的檔案(_N)
action.RecentLocations.description=顯示最近檢視/更改的位置的列表
action.RecentLocations.text=最近的位置
action.RecordStateCollectors.description=將所有狀態收集器和記錄結果呼叫到事件日誌
action.RecordStateCollectors.text=將狀態收集器記錄到事件日誌
action.RedesignedRunConfigurationSelector.text=選擇執行/偵錯組態
action.Refactorings.QuickListPopupAction.description=包含重構動作列表的上下文感知彈出視窗
action.Refactorings.QuickListPopupAction.text=重構…
action.ReformatCode.description=重新設定程式碼格式
action.ReformatCode.synonym1=設定程式碼格式
action.ReformatCode.text=重新設定程式碼格式(_R)
action.Refresh.text=重新整理(_E)
action.Register.description=輸入註冊資料
action.Register.text=註冊(_R)…
action.ReloadProjectAction.text=重新載入專案
action.RemoveBom.text=移除 BOM
action.RemoveFromScopeAction.text=從作用域中移除
action.RemoveStripeButton.description=從側邊列移除工具視窗按鈕
action.RemoveStripeButton.text=從側邊列中移除
action.RenameAction.text=重新命名…
action.RenameElement.description=重新命名所選符號並更正所有參照
action.RenameElement.text=重新命名(_R)…
action.RenameFile.description=重新命名所選檔案
action.RenameFile.text=重新命名檔案…
action.ReopenClosedTab.text=重新開啟關閉的頁籤
action.RepairDebuggerViewAction.description=嘗試將偵錯器檢視修復到可信狀態
action.RepairDebuggerViewAction.text=修復偵錯器檢視
action.Replace.description=將活動編輯器中的字串取代為另一個字串
action.Replace.text=取代(_R)…
action.ReplaceInPath.description=在多個檔案中使用另一個字串取代一個字串
action.ReplaceInPath.synonym1=在路徑中取代(_A)
action.ReplaceInPath.text=在檔案中取代(_A)…
action.ReplaceMethodWithMethodObject.description=將方法轉換為自己的物件，以便所有參數都成為該物件上的欄位
action.ReplaceMethodWithMethodObject.text=將方法取代為方法物件(_J)…
action.ReportProblem.description=在 JetBrains 問題追蹤器中提交錯誤報告
action.ReportProblem.text=提交 bug 報告…
action.ReportSettingsToFUS.text=將更改的設定記錄到事件日誌
action.RequestCachesDefragmentation.text=請求 VFS 和索引碎片整理
action.Rerun.text=重新執行
action.RerunFailedTests.description=僅執行上次執行後失敗/崩潰的測試；按 Shift 鍵選擇“執行/偵錯”模式
action.RerunFailedTests.text=重新執行失敗的測試
action.RerunTests.text=重新執行測試
action.ResetFilterAction.text=重設篩選器
action.ResetGotItTooltips.text=重設“知道了”工具提示
action.ResetIdeScaleAction.text=重設 IDE 比例
action.ResetWindowsDefenderNotification.text=重設 Microsoft Defender 通知
action.ResizeToolWindowDown.description=將活動工具視窗延伸至底部
action.ResizeToolWindowDown.text=延伸至底部
action.ResizeToolWindowLeft.description=將活動工具視窗延伸至左側
action.ResizeToolWindowLeft.text=延伸至左側
action.ResizeToolWindowMaximize.text=最大化工具視窗
action.ResizeToolWindowMaximize.text.alternative=還原工具視窗大小
action.ResizeToolWindowRight.description=將活動工具視窗延伸至右側
action.ResizeToolWindowRight.text=延伸至右側
action.ResizeToolWindowUp.description=將活動工具視窗延伸至頂部
action.ResizeToolWindowUp.text=延伸至頂部
action.RestartIde.text=重啟 IDE…
action.RestoreDefaultExtensionScripts.description=重設此目錄的捆綁擴展
action.RestoreDefaultExtensionScripts.text=重設預設擴展
action.RestoreDefaultLayout.description=恢復當前所選布局
action.RestoreDefaultLayout.named.description=恢復當前所選布局(“{0}”)
action.RestoreDefaultLayout.text=恢復當前布局(_R)
action.RestoreDefaultSettings.description=將所有設定重設為其預設值
action.RestoreDefaultSettings.text=恢復預設設定…
action.RestoreFactoryDefaultLayout.description=將工具視窗布局重設為出廠預設設定
action.RestoreFactoryDefaultLayout.text=預設
action.RestoreFontPreviewTextAction.text=還原預覽文本
action.RestoreNamedLayout.description=還原布局“{0}”
action.RestoreProtocolHandler.text=註冊 Gateway 協議
action.RestoreShelvedChange.text=還原
action.Resume.description=恢復程序執行
action.Resume.text=恢復程序(_G)
action.RetypeFile.text=重新輸入當前檔案
action.RevealIn.description=在作業系統檔案管理器中醒目提示檔案
action.RevealIn.name.mac=在“訪達”中顯示
action.RevealIn.name.other=在 {0} 中顯示
action.RevealIn.text=在檔案管理器中顯示
action.ReverteOverrideFileTypeAction.description=撤消“覆寫檔案類型”動作並還原舊檔案類型
action.ReverteOverrideFileTypeAction.text=還原檔案類型覆寫
action.ReverteOverrideFileTypeAction.verbose.description=撤消“覆寫檔案類型”動作並為檔案 ''{0}''{1,choice,0#|1# (和其他 {1} 個檔案)}還原舊的檔案類型
action.RubyMineDemos.description=檢視介紹 RubyMine 功能的簡短現場示範
action.RubyMineDemos.text=示範和教程
action.RubyMineDeveloperCommunity.description=RubyMine 開發者社群論壇
action.RubyMineDeveloperCommunity.text=開發者社群
action.RubyMineProjectFromVersionControlAction.ProjectWidgetPopup.text=克隆儲存庫…
action.RubyMineProjectFromVersionControlAction.text=來自版本控制的專案…
action.RulerGuide.text=標尺參考線
action.RunAnything.description=允許執行任何指令
action.RunAnything.text=執行任何內容
action.RunConfiguration.description=選擇執行/偵錯組態
action.RunConfiguration.text=選擇執行/偵錯組態
action.RunConfigurationTemplatesForNewProjects.MainMenu.text=執行組態模板…
action.RunDashboard.AddConfiguration.text=執行組態…
action.RunDashboard.ClearConsole.text=清除主控台
action.RunDashboard.ClearContent.text=清除內容
action.RunDashboard.CopyConfiguration.text=複製組態
action.RunDashboard.Debug.text=偵錯
action.RunDashboard.DoubleClickRun.text=雙擊以執行組態
action.RunDashboard.EditConfiguration.text=編輯所選組態
action.RunDashboard.GroupByStatus.text=狀態
action.RunDashboard.GroupByType.text=類型
action.RunDashboard.GroupConfigurations.text=分組組態
action.RunDashboard.HideConfiguration.text=隱藏組態
action.RunDashboard.OpenRunningConfigInNewTab.text=在新頁籤中開啟執行組態
action.RunDashboard.RemoveType.text=從服務中移除組態類型
action.RunDashboard.RestoreConfiguration.text=還原組態
action.RunDashboard.RestoreHiddenConfigurations.text=還原隱藏的組態
action.RunDashboard.Run.text=執行
action.RunDashboard.Stop.text=停止
action.RunDashboard.UngroupConfigurations.text=對組態取消分組
action.RunToCursor.description=跳轉到文字游標所在的行
action.RunToCursor.text=執行到游標處(_C)
action.RunToolbarEditConfigurationAction.text=編輯組態…
action.RunToolbarMainMultipleStopAction.text=停止
action.RunToolbarMainRunConfigurationsAction.text=新增組態…
action.RunToolbarMainSlotActive.text=有效程序
action.RunToolbarMainSlotInfoAction.text=有效程序
action.RunToolbarMoveToTopAction.text=將組態移至頂部
action.RunToolbarPauseAction.text=暫停
action.RunToolbarProcessStartedAction.text=有效程序
action.RunToolbarRemoveSlotAction.terminating=正在終止
action.RunToolbarRemoveSlotAction.text=移除
action.RunToolbarRerunAction.text=重新執行
action.RunToolbarResumeAction.text=恢復
action.RunToolbarRollbackToPrevious.text=復原到上一個工具列
action.RunToolbarRunConfigurationsAction.text=新增組態…
action.RunToolbarShowHidePopupAction.click.to.open.combo.text=點擊以選擇執行組態
action.RunToolbarShowHidePopupAction.click.to.open.toolwindow.text=點擊以開啟“程序”工具視窗
action.RunToolbarShowHidePopupAction.click.to.show.popup.text=點擊以顯示或隱藏停靠的組態
action.RunToolbarShowHidePopupAction.show.popup.text=顯示或隱藏停靠的組態
action.RunToolbarShowHidePopupAction.text=同時啟動多個組態
action.RunToolbarShowToolWindowTab.text=顯示“程序”工具視窗
action.RunToolbarStopAction.text=停止
action.RunToolbarWidgetAction.text=執行/偵錯小工具
action.Runner.CloseAllUnpinnedViews.description=關閉所有未固定的頁籤
action.Runner.CloseAllUnpinnedViews.text=關閉所有未固定的
action.Runner.CloseAllViews.description=關閉所有檢視
action.Runner.CloseAllViews.text=關閉所有
action.Runner.CloseOtherViews.description=關閉其他檢視
action.Runner.CloseOtherViews.text=關閉其他
action.Runner.CloseView.description=關閉檢視
action.Runner.CloseView.text=關閉
action.Runner.FocusOnStartup.description=當 UI 顯示時預設將此檢視設為焦點
action.Runner.FocusOnStartup.text=在啟動時獲取焦點
action.Runner.RestoreLayout.description=將偵錯器會話的可視元素還原為預設狀態
action.Runner.RestoreLayout.text=恢復預設布局
action.Runner.ToggleTabLabels.text=顯示頁籤標籤
action.SafeDelete.description=刪除所選的類別、方法或欄位，檢查用法
action.SafeDelete.text=安全刪除(_D)…
action.SaveAll.description=儲存所有檔案和設定
action.SaveAll.text=全部儲存(_S)
action.SaveAs.text=另存為…
action.SaveAsNewFormat.text=另存為基於目錄的格式…
action.SaveAsTemplate.description=將所選文本儲存為實時模板
action.SaveAsTemplate.text=儲存為實時模板(_I)…
action.SaveDocument.description=只儲存在當前編輯器中開啟的檔案
action.SaveDocument.text=儲存文檔
action.SaveFileAsTemplate.description=將當前檔案另存為模板
action.SaveFileAsTemplate.text=將檔案另存為模板(_L)…
action.SaveProjectAsTemplate.text=將專案另存為模板…
action.SaveTemporaryRunConfiguration.description=儲存臨時執行組態
action.SaveTemporaryRunConfiguration.text=儲存組態
action.ScanSourceCommentsAction.text=傾印專案中的所有註釋
action.ScopeView.EditScopes.description=編輯作用域…
action.ScopeView.EditScopes.text=編輯作用域(_I)…
action.Scratch.ChangeLanguage.description=更改臨時檔案語言
action.Scratch.ChangeLanguage.text=更改檔案語言
action.Scratch.ExportToScratch.description=作為文本匯出到新的臨時檔案
action.Scratch.ExportToScratch.text=匯出到臨時檔案
action.Scratch.ShowFilesPopup.description=在彈出視窗中顯示臨時檔案
action.Scratch.ShowFilesPopup.text=顯示臨時檔案
action.ScrollPane-scrollDown.description=將周圍的可滾動區域向下滾動一頁
action.ScrollPane-scrollDown.text=向下滾動頁面
action.ScrollPane-scrollEnd.description=將周圍的可滾動區域滾動到底部
action.ScrollPane-scrollEnd.text=滾動至頁尾
action.ScrollPane-scrollHome.description=將周圍的可滾動區域滾動到頂部
action.ScrollPane-scrollHome.text=滾動至頁首
action.ScrollPane-scrollLeft.description=將周圍的可滾動區域向左滾動一頁
action.ScrollPane-scrollLeft.text=向左滾動頁面
action.ScrollPane-scrollRight.description=將周圍的可滾動區域向右滾動一頁
action.ScrollPane-scrollRight.text=向右滾動頁面
action.ScrollPane-scrollUp.description=將周圍的可滾動區域向上滾動一頁
action.ScrollPane-scrollUp.text=向上滾動頁面
action.ScrollPane-unitScrollDown.description=將周圍的可滾動區域向下滾動一個單位
action.ScrollPane-unitScrollDown.text=向下滾動
action.ScrollPane-unitScrollLeft.description=將周圍的可滾動區域向左滾動一個單位
action.ScrollPane-unitScrollLeft.text=向左滾動
action.ScrollPane-unitScrollRight.description=將周圍的可滾動區域向右滾動一個單位
action.ScrollPane-unitScrollRight.text=向右滾動
action.ScrollPane-unitScrollUp.description=將周圍的可滾動區域向上滾動一個單位
action.ScrollPane-unitScrollUp.text=向上滾動
action.ScrollTreeToCenter.text=滾動到中心
action.SearchEverywhere.CompleteCommand.description=在“隨處搜尋”對話框中自動補全指令
action.SearchEverywhere.CompleteCommand.text=補全指令
action.SearchEverywhere.NavigateToNextGroup.description=在“隨處搜尋”對話框中導覽到下一個組
action.SearchEverywhere.NavigateToNextGroup.text=下一個組元素
action.SearchEverywhere.NavigateToPrevGroup.description=在“隨處搜尋”對話框中導覽到上一個組
action.SearchEverywhere.NavigateToPrevGroup.text=上一個組元素
action.SearchEverywhere.NextTab.description=在“隨處搜尋”對話框中切換到下一個頁籤
action.SearchEverywhere.NextTab.text=下一個頁籤
action.SearchEverywhere.PrevTab.description=在“隨處搜尋”對話框中切換到上一個頁籤
action.SearchEverywhere.PrevTab.text=上一個頁籤
action.SearchEverywhere.SelectItem.description=在“隨處搜尋”對話框中選擇一個條目
action.SearchEverywhere.SelectItem.text=選擇條目
action.SearchEverywhere.description=搜尋類別、檔案、工具視窗、動作和偏好設定
action.SearchEverywhere.text=隨處搜尋
action.SearchEverywhereNewToolbarAction.text=隨處搜尋
action.SearchEverywhereToolbar.searching.text=正在搜尋…
action.SearchEverywhereToolbar.text=隨處搜尋
action.SearchEverywhereToolbarHotKey.hotkey=Shift+Shift
action.SearchEverywhereToolbarHotKey.text=隨處搜尋 {0}
action.SegmentedButton-left.text=選擇上一個分段按鈕
action.SegmentedButton-right.text=選擇下一個分段按鈕
action.SegmentedVcsControlAction.text=VCS 小工具
action.SelectAllOccurrences.description=通過將當前單詞的所有符合項新增到選區來設定多個游標。
action.SelectAllOccurrences.text=選擇所有符合項
action.SelectAndDumpInvalidTipsOfTheDay.text=選擇並傾印無效的每日小技巧
action.SelectAndShowTip.text=選擇並顯示提示(_S)
action.SelectIn.description=在任意檢視下選擇當前的類別或方法
action.SelectIn.text=選擇位置(_L)…
action.SelectInProjectView.description=在專案檢視中選擇上下文檔案
action.SelectInProjectView.directory.text=在專案檢視中選擇目錄
action.SelectInProjectView.text=在專案檢視中選擇檔案
action.SelectNextOccurrence.description=通過將當前單詞的下一個符合項新增到選區來設定多個游標。
action.SelectNextOccurrence.text=將下一個符合項新增到選擇
action.SelectOpenedFileInProjectView.description=在專案檢視中選擇已開啟的檔案
action.SelectOpenedFileInProjectView.text=選擇開啟的檔案
action.SelectVirtualTemplateElement.text=顯示用於就地重構的選項彈出視窗
action.SendEOF.text=發送 EOF
action.SendEventLogStatistics.description=將事件日誌檔案發送到 QA 伺服器
action.SendEventLogStatistics.text=將功能使用事件日誌發送到生產環境
action.SendFeedback.detailed.description=提交意見反應給 {0}
action.SendFeedback.text=提交意見反應(_F)…
action.ServiceView.ConfigureServices.text=組態服務工具視窗
action.ServiceView.GroupByContributor.text=按類型對服務分組
action.ServiceView.JumpToServices.text=跳轉到服務
action.ServiceView.OpenEachInNewTab.text=在新頁籤中開啟每個項
action.ServiceView.OpenInNewTab.text=在新頁籤中開啟
action.ServiceView.OpenInToolWindow.text=在單獨的工具視窗中開啟
action.ServiceView.SelectActiveService.text=始終選擇有效服務
action.ServiceView.ShowServices.text=顯示服務樹
action.ServiceView.SplitByType.text=在新頁籤中開啟每個類型
action.SetCaretVisualAttributesInternalAction.text=設定文字游標視覺特性…
action.SetShortcutAction.text=新增快捷鍵…
action.SettingsEditor.SaveChanges.text=儲存更改
action.SettingsEditor.ToggleSidebar.text=切換側邊列
action.SeverityEditorDialogAction.text=顯示嚴重性編輯器
action.ShelveChanges.UnshelveWithDialog.description=更正套用更新檔的路徑並取消擱置
action.ShelveChanges.UnshelveWithDialog.text=取消擱置…
action.ShelvedChanges.Rename.description=重新命名擱置的更改列表
action.ShelvedChanges.Rename.text=重新命名…
action.ShelvedChanges.Restore.text=還原已套用的擱置更改
action.ShelvedChanges.ShowHideDeleted.description=顯示/隱藏已取消擱置更改
action.ShelvedChanges.ShowHideDeleted.text=顯示/隱藏已套用的擱置更改
action.Show.Current.Revision.text=顯示當前修訂
action.ShowBackwardPackageDeps.MainMenu.text=向後相依關係(_B)…
action.ShowBackwardPackageDeps.description=瀏覽使用的程式碼所選分析條目
action.ShowBackwardPackageDeps.text=分析向後相依關係(_B)…
action.ShowBlankDiffWindow.description=並排開啟兩個編輯器並比較他們的內容
action.ShowBlankDiffWindow.synonym1=開啟空的差異視窗
action.ShowBlankDiffWindow.synonym2=開啟新的差異視窗
action.ShowBlankDiffWindow.text=開啟空白差異視窗
action.ShowBookmarks.text=顯示書籤…
action.ShowBundleLocalizationDialogAction.text=顯示捆綁包訊息
action.ShowChangedStateStatisticsAction.description=呼叫所有狀態收集器，並僅顯示自上一個記錄以來已更改的事件
action.ShowChangedStateStatisticsAction.text=僅顯示已更改的狀態事件
action.ShowColorPicker.text=顯示取色器
action.ShowCompressibleToolbarAction.text=顯示動態壓縮工具列
action.ShowContent.description=顯示一個包含工具視窗頁籤列表的彈出視窗
action.ShowContent.text=顯示頁籤列表
action.ShowContent.views.text=顯示檢視列表
action.ShowControlFlowAction.text=顯示控制流
action.ShowDependenciesOnTarget.MainMenu.text=指定目標上的相依項
action.ShowDependenciesOnTarget.text=分析指定目標上的相依項
action.ShowDetailedInformationAction.text=顯示間接相依項
action.ShowDiscoveredTests.text=顯示受影響的測試
action.ShowEditorHighlighterTokens.text=顯示編輯器螢光筆令牌
action.ShowEdtUtilizationChart.description=啟用對寫入、讀取和寫入意圖鎖下的 EDT 使用情況的監測
action.ShowEdtUtilizationChart.text=顯示 EDT 使用情況圖表
action.ShowErrorDescription.description=在文字游標處顯示錯誤或警告的描述
action.ShowErrorDescription.text=錯誤描述(_R)
action.ShowExecutionPoint.description=顯示當前程序執行點
action.ShowExecutionPoint.text=顯示執行點(_X)
action.ShowExperiments.text=實驗性功能…
action.ShowFilePath.description=顯示帶有當前檔案路徑的彈出視窗，以便在外部檔案管理器中開啟
action.ShowFilePath.popup=路徑彈出視窗(_P)
action.ShowFilePath.text=檔案路徑(_P)
action.ShowFontsUsedByEditor.description=允許找出編輯器中實際使用的回退字體
action.ShowFontsUsedByEditor.text=顯示編輯器使用的字體
action.ShowGotItDemo.text=顯示 GotIt 示範
action.ShowGutterIconsSettings.description=顯示用於組態裝訂區域圖示的對話框
action.ShowGutterIconsSettings.text=組態裝訂區域圖示…
action.ShowHideDebugInfoInUi.text=UI 中的偵錯資訊
action.ShowHoverInfo.description=在文字游標處顯示帶有符號文檔以及錯誤或警告描述的工具提示
action.ShowHoverInfo.text=懸停資訊
action.ShowInlineBanner.text=顯示內聯橫幅
action.ShowInlineCompletionStatistics.text=顯示內聯補全統計資訊
action.ShowIntentionActions.text=顯示上下文動作
action.ShowLiveRunConfigurations.description=顯示當前正在執行的執行組態列表
action.ShowLiveRunConfigurations.text=顯示正在執行的列表
action.ShowLog.Explorer.text=在資源管理器中顯示日誌(_L)
action.ShowLog.Finder.text=在“訪達”中顯示日誌(_L)
action.ShowLog.description=開啟包含日誌檔案的目錄
action.ShowLog.text=在檔案管理器中顯示日誌(_L)
action.ShowMainMenu.text=顯示主選單
action.ShowMembersInNavigationBar.description=在導覽列中顯示/隱藏宣告
action.ShowMembersInNavigationBar.text=顯示成員
action.ShowModulesDependencies.MainMenu.text=模組相依項(_M)…
action.ShowModulesDependencies.description=顯示專案中模組之間的相依關係
action.ShowModulesDependencies.text=分析模組相依關係(_M)…
action.ShowNonRetinaImages.text=顯示非 Retina 圖片
action.ShowNotificationIconsDialogAction.text=測試通知圖示
action.ShowPackageCycles.MainMenu.text=迴圈相依關係(_C)…
action.ShowPackageCycles.description=瀏覽迴圈中使用的程式碼所選分析條目
action.ShowPackageCycles.text=分析迴圈相依關係(_C)…
action.ShowPackageDeps.MainMenu.text=相依項(_D)…
action.ShowPackageDeps.description=瀏覽所選分析項所相依的程式碼
action.ShowPackageDeps.text=分析相依關係(_D)…
action.ShowParameterHintsSettings.description=開啟參數名稱提示設定
action.ShowParameterHintsSettings.text=提示設定…
action.ShowPopupMenu.text=顯示右鍵選單
action.ShowProcessWindow.description=顯示/隱藏背景任務視窗
action.ShowProcessWindow.double.click=點擊以顯示/隱藏背景任務視窗
action.ShowProcessWindow.text=顯示
action.ShowProgressTestDialogAction.text=測試進度指示器
action.ShowProjectStructureSettings.description=組態專案結構
action.ShowProjectStructureSettings.text=專案結構…
action.ShowRecentTests.text=最近的測試
action.ShowReformatFileDialog.text=重新設定檔案格式…
action.ShowRegistry.text=註冊表…
action.ShowSearchEverywhereItemInfo.text=顯示“隨處搜尋”條目資訊
action.ShowSearchHistory.text=顯示搜尋歷史記錄
action.ShowSettingsAndFindUsages.description=為“尋找用法”動作選擇作用域和編輯選項
action.ShowSettingsAndFindUsages.text=尋找用法設定…
action.ShowSettingsWithAddedPattern.description=開啟參數名稱提示設定
action.ShowSettingsWithAddedPattern.text=停用方法的提示
action.ShowSiblings.description=顯示包含符號同級內容的彈出視窗
action.ShowSiblings.text=顯示同級
action.ShowSouthPanelTestDialogAction.text=測試 DialogWrapper 南側面板
action.ShowSplash.text=顯示初始頁面
action.ShowTips.description=學習如何提高編碼效率。
action.ShowTips.text=每日小技巧(_T)
action.ShowToolbar.text=顯示工具列
action.ShowTrustProjectDialog.text=信任專案…
action.ShowTypeBookmarks.text=轉到助記符…
action.ShowUpdateDialogAction.text=顯示“更新”對話框
action.ShowUsageFeatures.text=顯示用法功能
action.ShowUsages.description=顯示文字游標處符號的用法
action.ShowUsages.text=顯示用法(_S)
action.SilentCodeCleanup.description=執行清理檢查並使用當前檢查組態檔案套用快速修復
action.SilentCodeCleanup.text=靜默程式碼清理
action.SilentHeapDumpSnapshot.text=建立並安排堆傾印分析(非使用者呼叫)
action.SkipWindowDeactivationEvents.description=開啟以簡化偵錯。當偵錯 IDE 中的中斷點命中時，主 IDE 會竊取焦點，並且偵錯 IDE 中的 \`WINDOW_DEACTIVATED\` 事件會觸發彈出視窗或檔案分析的取消，從而使 \`ProgressManager.checkCanceled()\` 立即拋出，而不提供任何機會偵錯。
action.SkipWindowDeactivationEvents.text=跳過視窗停用事件
action.SliceBackward.MainMenu.text=流入此處的資料(_T)…
action.SliceBackward.description=搜尋可以分配給所選表達式的值
action.SliceBackward.text=分析流入此處的資料(_T)…
action.SliceForward.MainMenu.text=流出此處的資料(_F)…
action.SliceForward.description=搜尋從此位置轉義的值
action.SliceForward.text=分析流出此處的資料(_F)…
action.SmartSelect.text=擴展選區
action.SmartStepInto.description=步入特定方法
action.SmartStepInto.text=智能步入(_P)
action.SmartTypeCompletion.description=基於預期類型補全程式碼
action.SmartTypeCompletion.synonym=SmartType
action.SmartTypeCompletion.synonym2=智能補全
action.SmartTypeCompletion.text=類型符合
action.SmartUnSelect.text=收縮選區
action.SpeedSearch.GotItTooltip.text=輸入任意符號可開啟搜尋框。無需按 {0}。
action.SpeedSearch.GotItTooltip.textWithoutShortcuts=輸入任意符號可開啟搜尋框。無需手動呼叫該動作。
action.SpeedSearch.shortcutTextSuffix=或任意符號
action.SpeedSearch.text=快速搜尋
action.SplitChooser.Duplicate.text=複製
action.SplitChooser.Exit.text=離開選擇器
action.SplitChooser.NextWindow.text=下一個拆分
action.SplitChooser.PreviousWindow.text=上一個拆分
action.SplitChooser.Split.text=拆分
action.SplitChooser.SplitCenter.text=無拆分
action.SplitChooser.SplitDown.text=使用向下拆分或向下切換
action.SplitChooser.SplitLeft.text=使用向左拆分或向左切換
action.SplitChooser.SplitRight.text=使用向右拆分或向右切換
action.SplitChooser.SplitTop.text=使用頂部拆分或向上切換
action.SplitChooser.description=允許在編輯器中互動選擇拆分位置，並在該處開啟/移動所選檔案
action.SplitChooser.text=通過選擇器以拆分方式開啟…
action.SplitHorizontally.description=將編輯器區域拆分為 2 個頁籤組，然後將當前頁籤移至底部組
action.SplitHorizontally.synonym=水平拆分
action.SplitHorizontally.text=向下拆分
action.SplitVertically.description=將編輯器區域拆分為 2 個頁籤組，然後將當前頁籤移至右側組
action.SplitVertically.synonym=垂直拆分
action.SplitVertically.text=向右拆分
action.Start.Use.Vcs.Vcs.Toolbar.Widget.text=其他服務…
action.Start.Use.Vcs.text=啟用版本控制整合(_E)…
action.StartStopMacroRecording.description=啟動/停止新巨集錄製
action.StartStopMacroRecording.text=啟動/停止巨集錄製(_R)
action.StaticIconFields.text=列出 static 圖示欄位初始設定式
action.StatusTextModeAction.text=狀態文本
action.StepInto.description=單步執行至已執行的下一行
action.StepInto.text=步入(_I)
action.StepOut.description=單步執行至從此方法返回後執行的第一行
action.StepOut.text=步出(_T)
action.StepOver.description=單步執行至此檔案中的下一行
action.StepOver.text=步過(_O)
action.StepOverInstruction.description=在指令級別執行單步跳過
action.StepOverInstruction.text=單步跳過指令
action.Stop.description=停止程序
action.Stop.text=停止
action.StopBackgroundProcesses.description=停止背景程序
action.StopBackgroundProcesses.text=停止背景程序…
action.StoreDefaultLayout.description=儲存當前所選布局中的更改
action.StoreDefaultLayout.named.description=儲存當前所選布局(“{0}”)中的更改
action.StoreDefaultLayout.synonym=存儲當前布局
action.StoreDefaultLayout.text=儲存當前布局中的更改(_S)
action.StoreNewLayout.description=以新名稱儲存當前布局
action.StoreNewLayout.text=將當前布局另存為新布局(_N)…
action.StretchSplitToBottom.description=將拆分的編輯器延伸至底部
action.StretchSplitToBottom.text=將編輯器延伸至底部
action.StretchSplitToLeft.description=向左拉伸編輯器拆分
action.StretchSplitToLeft.text=將編輯器延伸至左側
action.StretchSplitToRight.description=將拆分的編輯器延伸至右側
action.StretchSplitToRight.text=將編輯器延伸至右側
action.StretchSplitToTop.description=將拆分的編輯器延伸至頂部
action.StretchSplitToTop.text=將編輯器延伸至頂部
action.StructuralSearchPlugin.StructuralReplaceAction.description=結構取代
action.StructuralSearchPlugin.StructuralReplaceAction.text=結構化取代(_C)…
action.StructuralSearchPlugin.StructuralSearchAction.description=結構搜尋
action.StructuralSearchPlugin.StructuralSearchAction.text=結構化搜尋(_T)…
action.SurroundWith.description=使用 if/while/try-catch 或其他結構包圍所選程式碼段
action.SurroundWith.text=環繞方式(_S)…
action.SurroundWithEmmet.description=使用 Emmet 縮寫包圍所選程式碼
action.SurroundWithEmmet.text=使用 Emmet 包圍
action.SurroundWithLiveTemplate.description=使用一個模板包圍選區
action.SurroundWithLiveTemplate.text=使用實時模板包圍(_P)…
action.SurroundWithTagTemplate.description=使用標記包圍所選程式碼
action.SurroundWithTagTemplate.text=使用標記包圍
action.SwapSidesInDiffWindow.text=交換兩側
action.SwapThreeWayColorModeInDiffWindow.text=更改三向檢視器模式
action.SwitchCoverage.text=顯示程式碼覆蓋率資料(_V)
action.SwitchFileBasedIndexStorageAction.text=切換基於檔案的索引存儲
action.SwitchIdeScaleAction.text=縮放 IDE
action.Switcher.text=切換器
action.SwitcherBackward.text=選擇上一行
action.SwitcherBackwardFallback.text=切換到左側的頁籤
action.SwitcherFallback.text=切換器
action.SwitcherForward.text=選擇下一行
action.SwitcherForwardFallback.text=切換到右側的頁籤
action.SwitcherIterateItems.text=迭代最近的檔案
action.SwitcherIterateItemsFallback.text=迭代最近的檔案
action.SwitcherNextProblem.text=選擇下一個問題檔案
action.SwitcherNextProblemFallback.text=選擇下一個問題檔案
action.SwitcherPreviousProblem.text=選擇上一個問題檔案
action.SwitcherPreviousProblemFallback.text=選擇上一個問題檔案
action.SwitcherRecentEditedChangedToggleCheckBox.text=切換僅更改的檔案
action.SwitcherRecentEditedChangedToggleCheckBoxFallback.text=切換僅更改的檔案
action.Synchronize.description=檢測所有外部更改的檔案，並從磁碟重新載入
action.Synchronize.text=從磁碟全部重新載入
action.SynchronizeCurrentFile.text=從磁碟重新載入
action.TW.CloseAllTabs.description=關閉活動工具視窗頁籤組中的所有頁籤
action.TW.CloseAllTabs.text=關閉所有頁籤(_A)
action.TW.CloseOtherTabs.description=關閉工具視窗中除活動頁籤之外的所有開啟的頁籤
action.TW.CloseOtherTabs.text=關閉其他頁籤(_O)
action.TW.SplitAndMoveDown.description=將工具視窗區域拆分為兩個頁籤組，然後將當前頁籤移至底部組
action.TW.SplitAndMoveDown.text=拆分並下移
action.TW.SplitAndMoveRight.description=將工具視窗區域拆分為兩個頁籤組，然後將當前頁籤移至右側組
action.TW.SplitAndMoveRight.text=拆分並右移
action.TW.SplitDown.description=將工具視窗區域拆分為兩個頁籤組，並在底部組中建立當前頁籤的副本
action.TW.SplitDown.text=向下拆分
action.TW.SplitRight.description=將工具視窗區域拆分為兩個頁籤組，並在右側組中建立當前頁籤的副本
action.TW.SplitRight.text=向右拆分
action.TW.Unsplit.description=取消拆分工具視窗頁籤組
action.TW.Unsplit.text=取消拆分(_S)
action.TabList.description=在單行頁籤布局中顯示一個下拉選單，列出螢幕上無法完全顯示的頁籤
action.TabList.text=顯示隱藏的頁籤
action.Tabbed.WelcomeScreen.OpenProject.text=開啟
action.Table-scrollDownChangeSelection.description=將周圍的可滾動區域向下滾動一頁，然後選擇相應的行
action.Table-scrollDownChangeSelection.text=向下滾動頁面並選擇行
action.Table-scrollDownExtendSelection.description=將周圍的可滾動區域向下滾動一頁，然後將相應的行新增到選區
action.Table-scrollDownExtendSelection.text=向下滾動頁面並擴展選區
action.Table-scrollUpChangeSelection.description=將周圍的可滾動區域向上滾動一頁，然後選擇相應的行
action.Table-scrollUpChangeSelection.text=向上滾動頁面並選擇行
action.Table-scrollUpExtendSelection.description=將周圍的可滾動區域向上滾動一頁，然後將相應的行新增到選區
action.Table-scrollUpExtendSelection.text=向上滾動頁面並擴展選區
action.Table-selectFirstRow.description=選擇第一行
action.Table-selectFirstRow.text=選擇第一行
action.Table-selectFirstRowExtendSelection.description=滾動到第一行並將相應行新增到選區
action.Table-selectFirstRowExtendSelection.text=將選區擴展到第一行
action.Table-selectLastRow.description=選擇最後一行
action.Table-selectLastRow.text=選擇最後一行
action.Table-selectLastRowExtendSelection.description=滾動到最後一行並將相應行新增到選區
action.Table-selectLastRowExtendSelection.text=將選區擴展到最後一行
action.Table-selectNextColumn.description=選擇下一列
action.Table-selectNextColumn.text=選擇下一列
action.Table-selectNextColumnExtendSelection.description=將下一列新增到選區
action.Table-selectNextColumnExtendSelection.text=將選區擴展到下一列
action.Table-selectNextRow.description=選擇下一行
action.Table-selectNextRow.text=選擇下一行
action.Table-selectNextRowExtendSelection.description=將下一行新增到選區
action.Table-selectNextRowExtendSelection.text=將選區擴展到下一行
action.Table-selectPreviousColumn.description=選擇上一列
action.Table-selectPreviousColumn.text=選擇上一列
action.Table-selectPreviousColumnExtendSelection.description=將上一列新增到選區
action.Table-selectPreviousColumnExtendSelection.text=將選區擴展到上一列
action.Table-selectPreviousRow.description=選擇上一行
action.Table-selectPreviousRow.text=選擇上一行
action.Table-selectPreviousRowExtendSelection.description=將上一行新增到選區。
action.Table-selectPreviousRowExtendSelection.text=將選區擴展到上一行
action.Table-startEditing.text=編輯表單元
action.TechnicalSupport.description=在 JetBrains 網站上聯繫技術支援
action.TechnicalSupport.text=聯繫支援(_S)…
action.TerminalDecreaseFontSize.GoToAction.text=減小終端中的字體大小
action.TerminalDecreaseFontSize.text=減小字體大小
action.TerminalIncreaseFontSize.GoToAction.text=增加終端中的字體大小
action.TerminalIncreaseFontSize.text=增大字體大小
action.TerminalResetFontSize.GoToAction.text=重設終端中的字體大小
action.TerminalResetFontSize.text=重設字體大小
action.TestCoroutineProgress.text=測試協程進度
action.TestDndAction.text=測試 Dnd
action.TestGestureAction.text=測試手勢動作
action.TestIconMappings.text=測試圖示映射
action.TestMessageBoxAction.text=顯示測試對話框
action.TestParseEventsSchemeAction.text=測試解析事件方案…
action.TestProgressWindow.text=測試進度視窗
action.TestRubberDuckDebuggerAction.text=測試小黃鴨偵錯器
action.TestSearchContributors.text=SE 貢獻者測試
action.TestTextFieldAction.text=測試文本欄位
action.TestTooltipsAction.text=測試工具提示
action.TextComponent.ClearAction.description=清除文本元件中的文本
action.TextComponent.ClearAction.text=清除文本
action.TextEditorWithPreview.SplitHorizontally.text=水平布局
action.TextEditorWithPreview.SplitVertically.text=垂直布局
action.TextGrayFilterConfig.text=文本灰色篩選器(&T)
action.TextSearchAction.description=在“隨處搜尋”中顯示文本符合項
action.TextSearchAction.text=文本…
action.ToggleBookmark.text=切換書籤(_B)
action.ToggleBookmarkWithMnemonic.text=切換書籤助記符…
action.ToggleBreakpointEnabled.description=啟用/停用當前行的中斷點
action.ToggleBreakpointEnabled.text=切換中斷點啟用狀態(_B)
action.ToggleCompactMode.text=緊湊模式
action.ToggleCompletionHintsAction.text=補全時顯示參數名稱提示
action.ToggleContentUiTypeMode.description=切換內容的標籤式/組合式顯示
action.ToggleContentUiTypeMode.text=頁籤分組
action.ToggleDistractionFreeMode.description=切換免打擾模式
action.ToggleDistractionFreeMode.enter=進入免打擾模式
action.ToggleDistractionFreeMode.exit=離開免打擾模式
action.ToggleDistractionFreeMode.text=切換免打擾模式
action.ToggleDockMode.description=停靠/取消停靠活動工具視窗
action.ToggleDockMode.text=停靠模式(_E)
action.ToggleEssentialHighlighting.description=基本醒目提示模式只保留一組有限的程式碼醒目提示工具。包括檢查在內的所有醒目提示工具都將在執行檔案儲存動作時執行
action.ToggleEssentialHighlighting.text=基本醒目提示顯示
action.ToggleFieldBreakpoint.MainMenu.text=欄位觀察點
action.ToggleFieldBreakpoint.description=為文字游標處的欄位切換欄位觀察點
action.ToggleFieldBreakpoint.text=切換欄位觀察點(_F)
action.ToggleFileBasedIndexes.text=切換基於檔案的索引
action.ToggleFindInSelection.text=僅在選區內搜尋
action.ToggleFloatingMode.description=浮動/取消浮動活動工具視窗
action.ToggleFloatingMode.text=浮動模式(_M)
action.ToggleFocusMode.text=僅醒目提示當前宣告
action.ToggleFullScreen.description=切換全螢幕模式
action.ToggleFullScreen.text=切換全螢幕模式
action.ToggleFullScreen.text.enter=進入全螢幕
action.ToggleFullScreen.text.exit=離開全螢幕
action.ToggleIncompleteMode.text=進入不完全相依關係模式
action.ToggleInlineHintsAction.description=切換參數名稱提示
action.ToggleInlineHintsAction.text=切換參數名稱提示
action.ToggleLineBreakpoint.MainMenu.text=行中斷點(_L)
action.ToggleLineBreakpoint.description=切換文字游標處的行中斷點
action.ToggleLineBreakpoint.text=切換行中斷點(_L)
action.ToggleMethodBreakpoint.MainMenu.text=方法中斷點(_M)
action.ToggleMethodBreakpoint.description=為文字游標處的方法切換方法中斷點
action.ToggleMethodBreakpoint.text=切換方法中斷點(_M)
action.TogglePinnedMode.description=固定/取消固定活動工具視窗
action.TogglePinnedMode.text=固定模式(_P)
action.TogglePopupHints.text=切換當前檔案的彈出視窗提示
action.TogglePowerSave.description=省電模式將停用背景程式碼分析和其他背景動作
action.TogglePowerSave.text=省電模式
action.TogglePresentationAssistantAction.text=Presentation Assistant
action.TogglePresentationMode.description=切換示範模式
action.TogglePresentationMode.enter=進入示範模式
action.TogglePresentationMode.exit=離開示範模式
action.TogglePresentationMode.text=切換示範模式
action.TogglePresentationMode.text.enter=進入示範模式
action.TogglePresentationMode.text.exit=離開示範模式
action.ToggleReadOnlyAttribute.description=切換當前檔案的唯讀特性
action.ToggleReadOnlyAttribute.dirs=使{3,choice,1#目錄|2#目錄}{0,choice,0#唯讀|1#可寫}
action.ToggleReadOnlyAttribute.files=將{2,choice,1#檔案|2#檔案}設為{0,choice,0#唯讀|1#可寫}
action.ToggleReadOnlyAttribute.mixed=使檔案/目錄{0,choice,0#唯讀|1#可寫}
action.ToggleReadOnlyAttribute.synonym=將檔案設為可寫
action.ToggleReadOnlyAttribute.synonym2=將檔案設為唯讀
action.ToggleReadOnlyAttribute.text=切換唯讀特性
action.ToggleRenderedDocPresentation.description=在檢視原始碼和文檔註釋的渲染表示之間切換
action.ToggleRenderedDocPresentation.text=切換呈現檢視
action.ToggleRenderedDocPresentationForAll.description=切換到所有文檔註釋的呈現檢視
action.ToggleRenderedDocPresentationForAll.text=呈現所有文檔註釋
action.ToggleScrollToResultsDuringTypingAction.text=輸入時滾動至結果
action.ToggleSideMode.description=開啟/關閉工具視窗拆分模式
action.ToggleSideMode.text=拆分模式
action.ToggleTemporaryLineBreakpoint.MainMenu.text=臨時行中斷點
action.ToggleTemporaryLineBreakpoint.description=切換文字游標處的臨時行中斷點
action.ToggleTemporaryLineBreakpoint.text=切換臨時行中斷點
action.ToggleThreeSideInBlankDiffWindow.text=切換三向檢視器
action.ToggleThreeSideInBlankDiffWindow.text.disable=切換到兩向檢視器
action.ToggleThreeSideInBlankDiffWindow.text.enable=切換到三向檢視器
action.ToggleUnusedState.description=指示 IDE 未使用或已使用
action.ToggleUnusedState.text=指示 IDE 未使用
action.ToggleWindowedMode.description=視窗化/取消視窗化活動工具視窗
action.ToggleWindowedMode.text=視窗化模式(_W)
action.ToggleZenMode.description=同時切換免打擾和全螢幕模式
action.ToggleZenMode.enter=進入 Zen 模式
action.ToggleZenMode.exit=離開 Zen 模式
action.ToggleZenMode.text=切換 Zen 模式
action.ToolWindowShowNamesAction.text=顯示工具視窗名稱
action.ToolbarDemo.text=工具列示範
action.TopStripeEnableAction.text=使用單個工具視窗列
action.TopStripePinButton.text=固定
action.TopStripeUnPinButton.text=取消固定
action.TransferSettingsDemoAction.text=測試傳輸設定
action.Tree-scrollDownChangeSelection.description=將周圍的可滾動區域向下滾動一頁，然後選擇相應的節點
action.Tree-scrollDownChangeSelection.text=向下滾動頁面並選擇節點
action.Tree-scrollDownExtendSelection.description=將周圍的可滾動區域向下滾動一頁，然後將相應的節點新增到選區
action.Tree-scrollDownExtendSelection.text=向下滾動頁面並擴展選區
action.Tree-scrollUpChangeSelection.description=將周圍的可滾動區域向上滾動一頁，然後選擇相應的節點
action.Tree-scrollUpChangeSelection.text=向上滾動頁面並選擇節點
action.Tree-scrollUpExtendSelection.description=將周圍的可滾動區域向上滾動一頁，然後將相應的節點新增到選區
action.Tree-scrollUpExtendSelection.text=向上滾動頁面並擴展選區
action.Tree-selectAll.description=選擇所有節點
action.Tree-selectAll.text=選擇所有節點
action.Tree-selectChild.description=展開摺疊的節點或選擇子節點
action.Tree-selectChild.text=選擇子節點
action.Tree-selectChildExtendSelection.description=展開摺疊的節點或將子節點新增到選區
action.Tree-selectChildExtendSelection.text=將選區擴展到子節點
action.Tree-selectFirst.description=選擇第一個節點
action.Tree-selectFirst.text=選擇第一個節點
action.Tree-selectFirstExtendSelection.description=滾動到第一個節點並將相應節點新增到選區
action.Tree-selectFirstExtendSelection.text=將選區擴展到第一個節點
action.Tree-selectLast.description=選擇最後一個節點
action.Tree-selectLast.text=選擇最後一個節點
action.Tree-selectLastExtendSelection.description=滾動到最後一個節點並將相應節點新增到選區
action.Tree-selectLastExtendSelection.text=將選區擴展到最後一個節點
action.Tree-selectNext.description=選擇下一個節點
action.Tree-selectNext.text=選擇下一個節點
action.Tree-selectNextExtendSelection.description=將下一個節點新增到選區。
action.Tree-selectNextExtendSelection.text=將選區擴展到下一個節點
action.Tree-selectNextSibling.description=選擇下一個同級節點。
action.Tree-selectNextSibling.text=選擇下一個同級節點
action.Tree-selectParent.description=摺疊展開的節點或選擇父節點。
action.Tree-selectParent.text=選擇父節點
action.Tree-selectParentExtendSelection.description=滾動到父節點並將相應節點新增到選區
action.Tree-selectParentExtendSelection.text=將選區擴展到父節點
action.Tree-selectParentNoCollapse.description=選擇父節點而不摺疊展開的節點
action.Tree-selectParentNoCollapse.text=選擇父節點
action.Tree-selectPrevious.description=選擇上一個節點
action.Tree-selectPrevious.text=選擇上一個節點
action.Tree-selectPreviousExtendSelection.description=將上一個節點新增到選區
action.Tree-selectPreviousExtendSelection.text=將選區擴展到上一個節點
action.Tree-selectPreviousSibling.description=選擇上一個同級節點。
action.Tree-selectPreviousSibling.text=選擇上一個同級節點
action.Tree-startEditing.text=編輯樹節點
action.TreeExpandAll.text=展開樹
action.TreeViewModelDemo.text=樹檢視模型示範
action.TrialStateWidget.text=試用狀態
action.TriggerLowMemoryNotification.text=觸發低記憶體通知
action.TriggerProjectIndexableFilesFilterHealthCheckAction.text=觸發專案可索引檔案篩選器執行狀況檢查
action.TrustProject.text=信任
action.TurnOnOffCachedValueProfilerAction.text=開啟快取值分析器
action.TurnRefsToSuper.description=將類別的用法更改為其超類別或接口的用法
action.TurnRefsToSuper.text=盡可能使用接口(_W)…
action.TypeHierarchy.Class.text=類別層次結構
action.TypeHierarchy.Subtypes.text=子類型層次結構
action.TypeHierarchy.Supertypes.text=父類型層次結構
action.TypeHierarchy.description=瀏覽所選類別的層次結構
action.TypeHierarchy.text=類型層次結構(_H)
action.TypeHierarchyBase.BaseOnThisType.text=基於此類型
action.TypingLatencyReport.text=輸入延遲報告
action.UIDefaults.text=LaF 預設設定
action.UISandboxAction.text=UI 沙盒
action.UiDebugger.text=UI 偵錯器…
action.UiDslShowcaseAction.text=UI DSL 展示
action.UiInspector.text=UI 檢查器(&I)
action.UiThemeColorPickerAction.text=啟用 UI 主題顏色選擇器
action.UndoDumpAction.text=傾印撤消
action.UndockMode.description=使工具視窗滑動並在焦點丟失時自動隱藏
action.UndockMode.text=取消停靠(_D)
action.UnixInfoTest.text=顯示 Unix 資訊
action.UnmarkRoot.text=取消標記
action.Unscramble.EditorPopup.text=堆疊追蹤或執行緒傾印(_S)…
action.Unscramble.description=開啟包含可導覽堆疊追蹤或執行緒傾印的主控台
action.Unscramble.text=分析堆疊追蹤或執行緒傾印(_S)…
action.UnselectPreviousOccurrence.description=從選區中移除單詞的當前符合項。
action.UnselectPreviousOccurrence.text=取消選擇符合項
action.Unsplit.description=取消拆分視窗
action.Unsplit.text=取消拆分(_S)
action.UnsplitAll.description=移除所有拆分器
action.UnsplitAll.text=取消全部拆分(_N)
action.UntrustProject.text=不信任
action.Unwrap.description=安全地解包或移除所選作用域
action.Unwrap.text=解包/移除(_W)…
action.UpdateFiles.text=更新(_U)
action.UpdateRunningApplication.text=更新正在執行的應用程式
action.UsageView.Exclude.description=將此用法從處理中排除
action.UsageView.Exclude.text=排除
action.UsageView.Include.description=將此用法包含到處理中
action.UsageView.Include.text=包含
action.UsageView.Remove.description=將此用法從處理中移除
action.UsageView.Remove.text=移除
action.UsageView.Rerun.description=重新執行搜尋
action.UsageView.Rerun.text=重新執行
action.UsageView.ShowRecentFindUsages.description=選擇並重新執行最近的尋找用法
action.UsageView.ShowRecentFindUsages.text=最近的尋找用法(_E)
action.UsedIconsListing.text=列出使用的圖示
action.UserInvokedFullAnalysis.text=建立並立即分析堆傾印
action.ValidateXml.description=驗證當前的 XML 檔案
action.ValidateXml.text=驗證(_V)
action.ValidationTest.text=驗證對話框測試
action.Vcs.ApplySelectedChanges.text=優選所選更改
action.Vcs.CombinedDiff.CaretToNextBlock.text=下一個檔案
action.Vcs.CombinedDiff.CaretToPrevBlock.text=上一個檔案
action.Vcs.CombinedDiff.ToggleCollapseAllBlock.description=切換摺疊組合差異中的所有檔案
action.Vcs.CombinedDiff.ToggleCollapseAllBlock.text=摺疊所有檔案
action.Vcs.CombinedDiff.ToggleCollapseBlock.text=摺疊檔案
action.Vcs.CopyCommitSubjectAction.description=將所選提交的主題複製到剪貼簿
action.Vcs.CopyCommitSubjectAction.text=複製提交主題
action.Vcs.CopyCurrentBranchName.description=將當前分支名稱複製到剪貼簿
action.Vcs.CopyCurrentBranchName.text=複製分支名稱
action.Vcs.CopyRevisionNumberAction.description=將選定提交的修訂號複製到剪貼簿
action.Vcs.CopyRevisionNumberAction.text=複製修訂號
action.Vcs.Diff.EnableDisableCombinedDiff.text=在單個差異檢視中顯示所有檔案
action.Vcs.Diff.ExcludeChangedLinesFromCommit.template.text={0,choice,0#|1#拆分區塊並|2#拆分區塊並}從提交中排除{1,choice,0#當前行|2#所選行}
action.Vcs.Diff.ExcludeChangedLinesFromCommit.text=拆分區塊並從提交中排除所選行
action.Vcs.Diff.IncludeChangedLinesIntoCommit.template.text={0,choice,0#|1#拆分區塊並|2#拆分區塊並}將{1,choice,0#當前行|2#所選行}包含到提交中
action.Vcs.Diff.IncludeChangedLinesIntoCommit.text=拆分區塊並將所選行包含到提交中
action.Vcs.Diff.IncludeWholeChangedLinesIntoCommit.text=將行包含到提交中
action.Vcs.Diff.ResolveConflictsInImports.text=解決 import 語句中的衝突
action.Vcs.Diff.ShowCombinedDiff.description=在一處顯示全部所選更改的差異
action.Vcs.Diff.ShowCombinedDiff.text=顯示組合差異
action.Vcs.Diff.ShowDiffInEditorTab.text=在編輯器頁籤中顯示差異
action.Vcs.Diff.ShowDiffInNewWindow.text=在單獨的視窗中顯示差異
action.Vcs.Diff.ToggleDiffAligningMode.description=啟用雙面差異的更改對齊
action.Vcs.Diff.ToggleDiffAligningMode.popup@DiffToolbar.text=對齊更改醒目提示
action.Vcs.Diff.ToggleDiffAligningMode.text=在並排差異中對齊更改
action.Vcs.Diff.ToggleSearchInChanges.text=在更改中搜尋
action.Vcs.EditSource.text=編輯源
action.Vcs.GetVersion.description=從儲存庫獲取版本
action.Vcs.GetVersion.text=獲取
action.Vcs.IntegrateProject.description=整合專案
action.Vcs.IntegrateProject.text=整合專案(_G)
action.Vcs.MoveChangedLinesToChangelist.description=將所選行中的更改移至另一個更改列表…
action.Vcs.MoveChangedLinesToChangelist.text=將行移至另一個變更列表…
action.Vcs.Operations.Popup.Annotate.text=註解行動作
action.Vcs.Push.Force.text=強制推送(_F)
action.Vcs.Push.text=推送…
action.Vcs.QuickListPopupAction.description=包含常用 VCS 動作列表的上下文感知彈出視窗
action.Vcs.QuickListPopupAction.text=VCS 動作彈出視窗…
action.Vcs.RevertSelectedChanges.text=還原所選更改
action.Vcs.RollbackChangedLines.description=復原所選行中的更改
action.Vcs.RollbackChangedLines.text=復原行
action.Vcs.RunCommitChecks.text=執行提交檢查
action.Vcs.Show.Local.Changes.text=顯示本地更改
action.Vcs.Show.Shelf.text=顯示 Shelf
action.Vcs.ShowConsoleTab.text=在 VCS 主控台頁籤中顯示
action.Vcs.ShowDiffChangedLines.description=顯示所選行的差異
action.Vcs.ShowDiffChangedLines.text=顯示行的差異
action.Vcs.ShowDiffWithLocal.Before.description=將之前的所選修訂中的版本與當前版本進行比較
action.Vcs.ShowDiffWithLocal.Before.text=將之前版本與本地版本進行比較
action.Vcs.ShowDiffWithLocal.description=將所選修訂中的版本與當前版本進行比較
action.Vcs.ShowDiffWithLocal.text=與本地比較
action.Vcs.ShowHistoryForBlock.description=顯示編輯器選擇的歷史記錄
action.Vcs.ShowHistoryForBlock.text=顯示選區的歷史記錄(_F)…
action.Vcs.ShowHistoryForRevision.description=顯示檔案的歷史記錄，直到所選修訂
action.Vcs.ShowHistoryForRevision.text=迄今為止的歷史記錄
action.Vcs.ShowMessageHistory.description=顯示提交訊息歷史記錄
action.Vcs.ShowMessageHistory.text=提交訊息歷史記錄
action.Vcs.ShowTabbedFileHistory.description=顯示檔案歷史
action.Vcs.ShowTabbedFileHistory.for.file.text=顯示 {0} 的歷史記錄(_H)
action.Vcs.ShowTabbedFileHistory.text=顯示歷史記錄(_H)
action.Vcs.ToggleAmendCommitMode.description=修改當前分支的最新提交
action.Vcs.ToggleAmendCommitMode.text=修正提交
action.Vcs.Toolbar.ShowMoreActions.description=VCS 動作
action.Vcs.Toolbar.ShowMoreActions.text=版本控制
action.Vcs.UpdateProject.text=更新專案(_U)
action.Vcs.VcsClone.text=從版本控制中獲取…
action.Vcs.VcsClone.text.synonym1=簽出
action.Vcs.VcsClone.text.synonym2=克隆
action.VcsHistory.ShowAllAffected.description=顯示選中修訂中所做的所有更改
action.VcsHistory.ShowAllAffected.text=顯示所有受影響的檔案
action.VcsShowCurrentChangeMarker.description=顯示當前所選更改的彈出視窗
action.VcsShowCurrentChangeMarker.text=文字游標下的更改(_H)
action.VcsShowNextChangeMarker.description=轉到下一個更改
action.VcsShowNextChangeMarker.text=下一個更改(_H)
action.VcsShowPrevChangeMarker.description=轉到上一個更改
action.VcsShowPrevChangeMarker.text=上一個更改(_A)
action.VcsToolbarLabelAction.text=VCS 標籤
action.ViewBreakpoints.description=檢視和管理所有中斷點和觀察點
action.ViewBreakpoints.text=檢視中斷點(_K)…
action.ViewImportPopups.description=在當前檔案中切換顯示匯入彈出視窗
action.ViewImportPopups.text=顯示 import 彈出視窗
action.ViewInplaceComments.description=在樹檢視中顯示/隱藏額外資訊
action.ViewInplaceComments.text=檔案詳細資訊
action.ViewMainMenu.description=顯示/隱藏主選單
action.ViewMainMenu.text=主選單
action.ViewMembersInNavigationBar.NavBar.text=在導覽列中顯示成員
action.ViewMembersInNavigationBar.description=在導覽列中顯示/隱藏宣告
action.ViewMembersInNavigationBar.text=導覽列中的成員
action.ViewNavigationBar.NavBar.text=顯示導覽列
action.ViewNavigationBar.description=顯示/隱藏導覽列
action.ViewNavigationBar.text=導覽列(_V)
action.ViewNewToolbarAction.text=工具列
action.ViewObsoleteNavBarAction.text=導覽列
action.ViewObsoleteToolbarAction.text=工具列經典
action.ViewOfflineInspection.description=載入離線檢查結果
action.ViewOfflineInspection.text=檢視離線檢查結果(_O)…
action.ViewSource.description=開啟所選條目的編輯器
action.ViewSource.text=顯示源(_W)
action.ViewStatusBar.description=顯示/隱藏狀態列
action.ViewStatusBar.text=狀態列(_S)
action.ViewToolBar.description=顯示/隱藏主工具列
action.ViewToolBar.text=工具列(_T)
action.ViewToolButtons.description=顯示/隱藏工具視窗按鈕
action.ViewToolButtons.text=工具視窗
action.VirtualFileInfo.text=虛擬檔案資訊
action.WebBrowser.text=顯示 Web 瀏覽器(&W)
action.WelcomeScreen.ChangeProjectIcon.text=設定自訂專案圖示…
action.WelcomeScreen.Configure.Export.text=匯出設定
action.WelcomeScreen.Configure.Import.text=匯入設定…
action.WelcomeScreen.CopyProjectPath.text=複製路徑
action.WelcomeScreen.CreateDirectoryProject.description=建立一個新項目。
action.WelcomeScreen.CreateDirectoryProject.text=新增專案
action.WelcomeScreen.CreateNewProject.description=啟動“新項目”嚮導，它將引導您建立一個新項目。
action.WelcomeScreen.CreateNewProject.text=新增專案
action.WelcomeScreen.DefaultNewProjectAction.text=新增專案
action.WelcomeScreen.DevelopPlugins.description=開始開發延伸模組。
action.WelcomeScreen.DevelopPlugins.text=延伸模組開發
action.WelcomeScreen.EditGroup.text=編輯…
action.WelcomeScreen.ManageLicense.text=管理授權…
action.WelcomeScreen.NewGroup.text=新增專案組
action.WelcomeScreen.OpenDirectoryProject.description=開始在指定的檔案或目錄中編輯程式碼。
action.WelcomeScreen.OpenDirectoryProject.text=開啟
action.WelcomeScreen.OpenProject.description=開啟檔案或專案。您也可以通過拖放到歡迎頁面來開啟專案或編輯檔案。
action.WelcomeScreen.OpenProject.text=開啟或匯入
action.WelcomeScreen.OpenSelected.text=開啟選定項
action.WelcomeScreen.Plugins.Extensions.text=擴展
action.WelcomeScreen.Plugins.description=管理已安裝的延伸模組，以及從儲存庫下載新延伸模組
action.WelcomeScreen.Plugins.text=延伸模組
action.WelcomeScreen.RemoveSelected.text=從最近的專案中移除…
action.WhatsNewAction.description=了解此版本 IDE 中的新功能
action.WhatsNewAction.text=最新變化(_N)
action.WindowMode.description=將工具視窗移至單獨的框架
action.WindowMode.text=視窗(_W)
action.WriteActionUnderProgress.text=正在測試寫入動作
action.XDebugger.CompareValueWithClipboard.description=將所選節點的值與剪貼簿文本進行比較
action.XDebugger.CompareValueWithClipboard.text=與剪貼簿比較值
action.XDebugger.CopyName.description=將所選節點的名稱複製到剪貼簿
action.XDebugger.CopyName.text=複製名稱
action.XDebugger.CopyValue.description=將所選節點的值複製到剪貼簿
action.XDebugger.CopyValue.text=複製值
action.XDebugger.CopyWatch.text=複製監視
action.XDebugger.DisableAllButThisBreakpoint.description=停用所有中斷點，僅保留文字游標所在行的中斷點
action.XDebugger.DisableAllButThisBreakpoint.text=停用其他中斷點
action.XDebugger.EditWatch.text=編輯…
action.XDebugger.Inline.description=在編輯器中顯示可用的偵錯器會話值
action.XDebugger.Inline.text=在編輯器中顯示變量值
action.XDebugger.Inspect.text=檢查…
action.XDebugger.JumpToSource.description=開啟所選條目的源
action.XDebugger.JumpToSource.text=跳轉到源
action.XDebugger.JumpToTypeSource.description=開啟所選值類型的源
action.XDebugger.JumpToTypeSource.text=跳轉到類型源
action.XDebugger.MoveWatchDown.text=下移監視
action.XDebugger.MoveWatchUp.text=上移監視
action.XDebugger.MuteBreakpoints.text=忽略中斷點
action.XDebugger.NewWatch.text=新增監視…
action.XDebugger.PauseWatch.text=暫停監視
action.XDebugger.PinToTop.text=固定至頂部
action.XDebugger.PreviewTab.text=在預覽頁籤中開啟檔案
action.XDebugger.RemoveAllButThisBreakpoint.description=移除所有中斷點，僅保留文字游標所在行的中斷點
action.XDebugger.RemoveAllButThisBreakpoint.text=移除其他中斷點
action.XDebugger.RemoveAllWatches.text=移除所有監視
action.XDebugger.RemoveWatch.text=移除監視
action.XDebugger.SeparateWatches.text=單獨的監視
action.XDebugger.SetValue.description=修改所選節點的值
action.XDebugger.SetValue.text=設定值…
action.XDebugger.Show.Breakpoints.Over.Line.Numbers.text=在行號上顯示中斷點
action.XDebugger.ToggleEvaluateExpressionField.text=顯示“對表達式求值”欄位
action.XDebugger.ToggleSortValues.description=在偵錯器檢視中按字母順序排列值
action.XDebugger.ToggleSortValues.text=按字母順序對變數進行排序
action.XDebugger.UnmuteOnStop.text=在會話完成時取消忽略中斷點
action.XSD2Document.text=從 XML 檔案生成 XSD 架構…
action.XcodeBuildSwiftDocumentationAction.description=為所有目標建置文檔
action.XcodeBuildSwiftDocumentationAction.text=建置文檔
action.XcodePreviewSwiftDocumentationAction.description=為所有目標建置並預覽文檔
action.XcodePreviewSwiftDocumentationAction.text=預覽文檔
action.ZoomCurrentWindow.description=縮放當前視窗
action.ZoomCurrentWindow.text=縮放
action.ZoomInIdeAction.text=放大 IDE
action.ZoomOutIdeAction.text=縮小 IDE
action.compare.archives.text=比較歸檔
action.compare.files.text=比較檔案
action.compare.text=比較
action.compare.with.text=比較物件…
action.editRunConfigurations.description=開啟“編輯執行/偵錯組態”對話框
action.editRunConfigurations.text=編輯組態(_R)…
action.fontEditorPreview.ToggleBoldFont.text=切換加粗的字體
action.main.toolbar.Filename.text=檔名小工具(當編輯器頁籤被隱藏或啟用了“始終顯示完整路徑”選項時)
action.main.toolbar.Project.text=專案小工具
action.multilaunch.AddExecutableAction.text=新增組態或任務
action.multilaunch.CancelExecutableAction.text=取消
action.multilaunch.DebugMultiLaunchAction.text=偵錯
action.multilaunch.DeleteExecutableAction.text=刪除
action.multilaunch.EditExecutableAction.text=編輯…
action.multilaunch.RunMultiLaunchAction.text=執行
action.multilaunch.StopMultiLaunchAction.text=停止
action.openAssertEqualsDiff.text=檢視 assertEquals 差異
action.performancePlugin.ShowMemoryDialogAction.description=顯示更改記憶體對話框
action.performancePlugin.ShowMemoryDialogAction.text=更改記憶體設定
action.plugins.autoupdate.repository.view.text=檢視延伸模組自動更新儲存庫
action.redo.description=重做{0}
action.redo.description.empty=最後的撤消動作
action.redo.text=重做{0}(_R)
action.separator=分隔符
action.synonym.Vcs.ShowHistoryForBlock.class.text=顯示類別的歷史記錄…
action.synonym.Vcs.ShowHistoryForBlock.method.text=顯示方法的歷史記錄…
action.undo.description=撤消{0}
action.undo.description.empty=最後動作
action.undo.text=撤消{0}(_U)
apply.toolbar.customization=套用
group.$LRU.GoToAction.text=開啟最近的專案
group.$LRU.description=最近開啟專案的列表
group.$LRU.text=最近的專案(_R)
group.ActiveToolwindowGroup.text=活動工具視窗
group.AnalyzeActionsPopup.text=分析程式碼
group.AnalyzeJavaMenu.description=分析 Java 選單
group.AnalyzeJavaMenu.text=分析 Java 選單
group.AnalyzeMenu.text=分析(_Z)
group.ArrangementRulesGroup.text=排列規則
group.BackgroundTasks.text=背景任務
group.Bookmarks.Goto.text=按數字/助記鍵轉到
group.Bookmarks.Toggle.text=按數字/助記鍵切換
group.Bookmarks.text=書籤
group.BreakpointActionsGroup.text=切換中斷點
group.BuildArtifactsGroup.text=建置工件
group.BuildMenu.text=建置(_B)
group.CacheRecovery.text=快取恢復
group.ChangeLineSeparators.text=行分隔符
group.ChangeMainMenuModeActionGroup.text=主選單
group.ChangeProjectColorActionGroup.text=更改專案顏色
group.ChangesView.Changelists.text=更改列表
group.ChangesView.GroupBy.text=分組依據
group.CleanupEventLog.description=移除所有未發送事件日誌檔案
group.CleanupEventLog.text=清理 事件日誌
group.CloseEditorsGroup.text=編輯器關閉動作
group.CodeCompletionGroup.text=程式碼補全(_C)
group.CodeEditorBaseGroup.text=程式碼編輯器檢視動作
group.CodeEditorViewGroup.text=程式碼檢視動作
group.CodeFormatGroup.text=程式碼格式設定動作
group.CodeMenu.text=程式碼(_C)
group.CommentGroup.text=註釋動作
group.CommitView.ShowOnDoubleClick.text=雙擊時顯示
group.ConvertIndentsGroup.text=轉換縮排
group.Copy.Paste.Special.description=複製/貼上特殊編輯器動作
group.Copy.Paste.Special.text=複製/貼上特殊
group.CopyReferencePopupGroup.text=複製路徑/參照…
group.CoverageMenu.text=程式碼覆蓋率動作
group.CreateRunConfiguration.description=根據當前上下文建立執行組態
group.CreateRunConfiguration.text=建立執行組態
group.CustomLayoutActionsGroup.text=工具視窗布局
group.CustomLayoutsGroup.text=工具視窗布局列表
group.CustomizeMainToolbarGroup.text=自訂主工具列
group.CutCopyPasteGroup.text=剪下/複製/貼上動作
group.DebugMainMenu.text=偵錯器動作
group.DebugToolbarQuickActions.text=新增到偵錯器工具列
group.Debugger.ViewAsGroup.text=檢視方式
group.DebuggingActionsGroup.text=偵錯動作
group.Diff.Binary.Settings.text=設定
group.Diff.KeymapGroup.text=差異與合併
group.Documentation.Navigation.text=快速文檔導覽
group.EditBookmarksGroup.text=書籤(_K)
group.EditCreateDeleteGroup.text=編輯器建立/刪除動作
group.EditMenu.text=編輯(_E)
group.EditSelectGroup.text=編輯器選擇動作
group.EditSelectWordGroup.text=選擇單詞動作
group.EditSmartGroup.text=編輯程式碼動作
group.EditorActions.text=編輯器動作
group.EditorBidiTextDirection.description=混合 LTR/RTL 文本的主要方向
group.EditorBidiTextDirection.text=雙向文本基礎方向
group.EditorBreadcrumbsSettings.description=切換路徑導覽列設定
group.EditorBreadcrumbsSettings.text=路徑導覽
group.EditorGutterPopupMenu.Appearance.text=外觀
group.EditorGutterPopupMenu.text=編輯器裝訂區域彈出選單
group.EditorLangPopupMenu.text=編輯器彈出視窗選單動作(2)
group.EditorPopupMenu.GoTo.description=轉到編輯器彈出視窗選單組
group.EditorPopupMenu.GoTo.text=轉到
group.EditorPopupMenu.Run.text=編譯/執行動作
group.EditorPopupMenu.description=編輯器彈出視窗選單
group.EditorPopupMenu.text=編輯器彈出視窗選單
group.EditorPopupMenu1.text=編輯器彈出視窗選單動作(1)
group.EditorPopupMenuDebug.text=偵錯動作
group.EditorStickyLinesSettings.description=切換粘性行面板設定
group.EditorStickyLinesSettings.text=粘性行
group.EditorTabPopupMenu.text=編輯器頁籤彈出視窗選單
group.EditorTabPopupMenuEx.text=編輯器頁籤彈出視窗選單動作(1)
group.EditorTabsEntryPoint.text=最近的檔案、頁籤動作等
group.EditorTabsGroup.text=編輯器頁籤(_T)
group.EditorToggleActions.text=活動編輯器
group.Emmet.text=Emmet
group.ExpandAllToLevel.text=全部展開到級別(_L)
group.ExpandToLevel.text=展開到級別(_E)
group.ExportImportGroup.text=管理 IDE 設定
group.ExternalSystem.ShowSettingsGroup.text=建置工具設定
group.ExternalToolsGroup.text=外部工具
group.FeatureUsage.Internal.text=功能用法統計資訊
group.FileChooserSettings.text=檔案選擇器設定
group.FileChooserToolbar.text=檔案選擇器工具列
group.FileExportGroup.text=匯出
group.FileHistory.KeymapGroup.text=檔案歷史記錄
group.FileMainSettingsGroup.text=設定動作
group.FileMenu.text=檔案(_F)
group.FileOpenGroup.text=檔案開啟動作
group.FileOtherSettingsGroup.text=新增專案設定
group.FilePropertiesGroup.text=檔案屬性
group.FileSettingsGroup.text=設定動作
group.FindMenuGroup.text=尋找(_F)
group.FindUsagesMenuGroup.text=尋找用法
group.Floating.CodeToolbar.Extract.text=提取
group.Floating.CodeToolbar.Surround.text=包圍
group.Floating.CodeToolbar.text=浮動程式碼工具列
group.FoldingGroup.text=折疊
group.GenerateGroup.text=生成(_G)
group.GoToChangeMarkerGroup.text=更改導覽動作
group.GoToCodeGroup.text=通過參照轉到
group.GoToErrorGroup.text=轉到錯誤/書籤動作
group.GoToMenu.text=導覽(_N)
group.GoToTargetEx.text=通過名稱轉到
group.Graph.AlignNodesGroup.text=對齊
group.Graph.AppearanceGroup.text=外觀
group.Graph.BehaviourGroup.text=行為
group.Graph.CommonLayoutGroup.text=布局
group.Graph.DistributeNodesGroup.text=分散排列
group.Graph.EdgeRealizerGroup.text=邊緣形狀
group.Graph.ExportGroup.text=匯出圖
group.Graph.LayoutOrientationGroup.text=方向
group.Graph.MergeEdgesGroup.text=合併邊緣
group.Graph.NeighborhoodViewPopup.AppearanceGroup.text=外觀
group.Graph.NeighborhoodViewPopup.LayoutGroup.text=布局
group.Graph.NetsLayoutGroup.text=網狀
group.Graph.OrthogonalLayoutGroup.text=正交
group.Graph.RadialLayoutGroup.text=徑向
group.Graph.TreeLayoutGroup.text=樹
group.Graphs.KeymapGroup.text=圖表
group.HelpDiagnosticTools.text=診斷工具
group.HelpMenu.text=幫助(_H)
group.HierarchyGroup.text=層次結構動作
group.ImportTests.text=匯入測試結果
group.InlineCompletion.Settings.text=內聯補全提供程序的設定
group.InlineCompletion.description=內聯補全
group.InlineCompletion.text=內聯補全
group.InspectCodeGroup.text=檢查程式碼動作
group.Internal.Dump.text=傾印
group.Internal.Editor.text=編輯器(&E)
group.Internal.Errors.text=異常
group.Internal.HeapAnalysis.text=堆分析
group.Internal.Java.text=Java
group.Internal.PMM.text=PMM 實用工具
group.Internal.Performance.text=性能
group.Internal.Trust.text=原始碼安全性
group.Internal.UI.Animation.text=動畫
group.Internal.UI.Demos.text=示範
group.Internal.UI.Focus.text=焦點
group.Internal.UI.Icons.text=圖示
group.Internal.UI.KotlinUiDsl.text=Kotlin UI DSL
group.Internal.UI.text=UI(&U)
group.Internal.VFS.text=VFS
group.Internal.WorkspaceModel.text=工作區模型
group.Internal.text=內部動作(&I)
group.Internal1.text=IDEA 內部動作
group.IntroduceActionsGroup.text=提取/引入(_X)
group.LayoutsGroup.MainMenu.text=布局(_L)
group.LayoutsGroup.text=工具視窗布局(_L)
group.LeftToolbarSideGroup.text=左側
group.ListActions.text=列表動作
group.LocalChangesView.ShowOnDoubleClick.text=雙擊時顯示
group.Macros.description=檢視、更改、錄製、執行巨集
group.Macros.text=巨集(_S)
group.MacrosGroup.text=巨集動作
group.MainMenu.text=主選單
group.MainToolBar.text=主工具列
group.MainToolbarCenter.text=中心
group.MainToolbarGeneralActionsGroup.text=一般動作
group.MainToolbarLeft.text=左側
group.MainToolbarQuickActions.text=將動作新增到主工具列
group.MainToolbarRight.text=右側
group.MaintenanceGroup.text=維護
group.MarkContentRootGroup.text=將目錄標記為內容根
group.MarkFileAs.text=將檔案標記為
group.MarkRootGroup.text=將目錄標記為
group.MigrationMenu.text=遷移軟體套件和類別
group.MoreActionGroup.text=更多
group.MoveModuleToGroup.description=移動模組(_M)
group.MoveModuleToGroup.text=將模組移至組
group.NavbarLocationGroup.description=選擇導覽列的位置
group.NavbarLocationGroup.text=導覽列
group.NavbarPopupMenu.text=導覽列
group.NavigateInFileGroup.text=在檔案中導覽
group.NewElement.text=新增(_N)
group.NewElementInMenuGroup.text=新增(_N)
group.NewElementMenu.text=新增(_N)
group.NewFromTemplate.text=從模板
group.NewGroup.text=新增(_N)
group.NewGroup1.text=新組(1)
group.NewMicroservices.text=微服務模板
group.NewWebDevelopment.text=Web 開發模板
group.NewXml.text=XML
group.NewXmlDescriptor.text=XML 組態檔案
group.Notifications.text=通知
group.OpenEventLogFileAction.description=在 IDE 中開啟有效事件日誌檔案
group.OpenEventLogFileAction.text=在編輯器中開啟事件日誌
group.OpenInBrowserEditorContextBarGroupAction.description=開啟位置…
group.OpenInBrowserEditorContextBarGroupAction.text=開啟位置…
group.OpenInBrowserGroup.RevealInPopup.text=瀏覽器
group.OpenProjectGroup.text=開啟專案動作
group.OpenProjectWindows.text=開啟專案視窗
group.OpenRecentEditorInBlankDiffWindow.text=切換到最近
group.OverrideFileTypeAction.bundledPlugin=捆綁
group.OverrideFileTypeAction.fromNamedPlugin=自 ''{0}'' 延伸模組
group.OverrideFileTypeAction.title=選擇檔案類型
group.PairFileActions.text=檔案對的動作
group.PasteGroup.text=貼上
group.Patch.MainMenu.text=補丁檔案
group.PopupMenuActions.text=彈出選單動作
group.PrintExportGroup.text=列印/匯出動作
group.ProblemsView.Options.description=允許對問題進行分類和篩選
group.ProblemsView.Options.text=檢視選項
group.ProblemsView.Show.text=顯示
group.ProblemsView.SortBy.text=排序依據
group.ProjectView.ToolWindow.Appearance.Actions.text=外觀
group.ProjectView.ToolWindow.Appearance.Show.text=顯示
group.ProjectView.ToolWindow.Behavior.Actions.text=行為
group.ProjectView.ToolWindow.SecondaryActions.text=專案檢視選項
group.ProjectView.ToolWindow.Sort.Actions.text=排序依據
group.ProjectViewAnalysisGroup.text=分析動作
group.ProjectViewCompileGroup.text=編譯/偵錯動作
group.ProjectViewPopupMenu.text=專案檢視彈出視窗選單
group.ProjectViewPopupMenuModifyGroup.text=專案檢視彈出視窗選單修改組
group.ProjectViewPopupMenuRefactoringGroup.text=專案檢視彈出視窗重構組
group.ProjectViewPopupMenuRunGroup.text=專案檢視彈出視窗選單執行組
group.ProjectViewPopupMenuSettingsGroup.text=專案檢視彈出視窗選單設定組
group.RefactoringMenu.text=重構(_R)
group.RefactoringMenu1.text=重構動作(1)
group.RefactoringMenu2.text=重構動作(2)
group.RegistrationActions.text=註冊動作
group.ResizeToolWindowGroup.text=調整大小
group.RevealGroup.text=開啟於
group.RightToolbarSideGroup.text=右側
group.RunContextGroupMore.text=更多執行/偵錯
group.RunContextPopupGroup.text=執行組態
group.RunDashboard.ViewOptions.text=執行組態
group.RunMenu.text=執行(_U)
group.Runner.Layout.description=布局組態
group.Runner.Layout.text=布局
group.RunnerActions.text=執行/偵錯
group.RunnerActionsTouchbar.text=Touch Bar 執行/偵錯動作
group.ScrollPaneActions.text=滾動
group.SearchEverywhereActions.text=隨處搜尋
group.ServiceView.AddService.text=新增服務
group.ServiceView.OpenInNewTabGroup.text=在新頁籤中開啟
group.ServiceView.ViewOptions.text=檢視選項
group.SettingsEntryPoint.text=IDE 和專案設定
group.Shelve.KeymapGroup.text=擱置
group.ShelvedChangesToolbar.ViewOptions.text=檢視選項
group.ShowAnnotateOperationsPopupGroup.text=註解行
group.ShowFilterPopup.text=顯示篩選器彈出視窗
group.ShowRecentFindUsagesGroup.description=選擇並重新執行最近的尋找用法
group.ShowRecentFindUsagesGroup.text=最近的尋找用法
group.SplitChooser.Actions.text=使用選擇器導覽拆分
group.StandardMacroActions.text=標準巨集動作
group.SwitcherAndRecentFiles.text=切換器(RecentFiles)動作
group.SwitcherAndRecentFilesFallback.text=切換器(RecentFiles)動作
group.TW.ViewModeGroup.text=檢視模式
group.TWViewModes.text=工具視窗檢視模式
group.TWViewModesLegacy.text=工具視窗傳統檢視模式(已棄用)
group.TableActions.text=表動作
group.TabsActions.text=頁籤
group.TextEditorWithPreview.SplitGroup.text=拆分布局
group.TipsAndFeatures.text=提示和功能
group.TodoMainGroup.text=TODO
group.TodoViewGroupByGroup.text=分組依據
group.ToggleBreakpointAction.text=中斷點動作
group.ToolWindowsGroup.text=工具視窗(_T)
group.ToolbarFindGroup.text=工具列尋找動作
group.ToolbarMakeGroup.text=工具列 Make 動作
group.ToolbarRunGroup.text=工具列執行動作
group.ToolsBasicGroup.text=基本工具組
group.ToolsMenu.Services.text=服務
group.ToolsMenu.text=工具(_T)
group.ToolsXmlGroup.text=XML 動作
group.TopAnomalies.text=熱門異常
group.TopStripeActionGroup.text=單個工具視窗列
group.TouchBar.text=觸控列
group.TouchBarDebug.ForceStepButtons.text=偵錯器強制步動作
group.TouchBarDebug.StepButtons.text=偵錯器步動作
group.TouchBarDebug.text=偵錯器
group.TouchBarDebug_alt.text=使用 Alt 鍵的偵錯器
group.TouchBarDefault.text=預設
group.TouchBarDefaultOptionalGroup.text=可選動作
group.TouchBarDefault_alt.text=預設使用 Alt 鍵
group.TouchBarDefault_cmd.alt.text=預設使用 Alt+Cmd 鍵
group.TouchBarDefault_cmd.text=預設使用 Cmd 鍵
group.TouchBarDefault_ctrl.text=預設使用 Ctrl 鍵
group.TouchBarDefault_shift.text=預設使用 Shift 鍵
group.TreeActions.text=樹動作
group.UpdateEventsSchemeAction.description=如果必要，從伺服器更新主要事件方案。另外，從檔案重新載入測試事件方案。
group.UpdateEventsSchemeAction.text=更新事件方案
group.Vcs.Browse.text=瀏覽 VCS 儲存庫
group.Vcs.Import.text=匯入到版本控制
group.Vcs.KeymapGroup.text=版本控制系統
group.VcsFileGroupPopup.text=版本控制組
group.VcsGlobalGroup.text=VCS 組
group.VcsGroup.text=版本控制
group.VcsGroups.text=Git(_G)
group.VcsToolbarActions.text=VCS 動作
group.VersionControlsGroup.text=VCS/LVCS 動作
group.ViewAppearanceGroup.text=外觀(_A)
group.ViewMenu.text=檢視(_V)
group.ViewRecentActions.text=檢視最近的動作組
group.ViewStatusBarWidgetsGroup.description=顯示/隱藏狀態列小工具
group.ViewStatusBarWidgetsGroup.text=狀態列小工具(_W)
group.WeighingNewGroup.text=新增(_N)
group.WeighingNewGroup.text.popup=新增檔案(_N)…
group.WelcomeScreen.CreateDirectoryProject.description=建立一個新項目。
group.WelcomeScreen.CreateDirectoryProject.text=新增專案
group.WelcomeScreen.KeymapGroup.text=歡迎頁面
group.WelcomeScreen.MoveToGroup.text=移至組
group.WelcomeScreen.Options.text=選項選單
group.WindowMenu.text=視窗(_W)
group.XDebugger.Attach.Dialog.Settings.text=附加對話框設定
group.XDebugger.settings.text=偵錯器設定
group.XmlGenerateToolsGroup.text=XML 生成動作
group.compare.contents.text=比較內容
group.popup@ExpandableBookmarkContextMenu.text=書籤
group.reopen.mac.text=開啟最近(_R)
group.reopen.win.text=重新開啟專案(_R)
save.file.as.template=將檔案另存為模板
separator.RunDashboard.Filter=顯示
separator.RunDashboard.GroupBy=分組
separator.show=顯示
show.log.in.action.text=在{0}中顯示日誌
show.log.notification.text=檢視日誌"
`;

exports[`dev messages/DiffBundle.properties 1`] = `
"action.Anonymous.text.apply.non.conflicting.changes=套用不衝突的更改\\:
action.merge.apply.non.conflicts.all.text=所有
action.merge.apply.non.conflicts.left.text=左側
action.merge.apply.non.conflicts.right.text=右側
action.presentation.RefreshDirDiffAction.text=重新整理
action.presentation.diff.accept.text=接受
action.presentation.diff.append.text=追加
action.presentation.diff.append.to.the.side.text=追加到 {0, choice, 0\\#左側|1\\#右側}
action.presentation.diff.copy.text=複製
action.presentation.diff.include.into.commit.area.marker.text=現在，差異檢視中忽略了此區塊中的某些更改。<br>選中該複選框，您將包括此列指示要提交的所有行。
action.presentation.diff.include.into.commit.text=包含到提交中
action.presentation.diff.revert.text=還原
action.presentation.go.to.change.text=轉到更改
action.presentation.merge.ignore.text=忽略
action.presentation.merge.resolve.automatically.text=自動解決
action.presentation.merge.resolve.text=解決
action.presentation.merge.resolve.using.side.text=使用{0, choice, 0\\#左側|1\\#右側} 解決
action.use.external.tool.text=使用以下內容顯示差異\\: {0}
advanced.setting.enable.combined.diff=一體化差異
advanced.setting.enable.combined.diff.description=如果啟用，所有更改的檔案都會顯示在單個可滾動差異檢視中
advanced.setting.show.diff.as.editor.tab=作為編輯器頁籤開啟差異
advanced.setting.show.diff.as.editor.tab.description=如果啟用，差異將顯示在編輯器頁籤中，而不是單獨的視窗中
advanced.settings.vcs=版本控制
apply.changes.and.mark.resolved=套用更改並標記為已解決
apply.partially.resolved.merge.dialog.title=套用更改
apply.patch.all.changes.processed.message.text=儲存更改並完成解析
apply.patch.all.changes.processed.title.text=所有區塊均已處理
apply.patch.partially.resolved.changes.confirmation.message={0, choice, 1\\#1 個區塊|2\\#{0, number} 個區塊}未處理。\\n要儲存更改並完成解決嗎?
apply.somehow.status.message.all.applied=已解決所有區塊
apply.somehow.status.message.already.applied={0, number} 個{0, choice, 1\\#區塊|2\\#區塊}已套用
apply.somehow.status.message.cant.apply=無法套用 {0, number} 個{0, choice, 1\\#區塊|2\\#區塊}
apply.somehow.status.message.cant.apply.some=無法套用 {0, number} 個區塊，共 {1, number} 個
binary.diff.contents.are.different.message.text=檔案內容不同
binary.diff.contents.are.identical.message.text=檔案內容相同
binary.file.viewer=二進制檔案檢視器
blank.diff.recent.content.summary.text.date={0} ({1})
blank.diff.recent.content.summary.text.length.date={0} ({1} 字元，{2})
button.abort.resolve=中止解決
button.associate.file.type=關聯
button.cancel.merge=取消合併
button.continue.merge=繼續合併
button.dirdiff.filter=過濾(&F)\\:
button.discard.changes.and.do=捨棄更改並{0}
button.hide.notification=隱藏
button.merge.resolve.accept.left=接受左側
button.merge.resolve.accept.right=接受右側
button.merge.resolve.apply=套用
button.merge.resolve.cancel=取消
button.reload.diff.request=重新載入
can.t.copy.file=無法複製檔案
can.t.finish.merge.resolve=無法解決合併衝突
can.t.load.some.changes=無法載入某些更改
can.t.show.diff.in.external.tool=無法在外部工具中顯示差異
can.t.show.diff.in.external.tool.too.many.files=選擇的檔案過多，無法使用外部工具開啟，{0} 未開啟。
can.t.show.merge.in.external.tool=無法在外部工具中顯示合併
cancel.visual.merge.dialog.title=取消檔案合併
cannot.create.file.error=無法建立檔案\\: {0}
cannot.find.file.error=找不到檔案\\: {0}
changing.highlighting.requires.the.file.merge.restart=更改醒目提示需要重啟檔案合併。是否捨棄未儲存的更改並重啟合併?
collapse.unchanged.fragments=摺疊未更改的片段
column.dirdiff.date=日期
column.dirdiff.name=名稱
column.dirdiff.size=大小
combined.diff.files.count={0, choice, 0\\#無檔案|1\\#1 個檔案|2\\#{1}/'<a href\\="">'{0} 個檔案'</a>'}
combined.side.by.side.viewer=拆分
combined.unified.viewer=統合
compare.0.with.1=比較 ''{0}'' 和 ''{1}''
compare.by=比較依據\\:
compare.selected.new.files=將左側和右側的所選新檔案相互比較。
configurable.DiffSettingsConfigurable.display.name=差異與合併
configurable.ExternalDiffSettingsConfigurable.display.name=外部差異工具
configurable.diff.collapse.unchanged.ranges.disable=停用
confirm.delete=確認刪除
continue.merge=繼續合併
copy.content.to.side=將內容複製到{0, choice, 0\\#左側|1\\#右側}
data.has.been.changed.externally.reloading.data=資料已在外部更改。正在重新載入資料…
delete.0.items=刪除 {0} 項?
dialog.title.diff.for.range=範圍的差異
diff.actions=差異動作
diff.all.differences.ignored.text=已忽略差異
diff.application.usage.parameters.and.description=用法\\: {0} 差異 <left file> <right file> [<base file>]
diff.cant.calculate.diff=無法計算差異
diff.clipboard.vs.editor.dialog.title=剪貼簿與編輯器
diff.clipboard.vs.editor.dialog.title.with.filename=剪貼簿 vs {0}
diff.clipboard.vs.value.dialog.title=剪貼簿與所選值
diff.content.clipboard.content.title=來自剪貼簿
diff.content.editor.content.title=編輯器
diff.content.selected.value=所選值
diff.content.selection.from.file.content.title={0}中的選區
diff.content.title.current.range=當前
diff.content.title.up.to.date=基本修訂
diff.contents.are.identical.message.text=內容相同
diff.contents.have.differences.only.in.charset.and.line.separators.message.text=內容僅在行分隔符和編碼中有差異
diff.contents.have.differences.only.in.charset.message.text=內容僅在編碼中有差異
diff.contents.have.differences.only.in.line.separators.message.text=內容僅在行分隔符中有差異
diff.count.differences.status.text={0, choice, 0\\#沒有|1\\#1個|2\\#{0, number}個}差異
diff.element.qualified.name.vs.element.qualified.name.dialog.title={0} 與 {1}
diff.file.editor.name=差異
diff.files.count.files.in.text=({0} 中)
diff.files.count.hyperlink.text={0} 個檔案
diff.files.dialog.title=差異
diff.files.editors.search.files.count={0,choice,1\\#{0} 個檔案|2\\#{0} 個檔案}
diff.files.editors.search.matches={0, choice, 0\\#{1} 中有 0 個結果|1\\#{1} 中有 1 個結果|2\\#{1} 中有 {0} 個結果}
diff.files.editors.search.partly.matches={0, choice, 0\\#{1} 中有 0+ 個結果|1\\#{1} 中有 1+ 個結果|2\\#{1} 中有 {0}+ 個結果}
diff.files.generic.request.title=更改
diff.highlighting.disabled.text=差異醒目提示處於關閉狀態
diff.inactive.count.differences.status.text=({0} 停用)
diff.included.count.differences.status.text=，包括 {0}
diff.progress.spinner.tooltip.text=正在計算差異
diff.tool=差異工具
diff.type.changed.name=已更改
diff.type.conflict.name=衝突
diff.type.deleted.name=已刪除
diff.type.inserted.name=已插入
diff.unchanged.lines.folding.marker.renderer=標記\\: 已摺疊的未更改的行
diff.utf.charset.name.bom.suffix={0} BOM
diff.version.title.after=之後
diff.version.title.before=之前
dirdiff.filter.help.description=<p>要包含檔案，請輸入符合模式。</p><p>要排除檔案，請在模式前新增 <code>\\!</code>。</p><p>使用 <code>\\\\&</code> 和 <code>|</code> 分別通過 <code>AND<code/> 和 <code>OR<code/> 運算組合多個篩選器。</p><p><b>範例</b>\\:</p><ul><li><code>*.txt</code> 會驗證以 .txt 結尾的所有路徑。</li><li><code>\\!build/*</code> 會排除位於 <code>build</code> 目錄內的所有檔案。</li><li><code>*.txt\\\\&\\!build/*</code> 會驗證以 <code>.txt</code> 結尾且不位於 <code>build</code> 目錄內的所有路徑。</li></ul>
dirdiff.filter.help.title=篩選模式
dirdiff.mode.binary.content=二進制內容
dirdiff.mode.size=大小
dirdiff.mode.size.and.timestamp=大小和時間戳
dirdiff.mode.text=文本
directory.diff=目錄差異
directory.diff.actions=目錄差異動作
directory.viewer=目錄檢視器
disable.editing=停用編輯
discard.changes.and.restart.merge=捨棄更改並重啟合併
do.not.ask.me.again=不再詢問我
editing.viewer.hint.enable.editing.text=此檢視為唯讀。<a href\\="">啟用編輯</a>
editor.settings=設定
error.can.not.calculate.diff.file.too.big=無法計算差異。檔案太大且更改太多。
error.can.not.calculate.diff.operation.canceled=無法計算差異。動作已取消。
error.cannot.show.diff=無法顯示差異
error.cannot.show.merge=無法顯示合併
error.cant.resolve.conflicts.in.a.read.only.file=無法解決唯讀檔案中的衝突
error.cant.show.diff.cant.load.revision.content=無法獲取此修訂中的內容
error.cant.show.diff.cant.show.for.directory=無法顯示目錄的差異
error.cant.show.diff.content.not.found=無法顯示差異\\: 找不到內容
error.cant.show.diff.file.not.found=無法顯示差異\\: 找不到檔案
error.cant.show.diff.for.unknown.file=無法顯示未知檔案類型的差異
error.cant.show.diff.message=錯誤\\: 無法顯示差異
error.cant.show.dirdiff.preview.cant.load.content=無法獲取內容
error.cant.show.file=無法顯示檔案
error.cant.show.merge.file.not.found=無法顯示合併衝突\\: 找不到檔案
error.cant.show.merge.operation.not.supported=無法顯示合併衝突\\: 此動作不受支援
error.cant.show.merge.project.not.found=無法顯示合併衝突\\: 未知專案類型
error.conflict.is.not.valid.and.no.longer.can.be.resolved=衝突無效，無法再解決。
error.content.decoded.with.wrong.charset=內容解碼出錯(使用 ''{0}'' 字符集)
error.file.is.not.valid=文本表示不再映射到磁碟上的檔案內容
error.file.is.too.large.only.preview.is.loaded=檔案太大。僅載入預覽。
error.files.too.large.to.compare.text=檔案太大，無法比較
error.message.cannot.show.diff=無法顯示差異
error.message.cannot.show.merge=無法顯示合併
error.operation.canceled=動作已被取消
error.viewer=錯誤檢視器
filetype.diff.description=差異
hide.this.notification=隱藏此通知
highlight.words=醒目提示顯示單詞
highlighting.level=醒目提示級別
label.cant.show.diff.with.description=無法顯示差異\\: {0}
label.cant.show.merge.with.description=無法顯示合併\\: {0}
label.default.diff.editor.tab.name=差異
label.diff.settings.path=設定 | 工具 | 差異與合併
label.diff.settings.path.macos=偏好設定 | 工具 | 差異與合併
label.dirdiff.loading.file=正在載入… {0}
label.merge.unsaved.changes.discard.and.do.anyway=結果檔案中有未儲存的更改。捨棄更改並繼續{0}嗎?
launching.external.tool=正在啟動外部工具…
mark.as.resolved=標記為已解決
merge.all.changes.processed.message.text=儲存更改並完成合併
merge.all.changes.processed.title.text=所有更改均已處理
merge.application.usage.parameters.and.description=用法\\: {0} 合併 <left file> <right file> [<base file>] <output file>
merge.color.options.background.color.label=重要
merge.color.options.dialog.title=合併顏色選項
merge.color.options.ignored.color.label=已忽略
merge.conflict.is.outdated=合併衝突已過時。在衝突解決開始之前還原檔案內容?
merge.continue.button=繼續(&C)
merge.dialog.accept.change.command=接受更改
merge.dialog.all.conflicts.resolved.message.text=已解決所有衝突
merge.dialog.apply.non.conflicted.changes.command=套用不衝突的更改
merge.dialog.apply.partially.resolved.changes.confirmation.message={0, choice, 0\\#'{1, choice, 1\\#有|2\\#有}'|1\\#有|2\\#有} {0, choice, 0\\#|1\\#1 個更改|2\\#{0, number} 個更改}{0, choice, 0\\#|1\\#'{1, choice, 0\\#|1\\#和 }'}{1, choice, 0\\#|1\\#1 個衝突|2\\#{1, number} 個衝突}未處理。\\n仍要儲存更改並將衝突標記為解決嗎?
merge.dialog.exit.without.applying.changes.confirmation.message=確定要登出且不套用更改嗎?
merge.dialog.ignore.change.command=忽略更改
merge.dialog.reset.change.command=重設已解決的更改
merge.dialog.resolve.conflict.command=解決衝突
merge.differences.status.text={0, choice, 0\\#沒有更改|1\\#1 個更改|2\\#{0, number} 個更改}。{1, choice, 0\\#沒有衝突|1\\#1 個衝突|2\\#{1, number} 個衝突}。
merge.files.dialog.title=合併
merge.in.external.tool=在外部工具中合併
merge.save.and.finish.button=儲存並完成(&F)
merge.tool=合併工具
merge.version.title.base=基礎版本
merge.version.title.current=當前版本\\:
merge.version.title.merged=合併版本
merge.version.title.merged.result=結果
merge.version.title.our=您的版本
merge.version.title.their=來自伺服器的更改
merge.version.title.their.with.revision=來自伺服器的更改 (修訂版 {0})
merge.window.title.file=合併 {0}
message.do.in.merge.command=合併時 {0}
message.init.merge.content.command=初始化合併內容
message.replace.change.command=取代更改
message.resolve.simple.conflicts.command=解決簡單的衝突更改
message.use.selected.changes.command={0}所選更改
notification.action.text.blank.diff.recent=最近
notification.action.text.blank.diff.select.file=選擇檔案…
notification.status.content.added=內容已新增
notification.status.content.removed=內容已移除
notification.you.can.disable.this.feature.in.0=您可以在 {0} 中停用此功能
option.highlighting.level.inspections=檢查
option.highlighting.level.none=無
option.highlighting.level.syntax=語法
option.highlighting.policy.group.name=醒目提示顯示模式
option.highlighting.policy.lines=醒目提示行
option.highlighting.policy.none=不醒目提示顯示
option.highlighting.policy.split=醒目提示拆分的更改
option.highlighting.policy.symbols=醒目提示顯示字元
option.highlighting.policy.words=醒目提示顯示單詞
option.ignore.policy.formatting=忽略格式設定
option.ignore.policy.group.name=忽略更改
option.ignore.policy.language.specific.changes=忽略針對特定語言的更改
option.ignore.policy.none=不忽略
option.ignore.policy.trim=修整空白
option.ignore.policy.whitespaces=忽略空格
option.ignore.policy.whitespaces.empty.lines=忽略空格和空行
option.inherit.ignored.color=繼承忽略的顏色
option.three.side.color.policy.left.to.right=左到右
option.three.side.color.policy.merge.conflict=合併衝突
option.three.side.color.policy.merge.resolved=解決的合併衝突
patch.dialog.copy.change.command=複製到剪貼簿
patch.dialog.copy.change.command.balloon=已複製到剪貼簿
patch.editing.viewer.hint.enable.editing.text=此檢視為唯讀。<a href\\="">切換到編輯</a>
press.again.to.go.to.the.next.file=再按一次轉到下一個檔案
press.again.to.go.to.the.previous.file=再按一次轉到上一個檔案
press.mark.as.resolve=在外部工具中解決完衝突時，按“標記為已解決”
progress.title.loading.requests=正在載入請求…
refresh.failed.message=重新整理失敗\\: {0}
rollback.change.command.name=復原更改
select.external.program.dialog.title=選擇外部程序
select.file.to.compare=選擇要比較的檔案
settings.automatically.apply.non.conflicting.changes=自動套用不衝突的更改
settings.automatically.resolve.imports.conflicts=自動解決 import 語句中的衝突
settings.context.lines=上下文行\\:
settings.diff.name=差異
settings.diffIncludedInHistory=包括導覽歷史記錄中的差異\\:
settings.diffIncludedInHistory.always=始終
settings.diffIncludedInHistory.never=從不
settings.diffIncludedInHistory.onlyIfOpen=直到差異關閉
settings.external.diff.base.file.content=基檔案內容
settings.external.diff.comboBox.value.unknown.filetype.text={0} (未知)
settings.external.diff.enable.external.tools=啟用外部工具
settings.external.diff.left.file.content=左側檔案內容
settings.external.diff.merge.conflict.resolve.successful=合併衝突解決成功。\\n已解決的內容為\\:\\n{0}
settings.external.diff.merge.conflict.resolve.was.canceled=合併衝突解決已取消。
settings.external.diff.original.output.file.content=原始輸出檔案內容
settings.external.diff.panel.table.title=組態與檔案類型關聯的外部差異/合併工具\\:
settings.external.diff.panel.tree.title=組態外部工具\\:
settings.external.diff.right.file.content=右側檔案內容
settings.external.diff.table.difftool.column=差異工具
settings.external.diff.table.filetype.column=檔案類型
settings.external.diff.table.filetype.default=預設
settings.external.diff.table.mergetool.column=合併工具
settings.external.diff.table.remove.dialog.message=確定要刪除此條目嗎?
settings.external.diff.table.remove.dialog.title=移除外部差異工具
settings.external.diff.table.tool.default=內建
settings.external.diff.test.complete=測試完成
settings.external.diff.test.diff=測試差異
settings.external.diff.test.merge=測試合併
settings.external.diff.test.three.side.diff=測試三向差異
settings.external.diff.trust.process.exit.code=信任程序離開程式碼
settings.external.tool.tree.add.dialog.field.argument.pattern=實參模式
settings.external.tool.tree.add.dialog.field.group=工具組
settings.external.tool.tree.add.dialog.field.program.path=程序路徑
settings.external.tool.tree.add.dialog.field.tool.name=工具名稱
settings.external.tool.tree.add.dialog.title=新增外部工具
settings.external.tool.tree.edit.dialog.title=編輯外部工具
settings.external.tool.tree.remove.warning.message=此工具用於組態。首先移除表中的組態
settings.external.tool.tree.remove.warning.title=無法刪除所選工具
settings.external.tool.tree.validation.already.exist=名稱為“{1}”的 {0} 已存在
settings.external.tool.tree.validation.empty=外部工具名稱不得為空
settings.external.tools.parameters.description=不同的工具有不同的參數。按正確的順序指定所有必要的參數非常重要\\:
settings.external.tools.parameters.diff=<b>%1</b> - 左(本地更改)<br><b>%2</b> - 右(伺服器內容)<br><b>%3</b> - 基礎(沒有本地更改的當前版本)
settings.external.tools.parameters.merge=<b>%1</b> - 左(本地更改)<br><b>%2</b> - 右(伺服器內容)<br><b>%3</b> - 基礎(沒有本地更改的當前版本)<br><b>%4</b> - 輸出(合併結果)
settings.external.tools.test.process.exit.text=程序已終止\\: exitCode ''{0}''
settings.go.to.the.next.file.after.reaching.last.change=到達上次更改後轉到下一個檔案
settings.highlight.modified.lines.in.gutter=在裝訂區域中醒目提示修改的行
settings.merge.text=合併
side.by.side.viewer=並排檢視器
synchronize.document.and.its.fragment=同步文檔及其片段
synchronize.document.and.its.fragment.range.error=選區無效
synchronize.editors.settings=同步編輯器設定
synchronize.scrolling=同步滾動
tooltip.merge.ctrl.click.to.resolve.conflict=Ctrl+點擊來解決衝突
unified.viewer=統合檢視器
update.highlighting.settings=更新醒目提示設定
use.space.button.or.mouse.click=使用空格按鈕或滑鼠點擊來更改選定元素的動作。按回車鍵執行。
use.space.button.to.change.operation=使用空格按鈕更改動作
vcs.marker.changed.line=VCS 標記\\: 更改的行
waiting.for.external.tool=正在等待外部工具…
"
`;

exports[`dev messages/GitBundle.properties 1`] = `
"abort=中止
abort.operation.cherry.pick.name=優選
abort.operation.dialog.msg=中止 {0}{1}?
abort.operation.dialog.title=中止 {0}
abort.operation.failed={0} 中止失敗
abort.operation.indicator.text=git {0} --abort{1}
abort.operation.merge.name=合併
abort.operation.progress.title=正在中止 {0} 程序
abort.operation.rebase.name=重定基底
abort.operation.revert.name=還原
abort.operation.succeeded={0} 中止成功
action.CopyPathFromRepositoryRootProvider.text=版本庫根路徑
action.Git.Add.text=新增
action.Git.Branches.text=分支(_B)…
action.Git.BrowseRepoAtRevision.text=在修訂版中顯示版本庫
action.Git.CheckoutRevision.text=簽出修訂
action.Git.CherryPick.Abort.text=中止優選
action.Git.Clone.text=克隆…
action.Git.Commit.Stage.text=提交…
action.Git.Compare.Selected.Heads.description=顯示所選分支 head 之間的差異
action.Git.Compare.Selected.Heads.title=顯示檔案差異
action.Git.Compare.Selected.description=相互比較選定分支
action.Git.Compare.Selected.description.disabled=從同一版本庫中選擇分支
action.Git.Compare.Selected.title=比較分支
action.Git.Compare.With.Current.title=與當前分支進行比較
action.Git.CompareWithBranch.text=與分支或標籤比較…
action.Git.Configure.Remotes.text=管理遠端…
action.Git.CreateNewBranch.FromCommit.description=從所選提交開始建立新分支
action.Git.CreateNewBranch.FromCommit.text=新增分支…
action.Git.CreateNewBranch.text=新增分支…
action.Git.CreateNewTag.description=建立指向此提交的新標籤
action.Git.CreateNewTag.text=新增標記…
action.Git.Delete.Branch.title=刪除{0,choice,1#分支|2#分支}
action.Git.Drop.Commits.text=刪除提交
action.Git.Drop.Selected.Changes.text=刪除所選更改
action.Git.Fetch.description.fetch.in.progress=正在獲取…
action.Git.Fetch.text=獲取
action.Git.Fetch.title=獲取所有遠端
action.Git.Fixup.To.Commit.description=建立 fixup 提交
action.Git.Fixup.To.Commit.description.nothing.to.commit=沒有要提交的內容
action.Git.Fixup.To.Commit.text=Fixup…
action.Git.InMemory.Extract.Selected.Changes.description=根據所選更改建立一個新的提交，並將其直接放置在歷史記錄中原始提交之後
action.Git.InMemory.Extract.Selected.Changes.text=將所選更改獲取到單獨的提交…
action.Git.InMemory.Reword.Commit.description=通過記憶體中重定基底更改提交訊息
action.Git.InMemory.Reword.Commit.text=編輯提交訊息…(記憶體中)
action.Git.Init.Stage.error=向 Git 新增檔案失敗
action.Git.Init.Vcs.Toolbar.Widget.text=建立 Git 版本庫…
action.Git.Init.error=Git init 失敗
action.Git.Init.text=建立 Git 版本庫…
action.Git.Interactive.Rebase.description=顯示互動重定基底的對話框，可以在該對話中對提交執行壓縮、fixup、重新排序、移除和改寫
action.Git.Interactive.Rebase.text=從這裡進行互動重定基底…
action.Git.Loading.Branches.progress=正在載入分支…
action.Git.Log.Branches.Change.Branch.Filter.On.Selection.description=選擇分支後，按此分支篩選日誌
action.Git.Log.Branches.Change.Branch.Filter.On.Selection.text=更新分支篩選器
action.Git.Log.Branches.Change.Branch.Filter.description=使用所選分支更新日誌中的分支篩選器
action.Git.Log.Branches.Change.Branch.Filter.text=更新日誌中的分支篩選器
action.Git.Log.Branches.Navigate.Log.To.Branch.On.Selection.description=選擇分支後，在日誌中導覽到該分支 HEAD
action.Git.Log.Branches.Navigate.Log.To.Branch.On.Selection.text=在日誌中導覽到分支 Head
action.Git.Log.Branches.Navigate.Log.To.Selected.Branch.text=在日誌中導覽到所選分支 Head
action.Git.Log.DeepCompare.description=醒目提示尚未優選到當前分支的提交
action.Git.Log.DeepCompare.text=無優選提交
action.Git.Log.Edit.Remote.text=編輯遠端
action.Git.Log.Hide.Branches.text=隱藏 Git 分支
action.Git.Log.Remove.Remote.text=移除{0,choice,1#遠端|2#遠端}
action.Git.Log.Show.Branches.text=分支
action.Git.Log.Show.Command.text=顯示指令的 Git 日誌
action.Git.Log.text=顯示 Git 版本庫日誌…
action.Git.Merge.Abort.text=中止合併
action.Git.Merge.text=合併…
action.Git.New.Branch.description=僅選擇一個分支以繼續建立新分支
action.Git.New.Branch.dialog.title=從 {0} 建立分支
action.Git.Pull.text=拉取…
action.Git.Push.Tag.text=推送標籤
action.Git.Push.Tag.text.to=推送到{1,choice,0#|1# {2} 中的} {0}
action.Git.PushUpToCommit.description=推送所有之前的提交，包括所選提交
action.Git.PushUpToCommit.text=推送此前所有提交…
action.Git.Rebase.Abort.text=中止重定基底
action.Git.Rebase.Continue.text=繼續重定基底
action.Git.Rebase.Skip.progress.title=重定基底期間跳過提交…
action.Git.Rebase.Skip.text=跳過提交
action.Git.Rebase.operation.name=重定基底
action.Git.Rebase.text=重定基底…
action.Git.Reset.In.Log.text=將當前分支重設到此處…
action.Git.Reset.text=重設 HEAD…
action.Git.ResolveConflicts.text=解決衝突…
action.Git.Revert.Abort.text=中止還原
action.Git.Revert.In.Log.description=生成新提交，這會還原在原始提交中所做的更改
action.Git.Revert.In.Log.template.text=還原{0,choice,1#提交|2#提交}
action.Git.Revert.In.Log.text=還原提交
action.Git.RevertResolved.confirmation=是否要還原已解析的{0,choice,1#檔案|2#檔案}: {1}?
action.Git.RevertResolved.confirmation.title=還原已解析的檔案
action.Git.RevertResolved.progress=正在還原已解決的衝突…
action.Git.RevertResolved.text=還原已解決
action.Git.Reword.Commit.description=通過 git rebase 或 amend 的改寫選項更改提交訊息
action.Git.Reword.Commit.text=編輯提交訊息…
action.Git.Show.My.Branches.description.calculating.branches.progress=正在計算我的分支
action.Git.Show.My.Branches.description.is.my.branch=如果分支的所有獨佔提交都是由“我”(即當前 Git 作者)執行的，則此分支為“我的”。
action.Git.Show.My.Branches.description.not.all.roots.indexed=並沒有為所有版本庫編制索引。
action.Git.Show.My.Branches.description.not.graph.ready=該日志尚未就緒，請稍候。
action.Git.Show.My.Branches.description.not.support.indexing=某些版本庫不支持索引。
action.Git.Show.My.Branches.title=顯示我的分支
action.Git.Show.Stage.text=顯示暫存區域
action.Git.Show.Stash.With.Shelf.description=開啟“隱藏和擱置”頁籤
action.Git.Show.Stash.With.Shelf.text=顯示隱藏和擱置
action.Git.Show.Stash.description=開啟“Git 隱藏”頁籤
action.Git.Show.Stash.text=顯示 Git 隱藏
action.Git.ShowBranches.pretty.description=顯示分支
action.Git.ShowBranches.text=顯示分支
action.Git.Squash.Commits.description=互動重定基底以將所選提交合併為一個提交
action.Git.Squash.Commits.text=壓縮提交…
action.Git.Squash.Into.Commit.description=提交本地更改，以便將其壓縮到所選提交中
action.Git.Squash.Into.Commit.text=壓縮到…
action.Git.Stage.Add.All.description=將所有未暫存的更改和未追蹤的檔案新增到索引
action.Git.Stage.Add.All.text=全部暫存
action.Git.Stage.Add.Tracked.description=將追蹤檔案中所有未暫存的更改新增到索引
action.Git.Stage.Add.Tracked.text=暫存全部已追蹤項
action.Git.Stage.Compare.Local.Staged.text=與暫存版本比較
action.Git.Stage.Compare.Staged.Head.text=與 HEAD 版本比較
action.Git.Stage.Compare.Staged.Local.text=與本地版本比較
action.Git.Stage.Compare.Three.Versions.text=比較 HEAD 版本、暫存版本和本地版本
action.Git.Stage.Disable.description=停用暫存區域並切換到更改列表
action.Git.Stage.Disable.text=變更列表
action.Git.Stage.Enable.description=使用原生 Git 暫存概念進行提交
action.Git.Stage.Enable.text=暫存區域
action.Git.Stage.Show.Local.description=在編輯器中顯示當前檔案的本地內容
action.Git.Stage.Show.Local.text=顯示本地版本
action.Git.Stage.Show.Staged.description=在編輯器中顯示當前檔案的暫存內容
action.Git.Stage.Show.Staged.text=顯示暫存版本
action.Git.Stage.ThreeSideDiff.description=顯示包含 HEAD、暫存和本地版本的差異視窗，從中可以互動地將更改新增到暫存區域
action.Git.Stage.ThreeSideDiff.text=比較 HEAD 版本、暫存版本和本地版本
action.Git.Stage.ToggleCommitAll.description=沒有暫存檔案時提交所有檔案
action.Git.Stage.ToggleCommitAll.text=無任何內容暫存時全部提交
action.Git.Stash.Apply.description=套用所選隱藏
action.Git.Stash.Apply.text=套用(&A)
action.Git.Stash.Clear.description=清除所有隱藏
action.Git.Stash.Clear.in.root.description=清除所選根中的所有隱藏
action.Git.Stash.Clear.in.root.text=清除 {0} 中的隱藏(&C)
action.Git.Stash.Clear.text=清除(&C)
action.Git.Stash.Drop.description=丟棄所選隱藏
action.Git.Stash.Drop.text=刪除(&D)
action.Git.Stash.Pop.description=彈出所選隱藏
action.Git.Stash.Pop.text=彈出(&P)
action.Git.Stash.Refresh.description=重新整理隱藏列表
action.Git.Stash.Refresh.text=重新整理隱藏
action.Git.Stash.Silently.text=無提示隱藏
action.Git.Stash.Toggle.Split.Preview.text=預覽差異
action.Git.Stash.UnstashAs.description=彈出或套用選定的隱藏作為新分支(帶或不帶索引)
action.Git.Stash.UnstashAs.text=取消隱藏(&U)…
action.Git.Stash.text=隱藏更改…
action.Git.Tag.text=新增標記…
action.Git.Toggle.Favorite.title=標記/取消標記為收藏項
action.Git.Toolbar.ShowMoreActions.description=VCS 動作
action.Git.Toolbar.ShowMoreActions.text=版本控制
action.Git.Uncommit.description=撤消最後一次提交並將其更改放入所選更改列表
action.Git.Uncommit.text=撤消提交…
action.Git.Unshallow.failure.title=無法取消淺層化版本庫
action.Git.Unshallow.progress.title=正在取消淺層化版本庫…
action.Git.Unshallow.text=取消淺層化版本庫
action.Git.Unstash.text=取消隱藏更改…
action.Git.Update.Selected.description=從追蹤的遠端獲取並使用 {1} 或像 \`git fetch branch:branch\` 一樣的快進(如果可能)更新所選{0,choice,1#分支|2#分支}
action.Git.Update.Selected.description.already.running=更新已在執行
action.Git.Update.Selected.description.select.non.current=僅選擇非當前分支
action.Git.Update.Selected.description.tracking.not.configured=沒有為所選{0,choice,1#分支|2#分支}組態追蹤分支
action.Git.Update.Selected.text=更新所選
action.New.Branch.disabled.fresh.description=無法在空版本庫中建立新分支。首先進行初始提交
action.New.Branch.disabled.several.commits.description=選擇單個提交以建立新分支
action.NotificationAction.GitDeleteBranchOperation.text.delete.tracked.branch=刪除追蹤的分支
action.NotificationAction.GitDeleteBranchOperation.text.restore=還原
action.NotificationAction.GitDeleteBranchOperation.text.view.commits=檢視提交
action.NotificationAction.GitDeleteTagOperation.text.restore=還原
action.NotificationAction.GitMergeAction.text.view.commits=檢視提交
action.NotificationAction.GitRewordOperation.text.undo=撤消
action.NotificationAction.GitUpdateSession.text.view.commits=檢視提交
action.NotificationAction.GithubNotifications.text.configure=組態…
action.NotificationAction.text.resolve=解決…
action.description.cant.revert.merge.commit=不允許還原合併提交
action.fetch.text=獲取
action.git.branches.group.by.prefix.text=按前綴分組
action.git.branches.popup.filter.by.action.single.text=在搜尋結果中顯示動作
action.git.branches.popup.filter.by.action.text=動作
action.git.branches.popup.filter.by.repository.text=版本庫
action.git.branches.show.recent.text=顯示最近的分支
action.git.branches.show.tags.text=顯示標籤
action.git.update.force.pushed.branch.description=對可能強制推送的當前分支執行更新。此動作可以利用現有的“更新專案”動作(例如，當存在本地合併提交時)。
action.git.update.force.pushed.branch.not.all.local.commits.chery.picked=並非所有本地提交都是從 {0} 分支中優選的
action.git.update.force.pushed.branch.progress=正在執行強制推送的分支更新…
action.git.update.force.pushed.branch.success=可能強制推送的分支更新成功
action.git.update.force.pushed.branch.text=更新強制推送的分支
action.git4idea.commands.TestGitHttpLoginDialogAction.text=測試 Git 登入對話框
action.gpg.agent.configuration.text=組態 GPG 代理
action.label.add.unstaged.range=暫存
action.label.add.unstaged.range.tooltip=向索引中新增新的更改
action.label.reset.staged.range=取消暫存
action.label.reset.staged.range.tooltip=移除索引中的更改
action.main.toolbar.git.Branches.text=VCS 小工具
action.main.toolbar.git.MergeRebase.text=VCS 合併/重定基底小工具
action.main.toolbar.git.project.not.trusted.separator.text=安全模式，版本控制不可用
action.not.possible.in.fresh.repo.checkout=簽出
action.not.possible.in.fresh.repo.generic=動作
action.selected.directory.text=選定{0,choice,1#目錄|2#目錄}
action.selected.file.text=選定{0,choice,1#檔案|2#檔案}
activity.name.abort.command=Git abort {0}
activity.name.checkout=Git checkout
activity.name.cherry.pick=Git cherry-pick
activity.name.merge=Git merge
activity.name.rebase=Git rebase
activity.name.reset=Git reset
activity.name.revert=Git revert
activity.name.stash=Git stash
activity.name.undo.commit=Git undo commit
activity.name.unstash=Git unstash
add.adding=正在新增檔案…
advanced.setting.git.branch.cleanup.symbol=分支名稱清理符號
advanced.setting.git.branch.cleanup.symbol.description=將在 Git 分支名稱中代替停用符號的符號
advanced.setting.git.clone.recurse.submodules=遞迴克隆專案中的子模組
advanced.setting.git.clone.recurse.submodules.description=啟用後，從 Git 呼叫 'git clone --recurse-submodules' 簽出，即克隆主版本庫與所有子模組 (如有)
advanced.setting.git.commit.do.not.run.commit.hooks=不執行 Git 提交掛鈎
advanced.setting.git.commit.do.not.run.commit.hooks.description=啟用後，提交始終使用 '--no-verify' 選項執行
advanced.setting.git.read.content.with=從 Git 讀取時套用內容轉換
advanced.setting.git.read.content.with.description=從 Git 讀取檔案內容時為 'git cat-file' 指令使用 '--filters' 或 '--textconv' 標誌
advanced.setting.git.recent.projects.show.branch=在最近專案列表中顯示分支名稱
advanced.setting.git.recent.projects.show.branch.description=分支名稱將顯示在歡迎頁面和主選單中的最近專案列表中
advanced.setting.git.search.everywhere.tab.enabled=在“隨處搜尋”中顯示 Git 頁籤
advanced.setting.git.update.incoming.outgoing.info=檢查傳入和傳出提交
advanced.setting.git.update.incoming.outgoing.info.description=在“分支”彈出視窗中更新具有傳入/傳出提交的分支資訊
advanced.setting.git.use.push.force.with.lease=使用安全強制推送
advanced.setting.git.use.push.force.with.lease.description=從 IDE 呼叫強制推送時使用 '--force-with-lease'，而非僅使用 '--force'
advanced.setting.git.use.schannel.on.windows=使用 Windows 憑證存儲
advanced.setting.git.use.schannel.on.windows.description=強制 Git 使用 Windows 憑證存儲來驗證 SSL 連線。適用於 Git 2.14 及更高版本。
advanced.settings.git=版本控制. Git
annotate.cannot.annotate.dir=無法註解目錄
annotate.line.mismatch.exception=正在為第 {0} 行新增資訊，但應當為第 {1} 行新增資訊
annotate.output.lack.data=第 {0} 行的輸出缺少必要的資料
annotate.repository.is.shallow=淺層版本庫中的註解可能不準確
annotations.options.detect.movements.across.files=檢測跨檔案的移動
annotations.options.detect.movements.within.file=檢測檔案內的移動
annotations.options.group=選項
annotations.options.ignore.whitespaces=忽略空格
apply.changes.applied.for.commits={0} {1,choice,1#項提交|2#{1,number} 項提交} 來自於 {2}
apply.changes.everything.applied={0} 中的所有更改已被{1}
apply.changes.nothing.to.do=沒要有{0}的內容
apply.changes.operation.canceled={0} 已取消
apply.changes.operation.failed={0} 失敗
apply.changes.operation.performed.with.conflicts={0}已執行，但存在衝突
apply.changes.operation.successful={0}成功
apply.changes.operation.successful.for.commits=但是，對以下{1, choice,1#提交|2#提交}成功進行了{0}:
apply.changes.resolving.conflicts.progress.title=正在解決衝突…
apply.changes.restore.notification.description=本地更改已在{0}之前儲存
apply.changes.restore.notification.title=還原本地更改
apply.changes.save.and.retry.operation={0}更改並重試
apply.changes.skipped={0} {1,choice,1#被|2#被}跳過，因為所有更改已被{2}。
apply.changes.unresolved.conflicts.notification.abort.action.text=中止{0}
apply.changes.unresolved.conflicts.notification.resolve.action.text=解決…
apply.changes.unresolved.conflicts.text=工作樹中有未解決的衝突。
apply.conflict.dialog.description.label.text=在由 {2} 執行的提交 {1} 的{0}過程中發生衝突{3}
blob.not.found=找不到 Blob: {0} - {1}
branch.checking.out.branch.from.process=正在從 {1} 簽出 {0}…
branch.checking.out.new.branch.process=正在簽出新分支 {0}…
branch.checking.out.process=正在簽出 {0}…
branch.creating.branch.process=正在建立分支 {0}…
branch.deleting.branch.process=正在刪除 {0}…
branch.deleting.remote.branch=正在刪除 {0}…
branch.deleting.tag.on.remote.process=正在刪除遠端分支上的標記 {0}…
branch.direction.panel.base.repo.label=base 版本庫:
branch.direction.panel.branch.label=分支:
branch.direction.panel.head.repo.label=head 版本庫:
branch.direction.panel.save.button=儲存
branch.direction.panel.select.link=選擇…
branch.direction.panel.warning.not.synced=本地分支未與遠端分支同步。\\n''{0}'' 分支將與 ''{1}'' 同步。
branch.direction.panel.warning.push=''{0}'' 沒有遠端分支。\\n將在 ''{1}'' 上建立新的遠端分支。
branch.merging.process=正在合併 {0}…
branch.not.fully.merged.dialog.all.commits.from.branch.were.merged=已合併來自分支 {0} 的所有提交
branch.not.fully.merged.dialog.repository.label=版本庫:
branch.not.fully.merged.dialog.restore.button=還原(&R)
branch.not.fully.merged.dialog.the.branch.was.not.fully.merged.to=分支 {0} 未完全合併到 {1}。<br/>以下是未合併提交的列表。
branch.not.fully.merged.dialog.title=分支未完全合併
branch.operation.could.not.0.operation.name.1.reference=無法{0} {1}
branch.operation.in={0} ({1} 中)
branch.rebasing.onto.process=正在重定基底到 ''{0}''…
branch.rebasing.process=正在重定基底 {0}…
branch.renaming.branch.process=正在將 {0} 重命名為 {1}…
branch.ui.handler.can.not.operation.name.because.of.unmerged.files=由於存在未合併的檔案而無法{0}
branch.ui.handler.delete.all=全部刪除
branch.ui.handler.delete.remote.branches=刪除遠端 {0,choice,1#分支|2#分支}
branch.ui.handler.delete.remote.branches.question=刪除遠端 {0,choice,1#分支|2#分支} {1}?
branch.ui.handler.delete.tracking.local.branch.as.well=同時刪除追蹤本地分支 {0}
branch.ui.handler.delete.tracking.local.branches=刪除追蹤本地分支:
branch.ui.handler.do.not.rollback=不復原
branch.ui.handler.merge.error.notification.title=仍然存在未解決的檔案。
branch.ui.handler.merge.notification.description=以下檔案存在未解決的衝突。您需要先解決它們，然後再{0}。
branch.ui.handler.rollback=復原
branch.ui.handler.unmerged.files.error.notification.text=您需要在{0}之前解決所有合併衝突。<br/>解決衝突後，請不要忘記在切換到另一個分支之前將檔案提交到當前分支。
branch.ui.handler.unmerged.files.error.resolve.conflicts.action.text=解決衝突…
branch.ui.handler.you.have.to.resolve.all.conflicts.before.operation.name=您需要先解決所有合併衝突，然後才能{0}。<br/>{1}
branch.worker.could.not.create.tag=無法{1,choice,0#|1#|2# 在 {2} 中}建立標記 {0}
branches.action.delete=刪除(&D)
branches.action.pull.into.branch.using.merge=使用“合併”拉入 {0}
branches.action.pull.into.branch.using.merge.description=使用合併拉入 {0}
branches.action.pull.into.branch.using.merge.selected=使用“合併”拉入當前分支
branches.action.pull.into.branch.using.rebase=使用“重定基底”拉入 {0}
branches.action.pull.into.branch.using.rebase.description=使用重定基底拉入 {0}
branches.action.pull.into.branch.using.rebase.selected=使用“重定基底”拉入當前分支
branches.branch.0=分支 ''{0}''
branches.branches=分支
branches.checking.existing.commits.process=正在檢查現有提交…
branches.checkout=簽出
branches.checkout.and.rebase.error.current.with.same.name=無法覆蓋當前分支 {0}
branches.checkout.and.rebase.failed=簽出和重定基底失敗
branches.checkout.and.rebase.onto.branch=簽出並重定基底到 {0}
branches.checkout.and.rebase.onto.current=簽出並重定基底到當前分支
branches.checkout.and.rebase.onto.current.process=正在簽出 {0} 並重定基底到當前分支
branches.checkout.and.rebase.onto.in.one.step=簽出 {0}，並在一個步驟中將其重定基底到 {1} (類似於 \`git rebase HEAD {2}\`)
branches.checkout.local=簽出本地分支
branches.checkout.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。將 ''{0}'' 變基到 ''{1}''，還是簽出 ''{0}''?
branches.checkout.s=簽出 {0}
branches.checkout.tag.or.revision=簽出標記或修訂…
branches.checkout.with.reset.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。將 ''{0}'' 變基到 ''{1}''，還是刪除本地提交?
branches.compare.the.current.working.tree.with=將當前工作樹與 {0} 中的樹進行比較
branches.compare.with.branch=與{0}比較
branches.compare.with.current=與當前分支進行比較
branches.create.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。是否要在其他版本庫中建立分支?
branches.create.new.branch.dialog.title=建立新分支
branches.create.with.reset.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。是否要刪除本地提交?
branches.current.branch=當前分支
branches.current.branch.name=當前
branches.drop.local.commits=刪除本地提交
branches.enter.reference.branch.tag.name.or.commit.hash=輸入參照(分支、標記)名稱或提交雜湊:
branches.fetch.finished=已獲取 {0} 個目標
branches.local.branches=本地分支
branches.local.branches.in.repo={0} 中的本地分支
branches.merge.into=將 {0} 合併到 {1} 中
branches.merge.into.current=合併到當前分支
branches.new.branch.from.branch=從 {0} 新增分支…
branches.new.branch.from.branch.current=從當前位置新增分支…
branches.new.branch.from.branch.description=從 {0} 建立新分支
branches.rebase.current.onto.selected=將當前分支重定基底到所選分支
branches.rebase.is.not.possible.in.the.detached.head.state=在游離的 HEAD 狀態下無法重定基底
branches.rebase.onto=將 {0} 變基到 {1}
branches.rebase.onto.selected.commit=將 {0} 重定基底到所選提交
branches.rebase.onto.selected.commit.description=將 {0} 變基到 {1}
branches.remote.branches=遠端分支
branches.remote.branches.in.repo={0} 中的遠端分支
branches.rename.branch=重新命名分支 {0}
branches.selected.branch.name=已選擇
branches.show.commits.in=在{0}中顯示{1}中缺少的提交
branches.show.diff.with.working.tree=顯示與工作樹的差異
branches.tag.0=標記 ''{0}''
branches.tags=標記
branches.tags.in.repo={0} 中的標籤
branches.there.are.incoming.and.outgoing.commits=存在傳入和傳出提交
branches.there.are.incoming.commits=存在傳入提交
branches.there.are.outgoing.commits=存在傳出提交
branches.tooltip.number.incoming.commits={0} 個傳入{0,choice,1#提交|2#提交}
branches.tooltip.number.incoming.commits.in.repositories={1} 個{1, choice, 1#版本庫|2#版本庫}中的 {0} 個傳入{0,choice,1#提交|2#提交}
branches.tooltip.number.outgoing.commits={0} 個傳出{0,choice,1#提交|2#提交}
branches.tooltip.number.outgoing.commits.in.repositories={1} 個{1, choice, 1#版本庫|2#版本庫}中的 {0} 個傳出{0,choice,1#提交|2#提交}
branches.tooltip.some.incoming.commits.not.fetched=一些傳入提交未被獲取
branches.tracking.branch.doesn.t.configured.for.s=沒有為 {0} 組態追蹤分支
branches.update=更新
branches.update.failed=更新失敗
branches.update.info.process=更新分支資訊…
branches.update.is.already.running=更新已在執行
branches.updating.process=正在更新分支…
button.changes.excluded.from.commit.commit.anyway=仍然提交
button.crlf.fix.dialog.commit.as.is=按原樣提交
button.crlf.fix.dialog.fix.and.commit=修復並提交
button.don.t.rollback=不復原
button.rollback=復原
button.set.name.and.commit.template=設定並{0}
changes.retrieving=檢索修訂 {0} 的更改
changes.view.merge.action.text=合併
changes.view.rollback.action.text=復原
checkbox.dont.warn.again=不再警告(&W)
checkbox.run.git.hooks=執行 Git 掛鈎(&H)
checkbox.set.config.property.globally=全域設定屬性(&G)
checkout.0=簽出 {0}
checkout.and.rebase=重定基底到遠端
checkout.new.branch.operation.branch.was.created=已建立分支 {0}
checkout.new.branch.operation.checked.out.0.and.deleted.1.on.2.3=已在{2,choice,1#根|2#根}{3}上簽出 {0} 並刪除 {1}
checkout.new.branch.operation.could.not.create.new.branch=無法建立新分支 {0}
checkout.new.branch.operation.error.during.rollback=復原期間出錯
checkout.new.branch.operation.errors.during.checkout=簽出期間出錯:
checkout.new.branch.operation.errors.during.deleting=刪除 {0} 期間出錯:
checkout.new.branch.operation.however.checkout.has.succeeded.for.the.following=不過，{0,choice,1#版本庫|2#版本庫}的簽出已成功:
checkout.new.branch.operation.rollback.successful=復原成功
checkout.new.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以復原(簽回上一個分支並刪除 {0})以使分支不出現分叉。
checkout.operation.checked.out=已簽出 {0}
checkout.operation.checked.out.new.branch.from=已從 {1} 中簽出新分支 {0}
checkout.operation.could.not.checkout.error=無法簽出 {0}
checkout.operation.could.not.checkout.error.title=無法簽出 {0}
checkout.operation.error.during.rollback=復原期間出錯
checkout.operation.errors.during.checkout=簽出期間出錯:
checkout.operation.errors.during.deleting=刪除 {0} 期間出錯:
checkout.operation.force.checkout=強制簽出(&F)
checkout.operation.however.checkout.has.succeeded.for.the.following=不過，以下{0,choice,1#版本庫|2#版本庫}的簽出已成功:
checkout.operation.in={1,choice,0#|1#{2}中的}{0}
checkout.operation.name=簽出
checkout.operation.previous.branch=上一個分支
checkout.operation.revision.not.found=在{0,choice,0#|1#{1}中}未找到修訂
checkout.operation.rollback.action=復原
checkout.operation.you.may.rollback.not.to.let.branches.diverge=您可以復原(簽回 {0})以使分支不出現分叉。
cherry.pick.applied=套用
cherry.pick.name=優選
clone.dialog.checking.git.version=正在檢查 Git 版本…
clone.dialog.shallow.clone=淺層化克隆，歷史記錄被截斷為
clone.dialog.shallow.clone.depth=提交
column.name.commit.signature=GPG 簽名
combobox.item.file.invalid=(無效)
commit.action.commit.and.rebase.text=提交並重定基底…
commit.action.name=提交 (&I)
commit.author=作者(&U):
commit.author.diffs=<html>作者與預設不同</html>
commit.author.with.committer={0}，通過 {1}
commit.check.warning.title.commit.during.rebase=正在版本庫中進行重定基底: {0}。在重定基底期間提交可能會導致提交丟失。
commit.check.warning.title.commit.during.rebase.details=有關 Git 重定基底的更多資訊
commit.check.warning.title.commit.with.detached.head=版本庫處於游離的 HEAD 狀態: {0}
commit.check.warning.title.commit.with.detached.head.details=有關游離的 HEAD 的更多資訊
commit.check.warning.title.large.file=您即將向版本庫提交一個大檔案: {0} 個{0,choice,1#檔案|2#檔案}，總大小為 {1}MB。\\n不建議在 Git 版本庫中存儲大檔案。請考慮使用 Git LFS。
commit.check.warning.user.name.email.not.set=未設定 Git user.name 和 user.email
commit.options.create.extra.commit.with.file.movements=使用檔案移動建立額外提交
commit.options.sign.off.commit.checkbox=Sign-off 提交(&G)
commit.options.sign.off.commit.message.line=在提交訊息結尾添加以下行:<br/>Signed-off by: {0}
commit.signature.bad=錯誤的 GPG 簽名
commit.signature.fingerprint=簽名指紋:
commit.signature.none=無 GPG 簽名
commit.signature.signed.by=通過密鑰簽名:
commit.signature.unverified=未驗證的 GPG 簽名
commit.signature.unverified.reason.cannot.verify=無法驗證(例如，缺少密鑰)
commit.signature.unverified.reason.expired=過期的簽名
commit.signature.unverified.reason.expired.key=使用過期的密鑰建立
commit.signature.unverified.reason.revoked.key=使用撤消的密鑰建立
commit.signature.unverified.reason.unknown=未知有效性
commit.signature.unverified.with.reason=未驗證的 GPG 簽名: {0}
commit.signature.verified=已驗證的 GPG 簽名
common.current.branch=當前分支:
common.current.branch.tooltip=當前已簽出的分支。
common.git.root=Git 根(&R):
common.git.root.tooltip=選擇 Git VCS 根
common.local.branches=公共本地分支
common.no.active.branch=<無活動分支>
common.refreshing=正在重新整理檔案
common.remote.branches=公共遠端分支
common.suffix.in.one.repository=在 {0} 中
common.suffix.in.several.repositories=在 {0} 個版本庫中
common.tags=常用標籤
computing.annotation=正在計算 {0} 的註解
conflict.resolver.unmerged.files.check.error.notification.description.text=由於錯誤，無法檢查工作樹中是否有未合併的檔案。{0}
conflicts.accept.progress=正在解析 {0,choice,1#個衝突|2#個衝突}
conflicts.accept.theirs.action.text=接受他們的更改
conflicts.accept.yours.action.text=接受您的更改
conflicts.loading.status=正在載入合併衝突…
conflicts.merge.window.error.message=找不到 {0} 的檔案
conflicts.merge.window.error.title=無法解決衝突
conflicts.resolve.action.text=解決
conflicts.type.added.by.them=由他們新增
conflicts.type.added.by.you=由您新增
conflicts.type.both.added=均已新增
conflicts.type.both.deleted=均已刪除
conflicts.type.both.modified=均已修改
conflicts.type.deleted.by.them=由他們刪除
conflicts.type.deleted.by.you=由您刪除
convert.language.extra.commit.commit.message=將 .{0} 重命名為 .{1}
convert.language.extra.commit.description=.{0} > .{1} 重新命名的額外提交
create.branch.operation.branch.created=已建立分支 {0}
create.branch.operation.could.not.create.new.branch=無法建立新分支 {0}
create.branch.operation.deleted.branch=已刪除 {0}
create.branch.operation.error.during.rollback=復原期間出錯
create.branch.operation.however.the.branch.was.created.in.the.following.repositories=不過，已在以下{0,choice,1#版本庫|2#版本庫}中建立分支:
create.branch.operation.name=建立分支
create.branch.operation.rollback.successful=復原成功
create.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以復原(刪除 {0})以使分支不出現分叉。
delete.branch.operation.branch.was.not.deleted.error=分支 {0} 未刪除
delete.branch.operation.collecting.unmerged.commits.process=正在收集未合併的提交…
delete.branch.operation.could.not.restore.branch.error=無法還原 {0}
delete.branch.operation.deleted.branch=已刪除分支 {0}
delete.branch.operation.deleted.branch.bold=<b>已刪除的分支:</b> {0}
delete.branch.operation.error.during.rollback.of.branch.deletion=分支刪除復原期間出錯
delete.branch.operation.however.branch.deletion.has.succeeded.for.the.following=不過，以下{0,choice,1#版本庫|2#版本庫}的分支刪除已成功:
delete.branch.operation.name=分支刪除
delete.branch.operation.restoring.branch.process=正在還原分支 {0}…
delete.branch.operation.unmerged.commits.were.discarded=未合併的提交已被捨棄
delete.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以復原(在這些根中重新建立 {0})以使分支不出現分叉。
delete.remote.branch.operation.also.deleted.local.branches=同時刪除了本地 {0,choice,1#分支|2#分支}: {1}
delete.remote.branch.operation.couldn.t.find.remote.by.name=無法按名稱尋找遠端: {0}
delete.remote.branch.operation.deleted.remote.branch=已刪除遠端分支 {0}
delete.remote.branch.operation.deleting.process=正在刪除 {0}
delete.remote.branch.operation.failed.to.delete.remote.branch=無法刪除遠端分支 {0}
delete.remote.tag.operation.deleted.tag.on.remotes=<b>已刪除{0,choice,1#遠端|2#遠端}上的標記:</b> {1}
delete.remote.tag.operation.failed.to.delete.tag.on.remotes=無法刪除 {1,choice,1#遠端|2#遠端} 上的標記 {0}
delete.remote.tag.operation.tag.does.not.exist.on.remotes=<b>標記在{0,choice,1#遠端|2#遠端}上不存在:</b> {1}
delete.tag.operation.could.not.find.tag=找不到標記 {0}
delete.tag.operation.could.not.find.tag.in=在 {0} 中找不到標記
delete.tag.operation.could.not.restore.tag=無法還原 {0}
delete.tag.operation.delete.on.remote=在{0,choice,1#遠端|2#遠端}上刪除
delete.tag.operation.deleted.tag=<b>已刪除的標記:</b> {0}
delete.tag.operation.error.during.rollback.of.tag.deletion=標記刪除復原期間出錯
delete.tag.operation.however.tag.deletion.has.succeeded.for.the.following=不過，以下{0,choice,1#版本庫|2#版本庫}的標籤刪除已成功:
delete.tag.operation.restored.tag=已還原標記 {0}
delete.tag.operation.restoring.tag.process=正在還原標記 {0}…
delete.tag.operation.rollback.successful=復原成功
delete.tag.operation.tag.was.not.deleted=未刪除標記 {0}
delete.tag.operation.you.may.rollback.not.to.let.tags.diverge=您可以復原(在這些根中重新建立 {0})以使標記不出現分叉。
dialog.message.rebasing.merge.commits=您即將重定基底存在衝突的合併提交。\\n\\n如果您不想再次解決衝突，請選擇“合併”; 如果要將歷史記錄線性化，仍可進行重定基底。
dialog.message.untracked.files.will.be.overwritten.by.operation=這些未追蹤的檔案將被{0}覆蓋
dialog.message.update.branch=您即將從 {1} 更新 {0}。\\n\\n如果要建立合併提交，請選擇“合併”；如果要重定基底到 {1}，請選擇“重定基底”。
dialog.title.could.not.operation=無法{0}
dialog.title.local.changes.prevent.from.operation=本地更改阻止{0}
dialog.title.rebasing.merge.commits=正在重定基底合併提交
dialog.title.untracked.files.preventing.operation=阻止{0}的未追蹤檔案
dialog.title.update.branch=更新 {0}
diff.find.error=正在尋找差異的修訂: {0}
editor.promo.close.link=不再顯示
editor.promo.commit.text=使用提交接口直接從 {0} 提交。
editor.promo.commit.try.link=嘗試
editor.promo.help.link=了解詳情
error.cannot.delete.file=無法刪除檔案: {0}
error.cant.set.user.name.email=無法設定 user.name 和 user.email
error.commit.cant.collect.partial.changes=無法收集要提交的部分更改
error.commit.cant.commit.multiple.changelists=無法一次提交多個更改列表中的更改
error.commit.cant.commit.with.unmerged.paths=由於您有未合併的檔案，因此無法提交。
error.commit.cant.create.message.file=建立提交訊息檔案失敗
error.dialog.title=錯誤
error.git.parse.not.a.revision.number=字串 ''{0}'' 不表示修訂號
error.git.parse.unknown.file.status=未知檔案狀態: {0}
error.git.repository.not.found=該版本庫不再存在: {0}
error.git.version.check.failed=執行 ''git --version'' 時出錯。離開程式碼: {0}，錯誤: {1}
error.list.title={0} 錯誤:
error.no.changed.files.no.commit.message=修改要提交的檔案並指定提交訊息
error.no.changed.files.to.commit=修改要提交的檔案
error.no.selected.roots.to.commit=選擇要提交的根
error.no.staged.changes.no.commit.message=暫存要提交的檔案並指定提交訊息
error.no.staged.changes.to.commit=暫存要提交的檔案
error.occurred.during=''{0}'' 時出錯
error.unresolved.conflicts=解決衝突以提交
errors.message=Git 動作以多個錯誤結束: {0}
errors.message.item=\\n{0}
exception.message.could.not.stash.root.error=無法隱藏 {0}: {1}
executable.error.git.not.installed=未安裝 Git
executable.mac.error.invalid.path.to.command.line.tools=Command Line Tools 的路徑無效
executable.mac.fix.path.action=修正路徑
exportable.Git.Application.Settings.presentable.name=Git
fetch.action.name=獲取
fetch.pruned.obsolete.remote.references=刪除過時的遠端 {0,choice,1#參照|2#參照}: {1}
fetching=正在獲取…
find.git.error.title=執行 Git 時出錯
find.git.success.title=Git 執行成功
find.git.unsupported.message=<html><tt>{0}</tt><br>此版本不受支援，某些延伸模組功能可能無法工作。<br>支援的最低版本是 <em>{1}</em>。</html>
git.add.to.exclude.file.action.description=將條目新增到 .git/info/exclude
git.add.to.exclude.file.action.text=.git/info/exclude
git.branches.popup.loading.tags=正在載入 Git 標籤…
git.branches.popup.search.field.actions.empty.text={0,choice,1#和|2#、}動作
git.branches.popup.search.field.empty.text=搜尋分支{0}{1}
git.branches.popup.search.field.repositories.empty.text={0,choice,1#和|2#、}版本庫
git.branches.popup.tree.accessible.name=分支樹
git.branches.popup.tree.no.branches=找不到分支 ''{0}''
git.branches.popup.tree.no.nodes=找不到 ''{0}''
git.commit.message.empty.title=提交訊息為空
git.commit.nothing.to.commit.error.message=沒有要提交的內容
git.compare.branches.empty.status={0} 包含來自 {1} 的所有提交
git.compare.branches.explanation.message=存在於 {0} 中但不存在於 {1} 中的提交
git.compare.branches.tab.name=比較
git.compare.branches.tab.suffix={0} 和 {1}
git.compare.with.branch.search.field.empty.text=搜尋分支{0,choice,0#|1#和標籤}
git.compare.with.branch.search.not.found=找不到 ''{0}''
git.compare.with.tag.file.not.found.in.tag=標記 ''{2}'' 中不存在{0,choice,1#檔案|2#目錄} {1}
git.compare.with.tag.loading.error.title=無法載入標記
git.compare.with.tag.modal.progress.loading.tags=正在載入標記…
git.compare.with.tag.popup.title=選擇要比較的標記
git.content.transform.filters=篩選器
git.content.transform.none=無
git.content.transform.textconv=TextConv
git.error.cant.process.output=無法處理 Git 輸出: {0}
git.error.exit=Git 程序離開，程式碼為 {0}
git.executable.detect.progress.title=正在檢測 Git 可執行檔案
git.executable.error.bash.not.found=找不到 bash 可執行檔案
git.executable.error.file.not.found=沒有此類別檔案: {0}
git.executable.new.version.update.available=更新為 Git {0}
git.executable.notification.cant.run.in.safe.mode=無法在安全模式下執行 Git 指令
git.executable.notification.description=Git 可執行檔案的路徑可能無效。
git.executable.notification.title=無法啟動 Git
git.executable.unknown.error.message=無法啟動 Git 程序: {0}
git.executable.validation.cant.identify.executable.message=無法識別 Git 可執行檔案 {0} 的版本
git.executable.validation.cant.run.in.safe.mode=無法在安全模式下執行 Git 指令
git.executable.validation.error.no.response.in.n.attempts.message=無法識別 Git 可執行檔案的版本: {0,choice,0#|2# {0} 次嘗試後}無響應
git.executable.validation.error.start.title=無法執行 Git
git.executable.validation.error.version.message=至少需要 {0}
git.executable.validation.error.version.title=Git 版本 {0} 不受支援
git.executable.validation.error.wsl.start.title=無法在 WSL 中執行 Git
git.executable.validation.error.wsl1.unsupported.message=不支持 WSL 版本 1，請參閱 <a href='https://youtrack.jetbrains.com/issue/IDEA-242469'>IDEA-242469</a> 了解可能的解決方案。
git.executable.validation.error.xcode.message=執行“sudo xcodebuild -license”並重試(需要管理員權限)
git.executable.validation.error.xcode.title=接受 XCode/iOS 授權以執行 Git
git.executable.version.is=Git 版本為 {0}
git.executable.version.progress.title=正在識別 Git 版本
git.fetch.progress=正在獲取…
git.history.diff.handler.choose.parent.popup=選擇要比較的父項
git.history.diff.handler.git.show.error=執行 git show {0}:{1} 時出錯
git.history.diff.handler.load.changes.process=正在載入更改…
git.history.diff.handler.no.changes.in.file.info=此合併提交中的檔案 {0} 無更改
git.integration.could.not.git.init=無法 git init {0}
git.integration.created.git.repository.in=已在 {0} 中建立 Git 版本庫
git.light.cant.find.current.revision.exception.message=找不到 {0} 的當前修訂
git.light.status.bar.display.name=Git
git.light.status.bar.text=Git: {0}
git.light.status.bar.tooltip=當前 Git 分支: {0}
git.log.action.checkout.group=簽出
git.log.action.checkout.revision.full.text=簽出修訂 ''{0}''
git.log.action.checkout.revision.short.text=修訂 ''{0}''
git.log.branches.search.field.accessible.description=按 {0} 轉到 VCS 日誌表篩選器
git.log.branches.search.field.accessible.name=Git 分支搜尋
git.log.branches.tree.accessible.name=Git 分支
git.log.cherry.picked.highlighter.cancelled.message=已取消對 ''{0}'' 中未選取提交的醒目提示，因為分支篩選器已被更改。
git.log.cherry.picked.highlighter.error.message=無法與分支 {0} 進行比較
git.log.cherry.picked.highlighter.process=正在比較分支…
git.log.cherry.picked.highlighter.select.branch.popup=選擇源分支
git.log.diff.handler.changes.between.revisions.in.paths.title={2} 中 {0} 與 {1} 之間的更改
git.log.diff.handler.changes.between.revisions.title={0} 與 {1} 之間的更改
git.log.diff.handler.local.version.content.title=本地
git.log.diff.handler.local.version.name=本地版本
git.log.external.loading.process=正在載入 Git 日誌…
git.log.external.tab.description={0} 的日誌
git.log.external.window.title=Git 日誌
git.log.refGroup.local=本地
git.log.show.commit.in.log.process=正在搜尋修訂 {0}
git.new.tag.dialog.tag.name.label=輸入新標記的名稱
git.new.tag.dialog.title=在 {0}上建立新標記
git.open.exclude.file.action.description=在編輯器中開啟 .git/info/exclude
git.open.exclude.file.action.text=開啟 .git/info/exclude
git.recent.projects.show.branch.mode.always=所有專案
git.recent.projects.show.branch.mode.for.duplicate.names=同名專案
git.recent.projects.show.branch.mode.never=從不
git.rename.branch.could.not.rename.from.to=無法將 {0} 重命名為 {1}
git.rename.branch.could.not.unset.upstream=無法取消設定分支 {0} 的上游
git.rename.branch.has.succeeded.for.the.following.repositories=不過，以下{0,choice,1#版本庫|2#版本庫}的重新命名已成功:
git.rename.branch.renamed.back.to=已重新命名回 {0}
git.rename.branch.rollback.failed=復原失敗
git.rename.branch.rollback.successful=復原成功
git.rename.branch.was.renamed.to=分支 {0} 已被重命名為 {1}
git.rename.branch.you.may.rename.branch.back=您可以復原(將分支重新命名回 {0})以使分支不出現分叉。
git.reset.button=重設
git.reset.dialog.description=<nobr>這會將當前分支 HEAD 重設為所選提交，<nobr/><br><nobr>並根據所選模式更新工作樹和索引:<nobr/>
git.reset.dialog.description.commit.details.by.author={0}，作者 {1}
git.reset.dialog.description.source.in.repository={0} ({1} 內)
git.reset.dialog.title=Git 重設
git.reset.failed.notification.title=重設失敗
git.reset.hard.button=硬重設(&H)
git.reset.mode.hard=硬
git.reset.mode.hard.description=<nobr>檔案將還原為所選提交的狀態。<nobr/><br><nobr>警告: 任何本地更改都將丟失。<nobr/>
git.reset.mode.keep=保留
git.reset.mode.keep.description=<nobr>檔案將還原為所選提交的狀態，<nobr/><br><nobr>但本地更改將保持不變。<nobr/>
git.reset.mode.mixed=混合
git.reset.mode.mixed.description=檔案不會更改，差異也不進行暫存。
git.reset.mode.soft=軟
git.reset.mode.soft.description=檔案不會更改，差異將暫存以進行提交。
git.reset.operation=重設
git.reset.partially.failed.notification.msg={0} 重設成功\\n但 {1} 重設失敗:\\n{2}
git.reset.partially.failed.notification.title=重設部分失敗
git.reset.process=Git 重設
git.reset.successful.notification.message=重設成功
git.rollback=復原(&R)
git.running=執行: {0}
git.status.bar.widget.name=Git 分支
git.status.bar.widget.text.cherry.pick=正在 {0} 中優選
git.status.bar.widget.text.merge=正在合併 {0}
git.status.bar.widget.text.rebase=正在重定基底 {0}
git.status.bar.widget.text.revert=正在 {0} 中還原
git.status.bar.widget.text.unknown=<未知>
git.status.bar.widget.tooltip.detached=Git: 游離的 HEAD 不指向任何分支
git.status.bar.widget.tooltip.rebasing=Git: 正在進行重定基底
git.status.copied=已複製
git.status.index=在暫存區域中{0}
git.status.not.changed=未更改
git.status.renamed=已重新命名
git.status.type.changed=已更改類型
git.status.unmerged=已取消合併
git.status.unmerged.both=兩者{0}
git.status.unmerged.index=我們{0}
git.status.unmerged.work.tree=由他人{0}
git.status.untracked=已取消追蹤
git.status.work.tree=在工作目錄中{0}
git.tag.could.not.create.tag=無法建立標記
git.tag.created.tag.successfully=已成功建立標記 {0}。
git.toolbar.widget.no.loaded.repo=Git
git.toolbar.widget.no.repo=版本控制
git.toolbar.widget.no.repo.tooltip=為專案組態版本控制
git.undo.action.cant.undo.commit.failure=無法撤消提交
git.undo.action.could.not.load.changes.of.commit=無法載入 {0} 的更改
git.undo.action.description=所選提交不是當前分支中的最後一次提交
git.undo.action.failed.notification.title=撤消提交失敗
git.undo.action.operation=撤消提交
git.undo.action.refreshing.changes.process=正在重新整理更改…
git.undo.action.select.target.changelist.title=選擇目標更改列表
git.undo.action.successful.notification.message=撤消提交成功
git.undo.action.undoing.last.commit.process=正在撤消最後一次提交…
git.update.commits.matching.filters={0,choice,1#{0} 個提交|2#{0} 個提交}與篩選器匹配
git.update.files.updated.in.commits=已更新 {1,choice,1#{1} 個提交|2#{1} 個提交}中的 {0,choice,1#{0} 個檔案|2#{0} 個檔案}
git.update.no.commits.matching.filters=沒有與篩選器符合的提交
git.update.operation=更新
git.update.project.partially.updated.title=專案已部分更新
git.update.repo.was.skipped=已跳過 {0} ({1})
git.update.skipped.repositories=已跳過 {0} 個版本庫:
git4idea.vcs.name=Git
git4idea.vcs.name.with.mnemonic=&Git
gpg.error.see.documentation.link.text=參閱 GPG 設定指南
gpg.error.text=提交簽名失敗
gpg.jb.manual.link=Set_up_GPG_commit_signing
gpg.pinentry.agent.configuration.configuration.backup.exception=無法建立組態備份
gpg.pinentry.agent.configuration.confirmation.text=GPG 代理將被組態為使用 {0} 內建 pinentry 程序。<br/><br/>如果 {0} 未處於有效狀態，將使用當前組態的 pinentry 程序: <tt>{1}</tt>
gpg.pinentry.agent.configuration.confirmation.title=更新 GPG 代理組態
gpg.pinentry.agent.configuration.confirmation.yes=更新
gpg.pinentry.agent.configuration.detect.default.pinentry.exception=無法檢測 pinentry 程序
gpg.pinentry.agent.configuration.exception=無法更新 GPG 組態: {0}
gpg.pinentry.agent.configuration.launcher.generation.exception=無法生成 pinentry 啟動器
gpg.pinentry.agent.configuration.read.exception=無法讀取 GPG 組態
gpg.pinentry.agent.configuration.save.exception=無法儲存更新的 GPG 組態
gpg.pinentry.configuration.error.title=GPG 代理組態失敗
gpg.pinentry.configuration.global.suggestion.do.not.ask.again.display.name=GPG 代理組態(建議)
gpg.pinentry.configuration.proposal.configure=組態…
gpg.pinentry.configuration.proposal.message=要{0,choice,0#在遠端主機上|1#在 WSL 中|2#}支援 GPG 提交簽名，請將 GPG 代理組態為使用 {1} 內建 pinentry 程序
gpg.pinentry.configuration.proposal.title=GPG 代理組態
gpg.pinentry.configuration.suggestion.do.not.ask.again.display.name=GPG 代理組態(無效提交後的建議)
gpg.pinentry.configured.successfully.backup.message=已在 <code>{0}</code> 中建立現有組態的備份
gpg.pinentry.configured.successfully.message=GPG 代理組態已在 <code>{0}</code> 中更新
gpg.pinentry.configured.successfully.title=GPG 代理組態成功
gpg.pinentry.default.description=請輸入密碼短語以解鎖 GPG 私鑰:
gpg.pinentry.jb.manual.link=Set_up_GPG_pinentry_for_commit_signing
gpg.pinentry.title=解鎖 GPG 私鑰
group.Git.Branch.Tracked.name=追蹤分支動作
group.Git.Branch.Tracked.name.withBranch=追蹤分支 ''{0}''
group.Git.CheckoutGroup.description=簽出所選修訂或所選提交中的分支
group.Git.CheckoutGroup.text=簽出
group.Git.ContextMenu.text=&Git
group.Git.HEAD.Branch.Filter.title=HEAD(當前分支)
group.Git.Local.Branch.title=本地
group.Git.Log.Branches.Grouping.Settings.text=分組依據
group.Git.Log.Branches.Settings.Separator.text=點擊時
group.Git.Log.Branches.Settings.text=分支窗格設定
group.Git.Log.ShareLogIndexData.text=共享 Git 日誌索引資料
group.Git.MainMenu.LocalChanges.text=未提交的更改(_U)
group.Git.MainMenu.MergeActions.text=合併(_M)
group.Git.MainMenu.RebaseActions.text=重定基底(_R)
group.Git.Menu.text=&Git
group.Git.Recent.Branch.in.repo.title={0} 中最近的分支
group.Git.Recent.Branch.title=最近
group.Git.Remote.Branch.title=遠端
group.Git.Stage.Configure.text=組態本地更改
group.Git.Stage.Index.File.Menu.text=Git
group.Git.Stage.Ui.Settings.text=檢視選項
group.Git.Tags.loading.text=正在載入…
group.Git.Tags.title=標籤
group.MainToolbarVCSGroup.text=VCS 組
group.Vcs.ToolbarWidget.ShareProject.text=在以下平台上共享專案:
history.filters.unsupported.error.message=不支持按“{0}”篩選歷史記錄
history.for.revision.filters.unsupported.error.message=不支持按“{0}”篩選修訂歷史記錄
in.branches.all.repositories=在所有版本庫中
in.memory.rebase.data.contains.empty.reword.message.for.entry=記憶體中重定基底資料包含條目的空改寫訊息: {0}
in.memory.rebase.data.contains.entry.with.unsupported.action=記憶體中重定基底資料包含具有不受支援動作的條目: {0}
in.memory.rebase.data.contains.missing.reword.message.for.entry=記憶體中重定基底資料包含條目缺失的改寫訊息: {0}
in.memory.rebase.fail.head.move=在提交編輯動作期間 HEAD 發生移動
in.memory.rebase.failed.rebase.data=無法生成有效的記憶體中重定基底資料
in.memory.rebase.interactive.failed.message=正在回退到一般重定基底
in.memory.rebase.interactive.failed.title=記憶體中重定基底失敗
in.memory.rebase.log.change.extract.action.progress.indicator.title=正在獲取更改…
in.memory.rebase.log.changes.action.operation.extract.name=獲取所選更改
in.memory.rebase.log.changes.extract.action.description.all.changes.selected=無法從提交中獲取所有更改
in.memory.rebase.log.changes.extract.action.failure.title=無法獲取所選更改
in.memory.rebase.log.changes.extract.action.notification.successful.title=已獲取的更改
in.memory.rebase.log.changes.extract.action.notification.undo.failed.title=撤消獲取更改失敗
in.memory.rebase.log.changes.extract.action.notification.undo.not.allowed.title=無法撤消獲取更改
in.memory.rebase.log.changes.extract.action.progress.indicator.undo.title=正在撤消獲取更改…
in.memory.rebase.log.changes.extract.dialog.description.label=由 {1} 從提交 {0} 中獲取的更改
in.memory.rebase.log.changes.extract.dialog.title=新的提交訊息
in.memory.rebase.log.changes.extract.failed.title=無法獲取所選更改
in.memory.rebase.log.interactive.action.notification.successful=重定基底成功
in.memory.rebase.log.interactive.action.notification.undo.failed.title=撤消互動重定基底失敗
in.memory.rebase.log.interactive.action.notification.undo.not.allowed.title=無法撤消互動重定基底
in.memory.rebase.log.interactive.action.progress.indicator.undo.title=正在撤消互動重定基底…
in.memory.rebase.log.interactive.failed.title=互動重定基底失敗
in.memory.rebase.log.reword.failed.title=改寫失敗
in.memory.rebase.log.squash.failed.title=壓縮失敗
in.memory.split.tree.mixed.error=無法獲取所選更改
in.memory.split.tree.submodules.error=不支持通過 git 子模組條目拆分樹
init.destination.directory.description=選擇將在其中建立新 Git 版本庫的目錄。
init.destination.directory.title=建立 Git 版本庫
init.warning.already.under.git=所選目錄 <tt>{0}</tt> 已在 Git 下。\\n確定要建立新的 VCS 根嗎?
init.warning.title=Git Init
initializing.title=正在初始化版本庫…
install.download.and.install.action=下載並安裝
install.downloading.progress=正在下載…
install.general.error=無法安裝 Git
install.installing.progress=正在安裝…
install.mac.error.couldnt.start.command.line.tools=無法啟動 Command Line Tools 安裝
install.mac.requesting.command.line.tools=正在請求 XCode Command Line Developer Tools
install.success.message=已安裝 Git
label.changes.excluded.from.commit.are.you.sure.want.to.continue=確定要從合併提交中排除這些更改過的檔案嗎?
label.credential.store.key.http.password=Git HTTP
label.diff.content.title.submodule.suffix={0} (子模組)
label.name.email.not.defined.in.n.roots={0,choice,1#根|2#根}中未定義 Git 的 user.name 和 user.email 屬性
label.user.email=電子郵件(&E):
label.user.name=名稱(&N):
link.label.commit.with.detached.head.read.more=閱讀有關游離的 HEAD 的更多資訊
link.label.commit.with.unfinished.rebase.read.more=閱讀有關 Git 重定基底的更多資訊
link.label.editor.notification.merge.conflicts.resolve.in.progress=正在解決合併衝突
link.label.editor.notification.merge.conflicts.suggest.resolve=檔案存在未解決的合併衝突
link.label.merge.conflicts.resolve.in.progress.cancel.resolve=取消解決
link.label.merge.conflicts.resolve.in.progress.focus.window=顯示解析衝突視窗
link.label.merge.conflicts.suggest.resolve.show.window=解決衝突…
local.changes.freeze.message.git.operation.prefix=Git {0}
local.changes.save.policy.shelve=擱置
local.changes.save.policy.stash=隱藏
local.changes.would.be.overwritten.by.merge.view.them.action=檢視這些變更
log.command.empty.text=[<options>] [<revision-range>] [[--] <path>...]
log.parser.exception.message.could.not.parse.output=無法解析 Git 日誌輸出“{0}”
log.parser.exception.message.error.command.line={0}\\n命令行: [{1}]
log.parser.exception.message.error.parsing.line=解析第“{0}”行時出錯
login.dialog.button.login=登入
login.dialog.error.password.cant.be.empty=密碼不能為空
login.dialog.error.username.cant.be.empty=用戶名不能為空
login.dialog.label.login.to.url=登入 {0}
login.dialog.login.with.selected.provider=使用 {0} 登入…
login.dialog.password.label=密碼:
login.dialog.prompt.enter.credentials=輸入憑證:
login.dialog.select.login.way.credentials=輸入憑證
login.dialog.select.login.way.use.helper=使用憑證幫助程序
login.dialog.username.label=用戶名:
mention.in=\\ ({0} 中)
merge.action.after.update.label=更新後
merge.action.before.update.label=更新前
merge.action.name=合併
merge.action.operation.failed=Git {0} 失敗
merge.branch.already.merged=分支 ''{0}'' 已被合併
merge.branch.field.placeholder=指定分支
merge.branch.into.current.title=合併到 {0}
merge.branch.loading.branches.progress=正在載入未合併的分支…
merge.branch.popup.empty.text=無分支
merge.branch.title=合併更改
merge.commit.message.label=提交訊息:
merge.dialog.customizer.collecting.details.progress=正在收集提交詳細資訊…
merge.dialog.customizer.filter.by.conflicted.file.checkbox=按衝突檔案篩選
merge.dialog.customizer.show.details.link.label=顯示詳細資訊
merge.dialog.description.cherry.pick.label.text=在優選{2,choice,0#|1#由 {3}{4} 執行的}{0,choice,1#提交 {1}|2#多個提交}期間出現衝突
merge.dialog.description.merge.label.text=將{0,choice,1#分支 {1} |2#分叉的分支}合併到{2,choice,1#分支 {3}|2#分叉的分支}
merge.dialog.description.rebase.conflict.current.commit=當前提交 {0} 由 {1} 完成:
merge.dialog.description.rebase.with.hash.label.text=正在{0,choice,0#|1#將分支 {1} }變基到 {2}
merge.dialog.description.rebase.with.onto.branch.label.text=正在{0,choice,0#|1#將分支 {1} }重定基底到分支 {2}{3,choice,0#|1#，修訂 {4}}
merge.dialog.description.rebase.without.onto.info.label.text=正在{0,choice,0#|1#將分支 {1} }重定基底到分叉的分支
merge.dialog.diff.left.title.cherry.pick.label.text=本地更改
merge.dialog.diff.left.title.default.branch.label.text=您的版本，分支 {0}
merge.dialog.diff.left.title.rebase.label.text=正在從 {1} 重定基底 {0}
merge.dialog.diff.right.title.cherry.pick.label.text=來自優選 {0} 的更改
merge.dialog.diff.right.title.default.with.hash.label.text=來自 {0} 的更改
merge.dialog.diff.right.title.default.with.onto.branch.label.text=來自分支 {0}{1,choice,0#|1#，修訂 {2}} 的更改
merge.dialog.diff.right.title.default.without.onto.info.label.text=來自分叉分支的更改
merge.dialog.diff.right.title.rebase.with.branch.label.text=已重定基底的提交和來自 {0} 的提交
merge.dialog.diff.right.title.rebase.without.branch.label.text=已重定基底的提交
merge.dialog.diff.title.changes.from.branch.label.text=來自 {0} 的更改
merge.error.unable.to.read.merge.head=無法讀取檔案 {0}: {1}
merge.no.branch.selected.error=應選擇該合併分支。
merge.no.matching.branch.error=沒有符合分支。
merge.operation.already.up.to.date=已處於最新狀態
merge.operation.branch.merged.with.conflicts={0} 已合併，但存在衝突
merge.operation.could.not.merge.branch=無法合併 {0}
merge.operation.delete.branch.action=刪除 {0}
merge.operation.error.during.rollback=復原期間出錯
merge.operation.however.merge.has.succeeded.for.the.following.repositories=不過，以下{0,choice,1#版本庫|2#版本庫}的合併已成功:
merge.operation.merged.to=已將 {0} 合併到 {1}
merge.operation.name=合併
merge.operation.you.may.rollback.not.to.let.branches.diverge=您可以復原(重設為合併之前的提交)以使分支不出現分叉。
merge.option.allow.unrelated.histories=允許合併不具有共同上級的歷史記錄
merge.option.ff.only=僅在可以快進時合併
merge.option.msg=指定合併提交的訊息
merge.option.no.commit=不提交合併結果
merge.option.no.ff=即使可以快進也建立合併提交
merge.option.no.verify=繞過預合併和提交訊息掛鈎
merge.option.squash=為所有合併更改建立一個提交
merge.options.modify=修改選項
merge.options.modify.popup.title=新增合併選項
merge.progress.indicator.loading.unmerged.files.title=正在載入未合併的檔案…
merge.tool.column.status.deleted=已刪除
merge.tool.column.status.modified=已修改
merge.tool.column.theirs.status=他人的更改
merge.tool.column.theirs.with.branch.status=他人的更改({0})
merge.tool.column.yours.status=您的更改
merge.tool.column.yours.with.branch.status=您的更改({0})
merge.unresolved.conflicts.remaining.notification.body=有掛起的未解決的衝突。
merge.unresolved.conflicts.remaining.notification.title=正在掛起未解決的衝突
merge.update.project.conflict.merge.description.label=檢測到合併衝突。請先解決這些衝突，然後再繼續更新。
merge.update.project.generic.error.title=無法完成更新
merging.title=將更改合併到 {0}
message.unresolved.conflicts.prevent.commit=由於有未解決的衝突，無法提交更改。
modal.commit.deprecation.notification.description=模態提交模式已移至一個將在 {0} {1} 中解綁的延伸模組
new.branch.dialog.branch.name=分支名稱:
new.branch.dialog.branch.root.all.name=所有
new.branch.dialog.branch.root.all.override.warning=根將位於不同的分支上。某些分支動作不會同時在所有根上執行。
new.branch.dialog.branch.root.name=根:
new.branch.dialog.checkout.branch.checkbox=簽出分支(&C)
new.branch.dialog.error.branch.already.exists=分支名稱 {0} 已存在
new.branch.dialog.error.branch.clashes.with.directory=分支名稱 {0} 與同名的本地分支目錄衝突
new.branch.dialog.error.branch.clashes.with.remote=分支名稱 {0} 與同名的遠端分支衝突
new.branch.dialog.error.branch.name.empty=指定新分支的名稱
new.branch.dialog.error.branch.name.head=HEAD 是保留關鍵字
new.branch.dialog.error.branch.name.invalid=分支名稱 {0} 無效
new.branch.dialog.operation.checkout.description=簽出現有分支，並在其他版本庫中建立新分支
new.branch.dialog.operation.checkout.name=簽出
new.branch.dialog.operation.create.description=在其他版本庫中建立新分支
new.branch.dialog.operation.create.name=建立
new.branch.dialog.operation.rename.name=重新命名
new.branch.dialog.overwrite.existing.branch.checkbox=覆蓋現有分支(&R)
new.branch.dialog.overwrite.existing.branch.warning=更改名稱或覆蓋現有分支
new.branch.dialog.set.tracking.branch.checkbox=設定追蹤分支(&T)
new.branch.dialog.unset.upstream.branch.checkbox=取消設定上游分支(&T)
no.revisions.available=無修訂
notification.content.branch.in.repo.has.no.tracked.branch={0} {1} 沒有追蹤的分支
notification.content.couldn.t.authorize=授權錯誤
notification.content.couldnt.collect.updated.files.info={0} 更新成功，但由於發生了一個錯誤，我們無法收集更新的更改
notification.content.detached.state.in.root.checkout.branch=您處於“游離的 HEAD”狀態，這表明您不在任何分支 {0} 上<br/>簽出分支以更新專案。
notification.content.fetch.failed.couldn.t.authorize=獲取失敗: 授權錯誤
notification.content.fetched.successfully=已成功獲取
notification.content.untracked.files.prevent.operation.move.or.commit=在 {0} 前移動或提交<br/>{1}
notification.content.updating.root.failed.with.error=更新 {0} 失敗，出現錯誤: {1}
notification.ignore.file.generation.error.text.files.progress.title=無法生成 .gitignore 檔案
notification.title.can.t.update.no.current.branch=無法更新: 無當前分支
notification.title.couldn.t.reset.merge=無法中止合併動作
notification.title.couldnt.collect.updated.files.info=無法收集已更新檔案的資訊
notification.title.error.merging=合併錯誤
notification.title.error.updating.root=更新 {0} 期間出錯
notification.title.fetch.details=獲取詳細資訊
notification.title.fetch.failed=獲取失敗
notification.title.fetch.failure=獲取失敗
notification.title.fetch.success=獲取成功
notification.title.git.operation.failed=Git {0} 失敗
notification.title.unstash.failed=取消隱藏失敗
notification.title.unstash.failed.index.conflict=由於索引衝突，取消隱藏失敗
notification.title.untracked.files.prevent.operation=未追蹤的檔案會阻止{0}
notification.title.update.failed=更新失敗
open.in.browser.error=無法在瀏覽器中開啟
open.in.browser.getting.revision=正在獲取最新的檔案修訂
open.in.browser.getting.revision.error=無法檢索檔案的最新修訂
operation.action.message=多個 Git 根有未完成的 {0} 程序，請選擇要對其執行動作的根。
operation.name.loading.revision=載入修訂
operation.name.validating.revision.0=驗證修訂 {0}
output.parse.exception.unexpected.end.message=文本在 ''{0}'' 意外結束
paths.affected.title=提交 {0} 中受影響的路徑
post.commit.check.load.changes.error=無法為 {1} 載入根 {0} 中的更改
preserving.process.local.changes.not.restored.error.title=未還原本地更改
progress.checking.line.separator.issues=正在檢查行分隔符問題…
progress.details.refreshing.files.for.root=正在重新整理根 {0} 的檔案
progress.finishing.conflict.resolve=正在解決衝突
progress.setting.config.value=正在更新 Git 組態…
progress.setting.user.name.email=正在設定 Git 用戶名…
progress.text.merging.repository=正在合併 {0}…
progress.title.calculating.commit.messages=正在計算提交訊息
progress.title.creating.git.repository=正在建立 Git 版本庫…
progress.title.enabling.git=正在啟用 Git…
progress.title.moving.files=正在移動檔案…
progress.title.reverting.n.commits=正在還原{0,choice,1#提交|2#提交}
progress.title.update=更新
progress.title.validating.revision=正在驗證修訂…
progress.update.destination.remote=遠端
pull.action.name=拉取
pull.branch.field.placeholder=指定分支
pull.branch.no.matching.remotes=無遠端
pull.branch.not.selected.error=應選擇要從中拉取的分支。
pull.branch.nothing.to.pull=無分支
pull.button=拉取
pull.dialog.fetch.shortcuts.hint=按 {0} 更新分支
pull.dialog.title=拉取
pull.dialog.with.branch.title=拉取到 {0}
pull.fetch.failed.notification.text=選擇一個本地版本庫和一個遠端版本庫
pull.fetch.failed.notification.title=無法載入遠端分支
pull.option.ff.only=僅在可以快進時合併
pull.option.no.commit=合併，但不提交結果
pull.option.no.ff=即使可以快進也建立合併提交
pull.option.rebase=在傳入更改上重定基底當前分支
pull.option.squash.commit=為所有拉取更改建立一個提交
pull.options.modify.popup.title=新增拉取選項
pull.remote.not.selected=選擇要從中拉取的遠端版本庫
pull.repository.not.selected.error=選擇一個版本庫
pulling.title=從 {0} 中拉取更改
push.dialog.preview.commits.before.push=對於向不受保護分支的提交和推送，應在推送之前預覽提交
push.dialog.prohibited.branch.configurable.path={0} | 版本控制 | Git
push.dialog.push.tags=推送標記(&T)
push.dialog.push.tags.combo.all=所有
push.dialog.push.tags.combo.current.branch=當前分支
push.dialog.target.panel.add.remote=新增遠端
push.dialog.target.panel.adding.remote=正在新增遠端…
push.dialog.target.panel.can.t.push=無法推送
push.dialog.target.panel.couldnt.add.remote=無法新增遠端: {0}
push.dialog.target.panel.define.remote=定義遠端
push.dialog.target.panel.empty.repository=空版本庫
push.dialog.target.panel.new=新增
push.dialog.target.panel.new.and.upstream=新增和上游
push.dialog.target.panel.upstream.checkbox=設定上游
push.dialog.target.panel.upstream.label=上游
push.failed.error.message=推送失敗: {0}
push.local.history.system.label.after=推送後
push.local.history.system.label.before=推送前
push.notification.description.force.pushed=強制推送 {0} 到 {1}
push.notification.description.new.branch=已推送 {0} 到新分支 {1}
push.notification.description.new.branch.with.many.tags=推送 {0} 到新分支 {1}，並將 {2} 標籤到 {3}
push.notification.description.new.branch.with.single.tag=推送 {0} 到新分支 {1}，並將 {2} 標籤到 {3}
push.notification.description.push.with.lease.rejected=使用 Force-with-lease 推送 {0} 到 {1} 被拒
push.notification.description.pushed=已將 {0} 個{0,choice,1#提交|2#提交} 推送到 {1}
push.notification.description.pushed.many.tags=已推送 {0} 標籤到 {1}
push.notification.description.pushed.single.tag=已推送標籤 {0} 到 {1}
push.notification.description.pushed.with.many.tags=已將 {0} 個{0,choice,1#提交|2#提交} 推送到 {1}，將 {2} 標籤推送到 {3}
push.notification.description.pushed.with.single.tag=已將 {0} 個{0,choice,1#提交|2#提交} 推送到 {1}，將標籤 {2} 推送到 {3}
push.notification.description.rejected=推送到 {0} 被拒
push.notification.description.rejected.and.cancelled=推送被拒，更新被取消
push.notification.description.rejected.and.conflicts=由於更新期間發生衝突，推送被取消。<br/>檢查是否已正確解決衝突，然後再次呼叫推送。
push.notification.description.rejected.and.failed=因發生錯誤，推送被拒，更新失敗
push.notification.description.rejected.and.incomplete=由於更新過程中並未解決所有衝突，推送被取消。<br/>請解決衝突並再次呼叫推送
push.notification.description.rejected.by.remote=推送 {0} 到 {1} 被遠端拒絕
push.notification.description.rejected.by.remote.without.target={0} 的推送被遠端拒絕
push.notification.description.up.to.date=所有內容都已處於最新狀態
push.notification.force.push.anyway.action=仍然強制推送
push.notification.force.push.progress.title.pushing=正在推送…
push.notification.force.with.lease.help=何為 Force-with-Lease?
push.notification.force.with.lease.help.description.first=Force-with-lease 推送阻止覆寫尚未獲取到本地版本庫的遠端更改
push.notification.force.with.lease.help.description.second=獲取最新更改，以確認能否安全捨棄更改並重複執行推送動作
push.notification.partially.failed.title=推送部分失敗
push.notification.partially.rejected.title=推送部分被拒
push.notification.push.failed.title=推送失敗
push.notification.rejected.title=推送被拒
push.notification.single.repo.success.description=推送動作期間收到 {0} 個{0, choice,1#提交|2#提交}
push.notification.successful.title=推送成功
push.notification.update.action=更新
push.notification.view.files.action=檢視在推送期間更新的檔案
push.notification.view.filtered.commits.actions=檢視與篩選器符合的 {0} 個{0,choice,1#提交|2#提交}
push.notification.view.received.commits.action=檢視收到的{0,choice,1#提交|2#提交}
push.rejected.dialog.title=推送被拒
push.rejected.many.repos=當前分支的推送被拒:
push.rejected.many.repos.item={1} 中的 {0}
push.rejected.many.repos.single.branch=當前分支“{0}”的推送被拒。
push.rejected.merge=合併(&M)
push.rejected.merge.needed=推送前需要合併遠端更改。
push.rejected.merge.needed.with.problem=在推送前，必須先合併遠端更改。<br/><br/>在這種情況下，強烈建議進行<b>合併</b>，因為存在未推送的合併提交。\\n<br/>進行重定基底可能導致問題。
push.rejected.only.one.git.repo=當前分支“{0}”的推送被拒。
push.rejected.rebase=重定基底(&R)
push.rejected.rebase.anyway=仍然重定基底
push.rejected.remember.checkbox=請記住更新方法，並在日後進行無提示更新(&S)。稍後可以在“{0} | 版本控制”中進行更改。<br/>
push.rejected.specific.repo=版本庫“{1}”中的當前分支“{0}”推送被拒。
push.up.to.commit.allowed.progress.title=正在檢查是否允許推送到選定的提交…
push.up.to.commit.getting.reference.progress.title=正在獲取對 HEAD 的提交參照…
push.upto.here.failed.dialog.title=無法啟動推送
rebase.abort.and.rollback.dialog.message=僅中止 {0} 中的重定基底還是同時復原 {1} 中的重定基底?
rebase.abort.and.rollback.dialog.no.button.text=僅中止
rebase.abort.and.rollback.dialog.yes.button.text=中止並復原
rebase.abort.dialog.message=中止{0} 中的重定基底?
rebase.abort.dialog.ok.button.text=中止
rebase.abort.dialog.title=中止重定基底
rebase.abort.notification.failed.title=中止重定基底失敗
rebase.abort.notification.successful.message=中止重定基底成功
rebase.abort.notification.warning.rollback.failed.message={0}中的復原失敗:{1}{2}
rebase.abort.notification.warning.rollback.failed.title=重定基底復原失敗
rebase.abort.notification.warning.rollback.failed.with.repo.message=成功中止 {0} 中的重定基底，但 {1}:{2}{3} 中的復原失敗
rebase.abort.progress.indicator.command.in.repo.title={0} ({1} 內)
rebase.abort.rollback.successful.rebase.dialog.message=是否要復原 {0} 中成功的重定基底?
rebase.abort.rollback.successful.rebase.dialog.ok.button.text=復原
rebase.confirmation.dialog.published.commits.button.cancel.text=取消
rebase.confirmation.dialog.published.commits.button.rebase.text=仍然重定基底
rebase.confirmation.dialog.published.commits.message.first=您正在嘗試重定基底一些已推送到受保護分支的提交。
rebase.confirmation.dialog.published.commits.message.second=對這些提交進行重定基底將使提交重複，這是不推薦的，而且很可能是不需要的。
rebase.confirmation.dialog.published.commits.title=重定基底已發佈的提交
rebase.conflict.diff.dialog.left.title=正在從 {1} 重定基底 {0}
rebase.conflict.diff.dialog.right.simple.title=已重定基底的提交
rebase.conflict.diff.dialog.right.with.branch.title=已重定基底的提交和來自 {0} 的提交
rebase.couldnt.resolve.file=無法解析 {0}
rebase.dialog.branch.field=源分支
rebase.dialog.error.base.not.selected=選擇新基
rebase.dialog.error.branch.invalid=分支 ''{0}'' 不存在
rebase.dialog.error.branch.not.selected=選擇要切換到的分支
rebase.dialog.error.branch.or.tag.not.exist=沒有這樣的分支或標記
rebase.dialog.error.rebase.in.progress=此 Git 根目錄已經在進行互動重定基底
rebase.dialog.error.upstream.not.selected=選擇上游
rebase.dialog.help=顯示 Git 重定基底幫助
rebase.dialog.new.base=新基礎(分支或雜湊)
rebase.dialog.old.base=原基礎(分支或雜湊)
rebase.dialog.progress.loading.tags=正在載入標記…
rebase.dialog.root.invalid.label.text=(無效)
rebase.dialog.start.rebase=重定基底
rebase.dialog.target=分支或雜湊
rebase.dialog.title=重定基底
rebase.entry.action.name.drop=刪除
rebase.entry.action.name.edit=編輯
rebase.entry.action.name.fixup=Fixup
rebase.entry.action.name.pick=選取
rebase.entry.action.name.reword=改寫
rebase.entry.action.name.squash=壓縮
rebase.entry.action.name.unknown=未知
rebase.entry.action.name.update.ref=更新參照
rebase.git.operation.name=重定基底
rebase.help.link=git-scm.com 上的 git 重定基底
rebase.help.popup.ad.text=按空格開啟外部連結
rebase.help.rebase.branch=將基於一個分支的分支重定基底到另一個分支:
rebase.interactive.dialog.cancel.reword.warning.body=輸入的提交訊息將會丟失
rebase.interactive.dialog.cancel.reword.warning.cancel=取消改寫
rebase.interactive.dialog.cancel.reword.warning.continue=繼續編輯
rebase.interactive.dialog.cancel.reword.warning.title=取消改寫
rebase.interactive.dialog.discard.modifications.cancel=取消重定基底
rebase.interactive.dialog.discard.modifications.continue=繼續重定基底
rebase.interactive.dialog.discard.modifications.discard=捨棄
rebase.interactive.dialog.discard.modifications.message=捨棄更改並取消重定基底?
rebase.interactive.dialog.git.commands=Git 指令
rebase.interactive.dialog.git.commands.column.action=動作
rebase.interactive.dialog.git.commands.column.hash=雜湊
rebase.interactive.dialog.git.commands.column.subject=主題
rebase.interactive.dialog.reset.link.text=重設
rebase.interactive.dialog.reword.hint.text=按 {0} 套用更改
rebase.interactive.dialog.start.rebase=啟動重定基底
rebase.interactive.dialog.stop.to.edit.text=停止以編輯
rebase.interactive.dialog.title=正在重定基底提交
rebase.interactive.dialog.view.git.commands.text=檢視 Git 指令
rebase.interactive.edit.commit.message.dialog.title=Git 提交訊息
rebase.interactive.edit.commit.message.ok.action.title=繼續重定基底
rebase.interactive.noop.dialog.text=由於當前分支直接位於基礎分支的正下方或它們指向同一個提交，因此沒有要重定基底的提交('noop' 情況)。\\n是否要繼續? (這會將當前分支重設為基礎分支)
rebase.interactive.noop.dialog.title=Git 重定基底
rebase.interactive.unstructured.editor.dialog.root.label=Git 根: {0}
rebase.log.action.loading.commit.message.failed.message=無法載入{0,choice,1#提交|2#提交}的更改
rebase.log.action.operation.rebase.name=重定基底
rebase.log.action.operation.reword.name=改寫
rebase.log.action.progress.indicator.loading.commit.message.title=正在載入{0,choice,1#提交|2#提交}詳細資訊…
rebase.log.changes.action.operation.drop.name=刪除所選更改
rebase.log.changes.drop.action.description.all.changes.selected=無法刪除提交中的所有更改
rebase.log.changes.drop.action.failure.title=無法刪除所選更改
rebase.log.changes.drop.action.notification.successful.title=更改已刪除
rebase.log.changes.drop.action.notification.undo.failed.title=撤消刪除更改失敗
rebase.log.changes.drop.action.notification.undo.not.allowed.title=無法撤消刪除更改
rebase.log.changes.drop.action.progress.indicator.title=正在刪除更改…
rebase.log.changes.drop.action.progress.indicator.undo.title=正在撤消刪除更改…
rebase.log.changes.drop.failed.title=無法刪除所選更改
rebase.log.commit.editing.action.commit.not.in.head.error.text=該提交不在當前分支中
rebase.log.commit.editing.action.commit.pushed.to.protected.branch.error.text=該提交已被推送到受保護分支 ''{0}''
rebase.log.commit.editing.action.disabled.parents.description=所選提交已{0}父項
rebase.log.commit.editing.action.initial.commit.dialog.text=確定要編輯初始提交嗎?
rebase.log.commit.editing.action.initial.commit.dialog.title=正在編輯初始提交
rebase.log.commit.editing.action.progress.containing.branches.title=正在搜尋包含所選提交的分支…
rebase.log.commit.editing.action.prohibit.state=不能{0}
rebase.log.commit.editing.action.prohibit.state.grafting=優選期間不能{0}
rebase.log.commit.editing.action.prohibit.state.merging=合併期間不能{0}
rebase.log.commit.editing.action.prohibit.state.rebasing=重定基底期間不能{0}
rebase.log.commit.editing.action.prohibit.state.reverting=還原期間不能{0}
rebase.log.create.fixup.commit.action.failure.title=無法建立 Fixup 提交
rebase.log.create.squash.commit.action.failure.title=無法建立壓縮提交
rebase.log.drop.action.confirmation.message=是否要從 <b>{1}</b> 分支刪除 {0} 個{0,choice,1#提交|2#提交}?
rebase.log.drop.action.confirmation.message.detached.head=版本庫處於分離的 HEAD 狀態。是否要刪除 {0} 個{0,choice,1#提交|2#提交}?
rebase.log.drop.action.confirmation.title=刪除{0,choice,1#提交|2#提交}
rebase.log.drop.action.custom.text=刪除{0,choice,1#提交|2#提交}
rebase.log.drop.action.failure.title=無法刪除提交
rebase.log.drop.progress.indicator.title=正在刪除{0, choice, 1#提交|2#提交}…
rebase.log.drop.success.notification.title=已刪除 {0} 個{0,choice,1#提交|2#提交}
rebase.log.drop.undo.failed.title=撤消刪除失敗
rebase.log.drop.undo.impossible.title=無法撤消刪除
rebase.log.drop.undo.progress.title=正在撤消刪除…
rebase.log.interactive.action.failure.title=無法啟動重定基底
rebase.log.multiple.commit.editing.action.cant.find.head=在包含選定{0,choice,1#提交|2#提交}的版本庫中找不到 HEAD 分支
rebase.log.multiple.commit.editing.action.disabled.external.repository.description=所選{0, choice, 1#提交|2#提交}{0, choice,1#|2#}來自外部版本庫
rebase.log.multiple.commit.editing.action.disabled.multiple.repository.description=所選{0, choice, 1#提交|2#提交}{0, choice,1#|2#}來自不同的版本庫
rebase.log.multiple.commit.editing.action.progress.indicator.action.possibility.check=正在檢查是否允許編輯所選提交…
rebase.log.multiple.commit.editing.action.specific.commit.not.in.head=提交 {0} 不在當前分支中
rebase.log.multiple.commit.editing.action.specific.commit.root.or.merge=提交 {0} 有 {1} 個父項
rebase.log.reword.action.failure.title=無法編輯提交訊息
rebase.log.reword.action.notification.successful.title=已更改提交訊息
rebase.log.reword.action.notification.undo.failed.title=撤消提交訊息編輯失敗
rebase.log.reword.action.notification.undo.not.allowed.repository.changed.message=版本庫已被更改
rebase.log.reword.action.notification.undo.not.allowed.title=無法撤消提交訊息編輯
rebase.log.reword.action.progress.indicator.title=正在改寫…
rebase.log.reword.action.progress.indicator.undo.title=正在撤消改寫…
rebase.log.reword.dialog.description.label=編輯由 {1} 執行的提交 {0} 的訊息
rebase.log.reword.dialog.failed.pushed.to.protected.message=無法編輯所選{0,choice,1#提交|2#提交}: 提交 {1} 已被推送到受保護的分支 ''{2}''
rebase.log.reword.dialog.failed.repository.changed.message=無法編輯所選{0,choice,1#提交|2#提交}: 版本庫狀態已更改
rebase.log.reword.dialog.title=編輯提交訊息
rebase.log.squash.action.failure.title=無法壓縮提交
rebase.log.squash.new.message.dialog.label=編輯已壓縮提交的訊息
rebase.log.squash.new.message.dialog.title=已壓縮提交訊息
rebase.log.squash.progress.indicator.title=正在壓縮…
rebase.log.squash.success.notification.title=提交已壓縮
rebase.log.squash.undo.failed.title=撤消壓縮失敗
rebase.log.squash.undo.impossible.title=無法撤消壓縮
rebase.log.squash.undo.progress.title=正在撤消壓縮…
rebase.log.undo.impossible.pushed.to.protected.branch.notification.text=來自當前分支的提交已被推送到受保護的分支 {0}
rebase.notification.action.abort.text=中止
rebase.notification.action.continue.text=繼續
rebase.notification.action.retry.text=重試
rebase.notification.action.stage.and.retry.text=暫存並重試
rebase.notification.action.view.shelf.text=檢視擱置…
rebase.notification.action.view.stash.text=檢視隱藏…
rebase.notification.all.conflicts.resolved.continue.rebase.action.text=繼續重定基底(&T)
rebase.notification.all.conflicts.resolved.text=所有衝突都已解決。是否要繼續重定基底?
rebase.notification.all.conflicts.resolved.title=解決衝突
rebase.notification.conflict.title=由於衝突，重定基底停止
rebase.notification.continue.failed.stage.changes.text=無法暫存追蹤檔案中的更改
rebase.notification.continue.failed.unstaged.changes.text=追蹤檔案中存在未暫存的更改，阻止繼續重定基底
rebase.notification.editing.title=重定基底已停止，可以進行編輯
rebase.notification.failed.continue.title=繼續重定基底失敗
rebase.notification.failed.rebase.title=重定基底失敗
rebase.notification.no.rebase.in.progress.abort.title=無法中止重定基底
rebase.notification.no.rebase.in.progress.continue.title=無法繼續重定基底
rebase.notification.no.rebase.in.progress.message=沒有正在進行的重定基底
rebase.notification.not.allowed.empty.repository.message=版本庫 {0} 為空。
rebase.notification.not.allowed.grafting.message.first={0} 中有一個未完成的優選程序。
rebase.notification.not.allowed.grafting.message.second=在開始重定基底前，應先完成這項動作。
rebase.notification.not.allowed.merging.message.first={0} 中有一個未完成的合併程序。
rebase.notification.not.allowed.merging.message.second=在開始重定基底前，應先完成合併。
rebase.notification.not.allowed.message=無法在 {0} 中進行重定基底。
rebase.notification.not.allowed.rebasing.message.first={0} 中有一個未完成的重定基底程序。
rebase.notification.not.allowed.rebasing.message.second=在開始另一個重定基底前，應先完成這項動作。
rebase.notification.not.allowed.reverting.message.first={0} 中有一個未完成的還原程序。
rebase.notification.not.allowed.reverting.message.second=在開始重定基底前，應先完成這項動作。
rebase.notification.not.allowed.title=不允許重定基底
rebase.notification.not.started.title=重定基底未啟動
rebase.notification.saved.local.changes.part.shelf.text=重定基底前已擱置本地更改。
rebase.notification.saved.local.changes.part.stash.text=重定基底前已隱藏本地更改。
rebase.notification.successful.rebased.checkout.message=已簽出{0,choice,0#|1# {1} }並將其重定基底{2,choice,0#|1#到 {3}}
rebase.notification.successful.rebased.message=已{0,choice,0#|1#將 {1} }重定基底{2,choice,0#|1#到 {3}}
rebase.notification.successful.title=重定基底成功
rebase.operation.name=重定基底
rebase.option.interactive=在重定基底之前編輯提交
rebase.option.keep.empty=重定基底期間不移除空提交
rebase.option.onto=為重定基底的提交指定新基
rebase.option.rebase.merges=重新建立提交拓撲
rebase.option.root=重定基底分支中的所有提交
rebase.option.switch.to.branch=選擇另一個要重定基底的分支
rebase.option.update.refs=自動更新指向重定基底的提交的分支
rebase.options.modify.dialog.title=新增重定基底選項
rebase.progress.indicator.aborting.title=正在中止重定基底程序…
rebase.progress.indicator.conflicts.collecting.title=正在收集要解決的衝突…
rebase.progress.indicator.continue.title=正在繼續重定基底程序…
rebase.progress.indicator.preparing.title=正在準備重定基底…
rebase.progress.indicator.retry.title=正在重試重定基底程序…
rebase.progress.indicator.title=正在重定基底…
rebase.simple.editor.dialog.title=Git 編輯器
rebase.tracked.files.with.unstaged.changes.empty.text=沒有未暫存的檔案
rebase.tracked.files.with.unstaged.changes.title=具有未暫存更改的追蹤檔案
rebase.update.project.abort.task.title=正在中止重定基底…
rebase.update.project.conflict.error.notification.description=然後，您可以<b>繼續重定基底</b>。<br/>您也可以<b>中止重定基底</b>以還原原始分支並停止重定基底。
rebase.update.project.conflict.error.notification.title=無法繼續重定基底
rebase.update.project.conflict.merge.description.label=檢測到合併衝突。請先解決這些衝突，然後再繼續重定基底。
rebase.update.project.notification.abort.error.message=中止重定基底時出錯
rebase.update.project.notification.abort.success.message=已中止重定基底
rebase.update.project.notification.failed.message=無法繼續重定基底。{0}
rebase.update.project.notification.failed.title=重定基底錯誤
rebase.using.log.couldnt.start.error=由於 IDE 生成的 'git-rebase-todo' 檔案無效，因此無法執行重定基底。是否要使用 Git 原生檔案生成來重試重定基底?
rebasing.merge.commits.button.cancel=取消
rebasing.merge.commits.button.merge=合併
rebasing.merge.commits.button.rebase=重定基底
reference.validating.progress.indicator.title=正在驗證修訂…
remote.dialog.add.remote=新增遠端
remotes.changing.remote.error.message=無法將遠端 {0} 更改為 {1} ''{2}''
remotes.changing.remote.error.title=更改遠端
remotes.changing.remote.progress=正在更改遠端…
remotes.define.duplicate.remote.name.validation.message=遠端名稱 ''{0}'' 已被使用
remotes.define.empty.remote.name.validation.message=遠端名稱不能為空
remotes.define.empty.remote.url.validation.message=遠端 URL 不能為空
remotes.define.invalid.remote.name.validation.message=遠端名稱包含非法字元
remotes.define.remote=定義遠端
remotes.define.remote.name=名稱:
remotes.define.remote.url=URL:
remotes.dialog.adding.remote=正在新增遠端…
remotes.dialog.cannot.add.remote.error.message=無法新增遠端 {0} ''{1}''
remotes.dialog.remove.remote.message=移除{0,choice,1#遠端|2#遠端}{1}?
remotes.dialog.remove.remote.title=移除{0,choice,1#遠端|2#遠端}
remotes.dialog.removing.remote.error.message=無法移除{0, choice, 1#遠端|2#遠端} {1}
remotes.dialog.removing.remote.error.title=移除{0,choice,1#遠端|2#遠端}
remotes.dialog.removing.remote.progress=正在移除{0,choice,1#遠端|2#遠端}…
remotes.dialog.title=Git 遠端
remotes.fetch.remote.text=獲取遠端
remotes.operation.error.message=在 {1} 中{0}:\\n{2}
remotes.operation.not.executed.message=動作未執行
remotes.remote.column.name=名稱
remotes.remote.column.url=URL
remove.removing=正在移除檔案…
rename.branch.operation.name=重新命名
repositories=版本庫
repository.action.missing.roots.misconfigured=組態的 Git 根都不在 Git 下。組態的目錄中必須包含“.git”目錄。
repository.action.missing.roots.title=沒有 Git 根
repository.action.missing.roots.unconfigured.message=沒有為專案組態 Git 根。
repository.not.found.error=找不到 {0} 的已組態 Git 版本庫
reset.action.name=重設 Head…
reset.commit.invalid=指定的提交表達式未通過驗證。
reset.commit.label=為提交(&C):
reset.commit.tooltip=由於重設動作而將成為當前 HEAD 的提交。
reset.title=重設 Head
reset.type=重設類型(&T):
reset.type.tooltip=<html>重設類型(另請參閱 <code>git reset</code> man 頁面):<ul><li><b>Mixed</b> 將重設索引，但不會重設工作樹</li><li><b>Soft</b> 將保留索引和工作樹，只是移動 HEAD 指針</li><li><b>Hard</b> 將重設索引和工作樹。<em>工作樹中的更改會丟失</em></li></ul></html>
reset.validate=驗證(&V)
resetting.title=正在重設 HEAD…
restore.conflict.dialog.description.label.text=在 {0} 之前儲存的未提交更改與 {1} 中的檔案衝突
restore.conflict.diff.dialog.left.shelf.title=擱置中的未提交更改
restore.conflict.diff.dialog.left.stash.title=隱藏中的未提交更改
restore.conflict.diff.dialog.right.title=來自 {0} 的更改
restore.notification.failed.shelf.message=在{0}之前，您未提交的更改已儲存至擱置。
restore.notification.failed.show.changes.action=檢視已儲存的更改…
restore.notification.failed.stash.message=在{0}之前，您的未提交的更改已儲存至隱藏。
restore.notification.failed.title=未還原本地更改
revert.operation.applied=還原
revert.operation.name=還原
revision.load.contents=載入修訂內容
revision.number.cannot.parse.output=無法解析輸出: [{0}]
save.load.conflict.dialog.diff.left.title=您未提交的更改
save.load.conflict.dialog.diff.right.title=遠端更改
save.notification.failed.shelf.text=無法擱置本地未提交的更改:
save.notification.failed.stash.text=無法隱藏本地未提交的更改:
save.notification.failed.title=無法儲存 {0} 上未提交的更改
search.everywhere.group.full.name=Git 參照
search.everywhere.group.name=Git
search.everywhere.items.commit.by.hash=提交(按雜湊)
search.everywhere.items.commit.by.message=提交(按訊息)
search.everywhere.items.local.branch=本地分支
search.everywhere.items.remote.branch=遠端分支
search.everywhere.items.tag=標記
search.scope.project.git.exclude.ignored=專案檔案，不包括 Git 忽略的檔案
search.scope.project.git.tracked=Git 追蹤的專案檔案
separator.Git.Stage.Configure.display.as=顯示為
separator.git.branches.popup.filter.by=在搜尋結果中新增
separator.show=顯示
settings.add.suffix=在挑選推送到受保護分支的提交時，新增 'cherry-picked from <hash>' 後綴
settings.auto.update.on.push.rejected=如果當前分支的推送被拒，則自動更新
settings.bad.file.names=提交名稱可能會導致其他系統出現問題的檔案時發出警告
settings.clean.working.tree=使用以下方法清理工作樹:
settings.commit.group.title=提交
settings.configure.sign.gpg.do.not.sign.table.text=不簽署
settings.configure.sign.gpg.error.no.available.keys.found.text=找不到適用的私鑰
settings.configure.sign.gpg.error.table.text=錯誤: {0}
settings.configure.sign.gpg.for.repo.dialog.title=組態 GPG 密鑰 {0}
settings.configure.sign.gpg.for.repos.dialog.title=組態 GPG 密鑰
settings.configure.sign.gpg.gpg.kep.table.column.name=GPG 密鑰
settings.configure.sign.gpg.loading.table.text=正在載入…
settings.configure.sign.gpg.root.table.column.name=根
settings.configure.sign.gpg.synced.with.gitconfig.text=與 gitconfig 同步
settings.configure.sign.gpg.with.key.checkbox.text=使用 GPG 密鑰簽署提交:
settings.credential.helper=使用憑證幫助程序
settings.crlf=如果即將提交 CRLF 行分隔符，則發出警告
settings.detached.head=在游離的 HEAD 中或重定基底期間提交時發出警告
settings.enable.staging.area=啟用暫存區域
settings.enable.staging.area.comment=這將停用更改列表支援。僅適用於非強制回應提交介面。
settings.enable.stashes.and.shelves=將隱藏和擱置合併到一個頁籤中
settings.explicitly.check=顯式檢查遠端分支上的傳入提交:
settings.explicitly.check.condition.comment=需要在“進階設定”中啟用 ''{0}'' 選項
settings.filter.update.info=按路徑過濾“更新專案”資訊:
settings.git.fetch.tag.mode.always=始終
settings.git.fetch.tag.mode.default=自動
settings.git.fetch.tag.mode.default.description=遵循 git 組態
settings.git.fetch.tag.mode.never=從未
settings.git.fetch.tag.mode.prune=同步
settings.git.fetch.tags.label=獲取標記:
settings.git.incoming.change.strategy.text.always=始終
settings.git.incoming.change.strategy.text.auto=自動
settings.git.incoming.change.strategy.text.never=從不
settings.git.option.group=Git
settings.git.update.method.branch.default=分支預設
settings.git.update.method.merge=合併
settings.git.update.method.merge.description=&將傳入更改合併到當前分支
settings.git.update.method.rebase=重定基底
settings.git.update.method.rebase.description=&在傳入更改上重定基底當前分支
settings.label.sign.gpg.commits.enabled.different.keys.text=提交使用不同的 GPG 密鑰簽署
settings.label.sign.gpg.commits.enabled.n.roots.of.m.text=提交使用 {1} 的 {0} 個{0,choice,1#根|2#根}中的 GPG 密鑰簽署
settings.label.sign.gpg.commits.enabled.text=提交使用 GPG 密鑰簽署: {0}
settings.label.sign.gpg.commits.no.roots.text=專案中沒有 Git 根
settings.label.sign.gpg.commits.not.configured.text=未組態使用 GPG 密鑰簽署提交
settings.large.files=提交大於以下大小的檔案時發出警告:
settings.large.files.suffix=MB
settings.protected.branched=受保護分支:
settings.protected.branched.validation=跳過無效的受保護分支模式 ''{0}'': {1}
settings.push.dialog=顯示提交和推送的推送對話框
settings.push.dialog.for.protected.branches=僅在提交到受保護分支時顯示推送對話框
settings.push.group.title=推送
settings.show.rebase.log.drop.confirmation=要求確認刪除提交
settings.show.rebase.log.drop.confirmation.description=適用於 Git
settings.sign.gpg.configure.link.text=組態 GPG 密鑰…
settings.stash=隱藏
settings.stash.show.diff.group=呼叫“顯示差異”時，比較隱藏的更改:
settings.stash.show.diff.with.head=與父提交
settings.stash.show.diff.with.local=與檔案的本地版本
settings.synchronize.branch.protection.rules=從 GitHub 載入分支保護規則
settings.synchronize.branch.protection.rules.description=將 GitHub 規則新增到本地規則中，並在每次獲取時進行同步
settings.update.group.title=更新
settings.update.method=更新方法:
share.action.remote.is.on.host=遠端已經在 {0} 上:
share.action.remotes.are.on.host={0} 上已經有以下遠端:
share.anyway.button=仍然共享
share.error.cannot.find.git.repo=找不到 Git 版本庫
share.error.cannot.finish=無法完成 {0} 共享過程
share.error.created.project=專案建立成功
share.error.failed.to.create.repo=無法建立版本庫
share.error.init.commit.failed=({0})，但初始提交失敗:<br/>
share.error.project.is.on.host=專案已在 {0} 上
share.error.push.failed=({0})，但初始推送失敗:<br/>{1}
share.error.push.no.current.branch=({0})，但初始推送失敗: 沒有當前分支
share.error.unknown=未知錯誤
share.error.unknownHost=未知主機: {0}
share.process=正在 {0} 中共享專案…
share.process.adding.files=正在將檔案新增到 git…
share.process.adding.gh.as.remote.host=正在將 {0} 新增為遠端主機…
share.process.creating.git.repository=正在建立空 git 版本庫…
share.process.creating.repository=正在建立 {0} 版本庫…
share.process.empty.project.created=已在 {0} 上成功建立空版本庫
share.process.loading.account.info=正在載入 {0} 的帳戶資訊
share.process.performing.commit=正在執行提交…
share.process.pushing.to.host.master=正在推送至 {0} {1}…
share.process.retrieving.username=正在檢索用戶名…
share.process.successfully.shared=在 {0} 中成功共享專案
share.untracked.files.dialog.title=為初始提交新增檔案
show.diff.between.dialog.could.not.load.diff.with.branch.error=無法載入與 {0} 的差異: {1}
show.diff.between.dialog.no.differences.empty.text=無差異
show.diff.between.dialog.title={0}與當前工作樹之間的更改
smart.operation.dialog.don.t.operation.name=不{0}
smart.operation.dialog.git.operation.name.problem=Git {0} 問題
smart.operation.dialog.north.panel.label.shelf.text=<html>您對以下檔案的本地更改將被{0}覆蓋。<br/>{1}可以擱置這些更改，{0}，並在之後取消擱置。</html>
smart.operation.dialog.north.panel.label.stash.text=<html>您對以下檔案的本地更改將被{0}覆蓋。<br/>{1} 可以隱藏這些更改，{0}，並在之後取消隱藏。</html>
smart.operation.dialog.ok.action.shelf.description=擱置本地更改，{0}，取消擱置
smart.operation.dialog.ok.action.stash.description=隱藏本地更改，{0}，取消隱藏
smart.operation.dialog.operation.name.and.overwrite.local.changes={0}並覆蓋本地更改
smart.operation.dialog.smart.operation.name=智能{0}
stage.add.action.text=暫存
stage.add.error.title=無法暫存檔案
stage.add.no.content.action.text=在沒有內容的情況下暫存
stage.add.process=正在暫存檔案…
stage.add.range.command.name=暫存更改
stage.commit.all.text=全部提交(&I)
stage.commit.failed=無法提交 {0}
stage.commit.process=正在提交暫存更改…
stage.commit.successful=已提交 {0}: {1}
stage.content.local=本地
stage.content.staged=已暫存
stage.default.status=沒有要提交的內容，工作樹是乾淨的
stage.default.status.help=暫存區域入門
stage.diff.local.content.exception.message=無法獲取本地檔案: ''{0}''
stage.diff.staged.content.exception.message=無法獲取暫存內容: ''{0}''
stage.loading.status=正在載入更改…
stage.reset.action.text=取消暫存
stage.reset.error.title=無法取消暫存檔案
stage.reset.process=正在取消暫存檔案…
stage.revert.action.text=復原
stage.revert.error.title=無法復原檔案
stage.revert.process=正在復原檔案…
stage.revert.staged.range.command.name=復原暫存的更改
stage.revert.unstaged.range.command.name=復原未暫存的更改
stage.tree.node.ignored=已忽略
stage.tree.node.staged=已暫存
stage.tree.node.unmerged=已取消合併
stage.tree.node.unstaged=未暫存
stage.tree.node.untracked=已取消追蹤
stage.vfs.editor.notification.link=開啟本地版本
stage.vfs.editor.notification.text=這是暫存版本的 ''{0}''
stage.vfs.editor.tab.tooltip=''{0}'' 的暫存版本
stage.vfs.presentable.file.name=已暫存: {0}
stage.vfs.read.process=正在從 Git 索引讀取 {0}
stage.vfs.shutdown.process=正在關閉 Git 索引 VFS
stage.vfs.write.process=正在將 {0} 寫入 Git 索引
stash.action.name=隱藏
stash.button=建立隱藏
stash.changes.non.empty.index.for.roots.notification.text={0} 中的暫存區域包含對儲存到隱藏的其他檔案的修改
stash.changes.non.empty.index.notification.action=不再顯示
stash.editor.diff.preview.empty.title=隱藏
stash.editor.diff.preview.id.change.title={0}: {1}
stash.empty.text.help.link=隱藏和擱置入門
stash.enable.stashes.link=啟用並檢視 Git 隱藏
stash.error=無法隱藏 {0}
stash.error.can.not.stash.changes.now=現在無法隱藏更改
stash.files.action.text=隱藏檔案
stash.files.error.message=無法隱藏檔案
stash.files.in.roots.success={0} 中的檔案已成功隱藏
stash.files.progress.title=正在隱藏檔案
stash.files.success=檔案已成功隱藏
stash.keep.index=保留索引(&I)
stash.keep.index.tooltip=如果選中此複選框，所有已新增到索引中的更改將保持不變
stash.load.changes.error=無法在解析為 {1} 的隱藏中載入根 {0} 中的更改
stash.message=訊息(&M):
stash.message.tooltip=在此處輸入隱藏訊息
stash.progress.indicator.title=正在隱藏來自 ''{0}'' 的更改…
stash.root.node.title=隱藏
stash.tab.name=儲藏
stash.title=隱藏
stash.unstash.changes.current.branch.label=當前分支:
stash.unstash.changes.in.root.dialog.title=取消隱藏 {0} 中的更改
stash.unstash.conflict.dialog.description.label.text=更新前隱藏的未提交更改與更新後的檔案衝突。
stash.unstash.progress.indicator.title=正在消除對 ''{0}'' 的更改…
stash.unstash.unresolved.conflict.warning.notification.message=您的未提交更改已儲存到隱藏。<br/>取消隱藏未完成，您的工作樹中有未解決的合併<br/>請解決衝突並刪除隱藏。
stash.unstash.unresolved.conflict.warning.notification.resolve.conflicts.action=解決衝突…
stash.unstash.unresolved.conflict.warning.notification.show.stash.action=檢視已儲存的更改…
stash.unstash.unresolved.conflict.warning.notification.title=本地更改已還原，但存在衝突
stash.view.stashes.link=檢視 Git 隱藏
stashes.and.shelves.tab.name=儲藏和擱置
stashing.progress.title=正在隱藏更改…
stashing.title=正在隱藏更改…
stats.wrong.git.shortlog.response=Git 快捷日誌輸出中出現意外行 ''{0}''
status.exception.message.format.message.xstatus.ystatus.line.output={0} xStatus=[{1}]，yStatus=[{2}]，行=[{3}]\\n輸出:\\n{4}
status.exception.message.line.is.too.short=此行過短
status.exception.message.missing.path=缺少初始路徑
status.exception.message.unexpected=意外的狀態符號
status.exception.message.unexpected.status=意外的狀態符號: ''{0}''
status.exception.message.unexpected.xstatus.ystatus=意外的狀態符號: ''{0}{1}''
tab.title.conflicts=衝突
tab.title.repo.root.name.at.revision={1} 的 {0}
tag.action.name=標記
tag.button=建立標籤
tag.commit.label=提交(&C)
tag.commit.tooltip=輸入要標記的提交或物件的名稱，或留空以使用 HEAD。
tag.error.creating.message.file.message=無法建立訊息檔案: {0}
tag.error.invalid.commit=該提交或物件名稱無效。
tag.error.tag.exists=存在同名的標記。
tag.force=強制(&F)
tag.force.tooltip=強制建立標記，即使已存在另一個具有此名稱的標記。
tag.getting.existing.tags=正在獲取現有標記…
tag.message.label=訊息(&M):
tag.message.tooltip=如果訊息不為空，則建立帶註解的標記。
tag.name.label=標記名稱(&N):
tag.name.tooltip=在此處輸入新的標記名稱。
tag.progress.title=正在新增標記…
tag.title=標記
tag.validate=驗證(&V)
tag.validate.tooltip=點擊此按鈕驗證要標記的提交
text.crlf.fix.dialog.description.proposed.fix=如果選擇<b>修正並提交</b>，將執行 {0}。<br/>如果選擇<b>按原樣提交</b>，則不會更改組態值。
text.crlf.fix.dialog.description.warning=您即將把 CRLF 行分隔符提交到 Git 版本庫。<br/>建議將 {0} Git 特性設定為 {1}，以免發生行分隔符問題。
text.crlf.fix.notification.description.warning=您即將向 Git 版本庫提交 CRLF 行分隔符
title.changes.excluded.from.commit=已從合併提交中排除更改
title.crlf.fix.dialog=行分隔符警告
title.sudo.command.install.git=安裝 Git
title.unresolved.conflicts.pre.commit.check=未解決的衝突
title.user.name.email.not.specified=未定義 Git 用戶名
tooltip.run.git.hooks=如果未選中，會在即將進行的提交中使用 '--no-verify' 選項跳過 Git 掛鈎
tooltip.run.git.hooks.disabled=已在“進階設定”中停用執行 Git 掛鈎
tracked.branch.fix.dialog.branch.placeholder=指定分支
tracked.branch.fix.dialog.not.on.branch.message=將跳過以下版本庫:
tracked.branch.fix.dialog.not.on.branch.title=游離的 HEAD 中的 Git 版本庫
tracked.branch.fix.dialog.ok.button.text=更新
tracked.branch.fix.dialog.set.as.tracked=設為追蹤分支
tracked.branch.fix.dialog.title=更新
unexpected.tree.entries.error=意外的樹條目: {0}
unexpected.tree.object.error=意外的樹物件: {0}
unshallow.repository.notification.message=檢測到淺層版本庫
unshallow.repository.notification.success.title=版本庫已轉換為完整版本庫
unshallow.repository.notification.title=此版本庫可以轉換為完整版本庫
unstash.action.name=取消隱藏
unstash.branch.label=作為新分支(&B):
unstash.branch.tooltip=如果輸入非空名稱，該隱藏將作為新分支簽出
unstash.button.apply=套用隱藏
unstash.button.branch=分支
unstash.button.pop=消除隱藏
unstash.clear=清除(&C)
unstash.clear.confirmation.message=移除所有隱藏? 此動作無法撤消。
unstash.clear.confirmation.title=移除所有隱藏?
unstash.clear.tooltip=刪除版本庫中的所有隱藏
unstash.clearing.stashes=正在清除隱藏…
unstash.conflict.dialog.description.label.text=取消隱藏 {0} 時發生衝突
unstash.conflict.diff.dialog.left.title=本地更改
unstash.conflict.diff.dialog.right.title=來自隱藏的更改
unstash.dialog.remove.stash.progress.indicator.title=正在移除隱藏 {0}…
unstash.dialog.show.stashes.error.dialog.title=無法顯示隱藏列表
unstash.dialog.stash.list.load.progress.indicator.title=正在載入隱藏列表…
unstash.dialog.unresolved.conflict.warning.notification.message=取消隱藏未完成，您的工作樹中存在未解決的合併。
unstash.dialog.unresolved.conflict.warning.notification.title=取消隱藏期間未解決衝突
unstash.dialog.unresolved.conflict.warning.resolve.conflicts.action=解決衝突…
unstash.drop=刪除(&D)
unstash.drop.confirmation.message=<html>是否要移除 {0}?<br/>“{1}”</html>
unstash.drop.confirmation.title=移除隱藏 {0}?
unstash.drop.tooltip=刪除所選隱藏
unstash.error.can.not.unstash.changes.now=現在無法取消隱藏更改
unstash.operation.name=取消隱藏
unstash.pop.stash=消除隱藏(&P)
unstash.pop.stash.tooltip=如果選中，則該隱藏在套用後會被刪除
unstash.reinstate.index=復原索引(&I)
unstash.reinstate.index.tooltip=嘗試復原索引以及工作樹更改
unstash.stash.applied=已成功套用隱藏
unstash.stashes=隱藏(&S):
unstash.title=取消隱藏更改
unstash.unstashed.with.conflicts.error.title=已取消隱藏，但存在衝突
unstash.unstashing=正在取消隱藏…
unstash.view=檢視(&V)
unstash.view.dialog.title=受 {0} 影響的路徑
unstash.view.tooltip=檢視所選隱藏
update.checks.not.supported.git.2.9.required=不支持更新檢查。需要 Git 2.9 及以上版本
update.notification.choose.upstream.branch=選擇上游分支
update.notification.update.error=無法更新
update.options.display.name=Git 更新設定
update.process.error.additional.description.unfinished.rebase=然後，您可以<b>繼續重定基底</b>。<br/>您也可以<b>中止重定基底</b>以還原原始分支並停止重定基底。
update.process.error.description.unfinished.rebase=您有未完成的重定基底程序。必須先解決這些衝突，然後才能更新。
update.process.error.message.unfinished.merge=您有未完成的合併。必須先解決這些衝突，然後才能更新。
update.process.error.message.unmerged.files=檢測到未合併的檔案。必須先解決這些衝突，然後才能更新。
update.process.error.notification.title=無法設定上游分支
update.process.generic.error.title=無法更新
update.process.nothing.to.update=沒有要更新的內容
update.process.progress.title=正在更新…
update.skip.root.reason.detached.head=游離的 HEAD
update.skip.root.reason.no.tracked.branch=無追蹤分支
util.remote.renderer.none=無
validation.error.email.no.at=電子郵件地址必須包含 '@' 符號
validation.warning.set.name.email.for.git=您必須為 Git 指定用戶名和電子郵件
vcs.history.action.gitlog=在 Git 日誌中顯示
vcs.log.archiving.log.index.data=正在歸檔 Git 日誌索引資料…
vcs.log.create.archive.with.log.index.data=傾印 Git 日誌索引資料
vcs.log.status.bar.extracting.log.index.data=正在獲取 Git 日誌索引資料…
vcs.log.status.bar.replacing.log.index.data=正在取代 Git 日誌索引資料…
vcs.log.use.log.index.data=使用共享 Git 日誌索引資料
vfs.listener.add.single.prompt=是否要安排將以下檔案新增到 Git?\\n{0}\\n\\n如果您選擇“取消”，以後仍可以手動新增。
vfs.listener.add.single.title=將檔案新增到 Git
vfs.listener.add.title=將檔案新增到 Git
vfs.listener.checking.ignored=正在檢查忽略的檔案…
vfs.listener.delete.single.prompt=是否要從 Git 中刪除以下檔案?\\n{0}\\n\\n如果您選擇“取消”，以後仍可以手動刪除。
vfs.listener.delete.single.title=從 Git 中刪除檔案
vfs.listener.delete.title=從 Git 中刪除檔案
warning.message.commit.with.bad.windows.file.name.bad.character=某些檔名包含 Windows 不允許的字元: ''{0}''。\\n如果提交，可能無法在 Windows 上檢出 Git 版本庫。
warning.message.commit.with.bad.windows.file.name.reserved=某些檔案使用 Windows 不允許的保留名稱: ''{0}。\\n如果提交，將無法在 Windows 上檢出 Git 版本庫。
warning.message.commit.with.detached.head=以下路徑中的 Git 版本庫處於<b>游離的 HEAD</b> 狀態: <br/>{0}<br/>您可以進行檢查，嘗試做出更改並提交，但務必簽出分支，以免丟失您的工作。<br/>否則，可能會丟失所做的更改。
warning.message.commit.with.unfinished.rebase=以下路徑中的 Git 版本庫有一個<b>未完成的重定基底</b>程序: <br/> {0}<br/>您可能想<b>繼續重定基底</b>而不是提交。<br/>在重定基底期間提交可能會導致提交丟失。
warning.title.commit.with.bad.windows.file.name=檔名不允許在 Windows 上使用
warning.title.commit.with.detached.head=在游離的 HEAD 中提交
warning.title.commit.with.unfinished.rebase=未完成重定基底程序
warning.your.local.changes.would.be.overwritten.by=您的本地更改將被 {0} 覆蓋。\\n提交、{1}或還原您的更改以繼續。"
`;

exports[`dev messages/GithubBundle.properties 1`] = `
"account.choose.as.default=設定為當前專案的預設帳戶
account.choose.button=選擇
account.choose.for=選擇 GitHub 帳戶\\: {0}
account.choose.not.selected=未選擇帳戶
account.choose.title=選擇 GitHub 帳戶
accounts.add.button=新增帳戶
accounts.add.dropdown.link=新增帳戶
accounts.default.missing=缺少預設的 GitHub 帳戶
accounts.relogin=重新登入
action.GitHub.Diff.Review.NextComment.description=轉到下一個可見註釋
action.GitHub.Diff.Review.NextComment.text=下一個註釋
action.GitHub.Diff.Review.PreviousComment.description=轉到上一個可見註釋
action.GitHub.Diff.Review.PreviousComment.text=上一個註釋
action.Github.Accounts.AddGHAccount.text=通過 GitHub 登入…
action.Github.Accounts.AddGHAccountWithToken.text=通過令牌登入…
action.Github.Accounts.AddGHEAccount.text=登入 GitHub Enterprise…
action.Github.Add.Account.synonym=新增 GitHub 帳戶
action.Github.Clone.MainMenu.text=克隆版本庫…
action.Github.Clone.popup@GoToAction.text=克隆版本庫…
action.Github.Clone.text=從 GitHub 克隆版本庫…
action.Github.Create.Gist.description=建立 GitHub gist
action.Github.Create.Gist.text=建立 Gist…
action.Github.Create.Pull.Request.synonym1=新增拉取請求/合併請求/程式碼審查
action.Github.Create.Pull.Request.synonym2=啟動拉取請求/合併請求/程式碼審查
action.Github.Create.Pull.Request.synonym3=建立合併請求/程式碼審查
action.Github.Create.Pull.Request.text=建立拉取請求…
action.Github.Open.Settings.MainMenu.text=管理帳戶…
action.Github.Open.Settings.popup@GoToAction.text=管理帳戶…
action.Github.Open.Settings.text=管理 GitHub 帳戶…
action.Github.Pull.Request.Branch.Update.text=更新以啟用審查模式…
action.Github.Pull.Request.Review.In.Editor.Toggle.text=審查模式
action.Github.Pull.Request.Show.In.Toolwindow.text=在工具視窗中顯示拉取請求
action.Github.PullRequest.Changed.MarkViewed.Toggle.text=切換已檢視/未檢視狀態
action.Github.PullRequest.Copy.Link.text=複製拉取請求 URL
action.Github.PullRequest.Open.Link.text=在瀏覽器中開啟拉取請求
action.Github.Share.Vcs.Toolbar.Widget.text=GitHub…
action.Github.Share.description=在 GitHub 上建立版本庫並將您的提交推送到該版本庫
action.Github.Share.text=在 GitHub 上共享專案
action.Github.Sync.Fork.description=相對於來源重定基底 GitHub 複刻版本庫
action.Github.Sync.Fork.text=同步複刻
action.Github.View.Pull.Request.synonym1=檢視合併請求/程式碼審查
action.Github.View.Pull.Request.text=檢視拉取請求
action.comment.text=評論
button.use.token=使用令牌…
cannot.configure.remote=無法組態 ''{0}'' 遠端\\:\\n{1}
cannot.create.gist=無法建立 Gist
cannot.display.item=無法顯示條目 - {0}
cannot.load.changes=無法載入更改
cannot.load.commits=無法載入提交
cannot.load.data=無法載入資料
cannot.load.details=無法載入詳細資訊
cannot.load.repo.info=無法載入版本庫資訊
create.gist.dialog.copy.url=複製 URL
create.gist.dialog.create.for.field=為以下帳戶建立\\:
create.gist.dialog.description.field=描述\\:
create.gist.dialog.filename.field=檔名\\:
create.gist.dialog.open.browser=在瀏覽器中開啟
create.gist.dialog.secret=私密
create.gist.dialog.title=建立 Gist
create.gist.error.binary.file=無法上傳二進制檔案\\: {0}
create.gist.error.content.read=無法讀取檔案 {0} 的內容
create.gist.error.empty=無法建立空 gist
create.gist.process=正在建立 gist…
create.gist.success=已成功建立 Gist
create.gist.url=在 GitHub 上開啟
credentials.button.generate=生成…
credentials.incorrect=憑證不正確。\\n{0}
credentials.invalid.auth.data=身份驗證資料無效。\\n{0}
credentials.invalid.server.path=伺服器路徑無效
credentials.server.cannot.be.empty=伺服器不能為空
credentials.server.field=伺服器\\:
credentials.server.path.invalid=伺服器 URL 無效
credentials.token.field=令牌\\:
dialog.message.account.cannot.be.empty=帳戶不能為空
dialog.message.login.to.continue=登入到 GitHub 以繼續
dialog.title.add.github.account=新增 GitHub 帳戶
github.actions.action.file.json.schema=GitHub Action JSON 架構
github.actions.file.promo.label=GitHub Actions
github.actions.workflow.file.json.schema=GitHub Workflow JSON 架構
gql.error.in.field={1} 的“{2}”欄位中存在 {0} 錯誤
group.GitHub.Copy.Link.CopyReferencePopup.text=GitHub 版本庫 URL
group.GitHub.Copy.Link.text=將連結複製到 GitHub 版本庫
group.GitHub.MainMenu.text=GitHub
group.Github.Open.In.Browser.EditorTabPopup.text=在瀏覽器中開啟
group.Github.PullRequest.Details.Commit.Tree.ViewOptions.text=檢視選項
group.Github.PullRequest.Diff.Thread.View.Options.text=顯示審查會話
issue.state.closed=已關閉
issue.state.open=開放
label.login.option.separator=或
label.login.progress=正在登入…
link.label.use.token=使用令牌…
login.account.already.added=已新增帳戶 ''{0}''
login.to.github=登入 GitHub
login.to.github.enterprise=登入 GitHub Enterprise
login.to.github.enterprise.action=登入 GitHub Enterprise…
login.token.cannot.be.empty=令牌不能為空
login.via.github.action=通過 GitHub 登入…
open.on.github.action=在 GitHub 上開啟
open.on.github.action.description=在瀏覽器中開啟相應連結
progress.text.loading.protected.branches=正在載入 GitHub 分支保護規則
pull.request.adding.reviewers=正在新增審查者
pull.request.adjustment.failed=無法調整列表
pull.request.assignees=被指派者\\:
pull.request.assignees.popup={0, choice, 1\\#被指派者|2\\#被指派者}
pull.request.change.remote.or.account=更改版本庫或帳戶…
pull.request.close.action=關閉拉取請求
pull.request.comment.hint={0} 以評論
pull.request.comment.suggested.changes.applying=正在套用更新檔
pull.request.comment.suggested.changes.committing=正在套用並提交更改
pull.request.comment.suggested.changes.resolving=正在解析會話
pull.request.commit.does.not.contain.changes=提交不包含任何更改
pull.request.commits=提交
pull.request.conflicts.merge.tooltip=拉取請求無法合併
pull.request.create.action=建立拉取請求
pull.request.create.already.exists=拉取請求已存在
pull.request.create.already.exists.view=檢視
pull.request.create.checking.branches=正在檢查拉取請求分支
pull.request.create.creating=正在建立拉取請求
pull.request.create.description=描述
pull.request.create.draft.action=建立草稿拉取請求
pull.request.create.error=無法建立拉取請求
pull.request.create.error.details=詳細資訊
pull.request.create.failed.to.check.branches=無法檢查拉取請求分支
pull.request.create.failed.to.load.changes=無法載入更改
pull.request.create.failed.to.load.commits=無法載入提交
pull.request.create.input.remote.branch.comment=您的更改將被推送到遠端版本庫以建立拉取請求
pull.request.create.input.remote.branch.name=遠端分支名稱\\:
pull.request.create.input.remote.branch.title=為拉取請求新增遠端分支
pull.request.create.no.changes=''{0}'' 和 ''{1}'' 之間沒有更改
pull.request.create.no.commits=無提交
pull.request.create.process.title=正在建立拉取請求…
pull.request.create.pushing=正在推送拉取請求分支
pull.request.create.select.branches=選擇拉取請求的 base 和 head 來檢視更改
pull.request.create.setting.metadata=正在更新拉取請求欄位
pull.request.create.title=標題
pull.request.details.adjusting.assignees=正在調整被指派者…
pull.request.details.adjusting.labels=正在調整標籤…
pull.request.details.adjusting.reviewers=正在調整審查者…
pull.request.diff.editor.title=拉取請求 \\#{0,number,\\#} 的差異
pull.request.discard.pending.comments=捨棄待定評論
pull.request.discard.pending.comments.dialog.msg=確定要刪除所有待定評論嗎?
pull.request.discard.pending.comments.dialog.title=捨棄待定審查
pull.request.does.not.contain.changes=拉取請求不包含任何更改
pull.request.does.not.contain.commits=拉取請求不包含任何提交
pull.request.editor.timeline=拉取請求時間線
pull.request.files=檔案
pull.request.info=資訊
pull.request.labels=標籤\\:
pull.request.labels.popup={0, choice, 1\\#標籤|2\\#標籤}
pull.request.list.cannot.load=無法載入拉取請求
pull.request.list.error.authorization=使用者授權失敗
pull.request.list.filter.assignee=被指派者
pull.request.list.filter.author=作者
pull.request.list.filter.label=標籤
pull.request.list.filter.quick.assigned=已分配給您
pull.request.list.filter.quick.open=開啟
pull.request.list.filter.quick.review.requests=審查請求
pull.request.list.filter.quick.yours=您的拉取請求
pull.request.list.filter.review=審查
pull.request.list.filter.review.approved.full=批准的審查
pull.request.list.filter.review.approved.short=批准的審查
pull.request.list.filter.review.awaiting.full=正在等待您的審查
pull.request.list.filter.review.awaiting.short=正在等待審查
pull.request.list.filter.review.change.requested.full=請求的更改
pull.request.list.filter.review.change.requested.short=請求的更改
pull.request.list.filter.review.no.full=無審查
pull.request.list.filter.review.no.short=無審查
pull.request.list.filter.review.not.full=未由您審查
pull.request.list.filter.review.not.short=未審查
pull.request.list.filter.review.required.full=需要審查
pull.request.list.filter.review.required.short=需要審查
pull.request.list.filter.review.reviewed.full=由您審查
pull.request.list.filter.review.reviewed.short=已審查
pull.request.list.filter.sort=排序
pull.request.list.filter.sort.least.commented=評論最少
pull.request.list.filter.sort.least.recently.updated=最早更新
pull.request.list.filter.sort.most.commented=評論最多
pull.request.list.filter.sort.newest=最新
pull.request.list.filter.sort.oldest=最舊
pull.request.list.filter.sort.recently.updated=最近更新
pull.request.list.filter.state=狀態
pull.request.list.filter.state.closed=已關閉
pull.request.list.filter.state.merged=已合併
pull.request.list.filter.state.open=開放
pull.request.list.filters.clear=清除篩選器
pull.request.list.no.matches=沒有與篩選器符合的拉取請求
pull.request.list.nothing.loaded={0} 中沒有拉取請求
pull.request.list.outdated=該列表已過時。
pull.request.list.refresh=重新整理
pull.request.loading.status=正在載入拉取請求狀態
pull.request.merge.commit.action=合併拉取請求…
pull.request.merge.disabled=此專案已停用合併
pull.request.merge.pull.request=合併拉取請求 \\#{0,number,\\#}
pull.request.new.diff.editor.title=新拉取請求的差異
pull.request.no.labels=無標籤
pull.request.no.reviewers=無審查者
pull.request.notification.create.action=建立拉取請求
pull.request.notification.open.action=開啟拉取請求
pull.request.on.branch={1} 上的 \\#{0,number,\\#}
pull.request.on.branch.description=當前分支 {1} 存在拉取請求 \\#{0,number,\\#}
pull.request.on.branch.error=當前分支 {1} 存在拉取請求 \\#{0,number,\\#}，但拉取請求詳細資訊載入失敗
pull.request.on.branch.loading=正在載入拉取請求 \\#{0,number,\\#} 的更改
pull.request.on.branch.out.of.sync=當前分支 {1} 存在拉取請求 \\#{0,number,\\#}，但本地分支與遠端分支不同步
pull.request.on.branch.update.failed.title=拉取請求分支更新失敗
pull.request.open.action=檢視拉取請求
pull.request.open.action.description=檢視拉取請求資訊和時間線
pull.request.post.action=發佈拉取請求
pull.request.refresh.details.action=重新整理拉取請求
pull.request.refresh.list.action=重新整理列表
pull.request.removing.reviewers=正在移除審查者
pull.request.reopen.action=重新開啟拉取請求
pull.request.repo.access.required=必須具有版本庫存取權限才能管理拉取請求
pull.request.repo.write.access.required=必須具有版本庫寫存取權限才能合併拉取請求
pull.request.resolveConflicts.error.remoteNotFound=找不到 {0} 遠端\\: {1}
pull.request.resolveConflicts.error.repositoryNotFound=找不到 {0} 版本庫
pull.request.review.actions.submit={0, choice, 0\\#提交審查…|1\\#提交審查({0})…}
pull.request.review.editor.add.review.comment=新增審查評論
pull.request.review.editor.add.single.comment=新增一條評論
pull.request.review.editor.start.review=開始審查
pull.request.review.refresh.data.task=重新整理審查資料
pull.request.review.refresh.data.task.description=重新整理 GitHub 拉取請求審查資訊
pull.request.review.submit.action.description=提交拉取請求審查
pull.request.review.submit.approve.button=批准
pull.request.review.submit.comment.button=評論
pull.request.review.submit.comment.description=提交不需要明確批准的一般意見反應
pull.request.review.submit.request.changes=請求更改
pull.request.reviewers=審查者\\:
pull.request.reviewers.popup={0, choice, 1\\#審查者|2\\#審查者}
pull.request.select.action=選擇開放的拉取請求
pull.request.timeline.approved.changes=批准了這些更改
pull.request.timeline.branch.deleted=刪除了 {0} 分支
pull.request.timeline.branch.force.pushed=強制推送了 {0} 分支
pull.request.timeline.branch.head.restored=還原了 head 分支
pull.request.timeline.cannot.load=無法載入時間線條目
pull.request.timeline.changed.base.branch=更改了基礎分支
pull.request.timeline.closed=關閉了此請求
pull.request.timeline.comment.suggested.changes=建議的更改
pull.request.timeline.comment.suggested.changes.action.commit.name=提交…
pull.request.timeline.comment.suggested.changes.button=區域套用
pull.request.timeline.comment.suggested.changes.progress.bar.apply=套用建議的更改
pull.request.timeline.comment.suggested.changes.progress.bar.commit=提交建議的更改
pull.request.timeline.comment.suggested.changes.tooltip.different.branch=無法在其他分支中套用來自拉取請求的建議更改
pull.request.timeline.comment.suggested.changes.tooltip.outdated=無法套用過時的建議
pull.request.timeline.comment.suggested.changes.tooltip.resolved=此建議已解決
pull.request.timeline.commit.added=已將提交新增到此拉取請求
pull.request.timeline.commits.added=已將 {0} 個提交新增到此拉取請求
pull.request.timeline.connected=連結了可能由此物件關閉的問題
pull.request.timeline.disconnected=移除了一個指向問題的連結
pull.request.timeline.event.assigned=指派 {0}
pull.request.timeline.event.assigned.and.unassigned=指派 {0} 並取消指派 {1}
pull.request.timeline.event.labels.added=新增標籤 {0}
pull.request.timeline.event.labels.added.and.removed=新增標籤 {0} 並移除 {1}
pull.request.timeline.event.labels.removed=移除標籤 {0}
pull.request.timeline.event.removed.review.request=從 {0} 中移除審查請求
pull.request.timeline.event.requested.review=從 {0} 請求審查
pull.request.timeline.event.requested.review.and.removed.review.request=從 {0} 請求審查並從 {1} 中移除審查請求
pull.request.timeline.event.unassigned=取消指派 {0}
pull.request.timeline.marked.as.draft=將此拉取請求標記為草稿
pull.request.timeline.marked.as.ready=將此拉取請求標記為可供審查
pull.request.timeline.mentioned=提及了此拉取請求
pull.request.timeline.merged=合併了此請求
pull.request.timeline.merged.commit=已將提交 {0} 合併到 {1}
pull.request.timeline.no.description=未提供描述
pull.request.timeline.refresh.action=重新整理時間線
pull.request.timeline.refresh.action.description=檢查新時間線事件
pull.request.timeline.renamed=將此拉取請求從 ''{0}'' 重命名為 ''{1}''
pull.request.timeline.reopened=重新開啟了此請求
pull.request.timeline.requested.changes=請求了更改
pull.request.timeline.reviewed=審查了更改
pull.request.timeline.stale.review.dismissed=忽略了 <b>{0}</b> 過時的審查
pull.request.timeline.started.review=開始了審查
pull.request.unassigned=未分配
pull.request.unresolved.comments={0,choice,0\\#沒有未解決的註釋|1\\#{0} 個未解決的註釋|2\\#{0} 個未解決的註釋}
pull.request.view.conversations.action.description=檢視拉取請求時間線
pull.request.view.list=檢視拉取請求
rebase.error=無法執行 GitHub 重定基底
rebase.error.failed.to.match.gh.repo=無法符合本地版本庫和 GitHub 版本庫
rebase.error.multi.repo.not.supported=不支持多版本庫專案
rebase.error.no.default.branch=無法確定上游分支 - 沒有為版本庫設定預設分支
rebase.error.no.suitable.account.found=找不到合適的 GitHub 帳戶
rebase.error.remote.origin.not.found=找不到 Git 遠端 'origin'
rebase.error.repo.not.found=找不到版本庫 {0}
rebase.error.upstream.not.found=未新增遠端 {0}
rebase.process=正在重定基底 GitHub 複刻…
rebase.process.adding.github.parent.as.remote.host=正在將 GitHub 父項新增為遠端主機…
rebase.process.configuring.upstream.remote=正在組態上游遠端…
rebase.process.fetching.upstream=正在獲取上游…
rebase.process.operation.title=正在重定基底
rebase.process.rebasing.branch.onto=正在將當前分支重定基底到 ''{0}''…
rebase.process.success=已成功重定基底 GitHub 複刻
request.response.0=請求響應\\: {0}。
retry.action=重試
retry.link=重試
server.unreachable=伺服器無法到達
settings.automatically.mark.as.viewed=自動將開啟的檔案標記為已檢視
settings.clone.ssh=使用 ssh 克隆 Git 版本庫
settings.configurable.display.name=GitHub
settings.enable.pr.seen.markers=在列表中的拉取請求上啟用未讀標記
settings.timeout=連線超時\\:
settings.timeout.seconds=秒
share.button=共享
share.dialog.account.info.load.error.prefix=無法載入 {0} 的資訊\\:
share.dialog.account.info.load.process.canceled=已取消程序
share.dialog.description=描述\\:
share.dialog.private=私有
share.dialog.remote=遠端\\:
share.dialog.repo.name=版本庫名稱\\:
share.dialog.share.by=共享者\\:
share.error.private.repos.not.supported=您的帳戶不支持私有版本庫
share.error.remote.with.selected.name.exists=已存在具有所選名稱的遠端
share.error.repo.with.selected.name.exists=已存在具有所選名稱的版本庫
share.on.github=在 GitHub 上共享專案
share.validation.invalid.repo.name=版本庫名稱無效。名稱應由字母、數字、短划線、點和下劃線組成
share.validation.no.remote.name=未選擇遠端名稱
share.validation.no.repo.name=未選擇版本庫名稱
tab.title.pull.requests.new=在 {0} 新增拉取請求
task.comment.author=作者\\:
task.comment.date=日期\\:
task.repo.host.field=主機\\:
task.repo.name.field.empty.hint=版本庫名稱
task.repo.owner.field.empty.hint=版本庫所有者
task.repo.repository.field=版本庫\\:
task.repo.token.create.button=建立 API 令牌
task.repo.token.field=API 令牌\\:
task.repo.token.field.empty.hint=OAuth2 令牌
toolwindow.stripe.Pull_Requests=拉取請求
toolwindow.stripe.Pull_Requests.shortName=PR
unknown.host.error=未知主機\\: {0}
unknown.loading.error=未知載入錯誤
"
`;

exports[`dev messages/IdeBundle.properties 1`] = `
"FileChooser.detailsViewActionLabelText=詳細資訊
FileChooser.listViewActionLabelText=列表
FileChooser.newFolderActionLabelText=新增目錄
FileChooser.refreshActionLabelText=重新整理
FileChooser.viewMenuLabelText=檢視
ShowUsagesTableCellRenderer.accessible.CURRENT_ASTERISK_COL=當前用法
ShowUsagesTableCellRenderer.accessible.FILE_GROUP_COL=檔案 {0}
ShowUsagesTableCellRenderer.accessible.LINE_NUMBER_COL=行 {0}
ShowUsagesTableCellRenderer.accessible.OTHER_ASTERISK_COL=另一種用法
ShowUsagesTableCellRenderer.accessible.USAGE_TEXT_COL=用法文本 {0}
about.box.build.date=，{0} 建置
about.box.build.date.omitted.in.dev.build.mode=，在開發建置模式中省略了建置日期
about.box.build.date.time=，{0} {1} 建置
about.box.build.number=構建版本 #{0}
about.box.copyright=版權所有 © {0}–{1} <hyperlink>{2}</hyperlink>
about.box.jcef=JCEF {0}.{1}.{2}
about.box.jre=運行時版本: {0} {1}
about.box.powered.by=由<hyperlink>開源軟體</hyperlink>提供支援
about.box.vm=VM: {0}，{1}
about.popup.about.app=關於 {0}
about.popup.system.info=系統資訊\\n{0}\\n{1}
accessibility.filter.label={0}: {1}
accessible.name.annotation=註解: {0}
accessible.name.empty=空
accessible.name.icon=圖示: {0}
accessible.name.line=行 {0}
action.ActionTracer.Anonymous.description.clear.log=清除日誌
action.ActionTracer.Anonymous.text.Clear=清除
action.AnAction.description.activate.frame.and.run=啟用框架並執行
action.AnAction.description.clear=清除
action.AnAction.description.new.script=新增腳本
action.AnAction.description.reload.list=重新載入列表
action.AnAction.description.run.on.frame.activation=在框架啟用時執行
action.AnAction.description.save=儲存
action.AnAction.description.search.history=搜尋歷史記錄
action.AnAction.description.set.script.file=設定腳本檔案
action.AnAction.description.stop=停止
action.AnAction.text.activate.frame.and.run=啟用框架並執行
action.AnAction.text.clear=清除
action.AnAction.text.new.script=新增腳本
action.AnAction.text.reload.list=重新載入列表
action.AnAction.text.run.on.frame.activation=在框架啟用時執行
action.AnAction.text.save=儲存
action.AnAction.text.search.history=搜尋歷史記錄
action.AnAction.text.set.script.file=設定腳本檔案
action.AnAction.text.stop=停止
action.AnActionButton.text.change.goto.check.box=更改“轉到”複選框
action.AnActionButton.text.install=安裝
action.AnActionButton.text.reload.list.of.packages=重新載入軟體套件列表
action.AnActionButton.text.uninstall=解除安裝
action.AnActionButton.text.upgrade=升級
action.Anonymous.text.add.abbreviation=新增縮寫
action.Anonymous.text.add.keyboard.shortcut=新增鍵盤快捷鍵
action.Anonymous.text.add.mouse.shortcut=新增滑鼠快捷方式
action.Anonymous.text.all=所有
action.Anonymous.text.back=後退
action.Anonymous.text.change.context=更改上下文…
action.Anonymous.text.configure=組態
action.Anonymous.text.delete.hook=刪除掛鈎
action.Anonymous.text.do.not.show.again=不再顯示
action.Anonymous.text.done=完成
action.Anonymous.text.edit.scopes.order=編輯作用域順序…
action.Anonymous.text.highlight=醒目提示顯示
action.Anonymous.text.live.template=實時模板
action.Anonymous.text.live.templates=實時模板
action.Anonymous.text.new.group=新增組…
action.Anonymous.text.new.tag=新增標記
action.Anonymous.text.remove.leading.directory=移除前導目錄
action.Anonymous.text.rename=重新命名
action.Anonymous.text.reset.shortcuts=重設快捷鍵
action.Anonymous.text.restore.leading.directory=還原前導目錄
action.Anonymous.text.start.trial=開始 30 天試用
action.Anonymous.text.template.group=模板組…
action.Anonymous.text.toggle=切換
action.CallHierarchy.BaseOnThisMethod.text=基於此方法
action.ChangeProjectColorAction.Amber.title=琥珀色
action.ChangeProjectColorAction.Cobalt.title=鈷藍色
action.ChangeProjectColorAction.Current.title={0} (當前)
action.ChangeProjectColorAction.Grass.title=草綠色
action.ChangeProjectColorAction.Ocean.title=海藍色
action.ChangeProjectColorAction.Olive.title=橄欖色
action.ChangeProjectColorAction.Plum.title=紫紅色
action.ChangeProjectColorAction.Rust.title=Rust
action.ChangeProjectColorAction.Sky.title=天藍色
action.ChangeProjectColorAction.Violet.title=紫色
action.ChooseCustomProjectColorAction.title=自訂顏色…
action.CollapseAllAction.text.collapse.all=全部摺疊
action.ComboContentLayout.close.other.views.text=關閉其他檢視
action.ComboContentLayout.close.view.text=關閉檢視
action.ComboContentLayout.select.next.view.text=選擇下一個檢視
action.ComboContentLayout.select.previous.view.text=選擇上一個檢視
action.DataSharingOptionsAction.description=資料共享選項
action.DataSharingOptionsAction.text=資料共享選項…
action.DescriptionAwareSchemeActions.add.description.text=新增描述…
action.DescriptionAwareSchemeActions.edit.description.text=編輯描述…
action.DumbAware.BuildView.text.stop=BuildView
action.DumbAware.CopyrightProfilesPanel.description.stop=停止
action.DumbAware.TerminalView.text.new.session=新增會話
action.Events=事件
action.ExpandAllAction.text.expand.all=全部展開
action.FinderRecursivePanel.text.edit=編輯
action.FinderRecursivePanel.text.next=下一個
action.FinderRecursivePanel.text.previous=上一個
action.GetHelp=獲取幫助
action.InstallFromDiskAction.not.allowed.description=您的組織不允許從磁碟安裝延伸模組
action.InstallFromDiskAction.progress.text=正在安裝延伸模組
action.InstallFromDiskAction.text=從磁碟安裝延伸模組…
action.MarkAllNotificationsAsReadAction.description=將所有未讀通知標記為已讀
action.MarkAllNotificationsAsReadAction.text=將所有通知標記為已讀
action.MethodHierarchy.BaseOnThisMethod.text=基於此方法
action.NamedItemsListEditor.AddAction.description.add=新增
action.NamedItemsListEditor.AddAction.text.add=新增
action.NamedItemsListEditor.CopyAction.description.copy=複製
action.NamedItemsListEditor.CopyAction.text.copy=複製
action.OpenUrlHyperlinkInfo.Anonymous.description.copy.url.to.clipboard=將 URL 複製到剪貼簿
action.OpenUrlHyperlinkInfo.Anonymous.text.copy.url=複製 URL
action.QuickChangeCodeStyleSchemeAction.Anonymous.text.project=<專案>
action.ReopenProject.reopen.project.text=重新開啟專案
action.SwitchToJBR.text=切換到捆綁執行時
action.ToggleAction.description.pin.window=固定視窗
action.ToggleAction.description.toggle.auto.test=程式碼更改時切換測試的自動重新執行
action.ToggleAction.show.filter.description.show.filters.popup=顯示篩選器彈出視窗
action.ToggleAction.show.filter.text.filter=篩選
action.ToggleAction.text.filter=篩選
action.ToggleAction.text.filter.files.by.type=按類型篩選檔案
action.ToggleAction.text.pin.window=固定視窗
action.ToggleAction.text.toggle.auto.test=自動重新執行
action.ToggleAction.text.toggle.view=切換檢視
action.TypeHierarchyBase.BaseOnThisType.text=基於此類別
action.UpdateIde.button.postpone=推遲
action.UpdateIde.installed=已安裝新版本: {0}
action.UpdateIde.progress.text.ide.will.restart=IDE 將在 {0, choice, 1#1 秒|2#{0} 秒}後重啟
action.UpdateIde.progress.title=新安裝準備就緒
action.UpdateIde.task.success.content=新安裝準備就緒
action.UpdateIde.task.success.restart=重新啟動
action.UpdateIde.task.success.title=IDE 更新
action.activate.tool.window=啟用{0}視窗
action.add.all.open.tabs.to.new.favorites.list=將所有開啟的頁籤新增到新收藏夾列表
action.add.repository=新增延伸模組庫
action.add.to.new.favorites.list=新增到新收藏夾列表(_N)
action.add.to.new.favorites.list.description=新增到新收藏夾列表
action.append=追加
action.base.on.this.0=基於此{0}
action.browse.call.hierarchy=瀏覽呼叫層次結構
action.browse.method.hierarchy=瀏覽方法層次結構
action.browse.type.hierarchy=瀏覽類型層次結構
action.callee.methods.hierarchy=被呼叫方方法層次結構
action.caller.methods.hierarchy=呼叫方方法層次結構
action.choose.actions.to.add=新增動作
action.clear.encoding.description=清除預設編碼。
action.clear.encoding.description.file=清除檔案 ''{0}'' 編碼。
action.close=關閉(_C)
action.close.all.editors.above=關閉上方頁籤
action.close.all.editors.below=關閉下方頁籤
action.close.all.editors.in.tab.group=關閉組內所有頁籤(_A)
action.close.all.readonly.editors=關閉所有唯讀項
action.close.all.readonly.editors.in.tab.group=關閉組中的所有唯讀項
action.close.all.unmodified.editors=關閉未修改頁籤(_U)
action.close.all.unmodified.editors.in.tab.group=關閉組內未修改頁籤(_U)
action.close.all.unpinned.editors=關閉所有未固定頁籤
action.close.all.unpinned.editors.in.tab.group=關閉組中的未固定頁籤
action.close.projects.in.current.window=關閉當前視窗中的專案(_J)
action.collapse=摺疊
action.collapse.all=全部摺疊
action.compact.empty.middle.packages=壓縮空的中間軟體套件
action.copy.link.text=複製 {0} 連結
action.copy.path=複製絕對路徑(_O)
action.copy.paths=複製絕對路徑(_O)
action.copy.template=複製模板
action.create.child.template=建立子模板檔案
action.create.new.class.name.field=名稱
action.create.new.class.templates.list.accessible.name=模板
action.create.template=建立模板
action.customizations.customize.action=自訂工具列…
action.delete=刪除(_D)
action.delete.ellipsis=刪除(_D)…
action.description.clear.the.contents.of.the.event.log=清除事件日誌的內容
action.description.create.new.module.group=建立新模組組
action.description.create.new.package=建立新的軟體套件
action.description.edit.notification.settings=編輯通知設定
action.description.pin.tool.window.to.0.side.ui.designer.editor=將工具視窗固定到{0}側 UI 設計器編輯器
action.description.show.files=顯示/隱藏檔案
action.description.show.included.only=僅顯示包含到當前所選作用域的檔案
action.description.show.modules=顯示/隱藏模組
action.description.todo.show.all=顯示全部 TODO 項
action.description.unpin.tool.window.from.designer.editor=從設計器編輯器取消固定工具視窗
action.description.view.class.hierarchy=選擇類別層次結構
action.description.view.subtypes.hierarchy=切換到子類型層次結構
action.description.view.supertypes.hierarchy=切換到父類型層次結構
action.descriptor.action=動作: {0}
action.descriptor.keystroke=按鍵:“{0}”
action.descriptor.typing=輸入:“{0}”
action.directory=目錄
action.dont.show.again.text=不再顯示
action.download.and.install.plugin=下載並安裝
action.edit.file.templates=編輯檔案模板…
action.edit.repository.url=編輯儲存庫 URL
action.empty.group.text=空組
action.empty.unnamed.group.text=空未命名組
action.enable.disable.global.menu.integration.description=啟用/停用全域選單整合(所有框架)
action.exclude.all.text=全部排除
action.expand=展開
action.expand.all=全部展開
action.explorer.text=檔案總管
action.file.manager.text=檔案管理器
action.filter.todo.items=篩選 TODO 條目
action.finder.text=訪達
action.flatten.packages=平展軟體套件
action.flatten.view=平展檢視
action.fn.keys.text=Fn 鍵
action.from.file.template=從檔案模板…
action.group.by.modules=模組
action.group.by.packages=軟體套件
action.group.macos.shortcuts.text=macOS 快捷鍵
action.group.name.unnamed.group=<未命名組>
action.help=幫助
action.hide.all.windows=隱藏所有視窗(_W)
action.hide.empty.middle.packages=隱藏空的中間軟體套件
action.hide.non.implementations=隱藏方法未合法實作的類別
action.include.all.text=全部包含
action.invoke.macro.text=呼叫巨集
action.jcef.restart=重啟
action.label.hide.notification=隱藏通知
action.manual.order=手動排序
action.maximize.editor=最大化編輯器
action.maximize.text=最大化
action.move.module.new.top.level.group=新增頂層組…
action.move.module.outside.any.group=在任意組外
action.move.module.to.new.sub.group=到新子組…
action.move.module.to.this.group=到此組
action.new.package=新增軟體套件…
action.next.message=下一條訊息
action.next.problem=下一個問題
action.next.tip=下一步(&N)
action.next.todo=下一個 TODO
action.normalize.splits=標準化拆分
action.open.editor.settings.text=開啟設定
action.open.tip=開啟(&O)…
action.open.web.preview.text=內建預覽
action.overwrite=覆蓋
action.package=軟體套件
action.pin.tab=固定頁籤(_I)
action.presentation.AbstractSchemesPanel.description=顯示方案動作
action.presentation.AbstractSchemesPanel.text=顯示方案動作
action.presentation.EditorTabbedContainer.text=關閉。按 {0} 並點擊以關閉其他。
action.presentation.EncodingPanel.text=檔案編碼
action.presentation.ExtractIncludeAction.text=Include 檔案…
action.presentation.FindAllAction.text=搜尋全部
action.presentation.LightEditTabs.text=關閉。按 {0} 並點擊以關閉其他。
action.presentation.OpenSelectedProjectsAction.text.open.all.projects.in.group=開啟組中的所有專案
action.presentation.OpenSelectedProjectsAction.text.open.selected=開啟選定專案
action.presentation.RegistryUi.text=還原為預設值
action.presentation.RegistryUi.text.edit=編輯
action.presentation.RemoveSelectedProjectsFromGroupsAction.text=從組中移除
action.presentation.ShowUiDebuggerAction.text=UI 偵錯器
action.presentation.WeighingActionGroup.text=其他
action.previous.message=上一條訊息
action.previous.problem=上一個問題
action.previous.tip=返回(&B)
action.previous.todo=上一個 TODO
action.refresh=重新整理
action.remove=移除
action.remove.repository.from.list=從列表中移除儲存庫
action.remove.template=移除模板
action.reopen.project.display.name.with.branch={0}  [{1}]
action.reset.font.size=重設為 {0}pt
action.reset.font.size.all.editors=在所有編輯器中重設為 {0}pt
action.reset.font.size.info=字體大小: {0}pt
action.reset.to.default=還原為原始模板
action.restore.windows=還原視窗(_W)
action.select.none=無選擇(&N)
action.send.to.new.favorites.list=發送至新收藏夾列表
action.separator=分隔符({0})
action.separator.file.templates=檔案模板
action.show.classes=顯示類別
action.show.compact.empty.middle.packages=顯示/壓縮中間軟體套件
action.show.files=顯示檔案
action.show.hide.empty.middle.packages=顯示/隱藏空的中間軟體套件
action.show.included.only=僅顯示包含的檔案
action.show.infos=顯示資訊訊息
action.show.members=顯示成員
action.show.modules=顯示模組
action.show.warnings=顯示警告
action.start.macro.recording=開始巨集錄製(_M)
action.stop=停止
action.stop.macro.recording=停止錄製巨集 (_M)
action.switch.project.text=切換專案
action.sync.completed.successfully=檔案同步已成功完成。
action.text.change.encoding=將編碼更改為 ''{0}''
action.text.change.system.shortcuts=更改系統快捷鍵
action.text.clear.all=全部清除
action.text.copy=複製(&C)
action.text.copy.link.address=複製連結地址
action.text.disable.input.methods=停用輸入方法
action.text.editor.mode.none=無
action.text.hide.chessboard=隱藏棋盤
action.text.hide.file.name=隱藏檔名
action.text.hide.file.size=隱藏檔案大小
action.text.hide.grid=隱藏網格
action.text.hide.tags.panel=隱藏標記面板
action.text.install.keymap=安裝 {0} 按鍵映射
action.text.merge.tabs.to.group=將頁籤合併到 ''{0}'' 組
action.text.modify.shortcut=修改快捷鍵
action.text.modify.shortcuts=修改快捷鍵
action.text.more=更多
action.text.open.link.in.browser=在瀏覽器中開啟連結
action.text.reload.file=重新載入檔案
action.text.remove.0=移除 {0}
action.text.remove.abbreviation.0=移除縮寫 ''{0}''
action.text.remove.all.shortcuts=移除所有快捷鍵
action.text.search.for.keymap=搜尋 {0} 按鍵映射延伸模組
action.text.select.next.tab=選擇下一個頁籤
action.text.select.previous.tab=選擇上一個頁籤
action.text.settings=設定
action.text.show.chessboard=顯示棋盤
action.text.show.file.name=顯示檔名
action.text.show.file.size=顯示檔案大小
action.text.show.grid=顯示網格
action.text.show.tags.panel=顯示標記面板
action.text.split.group=拆分 ''{0}'' 組
action.title.group.by.directory=按目錄分組
action.todo.edit.filters=編輯篩選器
action.todo.edit.filters.description=編輯篩選器
action.todo.show.all=全部顯示
action.toggle.global.menu.integration.text=切換全域選單整合
action.unpin.tab=取消固定頁籤(_I)
action.unpin.tab.tooltip=取消固定頁籤
action.view.class.hierarchy=類別層次結構
action.view.subtypes.hierarchy=子類型層次結構
action.view.supertypes.hierarchy=父類型層次結構
actions.on.save.background.progress=儲存時執行動作
actions.on.save.label.activated.on.any.save=任何儲存
actions.on.save.label.activated.on.any.save.and.external.change=<html>任何儲存和<br/>外部更改</html>
actions.on.save.label.activated.on.explicit.save=顯式儲存
actions.on.save.label.activated.on.explicit.save.with.0.shortcut=顯式儲存({0})
actions.on.save.link.all.actions.on.save=儲存時的所有動作…
actions.on.save.link.configure=組態…
actions.on.save.link.configure.autosave.options=組態自動儲存選項…
actions.on.save.option.activated.on.any.save.and.external.change=任何儲存和外部更改
actions.on.save.option.activated.on.any.save.including.autosave=任何儲存(包括自動儲存)
actions.on.save.page.title=儲存時的動作
actions.on.save.processing.file={0}: 正在處理 {1}
actions.on.save.table.column.name.action=動作
actions.on.save.table.column.name.activated.on=啟用條件
activation.file.is.waiting.dismiss=消除
activation.file.is.waiting.do.not.show=不再顯示
activation.file.is.waiting.notification=指令行將一直等待，直到檔案 ''{0}'' 關閉。
activation.file.is.waiting.release=釋放
activation.file.is.waiting.title=指令行將一直等待，直到此檔案關閉
activation.not.initialized=IDE 尚未初始化
activation.project.is.waiting.notification=指令行將一直等待，直到專案 ''{0}'' 關閉。
activation.shutting.down=IDE 正在關閉
activation.unknown.error=意外錯誤: {0}
add.byte.order.mark.to=向 {0} 新增位元組順序標記
add.local.scope.action.text=本地
add.module.popup.title=新增模組
add.scope.dialog.title=新增新作用域
add.scope.name.label=名稱
add.scope.popup.title=新增作用域
add.shared.scope.action.text=共享
add.source.header.popup.title=新增源和標題
alphabetical.mode.is.on.notification=已關閉按字母順序排列的制表符順序
analyze.plugin.title=每個延伸模組的啟動時間成本
appearance.ui.option.group=UI
appearance.view.option.group=檢視
appearance.window.option.group=視窗
archiving.logs.progress.title=正在製作日誌歸檔
archiving.user.logs.progress.title=正在將使用者日誌新增到歸檔
assign.custom.shortcuts.or.change.the.macos.system.settings=分配自定義快捷鍵或更改 macOS 系統設定。
attachable.project.pane.name=檔案
available.packages.dialog.title=可用軟體套件
background.image.button=背景圖像…
banner.button.close=關閉
before.run.component.accessible.name=在啟動選項之前
big.popup.filter.button.all=所有
big.popup.filter.button.invert=反轉
big.popup.filter.button.none=無
binary.file.too.large=二進制檔案 {0} 太大({1})
border.title.command.output=指令輸出
border.title.description=描述
border.title.problem.files=問題檔案
browse.custom.icon.hint=要設定自訂圖示，請指定 SVG 或 PNG 檔案的路徑。
browser.default.not.supported=抱歉，IDE 不知道如何在此系統上啟動預設瀏覽器。
browser.error=瀏覽器錯誤
browser.notification.timeout.group=在瀏覽器中開啟頁面超時
browser.notification.timeout.text=無法在瀏覽器中開啟 <a href="{0}">{1}</a>，因為 URL 未響應。
browser.notification.timeout.title=URL 未響應
browser.preview.file.title={0} 的預覽
browser.select.in.default.name=Web 瀏覽器
browser.shortcut=按住 Shift 以開啟本地檔案 URL
browser.shortcut.or.shift={0}，按住 Shift 以開啟本地檔案 URL
browser.url.popup=選擇 URL
browsers.chrome=Chrome
browsers.explorer=Internet Explorer
browsers.firefox=Firefox
browsers.safari=Safari
browsers.settings=Web 瀏覽器和預覽
buildToolWindow.tree.accessibleName=建置結果
bundled.jre.arch.mismatch.download=下載…
bundled.jre.arch.mismatch.mac=為 Apple Silicon 下載 {0} 以獲得更好的性能和穩定性。
bundled.jre.arch.mismatch.win=為 ARM64 下載 {0} 以獲得更好的性能和穩定性。
bundled.jre.version.message=請考慮切換到更適合 IDE 的捆綁 Java Runtime(您當前的 Java Runtime 為 {0}，來自 {1}，位置為 ''{2}'')。
button.add.action=新增動作(&A)…
button.add.separator=新增分隔符 (&S)
button.back=後退
button.cancel=取消(&C)
button.cancel.without.mnemonic=取消
button.choose=選擇
button.clear.and.close=清除並關閉
button.continue.editing=繼續編輯
button.convert=轉換
button.convert.anyway=仍然轉換
button.copy=複製(&C)
button.copy.and.close=複製並關閉
button.create=建立(&C)
button.delete=刪除
button.disable=停用
button.disable.selected.plugins=停用所選延伸模組
button.do.not.send=不發送
button.done=完成
button.edit.action.icon=編輯圖示(&I)…
button.enable.all=全部啟用
button.enable.updated.plugins=啟用更新的{0,Choice,1#Plugin|2#Plugins}
button.exclude=排除
button.exclude.recursively=遞迴排除
button.existing.frame=此視窗(&T)
button.facet.quickfix.text=修正(&F)
button.finish=完成(&F)
button.fix=修正…
button.fix.it=修復
button.help=幫助(&H)
button.http.proxy.settings=HTTP 代理設定(&H)…
button.i.want.to.edit.all.files.in.choice.this.directory={0, choice, 1#此目錄|2#這些目錄}中的所有檔案
button.i.want.to.edit.any.non.project.file.in.current.session=任何非專案檔案
button.i.want.to.edit.choice.this.directory.anyway={0, choice, 1#此目錄|2#這些目錄}
button.i.want.to.edit.choice.this.file.anyway={0, choice, 1#此文件|2#這些檔案}
button.include=包含
button.include.recursively=遞迴包含
button.invalidate.and.exit=清除並離開(&E)
button.invalidate.and.restart=失效並重啟(&R)
button.just.restart=重新啟動
button.later=稍後{0,choice,0#重啟|1#關閉}
button.move.down=下移 (&D)
button.move.up=上移(&U)
button.new.frame=新視窗 (&W)
button.next=下一個
button.now=立即{0,choice,0#重啟|1#關閉}
button.ok=確定 (&O)
button.previous=上一個
button.reject=拒絕
button.reload=重新載入
button.reload.anyway=仍然重新載入
button.remove=移除(&R)
button.remove.from.list=從列表中移除(\\\\&R)
button.rename=重新命名
button.repaint.icons=重新繪製圖示(&R)
button.restore.all=恢復所有預設設定(&L)
button.restore.defaults=恢復預設設定
button.restore.last.state=還原上次狀態
button.restore.selected.groups=還原選定組
button.restore.selection=還原{0}
button.save=儲存
button.save.anyway=仍然儲存
button.set.0=設定 {0}
button.skip=跳過
button.wizard.next=下一步 (&N)
button.wizard.previous=上一步 (&P)
button.yes=是(_Y)
cannot.delete.jre.config=無法刪除執行時組態檔案 ''{0}'': {1}
cannot.redo.message=無法重做
cannot.redo.title=無法重做
cannot.undo.error.contains.nonundoable.changes.message=<html>無法執行 ''{0}''<br>以下檔案包含無法撤消的更改:
cannot.undo.error.other.affected.files.changed.message=受此動作影響的以下檔案已更改:
cannot.undo.error.other.users.overwrote.changes.message=您對以下檔案的更改已被其他使用者覆蓋:
cannot.undo.message=無法撤消
cannot.undo.title=無法撤消
change.encoding.command.name=更改 ''{0}'' 的編碼
change.memory.code.cache=程式碼快取大小
change.memory.direct.buffers=直接緩衝區限制
change.memory.max.heap=堆大小上限
change.memory.metaspace=元空間大小
change.memory.min.heap=初始堆大小
channel.status.beta=Beta 版本或公開預覽
channel.status.eap=搶先體驗計劃
channel.status.milestone=里程碑 EAP 建置
channel.status.stable=穩定版本
checkbox.accessibility.contrast.scrollbars=使用對比度捲軸
checkbox.also.in.reader.mode=也適用於<a>閱讀器模式</a>
checkbox.case.sensitive=區分大小寫
checkbox.colors.only=僅顏色
checkbox.compact.mode=緊湊模式
checkbox.compact.mode.description=UI 元素佔用更少的螢幕空間
checkbox.compact.tree.indents=使用較小的縮排
checkbox.confirm.application.exit=離開 IDE 之前確認
checkbox.copy.javadoc=複製 JavaDoc(&J)
checkbox.create.the.entry.for.all.users.requires.superuser.privileges=為所有用戶建立條目(需具備超級使用者權限)(&A)
checkbox.customfiletype.ignore.case=忽略情況 (&I)
checkbox.customfiletype.support.paired.braces=支援配對大括號 (&R)
checkbox.customfiletype.support.paired.brackets=支援配對中括號 (&C)
checkbox.customfiletype.support.paired.parens=支援配對小括號 (&P)
checkbox.customfiletype.support.string.escapes=支援字串轉義 (&E)
checkbox.disabled.included=包括停用的動作(&D)
checkbox.enable.live.templates=啟用實時模板 (&L)
checkbox.errortree.export.details=詳細資訊
checkbox.expand.node.with.single.click=單擊展開節點
checkbox.expand.node.with.single.click.comment=某些樹可能會忽略此設定
checkbox.full.paths.in.window.header=始終在視窗標題中顯示完整路徑
checkbox.ide.mac.app.icon=自訂應用程式圖示
checkbox.inject.reveal.library.on.launch=啟動時注入 Reveal 庫
checkbox.insert.at.override=插入 @Override(&O)
checkbox.keep.popups.for.toggles=切換條目時保持彈出視窗開啟
checkbox.left.toolwindow.layout=左側並排布局
checkbox.merge.main.menu.with.window.title=合併主選單和視窗標題
checkbox.narrow.down.on.typing=在輸入時縮小(&N)
checkbox.narrow.down.the.list.on.typing=在輸入時縮小列表(&N)
checkbox.override.default.laf.fonts=使用自訂字體:
checkbox.password.safe.remember=記住(&R)
checkbox.reformat.according.to.style=按照樣式重新設定格式(&R)
checkbox.remember.size.for.each.tool.window=記住每個工具視窗的大小
checkbox.remote.sdk.run.as.root.via.sudo=通過 sudo 作為 root 執行
checkbox.right.toolwindow.layout=右側並排布局
checkbox.safe.delete.with.usage.search=安全刪除(帶有用法搜尋)(&F)
checkbox.safe.write=儲存前備份檔案
checkbox.save.files.automatically=如果 IDE 空閒則儲存檔案
checkbox.save.files.on.frame.deactivation=切換到其他應用程式或內建終端時儲存檔案
checkbox.show.editor.preview.popup=懸停在捲軸上時顯示程式碼透鏡
checkbox.show.icons.in.menu.items=在選單項顯示圖示
checkbox.show.rendered.doc.comments=渲染文檔註釋
checkbox.show.tips.on.startup=啟動時不顯示小技巧
checkbox.show.tool.window.bars=顯示工具視窗列
checkbox.show.tool.window.names=顯示工具視窗名稱
checkbox.show.tool.window.numbers=顯示工具視窗編號
checkbox.show.tree.indent.guides=顯示縮排參考線
checkbox.smooth.scrolling=平滑滾動
checkbox.smooth.scrolling.animated=動畫平滑滾動(&N)
checkbox.smooth.scrolling.description=使用滑鼠滾輪/觸摸板時，整個介面將平滑滾動，而不是逐行滾動
checkbox.smooth.scrolling.enable.high.precision.timer=啟用 Windows 高精度計時器
checkbox.smooth.scrolling.enable.high.precision.timer.comments=為刷新率較高的顯示器啟用更平滑的動畫。
checkbox.smooth.scrolling.enable.high.precision.timer.help=通常，預設的 Windows 計時器周期為 15.625 毫秒。因此，預設動畫每秒播放近 60 幀。此選項會在播放動畫時動態地將周期設定為較低的值。
checkbox.support.screen.readers=支援螢幕閱讀器
checkbox.synchronize.files.in.background=在 IDE 處於非活動狀態時定期(實驗性)
checkbox.synchronize.files.on.frame.activation=切換到 IDE 視窗或開啟編輯器頁籤時
checkbox.text.this.project.only=僅此專案
checkbox.todo.use.default.colors=使用配色方案 TODO 預設顏色
checkbox.transparent.native.to.ascii.conversion=自動轉換成 Ascii 但顯示原生的內容
checkbox.upload.reveal.library.on.the.device.if.necessary=如有必要，上傳裝置上的 Reveal 庫
checkbox.use.custom.user.data.directory.for.chrome=使用自訂用戶數據目錄(&U):
checkbox.use.solution.colors.in.main.toolbar=在主工具列中使用專案顏色
checkbox.use.solution.colours.in.toolbar=顯示專案漸變
checkbox.use.transparent.mode.for.floating.windows=為浮動視窗使用透明模式
checkbox.widescreen.tool.window.layout=寬屏工具視窗布局
checkbox.widescreen.tool.window.layout.description=通過限制水平工具視窗的寬度，使垂直工具視窗的高度最大化
chooser.description.specifies.user.data.directory=指定儲存使用者資料(您的“組態檔案”)的目錄
chooser.title.select.profiles.ini.file=選擇 "profiles.ini" 檔案
chooser.title.select.user.data.directory=選擇使用者資料目錄
code.cache.warn.message={0} MB 的程式碼快取大小不足。請將 ''-XX:ReservedCodeCacheSize'' 增加到 {1} MB 或以上，以避免性能問題。
collect.client.logs.progress.title=正在收集用戶端日誌
collect.host.logs.progress.title=正在收集主機日誌
collect.local.logs.notification.error=無法收集更多日誌
collect.local.logs.progress.title=正在收集本地日誌
collect.logs.notification.error=無法使用日誌建立 .zip 檔案: {0}
collect.logs.notification.host.error=無法從主機收集日誌，僅儲存用戶端的日誌
collect.logs.notification.sent.success=日誌已發送至 {0}。您的 ID 為: {1}
collect.logs.notification.success=已建立日誌檔案: {0}
collect.logs.progress.title=正在收集日誌
collect.logs.sensitive.text=包含的日誌和設定中可能含有敏感資料。
collect.logs.sensitive.title=敏感資料
collect.upload.logs.progress.title=正在收集和上傳日誌
color.name.blue=藍色
color.name.brown=棕色
color.name.gray=灰色
color.name.green=綠色
color.name.orange=橙色
color.name.rose=玫瑰色
color.name.violet=紫色
color.name.yellow=黃色
colorpanel.label.alpha=A
colorpanel.label.alpha.percent=A%
colorpanel.label.blue=B
colorpanel.label.brightness=B%
colorpanel.label.green=G
colorpanel.label.hue=H°
colorpanel.label.red=R
colorpanel.label.saturation=S%
colorpicker.brightness.slider.title=亮度
colorpicker.brightness.slider.tooltip=亮度
colorpicker.colorvaluepanel.hexlabel=十六進制
colorpicker.format.hsb=HSB
colorpicker.format.rgb=RGB
colorpicker.label.blue=B:
colorpicker.label.brightness=B:
colorpicker.label.green=G:
colorpicker.label.hue=H:
colorpicker.label.red=R:
colorpicker.label.saturation=S:
colorpicker.opacity.slider.title=不透明度
colorpicker.opacity.slider.tooltip=不透明度
colorpicker.recent.color.tooltip=R: {0} G: {1} B: {2} A: {3}
column.enabled=已啟用
column.name.cost.details=成本詳細資訊
column.name.plugin=延伸模組
column.name.startup.time.ms=啟動時間(毫秒)
column.plugins.name=名稱
column.todo.filter.patterns=模式
column.todo.filters.name=名稱
column.todo.patterns.case.sensitive=區分大小寫
column.todo.patterns.icon=圖示
column.todo.patterns.pattern=模式
combobox.editor.color.scheme=編輯器配色方案:
combobox.editor.color.scheme.edit=編輯…
combobox.ide.scale.comment.format=通過 {0} 或 {1} 進行更改。通過 {2} 設定為 100%
combobox.ide.scale.percent=縮放:
combobox.language=語言:
combobox.language.option=語言
combobox.list.custom.section.title=自訂
combobox.look.and.feel=主題:
combobox.region=區域:
combobox.region.comment=選擇一個區域以確保許可、JetBrains Marketplace 和<br>其他針對特定區域的功能和連結正常工作。<br>需要重新啟動。有關詳情，請參閱<a href="{0}">文檔</a>。
combobox.region.hint=選擇一個區域以確保<br>許可、JetBrains Marketplace<br>和其他針對特定區域的功能<br>和連結正常工作。<br>需要重新啟動。
combobox.region.hint.link=文檔
command.close.all.editors=關閉所有編輯器
command.close.all.unmodified.editors=關閉所有未修改的編輯器
command.create.directory=建立目錄
command.create.file=建立檔案
command.create.file.from.template=從模板建立檔案
command.create.new.package=建立新軟體套件
command.create.package=建立軟體套件
command.deleting.files=正在刪除檔案
command.finish=完成
command.fixing.line.separators=修正行分隔符
command.go.to.line=轉到行
command.name.apply.color=套用顏色
command.name.choice.attach.detach={0, choice, 0#附加|1#分離} {1}
command.name.choice.exclude.include={0, choice, 0#排除|1#包含}{1}
command.pasting.reference=貼上參照
command.renaming.module=正在重新命名模組 {0}
command.select.all=全選
command.unselect.all=取消全選
comment.text.pause=暫停
comment.text.paused=已暫停
comment.text.resume=恢復
configurable.ChromeSettingsConfigurable.display.name=Chrome 設定
configurable.CodeStyle.display.name=程式碼樣式
configurable.Console.display.name=主控台
configurable.DatabaseSettingsConfigurable.CsvFormats.display.name=CSV 格式
configurable.DatabaseSettingsConfigurable.DataViews.display.name=資料編輯器和檢視器
configurable.DatabaseSettingsConfigurable.Other.display.name=其他
configurable.DatabaseSettingsConfigurable.OutputResults.display.name=輸出和結果
configurable.DatabaseSettingsConfigurable.QueryExecution.display.name=查詢執行
configurable.DatabaseSettingsConfigurable.Templating.display.name=使用者參數
configurable.DockerExtraHostConfigurable.display.name=額外主機
configurable.DuplicatesConfigurable.display.name=重複項
configurable.EmbeddedSettingsConfigurable.display.name=嵌入式開發
configurable.ExceptionAnalyzerConfigurable.display.name=異常分析器
configurable.ExternalDependenciesConfigurable.display.name=必需延伸模組
configurable.GutterIconsConfigurable.display.name=裝訂區域圖示
configurable.JavaFxSettingsConfigurable.display.name=JavaFX
configurable.PluginHostsConfigurable.display.name=自訂延伸模組儲存庫
configurable.Postfix.Completion.display.name=後綴補全
configurable.Runtime.Targets.Configurable.display.name=執行目標
configurable.SettingsPage.display.name=捆綁的 Web 幫助
configurable.TerminalOptionsConfigurable.display.name=終端
configurable.TextMateConfigurableProvider.display.name=TextMate 捆綁包
configurable.TimeTrackingConfigurable.display.name=時間追蹤
configurable.VagrantConfigurable.display.name=Vagrant
configurable.console.font.name=主控台字體
configurable.console.font.use.editor.font=使用編輯器字體
configurable.file.colors=檔案顏色
configurable.font.name=字體
configurable.new.ui.name=新 UI
configurable.notifications.name=通知
configurable.quick.lists.name=快速列表
configurable.trusted.hosts.display.name=受信任的位置
consent.configurable=資料共享
conversion.dialog.text.1=專案 ''{0}'' 的格式已過時，將被轉換。您可能無法使用早期版本的 {1} 開啟此專案。
conversion.dialog.text.2=<b> </b><a href="details">詳細資訊…</a><br/><br/>舊版本的專案檔案將被儲存到: ''{0}''
convert.project.dialog.button.text=轉換
copy.reference=複製參照(&Y)
copy.references=複製參照(&Y)
copy.relative.path=複製相對路徑(&Y)
copy.relative.paths=複製相對路徑(&Y)
copy.system.information.to.clipboard=將系統資訊複製到剪貼簿
create.new.UT8.file.option.always=包含 BOM
create.new.UT8.file.option.never=不含 BOM
create.new.UT8.file.option.only.under.windows=在 Windows 下使用 BOM，否則不使用 BOM
custom.action.actual=實際: {0}
custom.action.stored=已存儲: {0}
custom.option.testmode=讀取自訂動作 {0}
darcula.theme.name=Darcula
dark.theme.name=深色
date.format.24.hours=使用 24 小時時間
date.format.date.format=日期格式:
date.format.date.patterns=日期模式
date.format.error.contains.time.pattern=日期格式不應包含時間模式(小時、分鐘、秒)
date.format.error.invalid.pattern=無效模式: {0}
date.format.override.system.date.and.time.format=覆寫系統日期和時間格式
date.format.pretty=使用美化的格式
date.format.relative=將數字日期取代為<i>今天</i>、<i>昨天</i>和 <i>10 分鐘前</i>
date.time.format.configurable=日期格式
default=預設
default.icons.add.text=新增
default.icons.edit.text=編輯
default.icons.export.text=匯出
default.icons.filter.text=篩選
default.icons.find.text=尋找
default.icons.gear.plain.text=純齒輪
default.icons.import.text=匯入
default.icons.list.files.text=列出檔案
default.icons.none.text=<無>
default.icons.remove.text=移除
default.icons.unknown.text=預設圖示
deleting.jre.config=正在刪除執行時組態檔案
description.copy.text.to.clipboard=將文本複製到剪貼簿
description.text.pause=暫停 ''{0}''
description.text.resume=恢復 ''{0}''
detach.directory.action.text.detach.0=從專案中分離{0,choice,1#目錄|2#目錄}…
detach.directory.dialog.button.detach=分離
detach.directory.dialog.message.detach.0=分離 {0}?\\n不會從磁碟上移除檔案。
detach.directory.dialog.title.detach=從專案中分離目錄
detach.library=分離庫
detach.library.from.module=從模組 ''{1}'' 分離庫 ''{0}''?\\n不會損害磁碟上的檔案。
dialog.apply=套用
dialog.button.ok.jcef.signIn=登入
dialog.content.jcef.proxyServer=<html>瀏覽器元件正在為代理<br>請求身份驗證: {0}
dialog.content.label.jcef.login=登入名: 
dialog.content.label.jcef.password=密碼: 
dialog.delete.window.layout.prompt=是否刪除布局“{0}”?
dialog.layout.already.exists=已存在使用此名稱的布局
dialog.layout.name.too.long=允許的最大長度為 {0} 個字元
dialog.message.attach.project.not.found=在 {0} 中找不到專案
dialog.message.caches.will.be.invalidated=移除所有專案的快取和索引。重新開啟專案時將建置新快取。
dialog.message.can.not.open.file=無法開啟檔案 {0}
dialog.message.cannot.perform.operation.too.complex.sorry=無法執行動作。抱歉，太複雜了。
dialog.message.cannot.save.the.file.0=無法儲存檔案 {0}
dialog.message.command.not.finished.yet={0} 尚未完成。
dialog.message.communication.error=通信錯誤
dialog.message.component.could.not.be.reloaded=無法重新載入該元件。重新載入專案?
dialog.message.conversions.will.be.performed=<html>將執行以下轉換:<br>{0}</html>
dialog.message.could.not.erase.files.or.folders.0.1=無法擦除檔案或目錄:\\n{0}{1}
dialog.message.disable.dependent.plugin=<html>將停用相依的 ''{0}'' 延伸模組</html>
dialog.message.disable.dependent.plugins=<html>以下相依延伸模組將被停用: <br>{0}</html>
dialog.message.enable.required.plugin=<html>將啟用所需的 ''{0}'' 延伸模組</html>
dialog.message.enable.required.plugins=<html>將啟用所需的以下延伸模組: <br>{0}</html>
dialog.message.enable.vagrant.support.plugin=啟用 Vagrant 支援延伸模組
dialog.message.enter.new.value.for.0=輸入 {0} 的新值
dialog.message.enter.new.value.for.0.in.form.brightness.contrast.alpha=在“亮度、對比度、Alpha”表單中\\n輸入 {0} 的新值
dialog.message.enter.new.value.for.0.in.form.top.left.bottom.right=在“上、下、左、右”表單中\\n輸入 {0} 的新值
dialog.message.enter.new.value.for.0.in.form.width.height=以“寬度,高度”形式\\n輸入 {0} 的新值
dialog.message.error.setting.value=設定值時出錯: {0}
dialog.message.execution.finished=執行已完成
dialog.message.execution.finished.because=執行被終止，原因是: {0}
dialog.message.fail.to.load.plugin.descriptor.from.file=無法從檔案 {0} 載入延伸模組檔案描述子
dialog.message.file.already.exists=檔案已存在
dialog.message.file.with.name.already.exists=名稱為 ''{0}'' 的檔案已存在
dialog.message.folder.with.name.already.exists=名稱為 ''{0}'' 的目錄已存在
dialog.message.following.plugin.depend.on=以下{0,choice,1#延伸模組|2#延伸模組}{0,choice,1#相依|2#相依}於 {1}:<br>{2}<br>是否繼續移除 {1}{3, choice, 0#|1# 更新}?
dialog.message.host.name.empty=主機名為空
dialog.message.incompatible.encoding=您選擇的編碼(''{0}'')可能會更改 ''{1}'' 的內容。<br>是否要<br>1. 以新的編碼 ''{0}'' 從磁碟<b>重新載入</b>檔案，並覆蓋編輯器內容或<br>2. <b>轉換</b>文本並以新編碼覆蓋檔案?
dialog.message.internal.error=內部錯誤
dialog.message.invalid.host.value=主機值無效
dialog.message.invalid.path=無效路徑 ''{0}''
dialog.message.jetbrains.client.for.ide={0} 的 JetBrains 用戶端
dialog.message.login.empty=登入名為空
dialog.message.must.be.restarted.for.changes.to.take.effect=重啟 {0} 以使更改生效
dialog.message.no.message=沒有訊息
dialog.message.no.project.found.to.open.file.in=找不到可以在以下位置開啟檔案的專案:
dialog.message.only.one.instance.can.be.run.at.time=一次只能執行一個 {0} 執行個體。
dialog.message.open.cancelled=開啟動作已取消
dialog.message.password.empty=密碼為空
dialog.message.please.enter.credentials.for=請輸入憑證: {0}
dialog.message.plugin.core.part=延伸模組 ''{0}'' 是 {1} 的核心部分。要將其更新到較新版本，您應該更新 IDE。
dialog.message.plugin.depends.on.unknown.plugin=延伸模組 {0} 依賴於未知{1,choice,1#延伸模組|2#延伸模組} {2}
dialog.message.plugin.is.not.allowed=您的組織不允許安裝延伸模組 ''{0}''
dialog.message.plugin.was.already.installed=延伸模組 ''{0}'' 已安裝
dialog.message.press.for.field.hints=按 {0} 獲取欄位提示
dialog.message.problem.with.connection=<html>連線出現問題:<br>{0}</html>
dialog.message.project.group.name=專案組名
dialog.message.remove.0.from.recent.projects.list=從最近的專案列表中移除 ''{0}''?
dialog.message.remove.projects.from.recent.projects.list=是否從最近的專案列表中移除專案?
dialog.message.restart.alt=您的設定不支持重新啟動。要離開 IDE 嗎?
dialog.message.restart.ide=是否要重啟 IDE?
dialog.message.restarted.to.apply.changes=是否重新啟動 {0} 以套用更改?
dialog.message.specified.path.cannot.be.found=找不到指定的路徑
dialog.message.the.following.items=可選:
dialog.message.there.already.same.interpreter=已經有相同的解釋器:\\n{0}
dialog.message.trying.to.create.folder.with.ignored.name=正在嘗試建立具有忽略名稱的目錄；結果將不可見
dialog.message.unable.to.apply.changes=<body style="padding: 5px;">無法套用更改: 將無法載入{0,choice,1#延伸模組|2#延伸模組} {1}。</body>
dialog.message.unable.to.create.idea.directory=無法建立 ''.idea'' 目錄(%s): {0}
dialog.message.unknown.error=未知錯誤
dialog.message.url.is.empty=URL 為空
dialog.message.url.is.invalid=URL 無效
dialog.message.wait.must.be.supplied.with.file.or.project.to.wait.for=必須為 '--wait' 提供要等待的檔案或專案
dialog.message.was.unable.to.save.some.project.files={0} 無法儲存某些專案檔案，確定仍要關閉此專案嗎?\\n\\n唯讀檔案:\\n
dialog.new.window.layout.prompt=布局名稱:
dialog.new.window.layout.title=新增布局
dialog.newui.title.user.interface=重啟以套用 UI 更改
dialog.rename.window.layout.prompt=布局名稱:
dialog.rename.window.layout.title=重新命名布局
dialog.text.error.getting.value=獲取值時出錯: {0}
dialog.title.abbreviation=縮寫
dialog.title.activity.monitor=活動監視器
dialog.title.add.actions.to.quick.list=將動作新增到快速列表
dialog.title.add.new.value=新增新值
dialog.title.attach.project.error=無法附加專案
dialog.title.auto.detected.proxy=自動檢測的代理
dialog.title.background.image=背景圖像
dialog.title.can.t.create.0.sdk=無法建立 {0} SDK
dialog.title.cannot.execute.command=無法執行指令
dialog.title.change.group.name=更改組名
dialog.title.change.project.icon=設定自訂專案圖示
dialog.title.check.proxy.settings=檢查代理設定
dialog.title.choose.color=選擇顏色
dialog.title.choose.encoding.for.the.0=選擇 ''{0}'' 的編碼
dialog.title.choose.plugins.to.install.or.enable=選擇要安裝或啟用的延伸模組
dialog.title.clear.read.only.file.status=清除唯讀狀態
dialog.title.collect.troubleshooting.information=收集故障排除資訊
dialog.title.color.picker=取色器
dialog.title.configuration.changed=組態已更改
dialog.title.convert.module=轉換模組
dialog.title.convert.project=轉換專案
dialog.title.create.new.project.group=建立新項目組
dialog.title.custom.debug.log.configuration=自訂偵錯日誌組態
dialog.title.customize.0=自訂 {0}
dialog.title.data.sharing=資料共享
dialog.title.delete.0=刪除 {0}
dialog.title.dependent.plugins.found=找到相依的延伸模組
dialog.title.dimension.editor=尺寸編輯器
dialog.title.disable.dependent.plugins=停用相依延伸模組
dialog.title.edit.laf.defaults=編輯 LaF 預設值
dialog.title.enable.required.plugins=啟用必需延伸模組
dialog.title.error.saving.project=儲存專案時出錯!
dialog.title.error.writing.file=寫入檔案時錯誤
dialog.title.experimental.features=實驗性功能
dialog.title.export.to.file=匯出到檔案
dialog.title.failed.to.perform.operation=執行動作失敗
dialog.title.fetching.predefined.settings.for.disabled.plugins=正在獲取已停用延伸模組的預定義設定
dialog.title.file.0.can.t.be.reloaded=無法以 ''{1}'' 編碼重新載入檔案 ''{0}''。{2}
dialog.title.file.0.most.likely.isn.t.stored=檔案 ''{0}'' 可能未以 ''{1}'' 編碼存儲。{2}
dialog.title.font.size.editor=字號編輯器
dialog.title.go.to.line.column=轉到行:列
dialog.title.gray.filter.editor=灰色篩選器編輯器
dialog.title.http.proxy.exceptions=代理異常
dialog.title.import=匯入
dialog.title.insets.editor=插入編輯器
dialog.title.install.plugin=安裝延伸模組
dialog.title.installing.plugin=正在安裝延伸模組 {0}
dialog.title.invalid.input=輸入無效
dialog.title.invalidate.caches=使快取失效
dialog.title.jcef.proxyAuthentication=代理身份驗證
dialog.title.migrating.plugins=正在遷移延伸模組
dialog.title.new.tag.name=新增標記名稱
dialog.title.non.project.files.protection=非專案檔案保護
dialog.title.number.editor=數字編輯器
dialog.title.plugin.updates=延伸模組更新
dialog.title.proxy.authentication=代理身份驗證: {0}
dialog.title.proxy.setup=代理設定
dialog.title.remove.recent.project=移除最近的專案
dialog.title.remove.recent.project.plural=移除最近的專案
dialog.title.reopen.project=重新開啟專案
dialog.title.required.plugin=必需延伸模組
dialog.title.restart.ide=重啟?
dialog.title.restart.required=需要重啟
dialog.title.save.as=另存為
dialog.title.save.project.to.directory.based.format=將專案儲存為基於目錄的格式
dialog.title.select.0=選擇 {0}
dialog.title.third.party.software={0} {1} 使用的第三方軟體
dialog.title.unable.to.save=無法儲存
dialog.title.untrusted.server.s.certificate=不可信伺服器的憑證
dialog.title.updating.plugin=正在更新延伸模組 {0}
dialog.title.vagrant.support.disabled=已停用 Vagrant 支援
diff.dialog.title=''{0}'' 與 ''{1}'' 之間的差異
directory.message.cant.create.folder=無法建立名為 ''{0}'' 的目錄
directory.project.location.description=為專案選擇基目錄
directory.project.location.label=位置(&L):
directory.project.location.title=選擇基目錄
display.balloon.notifications=顯示氣球通知
display.name.firefox.settings=Firefox 設定
dnd.with.alt.pressed.only=僅按下 Alt 時拖放
do.not.ask.me.again=不再詢問
double.ctrl.or.shift.shortcut=雙擊 {0}
dumb.balloon.0.is.not.available.while.indexing=索引編制期間 {0} 不可用
dumb.balloon.none.of.the.following.actions.are.available.during.indexing.0=索引編制期間以下動作均不可用: {0}
dumb.balloon.this.action.is.not.available.during.indexing=索引編制期間此動作不可用
dumb.mode.results.might.be.incomplete=編制索引時，結果可能不完整
dumb.mode.spoiler.wrapper.reload.text=重新載入結果
dumb.service.indexing.paused.due.to=由於{0}，索引編制暫停
dump.focusable.component.hierarchy.close.button=關閉並複製到剪貼簿
editbox.customfiletype.block.comment.end=塊註釋結束:
editbox.customfiletype.block.comment.start=塊註釋開始:
editbox.customfiletype.description=描述:
editbox.customfiletype.hex.prefix=十六進制前綴:
editbox.customfiletype.line.comment=行註釋:
editbox.customfiletype.name=名稱:
editbox.customfiletype.number.postfixes=數字後綴:
editbox.default.encoding.for.properties.files=屬性檔案的預設編碼:
editbox.export.to.file=匯出到檔案:
editbox.plugin.description=描述
editor.banner.close.tooltip=關閉
editor.tabs.always.keep.sorting=始終保持啟用排序
editor.tabs.enable.sorting=啟用排序
empty.project.generator.description=不帶模組的專案。用它來建立自由樣式的模組結構。將開啟“專案結構”對話框，幫助您建置專案結構。
empty.project.generator.name=多模組專案
empty.text.drop.files.to.open=將檔案拖放到此處以開啟
empty.text.go.to.file=轉到檔案
empty.text.navigation.bar=導覽列
empty.text.no.entries=無條目
empty.text.no.features.available=無可用功能
empty.text.no.project.open.yet=尚無專案開放
empty.text.nothing.found=找不到任何內容
empty.text.nothing.selected=未選擇任何內容
empty.text.project.view=專案檢視
empty.text.recent.files=最近的檔案
empty.text.search.everywhere=隨處搜尋
empty.text.this.view.is.not.available.until.indices.are.built=在建置索引前，此檢視不可用
encoding.do.not.convert.message=請勿轉換到 ''{0}''。
encoding.name.properties.default=<屬性預設值: {0}>
encoding.name.system.default=<系統預設: {0}>
encoding.not.available=不適用
encoding.unsupported.characters.message=編碼 ''{0}'' 不支持文本中的某些字元。
encodings.dialog.caption=新增檔案或目錄的路徑並選擇 {0} 應使用的編碼。<br>檔案和目錄從父目錄或專案編碼繼承編碼。<br>JSP、HTML 和 XML 檔案中的內建檔案編碼會覆寫這些設定。
environment.key.description.enable.disabled.dependent.plugins=指定在更新某些延伸模組時是否應啟用已停用的相依延伸模組。如果選擇“所有”，則啟用所有已更新和相依的延伸模組。如果選擇“已更新”，則僅啟用已更新的延伸模組。如果為“無”，則不會啟用任何延伸模組。
error.0.browser.path.not.specified={0}瀏覽器路徑未指定。
error.cannot.convert.project=無法轉換專案: {0}
error.cannot.load.project=無法載入專案: {0}
error.cannot.set.look.and.feel=<html><body>無法設定{0}主題:<br>{1}</body></html>
error.connection.failed=連線失敗
error.descriptor.load.failed=無法從{0}載入延伸模組檔案描述子。所選檔案可能不是 IntelliJ 延伸模組。
error.dir.contains.no.project=''{0}'' 不包含專案
error.directory.with.name.already.exists=名稱為 ''{0}'' 的目錄已存在
error.download.plugin.via.blockmap=無法通過塊映射下載延伸模組。正在從 {0} 下載整個歸檔
error.downloaded.descriptor.load.failed=無法從下載的歸檔載入延伸模組檔案描述子。歸檔可能不是 IntelliJ 延伸模組。
error.empty.name=名稱不得為空
error.failed.to.create.directory=無法建立目錄“{0}”
error.favorites.list.already.exists=收藏夾列表 ''{0}'' 已存在
error.file.does.not.exist=檔案 {0} 不存在。
error.file.not.found.message=檔案 ''{0}'' 不存在
error.file.with.name.already.exists=名稱為 ''{0}'' 的檔案已存在
error.files.of.this.type.cannot.be.opened=無法在{0}中開啟此類型的檔案
error.filter.name.should.be.specified=應指定篩選器名稱
error.filter.should.contain.at.least.one.pattern=篩選器應至少包含一個模式
error.filter.with.the.same.name.already.exists=具有相同名稱的篩選器已存在
error.group.already.exists=組 ''{0}'' 已存在。
error.incompatible.update=下載的版本與當前 IDE 不相容: {0}
error.invalid.directory=無效目錄: ''{0}''
error.invalid.directory.name=''{0}'' 不是有效的目錄名稱
error.invalid.file.name=''{0}'' 是無效的檔名
error.invalid.java.package.name=無效的軟體套件名稱；無法在內部建立 Java 類別
error.invalid.java.package.name.format=無效的軟體套件名稱格式設定；無法在內部建立 Java 類別
error.invalid.template.file.name.or.extension=無效的模板檔名或副檔名
error.loading.package.list=載入軟體套件列表時出錯: {0}
error.malformed.url=URL 格式錯誤: {0}
error.message.cannot.make.files.writable=無法解鎖以下檔案:\\n{0}
error.message.cannot.modify.file.0=無法修改檔案 ''{0}''
error.message.exception.was.thrown=拋出了異常
error.message.unable.to.create.file=無法建立檔案 ''{0}''
error.module.already.exists=名為 ''{0}'' 的模組已存在
error.name.already.exists=名稱已被使用。請更改為唯一名稱。
error.name.cannot.be.empty=名稱不能為空
error.name.should.be.specified=必須指定名稱
error.no.plugins.found=未找到延伸模組。檢查日誌檔案中有無錯誤。
error.occurred.please.check.your.internet.connection=出錯了。請檢查您的互聯網連線。
error.older.update=下載的版本({0})比當前安裝的版本({1})舊。
error.package.with.name.already.exists=名稱為 ''{0}'' 的軟體套件已存在
error.parsing.file.template=解析檔案模板時出錯: {0}
error.pattern.should.be.specified=應指定模式
error.pending.update=延伸模組“{0}”的另一個更新正在等待安裝。請重啟，然後重試。
error.please.enter.a.file.name=指定檔名
error.please.specify.path.to.web.browser=在“{0} | Web 瀏覽器”中指定 Web 瀏覽器路徑
error.please.specify.template.name=指定模板名稱
error.plugin.required.for.project.disabled=''{1}'' 專案所需延伸模組 ''{0}'' 已停用。
error.plugin.required.for.project.not.installed=''{1}'' 專案所需延伸模組 ''{0}'' 未安裝。
error.plugin.was.not.installed=延伸模組“{0}”未安裝: {1}
error.project.file.does.not.exist=無法載入 {0}。該檔案不存在。
error.project.requires.newer.ide=專案 ''{0}'' 需要 IDE 的 {1}''{2}'' 或更新的建置，但當前建置為 ''{3}''。
error.project.requires.newer.plugin=專案 ''{0}'' 需要延伸模組 ''{1}'' 版本 ''{2}'' 或更高版本，但已安裝的是 ''{3}''。
error.project.requires.older.ide=專案 ''{0}'' 需要 IDE 的 {1}''{2}'' 或更老的建置，但當前建置為 ''{3}''。
error.project.requires.older.plugin=專案 ''{0}'' 需要延伸模組 ''{1}'' 版本 ''{2}'' 或更低版本，但已安裝的是 ''{3}''。
error.project.requires.plugins.not.enabled=專案 ''{0}'' 需要啟用以下延伸模組:
error.project.requires.plugins.not.installed=專案 ''{0}'' 需要安裝以下延伸模組:
error.same.pattern.already.exists=一些模式已存在
error.saving.statistics=儲存系統資訊時出錯: {0}
error.text.file.already.exists=檔案 {0} 已存在。\\n希望覆蓋還是追加?
error.tips.not.found=找不到每日小技巧。確保已正確安裝 {0}。
error.tree.view.cell.error=錯誤: {0}
error.tree.view.fix.description=修復: {0}
error.tree.view.fixing=正在修正…
error.unable.to.parse.template.message=無法解析模板“{0}”，\\n錯誤訊息: {1}
error.unable.to.read.tip.of.the.day=<html><body>無法讀取每日小技巧({0})。確認已正確安裝 {1}。</body></html>
error.unc.not.supported=UNC 路徑不受支援: {0}
error.updating.package.list=更新軟體套件列表時出錯: {0}
error.user.home.directory.not.found=未找到使用者主目錄
error.writing.to.file=寫入檔案時出錯: {0}
errortree.error=錯誤:
errortree.information=資訊:
errortree.noMessages=沒有訊息
errortree.note=注意:
errortree.prefix.line=行({0})
errortree.warning=警告:
essential-highlighting.mode.disable.action.title=停用基本醒目提示顯示模式
essential-highlighting.mode.on.notification.content=基本醒目提示模式只保留一組有限的程式碼醒目提示工具。包括檢查在內的所有醒目提示工具都將在執行檔案儲存動作時執行。
essential-highlighting.mode.on.notification.title=基本醒目提示模式已開啟
external.link.confirmation.message.0=確定要在瀏覽器或關聯的應用程式中開啟此連結嗎?<br><br>{0}
external.link.confirmation.title=開啟連結
external.link.confirmation.trust.label=信任專案並開啟
external.link.confirmation.yes.label=開啟
failed.to.install.package.dialog.title=無法安裝 ''{0}''
failed.to.install.packages.dialog.title=無法安裝軟體套件
failed.to.take.thread.dump=無法獲取執行緒傾印。
failed.to.unload.modified.plugins=無法移除修改的延伸模組: {0}
favorites.list.unnamed=未命名的{0}
feature.file.handler.ansi.highlighter=ANSI 程式碼
file.changed.externally.message=檔案在磁碟上已被更改。
file.changed.externally.reload=重新載入
file.chooser.completion.ad.text=使用 {0} 保留路徑尾部
file.chooser.completion.no.suggestions=無建議
file.chooser.completion.path.variables.text=路徑變數
file.chooser.hide.path=隱藏路徑
file.chooser.show.path=顯示路徑
file.encoding.option.create.utf8.files=建立 UTF-8 檔案:
file.encoding.option.encoding.column=編碼
file.encoding.option.global.encoding=全域編碼
file.encoding.option.path.column=路徑
file.encoding.option.project.encoding=專案編碼
file.encoding.option.warning.always={0} 會將 <a href="https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8">UTF-8 BOM</a> 新增到使用 UTF-8 編碼建立的每個檔案中
file.encoding.option.warning.never={0} 不會將 <a href="https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8">UTF-8 BOM</a> 新增到每個以 UTF-8 編碼建立的檔案中
file.encoding.option.warning.windows.only={0} 只會在每個建立的 UTF-8 檔案在 Windows 下執行時向其新增 <a href="https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8">UTF-8 BOM</a>
file.encodings.configurable=檔案編碼
file.encodings.not.configured=未組態編碼
file.nesting.dialog.title=檔案嵌套
file.nesting.feature.enabled.checkbox=以嵌套形式顯示具有相同名稱的檔案(&S)
file.nesting.reset.to.default.button=重設為預設(&R)
file.nesting.table.title=嵌套規則:
file.read.error=無法讀取檔案 {0}。
file.read.error.details=無法讀取檔案 {0}: {1}
file.write.error=無法寫入到檔案 {0}
file.write.error.details=無法寫入檔案 {0}: {1}
filetype.gui.designer.form.description=GUI 設計器表單
filetype.gui.designer.form.display.name=GUI 設計器表單
filetype.scalable.vector.graphics.description=可縮放矢量圖形
filetype.scalable.vector.graphics.display.name=可縮放矢量圖形
filetype.search.everywhere.directory.description=檔案系統目錄
filetype.web.preview.description=用於嵌入式瀏覽器中的檔案預覽
filetype.web.preview.display.name=Web 預覽
filters.all=所有
filters.select=選擇…
find.ide.update.title=尋找 IDE 更新
fixed.problem.prefix=已修復:
focus.debugger.label.newvalue=新值=
focus.debugger.label.oldvalue=舊值=
font.info.renderer.non.latin=非拉丁語
font.reset.link=重設為預設
gdpr.checkbox.when.using.eap.versions=使用 EAP 版本時{0}
gdpr.consent.externally.disabled.warning=此選項已從外部停用
gdpr.continue.button=繼續
gdpr.data.collection.consent.group.comment.text=幫助塑造 JetBrains 產品的未來。通過共享您的資料和使用統計資訊，您可以讓我們更好地了解您如何使用我們的工具，並幫助我們改進這些工具。點擊<a href="https://www.jetbrains.com/legal/docs/terms/product_data_collection/">此處</a>了解詳情。
gdpr.data.collection.consent.group.setting.disabled.warning.text=您的組織管理員已停用資料收集。
gdpr.data.collection.consent.group.setting.enabled.warning.text=您的組織管理員已啟用資料收集。
gdpr.exit.button=離開
gdpr.hint.text.apply.to.all.installed.products=資料共享偏好設定適用於所有已安裝的 {0} 產品。
gdpr.hint.text.you.can.always.change.this.behavior=您隨時可以在“{0} | 外觀與行為 | 系統設定 | 資料共享”中更改此行為。
gdpr.label.there.are.no.data.sharing.options.available=沒有可用的資料共享選項
gdpr.usage.statistics.disabled.externally.warning=Toolbox Enterprise 延伸模組已暫時停用發送使用統計資訊。
gdpr.usage.statistics.enabled.for.free.license.warning=在非商業許可下，IDE 會收集使用數據以驗證是否符合許可條款，並向 JetBrains 發送匿名功能使用統計資訊以幫助改進產品。有關詳情，請參閱 <a href="https://www.jetbrains.com/legal/docs/privacy/privacy/">JetBrains 隱私政策</a>。
general.module.type.description=一個允許使用單獨的檔案並編譯 Java 和 Kotlin 類別的基本專案。
github.project.generator.version=版本(&V):
github.project.generator.versions.not.loaded.error=尚未載入版本。
go.to.class.action.description=按名稱快速導覽到{0}
go.to.class.dumb.mode.message=在建置索引前，轉到 {0} 動作不可用，改用轉到檔案
go.to.class.kind.text=類別
go.to.class.kind.text.pluralized=類別
go.to.class.title.prefix=轉到{0}
got.it.button.name=知道了
goto.custom.region.command=轉到自訂折疊
goto.custom.region.menu.item=自訂折疊…
goto.custom.region.message.dumb.mode=在建置索引前，自訂折疊導覽不可用。
goto.custom.region.message.unavailable=當前檔案中沒有自訂的折疊
goto.inspection.action.choose.inherit.settings.from=檢查選項
goto.inspection.action.dialog.title=執行 ''{0}''
goto.inspection.action.fix.all=全部修正
goto.inspection.action.text=通過名稱執行檢查(&R)…
group.antialiasing.mode=抗鋸齒
group.customfiletype.syntax.highlighting=語法醒目提示
group.customizations.add.action.below=在下方新增動作…
group.customizations.add.action.button=新增…
group.customizations.add.action.group=新增動作…
group.customizations.restore.action.group=還原動作…
group.presentation.mode=示範模式
group.settings.process.tab.close=關閉具有執行程序的工具視窗時:
group.todo.filter.patterns=模式
group.transparency=透明度
group.trees=樹檢視
group.ui.options=UI 選項
group.vendor=供應商
group.view.options=檢視選項
group.window.options=工具視窗
handle.ro.file.status.failed=<html>無法更改以下檔案的唯讀狀態:<br>{0}</html>
handle.ro.file.status.failed.many.files=<br>…<br>共 {0} 個檔案
handle.ro.file.status.type.using.file.system=使用檔案系統
hashes.doesnt.match=還原的歸檔的雜湊與原始歸檔的雜湊不符合
hide.native.linux.title.not.supported.incompatible.jbr=不相容的 JBR/JRE
hide.native.linux.title.not.supported.tiling.wm=不支持平鋪式視窗管理器
hide.native.linux.title.not.supported.undefined.desktop=不支持未定義的桌面
hide.native.linux.title.not.supported.wayland.or.xtoolkit.required=需要 Wayland 或 XToolkit
hide.native.linux.title.not.supported.wsl=不支持 WSL
hierarchy.call.next.occurence.name=轉到下一個呼叫
hierarchy.call.prev.occurence.name=轉到上一個呼叫
hierarchy.legend.method.defined.in.superclass=方法未在類別中定義，但在其超類別中定義
hierarchy.legend.method.is.defined.in.class=方法已在類別中定義
hierarchy.legend.method.should.be.defined=必須定義方法，因為類別不為 abstract
hierarchy.method.next.occurence.name=轉到下一個方法
hierarchy.method.prev.occurence.name=轉到上一個方法
hierarchy.type.next.occurence.name=轉到下一個類型
hierarchy.type.prev.occurence.name=轉到上一個類型
high.contrast.theme.name=高對比度
hint.scheme.editing=按 Enter 儲存，按 Esc 取消
hint.text.all.lines.already.have.requested.indentation=所有行都已請求縮排
hint.text.changed.indentation.in=已更改{0,choice,1#行|2#行}中的縮排
http.editor.name=HTTP
http.multirange.response.doesnt.contain.boundary=HTTP 多範圍響應邊界線 {0} 不包含邊界 {1}
http.multirange.response.doesnt.include.line.separator=HTTP 多範圍響應不包含行分隔符
http.multirange.response.includes.incorrect.header=HTTP 多範圍響應包含不正確的頭 - {0}，應為 {1}
http.proxy.configurable=HTTP 代理
http.velocity={0}<hr> <font face="verdana" size="-1"><a href=''https://velocity.apache.org/engine/devel/user-guide.html#Velocity_Template_Language_VTL:_An_Introduction''>\\nApache Velocity</a> 模板語言已使用</font>
icon.debugger.db_array.tooltip=陣列
icon.debugger.db_obsolete.tooltip=過時的框架
icon.debugger.db_primitive.tooltip=基元類型的值
icon.debugger.db_watch.tooltip=監視
icon.debugger.frame.tooltip=框架
icon.debugger.selfreference.tooltip='this' 的參照
icon.debugger.threadAtBreakpoint.tooltip=中斷點處的執行緒
icon.debugger.threadCurrent.tooltip=當前執行緒
icon.debugger.threadFrozen.tooltip=凍結執行緒
icon.debugger.threadGroup.tooltip=執行緒組
icon.debugger.threadGroupCurrent.tooltip=當前線程組
icon.debugger.threadRunning.tooltip=正在執行的執行緒
icon.debugger.threadSuspended.tooltip=暫停的執行緒
icon.debugger.value.tooltip=值
icon.debugger.watchLastReturnValue.tooltip=最後一個方法呼叫的返回值
icon.file.filter.label=圖示檔案
icon.fileTypes.archive.tooltip=歸檔檔案
icon.fileTypes.custom.tooltip=自訂類型的檔案
icon.fileTypes.diagram.tooltip=圖表檔案
icon.fileTypes.java.tooltip=Java 檔案
icon.fileTypes.javaClass.tooltip=Java 編譯的位元組碼檔案
icon.fileTypes.javaOutsideSource.tooltip=來來源根之外的 Java 檔案
icon.fileTypes.json.tooltip=JSON 檔案
icon.fileTypes.jsonSchema.tooltip=JSON 架構檔案
icon.fileTypes.manifest.tooltip=清單檔案
icon.fileTypes.properties.tooltip=屬性檔案
icon.fileTypes.unknown.tooltip=未知類型的檔案
icon.fileTypes.xml.tooltip=XML 檔案
icon.fileTypes.yaml.tooltip=YAML 檔案
icon.modules.excludeRoot.tooltip=排除的目錄
icon.modules.excludedGeneratedRoot.tooltip=排除的生成來源根
icon.modules.generatedFolder.tooltip=生成的目錄
icon.modules.generatedSourceRoot.tooltip=生成的來源根
icon.modules.generatedTestRoot.tooltip=生成的測試來源根
icon.modules.output.tooltip=輸出根
icon.modules.resourcesRoot.tooltip=資源根
icon.modules.sourceRoot.tooltip=來來源根
icon.modules.testResourcesRoot.tooltip=測試資源根
icon.modules.testRoot.tooltip=測試來來源根
icon.modules.unloadedModule.tooltip=已移除的模組
icon.nodes.Module.tooltip=模組
icon.nodes.abstractClass.tooltip=抽象類別
icon.nodes.abstractException.tooltip=abstract 異常
icon.nodes.abstractMethod.tooltip=abstract 方法
icon.nodes.annotationtype.tooltip=註解類型
icon.nodes.anonymousClass.tooltip=匿名類別
icon.nodes.c_plocal.tooltip=package-local
icon.nodes.c_private.tooltip=private
icon.nodes.c_protected.tooltip=protected
icon.nodes.c_public.tooltip=public
icon.nodes.class.tooltip=類別
icon.nodes.classInitializer.tooltip=類別初始設定式
icon.nodes.enum.tooltip=枚舉
icon.nodes.exceptionClass.tooltip=異常類別
icon.nodes.excludedFromCompile.tooltip=已從編譯中排除
icon.nodes.field.tooltip=欄位
icon.nodes.finalMark.tooltip=final
icon.nodes.folder.tooltip=目錄
icon.nodes.ideaModule.tooltip=IntelliJ 模組檔案
icon.nodes.interface.tooltip=接口
icon.nodes.junitTestMark.tooltip=單元測試
icon.nodes.locked.tooltip=唯讀
icon.nodes.method.tooltip=方法
icon.nodes.moduleGroup.tooltip=模組組
icon.nodes.nodePlaceholder.tooltip=
icon.nodes.package.tooltip=軟體套件
icon.nodes.parameter.tooltip=參數
icon.nodes.ppJdk.tooltip=JDK
icon.nodes.ppLib.tooltip=外部庫
icon.nodes.runnableMark.tooltip=可執行
icon.nodes.staticMark.tooltip=static
icon.runConfigurations.testError.tooltip=意外異常
icon.runConfigurations.testFailed.tooltip=斷言失敗
icon.runConfigurations.testIgnored.tooltip=測試已忽略
icon.runConfigurations.testNotRan.tooltip=測試未開始
icon.runConfigurations.testPassed.tooltip=測試通過
icon.runConfigurations.testSkipped.tooltip=測試已跳過
icon.runConfigurations.testTerminated.tooltip=測試已終止
icon.validation.message.format=圖示格式不正確
icon.validation.message.not.found=該圖示不存在
ide.mac.app.icon.error.message=無法{0,choice,0#設定|1#重設}自訂應用程式圖示
ide.notnow.action=以後再說
ide.postpone.action=推遲
ide.protocol.cannot.title=無法開啟 URI
ide.protocol.exception=內部錯誤: {0}: {1}
ide.protocol.internal.bad.query=不正確的查詢字串: ''{0}''
ide.protocol.progress.title=正在開啟 URI
ide.protocol.unsupported=不支持的協議: ''{0}''
ide.restart.action=重啟
ide.restart.required.comment=需要重新啟動
ide.restart.required.message={0}{1}以套用延伸模組中的更改?
ide.restart.required.notification={0, choice, 0#關閉|1#重啟}以啟用延伸模組更新
ide.scale.reset.link=重設為預設
ide.script.launcher.used=IDE 似乎是用腳本啟動器(''{0}'')啟動的。請考慮切換到原生啟動器(''{1}'')以獲得更好的體驗。
ide.shutdown.action=關閉
idea.intellij.look.and.feel=IntelliJ Light 舊版
ijent.wsl.fs.dialog.message=虛擬機選項組態不正確。WSL 動作可能會失敗。
ijent.wsl.fs.dialog.restart.button=自動修正虛擬機選項並重新啟動
ijent.wsl.fs.dialog.shutdown.button=自動修正虛擬機選項並關閉
implicit.log.directory.path=似乎您正在使用 ''idea.system.path'' 屬性指定快取目錄的位置。在 2020.1 中，應用程式目錄的預設位置已更改。為確保兼容性，IDE 選擇了日誌的舊位置({0})，但為了避免將來出現任何歧義(並去除此警告)，另請設定 ''idea.log.path'' 屬性。
implicit.plugin.directory.path=似乎您正在使用 ''idea.config.path'' 屬性指定設定目錄的位置。在 2020.1 中，應用程式目錄的預設位置已更改。為確保兼容性，IDE 選擇了延伸模組的舊位置({0})，但為了避免將來出現任何歧義(並去除此警告)，另請設定 ''idea.plugins.path'' 屬性。
in.product.notification.action.default.text=授權到期資訊
in.product.notification.action.discount.button=獲取六折優惠
in.product.notification.action.dismiss.button=關閉
in.product.notification.action.renew.button=續訂授權…
in.product.notification.action.text=<b>您的授權將在{0,choice,0#今天|1# 1 天後|2# {0} 天後}到期。</b>您可以選擇<br>免費續訂教育授權，或者獲取六折<br>畢業折扣。
in.product.notification.action.tooltip={0} 授權將在{1,choice,0#今天|1# 1 天後|2# {1} 天後}到期
in.product.notification.dialog.text=<h1>您的授權將在{0,choice,0#今天|1# 1 天後|2# {0} 天後}到期</h1><br>您可以選擇免費續訂教育授權，<br>或者如果您已經畢業，可以<a href="https://www.jetbrains.com/community/education/#students/renewal/">獲取六折優惠</a>。<br>
incompatible.encoding.dialog.title=不相容的編碼: {0}
incomplete.mode.results.might.be.incomplete=在載入所有相依項之前，結果可能不完整
information.hint.accessible.context.name=提示
initial.popup.context.switchers.text=正在載入上下文…
inline.actions.more.actions.text=更多動作
inline.completion.tooltip.shortcuts.accept.description=以補全
inline.completion.tooltip.shortcuts.accept.select.custom=自訂…
inline.completion.tooltip.shortcuts.header=內聯補全快捷鍵
inspection.message.inspection.info=檢查資訊
install.package.failure=安裝軟體套件 ''{0}'' 時發生錯誤。<a href="xxx">詳細資訊…</a>
install.plugin.chooser.description=接受 JAR 和 ZIP 歸檔
install.plugin.chooser.label=延伸模組檔案
install.plugin.chooser.title=選擇延伸模組檔案
intellij.light.theme.name=IntelliJ Light
intention.family.editor.notification=編輯器通知
intention.family.editor.notification.option=編輯器通知選項
intention.family.editor.notification.settings=編輯器通知設定
internal.decorator.accessible.postfix=工具視窗
interpreter.default.name=遠端 {0} 解釋器
invalid.context=<無效>
invalid.node.text=無效
invalidate.all.caches.recovery.action.name=使快取失效並重啟
invalidate.workspace.model.recovery.action.presentable.name=重新開啟專案
item.get.more.languages=獲取更多語言…
javascript.debugger.settings.choose.file.subtitle=選擇要偵錯其中的 JavaScript 的網頁
javascript.debugger.settings.choose.file.title=選擇
jb.protocol.navigate.missing.parameters=URL 中既沒有指定 'project' 參數，也沒有指定 'origin' 參數
jb.protocol.navigate.no.project=找不到或無法開啟指定的專案
jb.protocol.navigate.target=''navigate'' 指令僅支援 ''reference'' 目標(找到 ''{0}'')
jb.protocol.parameter.missing=缺少參數: ''{0}''
jb.protocol.settings.no.configurable=找不到設定頁面: ''{0}''
jb.protocol.unknown.command=未知指令: ''{0}''
jb.protocol.unknown.target=未知目標: ''{0}''
jcef.local.cache.invalidate.comment=影響使用嵌入式瀏覽器呈現基於 HTML 的內容和網頁的元件。
jcef.local.cache.invalidate.description=刪除嵌入式瀏覽器引擎快取和 Cookie
jcef.local.cache.invalidate.failed.message=“使快取失效”動作請求了嵌入式瀏覽器引擎快取清理。由於 I/O 錯誤，動作失敗: {0}
jcef.local.cache.invalidate.failed.title=無法清理瀏覽器引擎快取
jetbrains.certificate.invalid=JetBrains 憑證無效。請聯繫 JetBrains 支援人員。
jetbrains.certificate.not.found=找不到 JetBrains 憑證。
jetbrains.certificate.vendor=供應商: {0}
keymap.action.configure.keymap=組態按鍵映射…
keymap.action.install.keymap=安裝按鍵映射…
label.appearance.caret.blinking=外觀: 文字游標閃爍
label.appearance.show.inner.whitespaces=外觀: 顯示內部空格
label.appearance.show.leading.whitespaces=外觀: 顯示前導空格
label.appearance.show.right.margin=外觀: 顯示右邊距
label.appearance.show.trailing.whitespaces=外觀: 顯示尾隨空格
label.appearance.show.vertical.indent.guides=外觀: 顯示垂直縮排參考線
label.autosave.comment=無法完全停用自動儲存。<a>工作原理</a>
label.category.n.a=不適用
label.category.unknown=未知
label.certificate.and=以及
label.certificate.expired=已過期
label.certificate.not.yet.valid=尚未生效
label.certificate.root=<根>
label.certificate.self.signed=自簽署
label.certificate.signed.by.untrusted.authority=由不受信任的機構簽署
label.certificate.untrusted.authority=不受信任的機構
label.certificate.will.be.saved=接受的憑證將被儲存在信任庫 {0} 中，預設密碼為 {1}
label.change.list.for.unlocked.files=\\   更改列表(&L):
label.choose.color.scheme.importer=選擇 {0}
label.choose.target.file=選擇目標檔案
label.choosebyname.no.matches.found=未找到符合
label.choosebyname.searching=正在搜尋…
label.chrome.command.line.options=命令行選項(&C):
label.continue.editing=繼續編輯
label.description=描述:
label.dont.show=不再顯示
label.downloading.cancelled=下載已取消
label.downloading.file.started=下載已開始
label.empty.file.name=<空檔名>
label.empty.text.attach.directories.with.right.click=通過右鍵點擊附加目錄
label.enable.debug.level=為日誌類別啟用 DEBUG 級別(每行一個)。<br>將 ''{0}'' 後綴追加到類別以啟用 TRACE 級別，或將 ''{1}'' 後綴追加到 ALL 級別。<br>追加 ''{2}'' 以將偵錯日誌寫入 \`idea.log\` 附近的單獨檔案中。<br>單獨的檔名包含縮短的記錄器名稱，例如直接在日誌中寫入的記錄器名稱。<br>新增 ''{0}:{2}'' 以設定日誌記錄級別和單獨的檔案。<br><br>
label.enter.group.name=輸入組名:
label.enter.new.abbreviation=輸入新縮寫:
label.enter.new.font.size.for.0=輸入 {0} 的新字號
label.extension=擴展(&E):
label.file.name=檔名:
label.font.name=字體:
label.font.size=大小:
label.generate.file.name=檔名(&F):
label.i.want.to.edit.choice=IDE 重啟前允許編輯:
label.icon.path=圖示(&I):
label.inactive.timeout.sec=秒
label.install.freemium.for.free.with.trial.or=使用免費版本，開始 {0} 天試用，或
label.install.freemium.for.free.without.trial.or=使用免費版本或
label.install.paid.with.trial.or=開始 {0} 天試用或
label.install.paid.without.trial=要享受該延伸模組的好處，
label.invalid.color=<無效>
label.line.column=[行] [:列]:
label.macro.recording.started=巨集錄製已開始…
label.maximum.version=最高版本:
label.milliseconds=毫秒
label.minimum.version=最低版本:
label.more.files=和其他{0, choice, 1#1 個檔案|2#{0} 個檔案}
label.name=名稱(&N):
label.new.version.will.be.available.after.restart=新版本將在重啟後可用
label.next.plugin.version.is=通過此更新，延伸模組將變為
label.no.actions.found=未找到動作
label.no.enabled.actions.found=未找到已啟用的動作
label.no.files.found=未找到檔案
label.no.matches.found=未找到符合
label.offset=偏移:
label.option.appearance=外觀: {0}
label.password.safe.password=密碼(&P)
label.password.safe.user=使用者(&U)
label.plugin=延伸模組:
label.plugin.0.downloads={0} 次下載
label.plugin.change.notes=更改說明
label.plugin.downloads=下載
label.plugin.freemium=免費增值
label.plugin.last.updated=上次更新
label.plugin.paid=付費
label.plugin.status=狀態
label.plugin.updated.0=已更新 {0}
label.plugin.vendor.email=電子郵件:
label.plugin.vendor.name=名稱:
label.project.files.location=專案位置(&L):
label.project.name=專案名稱(&A):
label.refactor.anyway=仍然重構
label.remote.sdk.helpers.path=幫助程序路徑:
label.remote.sdk.name=名稱(&N):
label.remote.sdk.python.interpreter.path=Python 解釋器路徑:
label.scope=作用域(&S):
label.scope.contains.files=作用域包含 {0} 個檔案，共 {1} 個
label.scope.editor.caret.position=位置: {0}
label.scope.pattern=模式(&P):
label.select.configuration.element=選擇樹中的組態元素以編輯其設定
label.show.block.cursor=顯示塊游標
label.show.line.numbers=顯示行號
label.show.status.bar.widget=顯示 {0}
label.show.whitespaces=顯示空格
label.smooth.scrolling.bezier.panel.updates=每秒繪製請求數: {0}
label.smooth.scrolling.duration=持續時間
label.ssl.certificate.details=憑證詳細資訊
label.ssl.certificate.remoteHost=伺服器地址:
label.start.search.in.background=在背景開始搜尋
label.text.antialiasing.scope.editor=編輯器:
label.text.antialiasing.scope.ide=IDE:
label.text.character.count={0} 個字元
label.text.code.completion.saved=自 {1} 以來，程式碼補全至少為您節省了 {0}的輸入時間(每個工作日約 {2})
label.text.html.center.drop.here.to.attach.br.as.a.root.directory.center.html=<html><center>拖放至此處<br/>以作為根目錄附加</center></html>
label.text.image=圖片:
label.text.opacity=不透明度:
label.text.path.to.profiles.ini="profiles.ini" 的路徑:
label.text.plugin.eap.license.not.required=EAP 版本不需要授權
label.text.plugin.no.license=無授權。
label.text.profile=使用者組態(&P):
label.text.put.stacktrace.here=在此放置一個堆疊追蹤:
label.text.quick.fixes.saved=自 {1} 以來，快速修復使您避免了 {0} 個可能的 bug (每個工作日約 {2} 個)
label.todo.filter.name=名稱:
label.todo.filters=篩選器:
label.todo.icon=圖示:
label.todo.multiline=將以下行中的縮排文本視為同一 TODO 的一部分
label.todo.pattern=模式:
label.todo.patterns=模式:
label.transparency.delay.ms=延遲(毫秒):
label.transparency.ratio=比例:
label.ui.filter=篩選:
label.ui.name=名稱:
label.ui.value=值:
label.valid.from=從:
label.valid.until=至:
label.version=版本: {0}
label.version.0.1.build.2={0} {1} 構建版本 {2}
label.version.any=<any>
label.welcome.to.0=歡迎來到 {0}
label.you.can.create.a.desktop.entry=<html>您可以建立桌面條目，以便從系統選單輕鬆啟動 $APP_NAME$ <br>並更好地進行桌面整合。<html>
laf.action.install.theme=獲取更多主題…
large.file.editor.name=大檔案編輯器
large.file.preview.notification=檔案太大({0})。正在顯示第一個 {1} 的唯讀預覽。
light.header.theme.name=帶淺色標題的淺色
light.theme.name=淺色
link.activate.subscription=啟用訂閱…
link.cancel=取消
link.change.icon=更改…
link.change.project.icon=選擇 SVG 檔案…
link.change.project.icon.description=SVG 檔案將儲存到 .idea 目錄。<br/>要共享專案圖示，請將其新增到儲存庫。
link.check=檢查
link.enable.required.plugin=啟用 {0}
link.enable.required.plugins=啟用延伸模組
link.get.more.themes=獲取更多主題…
link.hide.processes=隱藏程序({0})
link.install.required.plugins=安裝延伸模組
link.label.wizard.step.plugin.customize=自訂…
link.learn.more=了解詳情
link.more=更多…
link.required.plugins.settings=開啟設定
link.reset.icon=重設
link.reset.project.icon=重設
link.show.all.processes=全部顯示({0})
link.smooth.scrolling.play.curve.animation=<a>播放此曲線的動畫</a>
link.smooth.scrolling.stop.curve.animation=<a>停止此曲線的動畫</a>
list.item.temporary.file.0=<temporary file>{0}
listbox.customfiletype.keywords=關鍵字
loading.in.progress=<html><body style='text-align: center;padding-top:20px;'>正在載入…</body></html>
log.in.link.text=登入…
login.dialog.authorization.token.field=IDE 授權令牌
login.dialog.back.link=← 返回
login.dialog.check.token=檢查令牌
login.dialog.eap.info.link=關於 EAP
login.dialog.empty.username=已登入
login.dialog.external.providers.panel.text=使用外部提供商登入
login.dialog.jb.login=登入 JetBrains Account
login.dialog.link.copied=連結已複製
login.dialog.log.out=登出…
login.dialog.manage.account=管理帳戶
login.dialog.manual.login=使用瀏覽器登入 JetBrains Account
login.dialog.manual.login.link=使用令牌登入…
login.dialog.new.user.label=新用戶?
login.dialog.register.link=建立帳戶
login.dialog.separator.text=或使用以下方式登入:
login.dialog.session.expired=授權會話已過期。請再次啟動
login.dialog.simple.login=登入 JetBrains Account
login.dialog.start.using=開始
login.dialog.title=登入 {0}
login.dialog.trouble.default.message=無法完成授權過程。
login.dialog.trouble.no.link={0}<br>有關可能的解決方案，請參閱<a href="{1}">幫助文章</a>。<br>如需幫助，請<a href="{2}">聯繫技術支援團隊</a>。
login.dialog.trouble.unknown=<a href="{0}">複製連結</a>並在瀏覽器中開啟，以獲取 IDE 授權令牌。
login.dialog.trouble.with.redirect=登入到您的帳戶並複製 IDE 授權令牌。<br/>如果瀏覽器未開啟，則 <a href="{0}">複製連結</a>並手動開啟。
login.dialog.troubles.link=有問題嗎?
login.dialog.waiting.for.login=正在等待在瀏覽器中登入…
login.dialog.waiting.for.login.short=正在等待登入…
login.dialog.welcome.to.eap=歡迎來到 {0} EAP
login.dialog.wrong.token=授權令牌錯誤
login.dialog.you.are.logged=您已登入
low.disk.space.message=系統目錄分區({0})上的剩餘空間少於 50 MiB
low.disk.space.title=磁碟空間不足
low.memory.notification.action=組態
low.memory.notification.analyze.action=準備記憶體報告
low.memory.notification.error=IDE 可用記憶體不足。請考慮增大“{0}”設定的值。
low.memory.notification.title=記憶體不足
low.memory.notification.warning=IDE 記憶體不足，這可能會影響性能。請考慮增加堆大小。
mac.window.tabs.close.other.tabs=關閉其他頁籤
mac.window.tabs.close.tab=關閉頁籤
mac.window.tabs.close.title=點擊以關閉此頁籤。按住 Option 鍵點擊以關閉除此之外的所有頁籤
mac.window.tabs.move.tab=將頁籤移至新視窗
mac.window.tabs.show.all.tabs=顯示所有頁籤
macOS.light.theme.name=macOS 淺色
macos.shortcut.conflict.few={0} 快捷鍵與 macOS 系統快捷鍵衝突。
macos.shortcut.conflict.many={0} 和 {1} 快捷鍵與 macOS 系統快捷鍵衝突。
main.menu.combobox.disabled.description=在“進階”設定中啟用“將主選單與視窗標題合併”來管理當前的 UI 設定。
main.menu.combobox.label=主選單:
main.toolbar.menu.button=主選單
manage.repositories.dialog.title=管理儲存庫
meetnewui.toolwindow.button.finishSetup=完成安裝
meetnewui.toolwindow.clean=簡潔
meetnewui.toolwindow.compact=緊湊
meetnewui.toolwindow.density=密度:
meetnewui.toolwindow.description=在“設定 > 外觀與行為 > <a>新 UI</a>”中組態或停用新 UI。
meetnewui.toolwindow.system=系統
meetnewui.toolwindow.theme=主題:
meetnewui.toolwindow.title=組態新 UI
memory.snapshot.captured.action.text=在 {1} 中開啟 ''{0}''
memory.snapshot.captured.text=套件解除安裝失敗時捕獲記憶體快照
message.action.remove.system.assigned.shortcut=動作快捷鍵 {0} 已被分配給系統動作 ''{1}''。是否要移除此快捷鍵?
message.cannot.delete.0.1=無法刪除 ''{0}''，{1}
message.check.the.internet.connection.and=檢查互聯網連線並
message.connection.successful=連線成功
message.do.you.want.to.delete.0.1=是否要刪除“{0}”{1}?
message.link.refresh=重新整理
message.macro.exists=巨集 ''{0}'' 已存在。是否要覆蓋它?
message.module=模組 ''{0}''
message.module.file.has.an.older.format.do.you.want.to.convert.it=模組檔案為舊格式。是否要轉換?
message.modules=模組
message.move.modules.to.group=將 {0} 移至組 {1}
message.no.targets.available=在此上下文中沒有可用目標
message.occurrence.N.of.M=匹配項 {0}/{1}
message.path.to.fqn.has.been.copied=''{0}'' 已複製。
message.please.select.element.for.javadoc=選擇您想檢視其文檔的元素
message.project.will.be.saved.and.reopened.in.new.directory.based.format=專案將會儲存並以基於目錄的新格式重新開啟。確定要繼續嗎?
message.reference.to.fqn.has.been.copied=對 ''{0}'' 的參照已複製。
message.text.enter.url.to.check.connection=警告: 您的設定將被儲存。\\n輸入任意 URL 以檢查連線:
message.text.files.do.not.exist=<html><body>以下檔案不存在:<br>{0}相應的模組將不會轉換。是否要繼續?</body></html>
message.text.proxy.both.use.proxy.and.autodetect.proxy.set=代理: 同時設定了 'use proxy' 和 'autodetect proxy' 設定。應當只選擇其中一個選項。請重新組態。
message.text.proxy.passwords.were.cleared=已清除代理密碼。
message.text.unlock.read.only.files=<html><body>以下檔案為唯讀檔案。{0}將解鎖它們。<br>{1}</body></html>
message.the.path.0.does.not.exist.maybe.on.remote=路徑 {0} 不存在。\\n如果它位於可移動驅動器或網絡驅動器上，請確保該驅動器已連線。
message.there.are.no.available.schemes.to.import=沒有可供匯入的方案
message.this.functionality.is.not.available.during.indexing=索引編制期間此功能不可用
message.your.module.was.successfully.converted.br.old.version.was.saved.to.0=<html><body>您的模組已成功轉換。<br> 舊版本已儲存到 ''{0}''</body></html>
mixed.bag.installation=您的 {0} 安裝似乎已損壞，因為存在多個版本標記。當較新版本的歸檔被提取到包含現有安裝的目錄中時，通常就會發生這種情況。為避免出現崩潰，請從頭開始將 IDE 重新安裝到一個空目錄。
more.shortcuts.link.text.with.count=其他 {0}
name.invalid=無效
name.variable=在對話框中輸入的檔名
navigate.command.search.reference.progress.title=正在搜尋參照 ''{0}''
navigation.bar=導覽列
navigation.bar.item.sample=範例
new.changelist.make.active.checkbox=設為活動(&A)
new.dir.project.create=建立
new.dir.project.error.empty=專案路徑為空
new.dir.project.error.invalid=專案目錄路徑無效
new.file.popup.search.hint=搜尋檔案類型
new.plugin.manager.incompatible.deps.action=啟用所需{0, choice, 1#延伸模組|2#延伸模組}
new.plugin.manager.incompatible.deps.tooltip=未載入。所需{0, choice, 1#延伸模組|2#延伸模組} {1} {0, choice, 1#|2#}已停用。
no.charset.set.reason.charset.auto.detected.by.bom=字符集被 BOM 自動檢出
no.charset.set.reason.charset.auto.detected.from.content=字符集從內容中自動檢出
no.charset.set.reason.charset.hard.coded.in.file=字符集在檔案中硬編碼
no.charset.set.reason.disabled.for.binary.file=對二進制檔案停用
no.charset.set.reason.disabled.for.directory=對目錄停用
no.charset.set.reason.disabled.for.file.type=為 {0} 停用
no.disk.space.message=系統目錄分區({0})上的剩餘空間少於 1 MiB
no.disk.space.title=磁碟空間不足
no.information.available=無可用資訊
no.tip.of.the.day=<html><body>此功能目前尚無每日小技巧。</body></html>
node.call.hierarchy.N.usages=({0} 個用法)
node.default.package=<預設軟體套件>
node.hierarchy.invalid=[無效]
node.memberchooser.all.classes=所有類別
node.project.view.bad.link=無效的符號連結
node.projectview.external.libraries=外部庫
node.projectview.libraries=庫
node.projectview.library={0} 庫
node.structureview.invalid=<無效>
node.todo.group={0} {0,choice,0#項|1#項|2#項}
node.todo.items={0} {0, choice, 0#項|1#項|2#項}
node.todo.more.items=…更多…
node.todo.summary=在 {1} 個{1,choice,0#檔案|1#檔案|2#檔案}中找到 {0} 個 TODO {0,choice,0#條目|1#條目|2#條目}
notification.accessible.announce.prefix=通知
notification.action.load.paid.plugins.and.restart=啟用延伸模組並重啟
notification.action.unknown.macros.error.fix=修復
notification.cache.diagnostic.helper.text=已執行恢復步驟 {0}: ''{1}''
notification.cache.diagnostic.helper.title=IDE 修復
notification.cache.diagnostic.stop.text=現在一切正常
notification.configurable.display.name.notifications=通知
notification.content.cannot.find.keymap=找不到鍵映射“{0}”
notification.content.cannot.find.parent.keymap=找不到“{1}”的父鍵映射“{0}”
notification.content.color.scheme=使用者配色方案 ''{0}'' 指向不正確或不存在的基本方案 {1}，因此不會顯示
notification.content.input.method.disabler=IDE 執行時啟用了可能導致凍結的輸入方法。如果您並不使用這些輸入方法，不妨停用它們。
notification.content.internal\\ error=內部錯誤
notification.content.jcef.applySettings=要將新設定應用於 JCEF 瀏覽器，需要重啟 IDE
notification.content.jcef.browser.suspended.text=嵌入式瀏覽器被掛起。
notification.content.jcef.enable.browser.button=啟用瀏覽器…
notification.content.jcef.enable.browser.dialog.message=<html>嵌入式瀏覽器被掛起。系統限制在啟用沙盒的情況下執行嵌入式瀏覽器。必須安裝相應的 AppArmor 組態檔案才能在沙盒模式下啟動瀏覽器。<p><p><a href="https://youtrack.jetbrains.com/articles/JBR-A-11">了解詳情…</a></html>
notification.content.jcef.enable.browser.dialog.title=啟用嵌入式瀏覽器
notification.content.jcef.failed.to.install.apparmor.profile=無法安裝 AppArmor 組態檔案
notification.content.jcef.gpu.process.failed.error.message=<html>JCEF GPU 程序多次失敗。<br>嵌入式瀏覽器被掛起</html>
notification.content.jcef.gpucrash.action.disable=停用 GPU 並重啟
notification.content.jcef.gpucrash.action.restart=重啟
notification.content.jcef.gpucrash.message=GPU 程序重啟次數過多，似乎不穩定。請嘗試重啟 {0} 或完全停用 GPU 加速。
notification.content.jcef.gpucrash.title=GPU 程序(JCEF)重啟次數過多
notification.content.jcef.measureFPS=按任意鍵或切換焦點即可停止
notification.content.jcef.super.user.error.message=<html>IDE 在超級使用者下執行。<br>嵌入式瀏覽器被掛起</html>
notification.content.jcef.unprivileged.userns.restricted.action.add.apparmor.profile=安裝組態檔案…
notification.content.jcef.unprivileged.userns.restricted.action.disable.sandbox=停用沙盒
notification.content.jcef.unprivileged.userns.restricted.action.learn.more=了解詳情…
notification.content.jcef.unprivileged.userns.restricted.install.apparmor.profile.prompt=為 %s 安裝 AppArmor 組態檔案
notification.content.jcef.unprivileged.userns.restricted.message=系統限制在啟用沙盒的情況下執行嵌入式瀏覽器。必須安裝相應的 AppArmor 組態檔案才能在沙盒模式下啟動瀏覽器。
notification.content.jcef.unprivileged.userns.restricted.title=嵌入式瀏覽器已掛起
notification.content.jit.compiler.disabled=JVM JIT 編譯器已被停用。重啟 IDE 以重新啟用 JIT。<br><br>如果再次看到此訊息，請嘗試使用 <code>-XX:ReservedCodeCacheSize</code> 選項增加 CodeCache 的大小。<br><br>有關 JVM 選項的更多資訊，請參閱<a href="help">此幫助主題</a>。
notification.content.keymap.successfully.activated=按鍵映射 {0} 成功啟用
notification.content.keymap.successfully.installed=鍵映射 {0} 成功安裝
notification.content.mandatory.bom.br={0,choice,1#此檔案具有|2#這些檔案具有}強制性 BOM:<br/>{1}
notification.content.more.shortcut.conflict={0} 和其他 {1} 個快捷鍵與 macOS 快捷鍵衝突。請修改這些快捷鍵或更改 macOS 系統設定。
notification.content.paid.plugins.not.loaded=必須重新啟動應用程式才能啟用以下延伸模組: <br>
notification.content.please.restart.0=請重啟 {0}</p>{1}
notification.content.shortcut.conflicts.with.macos.shortcut.modify={0} 快捷鍵與 macOS 快捷鍵 {1} 衝突。請修改此快捷鍵或更改 macOS 系統設定。
notification.content.solarized.color.scheme.deprecation.enable=您正在使用即將刪除的 {0} 捆綁配色方案。請考慮改為啟用 {1} 主題
notification.content.solarized.color.scheme.deprecation.install=您正在使用即將刪除的 {0} 捆綁配色方案。請考慮切換到 {1} 延伸模組
notification.content.unable.to.save.project.files=無法儲存專案檔案。請確保專案檔案可寫入，並且您具備修改權限。<a href="">再次嘗試儲存專案</a>。
notification.content.unknown.macro.error={0} 未定義。
notification.content.unknown.macros.error={0} 未定義。
notification.content.unknown.macros.error.description=路徑變數用於取代專案檔案中的絕對路徑，並允許專案檔案在版本控制系統中共享。<br>當前專案設定的某些檔案包含未知的路徑變數，{0} 無法還原這些路徑。
notification.content.updated.plugin.to.version=已將 {0} 延伸模組更新到版本 {1}
notification.content.updated.plugins=已更新 {0} 個延伸模組
notification.group.advertiser.try.ultimate.installed=安裝完成
notification.group.advertiser.try.ultimate.installed.content=您的設定將被遷移。{0} 仍將可用。
notification.group.advertiser.try.ultimate.installed.title={0} 已安裝
notification.group.browser.config.problems=瀏覽器組態問題
notification.group.built.in.server=內建 HTTP 伺服器無法啟動
notification.group.cache.recovery=已執行快取恢復步驟
notification.group.essential-highlighting.mode=基本醒目提示模式已啟用
notification.group.failed.to.generate.module.descriptors=無法生成模組檔案描述子
notification.group.failed.to.remove.bom=無法移除 BOM
notification.group.ide.and.plugin.updates=IDE 和延伸模組更新可用
notification.group.ide.errors=IDE 錯誤
notification.group.ide.update.results=IDE 更新已安裝
notification.group.language.plugin=推薦的語言延伸模組可用
notification.group.leftover.directories=找到了殘留的 IDE 目錄
notification.group.load.error=無法載入設定
notification.group.low.memory=檢測到記憶體不足
notification.group.missing.keymap=缺少快捷鍵
notification.group.paid.plugins=付費延伸模組未載入
notification.group.password.safe=密碼存儲不可用
notification.group.plugin.error=延伸模組載入失敗
notification.group.plugin.updates=延伸模組已安裝或更新
notification.group.plugins.suggestion=有可用的延伸模組建議
notification.group.power.save.mode=已啟用省電模式
notification.group.project.settings=無法儲存專案
notification.group.required.plugins=未載入所需的延伸模組
notification.group.settings.error=無法儲存設定
notification.group.system.clipboard=系統剪貼簿不可用
notification.group.system.health=檢測到系統執行狀況問題
notification.group.system.messages=系統訊息
notification.group.too.many.carets=已達到編輯器文字游標的最大數量
notification.manager.content.height.linebreak=<br>\\n
notification.manager.content.height.word=內容
notification.manager.merge.n.more=其他 {0} 個
notification.manager.merge.n.more.from=來自 {1} 的其他 {0} 個
notification.settings.action.text=設定…
notification.title.activated.from.command.line=已從命令行啟用
notification.title.browser.config.problem=瀏覽器組態問題
notification.title.cannot.open=無法開啟 URL
notification.title.desktop.entry.created=已建立桌面條目
notification.title.desktop.entry.creation.failed=桌面條目建立失敗
notification.title.enable.action.solarized.color.scheme.deprecation=啟用 {0} 主題
notification.title.incompatible.color.scheme=不相容的配色方案
notification.title.input.method.disabler=輸入方法停用程序
notification.title.install.action.solarized.color.scheme.deprecation=安裝 Marketplace 中的 Solarized Themes 延伸模組
notification.title.jcef.measureFPS=OSR JCEF FPS Meter
notification.title.jcef.proxyChanged=代理設定已更改
notification.title.jit.compiler.disabled=重啟 IDE 避免減速
notification.title.paid.plugins.not.loaded=延伸模組未載入
notification.title.required.plugins.not.loaded=尚未載入必需延伸模組
notification.title.shortcuts.conflicts=快捷鍵衝突
notification.title.solarized.color.scheme.deprecation=配色方案棄用
notification.title.unknown.macros.error=載入錯誤: 未定義的路徑變數
notification.title.was.unable.to.remove.bom.in=無法移除 {0} {0,choice,1#檔案|2#檔案}中的 BOM
notifications.collapse.balloon.title=其他 {0} 個{1}
notifications.collapse.balloon.title.suggestion={0,choice,1#建議|1<建議}
notifications.collapse.balloon.title.timeline={0,choice,1#通知|1<通知}
notifications.configurable.announcing.comment=如果上一個輸出具有較低的優先級，則通知將中斷該輸出
notifications.configurable.announcing.title=使用螢幕閱讀器宣布:
notifications.configurable.announcing.value.high=具有高優先級
notifications.configurable.announcing.value.interrupting=正在中斷當前輸出
notifications.configurable.announcing.value.medium=具有中等優先級
notifications.configurable.announcing.value.not.interrupting=當前輸出完成後
notifications.configurable.announcing.value.off=關
notifications.configurable.column.group=組
notifications.configurable.column.log=日誌
notifications.configurable.column.popup=彈出視窗類型:
notifications.configurable.column.read.aloud=大聲朗讀
notifications.configurable.column.toolwindow=在工具視窗中顯示
notifications.configurable.display.balloon.notifications=顯示氣球通知
notifications.configurable.do.not.ask.project.title=此專案
notifications.configurable.do.not.ask.title=不再詢問通知:
notifications.configurable.enable.system.notifications=啟用系統通知
notifications.configurable.no.notifications.configured=未組態通知
notifications.configurable.play.sound=播放聲音
notifications.toolwindow.dont.show.again=不再顯示
notifications.toolwindow.dont.show.again.for.this.project=不再為此專案顯示
notifications.toolwindow.empty.text.first.line=建議、事件，
notifications.toolwindow.empty.text.second.line=以及錯誤將出現在這裡
notifications.toolwindow.remind.tomorrow=明天提醒我
notifications.toolwindow.suggestions=建議
notifications.toolwindow.timeline=時間線
notifications.toolwindow.timeline.clear.all=全部清除
old.dirs.action.progress=正在尋找殘留的 IDE 存儲目錄…
old.dirs.column.name=目錄
old.dirs.column.size=大小
old.dirs.column.updated=上次使用
old.dirs.delete.error=無法刪除目錄
old.dirs.delete.progress=正在刪除目錄…
old.dirs.dialog.delete.button=刪除 {0} 個{0,choice,0#目錄|1#目錄|2#目錄}
old.dirs.dialog.text=<html>安裝在您電腦上的其他 IDE 版本使用下面列出的目錄來存儲特定於版本的<br>設定、快取和延伸模組。刪除它們可以釋放空間，並且不影響<i>此版本</i>的穩定性。<br><b>警告</b>: 不要刪除仍在使用的版本的目錄!<br><br>選擇要刪除的目錄:</html>
old.dirs.dialog.title=刪除殘留的 IDE 存儲目錄
old.dirs.not.found.notification.text=沒有找到殘留的 IDE 存儲目錄。
old.dirs.notification.action=檢視並刪除…
old.dirs.notification.text=找到殘留的 IDE 存儲目錄。
only.at.line.start=僅在行首(\\\\&O)
open.in.0=在 {0} 中開啟
open.in.browser=在瀏覽器中開啟(_B)
open.selected.file.in.browser=在瀏覽器中開啟所選檔案
open.url.in.0=在 {0} 中開啟 URL
open.url.in.browser.tooltip=在瀏覽器中開啟
option.hide.tool.window.bars=隱藏工具視窗列
option.is.overridden.by.jvm.property=此選項已由 JVM 屬性覆寫:“{0}”
option.show.tips.on.startup=啟動時顯示每日小技巧
overridden.by.jvm.property=已被 JVM 屬性 ''{0}'' 覆寫
package.0.installed.successfully=已成功安裝軟體套件 ''{0}''
package.installed.successfully=已成功安裝軟體套件
package.successfully.uninstalled=已成功解除安裝軟體套件 ''{0}''
package.successfully.upgraded=已成功升級軟體套件 {0}
packages.settings.latest.version=最新版本
packages.settings.loading=正在載入軟體套件列表
packages.settings.package=軟體套件
packages.settings.version=版本
packages.successfully.uninstalled=已成功解除安裝軟體套件
packages.title=軟體套件
path.macro.ignored.variables=忽略的變數:
path.macro.use.semicolon=使用 ; 分隔忽略的變數
please.edit.repository.url=請編輯儲存庫 URL
please.input.repository.url=請輸入儲存庫 URL
plugin.advertiser.free.trial.action=30 天免費試用
plugin.advertiser.product.call.to.action={0}: {1}
plugin.available.in.commercial.ide.text=此延伸模組僅適用於 {0} 訂閱
plugin.description.vim.editor=Vim 編輯器仿真
plugin.descriptor.aws.toolkit=建立、測試和偵錯使用 AWS 無伺服器應用程式模型建置的無伺服器應用程式
plugin.group.cloud.support=雲支援
plugin.group.editor=編輯器
plugin.group.tools.integration=工具整合
plugin.has.ultimate.features.text=此延伸模組可以通過 {0} 提供更多功能
plugin.info.not.available=不適用
plugin.info.unknown=未知
plugin.installed.ide.restart.required.message=延伸模組“{0}”已安裝。{1} {2} 以在延伸模組中套用更改?
plugin.invalid.signature.result=''{0}'' 延伸模組的數位簽章驗證失敗並顯示以下訊息: ''{1}''。
plugin.manager.action.label.sort.by=排序依據: {0}
plugin.manager.action.label.sort.by.1=排序依據
plugin.manager.custom.certificates=管理延伸模組憑證…
plugin.manager.dependencies.detected.message=''{0}'' 延伸模組需要安裝 {1}。
plugin.manager.dependencies.detected.title=安裝必需延伸模組
plugin.manager.incompatible.tooltip=延伸模組與當前 {0} 安裝不相容
plugin.manager.installed.panel.accessible.name=已安裝
plugin.manager.installed.tooltip=延伸模組將在重啟後啟用
plugin.manager.main.suggest.to.enable.message.part1=更新的延伸模組 ''{0}'' 已停用。
plugin.manager.main.suggest.to.enable.message.part2=更新的延伸模組 {0} 已停用。
plugin.manager.main.suggest.to.enable.message.part3=更新的依賴於停用內容的{0,choice,1#延伸模組|2#延伸模組}
plugin.manager.main.suggest.to.enable.message.part4=延伸模組 ''{0}''。
plugin.manager.main.suggest.to.enable.message.part5=延伸模組 {0}。
plugin.manager.main.suggest.to.enable.message.part6=被停用的延伸模組和相依停用的延伸模組在重啟後不會被啟用。
plugin.manager.main.suggest.to.enable.message.part7=停用的延伸模組在重啟後不會被啟用。
plugin.manager.main.suggest.to.enable.message.part8=是否想要啟用更新的{0,choice, 1#延伸模組|2#延伸模組}
plugin.manager.main.suggest.to.enable.message.part9=是否想要啟用延伸模組{0,choice,1#相依項|2#相依項}
plugin.manager.marketplace.panel.accessible.name=Marketplace
plugin.manager.new.version.tooltip=從版本 {0} 更新安裝的延伸模組
plugin.manager.obsolete.plugins.detected.title=停用衝突的延伸模組
plugin.manager.optional.dependencies.detected.message=建議安裝包含延伸模組 ''{0}'' 的 {1}。
plugin.manager.optional.dependencies.detected.title=安裝推薦的延伸模組
plugin.manager.options.command=輸入 / 以檢視選項
plugin.manager.plugins.auto.update.description=啟用延伸模組自動更新以始終擁有其最新版本。
plugin.manager.plugins.auto.update.title=延伸模組自動更新
plugin.manager.refresh=重新整理
plugin.manager.replace.plugin.0.by.plugin.1=<html>''{1}'' 延伸模組旨在替代安裝的 ''{0}'' 延伸模組。<br>停用“{0}”延伸模組以避免衝突?</html>
plugin.manager.repositories=管理延伸模組儲存庫…
plugin.manager.search.accessible.name=搜尋延伸模組
plugin.manager.search.filters.popup.accessible.name=搜尋篩選器
plugin.manager.tab.installed=已安裝
plugin.manager.tab.marketplace=Marketplace
plugin.manager.tooltip=從磁碟管理儲存庫、組態代理或安裝延伸模組
plugin.manager.uninstalled.tooltip=延伸模組已被移除；重啟後將套用更改
plugin.manager.update.all=全部更新
plugin.manager.update.available.tooltip=有更新版本的延伸模組可用
plugin.manager.updated.tooltip=延伸模組已升級到最新版本；重啟後將套用更改
plugin.message.plugin.only.supported.in=此延伸模組僅在 {0} 中可用。
plugin.settings.link.title=延伸模組設定…
plugin.signature.checker.no=取消安裝
plugin.signature.checker.revoked.cert=<html><body>''{0}'' 延伸模組已撤消 JetBrains 憑證</body></html>
plugin.signature.checker.title=延伸模組安全警告
plugin.signature.checker.yes=忽略並繼續
plugin.signature.not.signed=<html><body>''{0}'' 延伸模組未進行數位簽章，無法驗證其可靠性。安裝或更新未簽名的延伸模組可能會將您的系統置於風險之中。<br/><br/>延伸模組詳細資訊: ID: {1}，版本: {2} {3}</body></html>
plugin.status.bundled=已捆綁
plugin.status.installed=已安裝
plugin.status.not.allowed=已阻止
plugin.status.not.allowed.but.enabled=停用!
plugin.status.not.allowed.tooltip=您的組織未批准此延伸模組
plugin.status.not.allowed.tooltip.but.enabled=請停用此延伸模組，因為它未經您的組織批准
plugin.status.not.specified=(未指定)
plugin.update.dialog.total.label=總計: {0}
plugin.updater.downloading=正在下載延伸模組
plugin.updater.error.cant.find.plugin.version=在儲存庫響應中找不到延伸模組版本
plugin.updater.error.check.failed=延伸模組更新檢查失敗
plugin.updater.error.custom.repository=檢查自訂延伸模組儲存庫 {0} 失敗
plugin.updater.error.unexpected.repository.response=意外延伸模組儲存庫響應
plugin.updater.install=安裝
plugin.updater.not.installed=未安裝延伸模組更新
plugin.updater.not.installed.misc=未安裝延伸模組更新: {0}
plugin.updater.not.installed.see.log.action=請參閱日誌了解更多資訊
plugin.updater.notification.message={1} 延伸模組有可用的新版本 {0}
plugin.vendor.info.label=供應商: {0}
plugin.vendor.non.trader.label=非貿易商
plugin.vendor.non.trader.status=根據指令(EU) 2019/2161 的定義，此供應商已將自己標識為非貿易商。源自歐盟消費者保護法的消費者權利將不適用。
plugin.vendor.trader.label=貿易商
plugin.vendor.trader.status=此供應商已根據指令(EU) 2019/2161 的定義將自己標識為貿易商。源自歐盟消費者保護法的消費者權利將適用。
plugin.verified.organization=已驗證的組織
plugin.version.bundled=已捆綁
plugins.advertiser.action.configure.plugins=組態延伸模組…
plugins.advertiser.action.enable.plugin=啟用延伸模組
plugins.advertiser.action.enable.plugins=啟用延伸模組…
plugins.advertiser.action.ignore.extension=忽略擴展
plugins.advertiser.action.ignore.ultimate=關閉
plugins.advertiser.action.ignore.unknown.feature=不再建議
plugins.advertiser.action.ignore.unknown.features=不再建議
plugins.advertiser.action.install.plugin.name=安裝 {0} 延伸模組
plugins.advertiser.action.install.plugins=安裝延伸模組
plugins.advertiser.action.try.ultimate=試用 {0}
plugins.advertiser.check.progress=正在檢查專案的推薦延伸模組
plugins.advertiser.extensions.supported.in.ides=<hyperlink>其他 JetBrains IDE</hyperlink> 中支援 {0} 檔案
plugins.advertiser.extensions.supported.in.ultimate={1} 支援 {0} 檔案
plugins.advertiser.feature.dependency=相依項
plugins.advertiser.framework.supported.in.ultimate={1} 支援 {0} 組態檔案
plugins.advertiser.learn.more=了解詳情
plugins.advertiser.missing.feature=支援 {1} ''{2}'' 的{0,choice,1#延伸模組|2#延伸模組} {4} {0,choice,1#當前|2#當前}{3,choice,0#已停用|1#尚未安裝}。
plugins.advertiser.missing.features=支援功能({1})的{0,choice,1#延伸模組|2#延伸模組} {3} {0,choice,1#當前|2#當前}{2,choice,0#已停用|1#尚未安裝}。
plugins.advertiser.missing.features.dependency=推薦的{0,choice,1#延伸模組|2#延伸模組} {1} 可用。
plugins.advertiser.no.suggested.plugins=找不到推薦的延伸模組
plugins.advertiser.plugins.file.handler.found=找到支援 {0} 的延伸模組。
plugins.advertiser.plugins.found=已找到支援 {0} 檔案的延伸模組。
plugins.advertiser.plugins.suggestions.text=已找到所選相依項的延伸模組。
plugins.advertiser.plugins.suggestions.title=延伸模組建議
plugins.advertiser.task.searching.for.plugins=在儲存庫中搜尋延伸模組
plugins.advertiser.try.ultimate.cancel.button=取消
plugins.advertiser.try.ultimate.could.not.download=無法從 {1} 下載 {0} 的發行版。網絡錯誤。
plugins.advertiser.try.ultimate.could.not.install=無法安裝 {0}。出錯了。
plugins.advertiser.try.ultimate.could.not.open=無法開啟 {0}。出錯了。
plugins.advertiser.try.ultimate.dialog.open.website=開啟網站
plugins.advertiser.try.ultimate.dialog.title=試用 {0}
plugins.advertiser.try.ultimate.dialog.try.again=再次試用
plugins.advertiser.try.ultimate.download=正在下載…
plugins.advertiser.try.ultimate.download.started.balloon={0} 正在下載並將自動安裝。
plugins.advertiser.try.ultimate.install=正在安裝…
plugins.advertiser.try.ultimate.opening=正在開啟 {0}…
plugins.advertiser.try.ultimate.upgrade=正在升級到 {0}…
plugins.advertiser.ultimate.features.detected=檢測到 IntelliJ IDEA Ultimate {0} 涵蓋的功能
plugins.auto.disabled.notification.content={0} 和 {1} 延伸模組已停用。
plugins.auto.disabled.notification.title=相依延伸模組已停用
plugins.auto.enabled.notification.content={0} 和 {1} 延伸模組已啟用。
plugins.auto.enabled.notification.title=必需延伸模組已啟用
plugins.auto.switch.action.name=撤消
plugins.changed.notification.content=延伸模組列表已更改。請重啟 {0} 以啟用更改。
plugins.changed.notification.title=需要重啟
plugins.configurable.InstalledSearchOption.Bundled=已捆綁
plugins.configurable.InstalledSearchOption.Disabled=停用
plugins.configurable.InstalledSearchOption.Downloaded=已下載
plugins.configurable.InstalledSearchOption.Enabled=啟用
plugins.configurable.InstalledSearchOption.Invalid=無效
plugins.configurable.InstalledSearchOption.NeedUpdate=可用的更新
plugins.configurable.SortBySearchOption.Downloads=下載
plugins.configurable.SortBySearchOption.Name=名稱
plugins.configurable.SortBySearchOption.Rating=評分
plugins.configurable.SortBySearchOption.Relevance=相關性
plugins.configurable.SortBySearchOption.Updated=已更新
plugins.configurable.activate.trial.for.full.access=購買授權
plugins.configurable.additional.info.tab.name=其他資訊
plugins.configurable.bugtracker.url=問題追蹤器
plugins.configurable.bundled.updates=捆綁的延伸模組更新
plugins.configurable.buy.the.license=購買授權
plugins.configurable.buy.the.license.from.0=購買授權，價格低至 {0}
plugins.configurable.check.internet=檢查互聯網連線。
plugins.configurable.choose.update.checkbox.accessible.name=更新
plugins.configurable.disable=停用
plugins.configurable.disable.all=全部停用
plugins.configurable.disable.all.downloaded=停用所有下載的延伸模組
plugins.configurable.disabled=已停用
plugins.configurable.documentation.url=文檔
plugins.configurable.downloaded=已下載
plugins.configurable.downloads.0=下載量: {0}
plugins.configurable.enable=啟用
plugins.configurable.enable.all=全部啟用
plugins.configurable.enable.all.downloaded=啟用所有下載的延伸模組
plugins.configurable.enable.checkbox.accessible.name=已啟用
plugins.configurable.enabled=已啟用
plugins.configurable.forum.url=論壇頁面
plugins.configurable.install=安裝
plugins.configurable.installed=已安裝
plugins.configurable.installing=正在安裝
plugins.configurable.license.expired=授權已過期。
plugins.configurable.license.expires.in.0.days=授權將於 {0} 天後到期。
plugins.configurable.license.is.active=授權有效。
plugins.configurable.license.is.active.until.0=授權有效期至 {0}。
plugins.configurable.license.url=授權
plugins.configurable.list.component.accessible.description.0.downloads={0} 次下載
plugins.configurable.list.component.accessible.description.0.stars={0} 顆星
plugins.configurable.list.component.accessible.description.install.available=可供安裝
plugins.configurable.list.component.accessible.description.restart.pending=待處理的 IDE 重啟
plugins.configurable.list.component.accessible.description.update.available=可用的更新
plugins.configurable.marketplace.plugins.not.loaded=未載入 Marketplace 延伸模組。
plugins.configurable.new.and.updated=新增和更新
plugins.configurable.not.allowed=您的組織未批准此延伸模組
plugins.configurable.notes.empty.text=很遺憾，{0} 未留下任何更新說明。
plugins.configurable.notes.empty.text.default.vendor=供應商
plugins.configurable.nothing.found=找不到任何內容。
plugins.configurable.one.plugin.details=選擇一個延伸模組以預覽延伸模組詳細資訊。
plugins.configurable.other.bundled=其他工具
plugins.configurable.overview.tab.name=概覽
plugins.configurable.plugin.details=選擇延伸模組以預覽詳細資訊
plugins.configurable.plugin.details.page.accessible.name=延伸模組詳細資訊
plugins.configurable.plugin.details.page.accessible.name.0={0} 詳細資訊
plugins.configurable.plugin.details.tags.panel.accessible.name=標記
plugins.configurable.plugin.feedback=<a href='showFeedback'>分享有關該延伸模組的意見反應</a>，幫助我們進行改進
plugins.configurable.plugin.homepage.link=延伸模組首頁
plugins.configurable.plugin.installing.failed=延伸模組“{0}”下載或安裝失敗
plugins.configurable.plugin.installing.success=延伸模組 {0} 已成功安裝
plugins.configurable.plugin.unavailable.for.platform=延伸模組對 {0} 不可用
plugins.configurable.rate.0=評分: {0}
plugins.configurable.release.date.0=發佈日期: {0}
plugins.configurable.report.marketplace.plugin=舉報延伸模組
plugins.configurable.repository.0=儲存庫: {0}
plugins.configurable.required.plugins.0=相依項:\\n{0}
plugins.configurable.restart.ide.button=重啟 IDE
plugins.configurable.reviews.tab.name=評價
plugins.configurable.search.in.marketplace=在 Marketplace 中搜尋
plugins.configurable.search.options=搜尋選項
plugins.configurable.search.result.0.plugins.found.in.1=在 {1} 中找到了 {0} 個{0, choice, 0#延伸模組|1#延伸模組|2#延伸模組}。
plugins.configurable.search.result.not.loaded=未載入搜尋結果。
plugins.configurable.several.plugins=已選擇多個延伸模組。
plugins.configurable.show=顯示
plugins.configurable.show.all=全部顯示
plugins.configurable.size.0=大小: {0}
plugins.configurable.sort.by=排序依據
plugins.configurable.source.code=原始碼
plugins.configurable.staff.picks=員工選擇
plugins.configurable.suggested=推薦
plugins.configurable.suggested.features.dependency=建議使用此延伸模組，因為您的專案使用了 {0} 庫
plugins.configurable.suggested.features.executable=建議使用此延伸模組，因為您已經安裝了 {0}
plugins.configurable.title.with.count={0} (已啟用 {1}/{2})
plugins.configurable.top.downloads=熱門下載
plugins.configurable.top.rated=最受好評
plugins.configurable.trial.expires.in.0.days=試用將於 {0} 天後到期。
plugins.configurable.unavailable.for.platform=不可用
plugins.configurable.uninstall=解除安裝
plugins.configurable.uninstall.bundled.update=移除更新
plugins.configurable.uninstalled=已解除安裝
plugins.configurable.update.button=更新
plugins.configurable.version.0=版本: {0}
plugins.configurable.whats.new.tab.name=最新變化
plugins.new.review.action=撰寫評價
plugins.progress.loading.plugin.title=正在載入延伸模組 {0}
plugins.progress.loading.plugins.for.current.project.title=正在載入延伸模組 
plugins.progress.unloading.plugin.title=正在移除延伸模組 {0}
plugins.progress.unloading.plugins.for.current.project.title=正在上傳 ''{0}'' 的延伸模組
plugins.reloaded.successfully={0} 成功重新載入
plugins.review.action.copy.link.text=複製連結
plugins.review.note=JetBrains 不會核實評價。
plugins.review.note.link=了解詳情
plugins.review.panel.empty.text=目前尚無評價。
plugins.review.panel.next.page.button=展開
popup.action.item.toggleable.checked.accessible.description=已檢查
popup.action.item.toggleable.not.checked.accessible.description=未檢查
popup.content.action.not.available.while.updating.indices=''{0}'' 在 {1} 更新索引期間不可用
popup.content.actions.not.available.while.updating.indices=在 {1} 更新索引期間 {0} 不可用
popup.content.none.of.following.actions.are.available.while.updating.indices=當 {0} 更新索引時，以下動作均不可用: {1}
popup.content.this.action.not.available.while.updating.indices=當 {0} 更新索引時，此動作不可用
popup.license.button.non.commercial.usage=管理授權…
popup.list.item.renderer.next.step.label.accessible.name=子選單
popup.new.element.empty.text.1=找不到檔案類型。
popup.new.element.empty.text.2=使用任意副檔名
popup.new.element.empty.text.3=建立新檔案
popup.new.element.list.accessible.name=檔案類型
popup.text.non.commercial.usage=<b>僅限非商業用途</b><br><br>使用您當前的授權，您可以:<br><ul><li>僅出於非商業目的進行開發</li><li>隨時切換到試用版或付費授權</li></ul><a href="https://www.jetbrains.com/legal/docs/toolbox/license_non-commercial/">非商業用途協議</a><br><br><a href="{0}">方案和定價</a>
popup.title.add.group.options=新增{0}選項
popup.title.add.run.options=新增執行選項
popup.title.add.tags=新增標記
popup.title.edit.shortcuts=編輯快捷鍵
popup.title.import.scheme=匯入方案
popup.title.in.editor.mode=在編輯器模式下
popup.title.maintenance=維護
popup.title.notification.display.type=通知顯示類型
popup.title.open.project=開啟專案
popup.title.play.saved.macros=播放儲存的巨集
popup.title.switch=切換
power.save.mode.disable.action.title=停用省電模式
power.save.mode.on.notification.content=程式碼洞察和背景任務已停用。
power.save.mode.on.notification.title=省電模式已開啟
preferred.editor.color.scheme.dark.header=用於深色作業系統
preferred.editor.color.scheme.description=選擇自動檢測模式的首選編輯器配色方案
preferred.editor.color.scheme.light.header=用於淺色作業系統
preferred.editor.color.scheme.text=首選編輯器配色方案
preferred.theme.and.editor.color.scheme.description=選擇自動檢測模式的首選主題和編輯器配色方案
preferred.theme.and.editor.color.scheme.text=首選主題和編輯器配色方案
preferred.theme.autodetect.selector=與作業系統同步
preferred.theme.dark.header=用於深色作業系統
preferred.theme.description=為自動檢測模式選擇首選主題
preferred.theme.light.header=用於淺色作業系統
preferred.theme.text=首選主題
presentation.assistant.configurable.alignment.bottom.center=底部居中
presentation.assistant.configurable.alignment.bottom.left=左下
presentation.assistant.configurable.alignment.bottom.right=右下
presentation.assistant.configurable.alignment.top.center=頂部居中
presentation.assistant.configurable.alignment.top.left=左上
presentation.assistant.configurable.alignment.top.right=右上
presentation.assistant.configurable.description=描述:
presentation.assistant.configurable.duration=顯示:
presentation.assistant.configurable.duration.seconds=秒發送保持活動的訊息
presentation.assistant.configurable.font.size=字體大小:
presentation.assistant.configurable.keymap.additional=其他:
presentation.assistant.configurable.keymap.group=按鍵映射
presentation.assistant.configurable.keymap.label=標籤:
presentation.assistant.configurable.keymap.mac=macOS
presentation.assistant.configurable.keymap.main=主:
presentation.assistant.configurable.keymap.win=Windows
presentation.assistant.configurable.keymap.win.label=Win/Linux
presentation.assistant.configurable.margin=邊距:
presentation.assistant.configurable.name=Presentation Assistant
presentation.assistant.configurable.popup.position=位置:
presentation.assistant.configurable.popup.size=彈出視窗大小:
presentation.assistant.configurable.size.large=大
presentation.assistant.configurable.size.medium=中
presentation.assistant.configurable.size.small=小
presentation.assistant.configurable.theme=主題:
presentation.assistant.configurable.theme.bright=明亮
presentation.assistant.configurable.theme.pale=暗淡
presentation.assistant.configurable.toggle=在彈出視窗中顯示動作名稱和快捷方式
presentation.assistant.notification=Presentation Assistant
presentation.assistant.notification.action.hide=不顯示 macOS 快捷方式
presentation.assistant.notification.action.install=安裝延伸模組
presentation.assistant.notification.content=要顯示 macOS 的快捷方式，您需要安裝 macOS Keymap 延伸模組
presentation.assistant.notification.title=macOS 的快捷方式未顯示
presentation.assistant.quick.settings.ad=拖動彈出視窗可自訂位置
presentation.assistant.quick.settings.position.group=位置
presentation.assistant.quick.settings.settings=設定…
presentation.assistant.quick.settings.size.group=大小
presentation.assistant.quick.settings.theme.group=主題
presentation.assistant.settings=Presentation Assistant
presentation.mode.fon.size=字體大小:
presentation.mode.ide.scale=縮放:
presentation.mode.ide.scale.out.of.range.number.message.format=指定一個介於 {0}% 到 {1}% 之間的值
presentation.mode.ide.scale.wrong.number.message=指定正整數
press.0.to.assign.a.shortcut=按 {0} 分配快捷鍵
press.copy.key.to.copy.system.information.to.clipboard=按 Copy 鍵將系統資訊複製到剪貼簿
product.and.plugin={0} 和 {1} 延伸模組
progress.closing.project=正在關閉專案…
progress.connecting.to.plugin.manager=正在連線到 {0}
progress.counting.files=正在進行檔案計數…
progress.creating.directory=正在建立目錄 {0}{1}{2}
progress.creating.file=正在建立檔案 {0}{1}{2}
progress.creating.package=正在建立軟體套件 {0}。{1}
progress.deleting=正在刪除
progress.deleting.class=正在刪除類別 {0}
progress.download.plugins=下載延伸模組
progress.downloading.available.plugins=正在下載可用延伸模組列表
progress.downloading.list.of.plugins=正在從 {0} 下載延伸模組列表
progress.downloading.plugin=正在下載延伸模組 ''{0}''
progress.downloading.plugins.meta=正在下載延伸模組 {0} 的資料
progress.file.system.changes=檔案系統更改
progress.performing.indexing.tasks=正在執行編制索引任務
progress.saving.app=正在儲存應用程式設定
progress.saving.project=正在儲存 ''{0}'' 設定
progress.searching=正在搜尋…
progress.text.clickToViewProgressWindow=點擊以檢視所有正在執行的背景任務
progress.text.collecting.classes=正在收集類別列表…
progress.text.downloading=正在下載…
progress.text.generate.classes.archive=正在生成類別歸檔…
progress.text.loading=正在載入…
progress.text.migrating.plugins=正在遷移延伸模組…
progress.text.paused=已暫停
progress.text.reloading.file=正在重新載入檔案…
progress.text.reloading.files=正在重新載入檔案…
progress.text.reopening.files=正在重新開啟檔案…
progress.text.stopping=正在停止 - {0}
progress.third.party.software=正在載入第三方軟體授權
progress.title.check.connection=檢查連線
progress.title.checking.plugin.dependencies=正在檢查延伸模組相依項
progress.title.checking.plugins.repository=正在檢查延伸模組儲存庫…
progress.title.constructing.tooltip=正在建置工具提示
progress.title.creating.git.repository=建立 Git 儲存庫
progress.title.deleting.files=正在刪除檔案…
progress.title.installing.plugin=正在安裝延伸模組“{0}”…
progress.title.loading.paid.plugins=正在啟用訂閱…
progress.title.loading.plugin.details=正在載入延伸模組詳細資訊
progress.title.preparing.navigation=正在準備導覽…
progress.title.project.initialization=專案初始化…
progress.title.reload.files=重新載入檔案
progress.window.empty.text=無背景任務
progress.window.title=背景任務
project.scheme=專案
project.structure.tree.accessible.name=專案結構樹
prompt.browse.icon.for.selected.action=以 SVG 或 PNG 格式瀏覽圖示
prompt.create.non.existing.package=軟體套件 {0} 不存在。\\n是否要建立?
prompt.delete.and=和
prompt.delete.directory={0,choice,1#目錄|2#目錄}
prompt.delete.directory.paren=({0} {0,choice,1#目錄|2#目錄})
prompt.delete.elements=刪除{0}?
prompt.delete.file={0,choice,1#檔案|2#檔案}
prompt.delete.it.anyway=仍要刪除?
prompt.delete.property={0,choice,1#屬性|2#屬性}
prompt.delete.symlink={0,choice,1#符號連結|2#符號連結}
prompt.directory.contains.read.only.files=目錄 {0} 包含唯讀檔案。仍要刪除?
prompt.enter.a.new.package.name=輸入一個新的軟體套件名稱:
prompt.enter.macro.name=輸入巨集名稱。如果為臨時巨集，請留空。
prompt.enter.new.directory.name=輸入新目錄名稱:
prompt.enter.new.file.name=指定新的檔名:
prompt.enter.new.library.name=輸入新庫名稱
prompt.enter.new.module.name=輸入新模組名稱
prompt.enter.new.name=輸入新名稱
prompt.enter.new.package.name=輸入新的軟體套件名稱:
prompt.filechooser.enter.file.name=輸入檔名:
prompt.goto.inspection.enter.name=輸入檢查名稱:
prompt.gotoaction.enter.action=輸入動作或選項名稱:
prompt.gotoclass.enter.class.name=輸入 {0} 名稱:
prompt.gotofile.enter.file.name=輸入檔名:
prompt.gotosymbol.enter.symbol.name=輸入符號名稱:
prompt.input.favorites.list.new.name=將收藏夾列表 ''{0}'' 重命名為:
prompt.input.new.favorites.list.name=輸入新收藏夾列表的名稱
prompt.open.project.or.attach=<html><body>可以在新視窗中開啟專案，取代當前視窗中的專案，或者將專案附加到已經開啟的專案。<br>您想如何開啟專案?</body></html>
prompt.open.project.or.attach.button.attach=附加(&A)…
prompt.open.project.or.attach.button.new.window=新視窗 (&W)
prompt.open.project.or.attach.button.this.window=此視窗(&T)
prompt.open.project.or.attach.title=開啟專案
prompt.proxy.authentication=代理身份驗證
prompt.reset.to.original.template=重設為原始模板?
prompt.server.authentication=伺服器身份驗證
prompt.specify.module.group.name=指定{0}將顯示在其下方的組名稱。\\n\\n
prompt.specify.name.of.module.subgroup=指定{1}將顯示在其下方的{0}子組的名稱\\n\\n
prompt.uninstall.plugin=確定要解除安裝套件 ''{0}'' 嗎?
prompt.uninstall.several.plugins=確定要解除安裝這 {0} 個套件嗎？
quick.lists.description=<html>快速列表允許您定義常用的動作組 (例如，重構或 VCS 動作)，並將鍵盤快捷鍵分配給此類別組。</html>
quick.lists.not.empty.name=快速列表應具有非空名稱
quick.lists.presentable.name=快速列表
quickfix.text.insert.0=插入 {0}
radio.button.open.matching.files.in.associated.application=在關聯的應用程式中開啟符合檔案
radio.button.unlock.all=全部解鎖
radio.button.unlock.dir=目錄解鎖
radio.button.unlock.one=解鎖一個
radio.button.using.file.system=使用檔案系統(&F)
radio.button.using.version.control.integration=使用版本控制整合(&V)
radio.process.close.ask=詢問
radio.process.close.disconnect=斷開連線
radio.process.close.terminate=終止程序
recent.files.accessible.file.list=檔案
recent.files.accessible.open.recently.edited.locations=開啟最近編輯的位置
recent.files.accessible.open.recently.viewed.locations=開啟最近的位置
recent.files.accessible.show.tool.window=啟用工具視窗: {0}
recent.files.accessible.tool.window.list=工具視窗
recent.files.checkbox.label=僅顯示已編輯的內容
recent.files.file.list.empty.text=無最近檔案
recent.files.file.list.loading.empty.text=正在提取最近的檔案…
recent.files.speed.search.empty.text=按 'Enter' 在專案中搜尋
recent.files.tool.window.list.empty.text=無工具視窗
recent.locations.changed.locations=最近編輯的位置
recent.locations.popup.empty.file.text=空行
recent.locations.popup.empty.text=未找到最近的位置
recent.locations.popup.title=最近的位置
recent.locations.title.text=僅顯示已編輯的內容
recent.project.unavailable=(不可用)
recovery.progress.title=正在嘗試{0}…
redo.command=重做{0}
redo.dialog.title=重做
registry.change.warning=更改這些值可能導致 {0} 的異常行為。除非要求，否則請不要更改這些值。
registry.close.action.text=關閉
registry.key.requires.ide.restart.note=需要重啟 IDE
registry.restore.defaults.action.text=恢復預設設定
reload.or.convert.dialog.title={0}: 重新載入或轉換為 {1}
remove.byte.order.mark.from=從 {0} 中移除位元組順序標記
removing.BOM=正在移除 BOM
rename.0=重新命名 {0}
reportProblemAction.progress.title.submitting=正在提交…
reportProblemAction.upload.logs.message=點擊“是”，即表示您同意發送 {0} 的日誌，以便於與 JetBrains 技術支援團隊進行溝通。日誌可能包含私有資訊，例如系統資訊和有關在 IDE 中開啟的專案的資訊。如果無法自動上傳日誌，您仍然能夠以附件形式發送單獨的、可編輯日誌。如果您不發送日誌，我們可能無法幫助您解決問題。
reportProblemAction.upload.logs.title=是否將日誌發送到 JetBrains?
repository.url.title=儲存庫 URL
required.plugin.at.least.versions=，版本至少為 ''{0}''
required.plugin.at.most.versions=，版本最高為 ''{0}''
required.plugin.between.versions=，''{0}'' 和 ''{1}'' 之間的版本
required.plugin.exact.version=，版本 ''{0}''
reset.action.text=重設
reveal.unsupported.message=無法在檔案管理器中開啟 ''{0}'': 此平台不支持該動作。
rubber.duck.debugger.popup.title=小黃鴨偵錯器
run.anything.accessible.name=執行任何內容
run.anything.action.tooltip.text=執行指令: 開啟專案，啟動執行組態，執行 Gradle 或 Maven 任務，執行終端指令等。
run.anything.actions.undefined=未定義
run.anything.ad.command.delete={0} 刪除最近的指令
run.anything.ad.run.action.with.default.settings=按 {0} 使用預設設定執行
run.anything.ad.run.in.context=按 {0} 在當前檔案上下文中執行
run.anything.ad.run.with.debug={0} 偵錯
run.anything.console.error.title=無法執行指令
run.anything.console.process.finished=\\n程序已結束，離開程式碼為 {0}。
run.anything.context.browse.directory=瀏覽目錄…
run.anything.context.project=專案
run.anything.context.project.undefined=未定義
run.anything.context.separator.directories=目錄
run.anything.context.separator.modules=模組
run.anything.context.title.working.directory=執行上下文
run.anything.context.tooltip=選擇將在其中執行當前指令的上下文
run.anything.custom.activity.notification.group.id=已執行 Run Anything 指令
run.anything.custom.activity.rollback.action=復原
run.anything.general.group.title=一般
run.anything.help.list.empty.secondary.text=選擇指令
run.anything.hint.initial.text=按 {0} 或 {1} 瀏覽建議列表
run.anything.indexing.mode.not.supported=在索引更新期間，“執行任何內容”不可用
run.anything.main.list.empty.primary.text=執行指令或組態
run.anything.main.list.empty.secondary.text=輸入“?”以檢視所有指令
run.anything.notification.warning.content=指令 ''{0}'' 無法執行。
run.anything.notification.warning.title=指令執行失敗
run.anything.recent.group.title=最近
run.anything.recent.project.command.placeholder=開啟 <專案名稱>
run.anything.recent.project.completion.group.title=最近的專案
run.anything.recent.project.help.group.title=最近的專案
run.anything.run.anything.title=執行任何內容
run.anything.run.configurations.group.title=執行組態
run.anything.run.debug.title=偵錯:
run.anything.run.in.context.debug.title=使用偵錯在上下文中執行:
run.anything.run.in.context.title=在上下文中執行:
run.layout.do.not.show.view.option.message=不顯示
save.as.trusted.certificate=另存為可信憑證
saving.activity.tracker.name=正在儲存
scheme.ide=IDE
scheme.project=專案
scheme.theme.default=主題預設
scope.banner.text=作用域 ''{0}''
scope.chooser.select.scope.text=在此處選擇作用域以檢視或編輯其詳細資訊
scope.class.hierarchy=類別層次結構
scope.current.file=當前檔案
scope.editor.legend.partly.included.label=部分包含
scope.editor.legend.recursively.included.label=遞迴包含
scope.files.in.previous.search.result=之前搜尋結果中的檔案
scope.open.files=開啟檔案
scope.previous.search.results=之前的搜尋結果
scope.recent.files=最近檢視的檔案
scope.recent.modified.files=最近更改的檔案
scope.selected.directories=選定{0,choice,1#目錄|2#目錄}
scope.selected.files=選定{0,choice,1#檔案|2#檔案}
scope.selected.files.and.directories=選定{0,choice,1#檔案|2#檔案}和{1,choice,1#目錄|2#目錄}
scope.selection=選區
scope.unable.to.save.scope.message=是否要儲存為共享作用域?
scope.unable.to.save.scope.title=無法使用區域作用域
scope.view.empty.link=顯示所有專案檔案
scope.view.empty.text=當前作用域中沒有檔案。
scope.view.title=作用域
scopes.display.name=作用域
scopes.no.scoped=未新增作用域。
scopes.save.dialog.title.local=儲存為區域作用域
scopes.save.dialog.title.shared=儲存為共享作用域
scratches.and.consoles=臨時檔案和主控台
search.everywhere.action.tooltip.description.text=搜尋: <ul style=''list-style-type:none;margin:0;padding:0;''><li>- {0}</li><li>- 檔案</li><li>- 工具視窗</li><li>- 動作</li><li>- 設定</li></ul>
search.everywhere.action.tooltip.text=搜尋所有位置<br/>按 <b>{0}</b> 存取 <ul style=''list-style-type:none;margin:0;padding:0;''><li>- {1}</li><li>- 檔案</li><li>- 工具視窗</li><li>- 動作</li><li>- 設定</li></ul>
search.everywhere.command.plugins=延伸模組: {0}
search.everywhere.directory.file.type.name=目錄
search.everywhere.filter.classes.description=轉到類別
search.everywhere.filter.files.description=轉到檔案
search.everywhere.filter.symbols.description=轉到符號
search.everywhere.group.name.actions=動作
search.everywhere.group.name.files=檔案
search.everywhere.group.name.recent.files=最近的檔案
search.everywhere.group.name.symbols=符號
search.everywhere.group.name.top.hit=點擊最多
search.everywhere.group.name.top.hit.client=點擊最多(用戶端)
search.everywhere.points.loading=…正在載入…
search.everywhere.points.more=…更多
search.everywhere.preview.action.description=顯示預覽
search.everywhere.preview.action.text=預覽
search.for.usages.and.delete.elements=搜尋用法並刪除{0}?
searcheverywhere.accessible.name=隨處搜尋
searcheverywhere.all.elements.tab.name=所有
searcheverywhere.autocompletion.tab.name=自動補全
searcheverywhere.commands.tab.name=指令
searcheverywhere.found.matches.title=''{0}'' 在 [{1}] 中的匹配項
searcheverywhere.found.targets.title=未排序的結果
searcheverywhere.history.shortcuts.hint=按 {0} 或 {1} 瀏覽搜尋歷史記錄
searcheverywhere.ide.search.tab.name=IDE
searcheverywhere.indexing.incomplete.results=在 {1} 更新索引期間，''{0}'' 中的搜尋結果可能不完整
searcheverywhere.indexing.mode.not.supported=在 {1} 更新索引期間，無法在 ''{0}'' 中搜尋
searcheverywhere.nothing.found.for.all.anywhere=找不到任何內容
searcheverywhere.nothing.found.for.contributor.anywhere=未找到使用此類別名的 {0}
searcheverywhere.open.in.new.window.shortcuts.hint=按 {0} 在新視窗中開啟檔案
searcheverywhere.open.in.split.shortcuts.hint=按 {0} 在右拆分中開啟檔案
searcheverywhere.project.search.tab.name=專案
searcheverywhere.reset.filters=重設篩選器
searcheverywhere.run.configs.tab.name=執行組態
searcheverywhere.runconfigurations.command.debug.description=在“偵錯”模式下開始執行組態
searcheverywhere.runconfigurations.command.run.description=在“執行”模式下開始執行組態
searcheverywhere.test.dialog.elements.limit=元素限制
searcheverywhere.test.dialog.grouping.interval=分組間隔
searcheverywhere.test.dialog.search.button=搜尋
searcheverywhere.test.dialog.search.field=搜尋文本
searcheverywhere.test.dialog.title=搜尋貢獻者測試
searcheverywhere.textfield.hint=輸入 {0} 以檢視指令
searcheverywhere.to.perform.fulltext.search=以執行全文搜尋
searcheverywhere.try.to.find.in.files=在檔案中尋找
searcheverywhere.try.to.reset.scope=將作用域設定為
searcheverywhere.use.main=使用
searcheverywhere.use.optional=或使用
section.title.fingerprints=指紋
section.title.issued.by=發佈者
section.title.issued.to=發佈物件
section.title.validity.period=有效期
select.in.commander=Commander
select.in.favorites=收藏夾
select.in.file.structure=檔案結構
select.in.packages=軟體套件
select.in.project=專案
select.in.scope=作用域
separator.scheme.stored.in=存儲於 {0}
set.action.editor.and.tools=為編輯器和工具設定
set.action.empty.frame=為空框架設定
setting.value.reload.mode.preview=在內置預覽中重新載入頁面:
setting.value.reload.mode.server=在瀏覽器中重新載入頁面:
settings.browsers.column.family=系列
settings.browsers.column.name=名稱
settings.browsers.column.path=路徑
settings.browsers.custom.path=自訂路徑
settings.browsers.default.browser=預設瀏覽器:
settings.browsers.first.listed=首先列出
settings.browsers.no.web.browsers.configured=未組態 Web 瀏覽器
settings.browsers.reload.behavior=重新載入行為
settings.browsers.show.browser.popup.html=對於 HTML 檔案
settings.browsers.show.browser.popup.in.the.editor=在編輯器中顯示瀏覽器彈出視窗
settings.browsers.show.browser.popup.xml=對於 XML 檔案
settings.browsers.system.default=系統預設值
settings.certificate.accept.non.trusted.certificates.automatically=自動接受非可信憑證(&A)
settings.certificate.accepted.certificates=接受的憑證:
settings.certificate.cannot.add.certificate=無法新增憑證
settings.certificate.cannot.add.certificate.for=無法為 {0} 新增憑證
settings.certificate.cannot.remove.certificate=無法移除憑證
settings.certificate.cannot.remove.certificate.for=無法移除 {0} 的憑證
settings.certificate.certificate.already.exists=憑證已存在
settings.certificate.choose.certificate=選擇憑證
settings.certificate.filter.label=憑證檔案
settings.certificate.malformed.x509.server.certificate=X509 伺服器憑證的格式錯誤
settings.certificate.no.certificate.selected=未選擇任何憑證
settings.certificate.no.certificates=無憑證
settings.certificate.not.imported=未匯入
settings.entry.point.newUi.tooltip=新 UI 可用
settings.entry.point.tooltip=IDE 和專案設定
settings.entry.point.update.ide.action=下載 {0} {1}
settings.entry.point.update.plugin.action=更新 {0} 延伸模組…
settings.entry.point.update.plugins.action=更新 {0} 延伸模組…
settings.entry.point.widget.name=IDE 和專案設定
settings.entry.point.with.updates.tooltip=有可用更新。IDE 和專案設定
settings.file.color.column.color=顏色
settings.file.color.column.scope=作用域
settings.file.color.column.shared=通過 VCS 共享
settings.file.color.column.shared.help=<html>共享組態存儲在 <code>.idea</code> 目錄中，<br>其他團隊成員可以通過 VCS 使用。
settings.file.color.custom.name=自訂
settings.file.colors.add.colors.link=新增顏色
settings.file.colors.description=檔案可以屬於多個範圍。如果一個範圍有兩種顏色，則使用列表中第一個範圍的顏色。
settings.file.colors.dialog.choose.color=選擇作用域顏色
settings.file.colors.dialog.warning.append=您是否希望再次新增?
settings.file.colors.dialog.warning.local=已為 {0} 定義區域顏色
settings.file.colors.dialog.warning.replace=<html>是否要將<span style="background-color:#{0};">舊顏色</span>更新為<span style="background-color:#{1};">新顏色</span>?
settings.file.colors.dialog.warning.shared=已為 {0} 定義共享顏色
settings.file.colors.dialog.warning.update=更新
settings.file.colors.enable.file.colors=啟用檔案顏色(&F)
settings.file.colors.manage.scopes=管理作用域(&M)…
settings.file.colors.no.colors.specified=未新增顏色
settings.file.colors.scope.unknown=不存在的作用域
settings.file.colors.use.in.editor.tabs=在編輯器頁籤中使用(&T)
settings.file.colors.use.in.project.view=在專案檢視中使用(&P)
settings.general.autosave=自動儲存
settings.general.directory.preselected=“開啟…” 和 “新增 | 專案…” 對話框中會預先選擇此目錄。
settings.general.synchronization=同步外部更改:
settings.menus.group.touch.bar=Touch Bar
settings.modal.opening.message=正在開啟設定
settings.password.internal.error.no.available.credential.store.implementation=內部錯誤，沒有可用的憑證存儲實作。
settings.password.package.libsecret.1.0.is.not.installed=未安裝軟體套件 libsecret-1-0 (要安裝，請使用以下指令: sudo apt-get install libsecret-1-0 gnome-keyring)。
settings.password.unknown.provider.type=未知提供程序類型: {0}
settings.required.plugins.title=指定專案所需的延伸模組列表。<br>如果缺少必需延伸模組或需要更新，{0} 將通知您。
settings.trusted.certificates=驗證延伸模組時受信任的憑證:
share.scope.checkbox.title=通過 VCS 共享
share.scope.context.help=<html>共享組態存儲在 <code>.idea</code> 目錄中，<br>其他團隊成員可以通過 VCS 使用。
shell.env.loading.failed={0} 未能從 ''{1}'' 載入環境。與依賴於環境變數的工具整合可能無法正常進行。
shell.env.loading.learn.more=了解詳情
shortcut.balloon.add.shortcut=新增快捷鍵
shortcut.in.group.text=在 {0} 中
show.details=顯示詳細資訊
show.hidden.tabs=顯示隱藏的頁籤
show.in.find.window.button.description=在“尋找工具”視窗中開啟搜尋結果
show.in.find.window.button.name=在“尋找工具”視窗中開啟
show.in.find.window.button.name.newui=在尋找視窗中開啟結果
show.in.find.window.button.pin.description=在單獨的工具視窗中顯示所有用法
show.main.toolbar=顯示主工具列
show.members.in.navigation.bar=在導覽列中顯示成員
show.navigation.bar=顯示導覽列
show.options.menu=選項
show.status.bar=顯示狀態列
small.labels.in.editor.tabs=編輯器頁籤中的小標籤
speed.search.got.it.link=知道了
speed.search.got.it.text=開始輸入以篩選元素
split.component.missing=拆分元件({0})
split.with.chooser.duplicate.tab=，{0}以複製
split.with.chooser.move.tab=按 {0} 開啟“{1}”
split.with.chooser.switch.tab=使用 {0} 轉到下一個拆分器
ssl.certificate.details=憑證詳細資訊
ssl.certificate.error.expired=憑證已過期
ssl.certificate.error.not.yet.valid=尚未生效的憑證
ssl.certificate.error.self.signed=自簽名憑證
ssl.certificate.error.untrusted.authority=由不受信任的機構簽署的憑證
ssl.certificate.server.action=動作:
ssl.certificate.server.address=伺服器地址:
ssl.certificate.tree.accessible.name=憑證
ssl.certificate.warning=正在嘗試連線到使用{0}的伺服器。繼續動作可能會危及連線安全。是否將{1}另存為可信憑證並繼續動作?
ssl.certificate.warning.default=正在嘗試連線到不受信任的伺服器。繼續動作可能會危及連線安全。是否將所選憑證儲存為受信任並繼續動作?
ssl.certificate.warning.plural=所選憑證
ssl.certificate.warning.singular=憑證
start.browser.border.label.open.browser=開啟瀏覽器
start.browser.checkbox.start.browser=在啟動後
start.browser.panel.url.label=URL(&U):
start.browser.with.js.debugger=使用 JavaScript 偵錯器(&J)
status.bar.message.at.line=行 {0}: {1}
status.bar.text.file.encoding=檔案編碼: {0}
status.bar.text.macro.recorded=已記錄: {0}
status.bar.text.script.execution.finished=腳本執行已完成
status.bar.widget.non.commercial.usage=非商業用途
status.text.tab.open.in.editor=該頁籤在編輯器區域中開啟
status.text.tab.open.in.editor.jump=轉到編輯器
status.text.tab.open.in.editor.restore=恢復頁籤
structure.view.tree.accessible.name=結構檢視樹
subscription.dialog.activate.button=啟用新的 {0} 訂閱
subscription.dialog.activate.ok.text=啟用 {0}…
subscription.dialog.cancel.button=離開 {0}
subscription.dialog.continue.button=在沒有訂閱的情況下繼續
subscription.dialog.continue.ok.text=繼續並重新啟動…
subscription.dialog.idea=IntelliJ IDEA
subscription.dialog.link={0} 訂閱如何為您提供幫助
subscription.dialog.pro=Pro
subscription.dialog.promise.button=承諾稍後付款
subscription.dialog.promise.ok.text=承諾…
subscription.dialog.pycharm=PyCharm
subscription.dialog.title=訂閱已過期
subscription.dialog.ultimate=旗艦版
support.screen.readers.tab={0} 和 {1} 將在對話框中導覽 UI 控件，並且不能用於切換編輯器頁籤或其他 IDE 動作。滑鼠懸停時的工具提示將被停用。
sys.health.acknowledge.action=不再顯示
sys.health.details=詳細資訊
tab.chooser.project=專案
tab.chooser.search.by.name=按名稱搜尋
tab.filetemplates.code=程式碼
tab.filetemplates.includes=Include
tab.filetemplates.j2ee=其他
tab.filetemplates.templates=檔案
tab.title.editor.and.preview=編輯器和預覽
tab.title.editor.only=編輯器
tab.title.html.preview=HTML 預覽
tab.title.preview.only=預覽
tab.title.stacktrace=<堆疊追蹤>
tab.title.text=文本
tabs.layout.compressible.name=可壓縮單排
tabs.layout.scrollable.single.row.name=可滾動單排
tabs.layout.table.name=表布局
tag.panel.group.options.accessible.name={0}選項
tag.panel.run.options.accessible.name=執行選項
task.browser.label=瀏覽器:
task.browser.launch=啟動 Web 瀏覽器
task.browser.url=URL:
tech.insights.lab.promoter.action=註冊…
tech.insights.lab.promoter.description=註冊以參加遠端訪談、調查和實用性測試，幫助塑造 JetBrains 產品的未來!
tech.insights.lab.promoter.title=加入我們的 JetBrains Tech Insights Lab!
temp.dir.env.invalid=環境變數 ''{0}'' 指向不存在的目錄(''{1}'')。有些東西可能工作不正常。
temp.dir.exec.failed=IDE 無法執行臨時目錄 ''{0}'' 中的測試腳本。某些內容可能無法正常工作。
template.copy.N.of.T=複製 {0} 個 {1}
template.file.name=用於生成檔名和路徑的模板
template.file.name.optional=用於生成檔名和路徑的模板(可選)
template.unnamed=未命名
terminal.action.ClearBuffer.text=清除緩衝區
terminal.action.Find.text=尋找
terminal.action.LineDown.text=向下移動一行
terminal.action.LineUp.text=向上滾動一行
terminal.action.MoveLeft.text=左移
terminal.action.MoveRight.text=右移
terminal.action.OpenAsUrl.text=作為 URL 開啟
terminal.action.PageDown.text=向下翻頁
terminal.action.PageUp.text=向上翻頁
terminal.action.SelectNextTab.text=選擇下一個頁籤
terminal.action.SelectPreviousTab.text=選擇上一個頁籤
terminal.action.ShowTabs.text=顯示頁籤
terminal.cursor.shape.block.name=塊
terminal.cursor.shape.underline.name=下劃線
terminal.cursor.shape.vertical.name=垂直線
text.password.hidden=<已隱藏>
text.server.s.certificate.trusted=伺服器的憑證不可信
text.server.s.certificate.trusted.details=伺服器的憑證不可信:<br/>{0}
text.todo.no.filters=未組態篩選器
text.todo.no.patterns=未組態模式
text.use.solution.colors.in.main.toolbar=使用不同的工具列顏色一目了然地區分專案。
this.directory.does.not.belong.to.the.project={0, choice, 1#這一目錄|2#這些目錄}不屬於專案:
this.file.does.not.belong.to.the.project={0, choice, 1#這一檔案|2#這些檔案}不屬於專案:
thread.dump.is.taken=執行緒傾印已被<a href="{0}">佔用</a>。
tip.of.the.day.feedback.dislike=不喜歡
tip.of.the.day.feedback.like=喜歡
tip.of.the.day.feedback.question=您覺得這個小技巧是否有用?
tip.of.the.day.progress.title=顯示每日小技巧
title.accessibility=無障礙功能
title.add.new.favorites.list=新增新收藏夾列表
title.add.todo.filter=新增篩選器
title.add.todo.pattern=新增模式
title.appearance=外觀
title.browse.icon=瀏覽圖示
title.cannot.convert.project=無法轉換專案
title.cannot.create.class=無法建立類別
title.cannot.create.file=無法建立檔案
title.cannot.load.project=無法載入專案
title.cannot.open.file=無法開啟檔案
title.cannot.open.project=無法開啟專案
title.cannot.save.current.template=無法儲存當前模板
title.choose.action.icon=選擇動作圖示
title.choose.destination.directory=選擇目標目錄
title.common=通用
title.customizations=選單與工具列
title.delete=刪除
title.edit.file.template=編輯檔案模板
title.edit.macros=編輯巨集
title.edit.todo.filter=編輯篩選器
title.edit.todo.pattern=編輯模式
title.enter.macro.name=輸入巨集名稱
title.error.reading.file=讀取檔案時出錯
title.error.writing.file=寫入檔案時錯誤
title.export.preview=匯出預覽
title.file.already.exists=檔案已存在
title.file.templates=檔案和程式碼模板
title.general=系統設定
title.hierarchy.callees.of={0} 的被呼叫方
title.hierarchy.callers.of={0} 的呼叫方
title.hierarchy.class=類別{0}
title.hierarchy.method=方法 {0}
title.hierarchy.subtypes={0}的子類型
title.hierarchy.supertypes={0}的父類型
title.language.and.region=語言和區域
title.load.file.from.share=正在從網絡載入檔案
title.load.project.from.share=正在從網絡載入專案
title.macro.name.already.used=巨集名稱已被使用
title.module.file.does.not.exist=模組檔案不存在: {0}
title.module.group=模組組
title.module.sub.group=模組子組
title.new.directory=新增目錄
title.new.file=新增檔案
title.new.from.template=新增 {0}
title.new.package=新增軟體套件
title.no.element.selected=未選擇任何元素
title.open.file.or.project=開啟檔案或專案
title.open.project=開啟專案
title.package.not.found=找不到軟體套件
title.plugin.error=延伸模組錯誤
title.plugin.installation=延伸模組安裝
title.plugin.uninstall=解除安裝套件
title.plugins=延伸模組
title.popup.new.element=新增
title.popup.new.element.same.place=在此目錄中新增
title.popup.recent.files=最近的檔案
title.popup.select.target=選擇位置:
title.project=專案
title.region.africa=非洲
title.region.america=美洲
title.region.asia=亞洲(中國大陸除外)
title.region.china=中國大陸
title.region.europe=歐洲
title.region.middle_east=中東
title.region.not_set=未指定
title.region.oceania=大洋洲
title.rename.favorites.list=重新命名
title.rename.library=重新命名庫
title.rename.macro=重新命名巨集
title.rename.module=重新命名模組
title.reset.template=重設模板
title.restart.needed=需要重啟
title.search.results=搜尋結果
title.select.path.to.browser=選擇瀏覽器的路徑
title.select.project.file.directory=選擇{0}檔案目錄
title.select.template=選擇模板
title.smooth.scrolling.options=平滑滾動選項
title.tip.of.the.day=每日小技巧
title.todo=TODO
title.todo.current.file=當前檔案
title.unable.to.add.favorites.list=無法新增收藏夾列表
title.use.rest.api=使用 REST API
title.velocity.error=Velocity 錯誤
title.warning=警告
to.create.new.file.tooltip=要建立新檔案，請按 <b>{0}</b>。或者右擊任何目錄並選擇<b>新增 | \\\\&lt;file type\\\\&gt;</b>
todo.panel.preview.source.action.text=預覽源
toggle.editor.and.tools=編輯器和工具
toggle.empty.frame=空框架
too.large.download.size=通過塊映射下載歸檔需要太多塊，因此將下載整個歸檔
toolbox.updates.download.ready.action.description=Toolbox App 已安裝 {2} {1} ({0})。是否重啟到新版本?
toolbox.updates.download.ready.action.text=切換到 {2} {1} ({0})…
toolbox.updates.download.update.action.description=Toolbox App 將下載 {2} {1} ({0}) 並通知您更新切換就緒的時間
toolbox.updates.download.update.action.text=下載 {2} {1} ({0})
tooltip.autosave.mode=自動儲存模式
tooltip.close.notification=關閉。按 {0} 並點擊以關閉所有通知
tooltip.close.tab=關閉頁籤
tooltip.eap.plugin.version=EAP 版本不保證延伸模組的穩定性\\n和可用性。
tooltip.event.log.show.balloon=顯示氣球
tooltip.flip.horizontally=水平翻轉
tooltip.flip.vertically=垂直翻轉
tooltip.from.deployment.configuration=來自部署組態:
tooltip.hide=隱藏
tooltip.inherited.editor.color.scheme=編輯器 | 配色方案 | {0}<br>{1}
tooltip.license.not.required.for.eap.version=EAP 版本不需要授權
tooltip.line.separator=行分隔符: {0}
tooltip.macro.is.being.recorded.now=正在錄製巨集
tooltip.module.group=模組組
tooltip.paid.plugin=安裝後啟用延伸模組授權或使用 30 天試用。
tooltip.recent.search=最近搜尋
tooltip.search.history=搜尋歷史記錄
tooltip.search.history.hotkey=搜尋歷史記錄 {0}
tooltip.shared.folders.from.vagrantfile=來自 Vagrantfile 的共享目錄:
tooltip.text.add.shortcut.with.special.keys=使用 {0} 鍵設定快捷鍵
tooltip.text.password.will.be.stored.between.application.sessions=密碼將存儲在應用程式會話之間
tooltip.text.update.is.in.progress.click.to.cancel=正在更新。點擊以取消
tooltip.turn.notification.off=關閉或更改行為
tooltip.ui.designer.form=UI 設計器表單
tooltip.ultimate.plugin=升級到 {0} 以使用此延伸模組
toolwindow.header.accessible.name=工具視窗標題
toolwindow.palette=調色板
toolwindow.stripe.Bookmarks=書籤
toolwindow.stripe.Commit=提交
toolwindow.stripe.Favorites=收藏夾
toolwindow.stripe.Notifications=通知
toolwindow.stripe.Problems=自動建置
toolwindow.stripe.ProblemsView=問題
toolwindow.stripe.Problems_View=問題
toolwindow.stripe.Profiler=分析器
toolwindow.stripe.Project=專案
toolwindow.stripe.Statistics_Event_Log=統計事件
toolwindow.stripe.Structure=結構
toolwindow.stripe.TODO=TODO
toolwindow.stripe.Version_Control=版本控制
toolwindow.stripe.documentation.v2=文檔
toolwindow.stripe.documentation.v2.shortName=文檔
transfer-settings.keymap.custom-shortcuts=僅自訂快捷鍵
transfer-settings.keymap.extension-custom-shortcuts=<html>來自 {0} 的某些擴展程序可能新增了自訂快捷鍵。這些快捷鍵也顯示在此列表中</html>
transfer-settings.keymap.more=更多…
transfer-settings.plugins.more=和另外 {0} 個
transfer-settings.sections.more=更多…
transfer-settings.vs-win.resharper-settings-found=ReSharper 設定已找到並將被匯入
transfersettings.button.retry.import=重試匯入
transfersettings.label.debug=偵錯
transfersettings.label.failed.to.import.settings.from=無法從 {0} {1} 匯入設定
transfersettings.label.find.usages=尋找用法
transfersettings.label.go.to.declaration=轉到宣告
transfersettings.label.please.try.again=請重試
transfersettings.label.run=執行
transfersettings.label.search.everywhere=隨處搜尋
transfersettings.plugin.built.in=內建
transfersettings.plugin.plugin=延伸模組
transfersettings.product.visual.studio=Visual Studio
transfersettings.product.visual.studio.for.mac=Visual Studio for Mac
transfersettings.product.vscode=VSCode
transfersettings.projects.and.n.more=和其他 {0} 個
transfersettings.task.progress.details.complete=已成功匯入
transfersettings.task.progress.details.finishing.up=正在完成…
transfersettings.task.progress.details.starting.up=正在啟動…
transfersettings.task.progress.title.importing.settings=正在匯入設定
transfersettings.vs.failureReason=如果 Visual Studio 處於開啟狀態或其檔案被另一個程序存取，則會發生這種情況。{0}
transfersettings.vs.noSettings=如果未正確移除 Visual Studio、其設定損壞或從未啟動，則會發生這種情況。
transfersettings.vs.quit.advise=離開 Visual Studio 和所有使用 Visual Studio 工具的程序。之後等待大約 30 秒。
treenode.loading=正在載入…
trial.expired=試用已過期。
trial.survey.another.reason=我的理由未在此處列出
trial.survey.check.for.daily=我正在評估它對我的日常任務是否有用
trial.survey.check.new.features=我正在評估最新版本中引入的新功能
trial.survey.learn=我想學習如何使用特定功能、語言或框架
trial.survey.no.goal=我沒有具體目標
trial.survey.waiting.license=我正在等待雇主的許可
trust.certificate.warning.details=信任此憑證可能會使您的資料面臨安全威脅。只有在您信任來源並了解相關風險的情況下，才可以繼續動作。
trust.certificate.warning.details.action=如何管理憑證
trust.certificate.warning.details.popup=<html>您可以稍後在“設定 | 工具 | 伺服器憑證”中停用已接受的憑證。已接受的憑證將以預設密碼 <i>{1}</i> 儲存在 <i>{0}</i> 信任庫中。</html>
trusted.folders.settings.label=位於這些本地目錄下的專案將被視為受信任的專案
trusted.hosts.settings.new.trusted.folder.dialog.title=新增受信任的位置
trusted.hosts.settings.new.trusted.folder.file.chooser.title=選擇受信任的位置
ui.button.off=關閉
ui.button.on=開啟
ui.customization.select.auto.popup.by.chars.text=通過按空格、點或其他上下文相關鍵插入選定建議
undo.command=撤消{0}
undo.command.local.name=本地
undo.conflicting.change.confirmation=受此動作影響的其他檔案已更改。
undo.dialog.title=撤消
uninstall.packages.failed=無法解除安裝軟體套件。<a href="xxx">詳細資訊…</a>
uninstall.packages.failed.dialog.title=解除安裝軟體套件失敗
unknown.error=未知錯誤
unscramble.dialog.title=分析堆疊追蹤
unsupported.windows=不再支援此版本的 Windows。某些功能可能無法正常工作。請使用 Windows 10 1809 或更高版本。
untrusted.jps.project.not.loaded.notification=對於在安全模式下開啟的專案，不載入組態檔案。如果您信任該專案，請相應地對其進行標記，然後重新開啟以避免此限制。
untrusted.project.dialog.distrust.button=繼續使用安全模式
untrusted.project.dialog.text=如果您不信任此源，請繼續使用安全模式。\\n\\n載入、執行或建置 {0} {1,choice,1#專案|1<專案}可能會執行其建置腳本中的潛在惡意程式碼。
untrusted.project.dialog.title=信任 {0} {1,choice,1#專案|1<專案}?
untrusted.project.dialog.trust.button=信任專案
untrusted.project.dialog.trust.folder.button=信任 ''{0}'' 目錄
untrusted.project.general.dialog.title=信任專案?
untrusted.project.link.dialog.cancel.button=不連結
untrusted.project.link.dialog.title=是否信任並連結 {0} 專案 ''{1}''?
untrusted.project.location.comment=這將提高 IDE 性能。您必須具有管理員權限才能使用。
untrusted.project.notification.description=安全模式，功能受限。信任該專案以存取完整的 IDE 功能。
untrusted.project.notification.read.more.link=閱讀更多資訊
untrusted.project.notification.trust.link=信任專案…
untrusted.project.open.dialog.cancel.button=不開啟
untrusted.project.open.dialog.distrust.button=在安全模式下預覽
untrusted.project.open.dialog.text={0} 提供的功能可能會從此目錄執行潛在惡意程式碼。如果不信任此源，請在安全模式下預覽專案，以便僅瀏覽其程式碼。
untrusted.project.open.dialog.title=信任並開啟專案 ''{0}''?
untrusted.project.warning.trust.location.checkbox=<html>信任 <b>''{0}''</b> 目錄中的所有專案
untrusted.project.windows.defender.trust.location.checkbox=<html>將 <b>IDE</b> 和 <b>''{0}''</b> 目錄新增到 Microsoft Defender 排除列表
update.apply.manually.message=抱歉，IDE 無法在您的系統上執行自動更新。\\n請離開 IDE 並通過啟動此腳本手動套用更新檔:\\n{0}。
update.channel.enforced=更新通道已切換為 ''{0}''
update.downloading.patch.error=無法準備更新:<br>{0}
update.downloading.patch.open=開啟下載頁面
update.downloading.patch.progress=正在下載更新檔檔案
update.downloading.plugins.progress=正在下載延伸模組更新
update.installed.notification.title=已安裝延伸模組更新
update.no.update.hosts=沒有組態延伸模組儲存庫
update.preparing=正在準備 IDE 更新
update.preparing.patch.progress=正在準備更新檔檔案
update.ready.message=IDE 已準備好更新
update.ready.restart=重新啟動
update.snap.blog.post.action=網誌
update.snap.message=IDE 已通過 Snap 更新。
update.whats.new={0} 最新變化
updates.all.plugins.action={0,choice,1#更新|2#全部更新}
updates.apply.manually.button=手動更新(&D)
updates.auto.update.title=啟用自動更新
updates.channel.bundled.key=新版本有一個到期日期，不需要授權密鑰。
updates.checking.platform=正在檢查 IDE 更新
updates.checking.plugins=正在檢查延伸模組更新
updates.checking.progress=正在檢查更新
updates.configure.label=<b><a href="updates">組態</a></b>自動更新。
updates.configure.updates.label=組態更新…
updates.dialog.title={0} 和延伸模組更新
updates.download.and.restart.button=更新並重啟(&D)
updates.download.button=下載(&L)
updates.error.connection.failed=連線失敗({0})。請檢查您的網絡連線並重試。
updates.error.connection.title=連線錯誤
updates.external.error.message=無法檢查 {0} 的更新: {1}
updates.external.progress=正在提取外部元件的可用更新
updates.external.ready.message={0,choice,1#元件|2#元件}: {1}
updates.fallback.build=您有新版本的永久回退授權。
updates.from.to=將 {0} 更新到 {1} ({2})。
updates.from.to.size=正在將 {0} 更新到 {1} ({2})。補丁大小為 {3} MB。
updates.ignore.update.button=忽略這個更新(&I)
updates.ignore.updates.button=忽略{0,choice,1#此更新|2#這些更新}(&I)
updates.ignore.updates.link=忽略{0,choice,1#此更新|2#這些更新}
updates.incompatible.plugins.found=新版本中的: {0,choice,1#'' ''|2#'<br/>'} {1} 與 {0,choice,1#延伸模組|2#延伸模組} 不相容
updates.interim.build=您可以使用新版本，直到您的訂閱於 {0} 到期。
updates.last.check.never=從不
updates.new.build.notification.title={0}{1}可用
updates.new.version.available=<b>有新版本的 {0} <a href="{1}">可用</a>!</b>
updates.no.updates.message=您已安裝最新版本的 {0} 和延伸模組。
updates.no.updates.notification=沒有可用的 IDE 或延伸模組更新
updates.no.updates.snap.message=<html>所有延伸模組都處於最新狀態。<br> {0} 更新由 Snap 管理。<br>執行 ''snap refresh'' 指令以檢查更新。</html>
updates.no.updates.toolbox.message=<html>所有延伸模組都是最新的。<br> {0} 更新由 Toolbox App 管理。<br>啟動它以檢查是否有可用更新。</html>
updates.no.updates.unknown.message=<html>所有延伸模組都是最新的。<br> {0} 更新由 {1} 管理。</html>
updates.notification.title={0} 和延伸模組更新
updates.notification.update.action=更新…
updates.paid.upgrade=您可以評估新版本 {0} 天，或者線上購買。
updates.plugin.ready.title=有可用的 {0} 延伸模組更新
updates.plugin.ready.tooltip={0} 個{1,choice,1#延伸模組|2#延伸模組}{1,choice,1#更新|2#更新}可用
updates.plugins.autoupdate.notification.do.not.ask.display=啟用延伸模組自動更新
updates.plugins.autoupdate.notification.message=是否啟用延伸模組自動更新以始終擁有其最新版本?
updates.plugins.autoupdate.se.option=自動更新延伸模組
updates.plugins.autoupdate.settings.action=自動更新延伸模組
updates.plugins.autoupdate.settings.checkbox=自動更新延伸模組
updates.plugins.autoupdate.settings.comment=更新將在背景下載並在重啟後自動套用
updates.plugins.autoupdate.settings.prohibited.by.policy.comment=公司政策禁止延伸模組自動更新
updates.plugins.dialog.action=詳細資訊…
updates.plugins.error.message1=無法從預設儲存庫載入延伸模組: {0}
updates.plugins.error.message2=無法從 ''{0}'' 載入延伸模組: {1}
updates.plugins.notification.title=延伸模組已更新
updates.plugins.ready.title=有可用的延伸模組更新
updates.plugins.settings.checkbox=檢查延伸模組更新
updates.remind.later.button=稍後提醒我(&R)
updates.settings.channel.locked=EAP 版本只能通過 EAP 通道更新
updates.settings.check.now.button=檢查更新(&C)…
updates.settings.checkbox=檢查 IDE 更新
updates.settings.checkbox.for=為之檢查 IDE 更新:
updates.settings.current.version=當前版本:
updates.settings.external=IDE 更新由 {0} 在外部管理
updates.settings.ignored=管理忽略的更新…
updates.settings.ignored.title=忽略的更新
updates.settings.last.check=上次檢查: {0}
updates.settings.recommend.toolbox=我們推薦 <a href=''{0}''>{1}</a>
updates.settings.recommend.toolbox.multiline.description=自動獲取更新，一鍵開啟您的專案，<br>了解其他 JetBrains 產品等
updates.settings.show.editor=IDE 更新後在編輯器中顯示新功能
updates.settings.title=更新
updates.write.protected={0} 沒有 {1} 的寫入權限。請通過特權使用者執行以更新。
upgrade.package.failed.title=升級軟體套件失敗。
upgrade.packages.failed=無法升級軟體套件。<a href="xxx">詳細資訊…</a>
upgrade.packages.failed.dialog.title=升級軟體套件失敗
uploading.logs.message=正在上傳日誌…
uses.shortcut.of=繼承自
vagrant.vm.1.choice.0.0.1.at.2.3=Vagrant 虛擬機{1, choice, 0#“{0}”|1#}，處於 {2} ({3})
vfs.activity.tracker.name=虛擬檔案系統
vm.options.edit.action.cap=編輯自定義虛擬機選項
vm.options.env.vars=檢測到使用了 Java 選項環境變數。此類別變數將覆寫 IDE 組態檔案(*.vmoptions)，並可能導致性能和穩定性問題。請考慮刪除以下變數: {0}。
vm.options.file.corrupted=VM 選項檔案 ''{0}'' 已損壞(它包含無效的 ''\\\\0'' 字元)。請移除這些字元或刪除檔案。
warning.create.directory.with.dot=注意: 名稱中的 "." 會被視為一般字元。如果要建立嵌套目錄，請改用 "/"
warning.create.directory.with.ignored.name=正在嘗試建立包含忽略名稱(''{0}'')的目錄；結果將不可見
warning.create.package.with.ignored.name=正在嘗試建立包含忽略名稱(''{0}'')的軟體套件；結果將不可見
warning.delete.all.files.and.subdirectories=\\n“{0}”中的所有檔案和子目錄將被刪除。\\n您可能無法完全撤消此動作!
warning.delete.all.files.and.subdirectories.in.the.selected.directory=\\n所選目錄中的所有檔案和子目錄將被刪除。\\n您可能無法完全撤消此動作!
warning.load.file.from.share=您正在開啟來自網絡共享的檔案。是否要繼續?\\n{0}
warning.load.project.from.share=您正在開啟來自網絡共享的專案。您是否信任此位置?\\n{0}
warning.use.rest.api.0.and.trust.host.1=''{0}'' API 已請求。您信任 ''{1}'' 嗎?
warning.use.rest.api.0.and.trust.host.unknown=已請求 ''{0}'' API。您是否信任未知主機?
warning.use.rest.api.block.unknown.hosts=是否要阻止來自未知主機的請求?
web.preview.file.editor.name={0} 的預覽
web.preview.reload.mode.disabled=已停用
web.preview.reload.mode.on.change=更改時
web.preview.reload.mode.on.save=儲存時
welcome.screen.action.docs.how.tos.action.text=文檔和指南
welcome.screen.all.settings.link=所有設定…
welcome.screen.check.for.updates.comment=更新。
welcome.screen.color.theme.header=外觀
welcome.screen.configure.action.text=組態
welcome.screen.copy.about.action.text=複製有關資訊
welcome.screen.customize.title=自訂
welcome.screen.drop.files.to.open.text=將檔案拖放到此處以開啟
welcome.screen.empty.projects.create.comment=從頭建立新項目。
welcome.screen.empty.projects.open.comment=從磁碟或版本控制中開啟現有專案。
welcome.screen.ide.font.size.label=IDE 字體:
welcome.screen.learnIde.help.and.resources.text=幫助和資源
welcome.screen.learnIde.interactive.courses.text=互動課程
welcome.screen.learnIde.title=學習
welcome.screen.logo.version.label=版本 {0}
welcome.screen.more.actions.link.text=更多動作
welcome.screen.plugins.title=延伸模組
welcome.screen.projects.title=專案
welcome.screen.quick.start.action.text=快速開始
welcome.screen.recent.projects.accessible.name=最近的專案
welcome.screen.recent.projects.branch.label.accessible.name=分支 {0}
welcome.screen.recent.projects.name.label.unavailable.accessible.name={0} (不可用)
welcome.screen.search.projects.empty.text=搜尋專案
whats.new.action.custom.description=了解此版本的 {0} 中的新功能
whats.new.action.custom.text={0} 最新變化(_N)
whats.new.notification.action=檢視最新變化
whats.new.notification.text={0} {1} 登場!
whats.new.notification.text.regular.language={0} {1} 已推出!
whats.new.timeout.action=您可以<a href="{0}" class="link" target="_blank">在瀏覽器中開啟此頁面</a>或稍後重試。
whats.new.timeout.message=無法載入該頁面的內容。請檢查您的互聯網連線。
whats.new.timeout.title=無法載入頁面
window.title.switcher=切換器
window.titleButton.close=關閉
window.titleButton.maximize=最大化
window.titleButton.minimize=最小化
window.titleButton.restore=還原
windows.10.light.theme.name=Windows 10 淺色
windows.native.common.dialog.all=所有檔案
windows.native.common.dialog.open=開啟
windows.native.common.dialog.select.folder=選擇目錄
wrong.http.range.response=HTTP 範圍響應的行過長 {0}
wrong.number.of.arguments.usage.ide.executable.exit=實參數量錯誤。用法: <ide executable> exit [--restart]
wrong.number.of.arguments.usage.ide.executable.save=實參數量錯誤。用法: <ide 可執行檔案> 儲存
wsl.cant.parse.ip.no.output=無法解析 {0}，因為輸出未包含足夠的資料。請參閱 idea.log 了解特定錯誤。
wsl.cant.parse.ip.process.failed=由於程序失敗，無法解析 {0}。請參閱 idea.log 了解特定錯誤。
wsl.enter.root.password.dialog.title=輸入根密碼
wsl.error.host.ip.not.obtained.message=無法獲取 WSL 發行版的主機 IP: {0}
wsl.executing.process=正在執行 WSL 程序
wsl.linux.distribution.label=Linux 發行版(&D):
wsl.no.distribution.found.error=WSL: 應設定 Linux 發行版
wsl.no.installed.distributions=沒有安裝發行版
wsl.no.rsync=請在您的 {0} WSL 上安裝 rsync
wsl.no_path=找不到此發行版特定於 Windows 的部分，無法瀏覽
wsl.not.installed.dialog.message=在 %PATH% 中找不到 wsl.exe，請安裝 WSL
wsl.not.installed.distribution=未安裝 {0}
wsl.rsync.unable.to.copy.files.dialog.message=無法將檔案複製到 {0}
wsl.rsync.unable.to.create.target.dir.message=無法建立目標目錄 {0}
wsl.sudo.password.for.root.label={0} 根的 Sudo 密碼:
wsl.target.introspection.step.command.finished.with.exit.code=程序已結束，離開程式碼為 {0}
wsl.target.introspection.step.completed.successfully=內省成功完成!
wsl.target.introspection.step.completed.with.errors=內省完成但有錯誤。
wsl.target.introspection.step.description=WSL 發行版內省
wsl.target.language.step.description=用於 {1} 的 {0} 執行時組態
wsl.target.tool.step.description=WSL 組態
wsl.win.ip=主機(Windows) IP
wsl.wsl.ip=WSL (Linux) IP
x.and.y={0} 和 {1}
xnext.comment.unavailable=啟用 XNext 時，此設定不可用"
`;

exports[`dev messages/InspectionGadgetsBundle.properties 1`] = `
"0.will.no.longer.be.overridable.by.1={0} 將不再可被 {1} 覆寫
absolute.alignment.in.user.interface.display.name=AWT/Swing 程式碼中的絕對對齊
absolute.alignment.in.user.interface.fix.family.name=取代為常數
absolute.alignment.in.user.interface.problem.descriptor=使用了絕對對齊常數 <code>{0}.\\#ref</code> \\#loc
abstract.class.extends.concrete.class.display.name=抽象類別擴展具體類別
abstract.class.extends.concrete.class.problem.descriptor=類別 <code>\\#ref</code> 被宣告為 'abstract'，並擴展一個具體類別 \\#loc
abstract.class.naming.convention.element.description=抽象類別
abstract.class.never.implemented.display.name=沒有具體子類別的抽象類別
abstract.class.never.implemented.problem.descriptor=抽象類別 <code>\\#ref</code> 沒有具體子類別 \\#loc
abstract.class.with.only.one.direct.inheritor.display.name=只有一個直接繼承者的抽象類別
abstract.class.with.only.one.direct.inheritor.problem.descriptor=只有一個直接繼承者的抽象類別 <code>\\#ref</code> \\#loc
abstract.class.without.abstract.methods.display.name=沒有 'abstract' 方法的抽象類別
abstract.class.without.abstract.methods.ignore.utility.class.option=忽略實用程序類別
abstract.class.without.abstract.methods.problem.descriptor=類別 <code>\\#ref</code> 被宣告為 'abstract'，並且沒有 'abstract' 方法 \\#loc
abstract.method.call.in.constructor.display.name=物件建構期間呼叫的 abstract 方法
abstract.method.call.in.constructor.problem.descriptor=物件建構期間呼叫 'abstract' 方法 <code>\\#ref()</code> \\#loc
abstract.method.overrides.abstract.method.display.name=abstract 方法覆寫 abstract 方法
abstract.method.overrides.abstract.method.ignore.different.javadoc.option=忽略 Javadoc 與其 super 方法不同的方法
abstract.method.overrides.abstract.method.problem.descriptor=abstract 方法 <code>\\#ref()</code> 覆寫 abstract 方法 \\#loc
abstract.method.overrides.abstract.method.remove.quickfix=移除冗餘 abstract 方法宣告
abstract.method.overrides.concrete.method.display.name=abstract 方法覆寫具體方法
abstract.method.overrides.concrete.method.problem.descriptor=abstract 方法 <code>\\#ref()</code> 覆寫具體方法 \\#loc
abstract.method.with.missing.implementations.display.name=缺少實作的 abstract 方法
abstract.method.with.missing.implementations.problem.descriptor=abstract 方法 <code>\\#ref()</code> 未在每個子類別中實作 \\#loc
access.to.non.thread.safe.static.field.from.instance.class.chooser.title=選擇非執行緒安全類別
access.to.non.thread.safe.static.field.from.instance.display.name=非執行緒安全的 'static' 欄位存取
access.to.non.thread.safe.static.field.from.instance.field.problem.descriptor=存取類型為 ''{0}'' 的非執行緒安全 static 欄位 <code>\\#ref</code> \\#loc
access.to.non.thread.safe.static.field.from.instance.option.title=非執行緒安全類別\\:
access.to.static.field.locked.on.instance.display.name=存取執行個體資料上鎖定的 'static' 欄位
access.to.static.field.locked.on.instance.fix.name=忽略類型 ''{0}'' 的 static 欄位
access.to.static.field.locked.on.instance.problem.descriptor=存取執行個體資料上鎖定的 static 欄位 <code>\\#ref</code> \\#loc
accessing.non.public.field.of.another.object.display.name=存取另一個物件的非 public 欄位
accessing.non.public.field.of.another.object.problem.descriptor=直接存取另一個物件的非 public 欄位 <code>\\#ref</code> \\#loc
add.0.to.ignore.if.annotated.by.list.quickfix=將 ''{0}'' 新增到“由以下物件註解時忽略”列表中
add.catch.section.fix.family.name=新增 'catch' 子句
add.read.write.object.methods.fix.family.name=新增始終拋出異常的 'readObject()' 和 'writeObject()' 方法
add.read.write.object.methods.fix.text=新增始終拋出異常的 'writeObject()' 方法
add.read.write.object.methods.fix.text2=新增始終拋出異常的 'readObject()' 方法
add.serialversionuidfield.quickfix=新增 'serialVersionUID' 欄位
add.this.qualifier.quickfix=新增 'this' 限定符
add.throws.clause.fix.family.name=修復 'throws' 子句
all.levels.option=所有日誌級別
allow.resource.to.be.opened.inside.a.try.block=允許在 'try' 塊內開啟資源
ambiguous.field.access.display.name=對繼承欄位的存取類似於對周圍程式碼中元素的存取
ambiguous.field.access.hides.field.problem.descriptor=存取超類別 ''{0}'' 中的 <code>\\#ref</code> 欄位類似於存取周圍類別中的欄位 \\#loc
ambiguous.field.access.hides.local.variable.problem.descriptor=存取超類別 ''{0}'' 中的 <code>\\#ref</code> 欄位類似於存取區域變數 \\#loc
ambiguous.field.access.hides.parameter.problem.descriptor=存取超類別 ''{0}'' 中的 <code>\\#ref</code> 欄位類似於存取參數 \\#loc
ambiguous.field.access.navigate.quickfix=導覽到明顯存取過的{0, choice, 1\\#區域變數|2\\#參數|3\\#欄位}
ambiguous.field.access.quickfix=將 'super' 限定符新增到欄位存取
ambiguous.method.call.display.name=對繼承方法的呼叫類似於對本地方法的呼叫
ambiguous.method.call.problem.descriptor=對來自超類別 ''{0}'' 的方法 <code>\\#ref()</code> 的呼叫類似於對來自類別 ''{1}'' 的方法的呼叫 \\#loc
ambiguous.method.call.quickfix=向方法呼叫中新增 'super' 限定符
annotation.class.display.name=註解接口
annotation.class.problem.descriptor=註解接口 <code>\\#ref</code> \\#loc
annotation.display.name=註解
annotation.naming.convention.element.description=註解接口
annotation.problem.descriptor=註解 <code>\\#ref</code> \\#loc
anonymous.class.field.hides.containing.method.variable.problem.descriptor=匿名類別欄位 <code>\\#ref</code> 隱藏包含方法中的變數 \\#loc
anonymous.class.parameter.hides.containing.method.variable.problem.descriptor=匿名類別參數 <code>\\#ref</code> 隱藏包含方法中的變數 \\#loc
anonymous.class.variable.hides.containing.method.variable.display.name=匿名類別變數隱藏包含方法中的變數
anonymous.class.variable.hides.containing.method.variable.problem.descriptor=匿名類別區域變數 <code>\\#ref</code> 隱藏包含方法中的變數 \\#loc
anonymous.extends.concrete.collection.problem.descriptor=匿名類別顯式擴展 ''{0}'' \\#loc
anonymous.extends.thread.problem.descriptor=匿名類別直接擴展 'java.lang.Thread' \\#loc
anonymous.extends.throwable.problem.descriptor=匿名類別直接擴展 'java.lang.Throwable' \\#loc
anonymous.inner.class.display.name=匿名類別可被取代為內部類別
anonymous.inner.class.problem.descriptor=匿名類別 <code>\\#ref</code> \\#loc
anonymous.inner.class.with.too.many.methods.display.name=具有太多方法的匿名類別
anonymous.inner.class.with.too.many.methods.problem.descriptor=具有太多方法的匿名類別 (方法計數 \\= {0}) \\#loc
anonymous.inner.may.be.named.static.inner.class.display.name=匿名類別可能是命名為 'static' 的內部類別
anonymous.inner.may.be.named.static.inner.class.problem.descriptor=匿名類別 <code>\\#ref</code> 可能是命名為 'static' 的內部類別 \\#loc
anonymous.inner.may.be.named.static.inner.class.quickfix=轉換為命名 'static' 內部類別
any.method.may.close.resource.argument=任何方法都可能關閉作為實參傳遞的資源
array.allocation.zero.length.display.name=零長度陣列分配
array.allocation.zero.length.problem.descriptor=零長度陣列的分配 \\#loc
array.can.be.replaced.with.enum.values=可以將陣列取代為枚舉值
array.can.be.replaced.with.enum.values.family.quickfix=將陣列取代為 EnumType.values()
array.can.be.replaced.with.enum.values.quickfix=將陣列取代為 {0}.values()
array.comparison.display.name=使用 '\\=\\=' 而不是 'Arrays.equals()' 進行陣列比較
array.comparison.problem.descriptor=使用 <code>\\#ref</code> 而不是 'Arrays.equals()' 來比較陣列物件 \\#loc
array.creation.without.new.keyword.family.quickfix=新增 'new' 表達式
array.creation.without.new.keyword.name=建立不帶 'new' 表達式的陣列
array.creation.without.new.keyword.quickfix=新增 ''new {0}''
array.equals.problem.descriptor=或許應當使用 ''{0}'' 完成陣列比較''
array.hash.code.display.name=在陣列上呼叫了 'hashCode()'
array.hash.code.fix.family.name=取代為 'Arrays.hashCode()' 呼叫
array.hash.code.problem.descriptor=陣列上呼叫的 <code>\\#ref()</code> 可能應當是 'Arrays.hashCode()' \\#loc
array.hashcode.problem.descriptor=或許應當使用 ''{0}'' 完成陣列雜湊程式碼計算
array.length.in.loop.condition.display.name=迴圈條件下的 Array.length
array.length.in.loop.condition.problem.descriptor=檢查迴圈條件下的陣列 <code>\\#ref</code> \\#loc
array.objects.equals.display.name=對陣列使用淺層方法或 'Objects' 方法
arrays.as.list.with.one.argument.problem.descriptor=僅使用一個實參呼叫 <code>\\#ref()</code> \\#loc
arrays.as.list.with.zero.arguments.problem.descriptor=呼叫 <code>\\#ref()</code> 以建立空列表 \\#loc
arrays.as.list.with.zero.or.one.argument.display.name='Arrays.asList()' 呼叫的實參過少
assert.can.be.if.quickfix=將 'assert' 取代為 'if' 語句
assert.keyword.is.considered.an.assertion='assert' 關鍵字被視為斷言
assert.message.not.string.display.name='assert' 訊息不是字串
assert.message.not.string.only.warn.boolean.option=僅當 'assert' 訊息為 'boolean' 或 'java.lang.Boolean' 時發出警告
assert.message.of.type.boolean.problem.descriptor=類型為 ''{0}'' 的 ''assert'' 訊息 \\#loc
assert.statement.display.name='assert' 語句
assert.with.side.effects.call.mutates.expression=呼叫 ''{0}()'' 會改變 ''{1}''
assert.with.side.effects.call.mutates.field=呼叫 ''{0}()'' 會改變欄位 ''{1}''
assert.with.side.effects.call.performs.io=呼叫 ''{0}()'' 會執行輸入/輸出動作
assert.with.side.effects.display.name=具有副作用的 'assert' 語句
assert.with.side.effects.problem.descriptor=<code>\\#ref</code> 具有副作用\\: {0} \\#loc
assert.without.message.problem.descriptor=沒有訊息的 <code>\\#ref()</code> \\#loc
assert.without.message.quick.fix.family.name=新增錯誤訊息
assertion.can.be.if.name=斷言可被取代為 'if' 語句
asserts.without.messages.display.name=斷言上缺少訊息
assignment.and.return.of.mutable.record.component={1} 記錄元件的隱式{0, choice, 1\\#指派|2\\#返回|3\\#指派和返回} <code>\\#ref</code> \\#loc
assignment.of.field.with.mutable.type.problem.descriptor=指派給參數 <code>\\#ref</code> 中的 {0} 欄位 ''{1}'' \\#loc
assignment.or.return.of.field.with.mutable.type.display.name=具有可變類型的欄位的指派或返回
assignment.replaceable.with.operator.assignment.display.name=指派可被取代為運算符指派
assignment.replaceable.with.operator.assignment.ignore.conditional.operators.option=忽略條件運算符
assignment.replaceable.with.operator.assignment.ignore.obscure.operators.option=忽略模糊的 ^ 和 % 運算符
assignment.replaceable.with.operator.assignment.problem.descriptor=<code>\\#ref</code> 可以簡化為 ''{0}'' \\#loc
assignment.to.catch.block.parameter.display.name=指派給 'catch' 塊參數
assignment.to.catch.block.parameter.problem.descriptor=指派給 'catch' 塊參數 <code>\\#ref</code> \\#loc
assignment.to.for.loop.parameter.check.foreach.option=檢查增強型 'for' 迴圈參數
assignment.to.for.loop.parameter.display.name=指派給 'for' 迴圈參數
assignment.to.for.loop.parameter.problem.descriptor=指派給 for 迴圈參數 <code>\\#ref</code> \\#loc
assignment.to.lambda.parameter.display.name=指派給 lambda 參數
assignment.to.lambda.parameter.problem.descriptor=指派給 lambda 參數 <code>\\#ref</code> \\#loc
assignment.to.method.parameter.display.name=指派給方法參數
assignment.to.method.parameter.ignore.transformation.option=<html>如果指派是原始參數的轉換，則忽略</html>
assignment.to.method.parameter.problem.descriptor=指派給方法參數 <code>\\#ref</code> \\#loc
assignment.to.null.display.name='null' 指派
assignment.to.null.option=忽略對欄位的指派
assignment.to.null.problem.descriptor='null' 已指派給變數 <code>\\#ref</code> \\#loc
assignment.to.static.field.from.instance.method.display.name=從實例上下文指派給 static 欄位
assignment.to.static.field.from.instance.method.problem.descriptor=從實例上下文指派給 static 欄位 <code>\\#ref</code> \\#loc
assignment.to.superclass.field.display.name=建構函式將值賦給在超類別中定義的欄位
assignment.to.superclass.field.problem.descriptor=指派給在超類別 ''{1}'' 中定義的欄位 ''{0}'' \\#loc
assignment.used.as.condition.display.name=用作條件的指派
assignment.used.as.condition.problem.descriptor=指派 <code>\\#ref</code> 作為條件使用 \\#loc
atomic.field.updater.issues.display.name='AtomicFieldUpdater' 宣告不一致
atomic.field.updater.not.static.final.display.name='AtomicFieldUpdater' 欄位未被宣告為 'static final'
atomic.field.updater.not.static.final.problem.descriptor={0} 欄位 <code>\\#ref</code> 未被宣告為 ''static final'' \\#loc
auto.boxing.display.name=自動裝箱
auto.boxing.ignore.added.to.collection.option=忽略新增到集合的表達式
auto.boxing.make.boxing.explicit.quickfix=使裝箱顯式
auto.boxing.problem.descriptor=自動裝箱 <code>\\#ref</code> \\#loc
auto.closeable.resource.display.name=在沒有 'try-with-resources' 的情況下使用 AutoCloseable
auto.closeable.resource.problem.descriptor=在沒有 ''try-with-resources'' 語句的情況下使用 ''{0}'' \\#loc
auto.closeable.resource.quickfix=忽略此方法返回的 'AutoCloseable'
auto.closeable.resource.quickfix.preview=將方法 <code>{0}</code> 新增到忽略方法列表中
auto.closeable.resource.returned.option=忽略從所有方法呼叫返回的 AutoCloseable 執行個體
auto.unboxing.display.name=自動拆箱
auto.unboxing.make.unboxing.explicit.quickfix=使拆箱顯式
auto.unboxing.problem.descriptor=自動拆箱 <code>\\#ref</code> \\#loc
await.not.in.loop.display.name=未在迴圈中呼叫的 'await()'
await.not.in.loop.problem.descriptor=<code>\\#ref()</code> 呼叫不在迴圈中 \\#loc
await.without.corresponding.signal.display.name=沒有相應 'signal()' 的 'await()'
await.without.corresponding.signal.problem.descriptor=在沒有相應 <code>signal()</code> 或 <code>signalAll()</code> 的情況下呼叫 <code>\\#ref()</code> \\#loc
bad.exception.caught.display.name=已捕獲禁止的 'Exception'
bad.exception.caught.problem.descriptor=已捕獲禁止異常 <code>\\#ref</code> \\#loc
bad.exception.declared.display.name=已宣告禁止異常
bad.exception.declared.problem.descriptor=已宣告禁止異常 <code>\\#ref</code> \\#loc
bad.exception.thrown.display.name=已拋出禁止異常
bad.exception.thrown.problem.descriptor=已拋出禁止異常 ''{0}'' \\#loc
bad.oddness.display.name=可疑的奇數檢查
bad.oddness.problem.descriptor=對負值進行奇數檢查將會失敗 \\#loc
big.decimal.equals.display.name=在 'BigDecimal' 上調用了 'equals()'
big.decimal.equals.problem.descriptor=BigDecimal 值之間的 <code>\\#ref()</code> 可能應當是 'compareTo()' \\#loc
big.decimal.method.without.rounding.called.display.name='BigDecimal' 方法呼叫沒有舍入模式實參
big.decimal.method.without.rounding.called.problem.descriptor=在沒有舍入模式實參的情況下呼叫了 'BigDecimal.\\#ref()'
bigdecimal.legacy.method.display.name=呼叫了 'BigDecimal' 遺留方法
bigdecimal.legacy.method.problem.descriptor=對 'BigDecimal.\\#ref()' 的呼叫可以使用 'RoundingMode' 枚舉常數
bigdecimal.legacy.method.quickfix=使用 'RoundingMode' 枚舉常數
boolean.constructor.display.name=布爾建構函式呼叫
boolean.constructor.problem.descriptor=布爾建構函式呼叫 \\#loc
boolean.constructor.simplify.quickfix=簡化
boolean.expression.can.be.simplified.problem.descriptor=<code>\\#ref</code> 可以簡化為 ''{0}'' \\#loc
boolean.expression.does.not.modify.problem.descriptor=<code>\\#ref</code> 未修改 ''{0}'' 的值 \\#loc
boolean.expression.may.be.conditional.display.name=布爾表達式可被取代為條件表達式
boolean.expression.remove.compound.assignment.quickfix=移除無意義的複合指派
boolean.field.always.inverted.problem.descriptor=布爾欄位 <code>\\#ref</code> 始終反轉 \\#loc
boolean.method.name.must.start.with.question.display.name=布爾方法名稱必須以疑問詞開頭
boolean.method.name.must.start.with.question.problem.descriptor=布爾方法名稱 <code>\\#ref</code> 未以疑問詞開頭 \\#loc
boolean.method.name.must.start.with.question.table.label=布爾方法名稱前綴\\:
boolean.parameter.constructor.problem.descriptor='public' 建構函式 <code>\\#ref()</code> 具有 'boolean' 參數 \\#loc
boolean.parameter.display.name='public' 方法具有 'boolean' 參數
boolean.parameter.only.report.multiple.option=僅報告具有多個布爾參數的方法
boolean.parameter.problem.descriptor='public' 方法 <code>\\#ref()</code> 具有 'boolean' 參數 \\#loc
boolean.parameters.constructor.problem.descriptor='public' 建構函式 <code>\\#ref()</code> 具有 'boolean' 參數 \\#loc
boolean.parameters.problem.descriptor='public' 方法 <code>\\#ref()</code> 具有 'boolean' 參數 \\#loc
boolean.variable.always.inverted.display.name=布爾變數始終反轉
boolean.variable.always.inverted.problem.descriptor=布爾變數 <code>\\#ref</code> 始終反轉 \\#loc
bounded.wildcard.contravariant.descriptor=可以泛化為 <code>? super \\#ref</code> \\#loc
bounded.wildcard.covariant.descriptor=可以泛化為 <code>? extends \\#ref</code> \\#loc
bounded.wildcard.display.name=可以使用有界萬用字元
bounded.wildcard.report.instance.option=報告執行個體方法
bounded.wildcard.report.invariant.option=報告固定類別
bounded.wildcard.report.private.option=報告 private 方法
boxing.boxed.value.display.name=裝箱已裝箱的值
boxing.boxed.value.problem.descriptor=裝箱已裝箱的 <code>\\#ref</code> \\#loc
boxing.boxed.value.quickfix=移除不必要的裝箱
break.statement.display.name='break' 語句
break.statement.with.label.display.name=帶標籤的 'break' 語句
break.statement.with.label.problem.descriptor=帶標籤的 <code>\\#ref</code> 語句 \\#loc
busy.wait.display.name=忙等待
busy.wait.problem.descriptor=在迴圈中呼叫 <code>Thread.\\#ref()</code>，可能處於忙等待 \\#loc
c.style.array.declaration.display.name=C 樣式陣列宣告
c.style.array.declaration.replace.quickfix=取代為 Java 樣式陣列宣告
cached.number.constructor.call.display.name=數字建構函式呼叫具有基元實參
cached.number.constructor.call.ignore.string.arguments.option=忽略具有字串實參的新數字表達式
cached.number.constructor.call.problem.descriptor=數字建構函式呼叫具有基元實參 \\#loc
cached.number.constructor.call.report.only.deprecated=僅在建構函式為 @Deprecated 時報告
call.to.date.tostring.display.name=呼叫 'Date.toString()'
call.to.date.tostring.problem.descriptor=國際化上下文中使用的 <code>Date.\\#ref()</code> \\#loc
call.to.native.method.while.locked.display.name=鎖定時呼叫 'native' 方法
call.to.native.method.while.locked.problem.descriptor=在同步上下文中呼叫本地方法 <code>\\#ref()</code> \\#loc
call.to.numeric.tostring.display.name=呼叫 'Number.toString()'
call.to.numeric.tostring.problem.descriptor=國際化上下文中呼叫的 <code>Number.\\#ref()</code> \\#loc
call.to.private.setter.in.class.option=僅在 setter 為 'private' 時報告
call.to.private.simple.getter.in.class.option=僅在 getter 為 'private' 時報告
call.to.simple.getter.in.class.display.name=從類別內呼叫簡單 getter
call.to.simple.getter.in.class.ignore.option=忽略其他物件上的 getter 呼叫
call.to.simple.getter.in.class.inline.quickfix=內聯呼叫 getter
call.to.simple.getter.in.class.problem.descriptor=從類別內呼叫簡單 getter <code>\\#ref()</code> \\#loc
call.to.simple.setter.in.class.display.name=從類別內呼叫簡單 setter
call.to.simple.setter.in.class.ignore.option=忽略其他物件上的 setter 呼叫
call.to.simple.setter.in.class.inline.quickfix=內聯呼叫 setter
call.to.simple.setter.in.class.problem.descriptor=從類別內呼叫簡單 setter <code>\\#ref()</code> \\#loc
call.to.string.concat.can.be.replaced.by.operator.display.name=對 'String.concat()' 的呼叫可被取代為 '+'
call.to.string.concat.can.be.replaced.by.operator.problem.descriptor=對 <code>\\#ref()</code> 的呼叫可被取代為 '+' 表達式 \\#loc
call.to.string.concat.can.be.replaced.by.operator.quickfix=用 '+' 取代 'concat()'
call.to.suspicious.string.method.display.name=呼叫可疑的 'String' 方法
call.to.suspicious.string.method.problem.descriptor=國際化上下文中呼叫的 <code>String.\\#ref()</code> \\#loc
cast.conflicts.with.instanceof.display.name=轉換與 'instanceof' 衝突
cast.conflicts.with.instanceof.problem.descriptor=轉換為 ''{0}'' 類型將與前面的 ''instanceof {1}'' 檢查衝突
cast.conflicts.with.instanceof.quickfix1=在轉換中將 ''{0}'' 取代為 ''{1}''
cast.conflicts.with.instanceof.quickfix2=在 instanceof 中將 ''{0}'' 取代為 ''{1}''
cast.that.loses.precision.display.name=損失精度的數字轉換
cast.that.loses.precision.negative.problem.descriptor=''{0}'' 到 <code>\\#ref</code> 的轉換可能導致負實參的精度損失 \\#loc
cast.that.loses.precision.option=忽略從 int 到 char 的轉換
cast.that.loses.precision.problem.descriptor=''{0}'' 到 <code>\\#ref</code> 的轉換可能導致精度損失 \\#loc
cast.to.concrete.class.problem.descriptor=轉換為具體類別 <code>{0}</code> \\#loc
casting.to.incompatible.interface.display.name=轉換為不相容的類型
casting.to.incompatible.interface.problem.descriptor=將類型為 ''{1}'' 的表達式轉換為不相容的{0, choice, 1\\#接口|2\\#類別} <code>\\#ref</code> \\#loc
caught.exception.immediately.rethrown.display.name=捕獲的異常被立即重新拋出
caught.exception.immediately.rethrown.problem.descriptor=捕獲的異常 <code>\\#ref</code> 被立即重新拋出 \\#loc
chain.of.class.equality.checks.problem.descriptor=類別相等檢查鏈指示抽象失敗 \\#loc
chain.of.instanceof.checks.display.name='instanceof' 檢查鏈
chain.of.instanceof.checks.problem.descriptor='instanceof' 檢查鏈指示抽象失敗 \\#loc
chained.equality.comparisons.display.name=鏈式相等比較
chained.equality.comparisons.problem.descriptor=鏈式相等比較 <code>\\#ref</code> \\#loc
chained.method.call.display.name=鏈式方法呼叫
chained.method.call.ignore.option=忽略欄位初始設定式中的鏈式方法呼叫
chained.method.call.ignore.self.types.option=忽略對返回類型與其封閉類別相同的方法的呼叫
chained.method.call.problem.descriptor=鏈式方法呼叫 <code>\\#ref()</code> \\#loc
change.modifier.fix.family.name=更改修飾符
change.modifier.package.private.quickfix=設為 package-private
change.modifier.quickfix=設為 ''{0}''
channel.opened.not.closed.display.name=開啟了 'Channel'，但未安全關閉
char.used.in.arithmetic.content.cast.fix.family.name=插入轉換
char.used.in.arithmetic.context.cast.quickfix=插入到 {0} 的轉換
char.used.in.arithmetic.context.display.name=在算術上下文中使用 'char' 表達式
char.used.in.arithmetic.context.problem.descriptor=算術上下文中使用了 'char' \\#loc
char.used.in.arithmetic.context.quickfix=轉換為字串字面量
character.comparison.display.name=字元比較
character.comparison.problem.descriptor=國際化上下文中的字元比較 <code>\\#ref</code> \\#loc
checkbox.ignore.null.on.wrong.side=忽略錯誤側的 'null'
checked.exception.class.display.name=已檢查的異常類別
checked.exception.class.problem.descriptor=已檢查的異常類別 <code>\\#ref</code> \\#loc
choose.autocloseable.type.to.ignore.title=選擇要忽略的 AutoCloseable 資源類型
choose.class=選擇類別
choose.class.hierarchy.to.ignore.title=選擇要忽略的類別層次結構
choose.class.type.to.ignore=選擇要忽略的類別
choose.exception.class=選擇異常類別
choose.exception.label=被禁止的異常\\:
choose.io.resource.type.to.ignore=選擇要忽略的 I/O 資源類型
choose.logger.class=選擇記錄器類別
class.escapes.defined.scope.display.module.option=報告在模組 API 中公開的非匯出類別(Java 9+)
class.escapes.defined.scope.display.name=類別在其可見性作用域之外公開
class.escapes.defined.scope.display.package.option=報告在 package-local API 中公開的 private 類別
class.escapes.defined.scope.display.public.option=報告在公開 API 中公開的不可存取類別
class.escapes.defined.scope.java9.modules.descriptor=類別 <code>\\#ref</code> 未從模組 ''{0}'' 匯出
class.escapes.defined.scope.problem.descriptor=類別 <code>\\#ref</code> 在其定義的可見性作用域之外公開 \\#loc
class.extends.utility.class.display.name=類別擴展實用程序類別
class.extends.utility.class.ignore.utility.class.option=如果覆寫類別為實用程序類別，則忽略
class.extends.utility.class.problem.descriptor=類別 <code>\\#ref</code> 擴展實用程序類別 ''{0}'' \\#loc
class.independent.of.module.display.name=獨立於其模組的類別
class.independent.of.module.problem.descriptor=類別 <code>\\#ref</code> 在其模組中沒有相依或相依項 \\#loc
class.initializer.display.name=非 'static' 初始設定式
class.initializer.may.be.static.display.name=執行個體初始設定式可以設為 'static'
class.initializer.may.be.static.problem.descriptor=類別初始設定式可能為 'static' \\#loc
class.initializer.move.code.to.constructor.quickfix=將初始設定式程式碼移至建構函式
class.initializer.option=僅在類別具有一個或多個建構函式時警告
class.initializer.problem.descriptor=非 'static' 初始設定式 \\#loc
class.loader.instantiation.display.name='ClassLoader' 實例化
class.loader.instantiation.problem.descriptor=實例化 <code>\\#ref</code> 可能造成安全問題 \\#loc
class.may.be.interface.convert.quickfix=將類別轉換為接口
class.may.be.interface.display.name='abstract' 類別可以是 'interface'
class.may.be.interface.java8.option=使用 Java 8 時報告包含非 abstract 方法的類別
class.may.be.interface.problem.descriptor=抽象類別 <code>\\#ref</code> 可能是接口 \\#loc
class.name=類別名
class.name.differs.from.file.name.display.name=類別名與檔名不同
class.name.differs.from.file.name.problem.descriptor=類別名 <code>\\#ref</code> 與檔名不同 \\#loc
class.name.prefixed.with.package.name.display.name=使用軟體套件名稱作為前綴的類別名
class.name.prefixed.with.package.name.problem.descriptor=類別名 <code>\\#ref</code> 以其軟體套件名稱開始 \\#loc
class.name.same.as.ancestor.name.display.name=類別名與上級名稱相同
class.name.same.as.ancestor.name.problem.descriptor=類別名 <code>\\#ref</code> 與其超類別的名稱之一相同 \\#loc
class.naming.convention.display.name=類別命名約定
class.naming.convention.element.description=類別
class.new.instance.display.name=對 'Class.newInstance()' 的呼叫不安全
class.new.instance.problem.descriptor=對 <code>\\#ref()</code> 的呼叫可能會拋出未宣告的已檢查的異常 \\#loc
class.only.used.in.one.module.display.name=僅在其他模組中使用的類別
class.only.used.in.one.module.problem.descriptor=類別 <code>\\#ref</code> 在其模組 ''{0}'' 中只有相依和/或相依性 \\#loc
class.only.used.in.one.package.display.name=僅在其他軟體套件中使用的類別
class.only.used.in.one.package.problem.descriptor=類別 <code>\\#ref</code> 在其軟體套件 ''{0}'' 中只有相依和/或相依項 \\#loc
class.references.subclass.display.name=類別參照其子類別之一
class.references.subclass.problem.descriptor=類別 ''{0}'' 參照子類別 <code>\\#ref</code> \\#loc
class.references.subclass.problem.descriptor.anonymous=匿名類別參照子類別 <code>\\#ref</code> \\#loc
class.too.deep.display.name=類別在繼承樹中太深
class.too.deep.inheritance.depth.limit.option=繼承深度限制\\:
class.too.deep.problem.descriptor=<code>\\#ref</code> 在繼承樹中太深 (繼承深度 \\= {0}) \\#loc
class.unconnected.to.package.display.name=獨立於其軟體套件的類別
class.unconnected.to.package.problem.descriptor=類別 <code>\\#ref</code> 在其軟體套件中沒有相依或相依項
class.with.only.private.constructors.display.name=僅包含 'private' 建構函式的類別應被宣告為 'final'
class.with.only.private.constructors.problem.descriptor=僅包含 'private' 建構函式的類別 <code>\\#ref</code> 應被宣告為 'final'
class.with.too.many.dependencies.display.name=相依過多的類別
class.with.too.many.dependencies.max.option=最大相依項數
class.with.too.many.dependencies.problem.descriptor=類別 ''{0}'' 的相依過多 ({1} > {2})
class.with.too.many.dependents.display.name=相依項過多的類別
class.with.too.many.dependents.max.option=最大相依項數
class.with.too.many.dependents.problem.descriptor=類別 ''{0}'' 的相依項過多 ({1} > {2})
class.with.too.many.transitive.dependencies.display.name=可傳遞相依項過多的類別
class.with.too.many.transitive.dependencies.max.option=最大可傳遞相依項數
class.with.too.many.transitive.dependencies.problem.descriptor=類別 ''{0}'' 的可傳遞相依項過多({1} > {2})
class.with.too.many.transitive.dependents.display.name=傳遞相依項過多的類別
class.with.too.many.transitive.dependents.max.option=最大傳遞相依項數
class.with.too.many.transitive.dependents.problem.descriptor=類別 ''{0}'' 的可傳遞相依項過多({1} > {2})
class.without.constructor.create.quickfix=生成空建構函式
class.without.constructor.display.name=不帶建構函式的類別
class.without.constructor.problem.descriptor=類別 <code>\\#ref</code> 沒有建構函式 \\#loc
class.without.logger.annotations.tab=註解
class.without.logger.loggers.tab=記錄器
class.without.no.arg.constructor.display.name=沒有無實參建構函式的類別
class.without.no.arg.constructor.ignore.option=如果類別具有預設建構函式，則忽略
class.without.no.arg.constructor.problem.descriptor=類別 <code>\\#ref</code> 缺少無實參建構函式 \\#loc
clone.doesnt.declare.clonenotsupportedexception.declare.quickfix=將 'CloneNotSupportedException' 新增到 throws 子句
clone.doesnt.declare.clonenotsupportedexception.display.name='clone()' 未宣告 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.problem.descriptor=<code>\\#ref()</code> \\#loc 未宣告 'CloneNotSupportedException'
clone.instantiates.new.array.problem.descriptor=''clone()'' 建立新的 {0} 陣列 \\#loc
clone.instantiates.objects.with.constructor.display.name='clone()' 用建構函式實例化物件
clone.instantiates.objects.with.constructor.problem.descriptor='clone()' 建立新的 <code>\\#ref</code> 執行個體 \\#loc
clone.method.in.non.cloneable.anonymous.class.problem.descriptor=<code>\\#ref()</code> 在派生自 ''{0}'' 的不可克隆匿名類別中定義 \\#loc
clone.method.in.non.cloneable.class.display.name=不可克隆類別中的 'clone()' 方法
clone.method.in.non.cloneable.class.problem.descriptor=<code>\\#ref()</code> 在不可克隆類別 ''{0}'' 中定義 \\#loc
clone.method.in.non.cloneable.interface.problem.descriptor=<code>\\#ref()</code> 在不可克隆接口 ''{0}'' 中定義 \\#loc
clone.returns.class.type.display.name='clone()' 應當具有等於其所包含類別的返回值類型
clone.returns.class.type.family.quickfix=將返回值類型更改為類別類型
clone.returns.class.type.problem.descriptor=''clone()'' 應當具有返回值類型 ''{0}'' \\#loc
clone.returns.class.type.quickfix=將返回值類型更改為 ''{0}''
cloneable.class.in.secure.context.display.name=安全上下文中的可克隆類別
cloneable.class.in.secure.context.problem.descriptor=類別 <code>\\#ref</code> 可能被克隆，影響安全性 \\#loc
cloneable.class.in.secure.context.quickfix=生成始終拋出異常的 'clone()' 方法
cloneable.class.without.clone.display.name=沒有 'clone()' 方法的可克隆類別
cloneable.class.without.clone.ignore.option=忽略由於繼承而可克隆的類別
cloneable.class.without.clone.ignore.when.clone.called.option=如果呼叫超類別的 clone() 方法需要 Cloneable，則忽略
cloneable.class.without.clone.problem.descriptor=<code>\\#ref</code> 為 'Cloneable'，但未定義 'clone()' 方法 \\#loc
cloneable.class.without.clone.quickfix=生成 'clone()' 方法
cloneable.class.without.clone.todo.message=TODO\\: 複製此處的可變狀態，這樣此克隆就不能更改初始克隆的內部項
collection.added.to.self.display.name=集合已新增到自身
collection.added.to.self.problem.descriptor=在以自身作為實參的集合 <code>\\#ref</code> 上調用了 ''{0}()'' \\#loc
collection.declared.by.class.display.name=按類別 (而不是接口) 宣告的集合
collection.declared.by.class.ignore.locals.option=忽略區域變數
collection.declared.by.class.ignore.private.members.option=忽略 'private' 欄位和方法
collection.declared.by.class.problem.descriptor=<code>\\#ref</code> 的宣告可能應當被削弱為 ''{0}'' \\#loc
collections.field.access.replaceable.by.method.call.display.name=對空集合欄位的參照可被取代為方法呼叫
collections.field.access.replaceable.by.method.call.fix.family.name=將 Collections.EMPTY_* 取代為呼叫
collections.field.access.replaceable.by.method.call.problem.descriptor=<code>\\#ref</code> 可被取代為 ''Collections.{0}'' \\#loc
collections.must.have.initial.capacity.display.name=沒有初始容量的集合
collections.must.have.initial.capacity.problem.descriptor=沒有初始容量的 <code>new \\#ref()</code> \\#loc
commented.out.code.delete.quickfix=刪除註釋
commented.out.code.uncomment.quickfix=撤消程式碼註釋
comments.as.content.option=註釋計為內容
comparable.implemented.but.equals.not.overridden.display.name=已實作 'Comparable'，但 'equals()' 未被覆寫
comparable.implemented.but.equals.not.overridden.fix.add.note.name=新增 'ordering inconsistent with equals' JavaDoc 記錄
comparable.implemented.but.equals.not.overridden.fix.generate.equals.name=生成 'equals()' 方法
comparable.implemented.but.equals.not.overridden.problem.descriptor=類別 <code>\\#ref</code> 實作 'java.lang.Comparable'，但未覆寫 'equals()' \\#loc
comparator.not.serializable.display.name='Comparator' 類別未被宣告為 'Serializable'
comparator.not.serializable.problem.descriptor=比較器類別 <code>\\#ref</code> 未被宣告為可序列化 \\#loc
comparison.of.short.and.char.display.name=比較 'short' 和 'char' 值
comparison.of.short.and.char.problem.descriptor=short 和 char 值的相等比較 <code>\\#ref</code> \\#loc
comparison.to.nan.display.name=與 'Double.NaN' 或 'Float.NaN' 比較
comparison.to.nan.problem.descriptor1=與 <code>\\#ref</code> 的比較始終為 false \\#loc
comparison.to.nan.problem.descriptor2=與 <code>\\#ref</code> 的比較始終為 true \\#loc
concrete.class.method.parameter.problem.descriptor=具體類別 <code>\\#ref</code> 的參數 ''{0}'' \\#loc
concrete.class.use.display.name=具體類別的使用
condition.signal.display.name=呼叫 'signal()' 而不是 'signalAll()'
condition.signal.problem.descriptor=<code>\\#ref</code> 可能應當取代為 'signalAll()' \\#loc
conditional.can.be.pushed.inside.expression.display.name=可以將條件推送到分支表達式內部
conditional.can.be.pushed.inside.expression.option=在條件將僅作為方法呼叫的實參時忽略
conditional.can.be.pushed.inside.expression.problem.descriptor=條件表達式可以推送到分支內 \\#loc
conditional.can.be.pushed.inside.expression.quickfix=在分支內推送條件表達式
conditional.expression.display.name=條件表達式
conditional.expression.expression.context.option=忽略無法使用 if 語句的位置
conditional.expression.option=對簡單指派和返回值忽略
conditional.expression.problem.descriptor=條件表達式 <code>\\#ref</code> \\#loc
conditional.expression.quickfix=取代為 'if' 語句
conditional.expression.with.identical.branches.collapse.quickfix=摺疊條件表達式
conditional.expression.with.identical.branches.display.name=具有相同分支的條件表達式
conditional.expression.with.identical.branches.problem.descriptor=具有相同分支的條件表達式 <code>\\#ref</code> \\#loc
confusing.else.option=當 'if' 語句之後沒有其他語句時報告
confusing.floating.point.literal.change.quickfix=更改為規範形式
confusing.floating.point.literal.display.name=引起混淆的浮點字面量
confusing.floating.point.literal.option=在科學記數法中忽略浮點字面量
confusing.floating.point.literal.problem.descriptor=引起混淆的浮點字面量 <code>\\#ref</code> \\#loc
confusing.main.method.display.name=引起混淆的 'main()' 方法
confusing.main.method.problem.descriptor=方法 <code>\\#ref</code> 沒有簽名 'public static void main(String[])' \\#loc
confusing.octal.escape.sequence.display.name=引起混淆的八進制轉義序列
confusing.octal.escape.sequence.problem.descriptor=八進制轉義序列 <code>\\#ref</code> 後面緊跟數字 \\#loc
connection.opened.not.safely.closed.display.name=集合已開啟，但未安全關閉
consider.static.final.fields.constant.option=考慮 'static final' 欄位常數
constant.assert.condition.display.name='assert' 語句中的常數條件
constant.assert.condition.problem.descriptor=斷言條件 <code>\\#ref</code> 是常數 \\#loc
constant.conditional.expression.display.name=常數條件表達式
constant.conditional.expression.problem.descriptor=<code>\\#ref</code> 可以簡化為 ''{0}'' \\#loc
constant.conditional.expression.simplify.quickfix=簡化
constant.conditional.expression.simplify.quickfix.sideEffect=提取副作用並簡化
constant.declared.in.abstract.class.display.name=在 'abstract' 類別中宣告的常數
constant.declared.in.abstract.class.problem.descriptor=常數 <code>\\#ref</code> 在抽象類別中宣告 \\#loc
constant.declared.in.interface.display.name=在接口中宣告的常數
constant.declared.in.interface.problem.descriptor=常數 <code>\\#ref</code> 在接口中宣告 \\#loc
constant.for.zero.length.array.display.name=不必要的零長度陣列用法
constant.for.zero.length.array.problem.descriptor=零長度陣列可更改為常數 \\#loc
constant.for.zero.length.array.quickfix.family=取代為常數
constant.junit.assert.argument.display.name=常數斷言實參
constant.junit.assert.argument.problem.descriptor=實參 <code>\\#ref</code> 是常數 \\#loc
constant.math.call.display.name=對 'Math' 的常數呼叫
constant.math.call.problem.descriptor=對 <code>\\#ref()</code> 的常數呼叫可以簡化 \\#loc
constant.naming.convention.element.description=常數
constant.on.lhs.of.comparison.options.item.left=左
constant.on.lhs.of.comparison.options.item.right=右
constant.on.lhs.of.comparison.problem.descriptor=常數 <code>\\#ref</code> 位於比較的左側 \\#loc
constant.on.rhs.of.comparison.problem.descriptor=常數 <code>\\#ref</code> 位於比較的右側 \\#loc
constant.on.side.of.comparison.display.name=常數位於比較的錯誤一側
constant.value.variable.use.display.name=使用已知值為常數的變數
constant.value.variable.use.problem.descriptor=<code>\\#ref</code> 的值已知為常數 \\#loc
constant.with.mutable.field.naming.convention.element.description=具有可變類型的常數
constructor.visibility.option=忽略具有以下可見性的建構函式\\:
continue.or.break.from.finally.block.display.name='continue' 或 'break' 位於 'finally' 塊內
continue.or.break.from.finally.block.problem.descriptor=<code>\\#ref</code> 位於 'finally' 塊內 \\#loc
continue.statement.display.name='continue' 語句
continue.statement.with.label.display.name=帶標籤的 'continue' 語句
continue.statement.with.label.problem.descriptor=帶標籤的 <code>\\#ref</code> 語句 \\#loc
control.flow.statement.without.braces.add.quickfix=將大括號新增到語句
control.flow.statement.without.braces.display.name=不帶大括號的控制流語句
control.flow.statement.without.braces.message=將大括號新增到 ''{0}'' 語句
control.flow.statement.without.braces.problem.descriptor=不帶大括號的 <code>{0}</code> \\#loc
convert.double.unary.quickfix=取代為 ''{0}{1}''
convert.empty.anonymous.to.new.fix.family.name=移除 '{}'
convert.octal.literal.to.decimal.literal.quickfix=將八進制字面量轉換為十進制字面量
convert.octal.literals.to.decimal.literals.quickfix=將八進制字面量轉換為十進制字面量
convert.system.out.to.log.call.family.name=將 'System.out' 呼叫轉換為日誌呼叫
convert.system.out.to.log.call.name=將 ''System.out'' 呼叫轉換為對 ''{0}'' 的呼叫
convert.to.variable.arity.method.quickfix=轉換為 vararg 方法
copy.constructor.misses.field.display.name=複製缺少欄位的建構函式
copy.constructor.misses.field.problem.descriptor.1=複製未複製欄位 ''{0}'' 的建構函式
copy.constructor.misses.field.problem.descriptor.2=複製未複製欄位 ''{0}'' 和 ''{1}'' 的建構函式
copy.constructor.misses.field.problem.descriptor.3=複製未複製欄位 ''{0}''、''{1}'' 和 ''{2}'' 的建構函式
copy.constructor.misses.field.problem.descriptor.many=複製未複製 {0} 個欄位的建構函式
covariant.equals.display.name=協變 'equals()'
covariant.equals.problem.descriptor=<code>\\#ref()</code> 應當以 'Object' 作為其實參 \\#loc
create.default.branch.fix.family.name=建立 'default' 分支
create.missing.boolean.switch.branches.fix.family.name=建立缺少的布爾 switch 分支
create.missing.branches.with.null.branch.fix.family.name=建立缺少的分支和 'null' 分支
create.missing.enum.switch.branches.fix.family.name=建立缺少的枚舉 switch 分支
create.missing.record.deconstructions.switch.branches.fix.family.name=建立缺失記錄解構 switch 分支
create.missing.sealed.class.switch.branches.fix.family.name=建立缺少的密封類別 switch 分支
create.missing.switch.branch=建立缺少的分支 {0}
create.missing.switch.branches=建立缺少的分支 {0}
create.null.branch.fix.family.name=建立 'null' 分支
create.package.info.java.family.name=建立 'package-info.java'
cstyle.array.method.declaration.problem.descriptor=方法 <code>{0}()</code> 具有 C 樣式陣列返回值類型宣告 \\#loc
cstyle.array.variable.declaration.problem.descriptor={0, choice, 1\\#欄位|2\\#參數|3\\#記錄元件|4\\#區域變數} <code>{1}</code> 具有 C 樣式陣列類型宣告 \\#loc
custom.classloader.display.name=宣告了自訂的 'ClassLoader'
custom.classloader.problem.descriptor=自訂 ClassLoader 類別 <code>\\#ref</code> \\#loc
custom.security.manager.display.name=自訂 'SecurityManager'
custom.security.manager.problem.descriptor=自訂 SecurityManager 類別 <code>\\#ref</code> \\#loc
cyclic.class.dependency.1.problem.descriptor=類別 ''{0}'' 迴圈依賴於類別 ''{1}''
cyclic.class.dependency.2.problem.descriptor=類別 ''{0}'' 迴圈依賴於類別 ''{1}'' 和 ''{2}''
cyclic.class.dependency.display.name=迴圈類別相依
cyclic.class.dependency.ignore.in.same.file=忽略位於同一檔案中的類別之間的迴圈
cyclic.class.dependency.problem.descriptor=類別 ''{0}'' 迴圈依賴於其他 {1} 個類別
cyclic.package.dependency.1.problem.descriptor=軟體套件 ''{0}'' 迴圈依賴於軟體套件 ''{1}''
cyclic.package.dependency.2.problem.descriptor=軟體套件 ''{0}'' 迴圈依賴於軟體套件 ''{1}'' 和 ''{2}''
cyclic.package.dependency.display.name=迴圈軟體套件相依關係
cyclic.package.dependency.problem.descriptor=軟體套件 ''{0}'' 迴圈依賴於其他 {1} 個軟體套件
cyclomatic.complexity.display.name=過度複雜的方法
cyclomatic.complexity.limit.option=迴圈復雜度限制\\:
cyclomatic.complexity.problem.descriptor=過度複雜的方法 <code>\\#ref()</code> (迴圈復雜度 \\= {0}) \\#loc
dangling.javadoc.convert.line.comment.quickfix=取代為行註釋
dangling.javadoc.convert.quickfix=取代為塊註釋
dangling.javadoc.delete.quickfix=移除懸空的註釋
dangling.javadoc.display.name=懸空的 Javadoc 註釋
dangling.javadoc.ignore.copyright.option=忽略 JavaDoc 格式的檔案頭註釋
dangling.javadoc.problem.descriptor=懸空的 Javadoc 註釋 \\#loc
debug.level.and.lower.option=偵錯級別和更低
declare.collection.as.interface.fix.family.name=削弱類型
declare.collection.as.interface.quickfix=削弱為 ''{0}''
default.not.last.case.in.switch.display.name='default' 不是 'switch' 中的最後一個 case
default.not.last.case.in.switch.problem.descriptor=''default'' 分支不是 ''switch'' {0} 中的最後一個 case \\#loc
default.tostring.call.display.name=呼叫預設 'toString()'
default.tostring.call.problem.descriptor=呼叫 <code>\\#ref</code> 上的預設 'toString()' \\#loc
delete.catch.section.fix.family.name=刪除 catch 語句
delete.catch.section.quickfix=刪除 'catch' 部分
delete.import.quickfix=刪除不必要的匯入
delete.unnecessary.statement.fix.family.name=移除冗餘語句
deserializable.class.in.secure.context.problem.descriptor=類別 <code>\\#ref</code> 可能被反序列化，影響安全性 \\#loc
design.for.extension.display.name=為擴展設計
design.for.extension.problem.descriptor=方法 <code>\\#ref()</code> 可能被覆寫，其功能會被忽略 \\#loc
diamond.can.be.replaced.with.explicit.type.arguments.name=diamond 可被取代為顯式類型實參
diamond.can.be.replaced.with.explicit.type.arguments.quickfix=將 '<>' 取代為顯式類型實參
disjoint.package.display.name=具有不相交相依關係圖的軟體套件
disjoint.package.problem.descriptor=軟體套件 {0} 可以分解為 {1} 個獨立軟體套件
divide.by.zero.display.name=除以零
divide.by.zero.problem.descriptor=除以零 \\#loc
dollar.sign.in.name.display.name=在關鍵字中使用 '$'
dollar.sign.in.name.problem.descriptor=關鍵字 <code>\\#ref</code> 包含 '$' \\#loc
double.brace.initialization.display.name=雙大括號初始化
double.brace.initialization.quickfix=取代為正則初始化
double.checked.locking.display.name=雙重檢查鎖定
double.checked.locking.fix.family.name=將欄位設為 volatile
double.checked.locking.problem.descriptor=雙重檢查鎖定 \\#loc
double.checked.locking.quickfix=將 ''{0}'' 設為 volatile
double.literal.may.be.float.literal.display.name=轉換為 'float' 可以是 'float' 字面量
double.negation.display.name=雙重否定
double.negation.problem.descriptor=<code>\\#ref</code> 中的雙重否定 \\#loc
double.negation.quickfix=移除雙重否定
drivermanager.call.display.name=使用 'DriverManager' 獲取 JDBC 連線
drivermanager.call.problem.descriptor=呼叫 <code>DriverManager.\\#ref()</code> \\#loc
dumpstack.call.display.name=呼叫 'Thread.dumpStack()'
dumpstack.call.problem.descriptor=對 <code>Thread.\\#ref()</code> 的呼叫可能應當取代為更可靠的日誌 \\#loc
duplicate.condition.display.name=條件重複
duplicate.condition.ignore.method.calls.option=忽略可能有副作用的條件
duplicate.condition.ignore.method.calls.option.description=如果選中，則不會報告具有潛在副作用的條件(例如，未知的方法呼叫)。已知會產生副作用的方法在任何情況下都不會被報告。
duplicate.condition.problem.descriptor=重複條件 <code>\\#ref</code> \\#loc
dynamic.regex.replaceable.by.compiled.pattern.display.name=動態正則表達式可被取代為已編譯的 'Pattern'
dynamic.regex.replaceable.by.compiled.pattern.problem.descriptor=<code>\\#ref()</code> 可被取代為已編譯的 'java.util.regex.Pattern' 結構 \\#loc
dynamic.regex.replaceable.by.compiled.pattern.quickfix=取代為對已編譯 'Pattern' 常數的方法的呼叫
empty.anonymous.class.problem.descriptor=匿名類別為空 \\#loc
empty.class.display.name=空類別
empty.class.file.without.class.problem.descriptor=Java 檔案未宣告任何類別 \\#loc
empty.class.ignore.parameterization.option=如果類別是父類型的參數化，則將其忽略
empty.class.initializer.delete.quickfix=刪除空類別初始設定式
empty.class.initializer.display.name=空類別初始設定式
empty.class.initializer.problem.descriptor=空類別初始設定式 \\#loc
empty.class.problem.descriptor=類別 <code>\\#ref</code> 為空 \\#loc
empty.enum.problem.descriptor=枚舉 <code>\\#ref</code> 為空 \\#loc
empty.finally.block.display.name=空 'finally' 塊
empty.finally.block.problem.descriptor=空 <code>\\#ref</code> 塊 \\#loc
empty.synchronized.statement.display.name=空 'synchronized' 語句
empty.synchronized.statement.problem.descriptor=空 <code>\\#ref</code> 語句 \\#loc
empty.try.block.display.name=空 'try' 塊
empty.try.block.problem.descriptor=空 <code>\\#ref</code> 塊 \\#loc
encapsulate.variable.fix.family.name=封裝欄位
encapsulate.variable.quickfix=封裝欄位 ''{0}''
enum.singleton.problem.descriptor=枚舉 <code>\\#ref</code> 為單例 \\#loc
enum.switch.statement.which.misses.cases.display.name=缺少 case 的枚舉 'switch' 語句
enum.switch.statement.which.misses.cases.option=忽略具有預設分支的 switch 語句
enum.switch.statement.which.misses.cases.problem.descriptor=枚舉類型 ''{0}'' 上的 <code>\\#ref</code> 語句缺少 case {1} \\#loc
enum.switch.statement.which.misses.cases.problem.descriptor.single=枚舉類型 ''{0}'' 上的 <code>\\#ref</code> 語句缺少 case ''{1}'' \\#loc
enumerated.class.display.name=枚舉類別
enumerated.class.naming.convention.element.description=枚舉類別
enumerated.class.problem.descriptor=枚舉類別 <code>\\#ref</code> \\#loc
enumerated.constant.naming.convention.element.description=枚舉常數
enumeration.can.be.iteration.display.name=枚舉可以是迭代
enumeration.can.be.iteration.problem.descriptor=<code>\\#ref()</code> 可被取代為 ''{0}'' 結構 \\#loc
enumeration.can.be.iteration.quickfix=取代為 'Iterator' 結構
equality.to.safe.equals.quickfix=用 null 安全 'equals()' 取代 '\\=\\='
equals.between.inconvertible.types.display.name='equals()' 位於不可轉換類型的物件之間
equals.between.inconvertible.types.mutual.subclass.option=如果未找到相互子類別，則發出警告
equals.between.inconvertible.types.no.mutual.subclass.problem.descriptor=未找到屬於 ''{0}'' 和 ''{1}'' 這兩個子類型的類別 \\#loc
equals.between.inconvertible.types.problem.descriptor=<code>\\#ref</code> 位於 ''{0}'' 和 ''{1}'' 不可轉換類型的物件之間 \\#loc
equals.called.on.array.display.name=在陣列上呼叫了 'equals()'
equals.called.on.array.problem.descriptor=陣列之間的 <code>\\#ref()</code> 可能應當是 'Arrays.equals()' \\#loc
equals.called.on.enum.constant.display.name=對枚舉值呼叫了 'equals()'
equals.called.on.enum.constant.problem.descriptor=對枚舉值呼叫了 <code>\\#ref()</code> \\#loc
equals.called.on.suspicious.object.display.name=在不對其進行覆寫的類別上呼叫了 'equals()'
equals.called.on.suspicious.object.fix.family.name=取代為代表值的比較
equals.called.on.suspicious.object.fix.name=取代為 ''{0}()'' 呼叫結果的比較
equals.called.on.suspicious.object.problem.descriptor=''{0}'' 物件上存在可疑的 ''equals()'' 呼叫
equals.doesnt.check.class.parameter.display.name=不檢查其參數的類別的 'equals()' 方法
equals.doesnt.check.class.parameter.problem.descriptor=<code>\\#ref()</code> 應當檢查其參數的類別 \\#loc
equals.replaceable.by.objects.call.display.name='equals()' 表達式可被取代為 'Objects.equals()' 表達式
equals.replaceable.by.objects.call.problem.descriptor=<code>\\#ref</code> 可被取代為 'Objects.equals()' 表達式 \\#loc
equals.replaceable.by.objects.check.not.null.option=醒目提示與 'a \\!\\= null \\\\&\\\\& a.equals(b)' 類似的表達式
equals.with.itself.display.name=在自身上呼叫了 'equals()'
equals.with.itself.option=忽略可能的約定測試
equals.with.itself.option.description=選中後，某些情況(如 <code>assertEquals(myObj, myObj)</code>)將不會被報告，以避免在檢查 <code>equals()</code> 方法正確性的測試中出現警告。
equals.with.itself.problem.descriptor=在自身上呼叫了 <code>\\#ref()</code>
error.rethrown.display.name='Error' 未重新拋出
error.rethrown.problem.descriptor=錯誤 <code>\\#ref</code> 未重新拋出 \\#loc
exception.from.catch.which.doesnt.wrap.display.name='throw' 位於忽略已捕獲異常的 'catch' 塊內
exception.from.catch.which.doesnt.wrap.problem.descriptor='catch' 塊內的 <code>\\#ref</code> 忽略捕獲的異常 \\#loc
exception.from.catch.which.doesntwrap.ignore.cant.wrap.option=如果拋出的異常無法包裝異常，則忽略
exception.from.catch.which.doesntwrap.ignore.option=如果使用異常方法呼叫的結果，則忽略
exception.name.doesnt.end.with.exception.display.name=異常類別名不以 'Exception' 結尾
exception.name.doesnt.end.with.exception.problem.descriptor=異常類別名 <code>\\#ref</code> 未以 'Exception' 結尾 \\#loc
exception.package.display.name=異常軟體套件
exception.package.problem.descriptor=軟體套件 ''{0}'' 僅包含異常類別
explicit.array.to.string.problem.descriptor=呼叫陣列上的 '\\#ref()' \\#loc
expression.can.be.replaced.no.quotes.problem.descriptor={0} 可被取代為 {1}
expression.can.be.replaced.problem.descriptor=<code>\\#ref</code> 可被取代為 ''{0}'' \\#loc
expression.may.be.factorized.display.name=表達式可以因式分解
extend.exception.fix.family.name=使類別擴展 'Exception'
extended.for.statement.display.name=增強的 'for' 語句
extended.for.statement.problem.descriptor=擴展 <code>\\#ref</code> 語句 \\#loc
extended.for.statement.replace.quickfix=取代為舊式 'for' 語句
extends.annotation.display.name=類別擴展註解接口
extends.annotation.interface.problem.descriptor=接口 ''{0}'' 擴展註解接口 <code>\\#ref</code> \\#loc
extends.annotation.problem.descriptor=類別 ''{0}'' 實作註解接口 <code>\\#ref</code> \\#loc
extends.concrete.collection.display.name=類別顯式擴展 'Collection' 類別
extends.concrete.collection.problem.descriptor=類別 <code>\\#ref</code> 顯式擴展 ''{0}'' \\#loc
extends.object.display.name=類別顯式擴展 'Object'
extends.object.problem.descriptor=類別 <code>\\#ref</code> 顯式擴展 'java.lang.Object' \\#loc
extends.object.remove.quickfix=移除冗餘的 'extends Object'
extends.thread.display.name=類別直接擴展 'Thread'
extends.thread.problem.descriptor=類別 <code>\\#ref</code> 直接擴展 'java.lang.Thread' \\#loc
extends.throwable.display.name=類別直接擴展 'Throwable'
extends.throwable.problem.descriptor=類別 <code>\\#ref</code> 直接擴展 'java.lang.Throwable' \\#loc
externalizable.with.serialization.methods.display.name=具有 'readObject()' 或 'writeObject()' 的可外部化類別
externalizable.with.serialization.methods.problem.descriptor.both=可外部化{0, choice, 1\\#類別|2\\#接口|3\\#派生的匿名類別|4\\#註解類型|5\\#枚舉|6\\#記錄} <code>\\#ref</code> 定義 'readObject()' 和 'writeObject()' \\#loc
externalizable.with.serialization.methods.problem.descriptor.read=可外部化{0, choice, 1\\#類別|2\\#接口|3\\#派生的匿名類別|4\\#註解類型|5\\#枚舉|6\\#記錄} <code>\\#ref</code> 定義 'readObject()' \\#loc
externalizable.with.serialization.methods.problem.descriptor.write=可外部化{0, choice, 1\\#類別|2\\#接口|3\\#派生的匿名類別|4\\#註解類型|5\\#枚舉|6\\#記錄} <code>\\#ref</code> 定義 'writeObject()' \\#loc
externalizable.without.public.no.arg.constructor.display.name=沒有 'public' 無實參建構函式的 'Externalizable' 類別
externalizable.without.public.no.arg.constructor.problem.descriptor=可外部化類別 <code>\\#ref</code> 沒有 'public' 無實參建構函式 \\#loc
extract.method.quickfix=提取方法
extract.parameter.as.local.variable.quickfix=提取參數作為區域變數
fallthru.in.switch.statement.display.name='switch' 語句中的直落
fallthru.in.switch.statement.problem.descriptor='switch' 語句存在直落 \\#loc
fallthru.in.switch.statement.quickfix=新增 ''{0}''
feature.envy.display.name=特性依戀
feature.envy.problem.descriptor=類別 ''{0}'' 在方法 <code>\\#ref()</code> 中被重複存取 \\#loc
field.accessed.synchronized.and.unsynchronized.display.name=同時在 'synchronized' 和未同步上下文中存取欄位
field.accessed.synchronized.and.unsynchronized.option=簡單的 getter 和 setter 也被視為欄位存取
field.accessed.synchronized.and.unsynchronized.problem.descriptor=同時在同步和未同步上下文中存取欄位 <code>\\#ref</code> \\#loc
field.count.inspection.include.constant.fields.in.count.checkbox=在計數中包含常數欄位
field.count.inspection.include.enum.constants.in.count=在計數中包含枚舉常數
field.count.inspection.static.final.fields.count.as.constant.checkbox=將 'static final' 欄位計為常數
field.has.setter.but.no.getter.display.name=欄位具有 setter 但沒有 getter
field.has.setter.but.no.getter.problem.descriptor=欄位 <code>\\#ref</code> 有 setter 但沒有 getter \\#loc
field.has.static.modifier.problem.descriptor=欄位 ''{0}'' 具有 ''static'' 修飾符
field.incorrect.type.problem.descriptor=欄位 ''{0}'' 沒有類型 ''{1}''
field.may.be.final.display.name=欄位可能為 'final'
field.may.be.final.problem.descriptor=欄位 <code>\\#ref</code> 可能為 'final' \\#loc
field.may.be.static.display.name=欄位可以為 'static'
field.may.be.static.problem.descriptor=欄位 <code>\\#ref</code> 可能為 'static' \\#loc
field.missing.volatile.modifier.problem.descriptor=欄位 ''{0}'' 沒有 ''volatile'' 修飾符
field.name.hides.in.superclass.display.name=子類別欄位隱藏超類別欄位
field.name.hides.in.superclass.ignore.option=忽略不可存取欄位
field.name.hides.in.superclass.ignore.static.field.option=忽略隱藏 static 欄位的 static 欄位
field.name.hides.in.superclass.problem.descriptor=欄位 <code>\\#ref</code> 隱藏超類別中的欄位 \\#loc
field.naming.convention.display.name=欄位命名約定
field.not.found.in.class.problem.descriptor=類別 ''{1}'' 中未找到命名為 ''{0}'' 的欄位
final.class.display.name=類別禁止繼承
final.class.problem.descriptor=類別 ''{0}'' 宣告了 <code>\\#ref</code> \\#loc
final.method.display.name=不能覆寫方法
final.method.in.final.class.display.name='final' 類別位於 'final' 方法中
final.method.in.final.class.problem.descriptor=方法在 'final' 類別中被宣告為 <code>\\#ref</code> \\#loc
final.method.problem.descriptor=方法被宣告為 <code>\\#ref</code> \\#loc
final.private.method.display.name='private' 方法被宣告為 'final'
final.private.method.problem.descriptor='private' 方法被宣告為 <code>\\#ref</code> \\#loc
final.static.method.display.name='static' 方法被宣告為 'final'
final.static.method.problem.descriptor='static' 方法被宣告為 <code>\\#ref</code> \\#loc
finalize.called.explicitly.display.name='finalize()' 被顯式呼叫
finalize.called.explicitly.problem.descriptor=<code>\\#ref()</code> 被顯式呼叫 \\#loc
finalize.declaration.display.name='finalize()' 不應被覆寫
finalize.declaration.problem.descriptor='finalize()' 不應被覆寫 \\#loc
finalize.not.declared.protected.display.name='finalize()' 應為 protected，不應為 public
finalize.not.declared.protected.problem.descriptor='finalize()' 應具有 protected 存取權限，不應具有 public 存取權限 \\#loc
finally.block.cannot.complete.normally.display.name=不能正常完成的 'finally' 塊
finally.block.cannot.complete.normally.problem.descriptor=<code>\\#ref</code> 塊無法正常完成 \\#loc
fix.add.argument.family.name=新增實參
fix.add.argument.name=新增 ''{0}'' 實參
fix.eliminate.folded.if.present.description=可以消除折疊的 'ifPresent()' 呼叫
fix.eliminate.folded.if.present.name=移除折疊的 'ifPresent()' 呼叫
fix.replace.map.with.flat.map.description='map()' 可被取代為 'flatMap()'
flip.comparison.quickfix=翻轉比較
floating.point.equality.display.name=浮點相等比較
floating.point.equality.problem.descriptor=<code>\\#ref</code>\\: 比較浮點值以實作完全相等 \\#loc
for.can.be.foreach.display.name='for' 迴圈可被取代為增強的 for 迴圈
for.can.be.foreach.fix.no.indexed=不報告索引的 'java.util.List' 迴圈
for.can.be.foreach.option=報告索引的 'java.util.List' 迴圈
for.can.be.foreach.option2=不報告無類型集合上的迭代
for.can.be.foreach.problem.descriptor=<code>\\#ref</code> 迴圈可被取代為增強的 'for' \\#loc
for.loop.replaceable.by.while.display.name='for' 迴圈可被取代為 'while' 迴圈
for.loop.replaceable.by.while.ignore.option=忽略無條件迴圈的 'infinite'
for.loop.replaceable.by.while.problem.descriptor=<code>\\#ref</code> 迴圈語句可被取代為 'while' 迴圈 \\#loc
for.loop.with.missing.component.collection.loop.option=忽略集合迭代
for.loop.with.missing.component.display.name=缺少元件的 'for' 迴圈
for.loop.with.missing.component.problem.descriptor1=<code>\\#ref</code> 語句缺少初始設定式 \\#loc
for.loop.with.missing.component.problem.descriptor2=<code>\\#ref</code> 語句缺少條件 \\#loc
for.loop.with.missing.component.problem.descriptor3=<code>\\#ref</code> 語句缺少更新 \\#loc
for.loop.with.missing.component.problem.descriptor4=<code>\\#ref</code> 語句缺少初始設定式和條件 \\#loc
for.loop.with.missing.component.problem.descriptor5=<code>\\#ref</code> 語句缺少初始設定式和條件 \\#loc
for.loop.with.missing.component.problem.descriptor6=<code>\\#ref</code> 語句缺少條件和更新 \\#loc
for.loop.with.missing.component.problem.descriptor7=<code>\\#ref</code> 語句缺少初始設定式、條件和更新 \\#loc
foreach.replace.quickfix=取代為增強 'for'
format.string.error.duplicate.flag=''{1}'' 中存在重複的標誌 ''{0}''
format.string.error.flags.not.allowed=''{1}'' 中不允許使用{2, choice, 1\\#標誌|1<標誌} ''{0}''
format.string.error.illegal.flag.combination=''{2}'' 中的標誌組合 ''{0}'' 和 ''{1}'' 非法
format.string.error.illegal.position.specifier=''{1}'' 存在非法的位置說明符 ''{0}''
format.string.error.invalid.precision=''{0}'' 中指定的精度無效
format.string.error.left.justify.no.width=使用了左對齊標誌 ''-''，但 ''{0}'' 中未指定寬度
format.string.error.precision.not.allowed=''{1}'' 中不允許該精度 (''{0}'')
format.string.error.previous.element.not.found=使用了以前的標誌 '<'，但沒有找到 ''{0}'' 以前的格式說明符
format.string.error.unexpected.flag=''{1}'' 中出現意外字元 ''{0}''
format.string.error.unknown.conversion=''{0}'' 中存在未知的轉換
format.string.error.unnecessary.position.specifier=''{1}'' 存在不必要的實參位置說明符 ''{0}''
format.string.error.width.not.allowed=''{1}'' 中不允許該寬度 (''{0}'')
format.string.error.zero.padding.no.width=使用了零填充標誌 ''0''，但 ''{0}'' 中未指定寬度
gc.call.display.name=呼叫 'System.gc()' 或 'Runtime.gc()'
gc.call.problem.descriptor=<code>\\#ref</code> 不應在生產程式碼中呼叫 \\#loc
generate.to.string.quick.fix.family.name=生成
generate.to.string.quick.fix.text=生成 toString()
hardcoded.file.separator.display.name=硬編碼檔案分隔符
hardcoded.file.separator.ignore.methods.option=忽略以下方法的實參\\:
hardcoded.file.separator.include.option=在已識別的 MIME 媒體類型中包括 'example/*'
hardcoded.file.separator.problem.descriptor=硬編碼檔案分隔符 <code>\\#ref</code> \\#loc
hardcoded.line.separator.display.name=硬編碼行分隔符
hardcoded.line.separator.problem.descriptor=硬編碼行分隔符 <code>\\#ref</code> \\#loc
hibernate.resource.opened.not.closed.display.name=Hibernate 資源已開啟，但未安全關閉
html.tag.can.be.javadoc.tag.display.name='<code>…</code>' 可被取代為 '{@code …}'
html.tag.can.be.javadoc.tag.problem.descriptor=<code>\\#ref...\\\\&lt;/code\\\\&gt;</code> 可被取代為 '{@code …}' \\#loc
i.o.resource.opened.not.closed.display.name=I/O 資源已開啟，但未安全關閉
if.can.be.assertion.name=語句可被取代為 'assert' 或 'Objects.requireNonNull'
if.can.be.assertion.replace.with.assertion.quickfix=將語句取代為 'assert' 語句
if.can.be.assertion.replace.with.objects.requirenonnull.quickfix=將語句取代為 'Objects.requireNonNull()'
if.can.be.switch.display.name='if' 可被取代為 'switch'
if.can.be.switch.enum.option=對枚舉啟用 switch 建議
if.can.be.switch.int.option=對數字啟用 switch 建議
if.can.be.switch.minimum.branch.option='if' 條件分支的最小數量\\:
if.can.be.switch.null.safe.option=僅對 null-safe 表達式啟用建議
if.can.be.switch.problem.descriptor=<code>\\#ref</code> 語句可被取代為 'switch' 語句 \\#loc
if.may.be.conditional.problem.descriptor=<code>\\#ref</code> 可被取代為條件表達式 \\#loc
if.may.be.conditional.quickfix=取代為條件表達式
if.may.be.factorized.problem.descriptor=<code>\\#ref</code> 可以因式分解 \\#loc
if.may.be.factorized.quickfix=取代為因式分解表達式
if.statement.with.identical.branches.display.name=具有相同分支或通用部分的 'if' 語句
if.statement.with.too.many.branches.display.name='if' 語句的分支過多
if.statement.with.too.many.branches.max.option=最大分支數\\:
if.statement.with.too.many.branches.problem.descriptor=<code>\\#ref</code> 的分支過多 ({0}) \\#loc
ignore.accesses.from.equals.method=忽略來自 'equals()' 方法的存取
ignore.accesses.from.the.same.class=忽略來自同一類的存取
ignore.anonymous.inner.classes=忽略匿名類別
ignore.boolean.methods.in.an.interface.option=忽略 @&interface 中的布爾方法
ignore.branches.of.switch.statements=忽略 'switch' 語句的分支
ignore.calls.to.property.getters=忽略對屬性 getter 的呼叫
ignore.calls.to.static.methods=忽略對 static 方法的呼叫
ignore.classes.annotated.by=由以下物件註解時忽略類別\\:
ignore.classes.in.hierarchy.column.name=忽略以下物件的子類別\\:
ignore.cloneable.option=忽略 'java.lang.Cloneable'
ignore.constructor.method.references=忽略產生 AutoCloseable 的建構函式方法參照
ignore.enhanced.for.loop.statements=忽略增強型 for 迴圈
ignore.equals.hashcode.and.tostring=忽略 'equals()'、'hashCode()' 和 'toString()' 方法
ignore.exceptions.declared.on.library.override.option=忽略在覆寫庫方法的方法上宣告的異常(&L)
ignore.for.equals.methods.option=對 'equals()' 方法忽略(&E)
ignore.getters.returning.resource=忽略返回源的 getter
ignore.guard.clauses.option=忽略 guard 子句(&G)
ignore.if.annotated.by=由以下物件註解時忽略\\:
ignore.in.module.statements.option=在 Java 9 模組語句中忽略
ignore.instanceof.on.library.classes=忽略庫類別上的 instanceof
ignore.methods.in.anonymous.classes=忽略匿名類別中的方法
ignore.methods.overriding.super.method=忽略覆寫/實作 super 方法的方法(O&)
ignore.methods.with.boolean.return.type.option=忽略具有 'java.lang.Boolean' 返回值類型的方法(&B)
ignore.overflowing.byte.casts.option=忽略從 int 128-255 到位元組的轉換
ignore.parentheses.around.single.no.formal.type.lambda.parameter=忽略單個非正式類型 lambda 參數周圍的括號
ignore.private.methods.option=忽略 private 方法中的指派和返回值
ignore.serializable.option=忽略 'java.io.Serializable'
ignore.single.field.static.imports.option=忽略單欄位 static import(&F)
ignore.single.method.static.imports.option=忽略單方法 static import(&M)
ignore.trivial.finalizers.option=對普通 'finalize()' 實作忽略
ignored.autocloseable.types.label=已忽略的 AutoCloseable 資源類型\\:
ignored.class.hierarchies.border.title=忽略以下物件的子類別\\:
ignored.class.label=已忽略類別(包括子類別)\\:
ignored.class.names=忽略類別(包括子類別)
ignored.io.resource.types.label=已忽略的 I/O 資源類型\\:
implicit.array.to.string.display.name=呼叫陣列上的 'toString()'
implicit.array.to.string.fix.family.name=將 Array.toString() 設為隱式
implicit.array.to.string.method.call.problem.descriptor=隱式呼叫呼叫 <code>\\#ref</code> 返回的陣列上的 'toString()' \\#loc
implicit.array.to.string.problem.descriptor=隱式呼叫陣列 <code>\\#ref</code> 上的 'toString()' \\#loc
implicit.array.to.string.quickfix=使用 ''{0}'' 表達式包裝
implicit.call.to.super.display.name=隱式呼叫 'super()'
implicit.call.to.super.ignore.option=對 'java.lang.Object' 的直接子類別忽略
implicit.call.to.super.make.explicit.quickfix=使對 'super()' 的呼叫顯式
implicit.call.to.super.problem.descriptor=隱式呼叫 'super()' \\#loc
implicit.default.charset.usage.constructor.problem.descriptor=<code>new \\#ref()</code> 呼叫使用平台的預設字符集
implicit.default.charset.usage.display.name=隱式平台預設字符集
implicit.default.charset.usage.fix.family.name=指定 UTF-8 字符集
implicit.default.charset.usage.problem.descriptor=對 <code>\\#ref()</code> 的呼叫使用平台的預設字符集
implicit.numeric.conversion.assignment.problem.descriptor=將結果值從 ''{0}'' 隱式數字轉換為 ''{1}'' \\#loc
implicit.numeric.conversion.display.name=隱式數字轉換
implicit.numeric.conversion.ignore.char.conversion.option=忽略 'char' 之間的轉換
implicit.numeric.conversion.ignore.constant.conversion.option=忽略從常數和字面量的轉換
implicit.numeric.conversion.ignore.widening.conversion.option=忽略擴大轉換
implicit.numeric.conversion.make.explicit.quickfix=使轉換顯式
implicit.numeric.conversion.problem.descriptor=將 <code>\\#ref</code> 從 ''{0}'' 隱式數字轉換為 ''{1}'' \\#loc
import.display.name='*' 匯入
import.from.same.package.display.name=相同軟體套件中的不必要 import
import.from.same.package.problem.descriptor=相同軟體套件 <code>\\#ref</code> 中有不必要的 import \\#loc
import.problem.descriptor=軟體套件匯入 <code>\\#ref</code> \\#loc
include.java.system.classes.option=包括與 Java 系統類別的耦合
include.library.classes.option=包括與庫類別的耦合
incompatible.mask.operation.display.name=不相容的位元遮罩運算
incompatible.mask.operation.problem.descriptor.always.false=<code>\\#ref</code> 始終為 false \\#loc
incompatible.mask.operation.problem.descriptor.always.true=<code>\\#ref</code> 始終為 true \\#loc
incorrect.date.format.fix.family.name=修復不正確的日期格式
increment.decrement.display.name=使用 '++' 或 '--' 的結果
increment.decrement.used.as.expression.fix.family.name=提取到分離語句中
increment.decrement.used.as.expression.quickfix=提取 ''{0}'' 以分離語句
inequality.to.safe.not.equals.quickfix=用 null 安全 '\\!equals()' 取代 '\\!\\='
infinite.loop.statement.display.name=無限迴圈語句
infinite.loop.statement.problem.descriptor=<code>\\#ref</code> 語句不能在未拋出異常的情況下完成 \\#loc
infinite.recursion.display.name=無限遞迴
infinite.recursion.problem.descriptor=方法 <code>\\#ref()</code> 無限遞迴，只能以拋出異常結束 \\#loc
info.level.and.lower.option=資訊級別和更低
inline.call.quickfix=內聯呼叫
inline.variable.quickfix=內聯變數
inner.class.field.hides.outer.display.name=內部類別欄位隱藏外部類別欄位
inner.class.field.hides.outer.ignore.option=忽略從內部類別不可見的外部欄位
inner.class.field.hides.outer.problem.descriptor=內部類別欄位 <code>\\#ref</code> 隱藏外部類別欄位 \\#loc
inner.class.may.be.static.display.name=內部類別可能為 'static'
inner.class.may.be.static.problem.descriptor=內部類別 <code>\\#ref</code> 可能為 'static' \\#loc
inner.class.on.interface.display.name=接口的內部類別
inner.class.on.interface.ignore.option=忽略接口的內部接口
inner.class.on.interface.problem.descriptor=接口 ''{0}'' 具有內部類別 <code>\\#ref</code> \\#loc
inner.class.referenced.via.subclass.display.name=通過子類別參照的內部類別
inner.class.referenced.via.subclass.problem.descriptor=內部類別 <code>\\#ref</code> 在類別 ''{0}'' 中宣告，但通過子類別 ''{1}'' 參照 \\#loc
inner.class.referenced.via.subclass.quickfix=使內部類別存取合理化
inner.class.too.deeply.nested.display.name=內部類別嵌套太深
inner.class.too.deeply.nested.nesting.limit.option=嵌套限制\\:
inner.class.too.deeply.nested.problem.descriptor=<code>\\#ref</code> 嵌套太深 (嵌套級別 \\= {0}) \\#loc
inspection.autocloseable.resource.ignored.methods.title=忽略從這些方法返回的 AutoCloseable 執行個體\\:
inspection.byte.array.output.stream.to.string.message=ByteArrayOutputStream 轉換低效
inspection.case.mismatch.display.name='String' 動作中不符合的大小寫
inspection.case.mismatch.message.arg.is.lower=方法 ''{0}()'' 始終返回 {1}\\: 實參包含小寫符號，而限定符不包含小寫符號
inspection.case.mismatch.message.arg.is.upper=方法 ''{0}()'' 始終返回 {1}\\: 實參包含大寫符號，而限定符不包含大寫符號
inspection.case.mismatch.message.label.is.lower=無法存取 switch 分支\\: 標籤包含小寫符號，而選擇器僅支援大寫
inspection.case.mismatch.message.label.is.upper=無法存取 switch 分支\\: 標籤包含大寫符號，而選擇器僅支援小寫
inspection.cast.can.be.replaced.with.variable.display.name=轉換可被取代為變數
inspection.cast.can.be.replaced.with.variable.family.name=用變數取代轉換
inspection.cast.can.be.replaced.with.variable.message=可以使用變數 ''{0}'' 替代 ''{1}''
inspection.catch.ignores.exception.display.name=catch 塊可能會忽略異常
inspection.catch.ignores.exception.empty.message=空 <code>\\#ref</code> 塊 \\#loc
inspection.catch.ignores.exception.option.comments=當 'catch' 塊包含註釋時不發出警告
inspection.catch.ignores.exception.option.ignored.used=當名稱為 'ignore(d)' 的異常實際上未被忽略時不發出警告
inspection.catch.ignores.exception.option.nonempty=當 'catch' 塊不為空時不發出警告
inspection.catch.ignores.exception.unused.message=未使用的 'catch' 參數 <code>\\#ref</code> \\#loc
inspection.catch.ignores.exception.used.message=已使用命名為 <code>\\#ref</code> 的 'catch' 參數 \\#loc
inspection.catch.ignores.exception.vm.ignored.message=<code>\\#ref</code> 塊中可能會忽略 ''{0}'' 之類的意外虛擬機異常 \\#loc
inspection.collection.must.have.initial.capacity.initializers.option=不報告欄位初始設定式
inspection.commented.out.code.disable.short.fragments=不報告此類別短片段
inspection.commented.out.code.display.name=註釋掉的程式碼
inspection.commented.out.code.min.lines.options=最少程式碼行數
inspection.commented.out.code.problem.descriptor=註釋掉的程式碼 ({0} {0, choice, 1\\#行|1<行})
inspection.common.if.parts.description.complete.duplicate=可以摺疊 ''if'' 語句{0}
inspection.common.if.parts.description.complete.duplicate.side.effect=可以通過提取副作用摺疊 'if' 語句
inspection.common.if.parts.description.variables.only=可以從 ''if'' 中提取變數{0}
inspection.common.if.parts.description.whole.branch=可以提取通用部分，同時移除分支{0}
inspection.common.if.parts.description.with.variables.extract=可以從 ''if'' 中提取包含變數的通用部分{0}
inspection.common.if.parts.description.without.variables.extract=可以從 ''if'' 中提取通用部分{0}
inspection.common.if.parts.message.complete.duplicate=摺疊 ''if'' 語句{0}
inspection.common.if.parts.message.complete.duplicate.side.effect=摺疊 'if' 語句並提取副作用
inspection.common.if.parts.message.variables.only=從 ''if'' 中提取變數{0}
inspection.common.if.parts.message.whole.branch=提取通用部分，同時移除分支{0}
inspection.common.if.parts.message.with.variables.extract=從 ''if'' 中提取包含變數的通用部分{0}
inspection.common.if.parts.message.without.variables.extract=從 ''if'' 中提取通用部分{0}
inspection.common.subexpression.in.switch.display.name=可以從 'switch' 中提取通用子表達式
inspection.common.subexpression.in.switch.fix.family.name=向下推送 'switch' 表達式
inspection.comparator.combinators.description=可被取代為 'Comparator' 鏈
inspection.comparator.combinators.description2=可被取代為 ''{0}''
inspection.comparator.combinators.fix.chain=取代為 'Comparator' 鏈
inspection.condition.covered.by.further.condition.descr=條件 ''{0}'' 由後面的{1, choice, 1\\#條件 ''''{2}''''|2\\#條件}覆蓋
inspection.constant.expression.display.name=可以對常數表達式求值
inspection.constant.expression.fix.family.name=計算常量值
inspection.constant.expression.fix.name=計算 ''{0}'' 的常量值
inspection.constant.expression.fix.name.short=取代為常量值
inspection.constant.expression.message=常數表達式的求值結果可以為 ''{0}''
inspection.constant.expression.report.compile.time=僅報告編譯時常量
inspection.constant.expression.report.compile.time.description=預設情況下，該檢查可以評估一些涉及庫方法呼叫的常數，甚至可以根據周圍程式碼推斷常量值。選中此選項可以根據 Java 語言規範僅報告編譯時常量。
inspection.constant.expression.skip.non.literal=不報告包含對已定義常數的參照的表達式
inspection.constant.expression.skip.non.literal.description=忽略包含對非字面量動作數(例如欄位和變數)參照的表達式。
inspection.deconstruction.can.be.used.display.name=可以使用記錄模式
inspection.deconstruction.can.be.used.fix.family.name=取代為記錄模式
inspection.deconstruction.can.be.used.message=可被取代為記錄模式
inspection.empty.catch.block.generate.body=從模板生成 'catch' 正文
inspection.empty.class.ignore.subclasses.option=忽略 {0} 的子類別
inspection.enhanced.for.with.record.pattern.can.be.used.components.option=要解構的記錄元件的最大數量\\:
inspection.enhanced.for.with.record.pattern.can.be.used.display.name=可以使用帶有記錄模式的增強 'for'
inspection.enhanced.for.with.record.pattern.can.be.used.fix.family.name=取代為記錄模式
inspection.enhanced.for.with.record.pattern.can.be.used.level.option=嵌套深度限制\\:
inspection.enhanced.for.with.record.pattern.can.be.used.maximum.depth.disabled=不建議帶有 {0} 種和更多嵌套模式的模式
inspection.enhanced.for.with.record.pattern.can.be.used.maximum.number.disabled=不建議帶有 {0} 個或更多元件的記錄
inspection.enhanced.for.with.record.pattern.can.be.used.message=可被取代為帶有記錄模式的增強 'for'
inspection.enhanced.for.with.record.pattern.can.be.used.not.used.option=未使用的記錄元件的最大數量\\:
inspection.excessive.range.check.fix.family.name=簡化過度範圍檢查
inspection.excessive.range.check.message=可被取代為 ''{0}''
inspection.if.statement.missing.break.in.loop.description=滿足條件後，可以終止迴圈
inspection.if.statement.missing.break.in.loop.name=在 'if' 條件下提前離開迴圈
inspection.if.statement.missing.break.in.loop.quickfix=新增 'break'
inspection.incorrect.date.format.display.name=不正確的 'DateTimeFormat' 模式
inspection.incorrect.date.format.message.literal=左單引號({0})後未跟隨右單引號
inspection.incorrect.date.format.message.padding=沒有連續模式字母的填充修飾符 ''{0}''
inspection.incorrect.date.format.message.reserved.character=使用保留字元 ''{0}''
inspection.incorrect.date.format.message.unpaired=在沒有事先開啟 ''{0}'' 的情況下關閉 <code>\\#ref</code>
inspection.incorrect.date.format.message.unsupported=非法模式字母 ''{0}''
inspection.incorrect.date.format.too.few.letters=連續模式字母 ''{0}'' 過少；最小\\: {1}；指定\\: {2}
inspection.incorrect.date.format.too.many.letters=連續模式字母 ''{0}'' 過多；最大\\: {1}；指定\\: {2}
inspection.incorrect.date.format.wrong.number.of.letters=連續模式字母 ''{0}'' 的數量錯誤；允許\\: {1}；指定\\: {2}
inspection.incorrect.message.custom.classes.methods=自訂 MessageFormat 方法\\:
inspection.incorrect.message.format.choice.limit.incorrect=選擇模式中的下限 ''{0}'' 不正確
inspection.incorrect.message.format.choice.limit.not.found=選擇模式中的下限為空
inspection.incorrect.message.format.display.name='MessageFormat' 模式不正確
inspection.incorrect.message.format.incorrect.index=索引 ''{0}'' 不正確
inspection.incorrect.message.format.incorrect.order.choice=選擇模式中的下限未按升序排列
inspection.incorrect.message.format.incorrect.quotes.number=引號的數量可能不正確，將列印超過 1 個引號
inspection.incorrect.message.format.not.found.argument=索引 ''{0}'' 沒有實參''
inspection.incorrect.message.format.not.found.arguments=索引沒有實參\\: {0}
inspection.incorrect.message.format.not.used.argument=模式中未使用索引為 ''{0}'' 的實參
inspection.incorrect.message.format.pattern=訊息格式模式 ''{1}'' 中的 {0}
inspection.incorrect.message.format.quotes.around.parameter=佔位符 ''{0}'' 不會被取代，因為它包含在引號中
inspection.incorrect.message.format.unclosed.brace=未閉合的大括號
inspection.incorrect.message.format.unknown.format.type=未知格式類型 ''{0}''
inspection.incorrect.message.format.unmatched.brace=不符合的大括號
inspection.incorrect.message.format.unpaired.quote=訊息模式中不成對的引號
inspection.list.remove.in.loop.display.name=在迴圈中呼叫了 'List.remove()'
inspection.list.remove.in.loop.message=可被取代為 'List.subList().clear()'
inspection.lossy.conversion.compound.assignment.display.name=複合指派中從 ''{0}'' 到 ''{1}'' 的隱式轉換可能是有損的
inspection.lossy.conversion.compound.assignment.name=複合指派中可能存在有損隱式轉換
inspection.meta.annotation.without.runtime.description={0} 應具有 @Retention(RetentionPolicy.RUNTIME)
inspection.method.call.in.loop.ignore.known.methods.option=忽略有副作用的已知方法
inspection.new.object.equality.display.name=使用 '\\=\\=' 比較新物件
inspection.new.object.equality.message=使用 ''{0}'' 比較新物件
inspection.non.strict.comparison.equality.display.name=非嚴格不等式 '>\\=' 或 '<\\=' 可被取代為 '\\=\\='
inspection.non.strict.comparison.equality.message=可被取代為等式
inspection.note.may.change.semantics=可能更改語意
inspection.only.one.element.used.array=僅使用了一個陣列元素
inspection.only.one.element.used.display.name=僅使用了一個元素
inspection.only.one.element.used.fix.family=取代為已存取的元素
inspection.only.one.element.used.list=僅使用了一個列表元素
inspection.only.one.element.used.string=僅使用了一個字串字元
inspection.option.ignore.as.initial.capacity=忽略 StringBuilders 和 Collections 的初始容量
inspection.option.ignore.assert=對斷言語句描述實參忽略
inspection.option.ignore.constant.initializers=對常數欄位的初始設定式忽略
inspection.option.ignore.exceptions=對 Throwable 子類別的建構函式實參忽略
inspection.option.ignore.in.annotations=在註解中忽略
inspection.option.ignore.in.hashcode=忽略 'hashCode()' 方法中的常數
inspection.option.ignore.in.tostring=在 toString() 方法內部忽略
inspection.option.ignore.nonnls=通過 @NonNls 進行註解時忽略
inspection.option.ignore.system.err=對 'System.err.print' 實參忽略
inspection.option.ignore.system.out=對 'System.out.print' 實參忽略
inspection.pattern.variable.can.be.used.display.name=可以使用模式變數
inspection.pattern.variable.can.be.used.existing.cast.message=可以使用現有模式變數 ''{0}'' 代替轉換表達式
inspection.pattern.variable.can.be.used.existing.fix.family.name=取代為現有模式變數
inspection.pattern.variable.can.be.used.existing.fix.name=將 ''{0}'' 取代為現有模式變數 ''{1}''
inspection.pattern.variable.can.be.used.existing.message=可以使用現有模式變數 ''{0}'' 代替 ''{1}''
inspection.pattern.variable.can.be.used.fix.family.name=取代為模式變數
inspection.pattern.variable.can.be.used.fix.name=將 ''{0}'' 取代為模式變數
inspection.pattern.variable.can.be.used.instead.of.cast.message=轉換表達式可被取代為模式變數
inspection.pattern.variable.can.be.used.message=變數 ''{0}'' 可被取代為模式變數
inspection.pattern.variable.can.be.used.report.cast.only=報告可被取代為新引入的模式變數的轉換表達式
inspection.pattern.variable.instead.of.cast.can.be.used.existing.fix.name=將轉換表達式取代為現有模式變數 ''{0}''
inspection.pattern.variable.instead.of.cast.can.be.used.fix.family.name=將轉換表達式取代為模式變數
inspection.redundant.arguments.message=不必要的實參
inspection.redundant.class.call.display.name=冗餘的 'isInstance()' 或 'cast()' 呼叫
inspection.redundant.collection.operation.display.name=冗餘的 'Collection' 動作
inspection.redundant.collection.operation.fix.family.name=簡化集合動作
inspection.redundant.collection.operation.problem.arraycopy=為複製陣列而建立的集合不必要
inspection.redundant.collection.removal.by.index.fix=使用按物件移除
inspection.redundant.collection.removal.by.index.problem=按索引移除可被取代為按物件移除
inspection.redundant.collection.unnecessary.contains.fix=移除 ''{0}()'' 檢查
inspection.redundant.collection.unnecessary.contains.problem=不必要的 ''{0}()'' 檢查
inspection.redundant.compare.call.display.name=冗餘的 'compare()' 方法呼叫
inspection.redundant.compare.call.fix.name=內聯 'compare()' 呼叫
inspection.redundant.embedded.expression.display.name=字串模板中的冗餘嵌入式表達式
inspection.redundant.embedded.expression.fix.family.name=內聯嵌入式表達式
inspection.redundant.embedded.expression.message.empty=冗餘的空嵌入式表達式
inspection.redundant.embedded.expression.message.literal=冗餘的嵌入式字面量
inspection.redundant.empty.string.argument.message=不必要的空字串實參
inspection.redundant.explicit.variable.type.description=可以省略區域變數的顯式類型
inspection.redundant.java.time.operation.compare.java.time.family.name=使用 'java.time' 'compareTo()' 呼叫簡化表達式
inspection.redundant.java.time.operation.compare.java.time.problem.descriptor=帶有 'java.time' <code>\\#ref()</code> 呼叫的表達式可以簡化
inspection.redundant.java.time.operation.creation.java.time.error.message=''{0}'' 物件的冗餘建立
inspection.redundant.java.time.operation.creation.java.time.error.remove.fix.message=移除 ''{0}'' 呼叫
inspection.redundant.java.time.operation.creation.java.time.error.replace.fix.message=取代為 ''{0}'' 呼叫
inspection.redundant.java.time.operation.creation.java.time.family.name=簡化 'java.time' 物件的建立
inspection.redundant.java.time.operation.creation.java.time.redundant.call.message=冗餘的 ''{0}'' 呼叫
inspection.redundant.java.time.operation.creation.java.time.remove.family.name=移除不必要的呼叫
inspection.redundant.java.time.operation.display.name='java.time' 物件上的冗餘動作
inspection.redundant.java.time.operation.explicit.chrono.field.family.name=簡化帶有顯式 'ChronoField' 或 'ChronoUnit' 實參的呼叫
inspection.redundant.java.time.operation.explicit.chrono.field.problem.descriptor=帶有顯式 'ChronoField' 或 'ChronoUnit' 實參的呼叫可以簡化
inspection.redundant.length.check.display.name=冗餘的陣列長度檢查
inspection.redundant.string.call.message=<code>\\#ref()</code> 的呼叫冗餘 \\#loc
inspection.redundant.string.constructor.message=<code>new \\#ref()</code> 冗餘 \\#loc
inspection.redundant.string.fix.family.name=移除冗餘呼叫
inspection.redundant.string.fix.remove.str.processor.description=字串模板可以轉換為普通字串字面量
inspection.redundant.string.intern.on.constant.message=編譯時常量上 <code>\\#ref()</code> 的呼叫不必要 \\#loc
inspection.redundant.string.length.argument.message=不必要的字串長度實參
inspection.redundant.string.new.array.message=<code>\\#ref</code> 冗餘 \\#loc
inspection.redundant.string.operation.display.name=冗餘的 'String' 動作
inspection.redundant.string.option.do.not.report.single.argument.substring=不報告冗餘的單實參 substring() 呼叫
inspection.redundant.string.option.do.not.report.string.constructors=不報告 String 建構函式呼叫
inspection.redundant.string.remove.argument.fix.name=移除實參
inspection.redundant.string.replace.with.arg.fix.name=取代為實參
inspection.redundant.string.replace.with.empty.fix.name=取代為空字串
inspection.redundant.zero.argument.message=不必要的零實參
inspection.refused.bequest.super.annotated.option=僅在通過以下方式註解 super 方法時報告\\:
inspection.remove.redundant.call.fix.name=移除冗餘的 ''{0}()'' 呼叫
inspection.replace.on.literal.display.name=取代動作不起任何作用
inspection.simplifiable.if.statement.display.name='if' 語句可被取代為條件或布爾表達式
inspection.simplifiable.if.statement.fix.family.name=將 'if else' 取代為條件運算符
inspection.simplifiable.if.statement.fix.name=將 ''if else'' 取代為 ''{0}''
inspection.simplifiable.if.statement.message=If 語句可被取代為 ''{0}''
inspection.simplifiable.if.statement.option.dont.warn.on.ternary=不建議使用 '?\\:' 運算符
inspection.suspicious.date.format.display.name=可疑的日期格式模式
inspection.suspicious.date.format.message.lower=使用了小寫 ''{0}'' ({1}) 模式\\: 預期可能為 ''{2}'' ({3})
inspection.suspicious.date.format.message.upper=使用了大寫 ''{0}'' ({1}) 模式\\: 預期可能為 ''{2}'' ({3})
inspection.suspicious.package.private.access.description={0} 是 {1}，但在不同的模組 ''{2}'' 中宣告
inspection.suspicious.package.private.access.from.tests.description={0} 是 {1} 且在測試中使用，但在生產源中宣告
inspection.suspicious.package.private.access.from.tests.problem=測試中的 {0} 重寫了生產源中宣告的 {1} 中的 package-private 方法
inspection.suspicious.package.private.access.problem={0} 重寫了來自在不同模組 ''{2}'' 中宣告的 {1} 的 package-private 方法
inspection.test.method.without.assertion.list.name=斷言方法\\:
inspection.test.method.without.assertions.exceptions.option=忽略宣告異常的測試方法
inspection.trivial.functional.expression.usage.description=可以簡化方法呼叫
inspection.type.may.be.weakened.add.stop.class.family=新增停止類別
inspection.type.may.be.weakened.add.stop.class.selection.popup=選擇停止類別
inspection.type.may.be.weakened.add.stop.class.selection.table=停止類別
inspection.type.may.be.weakened.add.stop.class.selection.table.label=停止類別\\:
inspection.type.may.be.weakened.add.stopper=作為停止類別添加以減弱
inspection.type.may.be.weakened.add.stopper.preview=停止類別將被新增到此檢查的停止類別列表中。
inspection.type.may.be.weakened.add.stopper.single=新增 {0} 作為停止類別以削弱
inspection.type.may.be.weakened.display.name=類型可能被削弱
inspection.type.may.be.weakened.do.not.weaken.inferred.variable.type=不建議削弱宣告為 'var' 的變數
inspection.type.may.be.weakened.field.problem.descriptor=欄位 <code>\\#ref</code> 的類型可能被削弱為 {0} \\#loc
inspection.type.may.be.weakened.method.problem.descriptor=方法 <code>\\#ref()</code> 的返回值類型可能被削弱為 {0} \\#loc
inspection.type.may.be.weakened.only.weaken.to.an.interface=僅削弱為接口
inspection.type.may.be.weakened.parameter.problem.descriptor=參數 <code>\\#ref</code> 的類型可能被削弱為 {0} \\#loc
inspection.type.may.be.weakened.problem.descriptor=變數 <code>\\#ref</code> 的類型可能被削弱為 {0} \\#loc
inspection.type.may.be.weakened.quickfix=將類型削弱為 ''{0}''
inspection.type.may.be.weakened.weaken.type.family=削弱類型
inspection.unnecessary.string.escape.report.char.literals.option=報告字元字面量
inspection.unsupported.chrono.field.unit.call.display.name=使用不受支援的 'java.time.temporal.ChronoUnit' 和 'java.time.temporal.ChronoField' 呼叫方法
inspection.unsupported.chrono.value.message=不支持的實參值\\: {0}
inspection.unsupported.chrono.values.message=不支持的實參值\\: {0}
inspection.use.of.private.field.inner.classes.option=忽略來自內部類別的存取
inspection.use.of.slash.s.display.name='\\\\s' 轉義序列的非終止使用
inspection.use.of.slash.s.fix.family=將 '\\\\s' 序列取代為空格
inspection.use.of.slash.s.message=使用轉義序列 '\\\\s' 作為非尾隨空格
inspection.use.of.slash.s.non.text.block.message=在文本塊之外使用轉義序列 '\\\\s'
inspection.while.can.be.replaced.with.do.while.display.name='while' 可被取代為 'do while'
inspection.while.can.be.replaced.with.do.while.family.name=將 'while' 取代為 'do while'
inspection.while.can.be.replaced.with.do.while.message=將 'while' 取代為 'do while'
inspection.x.call.can.be.replaced.with.y=<code>\\#ref()</code> 呼叫可被取代為 ''{0}()''
instance.Variable.may.not.be.initialized.problem.descriptor.junit=執行個體欄位 <code>\\#ref</code> 在物件建構或 'setUp()' 呼叫期間可能無法初始化 \\#loc
instance.method.naming.convention.element.description=執行個體方法
instance.variable.may.not.be.initialized.display.name=執行個體欄位可能無法初始化
instance.variable.may.not.be.initialized.problem.descriptor=執行個體欄位 <code>\\#ref</code> 在物件建構期間可能無法初始化 \\#loc
instance.variable.naming.convention.element.description=執行個體欄位
instance.variable.of.concrete.class.problem.descriptor=具體類別 <code>\\#ref</code> 的執行個體欄位 ''{0}'' \\#loc
instance.variable.used.before.initialized.display.name=執行個體欄位在初始化前使用
instance.variable.used.before.initialized.problem.descriptor=初始化前使用的執行個體欄位 <code>\\#ref</code> \\#loc
instanceof.catch.parameter.display.name='catch' 參數上的 'instanceof'
instanceof.catch.parameter.problem.descriptor='catch' 參數 <code>\\#ref</code> 上的 'instanceof' \\#loc
instanceof.check.for.this.display.name='this' 的 'instanceof' 檢查
instanceof.check.for.this.equality.problem.descriptor='this' 的類別比較 \\#loc
instanceof.check.for.this.problem.descriptor=<code>\\#ref</code> 的 'instanceof' 檢查 \\#loc
instanceof.concrete.class.equality.problem.descriptor=與具體類別 <code>\\#ref</code> 的類別比較 \\#loc
instanceof.concrete.class.pattern.problem.descriptor=針對具體類別 <code>\\#ref</code> 的模式測試 \\#loc
instanceof.concrete.class.problem.descriptor='instanceof' 具體類別 <code>\\#ref</code> \\#loc
instanceof.with.incompatible.interface.display.name=具有不相容類型的 'instanceof'
instanceof.with.incompatible.interface.problem.descriptor=類型為 ''{1}'' 的表達式中具有不相容{0, choice, 1\\#接口|2\\#類別}的 ''instanceof'' <code>\\#ref</code> \\#loc
instantiating.datetimeformatter.without.locale.problem.descriptor=在未在國際化上下文中指定區域設定的情況下呼叫 <code>DateTimeFormatter.\\#ref()</code> \\#loc
instantiating.object.to.get.class.object.display.name=實例化物件以獲取 'Class' 物件
instantiating.object.to.get.class.object.problem.descriptor=實例化物件以獲取類別物件 \\#loc
instantiating.object.to.get.class.object.replace.quickfix=取代為直接類別物件存取
instantiating.simpledateformat.without.locale.display.name=無區域設定的 'SimpleDateFormat'
instantiating.simpledateformat.without.locale.problem.descriptor=在未在國際化上下文中指定區域設定的情況下實例化 <code>\\#ref</code> \\#loc
instantiation.utility.class.display.name=實用程序類別的實例化
instantiation.utility.class.problem.descriptor=實用程序類別 <code>\\#ref</code> 的實例化 \\#loc
int.literal.may.be.long.literal.display.name=轉換為 'long' 可以是 'long' 字面量
int.literal.may.be.long.literal.problem.descriptor=<code>\\#ref</code> 可被取代為 ''{0}'' \\#loc
integer.division.in.floating.point.context.display.name=浮點上下文中的整數除法
integer.division.in.floating.point.context.fix.family.name=將分子轉換為浮點類型
integer.division.in.floating.point.context.fix.name=將分子轉換為 ''{0}''
integer.division.in.floating.point.context.problem.descriptor=<code>\\#ref</code>\\: 浮點上下文中的整數除法 \\#loc
integer.multiplication.implicit.cast.to.long.display.name=整數乘法或移位隱式轉換為 'long'
integer.multiplication.implicit.cast.to.long.option=<html>忽略靜態證明不可能溢出的表達式</html>
integer.multiplication.implicit.cast.to.long.problem.descriptor=\\#ref\\: 整數乘法隱式轉換為 long \\#loc
integer.multiplication.implicit.cast.to.long.quickfix=轉換為 long
integer.shift.implicit.cast.to.long.problem.descriptor=\\#ref\\: 整數移位隱式轉換為 long \\#loc
interface.clashes.with.object.class.display.name=接口方法與 'Object' 中的方法衝突
interface.clashes.with.object.class.problem.descriptor=<code>\\#ref()</code> 與 'java.lang.Object' 中的方法衝突
interface.may.be.annotated.functional.display.name=接口可以註解為 '@FunctionalInterface'
interface.may.be.annotated.functional.problem.descriptor=接口 <code>\\#ref</code> 可以使用 @FunctionalInterface 註解
interface.naming.convention.element.description=接口
interface.never.implemented.display.name=沒有具體子類別的接口
interface.never.implemented.option=忽略僅宣告常數的接口
interface.never.implemented.problem.descriptor=接口 <code>\\#ref</code> 沒有具體子類別 \\#loc
interface.one.inheritor.display.name=只有一個直接繼承者的接口
interface.one.inheritor.problem.descriptor=只有一個直接繼承者的接口 <code>\\#ref</code> \\#loc
introduce.holder.class.quickfix=引入 holder 類別
introduce.variable.may.change.semantics.quickfix=引入變數 (可能更改語意)
introduce.variable.quickfix=引入變數
invert.method.quickfix=反轉方法
invert.quickfix=反轉 ''{0}''
invert.quickfix.family.name=反轉布爾
iterator.hasnext.which.calls.next.display.name=呼叫 'next()' 的 'Iterator.hasNext()'
iterator.hasnext.which.calls.next.problem.descriptor=<code>Iterator.{0}()</code> 包含 ''\\#ref()'' 呼叫 \\#loc
iterator.next.does.not.throw.nosuchelementexception.display.name=無法拋出 'NoSuchElementException' 的 'Iterator.next()'
iterator.next.does.not.throw.nosuchelementexception.problem.descriptor=無法拋出 'NoSuchElementException' 的 <code>Iterator.\\#ref()</code> '\\#loc
java.lang.import.display.name='java.lang' 軟體套件中有不必要的 import
java.lang.import.problem.descriptor='java.lang' 軟體套件中有不必要的 import \\#loc
jdbc.execute.with.non.constant.string.display.name='Statement.execute()' 呼叫具有非常數字串
jdbc.execute.with.non.constant.string.problem.descriptor=<code>Statement.\\#ref()</code> 呼叫具有非常數實參 \\#loc
jdbc.prepare.statement.with.non.constant.string.display.name='Connection.prepare*()' 呼叫具有非常數字串
jdbc.prepare.statement.with.non.constant.string.problem.descriptor=<code>Connection.\\#ref()</code> 呼叫具有非常數實參 \\#loc
jdbc.resource.opened.not.closed.display.name=JDBC 資源已開啟，但未安全關閉
jndi.resource.opened.not.closed.display.name=JNDI 資源已開啟，但未安全關閉
junit.abstract.test.class.naming.convention.element.description=抽象測試類別
junit.test.class.naming.convention.element.description=測試類別
junit.test.suite.naming.convention.element.description=測試套件
junit3.method.naming.convention.element.description=JUnit 3 測試方法
junit4.method.naming.convention.element.description=JUnit 4+ 測試方法
key.set.iteration.may.use.entry.set.display.name=可以最佳化對 'keySet()' 的迭代
key.set.iteration.may.use.entry.set.problem.descriptor=<code>\\#ref</code> 上的迭代可被取代為 ''{0}'' 迭代 \\#loc
key.set.iteration.may.use.entry.set.quickfix=最佳化 Map 迭代
labeled.statement.display.name=標記語句
labeled.statement.problem.descriptor=標記語句 <code>\\#ref\\:</code> \\#loc
lambda.body.can.be.code.block.name=lambda 體可以是程式碼塊
lambda.body.can.be.code.block.quickfix=將 lambda 體擴展為 {...}
lambda.can.be.replaced.with.anonymous.name=lambda 可被取代為匿名類別
lambda.can.be.replaced.with.anonymous.quickfix=將 lambda 取代為匿名類別
lambda.parameter.hides.member.variable.display.name=lambda 參數隱藏欄位
lambda.parameter.hides.member.variable.ignore.invisible.option=忽略從 lambda 實際不可見的欄位
lambda.parameter.hides.member.variable.problem.descriptor=lambda 參數 <code>\\#ref</code> 隱藏類別 ''{0}'' 中的欄位 \\#loc
lambda.parameter.naming.convention.display.name=lambda 參數命名約定
lambda.parameter.naming.convention.element.description=lambda 參數
lambda.parameter.type.can.be.specified.descriptor=Lambda 參數類型可以擴展為{0}
lambda.parameter.type.can.be.specified.family.quickfix=指定 lambda 參數類型
lambda.parameter.type.can.be.specified.name=可以指定 lambda 參數類型
lambda.parameter.type.can.be.specified.quickfix=將參數類型擴展為{0}
lambda.unfriendly.constructor.overload.problem.descriptor=建構函式 <code>\\#ref()</code> 的多載對 lambda 不友好
lambda.unfriendly.method.overload.display.name=方法多載對 lambda 不友好
lambda.unfriendly.method.overload.problem.descriptor=方法 <code>\\#ref()</code> 的多載對 lambda 不友好
large.array.allocation.no.outofmemoryerror.display.name=沒有 OutOfMemoryError 檢查的大型陣列分配
large.array.allocation.no.outofmemoryerror.maximum.number.of.elements.option=最大元素數\\:
large.array.allocation.no.outofmemoryerror.problem.descriptor=未檢查記憶體不足情況的大型陣列分配 \\#loc
large.initializer.primitive.type.array.display.name=原始類型陣列的過大初始設定式
large.initializer.primitive.type.array.maximum.number.of.elements.option=最大元素數\\:
large.initializer.primitive.type.array.problem.descriptor=具有太多元素 ({0}) 的原始陣列初始設定式 \\#loc
law.of.demeter.display.name=迪米特法則
law.of.demeter.field.problem.descriptor=對 <code>\\#ref()</code> 的存取違反迪米特法則 \\#loc
law.of.demeter.ignore.library.calls.option=忽略對庫方法的呼叫和對庫欄位的存取
law.of.demeter.problem.descriptor=對 <code>\\#ref()</code> 的呼叫違反迪米特法則 \\#loc
length.one.string.in.indexof.display.name='String.indexOf()' 呼叫中的單字元字串實參
length.one.strings.in.concatenation.display.name=單字元字串串聯
length.one.strings.in.concatenation.replace.quickfix=取代為字元
limited.scope.inner.class.display.name=區域類別
limited.scope.inner.class.problem.descriptor=區域類別 <code>\\#ref</code> \\#loc
list.indexof.replaceable.by.contains.display.name='List.indexOf()' 表達式可被取代為 'contains()'
listener.may.use.adapter.display.name=類別可以擴展適配器而不是實作偵聽器
listener.may.use.adapter.emtpy.methods.option=僅在找到空實作方法時發出警告(&O)
listener.may.use.adapter.fix.family.name=取代為適配器
listener.may.use.adapter.problem.descriptor=類別 ''{0}'' 可以擴展 ''{1}'' 而不是實作 <code>\\#ref</code> \\#loc
literal.as.arg.to.string.equals.display.name=字串字面量可以為 'equals()' 限定符
literal.as.arg.to.string.equals.flip.quickfix=翻轉 ''{0}()''
literal.as.arg.to.string.equals.problem.descriptor=字面量 \\#ref 是 ''{0}()'' 的實參，而不是其限定符 \\#loc
load.library.with.non.constant.string.display.name='System.loadLibrary()' 呼叫具有非常數字串
load.library.with.non.constant.string.problem.descriptor=<code>{0}.\\#ref()</code> 呼叫具有非常數實參 \\#loc
local.variable.hides.member.variable.display.name=區域變數隱藏欄位
local.variable.hides.member.variable.ignore.option=忽略隱藏非 static 欄位的 static 上下文中的區域變數
local.variable.hides.member.variable.problem.descriptor=區域變數 <code>\\#ref</code> 隱藏類別 ''{0}'' 中的欄位 \\#loc
local.variable.naming.convention.display.name=區域變數命名約定
local.variable.naming.convention.element.description=區域變數
local.variable.naming.convention.ignore.catch.option=忽略 'catch' 塊參數
local.variable.naming.convention.ignore.option=忽略 for 迴圈參數
local.variable.of.concrete.class.problem.descriptor=具體類別 <code>\\#ref</code> 的區域變數 ''{0}'' \\#loc
log.condition.text=日誌條件文本
log.method.name=記錄方法名稱
log.statement.guarded.by.log.condition.display.name=日誌呼叫不受日誌條件保護
log.statement.guarded.by.log.condition.flag.all.unguarded.option=標記所有不受保護的日誌呼叫
log.statement.guarded.by.log.condition.problem.descriptor=<code>\\#ref()</code> 日誌呼叫不受日誌條件保護 \\#loc
log.statement.guarded.by.log.condition.quickfix=使用日誌條件包圍
log4j.use.parameterized.logger=對於 Log4j 2，請使用與參數化記錄器相同的修正
log4j.use.parameterized.logger.description=對於 Log4j 2，如果類型無法推斷，請使用與參數化記錄器相同的修正；否則，將不會建議修正
logger.class.name=記錄器類別名\\:
logger.factory.class.name=記錄器工廠類別名
logger.factory.method.name=記錄器工廠方法名稱
logger.initialized.with.foreign.class.display.name=使用外類別初始化記錄器
logger.initialized.with.foreign.class.fix.family.name=取代外類別
logger.initialized.with.foreign.class.ignore.non.public.classes.option=忽略非 public 類別中的記錄器
logger.initialized.with.foreign.class.ignore.not.final.field=忽略未在 final 欄位中初始化的記錄器
logger.initialized.with.foreign.class.ignore.super.class.option=忽略使用超類別初始化的記錄器
logger.initialized.with.foreign.class.problem.descriptor=使用外類別 <code>\\#ref</code> 初始化記錄器 \\#loc
logger.name.option=記錄器類別名(&C)\\:
long.literals.ending.with.lowercase.l.display.name='long' 字面量以 'l' 而不是 'L' 結尾
long.literals.ending.with.lowercase.l.problem.descriptor='long' 字面量 <code>\\#ref</code> 以小寫 'l' 結尾 \\#loc
loop.condition.not.updated.inside.loop.display.name=迴圈變數未在迴圈內更新
loop.condition.not.updated.inside.loop.problem.descriptor=條件 '\\#ref' 未在迴圈內更新\\#loc
loop.statements.that.dont.loop.display.name=不迴圈的迴圈語句
loop.statements.that.dont.loop.problem.descriptor=<code>\\#ref</code> 語句未迴圈 \\#loc
loop.variable.not.updated.inside.loop.option.nonlocal=忽略可能的非本地更改
loop.variable.not.updated.inside.loop.problem.descriptor=變數 '\\#ref' 未在迴圈內更新\\#loc
loop.with.implicit.termination.condition.display.name=具有隱式終止條件的迴圈
loop.with.implicit.termination.condition.dowhile.problem.descriptor=具有隱式終止條件的 <code>\\#ref-while</code> 迴圈 \\#loc
loop.with.implicit.termination.condition.problem.descriptor=具有隱式終止條件的 <code>\\#ref</code> 迴圈 \\#loc
loop.with.implicit.termination.condition.quickfix=使條件顯式
magic.character.display.name=魔幻字元
magic.character.problem.descriptor=國際化上下文中使用的魔幻字元 <code>\\#ref</code> \\#loc
magic.number.display.name=幻數
magic.number.problem.descriptor=幻數 <code>\\#ref</code> \\#loc
make.class.final.fix.family.name=將類別設為 final
make.class.final.fix.name=將類別 ''{0}'' 設為 ''final''
make.constructor.public=將建構函式設為 'public'
make.field.final.fix.family.name=設為 final
make.field.final.quickfix=將 ''{0}'' 設為 ''final''
make.field.static.final.fix.family.name=設為 static final
make.initialization.explicit.quickfix=使初始化顯式
make.method.ctr.quickfix=使方法成為建構函式
make.method.final.fix.family.name=將方法設為 'final'
make.method.final.fix.name=將方法 ''{0}()'' 設為 ''final''
make.package.private.fix.family.name=設為 package-private
make.static.final.quickfix=將 ''{0}'' 設為 static final
make.static.quickfix=設為 'static'
malformed.format.string.display.name=字串的格式錯誤
malformed.format.string.problem.descriptor.arguments.do.not.match.type=實參類型 ''{0}'' 與格式說明符 ''{1}'' 的類型不符合 \\#loc
malformed.format.string.problem.descriptor.at.least.too.few.arguments=格式字串的實參過少(實際\\: {0}，至少應為\\: {1}) \\#loc
malformed.format.string.problem.descriptor.illegal=非法格式字串指定符\\: {0} \\#loc
malformed.format.string.problem.descriptor.malformed=格式字串 <code>\\#ref</code> 的格式錯誤 \\#loc
malformed.format.string.problem.descriptor.too.few.arguments=格式字串的實參太少(實際\\: {0}，應為\\: {1}) \\#loc
malformed.format.string.problem.descriptor.too.many.arguments=格式字串的實參太多(實際\\: {0}，應為\\: {1}) \\#loc
manual.array.copy.display.name=手動陣列複製
manual.array.copy.problem.descriptor=手動陣列複製 \\#loc
manual.array.to.collection.copy.display.name=手動陣列到集合複製
manual.array.to.collection.copy.problem.descriptor=手動陣列到集合複製 \\#loc
map.replaceable.by.enum.map.display.name='Map' 可被取代為 'EnumMap'
map.replaceable.by.enum.map.problem.descriptor=<code>\\#ref</code> 可被取代為 'EnumMap' \\#loc
markdown.documentation.comments.migration.display.name=Javadoc 註釋可以是 Markdown 文檔註釋
markdown.documentation.comments.migration.fix=轉換為 Markdown 文檔註釋
marker.interface.display.name=標記接口
marker.interface.problem.descriptor=標記接口 <code>\\#ref</code> \\#loc
masked.assertion.display.name=斷言通過 'catch' 禁止
masked.assertion.problem.description=''{0}'' 不能失敗，因為它被包圍 ''catch'' 禁止
math.random.cast.to.int.display.name='Math.random()' 轉換為 'int'
math.random.cast.to.int.problem.descriptor=<code>\\#ref</code> 轉換為 ''{0}'' 時始終向下舍入為 ''0'' \\#loc
math.random.cast.to.int.quickfix=新增括號以在轉換前執行乘法
math.rounding.with.int.argument.display.name=使用 'int' 實參呼叫數學舍入
math.rounding.with.int.argument.family.name=簡化舍入呼叫
math.rounding.with.int.argument.problem.descriptor=帶有 'int' 類型實參的 <code>\\#ref()</code> \\#loc
math.rounding.with.int.argument.quickfix=簡化 ''{0}()'' 呼叫
meta.annotation.without.runtime.retention=不含 '@Retention(RUNTIME)' 註解的測試註解
method.call.in.loop.condition.display.name=迴圈條件下的方法呼叫
method.call.in.loop.condition.problem.descriptor=迴圈條件下呼叫方法 <code>\\#ref()</code> \\#loc
method.can.be.variable.arity.method.display.name=方法可以有 varargs 參數
method.can.be.variable.arity.method.ignore.all.primitive.arrays.option=忽略所有原始陣列類型
method.can.be.variable.arity.method.ignore.byte.short.option=忽略具類型為 byte[] 或 short[] 的參數
method.can.be.variable.arity.method.ignore.multidimensional.arrays.option=忽略多維陣列參數
method.can.be.variable.arity.method.ignore.multiple.arrays.option=忽略具有多個陣列參數的方法
method.can.be.variable.arity.method.problem.descriptor=<code>\\#ref()</code> 可以轉換為 vararg 方法 \\#loc
method.complexity.limit.option=方法復雜度限制\\:
method.count.ignore.getters.setters.option=忽略簡單的 getter 和 setter 方法(&I)
method.count.limit.option=方法計數限制\\:
method.coupling.display.name=過度耦合的方法
method.coupling.limit.option=方法耦合限制\\:
method.coupling.problem.descriptor=<code>\\#ref</code> 過度耦合 (\\# 參照的類別 \\= {0}) \\#loc
method.may.be.static.display.name=方法可以為 'static'
method.may.be.static.empty.option=忽略空方法
method.may.be.static.ignore.default.methods.option=忽略 'default' 方法
method.may.be.static.only.option=僅檢查 'private' 或 'final' 方法
method.may.be.static.problem.descriptor=方法 <code>\\#ref()</code> 可能為 'static' \\#loc
method.may.be.static.replaces.qualifiers.with.class.references.option=快速修復可將執行個體限定符取代為類別參照
method.may.be.synchronized.display.name=只有一個 'synchronized' 塊的方法可被取代為 'synchronized' 方法
method.may.be.synchronized.problem.descriptor=帶 synchronized 塊的方法 <code>\\#ref()</code> 可以是 synchronized 方法 \\#loc
method.may.be.synchronized.quickfix=將方法設為 synchronized 並移除 synchronized 塊
method.name.regex=方法名稱正則表達式
method.name.same.as.class.name.display.name=方法名稱與類別名相同
method.name.same.as.class.name.problem.descriptor=方法名稱 <code>\\#ref</code> 與其類別名相同 \\#loc
method.name.same.as.parent.name.display.name=方法名稱與父類別名相同
method.name.same.as.parent.name.problem.descriptor=方法名稱 <code>\\#ref</code> 與其父類別名相同 \\#loc
method.names.differ.only.by.case.display.name=方法名稱僅大小寫不同
method.names.differ.only.by.case.problem.descriptor=方法名稱 <code>\\#ref</code> 和方法名稱 ''{0}'' 僅大小寫不同 \\#loc
method.only.used.from.inner.class.display.name=僅在內部類中使用 private 方法
method.only.used.from.inner.class.ignore.option=忽略從匿名類別或區域類別呼叫的方法(&A)
method.only.used.from.inner.class.problem.descriptor=方法 <code>\\#ref()</code>\\#loc 只能從{0, choice, 1\\#內部|2\\#區域|3\\#}{1, choice, 1\\#類別|2\\#接口|3\\#派生的匿名類別|4\\#註解類型|5\\#枚舉|6\\#記錄} ''{2}'' 使用 \\#loc
method.overloads.display.name=可能是超類別方法意外多載
method.overloads.problem.descriptor=當可能打算覆寫時，方法 <code>\\#ref()</code> 多載超類別的相容方法 \\#loc
method.overloads.report.incompatible.option=即使參數類型不相容，也會報告
method.overrides.inaccessible.method.display.name=方法覆寫了超類別不可存取的方法
method.overrides.package.local.method.problem.descriptor=方法 <code>\\#ref()</code> 覆寫了位於另一個軟體套件中的超類別的 package-private 方法 \\#loc
method.overrides.private.display.name.problem.descriptor=方法 <code>\\#ref()</code> 重寫了超類別的 'private' 方法 \\#loc
method.overrides.static.display.name=方法嘗試覆寫超類別的 'static' 方法
method.overrides.static.problem.descriptor=方法 <code>\\#ref()</code> 嘗試覆寫超類別的 static 方法 \\#loc
method.ref.can.be.replaced.with.lambda.name=方法參照可被取代為 lambda
method.ref.can.be.replaced.with.lambda.quickfix=將方法參照取代為 lambda
method.ref.can.be.replaced.with.lambda.quickfix.no.side.effects=將可能的副作用保留在 lambda 內部
method.ref.can.be.replaced.with.lambda.quickfix.side.effects=將可能的副作用提取到變數中
method.return.always.constant.display.name=方法返回類別特定的常數
method.return.always.constant.problem.descriptor=方法 <code>\\#ref()</code> 及其所有派生方法始終返回常數
method.return.concrete.class.problem.descriptor=方法返回一個具體類別 <code>\\#ref</code> \\#loc
method.with.multiple.loops.display.name=具有多個迴圈的方法
method.with.multiple.loops.problem.descriptor=<code>\\#ref</code> 包含 {0} 個迴圈 \\#loc
mismatched.read.write.array.display.name=陣列的讀取和寫入不符合
mismatched.read.write.array.problem.descriptor.read.not.write=陣列 <code>\\#ref</code> 的內容已讀取，但從未被寫入 \\#loc
mismatched.read.write.array.problem.descriptor.write.not.read=陣列 <code>\\#ref</code> 的內容已寫入，但從未被讀取 \\#loc
mismatched.string.builder.queried.problem.descriptor=<code>{0} \\#ref</code> 的內容已查詢，但從未更新 \\#loc
mismatched.string.builder.query.update.display.name='StringBuilder' 的查詢和更新不符合
mismatched.string.builder.updated.problem.descriptor=<code>{0} \\#ref</code> 的內容已更新，但從未被查詢 \\#loc
mismatched.update.collection.display.name=不符合的集合查詢和更新
mismatched.update.collection.problem.description.no.effect.updates=對空集合 <code>\\#ref</code> 進行的更新動作無效 \\#loc
mismatched.update.collection.problem.description.queried.empty=空集合 <code>\\#ref</code> 的內容已被查詢，但從未填充 \\#loc
mismatched.update.collection.problem.description.queried.not.updated=集合 <code>\\#ref</code> 的內容已被查詢，但從未更新 \\#loc
mismatched.update.collection.problem.description.updated.not.queried=集合 <code>\\#ref</code> 的內容已更新，但從未被查詢 \\#loc
misordered.assert.equals.arguments.display.name=順序錯誤的 'assertEquals()' 實參
misordered.assert.equals.arguments.flip.quickfix=翻轉比較實參
misordered.assert.equals.arguments.problem.descriptor=<code>\\#ref()</code> 的實參順序錯誤 \\#loc
missing.add.deprecated.javadoc.tag.quickfix=新增 '@deprecated' Javadoc 標記說明
missing.deprecated.annotation.add.quickfix=新增 '@Deprecated' 註解
missing.deprecated.annotation.display.name=缺少 '@Deprecated' 註解
missing.deprecated.annotation.problem.descriptor=缺少 '@Deprecated' 註解 \\#loc
missing.deprecated.tag.option=警告缺少 @deprecated Javadoc 標記說明
missing.deprecated.tag.problem.descriptor=缺少 '@deprecated' Javadoc 標記說明 \\#loc
missing.override.annotation.display.name=缺少 '@Override' 註解
missing.override.annotation.in.overriding.problem.descriptor=覆寫方法未使用 '@Override' 註解
missing.override.annotation.problem.descriptor=缺少關於 <code>\\#ref()</code> 的 '@Override' 註解 \\#loc
missing.override.warn.on.super.option=當方法的覆寫方法並非全部具有 '@Override' 註解時，醒目提示該方法
missing.package.html.problem.descriptor=軟體套件 ''{0}'' 缺少 <code>package.html</code> 檔案
missing.package.info.display.name=缺少 'package-info.java'
missing.package.info.problem.descriptor=軟體套件 ''{0}'' 缺少 <code>package-info.java</code> 檔案
missing.serial.annotation.display.name=可以使用 '@Serial' 註解
missing.serial.annotation.on.field.problem.descriptor=<code>\\#ref</code> 可以使用 '@Serial' 進行註解
missing.serial.annotation.on.method.problem.descriptor=<code>\\#ref()</code> 可以使用 '@Serial' 進行註解
missorted.modifiers.allowed.place=TYPE_USE 註解遵循生成選項
missorted.modifiers.allowed.place.description=啟用此選項時，如果目標 TYPE_USE 註解的位置不符合<pre>設定 | 編輯器 | 程式碼樣式 | Java | 程式碼生成</pre>中的 <pre>{0}</pre> 選項，將報告目標 TYPE_USE 註解。停用此選項時，目標 TYPE_USE 註解可以直接位於類型之前或修飾符關鍵字之前。
missorted.modifiers.display.name=錯位修飾符
missorted.modifiers.problem.descriptor=錯位修飾符 <code>{0}</code> \\#loc
missorted.modifiers.require.option=檢查註解順序
missorted.modifiers.require.option.description=使用此選項可以報告錯誤位置的註解\\: 帶有 <code>ElementType.TYPE_USE</code> 的註解<em>不</em>直接位於類型之前且位於修飾符關鍵字之後，或者其他註解<em>不</em>位於修飾符關鍵字之前。停用此選項時，註解可以位於修飾符關鍵字之前或之後。將始終報告位於修飾符關鍵字之間的註解。
missorted.modifiers.sort.quickfix=對修飾符排序
misspelled.equals.display.name='equal()' 代替 'equals()'
misspelled.equals.problem.descriptor=<code>\\#ref()</code> 方法可能應當是 'equals()' \\#loc
module.with.too.few.classes.display.name=類別過少的模組
module.with.too.few.classes.min.option=最小類別數\\:
module.with.too.few.classes.problem.descriptor=模組 ''{0}'' 包含過少的類別 ({1} < {2})
module.with.too.many.classes.display.name=類別過多的模組
module.with.too.many.classes.max.option=最大類別數\\:
module.with.too.many.classes.problem.descriptor=模組 ''{0}'' 包含過多的類別 ({1} > {2})
move.anonymous.to.inner.quickfix=轉換為命名內部類別
move.class.quickfix=移動類別
move.exception.to.javadoc.fix.family.name=移至 Javadoc '@throws'
move.local.to.inner.quickfix=轉換為內部類別
multi.catch.can.be.split.name=多 catch 可拆分為單獨的 catch 塊
multi.catch.can.be.split.quickfix=將多 catch 拆分為單獨的 'catch' 塊
multiple.declaration.array.only.option=僅在單個宣告中對不同的陣列次元發出警告
multiple.declaration.display.name=一個宣告中的多個變數
multiple.declaration.ignore.for.option=忽略 'for' 迴圈宣告
multiple.declaration.problem.descriptor=一個宣告中的多個變數 \\#loc
multiple.loggers.display.name=具有多個記錄器的類別
multiple.loggers.problem.descriptor=類別 <code>\\#ref</code> 宣告多個記錄器 \\#loc
multiple.return.points.per.method.display.name=具有多個返回點的方法
multiple.return.points.per.method.problem.descriptor=<code>\\#ref</code> 具有 {0} 個返回點 \\#loc
multiple.top.level.classes.in.file.display.name=單個檔案中的多個頂級類別
multiple.top.level.classes.in.file.problem.descriptor=檔案中的多個頂級類別
multiple.typed.declaration.problem.descriptor=在一個宣告中具有不同陣列次元的變數 \\#loc
multiply.or.divide.by.power.of.two.display.name=乘以或除以 2 的冪
multiply.or.divide.by.power.of.two.divide.option=還通過 2 的冪檢查除法
multiply.or.divide.by.power.of.two.replace.quickfix=取代為移位
naked.notify.display.name=沒有相應狀態更改的 'notify()' 或 'notifyAll()'
naked.notify.problem.descriptor=在沒有相應狀態更改的情況下呼叫 <code>\\#ref()</code> \\#loc
naming.convention.problem.descriptor.long={0} 名稱 <code>\\#ref</code> 過長({1} > {2}) \\#loc
naming.convention.problem.descriptor.regex.mismatch={0} 名稱 <code>\\#ref</code> 不符合正則表達式 ''{1}'' \\#loc
naming.convention.problem.descriptor.short={0} 名稱 <code>\\#ref</code> 過短({1} < {2}) \\#loc
native.method.display.name=本地方法
native.method.naming.convention.element.description='native' 方法
native.method.problem.descriptor=宣告為 <code>\\#ref</code> 的方法不可移植 \\#loc
negated.conditional.display.name=具有否定條件的條件表達式
negated.conditional.expression.display.name=否定條件表達式
negated.conditional.expression.problem.descriptor=否定條件表達式 \\#loc
negated.conditional.expression.quickfix=移除否定
negated.conditional.invert.quickfix=反轉條件
negated.conditional.problem.descriptor=具有否定條件的條件表達式 \\#loc
negated.equality.expression.display.name=否定相等表達式
negated.equality.expression.problem.descriptor=否定 ''{0}'' \\#loc
negated.equality.expression.quickfix=移除否定
negated.if.else.display.name=具有否定條件的 'if' 語句
negated.if.else.ignore.negated.null.option=忽略 '\\!\\= null' 比較
negated.if.else.ignore.negated.zero.option=忽略 '\\!\\= 0' 比較
negated.if.else.invert.quickfix=反轉 'if' 條件
negated.if.else.problem.descriptor=帶嵌套條件的 <code>\\#ref</code> 語句 \\#loc
negative.int.constant.in.long.context.display.name=長整數型上下文中的負整數型十六進制常數
negative.int.constant.in.long.context.fix.add.suffix=新增 'L' 後綴(更改語意)
negative.int.constant.in.long.context.fix.convert=轉換為長整數型常數(保留語意)
negatively.named.boolean.variable.display.name=否定命名的布爾變數
negatively.named.boolean.variable.problem.descriptor=布爾變數 <code>\\#ref</code> 已否定命名 \\#loc
nested.assignment.display.name=嵌套指派
nested.assignment.problem.descriptor=使用的指派表達式的結果 \\#loc
nested.conditional.expression.display.name=嵌套條件表達式
nested.conditional.expression.problem.descriptor=嵌套條件表達式 <code>\\#ref</code> \\#loc
nested.method.call.display.name=嵌套方法呼叫
nested.method.call.ignore.option=忽略欄位初始設定式中的嵌套方法呼叫
nested.method.call.problem.descriptor=嵌套方法呼叫 <code>\\#ref()</code> \\#loc
nested.switch.statement.display.name=嵌套 'switch' 語句
nested.switch.statement.problem.descriptor=嵌套 <code>\\#ref</code> {0} \\#loc
nested.synchronized.statement.display.name=嵌套 'synchronized' 語句
nested.synchronized.statement.problem.descriptor=嵌套 <code>\\#ref</code> 語句 \\#loc
nested.try.statement.display.name=嵌套 'try' 語句
nested.try.statement.problem.descriptor=嵌套 <code>\\#ref</code> 語句 \\#loc
nesting.depth.display.name=過度嵌套的方法
nesting.depth.limit.option=嵌套深度限制\\:
nesting.depth.problem.descriptor=<code>\\#ref</code> 過度嵌套 (最大嵌套深度 \\= {0}) \\#loc
new.exception.without.arguments.display.name=未使用實參呼叫異常建構函式
new.exception.without.arguments.problem.descriptor=<code>new \\#ref()</code> 沒有實參 \\#loc
new.method.naming.convention.display.name=方法命名約定
new.string.buffer.replaceable.by.string.problem.descriptor=<code>\\#ref</code> 可被取代為 'String' \\#loc
new.string.buffer.with.char.argument.display.name=StringBuilder 建構函式呼叫具有 'char' 實參
new.string.buffer.with.char.argument.problem.descriptor=<code>new \\#ref()</code> 具有 'char' 類型的實參 \\#loc
new.string.buffer.with.char.argument.quickfix=將字元實參取代為字串字面量
no.logger.display.name=不帶記錄器的類別
no.logger.problem.descriptor=類別 <code>\\#ref</code> 未宣告記錄器 \\#loc
non.atomic.operation.on.volatile.field.display.name='volatile' 欄位上的非原子動作
non.atomic.operation.on.volatile.field.problem.descriptor=volatile 欄位 <code>\\#ref</code> 上的非原子動作 \\#loc
non.boolean.method.name.must.not.start.with.question.display.name=非布爾方法名稱不能以疑問詞開頭
non.boolean.method.name.must.not.start.with.question.problem.descriptor=非布爾方法名稱 <code>\\#ref</code> 以疑問詞開頭 \\#loc
non.comment.source.statements.display.name=過長的方法
non.comment.source.statements.limit.option=非註釋源語句限制\\:
non.comment.source.statements.problem.descriptor=<code>\\#ref</code> 過長 (\\# 非註釋源語句 \\= {0}) \\#loc
non.constant.logger.display.name=非常數記錄器
non.constant.logger.problem.descriptor=非常數記錄器欄位 <code>\\#ref</code> \\#loc
non.exception.name.ends.with.exception.display.name=非異常類別名以 'Exception' 結尾
non.exception.name.ends.with.exception.problem.descriptor=非異常類別名 <code>\\#ref</code> 以 'Exception' 結尾 \\#loc
non.exception.name.ends.with.exception.quickfix=使 ''{0}'' 擴展 ''java.lang.Exception''
non.final.clone.display.name=非 final 'clone()' 位於安全上下文中
non.final.clone.problem.descriptor=非 final <code>\\#ref()</code> 方法，影響安全性 \\#loc
non.final.field.compareto.display.name='compareTo()' 中參照了非 final 欄位
non.final.field.compareto.problem.descriptor=在 'compareTo()' 中存取了非 final 欄位 <code>\\#ref</code> \\#loc
non.final.field.in.enum.display.name='enum' 中的非 final 欄位
non.final.field.in.enum.problem.descriptor=枚舉 ''{0}'' 中存在非 final 欄位 <code>\\#ref</code> \\#loc
non.final.field.in.enum.quickfix.option=忽略無法成為 'final' 的欄位
non.final.field.in.equals.display.name='equals()' 中參照了非 final 欄位
non.final.field.in.equals.problem.descriptor=在 'equals()' 中存取了非 final 欄位 <code>\\#ref</code> \\#loc
non.final.field.in.hashcode.display.name='hashCode()' 中參照了非 final 欄位
non.final.field.in.hashcode.problem.descriptor=在 'hashCode()' 中存取了非 final 欄位 <code>\\#ref</code> \\#loc
non.final.field.of.exception.display.name='Exception' 類別的非 final 欄位
non.final.field.of.exception.problem.descriptor=異常類別的非 final 欄位 <code>\\#ref</code> \\#loc
non.final.static.variable.initialization.display.name=在類別初始化期間使用非 final static 欄位
non.final.static.variable.initialization.problem.descriptor=在類別初始化期間使用非 final static 欄位 <code>\\#ref</code> \\#loc
non.final.utility.class.display.name=實用程序類別不為 'final'
non.final.utility.class.problem.descriptor=實用程序類別 <code>\\#ref</code> 不為 'final' \\#loc
non.protected.constructor.in.abstract.class.display.name=抽象類別中的 public 建構函式
non.protected.constructor.in.abstract.class.ignore.option=對非 public 類別忽略
non.protected.constructor.in.abstract.class.problem.descriptor=抽象類別的建構函式 <code>\\#ref()</code> 不應宣告為 'public' \\#loc
non.public.clone.display.name='clone()' 方法不是 'public'
non.public.clone.problem.descriptor=<code>\\#ref()</code> 方法不是 'public' \\#loc
non.reproducible.math.call.display.name=對 'Math' 的不可重現呼叫
non.reproducible.math.call.problem.descriptor=<code>Math.\\#ref()</code> 可能產生不可重現的結果 \\#loc
non.reproducible.math.call.replace.quickfix=取代為 'StrictMath' 呼叫
non.serializable.@interface.with.serialversionuid.problem.descriptor=定義 'serialVersionUID' 欄位的不可序列化 @interface <code>\\#ref</code> \\#loc
non.serializable.anonymous.with.serialversionuid.problem.descriptor=派生自 <code>\\#ref</code> 的不可序列化匿名類別定義 'serialVersionUID' 欄位 \\#loc
non.serializable.class.with.readwriteobject.display.name=具有 'readObject()' 或 'writeObject()' 的不可序列化類別
non.serializable.class.with.readwriteobject.problem.descriptor.both=不可序列化{0, choice, 1\\#類別|2\\#接口|3\\#派生的匿名類別|4\\#註解類型|5\\#枚舉|6\\#記錄} <code>\\#ref</code> 定義 'readObject()' 和 'writeObject()' \\#loc
non.serializable.class.with.readwriteobject.problem.descriptor.read=不可序列化{0, choice, 1\\#類別|2\\#接口|3\\#派生的匿名類別|4\\#註解類型|5\\#枚舉|6\\#記錄} <code>\\#ref</code> 定義 'readObject()' \\#loc
non.serializable.class.with.readwriteobject.problem.descriptor.write=不可序列化{0, choice, 1\\#類別|2\\#接口|3\\#派生的匿名類別|4\\#註解類型|5\\#枚舉|6\\#記錄} <code>\\#ref</code> 定義 'writeObject()' \\#loc
non.serializable.class.with.serialversionuid.problem.descriptor=定義 'serialVersionUID' 欄位的不可序列化類別 <code>\\#ref</code> \\#loc
non.serializable.component.in.serializable.record.problem.descriptor=Serializable 記錄中存在非 Serializable 元件 '\\#ref' \\#loc
non.serializable.field.in.serializable.class.display.name='Serializable' 類別中有不可序列化的欄位
non.serializable.field.in.serializable.class.problem.descriptor=Serializable 類別中存在非 Serializable 欄位 '\\#ref' \\#loc
non.serializable.interface.with.serialversionuid.problem.descriptor=定義 'serialVersionUID' 欄位的不可序列化接口 <code>\\#ref</code> \\#loc
non.serializable.object.bound.to.http.session.display.name=不可序列化的物件被綁定到了 'HttpSession'
non.serializable.object.bound.to.http.session.problem.descriptor=傳遞給 HttpSession 的不可序列化物件 \\#loc
non.serializable.object.passed.to.object.stream.display.name=不可序列化的物件被傳遞給了 'ObjectOutputStream'
non.serializable.object.passed.to.object.stream.problem.descriptor=傳遞給 ObjectOutputStream 的不可序列化物件 \\#loc
non.serializable.with.serialversionuid.display.name=具有 'serialVersionUID' 的不可序列化類別
non.short.circuit.boolean.expression.display.name=非短路布爾表達式
non.short.circuit.boolean.expression.problem.descriptor=非短路布爾表達式 <code>\\#ref</code> \\#loc
non.short.circuit.boolean.expression.replace.quickfix=取代為短路表達式
non.synchronized.method.overrides.synchronized.method.display.name=未同步方法覆寫 'synchronized' 方法
non.synchronized.method.overrides.synchronized.method.problem.descriptor=未同步方法 <code>\\#ref()</code> 覆寫 synchronized 方法 \\#loc
non.thread.safe.lazy.initialization.display.name=不安全的 'static' 欄位延遲初始化
non.thread.safe.lazy.initialization.problem.descriptor='static' 欄位 <code>\\#ref</code> 的延遲初始化不是執行緒安全 \\#loc
none=無
noop.method.in.abstract.class.display.name='abstract' 類別中的無運算方法
noop.method.in.abstract.class.problem.descriptor=無動作方法 <code>\\#ref()</code> 應當設為 abstract \\#loc
normalize.declaration.quickfix=拆分為單獨的宣告
not.object.equals.can.be.equality.problem.descriptor=<code>\\!\\#ref()</code> 可被取代為 '\\!\\='
notify.called.on.condition.display.name=在 'java.util.concurrent.locks.Condition' 物件上呼叫了 'notify()' 或 'notifyAll()'
notify.called.on.condition.problem.descriptor=在條件物件上呼叫 <code>\\#ref()</code> \\#loc
notify.without.corresponding.wait.display.name=沒有相應 'wait()' 的 'notify()'
notify.without.corresponding.wait.problem.descriptor=在沒有相應 <code>wait()</code> 的情況下呼叫 <code>\\#ref()</code> \\#loc
null.argument.to.var.arg.method.display.name=引起混淆的 vararg 方法實參
null.argument.to.var.arg.method.problem.descriptor=引起混淆的實參 <code>\\#ref</code>，不清楚是否需要 vararg 或非 vararg 呼叫 \\#loc
null.thrown.display.name=已拋出 'null'
null.thrown.problem.descriptor=已拋出 <code>\\#ref</code> \\#loc
number.comparison.display.name=使用 '\\=\\=' 而不是 'equals()' 進行數字比較
number.comparison.problem.descriptor=使用 <code>\\#ref</code> 而不是 'equals()' 來比較數字物件 \\#loc
object.allocation.in.loop.display.name=迴圈中的物件分配
object.allocation.in.loop.new.descriptor=迴圈中的物件分配 <code>new \\#ref()</code> \\#loc
object.allocation.in.loop.problem.array.initializer.descriptor=迴圈中的陣列分配 \\#loc
object.allocation.in.loop.problem.call.descriptor=物件分配通過迴圈中的 <code>\\#ref()</code> 呼叫完成 \\#loc
object.allocation.in.loop.problem.lambda.descriptor=物件分配通過捕獲迴圈中的 lambda 完成 \\#loc
object.allocation.in.loop.problem.methodref.descriptor=物件分配通過迴圈中的執行個體綁定方法參照 <code>\\#ref()</code> 完成 \\#loc
object.allocation.in.loop.problem.string.concat=物件分配通過迴圈中的字串串聯完成 \\#loc
object.comparison.display.name=使用 '\\=\\=' 而不是 'equals()' 進行物件比較
object.comparison.enumerated.ignore.option=忽略枚舉變數之間的 '\\=\\='
object.comparison.klass.ignore.option=忽略沒有 'equals()' 實作的 final 類別類型之間的 '\\=\\='
object.comparison.problem.description=使用 <code>\\#ref</code> 而不是 'equals()' 來比較物件值 \\#loc
object.equality.ignore.between.objects.of.a.type.with.only.private.constructors.option=忽略只有 'private' 建構函式的類型物件之間的 '\\=\\='
object.equals.can.be.equality.display.name='equals()' 呼叫可被取代為 '\\=\\='
object.equals.can.be.equality.problem.descriptor=<code>\\#ref()</code> 可被取代為 '\\=\\='
object.instantiation.inside.equals.or.hashcode.display.name='equals()' 或 'hashCode()' 內部的物件實例化
object.instantiation.inside.equals.or.hashcode.problem.descriptor=''{0}()'' 內部的物件實例化 \\#loc
object.instantiation.inside.equals.or.hashcode.problem.descriptor2=''{0}()'' ({1}) 內部的物件實例化 \\#loc
object.notify.display.name=呼叫 'notify()' 而不是 'notifyAll()'
object.notify.problem.descriptor=<code>\\#ref</code> 可能應當取代為 'notifyAll()' \\#loc
objects.hash.fix.family.name=使用 'Arrays.hashCode()' 包裝
objects.hash.problem.descriptor=傳遞給 'Objects.hash()' 的陣列應包裝在 'Arrays.hashcode()' 中
octal.and.decimal.integers.in.same.array.display.name=同一陣列中的八進制和十進制整數
octal.and.decimal.integers.in.same.array.problem.descriptor=同一陣列初始設定式中的八進制和十進制整數 \\#loc
octal.literal.display.name=八進制整數
octal.literal.problem.descriptor=八進制整數 <code>\\#ref</code> \\#loc
only.report.public.methods.option=僅報告 'public' 方法
only.report.qualified.static.usages.option=僅報告來自 static 上下文的限定靜態存取
only.report.static.methods=僅報告 'static' 方法(&O)
only.warn.on.protected.clone.methods=僅對 'protected' 克隆方法發出警告
only.warn.on.public.clone.methods=僅對 'public' 克隆方法發出警告
optional.contains.array.problem.descriptor='Optional' 包含陣列 <code>\\#ref</code>
optional.contains.collection.display.name='Optional' 包含陣列或集合
optional.contains.collection.problem.descriptor='Optional' 包含集合 <code>\\#ref</code>
optional.used.as.field.or.parameter.type.display.name=用作欄位或參數類型的 'Optional'
optional.used.as.field.type.problem.descriptor=<code>\\#ref</code> 用作欄位 ''{0}'' 的類型
optional.used.as.parameter.type.problem.descriptor=<code>\\#ref</code> 用作參數 ''{0}'' 的類型
options.label.ignored.classes=已忽略的類別\\:
options.title.ignored.classes=已忽略的類別
overloaded.methods.with.same.number.parameters.display.name=具有相同參數數量的多載方法
overloaded.methods.with.same.number.parameters.option=<html>忽略參數類型絕對不相容的多載方法</html>
overloaded.methods.with.same.number.parameters.problem.descriptor=具有相同數量參數的多個方法命名 <code>\\#ref</code> \\#loc
overloaded.vararg.constructor.problem.descriptor=多載 vararg 建構函式 <code>\\#ref()</code> \\#loc
overloaded.vararg.method.display.name=多載 vararg 方法
overloaded.vararg.method.problem.descriptor=多載 vararg 方法 <code>\\#ref()</code> \\#loc
overloaded.vararg.method.problem.option=忽略參數類型絕對不相容的多載方法
overly.broad.throws.clause.display.name=過寬的 'throws' 子句
overly.broad.throws.clause.ignore.thrown.option=忽略隱藏其他異常但自身被拋出的異常(&H)
overly.broad.throws.clause.problem.descriptor1=<code>throws \\#ref</code> 過寬，遮罩異常 ''{0}'' \\#loc
overly.broad.throws.clause.problem.descriptor2=<code>throws \\#ref</code> 過寬，遮罩異常 ''{0}'' 和 ''{1}'' \\#loc
overly.broad.throws.clause.quickfix1=新增特定異常
overly.broad.throws.clause.quickfix2=取代為特定異常
overly.broad.throws.clause.threshold.option=要報告的最大隱藏異常數\\:
overly.complex.anonymous.inner.class.display.name=過度複雜的匿名類別
overly.complex.anonymous.inner.class.problem.descriptor=過度複雜的匿名類別 (迴圈復雜度 \\= {0}) \\#loc
overly.complex.arithmetic.expression.display.name=過於複雜的算術表達式
overly.complex.arithmetic.expression.max.number.option=最大項數\\:
overly.complex.arithmetic.expression.problem.descriptor=過於複雜的算術表達式 \\#loc
overly.complex.boolean.expression.display.name=過度複雜的布爾表達式
overly.complex.boolean.expression.ignore.option=忽略純合取和析取
overly.complex.boolean.expression.max.terms.option=最大項數\\:
overly.complex.boolean.expression.problem.descriptor=過度複雜的布爾表達式 ({0} 項) \\#loc
overly.complex.class.display.name=過度複雜的類別
overly.complex.class.problem.descriptor=過度複雜的類別<code>\\#ref</code> (迴圈復雜度 \\= {0}) \\#loc
overly.coupled.class.class.coupling.limit.option=類別耦合限制\\:
overly.coupled.class.display.name=過度耦合的類別
overly.coupled.class.problem.descriptor=<code>\\#ref</code> 過度耦合 (相依 \\= {0}) \\#loc
overly.long.lambda.display.name=過長的 lambda 表達式
overly.long.lambda.problem.descriptor=lambda 表達式過長 (\\# 非註釋源語句 \\= {0}) \\#loc
overly.strong.type.cast.display.name=過強的類型轉換
overly.strong.type.cast.ignore.in.matching.instanceof.option=忽略具有符合 instanceof 表達式的轉換
overly.strong.type.cast.problem.descriptor=到 <code>\\#ref</code> 的轉換可以被削弱為 ''{0}'' \\#loc
overly.strong.type.cast.weaken.quickfix=削弱過強的轉換
overridable.method.call.in.constructor.display.name=物件建構期間呼叫的可覆寫方法
overridable.method.call.in.constructor.problem.descriptor=物件建構期間呼叫可覆寫方法 <code>\\#ref()</code> \\#loc
overridden.method.call.in.constructor.display.name=覆寫的方法在物件建構期間呼叫
overridden.method.call.in.constructor.problem.descriptor=物件建構期間呼叫已覆寫方法 <code>\\#ref()</code> \\#loc
package.dot.html.may.be.package.info.convert.quickfix=轉換為 'package-info.java'
package.dot.html.may.be.package.info.delete.quickfix=刪除 'package.html'
package.dot.html.may.be.package.info.display.name='package.html' 可以轉換為 'package-info.java'
package.dot.html.may.be.package.info.exists.problem.descriptor=<code>package.html</code> 被忽略，因為 <code>package-info.java</code> 存在
package.dot.html.may.be.package.info.problem.descriptor=<code>package.html</code> 可以轉換為 <code>package-info.java</code>
package.in.multiple.modules.display.name=具有多個模組中的類別的軟體套件
package.in.multiple.modules.problem.descriptor.many=軟體套件 ''{0}'' 具有模組 ''{1}''、''{2}'' 以及其他 {3} 個模組中的類別
package.in.multiple.modules.problem.descriptor2=軟體套件 ''{0}'' 具有模組 ''{1}'' 和 ''{2}'' 中的類別
package.in.multiple.modules.problem.descriptor3=軟體套件 ''{0}'' 具有模組 ''{1}''、''{2}'' 和 ''{3}'' 中的類別
package.info.java.without.package.display.name=不帶 'package' 語句的 'package-info.java'
package.info.without.package.family.quickfix=新增 package 語句
package.info.without.package.problem.descriptor='package-info.java' 沒有 'package' 語句
package.info.without.package.quickfix=新增 ''package {0};''
package.local.field.not.accessible=package-private 欄位 ''{0}'' 無法從此處存取
package.local.private=package-private 與 private
package.naming.convention.display.name=軟體套件命名約定
package.naming.convention.problem.descriptor.long=軟體套件名稱 <code>{0}</code> 過長
package.naming.convention.problem.descriptor.regex.mismatch=軟體套件名稱 <code>{0}</code> 與正則表達式 ''{1}'' 不符合
package.naming.convention.problem.descriptor.short=軟體套件名稱 <code>{0}</code> 過短
package.visible.field.display.name=軟體套件可見欄位
package.visible.field.problem.descriptor=軟體套件可見欄位 <code>\\#ref</code> \\#loc
package.visible.inner.class.display.name=軟體套件可見的嵌套類別
package.visible.inner.class.ignore.enum.option=忽略軟體套件可見的內部枚舉
package.visible.inner.class.ignore.interface.option=忽略軟體套件可見的內部接口
package.visible.inner.class.problem.descriptor=軟體套件可見的嵌套類別 <code>\\#ref</code> \\#loc
package.with.too.few.classes.display.name=軟體套件具有過少類別
package.with.too.few.classes.min.option=最小類別數\\:
package.with.too.few.classes.problem.descriptor=軟體套件 ''{0}'' 包含過少的類別 ({1} < {2})
package.with.too.many.classes.display.name=類別過多的軟體套件
package.with.too.many.classes.max.option=最大類別數\\:
package.with.too.many.classes.problem.descriptor=軟體套件 ''{0}'' 包含過多的類別 ({1} > {2})
parameter.hides.member.variable.display.name=參數隱藏欄位
parameter.hides.member.variable.ignore.abstract.methods.option=對 abstract 方法忽略
parameter.hides.member.variable.ignore.constructors.option=對建構函式忽略
parameter.hides.member.variable.ignore.setters.option=對屬性 setter 忽略
parameter.hides.member.variable.ignore.static.parameters.option=對隱藏執行個體欄位的 static 方法參數忽略
parameter.hides.member.variable.ignore.superclass.option=忽略從子類別不可見的超類別欄位
parameter.hides.member.variable.problem.descriptor=參數 <code>\\#ref</code> 隱藏類別 ''{0}'' 中的欄位 \\#loc
parameter.limit.option=參數限制\\:
parameter.name.differs.from.overridden.parameter.display.name=參數名稱與覆寫或多載方法中的參數不同
parameter.name.differs.from.overridden.parameter.ignore.character.option=如果覆寫的參數僅包含一個字元，則忽略
parameter.name.differs.from.overridden.parameter.ignore.library.option=如果覆寫的參數來自庫，則忽略
parameter.name.differs.from.overridden.parameter.problem.descriptor=參數名 <code>\\#ref</code> 不同於{1, choice, 1\\#super 方法|2\\#多載方法|3\\#super 建構函式|4\\#多載建構函式}中的參數 ''{0}'' \\#loc
parameter.naming.convention.display.name=方法參數命名約定
parameter.naming.convention.element.description=參數
parameter.type.prevents.overriding.display.name=參數類型阻止覆寫
parameter.type.prevents.overriding.family.quickfix=更改參數類型
parameter.type.prevents.overriding.problem.descriptor=參數類型 <code>\\#ref</code> 位於 ''{0}''，而 super 方法參數類型位於 ''{1}''，可防止覆寫 \\#loc
parameter.type.prevents.overriding.quickfix=將參數類型更改為 ''{0}''
parameters.per.constructor.display.name=參數過多的建構函式
parameters.per.constructor.problem.descriptor=<code>\\#ref()</code> 的參數過多(參數數量 \\= {0}) \\#loc
parameters.per.method.display.name=參數過多的方法
parameters.per.method.problem.descriptor=<code>\\#ref()</code> 的參數過多(參數數量 \\= {0}) \\#loc
pattern.variable.hides.field.display.name=模式變數隱藏欄位
pattern.variable.hides.field.problem.descriptor=模式變數 <code>\\#ref</code> 隱藏類別 ''{0}'' 中的欄位 \\#loc
pointless.arithmetic.expression.display.name=無意義的算術表達式
pointless.bitwise.expression.display.name=無意義的按位表達式
pointless.bitwise.expression.simplify.quickfix=簡化
pointless.boolean.expression.display.name=無意義的布爾表達式
pointless.boolean.expression.ignore.option=在確定無意義表達式時忽略命名常數
pointless.indexof.comparison.always.false.problem.descriptor=<code>\\#ref</code> 始終為 false \\#loc
pointless.indexof.comparison.always.true.problem.descriptor=<code>\\#ref</code> 始終為 true \\#loc
pointless.indexof.comparison.display.name=無意義的 'indexOf()' 比較
pointless.nullcheck.display.name=方法呼叫前出現不必要的 'null' 檢查
pointless.nullcheck.problem.descriptor.call=''{0}()'' 呼叫之前的 ''null'' 檢查不必要
possible.throw.from.finally.block.problem.descriptor=<code>{0}</code> 可能在 ''finally'' 塊內拋出 \\#loc
prefer.empty.array.options.mode.always=始終
prefer.empty.array.options.mode.always.never=從不(首選預設大小的陣列)
prefer.empty.array.options.mode.by.level=根據語言級別
prefer.empty.array.options.title=首選空陣列\\:
prefix.operation.quickfix.family.name=取代為前綴運算符
press.escape.to.remove.highlighting.message=按 Esc 移除醒目提示
primitive.array.argument.to.var.arg.method.display.name=引起混淆的 vararg 方法基元陣列實參
primitive.array.argument.to.var.arg.method.problem.descriptor=引起混淆的 vararg 方法基元陣列實參 \\#loc
primitive.fields.ignore.option=忽略原始欄位
printstacktrace.call.display.name=呼叫 'printStackTrace()'
printstacktrace.call.problem.descriptor=對 <code>\\#ref()</code> 的呼叫可能應當取代為更可靠的日誌 \\#loc
private=private
private.field.not.accessible.problem.descriptor=''private'' 欄位 ''{0}'' 無法從此處存取
private.member.access.between.outer.and.inner.classes.display.name=合成存取器呼叫
private.member.access.between.outer.and.inner.classes.make.constructor.package.local.quickfix=將 ''{0}'' 建構函式設為 package-private
private.member.access.between.outer.and.inner.classes.make.local.quickfix=將 ''{0}'' 設為 package-private
private.member.access.between.outer.and.inner.classes.problem.descriptor=存取類別 ''{0}'' 的 ''private'' 成員需要合成存取器 \\#loc
problematic.varargs.method.display.name=非 vararg 方法覆寫 vararg 方法
problematic.varargs.method.override.problem.descriptor=非 vararg 方法 <code>\\#ref()</code> 覆寫 vararg 方法 \\#loc
progress.text.analyzing.package.0=正在分析軟體套件 {0}
properties.object.as.hashtable.display.name=將 'Properties' 物件用作 'Hashtable'
properties.object.as.hashtable.problem.descriptor=在屬性物件上呼叫 <code>Hashtable.\\#ref()</code> \\#loc
property.value.set.to.itself.display.name=屬性值設定為自身
protected.field.display.name=protected 欄位
protected.field.not.accessible.problem.descriptor=''protected'' 欄位 ''{0}'' 無法從此處存取
protected.field.problem.descriptor=protected 欄位 <code>\\#ref</code> \\#loc
protected.inner.class.display.name=protected 嵌套類別
protected.inner.class.ignore.enum.option=忽略 'protected' 內部枚舉
protected.inner.class.ignore.interface.option=忽略 'protected' 內部接口
protected.inner.class.problem.descriptor=protected 嵌套類別 <code>\\#ref</code> \\#loc
protected.member.in.final.class.display.name='protected' 成員位於 'final' 類別中
protected.member.in.final.class.problem.descriptor=類別成員在 'final' 類別中被宣告為 <code>\\#ref</code> \\#loc
protected.package.local.private=protected、package-private 和 private
public.constructor.display.name='public' 建構函式可被取代為工廠方法
public.constructor.in.non.public.class.display.name='public' 建構函式位於非 public 類別中
public.constructor.in.non.public.class.problem.descriptor=建構函式在非 public 類別 ''{0}'' 中被宣告為 <code>\\#ref</code> \\#loc
public.constructor.in.non.public.class.quickfix=將建構函式設為 private
public.constructor.problem.descriptor=public 建構函式 <code>\\#ref()</code> \\#loc
public.constructor.quickfix=將建構函式取代為工廠方法
public.default.constructor.problem.descriptor=類別 <code>\\#ref</code> 具有 'public' 預設建構函式
public.field.accessed.in.synchronized.context.display.name=在 'synchronized' 上下文中存取d了非 private 欄位
public.field.accessed.in.synchronized.context.problem.descriptor=在同步上下文中存取非 private 欄位 <code>\\#ref</code> \\#loc
public.field.display.name='public' 欄位
public.field.ignore.enum.type.fields.option=忽略枚舉類型的 'public final' 欄位
public.field.problem.descriptor='public' 欄位 <code>\\#ref</code> \\#loc
public.inner.class.display.name='public' 嵌套類別
public.inner.class.ignore.enum.option=忽略 'public' 內部枚舉
public.inner.class.ignore.interface.option=忽略 'public' 內部接口
public.inner.class.problem.descriptor='public' 嵌套類別 <code>\\#ref</code> \\#loc
public.method.not.in.interface.display.name='public' 方法在接口中未公開
public.method.not.in.interface.option=<html>如果包含類別未實作非庫接口，則忽略</html>
public.method.not.in.interface.problem.descriptor='public' 方法 <code>\\#ref()</code> 未通過接口公開 \\#loc
public.method.without.logging.display.name='public' 方法沒有日誌記錄
public.method.without.logging.problem.descriptor='public' 方法 <code>\\#ref()</code> 沒有日誌呼叫 \\#loc
public.static.array.field.display.name='public static' 陣列欄位
public.static.array.field.problem.descriptor='public static' 陣列欄位 <code>\\#ref</code>，影響安全性 \\#loc
public.static.collection.field.display.name='public static' 集合欄位
public.static.collection.field.problem.descriptor='public static' 集合欄位 <code>\\#ref</code>，影響安全性 \\#loc
qualify.call.fix.family.name=限定呼叫
query.label=查詢名稱開頭\\:
questionable.name.display.name=可疑名稱
questionable.name.list.label=報告的名稱\\:
questionable.name.problem.descriptor=可疑名稱 <code>\\#ref</code> \\#loc
random.double.for.random.integer.display.name=使用 'Random.nextDouble()' 獲取隨機整數
random.double.for.random.integer.problem.descriptor=使用 <code>Random.\\#ref</code> 建立隨機整數 \\#loc
raw.use.of.parameterized.type.display.name=參數化類別的原始使用
readobject.initialization.display.name=執行個體欄位可能無法被 'readObject()' 初始化
readobject.initialization.problem.descriptor=執行個體欄位 <code>\\#ref</code> 在 'readObject()' 呼叫期間可能無法初始化 \\#loc
readresolve.writereplace.protected.display.name='readResolve()' 或 'writeReplace()' 未被宣告為 'protected'
readresolve.writereplace.protected.problem.descriptor=<code>\\#ref()</code> 未被宣告為 'protected' \\#loc
readwriteobject.private.display.name='readObject()' 或 'writeObject()' 未被宣告為 'private'
readwriteobject.private.problem.descriptor=<code>\\#ref</code> 未被宣告為 'private' \\#loc
recordstore.opened.not.safely.closed.display.name=開啟了 'RecordStore'，但未安全關閉
redundant.as.list.for.iteration.fix.name=解包
redundant.as.list.for.iteration.problem=不必要的 'Arrays.asList()' 呼叫
redundant.call.problem.descriptor=冗餘呼叫 <code>\\#ref()</code> \\#loc
redundant.else.display.name=冗餘的 'else'
redundant.else.problem.descriptor=<code>\\#ref</code> 分支可以解包，因為 'if' 分支永遠不會正常完成 \\#loc
redundant.else.unwrap.quickfix=移除冗餘的 'else'
redundant.escape.in.regex.replacement.display.name=正則表達式取代字串中的冗餘轉義
redundant.escape.in.regex.replacement.problem.descriptor=''{0}'' 的冗餘轉義
redundant.escape.in.regex.replacement.quickfix=移除冗餘轉義
redundant.explicit.var.type.display.name=可以省略區域變數類型
redundant.field.initialization.display.name=冗餘欄位初始化
redundant.field.initialization.problem.descriptor=<code>\\#ref</code> 的欄位初始化是冗餘的 \\#loc
redundant.field.initialization.remove.quickfix=移除初始設定式
redundant.implements.display.name=冗餘接口宣告
redundant.implements.problem.descriptor=冗餘接口宣告 <code>\\#ref</code> \\#loc
redundant.implements.remove.quickfix=移除冗餘接口宣告
redundant.local.variable.annotation.option=忽略具有註解的變數
redundant.local.variable.display.name=冗餘區域變數
redundant.local.variable.ignore.option=忽略立即返回或拋出的變數
redundant.method.override.delegate.quickfix=將方法取代為到 super 的委託
redundant.method.override.delegates.to.super.problem.descriptor=方法 <code>\\#ref()</code> 僅委託給 super 方法 \\#loc
redundant.method.override.display.name=方法與其 super 方法相同
redundant.method.override.option.check.library.methods=檢查覆寫庫方法的方法
redundant.method.override.option.ignore.delegates=忽略到 super 方法的委託
redundant.method.override.problem.descriptor=方法 <code>\\#ref()</code> 與其 super 方法相同 \\#loc
redundant.method.override.quickfix=移除冗餘方法
redundant.string.format.call.display.name=冗餘呼叫 'String.format()'
redundant.string.format.call.quickfix=移除對 'String.format()' 的冗餘呼叫
redundant.string.formatted.call.quickfix=移除對 'String.formatted()' 的冗餘呼叫
referencing.subclass.0.from.superclass.1.initializer.might.lead.to.class.loading.deadlock=從超類別 {1} 初始設定式參照子類別 {0} 可能會導致類別載入死鎖
reflection.for.unavailable.annotation.display.name=對僅源註解的反射存取
reflection.for.unavailable.annotation.problem.descriptor=註解 '\\#ref' 不保留用於反射存取 \\#loc
refused.bequest.display.name=方法不呼叫 super 方法
refused.bequest.fix.family.name=將呼叫插入 super 方法
refused.bequest.ignore.default.super.methods.option=忽略 'default' super 方法
refused.bequest.ignore.empty.super.methods.option=忽略空 super 方法
refused.bequest.problem.descriptor=方法 <code>\\#ref()</code> 未呼叫 'super.\\#ref()' \\#loc
remove.annotation.parameter.0.fix.name=移除註解參數 ''{0}''
remove.call.fix.family.name=移除呼叫
remove.cloneable.quickfix=從 'implements' 子句中移除 'Cloneable'
remove.finally.block.quickfix=移除 'finally' 塊
remove.leading.zero.to.make.decimal.quickfix=移除前導零以變為十進制
remove.leading.zeroes.to.make.decimals.quickfix=移除前導零以變為十進制
remove.loop.fix.family.name=移除迴圈
remove.modifier.fix.family.name=移除修飾符
remove.modifier.quickfix=移除 ''{0}'' 修飾符
remove.redundant.polyadic.operand.fix.family.name=移除不必要的條件
remove.redundant.polyadic.operand.fix.name=移除不必要的 ''{0}'' 條件
remove.redundant.string.fix.text=使用 ''{0}()'' 並移除冗餘的 ''{1}()'' 呼叫
remove.redundant.substring.fix.family.name=移除冗餘的 'substring()' 呼叫
remove.try.finally.block.quickfix=移除 'try-finally' 塊
remove.unnecessary.0.call.quickfix=移除不必要的 ''{0}()'' 呼叫
rename.quickfix=重新命名
renameto.quickfix=重命名為 ''{0}''
replace.all.dot.display.name=可疑的正則表達式實參
replace.all.dot.problem.descriptor=''{0}()'' 呼叫中存在可疑的正則表達式 \\#ref \\#loc
replace.all.dot.quickfix=轉義正則表達式元字元
replace.all.file.separator.problem.descriptor=File.separator 用作正則表達式；無法在 Windows 上工作
replace.anonymous.with.lambda.body.fix.family.name=將呼叫取代為方法體
replace.case.default.null.with.null.default=將 'case default, null' 取代為 'case null, default'
replace.case.default.with.default=將 'case default' 取代為 'default'
replace.cast.fix.family.name=取代轉換類型
replace.casted.literal.with.just.literal.fix.family.name=取代為 {0} 字面量
replace.field.reference.fix.family.name=取代欄位參照
replace.field.reference.fix.text=將欄位參照取代為 ''{0}''
replace.inheritance.with.delegation.quickfix=將繼承取代為委託
replace.instanceof.fix.family.name=取代 instanceOf 類型
replace.method.call.fix.family.name=取代方法呼叫
replace.method.call.fix.text=將方法呼叫取代為 ''{0}''
replace.method.ref.with.qualifier.fix.family.name=取代為限定符
replace.method.ref.with.qualifier.problem.lambda=lambda 可被取代為呼叫限定符
replace.method.ref.with.qualifier.problem.method=方法參照可被取代為限定符
replace.with.cast.fix.family.name=取代為轉換
replace.with.catch.clause.for.runtime.exception.quickfix=針對 'RuntimeException' 取代為 'catch' 子句
replace.with.comparator.fix.family.name=使用 'Comparator' static 方法簡化比較器
replace.with.lambda.body.fix.family.name=將 lambda 上的方法呼叫取代為 lambda 體
replace.with.method.ref.fix.family.name=將 lambda 取代為方法參照
replace.with.method.ref.fix.name.may.change.semantics=將 lambda 取代為方法參照(可能更改語意)
replace.with.method.reference.fix.family.name=將方法參照上的方法呼叫取代為相應的方法呼叫
replace.with.var.fix.family.name=將顯式類型取代為 'var'
resource.opened.not.closed.problem.descriptor=''{0}'' 應在 ''try'' 塊之前開啟，並在相應的 ''finally'' 塊中關閉 \\#loc
result.of.method.call.ignored.class.column.title=類別名
result.of.method.call.ignored.display.name=方法呼叫的結果已忽略
result.of.method.call.ignored.non.library.option=報告所有忽略的非庫呼叫
result.of.method.call.ignored.problem.descriptor=<code>{0}.\\#ref()</code> 的結果已忽略 \\#loc
result.of.object.allocation.fix.name=忽略類型 ''{0}'' 的物件的分配
result.of.object.allocation.ignored.display.name=物件分配的結果已忽略
result.of.object.allocation.ignored.options.chooserTitle=選擇可以忽略物件分配的類別
result.of.object.allocation.ignored.problem.descriptor=<code>new \\#ref()</code> 的結果已忽略 \\#loc
result.of.object.allocation.ignored.problem.descriptor.methodRef=在 <code>\\#ref</code> 內部分配的物件已被捨棄 \\#loc
return.from.finally.block.display.name='return' 位於 'finally' 塊內
return.from.finally.block.problem.descriptor='return' 位於 'finally' 塊內 \\#loc
return.of.anonymous.class.problem.descriptor=返回匿名類別的執行個體 \\#loc
return.of.collection.field.fix.family.name=使返回集合 'unmodifiable'
return.of.field.with.mutable.type.problem.descriptor={0} 欄位 <code>\\#ref</code> 的返回值 \\#loc
return.of.inner.class.display.name=返回匿名、區域或內部類別的執行個體
return.of.inner.class.ignore.non.public.option=忽略非 public 方法的返回值
return.of.inner.class.problem.descriptor=返回非 static 內部類別 <code>{0}</code> 的執行個體 \\#loc
return.of.local.class.problem.descriptor=返回區域類別 <code>{0}</code> 的執行個體 \\#loc
return.of.null.arrays.option=報告返回陣列的方法
return.of.null.collections.option=報告返回集合物件的方法
return.of.null.display.name=返回 'null'
return.of.null.ignore.private.option=忽略 'private' 方法、匿名類別和 lambda
return.of.null.objects.option=報告返回物件的方法
return.of.null.problem.descriptor=返回 <code>\\#ref</code> \\#loc
return.point.limit.option=返回點限制(&R)\\:
return.this.display.name=返回 'this'
return.this.problem.descriptor=返回 <code>\\#ref</code> \\#loc
reuse.of.local.variable.display.name=區域變數的重用
reuse.of.local.variable.problem.descriptor=區域變數 <code>\\#ref</code> 的重用 \\#loc
reuse.of.local.variable.split.quickfix=拆分區域變數
runtime.exec.call.display.name=呼叫 'Runtime.exec()'
runtime.exec.call.problem.descriptor=對 <code>Runtime.\\#ref()</code> 的呼叫不可移植 \\#loc
runtime.exec.with.non.constant.string.display.name='Runtime.exec()' 呼叫具有非常數字串
runtime.exec.with.non.constant.string.problem.descriptor=<code>Runtime.\\#ref()</code> 呼叫具有非常數實參 \\#loc
safe.lock.display.name=已獲取但未安全解鎖的鎖
safe.lock.problem.descriptor=''{0}'' 應在 ''try'' 塊之前鎖定，並在相應的 ''finally'' 塊中解鎖 \\#loc
sequenced.collection.method.can.be.used.ignore.option=忽略用作實參的命名常數
serial.annotation.used.on.wrong.member.display.name=對錯誤的成員使用了 '@Serial' 註解
serial.annotation.used.on.wrong.member.problem.descriptor=註解的成員不是序列化機制的一部分
serializable.anonymous.class.stores.non.serializable.problem.descriptor=可序列化匿名類別隱式存儲類型為 ''{0}'' 的不可序列化物件
serializable.class.in.secure.context.display.name=安全上下文中的可序列化類別
serializable.class.in.secure.context.problem.descriptor=類別 <code>\\#ref</code> 可能被序列化，影響安全性 \\#loc
serializable.deserializable.class.in.secure.context.problem.descriptor=類別 <code>\\#ref</code> 可能被序列化和反序列化，影響安全性 \\#loc
serializable.has.serialization.methods.display.name=不帶 'readObject()' 和 'writeObject()' 的可序列化類別
serializable.has.serialization.methods.ignore.option=忽略未定義執行個體欄位的類別
serializable.has.serialization.methods.problem.descriptor=可序列化類別 <code>\\#ref</code> 未定義 'readObject()' 或 'writeObject()' \\#loc
serializable.has.serialization.methods.problem.descriptor1=可序列化類別 <code>\\#ref</code> 未定義 'writeObject()' \\#loc
serializable.has.serialization.methods.problem.descriptor2=可序列化類別 <code>\\#ref</code> 未定義 'readObject()' \\#loc
serializable.inner.class.has.serial.version.uid.field.display.name=沒有 'serialVersionUID' 的可序列化非 static 內部類別
serializable.inner.class.has.serial.version.uid.field.problem.descriptor=內部類別 <code>\\#ref</code> 未定義 'serialVersionUID' 欄位 \\#loc
serializable.inner.class.with.non.serializable.outer.class.display.name=可序列化非 'static' 內部類別具有不可序列化外部類
serializable.inner.class.with.non.serializable.outer.class.problem.descriptor=內部類別 <code>\\#ref</code> 可序列化，而其外部類別不可序列化 \\#loc
serializable.lambda.stores.non.serializable.problem.descriptor=可序列化 lambda 隱式存儲類型為 ''{0}'' 的不可序列化物件
serializable.local.class.stores.non.serializable.problem.descriptor=可序列化區域類別 ''{1}'' 隱式存儲類型為 ''{0}'' 的不可序列化物件
serializable.record.contains.ignored.field.problem.descriptor=在記錄序列化期間將忽略 <code>\\#ref</code>
serializable.record.contains.ignored.members.display.name='record' 包含被忽略的成員
serializable.record.contains.ignored.method.problem.descriptor=在記錄序列化期間將忽略 <code>\\#ref()</code>
serializable.stores.non.serializable.display.name='Serializable' 物件隱式存儲非 'Serializable' 物件
serializable.with.unconstructable.ancestor.display.name=具有不可建構上級的可序列化類別
serializable.with.unconstructable.ancestor.problem.descriptor=<code>\\#ref</code> 具有不帶無實參建構函式的不可序列化上級 ''{0}'' \\#loc
serialpersistentfields.with.wrong.signature.display.name='serialPersistentFields' 欄位未被宣告為 'private static final ObjectStreamField[]'
serialpersistentfields.with.wrong.signature.problem.descriptor=可序列化類別的 <code>\\#ref</code> 欄位未被宣告為 'private static final ObjectStreamField[]' \\#loc
serialversionuid.private.static.final.long.display.name='serialVersionUID' 欄位未被宣告為 'private static final long'
serialversionuid.private.static.final.long.problem.descriptor=可序列化類別的 <code>\\#ref</code> 欄位未被宣告為 'private static final long' \\#loc
serialversionuid.private.static.final.long.quickfix=將 serialVersionUID 設為 'private static final'
set.annotation.parameter.0.1.fix.name=將註解參數 {0} 設定為“{1}”
set.replaceable.by.enum.set.display.name='Set' 可被取代為 'EnumSet'
set.replaceable.by.enum.set.problem.descriptor=<code>\\#ref</code> 可被取代為 'EnumSet' \\#loc
shared.thread.local.random.display.name='ThreadLocalRandom' 執行個體可能是共享的
shared.thread.local.random.problem.descriptor='ThreadLocalRandom' 執行個體可能線上程之間共享
shift.operation.by.inappropriate.constant.display.name=按不當常數進行移位運算
shift.operation.by.inappropriate.constant.problem.descriptor.negative=對 <code>\\#ref</code> 進行移位運算時使用的常量值 {0} 為負 \\#loc
shift.operation.by.inappropriate.constant.problem.descriptor.out.of.bounds=按超出範圍的值 {0} 進行移位運算 <code>\\#ref</code> \\#loc
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=對 <code>\\#ref</code> 進行移位運算時使用的常量值 {0} 過大 \\#loc
shift.out.of.range.fix.family.name=修復移位值
signal.without.corresponding.await.display.name=沒有相應 'await()' 的 'signal()'
signal.without.corresponding.await.problem.descriptor=在沒有相應 <code>await()</code> 的情況下呼叫 <code>\\#ref()</code> \\#loc
simplifiable.annotation.braces.problem.descriptor=註解中 <code>{0}</code> 周圍不必要的圓括號 \\#loc
simplifiable.annotation.display.name=可簡化註解
simplifiable.annotation.problem.descriptor=註解中有不必要的 <code>\\#ref</code> \\#loc
simplifiable.annotation.quickfix=簡化註解
simplifiable.annotation.whitespace.problem.descriptor=註解中有不必要的空格 \\#loc
simplifiable.boolean.expression.display.name=可簡化的布爾表達式
simplifiable.conditional.expression.display.name=可簡化的條件表達式
simplifiable.conditional.expression.problem.descriptor=<code>{1}</code> 可以簡化為 ''{0}'' \\#loc
simplifiable.equals.expression.display.name='equals()' 呼叫之前的 'null' 檢查不必要
simplifiable.equals.expression.option.non.constant=報告具有非常數非 null 實參的等於
simplifiable.equals.expression.problem.descriptor=''{0}()'' 呼叫之前的 ''null'' 檢查不必要 \\#loc
simplifiable.equals.expression.quickfix=翻轉 ''.{0}()'' 並移除不必要的 ''null'' 檢查
simplifiable.junit.assertion.display.name=可簡化斷言
simplifiable.junit.assertion.problem.descriptor=<code>\\#ref()</code> 可以簡化為 ''{0}'' \\#loc
simplify.junit.assertion.simplify.quickfix=簡化斷言
single.character.startswith.display.name=單個字元 'startsWith()' 或 'endsWith()'
single.character.startswith.problem.descriptor=單個字元 <code>\\#ref()</code> 可被取代為 'charAt()' 表達式 \\#loc
single.character.startswith.quickfix=取代為 'charAt()' 表達式
single.class.import.display.name=單個類別匯入
single.class.import.problem.descriptor=單個類別匯入 <code>\\#ref</code> \\#loc
single.element.annotation.family.quickfix=將註解擴展為標準形式
single.element.annotation.name=非規范化註解
single.element.annotation.quickfix=新增 'value\\='
single.statement.in.block.descriptor=''{0}'' 包含單條語句
single.statement.in.block.family.quickfix=從語句中移除大括號
single.statement.in.block.name=程式碼塊包含單條語句
single.statement.in.block.quickfix=從 ''{0}'' 語句中移除大括號
singleton.display.name=單例
singleton.problem.descriptor=類別 <code>\\#ref</code> 為單例 \\#loc
size.replaceable.by.isempty.display.name='size() \\=\\= 0' 可被取代為 'isEmpty()'
size.replaceable.by.isempty.fix.ignore.calls=忽略類型 ''{1}'' 上的 ''.{0}()'' 呼叫
size.replaceable.by.isempty.negation.ignore.option=忽略將取代為 '\\!isEmpty()' 的表達式
sleep.while.holding.lock.display.name=同步時呼叫 'Thread.sleep()'
sleep.while.holding.lock.problem.descriptor=同步時呼叫 <code>Thread.\\#ref()</code> \\#loc
smth.unnecessary.remove.quickfix=移除不必要的 ''{0}''
socket.opened.not.closed.display.name=套接字已開啟，但未安全關閉
standard.variable.names.display.name=標準變數名稱
standard.variable.names.ignore.override.option=對與 super 方法參數相同的參數名稱忽略
standard.variable.names.problem.descriptor=變數命名 <code>\\#ref</code> 沒有類型 ''{0}'' \\#loc
standard.variable.names.problem.descriptor2=變數命名 <code>\\#ref</code> 沒有類型 ''{0}'' 或 ''{1}'' \\#loc
statement.problem.descriptor=<code>\\#ref</code> 語句 \\#loc
statement.with.empty.body.display.name=帶空體的語句
statement.with.empty.body.include.option=包含空程式碼塊語句正文
statement.with.empty.body.problem.descriptor=<code>\\#ref</code> 語句具有空體 \\#loc
static.collection.display.name=靜態集合
static.collection.ignore.option=忽略弱靜態集合或映射
static.collection.problem.descriptor=靜態集合 <code>\\#ref</code> \\#loc
static.field.via.subclass.display.name=static 欄位通過子類別參照
static.field.via.subclass.problem.descriptor=static 欄位 <code>\\#ref</code> 在類別 ''{0}'' 中宣告，但通過子類別 ''{1}'' 參照 \\#loc
static.field.via.subclass.rationalize.quickfix=使 static 欄位存取合理化
static.import.display.name=static import
static.import.fix.ignore.class=允許類別 ''{0}'' 的 static import
static.import.options.border.title=靜態可匯入類別\\:
static.import.options.chooserTitle=選擇靜態可匯入類別
static.import.problem.descriptor=static import <code>\\#ref</code>  \\#loc
static.import.replace.quickfix=取代為非 static import
static.inheritance.display.name=靜態繼承
static.inheritance.fix.family.name=將繼承取代為限定參照
static.inheritance.problem.descriptor=接口 <code>\\#ref</code> 僅針對其 static 常數實作 \\#loc
static.inheritance.replace.quickfix=將繼承取代為 {0} 中的限定參照
static.initializer.references.subclass.display.name=static 初始設定式參照子類別
static.method.naming.convention.element.description='static' 方法
static.method.only.used.in.one.anonymous.class.problem.descriptor=static {0, choice, 1\\#方法|2\\#欄位} <code>\\#ref{0, choice, 1\\#()|2\\#}</code> 僅在派生自 ''{1}'' 的匿名類別中使用 \\#loc
static.method.only.used.in.one.class.display.name=static 成員僅在其他一個類別中使用
static.method.only.used.in.one.class.ignore.anonymous.option=僅在匿名類別中使用時忽略
static.method.only.used.in.one.class.ignore.on.conflicts=當方法無法在不產生衝突的情況下移動時忽略
static.method.only.used.in.one.class.ignore.test.option=僅在測試類別中使用時忽略
static.method.only.used.in.one.class.ignore.utility.classes=忽略位於實用程序類別中的成員
static.method.only.used.in.one.class.problem.descriptor=static {0, choice, 1\\#方法|2\\#欄位} <code>\\#ref{0, choice, 1\\#()|2\\#}</code> 僅在 ''{1}'' 類別中使用 \\#loc
static.method.only.used.in.one.class.quickfix=將 {0} 移至使用類別
static.method.only.used.in.one.class.quickfix.preview=將 static 成員移至使用它的類別。
static.method.via.subclass.display.name=static 方法通過子類別參照
static.method.via.subclass.problem.descriptor=static 方法 <code>\\#ref()</code> 在類別 ''{0}'' 中宣告，但通過子類別 ''{1}'' 參照 \\#loc
static.method.via.subclass.rationalize.quickfix=使 static 方法呼叫合理化
static.non.final.field.display.name='static' 非 'final' 欄位
static.non.final.field.option=僅報告 'public' 欄位
static.non.final.field.problem.descriptor='static' 非 'final' 欄位 <code>\\#ref</code> \\#loc
static.variable.may.not.be.initialized.display.name=static 欄位可能無法初始化
static.variable.may.not.be.initialized.problem.descriptor=static 欄位 <code>\\#ref</code> 在類別初始化期間可能無法初始化 \\#loc
static.variable.naming.convention.element.description='static' 欄位
static.variable.of.concrete.class.problem.descriptor=具體類別 <code>\\#ref</code> 的 static 欄位 ''{0}'' \\#loc
static.variable.used.before.initialization.display.name=static 欄位在初始化前使用
static.variable.used.before.initialization.problem.descriptor=static 欄位 <code>\\#ref</code> 在初始化前使用 \\#loc
string.buffer.must.have.initial.capacity.display.name=沒有初始容量的 'StringBuilder'
string.buffer.must.have.initial.capacity.problem.descriptor=沒有初始容量的 <code>new \\#ref()</code> \\#loc
string.buffer.replaceable.by.string.builder.display.name='StringBuffer' 可能是 'StringBuilder'
string.buffer.replaceable.by.string.builder.problem.descriptor=<code>StringBuffer \\#ref</code> 可能被宣告為 'StringBuilder' \\#loc
string.buffer.replaceable.by.string.display.name='StringBuilder' 可被取代為 'String'
string.buffer.replaceable.by.string.problem.descriptor=<code>{0} \\#ref</code> 可被取代為 ''String'' \\#loc
string.comparison.display.name=使用 '\\=\\=' 而不是 'equals()' 進行字串比較
string.comparison.problem.descriptor=使用 <code>\\#ref</code> 而不是 'equals()' 來比較字串值 \\#loc
string.concatenation.argument.to.log.call.display.name=非常數字串串聯作為日誌呼叫的實參
string.concatenation.argument.to.log.call.problem.descriptor=非常數字串作為 <code>\\#ref()</code> 日誌記錄呼叫的實參 \\#loc
string.concatenation.argument.to.log.call.quickfix=將串聯取代為參數化的日誌訊息
string.concatenation.argument.to.log.message.format.call.quickfix=將 'Message.format()' 取代為參數化日誌訊息
string.concatenation.argument.to.log.string.format.call.quickfix=將 'String.format()' 取代為參數化日誌訊息
string.concatenation.display.name=字串串聯
string.concatenation.in.format.call.display.name=字串串聯作為 'format()' 呼叫的實參
string.concatenation.in.format.call.fix.family.name=將串聯取代為實參
string.concatenation.in.format.call.problem.descriptor=''{0}()'' 呼叫包含字串串聯實參
string.concatenation.in.format.call.quickfix=將串聯取代為單獨的實參
string.concatenation.in.loops.display.name=字串串聯在迴圈中
string.concatenation.in.loops.problem.descriptor=迴圈中的字串串聯 <code>\\#ref</code> \\#loc
string.concatenation.in.message.format.call.display.name=字串串聯作為 'MessageFormat.format()' 呼叫的實參
string.concatenation.in.message.format.call.problem.descriptor=字串串聯作為 'MessageFormat.format()' 呼叫的實參 \\#loc
string.concatenation.inside.string.buffer.append.display.name=字串串聯作為 'StringBuilder.append()' 呼叫的實參
string.concatenation.inside.string.buffer.append.problem.descriptor=字串串聯作為 <code>{0}.\\#ref()</code> 呼叫的實參 \\#loc
string.concatenation.inside.string.buffer.append.replace.quickfix=取代為鏈式 'append()' 呼叫
string.concatenation.introduce.fix=引入 StringBuilder
string.concatenation.introduce.fix.name=引入新的 {1} 以更新變數 ''{0}''
string.concatenation.introduce.fix.name.null.safe=引入新的 {1} 以更新變數 ''{0}'' (null 安全)
string.concatenation.missing.whitespace.display.name=字串串聯中可能缺少空格
string.concatenation.missing.whitespace.option=忽略具有變量字串的串聯
string.concatenation.missing.whitespace.problem.descriptor=字串串聯中可能缺少空格 \\#loc
string.concatenation.problem.descriptor=國際化上下文中的字串串聯 <code>\\#ref</code> \\#loc
string.concatenation.replace.fix=取代為 StringBuilder
string.concatenation.replace.fix.name=將變數 ''{0}'' 從字串轉換為 {1}
string.concatenation.replace.fix.name.null.safe=將變數 ''{0}'' 從字串轉換為 {1} (null 安全)
string.equals.char.sequence.display.name=使用 'CharSequence' 實參呼叫了 'String.equals()'
string.equals.char.sequence.problem.descriptor=使用 ''{0}'' 實參呼叫了 <code>String.equals()</code> \\#loc
string.equals.empty.string.display.name='String.equals()' 可被取代為 'String.isEmpty()'
string.equals.empty.string.fix.family.name=簡化空字串檢查
string.equals.empty.string.is.empty.problem.descriptor=<code>\\#ref("")</code> 可被取代為 'isEmpty()' \\#loc
string.equals.empty.string.option.do.not.add.null.check=當有必要進行 null 檢查時，不必報告
string.equals.empty.string.problem.descriptor=<code>\\#ref("")</code> 可被取代為 'length()\\=\\=0' \\#loc
string.format.choose.class=選擇格式化程序類別
string.format.class.label=附加格式化程序類別\\:
string.format.class.method.label=附加格式化程序方法\\:
string.indexof.replaceable.by.contains.display.name='String.indexOf()' 表達式可被取代為 'contains()'
string.replace.quickfix=移除空字串動作數
string.replaceable.by.string.buffer.display.name=非常數 'String' 可被取代為 'StringBuilder'
string.replaceable.by.string.buffer.in.loop.option=僅在迴圈中追加時發出警告
string.replaceable.by.string.buffer.problem.descriptor=非常數字串 <code>\\#ref</code> 可能應被宣告為 'StringBuilder' \\#loc
string.touppercase.tolowercase.without.locale.display.name=呼叫無區域設定的 'String.toUpperCase()' 或 'toLowerCase()'
string.touppercase.tolowercase.without.locale.problem.descriptor=在未使用國際化字串指定區域設定的情況下呼叫 <code>String.\\#ref()</code> \\#loc
stringbuffer.field.display.name='StringBuilder' 欄位
stringbuffer.field.problem.descriptor=''{0}'' 欄位 <code>\\#ref</code> \\#loc
subtraction.in.compareto.display.name='compareTo()' 中的減法
subtraction.in.compareto.problem.descriptor='compareTo()' 中的減法 <code>\\#ref</code> 可能導致溢出或精度損失 \\#loc
super.class.logger.option=在超類別有可存取的記錄器時忽略
suppress.for.tests.scope.quickfix=對 'Tests' 作用域禁止
suspicious.array.cast.display.name=可疑的陣列轉換
suspicious.array.cast.problem.descriptor=可疑轉換為 <code>\\#ref</code> \\#loc
suspicious.comparator.compare.descriptor.min.value=不建議從比較函式返回 Integer.MIN_VALUE
suspicious.comparator.compare.descriptor.non.negative=比較器從不返回負值
suspicious.comparator.compare.descriptor.non.positive=比較器從不返回正值
suspicious.comparator.compare.descriptor.non.reflexive=對於相等的元素，比較器不返回 0
suspicious.comparator.compare.descriptor.parameter.not.used=未使用 ''{0}()'' 參數 <code>\\#ref</code> \\#loc
suspicious.comparator.compare.display.name=可疑的 'Comparator.compare()' 實作
suspicious.getter.problem.descriptor=getter <code>\\#ref()</code> 返回欄位 ''{0}'' \\#loc
suspicious.getter.setter.display.name=可疑的 getter/setter
suspicious.indent.after.control.statement.display.name=沒有大括號的控制語句後存在可疑縮排
suspicious.indent.after.control.statement.problem.descriptor=''{0}'' 語句後存在可疑縮排 \\#loc
suspicious.integer.div.assignment.display.name=可疑的整數除法指派
suspicious.integer.div.assignment.problem.descriptor=除法結果被截斷為整數
suspicious.integer.div.assignment.quickfix=轉換為 double
suspicious.literal.underscore.display.name=數字字面量中的可疑下劃線
suspicious.literal.underscore.problem.descriptor=帶下劃線的數字字面量中的組沒有長度 3 \\#loc
suspicious.package.private.access.display.name=可疑的 package-private 存取權限
suspicious.setter.problem.descriptor=setter <code>\\#ref()</code> 對欄位 ''{0}'' 指派 \\#loc
suspicious.system.arraycopy.display.name=可疑的 'System.arraycopy()' 呼叫
suspicious.system.arraycopy.problem.descriptor.length.bigger.dest=長度始終大於 ''dest.length - destPos'' {0}
suspicious.system.arraycopy.problem.descriptor.length.bigger.src=長度始終大於 ''src.length - srcPos'' {0}
suspicious.system.arraycopy.problem.descriptor.ranges.intersect=複製到具有相交範圍的同一陣列
suspicious.system.arraycopy.problem.descriptor4=<code>\\#ref</code> 不是陣列類型 \\#loc
suspicious.system.arraycopy.problem.descriptor5=<code>\\#ref</code> 不是陣列類型 \\#loc
suspicious.system.arraycopy.problem.descriptor6=源參數類型 ''{0}'' 不可分配給類型為 ''{1}'' 的目標參數 <code>\\#ref</code> \\#loc
suspicious.to.array.call.display.name=可疑的 'Collection.toArray()' 呼叫
suspicious.to.array.call.fix.family.name=取代為正確陣列
suspicious.to.array.call.problem.descriptor=應為類型 ''{0}[]'' 的陣列，找到的是 ''{1}[]'' \\#loc
swap.equals.fix.family.name=翻轉方法呼叫
switch.expression.with.single.default.message='switch' 表達式只有 'default' case
switch.expression.with.too.few.branches.problem.descriptor=''switch'' 表達式的 case 標籤太少 ({0})，並且可能應當取代為 ''if'' 語句或條件運算符 \\#loc
switch.statement.density.display.name='switch' 語句的分支密度過低
switch.statement.density.min.option=分支的最小密度\\: %
switch.statement.density.problem.descriptor=<code>\\#ref</code> 分支密度過低({0}%) \\#loc
switch.statement.display.name='switch' 語句
switch.statement.with.confusing.declaration.display.name=在不同 'switch' 分支中使用並宣告的區域變數
switch.statement.with.confusing.declaration.problem.descriptor=區域變數 <code>\\#ref</code> 在一個 'switch' 分支中宣告，並在另一個分支中使用 \\#loc
switch.statement.with.single.default.message='switch' 語句只有 'default' case
switch.statement.with.too.few.branches.display.name=最小 'switch' 分支
switch.statement.with.too.few.branches.ignore.pattern.option=不報告模式 switch 語句
switch.statement.with.too.few.branches.min.option=最小分支數\\:
switch.statement.with.too.few.branches.problem.descriptor=''switch'' 語句的 case 標籤太少({0})，並且可能應當取代為 ''if'' 語句 \\#loc
switch.statement.with.too.many.branches.display.name=最大 'switch' 分支
switch.statement.without.default.ignore.option=忽略詳盡的 switch 語句
switch.statements.without.default.display.name=不帶 'default' 分支的 'switch' 語句
switch.statements.without.default.problem.descriptor=沒有 'default' 分支的 <code>\\#ref</code> 語句 \\#loc
synchronization.on.get.class.display.name=在 'getClass()' 上同步
synchronization.on.get.class.problem.descriptor=在 <code>\\#ref()</code> 上同步 \\#loc
synchronization.on.local.variable.or.method.parameter.display.name=在區域變數或方法參數上同步
synchronization.on.local.variable.problem.descriptor=在區域變數 <code>\\#ref</code> 上同步 \\#loc
synchronization.on.method.parameter.problem.descriptor=在方法參數 <code>\\#ref</code> 上同步 \\#loc
synchronization.on.static.field.display.name=在 'static' 欄位上同步
synchronization.on.static.field.problem.descriptor=在 'static' 欄位 <code>\\#ref</code> 上同步 \\#loc
synchronize.on.class.problem.descriptor=對類別的鎖定動作可能會產生不可預見的副作用 \\#loc
synchronize.on.lock.display.name=在 'Lock' 物件上同步
synchronize.on.lock.problem.descriptor=在 ''{0}'' 物件上同步不太可能是故意的 \\#loc
synchronize.on.non.final.field.display.name=在非 final 欄位上同步
synchronize.on.non.final.field.problem.descriptor=在非 final 欄位 <code>\\#ref</code> 上同步 \\#loc
synchronize.on.this.display.name=在 'this' 上同步
synchronize.on.this.problem.descriptor=對 'this' 的鎖定動作可能會產生不可預見的副作用 \\#loc
synchronized.method.display.name='synchronized' 方法
synchronized.method.ignore.synchronized.super.option=忽略覆寫 synchronized 方法的方法
synchronized.method.include.option=包含本地方法
synchronized.method.move.quickfix=將同步移至方法中
synchronized.method.problem.descriptor=方法 ''{0}()'' 被宣告為 <code>\\#ref</code> \\#loc
synchronized.on.direct.literal.object.problem.descriptor=在 {0} 字面量 <code>\\#ref</code> 上同步 \\#loc
synchronized.on.literal.object.name=在使用字面量初始化的物件上同步
synchronized.on.literal.object.problem.descriptor=在使用字面量初始化的 {0} <code>\\#ref</code> 上同步 \\#loc
synchronized.on.literal.object.warn.on.all.option=警告所有可能的字面量
synchronized.on.possibly.literal.object.problem.descriptor=在 {0} <code>\\#ref</code> 上同步 \\#loc
system.exit.call.display.name=呼叫 'System.exit()' 或相關方法
system.exit.call.ignore.option=在 main 方法中忽略
system.exit.call.problem.descriptor=對 <code>{0}.\\#ref()</code> 的呼叫不可移植 \\#loc
system.getenv.call.display.name=呼叫 'System.getenv()'
system.getenv.call.problem.descriptor=對 <code>System.\\#ref()</code> 的呼叫不可移植 \\#loc
system.properties.display.name=系統屬性的存取
system.properties.problem.descriptor=對 <code>Integer.\\#ref()</code> 的呼叫可能造成安全問題 \\#loc
system.properties.problem.descriptor1=對 <code>Boolean.\\#ref()</code> 的呼叫可能造成安全問題 \\#loc
system.run.finalizers.on.exit.display.name=呼叫 'System.runFinalizersOnExit()'
system.run.finalizers.on.exit.problem.descriptor=呼叫 <code>System.\\#ref()</code> \\#loc
system.set.problem.descriptor=對 <code>System.\\#ref()</code> 的呼叫可能造成安全問題 \\#loc
system.set.security.manager.display.name=呼叫 'System.setSecurityManager()'
system.set.security.manager.problem.descriptor=對 <code>System.\\#ref()</code> 的呼叫可能造成安全問題 \\#loc
tail.recursion.display.name=尾遞迴
tail.recursion.problem.descriptor=尾部遞迴呼叫 <code>\\#ref()</code> \\#loc
tail.recursion.replace.quickfix=用迭代替換尾部遞迴
text.label.in.switch.statement.display.name='switch' 語句中的文本標籤
text.label.in.switch.statement.problem.descriptor='switch' {0, choice, 1\\#語句|2\\#表達式}中存在文本標籤 <code>\\#ref\\:</code> \\#loc
the.whole.project=整個專案
this.class=此類別
this.reference.escaped.in.construction.display.name=物件建構中轉義的 'this' 參照
this.reference.escaped.in.construction.problem.descriptor=物件建構期間轉義 <code>\\#ref</code> \\#loc
thread.death.rethrown.display.name='ThreadDeath' 未重新拋出
thread.death.rethrown.problem.descriptor=ThreadDeath <code>\\#ref</code> 未重新拋出 \\#loc
thread.local.not.static.final.display.name='ThreadLocal' 欄位未被宣告為 'static final'
thread.local.not.static.final.problem.descriptor=ThreadLocal <code>\\#ref</code> 未被宣告為 'static final' \\#loc
thread.local.set.with.null.display.name=以 null 作為實參的 'ThreadLocal.set()'
thread.local.set.with.null.problem.descriptor=使用 null 作為實參的 'ThreadLocal.set()' 可能會導致記憶體泄漏
thread.local.set.with.null.quickfix=取代為 'ThreadLocal.remove()' 呼叫
thread.priority.display.name=呼叫 'Thread.setPriority()'
thread.priority.problem.descriptor=呼叫 <code>Thread.\\#ref()</code> \\#loc
thread.run.problem.descriptor=對 <code>\\#ref()</code> 的呼叫可能應當取代為 'start()' \\#loc
thread.start.in.construction.display.name=物件建構期間呼叫 'Thread.start()'
thread.start.in.construction.problem.descriptor=物件建構期間呼叫 <code>\\#ref()</code> \\#loc
thread.stop.suspend.resume.display.name=呼叫 'Thread.stop()'、'suspend()' 或 'resume()'
thread.stop.suspend.resume.problem.descriptor=呼叫 <code>Thread.\\#ref()</code> \\#loc
thread.with.default.run.method.display.name=使用預設的 'run()' 方法實例化 'Thread'
thread.with.default.run.method.problem.descriptor=使用預設的 'run()' 方法實例化 <code>\\#ref</code> \\#loc
thread.yield.display.name=呼叫 'Thread.yield()'
thread.yield.problem.descriptor=呼叫 <code>Thread.\\#ref()</code> \\#loc
three.negations.per.method.display.name=具有三個以上否定的方法
three.negations.per.method.ignore.assert.option=忽略 'assert' 語句中的否定
three.negations.per.method.ignore.option=忽略 'equals()' 方法中的否定
three.negations.per.method.problem.descriptor=<code>\\#ref</code> 包含 {0} 個否定 \\#loc
throw,from.finally.block.everywhere.option=在可能拋出已宣告異常的每一處發出警告
throw.caught.locally.display.name=通過包含 'try' 語句捕獲 'throw'
throw.caught.locally.ignore.option=忽略重新拋出的異常
throw.caught.locally.problem.descriptor=通過包含 'try' 語句捕獲 <code>\\#ref</code> \\#loc
throw.from.finally.block.display.name='throw' 位於 'finally' 塊內
throw.from.finally.block.problem.descriptor=<code>\\#ref</code> 位於 'finally' 塊內 \\#loc
throwable.instance.never.thrown.checked.exception.problem.descriptor=已檢查的異常執行個體 <code>\\#ref</code> 未拋出 \\#loc
throwable.instance.never.thrown.error.problem.descriptor=錯誤執行個體 <code>\\#ref</code> 未拋出 \\#loc
throwable.instance.never.thrown.problem.descriptor=Throwable 執行個體 <code>\\#ref</code> 未拋出 \\#loc
throwable.instance.never.thrown.runtime.exception.problem.descriptor=執行時異常執行個體 <code>new \\#ref()</code> 未拋出 \\#loc
throwable.not.thrown.display.name='Throwable' 未拋出
throwable.printed.to.system.out.display.name='Throwable' 列印到 'System.out'
throwable.printed.to.system.out.problem.descriptor=''Throwable'' 實參 <code>\\#ref</code> 到 ''System.{0}.{1}()'' 呼叫
throwable.printed.to.system.out.problem.fix.level.option=修正的日誌方法\\:
throwable.result.of.method.call.ignored.problem.descriptor=<code>\\#ref()</code> 的結果未拋出 \\#loc
throwable.supplier.only.throw.exception.name=Throwable 供應商從不返回值
throwable.supplier.only.throw.exception.problem.descriptor=Throwable 供應商不返回任何異常
throwable.supplier.only.throw.exception.quickfix=將 lambda 中的 'throw' 取代為 'return'
thrown.exceptions.per.method.display.name=方法宣告的異常過多
thrown.exceptions.per.method.limit.option=異常拋出限制\\:
thrown.exceptions.per.method.problem.descriptor=<code>\\#ref</code> 宣告的異常過多 (異常數量 \\= {0}) \\#loc
throws.runtime.exception.display.name=在 'throws' 子句中宣告的未檢查的異常
throws.runtime.exception.fix.family.name=從 'throws' 子句中移除
throws.runtime.exception.move.quickfix=將 ''{0}'' 移至 Javadoc ''@throws'' 標記中
throws.runtime.exception.problem.descriptor=在 'throws' 子句中宣告的未檢查的異常 <code>\\#ref</code> \\#loc
throws.runtime.exception.quickfix=從 ''throws'' 子句中移除 ''{0}''
time.tostring.call.display.name=呼叫 'Time.toString()'
time.tostring.call.problem.descriptor=國際化上下文中的 <code>Time.\\#ref()</code> \\#loc
to.array.call.style.display.name='Collection.toArray()' 呼叫樣式
to.array.call.style.problem.descriptor.presized=<code>\\#ref()</code> 呼叫具有預設大小的陣列實參 ''{0}'' \\#loc
to.array.call.style.problem.descriptor.zero=<code>\\#ref()</code> 呼叫具有空陣列實參 ''{0}'' \\#loc
to.array.call.style.quickfix.family.name=修復傳遞到 'toArray()' 呼叫的陣列的大小
to.array.call.style.quickfix.make.presized=將實參取代為預設大小的陣列
to.array.call.style.quickfix.make.zero=將實參取代為空陣列
too.broad.catch.display.name=過寬的 'catch' 塊
too.broad.catch.option=僅對 RuntimeException、異常、錯誤或 Throwable 發出警告(&O)
too.broad.catch.problem.descriptor=<code>\\#ref</code> 的 ''catch'' 過寬，遮罩異常 ''{0}'' \\#loc
too.broad.catch.problem.descriptor1=<code>\\#ref</code> 的 ''catch'' 過寬，遮罩異常 ''{0}'' 和 ''{1}'' \\#loc
too.broad.catch.quickfix=向 ''{0}'' 新增 ''catch'' 子句
too.broad.scope.allow.option=<html>報告使用新表達式作為初始設定式的變數<br>(可能不安全)</html>
too.broad.scope.display.name=變數作用域過寬
too.broad.scope.inspection.fix.family.name=限縮作用域
too.broad.scope.narrow.quickfix=將 ''{0}'' 的宣告移近用法
too.broad.scope.only.blocks.option=僅報告可移入內部塊的變數
too.broad.scope.problem.descriptor=變數 <code>\\#ref</code> 的作用域過寬 \\#loc
too.many.constructors.count.limit.option=建構函式計數限制\\:
too.many.constructors.display.name=建構函式過多的類別
too.many.constructors.ignore.deprecated.option=忽略棄用的建構函式
too.many.constructors.problem.descriptor=<code>\\#ref</code> 的建構函式過多 (建構函式計數 \\= {0}) \\#loc
too.many.fields.count.limit.option=欄位計數限制\\:
too.many.fields.display.name=欄位過多的類別
too.many.fields.problem.descriptor=<code>\\#ref</code> 的欄位過多 (欄位計數 \\= {0}) \\#loc
too.many.methods.display.name=方法過多的類別
too.many.methods.problem.descriptor=<code>\\#ref</code> 的方法過多 (方法計數 \\= {0}) \\#loc
trace.level.option=追蹤級別
transient.field.in.non.serializable.class.display.name=不可序列化類別中存在 transient 欄位
transient.field.in.non.serializable.class.problem.descriptor=欄位 ''{0}'' 已在不可序列化類別中標記為 <code>\\#ref</code> \\#loc
transient.field.not.initialized.display.name=transient 欄位在反序列化時未初始化
transient.field.not.initialized.problem.descriptor=transient 欄位 <code>\\#ref</code> 在反序列化時未初始化 \\#loc
trivial.if.display.name=冗餘的 'if' 語句
trivial.if.fix.family.name=簡化 'if else'
trivial.if.option.ignore.assert.statements=忽略帶有簡單 'assert' 的 'if' 語句
trivial.if.option.ignore.chained=忽略鏈式 'if' 語句
trivial.if.problem.descriptor=<code>\\#ref</code> 語句可以簡化 \\#loc
trivial.string.concatenation.display.name=與空字串串聯
trivial.string.concatenation.option.only.necessary=僅報告無需其他更改即可移除空字串的情況
trivial.string.concatenation.problem.descriptor=串聯中存在空字串
try.finally.can.be.try.with.resources.display.name='try finally' 可被取代為 'try' with resources
try.finally.can.be.try.with.resources.problem.descriptor=<code>\\#ref</code> 可以使用自動資源管理 \\#loc
try.finally.can.be.try.with.resources.quickfix=取代為 'try-with-resources'
try.statement.with.multiple.resources.name=可以拆分具有多個資源的 'try' 語句
try.statement.with.multiple.resources.quickfix=拆分具有多個資源的 'try' 語句
try.with.identical.catches.checkbox.different.comments=不報告帶有不同註釋的 catch 塊
try.with.identical.catches.display.name='try' 語句中的相同 'catch' 分支
try.with.identical.catches.problem.descriptor=''catch'' 分支與 ''{0}'' 分支相同 \\#loc
try.with.identical.catches.quickfix=摺疊 'catch' 塊
type.parameter.extends.enum.type.parameter.problem.descriptor=類型參數 <code>\\#ref</code> 隱式擴展 final 枚舉 ''{0}'' \\#loc
type.parameter.extends.enum.wildcard.problem.descriptor=萬用字元類型實參 <code>\\#ref</code> 隱式擴展了 final 枚舉 ''{0}'' \\#loc
type.parameter.extends.final.class.display.name=類型參數擴展 'final' 類別
type.parameter.extends.final.class.quickfix=將類型參數取代為實際類別
type.parameter.extends.final.class.type.parameter.problem.descriptor=類型參數 <code>\\#ref</code> 擴展 ''final'' 類別{0} \\#loc
type.parameter.extends.final.class.wildcard.problem.descriptor=萬用字元類型實參 <code>\\#ref</code> 擴展了 ''final'' 類別 ''{0}'' \\#loc
type.parameter.extends.object.display.name=類型參數顯式擴展 'Object'
type.parameter.extends.object.ignore.annotated=註解 java.lang.Object 時忽略
type.parameter.extends.object.problem.descriptor1=類型參數 <code>\\#ref</code> 顯式擴展 'java.lang.Object' \\#loc
type.parameter.extends.object.problem.descriptor2=萬用字元類型實參 <code>\\#ref</code> 顯式擴展 'java.lang.Object' \\#loc
type.parameter.hides.type.parameter.problem.descriptor=類型參數 <code>\\#ref</code> 隱藏類型參數 ''{0}'' \\#loc
type.parameter.hides.visible.type.display.name=類型參數隱藏可見類型
type.parameter.hides.visible.type.problem.descriptor=類型參數 <code>\\#ref</code> 隱藏可見類型 ''{0}'' \\#loc
type.parameter.naming.convention.element.description=類型參數
unary.plus.display.name=一元正號
unary.plus.problem.descriptor=一元 <code>\\#ref</code> 運算符 \\#loc
unary.plus.quickfix=移除一元 '+'
unchecked.exception.class.display.name=未檢查的 'Exception' 類別
unchecked.exception.class.problem.descriptor=未檢查的異常類別 <code>\\#ref</code> \\#loc
unclear.binary.expression.display.name=具有不同優先級的多個運算符
unclear.binary.expression.problem.descriptor=表達式可以使用澄清括號 \\#loc
unclear.binary.expression.quickfix=新增澄清括號
unconditional.wait.display.name=無條件的 'wait()' 呼叫
unconditional.wait.problem.descriptor=無條件呼叫 <code>\\#ref()</code> \\#loc
unnecessarily.qualified.inner.class.access.display.name=不必要的限定內部類別存取
unnecessarily.qualified.inner.class.access.option=忽略需要匯入的參照
unnecessarily.qualified.inner.class.access.problem.descriptor=使用 <code>\\#ref</code> 限定 ''{0}'' 不必要 \\#loc
unnecessarily.qualified.inner.class.access.quickfix=移除限定符
unnecessarily.qualified.static.usage.display.name=不必要的限定靜態存取
unnecessarily.qualified.static.usage.ignore.field.option=忽略不必要的限定欄位存取
unnecessarily.qualified.static.usage.ignore.method.option=忽略不必要的限定方法呼叫
unnecessarily.qualified.static.usage.problem.descriptor=對 static 方法 <code>{0}()</code> 不必要的限定呼叫 \\#loc
unnecessarily.qualified.static.usage.problem.descriptor1=對 static 欄位 <code>{0}</code> 不必要的限定存取 \\#loc
unnecessarily.qualified.statically.imported.element.display.name=不必要的限定靜態匯入元素
unnecessarily.qualified.statically.imported.element.problem.descriptor=靜態匯入元素 ''{0}'' 使用 <code>\\#ref</code> 不必要限定 \\#loc
unnecessarily.qualified.statically.imported.element.quickfix=移除不必要的限定符
unnecessary.block.statement.problem.descriptor=此語句周圍的大括號不必要 \\#loc
unnecessary.boxing.display.name=不必要的裝箱
unnecessary.boxing.inside.value.of.problem.descriptor=冗餘裝箱，可以改用 <code>{0}.{1}()</code> 呼叫 \\#loc
unnecessary.boxing.problem.descriptor=不必要的裝箱 \\#loc
unnecessary.boxing.remove.quickfix=移除裝箱
unnecessary.boxing.superfluous.option=僅報告真正多餘的裝箱表達式
unnecessary.break.display.name=不必要的 'break' 語句
unnecessary.break.problem.descriptor=<code>\\#ref</code> 語句不必要 \\#loc
unnecessary.code.block.display.name=不必要的程式碼塊
unnecessary.code.block.unwrap.quickfix=解包塊
unnecessary.constant.array.creation.expression.display.name=常數陣列建立中的冗餘 'new' 表達式
unnecessary.constant.array.creation.expression.family.quickfix=從新陣列表達式中移除類型規範
unnecessary.constant.array.creation.expression.problem.descriptor=可從新陣列表達式中移除 <code>\\#ref</code> \\#loc
unnecessary.constructor.annotation.option=忽略有註解的建構函式
unnecessary.constructor.display.name=冗餘無實參建構函式
unnecessary.constructor.problem.descriptor=無實參建構函式 <code>\\#ref()</code> 是冗餘的 \\#loc
unnecessary.constructor.remove.quickfix=移除冗餘建構函式
unnecessary.continue.display.name=不必要的 'continue' 語句
unnecessary.continue.problem.descriptor=<code>\\#ref</code> 不必要，因為是迴圈中的最後一條語句 \\#loc
unnecessary.conversion.to.string.display.name=到 'String' 的不必要轉換
unnecessary.default.display.name=枚舉 'switch' 語句的 'default' 不必要
unnecessary.default.expressions.option=僅報告 switch 表達式
unnecessary.default.problem.descriptor=<code>\\#ref</code> 分支不必要 \\#loc
unnecessary.default.quickfix=移除 'default' 分支
unnecessary.enum.constructor.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 對於枚舉建構函式是冗餘的 \\#loc
unnecessary.explicit.numeric.cast.display.name=不必要的顯式數字轉換
unnecessary.explicit.numeric.cast.problem.descriptor=''{0}'' 不必要轉換為 <code>\\#ref</code> \\#loc
unnecessary.explicit.numeric.cast.quickfix=移除轉換
unnecessary.final.on.local.variable.or.parameter.display.name=區域變數或參數上存在不必要的 'final'
unnecessary.final.on.local.variable.problem.descriptor=變數 ''{0}'' 上存在不必要的 <code>\\#ref</code> \\#loc
unnecessary.final.on.parameter.only.interface.option=僅對 abstract 或接口方法發出警告
unnecessary.final.on.parameter.problem.descriptor=參數 ''{0}'' 上存在不必要的 <code>\\#ref</code> \\#loc
unnecessary.final.report.local.variables.option=報告區域變數
unnecessary.final.report.parameters.option=報告參數
unnecessary.final.report.pattern.variables.option=報告模式變數
unnecessary.fully.qualified.name.display.name=不必要的完全限定名稱
unnecessary.fully.qualified.name.fix.family.name=取代完全限定名稱
unnecessary.fully.qualified.name.problem.descriptor1=限定符 <code>\\#ref</code> 不必要，可被取代為匯入 \\#loc
unnecessary.fully.qualified.name.problem.descriptor2=限定符 <code>\\#ref</code> 不必要，可以移除 \\#loc
unnecessary.fully.qualified.name.remove.quickfix=移除不必要的限定
unnecessary.fully.qualified.name.replace.quickfix=將限定名稱取代為匯入
unnecessary.inherit.doc.class.invalid.problem.descriptor=<code>\\#ref</code> 在類別上無效 \\#loc
unnecessary.inherit.doc.constructor.invalid.problem.descriptor=<code>\\#ref</code> 在建構函式上無效 \\#loc
unnecessary.inherit.doc.constructor.no.super.problem.descriptor=找不到繼承 Javadoc 的 super 方法 \\#loc
unnecessary.inherit.doc.display.name=不必要的 '{@inheritDoc}' Javadoc 註釋
unnecessary.inherit.doc.field.invalid.problem.descriptor=<code>\\#ref</code> 在欄位上無效 \\#loc
unnecessary.inherit.doc.module.invalid.problem.descriptor=<code>\\#ref</code> 在模組宣告上無效 \\#loc
unnecessary.inherit.doc.problem.descriptor=僅包含 <code>\\#ref</code> 的 Javadoc 註釋不必要 \\#loc
unnecessary.inherit.doc.quickfix=移除不必要的 {@inheritDoc}
unnecessary.initcause.display.name=對 'Throwable.initCause()' 的呼叫不必要
unnecessary.initcause.problem.descriptor=不必要的 <code>Throwable.\\#ref()</code> 呼叫
unnecessary.initcause.quickfix=移除 'Throwable.initCause()' 呼叫
unnecessary.inner.enum.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 對於內部枚舉是冗餘的 \\#loc
unnecessary.inner.interface.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 對於內部接口是冗餘的 \\#loc
unnecessary.inner.record.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 對於內部記錄是冗餘的
unnecessary.interface.field.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 對於接口欄位是冗餘的 \\#loc
unnecessary.interface.inner.class.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 對於接口的內部類別是冗餘的 \\#loc
unnecessary.interface.member.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 對於接口成員是冗餘的 \\#loc
unnecessary.interface.method.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 對於接口方法是冗餘的 \\#loc
unnecessary.interface.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 對於接口是冗餘的 \\#loc
unnecessary.java.doc.link.fix.family.name=移除冗餘標記
unnecessary.javadoc.link.display.name=不必要的 Javadoc 連結
unnecessary.javadoc.link.option=忽略 super 方法的內聯連結
unnecessary.javadoc.link.quickfix=移除不必要的 ''{0}''
unnecessary.javadoc.link.super.method.problem.descriptor=指向 super 方法的 <code>\\#ref</code> 不必要 \\#loc
unnecessary.javadoc.link.this.class.problem.descriptor=指向包含類別的 <code>\\#ref</code> 不必要 \\#loc
unnecessary.javadoc.link.this.method.problem.descriptor=指向此方法的 <code>\\#ref</code> 不必要 \\#loc
unnecessary.label.on.break.statement.display.name='break' 語句上的標籤不必要
unnecessary.label.on.break.statement.problem.descriptor=Break 語句上存在不必要的標籤 <code>\\#ref</code> \\#loc
unnecessary.label.on.continue.statement.display.name='continue' 語句上的不必要標籤
unnecessary.label.on.continue.statement.problem.descriptor=Continue 語句上存在不必要的標籤 <code>\\#ref</code> \\#loc
unnecessary.label.remove.quickfix=移除標籤
unnecessary.local.variable.problem.descriptor=區域變數 <code>\\#ref</code> 是冗餘的 \\#loc
unnecessary.main.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 對於 Java {0} 的 ''main'' 方法是冗餘的 \\#loc
unnecessary.modifier.display.name=不必要的修飾符
unnecessary.parentheses.conditional.option=忽略條件表達式條件周圍的圓括號
unnecessary.parentheses.display.name=不必要的圓括號
unnecessary.parentheses.option=忽略澄清圓括號
unnecessary.parentheses.problem.descriptor=<code>\\#ref</code> 周圍的圓括號不必要 \\#loc
unnecessary.parentheses.remove.quickfix=移除不必要的圓括號
unnecessary.qualifier.for.super.problem.descriptor='super' 上的限定符 <code>\\#ref</code> 在此上下文中不必要 \\#loc
unnecessary.qualifier.for.this.display.name='this' 或 'super' 的限定符不必要
unnecessary.qualifier.for.this.problem.descriptor='this' 上的限定符 <code>\\#ref</code> 在此上下文中不必要 \\#loc
unnecessary.qualifier.for.this.remove.quickfix=移除不必要的限定符
unnecessary.record.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 對於記錄是冗餘的
unnecessary.return.constructor.problem.descriptor=<code>\\#ref</code> 不必要，因為是建構函式中的最後一條語句 \\#loc
unnecessary.return.display.name=不必要的 'return' 語句
unnecessary.return.option=在具有 'else' 分支的 'if' 語句的 then 分支中忽略
unnecessary.return.problem.descriptor=<code>\\#ref</code> 不必要，因為是 'void' 方法中的最後一條語句 \\#loc
unnecessary.semicolon.display.name=不必要的分號
unnecessary.semicolon.ignore.after.enum.constants.option=忽略枚舉常數後的不必要分號
unnecessary.semicolon.problem.descriptor=不必要的分號 <code>\\#ref</code> \\#loc
unnecessary.semicolon.remove.quickfix=移除不必要的分號
unnecessary.strictfp.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 在 Java 17 和更高版本上是冗餘的
unnecessary.string.escape.display.name=不必要的轉義字元
unnecessary.string.escape.problem.descriptor=<code>{0}</code> 進行了不必要的轉義
unnecessary.string.escape.quickfix=移除不必要的轉義
unnecessary.super.constructor.display.name=對 'super()' 的呼叫不必要
unnecessary.super.constructor.problem.descriptor=<code>\\#ref</code> 不必要 \\#loc
unnecessary.super.constructor.remove.quickfix=移除不必要的 'super()'
unnecessary.super.qualifier.display.name=不必要的 'super' 限定符
unnecessary.super.qualifier.problem.descriptor=限定符 <code>\\#ref</code> 在此上下文中不必要 \\#loc
unnecessary.super.qualifier.quickfix=移除不必要的 'super' 限定符
unnecessary.temporary.object.fix.family.name=取代串聯
unnecessary.temporary.on.conversion.from.string.display.name=從 'String' 轉換時有不必要的臨時物件
unnecessary.temporary.on.conversion.to.string.display.name=轉換為 'String' 時有不必要的臨時物件
unnecessary.this.display.name=不必要的 'this' 限定符
unnecessary.this.ignore.assignments.option=忽略欄位指派
unnecessary.this.problem.descriptor=<code>\\#ref</code> 在此上下文中不必要 \\#loc
unnecessary.this.remove.quickfix=移除不必要的 'this' 限定符
unnecessary.tostring.call.display.name=對 'toString()' 的呼叫不必要
unnecessary.tostring.call.option.report.with.empty.string=報告可被取代為帶空字串的串聯的呼叫
unnecessary.tostring.call.problem.descriptor=不必要的 <code>\\#ref()</code> 呼叫 \\#loc
unnecessary.tostring.call.problem.empty.string.descriptor=可以取代為帶空字串的串聯
unnecessary.transient.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 對於 'static' 欄位是冗餘的
unnecessary.unary.minus.display.name=不必要的一元負號
unnecessary.unary.minus.problem.descriptor=不必要的一元 <code>\\#ref</code> 運算符 \\#loc
unnecessary.unary.minus.quickfix=移除一元負號並反轉父運算符號
unnecessary.unary.minus.remove.quickfix=移除雙一元減號
unnecessary.unboxing.display.name=不必要的拆箱
unnecessary.unboxing.problem.descriptor=不必要的拆箱 \\#loc
unnecessary.unboxing.remove.quickfix=移除拆箱
unnecessary.unboxing.superfluous.option=僅報告真正多餘的拆箱表達式
unnecessary.unicode.escape.display.name=不必要的 Unicode 轉義序列
unnecessary.unicode.escape.fix.family.name=取代為字元
unnecessary.unicode.escape.fix.text=取代為{0, choice, 1\\#新行|2\\#制表符|3\\#空格}字元
unnecessary.unicode.escape.problem.descriptor=Unicode 轉義序列 <code>\\#ref</code> 可被取代為 ''{0}'' \\#loc
unnecessary.unicode.escape.problem.newline.descriptor=Unicode 轉義序列 <code>\\#ref</code> 可被取代為換行字元 \\#loc
unpredictable.big.decimal.constructor.call.display.name=不可預知的 'BigDecimal' 建構函式呼叫
unpredictable.big.decimal.constructor.call.ignore.complex.literals.option=忽略具有多個字面量的建構函式呼叫 (例如 0.1 + 0.2)
unpredictable.big.decimal.constructor.call.ignore.references.option=忽略具有變量或方法呼叫實參的建構函式呼叫
unpredictable.big.decimal.constructor.call.problem.descriptor=不可預知的 <code>new \\#ref()</code> 呼叫 \\#loc
unqualified,static.usage.only.report.static.usages.option=僅報告來自非 static 上下文的靜態存取
unqualified.field.access.display.name=未使用 'this' 限定的執行個體欄位存取
unqualified.field.access.problem.descriptor=未使用 'this' 限定的執行個體欄位存取 <code>\\#ref</code> \\#loc
unqualified.inner.class.access.display.name=非限定內部類別存取
unqualified.inner.class.access.option=忽略對本地內部類別的參照
unqualified.inner.class.access.problem.descriptor=<code>\\#ref</code> 未使用外部類別限定 \\#loc
unqualified.inner.class.access.quickfix=使用外部類別限定
unqualified.method.access.display.name=未使用 'this' 限定的執行個體方法呼叫
unqualified.method.access.problem.descriptor=未使用 'this' 限定執行個體方法呼叫 <code>\\#ref()</code> \\#loc
unqualified.static.access.fix.family.name=限定靜態存取
unqualified.static.usage.display.name=非限定靜態存取
unqualified.static.usage.ignore.field.option=忽略非限定欄位存取
unqualified.static.usage.ignore.method.option=忽略非限定方法呼叫
unqualified.static.usage.problem.descriptor=非限定 static 方法呼叫 <code>\\#ref()</code> \\#loc
unqualified.static.usage.problem.descriptor1=非限定 static 欄位存取 <code>\\#ref</code> \\#loc
unqualified.static.usage.qualify.field.quickfix=限定 static 欄位存取
unqualified.static.usage.qualify.method.quickfix=限定 static 方法呼叫
unrunnable.main.method.problem.descriptor=無法執行方法 <code>\\#ref()</code>，因為包含類別沒有完全限定名稱
unsecure.random.number.generation.display.name=不安全的隨機數生成
unsecure.random.number.generation.problem.descriptor1=出於安全目的，請使用 'java.security.SecureRandom' 而不是 <code>java.lang.Math.\\#ref()</code> \\#loc
unsecure.random.number.generation.problem.descriptor2=出於安全目的，請使用 'java.security.SecureRandom' 而不是 <code>java.util.\\#ref</code> \\#loc
unsecure.random.number.generation.problem.descriptor3=出於安全目的，請使用 'java.security.SecureRandom' 而不是 <code>\\#ref</code> \\#loc
unused.import.problem.descriptor=未使用的 import <code>\\#ref</code> \\#loc
unused.label.display.name=未使用的標籤
unused.label.problem.descriptor=未使用的標籤 <code>\\#ref</code> \\#loc
unused.label.remove.quickfix=移除未使用的標籤
update.label=更新名稱開頭\\:
upper.case.field.name.not.constant.display.name=具有大寫名稱的非常數欄位
upper.case.field.name.not.constant.problem.descriptor=帶常數樣式名稱的非常數欄位 <code>\\#ref</code> \\#loc
use.0index.in.jdbc.prepared.statement.problem.descriptor=在 JDBC PreparedStatement 中使用索引 '0' \\#loc
use.0index.in.jdbc.resultset.display.name=在 JDBC ResultSet 中使用索引 0
use.0index.in.jdbc.resultset.problem.descriptor=在 JDBC ResultSet 中使用索引 '0' \\#loc
use.contentequals=使用 'contentEquals()' 與 'AbstractStringBuilder' 進行比較
use.equalsignorecase.for.case.insensitive.comparison=為不區分大小寫的比較使用 'equalsIgnoreCase()'
use.isblank.to.check.if.string.is.whitespace.or.empty=使用 'isBlank()' 檢查字串是否為空或者僅包含空格
use.obsolete.collection.type.display.name=使用廢棄的集合類型
use.obsolete.collection.type.ignore.library.arguments.option=在需要的位置忽略廢棄的集合類型
use.obsolete.collection.type.problem.descriptor=使用了廢棄的集合類型 <code>\\#ref</code> \\#loc
use.of.awt.peer.class.display.name=使用 AWT 對等類別
use.of.awt.peer.class.problem.descriptor=AWT 對等類別 <code>\\#ref</code> 的使用不可移植 \\#loc
use.of.clone.call.method.problem.descriptor=實作 <code>\\#ref()</code>
use.of.clone.call.problem.descriptor=呼叫 <code>\\#ref()</code>
use.of.clone.display.name=使用 'clone()' 或 'Cloneable'
use.of.clone.reference.problem.descriptor=使用 <code>\\#ref</code>
use.of.concrete.class.option.ignore.abstract=忽略抽象類別類型
use.of.concrete.class.option.ignore.records=忽略 Java 記錄
use.of.concrete.class.option.report.cast=報告轉換表達式中使用的類型
use.of.concrete.class.option.report.instance.fields=報告執行個體欄位類型
use.of.concrete.class.option.report.instanceof=報告 instanceof、patterns 或 getClass() 比較中使用的類型
use.of.concrete.class.option.report.local.variable=報告區域變數類型
use.of.concrete.class.option.report.method.returns=報告方法返回值類型
use.of.concrete.class.option.report.parameter=報告方法參數類型
use.of.concrete.class.option.report.static.fields=報告 static 欄位類型
use.of.concrete.jdbc.driver.class.display.name=使用具體的 JDBC 驅動程序類別
use.of.concrete.jdbc.driver.class.problem.descriptor=具體 JDBC 驅動程序類別 <code>\\#ref</code> 的使用不可移植 \\#loc
use.of.obsolete.date.time.api.display.name=使用廢棄的日期時間 API
use.of.obsolete.date.time.api.problem.descriptor=使用了廢棄的日期時間類型 <code>\\#ref</code> \\#loc
use.of.properties.as.hashtable.fix.family.name=修復屬性存取
use.processbuilder.class.display.name=使用 'java.lang.ProcessBuilder' 類別
use.processbuilder.class.problem.descriptor=<code>\\#ref</code> 的使用不可移植 \\#loc
use.stringtokenizer.display.name=使用 'StringTokenizer'
use.stringtokenizer.problem.descriptor=國際化上下文中的 <code>\\#ref</code> \\#loc
use.sun.classes.display.name=使用 'sun.*' 類別
use.sun.classes.problem.descriptor=Sun 提供的類別 <code>\\#ref</code> 的使用不可移植 \\#loc
use.system.out.err.display.name=使用 'System.out' 或 'System.err'
use.system.out.err.problem.descriptor=<code>\\#ref</code> 的使用可能應當取代為更可靠的日誌 \\#loc
use.system.out.err.problem.fix.err.option='System.err' 的日誌方法\\:
use.system.out.err.problem.fix.out.option='System.out' 的日誌方法\\:
utility.class.can.be.enum.display.name=實用程序類別可以是 'enum'
utility.class.code.can.be.enum.problem.descriptor=實用程序類別 <code>\\#ref</code> 可以是 'enum' \\#loc
utility.class.code.can.be.enum.quickfix=轉換為 'enum'
utility.class.display.name=實用程序類別
utility.class.problem.descriptor=類別 <code>\\#ref</code> 只有 'static' 成員，指示程序建構 \\#loc
utility.class.with.public.constructor.display.name=實用程序類別具有 'public' 建構函式
utility.class.with.public.constructor.fix.family.name=將建構函式設為非 public
utility.class.with.public.constructor.make.private.quickfix=將{0, choice, 1\\#建構函式|2\\#建構函式}設為 'private'
utility.class.with.public.constructor.make.protected.quickfix=將{0, choice, 1\\#建構函式|2\\#建構函式}設為 'protected'
utility.class.with.public.constructor.problem.descriptor=類別 <code>\\#ref</code> 只有 'static' 成員和 'public' 建構函式 \\#loc
utility.class.without.private.constructor.cant.generate.constructor.message=實用程序類別具有實例化，將不會建立 private 建構函式
utility.class.without.private.constructor.create.quickfix=生成空 'private' 建構函式
utility.class.without.private.constructor.display.name=實用程序類別沒有 'private' 建構函式
utility.class.without.private.constructor.make.quickfix=將建構函式設為 'private'
utility.class.without.private.constructor.option=忽略僅具有主方法的類別
utility.class.without.private.constructor.problem.descriptor=類別 <code>\\#ref</code> 只有 'static' 成員，缺少 'private' 建構函式 \\#loc
value.of.post.decrement.problem.descriptor=使用後減量表達式 <code>\\#ref</code> 的值 \\#loc
value.of.post.increment.problem.descriptor=使用後增量表達式 <code>\\#ref</code> 的值 \\#loc
value.of.pre.decrement.problem.descriptor=使用前減量表達式 <code>\\#ref</code> 的值 \\#loc
value.of.pre.increment.problem.descriptor=使用前增量表達式 <code>\\#ref</code> 的值 \\#loc
variable.argument.method.display.name=vararg 方法
variable.argument.method.problem.descriptor=vararg 方法 <code>\\#ref()</code> \\#loc
variable.argument.method.quickfix=將 vararg 參數轉換為數組
variable.not.used.inside.conditional.problem.descriptor=條件內未使用檢查為 'null' 的 <code>\\#ref</code> \\#loc
variable.not.used.inside.if.display.name='if' 內未使用檢查為 'null' 的參照
variable.not.used.inside.if.problem.descriptor='if' 內未使用檢查為 'null' 的 <code>\\#ref</code> \\#loc
variable.type.can.be.explicit.display.name=變數類型可以是顯式的
volatile.array.field.display.name=volatile 陣列欄位
volatile.field.problem.descriptor=類型 ''{0}'' 的 volatile 欄位 <code>\\#ref</code> \\#loc
wait.called.on.condition.display.name=在 'java.util.concurrent.locks.Condition' 物件上呼叫了 'wait()'
wait.called.on.condition.problem.descriptor=在條件物件上呼叫 <code>\\#ref()</code> \\#loc
wait.not.in.loop.display.name=未在迴圈中呼叫的 'wait()'
wait.not.in.loop.problem.descriptor=<code>\\#ref()</code> 呼叫不在迴圈中 \\#loc
wait.notify.not.in.synchronized.context.display.name='wait()' 或 'notify()' 不在同步的上下文中
wait.notify.while.not.synchronized.on.problem.descriptor=''{0}'' 未同步時呼叫 <code>\\#ref</code> \\#loc
wait.or.await.without.timeout.display.name=無超時的 'wait()' 或 'await()'
wait.or.await.without.timeout.problem.descriptor=無超時的 <code>\\#ref</code> \\#loc
wait.while.holding.two.locks.display.name=保持兩個鎖時 'wait()'
wait.while.holding.two.locks.problem.descriptor=在保持兩個鎖的情況下呼叫 <code>\\#ref()</code> \\#loc
wait.without.corresponding.notify.display.name=沒有相應 'notify()' 的 'wait()'
wait.without.corresponding.notify.problem.descriptor=在沒有相應 <code>notify()</code> 或 <code>notifyAll()</code> 的情況下呼叫 <code>\\#ref()</code> \\#loc
warn.level.and.lower.option=警告級別和更低
warn.on.label=警告物件\\:
weaken.visibility.quickfix=削弱可見性
while.can.be.foreach.display.name='while' 迴圈可被取代為增強的 'for' 迴圈
while.can.be.foreach.problem.descriptor=<code>\\#ref</code> 迴圈可被取代為增強的 'for' \\#loc
while.loop.spins.on.field.display.name='while' 迴圈在欄位上自旋
while.loop.spins.on.field.fix.family.name=修復自旋迴圈
while.loop.spins.on.field.fix.spinwait=新增 Thread.onSpinWait()
while.loop.spins.on.field.fix.volatile=將 ''{0}'' 設為 volatile
while.loop.spins.on.field.fix.volatile.spinwait=將 ''{0}'' 設為 volatile 並新增 Thread.onSpinWait()
while.loop.spins.on.field.ignore.non.empty.loops.option=僅當迴圈為空時才發出警告
while.loop.spins.on.field.problem.descriptor=<code>\\#ref</code> 迴圈在欄位上自旋 \\#loc
wrap.with.arrays.hash.code.quickfix=使用 ''{0}'' 包裝
write.only.object.display.name=只寫入物件
write.only.object.option.ignore.impure.constructors=忽略不純的建構函式
"
`;

exports[`dev messages/JavaScriptBundle.properties 1`] = `
"0.is.not.a.legal.name=''{0}'' 不是合法的類別名
0.is.not.accessible.from.1=無法從 {1} 存取 {0}
0.is.not.allowed.in.interface=接口中不允許使用 {0} 
0.with.1.visibility.in.the.target.class.is.not.accessible.from.2=目標類別中可見性為 {1} 的 {0} 無法從 {2} 存取
0.with.1.visibility.is.not.accessible.from.2=可見性為 {1} 的 {0} 將無法從 {2} 存取
action.Anonymous.text.configure=組態
action.ES6.Generate.Index.description=生成 index.js/index.ts
action.ES6.Generate.Index.text=生成 index.js/index.ts
action.EnablePackageJsonMismatchedDependenciesNotification.text=啟用有關從 package.json 安裝相依項的通知
action.EslintImportCodeStyle.description=套用 ESLint 程式碼樣式規則
action.EslintImportCodeStyle.text=套用 ESLint 程式碼樣式規則
action.ExplainNodeModulesLibrariesAction.text=解釋 node__modules 庫
action.FindDuplicatedIndexedFilesInNodeModulesAction.text=在 node__modules 中尋找重複的索引檔案
action.FlowJS.Restart.All.Servers.description=重啟所有 Flow 伺服器
action.FlowJS.Restart.All.Servers.text=重啟所有 Flow 伺服器
action.Generate.Constructor.JavaScript.text=建構函式
action.Generate.GetAccessor.JavaScript.text=Getter
action.Generate.GetSetAccessor.JavaScript.text=Getter 和 Setter
action.Generate.Missing.Members.ES6.text=實作方法…
action.Generate.Missing.Members.TypeScript.text=實作成員…
action.Generate.SetAccessor.JavaScript.text=Setter
action.InstallNodeLocalDependencies$Root.text=在專案根目錄中執行 'npm install'
action.InstallNodeLocalDependencies$Root.text.template=為 {1} 執行 ''{0}''
action.InstallNodeLocalDependencies.text=安裝 Node.js 相依項
action.JS.TypeScript.Include.Generated.Declarations.description=在專案中包含 .d.ts 子檔案
action.JS.TypeScript.Include.Generated.Declarations.text=包括 '.d.ts' 子檔案
action.JSShowUsagesFloatingToolbar.description=顯示文字游標處符號的用法
action.JSShowUsagesFloatingToolbar.text=顯示用法(_S)
action.JasmineGenerateAfterEachMethodAction.text=Jasmine afterEach
action.JasmineGenerateBeforeEachMethodAction.text=Jasmine beforeEach
action.JasmineGenerateNewSpecAction.text=Jasmine Spec
action.JasmineGenerateNewSuiteAction.text=Jasmine Suite
action.JavaScript.SearchForComponentUsageAction.description=顯示當前所選元件的用法
action.JavaScript.SearchForComponentUsageAction.text=顯示元件用法
action.JavaScript.ShowComponentUsages.description=顯示當前所選元件的用法
action.JavaScript.ShowComponentUsages.text=顯示元件用法
action.JavaScriptGenerateDictionaries.text=生成 JavaScript 拼寫檢查器字典
action.LearnWebstormAction.description=檢視自定義和程式碼編輯提示以充分利用 WebStorm
action.LearnWebstormAction.text=學習 WebStorm
action.NewJavaScriptFile.description=從指定的模板建立 JavaScript 檔案
action.NewJavaScriptFile.text=JavaScript 檔案
action.NewPackageJsonFile.description=建立 package.json 檔案
action.NewPackageJsonFile.text=package.json
action.NewTypeScriptFile.description=建立新的 TypeScript 檔案
action.NewTypeScriptFile.text=TypeScript 檔案
action.NodeServicesProfilerAction.text=啟動 Node.js 服務分析
action.QUnitGenerateNewTestAction.text=QUnit Test
action.QUnitGenerateSetupAction.text=QUnit Setup
action.QUnitGenerateTearDownAction.text=QUnit TearDown
action.RestartEsLintServiceAction.description=停止執行 ESLint 服務，根據需要自動重啟
action.RestartEsLintServiceAction.text=根據需要停止和自動執行 ESLint 服務
action.RunJsbtTask.text=執行 Gulp/Grunt/npm 任務
action.StopSingleEsLintServiceAction.text=根據需要停止和自動執行服務
action.ToggleNodeCoreCodingAssistanceAction.text=切換 Node.js 的編碼輔助
action.TypeScript.Enable.Service.text=TypeScript 語言服務
action.TypeScript.Include.Sources.text=包括 JavaScript 檔案
action.TypeScript.Restart.Service.text=重啟 TypeScript 服務
action.TypeScript.Show.Structure.text=顯示 TypeScript 伺服器專案
action.TypeScript.Test.Slow.Server.text=測試慢速 TypeScript 伺服器
action.TypeScriptAddEnumTextInlayAction.text=新增枚舉顯式值
action.TypeScriptExtractTypeAlias.description=提取類型別名
action.TypeScriptExtractTypeAlias.text=類型別名…
action.already.set.for.containing.folder.or.project.description=已針對包含的目錄或專案進行設定。
action.creates.new.file.description=建立新的 {0} 檔案
action.don.t.ask.again.text=不再詢問
action.don.t.use.library.description=不使用庫
action.js.tagged.literal.injection.text=JS 標記字面量注入
action.jump.to.text=跳轉到…
action.name.disable.category=停用 {0}
action.restart.service=重啟服務
action.show.error.details.text=顯示錯誤詳細資訊
action.show.structure.text=顯示結構
action.structureview.show.object.inherited=從物件繼承
action.use.library.description=使用庫
action.view.install.text=檢視並安裝…
actionscript.space.after.dots.in.rest.parameter=在 rest 參數中的 '…' 後面
actionscript.validation.message.get.method.access.type.is.different.from.setter=Flash 編譯器錯誤 174646: Get 存取器方法存取類型不同於 set 存取器存取類型，應為 ''{0}''
actionscript.validation.message.set.method.access.type.is.different.from.getter=Flash 編譯器錯誤 174646: Set 存取器方法存取類型不同於 get 存取器存取類型，應為 ''{0}''
activity.key.node.js.name=Node.js
activity.tracker.node.modules.name=node_modules 追蹤器
add.import.binding.to.import=將匯入綁定新增到匯入
add.import.specifier.to.import=將匯入說明符新增到匯入
add.variable.to.require=新增 require 呼叫的變數
advanced.setting.js.FindInFiles.with.library.files=在“在檔案中尋找”中選擇“目錄”時，在庫檔案中搜尋
advanced.setting.js.fallback.to.old.eval.outside.of.import.graph=使用來自伺服器的類型時，回退到 IDE 類型評估器以處理當前匯入圖之外的檔案。
advanced.setting.js.fallback.to.old.eval.outside.of.import.graph.description=IDE 可以嘗試評估不在當前 TypeScript 專案(tsconfig.json) import 圖內的檔案中的類型。在這種情況下，伺服器可以載入和解析大量新檔案來提供類型。回退到 IDE 評估器可以顯著提高大型專案的性能。
advanced.setting.js.js.advanced.annotator=進階 JavaScript 註解器
advanced.setting.js.js.advanced.annotator.description=JavaScript 註解器會檢查 JS / JSX 中的基本語意 JS 錯誤。進階註解器可以發現更多錯誤，但可能會消耗更多 CPU 資源。
advanced.setting.js.jsx.advanced.annotator=進階 JSX 註解器
advanced.setting.js.jsx.advanced.annotator.description=JSX 註解器會驗證 JSX 和 TSX 中的 JSX 標籤。進階註解器可以發現更多錯誤，但可能消耗更多 CPU 資源。如果您使用 TypeScript 語言服務，請考慮停用此選項。
advanced.setting.js.jsx.client.components=醒目提示顯示 JSX 用戶端元件
advanced.setting.js.jsx.client.components.description=對 JSX 伺服器/用戶端元件使用不同的顏色。可能會消耗額外的 CPU 資源
advanced.setting.js.semantic.highlighting.accuracy=語意醒目提示準確性
advanced.setting.js.semantic.highlighting.accuracy.basic=基本
advanced.setting.js.semantic.highlighting.accuracy.description=語意醒目提示會為程式碼元素指定不同的顏色，以區分本地和全域、函式和物件等。更高的準確性可以更深入地分析程式碼，但可能會消耗更多的 CPU 資源。
advanced.setting.js.semantic.highlighting.accuracy.high=高
advanced.setting.js.semantic.highlighting.accuracy.limited=有限
advanced.setting.js.semantic.highlighting.accuracy.normal=正常
advanced.settings.js=JavaScript 和 TypeScript
and.more=以及更多…
anonymous.to.named.intention.function.name=函式名稱:
automatically.replace.with.template.string.on.typing=輸入 '\${' 時自動將字串字面量取代為模板字串
border.title.inspection.export.results.capitalized.location=位置
build.event.title.failed.to.list.tasks=無法列出 {0} 任務
buildTools.EditRunSettingsAction.text=編輯 ''{0}'' 設定(&E)…
buildTools.JsbtAddBuildfileAction.text=新增 {0}
buildTools.JsbtReloadTasksAction.npm.text=重新載入腳本
buildTools.JsbtReloadTasksAction.text=重新載入任務
buildTools.JsbtRemoveBuildfileAction.text=移除 {0}
buildTools.JsbtShowTasksAction.npm.text=顯示 npm 腳本
buildTools.JsbtShowTasksAction.text=顯示 {0} 任務
buildTools.ShowSettingsAction.npm.text=編輯 npm 組態(&E)…
buildTools.ShowSettingsAction.text={0}設定…
buildTools.add.with=使用 {1} 新增 {0}
buildTools.choose_buildfile.text=選擇 {0}
buildTools.edit.run.configuration=編輯執行組態
buildTools.failed.to.list.tasks=無法列出任務
buildTools.failed.to.list.tasks.details.reference=詳細資訊
buildTools.no.files.added=未新增檔案
buildTools.no.such.file=沒有此類別檔案
buildTools.no.tasks.found=未找到任務
buildTools.searchEverywhere.npm.text=執行 {0} npm 腳本
buildTools.searchEverywhere.text=執行“{0}”任務
buildTools.tooltip.click.to.show.error.details=點擊以顯示錯誤詳細資訊
buildTools.tree.sortBy.definitionOrder.text=定義順序
buildTools.tree.sortBy.name.text=名稱
buildTools.tree.sortBy.text=排序方式
bundler.configuration.automatic=自動
bundler.configuration.automatic.hint={0} 將使用當前檔案所在目錄或其任意父目錄中的 {1} 組態檔案內的模組解析規則。
bundler.configuration.automatic.how.it.works=運作方式
bundler.configuration.detect.description=檢測適合模組解析的 {0} 組態檔案:
bundler.configuration.disabled=已停用
bundler.configuration.field=組態檔案:
bundler.configuration.field.required.error=手動模式下需要組態檔案路徑
bundler.configuration.manual=手動
button.abort=中止
button.continue=繼續
button.install.update=安裝/更新
can.t.find.flow.executable=找不到 Flow 可執行檔案
cannot.modify.library.code=無法修改庫或 SDK 程式碼
cannot.parse.service.initialization.answer.0=無法解析服務初始化回復 {0}\\n
cannot.refactor.anonymous.function=現有非呼叫用法阻止呼叫點分析。
change.method.signature.and.update.delegating.call.fix.family.name=更改方法簽名並更新委託呼叫
change.method.signature.and.update.delegating.call.fix.text=更改 {0} 簽名以符合 {1} 呼叫和更新呼叫
change.method.signature.and.update.delegating.call.noname.fix.text=更改簽名以符合 {0} 呼叫和更新呼叫
change.method.signature.delegating.default.text=委託
change.method.signature.fix.family.name=更改方法簽名
change.method.signature.fix.text=更改 {0} 簽名
change.signature.call.expression.contains.spreads=函式呼叫包含傳播實參。用法將保持不變。
change.signature.column.name=名稱
change.signature.column.name.call.value=呼叫中的值
change.signature.column.name.default.parameter=預設參數
change.signature.column.name.initializer=初始設定式
change.signature.column.name.modifier=修飾符
change.signature.column.name.optional.flag=可選
change.signature.column.type=類型
change.signature.conflict.eliminating.parameter.property.breaks.usages=將參數-屬性轉換為簡單的參數將中斷 {0} 的欄位用法
change.signature.conflict.incompatible.implementation=實作 {0} 的參數個數與重構 {1} 的參數個數不同。重構期間將忽略 {2}。
change.signature.conflict.incompatible.override=覆寫 {0} 的參數個數與重構 {1} 的參數個數不同。重構期間將忽略 {2}。
change.signature.conflict.readonly.parameter.property.write.usage=將 {0} 變為唯讀將中斷非讀取用法
change.signature.dialog.title=更改 {0} 的簽名
change.signature.method.references.arguments=函式參照實參，更改簽名後代碼可能會中斷
change.signature.parameter.table.empty.message=使用  '+' 按鈕新增新參數
change.signature.tagged.template.issue=無法更新標記的模板呼叫。用法將保持不變。
change.signature.usage.view.declarations.header=要重構的方法
change.signature.value.column.title=值
changeSignature.vararg.not.last=Rest 參數應當為方法簽名中的最後一個參數
checkbox.collapse.array.literals=陣列字面量
checkbox.collapse.object.literals=物件字面量
checkbox.collapse.one.line.function.literals=JavaScript 和 TypeScript 中的單行函式
checkbox.collapse.xml.literals=XML 字面量
checkbox.enable=啟用
checkbox.move.simple.expressions.to.field.initializer=將簡單表達式移至欄位初始設定式
choose.base.component.title=選擇超類別
choose.class.to.import.title=要匯入的類別
choose.declaration.element=<html><body>選擇 TypeScript 宣告</body></html>
choose.destination.scope=選擇目標作用域
choose.field.type=選擇欄位類型
choose.implementing.class=<html><body>選擇 <b>{0}</b> 的實作(找到 {1})</body></html>
choose.implementing.method=<html><body>選擇 <b>{0}</b> 的實作(找到 {1} 個)</body></html>
choose.overriding.function=<html><body>選擇 <b>{0}</b> 的覆寫函式(找到 {1} 個)</body></html>
choose.overriding.method=<html><body>選擇 <b>{0}</b> 的覆寫方法(找到 {1} 個)</body></html>
choose.subclass=<html><body>選擇 <b>{0}</b> 的子類別(找到 {1})</body></html>
choose.super.class.title=選擇超類別
choose.super.classifier=<html><body>選擇 <b>{0}</b> 的超類別或接口(找到 {1})</body></html>
choose.super.field=<html><body>選擇 <b>{0}</b> 的 Super 欄位(找到 {1})</body></html>
choose.super.function=<html><body>選擇 <b>{0}</b> 的 Super 函式(找到 {1})</body></html>
choose.super.interface.title=選擇 Super 接口
choose.super.method=<html><body>選擇 <b>{0}</b> 的 Super 方法(找到 {1})</body></html>
class.0.cannot.be.created=無法建立目標類別 {0}，因為存在同名的限定元素
class.already.contains.field.warning=類別 ''{0}'' 已包含欄位 ''{1}''。\\n是否繼續?
class.already.contains.method.warning=類別 ''{0}''已經 {1, choice, 1# 包含|2#繼承} 方法 ''{2}()''。\\n是否繼續?
class.chooser.not.available.in.dumb.mode=正在進行索引更新，選擇器不可用。
class.does.not.have.inheritors.in.current.project={0} 在當前專案中沒有繼承者
class.names={0,choice,1#類別|2#類別} {1}
class.template.title=類別
class.with.supers.template.title=包含 Super 的類別
code.vision.implementations.hint={0, choice, 1#1 個實作|2#{0,number} 個實作}
code.vision.inheritors.hint={0, choice, 1#1 個繼承者|2#{0,number} 個繼承者}
code.vision.overrides.hint={0, choice, 1#1 個覆寫|2#{0,number} 個覆寫}
code.vision.performance.watcher.notification.configure=組態…
code.vision.performance.watcher.notification.disable.code.vision=停用提示
code.vision.performance.watcher.notification.message=停用 Code Vision 提示可以通過減少 CPU 負載來提高性能。
code.vision.performance.watcher.notification.title=Code Vision 提示評估緩慢
codestyle.ui.field.prefix=欄位前綴 (&F):
codestyle.ui.file.name.style=檔案命名約定 (&N):
codestyle.ui.generated.jsdoc.use.types.checkbox=在 JSDoc 中包括類型 (&T)
codestyle.ui.property.prefix=屬性前綴 (&P):
collection.queried.but.not.update=查詢了集合 <code>#ref</code> 的內容，但從未寫入
collection.updated.but.not.queried=更新了集合 <code>#ref</code> 的內容，但從未被查詢
command.name.add.explicit.value=新增顯式值 ''{0}''
command.name.create.javascript.file=建立 JavaScript 檔案 {0}
command.name.create.typescript.file=建立 TypeScript 檔案 {0}
command.name.extract.named.type=提取已命名類型
command.name.import=匯入 {0}
complete.import.binding=完整的匯入綁定
complete.import.name=完整的匯入名稱
configurable.JSCodeCompletionConfigurable.display.name=JavaScript
configurable.JSSmartKeysConfigurable.display.name=JavaScript
configurable.JSTemplateLangConfigurable.display.name=模板
configurable.MyConfigurable.display.name=JSX
configure.code.completion.settings=組態程式碼補全設定
configure.node.interpreter.path=組態 Node.js 路徑…
copying.files=正在複製檔案
create.button.text=建立(&C)
create.class.interfaces.label=接口(&I):
create.class.name.label=名稱(&N):
create.class.ok.button.text=建立
create.class.package.label=軟體套件:
create.class.superclass.label=超類別(&S):
create.class.template.label=模板(&T):
create.constructor.dialog.title=建立建構函式
create.field.dialog.title=建立欄位
create.file.name=建立檔案 ''{0}''
create.file.name.with=使用 {1} 建立檔案 ''{0}''
create.file.name.with.and=使用 {1} 和 {2} 建立檔案 ''{0}''
create.method.dialog.title=建立方法
create.mobile.view=建立檢視 ''{0}''
create.react.app.warning.deprecated=不建議使用 <b>create-react-app</b> 建立 React 應用程式。在沒有框架的情況下使用 React 時，首選方式是使用帶 <a href="https://vitejs.dev/guide/#trying-vite-online">Vite Bundler</a> 的模板。
custom.template.variables=自訂模板變數(&C):
custom.variables.step.title.label.text=模板 ''{0}'' 中的自訂變數 (&C):
declare.event.0=宣告事件 ''{0}''
declare.static=宣告 static(&S)
diagram.element.not.found={0} (未找到)
dialog.kind.0.file={0} 檔案
dialog.message.cannot.compile.typescript.config.file.incorrect=無法編譯 TypeScript。組態檔案不正確。
dialog.message.cannot.create.argument.stubs.invoked.method.function=無法建立實參存根: 呼叫的方法不是函式
dialog.message.cannot.determine.package.json.directory=無法確定 package.json 目錄
dialog.message.cannot.find.file=找不到檔案 {0}
dialog.message.cannot.find.module.for.import=無法建置用於匯入的模組路徑
dialog.message.cannot.find.module.types=找不到模組 @types/{0}
dialog.message.cannot.find.npx.bundled.with=找不到使用 {0} 捆綁的 npx
dialog.message.cannot.infer.type.new.parameter=無法推斷新參數的類型
dialog.message.cannot.locate.wrapper.config.file=找不到包裝器組態檔案
dialog.message.cannot.proceed.when.having.non.read.usages.in.embedded.expressions=嵌入式表達式中有非讀取用法時，無法繼續
dialog.message.cannot.propagate.variable=無法傳播變數: {0}
dialog.message.cannot.propagate.when.having.usages.declarations.in.different.files=用法和宣告位於不同檔案中時，無法傳播
dialog.message.cannot.transform.object.array.destructuring.patterns.for.same.element=無法為相同的元素轉換物件和陣列解構模式
dialog.message.command.supported.by={1} 不支持指令 ''{0}''
dialog.message.component.name=元件名稱:
dialog.message.expression.indexed.by.non.numeric.value=表達式使用非數字值編制索引
dialog.message.failed.to.download.0.1=無法下載 {0}。{1}
dialog.message.incomplete.destructuring.pattern.encountered.in.code=在程式碼中遇到不完整的解構模式
dialog.message.incorrect.path.to.typescript.package=typescript 軟體套件的路徑不正確
dialog.message.invalid.npm.package=無效的 {0} 軟體套件: 無此類別檔案或目錄
dialog.message.invalid.npx.command=無效的 npx 指令
dialog.message.invalid.package.file.specified.but.directory.with.package.json.expected={0} 軟體套件無效: 指定了一個檔案，但應為包含 package.json 的目錄
dialog.message.invalid.package.no.such.directory=無效的 {0} 軟體套件: 無此類別目錄
dialog.message.no.npm.script=無 ''{0}'' npm 腳本
dialog.message.no.path.to.package.json.found=未找到 package.json 的路徑。
dialog.message.no.results.for.after={1} 之後沒有 {0} 的結果
dialog.message.no.such=沒有這樣的 {0}
dialog.message.node.interpreter.is.located.in.another.wsl.distribution=Node.js 解釋器位於與指定專案路徑不同的 WSL 發行版中。
dialog.message.node.interpreter.must.be.located.in.wsl=Node.js 解釋器必須位於 WSL 中，並具有指定的專案路徑。
dialog.message.node.interpreter.unspecified.error.text=請指定 Node.js 解釋器
dialog.message.package.yarn.installed.package.format.yarn.relative.path.to.package.json.package.name={0}軟體套件: Yarn 安裝的軟體套件格式為 ''yarn:[package.json 的相對路徑]:[軟體套件名稱]''。
dialog.message.please.select.distribution=請選擇發行版
dialog.message.please.specify.npm.scripts.to.run=請指定要執行的 npm 腳本
dialog.message.please.specify.package.json=請指定 package.json
dialog.message.please.specify.package.json.correctly=請正確指定 package.json
dialog.message.please.specify.wsl.path.to.node.js.interpreter=請指定 WSL 中安裝的 Node.js 解釋器的路徑
dialog.message.some.usages.cannot.be.updated.properly=有些用法無法正常更新。\\n匯入和匯出中的用法、字串用法或動態參照無法取代為解構。
dialog.message.some.usages.cannot.be.updated.properly.wrong.access=有些用法無法正常更新。\\n無法取代不按名稱存取屬性的用法或者不按索引存取元素的用法。
dialog.message.transforming.multiple.nested.patterns.not.supported=陣列解構不支持轉換多個嵌套模式
dialog.message.unspecified=未指定的 {0}
dialog.message.unspecified.package=未指定 {0} 軟體套件
dialog.message.unspecified.package.name=未指定軟體套件名稱。
dialog.message.unspecified.suite.name=未指定的套件名稱
dialog.message.unspecified.test.name=未指定的測試名稱
dialog.message.unsupported.destructuring.container=不支持的解構容器: {0}
dialog.message.usages.search.was.interrupted=用法搜尋被中斷
dialog.message.variables.from.destructuring.pattern.have.no.usages=來自於解構模式的變數沒有用法
dialog.message.write.usages.cannot.be.updated.with.destructuring=寫入用法無法通過重構進行更新
dialog.title.cannot.convert=無法轉換
dialog.title.cannot.introduce.new.interface=無法引入新接口
dialog.title.cannot.propagate=無法傳播
dialog.title.configure.coding.assistance.for.node.js.api=組態 Node.js API 編碼輔助
dialog.title.download.error=下載錯誤
dialog.title.edit.run.debug.configuration=編輯執行/偵錯組態: ''{0}''
dialog.title.grunt.settings=Grunt 設定
dialog.title.gulp.settings=Gulp 設定
dialog.title.missing.dependencies=缺少相依項
dialog.title.move.members=移動成員
dialog.title.new.javascript.file=新增 JavaScript 檔案
dialog.title.new.typescript.file=新增 TypeScript 檔案
dialog.title.select.navigation.target=選擇導覽目標
dialog.title.select.parameters.to.convert.to.parameter.properties=選擇要轉換為參數-屬性的參數
dialog.title.select.targets.to.convert.to.class=選擇要轉換為類別的目標
dialog.title.wsl.node.interpreter={0} WSL Node 解釋器
dialog.title.wsl.node.interpreter.edit=編輯
dialog.title.wsl.node.interpreter.edit.add=新增
directory.already.contains.file=目錄 ''{0}'' 已包含檔案 ''{1}''
duplicate.parameter.name=重複的參數名稱: {0}
editor.notification.label.enable.babel.file.watcher.question=是否啟用 File Watcher 以使用 Babel 將 ECMAScript 6 轉換為 ECMAScript 5?
element.name.anonymous=<匿名>
element.name.default=<預設>
entity.in.parent.description={0} ({1} 內)
env.variable.empty={0} 為空
env.variable.undefined={0} 未定義
environment.key.description.package_json.install.dependencies=指示 IDE 是否應安裝專案檔案中發現的 'package.json' 的相依項。\\n值為 'true' 或 'false'
error.not.available.in.javascript.code={0} 在 JavaScript 程式碼中不可用
error.wrong.caret.position.method.name=文字游標應置於要重構的方法的名稱處。
es6.auto.import.options.completion.add.imports=自動新增 JavaScript import
es6.auto.import.options.title=TypeScript / JavaScript
es6.change.to.default.fix=對 ''{0}'' 使用預設匯入
es6.change.to.named.import.fix=對 ''{0}'' 使用命名匯入
es6.changeSignature.call.value.not.allowed=參數 ''{0}'' 不允許使用呼叫中的值。因為沒有為前面的參數指定它。
es6.changeSignature.no.call.value=新參數 ''{0}'' 已新增。\\n指定要用於此方法的所有現有呼叫的預設值或值。
es6.code.style.path.mapping.always=始終
es6.code.style.path.mapping.different.paths=僅在指定路徑以外的檔案中
es6.code.style.path.mapping.never=從不
es6.default.export.not.declared=未在匯入的模組中宣告預設匯出
es6.extract.super.destination.label=目標檔案 (&D):
es6.extract.super.different.name.expected=應為不同名稱
es6.extract.super.members.in.interface=新接口中的成員
es6.extract.super.members.in.superclass=新超類別中的成員
es6.extract.super.overload.declaration.without.implementation.conflict=類別中不允許沒有實作的多載宣告 {0}
es6.import.options.blacklist.title=不從指定路徑或路徑模式匯入:
es6.import.options.exts.help=此選項用於組態 import 語句中的副檔名。<br><br>選擇“自動”時，IDE 會向 vue 檔案、來自在 package.json 中具有 "type": "module" 的專案的檔案，以及擴展名為 .mjs 或 .cjs 的檔案的名稱新增副檔名。<br><br>選擇“始終”時，IDE 會始終向檔名新增副檔名。<br><br>選擇“從不”時，IDE 會始終使用不帶副檔名的檔名。
es6.import.options.not.import.help=此選項會組態 IDE 在自動匯入符號期間跳過的確切路徑。相反，IDE 將尋找替代路徑來匯入符號。路徑應符合 glob 模式規則。
es6.import.options.paths=使用路徑別名:
es6.import.options.paths.help=此選項用於組態 import 語句中使用的路徑樣式。<br><br>選擇“始終”時，IDE 會始終使用來自 webpack、vite 或 jsconfig.json 組態的別名。<br><br>選擇“僅在指定路徑之外的檔案中”時，IDE 會針對為之定義了別名的檔案之間的匯入使用相對路徑。在所有其他檔案中，使用路徑映射。<br><br>選擇“從不”時，則從不使用別名。
es6.insert.await.fix=插入 await
es6.missing.await.report.for.promises=報告 return 語句中的 promise
es6.missing.await.report.for.promises.hint=在異步函式呼叫前插入 'await' 有助於 V8 提供異步堆疊追蹤
es6.move.module.members.cannot.detect.js.language=目標檔案不是 JS 檔案
es6.move.module.members.destination.contains.default.export=目標模組包含預設匯出
es6.move.module.members.destination.does.not.support.jsx={0} 包含 JSX 標籤，但目標語言不支持這些標籤
es6.move.module.members.destination.not.es6=目標檔案 {0} 不是 ES6 模組
es6.move.module.members.has.local.usage.message=檔案 {1} 中使用未匯出的 {0}
es6.move.module.members.incompatible.language=目標模組具有不相容的語言
es6.move.module.members.non.es6.module.usage=在非 ES6 模組的檔案 {1} 中使用 {0}
es6.move.module.members.refactoring.create.file=建立檔案
es6.move.module.members.refactoring.create.file.message=檔案 {0} 不存在。\\n是否要建立?
es6.move.module.members.refactoring.dialog.error.incorrect.module=目標模組不正確
es6.move.module.members.refactoring.dialog.error.invalid.file.name=目標檔名在此作業系統中無效
es6.move.module.members.refactoring.dialog.error.modules.same=源模組和目標模組應不同
es6.move.module.members.refactoring.dialog.error.no.script.tag=目標檔案不包含腳本標籤
es6.move.module.members.refactoring.dialog.error.no.selected.items=沒有要移動的選定成員
es6.move.module.members.refactoring.dialog.field.from=從:
es6.move.module.members.refactoring.dialog.field.to=到:
es6.move.module.members.refactoring.dialog.move.member.to=成員移動至
es6.move.module.members.refactoring.file.does.not.exist=檔案 {0} 不存在
es6.move.module.members.refactoring.name=移動模組成員
es6.move.module.members.references.local.message=選擇的 {0} 參照非匯出 {1}
es6.move.module.members.references.unresolved.import.message=選擇的 {0} 參照未解析匯入 {1}
es6.move.module.members.syntax.errors=移動 {0} 將引入語法錯誤，因為目標語言不同於源語言
es6.move.module.members.table.title=要移動的成員
es6.prefer.short.import.name=可以縮短匯入
es6.redundant.await.report.for.promises=報告 promise
es6.redundant.await.report.for.promises.hint=總是報告 'return await' 為冗餘，但這會破壞 V8 的異步堆疊追蹤功能
es6.replace.import.action.name=取代為 {0}
es6.replace.import.family.name=取代為較短的路徑
es6.validate.import.error=無法解析符號 ''{0}''
es6.validation.message.const.variable.without.initializer=不允許使用無初始設定式的 'const' 變數
escape.jsdoc.copy.pasted.text=在複製和貼上時轉義 JSDoc 前導星號
escape.pasted.text=在貼上字串字面量時轉義文本
eslint.action.fix.problems.description=通過呼叫 'eslint --fix' 修正 ESLint 問題
eslint.additional.rules.directory.field.name=其他規則目錄
eslint.code.style.apply.message=套用 ESLint 的程式碼樣式?
eslint.code.style.apply.text=是
eslint.code.style.dismiss.text=否
eslint.configurable.additionalRulesDir.browseDialogTitle=選擇 ESLint 其他規則目錄
eslint.configurable.additionalRulesDir.label=其他規則目錄 (&R):
eslint.configurable.config.autoSearch.description.bodyInnerHtml=ESLint 將在要 lint 的檔案的目錄中以及連續的父目錄中尋找 .eslintrc.* 和 package.json 檔案，直至尋找到檔案系統的根目錄。<div style="padding-top:8px">要使用 package.json，請將您的組態新增到 <code>eslintConfig</code> 屬性下。</div>
eslint.configurable.config.select.config.text=選擇 ESLint 組態檔案(*.eslintrc.*)
eslint.configurable.eslintPackage.label=ESLint 軟體套件(&E):
eslint.configurable.extraOptions.label=額外 eslint 選項 (&O):
eslint.configurable.label.working.directories=工作目錄(&W):
eslint.configurable.working.dir.field.empty.text=由最近的 .eslintrc 或 .eslintignore 檢出
eslint.configurable.working.directories.comment=路徑或 <a href='https://github.com/isaacs/node-glob#glob-primer'>glob 模式</a>，以分號分隔。為自動檢測留空。
eslint.configuration.file.field.name=ESLint 組態檔案
eslint.error.package.directory.expected=應為軟體套件目錄
eslint.files.pattern.comment=使用 <a href=''https://github.com/isaacs/node-glob#glob-primer''>glob 模式</a>，例如 <code>**/*.{js,ts}</code>
eslint.fix.problems.family.name={0}: 修復當前錯誤
eslint.fix.problems.text.current={0}: 修復當前錯誤
eslint.fix.problems.text.with.error.code={0}: 修復 ''{1}''
eslint.inspections.error.can.not.parse.message=無法解析訊息，應為 JSON 物件，但實際為: {0}
eslint.inspections.error.messages.not.array=訊息不是陣列: {0}
eslint.inspections.error.unexpected.language.service.response=意外的語言服務響應: {0}
eslint.inspections.error.unknown.message.severity=未知的訊息嚴重性: {0}\\n主體:\\n{1}
eslint.run.for.files.label=為檔案執行(&F):
eslint.run.on.save=儲存時執行 eslint --fix(&U)
eslint.run.on.save.auto.configuration.comment=自動 ESLint 組態
eslint.run.on.save.checkbox.on.actions.on.save.page=執行 eslint --fix
eslint.run.on.save.disabled.comment=已停用 ESLint 整合
eslint.run.on.save.link.enable.eslint=啟用 ESLint…
eslint.run.on.save.manual.configuration.comment=手動 ESLint 組態
eslint.version.0.is.not.supported.please.upgrade.eslint=ESLint 版本 {0} 不受支援。請升級 ESLint。
extract.0.turn.refs=提取 {0} 並盡量使用 (&T)
extract.constant.type=類型(&T):
extract.function.declare.arrow.function=&箭頭函式
extract.function.function=函式
extract.function.name=名稱(&N):
extract.function.parameters=參數
extract.function.return.type=返回值類型(&T):
extract.function.signature.preview=簽名預覽
extract.interface.command.name=提取接口
extract.method.declare.static=宣告 static(&S)
extract.subclass.command.name=從 {1} 提取子類別 {0}
extract.type.alias.command.name=提取類型別名
failed.to.download=無法下載
fetch.client.generator.title=JavaScript Fetch
field.initializer.is.not.specified=未指定欄位初始設定式
file.name.masks.to.skip.from.analysis=要在分析中排除的檔名遮罩:
filetype.actionscript.description=ActionScript
filetype.js.testing.snapshot.description=JavaScript 測試快照(Jest)
filetype.js.testing.snapshot.display.name=JavaScript 測試快照
filetype.jshint.config.description=JSHint 組態
filetype.jshint.config.display.name=JSHint 組態
filetype.yarn.lock.description=Yarn lock
filetype.yarn.lock.display.name=Yarn Lock
find.usages.of.base.class={1} 的方法 {0}\\n覆寫 {2} 的方法。\\n要{3}基方法嗎?
find.usages.of.base.interface={1} 的方法 {0}\\n實作 {2} 的方法。\\n要{3}基方法嗎?
flow.js.get.type=Flow JS:Get 類型
flow.js.show.settings=組態 Flow…
flow.js.version.not.supported=Flow JS 版本 {0} 不受支援
flow.js.widget.display.name=Flow JS
flow.js.widget.name=Flow
function.names={1}{0,choice,1#函式|2#函式} 
function.returns=函式返回值類型
function.returns.description=函式返回值類型
generate.constructor.overloads.and.fields.chooser.title=選擇要使用的多載和要初始化的欄位
generate.delegate.method.conflict.message=無法通過不同的屬性為同名成員生成委託
generate.delegate.method.conflict.message.title=無法生成委託
generate.filter.button.description=在列表中顯示 {0} 
generate.filter.button.tooltip=顯示 {0}
generate.filter.fields=欄位和屬性
generate.filter.indexers=索引器
generate.filter.methods=方法
generate.to.string.chooser.title=選擇要在 toString 函式中使用的欄位
generating.0=正在生成 {0}
generating.errors.cannot.generate=無法生成 {0}
generating.errors.in.console=檢視主控台中的錯誤(離開程式碼 {0}})
generating.installing.deps=正在安裝相依項…
generating.new.project=新增專案
generating.template.processing=模板處理
generating.with.tips=生成帶有入門提示的 Playground 專案
generating.with.tips.comment=基於 Vite 的計數器專案
generation.bindable.event=可綁定事件(&B):
generation.event.constant=事件常數(&E):
group.Editor.JSLibrariesMenu.description=選擇要與當前檔案一起使用的 JavaScript 庫
group.Editor.JSLibrariesMenu.text=使用 JavaScript 庫
group.Floating.CodeToolbar.JS.Refactor.text=重構
group.Floating.CodeToolbar.JS.text=浮動程式碼工具列 Web
grunt.before.run.task=執行 Grunt 任務
grunt.before.run.task.descr=執行 Grunt {0, choice, 0#任務|1#任務 |2#任務 }{1} [{2}]
grunt.gruntfile.not.found=未找到 Gruntfile
grunt.rc.arguments.label=實參(&R):
grunt.rc.environmentVariables.label=環境(&E):
grunt.rc.gruntCliPackage.label=軟體套件 grunt-cli (&P):
grunt.rc.gruntfile.browseDialogTitle=選擇 Gruntfile
grunt.rc.gruntfile.label=Gruntfile (&F):
grunt.rc.nodeInterpreter.label=Node 解釋器(&I):
grunt.rc.nodeOptions.label=Node 選項(&O):
grunt.rc.tasks.label=任務(&T):
grunt.task.title=Grunt 任務
grunt.unspecified.gruntfile=未指定 Gruntfile
gulp.before.run.task=執行 gulp 任務
gulp.before.run.task.descr=執行 gulp {0, choice, 0#任務|1#任務 |2#任務 }{1} [{2}]
gulp.gulpfile.not.found=未找到 Gulpfile
gulp.gulpfile.unspecified=未指定 Gulpfile
gulp.rc.arguments.label=實參(&R):
gulp.rc.environmentVariables.label=環境(&E):
gulp.rc.gulpPackage.label=Gulp 軟體套件(&G):
gulp.rc.gulpfile.browseDialogTitle=選擇 gulpfile.js
gulp.rc.gulpfile.label=Gulpfile (&F):
gulp.rc.nodeInterpreter.label=Node 解釋器(&I):
gulp.rc.nodeOptions.label=Node 選項(&O):
gulp.rc.tasks.label=任務(&T):
gulp.task.title=Gulp 任務
header.declarations.to.be.refactored=要重構的宣告
icon.icons.nodes.readonlyMark.tooltip=唯讀
ignore.unused.option.all=所有
ignore.unused.option.before.used=使用前
ignore.unused.option.none=無
implement.members.abstract=實作 abstract 成員
import.options.find.more.configuration.options=在<a>程式碼樣式</a>中尋找更多組態選項
initialize.fields.intention.visibility=可見性:
inlay.hints.max.one.usage.text={0,choice, 0#無用法|1#顯示用法}
inlay.hints.usages.text={0,choice, 0#無用法|1#1 個用法|2#{0,number} 個用法}
inlay.parameters.angular.show.names.for.all.args=Angular HTML 模板中的命名物件參數。<p style="padding-left: 5px; padding-top: 5px; font-size: 0.85em">注意: 啟用 TypeScript 服務後，請改用 "TypeScript" 組。</p>
inlay.parameters.angular.show.names.for.literal.args=Angular HTML 模板中的字面量參數。<p style="padding-left: 5px; padding-top: 5px; font-size: 0.85em">注意: 啟用 TypeScript 服務後，請改用 "TypeScript" 組。</p>
inlay.parameters.angular.show.names.for.pipes=<a href='https://angular.io/guide/pipes'>Angular HTML 模板中的管道。</a> <p style="padding-left: 5px; padding-top: 5px; font-size: 0.85em">注意: 啟用 TypeScript 服務後，請改用 "TypeScript" 組。</p>
inlay.parameters.js.only.show.names.for.all.args=非字面量實參，例如參照和表達式。
inlay.parameters.js.only.show.names.for.literal.args=字面量實參，例如基元、物件和陣列初始設定式。
inlay.parameters.js.only.show.names.for.pipes=<a href='https://github.com/tc39/proposal-pipeline-operator'>管道運算符中的參數。</a>
inlay.parameters.js.only.show.names.for.tagged=<a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates'>標記模板中的實參<a>。
inlay.parameters.js.param.hints.show.names.for.all.args=非字面量實參，例如參照和表達式。
inlay.parameters.js.param.hints.show.names.for.tagged=標記模板中的實參。
inlay.parameters.ts.param.hints.show.names.for.literal.args=字面量實參，例如基元、物件和陣列初始設定式。<p style="padding-left: 5px; padding-top: 5px; font-size: 0.85em">注意: 從 TypeScript v4.4 開始，啟用“非字面量實參”時，停用此選項沒有任何效果。</p>
inlay.parameters.vuejs.show.names.for.all.args=非字面量實參。
inlay.parameters.vuejs.show.names.for.filters=<a href='https://v2.vuejs.org/v2/guide/filters.html'>篩選器(Vue 2)。</a>
inlay.parameters.vuejs.show.names.for.literal.args=字面量實參。
inline.cannot.inline.has.supers=無法內聯擴展其他類型的 {0} 
inline.cannot.inline.references.this.type=無法內聯參照 'this' 類型的接口
inline.type.used.in.reference.list=無法在''{0}'' 列表中內聯用法
insert.class.fix.name=新增類別名限定符
insert.new.keyword.fix.name=插入新關鍵字
insert.this.keyword.fix.name=新增 this 限定符
inspection.NodeCoreCodingAssistanceInspection.no.coding.assistance.message=Node.js 的編碼輔助已被停用
inspection.message.installed.version.doesn.t.match.version.range=安裝的版本 {0} 與版本範圍 {1} 不符合
inspection.message.package.installed=未安裝 {0} 軟體套件
inspection.message.package.version.specified=未指定軟體套件版本
inspection.message.reference.includes.files.outside.project=參照包括專案範圍之外的檔案
inspection.message.sm.test.runner.magnitude.assertion.failed.title=斷言失敗
inspection.update.package_json.dependency.action.text=將 ''{0}'' 更新到最新版本 {1}
inspection.update.package_json.dependency.message=有可用的 ''{0}'' 新版本: {1}
intellilang.tagged.literal.expression.border.title=模板標籤
intellilang.tagged.literal.injection.name.label=模式:
intention.category.ecmascript6=JavaScript/ECMAScript 6
intention.category.javascript=JavaScript
intention.category.react=React
intention.category.typescript=TypeScript
intention.family.name.add.required.property=新增所需的屬性
intention.family.name.enable.web.types=啟用 HTMX 支援
intention.family.name.introduce.parameter.properties.for.unused.parameters=轉換為參數屬性
intention.family.name.run.npm.install=執行 'npm install'
intention.family.name.select.in.test.tree=在測試樹中選擇
intention.family.name.suppress.with.ts.ignore=使用 @ts-ignore 禁止
intention.family.name.surround.with.tag=使用標記包圍
intention.name.add.file.to.tsconfig=將檔案 ''{0}'' 新增到 tsconfig.json
intention.name.create.library.with.files.outside.project=使用專案外部的檔案建立庫
intention.name.import.augmentation=匯入擴大 {0}
intention.name.loading.service.fixes=正在載入服務修正…
intention.name.navigate.to=導覽到 {0}
intention.name.run.npm=執行 ''{0}''
intention.name.surround.with.tag=使用 <{0}> 包圍
interface.cannot.be.extracted.from.enum=無法從枚舉中提取接口
interface.cannot.be.extracted.from.type.alias=無法從類型別名中提取接口
interface.template.title=接口
introduce.constant.target.class=目標類別(&A):
introduce.field.class.constructor=類別建構函式(&C)
introduce.field.current.method=當前方法(&M)
introduce.field.declaration=欄位宣告(&D)
introduce.field.initialize.in=初始化位置
introduce.field.type=類型(&T):
introduce.parameter.optional=可選參數(&O)
introduce.parameter.type=類型(&T):
introduce.variable.const=const(&C)
introduce.variable.declaration=變數宣告
introduce.variable.let=let(&L)
introduce.variable.make.constant=設為常數(&C)
introduce.variable.var=var(&V)
introduce.variable.var.of.type=類型的變數(&T):
invalid.field.type.expression=無效欄位類型: ''{0}''
invalid.identifier.value.0=無效關鍵字: ''{0}''
invalid.parameter.type.expression=參數類型 ''{0}'' 無效
invalid.return.type.expression=返回值類型 ''{0}'' 無效
item.already.exists={0} {1} 已存在
javascript.abstract.class.can.not.be.instantiated.message=無法實例化抽象類別
javascript.ambient.declaration.const.should.be.primitive=環境上下文中的 'const' 初始設定式必須是基元字面量或字面量枚舉參照
javascript.ambient.declaration.should.have.no.initializer=環境宣告不應有初始設定式
javascript.argument.type.mismatch=實參類型 {1} 不可分配給參數類型 {0}
javascript.argument.types.mismatch=實參類型與參數不符合
javascript.assign.parameter.to.field.intention.name=分配參數 ''{0}'' 給欄位
javascript.assigned.expression.type.mismatch=分配的表達式類型 {1} 不可分配給類型 {0}
javascript.assume.uppercase.functions.to.be.constructors=假設只有大寫的函式是建構函式
javascript.auto.import.options.add.imports.on.the.fly=動態明確 import
javascript.auto.import.options.add.on.code.completion=程式碼補全時
javascript.auto.import.options.show.popup=包含自動匯入工具提示
javascript.cannot.return.expression.from.function.with.void.result.type=無法從結果類型為 void 的函式返回值
javascript.cannot.return.expression.from.function.with.void.result.type.fix=移除返回值
javascript.change.jsdoc.type.family.name=更改 JSDoc 中元素的類型
javascript.change.language.level.family=更改 JavaScript 語言版本
javascript.change.language.level.message=更改 JavaScript 語言版本為 {0}
javascript.change.signature.invalid.function.name.0=無效函式名稱: ''{0}''
javascript.change.signature.invalid.parameter.declaration=無效參數: ''{0}''
javascript.changeSignature.call.value.not.allowed=參數 ''{0}'' 不允許使用預設值。因為沒有為前面的參數指定它。
javascript.changeSignature.no.call.value=新的必選參數 ''{0}'' 已新增。\\n指定要用於此方法的所有現有呼叫的預設值。
javascript.check.global.definitions=檢查全域作用域內的指派
javascript.completion.several.definitions=(多個定義)
javascript.constructor.call.without.new.message=不帶 <code>new</code> 的建構函式呼叫
javascript.constructor.with.lower.case.name.used.message=建構函式名稱通常以大寫字母開頭。拼寫錯誤?
javascript.create.class.intention.name=建立類別 ''{0}''
javascript.create.constant.field.intention.name=建立常數欄位 ''{0}''
javascript.create.constant.holding.arrow.function.intention.name=建立含有常數 ''{0}'' 的箭頭函式
javascript.create.constant.intention.name=建立常數 ''{0}''
javascript.create.constructor.intention.name=在 ''{0}'' 類別中建立建構函式
javascript.create.event.handler.intention.name=建立事件處理程序 ''{0}''
javascript.create.field.holding.arrow.function.intention.name=建立含有欄位 ''{0}'' 的箭頭函式
javascript.create.field.intention.name=建立欄位 ''{0}''
javascript.create.function.intention.family=建立 JavaScript 函式或方法
javascript.create.function.intention.name=建立函式 ''{0}''
javascript.create.function.property.intention.name=建立函式屬性 ''{0}''
javascript.create.get.property.intention.name=建立 ''get'' 屬性 ''{0}''
javascript.create.interface.intention.name=建立接口 ''{0}''
javascript.create.method.intention.name=建立方法 ''{0}''
javascript.create.property.holding.arrow.function.intention.name=建立含有屬性 ''{0}'' 的箭頭函式
javascript.create.property.intention.name=建立屬性 ''{0}''
javascript.create.set.property.intention.name=建立 ''set'' 屬性 ''{0}''
javascript.create.variable.holding.arrow.function.intention.name=建立含有變數 ''{0}'' 的箭頭函式
javascript.create.variable.intention.family=建立 JavaScript 變數或屬性
javascript.create.variable.intention.name=建立變數 ''{0}''
javascript.declare.variable.in.previous.var.statement.intention.family=將 var 宣告插入之前的 var 語句
javascript.declare.variable.in.previous.var.statement.intention.name=將 ''{0}'' 的 var 宣告插入之前的 var 語句
javascript.declare.variable.intention.family.name=插入 var 宣告
javascript.declare.variable.intention.name=為 ''{1}'' 插入 {0} 宣告
javascript.deprecated.symbol.replace.fix=將棄用的程式碼取代為 {0}
javascript.deprecated.symbol.replace.fix.family=將棄用的程式碼取代為建議的取代
javascript.deprecated.symbol.used.name.message=使用了棄用的符號，請查閱文檔，以獲取更好的替代性 #loc
javascript.deprecated.symbol.used.name.message2=自版本 {0} 符號被標記為棄用以來，使用 {1} 作為取代用 #loc
javascript.destructuring.initializer=初始設定式 {0}
javascript.destructuring.variable.only=僅解構變數
javascript.element.default.instead.named=使用了預設匯入而不是命名匯入
javascript.element.is.not.accessible.message=元素不可存取 #loc
javascript.element.need.to.be.exported=未匯出元素
javascript.element.need.to.be.imported=未匯入元素
javascript.element.need.to.be.included.to.config=tsconfig.json 中不包含相應檔案
javascript.equality.comparison.with.coercion.display.name=相等運算符可能導致類型強制
javascript.equality.comparison.with.coercion.error.string=比較 #ref 可能導致意外類型強制 #loc
javascript.equality.comparison.with.coercion.family.name=取代但不進行類型強制
javascript.equality.comparison.with.coercion.fix=取代為 ''{0}''
javascript.equality.comparison.with.coercion.option.always=所有
javascript.equality.comparison.with.coercion.option.always.except.null=與 null 或 typeof 比較時除外
javascript.equality.comparison.with.coercion.option.only.suspicious=僅可疑表達式
javascript.equality.comparison.with.coercion.options.label=醒目提示顯示 '==' 和 '!=' 的用法:
javascript.expected.class.or.descendant=應為類別 {0} 或後代
javascript.export.only.member=元素僅匯出
javascript.expression.type.implicitly.coerced.to.unrelated.type=表達式類型 {1} 隱式強制為不相關類型 {0}
javascript.extract.method.title=提取函式
javascript.falsy.typeof.guard=''typeof'' 檢查始終為 false: {0}'' 始終具有類型 ''{1}''
javascript.find.usages.destructuring.target.dialog=速記解構變數使用 {0} 初始化。\\n您想尋找哪些用法?
javascript.fix.add.enum.values=新增枚舉值
javascript.fix.add.override.modifier=新增覆寫修飾符
javascript.fix.add.string.enum.values=新增字串枚舉值
javascript.fix.change.parameter.type=參數 ''{0}'' 類型更改為 ''{1}''
javascript.fix.change.type=''{0}'' 類型更改為 ''{1}''
javascript.fix.create.constructor.invoke.super=建立符合 super 的建構函式
javascript.fix.create.extends=使 ''{0}'' 擴展 ''{1}''
javascript.fix.create.implements=使 ''{0}'' 實作 ''{1}''
javascript.fix.create.inheritor.family=從 super 類型繼承
javascript.fix.create.invoke.super=插入超類別建構函式呼叫
javascript.fix.create.parameter=建立參數 ''{0}''
javascript.fix.generate.argument.stubs=生成實參存根
javascript.fix.implement=實作 {0}
javascript.fix.implement.chooser.all=所有類別
javascript.fix.implement.chooser.title=從中實作成員
javascript.fix.implement.family=在派生類別中實作
javascript.fix.implement.members=實作成員
javascript.fix.implement.methods=實作方法
javascript.fix.initialize.parameter=初始化參數
javascript.fix.message.change.parameters.to.expected=將這些參數更改為預期參數
javascript.fix.message.change.return.type.to.expected=將返回值類型更改為預期類型
javascript.fix.optimize.imports=最佳化 import
javascript.fix.property.spelling.family=修復屬性名稱中可能的拼寫錯誤
javascript.fix.property.spelling.text=將拼寫調整為 ''{0}''
javascript.fix.remove.abstract.keyword=移除 'abstract' 修飾符
javascript.fix.remove.access.modifier=移除存取修飾符
javascript.fix.remove.circular.dependency=移除迴圈相依關係
javascript.fix.remove.comma=移除逗號
javascript.fix.remove.constructor=移除建構函式
javascript.fix.remove.default=移除預設子句
javascript.fix.remove.dynamic.modifier=移除動態修飾符
javascript.fix.remove.externally.visible.symbol=移除外部可見符號
javascript.fix.remove.final.modifier=移除 final 修飾符
javascript.fix.remove.initializer=移除初始設定式
javascript.fix.remove.modifier=移除修飾符
javascript.fix.remove.namespace.reference=移除命名空間參照
javascript.fix.remove.override.modifier=移除覆寫修飾符
javascript.fix.remove.parameter=移除參數
javascript.fix.remove.parameters=移除參數
javascript.fix.remove.setter.parameter.initializer=移除參數預設值
javascript.fix.remove.static.modifier=移除 static 修飾符
javascript.fix.remove.type.reference=移除類型參照
javascript.fix.remove.virtual.modifier=移除虛擬修飾符
javascript.fix.remove.visibility.modifier=移除可見性修飾符
javascript.fix.set.element.visibility=將 {0} 設為 {1}
javascript.fix.set.method.return.type=使 ''{0}'' 返回 ''{1}''
javascript.fix.visibility.family=修復可見性問題
javascript.formatting.options.panel.comments=註釋
javascript.formatting.options.panel.naming.conventions=命名約定
javascript.formatting.web.spacing.within.group=內部
javascript.formatting.web.spacing.within.interpolations=插值
javascript.formatting.web.wrapping.interpolations=插值
javascript.formatting.web.wrapping.new-line-after-start-delimiter=在 '{{' 後換行
javascript.formatting.web.wrapping.new-line-before-end-delimiter='}}' 前新起一行
javascript.ignore.unused.catch.parameters=忽略未使用的 catch 參數
javascript.ignore.unused.function.parameters=忽略未使用的參數:
javascript.illegal.variable.type.void=非法變數類型: 'void'
javascript.implement.all.interfaces=實作所有成員
javascript.implement.members.abstract=實作 abstract 成員
javascript.implement.required.interfaces=實作所需的所有成員
javascript.import.options.use.resource.root=使用相對於專案、資源或來源根目錄的路徑
javascript.incorrect.array.type.in.for-in=陣列鍵類型應為字串
javascript.incorrect.variable.type.mismatch=變數類型 {1} 不可分配給類型 {0}
javascript.indexed.property.instead.of.computed.name=索引屬性存取中括號位於單獨的行中。是否應為計算的名稱?
javascript.initializer.type.mismatch=初始設定式類型 {1} 不可分配給變數類型 {0}
javascript.inline.element.is.not.used={0} 從未使用
javascript.insert.cast.fix=插入轉換
javascript.insert.generic.wrapper.fix.family.name=使用泛型類型包裝
javascript.insert.primitive.wrapper.fix.family.name=使用基元類型包裝
javascript.insert.symbol.fix=插入{0}
javascript.insert.wrapper.fix.text=使用 ''{0}'' 包裝
javascript.instance.member.is.not.accessible.message=執行個體成員不可存取 #loc
javascript.intention.add.default.export.family.name=新增預設匯出
javascript.intention.add.export.family.name=新增匯出
javascript.intention.add.export.fix.text=將 {0} 匯出在檔案 {1} 中
javascript.intention.add.template.argument=插入模板字串實參
javascript.intention.call.chain.to.pipe=將嵌套呼叫取代為管道表達式
javascript.intention.code.optimizations.text=正在最佳化生成的程式碼
javascript.intention.create.getter=為 ''{0}'' 建立 getter
javascript.intention.create.getter.desc=建立 getter
javascript.intention.create.getter.setter=為 ''{0}'' 建立 getter 和 setter
javascript.intention.create.getter.setter.desc=建立 getter 和 setter
javascript.intention.create.setter=為 ''{0}'' 建立 setter
javascript.intention.create.setter.desc=建立 setter
javascript.intention.expand.nullish.coalescing=展開 null 合併
javascript.intention.expand.opt.chain=展開可選連結
javascript.intention.expand.opt.chain.and.nullish.coalescing=展開可選連結和 null 合併
javascript.intention.expand.opt.chain.and.or.coalescing=展開可選連結並使用 ?: 運算符
javascript.intention.expand.opt.chain.family=將可選連結或 null 合併擴展到顯式檢查
javascript.intention.expand.or.coalescing=使用 ?: 運算符
javascript.intention.explicit.fields=宣告顯式類別欄位
javascript.intention.explicit.fields.dialog.title=選擇要顯式宣告的欄位
javascript.intention.explicit.fields.single=宣告顯式類別欄位
javascript.intention.init.fields=從參數初始化新字段
javascript.intention.init.fields.dialog.title=選擇參數以初始化欄位
javascript.intention.opt.chain.chain.and.coalesce=使用可選連結和 null 合併
javascript.intention.opt.chain.chain.only=使用可選連結
javascript.intention.opt.chain.coalesce.only=使用 null 合併
javascript.intention.opt.chain.conditional.only=使用 '||'
javascript.intention.opt.chain.family=使用可選連結或 null 合併
javascript.intention.pipe.to.call.chain=將管道表達式取代為嵌套呼叫
javascript.intention.promise.to.async.name=轉換為異步函式
javascript.intention.remove.export.family.name=移除匯出
javascript.intention.remove.export.inaccessible.conflict.text={0} 在 {1} 中進行了使用
javascript.interface.can.not.be.instantiated.message=無法實例化接口
javascript.introduce.breaks.operator.precedence=無法呼叫重構。\\n通過引入將更改表達式中的運算符優先級。
javascript.introduce.constant.error.expression.has.void.type=無法引入常數。\\n選定的表達式類型無效。
javascript.introduce.constant.error.no.expression.selected=無法引入常數。\\n選定內容不構成表達式。
javascript.introduce.constant.error.not.constant.expression.selected=無法引入常數。\\n選定內容不是常數表達式。
javascript.introduce.constant.in.es5=無法呼叫重構。\\n無法在 ECMAScript 3 或 ECMAScript 5 程式碼中引入常數。
javascript.introduce.constant.title=引入常數
javascript.introduce.element.already.exists=作用域中已存在同名的 {0}。
javascript.introduce.field.before.super.call=無法引入欄位。\\n在"super"呼叫前無法存取"this"。
javascript.introduce.field.constructor=建構函式
javascript.introduce.field.current.method=當前方法
javascript.introduce.field.error.expression.has.void.type=無法引入變數。\\n選定的表達式類型無效。
javascript.introduce.field.error.no.enclosing.class=無法引入欄位。\\n沒有封閉類別。
javascript.introduce.field.error.no.expression.selected=無法引入欄位。\\n選定內容不構成表達式。
javascript.introduce.field.field.declaration=欄位宣告
javascript.introduce.field.initialize.in.scope=初始化位置(&I):
javascript.introduce.field.keyboard.hint=按 {0} 用於鍵盤快捷鍵
javascript.introduce.field.make.readonly=設為唯讀(&R)
javascript.introduce.field.title=引入欄位
javascript.introduce.field.visibility=可見性(&V):
javascript.introduce.in.embedded.expression=無法呼叫重構。\\n無法在嵌入式表達式中引入
javascript.introduce.incorrect.context=無法引入變數。\\n選定內容包含對"this"的參照
javascript.introduce.parameter.error.expression.has.void.type=無法引入參數。\\n選定的表達式類型無效。
javascript.introduce.parameter.error.no.containing.function=無法引入參數。\\n找不到要使用的包含函式。
javascript.introduce.parameter.error.no.expression.selected=無法引入參數。\\n選定內容不構成表達式。
javascript.introduce.parameter.error.not.async.context=無法為包含 'await' 的表達式引入參數。\\n並非所有用法都包含在異步函式中
javascript.introduce.parameter.error.target.not.async=無法為包含 'await' 的表達式引入參數。\\n目標函式不是異步函式
javascript.introduce.parameter.error.yield=無法為包含 'yield 的表達式引入參數。
javascript.introduce.parameter.generate.jsdoc=生成 JSDoc
javascript.introduce.parameter.introduced.variable.value=值(&V):
javascript.introduce.parameter.optional.parameter=可選參數
javascript.introduce.parameter.title=提取參數
javascript.introduce.throw.expressions.unsupported=無法呼叫重構。\\n“提取”重構中當前不支持 throw 表達式。
javascript.introduce.variable.arrow.await.referenced=無法引入。\\n選定內容包含 await 表達式
javascript.introduce.variable.arrow.function.parameter.referenced=無法引入。\\n選定內容包含對箭頭函式參數的參照
javascript.introduce.variable.error.expression.has.void.type=無法引入變數。\\n選定的表達式類型無效。
javascript.introduce.variable.error.no.expression.selected=無法引入變數。\\n選定內容不構成表達式。
javascript.introduce.variable.invalid.name=請輸入有效名稱。
javascript.introduce.variable.make.constant=設為常數
javascript.introduce.variable.name.prompt=名稱(&N):
javascript.introduce.variable.replace.all.occurrences=取代所有符合項(找到 {0} 個匹配項)(&A)
javascript.introduce.variable.title=提取變數
javascript.introduce.variable.title.local=引入區域變數
javascript.introduce.variable.xml.embedded=無法在嵌入式表達式中引入變數
javascript.invalid.delete.target.message=刪除運算符目標無效，應為欄位參照
javascript.invalid.extended.unicode.escape=擴展的 Unicode 轉義僅允許介於 0x0 和 0x10FFFF 之間的值
javascript.invalid.invoker.target=無效呼叫目標
javascript.invalid.number.of.parameters=實參數量無效，應為 {0} 個
javascript.jsdoc.private.member.is.not.accessible.message=private 成員不可存取 #loc
javascript.jsdoc.protected.member.is.not.accessible.message=protected 成員不可存取 #loc
javascript.kind.unknown=未知元素
javascript.known.props.only=物件字面量只能指定已知屬性，但以下為額外屬性: {0}
javascript.label.visibility.package_local=internal(&I)
javascript.label.visibility.private=private(&V)
javascript.label.visibility.protected=protected(&O)
javascript.label.visibility.public=公共 (&B)
javascript.language.service.cannot.get.results=無法從語言服務獲得結果
javascript.language.service.cannot.start=無法啟動語言服務程序
javascript.language.service.default.empty.text=無錯誤
javascript.language.service.start.timeout=啟動語言服務程序超時
javascript.language.service.tracking.disabled=錯誤追蹤已停用
javascript.language.service.tracking.is.not.started=服務未啟動
javascript.language.simple.name=JavaScript
javascript.language.term.attribute=特性
javascript.language.term.attribute.value=特性值
javascript.language.term.class=類別
javascript.language.term.const=常數
javascript.language.term.const.field=常數欄位
javascript.language.term.constructor=建構函式
javascript.language.term.decorator=裝飾器
javascript.language.term.default.export=預設匯出
javascript.language.term.definition=定義
javascript.language.term.destructuring.property=解構屬性
javascript.language.term.entity.name=實體名稱
javascript.language.term.enum=枚舉
javascript.language.term.export.specifier=匯出說明符
javascript.language.term.exported.default.binding=已匯出預設綁定
javascript.language.term.external.module.reference=外部模組參照
javascript.language.term.field=欄位
javascript.language.term.file=檔案
javascript.language.term.function=函式
javascript.language.term.import.specifier=匯入說明符
javascript.language.term.import.statement=import 語句
javascript.language.term.imported.default.binding=已匯入預設綁定
javascript.language.term.inner.class=內部類別
javascript.language.term.inner.function=內部函式
javascript.language.term.inner.interface=內部接口
javascript.language.term.interface=接口
javascript.language.term.jsdoc.tag=JSDoc 標記
javascript.language.term.label=標籤
javascript.language.term.local.const=區域常數
javascript.language.term.local.variable=區域變數
javascript.language.term.method=方法
javascript.language.term.module=模組
javascript.language.term.namespace=命名空間
javascript.language.term.namespace.export=命名空間匯出
javascript.language.term.namespace.import=命名空間匯入
javascript.language.term.package=軟體套件
javascript.language.term.parameter=參數
javascript.language.term.property=屬性
javascript.language.term.readonly.field=唯讀欄位
javascript.language.term.shorthand.property=速記屬性
javascript.language.term.tag=標記
javascript.language.term.top.level=頂層
javascript.language.term.type.alias=類型別名
javascript.language.term.type.parameter=類型參數
javascript.language.term.variable=變數
javascript.language.term.xml.tag=xml 標籤
javascript.library.built.in=內建
javascript.linter.action.edit.config=編輯 {0}
javascript.linter.action.edit.property=編輯 {1} 中的 {0}
javascript.linter.action.edit.settings.text={0}設定…
javascript.linter.action.fix.problems.file.text={0}: 修復當前檔案
javascript.linter.action.fix.problems.name=修復 {0} 問題
javascript.linter.action.fix.problems.name.finish=已結束修復 {0} 問題
javascript.linter.action.fix.problems.name.start=已開始修復 {0} 問題
javascript.linter.action.fix.prompt=使用 {0} 重新設定所選檔案的格式?
javascript.linter.configurable.config.autoSearch.title=自動搜尋 (&S)
javascript.linter.configuration.file.title=組態檔案
javascript.linter.error.can.not.find.document=找不到 {0} 的文檔
javascript.linter.error.can.not.find.psi.file=找不到 {0} 的 PSI 檔案
javascript.linter.error.empty.path=路徑為空
javascript.linter.error.failed.to.lint=Lint {0} 失敗
javascript.linter.error.invalid.path.to.package=指定 ''{0}'' 軟體套件的正確路徑
javascript.linter.error.no.path.to.package=指定 ''{0}'' 軟體套件的路徑
javascript.linter.error.no.such.file=沒有此類別檔案
javascript.linter.error.notification.problem.with.reformatting=重新設定 {0} 的格式時出現問題:<br/>{1}
javascript.linter.error.package.not.installed=安裝 ''{0}'' 軟體套件
javascript.linter.error.specify.correct.path.to=指定 {0} 的正確路徑
javascript.linter.import.error.bin.file.not.found=無法 ''{1}'' 軟體套件下找到 ''{0}''
javascript.linter.import.error.entry.point.not.found=無法在 ''{0}'' 軟體套件中找到入口點
javascript.linter.import.error.generic=套用組態檔案中的程式碼樣式規則時出錯，可能是組態檔案無效。
javascript.linter.import.error.package.not.found=找不到 ''{0}'' 軟體套件
javascript.linter.import.error.timeout.processing.configuration.file=處理組態檔案時超時
javascript.linter.import.nothing.to.import={0}: 已套用所有已知規則
javascript.linter.import.notification={0}: 專案程式碼樣式和編輯器設定基於 ''{1}'' 更新。
javascript.linter.import.notification.edit=編輯 ''{0}''
javascript.linter.import.notification.reset=重設
javascript.linter.import.notification.restored=預設程式碼樣式和編輯器設定已還原
javascript.linter.import.notification.rules.applied=套用了以下 {0}: {1}。
javascript.linter.import.translate.config.file.error=無法套用程式碼樣式規則
javascript.linter.import.translate.config.progress.title=套用 {0} 程式碼樣式規則
javascript.linter.intention.family.name.show.details={0}: 顯示詳細資訊
javascript.linter.intention.name.details=詳細資訊
javascript.linter.progress.reformatting.with=正在使用 {0} 重新設定格式…
javascript.linter.radio.button.configuration.file=組態檔案(&C):
javascript.linter.suppress.all.rules.for.file.description=禁止當前檔案的所有 {0} 規則
javascript.linter.suppress.all.rules.for.line.description=禁止當前行的所有 {0} 規則
javascript.linter.suppress.rule.for.file.description=禁止當前檔案的 ''{0}''
javascript.linter.suppress.rule.for.line.description=禁止當前行的 ''{0}''
javascript.linter.suppress.rules.for.file.family.name=對當前檔案禁止
javascript.linter.suppress.rules.for.line.family.name=對當前行禁止
javascript.linter.use.severity.from.config.label=使用組態檔案中的規則嚴重性
javascript.member.from.unopened.namespace.message=未開啟命名空間的成員 #loc
javascript.missed.argument.for.parameter=參數 {0} 缺少實參
javascript.missing.read.property=未解析的讀取屬性 #loc
javascript.missing.write.property=未解析的寫入屬性 #loc
javascript.module.dependencies.empty.got.it.text=<div align='left'>當前檔案或目錄沒有任何相依關係。<br/>請嘗試使用其他檔案或目錄。</div>
javascript.module.dependencies.got.it.text=<div align='left'>此圖顯示所選檔案或目錄具有的模組相依關係。<br/>要檢視多個檔案或目錄的相依關係，請在<i>專案檢視</i><br/>中將其選定，然後從所選專案右鍵選單中選擇<i>圖 – 顯示圖</i>。</div>
javascript.module.dependencies.got.it.title=模組相依關係圖
javascript.mutable.variable.accessible.from.closure=可從閉包存取可變變數
javascript.no.call.signatures=分配的類型不包含呼叫簽名
javascript.not.a.constructor.call.message=不是建構函式呼叫
javascript.object.is.null={0} 為 null
javascript.object.is.null.or.undefined={0} 為 null 或 undefined
javascript.object.is.possibly.null={0} 可能為 null
javascript.object.is.possibly.null.or.undefined={0} 可能為 null 或 undefined
javascript.object.is.possibly.undefined={0} 可能為 undefined
javascript.object.is.undefined={0} 未定義
javascript.object.null.or.undefined.desc=物件為 'null' 或 'undefined'
javascript.octal.literals.are.not.allowed.es5.message=前綴為 '0' 的八進制字面量已過時，不建議使用
javascript.octal.literals.are.not.allowed.es6.message=不允許使用前綴為 '0' 的八進制字面量。改用 '0o' 前綴
javascript.octal.literals.are.not.allowed.in.strict.mode=在嚴格模式下不允許八進制字面量
javascript.octal.literals.warn.always=關於 ES5-程式碼中過時八進制字面量的警告
javascript.octal.sequences.are.not.allowed.message=不允許八進制轉義序列
javascript.potentially.invalid.target.of.indexed.property.access=索引的屬性存取的目標可能無效
javascript.potentially.invalid.usage.of.class.this=通過嵌套函式的 'this.' 對類別欄位的參照存取可能無效
javascript.potentially.invalid.usage.of.this=This 的用法可能無效
javascript.private.constructor.is.not.accessible.message=private 建構函式不可存取 #loc
javascript.private.member.is.not.accessible.message=private 成員不可存取 #loc
javascript.property.is.read.only.message=唯讀屬性 #loc
javascript.property.is.write.only.message=只寫屬性 #loc
javascript.protected.constructor.is.not.accessible.message=protected 建構函式不可存取 #loc
javascript.protected.member.is.not.accessible.message=protected 成員不可存取 #loc
javascript.qualified.class.name.expected=應為限定的類別名
javascript.qualified.name.is.not.imported.message=未匯入限定名稱 #loc
javascript.redundant.typeof.guard=''typeof'' 檢查冗餘: ''{0}'' 始終具有類型 ''{1}''
javascript.refactoring.asdoc.for.abstracts=abstract 的 ASDoc
javascript.refactoring.cannot.find.usages.of.definition.to.inline=找不到要內聯的定義的用法
javascript.refactoring.cannot.inline.ambient.function=無法內聯沒有實作的宣告
javascript.refactoring.cannot.inline.complex.expression.evaluation=無法內聯複雜表達式求值
javascript.refactoring.cannot.inline.constructor=無法內聯建構函式
javascript.refactoring.cannot.inline.destructuring.rest.variable=無法內聯解構 rest 變數
javascript.refactoring.cannot.inline.destructuring.variable.with.default=無法內聯使用預設值的解構變數
javascript.refactoring.cannot.inline.function.defined.in.library=無法內聯外部庫中定義的函式
javascript.refactoring.cannot.inline.function.referencing.arguments=無法內聯參照實參的函式
javascript.refactoring.cannot.inline.function.referencing.rest.parameter=無法內聯函式參照的 rest 參數
javascript.refactoring.cannot.inline.function.with.multiple.returns=無法內聯有多個離開點的函式
javascript.refactoring.cannot.inline.interface.method=無法內聯接口方法
javascript.refactoring.cannot.inline.jsx.usage=無法內聯 JSX 標籤用法
javascript.refactoring.cannot.inline.not.initialized.variable=無法內聯未初始化的變數
javascript.refactoring.cannot.inline.overrided.or.overridden.method=無法內聯參與層次結構的方法
javascript.refactoring.cannot.inline.recursive.function=無法內聯遞迴函式
javascript.refactoring.extract.function.already.exists.in.this.scope=此作用域中已存在 {0}
javascript.refactoring.extract.function.bad.selection=所選塊應代表一組語句或表達式
javascript.refactoring.extract.function.function.used.before.declaring=選定內容包含在宣告之前使用的函式
javascript.refactoring.extract.function.multiple.exit.points=所選程式碼段有多個離開點
javascript.refactoring.extract.function.no.loop.for.break=程式碼段內沒有用於 break 語句的相應迴圈
javascript.refactoring.extract.function.no.loop.for.continue=程式碼段內沒有用於 continue 語句的相應迴圈
javascript.refactoring.extract.function.no.switch.for.break=程式碼段內沒有用於 break 語句的相應 'switch'
javascript.refactoring.extract.function.title=提取函式
javascript.refactoring.extract.function.yield.and.return=所選片段同時包含 yield 表達式和 return 語句
javascript.refactoring.function.to.es6.class.command=將函式 {0} 轉換為類別
javascript.refactoring.function.to.es6.class.defineProperty.warning.text=警告: 將使用“Object.defineProperty”、“Object.defineProperties”或“Object.create”建立的屬性轉換為 ES6 語法可能會影響其可枚舉性和可組態性
javascript.refactoring.inline.all.message=內聯所有參照並移除 {0} ({1}) (&A)
javascript.refactoring.inline.dialog.title=內聯{0}
javascript.refactoring.inline.function.title=內聯函式
javascript.refactoring.inline.this.only=僅內聯此參照並保留 {0}(&K)
javascript.refactoring.inline.variable.title=內聯變數
javascript.refactoring.searching.usages=尋找用法
javascript.refactoring.variable.used.as.lvalue=要內聯的變數在指派的左側使用
javascript.refactoring.variable.value.is.changed.when.accessed.from.closure=從閉包存取時變量值被更改
javascript.rename.choose.target.message=您要重新命名哪一個?
javascript.rename.containing.file.message=是否還要將該檔案重命名為 {0}?\\n{1} 的用法和 import 語句中的檔案路徑將進行相應更新。
javascript.rename.destructuring.target.dialog.title=速記解構變數使用 {0} 初始化
javascript.rename.element.with.related.elements.title=重新命名 {0}
javascript.rename.reference.intention.name=重新命名參照
javascript.rename.related.declaration.message=是否還要重新命名 {0}?\\nimport 語句中的 {0} 用法將進行相應更新。
javascript.rename.shorthand.target.dialog.title=速記屬性使用 {0} 初始化
javascript.rename.shorthand.target.option.both.label=兩者
javascript.rename.shorthand.target.option.property.label=屬性
javascript.rename.symbol.intention.name=重新命名符號
javascript.report.unused.definitions=報告未使用的定義
javascript.report.unused.properties=報告未使用的屬性
javascript.returned.expression.type.mismatch=返回的表達式類型 {1} 不可分配給類型 {0}
javascript.service.is.disabled.in.safe.mode=服務在安全模式下被停用
javascript.service.node.error=Node 解釋器路徑不正確。請檢查解釋器設定
javascript.starting.service=啟動 {0} 服務
javascript.static.member.is.not.accessible.message=static 成員不可存取 #loc
javascript.strictly.check.global.vars=將未宣告的全域符號報告為錯誤
javascript.strictly.check.object.properties=將未宣告的屬性報告為錯誤
javascript.surround.with.cast=Type(expr)
javascript.surround.with.do.while=do / while
javascript.surround.with.for=for
javascript.surround.with.function=函式
javascript.surround.with.function.expression=函式表達式
javascript.surround.with.if=if
javascript.surround.with.if.cond=if (cond)
javascript.surround.with.if.else=if / else
javascript.surround.with.if.else.cond=if (cond) / else
javascript.surround.with.not.parenthesis=!(expr)
javascript.surround.with.object.literal=物件字面量
javascript.surround.with.parenthesis=(expr)
javascript.surround.with.try.catch=try / catch
javascript.surround.with.try.catch.finally=try / catch / finally
javascript.surround.with.try.finally=try / finally
javascript.surround.with.while=while
javascript.surround.with.with=with
javascript.suspicious.type.guard.desc=類型 guard 檢查不健全
javascript.suspicious.typeof.guard=''typeof'' 檢查無效: ''{0}'' 不能具有類型 ''{1}''
javascript.template.context.type=JavaScript(&R)
javascript.term.does.not.evaluate.to.function=方法表達式不是函式類型
javascript.term.does.not.evaluate.to.function.line.break=表達式不可呼叫。如果這不應是呼叫，請檢查是否缺少分號
javascript.term.does.not.evaluate.to.function.nullable=方法表達式可以為 null 或 undefined
javascript.term.does.not.evaluate.to.function2=屬性不能作為函式呼叫
javascript.term.does.not.evaluate.to.function2.fix=移除實參列表
javascript.term.nullable.indexer.qualifier=索引的表達式可以為 null 或 undefined
javascript.type.is.not.assignable.to.type=類型 {1} 不可分配給類型 {0}
javascript.undeclared.variable.name.message=隱式宣告變數 {0} #loc
javascript.unfiltered.for.in.loop=可能迭代意外(自訂/繼承)成員，可能缺少 hasOwnProperty 檢查
javascript.unknown.metadata.attribute=未知元資料特性
javascript.unknown.metadata.tag=未知元資料標籤
javascript.unresolved.circle.definition=匯入的圓定義
javascript.unresolved.file.or.dir=無法解析 {0} {1}
javascript.unresolved.function.name.message=未解析的函式或方法 <code>{0}()</code> #loc
javascript.unresolved.symbol.message=未解析的符號
javascript.unresolved.type.name.message=未解析的類型 {0} #loc
javascript.unresolved.variable.name.message=未解析的變數 {0} #loc
javascript.unresolved.variable.null.or.undefined.qualifier.message=''{0}'' 的限定符可能為 null 或 undefined #loc
javascript.unresolved.variable.null.qualifier.message=''{0}'' 的限定符可能為 null #loc
javascript.unresolved.variable.or.type.name.message=未解析的變數或類型 {0} #loc
javascript.unresolved.variable.or.type.name.message2=未解析的變數或類型 {0}
javascript.unresolved.variable.undefined.qualifier.message=''{0}'' 的限定符可能未定義 #loc
javascript.unused.import.remove=移除未使用的 'import'
javascript.unused.import.remove.specifier=移除未使用的元素
javascript.validate.imports.name=未解析的已匯入名稱
javascript.validation.destructuring.without.initializer=解構宣告必須有初始設定式
javascript.validation.fqn.to.replace.with.import=限定名稱可被取代為 import 語句
javascript.validation.generators.yield.not.assignable.to.return=類型 ''{1}'' 不可分配給類型 ''{0}''
javascript.validation.generators.yield.not.in.generator=只允許在產生器正文中使用 'yield' 表達式。
javascript.validation.generators.yield.not.iterable=表達式類型沒有定義 [Symbol.iterator] 或 [Symbol.asyncIterator]
javascript.validation.initialized.var.in.for.loop=''{0}'' 迴圈中不允許變數初始設定式
javascript.validation.message.abstract.get.accessor.not.implemented=未實作類別 {1} 的 abstract get 存取器 {0}
javascript.validation.message.abstract.method.not.implemented=未實作類別 {1} 中的 abstract 方法 {0}
javascript.validation.message.abstract.set.accessor.not.implemented=未實作類別 {1} 的 abstract set 存取器 {0}
javascript.validation.message.accessor.could.not.be.nested.under.other.function=存取器方法不能嵌套在其他函式中
javascript.validation.message.arguments.is.readonly='arguments' 唯讀
javascript.validation.message.arguments.with.rest.parameter=使用 rest 參數時，'arguments' 物件不可用
javascript.validation.message.assignment.to.const=嘗試分配給常數或唯讀變數
javascript.validation.message.assignment.to.const.fix.remove.readonly=移除唯讀修飾符
javascript.validation.message.assignment.to.const.fix.replace=取代為 let
javascript.validation.message.attribute.was.specified.multiple.times=多次指定修飾符 {0}
javascript.validation.message.base.constructor.in.not.derived=僅允許在派生建構函式中呼叫基類別建構函式
javascript.validation.message.baseMethod.before.super.call=超類別建構函式呼叫前不允許有 'super'
javascript.validation.message.break.without.target=無法確定 'break' 的目標
javascript.validation.message.can.not.override.final.method=無法從{0}覆寫 final 方法
javascript.validation.message.circular.dependency=迴圈相依關係
javascript.validation.message.class.method.incompatible=''{1}'' 類別中的方法 ''{0}'' 不可分配給基類別 ''{2}'' 中的同一方法
javascript.validation.message.class.method.not.implemented=未實作類別 {1} 的方法 {0}
javascript.validation.message.class.name.expected.here=此處應為類別名
javascript.validation.message.class.property.incompatible=''{1}'' 類別中的屬性 ''{0}'' 不可分配給基類別 ''{2}'' 中的同一屬性
javascript.validation.message.class.property.not.implemented=未實作類別 {1} 的屬性 {0}
javascript.validation.message.class.setter.cannot.have.return.type='set' 存取器不能有返回值類型
javascript.validation.message.comma.is.not.allowed.after.last.parameter=最後一個參數後不允許有逗號
javascript.validation.message.comma.is.not.allowed.after.rest.element=rest 元素後不允許有逗號
javascript.validation.message.conflicting.definition.was.found.with.the.same.name=在命名空間 {1} 中發現衝突性的繼承宣告 {0}
javascript.validation.message.const.variable.without.initializer='const' 變數不包含初始設定式。以後無法賦予有意義的值。
javascript.validation.message.constructor.cannot.be.static=建構函式不能為 static
javascript.validation.message.constructor.cannot.have.custom.visibility=建構函式應為 public 或未指定可見性
javascript.validation.message.constructor.field.not.allowed=類別可能沒有名為 'constructor' 的非 static 欄位
javascript.validation.message.continue.outside.loop='continue' 在迴圈語句外部
javascript.validation.message.continue.without.target=無法確定 'continue' 的目標
javascript.validation.message.duplicate.catch.block=重複 catch 塊 #loc
javascript.validation.message.duplicate.catch.block.fix=移除重複的 catch 塊
javascript.validation.message.duplicate.declaration=重複宣告
javascript.validation.message.duplicate.declaration.fix.remove=移除類型
javascript.validation.message.duplicate.declaration.fix.text=導覽到上一個宣告 ''{0}''
javascript.validation.message.duplicate.declaration.fix.text.no.name=導覽到上一個宣告
javascript.validation.message.duplicate.default.export.declaration=一個模組不能有多個預設匯出
javascript.validation.message.duplicate.default.export.in.module=預設匯出只能在 ECMAScript-style 模組中使用
javascript.validation.message.duplicate.export.declaration=匯出宣告與已匯出的宣告 ''{0}'' 相衝突
javascript.validation.message.duplicate.label=重複標籤
javascript.validation.message.dynamic.can.be.applied.to.class=動態特性只能應用於類別宣告
javascript.validation.message.es5.function.declarations.allowed.on.top.level.or.function=禁止在程序或函式的頂層使用函式語句
javascript.validation.message.eval.cannot.be.assigned=不能在嚴格模式下分配 'eval'
javascript.validation.message.extend.final.class=無法擴展 final 類別 ''{0}''
javascript.validation.message.extend.multiple.classes=類別不能擴展多個類別
javascript.validation.message.final.modifier.allowed.only.for.methods=final 修飾符只能應用於類別和類別方法
javascript.validation.message.flowjs.path=Flow 路徑不正確
javascript.validation.message.for.await.no.async.context='for await' 只能在 'async' 函式中使用
javascript.validation.message.for.await.top.level=使用了頂層 'for await'
javascript.validation.message.function.method.invalid.overridden.parameter.type=不相容覆寫，應有類型 ''{0}''
javascript.validation.message.function.override.for.interface=對 {0} 中的方法進行了不相容的覆寫
javascript.validation.message.function.override.for.object.method=從 Object 繼承的方法無需覆寫
javascript.validation.message.function.override.incompatible.access.modifier=不相容覆寫，應有 ''{0}'' 存取修飾符
javascript.validation.message.function.override.incompatible.signature=不相容覆寫，應有簽名 ''{0}''
javascript.validation.message.function.override.incompatible.signature.generic=不相容覆寫
javascript.validation.message.function.override.incompatible.signature2=不相容覆寫，應有返回值類型 ''{0}''
javascript.validation.message.function.override.incompatible.signature3=不相容覆寫，應有種類 ''{0}''
javascript.validation.message.function.override.without.override.modifier=方法重寫了沒有 override 關鍵字的超類別 {0} 中的方法
javascript.validation.message.function.override.without.parent.method=方法不覆寫超類別的方法
javascript.validation.message.get.method.should.be.valid.type=getter 定義的返回值類型不應為 {0}
javascript.validation.message.get.method.should.have.no.parameter=getter 定義不得有形參
javascript.validation.message.get.method.type.is.different.from.setter=Get 存取器方法的類型與 set 存取器類型不相容，應為 ''{0}''
javascript.validation.message.identifier.not.allowed.in.strict.mode=在嚴格模式下不能將 ''{0}'' 用作關鍵字
javascript.validation.message.implements.for.interface.not.allowed=接口不允許有實作列表
javascript.validation.message.implements.is.not.allowed=標準 ECMAScript 中不允許有實作子句
javascript.validation.message.incompatible.override=對 {0} 中的成員進行了不相容的覆寫
javascript.validation.message.index.no.type=索引簽名參數必須具有類型註解
javascript.validation.message.index.wrong.type=索引簽名參數類型必須可以分配給 'string | number | symbol'
javascript.validation.message.interface.call.signature.not.implemented=未實作接口 {0} 的呼叫簽名
javascript.validation.message.interface.cannot.be.final.modifiers=接口不能為最終
javascript.validation.message.interface.get.accessor.not.implemented=未實作接口 {1} 的屬性 get 存取器 {0}
javascript.validation.message.interface.index.signature.not.implemented=未實作接口 {0} 的索引簽名
javascript.validation.message.interface.members.cannot.be.final.modifiers=接口成員不能為最終
javascript.validation.message.interface.members.cannot.have.access.modifiers=接口成員不能具有存取修飾符
javascript.validation.message.interface.members.cannot.have.namespace.attributes=接口成員不能具有命名空間特性
javascript.validation.message.interface.method.invalid.access.modifier=不相容實作，應有 'public' 存取修飾符
javascript.validation.message.interface.method.invalid.signature=不相容實作，應有簽名 ''{0}''
javascript.validation.message.interface.method.invalid.signature2=不相容實作，應有返回值類型 ''{0}''
javascript.validation.message.interface.method.invalid.signature3=不相容實作，應有 get / set ''{0}''
javascript.validation.message.interface.method.not.implemented=未實作來自接口 {1} 的方法 {0}
javascript.validation.message.interface.name.expected.here=此處應為接口名稱
javascript.validation.message.interface.property.not.implemented=未實作接口 {1} 的屬性 {0}
javascript.validation.message.interface.set.accessor.not.implemented=未實作接口 {1} 的屬性 set 存取器 {0}
javascript.validation.message.jsdoc.types.are.used=JSDoc 類型只能在文檔註釋內部使用
javascript.validation.message.missed.super.constructor.call=缺少超類別建構函式呼叫
javascript.validation.message.missing.catch.or.finally=缺少 catch 或 finally 子句
javascript.validation.message.must.be.lvalue={0} 中的左側無效
javascript.validation.message.nested.classes.are.not.allowed=不允許嵌套類別
javascript.validation.message.one.visibility.modifier.allowed=只允許一個可見性修飾符(public、protected、internal、private)
javascript.validation.message.only.one.default.is.allowed=\\ switch 中只允許一個預設子句
javascript.validation.message.override.can.be.applied.to.method=覆寫只能應用於函式宣告
javascript.validation.message.parameter.is.not.allowed.after.rest.parameter=rest 參數後不允許有任何參數
javascript.validation.message.parameter.non.optional.after.optional=必選參數不能位於可選參數後
javascript.validation.message.parameter.rest.optional=rest 參數不能是可選參數
javascript.validation.message.parameter.should.be.initialized=應初始化參數
javascript.validation.message.redeclaration.of.block.scope=不能重複宣告塊作用域變數
javascript.validation.message.redeclaration.of.block.scope.in.scope.of.var=塊作用域變數不能與同一塊作用域中的"var"變數或參數使用相同的名稱
javascript.validation.message.redeclaration.of.var.in.scope.of.block.scope="var" 變數不能與其可見性作用域內的塊作用域變數使用相同的名稱
javascript.validation.message.redefining.is.not.allowed=不允許重新定義 {0}
javascript.validation.message.redundant.type=顯式類型實參 {0} 可被取代為 {1}
javascript.validation.message.redundant.type.remove=可以移除顯式類型實參 {0}
javascript.validation.message.referencing.arguments.caller.callee.is.not.allowed=不允許從實參中參照 'caller' 和 'callee'
javascript.validation.message.referencing.function.arguments.property.is.not.allowed=不允許參照 'arguments' 函式屬性
javascript.validation.message.remove.unneeded.comma.fix=移除不需要的逗號
javascript.validation.message.rest.parameter.should.not.be.initialized=不應初始化 Rest 參數
javascript.validation.message.return.outside.function.definition='return' 在函式定義外部
javascript.validation.message.return.statement.required=非無效返回值類型必需具備 return 語句
javascript.validation.message.return.value.of.type.is.required=必需具備類型 {0} 的返回值
javascript.validation.message.set.method.should.be.void.or.without.type=setter 定義的返回值類型必須為未指定或無效
javascript.validation.message.set.method.should.have.one.parameter=setter 定義必須正好有一個參數
javascript.validation.message.set.method.type.is.different.from.getter=set 存取器方法的類型與 get 存取器類型不相容，應為 ''{0}''
javascript.validation.message.setter.parameter.cannot.have.initializer=Setter 定義不能具有可選參數
javascript.validation.message.static.method.cannot.be.final=靜態方法不能為最終
javascript.validation.message.static.modifier.is.allowed.only.for.class.members=僅允許類別成員使用 static 修飾符
javascript.validation.message.super.constructor.call.should.be.in.constructor=超類別建構函式呼叫應位於建構函式本體中
javascript.validation.message.super.referenced.from.static.context=在 static 上下文中參照了 'super'
javascript.validation.message.super.referenced.without.class.instance.context=在沒有類別執行個體上下文的情況下參照了'super'
javascript.validation.message.this.before.super.call=超類別建構函式呼叫前不允許有 'this'
javascript.validation.message.this.referenced.from.static.context=在 static 上下文中參照了 'this'
javascript.validation.message.unexpected.type.for.rest.parameter=Rest 參數不應有類型
javascript.validation.message.unknown.metadata.annotation.used=使用了未知的元資料特性
javascript.validation.message.unneeded.comma=不需要的逗號
javascript.validation.message.unresolved.component=未解析的元件 {0}
javascript.validation.message.use.namespace.reference.or.access.modifier=使用命名空間或存取修飾符
javascript.validation.multiple.var.in.for.loop=''{0}'' 迴圈中只允許一個變數
javascript.validation.new.target.not.in.function=僅允許函式宣告、函式表達式或建構函式的本體中有元屬性 'new.target'
javascript.validation.unused.import=未使用的 import
javascript.vector.literal.element.type.mismatch=矢量字面量元素類型 {1} 不可分配給類型 {0}
javascript.visibility.internal=internal
javascript.visibility.private=private
javascript.visibility.protected=protected
javascript.visibility.public=public
javascript.with.clause.assert.deprecated.message=import 特性的 'assert' 關鍵字已棄用。請改用 'with' 語法。
javascript.with.statement.is.not.allowed.in.strict.mode.message=嚴格模式下不允許使用 With 語句
jest.cannot.find.bin.file.for.package.dialog.message=找不到 ''{0}'' 軟體套件的 bin 檔案
jest.coverage.cannot.find.lcov.info.notification.content=無法顯示 Jest 覆蓋率: 找不到 {0}。
jest.coverage.directory.not.found.notification.content=無法從 Jest 組態中讀取 coverageDirectory 選項
jest.coverage.notification.title=Jest 覆蓋率
jest.go.to.snapshot.text=轉到 ''{0}'' 快照
jest.package.placeholder.text=軟體套件目錄的路徑，可選擇 jest、react-scripts 或 react-scripts 替代項
jest.rc.configurationFile.label=組態檔案(&C):
jest.rc.configurationFile.title=選擇 Jest 組態檔案
jest.rc.jestOptions.emptyText=CLI 選項，例如 --watch 或 --env=jsdom
jest.rc.jestOptions.label=Jest 選項:
jest.rc.jestPackageField.label=Jest 軟體套件(&J):
jest.snapshot.label=Jest 快照
jest.snapshot.update.all.tests.text=<link>點擊以更新所有失敗的快照</link>
jest.snapshot.update.rc.name=更新 {0} 的快照
jest.snapshot.update.single.test.text=<link>點擊以更新 ''{0}'' 的快照</link>
jest.snapshot.update.test.file.text=<link>點擊以更新 {0} 中失敗的快照</link>
jquery.documentation.not.found=找不到 jQuery 文檔
js.accessibility.check.inspection.name=已參照無法存取的 @private 和 @protected 成員
js.add.braces.to.arrow.function=向箭頭函式中新增大括號
js.add.members.to.type=將成員 {0} 新增到 ''{1}''
js.add.members.to.type.desc=將成員新增到類別或接口
js.add.then.fix=新增 '.then()'
js.align.multiline.extends.list=多行時對齊
js.align.properties.none=不對齊
js.align.properties.on.colon=冒號上
js.align.properties.on.value=值上
js.annotator.assignment.pattern.rhs=指派模式必須位於指派的左側
js.annotator.inspection.name=未遵循 ECMAScript 規範
js.annotator.newline.before.arrow=箭頭前不允許換行符
js.annotator.replace.with.fat.arrow=取代為粗箭頭
js.annotator.rest.element.must.be.last=rest 元素必須位於最後
js.annotator.thin.arrow.used=使用了細箭頭
js.annotator.unary.operator.within.exponential=一元運算符 ''{0}'' 不允許直接位於指數表達式之前。建議新增括號以解決歧義問題。
js.annotator.yield.cannot.be.used.inside.generator='yield' 不能用作產生器內部的關鍵字
js.anonymous.to.named.function=匿名函式轉換為命名函式
js.arrangement.group.arrow.fields.with.methods=使用包含方法的箭頭函式初始化的組欄位
js.array.new.line.after.left.bracket=在 '[' 後換行
js.array.new.line.before.right.bracket=將 ']' 置於新行中
js.arrow.function.braces.can.be.removed.fix.family.name=移除箭頭函式體周圍的大括號
js.arrow.function.braces.can.be.removed.key=箭頭函式體周圍的大括號冗餘
js.arrow.function.braces.can.be.removed.problem.description=可以移除箭頭函式體周圍的大括號
js.assigning.to.primitive.type.property=賦給基元的值將丟失
js.assignment.issues.group.name=指派問題
js.assignment.used.as.condition.fix=將 ''='' 取代為 ''{0}''
js.assignment.used.as.condition.name=用作條件的指派
js.assignment.used.as.condition.text=<code>#ref</code> 作為條件使用
js.await-using.in.synchronous.function='await using' 指令只能在 'async' 函式中使用
js.await.in.synchronous.function='await' 運算符只能在 'async' 函式中使用
js.await.promise.double.await.inspection=冗餘 'await await'
js.await.promise.reject.inspection=冗餘 'await Promise.reject()'
js.await.promise.resolve.fix=取代為 ''{0}''
js.await.promise.resolve.inspection=冗餘 'await Promise.resolve()'
js.await.promise.return.await.inspection=冗餘 'return await'
js.await.promise.trivial.await.inspection=非 promise 類型的冗餘 'await'
js.bitwise.operator.usage.name=按位運算符用法
js.bitwise.operator.usage.popup=使用了按位運算符
js.bitwise.operator.usage.quickfix=取代為 {0}
js.blank.lines.around.function=Around 函式:
js.blank.lines.around.method=方法周圍:
js.breadcrumbs.callback.for=\\ {0}({1}) 回調
js.chained.call.dot.on.next.line='.' 在新行
js.check.function.signature.guess.optionality=將非類型化參數視為必選
js.check.function.signature.guess.optionality.hint=如果停用，則所有未鍵入的參數均視為可選參數
js.checkbox.make.readonly=設為唯讀(&R)
js.class.context.type=類別/接口
js.class.member.expression.context.type=類別成員表達式
js.class.member.initialization.inspection.name=在 static 初始設定式中使用可能未分配的屬性
js.class.member.initialization.inspection.text=欄位 ''{1}'' 在 ''{0}'' 之後宣告，並且可能尚未分配
js.class.member.initialization.inspection.text.id=欄位 ''{0}'' 參照本身
js.class.member.statement.context.type=類別成員語句
js.closure.compiler.syntax.cyclic.inheritance=涉及 {0} 的迴圈繼承
js.closure.compiler.syntax.empty.type=空類型不可用
js.closure.compiler.syntax.implements.not.interface={0} 未用 @interface 進行註解
js.closure.compiler.syntax.inspection.name=JSDoc 標記不正確的用法
js.closure.compiler.syntax.invalid.type=類型語法無效
js.code.style.align.caption=對齊
js.code.style.align.from.clause.caption=對齊 'from' 子句
js.code.style.align.var.statements=當多行時
js.code.style.align.var.statements.and.assignments=分組時
js.code.style.array.group.name=陣列
js.code.style.do.not.align.var.statement=不對齊
js.code.style.file.name.camel.style=駝峰命名法 (appComponent)
js.code.style.file.name.lisp.style=中線命名法 (app-component)
js.code.style.file.name.mixed.style=帶後綴的中線命名法 (my-app.component)
js.code.style.file.name.pascal.style=帕斯卡命名法 (AppComponent)
js.code.style.file.name.relaxed.style=重用當前檔案的 case
js.code.style.file.name.snake.style=蛇形命名法 (app_component)
js.code.style.issues.group.name=程式碼樣式問題
js.code.style.object.literals.category.name=物件
js.code.style.punctuation.tab.title=標點
js.code.style.tab.name=JavaScript
js.code.vision.component.usages=元件用法
js.code.vision.component.usages.action=顯示元件用法
js.code.vision.component.usages.description=用於呼叫元件的“尋找用法”的可點擊提示。
js.code.vision.component.usages.tooltip=點擊檢視該元件的用法
js.command.name.auto-import-symbols=自動匯入外部符號
js.commandline.configure.language.version=為專案組態 JavaScript 語言版本
js.commandline.configure.nodejs=組態 NodeJS 解釋器並為 package.json 檔案安裝軟體套件
js.comment.matches.signature.inspection.name=不符合的 JSDoc 和函式簽名
js.comment.matches.signature.inspection.problem1=JSDoc 中未描述參數 {0}
js.comment.matches.signature.inspection.problem2=JSDoc 中描述的參數 {0} 未出現在函式簽名中
js.comment.matches.signature.inspection.quickfix=更新 JSDoc 註釋
js.comparison.with.nan.inspection.name=與 NaN 比較
js.comparison.with.nan.inspection.problem=與 NaN 的相等比較的求值結果始終為 false
js.comparison.with.nan.inspection.problem2=與 NaN 的不等比較的求值結果始終為 true
js.comparison.with.nan.inspection.quickfix=取代為 {0}isNaN(…)
js.component.usage.in.template.group.display.name=模板中的用法
js.component.usage.type.display.name=元件
js.consecutive.commas.in.array.literal.inspection.insert.undefined=插入 'undefined'
js.consecutive.commas.in.array.literal.inspection.message=陣列字面量中的連續逗號
js.consecutive.commas.in.array.literal.inspection.name=陣列字面量中的連續逗號
js.constructor.cant.have.return.type=建構函式不能有返回值類型
js.convert.default.export.to.named.intention.family=將 default export 轉換為命名 export
js.convert.default.export.to.named.intention.working=將 default export 和 import 轉換為命名 export 和 import…
js.convert.for.each.to.for.of.intention.family=將 'forEach' 取代為 'for..of' 迴圈
js.convert.for.each.to.indexed.intention.family=將 'forEach' 取代為索引的 'for' 迴圈
js.convert.for.in.to.for.of.family.name=將 'for..in' 轉換為 'for..of'
js.convert.for.in.to.for.of.inspection.text=使用了 'for..in' 而不是 'for..of'
js.convert.for.in.to.for.of.text=將 'for..in' 轉換為 'for..of'
js.convert.for.of.to.indexed.intention.family=將 'for..of' 取代為索引的 'for' 迴圈
js.convert.indexed.for.to.for.of.family.name=將帶索引的 'for' 轉換為 'for..of'
js.convert.indexed.for.to.for.of.inspection.text=已使用索引的 'for' 而不是 'for..of'
js.convert.indexed.for.to.for.of.text=將帶索引的 'for' 轉換為 'for..of'
js.convert.indexed.for.to.foreach.intention.family=將索引的 'for' 轉換為 'forEach' 呼叫
js.convert.let.to.const.inspection.text=已使用 'let' 而不是 'const'
js.convert.map.to.for.of.intention.family=將 'map' 陣列呼叫取代為 'for..of' 迴圈
js.convert.module.exports.into.es6.export.family.name=轉換為 export
js.convert.module.exports.into.es6.export.inspection.text=使用了 'module.exports' 而不是 'export'
js.convert.module.exports.into.es6.export.text=轉換為 export
js.convert.named.export.to.default.intention.family=將命名 export 轉換為 default export
js.convert.named.export.to.default.intention.working=正在將命名 export 和 import 轉換為 default export 和 import…
js.convert.parameters.to.object.intention.name=將參數轉換為物件
js.convert.parameters.to.object.non.call.usage.will.not.be.updated=不更新非呼叫用法
js.convert.parameters.to.object.usage.will.not.be.updated.for.contextual.type=方法會覆寫另一個方法。不會更新基方法
js.convert.parameters.to.object.usage.will.not.be.updated.for.spread=不會更新使用非終端傳播實參進行的呼叫
js.convert.parameters.to.object.with.interface.intention.name=將參數轉換為物件並引入接口
js.convert.require.into.es6.import.family.name=將 require() 轉換為 import
js.convert.require.into.es6.import.inspection.text=使用了 'require()' 而不是 'import'
js.convert.require.into.es6.import.inspection.withConditional.option=使用“全部修復”動作在內部作用域內轉換 require()
js.convert.require.into.es6.import.inspection.withConditional.option.description=在內部作用域內轉換 require() (例如 'if' 語句或內部函式)
js.convert.require.into.es6.import.text=將 require() 轉換為 import
js.convert.to.anonymous.function=轉換為匿名函式
js.convert.to.anonymous.function.family.name=箭頭函式轉換為匿名函式
js.convert.to.arrow.function=轉換為箭頭函式
js.convert.to.es6.class=轉換為類別
js.convert.to.es6.class.family.name=將函式及其成員宣告轉換為類別
js.convert.to.foreach.intention.name=將 'for-in' 轉換為 'forEach' 呼叫
js.convert.to.named.function=轉換為命名函式
js.convert.to.named.function.to.class.method=轉換為類別方法
js.convert.var.to.const.text=轉換為 const
js.convert.var.to.let.or.const=轉換為 let/const
js.convert.var.to.let.or.const.family.name=將 var 轉換為 let/const
js.convert.var.to.let.or.const.inspection.conservative.option=使用“全部修復”動作保守地轉換 var
js.convert.var.to.let.or.const.inspection.conservative.option.description=在第一次使用變數之前，宣告可能會移至函式器頂部。\\n要在使用“全部修復”動作時停用此行為，請選中“保守轉換 var”選項。
js.convert.var.to.let.or.const.inspection.text=已使用 'var' 而不是 'let' 或 'const'
js.convert.var.to.let.text=轉換為 let
js.copy.qualified.to.clipboard=將限定名稱複製到剪貼簿
js.create.derived.type.abstract.class=實作抽象類別
js.create.derived.type.class=建立派生類別
js.create.derived.type.family=建立派生類別/實作接口
js.create.derived.type.interface=實作接口
js.create.switch.cases=建立缺少的 'switch' 分支
js.create.switch.cases.fix=建立缺少的分支: {0}
js.declaration.is.not.at.scope.start=var 語句不在作用域開始
js.declarations.at.scope.start.inspection='var' 未在函式開頭宣告
js.deprecated.symbols.inspection.name=已使用棄用的符號
js.destructuring.merge.inspection=正在解構具有相同鍵的屬性
js.destructuring.merge.inspection.fix=合併解構屬性
js.destructuring.merge.inspection.text=可以合併具有多個相同鍵的解構屬性
js.dialect.settings.caption=
js.dialect.settings.dialog.title=JavaScript 語言版本
js.dialect.settings.empty.text=使用 + 按鈕新增目錄，並選擇 JavaScript 版本
js.dialect.settings.override.question=覆寫子目錄和檔案的語言版本?
js.dialect.settings.override.title=覆寫語言版本設定
js.dialect.settings.tableTitle=語言
js.dialects.customized.label=根據目錄自定義
js.documentation.fires=觸發:
js.documentation.jsdoc.aliases=別名:
js.documentation.jsdoc.dialect=方言:
js.documentation.jsdoc.supported-also-by=還受以下物件的支援:
js.documentation.more.overload=其他 +{0} 個多載
js.documentation.more.overloads=其他 +{0} 個多載
js.dot.property.access.context.type=點號屬性存取
js.duplicate.declaration.inspection.name=重複宣告
js.edit.object.literal=編輯物件字面量屬性的值
js.expand.shorthand.property.quick.fix=展開速記屬性
js.expression.context.type=表達式
js.extends.keyword.wrap=擴展關鍵字
js.extends.list.wrap=Extends 列表
js.extjs.unresolved.ext.xtype.inspection.name=未解析的 Ext JS xtype
js.file.references.inspection.ignore.complex.cases=忽略複雜 case
js.file.references.inspection.name=未解析的檔案參照
js.file.watcher.6to5.description=使用 Babel 將 ECMAScript 6 程式碼轉換成 ECMAScript 5
js.fix.change.member.access.to.sharp=使用 '#' 設為 private
js.flow.enable.flow.service.error=\\ 不正確的 Flow 路徑
js.flow.enable.flow.service.error.empty=Flow 可執行檔案的路徑為空
js.flow.enable.flow.service.error.message={0}。停用所有 Flow 服務或為可執行檔案提供有效路徑。
js.flow.enable.flow.service.error.on.checking=檢查 Flow 路徑時出錯: {0}
js.flow.enable.other.services=導覽、程式碼補全和類型提示
js.flow.enable.type.checking=類型檢查
js.flow.has.unsaved.files=由於修改了某些檔案，因此沒有執行醒目提示
js.flow.process.log=Flow 流程日誌
js.flow.services.label=為之使用 Flow 伺服器:
js.flow.settings.auto.save=自動儲存所有修改的檔案
js.flow.settings.auto.save.warning.lsp=這樣 Flow 將始終顯示最新的錯誤狀態。
js.flow.settings.executable.dialog.title=選擇 Flow 軟體套件或可執行檔案
js.flow.settings.executable.label=Flow 軟體套件或可執行檔案 (&F):
js.flowjs.annotation.inspection.name=Flow 類型檢查器
js.flowjs.config.inspection.message=無關聯的 .flowconfig
js.flowjs.config.inspection.name=缺少 .flowconfig
js.flowjs.config.inspection.to.current.path.name=向當前目錄中新增 .flowconfig
js.flowjs.config.inspection.to.module.path.name=向模組內容根中新增 .flowconfig
js.flowjs.config.inspection.to.project.path.name=向專案根目錄中新增 .flowconfig
js.flowjs.flag.without.language.version=無 Flow 語言版本的 Flow 標誌
js.flowjs.group.name=Flow 類型檢查器
js.format.cstyle.comments=對齊多行
js.frameworks.sencha.xtype.not.found=找不到 xtype ''{0}'' 的 Ext JS 類別
js.function.brace.style=在函式宣告中
js.function.call.parentheses=函式呼叫括號
js.function.call.wrap=函式呼叫實參
js.function.declaration.parentheses=函式宣告括號
js.function.expression.brace.style=在函式表達式中
js.function.metrics.group.name=函式指標
js.function.parameters.wrap=函式宣告參數
js.generated.explicit.return.expression.types=函式表達式返回
js.generated.explicit.return.types=函式宣告返回
js.generated.explicit.types=此項的首選顯式類型:
js.generated.explicit.var.types=變數和欄位
js.generated.types=類型
js.generated.types.settings.link=顯式類型的程式碼樣式設定
js.generated.use.as.cast=首選 'as' 類型轉換
js.generated.use.public.modifier=使用 'public' 修飾符
js.import.options.merge.import=合併同一模組中成員的匯入
js.import.options.sort.members=對匯入的成員排序
js.import.options.sort.module.name=按模組對 import 排序
js.import.options.use.explicit.js.extension=使用檔案副檔名:
js.import.options.use.explicit.js.extension.auto=自動
js.import.options.use.explicit.js.extension.no=從不
js.import.options.use.explicit.js.extension.yes=始終
js.import.options.use.explicit.js.extension.yes.ts=始終為 ".js"
js.import.options.use.import-type=在 import 中使用 type 修飾符:
js.import.options.use.import-type.always=始終使用 type
js.import.options.use.import-type.auto=自動
js.import.options.use.import-type.help=此選項用於組態匯入類型時 TypeScript 'import type' 語句或類型說明符的用法。<br><br>選擇“始終使用 type”時，會始終使用 'import type' 或類型說明符。<br> <br>選擇“從不”時，所有類型都會像值一樣匯入，沒有 'type' 關鍵字。<br><br>選擇“自動”時，IDE 會檢查 TypeScript 版本和 tsconfig.json 以選擇最合適的選項。
js.import.options.use.import-type.never=從不
js.import.options.use.node.resolution=在 index.js 可用時使用目錄匯入(Node 樣式模組解析)
js.imports.dependencies.group.name=Import 和相依項
js.incompatible.types.comparison.inspection.name=類型不相容的表達式的比較
js.incompatible.types.comparison.message=條件始終為 {0, choice, 0#false|1#true}，因為類型 ''{1}'' 和 ''{2}'' 沒有重疊
js.indexer.to.property.intention=取代為屬性存取
js.infer.parameter.types.intention=從用法中推斷參數類型
js.infer.parameter.types.intention.failure.readonly.text=無法從用法中推斷類型: 為唯讀檔案
js.infer.parameter.types.intention.failure.text=無法從用法中推斷類型
js.infer.parameter.types.intention.failure.title=無法推斷類型
js.infer.parameter.types.intention.jsdoc=從用法中推斷 JSDoc 參數類型
js.infer.parameter.types.intention.progress.text=正在推斷類型
js.inject.dont.format.intention.text=停用注入內容的格式設定
js.inject.with.comment.intention.family.name=使用註釋對注射做出註解
js.inspection.amd.modules.dependencies.family.name=缺少 AMD 模組相依關係
js.inspection.async.group.name=Async 程式碼和 promise
js.inspection.bitwise.group.name=按位運算問題
js.inspection.convert.to.es6.group.name=ES2015 遷移協助
js.inspection.es6.modules.dependencies.family.name=缺少 import 語句
js.inspection.function.expression.is.used.instead.of.arrow=使用了函式表達式而不是箭頭函式
js.inspection.group.name=一般
js.inspection.group.path=JavaScript 和 TypeScript
js.inspection.missing.amd.dependency=缺少 AMD 模組相依關係
js.inspection.missing.import=缺少 import 語句
js.inspection.missing.module.dependency=缺少模組相依關係
js.inspection.package.json.dependencies=package.json 中的相依關係不符合
js.inspection.package.json.update.dependency.to.latest.version=將 package.json 相依項更新為最新版本
js.inspection.promise.ignored.display.name=返回 promise 的方法呼叫結果被忽略
js.inspection.promise.ignored.problem.descriptor=從 {0} 返回的 Promise 被忽略
js.inspection.promise.value.expected.problem.descriptor=應為值，但使用了從 {0} 返回的 Promise
js.inspection.switch.group.name=switch 語句問題
js.iterate=使用 'for..of' 進行迭代
js.iterate.async=使用 'for await..of' 進行迭代
js.join.declaration.assignment.inspection.fix=聯接變數宣告和指派
js.join.declaration.assignment.inspection.name=變數宣告可與變數的第一個指派合併
js.join.vars.intention=加入後續變數宣告
js.jquery.efficiency.inspection.allow.attribute.and.pseudo.selectors=允許特性和偽選擇器
js.jquery.efficiency.inspection.attribute.used.message=jQuery 特性選擇器可能低效
js.jquery.efficiency.inspection.duplicated.selector=重複的 jQuery 選擇器
js.jquery.efficiency.inspection.name=可以最佳化 JQuery 選擇器
js.jquery.efficiency.inspection.pseudoselector.used.message=jQuery 偽選擇器可能低效
js.language.version.label=JavaScript 語言版本
js.last.comma.in.array.literal.inspection.name=陣列字面量中的最後一個逗號多餘
js.last.comma.in.object.literal.inspection.name=物件字面量中的最後一個逗號多餘
js.library.attach.debug=附加偵錯版本(&D)…
js.library.attach.release=附加發佈版本(&R)…
js.library.configurable.name=庫
js.library.documentation=文檔
js.library.download.fix=下載庫
js.library.download.stubs.label=TypeScript 社群存根
js.library.downloading.library=正在下載庫
js.library.successfully.downloaded=已成功下載 {0}
js.library.unresolved.url.inspection.name=HTTP 連結缺少本地存儲的庫
js.linter.guesser.linter.disabled={0} 已停用。
js.linter.guesser.linter.enabled.because.of.config.file=已啟用 {0}: 組態檔案位於專案中。
js.linter.guesser.linter.enabled.because.of.dependency=已啟用 {0}: ''{1}'' 列出在 package.json 中。
js.linter.guesser.linter.enabled.because.of.package.json.section=已啟用 {0}: ''{1}'' 位於 package.json 中。
js.linters.detect.automatically.caption=從最近的 package.json 檢測軟體套件和組態檔案
js.linters.inspection.group.name=程式碼品質工具
js.make.single.var.statement=設為單變數語句
js.method.can.be.static=方法可以為 'static'
js.method.can.be.static.option=僅檢查 'private' 方法
js.mismatched.update.collection.inspection.name=不符合的集合查詢和更新
js.mismatched.update.collection.update.method.names=更新方法名稱:
js.missing.await.symbol.inspection.for.generator.name=異步產生器應使用 for-await 迴圈進行迭代
js.missing.await.symbol.inspection.for.returns=始終對異步函式呼叫使用 'await' 以避免錯誤，並幫助進行 V8 異步堆疊追蹤
js.missing.await.symbol.inspection.name=異步函式呼叫缺少 await
js.missing.switch.branches.ignore.with.default=忽略具有預設分支的 switch 語句
js.missing.switch.branches.inspection.desc=''switch'' 語句缺少 case: {0}
js.missing.switch.branches.inspection.name='switch' 語句缺少分支
js.module.uml.presentable.name=JavaScript 模組相依項
js.move.to.scope.start=將 var 語句移至作用域開始
js.move.type.to.file.family=移至名稱符合的檔案
js.move.type.to.file.text=將 {0} 移至檔案 {1}
js.named.to.anonymous.family.name=轉換為函式表達式
js.named.to.arrow.text=轉換為含有 {0} 的箭頭函式
js.named.to.function.expression.text=轉換為包含變數的函式表達式
js.named.to.function.hoisting.conflict.text=函式在宣告之前使用。轉換為變數後，將中斷使用
js.nested.template.literal.fix=內聯嵌套字面量
js.nested.template.literal.inspection=模板字面量中的冗餘嵌套
js.node.service.memory.configurable.autoIncrease=如果可用，自動增加記憶體
js.node.service.memory.configurable.autoIncrease.hint=當需要更多記憶體時，將新增 {0,number,#} MB 並重新啟動 LS。最大限制為 {1,number,#} MB
js.node.service.memory.configurable.footer=該設定適用於在 <code>node</code> 上執行的所有 TS 語言服務。<a href="{0}">詳細了解 LS 記憶體和故障排查。</a>
js.node.service.memory.configurable.header=語言服務記憶體
js.node.service.memory.configurable.manualIncrease=設定記憶體限制:
js.node.service.memory.configurable.manualIncrease.MB=MB
js.node.service.memory.configurable.manualIncrease.addMB=新增 {0,number,#} MB
js.node.service.memory.configurable.manualIncrease.validation.tooLarge=沒有此大小的可用 RAM。請使用小於 {0,number,#} MB 的值。
js.node.service.memory.oom.notification.actions.addMB=新增 {0,number,#} MB
js.node.service.memory.oom.notification.actions.configure=組態…
js.node.service.memory.oom.notification.actions.disableAutoIncrease=停用自動增加
js.node.service.memory.oom.notification.actions.enableAutoIncrease=啟用自動增加
js.node.service.memory.oom.notification.actions.howTo=如何手動修復
js.node.service.memory.oom.notification.autoIncreased=該項目的語言服務記憶體大小已自動增加 {0,number,#} MB
js.node.service.memory.oom.notification.content=這會影響自動補全和程式碼分析等基本功能。要解決此問題，請增加分配的記憶體。
js.node.service.memory.oom.notification.header=語言服務記憶體不足
js.node.services.profiler.disable=停止 Node.js 服務分析
js.node.services.profiler.enable=啟動 Node.js 服務分析
js.param.hints.blacklist.pattern.explanation=要停用方法或函式提示，請使用下面的其中一種模式: <p style="margin-left: 5px"><code><b>(*info)</b></code> - 所有參數名稱以 <em>info</em> 結尾的單參數方法<br><code><b>(key, value)</b></code> - 所有包含參數<em>鍵</em>和<em>值</em>的方法<br><code><b>*.put(key, value)</b></code>- 所有包含<em>鍵</em>和<em>值</em>參數的 <em>put</em> 方法<br><code><b>Console.log(*, *)</b></code> - 正好包含兩個參數的 <em>Console</em> 類型的 <em>log</em> 方法</p><br><p>必須為所有參數(包括可選參數)提供名稱或佔位符。<br>限定方法名稱必須包含類別或接口名稱或佔位符。<br>在編輯程式碼時，請使用“不為當前方法顯示提示”{0} 動作來新增模式。</p>
js.param.hints.show.names.for.all.args=非字面量實參
js.param.hints.show.names.for.literal.args=字面量實參
js.param.hints.show.names.for.pipes=管道運算符
js.param.hints.show.names.for.tagged=標記的模板實參
js.possibly.async.function.inspection=非異步函式中的 'await'
js.possibly.async.function.quick.fix=令函式 {0} 為異步函式
js.possibly.async.function.quick.fix.family.name=將函式設為異步
js.potentially.invalid.constructor.usages.inspection.name=可能無效的建構函式用法
js.potentially.invalid.target.of.indexed.property.access.inspection.name=索引的屬性存取的目標可能不正確
js.potentially.invalid.usage.of.class.this.inspection.name=從閉包對類別中 'this' 的參照可能無效
js.potentially.invalid.usage.of.this.inspection.name=從閉包對 'this' 的參照可能無效
js.primitive.type.improper.instantiation.inspection={0} 實例化可以簡化
js.primitive.type.wrapper.usage.inspection=使用了基元類型物件包裝器
js.probable.bugs.group.name=可能的 bug
js.progress.title.auto-importing-symbols-on-paste=貼上時自動匯入外部符號…
js.property.can.be.replaced.with.shorthand=屬性可被取代為速記形式
js.property.can.be.replaced.with.shorthand.method=屬性可被取代為速記方法
js.property.to.indexer.intention=取代為索引器存取
js.pull.up.will.be.made.abstract=非 abstract {0}將被設為 abstract
js.quote.unquote.intention.plural={0} 屬性名稱
js.quote.unquote.intention.quote=參照
js.quote.unquote.intention.quote.family=使用引號包裝屬性名稱
js.quote.unquote.intention.singular={0} 屬性名稱
js.quote.unquote.intention.unquote=取消參照
js.quote.unquote.intention.unquote.family=移除屬性名稱中的引號
js.react.group.name=React
js.redundant.await.inspection=冗餘 'await' 表達式
js.redundant.switch.problems.inspection.default='switch' 語句僅包含一個 'default' 子句
js.redundant.switch.problems.inspection.default.unwrap=解包 'switch' 語句
js.redundant.switch.problems.inspection.empty='switch' 語句為空
js.redundant.switch.problems.inspection.empty.remove=移除空的 'switch' 語句
js.redundant.switch.problems.inspection.name='switch' 語句冗餘，可以取代
js.redundant.switch.problems.inspection.side.effects=並提取副作用
js.redundant.switch.problems.inspection.single='switch' 語句僅包含一個非預設子句
js.redundant.switch.problems.inspection.single.replace=將 'switch' 取代為 'if'
js.referencing.mutable.variable.from.closure.inspection.name=從閉包中參照可變變數
js.regex.flag.d=符合索引 - 用於子字串符合的索引
js.regex.flag.g=全域符合 - 返回所有符合項
js.regex.flag.i=忽略大小寫 - 不區分大小寫的符合
js.regex.flag.m=多行 - ^ 和 $ 的每行符合
js.regex.flag.s=dotAll - . 符合換行符
js.regex.flag.u=unicode - 完整 unicode 支援
js.regex.flag.y=粘性 - 在確切的位置搜尋
js.remove.digit.separators=移除數字分隔符
js.remove.redundant.initializer.fix=移除冗餘的初始設定式
js.remove.unused.assignment=移除未使用的指派
js.rename.base.member=重新命名基{0}
js.rename.component.usage.provide.name.error=元件名稱應為有效的 JavaScript 關鍵字
js.rename.component.usage.provide.name.message=輸入新元件名稱
js.rename.component.usage.provide.name.title=重新命名元件
js.rename.current.member=重新命名當前 {0}
js.rename.file.to.match.type.name=將檔案重命名為 {0} 以匹配 {1} 名稱
js.rename.file.to.match.type.name.family=重新命名檔案以符合類型名稱
js.rename.member.title={0} {1} {3} 的 {2}
js.rename.member.title.implements=實作
js.rename.member.title.overrides=覆寫
js.rename.search.for.component.usages=搜尋元件用法(&O)
js.replace.string.concatenation.with.es6.template.fix.text=取代為模板字串
js.replace.string.concatenation.with.es6.template.inspection.name=已使用字串串聯而不是模板字面量
js.replace.string.with.es6.template=取代為模板字串
js.replace.with.literal=取代為 {0} 字面量
js.replace.with.shorthand.method.quick.fix=取代為速記方法
js.replace.with.shorthand.property.quick.fix=取代為速記屬性
js.replace.with.type.cast.to.primitive=取代為 {0} 的類型轉換
js.search.for.default.imports=正在搜尋 default import…
js.search.for.named.imports=正在搜尋命名 import…
js.searching.for.component.usages=正在搜尋元件用法…
js.separate.bytes=分隔位元組
js.separate.digits=分隔數字
js.separate.nibbles=分隔半位元組
js.separate.thousands=分隔千分位
js.separate.thousands.in.integer.part=分隔整數中的千分位
js.separate.words=分隔 16 位單詞
js.show.dynamic.usages=顯示動態用法
js.show.type.info.action.error=找不到表達式
js.space.before.function.left.brace=函式左大括號
js.spaces.in.flow.category=在 Flow 中
js.split.declarations=拆分宣告
js.split.into.multiple.declarations=拆分為多個宣告
js.statement.context.type=語句
js.strict.mode.inspection.error={0} 不處於嚴格模式下
js.strict.mode.inspection.fix=新增“use strict”雜註
js.strict.mode.inspection.name=使用了非嚴格模式
js.strict.mode.inspection.redundant.pragma="use strict"雜註冗餘
js.strict.mode.remove.pragma=移除“use strict”雜註
js.string.template.line.separators.multispan=轉換為多行字串模板
js.string.template.line.separators.multispan.family.name=轉換為多行字串模板
js.string.template.line.separators.visible=轉換為可見行分隔符
js.string.template.line.separators.visible.family.name=轉換模板字串以使用可見行分隔符
js.suspicious.bind.with.arrow.function=箭頭函式 'bind' 用法可疑
js.suspicious.eq.plus.fix.name=取代為 '+='
js.suspicious.eq.plus.inspection.desc=可疑的 '=+' 指派: '+=' 可能拼寫錯誤
js.suspicious.eq.plus.inspection.name=可疑的 '=+' 指派
js.suspicious.name.assignment=''{0}'' 可能不應分配給 ''{1}''
js.suspicious.name.combination.inspection.name=可疑的變數/參數名稱組合
js.suspicious.name.parameter=''{0}'' 可能不應作為參數 ''{1}'' 傳遞
js.suspicious.name.return=''{0}'' 可能不應從方法 ''{1}'' 返回
js.switch.no.default='switch' 語句沒有 'default' 分支
js.switch.no.default.add=建立缺少的預設分支
js.switch.to.jsx.inspection.dismiss=關閉
js.testing.autoWatch.action.name=監視更改
js.testing.highlight.line=在測試程式碼中醒目提示失敗的行
js.testing.inspection.group.name=單元測試
js.tool.window.limit=顯示前 {0} 個錯誤。
js.tool.window.limit.all=檢視所有 {0} 個錯誤
js.top.level.await.expression.inspection=頂層 'await' 表達式
js.top.level.await.expression.inspection.description=使用了頂層 'await' 表達式
js.top.level.statement.context.type=頂級語句
js.trailing.comma.keep=保持
js.trailing.comma.remove=移除
js.trailing.comma.whenMultiline=多行時新增
js.undeclared.variable.inspection.name=隱式宣告的全域 JavaScript 變數
js.undefined.property.assignment.inspection.message=類型 {1} 中未定義屬性 {0}
js.undefined.property.assignment.inspection.name=未定義的屬性指派
js.unfiltered.for.in.loop.inspection.name=未過濾 for..in 迴圈
js.unfiltered.for.in.loop.skip.primitives=使用陣列或物件初始設定式跳過參照迭代
js.unfiltered.for.in.loop.skip.primitives.tooltip=在未修改 Object.prototype 和 Array.prototype 時啟用它
js.unnecessary.semicolon.fix.name=移除不必要的分號
js.unnecessary.semicolon.inspection.name=不必要的分號
js.unnecessary.semicolon.problem=不必要的分號 #loc
js.unreachable.switch.branches.ignore.with.dynamic=不在動態類型的上下文中顯示此警告
js.unreachable.switch.branches.inspection.desc=不可到達的 'case' 分支
js.unreachable.switch.branches.inspection.name=不可到達 'switch' 語句的 'case' 分支
js.unreachable.switch.branches.remove=移除不可到達的 'case' 分支
js.unresolved.variable.inspection.name=未解析的參照
js.unused.assignment.inspection.name=未使用的指派
js.unused.es6.import.inspection.name=未使用的 import
js.unused.global.symbol.inspection.name=未使用的全域符號
js.unused.local.symbol.inspection.name=未使用的區域符號
js.unused.symbol=未使用的 {0} #ref
js.unused.symbol.full=未使用的 {0}
js.unused.symbol.remove=移除未使用的 {0}
js.unused.symbols.group.name=未使用的符號
js.unwanted.symbols.group.name=可能不合需要的程式碼結構
js.url.import.usage.inspection.download.module.0.quick.fix.failed=下載模組 ''{0}'' 失敗
js.url.import.usage.inspection.download.module.0.quick.fix.progress=正在下載模組 ''{0}''
js.url.import.usage.inspection.download.module.0.quick.fix.success=模組 ''{0}'' 已成功下載
js.url.import.usage.inspection.download.module.0.quick.fix.warning=模組 ''{0}'' 已下載，但有錯誤
js.url.import.usage.inspection.download.module.0.quick.fix.warning.urls=失敗的 URL:
js.url.import.usage.inspection.download.module.quick.fix.name=下載模組
js.url.import.usage.inspection.name=使用了 URL 匯入
js.usage.type.call=函式呼叫中的用法
js.validate.jsdoc.inspection.name=JSDoc 中的語法錯誤和未解析的參照
js.validate.signature.inspection.name=簽名不符合
js.validate.types.inspection.name=類型不符合
js.validity.issues.group.name=有效性問題
js.value.assigned.is.never.used=從未使用過所賦之值 #loc
js.value.assigned.to.is.never.used=賦給 ''{0}'' 的值從未使用 #loc
js.variable.initializer.is.redundant=變數初始設定式冗餘 #loc
js.variable.might.not.been.initialized=變數可能尚未初始化 #loc
js.variable.problems.ignore.desc=對可變變數忽略
js.variable.problems.inspection.desc=變數 ''{0}'' 在子句 ''{1}'' 中宣告， 但在子句 ''{2}'' 中使用
js.variable.problems.inspection.desc.ref.error=存取時參照錯誤
js.variable.problems.inspection.name=宣告了變數並在不同的 'case' 子句中使用
js.void.function.result.used.description=使用了 void 函式返回值
js.void.function.result.used.name=使用了 void 函式返回值
js.wrap.settings.class.decorators=類別裝飾器
js.wrap.settings.class.field.decorators=類別欄位裝飾器
js.wrap.settings.class.method.decorators=類別方法裝飾器
js.wrap.settings.function.parameter.decorators=函式參數裝飾器
js.wrap.settings.import=ES6 匯入/匯出
js.wrap.settings.object.types=物件類型
js.wrap.settings.union.and.intersection.types=聯合體與相交類型
js.wrap.settings.var.group.name=變數宣告
jshint.clear.field.to.disable=清除要停用的欄位
jshint.config.default.description=<div style="padding-bottom:10px"><div><b>.jshintrc</b></div><div style="padding-left:10px; padding-top:4px;">對 JavaScript 檔案進行 Linting 檢查時，IDE 會從檔案所在的目錄開始尋找 .jshintrc，然後上行到檔案系統根目錄。</div></div><div><div><b>package.json</b></div><div style="padding-left:10px; padding-top:4px;">將您的組態新增到專案的 package.json 檔案中的 <code>jshintConfig</code> 屬性下。</div></div>
jshint.config.error.cannot.locate.ext.config=JSHint: 無法定位擴展組態
jshint.config.error.cannot.parse.ext.config=JSHint: 無法解析擴展組態
jshint.config.error.failed.to.read.property=無法從 package.json 讀取 ''{0}'' 屬性
jshint.config.extends.cyclically=JSHint 組態迴圈擴展
jshint.config.failed.to.read=無法讀取 JSHint 組態
jshint.config.option.custom.browser.title=選擇 JSHint 組態檔案 (*.jshintrc)
jshint.config.option.custom.name=自訂組態檔案
jshint.config.option.default.name=預設
jshint.exception.balloon.action.configure.proxy.or.retry=<a href=''{0}''>組態 HTTP 代理</a>或<a href=''{1}''>重試</a>
jshint.exception.balloon.action.retry=<a href=''{0}''>重試</a>
jshint.illegal.integer=非法整數
jshint.inspection.message.config.not.found=未找到 JSHint 組態
jshint.inspection.message.duplicate.options=重複 JSHint 選項: {0}，{1}。
jshint.inspection.message.expected.value=預期值: {0}
jshint.inspection.message.expected.values.x.or.y=預期值: {0} 或 {1}
jshint.inspection.message.malformed.config=JSHint 組態格式錯誤
jshint.inspection.message.not.loaded=未載入 JSHint {0}
jshint.inspection.message.object.or.array.expected=應為物件或陣列
jshint.inspection.message.prefix=JSHint:
jshint.inspection.message.unexpected.jshint.option.name=意外的 JSHint 選項名稱
jshint.inspection.message.unexpected.value=意外值
jshint.label.bundled.suffix=(捆綁)
jshint.label.no.version=無版本
jshint.latedef.false.text=不警告
jshint.latedef.nofunc.text=<html><body>禁止變數在未定義的情況下使用，<br>但允許函式宣告。</body></html>
jshint.latedef.true.text=禁止變數在未定義的情況下使用
jshint.option.asi.description.short=禁止缺少分號的警告
jshint.option.bitwise.description.short=有關使用逐位運算符的警告
jshint.option.boss.description.short=禁止有關 <code>if/for/…</code> 內部指派的警告
jshint.option.browser.description.short=瀏覽器
jshint.option.camelcase.description.short=有關變數命名的警告
jshint.option.curly.description.short=塊省略 <code>{}</code> 時發出警告
jshint.option.debug.description.short=禁止有關偵錯模式的警告
jshint.option.devel.description.short=開發
jshint.option.edit.dialog.title=設定 ''{0}'' 選項
jshint.option.elision.description.short=禁止有關 ES3 陣列省略元素的警告
jshint.option.enforceall.description.short=程式碼未遵守最嚴格的組態時發出警告
jshint.option.eqeqeq.description.short=有關不安全比較的警告
jshint.option.eqnull.description.short=禁止有關 <code>== null</code> 的警告
jshint.option.es3.description.short=有關與 ES3 規範不相容的警告
jshint.option.es5.description.short=有關與 ES5 規範不相容的警告
jshint.option.esnext.description.short=EcmaScript.next
jshint.option.esversion.description.short=在與指定的 ECMAScript 版本不相容時發出警告
jshint.option.evil.description.short=禁止有關 <code>eval</code> 的警告
jshint.option.expr.description.short=禁止有關將表達式用作語句的警告
jshint.option.forin.description.short=有關不安全 <code>for..in</code> 的警告
jshint.option.freeze.description.short=有關覆蓋原生物件原型的警告
jshint.option.funcscope.description.short=禁止有關在已宣告塊外部使用變數的警告
jshint.option.futurehostile.description.short=有關使用在以後的 JavaScript 版本中定義的關鍵字的警告
jshint.option.gcl.description.short=將 JSHint 設為與 Google Closure Compiler 相容
jshint.option.globalstrict.description.short=禁止有關使用全域嚴格模式的警告
jshint.option.immed.description.short=有關未使用括號包裝函式而直接呼叫函式的警告
jshint.option.indent.description.short=縮排
jshint.option.iterator.description.short=禁止有關 <code>__iterator__</code> 屬性的警告
jshint.option.lastsemic.description.short=禁止有關缺少分號的警告，但僅當單行塊中的最後一條語句省略分號時才顯示該警告
jshint.option.latedef.description.short=當變數在未定義的情況下使用時發出警告
jshint.option.laxbreak.description.short=禁止有關不安全換行的警告
jshint.option.laxcomma.description.short=禁止有關編碼樣式以逗號開頭的警告
jshint.option.loopfunc.description.short=禁止有關函式在迴圈內部的警告
jshint.option.maxcomplexity.description.short=程式碼中的最大迴圈復雜度
jshint.option.maxdepth.description.short=塊的最大深度
jshint.option.maxerr.description.short=最大錯誤數
jshint.option.maxlen.description.short=行的最大長度
jshint.option.maxparams.description.short=函式中的最大參數數量
jshint.option.maxstatements.description.short=函式中的最大語句數量
jshint.option.module.description.short=ECMAScript 6 模組
jshint.option.moz.description.short=檢查程式碼是否使用 Mozilla JavaScript 擴展
jshint.option.multistr.description.short=禁止有關多行字串的警告
jshint.option.newcap.description.short=有關使用非大寫形式的建構函式的警告
jshint.option.noarg.description.short=有關 <code>arguments.caller</code> 和 <code>.callee</code> 的警告
jshint.option.nocomma.description.short=有關使用逗號運算符的警告
jshint.option.noempty.description.short=有關空塊的警告
jshint.option.nomen.description.short=不允許使用 _ in 變數
jshint.option.nonbsp.description.short=有關“不間斷空格”字元的警告
jshint.option.nonew.description.short=有關副作用 <code>new</code> 用法的警告
jshint.option.nonstandard.description.short=轉義和未轉義
jshint.option.notypeof.description.short=禁止有關無效 <code>typeof</code> 運算符值的警告
jshint.option.noyield.description.short=禁止在產生器函式中無 yield 語句時有關產生器函式的警告
jshint.option.onevar.description.short=每個函式一個變數語句
jshint.option.passfail.description.short=出現第一個錯誤時停止
jshint.option.plusplus.description.short=有關使用一元遞增和遞減運算符的警告
jshint.option.predef.description.short=預定義(以 , 分隔)
jshint.option.predef.details=指定全域變數及其可分配狀態:\\n<pre>DISQUS:true、jQuery:false</pre>\\n<p/>此時，JSHint 允許您覆寫 DISQUS，但禁止覆寫 jQuery。
jshint.option.proto.description.short=禁止有關 <code>__proto__</code> 屬性的警告
jshint.option.quotmark.description.short=引號
jshint.option.scripturl.description.short=禁止有關使用以腳本為目標的 URL 的警告
jshint.option.shadow.description.short=禁止有關變數隱藏的警告
jshint.option.singlegroups.description.short=如果未嚴格要求使用分組運算符，禁止使用該運算符
jshint.option.smarttabs.description.short=在空格僅用於對齊時，禁止有關將制表符和空格混合使用的警告
jshint.option.strict.description.short=程式碼未採用嚴格模式時發出警告
jshint.option.sub.description.short=如果可以使用點符號表示 <code>[]</code> 符號，則禁止有關使用後者的警告
jshint.option.supernew.description.short=禁止有關“怪異”建構的警告
jshint.option.trailing.description.short=有關尾隨空格的警告
jshint.option.typed.description.short=輸入的陣列
jshint.option.undef.description.short=未定義變數時發出警告
jshint.option.unused.description.short=存在未使用的變數時發出警告
jshint.option.validthis.description.short=禁止有關可能違反嚴格要求的警告
jshint.option.varstmt.description.short=有關使用 VariableStatements 的警告
jshint.option.white.description.short=不允許使用雜亂的空格
jshint.option.withstmt.description.short=禁止有關使用 with 語句的警告
jshint.option.worker.description.short=Web 工作執行緒
jshint.option.wsh.description.short=Windows Script Host
jshint.options.tree.tooltip.set.a.new.value=設定新值
jshint.progress.title=JSHint {0}
jshint.progress.title.downloading=正在下載 {0}
jshint.progress.title.updating.jshint=正在將 JSHint 更新到 {0}
jshint.quotmark.double.text=僅允許雙引號
jshint.quotmark.false.text=允許兩種引號
jshint.quotmark.single.text=僅允許單引號
jshint.quotmark.true.text=僅允許單引號或雙引號
jshint.suppress.text.suppress.for.line=禁止行
jshint.tree.link.set=設定
jshint.unused.false.text=不檢查任何內容
jshint.unused.strict.text=檢查所有變量和參數
jshint.unused.true.text=<html><body>檢查所有變量和參數，但允許<br>使用的參數後存在未使用參數</body></html>
jshint.unused.vars.text=檢查變數，而不是函式參數
jshint.use.config.files=使用組態檔案
jshint.version.label=版本(&V):
jsx.code.style.attribute.default.value=為 JSX 特性新增:
jsx.code.style.attribute.default.value.braces=大括號
jsx.code.style.attribute.default.value.none=無
jsx.code.style.attribute.default.value.quotes=引號
jsx.code.style.attribute.default.value.typebased=基於類型
jsx.convert.html.attributes.to.jsx=將程式碼貼上到 JSX 檔案時關閉 HTML 單一標記
jsx.convert.html.attributes.to.react=將程式碼貼上到 React JSX 檔案時轉換 HTML 特性名稱
jsx.convert.html.to.jsx.command.name=將 HTML 程式碼轉換為 JSX
jsx.convert.html.to.jsx.progress=正在將 HTML 程式碼轉換為 JSX…
jsx.dom.nesting.inspection.message=''{0}'' 不能作為 ''{1}'' 的子級出現
jsx.dom.nesting.inspection.message.text=文本節點不能顯示為 ''{0}'' 的子級
jsx.dom.nesting.inspection.message.tr=''{0}'' 不能作為 ''{1}'' 的子級出現。在您的程式碼中新增 <tbody>、<thead> 或 <tfoot> 以符合瀏覽器生成的 DOM 樹。
jsx.dom.nesting.inspection.name=無效的 DOM 元素嵌套
jsx.html.context.type=JSX HTML
jsx.missing.namespace.inspection.name=缺少 JSX 命名空間
jsx.missing.namespace.inspection.text=在未匯入 {0} 的情況下使用 JSX
jsx.syntax.used.description=已使用 JSX 語法
jsx.syntax.used.name=已使用 JSX 語法
jsx.unresolved.component.name=未解析的 JSX 元件
jsx.unresolved.prop.name=未解析的 JSX 屬性
label.compiles.js.files=編譯 .js 檔案
label.compress.js.files=壓縮 .js 檔案
label.exclude.methods.classes=排除類別方法:
label.import.popup=自動匯入工具提示
label.method.should.be.defined=方法應已定義
label.minimum.language.level=最低語言級別:
label.name.injection=名稱(&N):
label.namespace=命名空間:
label.path=路徑(&P):
label.wsl.node.interpreter=WSL Node.js 解釋器(&N):
linemarker.implemented=已實作
linemarker.implementing=實作
linemarker.implements.invalid=<無效>
linemarker.implements.several=實作多種接口方法
linemarker.implements.text=實作 {1} 中的 {0}
linemarker.javascript.sources=JavaScript 源
linemarker.javascript.typescript=JavaScript/TypeScript 行標記
linemarker.overridden=覆寫
linemarker.overrides.text=覆寫 {1} 中的 {0}
linemarker.overriding=覆寫
linemarker.typescript.declaration=TypeScript 宣告
list.item.class.field=類別欄位
list.item.declarations.function.members.to.be.converted.to.class.members=要轉換為類別成員的函式成員的宣告
list.item.declarations.that.were.not.converted=未轉換的宣告
list.item.function.converted.to.class=轉換為類別的函式
list.item.function.to.be.converted.to.class=要轉換為類別的函式
list.item.global.or.module.constant=全域或模組常數
list.item.google.javascript.style.guide=Google JavaScript 樣式指南
list.item.javascript.file=JavaScript 檔案
list.item.javascript.jsx.file=JSX 檔案
list.item.javascript.standard.style=JavaScript 標準樣式
list.item.local.constant=區域常數
list.item.typescript.file=TypeScript 檔案
list.item.typescript.jsx.file=TypeScript JSX 檔案
live.template.con.description=帶 props 實參的建構函式
live.template.fsc.description=React Flow 箭頭函式元件
live.template.fsf.description=React Flow 函式元件
live.template.props.description=this.props.
live.template.rcc.description=React 類別元件
live.template.rccp.description=帶有 PropTypes 的 React 類別元件
live.template.rcfc.description=帶有 PropTypes 和生存期方法的 React 類別元件
live.template.rsc.description=React 箭頭函式元件
live.template.rscp.description=帶有 propTypes 的 React 箭頭函式元件
live.template.rsf.description=React 函式元件
live.template.rsfp.description=帶有 propTypes 的 React 函式元件
live.template.rsi.description=帶有隱式 return 的 React 箭頭函式元件
live.template.state.description=this.state.
livetemplate.description.arf=使用箭頭函式包圍
livetemplate.description.console.assert=console.assert()
livetemplate.description.console.error=console.error()
livetemplate.description.console.info=console.info()
livetemplate.description.console.log=console.log()
livetemplate.description.console.trace=console.trace()
livetemplate.description.console.warn=console.warn()
livetemplate.description.defi=插入 define() 表達式
livetemplate.description.exportall=匯出語句 - 從 'a' 匯出 *
livetemplate.description.exportfrom=匯出語句 - 從 ''a'' 匯出 {b} 
livetemplate.description.exportitems=匯出語句 - export {b}
livetemplate.description.flow=插入 @flow 註解
livetemplate.description.fori=建立迭代迴圈
livetemplate.description.importdefault=import 語句 - 從 'a' 匯入 b
livetemplate.description.importfrom=import 語句 - 從 ''a'' 匯入 {b}
livetemplate.description.importns=import 語句 - 從 'a' 匯入 * as b
livetemplate.description.itar=遍歷陣列元素
livetemplate.description.iter=迭代 (for..of)
livetemplate.description.itera=迭代 (for await..of)
livetemplate.description.itin=迭代(for..in)
livetemplate.description.moduleexports=匯出語句 - module.exports = a
livetemplate.description.ref=插入參照路徑註釋
livetemplate.description.ritar=以相反順序遍歷陣列的元素
livetemplate.description.us=插入 'use strict' 語句
lsp.executable.error=找不到 {0} 的可執行檔案。
lsp.interpreter.error=未組態本地或 WSL Node.js 解釋器。
macro.js.component.type.of=jsComponentTypeOf(Array)
macro.js.suggest.default.variable.kind=jsSuggestDefaultVariableKind(Boolean)
make.method.static=設為 'static'
make.private=設為 private
members.to.implement.chooser.title=選擇要實作的成員
members.to.override.chooser.title=選擇要覆寫的成員
merged.process.output.text={0}{2, choice, 0#\\n\\n標準錯誤:\\n{1}|1#}{4, choice, 0#\\n\\n標準輸出:\\n{3}|1#}\\n\\n{5}
method.return.types.in.call.chains=呼叫鏈中的函式返回值類型
modules.selected=選定
move.members.dialog.title=移動成員
move.members.refactoring.name=移動成員
multiple.inheritance=多重繼承
new.actionscript.class.dialog.title=新增 ActionScript 類別
new.actionscript.interface.dialog.title=新增 ActionScript 接口
new.constructor.action.description=建立建構函式
new.constructor.action.text=建構函式
new.field.action.description=在類別中建立新字段
new.field.action.text=欄位
new.method.action.description=在類別中建立新方法
new.method.action.text=方法
no.candidates=無候選項
no.executable.found.in.path=在 {0, choice, 0#%PATH%|1#$PATH} 中未找到可執行檔案
no.members.to.implement=找不到要實作的成員
no.members.to.override=找不到要覆寫的成員
no.methods.to.implement=找不到要實作的方法
no.methods.to.override=找不到要覆寫的方法
no.variables.for.getter=找不到沒有 getter 的欄位
no.variables.for.getter.setter=找不到沒有 getter 和 setter 的欄位
no.variables.for.setter=找不到沒有 setter 的欄位
node.core.core_modules_fetch_timed_out.dialog.message=無法提取核心模組: 已超時
node.core.enable_coding_assistance_intention.name=啟用 Node.js 的編碼輔助
node.core.failed_to_fetch_node_core_modules.dialog.message=無法提取 Node 核心模組
node.core.make.sure.javascript.debugger.plugin.enabled.dialog.message=確保已啟用 'JavaScript Debugger' 延伸模組
node.core.navigate_action_text.text=組態 Node.js…
node.core.not_ready_for_core_modules_configuration.dialog.message=未準備好進行核心模組組態
node.debug.cannot_connect_to_vm.error.message=無法連線到虛擬機 {0}
node.debug.cannot_get_localhost_IPv4.error.message=無法獲取 127.0.0.1 IPv4
node.download.broken.installation.error=Node.js 安裝損壞。
node.download.cannot_find_interpreter.error=找不到已下載的 Node.js 解釋器。
node.download.dialog.error.failed_to_fetch_versions=無法提取可用的 Node.js 版本
node.download.dialog.full.version.label=版本:
node.download.dialog.location.description=選擇下載 Node.js 的路徑:
node.download.dialog.location.error.blank=位置路徑為空
node.download.dialog.location.error.existing_non_empty_directory=位置指向現有的非空目錄
node.download.dialog.location.error.failed_to_resolve=無法解析位置
node.download.dialog.location.error.file.exists=位置指向現有檔案
node.download.dialog.location.label=位置:
node.download.dialog.major.version.label=發佈:
node.download.dialog.no_version.label=無版本
node.download.dialog.ok_text=下載
node.download.dialog.released_on.label={0} 發佈
node.download.dialog.unavailable.label=不可用
node.download.download.cancelled.error=動作已被取消。
node.download.editor.suggestion={0} 需要 Node.js 才能正常工作。
node.download.failure.notification=無法下載 Node.js {0}。{1}
node.download.fetching.version=正在提取 Node.js 版本…
node.download.node.archive=正在下載 Node.js {0}
node.download.open.settings=開啟設定
node.download.success.notification=Node.js {0} 已組態。
node.download.supported_later.platform=Node.js 在版本 {2} 或更高版本中支援 {0}，{1}
node.download.unsupported.platform=Node.js 不支持 {0}，{1}
node.execution.failed.to.prepare.target.environment.error=無法準備環境: {0}
node.execution.starting.process.progress.title=正在啟動 ''{0}''…
node.interpreter.command_timed_out.dialog.message=''{0}'' 指令執行超時(>{1} 毫秒)
node.interpreter.download=下載 Node.js
node.interpreter.field.add.item.text=新增…
node.interpreter.field.popup.download.item=下載…
node.interpreter.field.unexpected_value.text=意外值 {0}
node.interpreter.invalid_interpreter.error.message=無效 ''{0}''
node.interpreter.label=Node 解釋器(&I):
node.interpreter.no_local_interpreter.error.message=沒有本地 Node.js 解釋器
node.interpreter.node_from_path.reference.name=node
node.interpreter.not.found=找不到 {0}
node.interpreter.project_node.reference.name=專案
node.interpreter.reference_not_found.text=未找到
node.interpreter.specified_interpreter_correctly.dialog.message=正確指定 Node.js 解釋器
node.interpreter.unavailable.target=不可用的目標: {0}
node.interpreter.unresolved_reference.error.message=未解析的解釋器 ''{0}''
node.interpreter.unspecified.error.text=指定 Node.js 解釋器
node.interpreter.unspecified_interpreter.dialog.message=指定 Node.js 解釋器
node.interpreter.unspecified_interpreter_with_link.dialog.message=指定 <a href="">Node.js 解釋器</a>
node.interpreter.unspecified_local_interpreter.dialog.message=指定本地 Node.js 解釋器
node.js.add.interpreter.action=新增{0}…
node.js.configure.interpreter=組態{0}
node.js.downloading=正在下載 Node.js {0}
node.js.inspection.group.name=Node.js
node.js.interpreters=Node.js 解釋器
node.js.invalid.node=該專案使用了無效的 Node.js 路徑。<br>它已更新為使用 {0} 中的 Node.js。
node.js.missing.require=缺少 require() 語句
node.js.quickfix.install.node.module.devDependencies.family.name=安裝模組作為開發相依關係
node.js.quickfix.install.node.module.error.no.interpreter.text=無法安裝 Node.js 模組: 請指定預設 Node.js 解釋器。
node.js.quickfix.install.node.module.error.no.interpreter.title=安裝 Node.js 模組
node.js.quickfix.install.node.module.error.prefix.text=無法安裝 Node.js 模組: {0}
node.js.quickfix.install.node.module.family.name=安裝模組
node.js.quickfix.install.node.module.text=安裝 ''{0}''
node.js.quickfix.install.node.module.update.modules.family.name=執行 'npm install'
node.js.quickfix.install.node.module.with.dev.dependencies.text=安裝 ''{0}'' 作為開發相依關係
node.js.quickfix.run.command=執行 ''{0}''
node.js.remote.interpreters.plugin.missing=缺少 Node.js 遠端解釋器延伸模組。請啟用 {0} 中的延伸模組
node.js.select.file=選擇 {0} 檔案
node.js.set.project.interpreter.action=設定為專案解釋器
node.js.unresolved.api=未解析的 Node.js API
node.no.interpreter=無解釋器
node.npm.cannot_find_package_by_reference.dialog.message=找不到軟體套件管理器 ''{0}''
node.npm.cannot_find_project_package_manager.dialog.message=找不到專案 Node.js 軟體套件管理器
node.npm.cannot_resolve_package_manager.dialog.message=無法解析 ''{0}'' 軟體套件管理器
node.npm.correct_path_to_npm_or_yarn_package.dialog.message=指定 npm 或 yarn 軟體套件的正確路徑: 無此類別目錄“{0}”
node.npm.invalid_package_manager.binary_file_not_found.dialog.message=指定有效的軟體套件管理器: 在 ''{0}'' 目錄內部找不到二進制檔案
node.npm.package_manager_link.text=軟體套件管理器
node.npm.project_package_manager_disallowed_here.dialog.message=無法在此處參照專案 npm 軟體套件
node.npm.specify_npm_or_yarn_package.dialog.message=指定 npm 或 yarn 軟體套件
node.npm.unspecified_package_manager.dialog.message=未指定軟體套件管理器
node.package.binary.file.hint=指向 {0} 的二進制檔案的路徑
node.package.cannot.find.bin.file.dialog.message=找不到 ''{0}'' 軟體套件的 bin 檔案
node.package.dropDownList.select=選擇…
node.package.empty.error.message=專案名稱為空
node.package.empty.hint={0} 軟體套件目錄路徑
node.package.empty.hint.pkg1.or.pkg2={0} 或 {1}
node.package.field.not_found.text=未找到
node.package.manager.label=軟體套件管理器 (&M):
node.package.name.URL-friendly.characters.error.message=專案目錄名稱應僅包含適用於 URL 的字元
node.package.name.capital.letters.error.message=專案目錄名稱不應包含大寫字母
node.package.name.core.module.error.message=''{0}'' 不能用作專案名稱，因為它是 Node.js 核心模組的名稱
node.package.name.forbidden.error.message=''{0}'' 不能用作專案名稱
node.package.name.leading.or.trailing.spaces.error.message=專案目錄名稱不應包含前導空格或尾隨空格
node.package.name.period.error.message=專案目錄名稱不應以句點開頭
node.package.name.special.characters.error.message=專案目錄名稱不應包含特殊字元("~'!()*")
node.package.name.too.long.error.message=專案目錄名稱不應超過 214 個字元
node.package.name.underscore.error.message=專案目錄名稱不應以下劃線開頭
node.package.none=無軟體套件
node.package.selector.multiple.packages.binary.file.title=選擇 {0} 的軟體套件目錄或二進制檔案
node.package.selector.multiple.packages.description=選擇 {0}
node.package.selector.multiple.packages.title=選擇軟體套件目錄
node.package.selector.single.package.title=選擇 {0} 軟體套件目錄
node.package_documentation.installed_version.text=已安裝版本: {0}
node.package_documentation.latest_version.text=最新版本: {0}
node.wsl.network.connection.failure=無法建立從 WSL 到 Windows 主機的網絡連線(可能被防火牆阻止)。\\n要了解詳細資訊，請參閱: https://jb.gg/wsl-firewall
node.wsl.unavailable.dialog.message=WSL 不可用
non.ascii.identifiers.inspection.name=包含非 ASCII 符號的關鍵字
non.ascii.identifiers.mixed.set=<html>名稱同時包含 ASCII 和非 ASCII 符號: {0}</html>
non.ascii.identifiers.non.ascii.found=<html>名稱包含非 ASCII 符號: {0}</html>
non.ascii.identifiers.only.ascii=僅允許 ASCII 名稱
non.parenthesized.single.parameter=未使用括號括起來的單個參數
non.parenthesized.single.parameter.description=未使用括號括起來的單個參數
not.installed.package=未安裝軟體套件
notification.content.html.href.settings.show.inspection.settings.or.href.undo.undo.html=<html><a href='settings'>顯示檢查設定</a>或<a href='undo'>撤消</a></html>
notification.content.notifications.are.enabled.for.all.package.json.files=為所有 package.json 檔案啟用通知
notification.content.notifications.are.enabled.for.current.package.json=為當前 package.json 啟用通知
notification.content.show.details=顯示詳細資訊
notification.group.code.vision.performance.watcher=JavaScript: Code Vision 性能觀察程序
notification.group.grunt.console=Grunt 'watch' 任務狀態已更改
notification.group.jest=Jest 測試執行失敗
notification.group.linters=JavaScript linter
notification.group.narrowed.types=JavaScript: 已停用限縮的類型的著色
notification.group.nodejs.assistance=Node.js 編碼輔助失敗
notification.group.nodejs.interpreter=Node.js 解釋器路徑已更新
notification.group.package.json=來自 package.json 的相依項可用
notification.group.package.json.disabled=來自 package.json 的相依項: 通知已停用
notification.group.project.generator=JavaScript 專案生成失敗
notification.group.vitest=Vitest 測試執行失敗
notification.provideInlayHints.serviceDisabled=<code>provideInlayHints</code> 方法在 TypeScript 伺服器上失敗。請嘗試將 TypeScript 升級到至少 v5.9。<br/>當前正在使用內部嵌入提示實作。
notification.provideInlayHints.serviceRestored=<code>provideInlayHints</code> 方法已恢復正常執行。
notification.title.cannot.download.types.node=無法下載 @types/node
notification.title.cannot.enable.node.js.coding.assistance=無法啟用 Node.js 編碼輔助
notification.title.cannot.generate=無法生成 {0}
notification.title.coloring.types.narrowed.by.type.guard.was.disabled=按類型防護限縮類型著色被停用
notify.urls.more=…和其他 {0,number} 個
npm.before.run.task=執行 npm 腳本
npm.before.run.task.descr=執行 npm {0, choice, 0#腳本|1#腳本|2#腳本}{1} [{2}]
npm.dialog.message.cannot.resolve.package.manager=無法解析 ''{0}'' 軟體套件管理器
npm.downloading_package=正在下載 {0}…
npm.failed_to_install_package.title.message=無法安裝 {0}
npm.modules.inspection.content.of.require.module.not.installed.warning=未安裝模組
npm.modules.inspection.content.of.require.not.in.dependencies.warning=package.json 相依關係中未列出模組
npm.modules.install.global.types.dialog.title=安裝 TypeScript 定義
npm.modules.install.global.types.directory.error=無法建立所需的目錄
npm.modules.install.global.types.fix.name=安裝 TypeScript 定義以提供更好的類型資訊
npm.no.scripts.found=未找到腳本
npm.rc.command.label=指令:(&C)
npm.rc.environmentVariables.label=環境:
npm.rc.nodeInterpreter.label=Node 解釋器(&I):
npm.rc.nodeOptions.label=Node 選項:
npm.rc.packageJson.browseDialogTitle=選擇 package.json 檔案
npm.rc.packageJson.label=package.json(&P):
npm.rc.scripts.label=腳本 (&T):
npm.rc.scriptsArguments.label=實參(&R):
npm.searching_for_previously_installed_package=正在搜尋先前安裝的 {0}…
npm.task.title=NPM 腳本
numeric.enum.values=數值枚舉值
package.description=軟體套件 {0}
package.downloader.create.package.directory=正在建立軟體套件目錄…
package.json.install.types.fix.family.name=為軟體套件安裝 @types
package.version.range.hint={0, choice, 0#允許|1#允許次要更新:|2#允許更新檔更新} {1} ≤ 版本 \\\\&lt; {2}
package.version.range.info={0, choice, 0#未安裝|1#已安裝: ?|2#已安裝: {1}}，最新: {2, choice, 0#正在載入…|1#找不到|2#{3}}
package_json.install_dependencies.notification.content=來自 {0}
package_json.install_dependencies.notification.title=安裝相依項
package_json.install_dependencies_multiple.notification.content=來自 {0} 和其他 {1} 個
package_json.notifications_are_disabled.notification.content=已停用從 {0} 安裝相依項的通知。<p>使用“{1}”動作重新啟用通知。
package_json.update_dependencies.notification.title=更新相依項
parameter.type.is.not.specified=參數 ''{0}'' 的類型未指定。\\n是否繼續?
parameters.in.parentheses=圓括號中的參數
parameters.in.parentheses.description=圓括號中的參數
please.specify.package.manager=指定<a href="">軟體套件管理器</a>。
popup.advertisement.latest.available.versions.for.all.distribution.tags=所有發行版標籤的最新可用版本
popup.advertisement.start.typing.package.name=開始輸入軟體套件名稱，以從 npm 官方公共註冊表中獲取更具體的結果
popup.content.cannot.edit.selected.node.js.interpreter=無法編輯選定的 Node.js 解釋器
popup.title.choose.class=選擇類別
popup.title.select.destructuring.assignment.target=選擇解構指派目標
popup.title.target.function=目標函式
postfix.template.condition.array.name=陣列
postfix.template.condition.non.void.name=非 Void
postfix.template.provider.name=JavaScript 和 TypeScript
process.terminated=程序已終止
progress.subtitle.install=正在通過 {1} 安裝 {0}…
progress.text.initializing.opened.files=正在初始化開啟的檔案
progress.text.modifying=正在修改 {0}
progress.text.processing=正在處理 {0}{1}
progress.title.compiling.typescript.files=正在編譯 TypeScript 檔案
progress.title.configuring.node.js.coding.assistance=正在組態 Node.js 編碼輔助…
progress.title.detect.overridden.methods=檢查覆寫方法
progress.title.downloading.documentation=正在下載文檔
progress.title.downloading.library=正在下載庫
progress.title.downloading.typings=正在下載 typings
progress.title.executing.performance.task.on.files=正在檔案上執行性能任務
progress.title.find.usages=正在尋找用法…
progress.title.install=安裝 {0}
progress.title.install.npm.module=安裝 npm 模組 ''{0}''
project.generation=生成專案
protractor.rc.configurationFile.label=組態檔案(&C):
protractor.rc.configurationFile.title=選擇 Protractor 組態檔案
protractor.rc.protractorOptions.emptyText=CLI 選項，例如 --browser 或 --rootElement
protractor.rc.protractorOptions.label=Protractor 選項 (&O):
protractor.rc.protractorPackage.label=Protractor 軟體套件(&P):
rc.browser.error.unspecified.url.text={0} 中未指定 URL
rc.browser.liveEdit.tab.name=瀏覽器 / Live Edit
rc.configuration.tab.name=組態
rc.environmentVariables.label=環境變數(&E):
rc.nodeOptions.label=Node 選項 (&O):
rc.testConfig.presentable.name={0} 中的所有測試
rc.testDirectory.presentable.name={0} 中的測試
rc.testOrSuiteScope.emptyTest=空測試名稱
rc.testOrSuiteScope.suite.label=套件名稱:
rc.testOrSuiteScope.suite.title=編輯套件名稱
rc.testOrSuiteScope.test.label=測試名稱:
rc.testOrSuiteScope.test.title=編輯測試名稱
rc.testRunScope.all=所有測試(&L)
rc.testRunScope.directory=目錄(&D)
rc.testRunScope.suite=套件
rc.testRunScope.test=測試(&T)
rc.testRunScope.testDirectory.browseTitle=選擇測試目錄
rc.testRunScope.testDirectory.label=測試目錄:
rc.testRunScope.testFile=測試檔案(&F)
rc.testRunScope.testFile.browseTitle=選擇測試檔案
rc.testRunScope.testFile.label=測試檔案:
rc.workingDirectory.browseDialogTitle=選擇工作目錄
rc.workingDirectory.label=工作目錄(&W):
recursive.call=遞迴呼叫
refactoring.destructuring.vars.for.refactor.this=物件或陣列解構…
refactoring.destructuring.vars.intention.const.to.var.warning=在轉換期間，醒目提示顯示的 const 變數將轉換為 let 變數。\\n是否要繼續?
refactoring.destructuring.vars.intention.const.to.var.warning.title=變數關鍵字更改
refactoring.destructuring.vars.intention.deconstruct=生成解構模式
refactoring.destructuring.vars.intention.depropagate=將解構取代為屬性和索引存取
refactoring.destructuring.vars.intention.guard.conflict=通過類型 guard 將表達式類型限縮為 ''{0}''，該類型 guard 在重構後將不起作用
refactoring.destructuring.vars.intention.name=引入物件或陣列解構
refactoring.destructuring.vars.intention.name.array=引入陣列解構
refactoring.destructuring.vars.intention.name.object=引入物件解構
refactoring.destructuring.vars.intention.propagate=傳播到解構宣告
refactoring.destructuring.vars.intention.replace.array=取代為數組解構
refactoring.destructuring.vars.intention.replace.object=取代為物件解構
refactoring.destructuring.vars.intention.replace.promise=取代為 'await Promise.all'
refactoring.destructuring.vars.intention.replace.shorthand=取代為解構和速記屬性
reg.exp.tagged.template=''{1}'' 標記模板中的 {0}
remove.type.prefix=移除類型前綴
remove.unnecessary.parentheses.fix.text=移除不必要的圓括號
rename.accessors.dialog.text=是否將屬性存取器也重命名為 ''{0}''?
rename.accessors.dialog.title=重新命名欄位
rename.css.definition.description=檢測到 CSS 類型宣告的用法。應重新命名相關屬性，否則可能導致程式碼不一致。
rename.css.definition.title=重新命名類型宣告成員
rename.destructuring.property.description=解構屬性參照多個成員。應重新命名相關屬性，否則可能導致程式碼不一致。
rename.destructuring.property.title=重新命名解構屬性
rename.prompt.do.you.want.to.rename.base.method=是否要重新命名基方法?
rename.react.hook.variable.description=將相關狀態變數重命名為:
rename.react.hook.variable.title=重新命名狀態變數
rename.type.members.destructuring.description=檢測到解構屬性中的用法。應重新命名相關屬性，否則可能導致程式碼不一致。
rename.type.members.title=重新命名類型成員
rename.type.members.union.intersection.mapped.description=檢測到聯合體、相交或映射類型用法。應重新命名相關屬性，否則可能導致程式碼不一致。
replace.implements.keyword.fix.name=將 'implements' 更改為 'extends'
required.parameters.are.not.permitted.after.optional.parameters=必選參數不能位於可選參數後
return.type.is.not.resolved=返回值類型 ''{0}'' 未解析。\\n是否繼續?
service.configurable.default={0} (預設)
service.highlighting.progress={0} 服務醒目提示顯示
settings.code.style.Trailing.comma=尾隨逗號(&T):
settings.code.style.always=始終
settings.code.style.dont.use=不使用
settings.code.style.double=雙
settings.code.style.in.new.code=在 IDE 生成的程式碼中
settings.code.style.indent.all.chained.calls.in.a.group=縮排組中的所有鏈式呼叫
settings.code.style.indent.chained.methods=縮排鏈式方法
settings.code.style.option.use=使用
settings.code.style.quotes=引號(&Q)
settings.code.style.semicolon.to.terminate.statements=分號(&S)
settings.code.style.single=單
settings.code.style.use=使用
settings.javascript.field.names.completion=為類別欄位建議名稱 (&F)
settings.javascript.lang.templates.configurable.name=模板
settings.javascript.linters.autodetect.configure.automatically=自動 {0} 組態 (&A)
settings.javascript.linters.autodetect.configure.automatically.help.text={0} 將使用 node_modules 目錄中的 {1} 軟體套件，還會使用與當前檔案或其任何父目錄位於同一目錄中的 {2} 組態檔案。
settings.javascript.linters.autodetect.configure.manually=手動 {0} 組態 (&M)
settings.javascript.linters.autodetect.disabled=停用 {0}(&D)
settings.javascript.linters.configurable.name=程式碼品質工具
settings.javascript.linters.eslint.configurable.name=ESLint
settings.javascript.linters.jshint.configurable.name=JSHint
settings.javascript.only.type.based.completion=僅基於類型補全 (&C)
settings.javascript.only.type.based.completion.tooltip=根據類型資訊顯示較少的補全建議。可能會顯著提高性能。
settings.javascript.opt.chain.completion=為可 null 類型建議包含可選連結的條目(&O)
settings.javascript.overrides.completion=在覆寫補全中展開方法體
settings.javascript.root.configurable.name=JavaScript
settings.javascript.runtime.configurable.name=JavaScript Runtime
settings.javascript.runtime.preferred.runtime.auto-detected.text=自動檢測
settings.javascript.runtime.preferred.runtime.context.help.description=For running and debugging within a project. Language services, ESLint, and tests will still use Node.js
settings.javascript.runtime.preferred.runtime.label.name=Preferred runtime:
settings.javascript.runtime.preferred.runtime.unavailable.text=不可用
settings.javascript.var.names.completion=建議變數和參數名稱(&V)
settings.javascript.var.names.completion.desc=補全名稱
settings.javascript.var.names.completion.names.only=無類型
settings.javascript.var.names.completion.types=為建議的參數名稱新增類型註解(&T)
settings.javascript.var.names.completion.types.everywhere=隨處都是類型
settings.javascript.var.names.completion.types.except.fields=隨處都是類型，欄位除外
settings.javascript.var.names.completion.types.for.params=具有函式參數的類型
settings.javascript.var.names.completion.types.for.params.fields=具有參數和欄位的類型
settings.nodejs.coding.assistance.label=Node.js 編碼協助 (&A):
settings.nodejs.coding.assistance.manage.scopes.label=管理作用域…
settings.nodejs.name=Node.js
settings.typescript.root.configurable.name=TypeScript
space.after.dots.in.rest.spread=在 rest/spread 中的 '…' 後面
space.after.generator.mult=在產生器中的 '*' 後面 
space.after.name.value.separator=在屬性名稱-值分隔符 ':' 後面
space.after.type.colon=在類型參照冒號 ':' 後面
space.before.class.interface.module.lbrace=類別/接口/模組左大括號
space.before.class.lbrace=類別的左大括號
space.before.function.left.parenth=在函式表達式中
space.before.generator.mult=在產生器中的 '*' 前面 
space.before.name.value.separator=在屬性名稱-值分隔符 ':' 前面
space.before.type.colon=在類型參照冒號 ':' 前面
spaces.after.unary.not=在 'not' (!) 和 '!!' 後面
spaces.arrow.function=箭頭函式(=>)
spaces.async.arrow.function=在異步箭頭函式中
spaces.before.unary.not=在 'not' (!) 和 '!!' 前面
spaces.within.array.initializer=陣列中括號
spaces.within.import.braces=ES6 匯入/匯出大括號
spaces.within.indexer.brackets=索引存取中括號
spaces.within.interpolation.expressions=插值表達式
spaces.within.object.literal.braces=物件字面量大括號
spaces.within.object.type.braces=物件字面量類型大括號
spaces.within.type.assertion=類型斷言
spaces.within.unary.additive=一元加法運算符 (+,-,++,--)
spaces.within.union.and.intersection=聯合體與相交類型
standardjs.action.fix.problems.description=修正標準程式碼樣式問題
standardjs.codestyle.updated={0}: 專案程式碼樣式設定已更新
standardjs.codestyle.updated.config.section={0}: 專案程式碼樣式設定已根據 package.json 中的 ''standard'' 部分更新
standardjs.codestyle.updated.dependency={0}: 專案程式碼樣式設定已根據 package.json 中的 ''standard'' 相依項更新
standardjs.edit.settings.caption=ESlint/標準程式碼樣式
standardjs.editor.notification.action=是
standardjs.editor.notification.can.be.enabled.text=為此專案使用 JavaScript 標準程式碼樣式?
standardjs.editor.notification.do.not.show.text=否
standardjs.error.unsupported.package=不支持的軟體套件版本。請將 ''Standard'' 軟體套件升級到最低版本 {0}。
standardjs.name=標準程式碼樣式
start.template.string.interpolation.on.typing=鍵入 '$' 時啟動模板字串內插
status.text.add.interpreter.with=使用 {0} 新增解釋器
status.text.javascript.language.service.default.project.errors=顯示專案錯誤
status.text.javascript.language.service.suggestions=顯示建議
status.text.no.interpreters.added=未新增解釋器
status.text.project.structure.isn.t.available=專案結構不可用
status.text.running.which.node=正在執行 \`which node\`…
status.text.service.doesn.t.contain.open.projects=服務不包含開放專案
status.text.service.is.not.started=服務未啟動
structural.search.anonymous.functions=匿名函式
structural.search.classes=類別
structural.search.comparison.to.self=與自身比較
structural.search.console.log.calls=呼叫 console.log()
structural.search.constants=常數
structural.search.empty.functions=空函式
structural.search.function.calls=函式呼叫
structural.search.functions=函式
structural.search.functions.with.boolean.parameters=使用布爾參數的函式
structural.search.var.statements=Var 語句
structural.search.variables=變數
structural.search.while.loops=While 迴圈
structural.search.with.statements=With 語句
successfully.downloaded=已成功下載
superclass.cannot.be.extracted.from.enum=無法從枚舉中提取超類別
superclass.cannot.be.extracted.from.mxml.component=無法從 MXML 元件中提取超類別。
superclass.cannot.be.extracted.from.type.alias=無法從類型別名中提取超類別
superclass.label.text=超類別(&S):
tab.title.compile.errors=編譯錯誤
tab.title.convert.to.class=轉換為類別
tab.title.project.errors=專案錯誤
tab.title.refactoring.preview=重構預覽
tab.title.refactoring.result=重構結果
template.add.imports=新增明確的 import
terminal.add_node_modules_bin_to_path.label=將 ''node_modules/.bin'' 從專案根目錄新增到 {0}
testing.select.in.test.tree.name=在測試樹中選擇 ''{0}''
testing.snapshot.update.all.tests.text=<link>點擊以更新所有失敗的快照</link>
testing.snapshot.update.single.test.text=<link>點擊以更新 ''{0}'' 的快照</link>
testing.snapshot.update.test.file.text=<link>點擊以更新 {0} 中所有失敗的快照</link>
text.cannot.download=無法下載 {0}。{1}
text.html.front.end.template.a.href.http.html5boilerplate.com=<html>前端模板<a href='http://html5boilerplate.com'>http://html5boilerplate.com</a></html>
text.html.sleek.intuitive.and.powerful.front.end.framework=<html>整潔、直觀、強大的前端框架，更快、更輕鬆地進行 Web 開發 <a href='http://getbootstrap.com'>http://getbootstrap.com</a></html>
titled.separator.predefined=預定義
top.level.package=頂層軟體套件
ts.add.import.all.family.name=新增所有 import
ts.add.import.hint.all.part=或全部使用 {0} 匯入
ts.add.import.hint.multiple.text=使用  {1} 為 {0} 新增匯入
ts.add.import.hint.text=使用 {1} 新增 {0}
ts.add.import.statement.dialog.title=新增 import 語句
ts.change.import.action.command=更改匯入
ts.change.import.action.dialog.title=匯入自…
ts.change.import.action.family.name=更改 ES6 匯入路徑
ts.change.import.action.many.title=更改匯入…
ts.change.import.action.one.title=更改為 {0}
ts.convert.alias.to.enum.action.family.name=將類型別名轉換為枚舉
ts.convert.alias.to.enum.action.title=將別名轉換為枚舉
ts.convert.alias.to.interface.action.family.name=將類型別名轉換為接口
ts.convert.alias.to.interface.action.title=將別名轉換為接口
ts.convert.field.to.parameter.property=將欄位轉換為參數屬性
ts.convert.parameter.property.to.field=將參數屬性轉換為欄位
ts.generate.reference.path.name=生成參照路徑註釋
ts.param.hints.blacklist.pattern.explanation=<b>棄用通知</b>: <p style="margin-left: 5px">從 TypeScript 4.4 開始，<code>provideInlayHints</code> 服務方法用於呈現提示。該方法有自己的啟發式方法；因此，不再使用此排除列表。
ts.param.hints.show.names.for.literal.args=字面量實參
ts.switch.to.jsx.inspection.name=更改檔案擴展名為 .tsx
ts.unresolved.variable.inspection.name=未解析的 TypeScript 參照
type.annotations=類型註解
type.is.not.resolved=類型 ''{0}'' 未解析。\\n是否繼續?
typescipt.import.options.paths.help=此選項用於組態 import 語句中使用的路徑樣式。<br><br>選擇“始終”時，IDE 會始終使用來自 tsconfig.json 組態的別名。<br><br>選擇“僅在指定路徑之外的檔案中”時，IDE 會為已定義別名的檔案之間的 import 使用相對路徑。在所有其他檔案中，將使用路徑映射。<br><br>選擇“從不”時，將從不使用別名。
typescript.abstract.class.constructor.can.be.made.protected=抽象類別建構函式可以設為 protected
typescript.auto.import.options.add.imports=自動新增 TypeScript import
typescript.before.task.check.errors=檢查錯誤
typescript.before.task.config.dialog.title=選擇 tsconfig.json
typescript.before.task.config.path=組態檔案:
typescript.before.task.title=TypeScript 編譯設定
typescript.code.style.tab.name=TypeScript
typescript.compiler.action.compile.all=全部編譯
typescript.compiler.action.compile.all.compile.config=組態 {0} 的編譯檔案
typescript.compiler.action.compile.all.description=編譯所有專案檔案
typescript.compiler.action.compile.current=編譯當前檔案
typescript.compiler.action.compile.description=編譯當前專案
typescript.compiler.action.compile.simple=編譯 TypeScript
typescript.compiler.action.compile.toolbar=編譯
typescript.compiler.action.compile.with.ellipsis=編譯…
typescript.compiler.action.no.compile.message=檔案未編譯，因為沒有從主檔案參照
typescript.compiler.before.run=編譯 TypeScript
typescript.compiler.configurable.name=TypeScript
typescript.compiler.configurable.options.command.line=選項:
typescript.compiler.configurable.options.command.line.localeNotSupportedForBundled=捆綁的 TypeScript 不支持區域設定
typescript.compiler.configurable.options.info.tsGo.local=<div>要使用本地克隆的 <a href='https://github.com/Microsoft/typescript-go/'>TypeScript-Go</a>，請先根據<a href='https://github.com/microsoft/typescript-go?tab=readme-ov-file#how-to-build-and-run'>說明</a>進行建置。</div><div>或者，您可以嘗試使用 <a href='https://github.com/microsoft/typescript-go?tab=readme-ov-file#preview'><code>@typescript/native-preview</code></a> 軟體套件。</div>
typescript.compiler.configurable.options.track.file.system=在更改時重新編譯
typescript.compiler.configurable.options.use.servicePoweredTypeEngine=啟用服務驅動的類型引擎
typescript.compiler.configurable.options.use.servicePoweredTypeEngine.comment=一種混合機制，結合了內部 IDE 模型<br>和語言服務的強大功能，以提高性能和類型推斷。<br>設定時需要啟用語言服務。
typescript.compiler.configurable.options.use.types.from.server=使用伺服器中的類型
typescript.compiler.configurable.options.use.types.from.server.description=啟用基於 TypeScript 編譯器的評估。
typescript.compiler.configurable.options.use.types.from.server.tsGoWarning=“啟用服務驅動的類型引擎”將被忽略，因為其尚不支持 TypeScript-Go
typescript.compiler.configurable.options.use.types.from.server.versionWarning=“啟用服務驅動的類型引擎”將被忽略，因為所選 TypeScript 版本低於 4.5
typescript.compiler.configurable.options.version=TypeScript:
typescript.compiler.configurable.options.version.bundled=已捆綁
typescript.compiler.loading.project=正在載入專案 {0}
typescript.compiler.starting=TypeScript 正在啟動…
typescript.compiler.structure.tab.title=結構
typescript.config.inspection=不一致的 Tsconfig.json 屬性
typescript.config.inspection.checkjs.info=屬性 checkJs 需要 allowJs 屬性
typescript.config.inspection.config.options.fix=向 tsconfig.json 中新增 ''{0}''
typescript.config.inspection.fix.pattern=新增 ''{0}'' 屬性
typescript.config.inspection.libs=缺少全域類別庫
typescript.config.inspection.libs.fix=在 tsconfig.json 中啟用庫 ''{0}''
typescript.config.inspection.missing.option=缺少 tsconfig.json 選項 
typescript.duplicate.typescript.union.inspection.name=重複的聯合體或相交類型元件
typescript.explicit.member.type.inspection.name=顯式類型
typescript.export.assignment.cannot.be.used.in.internal.modules=匯出不能在內部模組中使用的指派
typescript.field.can.be.made.readonly=可以為唯讀欄位
typescript.fix.change.member.access=設為 ''{0}''
typescript.generics.should.not.be=類型 ''{0}'' 非泛型
typescript.go.bad.package=在 {0} 中找不到 TypeScript-Go 軟體套件
typescript.go.name=TypeScript-Go
typescript.import.options.exts.help=此選項用於組態 import 語句中的副檔名。<br><br>選擇“自動”時，IDE 會始終向 vue 檔案、來自在 tsconfig.json 中具有 "module": "node16" 或 "module": "nodenext" 和在 package.json 中具有 "type": "module" 的專案的檔案，以及擴展名為 .mts 的檔案的名稱新增副檔名。<br><br>選擇“始終”時，IDE 會始終向 TypeScript 檔名新增 .js 副檔名。<br><br>選擇“從不”時，IDE 會始終使用不帶副檔名的檔名。
typescript.import.options.paths=使用 tsconfig.json 的路徑映射:
typescript.import.options.use.config=使用相對於 tsconfig.json 的路徑
typescript.include.js.sources.dialog.message=是否在此專案中包含 ''{0}'' 中的 JavaScript 檔案?
typescript.include.js.sources.dialog.title=包括軟體套件 {0}
typescript.include.js.sources.element=搜尋 JavaScript 宣告
typescript.insert.cast.fix=插入類型斷言
typescript.insert.type.guard.fix.family=插入類型 guard
typescript.insert.type.guard.nc=將限定符取代為 ''{0}''
typescript.insert.type.guard.nc.self=取代為 ''{0}''
typescript.insert.type.guard.postfix=使用 ''{0}'' 進行可選查詢
typescript.insert.type.guard.prefix=前綴為 ''{0}''
typescript.insert.type.guard.surround=封閉在 ''{0}''中
typescript.inspection.group.name=TypeScript
typescript.intention.convert.import.require=將 import require 轉換為 import from
typescript.intention.convert.import.require.text=轉換為 {0}
typescript.language.service.clean=正在重設快取…
typescript.language.service.compile.file=正在編譯檔案… {0}
typescript.language.service.compile.file.errors=正在計算錯誤… {0}
typescript.language.service.compile.project=正在編譯專案… {0}
typescript.language.service.compile.project.errors=正在計算專案錯誤… {0}
typescript.language.service.compile.project.open.file=正在開啟檔案… {0}
typescript.language.service.name=TypeScript 服務
typescript.language.simple.name=TypeScript
typescript.make.constructor.protected=將建構函式設為 protected
typescript.make.field.readonly=將欄位設為唯讀
typescript.missing.augmentation.import=缺少擴大匯入
typescript.narrowed.to=範圍限縮至 ''{0}''
typescript.private.field.modifiers.mix=使用不公開名稱的欄位不能具有 'public'、'private' 或 'protected' 存取修飾符
typescript.redundant.declaration=類型宣告與推斷的類型相符合，因此可以移除
typescript.redundant.instanceof.guard=''instanceof'' 檢查冗餘: ''{0}'' 具有類型 ''{1}'' 或 ''{1}'' 的子類型
typescript.redundant.instanceof.inheritor.guard=''instanceof'' 檢查冗餘: ''{0}'' 具有類型 ''{1}'' 或 ''{1}'' 的繼承者
typescript.redundant.typescript.type.argument.inspection.name=冗餘類型實參
typescript.reference.to.umd.global=已參照的 UMD 全域變數
typescript.remove.type.declaration=移除類型宣告
typescript.rename.dynamic.references=搜尋動態參照 (&D)
typescript.rename.javascript.references=在 JavaScript 檔案中搜尋(&J)
typescript.service.no.config=檔案未包括在任何 tsconfig.json 中
typescript.service.no.main.reference=檔案未處理，因為沒有從主檔案參照
typescript.smart.cast=範圍限縮的類型
typescript.smart.cast.hyperlink=設定字體和背景
typescript.specify.all.param.types.explicitly=顯式指定所有參數類型
typescript.specify.type.explicitly=顯式指定類型
typescript.suspicious.constructor.parameter.assignment=建構函式中的參數指派可疑。您是否忘記了新增 'this.'?
typescript.suspicious.constructor.parameter.assignment.desc=已分配建構函式欄位參數
typescript.suspicious.instanceof.guard=''instanceof'' 檢查無效: ''{0}'' 的類型與 ''{1}'' 無關
typescript.type.guard.name=變數類型限縮為類型 guard
typescript.type.guard.name.disable=停用範圍限縮的類型的著色
typescript.type.predicate.destructuring=類型謂詞不能參照綁定模式中的元素。
typescript.type.predicate.incompatible.types=類型謂詞不可分配給 {0}
typescript.type.predicate.not.match.name=找不到參數 {0}
typescript.type.predicate.not.return=僅函式和方法的返回值類型位置允許類型謂詞
typescript.type.predicate.rest=類型謂詞不能參照 rest 參數
typescript.type.this.predicate.not.return=僅類別或接口成員、get 存取器或函式和方法的返回值類型位置允許基於 'this' 類型的謂詞。
typescript.types.intersection=相交
typescript.types.key=鍵參照
typescript.types.mapped=映射
typescript.types.merged=已合併
typescript.types.merged.accessor=合併存取器
typescript.types.merged.parts=參照的屬性:
typescript.types.module.not.installed.warning=無法解析模組 ''{0}'' 的定義
typescript.types.type.member={0} 類型屬性
typescript.types.union=聯合體
typescript.validate.generic.types.fix.add=新增泛型實參
typescript.validate.generic.types.fix.delete=移除泛型實參
typescript.validate.generic.types.inspection.error.argument.number=泛型類型 ''{0}'' 需要 ''{1}'' 類型實參
typescript.validate.generic.types.inspection.error.argument.number.between=泛型類型 ''{0}'' 需要介於 {1} 和 {2} 之間的類型實參
typescript.validate.generic.types.inspection.error.not.empty.argument=類型實參列表不能為空
typescript.validate.generic.types.inspection.error.not.empty.parameter=類型參數列表不能為空
typescript.validate.generic.types.inspection.name=不正確的泛型實參
typescript.validate.optional.parameter.inspection.error=參數不能有問號和初始設定式
typescript.validate.optional.parameter.inspection.fix.question=移除問號
typescript.validate.template.literal.types=模板類型 {1} 不可分配給約束類型 {0}
typescript.validation.async.incorrect.type.annotation=異步函式不能有 ''{0}'' 類型註解
typescript.validation.cannot.find.best.common.type=無法從用法推斷類型實參
typescript.validation.class.extend.constructor.return.not.class=基類別建構函式返回值類型 ''{0}'' 不是類別或接口類型。
typescript.validation.class.extend.cycled.definition=迴圈類別定義
typescript.validation.class.extend.many.constructors=基類別建構函式必須具有相同的返回值類型
typescript.validation.class.extend.no.type.arguments.type=沒有任何基類別建構函式具有指定數量的類型實參
typescript.validation.class.extend.not.constructor.type=類型 ''{0}'' 不是建構函式類型
typescript.validation.dissatisfies.type.annotation=類型 ''{0}'' 不滿足預期類型 ''{1}''
typescript.validation.expressionWithTypeArguments.compatibleSignatureNotFound=找不到相容的簽名
typescript.validation.generators.ambient=環境上下文中不允許使用產生器
typescript.validation.generators.async.no.yield=產生器隱式具有類型 'AsyncIterableIterator<any>'，因為它不產生任何值。請考慮提供返回值類型。
typescript.validation.generators.incorrect.type.annotation=發生器不能有 ''{0}'' 類型註解
typescript.validation.generators.incorrect.type.annotation.iterable=類型 ''{0}'' 不可分配給類型 ''{1}''。
typescript.validation.generators.no.yield=產生器隱式具有類型 'IterableIterator<any>'，因為它不產生任何值。請考慮提供返回值類型。
typescript.validation.generators.overload=多載簽名無法被宣告為產生器
typescript.validation.incorrect.rhs.in.private.brand=右側必須是一個物件，實際為: ''{0}''
typescript.validation.message.abstract.cannot.be.used=''{0}'' 修飾符不能與 ''abstract''修飾符一起使用
typescript.validation.message.abstract.cannot.have.body=方法不能具有實作，因為它被標記為 'abstract'
typescript.validation.message.abstract.class.be.created=無法建立抽象類別 ''{0}'' 的執行個體
typescript.validation.message.abstract.class.should.be=abstract 方法只能出現在抽象類別中
typescript.validation.message.abstract.member.access.super=無法通過 super 表達式存取 abstract 方法 ''{0}''。
typescript.validation.message.abstract.overload=多載簽名必須全部為 abstract 或非 abstract。
typescript.validation.message.constructor.cannot.be.abstract=建構函式不能為 'abstract'
typescript.validation.message.duplicate.modifier=已看到修飾符 {0}
typescript.validation.message.duplicate.modifier2=已看到可存取性修飾符
typescript.validation.message.function.implementation.missing=缺少函式實作或此宣告之後未緊隨函式實作
typescript.validation.message.getter.and.setter.must.have.same.access.type=Getter 和 setter 必須具有相同的存取類型
typescript.validation.message.invalid.modifier.cannot.be.here=修飾符 {0} 不能出現在此處
typescript.validation.message.invalid.module.member.modifier=''{0}'' 不是模組成員的有效修飾符
typescript.validation.message.misordered.in.modifier='in' 修飾符必須在 'out' 修飾符之前。
typescript.validation.message.unexpected.type.for.rest.parameter=Rest 參數必須為數組類型或具有陣列約束的泛型
typescript.validation.message.unexpected.type.for.rest.parameter.fix=取代為數組類型
typescript.validation.message.unique.symbol.mutable.non.static.field.declaration=類型為 'unique symbol' 類型的類別的屬性必須同時為 'static' 和 'readonly'
typescript.validation.message.unique.symbol.mutable.non.static.field.declaration.fix.add.static.readonly=新增 static 和 readonly 修飾符
typescript.validation.message.unique.symbol.mutable.property.signature=如果接口或類型字面量的類型是 'unique symbol' 類型，則其屬性必須為 'readonly'
typescript.validation.message.unique.symbol.mutable.variable=類型為 'unique symbol' 類型的變數必須為 'const'
typescript.validation.message.unique.symbol.wrong.usage=此處不允許使用 'unique symbol' 類型
typescript.validation.module.reference.with.extension=外部模組參照不能以擴展結束
unnecessary.parentheses.display.name=不必要的圓括號
unnecessary.parentheses.problem.descriptor=<code>#ref</code> 周圍的圓括號不必要 #loc
unresolved.project.interpreter.notification.content=要正常工作，{0} 需要 Node.js，但在您的電腦上找不到 Node.js。
unresolved.project.interpreter.notification.download.action.text=下載 Node.js
unresolved.project.interpreter.notification.download.action.url=https://nodejs.org/en/download
unwrap.with.kind=解包 ''{0}…''
variables.and.fields=變數和欄位
variables.and.fields.description=變數和欄位
varible.name.column.title=名稱
varible.value.column.title=值
visibility.level.details=詳細資訊
visibility.level.overview=概覽
vitest.coverage.cannot.copy.lcov.info.notification.content=無法顯示 Vitest 覆蓋率: 無法複製檔案。
vitest.coverage.cannot.find.lcov.info.notification.content=無法顯示 Vitest 覆蓋率: 找不到 {0}。
vitest.coverage.directory.not.found.notification.content=無法從 Vitest 組態中讀取 coverageDirectory 選項
vitest.coverage.notification.title=Vitest 覆蓋率
vitest.coverage.presentable.text=Vitest 覆蓋率
vitest.rc.configurationFile.label=組態檔案(&C):
vitest.rc.configurationFile.title=選擇 Vitest 組態檔案
vitest.rc.vitestOptions.emptyText=CLI 選項，例如 --watch 或 --ui
vitest.rc.vitestOptions.label=Vitest 選項:
vitest.rc.vitestPackageField.label=Vitest 軟體套件(&V):
vitest.snapshot.update.rc.name=更新 {0} 的快照
web.bundler.analyzing.configs.progress=正在分析 Web 捆綁程序的組態檔案
web.bundler.cannot.analyze=無法分析 {0}: 編碼輔助將忽略此檔案中的模組解析規則。
web.bundler.error.details=錯誤詳細資訊: {0}
web.bundler.failed.to.load=無法載入 {0}
web.bundler.possible.reasons=可能的原因: 此檔案不是有效的組態檔案，或者 IDE 目前不支持其格式。
web.template.file-type.description={0} 模板
yarn.package_requires_yarn.dialog.message=軟體套件“{0}”要求 Yarn {1}。
yarn.pnp.library_name=來自 {0} 的相依項
yarn.pnp.requires.yarn.package_manager.dialog.message=Yarn PnP 需要 Yarn <a href="">軟體套件管理器</a>
{0}.visibility.will.break.methods.hierarchy=可見性為 {1} 的{0}無法參與層次結構"
`;

exports[`dev messages/PhpBundle.properties 1`] = `
"0=\\ ({0})
0.1={0}，{1}
0.1.choice.0.extends.1.implements.2={0}{1, choice, 0# 擴展 |1# 執行 }{2}
0.12={0}:{1}
0.and.1.define.the.same.property.2=''{0}'' 和 ''{1}'' 定義相同的屬性 ''{2}''
0.by.remote.interpreter=通過遠端解釋器{0}
0.completion.shortcut=使用{1}進行{0}補全
0.extends.1={0} 擴展 {1}
0.for.1.run.configuration={1} 執行組態的 {0}
0.local={0}本地
0.location={0} 位置
0.path={0} 路徑:
0.pushing.members.down.will.result.in.them.being.deleted={0}\\n向下推送成員將導致它們被刪除
0.should.not.extend.itself={0} 不應自行擴展
0.with.same.name.already.defined.in.this.class=此類別中已經定義了具有相同名稱的{0}
02={0}::
03=({0})
04={0}:
12.hour.format.of.an.hour.with.leading.zeros=帶前導零的 12 小時格式小時(01 到 12)
12.hour.format.of.an.hour.without.leading.zeros=不帶前導零的 12 小時格式小時(1 到 12)
24.hour.format.of.an.hour.with.leading.zeros=帶前導零的 24 小時格式小時(00 到 23)
24.hour.format.of.an.hour.without.leading.zeros=不帶前導零的 24 小時格式小時(0 到 23)
DBGPProxyConfigurable.display.name=DBGp 代理
DBGPProxyConfigurable.host=主機:
DBGPProxyConfigurable.ide.key=IDE 鍵:
DBGPProxyConfigurable.port=連接埠:
PhpBuiltInWebServerRunConfigurationEditor.configuration.description=PHP 內建 Web 伺服器組態
PhpBuiltInWebServerRunConfigurationEditor.configuration.display.name=PHP 內建 Web 伺服器
PhpBuiltInWebServerRunConfigurationEditor.document.root=文檔根:
PhpBuiltInWebServerRunConfigurationEditor.host=主機:
PhpBuiltInWebServerRunConfigurationEditor.port=連接埠:
PhpBuiltInWebServerRunConfigurationEditor.title=伺服器組態
PhpBuiltInWebServerRunConfigurationEditor.use.router.script=使用 router 腳本:
PhpCommandLineConfigurationEditor.command.line=命令行
PhpCommandLineConfigurationEditor.field.custom.working.directory=自訂工作目錄:
PhpCommandLineConfigurationEditor.field.environment.variables=環境變數:
PhpCommandLineConfigurationEditor.field.interpreter.options=解釋器選項:
PhpCommandLineConfigurationEditor.interpreter.options.editor.dialog.caption=解釋器選項
PhpDebugConfigurable.advanced.settings=進階設定
PhpDebugConfigurable.break.at.first.line=在 PHP 腳本中的第一行中斷
PhpDebugConfigurable.detect.path.mappings.from.deployment=檢測部署組態的路徑映射
PhpDebugConfigurable.evaluation=評估
PhpDebugConfigurable.external.connections=外部連線
PhpDebugConfigurable.ignore.external.connections.through.unregistered.server.configurations.label=通過未註冊的伺服器組態忽略外部連線
PhpDebugConfigurable.import.use.statements=從求值上下文匯入命名空間和 'use' 語句
PhpDebugConfigurable.notify.resolved.breakpoint=通知是否將中斷點解析為另一行(Xdebug 2.8+)
PhpDebugConfigurable.notify.session.stopped.without.pause=在偵錯會話完成而不暫停時通知
PhpDebugConfigurable.pass.required.configuration.options=通過命令行傳遞所需組態選項(仍需要手動啟用偵錯擴展)
PhpDebugConfigurable.remote.debug.listen.for.connections=3. 啟動“PHP 遠端偵錯”執行組態。
PhpDebugConfigurable.safe.evaluation.mode=值提示和監視框架下的安全求值模式
PhpDebugConfigurable.show.array.children.in.repl=在偵錯主控台中顯示陣列和物件子級
PhpDebugConfigurable.web.page.listen.for.connections=2. 啟動“PHP 網頁”執行組態。
PhpDebugConfigurable.web.page.pre.config.title=偵錯預組態
PhpDebugConfigurable.xdebug=Xdebug
PhpDebugConfigurable.xdebug.debug.port=Xdebug 偵錯連接埠
PhpDebugConfigurable.xdebug.force.break.no.path.mapping=未指定路徑映射時，在第一行強制中斷
PhpDebugConfigurable.xdebug.force.break.when.outside.project=當腳本在專案外部時，在第一行強制中斷
PhpDebugConfigurable.xdebug.resolve.breakpoints=如果中斷點在當前行不可用，則解析中斷點(Xdebug 2.8+)
PhpDebugConfigurable.zend.debug.port=Zend Debugger 偵錯連接埠
PhpDebugConfigurable.zend.debugger=Zend 偵錯器
PhpDebugConfigurable.zend.settings.broadcasting.port=Zend Debugger 設定廣播連接埠
PhpDebugConfigurable.zend.settings.ide.hosts=Zend Debugger IDE 主機
PhpDebugConfigurable.zend.settings.ide.hosts.detect=正在檢測…
PhpDebugConfigurable.zend.settings.ide.hosts.detect.progress=正在檢測 Zend Debugger 的 IP…
PhpDebugConfigurable.zero.configuration=預組態
PhpDebugConfigurable.zero.configuration.install.debugger.php.instruction=1. 安裝
PhpDebugConfigurable.zero.configuration.install.php.instruction=或
PhpDebugConfigurable.zero.configuration.install.php.validate=Web 伺服器上的偵錯器組態。
PhpDebugConfigurable.zero.configuration.install.php.validate.action=驗證
PhpDebugConfigurable.zero.configuration.install.toolbar.instruction=瀏覽器工具列或小書籤。
PhpDebugConfigurable.zero.configuration.install.toolbar.instruction.label=2. 安裝
PhpDebugConfigurable.zero.configuration.install.xdebug.php.instruction=Xdebug
PhpDebugConfigurable.zero.configuration.install.zend.debugger.php.action=Zend 偵錯器
PhpDebugConfigurable.zero.configuration.install.zend.debugger.php.instruction=在 Web 伺服器上。
PhpDebugConfigurable.zero.configuration.listen.for.connections=3. 啟用 PHP 偵錯連線偵聽:
PhpDebugConfigurable.zero.configuration.listen.for.connections.action=開始偵聽
PhpDebugConfigurable.zero.configuration.start.session=4. 使用工具列或小書籤在瀏覽器中啟動偵錯會話。
PhpDebugConfigurable.zero.configuration.stop.listen.for.connections.action=停止偵聽
PhpDebugConfigurable.zero.configuration.tutorial=有關更多資訊，請參見
PhpDebugConfigurable.zero.configuration.tutorial.action=“零組態偵錯”教程
PhpDebugSkippedPathsConfigurable.column.title=跳過的路徑
PhpDebugSkippedPathsConfigurable.display.name=跳過的路徑
PhpDebugSkippedPathsConfigurable.notify.about.skipped.files=通知跳過的檔案
PhpExtractMethodDialog.declare.static=宣告 static(&S)
PhpExtractMethodDialog.duplicates.count=檢查並取代重複項(找到 {0} 個)
PhpExtractMethodDialog.duplicates.pending=正在搜尋重複項…
PhpExtractMethodDialog.extract.function=提取函式
PhpExtractMethodDialog.extract.method=提取方法
PhpExtractMethodDialog.function=函式:
PhpExtractMethodDialog.generate.php.doc=生成 PhpDoc(&G)
PhpExtractMethodDialog.generate.php.doc.inplace=生成 PHPDoc
PhpExtractMethodDialog.method=方法:
PhpExtractMethodDialog.name=名稱(&A):
PhpExtractMethodDialog.output.variables=輸出變數
PhpExtractMethodDialog.parameters=參數
PhpExtractMethodDialog.private=private(&V)
PhpExtractMethodDialog.protected=protected(&T)
PhpExtractMethodDialog.public=public(&B)
PhpExtractMethodDialog.replace.tail.break.continue.with.return=將尾“break/continue”語句取代為“return”語句(&T)
PhpExtractMethodDialog.return.output.through=通過以下方式返回輸出變數:
PhpExtractMethodDialog.return.output.through.ref.parameters=通過參照傳遞的參數(&P)
PhpExtractMethodDialog.return.output.through.return=return 語句(&E)
PhpExtractMethodDialog.signature.preview=簽名預覽
PhpExtractMethodDialog.transformation.options=轉換選項
PhpExtractMethodDialog.visibility=可見性:
PhpFrameworksCommonConfigurable.display.name=框架
PhpHttpRequestRunConfiguration.configuration.description=HTTP 請求組態
PhpHttpRequestRunConfiguration.configuration.display.name=PHP HTTP 請求
PhpHttpRequestRunConfiguration.error.fetch.result=響應正文不可用
PhpHttpRequestRunConfiguration.error.host.is.not.specified=伺服器 ''{0}'' 的主機未指定或無效
PhpHttpRequestRunConfiguration.error.server.configuration=無法執行 HTTP 請求: ''{0}''。請在“PHP|伺服器”下檢查伺服器組態。
PhpHttpRequestRunConfiguration.error.server.is.not.specified=找不到名稱為 ''{0}'' 的遠端伺服器
PhpHttpRequestRunConfiguration.error.url.is.not.specified=URL 未指定或無效: ''{0}''。
PhpIncomingConnectionDialog.file.path.on.server=伺服器上的檔案路徑:
PhpIncomingConnectionDialog.request.uri=請求 URI:
PhpIncomingConnectionDialog.server.name=伺服器名稱:
PhpIncomingConnectionDialog.server.port=伺服器連接埠:
PhpIncomingLocalConnectionDialog.file.path=檔案路徑:
PhpInterpreter.configuration.duplicate.interpreter.name=找到了具有非唯一名稱 ''{0}'' 的 PHP 解釋器。
PhpInterpreter.configuration.in.project.settings.message=無法將 PHP 解釋器指定為預設 SDK。您可以在“設定| PHP”中為當前專案組態
PhpInterpreter.configuration.in.project.settings.title=PHP 解釋器組態
PhpInterpreter.configuration.interpreter.is.invalid=啟用“PHP Remote Interpreters”延伸模組以編輯解釋器。
PhpInterpreter.configuration.selection.list.title=選擇 CLI 解釋器
PhpInterpreter.php.debugger.label=偵錯器:
PhpInterpreter.php.dependent.configuration.exists=所選 PHP 解釋器有{0}組態。確定要刪除此解釋器嗎?
PhpInterpreter.php.dependent.configuration.exists.title=PHP 解釋器相依組態
PhpInterpreter.php.general.title=一般
PhpInterpreter.php.home.path.label=PHP 可執行檔案:
PhpInterpreter.php.interpreter.name.conflict=發現專案級和應用程式級解釋程序名稱存在衝突。為解決該問題，以下專案級解釋器被重新命名:
PhpInterpreter.php.interpreter.name.conflict.title=解釋器名稱衝突
PhpInterpreter.php.sdk.type=PHP 解釋器
PhpInterpreterConfigurable.can.not.updated.phpinfo=無法更新 phpinfo
PhpInterpreterConfigurable.configuration.default.project.tooltip=無法僅為預設專案儲存解釋器。
PhpInterpreterConfigurable.configuration.file.can.not.find=無法通過路徑找到檔案: ''{0}''
PhpInterpreterConfigurable.configuration.file.can.not.find.title=找不到組態檔案
PhpInterpreterConfigurable.configuration.file.evaluate.dir=正在評估組態檔案目錄…
PhpInterpreterConfigurable.configuration.file.fix=在 {0} 目錄中建立 php.ini 檔案，<br><br>組態檔案模板可在 php 根目錄中找到:<br>“php.ini-development”- 預設設定<br>“php.ini-production”- 推薦設定。<br>
PhpInterpreterConfigurable.configuration.file.fix.failed.to.detect=使用“{0} --ini”指令確定組態檔案目錄。<br>
PhpInterpreterConfigurable.configuration.file.fix.link=<br>點擊此<a href="http://php.net/manual/en/configuration.file.php">連結</a>獲取更多資訊。
PhpInterpreterConfigurable.configuration.file.fix.title=組態 php.ini 檔案不存在
PhpInterpreterConfigurable.configuration.file.hhvm.fix=在 <b>/etc/hhvm</b> 目錄中建立 php.ini 檔案，<br><br>點擊此<a href="http://docs.hhvm.com/manual/en/configuration.file.php">>連結</a>獲取更多資訊。
PhpInterpreterConfigurable.configuration.file.path=組態檔案: {0}
PhpInterpreterConfigurable.configuration.file.path.not.found=組態 php.ini 檔案不存在
PhpInterpreterConfigurable.configuration.options.description=這些選項將使用 '-d' 命令行選項傳遞
PhpInterpreterConfigurable.configuration.options.dialog.caption=組態選項
PhpInterpreterConfigurable.configuration.options.label=組態選項:
PhpInterpreterConfigurable.configuration.options.table.empty.text=為 php.ini 中允許的任何組態指令設定自訂值
PhpInterpreterConfigurable.configuration.options.table.name=組態指令
PhpInterpreterConfigurable.configuration.options.table.value=值
PhpInterpreterConfigurable.configuration.options.with.empty.name.are.not.allowed=不允許名稱為空的組態選項
PhpInterpreterConfigurable.configuration.project.level=僅對此專案可見
PhpInterpreterConfigurable.configuration.project.tooltip=檢查是否不想在專案之間共享解釋器
PhpInterpreterConfigurable.configuration.title=其他
PhpInterpreterConfigurable.debugger.extension.description=將僅為從 CLI 執行組態啟動的偵錯會話載入偵錯器擴展
PhpInterpreterConfigurable.debugger.extension.label=偵錯器擴展:
PhpInterpreterConfigurable.debugger.extension.title=選擇偵錯器擴展路徑
PhpInterpreterConfigurable.download.xdebug.extension=下載 Xdebug 擴展程序
PhpInterpreterConfigurable.generate.xdebug.extension=生成安裝腳本
PhpInterpreterConfigurable.install.xdebug.extension=下載並安裝 Xdebug 擴展程序
PhpInterpreterConfigurable.not.installed=未安裝
PhpInterpreterConfigurable.php.ini.title=選擇組態檔案或目錄
PhpInterpreterConfigurable.php.version=PHP 版本: {0}
PhpInterpreterConfigurable.reload.phpinfo=重新載入 phpinfo
PhpInterpreterConfigurable.show.phpinfo=顯示 phpinfo
PhpInterpreterConfigurable.update.helpers.title=正在更新幫助程序目錄…
PhpInterpreterConfigurable.updated.phpinfo=已成功更新 phpinfo
PhpInterpreterConfigurable.xdebug.was.not.installed=Xdebug 安裝失敗
PhpInterpreterConfigurable.xdebug.was.successfully.installed=Xdebug 已成功安裝
PhpPathMappingsConfigurable.use.path.mappings.label=使用路徑映射(選擇伺服器是遠端伺服器還是使用符號連結)
PhpProjectConfigurable.advanced.settings=進階設定(&V)
PhpProjectConfigurable.analysis=分析
PhpProjectConfigurable.analysis.custom.format.functions=自訂格式函式
PhpProjectConfigurable.default.stubs.path=預設存根路徑(&D):
PhpProjectConfigurable.docker.default.project.error.tooltip=開啟或建立專案以組態 Docker 容器
PhpProjectConfigurable.exception.analysis=異常分析
PhpProjectConfigurable.exception.analysis.depth=呼叫樹分析路徑:
PhpProjectConfigurable.exception.analysis.unchecked.exceptions=未檢查的異常:
PhpProjectConfigurable.include.analysis=Include 分析
PhpProjectConfigurable.include.path=Include 路徑
PhpProjectConfigurable.interpreter=CLI 解釋器:
PhpProjectConfigurable.language.level=PHP 語言級別(&P):
PhpProjectConfigurable.php.runtime=PHP 執行時
PhpProjectConfigurable.select.default.stubs.path.description=選擇預設存根路徑
PhpProjectConfigurable.select.default.stubs.path.title=選擇預設存根路徑
PhpProjectConfigurable.select.document.root.path.description=選擇 $_SERVER['DOCUMENT_ROOT'] 路徑
PhpProjectConfigurable.select.document.root.path.title=選擇 $_SERVER['DOCUMENT_ROOT'] 路徑
PhpRemoteDebugRunConfigurationEditor.auto.config=通過 IDE 鍵篩選偵錯連線
PhpRemoteDebugRunConfigurationEditor.configuration.description=PHP 偵錯組態
PhpRemoteDebugRunConfigurationEditor.configuration.display.name=PHP 遠端偵錯
PhpRemoteDebugRunConfigurationEditor.filter.connections.help=適用於複雜伺服器設定，例如同一主機連接埠上有多個應用程式。<p/>保持未選中狀態以自動檢測組態，或使用<i>“偵聽偵錯連線”</i>動作。
PhpRemoteDebugRunConfigurationEditor.filter.connections.help.link=閱讀更多資訊
PhpRemoteDebugRunConfigurationEditor.filter.connections.help.title=進階選項
PhpRemoteDebugRunConfigurationEditor.server.label=伺服器(&E):
PhpRemoteDebugRunConfigurationEditor.session.id.cannot.be.empty=IDE 鍵(會話 ID)不能為空
PhpRemoteDebugRunConfigurationEditor.session.id.label=IDE 鍵(會話 ID)(&K):
PhpRemoteDebugRunConfigurationEditor.stop.zero.configuration=PhpStorm 已停止偵聽傳入偵錯連線。
PhpRemoteDebugRunConfigurationEditor.stop.zero.configuration.title=已停止偵聽傳入 PHP 偵錯連線
PhpRemoteDebugRunConfigurationEditor.zero.configuration.is.already.used=“偵聽傳入偵錯連線”已啟用，不會發生任何變化。<br/>檢視<a href="zero_config">零組態偵錯</a>獲取更多資訊。<br/><br/>要停止偵聽偵錯連線，請使用<a href="stop">執行|停止偵聽 PHP 偵錯連線</a>。
PhpRemoteDebugRunConfigurationEditor.zero.configuration.used=沒有為 <i>''{0}''</i> 執行組態指定<i>伺服器</i>，因此 PhpStorm 將偵聽所有傳入偵錯連線。<br/>檢視<a href="zero_config">零組態偵錯</a>獲取更多資訊。<br/><br/>要停止偵聽偵錯連線，請使用<a href="stop">執行|停止偵聽 PHP 偵錯連線</a>。
PhpRemoteDebugRunConfigurationEditor.zero.configuration.used.title=已開始偵聽傳入 PHP 偵錯連線
PhpScripRunConfigurationEditor.arguments=實參:
PhpScripRunConfigurationEditor.arguments.caption=實參
PhpScripRunConfigurationEditor.configuration.description=PHP 腳本組態
PhpScripRunConfigurationEditor.configuration.display.name=PHP 腳本
PhpScripRunConfigurationEditor.file=檔案:
PhpServerConfigurable.debugger.label=偵錯器(&D)
PhpServerConfigurable.host=主機
PhpServerConfigurable.host.label=主機(&H):
PhpServerConfigurable.port=連接埠
PhpServerConfigurable.port.label=連接埠(&P)
PhpServerConfigurable.shared=共享(&S)
PhpStepFilters.log.frame=框架已被跳過。函式名稱: {0}。遠端檔案 URL: {1}
PhpStepFiltersConfigurable.add.method=新增方法
PhpStepFiltersConfigurable.display.name=步進篩選器
PhpStepFiltersConfigurable.skip.constructors=跳過建構函式
PhpStepFiltersConfigurable.skip.magic.methods=跳過魔術方法
PhpStepFiltersConfigurable.skipped.files=跳過的檔案
PhpStepFiltersConfigurable.skipped.methods=跳過的方法
PhpStepFiltersConfigurable.specify.method.name=指定方法名稱
PhpStepFiltersConfigurable.title.files=檔案
PhpStepFiltersConfigurable.title.methods=方法
PhpUnitConfigurableForm.can.not.find.custom.loader=在 ''{0}'' 下找不到自動載入器腳本
PhpUnitConfigurableForm.can.not.find.paratest=在 ''{0}'' 下找不到 ParaTest
PhpUnitConfigurableForm.can.not.find.phpunit.phar=在 ''{0}'' 下找不到 phpunit.phar
PhpUnitConfigurableForm.custom.loader.is.directory=自動載入器不應為目錄，對於預設 Composer 組態，將路徑設定為“vendor/autoload.php”
PhpUnitConfigurableForm.custom.loader.is.empty=自動載入器檔案的路徑為空
PhpUnitConfigurableForm.default.paratest.binary=預設 ParaTest 二進制檔案:
PhpUnitConfigurableForm.download.phpunit.phar.link.text=從 {0} 下載 phpunit.phar
PhpUnitConfigurableForm.paratest.path=預設 ParaTest 二進制檔案
PhpUnitConfigurableForm.path.to.phpunit.phar=phpunit.phar 路徑
PhpUnitConfigurableForm.path.to.script=腳本路徑:
PhpUnitConfigurableForm.phpunit.library=PHPUnit 庫
PhpUnitConfigurableForm.phpunit.paratest.is.empty=ParaTest 的路徑為空
PhpUnitConfigurableForm.phpunit.phar.is.empty=phpunit.phar 路徑為空
PhpUnitConfigurableForm.specified.wrong.paratest.binary=指定了錯誤的 ParaTest 二進制檔案，請改用 'paratest_for_phpstorm'
PhpUnitConfigurableForm.test.runner=測試執行程序
PhpUnitConfigurableForm.unsupported.paratest.version=<html>安裝的 ParaTest 版本不支持與 PHPStorm 整合。<br>請將 ParaTest 更新到 6.5.0 或更高版本。</html>
PhpUnitConfigurableForm.use.bootstrap.file=預設啟動檔案:
PhpUnitConfigurableForm.use.bootstrap.file.validation.warning=為 ''{0}'' 提供啟動檔案的路徑，或停用“預設啟動檔案”選項
PhpUnitConfigurableForm.use.configuration.file=預設組態檔案:
PhpUnitConfigurableForm.use.configuration.file.validation.warning=為 ''{0}'' 提供組態檔案的路徑，或停用“預設組態檔案”選項
PhpUnitConfigurableForm.use.custom.loader=使用 Composer 自動載入器
PhpUnitConfigurableForm.use.paratest=使用 ParaTest:
PhpUnitConfiguration.interpreter.conflict=發現應用程式級 PHPUnit 組態衝突。為解決該問題，建立了以下組態的專案級副本:
PhpUnitConfiguration.interpreter.conflict.title=PHPUnit 組態衝突
PhpUnitTestRunnerConfigurationEditor.dialog.caption.test.runner.options=測試執行程序選項
PhpUnitTestRunnerConfigurationEditor.field.class=類別:
PhpUnitTestRunnerConfigurationEditor.field.directory=目錄:
PhpUnitTestRunnerConfigurationEditor.field.file=檔案:
PhpUnitTestRunnerConfigurationEditor.field.method=方法:
PhpUnitTestRunnerConfigurationEditor.field.test.runner.coverage.engine=首選覆蓋率引擎:
PhpUnitTestRunnerConfigurationEditor.field.test.runner.options=測試執行程序選項(&O):
PhpUnitTestRunnerConfigurationEditor.scope=測試作用域:
PhpUnitTestRunnerConfigurationEditor.scope.class=類別
PhpUnitTestRunnerConfigurationEditor.scope.directory=目錄
PhpUnitTestRunnerConfigurationEditor.scope.method=方法
PhpUnitTestRunnerConfigurationEditor.scope.xml=在組態檔案中定義
PhpUnitTestRunnerConfigurationEditor.test.runner=測試執行程序
PhpUnitTestRunnerConfigurationEditor.use.alt.bootstrap.file=使用替代啟動檔案(&U):
PhpUnitTestRunnerConfigurationEditor.use.alt.configuration.file=使用替代組態檔案(&U):
PhpUserDefinedConstantsGroup.name=常數
PhpWebAppRunConfigurationEditor.browser=瀏覽器(&B):
PhpWebAppRunConfigurationEditor.configuration.description=PHP 網頁組態
PhpWebAppRunConfigurationEditor.configuration.display.name=PHP 網頁
PhpWebAppRunConfigurationEditor.malformed.start.url=起始 URL 的格式錯誤 - {0}
PhpWebAppRunConfigurationEditor.startUrl=起始 URL(&U):
RunConfigurationEditor.configuration=組態
RunConfigurationEditor.error.server.is.not.exist=名稱為 ''{0}'' 的伺服器不存在
RunConfigurationEditor.error.server.is.not.selected=未選擇伺服器
RunConfigurationEditor.server=伺服器(&S):
XdebugCloudConfigurable.base.host=Cloud 主機:
XdebugCloudConfigurable.cloud.id=Cloud ID:
XdebugCloudConfigurable.connect.via.xdebug.cloud=連線到 Xdebug Cloud
XdebugCloudConfigurable.custom.server=連線到預置 Xdebug Cloud
XdebugCloudConfigurable.display.name=Xdebug Cloud
XdebugCloudConfigurable.port=Cloud 連接埠:
a.class.constant.must.not.be.called.class.it.is.reserved.for.class.name.fetching=類別常數不得被稱為 'class'；後者被保留用於類別名提取
a.full.numeric.representation.of.a.year.at.least.4.digits.with.for.years.bce=年份的完整數字表示，至少 4 位數，使用 - 表示公元前的年份(2022 年)
a.full.textual.representation.of.a.month.such.as.january.or.march=月份的完整文本表示，英語(January 到 December)
a.full.textual.representation.of.the.day.of.the.week=星期几的完整文本表示(Sunday 到 Saturday)
a.short.textual.representation.of.a.month.three.letters=月份的短文本表示，三個英語字母(Jan 到 Dec)
a.textual.representation.of.a.day.three.letters=星期几的文本表示，三個英語字母(Mon 到 Sun)
a.trait.cannot.extend.a.class=特徵無法擴展類別
a.trait.cannot.implement.an.interface=特徵無法實作接口
a.two.digit.representation.of.a.year=年份的兩位數表示(22)
absolute.reference.is.not.allowed=不允許絕對參照
abstract.modifier.is.not.allowed.here=此處不允許使用 'Abstract' 修飾符
access.level.to.0.1.must.be.2.as.in.class.3.or.weaker=''{0}::\${1}'' 的存取級別必須為 {2} (與類別 {3} 中一樣)或更低
access.level.to.0.1.must.be.2.as.in.class.3.or.weaker2=''{0}::{1}'' 的存取級別必須為 {2} (與類別 {3} 中一樣)或更低
access.must.be.public=存取必須為 public
access.type.for.interface.member.must.be.omitted=接口成員的存取類型必須省略
action.ChangePHPInterpreter.description=更改專案 PHP 解釋器
action.ChangePHPInterpreter.text=更改 PHP 解釋器
action.ComposerAddDependencyAction.description=管理 Composer 相依項
action.ComposerAddDependencyAction.text=管理相依項…
action.ComposerClearCacheAction.description=刪除 Composer 快取目錄中的所有內容
action.ComposerClearCacheAction.text=清除快取
action.ComposerDiagnoseAction.description=檢查常見的 Composer 問題
action.ComposerDiagnoseAction.text=診斷
action.ComposerDryRunUpdate.description=模擬更新，但不實際更新
action.ComposerDryRunUpdate.text=模擬更新
action.ComposerDumpAutoloadAction.description=重新生成自動載入類別的列表
action.ComposerDumpAutoloadAction.text=傾印自動載入器…
action.ComposerInstallAction.description=考慮到 composer.lock，安裝 composer.json 中的軟體套件
action.ComposerInstallAction.text=安裝
action.ComposerLicensesAction.description=列出安裝的每個軟體套件的名稱、版本和授權
action.ComposerLicensesAction.text=列出授權
action.ComposerSelfUpdateAction.description=將 Composer 本身更新到最新版本
action.ComposerSelfUpdateAction.text=自我更新
action.ComposerShowLogAction.description=顯示包含此 composer.json 的 Composer 動作日誌
action.ComposerShowLogAction.text=顯示日誌
action.ComposerStatusAction.description=檢查任何相依項中有無本地更改
action.ComposerStatusAction.text=檢查相依項中的更改
action.ComposerUpdateAction.description=從 Composer.json 安裝最新適當版本的軟體套件
action.ComposerUpdateAction.text=更新
action.ComposerValidateAction.description=檢查 composer.json 是否有效
action.ComposerValidateAction.text=驗證…
action.DBGPProxy.Configuration.description=代理組態
action.DBGPProxy.Configuration.text=組態…
action.DBGPProxy.Init.description=代理初始化
action.DBGPProxy.Init.text=註冊 IDE
action.DBGPProxy.Stop.description=代理停止
action.DBGPProxy.Stop.text=取消 IDE 註冊
action.DisableXdebugDfaAssist.description=永久關閉數據流輔助偵錯
action.DisableXdebugDfaAssist.text=永久關閉數據流助手
action.IgnorePharAction.text=在專案中包含或排除 phar
action.MessDetectorAddToIgnored.description=新增到 PHP Mess Detector 忽略列表
action.MessDetectorAddToIgnored.text=新增到 PHPMD 忽略列表
action.NewComposerJsonFile.description=建立 composer.json 檔案
action.NewComposerJsonFile.text=composer.json 檔案
action.PhpCSAddToIgnored.description=新增到 PHP_CodeSniffer 忽略列表
action.PhpCSAddToIgnored.text=新增到 PHPCS 忽略列表
action.PhpCSFixerAddToIgnored.description=新增到 PHP CS Fixer 忽略列表
action.PhpCSFixerAddToIgnored.text=新增到 PHP CS Fixer 忽略列表
action.PhpDebugBreakAtFirstLine.text=在 PHP 腳本中的第一行中斷
action.PhpDebugHideEmptySuperGlobals.text=顯示空的超全域變數
action.PhpDebuggerCopyType.text=複製類型
action.PhpDetectPsroRoots.description=將檢測原始碼命名空間根
action.PhpDetectPsroRoots.text=檢測 PSR-0 命名空間根
action.PhpExtractClassAction.description=將元素提取到單獨的類別
action.PhpExtractClassAction.text=提取類別…
action.PhpGenerateConstructor.description=建立建構函式。
action.PhpGenerateConstructor.text=建構函式…
action.PhpGenerateGetters.description=為 private 類別欄位建立 getter。
action.PhpGenerateGetters.text=getter…
action.PhpGenerateGettersAndSetters.description=為 private 類別欄位建立 getter 和 setter。
action.PhpGenerateGettersAndSetters.text=getter 和 setter…
action.PhpGeneratePhpDocBlocks.description=為函式、類別和欄位新增 PHPDoc 塊。
action.PhpGeneratePhpDocBlocks.text=PHPDoc 塊…
action.PhpGeneratePropertyHooks.description=為非 abstract 類別欄位建立屬性掛鈎。
action.PhpGeneratePropertyHooks.text=屬性掛鈎…
action.PhpGenerateSetters.description=為 private 類別欄位建立 setter。
action.PhpGenerateSetters.text=setter…
action.PhpListenDebugAction.description=偵聽偵錯連線
action.PhpListenDebugAction.text=偵聽偵錯連線
action.PhpMakeStaticAction.description=將類別方法設為 static
action.PhpMakeStaticAction.text=設為 static
action.PhpNewClass.description=建立新的 PHP 類別
action.PhpNewClass.text=PHP 類別
action.PhpNewFile.description=建立新的 PHP 檔案
action.PhpNewFile.text=PHP 檔案
action.PhpNewTest.description=建立新的 PHP 測試
action.PhpNewTest.text=PHP 測試
action.PhpResetTestFrameworkSyncAction.text=重設與 Composer 同步的測試框架組態
action.PhpSimpleNewFile.description=建立新的 PHP 檔案
action.PhpSimpleNewFile.text=PHP 檔案
action.PhpStanAddToIgnored.description=新增到 PHPStan 忽略列表
action.PhpStanAddToIgnored.text=新增到 PHPStan 忽略列表
action.PhpStormMigrationGuide.text=PhpStorm 遷移指南
action.PhpUnitGenerateSetUpMethod.description=建立 PHPUnit setUp 方法
action.PhpUnitGenerateSetUpMethod.text=SetUp 方法
action.PhpUnitGenerateTearDownMethod.description=建立 PHPUnit tearDown 方法
action.PhpUnitGenerateTearDownMethod.text=TearDown 方法
action.PhpUnitGenerateTestMethod.description=建立 PHPUnit 測試方法
action.PhpUnitGenerateTestMethod.text=測試方法
action.ProfilerJumpToSource.description=跳轉到源
action.ProfilerJumpToSource.text=跳轉到源
action.ProjectFromVersionControl.ProjectWidgetPopup.text=克隆儲存庫…
action.ProjectFromVersionControl.text=從版本控制新增專案…
action.XDebugger.CopyPath.text=複製路徑
action.XdebugAddMethodToSkipListAction.text=將方法新增到跳過列表
action.XdebugAnalyzeProfilerSnapshotAction.text=分析 Xdebug 分析器快照…
action.XdebugDetachFromSessionAction.text=從會話中分離
action.XdebugShowUserDefinedConstants.description=將其停用會停止獲取使用者定義的常數資訊並提高偵錯器性能
action.XdebugShowUserDefinedConstants.text=顯示使用者定義的常數
action.add.file.s.to.list.text=向列表中新增檔案
action.com.jetbrains.php.composer.ComposerInitSupportAction.description=初始化 Composer
action.com.jetbrains.php.composer.ComposerInitSupportAction.text=初始化 Composer…
action.com.jetbrains.php.internal.PhpCreateYoutrackIssueFromFileAction.text=在 WI (PhpStorm) 專案中根據檔案內容建立 YouTrack 問題
action.com.jetbrains.php.internal.PhpCreateYoutrackIssueFromSelectionAction.text=在 WI (PhpStorm) 專案中根據所選內容建立 YouTrack 問題
action.com.jetbrains.php.internal.PhpShowFQNInternalAction.text=顯示 PHP FQN
action.com.jetbrains.php.internal.PhpViewControlFlowAction.text=當前檔案的 PHP 控制流
action.configure.php.runtime.text=組態 PHP 執行時…
action.configure.project.directories.text=組態專案目錄
action.copy.3v4l.link.text=將 3v4l 連結複製到剪貼簿
action.copy.port.to.clipboard.text=將連接埠值複製到剪貼簿
action.copy.to.clipboard.text=複製到剪貼簿
action.detect.composer.json.not.found=在路徑 {0} 下找不到 composer.json
action.detect.composer.json.not.found.title=找不到 composer.json
action.detect.composer.json.open=在編輯器中開啟
action.detect.settings.sync.turned.on=PHP 語言級別已與 composer.json 同步
action.detect.settings.sync.turned.on.title=已與 composer.json 同步
action.detect.user.settings.state.overwritten=如果開啟同步，IDE 設定(PHP 語言級別，PSR-0/PSR-4 根)可能會被覆蓋
action.detect.user.settings.state.overwritten.short=設定可能會被覆蓋: PSR-0/PSR-4 根和 PHP 語言級別。
action.detect.user.settings.state.supported=支援 PSR-0/PSR-4 根和 PHP 語言級別的同步
action.enable.plugin.text=啟用 ''{0}'' 延伸模組
action.migrate.text=是
action.open.3v4l.link.in.browser.text=在瀏覽器中開啟 3v4l 連結
action.quality.tools.provider=品質工具
action.quality.tools.provider.description=檔案被排除在外部品質工具分析和格式化程序外
action.retry.text=重試
action.revert.back.to.text=還原為 {0}
action.run.composer.install.text=執行 'composer install'
action.run.on.3v4l.org.promotion.tooltip=您現在可以在 3v4l.org 上執行不同 PHP 版本的臨時檔案
action.run.on.3v4l.org.text=在 3v4l.org 上執行
action.show.in.log.text=在日誌中顯示
action.submits.code.to.3v4l.org.show.result.in.preview.editor.description=將程式碼提交到 3v4l.org，並在預覽編輯器中顯示結果
action.synonym.listening=偵聽
action.synonym.start.listening=開始偵聽 PHP Xdebug 連線
action.synonym.stop.listening=停止偵聽 PHP Xdebug 連線
action.use.possibly.outdated.defaults.text=使用預設版本(可能已過時)
actions.detect.common.setting.from.composer.disable=不同步
actions.detect.common.setting.from.composer.enable=啟用同步
actions.detect.common.setting.from.composer.show.settings=顯示設定
actions.detect.common.setting.from.composer.suggest.title=將設定與 Composer 同步?
actions.detect.common.settings.composer.sync.state.title=與 composer.json 的同步{0}
actions.detect.common.settings.updated.from.composer.title={0} 設定已更新
actions.detect.language.level.loaded.from.composer.idea.title=語言級別
actions.detect.language.level.loaded.from.composer.title=PHP 語言級別
actions.detect.namespace.roots.finished=已完成 PSR-0 命名空間根檢測。
actions.detect.namespace.roots.from.composer.idea.title=來來源根
actions.detect.namespace.roots.from.composer.title=PSR-0/PSR-4 根
actions.detect.namespace.roots.idea.view.configuration=您可以在 '專案結構 | 模組' 中修改設定。
actions.detect.namespace.roots.manual.configuration=手動組態
actions.detect.namespace.roots.no.new.roots.detected=未檢測到新的 PSR-0 命名空間根。
actions.detect.namespace.roots.notification.id=PHP PSR-0 命名空間根檢測已完成
actions.detect.namespace.roots.notification.title=檢測 PSR-0 命名空間根
actions.detect.namespace.roots.progress.title=正在檢測 PSR-0 命名空間根…
actions.detect.namespace.roots.view.configuration=檢視組態
actions.mark.directory.as.psr.0.root=<i>{0}</i>
actions.mark.directory.as.psr.0.root.mark.psr=標記為 {0} 根
actions.mark.directory.as.psr.0.root.title=是否要將目錄標記為 {0} 根?
actions.mark.directory.as.psr.0.root.with.prefix=<i>{0}</i>為前綴“{1}”?
actions.new.php.base.arrows.extension.tooltip=在編輯器中按向上或向下箭頭可更改檔案副檔名
actions.new.php.base.arrows.template.tooltip=在編輯器中按向上或向下箭頭可更改模板
actions.new.php.base.dialog.label.extension=檔案副檔名:
actions.new.php.base.dialog.label.file.name=檔名:
actions.new.php.class.dialog.border.title.class=類別
actions.new.php.class.dialog.label.class.name=名稱:
actions.new.php.class.dialog.label.directory=目錄:
actions.new.php.class.dialog.label.namespace=命名空間:
actions.new.php.class.dialog.label.superclasses.container=父類別
actions.new.php.class.dialog.label.superclasses.super.fqn=擴展:
actions.new.php.class.dialog.label.superinterfaces.add.interface=新增接口…
actions.new.php.class.dialog.label.superinterfaces.to.extend.empty=選擇要擴展的接口
actions.new.php.class.dialog.label.superinterfaces.to.implement=實作:
actions.new.php.class.dialog.label.superinterfaces.to.implement.empty=選擇要實作的接口
actions.new.php.class.dialog.label.template=模板:
actions.new.php.class.dialog.title=建立新的 PHP 類別
actions.new.php.file.dialog.title=建立新的 PHP 檔案
actions.new.phpunit.class.action.description=建立新的 PHPUnit 測試
actions.new.phpunit.class.action.name=PHPUnit 測試
actions.new.test.class.action.description=建立新的 PHP 測試
actions.new.test.class.action.name=新增 PHP 測試
actions.new.test.class.dialog.arrows.libraries.hint=在編輯器中按向上或向下箭頭可更改測試庫
actions.new.test.class.dialog.border.title.class.to.test=要測試的類別(可選)
actions.new.test.class.dialog.border.title.target.class.file.path=檔案路徑:
actions.new.test.class.dialog.border.title.test.class=測試類別
actions.new.test.class.dialog.label.directory=目錄:
actions.new.test.class.dialog.label.fqn=完全限定名稱:
actions.new.test.class.dialog.label.name=名稱:
actions.new.test.class.dialog.label.namespace=命名空間:
actions.new.test.class.dialog.select.methods.show.inherited.methods=顯示繼承的方法(&I)
actions.new.test.class.dialog.title=建立新的 PHP 測試
actions.new.test.class.dialog.title.named=為 {0} 建立新的 PHP 測試
add=新增
add.catch.clause.quick.fix=新增 'catch' 從句
add.clarifying.parentheses=新增澄清括號
add.class=新增類別…
add.class1=新增類別
add.constant.0.to.class.1.and.opens.containing.file.in.editor=將常數 ''{0}'' 新增到類別 ''{1}'' 並在編輯器中開啟包含的檔案
add.constant.declaration.quick.fix.text=新增常數
add.custom.format.function=新增自訂格式函式…
add.custom.format.function1=新增自訂格式函式
add.enum.declaration.quick.fix.text=新增枚舉 case
add.fluent.setter=新增 fluent setter
add.global.variable.quick.fix.family.name=新增全域變數
add.global.variable.quick.fix.text=新增 ''global \${0}''
add.phpunit.test.pattern=新增 PHPUnit 測試模式
add.port.in.ide.settings=將連接埠 {0} 新增到設定
add.property=新增 @property
add.property.hooks=新增屬性掛鈎
add.remote.interpreter=新增遠端解釋器
add.return.type=新增返回值類型
add.rule=新增規則
add.serialize.magic.method=新增{0}方法
add.serialize.magic.methods=新增{0}方法
add.setter=新增 setter
add.slash.to.the.start=在開頭新增 '/'
add.test.class.method=新增測試類別/方法…
add.throw.before.exception=在表達式前面新增 'throw'
add.to.composer.json.quick.fix=向 composer.json 中新增 ''{0}''
add.to.excluded.files.action=將 \`{0}\` 新增到忽略的檔案
advanced.setting.php.code.vision.hierarchy.limit=Code Vision: 要處理的最大繼承實體數
advanced.setting.php.code.vision.usages.limit=Code Vision: 要搜尋的最大用法數
advanced.setting.php.max.chain.resolve.depth=解析成員參照的最大深度
advanced.setting.php.sql.completion.recursive.jumps.limit=補全: 尋找 SQL 查詢時要解析的最大元素數量
advanced.setting.php.type.completion.complexity.limit=類型補全復雜度限制
advanced.setting.php.type.inference.complexity.limit=參數類型推斷復雜度限制
advanced.setting.php.use.internal.formatter=在外部格式化程序之前執行內建格式化程序
alias=別名
align.composer.log.console=對齊 Composer 日誌主控台
all.0=所有({0})
all.cases.of.backed.enum.must.have.a.value=備用枚舉的所有 case 必須包含值
all.exceptions.considered.checked=所有異常均被視為已檢查
all.scripts=<All scripts>
all.values=所有變數
all.versions=所有版本
always.show.pass.by.reference=始終顯示參照傳遞
an.alias.was.defined.for.method.0.which.exists.in.1=已為 {1} 中的方法 {0}() 定義別名
an.expanded.full.numeric.representation.if.requried.or.a.full.numeral.representation.like.y=擴展的完整數字表示(如果需要)，或完整數字表示(2022)
an.expanded.full.numeric.representation.of.a.year.at.least.4.digits.with.or=年份的擴展完整數字表示，至少 4 位數，帶 - 或 + (+2022)
an.object.s.clone.method.cannot.be.called.directly=無法直接呼叫物件的 '__clone()' 方法
analyzing.php.sdk=正在檢查 PHP 安裝…
and=和
annotation.expression.is.not.allowed.as.class.constant.value=表達式不允許為類別常量值
annotation.new.expression.abstract=無法實例化抽象類別 ''{0}''
annotation.new.expression.enum=無法實例化枚舉 ''{0}''
annotation.new.expression.interface=無法實例化接口 ''{0}''
annotation.new.expression.trait=無法實例化特徵 ''{0}''
annotation.variable.variable=可變變數
annotator.cannot.break.continue=無法中斷/繼續{0}級別
annotator.duplicate.default.match.condition=match 表達式只能包含一個 'default' 分支
annotator.duplicate.use.statement=無法使用 ''{0}''，因為該名稱已被使用
annotator.fix.remove=移除 ''{0}''
annotator.invalid.class.name=''{0}'' 是無效的類別名
annotator.jump.out.of.finally=不允許跳出 finally 塊
annotator.only.default.condition.allowed='default' arm 中僅允許單個 'default' 條件
annotator.reserved.class.name=無法使用 ''{0}'' 作為類別名，因為該名稱已被保留
annotator.special.class.name=無法將 {0} 用作 {1}，因為 ''{1}'' 是一個特殊的類別名
annotator.unhandled.match.argument=未處理的 'match' 實參
anonymous.0=匿名{0}
anonymous.class=匿名類別
anonymous.function=匿名函式
anonymous.function.expected=應為匿名函式
another.definition.with.same.name.exists.in.this.file=此檔案中存在另一個具有相同名稱的定義
argument.passed.must.be.of.the.type.0.1.given=傳遞的實參必須為 {0} 類型，給定的為 {1}
array.callback.must.have.exactly.two.elements=陣列回調必須正好有兩個元素
array.can.t.be.used.for.array.destructuring.assignment='array()' 不能用於陣列解構指派
array.index=陣列索引
array.only.updated.but.never.queried=陣列僅被更新，但從未被查詢
arrays.are.not.supported.as.operands.for.0=不支持將陣列用作 ''{0}'' 的動作數
attribute.can.be.added.to.overridden.method=可以將特性新增到覆寫方法
attribute.can.be.added.to.overridden.parameter=可以將特性新增到覆寫參數
attribute.must.be.first.child.of.parent.element=特性必須是父元素的第一個子項
auto.import.from.global.space=處理來自全域空間的符號
auto.import.from.global.space.class=類別:
auto.import.from.global.space.constant=常數:
auto.import.from.global.space.function=函式:
auto.import.from.global.space.prefer.fallback=回退優先
auto.import.from.global.space.prefer.fqn=FQN 優先
auto.import.from.global.space.prefer.import=匯入優先
auto.import.in.file.scope=在檔案作用域內啟用自動匯入
auto.import.in.namespace.scope=在命名空間作用域內啟用自動匯入
background.task.detect.namespace.roots.progress.title=正在檢測命名空間根…
bit.shift.by.negative.number=按負數進行移位
border.title.additional.dependencies=其他相依項
border.title.constant.syntax=常數語法
border.title.include.analysis=Include 分析
border.title.initialize.in=初始化位置
border.title.introduce.field=引入屬性
border.title.introduce.variable=引入變數
border.title.options=選項
border.title.php=PHP
border.title.require.dependencies='require' 相依項
border.title.require.dev.dependencies='require-dev' 相依項
border.title.visibility=可見性
build.control.flow=建置控制流(&B)
build.control.flow.with.exit.points=使用出口點建置控制流(&E)
button.sync.extensions.with.interpreter=將擴展與解釋器同步
button.turn.off.listening=停用偵錯偵聽
button.turn.off.listening.descr=為所選專案停用偵錯偵聽
cache.creating=正在建立 psalm 快取…
call.to.0.1.construct.from.invalid.context=從無效上下文呼叫 ''{0} {1}::__construct()''
call.to.method.clone.from.invalid.context=從無效上下文呼叫方法 '__clone'
call.tree=呼叫樹
callees=被呼叫方
callers=呼叫方
can.not.correctly.run.the.tool.with.parameters=無法使用參數正確執行該工具:
can.not.delete.temporary.file.because.it.was.not.created=無法刪除臨時檔案，因為未建立該檔案
can.not.execute.tests=無法執行測試
can.not.execute.transfer.task.project.is.already.disposed=無法執行傳輸任務: 專案已被處置
can.not.find.0.helper.script=找不到 ''{0}'' 幫助程序腳本
can.not.find.specified.interpreter=找不到指定的解釋器
can.not.parse.phpunit.version.output.0=無法解析 PHPUnit 版本輸出: {0}
can.not.run.command.composer.execution.plugin.was.unloaded=無法執行指令: Composer 執行延伸模組已移除
can.only.be.used.as.standalone.type={0} 僅可用作獨立類型
can.t.use.nullsafe.operator.in.write.context=在寫入上下文中不能使用 nullsafe 運算符
cancel=取消
cannot.apply.0.to.interface=無法將 {0} 應用於接口
cannot.apply.0.to.readonly.class=無法將 {0} 應用於 ''readonly'' 類別
cannot.apply.0.to.trait=無法將 {0} 應用於特徵
cannot.call.abstract.method.0.1=無法呼叫 abstract 方法 ''{0}::{1}''
cannot.combine.nullsafe.operator.with.closure.creation=無法將 nullsafe 運算符與 'Closure' 建立組合
cannot.create.closure.for.new.expression=無法為 'new' 表達式建立 'Closure'
cannot.declare.dynamic.properties.in.readonly.class=不能在 'readonly' 類別中宣告動態屬性
cannot.declare.promoted.property.in.an.abstract.constructor=無法在 abstract 建構函式中宣告提升的屬性
cannot.declare.promoted.property.outside.a.constructor=無法在建構函式外部宣告提升的屬性
cannot.declare.self.referencing.constant=無法宣告自參照常數
cannot.declare.static.properties.in.readonly.class=不能在 'readonly' 類別中宣告 'static' 屬性
cannot.declare.variadic.promoted.property=無法宣告可變提升屬性
cannot.implement.interface.0=無法實作接口 ''{0}''
cannot.implement.interface.0.directly=無法直接實作接口 ''{0}''
cannot.inherit.previously.inherited.or.override.constant.0.from.interface.1=無法從接口 ''{1}'' 繼承先前繼承的常數 ''{0}'' 或將其覆寫
cannot.make.interface.method.non.static=無法將接口方法設為非 static
cannot.make.interface.method.static=無法將接口方法設為 static
cannot.mix.amp.and.pipe.in.type.declaration=類型宣告中不能混用 '\\\\&' 和 '|'
cannot.mix.and.list=不能混合 [] 與 list()
cannot.mix.keyed.and.unkeyed.array.entries.in.assignments=在指派中不能混合鍵控和非鍵控陣列條目
cannot.override.final.constant=無法從 ''{1}'' 覆寫 final 常數 ''{0}''
cannot.redeclare.constant.0=無法重新宣告常數 ''{0}''
cannot.redeclare.methods.from.enum.implicit.interfaces=無法從枚舉隱式接口重新宣告方法
cannot.redeclare.non.static.0.1.as.static.2.3=無法將非 static ''{0}::\${1}'' 重新宣告為 static ''{2}::\${3}''
cannot.redeclare.static.0.1.as.non.static.2.3=無法將 static ''{0}::\${1}'' 重新宣告為非 static ''{2}::\${3}''
cannot.register.handler=無法註冊處理程序
cannot.use.0.as.lexical.variable=無法將 ''\${0}'' 用作詞法變數
cannot.use.class.on.primitive.type=只允許在物件上使用 '::class'
cannot.use.empty.array.elements.in.arrays=無法在陣列中使用空陣列元素
cannot.use.empty.array.entries.in.keyed.array.assignment=在鍵控陣列指派中不能使用空陣列條目
cannot.use.empty.list=無法使用空列表
cannot.use.for.reading=無法使用 '[]' 進行讀取
cannot.use.match.as.identifier=無法將 'match' 用作關鍵字，自 PHP 8.0 起作為預留關鍵字
cannot.use.positional.argument.after.argument.unpacking=無法在實參解包後使用位置實參
cannot.use.positional.argument.after.argument.unpacking.named.argument.81=實參解包後的位置實參從 PHP 8.1 起才可用
cannot.use.positional.argument.after.named.argument=無法在命名實參後面使用位置實參
cannot.use.readonly.as.identifier=無法將 'readonly' 用作關鍵字。自 PHP 8.1 起作為預留關鍵字
cannot.use.static.as.function.return.type.declaration=不允許 'static' 作為類別作用域外部的返回值類型宣告
cannot.use.this.as.parameter=不能將 $this 用作參數
cannot.use.traits.inside.of.interfaces=無法在接口內部使用特徵
cannot.use.unpacking.in.attribute.argument.list=無法在特性實參列表中使用解包
cannot.use.yield.from.inside.a.by.reference.generator=不能在參照傳遞產生器中使用 'yield from'
cant.save.interpreter=無法儲存 ''{0}'': {1}
cant.use.temporary.expression.in.write.context=在寫上下文中不能使用臨時表達式
case.of.non.backed.enum.must.not.have.a.value=非備用枚舉的 case 不得包含值
caused.by.0=原因是:“{0}”
change.member.access=更改成員存取
change.method.modifiers.to.0=將方法修飾符更改為 ''{0}''
change.php.language.level=更改 PHP 語言級別
change.signature.arg.type.incompatible=應為 ''{0}'' 類型的參數，提供的是 ''{1}''
change.signature.arg.type.miss.argument=應為 ''{0}'' 類型的參數
change.signature.column.name.parameter=參數:
change.signature.column.type.parameter=類型:
change.signature.error.wrong.caret.position=文字游標應置於要重構的函式的名稱處。
change.signature.find.usages.of.base.class=類別 {1} 的方法 {0}\\n重寫了類別 {2} 的方法。\\n要{3}基方法嗎?
change.signature.find.usages.of.base.interface=類別 {1} 的方法 {0}\\n實作了接口 {2} 的方法。\\n要{3}基方法嗎?
change.signature.initialize.new.parameters=建立並初始化類別屬性(&I)
change.signature.parameter.may.have.side.effect=用作參數“{1}”的表達式“{0}”可能會有副作用
change.signature.tooltip.default.value=要在此方法的所有現有呼叫中使用的值
change.signature.tooltip.parameter=$name = 'init' 或 &...$array = 'init'
change.signature.usage.view.declarations.header=要重構的函式
change.signature.visibility.not.accessible=可見性為 {1} 的{0}將無法從{2}存取
checkbox.add.override=新增 #[Override]
checkbox.add.packages.as.libraries=作為庫新增軟體套件(&A)
checkbox.add.phpdoc=新增 PHPDoc(&D):
checkbox.always.enable.blade.template.highlighting=始終啟用 Blade 模板醒目提示顯示
checkbox.always.enable.php.code.background.highlighting=始終啟用 PHP 程式碼背景醒目提示顯示
checkbox.anonymous.classes=匿名類別
checkbox.check.clone.method=檢查 '__clone' 方法
checkbox.check.destruct.method=檢查 '__destruct' 方法
checkbox.check.sleep.method=檢查 '__sleep' 方法
checkbox.check.wakeup.method=檢查 '__wakeup' 方法
checkbox.ignore.empty.functions=忽略空函式
checkbox.ignore.test.methods=忽略測試方法
checkbox.lambdas=Lambda
checkbox.move.to.another.class=移至另一個類別(&M)
checkbox.rename.only.nearest.scope=僅重新命名最近作用域中的變數
checkbox.show.class.namespace.separators=顯示 PHP 類別和命名空間分隔符
checkbox.static=static
checkbox.use.as.a.default.template=用作預設模板
checkbox.use.composer=新增 'composer.json'
checkbox.use.fully.qualified.class.names=使用完全限定類別名
checking.for.changes.in.code.of.dependencies=正在檢查相依項程式碼中的更改
choose.a.valid.0.launcher=選擇有效的 {0} 啟動器
choose.an.alias.to.use=選擇要使用的別名
choose.class=選擇類別
choose.elements.to.generate.phpdoc.for=選擇要為其生成 PHPDoc 的元素
choose.executable.class.to.run.0=選擇用於執行 {0} 的可執行類別
choose.methods.to.implement=選擇要實作的方法
choose.methods.to.implement1=選擇要實作的方法
choose.methods.to.override=選擇要覆寫的方法
choose.php.home=選擇 PHP 可執行檔案
choose.properties=選擇屬性
choose.super.class.or.interface=選擇超類別或接口
choose.super.method=選擇 super 方法
choose.test.method.to.run.dataset.0=選擇測試方法以執行資料集 {0}
class=類別
class.cannot.extend.from.trait=類別無法從特徵擴展
class.cannot.implement.previously.implemented.interface=類別無法實作先前實作的接口
class.constant=類別常數
class.constant.reference.fetch.with.non.string.type=只有 'string' 類型的元素才能用於類別常數尋找
class.constant1=類別常數
class.constructor=類別建構函式
class.declarations.may.not.be.nested=類別宣告不能被嵌套
class.implements.solely.traversable=類別 ''{0}'' 必須將接口 Traversable 作為 Iterator 或 IteratorAggregate 的一部分來實作
class.implements.the.serializable.interface.which.is.deprecated=在不使用 '__serialize()'/'__unserialize()' 方法的情況下實作 'Serializable' 接口已棄用
class.name=類別名
class.ref.is.deprecated=類別 '#ref' 已棄用
class.reference=類別參照
class.should.not.implement.itself=類別不應自行實作
class1=類別
class2=類別
classes.can.not.have.backed.type=類別不能有備用類型
classes.named.never.is.forbidden.in.php.8.1=PHP 8.1 中禁止名為 'never' 的類別
classes.named.object.are.forbidden.in.php.7.2=PHP 7.2 中禁止名為 'object' 的類別
classes.named.void.and.iterable.are.forbidden.in.php.7.1=PHP 7.1 中禁止名為 'void' 和 'iterable' 的類別
classes.without.member=層次結構中不帶 ''{0}'' 的類別
cleaning.up=正在清理…
clear.log=清除日誌
clearing.cache=正在清除快取
cli.interpreters.name=CLI 解釋器
close=關閉(&C)
closest.scope=最近作用域中的變數
code.fully.qualified.classname.methodname.key.value.code.example.precise.match={0} 是一個精確排除的範例。
code.global.code.matches.function.with.two.parameters={0} 符合帶有兩個參數的函式。
code.info.code.matches.all.single.parameter.methods.where.the.parameter.name.ends.with.em.info.em={0} 符合參數名以 {1} 結尾的所有單參數方法。
code.key.value.code.matches.all.methods.with.parameters.em.key.em.and.em.value.em={0} 符合所有具有參數 {1} 和 {2} 的方法。
code.size.rules=程式碼大小規則
code.vision.implementations.hint={0, choice, 1#1 個實作|2#{0,number}'{1,choice, |1#+}' 實作}
code.vision.inheritors.hint={0, choice, 1#1 個繼承者|2#{0,number}'{1,choice, |1#+}' 繼承者}
code.vision.overrides.hint={0, choice, 1#1 個覆寫|2#{0,number}'{1,choice, |1#+}' 覆寫}
code.vision.used.in.hint=由 {0}{1, choice, |1#+} 使用
column.name.annotation.name=註解名稱
column.name.file.directory=檔案/目錄
column.name.parameter=參數
command.name.create.php.file=建立 PHP 檔案 {0}
command.name.disable.synchronisation.with.composer=停用與 composer.json 同步
command.name.make.method.static=將方法設為 static
command.name.new.file=新增檔案
completion.press.again.to.see.all.classes=再次按 {0} 以檢視所有類別
completion.press.again.to.see.global.variants=再次按 {0} 以檢視全域變體
completion.press.again.to.see.more.variants=再次按 {0} 以檢視更多變體
composer=composer
composer.autoloader.generation.settings.name=自動載入器生成設定
composer.border.title.execution=執行
composer.border.title.package=軟體套件
composer.change.setting.action.name=更改設定
composer.checkbox.allow.unbound.version.constraints=允許未綁定的版本約束
composer.checkbox.autoload.classes.from.the.classmap.only=僅從類別映射自動載入類別
composer.checkbox.check.if.composer.lock.is.up.to.date=檢查 composer.lock 是否為最新
composer.checkbox.check.if.the.package.is.packagist.ready=檢查軟體套件是否為 Packagist 就緒
composer.checkbox.disable.autoload.dev.dependencies=停用 autoload-dev 相依項
composer.checkbox.download.composer.phar.from.getcomposer.org=從 getcomposer.org 下載 composer-stable.phar
composer.checkbox.optimize.autoloader.convert.psr.0.4.rules.to.a.classmap=最佳化自動載入器(將 PSR-0/4 規則轉換為類別映射)
composer.checkbox.skip.scripts.execution=跳過腳本執行
composer.checkbox.synchronize.ide.settings.with.composer.json=將 IDE 設定與 composer.json 同步(&S)
composer.checkbox.use.apcu.to.cache.found.not.found.classes=使用 APCu 快取找到/未找到的類別
composer.checkbox.validate.package.dependencies=驗證軟體套件相依項
composer.checking.for.changes.in.code.of.dependencies.task.title=檢查相依項程式碼中的更改
composer.clearing.cache.action.name=清除快取
composer.diagnose.task.title=診斷
composer.executable='composer' 可執行檔案
composer.generate.list.popup.title=生成
composer.generating.autoloader.task.title=生成自動載入器
composer.json.custom.invalid.json=json 無效
composer.json.custom.packages.done=自訂儲存庫已載入
composer.json.custom.packages.empty=找不到軟體套件。請檢查您的儲存庫
composer.json.exec.not.configured=自訂儲存庫無法載入。未組態 Composer 可執行檔案路徑
composer.json.open.tool.settings.intention=開啟工具設定
composer.json.packages.loading.error=軟體套件未重新載入
composer.json.packages.refresh=軟體套件正在重新整理
composer.json.packagist.packages.done=僅載入了 packagist 儲存庫
composer.json.packagist.packages.reused=正在重用軟體套件列表而不更新
composer.json.path.not.configured=自訂儲存庫無法載入。未組態 composer.json 路徑
composer.label.can.be.time.consuming=可能較為耗時
composer.label.executable='composer' 可執行檔案
composer.label.filter.packages=篩選軟體套件(&F):
composer.label.label=標籤
composer.label.package=軟體套件:
composer.label.path.to.composer.json=composer.json 路徑(&C):
composer.label.phar=composer.phar
composer.label.the.settings.php.language.level.directories.may.be.updated=設定(Php 語言級別，目錄)可能已更新
composer.label.version.to.install=要安裝的版本:
composer.listing.licenses.task.title=列出授權
composer.packages.versions=Composer 軟體套件版本
composer.remove.action.name=移除(&R)
composer.require.package.task.title=需要 Composer 軟體套件
composer.revert.action.name=還原
composer.simulating.update.task.title=模擬更新
composer.update.composer.packages.task.title=更新 Composer 軟體套件
composer.update.composer.task.title=更新 Composer
composer.validate.dialog.action.button.title=驗證
composer.validating.task.title=驗證
composer.validation.settings.name=驗證設定
composer.version.update.hint=已安裝軟體套件的當前版本和可用更新。
composite.test.patterns=複合測試模式
config.file.doesnt.exist=組態檔案不存在
configurable.PhpDebugConfigurable.display.name=偵錯
configurable.PhpProjectConfigurable.display.name=PHP
configurable.PhpServerConfigurable.display.name=伺服器
configurable.PhpServersConfigurable.display.name=伺服器
configurable.PhpSmartKeysConfigurable.display.name=PHP
configurable.PhpTemplatesCommonConfigurable.display.name=模板
configurable.PhpTestFrameworksConfigurable.display.name=測試框架
configurable.QualityToolCommonConfigurable.display.name=品質工具
configurable.name.php.servers=PHP 伺服器
configurable.quality.tool.laravel.pint=Laravel Pint
configurable.quality.tool.mess.detector=Mess Detector
configurable.quality.tool.php.code.sniffer=PHP_CodeSniffer
configurable.quality.tool.php.cs.fixer=PHP CS Fixer
configure=組態
configure.php.include.paths=組態 PHP Include 路徑(&O)…
configure.suppressed.annotations=組態禁止的註解
configured.is.incorrect=組態的 {0} 不正確
conflict.class.constant.with.same.name.already.exists=此類別中已經定義了具有相同名稱的常數
conflict.class.with.same.name.already.exists=已經定義了具有相同名稱的類別
conflict.constant.with.same.name.already.exists=已經定義了具有相同名稱的常數
conflict.field.with.same.name.already.exists=此類別中已經定義了具有相同名稱的屬性
conflict.function.with.same.name.already.exists=已經定義了具有相同名稱的函式
conflict.method.with.same.name.already.exists=此類別中已經定義了具有相同名稱的方法
conflict.parameter.with.same.name.already.exists=已經定義了具有相同名稱的參數
conflict.tag.name.contains.close.tag=文本包含“{0}”
conflict.template.parameter.with.same.name.already.exists=已存在同名的模板參數
conflict.use.with.same.name.already.exists=已經定義名稱相同的 'Use' 語句
conflict.variable.with.same.name.already.exists=已經定義了具有相同名稱的變數
connection.failed.message=連線失敗。請檢查您的網絡連線並重試。
connection.port.is.busy=連接埠 {0} 繁忙
constant=常數
constant.0=常數 {0}
constant.expression.contains.invalid.operations=常數表達式包含無效運算
constant.ref.is.deprecated=常數 '#ref' 已棄用
constant.ref.is.deprecated1=常數 '#ref' 已棄用
constant.ref.not.found.in=在 {0} 中未找到常數 ''#ref''
constant.with.same.name.already.exists.in.0={0} 中已經存在名稱相同的常數
constant1=常數
constants.defined.using.the.const.keyword.must.be.declared.at.the.top.level.scope=使用 'const' 關鍵字定義的常數必須在頂層作用域宣告
constants.may.only.evaluate.to.scalar.values.arrays.or.resources=常數的求值結果只能為標量值、陣列或資源
constructor.already.exists=建構函式已存在
constructor.field=建構函式欄位
constructors=建構函式
controversial.rules=有爭議的規則
convert.closure.to.arrow.function=將閉包轉換為箭頭函式
convert.concatenation.to.sprintf.call=將串聯轉換為 'sprintf()' 呼叫
convert.string.interpolation.to.concatenation=將字串內插轉換為串聯
convert.string.interpolation.to.sprintf.call=將字串內插轉換為 'sprintf()' 呼叫
convert.the.arrow.function.to.a.traditional.closure=將箭頭函式轉換為傳統閉包
copy=複製
copy.concatenated.string.to.clipboard=將串聯的字串複製到剪貼簿
copy.handler.is.dumb.during.indexing=在索引編制進行時複製類別將只是簡單地複製包含的檔案。您將必須手動更改命名空間和匯入。是否仍要繼續?
copy.switch.branch=複製 'switch' 分支
copy.to.namespace=目標命名空間:
couldnt.update.php.ini=''zend_extension=xdebug'' 未新增到 {0}。存取被拒絕。
coverage.is.not.supported.for.selected.run.profile=程式碼覆蓋率與所選執行組態檔案不相容
create.missing.target.method.fix=建立缺少的目標方法修復
create.new.class.quickfix=建立一個新類別
create.new.field.dialog.title=建立新字段
create.target.class.quick.fix=建立目標類別快速修復
creates.new.class.0.in.a.separate.file=在單獨的檔案中建立名為 ''{0}'' 的新類別
creates.new.class.method.0.in.a.separate.file=在單獨的檔案中使用方法 ''{1}'' 建立名為 ''{0}'' 的新類別
custom.format.functions.dialog.class.placeholder=留空以新增純函式
custom.format.functions.dialog.format.index.title=格式字串模板的索引
custom.format.functions.dialog.validation.class.not.found=找不到類別 {0}
custom.format.functions.dialog.validation.format.index=索引必須為非負數
custom.format.functions.dialog.validation.function.not.found=找不到函式 {0}
custom.format.functions.dialog.validation.method.not.found=在 {1} 中找不到方法 {0}
day.of.the.month.2.digits.with.leading.zeros=月中幾號，2 位數，帶前導零(01到 31)
day.of.the.month.without.leading.zeros=月中幾號，不帶前導零(1 到 31)
days.numeric=天，數字(1、3、31)
days.numeric.at.least.2.digits.with.leading.0=天，數字，至少 2 位數，帶前導 0 (01、03、31)
dbgp.invalid.packet=無效封包
dbgp.proxy=Xdebug 代理
dbgp.proxy.cannot.connect.to.host=無法連線到主機 ''{0}''
dbgp.proxy.cannot.connect.to.xdebug.proxy=無法連線到 ''{0}:{1}'' 上的 Xdebug 代理
dbgp.proxy.host=代理主機
dbgp.proxy.ide.key=IDE 鍵
dbgp.proxy.ide.register.error=無法使用 IDE 鍵 ''{0}'' 註冊 IDE
dbgp.proxy.ide.register.success=IDE 已成功使用 IDE 鍵 ''{0}'' 註冊
dbgp.proxy.ide.unregister.success=IDE 已成功註銷
dbgp.proxy.port=代理連接埠
dbgp.proxy.sending.request.to.xdebug.proxy=正在將請求發送到 Xdebug 代理…
dead.code.commented.out=註釋掉
dead.code.deleted=已刪除
debug.accept.connection=接受
debug.action.copy.as.title=將變數複製為 ''{0}''
debug.action.copy.as.was.fail.can.not.get.full.name=無法將變數複製為 ''{0}''，無法對完整的變數名求值
debug.breakpoint.move.disabled=中斷點移動到解析的位置已被停用，從下一個偵錯會話開始將不會移動中斷點。您可以稍後在 <a href="open">PHP|偵錯</a>下將其啟用。
debug.breakpoint.resolved.disabled=中斷點解析已被停用，從下一個偵錯會話開始將不會解析中斷點。 您可以稍後在 <a href="open">PHP|偵錯</a>下將其啟用。
debug.breakpoint.resolved.notify.disabled=中斷點解析通知已被停用。您可以在 <a href="open">PHP|偵錯|進階設定</a>下將其啟用。
debug.breakpoint.was.moved=<br/>中斷點也已移至此行。
debug.breakpoint.was.resolved=此處的偵錯會話已暫停，因為 ''{0}'' 處的中斷點已被解析到此行。<br/>您可以<a href="disable">停用</a>中斷點解析或<a href="more">了解詳情</a>。<a href="dontshow">不再顯示</a>
debug.cannot.find.port=找不到可用連接埠
debug.cannot.map.local.file=檔案路徑未映射到伺服器上的任何檔案路徑。編輯路徑映射以解決此問題。
debug.cannot.start=無法啟動 ''{0}''
debug.cannot.start.listening.for.connections.from.0=無法開始偵聽來自 ''{0}'' 的連線
debug.check.firewall=請檢查您的防火牆設定
debug.checkbox.can.accept.external.connections=可以接受外部連線
debug.checkbox.ignore.z.ray.system.requests=忽略 Z-Ray 系統請求
debug.composite.value.presentation=[{0}]
debug.configure.servers=組態伺服器
debug.debug.port=偵錯連接埠:
debug.edit.ignored.paths.list=<a href="#a">編輯</a>跳過的路徑。
debug.edit.path.mappings=點擊以設定路徑映射
debug.error=錯誤
debug.error.cannot.evaluate.expression=無法對表達式求值
debug.error.cannot.evaluate.expression0=無法對表達式 ''{0}'' 求值
debug.error.cannot.evaluate.variables=無法對變數求值
debug.error.cannot.modify.value=無法修改值
debug.error.cannot.parse.server.name=要修復，請在遠端伺服器上建立環境變數 <i><b>PHP_IDE_CONFIG</b></i>。<br/><br/><i>Windows:</i> 設定 PHP_IDE_CONFIG="serverName=SomeName"<br/> <i>Linux / Mac OS X:</i> 匯出 PHP_IDE_CONFIG="serverName=SomeName"。
debug.error.cannot.parse.server.name.for.external.connection=無法為外部 {0} 連線解析伺服器名稱。
debug.error.cannot.parse.ssh.connection=無法從 $_SERVER[''SSH_CONNECTION''] 解析連接埠: ''{0}''
debug.error.server.name.is.empty=<i><b>$_SERVER["SERVER_NAME"]</i></b> 為空，這可能是 Web 伺服器組態錯誤所致。<br/><br/><i>Nginx:</i> 將 fastcgi 參數新增至 nginx 組態，<a href="http://wiki.nginx.org/PHPFcgiExample">更多</a><br/><i>Apache:</i> 為當前 VirtualHost 組態 ServerName，<a href="https://httpd.apache.org/docs/2.4/vhosts/name-based.html">更多</a>
debug.error.title.cannot.accept.external.0.connection=無法接受外部 {0} 連線
debug.error.unknown.debugger.id=未檢測到偵錯器擴展
debug.error.wrong.debugger.id=不支持 {0}
debug.expression.evaluation.fail=由於返回值未知，無法對表達式求值
debug.file.is.ignored=檔案 ''{0}'' 被跳過。
debug.function.was.added.to.skip.list=''{0}'' 已新增到跳過列表。
debug.ignore.connection=忽略
debug.incoming.connection.title.0=來自 {0} 的傳入連線
debug.label.file.path.in.project=專案中的檔案路徑:
debug.label.file.path.on.server=伺服器上的檔案路徑:
debug.label.max.simultaneous.connections=最大同時連線數:
debug.label.select.a.project.or.a.file.to.debug=選擇一個專案或檔案進行偵錯
debug.label.select.a.project.to.debug=選擇一個專案進行偵錯
debug.log.cant.register.breakpoint.no.remote=無法註冊中斷點。沒有本地路徑 ''{0}'' 的路徑映射
debug.log.cant.register.breakpoint.no.template.mapping=無法註冊中斷點。沒有到 PHP 行 ''{0}'' 的映射
debug.log.connection.was.terminated=偵錯連線在 ''{0}'':''{1}'' 上意外終止
debug.log.exception.break=異常中斷: {0} ({1})
debug.log.invalid.xdebug.message=由於 Xdebug 訊息無效，無法在中斷點處停止。\\n要解決此問題，請切換到穩定版本的 Xdebug 或使用 'xdebug.remote_log' 選項收集日誌並建立錯誤報告。 
debug.log.path.mapping.remote.extracted=遠端: ''{0}'' <-> 提取: ''{1}''
debug.log.path.mapping.remote.local=遠端: ''{0}'' <-> 本地: ''{1}''
debug.log.stack.frame=框架: {0}:{1}，{2}
debug.log.stop=停止於 (''{0}'':{1})
debug.mapping.resolve.dialog.stop.debugger=停止偵錯器
debug.not.installed=<未安裝>
debug.output=輸出
debug.path.on.server=伺服器上的絕對路徑
debug.php.breakpoint.failed.to.register=無法註冊中斷點，請嘗試將其停用並重新啟用。
debug.php.exception.breakpoint.dialog.title=新增異常中斷點
debug.php.exception.breakpoint.exception.name=異常名稱:
debug.php.exception.breakpoint.not.supported=載入的偵錯擴展不支持異常中斷點
debug.php.exception.breakpoint.title=PHP 異常中斷點
debug.php.exception.breakpoint.zend.not.supported=Zend Debugger 不支持異常中斷點
debug.php.external.connection.finished.break.at.first.line=<b><i>'在第一行中斷'</i></b> 選項已啟用
debug.php.external.connection.finished.break.at.first.line.title=PHP 偵錯組態
debug.php.external.connection.finished.warning=這可能是由於路徑映射組態錯誤或本地和遠端專案未同步。<br/><br/>要找出問題，請在 <b><i><a href="servers">PHP|伺服器</a></i></b>下檢查 ''{0}'' 伺服器的路徑映射組態，或啟用 <b><i><a href="break">''在 PHP 腳本中的第一行中斷''</a></i></b> 選項(位於<i>執行</i>選單下)。<br/><a href="ignore">不再顯示</a>
debug.php.external.connection.finished.warning.title=偵錯會話已完成且未暫停
debug.php.line.breakpoint.title=PHP 行中斷點
debug.php.method.breakpoint.dialog.title=新增方法中斷點
debug.php.method.breakpoint.title=PHP 方法中斷點
debug.php.method.breakpoint.zend.not.supported=Zend Debugger 不支持方法中斷點
debug.port.is.updated=設定中指定的連接埠 {0} 正在使用中。連接埠 {1} 可用，可由 Xdebug 使用。請使用 {2} 更新 php.ini
debug.port.is.updated.descr=設定中指定的連接埠 {0} 正在使用中。連接埠 {1} 可用，可由 Xdebug 使用。
debug.ports.is.updated=設定中指定的所有連接埠都在使用中。連接埠 {0} 可用，可由 Xdebug 使用。請使用 {1} 更新 php.ini
debug.process.cannot.find.file=在本地找不到檔案 ''{0}''。\\n要修復，請通過環境變數 PHP_IDE_CONFIG 設定伺服器名稱，然後重啟偵錯會話。
debug.process.cannot.find.file.in.project=在專案中找不到路徑為 ''{0}'' 的檔案
debug.process.cannot.find.file.link=更多資訊
debug.process.cannot.find.local.file=在伺服器 {0} 上找不到檔案的本地副本\\n本地路徑為 {1}
debug.process.cannot.find.path.mapping=遠端檔案路徑 ''{0}'' 未映射到專案中的任何檔案路徑
debug.process.cannot.find.remote.copy.local.file=專案 ''{0}'' 中的檔案路徑未映射到伺服器上的任何檔案路徑
debug.process.cannot.find.server.name=找不到源位置。名稱為 ''{0}'' 的伺服器不存在。
debug.process.cant.compute.source.position=無法計算源位置。腳本 ''{0}'' 未與任何文本檔案類型關聯。
debug.process.console.error.format={0}: {1}，{2} 中的第 {3} 行\\n
debug.process.script.outside.project=腳本 ''{0}'' 在專案外部。
debug.process.smart.step.into.function.evaluation.error=無法對目標函式求值。將執行“單步跳入”。
debug.process.smart.step.into.function.was.not.executed=尚未呼叫所選函式。
debug.process.smart.step.into.popup=步入函式
debug.process.status.connected=已連線
debug.process.status.disconnected=已斷開連線
debug.process.status.wait=正在等待與{0} ''{1}'' 的傳入連線
debug.resolve.mapping.problem=解決路徑映射問題
debug.rest.client.error.cannot.evaluate.server.name=無法評估 '$_SERVER['SERVER_NAME']'。請確保為您的 Web 伺服器組態了正確的伺服器名稱。<br>點擊此<a href="help">連結</a>獲取更多資訊。
debug.rest.client.error.cannot.evaluate.server.name.title=無法通過伺服器名稱找到對應的“PHP|伺服器”
debug.server.can.not.detect.path.mappings.from.deployment=無法評估路徑映射: 未選擇目標部署伺服器
debug.server.detect.path.mappings.from.deployment=正在檢測現有路徑映射…
debug.server.detect.path.mappings.from.deployment.progress=正在為 ''{0}'' 專案分析路徑映射
debug.server.import.configuration.deployment=部署(&D):
debug.server.import.configuration.dialog.title=從部署組態匯入
debug.server.import.configuration.local=本地(&L)
debug.server.import.configuration.local.file.path=本地檔案路徑:
debug.server.import.configuration.mounted=已掛載(&M)
debug.server.import.configuration.path.to.remote.root=部署根的絕對路徑(&R):
debug.server.import.configuration.path.to.remote.root.mounted=本地: ''{0}'' -> 遠端: ''{1}''
debug.server.import.configuration.path.to.remote.root.mounted.label=已掛載目錄的遠端路徑(&R):
debug.server.import.configuration.path.to.remote.root.mounted.tooltip=遠端檔案的絕對路徑:<br>"已掛載目錄的遠端路徑" . "伺服器上的相對部署路徑" (來自部署路徑映射)
debug.server.import.configuration.path.to.remote.root.sftp=絕對遠端根: ''{0}''
debug.server.import.configuration.path.to.remote.root.sftp.tooltip=遠端檔案的絕對路徑:<br>"遠端根的絕對路徑" . "根路徑" (來自部署設定) . "伺服器上的相對部署路徑" (來自部署路徑映射)
debug.server.import.configuration.preview.border.title=預覽
debug.server.import.configuration.project=專案(&P):
debug.server.import.from.deployment.deployment.configurations.message=找到具有相關路徑映射的部署組態。
debug.server.import.from.deployment.deployment.root.label=部署根(&R):
debug.server.import.from.deployment.no.deployment.configurations.message=找不到合適的部署組態
debug.server.import.from.deployment.no.deployment.configurations.tooltip=組態部署根(如果不為空)
debug.server.import.from.deployment.radio=從部署匯入映射(&I)
debug.server.manually.select.file.message=選擇一個專案或檔案進行偵錯
debug.server.manually.select.file.or.project=手動選擇本地檔案或專案(&M)
debug.server.select.file.mapping=組態本地檔案路徑
debug.settings.auto.detect.ide.host=自動檢測 IDE IP:
debug.settings.broadcasting.port=設定廣播連接埠:
debug.start.listen.debug.connections=開始偵聽 PHP 偵錯連線
debug.stop.listen.debug.connections=停止偵聽 PHP 偵錯連線
debug.type.float=浮點
debug.type.int=int
debug.type.resource=資源
debug.xdebug=Xdebug
debug.xdebug.error.unsupported.protocol.version=不支持的 Xdebug 協議版本
debug.zend.cannot.accept.incoming.connection=無法接受來自 Zend Debugger 的傳入連線
debug.zend.debugger=Zend 偵錯器
debug.zend.debugger.settings.broadcasting=Zend Debugger 設定廣播
debug.zend.error.title.cannot.accept.external.xdebug.connection=無法接受外部 Xdebug 連線
debug.zend.required.protocol.version.0.or.higher=所需協議版本為 ''{0}'' 或更高版本
debugger.method=方法
declaration.in.parent.class.is.incompatible.with.interface=父類別中的宣告與接口不相容
declaration.must.be.compatible.with.0=宣告必須與 {0} 相容
declaration.must.be.compatible.with.super=宣告必須與父級相容
default=預設:
default.value=預設值
delete.assignment=刪除指派
delete.case=刪除 'case'
delete.catch.statement=刪除 'catch' 語句
delete.elseif=刪除 'elseif'
delete.if=刪除 'if'
delete.redundant.method.override=移除方法
delete.redundant.switch.branch=刪除冗餘 'switch' 分支
delete.unused.element=刪除未使用的元素
delete.void.return.type=刪除 'void' 返回值類型
deprecated.form.of.callables=已棄用的可調用對象形式
design.rules=設計規則
diagnosing=正在診斷
dialog.error.title.php.extract.class=PHP 提取類別
dialog.message.cannot.create.file.because.project.already.disposed=由於專案已被處置，無法建立檔案
dialog.message.could.not.find.network.interface=找不到 {0} 網絡接口
dialog.message.do.you.want.to.upload.content.scratch.file.to.3v4l.org.make.it.public=是否要將臨時檔案的內容上傳到 3v4l.org 並將其公開?
dialog.message.docker.account.not.found=找不到 Docker 帳戶
dialog.message.docker.account.not.specified=未指定 Docker 帳戶
dialog.message.execution.quality.tools.in.untrusted.project.prohibited=禁止在不受信任的專案中執行品質工具
dialog.message.no.interface.addresses.for.network.interface=沒有 {0} 網絡接口的接口地址
dialog.message.port.cannot.be.negative.number=端口號不能為負
dialog.message.query.string.cannot.start.with=查詢字串不能以 '?' 開頭
dialog.message.server.host.cannot.be.empty=伺服器主機不能為空
dialog.message.unable.to.create.configurations.with.same.executable.path=同一 Composer 專案的同一解釋器的組態發生衝突: {0}
dialog.title.configure.code.patterns=組態程式碼模式…
dialog.title.edit.phpunit.test.pattern=編輯 PHPUnit 測試模式
dialog.title.enter.tag.name=輸入標記名稱
dialog.title.inline.variable=內聯變數
dialog.title.new.php.file=新增 PHP 檔案
dialog.title.select.methods.to.propagate.safe.delete=選擇要傳播安全刪除的方法
dialog.title.select.parameters.to.propagate.safe.delete=選擇要傳播安全刪除的參數
dialog.title.select.properties.to.initialize=選擇要初始化的屬性
difference.to.greenwich.time.gmt.with.colon.between.hours.and.minutes=與格林威治時間(GMT)的差值，小時和分鐘之間有冒號(+02:00)
difference.to.greenwich.time.gmt.without.colon.between.hours.and.minutes=與格林威治時間(GMT)的差值，小時和分鐘之間沒有冒號(+0200)
directories=目錄
display.name.directory.0=目錄 ''{0}''
do.not.ask.again=不再詢問
do.not.override=不覆寫
docker.compose.border.title.lifecycle=生存期
docker.compose.coverage.file.failed.to.copy=無法從 Docker 容器複製覆蓋率結果
docker.compose.coverage.file.failed.to.extract=無法提取覆蓋率結果
docker.compose.coverage.file.is.not.found=找不到覆蓋率檔案
docker.compose.failed.to.start.container=啟動 docker-compose 服務失敗，請在命令行中啟動並重試
docker.compose.radio.button.always.start.a.new.container.docker.compose.run=始終啟動一個新容器('Docker-compose run')
docker.compose.radio.button.connect.to.existing.container.docker.compose.exec=連線到現有容器('Docker-compose exec')
docker.host.name.error=主機名與 <i>host.docker.internal</i> 不同
docker.host.name.error.descr=<i>host.docker.internal</i> 解析為主機使用的內部 IP 地址
doctrine.query.builder.completion.ascending.order.description=從最小到最大
doctrine.query.builder.completion.descending.order.description=從最大到最小
doctrine.query.builder.parameter.name=DQL 參數
doctrine.query.builder.table.name=DQL 表名稱
download.validation.script=下載 Xdebug 驗證腳本
duplicate.value.in.enum.for.cases.0.and.1=case ''{0}'' 和 ''{1}'' 的枚舉中的重複值
duplicate.variable.0=重複的變數 ''{0}''
dynamically.declared.field=動態宣告的欄位
edit.custom.format.function=編輯自定義格式函式
edit.template=編輯模板
empty.extends.list=空 extends 列表
empty.implements.list=空實作列表
empty.pattern=空模式
empty.type=空類型
enable=啟用
enable.navigate.links.for.class.and.member.references=為類別和成員參照啟用“… 導覽”連結
enable.return.function.value.debugging.xdebug.3.2=啟用返回函式值偵錯 (Xdebug 3.2+)
enable.support=啟用支援
enable.the.following.extension=在 PHP 執行時選項中啟用以下擴展存根:
enable.tostring.object.view=啟用 '__toString' 物件檢視
enables.inspection.0=啟用檢查 ''{0}''
english.ordinal.suffix.for.the.day.of.the.month.2.characters=月中幾號的英語序數後綴，2 個字元(st、nd、rd、th)
enter.annotation=輸入註解
entry.points=入口點
entry.points.tab=入口點
enum=枚舉
enum.backing.type.must.be.int.or.string=枚舉支援類型必須為 'int' 或 'string'
enum.backing.type.must.be.int.or.string.0.given=在給出 ''{0}'' 的情況下，枚舉支援類型必須為 ''int'' 或 ''string''
enum.case=枚舉 case
enum.case.should.be.located.only.inside.enum.classes=枚舉 case 只應位於枚舉類別內部
enum.case.type.0.does.not.match.enum.backing.type.1=枚舉 case 類型 ''{0}'' 與枚舉支援類型 ''{1}'' 不符合
enum.case.value.must.be.constant=枚舉 case 值必須為常數
enum.may.not.include.0=枚舉不得包含 ''{0}''
enum.may.not.include.extend=枚舉不得擴展其他類別
enum.properties.are.immutable=枚舉屬性不可變
enum.value.cannot.referer.to.enum.cases=枚舉值不能參照枚舉 case
enums.may.not.be.cloned=不得克隆枚舉
enums.may.not.implement.the.serializable.interface=枚舉可能不會實作 'Serializable' 接口
enums.may.not.include.properties=枚舉不得包含屬性
environment.key.description.run.composer.install=定義找不到 'vendor' 目錄時是否執行 'composer install'\\n值: 'false' (預設值)或 'true'
error.cannot.connect.to.0=無法連線到 ''{0}''
error.cannot.connect.to.0.1=無法連線到 ''{0}'': {1}
error.cant.create.edge=無法建立關係連結
error.during.access.to.3v4l.org=存取 3v4l.org 時出錯
error.file.unable.create.selected.directory=無法在所選目錄中建立檔案 {0}
error.template.unable.create.from.internal.template=無法從內部模板 {0} 建立檔案
error.template.unable.parse.internal.template=無法解析內部模板 {0}
exception.analysis.settings.path=PHP/分析
exception.class=異常類別
exclude.0.from.1.analysis.a=從{1}分析中排除{0}。
executable.0.was.not.found.in.path.please.make.sure.it.s.there.possible.solutions=在 %PATH% 中找不到可執行檔案 ''{0}''。請確保已指定有效路徑。可能的解決方案:
executable.0.was.not.found.in.path.please.make.sure.it.s.there.possible.solutions1=在 $PATH 中找不到可執行檔案 ''{0}''。請確保已指定有效路徑。可能的解決方案:
execution.result.is.null=執行結果為 null
execution.statistics=執行統計
expected.class.reference=應為: 類別參照
expected.expression.after.spread.operator=應為: 展開運算符後的表達式
expected.property=屬性
explore.migration.guides=探索遷移指南
expression=表達式
expression.0=表達式 {0}
expression.is.not.allowed.as.constant.value=表達式不允許作為常量值
expression.is.not.allowed.as.field.default.value=表達式不允許為欄位預設值
expression.is.not.allowed.as.parameter.default.value=表達式不允許為參數預設值
expression.is.not.allowed.as.static.initializer=表達式不允許為 static 初始設定式
expression.is.not.assignable=表達式不可指派
expression1=表達式
expressions=表達式
extends=擴展
extends.implements.overrides=擴展/實作/覆寫
extends.or.implements=擴展或實作
external.formatter.after=啟用外部格式化程序會停用 IDE 的內建格式化程序
external.formatter.couldnt.run.tool={0} 無法啟動。請檢查您的組態。
external.formatter.phpcbf=PHP Code Beautifier and Fixer
external.formatter.phpcsfixer=PHP CS Fixer
extract.condition=提取條件
extract.method.link.label.more.options=更多選項
extract.method.parameter.name.column.title=參數
extract.method.selector.title=要提取的程式碼
extract.selected.string.part.as.concatenation.operand=將所選字串部分作為串聯動作數提取
extract.selected.string.part.as.format.function.argument=將所選字串部分作為格式函式實參提取
extract.side.effect=提取副作用
failed.to.find.interpreter=無法尋找解釋器
failed.to.find.valid.interpreter.path=無法尋找有效的解釋器路徑
failed.to.parse.php.ini.output.0=無法解析 php --ini 輸出: {0}
failed.to.retrieve.php.versions.from.3v4l.org=無法從 3v4l.org 檢索 PHP 版本資訊
failed.to.run.interpreter=無法執行解釋器
field=欄位
field.name=欄位名稱
field.ref.is.deprecated=欄位 '#ref' 已棄用
field.ref.not.found=找不到欄位 '#ref'
field1=欄位
fields.cannot.be.declared.abstract=屬性不能宣告為 abstract
fields.cannot.be.declared.final=屬性不能宣告為 final
fields.default.visibility.private=private
file=檔案
file.0.does.not.exist=檔案 {0} 不存在
file.0.does.not.exists=檔案 {0} 不存在
files.in.the.directory.should.be.accessible.by.0.request=目錄中的檔案應當可通過 {0} 請求進行存取。
files.in.the.remote.directory.should.be.accessible.by.0.request=遠端目錄中的檔案應當可通過 {0} 請求進行存取。
filetype.composer.log.description=Composer 日誌
filetype.doctrine.query.description=Doctrine 查詢語言
filetype.phar.description=Php Phar
filetype.phar.display.name=Php Phar
filetype.php.description=PHP
filetype.profiler.snapshot.description=分析器快照
final=final
final.class.cant.be.inherited=類別 {0} 為 final
final.modifier.is.not.allowed.here=此處不允許使用 'final' 修飾符
find.cause=尋找原因
find.classes.without.member=尋找沒有成員的類別
find.exception.cause.table.title=異常原因
find.field.accessors.text=是否要搜尋 ''{0}'' 的存取器?
find.field.accessors.title=搜尋存取器
find.options.include.child.methods.checkbox=包括覆寫/實作方法(&V)
find.usages.button.base.method=基方法
find.usages.button.current.method=當前方法
find.usages.prompt.dialog.implements=類別 ''{1}'' 的方法 ''{0}()'' 在 ''{2}'' 中實作了{3,choice,0#方法|1#方法}\\n是否要尋找基{3,choice,0#方法|1#方法}的用法?
find.usages.prompt.dialog.overrides=類別 ''{1}'' 的方法 ''{0}()'' 在 ''{2}'' 中重寫了{3,choice,0#方法|1#方法}\\n是否要尋找基{3,choice,0#方法|1#方法}的用法?
fix.not.available=修復不可用
fix.package.text=將命名空間 ''{0}'' 取代為 ''{1}''
fix.package.text.family=修復命名空間 
flip.key.value.intention.family.name=翻轉鍵和值
flip.key.value.intention.message.all.in.array=翻轉陣列中的所有鍵和值
flip.key.value.intention.message.single=翻轉鍵和值
fluent.setters=Fluent setter
folding.checkbox.collapse.attribute=特性
folding.checkbox.collapse.attribute.list=特性列表
folding.checkbox.collapse.classes=類別主體
folding.checkbox.collapse.function.body=函式體
folding.checkbox.collapse.heredocs.and.nowdocs=heredoc/nowdoc
folding.checkbox.collapse.imports=Import
folding.checkbox.collapse.method.body=方法體
folding.checkbox.collapse.php.tags=標記
follow.this.0.for.more.information.about.deployment=有關部署的詳細資訊，請參閱此{0}。
follow.this.0.for.more.information.about.path.mappings=有關路徑映射的詳細資訊，請參閱{0}。
follow.this.links.to.install.and.configure.0.or.1=點擊這些連結以安裝並組態 {0} 或 {1}。
for=for
foreach=foreach
found.roots.configured=檢測到並組態了 PSR-0 根
framework.composer=Composer
framework.composer.0.1.version.2={0} {1}，版本 {2}
framework.composer.add.composer.dependency.title=管理 Composer 相依項
framework.composer.add.dependency.available.packages.label=可用軟體套件
framework.composer.add.dependency.close.button=關閉(&C)
framework.composer.add.dependency.hide.tooltip=隱藏
framework.composer.add.dependency.install.button=安裝
framework.composer.add.dependency.no.new.version.found.for.0=找不到 {0} 的新版本。
framework.composer.add.dependency.no.package.selected=未選擇軟體套件
framework.composer.add.dependency.no.such.package=packagist 上無此類別軟體套件
framework.composer.add.dependency.no.version.selected=未選擇版本
framework.composer.add.dependency.running=正在執行
framework.composer.add.dependency.settings.cl.dialog.title=參數
framework.composer.add.dependency.settings.cl.label=命令行參數(&P):
framework.composer.add.dependency.settings.interpreter.label=PHP 解釋器:
framework.composer.add.dependency.settings.title=設定(&S)
framework.composer.add.dependency.show.output=顯示輸出
framework.composer.add.dependency.successfully.installed.0.version.1=已成功安裝 {0}，版本 {1}。
framework.composer.add.dependency.successfully.removed.0=已成功移除 {0}。
framework.composer.add.dependency.successfully.updated.0=已成功更新 {0}。
framework.composer.add.dependency.task.title=新增相依項
framework.composer.add.dependency.update.button=更新
framework.composer.available.version=可用版本:
framework.composer.checking.for.update=正在檢查更新…
framework.composer.configurable.title=Composer
framework.composer.create.project.from=自以下建立專案
framework.composer.create.project.progress.title=建立專案
framework.composer.default.composer.interpreter.name=Composer 的解釋器
framework.composer.default.interpreter.for.this.project.is.remote=此專案的預設解釋器是遠端解釋器，無法使用。
framework.composer.default.interpreter.is.not.configured=尚未為此專案組態預設解釋器。
framework.composer.default.project.interpreter=預設專案解釋器
framework.composer.empty.package.name.in.0={0} 中的軟體套件名稱為空
framework.composer.empty.path.to.0={0} 的路徑為空
framework.composer.expected.name.0.versions.0.description.got.1=應為 <name> {0} <versions> {0} <description>，獲得的是 {1}
framework.composer.failed.check.for.update=無法執行 'update --dry-run' 指令。
framework.composer.failed.to.0=無法{0}。
framework.composer.failed.to.0.1.script.was.cancelled=無法{0} {1}。腳本已被取消。
framework.composer.failed.to.download.composer.phar=無法下載 composer-stable.phar
framework.composer.failed.to.load.package.names=無法載入軟體套件名稱。
framework.composer.failed.to.parse.package.description=無法解析軟體套件描述。
framework.composer.failed.to.parse.package.names=無法解析軟體套件名稱。
framework.composer.file.0.is.not.found=找不到檔案 ''{0}''。
framework.composer.file.0.set.as.composer.config.change.setting.a.href.here.a=檔案 ''{0}'' 設定為 Composer 組態。
framework.composer.init.dialog.title.composer.settings=Composer 設定
framework.composer.initialize.popup=找到了 Composer 組態檔案 {0}。專案設定與其同步。
framework.composer.initialize.popup.multi.composer=找到 {0} 個 composer 組態檔案。專案設定已與其同步。
framework.composer.install.action.name=安裝
framework.composer.install.task.title=正在安裝軟體套件
framework.composer.interpreters.combo.default.interpreter=< 預設解釋器 >
framework.composer.interpreters.combo.default.interpreter.no.php.path=預設解釋器未提供 PHP 路徑
framework.composer.interpreters.combo.default.project.interpreter=< 預設專案解釋器 >
framework.composer.interpreters.combo.no.default.interpreter=預設設定中沒有預設解釋器
framework.composer.interpreters.combo.no.default.interpreter.in.project=此專案中沒有預設解釋器
framework.composer.label.installed.version=已安裝的版本:
framework.composer.label.version.to.install=要安裝的版本(&V):
framework.composer.load.update.availability=檢查可用軟體套件更新
framework.composer.loading.package.description=正在載入軟體套件描述
framework.composer.loading.packages=正在載入 Composer 軟體套件
framework.composer.loading.update.availability=正在檢查 Composer 軟體套件更新
framework.composer.name.composer=Composer
framework.composer.no.description.available=無可用描述。
framework.composer.no.package.versions.in.0={0} 中沒有軟體套件版本
framework.composer.notification.title.init.composer=初始化 Composer
framework.composer.notify.about.missing.vendor=缺少 'vendor' 目錄時通知
framework.composer.package.default.version=<預設>
framework.composer.package.version.available.0={0}的更新
framework.composer.packages.were.added.0.excluded.folders.popup=Composer 軟體套件已被新增到排除的目錄中。
framework.composer.packages.were.added.0.php.include.paths.popup=Composer 軟體套件已被新增到 PHP include 路徑中。
framework.composer.packages.were.changed.0.excluded.folders.popup=Composer 軟體套件已更改，因此更新了排除的目錄。
framework.composer.packages.were.changed.0.php.include.paths.popup=Composer 軟體套件已更改，因此更新了 PHP include 路徑。
framework.composer.packages.were.changed.0.test.config.popup={0} 組態已根據 composer.json 更新
framework.composer.packages.were.changed.0.test.config.title=Composer 軟體套件已被更改
framework.composer.packages.were.moved.to.0.php.include.paths.popup=Composer 軟體套件已從 Composer 外部庫移至 PHP include 路徑。
framework.composer.packages.were.removed.0.excluded.folders.popup=Composer 軟體套件已從排除的目錄中移除。
framework.composer.packages.were.removed.0.php.include.paths.popup=Composer 軟體套件已從 PHP include 路徑中移除。
framework.composer.path.dialog.path.to.composer=Composer 路徑
framework.composer.path.dialog.path.to.composer.json=composer.json 路徑
framework.composer.path.dialog.specify.composer.executable=指定 Composer 可執行檔案:
framework.composer.path.dialog.specify.composer.json=指定 composer.json:
framework.composer.path.dialog.specify.composer.phar=指定 Composer phar:
framework.composer.path.form.empty.path.to.composer.executable=Composer 可執行檔案路徑為空
framework.composer.path.form.empty.path.to.composer.json=composer.json 路徑為空
framework.composer.path.form.empty.path.to.composer.phar=composer.phar 路徑為空
framework.composer.path.form.execution.validation.wrapper=<html>執行未設定。<br/>{0}</html>
framework.composer.path.to.php.executable.titled=PHP 可執行檔案的路徑
framework.composer.path.validation.0.is.a.directory={0} 是目錄
framework.composer.project.generation.error.title=無法建立 Composer 專案
framework.composer.project.generator.description=通過 Composer 指令建立專案。
framework.composer.project.generator.failed.to.copy.temp.directory.0.content.to.project.root=無法將臨時目錄 ''{0}'' 內容複製到專案根目錄
framework.composer.project.generator.name=Composer 軟體套件專案
framework.composer.project.generator.notification.content.failed.to.find=找不到 {0}
framework.composer.project.generator.notification.content.failed.to.find.composer.json=無法在專案根目錄中找到 composer.json
framework.composer.remove.action.name=移除
framework.composer.removing.package.task.title=移除軟體套件
framework.composer.require.action.name=需要
framework.composer.require.task.title=正在安裝軟體套件 {0}
framework.composer.run.path.to.composer.json=composer.json 路徑:
framework.composer.run.script=腳本:
framework.composer.run.script.missing=未指定 Composer 腳本
framework.composer.script.run.configuration.description=Composer 腳本執行組態
framework.composer.script.run.configuration.name=Composer 腳本
framework.composer.selected.file.is.not.composer.json=所選檔案不是 composer.json
framework.composer.self.update.action.name=自我更新
framework.composer.self.update.task.title=更新 Composer
framework.composer.specify.php.executable.0=指定 PHP 可執行檔案 {0}
framework.composer.update.action.name=更新
framework.composer.update.task.title=正在更新軟體套件
framework.composer.updating.package.task.title=更新軟體套件
framework.composer.vendors.library.name=Composer 供應商
frameworks.composer.could.not.get.package.info=無法獲取軟體套件資訊。
frameworks.composer.could.not.get.packages.info.0=無法獲取軟體套件資訊。{0}
frameworks.settings.none.installed=沒有可用的框架設定提供程序。<br/>考慮安裝 Drupal Support、Joomla! Support 或 WordPress Support 延伸模組。
frameworl.composer.show.quick.actions=顯示具有快速動作的 composer.json 頂部面板
function=函式
function.call=函式呼叫
function.call.is.not.allowed.here=此處不允許使用函式呼叫
function.call.is.not.compatible.with.advance.callable.declaration=函式呼叫與 'callable' 宣告不相容
function.fqn=函式 FQN
function.has.parameter.with.incompatible.default.value.type=函式有一個預設值與其宣告的類型不相容的參數
function.name.must.be.callable.a.string.closure.or.class.implementing.invoke.currently.0=函式名稱必須可呼叫 - 字串、閉包或實作 ''__invoke'' 的類別，當前為 ''{0}''
function.ref.is.deprecated=函式 '#ref' 已棄用
function2=函式
functions.to.be.extracted=要提取的函式
generating.autoloader=正在生成自動載入器
getters.setters.configure=組態…
getting.installed.standards=正在獲取已安裝的標準…
global.code.should.be.enclosed.in.global.namespace.declaration=全域程式碼應包含在全域命名空間宣告中
global.namespace.should.use.braced.syntax=全域命名空間應使用帶大括號的語法
global.this.is.deprecated=不能將 $this 用作全域變數，它已在 PHP 7.1 中棄用
global.variable.from.globals.array.assignment=來自 $GLOBALS 陣列指派的全域變數
globals.can.only.be.modified.using.the.globals.name.value.syntax='$GLOBALS' 只能使用 '$GLOBALS[$name] = $value' 語法進行修改
group.ComposerGroup.text=Composer
group.ComposerToolsGroup.text=Composer
group.DBGPProxyGroup.text=DBGp 代理
group.PHPQualityToolsAddToIgnoredList.text=新增到忽略列表…
group.PhpDebuggerCopyAsGroup.text=將值複製為…
group.PhpNewTestGroup.text=PHP 測試
group.advanced.settings.php=PHP
group.methods.by.type=按類型對方法分組
group.use.statements.by.selected.prefix=按所選前綴將 'use' 語句分組
guality.tool.configuration.show.ignored.files=顯示忽略的檔案
gutter.overriden.select.implementation.title=選擇 {0} 的實作
gutter.overriden.select.subclass.title=選擇 {0} 的子類別
gutter.overriding.select.title=選擇要導覽的父方法
gutter.pin.overriden.select.implementation.title={0} 的實作
gutter.pin.overriden.select.subclass.title={0} 的實作
gutter.pin.overriding.select.title={0} 的父項
guzzle.http.request.gutter.name=Guzzle HTTP 請求
guzzle.invalid.http.request.file=檔案 ''{0}'' 是無效的 HTTP 請求檔案
guzzle.name=Guzzle
guzzle.open.http.request=在 HTTP 請求編輯器中開啟
guzzle.unable.to.add.new.request.to.file=無法向 ''{0}'' 檔案新增新請求
guzzle.unable.to.extract.request.parameters=無法提取請求參數
halt.compiler.can.only.be.used.from.the.outermost.scope=僅可從最外側作用域使用 '__halt_compiler()'
handler.with.the.same.session.id.is.already.registered=已註冊使用相同會話 ID 的處理程序
hint.evaluation.fully.contains=求值結果完全覆蓋 ''{0}'' 的可能結果
hint.evaluation.makes.array.always.empty=求值使得陣列始終為空
hint.evaluation.makes.subsequent.condition.always.true=求值使後續條件始終為 ''{0,choice,0#false|1#true}'
hint.text.can.not.find.target.class.for.modification=找不到要修改的目標類別。
hint.text.element.doesn.t.have.fqn=元素沒有 FQN
hint.text.installed.version=已安裝的版本
hint.text.target.class.does.not.belong.to.project.can.not.be.modified=目標類別 {0} 不屬於該專案\\n並且無法修改。
hint.text.target.class.not.writable=目標類別 {0} 不可寫。
hint.text.use.statement.choice.s.removed={0} ''use'' 語句{1, choice, 0#|1#}已移除
hint.text.use.statements.checked.nothing.was.removed=已檢查 {0} ''use'' 語句，未移除任何內容
host.name.eg.localhost.example.com=主機名。例如，localhost.example.com
hours.numeric=小時，數字(1、3、23)
hours.numeric.at.least.2.digits.with.leading.0=小時，數字，至少 2 位數，帶前導 0 (01、03、23)
how.to.fix=修正方法
html.note.core.extensions.are.part.of.the.php.core.and.cannot.be.left.out.of.a.php.binary.with.compilation.options.html=<html>註: 核心擴展是 PHP 核心的一部分，不能放在包含編譯選項的 PHP 二進制檔案外部。</html>
http.client.request.init.debug.connection.title=正在初始化偵錯連線
identifier=關鍵字
if.with.common.parts=具有通用部分的 'if'
if.you.have.already.configured.debug.extension.in.php.ini.file.check.possible.reasons.why.it.was.not.loaded=如果已在 php.ini 檔案中組態偵錯擴展，請檢查未載入該擴展的可能原因:
if.you.ve.changed.the.path.recently.restart.the.ide=如果最近更改了 %PATH%，請重啟 IDE。
if.you.ve.changed.the.path.recently.restart.the.ide1=如果最近更改了 $PATH，請重啟 IDE。
ignore.imports.and.formatting=忽略匯入和格式設定
implement.method=實作方法
import=匯入
import.from.deployment.configuration=從部署組態匯入
import.references.on.paste.dialog.message=<html>貼上的程式碼段使用 {0}，後者在目標作用域中不能通過匯入存取。<br/>選擇您想要匯入到作用域中的{0}。</html>
import.references.on.paste.dialog.title=選擇要匯入的{0}
in=位置:
in.0=\\ ({0} 中)
include.eol.slow=包括 eol (慢)
include.path=Include 路徑
include.path.column.info=路徑
incorrect.null.safe.operator=錯誤的 nullsafe 運算符
info=資訊
information=資訊
init.cache=初始化快取
initialize.var.quick.fix.family.name=使用值初始化
initializer=初始設定式
inject.language.using.phpdoc=使用 PHPDoc 注入語言
inlay.hints.usages.text={0,choice, 0#無用法|1#1 個用法|2#{0,number} 個用法}
insert.default.branch=插入 'default' 分支
inspection.add.override.attribute=使用 #[Override] 標記覆寫的方法
inspection.array.access.can.be.replaced.with.foreach.value=陣列存取可被取代為 'foreach' 值
inspection.array.modification.will.not.have.any.effect=按值修改從函式返回的陣列不會有任何影響
inspection.array.to.string.conversion=陣列到字串的轉換
inspection.arrayall.can.be.converted.to.loop='array_all()' 呼叫可以轉換為迴圈
inspection.arrayany.can.be.converted.to.loop='array_any()' 呼叫可以轉換為迴圈
inspection.arrayfill.can.be.converted.to.loop='array_fill()' 呼叫可以轉換為迴圈
inspection.arrayfilter.can.be.converted.to.loop='array_filter()' 呼叫可以轉換為迴圈
inspection.arrayfind.can.be.converted.to.loop='array_find()' 呼叫可以轉換為迴圈
inspection.arrayfindkey.can.be.converted.to.loop='array_find_key()' 呼叫可以轉換為迴圈
inspection.arraymap.can.be.converted.to.loop='array_map()' 呼叫可以轉換為迴圈
inspection.assignment.in.condition=條件中的指派
inspection.assignment.in.condition.move.assignment.out.of.condition.fix.name=從條件中移出指派
inspection.assignment.replaceable.with=<code>#ref</code> 可被取代為 ''{0}'' #loc
inspection.cannot.indirectly.modify.property.outside.of.scope=無法間接修改 ''set'' 可見性作用域之外的 ''{0}'' 屬性
inspection.cannot.modify.property.outside.of.scope=無法修改 ''set'' 可見性作用域之外的 ''{0}'' 屬性
inspection.cannot.modify.property.with.limited.set.visibility.from.global.scope=無法修改 'set' 可見性作用域之外的屬性
inspection.cannot.unset.property.outside.of.scope=無法在 ''set'' 可見性作用域之外取消設定 ''{0}'' 屬性
inspection.closure.can.be.converted.to.arrow.function=閉包可以轉換為箭頭函式
inspection.closure.can.be.converted.to.first.class.callable='Closure::fromCallable()' 可以轉換為一級可調用語法
inspection.code.patterns.panel.description.label=如果 fqn 名稱符合，則將程式碼標記為入口點
inspection.code.patterns.panel.description.text=將方法留空以表示建構函式 \\n任何 * 都將與 fqn 名稱中的一個或多個字元符合
inspection.code.patterns.panel.errors.class=模式必須是有效的 php fqn，僅接受 '*' 作為佔位符
inspection.code.patterns.panel.errors.member=方法模式 {0} 必須是有效的 php 關鍵字，僅接受 ''*'' 作為佔位符
inspection.codeSmell.class.call.is.not.casesensitive=類別用法中的大小寫與宣告中的大小寫不符合
inspection.codeSmell.function.call.is.not.casesensitive=函式/方法呼叫中的大小寫與宣告中的大小寫不符合
inspection.codeSmell.namespace.reference.is.not.casesensitive=命名空間參照中的大小寫與宣告中的大小寫不符合
inspection.codeSmell.overriding.method.visibility.description=方法可見性不應被覆寫
inspection.composer.file.reference.problem=路徑 ''{0}'' 未找到
inspection.composer.json.file.references.inspection.display.name=未解析的檔案參照
inspection.constructor.style=舊式建構函式
inspection.convert.to.json.validate='json_decode()' 和 'json_last_error()' 可以轉換為 'json_validate()'
inspection.curly.braces.access.syntax.usage=大括號存取語法自 PHP 7.4 已棄用
inspection.dead.code.problem.class.abstract.several.implementations={0} 具有{1, choice, 1#直接或間接實作|2# {1,number} 個直接或間接實作}，但<ul><li>其從未實例化或</li><li>不存在可從入口點到達的實例化。</li></ul>
inspection.dead.code.problem.class.nousages.synopsis=類別從未使用。
inspection.dead.code.problem.empty.constant.synopsis=常數從未使用。
inspection.dead.code.problem.empty.function.synopsis=函式從未使用。
inspection.dead.code.problem.multiple.constant.synopsis=常數有 {0, choice, 1#1 個用法|2#{0,number} 個用法}，但無法從入口點到達。
inspection.dead.code.problem.recursive.suspicious.function.synopsis=所有函式用法均屬於不存在可從入口點到達的成員的呼叫鏈。
inspection.dead.code.problem.single.constant.synopsis=常數有一個用法，但無法到達。
inspection.dead.code.problem.suspicious.function.synopsis=函式無法從入口點到達。
inspection.dead.code.problem.trait.additional.reachable=特徵具有可到達用法。
inspection.dead.code.problem.trait.additional.unreachable=特徵沒有可到達用法。
inspection.dead.code.problem.trait.synopsis=特徵從未使用。
inspection.deprecated.cast={0} 轉換自 PHP {1} 已棄用
inspection.deprecated.implode.usage=帶實參(陣列，字串)呼叫的 {0} 自 PHP 7.4 已棄用
inspection.disabled.quality.tool.inspection={0} 檢查已停用
inspection.disabled.quality.tool.inspection.fix=啟用檢查
inspection.disabled.quality.tool.inspection.open.fix=開啟檢查設定
inspection.division.by.zero=除以零
inspection.doc.field.type.mismatch={0, choice, 0#屬性|1#類別常數}類型不符合
inspection.doc.missing.return.tag.problem=函式/方法 PHPDoc 註釋中缺少 @return 標記
inspection.doc.throws.option.skip.on.empty.phpdoc=忽略沒有 @param/@return 的 PHPDoc
inspection.doc.throws.problem=PHPDoc 註釋不包含所有必需的 @throws 標記
inspection.duplicate.array.keys.display.name=重複的陣列鍵
inspection.duplicate.array.keys.problem=重複的陣列鍵
inspection.duplicate.array.keys.problem.0=值為 ''{0}'' 的重複陣列鍵
inspection.duplicate.match.arm.body=''match'' arm 是 ''{0}'' arm 的重複項
inspection.duplicate.match.condition.message=重複條件
inspection.duplicate.phpdoc.type.fix=從標記中移除重複類型
inspection.duplicate.phpdoc.type.problem=重複的類型 ''{0}''
inspection.duplicate.switch.case.body=''switch'' 中的分支是 ''{0}'' 分支的重複項
inspection.dynamic.method.called.as.static.problem=非 static 方法 '#ref' 不應被靜態呼叫
inspection.dynamic.method.called.as.static.problem.magic=非 static 方法 '#ref' 不應被靜態呼叫，但類別具有 '__magic' 方法。
inspection.export.results.back.traces=反向追蹤
inspection.export.results.const=常數
inspection.expression.have.same.operands=表達式有相同動作數
inspection.expression.result.unused.problem=表達式結果未在任何位置使用
inspection.ext.is.specified.in.require.dev.but.used.outside.tests=''{0}'' 在 ''require-dev'' 部分中指定，但在測試外部使用
inspection.ext.is.specified.in.suggest=''{0}'' 在 ''suggest'' 中指定，可能不可用
inspection.family.name.replace.implicit.octal.literal.with.explicit.one=將隱式八進制字面量取代為顯式八進制字面量
inspection.field.assignment.type.mismatch=類型不相容: 應為 ''{0}'' 類型的屬性，提供的是 ''{1}''
inspection.field.assignment.type.mismatch.multi.resolve=指派的類型 ''{0}'' 與屬性的宣告類型不相容
inspection.field.can.be.promoted=可以提升屬性
inspection.foreach.array.is.used.as.value.problem=變數 ''{0}'' 已被用作 ''array expression''
inspection.format.function.parameters.mismatch.conversion.specification=轉換規範未映射到任何參數
inspection.format.function.parameters.mismatch.parameter=參數未映射到任何轉換規範
inspection.fully.qualified.name.usage=限定符可被取代為匯入
inspection.fully.qualified.name.usage.name.option.ignore.global.namespace=忽略全域命名空間
inspection.fully.qualified.name.usage.option.enable.file.scope=在檔案作用域內啟用
inspection.group=PHP
inspection.group.code.smell=程式碼異味
inspection.group.code.style=程式碼樣式
inspection.group.control.flow=控制流
inspection.group.general=一般
inspection.group.naming.convention=命名約定
inspection.group.php.doc=PHPDoc
inspection.group.probably.bug=可能的 bug
inspection.group.type.compatibility=類型相容性
inspection.group.undefined=未定義
inspection.group.unused=未使用
inspection.group.unused.quickfix.label=未使用的元素
inspection.group.unused.quickfix.message=未使用的元素: ''{0}''
inspection.hierarchyChecks=類別層次結構檢查
inspection.hierarchyChecks.descr=類別必須被宣告為 abstract 或實作 {0}
inspection.hierarchyChecks.field.type.redeclaration.match.super.type=類型必須為 ''{0}''(如基類別 ''{1}'' 中)
inspection.hierarchyChecks.field.type.redeclaration.must.not.be.defined=類型不得定義(如基類別 ''{0}'' 中)
inspection.hierarchyChecks.should.implement=類別必須實作 {0}
inspection.ignored.class.alias.declaration=忽略了類別名聲明
inspection.illegal.array.key.type.problem=非法陣列鍵類型
inspection.illegal.psr.class.path.class.is.not.matched.to.psr0={0}名稱與包含檔名不符合
inspection.illegal.psr.class.path.namespace.name.is.not.matched.to.psr0=命名空間名稱與 PSR-0/PSR-4 專案結構不符合
inspection.illegal.string.offset.problem=非法字串偏移 {0}
inspection.incompatible.return.type=返回值應為 ''{0}''，返回的是 ''{1}''
inspection.incompatible.return.type.batch=返回值類型與宣告不相容
inspection.incompatible.return.type.strict.type.checking=嚴格類型檢查
inspection.inconsistent.return.points.option.treat.return=在 'void' 函式/方法中以相同方式對待 'return null' 和 'return'
inspection.inconsistent.return.points.problem1=缺少 'return' 語句
inspection.inconsistent.return.points.problem1.yield=缺少 'yield' 語句
inspection.inconsistent.return.points.problem2=缺少返回實參
inspection.invalid.function.result.used.problem=使用了 ''{0}'' {1} ''{2}'' 結果
inspection.invalid.function.result.used.problem.function=函式
inspection.invalid.function.result.used.problem.method=方法
inspection.json.all.not.installed.packages=未安裝軟體套件
inspection.json.duplicated.packages.0=require 和 require-dev 中存在重複的 ''{0}'' 條目
inspection.json.duplicated.packages.fix=從 require-dev 中移除重複項
inspection.json.not.installed.package.update.fix=更新軟體套件
inspection.json.not.installed.packages=未安裝軟體套件
inspection.json.not.installed.packages.install.fix=安裝軟體套件
inspection.json.not.installed.packages.update.fix=更新所有軟體套件
inspection.key.getter.setter.can.be.replaced.property.hooks=getter 和 setter 可被取代為 get 和 set 屬性掛鈎
inspection.language.level.quick.fix.switch.language.level.in.composer.0=切換到 composer.json 中的 PHP {0} 語言級別
inspection.language.level.quick.fix.switch.language.level.in.composer.manually.0=手動切換到 composer.json 中的 PHP {0} 語言級別
inspection.language.level.quick.fix.switch.language.level.name.0=切換到 PHP {0} 語言級別
inspection.loop.can.be.converted.to.arrayall=迴圈可以轉換為 array_all()' 呼叫
inspection.loop.can.be.converted.to.arrayany=迴圈可以轉換為 array_any()' 呼叫
inspection.loop.can.be.converted.to.arrayfill=迴圈可以轉換為 'array_fill()' 呼叫
inspection.loop.can.be.converted.to.arrayfilter=迴圈可以轉換為 'array_filter()' 呼叫
inspection.loop.can.be.converted.to.arrayfind=迴圈可以轉換為 'array_find()' 呼叫
inspection.loop.can.be.converted.to.arrayfindkey=迴圈可以轉換為 'array_find_key()' 呼叫
inspection.loop.can.be.converted.to.arraymap=迴圈可以轉換為 'array_map()' 呼叫
inspection.magic.method.visibility.cannot.be.static=魔術方法 ''{0}'' 不能為 static
inspection.magic.method.visibility.must.be.public=魔術方法 ''{0}'' 必須為 public
inspection.magic.method.visibility.must.be.static=魔術方法 ''{0}'' 必須為 static
inspection.mess.detector.validation.inspection.display.name=PHP Mess Detector 驗證
inspection.message.0.extends.class.with.final.tag=''{0}'' 會擴展帶有 @final 標記的類別
inspection.message.0.overrides.method.with.final.tag=''{0}'' 會覆寫帶有 @final 標記的方法
inspection.message.absolute.method.reference.should.be.specified.for.insteadof.trait.use.rule=應為 'insteadof' 特徵 use 規則指定絕對方法參照
inspection.message.always.true=條件始終為 ''{0,choice,0#false|1#true}'
inspection.message.always.true.because=條件始終為 ''{0, choice, 0#false|1#true}''，因為此時 ''{1}'' 已經為 ''{2, choice, 0#false|1#true}''
inspection.message.always.true.because.evaluated=條件始終為 ''{0,choice,0#false|1#true}''，因為此時對 ''{1}'' 求值
inspection.message.argument.with.type.deprecated.for.this.call=類型為 ''{0}'' 的實參對此呼叫已棄用
inspection.message.argument.without.name.identifier=無名稱關鍵字的實參
inspection.message.array.always.empty.at.this.point=陣列在此點始終為空
inspection.message.array.index.immediately.rewritten.before.accessing=陣列索引在存取之前會被立即覆蓋
inspection.message.array.key.unused=陣列密鑰未使用
inspection.message.array.push.with.single.element=只有一個元素的 'array_push'
inspection.message.array.to.string.conversion=陣列到字串的轉換
inspection.message.array.traversable.can.be.replaced.with.iterable=類型提示 'array|Traversable' 可被取代為 'iterable'
inspection.message.array.values.call.redundant='array_values' 呼叫冗餘
inspection.message.array.write.access.unused=未使用陣列寫入存取
inspection.message.arrayshape.can.be.added=ArrayShape 可以新增
inspection.message.assert.always.will.be.false=實參類型不相容，因為 'assertTrue()' 執行與 'true' 的嚴格比較
inspection.message.assertion.always.true=斷言始終為 ''{0,choice,0#false|1#true}'
inspection.message.assertion.always.true.because=斷言始終為 ''{0, choice, 0#false|1#true}''，因為此時 ''{1}'' 已經為 ''{2, choice, 0#false|1#true}''
inspection.message.assertion.always.true.because.evaluated=斷言始終為 ''{0,choice,0#false|1#true}''，因為此時 ''{1}'' 已求值
inspection.message.attribute.can.t.be.applied.to.because.it.doest.contains=特性不能應用於 {0}，因為它不包含 ''{1}'' 標誌
inspection.message.attribute.is.not.repeatable=特性不可重複，因為它不包含 'Attribute::IS_REPEATABLE' 標誌
inspection.message.behavior.unparenthesized.expressions.containing.both.will.change.in.php=同時包含 ''.'' 和 ''{0}'' 的無括號表達式可能會產生意外結果
inspection.message.branch.is.unused=從不執行 'switch' 分支
inspection.message.call.chain.too.long.to.analyse.break.it.into.fragments.up.to.calls=呼叫鏈過長，無法進行分析。請將其拆分為最多包含 {0} 個呼叫的片段
inspection.message.call.with.negative.width.deprecated=帶有負 'width' 實參的 'mb_strimwidth' 呼叫已棄用
inspection.message.call.with.two.arguments.deprecated=帶兩個實參的 ''{0}'' 呼叫已棄用
inspection.message.call.without.arguments.deprecated=不帶實參的 ''{0}'' 呼叫已棄用
inspection.message.calling.static.trait.member=直接呼叫 static 特徵成員已棄用。只應在使用特徵的類別上訪問。
inspection.message.can.be.final=可以為 'final'
inspection.message.can.be.merged.with=可以與 ''{0}'' 合併
inspection.message.can.be.removed=可以移除 ''{0}''
inspection.message.can.be.replaced.with=可被取代為 ''{0}''
inspection.message.can.be.replaced.with.assert.false=可被取代為 'assertFalse'
inspection.message.can.be.replaced.with.assert.true=可被取代為 'assertTrue'
inspection.message.can.be.replaced.with.const.syntax=可被取代為 'const' 語法
inspection.message.can.be.replaced.with.direct.parameter.access='func_get_arg' 可被取代為直接參數存取
inspection.message.can.be.replaced.with.fail=可被取代為 ''{0}''
inspection.message.can.be.replaced.with.in.array.call=可被取代為 ''{0}'' 呼叫
inspection.message.can.be.replaced.with.match.expression='if' 語句可被取代為 'match' 表達式
inspection.message.can.be.replaced.with.min.max.call=可被取代為 ''{0}'' 呼叫
inspection.message.can.be.replaced.with.named.argument=可被取代為命名實參
inspection.message.can.be.replaced.with.operator=可被取代為 '?->' 運算符
inspection.message.can.be.replaced.with.str.function=可被取代為 ''{0}''
inspection.message.can.be.replaced.with.version=表達式可被取代為 '??' 版本
inspection.message.cannot.assign.empty.string.to.string.offset=無法將空字串分配給字串偏移
inspection.message.cannot.create.references.to.from.string.offsets=無法建立到/從字串偏移的參照
inspection.message.cannot.increment.decrement.string.offsets=無法遞增/遞減字串偏移
inspection.message.cannot.make.method=無法將 {0} 方法設為 {1} {2}
inspection.message.cannot.make.method.visibility.lower.than.super.s=無法將方法的可見性設為低於父級的可見性
inspection.message.cannot.make.non.abstract.method.abstract=無法將非 abstract 方法設為 abstract
inspection.message.cannot.make.non.abstract.method.abstract.1=無法將非 abstract 方法 {0} 設為 abstract
inspection.message.cannot.make.non.static.method.static=無法將非 static 方法 {0} 設為 static
inspection.message.cannot.make.static.method.non.static=無法將 static 方法 {0} 設為非 static
inspection.message.cannot.override.final.method=無法覆寫 final 方法
inspection.message.cannot.override.final.method.1=無法覆寫 final 方法 {0}
inspection.message.cannot.override.final.property=無法覆寫 final 屬性
inspection.message.cannot.override.final.property.1=無法覆寫 final 屬性 ''{0}::\${1}''
inspection.message.cannot.override.final.property.hook=無法覆寫 final 屬性掛鈎
inspection.message.cannot.override.final.property.hook.1=無法覆寫 final 屬性掛鈎 {0}
inspection.message.cannot.stub.or.mock.using.method.list.that.contains.duplicates=不能使用包含重複項的方法列表進行存根或模擬
inspection.message.cannot.unset.string.offsets=無法取消設定字串偏移
inspection.message.cannot.use.assign.op.operators.with.string.offsets=無法將組合運算符指派與字串偏移一起使用
inspection.message.cannot.use.string.offset.as.array=無法將字串偏移用作陣列
inspection.message.cannot.use.string.offset.as.object=無法將字串偏移用作物件
inspection.message.cast.evaluable=轉換可被取代為 ''{0}''
inspection.message.cast.redundant=類型轉換冗餘
inspection.message.class.can.be.readonly=類別可以為 'readonly'
inspection.message.class.does.not.have.attribute=類別 ''{0}'' 未使用 ''Attribute'' 註解
inspection.message.class.may.inherit.from.final.class=類別可能無法繼承 final 類別
inspection.message.class.ref.marked.as.internal=類別 '#ref' 已標記為 @internal
inspection.message.classes.cannot.be.doubled=''{0}'' 類別無法重複
inspection.message.clone.method.cannot.be.static='Clone' 方法不能為 static
inspection.message.code.fragment.too.complex.to.parse.this.piece.code.will.be.treated.as.plain.text=程式碼段過於複雜，無法解析，因此將作為純文本處理
inspection.message.comment.can.be.replaced.with.named.argument=註釋可被取代為命名實參
inspection.message.comment.will.be.parsed.as.attribute.starting.with.php=從 PHP 8.0 起註釋被解析為特性
inspection.message.concatenation.can.be.merged.with.assignment.empty.string.literal=串聯可以與空字串字面量指派合併
inspection.message.condition.is.never.matched=條件從未符合
inspection.message.constant.from.base.class.referenced.via.child.class=通過子類別參照的基類別 ''{0}'' 中的常數
inspection.message.constant.reassignment=常數重新指派
inspection.message.constant.ref.marked.as.internal=常數 '#ref' 已標記為 @internal
inspection.message.constant.ref.not.found=未找到常數 '#ref'
inspection.message.constructor.cannot.be.static=建構函式不能為 static
inspection.message.continue.targeting.switch.equivalent.to.break=針對 'switch' 的 'continue' 相當於 'break'
inspection.message.control.flow.too.big.to.analyze=控制流太大，無法分析
inspection.message.count.used.as.array.index.to.append.element='count' 用作陣列索引以追加元素
inspection.message.dangerous.array.initialization=危險的陣列初始化
inspection.message.data.provider.method.should.be=資料提供程序方法應為 {0}
inspection.message.data.provider.method.should.not.require.arguments=資料提供程序方法不應需要實參
inspection.message.declaration.should.be.compatible.with=宣告應該與 {0} 相容
inspection.message.declaration.should.be.compatible.with.super=宣告應與父級相容
inspection.message.defining.custom.assert.function.deprecated=定義自定義 'assert()' 函式已棄用
inspection.message.defining.custom.assert.function.forbidden=禁止定義自定義 'assert()' 函式
inspection.message.deprecated.autoload.declaration='__autoload()' 宣告已棄用
inspection.message.destructor.cannot.be.static=解構函式不能為 static
inspection.message.doc.tag.without.variable.name.doesn.t.provide.type.information.for.any.expression=沒有變量名稱的 Doc 標記不提供任何表達式的類型資訊
inspection.message.double.quotes.are.unnecessary=雙引號不必要
inspection.message.duplicate.case.expression=重複 case 表達式
inspection.message.duplicate.case.expression.ref=重複 case 表達式: #ref
inspection.message.duplicate.character=重複字元
inspection.message.duplicates.catch.statement=重複 ''{0}'' 語句
inspection.message.element.already.covered.by=''{0}'' 已被 ''{1}'' 覆蓋
inspection.message.enum.field.reference.in.constant.expression.allowed.only.from.php=從 PHP 8.2 起才允許在常數表達式中參照枚舉欄位
inspection.message.exception.immediately.rethrown=立即重新拋出異常
inspection.message.exception.never.thrown.in.corresponding.try.block=相應的 ''try'' 塊中從未拋出異常 ''{0}''
inspection.message.existing.overriding.private.method.may.be.inaccessible=現有的覆寫 private 方法可能無法存取
inspection.message.existing.overriding.private.method.may.be.inaccessible.method=覆寫 private 方法 ''{0}'' 可能無法存取
inspection.message.exitpoint.attribute.can.be.added=可以新增 #[NoReturn] 特性
inspection.message.expression.always.choice=表達式始終為 ''{0}''
inspection.message.expression.have.duplicate.operand=表達式有重複的動作數 {0}
inspection.message.expression.not.changed.after.applying=套用 ''{0}'' 後，表達式不會改變
inspection.message.expression.without.parentheses=表達式沒有括號
inspection.message.extends.class.with.final.tag=擴展帶有 @final 標記的類別
inspection.message.field.assignment.can.be.converted.to.promoted.field=可以提升屬性
inspection.message.field.immediately.rewritten.before.accessing=屬性在存取之前會被立即覆蓋
inspection.message.field.ref.marked.as.internal=欄位 '#ref' 已標記為 @internal
inspection.message.for.loop.can.be.replaced.with.implode='foreach' 迴圈可被取代為 'implode()'
inspection.message.for.loop.can.be.replaced.with.str.repeat='for' 迴圈可被取代為 'str_repeat'
inspection.message.foreach.over.array.literal.with.single.element=對只有一個元素的陣列字面量執行 'foreach'
inspection.message.from.php.this.allowed={0}。從 PHP {1} 起才允許這樣。
inspection.message.function.deprecated.will.be.removed.in.phpunit=方法已棄用並已在 PHPUnit 10 中移除
inspection.message.function.deprecated.will.be.removed.in.phpunit.11=方法已棄用並已在 PHPUnit 11 中移除
inspection.message.function.may.produce.side.effects=函式可能會產生副作用
inspection.message.function.ref.marked.as.internal=函式 '#ref' 已標記為 @internal
inspection.message.generators.may.only.declare.return.type.generator.iterator.or.traversable.or.iterable.permitted=產生器只能宣告 ''Generator''、''Iterator''、''Traversable'' 或 ''iterable'' 的返回值類型，不允許 {0}
inspection.message.get.class.call.can.be.replaced.with.class.name.literal='get_class()' 呼叫可被取代為 '::class'
inspection.message.getter.setter.can.be.replaced.property.hooks={0} 可被取代為 {1}
inspection.message.goto.labels.inside.loops.or.switch.statements.are.not.allowed=不允許在迴圈或 switch 語句中使用 'goto' 標籤
inspection.message.if.can.be.replaced.with.version='if' 可被取代為 '??' 版本
inspection.message.if.statement.with.common.parts=包含通用部分的 ''{0}'' 語句
inspection.message.illegal.array.offset.access=嘗試存取類型為 ''{0}'' 的值的陣列偏移
inspection.message.immutable.property.write.scope.does.not.allow.write.access.here=無效的不可變屬性寫入: 作用域 ''{0}'' 不允許在此處進行寫入存取
inspection.message.instanceof.checks.in.catch.can.be.replaced.with.specific.catches='catch' 塊中的 'instanceof' 檢查可被取代為特定的 catch
inspection.message.interpolated.string.dereferencing.available.in.php.only=從 PHP 8.0 起才允許插值字串解參照
inspection.message.key.element.cannot.be.reference=鍵元素不能為參照
inspection.message.leading.slash.in.constant.fqn.will.not.be.trimmed.by.php=PHP 不會修剪常數 FQN 中的前導斜杠
inspection.message.local.object.used.only.for.writing.properties=區域物件僅用於寫入屬性
inspection.message.loop.can.be.replaced.with.0=迴圈可被取代為 ''{0}()''
inspection.message.magic.constant.dereferencing.available.in.php.only=從 PHP 8.0 起才允許魔術常數解參照
inspection.message.match.can.be.replaced.with.switch='match' 表達式可轉換為 'switch' 語句。
inspection.message.match.can.be.replaced.with.switch.changing.semantics='match' 表達式可以轉換為 'switch' 語句。請注意，'switch' 語句依賴於鬆散比較，這可能會改變表達式語意。
inspection.message.match.can.be.replaced.with.ternary='match' 表達式可被取代為三元表達式
inspection.message.max.must.be.greater.than.or.equal.to.argument.min='max' 實參必須大於或等於 'min'
inspection.message.method.may.produce.side.effects=方法可能會產生副作用
inspection.message.method.ref.marked.as.internal=方法 '#ref' 已標記為 @internal
inspection.message.method.reference.resolves.to.method.with.containing.class=''Use'' 規則解析為包含類別 ''{0}'' 中的方法
inspection.message.methods.cannot.be.mocked=''{0}'' 方法無法模擬
inspection.message.multiple.isset.calls.can.be.combined.into.one=可將多個 'isset' 呼叫合併為一個
inspection.message.name.parameter.may.be.different.depending.on.instance.class=在 ''{0}.{1}'' 中可能未解析命名實參
inspection.message.named.argument.usage=命名實參用法
inspection.message.nested.call.can.be.unwrapped=嵌套的 ''{0}'' 呼叫可以解包
inspection.message.never.returning.function.must.not.return='never' 返回函式不得返回
inspection.message.non.readonly.class.cannot.extend.readonly.class=非 ''readonly'' 類別不能擴展 ''readonly'' 類別 ''{0}''
inspection.message.non.readonly.property.readonly=無法將非 'readonly' 屬性重新宣告為 'readonly'
inspection.message.not.valid.backing.value.for.enum={0} 不是枚舉的有效支援值
inspection.message.only.first.byte.will.be.assigned.to.string.offset=只有第一個位元組將被分配給字串偏移
inspection.message.only.variables.can.be.passed.by.reference=僅可通過參照傳遞變數
inspection.message.operands.have.incompatible.types=動作數具有不相容的類型
inspection.message.overrides.method.with.final.tag=覆寫帶有 @final 標記的方法
inspection.message.parameter.name.changed.from.to=參數名稱由 ''{0}'' 更改為 ''{1}''
inspection.message.parentheses.are.unnecessary=圓括號不必要
inspection.message.pointless.boolean.expression=可以簡化布爾表達式
inspection.message.primitive.types.can.t.be.used.as.instanceof.argument=僅物件或字串應用作 ''instanceof'' 實參，當前: ''{0}''
inspection.message.prohibited.autoload.declaration=禁止使用 '__autoload()' 宣告
inspection.message.promoted.field.usage=提升的屬性用法
inspection.message.property.can.be.readonly=屬性可以為 'readonly'
inspection.message.property.only.read.but.never.written=屬性只讀取，但從未寫入
inspection.message.property.only.written.but.never.read=屬性僅寫入，但從未讀取
inspection.message.psr.compound.namespace.with.depth.more.than.two.levels=PSR-12: 複合命名空間的深度超過兩級
inspection.message.psr.missing.parameter.list=PSR-12: 缺少參數列表
inspection.message.psr.missing.visibility.definition=PSR-12: 缺少可見性定義
inspection.message.psr.order.modifiers.incorrect=PSR-12: 修飾符的順序不正確
inspection.message.psr.short.form.type.keywords.should.be.used=PSR-12: 應當使用類型關鍵字的縮寫
inspection.message.psr.traits.must.be.included.one.per.line=PSR-12: 必須以每行一個的形式新增特徵
inspection.message.psr.usage.else.if.construct=PSR-12: 使用 'else if' 結構
inspection.message.psr.usage.var=PSR-12: 'var' 的用法
inspection.message.pure.can.be.added=可以新增 ''{0}''
inspection.message.qualified.name.can.t.contain.whitespaces=限定名稱不能包含空格
inspection.message.readonly.class.cannot.extend.non.readonly.class=''readonly'' 類別不能擴展非 ''readonly'' 類別 ''{0}''
inspection.message.readonly.modifier.redundant='readonly' 修飾符冗餘
inspection.message.readonly.property.non.readonly=無法將 'readonly' 屬性重新宣告為非 'readonly'
inspection.message.redundant.argument={0, choice, 0#實參|1#實參}{0,choice,0#符合|1#符合}{0, choice, 0#參數的|1#參數的}預設{0, choice, 0#值|1#值}
inspection.message.redundant.assignment=冗餘的提升屬性指派
inspection.message.redundant.expression=冗餘表達式
inspection.message.redundant.method.override=方法覆寫冗餘
inspection.message.redundant.parenthesis=冗餘圓括號
inspection.message.redundant.static.in.final.class=final 類別中有冗餘的 'static'
inspection.message.remove.final.tag=移除 '@final' 標記
inspection.message.remove.final.tag.from.0=從 ''{0}'' PHPDoc 註釋中移除 ''@final'' 標記
inspection.message.replace.implicit.octal.literal.with.explicit.one=隱式八進制字面量可被取代為顯式八進制字面量
inspection.message.results.postfix.expression.unused=未使用後綴表達式的結果
inspection.message.return.type.declaration.must.be.compatible.with=返回值類型宣告必須與 {0} 相容: {1}
inspection.message.return.value.method.never.used=方法的返回值從未使用
inspection.message.returning.by.reference.from.void.function.deprecated=從 void 函式通過參照返回已棄用
inspection.message.second.write.to.readonly.property=無法修改 'readonly' 屬性
inspection.message.set.access.level.must.be.omitted=需要 'set' 的屬性不能是 'readonly'
inspection.message.should.be.one=值應為以下選項之一: {0}
inspection.message.should.probably.not.be.assigned=''{0}'' 可能不應分配給 ''{1}''
inspection.message.should.probably.not.be.passed.as.parameter=''{0}'' 可能不應作為參數 ''{1}'' 傳遞
inspection.message.spread.operator.can.be.unwrapped=展開運算符可以解包
inspection.message.spread.operator.over.literal.unnecessary.for.arguments.resolved.to.variadic.parameter=對於解析為可變參數的實參，字面量上的展開運算符不必要
inspection.message.statement.can.be.collapsed.into.parameter.default.value=語句可以摺疊到參數的預設值中
inspection.message.switch.can.be.replaced.with.match='switch' 語句無法轉換為 'match' 表達式
inspection.message.switch.has.only.default.case=switch 只有 'default' case
inspection.message.switch.has.only.single.case=switch 只有一個 case
inspection.message.too.many.messages.per.file.only.first.errors.warnings.are.shown=每個檔案中的訊息過多。僅顯示前 {0} 條。
inspection.message.too.many.messages.per.line=每行的訊息過多
inspection.message.tostring.method.must.return.string='__toString' 方法必須返回字串
inspection.message.trait.usage=不允許特徵用法
inspection.message.type.can.be.reduced.to=類型範圍可以限縮為 ''{0}''
inspection.message.type.mismatch.should.be.conditional.expression=類型不符合: 應為條件表達式
inspection.message.uncovered.enum.cases='match' 表達式具有未被覆蓋的 enum case
inspection.message.uncovered.enum.cases.switch='switch' 語句有未被覆蓋的枚舉 case
inspection.message.undefined.goto.label.ref=未定義的 goto 標籤 '#ref'
inspection.message.unnecessary.cast.to.string=不必要地轉換為 ''{0}''
inspection.message.unnecessary.curly.braces=不必要的大括號
inspection.message.unnecessary.else=不必要的 'else'
inspection.message.unnecessary.leading.slash=不必要的前導 ''
inspection.message.unused.private.property.ref=未使用的 private 屬性 '#ref'
inspection.message.use.statement.with.non.compound.name.ref.has.no.effect=包含非複合名稱 '#ref' 的 'use' 語句沒有任何作用
inspection.message.using.in.strings.deprecated.use.instead=在字串中使用 {0} 已棄用，請改用 {1}
inspection.message.using.variable.variables.in.strings.deprecated.use.instead=在字串中使用 {0} (可變變數)已棄用，請改用 {1}
inspection.message.value.parameter.always=參數值始終為 ''{0}''
inspection.message.value.ranges.mismatch.expected.actual=值範圍不符合。應為: {0}，實際為: {1}
inspection.message.var.export.with.return.argument.equals.false.always.returns.null=帶等於 ''false'' 的 ''return'' 實參的 ''{0}'' 始終返回 ''{1}''
inspection.message.var.export.without.return.argument.always.returns.null=不帶 ''return'' 實參的 ''{0}'' 始終返回 ''{1}''
inspection.message.variable.already.equal.to.assigned.value=變數已等於指派
inspection.message.will.be.covered.by=非必要條件，因為它由 ''{0}'' 檢查
inspection.message.with.single.string.argument=帶單個字串實參的 ''{0}''
inspection.message.write.access.to.readonly.property.outside.declaration.scope=無法寫入宣告作用域之外的 'readonly' 屬性
inspection.message.write.access.to.readonly.property.outside.declaration.scope.ret.by.ref='readonly' 屬性通過參照返回，可能會泄漏到宣告作用域之外
inspection.message.write.access.to.variable.that.still.references.array.value=對仍參照 'foreach' 中先前所用陣列值的變數的寫入權限
inspection.method.does.not.override.super=方法未從其超類別覆寫方法
inspection.method.may.be.static=方法可以為 'static'
inspection.method.parameters.count.mismatch=為方法呼叫提供了 {0} 個參數，但方法簽名使用了 {1} 個參數
inspection.method.parameters.count.mismatch.option.ignore.func.get.arg=忽略帶有 func_get_arg/func_get_args 呼叫的函式/方法
inspection.method.parameters.count.mismatch.option.ignore.underscore=忽略最後一個參數為 $_ 的函式/方法
inspection.method.to.string.is.not.implemented=沒有為類別 ''{0}'' 實作方法 ''__toString''
inspection.method.to.string.is.not.implemented.strict.mode=檢查每種表達式類型是否存在 __toString
inspection.missing.break.statement.problem=缺少 'break' 語句
inspection.missing.class.constant.type=缺少類別常數類型
inspection.missing.doc.comment.options.panel.class=類別(&C)
inspection.missing.doc.comment.options.panel.class.constant=類別常數(&A)
inspection.missing.doc.comment.options.panel.constant=常數(&O)
inspection.missing.doc.comment.options.panel.field=屬性(&P)
inspection.missing.doc.comment.options.panel.function=函式(&F)
inspection.missing.doc.comment.options.panel.ignore.private.members=忽略 private 成員
inspection.missing.doc.comment.options.panel.method=方法(&M)
inspection.missing.doc.comment.problem=缺少 PHPDoc 註釋
inspection.missing.doc.comment.problem.batch={0} 缺少 PHPDoc 註釋
inspection.missing.ext.composer.json=composer.json 中缺少 ''{0}''
inspection.missing.ext.require.bundled=需要 PHP 捆綁的擴展
inspection.missing.field.type=缺少屬性的類型宣告
inspection.missing.parent.call.message=缺少父方法呼叫
inspection.missing.parent.constructor.call.message=缺少父建構函式呼叫
inspection.missing.strict.types.declaration=缺少嚴格類型宣告
inspection.missing.strict.types.declaration.add.declaration=新增嚴格類型宣告
inspection.missing_param=缺少所需參數 ''{0}''
inspection.mockery.protected.method.cannot.be.mocked=在不呼叫 'Mock.shouldAllowMockingProtectedMethods' 的情況下，無法對 'protected' 方法進行模擬
inspection.multiple.classes.declarations.in.one.file=在此檔案中宣告了另一個類別
inspection.naming.convention.element.description.class=類別
inspection.naming.convention.element.description.constant=常數
inspection.naming.convention.element.description.function=函式
inspection.naming.convention.element.description.method=方法
inspection.naming.convention.element.description.property=屬性
inspection.naming.convention.element.description.variable=變數
inspection.naming.convention.element.descriptor.regexp={0} 名稱 <code>#ref</code> 不符合正則表達式 ''{1}'' #loc
inspection.naming.convention.problem.descriptor.long={0} 名稱 <code>#ref</code> 過長({1} > {2}) #loc
inspection.naming.convention.problem.descriptor.short={0} 名稱 <code>#ref</code> 過短({1} < {2}) #loc
inspection.nested.ternary.expression=嵌套三元表達式自 PHP 7.4 已棄用
inspection.nested.vs.outer.foreach.variables.conflict.problem1=變數 ''{0}'' 作為鍵用於內部和外部 ''foreach'' 迴圈
inspection.nested.vs.outer.foreach.variables.conflict.problem2=變數 ''{0}'' 作為值用於內部和外部 ''foreach'' 迴圈
inspection.never.function.result.used.problem.type=從未
inspection.non.strict.object.equality=非嚴格物件相等比較
inspection.nullsafe.deref.unnecessary.because=Nullsafe 運算符{0,choice,0#將始終產生 ''null''|1#不必要}，因為此時 ''{1}'' 已經為 ''{2,choice,0#false|1#true}''
inspection.nullsafe.deref.unnecessary.because.evaluated=Nullsafe 運算符 ''{0,choice,0#將始終產生 ''null''|1#不必要}''，因為此時對 ''{1}'' 求值
inspection.option.label.php.severity=PHP {0} 嚴重性:
inspection.option.label.php73.severity=PHP 7.3 嚴重性:
inspection.option.label.php8.severity=PHP 8 嚴重性:
inspection.optional.before.required=可選參數在需要前提供
inspection.parentheses.around.new.call.can.be.omitted=可以省略 'new' 呼叫周圍的圓括號
inspection.php.CS.fixer.validation.inspection.display.name=PHP CS Fixer 驗證
inspection.php.CS.validation.inspection.display.name=PHP_CodeSniffer 驗證
inspection.php.abstract.static.method.description=PHP 嚴格標準: static 方法 '#ref' 不應為 abstract
inspection.php.abstract.static.method.inspection.display.name=static 函式不應為 abstract
inspection.php.accessed.array.is.always.empty=陣列在存取點始終為空
inspection.php.acessing.static.trait.members=正在存取 static 特徵成員
inspection.php.add.line.break.after.trailing.comma=在尾隨逗號後新增換行符
inspection.php.annotation.can.be.replaced.with.attribute={0} 註解可被取代為特性
inspection.php.annotation.must.be.replaced.with.attribute={0} 註解必須取代為特性
inspection.php.arg.trigger.error.is.deprecated=自 PHP 8.4 起，將 'E_USER_ERROR' 傳遞給 'trigger_error()' 已被棄用
inspection.php.argument.without.name.identifier=無名稱關鍵字的實參
inspection.php.arithmetic.type.check=帶有不支持動作數的算術運算
inspection.php.array.access.on.illegal.type.display.name=非法類型的陣列偏移存取
inspection.php.array.append.using.count=使用 'count()' 作為索引將值追加到陣列
inspection.php.array.fill.can.be.converted.to.loop.inspection.display.name='array_fill' 可以轉換為迴圈
inspection.php.array.filter.can.be.converted.to.loop.inspection.display.name='array_filter()' 呼叫可以轉換為迴圈
inspection.php.array.index.immediately.rewritten=陣列索引會被立即覆寫
inspection.php.array.key.does.not.match.array.shape=陣列鍵與陣列形狀不符合 
inspection.php.array.map.can.be.converted.to.loop.inspection.display.name='array_map()' 呼叫可以轉換為迴圈
inspection.php.array.push.with.single.element=只有一個元素的 'array_push()'
inspection.php.array.search.can.be.replaced.with.in.array='array_search()' 可被取代為 'in_array()' 呼叫
inspection.php.array.traversable.can.be.replaced.with.iterable=類型提示 'array|Traversable' 可被取代為 'iterable'
inspection.php.array.used.only.for.write.inspection.display.name=陣列僅用於寫存取
inspection.php.array.write.access.is.not.used=未使用陣列寫入存取
inspection.php.assert.declaration.is.deprecated=已棄用的 'assert()' 函式宣告
inspection.php.assignment.in.condition.inspection.display.name=條件中的指派
inspection.php.assignment.replaceable.with.operator.assignment.inspection.display.name=指派可被取代為運算符指派
inspection.php.assignment.replaceable.with.prefix.expression.inspection.display.name=指派可被取代為增量或減量
inspection.php.attribute.array.shape.can.be.added=可以新增 '#[ArrayShape]' 特性
inspection.php.attribute.can.be.overridden=可以將特性新增到覆寫成員
inspection.php.attribute.is.not.repeatable=不可重複的特性
inspection.php.attribute.no.return.can.be.added=可以新增 NoReturn 特性
inspection.php.autoload.declaration.is.deprecated=已棄用的 '__autoload()' 函式宣告
inspection.php.autovivification.on.false.values='false' 到陣列的自動轉換已棄用
inspection.php.autovivification.on.false.values.possible=可能會導致將 'false' 轉換為數組，這一轉換已棄用
inspection.php.backed.property.with.set.hook.cant.be.accessed.by.ref.key=帶有 'set' 掛鈎的備用屬性無法通過參照存取
inspection.php.boolean.expression.can.be.simplified=可以簡化布爾表達式
inspection.php.cannot.apply.to.multiple.constants=無法同時將特性應用於多個常數
inspection.php.cannot.define.the.same.hooked.property={0} 和 {1} 在組合中定義相同的掛鈎屬性。目前不支持掛鈎屬性之間的衝突解決。
inspection.php.cast.is.evaluable=對標量值進行類型轉換
inspection.php.cast.is.unnecessary=類型轉換不必要
inspection.php.class.cant.be.used.as.attribute=類別不能用作特性
inspection.php.class.constant.accessed.via.child.class=通過子類別參照的類別常數
inspection.php.class.constant.can.be.final=類別常數可以為 'final'
inspection.php.class.implements.solely.traversable.inspection.display.name=類別無法直接實作 Traversable
inspection.php.class.naming.convention.inspection.display.name=類別名未遵循編碼約定
inspection.php.class.static.member.accessed.via.instance.inspection.display.name=通過執行個體存取的類別 static 成員
inspection.php.clone.can.be.replaced.with.clone.with='clone' 可以取代為 'clone with'
inspection.php.closure.can.be.converted.to.first.class.callable.inspection.display.name='Closure::fromCallable()' 可以轉換為一級可調用語法
inspection.php.closure.can.be.converted.to.short.arrow.function.inspection.display.name=閉包可以轉換為箭頭函式
inspection.php.comment.will.be.parsed.as.attribute=在 PHP 8.0 中註釋被解析為特性
inspection.php.composer.duplicated.requirement.inspection.display.name=composer.json 中存在重複的軟體套件條目
inspection.php.composer.extension.stubs.inspection.display.name=composer.json 中缺少擴展
inspection.php.compound.namespace.depth.inspection.display.name=複合命名空間深度大於 2
inspection.php.concatenation.with.arithmetic.usage=具有算術用法的串聯
inspection.php.concatenation.with.empty.string.can.be.merged=空字串的串聯可以與指派合併
inspection.php.condition.always.evaluates.to.constant=條件的求值結果始終為 'true/false'
inspection.php.condition.can.be.replaced.with.min.max.call=條件可被取代為 'min()'/'max()' 呼叫
inspection.php.condition.checked.by.next.condition=邏輯表達式內部的條件由後續條件檢查
inspection.php.constant.naming.convention.inspection.display.name=常數名稱未遵循編碼約定
inspection.php.constant.reassignment.inspection.display.name=常數重新指派
inspection.php.constructor.style.inspection.display.name=舊式建構函式
inspection.php.continue.targeting.switch='continue' 針對 'switch' 語句
inspection.php.covered.element.in.class=類別中的元素已被覆蓋
inspection.php.curly.brace.access.syntax.usage.inspection.display.name=使用了大括號存取語法
inspection.php.declaration.must.be.compatible.with.parent=宣告必須與父級相容並通過參照返回
inspection.php.define.constant.can.be.replaced.with.const.syntax=define 常數名稱可被取代為 'const' 語法
inspection.php.define.constant.name.with.leading.slash=使用前導斜杠定義的常數名稱
inspection.php.delete.redundant.isset.calls=刪除冗餘的 'isset' 呼叫
inspection.php.deprecated.cast.inspection.display.name=棄用的轉換
inspection.php.deprecated.dollar.brace.string.interpolation=已棄用的 '\${' 字串內插
inspection.php.deprecated.implode.usage.inspection.display.name=棄用的 'implode/join' 用法
inspection.php.deprecated.modifier=自 PHP {1} 起修飾符 ''{0}'' 已棄用
inspection.php.deprecated.partially.supported.callables.display.name=已棄用的部分支援可呼叫物件
inspection.php.deprecated.serializable.interface.usage.inspection.display.name=已棄用的 'Serializable' 接口用法
inspection.php.deprecated.stdlib.call=已棄用的標準庫呼叫
inspection.php.deprecation.inspection.display.name=已棄用
inspection.php.disabled.extension.stubs.description=已停用的 ''{0}'' 擴展存根
inspection.php.disabled.extension.stubs.inspection.display.name=已停用的擴展存根
inspection.php.disabled.quality.tool.composer.inspection.display.name=品質工具檢查已停用
inspection.php.division.by.zero.inspection.display.name=除以零
inspection.php.doc.duplicate.type.inspection.display.name=類型已存在於 PHPDoc 標記中
inspection.php.doc.field.type.mismatch.inspection.display.name=類型與屬性的宣告類型不符合
inspection.php.doc.is.not.complete.inspection.display.name=PHPDoc 註釋簽名不完整
inspection.php.doc.missing.throws.inspection.display.name=缺少 @throws 標記
inspection.php.doc.redundant.throws.inspection.display.name=冗餘 @throws 標記
inspection.php.doc.signature.description=重複的實參 PHPDoc
inspection.php.doc.signature.description2=返回值類型與宣告的不符合
inspection.php.doc.signature.description3=不存在實參的 PHPDoc
inspection.php.doc.signature.description5=實參類型與宣告的不符合
inspection.php.doc.signature.inspection.display.name=PHPDoc 註釋符合函式/方法簽名
inspection.php.doctrine.annotation.can.be.replaced.with.attribute=Doctrine 註解可被取代為特性
inspection.php.dql.builder.unknown.model=無法推斷 DQL 模型類別以啟用補全
inspection.php.dql.builder.unknown.model.quickfix.family.name=新增帶有模型類別類型的 PHPDoc
inspection.php.dql.builder.unknown.model.quickfix.name=新增帶有模型類別類型的 PHPDoc
inspection.php.duplicate.case.inspection.display.name=switch 語句中存在重複的 case
inspection.php.duplicate.character.in.str.function.call=函式呼叫中的重複字元
inspection.php.duplicate.match.arm.body.inspection.display.name='match' 表達式中的重複 arm
inspection.php.duplicate.match.condition.inspection.display.name=重複條件
inspection.php.duplicate.operand.in.comparison=比較中的重複動作數
inspection.php.duplicate.switch.case.body.inspection.display.name=switch 語句中存在重複分支
inspection.php.duplicate.switch.catch.body.inspection.display.name='catch' 語句中的重複分支
inspection.php.dynamic.as.static.method.call.inspection.display.name=動態方法被呼叫為 static
inspection.php.dynamic.field.declaration=動態屬性宣告
inspection.php.element.is.not.available.in.current.php.version.inspection.display.name=元素在組態的 PHP 版本中不可用
inspection.php.empty.index.operator.not.supported.for.strings=字串不支持 '[]' 運算符
inspection.php.empty.index.operator.not.supported.for.strings.display.name=字串不支持的空索引運算符
inspection.php.enforce.doc.comment.inspection.display.name=強制執行 PHPDoc 註釋
inspection.php.enum.case.with.value.not.found=枚舉中找不到包含指定值的 case
inspection.php.exception.is.immediately.rethrown=立即重新拋出異常
inspection.php.expected.values.should.be.used=應使用預期值
inspection.php.expression.always.constant.inspection.display.name=到達時，變數始終為 true/false
inspection.php.expression.always.null.description='#ref' 始終為 'null'
inspection.php.expression.always.null.inspection.display.name=表達式始終為 'null'
inspection.php.expression.result.unused.inspection.display.name=未使用表達式結果
inspection.php.expression.with.same.operands.inspection.display.name=邏輯表達式有相同動作數
inspection.php.expression.without.clarifying.parentheses.inspection.display.name=表達式不帶澄清括號
inspection.php.field.assignment.type.mismatch.inspection.display.name=屬性指派中的類型不符合
inspection.php.field.immediately.rewritten=屬性會被立即覆寫
inspection.php.field.reference.does.not.match.object.shape=欄位參照與物件形狀不符合
inspection.php.foreach.array.is.used.as.value.inspection.display.name=Foreach 陣列用作值
inspection.php.foreach.nested.outer.key.value.variables.conflict.inspection.display.name=嵌套與外部 'foreach' 變數衝突
inspection.php.foreach.over.single.element=對只有一個元素的陣列字面量執行 Foreach
inspection.php.foreach.variable.overwrite.already.defined.variable='foreach' 變數覆寫已定義的變數
inspection.php.format.function.call.with.single.argument=使用單個實參格式化函式呼叫
inspection.php.format.function.parameters.mismatch.inspection.display.name=格式函式參數不符合
inspection.php.fully.qualified.name.usage.inspection.display.name=使用了完全限定名稱
inspection.php.func.get.arg.can.be.replaced.with.parameter.access='func_get_arg()' 呼叫可被取代為參數存取
inspection.php.function.naming.convention.inspection.display.name=函式名稱未遵循編碼約定
inspection.php.get.class.can.be.replaced.with.class.name.literal.inspection.display.name='get_class()' 呼叫可被取代為 '::class'
inspection.php.get.hook.of.backed.property.with.set.hook.may.not.return.by.reference=如果定義了 'set' 掛鈎，無法通過 '\\\\&get' 返回備用屬性
inspection.php.goto.into.loop.inspection.display.name=Goto 轉入迴圈語句
inspection.php.group.attributes=特性
inspection.php.group.code.smell=程式碼異味
inspection.php.group.code.style=程式碼樣式
inspection.php.group.composer=Composer
inspection.php.group.control.flow=控制流
inspection.php.group.error.handling=錯誤處理
inspection.php.group.general=一般
inspection.php.group.naming.conventions=命名約定
inspection.php.group.phpdoc=PHPDoc
inspection.php.group.phpunit=PHPUnit
inspection.php.group.probable.bugs=可能的 bug
inspection.php.group.psr.12=PSR-12
inspection.php.group.quality.tools=品質工具
inspection.php.group.regexp=正則表達式
inspection.php.group.replacable.assignments=可取代指派
inspection.php.group.strict.standards=PHP 嚴格標準
inspection.php.group.type.compatibility=類型相容性
inspection.php.group.undefined=未定義的符號
inspection.php.group.unused=未使用的符號
inspection.php.highlight.only.closures.with.multiple.statements.option=僅醒目提示包含多條語句的閉包
inspection.php.hooked.property.cant.be.unset=掛鈎屬性不能取消設定
inspection.php.idempotent.operation=二元表達式中的冪等運算
inspection.php.if.can.be.merged.with.sequential.condition='if' 可以與後續條件合併
inspection.php.if.can.be.replaced.with.match.expression='if' 可被取代為 'match' 表達式
inspection.php.ignored.class.alias.declaration.display.name=忽略的類別名聲明
inspection.php.illegal.array.key.type.description={0} {1}
inspection.php.illegal.array.key.type.inspection.display.name=非法陣列鍵類型
inspection.php.illegal.psr.class.path.inspection.display.name=類別路徑與專案結構不符合
inspection.php.illegal.string.offset.inspection.display.name=非法字串偏移
inspection.php.immutable.property.is.written.in.invalid.scope=在無效的作用域中寫入不可變屬性
inspection.php.implicit.octal.literal.can.be.replaced.with.explicit.one=隱式八進制字面量可被取代為顯式八進制字面量
inspection.php.implicitly.marking.parameter.as.nullable.is.deprecated=將參數隱式標記為可為 null 已被棄用
inspection.php.in.array.can.be.replaced.with.comparison='in_array' 可被取代為比較
inspection.php.inapplicable.attribute.target.declaration=不適用的特性目標宣告
inspection.php.inappropriate.inherit.doc.usage.class.description=@inheritDoc 用於沒有帶 doc 註釋的父類別的類別
inspection.php.inappropriate.inherit.doc.usage.description=@inheritDoc 用於沒有父級成員但含有 doc 註釋的成員
inspection.php.inappropriate.inherit.doc.usage.description2=@inheritDoc 應僅用於類別成員
inspection.php.inappropriate.inherit.doc.usage.inspection.display.name=使用了不當的 @inheritDoc
inspection.php.include.description=無法解析表達式 ''{0}'' 的目標
inspection.php.include.description2=未找到路徑 ''{0}''
inspection.php.include.inspection.display.name=未解析的 include
inspection.php.incompatible.return.type.inspection.display.name=返回值類型不相容
inspection.php.incomplete.array.shape.implementation=根據形狀宣告，陣列不完整。缺少鍵: {0}
inspection.php.inconsistent.return.points.inspection.display.name=不一致的返回點
inspection.php.incorrect.magic.method.signature.inspection.display.name=魔術方法簽名不正確
inspection.php.indirect.modification.on.property.is.not.allowed=不允許間接修改屬性
inspection.php.indirect.modification.on.property.potential=潛在禁止的間接屬性修改
inspection.php.instanceof.checks.in.catch.can.be.replaced.with.specific.catches='catch' 塊中的 'instanceof' 檢查可被取代為特定的 catch
inspection.php.instanceof.is.always.true='instanceof' 的結果始終為 'true'
inspection.php.int.ranges.mismatch=數字範圍不符合
inspection.php.internal.array.index.reset.is.unnecessary=無需陣列內部指針重設
inspection.php.internal.array.index.reset.is.unnecessary.navigate.to.function=導覽到重設陣列內部指針的函式
inspection.php.internal.entity.used.inspection.display.name=使用了內部實體
inspection.php.invalid.delimiter.key=無效分隔符
inspection.php.invalid.function.result.used.inspection.display.name=使用了無效的函式結果
inspection.php.invalid.instanceof.argument.type='instanceof' 的實參只應是物件或字串
inspection.php.invalid.magic.method.modifiers.inspection.display.name=魔術方法修飾符無效
inspection.php.invalid.string.offset.usage=字串偏移用法無效
inspection.php.isset.can.be.replaced.with.coalesce='isset' 可被取代為合併
inspection.php.isset.can.check.nested.access.directly='isset' 可以直接檢查嵌套存取
inspection.php.isset.can.check.nested.array.access.subproperties.directly='isset' 可以直接檢查嵌套陣列存取和子屬性
inspection.php.language.level.description='fn' 是 PHP 7.4 中的保留關鍵字
inspection.php.language.level.inspection.display.name=語言級別
inspection.php.laravel.pint.inspection.display.name=Laravel Pint 驗證
inspection.php.long.type.form.inspection.display.name=類型關鍵字的縮寫
inspection.php.loop.can.be.converted.to.array.fill.inspection.display.name=迴圈可以轉換為 'array_fill()' 呼叫
inspection.php.loop.can.be.converted.to.array.filter.inspection.display.name=迴圈可以轉換為 'array_filter()' 呼叫
inspection.php.loop.can.be.converted.to.array.map.inspection.display.name=迴圈可以轉換為 'array_map()' 呼叫
inspection.php.loop.can.be.replaced.with.implode=迴圈可被取代為 'implode()'
inspection.php.loop.can.be.replaced.with.in.array=迴圈可被取代為 'in_array()' 或 'array_key_exists()' 呼叫
inspection.php.loop.can.be.replaced.with.str.repeat=迴圈可被取代為 'str_repeat'
inspection.php.loop.never.iterates=''{0}'' 語句不迴圈
inspection.php.loop.never.iterates.name=迴圈未迭代
inspection.php.match.can.be.replaced.with.switch.statement='match' 可被取代為 'switch' 語句
inspection.php.match.expression.can.be.replaced.with.ternary='match' 表達式可被取代為三元表達式
inspection.php.method.may.be.static.inspection.display.name=方法可以為 'static'
inspection.php.method.naming.convention.inspection.display.name=方法名稱未遵循編碼約定
inspection.php.method.or.class.call.is.not.case.sensitive.inspection.display.name=方法呼叫或類別用法中的大小寫不符合
inspection.php.method.parameters.count.mismatch.inspection.display.name=參數數量與宣告不符合
inspection.php.method.return.value.is.never.used=方法的返回值從未使用
inspection.php.missing.break.statement.inspection.display.name=缺少 'break' 語句
inspection.php.missing.doc.comment.inspection.display.name=缺少 PHPDoc 註釋
inspection.php.missing.field.type.inspection.display.name=缺少屬性的類型宣告
inspection.php.missing.param.type.description=缺少參數的類型宣告
inspection.php.missing.parameter.type.inspection.display.name=缺少參數的類型宣告
inspection.php.missing.parent.call.common.inspection.display.name=方法缺少父呼叫
inspection.php.missing.parent.call.magic.inspection.display.name=魔術方法缺少父呼叫
inspection.php.missing.parent.constructor.inspection.display.name=建構函式缺少父呼叫
inspection.php.missing.return.type.description=缺少函式的返回值類型宣告
inspection.php.missing.return.type.inspection.display.name=缺少返回值類型宣告
inspection.php.missing.strict.types.declaration.inspection.display.name=缺少嚴格類型宣告
inspection.php.missing.visibility.inspection.display.name=缺少可見性
inspection.php.mixed.return.type.can.be.reduced=可以限縮 'mixed' 返回值類型的範圍
inspection.php.mockery.invalid.mocking.target=無效的 Mockery 模擬目標
inspection.php.modifier.order.inspection.display.name=修飾符順序
inspection.php.modulo.operation.with.one=以 '1' 為動作數的取模運算
inspection.php.move.variable.inside.closure=在閉包內移動變數指派
inspection.php.multiple.class.declarations.inspection.display.name=多個類別宣告
inspection.php.multiple.classes.declarations.in.one.file.display.name=一個檔案中有多個類別宣告
inspection.php.multiple.isset.calls.can.be.replaced.with.one=可將多個 'isset' 呼叫取代為一個
inspection.php.name.variable.is.used.only.inside.closure=變數僅在閉包內使用
inspection.php.named.argument.may.be.unresolved=命名實參可能未解析
inspection.php.named.argument.usage=有名稱關鍵字的實參
inspection.php.named.arguments.with.changed.order=命名實參順序與參數順序不符合
inspection.php.navigate.to.variable.assignment=導覽到變數指派
inspection.php.nested.dirname.call.can.be.replaced.with.levels.usage=嵌套的 'dirname()' 呼叫可被取代為 'levels' 參數用法
inspection.php.nested.min.max.call=嵌套的 'min/max' 呼叫
inspection.php.nested.ternary.expression.usage.inspection.display.name=使用了嵌套的三元運算符
inspection.php.never.typed.function.returning.value='never' 類型的函式返回一個值
inspection.php.new.class.missing.parameter.list.inspection.display.name=缺少參數列表
inspection.php.non.canonical.elements.order.description=變數及其類型以非規範順序列出
inspection.php.non.canonical.elements.order.inspection.display.name=元素的非規範順序
inspection.php.non.compound.use.inspection.display.name=不必要的語句使用
inspection.php.non.strict.object.equality.inspection.display.name=非嚴格物件相等
inspection.php.not.installed.packages.inspection.display.name=未安裝的 Composer 軟體套件
inspection.php.null.is.not.compatible.with.parameter='null' 與參數的宣告類型不相容
inspection.php.null.safe.operator.can.be.used=可以使用 Nullsafe 運算符 '?->'
inspection.php.object.fields.are.only.written=區域物件僅用於寫入屬性
inspection.php.object.shape.can.be.added=ObjectShape 可以新增
inspection.php.open.echo.tag.inspection.display.name=開啟 'echo' 標記用法
inspection.php.optional.before.required.parameters.inspection.display.name=可選參數在必選參數之前
inspection.php.overriding.method.extending.class.marked.as.final=被標記為 '@final' 的覆寫方法/擴展類別
inspection.php.overriding.method.visibility.inspection.display.name=方法可見性不應被覆寫
inspection.php.parameter.always.have.same.value=參數值始終相同
inspection.php.parameter.by.ref.is.not.used.as.reference.inspection.display.name=不必要的通過參照傳遞
inspection.php.parameter.name.chaged.during.inhertiance=在繼承期間更改了參數名稱
inspection.php.params.inspection.display.name=參數類型
inspection.php.pass.by.ref.description=僅變數可通過參照返回
inspection.php.pass.by.ref.inspection.display.name=通過參照傳遞參數
inspection.php.passing.0.dba.key.split.is.deprecated=自 PHP 8.4 起，將 ''{0}'' 傳遞給 ''dba_key_split()'' 已被棄用
inspection.php.passing.0.type.1.is.deprecated=自 PHP 8.4 起，傳遞除 ''{1}'' 之外的其他類型的 ''{0}'' 已被棄用
inspection.php.passing.non.callable.string.is.deprecated=自 PHP 8.4 版起，將不可呼叫字串傳遞給 'xml_set_*_handler()' 函式已被棄用
inspection.php.passing.non.empty.enclosure.to.csv.function.is.deprecated=自 PHP 8.4 起，為 '$escape' 參數傳遞非空字串已被棄用
inspection.php.passing.null.or.false.dba.key.split.is.deprecated=自 PHP 8.4 起，將 'null' 或 'false' 傳遞給 'dba_key_split()' 已被棄用
inspection.php.passing.option.type.is.deprecated=自 PHP 8.4 起，傳遞錯誤類型的選項已被棄用
inspection.php.plural.mixed.can.be.replaced.with.array='mixed' 類型可被取代為 'array'
inspection.php.pointless.boolean.expression='if' 條件內的無意義布爾表達式
inspection.php.possible.polymorphic.invocation.inspection.display.name=可能的多態呼叫
inspection.php.pow.call.can.be.replace.with.pow.operator='pow()' 呼叫可被取代為 '**' 運算符
inspection.php.preg.match.can.be.replaced.with.comparison='preg_match()' 可被取代為比較
inspection.php.preg.match.redundant.closure=冗餘閉包 '.*'
inspection.php.preg.match.without.regular.expression='preg_match' 可被取代為 'str_contains'
inspection.php.preg.replace.with.empty.replacement.name='preg_replace()' 可被取代為 '(l|r)trim' 呼叫
inspection.php.preg.split.can.be.replaced.with.explode='preg_split' 可被取代為 'explode'
inspection.php.private.field.can.be.local.variable.description=屬性可被取代為區域變數
inspection.php.private.field.can.be.local.variable.inspection.display.name=private 屬性可為區域
inspection.php.private.method.may.be.inaccessible.in.late.static.binding.call=在延遲 static 綁定呼叫期間可能無法存取 private 方法
inspection.php.promoted.field.usage=提升的屬性用法
inspection.php.property.can.be.promoted.with.private.set.modifier=可以使用 'private(set)' 可見性修飾符提升屬性
inspection.php.property.can.be.readonly=屬性可以為 'readonly'
inspection.php.property.can.be.replaced.with.private.set.modifier=屬性可以取代為 'private(set)' 可見性修飾符
inspection.php.property.naming.convention.inspection.display.name=屬性名稱未遵循編碼約定
inspection.php.property.only.written=屬性用法具有相同的存取權限
inspection.php.property.without.set.hook.can.be.replaced.with.private.set.visibility.modifier=沒有 'set' 掛鈎的屬性可以取代為 'private(set)' 可見性修飾符
inspection.php.psalm=Psalm
inspection.php.pure.contract.attribute.can.be.added=可以新增 '#[Pure]' 特性
inspection.php.pure.function.may.produce.side.effect=純函式可能會產生副作用
inspection.php.raising.zero.to.the.power.of.negative.number.is.deprecated=自 PHP 8.4 起，0 的負數次方已被棄用。
inspection.php.rand.arguments.in.revers.order=順序錯誤的 'rand' 函式實參
inspection.php.ranges.in.class.can.re.merged=類別中的範圍可以合併
inspection.php.redeclaration.stdlib.function=標準庫函數的重複宣告
inspection.php.redeclaration.stdlib.function.description=不能重複宣告標準庫函數 ''{0}''
inspection.php.redundant.array.call.in.foreach.iterated.value=對 'foreach' 中迭代的值的冗餘 'array_values' 呼叫
inspection.php.redundant.assignment.to.promoted.field=冗餘的提升屬性指派
inspection.php.redundant.attribute.parenthesis=特性中的冗餘圓括號
inspection.php.redundant.catch.clause.inspection.display.name=冗餘 catch 子句
inspection.php.redundant.closing.tag.inspection.display.name=冗餘結束標記
inspection.php.redundant.continue.break.argument=冗餘的 'continue/break' 實參
inspection.php.redundant.doc.comment.inspection.display.name=冗餘 PHPDoc 註釋
inspection.php.redundant.match.expression='match' 表達式只有 default arm，應當進行簡化
inspection.php.redundant.method.override=冗餘方法覆寫
inspection.php.redundant.modifier=冗餘的 ''{0}'' 修飾符
inspection.php.redundant.modifier.key=冗餘修飾符
inspection.php.redundant.optional.argument=冗餘的可選實參
inspection.php.redundant.type.in.union.type=類型宣告冗餘，可以簡化
inspection.php.redundant.type.in.union.type.fix.name=簡化冗餘類型
inspection.php.redundant.type.in.union.type.template=類型宣告可以簡化為 ''{0}''
inspection.php.redundant.variable.doc.type.description=@var 標記指定了已從原始碼推斷出的類型
inspection.php.redundant.variable.doc.type.inspection.display.name=冗餘 @var 標記
inspection.php.regexp.delimiter.is.alphanumeric.or.backslash=分隔符是字母數字或反斜杠
inspection.php.regexp.delimiter.is.used.in.reg.exp=在正則表達式中使用了分隔符
inspection.php.regexp.n.modifier.can.be.replaced.with.non.capturing.groups='n' 修飾符可被取代為非捕獲組
inspection.php.regexp.replace.n.modifier.with.non.capturing.groups=將 'n' 修飾符取代為非捕獲組
inspection.php.regexp.replace.with.valid.delimiter=取代為有效分隔符
inspection.php.remove.modifier=移除修飾符 ''{0}''
inspection.php.remove.useless.trailing.comma=移除無用的尾隨逗號
inspection.php.replace.annotation.with.attribute=將註解取代為特性
inspection.php.return.doc.type.mismatch=PHPDoc 中的返回值類型與實際返回值類型不符合
inspection.php.return.doc.type.mismatch.inspection.display.name=PHPDoc 註釋中的返回值類型與實際返回值類型不符合
inspection.php.second.write.to.readonly.property=第二次寫入 'readonly' 屬性
inspection.php.separate.else.if.inspection.display.name=Else if
inspection.php.short.echo.open.tag.description=短 echo 起始標記用法
inspection.php.short.open.echo.tag.inspection.display.name=短起始 'echo' 標記用法
inspection.php.short.open.tag.description=使用了短起始標記
inspection.php.short.open.tag.inspection.display.name=使用了短起始標記
inspection.php.signature.mismatch.during.inheritance.inspection.display.name=覆寫方法的宣告應與父類別相容
inspection.php.silly.assignment.inspection.display.name=冗餘指派
inspection.php.single.statement.with.braces.inspection.display.name=單語句主體帶大括號
inspection.php.statement.has.empty.body.description=語句具有空體
inspection.php.statement.has.empty.body.inspection.display.name=語句具有空體
inspection.php.statement.without.braces.inspection.display.name=控制語句主體無大括號
inspection.php.static.as.dynamic.method.call.inspection.display.name=static 方法被呼叫為動態
inspection.php.str.functions.inspection.display.name='str*()' 呼叫可被取代為 PHP 8 'str_*()' 呼叫
inspection.php.strict.comparison.of.operands.with.different.types=嚴格比較類型不相容的動作數
inspection.php.strict.type.checking.inspection.display.name=嚴格類型檢查規則違反
inspection.php.super.class.incompatible.with.interface.inspection.display.name=父類別的方法宣告與實作的接口不相容
inspection.php.suspicious.name.combination.inspection.name=可疑名稱組合
inspection.php.switch.can.be.replaced.with.match.expression='switch' 可被取代為 'match' 表達式
inspection.php.switch.case.without.default.branch.inspection.display.name=switch 語句沒有 default 分支
inspection.php.symfony.annotation.can.be.replaced.with.attribute=Symfony 註解可被取代為特性
inspection.php.ternary.expression.can.be.replaced.with.condition.inspection.display.name=三元表達式可被取代為條件
inspection.php.ternary.expression.can.be.replaced.with.short.version=三元表達式可被取代為短版本
inspection.php.throwable.not.thrown.inspection.display.name=未拋出 Throwable
inspection.php.to.string.implementation.inspection.display.name=方法 '__toString' 實作
inspection.php.to.string.may.produce.exception='__toString' 可能會拋出異常
inspection.php.to.string.return.inspection.display.name=方法 '__toString' 返回值類型
inspection.php.too.long.member.reference.chain=成員參照鏈過長，無法分析
inspection.php.too.many.parameters.inspection.display.name=函式宣告中的參數過多
inspection.php.traditional.syntax.array.literal.inspection.display.name=檢測到傳統語法陣列字面量
inspection.php.trait.method.use.is.located.inside.different.target.class=特徵 use 規則已解析為使用不同包含類別的方法 
inspection.php.trait.usage=不允許特徵用法
inspection.php.traits.use.list.inspection.display.name=每行一個特徵 use
inspection.php.tried.to.read.from.virtual.property.without.getter=無法從未定義 getter 的 virtual 屬性中讀取
inspection.php.tried.to.write.to.virtual.property.without.setter=無法向未定義 setter 的 virtual 屬性寫入
inspection.php.type.tag.without.variable.name=不帶變數名稱的類型標記
inspection.php.typed.property.might.be.uninitialized.inspection.display.name=類型化屬性可能未初始化
inspection.php.typed.property.might.be.uninitialized.inspection.problem=類型化屬性 ''{0}'' 可能未初始化
inspection.php.uncovered.enum.cases=某些 enum case 未被覆蓋
inspection.php.undefined.callback.inspection.display.name=未定義的回調
inspection.php.undefined.class.constant.inspection.display.name=未定義的類別常數
inspection.php.undefined.class.description=類別 '#ref' 存在多個定義
inspection.php.undefined.class.description2=未定義的類別 '#ref'
inspection.php.undefined.class.description5=存在類別 '#ref' 的其他宣告
inspection.php.undefined.class.inspection.display.name=未定義的類別
inspection.php.undefined.class.other.declaration.exists={0} 處存在類別 ''#ref'' 的其他宣告
inspection.php.undefined.class.other.declaration.exists.and={0} 和另 {1} 處存在類別 ''#ref'' 的其他宣告
inspection.php.undefined.constant.inspection.display.name=未定義的常數
inspection.php.undefined.field.inspection.display.name=未定義的屬性
inspection.php.undefined.function.inspection.display.name=未定義的函式
inspection.php.undefined.goto.label.inspection.display.name=未定義的 goto 標籤
inspection.php.undefined.method.inspection.display.name=未定義的方法
inspection.php.undefined.namespace.description=未定義的命名空間 '#ref'
inspection.php.undefined.namespace.inspection.display.name=未定義的命名空間
inspection.php.undefined.variable.inspection.display.name=未定義的變數
inspection.php.underscore.as.class.name.is.deprecated=自 PHP 8.4 起，使用單下劃線 '_' 作為類別名已被棄用
inspection.php.unhandled.exception.inspection.display.name=未處理的異常
inspection.php.unit.annotation.can.be.replaced.with.attribute=PHPUnit 註解在 PHPUnit 11 中已棄用，可被取代為特性
inspection.php.unit.assert.always.execute.to.same.result=實參類型不相容的 'assertTrue()'
inspection.php.unit.assert.array.has.key.inspection.display.name=可以改用方法 'assertArrayHasKey/assertArrayNotHasKey'
inspection.php.unit.assert.can.be.replaced.with.assert.true.false=斷言可被取代為 'assertTrue/assertFalse'
inspection.php.unit.assert.can.be.replaced.with.fail=斷言可被取代為 'fail'
inspection.php.unit.assert.contains.inspection.display.name=棄用的 'assertContains/assertNotContains' 用法
inspection.php.unit.assert.count.inspection.display.name=使用了 'assertCount/assertSameSize' 方法而非 assertEquals
inspection.php.unit.assert.empty.inspection.display.name=斷言可被取代為 'assertEmpty/assertNotEmpty'
inspection.php.unit.assert.equals.inspection.display.name=棄用的 'assertEquals/assertNotEquals' 用法
inspection.php.unit.assert.file.equals.inspection.display.name=棄用的 'assertFileEquals/assertStringEqualsFile' 用法
inspection.php.unit.covers.by.access.modifier.is.deprecated.inspection.display.name=棄用的通過修飾符註解進行的 @covers/@uses
inspection.php.unit.covers.function.without.scope.resolution.operator.inspection.display.name=提供的覆蓋函式參照沒有 '::'
inspection.php.unit.deprecated.call.in.phpunit.10=方法在 PHPUnit 10 中已棄用
inspection.php.unit.deprecated.call.in.phpunit.11=方法在 PHPUnit 11 中已棄用
inspection.php.unit.deprecated.data.provider.signature.inspection.display.name=自 PHPUnit 10 以來，已棄用資料提供程序
inspection.php.unit.deprecated.expect.exception.inspection.display.name=使用了棄用的 expectException
inspection.php.unit.expected.exception.doc.tag.is.deprecated.inspection.display.name=棄用的通過文檔標記進行的異常處理
inspection.php.unit.failed.line=測試中失敗的行
inspection.php.unit.invalid.mocking.target=無效的 PHPUnit 模擬目標
inspection.php.unit.misordered.assert.equals.arguments.inspection.display.name=順序錯誤的 PHPUnit 等式斷言方法實參
inspection.php.unit.missing.target.for.test.inspection.display.name=PHPUnit 測試缺少目標元素
inspection.php.unit.undefined.data.provider.inspection.display.name=未定義的 PHPUnit 資料提供程序
inspection.php.unknown.modifier=未知修飾符 ''{0}''
inspection.php.unnecessary.continue='continue' 不必要，因為是迴圈中的最後一條語句
inspection.php.unnecessary.curly.variable.syntax=變數的不必要大括號語法
inspection.php.unnecessary.double.quotes.display.name=不必要的雙引號
inspection.php.unnecessary.else.inspection.display.name=不必要的 'else' 分支
inspection.php.unnecessary.fully.qualified.name.inspection.display.name=不必要的完全限定名稱
inspection.php.unnecessary.leading.backslash.in.use.statement='use' 語句中有不必要的前導 ''
inspection.php.unnecessary.local.variable.inspection.display.name=不必要的區域變數
inspection.php.unnecessary.parentheses.inspection.display.name=不必要的圓括號
inspection.php.unnecessary.return.function='return' 不必要，因為是函式中的最後一條語句
inspection.php.unnecessary.return.inspection.display.name=不必要的 'return/continue' 語句
inspection.php.unnecessary.return.method='return' 不必要，因為是方法中的最後一條語句
inspection.php.unnecessary.semicolon.description=不必要的 ;
inspection.php.unnecessary.semicolon.inspection.display.name=不必要的分號
inspection.php.unnecessary.spread.operator.for.function.call.argument=函式呼叫實參的不必要展開運算符
inspection.php.unpacked.argument.type.mismatch.inspection.display.name=無效類型的解包實參
inspection.php.unpacking.arrays.with.string.keys.inspection=對於 PHP 8.1 之前的版本，禁止使用字串鍵解包陣列
inspection.php.unsupported.modifier=自 PHP {1} 起不支持修飾符 ''{0}''
inspection.php.unsupported.modifier.key=不支持的修飾符
inspection.php.unused.alias.description=匯入 '#ref' 不必要
inspection.php.unused.alias.description2=匯入 '#ref' 從未使用
inspection.php.unused.alias.inspection.display.name=未使用的 import
inspection.php.unused.display.name=未使用的宣告
inspection.php.unused.field.default.value.description=屬性初始設定式冗餘
inspection.php.unused.field.default.value.inspection.display.name=冗餘屬性初始設定式
inspection.php.unused.local.variable.inspection.display.name=未使用的區域變數
inspection.php.unused.match.arm.condition.inspection.display.name=未使用的 'match' 條件
inspection.php.unused.parameter.inspection.display.name=未使用的參數
inspection.php.unused.private.field.inspection.display.name=未使用的 private 屬性
inspection.php.unused.private.method.inspection.display.name=未使用的 private 方法
inspection.php.unused.switch.case.inspection.display.name=未使用的 'switch' 分支
inspection.php.usage.of.silence.operator.inspection.display.name=使用了靜默運算符
inspection.php.useless.trailing.comma.inspection.desc=無用的尾隨逗號
inspection.php.useless.trailing.comma.inspection.display.name=無用的尾隨逗號
inspection.php.var.export.used.without.return.argument=使用 'var_export' 或 'print_r' 調用時不帶 'return' 實參
inspection.php.var.usage.inspection.display.name=使用了 var
inspection.php.variable.naming.convention.inspection.display.name=變數名稱未遵循編碼約定
inspection.php.variable.variable.inspection.display.name=使用了可變變數
inspection.php.void.function.result.used.inspection.display.name=使用了 void 函式結果
inspection.php.write.access.to.readonly.property.outside.declaration.scope=對宣告作用域之外的 'readonly' 屬性的寫入權限
inspection.php.write.access.to.referenced.array.value.without.unset=對無 'unset' 的參照陣列值的寫入權限
inspection.php.wrong.catch.clauses.order.inspection.display.name=catch 子句順序錯誤
inspection.php.wrong.foreach.argument.type.inspection.display.name=為 'foreach()' 提供的無效實參
inspection.php.wrong.string.concatenation.inspection.display.name=字串串聯錯誤
inspection.phpunit.asserts.array.has.key.can.be.used.instead=可以改用方法 ''{0}''
inspection.phpunit.asserts.assert.with.count.function=可以使用方法 {0} 代替 {1}
inspection.phpunit.asserts.assertEquals.misordered.arguments=順序錯誤的 ''{0}()'' 實參
inspection.phpunit.asserts.assertEquals.parameters.empty=帶有此類別參數的呼叫已棄用
inspection.phpunit.asserts.assertEquals.parameters.many=可選的 {0} 個參數已棄用
inspection.phpunit.asserts.assertEquals.parameters.single=可選的 {0} 個參數已棄用
inspection.phpunit.covers.function.without.scope.resolution.operator=提供的覆蓋{0}參照沒有 ''::''
inspection.phpunit.expectException=對將 expectException() 用於 {0} 的支援已棄用，將在 PHPUnit 10 中移除。請改用 {1}()。
inspection.phpunit.missing.target.element.ref=未找到 '#ref' 的測試目標元素
inspection.phpunit.will.deprecation=對使用 {0}() 的支援已棄用，將在 PHPUnit 12 中移除。請改用 {1}()。
inspection.probably.undefined.property=屬性 '#ref' 已動態宣告，可能未定義
inspection.property.declared.dynamically=動態宣告的屬性
inspection.property.declared.dynamically.deprecated=動態宣告的屬性，從 PHP 8.2 開始已棄用。
inspection.property.hook.can.be.can.be.shortened=屬性掛鈎可以縮短
inspection.redundant.closing.tag.fix.remove=移除結束標記
inspection.redundant.closing.tag.problem=冗餘結束標記
inspection.redundant.intersection.type=冗餘的交叉類型
inspection.redundant.intersection.type.fix=交叉類型可以簡化為 ''{0}''
inspection.redundant.intersection.type.fix.name=簡化交叉類型
inspection.redundant.phpdoc=冗餘 PHPDoc 註釋
inspection.redundant.phpdoc.tag=冗餘的 PHPDoc 標記
inspection.set.visibility.can.be.removed=可以移除 'set' 可見性
inspection.severity.with.magic=當 __magic 存在時顯示
inspection.silly.assignment.problem=指派左右兩側相等
inspection.single.statement.with.braces=單語句主體帶大括號
inspection.single.statement.with.braces.fix.name=從 ''{0}'' 語句中移除大括號
inspection.statement.has.empty.body.comments.count.as.content=註釋計為內容
inspection.statement.has.empty.body.ignore.empty.for=忽略無主體的 'for' 迴圈
inspection.statement.has.empty.body.ignore.empty.while=忽略無主體的 'while' 迴圈
inspection.statement.without.braces=控制語句主體無大括號
inspection.statement.without.braces.fix.name=將大括號新增到 ''{0}'' 語句
inspection.static.member.accessed.via.instance.reference=通過執行個體參照存取 static 成員 ''{0}''
inspection.static.method.called.as.dynamic.problem=static 方法 '#ref' 不應被動態呼叫
inspection.static.method.called.as.dynamic.problem.magic=static 方法 '#ref' 不應被動態呼叫，但類別具有 '__magic' 方法。
inspection.str.functions.strpos.call.can.be.converted.to.strcontains='strpos()' 呼叫可以轉換為 'str_contains()'
inspection.str.functions.strpos.call.can.be.converted.to.strstartswith='strpos()' 呼叫可以轉換為 'str_starts_with()'
inspection.str.functions.substr.call.can.be.converted.to.strendswith='substr()' 呼叫可以轉換為 'str_ends_with()'
inspection.str.functions.substr.call.can.be.converted.to.strstartswith='substr()' 呼叫可以轉換為 'str_starts_with()'
inspection.strict.type.checking.field.assignment=屬性必須為 ''{0}'' 類型，提供的是 ''{1}''
inspection.strict.type.checking.field.assignment.multi.resolve=指派的類型 ''{0}'' 與屬性的宣告類型不相容
inspection.strict.type.checking.option=為所有檔案啟用
inspection.strict.type.checking.parameter=應為 ''{0}'' 類型的參數，提供的是 ''{1}''
inspection.strict.type.checking.parameter.batch=參數 '#ref' 類型與宣告不相容
inspection.strict.type.checking.return=返回值必須為 ''{0}'' 類型，返回的是 ''{1}''
inspection.strict.type.checking.return.batch=返回值類型與宣告不相容
inspection.super.incompatible.with.interface.declaration.must.be.compatible=''{0}'' 的宣告必須與 ''{1}'' 相容
inspection.switch.with.single.case=只有一個 'case' 的 'switch'
inspection.switch.without.default.case='Switch' 沒有預設分支
inspection.too.many.parameters=參數數量超出指定限值
inspection.too.many.parameters.ignore.constructors=忽略建構函式
inspection.too.many.parameters.max.number.of.parameters=最大參數數量
inspection.traditional.syntax.array.literal.detected=使用了傳統語法陣列字面量
inspection.undefined.callback.class=未定義的類別 ''{0}''
inspection.undefined.callback.dont.report.ambiguity.checkbox=不明確時不報告
inspection.undefined.callback.dont.report.exist.checkbox=忽略來自 '*_exists' 和 'is_callable' 函式的回調
inspection.undefined.callback.field=在類別 ''{1}'' 中未找到屬性 ''{0}''
inspection.undefined.callback.function=未定義的函式 ''{0}''
inspection.undefined.callback.method=在類別 ''{1}'' 中未找到方法 ''{0}''
inspection.undefined.class.ignore.phpdoc=忽略 PHPDoc
inspection.undefined.constant.problem1=未定義的常數 '#ref'
inspection.undefined.constant.problem2=常數 '#ref' 可能未定義
inspection.undefined.field.notify.access.magic.method=通過魔術方法存取屬性的通知
inspection.undefined.field.notify.dynamic.declaration=動態屬性宣告的通知
inspection.undefined.field.notify.dynamic.read=通知對動態屬性的讀取權限
inspection.undefined.field.problem1=通過魔術方法存取的屬性
inspection.undefined.function.problem1=未定義的函式 '#ref'
inspection.undefined.function.problem2=函式 '#ref' 可能未定義
inspection.undefined.member.downgrade=如果類別中存在 __magic 方法則降級嚴重性(&D)
inspection.undefined.member.warnOnMixed=出現混合、物件、stdClass、未定義類型、null 的存取成員時通知
inspection.undefined.phpunit.provider=未定義的 PHPUnit 資料提供程序 ''{0}''
inspection.undefined.variable.option.description.enable.in.file.scope=在全域空間中啟用檢查
inspection.undefined.variable.option.description.ignore.include=在當前檔案外搜尋變數定義
inspection.undefined.variable.option.description.report.can.be.undefined=報告變數可能未定義
inspection.undefined.variable.problem1=未定義的變數 '#ref'
inspection.undefined.variable.problem2=變數 '#ref' 可能未定義
inspection.unnecessary.bool.cast=冗餘轉換為布林值
inspection.unnecessary.fully.qualified.name.option.enable.file.scope=在檔案作用域中啟用
inspection.unnecessary.fully.qualified.name.option.ignore.global.namespace=忽略全域命名空間
inspection.unnecessary.qualifier.already.imported.message=限定符不必要，可以移除
inspection.unnecessary.static.reference=final 類別中有冗餘的 'static'
inspection.unnecessary.string.cast=冗餘轉換為字串
inspection.unpacked.argument.type.mismatch=僅可解包陣列和 Traversable，獲得的是{0}
inspection.unreachable.statement=不可到達的語句
inspection.unreachable.statement.problem=不可到達的語句
inspection.unused.declaration.option.show.unused_from_entries=顯示所有宣告
inspection.unused.declaration.option.show_strictly_unused=僅顯示未使用項
inspection.unused.declaration.option.test.entry_points=假定測試宣告為入口點
inspection.unused.declaration.option.test.suppressGettersAndSetters=禁止 getter/setter
inspection.unused.description.code.suppressed.annotations=已禁止的註解
inspection.unused.local.variable.option.description.file.scope=在全域空間中啟用檢查
inspection.unused.local.variable.option.description.foreach=在 'list()' 中或存在 'foreach' 鍵時忽略 foreach 值
inspection.unused.local.variable.option.description.include=忽略 'include' 之前的變數
inspection.unused.local.variable.option.description.list=忽略 'list()' 中的變數
inspection.unused.local.variable.option.description.null=忽略 'null' 的指派
inspection.unused.local.variable.option.indirect.access=忽略通過 'get_defined_vars()' 存取的變數
inspection.unused.local.variable.problem=未使用的區域變數 ''{0}''。{1}
inspection.unused.local.variable.problem.batch=區域變數 '#ref' 未在任何位置使用
inspection.unused.local.variable.problem.case1=變數的值未在任何位置使用。
inspection.unused.local.variable.problem.case2=變數的值被立即覆蓋。
inspection.unused.local.variable.problem.case3=變數中存儲的參照未在任何位置使用。
inspection.unused.local.variable.problem.case4=變數中存儲的參照被立即覆蓋。
inspection.unused.local.variable.problem.fix.side.effects.found.dialog.message=分配給 ''{0}'' 的表達式可能含有副作用。\\n您可以:\\n- 完全<b>移除</b>變數指派\\n- 將分配的表達式<b>轉換</b>成單獨的語句
inspection.unused.local.variable.problem.fix.side.effects.found.dialog.title=發現副作用
inspection.unused.parameter.option.description.empty.abstract=忽略抽象類別方法的參數
inspection.unused.parameter.option.description.empty.anonymous=忽略匿名函式的參數
inspection.unused.parameter.option.description.empty.body=忽略帶有空體的方法/函式的參數
inspection.unused.parameter.option.description.empty.override=忽略覆寫方法的參數
inspection.unused.parameter.option.description.parameter.count=不報告通過 'func_num_args()' 存取的參數
inspection.unused.parameter.option.description.property.hook.param.type=當屬性掛鈎參數等於屬性類型時不報告
inspection.unused.parameter.problem=未使用的參數 ''{0}''。{1}
inspection.unused.parameter.problem.case1=參數值未在任何位置使用。
inspection.unused.parameter.problem.case2=參數值被立即覆蓋。
inspection.unused.parameter.problem.case3=參數中存儲的參照未在任何位置使用。
inspection.unused.parameter.problem.case4=參數中存儲的參照被立即覆蓋。
inspection.unused.parameter.problem.case5=參數類型等於屬性類型。
inspection.unused.private.method.option.ignore.clone=忽略方法 '__clone' 用法
inspection.unused.private.method.option.ignore.constructor=忽略方法 '__construct' 用法
inspection.unused.private.method.problem.batch=未使用的 private 方法 '#ref'
inspection.unused.symbol.check.anonymous_classes=匿名
inspection.unused.symbol.check.classes=類別
inspection.unused.symbol.check.constants=常數
inspection.unused.symbol.check.fields=屬性
inspection.unused.symbol.check.functions=函式
inspection.unused.symbol.check.magic_method=魔術方法
inspection.unused.symbol.check.methods=方法
inspection.unused.symbol.export.abstract=abstract
inspection.unused.symbol.export.call=呼叫
inspection.unused.symbol.export.calls=呼叫
inspection.unused.symbol.export.closure=結束
inspection.unused.symbol.export.entry=入口點
inspection.unused.symbol.export.label=標籤
inspection.unused.symbol.export.reachable_element=可到達
inspection.unused.symbol.export.test_method=測試
inspection.unusedd.description.code.patterns.button.label=程式碼模式
inspection.usage.of.silence.operator.problem=使用了沉默運算符
inspection.variable.variable=使用了可變變數
inspection.visibility.modifier.can.be.removed=可以移除可見性修飾符
inspection.void.function.result.used.problem.type=void
inspection.void.never.function.result.used.problem.type=void/never
inspection.wrong.exception.order.fix.move.display.name=將 ''catch'' 子句移至 ''{0}'' 前
inspection.wrong.exception.order.fix.move.family.name=移動 'catch' 子句
inspection.wrong.exception.order.problem.batch=已捕獲異常 '#ref'
inspection.wrong.exception.order.problem.same=已捕獲異常 ''{0}''
inspection.wrong.exception.order.problem.super=已捕獲異常類別 ''{1}'' 的超類別 ''{0}''
inspection.wrong.exception.type.problem.catch=無法捕獲非派生自 'Exception' 或 'Throwable' 基類別的物件
inspection.wrong.exception.type.problem.throw=已拋出物件必須為 'Exception' 或 'Throwable' 的執行個體
inspection.wrong.foreach.argument.type.problem=提供給 ''foreach'' 的實參無效。預期類型: ''array'' 或 ''object''，提供的是 ''{0}''。
inspection.wrong.foreach.argument.type.problem.batch=提供給 'foreach' 的無效實參
inspection.wrong.string.concatenation.operator.option.ignore.magic=忽略通過魔術方法存取的屬性
inspection.wrong.string.concatenation.operator.problem=字串串聯運算符錯誤
inspection.wrong.string.concatenation.operator.problem.batch=字串串聯運算符錯誤
inspection.wrong_param_type=應為 ''{1}'' 類型的參數，提供的是 ''{0}''
install.composer.packages.task.title=安裝 Composer 軟體套件
instanceof.is.always.true={0} 已位於 {1} 的層次結構中
intention.add.constructor.parameters=新增建構函式參數
intention.add.constructor.parameters.fields.chooser.dialog.title=選擇要在建構函式中初始化的屬性
intention.can.not.find.statement.to.surround=找不到要包圍的目標語句。
intention.convert.to.short.syntax=將陣列轉換為短語法
intention.convert.to.short.syntax.list=將列表轉換為短語法
intention.convert.to.traditional.syntax=將陣列轉換為傳統語法
intention.convert.to.traditional.syntax.list=將列表轉換為傳統語法
intention.declare.missing.field=宣告屬性
intention.declare.missing.property=新增 @property
intention.family.inline.value.for.parameter=內聯參數值
intention.family.name.add=新增 ''\${0}''
intention.family.name.add.arrayshape.attribute=新增 '#[ArrayShape]' 特性
intention.family.name.add.arrayshape.to.doc=將 ArrayShape 新增到 PHPDoc
intention.family.name.add.attribute=新增 ''#[{0}]''
intention.family.name.add.attribute.attribute=使用 'Attribute' 註解
intention.family.name.add.attribute.to=將 ''#[{0}]'' 新增到 ''{1}''
intention.family.name.add.attribute.to.overridden.method=將特性新增到覆寫方法
intention.family.name.add.attribute.to.overridden.method.of.abstract.method=將特性新增到抽象方法的覆寫方法
intention.family.name.add.attribute.to.overridden.parameter=將特性新增到覆寫參數
intention.family.name.add.break.as.last.statement=將 'break' 作為最後一條語句新增
intention.family.name.add.default.match.arm=新增 'default' 'match' arm
intention.family.name.add.doc.tag.with.throws.tags=使用 @throws 標記新增 PHPDoc 註釋
intention.family.name.add.getter=新增 getter
intention.family.name.add.getter.setter=新增 getter 和 setter
intention.family.name.add.missing.array.key=新增缺失的陣列鍵 ''{0}''
intention.family.name.add.missing.parameters=新增缺少的參數
intention.family.name.add.name.identifiers.to.all.arguments.starting.from.current=從當前位置開始將名稱關鍵字新增到所有實參
intention.family.name.add.number.separators=新增數字分隔符
intention.family.name.add.readonly.modifier=新增 'readonly' 修飾符
intention.family.name.add.remaining.enum.cases=新增剩餘 enum case
intention.family.name.add.should.allow.mocking.protected.methods.call=新增 'shouldAllowMockingProtectedMethods' 呼叫
intention.family.name.add.to.containing.enum=將 '' : {0}'' 新增到包含枚舉
intention.family.name.add.to.parameter=將 '\\\\&' 新增到參數
intention.family.name.add.trait.to.use.list=將特徵新增到 use 列表
intention.family.name.add.true.argument.to.var.export.call=將 'true' 實參新增到 'var_export' 呼叫
intention.family.name.add.variable.name=新增變數名稱
intention.family.name.append=追加 ''{0}''
intention.family.name.append.absolute.trait=追加 ''{0}::''
intention.family.name.can.be.merged.with.sequential=''if'' 可以與後續 ''{0}'' 合併
intention.family.name.change.to.mixed=將類型更改為 'mixed'
intention.family.name.collapse.if.statement=摺疊 ''{0}'' 語句
intention.family.name.collapse.statement.into.parameter.default.value=將語句摺疊到參數的預設值中
intention.family.name.collapse.whitespaces=摺疊空格
intention.family.name.combine.multiple.isset.calls.into.one=將多個 'isset' 呼叫合併為一個
intention.family.name.convert.heredoc.nowdoc.to.string.literal=將 heredoc/nowdoc 轉換為字串字面量
intention.family.name.convert.heredoc.to.string.literal=將 heredoc 轉換為字串字面量
intention.family.name.convert.nowdoc.to.string.literal=將 nowdoc 轉換為字串字面量
intention.family.name.convert.string.literal.to.heredoc.nowdoc=將字串字面量轉換為 heredoc/nowdoc
intention.family.name.convert.to.promoted.field=轉換為提升的屬性
intention.family.name.convert.to.promoted.field.remove.doc.comment=轉換為提升的屬性並移除屬性 PHPDoc 註釋
intention.family.name.copy.phpdoc.from.parent=從父項複製 PHPDoc
intention.family.name.count.comments.as.content=將註釋計為內容
intention.family.name.delete.covered.element=刪除已覆蓋的元素
intention.family.name.delete.field=刪除屬性
intention.family.name.delete.initializer=刪除初始設定式
intention.family.name.delete.readonly=刪除 'readonly'
intention.family.name.evaluate.cast=取代為 ''{0}''
intention.family.name.extract.attribute.into.separate.list=將特性提取到單獨的列表
intention.family.name.extract.common.parts=提取通用部分
intention.family.name.extract.common.parts.with.removing.branch=提取通用部分，並移除分支
intention.family.name.flip=翻轉 '?:'
intention.family.name.flip.attributes.lists=翻轉特性列表
intention.family.name.force.fqcn.for.references.in.phpdoc=對 PHPDoc 中的參照強制 FQCN
intention.family.name.generate.phpdoc.comment=生成 PHPDoc 註釋
intention.family.name.group.intersection.types=對交叉類型分組
intention.family.name.initialize.properties=初始化屬性
intention.family.name.initialize.property.in.constructor=初始化建構函式中的屬性
intention.family.name.insert.space.after=在 '#' 後面插入一個空格
intention.family.name.insert.unset.before=在前面插入 ''unset(\${0});''
intention.family.name.invert.if.statement=反轉 'if' 語句
intention.family.name.make.class.readonly=將類別設定為 'readonly'
intention.family.name.make.containing.class.enum=將包含類別設為枚舉
intention.family.name.make.data.provider.method.public.static=將資料提供程序方法設定為 'public' 和 'static'
intention.family.name.make.final=設為 'final'
intention.family.name.make.function.return.by.reference=使函式按參照返回
intention.family.name.make.method.void=將方法設為 'void'
intention.family.name.mark.missing.array.key.as.optional=將缺失的陣列鍵 ''{0}'' 標記為可選
intention.family.name.merge.with.adjustment.range=與調整後的範圍合併
intention.family.name.merge.with.assignment=與指派合併
intention.family.name.merge.with.duplicated.catch.statement=與重複的 'catch' 語句合併
intention.family.name.merge.with.duplicated.match.arm=與重複的 'match' arm 合併
intention.family.name.merge.with.following.attribute.list=將特性列表與以下內容合併
intention.family.name.merge.with.sequential=與後續 ''{0}'' 合併
intention.family.name.move.attribute.to.start.element=將特性移至元素開頭
intention.family.name.move.from.to.composer.json.section=將 ''{0}'' 從 ''{1}'' 移至 ''{2}'' composer.json 部分
intention.family.name.move.trait.use.rule.to.resolved.class.use.list=將特徵 'use' 規則移至解析的類別 'use' 列表
intention.family.name.navigate.to.cause=導覽到原因
intention.family.name.navigate.to.duplicate.method.name=導覽到重複的方法
intention.family.name.navigate.to.possibly.inaccessible.methods=導覽到可能無法存取的方法
intention.family.name.navigate.to.rewrite.expression=導覽到覆寫表達式
intention.family.name.remove=移除 {0}
intention.family.name.remove.argument.name=移除實參名稱
intention.family.name.remove.attribute=移除 ''#[{0}]''
intention.family.name.remove.backed.type.from.containing.enum=從包含枚舉中移除備用類型
intention.family.name.remove.duplicate.operand=移除重複動作數
intention.family.name.remove.empty.index.operator=移除 '[]' 運算符
intention.family.name.remove.leading=移除前導 ''
intention.family.name.remove.parenthesis=移除圓括號
intention.family.name.remove.readonly.modifier=移除 'readonly' 修飾符
intention.family.name.remove.redundant.arguments=移除冗餘{0, choice, 0#實參|1#實參}
intention.family.name.remove.unused.postfix.operation=移除未使用的後綴運算
intention.family.name.remove.unused.property=移除未使用的屬性
intention.family.name.rename.parameter.to.match.super=重新命名參數以符合父級
intention.family.name.replace.array.traversable.with.iterable=將 'array|Traversable '取代為'iterable'
intention.family.name.replace.elseif.with.else=將 'elseif' 取代為 'else'
intention.family.name.replace.if.with.match.expression=將 'if' 取代為 'match' 表達式
intention.family.name.replace.if.with.version=將 'if' 取代為 '??' 版本
intention.family.name.replace.in.array.with.disjunction=將 'in_array()' 取代為 '||'
intention.family.name.replace.instanceof.checks.in.catch.with.specific.catches=將 'catch' 塊中的 'instanceof' 檢查取代為特定的 catch
intention.family.name.replace.match.with.switch.statement=將 'match' 取代為 'switch' 語句
intention.family.name.replace.match.with.switch.statement.changing.semantics=將 'match' 取代為 'switch' 語句(可能會改變比較語意)
intention.family.name.replace.match.with.ternary=取代為三元表達式
intention.family.name.replace.readonly.with.public=將 'readonly' 取代為 'public'
intention.family.name.replace.switch.with.if=將 'switch' 取代為 'if'
intention.family.name.replace.switch.with.match.expression=將 'switch' 取代為 'match' 表達式
intention.family.name.replace.ternary.expression.with.true.branch=將三元表達式取代為 ''{0}'' 分支
intention.family.name.replace.true.argument.with.false=將 'true' 實參取代為 'false'
intention.family.name.replace.with=取代為 ''{0}''
intention.family.name.replace.with.argument=取代為實參
intention.family.name.replace.with.array=取代為數組
intention.family.name.replace.with.array.assignment=取代為數組指派
intention.family.name.replace.with.array.merge.expression=取代為 'array_merge' 表達式
intention.family.name.replace.with.check=取代為 '!==' 檢查
intention.family.name.replace.with.class.constant=取代為類別常數
intention.family.name.replace.with.class.name.literal=取代為 '::class'
intention.family.name.replace.with.class.reference.with.base.class=取代為對基類別的類別參照
intention.family.name.replace.with.closure.fromCallable=取代為 'Closure::fromCallable(...)'
intention.family.name.replace.with.comparison=取代為比較
intention.family.name.replace.with.compile.time.result=取代為編譯時結果
intention.family.name.replace.with.concatenation=取代為串聯
intention.family.name.replace.with.const.syntax=取代為 'const' 語法
intention.family.name.replace.with.define.call=取代為 'define()' 呼叫
intention.family.name.replace.with.dirname.call=取代為 'dirname()' 呼叫
intention.family.name.replace.with.dnf=取代為 DNF 類型宣告
intention.family.name.replace.with.get.class.call=取代為 'get_class()' 呼叫
intention.family.name.replace.with.if=取代為 'if'
intention.family.name.replace.with.implicit.octal.notation=取代為隱式八進制表示法
intention.family.name.replace.with.implode.call=取代為 'implode()' 呼叫
intention.family.name.replace.with.in.array.call=取代為 'in_array()' 呼叫
intention.family.name.replace.with.interpolation=取代為 '{$' 插值
intention.family.name.replace.with.list=取代為 'list'
intention.family.name.replace.with.min.max.call=取代為 'min()'/'max()' 呼叫
intention.family.name.replace.with.named.argument=取代為命名實參
intention.family.name.replace.with.operator=取代為 '?->' 運算符
intention.family.name.replace.with.parameter.access=取代為參數存取
intention.family.name.replace.with.public=取代為 'public'
intention.family.name.replace.with.self.access=取代為 'self::' 存取
intention.family.name.replace.with.spl.autoload.register.call=取代為 'spl_autoload_register()' 呼叫
intention.family.name.replace.with.str.function.call=取代為 ''{0}'' 呼叫
intention.family.name.replace.with.str.repeat.call=取代為 'str_repeat()' 呼叫
intention.family.name.replace.with.suggested.call.in.phpunit=取代為 PHPUnit 10 中建議的呼叫
intention.family.name.replace.with.suggested.call.in.phpunit.11=取代為 PHPUnit 11 中建議的呼叫
intention.family.name.replace.with.ternary.expression=取代為三元表達式
intention.family.name.replace.with.traditional.property.declaration=取代為傳統屬性宣告
intention.family.name.replace.with.union.type=取代為聯合體類型
intention.family.name.replace.with.version=取代為 '??' 版本
intention.family.name.replace.with.zero=取代為 ''{0}''
intention.family.name.show.example.date.time.output=顯示範例日期時間輸出
intention.family.name.simplify.expression=簡化表達式
intention.family.name.simplify.ternary.expression=簡化 '?:'
intention.family.name.sort.arguments=對實參排序
intention.family.name.split.into.multiple.catch.statements=拆分為多個 'catch' 語句
intention.family.name.split.into.multiple.enum.cases=拆分為多個枚舉 case
intention.family.name.split.into.separate.case.statements=拆分為獨立的 'case' 語句
intention.family.name.split.into.two.separate.match.arms=將條件提取到單獨的 'match' arm
intention.family.name.unwrap.call=解包呼叫
intention.family.name.unwrap.cast=解包轉換
intention.family.name.unwrap.curly.braces=解包大括號
intention.family.name.unwrap.else=解包 'else'
intention.family.name.unwrap.foreach=解包 'foreach'
intention.family.name.unwrap.function.call=解包函式呼叫
intention.family.name.unwrap.intersection.type=解包交叉類型
intention.family.name.unwrap.spread.operator=解包展開運算符
intention.family.name.unwrap.type=解包類型
intention.flip.binary.expression.family.name=翻轉二元表達式
intention.flip.binary.expression.text1=翻轉 ''{0}''
intention.flip.binary.expression.text2=翻轉 ''{0}'' (可能更改語意)
intention.flip.binary.expression.text3=翻轉 ''{0}'' (更改語意)
intention.generate.phpdoc=生成 PHPDoc
intention.implement.interface=實作接口
intention.import.class=作為別名匯入類別
intention.import.class.alias.already.exists=已匯入具有相同別名的類別
intention.import.class.alias.name=別名:
intention.inline.alias=內聯別名
intention.inline.method.family.name=內聯方法
intention.join.comma.separated.values=將逗號分隔的值合併為一行
intention.line.split=在兩個字串和串聯中拆分字串
intention.merge.condition.with.outer=與外部條件合併
intention.message.replace.in.array.with.disjunction=將 ''in_array()'' 取代為 ''{0}''
intention.name.add.as.function.s.return.type=將 ''{0}'' 作為函式返回值類型新增
intention.name.add.enum.case.with.value=新增具有 ''{0}'' 值的枚舉 case
intention.name.add.method.stubs=新增方法存根
intention.name.add.name.identifier=新增名稱關鍵字 ''{0}''
intention.name.add.to.parameter=將 ''\\\\&'' 新增到參數 ''{0}''
intention.name.add.trait.to.use.list=將特徵 ''{0}'' 新增到 use 列表
intention.name.cast.to=將{0}轉換為{1}
intention.name.change.cast.to=將 {0} 轉換更改為 {1}
intention.name.change.method.to=將方法 ''{0}'' 更改為 {1}
intention.name.change.signature=更改 {0}({1}) 的簽名
intention.name.convert.array.syntax.to.short=將陣列轉換為短語法
intention.name.convert.concatenation.to.scalar.value=將串聯轉換為標量值
intention.name.convert.concatenation.to.string.interpolation=將串聯轉換為字串內插
intention.name.convert.sprintf.call.to.concatenation=將 'sprintf()' 呼叫轉換為串聯
intention.name.convert.sprintf.call.to.scalar.value=將 'sprintf()' 呼叫轉換為標量值
intention.name.convert.sprintf.call.to.string.interpolation=將 'sprintf()' 呼叫轉換為字串內插
intention.name.convert.string.literal.to.heredoc=將字串字面量轉換為 heredoc
intention.name.convert.string.literal.to.nowdoc=將字串字面量轉換為 nowdoc
intention.name.evaluate.cast=對轉換求值
intention.name.extract.if=提取 if ({0})
intention.name.flip=翻轉 {0} 和 {1}
intention.name.inline.value=內聯值 ''{0}''
intention.name.make.abstract=將{0}設為 abstract
intention.name.make.non.final=將 ''{0}'' 設為非 final
intention.name.merge.with=與 ''{0}'' 合併
intention.name.merge.with.match.arm=與 ''{0}'' arm 合併
intention.name.move.trait.use.rule.to.use.list=將特徵 ''use'' 規則移至 ''{0}'' ''use'' 列表
intention.name.prepend.default.case=預置 'default'
intention.name.remove=移除 {0}
intention.name.remove.argument.names.from.all.arguments.up.to.current=從截止到當前位置的所有實參中移除實參名稱
intention.name.remove.brackets=刪除中括號
intention.name.remove.duplicated.type=移除重複類型
intention.name.rename.to=重命名為 ''{0}''
intention.name.replace.brackets.with.types=取代為 'array'
intention.name.replace.coalesce.expression.with=將合併表達式取代為 ''{0}''
intention.name.replace.coalesce.expression.with.operand=將合併表達式取代為動作數
intention.name.replace.null.as.part.union.type.with.nullable.notation=將 '|null' 作為聯合體類型的一部分取代為 '?'
intention.name.replace.nullable.notation.with.null.as.part.union.type=用 '|null' 取代 '?' 作為聯合體類型的一部分
intention.name.replace.with=將 ''{0}'' 取代為 ''{1}''
intention.name.replace.with.min.max.call=取代為 ''{0}'' 呼叫
intention.name.suppress.for.statement=對語句禁止
intention.name.wrap.left.operand.in.parentheses=使用圓括號包裝左動作數
intention.name.wrap.right.operand.in.parentheses=使用圓括號包裝右動作數
intention.namespace.bracing=將命名空間轉換為帶大括號
intention.php.add.object.shape.attribute=新增 '#[ObjectShape]' 特性
intention.php.doc.add.object.shape=將 ObjectShape 新增到 PHPDoc
intention.php.replace.class.with.enum=將類別取代為枚舉
intention.php.replace.class.with.enum.error.message=由於建構函式呼叫，無法將類別取代為枚舉
intention.php.replace.class.with.enum.title=將類別取代為枚舉
intention.replace.class.with.alias=取代為別名
intention.replace.if.with.ternaryExpression=簡化 'if'
intention.replace.quotes=無法取代引號 - 轉義符號無效且\\\\r 不受支援
intention.replace.ternary.expression.with.if=將 '?:' 取代為 if
intention.replace.with.method.call=取代為對現有方法的呼叫
intention.split.comma.separated.values=將逗號分隔的值拆分為多行
intention.statement.to.surround.failed.message=無法使用 ''{0}'' 包圍語句。
intention.swap.call.arguments.family.name=交換呼叫實參
intention.swap.call.arguments.text1=交換 ''{0}'' 和 ''{1}''
intention.variable.add.phpdoc.comment.family.name=新增 PHPDoc 註釋
interface=接口
interface.cannot.extend.previously.extended.interface=接口無法擴展先前擴展的接口
interface.method.can.t.have.body=接口方法不能有主體
interface.name=接口名稱
interfaces.may.not.include.member.variables=接口可能不包括成員變數
interpreter=解釋器
intersection.types.and.the.nullable.type.notation.cannot.be.mixed=交叉類型和可 null 類型表示法不能混用
introduce.named.constant.for.value.0=為值 ''{0}'' 引入命名常數
introduce.variable.fix=引入變數
invalid.class.name=無效類別名
invalid.condition.to.body.separator.should.be.used=條件與主體之間的分隔符無效: 應改用 '=>'
invalid.octal.literal.won.t.be.reported.by.php.but.will.work.incorrectly=無效的八進制字面量: 不會由 PHP 報告，但無法正常工作
invalid.syntax.for.multiple.case.expressions=多個 'case' 表達式的語法無效
is.duplicated.by.0=類型被 ''{0}'' 重複
iso.8601.date=ISO 8601 日期({0})
iso.8601.numeric.representation.of.the.day.of.the.week=ISO 8601 星期几的數字表示(1 到 7)
iso.8601.week.number.of.year.weeks.starting.on.monday=ISO 8601 一年中的第幾周，周從星期一開始(42)
iso.8601.week.numbering.year=ISO 8601 周編號年份(2022)
isset.only.works.with.variables.and.arrays=isset 僅適用於變數和陣列
it.s.not.possible.to.unpack.array.argument.by.reference=無法通過參照對陣列實參解包
it.s.not.possible.to.unpack.array.key=無法解包陣列鍵
it.s.not.possible.to.unpack.array.value.with.associated.key=無法使用關聯鍵解包陣列值
jump.into.a.finally.block.is.disallowed=不允許跳入 'finally' 塊
key=鍵
label=標籤
label.authentication.data.not.specified=未指定身份驗證資料
label.can.be.configured.as.external.formatter=可組態為 {0}
label.class.fqn=類別 FQN
label.configured.as.external.formatter=已組態為 {0}
label.constant.syntax=常數語法(&C)
label.docker.container=Docker 容器:
label.failed=已失敗
label.global.namespace=<全域命名空間>
label.highlight.target.parameter.attributes.applied.to.promoted.property=僅允許具有提升屬性的 'TARGET_PARAMETER|TARGET_PROPERTY' 特性
label.initialize.in=初始化位置(&I)
label.insert.imports.on.paste=貼上時插入 import:
label.interpreter=解釋器: {0}
label.lt.no.server=<no server>
label.method.name=方法名稱
label.name=名稱:
label.new.name=新名稱:
label.predecessors=前驅
label.server.document.root=$_SERVER['DOCUMENT_ROOT']
label.successors=後繼
label.system.php=系統 PHP
label.visibility=可見性(&V)
label.visibility2=可見性:
label.with.same.name.already.defined.in.current.scope=當前作用域中已定義具有相同名稱的標籤
label1=標籤
lambda=Lambda
languages.frameworks.php.php.runtime=PHP / PHP 執行時
line.separator=行分隔符
link=連結
link.label.builtin.formatter=強制啟用內建格式化程序
link.label.go.to.documentation=轉到文檔
link.label.inspection={0} 檢查
link.label.languages.frameworks.php=PHP
list.is.not.allowed.as.class.reference=不允許將列表作為類別參照
list.item.php.file=PHP 檔案
list.item.update.phpdoc.comment=更新 PHPDoc 註釋
list.of.causes.0=// 可能拋出異常的位置列表:\\n{0}
listing.licenses=正在列出授權
literal.%=字面量 % (%)
live.template.class.member=類別成員
live.template.interface.member=接口成員
live.template.name.comment=註釋
live.template.name.empty.file=空 PHP 檔案
live.template.name.expression=表達式
live.template.name.method.expression=類別成員中的表達式
live.template.name.method.statement=類別成員中的宣告
live.template.name.statement=語句
live.template.name.string.literal=字串字面量
live.template.trait.member=特徵成員
local=本地
lowercase.ante.meridiem.and.post.meridiem.am.pm=小寫上午和下午(am/pm)
machine.type.eg.i386=機器類型。例如，i386
make.0.1=將 ''{0}'' 設為{1}
make.01=設為 ''{0}''
make.call.dynamic.quick.fix.family.name=使呼叫為動態
make.non.nullable=設為不可為 null
member.has.0.access=成員具備 {0} 可見性
member.has.0.access.but.class.has.magic.method.1=成員具備 {0} 可見性，但可以通過 ''{1}'' 魔術方法存取
members.to.report=要報告的成員
merge.into.elseif=合併到 'elseif' 中
merge.nested.conditions=合併嵌套的條件
merge.with.0.branch=與 ''{0}'' 分支合併
meta.declaration.exists=''{1}'' 存在元宣告 ''{0}''
meta.declaration.line.marker.name=存在元宣告
meta.multiple.declaration.exists=''{0}'' 存在多個元宣告
method=方法
method.0.can.t.be.overridden.with.same.trait.1=無法使用相同的特徵 ''{1}'' 覆寫方法 ''{0}''
method.0.clone.cannot.accept.any.arguments=方法 ''{0}::__clone()'' 不能接受任何實參
method.call=方法呼叫
method.is.undefined=方法 '#ref' {0,choice,0#未定義|1#可能未定義}
method.is.undefined.in.class=方法 ''#ref'' 在 {0} 中{1,choice,0#未找到|1#可能未定義}
method.name=方法名稱
method.ref.is.deprecated=方法 '#ref' 已棄用
method.ref.not.found=找不到方法 '#ref'
method.should.either.have.body.or.be.abstract=方法應具有主體或為 abstract
method.should.not.be.finished.with=方法不應以 ';' 結束
method.template.parameter.shadows.class.template.parameter=方法模板參數 ''{0}'' 會隱藏類別模板參數
method.with.same.name.already.defined.in.this.class=此類別中已經定義了具有相同名稱的方法
method1=方法
microseconds=微秒(654321)
microseconds.numeric=微秒，數字(007701、052738、428291)
microseconds.numeric.at.least.6.digits.with.leading.0=微秒，數字，至少 6 位數，帶前導 0 (007701、052738、428291)
milliseconds=毫秒(654)
minutes.numeric=分鐘，數字(1、3、59)
minutes.numeric.at.least.2.digits.with.leading.0=分鐘，數字，至少 2 位數，帶前導 0 (01、03、59)
minutes.with.leading.zeros=帶前導零的分鐘(00 到 59)
modifier=修飾符
months.numeric=月份，數字(1、3、12)
months.numeric.at.least.2.digits.with.leading.0=月份，數字，至少 2 位數，帶前導 0 (01、03、12)
more.actions=更多動作…
move.class.to.separate.file.text.family=將類別移至單獨的檔案
move.from.another.ide.or.code.editor=從另一個 IDE 或程式碼編輯器遷移
move.xdebug.file.to.the.extensions.directory.and.update.configuration.file=將 'xdebug.so' 檔案移動到 PHP 擴展程序目錄並更新組態檔案
multiple.enum.identifiers.should.be.stated.in.different.cases=多個枚舉關鍵字應在不同的 case 中宣告
multiple.modifiers.are.not.allowed=不允許多個修飾符
multiple.namespaces.in.a.file.should.use.same.preferably.braced.syntax=檔案中的多個命名空間應使用相同的(最好帶大括號)語法
multiple.subsequent.underscores.in.a.numeric.literal.are.not.allowed=不允許在數字字面量中使用多個後續下劃線
mute.until.restart=重啟前靜音
name=名稱
named.parameter.overwrites.previous.argument=命名參數覆寫以前的實參
namespace=命名空間
namespace.cannot.start.with.namespace.due.to.conflict.with.ns.relative.names=由於與 ns 相關名稱衝突，命名空間不能以 "namespace" 開頭
namespace.declarations.cannot.be.nested=命名空間宣告不能被嵌套
naming.rules=命名規則
navigate=… 導覽
navigate.to.composer.json=導覽到 composer.json
navigate.to.meta.declaration=導覽到 ''{0}''
navigation.goto.super.method.is.not.available=索引更新期間無法在此處導覽
negate.boolean.expression=布爾表達式求反
nested.type.groups.are.not.allowed=不允許嵌套類型組
never.can.only.be.used.as.return.type='never' 只能用作返回值類型
newUiOnboarding.php.connections.header=正在偵聽 PHP 偵錯連線
newUiOnboarding.php.connections.link=使用 PhpStorm 進行偵錯: 終極指南
newUiOnboarding.php.connections.step.text=點擊以開始/停止偵聽傳入的 PHP 偵錯連線。有關詳情，請參閱{0}
no.candidate.methods.to.implement=沒有要實作的候選方法
no.candidate.methods.to.override=沒有要覆寫的候選方法
no.content.allowed.before.namespace.declaration=命名空間宣告之前不允許任何內容
no.elements.to.generate.phpdoc.for=沒有任何可為其生成 PHPDoc 的元素
no.expression.found=找不到表達式
no.external.formatter=無外部格式化程序
no.fields.to.generate.property.hooks.for=沒有要為其生成屬性掛鈎的欄位
no.in.line.parameter.name.hints.will.be.shown.for.methods.matching.any.of.these.patterns=對於符合其中任一模式的方法，都不會顯示任何嵌入參數名稱提示。
no.interpreter=<無解釋器>
no.item=沒有項
no.members.to.pull.up.found=未找到要向上拉取的成員
no.members.to.push.down.found=未找到要向下推送的成員
no.name=無名稱
no.private.fields.to.generate.both.getters.and.setters.for=沒有要為之同時生成 getter 和 setter 的 private 欄位
no.private.fields.to.generate.getters.for=沒有要為之生成 getter 的 private 欄位
no.private.fields.to.generate.setters.for=沒有要為之生成 setter 的 private 欄位
no.response.from.0.after.1.ms={1} 毫秒後 {0} 未響應
no.type=NO_TYPE
node.is.interface=接口只能擴展一個接口
non.backed.enum.cannot.implement.interface.backedenum=非備用枚舉無法實作接口 'BackedEnum'
non.enum.class.cannot.implement.interface=非枚舉類別無法實作接口 ''{0}''
notication.group.php.debugger=PHP 偵錯器
notification.content.composer.executable.was.automatically.set.to.global.composer=Composer 可執行檔案已被自動設定為全域 'composer'
notification.content.configure.manually=手動組態
notification.content.disable.breakpoint.move.to.resolved.position=停用中斷點移動到已解析的位置
notification.content.disable.paratest=停用 ParaTest
notification.content.formatter.couldn.t.apply.result.external.tool=格式化程序無法套用外部工具的結果
notification.content.language.level.synchronisation.with.composer.was.disabled=已停用與 composer.json 的語言級同步
notification.content.language.level.was.changed.to.based.on.project.usage=語言級別已根據專案中使用的功能設定為 {0}
notification.content.link.copied.to.clipboard=連結 {0} 已複製到剪貼簿
notification.content.phpunit.xml.configuration.file.was.migrated=PHPUnit XML 組態檔案已遷移
notification.content.process.exited.with.non.zero.code=程序以非零程式碼離開
notification.content.should.be.migrated=PHPUnit XML 組態使用了已棄用的架構。是否要使用 "--migrate-configuration" 遷移 XML 組態?
notification.content.tests.have.been.run.without.paratest=測試在沒有 ParaTest 的情況下執行
notification.content.timeout.while.fetching.data.from=從 {0} 提取資料時超時
notification.content.usage.found.in.project=在專案中找到了 {0} 用法
notification.content.vendor.directory.not.found=未找到 'vendor' 目錄
notification.content.xdebug.extension.not.installed=未安裝 Xdebug 擴展程序
notification.group.composer.install=建議使用 Composer 'install' 指令
notification.group.composer.language.level=已停用 Composer 語言級別同步
notification.group.dbgp.proxy=PHP 偵錯器代理
notification.group.debug.listener=PHP 偵錯偵聽器
notification.group.default.stubs=PHP 預設存根路徑不正確
notification.group.php=PHP
notification.group.php.3v4l=PHP 3v4l 整合
notification.group.php.birthday.discount=PHP 誕生 29 周年
notification.group.php.cgi=PHP-CGI 伺服器
notification.group.php.code.style=建議進行 PHP 程式碼樣式檢查
notification.group.php.interpreters=PHP 解釋器問題
notification.group.php.plugin.suggestion=PHP 延伸模組建議
notification.group.php.profiler=PHP 分析器問題
notification.group.phpunit=PHPUnit
notification.group.quality.tools=PHP 外部品質工具
notification.paratest.mute=忽略
notification.title.cannot.read.snapshot=無法讀取快照
notification.title.incorrect.profiler.snapshot.format=分析器快照格式不正確
notification.title.paratest.doesn.t.support.filter.option=ParaTest 不支持 --filter 選項
notification.title.phpunit=PHPUnit
null.cannot.be.marked.as.nullable='null' 不能被標記為可以為 null
number.of.days.in.the.given.month=給定月份中的天數(28 到 31)
numeric.representation.of.a.month.with.leading.zeros=月份的數字表示，帶前導零(01 到 12)
numeric.representation.of.a.month.without.leading.zeros=月份的數字表示，不帶前導零(1 到 12)
numeric.representation.of.the.day.of.the.week=星期几的數字表示(0 到 6)
object.property=物件屬性
older=較舊…
only.final.and.visibility.modifiers.can.be.applied.to.promoted.property=只有 'final' 和可見性修飾符可以應用於提升的屬性
only.intersection.type.can.be.used.for.grouping=只能使用交叉類型進行分組
only.intersection.type.can.be.used.for.grouping1=只能使用交叉類型進行分組
only.simple.expressions.are.allowed=只允許簡單表達式
only.the.last.parameter.can.be.variadic=只有最後一個參數可以是可變形參
open.in.editor=在編輯器中開啟
open.inspection.settings=開啟 {0} 檢查設定
open.tool.settings=開啟 {0} 設定
opens.composer.json.to.change.php.property=開啟 'composer.json' 以更改 'php' 屬性
opens.inspection.0.setting=開啟檢查 ''{0}'' 設定
operating.system.name.eg.freebsd=作業系統名稱。例如，FreeBSD
or.disable.inspection=或
output.phpinfo=輸出 phpinfo():
output.phpinfo.title=輸出 phpinfo() 
override=覆寫
overriding.implementing.methods=覆寫/實作方法
overriding.private.methods=覆寫 private 方法
parameter=參數
parameter.is.deprecated=參數 ''{0}'' 已棄用
parameter.ref.type.is.not.compatible.with.declaration=參數 '#ref' 類型與宣告不相容
parameter.type.is.not.compatible.with.declaration=參數類型 ''{0}'' 與 ''{1}'' 不相容
parameter.type.is.not.convertible.from.null=參數類型不可從 'null' 轉換
parameter1=參數
paratest=ParaTest
paratest.is.not.supported.for.selected.run.profile=ParaTest 與所選執行組態檔案不相容
paratest.runner.description=使用 ParaTest 執行所選組態
pass.by.ref.is.not.effectively.used.inside.body=參照沒有必要，因為實參既不通過參照指派，也不通過參照進一步傳遞
path.0.is.invalid=路徑 ''{0}'' 無效
path.to.php=<php 路徑>
patterns.are.matched.on.fully.qualified.name.parameter.count.and.parameter.names=模式會通過完全限定名稱、參數計數和參數名稱進行符合。
percentage.lines={0}% 行
phar.exclude.from.project.action.title=從專案中排除 phar
phar.failed.to.parse=無法解析
phar.include.into.project.action.title=將 phar 包含到專案中
php=PHP
php.5.6.is.not.supported=不支持下載 PHP 5.6 版本的 Xdebug 擴展程序
php.add.exception=將 ''{0}'' 新增到現有 @throws 標記
php.add.field.declaration.quick.fix.text=新增屬性
php.add.method.declaration.quick.fix.text=新增方法
php.add.tag.base.quick.fix.family.name=新增 {0} 標記
php.annotator.abstract.property.hook.cannot.have.a.body=abstract 屬性掛鈎不能有主體
php.annotator.abstract.property.must.specify.at.least.one.hook=abstract 屬性必須至少指定一個 abstract 掛鈎
php.annotator.cannot.declare.hooks.for.static.property=無法為 static 屬性宣告掛鈎
php.annotator.cannot.redeclare.property.hook.0=無法重新宣告屬性掛鈎 {0}
php.annotator.cannot.specify.default.value.for.virtual.hooked.property=無法為 virtual 掛鈎屬性指定預設值
php.annotator.cannot.use.the.0.modifier.on.a.property.hook=無法在屬性掛鈎上使用 {0} 修飾符
php.annotator.clone.as.callable='clone' 僅在 PHP 8.5 或更高版本中才可用作 callable
php.annotator.clone.expects.two.args='clone' 最多需要 2 個實參
php.annotator.exchange.extends.implements.keyword=將 ''{0} {2}'' 更改為 ''{1} {2}''
php.annotator.exit.or.die.as.callables='exit' 和 'die' 僅在 PHP 8.4 或更高版本中才可用作可調用對象
php.annotator.expecting.class=應為類別參照
php.annotator.expecting.interface=應為接口參照
php.annotator.get.hook.must.not.have.parameter.list='get' 掛鈎不能有參數列表
php.annotator.hooked.properties.cannot.be.readonly=掛鈎屬性不能為 'readonly'
php.annotator.interfaces.may.only.include.hooked.properties=接口只能包含掛鈎屬性
php.annotator.must.not.call.0.in.different.property=無法在另一個屬性(''{1}'')內呼叫 ''{0}'' 屬性的掛鈎
php.annotator.must.not.call.0.in.hook.1=無法從 ''{1}'' 屬性掛鈎呼叫 ''{0}'' 掛鈎
php.annotator.non.abstract.property.hook.must.have.a.body=非 abstract 屬性掛鈎必須有一個主體
php.annotator.only.hooked.properties.may.be.declared.abstract=只有掛鈎屬性才可以宣告為 abstract
php.annotator.parameter.of.set.hook.must.not.be.pass.by.ref='set' 掛鈎參數不能通過參照傳遞
php.annotator.parameter.of.set.hook.must.not.be.variadic='set' 掛鈎參數不能是可變的
php.annotator.parameter.of.set.hook.must.not.have.default.value='set' 掛鈎參數不能具有預設值
php.annotator.property.cannot.be.both.abstract.and.private=屬性不能同時為 abstract 和 private
php.annotator.property.cannot.be.both.final.and.private=屬性不能同時為 final 和 private
php.annotator.property.hook.cannot.be.both.abstract.and.final=屬性掛鈎不能同時為 abstract 和 final
php.annotator.property.hook.cannot.be.both.final.and.private=屬性掛鈎不能同時為 final 和 private
php.annotator.property.in.interface.cannot.be.explicitly.abstract=接口屬性不能為顯式 abstract。所有接口成員都是隱式 abstract
php.annotator.property.in.interface.cannot.be.final=接口中的屬性不能為 final
php.annotator.property.with.asymmetric.visibility.must.have.type=具有不對稱可見性的屬性必須指定類型
php.annotator.read.only.virtual.property.must.not.specify.asymmetric.visibility=無法為唯讀 virtual 屬性指定非對稱可見性
php.annotator.return.type.make.nullable.fix=使返回值類型可為 null
php.annotator.return.type.non.nullable.null.returned=無法返回 'null': 返回值類型不可為 null
php.annotator.set.access.level.must.be.omitted=''{0}::\${1}'' 的 ''set'' 存取級別必須省略(與類別 ''{2}'' 中一樣)
php.annotator.set.hook.must.accept.exactly.one.parameter='set' 掛鈎必須只接受一個參數
php.annotator.set.hook.type.parameter.must.compatible.property.type=參數類型必須與屬性類型相容
php.annotator.static.property.may.not.have.asymmetric.visibility=static 屬性不能具有不對稱可見性
php.annotator.strict.types.block.mode='strict_types' 宣告不能使用塊模式
php.annotator.strict.types.first.statement='strict_types' 宣告必須是腳本中的第一條語句
php.annotator.typed.class.constant.callable.is.illegal=類別常數不能具有 'callable' 類型
php.annotator.typed.parameter.type.mismatch.fix.change=將參數類型更改為 ''{0}''
php.annotator.typed.parameter.type.mismatch.fix.family=更改參數類型以符合預設值的類型
php.annotator.typed.parameter.type.mismatch.fix.nullable=使參數類型可為 null
php.annotator.typed.property.callable.is.illegal={0, choice, 0#屬性|1#類別常數}不能具有類型 'callable'
php.annotator.typed.property.illegal.value=類型 ''{1}'' 的{0, choice, 0#屬性|1#類別常數}可能沒有預設值
php.annotator.typed.property.type.mismatch=預設值只能是 ''{0}'' 類型
php.annotator.typed.property.type.mismatch.fix.change=將{0, choice, 0#屬性|1#類別常數}類型更改為 ''{1}''
php.annotator.typed.property.type.mismatch.fix.family=更改{0, choice, 0#屬性|1#類別常數}類型以符合預設值的類型
php.annotator.typed.property.type.mismatch.fix.nullable=使{0, choice, 0#屬性|1#類別常數}類型可為 null
php.annotator.visibility.of.property.must.not.be.weaker.than.set.visibility=屬性可見性不能比 'set' 可見性弱
php.annotator.void.function.must.not.return.value=void 函式不得返回值
php.annotator.with.properties.type=實參 '$withProperties' 必須是 'array' 類型
php.annotator.write.only.virtual.property.must.not.specify.asymmetric.visibility=無法為只寫 virtual 屬性指定不對稱可見性
php.append.doc.static.fix.family.name=在函式參照前追加 '::'
php.birthday.button.buy=購買 PhpStorm
php.birthday.button.save=立即儲存
php.birthday.notification.1.content=為了慶祝 PHP 29 周年，新用戶可以享受特殊優惠。有效期至 2024 年 6 月 8 日。
php.birthday.notification.1.title=PhpStorm 可享受 29% 優惠
php.birthday.notification.2.content=PHP 29 周年慶，PhpStorm 優惠同步進行! 有效期至 2024 年 6 月 8 日。
php.birthday.notification.2.title=購買 PhpStorm 可節省 29%
php.cgi.not.found=請確保<a href="">組態的 PHP 解釋器</a>作為 CGI 程序建置(指定了 --enable-fastcgi)
php.cgi.not.found.title=找不到 {0}
php.change.cast.operation.quick.fix.family.name=將轉換更改為{0}
php.change.function.signature.from.usage.quick.fix.family.name=從用法改變函式簽名
php.change.function.signature.manually.quick.fix.family.name=手動更改簽名
php.change.method.modifiers.quick.fix.family.name=更改修飾符
php.change.method.modifiers.quick.fix.text=移除修飾符
php.change.signature.conflict.with.local.var=參數 ''{0}'' 與函式 ''{1}'' 內的區域變數衝突
php.change.signature.conflict.with.local.var.method=參數 ''{0}'' 與來自 ''{2}'' 的方法 ''{1}'' 內的區域變數衝突
php.check.validity.reg.exp=在專用對話框中檢查正則表達式的有效性
php.class=類別
php.codestyle.per.2.title=PER-CS 2.0.0
php.commit.checkin.configure.external.formatter=組態
php.commit.checkin.could.not.run.external.formatter=無法執行外部格式化程序
php.commit.checkin.progress.text.reformatting.code.with.external.formatter=正在使用外部格式化程序重新設定程式碼格式…
php.commit.checkin.run.external.formatter=執行外部格式化程序
php.configure.extensions.quick.fix.family.name=組態擴展存根
php.console=PHP 主控台
php.control.flow.viewer=PHP 控制流檢視器
php.control.flow.viewer.0=PHP 控制流檢視器: {0}
php.create.data.provider.quick.fix.family.name=建立資料提供程序
php.dead.code.entries=PHP 死碼條目
php.debug.action.include.return.value.breakpoint.step.description=啟用額外的“從函式返回”偵錯步驟
php.debug.action.watches.method.return.value.enable=啟用函式返回值偵錯
php.debug.action.watches.method.return.value.unavailable.reason=從 Xdebug 3.2 起才支援返回值偵錯
php.debug.state.widget=停止/啟動偵錯偵聽
php.debug.validate.got.it=偵錯驗證
php.debug.validate.got.it.descr=您可以使用偵錯驗證對話框驗證設定
php.delete.catch.clause.quick.fix=刪除 'catch' 子句
php.delete.exception.quick.fix=刪除異常
php.element.is.available.starting.with.php.version=''{0}'' 從 PHP 版本 {1} 開始可用
php.element.was.removed.in.php.version=''{0}'' 已在 PHP {1} 版本中被移除
php.embedded.stubs.incorrect.path.warning.message=組態的預設存根路徑 ''{0}'' 不存在，改為使用嵌入式存根。
php.embedded.stubs.incorrect.path.warning.title=預設存根路徑不正確
php.embedded.stubs.notification.provider.clone=在 GitHub 上克隆
php.embedded.stubs.notification.provider.do.not.show.again=不再顯示
php.embedded.stubs.notification.provider.notification=您正在檢視不可變的嵌入式存根。為了能夠編輯這些存根，您需要克隆一個存根專案，然後通過“PHP / PHP 執行時 / 進階設定”提供預設存根路徑。
php.embedded.stubs.notification.provider.provide=提供預設存根路徑
php.empty.project.generator.description=為 PHP 建立空專案
php.empty.project.generator.name=PHP 空專案
php.enable.extension.quick.fix.family.name=啟用擴展存根
php.enable.extension.quick.fix.text=啟用 ''{0}'' 擴展存根
php.enum=枚舉
php.exception.is.never.thrown=函式中從未拋出異常 ''{0}''
php.executable.macro.description=專案設定中組態的 Php 可執行檔案
php.external.formatter=PHP 外部格式化程序
php.external.formatter.title=外部格式化程序
php.extract.class=PHP 提取類別
php.find.clause.throws=可能拋出: {0}
php.flip.arguments.quick.fix.family.name=翻轉第一和第二個實參
php.flip.variable.and.type.quick.fix.family.name=翻轉變數和類型
php.framework.enable.plugin=啟用延伸模組
php.framework.install.plugin=安裝延伸模組
php.framework.laravel.plugin=Laravel Idea
php.framework.settings.page=設定
php.framework.symfony.plugin=Symfony
php.generation.code.style.title=程式碼生成
php.include.path.action.add.text=新增 Include 路徑
php.include.path.action.exclude.description=在此路徑下新增排除項以防止被編入索引
php.include.path.action.exclude.text=排除此路徑下的內容
php.include.path.excluded.file.description=從索引中排除
php.include.path.library.file.description=包括在索引中
php.info.parse.exception=無法解析 php 資訊: {0} 是空的
php.information.dialog.title=PHP 資訊
php.inline.variable.quick.fix.family.name=內聯變數
php.inspection.redundant.final.modifier='final' 修飾符冗餘，具有 private 'set' 可見性的屬性為隱式 final
php.intention.category=PHP
php.interface=接口
php.interpreter.base.configuration.fix.interpreter={0}。要修復，請<a href=''{1}''>更改</a>專案解釋器或<a href=''{2}''>檢查</a>設定。
php.interpreter.base.configuration.interpreter.is.invalid=無法執行 {0}，因為{1}組態的解釋器無效。
php.interpreter.base.configuration.is.not.provided.or.empty={1} 的 {0} 路徑未組態。您可以在“PHP|{0}”下進行修復
php.interpreter.base.configuration.working.directory=無法檢測工作目錄，請在執行組態中進行組態。
php.interpreter.configurable.description.laravel.herd=Herd
php.interpreter.configurable.description.main.laravel.herd=主要 Herd
php.interpreter.custom.ini.label=組態檔案:
php.interpreter.info.failed.to.parse.validation.script=無法解析驗證腳本輸出
php.interpreter.is.remote.message=請<a href="">選擇本地 PHP 解釋器</a>以使用內建 Web 伺服器
php.interpreter.is.remote.title=已組態遠端 PHP 解釋器
php.interpreter.label.label=標籤
php.interpreter.not.configured=請<a href="">組態 PHP 解釋器</a>以使用內建 Web 伺服器
php.interpreter.not.configured.title=未組態 PHP 解釋器
php.interpreters.configurable.group.name.laravel.herd.interpreters=Laravel Herd 解釋器
php.language.level.widget=PHP 語言級別
php.llm.smart.chat.searching.for.bundles=正在搜尋捆綁包…
php.llm.smart.chat.searching.for.controller=正在搜尋控制器…
php.llm.smart.chat.searching.for.entity=正在搜尋實體…
php.llm.smart.chat.searching.for.events=正在搜尋事件…
php.llm.smart.chat.searching.for.middlewares=正在搜尋中間件…
php.llm.smart.chat.searching.for.model=正在搜尋模型…
php.make.class.abstract.quick.fix.family.name=將類別設為 abstract
php.make.class.non.final.quick.fix.family.name=將類別設為非 final
php.make.field.non.final.quick.fix.family.name=將欄位設為非 final
php.make.method.non.abstract.quick.fix.family.name=將方法設為非 abstract
php.make.method.non.final.quick.fix.family.name=將方法設為非 final
php.make.method.non.static.quick.fix.family.name=將方法設為非 static
php.make.property.hook.non.final.quick.fix.family.name=將屬性掛鈎設為非 final
php.method.name.empty=未指定測試方法
php.method.not.found=在類別 ''{1}'' 中未找到方法 ''{0}''
php.non.strict.object.equality.quick.fix.text=取代為身份比較
php.not.test.method=類別 ''{1}'' 中的方法 ''{0}'' 不是測試方法
php.path.was.updated={0} 自訂
php.path.was.updated.text=專案預設解釋器已被新增到 {0}
php.prefdefined.codestyle.psr12.chosen.message=您可以啟用其他 PSR-12 檢查，這些檢查當前已停用。
php.prefdefined.codestyle.psr12.chosen.title=PSR-12 程式碼樣式
php.prefdefined.codestyle.psr12.enabled.message=PSR-12 檢查已啟用。
php.project.configurable.composer.configs.tab.name=Composer 檔案
php.project.configurable.composer.duplicate.configurations=已經存在具有相同 composer.json 的組態
php.project.configurable.composer.main=主
php.property.hooks.search.setter.getter.usages=正在搜尋 getter 和 setter 用法…
php.quick.documentation.namespace.classes=命名空間類別:
php.quick.fix.add.property.hooks=新增屬性掛鈎
php.quick.fix.change.append.field.declared.type=將參數類型更改為 {0}
php.quick.fix.leave.one.hook.parameter.family.name=只保留一個參數
php.quick.fix.remove.default.value=移除預設值
php.quick.fix.remove.parameter.list=移除參數列表
php.remote.debug.name=PHP 遠端偵錯
php.remote.interpreter.plugin.is.not.installed=PHP Remote Interpreter 延伸模組未安裝
php.remove.all.unused.parameters.quick.fix.text=移除所有未使用的參數
php.remove.doc.tag.quick.fix.family.name=移除 {0}
php.remove.exception.from.throws=從 @throws 標記中移除 ''{0}''
php.remove.parameters.quick.fix.text=移除未使用的參數
php.remove.pass.by.ref.from.parameter.quick.fix.family.name=從參數中移除 '&'
php.remove.ref.from.assignment.quick.fix.family.name=將 '=\\\\&' 取代為 '='
php.remove.ref.from.function.declaration.quick.fix.family.name=從函式宣告中移除 '&'
php.remove.statement.fix.family.name=移除
php.remove.throws.tag=從 @throws 標記移除
php.remove.unused.local.variable.without.successor.quick.fix.family.name=移除變數 ''{0}''
php.rename.wrong.reference.quick.fix.family.name=重新命名參照
php.replace.argument.with.cast.quick.fix.family.name=將實參轉換為{0}
php.replace.try.from.with.null.quick.fix.family.name=將 'tryFrom()' 呼叫取代為 'null'
php.replace.with=取代為 ''{0}''
php.replace.with.float.cast.quick.fix.family.name=取代為 '(float)' 轉換
php.replace.with.interface.quick.fix.family.name=取代為 {0}
php.replace.with.local.variable.quick.fix.family.name=將屬性取代為區域變數
php.replace.with.null.quick.fix.family.name=取代為 'null'
php.run.check.reg.exp=執行檢查 RegExp 意圖 {0}
php.run.http.border.title.configuration=組態
php.run.label.https=HTTPS:
php.run.label.interpreter=解釋器:
php.run.label.query.string=查詢字串:
php.run.label.request.body=請求正文:
php.run.label.request.method=請求方法:
php.run.label.send.request.body.as=將請求正文發送為:
php.run.label.server=伺服器:
php.run.label.url=URL:
php.run.radio.button.key.value=鍵值
php.run.radio.button.text=文本
php.structure.view.dumb.mode.resolving=正在解決…
php.surround.with.if=if
php.surround.with.try.catch.quick.fix=使用 'try-catch' 包圍
php.tag.is.deprecated={0} 已棄用，將在 PHPUnit 9 中移除
php.terminal.artisan.command.description=Laravel Artisan
php.terminal.composer.command.description=PHP 的相依項管理器
php.terminal.file.path.argument.description=用於執行分析的原始碼路徑
php.terminal.php.command.description=執行 PHP 解釋器
php.terminal.phpstan.command.description=PHPStan
php.terminal.psalm.command.description=Psalm
php.terminal.sail.command.description=Laravel Sail
php.terminal.symfony.command.description=Symfony 主控台
php.terminal.word.press.command.description=通過命令行管理 WordPress
php.terminal.word.press.info.option=列印有關 WP-CLI 環境的各種詳細資訊
php.test.framework.by.sdk.dialog.label=解釋器(&I):
php.test.framework.by.sdk.new.settings.dialog.title=通過遠端解釋器{0}
php.test.framework.by.sdk.settings.already.exist=所選解釋器的 {0} 設定已存在
php.test.framework.by.sdk.settings.remote.path.title=選擇伺服器上的路徑
php.test.framework.by.sdk.settings.select.server=選擇遠端解釋器以組態遠端{0}
php.test.framework.configuration.can.not.update=無法更新 {0} 版本
php.test.framework.configuration.ui.library={0} 庫
php.test.framework.configuration.ui.not.installed=未安裝
php.test.framework.configuration.ui.path.to.exe={0} 可執行檔案路徑:
php.test.framework.configuration.ui.select.interpreter=請選擇 PHP 解釋器以載入 {0} 版本
php.test.framework.configuration.ui.select.local.interpreter=請選擇本地 PHP 解釋器以載入 {0} 版本
php.test.framework.configuration.ui.test.runner=測試執行程序
php.test.framework.configuration.ui.use.configuration.file=預設組態檔案:
php.test.framework.configuration.ui.version={0} 版本: {1}
php.test.framework.configuration.updated.version=已成功更新 {0} 版本
php.test.framework.default.interpreter.is.not.local=無法檢測到 {0} 版本。預設 PHP 解釋器不是本地解釋器
php.test.framework.download.hyperlink={0} 版本: <a href={1}>{1}</a>
php.test.framework.field.test.runner.options=測試執行程序選項(&O):
php.test.framework.interpreter.conflict=發現應用程式級 {0} 組態衝突。為解決該問題，建立了以下組態的專案級副本:
php.test.framework.interpreter.conflict.title={0} 組態衝突
php.test.framework.no.configuration.types.are.available=沒有可用的其他組態類型
php.test.framework.project.level=(當前專案)
php.test.framework.run.configuration.ui.alternative.configuration.file=使用替代組態檔案(&U):
php.test.framework.run.configuration.ui.alternative.custom.file=使用替代 {0}(&U)
php.test.framework.run.configuration.ui.configuration.radio.button=在組態檔案中定義(&C)
php.test.framework.run.configuration.ui.custom.file.radio.button=在 {0} 中定義
php.test.framework.run.configuration.ui.directory.radio.button=目錄 (&D)
php.test.framework.run.configuration.ui.directory.text.field=目錄:
php.test.framework.run.configuration.ui.file.radio.button=檔案(&F)
php.test.framework.run.configuration.ui.file.text.field=檔案:
php.test.framework.run.configuration.ui.scenario.radio.button=方法(&M)
php.test.framework.run.configuration.ui.scenario.text.field=方法:
php.test.framework.run.configuration.ui.scope=測試作用域:
php.test.framework.run.configuration.ui.type.combo.box=類型:
php.test.framework.run.configuration.ui.type.radio.button=類型(&T)
php.test.framework.run.confuguration.ui.dialog.caption.test.runner.options=測試執行程序選項
php.test.framework.select.type.of.settings.popup.title=選擇組態類型
php.test.framework.settings.is.not.provided.or.empty={1} 的 {0} 路徑未組態。按“修復”以編輯您的 {0} 組態。
php.test.framework.undefined.interpreter=未定義
php.test.framework.untrusted.reload=在安全模式下禁止重新整理測試框架的版本
php.test.framework.validation.run.configuration.file.working.directory=檔案應該是工作目錄的子項: ''{0}''
php.test.framework.validation.run.configuration.method=在 ''{1}'' 中找不到 ''{0}''
php.test.framework.validation.run.configuration.no.type=如果未選擇類型則無法執行測試。
php.test.framework.validation.run.configuration.unsupported.type=無法通過 ''{0}'' 指令執行測試。
php.test.framework.validation.run.configuration.working.directory=目錄應該是工作目錄的子目錄: ''{0}''
php.test.framework.version.configuration.ui.can.not.parse.version=無法解析版本指令輸出。\\n{0}
php.test.framework.version.detector.empty.output=''{0}'' 指令輸出為空。
php.test.framework.version.getting.version.title=正在獲取 {0} 版本…
php.test.framework.version.path.to.exe.is.invalid={0} 可執行檔案的路徑為空或無效。
php.test.frameworks.form.application=\\ (應用程式)
php.testframework.local.interpreter=本地解釋器
php.testframework.local.interpreter.version=本地 PHP {0}
php.testframework.remote.interpreter=遠端 {0}
php.title.docker.compose.settings=Docker Compose 設定
php.trait=特徵
php.turn.off.path.modification=關閉 {0} 自訂
php.uml.provider.presentable.name=PHP 類別圖
php.unit.checkbox.use.alternative.patterns.base.path=使用替代模式基路徑:
php.unit.create.target.class.quick.fix.family.name=建立缺少的目標類別
php.unit.create.target.method.quick.fix.family.name=建立缺少的目標方法
php.unit.label.test.file.template=測試檔案模板(&T):
php.unit.local.run.description=PHPUnit
php.unit.local.run.display.name=PHPUnit
php.unit.optional=可選
php.unit.radio.button.composite=複合
php.unit.test.runner.options=測試執行程序選項
php.web.application.name=PHP Web 應用程式
php.web.server.validation.action.text=Web 伺服器偵錯驗證
php.web.server.validation.additional.configuration.files=<b>已解析的其他 .ini 檔案:</b> {0}
php.web.server.validation.chose.path.to.script=選擇驗證腳本的路徑
php.web.server.validation.chose.path.to.script.description=選擇本地目錄以建立驗證腳本
php.web.server.validation.client.host.is.reachable=<b>偵錯用戶端主機</b>: 可以存取
php.web.server.validation.client.host.is.unreachable=<b>偵錯用戶端主機</b>: 無法存取
php.web.server.validation.client.host.is.unreachable.descr=請確保已正確組態 <i>xdebug.remote_host</i> (適用於 Xdebug 2)、<i>xdebug.client_host</i> (適用於 Xdebug 3)或 zend_debugger。值可以是執行 PhpStorm 的機器的主機名(例如，localhost)或 IP 地址，並且必須可以從伺服器 ping 通。使用 Xdebug 時，<i>xdebug.remote_connect_back</i> (適用於 Xdebug 2)或 <i>xdebug.discover_client_host</i> (適用於 Xdebug 3)可用於故障排除。
php.web.server.validation.client.phpstorm.is.reachable=<b>PhpStorm:</b> 準備接收 Xdebug 連線
php.web.server.validation.client.phpstorm.is.unreachable=<b>PhpStorm:</b> 無法接收 Xdebug 連線
php.web.server.validation.client.phpstorm.is.unreachable.descr=偵聽傳入偵錯連線可能被停用，或者可能在設定中為傳入連線指定了錯誤的連接埠
php.web.server.validation.configuration.files=<b>已載入的 php.ini:</b> {0}
php.web.server.validation.configure.local=指定文檔根下的目錄路徑及其對應的 URL
php.web.server.validation.configure.phpinfo=請貼上 <i>phpinfo()</i> 的完整輸出
php.web.server.validation.configure.phpinfo.desc=複製並貼上 HTML 版本、HTML 原始碼或 <i>php -i</i> 輸出
php.web.server.validation.configure.remote=指定目錄路徑並選擇部署伺服器
php.web.server.validation.configure.validation.script=複製下載腳本指令，在正在執行的 Web 伺服器上執行，並檢查 URL 的輸出
php.web.server.validation.deployment.server=部署伺服器(&D):
php.web.server.validation.deployment.server.tooltip=所選伺服器會用於將驗證腳本部署到遠端伺服器
php.web.server.validation.dialog.validate.button=驗證(&V)
php.web.server.validation.docker=<b>在 Docker 容器中</b>: {0}
php.web.server.validation.failed.to.deploy.validation.script=無法將驗證腳本部署到伺服器
php.web.server.validation.failed.to.execute.script=指定的 URL 不可到達，原因是: ''{0}''
php.web.server.validation.failed.to.fetch.script.result=無法提取驗證腳本的結果
php.web.server.validation.failed.to.find.deployment.settings=找不到伺服器的部署設定
php.web.server.validation.failed.to.find.web.path=請組態驗證腳本的 Web 路徑
php.web.server.validation.failed.to.map.deployment.folder=請為驗證目錄組態遠端路徑映射
php.web.server.validation.failed.to.map.deployment.folder.to.web=請為驗證目錄組態 Web 路徑映射
php.web.server.validation.failed.to.unzip=無法從 {0} 提取資料
php.web.server.validation.invalid.path.to.script=驗證目錄的路徑無效
php.web.server.validation.loaded.debugger.extension=<b>偵錯器擴展:</b> {0}
php.web.server.validation.local.path.to.script=放置驗證腳本的目錄(&D):
php.web.server.validation.local.path.to.script.tooltip=所選路徑應可通過 Web 伺服器存取
php.web.server.validation.local.web.server.radio=本地 Web 伺服器或共享目錄(&L)
php.web.server.validation.multi.debugger.extension=Xdebug 和 Zend Debugger 擴展均已載入
php.web.server.validation.multi.debugger.extension.description=只有一個偵錯器擴展可在 php.ini 中載入。
php.web.server.validation.no.configuration.files=找不到 php.ini 檔案
php.web.server.validation.no.debugger.extension=未載入偵錯擴展
php.web.server.validation.os=<b>用戶端主機作業系統</b>: {0}
php.web.server.validation.os.server=<b>伺服器主機作業系統</b>: {0}
php.web.server.validation.process.title=驗證 Web 伺服器
php.web.server.validation.reference.to.documentation=請參閱<a href="{0}">{0}</a>獲取更多資訊。
php.web.server.validation.remote.web.server.radio=遠端 Web 伺服器(&R)
php.web.server.validation.script.local.result.path.mapping.check=請檢查是否為 <b>''{0}''</b> 目錄正確組態了驗證腳本的 Web 路徑
php.web.server.validation.script.result.is.empty=驗證腳本的結果為空
php.web.server.validation.script.result.path.mapping.check=請檢查是否在部署設定中為 <b>''{0}''</b> 目錄正確組態了遠端和 Web 路徑映射
php.web.server.validation.script.result.wrong.format=驗證腳本的結果具有意外格式
php.web.server.validation.server.name=<b>伺服器名稱:</b> {0}
php.web.server.validation.server.name.is.empty=伺服器名稱為空
php.web.server.validation.server.name.is.empty.description=PhpStorm 內部需要使用伺服器名稱進行識別。<br> 在 Web 伺服器組態檔案中組態伺服器名稱。
php.web.server.validation.synonym=驗證偵錯
php.web.server.validation.synonym2=驗證 Xdebug
php.web.server.validation.title=驗證 Web 伺服器上的偵錯器組態
php.web.server.validation.uploading.validation.script=正在將驗證腳本上傳至 {0}
php.web.server.validation.url.to.validation.script=指向包含腳本的目錄的 URL(&U):
php.web.server.validation.url.to.validation.script.tooltip=所選 Web 路徑將用於執行驗證腳本
php.web.server.validation.xdebug.debugger.host=<b>遠端主機:</b> {0}
php.web.server.validation.xdebug.debugger.host.description=正在執行偵錯器<b>用戶端</b>的主機。
php.web.server.validation.xdebug.debugger.host.remote.addr=<br/><br/>在 php.ini 檔案中，將 <b>''{0}''</b> 設為 <i>''{1}''</i> 或自 Web 伺服器可見的本地機器 IP 地址。
php.web.server.validation.xdebug.debugger.localhost=儘管伺服器主機可能不在本地，但遠端主機仍組態為 ''{0}''
php.web.server.validation.xdebug.mode.is.not.supported=不支持遠端模式 ''{0}''
php.web.server.validation.xdebug.option.is.enabled=<b>{0}:</b> 選項已啟用
php.web.server.validation.xdebug.option.is.ignored.description=<b>{0}:</b> 選項將被忽略。
php.web.server.validation.xdebug.option.is.not.enabled.description=<b>{0}:</b> 選項未啟用
php.web.server.validation.xdebug.port=<b>遠端連接埠:</b> {0}
php.web.server.validation.xdebug.port.require.sudo=<b>遠端連接埠:</b> {0}，需要根權限才能使用
php.web.server.validation.xdebug.port.require.sudo.description=要在 Linux 和 Mac 上使用小於 1024 的連接埠，必須具有根權限。
php.web.server.validation.xdebug.protocol.is.not.supported=不支持偵錯協議 ''{0}''
php.web.server.validation.xdebug.remote.autostart.description=偵錯會話將嘗試為每個請求啟動。
php.web.server.validation.xdebug.remote.is.not.enable=遠端偵錯未啟用
php.web.server.validation.xdebug.remote.is.not.enable.description=將 <b>''{0}''</b> 行新增到 php.ini 檔案。
php.web.server.validation.xdebug.remote.log=<b>{0}:</b> {1}
php.web.server.validation.xdebug.remote.mode.jit=<b>遠端模式:</b> 'jit'
php.web.server.validation.xdebug.remote.mode.jit.description=偵錯會話將僅在出現錯誤後初始化。
php.web.server.validation.xdebug.remote.mode.req=<b>遠端模式:</b> 'req'
php.web.server.validation.xdebug.remote.mode.req.description=偵錯會話將在腳本啟動時初始化。
php.web.server.validation.xdebug.wrong.port=Xdebug 連接埠(''{0}'')與“PHP->偵錯 IDE”設定(''{1}'')不同
php.web.server.validation.xdebug.wrong.port.description=來自 php.ini (<b>{0}</b>)的 Xdebug 連接埠應與在 IDE 內(在 <b>PHP->偵錯</b>下)組態的連接埠相同。
php.web.server.validation.xdebug.wrong.port.format=<b>Xdebug 連接埠無效:</b> ''{0}''
php.web.server.validation.xdebug.zend.extension.load=Xdebug 必須通過 'zend_extension' 而不是 'extension' 載入
php.web.server.validation.xdebug.zend.extension.load.description=在 php.ini 檔案中使用 <b>'zend_extension=path_to_xdebug.so'</b> 行以載入 Xdebug 擴展。
php.web.server.validation.xdebug3.cloud.php.ini.xdebug.disabled.message=<b>Php.ini 雲偵錯:</b> 已停用。
php.web.server.validation.xdebug3.cloud.xdebug.correct.cloud.id.message=<b>IDE 中的雲 ID:</b> 與伺服器上的雲 ID 相同
php.web.server.validation.xdebug3.cloud.xdebug.disabled.message=<b>通過 Xdebug Cloud 連線</b>: 已停用。在 IDE 設定中啟用: <b>PHP->偵錯->XDebug Cloud</b>
php.web.server.validation.xdebug3.cloud.xdebug.doesnt.accept.connections.message=Xdebug 現在不接受外部連線
php.web.server.validation.xdebug3.cloud.xdebug.wrong.cloud.id.description=<b>IDE 中的雲 ID:</b> {0}<br><b>伺服器上的雲 ID:</b> {1}
php.web.server.validation.xdebug3.cloud.xdebug.wrong.cloud.id.message=<b>IDE 中的雲 ID:</b> 與伺服器上的雲 ID 不同
php.web.server.validation.xdebug3.discover.client=該設定預設處於停用狀態。如果啟用，Xdebug 會嘗試自動連線到發出 HTTP 請求的偵錯用戶端。
php.web.server.validation.xdebug3.discover.client.message=<b>發現用戶端主機</b>: Xdebug 將嘗試自動提取用戶端主機。
php.web.server.validation.xdebug3.discover.client.no=<b>發現用戶端主機</b>: 關閉
php.web.server.validation.xdebug3.discover.client.with.discover.header=根據 <b>$_SERVER[''{0}'']</b> 中的值，Xdebug 將嘗試自動連線到用戶端。若失敗，則以空的 <b>''xdebug.client_discovery_header''</b> 回到 <b>''xdebug.discover_client_host''</b>。
php.web.server.validation.xdebug3.option.in.invalid.mode=''{0}'' 選項設定為 ''{1}''，這對於 xdebug3 是無效模式。
php.web.server.validation.xdebug3.option.is.enabled.message=<b>{0}</b>: 選項被設定為 ''{1}''。
php.web.server.validation.xdebug3.remote.mode.emulation.description=偵錯會話將在腳本啟動時初始化，與 xdebug2 的 <b>remote_mode=''{0}''</b> 相同。
php.web.server.validation.xdebug3.remote.mode.emulation.message=<b>遠端模式:</b> xdebug2 的 ''{0}'' 已模擬。 
php.web.server.validation.xdebug3.start.upon.error.description=偵錯會話將嘗試根據相應組態在錯誤時自動啟動。
php.web.server.validation.xdebug3.start.with.request.description=偵錯會話將嘗試根據相應組態自動啟動。
php.web.server.validation.zend.debugger.deny.host=<b>拒絕主機:</b> {0}
php.web.server.validation.zend.debugger.deny.host.description=無法使用拒絕主機從用戶端進行偵錯。
php.web.server.validation.zend.debugger.host=<b>遠端主機:</b> {0}
php.web.server.validation.zend.debugger.localhost=儘管伺服器不在本地，但偵錯會話僅適用於本地主機。
php.web.server.validation.zend.debugger.localhost.description=將正在執行偵錯器<b>用戶端</b>的主機新增至 <b>'zend_debugger.allow_hosts'</b> 選項。
php.web.server.validation.zend.expose.remotely=<b>屬性 ''expose_remotely''</b> 設為 ''{0}''
php.web.server.validation.zend.expose.remotely.allowed.hosts.description=偵錯器會話將嘗試從 <b>'zend_debugger.allow_hosts'</b> 選項為主機啟動。
php.web.server.validation.zend.expose.remotely.always.description=偵錯器會話將嘗試為每個用戶端啟動。
php.web.server.validation.zend.expose.remotely.never.description=偵錯器會話將不會進行初始化，<b>'zend_debugger.allow_hosts'</b> 選項將被忽略。<br>將選項 <b>'zend_debugger.expose_remotely'</b> 設定為 'allowed_hosts' 或 'always' 以啟用 Web 伺服器偵錯。
php.web/server.validation.validation.script=偵錯驗證腳本
php.xdebug.enable.dfa.assist=預測分析程序數據流的未來條件值
php.xdebug.enable.dfa.assist.gray.mode=將預計不可到達的程式碼塊變灰
php.xdebug.move.to.resolve.breakpoint=如果中斷點與源不同，則將中斷點移動到已解析的位置
phpdoc.code.style.throws.analysis.depth.performance.note.message=不建議深入分析多個級別，因為這可能會影響 IDE 性能。要繼續嗎?
phpdoc.code.style.throws.analysis.depth.performance.note.title=性能註釋
phpunit.10.won.t.support.classname.annotations=PHPUnit 10 將不支持 ClassName::<*> 註解
phpunit.can.not.rerun.failed.tests.title=無法執行失敗的 PHPUnit 測試。
phpunit.config.directory.label=目錄:
phpunit.config.empty.pattern=空模式
phpunit.config.label=測試根
phpunit.getting.phpunit.version=正在更新 PhpUnit 版本…
phpunit.label.data.set=資料集:
phpunit.not.tests.was.executed.message=要修復，為 <i>{0}</i> <a href="config">組態</a>自動載入檔案或 PHPUnit phar 路徑。
phpunit.not.tests.was.executed.title=未組態 PHPUnit
platform.reqs.are.missing=缺少平台要求。
plural.types.are.not.allowed.in.real.types=僅在 doc 類型中允許複數類型
popup.content.configuration.remains.unchanged=當前組態與解釋器同步
popup.content.enabled.disabled.extensions=已啟用{0}和已停用{1}擴展
popup.select.target.code.block.closure=箭頭函式體(轉換為閉包)
popup.select.target.code.block.containing.block=包含塊
popup.title.multiple.write.scopes.found=找到多個寫入作用域
popup.title.select.reference.to.remove=選擇要移除的類型
popup.title.select.target.code.block=選擇目標程式碼塊
possible.tool.process.hangup.after.0.sec={0} 秒後可能工具過程掛起。
postfix.template.provider.display.name=PHP
potentially.polymorphic.call.multiple.subclasses=潛在的多態呼叫。該程式碼可能無法動作，具體取決於作為實參傳遞的實際類別執行個體。
potentially.polymorphic.call.single.subclass=潛在的多態呼叫。{0} 的層次結構中沒有成員
primitive.hints.name.are.forbidden.in.php.7=PHP 7 中禁止名為 'int'、'string'、'float'、'bool'、'true'、'false' 和 'null' 的類別
private.constant.cannot.be.final='private' 常數不能為 'final'，因為它對其他類別不可見
private.methods.cannot.be.final=private 方法不能是 final，因為它們從不會被其他類別覆寫
proceed=繼續
profiler.button.refresh=重新整理
profiler.column.invocation.callable=可調用
profiler.column.invocation.count.title=呼叫
profiler.column.memory.title=記憶體(B)
profiler.column.own.memory.title=自身記憶體(B)
profiler.column.own.time.title=自用時間
profiler.column.script=腳本
profiler.column.time.title=時間
profiler.label.time=時間:
profiler.measurement.unit.microsecond=微秒
profiler.measurement.unit.microsecond.short=µs
profiler.measurement.unit.millisecond=毫秒
profiler.measurement.unit.millisecond.short=毫秒
profiler.measurement.unit.second=秒
profiler.measurement.unit.second.short=秒
profiler.view.call.tree.title=呼叫樹
profiler.view.callees.title=被呼叫方
profiler.view.callers.title=呼叫方
profiler.view.execution.statistics.title=執行統計
profiler.xdebug.file.chooser.title=選擇 Xdebug 分析器快照
profiler.xdebug.task.parsing=正在解析 ''{0}''
profiler.xdebug.task.title=分析 Xdebug 分析器快照
progress.text.fetching.result.from=正在從 {0} 提取結果
progress.text.submitting.code.to.3v4l.org=正在將程式碼提交到 3v4l.org
progress.title.executing.3v4l.org=正在 3v4l.org 上執行程式碼
progress.title.initializing.git.repository=正在初始化 Git 儲存庫
project.files=專案檔案
project.is.already.disposed=專案已被處置
promoted.property=提升屬性
property=屬性
property.declaration=屬性宣告
property.is.undefined=屬性 '#ref' {0,choice,0#未定義|1#可能未定義}
property.is.undefined.in.class=屬性 ''#ref'' 在 {0} 中{1,choice,0#未找到|1#可能未定義}
property.or.function=屬性或函式
property.read=@property-read
property.write=@property-write
provide.the.full.path.to.executable=提供可執行檔案的完整路徑。
psr.12.add.missing.parameter.list=PSR-12: 新增缺少的參數列表
psr.12.add.public.visibility=PSR-12: 新增 'public' 可見性
psr.12.convert.to.short.form=PSR-12: 轉換為縮寫
psr.12.extract.namespace=PSR-12: 提取命名空間
psr.12.fix.modifiers.order=PSR-12: 修復修飾符順序
psr.12.replace.var.with.public=PSR-12: 將 'var' 取代為 'public'
psr.12.split.to.several.use.statements=PSR-12: 拆分為多個 'use' 語句
psr.roots.revert=還原
public.and.static='public' 和 'static'
quality.inspection.button.tooltip=該按鈕顯示相應的檢查是否開啟
quality.tool.action.clean.list.text=清除列表
quality.tool.action.remove.file.s.from.list.text=從列表中移除檔案
quality.tool.border.title.ignored.files=已忽略的檔案
quality.tool.button.validate=驗證
quality.tool.can.not.create.temporary.file=PhpStorm 無法建立臨時檔案
quality.tool.can.not.determine.version=無法確定工具版本，得到 ''{0}''
quality.tool.can.not.retrieve.standards=無法檢索可用規則集，請檢查 PHP CS Fixer 工具組態。
quality.tool.checkbox.installed.standard.paths=已安裝的標準路徑:
quality.tool.checkbox.show.sniff.name=顯示 sniff 名稱
quality.tool.checkbox.show.warning.as=將警告顯示為:
quality.tool.coding.stardards.has.been.updated=已安裝的編碼標準列表已更新。
quality.tool.configuration.can.not.find.configuration.by.id=按 ID 找不到 {0} 組態: ''{1}''
quality.tool.configuration.default.interpreter.is.not.found=預設選擇 {0} 組態解釋器，但未指定解釋器
quality.tool.configuration.for.interpreter.is.not.found=找不到解釋器的 {0} 組態: ''{1}''
quality.tool.configuration.interpreter.is.undefined={0} 組態的解釋器未指定或無效
quality.tool.configuration.tool.path.is.empty=所選組態的 {0} 路徑為空
quality.tool.cs.fixer.allow.risky.rules=允許為內建規則集設定有風險的規則
quality.tool.cs.fixer.custom.rules.warning=選擇 'Custom' 類型以選擇您的組態。
quality.tool.cs.fixer.reformat.action=PHP CS Fixer: 修復整個檔案
quality.tool.cs.fixer.ruleset=規則集:
quality.tool.empty.path.phpcs={0} 的路徑為空
quality.tool.file.not.found=找不到檔案。
quality.tool.ignored.files={0} 忽略的檔案
quality.tool.label.check.files.with.extensions=檢查帶副檔名的檔案:
quality.tool.label.coding.standard=編碼標準:
quality.tool.label.configuration=組態:
quality.tool.label.custom.rulesets=自訂規則集:
quality.tool.label.label=標籤
quality.tool.label.tool.path=工具路徑:
quality.tool.label.tool.process.timeout=工具處理超時，[1...60] 秒:
quality.tool.label.validation.label=驗證標籤
quality.tool.laravel.pint=Laravel Pint
quality.tool.laravel.pint.json.path=pint.json 的路徑:
quality.tool.laravel.pint.quick.fix.text=Laravel Pint: 修正整個檔案
quality.tool.laravel.pint.reformat.only.uncommitted.files=僅重新設定未提交檔案的格式
quality.tool.laravel.pint.ruleset=規則集:
quality.tool.laravel.pint.should.be.json.file=選擇 .json 檔案
quality.tool.path.must.not.be.empty=路徑不得為空。
quality.tool.php.cs.fixer.required.phpcs.version=支援的 PHP CS Fixer 版本為 2.8.0 或更高，找到的是 {0}
quality.tool.php.dir.does.not.contain=該目錄不包含{0}
quality.tool.php_cs.custom.rules.validation.not.php_cs=PHP CS Fixer 不支持所選規則集
quality.tool.php_cs.dir.does.not.contain.custom=此目錄不包含任何受支援的檔案: {0}
quality.tool.phpcbf.location=PHPCBF 位置
quality.tool.phpcbf.location.descr=選擇有效的 phpcbf 啟動器
quality.tool.phpcbf.name=PHP Code Beautifier and Fixer
quality.tool.phpcbf.path=phpcbf 路徑:
quality.tool.phpcbf.reformat.action=PHP Code Beautifier and Fixer: 修復整個檔案
quality.tool.phpcbf.settings=PHP Code Beautifier and Fixer 設定
quality.tool.phpcs.can.not.retrieve.standards=無法檢索可用標準，請檢查 PHP_CodeSniffer 工具組態。
quality.tool.phpcs.custom.rules.validation.not.xml=所選規則集不是 XML
quality.tool.phpcs.custom.rules.warning=選擇 'Custom' 編碼標準類型以選擇自訂規則集。
quality.tool.phpcs.installed.paths=已安裝的標準路徑
quality.tool.phpcs.label.path.to.ruleset=規則集路徑:
quality.tool.phpcs.required.phpcs.version=所需的 PHP_CodeSniffer 版本為 1.5.0 或更高，找到的是 {0}
quality.tool.selected.file.is.not.phpcbf=所選檔案不是 phpcbf 可執行檔案
quality.tool.settings.link.inspection={0} 檢查:
quality.tool.stardards.has.been.updated=已安裝的規則集列表已更新。
quality.tools.0.added.to.ignored.files.list={0}已新增到忽略的檔案列表。
quality.tools.custom.coding.standard=自訂編碼標準
quality.tools.label.by.default.project.interpreter=預設為專案解釋器
quality.tools.provider.tooltip=此檔案被排除在外部品質工具分析和格式設定外。您可以從忽略的檔案列表中移除該檔案。
quick.fix.change.field.type.to.match.get.hook.return.type=更改欄位類型以符合 'get' 掛鈎返回類型
quick.fix.change.set.hook.parameter.type.to.match.field.type=將 ''set'' 掛鈎的參數更改為 {0}
quick.fix.delete=刪除 ''{0}''
quick.fix.error=快速修復錯誤
quick.fix.missing.class.constant.type=作為常數類型新增 ''{0}''
quick.fix.promote.property.with.private.set.visibility.modifier=使用 'private(set)' 可見性修飾符提升屬性
quick.fix.replace.clone.with.clone.with=將 'clone' 取代為 'clone with'
quick.fix.replace.getter.setter.with.hooks=將 {0} 取代為 {1}
quick.fix.replace.property.with.private.set.visibility.modifier=將屬性取代為 'private(set)' 可見性修飾符
quickfix.access.static.via.class.reference=取代為 ''{0}''
quickfix.add.parentheses.around.new.call=在 'new' 呼叫周圍新增圓括號
quickfix.add.to.use=新增到閉包 'use' 建構
quickfix.can.not.find.class.reference.name=無法按名稱尋找類別
quickfix.can.not.find.dynamic.method.reference=找不到動態方法參照
quickfix.can.not.find.static.method.reference=找不到 static 方法參照
quickfix.cannot.find.class.reference=找不到要解析的類別參照
quickfix.cannot.find.target.class=無法從參照 ''{0}'' 解析類別
quickfix.case.sensitive.name=更改 {0} 的大小寫以符合其宣告
quickfix.change.field.type.add.inferred.type.error.non.project=無法修改非專案檔案 ''{0}''
quickfix.change.field.type.add.inferred.type.error.read.only=無法修改唯讀檔案 ''{0}''
quickfix.change.field.type.add.inferred.type.family.name=作為屬性的類型新增推斷的類型
quickfix.change.field.type.add.inferred.type.name=作為屬性的類型新增 ''{0}''
quickfix.change.field.type.to.match.super=更改類型以符合父項
quickfix.change.field.type.to.match.super.0=將類型更改為 ''{0}'' 以匹配父項
quickfix.change.field.type.to.match.super.remove=移除類型宣告以符合父項
quickfix.change.type=更改為 ''{0}''
quickfix.change.type.declaration.family=更改類型
quickfix.convert.arrayall.to.loop=將 'array_all()' 呼叫轉換為迴圈
quickfix.convert.arrayany.to.loop=將 'array_any()' 呼叫轉換為迴圈
quickfix.convert.arrayfill.to.loop=將 'array_fill()' 呼叫轉換為迴圈
quickfix.convert.arrayfilter.to.loop=將 'array_filter()' 呼叫轉換為迴圈
quickfix.convert.arrayfind.to.loop=將 'array_find()' 呼叫轉換為迴圈
quickfix.convert.arrayfindkey.to.loop=將 'array_find_key()' 呼叫轉換為迴圈
quickfix.convert.arraymap.to.loop=將 'array_map()' 呼叫轉換為迴圈
quickfix.convert.loop.to.arrayall=將迴圈轉換為 'array_all()' 呼叫
quickfix.convert.loop.to.arrayany=將迴圈轉換為 'array_any()' 呼叫
quickfix.convert.loop.to.arrayfilll=將迴圈轉換為 'array_fill()' 呼叫
quickfix.convert.loop.to.arrayfilter=將迴圈轉換為 'array_filter()' 呼叫
quickfix.convert.loop.to.arrayfind=將迴圈轉換為 'array_find()' 呼叫
quickfix.convert.loop.to.arrayfindkey=將迴圈轉換為 'array_find_key()' 呼叫
quickfix.convert.loop.to.arraymap=將迴圈轉換為 'array_map()' 呼叫
quickfix.convert.to.json.validate=轉換為 'json_validate()'
quickfix.convert.to.new.style.constructor=將建構函式轉換為新樣式
quickfix.create.class=建立類別
quickfix.create.field.from.callback.invalid.element=無法從回調提取屬性名稱
quickfix.create.field.from.callback.name=從回調建立屬性
quickfix.create.field.from.callback.unresolved.class.ref=無法從回調建立屬性。無法解析目標類別參照。
quickfix.create.function.from.callback.family.name=從回調建立函式
quickfix.create.function.from.callback.name=新增函式
quickfix.create.method.from.callback.name=從回調建立方法
quickfix.create.parameter=建立參數
quickfix.delete.return.argument=刪除返回實參
quickfix.disable.inspection.for.global.namespace=為全域命名空間停用檢查
quickfix.failed.to.create.class=無法建立類別 ''{0}''
quickfix.import.base.no.candidates=找不到要匯入的候選項
quickfix.import.class.name=匯入類別
quickfix.import.class.popup.title=要匯入的類別
quickfix.import.constant.name=匯入常數
quickfix.import.constant.popup.title=要匯入的常數
quickfix.import.function.name=匯入函式
quickfix.import.function.popup.title=要匯入的函式
quickfix.is.not.available.in.dump.mode=在索引更新期間，''{0}'' 快速修復不可用
quickfix.make.call.static.name=將呼叫設為 static
quickfix.make.method.static=設為 'static'
quickfix.move.class.to.corresponding.directory=移至目錄 ''{0}''
quickfix.move.class.to.corresponding.directory.error.file.exists=檔案 {0} 已存在
quickfix.move.class.to.corresponding.directory.error.unable.create.directories=無法建立缺少的目錄: ''{0}''
quickfix.move.class.to.corresponding.directory.error.unable.move.file=無法將檔案移至目錄 ''{0}''
quickfix.multiple.target.class.resolve=類別 ''{0}'' 有多個宣告
quickfix.navigate.to.duplicate.array.key=導覽到重複鍵
quickfix.navigate.to.duplicate.case.value=導覽到重複的 case 值
quickfix.navigate.to.duplicate.condition=導覽到重複條件
quickfix.non.strict.object.equality=非嚴格物件相等比較
quickfix.omit.parentheses.around.new.call=省略 'new' 呼叫周圍的圓括號
quickfix.overriding.method.visibility=移除可見性覆寫
quickfix.php.missing.param.type.batch.description=作為屬性類型新增推斷的類型
quickfix.php.missing.param.type.description=作為參數類型新增 ''{0}''
quickfix.phpdoc.update.field.type=將{0, choice, 0#屬性|1#類別常數}類型更改為 ''{1}'' 以匹配 PHPDoc 註釋
quickfix.phpdoc.update.type=更新 PHPDoc 類型
quickfix.phpunit.assert.equals.flip.compared.arguments=翻轉比較實參
quickfix.phpunit.create.target.class.error.filename.exists=存在檔案 {0}
quickfix.phpunit.drop.redundant.optional.parameters=刪除冗餘的可選參數
quickfix.phpunit.replace.current.method.with.alternative=取代為 ''{0}''
quickfix.remove.condition.from.default.arm=從 'default' arm 中移除非 'default' 條件
quickfix.remove.default.arm=移除重複的 'default' match arm
quickfix.remove.duplicate.condition=移除重複條件
quickfix.remove.match.arm=移除 'match' arm
quickfix.remove.override.attribute=移除 '#[Override]'
quickfix.remove.phpdoc=移除冗餘 PHPDoc 註釋
quickfix.remove.phpdoc.param.tag=移除 @param 標記
quickfix.remove.phpdoc.return.tag=移除 @return 標記
quickfix.remove.phpdoc.signature.tags=移除不必要的 @param 和 @return 標記
quickfix.remove.redundant.phpdoc.tags=移除所有冗餘的 PHPDoc 標記
quickfix.remove.type=移除類型 ''{0}''
quickfix.remove.unnecessary.qualifier=移除不必要的限定符
quickfix.remove.unnecessary.qualifier.on.class.name=簡化 FQN
quickfix.remove.unused.condition=移除未使用的條件
quickfix.replace.assignment.operator.with.prefix.expression.family.name=將指派運算符取代為前綴表達式
quickfix.replace.assignment.with.operator.assignment.family.name=將指派取代為運算符指派
quickfix.replace.assignment.with.operator.assignment.name=將 ''='' 取代為 ''{0}=''
quickfix.replace.assignment.with.prefix.expression.family.name=將指派取代為前綴表達式
quickfix.replace.curly.braces.with.brackets=將大括號取代為中括號
quickfix.replace.nested.ternary.expression=將三元表達式取代為 {0} 關聯版本
quickfix.replace.one.operator.with.another=將 ''{0}'' 取代為 ''{1}''
quickfix.set.inheritance.between.classes=使{0} {1} {2}
quickfix.strict.type.checking.change.parameter.type.family=更改參數類型
quickfix.strict.type.checking.change.parameter.type.name=將{0, choice, 1#第 1 個|2#第 2 個|3#第 3 個|4#第 {0,number} 個}參數的類型從 ''{1}'' 更改為 ''{2}''
quickfix.strict.type.checking.change.return.type.family=更改返回值類型
quickfix.strict.type.checking.change.return.type.name=將返回值類型從 ''{0}'' 更改為 ''{1}''
quickfix.strict.type.checking.extend.return.type.family=擴展返回值類型
quickfix.strict.type.checking.extend.return.type.name=將返回值類型從 ''{0}'' 擴展為 ''{1}''
quickfix.undefined.function.add.function=新增函式
radio.button.by.concatenation=通過串聯(&C)
radio.button.by.embeding=通過嵌入(&E)
radio.button.class.constructor=類別建構函式(&S)
radio.button.const=const(&C)
radio.button.copy.from.base.class=從基類別複製(&P)
radio.button.current.method=當前方法(&T)
radio.button.default=預設(&F)
radio.button.default.empty.template=預設/空模板(&E)
radio.button.define=定義(&D)
radio.button.field.declaration=屬性宣告(&D)
radio.button.private=private(&I)
radio.button.protected=protected(&O)
radio.button.public=public(&U)
radio.button.setup=設定(&U)
radio.button.with.inheritdoc.tag=帶有 @inheritDoc 標記(&I)
radio.for.all.properties=適用於所有方法
radio.only.for.properties.without.declared.type=適用於沒有宣告類型的方法
reading.and.writing.creates.files.if.not.exists.fails.otherwise=讀/寫。如果檔案不存在則建立檔案，如果找到檔案則失敗。
reading.and.writing.start.at.the.beginning.of.the.file=讀/寫。從檔案開頭開始。
reading.and.writing.start.at.the.beginning.of.the.file.and.truncate.the.file.to.zero.length.creates.files.if.not.exists=讀/寫。從檔案開頭開始，將其截斷為零長度。如果檔案不存在則建立檔案。
reading.and.writing.start.at.the.the.end.of.the.file.creates.files.if.not.exists=讀/寫。從檔案末尾開始。如果檔案不存在則建立檔案。
reading.and.writing.starts.at.the.beginning.of.the.file.creates.files.if.not.exists=讀/寫。從檔案開頭開始。如果檔案不存在則建立檔案。
reading.only.start.at.the.beginning.of.the.file=唯讀。從檔案開頭開始。
readonly.property.cannot.have.default.value='readonly' 屬性不能具有預設值
readonly.property.must.have.type='readonly' 屬性必須指定類型
recursive.call=遞迴呼叫
redefinition.of.parameters.is.not.allowed=不允許參數重新定義
refactoring.common.fail.to.extract.expression=無法從所選程式碼段中提取表達式
refactoring.common.not.extractable.expression=不支持此類別表達式
refactoring.common.not.supported.context=當前上下文不支持{0}
refactoring.common.not.supported.expression.in.scope=當前作用域不支持此類別表達式的{0}
refactoring.common.ui.target.directory.edit=按 F2 編輯目標目錄
refactoring.common.ui.target.directory.label=目標目錄(&D):
refactoring.common.ui.target.namespace.label=命名空間(&N):
refactoring.common.validation.class.psi=無法執行重構: 目標類別“{0}”無效
refactoring.common.validation.namespace.name=“{0}”不是有效的命名空間名稱
refactoring.common.validation.target.directory.is.not.valid=目錄“{0}”的路徑無效
refactoring.common.validation.target.directory.not.inside.project=目錄“{0}”不在專案內部
refactoring.copy.class.name=複製類別
refactoring.extract.base.dialog.replace.all.occurrences=取代所有符合項(找到 {0} 個匹配項)(&A)
refactoring.extract.base.handler.no.expression.selected=選擇不構成正確的表達式
refactoring.extract.base.handler.not.supported.expression=此類別表達式不支持{0}
refactoring.extract.base.handler.not.supported.scope=當前作用域不支持{0}
refactoring.extract.base.validator.not.valid.identifier=“{0}”不是有效的 PHP 關鍵字。
refactoring.extract.base.validator.reserved.keyword=“{0}”是保留的 PHP 關鍵字。
refactoring.extract.class.conflicts.extract.class.refactoring.is.not.supported.for.dynamically.declared.properties.usages=動態宣告屬性用法不支持“提取類別”重構
refactoring.extract.class.conflicts.method.0.depends.on.1.constant.2=方法“{0}”依賴於 {1} 常數“{2}”
refactoring.extract.class.conflicts.method.0.depends.on.1.method.2=方法“{0}”依賴於 {1} 方法“{2}”
refactoring.extract.class.conflicts.method.0.depends.on.property.1.which.needs.getters.in.2=方法“{0}”依賴於屬性 "\${1}"，需要“{2}”中的 getter
refactoring.extract.class.conflicts.method.0.depends.on.property.1.which.needs.setters.in.2=方法“{0}”依賴於屬性 "\${1}"，需要“{2}”中的 setter
refactoring.extract.class.conflicts.unable.to.add.delegate.property.initialization.to.constructor=無法將委託的屬性初始化新增到類別建構函式
refactoring.extract.class.conflicts.unable.to.add.delegate.property.initialization.to.constructor.trait.constructor.will.be.overridden=無法將委託的屬性初始化新增到類別建構函式: 特徵建構函式將被覆寫
refactoring.extract.class.conflicts.using.write.access.for.non.public.properties.in.array.destructuring.expressions.is.not.supported.in.extract.class.refactoring=“提取類別”重構不支持將寫入權限用於陣列解構表達式中的非 public 屬性
refactoring.extract.class.conflicts.using.write.access.for.non.public.properties.in.multiple.assignment.expressions.in.extract.class.refactoring=“提取類別”重構不支持將寫入權限用於多個指派表達式中的非 public 屬性
refactoring.extract.class.dialog.class=類別名:
refactoring.extract.class.dialog.generate.accessors=生成存取器(&G)
refactoring.extract.class.dialog.members.to.be.extracted=要提取的成員
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.abstract.methods=抽象方法不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.anonymous.classes=匿名類別不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.anonymous.functions=匿名函式不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.doc.methods=通過 PHPDoc 定義的魔術方法不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.doc.properties=通過 PHPDoc 定義的魔術屬性不支持 Extract Class 重構
refactoring.extract.class.error.failed.to.create.file=無法建立檔案
refactoring.extract.class.error.the.selected.function.should.belong.to.project.sources=所選函式必須屬於專案源
refactoring.extract.class.extract.to.class=提取到類別
refactoring.extract.class.extracting.from.class=正在從類別提取:
refactoring.extract.class.extracting.from.file=正在從檔案提取:
refactoring.extract.constant.conflict.already.exists=作用域中已經存在名稱為“{0}”的常數。
refactoring.extract.constant.conflict.cannot.override.interface.constant=無法覆寫接口“{1}”的常數“{0}”
refactoring.extract.constant.conflict.exists.in.subclass=“{0}::{1}”將被此常數覆寫
refactoring.extract.constant.conflict.exists.in.subclass.with.weaker.access=“{0}”的存取級別必須為“{1}”(如在類別“{2}”中)或更弱
refactoring.extract.constant.name=提取常數
refactoring.extract.constant.unable.to.add.constant.declaration="無法新增常數宣告"
refactoring.extract.field.conflict.already.exists=該類中已經存在名稱為“{0}”的屬性。
refactoring.extract.field.name=提取屬性
refactoring.extract.field.validator.reserved.field.name=“{0}”是保留的屬性名稱
refactoring.extract.field.visibility=可見性
refactoring.extract.field.visibility.private=private(&I)
refactoring.extract.field.visibility.protected=protected(&O)
refactoring.extract.field.visibility.public=public(&U)
refactoring.extract.interface.fail.to.create.file=無法建立檔案 ''{0}''。
refactoring.extract.interface.field=接口名稱(&I):
refactoring.extract.interface.invalid.caret.location=文字游標應置於要重構的類別名處。
refactoring.extract.interface.invalide.extract.from.trait=無法從特徵提取接口。
refactoring.extract.interface.members.title=要構成接口的成員(&B)
refactoring.extract.interface.name=提取接口
refactoring.extract.interface.no.methods=沒有要提取到接口的方法。
refactoring.extract.interface.phpdoc.copy=複製(&C)
refactoring.extract.interface.phpdoc.do.nothing=保留原樣(&A)
refactoring.extract.interface.phpdoc.move=移動(&M)
refactoring.extract.interface.phpdoc.title=PhpDoc
refactoring.extract.interface.title=從類別 ''{0}'' 提取接口
refactoring.extract.interface.validation.members.modifier=對於每個提取的方法，修飾符將更改為 public。
refactoring.extract.method.error.a.set.of.statements.should.be.from.the.same.code.block=一組語句應來自同一程式碼塊。
refactoring.extract.method.error.inconsistent.return.points.in.selected.code.fragment=所選程式碼段中的返回點不一致。
refactoring.extract.method.error.selected.block.should.represent.a.set.of.statement.or.an.expression=所選塊應代表一組語句或表達式。
refactoring.extract.method.error.there.are.break.continue.operators.which.can.interrupt.execution=存在會中斷執行的 break/continue 運算符。
refactoring.extract.method.from.duplicate.code=從重複的程式碼中提取方法
refactoring.extract.method.name=提取函式/方法
refactoring.extract.method.tooltip=輸入 $name = 'init'
refactoring.extract.parameter.name=提取參數
refactoring.extract.replace.class.reference=盡可能將類別參照取代為接口(&F)
refactoring.extract.variable.conflict.already.exists=作用域中已經存在名稱為“{0}”的變數。
refactoring.extract.variable.name=提取變數
refactoring.inline.cannot.find.variable.to.inline=找不到要內聯的變數
refactoring.inline.constant.all.references.and.keep=全部內聯並保留常數
refactoring.inline.constant.all.references.and.remove=全部內聯並移除常數
refactoring.inline.constant.cannot.extract.value=無法提取常數的值
refactoring.inline.constant.command=內聯常數
refactoring.inline.constant.is.never.used=常數 {0} 從未使用
refactoring.inline.constant.multiple.declarations=還有其他具有相同名稱的常數宣告。
refactoring.inline.constant.name=內聯常數
refactoring.inline.constant.this.reference.only=僅內聯此參照並保留常數
refactoring.inline.function.all.invocations.and.remove.the.method=全部內聯並移除{0}(&A)
refactoring.inline.function.all.invocations.keep.the.method=全部內聯並保留{0}(&E)
refactoring.inline.function.cannot.find.function.declaration=找不到函式宣告
refactoring.inline.function.cannot.inline.constructor=無法內聯建構函式
refactoring.inline.function.cannot.inline.first.class.callable.declaration=無法內聯一級可調用宣告
refactoring.inline.function.cannot.inline.function.with.global.usage=無法內聯{0}和 <code>global</code> 用法
refactoring.inline.function.cannot.inline.library.function=無法內聯庫函數
refactoring.inline.function.cannot.inline.magic.method=無法內聯魔術方法
refactoring.inline.function.cannot.inline.overridden.method=無法內聯被覆寫的方法
refactoring.inline.function.cannot.parse.function.body=無法解析函式體
refactoring.inline.function.command=正在內聯{0}
refactoring.inline.function.inline.function.refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow=當 return 語句中斷執行流程時，不支持內聯函式重構
refactoring.inline.function.not.accessible.from.caller.site=無法從呼叫者站點存取成員參照 <code>{0}</code>
refactoring.inline.function.only.static.method.is.supported=僅支援 static 方法
refactoring.inline.function.parent.reference.unresolved=<code>parent</code> 類別參照在 {0} 中未解析
refactoring.inline.function.reference.is.recursive=不支持遞迴呼叫
refactoring.inline.function.this.invocation.only.and.keep.the.method=僅內聯此呼叫並保留{0}(&K)
refactoring.inline.function.title=內聯{0}重構
refactoring.inline.function.yield.found.in.function.body=在函式體中找到 <code>yield</code> 用法
refactoring.inline.variable.cannot.extract.value=無法提取變數 ''\${0}'' 的值
refactoring.inline.variable.no.occurrences=沒有符合項可以被安全地內聯
refactoring.inline.variable.unary.operation=無法內聯到遞減或遞增運算
refactoring.inplace.extract.method.name=就地提取函式/方法
refactoring.make.method.static=將方法設為 static
refactoring.make.method.static.add.parameters.for.fields=新增屬性參數(&P):
refactoring.make.method.static.doc.method.is.not.supported=不支持文檔方法
refactoring.make.method.static.dynamic.method.call.found=執行個體物件應作為參數傳遞，找到動態方法呼叫: {0}
refactoring.make.method.static.magic.method=魔術方法不能設為 static
refactoring.make.method.static.method.calls.found.in.static.context=在 static 上下文中找到方法呼叫
refactoring.make.method.static.method.converts.method.to.static=將方法轉換為 static
refactoring.make.method.static.method.is.overridden=方法 {0} 被覆寫
refactoring.make.method.static.object.is.needed=方法 {0} 使用未作為參數傳遞的屬性 {1}
refactoring.make.method.static.private.field.is.not.accessible=private 屬性 {0} 無法從類別外部存取
refactoring.make.method.static.protected.field.is.not.accessible=protected 屬性 {0} 無法從類別及其繼承者外部存取
refactoring.make.method.static.references.to.be.changed=待更改參照 {0}
refactoring.make.method.static.this.found=執行個體物件應作為參數傳遞，找到 $this
refactoring.make.method.static.writeAccess=檢測到 {0} 寫入存取，執行個體物件應作為參數傳遞。
refactoring.make.static.then.move.method.message=方法 ''{0}'' 將被設為 ''public static''
refactoring.make.static.then.move.method.select=將方法 ''{0}'' 移至類別
refactoring.move.class.action.name=移動類別…
refactoring.move.class.cannot.move.anonymous.class=無法移動匿名類別
refactoring.move.class.in.non.code.message=註釋和字串中的類別參照
refactoring.move.class.name=移動類別
refactoring.move.class.new.file=將類別提取到單獨的檔案(&E)
refactoring.move.class.title=將類別 {0} 移至命名空間(&C):
refactoring.move.classes.dnd.files.with.the.same.name.error=單個目標中不允許有多個同名檔案。
refactoring.move.classes.dnd.name=移動類別
refactoring.move.classes.dnd.title=將所選{0,choice,0#類別|1#命名空間|2#類別和命名空間}移至命名空間:
refactoring.move.constant.action.name=移動常數…
refactoring.move.constant.class.already.contains.constant=類別 {0} 已包含常數 {1}
refactoring.move.constant.class.already.contains.method=類別 {0} 已包含方法 {1}
refactoring.move.constant.label.text.field=將常數 {0} 移至類別(&C)
refactoring.move.constant.title=移動常數
refactoring.move.constant.unable.to.resolve=無法解析 {0}
refactoring.move.function.action.name=移動函式…
refactoring.move.function.interface.cant.contain.method=接口中不允許帶有主體的方法
refactoring.move.function.label.text.field=將函式 {0} 移至類別(&C)
refactoring.move.function.title=移動函式
refactoring.move.instance.method=移動執行個體方法
refactoring.move.instance.method.action.name=移動執行個體方法…
refactoring.move.instance.method.preview.header=要移至另一個類別的方法
refactoring.move.instance.method.this.parameter.label=將取代類別 {0} 的 $this 參照的參數名稱
refactoring.move.instance.method.usage.will.not.be.accessible=用法 {0} 將無法存取。應提高方法可見性
refactoring.move.member.action.name=移動成員…
refactoring.move.member.method.is.overridden.in.a.sublclass={0} 在子類別 {1} 中被覆寫
refactoring.move.member.title=移動 static 成員
refactoring.move.members.0.will.be.hidden.in.1=成員 {0} 將在 {1} 中被隱藏
refactoring.move.members.cannot.find.target.class=找不到類別 {0}
refactoring.move.members.class.0.does.not.exist=類別 {0} 不存在。\\n是否要建立?
refactoring.move.members.enum.0.already.contains.case.with.name.0=枚舉 {0} 已經包含名稱為 ''{1}'' 的 case
refactoring.move.members.enum.0.already.contains.case.with.value.1=枚舉 {0} 已經包含值為 ''{1}'' 的 case
refactoring.move.members.is.not.a.valid.class.name=“{0}”不是有效的類別名
refactoring.move.members.is.not.accessible={0} 在 {1} 中無法存取
refactoring.move.members.late.static.binding.detected=檢測到延遲 static 綁定: {0}
refactoring.move.members.late.static.binding.detected.in.doc=在文檔中檢測到延遲 static 綁定
refactoring.move.members.member.will.change.visibility.to.public=成員 {0} 會將可見性更改為 public
refactoring.move.members.method.implements.abstract.method={0} 在 {1} 中實作 abstract 方法
refactoring.move.members.method.implements.method.in={0} 在 {1} 中實作方法
refactoring.move.members.move.as.enum.cases=作為枚舉 case 移動
refactoring.move.members.no.members.are.selected=未選擇成員
refactoring.move.members.only.constants.can.be.moved.to.interface=只有常數可以移至接口
refactoring.move.members.preview.header=要移至另一個類別的成員
refactoring.move.members.properties.can.not.be.moved.to.enum=屬性不能移動到枚舉
refactoring.move.members.self.from.anonymous.class=無法處理對匿名類別的自參照
refactoring.move.members.there.are.several.classes.with.specified.name=存在多個具有指定名稱 {0} 的類別
refactoring.move.members.to.be.moved=要移至另一個類別的成員(&B)
refactoring.move.members.unable.to.resolve.usage.callback.found=無法解析用法: 發現回調: {0}
refactoring.move.members.unable.to.resolve.usage.late.static.binding.detected=無法解析用法: 檢測到延遲 static 綁定: {0}
refactoring.move.method.cannot.move.constructor=無法移動建構函式
refactoring.move.method.cannot.move.magic.method=無法移動魔術方法
refactoring.move.method.label.text.field=將成員移至類別(&C)
refactoring.move.multiple.constant.label.text.field=將 {0} 個常數移至類別(&C)
refactoring.move.multiple.functions.label.text.field=將 {0} 個函式移至類別(&C)
refactoring.move.namespace.action.name=移動命名空間…
refactoring.move.namespace.header.message=移動命名空間
refactoring.move.namespace.in.non.code.message=註釋和字串中的命名空間參照
refactoring.move.namespace.message=要移動的命名空間
refactoring.move.namespace.name=移動命名空間
refactoring.move.namespace.new.namespace=新命名空間名稱(&N):
refactoring.move.namespace.title=移動命名空間 {0}
refactoring.move.related.namespace.collect.title=收集子命名空間
refactoring.move.related.namespace.description=將具有相關命名空間的檔案移至新目錄:
refactoring.move.related.namespace.directory.column=新增目錄
refactoring.move.related.namespace.name.column=新命名空間名稱
refactoring.move.related.namespace.title=移動具有相關命名空間的檔案
refactoring.parameter.reserved.name=參數名稱“{0}”已保留
refactoring.parameter.validation=參數 {0} 無效
refactoring.parameter.validation.default.value=預設值表達式 ''{0}'' 無效
refactoring.parameter.validation.duplicate.parameter=重複的參數名稱: {0}
refactoring.parameter.validation.initializer=初始設定式 ''{0}'' 無效
refactoring.parameter.validation.initializer.last=必選參數不能位於可選參數後
refactoring.parameter.validation.initializer.type=具有類別類型提示的參數的預設值只能為 NULL
refactoring.parameter.validation.name.collision.with.use.list=參數名稱 ''{0}'' 無效。''{0}'' 已匯入 use 列表
refactoring.parameter.validation.no.default.value=應該為參數 ''{0}'' 提供初始設定式或預設值
refactoring.parameter.validation.pass.by.reference=僅變數可通過參照傳遞
refactoring.parameter.validation.type=參數類型 ''{0}'' 無效
refactoring.parameter.validation.variadic.can.have.default.value=可變參數不能具有預設值
refactoring.parameter.validation.variadic.last=只有最後一個參數可以是可變形參
refactoring.php.cannot.create.class=無法在預覽中建立新類別
refactoring.php.create.class=建立新類別
refactoring.php.extract.enum=提取枚舉
refactoring.pull.up.abstract.method=類別 {0} 將被標記為 abstract
refactoring.pull.up.class.does.not.have.base.classes.interfaces.in.project.files={0}在專案檔案中沒有基類別/接口
refactoring.pull.up.conflict.duplicate.constant={0} 將與 {1} 中的常數衝突。
refactoring.pull.up.implement.method=在實作接口的類別中建立方法存根(&S)
refactoring.pull.up.is.1.and.will.not.be.accessible.in.the.target.class={0} 為 private，在目標類別中將無法存取。
refactoring.pull.up.may.not.be.accessible.in.the.target.class={0} 在目標類別中可能無法存取。
refactoring.pull.up.private.access={0} 存取權限將更改為 {1}
refactoring.pull.up.static.reference.is.not.accessible.in.the.target.class=非 static 方法 {0} 不應在外部類中靜態呼叫
refactoring.pull.up.validation.field.into.interface=無法將屬性拉入接口
refactoring.pull.up.validation.static.method.into.interface={0} 為 static，不能為 abstract。
refactoring.pull.up.will.not.be.accessible.in.the.target.class={0} 在目標類別中將無法存取。
refactoring.push.down.method.implemented.in.interface={0} 必須被宣告為 abstract 或實作 {1}
refactoring.push.down.validation.magic.method=移動魔術方法會產生副作用
refactoring.rename.automatic.renamer.accessors.name=重新命名存取器(&C)
refactoring.rename.automatic.renamer.class.dialog.description=將具有以下名稱的類別重命名為:
refactoring.rename.automatic.renamer.class.dialog.title=重新命名類別
refactoring.rename.automatic.renamer.class.entity.name=類別
refactoring.rename.automatic.renamer.class.name=重新命名類別(&C)
refactoring.rename.automatic.renamer.field.accessors.dialog.description=將具有以下名稱的屬性存取器重命名為:
refactoring.rename.automatic.renamer.field.accessors.dialog.title=重新命名存取器
refactoring.rename.automatic.renamer.field.accessors.entity.name=存取器
refactoring.rename.entity.name.inheritor=繼承者/檔案
refactoring.rename.inheritors.and.related.files.with.the.following.names.to=將具有以下名稱的繼承者和相關檔案重命名為:
refactoring.rename.search.in.global.scope=在全域作用域中搜尋
refactoring.returnType.validation.type=返回值類型 ''{0}'' 無效
refactoring.validation.class.error.property.with.name.0.is.already.exists=已存在名稱為“{0}”的屬性
reference=參照
referenced.calls=參照的呼叫
reformats.file.with.0=使用 ''{0}'' 重新設定檔案格式
relationship.already.exists={0} 與 {1} 之間的關係已存在
release.name.eg.5.1.2.release=發佈名稱。例如，5.1.2-RELEASE
remote.connection.settings.default.remote.interpreter=預設遠端解釋器
remote.connection.settings.interpreter.is.not.remote=當前專案解釋器非遠端解釋器
remote.interpreter.browse.action.is.not.supported.for.docker=基於 Docker 的遠端解釋器不支持瀏覽動作
remote.interpreter.can.t.be.executed.please.enable.the.php.remote.interpreter.plugin=無法執行遠端解釋器。啟用 PHP Remote Interpreter 延伸模組。
remote.interpreter.path.mappings.validation.message=請檢查映射是否在 {0} 下正確組態。
remote.interpreter.path.mappings.validation.php.section=<b><i><a href="php_mappings">設定|PHP</a></i></b>
remote.interpreter.path.mappings.validation.title=沒有為所選解釋器組態路徑映射。
remove=移除
remove.assignment=移除指派
remove.else=移除 else…
remove.from.function.0.declaration=從函式 ''{0}'' 宣告中移除 ''\\\\&''
remove.from.ignored.list=移除
remove.from.the.parameter.0=從參數 ''{0}'' 中移除 ''\\\\&''
remove.link.between.0.and.1=移除 {0} 與 {1} 之間的連結
remove.numeric.literals.separators=移除數字字面量分隔符
remove.pass.by.ref=移除 '\\\\&'
remove.pass.by.ref.sign=移除 '\\\\&'
remove.redundant.initializer=移除冗餘的初始設定式
remove.redundant.suppression.quick.fix.family.name=移除 ''{0}'' 禁止
remove.relationship.link=移除關係連結
remove.rule=移除規則
remove.unnecessary.parentheses=移除不必要的圓括號
remove.unnecessary.reset=移除不必要的 'reset'
remove.unnecessary.semicolon=移除不必要的分號
remove.variable=移除變數
rename=重新命名
rename.constructor=重新命名建構函式
rename.filename.quick.fix=將檔案 ''{0}'' 重命名為 ''{1}''
rename.parameter.dialog.description=將層次結構中的參數重命名為:
rename.parameters.dialog.title=重新命名參數
rename.psi.element.quick.fix=將{0} ''{1}'' 重命名為 ''{2}''
replace.all.occurrences.with.php=將所有符合項取代為 '<?php'
replace.all.occurrences.with.php.echo=將所有符合項取代為 '<?php echo'
replace.all.occurrences.with.short.php.echo=將所有符合項取代為 '<?='
replace.all.occurrences.without.side.effects=取代所有無副作用的符合項
replace.deprecated.from.of.callable=取代已棄用的可呼叫物件形式
replace.extends.implements=取代 'extends'/'implements'
replace.if.clause.with.ternary.expression=將 if 子句取代為三元表達式
replace.if.with.switch=將 'if' 取代為 'switch'
replace.plus.asgn.to.concat.asgn.quick.fix.family.name=將 '+=' 取代為 '.='
replace.plus.to.concat.quick.fix.family.name=將 '+' 取代為 '.'
replace.qualifier.with.an.import=將限定符取代為匯入
replace.quotes=取代引號
replace.ternary.expression.with.if.clause=將三元表達式取代為 if 子句
replace.unnecessary.double.quotes=取代不必要的雙引號
replace.variable.assignment.with.named.argument=將變數指派取代為命名實參
replace.with.0=取代為 {0}
replace.with.01=取代為 {0}
replace.with.absolute.reference=取代為絕對參照
replace.with.alias=取代為別名
replace.with.alias.from.target.scope=取代為目標作用域中的別名
replace.with.anonymous.function=取代為匿名函式
replace.with.array=取代為直接指派 '$array = array($value)'
replace.with.array.short.syntax=取代為直接指派 '$array = [$value]'
replace.with.arrow.function=取代為箭頭函式
replace.with.coalesce.operator=取代為合併運算符
replace.with.first.class.callable.family.name=取代為一級可調用語法
replace.with.pow.operator=取代為 '**' 運算符
replace.with.quest=取代為 '?'
require='必需'
required.parameters.missing=缺少所需參數 ''{0}''
required.trait.0.wasn.t.added.to.1=必需特徵 ''{0}'' 未新增到 ''{1}''
rerun.with.ignore.platform.reqs=使用 --ignore-platform-reqs 重新執行
retrieving.php.version.data.from.3v4l.org=正在從 3v4l.org 檢索 PHP 版本資訊
return.type=返回值類型
return.type.declaration.is.not.allowed=不允許返回值類型宣告
return.type.declaration.must.be.compatible.with.super=返回值類型宣告必須與父級相容
returned.by.iterator.aggregate.should.be.traversable=\\\\IteratorAggregate::getIterator() 返回的物件必須為 Traversable 或實作接口 Iterator
rfc.2822.rfc.5322.formatted.date=RFC 2822/RFC 5322 格式的日期({0})
run.install.update.with.platform.reqs=使用 --ignore-platform-reqs 執行安裝/更新(&R)
run.with.paratest=使用 ParaTest 執行
run.with.paratest.mnemonic=使用 ParaTest 執行 %s
searching.for.usages=正在搜尋用法…
seconds.numeric=秒，數字(1、3、57)
seconds.numeric.at.least.2.digits.with.leading.0=秒，數字，至少 2 位數，帶前導 0 (01、03、57)
seconds.since.the.unix.epoch.january.1.1970.00.00.00.gmt=自 Unix 時間戳 1970 年 1 月 1 日 00:00:00 GMT 以來的秒數({0})
seconds.with.leading.zeros=帶前導零的秒(00 到 59)
select.composer.phar.and.provide.the.full.path.to.it.or.select.download.composer.stable.phar.from.getcomposer.org=選擇 'composer.phar' 並提供其完整路徑，或者選擇“從 getcomposer.org 下載 composer-stable.phar”。
select.composer.phar.and.provide.the.full.path.to.it.or.select.download.composer.stable.phar.from.getcomposer.org1=選擇 'composer.phar' 並提供其完整路徑，或者選擇“從 getcomposer.org 下載 composer-stable.phar”。
server=伺服器
set=設定
set.access.level.to.0.1.must.be.2.as.in.class.3.or.weaker=''{0}::\${1}'' 的 ''set'' 存取級別必須為 {2} (與類別 ''{3}'' 中一樣)或更低
set.close.on.exec.flag.on.the.opened.file.descriptor.only.available.in.php.compiled.on.posix.1.2008.conform.systems=在檔案檔案描述子上設定 close-on-exec 標誌。僅適用於符合 POSIX.1-2008 標準的系統。
set.the.following.option=設定以下選項:
settings.smart.keys.auto.insert.closing.html.tag.in.php.doc=在 PHPDoc 塊中自動插入 HTML 結束標記
settings.smart.keys.auto.insert.semicolon=在函式呼叫內部鍵入時自動插入分號 
settings.smart.keys.auto.insert.tag.after.typing=輸入 '<?' 後自動插入 '<?php' 標記
settings.smart.keys.enable.smart.function.parameters.completion=啟用智能函式參數補全
settings.smart.keys.escape.symbols.on.paste.in.string.literals=在字串字面量中貼上時轉義符號
settings.smart.keys.find.usages.of.base.method.prompt=搜尋方法用法時顯示其他選項
settings.smart.keys.remove.php.open.close.tags.while.pasting.in.php.context=在 PHP 上下文中貼上時移除 PHP 開始/結束標記
settings.smart.keys.replace.unnecessary.double.quotes.on.paste=貼上時取代不必要的雙引號
settings.smart.keys.select.variable.name.without.dollar.sign.on.double.click=在雙擊時選擇不帶 '$' 符號的變數名
settings.smart.keys.title=PHP
short.arrow.function.cannot.return.void=箭頭函式不能有 'void' 返回值類型
shorten.property.hook=縮短屬性掛鈎
show.0.settings.window=顯示 ''{0}'' 設定視窗
show.composer.settings.action.name=顯示 Composer 設定
show.constants=顯示常數
show.implementations.for.0={0} 的實作
show.includes=顯示 Include
show.log=顯示日誌
show.log.of.composer.related.actions=顯示 Composer 相關動作的日誌
show.name.for.all.arguments=顯示所有實參的名稱
show.private.members=顯示 private 成員
show.properties=顯示屬性
show.protected.members=顯示 protected 成員
show.settings=顯示設定
show.super.types.for.0=顯示 {0} 的父類型
show.validation.dialog=顯示“驗證偵錯器”對話框
shows.0.dialog=顯示 ''{0}'' 對話框
shows.dialog.with.methods.from.implemented.interface.selected.methods.will.be.inserted.into.the.class.after.dialog.confirmation=顯示包含已實作接口中方法的對話框。對話框確認後，所選方法將被插入到類別中。
shows.list.of.child.classes.with.inaccessible.methods=顯示具有不可存取方法的子類別列表
shows.list.of.child.classes.without.without.resolved.member=顯示沒有已解析成員的子類別列表
sign.minus.when.negative.empty.when.positive=負數時標記為 "-"，正數時留空(-、 )
sign.minus.when.negative.plus.when.positive=負數時標記為 "-"，正數時標記為 "+" (-、+)
simulating.update=正在模擬更新
skip.constant.params=跳過使用常數參數的呼叫
smarty=Smarty
smarty.configurable.title=Smarty
sort.by.visibility=按可見性排序
sort.the.elements.by.visibility.public.protected.private=按可見性對元素排序: public、protected、private
split.elseif=拆分 'elseif'
split.selected.group.use.statement=拆分所選 'use' 語句組
spread.operator.on.named.arguments.is.forbidden=禁止對命名實參使用展開運算符
spread.operators.in.arrays.are.not.supported.for.multiassignments.variables=多指派變數不支持在陣列中使用展開運算符
squash.repetitive.underscores=壓縮重複下劃線
static.is.not.allowed.in.compile.time.constants=編譯時常量中不允許使用 'static::'
static.is.not.allowed.in.parameter.type.declaration=參數類型宣告中不允許 'static'
static.modifier.is.not.allowed.here=此處不允許使用 'Static' 修飾符
static.property.cannot.be.readonly='static' 屬性不能為 'readonly'
static.property.cannot.be.unset=static 屬性不能取消設定
static.value=static 值
static.variable.with.same.name.already.defined.in.current.scope=static 變數 ''{0}'' 的宣告重複
status.text.no.dependencies=無相依項
strict.type.declaration.is.available.in.php.7.only=從 PHP 7.0 起才允許使用嚴格類型宣告
strict.types.declaration.must.have.0.or.1.as.its.value='strict_types' 宣告的值必須為 0 或 1
summary=摘要
suppress.all.for.file=對檔案全部禁止
suppress.for.field=對欄位禁止
suppress.for.file=對檔案禁止
suppress.for.function=對函式禁止
suppress.for.method=對方法禁止
suppress.for.phpdoc.comment=對 PhpDoc 註釋禁止
suppress.if.annotated.by.tag=如果用 ''{0}'' 註解，則禁止
suppress.unused.preview=對使用 ''{0}'' 註解的實體禁止“未使用的宣告”檢查
suppressed.annotation.title=已禁止的註解
surround.with.0=使用 ''{0}'' 包圍
surround.with.if.0.1=使用 ''if({0}({1}))'{'...'}''' 包圍
swatch.internet.time=Swatch 互聯網時間(000 到 999)
switch.statements.may.only.contain.one.default.clause.in.php.7=在 PHP 7 中，switch 語句只能包含一個 'default' 子句
switch.with.common.parts=包含通用部分的 'switch'
switching.from.another.vs.code.sublime.text.or.another.ide.check.out.our.migration.guides.to.get.started.faster=從 VS Code、Sublime Text 或其他 IDE 切換而來? 請檢視我們的遷移指南以更快地開始使用。
target=目標
target.class=目標類別:
target.directory.for.validation.script.is.not.public=驗證腳本的目標目錄不是 public。
target.trait.should.be.specified=應指定目標特徵
template.debug.cache.dir.is.incorrect=模板偵錯: 在設定中指定的快取目錄路徑無效
template.debug.cache.dir.is.not.specified=模板偵錯: 未在設定中指定快取目錄路徑
template.debug.cache.path=快取路徑:
template.debug.path.to.output.folder=快取目錄路徑
template.debug.path.to.output.folder.descr=指定快取目錄路徑
template.debug.php.file.not.found=模板偵錯: 未找到 {0} 的相應 PHP 檔案
template.parameter=模板參數
template.smart.completion.function.parameters.description=智能函式參數補全
terminal.add.interpreter.to.path=將預設專案 PHP 解釋器新增到 {0}
ternary.condition.can.be.replaced.with.condition.expression=表達式可以安全地取代為 ''{0}''
test.not.tests.was.executed.title=未組態 {0}。按 ''修正'' 安裝 composer 軟體套件。
text.plain=文本/純
the.button.shows.whether.inspection.is.on.or.off=該按鈕顯示檢查是開啟還是關閉
the.day.of.the.year.starting.from.0=一年中的第幾天(0 至 365)
the.original.class.0.does.not.belong.to.the.project.and.cannot.be.modified=原始類別 {0} 不屬於該專案\\n並且無法修改。
the.remote.hosts.access.plugin.is.missing.please.enable.the.plugin.in.0.plugins=缺少 ''FTP/SFTP/WebDAV Connectivity'' 和 ''Terminal'' 延伸模組中的一個或兩個。請在“{0} | 延伸模組”中啟用延伸模組。
the.result.of.validation.will.be.fetched.by.http.request=驗證輸出由 HTTP 請求提取。
the.same.as.p.but.returns.z.instead.of.00.00.available.as.of.php.8.0=與 P 相同，但返回 Z 而不是 +00:00，從 PHP 8.0 起可用(+02:00)
the.use.keyword.must.be.declared.in.the.outermost.scope.of.a.file.the.global.scope.or.inside.namespace.declarations=必須在檔案的最外側作用域(全域作用域)或命名空間宣告內部宣告 'use' 關鍵字
the.yield.expression.can.only.be.used.inside.a.function='yield' 表達式只能在函式中使用
there.are.errors.on.attempt.to.load.debug.extension.e.g.version.incompatibility=嘗試載入偵錯擴展時出錯，例如版本不相容。
this.is.the.default.contains.all.modes.in.the.sequence.s.n.r.v.m=這是預設值。包含序列 "s n r v m" 中的所有模式
this.reassignment.is.not.allowed=不能重新分配 $this
this.will.remove.relationship.link.between.classes=這將移除類別之間的關係連結並修改類別 {0}。繼續?
timezone.abbreviation.if.known.otherwise.the.gmt.offset=時區縮寫(如果已知)，否則為 GMT 偏移量(EST、MDT、+05)
timezone.identifier=時區關鍵字(UTC、GMT、大西洋/亞速爾群島)
timezone.offset.in.seconds=以秒為單位的時區偏移量(-43200 到 50400)
tooltip.configured.php.language.level.widget=已組態的 PHP 語言級別
tooltip.configured.php.language.level.widget.composer=通過 Composer 組態的 PHP 語言級別
tooltip.defaults.to.project.folder=預設為專案目錄
tooltip.from=來自{0}:
tooltip.from.volumes=來自{0}卷:
tooltip.update=更新 {0}
tooltip.wsl2.mappings=WSL2 映射
total.number.of.days.as.a.result.of.a.datetime.diff.or.unknown.otherwise=由 DateTime::diff() 或(未知)方法得出的總天數(4、8、8123)
trailing.comma.is.not.allowed=不允許尾隨逗號
trait.already.contains.method=特徵 {0} 已包含方法 {1}
trait.expected.class.found=應為特徵，發現類別
trait.method.0.will.not.be.applied.because.it.collides.with.1=由於與 ''{1}'' 衝突，因此不會套用特徵方法 ''{0}''
trait.use.rule.type.name=特徵 use 規則方法
transform=轉換
turn.off.external.formatter=關閉外部格式化程序
turn.off.inspection.tool=關閉 {0} 檢查
type=類型
type.0.cannot.be.part.of.an.intersection.type=類型 ''{0}'' 不能是交叉類型的一部分
type.0.is.redundant.as.it.is.more.restrictive.than.type.1=類型 ''{0}'' 冗餘，因為它比類型 ''{1}'' 更加嚴格
type.contains.both.true.and.false.bool.should.be.used.instead=類型同時包含 true 和 false，應改用布爾
type.primitive.false.null.hints.names.are.forbidden=從 PHP 8.0 起才允許使用名為 'false' 和 'null' 的類型提示
type.primitive.true.hints.names.are.forbidden=從 PHP 8.2 起才允許使用名為 'true' 的類型提示
types.not.supported.as.operands.for.0.1.2=''{1} {0} {2}'' 中不受支援的動作數類型將導致 PHP 8 TypeError
uml.0.already.exists.in.class.1=類別 {1} 中已經存在 ''{0}''
uml.wrong.name=錯誤的名稱
undefined.interpreter=未定義的解釋器
unhandled.0=未處理的{0}
unhandled.exceptions=未處理的異常
union.types.and.the.nullable.type.notation.cannot.be.mixed=聯合體類型和可為 null 類型表示法不能混合
union.types.mixed.cannot.be.nullable=混合類型不能為可 null，'null' 已是混合類型的一部分
unknown=未知
unknown.debugger.type=未知偵錯器類型
unknown.named.parameter=未知命名參數 ''{0}''
unnamed.variable=(未命名)
unnecessary.local.variable=不必要的區域變數
unsupported.declare.0=不支持的宣告 ''{0}''
untrusted.composer.dialog.text=正在安裝或更新相依項，或者執行 Composer 指令可能會執行潛在的惡意程式碼。\\n\\n如果不信任此源，請繼續使用安全模式。
unused.code.rules=未使用的程式碼規則
unwrap.dowhile=解包 do-while…
unwrap.else=解包 else…
unwrap.elseif=解包 elseif…
unwrap.for=解包 for…
unwrap.foreach=解包 foreach…
unwrap.if=解包 if…
unwrap.method=解包 ''{0}''
unwrap.switch=解包 switch…
unwrap.try=解包 try…
unwrap.while=解包 while…
update.php.doc.type.comment=取代為 ''{0}''
update.php.doc.type.family.name=更新 PHPDoc 類型
update.signature.to.match.phpdoc.comment=更新簽名以符合 PHPDoc 註釋
uppercase.ante.meridiem.and.post.meridiem.am.pm=大寫上午和下午(AM/PM)
url.to.validation.script='驗證腳本的 URL'
usage.in.extends.clause=etends 子句中的用法
usage.in.implements.clause=implements 子句中的用法
usage.in.import.statement=import 語句中的用法
usage.in.return.type=返回值類型中的用法
usage.in.type.hinting=類型提示中的用法
usage.of.intersection.types.grouping.is.allowed.only.as.part.of.union.type=交叉類型分組僅允許作為聯合體類型的一部分使用
usages.show.this.self.references=顯示 $this/自參照
use.0.in.callables.is.deprecated=在可呼叫物件中使用 ''{0}'' 已棄用
using.this.when.not.in.object.context=不在物件上下文中時使用 '$this'
validated.web.server.is.not.running=驗證的 Web 伺服器未執行。
validating=正在驗證
validating1=正在驗證…
validation.0.extension.is.installed.check.configuration.options=已安裝 ''{0}'' 擴展。檢查組態選項。
validation.0.extension.is.not.installed=未安裝 ''{0}'' 擴展
validation.0.is.not.a.directory=''{0}'' 不是目錄
validation.0.not.found.at.1=在 ''{1}'' 中找不到 ''{0}''
validation.cannot.parse.value.of.0=無法解析 ''{0}'' 的值
validation.class.already.exists={0}中已經存在具有相同名稱的類別
validation.class.cannot.be.overridden=類別“{0}”不能被覆寫
validation.class.not.valid.name=“{0}”不是有效的類別名
validation.connection.was.not.established=未建立連線。
validation.connection.was.not.established.0=無法使用 ''{0}'' 啟動偵錯器會話
validation.connection.was.not.established.no.debug=未安裝偵錯擴展
validation.connection.was.not.established.update.info=更新解釋器資訊
validation.connection.was.not.established.validate.installation=驗證安裝
validation.debug.extension.is.updated=偵錯擴展設定已更新。請重新執行當前組態以使用新值。
validation.file.already.exists=檔案“{0}”已存在
validation.file.already.exists.in.dir=名稱為“{0}”的檔案已存在於“{1}”中
validation.file.not.valid.name=“{0}”不是有效的檔名
validation.function.already.exists=當前命名空間中已定義具有相同名稱的函式
validation.interface.cannot.be.overridden=無法實作接口“{0}”
validation.invalid.alias=“{0}”不是有效的別名
validation.invalid.identifier=“{0}”不是有效的關鍵字
validation.invalid.identifier.with.no.identifier=插入的關鍵字無效
validation.namespace.already.exists={1}中已定義名稱為 ''{0}'' 的命名空間
validation.namespace.not.valid.name=“{0}”不是有效的命名空間名稱
validation.no.debug.extension.is.installed=未安裝偵錯擴展。
validation.press.fix.to.edit.project.configuration=按“修復”編輯您的專案組態。
validation.script.was.created.but.it.cannot.be.executed.check.possible.reasons=驗證腳本已建立，但無法執行。可能的原因:
validation.script.will.be.created.in.0.directory=驗證腳本將在 {0} 目錄中建立。
validation.script.will.be.created.in.0.directory.and.deployed.to.the.1.server=驗證腳本將在 {0} 目錄中建立並部署到 {1} 伺服器。
validation.script.will.be.created.locally.and.deployed.to.the.remote.server=IDE 會在本地建立臨時驗證腳本並將其部署到遠端伺服器。
validation.script.will.be.created.locally.and.the.result.will.be.fetched.by.http.request=IDE 會在指定目錄中建立一個臨時驗證腳本，然後從 Web 伺服器 URL 提取並解析此腳本生成的 XML 輸出。之後，腳本將被移除。
validation.ssh.remote.code.coverage.support={0} 擴展不支持通過 ssh 進行程式碼覆蓋
validation.ssh.remote.debug.support=''{0}'' 擴展不支持通過 ssh 進行遠端偵錯。
validation.test.no.test.patterns=未新增任何模式
validation.value.is.invalid={0} 無效
validation.value.is.not.specified.or.invalid={0} 未指定或無效。
validation.value.is.not.specified.or.invalid.press.fix.project.configuration={0} 未指定或無效。按“修復”編輯您的專案組態。
validation.value.is.not.specified.press.fix.project.configuration={1} 組態中未指定 {0}。按“修復”以編輯 {1} 組態。
validation.value.path.to.value.is.invalid=無法通過 {1} 中提供的路徑找到 {0}
validation.value.path.to.value.is.invalid.press.fix.project.configuration=無法通過 {1} 中提供的路徑找到 {0}。按“修復”以編輯 {2} 組態。
validation.value.path.to.value.should.be.specified={0} 的路徑應在 {1} 中指定
validation.vendor.doesnt.exit=供應商目錄不存在
value=值
variable=變數
variable.always.have.value.0=到達時變數始終為 ''{0,choice,0#false|1#true}'
variable.dereferenced=已解參照變數
variable1=變數
variadic.parameter.cannot.have.a.default.value=可變參數不能具有預設值
version.information.varies.a.lot.between.operating.systems=版本資訊。不同作業系統之間差異很大
void.can.only.be.used.as.return.type=Void 只能用作返回值類型
void.type.cannot.be.nullable=void 類型不能是可為 null
waiting.for.3v4l.org.response=正在等待 3v4l.org 響應…
whether.it.s.a.leap.year.1.or.0=是否為閏年(1 或 0)
whether.or.not.the.date.is.in.daylight.saving.time.1.or.0=日期是否為夏令時(1 或 0)
while=while
with.data.set.0=使用資料集 {1} 的 {0}
working.directory.invalid=找不到工作目錄 ''{0}''
writing.only.creates.files.if.not.exists.fails.otherwise=只寫。如果檔案不存在則建立檔案，如果找到檔案則失敗。
writing.only.start.at.the.beginning.of.the.file.and.truncate.the.file.to.zero.length.creates.files.if.not.exists=只寫。從檔案開頭開始，將其截斷為零長度。如果檔案不存在則建立檔案。
writing.only.start.at.the.the.end.of.the.file.creates.files.if.not.exists=只寫。從檔案末尾開始。如果檔案不存在則建立檔案。
writing.only.starts.at.the.beginning.of.the.file.creates.files.if.not.exists=只寫。從檔案開頭開始。如果檔案不存在則建立檔案。
xdebug.cloud.cannot.connect=無法連線到 Xdebug Cloud
xdebug.cloud.cannot.connect.unknown.host=Xdebug Cloud 無法存取: {0}
xdebug.cloud.cannot.open.new.debug.connection=打不開新的偵錯連線
xdebug.cloud.cannot.register.cloud.id=無法在 Xdebug Cloud 上註冊 Cloud ID
xdebug.cloud.cannot.register.cloud.id.unexpected.response=由於意外響應，無法註冊 Cloud ID
xdebug.cloud.validation.cloud.id.not.defined=Cloud ID 未定義
xdebug.cloud.validation.host.not.defined=未定義本地部署 Xdebug Cloud 主機
xdebug.cloud.validation.port.invalid=本地部署 Xdebug Cloud 連接埠無效
xdebug.compile.task=編譯 Xdebug 擴展程序
xdebug.initializing.connection.debugger=偵錯器
xdebug.initializing.connection.failed.with.timeout=無法連線到 {0}: 超時
xdebug.initializing.connection.xdebug.cloud=Xdebug Cloud
xdebug.initializing.debugger.connection=正在連線到 {0}…
xdebug.validation.download.script.label=下載腳本指令:
xdebug.validation.ip.not.found=在自動檢測到的 IDE IP 中找不到 {0}
xdebug.validation.ip.not.found.descr=自動檢測的 IDE IP: {0}
years.numeric=年份，數字(1、3)
years.numeric.at.least.2.digits.with.leading.0=年份，數字，至少 2 位數，帶前導 0 (01、03)
you.are.configuring.debug.extension.in.the.wrong.php.ini.see.the.loaded.php.ini.files.below=您正在錯誤的 php.ini 中組態偵錯擴展(請參見下方已載入的 php.ini 檔案)。
you.can.always.add.a.precise.exclusion.via.alt.enter.and.then.edit.it.to.broaden.as.needed=您始終可以通過 Alt-Enter 組合鍵新增精確排除，然後根據需要對其進行編輯以擴大範圍。
you.did.not.reload.web.server.after.changes.in.php.ini.file=在 php.ini 檔案中進行更改後，未重新載入 Web 伺服器。
zend.debugger.settings.broadcasting.is.already.launched=Zend Debugger 設定廣播已啟動"
`;

exports[`dev messages/SvnBundle.properties 1`] = `
"action.DumbAware.RepositoryBrowserDialog.text.branch.or.tag=分支或標記…
action.DumbAware.RepositoryBrowserDialog.text.move.or.rename=移動或重新命名(_M)…
action.DumbAware.SvnConfigureProxiesComponent.description.add=新增
action.DumbAware.SvnConfigureProxiesComponent.description.copy=複製
action.DumbAware.SvnConfigureProxiesComponent.text.add=新增
action.DumbAware.SvnConfigureProxiesComponent.text.copy=複製
action.EditCommitMessage.description=編輯修訂註釋。覆寫上一條訊息。
action.EditCommitMessage.text=編輯修訂註釋
action.IntegrateChangeSetAction.text=整合到分支
action.Subversion.BrowseSVNRepository.description=瀏覽 Subversion 版本庫
action.Subversion.BrowseSVNRepository.text=瀏覽 Subversion 版本庫(_W)…
action.Subversion.CleanupProject.description=對專案中的所有工作副本目錄執行清理
action.Subversion.CleanupProject.text=清理專案
action.Subversion.Clenaup.description=解鎖鎖定的目錄，並執行其餘所有未完成的動作
action.Subversion.Clenaup.text=清理(_E)
action.Subversion.CompareWithBranch.text=與分支比較…
action.Subversion.ConfigureBranches.text=組態分支…
action.Subversion.Copy.description=將選定的檔案或目錄複製到新的版本庫位置
action.Subversion.Copy.text=分支或標記(_B)…
action.Subversion.Create.External.description=選擇 URL，新增 svn\\:external 屬性，然後可以選擇簽出
action.Subversion.Create.External.text=建立外部…
action.Subversion.Ignore.ExactMatch.description=將所有所選檔案的名稱新增到目錄忽略列表
action.Subversion.Ignore.ExactMatch.text=所選檔名
action.Subversion.Ignore.MatchExtension.description=將 {0} 遮罩新增到目錄忽略列表
action.Subversion.ImportToSVNRepository.text=匯入 Subversion(_M)…
action.Subversion.Lock.description=鎖定檔案
action.Subversion.Lock.text=鎖定(_L)…
action.Subversion.MarkResolved.description=將文本和屬性衝突標記為已解決
action.Subversion.MarkResolved.text=標記為已解決(_M)…
action.Subversion.MarkTreeResolved.text=將樹衝突標記為已解決…
action.Subversion.PropertiesView.AddProperty.description=新增新屬性
action.Subversion.PropertiesView.AddProperty.text=新增屬性
action.Subversion.PropertiesView.Close.description=關閉此工具視窗
action.Subversion.PropertiesView.Close.text=關閉
action.Subversion.PropertiesView.DeleteProperty.description=刪除選定屬性
action.Subversion.PropertiesView.DeleteProperty.text=刪除屬性
action.Subversion.PropertiesView.EditKeywords.description=管理 svn\\:keywords 屬性
action.Subversion.PropertiesView.EditKeywords.text=編輯關鍵字
action.Subversion.PropertiesView.EditProperty.description=編輯選定屬性值
action.Subversion.PropertiesView.EditProperty.text=編輯屬性
action.Subversion.PropertiesView.FollowSelection.description=跟隨選擇
action.Subversion.PropertiesView.FollowSelection.text=跟隨選擇
action.Subversion.PropertiesView.Refresh.description=重新載入屬性
action.Subversion.PropertiesView.Refresh.text=重新整理
action.Subversion.Relocate.description=將工作副本重定位到其他 URL
action.Subversion.Relocate.text=重定位…
action.Subversion.RepositoryBrowser.Checkout.text=簽出(_C)…
action.Subversion.RepositoryBrowser.CompareWith.text=比較物件…
action.Subversion.RepositoryBrowser.CopyUrl.text=複製 URL…
action.Subversion.RepositoryBrowser.Export.text=匯出(_E)…
action.Subversion.Resolve.description=解決檔案中的文本衝突
action.Subversion.Resolve.text=解決文本衝突(_S)…
action.Subversion.SelectAllRevisions.description=全選
action.Subversion.SelectAllRevisions.text=全選
action.Subversion.SetProperty.description=在檔案或目錄中設定版本化屬性
action.Subversion.SetProperty.text=設定屬性(_T)…
action.Subversion.Share.text=共享目錄(_S)…
action.Subversion.ShareWholeProject.text=共享專案(Subversion)…
action.Subversion.ShowIntegratePanel.text=顯示整合面板
action.Subversion.ShowMergeSourceDetails.text=顯示合併原始碼詳細資訊
action.Subversion.ShowProperties.text=編輯屬性(_P)
action.Subversion.TogglePropertiesDiff.description=顯示 SVN 屬性的差異
action.Subversion.TogglePropertiesDiff.text=顯示屬性
action.Subversion.UndoIgnore.description=從目錄忽略列表中移除檔名/遮罩
action.Subversion.UndoIgnore.text=所選檔名
action.Subversion.Unlock.description=解鎖檔案
action.Subversion.Unlock.text=解鎖(_O)
action.Subversion.UnselectAllRevisions.description=取消全選
action.Subversion.UnselectAllRevisions.text=取消全選
action.Subversion.cleanup.error.message=對 ''{0}'' 執行清理時出錯\\: {1}
action.Subversion.cleanup.progress.title=Subversion 清理
action.Subversion.integrate.changes.actionname=整合到分支…
action.Subversion.integrate.changes.branch.info.source.label.text=源分支 URL\\: {0}
action.Subversion.integrate.changes.branch.info.target.label.text=目標分支 URL\\: {0}
action.Subversion.integrate.changes.collecting.changes.to.commit.task.title=正在收集要提交的更改
action.Subversion.integrate.changes.description=將選定的更改列表/更改集整合到選定的分支
action.Subversion.integrate.changes.dialog.add.wc.text=新增
action.Subversion.integrate.changes.dialog.remove.wc.text=移除
action.Subversion.integrate.changes.error.unable.to.collect.changes.text=收集要提交的更改時出錯\\: {0}
action.Subversion.integrate.changes.message.another.wc.text=所選目標位於另一個版本庫的工作副本內。仍要繼續?
action.Subversion.integrate.changes.message.files.up.to.date.text=所有檔案均為最新
action.Subversion.integrate.changes.message.not.under.control.text=所選目標不在 Subversio 的控制下。仍要繼續?
action.Subversion.integrate.changes.messages.title=整合到分支
action.Subversion.integrate.changes.progress.integrating.text=正在合併更改
action.Subversion.integrate.changes.select.working.copy.text=整合到工作副本\\:
action.Subversion.integrate.difference.option.use.ancestry.text=使用以前的版本(&U)
action.Svn.RefreshWorkingCopies.description=重新整理工作副本資訊
action.Svn.RefreshWorkingCopies.text=重新整理
action.Svn.Show.Working.Copies.description=顯示工作副本資訊\\: 工作副本格式和 URL
action.Svn.Show.Working.Copies.text=顯示工作副本
action.mark.list.as.merged.description=將所選修訂版標記為已合併，但實際沒有合併
action.mark.list.as.merged.text=標記為已合併
action.mark.list.as.not.merged.description=將所選修訂版標記為未合併，但不會更改 svn\\:mergeinfo 之外的任何內容
action.mark.list.as.not.merged.text=標記為未合併
action.name.configure.branches=組態分支
action.name.ignore.files=新增忽略檔案遮罩
action.name.mark.resolved=標記已解決
action.name.merge.from=合併自
action.name.merge.from.ellipsis=合併自…
action.name.refresh=重新整理
action.name.resolve.conflict=解決衝突
action.name.revert=還原(&R)
action.name.set.property=設定屬性
action.name.show.properties=顯示屬性
action.name.switch=切換
action.name.undo.ignore.files=從忽略列表移除檔名(或遮罩)
action.new.remote.folder.text=新增遠端目錄…
action.repository.browser.history.description=顯示歷史記錄
action.repository.browser.history.text=顯示歷史記錄
action.share.whole.project.text=共享專案(Subversion)…
action.text.annotate=註解
action.title.select.configuration.directory=更改組態目錄
add.files.errors.title=新增檔案時出錯
annotation.original.revision=原始修訂
annotation.show.merge.sources.default.text=在歷史記錄和註解中顯示合併原始碼
browse.changes.settings.stop.on.copy=複製時停止(&S)
button.copy=複製
button.keep=保留
button.load.quantity=載入 +{0}
button.merge.all=全部合併
button.merge.selected=合併所選內容
button.move=移動
button.resolve.conflict.accept.theirs=接受他們的更改
button.resolve.conflict.accept.yours=接受您的更改
button.resolve.conflict.merge=合併
button.select=選擇
button.share=共享
button.text.clear.authentication.cache=清除身份驗證快取(&C)
button.text.deselect.all=取消全選(&D)
button.text.edit.proxies=編輯網絡選項(&O)…
button.text.select.all=全選(&A)
button.text.ssh.accept=是 (_Y)
button.text.ssh.reject=否 (_N)
button.text.ssl.accept=接受(_A)
button.text.ssl.reject=拒絕(_R)
changes.browser.revision.term=修訂
checkbox.auth.keep.for.current.session=儲存憑證(&S)
checkbox.changes.filter.filter.by.author=作者(&U)\\:
checkbox.checkin.auto.update.after.commit=提交後自動更新
checkbox.checkin.keep.files.locked=保持檔案鎖定(&K)
checkbox.checkout=簽出
checkbox.create.tags.branches=建立 /tags 和 /branches
checkbox.force.update=強制更新(&F)
checkbox.ignore.externals=忽略外部項(&E)
checkbox.ignore.whitespace.when.merge.text=&忽略空格
checkbox.include.externals.locations=包括外部項位置
checkbox.include.ignored.resources=包含忽略的資源
checkbox.replace.existing.files=取代現有檔案
checkbox.set.property.update.properties.recursively=遞迴更新屬性(&R)
checkbox.ssl.keep.for.current.session=儲存憑證(&S)
checkbox.svn.ssh.cache.fingerprint=將密鑰新增到 Subversion 快取(&A)
checkbox.switch.to.newly.created.branch.or.tag=將 {0} 切換到新增的分支或標記
checkbox.update.switch.configurable.to.specific.revision=更新/切換到特定版本(&R)\\:
checkbox.update.switch.configurable.try.merge.without.changes=嘗試合併，但不做任何更改(&T)
checkin.different.formats.involved={0,choice,0\\#版本庫|1\\#版本庫} {1} 的選定更改\\n屬於不同格式的 Subversion 工作副本。\\n提交將分為多個提交。\\n\\n您可以在“更改 | Subversion 工作副本資訊”中將所有工作副本轉換為相同格式。\\n是否要繼續提交?
checkin.operation.name=提交(_I)
checkout.dialog.button=檢出
checkout.dialog.title=從 Subversion 簽出
checkout.directory.chooser.prompt=選擇要從 Subversion 簽出的目錄
checkout.directory.chooser.title=簽出目錄
checkout.options.checkout.label=檢出\\:
checkout.options.dialog.title=SVN 簽出選項
checkout.repository=正在簽出版本庫…
checkout.repository.canceled=簽出已取消
checkout.repository.failed=簽出失敗
checkout.repository.tooltip=該專案將在完成簽出後開啟
checkout.stop.message.description=確定要停止簽出 {0} 版本庫嗎?
checkout.stop.message.title=停止簽出
cleanup.action.name=清理
column.name.merge.sources=合併原始碼
column.name.property.name=名稱
column.name.property.value=值
combobox.crlf.none=無
command.line.interactive.mode.description=模擬直接從終端執行 Subversion 指令時的行為(互動模式)。<br>這是處理 svn+ssh 版本庫的密碼/密碼短語提示以及信任 https 版本庫的無效伺服器憑證所必需的。
command.line.interactive.mode.title=啟用互動模式
committed.changes.action.enable.merge.highlighting=醒目提示已整合的更改列表
committed.changes.action.enable.merge.highlighting.description.text=選項僅適用於 SVN 版本庫和 1.5 版本的工作副本
committed.changes.action.merge.highlighting.refresh.description=重新整理合併的修訂資訊
committed.changes.action.merge.highlighting.refresh.text=重新整理
compare.with.branch.diff.title=與分支比較
compare.with.branch.error.title=與分支比較
compare.with.branch.location.error=在分支 ''{1}'' 下找不到檔案 ''{0}'' 的版本庫位置\\n請檢查您的分支組態。
compare.with.branch.popup.title=與分支比較
compare.with.branch.progress.loading.content=載入內容中…
configurable.SvnConfigureProxiesComponent.display.name=HTTP 代理組態
configurable.name.svn.general=Subversion
configurable.name.svn.network=網絡
configurable.name.svn.presentation=表示
configurable.name.svn.ssh=SSH
configure.branches.branch.locations=分支位置\\:
configure.branches.error.wrong.url=主幹位置必須在版本庫根 ''{0}'' 下
configure.branches.title=組態 Subversion 分支
configure.branches.trunk.location=主幹位置\\:
configure.revision.head.radio=HEAD
configure.revision.specified.radio=指定的
confirmation.resolve.tree.conflict.merge.moved=將 {0} 中的更改應用到本地移動的 {1}?
confirmation.resolve.tree.conflict.merge.renamed=將 {0} 中的更改套用到本地重新命名的 {1}?
confirmation.text.add.dir=是否要安排將以下目錄新增到 Subversion?\\n{0}
confirmation.text.add.file=是否要安排將以下檔案新增到 Subversion?\\n{0}
confirmation.text.delete.dir=是否要安排將以下目錄從 Subversion 刪除?\\n{0}\\n注意\\: 提交更改後，該目錄將從磁碟中刪除。
confirmation.text.delete.dir.17=是否要安排將以下目錄從 Subversion 刪除?\\n{0}
confirmation.text.delete.file=是否要安排將以下檔案從 Subversion 刪除?\\n{0}
confirmation.text.delete.stored.authentication.information=您將刪除所有存儲的 Subversion 身份驗證資訊。\\n確定要刪除嗎?
confirmation.text.edit.file=您要編輯的檔案在編輯前需要鎖定
confirmation.title.add.file=新增的時間表
confirmation.title.add.multiple.files=選擇要新增到 Subversion 的檔案
confirmation.title.clear.authentication.cache=清除身份驗證快取
confirmation.title.delete.file=計劃刪除
confirmation.title.delete.multiple.files=選擇要從 Subversion 刪除的檔案
conflict.action.add=新增
conflict.action.delete=刪除
conflict.action.edit=編輯
conflict.action.replace=取代
conflict.operation.merge=合併
conflict.operation.none=無
conflict.operation.switch=切換
conflict.operation.update=更新
conflict.reason.added=新增
conflict.reason.deleted=刪除
conflict.reason.edited=編輯
conflict.reason.missing=缺少
conflict.reason.moved.away=移開
conflict.reason.moved.here=已移到此處
conflict.reason.obstructed=障礙
conflict.reason.replaced=取代
conflict.reason.unversioned=未進行版本管理
copy.column.title=複製
copy.column.tooltip=從 {0} 複製
copy.dialog.title=分支或標籤
delete.files.errors.title=刪除檔案時出錯
dialog.Subversion.select.working.copy.title=組態工作副本路徑
dialog.Subversion.select.working.copy.wcopy.list.title=已知工作副本
dialog.create.branch.or.tag.from.working.copy.warning=<html>使用此變體建立<b>具有本地更改</b>的分支。<br/>通常，不僅是目標目錄，還將有幾個項“帶歷史記錄新增”。<br/><br/>具有與根不同的修訂的各個檔案將被分別複製。<br/>因此，建議先更新工作副本，然後再建立分支。</html>
dialog.description.select.configuration.directory=選擇 Subversion 組態目錄或建立新目錄
dialog.edit.http.proxies.settings.client.certificate.passphrase.text=SSL 用戶端憑證密碼短語(&H)\\:
dialog.edit.http.proxies.settings.connection.timeout.text=連線超時(&I)\\:
dialog.edit.http.proxies.settings.dialog.select.ssl.client.certificate.path.title=選擇憑證路徑
dialog.edit.http.proxies.settings.error.ambiguous.group.patterns.text=找到與多個組符合的版本庫 URL\\: {0}
dialog.edit.http.proxies.settings.error.ambiguous.group.patterns.to.text=URL {0} 符合 {1}
dialog.edit.http.proxies.settings.error.same.group.names.text=檢測到同名的組\\: ''{0}''
dialog.edit.http.proxies.settings.exceptions.text=異常(&X)\\:
dialog.edit.http.proxies.settings.panel.proxy.title=HTTP 代理設定
dialog.edit.http.proxies.settings.panel.repositories.title=版本庫
dialog.edit.http.proxies.settings.panel.ssl.title=SSL 設定
dialog.edit.http.proxies.settings.password.text=密碼(&W)\\:
dialog.edit.http.proxies.settings.paths.to.authority.certificates.text=CA 憑證檔案的逗號分隔的路徑(&P)\\:
dialog.edit.http.proxies.settings.patterns.text=URL 模式(&R)\\:
dialog.edit.http.proxies.settings.port.must.be.number.error=連接埠必須為數字(組 ''{0}'')
dialog.edit.http.proxies.settings.port.text=連接埠(&O)\\:
dialog.edit.http.proxies.settings.seconds.text=秒
dialog.edit.http.proxies.settings.server.text=伺服器(&S)\\:
dialog.edit.http.proxies.settings.ssl.client.certificate.file.text=SSL 用戶端憑證檔案(&C)\\:
dialog.edit.http.proxies.settings.tab.edit.system.file.title=系統檔案
dialog.edit.http.proxies.settings.tab.edit.user.file.title=使用者檔案
dialog.edit.http.proxies.settings.test.connection.button.text=測試連線(&T)
dialog.edit.http.proxies.settings.test.connection.error.title=連線測試失敗
dialog.edit.http.proxies.settings.test.connection.settings.will.be.stored.text=設定將被儲存
dialog.edit.http.proxies.settings.test.connection.settings.will.be.stored.title=警告
dialog.edit.http.proxies.settings.test.connection.success.text=連線測試成功
dialog.edit.http.proxies.settings.test.connection.success.title=連線測試成功
dialog.edit.http.proxies.settings.timeout.must.be.number.error=HTTP 超時必須為數字(組 ''{0}'')
dialog.edit.http.proxies.settings.trust.default.cas.text=信任預設 CA(&A)
dialog.edit.http.proxies.settings.user.text=使用者(&U)\\:
dialog.message.accept.theirs.for.path=接受他們對 {0} 的更改?
dialog.message.accept.yours.for.path=接受您對 {0} 的更改?
dialog.message.branch.name.is.empty=分支名稱為空
dialog.message.can.not.detect.repository.root.for.url=無法檢測 URL 的版本庫根\\: {0}
dialog.message.confirm.move.folder=您即將移動名稱為 ''{0}'' 的目錄。是否確定?
dialog.message.could.not.parse.url=無法解析 url
dialog.message.error.relocating.working.copy=重定位工作副本時出錯\\: {0}
dialog.message.integrate.changes.error.no.available.files=沒有可用於整合的檔案
dialog.message.integrate.changes.error.not.versioned=無法啟動整合\\: 目標目錄不在 Subversion 控制下或不屬於所選分支。
dialog.message.integrate.changes.error.same.source.and.target=無法啟動整合\\: 目標分支和源分支相同。
dialog.message.integrate.changes.error.target.not.dir=無法啟動整合\\: 目標目錄不存在或不是目錄。
dialog.message.invalid.branch.name=分支名稱無效
dialog.message.invalid.branch.url=分支 url 無效
dialog.message.invalid.repository.location=版本庫位置無效
dialog.message.invalid.revision=修訂無效
dialog.message.invalid.working.copy.root=無效的工作副本根\\: {0}
dialog.message.keep.newly.created.files.in.their.original.place=在其初始位置保留新增檔案?
dialog.message.mark.tree.conflict.resolved.confirmation=是否要將樹衝突標記為已解決?
dialog.message.merge.confirm.reintegrate=您將重新整合更改。<br><br>此舉將導致分支 ''{0}'' <b>不能再用於進一步的處理</b>。<br>此分支既無法正確吸收新的主幹({1})更改，<br>也無法正確地重新整合到主幹。<br> <br>確定嗎?
dialog.message.merge.from.theirs.create.binary.file=(根據其更改)建立二進制檔案 {0}?
dialog.message.merge.from.theirs.delete.binary.file=(根據其更改)刪除二進制檔案 {0}?
dialog.message.merge.from.theirs.modify.binary.file=(根據其更改)對二進制檔案 {0} 套用更改?
dialog.message.merge.intersects.with.local.changes.prompt=存在與合併更改衝突的本地更改。\\n是否要繼續?
dialog.message.merge.potentially.intersects.with.local.changes.prompt=存在與合併更改有可能相交的本地更改。\\n是否要繼續?
dialog.message.merge.with.switched.paths.in.working.copy=工作副本中有一些切換的路徑。是否要繼續?
dialog.message.no.branch.base.location.selected=未選擇分支基位置
dialog.message.repository.path.does.not.exist=版本庫路徑 ''{0}'' 不存在。要建立它嗎?
dialog.message.select.binary.files.to.patch=選擇要打補丁的二進制檔案
dialog.message.set.working.copy.infinity.depth=您將以 ''infinity'' 深度簽出到 ''{0}''。\\n您的工作副本也將隨之更新為 HEAD 修訂。
dialog.message.share.to.not.empty.directory=遠端目錄“{0}”非空。\\n是否要繼續共享?
dialog.message.switch.target.not.copy.current=切換目標 URL 不是當前副本。\\n是否要繼續?
dialog.message.target.file.already.exists=目標檔案已經存在
dialog.show.svn.map.title=Subversion 工作副本資訊
dialog.title.authentication.required=需要身份驗證
dialog.title.branch=建立分支或標記
dialog.title.can.not.invoke.action=無法呼叫 {0}
dialog.title.changes.in.url={0} 中的更改
dialog.title.check.out=從 Subversion 簽出
dialog.title.commit.will.split=Subversion\\: 提交將進行拆分
dialog.title.computing.difference=正在計算差異
dialog.title.convert.working.copy.format=轉換工作副本格式
dialog.title.destination.directory=目標目錄
dialog.title.edit.http.proxies.settings=編輯與網絡層相關的 Subversion 選項
dialog.title.error=錯誤
dialog.title.export.directory=匯出目錄
dialog.title.import.directory=匯入目錄
dialog.title.integrate.to.branch=整合到分支
dialog.title.lock.file=鎖定檔案
dialog.title.lock.files=鎖定檔案
dialog.title.mark.resolved=標記已解決
dialog.title.mark.tree.conflict.resolved=將樹衝突標記為已解決
dialog.title.merge.from.branch=合併自 {0}
dialog.title.new.remote.folder=新增遠端目錄
dialog.title.relocate.working.copy=重新定位工作副本
dialog.title.resolve.tree.conflict=解決樹衝突
dialog.title.save.unified.diff=補丁檔案
dialog.title.select.configuration.directory=選擇組態目錄
dialog.title.select.merge.variant=選擇合併變體
dialog.title.select.path.to.subversion.executable=Subversion
dialog.title.select.repository.location=選擇版本庫位置
dialog.title.select.share.target=選擇共享目標
dialog.title.select.target.for.external=選擇用於外部的目標
dialog.title.select.working.copy.location=選擇工作副本位置
dialog.title.set.property=設定屬性
dialog.title.set.working.copy.infinity.depth=設定工作副本無限深度
dialog.title.ssh.examine.server.fingerprints=驗證伺服器密鑰指紋
dialog.title.ssh.settings.browse.executable=SSH 可執行檔案
dialog.title.ssh.settings.browse.private.key=私鑰
dialog.title.ssl.examine.server.crertificate=檢查伺服器憑證
dialog.title.svn.delete=SVN 刪除
dialog.title.svn.export.options=SVN 匯出選項
dialog.title.svn.import.options=SVN 匯入選項
dialog.title.svn.keywords=SVN 關鍵字
dialog.title.svn.properties.diff=SVN 屬性差異
dialog.title.svn.repository.browser=SVN 版本庫瀏覽器
dialog.title.switch.target.problem=切換目標問題
dialog.upgrade.wcopy.format.title=Subversion 工作副本格式
diff.cant.get.properties.changes=無法顯示 SVN 屬性
diff.options.checkbox.reverse.diff=反轉差異
diff.options.label.compare=比較\\:
diff.options.label.compare.type=比較類型
diff.options.label.with=與\\:
diff.options.no.patch.file.error=請指定儲存補丁檔案的路徑
diff.options.no.url.error=請選擇一個 URL 進行比較
diff.options.radio.graphical.compare=圖形比較
diff.options.radio.unified.diff=統合差異
diff.options.same.url.error=請選擇其他 URL 進行比較
diff.options.title=與分支或標記比較
error.authentication.canceled.for.repository=已對版本庫取消身份驗證\\: {0}
error.can.not.access.file.base.revision.contents.administrative.area.is.locked=無法存取檔案的基礎修訂內容\\: 管理區域已被鎖定
error.can.not.create.directory=無法建立目錄\\: {0}
error.can.not.delete.file=無法刪除檔案\\: {0}
error.can.not.find.file=找不到檔案\\: {0}
error.can.not.find.relative.path.for.path.at.revision=找不到 {0}@{1} 的相對路徑
error.can.not.find.repository.root.for.url=找不到 URL 的版本庫根\\: {0}
error.can.not.find.repository.root.for.url.in.revision=在修訂 {1} 中找不到 URL\\: {0} 的版本庫根
error.can.not.find.url.for.file=找不到檔案的 url\\: {0}
error.can.not.find.working.copy.for.file=找不到檔案的工作副本\\: {0}
error.can.not.get.current.revision.for.path=無法獲取檔案 {0} 的當前修訂
error.can.not.get.last.changed.revision.for.path.please.file.an.issue=無法獲取檔案上次進行的修訂\\: {0}\\n請為此檔案執行 svn info 並提交問題。
error.can.not.load.theirs.content.for.file=無法為檔案 {0} 載入他們的內容
error.can.not.set.property=無法設定屬性\\: {0}
error.cannot.load.revisions=無法載入修訂列表
error.could.not.compare.local.file.and.remote.url.with.executable.for.svn.version=無法將本地檔案和遠端 Url 與 svn {0} 的可執行檔案相比較
error.could.not.determine.revision.number.for.file.and.revision=無法確定檔案 {0} 和修訂 {1} 的修訂號
error.could.not.find.separating.space=找不到分隔空間
error.could.not.find.start.quote=找不到起始引號
error.could.not.get.head.info.for.url=無法獲取 {0} 的標頭資訊
error.could.not.get.info.for.path=無法獲取 {0} 的資訊
error.could.not.get.relative.path.for.parent.and.child=無法獲取 {0} 和 {1} 的相對路徑
error.could.not.get.revision.for.url=無法獲取 {0} 的修訂
error.could.not.get.svn.version=離開程式碼\\: {0}，錯誤\\: {1}
error.could.not.parse.merge.info=無法解析 {0}
error.could.not.parse.svn.version=無法解析 svn 版本\\: {0}
error.file.is.not.under.subversion=檔案 {0} 未受到 Subversion 控制
error.file.is.not.under.version.control=檔案 {0} 未進行版本管理
error.format.is.not.supported=不支持 {0} 格式。支援的格式\\: {1}。
error.integration.was.canceled=整合已被取消
error.invalid.svn.revision=無效的 svn 修訂\\: {0}
error.invalid.url=無效 url\\: {0}
error.latest.existing.revision.found.for.url=已找到 {0} 的最新現有修訂
error.missing.committed.revision.number=缺少提交的修訂號\\: {0}
error.move.have.not.been.performed=尚未執行 Subversion 移動。
error.no.branch.point.found.for.target=找不到 {0} 的分支點
error.parse.file.status.unknown.state.on.line=第 {0} 行的狀態未知
error.properties.loading.for.revision.canceled=已取消為修訂 {0} 載入屬性。
error.revert.failed=還原失敗
error.revision.from.must.be.a.valid.number=“起始修訂”必須為有效數字
error.revision.to.must.be.a.valid.number=“結束修訂”須為有效數字
error.selected.destination.conflicts.with.existing=所選目標與現有目標相衝突\\: {0}
error.server.ssl.certificate.rejected=伺服器 SSL 憑證被拒
error.svn.exited.with.error.code=SVN 程序已離開，錯誤程式碼為\\: {0}
error.svn.status.not.in.working.copy=請求的狀態不在工作副本中\\: {0}
error.svn.status.with.no.output=狀態請求沒有為指令返回任何內容\\: {0}
error.target.not.found.in.paths=在 {1} 中找不到 {0}
error.target.of.move.operation.is.already.under.version.control=移動動作的目標已受到版本控制。
error.url.could.not.contain.fragment={0} 不能包含片段
error.url.could.not.contain.query={0} 不能包含查詢
error.url.is.not.absolute={0} 非絕對
error.url.is.not.hierarchical={0} 非層次結構
error.wrong.committed.revision.number=提交的修訂號錯誤\\: {0}
exception.text.cannot.annotate.directory=註解動作僅對檔案有意義
exception.text.cleanupaction.batchperform.not.implemented=CleanupAction.batchPerform 未實作
exception.text.failed.to.unlock.file=無法解鎖檔案\\: {0}
exception.text.file.miss.svn=檔案 ''{0}'' 為唯讀，但缺少 svn\\:needs-lock 屬性
exception.text.locking.file.failed=無法鎖定檔案\\: {0}
exception.text.root.was.not.properly.updated=svn\\: {0} 未正確更新; 可能是因為它已經與父級一起從版本庫中移除。
exportable.SvnDiffSettings.presentable.name=SVN 差異
file.conflict.property=屬性
file.conflict.text=文本
file.conflict.tree=樹
file.status.external=外部 (svn)
file.status.obstructed=受阻 (svn)
file.status.replaced=取代 (svn)
global.group=全域
group.IgnoreChoicesGroup.text=忽略
group.RevertIgnoreChoicesGroup.text=從忽略列表中移除
group.SubversionFilePopupGroup.text=Subversion(_S)
import.dialog.button=匯入
import.dialog.title=匯入 Subversion
integrate.configuration.description.label=將源之間的差異整合到工作副本中(比較源 2 和源 1)
integrate.configuration.revision1.label=修訂(&V)
integrate.configuration.revision2.label=修訂(&R)
integrate.configuration.source1.label=源 1\\:
integrate.configuration.source2.label=源 2\\:
integrate.display.name=整合
label.after.accepting.theirs.for.path=在接受他們對 {0} 的更改後
label.already.merged=已合併
label.auth.authentication.realm=身份驗證領域\\: ''{0}''
label.auth.password=密碼(&P)\\:
label.auth.user.name=用戶名(&U)\\:
label.before.accepting.theirs.for.path=在接受他們對 {0} 的更改前
label.branch.base.url=基 URL\\:
label.branch.name=名稱\\:
label.changelists.merging.faced.problems=更改列表\\:\\n{0}\\n合併面臨的問題
label.commit.message=提交訊息\\:
label.configure.change.label=將工作副本 ''{0}'' 格式更改為\\:
label.configure.create.label={0} 將要建立新的 Subversion 工作副本，\\n請選擇所需的工作副本格式\\:
label.configure.upgrade.label=工作副本升級策略\\:
label.conflict.directory.added=(目錄)已新增
label.conflict.directory.unversioned=(目錄)未進行版本管理
label.conflict.file.added=(檔案)已新增
label.conflict.file.unversioned=(檔案)未進行版本管理
label.conflict.left.side=左\\: {0}
label.conflict.right.side=右\\: {0}
label.copy.comment=&註釋
label.copy.from=複製自
label.copy.from.revision=修訂(&V)\\:
label.copy.select.location.dialog.copy.as=複製為(&A)\\:
label.copy.to=複製到
label.define.share.target=定義共享目標
label.depth.description=取代舊的“遞迴”選項。“遞迴”為 false 等效於“直接子級”，“遞迴”為 true 等效於“無限”
label.depth.empty=空
label.depth.exclude=排除
label.depth.files=檔案
label.depth.immediates=直接
label.depth.infinity=無限
label.depth.text=深度(&D)\\:
label.depth.unknown=未知
label.destination=目標\\:
label.export=匯出\\:
label.external.copy=外部副本
label.file.has.conflicts=檔案有 {0} 個衝突，無法提交
label.file.has.conflicts.before.and.after=檔案有 {0} 個衝突，無法提交\\n之前\\: {1}\\n之後\\: {2}
label.file.has.conflicts.before.or.after=檔案有 {0} 個衝突，無法提交\\n{1}
label.from.url=源 URL\\:
label.import.from=匯入自\\:
label.import.to=匯入到\\:
label.local.target=本地目標\\:
label.locally.deleted.file.has.conflicts=檔案有 {0} 個衝突
label.lock.comment=鎖定註釋(&L)\\:
label.locl.steal.existing=竊取現有鎖(&S)\\:
label.merge.all.from.branch=合併 {0} 中的全部內容
label.merge.all.from.branch.at.revision=合併 {1} 的 {0} 中的全部內容
label.merge.all.from.branch.at.revision.reintegrate=合併 {1} 的 {0} 中的全部內容(重新整合)
label.merge.all.from.branch.reintegrate=合併 {0} 中的全部內容(重新整合)
label.merge.from.url=從\\:
label.merge.local.changes.intersection=以下檔案具有與合併更改相交的本地更改\\:
label.merge.source.revision=合併原始碼修訂
label.merge.to.branch=到\\:
label.merged.from.branch=已合併自 {0}
label.mixed.revision.working.copy=混合修訂工作副本
label.nested.copy.type.external=外部
label.nested.copy.type.inner=嵌套
label.nested.copy.type.switched=已切換
label.no.subversion.1.5.working.copies=此專案中沒有 1.5 版本庫的 Subversion 1.5 工作副本
label.override.native.eols.with=覆寫 'native' EOL 的選項\\:
label.path.revisions.info={0}(當前\\: {1}，已提交\\: {2})
label.path.to.svn.executable=Subversion 可執行檔案的路徑\\:
label.point.to.repository.location=指向版本庫位置
label.recent.messages=最近的訊息\\:
label.remote.folder.name=遠端目錄名稱\\:
label.remote.folder.url=遠端目錄 URL\\:
label.repositories=版本庫\\:
label.revision=修訂
label.select.checkout.destination.directory=選擇簽出目標目錄
label.select.directory.to.export.from.subversion=選擇要從 Subversion 匯出的目錄
label.select.directory.to.import.into.repository=選擇要匯入版本庫的目錄
label.select.export.destination.directory=選擇匯出目標目錄
label.select.file.to.save.unified.diff=選擇用於存儲統合差異的檔案
label.select.files.and.directories.to.mark.resolved=選擇要標記為已解決的檔案和目錄\\:
label.select.keywords.to.set=選擇要設定的關鍵字\\:
label.select.location.to.copy.from=選擇要從中複製的位置\\:
label.select.path.to.subversion.executable=選擇 Subversion 可執行檔案(1.7+)的路徑
label.select.target.working.copy=選擇目標工作副本的路徑
label.set.property.property.name=屬性名稱(&N)\\:
label.skipped.changelists=已跳過的更改列表\\: {0}
label.source.url=源 URL\\:
label.specify.ssl.protocol.manually=請嘗試手動指定 SSL 協議 - SSLv3 或 TLSv1
label.ssh.key.file=密鑰檔案(&F)\\:
label.ssh.passphrase=密碼短語(&R)\\:
label.ssh.server.provided.fingerprints=無法建立主機 {0} 的驗證。
label.ssh.server.provided.fingerprints2={0} 密鑰指紋為
label.ssh.server.provided.fingerprints3=確定要繼續連線嗎?
label.ssl.certificate.password=憑證密碼短語\\:
label.ssl.certificate.path=憑證路徑\\:
label.ssl.server.provided.certificate=伺服器提供了以下憑證\\:
label.svn.phantom.change=技術記錄
label.svn.properties.changed=SVN 屬性已更改
label.switched.copy=已切換副本
label.target.location=目標位置\\:
label.target.name=目標名稱\\:
label.target.url=目標 URL\\:
label.text.delete.stored.credentials=刪除 'http'、'svn' 和 'svn+ssh' 協議的所有已存儲憑證
label.to.url=目標 URL\\:
label.update.switch.to.revision=更新/切換到修訂\\:
label.update.url=URL\\:
label.working.copy=工作副本
label.working.copy.depth=深度\\:
label.working.copy.format=格式\\:
label.working.copy.format.unknown=未知
label.working.copy.root=工作副本根
label.working.copy.root.outside.text=工作副本根位於“專案設定”中指定的目錄外部。\\n整個工作副本將被轉換。
label.working.copy.url=URL\\:
link.change.format=更改
link.fix.depth=修正
merge.chunk.changelist.description={0} [來自於修訂 {1}]
merge.source.details.title=合併 {0} [{1}] 的原始碼詳細資訊
message.text.cannot.checkout=無法從 svn 簽出\\: {0}
message.text.cannot.export=無法從 svn 匯出\\: {0}
message.text.cannot.import=無法匯入 svn\\: {0}
message.text.cannot.load.supported.formats=無法載入支援的格式\\: {0}
message.text.files.lock.failed={0,choice, 0\\#無法鎖定檔案。|1\\#無法鎖定檔案。}
message.text.files.locked={0,choice, 0\\#無法鎖定檔案。|1\\#已鎖定 1 個檔案|2\\#已鎖定 {0,number} 個檔案}
message.text.files.unlocked={0,choice, 0\\#無法解鎖檔案。|1\\#已解鎖 1 個檔案|2\\#已解鎖 {0,number} 個檔案}
message.text.no.conflicts.found=未找到衝突
message.text.update.no.directories.found=找不到要更新的版本管理目錄
message.theirs.accepted.for.file=已接受他們對 {0} 的更改
message.theirs.changes.merged.for.file=已針對 {0} 合併他們的更改
message.title.export=從 Subversion 匯出
message.title.import=匯入 Subversion
message.title.no.conflicts.found=無衝突
message.title.unlock.failures=解鎖失敗
message.yours.accepted.for.file=已接受您對 {0} 的更改
messate.text.update.error=SVN\\: 更新錯誤
move.dialog.title=移動或重新命名
move.files.errors.title=移動檔案時出錯
navigate.to.idea.proxy.settings=導覽到一般代理設定
no.differences.between.sources.error.message=源和相同源之間沒有區別
non.english.locale.detected.warning=使用了非英語區域設定。
notification.action.click.to.fix=點擊以修正。
notification.content.authentication.failed=身份驗證失敗\\: {0}
notification.content.branches.load.error=分支載入錯誤\\: {0}
notification.content.can.not.access.working.copy.database=存取 svn 工作副本資料庫時發生了若干錯誤。
notification.content.can.not.merge.from.self=無法自我合併
notification.content.everything.is.up.to.date=所有內容都已處於最新狀態
notification.content.merge.start.was.not.found=找不到合併起始點
notification.content.multiple.roots.unsupported.format=某些根的格式可能是不受支援的 Subversion 格式
notification.content.not.logged.into.subversion=未登錄到 Subversion ''{0}'' ({1})
notification.content.revision.commit.message.changed.to=修訂 \\#{0} 註釋更改為\\:\\n''{1}''
notification.content.single.root.unsupported.format=根 ''{0}'' 可能是不受支援的 Subversion 格式
notification.content.unknown.certificate.type.from.url=Subversion\\: {0} 中的憑證類型未知
notification.group.svn.roots=Subversion 根檢測失敗
notification.title.not.logged.into.subversion=未登錄到 Subversion
operation.merge=合併
popup.content.already.checking=正在檢查…
popup.content.failed.to.authenticate.to.proxy=代理驗證失敗。
popup.content.failed.to.authenticate.to.proxy.change.credentials=代理驗證失敗。您可以在 HTTP 代理設定中更改代理憑證。
popup.title.select.branch=選擇分支
popup.title.select.branch.to.integrate.to=選擇要整合到的分支…
progres.text2.merged=已合併 {0}
progres.text2.updated=已更新 {0}
progres.text2.updated.to.revision=已更新至修訂 {0}。
progress.details.merging.changelist.range=正在合併更改列表 {0}
progress.details.upgraded.path=已升級路徑 {0}
progress.live.provider.loading.revisions.details.text=正在從伺服器載入修訂…
progress.live.provider.loading.revisions.text=正在從伺服器載入修訂
progress.message.connecting.to.url=正在連線到 {0}
progress.searching.for.files.with.conflicts=正在搜尋有衝突的檔案
progress.text.browser.copying=正在拷貝{0}
progress.text.browser.creating=正在建立 {0}
progress.text.browser.moving=正在移動 {0}
progress.text.browser.remote.destination=到 {0}
progress.text.changes.collecting.changes=正在收集有關更改的資訊
progress.text.checking.out=正在將檔案簽出到 ''{0}''
progress.text.clearing.stored.credentials=正在清除 {0} 中存儲的憑證
progress.text.collecting.merge.information=正在收集合併資訊
progress.text.collecting.not.merged.revisions=正在收集未合併的修訂
progress.text.computing.annotation=正在計算 ''{0}'' 的註解
progress.text.converting.working.copy.format=將 {0} 格式的工作副本從 {1} 轉換為 {2}
progress.text.copy.to=複製到 ''{0}''
progress.text.create.remote.folder=建立遠端目錄
progress.text.deleting=正在刪除 {0}
progress.text.export=正在將檔案匯出到 ''{0}''
progress.text.import=匯入 {0}
progress.text.loading.contents=正在載入 ''{0}'' 的內容
progress.text.locking.files=正在鎖定版本庫中的檔案…
progress.text.merging.changes=正在將更改合併到 ''{0}''
progress.text.merging.dry.run.changes=正在將(dry run)更改合併到 ''{0}''
progress.text.performing.path.cleanup=正在執行 ''{0}'' 清理…
progress.text.unlocking.files=正在解鎖版本庫中的檔案…
progress.text.updating=正在更新 ''{0}''
progress.text.updating.external.location=正在更新 ''{0}'' 的外部位置
progress.text2.added=已新增 {0}
progress.text2.adding=正在新增 ''{0}''
progress.text2.changes.establishing.connection=正在建立與 ''{0}'' 的連線
progress.text2.checked.out=已簽出 {1} 個檔案，正在簽出 {0}
progress.text2.checked.out.revision=已簽出修訂 {0}。
progress.text2.collecting.history=正在收集 ''{0}'' 的修訂歷史記錄
progress.text2.conflicted={0} 存在衝突
progress.text2.deleted=已刪除 {0}
progress.text2.deleting=正在刪除 ''{0}''
progress.text2.exported=已匯出 {1} 個檔案，正在匯出 {0}
progress.text2.exported.revision=已匯出修訂 {0}。
progress.text2.fetching.external.location=正在獲取 ''{0}'' 的外部位置
progress.text2.processing.file=正在處理檔案 {0}
progress.text2.processing.revision=正在處理修訂 ''{0}''
progress.text2.replacing=正在取代 ''{0}''
progress.text2.restored.file=已還原 {0}
progress.text2.revision.information=修訂{0}
progress.text2.revision.processed=已處理修訂 ''{0}''
progress.text2.sending=正在發送 ''{0}''
progress.text2.skipped.file=已跳過 {0}
progress.text2.transmitting.delta=正在傳輸 ''{0}'' 的增量
progress.text2.treeconflicted=已衝突 {0}(樹衝突)
progress.title.accepting.theirs.for.path=正在接受他們對 {0} 的更改
progress.title.accepting.working.state=正在接受工作狀態
progress.title.accepting.yours.for.path=為之接受您的更改\\: {0}
progress.title.adding.file.to.subversion=正在將 {0} 新增到 Subversion
progress.title.adding.files.to.subversion=正在向 Subversion 新增檔案
progress.title.applying.binary.changes=正在套用二進制更改
progress.title.browser.copy=複製
progress.title.browser.delete=刪除
progress.title.browser.move=移動
progress.title.calculating.copy.revision=正在計算副本修訂
progress.title.check.out=從 Subversion 簽出
progress.title.check.out.cancel=停止從 Subversion 簽出
progress.title.check.remote.folder.contents=檢查遠端目錄內容
progress.title.checking.repository.capabilities=正在檢查版本庫容量
progress.title.checking.target.folder=正在檢查目標目錄
progress.title.cleanup.project=清理專案
progress.title.clear.authentication.cache=清除身份驗證快取(&C)
progress.title.commit=提交
progress.title.convert.working.copy.format=轉換工作副本格式
progress.title.copy=Subversion 副本
progress.title.creating.external=正在建立外部
progress.title.creating.patch.for.theirs.changes=正在為其更改建立更新檔
progress.title.deleting.files.from.subversion=正在從 Subversion 中刪除檔案
progress.title.detecting.repository.root=正在檢測版本庫根
progress.title.edit.revision.comment=編輯修訂註釋
progress.title.filtering.branch.revisions=正在篩選 {0} 修訂
progress.title.getting.base.and.theirs.revisions.content=獲取基本內容及其修訂內容
progress.title.getting.latest.repository.revision=正在獲取最新的版本庫修訂
progress.title.loading.branches=正在載入分支
progress.title.loading.change.details=正在載入更改詳細資訊
progress.title.loading.child.entries=正在載入子條目
progress.title.loading.file.content=正在載入遠端檔案內容
progress.title.loading.file.properties=正在載入遠端檔案屬性
progress.title.loading.recent.branch.revisions=正在載入最近的 {0} 修訂
progress.title.loading.tree.conflict.details=正在載入樹衝突詳細資訊
progress.title.loading.working.copies.data=Subversion\\: 正在載入工作副本資料…
progress.title.lock.files=鎖定檔案
progress.title.looking.for.branch.origin=正在尋找分支來源
progress.title.looking.for.file.working.copy.root=正在尋找 ''{0}'' 工作副本根
progress.title.mark.tree.conflict.resolved=將樹衝突標記為已解決
progress.title.merging.all.from.branch=正在合併 {0} 中的全部內容
progress.title.merging.all.from.branch.reintegrate=正在合併 {0} 中的全部內容(重新整合)
progress.title.moving.files.in.subversion=正在移動 Subversion 中的檔案
progress.title.relocating.working.copy=正在重定位工作副本
progress.title.resolve.tree.conflict=解決樹衝突
progress.title.share.directory=共享目錄
progress.title.shelving.local.changes.before.merge=正在擱置合併前的本地更改
progress.title.svn.branches.preloader=Subversion 分支預載入程序
progress.title.svn.roots.authorization.checker=SVN VCS 根授權檢查器
progress.title.test.connection=測試連線
progress.title.unlock.files=解鎖檔案
quick.merge.variants.merge.all=全部合併
quick.merge.variants.merge.all.explanation=所有未合併的修訂將被合併。\\nSubversion 將使用本地副本中記錄的 svn\\:mergeinfo 屬性尋找未合併的修訂。
quick.merge.variants.pre.select=通過預篩選選擇
quick.merge.variants.pre.select.explanation=尋找涉及的一個分支複製自另一個分支的位置。\\n僅載入尚未合併的修訂以供選擇。執行可能需要很長時間。
quick.merge.variants.quick.select=快速手動選擇
quick.merge.variants.quick.select.explanation=顯示來自目標分支、已合併和未合併分支的所有修訂。\\n用於手動選擇。快速獲取結果。
radio.configure.change.auto.16format=1.6 格式(&6)
radio.configure.change.auto.17format=1.7 格式(&7)
radio.configure.change.auto.18format=1.8 格式(&8)
radio.configure.create.auto.16format=1.6 格式(&6)
radio.configure.create.auto.17format=1.7 格式(&7)
radio.configure.create.auto.18format=1.8 格式(&8)
radio.configure.upgrade.auto.16format=自動升級(使用 Subversion 1.6)(&6)
radio.configure.upgrade.auto.17format=自動升級(使用 Subversion 1.7)(&7)
radio.configure.upgrade.auto.18format=自動升級(使用 Subversion 1.8)(&8)
radio.copy.repository.location=版本庫位置(&R)\\:
radio.copy.to.any.location=任何位置
radio.copy.to.branch.or.tag=分支或標籤
radio.copy.working.copy=工作副本(&W)
radio.set.property.delete.property=刪除屬性(&D)
radio.set.property.set.property.value=設定屬性值(&S)\\:
radio.share.target.at.selected.repository.location=在所選版本庫位置
radio.share.target.in.new.folder=在所選版本庫位置的新“{0}”目錄中
refresh.branches.item=重新整理分支…
repository.browser.add.location.action.description=新增版本庫位置
repository.browser.add.location.action.text=新增版本庫位置
repository.browser.add.location.menu.item=版本庫位置(_R)…
repository.browser.add.location.prompt=版本庫 URL\\:
repository.browser.add.location.title=新增版本庫位置
repository.browser.browse.changes.action=瀏覽更改(_B)…
repository.browser.browse.changes.description=檢視選定節點中的更改歷史記錄
repository.browser.compare.title=比較 ''{0}'' 和 ''{1}''
repository.browser.details.action=顯示/隱藏詳細資訊
repository.browser.discard.location.action=捨棄位置(_L)
repository.browser.discard.location.prompt=要捨棄位置 ''{0}'' 嗎?
repository.browser.discard.location.title=捨棄位置
repository.browser.edit.location.dialog.title=編輯位置 URL
repository.browser.edit.location.menu.item=編輯位置 URL(_U)…
repository.browser.import.action=匯入(_I)…
repository.browser.new.folder.action=遠端目錄(_F)…
repository.browser.no.locations.added.info=未新增版本庫位置。
repository.browser.refresh.action=重新整理選定樹節點
revision.title=修訂
select.location.invalid.url.message=無效的 Subversion 版本庫 URL\\: ''{0}''
separator.commit.comment.prefix=提交註釋前綴
separator.property.changes=屬性更改
server.ssl.accept.temporary.action.name=接受臨時(_T)
settings.HTTP.timeout=HTTP 超時\\:
settings.SSH.connection.timeout=SSH 連線超時\\:
settings.SSH.read.timeout=SSH 讀取超時\\:
settings.check.mergeinfo=準備合併時檢查目標子樹中的 svn\\:mergeinfo
settings.edit.servers.subversion.runtime.configuration.file=編輯 'servers' Subversion 執行時組態檔案
settings.maximum.revisions.number=註解中可回顧的最大修訂數\\:
settings.seconds=秒
settings.ssl.protocols=SSL 協議\\:
settings.ssl.protocols.all=所有
settings.ssl.protocols.all.tlsv1=TLSv1
settings.ssl.protocols.sslv3=SSLv3
settings.use.custom.directory=使用自訂組態目錄(&U)\\:
share.directory.action=共享目錄…
share.directory.checkout.back.progress.text=正在簽出 {0}
share.directory.commit.message={2}\\n{1} 建立的目錄 ''{0}''
share.directory.create.dir.progress.text=正在建立遠端目錄 {0}
share.directory.info.message=要完成共享動作，請提交 ''{0}''。
share.directory.title=共享目錄
share.or.import.add.progress.text=正在排定 {0} 的新增時間表
show.properties.diff.progress.text.revision.information=修訂{0}
show.properties.diff.progress.text2.property.information=屬性 {0}
source.url.could.not.be.empty.error.message=源 URL 不能為空
ssh.settings.executable.label=SSH 可執行檔案\\:
ssh.settings.password.choice.title=密碼
ssh.settings.port.label=連接埠\\:
ssh.settings.private.key.choice.title=私鑰
ssh.settings.private.key.path.label=路徑\\:
ssh.settings.subversion.config.choice.title=Subversion 組態
ssh.settings.tunnel.label=SSH 隧道\\:
ssh.settings.update.tunnel.title=更新
ssh.settings.user.name.label=用戶名\\:
status.group.name.replaced=已取代
status.text.checked.out.revision=已簽出修訂 {0}。
status.text.committed.revision=提交的修訂 {0}。
status.text.merge.sources=合併原始碼
status.text.updated.to.revision=已更新至修訂 {0}。
subversion.executable.notification.cant.run.in.safe.mode=無法在安全模式下執行 Svn 指令
subversion.executable.notification.description=Subversion 可執行檔案的路徑可能是錯誤的。
subversion.executable.notification.title=無法使用 Subversion 命令行用戶端
subversion.executable.too.old=Subversion 命令行用戶端版本過舊({0})。
subversion.roots.detection.errors.found.action.text=修復
subversion.roots.detection.errors.found.description=檢測 Subversion 工作副本時發現錯誤。
svn.cannot.save.credentials.store-auth-creds=無法存儲憑證\\: “store-auth-creds \\= no”禁止
svn.edit.commit.message.attention=注意\\! 以前的訊息將丟失\\!
svn.edit.commit.message.prompt=新修訂註釋\\:
svn.edit.commit.message.title=編輯修訂 \\#{0} 註釋
svn.integrate.changelist.warning.unresolved.conflicts.text=整合中斷。存在未解決的衝突或跳過的項。
svn.name.with.mnemonic=Subversion(_S)
svn.option.ignore.whitespace.in.annotate=忽略註解中的空格差異
svn.phantom.changes.viewer=SVN 模擬更改檢視器
svn.properties.viewer=SVN 屬性檢視器
svn.short.name.with.mnemonic=SVN(_S)
svn.tree.conflict.viewer=SVN 樹衝突檢視器
tab.repository.merge.panel.filter.minus=篩選出未整合項
tab.repository.merge.panel.filter.others=篩選出其他
tab.repository.merge.panel.filter.plus=篩選出整合項
tab.title.create.external=建立外部
tab.title.edit.revision.comment=編輯修訂註釋
tab.title.failed.to.share.project=無法共享專案
tab.title.merge.local.changes.intersection={0}，本地更改相交
text.svn.phantom.change=已記錄此更改，因為其目標檔案被刪除，\\n並且某些父目錄已複製(或移動)到新位置。
tooltip.revision.number.message=修訂 {0}\\: {1}
tooltip.use.project.location=使用專案位置
toolwindow.stripe.SVN_Properties=SVN 屬性
toolwindow.stripe.SVN_Repositories=SVN 版本庫
toolwindow.working.copies.info.title=Subversion 工作副本資訊
tree.conflict.description=本地 {0}，{2} 時傳入 {1}
undo.integrate.to.branch=撤消整合到分支…
undo.integrate.to.branch.description=從分支中移除修訂中所做的更改
undo.integrate.to.branch.dialog.title=撤消整合到分支
update.configuration.specific.url=更新/切換到特定 URL(&U)\\:
update.switch.configurable.name=更新/切換
update.switch.to.branch.text=使用分支\\:
use.idea.proxy.as.default=將 {0} 一般代理設定用作 Subversion 的預設設定
use.idea.proxy.as.default.label.text=只有 HTTP 代理可以用作預設設定
value.new.branch.name=new_branch
value.new.folder.name=NewFolder
value.new.server.group.name=未命名
value.patch.file.name=TheirsChanges.patch
"
`;

exports[`dev messages/VcsBundle.properties 1`] = `
"ChangesBrowserToolWindow.toolwindow.name=更改
RepositoryBrowser.toolwindow.name=版本庫
action.AnActionButton.text.add.jira.pattern=新增 JIRA 模式
action.AnActionButton.text.add.youtrack.pattern=新增 YouTrack 模式
action.Anonymous.text.remove.all.leading.directories=移除所有前導目錄
action.Anonymous.text.restore.all.leading.directories=還原所有前導目錄
action.ChangesView.ShowIgnored.description=顯示忽略的檔案
action.ChangesView.ShowIgnored.text=已忽略的檔案
action.DumbAware.ApplyPatchDifferentiatedDialog.description.refresh=重新整理
action.DumbAware.ApplyPatchDifferentiatedDialog.text.refresh=重新整理
action.DumbAwareAction.text.compare.with.local.content=與本地內容比較
action.ImportIntoShelfAction.description=將補丁檔案複製到擱置
action.ImportIntoShelfAction.text=匯入更新檔…
action.NotificationAction.AllVcses.text.install=安裝
action.NotificationAction.AllVcses.text.open.plugin.page=開啟“延伸模組”頁面
action.NotificationAction.AllVcses.text.read.more=閱讀更多
action.NotificationAction.InactiveRangesDamagedNotification.text.view.changes=檢視更改…
action.NotificationAction.VFSListener.text.view.files=檢視檔案…
action.NotificationAction.VcsRootProblemNotifier.text.configure=組態…
action.NotificationAction.VcsRootProblemNotifier.text.enable.integration=啟用整合
action.NotificationAction.VcsRootProblemNotifier.text.ignore=忽略
action.SearchFieldAction.text.find=尋找\\: 
action.ShowAffectedFilesAction.show.affected.files.text=顯示受影響的檔案
action.ToggleAction.description.show.details=顯示詳細資訊面板
action.ToggleAction.text.preview.diff=預覽差異
action.ToggleAction.text.scope.filter=作用域篩選器
action.ToggleAction.text.show.details=顯示詳細資訊
action.Vcs.Commit.CloseDialog.text=關閉提交對話框
action.Vcs.Toolbar.QuickListPopupAction.text=VCS 動作
action.amend.commit.anyway.text=仍然修正
action.annotate.previous.revision.text=註解之前的修訂
action.annotate.revision.text=註解修訂
action.annotate.selected.revision.in.new.tab.description=在新頁籤中註解所選修訂
action.annotate.show.diff.preview.on.hover.text=懸停時顯示差異
action.annotate.successor.selected.revision.in.new.tab.description=在新頁籤中註解所選修訂的後繼者
action.clone.dialog.stub.click.to.continue=點擊“{0}”繼續
action.commit.anyway.text=仍然{0}
action.description.compare=比較版本
action.description.create.patch.for.selected.revisions=為所選修訂建立更新檔
action.description.refresh=重新整理檔案歷史記錄
action.description.refresh.compare.with.local.panel=重新整理更改
action.display.name.check.scope.status=檢查{0}狀態
action.display.name.integrate.scope=整合{0}
action.display.name.update=更新
action.display.name.update.scope=更新{0}
action.enable.version.control.integration.text=啟用版本控制整合(_E)…
action.filter.filter.by.text=篩選依據
action.filter.moved.files.text=已移動且無更改
action.filter.non.important.files.text=包含不重要的更改
action.filter.separator.text=隱藏檔案
action.for.file.with.dialog.text={0}{1, choice, 1\\#檔案|2\\#檔案}…
action.import.to.shelf=匯入到 Shelf
action.message.use.selected.changes.description={0}所選更改
action.name.check.scope.status=檢查{0}狀態(_K)
action.name.check.status=檢查狀態(_K)
action.name.checkin.directory={0}{1,choice,1\\#目錄|2\\#目錄}
action.name.checkin.file={0}{1,choice,1\\#檔案|2\\#檔案}
action.name.compare=比較
action.name.create.patch=建立更新檔…
action.name.get.file.content.from.repository=從修訂中獲取
action.name.group.by.packages=按軟體套件分組
action.name.integrate=合併 (_G)
action.name.integrate.scope=合併 {0}(_G)
action.name.refresh=重新整理
action.name.refresh.compare.with.local.panel=重新整理
action.name.show.difference=顯示差異
action.name.show.files.as.tree=作為樹顯示
action.name.show.history.for.class=類別
action.name.show.history.for.code.block=程式碼塊
action.name.show.history.for.field=欄位
action.name.show.history.for.function=函式
action.name.show.history.for.method=方法
action.name.show.history.for.selection=選區
action.name.show.history.for.statement=語句
action.name.update=更新(_U)
action.name.update.scope=更新{0}(_U)
action.presentation.ApplySelectedChangesAction.text=接受
action.presentation.DiffShelvedChangesWithLocalActionProvider.description=將擱置版本與當前版本進行比較
action.presentation.IgnoreSelectedChangesAction.text=忽略
action.presentation.ShowUpdatedDiffActionProvider.description=更新前顯示與版本的差異
action.vcs.log.show.separator=顯示
activity.name.amend.message=修正提交\\: {0}
activity.name.apply.patch=套用補丁
activity.name.commit=提交更改
activity.name.commit.message=提交更改\\: {0}
activity.name.get=從 VCS 獲取
activity.name.get.from=從 {0} 獲取
activity.name.rollback=復原
activity.name.shelve=擱置更改
activity.name.unshelve=取消擱置
activity.name.update=從 VCS 更新
acton.name.get.revision=獲取修訂
add.issue.dialog.invalid.regular.expression=無效的正則表達式\\: {0}
add.issue.dialog.issue.example.border.title=範例
add.issue.dialog.issue.id.label=問題 ID\\:
add.issue.dialog.issue.id.regular.expression=問題 ID (正則表達式)\\:
add.issue.dialog.issue.link.label=問題連結\\:
add.issue.dialog.issue.link.replacement.expression=問題連結 (取代表達式)\\:
add.issue.dialog.issue.no.match=<無符合>
advanced.setting.vcs.annotations.preload=在編輯器中開啟檔案時載入 VCS 中的檔案註解
advanced.setting.vcs.annotations.preload.description=這樣就可以更快速地按需顯示。
advanced.setting.vcs.commit.tool.window=啟用“提交”工具視窗
advanced.setting.vcs.commit.tool.window.description=在單獨的“提交”工具視窗中顯示“本地更改”和“擱置”頁籤
advanced.setting.vcs.non.modal.commit.toggle.ui=切換提交控件
advanced.setting.vcs.non.modal.commit.toggle.ui.description=執行提交後隱藏提交面板和複選框，並允許在“本地更改”中切換提交 UI
advanced.setting.vcs.process.ignored=醒目提示忽略的檔案
advanced.setting.vcs.process.ignored.description=請求 VCS 中被忽略檔案的列表，並在 IDE 中顯示這些檔案的狀態
advanced.setting.vcs.push.all.with.commits=選擇包含要推送的新提交的所有版本庫
advanced.setting.vcs.push.all.with.commits.description=預設預先選擇包含要推送的提交的所有版本庫
advanced.settings.vcs=版本控制
amend.action.name=修正{0}
amend.commit.different.committer.warning=修正後提交的提交者與預設設定不同
amend.commit.load.details.task.title=正在載入提交詳細資訊
amend.commit.load.message.error.text=無法載入待修正提交的提交訊息。
amend.commit.load.message.error.title=提交訊息未載入
amend.commit.load.message.task.title=正在載入提交訊息
amend.commit.tree.node.loading=正在載入修正的提交…
annotate.action.description=註解檔案
annotate.action.name=註解
annotate.action.view.group.text=檢視
annotation.background=註解背景
annotation.commit.number=提交編號
annotation.original.revision.text=修訂\\: {0}
annotation.switch.to.merged.text=顯示合併原始碼
annotation.switch.to.original.text=隱藏合併原始碼
annotation.wrong.line.number.notification.text=<html>由 {0} 註解的行數與檔案中的行數不相等。請檢查檔案編碼和行分隔符。</html>
annotations.color.mode.author=作者
annotations.color.mode.group.colors=顏色
annotations.color.mode.hide=隱藏
annotations.color.mode.order=順序
annotations.short.name.type.email=電子郵件
annotations.short.name.type.first.name=名字
annotations.short.name.type.full.name=全名
annotations.short.name.type.group.names=姓名
annotations.short.name.type.initials=初始
annotations.short.name.type.last.name=姓氏
before.checkin.cleanup.code=清理(&L)
before.checkin.cleanup.code.profile=使用 ''{0}'' 組態檔案清理(&L)
before.checkin.error.in.plugin=無法檢查提交\\: 延伸模組 ''{0}'' 中存在錯誤
before.checkin.error.internal=無法檢查提交\\: 內部錯誤
before.checkin.error.multiple.changelists.selected=選擇了多個更改列表進行提交
before.checkin.error.unknown=無法檢查提交
before.checkin.error.unresolved.merge.conflicts=檔案有未解決的衝突
before.checkin.new.todo.check=檢查 TODO ({0})
before.checkin.new.todo.check.no.filter=檢查 TODO
before.checkin.options.check.smells.choose.profile=選擇組態檔案
before.checkin.options.check.smells.profile=使用 ''{0}'' 組態檔案分析程式碼(&A)
before.checkin.post.commit.error.dumb.mode=現在無法進行程式碼分析
before.checkin.standard.options.check.smells=分析程式碼(&A)
before.checkin.waiting.for.smart.mode=正在等待智能模式…
before.commit.file.contains.code.smells.edit.them.confirm.text=檔案 {0} 有問題。\\n{1,choice, 0\\#無錯誤|1\\#1 個錯誤|2\\#{1} 個錯誤}和{2,choice, 0\\#無警告|1\\#1 個警告|2\\#{2} 個警告}。\\n要檢視它們嗎?
before.commit.files.contain.code.smells.edit.them.confirm.text={0} 個檔案有問題。\\n{1,choice, 0\\#無錯誤|1\\#1 個錯誤|2\\#{1} 個錯誤}，{2,choice, 0\\#無警告|1\\#1 個警告|2\\#{2} 個警告} \\n要檢視它們嗎?
before.commit.run.configuration.failed=''{0}'' 失敗，離開程式碼為 {1}
before.commit.run.configuration.failed.edit.configuration=編輯執行組態
before.commit.run.configuration.failed.to.start=無法啟動 ''{0}''
before.commit.run.configuration.no.configuration.selected.checkbox=執行組態
before.commit.run.configuration.tests.failed=''{0}'' - {1}
border.changes.filter.change.number.filter=更改
border.changes.filter.date.filter=日期
border.selected.revision.commit.message=提交訊息
border.standard.after.checkin.options.group=在{0}之後
browse.changes.action=瀏覽更改
browse.changes.content.title={0}下的更改
browse.changes.error.message=存取 VCS 時發生問題\\: {0}
browse.changes.error.title=無法顯示更改
browse.changes.filter.title=指定搜尋條件
browse.changes.no.filter.prompt=尚未指定任何篩選條件。確定要檢視專案的整個歷史記錄嗎?
browse.changes.nothing.found=未找到與條件符合的任何更改
browse.changes.nothing.found.title=未找到任何更改
browse.changes.progress.title=正在搜尋更改
browse.changes.scope=影響 {0} 的更改
browse.changes.show.all.button=顯示所有更改
browse.changes.show.recent.button=顯示最近的更改
browse.changes.title=瀏覽更改
button.apply.patch=套用補丁
button.clear=清除
button.remove=移除
button.search.again=再次搜尋
button.skip=跳過
button.text.overwrite.modified.file=覆蓋已修改的檔案(&O)
button.text.overwrite.modified.files=覆蓋已修改的檔案(&O)
button.tooltip.remove.commit.author.date=移除
cache.settings.dialog.title=VCS 歷史記錄快取設定
cannot.apply.file.already.exists=無法將補丁套用到檔案 {0}\\: 它已存在。
cannot.create.directory.for.patch=不能建立檔案\\: {0}。{1}
cannot.find.file.to.patch=找不到要套用更新檔的檔案\\: {0}
change.dialog.title.change.list.name={0} [{1}]
change.dialog.title.in.change.list.name={1} 中的 {0}
change.file.copied.from.text=- 已從 {0} 複製
change.file.moved.from.text=- 已從 {0} 移動
change.file.moved.to.text=- 已移至 {0}
change.file.renamed.from.text=- 已從 {0} 重新命名
change.file.renamed.to.text=- 已重命名為 {0}
change.file.replaced.text=- 已取代
change.list.manager.wait.lists.synchronization.background={1, choice, 0\\#正在等待 |1\\#{0}\\: }本地更改重新整理
change.list.manager.wait.lists.synchronization.modal={1, choice, 0\\#正在等待 |1\\#{0}\\: }本地更改重新整理
change.list.scope.provider.local.changes=本地更改
change.list.scope.provider.only.changes=所有檔案中僅未提交到 VCS 的更改
change.list.scope.provider.only.changes.in.file=檔案 {0} 中僅未提交到 VCS 的更改
change.lists.manager.add.unversioned=新增未進行版本管理的檔案
change.nodetitle.change.is.outdated=檔案在伺服器上已被更改
change.shelves.location.dialog.action.button=更改位置
change.shelves.location.dialog.custom.label=自訂目錄(&U)\\:
change.shelves.location.dialog.default.label=預設目錄\\:
change.shelves.location.dialog.group.title=將擱置存儲於\\:
change.shelves.location.dialog.location.browser.title=選擇要將擱置存儲在其中的目錄
change.shelves.location.dialog.title=更改擱置位置
changelist.details.committed.format=由 {0} {1} 提交
changelist.details.title=更改列表詳細資訊
changes.ExcludeChangedLinesFromCommit.chunks.action.text=從提交中排除所選區塊
changes.IncludeChangedLinesIntoCommit.chunks.action.text=將所選區塊包含到提交中
changes.action.include.in.operation.name=包含在 {0} 中(&I)
changes.action.rollback.custom.title={0}更改
changes.action.rollback.text=復原
changes.action.rollback.title={0}更改
changes.another.change.list=另一個
changes.browse=瀏覽
changes.browser.details.marker=更多…
changes.button.newer=較新的 >
changes.button.older=< 較舊的
changes.can.not.find.patch.for.path.in.patch.file=在更新檔檔案中找不到 {0} 的補丁。
changes.cant.load.changes=無法載入更改
changes.change.list.conflict.dialog.radio.button.ignore=忽略(&I)
changes.change.list.conflict.dialog.radio.button.shelve.changes=擱置更改(&S)
changes.changelists.to.cache.initially=最初要快取的更改列表\\:
changes.checkbox.delete.locally.added.files=刪除新增的檔案的本地副本(&D)
changes.checking.configuration.0.for.ignore=正在為忽略物件檢查組態 {0}…
changes.combined.diff=組合更改差異
changes.committed.changes=已提交更改
changes.configure=組態(&C)…
changes.days.of.history.to.cache.initially=最初要快取的歷史記錄的天數\\:
changes.default.change.list=預設
changes.default.changelist.name=更改
changes.default.changelist.name.old=預設更改列表
changes.deleting.added.files.locally=正在本地刪除已新增檔案…
changes.dialog.editchangelist.error.already.exists=名為 ''{0}'' 的更改列表已存在
changes.dialog.editchangelist.title=編輯更改列表
changes.dialog.message.failed.to.revert.apply.changes=無法{0, choice, 0\\#還原|1\\#套用}更改\\: 
changes.dialog.newchangelist.title=新增更改列表
changes.diff.separator=差異
changes.directory.does.not.belong.to.the.active.changelist={0, choice, 1\\#這一目錄|2\\#這些目錄}不屬於活動更改列表\\:
changes.do.cleanup=進行清理…
changes.editor.diff.preview.empty.title=更改
changes.editor.diff.preview.title=更改\\: {0}
changes.empty.changelists.no.longer.active={0,choice,1\\#空更改列表 ''''{1}'''' 已|2\\#空更改列表 '<br/>'{1} 已}不再活動。<br/>是否要將{0, choice,1\\#其|2\\#其}移除?
changes.error.can.t.get.revision.content=無法獲取修訂內容
changes.error.can.t.show.diff.for=無法顯示 ''{0}'' 的差異
changes.error.can.t.show.diff.for.binary.file=無法顯示二進制檔案 ''{0}'' 的差異
changes.error.cannot.find.base.for.path=找不到 ''{0}'' 的基
changes.error.content.for.0.was.removed=''{0}'' 的內容已被移除
changes.error.default.project.not.supported=不支持預設專案
changes.error.failed.to.create.content.for.current.revision=無法為當前修訂建立內容
changes.error.failed.to.fetch.current.revision=無法獲取當前修訂
changes.error.refreshing.vcs.history=重新整理 VCS 歷史記錄時出錯
changes.error.refreshing.view=重新整理檢視時出錯\\: {0}
changes.error.shelving.changes.failed=擱置更改失敗\\: {0}
changes.exclude.lines.from.commit=將行從提交中排除
changes.file.does.not.belong.to.the.active.changelist={0, choice, 1\\#這一檔案|2\\#這些檔案}不屬於活動更改列表\\:
changes.file.from.non.active.changelist.is.modified=停用更改列表中的檔案已修改
changes.finishing.changed.on.server.update=正在完成“在伺服器上被更改”更新
changes.hide.this.notification=隱藏此通知
changes.ignore.file=忽略檔案
changes.impossible.until.indices.are.up.to.date=在索引更新前不可行
changes.include.lines.into.commit=將行包含在提交中
changes.locked.by=被 {0} 鎖定
changes.minutes=分鐘
changes.move.changes.to.active.change.list.name=將更改移至活動更改列表({0})
changes.move.to.changelist=移至 ''{0}'' 更改列表
changes.new.changelist=新增更改列表
changes.no.incoming.changelists.available=無可用傳入更改列表
changes.no.tracking.branch=無追蹤分支
changes.no.tracking.branch.suffix=\\ (無追蹤分支)
changes.nodetitle.changecount={0,choice, 0\\#無檔案|1\\#1 個檔案|2\\#{0} 個檔案}
changes.nodetitle.directory.changecount={0,choice, 0\\#無目錄|1\\#1 個目錄|2\\#{0} 個目錄}
changes.nodetitle.directory.file.changecount={0,choice, 0\\#無目錄|1\\#1 個目錄|2\\#{0} 個目錄}，{1,choice, 0\\#無檔案|1\\#1 個檔案|2\\#{1} 個檔案}
changes.nodetitle.empty.changelist.name=<空名稱>
changes.nodetitle.filter.pending=未篩選
changes.nodetitle.filtered.out=已篩選
changes.nodetitle.have.outdated.files=某些檔案在伺服器上已被更改
changes.nodetitle.ignored.files=已忽略的檔案
changes.nodetitle.locally.deleted.files=本地已刪除的檔案
changes.nodetitle.locked.folders=鎖定的工作副本目錄
changes.nodetitle.locked.folders.tooltip=某些目錄已被鎖定；不允許對它們進行 VCS 動作。應執行清理。
changes.nodetitle.logicallt.locked.folders=明確鎖定的檔案
changes.nodetitle.merge.conflicts=合併衝突
changes.nodetitle.merge.conflicts.resolve.link.label=解決
changes.nodetitle.modified.without.editing=已修改，但未簽出的檔案
changes.nodetitle.resolved.conflicts=已解決的衝突
changes.nodetitle.switched.files=已切換的檔案
changes.nodetitle.switched.roots=根開關
changes.nodetitle.untracked.updating.delayed=檔案掃描期間未進行版本控制的檔案不可用
changes.nodetitle.unversioned.files=未進行版本管理的檔案
changes.nodetitle.updating=正在更新…
changes.none=<無>
changes.notification.content.repository.location.not.found.for=找不到 {0} 的版本庫位置
changes.please.enter.a.valid.regex=請輸入有效正則表達式
changes.progress.text.vcs.name.performing.operation.name={0}\\: 正在執行 {1}…
changes.progress.title.choice.revert.apply.changes={0, choice, 0\\#還原|1\\#套用}更改
changes.project.exclude.paths=專案排除路徑
changes.refresh.changelists.after.update=更新後重新整理更改列表
changes.refresh.changes.every=更改重新整理間隔
changes.remove.active.empty.prompt=選擇要設為活動的更改列表\\:
changes.remove.active.prompt=選擇應將更改移至其中的更改列表\\:
changes.remove.active.title=刪除活動更改列表
changes.removechangelist.all.lists.warning.text=確定要移除{0}個更改列表嗎?\\n所有更改都將移至新的預設更改列表。
changes.removechangelist.multiple.warning.text=確定要刪除{0}個更改列表?\\n所有的更改將會移至活動的更改列表中。
changes.removechangelist.warning.text=確定要移除更改列表 ''{0}'' 嗎?\\n所有更改都將移至活動更改列表。
changes.removechangelist.warning.title=刪除更改列表
changes.removing.configuration.0.from.ignore=正在從忽略物件中移除組態 {0}…
changes.revert.apply.change.list.name={0, choice, 0\\#還原\\: |1\\#套用\\: }{1}
changes.set.active.changelist.to.change.list.name=將活動更改列表設定為 ''{0}''
changes.switched.to.branch.name=已切換到 {0}
changes.tab.title.vcs.errors=VCS 錯誤
changes.text.default.ignored.files=預設忽略的檔案
changes.title.loading.changes=正在載入更改
changes.tree.accessible.name=更改
changes.tried.to.save.uncommitted.changes.in.shelve.before.s.but.failed.with.an.error=嘗試在{0}之前擱置未提交的更改，但因為錯誤而失敗。<br/>{1}
changes.view.conflicts.banner.default.resolve.action=解決…
changes.view.conflicts.banner.title=由於合併衝突，無法繼續
changes.warning.not.all.local.changes.may.be.shown.due.to.an.error=警告\\: 由於錯誤，可能不會顯示所有本地更改\\: {0}
checkbox.amend=修正(_M)
checkbox.checkin.options.optimize.imports=最佳化 import(&O)
checkbox.checkin.options.rearrange.code=重新整理程式碼(&N)
checkbox.checkin.options.reformat.code=重新設定程式碼格式(&R)
checkbox.clear.initial.commit.message=清除初始提交訊息(&I)
checkbox.include=包含(&I)
checkbox.include.issues.not.assigned.to.me=包括未指派給我的問題
checkbox.including.files.created.outside.ide=應用於在 {0} 外部建立的檔案
checkbox.remember.my.choice=記住我的選擇(&R)
checkbox.select.current.file.only=僅選擇當前檔案(&C)
checkbox.show.changed.revisions.only=僅更改
checkbox.show.changes.after.date=之後(&A)
checkbox.show.changes.after.num=從(&F)
checkbox.show.changes.before.date=之前(&B)
checkbox.show.changes.before.num=到(&T)\\:
checkbox.show.clear.read.only.status.dialog=如果嘗試編輯唯讀檔案，則要求將其解鎖
checkbox.show.dirty.recursively=在專案樹中醒目提示包含已修改檔案的目錄
checkin.can.not.load.current.revision=無法載入當前修訂
checkin.can.not.load.previous.revision=無法載入之前的修訂
checkin.commit.checks.failed=提交檢查失敗
checkin.commit.checks.failed.cancel.button=取消(&N)
checkin.dialog.title.todo=TODO
checkin.filter.filter.name=篩選器\\: {0}
checkin.invalid.file.s=無效檔案
checkin.title.for.commit.0=以供提交 ({0})
checkin.unresolved.merge.are.you.sure.you.want.to.commit.changes.with.unresolved.conflicts=確定要提交有未解決衝突的更改嗎?
checkin.unresolved.merge.unresolved.conflicts=未解決的衝突
checkin.wait=等待(&W)
checking.code.smells.progress.title=正在執行程式碼分析
checking.recent.changes=正在檢查最近的更改…
checking.vcs.status.progress=正在檢查 VCS 狀態…
clone.dialog.clone.button=克隆
clone.dialog.clone.failed.error=克隆失敗
clone.dialog.repository.url.item=版本庫 URL
clone.dialog.unable.create.destination.error=無法建立目標目錄
code.smells.error.messages.tab.name=程式碼分析
code.smells.review.button=檢查程式碼分析(&R)
column.info.configure.vcses.directory=目錄
column.name.configure.vcses.vcs=VCS
column.name.revision.date=日期
column.name.revision.list.author=作者
column.name.revision.list.committer=使用者
column.name.revision.list.date=日期
column.name.revision.list.description=描述
column.name.revision.list.number=數字
column.name.revision.list.revision=修訂
column.name.revision.version=版本
column.name.revisions.list.branch=分支
column.name.revisions.list.filter=日期
command.name.open.error.message.view=開啟訊息檢視
commit.amend.commit=修正提交
commit.changes=提交更改
commit.checks.error.indexing=現在無法進行程式碼分析
commit.checks.error.indexing.message=當 {0} 在背景更新索引時，無法執行提交檢查。\\n您可以在不執行檢查的情況下提交更改，也可以等到索引建立後再提交。
commit.checks.failed.notification.commit.anyway.action=仍然{0}
commit.checks.failed.notification.show.details.action=顯示詳細資訊
commit.checks.failed.notification.title={0} 檢查失敗
commit.checks.group={0} 檢查
commit.checks.group.post=進階 {0} 檢查
commit.checks.on.commit.progress.text=正在提交…
commit.checks.on.commit.progress.text.with.context=正在提交\\: {0}
commit.checks.only.progress.text=正在執行提交檢查…
commit.checks.only.progress.text.with.context=正在執行提交檢查\\: {0}
commit.description.tooltip.author=作者\\: {0}
commit.description.tooltip.commit=提交 {0}
commit.description.tooltip.date=日期\\: {0}
commit.description.tooltip.path=路徑\\: {0}
commit.dialog.changelist.label=更改列表(&T)\\:
commit.dialog.configurable=提交
commit.dialog.default.commit.operation.name=Comm&it
commit.dialog.include.action.name=包含到提交裡(&I)
commit.dialog.no.changes.detected.text=未檢測到更改
commit.dialog.no.changes.detected.title=沒有要提交的內容
commit.dialog.partial.commit.warning.body=不支持 ''{0}'' 的部分提交。\\n所選檔案中的所有更改都將提交。
commit.dialog.partial.commit.warning.title=不支持部分提交
commit.dialog.refresh.files=正在同步檔案…
commit.dialog.title=提交更改
commit.editor.diff.preview.empty.title=提交
commit.editor.diff.preview.title=提交\\: {0}
commit.from.gutter.placeholder=提交此更改
commit.legend.deleted=已刪除
commit.legend.modified=已修改
commit.legend.new=已新增
commit.message=提交訊息
commit.message.editor.accessible.name=提交訊息
commit.message.inspection.message.body.lines.should.not.exceed.characters=正文行不能超過 {0} 個字元
commit.message.inspection.message.subject.should.not.exceed.characters=主題不能超過 {0} 個字元
commit.message.intention.family.name.reformat.commit.message=重新設定提交訊息的格式
commit.message.intention.family.name.wrap.line=換行
commit.message.missing.blank.line.between.subject.and.body=主題與正文之間缺少空行
commit.message.placeholder=提交訊息
commit.progress.title=提交
commit.tooltip.merge.this.commit.with.the.previous.one=將此提交與前一個提交合併
commit.wait.util.synched.text=正在執行 VCS 重新整理…
committed.changes.empty.comment=<無註釋>
committed.changes.empty.message=版本庫沒有提交的更改
committed.changes.filter.all=所有
committed.changes.filter.none=<無>
committed.changes.filter.title=篩選依據
committed.changes.group.title=分組依據
committed.changes.incorrect.regex.message=篩選器中使用的正則表達式無效
committed.changes.not.loaded.message=按“重新整理”按鈕以載入版本庫更改
committed.changes.partial.list=[部分]
committed.changes.refresh.progress=正在重新整理 VCS 歷史記錄
committed.changes.regex.title=正則表達式(&G)
committed.changes.tab=版本庫
composite.change.provider.include.vcs.checkbox=包含{0}中的更改
configurable.ChangelistConflictConfigurable.display.name=更改列表
configurable.IssueNavigationConfigurationPanel.display.name=問題導覽
configurable.VcsContentAnnotationConfigurable.display.name=顯示最近更改
configurable.VcsDirectoryConfigurationPanel.display.name=目錄映射
configurable.VcsGeneralConfigurationConfigurable.display.name=確認
configurable.issue.link.edit=編輯
configurable.issue.link.remove=移除
configurable.shelf.storage.cant.find.or.create.new.shelf.directory=找不到或建立新的擱置目錄
configurable.shelf.storage.destination.shelf.directory.should.have.read.access=目標擱置目錄必須具備讀取權限
configurable.shelf.storage.destination.shelf.directory.should.have.write.access=目標擱置目錄必須具備寫入權限
configurable.vcs.manage.scopes=管理作用域
configuration.project.not.trusted.label=安全模式，版本控制不可用。信任該專案以存取完整的 IDE 功能。
confirmation.message.add.ignored.files.or.dirs=選擇要新增到 Git 的檔案
confirmation.message.add.ignored.single.directory=確定要將所選目錄新增到 Git 嗎?
confirmation.message.add.ignored.single.file=確定要將所選檔案新增到 Git 嗎?
confirmation.title.add.file.to=將檔案新增到 {0}?
confirmation.title.add.files.to=將檔案新增到 {0}?
confirmation.title.add.ignored.files.or.dirs=檔案位於 .gitignore 中
confirmation.title.add.ignored.single.directory=目錄位於 .gitignore 中
confirmation.title.add.ignored.single.file=檔案位於 .gitignore 中
copy.revision.number.action=複製修訂號
create.patch.commit.action.progress=正在建立更新檔…
create.patch.commit.action.title=建立更新檔
create.patch.encoding=編碼(&E)\\:
create.patch.error.title=建立補丁時出錯\\: {0}
create.patch.file.path=到檔案(&P)\\:
create.patch.loading.content.progress=正在載入內容修訂
create.patch.reverse.checkbox=反轉更新檔(&R)
create.patch.settings.dialog.title=更新檔檔案設定
create.patch.success.confirmation=已成功建立更新檔 {0}
create.patch.to.clipboard=到剪貼簿(&C)
current.version.text={4}<br/><br/>當前版本為 {3}。<br/>修改者為 {0}<br/>{1}<br/>{2}
date.group.last.week=過去一周
date.group.title=日期
date.group.today=今天
description.text.option.applicable.to.vcses=適用於 {0}
dialog.enable.version.control.integration.hint.text=可在以下位置組態版本控制設定 
dialog.enable.version.control.integration.select.vcs.label.text=選擇要與{0}關聯的版本控制系統\\:
dialog.enable.version.control.integration.title=啟用版本控制整合
dialog.message.can.t.create.text.editor.for=無法為 {0} 建立文本編輯器
dialog.message.conflict.seems.to.be.resolved=衝突似乎已解決
dialog.message.enter.directory.name=為建立的專案輸入目錄名稱。留空可直接簽出到“{0}”。
dialog.message.no.changes.for.this.file=此檔案沒有更改
dialog.title.cannot.convert.module=無法轉換模組
dialog.title.changes.browser=更改瀏覽器
dialog.title.files.created=檔案已建立
dialog.title.ignored.files=已忽略的檔案
dialog.title.message=訊息
dialog.title.modified.without.checkout.files=已修改，但未簽出檔案
dialog.title.move.changes.to.active.changelist=將更改移至活動更改列表
dialog.title.no.conflict.found=未找到衝突
dialog.title.project.directory.name=專案目錄名稱
dialog.title.remove.empty.changelist=移除空更改列表
dialog.title.resolve.changelist.conflict=解決更改列表衝突
dialog.title.select.destination.folder=選擇目標目錄
dialog.title.unversioned.files=未進行版本管理的檔案
diff.content.title.revision.number=修訂 {0}
diff.producer.error.cant.get.revision.content=無法獲取修訂內容
diff.title.local=本地
diff.title.local.with.number=本地({0})
diff.title.revision.tooltip=[{0}] {1}<br/><br/>由 {2} 在 {3}
directory.mapping.add.title=新增 VCS 目錄映射
directory.mapping.checkbox.detect.vcs.mappings.automatically=啟用自動映射檢測
directory.mapping.checkbox.detect.vcs.mappings.automatically.hint=在專案結構更改時新增和移除映射。檢測新增立的 VCS 根。
directory.mapping.remove.title=編輯 VCS 目錄映射
edit.changelist.description=註釋(&C)\\:
edit.changelist.name=名稱(&N)\\:
edit.errors=編輯錯誤
edit.source.action.text=編輯源
error.adding.files.notification.title=無法新增檔案
error.adding.files.prompt=新增檔案時發生以下問題\\:
error.adding.files.title=無法新增檔案
error.annotated.line.out.of.bounds=帶註解的行超出界限\\: {0}，總行數\\: {1}
error.cant.get.local.file.for.non.local=無法獲取檔案 ''{0}'' 的本地位置
error.cant.load.affected.files=無法載入修訂 ''{1}'' 中路徑 ''{0}'' 的受影響檔案
error.cant.perform.operation.now=現在無法{0}
error.change.from.must.be.a.valid.number=起始日期必須是有效數字
error.change.to.must.be.a.valid.number=更改物件必須是有效數字
error.date.after.must.be.a.valid.date=之後的日期必須是有效日期
error.date.before.must.be.a.valid.date=之前的日期必須是有效日期
error.executing.commit=執行 ''{0}'' 時出錯\\: {1}
error.no.changes.no.commit.message=選擇要提交的檔案並指定提交訊息
error.no.changes.to.commit=選擇要提交的檔案
error.no.commit.message=指定提交訊息
error.text.check.in.with.empty.comment=在提交訊息欄位中新增更改摘要
error.title.check.in.with.empty.comment=無提交訊息
error.updating.changes=更新更改時出錯\\: {0}
ex.changelists=更改列表
ex.move.lines.to.another.changelist.0=將行移至另一個更改列表({0})
ex.new.changelist=新增更改列表…
exception.text.internal.error.method.should.not.be.called=不應呼叫
exception.text.internal.errror.could.not.implement.method=無法實作
exception.text.unknown.error=未知錯誤
executable.project.override=僅為當前專案設定此路徑
executable.project.override.reset.globalize=設為全域
executable.project.override.reset.message=為此專案組態的可執行檔案路徑既可以設為所有專案的全域路徑，也可以還原為當前全域可執行檔案
executable.project.override.reset.revert=還原
executable.project.override.reset.title=專案可執行檔案
executable.select.label={0} 可執行檔案路徑(&P)\\:
executable.select.title=選擇可執行檔案
executable.test=測試
external.files.add.notification.action.add=始終新增
external.files.add.notification.action.mute=不再詢問
external.files.add.notification.action.view=檢視檔案
external.files.add.notification.message=外部新增的檔案可以新增到 {0}
external.files.add.view.dialog.title=將檔案新增到 {0}
file.content.too.big.to.load.increase.property.suggestion=無法顯示 ''{0}'' 的內容。\\n該檔案大小大於 {1}。\\n\\n您可以通過在 ''idea.properties'' 檔案中增大{2}屬性來覆寫此限制。
file.history.checking.last.revision.process=正在檢查最新修訂
file.history.details.committer.info=由 {0} 提交
file.history.details.committer.tooltip.info=通過 {0}
file.history.details.empty.status=提交訊息
file.history.details.hash.author.on.date.at.time={0} {1}，{2} {3}
file.history.diff.handler.affected.changes.title={1} 中的初始提交 {0}
file.history.diff.handler.collecting.affected.process=正在收集受影響的更改…
file.history.diff.handler.comparing.process=正在比較修訂…
file.history.diff.handler.paths.diff.title={0} 與 {2} 中的 {1} 之間的差異
file.history.diff.handler.paths.diff.with.local.title={0} 與 {1} 中的本地版本之間的差異
file.history.diff.handler.process.error=任務期間出錯\\: {0}
file.history.diff.revisions.process=正在比較修訂…
file.history.exceeded.limit.message=檔案歷史記錄\\: 僅為 {1} 載入了 {0} 個修訂\\n要更改歷史記錄限制，請轉到 {2}
file.history.tab.name=歷史記錄
filetype.patch.description=補丁
filetype.patch.display.name=補丁
filter.none.name=無
filter.structure.name=結構
get.from.vcs.extension.list.accessible.name=版本庫位置
get.from.version.control=克隆版本庫
group.ChangesView.ViewOptions.text=檢視選項
group.mainmenu.vcs.current.file.text=當前檔案
group.name.version.control=VCS(&V)
gutter.name.version.control.ignored.directories=版本控制忽略目錄
handle.ro.file.status.type.using.vcs=使用 {0}
hide.this.notification=隱藏此通知
history.dialog.title.difference.between.versions.in={2} 中的 {0} 和 {1} 版本的差異
history.empty=歷史記錄為空
history.failed.to.load.content.for.revision.0=無法為修訂 {0} 載入內容
history.file.not.found=找不到檔案 {0}
history.loading.revisions=正在載入受影響的修訂…
history.tab.title.can.not.load.changelist.contents=無法載入更改列表內容
ignore.codeInspection.duplicateEntry=忽略檔案重複項
ignore.codeInspection.duplicateEntry.message=<code>\\#ref</code> 模式不止定義一次 \\#loc
ignore.codeInspection.group=版本控制
ignore.quick.fix.remove.entry=移除模式
ignore.to.exclude.no.directories.found=未找到要排除的目錄
ignore.to.exclude.notification.action.details=了解更多
ignore.to.exclude.notification.action.mute=不再顯示
ignore.to.exclude.notification.action.view=檢視目錄
ignore.to.exclude.notification.message=部分忽略的目錄未從索引和搜尋中排除
ignore.to.exclude.notification.notice=<html><b>註</b>\\: 建議在排除之前重新檢查目錄內容。一些目錄可能包含不應排除的項。</html>
ignore.to.exclude.view.dialog.exclude.action=排除(&E)
ignore.to.exclude.view.dialog.title=排除目錄
ignoreTokenType./=<斜杠>
ignoreTokenType.BRACKET_LEFT=<左括號>
ignoreTokenType.BRACKET_RIGHT=<右括號>
ignoreTokenType.COMMENT=<註釋>
ignoreTokenType.CRLF=<空行>
ignoreTokenType.HEADER=<標頭>
ignoreTokenType.SECTION=<部分>
ignoreTokenType.VALUE=<值>
ignoreTokenType.syntax=\\=<語法>
ignored.file.excluded.settings.title=排除目錄管理策略
ignored.file.excluded.to.ignored.label=將排除目錄新增到忽略檔案
ignored.file.general.settings.title=一般設定
ignored.file.ignored.to.excluded.label=自動從索引中排除被忽略的目錄
ignored.file.manage.all.project=在所有專案中
ignored.file.manage.all.projects.option=為所有專案管理
ignored.file.manage.always.ask.option=始終詢問
ignored.file.manage.message={0} 可以自動將經常被忽略的檔案新增到 {1}。
ignored.file.manage.notmanage=不新增
ignored.file.manage.policy.label=忽略檔案管理策略\\:
ignored.file.manage.this.project=在此專案中
ignored.file.manage.this.project.option=僅為此專案管理
ignored.file.manage.view=檢視
ignored.file.manage.view.dialog.ignore.action=忽略(&I)
ignored.file.manage.view.dialog.title=將檔案新增到忽略
ignored.file.manage.with.files.message={0} 可以自動將經常被忽略的檔案新增到 {1}。
ignored.file.not.manage.option=關閉套用範圍
ignored.file.not.manage.this.project.option=不只為此專案管理
ignored.file.tab.title=已忽略的檔案
ignoring.files.progress.title=正在忽略檔案…
impl.notification.content.could.not.find.plugin=找不到延伸模組 {0}
impl.notification.content.plugin.was.unbundled.needs.to.be.installed.manually={0} 延伸模組已解除捆綁，需要手動安裝
impl.notification.content.vcs.plugin.not.found.for.mapping.to=沒有為 ''{0}'' 的映射找到 VCS 延伸模組
impl.notification.title.failed.to.install.plugin=安裝延伸模組失敗
impl.progress.title.installing.plugin=正在安裝延伸模組…
impl.show.all.affected.files.for.path.at.revision.failed=為 {0} 顯示 {1} 失敗時所有受影響的檔案
import.patches=匯入更新檔
import.patches.into.shelf=將補丁匯入到擱置…
incoming.changes.empty.message=沒有傳入的更改
incoming.changes.indicator.name=傳入更改
incoming.changes.indicator.tooltip={0} 個可用的傳入更改列表
incoming.changes.not.loaded.message=按“重新整理”按鈕以載入傳入的更改
incoming.changes.tab=傳入
inlay.vcs.code.author.description=根據 VCS 中的記錄獲得的程式碼作者。<br><br>作者是最後編輯類別、方法或函式的人。如果有來自不同作者的多個提交，擁有最多行的那個會被視為作者。
inspection.BodyLimitInspection.display.name=限制正文行
inspection.CommitMessageSpellCheckingInspection.display.name=拼寫
inspection.SubjectBodySeparationInspection.display.name=主題與正文之間的空白行
inspection.SubjectLimitInspection.display.name=限制主題行
issue.action.add.jira.issue.navigation.pattern.title=新增 JIRA 問題導覽模式
issue.action.add.youtrack.issue.navigation.pattern.title=新增 YouTrack 問題導覽模式
issue.action.enter.jira.installation.url.label=輸入 JIRA 安裝 URL\\:
issue.action.enter.youtrack.installation.url.label=輸入 YouTrack 安裝 URL\\:
issue.link.add.title=新增問題導覽連結
issue.link.delete.prompt=刪除所選導覽連結?
issue.link.delete.title=刪除問題導覽連結
issue.link.edit.title=編輯問題導覽連結
issue.link.issue.column=問題
issue.link.link.column=連結
issue.link.no.patterns=未組態模式
jb.protocol.no.provider=找不到 VCS 提供程序\\: ''{0}''
label.at.date.leading=在 {0}
label.at.date.middle=在 {0}
label.by.author=作者
label.code.author.inlay.hints=程式碼作者
label.commit.checks.failed.unknown.reason=檢查失敗
label.commit.checks.not.available.during.indexing=索引編制期間無法提交檢查
label.commit.comment=提交訊息(&M)
label.multi.author.modified.code={0} +{1} *
label.multi.author.not.modified.code={0} +{1}
label.new.code=新 *
label.project.vcs.root.mapping=<專案>
label.relative.project.path.presentation=<專案>/{0}
label.select.files.to.be.added.to.version.control=選擇要新增到版本控制中的檔案
label.selected.revision.commit.message=提交訊息
label.single.author.modified.code={0} *
label.todo.items.found={0} 個 TODO
line.annotation.aspect.author=作者
line.annotation.aspect.date=日期
line.annotation.aspect.revision=修訂
link.label.display.anyway=仍然顯示
link.label.hide=隱藏
link.label.ignore=忽略
link.label.move.changes=移動更改
link.label.switch.changelist=切換更改列表
loading.file.history.progress=正在載入檔案歷史記錄
loading.file.history.status=正在載入 {0} 的歷史記錄…
loading.file.history.up.to.revision.status=正在載入 {0} 截至 {1} 的歷史記錄…
loading.text2.file.history.progress=正在載入檔案歷史記錄
local.changes.freeze.message={0}完成之前，本地更改不可用
local.changes.tab=本地更改
local.history.update.from.vcs=從 VCS 更新
local.version.title=本地版本
looking.for.patch.files=正在尋找更新檔檔案…
lookup.title.vcs.file.revisions=檔案修訂
lst.inactive.ranges.damaged.notification=部分更改已移至活動更改列表
merge.loading.merge.details=正在載入合併詳細資訊…
message.read.only.status.content=您以 <b>root</b> 身份登入，因此\\: <br><br>- {0} 無法看到唯讀狀態的檔案。<br>- 所有檔案都被視為可寫入。<br>- 修改時無法自動簽出檔案。
message.read.only.status.title={0}\\: 無法看到唯讀狀態
message.text.all.files.are.up.to.date=所有檔案都處於最新狀態
message.text.background.tasks=正在等待背景 VCS 任務完成…
message.text.cannot.edit.file=無法編輯檔案\\: {0}
message.text.cannot.load.revision=無法載入修訂\\: {0}
message.text.cannot.open.editor=無法開啟檔案 {0} 的文本編輯器
message.text.cannot.save.content=無法儲存內容\\: {0}
message.text.cannot.save.settings=無法執行動作\\: {0}
message.text.cannot.show.differences=無法顯示差異\\: {0}
message.text.commit.failed.with.error=提交失敗，有{0,choice,1\\#錯誤|2\\#錯誤}
message.text.commit.finished.with.warning=提交完成，有{0,choice,1\\#警告|2\\#警告}
message.text.commit.progress=正在提交…
message.text.could.not.load.virtual.file.content=無法載入檔案 {0} 的內容\\: {1}
message.text.file.is.up.to.date=檔案處於最新狀態
message.text.file.locally.modified=檔案 {0} 已在本地被修改。
message.text.several.files.locally.modified=某些檔案已在本地被修改。
message.title.annotate=註解
message.title.cannot.open.editor=無法開啟編輯器
message.title.could.not.load.content=無法載入內容
message.title.could.not.load.file.history=載入檔案歷史記錄時發生問題
message.title.edit.files=編輯檔案
message.title.get.revision.content=獲取修訂內容
message.title.get.version=獲取版本
message.title.show.differences=顯示差異
message.title.vcs.update.errors={0}錯誤
move.to.another.changelist.nothing.selected.notification=沒有選擇任何可以移動的專案
move.to.changelist=將更改移至活動更改列表(''{0}'')(&M)
multiple.file.merge.accept.theirs=接受他們的(&T)
multiple.file.merge.accept.yours=接受您的更改(&Y)
multiple.file.merge.column.name=名稱
multiple.file.merge.dialog.command.name.accept.theirs=接受他們的更改
multiple.file.merge.dialog.command.name.accept.yours=接受您的更改
multiple.file.merge.dialog.error.loading.revisions.to.merge=載入待合併修訂時出錯\\: {0}
multiple.file.merge.dialog.message.error.saving.merged.data=儲存合併資料時出錯\\: {0}
multiple.file.merge.dialog.message.file.too.big.to.be.loaded=檔案過大，無法載入
multiple.file.merge.dialog.progress.title.loading.revisions=正在載入修訂…
multiple.file.merge.dialog.progress.title.resolving.conflicts=正在解決衝突…
multiple.file.merge.dialog.title.can.t.show.merge.dialog=無法顯示“合併”對話框
multiple.file.merge.group.by.directory.checkbox=按目錄對檔案分組
multiple.file.merge.loading.progress.title=正在載入合併修訂…
multiple.file.merge.merge=合併(&M)…
multiple.file.merge.request.title=合併 {0} 的修訂
multiple.file.merge.title=衝突
new.changelist.duplicate.name.error=具有該名稱的更改列表已存在
new.changelist.empty.name.error=無法使用空名稱建立新的更改列表
new.changelist.make.active.checkbox=設為活動(&A)
new.changelist.new.label=新增
no.ignored.files=沒有忽略的檔案
none.vcs.presentation=<無>
notification.content.didn.t.update.repository.changes=由於發生錯誤，未使用新消息更新版本庫更改\\: {0}
notification.group.external.executable=VCS 外部可執行檔案驗證失敗
notification.group.vcs.common.messages=VCS 普通訊息
notification.group.vcs.important.messages=VCS 重要訊息
notification.group.vcs.messages=VCS 訊息
notification.group.vcs.notifications=VCS 通知
notification.group.vcs.silent.notifications=VCS 靜默通知
notification.showDetailsInConsole=在主控台中顯示詳細資訊
notification.title.cant.load.annotations=無法載入註解
notification.title.couldn.t.save.uncommitted.changes=無法儲存未提交的更改。
notification.title.vcs.name.repository.repositories.found=已找到 {0} {1, choice, 1\\#版本庫|2\\#版本庫}
open.repository.version.description=在編輯器中開啟檔案的所選修訂
open.repository.version.text=開啟版本庫版本
operation.name.annotate=註釋
outdated.version.show.diff.action=顯示差異
outdated.version.text=過時的版本。{0} 在 {1} {3,choice,0\\#修改|1\\#刪除}了以下訊息\\: {2}
outdated.version.update.project.action=更新專案
patch.apply.abort.action=中止…
patch.apply.abort.and.rollback.action=中止並復原(_A)
patch.apply.abort.and.rollback.prompt=中止並復原套用更新檔還是跳過此檔案?
patch.apply.abort.title=中止更新檔
patch.apply.aborted.message=“套用補丁”動作期間更改的所有檔案已被復原
patch.apply.aborted.title=套用更新檔中止
patch.apply.added.status=已新增
patch.apply.after.patch.label.text=補丁後
patch.apply.already.applied=指定更新檔的所有更改均已包含在程式碼中
patch.apply.already.applied.status=已套用
patch.apply.already.exists.overwrite.prompt=檔案 {0} ({1})已存在。\\n是否要覆蓋它?
patch.apply.analyze.from.clipboard.on.the.fly.checkbox=動態分析和套用剪貼簿中的更新檔
patch.apply.automatically.applied.status=已自動套用
patch.apply.bad.diff.title=更新檔套用的結果
patch.apply.bad.diff.to.title=將補丁應用於 {0} 的結果
patch.apply.before.patch.label.text=補丁前
patch.apply.can.not.apply.additional.info.error=無法套用附加更新檔資訊\\: {0}
patch.apply.can.t.find.patch.file.warning=找不到補丁檔案 {0}
patch.apply.cannot.apply.now=現在無法套用更新檔
patch.apply.cannot.read.patch=無法讀取更新檔 {0}\\: {1}
patch.apply.change.directory.paths.group=更改目錄路徑
patch.apply.changes.in.patch.resolve=在補丁解析中{0}
patch.apply.command=套用補丁
patch.apply.conflict.for.title={0}的補丁衝突
patch.apply.conflict.local.version=本地版本
patch.apply.conflict.merged.version=合併結果
patch.apply.conflict.patch=補丁
patch.apply.conflict.patched.somehow.version=結果
patch.apply.conflict.patched.version=更新檔版本
patch.apply.conflict.title=補丁衝突
patch.apply.continue.resolve.action=繼續解析
patch.apply.deleted.status=已刪除
patch.apply.dialog.title=套用補丁
patch.apply.display.local.content.was.modified.error=無法顯示更新檔套用者 - 本地內容已修改
patch.apply.error.conflict=套用更新檔衝突
patch.apply.error.document.not.found=找不到文檔 {0}
patch.apply.error.file.not.found=找不到檔案 {0}
patch.apply.file.name.field=補丁檔名(&P)\\:
patch.apply.file.type.binary.error=無法從補丁套用 {0} 檔案，因為它是二進制檔案。
patch.apply.file.type.directory.error=無法從補丁套用 {0} 檔案的內容，因為它是目錄。
patch.apply.file.type.undefined.error=無法從補丁套用 {0} 檔案的內容，因為它的類型未定義。
patch.apply.hunk.warning=無法檢測到以下物件的區塊修改行\\: -{0},{1} +{2},{3}
patch.apply.incorrectly.processed.warning=VCS 可能未正確處理以下{0, choice, 1\\#檔案|2\\#檔案}。\\n請手動檢查{0, choice, 1\\#它|2\\#它們}\\: {1}
patch.apply.map.base.directory.action=映射基目錄…
patch.apply.marker.renderer=標記\\: {0}
patch.apply.missing.base.file.label=缺少基
patch.apply.modified.status=已修改
patch.apply.new.base.detected.node.description=檢測到新基
patch.apply.new.files.warning=套用更新檔建立新檔案報錯
patch.apply.not.applied.status=未套用
patch.apply.not.patch=內容不是更新檔
patch.apply.not.patch.clipboard=剪貼簿內容不是補丁
patch.apply.not.patch.type.file.error=所選檔案 {0} 不是補丁類型檔案
patch.apply.notification.title=套用補丁
patch.apply.old.new.base.info=更改前\\: {0} (基目錄\\: {1})<br/>更改後\\: {2} (基目錄\\: {3})
patch.apply.outside.content.root.message=在內容根外部找到補丁檔案\\: {0}
patch.apply.overwrite.existing.file.prompt=以下檔案應通過更新檔建立，但它已經存在。\\n是否要覆蓋它?\\n{0}
patch.apply.overwrite.existing.files.prompt=以下檔案應通過更新檔建立，但它們已經存在。\\n是否要覆蓋它們?
patch.apply.overwrite.existing.title=覆蓋現有檔案
patch.apply.partially.applied=指定更新檔的某些更改已被跳過，因為它們已包含在程式碼中
patch.apply.partly.failed.title=更新檔部分套用失敗
patch.apply.progress.title=正在套用更新檔…
patch.apply.rollback.action=復原
patch.apply.rollback.failed.message=嘗試使用“本地歷史記錄”對話框手動執行還原。
patch.apply.rollback.failed.title=復原失敗
patch.apply.rollback.progress=復原套用的更改…
patch.apply.rollback.progress.title=復原套用的更改…
patch.apply.rollback.prompt=無法{0, choice, 0\\#套用補丁。|1\\#將補丁套用到檔案\\:|2\\#將補丁套用到檔案\\:}
patch.apply.rollback.prompt.bottom=更新檔中的其他更改已成功套用，是否要復原它們?
patch.apply.rollback.will.not.affect.binaries.info=復原不會影響二進制檔案
patch.apply.select.base.for.a.path.message=為路徑選擇基
patch.apply.select.base.title=選擇{0, choice, 0\\#目錄|1\\#檔案}基
patch.apply.select.missing.base.link=選擇缺少的基
patch.apply.select.title=選擇更新檔檔案
patch.apply.skip.action=跳過(_S)
patch.apply.somehow.diff.name=以某種方式套用更新檔
patch.apply.stripped.description=\\ 去除的{0}
patch.apply.success.applied.text=已成功套用補丁
patch.apply.syntax.line=\\ (行\\: {0})
patch.apply.wrong.base.and.can.t.be.applied.warning={0} 的補丁的基錯誤，無法正確套用
patch.binary.decoder.char.error=無法解碼二進制檔案更新檔\\: 字元大小符號錯誤
patch.binary.decoder.content.error=解碼的二進制內容{0,choice,0\\#少於|1\\#多於}預期
patch.binary.decoder.decompress.error=無法解碼二進制檔案更新檔\\: 無法解壓資料
patch.binary.decoder.line.error=無法編碼二進制檔案更新檔\\: 行大小錯誤
patch.can.t.detect.file.names.from.git.format.header.line=無法從 git 格式頭行檢測檔名
patch.contains.additional.information.without.patch.itself=包含附加資訊但不含更新檔本身
patch.content.viewer.name=補丁檢視器
patch.content.viewer.side.by.side.name=並排補丁檢視器
patch.copied.to.clipboard=更新檔已複製到剪貼簿
patch.creation.base.dir.does.not.exist.error=基目錄不存在
patch.creation.base.path.field=基路徑(&B)\\:
patch.creation.can.not.write.patch.error=無法將更新檔寫入指定檔案\\: {0}
patch.creation.empty.base.path.error=基路徑不能為空\\!
patch.creation.failed=更新檔建立失敗
patch.creation.name.too.long.error=檔案路徑不應過長。
patch.creation.save.patch.file.title=儲存更新檔檔案
patch.creation.save.to.file.button=將補丁儲存到檔案
patch.creation.save.to.title=將補丁儲存到
patch.creation.wrong.base.path.for.changes.error=基路徑不包含所有所選更改(使用 {0})
patch.empty.0.data.section=空 ''{0}'' 資料分區
patch.empty.additional.info.header=空的附加資訊頭
patch.failed.to.fetch.old.content.for.file.name.in.revision=無法在修訂 {1} 中獲取檔案 {0} 的舊內容
patch.import.additional.info.error=無法匯入附加更新檔資訊\\: {0}
patch.import.no.patches.found.warning=未找到更新檔
patch.import.to.shelf.progress.title=將補丁匯入到 Shelf
patch.import.to.shelf.tab=將補丁匯入到 Shelf
patch.is.binary.text=二進制補丁檔案
patch.missing.after.hunk=缺少 after 區塊
patch.parse.error=無效的更新檔檔案\\: {0}
patch.parse.error.empty.file=更新檔檔案為空
patch.parse.no.document.error=無法解析更新檔檔案
patch.second.file.name.expected=應為第二個檔名
patch.simple.apply.base.line.error=意外基線\\: 應為 - {0}，實際為 - {1}
patch.simple.apply.base.line.total.error=意外基線\\: 總行數 - {0}，實際行數 - {1}
patch.simple.apply.hunk.base.body.error=意外的區塊基主體\\: 應為 - {0}，實際為 - {1}
patch.simple.apply.hunk.base.end.error=意外的區塊基結束\\: 總行數為 - {0}，區塊結束為 - {1}
patch.simple.apply.hunk.base.start.error=意外的區塊基開始\\: 應為 - {0}，實際為 - {1}
patch.simple.apply.hunk.content.error=意外的區塊內容\\: 應為 - {0}，實際為 - {1}
patch.simple.apply.hunk.patched.body.error=意外的區塊補丁主體\\: 應為 - {0}，實際為 - {1}
patch.simple.apply.hunk.patched.start.error=意外的區塊更新檔開始\\: 應為 - {0}，實際為 - {1}
patch.unexpected.end.of.binary.patch=二進制補丁意外結束
patch.unknown.after.hunk.start.syntax=未知的 after 區塊開始語法
patch.unknown.before.hunk.start.syntax=未知的 before 區塊開始語法
patch.unknown.hunk.start.syntax=未知的區塊開始語法
patch.unknown.line.prefix=未知行前綴
patched.version.name=更新檔版本
path.apply.select.base.directory.for.a.path.popup=為路徑選擇基目錄
paths.affected.in.revision={0} 中的更改
post.commit.checks.failed.notification.ignore.action=忽略
post.commit.checks.failed.notification.title=提交包含問題
post.commit.checks.failed.push.dialog.notification.text=提交包含問題\\: {0}
post.commit.checks.not.finished.push.dialog.notification.text=提交檢查仍在進行中
post.commit.checks.progress.step.collecting.commits.text=正在收集受影響的提交…
post.commit.checks.progress.text=正在檢查提交中的檔案
progress.text.analyzing.code=正在分析程式碼…
progress.text.applying.fixes=正在套用修正…
progress.text.checking.for.todo=正在檢查 TODO…
progress.text.inspecting.code=正在檢查程式碼…
progress.text.loading.patch.base.revision=正在載入更新檔基礎修訂
progress.text.optimizing.imports=正在最佳化 import…
progress.text.performing={0}\\: 正在執行 {1}…
progress.text.performing.rollback={0}\\: 正在執行復原…
progress.text.rearranging.code=正在重新排列程式碼…
progress.text.reformatting.code=正在重新設定程式碼格式…
progress.text.searching.for.modified.files=正在搜尋修改的檔案
progress.text.synchronizing.files=正在同步檔案…
progress.text.updating.canceled=更新已取消
progress.text.updating.done=更新完成
progress.title.adding.files.to.vcs=正在將檔案新增到 VCS…
progress.title.commit.checks=提交檢查
progress.title.discovering.location=正在發現 {0} 的位置
progress.title.hey=嗨
progress.title.loading.current.revision=正在載入當前修訂…
progress.title.version.control.processing.changed.files=版本控制\\: 正在處理更改的檔案
project.configuration.files.add.notification.action.add=始終新增
project.configuration.files.add.notification.action.mute=不再詢問
project.configuration.files.add.notification.action.view=檢視檔案
project.configuration.files.add.notification.message=可以將 IDE 專案設定新增到 {0}
project.configuration.files.view.dialog.title=將檔案新增到 {0}
project.detected.n.roots.presentation=已檢測到 {0}
radio.after.creation.add.silently=無提示新增
radio.after.creation.do.not.add=不新增
radio.after.creation.show.options=詢問
radio.after.deletion.do.not.remove=不移除
radio.after.deletion.remove.silently=無提示移除
radio.after.deletion.show.options=詢問
radio.restore.workspace.on.branch.switching=切換分支時還原工作區(&B)
radio.restore.workspace.on.branch.switching.comment=工作區是一組開啟的檔案、當前執行組態以及與分支關聯的中斷點。
ranges.to.commit.of.ranges.size.changes={1} 個中的 {0} 個發生更改
remove.changelist.combobox.do.not.remove=不執行任何動作
remove.changelist.combobox.remove.silently=無提示移除
remove.changelist.combobox.show.options=顯示選項
retrieving.annotations=正在載入註解
revert.changes.changelist.chooser.title=選擇目標更改列表
rollback.modified.without.checkout.error.tab={0}未簽出時進行了修改
rollback.modified.without.editing.confirm.multiple=要將更改{0}到 {1} 個所選檔案嗎?
rollback.modified.without.editing.confirm.single=要將更改{0}到{1}嗎?
rolling.back.file=正在復原{0}
roots.notification.content.added.vcs.name.roots=已新增 {0} 個{1,choice,1\\#根|2\\#根}\\: {2}
roots.notification.content.directory.registered.as.root.but.no.repositories.were.found.there=目錄 {0} 被註冊為 {1} 根，但在那裡沒有發現 {1} 版本庫。
roots.notification.title.invalid.vcs.root.choice.mapping.mappings=無效 VCS 根{0, choice, 1\\#映射|2\\#映射}
roots.notification.title.vcs.name.integration.enabled={0} 整合已啟用
roots.notification.title.vcs.root.configuration.problems=VCS 根組態問題
roots.the.following.directories.are.registered.as.vcs.roots.but.they.are.not=以下目錄被錯誤註冊為 VCS 根\\:
save.committing.files.confirmation.cancel=延遲儲存
save.committing.files.confirmation.ok=立即儲存
save.committing.files.confirmation.text=當前正在將以下{0,choice,1\\#檔案|2\\#檔案}提交到 VCS。立即儲存可能會導致提交的資料不一致。\\n{1}\\n立即儲存{0,choice,1\\#檔案|2\\#檔案}?
save.committing.files.confirmation.title=在提交期間儲存檔案
saved.patch.apply.action=套用(&A)
saved.patch.apply.pop.help.tooltip=<html>套用\\\\&mdash;套用並將隱藏保留在<br/>列表中。<br/>彈出\\\\&mdash;套用並從列表中<br/>移除隱藏。</html>
saved.patch.changes.empty=選擇隱藏或擱置以檢視檔案
saved.patch.changes.loading=正在載入…
saved.patch.created.on.date.at.time.tooltip={0} 在 {2} 建立於 {1}
saved.patch.editor.diff.preview.empty.title=隱藏和擱置
saved.patch.empty.text=未新增任何隱藏或擱置。
saved.patch.pop.action=彈出(&P)
scope.name.changelist.all.changed.files=所有更改的檔案
searching.for.code.smells.freezing.process=簽入前代碼分析
searching.for.code.smells.processing.file.progress.text=正在處理 {0}
selection.history.can.not.load.message=無法載入修訂內容
selection.history.commit.message.label=提交訊息\\:
selection.history.loading.revision.status=正在載入修訂 {0}…
selection.history.local.revision.text=本地更改
sequence.concatenation.a.and.b={0} 和 {1}
sequence.concatenation.separator=, 
sequence.concatenation.tail=和 {0}
sequence.concatenation.tail.n.others=和其他 {0} 個
settings.auto.detected=自動檢測\\:
settings.auto.detected.progress=正在檢測…
settings.border.when.files.are.created=當檔案被建立時\\:
settings.change.shelves.location=更改擱置位置…
settings.changelist.conflicts.group.title=衝突
settings.changelists.create.automatically.checkbox=自動建立更改列表(&A)
settings.changelists.option.group=更改列表
settings.check.every.minutes=分鐘
settings.checkbox.limit.history.to=將歷史記錄限制為
settings.checkbox.measure.days=天
settings.checkbox.rows=行
settings.checkbox.show.changed.in.last=醒目提示以下時間內更改的檔案\\:
settings.checkbox.show.changed.in.last.comment=修改的檔案將在外部堆疊追蹤和偵錯時醒目提示。
settings.commit.message.body.add.blank.line.fix=新增空白行
settings.commit.message.inspections=提交訊息檢查\\:
settings.commit.message.option.group=提交訊息
settings.commit.message.right.margin.label=右邊距\\:
settings.commit.message.show.right.margin.label=顯示右邊距
settings.commit.message.show.right.margin.n.columns.label=顯示 {0} 列中的右邊距
settings.commit.postpone.slow.checks=提交完成後執行進階檢查
settings.commit.postpone.slow.checks.description=失敗的檢查不會阻止提交
settings.commit.postpone.slow.checks.description.short=檢查失敗不會阻止提交
settings.commit.without.dialog.applies.to.git.mercurial=套用到 Git 和 Mercurial 下的專案
settings.confirmation.option.group=確認
settings.confirmation.option.text.ask=詢問
settings.confirmation.option.text.no=否
settings.confirmation.option.text.yes=是
settings.current.location=當前位置為
settings.default.location=預設位置為 
settings.file.status.color.added.in.not.active.changelist=已在停用更改列表中新增
settings.file.status.color.changelist.conflict=更改列表衝突
settings.file.status.color.modified.in.not.active.changelist=已在停用更改列表中修改
settings.files.with.ignored.conflicts.list.title=包含忽略衝突的檔案\\:
settings.filter.configure.link=組態
settings.filter.update.project.info.by.scope=按作用域篩選更新專案資訊
settings.general.changes.group.title=更改
settings.general.confirmation.group.title=確認
settings.general.show.options.before.command.label=進行以下動作之前顯示選項\\:
settings.highlight.files.from.non.active.changelist.checkbox=醒目提示停用更改列表中的檔案(&I)
settings.highlight.files.with.conflicts.checkbox=醒目提示存在更改列表衝突的檔案(&H)
settings.inactive.changelist.group.title=停用更改列表
settings.issue.navigation.patterns={0} 將在簽入註釋中搜尋指定的模式，並將它們連結到問題追蹤器中的問題\\:
settings.label.when.empty.changelist.becomes.inactive=當空更改列表變為停用狀態時\\:
settings.limit.history.to.n.rows.label=將歷史記錄限制為 {0} 行
settings.partial.changelists.enable.checkbox=允許將一個檔案中的更改放入不同的更改列表(&P)
settings.shelf.content.larger=大於 {0}K 的檔案的基內容不會被存儲
settings.show.changed.in.last.n.days.label=顯示過去 {0} 天的更改
settings.show.conflict.resolve.dialog.checkbox=試圖編輯停用更改列表中的檔案時顯示對話框(&D)
settings.vcs.mapping.browser.select.directory.description=選擇要映射到 VCS 的目錄
settings.vcs.mapping.browser.select.directory.title=選擇目錄
settings.vcs.mapping.invalid.vcs.options.error=無效的 VCS 選項\\: {0}
settings.vcs.mapping.project.description=所有模組的內容根，以及專案基目錄的所有直接後代
settings.vcs.mapping.project.description.with.idea.directory=所有模組的內容根、專案基目錄的所有直接後代以及 {0} 目錄內容
settings.vcs.mapping.status.looking.for.vcs.administrative.area=正在尋找 VCS 管理區域
settings.version.control.option.group=版本控制
settings.when.files.are.deleted=當檔案被刪除時\\:
shelf.apply.action.description=套用所選擱置
shelf.drop.action=刪除(&D)
shelf.drop.action.description=刪除所選擱置
shelf.pop.action.description=彈出所選擱置
shelf.root.node.title=擱置
shelf.tab=擱置
shelf.tooltip.title=擱置
shelf.unshelve.changes.action.description=取消擱置所選更改
shelf.unshelve.changes.action.text=取消擱置(&U)
shelf.unshelve.changes.remove.action.description=取消擱置所選更改並將其從擱置中移除
shelf.unshelve.changes.remove.action.text=取消擱置並移除(&R)
shelve.base.content.not.found.or.not.applicable.error=基內容未找到或不適用。顯示與本地版本的差異
shelve.changelist.not.found=未找到擱置的更改列表 {0}
shelve.changes.action=托管更改(_S)
shelve.changes.only.directories=所選更改僅影響目錄，不影響檔案，因此無法擱置它們
shelve.changes.progress.text=正在擱置更改…
shelve.changes.progress.title=正在擱置更改
shelve.changes.restore.error=無法完全還原{0, choice, 1\\#擱置的更改列表|2\\#{0}擱置的更改列表}，因為某些檔案已被永久刪除
shelve.copying.shelves.to.progress=正在將擱置複製到新目錄…
shelve.default.path.rendering=<專案根目錄>
shelve.delete.already.unshelved.label=刪除已擱置的更改列表\\:
shelve.delete.changelist.name.message=''{0}'' 更改列表
shelve.delete.changelists.count.message={0} 個更改列表
shelve.delete.files.from.changelist.error=無法從 {0} 刪除檔案
shelve.delete.files.successful.message={0,choice, 1\\#1 個檔案|2\\#{0} 個檔案}
shelve.delete.successful.message=已成功從擱置中刪除 {0}{1,choice, 0\\#|1\\# 和 }{2}
shelve.editor.diff.preview.title=擱置\\: {0}
shelve.error.title=Shelf 錯誤
shelve.failed.message={0,choice,1\\#更改列表|2\\#更改列表} [{1}] 的更改擱置失敗
shelve.failed.title=擱置失敗
shelve.file.is.locked.for.editing.message=在擱置期間檔案已鎖定，無法編輯
shelve.import.one.patch.file.prompt=找到一個更新檔檔案({0})。\\n繼續匯入?
shelve.import.patches.prompt=找到 {0} 個補丁檔案。\\n繼續匯入?
shelve.import.to.progress=正在處理 
shelve.loading.patch.error=無法載入更新檔檔案\\: {0}
shelve.moving.failed.prompt=Shelf 移動失敗。<br/>要使用新的 Shelf 目錄路徑還是將其還原為上一個路徑?
shelve.recently.deleted.node=最近刪除項
shelve.remove.successfully.applied.files.checkbox=從 Shelf 移除成功套用的檔案
shelve.revert.moving.button=還原(&R)
shelve.shelved.version=擱置的版本
shelve.show.already.unshelved.action=已取消擱置
shelve.successful.message=已成功擱置更改
shelve.tree.accessible.name=擱置
shelve.undo.deletion=撤消 Shelf 刪除
shelve.use.new.directory.button=使用新路徑(&U)
shelved.version.name=擱置的版本
show.diff.from.annotation.action.error.can.not.load.data.to.show.diff=無法載入資料以顯示差異
show.diff.in.editor.tab.got.it.tooltip=要在編輯器頁籤中再次顯示差異，請使用此選單。
show.diff.progress.title=正在載入內容
show.diff.progress.title.detailed=正在載入 {0} 的內容
show.history.action.name.template=顯示 {0} 的歷史記錄(_F)…
show.history.dialog.title.template={0} 的歷史記錄
show.patch.in.explorer.after.creation.combobox.text.ask=詢問
show.patch.in.explorer.after.creation.combobox.text.no=不執行任何動作
show.patch.in.explorer.after.creation.combobox.text.show.in.file.manager=在 {0} 中顯示
show.patch.in.explorer.after.creation.label=建立補丁時\\:
stash.changes.message=在{0}之前未提交的更改
stash.changes.message.with.date=在進行{0}之前於 {1} 取消提交了更改
stash.tree.accessible.name=隱藏
status.group.name.changed=已更改
status.group.name.changed.on.server=在伺服器上已更改
status.group.name.created=已建立
status.group.name.deleted=已刪除
status.group.name.locally.added=本地已新增
status.group.name.locally.removed=本地已移除
status.group.name.modified=已修改
status.group.name.not.in.repository=不在版本庫中
status.group.name.skipped=已跳過
status.group.name.switched=已切換
status.group.name.will.be.merged=將被合併
status.group.name.will.be.merged.with.conflicts=將在存在衝突的情況下被合併
status.group.name.will.be.merged.with.property.conflicts=將在存在屬性衝突的情況下合併
status.group.name.will.be.merged.with.tree.conflicts=將在存在樹衝突的情況下合併
status.group.name.will.be.restored=將被還原
status.text.commit.toolwindow.create.repository=建立 Git 版本庫…
status.text.commit.toolwindow.create.repository.prefix=要提交更改，
status.text.commit.toolwindow.local.history=本地歷史記錄…
status.text.commit.toolwindow.local.history.prefix=有關最近的更改，請參閱
status.text.vcs.toolwindow=要追蹤程式碼更改\\:
status.text.vcs.toolwindow.create.repository=建立 Git 版本庫…
status.text.vcs.toolwindow.emptyPrefix=—
status.text.vcs.toolwindow.help=版本控制整合
status.text.vcs.toolwindow.local.history=使用當地歷史記錄…
status.text.vcs.toolwindow.shareProject=將專案共享到
status.text.vcs.toolwindow.shareProject.orOn=或者
switch.to.changelist=切換到更改列表(''{0}'')(&T)
tab.title.commit=提交
tab.title.commit.to.branch=提交至 {0}
text.commit.message.truncated.by.ide.name={0}\\n\\n…提交訊息過長，被 {1} 截斷…
title.code.author.inlay.hints=程式碼作者
title.load.revision.contents=載入修訂內容
todo.handler.only.added=<html><body>發現{0,choice, 0\\#|1\\#一|2\\#{0}}個已被新增或編輯的 TODO {0,choice, 0\\#|1\\#專案|2\\#專案}。<br/>您是否想檢視{0,choice,1\\#它|2\\#它們}?<br/>{1,choice, 0\\#|1\\#1個檔案被跳過。|2\\#{1} 個檔案被跳過。}</body></html>
todo.handler.only.both=<html><body>{0, choice, 1\\#1|2\\#{0}} 個新增/編輯的 TODO {0,choice, 1\\#條目|2\\#條目}，<br/>並在更改的片段中找到 {1, choice, 1\\#1個條目|2\\#{1} 個條目}。<br/>要檢查它們嗎?<br/>{2,choice, 0\\#|1\\#1 個檔案被跳過。|2\\#{2} 個檔案被跳過。}</body></html>
todo.handler.only.in.changed=<html><body>{0,choice, 1\\#一|2\\#{0}}個 TODO {0,choice, 1\\#項|2\\#項} 在已改變的片段中找到。<br/>您是否需要查閱{0,choice,1\\#它|2\\#它們}?<br/>{1,choice, 0\\#|1\\#一個檔案被跳過|2\\#{1} 個檔案被跳過。}</body></html>
todo.handler.only.skipped=<html><body>TODO 檢查已經跳過 {0,choice, 0\\#|1\\#1 個檔案|2\\#{0}多個檔案}。<br/>沒有發現新的或已編輯的 TODO 條目，也沒有位於更改的文本片段中的條目。</body></html>
todo.in.new.review.button=審查 TODO(&R)
todo.tab.title.all.changes=本地更改
todo.tab.title.changelist.suffix=更改列表
tooltip.rerun.commit.checks=重新執行提交檢查
tooltip.show.options.dialog=顯示選項對話框
toolwindow.title.update.project=更新專案({0})
unknown.vcs.presentation=<未知 VCS> ({0})
unregistered.roots.label=未註冊的根\\:
unshelve.changelist.chooser.title=取消擱置更改列表的更改
unshelve.changes.action=取消托管更改
unshelve.changes.dialog.title=取消擱置更改
unshelve.changes.progress.title=正在取消擱置更改…
unshelve.loading.patch.error=無法載入更新檔\\: {0}
update.can.t.load.content=無法載入內容
update.checkbox.don.t.show.again=不再顯示
update.directories.scope.name=目錄
update.directory.scope.name=目錄
update.error.label=錯誤\\: 
update.file.name.wasn.t.modified={0} 未修改
update.file.scope.name=檔案
update.files.scope.name=檔案
update.filtered.files.count.in.filter.name={0} ({1} 內)
update.group.name.created=已建立
update.group.name.deleted=已刪除
update.group.name.locally.added=本地已新增
update.group.name.locally.removed=本地已移除
update.group.name.merged=已合併
update.group.name.merged.with.conflicts=已合併，但存在衝突
update.group.name.merged.with.property.conflicts=已合併，但存在屬性衝突
update.group.name.merged.with.tree.conflicts=已合併，但存在樹衝突
update.group.name.modified=已修改
update.group.name.not.in.repository=不在版本庫中
update.group.name.restored=已還原
update.group.name.skipped=已跳過
update.group.name.switched=已切換
update.group.name.updated=已更新
update.group.name.updated.from.server=從伺服器更新
update.info.click.status.text.prefix=點擊
update.info.group.by.changelist=按更改列表分組
update.info.loading.changelists=正在載入更改列表…
update.info.refresh.link.status.text=重新整理
update.info.to.initialize.status.text.suffix=以初始化版本庫更改快取
update.label.after.update=更新後
update.label.before.update=更新前
update.notification.content.files.updated={0,choice,1\\#1 個檔案|2\\#{0} 個檔案}已更新
update.notification.content.view=檢視
update.notification.title.count.files.updated={0,choice,1\\#1 個檔案|2\\#{0} 個檔案}已更新
update.notification.title.project.partially.updated=專案已部分更新
update.project.scope.name=專案
update.tree.node.size.statistics={0,choice, 0\\#無條目|1\\#1 個條目|2\\#{0, number} 個條目}
user.group.title=使用者
vcs.add.to.ignore.file.action.group.description=將所選檔案新增到 {0}
vcs.add.to.ignore.file.action.group.text=新增到 {0}
vcs.add.to.ignore.file.create.ignore.file.confirmation.message=在 {1} 中建立 {0} 檔案?
vcs.add.to.ignore.file.create.ignore.file.confirmation.title=建立 {0}
vcs.command.name.add=新增
vcs.command.name.checkin=提交(_I)
vcs.command.name.checkout=簽出
vcs.command.name.edit=編輯
vcs.command.name.remove=移除
vcs.command.name.status=狀態
vcs.command.name.update=更新
vcs.commit.canceled=提交已取消
vcs.commit.files.committed={0,choice,0\\#無檔案|1\\#{0} 個檔案|2\\#{0} 個檔案}已提交
vcs.commit.files.committed.and.files.failed.to.commit={0,choice,0\\#無檔案|1\\#{0} 個檔案|2\\#{0} 個檔案}已提交，{1,choice,1\\#{1} 個檔案|2\\#{1} 個檔案}提交失敗
vcs.commit.notification.shareProjectOn=在 {0} 上共享專案
vcs.commit.notification.shareProjectOn.orOn=基於 {0}
vcs.common.labels.directory=目錄\\:
vcs.common.labels.url=URL\\:
vcs.common.labels.vcs=VCS\\:
vcs.common.labels.version.control=版本控制\\:
vcs.config.track.changed.on.server=檢查與伺服器衝突的時間間隔
vcs.console.toolwindow.display.name=主控台
vcs.dnd.image.text.n.files={0} 個{0, choice, 1\\#檔案|2\\#檔案}
vcs.error.failed.to.load.file.content.from.vcs=無法載入內容
vcs.generic.name=VCS
vcs.generic.name.with.mnemonic=VCS(_S)
vcs.local.changes.toolbar=VCS 本地更改工具列
vcs.operations.popup=VCS 動作彈出視窗
vcs.preview.panel.added.ignored.line=已新增忽略的行
vcs.preview.panel.added.line=已新增行
vcs.preview.panel.deleted.ignored.line.below=已刪除以下忽略的行
vcs.preview.panel.deleted.line.below=以下已刪除的行
vcs.preview.panel.last.commit.modified.line=上次提交中修改的行
vcs.preview.panel.line.with.modified.whitespaces=帶有修改的空格的行
vcs.preview.panel.line.with.modified.whitespaces.and.deletion.after=帶有修改的空格和後續刪除的行
vcs.preview.panel.modified.ignored.line=已修改忽略的行
vcs.preview.panel.modified.line=已修改的行
vcs.quicklist.popup.title=VCS 動作
vcs.revision.name.current=當前
vcs.settings.path=設定 | 版本控制
vcs.settings.path.mac=偏好設定 | 版本控制
vcs.shelf.action.restore.description=還原最近刪除的{0, choice, 1\\#更改列表|2\\#更改列表}
vcs.shelf.action.restore.text=還原
vcs.shelf.move.text=將擱置移至新位置(&M)
vcs.shelf.store.base.content=擱置分布式版本控制系統下檔案的基本修訂版本
vcs.shelving.changes=正在擱置更改…
vcs.unshelving.changes=正在取消擱置更改…
vcs.unshelving.conflict.left=您未提交的更改
vcs.unshelving.conflict.right=遠端更改
vcs.update.tab.name=更新資訊
version.control.main.configurable.description=<html><body>組態與專案中使用的版本控制相關的設定
version.control.main.configurable.name=版本控制
vfs.revision.author.unknown=未知
waiting.changelists.update.for.show.commit.dialog.message=提交
"
`;

exports[`dev messages/VcsLogBundle.properties 1`] = `
"action.ShowCommitTooltipAction.description=在日誌中為當前所選提交顯示工具提示
action.ShowCommitTooltipAction.text=顯示提交工具提示
action.Vcs.Log.AlignLabels.description=在提交訊息左側顯示參照
action.Vcs.Log.AlignLabels.text=左側的參照
action.Vcs.Log.AnnotateRevisionAction.description=註解所選修訂
action.Vcs.Log.AnnotateRevisionAction.text=註解
action.Vcs.Log.CompactReferencesView.description=僅在表中顯示提交的第一個參照
action.Vcs.Log.CompactReferencesView.text=緊湊型參照檢視
action.Vcs.Log.CompareRevisions.description=比較選定版本
action.Vcs.Log.CompareRevisions.text=比較版本
action.Vcs.Log.EnableFilterByRegexAction.text=正則表達式
action.Vcs.Log.FocusTextFilter.description=聚焦文本篩選器或將焦點移回提交列表
action.Vcs.Log.FocusTextFilter.text=聚焦文本篩選器
action.Vcs.Log.GoToChild.description=導覽到提交圖中的子行
action.Vcs.Log.GoToChild.text=轉到子提交
action.Vcs.Log.GoToParent.description=導覽到提交圖中的父行
action.Vcs.Log.GoToParent.text=轉到父提交
action.Vcs.Log.GoToRef.description=指定分支或標記的雜湊或名稱，以導覽到其指向的提交
action.Vcs.Log.GoToRef.text=轉到雜湊/分支/標記
action.Vcs.Log.MatchCaseAction.text=區分大小寫
action.Vcs.Log.MoveDiffPreviewToBottom.description=在底部找到差異預覽
action.Vcs.Log.MoveDiffPreviewToBottom.text=底部
action.Vcs.Log.MoveDiffPreviewToRight.description=在右側找到差異預覽
action.Vcs.Log.MoveDiffPreviewToRight.text=右側
action.Vcs.Log.OpenRepositoryVersion.description=在編輯器中開啟檔案的所選修訂
action.Vcs.Log.OpenRepositoryVersion.text=按修訂顯示檔案
action.Vcs.Log.PreferCommitDate.description=顯示提交更改的時間，而不是建立時間
action.Vcs.Log.PreferCommitDate.text=提交時間戳
action.Vcs.Log.Refresh.description=檢查新提交，必要時重新整理日誌
action.Vcs.Log.Refresh.text=重新整理
action.Vcs.Log.ResumeIndexing.description=索引編制已暫停，因為它花費的時間比預期長。恢復。
action.Vcs.Log.ResumeIndexing.text=恢復索引編制
action.Vcs.Log.SelectInLog.text=在 VCS 日誌中顯示
action.Vcs.Log.SelectInLog.text.template=在 {0} 日誌中顯示
action.Vcs.Log.ShowAllAffected.description=顯示選中修訂中所做的所有更改
action.Vcs.Log.ShowAllAffected.text=顯示所有受影響的檔案
action.Vcs.Log.ShowBigRepositories.text=顯示已停用索引的版本庫
action.Vcs.Log.ShowChangesFromParents.description=分別顯示對每個合併提交所做的更改
action.Vcs.Log.ShowChangesFromParents.text=顯示對父項的更改
action.Vcs.Log.ShowDetailsAction.description=顯示詳細資訊面板
action.Vcs.Log.ShowDetailsAction.text=顯示詳細資訊
action.Vcs.Log.ShowDiffPreview.description=顯示差異預覽面板
action.Vcs.Log.ShowDiffPreview.text=顯示差異預覽
action.Vcs.Log.ShowLongEdges.description=即使提交在當前檢視中不可見，也顯示長分支邊。
action.Vcs.Log.ShowLongEdges.text=長邊
action.Vcs.Log.ShowOnlyAffectedChanges.description=僅顯示影響“路徑”選單中所選檔案的更改
action.Vcs.Log.ShowOnlyAffectedChanges.text=僅顯示受影響的更改
action.Vcs.Log.ShowRootsColumnAction.text=根名稱
action.Vcs.Log.ShowSettingsAction.GoToAction.text=VCS 日誌設定
action.Vcs.Log.ShowSettingsAction.text=設定
action.Vcs.Log.ShowTagNames.description=在表中顯示標籤名稱
action.Vcs.Log.ShowTagNames.text=標籤名稱
action.Vcs.Log.ShowTooltip.description=在日誌中為當前選定提交顯示工具提示
action.Vcs.Log.ShowTooltip.text=顯示提交工具提示
action.Vcs.Show.Log.text=顯示 VCS 日誌
action.Vcs.Show.Log.text.template=顯示 {0} 日誌
action.description.collapse.linear.branches=摺疊線性分支
action.description.collapse.merges=摺疊合併
action.description.expand.linear.branches=展開線性分支
action.description.expand.merges=展開合併
action.description.is.scheduled=為 {0} 編制索引已計劃。暫停。
action.description.was.disabled=索引 {0} 已停用。啟用。
action.description.was.paused=為 {0} 編制索引已暫停。恢復。
action.go.to.navigate.to=導覽到 {0}
action.go.to.select.child.to.navigate=選擇要導覽的子項
action.go.to.select.hash.subject.author.date.time={0} {1}，作者 {2}，{3} {4}
action.go.to.select.parent.to.navigate=選擇要導覽的父項
action.help.tooltip.resume.indexing=為專案版本庫編制索引可以改進整個 IDE 中對更改歷史記錄的處理\\:<br/>- 快速日誌篩選和計算精確歷史記錄<br/>- 用於修訂的檔案歷史記錄中的分支篩選器<br/>- 在“隨處搜尋”中跨歷史記錄進行搜尋
action.presentation.CompareRevisionsFromFileHistoryActionProvider.description.compare=比較所選版本
action.presentation.CompareRevisionsFromFileHistoryActionProvider.description.show.diff=顯示與之前版本的差異
action.presentation.CompareRevisionsFromFileHistoryActionProvider.text.compare=比較
action.presentation.CompareRevisionsFromFileHistoryActionProvider.text.show.diff=顯示差異
action.process.collapsing.linear.branches=正在摺疊線性分支…
action.process.collapsing.merges=正在摺疊合併…
action.process.expanding.linear.branches=正在展開線性分支…
action.process.expanding.merges=正在展開合併…
action.title.collapse.linear.branches=摺疊線性分支
action.title.collapse.merges=摺疊合併
action.title.enable.indexing=啟用 {0} 日誌索引
action.title.expand.linear.branches=展開線性分支
action.title.expand.merges=展開合併
action.title.match.case=區分大小寫
action.title.match.case.only.supported=區分大小寫(僅限 {0})
action.title.pause.indexing=暫停 {0} 日誌索引編制
action.title.resume.indexing=恢復 {0} 日誌索引編制
action.vcs.log.branches.separator=分支動作
action.vcs.log.graph.options.separator=選項
action.vcs.log.highlight.separator=醒目提示顯示
action.vcs.log.show.separator=顯示
action.vcs.log.sort.type.separator=排序
activity.tracker.vcs.log=VCS 日誌索引
dialog.title.paths.affected.by.commit=受提交 {0} 影響的路徑
file.history.action.could.not.load.selected.commits.message=無法載入所選提交\\: {0}
file.history.commit.not.found={1} 的歷史記錄中不存在 {0}
file.history.commit.not.found.in.branch=所選分支中 {1} 的歷史記錄中沒有 {0}
file.history.commit.not.found.view.and.show.all.branches.link=檢視並顯示所有分支
file.history.commit.not.found.view.in.log.link=在日誌中檢視
file.history.diff.preview.editor.tab.name=歷史記錄\\: {0}
file.history.empty.status=檔案歷史記錄
file.history.error.status=計算檔案歷史記錄時出錯
file.history.reset.filters.status.action=重設篩選器
file.history.show.commit.in.history.process=正在檔案歷史記錄中搜尋提交 {0}
file.history.toolbar=檔案歷史工具列
filetype.vcs.log.description=VSC 日誌
graph.options.first.parent=第一個父項
graph.options.first.parent.description=看到合併提交後，僅跟隨第一個父提交
graph.options.linear=線性化合併
graph.options.linear.description=合併時，在 main 分支提交的頂部顯示傳入提交，就好像對它們進行重定基底
graph.options.linear.presentation=已線性化
graph.sort.off=按提交日期
graph.sort.off.description=按提交日期以拓撲方式對提交進行排序
graph.sort.standard=以拓撲方式
graph.sort.standard.description=合併時，首先在合併提交正下方顯示傳入提交
group.Log.KeymapGroup.text=日誌
group.Vcs.FileHistory.PresentationSettings.description=組態檔案歷史記錄的表示
group.Vcs.FileHistory.PresentationSettings.text=檢視選項
group.Vcs.Log.ChangesBrowser.PresentationSettings.text=檢視選項
group.Vcs.Log.Diff.Preview.Location.text=差異預覽位置
group.Vcs.Log.GraphOptionsGroup.description=VCS 日誌圖選項和動作
group.Vcs.Log.GraphOptionsGroup.text=圖選項
group.Vcs.Log.Internal.text=VSC 日誌
group.Vcs.Log.LayoutConfiguration.description=組態視窗布局
group.Vcs.Log.LayoutConfiguration.separator.text=布局
group.Vcs.Log.LayoutConfiguration.text=組態布局
group.Vcs.Log.PresentationSettings.description=組態日誌的表示
group.Vcs.Log.PresentationSettings.text=檢視選項
group.Vcs.Log.TextFilterSettings.description=選擇文本篩選器選項
group.Vcs.Log.TextFilterSettings.text=文本篩選器設定
group.Vcs.Log.ToggleColumns.description=選擇要在表中檢視的列
group.Vcs.Log.ToggleColumns.text=列
loading.commit.changes=正在載入提交更改
prefer.commit.timestamp.action.text.show=顯示提交時間戳
vcs=VCS
vcs.log.action.description.open.new.tab.with.log=開啟包含 {0} 日誌的新頁籤
vcs.log.action.description.open.new.tab.with.log.in.editor=在編輯器中開啟包含 {0} 日誌的新頁籤
vcs.log.action.highlight.current.branch=當前分支
vcs.log.action.highlight.indexed.commits=已編制索引的提交
vcs.log.action.highlight.merge.commits=合併提交
vcs.log.action.highlight.my.commits=我的提交
vcs.log.action.open.new.tab.with.log=開啟新的 {0} 日誌頁籤
vcs.log.action.open.new.tab.with.log.in.editor=開啟新的 {0} 日誌編輯器頁籤
vcs.log.action.show.in.file.history.text=在檔案歷史記錄中顯示
vcs.log.applying.filters.process=正在套用篩選器…
vcs.log.big.repositories.dialog.title=已停用索引的版本庫
vcs.log.bookmark.description.empty.subject=(無訊息)
vcs.log.bookmark.label=書籤
vcs.log.bookmark.label.mnemonic=為 ''{0}'' 新增書籤
vcs.log.branch.filter.action.text=按分支篩選
vcs.log.branch.filter.favorites=收藏夾
vcs.log.branch.filter.label=分支
vcs.log.changes.accessible.name=提交更改瀏覽器
vcs.log.changes.browser.toolbar=VCS 日誌更改瀏覽器工具列
vcs.log.changes.changes.to.parent.node=對 {0} 的更改
vcs.log.changes.details.no.commits.selected.status=未選擇提交
vcs.log.changes.no.changes.that.affect.selected.paths.status=沒有影響所選路徑的更改。
vcs.log.changes.no.merge.conflicts.node=沒有合併的衝突
vcs.log.changes.no.merge.conflicts.status=沒有合併的衝突。
vcs.log.changes.select.commits.to.view.changes.status=選擇要檢視更改的提交
vcs.log.changes.show.all.paths.status.action=顯示所有路徑的更改
vcs.log.changes.show.changes.to.parents.status.action=顯示對父項的更改
vcs.log.changes.too.many.show.anyway.status.action=仍然顯示
vcs.log.changes.too.many.status={0,choice,1\\#此提交|2\\#所選提交之一}具有 {1} 個更改
vcs.log.clear.caches.checkbox.description=清除 VCS 日誌快取和索引
vcs.log.click.to.collapse.paths.column.tooltip=點擊以摺疊
vcs.log.click.to.expand.paths.column.tooltip=點擊以展開
vcs.log.column.author=作者
vcs.log.column.date=日期
vcs.log.column.hash=雜湊
vcs.log.column.subject=主題
vcs.log.commit.details.status=提交詳細資訊
vcs.log.commit.does.not.match={0} 與篩選器不符合
vcs.log.commit.does.not.match.view.and.reset.link=檢視並重設篩選器
vcs.log.commit.does.not.match.view.in.tab.link=在新頁籤中檢視
vcs.log.commit.not.found=找不到 {0}
vcs.log.commit.or.reference.prefix=提交或參照 ''{0}''
vcs.log.commit.prefix=提交 ''{0}''
vcs.log.commit.status.action=提交本地更改
vcs.log.creating.process=正在載入提交…
vcs.log.date.filter.action.last.day=過去 24 小時
vcs.log.date.filter.action.last.week=過去 7 天
vcs.log.date.filter.action.text=按日期篩選
vcs.log.date.filter.label=日期
vcs.log.date.filter.select.period.dialog.title=選擇期間
vcs.log.date.filter.since=自 {0}
vcs.log.date.filter.until=到 {0}
vcs.log.default.status=更改日誌
vcs.log.details.author.on.date.at.time=作者 {0}，{1} {2}
vcs.log.details.committer.info.date.time=在 {0} {1} 提交
vcs.log.details.committer.info.user=由 {0} 提交
vcs.log.details.committer.info.user.date.time=由 {0} 於 {1} {2} 提交
vcs.log.details.in.branches=在 {0,choice,1\\#{0} 個分支|2\\#{0} 個分支}中\\:
vcs.log.details.in.branches.empty=不在任何分支中
vcs.log.details.in.branches.hide=隱藏
vcs.log.details.in.branches.loading=在分支中\\: 正在載入…
vcs.log.details.in.branches.show.all=全部顯示
vcs.log.details.references.more.label=…其他 {0} 個
vcs.log.details.showing.selected.commits=(正在顯示 {0}/{1} 個所選提交)
vcs.log.diff.preview.editor.empty.tab.name=版本庫差異
vcs.log.diff.preview.editor.tab.name=版本庫差異\\: {0}
vcs.log.duplicated.tab.id.error=“VCS 日誌”頁籤不能開啟兩次
vcs.log.editor.name=VCS 日誌編輯器
vcs.log.error.filtering.status=篩選提交時出錯
vcs.log.error.loading.changes.status=載入更改時出錯
vcs.log.error.loading.commits.status=載入提交時出錯
vcs.log.error.loading.details.status=載入提交詳細資訊時出錯
vcs.log.failed.loading.details=無法在 {1} 中載入提交 {0} 的詳細資訊
vcs.log.fatal.error.message=無法使 {0} 下的快取失效。\\n請手動刪除快取目錄，然後重啟 {1}。
vcs.log.filter.accessible.name={0}\\: {1}
vcs.log.filter.action.select=選擇…
vcs.log.filter.all=所有
vcs.log.filter.branch.presentation.with.prefix=在 {0} 上
vcs.log.filter.clear=清除
vcs.log.filter.date.display.name.after=自 {0}
vcs.log.filter.date.display.name.before=到 {0}
vcs.log.filter.date.display.name.between={0} 和 {1} 之間
vcs.log.filter.date.presentation.with.prefix.made.after=生成自 {0}
vcs.log.filter.date.presentation.with.prefix.made.before=生成到 {0}
vcs.log.filter.date.presentation.with.prefix.made.between=在 {0} 與 {1} 之間進行
vcs.log.filter.edit.folders=選擇…
vcs.log.filter.no.merges=無合併
vcs.log.filter.popup.advertisement.text=選擇一個或多個用 {0} 分隔的值
vcs.log.filter.popup.advertisement.text.new.lines=新行
vcs.log.filter.popup.advertisement.text.or.suffix=或{0}
vcs.log.filter.popup.advertisement.with.key.text=選擇一個或多個用 {0} 分隔的值，並使用 {1} 完成
vcs.log.filter.popup.no.folders=無路徑
vcs.log.filter.popup.no.items=沒有項
vcs.log.filter.popup.no.roots=沒有根
vcs.log.filter.popup.paths=路徑
vcs.log.filter.recent=最近
vcs.log.filter.root.presentation.with.prefix=在 {0} 中
vcs.log.filter.roots=根
vcs.log.filter.select.folders=在樹中選擇…
vcs.log.filter.structure.presentation.with.prefix=用於 {0}
vcs.log.filter.text.hash.empty.text=文本或雜湊
vcs.log.filter.text.hash.tooltip=按提交訊息或雜湊篩選
vcs.log.filter.text.presentation.with.prefix=包含 {0}
vcs.log.filter.tooltip.click.to.see.only={0}+點擊以僅檢視“{1}”
vcs.log.filter.tooltip.folders=路徑\\:
vcs.log.filter.tooltip.no.roots.selected=未選擇根
vcs.log.filter.tooltip.roots=根\\:
vcs.log.filter.user.presentation.with.prefix=被 {0} 使用
vcs.log.filters.structure.label=已選擇\\: {0}
vcs.log.filters.structure.max.selected.error.message=您已新增 {0} 個元素。不允許更多元素。
vcs.log.go.to.hash.popup.label=輸入雜湊或分支/標記名稱\\:
vcs.log.graph.arrow.tooltip.jump.to.hash=跳轉到提交 {0}
vcs.log.graph.arrow.tooltip.jump.to.hash.in.root=跳轉到 {1} 中的提交 {0}
vcs.log.graph.arrow.tooltip.jump.to.subject.author.date.time=跳轉到 {0} (作者 {1}，{2} {3})
vcs.log.index.diagnostic.action.title=檢查舊提交的 VCS 日誌索引資料
vcs.log.index.diagnostic.error.attribute.name.author=作者
vcs.log.index.diagnostic.error.attribute.name.author.time=作者日期
vcs.log.index.diagnostic.error.attribute.name.committer=提交者
vcs.log.index.diagnostic.error.attribute.name.committer.time=提交日期
vcs.log.index.diagnostic.error.attribute.name.message=訊息
vcs.log.index.diagnostic.error.attribute.name.parents=父項
vcs.log.index.diagnostic.error.filter=按 {0} 篩選不會返回 {1}
vcs.log.index.diagnostic.error.for.commit=提交 {0} 的差異\\n{1}
vcs.log.index.diagnostic.error.message=應為 {0}\\: {1}，實際為 {0}\\: {2}
vcs.log.index.diagnostic.progress.title=正在執行 VCS 日誌索引診斷
vcs.log.index.diagnostic.report.title=VCS 日誌索引診斷報告 {0}
vcs.log.index.diagnostic.selected.action.title=檢查所選提交的 VCS 日誌索引資料
vcs.log.index.diagnostic.selected.non.indexed.warning.message=所選提交未編制索引
vcs.log.index.diagnostic.success.message={0} 個已檢查{0,choice,1\\#提交|2\\#提交}的 VCS 日誌索引資料正確
vcs.log.invalidate.caches.progress=正在使 {0} 日誌快取和索引失效
vcs.log.invalidate.caches.text=使 {0} 日誌快取和索引失效
vcs.log.is.loading=正在載入 VCS 日誌…
vcs.log.is.not.available=VCS 日誌不可用
vcs.log.loading.selected.details.process=正在載入所選詳細資訊
vcs.log.loading.status=正在載入提交…
vcs.log.no.commits.matching.status=沒有與篩選器符合的提交
vcs.log.no.commits.status=未提交更改。
vcs.log.path.filter.action.text=按路徑篩選
vcs.log.references.more.tooltip=…詳細資訊窗格中的其他 {0} 項
vcs.log.refresh.status.action=重新整理
vcs.log.reset.filters.status.action=重設篩選器
vcs.log.right.corner.toolbar=VCS 日誌工具列
vcs.log.select.folder.dialog.title=選擇要篩選的路徑
vcs.log.settings.diff.preview.location=位置\\:
vcs.log.settings.enable.index.checkbox=為專案啟用索引編制{0,choice,0\\#|1\\# (僅 {1})}
vcs.log.settings.enable.index.checkbox.comment=改進跨 IDE 的更改歷史記錄的處理
vcs.log.settings.group.file.history.title=檔案歷史記錄
vcs.log.settings.group.indexing.title=正在編制索引
vcs.log.settings.group.title=日誌
vcs.log.settings.show.file.names=顯示檔名
vcs.log.settings.visible.columns=可見列
vcs.log.show.commit.in.log.process=正在日誌中搜尋提交 {0}
vcs.log.status.bar.indexing={0} 日誌正在編制索引…
vcs.log.status.bar.indexing.cancel.cancelling=正在取消
vcs.log.status.bar.indexing.cancel.tooltip=取消索引編制。可以從 {0} 日誌工具列手動重啟索引編制。
vcs.log.string.is.not.a.hash=''{0}'' 看起來不像提交雜湊
vcs.log.tab.name=日誌
vcs.log.table.accessible.name={0} 日誌
vcs.log.text.filter.accessible.name={0} 日誌文本或雜湊篩選器
vcs.log.text.filter.action.text=按文本或雜湊篩選
vcs.log.user.filter.action.text=按使用者篩選
vcs.log.user.filter.label=使用者
vcs.log.user.filter.me=我
vcs.log.wip.label=新增提交…
"
`;

exports[`src inspectionDescriptions/LeakableMapKey.html 1`] = `
"<html>
<body>
報告在延伸模組程式碼中將 <code>Language</code> 或 <code>FileType</code> 用作映射鍵。
<p>
  此類別用法可能導致無法正確解除安裝延伸模組。
</p>
<p>
  請考慮使用 <code>String</code> 作為鍵。
</p>
<p>
  有關詳情，請參閱 SDK 文檔中的<a href="https://plugins.jetbrains.com/docs/intellij/dynamic-plugins.html">動態延伸模組</a>。
</p>
</body>
</html>"
`;

exports[`src messages/ActionsBundle.properties 1`] = `
"MainToolbarQuickActions.BackForward.text=後退/前進
MainToolbarQuickActions.Build.text=建置
MainToolbarQuickActions.SaveAll.text=全部儲存
NewFile.popup.title=新
Vcs.VcsClone.Tabbed.Welcome.text=克隆儲存庫
Vcs.VcsClone.Welcome.text=從版本控制中獲取
action.$Copy.description=複製到剪貼簿
action.$Copy.text=複製(_C)
action.$Cut.description=剪下到剪貼簿
action.$Cut.text=剪下(_T)
action.$Delete.description=刪除所選條目
action.$Delete.text=刪除(_D)
action.$Paste.description=從剪貼簿貼上
action.$Paste.text=貼上(_P)
action.$Redo.text=重做
action.$SearchWeb.description=使用 Google 搜尋選區
action.$SearchWeb.text=使用 Google 搜尋(_S)
action.$SelectAll.description=全選
action.$SelectAll.text=全選(_A)
action.$Undo.text=撤消
action.About.description=顯示有關 IDE 的資訊
action.About.description.specialized=顯示有關 {0} 的資訊
action.About.text=關於(_A)
action.Actions.ActionsPlugin.GenerateToString.description=生成 toString() 方法
action.Actions.ActionsPlugin.GenerateToString.text=to_String()
action.ActivateDebugToolWindow.text=偵錯
action.ActivateFindToolWindow.text=尋找
action.ActivateHierarchyToolWindow.text=層次結構
action.ActivateMeetNewUIToolWindow.text=組態新 UI
action.ActivateRunToolWindow.text=執行
action.AddAnotherBookmark.text=將書籤新增到另一個列表
action.AddBom.text=新增 BOM
action.AddBreakpoint.text=新增中斷點
action.AddConditionalBreakpoint.text=新增條件中斷點…
action.AddFrameworkSupport.text=新增框架支援…
action.AddGroupToTestSchemeAction.description=允許來自組的所有資料。使用它在本地測試新的收集器。
action.AddGroupToTestSchemeAction.text=將組新增到事件測試方案
action.AddInlayBlockInternalAction.text=新增塊嵌入…
action.AddInlayInternalAction.text=新增嵌入…
action.AddLoggingBreakpoint.text=新增日誌記錄中斷點…
action.AddToScopeAction.text=新增到作用域
action.AllRunConfigurationsToggle.text=切換所有執行/偵錯組態
action.AnalyzeHeapDumpSnapshot.text=分析堆傾印
action.AnalyzePluginStartupPerformance.text=分析延伸模組啟動性能
action.AnimatorTestAction.text=測試 Animator
action.Annotate.description=顯示每行的最新修改日期和作者(也稱為“追溯”)
action.Annotate.synonym1=追溯
action.Annotate.text=註解(_N)
action.Annotate.with.Blame.text=使用 Git 追溯註解(_N)
action.AnnotateStackTraceAction.show.files.modification.info.text=顯示檔案修改資訊
action.AnonymousToInner.description=將匿名類別轉換為內部類別
action.AnonymousToInner.text=將匿名轉換成內部(_Y)…
action.ApplyFixedWindowSize.text=套用特定大小
action.AssociateWithFileType.description=將所選檔案關聯到某種檔案類型
action.AssociateWithFileType.text=與檔案類型關聯…
action.AttachDirectory.text=將目錄附加到專案…
action.AttachProject.text=附加專案…
action.AutoIndentLines.description=根據程式碼樣式設定縮排當前行或所選塊
action.AutoIndentLines.text=自動縮排行(_A)
action.AutoShowProcessWindow.description=啟動任何程序時顯示背景任務視窗
action.AutoShowProcessWindow.text=自動顯示
action.Back.description=撤消上次導覽動作
action.Back.text=後退(_B)
action.BookmarkOpenTabs.text=書籤開啟頁籤…
action.BookmarksView.AskBeforeDeletingLists.text=刪除多個書籤前詢問
action.BookmarksView.AutoscrollFromSource.text=始終選擇開啟的元素
action.BookmarksView.AutoscrollToSource.text=一鍵導覽
action.BookmarksView.ChooseType.text=更改助記符…
action.BookmarksView.Create.text=建立書籤列表…
action.BookmarksView.DefaultGroup.text=將列表標記為預設
action.BookmarksView.Delete.text=刪除
action.BookmarksView.DeleteType.text=移除助記鍵
action.BookmarksView.GroupLineBookmarks.text=按檔案將行書簽分組
action.BookmarksView.MoveDown.text=下移
action.BookmarksView.MoveUp.text=上移
action.BookmarksView.OpenInPreviewTab.text=啟用預覽頁籤
action.BookmarksView.Rename.text=編輯
action.BookmarksView.RewriteBookmarkType.text=覆寫助記鍵之前詢問
action.BookmarksView.ShowPreview.text=開啟編輯器預覽
action.BookmarksView.SortGroupBookmarks.text=按類型和名稱對書籤進行排序
action.BraceOrQuoteOut.text=跳到當前括號/引號
action.BrowseSpecialPaths.text=特殊檔案和目錄
action.BrowseWeb.text=瀏覽 Web…
action.BuildArtifact.description=選擇並建置專案中組態的工件
action.BuildArtifact.text=建置工件…
action.CallHierarchy.BaseOnThisMethod.text=基於此方法
action.CallHierarchy.description=瀏覽所選方法的呼叫層次結構
action.CallHierarchy.text=呼叫層次結構(_Y)
action.CallInlineCompletionAction.description=為當前游標位置生成建議，並將其顯示為內聯
action.CallInlineCompletionAction.text=呼叫內聯補全
action.CallSaul.description=執行快取診斷並嘗試恢復其狀態
action.CallSaul.on.file.text=修復{0, choice, 0\\#檔案|2\\#檔案}上的 IDE
action.CallSaul.text=修復 IDE
action.ChangeCodeStyleScheme.description=更改當前程式碼樣式方案
action.ChangeCodeStyleScheme.text=程式碼樣式方案
action.ChangeColorScheme.description=更改當前編輯器配色方案
action.ChangeColorScheme.text=編輯器配色方案
action.ChangeFileEncodingAction.description=更改檔案編碼
action.ChangeFileEncodingAction.text=檔案編碼
action.ChangeIdeScale.text=縮放
action.ChangeInspectionProfile.description=更改當前編輯器檢查組態檔案
action.ChangeInspectionProfile.text=錯誤醒目提示顯示
action.ChangeKeymap.description=更改當前按鍵映射
action.ChangeKeymap.text=按鍵映射
action.ChangeLaf.description=更改當前主題
action.ChangeLaf.text=主題
action.ChangeMainMenu.restart.dialog.title=更新“主選單”設定
action.ChangeSignature.description=更改所選方法或類別的簽名，並更正所有參照
action.ChangeSignature.text=更改簽名(_G)…
action.ChangeSortingAction.text=按名稱排序
action.ChangeSplitOrientation.description=更改拆分器方向
action.ChangeSplitOrientation.text=更改拆分器方向(_R)
action.ChangeTemplateDataLanguage.text=更改模板資料語言
action.ChangeToThisFileTypeAction.description=將檔案類型覆寫為 ''{0}''
action.ChangeToolWindowLayout.GoToAction.text=切換工具視窗布局
action.ChangeToolWindowLayout.text=布局
action.ChangeTypeSignature.description=更改方法、欄位、參數、變數或類別類型實參的返回值類型，並更正所有參照
action.ChangeTypeSignature.text=類型遷移(_Y)…
action.ChangeView.description=更改檢視模式
action.ChangeView.text=檢視模式
action.ChangesView.AddUnversioned.description=排定將所選檔案新增到 VCS 的時間表
action.ChangesView.AddUnversioned.text=新增到 VCS
action.ChangesView.ApplyPatch.description=將補丁套用到專案的源
action.ChangesView.ApplyPatch.text=套用補丁…
action.ChangesView.ApplyPatchFromClipboard.description=將補丁套用到專案的源
action.ChangesView.ApplyPatchFromClipboard.text=從剪貼簿套用補丁…
action.ChangesView.Browse.description=檢視已提交更改的歷史記錄
action.ChangesView.Browse.text=瀏覽更改…
action.ChangesView.CreatePatch.description=從所選更改建立補丁
action.ChangesView.CreatePatch.text=從本地更改建立補丁…
action.ChangesView.CreatePatchFromChanges.description=從所選更改建立補丁
action.ChangesView.CreatePatchFromChanges.text=建立補丁…
action.ChangesView.CreatePatchToClipboard.description=從更改建立補丁並將其複製到剪貼簿
action.ChangesView.CreatePatchToClipboard.text=作為補丁複製到剪貼簿
action.ChangesView.Edit.description=簽出所選檔案進行編輯
action.ChangesView.Edit.text=簽出
action.ChangesView.GroupBy.Directory.text=目錄
action.ChangesView.GroupBy.Module.text=模組
action.ChangesView.GroupBy.Repository.text=儲存庫
action.ChangesView.Move.Files.text=將檔案移動到另一個更改列表…
action.ChangesView.Move.description=將所選更改移至另一個更改列表
action.ChangesView.Move.text=移至另一個更改列表…
action.ChangesView.NewChangeList.description=建立新的更改列表
action.ChangesView.NewChangeList.text=新增更改列表…
action.ChangesView.Refresh.MainMenu.text=重新整理 VCS 更改
action.ChangesView.Refresh.description=重新整理 VCS 更改
action.ChangesView.Refresh.text=重新整理
action.ChangesView.RemoveChangeList.description=移除更改列表並將所有更改移至其他更改列表
action.ChangesView.RemoveChangeList.description.template=移除{0,choice,0\\#更改列表|2\\#更改列表}和移動所有的改變到{1}
action.ChangesView.RemoveChangeList.text=刪除更改列表
action.ChangesView.RemoveChangeList.text.template=刪除{0,choice,0\\#更改列表|2\\#更改列表}
action.ChangesView.RemoveDeleted.description=排定將所選檔案從 VCS 移除的時間表
action.ChangesView.RemoveDeleted.text=從 VCS 移除
action.ChangesView.Rename.description=編輯所選更改列表的名稱和描述
action.ChangesView.Rename.text=編輯更改列表…
action.ChangesView.Revert.text=回滾(_R)…
action.ChangesView.RevertFiles.text=回滾檔案(_R)…
action.ChangesView.SaveToShelve.description=將所選更改複製到擱置的更改列表
action.ChangesView.SaveToShelve.text=儲存到擱置
action.ChangesView.SetDefault.description=設定預設情況下放置新更改的更改列表
action.ChangesView.SetDefault.text=設定活動更改列表
action.ChangesView.Shelve.description=將更改儲存到外部補丁檔案，並將其從程式碼中移除
action.ChangesView.Shelve.text=擱置更改…
action.ChangesView.ShelveSilently.description=擱置對適當的已擱置更改列表的更改
action.ChangesView.ShelveSilently.text=無提示擱置
action.ChangesView.ShowCommitOptions.text=顯示提交選項
action.ChangesView.SingleClickPreview.text=預覽差異
action.ChangesView.ToggleCommitUi.text=切換提交 UI…
action.ChangesView.UnshelveSilently.description=取消擱置對相應更改列表的更改
action.ChangesView.UnshelveSilently.text=無提示取消擱置
action.CheckForUpdate.WelcomeScreen.text=檢查更新
action.CheckForUpdate.description=檢查可用的 IDE 和延伸模組更新
action.CheckForUpdate.description.plugins=檢查可用的延伸模組更新(IDE 更新在外部管理)
action.CheckForUpdate.text=檢查更新(_C)…
action.CheckIgnoredAndNotExcludedDirectories.description=檢查是否存在可以排除在索引和搜尋之外的已忽略目錄
action.CheckIgnoredAndNotExcludedDirectories.progress=正在檢查已忽略但未排除的目錄…
action.CheckIgnoredAndNotExcludedDirectories.text=檢查已忽略但未排除的目錄
action.CheckStatusForFiles.text=檢查狀態(_K)
action.CheckSuggestedPlugins.text=檢查推薦的延伸模組
action.CheckVfsSanity.progress=檢查 VFS 執行狀況(檢視日誌中的結果)
action.CheckVfsSanity.text=執行 VFS 執行狀況檢查
action.CheckinFiles.description=提交選中的檔案或目錄
action.CheckinFiles.text=提交檔案(_I)
action.CheckinProject.text=提交(_I)…
action.ChooseDebugConfiguration.description=選擇並偵錯組態
action.ChooseDebugConfiguration.text=偵錯…
action.ChooseRunConfiguration.description=選擇並執行組態
action.ChooseRunConfiguration.text=執行…
action.ChooseRuntime.text=選擇 IDE 的啟動 Java Runtime…
action.ClassNameCompletion.description=與雙擊基本補全快捷鍵相同(可用於補全非匯入類別名)
action.ClassNameCompletion.text=第二基本補全
action.CleanupEventsTestSchemeAction.description=移除測試方案中註冊的所有組
action.CleanupEventsTestSchemeAction.text=清理事件測試方案
action.ClearAllNotifications.text=清除所有通知
action.ClickLink.text=點擊鏈接
action.CloseActiveTab.description=關閉活動工具視窗頁籤
action.CloseActiveTab.text=關閉活動頁籤(_O)
action.CloseAllEditors.description=在活動頁籤組中關閉所有編輯視窗
action.CloseAllEditors.text=關閉所有頁籤(_A)
action.CloseAllEditorsButActive.description=除活動編輯視窗外關閉所有其他視窗
action.CloseAllEditorsButActive.text=關閉其他頁籤(_O)
action.CloseAllNotifications.text=關閉所有
action.CloseAllProjects.description=關閉所有專案
action.CloseAllProjects.text=關閉所有專案
action.CloseAllReadonly.description=關閉具有唯讀檔案的所有編輯器
action.CloseAllReadonly.text=關閉所有唯讀頁籤
action.CloseAllToTheLeft.description=關閉左邊的所有編輯器
action.CloseAllToTheLeft.text=關閉左側頁籤
action.CloseAllToTheRight.description=關閉右邊的所有編輯器
action.CloseAllToTheRight.text=關閉右側頁籤
action.CloseAllUnmodifiedEditors.description=關閉所有未修改的編輯視窗
action.CloseAllUnmodifiedEditors.text=關閉未修改頁籤(_U)
action.CloseAllUnpinnedEditors.description=關閉所有未固定的編輯器
action.CloseAllUnpinnedEditors.text=關閉所有未固定
action.CloseContent.EditorTabPopup.text=關閉(_C)
action.CloseContent.description=關閉當前焦點的內容
action.CloseContent.text=關閉頁籤(_C)
action.CloseDiffEditor.text=關閉差異編輯器
action.CloseEditor.EditorPopup.text=關閉 (_C)
action.CloseEditor.EditorTabPopup.text=關閉(_C)
action.CloseEditor.description=關閉活動編輯器
action.CloseEditor.text=關閉活動編輯器(_C)
action.CloseFirstNotification.text=關閉第一個
action.CloseGotItTooltip.text=關閉“知道了”工具提示
action.CloseOtherProjects.description=關閉其他專案
action.CloseOtherProjects.text=關閉其他專案
action.CloseProject.description=關閉當前專案
action.CloseProject.text=關閉專案(_J)
action.CodeCleanup.description=執行清理檢查並套用快速修復
action.CodeCleanup.text=程式碼清理(_C)…
action.CodeCompletion.description=補全程式碼
action.CodeCompletion.text=基本(_B)
action.CodeFloatingToolbar.GotoNextMenu.text=轉到下一個工具列選單
action.CodeFloatingToolbar.GotoPrevMenu.text=轉到上一個工具列選單
action.CodeInspection.OnEditor.text=使用編輯器設定檢查程式碼(_E)
action.CodeVisionToggleAction.description=切換當前項目的 Code Vision
action.CodeVisionToggleAction.text=切換專案的 Code Vision
action.CollapseAll.text=全部摺疊
action.CollapseAllRegions.description=摺疊所有折疊區域(選區中)
action.CollapseAllRegions.text=全部摺疊(_A)
action.CollapseBlock.description=折疊當前程式碼塊
action.CollapseBlock.text=折疊程式碼塊(_B)
action.CollapseDocComments.description=摺疊所有文檔註釋
action.CollapseDocComments.text=摺疊文檔註釋(_O)
action.CollapseExpandableComponent.text=摺疊組件
action.CollapseRegion.description=摺疊文字游標處的折疊區域
action.CollapseRegion.text=摺疊(_C)
action.CollapseRegionRecursively.description=遞迴摺疊文字游標處的塊
action.CollapseRegionRecursively.text=遞迴摺疊(_A)
action.CollapseSelection.description=折疊所選塊
action.CollapseSelection.text=折疊選區/移除區域(_S)
action.CollapseTreeNode.text=摺疊樹節點
action.CollapsiblePanel-toggle.text=展開/摺疊可折疊面板
action.CollectFUStatisticsAction.text=從收集器收集統計資訊…
action.CollectTroubleshootingInformation.text=收集故障排除資訊
action.CollectZippedLogs.description=將日誌和設定壓縮到檔案中
action.CollectZippedLogs.text=收集日誌和診斷資料
action.ColorBlindnessTest.text=測試色盲
action.ColoredHeaderAction.text=顯示專案漸變
action.CommentByBlockComment.description=使用塊註釋註釋/取消程式碼
action.CommentByBlockComment.text=使用塊註釋進行註釋(_B)
action.CommentByLineComment.description=使用行註釋註釋/取消註釋當前行或所選塊
action.CommentByLineComment.text=使用行註釋進行註釋(_L)
action.CommitView.ShowOnDoubleClick.EditorPreview.ToolwindowPopup.text=差異
action.CommitView.ShowOnDoubleClick.EditorPreview.text=雙擊時顯示差異
action.CommitView.ShowOnDoubleClick.Source.ToolwindowPopup.text=源
action.CommitView.ShowOnDoubleClick.Source.text=雙擊時顯示源
action.CommitView.SwitchToCommitDialog.text=切換到“提交”對話框
action.CommittedChanges.Clear.description=清除快取的修訂版本
action.CommittedChanges.Clear.text=清除
action.CommittedChanges.Details.description=檢視所選更改列表的完整資訊
action.CommittedChanges.Details.text=顯示詳細資訊
action.CommittedChanges.Filter.description=更改篩選條件
action.CommittedChanges.Filter.text=篩選
action.CommittedChanges.Refresh.description=重新整理已提交更改的列表
action.CommittedChanges.Refresh.text=重新整理
action.CommittedChanges.Revert.description=將所選更改的反向動作應用於工作副本
action.CommittedChanges.Revert.text=還原更改
action.Compare.LastVersion.text=與最新的儲存庫版本進行比較(_V)
action.Compare.SameVersion.text=與同一個儲存庫版本進行比較(_Y)
action.Compare.Selected.text=與修訂比較(_C)…
action.Compare.Specified.text=與指定修訂比較(_P)…
action.CompareClipboardWithSelection.description=將當前選區與剪貼簿進行比較
action.CompareClipboardWithSelection.text=與剪貼簿比較(_B)
action.CompareDirs.text=比較目錄
action.CompareFileWithEditor.description=將所選檔案與編輯器中的檔案進行比較
action.CompareFileWithEditor.text=與編輯器比較檔案(_M)
action.CompareKeymaps.text=比較按鍵映射…
action.CompareTwoFiles.description=比較兩個所選檔案或目錄
action.CompareTwoFiles.synonym1=將檔案與以下檔案比較…
action.CompareTwoFiles.synonym2=比較目錄
action.CompareTwoFiles.synonym3=將目錄與以下檔案比較…
action.CompareTwoFiles.text=比較檔案(_F)
action.Compile.description=強制重新編譯所選模組、檔案或軟體套件
action.Compile.text=重新建置(_E)
action.CompileDirty.description=編譯專案中的所有修改和相依檔案
action.CompileDirty.text=建置專案(_P)
action.CompileFile.text=重新編譯(_E)
action.CompileProject.description=重新編譯專案中的所有檔案
action.CompileProject.text=重新建置專案(_R)
action.CompletionQualityStats.text=補全品質統計資訊
action.ComponentPanelTestAction.text=顯示標準面板
action.ComputeVirtualFileNameStatAction.text=計算 VF 名稱統計資訊
action.ConfigureDefaultSize.text=組態預設大小…
action.ConfigureEditorTabs.description=組態編輯器頁籤的外觀，行為和順序
action.ConfigureEditorTabs.text=組態編輯器頁籤…
action.ConfigureEventsSchemeFileAction.description=載入自訂目錄中的事件方案
action.ConfigureEventsSchemeFileAction.text=組態事件方案檔案
action.ConfigureInspectionsAction.text=組態檢查…
action.ConfigureScopesAction.text=組態…
action.ConfigureSoftWraps.text=組態自動換行
action.ConfigureTemplatesAction.text=組態實時模板…
action.Console.Execute.Multiline.description=在多行主控台中執行當前語句
action.Console.Execute.Multiline.text=在多行主控台中執行當前語句
action.Console.Execute.description=在單行主控台中執行當前語句
action.Console.Execute.text=在單行主控台中執行當前語句
action.Console.History.Browse.description=瀏覽查詢歷史記錄
action.Console.History.Browse.text=瀏覽查詢歷史記錄
action.Console.History.Next.description=主控台歷史記錄中的下一個條目
action.Console.History.Next.text=主控台歷史記錄中的下一個條目
action.Console.History.Previous.description=主控台歷史記錄中的上一個條目
action.Console.History.Previous.text=主控台歷史記錄中的上一個條目
action.Console.Open.description=為所選實體開啟主控台
action.Console.Open.text=開啟主控台
action.Console.SplitLine.text=拆分行
action.ConsoleView.FoldLinesLikeThis.text=像這樣折疊行
action.ContextHelp.description=顯示上下文幫助
action.ContextHelp.text=上下文幫助(_X)
action.ConvertIndentsToSpaces.description=轉換檔案或所選塊中的縮排，以使用空格代替制表符
action.ConvertIndentsToSpaces.text=轉換為空格
action.ConvertIndentsToTabs.description=轉換檔案或所選塊中的縮排，以使用制表符代替空格
action.ConvertIndentsToTabs.text=轉換為制表符
action.ConvertToInstanceMethod.description=將 static 方法轉換為實例方法並更正所有參照
action.ConvertToInstanceMethod.text=轉換為實例方法(_O)…
action.CopyAbsolutePath.text=絕對路徑
action.CopyAsPlainText.description=將選區複製到剪貼簿作為純文本
action.CopyAsPlainText.text=複製為純文本
action.CopyAsRichText.description=將選區複製到剪貼簿作為富文本(以 RTF 和 HTML 格式)
action.CopyAsRichText.text=複製為富文本
action.CopyContentRootPath.text=來自內容根的路徑
action.CopyElement.description=建立所選類別、檔案或目錄的副本
action.CopyElement.text=複製(_O)…
action.CopyFileName.text=檔名
action.CopyPathWithLineNumber.text=帶行號的路徑
action.CopyPaths.description=將與所選檔案或目錄對應的路徑複製到剪貼簿
action.CopyPaths.text=複製路徑(_O)
action.CopyReference.description=複製對所選類別、方法或函式或者所選檔案相對路徑的參照
action.CopyReference.text=複製參照(_Y)
action.CopySettingsPath.description=複製所選可組態選項的相對路徑
action.CopySettingsPath.text=複製選項路徑
action.CopySettingsPath.text.template=複製 {0} 路徑
action.CopySourceRootPath.text=來自來源根的路徑
action.CopyTBXReference.text=工具箱 URL
action.CopyUiLabel.text=複製 UI 標籤
action.CopyUrl.description=將文字游標下的 URL 複製到剪貼簿
action.CopyUrl.text=複製 URL
action.CreateDesktopEntry.description=建立桌面條目以與系統應用程式選單整合
action.CreateDesktopEntry.text=建立桌面條目…
action.CreateLauncherScript.description=使 IDE 可從命令行存取
action.CreateLauncherScript.text=建立命令行啟動器…
action.CreateLibraryFromFile.text=新增為庫…
action.CustomLayoutActionsGroup.Apply.text=套用(_A)
action.CustomLayoutActionsGroup.Delete.text=刪除(_D)…
action.CustomLayoutActionsGroup.Rename.description=重新命名當前布局(“{0}”)
action.CustomLayoutActionsGroup.Rename.text=重新命名(_E)
action.CustomLayoutActionsGroup.Restore.text=還原(_R)
action.CustomLayoutActionsGroup.Save.text=儲存更改(_S)
action.CustomizeMainToolbarAction.text=自訂工具…
action.CustomizeUIAction.text=自訂選單與工具列…
action.DSOpenConsole.text=開啟 Python 主控台
action.DebugBuildProcess.description=如果啟用，建置過程將在啟動時等待偵錯連線
action.DebugBuildProcess.text=偵錯建置過程
action.DebugListen.text=拋出偵錯異常
action.Debugger.AddInlineWatch.text=新增內聯監視
action.Debugger.AddSteppingFilter.text=新增步進篩選器…
action.Debugger.AddToWatch.text=新增到監視
action.Debugger.AdjustArrayRange.text=調整範圍…
action.Debugger.AutoRenderer.text=自動
action.Debugger.CallTracer.text=追蹤呼叫
action.Debugger.CopyStack.text=複製堆疊
action.Debugger.CreateRenderer.XDebuggerTreePopup.text=建立呈現器
action.Debugger.CreateRenderer.text=建立…
action.Debugger.CustomizeContextView.text=自訂資料檢視…
action.Debugger.CustomizeThreadsView.text=自訂執行緒檢視…
action.Debugger.EditArrayFilter.text=編輯…
action.Debugger.EditCustomField.text=編輯…
action.Debugger.EditFrameSource.text=EditFrameSource
action.Debugger.EvaluateInConsole.text=在主控台中求值
action.Debugger.FilterArray.text=篩選…
action.Debugger.FocusOnBreakpoint.description=到達中斷點時預設切換到此檢視
action.Debugger.FocusOnBreakpoint.text=在中斷點時獲取焦點
action.Debugger.FocusOnFinish.description=預設情況下，在偵錯會話結束時聚焦此檢視
action.Debugger.FocusOnFinish.text=完成後聚焦
action.Debugger.ForceEarlyReturn.description=強制方法在到達 return 語句之前返回
action.Debugger.ForceEarlyReturn.text=強制返回
action.Debugger.FreezeActiveThreadAction.description=執行緒執行將被掛起
action.Debugger.FreezeActiveThreadAction.synonym=凍結執行緒
action.Debugger.FreezeActiveThreadAction.text=掛起執行緒
action.Debugger.FreezeInactiveThreadsAction.description=其他執行緒上的執行緒執行將被掛起
action.Debugger.FreezeInactiveThreadsAction.synonym=凍結其他執行緒
action.Debugger.FreezeInactiveThreadsAction.text=掛起其他執行緒
action.Debugger.FreezeInactiveThreadsAmongSelected.description=掛起組中的停用執行緒
action.Debugger.FreezeInactiveThreadsAmongSelected.synonym=凍結組中的停用執行緒
action.Debugger.FreezeInactiveThreadsAmongSelected.text=掛起組中的停用執行緒
action.Debugger.FreezeSelectedThreads.description=掛起執行緒
action.Debugger.FreezeSelectedThreads.synonym=凍結執行緒
action.Debugger.FreezeSelectedThreads.text=掛起執行緒
action.Debugger.FreezeThread.text=掛起
action.Debugger.InterruptThread.text=中斷
action.Debugger.MarkObject.description=標記/取消標記物件，以便可以在偵錯器檢視中直觀區分
action.Debugger.MarkObject.text=標記物件…
action.Debugger.MarkObject.unmark.text=取消標記物件
action.Debugger.MuteRenderers.text=忽略呈現器
action.Debugger.NewCustomField.text=新增類別級別監視…
action.Debugger.PopFrame.description=將執行點移回方法呼叫，從堆疊中丟棄當前的方法幀
action.Debugger.PopFrame.text=重設幀(_F)
action.Debugger.ReloadFile.description=編譯檔案並熱交換所有已更改的類別
action.Debugger.ReloadFile.text=編譯並重新載入檔案
action.Debugger.RemoveAllBreakpoints.text=移除所有中斷點
action.Debugger.RemoveAllBreakpointsInFile.text=移除當前檔案中的所有中斷點
action.Debugger.RemoveArrayFilter.text=移除篩選器
action.Debugger.RemoveCustomField.text=移除監視
action.Debugger.RestoreBreakpoint.description=還原上次刪除的中斷點
action.Debugger.RestoreBreakpoint.text=還原中斷點
action.Debugger.ResumeThread.text=恢復
action.Debugger.ShowCollectionHistory.text=顯示集合歷史記錄
action.Debugger.ShowLibraryFrames.text=顯示/隱藏庫框架
action.Debugger.ShowReferring.text=顯示參照物件…
action.Debugger.ShowRelatedStack.text=顯示相關堆疊…
action.Debugger.ShowTypes.text=顯示類型
action.Debugger.SwitchToTheNextContext.text=切換到下一個停止的中斷點
action.Debugger.ThawActiveThreadAction.description=執行緒執行將被恢復
action.Debugger.ThawActiveThreadAction.synonym=取消凍結執行緒
action.Debugger.ThawActiveThreadAction.text=恢復執行緒
action.Debugger.ThawAllThreadsAction.description=其他執行緒上的執行緒執行將被恢復
action.Debugger.ThawAllThreadsAction.synonym=取消凍結所有執行緒
action.Debugger.ThawAllThreadsAction.text=恢復所有執行緒
action.Debugger.ThawSelectedThreads.description=恢復執行緒
action.Debugger.ThawSelectedThreads.synonym=取消凍結執行緒
action.Debugger.ThawSelectedThreads.text=恢復執行緒
action.Debugger.ThrowException.description=拋出一個異常
action.Debugger.ThrowException.text=拋出異常
action.Debugger.Tree.EvaluateInConsole.text=在主控台中求值
action.Debugger.ViewEditText.text=檢視/編輯文本
action.Debugger.ViewText.description=在單獨的窗格中檢視所選節點的文本值
action.Debugger.ViewText.text=檢視文本
action.Debugger.XDebuggerTextPopup.ShowAsObject.text=顯示為物件
action.DecrementWindowHeight.text=減小高度
action.DecrementWindowWidth.text=減小寬度
action.DelegateMethods.description=為欄位/getter 生成委託方法
action.DelegateMethods.text=委託方法(_D)…
action.DeleteMnemonicFromBookmark.text=移除助記鍵
action.DeleteNamedLayout.current.description=無法刪除有效布局
action.DeleteNamedLayout.description=刪除布局“{0}”
action.DeleteOldAppDirs.description=尋找以前 IDE 版本中的設定、快取和日誌目錄
action.DeleteOldAppDirs.text=刪除殘留的 IDE 目錄…
action.DeleteRecentFiles.description=從“最近的檔案”中刪除所選檔案或關閉所選工具視窗
action.DeleteRecentFiles.text=從最近的檔案中刪除
action.DeleteRecentFilesFallback.description=從“最近的檔案”中刪除所選檔案或關閉所選工具視窗
action.DeleteRecentFilesFallback.text=從“最近的檔案”中刪除
action.DeleteRunConfiguration.description=刪除執行組態
action.DeleteRunConfiguration.text=刪除
action.DetachDirectory.text=從專案中分離目錄…
action.DevKit.Bootstrap.synonym=安裝 Plugin DevKit
action.DevKit.Bootstrap.text=建立 IntelliJ IDEA 延伸模組…
action.Diff.AppendLeftSide.text=追加左側
action.Diff.AppendRightSide.text=追加右側
action.Diff.ApplyLeftSide.text=接受左側
action.Diff.ApplyNonConflicts.Left.text=從左側套用不衝突的更改
action.Diff.ApplyNonConflicts.Right.text=從右側套用不衝突的更改
action.Diff.ApplyNonConflicts.text=套用所有不衝突的更改
action.Diff.ApplyRightSide.text=接受右側
action.Diff.ComparePartial.Base.Left.text=左和中
action.Diff.ComparePartial.Base.Right.text=中和右
action.Diff.ComparePartial.Generic={0,choice,0\\#左|1\\#中|2\\#右} 和 {1,choice,0\\#左|1\\#中|2\\#右}
action.Diff.ComparePartial.Left.Right.text=左和右
action.Diff.CompareWithBase.Left.text=基礎和左
action.Diff.CompareWithBase.Result.text=基礎和中
action.Diff.CompareWithBase.Right.text=基礎和右
action.Diff.FocusOppositePane.description=在差異檢視中選擇相對窗格
action.Diff.FocusOppositePane.text=選擇相對差異窗格
action.Diff.FocusOppositePaneAndScroll.description=在差異檢視的相對窗格中選擇相同的位置
action.Diff.FocusOppositePaneAndScroll.text=在相對差異窗格中選擇位置
action.Diff.IgnoreLeftSide.text=忽略左側
action.Diff.IgnoreRightSide.text=忽略右側
action.Diff.MagicResolveConflicts.text=解決簡單的衝突
action.Diff.NextChange.text=比較下一個檔案
action.Diff.NextConflict.description=移至下一個未解決的衝突
action.Diff.NextConflict.text=下一個衝突
action.Diff.OpenDiffInEditor.text=作為編輯器頁籤開啟選定的差異請求
action.Diff.PrevChange.text=比較上一個檔案
action.Diff.PreviousConflict.description=移至上一個未解決的衝突
action.Diff.PreviousConflict.text=上一個衝突
action.Diff.ResolveConflict.text=自動解決
action.Diff.ShowDiff.description=比較檔案或修訂
action.Diff.ShowDiff.text=顯示差異
action.Diff.ShowDiffPreview.description=選區更改時取代差異內容
action.Diff.ShowInExternalTool.text=在外部工具中顯示差異
action.Diff.ShowSettingsPopup.text=顯示差異設定彈出視窗…
action.Diff.ShowStandaloneDiff.description=在新頁籤或視窗中開啟每個選區的差異
action.Diff.ShowStandaloneDiff.tab.description=在新頁籤中開啟每個選區的差異
action.Diff.ShowStandaloneDiff.tab.text=在新頁籤中顯示差異
action.Diff.ShowStandaloneDiff.text=在新頁籤或視窗中顯示差異
action.Diff.ShowStandaloneDiff.window.description=在新視窗中開啟每個選區的差異
action.Diff.ShowStandaloneDiff.window.text=在新視窗中顯示差異
action.DirDiffMenu.CancelComparingNewFilesWithEachOther.text=取消相互比較新檔案
action.DirDiffMenu.CompareNewFilesWithEachOtherAction.text=相互比較新檔案
action.DirDiffMenu.EnableEqual.text=顯示相同的檔案
action.DirDiffMenu.EnableLeft.text=在左側顯示新檔案
action.DirDiffMenu.EnableNotEqual.text=顯示差異
action.DirDiffMenu.EnableRight.text=在右側顯示新檔案
action.DirDiffMenu.Exclude.text=從結果中排除
action.DirDiffMenu.MirrorToLeft.text=設定鏡像到左側
action.DirDiffMenu.MirrorToRight.text=設定鏡像到右側
action.DirDiffMenu.SetCopyToLeft.text=設定複製到左側
action.DirDiffMenu.SetCopyToRight.text=設定複製到右側
action.DirDiffMenu.SetDefault.text=設定預設值
action.DirDiffMenu.SetDelete.text=設定刪除
action.DirDiffMenu.SetNoOperation.text=設定不執行任何動作
action.DirDiffMenu.SynchronizeDiff.All.text=全部同步
action.DirDiffMenu.SynchronizeDiff.text=同步選定項
action.DirDiffMenu.WarnOnDeletion.text=刪除時發出警告
action.DockPinnedMode.description=使工具視窗停靠並固定
action.DockPinnedMode.text=停靠固定(_P)
action.DockToolWindow.text=Dock
action.DockUnpinnedMode.description=使工具視窗停靠但焦點丟失時自動隱藏
action.DockUnpinnedMode.text=停靠不固定(_U)
action.Document2XSD.text=從 XSD 架構生成 XML 文檔…
action.Documentation.Back.text=後退
action.Documentation.EditSource.text=跳轉到源(_J)
action.Documentation.Forward.text=前進
action.Documentation.KeepTab.description=關閉當前頁籤中的所有更新，使下一個動作呼叫開啟新的頁籤
action.Documentation.KeepTab.text=保留此文檔
action.Documentation.ToggleAutoShow.description=切換是否使用補全彈出視窗自動顯示文檔
action.Documentation.ToggleAutoShow.text=在補全期間自動顯示
action.Documentation.ToggleAutoUpdate.description=選區更改時自動重新整理文檔
action.Documentation.ToggleAutoUpdate.text=從源自動更新
action.Documentation.ToggleShowInPopup.description=切換是否應在工具視窗之前顯示“文檔”彈出視窗
action.Documentation.ToggleShowInPopup.text=首先顯示“文檔”彈出視窗
action.Documentation.ViewExternal.text=檢視外部文檔
action.DumbMode.text=靜默模式
action.DumbModeTremble.text=Tremble Dumb 模式
action.DumpExtensions.text=傾印副檔名
action.DumpFeaturesAndTips.description=將有關功能和提示檔案的資訊複製到剪貼簿
action.DumpFeaturesAndTips.text=傾印功能和提示資訊(_D)
action.DumpFocusableComponentHierarchyAction.text=傾印可聚焦組件層次結構
action.DumpFormattingModel.text=傾印格式設定模型
action.DumpIElementTypesAction.text=傾印 IElementType 註冊表
action.DumpInspectionDescriptions.text=傾印檢查描述
action.DumpInspectionDescriptionsAction.text=傾印檢查描述
action.DumpIntentionsAction.text=傾印意圖
action.DumpIntentionsDescriptions.text=傾印意圖描述
action.DumpInvalidTipsOfTheDay.text=傾印無效的每日小技巧
action.DumpLibraryUsageStatistics.text=傾印庫用法的統計資訊
action.DumpLoadedInspectionsAction.text=傾印已初始化的檢查
action.DumpLookupElementWeights.text=將尋找元素權重傾印到日誌
action.DumpPluginDescriptorsAction.description=將有關已載入延伸模組的檔案描述子和類別載入器的資訊寫入日誌目錄中的 plugin-descriptors-data.json
action.DumpPluginDescriptorsAction.text=傾印延伸模組檔案描述子
action.DumpRunConfigurationTypesAction.text=傾印執行組態類型
action.DumpScreenConfiguration.text=傾印螢幕組態
action.DumpVfsInfoForExcludedFiles.text=傾印排除根下檔案的 VFS 內容
action.DumpVfsInfoForFsRoot.text=傾印以下根的 VFS 內容…
action.DumpWatchedRoots.text=顯示監視的 VFS 根
action.DupLocate.description=尋找專案中的重複程式碼
action.DupLocate.text=尋找重複項(_L)
action.EditBookmark.text=重新命名書籤…
action.EditBreakpoint.text=編輯中斷點
action.EditCustomProperties.description=開啟帶有自訂屬性檔案的編輯器頁籤
action.EditCustomProperties.text=編輯自定義屬性…
action.EditCustomVmOptions.description=開啟帶有自訂虛擬機選項檔案的編輯器頁籤
action.EditCustomVmOptions.text=編輯自定義虛擬機選項…
action.EditMacros.description=組態現有巨集
action.EditMacros.text=編輯巨集(_E)
action.EditSource.description=開啟所選條目的編輯器並使之獲得焦點
action.EditSource.text=跳轉到源(_J)
action.EditSourceInNewWindow.description=在新視窗開啟所選條目的編輯器並使之獲得焦點
action.EditSourceInNewWindow.text=在新視窗中開啟頁籤
action.EditSourceNotInEditor.text=編輯源(不在編輯器中)
action.EditTestSchemeAction.description=允許來自組的所有資料。使用它在本地測試新的收集器。
action.EditTestSchemeAction.text=編輯事件測試方案
action.EditorAddCaretPerSelectedLine.text=在所選行的末尾新增文字游標
action.EditorAddOrRemoveCaret.description=在當前檔案中設定多個游標，以同時編輯多行程式碼。
action.EditorAddOrRemoveCaret.text=新增或移除文字游標
action.EditorAddRectangularSelectionOnMouseDrag.text=拖動滑鼠時新增矩形選區
action.EditorBackSpace.text=退格
action.EditorBackwardParagraph.text=將文字游標後移一段
action.EditorBackwardParagraphWithSelection.text=在保持選區的情況下將文字游標後移一段
action.EditorBreadcrumbsHideBoth.description=隱藏路徑導覽列
action.EditorBreadcrumbsHideBoth.text=不顯示
action.EditorBreadcrumbsShowAbove.description=在文本編輯器上方顯示路徑導覽列
action.EditorBreadcrumbsShowAbove.text=頂部
action.EditorBreadcrumbsShowBelow.description=在文本編輯器下方顯示路徑導覽列
action.EditorBreadcrumbsShowBelow.text=底部
action.EditorCenterView.description=切換編輯器文本的左對齊和居中對齊
action.EditorCenterView.text=切換居中檢視
action.EditorChooseLookupItem.text=選擇查詢條目
action.EditorChooseLookupItemCompleteStatement.text=選擇查詢條目並呼叫語句補全
action.EditorChooseLookupItemDot.text=選擇查詢條目並插入點
action.EditorChooseLookupItemReplace.text=選擇查詢條目取代
action.EditorCloneCaretAbove.description=在上面的行中插入一個輔助游標，以同時編輯多行程式碼。
action.EditorCloneCaretAbove.text=在上方克隆文字游標
action.EditorCloneCaretBelow.description=在下面的行中插入一個輔助游標，以同時編輯多行程式碼。
action.EditorCloneCaretBelow.text=在下方克隆文字游標
action.EditorCodeBlockEnd.text=將文字游標移至程式碼塊結束
action.EditorCodeBlockEndWithSelection.text=在保持選區的情況下將文字游標移至程式碼塊結束
action.EditorCodeBlockStart.text=將文字游標移至程式碼塊開始
action.EditorCodeBlockStartWithSelection.text=在保持選區的情況下將文字游標移至程式碼塊開始
action.EditorCompleteStatement.text=補全當前語句
action.EditorConsoleScrollToTheEnd.text=滾動到末尾
action.EditorContextInfo.description=不可見時，顯示當前方法或類別宣告
action.EditorContextInfo.text=上下文資訊(_C)
action.EditorCopy.text=複製
action.EditorCreateRectangularSelection.text=建立矩形選區
action.EditorCreateRectangularSelectionOnMouseDrag.text=拖動滑鼠建立矩形選區
action.EditorCut.text=剪下
action.EditorCutLineBackward.text=反向剪下行
action.EditorCutLineEnd.text=剪下到行尾
action.EditorDecreaseFontSize.text=減小字體大小
action.EditorDecreaseFontSizeGlobal.text=在所有編輯器中減小字體大小
action.EditorDelete.text=刪除
action.EditorDeleteLine.text=刪除行
action.EditorDeleteToLineEnd.text=刪除到行尾
action.EditorDeleteToLineStart.text=刪除到行首
action.EditorDeleteToWordEnd.text=刪除到詞尾
action.EditorDeleteToWordEndInDifferentHumpsMode.text=在不同的 "CamelHumps" 模式下刪除到詞尾
action.EditorDeleteToWordStart.text=刪除到詞首
action.EditorDeleteToWordStartInDifferentHumpsMode.text=在不同的 "CamelHumps" 模式下刪除到詞首
action.EditorDown.text=下
action.EditorDownWithSelection.text=在保持選區的情況下向下
action.EditorDuplicate.text=重複行或選區
action.EditorDuplicateLines.text=重複整行
action.EditorEnter.text=Enter
action.EditorEscape.text=Esc
action.EditorFocusGutter.text=將裝訂區域設為焦點(無障礙功能)
action.EditorForwardParagraph.text=將文字游標前移一段
action.EditorForwardParagraphWithSelection.text=在保持選區的情況下將文字游標前移一段
action.EditorGutterToggleGlobalIndentLines.text=顯示縮排參考線
action.EditorGutterToggleGlobalLineNumbers.text=顯示行號
action.EditorGutterToggleGlobalStickyLines.description=顯示粘性行面板
action.EditorGutterToggleGlobalStickyLines.text=顯示粘性行
action.EditorGutterToggleLocalSoftWraps.gutterText=自動換行當前編輯器
action.EditorHungryBackSpace.description=與退格鍵的作用相同，但也會移除文字游標前的所有空白符號(如有)
action.EditorHungryBackSpace.text=飢餓退格
action.EditorIncreaseFontSize.text=增大字體大小
action.EditorIncreaseFontSizeGlobal.text=在所有編輯器中增加字體大小
action.EditorIndentLineOrSelection.text=縮排行或選區
action.EditorIndentSelection.text=縮排選區
action.EditorJoinLines.text=合併行
action.EditorKillRegion.text=終止所選區域
action.EditorKillRingSave.text=儲存至終止環
action.EditorKillToWordEnd.text=終止至詞尾
action.EditorKillToWordStart.text=終止至詞首
action.EditorLeft.text=左
action.EditorLeftWithSelection.text=在保持選區的情況下向左
action.EditorLineEnd.text=將文字游標移至行尾
action.EditorLineEndWithSelection.text=在保持選區的情況下將文字游標移至行尾
action.EditorLineStart.text=將文字游標移至行首
action.EditorLineStartWithSelection.text=在保持選區的情況下將文字游標移至行首
action.EditorLookupDown.text=向下尋找
action.EditorLookupSelectionDown.text=選擇下一個補全選項
action.EditorLookupSelectionUp.text=選擇上一個補全選項
action.EditorLookupUp.text=向上尋找
action.EditorMatchBrace.text=將文字游標移至符合的大括號
action.EditorMoveDownAndScroll.text=向下移動並滾動
action.EditorMoveDownAndScrollWithSelection.text=在保持選區的情況下向下移動並滾動
action.EditorMoveToPageBottom.text=將文字游標移至頁面底部
action.EditorMoveToPageBottomWithSelection.text=在保持選區的情況下將文字游標移至頁面底部
action.EditorMoveToPageTop.text=將文字游標移至頁面頂部
action.EditorMoveToPageTopWithSelection.text=在保持選區的情況下將文字游標移至頁面頂部
action.EditorMoveUpAndScroll.text=向上移動並滾動
action.EditorMoveUpAndScrollWithSelection.text=在保持選區的情況下向上移動並滾動
action.EditorNextWord.text=將文字游標移至下一個單詞
action.EditorNextWordInDifferentHumpsMode.text=在不同的 "CamelHumps" 模式下將文字游標移至下一個單詞
action.EditorNextWordInDifferentHumpsModeWithSelection.text=在不同的 "CamelHumps" 模式下保持選區的情況下將文字游標移至下一個單詞
action.EditorNextWordWithSelection.text=在保持選區的情況下將文字游標移至下一個單詞
action.EditorPageDown.text=向下翻頁
action.EditorPageDownWithSelection.text=在保持選區的情況下向下翻頁
action.EditorPageUp.text=向上翻頁
action.EditorPageUpWithSelection.text=在保持選區的情況下向上翻頁
action.EditorPaste.text=貼上
action.EditorPasteFromX11.text=從 X 剪貼簿貼上
action.EditorPasteSimple.description=貼上，不進行格式設定、自動匯入、字面量轉義等。
action.EditorPasteSimple.text=貼上為純文本(_L)
action.EditorPreviousWord.text=將文字游標移至上一個單詞
action.EditorPreviousWordInDifferentHumpsMode.text=在不同的 "CamelHumps" 模式下將文字游標移至上一個單詞
action.EditorPreviousWordInDifferentHumpsModeWithSelection.text=在不同的 "CamelHumps" 模式下保持選區的情況下將文字游標移至上一個單詞
action.EditorPreviousWordWithSelection.text=在保持選區的情況下將文字游標移至上一個單詞
action.EditorRenderingBenchmarkAction.text=編輯器渲染基準
action.EditorResetFontSize.text=重設字體大小
action.EditorResetFontSizeGlobal.text=在所有編輯器中重設字體大小
action.EditorReverseLines.text=反轉行
action.EditorRight.text=右
action.EditorRightWithSelection.text=在保持選區的情況下向右
action.EditorScrollBottom.text=滾動到底部
action.EditorScrollDown.text=向下滾動
action.EditorScrollDownAndMove.text=向下滾動並根據需要移動
action.EditorScrollLeft.text=向左滾動
action.EditorScrollRight.text=向右滾動
action.EditorScrollToCenter.text=滾動到中心
action.EditorScrollTop.text=滾動到頂部
action.EditorScrollUp.text=向上滾動
action.EditorScrollUpAndMove.text=向上滾動並根據需要移動
action.EditorSelectLine.text=擴展行選區
action.EditorSelectSingleLineAtCaret.text=選擇文字游標處的一行
action.EditorSelectWord.text=擴展選區
action.EditorSetContentBasedBidiTextDirection.description=方向由初始字元決定
action.EditorSetContentBasedBidiTextDirection.text=基於內容
action.EditorSetLtrBidiTextDirection.text=左到右
action.EditorSetRtlBidiTextDirection.text=右到左
action.EditorShowGutterIconTooltip.text=顯示裝訂區域圖示工具提示(無障礙功能)
action.EditorSortLines.text=對行排序
action.EditorSplitLine.text=拆分行
action.EditorStartNewLine.text=開始新行
action.EditorStartNewLineBefore.text=在當前行之前開始新行
action.EditorStickyConfigure.description=顯示粘性行設定對話框
action.EditorStickyConfigure.text=組態粘性行…
action.EditorStickyLinesDisable.description=隱藏粘性行面板
action.EditorStickyLinesDisable.text=停用
action.EditorStickyLinesDisableForLang.description=隱藏語言的粘性行面板
action.EditorStickyLinesDisableForLang.for.lang.text=對{0}停用
action.EditorStickyLinesDisableForLang.text=對語言停用
action.EditorSwapSelectionBoundaries.text=交換選區邊界
action.EditorTab.text=頁籤
action.EditorTextEnd.text=將文字游標移至文本結束
action.EditorTextEndWithSelection.text=在保持選區的情況下將文字游標移至文本結束
action.EditorTextStart.text=將文字游標移至文本開始
action.EditorTextStartWithSelection.text=在保持選區的情況下將文字游標移至文本開始
action.EditorToggleCase.synonym.lower=小寫
action.EditorToggleCase.synonym.upper=大寫
action.EditorToggleCase.text=切換大小寫
action.EditorToggleColumnMode.description=在當前編輯器中切換列選擇模式
action.EditorToggleColumnMode.text=列選擇模式(_M)
action.EditorToggleInsertState.text=切換插入/覆蓋
action.EditorToggleShowBreadcrumbs.description=在當前編輯器中切換顯示路徑導覽列
action.EditorToggleShowBreadcrumbs.text=顯示路徑導覽
action.EditorToggleShowGutterIcons.description=在當前編輯器中切換顯示裝訂區域圖示
action.EditorToggleShowGutterIcons.text=顯示裝訂區域圖示 (_O)
action.EditorToggleShowIndentLines.description=在當前編輯器中切換顯示縮排參考線
action.EditorToggleShowIndentLines.text=顯示縮排參考線(_O)
action.EditorToggleShowLineNumbers.description=在當前編輯器中切換顯示行號
action.EditorToggleShowLineNumbers.text=顯示行號(_I)
action.EditorToggleShowWhitespaces.description=在當前編輯器中切換顯示空格
action.EditorToggleShowWhitespaces.text=顯示空格(_O)
action.EditorToggleStickySelection.text=切換粘性選區
action.EditorToggleUseSoftWraps.description=在當前編輯器中切換使用自動換行
action.EditorToggleUseSoftWraps.text=自動換行
action.EditorToggleUseSoftWrapsInPreview.description=在預覽編輯器中切換使用自動換行
action.EditorToggleUseSoftWrapsInPreview.text=自動換行預覽編輯器
action.EditorTranspose.text=轉置
action.EditorUnSelectWord.text=收縮選區
action.EditorUnindentSelection.text=取消縮排行或選區
action.EditorUniqueLines.text=刪除重複行
action.EditorUp.text=上
action.EditorUpWithSelection.text=在保持選區的情況下向上
action.EmacsStyleIndent.text=Emacs 頁籤
action.EmmetNextEditPoint.description=轉到下一個 Emmet 編輯點
action.EmmetNextEditPoint.text=下一個 Emmet 編輯點
action.EmmetPreview.description=顯示 Emmet 縮寫的預覽
action.EmmetPreview.text=Emmet 預覽
action.EmmetPreviousEditPoint.description=轉到上一個 Emmet 編輯點
action.EmmetPreviousEditPoint.text=上一個 Emmet 編輯點
action.EmmetUpdateTag.description=使用 Emmet 縮寫更新現有 HTML 標記
action.EmmetUpdateTag.text=使用 Emmet 更新標記
action.EmojiAndSymbols.description=使用 macOS 系統調色板輸入特殊字元
action.EmojiAndSymbols.text=表情和符號
action.EnableMetalRendering.text=Metal 呈現管道
action.EncapsulateFields.description=使用存取器方法取代所選類別中欄位的直接存取
action.EncapsulateFields.text=封裝欄位(_E)…
action.EscapeEntities.description=使用實體轉義 XML/HTML 特殊字元
action.EscapeEntities.text=編碼 XML/HTML 特殊字元
action.EvaluateExpression.description=對任意表達式求值
action.EvaluateExpression.text=對表達式求值(_X)…
action.ExcludeFromProjectAction.text=從專案中排除
action.ExecutionTargets.text=目標
action.Exit.description=離開 IDE
action.Exit.text=離開(_X)
action.ExpandAll.text=全部展開
action.ExpandAllRegions.description=展開所有折疊區域(選區中)
action.ExpandAllRegions.text=全部展開(_E)
action.ExpandAllToLevel1.text=_1
action.ExpandAllToLevel2.text=_2
action.ExpandAllToLevel3.text=_3
action.ExpandAllToLevel4.text=_4
action.ExpandAllToLevel5.text=_5
action.ExpandCollapseToggleAction.description=展開或摺疊當前程式碼塊
action.ExpandCollapseToggleAction.text=切換折疊
action.ExpandDocComments.description=展開所有文檔註釋
action.ExpandDocComments.text=展開文檔註釋(_D)
action.ExpandExpandableComponent.text=展開組件
action.ExpandLiveTemplateByTab.text=按 Tab 展開實時模板
action.ExpandLiveTemplateCustom.description=使用在編輯器中輸入的前綴呼叫綁定到 '自訂快捷鍵' 的實時模板
action.ExpandLiveTemplateCustom.text=展開實時模板/Emmet 縮寫
action.ExpandRecursively.shortcutHint=按 {0} 展開所有節點
action.ExpandRecursively.text=擴展所選
action.ExpandRegion.description=展開文字游標處的折疊區域
action.ExpandRegion.text=展開(_X)
action.ExpandRegionRecursively.description=遞迴展開文字游標處的塊
action.ExpandRegionRecursively.text=遞迴展開(_R)
action.ExpandToLevel1.text=_1
action.ExpandToLevel2.text=_2
action.ExpandToLevel3.text=_3
action.ExpandToLevel4.text=_4
action.ExpandToLevel5.text=_5
action.ExpandTreeNode.text=展開樹節點
action.ExportSettings.description=匯出全域設定
action.ExportSettings.text=匯出設定(_E)…
action.ExportTestResults.description=將測試結果匯出到檔案
action.ExportTestResults.text=匯出測試結果…
action.ExportThreads.description=將所有執行緒資訊儲存到文本檔案或剪貼簿
action.ExportThreads.text=匯出執行緒(_H)…
action.ExportToEclipse.description=為每個模組建立 Eclipse 專案
action.ExportToEclipse.text=匯出到 Eclipse…
action.ExportToHTML.MainMenu.text=將檔案或選區匯出到 HTML(_H)…
action.ExportToHTML.description=以 HTML 格式儲存檔案內容，包括語法顏色
action.ExportToHTML.text=將檔案或選區匯出到 HTML(_H)…
action.ExportToTextFile.text=匯出到文本檔案
action.ExpressionStatistics.text=收集 Java 表達式統計資訊
action.ExpressionTypeInfo.description=顯示所選表達式的類型
action.ExpressionTypeInfo.text=類型資訊(_E)
action.ExternalJavaDoc.description=開啟包含所選條目文檔的瀏覽器
action.ExternalJavaDoc.text=外部文檔(_X)
action.ExternalSystem.AfterCompile.description=在建置後執行所選任務
action.ExternalSystem.AfterCompile.text=建置後執行
action.ExternalSystem.AfterRebuild.description=在完全重新建置後執行所選任務
action.ExternalSystem.AfterRebuild.text=重新建置後執行
action.ExternalSystem.AfterSync.description=在專案匯入後執行所選任務
action.ExternalSystem.AfterSync.text=同步後執行
action.ExternalSystem.AssignRunConfigurationShortcut.description=將快捷鍵指定至所選執行組態
action.ExternalSystem.AssignRunConfigurationShortcut.text=指定快捷鍵…
action.ExternalSystem.AssignShortcut.description=將快捷鍵指定至所選任務
action.ExternalSystem.AssignShortcut.text=指定快捷鍵…
action.ExternalSystem.BeforeCompile.description=在建置前執行所選任務
action.ExternalSystem.BeforeCompile.text=建置前執行
action.ExternalSystem.BeforeRebuild.description=在完全重新建置前執行所選任務
action.ExternalSystem.BeforeRebuild.text=重新建置前執行
action.ExternalSystem.BeforeRun.description=在啟動執行/偵錯組態之前執行所選任務
action.ExternalSystem.BeforeRun.text=在執行/偵錯之前執行…
action.ExternalSystem.BeforeSync.description=在專案匯入前執行所選任務
action.ExternalSystem.BeforeSync.text=同步前執行
action.ExternalSystem.CollapseAll.text=全部摺疊
action.ExternalSystem.EditRunConfiguration.text=編輯執行組態…
action.ExternalSystem.ExpandAll.text=全部展開
action.ExternalSystem.GroupModules.text=組模組
action.ExternalSystem.GroupTasks.text=組任務
action.ExternalSystem.RemoveRunConfiguration.text=移除執行組態
action.ExternalSystem.RunTask.description=執行選定任務
action.ExternalSystem.RunTask.text=執行任務(_R)
action.ExternalSystem.SelectProjectDataToImport.text=選擇要匯入的專案資料
action.ExternalSystem.ShowCommonSettings.description=為當前專案編輯建置工具設定
action.ExternalSystem.ShowCommonSettings.text=自動同步設定…
action.ExternalSystem.ShowIgnored.text=顯示忽略項
action.ExternalSystem.ShowInheritedTasks.text=顯示從子專案繼承的任務
action.ExtractClass.description=提取委託
action.ExtractClass.text=提取委託(_D)…
action.ExtractInclude.description=將所選程式碼段轉換為包含的檔案
action.ExtractInclude.text=包含檔案(_I)…
action.ExtractInterface.description=從所選類別提取接口
action.ExtractInterface.text=提取接口(_I)…
action.ExtractMethod.description=將所選程式碼段轉換為一個方法
action.ExtractMethod.text=提取方法(_M)…
action.ExtractModule.description=從所選類別提取模組
action.ExtractModule.text=提取模組(_M)…
action.ExtractModuleFromPackage.description=將軟體套件提取到單獨的模組
action.ExtractModuleFromPackage.text=提取模組…
action.ExtractSuperclass.description=從所選類別提取超類別
action.ExtractSuperclass.text=提取超類別(_U)…
action.FileChooser.Delete.description=刪除
action.FileChooser.Delete.text=刪除…
action.FileChooser.GoBackward.description=轉到之前存取過的目錄。
action.FileChooser.GoBackward.text=上一個目錄
action.FileChooser.GoForward.description=轉到之前存取過的目錄。
action.FileChooser.GoForward.text=下一個目錄
action.FileChooser.GoToParent.description=轉到父目錄
action.FileChooser.GoToParent.text=父目錄
action.FileChooser.GoToRoot.description=轉到根目錄或根目錄列表
action.FileChooser.GoToRoot.text=根目錄
action.FileChooser.GoToWslHome.description=轉到 WSL VM 中的主目錄
action.FileChooser.GoToWslHome.text=WSL 中的主目錄
action.FileChooser.GotoDesktop.description=轉到桌面目錄
action.FileChooser.GotoDesktop.text=桌面目錄
action.FileChooser.GotoHome.description=轉到主目錄
action.FileChooser.GotoHome.text=主目錄
action.FileChooser.GotoModule.description=轉到模組目錄
action.FileChooser.GotoModule.text=模組目錄
action.FileChooser.GotoProject.description=轉到專案目錄
action.FileChooser.GotoProject.text=專案目錄
action.FileChooser.LightEditGotoOpenedFile.text=選擇開啟的檔案
action.FileChooser.NewFile.description=建立一個新檔案
action.FileChooser.NewFile.text=新增檔案…
action.FileChooser.NewFolder.description=建立一個新目錄
action.FileChooser.NewFolder.text=新增目錄…
action.FileChooser.Refresh.description=重新整理檔案系統樹
action.FileChooser.Refresh.text=重新整理
action.FileChooser.ShowHidden.description=顯示隱藏的檔案和目錄
action.FileChooser.ShowHidden.text=顯示隱藏的檔案和目錄
action.FileChooser.ToggleDetection.description=允許 IDE 檢視內部以檢測專案目錄
action.FileChooser.ToggleDetection.text=檢測專案目錄
action.FileChooser.TogglePathBar.description=切換路徑輸入欄位的可見性
action.FileChooser.TogglePathBar.text=顯示/隱藏路徑輸入欄位
action.FileChooser.TogglePathShowing.text=顯示/隱藏路徑文本
action.FileStructurePopup.description=顯示帶有當前檔案結構的彈出視窗，以便快速導覽
action.FileStructurePopup.text=檔案結構(_I)
action.FillParagraph.description=重新設定字串字面量或註釋的格式以適應最大寬度(通常為80)
action.FillParagraph.text=填充段落
action.Find.description=在活動編輯器中尋找字串
action.Find.text=尋找(_F)…
action.FindInPath.description=在多個檔案中尋找字串
action.FindInPath.synonym1=在路徑中尋找
action.FindInPath.text=在檔案中尋找…
action.FindNext.MainMenu.text=尋找下一個符合項(_N)
action.FindNext.description=重複上一次尋找/取代動作，或移至所選文本的下一個符合項
action.FindNext.text=尋找下一個/移至下一個符合項(_N)
action.FindPrevWordAtCaret.description=尋找文字游標處單詞的上一個符合項
action.FindPrevWordAtCaret.text=文字游標處單詞的上一個符合項
action.FindPrevious.MainMenu.text=尋找上一個符合項(_V)
action.FindPrevious.description=反向重複上一次尋找/取代動作，或移至所選文本的上一個符合項
action.FindPrevious.text=尋找上一個/移至上一個符合項(_V)
action.FindSelectionInPath.text=在檔案中尋找
action.FindUsages.description=尋找文字游標處符號的用法
action.FindUsages.text=尋找用法(_U)
action.FindUsagesInFile.description=在活動編輯器中尋找文字游標處符號的用法
action.FindUsagesInFile.text=在檔案中尋找用法(_I)
action.FindUsedTestData.text=尋找未使用的測試資料
action.FindWordAtCaret.description=尋找文字游標處單詞的下一個符合項
action.FindWordAtCaret.text=尋找文字游標處的字
action.FixDocComment.description=生成或修正當前上下文的文檔註釋
action.FixDocComment.text=修正文檔註釋
action.FixLineSeparators.text=修復行分隔符
action.FloatMode.description=將工具視窗移至單獨的對話框
action.FloatMode.text=浮動(_F)
action.Floating.CodeToolbar.Customize.text=自訂工具列…
action.Floating.CodeToolbar.Disable.text=不顯示工具列
action.Floating.CodeToolbar.SurroundWithIf.text=if
action.Floating.CodeToolbar.SurroundWithTryCatch.text=try / catch
action.Floating.CodeToolbar.SurroundWithTryCatchFinally.text=try / catch / finally
action.FocusDebugger.text=啟動焦點偵錯器
action.FocusEditor.text=聚焦編輯器
action.FocusTracer.text=啟動焦點追蹤
action.ForceIndexRebuild.text=對所有內容重新編制索引
action.ForceIndexRebuild.warning=確定要重新索引所有檔案嗎?
action.ForceIndexRescanning.text=同步索引
action.ForceRefresh.text=強制重新整理
action.ForceRunToCursor.description=執行到文字游標所在的行，忽略任何中斷點
action.ForceRunToCursor.text=強制執行到游標(_S)
action.ForceStepInto.description=步入，忽略庫、建構函式等步進篩選器。
action.ForceStepInto.text=強制步入(_N)
action.ForceStepOver.description=步過，在步進前停用所有中斷點。
action.ForceStepOver.text=強制步過(_V)
action.Forward.description=恢復上次撤消的導覽動作
action.Forward.text=前進(_W)
action.Frontend.ChangesView.GroupBy.Directory.text=目錄
action.Frontend.ChangesView.GroupBy.Module.text=模組
action.Frontend.ChangesView.GroupBy.Repository.text=儲存庫
action.Frontend.ChangesView.Shelf.CreatePatchFromChanges.Clipboard.text=作為補丁複製到剪貼簿
action.Frontend.ChangesView.Shelf.CreatePatchFromChanges.text=建立補丁…
action.Frontend.ChangesView.Shelf.ImportFromPatches.text=匯入補丁…
action.Frontend.ChangesView.Shelf.Rename.text=重新命名…
action.Frontend.ChangesView.Shelf.Restore.text=還原
action.Frontend.ChangesView.ShowDiff.text=顯示差異
action.Frontend.ChangesView.UnshelveSilently.text=無提示取消擱置
action.Frontend.Delete.Action.text=刪除(_D)
action.Frontend.EditSource.text=跳轉到原始碼(_J)
action.Frontend.ShelveChanges.UnshelveWithDialog.text=取消擱置…
action.Frontend.Vcs.CompareWithLocal.text=與本地比較
action.Frontend.Vcs.ShowStandaloneDiff.window.text=在新視窗中顯示差異
action.FullyExpandTreeNode.text=完全展開樹節點
action.GatewayPluginsAction.text=管理提供程序
action.GemRequirements.ShowSettings.text=Ruby 解釋器
action.Generate.description=生成建構函式、getter 或 setter 方法等
action.Generate.text=生成…
action.GenerateAfterClassMethod.text=AfterClass 方法
action.GenerateBeforeClassMethod.text=BeforeClass 方法
action.GenerateConstructor.description=生成建構函式
action.GenerateConstructor.text=建構函式
action.GenerateCoverageReport.text=生成覆蓋率報告(_G)
action.GenerateCreateUI.description=生成 createUI(…)
action.GenerateCreateUI.text=createUI(…)
action.GenerateDTD.text=從 XML 檔案生成 DTD(_X)
action.GenerateDataMethod.text=參數方法
action.GenerateEquals.description=生成 equals() 和 hashCode()
action.GenerateEquals.text=equals() 和 hashCode()
action.GenerateEventsScheme.description=從正在執行的 IDE 實例中收集統計資訊收集器的方案
action.GenerateEventsScheme.text=顯示 FUS 收集器方案
action.GenerateGetter.description=生成 getter
action.GenerateGetter.text=Getter
action.GenerateGetterAndSetter.description=生成 getter 和 setter
action.GenerateGetterAndSetter.text=Getter 和 Setter
action.GenerateJavadoc.description=執行 Javadoc 工具
action.GenerateJavadoc.text=生成 Javadoc(_D)…
action.GenerateLogField.description=生成記錄器
action.GenerateLogField.text=記錄器
action.GenerateModuleDescriptors.description=為專案中的所有模組 module-info 檔案 (適用於 Java 9 及更高版本)
action.GenerateModuleDescriptors.text=生成 module-info 檔案描述子
action.GenerateProviderMethod.description=生成 provider 方法
action.GenerateProviderMethod.text=provider()
action.GenerateSetUpMethod.text=SetUp 方法
action.GenerateSetter.description=生成 setter
action.GenerateSetter.text=Setter
action.GenerateSuperMethodCall.description=生成 super 方法呼叫
action.GenerateSuperMethodCall.text=super 方法呼叫
action.GenerateTearDownMethod.text=TearDown 方法
action.GenerateTestDataPathFiles.text=@TestDataPath 檔案
action.GenerateTestDataPathMethods.text=@TestDataPath 方法
action.GenerateTestMethod.text=測試方法
action.GenerateVisitorByHierarchy.text=生成層次結構存取器…
action.GenerateXmlTag.description=根據架構資訊生成新的 XML 標記
action.GenerateXmlTag.text=XML 標記…
action.GoToLastTab.description=啟用最後一個頁籤
action.GoToLastTab.text=選擇最後一個頁籤
action.GoToLinkTarget.description=在專案檢視中開啟此符號鏈接的目標
action.GoToLinkTarget.text=轉到鏈接目標
action.GoToTab.description=啟用頁籤 \\#{0}
action.GoToTab.text=選擇頁籤 \\#{0}
action.GotoAction.description=通過名稱快速導覽到動作
action.GotoAction.text=尋找動作(_F)…
action.GotoChangedFile.description=通過名稱快速導覽到更改的檔案
action.GotoChangedFile.text=轉到更改的檔案…
action.GotoClass.description=通過名稱快速導覽到類別
action.GotoClass.text=轉到類別…
action.GotoCustomRegion.text=自訂折疊…
action.GotoDeclaration.MainMenu.text=宣告或用例(_D)
action.GotoDeclaration.description=導覽到文字游標處符號的宣告或顯示其用法
action.GotoDeclaration.text=前往宣告或用法
action.GotoDeclarationOnly.MainMenu.text=宣告
action.GotoDeclarationOnly.description=導覽到文字游標處符號的宣告
action.GotoDeclarationOnly.text=轉到宣告
action.GotoFile.MainMenu.text=檔案(_F)…
action.GotoFile.description=通過名稱快速導覽到檔案
action.GotoFile.text=轉到檔案…
action.GotoImplementation.MainMenu.text=實作(_M)
action.GotoImplementation.description=導覽到所選類別或方法的實作
action.GotoImplementation.text=轉到實作(_M)
action.GotoLine.MainMenu.text=行\\:列(_L)…
action.GotoLine.description=通過編號在編輯器中導覽到某一行(和/或列)
action.GotoLine.text=轉到行\\:列…
action.GotoNextBookmark.text=下一行書籤
action.GotoNextBookmarkInEditor.text=編輯器中的下一行書籤
action.GotoNextElementUnderCaretUsage.description=導覽到下一個醒目提示的元素用法
action.GotoNextElementUnderCaretUsage.text=下一個醒目提示用例
action.GotoNextError.description=在活動編輯器中導覽到下一個醒目提示的錯誤
action.GotoNextError.text=下一個醒目提示顯示錯誤(_N)
action.GotoPrevElementUnderCaretUsage.description=導覽到上一個醒目提示的元素用法
action.GotoPrevElementUnderCaretUsage.text=轉到上一個醒目提示的元素用法
action.GotoPreviousBookmark.text=上一行書籤
action.GotoPreviousBookmarkInEditor.text=編輯器中的上一行書籤
action.GotoPreviousError.description=在活動編輯器中導覽到上一個醒目提示的錯誤
action.GotoPreviousError.text=上一個醒目提示顯示錯誤(_P)
action.GotoRelated.description=導覽到一個相關或鏈接的符號
action.GotoRelated.text=相關符號(_R)…
action.GotoSuperMethod.MainMenu.text=super 方法(_U)
action.GotoSuperMethod.description=導覽到當前方法覆寫或實作的方法的宣告
action.GotoSuperMethod.text=轉到 Super 方法
action.GotoSymbol.MainMenu.text=符號(_S)…
action.GotoSymbol.description=通過名稱快速導覽到任意符號
action.GotoSymbol.text=轉到符號…
action.GotoTest.MainMenu.text=測試(_E)
action.GotoTest.description=導覽到所選類別的測試
action.GotoTest.text=轉到測試
action.GotoTest.text.subject=轉到測試主體
action.GotoTestSubject.MainMenu.text=測試主體(_E)
action.GotoTestSubject.description=導覽到所選測試的主體
action.GotoTestSubject.text=轉到測試主體(_E)
action.GotoTypeDeclaration.MainMenu.text=類型宣告(_T)
action.GotoTypeDeclaration.description=導覽到文字游標處符號類型的宣告
action.GotoTypeDeclaration.text=轉到類型宣告
action.Graph.ActualSize.text=實際尺寸
action.Graph.AlignNodes.Bottom.text=底部
action.Graph.AlignNodes.Center.text=中心
action.Graph.AlignNodes.Left.text=左側
action.Graph.AlignNodes.Middle.text=居中排列
action.Graph.AlignNodes.Right.text=右側
action.Graph.AlignNodes.Top.text=頂部
action.Graph.ApplyCurrentLayout.text=套用當前布局
action.Graph.CopyDiagramSelectionToClipboard.text=將選區複製到剪貼簿
action.Graph.CopyEntireDiagramToClipboard.text=將圖表複製到剪貼簿
action.Graph.Current.Node.Dependencies.Filter.text=顯示所選節點與相依關係
action.Graph.Delete.text=刪除選區
action.Graph.DistributeNodes.Horizontally.text=水平排列
action.Graph.DistributeNodes.Vertically.text=垂直排列
action.Graph.EdgeRealizer.ArcEdgeRealizer.text=弧形
action.Graph.EdgeRealizer.BezierEdgeRealizer.text=貝塞爾曲線
action.Graph.EdgeRealizer.QuadCurveEdgeRealizer.text=二次曲線
action.Graph.EdgeRealizer.SmoothedPolylineEdgeRealizer.text=平滑多段線
action.Graph.EdgeRealizer.SplineEdgeRealizer.text=樣條
action.Graph.EdgeRealizer.StraightPolylineEdgeRealizer.text=直多段線
action.Graph.ExportToFile.description=匯出為 PNG、JPG、GIF、SVG 或 SVGZ 檔案
action.Graph.ExportToFile.text=匯出到圖片…
action.Graph.FitContent.text=調整內容
action.Graph.Layout.ARTreeLayouter.text=緊湊
action.Graph.Layout.BalloonEdgeBundledLayouter.text=邊緣捆綁(氣球)
action.Graph.Layout.BalloonLayouter.text=氣球
action.Graph.Layout.ChannelLayouter.text=通道
action.Graph.Layout.CircularEdgeBundledLayouter.text=邊緣捆綁(圓形)
action.Graph.Layout.CircularLayouter.text=迴圈
action.Graph.Layout.CompactOrthogonalLayouter.text=緊湊
action.Graph.Layout.CustomLayouter.text=圖特定
action.Graph.Layout.FamilyLayouter.text=系列
action.Graph.Layout.Fit.Content.text=在布局後調整內容
action.Graph.Layout.GenericLayouter.text=泛型
action.Graph.Layout.HVTreeLayouter.text=寬
action.Graph.Layout.HierarchicGroupLayouter.text=層次結構組
action.Graph.Layout.HierarchicLayouter.text=分層
action.Graph.Layout.OrganicEdgeBundledLayouter.text=邊緣捆綁(有機)
action.Graph.Layout.OrganicLayouter.text=有機
action.Graph.Layout.OrthogonalGroupLayouter.text=正交群
action.Graph.Layout.RadialEdgeBundledLayouter.text=邊緣捆綁(徑向)
action.Graph.Layout.RadialLayouter.text=徑向
action.Graph.Layout.RandomLayouter.text=隨機
action.Graph.Layout.SeriesParallelLayouter.text=串並聯
action.Graph.Layout.SingleCycleLayouter.text=單迴圈
action.Graph.LayoutOrientation.BottomToTop.text=↑ 從下到上
action.Graph.LayoutOrientation.LeftToRight.text=→ 從左到右
action.Graph.LayoutOrientation.RightToLeft.text=← 從右到左
action.Graph.LayoutOrientation.TopToBottom.text=↓ 從上到下
action.Graph.MergeEdges.BySources.text=按源
action.Graph.MergeEdges.ByTargets.text=按目標
action.Graph.NeighborhoodViewPopup.CompactMode.text=緊湊地顯示節點
action.Graph.NeighborhoodViewPopup.SameAsModelLayouter.text=與 Main 相同
action.Graph.RouteEdges.text=自動路由邊緣
action.Graph.Show.Bridges.text=顯示鏈接橋
action.Graph.Show.Edge.Labels.text=顯示邊緣標籤
action.Graph.ShowHideGrid.text=顯示網格
action.Graph.ShowStructureViewForSelectedNode.text=顯示所選節點的結構檢視
action.Graph.SnapToGrid.text=對齊到網格
action.Graph.ZoomIn.text=放大
action.Graph.ZoomOut.text=縮小
action.Graph.print.reset=重設
action.GrayFilterConfig.text=灰色篩選器(&G)
action.Help.JetBrainsTV.description=檢視介紹 JetBrains 產品功能的簡短現場示範
action.Help.JetBrainsTV.templateText=YouTube 上的 {0}
action.Help.JetBrainsTV.text=YouTube 上的產品
action.Help.KeymapReference.description=開啟帶有預設按鍵映射參考卡的 PDF 檔案
action.Help.KeymapReference.text=鍵盤快捷鍵 PDF(_K)
action.HelpTopics.description=顯示幫助內容
action.HelpTopics.text=幫助(_H)
action.HideActiveWindow.description=隱藏活動工具視窗
action.HideActiveWindow.text=隱藏活動工具視窗(_D)
action.HideAllWindows.description=隱藏所有工具視窗
action.HideAllWindows.text=隱藏所有工具視窗(_T)
action.HideSideWindows.description=隱藏本側所有視窗
action.HideSideWindows.text=隱藏本側工具視窗
action.HidpiInfo.text=顯示 HiDPI 資訊(&H)
action.HighlightUsagesInFile.description=在活動編輯器中醒目提示文字游標處符號的用法
action.HighlightUsagesInFile.not.ready=此用法搜尋需要索引，在索引建置之前無法執行
action.HighlightUsagesInFile.text=醒目提示檔案中的用法(_H)
action.HippieBackwardCompletion.description=迴圈擴展詞(向後)
action.HippieBackwardCompletion.text=迴圈擴展詞(向後)(_E)
action.HippieCompletion.description=迴圈擴展詞
action.HippieCompletion.text=迴圈擴展詞(_E)
action.Hotswap.and.compile.description=編譯專案並熱交換所有已更改的類別
action.Hotswap.and.compile.text=編譯專案並重新載入已更改的類別(_A)
action.Hotswap.description=熱交換所有已更改的類別
action.Hotswap.text=重新載入已更改的類別(_A)
action.IconScaleTestAction.text=顯示圖示比例測試對話框
action.IconsLoadTime.text=日誌圖示載入時間
action.IdeScriptingConsole.description=開啟 IDE 腳本主控台
action.IdeScriptingConsole.text=IDE 腳本主控台
action.ImageDuplicates.text=尋找圖片重複項
action.ImplementMethods.description=在當前類別中實作基接口/類別方法
action.ImplementMethods.text=實作方法(_I)…
action.ImportModule.description=從包含現有原始碼的目錄或者現有專案模型匯入模組
action.ImportModule.text=來自現有源的模組…
action.ImportModuleFromImlFile.description=將 iml 檔案作為一個模組匯入到專案
action.ImportModuleFromImlFile.text=匯入模組
action.ImportProject.description=為包含現有原始碼的目錄建立專案結構或者轉換現有專案模型
action.ImportProject.text=來自現有源的專案…
action.ImportSettings.description=匯入全域設定
action.ImportSettings.text=匯入設定…
action.ImportTestsFromFile.text=從檔案匯入測試
action.IncludeToProjectAction.text=包含到專案中
action.IncomingChanges.Refresh.description=重新整理傳入更改的列表
action.IncomingChanges.Refresh.text=重新整理
action.IncrementWindowHeight.text=增大高度
action.IncrementWindowWidth.text=增大寬度
action.IncrementalSearch.description=啟動增量搜尋(輸入時搜尋字串)，IntelliJ IDEA 6.0 實作。
action.IncrementalSearch.text=增量搜尋(_L)
action.InferNullity.description=推斷為 null 性
action.InferNullity.text=推斷為 null 性(_N)…
action.InheritanceToDelegation.description=將繼承取代為委託
action.InheritanceToDelegation.text=將繼承取代為委託(_I)…
action.Inline.description=內聯所選方法或變數
action.Inline.text=內聯(_N)…
action.InsertInlineCompletionAction.description=插入當前內聯補全提案
action.InsertInlineCompletionAction.text=插入內聯提案
action.InsertInlineCompletionLineAction.description=從當前內聯補全提案中插入下一行
action.InsertInlineCompletionLineAction.text=插入內聯提案的行
action.InsertInlineCompletionWordAction.description=從當前內聯補全提案中插入下一個單詞
action.InsertInlineCompletionWordAction.text=插入內聯提案的單詞
action.InsertLiveTemplate.description=顯示以指定前綴開頭的實時模板的彈出式列表
action.InsertLiveTemplate.text=插入實時模板(_T)…
action.InsertRubyInjection.description=在 Erb 檔案中插入 '<%\\= %>'
action.InsertRubyInjection.text=插入 '<%\\= %>'
action.InsertRubyInjectionWithoutOutput.description=在 Erb 檔案中插入 '<% %>'
action.InsertRubyInjectionWithoutOutput.text=插入 '<% %>'
action.InspectCode.description=檢查程式碼
action.InspectCode.text=檢查程式碼(_I)…
action.InspectionFilterAction.filter.by.language.text=按語言篩選
action.InspectionFilterAction.filter.inspections.text=篩選器檢查
action.IntegrateFiles.description=整合所選檔案或目錄
action.IntegrateFiles.text=整合
action.IntroduceConstant.description=將所選表達式取代為常數
action.IntroduceConstant.text=引入常數(_C)…
action.IntroduceField.description=將所選表達式的結果放入欄位中
action.IntroduceField.text=引入欄位(_F)…
action.IntroduceFunctionalParameter.description=通過呼叫新的函式方法參數來取代所選的語句
action.IntroduceFunctionalParameter.text=引入函式參數(_L)…
action.IntroduceFunctionalVariable.description=通過呼叫新的函式變數來取代所選的語句
action.IntroduceFunctionalVariable.text=引入函式變數…
action.IntroduceParameter.description=將所選表達式轉換為方法參數
action.IntroduceParameter.text=引入參數(_P)…
action.IntroduceParameterObject.description=將方法參數列表取代為物件
action.IntroduceParameterObject.text=引入參數物件(_J)…
action.IntroduceVariable.description=將所選表達式的結果放入變數中
action.IntroduceVariable.text=引入變數(_V)…
action.InvalidateCaches.description=在下次啟動時強制重新建置所有快取和索引
action.InvalidateCaches.text=使快取失效…
action.InvertBoolean.description=使方法返回值或變數包含相反的值並更正參照
action.InvertBoolean.text=反轉布林值(_B)…
action.JBCefOsrMeasureFps.text=測量 OSR JCEF FPS
action.JBCefTestApp.text=JCEF 測試套用
action.JBTabsDemo.text=JBTabs 示範
action.JShell.Console.description=啟動 JShell 主控台
action.JShell.Console.text=JShell 主控台…
action.JTabbedPaneDemo.text=JTabbedPane 示範
action.JsonCopyPointer.description=複製 JSON 指針
action.JsonCopyPointer.text=複製 JSON 指針
action.JumpToColorsAndFonts.description=跳轉到文字游標下的螢光筆的顏色選項
action.JumpToColorsAndFonts.text=跳轉到顏色和字體
action.JumpToLastChange.description=在最近的更改點中移動
action.JumpToLastChange.text=最後編輯位置(_O)
action.JumpToLastWindow.description=啟用上一個聚焦的工具視窗
action.JumpToLastWindow.text=跳轉到上一個工具視窗(_J)
action.JumpToNextChange.description=在最近的更改點中移動
action.JumpToNextChange.text=下一個編輯位置
action.KeepTabOpen.description=將預覽頁籤轉換為一般編輯器頁籤
action.KeepTabOpen.text=保持頁籤開啟
action.KeymapToCsv.text=將按鍵映射匯出到 CSV…
action.LabelSizeDemoAction.text=測試標籤大小
action.LaggingMode.text=滯後模式
action.LibrarySettings.navigate=開啟庫設定
action.LibraryUsageStatistics.text=顯示匯入的庫用法資訊
action.LightEditExitAction.text=離開(&X)
action.LightEditNewFileAction.text=新增(&N)
action.LightEditOpenFileInProjectAction.text=在專案中開啟檔案…
action.List-scrollDown.description=將周圍的可滾動區域向下滾動一頁，然後選擇相應的行
action.List-scrollDown.text=向下滾動頁面並選擇行
action.List-scrollDownExtendSelection.description=將周圍的可滾動區域向下滾動一頁，然後將相應的行新增到選區
action.List-scrollDownExtendSelection.text=向下滾動頁面並擴展選區
action.List-scrollUp.description=將周圍的可滾動區域向上滾動一頁，然後選擇相應的行
action.List-scrollUp.text=向上滾動頁面並選擇行
action.List-scrollUpExtendSelection.description=將周圍的可滾動區域向上滾動一頁，然後將相應的行新增到選區
action.List-scrollUpExtendSelection.text=向上滾動頁面並擴展選區
action.List-selectFirstRow.description=選擇第一行
action.List-selectFirstRow.text=選擇第一行
action.List-selectFirstRowExtendSelection.description=滾動到第一行並將相應行新增到選區
action.List-selectFirstRowExtendSelection.text=將選區擴展到第一行
action.List-selectLastRow.description=選擇最後一行
action.List-selectLastRow.text=選擇最後一行
action.List-selectLastRowExtendSelection.description=滾動到最後一行並將相應行新增到選區
action.List-selectLastRowExtendSelection.text=將選區擴展到最後一行
action.List-selectNextColumn.description=選擇下一列
action.List-selectNextColumn.text=選擇下一列
action.List-selectNextColumnExtendSelection.description=將下一列新增到選區
action.List-selectNextColumnExtendSelection.text=將選區擴展到下一列
action.List-selectNextRow.description=選擇下一行
action.List-selectNextRow.text=選擇下一行
action.List-selectNextRowExtendSelection.description=將下一行新增到選區
action.List-selectNextRowExtendSelection.text=將選區擴展到下一行
action.List-selectPreviousColumn.description=選擇上一列
action.List-selectPreviousColumn.text=選擇上一列
action.List-selectPreviousColumnExtendSelection.description=將上一列新增到選區。
action.List-selectPreviousColumnExtendSelection.text=將選區擴展到上一列
action.List-selectPreviousRow.description=選擇上一行
action.List-selectPreviousRow.text=選擇上一行
action.List-selectPreviousRowExtendSelection.description=將上一行新增到選區。
action.List-selectPreviousRowExtendSelection.text=將選區擴展到上一行
action.ListPersistentStateComponents.text=列出持久狀態組件
action.LoadAllContent.text=載入所有檔案內容
action.LoadAllVFSContent.text=載入所有 VFS 存儲的檔案內容
action.LoadDefaultYamlProfile.text=從 YAML 載入檢查組態檔案
action.LoadUnloadModules.text=載入/移除模組…
action.LogDebugConfigure.description=啟用或停用額外的日誌類別。允許通過請求向支援團隊提供更多資訊。
action.LogDebugConfigure.text=偵錯日誌設定(_E)…
action.LogFocusRequests.text=日誌焦點請求
action.LongBackgroundWriteAction.text=執行長時間背景寫入動作
action.MacMessagesTest.text=測試 Mac 訊息
action.MainMenuButton.ShowMenu.text=顯示折疊的主選單
action.MakeModule.description=編譯模組中的所有修改和相依檔案
action.MakeModule.text=建置模組(_M)
action.MakeStatic.description=將方法或內部類別轉換為 static 並更正所有參照
action.MakeStatic.text=設為 static(_T)…
action.ManageProjectTemplates.text=管理專案模板…
action.ManageRecentProjects.text=管理專案…
action.ManageSubscriptions.alias1=註冊
action.ManageSubscriptions.alias2=授權許可
action.ManageSubscriptions.alias3=授權
action.ManageSubscriptions.alias4=訂閱
action.ManageSubscriptions.alias5=訂閱
action.ManageSubscriptions.text=管理訂閱…
action.MarkAsContentRoot.description=取消所選目錄的排除，使其檔案可以被 IDE 的動作處理
action.MarkAsContentRoot.text=不排除
action.MarkExcludeRoot.text=已排除
action.MarkFileDirty.text=在 VCS 中將檔案標記為髒
action.MarkVfsCorrupted.text=將 VFS 標記為已損壞
action.MaximizeActiveDialog.text=最大化/還原活動對話框
action.MeetNewUIAction.text=組態新 UI
action.MemberPushDown.description=將類別成員向下推送到直接繼承子類別
action.MemberPushDown.text=向下推送成員(_S)…
action.MembersPullUp.description=將類別成員拉取至超類別或實作的接口
action.MembersPullUp.text=向上拉取成員(_L)…
action.MemoryView.EnableTrackingWithClosedWindow.text=啟用具有隱藏記憶體檢視的追蹤
action.MemoryView.JumpToTypeSource.text=跳轉到類型源
action.MemoryView.ShowAllocationStackTrace.text=跳轉到分配位置
action.MemoryView.ShowInstances.text=顯示實例
action.MemoryView.ShowNewInstances.text=顯示新實例
action.MemoryView.ShowOnlyTracked.text=僅顯示追蹤類別
action.MemoryView.ShowOnlyWithDiff.text=僅顯示非零差異
action.MemoryView.ShowOnlyWithInstances.text=僅顯示實例
action.MemoryView.SwitchUpdateMode.description=在偵錯器暫停時載入類別 (可能會增加偵錯器步進的開銷)
action.MemoryView.SwitchUpdateMode.text=在偵錯器停止時更新已載入的類別
action.MemoryView.TrackingAction.NewInstancesTracking.text=追蹤新實例
action.Merge3Files.text=合併
action.MergeAllWindowsAction.text=合併所有專案視窗
action.MergeMenuWithWindowTitleAction.text=將主選單與視窗標題合併…
action.MethodDown.description=在活動編輯器中導覽到下一個方法
action.MethodDown.text=下一個方法(_E)
action.MethodDuplicates.description=尋找所選作用域內可以轉換為所選方法/常數的呼叫的程式碼
action.MethodDuplicates.field.text=尋找欄位重複項並取代為參照…
action.MethodDuplicates.method.text=尋找方法重複項並取代為呼叫…
action.MethodDuplicates.text=尋找並取代程式碼重複項(_C)…
action.MethodHierarchy.BaseOnThisMethod.text=基於此方法
action.MethodHierarchy.ImplementMethodAction.description=實作方法(從方法層次結構)
action.MethodHierarchy.ImplementMethodAction.text=實作方法
action.MethodHierarchy.OverrideMethodAction.description=覆寫方法(從方法層次結構)
action.MethodHierarchy.OverrideMethodAction.text=覆寫方法
action.MethodHierarchy.description=瀏覽所選方法的方法層次結構
action.MethodHierarchy.text=方法層次結構(_M)
action.MethodOverloadSwitchDown.text=下一個方法多載
action.MethodOverloadSwitchUp.text=上一個方法多載
action.MethodUp.description=在活動編輯器中導覽到上一個方法
action.MethodUp.text=上一個方法(_I)
action.MinimizeCurrentWindow.description=最小化當前視窗
action.MinimizeCurrentWindow.text=最小化
action.ModuleSettings.description=為所選模組開啟設定對話框
action.ModuleSettings.navigate=開啟模組設定
action.ModuleSettings.text=模組設定(_S)
action.Move.description=將所選的類別、方法、軟體套件或 static 成員移動到另一個軟體套件或類別並更正所有參照
action.Move.text=移動(_M)…
action.MoveEditorToOppositeTabGroup.description=將編輯器移至相反的頁籤組
action.MoveEditorToOppositeTabGroup.text=移至相反的組(_M)
action.MoveElementLeft.description=將當前元素移至包含元素列表的上一個位置
action.MoveElementLeft.text=向左移動元素
action.MoveElementRight.description=將當前元素移至包含元素列表的下一個位置
action.MoveElementRight.text=向右移動元素
action.MoveFileToAnotherModule.text=將檔案移至另一個模組
action.MoveLineDown.description=將所選行向下移動一行
action.MoveLineDown.text=下移行(_W)
action.MoveLineUp.description=將所選行向上移動一行
action.MoveLineUp.text=上移行(_U)
action.MoveStatementDown.description=將所選語句向下移動一行
action.MoveStatementDown.text=向下移動語句(_W)
action.MoveStatementUp.description=將所選語句向上移動一行
action.MoveStatementUp.text=向上移動語句(_U)
action.MoveTabDown.description=將編輯器區域拆分為 2 個頁籤組，然後將當前頁籤移至底部組並關閉頂部編輯器
action.MoveTabDown.text=拆分並下移
action.MoveTabRight.description=將編輯器區域拆分為 2 個頁籤組，然後將當前頁籤移至右側組並關閉左側編輯器
action.MoveTabRight.text=拆分並右移
action.MoveToolWindowTabToEditorAction.description=作為編輯器頁籤開啟
action.MoveToolWindowTabToEditorAction.reverse.text=在工具視窗中還原
action.MoveToolWindowTabToEditorAction.text=作為編輯器頁籤開啟
action.MoveWindowBuiltinDisplayAction.description=將當前視窗移至內建螢幕
action.MoveWindowBuiltinDisplayAction.text=移至內建顯示屏
action.NavBarLocationBottom.description=在狀態列中顯示導覽列
action.NavBarLocationBottom.text=在狀態列中
action.NavBarLocationHide.description=隱藏導覽列
action.NavBarLocationHide.text=不顯示
action.NavBarLocationTop.description=在頂部顯示導覽列
action.NavBarLocationTop.text=頂部
action.NewClass.text=Java 類別
action.NewDatabaseProject.text=專案…
action.NewDir.GoToAction.text=建立新目錄或軟體套件
action.NewDir.text=目錄/軟體套件
action.NewDirectoryProject.cannot.create.dir=無法建立目錄 ''{0}''。
action.NewDirectoryProject.description=建立一個新項目
action.NewDirectoryProject.not.empty.dialog.create.new=從現有的源建立
action.NewDirectoryProject.not.empty.dialog.open.existing=開啟專案
action.NewDirectoryProject.not.empty.dialog.text=目錄 ''{0}'' 不為空。是否要從現有的原始碼建立專案?
action.NewDirectoryProject.not.empty.dialog.title=目錄不為空
action.NewDirectoryProject.text=新增專案…
action.NewDirectoryProject.title=建立專案
action.NewElement.ProjectView.text=新增檔案或目錄…
action.NewElement.description=建立新的類別、接口、檔案或目錄
action.NewElement.text=新增(_N)…
action.NewElementSamePlace.description=在此目錄中建立新的類別、接口、檔案或目錄
action.NewElementSamePlace.text=在當前目錄中新增(_N)…
action.NewFile.GoToAction.text=建立新檔案
action.NewFile.NewElementInProjectViewPopupEmptyTextLink.text=手動建立檔案
action.NewFile.description=建立一個新檔案
action.NewFile.text=檔案
action.NewHtmlFile.description=建立新的 HTML 檔案
action.NewHtmlFile.text=HTML 檔案
action.NewMigration.text=建立新遷移…
action.NewModule.description=從頭建立新模組並將其新增到專案
action.NewModule.text=模組(_M)…
action.NewModuleInGroup.text=模組
action.NewProject.ProjectWidgetPopup.text=新增專案…
action.NewProject.description=從頭建立一個新項目
action.NewProject.text=專案(_P)…
action.NewRubyMineDirectoryProject.ProjectWidgetPopup.text=新增專案…
action.NewRubyMineDirectoryProject.text=專案…
action.NewScratchBuffer.description=建立新的臨時緩衝區或重用現有的臨時緩衝區
action.NewScratchBuffer.text=新增臨時緩衝區
action.NewScratchFile.EditorPopup.text=建立新的臨時檔案
action.NewScratchFile.description=使用所選語言建立新的臨時檔案
action.NewScratchFile.text=臨時檔案
action.NewScratchFile.text.with.new=新增臨時檔案
action.NewSqlFile.description=建立新的 SQL 檔案
action.NewSqlFile.text=SQL 檔案
action.NewUiRunWidget.text=執行小工具
action.NextDiff.description=移至下一個差異
action.NextDiff.text=下一個差異
action.NextEditorTab.text=在多編輯器檔案中選擇下一個頁籤
action.NextInlineCompletionSuggestionAction.description=顯示下一個內聯補全提案
action.NextInlineCompletionSuggestionAction.text=下一個內聯提案
action.NextOccurence.description=導覽到下一個符合項
action.NextOccurence.text=下一個符合項(_X)
action.NextParameter.text=下一個參數
action.NextProjectWindow.description=切換到下一個專案視窗
action.NextProjectWindow.text=下一個專案視窗
action.NextSplitter.description=轉到下一個拆分視窗
action.NextSplitter.text=轉到下一個拆分器(_G)
action.NextTab.description=啟用下一個頁籤
action.NextTab.text=選擇下一個頁籤(_X)
action.NextTemplateParameter.text=下一個實時模板參數
action.NextTemplateVariable.text=下一個模板變數或完成就地重構
action.NextWindow.text=啟用下一個視窗
action.NotificationTestAction.text=新增測試通知
action.OnlineDocAction.description=顯示在線文檔
action.OnlineDocAction.text=入門指南(_G)
action.OpenBlankEditorInBlankDiffWindow.text=切換到空白編輯器
action.OpenBookmarkGroup.text=開啟所有已新增書籤的檔案
action.OpenEditorInOppositeTabGroup.description=在相反的頁籤組中開啟此編輯器的副本
action.OpenEditorInOppositeTabGroup.text=在相反的組中開啟(_O)
action.OpenElementInNewWindow.text=在新編輯器視窗中開啟
action.OpenEventsSchemeFileAction.description=開啟 IDE 事件日誌的方案
action.OpenEventsSchemeFileAction.text=開啟方案檔案
action.OpenEventsTestSchemeFileAction.description=開啟 IDE 事件日誌的測試方案
action.OpenEventsTestSchemeFileAction.text=開啟測試方案檔案
action.OpenFile.description=在編輯器中開啟專案或檔案
action.OpenFile.text=開啟(_O)…
action.OpenFileEditorInBlankDiffWindow.text=切換到檔案…
action.OpenInAssociatedApplication.description=在關聯的應用程式中開啟
action.OpenInAssociatedApplication.text=在關聯的應用程式中開啟
action.OpenInBrowser.description=在預設瀏覽器中開啟所選檔案
action.OpenInBrowser.text=在預設瀏覽器中開啟(_B)
action.OpenInRightSplit.description=將編輯器區域拆分為 2 個頁籤組，然後將當前檔案開啟到右側組
action.OpenInRightSplit.text=在右側拆分部分開啟
action.OpenLog.Show.text=在編輯器中顯示登入
action.OpenLog.text=在編輯器中開啟日誌
action.OpenModuleSettings.text=模組設定
action.OpenMouseWheelSmoothScrollSettings.text=平滑滾動選項
action.OpenStatisticsEventLogAction.description=開啟包含統計事件日誌的工具視窗
action.OpenStatisticsEventLogAction.text=開啟統計事件日誌
action.OptimizeImports.description=移除未使用的 import 並重新排列/重新組織 import
action.OptimizeImports.text=最佳化 import(_Z)
action.OverrideFileTypeAction.description=將當前檔案視為不同檔案類型的檔案
action.OverrideFileTypeAction.text=覆寫檔案類型
action.OverrideFileTypeAction.verbose.description=將檔案 ''{0}''{1,choice,0\\#|1\\# (和其他 {1} 個檔案)}視為不同檔案類型的檔案
action.OverrideMethods.description=在當前類別中覆寫基類別方法
action.OverrideMethods.text=覆寫方法(_O)…
action.PaintEditorLineStripeComponentAction.text=繪製編輯器文字游標條紋
action.ParameterInfo.description=顯示文字游標處方法的參數
action.ParameterInfo.text=參數資訊(_P)
action.PasteMultiple.description=從最近的剪貼簿貼上
action.PasteMultiple.text=從歷史記錄貼上(_E)…
action.Pause.description=掛起程序執行並啟用偵錯
action.Pause.text=暫停程序(_P)
action.PauseScanningAndIndexing.text=暫停掃描和索引
action.PerformGC.text=執行垃圾回收
action.Performance.ActivityMonitor.description=用於檢查哪些延伸模組和子系統使用了最多資源的工具
action.Performance.ActivityMonitor.text=活動監視器…
action.Performance.DumpThreads.text=傾印執行緒
action.Performance.MemTester.text=執行記憶體測試程序…
action.PinActiveEditorTab.description=固定活動編輯器頁籤
action.PinActiveEditorTab.text=固定活動頁籤(_I)
action.PinActiveTab.description=固定活動編輯器或工具視窗頁籤
action.PinActiveTab.text=固定活動頁籤(_I)
action.PinActiveTabToggle.description=固定活動編輯器或工具視窗頁籤
action.PinActiveTabToggle.text=固定活動頁籤
action.PinToolwindowTab.description=固定活動工具視窗頁籤
action.PinToolwindowTab.text=固定活動工具視窗頁籤(_I)
action.PlaySavedMacrosAction.description=播放儲存的巨集
action.PlaySavedMacrosAction.text=播放儲存的巨集…
action.PlaybackLastMacro.description=播放上次使用的巨集
action.PlaybackLastMacro.text=回放上一個巨集(_Y)
action.PluginManagerFiltersConfigureResetTrustDebugAction.text=Org 延伸模組篩選器\\: 重設
action.PluginManagerFiltersConfigureTrustOnlyJetBrainsDebugAction.text=Org 延伸模組篩選器\\: 僅信任 JetBrains
action.PopupHector.description=顯示面板來為當前檔案組態醒目提示模式
action.PopupHector.text=組態當前檔案分析…
action.PopupMenu-cancel.description=關閉右鍵選單。
action.PopupMenu-cancel.text=關閉右鍵選單
action.PopupMenu-return.description=開啟子選單或從所選選單項中呼叫動作
action.PopupMenu-return.text=呼叫選定動作
action.PopupMenu-selectChild.description=開啟子選單並在其中選擇相應的選單項
action.PopupMenu-selectChild.text=選擇子選單項
action.PopupMenu-selectNext.description=選擇下一個選單項
action.PopupMenu-selectNext.text=選擇下一個選單項
action.PopupMenu-selectParent.description=關閉子選單並在父選單中選擇相應的選單項
action.PopupMenu-selectParent.text=選擇父選單項
action.PopupMenu-selectPrevious.description=選擇上一個選單項
action.PopupMenu-selectPrevious.text=選擇上一個選單項
action.PositionTrackerTestAction.text=測試位置追蹤器
action.PrevInlineCompletionSuggestionAction.description=顯示上一個內聯補全提案
action.PrevInlineCompletionSuggestionAction.text=上一個內聯提案
action.PrevParameter.text=上一個參數
action.PrevSplitter.description=轉到上一個拆分視窗
action.PrevSplitter.text=轉到上一個拆分器
action.PrevTemplateParameter.text=上一個實時模板參數
action.PreviousDiff.description=移至上一個差異
action.PreviousDiff.text=上一個差異
action.PreviousEditorTab.text=在多編輯器檔案中選擇上一個頁籤
action.PreviousOccurence.description=導覽到上一個符合項
action.PreviousOccurence.text=上一個符合項(_O)
action.PreviousProjectWindow.description=切換到上一個專案視窗
action.PreviousProjectWindow.text=上一個專案視窗
action.PreviousTab.description=啟用上一個頁籤
action.PreviousTab.text=選擇上一個頁籤(_L)
action.PreviousTemplateVariable.text=上一個模板變數
action.PreviousWindow.text=啟用上一個視窗
action.Print.description=列印檔案
action.Print.text=列印(_P)…
action.ProblemsView.AutoscrollToSource.description=為所選檔案開啟編輯器，並在選區更改後導覽到所選問題
action.ProblemsView.AutoscrollToSource.text=一鍵開啟檔案
action.ProblemsView.CopyProblemDescription.description=將問題描述複製到剪貼簿
action.ProblemsView.CopyProblemDescription.text=複製問題描述
action.ProblemsView.GroupByToolId.description=允許通過檢查對問題進行分組
action.ProblemsView.GroupByToolId.text=按檢查分組
action.ProblemsView.OpenInPreviewTab.text=啟用預覽頁籤
action.ProblemsView.QuickFixes.description=顯示所選問題的可用快速修復
action.ProblemsView.QuickFixes.text=顯示快速修復
action.ProblemsView.ShowPreview.description=點擊所選問題以開啟其預覽
action.ProblemsView.ShowPreview.text=開啟編輯器預覽
action.ProblemsView.SortByName.description=允許按名稱對問題進行排序
action.ProblemsView.SortByName.text=名稱
action.ProblemsView.SortBySeverity.description=允許按嚴重性對問題進行排序
action.ProblemsView.SortBySeverity.text=嚴重性
action.ProblemsView.SortFoldersFirst.description=單獨對檔案和目錄排序
action.ProblemsView.SortFoldersFirst.text=目錄總在最前面
action.ProductivityGuide.description=顯示生產力功能使用情況統計資訊
action.ProductivityGuide.text=我的工作效率(_P)
action.ProgressIconShowcaseAction.text=進度圖示展示
action.ProjectFromVersionControl.ProjectWidgetPopup.text=克隆儲存庫…
action.ProjectFromVersionControl.text=來自版本控制的專案…
action.ProjectView.AbbreviatePackageNames.description=以縮寫形式顯示合格的軟體套件名稱
action.ProjectView.AbbreviatePackageNames.text=縮寫限定名稱
action.ProjectView.AutoscrollFromSource.description=選擇編輯器頁籤後，在“專案”檢視中選擇相應的檔案
action.ProjectView.AutoscrollFromSource.text=始終選擇開啟的檔案
action.ProjectView.AutoscrollToSource.description=選擇檔案後，將其開啟進行編輯
action.ProjectView.AutoscrollToSource.text=一鍵開啟檔案
action.ProjectView.CompactDirectories.description=如果第一個目錄僅包含第二個目錄，則將兩個相似的目錄合併到單個節點
action.ProjectView.CompactDirectories.text=壓縮目錄
action.ProjectView.CustomizeTrees.text=自訂樹檢視…
action.ProjectView.FileNesting.description=組態檔案嵌套
action.ProjectView.FileNesting.text=檔案嵌套…
action.ProjectView.FlattenModules.description=以簡單列表顯示模組
action.ProjectView.FlattenModules.text=平展模組
action.ProjectView.FlattenPackages.description=以簡單列表顯示包
action.ProjectView.FlattenPackages.text=平展軟體套件
action.ProjectView.FoldersAlwaysOnTop.description=單獨對檔案和目錄排序
action.ProjectView.FoldersAlwaysOnTop.text=目錄總在最前
action.ProjectView.HideEmptyMiddlePackages.description=隱藏空的中間軟體套件
action.ProjectView.HideEmptyMiddlePackages.text=隱藏空的中間軟體套件
action.ProjectView.ManualOrder.description=手動對檔案排序
action.ProjectView.ManualOrder.text=手動排序
action.ProjectView.OpenDirectoriesWithSingleClick.text=一鍵開啟目錄
action.ProjectView.OpenInPreviewTab.text=啟用預覽頁籤
action.ProjectView.ShowExcludedFiles.ToolwindowPopup.text=排除的檔案
action.ProjectView.ShowExcludedFiles.description=顯示排除的檔案
action.ProjectView.ShowExcludedFiles.text=顯示排除的檔案
action.ProjectView.ShowLibraryContents.ToolwindowPopup.text=庫內容
action.ProjectView.ShowLibraryContents.description=顯示庫內容
action.ProjectView.ShowLibraryContents.text=顯示庫內容
action.ProjectView.ShowMembers.ToolwindowPopup.text=成員
action.ProjectView.ShowMembers.description=顯示類別成員
action.ProjectView.ShowMembers.text=顯示成員
action.ProjectView.ShowModules.ToolwindowPopup.text=模組
action.ProjectView.ShowModules.description=顯示相應根的模組名稱
action.ProjectView.ShowModules.text=顯示模組
action.ProjectView.ShowScratchesAndConsoles.ToolwindowPopup.text=臨時檔案和主控台
action.ProjectView.ShowScratchesAndConsoles.description=顯示臨時檔案和主控台
action.ProjectView.ShowScratchesAndConsoles.text=顯示臨時檔案和主控台
action.ProjectView.ShowVisibilityIcons.ToolwindowPopup.text=可見性圖示
action.ProjectView.ShowVisibilityIcons.description=在元素名稱前顯示元素可見性圖示
action.ProjectView.ShowVisibilityIcons.text=顯示可見性圖示
action.ProjectView.SortByName.ToolwindowPopup.text=名稱
action.ProjectView.SortByName.description=按檔名對檔案進行排序
action.ProjectView.SortByName.text=按名稱排序
action.ProjectView.SortByTimeAscending.ToolwindowPopup.text=修改時間(從舊到新)
action.ProjectView.SortByTimeAscending.description=按最後修改時間對檔案進行排序，從舊到新
action.ProjectView.SortByTimeAscending.text=按修改時間排序(從舊到新)
action.ProjectView.SortByTimeDescending.ToolwindowPopup.text=修改時間(從新到舊)
action.ProjectView.SortByTimeDescending.description=按最後修改時間對檔案進行排序，從新到舊
action.ProjectView.SortByTimeDescending.text=按修改時間排序(從新到舊)
action.ProjectView.SortByType.ToolwindowPopup.text=類型
action.ProjectView.SortByType.description=單獨對不同類型的檔案排序
action.ProjectView.SortByType.text=按類型排序
action.ProjectViewEditSource.text=編輯源
action.ProjectViewExpandAll.text=全部展開
action.PruneEmptyDirectories.text=刪除空目錄
action.QuickActionPopup.text=顯示快速動作彈出視窗
action.QuickChangeScheme.description=更改當前的程式碼樣式方案、顏色與字體方案、按鍵映射或外觀
action.QuickChangeScheme.text=快速切換方案(_Q)…
action.QuickDocCopy.text=複製快速文檔
action.QuickImplementations.description=顯示包含符號(及其實作)內容的彈出視窗
action.QuickImplementations.text=快速定義(_K)
action.QuickJavaDoc.description=顯示包含文字游標處符號的文檔的彈出視窗
action.QuickJavaDoc.text=快速文檔(_D)
action.QuickPreview.text=快速預覽
action.QuickTypeDefinition.description=顯示包含文字游標處符號的類型定義的彈出視窗
action.QuickTypeDefinition.text=快速類型定義
action.RearrangeCode.description=重新排列程式碼
action.RearrangeCode.text=重新排列程式碼
action.RecentChangedFiles.description=顯示最近更改的檔案的列表
action.RecentChangedFiles.text=最近更改的檔案
action.RecentChangedFilesFallback.description=顯示最近更改的檔案的列表
action.RecentChangedFilesFallback.text=最近更改的檔案
action.RecentFiles.description=顯示最近檢視的檔案的列表
action.RecentFiles.text=最近的檔案(_N)
action.RecentFilesFallback.description=顯示最近檢視的檔案的列表
action.RecentFilesFallback.text=最近的檔案(_N)
action.RecentLocations.description=顯示最近檢視/更改的位置的列表
action.RecentLocations.text=最近的位置
action.RecordStateCollectors.description=將所有狀態收集器和記錄結果呼叫到事件日誌
action.RecordStateCollectors.text=將狀態收集器記錄到事件日誌
action.RedesignedRunConfigurationSelector.text=選擇執行/偵錯組態
action.Refactorings.QuickListPopupAction.description=包含重構動作列表的上下文感知彈出視窗
action.Refactorings.QuickListPopupAction.text=重構…
action.ReformatCode.description=重新設定程式碼格式
action.ReformatCode.synonym1=設定程式碼格式
action.ReformatCode.text=重新設定程式碼格式(_R)
action.Refresh.text=重新整理(_E)
action.Register.description=輸入註冊資料
action.Register.text=註冊(_R)…
action.ReloadProjectAction.text=重新載入專案
action.RemoveBom.text=移除 BOM
action.RemoveFromScopeAction.text=從作用域中移除
action.RemoveStripeButton.description=從側邊列移除工具視窗按鈕
action.RemoveStripeButton.text=從側邊列中移除
action.RenameAction.text=重新命名…
action.RenameElement.description=重新命名所選符號並更正所有參照
action.RenameElement.text=重新命名(_R)…
action.RenameFile.description=重新命名所選檔案
action.RenameFile.text=重新命名檔案…
action.ReopenClosedTab.text=重新開啟關閉的頁籤
action.RepairDebuggerViewAction.description=嘗試將偵錯器檢視修復到可信狀態
action.RepairDebuggerViewAction.text=修復偵錯器檢視
action.Replace.description=將活動編輯器中的字串取代為另一個字串
action.Replace.text=取代(_R)…
action.ReplaceInPath.description=在多個檔案中使用另一個字串取代一個字串
action.ReplaceInPath.synonym1=在路徑中取代(_A)
action.ReplaceInPath.text=在檔案中取代(_A)…
action.ReplaceMethodWithMethodObject.description=將方法轉換為自己的物件，以便所有參數都成為該物件上的欄位
action.ReplaceMethodWithMethodObject.text=將方法取代為方法物件(_J)…
action.ReportProblem.description=在 JetBrains 問題追蹤器中提交錯誤報告
action.ReportProblem.text=提交 bug 報告…
action.ReportSettingsToFUS.text=將更改的設定記錄到事件日誌
action.RequestCachesDefragmentation.text=請求 VFS 和索引碎片整理
action.Rerun.text=重新執行
action.RerunFailedTests.description=僅執行上次執行後失敗/崩潰的測試；按 Shift 鍵選擇“執行/偵錯”模式
action.RerunFailedTests.text=重新執行失敗的測試
action.RerunTests.text=重新執行測試
action.ResetFilterAction.text=重設篩選器
action.ResetGotItTooltips.text=重設“知道了”工具提示
action.ResetIdeScaleAction.text=重設 IDE 比例
action.ResetWindowsDefenderNotification.text=重設 Microsoft Defender 通知
action.ResizeToolWindowDown.description=將活動工具視窗延伸至底部
action.ResizeToolWindowDown.text=延伸至底部
action.ResizeToolWindowLeft.description=將活動工具視窗延伸至左側
action.ResizeToolWindowLeft.text=延伸至左側
action.ResizeToolWindowMaximize.text=最大化工具視窗
action.ResizeToolWindowMaximize.text.alternative=還原工具視窗大小
action.ResizeToolWindowRight.description=將活動工具視窗延伸至右側
action.ResizeToolWindowRight.text=延伸至右側
action.ResizeToolWindowUp.description=將活動工具視窗延伸至頂部
action.ResizeToolWindowUp.text=延伸至頂部
action.RestartIde.text=重啟 IDE…
action.RestoreDefaultExtensionScripts.description=重設此目錄的捆綁擴展
action.RestoreDefaultExtensionScripts.text=重設預設擴展
action.RestoreDefaultLayout.description=恢復當前所選布局
action.RestoreDefaultLayout.named.description=恢復當前所選布局(“{0}”)
action.RestoreDefaultLayout.text=恢復當前布局(_R)
action.RestoreDefaultSettings.description=將所有設定重設為其預設值
action.RestoreDefaultSettings.text=恢復預設設定…
action.RestoreFactoryDefaultLayout.description=將工具視窗布局重設為出廠預設設定
action.RestoreFactoryDefaultLayout.text=預設
action.RestoreFontPreviewTextAction.text=還原預覽文本
action.RestoreNamedLayout.description=還原布局“{0}”
action.RestoreProtocolHandler.text=註冊 Gateway 協議
action.RestoreShelvedChange.text=還原
action.Resume.description=恢復程序執行
action.Resume.text=恢復程序(_G)
action.RetypeFile.text=重新輸入當前檔案
action.RevealIn.description=在作業系統檔案管理器中醒目提示檔案
action.RevealIn.name.mac=在“訪達”中顯示
action.RevealIn.name.other=在 {0} 中顯示
action.RevealIn.text=在檔案管理器中顯示
action.ReverteOverrideFileTypeAction.description=撤消“覆寫檔案類型”動作並還原舊檔案類型
action.ReverteOverrideFileTypeAction.text=還原檔案類型覆寫
action.ReverteOverrideFileTypeAction.verbose.description=撤消“覆寫檔案類型”動作並為檔案 ''{0}''{1,choice,0\\#|1\\# (和其他 {1} 個檔案)}還原舊的檔案類型
action.RubyMineDemos.description=檢視介紹 RubyMine 功能的簡短現場示範
action.RubyMineDemos.text=示範和教程
action.RubyMineDeveloperCommunity.description=RubyMine 開發者社區論壇
action.RubyMineDeveloperCommunity.text=開發者社區
action.RubyMineProjectFromVersionControlAction.ProjectWidgetPopup.text=克隆儲存庫…
action.RubyMineProjectFromVersionControlAction.text=來自版本控制的專案…
action.RulerGuide.text=標尺參考線
action.RunAnything.description=允許執行任何指令
action.RunAnything.text=執行任何內容
action.RunConfiguration.description=選擇執行/偵錯組態
action.RunConfiguration.text=選擇執行/偵錯組態
action.RunConfigurationTemplatesForNewProjects.MainMenu.text=執行組態模板…
action.RunDashboard.AddConfiguration.text=執行組態…
action.RunDashboard.ClearConsole.text=清除主控台
action.RunDashboard.ClearContent.text=清除內容
action.RunDashboard.CopyConfiguration.text=複製組態
action.RunDashboard.Debug.text=偵錯
action.RunDashboard.DoubleClickRun.text=雙擊以執行組態
action.RunDashboard.EditConfiguration.text=編輯所選組態
action.RunDashboard.GroupByStatus.text=狀態
action.RunDashboard.GroupByType.text=類型
action.RunDashboard.GroupConfigurations.text=分組組態
action.RunDashboard.HideConfiguration.text=隱藏組態
action.RunDashboard.OpenRunningConfigInNewTab.text=在新頁籤中開啟執行組態
action.RunDashboard.RemoveType.text=從服務中移除組態類型
action.RunDashboard.RestoreConfiguration.text=還原組態
action.RunDashboard.RestoreHiddenConfigurations.text=還原隱藏的組態
action.RunDashboard.Run.text=執行
action.RunDashboard.Stop.text=停止
action.RunDashboard.UngroupConfigurations.text=對組態取消分組
action.RunToCursor.description=跳轉到文字游標所在的行
action.RunToCursor.text=執行到游標處(_C)
action.RunToolbarEditConfigurationAction.text=編輯組態…
action.RunToolbarMainMultipleStopAction.text=停止
action.RunToolbarMainRunConfigurationsAction.text=新增組態…
action.RunToolbarMainSlotActive.text=有效程序
action.RunToolbarMainSlotInfoAction.text=有效程序
action.RunToolbarMoveToTopAction.text=將組態移至頂部
action.RunToolbarPauseAction.text=暫停
action.RunToolbarProcessStartedAction.text=有效程序
action.RunToolbarRemoveSlotAction.terminating=正在終止
action.RunToolbarRemoveSlotAction.text=移除
action.RunToolbarRerunAction.text=重新執行
action.RunToolbarResumeAction.text=恢復
action.RunToolbarRollbackToPrevious.text=回滾到上一個工具列
action.RunToolbarRunConfigurationsAction.text=新增組態…
action.RunToolbarShowHidePopupAction.click.to.open.combo.text=點擊以選擇執行組態
action.RunToolbarShowHidePopupAction.click.to.open.toolwindow.text=點擊以開啟“程序”工具視窗
action.RunToolbarShowHidePopupAction.click.to.show.popup.text=點擊以顯示或隱藏停靠的組態
action.RunToolbarShowHidePopupAction.show.popup.text=顯示或隱藏停靠的組態
action.RunToolbarShowHidePopupAction.text=同時啟動多個組態
action.RunToolbarShowToolWindowTab.text=顯示“程序”工具視窗
action.RunToolbarStopAction.text=停止
action.RunToolbarWidgetAction.text=執行/偵錯小工具
action.Runner.CloseAllUnpinnedViews.description=關閉所有未固定的頁籤
action.Runner.CloseAllUnpinnedViews.text=關閉所有未固定的
action.Runner.CloseAllViews.description=關閉所有檢視
action.Runner.CloseAllViews.text=關閉所有
action.Runner.CloseOtherViews.description=關閉其他檢視
action.Runner.CloseOtherViews.text=關閉其他
action.Runner.CloseView.description=關閉檢視
action.Runner.CloseView.text=關閉
action.Runner.FocusOnStartup.description=當 UI 顯示時預設將此檢視設為焦點
action.Runner.FocusOnStartup.text=在啟動時獲取焦點
action.Runner.RestoreLayout.description=將偵錯器會話的可視元素還原為預設狀態
action.Runner.RestoreLayout.text=恢復預設布局
action.Runner.ToggleTabLabels.text=顯示頁籤標籤
action.SafeDelete.description=刪除所選的類別、方法或欄位，檢查用法
action.SafeDelete.text=安全刪除(_D)…
action.SaveAll.description=儲存所有檔案和設定
action.SaveAll.text=全部儲存(_S)
action.SaveAs.text=另存為…
action.SaveAsNewFormat.text=另存為基於目錄的格式…
action.SaveAsTemplate.description=將所選文本儲存為實時模板
action.SaveAsTemplate.text=儲存為實時模板(_I)…
action.SaveDocument.description=只儲存在當前編輯器中開啟的檔案
action.SaveDocument.text=儲存文檔
action.SaveFileAsTemplate.description=將當前檔案另存為模板
action.SaveFileAsTemplate.text=將檔案另存為模板(_L)…
action.SaveProjectAsTemplate.text=將專案另存為模板…
action.SaveTemporaryRunConfiguration.description=儲存臨時執行組態
action.SaveTemporaryRunConfiguration.text=儲存組態
action.ScanSourceCommentsAction.text=傾印專案中的所有註釋
action.ScopeView.EditScopes.description=編輯作用域…
action.ScopeView.EditScopes.text=編輯作用域(_I)…
action.Scratch.ChangeLanguage.description=更改臨時檔案語言
action.Scratch.ChangeLanguage.text=更改檔案語言
action.Scratch.ExportToScratch.description=作為文本匯出到新的臨時檔案
action.Scratch.ExportToScratch.text=匯出到臨時檔案
action.Scratch.ShowFilesPopup.description=在彈出視窗中顯示臨時檔案
action.Scratch.ShowFilesPopup.text=顯示臨時檔案
action.ScrollPane-scrollDown.description=將周圍的可滾動區域向下滾動一頁
action.ScrollPane-scrollDown.text=向下滾動頁面
action.ScrollPane-scrollEnd.description=將周圍的可滾動區域滾動到底部
action.ScrollPane-scrollEnd.text=滾動至頁尾
action.ScrollPane-scrollHome.description=將周圍的可滾動區域滾動到頂部
action.ScrollPane-scrollHome.text=滾動至頁首
action.ScrollPane-scrollLeft.description=將周圍的可滾動區域向左滾動一頁
action.ScrollPane-scrollLeft.text=向左滾動頁面
action.ScrollPane-scrollRight.description=將周圍的可滾動區域向右滾動一頁
action.ScrollPane-scrollRight.text=向右滾動頁面
action.ScrollPane-scrollUp.description=將周圍的可滾動區域向上滾動一頁
action.ScrollPane-scrollUp.text=向上滾動頁面
action.ScrollPane-unitScrollDown.description=將周圍的可滾動區域向下滾動一個單位
action.ScrollPane-unitScrollDown.text=向下滾動
action.ScrollPane-unitScrollLeft.description=將周圍的可滾動區域向左滾動一個單位
action.ScrollPane-unitScrollLeft.text=向左滾動
action.ScrollPane-unitScrollRight.description=將周圍的可滾動區域向右滾動一個單位
action.ScrollPane-unitScrollRight.text=向右滾動
action.ScrollPane-unitScrollUp.description=將周圍的可滾動區域向上滾動一個單位
action.ScrollPane-unitScrollUp.text=向上滾動
action.ScrollTreeToCenter.text=滾動到中心
action.SearchEverywhere.CompleteCommand.description=在“隨處搜尋”對話框中自動補全指令
action.SearchEverywhere.CompleteCommand.text=補全指令
action.SearchEverywhere.NavigateToNextGroup.description=在“隨處搜尋”對話框中導覽到下一個組
action.SearchEverywhere.NavigateToNextGroup.text=下一個組元素
action.SearchEverywhere.NavigateToPrevGroup.description=在“隨處搜尋”對話框中導覽到上一個組
action.SearchEverywhere.NavigateToPrevGroup.text=上一個組元素
action.SearchEverywhere.NextTab.description=在“隨處搜尋”對話框中切換到下一個頁籤
action.SearchEverywhere.NextTab.text=下一個頁籤
action.SearchEverywhere.PrevTab.description=在“隨處搜尋”對話框中切換到上一個頁籤
action.SearchEverywhere.PrevTab.text=上一個頁籤
action.SearchEverywhere.SelectItem.description=在“隨處搜尋”對話框中選擇一個條目
action.SearchEverywhere.SelectItem.text=選擇條目
action.SearchEverywhere.description=搜尋類別、檔案、工具視窗、動作和偏好設定
action.SearchEverywhere.text=隨處搜尋
action.SearchEverywhereNewToolbarAction.text=隨處搜尋
action.SearchEverywhereToolbar.searching.text=正在搜尋…
action.SearchEverywhereToolbar.text=隨處搜尋
action.SearchEverywhereToolbarHotKey.hotkey=Shift+Shift
action.SearchEverywhereToolbarHotKey.text=隨處搜尋 {0}
action.SegmentedButton-left.text=選擇上一個分段按鈕
action.SegmentedButton-right.text=選擇下一個分段按鈕
action.SegmentedVcsControlAction.text=VCS 小工具
action.SelectAllOccurrences.description=通過將當前單詞的所有符合項新增到選區來設定多個游標。
action.SelectAllOccurrences.text=選擇所有符合項
action.SelectAndDumpInvalidTipsOfTheDay.text=選擇並傾印無效的每日小技巧
action.SelectAndShowTip.text=選擇並顯示提示(_S)
action.SelectIn.description=在任意檢視下選擇當前的類別或方法
action.SelectIn.text=選擇位置(_L)…
action.SelectInProjectView.description=在專案檢視中選擇上下文檔案
action.SelectInProjectView.directory.text=在專案檢視中選擇目錄
action.SelectInProjectView.text=在專案檢視中選擇檔案
action.SelectNextOccurrence.description=通過將當前單詞的下一個符合項新增到選區來設定多個游標。
action.SelectNextOccurrence.text=將下一個符合項新增到選擇
action.SelectOpenedFileInProjectView.description=在專案檢視中選擇已開啟的檔案
action.SelectOpenedFileInProjectView.text=選擇開啟的檔案
action.SelectVirtualTemplateElement.text=顯示用於就地重構的選項彈出視窗
action.SendEOF.text=發送 EOF
action.SendEventLogStatistics.description=將事件日誌檔案發送到 QA 伺服器
action.SendEventLogStatistics.text=將功能使用事件日誌發送到生產環境
action.SendFeedback.detailed.description=提交反饋給 {0}
action.SendFeedback.text=提交反饋(_F)…
action.ServiceView.ConfigureServices.text=組態服務工具視窗
action.ServiceView.GroupByContributor.text=按類型對服務分組
action.ServiceView.JumpToServices.text=跳轉到服務
action.ServiceView.OpenEachInNewTab.text=在新頁籤中開啟每個項
action.ServiceView.OpenInNewTab.text=在新頁籤中開啟
action.ServiceView.OpenInToolWindow.text=在單獨的工具視窗中開啟
action.ServiceView.SelectActiveService.text=始終選擇有效服務
action.ServiceView.ShowServices.text=顯示服務樹
action.ServiceView.SplitByType.text=在新頁籤中開啟每個類型
action.SetCaretVisualAttributesInternalAction.text=設定文字游標視覺特性…
action.SetShortcutAction.text=新增快捷鍵…
action.SettingsEditor.SaveChanges.text=儲存更改
action.SettingsEditor.ToggleSidebar.text=切換側邊列
action.SeverityEditorDialogAction.text=顯示嚴重性編輯器
action.ShelveChanges.UnshelveWithDialog.description=更正套用補丁的路徑並取消擱置
action.ShelveChanges.UnshelveWithDialog.text=取消擱置…
action.ShelvedChanges.Rename.description=重新命名擱置的更改列表
action.ShelvedChanges.Rename.text=重新命名…
action.ShelvedChanges.Restore.text=還原已套用的擱置更改
action.ShelvedChanges.ShowHideDeleted.description=顯示/隱藏已取消擱置更改
action.ShelvedChanges.ShowHideDeleted.text=顯示/隱藏已套用的擱置更改
action.Show.Current.Revision.text=顯示當前修訂
action.ShowBackwardPackageDeps.MainMenu.text=向後相依關係(_B)…
action.ShowBackwardPackageDeps.description=瀏覽使用的程式碼所選分析條目
action.ShowBackwardPackageDeps.text=分析向後相依關係(_B)…
action.ShowBlankDiffWindow.description=並排開啟兩個編輯器並比較他們的內容
action.ShowBlankDiffWindow.synonym1=開啟空的差異視窗
action.ShowBlankDiffWindow.synonym2=開啟新的差異視窗
action.ShowBlankDiffWindow.text=開啟空白差異視窗
action.ShowBookmarks.text=顯示書籤…
action.ShowBundleLocalizationDialogAction.text=顯示捆綁包訊息
action.ShowChangedStateStatisticsAction.description=呼叫所有狀態收集器，並僅顯示自上一個記錄以來已更改的事件
action.ShowChangedStateStatisticsAction.text=僅顯示已更改的狀態事件
action.ShowColorPicker.text=顯示取色器
action.ShowCompressibleToolbarAction.text=顯示動態壓縮工具列
action.ShowContent.description=顯示一個包含工具視窗頁籤列表的彈出視窗
action.ShowContent.text=顯示頁籤列表
action.ShowContent.views.text=顯示檢視列表
action.ShowControlFlowAction.text=顯示控制流
action.ShowDependenciesOnTarget.MainMenu.text=指定目標上的相依項
action.ShowDependenciesOnTarget.text=分析指定目標上的相依項
action.ShowDetailedInformationAction.text=顯示間接相依項
action.ShowDiscoveredTests.text=顯示受影響的測試
action.ShowEditorHighlighterTokens.text=顯示編輯器螢光筆令牌
action.ShowEdtUtilizationChart.description=啟用對寫入、讀取和寫入意圖鎖下的 EDT 使用情況的監測
action.ShowEdtUtilizationChart.text=顯示 EDT 使用情況圖表
action.ShowErrorDescription.description=在文字游標處顯示錯誤或警告的描述
action.ShowErrorDescription.text=錯誤描述(_R)
action.ShowExecutionPoint.description=顯示當前程序執行點
action.ShowExecutionPoint.text=顯示執行點(_X)
action.ShowExperiments.text=實驗性功能…
action.ShowFilePath.description=顯示帶有當前檔案路徑的彈出視窗，以便在外部檔案管理器中開啟
action.ShowFilePath.popup=路徑彈出視窗(_P)
action.ShowFilePath.text=檔案路徑(_P)
action.ShowFontsUsedByEditor.description=允許找出編輯器中實際使用的回退字體
action.ShowFontsUsedByEditor.text=顯示編輯器使用的字體
action.ShowGotItDemo.text=顯示 GotIt 示範
action.ShowGutterIconsSettings.description=顯示用於組態裝訂區域圖示的對話框
action.ShowGutterIconsSettings.text=組態裝訂區域圖示…
action.ShowHideDebugInfoInUi.text=UI 中的偵錯資訊
action.ShowHoverInfo.description=在文字游標處顯示帶有符號文檔以及錯誤或警告描述的工具提示
action.ShowHoverInfo.text=懸停資訊
action.ShowInlineBanner.text=顯示內聯橫幅
action.ShowInlineCompletionStatistics.text=顯示內聯補全統計資訊
action.ShowIntentionActions.text=顯示上下文動作
action.ShowLiveRunConfigurations.description=顯示當前正在執行的執行組態列表
action.ShowLiveRunConfigurations.text=顯示正在執行的列表
action.ShowLog.Explorer.text=在資源管理器中顯示日誌(_L)
action.ShowLog.Finder.text=在“訪達”中顯示日誌(_L)
action.ShowLog.description=開啟包含日誌檔案的目錄
action.ShowLog.text=在檔案管理器中顯示日誌(_L)
action.ShowMainMenu.text=顯示主選單
action.ShowMembersInNavigationBar.description=在導覽列中顯示/隱藏宣告
action.ShowMembersInNavigationBar.text=顯示成員
action.ShowModulesDependencies.MainMenu.text=模組相依項(_M)…
action.ShowModulesDependencies.description=顯示專案中模組之間的相依關係
action.ShowModulesDependencies.text=分析模組相依關係(_M)…
action.ShowNonRetinaImages.text=顯示非 Retina 圖片
action.ShowNotificationIconsDialogAction.text=測試通知圖示
action.ShowPackageCycles.MainMenu.text=迴圈相依關係(_C)…
action.ShowPackageCycles.description=瀏覽迴圈中使用的程式碼所選分析條目
action.ShowPackageCycles.text=分析迴圈相依關係(_C)…
action.ShowPackageDeps.MainMenu.text=相依項(_D)…
action.ShowPackageDeps.description=瀏覽所選分析項所相依的程式碼
action.ShowPackageDeps.text=分析相依關係(_D)…
action.ShowParameterHintsSettings.description=開啟參數名稱提示設定
action.ShowParameterHintsSettings.text=提示設定…
action.ShowPopupMenu.text=顯示右鍵選單
action.ShowProcessWindow.description=顯示/隱藏背景任務視窗
action.ShowProcessWindow.double.click=點擊以顯示/隱藏背景任務視窗
action.ShowProcessWindow.text=顯示
action.ShowProgressTestDialogAction.text=測試進度指示器
action.ShowProjectStructureSettings.description=組態專案結構
action.ShowProjectStructureSettings.text=專案結構…
action.ShowRecentTests.text=最近的測試
action.ShowReformatFileDialog.text=重新設定檔案格式…
action.ShowRegistry.text=註冊表…
action.ShowSearchEverywhereItemInfo.text=顯示“隨處搜尋”條目資訊
action.ShowSearchHistory.text=顯示搜尋歷史記錄
action.ShowSettingsAndFindUsages.description=為“尋找用法”動作選擇作用域和編輯選項
action.ShowSettingsAndFindUsages.text=尋找用法設定…
action.ShowSettingsWithAddedPattern.description=開啟參數名稱提示設定
action.ShowSettingsWithAddedPattern.text=停用方法的提示
action.ShowSiblings.description=顯示包含符號同級內容的彈出視窗
action.ShowSiblings.text=顯示同級
action.ShowSouthPanelTestDialogAction.text=測試 DialogWrapper 南側面板
action.ShowSplash.text=顯示初始頁面
action.ShowTips.description=學習如何提高編碼效率。
action.ShowTips.text=每日小技巧(_T)
action.ShowToolbar.text=顯示工具列
action.ShowTrustProjectDialog.text=信任專案…
action.ShowTypeBookmarks.text=轉到助記符…
action.ShowUpdateDialogAction.text=顯示“更新”對話框
action.ShowUsageFeatures.text=顯示用法功能
action.ShowUsages.description=顯示文字游標處符號的用法
action.ShowUsages.text=顯示用法(_S)
action.SilentCodeCleanup.description=執行清理檢查並使用當前檢查組態檔案套用快速修復
action.SilentCodeCleanup.text=靜默程式碼清理
action.SilentHeapDumpSnapshot.text=建立並安排堆傾印分析(非使用者呼叫)
action.SkipWindowDeactivationEvents.description=開啟以簡化偵錯。當偵錯 IDE 中的中斷點命中時，主 IDE 會竊取焦點，並且偵錯 IDE 中的 \`WINDOW_DEACTIVATED\` 事件會觸發彈出視窗或檔案分析的取消，從而使 \`ProgressManager.checkCanceled()\` 立即拋出，而不提供任何機會偵錯。
action.SkipWindowDeactivationEvents.text=跳過視窗停用事件
action.SliceBackward.MainMenu.text=流入此處的資料(_T)…
action.SliceBackward.description=搜尋可以分配給所選表達式的值
action.SliceBackward.text=分析流入此處的資料(_T)…
action.SliceForward.MainMenu.text=流出此處的資料(_F)…
action.SliceForward.description=搜尋從此位置轉義的值
action.SliceForward.text=分析流出此處的資料(_F)…
action.SmartSelect.text=擴展選區
action.SmartStepInto.description=步入特定方法
action.SmartStepInto.text=智能步入(_P)
action.SmartTypeCompletion.description=基於預期類型補全程式碼
action.SmartTypeCompletion.synonym=SmartType
action.SmartTypeCompletion.synonym2=智能補全
action.SmartTypeCompletion.text=類型符合
action.SmartUnSelect.text=收縮選區
action.SpeedSearch.GotItTooltip.text=輸入任意符號可開啟搜尋框。無需按 {0}。
action.SpeedSearch.GotItTooltip.textWithoutShortcuts=輸入任意符號可開啟搜尋框。無需手動呼叫該動作。
action.SpeedSearch.shortcutTextSuffix=或任意符號
action.SpeedSearch.text=快速搜尋
action.SplitChooser.Duplicate.text=複製
action.SplitChooser.Exit.text=離開選擇器
action.SplitChooser.NextWindow.text=下一個拆分
action.SplitChooser.PreviousWindow.text=上一個拆分
action.SplitChooser.Split.text=拆分
action.SplitChooser.SplitCenter.text=無拆分
action.SplitChooser.SplitDown.text=使用向下拆分或向下切換
action.SplitChooser.SplitLeft.text=使用向左拆分或向左切換
action.SplitChooser.SplitRight.text=使用向右拆分或向右切換
action.SplitChooser.SplitTop.text=使用頂部拆分或向上切換
action.SplitChooser.description=允許在編輯器中互動選擇拆分位置，並在該處開啟/移動所選檔案
action.SplitChooser.text=通過選擇器以拆分方式開啟…
action.SplitHorizontally.description=將編輯器區域拆分為 2 個頁籤組，然後將當前頁籤移至底部組
action.SplitHorizontally.synonym=水平拆分
action.SplitHorizontally.text=向下拆分
action.SplitVertically.description=將編輯器區域拆分為 2 個頁籤組，然後將當前頁籤移至右側組
action.SplitVertically.synonym=垂直拆分
action.SplitVertically.text=向右拆分
action.Start.Use.Vcs.Vcs.Toolbar.Widget.text=其他服務…
action.Start.Use.Vcs.text=啟用版本控制整合(_E)…
action.StartStopMacroRecording.description=啟動/停止新巨集錄製
action.StartStopMacroRecording.text=啟動/停止巨集錄製(_R)
action.StaticIconFields.text=列出 static 圖示欄位初始設定式
action.StatusTextModeAction.text=狀態文本
action.StepInto.description=單步執行至已執行的下一行
action.StepInto.text=步入(_I)
action.StepOut.description=單步執行至從此方法返回後執行的第一行
action.StepOut.text=步出(_T)
action.StepOver.description=單步執行至此檔案中的下一行
action.StepOver.text=步過(_O)
action.StepOverInstruction.description=在指令級別執行單步跳過
action.StepOverInstruction.text=單步跳過指令
action.Stop.description=停止程序
action.Stop.text=停止
action.StopBackgroundProcesses.description=停止背景程序
action.StopBackgroundProcesses.text=停止背景程序…
action.StoreDefaultLayout.description=儲存當前所選布局中的更改
action.StoreDefaultLayout.named.description=儲存當前所選布局(“{0}”)中的更改
action.StoreDefaultLayout.synonym=存儲當前布局
action.StoreDefaultLayout.text=儲存當前布局中的更改(_S)
action.StoreNewLayout.description=以新名稱儲存當前布局
action.StoreNewLayout.text=將當前布局另存為新布局(_N)…
action.StretchSplitToBottom.description=將拆分的編輯器延伸至底部
action.StretchSplitToBottom.text=將編輯器延伸至底部
action.StretchSplitToLeft.description=向左拉伸編輯器拆分
action.StretchSplitToLeft.text=將編輯器延伸至左側
action.StretchSplitToRight.description=將拆分的編輯器延伸至右側
action.StretchSplitToRight.text=將編輯器延伸至右側
action.StretchSplitToTop.description=將拆分的編輯器延伸至頂部
action.StretchSplitToTop.text=將編輯器延伸至頂部
action.StructuralSearchPlugin.StructuralReplaceAction.description=結構取代
action.StructuralSearchPlugin.StructuralReplaceAction.text=結構化取代(_C)…
action.StructuralSearchPlugin.StructuralSearchAction.description=結構搜尋
action.StructuralSearchPlugin.StructuralSearchAction.text=結構化搜尋(_T)…
action.SurroundWith.description=使用 if/while/try-catch 或其他結構包圍所選程式碼段
action.SurroundWith.text=環繞方式(_S)…
action.SurroundWithEmmet.description=使用 Emmet 縮寫包圍所選程式碼
action.SurroundWithEmmet.text=使用 Emmet 包圍
action.SurroundWithLiveTemplate.description=使用一個模板包圍選區
action.SurroundWithLiveTemplate.text=使用實時模板包圍(_P)…
action.SurroundWithTagTemplate.description=使用標記包圍所選程式碼
action.SurroundWithTagTemplate.text=使用標記包圍
action.SwapSidesInDiffWindow.text=交換兩側
action.SwapThreeWayColorModeInDiffWindow.text=更改三向檢視器模式
action.SwitchCoverage.text=顯示程式碼覆蓋率資料(_V)
action.SwitchFileBasedIndexStorageAction.text=切換基於檔案的索引存儲
action.SwitchIdeScaleAction.text=縮放 IDE
action.Switcher.text=切換器
action.SwitcherBackward.text=選擇上一行
action.SwitcherBackwardFallback.text=切換到左側的頁籤
action.SwitcherFallback.text=切換器
action.SwitcherForward.text=選擇下一行
action.SwitcherForwardFallback.text=切換到右側的頁籤
action.SwitcherIterateItems.text=迭代最近的檔案
action.SwitcherIterateItemsFallback.text=迭代最近的檔案
action.SwitcherNextProblem.text=選擇下一個問題檔案
action.SwitcherNextProblemFallback.text=選擇下一個問題檔案
action.SwitcherPreviousProblem.text=選擇上一個問題檔案
action.SwitcherPreviousProblemFallback.text=選擇上一個問題檔案
action.SwitcherRecentEditedChangedToggleCheckBox.text=切換僅更改的檔案
action.SwitcherRecentEditedChangedToggleCheckBoxFallback.text=切換僅更改的檔案
action.Synchronize.description=檢測所有外部更改的檔案，並從磁碟重新載入
action.Synchronize.text=從磁碟全部重新載入
action.SynchronizeCurrentFile.text=從磁碟重新載入
action.TW.CloseAllTabs.description=關閉活動工具視窗頁籤組中的所有頁籤
action.TW.CloseAllTabs.text=關閉所有頁籤(_A)
action.TW.CloseOtherTabs.description=關閉工具視窗中除活動頁籤之外的所有開啟的頁籤
action.TW.CloseOtherTabs.text=關閉其他頁籤(_O)
action.TW.SplitAndMoveDown.description=將工具視窗區域拆分為兩個頁籤組，然後將當前頁籤移至底部組
action.TW.SplitAndMoveDown.text=拆分並下移
action.TW.SplitAndMoveRight.description=將工具視窗區域拆分為兩個頁籤組，然後將當前頁籤移至右側組
action.TW.SplitAndMoveRight.text=拆分並右移
action.TW.SplitDown.description=將工具視窗區域拆分為兩個頁籤組，並在底部組中建立當前頁籤的副本
action.TW.SplitDown.text=向下拆分
action.TW.SplitRight.description=將工具視窗區域拆分為兩個頁籤組，並在右側組中建立當前頁籤的副本
action.TW.SplitRight.text=向右拆分
action.TW.Unsplit.description=取消拆分工具視窗頁籤組
action.TW.Unsplit.text=取消拆分(_S)
action.TabList.description=在單行頁籤布局中顯示一個下拉選單，列出螢幕上無法完全顯示的頁籤
action.TabList.text=顯示隱藏的頁籤
action.Tabbed.WelcomeScreen.OpenProject.text=開啟
action.Table-scrollDownChangeSelection.description=將周圍的可滾動區域向下滾動一頁，然後選擇相應的行
action.Table-scrollDownChangeSelection.text=向下滾動頁面並選擇行
action.Table-scrollDownExtendSelection.description=將周圍的可滾動區域向下滾動一頁，然後將相應的行新增到選區
action.Table-scrollDownExtendSelection.text=向下滾動頁面並擴展選區
action.Table-scrollUpChangeSelection.description=將周圍的可滾動區域向上滾動一頁，然後選擇相應的行
action.Table-scrollUpChangeSelection.text=向上滾動頁面並選擇行
action.Table-scrollUpExtendSelection.description=將周圍的可滾動區域向上滾動一頁，然後將相應的行新增到選區
action.Table-scrollUpExtendSelection.text=向上滾動頁面並擴展選區
action.Table-selectFirstRow.description=選擇第一行
action.Table-selectFirstRow.text=選擇第一行
action.Table-selectFirstRowExtendSelection.description=滾動到第一行並將相應行新增到選區
action.Table-selectFirstRowExtendSelection.text=將選區擴展到第一行
action.Table-selectLastRow.description=選擇最後一行
action.Table-selectLastRow.text=選擇最後一行
action.Table-selectLastRowExtendSelection.description=滾動到最後一行並將相應行新增到選區
action.Table-selectLastRowExtendSelection.text=將選區擴展到最後一行
action.Table-selectNextColumn.description=選擇下一列
action.Table-selectNextColumn.text=選擇下一列
action.Table-selectNextColumnExtendSelection.description=將下一列新增到選區
action.Table-selectNextColumnExtendSelection.text=將選區擴展到下一列
action.Table-selectNextRow.description=選擇下一行
action.Table-selectNextRow.text=選擇下一行
action.Table-selectNextRowExtendSelection.description=將下一行新增到選區
action.Table-selectNextRowExtendSelection.text=將選區擴展到下一行
action.Table-selectPreviousColumn.description=選擇上一列
action.Table-selectPreviousColumn.text=選擇上一列
action.Table-selectPreviousColumnExtendSelection.description=將上一列新增到選區
action.Table-selectPreviousColumnExtendSelection.text=將選區擴展到上一列
action.Table-selectPreviousRow.description=選擇上一行
action.Table-selectPreviousRow.text=選擇上一行
action.Table-selectPreviousRowExtendSelection.description=將上一行新增到選區。
action.Table-selectPreviousRowExtendSelection.text=將選區擴展到上一行
action.Table-startEditing.text=編輯表單元
action.TechnicalSupport.description=在 JetBrains 網站上聯繫技術支援
action.TechnicalSupport.text=聯繫支援(_S)…
action.TerminalDecreaseFontSize.GoToAction.text=減小終端中的字體大小
action.TerminalDecreaseFontSize.text=減小字體大小
action.TerminalIncreaseFontSize.GoToAction.text=增加終端中的字體大小
action.TerminalIncreaseFontSize.text=增大字體大小
action.TerminalResetFontSize.GoToAction.text=重設終端中的字體大小
action.TerminalResetFontSize.text=重設字體大小
action.TestCoroutineProgress.text=測試協程進度
action.TestDndAction.text=測試 Dnd
action.TestGestureAction.text=測試手勢動作
action.TestIconMappings.text=測試圖示映射
action.TestMessageBoxAction.text=顯示測試對話框
action.TestParseEventsSchemeAction.text=測試解析事件方案…
action.TestProgressWindow.text=測試進度視窗
action.TestRubberDuckDebuggerAction.text=測試小黃鴨偵錯器
action.TestSearchContributors.text=SE 貢獻者測試
action.TestTextFieldAction.text=測試文本欄位
action.TestTooltipsAction.text=測試工具提示
action.TextComponent.ClearAction.description=清除文本組件中的文本
action.TextComponent.ClearAction.text=清除文本
action.TextEditorWithPreview.SplitHorizontally.text=水平布局
action.TextEditorWithPreview.SplitVertically.text=垂直布局
action.TextGrayFilterConfig.text=文本灰色篩選器(&T)
action.TextSearchAction.description=在“隨處搜尋”中顯示文本符合項
action.TextSearchAction.text=文本…
action.ToggleBookmark.text=切換書籤(_B)
action.ToggleBookmarkWithMnemonic.text=切換書籤助記符…
action.ToggleBreakpointEnabled.description=啟用/停用當前行的中斷點
action.ToggleBreakpointEnabled.text=切換中斷點啟用狀態(_B)
action.ToggleCompactMode.text=緊湊模式
action.ToggleCompletionHintsAction.text=補全時顯示參數名稱提示
action.ToggleContentUiTypeMode.description=切換內容的標籤式/組合式顯示
action.ToggleContentUiTypeMode.text=頁籤分組
action.ToggleDistractionFreeMode.description=切換免打擾模式
action.ToggleDistractionFreeMode.enter=進入免打擾模式
action.ToggleDistractionFreeMode.exit=離開免打擾模式
action.ToggleDistractionFreeMode.text=切換免打擾模式
action.ToggleDockMode.description=停靠/取消停靠活動工具視窗
action.ToggleDockMode.text=停靠模式(_E)
action.ToggleEssentialHighlighting.description=基本醒目提示模式只保留一組有限的程式碼醒目提示工具。包括檢查在內的所有醒目提示工具都將在執行檔案儲存動作時執行
action.ToggleEssentialHighlighting.text=基本醒目提示顯示
action.ToggleFieldBreakpoint.MainMenu.text=欄位觀察點
action.ToggleFieldBreakpoint.description=為文字游標處的欄位切換欄位觀察點
action.ToggleFieldBreakpoint.text=切換欄位觀察點(_F)
action.ToggleFileBasedIndexes.text=切換基於檔案的索引
action.ToggleFindInSelection.text=僅在選區內搜尋
action.ToggleFloatingMode.description=浮動/取消浮動活動工具視窗
action.ToggleFloatingMode.text=浮動模式(_M)
action.ToggleFocusMode.text=僅醒目提示當前宣告
action.ToggleFullScreen.description=切換全螢幕模式
action.ToggleFullScreen.text=切換全螢幕模式
action.ToggleFullScreen.text.enter=進入全螢幕
action.ToggleFullScreen.text.exit=離開全螢幕
action.ToggleIncompleteMode.text=進入不完全相依關係模式
action.ToggleInlineHintsAction.description=切換參數名稱提示
action.ToggleInlineHintsAction.text=切換參數名稱提示
action.ToggleLineBreakpoint.MainMenu.text=行中斷點(_L)
action.ToggleLineBreakpoint.description=切換文字游標處的行中斷點
action.ToggleLineBreakpoint.text=切換行中斷點(_L)
action.ToggleMethodBreakpoint.MainMenu.text=方法中斷點(_M)
action.ToggleMethodBreakpoint.description=為文字游標處的方法切換方法中斷點
action.ToggleMethodBreakpoint.text=切換方法中斷點(_M)
action.TogglePinnedMode.description=固定/取消固定活動工具視窗
action.TogglePinnedMode.text=固定模式(_P)
action.TogglePopupHints.text=切換當前檔案的彈出視窗提示
action.TogglePowerSave.description=省電模式將停用背景程式碼分析和其他背景動作
action.TogglePowerSave.text=省電模式
action.TogglePresentationAssistantAction.text=Presentation Assistant
action.TogglePresentationMode.description=切換示範模式
action.TogglePresentationMode.enter=進入示範模式
action.TogglePresentationMode.exit=離開示範模式
action.TogglePresentationMode.text=切換示範模式
action.TogglePresentationMode.text.enter=進入示範模式
action.TogglePresentationMode.text.exit=離開示範模式
action.ToggleReadOnlyAttribute.description=切換當前檔案的唯讀特性
action.ToggleReadOnlyAttribute.dirs=使{3,choice,1\\#目錄|2\\#目錄}{0,choice,0\\#唯讀|1\\#可寫}
action.ToggleReadOnlyAttribute.files=將{2,choice,1\\#檔案|2\\#檔案}設為{0,choice,0\\#唯讀|1\\#可寫}
action.ToggleReadOnlyAttribute.mixed=使檔案/目錄{0,choice,0\\#唯讀|1\\#可寫}
action.ToggleReadOnlyAttribute.synonym=將檔案設為可寫
action.ToggleReadOnlyAttribute.synonym2=將檔案設為唯讀
action.ToggleReadOnlyAttribute.text=切換唯讀特性
action.ToggleRenderedDocPresentation.description=在檢視原始碼和文檔註釋的渲染表示之間切換
action.ToggleRenderedDocPresentation.text=切換呈現檢視
action.ToggleRenderedDocPresentationForAll.description=切換到所有文檔註釋的呈現檢視
action.ToggleRenderedDocPresentationForAll.text=呈現所有文檔註釋
action.ToggleScrollToResultsDuringTypingAction.text=輸入時滾動至結果
action.ToggleSideMode.description=開啟/關閉工具視窗拆分模式
action.ToggleSideMode.text=拆分模式
action.ToggleTemporaryLineBreakpoint.MainMenu.text=臨時行中斷點
action.ToggleTemporaryLineBreakpoint.description=切換文字游標處的臨時行中斷點
action.ToggleTemporaryLineBreakpoint.text=切換臨時行中斷點
action.ToggleThreeSideInBlankDiffWindow.text=切換三向檢視器
action.ToggleThreeSideInBlankDiffWindow.text.disable=切換到兩向檢視器
action.ToggleThreeSideInBlankDiffWindow.text.enable=切換到三向檢視器
action.ToggleUnusedState.description=指示 IDE 未使用或已使用
action.ToggleUnusedState.text=指示 IDE 未使用
action.ToggleWindowedMode.description=視窗化/取消視窗化活動工具視窗
action.ToggleWindowedMode.text=視窗化模式(_W)
action.ToggleZenMode.description=同時切換免打擾和全螢幕模式
action.ToggleZenMode.enter=進入 Zen 模式
action.ToggleZenMode.exit=離開 Zen 模式
action.ToggleZenMode.text=切換 Zen 模式
action.ToolWindowShowNamesAction.text=顯示工具視窗名稱
action.ToolbarDemo.text=工具列示範
action.TopStripeEnableAction.text=使用單個工具視窗列
action.TopStripePinButton.text=固定
action.TopStripeUnPinButton.text=取消固定
action.TransferSettingsDemoAction.text=測試傳輸設定
action.Tree-scrollDownChangeSelection.description=將周圍的可滾動區域向下滾動一頁，然後選擇相應的節點
action.Tree-scrollDownChangeSelection.text=向下滾動頁面並選擇節點
action.Tree-scrollDownExtendSelection.description=將周圍的可滾動區域向下滾動一頁，然後將相應的節點新增到選區
action.Tree-scrollDownExtendSelection.text=向下滾動頁面並擴展選區
action.Tree-scrollUpChangeSelection.description=將周圍的可滾動區域向上滾動一頁，然後選擇相應的節點
action.Tree-scrollUpChangeSelection.text=向上滾動頁面並選擇節點
action.Tree-scrollUpExtendSelection.description=將周圍的可滾動區域向上滾動一頁，然後將相應的節點新增到選區
action.Tree-scrollUpExtendSelection.text=向上滾動頁面並擴展選區
action.Tree-selectAll.description=選擇所有節點
action.Tree-selectAll.text=選擇所有節點
action.Tree-selectChild.description=展開摺疊的節點或選擇子節點
action.Tree-selectChild.text=選擇子節點
action.Tree-selectChildExtendSelection.description=展開摺疊的節點或將子節點新增到選區
action.Tree-selectChildExtendSelection.text=將選區擴展到子節點
action.Tree-selectFirst.description=選擇第一個節點
action.Tree-selectFirst.text=選擇第一個節點
action.Tree-selectFirstExtendSelection.description=滾動到第一個節點並將相應節點新增到選區
action.Tree-selectFirstExtendSelection.text=將選區擴展到第一個節點
action.Tree-selectLast.description=選擇最後一個節點
action.Tree-selectLast.text=選擇最後一個節點
action.Tree-selectLastExtendSelection.description=滾動到最後一個節點並將相應節點新增到選區
action.Tree-selectLastExtendSelection.text=將選區擴展到最後一個節點
action.Tree-selectNext.description=選擇下一個節點
action.Tree-selectNext.text=選擇下一個節點
action.Tree-selectNextExtendSelection.description=將下一個節點新增到選區。
action.Tree-selectNextExtendSelection.text=將選區擴展到下一個節點
action.Tree-selectNextSibling.description=選擇下一個同級節點。
action.Tree-selectNextSibling.text=選擇下一個同級節點
action.Tree-selectParent.description=摺疊展開的節點或選擇父節點。
action.Tree-selectParent.text=選擇父節點
action.Tree-selectParentExtendSelection.description=滾動到父節點並將相應節點新增到選區
action.Tree-selectParentExtendSelection.text=將選區擴展到父節點
action.Tree-selectParentNoCollapse.description=選擇父節點而不摺疊展開的節點
action.Tree-selectParentNoCollapse.text=選擇父節點
action.Tree-selectPrevious.description=選擇上一個節點
action.Tree-selectPrevious.text=選擇上一個節點
action.Tree-selectPreviousExtendSelection.description=將上一個節點新增到選區
action.Tree-selectPreviousExtendSelection.text=將選區擴展到上一個節點
action.Tree-selectPreviousSibling.description=選擇上一個同級節點。
action.Tree-selectPreviousSibling.text=選擇上一個同級節點
action.Tree-startEditing.text=編輯樹節點
action.TreeExpandAll.text=展開樹
action.TreeViewModelDemo.text=樹檢視模型示範
action.TrialStateWidget.text=試用狀態
action.TriggerLowMemoryNotification.text=觸發低記憶體通知
action.TriggerProjectIndexableFilesFilterHealthCheckAction.text=觸發專案可索引檔案篩選器執行狀況檢查
action.TrustProject.text=信任
action.TurnOnOffCachedValueProfilerAction.text=開啟快取值分析器
action.TurnRefsToSuper.description=將類別的用法更改為其超類別或接口的用法
action.TurnRefsToSuper.text=盡可能使用接口(_W)…
action.TypeHierarchy.Class.text=類別層次結構
action.TypeHierarchy.Subtypes.text=子類型層次結構
action.TypeHierarchy.Supertypes.text=父類型層次結構
action.TypeHierarchy.description=瀏覽所選類別的層次結構
action.TypeHierarchy.text=類型層次結構(_H)
action.TypeHierarchyBase.BaseOnThisType.text=基於此類型
action.TypingLatencyReport.text=輸入延遲報告
action.UIDefaults.text=LaF 預設設定
action.UISandboxAction.text=UI 沙盒
action.UiDebugger.text=UI 偵錯器…
action.UiDslShowcaseAction.text=UI DSL 展示
action.UiInspector.text=UI 檢查器(&I)
action.UiThemeColorPickerAction.text=啟用 UI 主題顏色選擇器
action.UndoDumpAction.text=傾印撤消
action.UndockMode.description=使工具視窗滑動並在焦點丟失時自動隱藏
action.UndockMode.text=取消停靠(_D)
action.UnixInfoTest.text=顯示 Unix 資訊
action.UnmarkRoot.text=取消標記
action.Unscramble.EditorPopup.text=堆疊追蹤或執行緒傾印(_S)…
action.Unscramble.description=開啟包含可導覽堆疊追蹤或執行緒傾印的主控台
action.Unscramble.text=分析堆疊追蹤或執行緒傾印(_S)…
action.UnselectPreviousOccurrence.description=從選區中移除單詞的當前符合項。
action.UnselectPreviousOccurrence.text=取消選擇符合項
action.Unsplit.description=取消拆分視窗
action.Unsplit.text=取消拆分(_S)
action.UnsplitAll.description=移除所有拆分器
action.UnsplitAll.text=取消全部拆分(_N)
action.UntrustProject.text=不信任
action.Unwrap.description=安全地解包或移除所選作用域
action.Unwrap.text=解包/移除(_W)…
action.UpdateFiles.text=更新(_U)
action.UpdateRunningApplication.text=更新正在執行的應用程式
action.UsageView.Exclude.description=將此用法從處理中排除
action.UsageView.Exclude.text=排除
action.UsageView.Include.description=將此用法包含到處理中
action.UsageView.Include.text=包含
action.UsageView.Remove.description=將此用法從處理中移除
action.UsageView.Remove.text=移除
action.UsageView.Rerun.description=重新執行搜尋
action.UsageView.Rerun.text=重新執行
action.UsageView.ShowRecentFindUsages.description=選擇並重新執行最近的尋找用法
action.UsageView.ShowRecentFindUsages.text=最近的尋找用法(_E)
action.UsedIconsListing.text=列出使用的圖示
action.UserInvokedFullAnalysis.text=建立並立即分析堆傾印
action.ValidateXml.description=驗證當前的 XML 檔案
action.ValidateXml.text=驗證(_V)
action.ValidationTest.text=驗證對話框測試
action.Vcs.ApplySelectedChanges.text=優選所選更改
action.Vcs.CombinedDiff.CaretToNextBlock.text=下一個檔案
action.Vcs.CombinedDiff.CaretToPrevBlock.text=上一個檔案
action.Vcs.CombinedDiff.ToggleCollapseAllBlock.description=切換摺疊組合差異中的所有檔案
action.Vcs.CombinedDiff.ToggleCollapseAllBlock.text=摺疊所有檔案
action.Vcs.CombinedDiff.ToggleCollapseBlock.text=摺疊檔案
action.Vcs.CopyCommitSubjectAction.description=將所選提交的主題複製到剪貼簿
action.Vcs.CopyCommitSubjectAction.text=複製提交主題
action.Vcs.CopyCurrentBranchName.description=將當前分支名稱複製到剪貼簿
action.Vcs.CopyCurrentBranchName.text=複製分支名稱
action.Vcs.CopyRevisionNumberAction.description=將選定提交的修訂號複製到剪貼簿
action.Vcs.CopyRevisionNumberAction.text=複製修訂號
action.Vcs.Diff.EnableDisableCombinedDiff.text=在單個差異檢視中顯示所有檔案
action.Vcs.Diff.ExcludeChangedLinesFromCommit.template.text={0,choice,0\\#|1\\#拆分區塊並|2\\#拆分區塊並}從提交中排除{1,choice,0\\#當前行|2\\#所選行}
action.Vcs.Diff.ExcludeChangedLinesFromCommit.text=拆分區塊並從提交中排除所選行
action.Vcs.Diff.IncludeChangedLinesIntoCommit.template.text={0,choice,0\\#|1\\#拆分區塊並|2\\#拆分區塊並}將{1,choice,0\\#當前行|2\\#所選行}包含到提交中
action.Vcs.Diff.IncludeChangedLinesIntoCommit.text=拆分區塊並將所選行包含到提交中
action.Vcs.Diff.IncludeWholeChangedLinesIntoCommit.text=將行包含到提交中
action.Vcs.Diff.ResolveConflictsInImports.text=解決 import 語句中的衝突
action.Vcs.Diff.ShowCombinedDiff.description=在一處顯示全部所選更改的差異
action.Vcs.Diff.ShowCombinedDiff.text=顯示組合差異
action.Vcs.Diff.ShowDiffInEditorTab.text=在編輯器頁籤中顯示差異
action.Vcs.Diff.ShowDiffInNewWindow.text=在單獨的視窗中顯示差異
action.Vcs.Diff.ToggleDiffAligningMode.description=啟用雙面差異的更改對齊
action.Vcs.Diff.ToggleDiffAligningMode.popup@DiffToolbar.text=對齊更改醒目提示
action.Vcs.Diff.ToggleDiffAligningMode.text=在並排差異中對齊更改
action.Vcs.Diff.ToggleSearchInChanges.text=在更改中搜尋
action.Vcs.EditSource.text=編輯源
action.Vcs.GetVersion.description=從儲存庫獲取版本
action.Vcs.GetVersion.text=獲取
action.Vcs.IntegrateProject.description=整合專案
action.Vcs.IntegrateProject.text=整合專案(_G)
action.Vcs.MoveChangedLinesToChangelist.description=將所選行中的更改移至另一個更改列表…
action.Vcs.MoveChangedLinesToChangelist.text=將行移至另一個變更列表…
action.Vcs.Operations.Popup.Annotate.text=註解行動作
action.Vcs.Push.Force.text=強制推送(_F)
action.Vcs.Push.text=推送…
action.Vcs.QuickListPopupAction.description=包含常用 VCS 動作列表的上下文感知彈出視窗
action.Vcs.QuickListPopupAction.text=VCS 動作彈出視窗…
action.Vcs.RevertSelectedChanges.text=還原所選更改
action.Vcs.RollbackChangedLines.description=回滾所選行中的更改
action.Vcs.RollbackChangedLines.text=回滾行
action.Vcs.RunCommitChecks.text=執行提交檢查
action.Vcs.Show.Local.Changes.text=顯示本地更改
action.Vcs.Show.Shelf.text=顯示 Shelf
action.Vcs.ShowConsoleTab.text=在 VCS 主控台頁籤中顯示
action.Vcs.ShowDiffChangedLines.description=顯示所選行的差異
action.Vcs.ShowDiffChangedLines.text=顯示行的差異
action.Vcs.ShowDiffWithLocal.Before.description=將之前的所選修訂中的版本與當前版本進行比較
action.Vcs.ShowDiffWithLocal.Before.text=將之前版本與本地版本進行比較
action.Vcs.ShowDiffWithLocal.description=將所選修訂中的版本與當前版本進行比較
action.Vcs.ShowDiffWithLocal.text=與本地比較
action.Vcs.ShowHistoryForBlock.description=顯示編輯器選擇的歷史記錄
action.Vcs.ShowHistoryForBlock.text=顯示選區的歷史記錄(_F)…
action.Vcs.ShowHistoryForRevision.description=顯示檔案的歷史記錄，直到所選修訂
action.Vcs.ShowHistoryForRevision.text=迄今為止的歷史記錄
action.Vcs.ShowMessageHistory.description=顯示提交訊息歷史記錄
action.Vcs.ShowMessageHistory.text=提交訊息歷史記錄
action.Vcs.ShowTabbedFileHistory.description=顯示檔案歷史
action.Vcs.ShowTabbedFileHistory.for.file.text=顯示 {0} 的歷史記錄(_H)
action.Vcs.ShowTabbedFileHistory.text=顯示歷史記錄(_H)
action.Vcs.ToggleAmendCommitMode.description=修改當前分支的最新提交
action.Vcs.ToggleAmendCommitMode.text=修正提交
action.Vcs.Toolbar.ShowMoreActions.description=VCS 動作
action.Vcs.Toolbar.ShowMoreActions.text=版本控制
action.Vcs.UpdateProject.text=更新專案(_U)
action.Vcs.VcsClone.text=從版本控制中獲取…
action.Vcs.VcsClone.text.synonym1=簽出
action.Vcs.VcsClone.text.synonym2=克隆
action.VcsHistory.ShowAllAffected.description=顯示選中修訂中所做的所有更改
action.VcsHistory.ShowAllAffected.text=顯示所有受影響的檔案
action.VcsShowCurrentChangeMarker.description=顯示當前所選更改的彈出視窗
action.VcsShowCurrentChangeMarker.text=文字游標下的更改(_H)
action.VcsShowNextChangeMarker.description=轉到下一個更改
action.VcsShowNextChangeMarker.text=下一個更改(_H)
action.VcsShowPrevChangeMarker.description=轉到上一個更改
action.VcsShowPrevChangeMarker.text=上一個更改(_A)
action.VcsToolbarLabelAction.text=VCS 標籤
action.ViewBreakpoints.description=檢視和管理所有中斷點和觀察點
action.ViewBreakpoints.text=檢視中斷點(_K)…
action.ViewImportPopups.description=在當前檔案中切換顯示匯入彈出視窗
action.ViewImportPopups.text=顯示 import 彈出視窗
action.ViewInplaceComments.description=在樹檢視中顯示/隱藏額外資訊
action.ViewInplaceComments.text=檔案詳細資訊
action.ViewMainMenu.description=顯示/隱藏主選單
action.ViewMainMenu.text=主選單
action.ViewMembersInNavigationBar.NavBar.text=在導覽列中顯示成員
action.ViewMembersInNavigationBar.description=在導覽列中顯示/隱藏宣告
action.ViewMembersInNavigationBar.text=導覽列中的成員
action.ViewNavigationBar.NavBar.text=顯示導覽列
action.ViewNavigationBar.description=顯示/隱藏導覽列
action.ViewNavigationBar.text=導覽列(_V)
action.ViewNewToolbarAction.text=工具列
action.ViewObsoleteNavBarAction.text=導覽列
action.ViewObsoleteToolbarAction.text=工具列經典
action.ViewOfflineInspection.description=載入離線檢查結果
action.ViewOfflineInspection.text=檢視離線檢查結果(_O)…
action.ViewSource.description=開啟所選條目的編輯器
action.ViewSource.text=顯示源(_W)
action.ViewStatusBar.description=顯示/隱藏狀態列
action.ViewStatusBar.text=狀態列(_S)
action.ViewToolBar.description=顯示/隱藏主工具列
action.ViewToolBar.text=工具列(_T)
action.ViewToolButtons.description=顯示/隱藏工具視窗按鈕
action.ViewToolButtons.text=工具視窗
action.VirtualFileInfo.text=虛擬檔案資訊
action.WebBrowser.text=顯示 Web 瀏覽器(&W)
action.WelcomeScreen.ChangeProjectIcon.text=設定自訂專案圖示…
action.WelcomeScreen.Configure.Export.text=匯出設定
action.WelcomeScreen.Configure.Import.text=匯入設定…
action.WelcomeScreen.CopyProjectPath.text=複製路徑
action.WelcomeScreen.CreateDirectoryProject.description=建立一個新項目。
action.WelcomeScreen.CreateDirectoryProject.text=新增專案
action.WelcomeScreen.CreateNewProject.description=啟動“新項目”嚮導，它將引導您建立一個新項目。
action.WelcomeScreen.CreateNewProject.text=新增專案
action.WelcomeScreen.DefaultNewProjectAction.text=新增專案
action.WelcomeScreen.DevelopPlugins.description=開始開發延伸模組。
action.WelcomeScreen.DevelopPlugins.text=延伸模組開發
action.WelcomeScreen.EditGroup.text=編輯…
action.WelcomeScreen.ManageLicense.text=管理授權…
action.WelcomeScreen.NewGroup.text=新增專案組
action.WelcomeScreen.OpenDirectoryProject.description=開始在指定的檔案或目錄中編輯程式碼。
action.WelcomeScreen.OpenDirectoryProject.text=開啟
action.WelcomeScreen.OpenProject.description=開啟檔案或專案。您也可以通過拖放到歡迎頁面來開啟專案或編輯檔案。
action.WelcomeScreen.OpenProject.text=開啟或匯入
action.WelcomeScreen.OpenSelected.text=開啟選定項
action.WelcomeScreen.Plugins.Extensions.text=擴展
action.WelcomeScreen.Plugins.description=管理已安裝的延伸模組，以及從儲存庫下載新延伸模組
action.WelcomeScreen.Plugins.text=延伸模組
action.WelcomeScreen.RemoveSelected.text=從最近的專案中移除…
action.WhatsNewAction.description=了解此版本 IDE 中的新功能
action.WhatsNewAction.text=最新變化(_N)
action.WindowMode.description=將工具視窗移至單獨的框架
action.WindowMode.text=視窗(_W)
action.WriteActionUnderProgress.text=正在測試寫入動作
action.XDebugger.CompareValueWithClipboard.description=將所選節點的值與剪貼簿文本進行比較
action.XDebugger.CompareValueWithClipboard.text=與剪貼簿比較值
action.XDebugger.CopyName.description=將所選節點的名稱複製到剪貼簿
action.XDebugger.CopyName.text=複製名稱
action.XDebugger.CopyValue.description=將所選節點的值複製到剪貼簿
action.XDebugger.CopyValue.text=複製值
action.XDebugger.CopyWatch.text=複製監視
action.XDebugger.DisableAllButThisBreakpoint.description=停用所有中斷點，僅保留文字游標所在行的中斷點
action.XDebugger.DisableAllButThisBreakpoint.text=停用其他中斷點
action.XDebugger.EditWatch.text=編輯…
action.XDebugger.Inline.description=在編輯器中顯示可用的偵錯器會話值
action.XDebugger.Inline.text=在編輯器中顯示變量值
action.XDebugger.Inspect.text=檢查…
action.XDebugger.JumpToSource.description=開啟所選條目的源
action.XDebugger.JumpToSource.text=跳轉到源
action.XDebugger.JumpToTypeSource.description=開啟所選值類型的源
action.XDebugger.JumpToTypeSource.text=跳轉到類型源
action.XDebugger.MoveWatchDown.text=下移監視
action.XDebugger.MoveWatchUp.text=上移監視
action.XDebugger.MuteBreakpoints.text=忽略中斷點
action.XDebugger.NewWatch.text=新增監視…
action.XDebugger.PauseWatch.text=暫停監視
action.XDebugger.PinToTop.text=固定至頂部
action.XDebugger.PreviewTab.text=在預覽頁籤中開啟檔案
action.XDebugger.RemoveAllButThisBreakpoint.description=移除所有中斷點，僅保留文字游標所在行的中斷點
action.XDebugger.RemoveAllButThisBreakpoint.text=移除其他中斷點
action.XDebugger.RemoveAllWatches.text=移除所有監視
action.XDebugger.RemoveWatch.text=移除監視
action.XDebugger.SeparateWatches.text=單獨的監視
action.XDebugger.SetValue.description=修改所選節點的值
action.XDebugger.SetValue.text=設定值…
action.XDebugger.Show.Breakpoints.Over.Line.Numbers.text=在行號上顯示中斷點
action.XDebugger.ToggleEvaluateExpressionField.text=顯示“對表達式求值”欄位
action.XDebugger.ToggleSortValues.description=在偵錯器檢視中按字母順序排列值
action.XDebugger.ToggleSortValues.text=按字母順序對變數進行排序
action.XDebugger.UnmuteOnStop.text=在會話完成時取消忽略中斷點
action.XSD2Document.text=從 XML 檔案生成 XSD 架構…
action.XcodeBuildSwiftDocumentationAction.description=為所有目標建置文檔
action.XcodeBuildSwiftDocumentationAction.text=建置文檔
action.XcodePreviewSwiftDocumentationAction.description=為所有目標建置並預覽文檔
action.XcodePreviewSwiftDocumentationAction.text=預覽文檔
action.ZoomCurrentWindow.description=縮放當前視窗
action.ZoomCurrentWindow.text=縮放
action.ZoomInIdeAction.text=放大 IDE
action.ZoomOutIdeAction.text=縮小 IDE
action.compare.archives.text=比較歸檔
action.compare.files.text=比較檔案
action.compare.text=比較
action.compare.with.text=比較物件…
action.editRunConfigurations.description=開啟“編輯執行/偵錯組態”對話框
action.editRunConfigurations.text=編輯組態(_R)…
action.fontEditorPreview.ToggleBoldFont.text=切換加粗的字體
action.main.toolbar.Filename.text=檔名小工具(當編輯器頁籤被隱藏或啟用了“始終顯示完整路徑”選項時)
action.main.toolbar.Project.text=專案小工具
action.multilaunch.AddExecutableAction.text=新增組態或任務
action.multilaunch.CancelExecutableAction.text=取消
action.multilaunch.DebugMultiLaunchAction.text=偵錯
action.multilaunch.DeleteExecutableAction.text=刪除
action.multilaunch.EditExecutableAction.text=編輯…
action.multilaunch.RunMultiLaunchAction.text=執行
action.multilaunch.StopMultiLaunchAction.text=停止
action.openAssertEqualsDiff.text=檢視 assertEquals 差異
action.performancePlugin.ShowMemoryDialogAction.description=顯示更改記憶體對話框
action.performancePlugin.ShowMemoryDialogAction.text=更改記憶體設定
action.plugins.autoupdate.repository.view.text=檢視延伸模組自動更新儲存庫
action.redo.description=重做{0}
action.redo.description.empty=最後的撤消動作
action.redo.text=重做{0}(_R)
action.separator=分隔符
action.synonym.Vcs.ShowHistoryForBlock.class.text=顯示類別的歷史記錄…
action.synonym.Vcs.ShowHistoryForBlock.method.text=顯示方法的歷史記錄…
action.undo.description=撤消{0}
action.undo.description.empty=最後動作
action.undo.text=撤消{0}(_U)
apply.toolbar.customization=套用
group.$LRU.GoToAction.text=開啟最近的專案
group.$LRU.description=最近開啟專案的列表
group.$LRU.text=最近的專案(_R)
group.ActiveToolwindowGroup.text=活動工具視窗
group.AnalyzeActionsPopup.text=分析程式碼
group.AnalyzeJavaMenu.description=分析 Java 選單
group.AnalyzeJavaMenu.text=分析 Java 選單
group.AnalyzeMenu.text=分析(_Z)
group.ArrangementRulesGroup.text=排列規則
group.BackgroundTasks.text=背景任務
group.Bookmarks.Goto.text=按數字/助記鍵轉到
group.Bookmarks.Toggle.text=按數字/助記鍵切換
group.Bookmarks.text=書籤
group.BreakpointActionsGroup.text=切換中斷點
group.BuildArtifactsGroup.text=建置工件
group.BuildMenu.text=建置(_B)
group.CacheRecovery.text=快取恢復
group.ChangeLineSeparators.text=行分隔符
group.ChangeMainMenuModeActionGroup.text=主選單
group.ChangeProjectColorActionGroup.text=更改專案顏色
group.ChangesView.Changelists.text=更改列表
group.ChangesView.GroupBy.text=分組依據
group.CleanupEventLog.description=移除所有未發送事件日誌檔案
group.CleanupEventLog.text=清理 事件日誌
group.CloseEditorsGroup.text=編輯器關閉動作
group.CodeCompletionGroup.text=程式碼補全(_C)
group.CodeEditorBaseGroup.text=程式碼編輯器檢視動作
group.CodeEditorViewGroup.text=程式碼檢視動作
group.CodeFormatGroup.text=程式碼格式設定動作
group.CodeMenu.text=程式碼(_C)
group.CommentGroup.text=註釋動作
group.CommitView.ShowOnDoubleClick.text=雙擊時顯示
group.ConvertIndentsGroup.text=轉換縮排
group.Copy.Paste.Special.description=複製/貼上特殊編輯器動作
group.Copy.Paste.Special.text=複製/貼上特殊
group.CopyReferencePopupGroup.text=複製路徑/參照…
group.CoverageMenu.text=程式碼覆蓋率動作
group.CreateRunConfiguration.description=根據當前上下文建立執行組態
group.CreateRunConfiguration.text=建立執行組態
group.CustomLayoutActionsGroup.text=工具視窗布局
group.CustomLayoutsGroup.text=工具視窗布局列表
group.CustomizeMainToolbarGroup.text=自訂主工具列
group.CutCopyPasteGroup.text=剪下/複製/貼上動作
group.DebugMainMenu.text=偵錯器動作
group.DebugToolbarQuickActions.text=新增到偵錯器工具列
group.Debugger.ViewAsGroup.text=檢視方式
group.DebuggingActionsGroup.text=偵錯動作
group.Diff.Binary.Settings.text=設定
group.Diff.KeymapGroup.text=差異與合併
group.Documentation.Navigation.text=快速文檔導覽
group.EditBookmarksGroup.text=書籤(_K)
group.EditCreateDeleteGroup.text=編輯器建立/刪除動作
group.EditMenu.text=編輯(_E)
group.EditSelectGroup.text=編輯器選擇動作
group.EditSelectWordGroup.text=選擇單詞動作
group.EditSmartGroup.text=編輯程式碼動作
group.EditorActions.text=編輯器動作
group.EditorBidiTextDirection.description=混合 LTR/RTL 文本的主要方向
group.EditorBidiTextDirection.text=雙向文本基礎方向
group.EditorBreadcrumbsSettings.description=切換路徑導覽列設定
group.EditorBreadcrumbsSettings.text=路徑導覽
group.EditorGutterPopupMenu.Appearance.text=外觀
group.EditorGutterPopupMenu.text=編輯器裝訂區域彈出選單
group.EditorLangPopupMenu.text=編輯器彈出視窗選單動作(2)
group.EditorPopupMenu.GoTo.description=轉到編輯器彈出視窗選單組
group.EditorPopupMenu.GoTo.text=轉到
group.EditorPopupMenu.Run.text=編譯/執行動作
group.EditorPopupMenu.description=編輯器彈出視窗選單
group.EditorPopupMenu.text=編輯器彈出視窗選單
group.EditorPopupMenu1.text=編輯器彈出視窗選單動作(1)
group.EditorPopupMenuDebug.text=偵錯動作
group.EditorStickyLinesSettings.description=切換粘性行面板設定
group.EditorStickyLinesSettings.text=粘性行
group.EditorTabPopupMenu.text=編輯器頁籤彈出視窗選單
group.EditorTabPopupMenuEx.text=編輯器頁籤彈出視窗選單動作(1)
group.EditorTabsEntryPoint.text=最近的檔案、頁籤動作等
group.EditorTabsGroup.text=編輯器頁籤(_T)
group.EditorToggleActions.text=活動編輯器
group.Emmet.text=Emmet
group.ExpandAllToLevel.text=全部展開到級別(_L)
group.ExpandToLevel.text=展開到級別(_E)
group.ExportImportGroup.text=管理 IDE 設定
group.ExternalSystem.ShowSettingsGroup.text=建置工具設定
group.ExternalToolsGroup.text=外部工具
group.FeatureUsage.Internal.text=功能用法統計資訊
group.FileChooserSettings.text=檔案選擇器設定
group.FileChooserToolbar.text=檔案選擇器工具列
group.FileExportGroup.text=匯出
group.FileHistory.KeymapGroup.text=檔案歷史記錄
group.FileMainSettingsGroup.text=設定動作
group.FileMenu.text=檔案(_F)
group.FileOpenGroup.text=檔案開啟動作
group.FileOtherSettingsGroup.text=新增專案設定
group.FilePropertiesGroup.text=檔案屬性
group.FileSettingsGroup.text=設定動作
group.FindMenuGroup.text=尋找(_F)
group.FindUsagesMenuGroup.text=尋找用法
group.Floating.CodeToolbar.Extract.text=提取
group.Floating.CodeToolbar.Surround.text=包圍
group.Floating.CodeToolbar.text=浮動程式碼工具列
group.FoldingGroup.text=折疊
group.GenerateGroup.text=生成(_G)
group.GoToChangeMarkerGroup.text=更改導覽動作
group.GoToCodeGroup.text=通過參照轉到
group.GoToErrorGroup.text=轉到錯誤/書籤動作
group.GoToMenu.text=導覽(_N)
group.GoToTargetEx.text=通過名稱轉到
group.Graph.AlignNodesGroup.text=對齊
group.Graph.AppearanceGroup.text=外觀
group.Graph.BehaviourGroup.text=行為
group.Graph.CommonLayoutGroup.text=布局
group.Graph.DistributeNodesGroup.text=分散排列
group.Graph.EdgeRealizerGroup.text=邊緣形狀
group.Graph.ExportGroup.text=匯出圖
group.Graph.LayoutOrientationGroup.text=方向
group.Graph.MergeEdgesGroup.text=合併邊緣
group.Graph.NeighborhoodViewPopup.AppearanceGroup.text=外觀
group.Graph.NeighborhoodViewPopup.LayoutGroup.text=布局
group.Graph.NetsLayoutGroup.text=網狀
group.Graph.OrthogonalLayoutGroup.text=正交
group.Graph.RadialLayoutGroup.text=徑向
group.Graph.TreeLayoutGroup.text=樹
group.Graphs.KeymapGroup.text=圖表
group.HelpDiagnosticTools.text=診斷工具
group.HelpMenu.text=幫助(_H)
group.HierarchyGroup.text=層次結構動作
group.ImportTests.text=匯入測試結果
group.InlineCompletion.Settings.text=內聯補全提供程序的設定
group.InlineCompletion.description=內聯補全
group.InlineCompletion.text=內聯補全
group.InspectCodeGroup.text=檢查程式碼動作
group.Internal.Dump.text=傾印
group.Internal.Editor.text=編輯器(&E)
group.Internal.Errors.text=異常
group.Internal.HeapAnalysis.text=堆分析
group.Internal.Java.text=Java
group.Internal.PMM.text=PMM 實用工具
group.Internal.Performance.text=性能
group.Internal.Trust.text=原始碼安全性
group.Internal.UI.Animation.text=動畫
group.Internal.UI.Demos.text=示範
group.Internal.UI.Focus.text=焦點
group.Internal.UI.Icons.text=圖示
group.Internal.UI.KotlinUiDsl.text=Kotlin UI DSL
group.Internal.UI.text=UI(&U)
group.Internal.VFS.text=VFS
group.Internal.WorkspaceModel.text=工作區模型
group.Internal.text=內部動作(&I)
group.Internal1.text=IDEA 內部動作
group.IntroduceActionsGroup.text=提取/引入(_X)
group.LayoutsGroup.MainMenu.text=布局(_L)
group.LayoutsGroup.text=工具視窗布局(_L)
group.LeftToolbarSideGroup.text=左側
group.ListActions.text=列表動作
group.LocalChangesView.ShowOnDoubleClick.text=雙擊時顯示
group.Macros.description=檢視、更改、錄製、執行巨集
group.Macros.text=巨集(_S)
group.MacrosGroup.text=巨集動作
group.MainMenu.text=主選單
group.MainToolBar.text=主工具列
group.MainToolbarCenter.text=中心
group.MainToolbarGeneralActionsGroup.text=一般動作
group.MainToolbarLeft.text=左側
group.MainToolbarQuickActions.text=將動作新增到主工具列
group.MainToolbarRight.text=右側
group.MaintenanceGroup.text=維護
group.MarkContentRootGroup.text=將目錄標記為內容根
group.MarkFileAs.text=將檔案標記為
group.MarkRootGroup.text=將目錄標記為
group.MigrationMenu.text=遷移軟體套件和類別
group.MoreActionGroup.text=更多
group.MoveModuleToGroup.description=移動模組(_M)
group.MoveModuleToGroup.text=將模組移至組
group.NavbarLocationGroup.description=選擇導覽列的位置
group.NavbarLocationGroup.text=導覽列
group.NavbarPopupMenu.text=導覽列
group.NavigateInFileGroup.text=在檔案中導覽
group.NewElement.text=新增(_N)
group.NewElementInMenuGroup.text=新增(_N)
group.NewElementMenu.text=新增(_N)
group.NewFromTemplate.text=從模板
group.NewGroup.text=新增(_N)
group.NewGroup1.text=新組(1)
group.NewMicroservices.text=微服務模板
group.NewWebDevelopment.text=Web 開發模板
group.NewXml.text=XML
group.NewXmlDescriptor.text=XML 組態檔案
group.Notifications.text=通知
group.OpenEventLogFileAction.description=在 IDE 中開啟有效事件日誌檔案
group.OpenEventLogFileAction.text=在編輯器中開啟事件日誌
group.OpenInBrowserEditorContextBarGroupAction.description=開啟位置…
group.OpenInBrowserEditorContextBarGroupAction.text=開啟位置…
group.OpenInBrowserGroup.RevealInPopup.text=瀏覽器
group.OpenProjectGroup.text=開啟專案動作
group.OpenProjectWindows.text=開啟專案視窗
group.OpenRecentEditorInBlankDiffWindow.text=切換到最近
group.OverrideFileTypeAction.bundledPlugin=捆綁
group.OverrideFileTypeAction.fromNamedPlugin=自 ''{0}'' 延伸模組
group.OverrideFileTypeAction.title=選擇檔案類型
group.PairFileActions.text=檔案對的動作
group.PasteGroup.text=貼上
group.Patch.MainMenu.text=補丁檔案
group.PopupMenuActions.text=彈出選單動作
group.PrintExportGroup.text=列印/匯出動作
group.ProblemsView.Options.description=允許對問題進行分類和篩選
group.ProblemsView.Options.text=檢視選項
group.ProblemsView.Show.text=顯示
group.ProblemsView.SortBy.text=排序依據
group.ProjectView.ToolWindow.Appearance.Actions.text=外觀
group.ProjectView.ToolWindow.Appearance.Show.text=顯示
group.ProjectView.ToolWindow.Behavior.Actions.text=行為
group.ProjectView.ToolWindow.SecondaryActions.text=專案檢視選項
group.ProjectView.ToolWindow.Sort.Actions.text=排序依據
group.ProjectViewAnalysisGroup.text=分析動作
group.ProjectViewCompileGroup.text=編譯/偵錯動作
group.ProjectViewPopupMenu.text=專案檢視彈出視窗選單
group.ProjectViewPopupMenuModifyGroup.text=專案檢視彈出視窗選單修改組
group.ProjectViewPopupMenuRefactoringGroup.text=專案檢視彈出視窗重構組
group.ProjectViewPopupMenuRunGroup.text=專案檢視彈出視窗選單執行組
group.ProjectViewPopupMenuSettingsGroup.text=專案檢視彈出視窗選單設定組
group.RefactoringMenu.text=重構(_R)
group.RefactoringMenu1.text=重構動作(1)
group.RefactoringMenu2.text=重構動作(2)
group.RegistrationActions.text=註冊動作
group.ResizeToolWindowGroup.text=調整大小
group.RevealGroup.text=開啟於
group.RightToolbarSideGroup.text=右側
group.RunContextGroupMore.text=更多執行/偵錯
group.RunContextPopupGroup.text=執行組態
group.RunDashboard.ViewOptions.text=執行組態
group.RunMenu.text=執行(_U)
group.Runner.Layout.description=布局組態
group.Runner.Layout.text=布局
group.RunnerActions.text=執行/偵錯
group.RunnerActionsTouchbar.text=Touch Bar 執行/偵錯動作
group.ScrollPaneActions.text=滾動
group.SearchEverywhereActions.text=隨處搜尋
group.ServiceView.AddService.text=新增服務
group.ServiceView.OpenInNewTabGroup.text=在新頁籤中開啟
group.ServiceView.ViewOptions.text=檢視選項
group.SettingsEntryPoint.text=IDE 和專案設定
group.Shelve.KeymapGroup.text=擱置
group.ShelvedChangesToolbar.ViewOptions.text=檢視選項
group.ShowAnnotateOperationsPopupGroup.text=註解行
group.ShowFilterPopup.text=顯示篩選器彈出視窗
group.ShowRecentFindUsagesGroup.description=選擇並重新執行最近的尋找用法
group.ShowRecentFindUsagesGroup.text=最近的尋找用法
group.SplitChooser.Actions.text=使用選擇器導覽拆分
group.StandardMacroActions.text=標準巨集動作
group.SwitcherAndRecentFiles.text=切換器(RecentFiles)動作
group.SwitcherAndRecentFilesFallback.text=切換器(RecentFiles)動作
group.TW.ViewModeGroup.text=檢視模式
group.TWViewModes.text=工具視窗檢視模式
group.TWViewModesLegacy.text=工具視窗傳統檢視模式(已棄用)
group.TableActions.text=表動作
group.TabsActions.text=頁籤
group.TextEditorWithPreview.SplitGroup.text=拆分布局
group.TipsAndFeatures.text=提示和功能
group.TodoMainGroup.text=TODO
group.TodoViewGroupByGroup.text=分組依據
group.ToggleBreakpointAction.text=中斷點動作
group.ToolWindowsGroup.text=工具視窗(_T)
group.ToolbarFindGroup.text=工具列尋找動作
group.ToolbarMakeGroup.text=工具列 Make 動作
group.ToolbarRunGroup.text=工具列執行動作
group.ToolsBasicGroup.text=基本工具組
group.ToolsMenu.Services.text=服務
group.ToolsMenu.text=工具(_T)
group.ToolsXmlGroup.text=XML 動作
group.TopAnomalies.text=熱門異常
group.TopStripeActionGroup.text=單個工具視窗列
group.TouchBar.text=觸控列
group.TouchBarDebug.ForceStepButtons.text=偵錯器強制步動作
group.TouchBarDebug.StepButtons.text=偵錯器步動作
group.TouchBarDebug.text=偵錯器
group.TouchBarDebug_alt.text=使用 Alt 鍵的偵錯器
group.TouchBarDefault.text=預設
group.TouchBarDefaultOptionalGroup.text=可選動作
group.TouchBarDefault_alt.text=預設使用 Alt 鍵
group.TouchBarDefault_cmd.alt.text=預設使用 Alt+Cmd 鍵
group.TouchBarDefault_cmd.text=預設使用 Cmd 鍵
group.TouchBarDefault_ctrl.text=預設使用 Ctrl 鍵
group.TouchBarDefault_shift.text=預設使用 Shift 鍵
group.TreeActions.text=樹動作
group.UpdateEventsSchemeAction.description=如果必要，從伺服器更新主要事件方案。另外，從檔案重新載入測試事件方案。
group.UpdateEventsSchemeAction.text=更新事件方案
group.Vcs.Browse.text=瀏覽 VCS 儲存庫
group.Vcs.Import.text=匯入到版本控制
group.Vcs.KeymapGroup.text=版本控制系統
group.VcsFileGroupPopup.text=版本控制組
group.VcsGlobalGroup.text=VCS 組
group.VcsGroup.text=版本控制
group.VcsGroups.text=Git(_G)
group.VcsToolbarActions.text=VCS 動作
group.VersionControlsGroup.text=VCS/LVCS 動作
group.ViewAppearanceGroup.text=外觀(_A)
group.ViewMenu.text=檢視(_V)
group.ViewRecentActions.text=檢視最近的動作組
group.ViewStatusBarWidgetsGroup.description=顯示/隱藏狀態列小工具
group.ViewStatusBarWidgetsGroup.text=狀態列小工具(_W)
group.WeighingNewGroup.text=新增(_N)
group.WeighingNewGroup.text.popup=新增檔案(_N)…
group.WelcomeScreen.CreateDirectoryProject.description=建立一個新項目。
group.WelcomeScreen.CreateDirectoryProject.text=新增專案
group.WelcomeScreen.KeymapGroup.text=歡迎頁面
group.WelcomeScreen.MoveToGroup.text=移至組
group.WelcomeScreen.Options.text=選項選單
group.WindowMenu.text=視窗(_W)
group.XDebugger.Attach.Dialog.Settings.text=附加對話框設定
group.XDebugger.settings.text=偵錯器設定
group.XmlGenerateToolsGroup.text=XML 生成動作
group.compare.contents.text=比較內容
group.popup@ExpandableBookmarkContextMenu.text=書籤
group.reopen.mac.text=開啟最近(_R)
group.reopen.win.text=重新開啟專案(_R)
save.file.as.template=將檔案另存為模板
separator.RunDashboard.Filter=顯示
separator.RunDashboard.GroupBy=分組
separator.show=顯示
show.log.in.action.text=在{0}中顯示日誌
show.log.notification.text=檢視日誌
"
`;

exports[`src messages/DiffBundle.properties 1`] = `
"action.Anonymous.text.apply.non.conflicting.changes=套用不衝突的更改\\:
action.merge.apply.non.conflicts.all.text=所有
action.merge.apply.non.conflicts.left.text=左側
action.merge.apply.non.conflicts.right.text=右側
action.presentation.RefreshDirDiffAction.text=重新整理
action.presentation.diff.accept.text=接受
action.presentation.diff.append.text=追加
action.presentation.diff.append.to.the.side.text=追加到 {0, choice, 0\\#左側|1\\#右側}
action.presentation.diff.copy.text=複製
action.presentation.diff.include.into.commit.area.marker.text=現在，差異檢視中忽略了此區塊中的某些更改。<br>選中該複選框，您將包括此列指示要提交的所有行。
action.presentation.diff.include.into.commit.text=包含到提交中
action.presentation.diff.revert.text=還原
action.presentation.go.to.change.text=轉到更改
action.presentation.merge.ignore.text=忽略
action.presentation.merge.resolve.automatically.text=自動解決
action.presentation.merge.resolve.text=解決
action.presentation.merge.resolve.using.side.text=使用{0, choice, 0\\#左側|1\\#右側} 解決
action.use.external.tool.text=使用以下內容顯示差異\\: {0}
advanced.setting.enable.combined.diff=一體化差異
advanced.setting.enable.combined.diff.description=如果啟用，所有更改的檔案都會顯示在單個可滾動差異檢視中
advanced.setting.show.diff.as.editor.tab=作為編輯器頁籤開啟差異
advanced.setting.show.diff.as.editor.tab.description=如果啟用，差異將顯示在編輯器頁籤中，而不是單獨的視窗中
advanced.settings.vcs=版本控制
apply.changes.and.mark.resolved=套用更改並標記為已解決
apply.partially.resolved.merge.dialog.title=套用更改
apply.patch.all.changes.processed.message.text=儲存更改並完成解析
apply.patch.all.changes.processed.title.text=所有區塊均已處理
apply.patch.partially.resolved.changes.confirmation.message={0, choice, 1\\#1 個區塊|2\\#{0, number} 個區塊}未處理。\\n要儲存更改並完成解決嗎?
apply.somehow.status.message.all.applied=已解決所有區塊
apply.somehow.status.message.already.applied={0, number} 個{0, choice, 1\\#區塊|2\\#區塊}已套用
apply.somehow.status.message.cant.apply=無法套用 {0, number} 個{0, choice, 1\\#區塊|2\\#區塊}
apply.somehow.status.message.cant.apply.some=無法套用 {0, number} 個區塊，共 {1, number} 個
binary.diff.contents.are.different.message.text=檔案內容不同
binary.diff.contents.are.identical.message.text=檔案內容相同
binary.file.viewer=二進制檔案檢視器
blank.diff.recent.content.summary.text.date={0} ({1})
blank.diff.recent.content.summary.text.length.date={0} ({1} 字元，{2})
button.abort.resolve=中止解決
button.associate.file.type=關聯
button.cancel.merge=取消合併
button.continue.merge=繼續合併
button.dirdiff.filter=過濾(&F)\\:
button.discard.changes.and.do=捨棄更改並{0}
button.hide.notification=隱藏
button.merge.resolve.accept.left=接受左側
button.merge.resolve.accept.right=接受右側
button.merge.resolve.apply=套用
button.merge.resolve.cancel=取消
button.reload.diff.request=重新載入
can.t.copy.file=無法複製檔案
can.t.finish.merge.resolve=無法解決合併衝突
can.t.load.some.changes=無法載入某些更改
can.t.show.diff.in.external.tool=無法在外部工具中顯示差異
can.t.show.diff.in.external.tool.too.many.files=選擇的檔案過多，無法使用外部工具開啟，{0} 未開啟。
can.t.show.merge.in.external.tool=無法在外部工具中顯示合併
cancel.visual.merge.dialog.title=取消檔案合併
cannot.create.file.error=無法建立檔案\\: {0}
cannot.find.file.error=找不到檔案\\: {0}
changing.highlighting.requires.the.file.merge.restart=更改醒目提示需要重啟檔案合併。是否捨棄未儲存的更改並重啟合併?
collapse.unchanged.fragments=摺疊未更改的片段
column.dirdiff.date=日期
column.dirdiff.name=名稱
column.dirdiff.size=大小
combined.diff.files.count={0, choice, 0\\#無檔案|1\\#1 個檔案|2\\#{1}/'<a href\\="">'{0} 個檔案'</a>'}
combined.side.by.side.viewer=拆分
combined.unified.viewer=統合
compare.0.with.1=比較 ''{0}'' 和 ''{1}''
compare.by=比較依據\\:
compare.selected.new.files=將左側和右側的所選新檔案相互比較。
configurable.DiffSettingsConfigurable.display.name=差異與合併
configurable.ExternalDiffSettingsConfigurable.display.name=外部差異工具
configurable.diff.collapse.unchanged.ranges.disable=停用
confirm.delete=確認刪除
continue.merge=繼續合併
copy.content.to.side=將內容複製到{0, choice, 0\\#左側|1\\#右側}
data.has.been.changed.externally.reloading.data=資料已在外部更改。正在重新載入資料…
delete.0.items=刪除 {0} 項?
dialog.title.diff.for.range=範圍的差異
diff.actions=差異動作
diff.all.differences.ignored.text=已忽略差異
diff.application.usage.parameters.and.description=用法\\: {0} 差異 <left file> <right file> [<base file>]
diff.cant.calculate.diff=無法計算差異
diff.clipboard.vs.editor.dialog.title=剪貼簿與編輯器
diff.clipboard.vs.editor.dialog.title.with.filename=剪貼簿 vs {0}
diff.clipboard.vs.value.dialog.title=剪貼簿與所選值
diff.content.clipboard.content.title=來自剪貼簿
diff.content.editor.content.title=編輯器
diff.content.selected.value=所選值
diff.content.selection.from.file.content.title={0}中的選區
diff.content.title.current.range=當前
diff.content.title.up.to.date=基本修訂
diff.contents.are.identical.message.text=內容相同
diff.contents.have.differences.only.in.charset.and.line.separators.message.text=內容僅在行分隔符和編碼中有差異
diff.contents.have.differences.only.in.charset.message.text=內容僅在編碼中有差異
diff.contents.have.differences.only.in.line.separators.message.text=內容僅在行分隔符中有差異
diff.count.differences.status.text={0, choice, 0\\#沒有|1\\#1個|2\\#{0, number}個}差異
diff.element.qualified.name.vs.element.qualified.name.dialog.title={0} 與 {1}
diff.file.editor.name=差異
diff.files.count.files.in.text=({0} 中)
diff.files.count.hyperlink.text={0} 個檔案
diff.files.dialog.title=差異
diff.files.editors.search.files.count={0,choice,1\\#{0} 個檔案|2\\#{0} 個檔案}
diff.files.editors.search.matches={0, choice, 0\\#{1} 中有 0 個結果|1\\#{1} 中有 1 個結果|2\\#{1} 中有 {0} 個結果}
diff.files.editors.search.partly.matches={0, choice, 0\\#{1} 中有 0+ 個結果|1\\#{1} 中有 1+ 個結果|2\\#{1} 中有 {0}+ 個結果}
diff.files.generic.request.title=更改
diff.highlighting.disabled.text=差異醒目提示處於關閉狀態
diff.inactive.count.differences.status.text=({0} 停用)
diff.included.count.differences.status.text=，包括 {0}
diff.progress.spinner.tooltip.text=正在計算差異
diff.tool=差異工具
diff.type.changed.name=已更改
diff.type.conflict.name=衝突
diff.type.deleted.name=已刪除
diff.type.inserted.name=已插入
diff.unchanged.lines.folding.marker.renderer=標記\\: 已摺疊的未更改的行
diff.utf.charset.name.bom.suffix={0} BOM
diff.version.title.after=之後
diff.version.title.before=之前
dirdiff.filter.help.description=<p>要包含檔案，請輸入符合模式。</p><p>要排除檔案，請在模式前新增 <code>\\!</code>。</p><p>使用 <code>\\\\&</code> 和 <code>|</code> 分別通過 <code>AND<code/> 和 <code>OR<code/> 運算組合多個篩選器。</p><p><b>範例</b>\\:</p><ul><li><code>*.txt</code> 會驗證以 .txt 結尾的所有路徑。</li><li><code>\\!build/*</code> 會排除位於 <code>build</code> 目錄內的所有檔案。</li><li><code>*.txt\\\\&\\!build/*</code> 會驗證以 <code>.txt</code> 結尾且不位於 <code>build</code> 目錄內的所有路徑。</li></ul>
dirdiff.filter.help.title=篩選模式
dirdiff.mode.binary.content=二進制內容
dirdiff.mode.size=大小
dirdiff.mode.size.and.timestamp=大小和時間戳
dirdiff.mode.text=文本
directory.diff=目錄差異
directory.diff.actions=目錄差異動作
directory.viewer=目錄檢視器
disable.editing=停用編輯
discard.changes.and.restart.merge=捨棄更改並重啟合併
do.not.ask.me.again=不再詢問我
editing.viewer.hint.enable.editing.text=此檢視為唯讀。<a href\\="">啟用編輯</a>
editor.settings=設定
error.can.not.calculate.diff.file.too.big=無法計算差異。檔案太大且更改太多。
error.can.not.calculate.diff.operation.canceled=無法計算差異。動作已取消。
error.cannot.show.diff=無法顯示差異
error.cannot.show.merge=無法顯示合併
error.cant.resolve.conflicts.in.a.read.only.file=無法解決唯讀檔案中的衝突
error.cant.show.diff.cant.load.revision.content=無法獲取此修訂中的內容
error.cant.show.diff.cant.show.for.directory=無法顯示目錄的差異
error.cant.show.diff.content.not.found=無法顯示差異\\: 找不到內容
error.cant.show.diff.file.not.found=無法顯示差異\\: 找不到檔案
error.cant.show.diff.for.unknown.file=無法顯示未知檔案類型的差異
error.cant.show.diff.message=錯誤\\: 無法顯示差異
error.cant.show.dirdiff.preview.cant.load.content=無法獲取內容
error.cant.show.file=無法顯示檔案
error.cant.show.merge.file.not.found=無法顯示合併衝突\\: 找不到檔案
error.cant.show.merge.operation.not.supported=無法顯示合併衝突\\: 此動作不受支援
error.cant.show.merge.project.not.found=無法顯示合併衝突\\: 未知專案類型
error.conflict.is.not.valid.and.no.longer.can.be.resolved=衝突無效，無法再解決。
error.content.decoded.with.wrong.charset=內容解碼出錯(使用 ''{0}'' 字符集)
error.file.is.not.valid=文本表示不再映射到磁碟上的檔案內容
error.file.is.too.large.only.preview.is.loaded=檔案太大。僅載入預覽。
error.files.too.large.to.compare.text=檔案太大，無法比較
error.message.cannot.show.diff=無法顯示差異
error.message.cannot.show.merge=無法顯示合併
error.operation.canceled=動作已被取消
error.viewer=錯誤檢視器
filetype.diff.description=差異
hide.this.notification=隱藏此通知
highlight.words=醒目提示顯示單詞
highlighting.level=醒目提示級別
label.cant.show.diff.with.description=無法顯示差異\\: {0}
label.cant.show.merge.with.description=無法顯示合併\\: {0}
label.default.diff.editor.tab.name=差異
label.diff.settings.path=設定 | 工具 | 差異與合併
label.diff.settings.path.macos=偏好設定 | 工具 | 差異與合併
label.dirdiff.loading.file=正在載入… {0}
label.merge.unsaved.changes.discard.and.do.anyway=結果檔案中有未儲存的更改。捨棄更改並繼續{0}嗎?
launching.external.tool=正在啟動外部工具…
mark.as.resolved=標記為已解決
merge.all.changes.processed.message.text=儲存更改並完成合併
merge.all.changes.processed.title.text=所有更改均已處理
merge.application.usage.parameters.and.description=用法\\: {0} 合併 <left file> <right file> [<base file>] <output file>
merge.color.options.background.color.label=重要
merge.color.options.dialog.title=合併顏色選項
merge.color.options.ignored.color.label=已忽略
merge.conflict.is.outdated=合併衝突已過時。在衝突解決開始之前還原檔案內容?
merge.continue.button=繼續(&C)
merge.dialog.accept.change.command=接受更改
merge.dialog.all.conflicts.resolved.message.text=已解決所有衝突
merge.dialog.apply.non.conflicted.changes.command=套用不衝突的更改
merge.dialog.apply.partially.resolved.changes.confirmation.message={0, choice, 0\\#'{1, choice, 1\\#有|2\\#有}'|1\\#有|2\\#有} {0, choice, 0\\#|1\\#1 個更改|2\\#{0, number} 個更改}{0, choice, 0\\#|1\\#'{1, choice, 0\\#|1\\#和 }'}{1, choice, 0\\#|1\\#1 個衝突|2\\#{1, number} 個衝突}未處理。\\n仍要儲存更改並將衝突標記為解決嗎?
merge.dialog.exit.without.applying.changes.confirmation.message=確定要登出且不套用更改嗎?
merge.dialog.ignore.change.command=忽略更改
merge.dialog.reset.change.command=重設已解決的更改
merge.dialog.resolve.conflict.command=解決衝突
merge.differences.status.text={0, choice, 0\\#沒有更改|1\\#1 個更改|2\\#{0, number} 個更改}。{1, choice, 0\\#沒有衝突|1\\#1 個衝突|2\\#{1, number} 個衝突}。
merge.files.dialog.title=合併
merge.in.external.tool=在外部工具中合併
merge.save.and.finish.button=儲存並完成(&F)
merge.tool=合併工具
merge.version.title.base=基礎版本
merge.version.title.current=當前版本\\:
merge.version.title.merged=合併版本
merge.version.title.merged.result=結果
merge.version.title.our=您的版本
merge.version.title.their=來自伺服器的更改
merge.version.title.their.with.revision=來自伺服器的更改 (修訂版 {0})
merge.window.title.file=合併 {0}
message.do.in.merge.command=合併時 {0}
message.init.merge.content.command=初始化合併內容
message.replace.change.command=取代更改
message.resolve.simple.conflicts.command=解決簡單的衝突更改
message.use.selected.changes.command={0}所選更改
notification.action.text.blank.diff.recent=最近
notification.action.text.blank.diff.select.file=選擇檔案…
notification.status.content.added=內容已新增
notification.status.content.removed=內容已移除
notification.you.can.disable.this.feature.in.0=您可以在 {0} 中停用此功能
option.highlighting.level.inspections=檢查
option.highlighting.level.none=無
option.highlighting.level.syntax=語法
option.highlighting.policy.group.name=醒目提示顯示模式
option.highlighting.policy.lines=醒目提示行
option.highlighting.policy.none=不醒目提示顯示
option.highlighting.policy.split=醒目提示拆分的更改
option.highlighting.policy.symbols=醒目提示顯示字元
option.highlighting.policy.words=醒目提示顯示單詞
option.ignore.policy.formatting=忽略格式設定
option.ignore.policy.group.name=忽略更改
option.ignore.policy.language.specific.changes=忽略針對特定語言的更改
option.ignore.policy.none=不忽略
option.ignore.policy.trim=修整空白
option.ignore.policy.whitespaces=忽略空格
option.ignore.policy.whitespaces.empty.lines=忽略空格和空行
option.inherit.ignored.color=繼承忽略的顏色
option.three.side.color.policy.left.to.right=左到右
option.three.side.color.policy.merge.conflict=合併衝突
option.three.side.color.policy.merge.resolved=解決的合併衝突
patch.dialog.copy.change.command=複製到剪貼簿
patch.dialog.copy.change.command.balloon=已複製到剪貼簿
patch.editing.viewer.hint.enable.editing.text=此檢視為唯讀。<a href\\="">切換到編輯</a>
press.again.to.go.to.the.next.file=再按一次轉到下一個檔案
press.again.to.go.to.the.previous.file=再按一次轉到上一個檔案
press.mark.as.resolve=在外部工具中解決完衝突時，按“標記為已解決”
progress.title.loading.requests=正在載入請求…
refresh.failed.message=重新整理失敗\\: {0}
rollback.change.command.name=回滾更改
select.external.program.dialog.title=選擇外部程序
select.file.to.compare=選擇要比較的檔案
settings.automatically.apply.non.conflicting.changes=自動套用不衝突的更改
settings.automatically.resolve.imports.conflicts=自動解決 import 語句中的衝突
settings.context.lines=上下文行\\:
settings.diff.name=差異
settings.diffIncludedInHistory=包括導覽歷史記錄中的差異\\:
settings.diffIncludedInHistory.always=始終
settings.diffIncludedInHistory.never=從不
settings.diffIncludedInHistory.onlyIfOpen=直到差異關閉
settings.external.diff.base.file.content=基檔案內容
settings.external.diff.comboBox.value.unknown.filetype.text={0} (未知)
settings.external.diff.enable.external.tools=啟用外部工具
settings.external.diff.left.file.content=左側檔案內容
settings.external.diff.merge.conflict.resolve.successful=合併衝突解決成功。\\n已解決的內容為\\:\\n{0}
settings.external.diff.merge.conflict.resolve.was.canceled=合併衝突解決已取消。
settings.external.diff.original.output.file.content=原始輸出檔案內容
settings.external.diff.panel.table.title=組態與檔案類型關聯的外部差異/合併工具\\:
settings.external.diff.panel.tree.title=組態外部工具\\:
settings.external.diff.right.file.content=右側檔案內容
settings.external.diff.table.difftool.column=差異工具
settings.external.diff.table.filetype.column=檔案類型
settings.external.diff.table.filetype.default=預設
settings.external.diff.table.mergetool.column=合併工具
settings.external.diff.table.remove.dialog.message=確定要刪除此條目嗎?
settings.external.diff.table.remove.dialog.title=移除外部差異工具
settings.external.diff.table.tool.default=內建
settings.external.diff.test.complete=測試完成
settings.external.diff.test.diff=測試差異
settings.external.diff.test.merge=測試合併
settings.external.diff.test.three.side.diff=測試三向差異
settings.external.diff.trust.process.exit.code=信任程序離開程式碼
settings.external.tool.tree.add.dialog.field.argument.pattern=實參模式
settings.external.tool.tree.add.dialog.field.group=工具組
settings.external.tool.tree.add.dialog.field.program.path=程序路徑
settings.external.tool.tree.add.dialog.field.tool.name=工具名稱
settings.external.tool.tree.add.dialog.title=新增外部工具
settings.external.tool.tree.edit.dialog.title=編輯外部工具
settings.external.tool.tree.remove.warning.message=此工具用於組態。首先移除表中的組態
settings.external.tool.tree.remove.warning.title=無法刪除所選工具
settings.external.tool.tree.validation.already.exist=名稱為“{1}”的 {0} 已存在
settings.external.tool.tree.validation.empty=外部工具名稱不得為空
settings.external.tools.parameters.description=不同的工具有不同的參數。按正確的順序指定所有必要的參數非常重要\\:
settings.external.tools.parameters.diff=<b>%1</b> - 左(本地更改)<br><b>%2</b> - 右(伺服器內容)<br><b>%3</b> - 基礎(沒有本地更改的當前版本)
settings.external.tools.parameters.merge=<b>%1</b> - 左(本地更改)<br><b>%2</b> - 右(伺服器內容)<br><b>%3</b> - 基礎(沒有本地更改的當前版本)<br><b>%4</b> - 輸出(合併結果)
settings.external.tools.test.process.exit.text=程序已終止\\: exitCode ''{0}''
settings.go.to.the.next.file.after.reaching.last.change=到達上次更改後轉到下一個檔案
settings.highlight.modified.lines.in.gutter=在裝訂區域中醒目提示修改的行
settings.merge.text=合併
side.by.side.viewer=並排檢視器
synchronize.document.and.its.fragment=同步文檔及其片段
synchronize.document.and.its.fragment.range.error=選區無效
synchronize.editors.settings=同步編輯器設定
synchronize.scrolling=同步滾動
tooltip.merge.ctrl.click.to.resolve.conflict=Ctrl+點擊來解決衝突
unified.viewer=統合檢視器
update.highlighting.settings=更新醒目提示設定
use.space.button.or.mouse.click=使用空格按鈕或滑鼠點擊來更改選定元素的動作。按回車鍵執行。
use.space.button.to.change.operation=使用空格按鈕更改動作
vcs.marker.changed.line=VCS 標記\\: 更改的行
waiting.for.external.tool=正在等待外部工具…
"
`;

exports[`src messages/GitBundle.properties 1`] = `
"abort=中止
abort.operation.cherry.pick.name=優選
abort.operation.dialog.msg=中止 {0}{1}?
abort.operation.dialog.title=中止 {0}
abort.operation.failed={0} 中止失敗
abort.operation.indicator.text=git {0} --abort{1}
abort.operation.merge.name=合併
abort.operation.progress.title=正在中止 {0} 程序
abort.operation.rebase.name=重定基底
abort.operation.revert.name=還原
abort.operation.succeeded={0} 中止成功
action.CopyPathFromRepositoryRootProvider.text=版本庫根路徑
action.Git.Add.text=新增
action.Git.Branches.text=分支(_B)…
action.Git.BrowseRepoAtRevision.text=在修訂版中顯示版本庫
action.Git.CheckoutRevision.text=簽出修訂
action.Git.CherryPick.Abort.text=中止優選
action.Git.Clone.text=克隆…
action.Git.Commit.Stage.text=提交…
action.Git.Compare.Selected.Heads.description=顯示所選分支 head 之間的差異
action.Git.Compare.Selected.Heads.title=顯示檔案差異
action.Git.Compare.Selected.description=相互比較選定分支
action.Git.Compare.Selected.description.disabled=從同一版本庫中選擇分支
action.Git.Compare.Selected.title=比較分支
action.Git.Compare.With.Current.title=與當前分支進行比較
action.Git.CompareWithBranch.text=與分支或標籤比較…
action.Git.Configure.Remotes.text=管理遠端…
action.Git.CreateNewBranch.FromCommit.description=從所選提交開始建立新分支
action.Git.CreateNewBranch.FromCommit.text=新增分支…
action.Git.CreateNewBranch.text=新增分支…
action.Git.CreateNewTag.description=建立指向此提交的新標籤
action.Git.CreateNewTag.text=新增標記…
action.Git.Delete.Branch.title=刪除{0,choice,1\\#分支|2\\#分支}
action.Git.Drop.Commits.text=刪除提交
action.Git.Drop.Selected.Changes.text=刪除所選更改
action.Git.Fetch.description.fetch.in.progress=正在獲取…
action.Git.Fetch.text=獲取
action.Git.Fetch.title=獲取所有遠端
action.Git.Fixup.To.Commit.description=建立 fixup 提交
action.Git.Fixup.To.Commit.description.nothing.to.commit=沒有要提交的內容
action.Git.Fixup.To.Commit.text=Fixup…
action.Git.InMemory.Extract.Selected.Changes.description=根據所選更改建立一個新的提交，並將其直接放置在歷史記錄中原始提交之後
action.Git.InMemory.Extract.Selected.Changes.text=將所選更改獲取到單獨的提交…
action.Git.InMemory.Reword.Commit.description=通過記憶體中重定基底更改提交訊息
action.Git.InMemory.Reword.Commit.text=編輯提交訊息…(記憶體中)
action.Git.Init.Stage.error=向 Git 新增檔案失敗
action.Git.Init.Vcs.Toolbar.Widget.text=建立 Git 版本庫…
action.Git.Init.error=Git init 失敗
action.Git.Init.text=建立 Git 版本庫…
action.Git.Interactive.Rebase.description=顯示互動重定基底的對話框，可以在該對話中對提交執行壓縮、fixup、重新排序、移除和改寫
action.Git.Interactive.Rebase.text=從這裡進行互動重定基底…
action.Git.Loading.Branches.progress=正在載入分支…
action.Git.Log.Branches.Change.Branch.Filter.On.Selection.description=選擇分支後，按此分支篩選日誌
action.Git.Log.Branches.Change.Branch.Filter.On.Selection.text=更新分支篩選器
action.Git.Log.Branches.Change.Branch.Filter.description=使用所選分支更新日誌中的分支篩選器
action.Git.Log.Branches.Change.Branch.Filter.text=更新日誌中的分支篩選器
action.Git.Log.Branches.Navigate.Log.To.Branch.On.Selection.description=選擇分支後，在日誌中導覽到該分支 HEAD
action.Git.Log.Branches.Navigate.Log.To.Branch.On.Selection.text=在日誌中導覽到分支 Head
action.Git.Log.Branches.Navigate.Log.To.Selected.Branch.text=在日誌中導覽到所選分支 Head
action.Git.Log.DeepCompare.description=醒目提示尚未優選到當前分支的提交
action.Git.Log.DeepCompare.text=無優選提交
action.Git.Log.Edit.Remote.text=編輯遠端
action.Git.Log.Hide.Branches.text=隱藏 Git 分支
action.Git.Log.Remove.Remote.text=移除{0,choice,1\\#遠端|2\\#遠端}
action.Git.Log.Show.Branches.text=分支
action.Git.Log.Show.Command.text=顯示指令的 Git 日誌
action.Git.Log.text=顯示 Git 版本庫日誌…
action.Git.Merge.Abort.text=中止合併
action.Git.Merge.text=合併…
action.Git.New.Branch.description=僅選擇一個分支以繼續建立新分支
action.Git.New.Branch.dialog.title=從 {0} 建立分支
action.Git.Pull.text=拉取…
action.Git.Push.Tag.text=推送標籤
action.Git.Push.Tag.text.to=推送到{1,choice,0\\#|1\\# {2} 中的} {0}
action.Git.PushUpToCommit.description=推送所有之前的提交，包括所選提交
action.Git.PushUpToCommit.text=推送此前所有提交…
action.Git.Rebase.Abort.text=中止重定基底
action.Git.Rebase.Continue.text=繼續重定基底
action.Git.Rebase.Skip.progress.title=重定基底期間跳過提交…
action.Git.Rebase.Skip.text=跳過提交
action.Git.Rebase.operation.name=重定基底
action.Git.Rebase.text=重定基底…
action.Git.Reset.In.Log.text=將當前分支重設到此處…
action.Git.Reset.text=重設 HEAD…
action.Git.ResolveConflicts.text=解決衝突…
action.Git.Revert.Abort.text=中止還原
action.Git.Revert.In.Log.description=生成新提交，這會還原在原始提交中所做的更改
action.Git.Revert.In.Log.template.text=還原{0,choice,1\\#提交|2\\#提交}
action.Git.Revert.In.Log.text=還原提交
action.Git.RevertResolved.confirmation=是否要還原已解析的{0,choice,1\\#檔案|2\\#檔案}\\: {1}?
action.Git.RevertResolved.confirmation.title=還原已解析的檔案
action.Git.RevertResolved.progress=正在還原已解決的衝突…
action.Git.RevertResolved.text=還原已解決
action.Git.Reword.Commit.description=通過 git rebase 或 amend 的改寫選項更改提交訊息
action.Git.Reword.Commit.text=編輯提交訊息…
action.Git.Show.My.Branches.description.calculating.branches.progress=正在計算我的分支
action.Git.Show.My.Branches.description.is.my.branch=如果分支的所有獨佔提交都是由“我”(即當前 Git 作者)執行的，則此分支為“我的”。
action.Git.Show.My.Branches.description.not.all.roots.indexed=並沒有為所有版本庫編制索引。
action.Git.Show.My.Branches.description.not.graph.ready=該日志尚未就緒，請稍候。
action.Git.Show.My.Branches.description.not.support.indexing=某些版本庫不支持索引。
action.Git.Show.My.Branches.title=顯示我的分支
action.Git.Show.Stage.text=顯示暫存區域
action.Git.Show.Stash.With.Shelf.description=開啟“隱藏和擱置”頁籤
action.Git.Show.Stash.With.Shelf.text=顯示隱藏和擱置
action.Git.Show.Stash.description=開啟“Git 隱藏”頁籤
action.Git.Show.Stash.text=顯示 Git 隱藏
action.Git.ShowBranches.pretty.description=顯示分支
action.Git.ShowBranches.text=顯示分支
action.Git.Squash.Commits.description=互動重定基底以將所選提交合併為一個提交
action.Git.Squash.Commits.text=壓縮提交…
action.Git.Squash.Into.Commit.description=提交本地更改，以便將其壓縮到所選提交中
action.Git.Squash.Into.Commit.text=壓縮到…
action.Git.Stage.Add.All.description=將所有未暫存的更改和未追蹤的檔案新增到索引
action.Git.Stage.Add.All.text=全部暫存
action.Git.Stage.Add.Tracked.description=將追蹤檔案中所有未暫存的更改新增到索引
action.Git.Stage.Add.Tracked.text=暫存全部已追蹤項
action.Git.Stage.Compare.Local.Staged.text=與暫存版本比較
action.Git.Stage.Compare.Staged.Head.text=與 HEAD 版本比較
action.Git.Stage.Compare.Staged.Local.text=與本地版本比較
action.Git.Stage.Compare.Three.Versions.text=比較 HEAD 版本、暫存版本和本地版本
action.Git.Stage.Disable.description=停用暫存區域並切換到更改列表
action.Git.Stage.Disable.text=變更列表
action.Git.Stage.Enable.description=使用原生 Git 暫存概念進行提交
action.Git.Stage.Enable.text=暫存區域
action.Git.Stage.Show.Local.description=在編輯器中顯示當前檔案的本地內容
action.Git.Stage.Show.Local.text=顯示本地版本
action.Git.Stage.Show.Staged.description=在編輯器中顯示當前檔案的暫存內容
action.Git.Stage.Show.Staged.text=顯示暫存版本
action.Git.Stage.ThreeSideDiff.description=顯示包含 HEAD、暫存和本地版本的差異視窗，從中可以互動地將更改新增到暫存區域
action.Git.Stage.ThreeSideDiff.text=比較 HEAD 版本、暫存版本和本地版本
action.Git.Stage.ToggleCommitAll.description=沒有暫存檔案時提交所有檔案
action.Git.Stage.ToggleCommitAll.text=無任何內容暫存時全部提交
action.Git.Stash.Apply.description=套用所選隱藏
action.Git.Stash.Apply.text=套用(&A)
action.Git.Stash.Clear.description=清除所有隱藏
action.Git.Stash.Clear.in.root.description=清除所選根中的所有隱藏
action.Git.Stash.Clear.in.root.text=清除 {0} 中的隱藏(&C)
action.Git.Stash.Clear.text=清除(&C)
action.Git.Stash.Drop.description=丟棄所選隱藏
action.Git.Stash.Drop.text=刪除(&D)
action.Git.Stash.Pop.description=彈出所選隱藏
action.Git.Stash.Pop.text=彈出(&P)
action.Git.Stash.Refresh.description=重新整理隱藏列表
action.Git.Stash.Refresh.text=重新整理隱藏
action.Git.Stash.Silently.text=無提示隱藏
action.Git.Stash.Toggle.Split.Preview.text=預覽差異
action.Git.Stash.UnstashAs.description=彈出或套用選定的隱藏作為新分支(帶或不帶索引)
action.Git.Stash.UnstashAs.text=取消隱藏(&U)…
action.Git.Stash.text=隱藏更改…
action.Git.Tag.text=新增標記…
action.Git.Toggle.Favorite.title=標記/取消標記為收藏項
action.Git.Toolbar.ShowMoreActions.description=VCS 動作
action.Git.Toolbar.ShowMoreActions.text=版本控制
action.Git.Uncommit.description=撤消最後一次提交並將其更改放入所選更改列表
action.Git.Uncommit.text=撤消提交…
action.Git.Unshallow.failure.title=無法取消淺層化版本庫
action.Git.Unshallow.progress.title=正在取消淺層化版本庫…
action.Git.Unshallow.text=取消淺層化版本庫
action.Git.Unstash.text=取消隱藏更改…
action.Git.Update.Selected.description=從追蹤的遠端獲取並使用 {1} 或像 \`git fetch branch\\:branch\` 一樣的快進(如果可能)更新所選{0,choice,1\\#分支|2\\#分支}
action.Git.Update.Selected.description.already.running=更新已在執行
action.Git.Update.Selected.description.select.non.current=僅選擇非當前分支
action.Git.Update.Selected.description.tracking.not.configured=沒有為所選{0,choice,1\\#分支|2\\#分支}組態追蹤分支
action.Git.Update.Selected.text=更新所選
action.New.Branch.disabled.fresh.description=無法在空版本庫中建立新分支。首先進行初始提交
action.New.Branch.disabled.several.commits.description=選擇單個提交以建立新分支
action.NotificationAction.GitDeleteBranchOperation.text.delete.tracked.branch=刪除追蹤的分支
action.NotificationAction.GitDeleteBranchOperation.text.restore=還原
action.NotificationAction.GitDeleteBranchOperation.text.view.commits=檢視提交
action.NotificationAction.GitDeleteTagOperation.text.restore=還原
action.NotificationAction.GitMergeAction.text.view.commits=檢視提交
action.NotificationAction.GitRewordOperation.text.undo=撤消
action.NotificationAction.GitUpdateSession.text.view.commits=檢視提交
action.NotificationAction.GithubNotifications.text.configure=組態…
action.NotificationAction.text.resolve=解決…
action.description.cant.revert.merge.commit=不允許還原合併提交
action.fetch.text=獲取
action.git.branches.group.by.prefix.text=按前綴分組
action.git.branches.popup.filter.by.action.single.text=在搜尋結果中顯示動作
action.git.branches.popup.filter.by.action.text=動作
action.git.branches.popup.filter.by.repository.text=版本庫
action.git.branches.show.recent.text=顯示最近的分支
action.git.branches.show.tags.text=顯示標籤
action.git.update.force.pushed.branch.description=對可能強制推送的當前分支執行更新。此動作可以利用現有的“更新專案”動作(例如，當存在本地合併提交時)。
action.git.update.force.pushed.branch.not.all.local.commits.chery.picked=並非所有本地提交都是從 {0} 分支中優選的
action.git.update.force.pushed.branch.progress=正在執行強制推送的分支更新…
action.git.update.force.pushed.branch.success=可能強制推送的分支更新成功
action.git.update.force.pushed.branch.text=更新強制推送的分支
action.git4idea.commands.TestGitHttpLoginDialogAction.text=測試 Git 登入對話框
action.gpg.agent.configuration.text=組態 GPG 代理
action.label.add.unstaged.range=暫存
action.label.add.unstaged.range.tooltip=向索引中新增新的更改
action.label.reset.staged.range=取消暫存
action.label.reset.staged.range.tooltip=移除索引中的更改
action.main.toolbar.git.Branches.text=VCS 小工具
action.main.toolbar.git.MergeRebase.text=VCS 合併/重定基底小工具
action.main.toolbar.git.project.not.trusted.separator.text=安全模式，版本控制不可用
action.not.possible.in.fresh.repo.checkout=簽出
action.not.possible.in.fresh.repo.generic=動作
action.selected.directory.text=選定{0,choice,1\\#目錄|2\\#目錄}
action.selected.file.text=選定{0,choice,1\\#檔案|2\\#檔案}
activity.name.abort.command=Git abort {0}
activity.name.checkout=Git checkout
activity.name.cherry.pick=Git cherry-pick
activity.name.merge=Git merge
activity.name.rebase=Git rebase
activity.name.reset=Git reset
activity.name.revert=Git revert
activity.name.stash=Git stash
activity.name.undo.commit=Git undo commit
activity.name.unstash=Git unstash
add.adding=正在新增檔案…
advanced.setting.git.branch.cleanup.symbol=分支名稱清理符號
advanced.setting.git.branch.cleanup.symbol.description=將在 Git 分支名稱中代替停用符號的符號
advanced.setting.git.clone.recurse.submodules=遞迴克隆專案中的子模組
advanced.setting.git.clone.recurse.submodules.description=啟用後，從 Git 呼叫 'git clone --recurse-submodules' 簽出，即克隆主版本庫與所有子模組 (如有)
advanced.setting.git.commit.do.not.run.commit.hooks=不執行 Git 提交掛鈎
advanced.setting.git.commit.do.not.run.commit.hooks.description=啟用後，提交始終使用 '--no-verify' 選項執行
advanced.setting.git.read.content.with=從 Git 讀取時套用內容轉換
advanced.setting.git.read.content.with.description=從 Git 讀取檔案內容時為 'git cat-file' 指令使用 '--filters' 或 '--textconv' 標誌
advanced.setting.git.recent.projects.show.branch=在最近專案列表中顯示分支名稱
advanced.setting.git.recent.projects.show.branch.description=分支名稱將顯示在歡迎頁面和主選單中的最近專案列表中
advanced.setting.git.search.everywhere.tab.enabled=在“隨處搜尋”中顯示 Git 頁籤
advanced.setting.git.update.incoming.outgoing.info=檢查傳入和傳出提交
advanced.setting.git.update.incoming.outgoing.info.description=在“分支”彈出視窗中更新具有傳入/傳出提交的分支資訊
advanced.setting.git.use.push.force.with.lease=使用安全強制推送
advanced.setting.git.use.push.force.with.lease.description=從 IDE 呼叫強制推送時使用 '--force-with-lease'，而非僅使用 '--force'
advanced.setting.git.use.schannel.on.windows=使用 Windows 憑證存儲
advanced.setting.git.use.schannel.on.windows.description=強制 Git 使用 Windows 憑證存儲來驗證 SSL 連線。適用於 Git 2.14 及更高版本。
advanced.settings.git=版本控制. Git
annotate.cannot.annotate.dir=無法註解目錄
annotate.line.mismatch.exception=正在為第 {0} 行新增資訊，但應當為第 {1} 行新增資訊
annotate.output.lack.data=第 {0} 行的輸出缺少必要的資料
annotate.repository.is.shallow=淺層版本庫中的註解可能不準確
annotations.options.detect.movements.across.files=檢測跨檔案的移動
annotations.options.detect.movements.within.file=檢測檔案內的移動
annotations.options.group=選項
annotations.options.ignore.whitespaces=忽略空格
apply.changes.applied.for.commits={0} {1,choice,1\\#項提交|2\\#{1,number} 項提交} 來自於 {2}
apply.changes.everything.applied={0} 中的所有更改已被{1}
apply.changes.nothing.to.do=沒要有{0}的內容
apply.changes.operation.canceled={0} 已取消
apply.changes.operation.failed={0} 失敗
apply.changes.operation.performed.with.conflicts={0}已執行，但存在衝突
apply.changes.operation.successful={0}成功
apply.changes.operation.successful.for.commits=但是，對以下{1, choice,1\\#提交|2\\#提交}成功進行了{0}\\:
apply.changes.resolving.conflicts.progress.title=正在解決衝突…
apply.changes.restore.notification.description=本地更改已在{0}之前儲存
apply.changes.restore.notification.title=還原本地更改
apply.changes.save.and.retry.operation={0}更改並重試
apply.changes.skipped={0} {1,choice,1\\#被|2\\#被}跳過，因為所有更改已被{2}。
apply.changes.unresolved.conflicts.notification.abort.action.text=中止{0}
apply.changes.unresolved.conflicts.notification.resolve.action.text=解決…
apply.changes.unresolved.conflicts.text=工作樹中有未解決的衝突。
apply.conflict.dialog.description.label.text=在由 {2} 執行的提交 {1} 的{0}過程中發生衝突{3}
blob.not.found=找不到 Blob\\: {0} - {1}
branch.checking.out.branch.from.process=正在從 {1} 簽出 {0}…
branch.checking.out.new.branch.process=正在簽出新分支 {0}…
branch.checking.out.process=正在簽出 {0}…
branch.creating.branch.process=正在建立分支 {0}…
branch.deleting.branch.process=正在刪除 {0}…
branch.deleting.remote.branch=正在刪除 {0}…
branch.deleting.tag.on.remote.process=正在刪除遠端分支上的標記 {0}…
branch.direction.panel.base.repo.label=base 版本庫\\:
branch.direction.panel.branch.label=分支\\:
branch.direction.panel.head.repo.label=head 版本庫\\:
branch.direction.panel.save.button=儲存
branch.direction.panel.select.link=選擇…
branch.direction.panel.warning.not.synced=本地分支未與遠端分支同步。\\n''{0}'' 分支將與 ''{1}'' 同步。
branch.direction.panel.warning.push=''{0}'' 沒有遠端分支。\\n將在 ''{1}'' 上建立新的遠端分支。
branch.merging.process=正在合併 {0}…
branch.not.fully.merged.dialog.all.commits.from.branch.were.merged=已合併來自分支 {0} 的所有提交
branch.not.fully.merged.dialog.repository.label=版本庫\\:
branch.not.fully.merged.dialog.restore.button=還原(&R)
branch.not.fully.merged.dialog.the.branch.was.not.fully.merged.to=分支 {0} 未完全合併到 {1}。<br/>以下是未合併提交的列表。
branch.not.fully.merged.dialog.title=分支未完全合併
branch.operation.could.not.0.operation.name.1.reference=無法{0} {1}
branch.operation.in={0} ({1} 中)
branch.rebasing.onto.process=正在重定基底到 ''{0}''…
branch.rebasing.process=正在重定基底 {0}…
branch.renaming.branch.process=正在將 {0} 重命名為 {1}…
branch.ui.handler.can.not.operation.name.because.of.unmerged.files=由於存在未合併的檔案而無法{0}
branch.ui.handler.delete.all=全部刪除
branch.ui.handler.delete.remote.branches=刪除遠端 {0,choice,1\\#分支|2\\#分支}
branch.ui.handler.delete.remote.branches.question=刪除遠端 {0,choice,1\\#分支|2\\#分支} {1}?
branch.ui.handler.delete.tracking.local.branch.as.well=同時刪除追蹤本地分支 {0}
branch.ui.handler.delete.tracking.local.branches=刪除追蹤本地分支\\:
branch.ui.handler.do.not.rollback=不回滾
branch.ui.handler.merge.error.notification.title=仍然存在未解決的檔案。
branch.ui.handler.merge.notification.description=以下檔案存在未解決的衝突。您需要先解決它們，然後再{0}。
branch.ui.handler.rollback=回滾
branch.ui.handler.unmerged.files.error.notification.text=您需要在{0}之前解決所有合併衝突。<br/>解決衝突後，請不要忘記在切換到另一個分支之前將檔案提交到當前分支。
branch.ui.handler.unmerged.files.error.resolve.conflicts.action.text=解決衝突…
branch.ui.handler.you.have.to.resolve.all.conflicts.before.operation.name=您需要先解決所有合併衝突，然後才能{0}。<br/>{1}
branch.worker.could.not.create.tag=無法{1,choice,0\\#|1\\#|2\\# 在 {2} 中}建立標記 {0}
branches.action.delete=刪除(&D)
branches.action.pull.into.branch.using.merge=使用“合併”拉入 {0}
branches.action.pull.into.branch.using.merge.description=使用合併拉入 {0}
branches.action.pull.into.branch.using.merge.selected=使用“合併”拉入當前分支
branches.action.pull.into.branch.using.rebase=使用“重定基底”拉入 {0}
branches.action.pull.into.branch.using.rebase.description=使用重定基底拉入 {0}
branches.action.pull.into.branch.using.rebase.selected=使用“重定基底”拉入當前分支
branches.branch.0=分支 ''{0}''
branches.branches=分支
branches.checking.existing.commits.process=正在檢查現有提交…
branches.checkout=簽出
branches.checkout.and.rebase.error.current.with.same.name=無法覆蓋當前分支 {0}
branches.checkout.and.rebase.failed=簽出和重定基底失敗
branches.checkout.and.rebase.onto.branch=簽出並重定基底到 {0}
branches.checkout.and.rebase.onto.current=簽出並重定基底到當前分支
branches.checkout.and.rebase.onto.current.process=正在簽出 {0} 並重定基底到當前分支
branches.checkout.and.rebase.onto.in.one.step=簽出 {0}，並在一個步驟中將其重定基底到 {1} (類似於 \`git rebase HEAD {2}\`)
branches.checkout.local=簽出本地分支
branches.checkout.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。將 ''{0}'' 變基到 ''{1}''，還是簽出 ''{0}''?
branches.checkout.s=簽出 {0}
branches.checkout.tag.or.revision=簽出標記或修訂…
branches.checkout.with.reset.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。將 ''{0}'' 變基到 ''{1}''，還是刪除本地提交?
branches.compare.the.current.working.tree.with=將當前工作樹與 {0} 中的樹進行比較
branches.compare.with.branch=與{0}比較
branches.compare.with.current=與當前分支進行比較
branches.create.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。是否要在其他版本庫中建立分支?
branches.create.new.branch.dialog.title=建立新分支
branches.create.with.reset.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。是否要刪除本地提交?
branches.current.branch=當前分支
branches.current.branch.name=當前
branches.drop.local.commits=刪除本地提交
branches.enter.reference.branch.tag.name.or.commit.hash=輸入參照(分支、標記)名稱或提交雜湊\\:
branches.fetch.finished=已獲取 {0} 個目標
branches.local.branches=本地分支
branches.local.branches.in.repo={0} 中的本地分支
branches.merge.into=將 {0} 合併到 {1} 中
branches.merge.into.current=合併到當前分支
branches.new.branch.from.branch=從 {0} 新增分支…
branches.new.branch.from.branch.current=從當前位置新增分支…
branches.new.branch.from.branch.description=從 {0} 建立新分支
branches.rebase.current.onto.selected=將當前分支重定基底到所選分支
branches.rebase.is.not.possible.in.the.detached.head.state=在游離的 HEAD 狀態下無法重定基底
branches.rebase.onto=將 {0} 變基到 {1}
branches.rebase.onto.selected.commit=將 {0} 重定基底到所選提交
branches.rebase.onto.selected.commit.description=將 {0} 變基到 {1}
branches.remote.branches=遠端分支
branches.remote.branches.in.repo={0} 中的遠端分支
branches.rename.branch=重新命名分支 {0}
branches.selected.branch.name=已選擇
branches.show.commits.in=在{0}中顯示{1}中缺少的提交
branches.show.diff.with.working.tree=顯示與工作樹的差異
branches.tag.0=標記 ''{0}''
branches.tags=標記
branches.tags.in.repo={0} 中的標籤
branches.there.are.incoming.and.outgoing.commits=存在傳入和傳出提交
branches.there.are.incoming.commits=存在傳入提交
branches.there.are.outgoing.commits=存在傳出提交
branches.tooltip.number.incoming.commits={0} 個傳入{0,choice,1\\#提交|2\\#提交}
branches.tooltip.number.incoming.commits.in.repositories={1} 個{1, choice, 1\\#版本庫|2\\#版本庫}中的 {0} 個傳入{0,choice,1\\#提交|2\\#提交}
branches.tooltip.number.outgoing.commits={0} 個傳出{0,choice,1\\#提交|2\\#提交}
branches.tooltip.number.outgoing.commits.in.repositories={1} 個{1, choice, 1\\#版本庫|2\\#版本庫}中的 {0} 個傳出{0,choice,1\\#提交|2\\#提交}
branches.tooltip.some.incoming.commits.not.fetched=一些傳入提交未被獲取
branches.tracking.branch.doesn.t.configured.for.s=沒有為 {0} 組態追蹤分支
branches.update=更新
branches.update.failed=更新失敗
branches.update.info.process=更新分支資訊…
branches.update.is.already.running=更新已在執行
branches.updating.process=正在更新分支…
button.changes.excluded.from.commit.commit.anyway=仍然提交
button.crlf.fix.dialog.commit.as.is=按原樣提交
button.crlf.fix.dialog.fix.and.commit=修復並提交
button.don.t.rollback=不回滾
button.rollback=回滾
button.set.name.and.commit.template=設定並{0}
changes.retrieving=檢索修訂 {0} 的更改
changes.view.merge.action.text=合併
changes.view.rollback.action.text=回滾
checkbox.dont.warn.again=不再警告(&W)
checkbox.run.git.hooks=執行 Git 掛鈎(&H)
checkbox.set.config.property.globally=全域設定屬性(&G)
checkout.0=簽出 {0}
checkout.and.rebase=重定基底到遠端
checkout.new.branch.operation.branch.was.created=已建立分支 {0}
checkout.new.branch.operation.checked.out.0.and.deleted.1.on.2.3=已在{2,choice,1\\#根|2\\#根}{3}上簽出 {0} 並刪除 {1}
checkout.new.branch.operation.could.not.create.new.branch=無法建立新分支 {0}
checkout.new.branch.operation.error.during.rollback=回滾期間出錯
checkout.new.branch.operation.errors.during.checkout=簽出期間出錯\\:
checkout.new.branch.operation.errors.during.deleting=刪除 {0} 期間出錯\\:
checkout.new.branch.operation.however.checkout.has.succeeded.for.the.following=不過，{0,choice,1\\#版本庫|2\\#版本庫}的簽出已成功\\:
checkout.new.branch.operation.rollback.successful=回滾成功
checkout.new.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滾(簽回上一個分支並刪除 {0})以使分支不出現分叉。
checkout.operation.checked.out=已簽出 {0}
checkout.operation.checked.out.new.branch.from=已從 {1} 中簽出新分支 {0}
checkout.operation.could.not.checkout.error=無法簽出 {0}
checkout.operation.could.not.checkout.error.title=無法簽出 {0}
checkout.operation.error.during.rollback=回滾期間出錯
checkout.operation.errors.during.checkout=簽出期間出錯\\:
checkout.operation.errors.during.deleting=刪除 {0} 期間出錯\\:
checkout.operation.force.checkout=強制簽出(&F)
checkout.operation.however.checkout.has.succeeded.for.the.following=不過，以下{0,choice,1\\#版本庫|2\\#版本庫}的簽出已成功\\:
checkout.operation.in={1,choice,0\\#|1\\#{2}中的}{0}
checkout.operation.name=簽出
checkout.operation.previous.branch=上一個分支
checkout.operation.revision.not.found=在{0,choice,0\\#|1\\#{1}中}未找到修訂
checkout.operation.rollback.action=回滾
checkout.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滾(簽回 {0})以使分支不出現分叉。
cherry.pick.applied=套用
cherry.pick.name=優選
clone.dialog.checking.git.version=正在檢查 Git 版本…
clone.dialog.shallow.clone=淺層化克隆，歷史記錄被截斷為
clone.dialog.shallow.clone.depth=提交
column.name.commit.signature=GPG 簽名
combobox.item.file.invalid=(無效)
commit.action.commit.and.rebase.text=提交並重定基底…
commit.action.name=提交 (&I)
commit.author=作者(&U)\\:
commit.author.diffs=<html>作者與預設不同</html>
commit.author.with.committer={0}，通過 {1}
commit.check.warning.title.commit.during.rebase=正在版本庫中進行重定基底\\: {0}。在重定基底期間提交可能會導致提交丟失。
commit.check.warning.title.commit.during.rebase.details=有關 Git 重定基底的更多資訊
commit.check.warning.title.commit.with.detached.head=版本庫處於游離的 HEAD 狀態\\: {0}
commit.check.warning.title.commit.with.detached.head.details=有關游離的 HEAD 的更多資訊
commit.check.warning.title.large.file=您即將向版本庫提交一個大檔案\\: {0} 個{0,choice,1\\#檔案|2\\#檔案}，總大小為 {1}MB。\\n不建議在 Git 版本庫中存儲大檔案。請考慮使用 Git LFS。
commit.check.warning.user.name.email.not.set=未設定 Git user.name 和 user.email
commit.options.create.extra.commit.with.file.movements=使用檔案移動建立額外提交
commit.options.sign.off.commit.checkbox=Sign-off 提交(&G)
commit.options.sign.off.commit.message.line=在提交訊息結尾添加以下行\\:<br/>Signed-off by\\: {0}
commit.signature.bad=錯誤的 GPG 簽名
commit.signature.fingerprint=簽名指紋\\:
commit.signature.none=無 GPG 簽名
commit.signature.signed.by=通過密鑰簽名\\:
commit.signature.unverified=未驗證的 GPG 簽名
commit.signature.unverified.reason.cannot.verify=無法驗證(例如，缺少密鑰)
commit.signature.unverified.reason.expired=過期的簽名
commit.signature.unverified.reason.expired.key=使用過期的密鑰建立
commit.signature.unverified.reason.revoked.key=使用撤消的密鑰建立
commit.signature.unverified.reason.unknown=未知有效性
commit.signature.unverified.with.reason=未驗證的 GPG 簽名\\: {0}
commit.signature.verified=已驗證的 GPG 簽名
common.current.branch=當前分支\\:
common.current.branch.tooltip=當前已簽出的分支。
common.git.root=Git 根(&R)\\:
common.git.root.tooltip=選擇 Git VCS 根
common.local.branches=公共本地分支
common.no.active.branch=<無活動分支>
common.refreshing=正在重新整理檔案
common.remote.branches=公共遠端分支
common.suffix.in.one.repository=在 {0} 中
common.suffix.in.several.repositories=在 {0} 個版本庫中
common.tags=常用標籤
computing.annotation=正在計算 {0} 的註解
conflict.resolver.unmerged.files.check.error.notification.description.text=由於錯誤，無法檢查工作樹中是否有未合併的檔案。{0}
conflicts.accept.progress=正在解析 {0,choice,1\\#個衝突|2\\#個衝突}
conflicts.accept.theirs.action.text=接受他們的更改
conflicts.accept.yours.action.text=接受您的更改
conflicts.loading.status=正在載入合併衝突…
conflicts.merge.window.error.message=找不到 {0} 的檔案
conflicts.merge.window.error.title=無法解決衝突
conflicts.resolve.action.text=解決
conflicts.type.added.by.them=由他們新增
conflicts.type.added.by.you=由您新增
conflicts.type.both.added=均已新增
conflicts.type.both.deleted=均已刪除
conflicts.type.both.modified=均已修改
conflicts.type.deleted.by.them=由他們刪除
conflicts.type.deleted.by.you=由您刪除
convert.language.extra.commit.commit.message=將 .{0} 重命名為 .{1}
convert.language.extra.commit.description=.{0} > .{1} 重新命名的額外提交
create.branch.operation.branch.created=已建立分支 {0}
create.branch.operation.could.not.create.new.branch=無法建立新分支 {0}
create.branch.operation.deleted.branch=已刪除 {0}
create.branch.operation.error.during.rollback=回滾期間出錯
create.branch.operation.however.the.branch.was.created.in.the.following.repositories=不過，已在以下{0,choice,1\\#版本庫|2\\#版本庫}中建立分支\\:
create.branch.operation.name=建立分支
create.branch.operation.rollback.successful=回滾成功
create.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滾(刪除 {0})以使分支不出現分叉。
delete.branch.operation.branch.was.not.deleted.error=分支 {0} 未刪除
delete.branch.operation.collecting.unmerged.commits.process=正在收集未合併的提交…
delete.branch.operation.could.not.restore.branch.error=無法還原 {0}
delete.branch.operation.deleted.branch=已刪除分支 {0}
delete.branch.operation.deleted.branch.bold=<b>已刪除的分支\\:</b> {0}
delete.branch.operation.error.during.rollback.of.branch.deletion=分支刪除回滾期間出錯
delete.branch.operation.however.branch.deletion.has.succeeded.for.the.following=不過，以下{0,choice,1\\#版本庫|2\\#版本庫}的分支刪除已成功\\:
delete.branch.operation.name=分支刪除
delete.branch.operation.restoring.branch.process=正在還原分支 {0}…
delete.branch.operation.unmerged.commits.were.discarded=未合併的提交已被捨棄
delete.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滾(在這些根中重新建立 {0})以使分支不出現分叉。
delete.remote.branch.operation.also.deleted.local.branches=同時刪除了本地 {0,choice,1\\#分支|2\\#分支}\\: {1}
delete.remote.branch.operation.couldn.t.find.remote.by.name=無法按名稱尋找遠端\\: {0}
delete.remote.branch.operation.deleted.remote.branch=已刪除遠端分支 {0}
delete.remote.branch.operation.deleting.process=正在刪除 {0}
delete.remote.branch.operation.failed.to.delete.remote.branch=無法刪除遠端分支 {0}
delete.remote.tag.operation.deleted.tag.on.remotes=<b>已刪除{0,choice,1\\#遠端|2\\#遠端}上的標記\\:</b> {1}
delete.remote.tag.operation.failed.to.delete.tag.on.remotes=無法刪除 {1,choice,1\\#遠端|2\\#遠端} 上的標記 {0}
delete.remote.tag.operation.tag.does.not.exist.on.remotes=<b>標記在{0,choice,1\\#遠端|2\\#遠端}上不存在\\:</b> {1}
delete.tag.operation.could.not.find.tag=找不到標記 {0}
delete.tag.operation.could.not.find.tag.in=在 {0} 中找不到標記
delete.tag.operation.could.not.restore.tag=無法還原 {0}
delete.tag.operation.delete.on.remote=在{0,choice,1\\#遠端|2\\#遠端}上刪除
delete.tag.operation.deleted.tag=<b>已刪除的標記\\:</b> {0}
delete.tag.operation.error.during.rollback.of.tag.deletion=標記刪除回滾期間出錯
delete.tag.operation.however.tag.deletion.has.succeeded.for.the.following=不過，以下{0,choice,1\\#版本庫|2\\#版本庫}的標籤刪除已成功\\:
delete.tag.operation.restored.tag=已還原標記 {0}
delete.tag.operation.restoring.tag.process=正在還原標記 {0}…
delete.tag.operation.rollback.successful=回滾成功
delete.tag.operation.tag.was.not.deleted=未刪除標記 {0}
delete.tag.operation.you.may.rollback.not.to.let.tags.diverge=您可以回滾(在這些根中重新建立 {0})以使標記不出現分叉。
dialog.message.rebasing.merge.commits=您即將重定基底存在衝突的合併提交。\\n\\n如果您不想再次解決衝突，請選擇“合併”; 如果要將歷史記錄線性化，仍可進行重定基底。
dialog.message.untracked.files.will.be.overwritten.by.operation=這些未追蹤的檔案將被{0}覆蓋
dialog.message.update.branch=您即將從 {1} 更新 {0}。\\n\\n如果要建立合併提交，請選擇“合併”；如果要重定基底到 {1}，請選擇“重定基底”。
dialog.title.could.not.operation=無法{0}
dialog.title.local.changes.prevent.from.operation=本地更改阻止{0}
dialog.title.rebasing.merge.commits=正在重定基底合併提交
dialog.title.untracked.files.preventing.operation=阻止{0}的未追蹤檔案
dialog.title.update.branch=更新 {0}
diff.find.error=正在尋找差異的修訂\\: {0}
editor.promo.close.link=不再顯示
editor.promo.commit.text=使用提交接口直接從 {0} 提交。
editor.promo.commit.try.link=嘗試
editor.promo.help.link=了解詳情
error.cannot.delete.file=無法刪除檔案\\: {0}
error.cant.set.user.name.email=無法設定 user.name 和 user.email
error.commit.cant.collect.partial.changes=無法收集要提交的部分更改
error.commit.cant.commit.multiple.changelists=無法一次提交多個更改列表中的更改
error.commit.cant.commit.with.unmerged.paths=由於您有未合併的檔案，因此無法提交。
error.commit.cant.create.message.file=建立提交訊息檔案失敗
error.dialog.title=錯誤
error.git.parse.not.a.revision.number=字串 ''{0}'' 不表示修訂號
error.git.parse.unknown.file.status=未知檔案狀態\\: {0}
error.git.repository.not.found=該版本庫不再存在\\: {0}
error.git.version.check.failed=執行 ''git --version'' 時出錯。離開程式碼\\: {0}，錯誤\\: {1}
error.list.title={0} 錯誤\\:
error.no.changed.files.no.commit.message=修改要提交的檔案並指定提交訊息
error.no.changed.files.to.commit=修改要提交的檔案
error.no.selected.roots.to.commit=選擇要提交的根
error.no.staged.changes.no.commit.message=暫存要提交的檔案並指定提交訊息
error.no.staged.changes.to.commit=暫存要提交的檔案
error.occurred.during=''{0}'' 時出錯
error.unresolved.conflicts=解決衝突以提交
errors.message=Git 動作以多個錯誤結束\\: {0}
errors.message.item=\\n{0}
exception.message.could.not.stash.root.error=無法隱藏 {0}\\: {1}
executable.error.git.not.installed=未安裝 Git
executable.mac.error.invalid.path.to.command.line.tools=Command Line Tools 的路徑無效
executable.mac.fix.path.action=修正路徑
exportable.Git.Application.Settings.presentable.name=Git
fetch.action.name=獲取
fetch.pruned.obsolete.remote.references=刪除過時的遠端 {0,choice,1\\#參照|2\\#參照}\\: {1}
fetching=正在獲取…
find.git.error.title=執行 Git 時出錯
find.git.success.title=Git 執行成功
find.git.unsupported.message=<html><tt>{0}</tt><br>此版本不受支援，某些延伸模組功能可能無法工作。<br>支援的最低版本是 <em>{1}</em>。</html>
git.add.to.exclude.file.action.description=將條目新增到 .git/info/exclude
git.add.to.exclude.file.action.text=.git/info/exclude
git.branches.popup.loading.tags=正在載入 Git 標籤…
git.branches.popup.search.field.actions.empty.text={0,choice,1\\#和|2\\#、}動作
git.branches.popup.search.field.empty.text=搜尋分支{0}{1}
git.branches.popup.search.field.repositories.empty.text={0,choice,1\\#和|2\\#、}版本庫
git.branches.popup.tree.accessible.name=分支樹
git.branches.popup.tree.no.branches=找不到分支 ''{0}''
git.branches.popup.tree.no.nodes=找不到 ''{0}''
git.commit.message.empty.title=提交訊息為空
git.commit.nothing.to.commit.error.message=沒有要提交的內容
git.compare.branches.empty.status={0} 包含來自 {1} 的所有提交
git.compare.branches.explanation.message=存在於 {0} 中但不存在於 {1} 中的提交
git.compare.branches.tab.name=比較
git.compare.branches.tab.suffix={0} 和 {1}
git.compare.with.branch.search.field.empty.text=搜尋分支{0,choice,0\\#|1\\#和標籤}
git.compare.with.branch.search.not.found=找不到 ''{0}''
git.compare.with.tag.file.not.found.in.tag=標記 ''{2}'' 中不存在{0,choice,1\\#檔案|2\\#目錄} {1}
git.compare.with.tag.loading.error.title=無法載入標記
git.compare.with.tag.modal.progress.loading.tags=正在載入標記…
git.compare.with.tag.popup.title=選擇要比較的標記
git.content.transform.filters=篩選器
git.content.transform.none=無
git.content.transform.textconv=TextConv
git.error.cant.process.output=無法處理 Git 輸出\\: {0}
git.error.exit=Git 程序離開，程式碼為 {0}
git.executable.detect.progress.title=正在檢測 Git 可執行檔案
git.executable.error.bash.not.found=找不到 bash 可執行檔案
git.executable.error.file.not.found=沒有此類別檔案\\: {0}
git.executable.new.version.update.available=更新為 Git {0}
git.executable.notification.cant.run.in.safe.mode=無法在安全模式下執行 Git 指令
git.executable.notification.description=Git 可執行檔案的路徑可能無效。
git.executable.notification.title=無法啟動 Git
git.executable.unknown.error.message=無法啟動 Git 程序\\: {0}
git.executable.validation.cant.identify.executable.message=無法識別 Git 可執行檔案 {0} 的版本
git.executable.validation.cant.run.in.safe.mode=無法在安全模式下執行 Git 指令
git.executable.validation.error.no.response.in.n.attempts.message=無法識別 Git 可執行檔案的版本\\: {0,choice,0\\#|2\\# {0} 次嘗試後}無響應
git.executable.validation.error.start.title=無法執行 Git
git.executable.validation.error.version.message=至少需要 {0}
git.executable.validation.error.version.title=Git 版本 {0} 不受支援
git.executable.validation.error.wsl.start.title=無法在 WSL 中執行 Git
git.executable.validation.error.wsl1.unsupported.message=不支持 WSL 版本 1，請參閱 <a href\\='https\\://youtrack.jetbrains.com/issue/IDEA-242469'>IDEA-242469</a> 了解可能的解決方案。
git.executable.validation.error.xcode.message=執行“sudo xcodebuild -license”並重試(需要管理員權限)
git.executable.validation.error.xcode.title=接受 XCode/iOS 授權以執行 Git
git.executable.version.is=Git 版本為 {0}
git.executable.version.progress.title=正在識別 Git 版本
git.fetch.progress=正在獲取…
git.history.diff.handler.choose.parent.popup=選擇要比較的父項
git.history.diff.handler.git.show.error=執行 git show {0}\\:{1} 時出錯
git.history.diff.handler.load.changes.process=正在載入更改…
git.history.diff.handler.no.changes.in.file.info=此合併提交中的檔案 {0} 無更改
git.integration.could.not.git.init=無法 git init {0}
git.integration.created.git.repository.in=已在 {0} 中建立 Git 版本庫
git.light.cant.find.current.revision.exception.message=找不到 {0} 的當前修訂
git.light.status.bar.display.name=Git
git.light.status.bar.text=Git\\: {0}
git.light.status.bar.tooltip=當前 Git 分支\\: {0}
git.log.action.checkout.group=簽出
git.log.action.checkout.revision.full.text=簽出修訂 ''{0}''
git.log.action.checkout.revision.short.text=修訂 ''{0}''
git.log.branches.search.field.accessible.description=按 {0} 轉到 VCS 日誌表篩選器
git.log.branches.search.field.accessible.name=Git 分支搜尋
git.log.branches.tree.accessible.name=Git 分支
git.log.cherry.picked.highlighter.cancelled.message=已取消對 ''{0}'' 中未選取提交的醒目提示，因為分支篩選器已被更改。
git.log.cherry.picked.highlighter.error.message=無法與分支 {0} 進行比較
git.log.cherry.picked.highlighter.process=正在比較分支…
git.log.cherry.picked.highlighter.select.branch.popup=選擇源分支
git.log.diff.handler.changes.between.revisions.in.paths.title={2} 中 {0} 與 {1} 之間的更改
git.log.diff.handler.changes.between.revisions.title={0} 與 {1} 之間的更改
git.log.diff.handler.local.version.content.title=本地
git.log.diff.handler.local.version.name=本地版本
git.log.external.loading.process=正在載入 Git 日誌…
git.log.external.tab.description={0} 的日誌
git.log.external.window.title=Git 日誌
git.log.refGroup.local=本地
git.log.show.commit.in.log.process=正在搜尋修訂 {0}
git.new.tag.dialog.tag.name.label=輸入新標記的名稱
git.new.tag.dialog.title=在 {0}上建立新標記
git.open.exclude.file.action.description=在編輯器中開啟 .git/info/exclude
git.open.exclude.file.action.text=開啟 .git/info/exclude
git.recent.projects.show.branch.mode.always=所有專案
git.recent.projects.show.branch.mode.for.duplicate.names=同名專案
git.recent.projects.show.branch.mode.never=從不
git.rename.branch.could.not.rename.from.to=無法將 {0} 重命名為 {1}
git.rename.branch.could.not.unset.upstream=無法取消設定分支 {0} 的上游
git.rename.branch.has.succeeded.for.the.following.repositories=不過，以下{0,choice,1\\#版本庫|2\\#版本庫}的重新命名已成功\\:
git.rename.branch.renamed.back.to=已重新命名回 {0}
git.rename.branch.rollback.failed=回滾失敗
git.rename.branch.rollback.successful=回滾成功
git.rename.branch.was.renamed.to=分支 {0} 已被重命名為 {1}
git.rename.branch.you.may.rename.branch.back=您可以回滾(將分支重新命名回 {0})以使分支不出現分叉。
git.reset.button=重設
git.reset.dialog.description=<nobr>這會將當前分支 HEAD 重設為所選提交，<nobr/><br><nobr>並根據所選模式更新工作樹和索引\\:<nobr/>
git.reset.dialog.description.commit.details.by.author={0}，作者 {1}
git.reset.dialog.description.source.in.repository={0} ({1} 內)
git.reset.dialog.title=Git 重設
git.reset.failed.notification.title=重設失敗
git.reset.hard.button=硬重設(&H)
git.reset.mode.hard=硬
git.reset.mode.hard.description=<nobr>檔案將還原為所選提交的狀態。<nobr/><br><nobr>警告\\: 任何本地更改都將丟失。<nobr/>
git.reset.mode.keep=保留
git.reset.mode.keep.description=<nobr>檔案將還原為所選提交的狀態，<nobr/><br><nobr>但本地更改將保持不變。<nobr/>
git.reset.mode.mixed=混合
git.reset.mode.mixed.description=檔案不會更改，差異也不進行暫存。
git.reset.mode.soft=軟
git.reset.mode.soft.description=檔案不會更改，差異將暫存以進行提交。
git.reset.operation=重設
git.reset.partially.failed.notification.msg={0} 重設成功\\n但 {1} 重設失敗\\:\\n{2}
git.reset.partially.failed.notification.title=重設部分失敗
git.reset.process=Git 重設
git.reset.successful.notification.message=重設成功
git.rollback=回滾(&R)
git.running=執行\\: {0}
git.status.bar.widget.name=Git 分支
git.status.bar.widget.text.cherry.pick=正在 {0} 中優選
git.status.bar.widget.text.merge=正在合併 {0}
git.status.bar.widget.text.rebase=正在重定基底 {0}
git.status.bar.widget.text.revert=正在 {0} 中還原
git.status.bar.widget.text.unknown=<未知>
git.status.bar.widget.tooltip.detached=Git\\: 游離的 HEAD 不指向任何分支
git.status.bar.widget.tooltip.rebasing=Git\\: 正在進行重定基底
git.status.copied=已複製
git.status.index=在暫存區域中{0}
git.status.not.changed=未更改
git.status.renamed=已重新命名
git.status.type.changed=已更改類型
git.status.unmerged=已取消合併
git.status.unmerged.both=兩者{0}
git.status.unmerged.index=我們{0}
git.status.unmerged.work.tree=由他人{0}
git.status.untracked=已取消追蹤
git.status.work.tree=在工作目錄中{0}
git.tag.could.not.create.tag=無法建立標記
git.tag.created.tag.successfully=已成功建立標記 {0}。
git.toolbar.widget.no.loaded.repo=Git
git.toolbar.widget.no.repo=版本控制
git.toolbar.widget.no.repo.tooltip=為專案組態版本控制
git.undo.action.cant.undo.commit.failure=無法撤消提交
git.undo.action.could.not.load.changes.of.commit=無法載入 {0} 的更改
git.undo.action.description=所選提交不是當前分支中的最後一次提交
git.undo.action.failed.notification.title=撤消提交失敗
git.undo.action.operation=撤消提交
git.undo.action.refreshing.changes.process=正在重新整理更改…
git.undo.action.select.target.changelist.title=選擇目標更改列表
git.undo.action.successful.notification.message=撤消提交成功
git.undo.action.undoing.last.commit.process=正在撤消最後一次提交…
git.update.commits.matching.filters={0,choice,1\\#{0} 個提交|2\\#{0} 個提交}與篩選器匹配
git.update.files.updated.in.commits=已更新 {1,choice,1\\#{1} 個提交|2\\#{1} 個提交}中的 {0,choice,1\\#{0} 個檔案|2\\#{0} 個檔案}
git.update.no.commits.matching.filters=沒有與篩選器符合的提交
git.update.operation=更新
git.update.project.partially.updated.title=專案已部分更新
git.update.repo.was.skipped=已跳過 {0} ({1})
git.update.skipped.repositories=已跳過 {0} 個版本庫\\:
git4idea.vcs.name=Git
git4idea.vcs.name.with.mnemonic=Git(_G)
gpg.error.see.documentation.link.text=參閱 GPG 設定指南
gpg.error.text=提交簽名失敗
gpg.jb.manual.link=Set_up_GPG_commit_signing
gpg.pinentry.agent.configuration.configuration.backup.exception=無法建立組態備份
gpg.pinentry.agent.configuration.confirmation.text=GPG 代理將被組態為使用 {0} 內建 pinentry 程序。<br/><br/>如果 {0} 未處於有效狀態，將使用當前組態的 pinentry 程序\\: <tt>{1}</tt>
gpg.pinentry.agent.configuration.confirmation.title=更新 GPG 代理組態
gpg.pinentry.agent.configuration.confirmation.yes=更新
gpg.pinentry.agent.configuration.detect.default.pinentry.exception=無法檢測 pinentry 程序
gpg.pinentry.agent.configuration.exception=無法更新 GPG 組態\\: {0}
gpg.pinentry.agent.configuration.launcher.generation.exception=無法生成 pinentry 啟動器
gpg.pinentry.agent.configuration.read.exception=無法讀取 GPG 組態
gpg.pinentry.agent.configuration.save.exception=無法儲存更新的 GPG 組態
gpg.pinentry.configuration.error.title=GPG 代理組態失敗
gpg.pinentry.configuration.global.suggestion.do.not.ask.again.display.name=GPG 代理組態(建議)
gpg.pinentry.configuration.proposal.configure=組態…
gpg.pinentry.configuration.proposal.message=要{0,choice,0\\#在遠端主機上|1\\#在 WSL 中|2\\#}支援 GPG 提交簽名，請將 GPG 代理組態為使用 {1} 內建 pinentry 程序
gpg.pinentry.configuration.proposal.title=GPG 代理組態
gpg.pinentry.configuration.suggestion.do.not.ask.again.display.name=GPG 代理組態(無效提交後的建議)
gpg.pinentry.configured.successfully.backup.message=已在 <code>{0}</code> 中建立現有組態的備份
gpg.pinentry.configured.successfully.message=GPG 代理組態已在 <code>{0}</code> 中更新
gpg.pinentry.configured.successfully.title=GPG 代理組態成功
gpg.pinentry.default.description=請輸入密碼短語以解鎖 GPG 私鑰\\:
gpg.pinentry.jb.manual.link=Set_up_GPG_pinentry_for_commit_signing
gpg.pinentry.title=解鎖 GPG 私鑰
group.Git.Branch.Tracked.name=追蹤分支動作
group.Git.Branch.Tracked.name.withBranch=追蹤分支 ''{0}''
group.Git.CheckoutGroup.description=簽出所選修訂或所選提交中的分支
group.Git.CheckoutGroup.text=簽出
group.Git.ContextMenu.text=Git(_G)
group.Git.HEAD.Branch.Filter.title=HEAD(當前分支)
group.Git.Local.Branch.title=本地
group.Git.Log.Branches.Grouping.Settings.text=分組依據
group.Git.Log.Branches.Settings.Separator.text=點擊時
group.Git.Log.Branches.Settings.text=分支窗格設定
group.Git.Log.ShareLogIndexData.text=共享 Git 日誌索引資料
group.Git.MainMenu.LocalChanges.text=未提交的更改(_U)
group.Git.MainMenu.MergeActions.text=合併(_M)
group.Git.MainMenu.RebaseActions.text=重定基底(_R)
group.Git.Menu.text=Git(_G)
group.Git.Recent.Branch.in.repo.title={0} 中最近的分支
group.Git.Recent.Branch.title=最近
group.Git.Remote.Branch.title=遠端
group.Git.Stage.Configure.text=組態本地更改
group.Git.Stage.Index.File.Menu.text=Git
group.Git.Stage.Ui.Settings.text=檢視選項
group.Git.Tags.loading.text=正在載入…
group.Git.Tags.title=標籤
group.MainToolbarVCSGroup.text=VCS 組
group.Vcs.ToolbarWidget.ShareProject.text=在以下平台上共享專案\\:
history.filters.unsupported.error.message=不支持按“{0}”篩選歷史記錄
history.for.revision.filters.unsupported.error.message=不支持按“{0}”篩選修訂歷史記錄
in.branches.all.repositories=在所有版本庫中
in.memory.rebase.data.contains.empty.reword.message.for.entry=記憶體中重定基底資料包含條目的空改寫訊息\\: {0}
in.memory.rebase.data.contains.entry.with.unsupported.action=記憶體中重定基底資料包含具有不受支援動作的條目\\: {0}
in.memory.rebase.data.contains.missing.reword.message.for.entry=記憶體中重定基底資料包含條目缺失的改寫訊息\\: {0}
in.memory.rebase.fail.head.move=在提交編輯動作期間 HEAD 發生移動
in.memory.rebase.failed.rebase.data=無法生成有效的記憶體中重定基底資料
in.memory.rebase.interactive.failed.message=正在回退到一般重定基底
in.memory.rebase.interactive.failed.title=記憶體中重定基底失敗
in.memory.rebase.log.change.extract.action.progress.indicator.title=正在獲取更改…
in.memory.rebase.log.changes.action.operation.extract.name=獲取所選更改
in.memory.rebase.log.changes.extract.action.description.all.changes.selected=無法從提交中獲取所有更改
in.memory.rebase.log.changes.extract.action.failure.title=無法獲取所選更改
in.memory.rebase.log.changes.extract.action.notification.successful.title=已獲取的更改
in.memory.rebase.log.changes.extract.action.notification.undo.failed.title=撤消獲取更改失敗
in.memory.rebase.log.changes.extract.action.notification.undo.not.allowed.title=無法撤消獲取更改
in.memory.rebase.log.changes.extract.action.progress.indicator.undo.title=正在撤消獲取更改…
in.memory.rebase.log.changes.extract.dialog.description.label=由 {1} 從提交 {0} 中獲取的更改
in.memory.rebase.log.changes.extract.dialog.title=新的提交訊息
in.memory.rebase.log.changes.extract.failed.title=無法獲取所選更改
in.memory.rebase.log.interactive.action.notification.successful=重定基底成功
in.memory.rebase.log.interactive.action.notification.undo.failed.title=撤消互動重定基底失敗
in.memory.rebase.log.interactive.action.notification.undo.not.allowed.title=無法撤消互動重定基底
in.memory.rebase.log.interactive.action.progress.indicator.undo.title=正在撤消互動重定基底…
in.memory.rebase.log.interactive.failed.title=互動重定基底失敗
in.memory.rebase.log.reword.failed.title=改寫失敗
in.memory.rebase.log.squash.failed.title=壓縮失敗
in.memory.split.tree.mixed.error=無法獲取所選更改
in.memory.split.tree.submodules.error=不支持通過 git 子模組條目拆分樹
init.destination.directory.description=選擇將在其中建立新 Git 版本庫的目錄。
init.destination.directory.title=建立 Git 版本庫
init.warning.already.under.git=所選目錄 <tt>{0}</tt> 已在 Git 下。\\n確定要建立新的 VCS 根嗎?
init.warning.title=Git Init
initializing.title=正在初始化版本庫…
install.download.and.install.action=下載並安裝
install.downloading.progress=正在下載…
install.general.error=無法安裝 Git
install.installing.progress=正在安裝…
install.mac.error.couldnt.start.command.line.tools=無法啟動 Command Line Tools 安裝
install.mac.requesting.command.line.tools=正在請求 XCode Command Line Developer Tools
install.success.message=已安裝 Git
label.changes.excluded.from.commit.are.you.sure.want.to.continue=確定要從合併提交中排除這些更改過的檔案嗎?
label.credential.store.key.http.password=Git HTTP
label.diff.content.title.submodule.suffix={0} (子模組)
label.name.email.not.defined.in.n.roots={0,choice,1\\#根|2\\#根}中未定義 Git 的 user.name 和 user.email 屬性
label.user.email=電子郵件(&E)\\:
label.user.name=名稱(&N)\\:
link.label.commit.with.detached.head.read.more=閱讀有關游離的 HEAD 的更多資訊
link.label.commit.with.unfinished.rebase.read.more=閱讀有關 Git 重定基底的更多資訊
link.label.editor.notification.merge.conflicts.resolve.in.progress=正在解決合併衝突
link.label.editor.notification.merge.conflicts.suggest.resolve=檔案存在未解決的合併衝突
link.label.merge.conflicts.resolve.in.progress.cancel.resolve=取消解決
link.label.merge.conflicts.resolve.in.progress.focus.window=顯示解析衝突視窗
link.label.merge.conflicts.suggest.resolve.show.window=解決衝突…
local.changes.freeze.message.git.operation.prefix=Git {0}
local.changes.save.policy.shelve=擱置
local.changes.save.policy.stash=隱藏
local.changes.would.be.overwritten.by.merge.view.them.action=檢視這些變更
log.command.empty.text=[<options>] [<revision-range>] [[--] <path>...]
log.parser.exception.message.could.not.parse.output=無法解析 Git 日誌輸出“{0}”
log.parser.exception.message.error.command.line={0}\\n命令行\\: [{1}]
log.parser.exception.message.error.parsing.line=解析第“{0}”行時出錯
login.dialog.button.login=登入
login.dialog.error.password.cant.be.empty=密碼不能為空
login.dialog.error.username.cant.be.empty=用戶名不能為空
login.dialog.label.login.to.url=登入 {0}
login.dialog.login.with.selected.provider=使用 {0} 登入…
login.dialog.password.label=密碼\\:
login.dialog.prompt.enter.credentials=輸入憑證\\:
login.dialog.select.login.way.credentials=輸入憑證
login.dialog.select.login.way.use.helper=使用憑證幫助程序
login.dialog.username.label=用戶名\\:
mention.in=\\ ({0} 中)
merge.action.after.update.label=更新後
merge.action.before.update.label=更新前
merge.action.name=合併
merge.action.operation.failed=Git {0} 失敗
merge.branch.already.merged=分支 ''{0}'' 已被合併
merge.branch.field.placeholder=指定分支
merge.branch.into.current.title=合併到 {0}
merge.branch.loading.branches.progress=正在載入未合併的分支…
merge.branch.popup.empty.text=無分支
merge.branch.title=合併更改
merge.commit.message.label=提交訊息\\:
merge.dialog.customizer.collecting.details.progress=正在收集提交詳細資訊…
merge.dialog.customizer.filter.by.conflicted.file.checkbox=按衝突檔案篩選
merge.dialog.customizer.show.details.link.label=顯示詳細資訊
merge.dialog.description.cherry.pick.label.text=在優選{2,choice,0\\#|1\\#由 {3}{4} 執行的}{0,choice,1\\#提交 {1}|2\\#多個提交}期間出現衝突
merge.dialog.description.merge.label.text=將{0,choice,1\\#分支 {1} |2\\#分叉的分支}合併到{2,choice,1\\#分支 {3}|2\\#分叉的分支}
merge.dialog.description.rebase.conflict.current.commit=當前提交 {0} 由 {1} 完成\\:
merge.dialog.description.rebase.with.hash.label.text=正在{0,choice,0\\#|1\\#將分支 {1} }變基到 {2}
merge.dialog.description.rebase.with.onto.branch.label.text=正在{0,choice,0\\#|1\\#將分支 {1} }重定基底到分支 {2}{3,choice,0\\#|1\\#，修訂 {4}}
merge.dialog.description.rebase.without.onto.info.label.text=正在{0,choice,0\\#|1\\#將分支 {1} }重定基底到分叉的分支
merge.dialog.diff.left.title.cherry.pick.label.text=本地更改
merge.dialog.diff.left.title.default.branch.label.text=您的版本，分支 {0}
merge.dialog.diff.left.title.rebase.label.text=正在從 {1} 重定基底 {0}
merge.dialog.diff.right.title.cherry.pick.label.text=來自優選 {0} 的更改
merge.dialog.diff.right.title.default.with.hash.label.text=來自 {0} 的更改
merge.dialog.diff.right.title.default.with.onto.branch.label.text=來自分支 {0}{1,choice,0\\#|1\\#，修訂 {2}} 的更改
merge.dialog.diff.right.title.default.without.onto.info.label.text=來自分叉分支的更改
merge.dialog.diff.right.title.rebase.with.branch.label.text=已重定基底的提交和來自 {0} 的提交
merge.dialog.diff.right.title.rebase.without.branch.label.text=已重定基底的提交
merge.dialog.diff.title.changes.from.branch.label.text=來自 {0} 的更改
merge.error.unable.to.read.merge.head=無法讀取檔案 {0}\\: {1}
merge.no.branch.selected.error=應選擇該合併分支。
merge.no.matching.branch.error=沒有符合分支。
merge.operation.already.up.to.date=已處於最新狀態
merge.operation.branch.merged.with.conflicts={0} 已合併，但存在衝突
merge.operation.could.not.merge.branch=無法合併 {0}
merge.operation.delete.branch.action=刪除 {0}
merge.operation.error.during.rollback=回滾期間出錯
merge.operation.however.merge.has.succeeded.for.the.following.repositories=不過，以下{0,choice,1\\#版本庫|2\\#版本庫}的合併已成功\\:
merge.operation.merged.to=已將 {0} 合併到 {1}
merge.operation.name=合併
merge.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滾(重設為合併之前的提交)以使分支不出現分叉。
merge.option.allow.unrelated.histories=允許合併不具有共同上級的歷史記錄
merge.option.ff.only=僅在可以快進時合併
merge.option.msg=指定合併提交的訊息
merge.option.no.commit=不提交合併結果
merge.option.no.ff=即使可以快進也建立合併提交
merge.option.no.verify=繞過預合併和提交訊息掛鈎
merge.option.squash=為所有合併更改建立一個提交
merge.options.modify=修改選項
merge.options.modify.popup.title=新增合併選項
merge.progress.indicator.loading.unmerged.files.title=正在載入未合併的檔案…
merge.tool.column.status.deleted=已刪除
merge.tool.column.status.modified=已修改
merge.tool.column.theirs.status=他人的更改
merge.tool.column.theirs.with.branch.status=他人的更改({0})
merge.tool.column.yours.status=您的更改
merge.tool.column.yours.with.branch.status=您的更改({0})
merge.unresolved.conflicts.remaining.notification.body=有掛起的未解決的衝突。
merge.unresolved.conflicts.remaining.notification.title=正在掛起未解決的衝突
merge.update.project.conflict.merge.description.label=檢測到合併衝突。請先解決這些衝突，然後再繼續更新。
merge.update.project.generic.error.title=無法完成更新
merging.title=將更改合併到 {0}
message.unresolved.conflicts.prevent.commit=由於有未解決的衝突，無法提交更改。
modal.commit.deprecation.notification.description=模態提交模式已移至一個將在 {0} {1} 中解綁的延伸模組
new.branch.dialog.branch.name=分支名稱\\:
new.branch.dialog.branch.root.all.name=所有
new.branch.dialog.branch.root.all.override.warning=根將位於不同的分支上。某些分支動作不會同時在所有根上執行。
new.branch.dialog.branch.root.name=根\\:
new.branch.dialog.checkout.branch.checkbox=簽出分支(&C)
new.branch.dialog.error.branch.already.exists=分支名稱 {0} 已存在
new.branch.dialog.error.branch.clashes.with.directory=分支名稱 {0} 與同名的本地分支目錄衝突
new.branch.dialog.error.branch.clashes.with.remote=分支名稱 {0} 與同名的遠端分支衝突
new.branch.dialog.error.branch.name.empty=指定新分支的名稱
new.branch.dialog.error.branch.name.head=HEAD 是保留關鍵字
new.branch.dialog.error.branch.name.invalid=分支名稱 {0} 無效
new.branch.dialog.operation.checkout.description=簽出現有分支，並在其他版本庫中建立新分支
new.branch.dialog.operation.checkout.name=簽出
new.branch.dialog.operation.create.description=在其他版本庫中建立新分支
new.branch.dialog.operation.create.name=建立
new.branch.dialog.operation.rename.name=重新命名
new.branch.dialog.overwrite.existing.branch.checkbox=覆蓋現有分支(&R)
new.branch.dialog.overwrite.existing.branch.warning=更改名稱或覆蓋現有分支
new.branch.dialog.set.tracking.branch.checkbox=設定追蹤分支(&T)
new.branch.dialog.unset.upstream.branch.checkbox=取消設定上游分支(&T)
no.revisions.available=無修訂
notification.content.branch.in.repo.has.no.tracked.branch={0} {1} 沒有追蹤的分支
notification.content.couldn.t.authorize=授權錯誤
notification.content.couldnt.collect.updated.files.info={0} 更新成功，但由於發生了一個錯誤，我們無法收集更新的更改
notification.content.detached.state.in.root.checkout.branch=您處於“游離的 HEAD”狀態，這表明您不在任何分支 {0} 上<br/>簽出分支以更新專案。
notification.content.fetch.failed.couldn.t.authorize=獲取失敗\\: 授權錯誤
notification.content.fetched.successfully=已成功獲取
notification.content.untracked.files.prevent.operation.move.or.commit=在 {0} 前移動或提交<br/>{1}
notification.content.updating.root.failed.with.error=更新 {0} 失敗，出現錯誤\\: {1}
notification.ignore.file.generation.error.text.files.progress.title=無法生成 .gitignore 檔案
notification.title.can.t.update.no.current.branch=無法更新\\: 無當前分支
notification.title.couldn.t.reset.merge=無法中止合併動作
notification.title.couldnt.collect.updated.files.info=無法收集已更新檔案的資訊
notification.title.error.merging=合併錯誤
notification.title.error.updating.root=更新 {0} 期間出錯
notification.title.fetch.details=獲取詳細資訊
notification.title.fetch.failed=獲取失敗
notification.title.fetch.failure=獲取失敗
notification.title.fetch.success=獲取成功
notification.title.git.operation.failed=Git {0} 失敗
notification.title.unstash.failed=取消隱藏失敗
notification.title.unstash.failed.index.conflict=由於索引衝突，取消隱藏失敗
notification.title.untracked.files.prevent.operation=未追蹤的檔案會阻止{0}
notification.title.update.failed=更新失敗
open.in.browser.error=無法在瀏覽器中開啟
open.in.browser.getting.revision=正在獲取最新的檔案修訂
open.in.browser.getting.revision.error=無法檢索檔案的最新修訂
operation.action.message=多個 Git 根有未完成的 {0} 程序，請選擇要對其執行動作的根。
operation.name.loading.revision=載入修訂
operation.name.validating.revision.0=驗證修訂 {0}
output.parse.exception.unexpected.end.message=文本在 ''{0}'' 意外結束
paths.affected.title=提交 {0} 中受影響的路徑
post.commit.check.load.changes.error=無法為 {1} 載入根 {0} 中的更改
preserving.process.local.changes.not.restored.error.title=未還原本地更改
progress.checking.line.separator.issues=正在檢查行分隔符問題…
progress.details.refreshing.files.for.root=正在重新整理根 {0} 的檔案
progress.finishing.conflict.resolve=正在解決衝突
progress.setting.config.value=正在更新 Git 組態…
progress.setting.user.name.email=正在設定 Git 用戶名…
progress.text.merging.repository=正在合併 {0}…
progress.title.calculating.commit.messages=正在計算提交訊息
progress.title.creating.git.repository=正在建立 Git 版本庫…
progress.title.enabling.git=正在啟用 Git…
progress.title.moving.files=正在移動檔案…
progress.title.reverting.n.commits=正在還原{0,choice,1\\#提交|2\\#提交}
progress.title.update=更新
progress.title.validating.revision=正在驗證修訂…
progress.update.destination.remote=遠端
pull.action.name=拉取
pull.branch.field.placeholder=指定分支
pull.branch.no.matching.remotes=無遠端
pull.branch.not.selected.error=應選擇要從中拉取的分支。
pull.branch.nothing.to.pull=無分支
pull.button=拉取
pull.dialog.fetch.shortcuts.hint=按 {0} 更新分支
pull.dialog.title=拉取
pull.dialog.with.branch.title=拉取到 {0}
pull.fetch.failed.notification.text=選擇一個本地版本庫和一個遠端版本庫
pull.fetch.failed.notification.title=無法載入遠端分支
pull.option.ff.only=僅在可以快進時合併
pull.option.no.commit=合併，但不提交結果
pull.option.no.ff=即使可以快進也建立合併提交
pull.option.rebase=在傳入更改上重定基底當前分支
pull.option.squash.commit=為所有拉取更改建立一個提交
pull.options.modify.popup.title=新增拉取選項
pull.remote.not.selected=選擇要從中拉取的遠端版本庫
pull.repository.not.selected.error=選擇一個版本庫
pulling.title=從 {0} 中拉取更改
push.dialog.preview.commits.before.push=對於向不受保護分支的提交和推送，應在推送之前預覽提交
push.dialog.prohibited.branch.configurable.path={0} | 版本控制 | Git
push.dialog.push.tags=推送標記(&T)
push.dialog.push.tags.combo.all=所有
push.dialog.push.tags.combo.current.branch=當前分支
push.dialog.target.panel.add.remote=新增遠端
push.dialog.target.panel.adding.remote=正在新增遠端…
push.dialog.target.panel.can.t.push=無法推送
push.dialog.target.panel.couldnt.add.remote=無法新增遠端\\: {0}
push.dialog.target.panel.define.remote=定義遠端
push.dialog.target.panel.empty.repository=空版本庫
push.dialog.target.panel.new=新增
push.dialog.target.panel.new.and.upstream=新增和上游
push.dialog.target.panel.upstream.checkbox=設定上游
push.dialog.target.panel.upstream.label=上游
push.failed.error.message=推送失敗\\: {0}
push.local.history.system.label.after=推送後
push.local.history.system.label.before=推送前
push.notification.description.force.pushed=強制推送 {0} 到 {1}
push.notification.description.new.branch=已推送 {0} 到新分支 {1}
push.notification.description.new.branch.with.many.tags=推送 {0} 到新分支 {1}，並將 {2} 標籤到 {3}
push.notification.description.new.branch.with.single.tag=推送 {0} 到新分支 {1}，並將 {2} 標籤到 {3}
push.notification.description.push.with.lease.rejected=使用 Force-with-lease 推送 {0} 到 {1} 被拒
push.notification.description.pushed=已將 {0} 個{0,choice,1\\#提交|2\\#提交} 推送到 {1}
push.notification.description.pushed.many.tags=已推送 {0} 標籤到 {1}
push.notification.description.pushed.single.tag=已推送標籤 {0} 到 {1}
push.notification.description.pushed.with.many.tags=已將 {0} 個{0,choice,1\\#提交|2\\#提交} 推送到 {1}，將 {2} 標籤推送到 {3}
push.notification.description.pushed.with.single.tag=已將 {0} 個{0,choice,1\\#提交|2\\#提交} 推送到 {1}，將標籤 {2} 推送到 {3}
push.notification.description.rejected=推送到 {0} 被拒
push.notification.description.rejected.and.cancelled=推送被拒，更新被取消
push.notification.description.rejected.and.conflicts=由於更新期間發生衝突，推送被取消。<br/>檢查是否已正確解決衝突，然後再次呼叫推送。
push.notification.description.rejected.and.failed=因發生錯誤，推送被拒，更新失敗
push.notification.description.rejected.and.incomplete=由於更新過程中並未解決所有衝突，推送被取消。<br/>請解決衝突並再次呼叫推送
push.notification.description.rejected.by.remote=推送 {0} 到 {1} 被遠端拒絕
push.notification.description.rejected.by.remote.without.target={0} 的推送被遠端拒絕
push.notification.description.up.to.date=所有內容都已處於最新狀態
push.notification.force.push.anyway.action=仍然強制推送
push.notification.force.push.progress.title.pushing=正在推送…
push.notification.force.with.lease.help=何為 Force-with-Lease?
push.notification.force.with.lease.help.description.first=Force-with-lease 推送阻止覆寫尚未獲取到本地版本庫的遠端更改
push.notification.force.with.lease.help.description.second=獲取最新更改，以確認能否安全捨棄更改並重複執行推送動作
push.notification.partially.failed.title=推送部分失敗
push.notification.partially.rejected.title=推送部分被拒
push.notification.push.failed.title=推送失敗
push.notification.rejected.title=推送被拒
push.notification.single.repo.success.description=推送動作期間收到 {0} 個{0, choice,1\\#提交|2\\#提交}
push.notification.successful.title=推送成功
push.notification.update.action=更新
push.notification.view.files.action=檢視在推送期間更新的檔案
push.notification.view.filtered.commits.actions=檢視與篩選器符合的 {0} 個{0,choice,1\\#提交|2\\#提交}
push.notification.view.received.commits.action=檢視收到的{0,choice,1\\#提交|2\\#提交}
push.rejected.dialog.title=推送被拒
push.rejected.many.repos=當前分支的推送被拒\\:
push.rejected.many.repos.item={1} 中的 {0}
push.rejected.many.repos.single.branch=當前分支“{0}”的推送被拒。
push.rejected.merge=合併(&M)
push.rejected.merge.needed=推送前需要合並遠端更改。
push.rejected.merge.needed.with.problem=在推送前，必須先合併遠端更改。<br/><br/>在這種情況下，強烈建議進行<b>合併</b>，因為存在未推送的合併提交。\\n<br/>進行重定基底可能導致問題。
push.rejected.only.one.git.repo=當前分支“{0}”的推送被拒。
push.rejected.rebase=重定基底(&R)
push.rejected.rebase.anyway=仍然重定基底
push.rejected.remember.checkbox=請記住更新方法，並在日後進行無提示更新(&S)。稍後可以在“{0} | 版本控制”中進行更改。<br/>
push.rejected.specific.repo=版本庫“{1}”中的當前分支“{0}”推送被拒。
push.up.to.commit.allowed.progress.title=正在檢查是否允許推送到選定的提交…
push.up.to.commit.getting.reference.progress.title=正在獲取對 HEAD 的提交參照…
push.upto.here.failed.dialog.title=無法啟動推送
rebase.abort.and.rollback.dialog.message=僅中止 {0} 中的重定基底還是同時回滾 {1} 中的重定基底?
rebase.abort.and.rollback.dialog.no.button.text=僅中止
rebase.abort.and.rollback.dialog.yes.button.text=中止並回滾
rebase.abort.dialog.message=中止{0} 中的重定基底?
rebase.abort.dialog.ok.button.text=中止
rebase.abort.dialog.title=中止重定基底
rebase.abort.notification.failed.title=中止重定基底失敗
rebase.abort.notification.successful.message=中止重定基底成功
rebase.abort.notification.warning.rollback.failed.message={0}中的回滾失敗\\:{1}{2}
rebase.abort.notification.warning.rollback.failed.title=重定基底回滾失敗
rebase.abort.notification.warning.rollback.failed.with.repo.message=成功中止 {0} 中的重定基底，但 {1}\\:{2}{3} 中的回滾失敗
rebase.abort.progress.indicator.command.in.repo.title={0} ({1} 內)
rebase.abort.rollback.successful.rebase.dialog.message=是否要回滾 {0} 中成功的重定基底?
rebase.abort.rollback.successful.rebase.dialog.ok.button.text=回滾
rebase.confirmation.dialog.published.commits.button.cancel.text=取消
rebase.confirmation.dialog.published.commits.button.rebase.text=仍然重定基底
rebase.confirmation.dialog.published.commits.message.first=您正在嘗試重定基底一些已推送到受保護分支的提交。
rebase.confirmation.dialog.published.commits.message.second=對這些提交進行重定基底將使提交重複，這是不推薦的，而且很可能是不需要的。
rebase.confirmation.dialog.published.commits.title=重定基底已發佈的提交
rebase.conflict.diff.dialog.left.title=正在從 {1} 重定基底 {0}
rebase.conflict.diff.dialog.right.simple.title=已重定基底的提交
rebase.conflict.diff.dialog.right.with.branch.title=已重定基底的提交和來自 {0} 的提交
rebase.couldnt.resolve.file=無法解析 {0}
rebase.dialog.branch.field=源分支
rebase.dialog.error.base.not.selected=選擇新基
rebase.dialog.error.branch.invalid=分支 ''{0}'' 不存在
rebase.dialog.error.branch.not.selected=選擇要切換到的分支
rebase.dialog.error.branch.or.tag.not.exist=沒有這樣的分支或標記
rebase.dialog.error.rebase.in.progress=此 Git 根目錄已經在進行互動重定基底
rebase.dialog.error.upstream.not.selected=選擇上游
rebase.dialog.help=顯示 Git 重定基底幫助
rebase.dialog.new.base=新基礎(分支或雜湊)
rebase.dialog.old.base=原基礎(分支或雜湊)
rebase.dialog.progress.loading.tags=正在載入標記…
rebase.dialog.root.invalid.label.text=(無效)
rebase.dialog.start.rebase=重定基底
rebase.dialog.target=分支或雜湊
rebase.dialog.title=重定基底
rebase.entry.action.name.drop=刪除
rebase.entry.action.name.edit=編輯
rebase.entry.action.name.fixup=Fixup
rebase.entry.action.name.pick=選取
rebase.entry.action.name.reword=改寫
rebase.entry.action.name.squash=壓縮
rebase.entry.action.name.unknown=未知
rebase.entry.action.name.update.ref=更新參照
rebase.git.operation.name=重定基底
rebase.help.link=git-scm.com 上的 git 重定基底
rebase.help.popup.ad.text=按空格開啟外部鏈接
rebase.help.rebase.branch=將基於一個分支的分支重定基底到另一個分支\\:
rebase.interactive.dialog.cancel.reword.warning.body=輸入的提交訊息將會丟失
rebase.interactive.dialog.cancel.reword.warning.cancel=取消改寫
rebase.interactive.dialog.cancel.reword.warning.continue=繼續編輯
rebase.interactive.dialog.cancel.reword.warning.title=取消改寫
rebase.interactive.dialog.discard.modifications.cancel=取消重定基底
rebase.interactive.dialog.discard.modifications.continue=繼續重定基底
rebase.interactive.dialog.discard.modifications.discard=捨棄
rebase.interactive.dialog.discard.modifications.message=捨棄更改並取消重定基底?
rebase.interactive.dialog.git.commands=Git 指令
rebase.interactive.dialog.git.commands.column.action=動作
rebase.interactive.dialog.git.commands.column.hash=雜湊
rebase.interactive.dialog.git.commands.column.subject=主題
rebase.interactive.dialog.reset.link.text=重設
rebase.interactive.dialog.reword.hint.text=按 {0} 套用更改
rebase.interactive.dialog.start.rebase=啟動重定基底
rebase.interactive.dialog.stop.to.edit.text=停止以編輯
rebase.interactive.dialog.title=正在重定基底提交
rebase.interactive.dialog.view.git.commands.text=檢視 Git 指令
rebase.interactive.edit.commit.message.dialog.title=Git 提交訊息
rebase.interactive.edit.commit.message.ok.action.title=繼續重定基底
rebase.interactive.noop.dialog.text=由於當前分支直接位於基礎分支的正下方或它們指向同一個提交，因此沒有要重定基底的提交('noop' 情況)。\\n是否要繼續? (這會將當前分支重設為基礎分支)
rebase.interactive.noop.dialog.title=Git 重定基底
rebase.interactive.unstructured.editor.dialog.root.label=Git 根\\: {0}
rebase.log.action.loading.commit.message.failed.message=無法載入{0,choice,1\\#提交|2\\#提交}的更改
rebase.log.action.operation.rebase.name=重定基底
rebase.log.action.operation.reword.name=改寫
rebase.log.action.progress.indicator.loading.commit.message.title=正在載入{0,choice,1\\#提交|2\\#提交}詳細資訊…
rebase.log.changes.action.operation.drop.name=刪除所選更改
rebase.log.changes.drop.action.description.all.changes.selected=無法刪除提交中的所有更改
rebase.log.changes.drop.action.failure.title=無法刪除所選更改
rebase.log.changes.drop.action.notification.successful.title=更改已刪除
rebase.log.changes.drop.action.notification.undo.failed.title=撤消刪除更改失敗
rebase.log.changes.drop.action.notification.undo.not.allowed.title=無法撤消刪除更改
rebase.log.changes.drop.action.progress.indicator.title=正在刪除更改…
rebase.log.changes.drop.action.progress.indicator.undo.title=正在撤消刪除更改…
rebase.log.changes.drop.failed.title=無法刪除所選更改
rebase.log.commit.editing.action.commit.not.in.head.error.text=該提交不在當前分支中
rebase.log.commit.editing.action.commit.pushed.to.protected.branch.error.text=該提交已被推送到受保護分支 ''{0}''
rebase.log.commit.editing.action.disabled.parents.description=所選提交已{0}父項
rebase.log.commit.editing.action.initial.commit.dialog.text=確定要編輯初始提交嗎?
rebase.log.commit.editing.action.initial.commit.dialog.title=正在編輯初始提交
rebase.log.commit.editing.action.progress.containing.branches.title=正在搜尋包含所選提交的分支…
rebase.log.commit.editing.action.prohibit.state=不能{0}
rebase.log.commit.editing.action.prohibit.state.grafting=優選期間不能{0}
rebase.log.commit.editing.action.prohibit.state.merging=合併期間不能{0}
rebase.log.commit.editing.action.prohibit.state.rebasing=重定基底期間不能{0}
rebase.log.commit.editing.action.prohibit.state.reverting=還原期間不能{0}
rebase.log.create.fixup.commit.action.failure.title=無法建立 Fixup 提交
rebase.log.create.squash.commit.action.failure.title=無法建立壓縮提交
rebase.log.drop.action.confirmation.message=是否要從 <b>{1}</b> 分支刪除 {0} 個{0,choice,1\\#提交|2\\#提交}?
rebase.log.drop.action.confirmation.message.detached.head=版本庫處於分離的 HEAD 狀態。是否要刪除 {0} 個{0,choice,1\\#提交|2\\#提交}?
rebase.log.drop.action.confirmation.title=刪除{0,choice,1\\#提交|2\\#提交}
rebase.log.drop.action.custom.text=刪除{0,choice,1\\#提交|2\\#提交}
rebase.log.drop.action.failure.title=無法刪除提交
rebase.log.drop.progress.indicator.title=正在刪除{0, choice, 1\\#提交|2\\#提交}…
rebase.log.drop.success.notification.title=已刪除 {0} 個{0,choice,1\\#提交|2\\#提交}
rebase.log.drop.undo.failed.title=撤消刪除失敗
rebase.log.drop.undo.impossible.title=無法撤消刪除
rebase.log.drop.undo.progress.title=正在撤消刪除…
rebase.log.interactive.action.failure.title=無法啟動重定基底
rebase.log.multiple.commit.editing.action.cant.find.head=在包含選定{0,choice,1\\#提交|2\\#提交}的版本庫中找不到 HEAD 分支
rebase.log.multiple.commit.editing.action.disabled.external.repository.description=所選{0, choice, 1\\#提交|2\\#提交}{0, choice,1\\#|2\\#}來自外部版本庫
rebase.log.multiple.commit.editing.action.disabled.multiple.repository.description=所選{0, choice, 1\\#提交|2\\#提交}{0, choice,1\\#|2\\#}來自不同的版本庫
rebase.log.multiple.commit.editing.action.progress.indicator.action.possibility.check=正在檢查是否允許編輯所選提交…
rebase.log.multiple.commit.editing.action.specific.commit.not.in.head=提交 {0} 不在當前分支中
rebase.log.multiple.commit.editing.action.specific.commit.root.or.merge=提交 {0} 有 {1} 個父項
rebase.log.reword.action.failure.title=無法編輯提交訊息
rebase.log.reword.action.notification.successful.title=已更改提交訊息
rebase.log.reword.action.notification.undo.failed.title=撤消提交訊息編輯失敗
rebase.log.reword.action.notification.undo.not.allowed.repository.changed.message=版本庫已被更改
rebase.log.reword.action.notification.undo.not.allowed.title=無法撤消提交訊息編輯
rebase.log.reword.action.progress.indicator.title=正在改寫…
rebase.log.reword.action.progress.indicator.undo.title=正在撤消改寫…
rebase.log.reword.dialog.description.label=編輯由 {1} 執行的提交 {0} 的訊息
rebase.log.reword.dialog.failed.pushed.to.protected.message=無法編輯所選{0,choice,1\\#提交|2\\#提交}\\: 提交 {1} 已被推送到受保護的分支 ''{2}''
rebase.log.reword.dialog.failed.repository.changed.message=無法編輯所選{0,choice,1\\#提交|2\\#提交}\\: 版本庫狀態已更改
rebase.log.reword.dialog.title=編輯提交訊息
rebase.log.squash.action.failure.title=無法壓縮提交
rebase.log.squash.new.message.dialog.label=編輯已壓縮提交的訊息
rebase.log.squash.new.message.dialog.title=已壓縮提交訊息
rebase.log.squash.progress.indicator.title=正在壓縮…
rebase.log.squash.success.notification.title=提交已壓縮
rebase.log.squash.undo.failed.title=撤消壓縮失敗
rebase.log.squash.undo.impossible.title=無法撤消壓縮
rebase.log.squash.undo.progress.title=正在撤消壓縮…
rebase.log.undo.impossible.pushed.to.protected.branch.notification.text=來自當前分支的提交已被推送到受保護的分支 {0}
rebase.notification.action.abort.text=中止
rebase.notification.action.continue.text=繼續
rebase.notification.action.retry.text=重試
rebase.notification.action.stage.and.retry.text=暫存並重試
rebase.notification.action.view.shelf.text=檢視擱置…
rebase.notification.action.view.stash.text=檢視隱藏…
rebase.notification.all.conflicts.resolved.continue.rebase.action.text=繼續重定基底(&T)
rebase.notification.all.conflicts.resolved.text=所有衝突都已解決。是否要繼續重定基底?
rebase.notification.all.conflicts.resolved.title=解決衝突
rebase.notification.conflict.title=由於衝突，重定基底停止
rebase.notification.continue.failed.stage.changes.text=無法暫存追蹤檔案中的更改
rebase.notification.continue.failed.unstaged.changes.text=追蹤檔案中存在未暫存的更改，阻止繼續重定基底
rebase.notification.editing.title=重定基底已停止，可以進行編輯
rebase.notification.failed.continue.title=繼續重定基底失敗
rebase.notification.failed.rebase.title=重定基底失敗
rebase.notification.no.rebase.in.progress.abort.title=無法中止重定基底
rebase.notification.no.rebase.in.progress.continue.title=無法繼續重定基底
rebase.notification.no.rebase.in.progress.message=沒有正在進行的重定基底
rebase.notification.not.allowed.empty.repository.message=版本庫 {0} 為空。
rebase.notification.not.allowed.grafting.message.first={0} 中有一個未完成的優選程序。
rebase.notification.not.allowed.grafting.message.second=在開始重定基底前，應先完成這項動作。
rebase.notification.not.allowed.merging.message.first={0} 中有一個未完成的合併程序。
rebase.notification.not.allowed.merging.message.second=在開始重定基底前，應先完成合併。
rebase.notification.not.allowed.message=無法在 {0} 中進行重定基底。
rebase.notification.not.allowed.rebasing.message.first={0} 中有一個未完成的重定基底程序。
rebase.notification.not.allowed.rebasing.message.second=在開始另一個重定基底前，應先完成這項動作。
rebase.notification.not.allowed.reverting.message.first={0} 中有一個未完成的還原程序。
rebase.notification.not.allowed.reverting.message.second=在開始重定基底前，應先完成這項動作。
rebase.notification.not.allowed.title=不允許重定基底
rebase.notification.not.started.title=重定基底未啟動
rebase.notification.saved.local.changes.part.shelf.text=重定基底前已擱置本地更改。
rebase.notification.saved.local.changes.part.stash.text=重定基底前已隱藏本地更改。
rebase.notification.successful.rebased.checkout.message=已簽出{0,choice,0\\#|1\\# {1} }並將其重定基底{2,choice,0\\#|1\\#到 {3}}
rebase.notification.successful.rebased.message=已{0,choice,0\\#|1\\#將 {1} }重定基底{2,choice,0\\#|1\\#到 {3}}
rebase.notification.successful.title=重定基底成功
rebase.operation.name=重定基底
rebase.option.interactive=在重定基底之前編輯提交
rebase.option.keep.empty=重定基底期間不移除空提交
rebase.option.onto=為重定基底的提交指定新基
rebase.option.rebase.merges=重新建立提交拓撲
rebase.option.root=重定基底分支中的所有提交
rebase.option.switch.to.branch=選擇另一個要重定基底的分支
rebase.option.update.refs=自動更新指向重定基底的提交的分支
rebase.options.modify.dialog.title=新增重定基底選項
rebase.progress.indicator.aborting.title=正在中止重定基底程序…
rebase.progress.indicator.conflicts.collecting.title=正在收集要解決的衝突…
rebase.progress.indicator.continue.title=正在繼續重定基底程序…
rebase.progress.indicator.preparing.title=正在準備重定基底…
rebase.progress.indicator.retry.title=正在重試重定基底程序…
rebase.progress.indicator.title=正在重定基底…
rebase.simple.editor.dialog.title=Git 編輯器
rebase.tracked.files.with.unstaged.changes.empty.text=沒有未暫存的檔案
rebase.tracked.files.with.unstaged.changes.title=具有未暫存更改的追蹤檔案
rebase.update.project.abort.task.title=正在中止重定基底…
rebase.update.project.conflict.error.notification.description=然後，您可以<b>繼續重定基底</b>。<br/>您也可以<b>中止重定基底</b>以還原原始分支並停止重定基底。
rebase.update.project.conflict.error.notification.title=無法繼續重定基底
rebase.update.project.conflict.merge.description.label=檢測到合併衝突。請先解決這些衝突，然後再繼續重定基底。
rebase.update.project.notification.abort.error.message=中止重定基底時出錯
rebase.update.project.notification.abort.success.message=已中止重定基底
rebase.update.project.notification.failed.message=無法繼續重定基底。{0}
rebase.update.project.notification.failed.title=重定基底錯誤
rebase.using.log.couldnt.start.error=由於 IDE 生成的 'git-rebase-todo' 檔案無效，因此無法執行重定基底。是否要使用 Git 原生檔案生成來重試重定基底?
rebasing.merge.commits.button.cancel=取消
rebasing.merge.commits.button.merge=合併
rebasing.merge.commits.button.rebase=重定基底
reference.validating.progress.indicator.title=正在驗證修訂…
remote.dialog.add.remote=新增遠端
remotes.changing.remote.error.message=無法將遠端 {0} 更改為 {1} ''{2}''
remotes.changing.remote.error.title=更改遠端
remotes.changing.remote.progress=正在更改遠端…
remotes.define.duplicate.remote.name.validation.message=遠端名稱 ''{0}'' 已被使用
remotes.define.empty.remote.name.validation.message=遠端名稱不能為空
remotes.define.empty.remote.url.validation.message=遠端 URL 不能為空
remotes.define.invalid.remote.name.validation.message=遠端名稱包含非法字元
remotes.define.remote=定義遠端
remotes.define.remote.name=名稱\\:
remotes.define.remote.url=URL\\:
remotes.dialog.adding.remote=正在新增遠端…
remotes.dialog.cannot.add.remote.error.message=無法新增遠端 {0} ''{1}''
remotes.dialog.remove.remote.message=移除{0,choice,1\\#遠端|2\\#遠端}{1}?
remotes.dialog.remove.remote.title=移除{0,choice,1\\#遠端|2\\#遠端}
remotes.dialog.removing.remote.error.message=無法移除{0, choice, 1\\#遠端|2\\#遠端} {1}
remotes.dialog.removing.remote.error.title=移除{0,choice,1\\#遠端|2\\#遠端}
remotes.dialog.removing.remote.progress=正在移除{0,choice,1\\#遠端|2\\#遠端}…
remotes.dialog.title=Git 遠端
remotes.fetch.remote.text=獲取遠端
remotes.operation.error.message=在 {1} 中{0}\\:\\n{2}
remotes.operation.not.executed.message=動作未執行
remotes.remote.column.name=名稱
remotes.remote.column.url=URL
remove.removing=正在移除檔案…
rename.branch.operation.name=重新命名
repositories=版本庫
repository.action.missing.roots.misconfigured=組態的 Git 根都不在 Git 下。組態的目錄中必須包含“.git”目錄。
repository.action.missing.roots.title=沒有 Git 根
repository.action.missing.roots.unconfigured.message=沒有為專案組態 Git 根。
repository.not.found.error=找不到 {0} 的已組態 Git 版本庫
reset.action.name=重設 Head…
reset.commit.invalid=指定的提交表達式未通過驗證。
reset.commit.label=為提交(&C)\\:
reset.commit.tooltip=由於重設動作而將成為當前 HEAD 的提交。
reset.title=重設 Head
reset.type=重設類型(&T)\\:
reset.type.tooltip=<html>重設類型(另請參閱 <code>git reset</code> man 頁面)\\:<ul><li><b>Mixed</b> 將重設索引，但不會重設工作樹</li><li><b>Soft</b> 將保留索引和工作樹，只是移動 HEAD 指針</li><li><b>Hard</b> 將重設索引和工作樹。<em>工作樹中的更改會丟失</em></li></ul></html>
reset.validate=驗證(&V)
resetting.title=正在重設 HEAD…
restore.conflict.dialog.description.label.text=在 {0} 之前儲存的未提交更改與 {1} 中的檔案衝突
restore.conflict.diff.dialog.left.shelf.title=擱置中的未提交更改
restore.conflict.diff.dialog.left.stash.title=隱藏中的未提交更改
restore.conflict.diff.dialog.right.title=來自 {0} 的更改
restore.notification.failed.shelf.message=在{0}之前，您未提交的更改已儲存至擱置。
restore.notification.failed.show.changes.action=檢視已儲存的更改…
restore.notification.failed.stash.message=在{0}之前，您的未提交的更改已儲存至隱藏。
restore.notification.failed.title=未還原本地更改
revert.operation.applied=還原
revert.operation.name=還原
revision.load.contents=載入修訂內容
revision.number.cannot.parse.output=無法解析輸出\\: [{0}]
save.load.conflict.dialog.diff.left.title=您未提交的更改
save.load.conflict.dialog.diff.right.title=遠端更改
save.notification.failed.shelf.text=無法擱置本地未提交的更改\\:
save.notification.failed.stash.text=無法隱藏本地未提交的更改\\:
save.notification.failed.title=無法儲存 {0} 上未提交的更改
search.everywhere.group.full.name=Git 參照
search.everywhere.group.name=Git
search.everywhere.items.commit.by.hash=提交(按雜湊)
search.everywhere.items.commit.by.message=提交(按訊息)
search.everywhere.items.local.branch=本地分支
search.everywhere.items.remote.branch=遠端分支
search.everywhere.items.tag=標記
search.scope.project.git.exclude.ignored=專案檔案，不包括 Git 忽略的檔案
search.scope.project.git.tracked=Git 追蹤的專案檔案
separator.Git.Stage.Configure.display.as=顯示為
separator.git.branches.popup.filter.by=在搜尋結果中新增
separator.show=顯示
settings.add.suffix=在挑選推送到受保護分支的提交時，新增 'cherry-picked from <hash>' 後綴
settings.auto.update.on.push.rejected=如果當前分支的推送被拒，則自動更新
settings.bad.file.names=提交名稱可能會導致其他系統出現問題的檔案時發出警告
settings.clean.working.tree=使用以下方法清理工作樹\\:
settings.commit.group.title=提交
settings.configure.sign.gpg.do.not.sign.table.text=不簽署
settings.configure.sign.gpg.error.no.available.keys.found.text=找不到適用的私鑰
settings.configure.sign.gpg.error.table.text=錯誤\\: {0}
settings.configure.sign.gpg.for.repo.dialog.title=組態 GPG 密鑰 {0}
settings.configure.sign.gpg.for.repos.dialog.title=組態 GPG 密鑰
settings.configure.sign.gpg.gpg.kep.table.column.name=GPG 密鑰
settings.configure.sign.gpg.loading.table.text=正在載入…
settings.configure.sign.gpg.root.table.column.name=根
settings.configure.sign.gpg.synced.with.gitconfig.text=與 gitconfig 同步
settings.configure.sign.gpg.with.key.checkbox.text=使用 GPG 密鑰簽署提交\\:
settings.credential.helper=使用憑證幫助程序
settings.crlf=如果即將提交 CRLF 行分隔符，則發出警告
settings.detached.head=在游離的 HEAD 中或重定基底期間提交時發出警告
settings.enable.staging.area=啟用暫存區域
settings.enable.staging.area.comment=這將停用更改列表支援。僅適用於非強制回應提交介面。
settings.enable.stashes.and.shelves=將隱藏和擱置合併到一個頁籤中
settings.explicitly.check=顯式檢查遠端分支上的傳入提交\\:
settings.explicitly.check.condition.comment=需要在“進階設定”中啟用 ''{0}'' 選項
settings.filter.update.info=按路徑過濾“更新專案”資訊\\:
settings.git.fetch.tag.mode.always=始終
settings.git.fetch.tag.mode.default=自動
settings.git.fetch.tag.mode.default.description=遵循 git 組態
settings.git.fetch.tag.mode.never=從未
settings.git.fetch.tag.mode.prune=同步
settings.git.fetch.tags.label=獲取標記\\:
settings.git.incoming.change.strategy.text.always=始終
settings.git.incoming.change.strategy.text.auto=自動
settings.git.incoming.change.strategy.text.never=從不
settings.git.option.group=Git
settings.git.update.method.branch.default=分支預設
settings.git.update.method.merge=合併
settings.git.update.method.merge.description=&將傳入更改合併到當前分支
settings.git.update.method.rebase=重定基底
settings.git.update.method.rebase.description=&在傳入更改上重定基底當前分支
settings.label.sign.gpg.commits.enabled.different.keys.text=提交使用不同的 GPG 密鑰簽署
settings.label.sign.gpg.commits.enabled.n.roots.of.m.text=提交使用 {1} 的 {0} 個{0,choice,1\\#根|2\\#根}中的 GPG 密鑰簽署
settings.label.sign.gpg.commits.enabled.text=提交使用 GPG 密鑰簽署\\: {0}
settings.label.sign.gpg.commits.no.roots.text=專案中沒有 Git 根
settings.label.sign.gpg.commits.not.configured.text=未組態使用 GPG 密鑰簽署提交
settings.large.files=提交大於以下大小的檔案時發出警告\\:
settings.large.files.suffix=MB
settings.protected.branched=受保護分支\\:
settings.protected.branched.validation=跳過無效的受保護分支模式 ''{0}''\\: {1}
settings.push.dialog=顯示提交和推送的推送對話框
settings.push.dialog.for.protected.branches=僅在提交到受保護分支時顯示推送對話框
settings.push.group.title=推送
settings.show.rebase.log.drop.confirmation=要求確認刪除提交
settings.show.rebase.log.drop.confirmation.description=適用於 Git
settings.sign.gpg.configure.link.text=組態 GPG 密鑰…
settings.stash=隱藏
settings.stash.show.diff.group=呼叫“顯示差異”時，比較隱藏的更改\\:
settings.stash.show.diff.with.head=與父提交
settings.stash.show.diff.with.local=與檔案的本地版本
settings.synchronize.branch.protection.rules=從 GitHub 載入分支保護規則
settings.synchronize.branch.protection.rules.description=將 GitHub 規則新增到本地規則中，並在每次獲取時進行同步
settings.update.group.title=更新
settings.update.method=更新方法\\:
share.action.remote.is.on.host=遠端已經在 {0} 上\\:
share.action.remotes.are.on.host={0} 上已經有以下遠端\\:
share.anyway.button=仍然共享
share.error.cannot.find.git.repo=找不到 Git 版本庫
share.error.cannot.finish=無法完成 {0} 共享過程
share.error.created.project=專案建立成功
share.error.failed.to.create.repo=無法建立版本庫
share.error.init.commit.failed=({0})，但初始提交失敗\\:<br/>
share.error.project.is.on.host=專案已在 {0} 上
share.error.push.failed=({0})，但初始推送失敗\\:<br/>{1}
share.error.push.no.current.branch=({0})，但初始推送失敗\\: 沒有當前分支
share.error.unknown=未知錯誤
share.error.unknownHost=未知主機\\: {0}
share.process=正在 {0} 中共享專案…
share.process.adding.files=正在將檔案新增到 git…
share.process.adding.gh.as.remote.host=正在將 {0} 新增為遠端主機…
share.process.creating.git.repository=正在建立空 git 版本庫…
share.process.creating.repository=正在建立 {0} 版本庫…
share.process.empty.project.created=已在 {0} 上成功建立空版本庫
share.process.loading.account.info=正在載入 {0} 的帳戶資訊
share.process.performing.commit=正在執行提交…
share.process.pushing.to.host.master=正在推送至 {0} {1}…
share.process.retrieving.username=正在檢索用戶名…
share.process.successfully.shared=在 {0} 中成功共享專案
share.untracked.files.dialog.title=為初始提交新增檔案
show.diff.between.dialog.could.not.load.diff.with.branch.error=無法載入與 {0} 的差異\\: {1}
show.diff.between.dialog.no.differences.empty.text=無差異
show.diff.between.dialog.title={0}與當前工作樹之間的更改
smart.operation.dialog.don.t.operation.name=不{0}
smart.operation.dialog.git.operation.name.problem=Git {0} 問題
smart.operation.dialog.north.panel.label.shelf.text=<html>您對以下檔案的本地更改將被{0}覆蓋。<br/>{1}可以擱置這些更改，{0}，並在之後取消擱置。</html>
smart.operation.dialog.north.panel.label.stash.text=<html>您對以下檔案的本地更改將被{0}覆蓋。<br/>{1} 可以隱藏這些更改，{0}，並在之後取消隱藏。</html>
smart.operation.dialog.ok.action.shelf.description=擱置本地更改，{0}，取消擱置
smart.operation.dialog.ok.action.stash.description=隱藏本地更改，{0}，取消隱藏
smart.operation.dialog.operation.name.and.overwrite.local.changes={0}並覆蓋本地更改
smart.operation.dialog.smart.operation.name=智能{0}
stage.add.action.text=暫存
stage.add.error.title=無法暫存檔案
stage.add.no.content.action.text=在沒有內容的情況下暫存
stage.add.process=正在暫存檔案…
stage.add.range.command.name=暫存更改
stage.commit.all.text=全部提交(&I)
stage.commit.failed=無法提交 {0}
stage.commit.process=正在提交暫存更改…
stage.commit.successful=已提交 {0}\\: {1}
stage.content.local=本地
stage.content.staged=已暫存
stage.default.status=沒有要提交的內容，工作樹是乾淨的
stage.default.status.help=暫存區域入門
stage.diff.local.content.exception.message=無法獲取本地檔案\\: ''{0}''
stage.diff.staged.content.exception.message=無法獲取暫存內容\\: ''{0}''
stage.loading.status=正在載入更改…
stage.reset.action.text=取消暫存
stage.reset.error.title=無法取消暫存檔案
stage.reset.process=正在取消暫存檔案…
stage.revert.action.text=回滾
stage.revert.error.title=無法回滾檔案
stage.revert.process=正在回滾檔案…
stage.revert.staged.range.command.name=回滾暫存的更改
stage.revert.unstaged.range.command.name=回滾未暫存的更改
stage.tree.node.ignored=已忽略
stage.tree.node.staged=已暫存
stage.tree.node.unmerged=已取消合併
stage.tree.node.unstaged=未暫存
stage.tree.node.untracked=已取消追蹤
stage.vfs.editor.notification.link=開啟本地版本
stage.vfs.editor.notification.text=這是暫存版本的 ''{0}''
stage.vfs.editor.tab.tooltip=''{0}'' 的暫存版本
stage.vfs.presentable.file.name=已暫存\\: {0}
stage.vfs.read.process=正在從 Git 索引讀取 {0}
stage.vfs.shutdown.process=正在關閉 Git 索引 VFS
stage.vfs.write.process=正在將 {0} 寫入 Git 索引
stash.action.name=隱藏
stash.button=建立隱藏
stash.changes.non.empty.index.for.roots.notification.text={0} 中的暫存區域包含對儲存到隱藏的其他檔案的修改
stash.changes.non.empty.index.notification.action=不再顯示
stash.editor.diff.preview.empty.title=隱藏
stash.editor.diff.preview.id.change.title={0}\\: {1}
stash.empty.text.help.link=隱藏和擱置入門
stash.enable.stashes.link=啟用並檢視 Git 隱藏
stash.error=無法隱藏 {0}
stash.error.can.not.stash.changes.now=現在無法隱藏更改
stash.files.action.text=隱藏檔案
stash.files.error.message=無法隱藏檔案
stash.files.in.roots.success={0} 中的檔案已成功隱藏
stash.files.progress.title=正在隱藏檔案
stash.files.success=檔案已成功隱藏
stash.keep.index=保留索引(&I)
stash.keep.index.tooltip=如果選中此複選框，所有已新增到索引中的更改將保持不變
stash.load.changes.error=無法在解析為 {1} 的隱藏中載入根 {0} 中的更改
stash.message=訊息(&M)\\:
stash.message.tooltip=在此處輸入隱藏訊息
stash.progress.indicator.title=正在隱藏來自 ''{0}'' 的更改…
stash.root.node.title=隱藏
stash.tab.name=儲藏
stash.title=隱藏
stash.unstash.changes.current.branch.label=當前分支\\:
stash.unstash.changes.in.root.dialog.title=取消隱藏 {0} 中的更改
stash.unstash.conflict.dialog.description.label.text=更新前隱藏的未提交更改與更新後的檔案衝突。
stash.unstash.progress.indicator.title=正在消除對 ''{0}'' 的更改…
stash.unstash.unresolved.conflict.warning.notification.message=您的未提交更改已儲存到隱藏。<br/>取消隱藏未完成，您的工作樹中有未解決的合併<br/>請解決衝突並刪除隱藏。
stash.unstash.unresolved.conflict.warning.notification.resolve.conflicts.action=解決衝突…
stash.unstash.unresolved.conflict.warning.notification.show.stash.action=檢視已儲存的更改…
stash.unstash.unresolved.conflict.warning.notification.title=本地更改已還原，但存在衝突
stash.view.stashes.link=檢視 Git 隱藏
stashes.and.shelves.tab.name=儲藏和擱置
stashing.progress.title=正在隱藏更改…
stashing.title=正在隱藏更改…
stats.wrong.git.shortlog.response=Git 快捷日誌輸出中出現意外行 ''{0}''
status.exception.message.format.message.xstatus.ystatus.line.output={0} xStatus\\=[{1}]，yStatus\\=[{2}]，行\\=[{3}]\\n輸出\\:\\n{4}
status.exception.message.line.is.too.short=此行過短
status.exception.message.missing.path=缺少初始路徑
status.exception.message.unexpected=意外的狀態符號
status.exception.message.unexpected.status=意外的狀態符號\\: ''{0}''
status.exception.message.unexpected.xstatus.ystatus=意外的狀態符號\\: ''{0}{1}''
tab.title.conflicts=衝突
tab.title.repo.root.name.at.revision={1} 的 {0}
tag.action.name=標記
tag.button=建立標籤
tag.commit.label=提交(&C)
tag.commit.tooltip=輸入要標記的提交或物件的名稱，或留空以使用 HEAD。
tag.error.creating.message.file.message=無法建立訊息檔案\\: {0}
tag.error.invalid.commit=該提交或物件名稱無效。
tag.error.tag.exists=存在同名的標記。
tag.force=強制(&F)
tag.force.tooltip=強制建立標記，即使已存在另一個具有此名稱的標記。
tag.getting.existing.tags=正在獲取現有標記…
tag.message.label=訊息(&M)\\:
tag.message.tooltip=如果訊息不為空，則建立帶註解的標記。
tag.name.label=標記名稱(&N)\\:
tag.name.tooltip=在此處輸入新的標記名稱。
tag.progress.title=正在新增標記…
tag.title=標記
tag.validate=驗證(&V)
tag.validate.tooltip=點擊此按鈕驗證要標記的提交
text.crlf.fix.dialog.description.proposed.fix=如果選擇<b>修正並提交</b>，將執行 {0}。<br/>如果選擇<b>按原樣提交</b>，則不會更改組態值。
text.crlf.fix.dialog.description.warning=您即將把 CRLF 行分隔符提交到 Git 版本庫。<br/>建議將 {0} Git 特性設定為 {1}，以免發生行分隔符問題。
text.crlf.fix.notification.description.warning=您即將向 Git 版本庫提交 CRLF 行分隔符
title.changes.excluded.from.commit=已從合併提交中排除更改
title.crlf.fix.dialog=行分隔符警告
title.sudo.command.install.git=安裝 Git
title.unresolved.conflicts.pre.commit.check=未解決的衝突
title.user.name.email.not.specified=未定義 Git 用戶名
tooltip.run.git.hooks=如果未選中，會在即將進行的提交中使用 '--no-verify' 選項跳過 Git 掛鈎
tooltip.run.git.hooks.disabled=已在“進階設定”中停用執行 Git 掛鈎
tracked.branch.fix.dialog.branch.placeholder=指定分支
tracked.branch.fix.dialog.not.on.branch.message=將跳過以下版本庫\\:
tracked.branch.fix.dialog.not.on.branch.title=游離的 HEAD 中的 Git 版本庫
tracked.branch.fix.dialog.ok.button.text=更新
tracked.branch.fix.dialog.set.as.tracked=設為追蹤分支
tracked.branch.fix.dialog.title=更新
unexpected.tree.entries.error=意外的樹條目\\: {0}
unexpected.tree.object.error=意外的樹物件\\: {0}
unshallow.repository.notification.message=檢測到淺層版本庫
unshallow.repository.notification.success.title=版本庫已轉換為完整版本庫
unshallow.repository.notification.title=此版本庫可以轉換為完整版本庫
unstash.action.name=取消隱藏
unstash.branch.label=作為新分支(&B)\\:
unstash.branch.tooltip=如果輸入非空名稱，該隱藏將作為新分支簽出
unstash.button.apply=套用隱藏
unstash.button.branch=分支
unstash.button.pop=消除隱藏
unstash.clear=清除(&C)
unstash.clear.confirmation.message=移除所有隱藏? 此動作無法撤消。
unstash.clear.confirmation.title=移除所有隱藏?
unstash.clear.tooltip=刪除版本庫中的所有隱藏
unstash.clearing.stashes=正在清除隱藏…
unstash.conflict.dialog.description.label.text=取消隱藏 {0} 時發生衝突
unstash.conflict.diff.dialog.left.title=本地更改
unstash.conflict.diff.dialog.right.title=來自隱藏的更改
unstash.dialog.remove.stash.progress.indicator.title=正在移除隱藏 {0}…
unstash.dialog.show.stashes.error.dialog.title=無法顯示隱藏列表
unstash.dialog.stash.list.load.progress.indicator.title=正在載入隱藏列表…
unstash.dialog.unresolved.conflict.warning.notification.message=取消隱藏未完成，您的工作樹中存在未解決的合併。
unstash.dialog.unresolved.conflict.warning.notification.title=取消隱藏期間未解決衝突
unstash.dialog.unresolved.conflict.warning.resolve.conflicts.action=解決衝突…
unstash.drop=刪除(&D)
unstash.drop.confirmation.message=<html>是否要移除 {0}?<br/>“{1}”</html>
unstash.drop.confirmation.title=移除隱藏 {0}?
unstash.drop.tooltip=刪除所選隱藏
unstash.error.can.not.unstash.changes.now=現在無法取消隱藏更改
unstash.operation.name=取消隱藏
unstash.pop.stash=消除隱藏(&P)
unstash.pop.stash.tooltip=如果選中，則該隱藏在套用後會被刪除
unstash.reinstate.index=復原索引(&I)
unstash.reinstate.index.tooltip=嘗試復原索引以及工作樹更改
unstash.stash.applied=已成功套用隱藏
unstash.stashes=隱藏(&S)\\:
unstash.title=取消隱藏更改
unstash.unstashed.with.conflicts.error.title=已取消隱藏，但存在衝突
unstash.unstashing=正在取消隱藏…
unstash.view=檢視(&V)
unstash.view.dialog.title=受 {0} 影響的路徑
unstash.view.tooltip=檢視所選隱藏
update.checks.not.supported.git.2.9.required=不支持更新檢查。需要 Git 2.9 及以上版本
update.notification.choose.upstream.branch=選擇上游分支
update.notification.update.error=無法更新
update.options.display.name=Git 更新設定
update.process.error.additional.description.unfinished.rebase=然後，您可以<b>繼續重定基底</b>。<br/>您也可以<b>中止重定基底</b>以還原原始分支並停止重定基底。
update.process.error.description.unfinished.rebase=您有未完成的重定基底程序。必須先解決這些衝突，然後才能更新。
update.process.error.message.unfinished.merge=您有未完成的合併。必須先解決這些衝突，然後才能更新。
update.process.error.message.unmerged.files=檢測到未合併的檔案。必須先解決這些衝突，然後才能更新。
update.process.error.notification.title=無法設定上游分支
update.process.generic.error.title=無法更新
update.process.nothing.to.update=沒有要更新的內容
update.process.progress.title=正在更新…
update.skip.root.reason.detached.head=游離的 HEAD
update.skip.root.reason.no.tracked.branch=無追蹤分支
util.remote.renderer.none=無
validation.error.email.no.at=電子郵件地址必須包含 '@' 符號
validation.warning.set.name.email.for.git=您必須為 Git 指定用戶名和電子郵件
vcs.history.action.gitlog=在 Git 日誌中顯示
vcs.log.archiving.log.index.data=正在歸檔 Git 日誌索引資料…
vcs.log.create.archive.with.log.index.data=傾印 Git 日誌索引資料
vcs.log.status.bar.extracting.log.index.data=正在獲取 Git 日誌索引資料…
vcs.log.status.bar.replacing.log.index.data=正在取代 Git 日誌索引資料…
vcs.log.use.log.index.data=使用共享 Git 日誌索引資料
vfs.listener.add.single.prompt=是否要安排將以下檔案新增到 Git?\\n{0}\\n\\n如果您選擇“取消”，以後仍可以手動新增。
vfs.listener.add.single.title=將檔案新增到 Git
vfs.listener.add.title=將檔案新增到 Git
vfs.listener.checking.ignored=正在檢查忽略的檔案…
vfs.listener.delete.single.prompt=是否要從 Git 中刪除以下檔案?\\n{0}\\n\\n如果您選擇“取消”，以後仍可以手動刪除。
vfs.listener.delete.single.title=從 Git 中刪除檔案
vfs.listener.delete.title=從 Git 中刪除檔案
warning.message.commit.with.bad.windows.file.name.bad.character=某些檔名包含 Windows 不允許的字元\\: ''{0}''。\\n如果提交，可能無法在 Windows 上檢出 Git 版本庫。
warning.message.commit.with.bad.windows.file.name.reserved=某些檔案使用 Windows 不允許的保留名稱\\: ''{0}。\\n如果提交，將無法在 Windows 上檢出 Git 版本庫。
warning.message.commit.with.detached.head=以下路徑中的 Git 版本庫處於<b>游離的 HEAD</b> 狀態\\: <br/>{0}<br/>您可以進行檢查，嘗試做出更改並提交，但務必簽出分支，以免丟失您的工作。<br/>否則，可能會丟失所做的更改。
warning.message.commit.with.unfinished.rebase=以下路徑中的 Git 版本庫有一個<b>未完成的重定基底</b>程序\\: <br/> {0}<br/>您可能想<b>繼續重定基底</b>而不是提交。<br/>在重定基底期間提交可能會導致提交丟失。
warning.title.commit.with.bad.windows.file.name=檔名不允許在 Windows 上使用
warning.title.commit.with.detached.head=在游離的 HEAD 中提交
warning.title.commit.with.unfinished.rebase=未完成重定基底程序
warning.your.local.changes.would.be.overwritten.by=您的本地更改將被 {0} 覆蓋。\\n提交、{1}或還原您的更改以繼續。
"
`;

exports[`src messages/GithubBundle.properties 1`] = `
"account.choose.as.default=設定為當前專案的預設帳戶
account.choose.button=選擇
account.choose.for=選擇 GitHub 帳戶\\: {0}
account.choose.not.selected=未選擇帳戶
account.choose.title=選擇 GitHub 帳戶
accounts.add.button=新增帳戶
accounts.add.dropdown.link=新增帳戶
accounts.default.missing=缺少預設的 GitHub 帳戶
accounts.relogin=重新登入
action.GitHub.Diff.Review.NextComment.description=轉到下一個可見註釋
action.GitHub.Diff.Review.NextComment.text=下一個註釋
action.GitHub.Diff.Review.PreviousComment.description=轉到上一個可見註釋
action.GitHub.Diff.Review.PreviousComment.text=上一個註釋
action.Github.Accounts.AddGHAccount.text=通過 GitHub 登入…
action.Github.Accounts.AddGHAccountWithToken.text=通過令牌登入…
action.Github.Accounts.AddGHEAccount.text=登入 GitHub Enterprise…
action.Github.Add.Account.synonym=新增 GitHub 帳戶
action.Github.Clone.MainMenu.text=克隆版本庫…
action.Github.Clone.popup@GoToAction.text=克隆版本庫…
action.Github.Clone.text=從 GitHub 克隆版本庫…
action.Github.Create.Gist.description=建立 GitHub gist
action.Github.Create.Gist.text=建立 Gist…
action.Github.Create.Pull.Request.synonym1=新增拉取請求/合併請求/程式碼審查
action.Github.Create.Pull.Request.synonym2=啟動拉取請求/合併請求/程式碼審查
action.Github.Create.Pull.Request.synonym3=建立合併請求/程式碼審查
action.Github.Create.Pull.Request.text=建立拉取請求…
action.Github.Open.Settings.MainMenu.text=管理帳戶…
action.Github.Open.Settings.popup@GoToAction.text=管理帳戶…
action.Github.Open.Settings.text=管理 GitHub 帳戶…
action.Github.Pull.Request.Branch.Update.text=更新以啟用審查模式…
action.Github.Pull.Request.Review.In.Editor.Toggle.text=審查模式
action.Github.Pull.Request.Show.In.Toolwindow.text=在工具視窗中顯示拉取請求
action.Github.PullRequest.Changed.MarkViewed.Toggle.text=切換已檢視/未檢視狀態
action.Github.PullRequest.Copy.Link.text=複製拉取請求 URL
action.Github.PullRequest.Open.Link.text=在瀏覽器中開啟拉取請求
action.Github.Share.Vcs.Toolbar.Widget.text=GitHub…
action.Github.Share.description=在 GitHub 上建立版本庫並將您的提交推送到該版本庫
action.Github.Share.text=在 GitHub 上共享專案
action.Github.Sync.Fork.description=相對於來源重定基底 GitHub 複刻版本庫
action.Github.Sync.Fork.text=同步複刻
action.Github.View.Pull.Request.synonym1=檢視合併請求/程式碼審查
action.Github.View.Pull.Request.text=檢視拉取請求
action.comment.text=評論
button.use.token=使用令牌…
cannot.configure.remote=無法組態 ''{0}'' 遠端\\:\\n{1}
cannot.create.gist=無法建立 Gist
cannot.display.item=無法顯示條目 - {0}
cannot.load.changes=無法載入更改
cannot.load.commits=無法載入提交
cannot.load.data=無法載入資料
cannot.load.details=無法載入詳細資訊
cannot.load.repo.info=無法載入版本庫資訊
create.gist.dialog.copy.url=複製 URL
create.gist.dialog.create.for.field=為以下帳戶建立\\:
create.gist.dialog.description.field=描述\\:
create.gist.dialog.filename.field=檔名\\:
create.gist.dialog.open.browser=在瀏覽器中開啟
create.gist.dialog.secret=私密
create.gist.dialog.title=建立 Gist
create.gist.error.binary.file=無法上傳二進制檔案\\: {0}
create.gist.error.content.read=無法讀取檔案 {0} 的內容
create.gist.error.empty=無法建立空 gist
create.gist.process=正在建立 gist…
create.gist.success=已成功建立 Gist
create.gist.url=在 GitHub 上開啟
credentials.button.generate=生成…
credentials.incorrect=憑證不正確。\\n{0}
credentials.invalid.auth.data=身份驗證資料無效。\\n{0}
credentials.invalid.server.path=伺服器路徑無效
credentials.server.cannot.be.empty=伺服器不能為空
credentials.server.field=伺服器\\:
credentials.server.path.invalid=伺服器 URL 無效
credentials.token.field=令牌\\:
dialog.message.account.cannot.be.empty=帳戶不能為空
dialog.message.login.to.continue=登入到 GitHub 以繼續
dialog.title.add.github.account=新增 GitHub 帳戶
github.actions.action.file.json.schema=GitHub Action JSON 架構
github.actions.file.promo.label=GitHub Actions
github.actions.workflow.file.json.schema=GitHub Workflow JSON 架構
gql.error.in.field={1} 的“{2}”欄位中存在 {0} 錯誤
group.GitHub.Copy.Link.CopyReferencePopup.text=GitHub 版本庫 URL
group.GitHub.Copy.Link.text=將鏈接複製到 GitHub 版本庫
group.GitHub.MainMenu.text=GitHub
group.Github.Open.In.Browser.EditorTabPopup.text=在瀏覽器中開啟
group.Github.PullRequest.Details.Commit.Tree.ViewOptions.text=檢視選項
group.Github.PullRequest.Diff.Thread.View.Options.text=顯示審查會話
issue.state.closed=已關閉
issue.state.open=開放
label.login.option.separator=或
label.login.progress=正在登入…
link.label.use.token=使用令牌…
login.account.already.added=已新增帳戶 ''{0}''
login.to.github=登入 GitHub
login.to.github.enterprise=登入 GitHub Enterprise
login.to.github.enterprise.action=登入 GitHub Enterprise…
login.token.cannot.be.empty=令牌不能為空
login.via.github.action=通過 GitHub 登入…
open.on.github.action=在 GitHub 上開啟
open.on.github.action.description=在瀏覽器中開啟相應鏈接
progress.text.loading.protected.branches=正在載入 GitHub 分支保護規則
pull.request.adding.reviewers=正在新增審查者
pull.request.adjustment.failed=無法調整列表
pull.request.assignees=被指派者\\:
pull.request.assignees.popup={0, choice, 1\\#被指派者|2\\#被指派者}
pull.request.change.remote.or.account=更改版本庫或帳戶…
pull.request.close.action=關閉拉取請求
pull.request.comment.hint={0} 以評論
pull.request.comment.suggested.changes.applying=正在套用補丁
pull.request.comment.suggested.changes.committing=正在套用並提交更改
pull.request.comment.suggested.changes.resolving=正在解析會話
pull.request.commit.does.not.contain.changes=提交不包含任何更改
pull.request.commits=提交
pull.request.conflicts.merge.tooltip=拉取請求無法合併
pull.request.create.action=建立拉取請求
pull.request.create.already.exists=拉取請求已存在
pull.request.create.already.exists.view=檢視
pull.request.create.checking.branches=正在檢查拉取請求分支
pull.request.create.creating=正在建立拉取請求
pull.request.create.description=描述
pull.request.create.draft.action=建立草稿拉取請求
pull.request.create.error=無法建立拉取請求
pull.request.create.error.details=詳細資訊
pull.request.create.failed.to.check.branches=無法檢查拉取請求分支
pull.request.create.failed.to.load.changes=無法載入更改
pull.request.create.failed.to.load.commits=無法載入提交
pull.request.create.input.remote.branch.comment=您的更改將被推送到遠端版本庫以建立拉取請求
pull.request.create.input.remote.branch.name=遠端分支名稱\\:
pull.request.create.input.remote.branch.title=為拉取請求新增遠端分支
pull.request.create.no.changes=''{0}'' 和 ''{1}'' 之間沒有更改
pull.request.create.no.commits=無提交
pull.request.create.process.title=正在建立拉取請求…
pull.request.create.pushing=正在推送拉取請求分支
pull.request.create.select.branches=選擇拉取請求的 base 和 head 來檢視更改
pull.request.create.setting.metadata=正在更新拉取請求欄位
pull.request.create.title=標題
pull.request.details.adjusting.assignees=正在調整被指派者…
pull.request.details.adjusting.labels=正在調整標籤…
pull.request.details.adjusting.reviewers=正在調整審查者…
pull.request.diff.editor.title=拉取請求 \\#{0,number,\\#} 的差異
pull.request.discard.pending.comments=捨棄待定評論
pull.request.discard.pending.comments.dialog.msg=確定要刪除所有待定評論嗎?
pull.request.discard.pending.comments.dialog.title=捨棄待定審查
pull.request.does.not.contain.changes=拉取請求不包含任何更改
pull.request.does.not.contain.commits=拉取請求不包含任何提交
pull.request.editor.timeline=拉取請求時間線
pull.request.files=檔案
pull.request.info=資訊
pull.request.labels=標籤\\:
pull.request.labels.popup={0, choice, 1\\#標籤|2\\#標籤}
pull.request.list.cannot.load=無法載入拉取請求
pull.request.list.error.authorization=使用者授權失敗
pull.request.list.filter.assignee=被指派者
pull.request.list.filter.author=作者
pull.request.list.filter.label=標籤
pull.request.list.filter.quick.assigned=已分配給您
pull.request.list.filter.quick.open=開啟
pull.request.list.filter.quick.review.requests=審查請求
pull.request.list.filter.quick.yours=您的拉取請求
pull.request.list.filter.review=審查
pull.request.list.filter.review.approved.full=批准的審查
pull.request.list.filter.review.approved.short=批准的審查
pull.request.list.filter.review.awaiting.full=正在等待您的審查
pull.request.list.filter.review.awaiting.short=正在等待審查
pull.request.list.filter.review.change.requested.full=請求的更改
pull.request.list.filter.review.change.requested.short=請求的更改
pull.request.list.filter.review.no.full=無審查
pull.request.list.filter.review.no.short=無審查
pull.request.list.filter.review.not.full=未由您審查
pull.request.list.filter.review.not.short=未審查
pull.request.list.filter.review.required.full=需要審查
pull.request.list.filter.review.required.short=需要審查
pull.request.list.filter.review.reviewed.full=由您審查
pull.request.list.filter.review.reviewed.short=已審查
pull.request.list.filter.sort=排序
pull.request.list.filter.sort.least.commented=評論最少
pull.request.list.filter.sort.least.recently.updated=最早更新
pull.request.list.filter.sort.most.commented=評論最多
pull.request.list.filter.sort.newest=最新
pull.request.list.filter.sort.oldest=最舊
pull.request.list.filter.sort.recently.updated=最近更新
pull.request.list.filter.state=狀態
pull.request.list.filter.state.closed=已關閉
pull.request.list.filter.state.merged=已合併
pull.request.list.filter.state.open=開放
pull.request.list.filters.clear=清除篩選器
pull.request.list.no.matches=沒有與篩選器符合的拉取請求
pull.request.list.nothing.loaded={0} 中沒有拉取請求
pull.request.list.outdated=該列表已過時。
pull.request.list.refresh=重新整理
pull.request.loading.status=正在載入拉取請求狀態
pull.request.merge.commit.action=合併拉取請求…
pull.request.merge.disabled=此專案已停用合併
pull.request.merge.pull.request=合併拉取請求 \\#{0,number,\\#}
pull.request.new.diff.editor.title=新拉取請求的差異
pull.request.no.labels=無標籤
pull.request.no.reviewers=無審查者
pull.request.notification.create.action=建立拉取請求
pull.request.notification.open.action=開啟拉取請求
pull.request.on.branch={1} 上的 \\#{0,number,\\#}
pull.request.on.branch.description=當前分支 {1} 存在拉取請求 \\#{0,number,\\#}
pull.request.on.branch.error=當前分支 {1} 存在拉取請求 \\#{0,number,\\#}，但拉取請求詳細資訊載入失敗
pull.request.on.branch.loading=正在載入拉取請求 \\#{0,number,\\#} 的更改
pull.request.on.branch.out.of.sync=當前分支 {1} 存在拉取請求 \\#{0,number,\\#}，但本地分支與遠端分支不同步
pull.request.on.branch.update.failed.title=拉取請求分支更新失敗
pull.request.open.action=檢視拉取請求
pull.request.open.action.description=檢視拉取請求資訊和時間線
pull.request.post.action=發佈拉取請求
pull.request.refresh.details.action=重新整理拉取請求
pull.request.refresh.list.action=重新整理列表
pull.request.removing.reviewers=正在移除審查者
pull.request.reopen.action=重新開啟拉取請求
pull.request.repo.access.required=必須具有版本庫存取權限才能管理拉取請求
pull.request.repo.write.access.required=必須具有版本庫寫存取權限才能合併拉取請求
pull.request.resolveConflicts.error.remoteNotFound=找不到 {0} 遠端\\: {1}
pull.request.resolveConflicts.error.repositoryNotFound=找不到 {0} 版本庫
pull.request.review.actions.submit={0, choice, 0\\#提交審查…|1\\#提交審查({0})…}
pull.request.review.editor.add.review.comment=新增審查評論
pull.request.review.editor.add.single.comment=新增一條評論
pull.request.review.editor.start.review=開始審查
pull.request.review.refresh.data.task=重新整理審查資料
pull.request.review.refresh.data.task.description=重新整理 GitHub 拉取請求審查資訊
pull.request.review.submit.action.description=提交拉取請求審查
pull.request.review.submit.approve.button=批准
pull.request.review.submit.comment.button=評論
pull.request.review.submit.comment.description=提交不需要明確批准的一般反饋
pull.request.review.submit.request.changes=請求更改
pull.request.reviewers=審查者\\:
pull.request.reviewers.popup={0, choice, 1\\#審查者|2\\#審查者}
pull.request.select.action=選擇開放的拉取請求
pull.request.timeline.approved.changes=批准了這些更改
pull.request.timeline.branch.deleted=刪除了 {0} 分支
pull.request.timeline.branch.force.pushed=強制推送了 {0} 分支
pull.request.timeline.branch.head.restored=還原了 head 分支
pull.request.timeline.cannot.load=無法載入時間線條目
pull.request.timeline.changed.base.branch=更改了基礎分支
pull.request.timeline.closed=關閉了此請求
pull.request.timeline.comment.suggested.changes=建議的更改
pull.request.timeline.comment.suggested.changes.action.commit.name=提交…
pull.request.timeline.comment.suggested.changes.button=區域套用
pull.request.timeline.comment.suggested.changes.progress.bar.apply=套用建議的更改
pull.request.timeline.comment.suggested.changes.progress.bar.commit=提交建議的更改
pull.request.timeline.comment.suggested.changes.tooltip.different.branch=無法在其他分支中套用來自拉取請求的建議更改
pull.request.timeline.comment.suggested.changes.tooltip.outdated=無法套用過時的建議
pull.request.timeline.comment.suggested.changes.tooltip.resolved=此建議已解決
pull.request.timeline.commit.added=已將提交新增到此拉取請求
pull.request.timeline.commits.added=已將 {0} 個提交新增到此拉取請求
pull.request.timeline.connected=鏈接了可能由此物件關閉的問題
pull.request.timeline.disconnected=移除了一個指向問題的鏈接
pull.request.timeline.event.assigned=指派 {0}
pull.request.timeline.event.assigned.and.unassigned=指派 {0} 並取消指派 {1}
pull.request.timeline.event.labels.added=新增標籤 {0}
pull.request.timeline.event.labels.added.and.removed=新增標籤 {0} 並移除 {1}
pull.request.timeline.event.labels.removed=移除標籤 {0}
pull.request.timeline.event.removed.review.request=從 {0} 中移除審查請求
pull.request.timeline.event.requested.review=從 {0} 請求審查
pull.request.timeline.event.requested.review.and.removed.review.request=從 {0} 請求審查並從 {1} 中移除審查請求
pull.request.timeline.event.unassigned=取消指派 {0}
pull.request.timeline.marked.as.draft=將此拉取請求標記為草稿
pull.request.timeline.marked.as.ready=將此拉取請求標記為可供審查
pull.request.timeline.mentioned=提及了此拉取請求
pull.request.timeline.merged=合併了此請求
pull.request.timeline.merged.commit=已將提交 {0} 合併到 {1}
pull.request.timeline.no.description=未提供描述
pull.request.timeline.refresh.action=重新整理時間線
pull.request.timeline.refresh.action.description=檢查新時間線事件
pull.request.timeline.renamed=將此拉取請求從 ''{0}'' 重命名為 ''{1}''
pull.request.timeline.reopened=重新開啟了此請求
pull.request.timeline.requested.changes=請求了更改
pull.request.timeline.reviewed=審查了更改
pull.request.timeline.stale.review.dismissed=忽略了 <b>{0}</b> 過時的審查
pull.request.timeline.started.review=開始了審查
pull.request.unassigned=未分配
pull.request.unresolved.comments={0,choice,0\\#沒有未解決的註釋|1\\#{0} 個未解決的註釋|2\\#{0} 個未解決的註釋}
pull.request.view.conversations.action.description=檢視拉取請求時間線
pull.request.view.list=檢視拉取請求
rebase.error=無法執行 GitHub 重定基底
rebase.error.failed.to.match.gh.repo=無法符合本地版本庫和 GitHub 版本庫
rebase.error.multi.repo.not.supported=不支持多版本庫專案
rebase.error.no.default.branch=無法確定上游分支 - 沒有為版本庫設定預設分支
rebase.error.no.suitable.account.found=找不到合適的 GitHub 帳戶
rebase.error.remote.origin.not.found=找不到 Git 遠端 'origin'
rebase.error.repo.not.found=找不到版本庫 {0}
rebase.error.upstream.not.found=未新增遠端 {0}
rebase.process=正在重定基底 GitHub 複刻…
rebase.process.adding.github.parent.as.remote.host=正在將 GitHub 父項新增為遠端主機…
rebase.process.configuring.upstream.remote=正在組態上游遠端…
rebase.process.fetching.upstream=正在獲取上游…
rebase.process.operation.title=正在重定基底
rebase.process.rebasing.branch.onto=正在將當前分支重定基底到 ''{0}''…
rebase.process.success=已成功重定基底 GitHub 複刻
request.response.0=請求響應\\: {0}。
retry.action=重試
retry.link=重試
server.unreachable=伺服器無法到達
settings.automatically.mark.as.viewed=自動將開啟的檔案標記為已檢視
settings.clone.ssh=使用 ssh 克隆 Git 版本庫
settings.configurable.display.name=GitHub
settings.enable.pr.seen.markers=在列表中的拉取請求上啟用未讀標記
settings.timeout=連線超時\\:
settings.timeout.seconds=秒
share.button=共享
share.dialog.account.info.load.error.prefix=無法載入 {0} 的資訊\\:
share.dialog.account.info.load.process.canceled=已取消程序
share.dialog.description=描述\\:
share.dialog.private=私有
share.dialog.remote=遠端\\:
share.dialog.repo.name=版本庫名稱\\:
share.dialog.share.by=共享者\\:
share.error.private.repos.not.supported=您的帳戶不支持私有版本庫
share.error.remote.with.selected.name.exists=已存在具有所選名稱的遠端
share.error.repo.with.selected.name.exists=已存在具有所選名稱的版本庫
share.on.github=在 GitHub 上共享專案
share.validation.invalid.repo.name=版本庫名稱無效。名稱應由字母、數字、短划線、點和下劃線組成
share.validation.no.remote.name=未選擇遠端名稱
share.validation.no.repo.name=未選擇版本庫名稱
tab.title.pull.requests.new=在 {0} 新增拉取請求
task.comment.author=作者\\:
task.comment.date=日期\\:
task.repo.host.field=主機\\:
task.repo.name.field.empty.hint=版本庫名稱
task.repo.owner.field.empty.hint=版本庫所有者
task.repo.repository.field=版本庫\\:
task.repo.token.create.button=建立 API 令牌
task.repo.token.field=API 令牌\\:
task.repo.token.field.empty.hint=OAuth2 令牌
toolwindow.stripe.Pull_Requests=拉取請求
toolwindow.stripe.Pull_Requests.shortName=PR
unknown.host.error=未知主機\\: {0}
unknown.loading.error=未知載入錯誤
"
`;

exports[`src messages/IdeBundle.properties 1`] = `
"FileChooser.detailsViewActionLabelText=詳細資訊
FileChooser.listViewActionLabelText=列表
FileChooser.newFolderActionLabelText=新增目錄
FileChooser.refreshActionLabelText=重新整理
FileChooser.viewMenuLabelText=檢視
ShowUsagesTableCellRenderer.accessible.CURRENT_ASTERISK_COL=當前用法
ShowUsagesTableCellRenderer.accessible.FILE_GROUP_COL=檔案 {0}
ShowUsagesTableCellRenderer.accessible.LINE_NUMBER_COL=行 {0}
ShowUsagesTableCellRenderer.accessible.OTHER_ASTERISK_COL=另一種用法
ShowUsagesTableCellRenderer.accessible.USAGE_TEXT_COL=用法文本 {0}
about.box.build.date=，{0} 建置
about.box.build.date.omitted.in.dev.build.mode=，在開發建置模式中省略了建置日期
about.box.build.date.time=，{0} {1} 建置
about.box.build.number=構建版本 \\#{0}
about.box.copyright=版權所有 © {0}–{1} <hyperlink>{2}</hyperlink>
about.box.jcef=JCEF {0}.{1}.{2}
about.box.jre=運行時版本\\: {0} {1}
about.box.powered.by=由<hyperlink>開源軟體</hyperlink>提供支援
about.box.vm=VM\\: {0}，{1}
about.popup.about.app=關於 {0}
about.popup.system.info=系統資訊\\n{0}\\n{1}
accessibility.filter.label={0}\\: {1}
accessible.name.annotation=註解\\: {0}
accessible.name.empty=空
accessible.name.icon=圖示\\: {0}
accessible.name.line=行 {0}
action.ActionTracer.Anonymous.description.clear.log=清除日誌
action.ActionTracer.Anonymous.text.Clear=清除
action.AnAction.description.activate.frame.and.run=啟用框架並執行
action.AnAction.description.clear=清除
action.AnAction.description.new.script=新增腳本
action.AnAction.description.reload.list=重新載入列表
action.AnAction.description.run.on.frame.activation=在框架啟用時執行
action.AnAction.description.save=儲存
action.AnAction.description.search.history=搜尋歷史記錄
action.AnAction.description.set.script.file=設定腳本檔案
action.AnAction.description.stop=停止
action.AnAction.text.activate.frame.and.run=啟用框架並執行
action.AnAction.text.clear=清除
action.AnAction.text.new.script=新增腳本
action.AnAction.text.reload.list=重新載入列表
action.AnAction.text.run.on.frame.activation=在框架啟用時執行
action.AnAction.text.save=儲存
action.AnAction.text.search.history=搜尋歷史記錄
action.AnAction.text.set.script.file=設定腳本檔案
action.AnAction.text.stop=停止
action.AnActionButton.text.change.goto.check.box=更改“轉到”複選框
action.AnActionButton.text.install=安裝
action.AnActionButton.text.reload.list.of.packages=重新載入軟體套件列表
action.AnActionButton.text.uninstall=移除
action.AnActionButton.text.upgrade=升級
action.Anonymous.text.add.abbreviation=新增縮寫
action.Anonymous.text.add.keyboard.shortcut=新增鍵盤快捷鍵
action.Anonymous.text.add.mouse.shortcut=新增滑鼠快捷方式
action.Anonymous.text.all=所有
action.Anonymous.text.back=後退
action.Anonymous.text.change.context=更改上下文…
action.Anonymous.text.configure=組態
action.Anonymous.text.delete.hook=刪除掛鈎
action.Anonymous.text.do.not.show.again=不再顯示
action.Anonymous.text.done=完成
action.Anonymous.text.edit.scopes.order=編輯作用域順序…
action.Anonymous.text.highlight=醒目提示顯示
action.Anonymous.text.live.template=實時模板
action.Anonymous.text.live.templates=實時模板
action.Anonymous.text.new.group=新增組…
action.Anonymous.text.new.tag=新增標記
action.Anonymous.text.remove.leading.directory=移除前導目錄
action.Anonymous.text.rename=重新命名
action.Anonymous.text.reset.shortcuts=重設快捷鍵
action.Anonymous.text.restore.leading.directory=還原前導目錄
action.Anonymous.text.start.trial=開始 30 天試用
action.Anonymous.text.template.group=模板組…
action.Anonymous.text.toggle=切換
action.CallHierarchy.BaseOnThisMethod.text=基於此方法
action.ChangeProjectColorAction.Amber.title=琥珀色
action.ChangeProjectColorAction.Cobalt.title=鈷藍色
action.ChangeProjectColorAction.Current.title={0} (當前)
action.ChangeProjectColorAction.Grass.title=草綠色
action.ChangeProjectColorAction.Ocean.title=海藍色
action.ChangeProjectColorAction.Olive.title=橄欖色
action.ChangeProjectColorAction.Plum.title=紫紅色
action.ChangeProjectColorAction.Rust.title=Rust
action.ChangeProjectColorAction.Sky.title=天藍色
action.ChangeProjectColorAction.Violet.title=紫色
action.ChooseCustomProjectColorAction.title=自訂顏色…
action.CollapseAllAction.text.collapse.all=全部摺疊
action.ComboContentLayout.close.other.views.text=關閉其他檢視
action.ComboContentLayout.close.view.text=關閉檢視
action.ComboContentLayout.select.next.view.text=選擇下一個檢視
action.ComboContentLayout.select.previous.view.text=選擇上一個檢視
action.DataSharingOptionsAction.description=資料共享選項
action.DataSharingOptionsAction.text=資料共享選項…
action.DescriptionAwareSchemeActions.add.description.text=新增描述…
action.DescriptionAwareSchemeActions.edit.description.text=編輯描述…
action.DumbAware.BuildView.text.stop=BuildView
action.DumbAware.CopyrightProfilesPanel.description.stop=停止
action.DumbAware.TerminalView.text.new.session=新增會話
action.Events=事件
action.ExpandAllAction.text.expand.all=全部展開
action.FinderRecursivePanel.text.edit=編輯
action.FinderRecursivePanel.text.next=下一個
action.FinderRecursivePanel.text.previous=上一個
action.GetHelp=獲取幫助
action.InstallFromDiskAction.not.allowed.description=您的組織不允許從磁碟安裝延伸模組
action.InstallFromDiskAction.progress.text=正在安裝延伸模組
action.InstallFromDiskAction.text=從磁碟安裝延伸模組…
action.MarkAllNotificationsAsReadAction.description=將所有未讀通知標記為已讀
action.MarkAllNotificationsAsReadAction.text=將所有通知標記為已讀
action.MethodHierarchy.BaseOnThisMethod.text=基於此方法
action.NamedItemsListEditor.AddAction.description.add=新增
action.NamedItemsListEditor.AddAction.text.add=新增
action.NamedItemsListEditor.CopyAction.description.copy=複製
action.NamedItemsListEditor.CopyAction.text.copy=複製
action.OpenUrlHyperlinkInfo.Anonymous.description.copy.url.to.clipboard=將 URL 複製到剪貼簿
action.OpenUrlHyperlinkInfo.Anonymous.text.copy.url=複製 URL
action.QuickChangeCodeStyleSchemeAction.Anonymous.text.project=<專案>
action.ReopenProject.reopen.project.text=重新開啟專案
action.SwitchToJBR.text=切換到捆綁執行時
action.ToggleAction.description.pin.window=固定視窗
action.ToggleAction.description.toggle.auto.test=程式碼更改時切換測試的自動重新執行
action.ToggleAction.show.filter.description.show.filters.popup=顯示篩選器彈出視窗
action.ToggleAction.show.filter.text.filter=篩選
action.ToggleAction.text.filter=篩選
action.ToggleAction.text.filter.files.by.type=按類型篩選檔案
action.ToggleAction.text.pin.window=固定視窗
action.ToggleAction.text.toggle.auto.test=自動重新執行
action.ToggleAction.text.toggle.view=切換檢視
action.TypeHierarchyBase.BaseOnThisType.text=基於此類別
action.UpdateIde.button.postpone=推遲
action.UpdateIde.installed=已安裝新版本\\: {0}
action.UpdateIde.progress.text.ide.will.restart=IDE 將在 {0, choice, 1\\#1 秒|2\\#{0} 秒}後重啟
action.UpdateIde.progress.title=新安裝準備就緒
action.UpdateIde.task.success.content=新安裝準備就緒
action.UpdateIde.task.success.restart=重新啟動
action.UpdateIde.task.success.title=IDE 更新
action.activate.tool.window=啟用{0}視窗
action.add.all.open.tabs.to.new.favorites.list=將所有開啟的頁籤新增到新收藏夾列表
action.add.repository=新增延伸模組庫
action.add.to.new.favorites.list=新增到新收藏夾列表(_N)
action.add.to.new.favorites.list.description=新增到新收藏夾列表
action.append=追加
action.base.on.this.0=基於此{0}
action.browse.call.hierarchy=瀏覽呼叫層次結構
action.browse.method.hierarchy=瀏覽方法層次結構
action.browse.type.hierarchy=瀏覽類型層次結構
action.callee.methods.hierarchy=被呼叫方方法層次結構
action.caller.methods.hierarchy=呼叫方方法層次結構
action.choose.actions.to.add=新增動作
action.clear.encoding.description=清除預設編碼。
action.clear.encoding.description.file=清除檔案 ''{0}'' 編碼。
action.close=關閉(_C)
action.close.all.editors.above=關閉上方頁籤
action.close.all.editors.below=關閉下方頁籤
action.close.all.editors.in.tab.group=關閉組內所有頁籤(_A)
action.close.all.readonly.editors=關閉所有唯讀項
action.close.all.readonly.editors.in.tab.group=關閉組中的所有唯讀項
action.close.all.unmodified.editors=關閉未修改頁籤(_U)
action.close.all.unmodified.editors.in.tab.group=關閉組內未修改頁籤(_U)
action.close.all.unpinned.editors=關閉所有未固定頁籤
action.close.all.unpinned.editors.in.tab.group=關閉組中的未固定頁籤
action.close.projects.in.current.window=關閉當前視窗中的專案(_J)
action.collapse=摺疊
action.collapse.all=全部摺疊
action.compact.empty.middle.packages=壓縮空的中間軟體套件
action.copy.link.text=複製 {0} 鏈接
action.copy.path=複製絕對路徑(_O)
action.copy.paths=複製絕對路徑(_O)
action.copy.template=複製模板
action.create.child.template=建立子模板檔案
action.create.new.class.name.field=名稱
action.create.new.class.templates.list.accessible.name=模板
action.create.template=建立模板
action.customizations.customize.action=自訂工具列…
action.delete=刪除(_D)
action.delete.ellipsis=刪除(_D)…
action.description.clear.the.contents.of.the.event.log=清除事件日誌的內容
action.description.create.new.module.group=建立新模組組
action.description.create.new.package=建立新的軟體套件
action.description.edit.notification.settings=編輯通知設定
action.description.pin.tool.window.to.0.side.ui.designer.editor=將工具視窗固定到{0}側 UI 設計器編輯器
action.description.show.files=顯示/隱藏檔案
action.description.show.included.only=僅顯示包含到當前所選作用域的檔案
action.description.show.modules=顯示/隱藏模組
action.description.todo.show.all=顯示全部 TODO 項
action.description.unpin.tool.window.from.designer.editor=從設計器編輯器取消固定工具視窗
action.description.view.class.hierarchy=選擇類別層次結構
action.description.view.subtypes.hierarchy=切換到子類型層次結構
action.description.view.supertypes.hierarchy=切換到父類型層次結構
action.descriptor.action=動作\\: {0}
action.descriptor.keystroke=按鍵\\:“{0}”
action.descriptor.typing=輸入\\:“{0}”
action.directory=目錄
action.dont.show.again.text=不再顯示
action.download.and.install.plugin=下載並安裝
action.edit.file.templates=編輯檔案模板…
action.edit.repository.url=編輯儲存庫 URL
action.empty.group.text=空組
action.empty.unnamed.group.text=空未命名組
action.enable.disable.global.menu.integration.description=啟用/停用全域選單整合(所有框架)
action.exclude.all.text=全部排除
action.expand=展開
action.expand.all=全部展開
action.explorer.text=資源管理器
action.file.manager.text=檔案管理器
action.filter.todo.items=篩選 TODO 條目
action.finder.text=訪達
action.flatten.packages=平展軟體套件
action.flatten.view=平展檢視
action.fn.keys.text=Fn 鍵
action.from.file.template=從檔案模板…
action.group.by.modules=模組
action.group.by.packages=軟體套件
action.group.macos.shortcuts.text=macOS 快捷鍵
action.group.name.unnamed.group=<未命名組>
action.help=幫助
action.hide.all.windows=隱藏所有視窗(_W)
action.hide.empty.middle.packages=隱藏空的中間軟體套件
action.hide.non.implementations=隱藏方法未合法實作的類別
action.include.all.text=全部包含
action.invoke.macro.text=呼叫巨集
action.jcef.restart=重啟
action.label.hide.notification=隱藏通知
action.manual.order=手動排序
action.maximize.editor=最大化編輯器
action.maximize.text=最大化
action.move.module.new.top.level.group=新增頂層組…
action.move.module.outside.any.group=在任意組外
action.move.module.to.new.sub.group=到新子組…
action.move.module.to.this.group=到此組
action.new.package=新增軟體套件…
action.next.message=下一條訊息
action.next.problem=下一個問題
action.next.tip=下一步(&N)
action.next.todo=下一個 TODO
action.normalize.splits=標準化拆分
action.open.editor.settings.text=開啟設定
action.open.tip=開啟(&O)…
action.open.web.preview.text=內建預覽
action.overwrite=覆蓋
action.package=軟體套件
action.pin.tab=固定頁籤(_I)
action.presentation.AbstractSchemesPanel.description=顯示方案動作
action.presentation.AbstractSchemesPanel.text=顯示方案動作
action.presentation.EditorTabbedContainer.text=關閉。按 {0} 並點擊以關閉其他。
action.presentation.EncodingPanel.text=檔案編碼
action.presentation.ExtractIncludeAction.text=Include 檔案…
action.presentation.FindAllAction.text=搜尋全部
action.presentation.LightEditTabs.text=關閉。按 {0} 並點擊以關閉其他。
action.presentation.OpenSelectedProjectsAction.text.open.all.projects.in.group=開啟組中的所有專案
action.presentation.OpenSelectedProjectsAction.text.open.selected=開啟選定專案
action.presentation.RegistryUi.text=還原為預設值
action.presentation.RegistryUi.text.edit=編輯
action.presentation.RemoveSelectedProjectsFromGroupsAction.text=從組中移除
action.presentation.ShowUiDebuggerAction.text=UI 偵錯器
action.presentation.WeighingActionGroup.text=其他
action.previous.message=上一條訊息
action.previous.problem=上一個問題
action.previous.tip=返回(&B)
action.previous.todo=上一個 TODO
action.refresh=重新整理
action.remove=移除
action.remove.repository.from.list=從列表中移除儲存庫
action.remove.template=移除模板
action.reopen.project.display.name.with.branch={0}  [{1}]
action.reset.font.size=重設為 {0}pt
action.reset.font.size.all.editors=在所有編輯器中重設為 {0}pt
action.reset.font.size.info=字體大小\\: {0}pt
action.reset.to.default=還原為原始模板
action.restore.windows=還原視窗(_W)
action.select.none=無選擇(&N)
action.send.to.new.favorites.list=發送至新收藏夾列表
action.separator=分隔符({0})
action.separator.file.templates=檔案模板
action.show.classes=顯示類別
action.show.compact.empty.middle.packages=顯示/壓縮中間軟體套件
action.show.files=顯示檔案
action.show.hide.empty.middle.packages=顯示/隱藏空的中間軟體套件
action.show.included.only=僅顯示包含的檔案
action.show.infos=顯示資訊訊息
action.show.members=顯示成員
action.show.modules=顯示模組
action.show.warnings=顯示警告
action.start.macro.recording=開始巨集錄製(_M)
action.stop=停止
action.stop.macro.recording=停止錄製巨集 (_M)
action.switch.project.text=切換專案
action.sync.completed.successfully=檔案同步已成功完成。
action.text.change.encoding=將編碼更改為 ''{0}''
action.text.change.system.shortcuts=更改系統快捷鍵
action.text.clear.all=全部清除
action.text.copy=複製(&C)
action.text.copy.link.address=複製鏈接地址
action.text.disable.input.methods=停用輸入方法
action.text.editor.mode.none=無
action.text.hide.chessboard=隱藏棋盤
action.text.hide.file.name=隱藏檔名
action.text.hide.file.size=隱藏檔案大小
action.text.hide.grid=隱藏網格
action.text.hide.tags.panel=隱藏標記面板
action.text.install.keymap=安裝 {0} 按鍵映射
action.text.merge.tabs.to.group=將頁籤合併到 ''{0}'' 組
action.text.modify.shortcut=修改快捷鍵
action.text.modify.shortcuts=修改快捷鍵
action.text.more=更多
action.text.open.link.in.browser=在瀏覽器中開啟鏈接
action.text.reload.file=重新載入檔案
action.text.remove.0=移除 {0}
action.text.remove.abbreviation.0=移除縮寫 ''{0}''
action.text.remove.all.shortcuts=移除所有快捷鍵
action.text.search.for.keymap=搜尋 {0} 按鍵映射延伸模組
action.text.select.next.tab=選擇下一個頁籤
action.text.select.previous.tab=選擇上一個頁籤
action.text.settings=設定
action.text.show.chessboard=顯示棋盤
action.text.show.file.name=顯示檔名
action.text.show.file.size=顯示檔案大小
action.text.show.grid=顯示網格
action.text.show.tags.panel=顯示標記面板
action.text.split.group=拆分 ''{0}'' 組
action.title.group.by.directory=按目錄分組
action.todo.edit.filters=編輯篩選器
action.todo.edit.filters.description=編輯篩選器
action.todo.show.all=全部顯示
action.toggle.global.menu.integration.text=切換全域選單整合
action.unpin.tab=取消固定頁籤(_I)
action.unpin.tab.tooltip=取消固定頁籤
action.view.class.hierarchy=類別層次結構
action.view.subtypes.hierarchy=子類型層次結構
action.view.supertypes.hierarchy=父類型層次結構
actions.on.save.background.progress=儲存時執行動作
actions.on.save.label.activated.on.any.save=任何儲存
actions.on.save.label.activated.on.any.save.and.external.change=<html>任何儲存和<br/>外部更改</html>
actions.on.save.label.activated.on.explicit.save=顯式儲存
actions.on.save.label.activated.on.explicit.save.with.0.shortcut=顯式儲存({0})
actions.on.save.link.all.actions.on.save=儲存時的所有動作…
actions.on.save.link.configure=組態…
actions.on.save.link.configure.autosave.options=組態自動儲存選項…
actions.on.save.option.activated.on.any.save.and.external.change=任何儲存和外部更改
actions.on.save.option.activated.on.any.save.including.autosave=任何儲存(包括自動儲存)
actions.on.save.page.title=儲存時的動作
actions.on.save.processing.file={0}\\: 正在處理 {1}
actions.on.save.table.column.name.action=動作
actions.on.save.table.column.name.activated.on=啟用條件
activation.file.is.waiting.dismiss=消除
activation.file.is.waiting.do.not.show=不再顯示
activation.file.is.waiting.notification=指令行將一直等待，直到檔案 ''{0}'' 關閉。
activation.file.is.waiting.release=釋放
activation.file.is.waiting.title=指令行將一直等待，直到此檔案關閉
activation.not.initialized=IDE 尚未初始化
activation.project.is.waiting.notification=指令行將一直等待，直到專案 ''{0}'' 關閉。
activation.shutting.down=IDE 正在關閉
activation.unknown.error=意外錯誤\\: {0}
add.byte.order.mark.to=向 {0} 新增位元組順序標記
add.local.scope.action.text=本地
add.module.popup.title=新增模組
add.scope.dialog.title=新增新作用域
add.scope.name.label=名稱
add.scope.popup.title=新增作用域
add.shared.scope.action.text=共享
add.source.header.popup.title=新增源和標題
alphabetical.mode.is.on.notification=已關閉按字母順序排列的制表符順序
analyze.plugin.title=每個延伸模組的啟動時間成本
appearance.ui.option.group=UI
appearance.view.option.group=檢視
appearance.window.option.group=視窗
archiving.logs.progress.title=正在製作日誌歸檔
archiving.user.logs.progress.title=正在將使用者日誌新增到歸檔
assign.custom.shortcuts.or.change.the.macos.system.settings=分配自定義快捷鍵或更改 macOS 系統設定。
attachable.project.pane.name=檔案
available.packages.dialog.title=可用軟體套件
background.image.button=背景圖像…
banner.button.close=關閉
before.run.component.accessible.name=在啟動選項之前
big.popup.filter.button.all=所有
big.popup.filter.button.invert=反轉
big.popup.filter.button.none=無
binary.file.too.large=二進制檔案 {0} 太大({1})
border.title.command.output=指令輸出
border.title.description=描述
border.title.problem.files=問題檔案
browse.custom.icon.hint=要設定自訂圖示，請指定 SVG 或 PNG 檔案的路徑。
browser.default.not.supported=抱歉，IDE 不知道如何在此系統上啟動預設瀏覽器。
browser.error=瀏覽器錯誤
browser.notification.timeout.group=在瀏覽器中開啟頁面超時
browser.notification.timeout.text=無法在瀏覽器中開啟 <a href\\="{0}">{1}</a>，因為 URL 未響應。
browser.notification.timeout.title=URL 未響應
browser.preview.file.title={0} 的預覽
browser.select.in.default.name=Web 瀏覽器
browser.shortcut=按住 Shift 以開啟本地檔案 URL
browser.shortcut.or.shift={0}，按住 Shift 以開啟本地檔案 URL
browser.url.popup=選擇 URL
browsers.chrome=Chrome
browsers.explorer=Internet Explorer
browsers.firefox=Firefox
browsers.safari=Safari
browsers.settings=Web 瀏覽器和預覽
buildToolWindow.tree.accessibleName=建置結果
bundled.jre.arch.mismatch.download=下載…
bundled.jre.arch.mismatch.mac=為 Apple Silicon 下載 {0} 以獲得更好的性能和穩定性。
bundled.jre.arch.mismatch.win=為 ARM64 下載 {0} 以獲得更好的性能和穩定性。
bundled.jre.version.message=請考慮切換到更適合 IDE 的捆綁 Java Runtime(您當前的 Java Runtime 為 {0}，來自 {1}，位置為 ''{2}'')。
button.add.action=新增動作(&A)…
button.add.separator=新增分隔符 (&S)
button.back=後退
button.cancel=取消(&C)
button.cancel.without.mnemonic=取消
button.choose=選擇
button.clear.and.close=清除並關閉
button.continue.editing=繼續編輯
button.convert=轉換
button.convert.anyway=仍然轉換
button.copy=複製(&C)
button.copy.and.close=複製並關閉
button.create=建立(&C)
button.delete=刪除
button.disable=停用
button.disable.selected.plugins=停用所選延伸模組
button.do.not.send=不發送
button.done=完成
button.edit.action.icon=編輯圖示(&I)…
button.enable.all=全部啟用
button.enable.updated.plugins=啟用更新的{0,Choice,1\\#Plugin|2\\#Plugins}
button.exclude=排除
button.exclude.recursively=遞迴排除
button.existing.frame=此視窗(&T)
button.facet.quickfix.text=修正(&F)
button.finish=完成(&F)
button.fix=修正…
button.fix.it=修復
button.help=幫助(&H)
button.http.proxy.settings=HTTP 代理設定(&H)…
button.i.want.to.edit.all.files.in.choice.this.directory={0, choice, 1\\#此目錄|2\\#這些目錄}中的所有檔案
button.i.want.to.edit.any.non.project.file.in.current.session=任何非專案檔案
button.i.want.to.edit.choice.this.directory.anyway={0, choice, 1\\#此目錄|2\\#這些目錄}
button.i.want.to.edit.choice.this.file.anyway={0, choice, 1\\#此文件|2\\#這些檔案}
button.include=包含
button.include.recursively=遞迴包含
button.invalidate.and.exit=清除並離開(&E)
button.invalidate.and.restart=失效並重啟(&R)
button.just.restart=重新啟動
button.later=稍後{0,choice,0\\#重啟|1\\#關閉}
button.move.down=下移 (&D)
button.move.up=上移(&U)
button.new.frame=新視窗 (&W)
button.next=下一個
button.now=立即{0,choice,0\\#重啟|1\\#關閉}
button.ok=確定 (&O)
button.previous=上一個
button.reject=拒絕
button.reload=重新載入
button.reload.anyway=仍然重新載入
button.remove=移除(&R)
button.remove.from.list=從列表中移除(\\\\&R)
button.rename=重新命名
button.repaint.icons=重新繪製圖示(&R)
button.restore.all=恢復所有預設設定(&L)
button.restore.defaults=恢復預設設定
button.restore.last.state=還原上次狀態
button.restore.selected.groups=還原選定組
button.restore.selection=還原{0}
button.save=儲存
button.save.anyway=仍然儲存
button.set.0=設定 {0}
button.skip=跳過
button.wizard.next=下一步 (&N)
button.wizard.previous=上一步 (&P)
button.yes=是(_Y)
cannot.delete.jre.config=無法刪除執行時組態檔案 ''{0}''\\: {1}
cannot.redo.message=無法重做
cannot.redo.title=無法重做
cannot.undo.error.contains.nonundoable.changes.message=<html>無法執行 ''{0}''<br>以下檔案包含無法撤消的更改\\:
cannot.undo.error.other.affected.files.changed.message=受此動作影響的以下檔案已更改\\:
cannot.undo.error.other.users.overwrote.changes.message=您對以下檔案的更改已被其他使用者覆蓋\\:
cannot.undo.message=無法撤消
cannot.undo.title=無法撤消
change.encoding.command.name=更改 ''{0}'' 的編碼
change.memory.code.cache=程式碼快取大小
change.memory.direct.buffers=直接緩衝區限制
change.memory.max.heap=堆大小上限
change.memory.metaspace=元空間大小
change.memory.min.heap=初始堆大小
channel.status.beta=Beta 版本或公開預覽
channel.status.eap=搶先體驗計劃
channel.status.milestone=里程碑 EAP 建置
channel.status.stable=穩定版本
checkbox.accessibility.contrast.scrollbars=使用對比度捲軸
checkbox.also.in.reader.mode=也適用於<a>閱讀器模式</a>
checkbox.case.sensitive=區分大小寫
checkbox.colors.only=僅顏色
checkbox.compact.mode=緊湊模式
checkbox.compact.mode.description=UI 元素佔用更少的螢幕空間
checkbox.compact.tree.indents=使用較小的縮排
checkbox.confirm.application.exit=離開 IDE 之前確認
checkbox.copy.javadoc=複製 JavaDoc(&J)
checkbox.create.the.entry.for.all.users.requires.superuser.privileges=為所有用戶建立條目(需具備超級使用者權限)(&A)
checkbox.customfiletype.ignore.case=忽略情況 (&I)
checkbox.customfiletype.support.paired.braces=支援配對大括號 (&R)
checkbox.customfiletype.support.paired.brackets=支援配對中括號 (&C)
checkbox.customfiletype.support.paired.parens=支援配對小括號 (&P)
checkbox.customfiletype.support.string.escapes=支援字串轉義 (&E)
checkbox.disabled.included=包括停用的動作(&D)
checkbox.enable.live.templates=啟用實時模板 (&L)
checkbox.errortree.export.details=詳細資訊
checkbox.expand.node.with.single.click=單擊展開節點
checkbox.expand.node.with.single.click.comment=某些樹可能會忽略此設定
checkbox.full.paths.in.window.header=始終在視窗標題中顯示完整路徑
checkbox.ide.mac.app.icon=自訂應用程式圖示
checkbox.inject.reveal.library.on.launch=啟動時注入 Reveal 庫
checkbox.insert.at.override=插入 @Override(&O)
checkbox.keep.popups.for.toggles=切換條目時保持彈出視窗開啟
checkbox.left.toolwindow.layout=左側並排布局
checkbox.merge.main.menu.with.window.title=合併主選單和視窗標題
checkbox.narrow.down.on.typing=在輸入時縮小(&N)
checkbox.narrow.down.the.list.on.typing=在輸入時縮小列表(&N)
checkbox.override.default.laf.fonts=使用自訂字體\\:
checkbox.password.safe.remember=記住(&R)
checkbox.reformat.according.to.style=按照樣式重新設定格式(&R)
checkbox.remember.size.for.each.tool.window=記住每個工具視窗的大小
checkbox.remote.sdk.run.as.root.via.sudo=通過 sudo 作為 root 執行
checkbox.right.toolwindow.layout=右側並排布局
checkbox.safe.delete.with.usage.search=安全刪除(帶有用法搜尋)(&F)
checkbox.safe.write=儲存前備份檔案
checkbox.save.files.automatically=如果 IDE 空閒則儲存檔案
checkbox.save.files.on.frame.deactivation=切換到其他應用程式或內建終端時儲存檔案
checkbox.show.editor.preview.popup=懸停在捲軸上時顯示程式碼透鏡
checkbox.show.icons.in.menu.items=在選單項顯示圖示
checkbox.show.rendered.doc.comments=渲染文檔註釋
checkbox.show.tips.on.startup=啟動時不顯示小技巧
checkbox.show.tool.window.bars=顯示工具視窗列
checkbox.show.tool.window.names=顯示工具視窗名稱
checkbox.show.tool.window.numbers=顯示工具視窗編號
checkbox.show.tree.indent.guides=顯示縮排參考線
checkbox.smooth.scrolling=平滑滾動
checkbox.smooth.scrolling.animated=動畫平滑滾動(&N)
checkbox.smooth.scrolling.description=使用滑鼠滾輪/觸摸板時，整個介面將平滑滾動，而不是逐行滾動
checkbox.smooth.scrolling.enable.high.precision.timer=啟用 Windows 高精度計時器
checkbox.smooth.scrolling.enable.high.precision.timer.comments=為刷新率較高的顯示器啟用更平滑的動畫。
checkbox.smooth.scrolling.enable.high.precision.timer.help=通常，預設的 Windows 計時器周期為 15.625 毫秒。因此，預設動畫每秒播放近 60 幀。此選項會在播放動畫時動態地將周期設定為較低的值。
checkbox.support.screen.readers=支援螢幕閱讀器
checkbox.synchronize.files.in.background=在 IDE 處於非活動狀態時定期(實驗性)
checkbox.synchronize.files.on.frame.activation=切換到 IDE 視窗或開啟編輯器頁籤時
checkbox.text.this.project.only=僅此專案
checkbox.todo.use.default.colors=使用配色方案 TODO 預設顏色
checkbox.transparent.native.to.ascii.conversion=自動轉換成 Ascii 但顯示原生的內容
checkbox.upload.reveal.library.on.the.device.if.necessary=如有必要，上傳裝置上的 Reveal 庫
checkbox.use.custom.user.data.directory.for.chrome=使用自訂用戶數據目錄(&U)\\:
checkbox.use.solution.colors.in.main.toolbar=在主工具列中使用專案顏色
checkbox.use.solution.colours.in.toolbar=顯示專案漸變
checkbox.use.transparent.mode.for.floating.windows=為浮動視窗使用透明模式
checkbox.widescreen.tool.window.layout=寬屏工具視窗布局
checkbox.widescreen.tool.window.layout.description=通過限制水平工具視窗的寬度，使垂直工具視窗的高度最大化
chooser.description.specifies.user.data.directory=指定儲存使用者資料(您的“組態檔案”)的目錄
chooser.title.select.profiles.ini.file=選擇 "profiles.ini" 檔案
chooser.title.select.user.data.directory=選擇使用者資料目錄
code.cache.warn.message={0} MB 的程式碼快取大小不足。請將 ''-XX\\:ReservedCodeCacheSize'' 增加到 {1} MB 或以上，以避免性能問題。
collect.client.logs.progress.title=正在收集客戶端日誌
collect.host.logs.progress.title=正在收集主機日誌
collect.local.logs.notification.error=無法收集更多日誌
collect.local.logs.progress.title=正在收集本地日誌
collect.logs.notification.error=無法使用日誌建立 .zip 檔案\\: {0}
collect.logs.notification.host.error=無法從主機收集日誌，僅儲存客戶端的日誌
collect.logs.notification.sent.success=日誌已發送至 {0}。您的 ID 為\\: {1}
collect.logs.notification.success=已建立日誌檔案\\: {0}
collect.logs.progress.title=正在收集日誌
collect.logs.sensitive.text=包含的日誌和設定中可能含有敏感資料。
collect.logs.sensitive.title=敏感資料
collect.upload.logs.progress.title=正在收集和上傳日誌
color.name.blue=藍色
color.name.brown=棕色
color.name.gray=灰色
color.name.green=綠色
color.name.orange=橙色
color.name.rose=玫瑰色
color.name.violet=紫色
color.name.yellow=黃色
colorpanel.label.alpha=A
colorpanel.label.alpha.percent=A%
colorpanel.label.blue=B
colorpanel.label.brightness=B%
colorpanel.label.green=G
colorpanel.label.hue=H°
colorpanel.label.red=R
colorpanel.label.saturation=S%
colorpicker.brightness.slider.title=亮度
colorpicker.brightness.slider.tooltip=亮度
colorpicker.colorvaluepanel.hexlabel=十六進制
colorpicker.format.hsb=HSB
colorpicker.format.rgb=RGB
colorpicker.label.blue=B\\:
colorpicker.label.brightness=B\\:
colorpicker.label.green=G\\:
colorpicker.label.hue=H\\:
colorpicker.label.red=R\\:
colorpicker.label.saturation=S\\:
colorpicker.opacity.slider.title=不透明度
colorpicker.opacity.slider.tooltip=不透明度
colorpicker.recent.color.tooltip=R\\: {0} G\\: {1} B\\: {2} A\\: {3}
column.enabled=已啟用
column.name.cost.details=成本詳細資訊
column.name.plugin=延伸模組
column.name.startup.time.ms=啟動時間(毫秒)
column.plugins.name=名稱
column.todo.filter.patterns=模式
column.todo.filters.name=名稱
column.todo.patterns.case.sensitive=區分大小寫
column.todo.patterns.icon=圖示
column.todo.patterns.pattern=模式
combobox.editor.color.scheme=編輯器配色方案\\:
combobox.editor.color.scheme.edit=編輯…
combobox.ide.scale.comment.format=通過 {0} 或 {1} 進行更改。通過 {2} 設定為 100%
combobox.ide.scale.percent=縮放\\:
combobox.language=語言\\:
combobox.language.option=語言
combobox.list.custom.section.title=自訂
combobox.look.and.feel=主題\\:
combobox.region=區域\\:
combobox.region.comment=選擇一個區域以確保許可、JetBrains Marketplace 和<br>其他針對特定區域的功能和鏈接正常工作。<br>需要重新啟動。有關詳情，請參閱<a href\\="{0}">文檔</a>。
combobox.region.hint=選擇一個區域以確保<br>許可、JetBrains Marketplace<br>和其他針對特定區域的功能<br>和鏈接正常工作。<br>需要重新啟動。
combobox.region.hint.link=文檔
command.close.all.editors=關閉所有編輯器
command.close.all.unmodified.editors=關閉所有未修改的編輯器
command.create.directory=建立目錄
command.create.file=建立檔案
command.create.file.from.template=從模板建立檔案
command.create.new.package=建立新軟體套件
command.create.package=建立軟體套件
command.deleting.files=正在刪除檔案
command.finish=完成
command.fixing.line.separators=修正行分隔符
command.go.to.line=轉到行
command.name.apply.color=套用顏色
command.name.choice.attach.detach={0, choice, 0\\#附加|1\\#分離} {1}
command.name.choice.exclude.include={0, choice, 0\\#排除|1\\#包含}{1}
command.pasting.reference=貼上參照
command.renaming.module=正在重新命名模組 {0}
command.select.all=全選
command.unselect.all=取消全選
comment.text.pause=暫停
comment.text.paused=已暫停
comment.text.resume=恢復
configurable.ChromeSettingsConfigurable.display.name=Chrome 設定
configurable.CodeStyle.display.name=程式碼樣式
configurable.Console.display.name=主控台
configurable.DatabaseSettingsConfigurable.CsvFormats.display.name=CSV 格式
configurable.DatabaseSettingsConfigurable.DataViews.display.name=資料編輯器和檢視器
configurable.DatabaseSettingsConfigurable.Other.display.name=其他
configurable.DatabaseSettingsConfigurable.OutputResults.display.name=輸出和結果
configurable.DatabaseSettingsConfigurable.QueryExecution.display.name=查詢執行
configurable.DatabaseSettingsConfigurable.Templating.display.name=使用者參數
configurable.DockerExtraHostConfigurable.display.name=額外主機
configurable.DuplicatesConfigurable.display.name=重複項
configurable.EmbeddedSettingsConfigurable.display.name=嵌入式開發
configurable.ExceptionAnalyzerConfigurable.display.name=異常分析器
configurable.ExternalDependenciesConfigurable.display.name=必需延伸模組
configurable.GutterIconsConfigurable.display.name=裝訂區域圖示
configurable.JavaFxSettingsConfigurable.display.name=JavaFX
configurable.PluginHostsConfigurable.display.name=自訂延伸模組儲存庫
configurable.Postfix.Completion.display.name=後綴補全
configurable.Runtime.Targets.Configurable.display.name=執行目標
configurable.SettingsPage.display.name=捆綁的 Web 幫助
configurable.TerminalOptionsConfigurable.display.name=終端
configurable.TextMateConfigurableProvider.display.name=TextMate 捆綁包
configurable.TimeTrackingConfigurable.display.name=時間追蹤
configurable.VagrantConfigurable.display.name=Vagrant
configurable.console.font.name=主控台字體
configurable.console.font.use.editor.font=使用編輯器字體
configurable.file.colors=檔案顏色
configurable.font.name=字體
configurable.new.ui.name=新 UI
configurable.notifications.name=通知
configurable.quick.lists.name=快速列表
configurable.trusted.hosts.display.name=受信任的位置
consent.configurable=資料共享
conversion.dialog.text.1=專案 ''{0}'' 的格式已過時，將被轉換。您可能無法使用早期版本的 {1} 開啟此專案。
conversion.dialog.text.2=<b> </b><a href\\="details">詳細資訊…</a><br/><br/>舊版本的專案檔案將被儲存到\\: ''{0}''
convert.project.dialog.button.text=轉換
copy.reference=複製參照(&Y)
copy.references=複製參照(&Y)
copy.relative.path=複製相對路徑(&Y)
copy.relative.paths=複製相對路徑(&Y)
copy.system.information.to.clipboard=將系統資訊複製到剪貼簿
create.new.UT8.file.option.always=包含 BOM
create.new.UT8.file.option.never=不含 BOM
create.new.UT8.file.option.only.under.windows=在 Windows 下使用 BOM，否則不使用 BOM
custom.action.actual=實際\\: {0}
custom.action.stored=已存儲\\: {0}
custom.option.testmode=讀取自訂動作 {0}
darcula.theme.name=Darcula
dark.theme.name=深色
date.format.24.hours=使用 24 小時時間
date.format.date.format=日期格式\\:
date.format.date.patterns=日期模式
date.format.error.contains.time.pattern=日期格式不應包含時間模式(小時、分鐘、秒)
date.format.error.invalid.pattern=無效模式\\: {0}
date.format.override.system.date.and.time.format=覆寫系統日期和時間格式
date.format.pretty=使用美化的格式
date.format.relative=將數字日期取代為<i>今天</i>、<i>昨天</i>和 <i>10 分鐘前</i>
date.time.format.configurable=日期格式
default=預設
default.icons.add.text=新增
default.icons.edit.text=編輯
default.icons.export.text=匯出
default.icons.filter.text=篩選
default.icons.find.text=尋找
default.icons.gear.plain.text=純齒輪
default.icons.import.text=匯入
default.icons.list.files.text=列出檔案
default.icons.none.text=<無>
default.icons.remove.text=移除
default.icons.unknown.text=預設圖示
deleting.jre.config=正在刪除執行時組態檔案
description.copy.text.to.clipboard=將文本複製到剪貼簿
description.text.pause=暫停 ''{0}''
description.text.resume=恢復 ''{0}''
detach.directory.action.text.detach.0=從專案中分離{0,choice,1\\#目錄|2\\#目錄}…
detach.directory.dialog.button.detach=分離
detach.directory.dialog.message.detach.0=分離 {0}?\\n不會從磁碟上移除檔案。
detach.directory.dialog.title.detach=從專案中分離目錄
detach.library=分離庫
detach.library.from.module=從模組 ''{1}'' 分離庫 ''{0}''?\\n不會損害磁碟上的檔案。
dialog.apply=套用
dialog.button.ok.jcef.signIn=登入
dialog.content.jcef.proxyServer=<html>瀏覽器組件正在為代理<br>請求身份驗證\\: {0}
dialog.content.label.jcef.login=登入名\\: 
dialog.content.label.jcef.password=密碼\\: 
dialog.delete.window.layout.prompt=是否刪除布局“{0}”?
dialog.layout.already.exists=已存在使用此名稱的布局
dialog.layout.name.too.long=允許的最大長度為 {0} 個字元
dialog.message.attach.project.not.found=在 {0} 中找不到專案
dialog.message.caches.will.be.invalidated=移除所有專案的快取和索引。重新開啟專案時將建置新快取。
dialog.message.can.not.open.file=無法開啟檔案 {0}
dialog.message.cannot.perform.operation.too.complex.sorry=無法執行動作。抱歉，太複雜了。
dialog.message.cannot.save.the.file.0=無法儲存檔案 {0}
dialog.message.command.not.finished.yet={0} 尚未完成。
dialog.message.communication.error=通信錯誤
dialog.message.component.could.not.be.reloaded=無法重新載入該組件。重新載入專案?
dialog.message.conversions.will.be.performed=<html>將執行以下轉換\\:<br>{0}</html>
dialog.message.could.not.erase.files.or.folders.0.1=無法擦除檔案或目錄\\:\\n{0}{1}
dialog.message.disable.dependent.plugin=<html>將停用相依的 ''{0}'' 延伸模組</html>
dialog.message.disable.dependent.plugins=<html>以下相依延伸模組將被停用\\: <br>{0}</html>
dialog.message.enable.required.plugin=<html>將啟用所需的 ''{0}'' 延伸模組</html>
dialog.message.enable.required.plugins=<html>將啟用所需的以下延伸模組\\: <br>{0}</html>
dialog.message.enable.vagrant.support.plugin=啟用 Vagrant 支援延伸模組
dialog.message.enter.new.value.for.0=輸入 {0} 的新值
dialog.message.enter.new.value.for.0.in.form.brightness.contrast.alpha=在“亮度、對比度、Alpha”表單中\\n輸入 {0} 的新值
dialog.message.enter.new.value.for.0.in.form.top.left.bottom.right=在“上、下、左、右”表單中\\n輸入 {0} 的新值
dialog.message.enter.new.value.for.0.in.form.width.height=以“寬度,高度”形式\\n輸入 {0} 的新值
dialog.message.error.setting.value=設定值時出錯\\: {0}
dialog.message.execution.finished=執行已完成
dialog.message.execution.finished.because=執行被終止，原因是\\: {0}
dialog.message.fail.to.load.plugin.descriptor.from.file=無法從檔案 {0} 載入延伸模組檔案描述子
dialog.message.file.already.exists=檔案已存在
dialog.message.file.with.name.already.exists=名稱為 ''{0}'' 的檔案已存在
dialog.message.folder.with.name.already.exists=名稱為 ''{0}'' 的目錄已存在
dialog.message.following.plugin.depend.on=以下{0,choice,1\\#延伸模組|2\\#延伸模組}{0,choice,1\\#相依|2\\#相依}於 {1}\\:<br>{2}<br>是否繼續移除 {1}{3, choice, 0\\#|1\\# 更新}?
dialog.message.host.name.empty=主機名為空
dialog.message.incompatible.encoding=您選擇的編碼(''{0}'')可能會更改 ''{1}'' 的內容。<br>是否要<br>1. 以新的編碼 ''{0}'' 從磁碟<b>重新載入</b>檔案，並覆蓋編輯器內容或<br>2. <b>轉換</b>文本並以新編碼覆蓋檔案?
dialog.message.internal.error=內部錯誤
dialog.message.invalid.host.value=主機值無效
dialog.message.invalid.path=無效路徑 ''{0}''
dialog.message.jetbrains.client.for.ide={0} 的 JetBrains 客戶端
dialog.message.login.empty=登入名為空
dialog.message.must.be.restarted.for.changes.to.take.effect=重啟 {0} 以使更改生效
dialog.message.no.message=沒有訊息
dialog.message.no.project.found.to.open.file.in=找不到可以在以下位置開啟檔案的專案\\:
dialog.message.only.one.instance.can.be.run.at.time=一次只能執行一個 {0} 實例。
dialog.message.open.cancelled=開啟動作已取消
dialog.message.password.empty=密碼為空
dialog.message.please.enter.credentials.for=請輸入憑證\\: {0}
dialog.message.plugin.core.part=延伸模組 ''{0}'' 是 {1} 的核心部分。要將其更新到較新版本，您應該更新 IDE。
dialog.message.plugin.depends.on.unknown.plugin=延伸模組 {0} 依賴於未知{1,choice,1\\#延伸模組|2\\#延伸模組} {2}
dialog.message.plugin.is.not.allowed=您的組織不允許安裝延伸模組 ''{0}''
dialog.message.plugin.was.already.installed=延伸模組 ''{0}'' 已安裝
dialog.message.press.for.field.hints=按 {0} 獲取欄位提示
dialog.message.problem.with.connection=<html>連線出現問題\\:<br>{0}</html>
dialog.message.project.group.name=專案組名
dialog.message.remove.0.from.recent.projects.list=從最近的專案列表中移除 ''{0}''?
dialog.message.remove.projects.from.recent.projects.list=是否從最近的專案列表中移除專案?
dialog.message.restart.alt=您的設定不支持重新啟動。要離開 IDE 嗎?
dialog.message.restart.ide=是否要重啟 IDE?
dialog.message.restarted.to.apply.changes=是否重新啟動 {0} 以套用更改?
dialog.message.specified.path.cannot.be.found=找不到指定的路徑
dialog.message.the.following.items=可選\\:
dialog.message.there.already.same.interpreter=已經有相同的解釋器\\:\\n{0}
dialog.message.trying.to.create.folder.with.ignored.name=正在嘗試建立具有忽略名稱的目錄；結果將不可見
dialog.message.unable.to.apply.changes=<body style\\="padding\\: 5px;">無法套用更改\\: 將無法載入{0,choice,1\\#延伸模組|2\\#延伸模組} {1}。</body>
dialog.message.unable.to.create.idea.directory=無法建立 ''.idea'' 目錄(%s)\\: {0}
dialog.message.unknown.error=未知錯誤
dialog.message.url.is.empty=URL 為空
dialog.message.url.is.invalid=URL 無效
dialog.message.wait.must.be.supplied.with.file.or.project.to.wait.for=必須為 '--wait' 提供要等待的檔案或專案
dialog.message.was.unable.to.save.some.project.files={0} 無法儲存某些專案檔案，確定仍要關閉此專案嗎?\\n\\n唯讀檔案\\:\\n
dialog.new.window.layout.prompt=布局名稱\\:
dialog.new.window.layout.title=新增布局
dialog.newui.title.user.interface=重啟以套用 UI 更改
dialog.rename.window.layout.prompt=布局名稱\\:
dialog.rename.window.layout.title=重新命名布局
dialog.text.error.getting.value=獲取值時出錯\\: {0}
dialog.title.abbreviation=縮寫
dialog.title.activity.monitor=活動監視器
dialog.title.add.actions.to.quick.list=將動作新增到快速列表
dialog.title.add.new.value=新增新值
dialog.title.attach.project.error=無法附加專案
dialog.title.auto.detected.proxy=自動檢測的代理
dialog.title.background.image=背景圖像
dialog.title.can.t.create.0.sdk=無法建立 {0} SDK
dialog.title.cannot.execute.command=無法執行指令
dialog.title.change.group.name=更改組名
dialog.title.change.project.icon=設定自訂專案圖示
dialog.title.check.proxy.settings=檢查代理設定
dialog.title.choose.color=選擇顏色
dialog.title.choose.encoding.for.the.0=選擇 ''{0}'' 的編碼
dialog.title.choose.plugins.to.install.or.enable=選擇要安裝或啟用的延伸模組
dialog.title.clear.read.only.file.status=清除唯讀狀態
dialog.title.collect.troubleshooting.information=收集故障排除資訊
dialog.title.color.picker=取色器
dialog.title.configuration.changed=組態已更改
dialog.title.convert.module=轉換模組
dialog.title.convert.project=轉換專案
dialog.title.create.new.project.group=建立新項目組
dialog.title.custom.debug.log.configuration=自訂偵錯日誌組態
dialog.title.customize.0=自訂 {0}
dialog.title.data.sharing=資料共享
dialog.title.delete.0=刪除 {0}
dialog.title.dependent.plugins.found=找到相依的延伸模組
dialog.title.dimension.editor=尺寸編輯器
dialog.title.disable.dependent.plugins=停用相依延伸模組
dialog.title.edit.laf.defaults=編輯 LaF 預設值
dialog.title.enable.required.plugins=啟用必需延伸模組
dialog.title.error.saving.project=儲存專案時出錯\\!
dialog.title.error.writing.file=寫入檔案時錯誤
dialog.title.experimental.features=實驗性功能
dialog.title.export.to.file=匯出到檔案
dialog.title.failed.to.perform.operation=執行動作失敗
dialog.title.fetching.predefined.settings.for.disabled.plugins=正在獲取已停用延伸模組的預定義設定
dialog.title.file.0.can.t.be.reloaded=無法以 ''{1}'' 編碼重新載入檔案 ''{0}''。{2}
dialog.title.file.0.most.likely.isn.t.stored=檔案 ''{0}'' 可能未以 ''{1}'' 編碼存儲。{2}
dialog.title.font.size.editor=字號編輯器
dialog.title.go.to.line.column=轉到行\\:列
dialog.title.gray.filter.editor=灰色篩選器編輯器
dialog.title.http.proxy.exceptions=代理異常
dialog.title.import=匯入
dialog.title.insets.editor=插入編輯器
dialog.title.install.plugin=安裝延伸模組
dialog.title.installing.plugin=正在安裝延伸模組 {0}
dialog.title.invalid.input=輸入無效
dialog.title.invalidate.caches=使快取失效
dialog.title.jcef.proxyAuthentication=代理身份驗證
dialog.title.migrating.plugins=正在遷移延伸模組
dialog.title.new.tag.name=新增標記名稱
dialog.title.non.project.files.protection=非專案檔案保護
dialog.title.number.editor=數字編輯器
dialog.title.plugin.updates=延伸模組更新
dialog.title.proxy.authentication=代理身份驗證\\: {0}
dialog.title.proxy.setup=代理設定
dialog.title.remove.recent.project=移除最近的專案
dialog.title.remove.recent.project.plural=移除最近的專案
dialog.title.reopen.project=重新開啟專案
dialog.title.required.plugin=必需延伸模組
dialog.title.restart.ide=重啟?
dialog.title.restart.required=需要重啟
dialog.title.save.as=另存為
dialog.title.save.project.to.directory.based.format=將專案儲存為基於目錄的格式
dialog.title.select.0=選擇 {0}
dialog.title.third.party.software={0} {1} 使用的第三方軟體
dialog.title.unable.to.save=無法儲存
dialog.title.untrusted.server.s.certificate=不可信伺服器的憑證
dialog.title.updating.plugin=正在更新延伸模組 {0}
dialog.title.vagrant.support.disabled=已停用 Vagrant 支援
diff.dialog.title=''{0}'' 與 ''{1}'' 之間的差異
directory.message.cant.create.folder=無法建立名為 ''{0}'' 的目錄
directory.project.location.description=為專案選擇基目錄
directory.project.location.label=位置(&L)\\:
directory.project.location.title=選擇基目錄
display.balloon.notifications=顯示氣球通知
display.name.firefox.settings=Firefox 設定
dnd.with.alt.pressed.only=僅按下 Alt 時拖放
do.not.ask.me.again=不再詢問
double.ctrl.or.shift.shortcut=雙擊 {0}
dumb.balloon.0.is.not.available.while.indexing=索引編制期間 {0} 不可用
dumb.balloon.none.of.the.following.actions.are.available.during.indexing.0=索引編制期間以下動作均不可用\\: {0}
dumb.balloon.this.action.is.not.available.during.indexing=索引編制期間此動作不可用
dumb.mode.results.might.be.incomplete=編制索引時，結果可能不完整
dumb.mode.spoiler.wrapper.reload.text=重新載入結果
dumb.service.indexing.paused.due.to=由於{0}，索引編制暫停
dump.focusable.component.hierarchy.close.button=關閉並複製到剪貼簿
editbox.customfiletype.block.comment.end=塊註釋結束\\:
editbox.customfiletype.block.comment.start=塊註釋開始\\:
editbox.customfiletype.description=描述\\:
editbox.customfiletype.hex.prefix=十六進制前綴\\:
editbox.customfiletype.line.comment=行註釋\\:
editbox.customfiletype.name=名稱\\:
editbox.customfiletype.number.postfixes=數字後綴\\:
editbox.default.encoding.for.properties.files=屬性檔案的預設編碼\\:
editbox.export.to.file=匯出到檔案\\:
editbox.plugin.description=描述
editor.banner.close.tooltip=關閉
editor.tabs.always.keep.sorting=始終保持啟用排序
editor.tabs.enable.sorting=啟用排序
empty.project.generator.description=不帶模組的專案。用它來建立自由樣式的模組結構。將開啟“專案結構”對話框，幫助您建置專案結構。
empty.project.generator.name=多模組專案
empty.text.drop.files.to.open=將檔案拖放到此處以開啟
empty.text.go.to.file=轉到檔案
empty.text.navigation.bar=導覽列
empty.text.no.entries=無條目
empty.text.no.features.available=無可用功能
empty.text.no.project.open.yet=尚無專案開放
empty.text.nothing.found=找不到任何內容
empty.text.nothing.selected=未選擇任何內容
empty.text.project.view=專案檢視
empty.text.recent.files=最近的檔案
empty.text.search.everywhere=隨處搜尋
empty.text.this.view.is.not.available.until.indices.are.built=在建置索引前，此檢視不可用
encoding.do.not.convert.message=請勿轉換到 ''{0}''。
encoding.name.properties.default=<屬性預設值\\: {0}>
encoding.name.system.default=<系統預設\\: {0}>
encoding.not.available=不適用
encoding.unsupported.characters.message=編碼 ''{0}'' 不支持文本中的某些字元。
encodings.dialog.caption=新增檔案或目錄的路徑並選擇 {0} 應使用的編碼。<br>檔案和目錄從父目錄或專案編碼繼承編碼。<br>JSP、HTML 和 XML 檔案中的內建檔案編碼會覆寫這些設定。
environment.key.description.enable.disabled.dependent.plugins=指定在更新某些延伸模組時是否應啟用已停用的相依延伸模組。如果選擇“所有”，則啟用所有已更新和相依的延伸模組。如果選擇“已更新”，則僅啟用已更新的延伸模組。如果為“無”，則不會啟用任何延伸模組。
error.0.browser.path.not.specified={0}瀏覽器路徑未指定。
error.cannot.convert.project=無法轉換專案\\: {0}
error.cannot.load.project=無法載入專案\\: {0}
error.cannot.set.look.and.feel=<html><body>無法設定{0}主題\\:<br>{1}</body></html>
error.connection.failed=連線失敗
error.descriptor.load.failed=無法從{0}載入延伸模組檔案描述子。所選檔案可能不是 IntelliJ 延伸模組。
error.dir.contains.no.project=''{0}'' 不包含專案
error.directory.with.name.already.exists=名稱為 ''{0}'' 的目錄已存在
error.download.plugin.via.blockmap=無法通過塊映射下載延伸模組。正在從 {0} 下載整個歸檔
error.downloaded.descriptor.load.failed=無法從下載的歸檔載入延伸模組檔案描述子。歸檔可能不是 IntelliJ 延伸模組。
error.empty.name=名稱不得為空
error.failed.to.create.directory=無法建立目錄“{0}”
error.favorites.list.already.exists=收藏夾列表 ''{0}'' 已存在
error.file.does.not.exist=檔案 {0} 不存在。
error.file.not.found.message=檔案 ''{0}'' 不存在
error.file.with.name.already.exists=名稱為 ''{0}'' 的檔案已存在
error.files.of.this.type.cannot.be.opened=無法在{0}中開啟此類型的檔案
error.filter.name.should.be.specified=應指定篩選器名稱
error.filter.should.contain.at.least.one.pattern=篩選器應至少包含一個模式
error.filter.with.the.same.name.already.exists=具有相同名稱的篩選器已存在
error.group.already.exists=組 ''{0}'' 已存在。
error.incompatible.update=下載的版本與當前 IDE 不相容\\: {0}
error.invalid.directory=無效目錄\\: ''{0}''
error.invalid.directory.name=''{0}'' 不是有效的目錄名稱
error.invalid.file.name=''{0}'' 是無效的檔名
error.invalid.java.package.name=無效的軟體套件名稱；無法在內部建立 Java 類別
error.invalid.java.package.name.format=無效的軟體套件名稱格式設定；無法在內部建立 Java 類別
error.invalid.template.file.name.or.extension=無效的模板檔名或副檔名
error.loading.package.list=載入軟體套件列表時出錯\\: {0}
error.malformed.url=URL 格式錯誤\\: {0}
error.message.cannot.make.files.writable=無法解鎖以下檔案\\:\\n{0}
error.message.cannot.modify.file.0=無法修改檔案 ''{0}''
error.message.exception.was.thrown=拋出了異常
error.message.unable.to.create.file=無法建立檔案 ''{0}''
error.module.already.exists=名為 ''{0}'' 的模組已存在
error.name.already.exists=名稱已被使用。請更改為唯一名稱。
error.name.cannot.be.empty=名稱不能為空
error.name.should.be.specified=必須指定名稱
error.no.plugins.found=未找到延伸模組。檢查日誌檔案中有無錯誤。
error.occurred.please.check.your.internet.connection=出錯了。請檢查您的互聯網連線。
error.older.update=下載的版本({0})比當前安裝的版本({1})舊。
error.package.with.name.already.exists=名稱為 ''{0}'' 的軟體套件已存在
error.parsing.file.template=解析檔案模板時出錯\\: {0}
error.pattern.should.be.specified=應指定模式
error.pending.update=延伸模組“{0}”的另一個更新正在等待安裝。請重啟，然後重試。
error.please.enter.a.file.name=指定檔名
error.please.specify.path.to.web.browser=在“{0} | Web 瀏覽器”中指定 Web 瀏覽器路徑
error.please.specify.template.name=指定模板名稱
error.plugin.required.for.project.disabled=''{1}'' 專案所需延伸模組 ''{0}'' 已停用。
error.plugin.required.for.project.not.installed=''{1}'' 專案所需延伸模組 ''{0}'' 未安裝。
error.plugin.was.not.installed=延伸模組“{0}”未安裝\\: {1}
error.project.file.does.not.exist=無法載入 {0}。該檔案不存在。
error.project.requires.newer.ide=專案 ''{0}'' 需要 IDE 的 {1}''{2}'' 或更新的建置，但當前建置為 ''{3}''。
error.project.requires.newer.plugin=專案 ''{0}'' 需要延伸模組 ''{1}'' 版本 ''{2}'' 或更高版本，但已安裝的是 ''{3}''。
error.project.requires.older.ide=專案 ''{0}'' 需要 IDE 的 {1}''{2}'' 或更老的建置，但當前建置為 ''{3}''。
error.project.requires.older.plugin=專案 ''{0}'' 需要延伸模組 ''{1}'' 版本 ''{2}'' 或更低版本，但已安裝的是 ''{3}''。
error.project.requires.plugins.not.enabled=專案 ''{0}'' 需要啟用以下延伸模組\\:
error.project.requires.plugins.not.installed=專案 ''{0}'' 需要安裝以下延伸模組\\:
error.same.pattern.already.exists=一些模式已存在
error.saving.statistics=儲存系統資訊時出錯\\: {0}
error.text.file.already.exists=檔案 {0} 已存在。\\n希望覆蓋還是追加?
error.tips.not.found=找不到每日小技巧。確保已正確安裝 {0}。
error.tree.view.cell.error=錯誤\\: {0}
error.tree.view.fix.description=修復\\: {0}
error.tree.view.fixing=正在修正…
error.unable.to.parse.template.message=無法解析模板“{0}”，\\n錯誤訊息\\: {1}
error.unable.to.read.tip.of.the.day=<html><body>無法讀取每日小技巧({0})。確認已正確安裝 {1}。</body></html>
error.unc.not.supported=UNC 路徑不受支援\\: {0}
error.updating.package.list=更新軟體套件列表時出錯\\: {0}
error.user.home.directory.not.found=未找到使用者主目錄
error.writing.to.file=寫入檔案時出錯\\: {0}
errortree.error=錯誤\\:
errortree.information=資訊\\:
errortree.noMessages=沒有訊息
errortree.note=注意\\:
errortree.prefix.line=行({0})
errortree.warning=警告\\:
essential-highlighting.mode.disable.action.title=停用基本醒目提示顯示模式
essential-highlighting.mode.on.notification.content=基本醒目提示模式只保留一組有限的程式碼醒目提示工具。包括檢查在內的所有醒目提示工具都將在執行檔案儲存動作時執行。
essential-highlighting.mode.on.notification.title=基本醒目提示模式已開啟
external.link.confirmation.message.0=確定要在瀏覽器或關聯的應用程式中開啟此鏈接嗎?<br><br>{0}
external.link.confirmation.title=開啟鏈接
external.link.confirmation.trust.label=信任專案並開啟
external.link.confirmation.yes.label=開啟
failed.to.install.package.dialog.title=無法安裝 ''{0}''
failed.to.install.packages.dialog.title=無法安裝軟體套件
failed.to.take.thread.dump=無法獲取執行緒傾印。
failed.to.unload.modified.plugins=無法移除修改的延伸模組\\: {0}
favorites.list.unnamed=未命名的{0}
feature.file.handler.ansi.highlighter=ANSI 程式碼
file.changed.externally.message=檔案在磁碟上已被更改。
file.changed.externally.reload=重新載入
file.chooser.completion.ad.text=使用 {0} 保留路徑尾部
file.chooser.completion.no.suggestions=無建議
file.chooser.completion.path.variables.text=路徑變數
file.chooser.hide.path=隱藏路徑
file.chooser.show.path=顯示路徑
file.encoding.option.create.utf8.files=建立 UTF-8 檔案\\:
file.encoding.option.encoding.column=編碼
file.encoding.option.global.encoding=全域編碼
file.encoding.option.path.column=路徑
file.encoding.option.project.encoding=專案編碼
file.encoding.option.warning.always={0} 會將 <a href\\="https\\://en.wikipedia.org/wiki/Byte_order_mark\\#UTF-8">UTF-8 BOM</a> 新增到使用 UTF-8 編碼建立的每個檔案中
file.encoding.option.warning.never={0} 不會將 <a href\\="https\\://en.wikipedia.org/wiki/Byte_order_mark\\#UTF-8">UTF-8 BOM</a> 新增到每個以 UTF-8 編碼建立的檔案中
file.encoding.option.warning.windows.only={0} 只會在每個建立的 UTF-8 檔案在 Windows 下執行時向其新增 <a href\\="https\\://en.wikipedia.org/wiki/Byte_order_mark\\#UTF-8">UTF-8 BOM</a>
file.encodings.configurable=檔案編碼
file.encodings.not.configured=未組態編碼
file.nesting.dialog.title=檔案嵌套
file.nesting.feature.enabled.checkbox=以嵌套形式顯示具有相同名稱的檔案(&S)
file.nesting.reset.to.default.button=重設為預設(&R)
file.nesting.table.title=嵌套規則\\:
file.read.error=無法讀取檔案 {0}。
file.read.error.details=無法讀取檔案 {0}\\: {1}
file.write.error=無法寫入到檔案 {0}
file.write.error.details=無法寫入檔案 {0}\\: {1}
filetype.gui.designer.form.description=GUI 設計器表單
filetype.gui.designer.form.display.name=GUI 設計器表單
filetype.scalable.vector.graphics.description=可縮放矢量圖形
filetype.scalable.vector.graphics.display.name=可縮放矢量圖形
filetype.search.everywhere.directory.description=檔案系統目錄
filetype.web.preview.description=用於嵌入式瀏覽器中的檔案預覽
filetype.web.preview.display.name=Web 預覽
filters.all=所有
filters.select=選擇…
find.ide.update.title=尋找 IDE 更新
fixed.problem.prefix=已修復\\:
focus.debugger.label.newvalue=新值\\=
focus.debugger.label.oldvalue=舊值\\=
font.info.renderer.non.latin=非拉丁語
font.reset.link=重設為預設
gdpr.checkbox.when.using.eap.versions=使用 EAP 版本時{0}
gdpr.consent.externally.disabled.warning=此選項已從外部停用
gdpr.continue.button=繼續
gdpr.data.collection.consent.group.comment.text=幫助塑造 JetBrains 產品的未來。通過共享您的資料和使用統計資訊，您可以讓我們更好地了解您如何使用我們的工具，並幫助我們改進這些工具。點擊<a href\\="https\\://www.jetbrains.com/legal/docs/terms/product_data_collection/">此處</a>了解詳情。
gdpr.data.collection.consent.group.setting.disabled.warning.text=您的組織管理員已停用資料收集。
gdpr.data.collection.consent.group.setting.enabled.warning.text=您的組織管理員已啟用資料收集。
gdpr.exit.button=離開
gdpr.hint.text.apply.to.all.installed.products=資料共享偏好設定適用於所有已安裝的 {0} 產品。
gdpr.hint.text.you.can.always.change.this.behavior=您隨時可以在“{0} | 外觀與行為 | 系統設定 | 資料共享”中更改此行為。
gdpr.label.there.are.no.data.sharing.options.available=沒有可用的資料共享選項
gdpr.usage.statistics.disabled.externally.warning=Toolbox Enterprise 延伸模組已暫時停用發送使用統計資訊。
gdpr.usage.statistics.enabled.for.free.license.warning=在非商業許可下，IDE 會收集使用數據以驗證是否符合許可條款，並向 JetBrains 發送匿名功能使用統計資訊以幫助改進產品。有關詳情，請參閱 <a href\\="https\\://www.jetbrains.com/legal/docs/privacy/privacy/">JetBrains 隱私政策</a>。
general.module.type.description=一個允許使用單獨的檔案並編譯 Java 和 Kotlin 類別的基本專案。
github.project.generator.version=版本(&V)\\:
github.project.generator.versions.not.loaded.error=尚未載入版本。
go.to.class.action.description=按名稱快速導覽到{0}
go.to.class.dumb.mode.message=在建置索引前，轉到 {0} 動作不可用，改用轉到檔案
go.to.class.kind.text=類別
go.to.class.kind.text.pluralized=類別
go.to.class.title.prefix=轉到{0}
got.it.button.name=知道了
goto.custom.region.command=轉到自訂折疊
goto.custom.region.menu.item=自訂折疊…
goto.custom.region.message.dumb.mode=在建置索引前，自訂折疊導覽不可用。
goto.custom.region.message.unavailable=當前檔案中沒有自訂的折疊
goto.inspection.action.choose.inherit.settings.from=檢查選項
goto.inspection.action.dialog.title=執行 ''{0}''
goto.inspection.action.fix.all=全部修正
goto.inspection.action.text=通過名稱執行檢查(&R)…
group.antialiasing.mode=抗鋸齒
group.customfiletype.syntax.highlighting=語法醒目提示
group.customizations.add.action.below=在下方新增動作…
group.customizations.add.action.button=新增…
group.customizations.add.action.group=新增動作…
group.customizations.restore.action.group=還原動作…
group.presentation.mode=示範模式
group.settings.process.tab.close=關閉具有執行程序的工具視窗時\\:
group.todo.filter.patterns=模式
group.transparency=透明度
group.trees=樹檢視
group.ui.options=UI 選項
group.vendor=供應商
group.view.options=檢視選項
group.window.options=工具視窗
handle.ro.file.status.failed=<html>無法更改以下檔案的唯讀狀態\\:<br>{0}</html>
handle.ro.file.status.failed.many.files=<br>…<br>共 {0} 個檔案
handle.ro.file.status.type.using.file.system=使用檔案系統
hashes.doesnt.match=還原的歸檔的雜湊與原始歸檔的雜湊不符合
hide.native.linux.title.not.supported.incompatible.jbr=不相容的 JBR/JRE
hide.native.linux.title.not.supported.tiling.wm=不支持平鋪式視窗管理器
hide.native.linux.title.not.supported.undefined.desktop=不支持未定義的桌面
hide.native.linux.title.not.supported.wayland.or.xtoolkit.required=需要 Wayland 或 XToolkit
hide.native.linux.title.not.supported.wsl=不支持 WSL
hierarchy.call.next.occurence.name=轉到下一個呼叫
hierarchy.call.prev.occurence.name=轉到上一個呼叫
hierarchy.legend.method.defined.in.superclass=方法未在類別中定義，但在其超類別中定義
hierarchy.legend.method.is.defined.in.class=方法已在類別中定義
hierarchy.legend.method.should.be.defined=必須定義方法，因為類別不為 abstract
hierarchy.method.next.occurence.name=轉到下一個方法
hierarchy.method.prev.occurence.name=轉到上一個方法
hierarchy.type.next.occurence.name=轉到下一個類型
hierarchy.type.prev.occurence.name=轉到上一個類型
high.contrast.theme.name=高對比度
hint.scheme.editing=按 Enter 儲存，按 Esc 取消
hint.text.all.lines.already.have.requested.indentation=所有行都已請求縮排
hint.text.changed.indentation.in=已更改{0,choice,1\\#行|2\\#行}中的縮排
http.editor.name=HTTP
http.multirange.response.doesnt.contain.boundary=HTTP 多範圍響應邊界線 {0} 不包含邊界 {1}
http.multirange.response.doesnt.include.line.separator=HTTP 多範圍響應不包含行分隔符
http.multirange.response.includes.incorrect.header=HTTP 多範圍響應包含不正確的頭 - {0}，應為 {1}
http.proxy.configurable=HTTP 代理
http.velocity={0}<hr> <font face\\="verdana" size\\="-1"><a href\\=''https\\://velocity.apache.org/engine/devel/user-guide.html\\#Velocity_Template_Language_VTL\\:_An_Introduction''>\\nApache Velocity</a> 模板語言已使用</font>
icon.debugger.db_array.tooltip=陣列
icon.debugger.db_obsolete.tooltip=過時的框架
icon.debugger.db_primitive.tooltip=基元類型的值
icon.debugger.db_watch.tooltip=監視
icon.debugger.frame.tooltip=框架
icon.debugger.selfreference.tooltip='this' 的參照
icon.debugger.threadAtBreakpoint.tooltip=中斷點處的執行緒
icon.debugger.threadCurrent.tooltip=當前執行緒
icon.debugger.threadFrozen.tooltip=凍結執行緒
icon.debugger.threadGroup.tooltip=執行緒組
icon.debugger.threadGroupCurrent.tooltip=當前線程組
icon.debugger.threadRunning.tooltip=正在執行的執行緒
icon.debugger.threadSuspended.tooltip=暫停的執行緒
icon.debugger.value.tooltip=值
icon.debugger.watchLastReturnValue.tooltip=最後一個方法呼叫的返回值
icon.file.filter.label=圖示檔案
icon.fileTypes.archive.tooltip=歸檔檔案
icon.fileTypes.custom.tooltip=自訂類型的檔案
icon.fileTypes.diagram.tooltip=圖表檔案
icon.fileTypes.java.tooltip=Java 檔案
icon.fileTypes.javaClass.tooltip=Java 編譯的位元組碼檔案
icon.fileTypes.javaOutsideSource.tooltip=來源根之外的 Java 檔案
icon.fileTypes.json.tooltip=JSON 檔案
icon.fileTypes.jsonSchema.tooltip=JSON 架構檔案
icon.fileTypes.manifest.tooltip=清單檔案
icon.fileTypes.properties.tooltip=屬性檔案
icon.fileTypes.unknown.tooltip=未知類型的檔案
icon.fileTypes.xml.tooltip=XML 檔案
icon.fileTypes.yaml.tooltip=YAML 檔案
icon.modules.excludeRoot.tooltip=排除的目錄
icon.modules.excludedGeneratedRoot.tooltip=排除的生成來源根
icon.modules.generatedFolder.tooltip=生成的目錄
icon.modules.generatedSourceRoot.tooltip=生成的來源根
icon.modules.generatedTestRoot.tooltip=生成的測試來源根
icon.modules.output.tooltip=輸出根
icon.modules.resourcesRoot.tooltip=資源根
icon.modules.sourceRoot.tooltip=來源根
icon.modules.testResourcesRoot.tooltip=測試資源根
icon.modules.testRoot.tooltip=測試來源根
icon.modules.unloadedModule.tooltip=已移除的模組
icon.nodes.Module.tooltip=模組
icon.nodes.abstractClass.tooltip=抽象類別
icon.nodes.abstractException.tooltip=abstract 異常
icon.nodes.abstractMethod.tooltip=abstract 方法
icon.nodes.annotationtype.tooltip=註解類型
icon.nodes.anonymousClass.tooltip=匿名類別
icon.nodes.c_plocal.tooltip=package-local
icon.nodes.c_private.tooltip=private
icon.nodes.c_protected.tooltip=protected
icon.nodes.c_public.tooltip=public
icon.nodes.class.tooltip=類別
icon.nodes.classInitializer.tooltip=類別初始設定式
icon.nodes.enum.tooltip=枚舉
icon.nodes.exceptionClass.tooltip=異常類別
icon.nodes.excludedFromCompile.tooltip=已從編譯中排除
icon.nodes.field.tooltip=欄位
icon.nodes.finalMark.tooltip=final
icon.nodes.folder.tooltip=目錄
icon.nodes.ideaModule.tooltip=IntelliJ 模組檔案
icon.nodes.interface.tooltip=接口
icon.nodes.junitTestMark.tooltip=單元測試
icon.nodes.locked.tooltip=唯讀
icon.nodes.method.tooltip=方法
icon.nodes.moduleGroup.tooltip=模組組
icon.nodes.nodePlaceholder.tooltip=
icon.nodes.package.tooltip=軟體套件
icon.nodes.parameter.tooltip=參數
icon.nodes.ppJdk.tooltip=JDK
icon.nodes.ppLib.tooltip=外部庫
icon.nodes.runnableMark.tooltip=可執行
icon.nodes.staticMark.tooltip=static
icon.runConfigurations.testError.tooltip=意外異常
icon.runConfigurations.testFailed.tooltip=斷言失敗
icon.runConfigurations.testIgnored.tooltip=測試已忽略
icon.runConfigurations.testNotRan.tooltip=測試未開始
icon.runConfigurations.testPassed.tooltip=測試通過
icon.runConfigurations.testSkipped.tooltip=測試已跳過
icon.runConfigurations.testTerminated.tooltip=測試已終止
icon.validation.message.format=圖示格式不正確
icon.validation.message.not.found=該圖示不存在
ide.mac.app.icon.error.message=無法{0,choice,0\\#設定|1\\#重設}自訂應用程式圖示
ide.notnow.action=以後再說
ide.postpone.action=推遲
ide.protocol.cannot.title=無法開啟 URI
ide.protocol.exception=內部錯誤\\: {0}\\: {1}
ide.protocol.internal.bad.query=不正確的查詢字串\\: ''{0}''
ide.protocol.progress.title=正在開啟 URI
ide.protocol.unsupported=不支持的協議\\: ''{0}''
ide.restart.action=重啟
ide.restart.required.comment=需要重新啟動
ide.restart.required.message={0}{1}以套用延伸模組中的更改?
ide.restart.required.notification={0, choice, 0\\#關閉|1\\#重啟}以啟用延伸模組更新
ide.scale.reset.link=重設為預設
ide.script.launcher.used=IDE 似乎是用腳本啟動器(''{0}'')啟動的。請考慮切換到原生啟動器(''{1}'')以獲得更好的體驗。
ide.shutdown.action=關閉
idea.intellij.look.and.feel=IntelliJ Light 舊版
ijent.wsl.fs.dialog.message=虛擬機選項組態不正確。WSL 動作可能會失敗。
ijent.wsl.fs.dialog.restart.button=自動修正虛擬機選項並重新啟動
ijent.wsl.fs.dialog.shutdown.button=自動修正虛擬機選項並關閉
implicit.log.directory.path=似乎您正在使用 ''idea.system.path'' 屬性指定快取目錄的位置。在 2020.1 中，應用程式目錄的預設位置已更改。為確保兼容性，IDE 選擇了日誌的舊位置({0})，但為了避免將來出現任何歧義(並去除此警告)，另請設定 ''idea.log.path'' 屬性。
implicit.plugin.directory.path=似乎您正在使用 ''idea.config.path'' 屬性指定設定目錄的位置。在 2020.1 中，應用程式目錄的預設位置已更改。為確保兼容性，IDE 選擇了延伸模組的舊位置({0})，但為了避免將來出現任何歧義(並去除此警告)，另請設定 ''idea.plugins.path'' 屬性。
in.product.notification.action.default.text=授權到期資訊
in.product.notification.action.discount.button=獲取六折優惠
in.product.notification.action.dismiss.button=關閉
in.product.notification.action.renew.button=續訂授權…
in.product.notification.action.text=<b>您的授權將在{0,choice,0\\#今天|1\\# 1 天後|2\\# {0} 天後}到期。</b>您可以選擇<br>免費續訂教育授權，或者獲取六折<br>畢業折扣。
in.product.notification.action.tooltip={0} 授權將在{1,choice,0\\#今天|1\\# 1 天後|2\\# {1} 天後}到期
in.product.notification.dialog.text=<h1>您的授權將在{0,choice,0\\#今天|1\\# 1 天後|2\\# {0} 天後}到期</h1><br>您可以選擇免費續訂教育授權，<br>或者如果您已經畢業，可以<a href\\="https\\://www.jetbrains.com/community/education/\\#students/renewal/">獲取六折優惠</a>。<br>
incompatible.encoding.dialog.title=不相容的編碼\\: {0}
incomplete.mode.results.might.be.incomplete=在載入所有相依項之前，結果可能不完整
information.hint.accessible.context.name=提示
initial.popup.context.switchers.text=正在載入上下文…
inline.actions.more.actions.text=更多動作
inline.completion.tooltip.shortcuts.accept.description=以補全
inline.completion.tooltip.shortcuts.accept.select.custom=自訂…
inline.completion.tooltip.shortcuts.header=內聯補全快捷鍵
inspection.message.inspection.info=檢查資訊
install.package.failure=安裝軟體套件 ''{0}'' 時發生錯誤。<a href\\="xxx">詳細資訊…</a>
install.plugin.chooser.description=接受 JAR 和 ZIP 歸檔
install.plugin.chooser.label=延伸模組檔案
install.plugin.chooser.title=選擇延伸模組檔案
intellij.light.theme.name=IntelliJ Light
intention.family.editor.notification=編輯器通知
intention.family.editor.notification.option=編輯器通知選項
intention.family.editor.notification.settings=編輯器通知設定
internal.decorator.accessible.postfix=工具視窗
interpreter.default.name=遠端 {0} 解釋器
invalid.context=<無效>
invalid.node.text=無效
invalidate.all.caches.recovery.action.name=使快取失效並重啟
invalidate.workspace.model.recovery.action.presentable.name=重新開啟專案
item.get.more.languages=獲取更多語言…
javascript.debugger.settings.choose.file.subtitle=選擇要偵錯其中的 JavaScript 的網頁
javascript.debugger.settings.choose.file.title=選擇
jb.protocol.navigate.missing.parameters=URL 中既沒有指定 'project' 參數，也沒有指定 'origin' 參數
jb.protocol.navigate.no.project=找不到或無法開啟指定的專案
jb.protocol.navigate.target=''navigate'' 指令僅支援 ''reference'' 目標(找到 ''{0}'')
jb.protocol.parameter.missing=缺少參數\\: ''{0}''
jb.protocol.settings.no.configurable=找不到設定頁面\\: ''{0}''
jb.protocol.unknown.command=未知指令\\: ''{0}''
jb.protocol.unknown.target=未知目標\\: ''{0}''
jcef.local.cache.invalidate.comment=影響使用嵌入式瀏覽器呈現基於 HTML 的內容和網頁的組件。
jcef.local.cache.invalidate.description=刪除嵌入式瀏覽器引擎快取和 Cookie
jcef.local.cache.invalidate.failed.message=“使快取失效”動作請求了嵌入式瀏覽器引擎快取清理。由於 I/O 錯誤，動作失敗\\: {0}
jcef.local.cache.invalidate.failed.title=無法清理瀏覽器引擎快取
jetbrains.certificate.invalid=JetBrains 憑證無效。請聯繫 JetBrains 支援人員。
jetbrains.certificate.not.found=找不到 JetBrains 憑證。
jetbrains.certificate.vendor=供應商\\: {0}
keymap.action.configure.keymap=組態按鍵映射…
keymap.action.install.keymap=安裝按鍵映射…
label.appearance.caret.blinking=外觀\\: 文字游標閃爍
label.appearance.show.inner.whitespaces=外觀\\: 顯示內部空格
label.appearance.show.leading.whitespaces=外觀\\: 顯示前導空格
label.appearance.show.right.margin=外觀\\: 顯示右邊距
label.appearance.show.trailing.whitespaces=外觀\\: 顯示尾隨空格
label.appearance.show.vertical.indent.guides=外觀\\: 顯示垂直縮排參考線
label.autosave.comment=無法完全停用自動儲存。<a>工作原理</a>
label.category.n.a=不適用
label.category.unknown=未知
label.certificate.and=以及
label.certificate.expired=已過期
label.certificate.not.yet.valid=尚未生效
label.certificate.root=<根>
label.certificate.self.signed=自簽署
label.certificate.signed.by.untrusted.authority=由不受信任的機構簽署
label.certificate.untrusted.authority=不受信任的機構
label.certificate.will.be.saved=接受的憑證將被儲存在信任庫 {0} 中，預設密碼為 {1}
label.change.list.for.unlocked.files=\\   更改列表(&L)\\:
label.choose.color.scheme.importer=選擇 {0}
label.choose.target.file=選擇目標檔案
label.choosebyname.no.matches.found=未找到符合
label.choosebyname.searching=正在搜尋…
label.chrome.command.line.options=命令行選項(&C)\\:
label.continue.editing=繼續編輯
label.description=描述\\:
label.dont.show=不再顯示
label.downloading.cancelled=下載已取消
label.downloading.file.started=下載已開始
label.empty.file.name=<空檔名>
label.empty.text.attach.directories.with.right.click=通過右鍵點擊附加目錄
label.enable.debug.level=為日誌類別啟用 DEBUG 級別(每行一個)。<br>將 ''{0}'' 後綴追加到類別以啟用 TRACE 級別，或將 ''{1}'' 後綴追加到 ALL 級別。<br>追加 ''{2}'' 以將偵錯日誌寫入 \`idea.log\` 附近的單獨檔案中。<br>單獨的檔名包含縮短的記錄器名稱，例如直接在日誌中寫入的記錄器名稱。<br>新增 ''{0}\\:{2}'' 以設定日誌記錄級別和單獨的檔案。<br><br>
label.enter.group.name=輸入組名\\:
label.enter.new.abbreviation=輸入新縮寫\\:
label.enter.new.font.size.for.0=輸入 {0} 的新字號
label.extension=擴展(&E)\\:
label.file.name=檔名\\:
label.font.name=字體\\:
label.font.size=大小\\:
label.generate.file.name=檔名(&F)\\:
label.i.want.to.edit.choice=IDE 重啟前允許編輯\\:
label.icon.path=圖示(&I)\\:
label.inactive.timeout.sec=秒
label.install.freemium.for.free.with.trial.or=使用免費版本，開始 {0} 天試用，或
label.install.freemium.for.free.without.trial.or=使用免費版本或
label.install.paid.with.trial.or=開始 {0} 天試用或
label.install.paid.without.trial=要享受該延伸模組的好處，
label.invalid.color=<無效>
label.line.column=[行] [\\:列]\\:
label.macro.recording.started=巨集錄製已開始…
label.maximum.version=最高版本\\:
label.milliseconds=毫秒
label.minimum.version=最低版本\\:
label.more.files=和其他{0, choice, 1\\#1 個檔案|2\\#{0} 個檔案}
label.name=名稱(&N)\\:
label.new.version.will.be.available.after.restart=新版本將在重啟後可用
label.next.plugin.version.is=通過此更新，延伸模組將變為
label.no.actions.found=未找到動作
label.no.enabled.actions.found=未找到已啟用的動作
label.no.files.found=未找到檔案
label.no.matches.found=未找到符合
label.offset=偏移\\:
label.option.appearance=外觀\\: {0}
label.password.safe.password=密碼(&P)
label.password.safe.user=使用者(&U)
label.plugin=延伸模組\\:
label.plugin.0.downloads={0} 次下載
label.plugin.change.notes=更改說明
label.plugin.downloads=下載
label.plugin.freemium=免費增值
label.plugin.last.updated=上次更新
label.plugin.paid=付費
label.plugin.status=狀態
label.plugin.updated.0=已更新 {0}
label.plugin.vendor.email=電子郵件\\:
label.plugin.vendor.name=名稱\\:
label.project.files.location=專案位置(&L)\\:
label.project.name=專案名稱(&A)\\:
label.refactor.anyway=仍然重構
label.remote.sdk.helpers.path=幫助程序路徑\\:
label.remote.sdk.name=名稱(&N)\\:
label.remote.sdk.python.interpreter.path=Python 解釋器路徑\\:
label.scope=作用域(&S)\\:
label.scope.contains.files=作用域包含 {0} 個檔案，共 {1} 個
label.scope.editor.caret.position=位置\\: {0}
label.scope.pattern=模式(&P)\\:
label.select.configuration.element=選擇樹中的組態元素以編輯其設定
label.show.block.cursor=顯示塊游標
label.show.line.numbers=顯示行號
label.show.status.bar.widget=顯示 {0}
label.show.whitespaces=顯示空格
label.smooth.scrolling.bezier.panel.updates=每秒繪製請求數\\: {0}
label.smooth.scrolling.duration=持續時間
label.ssl.certificate.details=憑證詳細資訊
label.ssl.certificate.remoteHost=伺服器地址\\:
label.start.search.in.background=在背景開始搜尋
label.text.antialiasing.scope.editor=編輯器\\:
label.text.antialiasing.scope.ide=IDE\\:
label.text.character.count={0} 個字元
label.text.code.completion.saved=自 {1} 以來，程式碼補全至少為您節省了 {0}的輸入時間(每個工作日約 {2})
label.text.html.center.drop.here.to.attach.br.as.a.root.directory.center.html=<html><center>拖放至此處<br/>以作為根目錄附加</center></html>
label.text.image=圖片\\:
label.text.opacity=不透明度\\:
label.text.path.to.profiles.ini="profiles.ini" 的路徑\\:
label.text.plugin.eap.license.not.required=EAP 版本不需要授權
label.text.plugin.no.license=無授權。
label.text.profile=使用者組態(&P)\\:
label.text.put.stacktrace.here=在此放置一個堆疊追蹤\\:
label.text.quick.fixes.saved=自 {1} 以來，快速修復使您避免了 {0} 個可能的 bug (每個工作日約 {2} 個)
label.todo.filter.name=名稱\\:
label.todo.filters=篩選器\\:
label.todo.icon=圖示\\:
label.todo.multiline=將以下行中的縮排文本視為同一 TODO 的一部分
label.todo.pattern=模式\\:
label.todo.patterns=模式\\:
label.transparency.delay.ms=延遲(毫秒)\\:
label.transparency.ratio=比例\\:
label.ui.filter=篩選\\:
label.ui.name=名稱\\:
label.ui.value=值\\:
label.valid.from=從\\:
label.valid.until=至\\:
label.version=版本\\: {0}
label.version.0.1.build.2={0} {1} 構建版本 {2}
label.version.any=<any>
label.welcome.to.0=歡迎存取 {0}
label.you.can.create.a.desktop.entry=<html>您可以建立桌面條目，以便從系統選單輕鬆啟動 $APP_NAME$ <br>並更好地進行桌面整合。<html>
laf.action.install.theme=獲取更多主題…
large.file.editor.name=大檔案編輯器
large.file.preview.notification=檔案太大({0})。正在顯示第一個 {1} 的唯讀預覽。
light.header.theme.name=帶淺色標題的淺色
light.theme.name=淺色
link.activate.subscription=啟用訂閱…
link.cancel=取消
link.change.icon=更改…
link.change.project.icon=選擇 SVG 檔案…
link.change.project.icon.description=SVG 檔案將儲存到 .idea 目錄。<br/>要共享專案圖示，請將其新增到儲存庫。
link.check=檢查
link.enable.required.plugin=啟用 {0}
link.enable.required.plugins=啟用延伸模組
link.get.more.themes=獲取更多主題…
link.hide.processes=隱藏程序({0})
link.install.required.plugins=安裝延伸模組
link.label.wizard.step.plugin.customize=自訂…
link.learn.more=了解詳情
link.more=更多…
link.required.plugins.settings=開啟設定
link.reset.icon=重設
link.reset.project.icon=重設
link.show.all.processes=全部顯示({0})
link.smooth.scrolling.play.curve.animation=<a>播放此曲線的動畫</a>
link.smooth.scrolling.stop.curve.animation=<a>停止此曲線的動畫</a>
list.item.temporary.file.0=<temporary file>{0}
listbox.customfiletype.keywords=關鍵字
loading.in.progress=<html><body style\\='text-align\\: center;padding-top\\:20px;'>正在載入…</body></html>
log.in.link.text=登入…
login.dialog.authorization.token.field=IDE 授權令牌
login.dialog.back.link=← 返回
login.dialog.check.token=檢查令牌
login.dialog.eap.info.link=關於 EAP
login.dialog.empty.username=已登入
login.dialog.external.providers.panel.text=使用外部提供商登入
login.dialog.jb.login=登入 JetBrains Account
login.dialog.link.copied=鏈接已複製
login.dialog.log.out=登出…
login.dialog.manage.account=管理帳戶
login.dialog.manual.login=使用瀏覽器登入 JetBrains Account
login.dialog.manual.login.link=使用令牌登入…
login.dialog.new.user.label=新用戶?
login.dialog.register.link=建立帳戶
login.dialog.separator.text=或使用以下方式登入\\:
login.dialog.session.expired=授權會話已過期。請再次啟動
login.dialog.simple.login=登入 JetBrains Account
login.dialog.start.using=開始
login.dialog.title=登入 {0}
login.dialog.trouble.default.message=無法完成授權過程。
login.dialog.trouble.no.link={0}<br>有關可能的解決方案，請參閱<a href\\="{1}">幫助文章</a>。<br>如需幫助，請<a href\\="{2}">聯繫技術支援團隊</a>。
login.dialog.trouble.unknown=<a href\\="{0}">複製鏈接</a>並在瀏覽器中開啟，以獲取 IDE 授權令牌。
login.dialog.trouble.with.redirect=登入到您的帳戶並複製 IDE 授權令牌。<br/>如果瀏覽器未開啟，則 <a href\\="{0}">複製鏈接</a>並手動開啟。
login.dialog.troubles.link=有問題嗎?
login.dialog.waiting.for.login=正在等待在瀏覽器中登入…
login.dialog.waiting.for.login.short=正在等待登入…
login.dialog.welcome.to.eap=歡迎存取 {0} EAP
login.dialog.wrong.token=授權令牌錯誤
login.dialog.you.are.logged=您已登入
low.disk.space.message=系統目錄分區({0})上的剩餘空間少於 50 MiB
low.disk.space.title=磁碟空間不足
low.memory.notification.action=組態
low.memory.notification.analyze.action=準備記憶體報告
low.memory.notification.error=IDE 可用記憶體不足。請考慮增大“{0}”設定的值。
low.memory.notification.title=記憶體不足
low.memory.notification.warning=IDE 記憶體不足，這可能會影響性能。請考慮增加堆大小。
mac.window.tabs.close.other.tabs=關閉其他頁籤
mac.window.tabs.close.tab=關閉頁籤
mac.window.tabs.close.title=點擊以關閉此頁籤。按住 Option 鍵點擊以關閉除此之外的所有頁籤
mac.window.tabs.move.tab=將頁籤移至新視窗
mac.window.tabs.show.all.tabs=顯示所有頁籤
macOS.light.theme.name=macOS 淺色
macos.shortcut.conflict.few={0} 快捷鍵與 macOS 系統快捷鍵衝突。
macos.shortcut.conflict.many={0} 和 {1} 快捷鍵與 macOS 系統快捷鍵衝突。
main.menu.combobox.disabled.description=在“進階”設定中啟用“將主選單與視窗標題合併”來管理當前的 UI 設定。
main.menu.combobox.label=主選單\\:
main.toolbar.menu.button=主選單
manage.repositories.dialog.title=管理儲存庫
meetnewui.toolwindow.button.finishSetup=完成安裝
meetnewui.toolwindow.clean=簡潔
meetnewui.toolwindow.compact=緊湊
meetnewui.toolwindow.density=密度\\:
meetnewui.toolwindow.description=在“設定 > 外觀與行為 > <a>新 UI</a>”中組態或停用新 UI。
meetnewui.toolwindow.system=系統
meetnewui.toolwindow.theme=主題\\:
meetnewui.toolwindow.title=組態新 UI
memory.snapshot.captured.action.text=在 {1} 中開啟 ''{0}''
memory.snapshot.captured.text=在 {0} 的延伸模組移除失敗時捕獲記憶體快照
message.action.remove.system.assigned.shortcut=動作快捷鍵 {0} 已被分配給系統動作 ''{1}''。是否要移除此快捷鍵?
message.cannot.delete.0.1=無法刪除 ''{0}''，{1}
message.check.the.internet.connection.and=檢查互聯網連線並
message.connection.successful=連線成功
message.do.you.want.to.delete.0.1=是否要刪除“{0}”{1}?
message.link.refresh=重新整理
message.macro.exists=巨集 ''{0}'' 已存在。是否要覆蓋它?
message.module=模組 ''{0}''
message.module.file.has.an.older.format.do.you.want.to.convert.it=模組檔案為舊格式。是否要轉換?
message.modules=模組
message.move.modules.to.group=將 {0} 移至組 {1}
message.no.targets.available=在此上下文中沒有可用目標
message.occurrence.N.of.M=匹配項 {0}/{1}
message.path.to.fqn.has.been.copied=''{0}'' 已複製。
message.please.select.element.for.javadoc=選擇您想檢視其文檔的元素
message.project.will.be.saved.and.reopened.in.new.directory.based.format=專案將會儲存並以基於目錄的新格式重新開啟。確定要繼續嗎?
message.reference.to.fqn.has.been.copied=對 ''{0}'' 的參照已複製。
message.text.enter.url.to.check.connection=警告\\: 您的設定將被儲存。\\n輸入任意 URL 以檢查連線\\:
message.text.files.do.not.exist=<html><body>以下檔案不存在\\:<br>{0}相應的模組將不會轉換。是否要繼續?</body></html>
message.text.proxy.both.use.proxy.and.autodetect.proxy.set=代理\\: 同時設定了 'use proxy' 和 'autodetect proxy' 設定。應當只選擇其中一個選項。請重新組態。
message.text.proxy.passwords.were.cleared=已清除代理密碼。
message.text.unlock.read.only.files=<html><body>以下檔案為唯讀檔案。{0}將解鎖它們。<br>{1}</body></html>
message.the.path.0.does.not.exist.maybe.on.remote=路徑 {0} 不存在。\\n如果它位於可移動驅動器或網絡驅動器上，請確保該驅動器已連線。
message.there.are.no.available.schemes.to.import=沒有可供匯入的方案
message.this.functionality.is.not.available.during.indexing=索引編制期間此功能不可用
message.your.module.was.successfully.converted.br.old.version.was.saved.to.0=<html><body>您的模組已成功轉換。<br> 舊版本已儲存到 ''{0}''</body></html>
mixed.bag.installation=您的 {0} 安裝似乎已損壞，因為存在多個版本標記。當較新版本的歸檔被提取到包含現有安裝的目錄中時，通常就會發生這種情況。為避免出現崩潰，請從頭開始將 IDE 重新安裝到一個空目錄。
more.shortcuts.link.text.with.count=其他 {0}
name.invalid=無效
name.variable=在對話框中輸入的檔名
navigate.command.search.reference.progress.title=正在搜尋參照 ''{0}''
navigation.bar=導覽列
navigation.bar.item.sample=範例
new.changelist.make.active.checkbox=設為活動(&A)
new.dir.project.create=建立
new.dir.project.error.empty=專案路徑為空
new.dir.project.error.invalid=專案目錄路徑無效
new.file.popup.search.hint=搜尋檔案類型
new.plugin.manager.incompatible.deps.action=啟用所需{0, choice, 1\\#延伸模組|2\\#延伸模組}
new.plugin.manager.incompatible.deps.tooltip=未載入。所需{0, choice, 1\\#延伸模組|2\\#延伸模組} {1} {0, choice, 1\\#|2\\#}已停用。
no.charset.set.reason.charset.auto.detected.by.bom=字符集被 BOM 自動檢出
no.charset.set.reason.charset.auto.detected.from.content=字符集從內容中自動檢出
no.charset.set.reason.charset.hard.coded.in.file=字符集在檔案中硬編碼
no.charset.set.reason.disabled.for.binary.file=對二進制檔案停用
no.charset.set.reason.disabled.for.directory=對目錄停用
no.charset.set.reason.disabled.for.file.type=為 {0} 停用
no.disk.space.message=系統目錄分區({0})上的剩餘空間少於 1 MiB
no.disk.space.title=磁碟空間不足
no.information.available=無可用資訊
no.tip.of.the.day=<html><body>此功能目前尚無每日小技巧。</body></html>
node.call.hierarchy.N.usages=({0} 個用法)
node.default.package=<預設軟體套件>
node.hierarchy.invalid=[無效]
node.memberchooser.all.classes=所有類別
node.project.view.bad.link=無效的符號鏈接
node.projectview.external.libraries=外部庫
node.projectview.libraries=庫
node.projectview.library={0} 庫
node.structureview.invalid=<無效>
node.todo.group={0} {0,choice,0\\#項|1\\#項|2\\#項}
node.todo.items={0} {0, choice, 0\\#項|1\\#項|2\\#項}
node.todo.more.items=…更多…
node.todo.summary=在 {1} 個{1,choice,0\\#檔案|1\\#檔案|2\\#檔案}中找到 {0} 個 TODO {0,choice,0\\#條目|1\\#條目|2\\#條目}
notification.accessible.announce.prefix=通知
notification.action.load.paid.plugins.and.restart=啟用延伸模組並重啟
notification.action.unknown.macros.error.fix=修復
notification.cache.diagnostic.helper.text=已執行恢復步驟 {0}\\: ''{1}''
notification.cache.diagnostic.helper.title=IDE 修復
notification.cache.diagnostic.stop.text=現在一切正常
notification.configurable.display.name.notifications=通知
notification.content.cannot.find.keymap=找不到鍵映射“{0}”
notification.content.cannot.find.parent.keymap=找不到“{1}”的父鍵映射“{0}”
notification.content.color.scheme=使用者配色方案 ''{0}'' 指向不正確或不存在的基本方案 {1}，因此不會顯示
notification.content.input.method.disabler=IDE 執行時啟用了可能導致凍結的輸入方法。如果您並不使用這些輸入方法，不妨停用它們。
notification.content.internal\\ error=內部錯誤
notification.content.jcef.applySettings=要將新設定應用於 JCEF 瀏覽器，需要重啟 IDE
notification.content.jcef.browser.suspended.text=嵌入式瀏覽器被掛起。
notification.content.jcef.enable.browser.button=啟用瀏覽器…
notification.content.jcef.enable.browser.dialog.message=<html>嵌入式瀏覽器被掛起。系統限制在啟用沙盒的情況下執行嵌入式瀏覽器。必須安裝相應的 AppArmor 組態檔案才能在沙盒模式下啟動瀏覽器。<p><p><a href\\="https\\://youtrack.jetbrains.com/articles/JBR-A-11">了解詳情…</a></html>
notification.content.jcef.enable.browser.dialog.title=啟用嵌入式瀏覽器
notification.content.jcef.failed.to.install.apparmor.profile=無法安裝 AppArmor 組態檔案
notification.content.jcef.gpu.process.failed.error.message=<html>JCEF GPU 程序多次失敗。<br>嵌入式瀏覽器被掛起</html>
notification.content.jcef.gpucrash.action.disable=停用 GPU 並重啟
notification.content.jcef.gpucrash.action.restart=重啟
notification.content.jcef.gpucrash.message=GPU 程序重啟次數過多，似乎不穩定。請嘗試重啟 {0} 或完全停用 GPU 加速。
notification.content.jcef.gpucrash.title=GPU 程序(JCEF)重啟次數過多
notification.content.jcef.measureFPS=按任意鍵或切換焦點即可停止
notification.content.jcef.super.user.error.message=<html>IDE 在超級使用者下執行。<br>嵌入式瀏覽器被掛起</html>
notification.content.jcef.unprivileged.userns.restricted.action.add.apparmor.profile=安裝組態檔案…
notification.content.jcef.unprivileged.userns.restricted.action.disable.sandbox=停用沙盒
notification.content.jcef.unprivileged.userns.restricted.action.learn.more=了解詳情…
notification.content.jcef.unprivileged.userns.restricted.install.apparmor.profile.prompt=為 %s 安裝 AppArmor 組態檔案
notification.content.jcef.unprivileged.userns.restricted.message=系統限制在啟用沙盒的情況下執行嵌入式瀏覽器。必須安裝相應的 AppArmor 組態檔案才能在沙盒模式下啟動瀏覽器。
notification.content.jcef.unprivileged.userns.restricted.title=嵌入式瀏覽器已掛起
notification.content.jit.compiler.disabled=JVM JIT 編譯器已被停用。重啟 IDE 以重新啟用 JIT。<br><br>如果再次看到此訊息，請嘗試使用 <code>-XX\\:ReservedCodeCacheSize</code> 選項增加 CodeCache 的大小。<br><br>有關 JVM 選項的更多資訊，請參閱<a href\\="help">此幫助主題</a>。
notification.content.keymap.successfully.activated=按鍵映射 {0} 成功啟用
notification.content.keymap.successfully.installed=鍵映射 {0} 成功安裝
notification.content.mandatory.bom.br={0,choice,1\\#此檔案具有|2\\#這些檔案具有}強制性 BOM\\:<br/>{1}
notification.content.more.shortcut.conflict={0} 和其他 {1} 個快捷鍵與 macOS 快捷鍵衝突。請修改這些快捷鍵或更改 macOS 系統設定。
notification.content.paid.plugins.not.loaded=必須重新啟動應用程式才能啟用以下延伸模組\\: <br>
notification.content.please.restart.0=請重啟 {0}</p>{1}
notification.content.shortcut.conflicts.with.macos.shortcut.modify={0} 快捷鍵與 macOS 快捷鍵 {1} 衝突。請修改此快捷鍵或更改 macOS 系統設定。
notification.content.solarized.color.scheme.deprecation.enable=您正在使用即將刪除的 {0} 捆綁配色方案。請考慮改為啟用 {1} 主題
notification.content.solarized.color.scheme.deprecation.install=您正在使用即將刪除的 {0} 捆綁配色方案。請考慮切換到 {1} 延伸模組
notification.content.unable.to.save.project.files=無法儲存專案檔案。請確保專案檔案可寫入，並且您具備修改權限。<a href\\="">再次嘗試儲存專案</a>。
notification.content.unknown.macro.error={0} 未定義。
notification.content.unknown.macros.error={0} 未定義。
notification.content.unknown.macros.error.description=路徑變數用於取代專案檔案中的絕對路徑，並允許專案檔案在版本控制系統中共享。<br>當前專案設定的某些檔案包含未知的路徑變數，{0} 無法還原這些路徑。
notification.content.updated.plugin.to.version=已將 {0} 延伸模組更新到版本 {1}
notification.content.updated.plugins=已更新 {0} 個延伸模組
notification.group.advertiser.try.ultimate.installed=安裝完成
notification.group.advertiser.try.ultimate.installed.content=您的設定將被遷移。{0} 仍將可用。
notification.group.advertiser.try.ultimate.installed.title={0} 已安裝
notification.group.browser.config.problems=瀏覽器組態問題
notification.group.built.in.server=內建 HTTP 伺服器無法啟動
notification.group.cache.recovery=已執行快取恢復步驟
notification.group.essential-highlighting.mode=基本醒目提示模式已啟用
notification.group.failed.to.generate.module.descriptors=無法生成模組檔案描述子
notification.group.failed.to.remove.bom=無法移除 BOM
notification.group.ide.and.plugin.updates=IDE 和延伸模組更新可用
notification.group.ide.errors=IDE 錯誤
notification.group.ide.update.results=IDE 更新已安裝
notification.group.language.plugin=推薦的語言延伸模組可用
notification.group.leftover.directories=找到了殘留的 IDE 目錄
notification.group.load.error=無法載入設定
notification.group.low.memory=檢測到記憶體不足
notification.group.missing.keymap=缺少快捷鍵
notification.group.paid.plugins=付費延伸模組未載入
notification.group.password.safe=密碼存儲不可用
notification.group.plugin.error=延伸模組載入失敗
notification.group.plugin.updates=延伸模組已安裝或更新
notification.group.plugins.suggestion=有可用的延伸模組建議
notification.group.power.save.mode=已啟用省電模式
notification.group.project.settings=無法儲存專案
notification.group.required.plugins=未載入所需的延伸模組
notification.group.settings.error=無法儲存設定
notification.group.system.clipboard=系統剪貼簿不可用
notification.group.system.health=檢測到系統執行狀況問題
notification.group.system.messages=系統訊息
notification.group.too.many.carets=已達到編輯器文字游標的最大數量
notification.manager.content.height.linebreak=<br>\\n
notification.manager.content.height.word=內容
notification.manager.merge.n.more=其他 {0} 個
notification.manager.merge.n.more.from=來自 {1} 的其他 {0} 個
notification.settings.action.text=設定…
notification.title.activated.from.command.line=已從命令行啟用
notification.title.browser.config.problem=瀏覽器組態問題
notification.title.cannot.open=無法開啟 URL
notification.title.desktop.entry.created=已建立桌面條目
notification.title.desktop.entry.creation.failed=桌面條目建立失敗
notification.title.enable.action.solarized.color.scheme.deprecation=啟用 {0} 主題
notification.title.incompatible.color.scheme=不相容的配色方案
notification.title.input.method.disabler=輸入方法停用程序
notification.title.install.action.solarized.color.scheme.deprecation=安裝 Marketplace 中的 Solarized Themes 延伸模組
notification.title.jcef.measureFPS=OSR JCEF FPS Meter
notification.title.jcef.proxyChanged=代理設定已更改
notification.title.jit.compiler.disabled=重啟 IDE 避免減速
notification.title.paid.plugins.not.loaded=延伸模組未載入
notification.title.required.plugins.not.loaded=尚未載入必需延伸模組
notification.title.shortcuts.conflicts=快捷鍵衝突
notification.title.solarized.color.scheme.deprecation=配色方案棄用
notification.title.unknown.macros.error=載入錯誤\\: 未定義的路徑變數
notification.title.was.unable.to.remove.bom.in=無法移除 {0} {0,choice,1\\#檔案|2\\#檔案}中的 BOM
notifications.collapse.balloon.title=其他 {0} 個{1}
notifications.collapse.balloon.title.suggestion={0,choice,1\\#建議|1<建議}
notifications.collapse.balloon.title.timeline={0,choice,1\\#通知|1<通知}
notifications.configurable.announcing.comment=如果上一個輸出具有較低的優先級，則通知將中斷該輸出
notifications.configurable.announcing.title=使用螢幕閱讀器宣布\\:
notifications.configurable.announcing.value.high=具有高優先級
notifications.configurable.announcing.value.interrupting=正在中斷當前輸出
notifications.configurable.announcing.value.medium=具有中等優先級
notifications.configurable.announcing.value.not.interrupting=當前輸出完成後
notifications.configurable.announcing.value.off=關
notifications.configurable.column.group=組
notifications.configurable.column.log=日誌
notifications.configurable.column.popup=彈出視窗類型\\:
notifications.configurable.column.read.aloud=大聲朗讀
notifications.configurable.column.toolwindow=在工具視窗中顯示
notifications.configurable.display.balloon.notifications=顯示氣球通知
notifications.configurable.do.not.ask.project.title=此專案
notifications.configurable.do.not.ask.title=不再詢問通知\\:
notifications.configurable.enable.system.notifications=啟用系統通知
notifications.configurable.no.notifications.configured=未組態通知
notifications.configurable.play.sound=播放聲音
notifications.toolwindow.dont.show.again=不再顯示
notifications.toolwindow.dont.show.again.for.this.project=不再為此專案顯示
notifications.toolwindow.empty.text.first.line=建議、事件，
notifications.toolwindow.empty.text.second.line=以及錯誤將出現在這裡
notifications.toolwindow.remind.tomorrow=明天提醒我
notifications.toolwindow.suggestions=建議
notifications.toolwindow.timeline=時間線
notifications.toolwindow.timeline.clear.all=全部清除
old.dirs.action.progress=正在尋找殘留的 IDE 存儲目錄…
old.dirs.column.name=目錄
old.dirs.column.size=大小
old.dirs.column.updated=上次使用
old.dirs.delete.error=無法刪除目錄
old.dirs.delete.progress=正在刪除目錄…
old.dirs.dialog.delete.button=刪除 {0} 個{0,choice,0\\#目錄|1\\#目錄|2\\#目錄}
old.dirs.dialog.text=<html>安裝在您計算機上的其他 IDE 版本使用下面列出的目錄來存儲特定於版本的<br>設定、快取和延伸模組。刪除它們可以釋放空間，並且不影響<i>此版本</i>的穩定性。<br><b>警告</b>\\: 不要刪除仍在使用的版本的目錄\\!<br><br>選擇要刪除的目錄\\:</html>
old.dirs.dialog.title=刪除殘留的 IDE 存儲目錄
old.dirs.not.found.notification.text=沒有找到殘留的 IDE 存儲目錄。
old.dirs.notification.action=檢視並刪除…
old.dirs.notification.text=找到殘留的 IDE 存儲目錄。
only.at.line.start=僅在行首(\\\\&O)
open.in.0=在 {0} 中開啟
open.in.browser=在瀏覽器中開啟(_B)
open.selected.file.in.browser=在瀏覽器中開啟所選檔案
open.url.in.0=在 {0} 中開啟 URL
open.url.in.browser.tooltip=在瀏覽器中開啟
option.hide.tool.window.bars=隱藏工具視窗列
option.is.overridden.by.jvm.property=此選項已由 JVM 屬性覆寫\\:“{0}”
option.show.tips.on.startup=啟動時顯示每日小技巧
overridden.by.jvm.property=已被 JVM 屬性 ''{0}'' 覆寫
package.0.installed.successfully=已成功安裝軟體套件 ''{0}''
package.installed.successfully=已成功安裝軟體套件
package.successfully.uninstalled=已成功移除軟體套件 ''{0}''
package.successfully.upgraded=已成功升級軟體套件 {0}
packages.settings.latest.version=最新版本
packages.settings.loading=正在載入軟體套件列表
packages.settings.package=軟體套件
packages.settings.version=版本
packages.successfully.uninstalled=已成功移除軟體套件
packages.title=軟體套件
path.macro.ignored.variables=忽略的變數\\:
path.macro.use.semicolon=使用 ; 分隔忽略的變數
please.edit.repository.url=請編輯儲存庫 URL
please.input.repository.url=請輸入儲存庫 URL
plugin.advertiser.free.trial.action=30 天免費試用
plugin.advertiser.product.call.to.action={0}\\: {1}
plugin.available.in.commercial.ide.text=此延伸模組僅適用於 {0} 訂閱
plugin.description.vim.editor=Vim 編輯器仿真
plugin.descriptor.aws.toolkit=建立、測試和偵錯使用 AWS 無伺服器應用程式模型建置的無伺服器應用程式
plugin.group.cloud.support=雲支援
plugin.group.editor=編輯器
plugin.group.tools.integration=工具整合
plugin.has.ultimate.features.text=此延伸模組可以通過 {0} 提供更多功能
plugin.info.not.available=不適用
plugin.info.unknown=未知
plugin.installed.ide.restart.required.message=延伸模組“{0}”已安裝。{1} {2} 以在延伸模組中套用更改?
plugin.invalid.signature.result=''{0}'' 延伸模組的數位簽章驗證失敗並顯示以下訊息\\: ''{1}''。
plugin.manager.action.label.sort.by=排序依據\\: {0}
plugin.manager.action.label.sort.by.1=排序依據
plugin.manager.custom.certificates=管理延伸模組憑證…
plugin.manager.dependencies.detected.message=''{0}'' 延伸模組需要安裝 {1}。
plugin.manager.dependencies.detected.title=安裝必需延伸模組
plugin.manager.incompatible.tooltip=延伸模組與當前 {0} 安裝不相容
plugin.manager.installed.panel.accessible.name=已安裝
plugin.manager.installed.tooltip=延伸模組將在重啟後啟用
plugin.manager.main.suggest.to.enable.message.part1=更新的延伸模組 ''{0}'' 已停用。
plugin.manager.main.suggest.to.enable.message.part2=更新的延伸模組 {0} 已停用。
plugin.manager.main.suggest.to.enable.message.part3=更新的依賴於停用內容的{0,choice,1\\#延伸模組|2\\#延伸模組}
plugin.manager.main.suggest.to.enable.message.part4=延伸模組 ''{0}''。
plugin.manager.main.suggest.to.enable.message.part5=延伸模組 {0}。
plugin.manager.main.suggest.to.enable.message.part6=被停用的延伸模組和相依停用的延伸模組在重啟後不會被啟用。
plugin.manager.main.suggest.to.enable.message.part7=停用的延伸模組在重啟後不會被啟用。
plugin.manager.main.suggest.to.enable.message.part8=是否想要啟用更新的{0,choice, 1\\#延伸模組|2\\#延伸模組}
plugin.manager.main.suggest.to.enable.message.part9=是否想要啟用延伸模組{0,choice,1\\#相依項|2\\#相依項}
plugin.manager.marketplace.panel.accessible.name=Marketplace
plugin.manager.new.version.tooltip=從版本 {0} 更新安裝的延伸模組
plugin.manager.obsolete.plugins.detected.title=停用衝突的延伸模組
plugin.manager.optional.dependencies.detected.message=建議安裝包含延伸模組 ''{0}'' 的 {1}。
plugin.manager.optional.dependencies.detected.title=安裝推薦的延伸模組
plugin.manager.options.command=輸入 / 以檢視選項
plugin.manager.plugins.auto.update.description=啟用延伸模組自動更新以始終擁有其最新版本。
plugin.manager.plugins.auto.update.title=延伸模組自動更新
plugin.manager.refresh=重新整理
plugin.manager.replace.plugin.0.by.plugin.1=<html>''{1}'' 延伸模組旨在替代安裝的 ''{0}'' 延伸模組。<br>停用“{0}”延伸模組以避免衝突?</html>
plugin.manager.repositories=管理延伸模組儲存庫…
plugin.manager.search.accessible.name=搜尋延伸模組
plugin.manager.search.filters.popup.accessible.name=搜尋篩選器
plugin.manager.tab.installed=已安裝
plugin.manager.tab.marketplace=Marketplace
plugin.manager.tooltip=從磁碟管理儲存庫、組態代理或安裝延伸模組
plugin.manager.uninstalled.tooltip=延伸模組已被移除；重啟後將套用更改
plugin.manager.update.all=全部更新
plugin.manager.update.available.tooltip=有更新版本的延伸模組可用
plugin.manager.updated.tooltip=延伸模組已升級到最新版本；重啟後將套用更改
plugin.message.plugin.only.supported.in=此延伸模組僅在 {0} 中可用。
plugin.settings.link.title=延伸模組設定…
plugin.signature.checker.no=取消安裝
plugin.signature.checker.revoked.cert=<html><body>''{0}'' 延伸模組已撤消 JetBrains 憑證</body></html>
plugin.signature.checker.title=延伸模組安全警告
plugin.signature.checker.yes=忽略並繼續
plugin.signature.not.signed=<html><body>''{0}'' 延伸模組未進行數位簽章，無法驗證其可靠性。安裝或更新未簽名的延伸模組可能會將您的系統置於風險之中。<br/><br/>延伸模組詳細資訊\\: ID\\: {1}，版本\\: {2} {3}</body></html>
plugin.status.bundled=已捆綁
plugin.status.installed=已安裝
plugin.status.not.allowed=已阻止
plugin.status.not.allowed.but.enabled=停用\\!
plugin.status.not.allowed.tooltip=您的組織未批准此延伸模組
plugin.status.not.allowed.tooltip.but.enabled=請停用此延伸模組，因為它未經您的組織批准
plugin.status.not.specified=(未指定)
plugin.update.dialog.total.label=總計\\: {0}
plugin.updater.downloading=正在下載延伸模組
plugin.updater.error.cant.find.plugin.version=在儲存庫響應中找不到延伸模組版本
plugin.updater.error.check.failed=延伸模組更新檢查失敗
plugin.updater.error.custom.repository=檢查自訂延伸模組儲存庫 {0} 失敗
plugin.updater.error.unexpected.repository.response=意外延伸模組儲存庫響應
plugin.updater.install=安裝
plugin.updater.not.installed=未安裝延伸模組更新
plugin.updater.not.installed.misc=未安裝延伸模組更新\\: {0}
plugin.updater.not.installed.see.log.action=請參閱日誌了解更多資訊
plugin.updater.notification.message={1} 延伸模組有可用的新版本 {0}
plugin.vendor.info.label=供應商\\: {0}
plugin.vendor.non.trader.label=非貿易商
plugin.vendor.non.trader.status=根據指令(EU) 2019/2161 的定義，此供應商已將自己標識為非貿易商。源自歐盟消費者保護法的消費者權利將不適用。
plugin.vendor.trader.label=貿易商
plugin.vendor.trader.status=此供應商已根據指令(EU) 2019/2161 的定義將自己標識為貿易商。源自歐盟消費者保護法的消費者權利將適用。
plugin.verified.organization=已驗證的組織
plugin.version.bundled=已捆綁
plugins.advertiser.action.configure.plugins=組態延伸模組…
plugins.advertiser.action.enable.plugin=啟用延伸模組
plugins.advertiser.action.enable.plugins=啟用延伸模組…
plugins.advertiser.action.ignore.extension=忽略擴展
plugins.advertiser.action.ignore.ultimate=關閉
plugins.advertiser.action.ignore.unknown.feature=不再建議
plugins.advertiser.action.ignore.unknown.features=不再建議
plugins.advertiser.action.install.plugin.name=安裝 {0} 延伸模組
plugins.advertiser.action.install.plugins=安裝延伸模組
plugins.advertiser.action.try.ultimate=試用 {0}
plugins.advertiser.check.progress=正在檢查專案的推薦延伸模組
plugins.advertiser.extensions.supported.in.ides=<hyperlink>其他 JetBrains IDE</hyperlink> 中支援 {0} 檔案
plugins.advertiser.extensions.supported.in.ultimate={1} 支援 {0} 檔案
plugins.advertiser.feature.dependency=相依項
plugins.advertiser.framework.supported.in.ultimate={1} 支援 {0} 組態檔案
plugins.advertiser.learn.more=了解詳情
plugins.advertiser.missing.feature=支援 {1} ''{2}'' 的{0,choice,1\\#延伸模組|2\\#延伸模組} {4} {0,choice,1\\#當前|2\\#當前}{3,choice,0\\#已停用|1\\#尚未安裝}。
plugins.advertiser.missing.features=支援功能({1})的{0,choice,1\\#延伸模組|2\\#延伸模組} {3} {0,choice,1\\#當前|2\\#當前}{2,choice,0\\#已停用|1\\#尚未安裝}。
plugins.advertiser.missing.features.dependency=推薦的{0,choice,1\\#延伸模組|2\\#延伸模組} {1} 可用。
plugins.advertiser.no.suggested.plugins=找不到推薦的延伸模組
plugins.advertiser.plugins.file.handler.found=找到支援 {0} 的延伸模組。
plugins.advertiser.plugins.found=已找到支援 {0} 檔案的延伸模組。
plugins.advertiser.plugins.suggestions.text=已找到所選相依項的延伸模組。
plugins.advertiser.plugins.suggestions.title=延伸模組建議
plugins.advertiser.task.searching.for.plugins=在儲存庫中搜尋延伸模組
plugins.advertiser.try.ultimate.cancel.button=取消
plugins.advertiser.try.ultimate.could.not.download=無法從 {1} 下載 {0} 的發行版。網絡錯誤。
plugins.advertiser.try.ultimate.could.not.install=無法安裝 {0}。出錯了。
plugins.advertiser.try.ultimate.could.not.open=無法開啟 {0}。出錯了。
plugins.advertiser.try.ultimate.dialog.open.website=開啟網站
plugins.advertiser.try.ultimate.dialog.title=試用 {0}
plugins.advertiser.try.ultimate.dialog.try.again=再次試用
plugins.advertiser.try.ultimate.download=正在下載…
plugins.advertiser.try.ultimate.download.started.balloon={0} 正在下載並將自動安裝。
plugins.advertiser.try.ultimate.install=正在安裝…
plugins.advertiser.try.ultimate.opening=正在開啟 {0}…
plugins.advertiser.try.ultimate.upgrade=正在升級到 {0}…
plugins.advertiser.ultimate.features.detected=檢測到 IntelliJ IDEA Ultimate {0} 涵蓋的功能
plugins.auto.disabled.notification.content={0} 和 {1} 延伸模組已停用。
plugins.auto.disabled.notification.title=相依延伸模組已停用
plugins.auto.enabled.notification.content={0} 和 {1} 延伸模組已啟用。
plugins.auto.enabled.notification.title=必需延伸模組已啟用
plugins.auto.switch.action.name=撤消
plugins.changed.notification.content=延伸模組列表已更改。請重啟 {0} 以啟用更改。
plugins.changed.notification.title=需要重啟
plugins.configurable.InstalledSearchOption.Bundled=已捆綁
plugins.configurable.InstalledSearchOption.Disabled=停用
plugins.configurable.InstalledSearchOption.Downloaded=已下載
plugins.configurable.InstalledSearchOption.Enabled=啟用
plugins.configurable.InstalledSearchOption.Invalid=無效
plugins.configurable.InstalledSearchOption.NeedUpdate=可用的更新
plugins.configurable.SortBySearchOption.Downloads=下載
plugins.configurable.SortBySearchOption.Name=名稱
plugins.configurable.SortBySearchOption.Rating=評分
plugins.configurable.SortBySearchOption.Relevance=相關性
plugins.configurable.SortBySearchOption.Updated=已更新
plugins.configurable.activate.trial.for.full.access=購買授權
plugins.configurable.additional.info.tab.name=其他資訊
plugins.configurable.bugtracker.url=問題追蹤器
plugins.configurable.bundled.updates=捆綁的延伸模組更新
plugins.configurable.buy.the.license=購買授權
plugins.configurable.buy.the.license.from.0=購買授權，價格低至 {0}
plugins.configurable.check.internet=檢查互聯網連線。
plugins.configurable.choose.update.checkbox.accessible.name=更新
plugins.configurable.disable=停用
plugins.configurable.disable.all=全部停用
plugins.configurable.disable.all.downloaded=停用所有下載的延伸模組
plugins.configurable.disabled=已停用
plugins.configurable.documentation.url=文檔
plugins.configurable.downloaded=已下載
plugins.configurable.downloads.0=下載量\\: {0}
plugins.configurable.enable=啟用
plugins.configurable.enable.all=全部啟用
plugins.configurable.enable.all.downloaded=啟用所有下載的延伸模組
plugins.configurable.enable.checkbox.accessible.name=已啟用
plugins.configurable.enabled=已啟用
plugins.configurable.forum.url=論壇頁面
plugins.configurable.install=安裝
plugins.configurable.installed=已安裝
plugins.configurable.installing=正在安裝
plugins.configurable.license.expired=授權已過期。
plugins.configurable.license.expires.in.0.days=授權將於 {0} 天後到期。
plugins.configurable.license.is.active=授權有效。
plugins.configurable.license.is.active.until.0=授權有效期至 {0}。
plugins.configurable.license.url=授權
plugins.configurable.list.component.accessible.description.0.downloads={0} 次下載
plugins.configurable.list.component.accessible.description.0.stars={0} 顆星
plugins.configurable.list.component.accessible.description.install.available=可供安裝
plugins.configurable.list.component.accessible.description.restart.pending=待處理的 IDE 重啟
plugins.configurable.list.component.accessible.description.update.available=可用的更新
plugins.configurable.marketplace.plugins.not.loaded=未載入 Marketplace 延伸模組。
plugins.configurable.new.and.updated=新增和更新
plugins.configurable.not.allowed=您的組織未批准此延伸模組
plugins.configurable.notes.empty.text=很遺憾，{0} 未留下任何更新說明。
plugins.configurable.notes.empty.text.default.vendor=供應商
plugins.configurable.nothing.found=找不到任何內容。
plugins.configurable.one.plugin.details=選擇一個延伸模組以預覽延伸模組詳細資訊。
plugins.configurable.other.bundled=其他工具
plugins.configurable.overview.tab.name=概覽
plugins.configurable.plugin.details=選擇延伸模組以預覽詳細資訊
plugins.configurable.plugin.details.page.accessible.name=延伸模組詳細資訊
plugins.configurable.plugin.details.page.accessible.name.0={0} 詳細資訊
plugins.configurable.plugin.details.tags.panel.accessible.name=標記
plugins.configurable.plugin.feedback=<a href\\='showFeedback'>分享有關該延伸模組的反饋</a>，幫助我們進行改進
plugins.configurable.plugin.homepage.link=延伸模組主頁
plugins.configurable.plugin.installing.failed=延伸模組“{0}”下載或安裝失敗
plugins.configurable.plugin.installing.success=延伸模組 {0} 已成功安裝
plugins.configurable.plugin.unavailable.for.platform=延伸模組對 {0} 不可用
plugins.configurable.rate.0=評分\\: {0}
plugins.configurable.release.date.0=發佈日期\\: {0}
plugins.configurable.report.marketplace.plugin=舉報延伸模組
plugins.configurable.repository.0=儲存庫\\: {0}
plugins.configurable.required.plugins.0=相依項\\:\\n{0}
plugins.configurable.restart.ide.button=重啟 IDE
plugins.configurable.reviews.tab.name=評價
plugins.configurable.search.in.marketplace=在 Marketplace 中搜尋
plugins.configurable.search.options=搜尋選項
plugins.configurable.search.result.0.plugins.found.in.1=在 {1} 中找到了 {0} 個{0, choice, 0\\#延伸模組|1\\#延伸模組|2\\#延伸模組}。
plugins.configurable.search.result.not.loaded=未載入搜尋結果。
plugins.configurable.several.plugins=已選擇多個延伸模組。
plugins.configurable.show=顯示
plugins.configurable.show.all=全部顯示
plugins.configurable.size.0=大小\\: {0}
plugins.configurable.sort.by=排序依據
plugins.configurable.source.code=原始碼
plugins.configurable.staff.picks=員工選擇
plugins.configurable.suggested=推薦
plugins.configurable.suggested.features.dependency=建議使用此延伸模組，因為您的專案使用了 {0} 庫
plugins.configurable.suggested.features.executable=建議使用此延伸模組，因為您已經安裝了 {0}
plugins.configurable.title.with.count={0} (已啟用 {1}/{2})
plugins.configurable.top.downloads=熱門下載
plugins.configurable.top.rated=最受好評
plugins.configurable.trial.expires.in.0.days=試用將於 {0} 天後到期。
plugins.configurable.unavailable.for.platform=不可用
plugins.configurable.uninstall=移除
plugins.configurable.uninstall.bundled.update=移除更新
plugins.configurable.uninstalled=已移除
plugins.configurable.update.button=更新
plugins.configurable.version.0=版本\\: {0}
plugins.configurable.whats.new.tab.name=最新變化
plugins.new.review.action=撰寫評價
plugins.progress.loading.plugin.title=正在載入延伸模組 {0}
plugins.progress.loading.plugins.for.current.project.title=正在載入延伸模組 
plugins.progress.unloading.plugin.title=正在移除延伸模組 {0}
plugins.progress.unloading.plugins.for.current.project.title=正在上傳 ''{0}'' 的延伸模組
plugins.reloaded.successfully={0} 成功重新載入
plugins.review.action.copy.link.text=複製鏈接
plugins.review.note=JetBrains 不會核實評價。
plugins.review.note.link=了解詳情
plugins.review.panel.empty.text=目前尚無評價。
plugins.review.panel.next.page.button=展開
popup.action.item.toggleable.checked.accessible.description=已檢查
popup.action.item.toggleable.not.checked.accessible.description=未檢查
popup.content.action.not.available.while.updating.indices=''{0}'' 在 {1} 更新索引期間不可用
popup.content.actions.not.available.while.updating.indices=在 {1} 更新索引期間 {0} 不可用
popup.content.none.of.following.actions.are.available.while.updating.indices=當 {0} 更新索引時，以下動作均不可用\\: {1}
popup.content.this.action.not.available.while.updating.indices=當 {0} 更新索引時，此動作不可用
popup.license.button.non.commercial.usage=管理授權…
popup.list.item.renderer.next.step.label.accessible.name=子選單
popup.new.element.empty.text.1=找不到檔案類型。
popup.new.element.empty.text.2=使用任意副檔名
popup.new.element.empty.text.3=建立新檔案
popup.new.element.list.accessible.name=檔案類型
popup.text.non.commercial.usage=<b>僅限非商業用途</b><br><br>使用您當前的授權，您可以\\:<br><ul><li>僅出於非商業目的進行開發</li><li>隨時切換到試用版或付費授權</li></ul><a href\\="https\\://www.jetbrains.com/legal/docs/toolbox/license_non-commercial/">非商業用途協議</a><br><br><a href\\="{0}">方案和定價</a>
popup.title.add.group.options=新增{0}選項
popup.title.add.run.options=新增執行選項
popup.title.add.tags=新增標記
popup.title.edit.shortcuts=編輯快捷鍵
popup.title.import.scheme=匯入方案
popup.title.in.editor.mode=在編輯器模式下
popup.title.maintenance=維護
popup.title.notification.display.type=通知顯示類型
popup.title.open.project=開啟專案
popup.title.play.saved.macros=播放儲存的巨集
popup.title.switch=切換
power.save.mode.disable.action.title=停用省電模式
power.save.mode.on.notification.content=程式碼洞察和背景任務已停用。
power.save.mode.on.notification.title=省電模式已開啟
preferred.editor.color.scheme.dark.header=用於深色作業系統
preferred.editor.color.scheme.description=選擇自動檢測模式的首選編輯器配色方案
preferred.editor.color.scheme.light.header=用於淺色作業系統
preferred.editor.color.scheme.text=首選編輯器配色方案
preferred.theme.and.editor.color.scheme.description=選擇自動檢測模式的首選主題和編輯器配色方案
preferred.theme.and.editor.color.scheme.text=首選主題和編輯器配色方案
preferred.theme.autodetect.selector=與作業系統同步
preferred.theme.dark.header=用於深色作業系統
preferred.theme.description=為自動檢測模式選擇首選主題
preferred.theme.light.header=用於淺色作業系統
preferred.theme.text=首選主題
presentation.assistant.configurable.alignment.bottom.center=底部居中
presentation.assistant.configurable.alignment.bottom.left=左下
presentation.assistant.configurable.alignment.bottom.right=右下
presentation.assistant.configurable.alignment.top.center=頂部居中
presentation.assistant.configurable.alignment.top.left=左上
presentation.assistant.configurable.alignment.top.right=右上
presentation.assistant.configurable.description=描述\\:
presentation.assistant.configurable.duration=顯示\\:
presentation.assistant.configurable.duration.seconds=秒發送保持活動的訊息
presentation.assistant.configurable.font.size=字體大小\\:
presentation.assistant.configurable.keymap.additional=其他\\:
presentation.assistant.configurable.keymap.group=按鍵映射
presentation.assistant.configurable.keymap.label=標籤\\:
presentation.assistant.configurable.keymap.mac=macOS
presentation.assistant.configurable.keymap.main=主\\:
presentation.assistant.configurable.keymap.win=Windows
presentation.assistant.configurable.keymap.win.label=Win/Linux
presentation.assistant.configurable.margin=邊距\\:
presentation.assistant.configurable.name=Presentation Assistant
presentation.assistant.configurable.popup.position=位置\\:
presentation.assistant.configurable.popup.size=彈出視窗大小\\:
presentation.assistant.configurable.size.large=大
presentation.assistant.configurable.size.medium=中
presentation.assistant.configurable.size.small=小
presentation.assistant.configurable.theme=主題\\:
presentation.assistant.configurable.theme.bright=明亮
presentation.assistant.configurable.theme.pale=暗淡
presentation.assistant.configurable.toggle=在彈出視窗中顯示動作名稱和快捷方式
presentation.assistant.notification=Presentation Assistant
presentation.assistant.notification.action.hide=不顯示 macOS 快捷方式
presentation.assistant.notification.action.install=安裝延伸模組
presentation.assistant.notification.content=要顯示 macOS 的快捷方式，您需要安裝 macOS Keymap 延伸模組
presentation.assistant.notification.title=macOS 的快捷方式未顯示
presentation.assistant.quick.settings.ad=拖動彈出視窗可自訂位置
presentation.assistant.quick.settings.position.group=位置
presentation.assistant.quick.settings.settings=設定…
presentation.assistant.quick.settings.size.group=大小
presentation.assistant.quick.settings.theme.group=主題
presentation.assistant.settings=Presentation Assistant
presentation.mode.fon.size=字體大小\\:
presentation.mode.ide.scale=縮放\\:
presentation.mode.ide.scale.out.of.range.number.message.format=指定一個介於 {0}% 到 {1}% 之間的值
presentation.mode.ide.scale.wrong.number.message=指定正整數
press.0.to.assign.a.shortcut=按 {0} 分配快捷鍵
press.copy.key.to.copy.system.information.to.clipboard=按 Copy 鍵將系統資訊複製到剪貼簿
product.and.plugin={0} 和 {1} 延伸模組
progress.closing.project=正在關閉專案…
progress.connecting.to.plugin.manager=正在連線到 {0}
progress.counting.files=正在進行檔案計數…
progress.creating.directory=正在建立目錄 {0}{1}{2}
progress.creating.file=正在建立檔案 {0}{1}{2}
progress.creating.package=正在建立軟體套件 {0}。{1}
progress.deleting=正在刪除
progress.deleting.class=正在刪除類別 {0}
progress.download.plugins=下載延伸模組
progress.downloading.available.plugins=正在下載可用延伸模組列表
progress.downloading.list.of.plugins=正在從 {0} 下載延伸模組列表
progress.downloading.plugin=正在下載延伸模組 ''{0}''
progress.downloading.plugins.meta=正在下載延伸模組 {0} 的資料
progress.file.system.changes=檔案系統更改
progress.performing.indexing.tasks=正在執行編制索引任務
progress.saving.app=正在儲存應用程式設定
progress.saving.project=正在儲存 ''{0}'' 設定
progress.searching=正在搜尋…
progress.text.clickToViewProgressWindow=點擊以檢視所有正在執行的背景任務
progress.text.collecting.classes=正在收集類別列表…
progress.text.downloading=正在下載…
progress.text.generate.classes.archive=正在生成類別歸檔…
progress.text.loading=正在載入…
progress.text.migrating.plugins=正在遷移延伸模組…
progress.text.paused=已暫停
progress.text.reloading.file=正在重新載入檔案…
progress.text.reloading.files=正在重新載入檔案…
progress.text.reopening.files=正在重新開啟檔案…
progress.text.stopping=正在停止 - {0}
progress.third.party.software=正在載入第三方軟體授權
progress.title.check.connection=檢查連線
progress.title.checking.plugin.dependencies=正在檢查延伸模組相依項
progress.title.checking.plugins.repository=正在檢查延伸模組儲存庫…
progress.title.constructing.tooltip=正在建置工具提示
progress.title.creating.git.repository=建立 Git 儲存庫
progress.title.deleting.files=正在刪除檔案…
progress.title.installing.plugin=正在安裝延伸模組“{0}”…
progress.title.loading.paid.plugins=正在啟用訂閱…
progress.title.loading.plugin.details=正在載入延伸模組詳細資訊
progress.title.preparing.navigation=正在準備導覽…
progress.title.project.initialization=專案初始化…
progress.title.reload.files=重新載入檔案
progress.window.empty.text=無背景任務
progress.window.title=背景任務
project.scheme=專案
project.structure.tree.accessible.name=專案結構樹
prompt.browse.icon.for.selected.action=以 SVG 或 PNG 格式瀏覽圖示
prompt.create.non.existing.package=軟體套件 {0} 不存在。\\n是否要建立?
prompt.delete.and=和
prompt.delete.directory={0,choice,1\\#目錄|2\\#目錄}
prompt.delete.directory.paren=({0} {0,choice,1\\#目錄|2\\#目錄})
prompt.delete.elements=刪除{0}?
prompt.delete.file={0,choice,1\\#檔案|2\\#檔案}
prompt.delete.it.anyway=仍要刪除?
prompt.delete.property={0,choice,1\\#屬性|2\\#屬性}
prompt.delete.symlink={0,choice,1\\#符號鏈接|2\\#符號鏈接}
prompt.directory.contains.read.only.files=目錄 {0} 包含唯讀檔案。仍要刪除?
prompt.enter.a.new.package.name=輸入一個新的軟體套件名稱\\:
prompt.enter.macro.name=輸入巨集名稱。如果為臨時巨集，請留空。
prompt.enter.new.directory.name=輸入新目錄名稱\\:
prompt.enter.new.file.name=指定新的檔名\\:
prompt.enter.new.library.name=輸入新庫名稱
prompt.enter.new.module.name=輸入新模組名稱
prompt.enter.new.name=輸入新名稱
prompt.enter.new.package.name=輸入新的軟體套件名稱\\:
prompt.filechooser.enter.file.name=輸入檔名\\:
prompt.goto.inspection.enter.name=輸入檢查名稱\\:
prompt.gotoaction.enter.action=輸入動作或選項名稱\\:
prompt.gotoclass.enter.class.name=輸入 {0} 名稱\\:
prompt.gotofile.enter.file.name=輸入檔名\\:
prompt.gotosymbol.enter.symbol.name=輸入符號名稱\\:
prompt.input.favorites.list.new.name=將收藏夾列表 ''{0}'' 重命名為\\:
prompt.input.new.favorites.list.name=輸入新收藏夾列表的名稱
prompt.open.project.or.attach=<html><body>可以在新視窗中開啟專案，取代當前視窗中的專案，或者將專案附加到已經開啟的專案。<br>您想如何開啟專案?</body></html>
prompt.open.project.or.attach.button.attach=附加(&A)…
prompt.open.project.or.attach.button.new.window=新視窗 (&W)
prompt.open.project.or.attach.button.this.window=此視窗(&T)
prompt.open.project.or.attach.title=開啟專案
prompt.proxy.authentication=代理身份驗證
prompt.reset.to.original.template=重設為原始模板?
prompt.server.authentication=伺服器身份驗證
prompt.specify.module.group.name=指定{0}將顯示在其下方的組名稱。\\n\\n
prompt.specify.name.of.module.subgroup=指定{1}將顯示在其下方的{0}子組的名稱\\n\\n
prompt.uninstall.plugin=確定要移除延伸模組 ''{0}''{1, choice, 0\\#|1\\# 更新}嗎?
prompt.uninstall.several.plugins=確定要移除這 {0} 個延伸模組嗎?
quick.lists.description=<html>快速列表允許您定義常用的動作組 (例如，重構或 VCS 動作)，並將鍵盤快捷鍵分配給此類別組。</html>
quick.lists.not.empty.name=快速列表應具有非空名稱
quick.lists.presentable.name=快速列表
quickfix.text.insert.0=插入 {0}
radio.button.open.matching.files.in.associated.application=在關聯的應用程式中開啟符合檔案
radio.button.unlock.all=全部解鎖
radio.button.unlock.dir=目錄解鎖
radio.button.unlock.one=解鎖一個
radio.button.using.file.system=使用檔案系統(&F)
radio.button.using.version.control.integration=使用版本控制整合(&V)
radio.process.close.ask=詢問
radio.process.close.disconnect=斷開連線
radio.process.close.terminate=終止程序
recent.files.accessible.file.list=檔案
recent.files.accessible.open.recently.edited.locations=開啟最近編輯的位置
recent.files.accessible.open.recently.viewed.locations=開啟最近的位置
recent.files.accessible.show.tool.window=啟用工具視窗\\: {0}
recent.files.accessible.tool.window.list=工具視窗
recent.files.checkbox.label=僅顯示已編輯的內容
recent.files.file.list.empty.text=無最近檔案
recent.files.file.list.loading.empty.text=正在提取最近的檔案…
recent.files.speed.search.empty.text=按 'Enter' 在專案中搜尋
recent.files.tool.window.list.empty.text=無工具視窗
recent.locations.changed.locations=最近編輯的位置
recent.locations.popup.empty.file.text=空行
recent.locations.popup.empty.text=未找到最近的位置
recent.locations.popup.title=最近的位置
recent.locations.title.text=僅顯示已編輯的內容
recent.project.unavailable=(不可用)
recovery.progress.title=正在嘗試{0}…
redo.command=重做{0}
redo.dialog.title=重做
registry.change.warning=更改這些值可能導致 {0} 的異常行為。除非要求，否則請不要更改這些值。
registry.close.action.text=關閉
registry.key.requires.ide.restart.note=需要重啟 IDE
registry.restore.defaults.action.text=恢復預設設定
reload.or.convert.dialog.title={0}\\: 重新載入或轉換為 {1}
remove.byte.order.mark.from=從 {0} 中移除位元組順序標記
removing.BOM=正在移除 BOM
rename.0=重新命名 {0}
reportProblemAction.progress.title.submitting=正在提交…
reportProblemAction.upload.logs.message=點擊“是”，即表示您同意發送 {0} 的日誌，以便於與 JetBrains 技術支援團隊進行溝通。日誌可能包含私有資訊，例如系統資訊和有關在 IDE 中開啟的專案的資訊。如果無法自動上傳日誌，您仍然能夠以附件形式發送單獨的、可編輯日誌。如果您不發送日誌，我們可能無法幫助您解決問題。
reportProblemAction.upload.logs.title=是否將日誌發送到 JetBrains?
repository.url.title=儲存庫 URL
required.plugin.at.least.versions=，版本至少為 ''{0}''
required.plugin.at.most.versions=，版本最高為 ''{0}''
required.plugin.between.versions=，''{0}'' 和 ''{1}'' 之間的版本
required.plugin.exact.version=，版本 ''{0}''
reset.action.text=重設
reveal.unsupported.message=無法在檔案管理器中開啟 ''{0}''\\: 此平台不支持該動作。
rubber.duck.debugger.popup.title=小黃鴨偵錯器
run.anything.accessible.name=執行任何內容
run.anything.action.tooltip.text=執行指令\\: 開啟專案，啟動執行組態，執行 Gradle 或 Maven 任務，執行終端指令等。
run.anything.actions.undefined=未定義
run.anything.ad.command.delete={0} 刪除最近的指令
run.anything.ad.run.action.with.default.settings=按 {0} 使用預設設定執行
run.anything.ad.run.in.context=按 {0} 在當前檔案上下文中執行
run.anything.ad.run.with.debug={0} 偵錯
run.anything.console.error.title=無法執行指令
run.anything.console.process.finished=\\n程序已結束，離開程式碼為 {0}。
run.anything.context.browse.directory=瀏覽目錄…
run.anything.context.project=專案
run.anything.context.project.undefined=未定義
run.anything.context.separator.directories=目錄
run.anything.context.separator.modules=模組
run.anything.context.title.working.directory=執行上下文
run.anything.context.tooltip=選擇將在其中執行當前指令的上下文
run.anything.custom.activity.notification.group.id=已執行 Run Anything 指令
run.anything.custom.activity.rollback.action=回滾
run.anything.general.group.title=一般
run.anything.help.list.empty.secondary.text=選擇指令
run.anything.hint.initial.text=按 {0} 或 {1} 瀏覽建議列表
run.anything.indexing.mode.not.supported=在索引更新期間，“執行任何內容”不可用
run.anything.main.list.empty.primary.text=執行指令或組態
run.anything.main.list.empty.secondary.text=輸入“?”以檢視所有指令
run.anything.notification.warning.content=指令 ''{0}'' 無法執行。
run.anything.notification.warning.title=指令執行失敗
run.anything.recent.group.title=最近
run.anything.recent.project.command.placeholder=開啟 <專案名稱>
run.anything.recent.project.completion.group.title=最近的專案
run.anything.recent.project.help.group.title=最近的專案
run.anything.run.anything.title=執行任何內容
run.anything.run.configurations.group.title=執行組態
run.anything.run.debug.title=偵錯\\:
run.anything.run.in.context.debug.title=使用偵錯在上下文中執行\\:
run.anything.run.in.context.title=在上下文中執行\\:
run.layout.do.not.show.view.option.message=不顯示
save.as.trusted.certificate=另存為可信憑證
saving.activity.tracker.name=正在儲存
scheme.ide=IDE
scheme.project=專案
scheme.theme.default=主題預設
scope.banner.text=作用域 ''{0}''
scope.chooser.select.scope.text=在此處選擇作用域以檢視或編輯其詳細資訊
scope.class.hierarchy=類別層次結構
scope.current.file=當前檔案
scope.editor.legend.partly.included.label=部分包含
scope.editor.legend.recursively.included.label=遞迴包含
scope.files.in.previous.search.result=之前搜尋結果中的檔案
scope.open.files=開啟檔案
scope.previous.search.results=之前的搜尋結果
scope.recent.files=最近檢視的檔案
scope.recent.modified.files=最近更改的檔案
scope.selected.directories=選定{0,choice,1\\#目錄|2\\#目錄}
scope.selected.files=選定{0,choice,1\\#檔案|2\\#檔案}
scope.selected.files.and.directories=選定{0,choice,1\\#檔案|2\\#檔案}和{1,choice,1\\#目錄|2\\#目錄}
scope.selection=選區
scope.unable.to.save.scope.message=是否要儲存為共享作用域?
scope.unable.to.save.scope.title=無法使用區域作用域
scope.view.empty.link=顯示所有專案檔案
scope.view.empty.text=當前作用域中沒有檔案。
scope.view.title=作用域
scopes.display.name=作用域
scopes.no.scoped=未新增作用域。
scopes.save.dialog.title.local=儲存為區域作用域
scopes.save.dialog.title.shared=儲存為共享作用域
scratches.and.consoles=臨時檔案和主控台
search.everywhere.action.tooltip.description.text=搜尋\\: <ul style\\=''list-style-type\\:none;margin\\:0;padding\\:0;''><li>- {0}</li><li>- 檔案</li><li>- 工具視窗</li><li>- 動作</li><li>- 設定</li></ul>
search.everywhere.action.tooltip.text=搜尋所有位置<br/>按 <b>{0}</b> 存取 <ul style\\=''list-style-type\\:none;margin\\:0;padding\\:0;''><li>- {1}</li><li>- 檔案</li><li>- 工具視窗</li><li>- 動作</li><li>- 設定</li></ul>
search.everywhere.command.plugins=延伸模組\\: {0}
search.everywhere.directory.file.type.name=目錄
search.everywhere.filter.classes.description=轉到類別
search.everywhere.filter.files.description=轉到檔案
search.everywhere.filter.symbols.description=轉到符號
search.everywhere.group.name.actions=動作
search.everywhere.group.name.files=檔案
search.everywhere.group.name.recent.files=最近的檔案
search.everywhere.group.name.symbols=符號
search.everywhere.group.name.top.hit=點擊最多
search.everywhere.group.name.top.hit.client=點擊最多(客戶端)
search.everywhere.points.loading=…正在載入…
search.everywhere.points.more=…更多
search.everywhere.preview.action.description=顯示預覽
search.everywhere.preview.action.text=預覽
search.for.usages.and.delete.elements=搜尋用法並刪除{0}?
searcheverywhere.accessible.name=隨處搜尋
searcheverywhere.all.elements.tab.name=所有
searcheverywhere.autocompletion.tab.name=自動補全
searcheverywhere.commands.tab.name=指令
searcheverywhere.found.matches.title=''{0}'' 在 [{1}] 中的匹配項
searcheverywhere.found.targets.title=未排序的結果
searcheverywhere.history.shortcuts.hint=按 {0} 或 {1} 瀏覽搜尋歷史記錄
searcheverywhere.ide.search.tab.name=IDE
searcheverywhere.indexing.incomplete.results=在 {1} 更新索引期間，''{0}'' 中的搜尋結果可能不完整
searcheverywhere.indexing.mode.not.supported=在 {1} 更新索引期間，無法在 ''{0}'' 中搜尋
searcheverywhere.nothing.found.for.all.anywhere=找不到任何內容
searcheverywhere.nothing.found.for.contributor.anywhere=未找到使用此類別名的 {0}
searcheverywhere.open.in.new.window.shortcuts.hint=按 {0} 在新視窗中開啟檔案
searcheverywhere.open.in.split.shortcuts.hint=按 {0} 在右拆分中開啟檔案
searcheverywhere.project.search.tab.name=專案
searcheverywhere.reset.filters=重設篩選器
searcheverywhere.run.configs.tab.name=執行組態
searcheverywhere.runconfigurations.command.debug.description=在“偵錯”模式下開始執行組態
searcheverywhere.runconfigurations.command.run.description=在“執行”模式下開始執行組態
searcheverywhere.test.dialog.elements.limit=元素限制
searcheverywhere.test.dialog.grouping.interval=分組間隔
searcheverywhere.test.dialog.search.button=搜尋
searcheverywhere.test.dialog.search.field=搜尋文本
searcheverywhere.test.dialog.title=搜尋貢獻者測試
searcheverywhere.textfield.hint=輸入 {0} 以檢視指令
searcheverywhere.to.perform.fulltext.search=以執行全文搜尋
searcheverywhere.try.to.find.in.files=在檔案中尋找
searcheverywhere.try.to.reset.scope=將作用域設定為
searcheverywhere.use.main=使用
searcheverywhere.use.optional=或使用
section.title.fingerprints=指紋
section.title.issued.by=發佈者
section.title.issued.to=發佈物件
section.title.validity.period=有效期
select.in.commander=Commander
select.in.favorites=收藏夾
select.in.file.structure=檔案結構
select.in.packages=軟體套件
select.in.project=專案
select.in.scope=作用域
separator.scheme.stored.in=存儲於 {0}
set.action.editor.and.tools=為編輯器和工具設定
set.action.empty.frame=為空框架設定
setting.value.reload.mode.preview=在內置預覽中重新載入頁面\\:
setting.value.reload.mode.server=在瀏覽器中重新載入頁面\\:
settings.browsers.column.family=系列
settings.browsers.column.name=名稱
settings.browsers.column.path=路徑
settings.browsers.custom.path=自訂路徑
settings.browsers.default.browser=預設瀏覽器\\:
settings.browsers.first.listed=首先列出
settings.browsers.no.web.browsers.configured=未組態 Web 瀏覽器
settings.browsers.reload.behavior=重新載入行為
settings.browsers.show.browser.popup.html=對於 HTML 檔案
settings.browsers.show.browser.popup.in.the.editor=在編輯器中顯示瀏覽器彈出視窗
settings.browsers.show.browser.popup.xml=對於 XML 檔案
settings.browsers.system.default=系統預設值
settings.certificate.accept.non.trusted.certificates.automatically=自動接受非可信憑證(&A)
settings.certificate.accepted.certificates=接受的憑證\\:
settings.certificate.cannot.add.certificate=無法新增憑證
settings.certificate.cannot.add.certificate.for=無法為 {0} 新增憑證
settings.certificate.cannot.remove.certificate=無法移除憑證
settings.certificate.cannot.remove.certificate.for=無法移除 {0} 的憑證
settings.certificate.certificate.already.exists=憑證已存在
settings.certificate.choose.certificate=選擇憑證
settings.certificate.filter.label=憑證檔案
settings.certificate.malformed.x509.server.certificate=X509 伺服器憑證的格式錯誤
settings.certificate.no.certificate.selected=未選擇任何憑證
settings.certificate.no.certificates=無憑證
settings.certificate.not.imported=未匯入
settings.entry.point.newUi.tooltip=新 UI 可用
settings.entry.point.tooltip=IDE 和專案設定
settings.entry.point.update.ide.action=下載 {0} {1}
settings.entry.point.update.plugin.action=更新 {0} 延伸模組…
settings.entry.point.update.plugins.action=更新 {0} 延伸模組…
settings.entry.point.widget.name=IDE 和專案設定
settings.entry.point.with.updates.tooltip=有可用更新。IDE 和專案設定
settings.file.color.column.color=顏色
settings.file.color.column.scope=作用域
settings.file.color.column.shared=通過 VCS 共享
settings.file.color.column.shared.help=<html>共享組態存儲在 <code>.idea</code> 目錄中，<br>其他團隊成員可以通過 VCS 使用。
settings.file.color.custom.name=自訂
settings.file.colors.add.colors.link=新增顏色
settings.file.colors.description=檔案可以屬於多個範圍。如果一個範圍有兩種顏色，則使用列表中第一個範圍的顏色。
settings.file.colors.dialog.choose.color=選擇作用域顏色
settings.file.colors.dialog.warning.append=您是否希望再次新增?
settings.file.colors.dialog.warning.local=已為 {0} 定義區域顏色
settings.file.colors.dialog.warning.replace=<html>是否要將<span style\\="background-color\\:\\#{0};">舊顏色</span>更新為<span style\\="background-color\\:\\#{1};">新顏色</span>?
settings.file.colors.dialog.warning.shared=已為 {0} 定義共享顏色
settings.file.colors.dialog.warning.update=更新
settings.file.colors.enable.file.colors=啟用檔案顏色(&F)
settings.file.colors.manage.scopes=管理作用域(&M)…
settings.file.colors.no.colors.specified=未新增顏色
settings.file.colors.scope.unknown=不存在的作用域
settings.file.colors.use.in.editor.tabs=在編輯器頁籤中使用(&T)
settings.file.colors.use.in.project.view=在專案檢視中使用(&P)
settings.general.autosave=自動儲存
settings.general.directory.preselected=“開啟…” 和 “新增 | 專案…” 對話框中會預先選擇此目錄。
settings.general.synchronization=同步外部更改\\:
settings.menus.group.touch.bar=Touch Bar
settings.modal.opening.message=正在開啟設定
settings.password.internal.error.no.available.credential.store.implementation=內部錯誤，沒有可用的憑證存儲實作。
settings.password.package.libsecret.1.0.is.not.installed=未安裝軟體套件 libsecret-1-0 (要安裝，請使用以下指令\\: sudo apt-get install libsecret-1-0 gnome-keyring)。
settings.password.unknown.provider.type=未知提供程序類型\\: {0}
settings.required.plugins.title=指定專案所需的延伸模組列表。<br>如果缺少必需延伸模組或需要更新，{0} 將通知您。
settings.trusted.certificates=驗證延伸模組時受信任的憑證\\:
share.scope.checkbox.title=通過 VCS 共享
share.scope.context.help=<html>共享組態存儲在 <code>.idea</code> 目錄中，<br>其他團隊成員可以通過 VCS 使用。
shell.env.loading.failed={0} 未能從 ''{1}'' 載入環境。與依賴於環境變數的工具整合可能無法正常進行。
shell.env.loading.learn.more=了解詳情
shortcut.balloon.add.shortcut=新增快捷鍵
shortcut.in.group.text=在 {0} 中
show.details=顯示詳細資訊
show.hidden.tabs=顯示隱藏的頁籤
show.in.find.window.button.description=在“尋找工具”視窗中開啟搜尋結果
show.in.find.window.button.name=在“尋找工具”視窗中開啟
show.in.find.window.button.name.newui=在尋找視窗中開啟結果
show.in.find.window.button.pin.description=在單獨的工具視窗中顯示所有用法
show.main.toolbar=顯示主工具列
show.members.in.navigation.bar=在導覽列中顯示成員
show.navigation.bar=顯示導覽列
show.options.menu=選項
show.status.bar=顯示狀態列
small.labels.in.editor.tabs=編輯器頁籤中的小標籤
speed.search.got.it.link=知道了
speed.search.got.it.text=開始輸入以篩選元素
split.component.missing=拆分組件({0})
split.with.chooser.duplicate.tab=，{0}以複製
split.with.chooser.move.tab=按 {0} 開啟“{1}”
split.with.chooser.switch.tab=使用 {0} 轉到下一個拆分器
ssl.certificate.details=憑證詳細資訊
ssl.certificate.error.expired=憑證已過期
ssl.certificate.error.not.yet.valid=尚未生效的憑證
ssl.certificate.error.self.signed=自簽名憑證
ssl.certificate.error.untrusted.authority=由不受信任的機構簽署的憑證
ssl.certificate.server.action=動作\\:
ssl.certificate.server.address=伺服器地址\\:
ssl.certificate.tree.accessible.name=憑證
ssl.certificate.warning=正在嘗試連線到使用{0}的伺服器。繼續動作可能會危及連線安全。是否將{1}另存為可信憑證並繼續動作?
ssl.certificate.warning.default=正在嘗試連線到不受信任的伺服器。繼續動作可能會危及連線安全。是否將所選憑證儲存為受信任並繼續動作?
ssl.certificate.warning.plural=所選憑證
ssl.certificate.warning.singular=憑證
start.browser.border.label.open.browser=開啟瀏覽器
start.browser.checkbox.start.browser=在啟動後
start.browser.panel.url.label=URL(&U)\\:
start.browser.with.js.debugger=使用 JavaScript 偵錯器(&J)
status.bar.message.at.line=行 {0}\\: {1}
status.bar.text.file.encoding=檔案編碼\\: {0}
status.bar.text.macro.recorded=已記錄\\: {0}
status.bar.text.script.execution.finished=腳本執行已完成
status.bar.widget.non.commercial.usage=非商業用途
status.text.tab.open.in.editor=該頁籤在編輯器區域中開啟
status.text.tab.open.in.editor.jump=轉到編輯器
status.text.tab.open.in.editor.restore=恢復頁籤
structure.view.tree.accessible.name=結構檢視樹
subscription.dialog.activate.button=啟用新的 {0} 訂閱
subscription.dialog.activate.ok.text=啟用 {0}…
subscription.dialog.cancel.button=離開 {0}
subscription.dialog.continue.button=在沒有訂閱的情況下繼續
subscription.dialog.continue.ok.text=繼續並重新啟動…
subscription.dialog.idea=IntelliJ IDEA
subscription.dialog.link={0} 訂閱如何為您提供幫助
subscription.dialog.pro=Pro
subscription.dialog.promise.button=承諾稍後付款
subscription.dialog.promise.ok.text=承諾…
subscription.dialog.pycharm=PyCharm
subscription.dialog.title=訂閱已過期
subscription.dialog.ultimate=旗艦版
support.screen.readers.tab={0} 和 {1} 將在對話框中導覽 UI 控件，並且不能用於切換編輯器頁籤或其他 IDE 動作。滑鼠懸停時的工具提示將被停用。
sys.health.acknowledge.action=不再顯示
sys.health.details=詳細資訊
tab.chooser.project=專案
tab.chooser.search.by.name=按名稱搜尋
tab.filetemplates.code=程式碼
tab.filetemplates.includes=Include
tab.filetemplates.j2ee=其他
tab.filetemplates.templates=檔案
tab.title.editor.and.preview=編輯器和預覽
tab.title.editor.only=編輯器
tab.title.html.preview=HTML 預覽
tab.title.preview.only=預覽
tab.title.stacktrace=<堆疊追蹤>
tab.title.text=文本
tabs.layout.compressible.name=可壓縮單排
tabs.layout.scrollable.single.row.name=可滾動單排
tabs.layout.table.name=表布局
tag.panel.group.options.accessible.name={0}選項
tag.panel.run.options.accessible.name=執行選項
task.browser.label=瀏覽器\\:
task.browser.launch=啟動 Web 瀏覽器
task.browser.url=URL\\:
tech.insights.lab.promoter.action=註冊…
tech.insights.lab.promoter.description=註冊以參加遠端訪談、調查和實用性測試，幫助塑造 JetBrains 產品的未來\\!
tech.insights.lab.promoter.title=加入我們的 JetBrains Tech Insights Lab\\!
temp.dir.env.invalid=環境變數 ''{0}'' 指向不存在的目錄(''{1}'')。有些東西可能工作不正常。
temp.dir.exec.failed=IDE 無法執行臨時目錄 ''{0}'' 中的測試腳本。某些內容可能無法正常工作。
template.copy.N.of.T=複製 {0} 個 {1}
template.file.name=用於生成檔名和路徑的模板
template.file.name.optional=用於生成檔名和路徑的模板(可選)
template.unnamed=未命名
terminal.action.ClearBuffer.text=清除緩衝區
terminal.action.Find.text=尋找
terminal.action.LineDown.text=向下移動一行
terminal.action.LineUp.text=向上滾動一行
terminal.action.MoveLeft.text=左移
terminal.action.MoveRight.text=右移
terminal.action.OpenAsUrl.text=作為 URL 開啟
terminal.action.PageDown.text=向下翻頁
terminal.action.PageUp.text=向上翻頁
terminal.action.SelectNextTab.text=選擇下一個頁籤
terminal.action.SelectPreviousTab.text=選擇上一個頁籤
terminal.action.ShowTabs.text=顯示頁籤
terminal.cursor.shape.block.name=塊
terminal.cursor.shape.underline.name=下劃線
terminal.cursor.shape.vertical.name=垂直線
text.password.hidden=<已隱藏>
text.server.s.certificate.trusted=伺服器的憑證不可信
text.server.s.certificate.trusted.details=伺服器的憑證不可信\\:<br/>{0}
text.todo.no.filters=未組態篩選器
text.todo.no.patterns=未組態模式
text.use.solution.colors.in.main.toolbar=使用不同的工具列顏色一目了然地區分專案。
this.directory.does.not.belong.to.the.project={0, choice, 1\\#這一目錄|2\\#這些目錄}不屬於專案\\:
this.file.does.not.belong.to.the.project={0, choice, 1\\#這一檔案|2\\#這些檔案}不屬於專案\\:
thread.dump.is.taken=執行緒傾印已被<a href\\="{0}">佔用</a>。
tip.of.the.day.feedback.dislike=不喜歡
tip.of.the.day.feedback.like=喜歡
tip.of.the.day.feedback.question=您覺得這個小技巧是否有用?
tip.of.the.day.progress.title=顯示每日小技巧
title.accessibility=無障礙功能
title.add.new.favorites.list=新增新收藏夾列表
title.add.todo.filter=新增篩選器
title.add.todo.pattern=新增模式
title.appearance=外觀
title.browse.icon=瀏覽圖示
title.cannot.convert.project=無法轉換專案
title.cannot.create.class=無法建立類別
title.cannot.create.file=無法建立檔案
title.cannot.load.project=無法載入專案
title.cannot.open.file=無法開啟檔案
title.cannot.open.project=無法開啟專案
title.cannot.save.current.template=無法儲存當前模板
title.choose.action.icon=選擇動作圖示
title.choose.destination.directory=選擇目標目錄
title.common=通用
title.customizations=選單與工具列
title.delete=刪除
title.edit.file.template=編輯檔案模板
title.edit.macros=編輯巨集
title.edit.todo.filter=編輯篩選器
title.edit.todo.pattern=編輯模式
title.enter.macro.name=輸入巨集名稱
title.error.reading.file=讀取檔案時出錯
title.error.writing.file=寫入檔案時錯誤
title.export.preview=匯出預覽
title.file.already.exists=檔案已存在
title.file.templates=檔案和程式碼模板
title.general=系統設定
title.hierarchy.callees.of={0} 的被呼叫方
title.hierarchy.callers.of={0} 的呼叫方
title.hierarchy.class=類別{0}
title.hierarchy.method=方法 {0}
title.hierarchy.subtypes={0}的子類型
title.hierarchy.supertypes={0}的父類型
title.language.and.region=語言和區域
title.load.file.from.share=正在從網絡載入檔案
title.load.project.from.share=正在從網絡載入專案
title.macro.name.already.used=巨集名稱已被使用
title.module.file.does.not.exist=模組檔案不存在\\: {0}
title.module.group=模組組
title.module.sub.group=模組子組
title.new.directory=新增目錄
title.new.file=新增檔案
title.new.from.template=新增 {0}
title.new.package=新增軟體套件
title.no.element.selected=未選擇任何元素
title.open.file.or.project=開啟檔案或專案
title.open.project=開啟專案
title.package.not.found=找不到軟體套件
title.plugin.error=延伸模組錯誤
title.plugin.installation=延伸模組安裝
title.plugin.uninstall=是否移除延伸模組{0, choice, 0\\#|1\\#更新}?
title.plugins=延伸模組
title.popup.new.element=新增
title.popup.new.element.same.place=在此目錄中新增
title.popup.recent.files=最近的檔案
title.popup.select.target=選擇位置\\:
title.project=專案
title.region.africa=非洲
title.region.america=美洲
title.region.asia=亞洲(中國大陸除外)
title.region.china=中國大陸
title.region.europe=歐洲
title.region.middle_east=中東
title.region.not_set=未指定
title.region.oceania=大洋洲
title.rename.favorites.list=重新命名
title.rename.library=重新命名庫
title.rename.macro=重新命名巨集
title.rename.module=重新命名模組
title.reset.template=重設模板
title.restart.needed=需要重啟
title.search.results=搜尋結果
title.select.path.to.browser=選擇瀏覽器的路徑
title.select.project.file.directory=選擇{0}檔案目錄
title.select.template=選擇模板
title.smooth.scrolling.options=平滑滾動選項
title.tip.of.the.day=每日小技巧
title.todo=TODO
title.todo.current.file=當前檔案
title.unable.to.add.favorites.list=無法新增收藏夾列表
title.use.rest.api=使用 REST API
title.velocity.error=Velocity 錯誤
title.warning=警告
to.create.new.file.tooltip=要建立新檔案，請按 <b>{0}</b>。或者右擊任何目錄並選擇<b>新增 | \\\\&lt;file type\\\\&gt;</b>
todo.panel.preview.source.action.text=預覽源
toggle.editor.and.tools=編輯器和工具
toggle.empty.frame=空框架
too.large.download.size=通過塊映射下載歸檔需要太多塊，因此將下載整個歸檔
toolbox.updates.download.ready.action.description=Toolbox App 已安裝 {2} {1} ({0})。是否重啟到新版本?
toolbox.updates.download.ready.action.text=切換到 {2} {1} ({0})…
toolbox.updates.download.update.action.description=Toolbox App 將下載 {2} {1} ({0}) 並通知您更新切換就緒的時間
toolbox.updates.download.update.action.text=下載 {2} {1} ({0})
tooltip.autosave.mode=自動儲存模式
tooltip.close.notification=關閉。按 {0} 並點擊以關閉所有通知
tooltip.close.tab=關閉頁籤
tooltip.eap.plugin.version=EAP 版本不保證延伸模組的穩定性\\n和可用性。
tooltip.event.log.show.balloon=顯示氣球
tooltip.flip.horizontally=水平翻轉
tooltip.flip.vertically=垂直翻轉
tooltip.from.deployment.configuration=來自部署組態\\:
tooltip.hide=隱藏
tooltip.inherited.editor.color.scheme=編輯器 | 配色方案 | {0}<br>{1}
tooltip.license.not.required.for.eap.version=EAP 版本不需要授權
tooltip.line.separator=行分隔符\\: {0}
tooltip.macro.is.being.recorded.now=正在錄製巨集
tooltip.module.group=模組組
tooltip.paid.plugin=安裝後啟用延伸模組授權或使用 30 天試用。
tooltip.recent.search=最近搜尋
tooltip.search.history=搜尋歷史記錄
tooltip.search.history.hotkey=搜尋歷史記錄 {0}
tooltip.shared.folders.from.vagrantfile=來自 Vagrantfile 的共享目錄\\:
tooltip.text.add.shortcut.with.special.keys=使用 {0} 鍵設定快捷鍵
tooltip.text.password.will.be.stored.between.application.sessions=密碼將存儲在應用程式會話之間
tooltip.text.update.is.in.progress.click.to.cancel=正在更新。點擊以取消
tooltip.turn.notification.off=關閉或更改行為
tooltip.ui.designer.form=UI 設計器表單
tooltip.ultimate.plugin=升級到 {0} 以使用此延伸模組
toolwindow.header.accessible.name=工具視窗標題
toolwindow.palette=調色板
toolwindow.stripe.Bookmarks=書籤
toolwindow.stripe.Commit=提交
toolwindow.stripe.Favorites=收藏夾
toolwindow.stripe.Notifications=通知
toolwindow.stripe.Problems=自動建置
toolwindow.stripe.ProblemsView=問題
toolwindow.stripe.Problems_View=問題
toolwindow.stripe.Profiler=分析器
toolwindow.stripe.Project=專案
toolwindow.stripe.Statistics_Event_Log=統計事件
toolwindow.stripe.Structure=結構
toolwindow.stripe.TODO=TODO
toolwindow.stripe.Version_Control=版本控制
toolwindow.stripe.documentation.v2=文檔
toolwindow.stripe.documentation.v2.shortName=文檔
transfer-settings.keymap.custom-shortcuts=僅自訂快捷鍵
transfer-settings.keymap.extension-custom-shortcuts=<html>來自 {0} 的某些擴展程序可能新增了自訂快捷鍵。這些快捷鍵也顯示在此列表中</html>
transfer-settings.keymap.more=更多…
transfer-settings.plugins.more=和另外 {0} 個
transfer-settings.sections.more=更多…
transfer-settings.vs-win.resharper-settings-found=ReSharper 設定已找到並將被匯入
transfersettings.button.retry.import=重試匯入
transfersettings.label.debug=偵錯
transfersettings.label.failed.to.import.settings.from=無法從 {0} {1} 匯入設定
transfersettings.label.find.usages=尋找用法
transfersettings.label.go.to.declaration=轉到宣告
transfersettings.label.please.try.again=請重試
transfersettings.label.run=執行
transfersettings.label.search.everywhere=隨處搜尋
transfersettings.plugin.built.in=內建
transfersettings.plugin.plugin=延伸模組
transfersettings.product.visual.studio=Visual Studio
transfersettings.product.visual.studio.for.mac=Visual Studio for Mac
transfersettings.product.vscode=VSCode
transfersettings.projects.and.n.more=和其他 {0} 個
transfersettings.task.progress.details.complete=已成功匯入
transfersettings.task.progress.details.finishing.up=正在完成…
transfersettings.task.progress.details.starting.up=正在啟動…
transfersettings.task.progress.title.importing.settings=正在匯入設定
transfersettings.vs.failureReason=如果 Visual Studio 處於開啟狀態或其檔案被另一個程序存取，則會發生這種情況。{0}
transfersettings.vs.noSettings=如果未正確移除 Visual Studio、其設定損壞或從未啟動，則會發生這種情況。
transfersettings.vs.quit.advise=離開 Visual Studio 和所有使用 Visual Studio 工具的程序。之後等待大約 30 秒。
treenode.loading=正在載入…
trial.expired=試用已過期。
trial.survey.another.reason=我的理由未在此處列出
trial.survey.check.for.daily=我正在評估它對我的日常任務是否有用
trial.survey.check.new.features=我正在評估最新版本中引入的新功能
trial.survey.learn=我想學習如何使用特定功能、語言或框架
trial.survey.no.goal=我沒有具體目標
trial.survey.waiting.license=我正在等待雇主的許可
trust.certificate.warning.details=信任此憑證可能會使您的資料面臨安全威脅。只有在您信任來源並了解相關風險的情況下，才可以繼續動作。
trust.certificate.warning.details.action=如何管理憑證
trust.certificate.warning.details.popup=<html>您可以稍後在“設定 | 工具 | 伺服器憑證”中停用已接受的憑證。已接受的憑證將以預設密碼 <i>{1}</i> 儲存在 <i>{0}</i> 信任庫中。</html>
trusted.folders.settings.label=位於這些本地目錄下的專案將被視為受信任的專案
trusted.hosts.settings.new.trusted.folder.dialog.title=新增受信任的位置
trusted.hosts.settings.new.trusted.folder.file.chooser.title=選擇受信任的位置
ui.button.off=關閉
ui.button.on=開啟
ui.customization.select.auto.popup.by.chars.text=通過按空格、點或其他上下文相關鍵插入選定建議
undo.command=撤消{0}
undo.command.local.name=本地
undo.conflicting.change.confirmation=受此動作影響的其他檔案已更改。
undo.dialog.title=撤消
uninstall.packages.failed=無法移除軟體套件。<a href\\="xxx">詳細資訊…</a>
uninstall.packages.failed.dialog.title=移除軟體套件失敗
unknown.error=未知錯誤
unscramble.dialog.title=分析堆疊追蹤
unsupported.windows=不再支援此版本的 Windows。某些功能可能無法正常工作。請使用 Windows 10 1809 或更高版本。
untrusted.jps.project.not.loaded.notification=對於在安全模式下開啟的專案，不載入組態檔案。如果您信任該專案，請相應地對其進行標記，然後重新開啟以避免此限制。
untrusted.project.dialog.distrust.button=繼續使用安全模式
untrusted.project.dialog.text=如果您不信任此源，請繼續使用安全模式。\\n\\n載入、執行或建置 {0} {1,choice,1\\#專案|1<專案}可能會執行其建置腳本中的潛在惡意程式碼。
untrusted.project.dialog.title=信任 {0} {1,choice,1\\#專案|1<專案}?
untrusted.project.dialog.trust.button=信任專案
untrusted.project.dialog.trust.folder.button=信任 ''{0}'' 目錄
untrusted.project.general.dialog.title=信任專案?
untrusted.project.link.dialog.cancel.button=不鏈接
untrusted.project.link.dialog.title=是否信任並鏈接 {0} 專案 ''{1}''?
untrusted.project.location.comment=這將提高 IDE 性能。您必須具有管理員權限才能使用。
untrusted.project.notification.description=安全模式，功能受限。信任該專案以存取完整的 IDE 功能。
untrusted.project.notification.read.more.link=閱讀更多資訊
untrusted.project.notification.trust.link=信任專案…
untrusted.project.open.dialog.cancel.button=不開啟
untrusted.project.open.dialog.distrust.button=在安全模式下預覽
untrusted.project.open.dialog.text={0} 提供的功能可能會從此目錄執行潛在惡意程式碼。如果不信任此源，請在安全模式下預覽專案，以便僅瀏覽其程式碼。
untrusted.project.open.dialog.title=信任並開啟專案 ''{0}''?
untrusted.project.warning.trust.location.checkbox=<html>信任 <b>''{0}''</b> 目錄中的所有專案
untrusted.project.windows.defender.trust.location.checkbox=<html>將 <b>IDE</b> 和 <b>''{0}''</b> 目錄新增到 Microsoft Defender 排除列表
update.apply.manually.message=抱歉，IDE 無法在您的系統上執行自動更新。\\n請離開 IDE 並通過啟動此腳本手動套用補丁\\:\\n{0}。
update.channel.enforced=更新通道已切換為 ''{0}''
update.downloading.patch.error=無法準備更新\\:<br>{0}
update.downloading.patch.open=開啟下載頁面
update.downloading.patch.progress=正在下載補丁檔案
update.downloading.plugins.progress=正在下載延伸模組更新
update.installed.notification.title=已安裝延伸模組更新
update.no.update.hosts=沒有組態延伸模組儲存庫
update.preparing=正在準備 IDE 更新
update.preparing.patch.progress=正在準備補丁檔案
update.ready.message=IDE 已準備好更新
update.ready.restart=重新啟動
update.snap.blog.post.action=網誌
update.snap.message=IDE 已通過 Snap 更新。
update.whats.new={0} 最新變化
updates.all.plugins.action={0,choice,1\\#更新|2\\#全部更新}
updates.apply.manually.button=手動更新(&D)
updates.auto.update.title=啟用自動更新
updates.channel.bundled.key=新版本有一個到期日期，不需要授權密鑰。
updates.checking.platform=正在檢查 IDE 更新
updates.checking.plugins=正在檢查延伸模組更新
updates.checking.progress=正在檢查更新
updates.configure.label=<b><a href\\="updates">組態</a></b>自動更新。
updates.configure.updates.label=組態更新…
updates.dialog.title={0} 和延伸模組更新
updates.download.and.restart.button=更新並重啟(&D)
updates.download.button=下載(&L)
updates.error.connection.failed=連線失敗({0})。請檢查您的網絡連線並重試。
updates.error.connection.title=連線錯誤
updates.external.error.message=無法檢查 {0} 的更新\\: {1}
updates.external.progress=正在提取外部組件的可用更新
updates.external.ready.message={0,choice,1\\#組件|2\\#組件}\\: {1}
updates.fallback.build=您有新版本的永久回退授權。
updates.from.to=將 {0} 更新到 {1} ({2})。
updates.from.to.size=正在將 {0} 更新到 {1} ({2})。補丁大小為 {3} MB。
updates.ignore.update.button=忽略這個更新(&I)
updates.ignore.updates.button=忽略{0,choice,1\\#此更新|2\\#這些更新}(&I)
updates.ignore.updates.link=忽略{0,choice,1\\#此更新|2\\#這些更新}
updates.incompatible.plugins.found=新版本中的\\: {0,choice,1\\#'' ''|2\\#'<br/>'} {1} 與 {0,choice,1\\#延伸模組|2\\#延伸模組} 不相容
updates.interim.build=您可以使用新版本，直到您的訂閱於 {0} 到期。
updates.last.check.never=從不
updates.new.build.notification.title={0}{1}可用
updates.new.version.available=<b>有新版本的 {0} <a href\\="{1}">可用</a>\\!</b>
updates.no.updates.message=您已安裝最新版本的 {0} 和延伸模組。
updates.no.updates.notification=沒有可用的 IDE 或延伸模組更新
updates.no.updates.snap.message=<html>所有延伸模組都處於最新狀態。<br> {0} 更新由 Snap 管理。<br>執行 ''snap refresh'' 指令以檢查更新。</html>
updates.no.updates.toolbox.message=<html>所有延伸模組都是最新的。<br> {0} 更新由 Toolbox App 管理。<br>啟動它以檢查是否有可用更新。</html>
updates.no.updates.unknown.message=<html>所有延伸模組都是最新的。<br> {0} 更新由 {1} 管理。</html>
updates.notification.title={0} 和延伸模組更新
updates.notification.update.action=更新…
updates.paid.upgrade=您可以評估新版本 {0} 天，或者在線購買。
updates.plugin.ready.title=有可用的 {0} 延伸模組更新
updates.plugin.ready.tooltip={0} 個{1,choice,1\\#延伸模組|2\\#延伸模組}{1,choice,1\\#更新|2\\#更新}可用
updates.plugins.autoupdate.notification.do.not.ask.display=啟用延伸模組自動更新
updates.plugins.autoupdate.notification.message=是否啟用延伸模組自動更新以始終擁有其最新版本?
updates.plugins.autoupdate.se.option=自動更新延伸模組
updates.plugins.autoupdate.settings.action=自動更新延伸模組
updates.plugins.autoupdate.settings.checkbox=自動更新延伸模組
updates.plugins.autoupdate.settings.comment=更新將在背景下載並在重啟後自動套用
updates.plugins.autoupdate.settings.prohibited.by.policy.comment=公司政策禁止延伸模組自動更新
updates.plugins.dialog.action=詳細資訊…
updates.plugins.error.message1=無法從預設儲存庫載入延伸模組\\: {0}
updates.plugins.error.message2=無法從 ''{0}'' 載入延伸模組\\: {1}
updates.plugins.notification.title=延伸模組已更新
updates.plugins.ready.title=有可用的延伸模組更新
updates.plugins.settings.checkbox=檢查延伸模組更新
updates.remind.later.button=稍後提醒我(&R)
updates.settings.channel.locked=EAP 版本只能通過 EAP 通道更新
updates.settings.check.now.button=檢查更新(&C)…
updates.settings.checkbox=檢查 IDE 更新
updates.settings.checkbox.for=為之檢查 IDE 更新\\:
updates.settings.current.version=當前版本\\:
updates.settings.external=IDE 更新由 {0} 在外部管理
updates.settings.ignored=管理忽略的更新…
updates.settings.ignored.title=忽略的更新
updates.settings.last.check=上次檢查\\: {0}
updates.settings.recommend.toolbox=我們推薦 <a href\\=''{0}''>{1}</a>
updates.settings.recommend.toolbox.multiline.description=自動獲取更新，一鍵開啟您的專案，<br>了解其他 JetBrains 產品等
updates.settings.show.editor=IDE 更新後在編輯器中顯示新功能
updates.settings.title=更新
updates.write.protected={0} 沒有 {1} 的寫入權限。請通過特權使用者執行以更新。
upgrade.package.failed.title=升級軟體套件失敗。
upgrade.packages.failed=無法升級軟體套件。<a href\\="xxx">詳細資訊…</a>
upgrade.packages.failed.dialog.title=升級軟體套件失敗
uploading.logs.message=正在上傳日誌…
uses.shortcut.of=繼承自
vagrant.vm.1.choice.0.0.1.at.2.3=Vagrant 虛擬機{1, choice, 0\\#“{0}”|1\\#}，處於 {2} ({3})
vfs.activity.tracker.name=虛擬檔案系統
vm.options.edit.action.cap=編輯自定義虛擬機選項
vm.options.env.vars=檢測到使用了 Java 選項環境變數。此類別變數將覆寫 IDE 組態檔案(*.vmoptions)，並可能導致性能和穩定性問題。請考慮刪除以下變數\\: {0}。
vm.options.file.corrupted=VM 選項檔案 ''{0}'' 已損壞(它包含無效的 ''\\\\0'' 字元)。請移除這些字元或刪除檔案。
warning.create.directory.with.dot=注意\\: 名稱中的 "." 會被視為一般字元。如果要建立嵌套目錄，請改用 "/"
warning.create.directory.with.ignored.name=正在嘗試建立包含忽略名稱(''{0}'')的目錄；結果將不可見
warning.create.package.with.ignored.name=正在嘗試建立包含忽略名稱(''{0}'')的軟體套件；結果將不可見
warning.delete.all.files.and.subdirectories=\\n“{0}”中的所有檔案和子目錄將被刪除。\\n您可能無法完全撤消此動作\\!
warning.delete.all.files.and.subdirectories.in.the.selected.directory=\\n所選目錄中的所有檔案和子目錄將被刪除。\\n您可能無法完全撤消此動作\\!
warning.load.file.from.share=您正在開啟來自網絡共享的檔案。是否要繼續?\\n{0}
warning.load.project.from.share=您正在開啟來自網絡共享的專案。您是否信任此位置?\\n{0}
warning.use.rest.api.0.and.trust.host.1=''{0}'' API 已請求。您信任 ''{1}'' 嗎?
warning.use.rest.api.0.and.trust.host.unknown=已請求 ''{0}'' API。您是否信任未知主機?
warning.use.rest.api.block.unknown.hosts=是否要阻止來自未知主機的請求?
web.preview.file.editor.name={0} 的預覽
web.preview.reload.mode.disabled=已停用
web.preview.reload.mode.on.change=更改時
web.preview.reload.mode.on.save=儲存時
welcome.screen.action.docs.how.tos.action.text=文檔和指南
welcome.screen.all.settings.link=所有設定…
welcome.screen.check.for.updates.comment=更新。
welcome.screen.color.theme.header=外觀
welcome.screen.configure.action.text=組態
welcome.screen.copy.about.action.text=複製有關資訊
welcome.screen.customize.title=自訂
welcome.screen.drop.files.to.open.text=將檔案拖放到此處以開啟
welcome.screen.empty.projects.create.comment=從頭建立新項目。
welcome.screen.empty.projects.open.comment=從磁碟或版本控制中開啟現有專案。
welcome.screen.ide.font.size.label=IDE 字體\\:
welcome.screen.learnIde.help.and.resources.text=幫助和資源
welcome.screen.learnIde.interactive.courses.text=互動課程
welcome.screen.learnIde.title=學習
welcome.screen.logo.version.label=版本 {0}
welcome.screen.more.actions.link.text=更多動作
welcome.screen.plugins.title=延伸模組
welcome.screen.projects.title=專案
welcome.screen.quick.start.action.text=快速開始
welcome.screen.recent.projects.accessible.name=最近的專案
welcome.screen.recent.projects.branch.label.accessible.name=分支 {0}
welcome.screen.recent.projects.name.label.unavailable.accessible.name={0} (不可用)
welcome.screen.search.projects.empty.text=搜尋專案
whats.new.action.custom.description=了解此版本的 {0} 中的新功能
whats.new.action.custom.text={0} 最新變化(_N)
whats.new.notification.action=檢視最新變化
whats.new.notification.text={0} {1} 登場\\!
whats.new.notification.text.regular.language={0} {1} 已推出\\!
whats.new.timeout.action=您可以<a href\\="{0}" class\\="link" target\\="_blank">在瀏覽器中開啟此頁面</a>或稍後重試。
whats.new.timeout.message=無法載入該頁面的內容。請檢查您的互聯網連線。
whats.new.timeout.title=無法載入頁面
window.title.switcher=切換器
window.titleButton.close=關閉
window.titleButton.maximize=最大化
window.titleButton.minimize=最小化
window.titleButton.restore=還原
windows.10.light.theme.name=Windows 10 淺色
windows.native.common.dialog.all=所有檔案
windows.native.common.dialog.open=開啟
windows.native.common.dialog.select.folder=選擇目錄
wrong.http.range.response=HTTP 範圍響應的行過長 {0}
wrong.number.of.arguments.usage.ide.executable.exit=實參數量錯誤。用法\\: <ide executable> exit [--restart]
wrong.number.of.arguments.usage.ide.executable.save=實參數量錯誤。用法\\: <ide 可執行檔案> 儲存
wsl.cant.parse.ip.no.output=無法解析 {0}，因為輸出未包含足夠的資料。請參閱 idea.log 了解特定錯誤。
wsl.cant.parse.ip.process.failed=由於程序失敗，無法解析 {0}。請參閱 idea.log 了解特定錯誤。
wsl.enter.root.password.dialog.title=輸入根密碼
wsl.error.host.ip.not.obtained.message=無法獲取 WSL 發行版的主機 IP\\: {0}
wsl.executing.process=正在執行 WSL 程序
wsl.linux.distribution.label=Linux 發行版(&D)\\:
wsl.no.distribution.found.error=WSL\\: 應設定 Linux 發行版
wsl.no.installed.distributions=沒有安裝發行版
wsl.no.rsync=請在您的 {0} WSL 上安裝 rsync
wsl.no_path=找不到此發行版特定於 Windows 的部分，無法瀏覽
wsl.not.installed.dialog.message=在 %PATH% 中找不到 wsl.exe，請安裝 WSL
wsl.not.installed.distribution=未安裝 {0}
wsl.rsync.unable.to.copy.files.dialog.message=無法將檔案複製到 {0}
wsl.rsync.unable.to.create.target.dir.message=無法建立目標目錄 {0}
wsl.sudo.password.for.root.label={0} 根的 Sudo 密碼\\:
wsl.target.introspection.step.command.finished.with.exit.code=程序已結束，離開程式碼為 {0}
wsl.target.introspection.step.completed.successfully=內省成功完成\\!
wsl.target.introspection.step.completed.with.errors=內省完成但有錯誤。
wsl.target.introspection.step.description=WSL 發行版內省
wsl.target.language.step.description=用於 {1} 的 {0} 執行時組態
wsl.target.tool.step.description=WSL 組態
wsl.win.ip=主機(Windows) IP
wsl.wsl.ip=WSL (Linux) IP
x.and.y={0} 和 {1}
xnext.comment.unavailable=啟用 XNext 時，此設定不可用
"
`;

exports[`src messages/InspectionGadgetsBundle.properties 1`] = `
"0.will.no.longer.be.overridable.by.1={0} 將不再可被 {1} 覆寫
absolute.alignment.in.user.interface.display.name=AWT/Swing 程式碼中的絕對對齊
absolute.alignment.in.user.interface.fix.family.name=取代為常數
absolute.alignment.in.user.interface.problem.descriptor=使用了絕對對齊常數 <code>{0}.\\#ref</code> \\#loc
abstract.class.extends.concrete.class.display.name=抽象類別擴展具體類別
abstract.class.extends.concrete.class.problem.descriptor=類別 <code>\\#ref</code> 被宣告為 'abstract'，並擴展一個具體類別 \\#loc
abstract.class.naming.convention.element.description=抽象類別
abstract.class.never.implemented.display.name=沒有具體子類別的抽象類別
abstract.class.never.implemented.problem.descriptor=抽象類別 <code>\\#ref</code> 沒有具體子類別 \\#loc
abstract.class.with.only.one.direct.inheritor.display.name=只有一個直接繼承者的抽象類別
abstract.class.with.only.one.direct.inheritor.problem.descriptor=只有一個直接繼承者的抽象類別 <code>\\#ref</code> \\#loc
abstract.class.without.abstract.methods.display.name=沒有 'abstract' 方法的抽象類別
abstract.class.without.abstract.methods.ignore.utility.class.option=忽略實用程序類別
abstract.class.without.abstract.methods.problem.descriptor=類別 <code>\\#ref</code> 被宣告為 'abstract'，並且沒有 'abstract' 方法 \\#loc
abstract.method.call.in.constructor.display.name=物件建構期間呼叫的 abstract 方法
abstract.method.call.in.constructor.problem.descriptor=物件建構期間呼叫 'abstract' 方法 <code>\\#ref()</code> \\#loc
abstract.method.overrides.abstract.method.display.name=abstract 方法覆寫 abstract 方法
abstract.method.overrides.abstract.method.ignore.different.javadoc.option=忽略 Javadoc 與其 super 方法不同的方法
abstract.method.overrides.abstract.method.problem.descriptor=abstract 方法 <code>\\#ref()</code> 覆寫 abstract 方法 \\#loc
abstract.method.overrides.abstract.method.remove.quickfix=移除冗餘 abstract 方法宣告
abstract.method.overrides.concrete.method.display.name=abstract 方法覆寫具體方法
abstract.method.overrides.concrete.method.problem.descriptor=abstract 方法 <code>\\#ref()</code> 覆寫具體方法 \\#loc
abstract.method.with.missing.implementations.display.name=缺少實作的 abstract 方法
abstract.method.with.missing.implementations.problem.descriptor=abstract 方法 <code>\\#ref()</code> 未在每個子類別中實作 \\#loc
access.to.non.thread.safe.static.field.from.instance.class.chooser.title=選擇非執行緒安全類別
access.to.non.thread.safe.static.field.from.instance.display.name=非執行緒安全的 'static' 欄位存取
access.to.non.thread.safe.static.field.from.instance.field.problem.descriptor=存取類型為 ''{0}'' 的非執行緒安全 static 欄位 <code>\\#ref</code> \\#loc
access.to.non.thread.safe.static.field.from.instance.option.title=非執行緒安全類別\\:
access.to.static.field.locked.on.instance.display.name=存取實例資料上鎖定的 'static' 欄位
access.to.static.field.locked.on.instance.fix.name=忽略類型 ''{0}'' 的 static 欄位
access.to.static.field.locked.on.instance.problem.descriptor=存取實例資料上鎖定的 static 欄位 <code>\\#ref</code> \\#loc
accessing.non.public.field.of.another.object.display.name=存取另一個物件的非 public 欄位
accessing.non.public.field.of.another.object.problem.descriptor=直接存取另一個物件的非 public 欄位 <code>\\#ref</code> \\#loc
add.0.to.ignore.if.annotated.by.list.quickfix=將 ''{0}'' 新增到“由以下物件註解時忽略”列表中
add.catch.section.fix.family.name=新增 'catch' 子句
add.read.write.object.methods.fix.family.name=新增始終拋出異常的 'readObject()' 和 'writeObject()' 方法
add.read.write.object.methods.fix.text=新增始終拋出異常的 'writeObject()' 方法
add.read.write.object.methods.fix.text2=新增始終拋出異常的 'readObject()' 方法
add.serialversionuidfield.quickfix=新增 'serialVersionUID' 欄位
add.this.qualifier.quickfix=新增 'this' 限定符
add.throws.clause.fix.family.name=修復 'throws' 子句
all.levels.option=所有日誌級別
allow.resource.to.be.opened.inside.a.try.block=允許在 'try' 塊內開啟資源
ambiguous.field.access.display.name=對繼承欄位的存取類似於對周圍程式碼中元素的存取
ambiguous.field.access.hides.field.problem.descriptor=存取超類別 ''{0}'' 中的 <code>\\#ref</code> 欄位類似於存取周圍類別中的欄位 \\#loc
ambiguous.field.access.hides.local.variable.problem.descriptor=存取超類別 ''{0}'' 中的 <code>\\#ref</code> 欄位類似於存取區域變數 \\#loc
ambiguous.field.access.hides.parameter.problem.descriptor=存取超類別 ''{0}'' 中的 <code>\\#ref</code> 欄位類似於存取參數 \\#loc
ambiguous.field.access.navigate.quickfix=導覽到明顯存取過的{0, choice, 1\\#區域變數|2\\#參數|3\\#欄位}
ambiguous.field.access.quickfix=將 'super' 限定符新增到欄位存取
ambiguous.method.call.display.name=對繼承方法的呼叫類似於對本地方法的呼叫
ambiguous.method.call.problem.descriptor=對來自超類別 ''{0}'' 的方法 <code>\\#ref()</code> 的呼叫類似於對來自類別 ''{1}'' 的方法的呼叫 \\#loc
ambiguous.method.call.quickfix=向方法呼叫中新增 'super' 限定符
annotation.class.display.name=註解接口
annotation.class.problem.descriptor=註解接口 <code>\\#ref</code> \\#loc
annotation.display.name=註解
annotation.naming.convention.element.description=註解接口
annotation.problem.descriptor=註解 <code>\\#ref</code> \\#loc
anonymous.class.field.hides.containing.method.variable.problem.descriptor=匿名類別欄位 <code>\\#ref</code> 隱藏包含方法中的變數 \\#loc
anonymous.class.parameter.hides.containing.method.variable.problem.descriptor=匿名類別參數 <code>\\#ref</code> 隱藏包含方法中的變數 \\#loc
anonymous.class.variable.hides.containing.method.variable.display.name=匿名類別變數隱藏包含方法中的變數
anonymous.class.variable.hides.containing.method.variable.problem.descriptor=匿名類別區域變數 <code>\\#ref</code> 隱藏包含方法中的變數 \\#loc
anonymous.extends.concrete.collection.problem.descriptor=匿名類別顯式擴展 ''{0}'' \\#loc
anonymous.extends.thread.problem.descriptor=匿名類別直接擴展 'java.lang.Thread' \\#loc
anonymous.extends.throwable.problem.descriptor=匿名類別直接擴展 'java.lang.Throwable' \\#loc
anonymous.inner.class.display.name=匿名類別可被取代為內部類別
anonymous.inner.class.problem.descriptor=匿名類別 <code>\\#ref</code> \\#loc
anonymous.inner.class.with.too.many.methods.display.name=具有太多方法的匿名類別
anonymous.inner.class.with.too.many.methods.problem.descriptor=具有太多方法的匿名類別 (方法計數 \\= {0}) \\#loc
anonymous.inner.may.be.named.static.inner.class.display.name=匿名類別可能是命名為 'static' 的內部類別
anonymous.inner.may.be.named.static.inner.class.problem.descriptor=匿名類別 <code>\\#ref</code> 可能是命名為 'static' 的內部類別 \\#loc
anonymous.inner.may.be.named.static.inner.class.quickfix=轉換為命名 'static' 內部類別
any.method.may.close.resource.argument=任何方法都可能關閉作為實參傳遞的資源
array.allocation.zero.length.display.name=零長度陣列分配
array.allocation.zero.length.problem.descriptor=零長度陣列的分配 \\#loc
array.can.be.replaced.with.enum.values=可以將陣列取代為枚舉值
array.can.be.replaced.with.enum.values.family.quickfix=將陣列取代為 EnumType.values()
array.can.be.replaced.with.enum.values.quickfix=將陣列取代為 {0}.values()
array.comparison.display.name=使用 '\\=\\=' 而不是 'Arrays.equals()' 進行陣列比較
array.comparison.problem.descriptor=使用 <code>\\#ref</code> 而不是 'Arrays.equals()' 來比較陣列物件 \\#loc
array.creation.without.new.keyword.family.quickfix=新增 'new' 表達式
array.creation.without.new.keyword.name=建立不帶 'new' 表達式的陣列
array.creation.without.new.keyword.quickfix=新增 ''new {0}''
array.equals.problem.descriptor=或許應當使用 ''{0}'' 完成陣列比較''
array.hash.code.display.name=在陣列上呼叫了 'hashCode()'
array.hash.code.fix.family.name=取代為 'Arrays.hashCode()' 呼叫
array.hash.code.problem.descriptor=陣列上呼叫的 <code>\\#ref()</code> 可能應當是 'Arrays.hashCode()' \\#loc
array.hashcode.problem.descriptor=或許應當使用 ''{0}'' 完成陣列雜湊程式碼計算
array.length.in.loop.condition.display.name=迴圈條件下的 Array.length
array.length.in.loop.condition.problem.descriptor=檢查迴圈條件下的陣列 <code>\\#ref</code> \\#loc
array.objects.equals.display.name=對陣列使用淺層方法或 'Objects' 方法
arrays.as.list.with.one.argument.problem.descriptor=僅使用一個實參呼叫 <code>\\#ref()</code> \\#loc
arrays.as.list.with.zero.arguments.problem.descriptor=呼叫 <code>\\#ref()</code> 以建立空列表 \\#loc
arrays.as.list.with.zero.or.one.argument.display.name='Arrays.asList()' 呼叫的實參過少
assert.can.be.if.quickfix=將 'assert' 取代為 'if' 語句
assert.keyword.is.considered.an.assertion='assert' 關鍵字被視為斷言
assert.message.not.string.display.name='assert' 訊息不是字串
assert.message.not.string.only.warn.boolean.option=僅當 'assert' 訊息為 'boolean' 或 'java.lang.Boolean' 時發出警告
assert.message.of.type.boolean.problem.descriptor=類型為 ''{0}'' 的 ''assert'' 訊息 \\#loc
assert.statement.display.name='assert' 語句
assert.with.side.effects.call.mutates.expression=呼叫 ''{0}()'' 會改變 ''{1}''
assert.with.side.effects.call.mutates.field=呼叫 ''{0}()'' 會改變欄位 ''{1}''
assert.with.side.effects.call.performs.io=呼叫 ''{0}()'' 會執行輸入/輸出動作
assert.with.side.effects.display.name=具有副作用的 'assert' 語句
assert.with.side.effects.problem.descriptor=<code>\\#ref</code> 具有副作用\\: {0} \\#loc
assert.without.message.problem.descriptor=沒有訊息的 <code>\\#ref()</code> \\#loc
assert.without.message.quick.fix.family.name=新增錯誤訊息
assertion.can.be.if.name=斷言可被取代為 'if' 語句
asserts.without.messages.display.name=斷言上缺少訊息
assignment.and.return.of.mutable.record.component={1} 記錄組件的隱式{0, choice, 1\\#賦值|2\\#返回|3\\#賦值和返回} <code>\\#ref</code> \\#loc
assignment.of.field.with.mutable.type.problem.descriptor=賦值給參數 <code>\\#ref</code> 中的 {0} 欄位 ''{1}'' \\#loc
assignment.or.return.of.field.with.mutable.type.display.name=具有可變類型的欄位的賦值或返回
assignment.replaceable.with.operator.assignment.display.name=賦值可被取代為運算符賦值
assignment.replaceable.with.operator.assignment.ignore.conditional.operators.option=忽略條件運算符
assignment.replaceable.with.operator.assignment.ignore.obscure.operators.option=忽略模糊的 ^ 和 % 運算符
assignment.replaceable.with.operator.assignment.problem.descriptor=<code>\\#ref</code> 可以簡化為 ''{0}'' \\#loc
assignment.to.catch.block.parameter.display.name=賦值給 'catch' 塊參數
assignment.to.catch.block.parameter.problem.descriptor=賦值給 'catch' 塊參數 <code>\\#ref</code> \\#loc
assignment.to.for.loop.parameter.check.foreach.option=檢查增強型 'for' 迴圈參數
assignment.to.for.loop.parameter.display.name=賦值給 'for' 迴圈參數
assignment.to.for.loop.parameter.problem.descriptor=賦值給 for 迴圈參數 <code>\\#ref</code> \\#loc
assignment.to.lambda.parameter.display.name=賦值給 lambda 參數
assignment.to.lambda.parameter.problem.descriptor=賦值給 lambda 參數 <code>\\#ref</code> \\#loc
assignment.to.method.parameter.display.name=賦值給方法參數
assignment.to.method.parameter.ignore.transformation.option=<html>如果賦值是原始參數的轉換，則忽略</html>
assignment.to.method.parameter.problem.descriptor=賦值給方法參數 <code>\\#ref</code> \\#loc
assignment.to.null.display.name='null' 賦值
assignment.to.null.option=忽略對欄位的賦值
assignment.to.null.problem.descriptor='null' 已賦值給變數 <code>\\#ref</code> \\#loc
assignment.to.static.field.from.instance.method.display.name=從實例上下文賦值給 static 欄位
assignment.to.static.field.from.instance.method.problem.descriptor=從實例上下文賦值給 static 欄位 <code>\\#ref</code> \\#loc
assignment.to.superclass.field.display.name=建構函式將值賦給在超類別中定義的欄位
assignment.to.superclass.field.problem.descriptor=賦值給在超類別 ''{1}'' 中定義的欄位 ''{0}'' \\#loc
assignment.used.as.condition.display.name=用作條件的賦值
assignment.used.as.condition.problem.descriptor=賦值 <code>\\#ref</code> 作為條件使用 \\#loc
atomic.field.updater.issues.display.name='AtomicFieldUpdater' 宣告不一致
atomic.field.updater.not.static.final.display.name='AtomicFieldUpdater' 欄位未被宣告為 'static final'
atomic.field.updater.not.static.final.problem.descriptor={0} 欄位 <code>\\#ref</code> 未被宣告為 ''static final'' \\#loc
auto.boxing.display.name=自動裝箱
auto.boxing.ignore.added.to.collection.option=忽略新增到集合的表達式
auto.boxing.make.boxing.explicit.quickfix=使裝箱顯式
auto.boxing.problem.descriptor=自動裝箱 <code>\\#ref</code> \\#loc
auto.closeable.resource.display.name=在沒有 'try-with-resources' 的情況下使用 AutoCloseable
auto.closeable.resource.problem.descriptor=在沒有 ''try-with-resources'' 語句的情況下使用 ''{0}'' \\#loc
auto.closeable.resource.quickfix=忽略此方法返回的 'AutoCloseable'
auto.closeable.resource.quickfix.preview=將方法 <code>{0}</code> 新增到忽略方法列表中
auto.closeable.resource.returned.option=忽略從所有方法呼叫返回的 AutoCloseable 實例
auto.unboxing.display.name=自動拆箱
auto.unboxing.make.unboxing.explicit.quickfix=使拆箱顯式
auto.unboxing.problem.descriptor=自動拆箱 <code>\\#ref</code> \\#loc
await.not.in.loop.display.name=未在迴圈中呼叫的 'await()'
await.not.in.loop.problem.descriptor=<code>\\#ref()</code> 呼叫不在迴圈中 \\#loc
await.without.corresponding.signal.display.name=沒有相應 'signal()' 的 'await()'
await.without.corresponding.signal.problem.descriptor=在沒有相應 <code>signal()</code> 或 <code>signalAll()</code> 的情況下呼叫 <code>\\#ref()</code> \\#loc
bad.exception.caught.display.name=已捕獲禁止的 'Exception'
bad.exception.caught.problem.descriptor=已捕獲禁止異常 <code>\\#ref</code> \\#loc
bad.exception.declared.display.name=已宣告禁止異常
bad.exception.declared.problem.descriptor=已宣告禁止異常 <code>\\#ref</code> \\#loc
bad.exception.thrown.display.name=已拋出禁止異常
bad.exception.thrown.problem.descriptor=已拋出禁止異常 ''{0}'' \\#loc
bad.oddness.display.name=可疑的奇數檢查
bad.oddness.problem.descriptor=對負值進行奇數檢查將會失敗 \\#loc
big.decimal.equals.display.name=在 'BigDecimal' 上調用了 'equals()'
big.decimal.equals.problem.descriptor=BigDecimal 值之間的 <code>\\#ref()</code> 可能應當是 'compareTo()' \\#loc
big.decimal.method.without.rounding.called.display.name='BigDecimal' 方法呼叫沒有舍入模式實參
big.decimal.method.without.rounding.called.problem.descriptor=在沒有舍入模式實參的情況下呼叫了 'BigDecimal.\\#ref()'
bigdecimal.legacy.method.display.name=呼叫了 'BigDecimal' 遺留方法
bigdecimal.legacy.method.problem.descriptor=對 'BigDecimal.\\#ref()' 的呼叫可以使用 'RoundingMode' 枚舉常數
bigdecimal.legacy.method.quickfix=使用 'RoundingMode' 枚舉常數
boolean.constructor.display.name=布爾建構函式呼叫
boolean.constructor.problem.descriptor=布爾建構函式呼叫 \\#loc
boolean.constructor.simplify.quickfix=簡化
boolean.expression.can.be.simplified.problem.descriptor=<code>\\#ref</code> 可以簡化為 ''{0}'' \\#loc
boolean.expression.does.not.modify.problem.descriptor=<code>\\#ref</code> 未修改 ''{0}'' 的值 \\#loc
boolean.expression.may.be.conditional.display.name=布爾表達式可被取代為條件表達式
boolean.expression.remove.compound.assignment.quickfix=移除無意義的複合賦值
boolean.field.always.inverted.problem.descriptor=布爾欄位 <code>\\#ref</code> 始終反轉 \\#loc
boolean.method.name.must.start.with.question.display.name=布爾方法名稱必須以疑問詞開頭
boolean.method.name.must.start.with.question.problem.descriptor=布爾方法名稱 <code>\\#ref</code> 未以疑問詞開頭 \\#loc
boolean.method.name.must.start.with.question.table.label=布爾方法名稱前綴\\:
boolean.parameter.constructor.problem.descriptor='public' 建構函式 <code>\\#ref()</code> 具有 'boolean' 參數 \\#loc
boolean.parameter.display.name='public' 方法具有 'boolean' 參數
boolean.parameter.only.report.multiple.option=僅報告具有多個布爾參數的方法
boolean.parameter.problem.descriptor='public' 方法 <code>\\#ref()</code> 具有 'boolean' 參數 \\#loc
boolean.parameters.constructor.problem.descriptor='public' 建構函式 <code>\\#ref()</code> 具有 'boolean' 參數 \\#loc
boolean.parameters.problem.descriptor='public' 方法 <code>\\#ref()</code> 具有 'boolean' 參數 \\#loc
boolean.variable.always.inverted.display.name=布爾變數始終反轉
boolean.variable.always.inverted.problem.descriptor=布爾變數 <code>\\#ref</code> 始終反轉 \\#loc
bounded.wildcard.contravariant.descriptor=可以泛化為 <code>? super \\#ref</code> \\#loc
bounded.wildcard.covariant.descriptor=可以泛化為 <code>? extends \\#ref</code> \\#loc
bounded.wildcard.display.name=可以使用有界萬用字元
bounded.wildcard.report.instance.option=報告實例方法
bounded.wildcard.report.invariant.option=報告固定類別
bounded.wildcard.report.private.option=報告 private 方法
boxing.boxed.value.display.name=裝箱已裝箱的值
boxing.boxed.value.problem.descriptor=裝箱已裝箱的 <code>\\#ref</code> \\#loc
boxing.boxed.value.quickfix=移除不必要的裝箱
break.statement.display.name='break' 語句
break.statement.with.label.display.name=帶標籤的 'break' 語句
break.statement.with.label.problem.descriptor=帶標籤的 <code>\\#ref</code> 語句 \\#loc
busy.wait.display.name=忙等待
busy.wait.problem.descriptor=在迴圈中呼叫 <code>Thread.\\#ref()</code>，可能處於忙等待 \\#loc
c.style.array.declaration.display.name=C 樣式陣列宣告
c.style.array.declaration.replace.quickfix=取代為 Java 樣式陣列宣告
cached.number.constructor.call.display.name=數字建構函式呼叫具有基元實參
cached.number.constructor.call.ignore.string.arguments.option=忽略具有字串實參的新數字表達式
cached.number.constructor.call.problem.descriptor=數字建構函式呼叫具有基元實參 \\#loc
cached.number.constructor.call.report.only.deprecated=僅在建構函式為 @Deprecated 時報告
call.to.date.tostring.display.name=呼叫 'Date.toString()'
call.to.date.tostring.problem.descriptor=國際化上下文中使用的 <code>Date.\\#ref()</code> \\#loc
call.to.native.method.while.locked.display.name=鎖定時呼叫 'native' 方法
call.to.native.method.while.locked.problem.descriptor=在同步上下文中呼叫本地方法 <code>\\#ref()</code> \\#loc
call.to.numeric.tostring.display.name=呼叫 'Number.toString()'
call.to.numeric.tostring.problem.descriptor=國際化上下文中呼叫的 <code>Number.\\#ref()</code> \\#loc
call.to.private.setter.in.class.option=僅在 setter 為 'private' 時報告
call.to.private.simple.getter.in.class.option=僅在 getter 為 'private' 時報告
call.to.simple.getter.in.class.display.name=從類別內呼叫簡單 getter
call.to.simple.getter.in.class.ignore.option=忽略其他物件上的 getter 呼叫
call.to.simple.getter.in.class.inline.quickfix=內聯呼叫 getter
call.to.simple.getter.in.class.problem.descriptor=從類別內呼叫簡單 getter <code>\\#ref()</code> \\#loc
call.to.simple.setter.in.class.display.name=從類別內呼叫簡單 setter
call.to.simple.setter.in.class.ignore.option=忽略其他物件上的 setter 呼叫
call.to.simple.setter.in.class.inline.quickfix=內聯呼叫 setter
call.to.simple.setter.in.class.problem.descriptor=從類別內呼叫簡單 setter <code>\\#ref()</code> \\#loc
call.to.string.concat.can.be.replaced.by.operator.display.name=對 'String.concat()' 的呼叫可被取代為 '+'
call.to.string.concat.can.be.replaced.by.operator.problem.descriptor=對 <code>\\#ref()</code> 的呼叫可被取代為 '+' 表達式 \\#loc
call.to.string.concat.can.be.replaced.by.operator.quickfix=用 '+' 取代 'concat()'
call.to.suspicious.string.method.display.name=呼叫可疑的 'String' 方法
call.to.suspicious.string.method.problem.descriptor=國際化上下文中呼叫的 <code>String.\\#ref()</code> \\#loc
cast.conflicts.with.instanceof.display.name=轉換與 'instanceof' 衝突
cast.conflicts.with.instanceof.problem.descriptor=轉換為 ''{0}'' 類型將與前面的 ''instanceof {1}'' 檢查衝突
cast.conflicts.with.instanceof.quickfix1=在轉換中將 ''{0}'' 取代為 ''{1}''
cast.conflicts.with.instanceof.quickfix2=在 instanceof 中將 ''{0}'' 取代為 ''{1}''
cast.that.loses.precision.display.name=損失精度的數字轉換
cast.that.loses.precision.negative.problem.descriptor=''{0}'' 到 <code>\\#ref</code> 的轉換可能導致負實參的精度損失 \\#loc
cast.that.loses.precision.option=忽略從 int 到 char 的轉換
cast.that.loses.precision.problem.descriptor=''{0}'' 到 <code>\\#ref</code> 的轉換可能導致精度損失 \\#loc
cast.to.concrete.class.problem.descriptor=轉換為具體類別 <code>{0}</code> \\#loc
casting.to.incompatible.interface.display.name=轉換為不相容的類型
casting.to.incompatible.interface.problem.descriptor=將類型為 ''{1}'' 的表達式轉換為不相容的{0, choice, 1\\#接口|2\\#類別} <code>\\#ref</code> \\#loc
caught.exception.immediately.rethrown.display.name=捕獲的異常被立即重新拋出
caught.exception.immediately.rethrown.problem.descriptor=捕獲的異常 <code>\\#ref</code> 被立即重新拋出 \\#loc
chain.of.class.equality.checks.problem.descriptor=類別相等檢查鏈指示抽象失敗 \\#loc
chain.of.instanceof.checks.display.name='instanceof' 檢查鏈
chain.of.instanceof.checks.problem.descriptor='instanceof' 檢查鏈指示抽象失敗 \\#loc
chained.equality.comparisons.display.name=鏈式相等比較
chained.equality.comparisons.problem.descriptor=鏈式相等比較 <code>\\#ref</code> \\#loc
chained.method.call.display.name=鏈式方法呼叫
chained.method.call.ignore.option=忽略欄位初始設定式中的鏈式方法呼叫
chained.method.call.ignore.self.types.option=忽略對返回類型與其封閉類別相同的方法的呼叫
chained.method.call.problem.descriptor=鏈式方法呼叫 <code>\\#ref()</code> \\#loc
change.modifier.fix.family.name=更改修飾符
change.modifier.package.private.quickfix=設為 package-private
change.modifier.quickfix=設為 ''{0}''
channel.opened.not.closed.display.name=開啟了 'Channel'，但未安全關閉
char.used.in.arithmetic.content.cast.fix.family.name=插入轉換
char.used.in.arithmetic.context.cast.quickfix=插入到 {0} 的轉換
char.used.in.arithmetic.context.display.name=在算術上下文中使用 'char' 表達式
char.used.in.arithmetic.context.problem.descriptor=算術上下文中使用了 'char' \\#loc
char.used.in.arithmetic.context.quickfix=轉換為字串字面量
character.comparison.display.name=字元比較
character.comparison.problem.descriptor=國際化上下文中的字元比較 <code>\\#ref</code> \\#loc
checkbox.ignore.null.on.wrong.side=忽略錯誤側的 'null'
checked.exception.class.display.name=已檢查的異常類別
checked.exception.class.problem.descriptor=已檢查的異常類別 <code>\\#ref</code> \\#loc
choose.autocloseable.type.to.ignore.title=選擇要忽略的 AutoCloseable 資源類型
choose.class=選擇類別
choose.class.hierarchy.to.ignore.title=選擇要忽略的類別層次結構
choose.class.type.to.ignore=選擇要忽略的類別
choose.exception.class=選擇異常類別
choose.exception.label=被禁止的異常\\:
choose.io.resource.type.to.ignore=選擇要忽略的 I/O 資源類型
choose.logger.class=選擇記錄器類別
class.escapes.defined.scope.display.module.option=報告在模組 API 中公開的非匯出類別(Java 9+)
class.escapes.defined.scope.display.name=類別在其可見性作用域之外公開
class.escapes.defined.scope.display.package.option=報告在 package-local API 中公開的 private 類別
class.escapes.defined.scope.display.public.option=報告在公開 API 中公開的不可存取類別
class.escapes.defined.scope.java9.modules.descriptor=類別 <code>\\#ref</code> 未從模組 ''{0}'' 匯出
class.escapes.defined.scope.problem.descriptor=類別 <code>\\#ref</code> 在其定義的可見性作用域之外公開 \\#loc
class.extends.utility.class.display.name=類別擴展實用程序類別
class.extends.utility.class.ignore.utility.class.option=如果覆寫類別為實用程序類別，則忽略
class.extends.utility.class.problem.descriptor=類別 <code>\\#ref</code> 擴展實用程序類別 ''{0}'' \\#loc
class.independent.of.module.display.name=獨立於其模組的類別
class.independent.of.module.problem.descriptor=類別 <code>\\#ref</code> 在其模組中沒有相依或相依項 \\#loc
class.initializer.display.name=非 'static' 初始設定式
class.initializer.may.be.static.display.name=實例初始設定式可以設為 'static'
class.initializer.may.be.static.problem.descriptor=類別初始設定式可能為 'static' \\#loc
class.initializer.move.code.to.constructor.quickfix=將初始設定式程式碼移至建構函式
class.initializer.option=僅在類別具有一個或多個建構函式時警告
class.initializer.problem.descriptor=非 'static' 初始設定式 \\#loc
class.loader.instantiation.display.name='ClassLoader' 實例化
class.loader.instantiation.problem.descriptor=實例化 <code>\\#ref</code> 可能造成安全問題 \\#loc
class.may.be.interface.convert.quickfix=將類別轉換為接口
class.may.be.interface.display.name='abstract' 類別可以是 'interface'
class.may.be.interface.java8.option=使用 Java 8 時報告包含非 abstract 方法的類別
class.may.be.interface.problem.descriptor=抽象類別 <code>\\#ref</code> 可能是接口 \\#loc
class.name=類別名
class.name.differs.from.file.name.display.name=類別名與檔名不同
class.name.differs.from.file.name.problem.descriptor=類別名 <code>\\#ref</code> 與檔名不同 \\#loc
class.name.prefixed.with.package.name.display.name=使用軟體套件名稱作為前綴的類別名
class.name.prefixed.with.package.name.problem.descriptor=類別名 <code>\\#ref</code> 以其軟體套件名稱開始 \\#loc
class.name.same.as.ancestor.name.display.name=類別名與上級名稱相同
class.name.same.as.ancestor.name.problem.descriptor=類別名 <code>\\#ref</code> 與其超類別的名稱之一相同 \\#loc
class.naming.convention.display.name=類別命名約定
class.naming.convention.element.description=類別
class.new.instance.display.name=對 'Class.newInstance()' 的呼叫不安全
class.new.instance.problem.descriptor=對 <code>\\#ref()</code> 的呼叫可能會拋出未宣告的已檢查的異常 \\#loc
class.only.used.in.one.module.display.name=僅在其他模組中使用的類別
class.only.used.in.one.module.problem.descriptor=類別 <code>\\#ref</code> 在其模組 ''{0}'' 中只有相依和/或相依性 \\#loc
class.only.used.in.one.package.display.name=僅在其他軟體套件中使用的類別
class.only.used.in.one.package.problem.descriptor=類別 <code>\\#ref</code> 在其軟體套件 ''{0}'' 中只有相依和/或相依項 \\#loc
class.references.subclass.display.name=類別參照其子類別之一
class.references.subclass.problem.descriptor=類別 ''{0}'' 參照子類別 <code>\\#ref</code> \\#loc
class.references.subclass.problem.descriptor.anonymous=匿名類別參照子類別 <code>\\#ref</code> \\#loc
class.too.deep.display.name=類別在繼承樹中太深
class.too.deep.inheritance.depth.limit.option=繼承深度限制\\:
class.too.deep.problem.descriptor=<code>\\#ref</code> 在繼承樹中太深 (繼承深度 \\= {0}) \\#loc
class.unconnected.to.package.display.name=獨立於其軟體套件的類別
class.unconnected.to.package.problem.descriptor=類別 <code>\\#ref</code> 在其軟體套件中沒有相依或相依項
class.with.only.private.constructors.display.name=僅包含 'private' 建構函式的類別應被宣告為 'final'
class.with.only.private.constructors.problem.descriptor=僅包含 'private' 建構函式的類別 <code>\\#ref</code> 應被宣告為 'final'
class.with.too.many.dependencies.display.name=相依過多的類別
class.with.too.many.dependencies.max.option=最大相依項數
class.with.too.many.dependencies.problem.descriptor=類別 ''{0}'' 的相依過多 ({1} > {2})
class.with.too.many.dependents.display.name=相依項過多的類別
class.with.too.many.dependents.max.option=最大相依項數
class.with.too.many.dependents.problem.descriptor=類別 ''{0}'' 的相依項過多 ({1} > {2})
class.with.too.many.transitive.dependencies.display.name=可傳遞相依項過多的類別
class.with.too.many.transitive.dependencies.max.option=最大可傳遞相依項數
class.with.too.many.transitive.dependencies.problem.descriptor=類別 ''{0}'' 的可傳遞相依項過多({1} > {2})
class.with.too.many.transitive.dependents.display.name=傳遞相依項過多的類別
class.with.too.many.transitive.dependents.max.option=最大傳遞相依項數
class.with.too.many.transitive.dependents.problem.descriptor=類別 ''{0}'' 的可傳遞相依項過多({1} > {2})
class.without.constructor.create.quickfix=生成空建構函式
class.without.constructor.display.name=不帶建構函式的類別
class.without.constructor.problem.descriptor=類別 <code>\\#ref</code> 沒有建構函式 \\#loc
class.without.logger.annotations.tab=註解
class.without.logger.loggers.tab=記錄器
class.without.no.arg.constructor.display.name=沒有無實參建構函式的類別
class.without.no.arg.constructor.ignore.option=如果類別具有預設建構函式，則忽略
class.without.no.arg.constructor.problem.descriptor=類別 <code>\\#ref</code> 缺少無實參建構函式 \\#loc
clone.doesnt.declare.clonenotsupportedexception.declare.quickfix=將 'CloneNotSupportedException' 新增到 throws 子句
clone.doesnt.declare.clonenotsupportedexception.display.name='clone()' 未宣告 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.problem.descriptor=<code>\\#ref()</code> \\#loc 未宣告 'CloneNotSupportedException'
clone.instantiates.new.array.problem.descriptor=''clone()'' 建立新的 {0} 陣列 \\#loc
clone.instantiates.objects.with.constructor.display.name='clone()' 用建構函式實例化物件
clone.instantiates.objects.with.constructor.problem.descriptor='clone()' 建立新的 <code>\\#ref</code> 實例 \\#loc
clone.method.in.non.cloneable.anonymous.class.problem.descriptor=<code>\\#ref()</code> 在派生自 ''{0}'' 的不可克隆匿名類別中定義 \\#loc
clone.method.in.non.cloneable.class.display.name=不可克隆類別中的 'clone()' 方法
clone.method.in.non.cloneable.class.problem.descriptor=<code>\\#ref()</code> 在不可克隆類別 ''{0}'' 中定義 \\#loc
clone.method.in.non.cloneable.interface.problem.descriptor=<code>\\#ref()</code> 在不可克隆接口 ''{0}'' 中定義 \\#loc
clone.returns.class.type.display.name='clone()' 應當具有等於其所包含類別的返回值類型
clone.returns.class.type.family.quickfix=將返回值類型更改為類別類型
clone.returns.class.type.problem.descriptor=''clone()'' 應當具有返回值類型 ''{0}'' \\#loc
clone.returns.class.type.quickfix=將返回值類型更改為 ''{0}''
cloneable.class.in.secure.context.display.name=安全上下文中的可克隆類別
cloneable.class.in.secure.context.problem.descriptor=類別 <code>\\#ref</code> 可能被克隆，影響安全性 \\#loc
cloneable.class.in.secure.context.quickfix=生成始終拋出異常的 'clone()' 方法
cloneable.class.without.clone.display.name=沒有 'clone()' 方法的可克隆類別
cloneable.class.without.clone.ignore.option=忽略由於繼承而可克隆的類別
cloneable.class.without.clone.ignore.when.clone.called.option=如果呼叫超類別的 clone() 方法需要 Cloneable，則忽略
cloneable.class.without.clone.problem.descriptor=<code>\\#ref</code> 為 'Cloneable'，但未定義 'clone()' 方法 \\#loc
cloneable.class.without.clone.quickfix=生成 'clone()' 方法
cloneable.class.without.clone.todo.message=TODO\\: 複製此處的可變狀態，這樣此克隆就不能更改初始克隆的內部項
collection.added.to.self.display.name=集合已新增到自身
collection.added.to.self.problem.descriptor=在以自身作為實參的集合 <code>\\#ref</code> 上調用了 ''{0}()'' \\#loc
collection.declared.by.class.display.name=按類別 (而不是接口) 宣告的集合
collection.declared.by.class.ignore.locals.option=忽略區域變數
collection.declared.by.class.ignore.private.members.option=忽略 'private' 欄位和方法
collection.declared.by.class.problem.descriptor=<code>\\#ref</code> 的宣告可能應當被削弱為 ''{0}'' \\#loc
collections.field.access.replaceable.by.method.call.display.name=對空集合欄位的參照可被取代為方法呼叫
collections.field.access.replaceable.by.method.call.fix.family.name=將 Collections.EMPTY_* 取代為呼叫
collections.field.access.replaceable.by.method.call.problem.descriptor=<code>\\#ref</code> 可被取代為 ''Collections.{0}'' \\#loc
collections.must.have.initial.capacity.display.name=沒有初始容量的集合
collections.must.have.initial.capacity.problem.descriptor=沒有初始容量的 <code>new \\#ref()</code> \\#loc
commented.out.code.delete.quickfix=刪除註釋
commented.out.code.uncomment.quickfix=撤消程式碼註釋
comments.as.content.option=註釋計為內容
comparable.implemented.but.equals.not.overridden.display.name=已實作 'Comparable'，但 'equals()' 未被覆寫
comparable.implemented.but.equals.not.overridden.fix.add.note.name=新增 'ordering inconsistent with equals' JavaDoc 記錄
comparable.implemented.but.equals.not.overridden.fix.generate.equals.name=生成 'equals()' 方法
comparable.implemented.but.equals.not.overridden.problem.descriptor=類別 <code>\\#ref</code> 實作 'java.lang.Comparable'，但未覆寫 'equals()' \\#loc
comparator.not.serializable.display.name='Comparator' 類別未被宣告為 'Serializable'
comparator.not.serializable.problem.descriptor=比較器類別 <code>\\#ref</code> 未被宣告為可序列化 \\#loc
comparison.of.short.and.char.display.name=比較 'short' 和 'char' 值
comparison.of.short.and.char.problem.descriptor=short 和 char 值的相等比較 <code>\\#ref</code> \\#loc
comparison.to.nan.display.name=與 'Double.NaN' 或 'Float.NaN' 比較
comparison.to.nan.problem.descriptor1=與 <code>\\#ref</code> 的比較始終為 false \\#loc
comparison.to.nan.problem.descriptor2=與 <code>\\#ref</code> 的比較始終為 true \\#loc
concrete.class.method.parameter.problem.descriptor=具體類別 <code>\\#ref</code> 的參數 ''{0}'' \\#loc
concrete.class.use.display.name=具體類別的使用
condition.signal.display.name=呼叫 'signal()' 而不是 'signalAll()'
condition.signal.problem.descriptor=<code>\\#ref</code> 可能應當取代為 'signalAll()' \\#loc
conditional.can.be.pushed.inside.expression.display.name=可以將條件推送到分支表達式內部
conditional.can.be.pushed.inside.expression.option=在條件將僅作為方法呼叫的實參時忽略
conditional.can.be.pushed.inside.expression.problem.descriptor=條件表達式可以推送到分支內 \\#loc
conditional.can.be.pushed.inside.expression.quickfix=在分支內推送條件表達式
conditional.expression.display.name=條件表達式
conditional.expression.expression.context.option=忽略無法使用 if 語句的位置
conditional.expression.option=對簡單賦值和返回值忽略
conditional.expression.problem.descriptor=條件表達式 <code>\\#ref</code> \\#loc
conditional.expression.quickfix=取代為 'if' 語句
conditional.expression.with.identical.branches.collapse.quickfix=摺疊條件表達式
conditional.expression.with.identical.branches.display.name=具有相同分支的條件表達式
conditional.expression.with.identical.branches.problem.descriptor=具有相同分支的條件表達式 <code>\\#ref</code> \\#loc
confusing.else.option=當 'if' 語句之後沒有其他語句時報告
confusing.floating.point.literal.change.quickfix=更改為規範形式
confusing.floating.point.literal.display.name=引起混淆的浮點字面量
confusing.floating.point.literal.option=在科學記數法中忽略浮點字面量
confusing.floating.point.literal.problem.descriptor=引起混淆的浮點字面量 <code>\\#ref</code> \\#loc
confusing.main.method.display.name=引起混淆的 'main()' 方法
confusing.main.method.problem.descriptor=方法 <code>\\#ref</code> 沒有簽名 'public static void main(String[])' \\#loc
confusing.octal.escape.sequence.display.name=引起混淆的八進制轉義序列
confusing.octal.escape.sequence.problem.descriptor=八進制轉義序列 <code>\\#ref</code> 後面緊跟數字 \\#loc
connection.opened.not.safely.closed.display.name=集合已開啟，但未安全關閉
consider.static.final.fields.constant.option=考慮 'static final' 欄位常數
constant.assert.condition.display.name='assert' 語句中的常數條件
constant.assert.condition.problem.descriptor=斷言條件 <code>\\#ref</code> 是常數 \\#loc
constant.conditional.expression.display.name=常數條件表達式
constant.conditional.expression.problem.descriptor=<code>\\#ref</code> 可以簡化為 ''{0}'' \\#loc
constant.conditional.expression.simplify.quickfix=簡化
constant.conditional.expression.simplify.quickfix.sideEffect=提取副作用並簡化
constant.declared.in.abstract.class.display.name=在 'abstract' 類別中宣告的常數
constant.declared.in.abstract.class.problem.descriptor=常數 <code>\\#ref</code> 在抽象類別中宣告 \\#loc
constant.declared.in.interface.display.name=在接口中宣告的常數
constant.declared.in.interface.problem.descriptor=常數 <code>\\#ref</code> 在接口中宣告 \\#loc
constant.for.zero.length.array.display.name=不必要的零長度陣列用法
constant.for.zero.length.array.problem.descriptor=零長度陣列可更改為常數 \\#loc
constant.for.zero.length.array.quickfix.family=取代為常數
constant.junit.assert.argument.display.name=常數斷言實參
constant.junit.assert.argument.problem.descriptor=實參 <code>\\#ref</code> 是常數 \\#loc
constant.math.call.display.name=對 'Math' 的常數呼叫
constant.math.call.problem.descriptor=對 <code>\\#ref()</code> 的常數呼叫可以簡化 \\#loc
constant.naming.convention.element.description=常數
constant.on.lhs.of.comparison.options.item.left=左
constant.on.lhs.of.comparison.options.item.right=右
constant.on.lhs.of.comparison.problem.descriptor=常數 <code>\\#ref</code> 位於比較的左側 \\#loc
constant.on.rhs.of.comparison.problem.descriptor=常數 <code>\\#ref</code> 位於比較的右側 \\#loc
constant.on.side.of.comparison.display.name=常數位於比較的錯誤一側
constant.value.variable.use.display.name=使用已知值為常數的變數
constant.value.variable.use.problem.descriptor=<code>\\#ref</code> 的值已知為常數 \\#loc
constant.with.mutable.field.naming.convention.element.description=具有可變類型的常數
constructor.visibility.option=忽略具有以下可見性的建構函式\\:
continue.or.break.from.finally.block.display.name='continue' 或 'break' 位於 'finally' 塊內
continue.or.break.from.finally.block.problem.descriptor=<code>\\#ref</code> 位於 'finally' 塊內 \\#loc
continue.statement.display.name='continue' 語句
continue.statement.with.label.display.name=帶標籤的 'continue' 語句
continue.statement.with.label.problem.descriptor=帶標籤的 <code>\\#ref</code> 語句 \\#loc
control.flow.statement.without.braces.add.quickfix=將大括號新增到語句
control.flow.statement.without.braces.display.name=不帶大括號的控制流語句
control.flow.statement.without.braces.message=將大括號新增到 ''{0}'' 語句
control.flow.statement.without.braces.problem.descriptor=不帶大括號的 <code>{0}</code> \\#loc
convert.double.unary.quickfix=取代為 ''{0}{1}''
convert.empty.anonymous.to.new.fix.family.name=移除 '{}'
convert.octal.literal.to.decimal.literal.quickfix=將八進制字面量轉換為十進制字面量
convert.octal.literals.to.decimal.literals.quickfix=將八進制字面量轉換為十進制字面量
convert.system.out.to.log.call.family.name=將 'System.out' 呼叫轉換為日誌呼叫
convert.system.out.to.log.call.name=將 ''System.out'' 呼叫轉換為對 ''{0}'' 的呼叫
convert.to.variable.arity.method.quickfix=轉換為 vararg 方法
copy.constructor.misses.field.display.name=複製缺少欄位的建構函式
copy.constructor.misses.field.problem.descriptor.1=複製未複製欄位 ''{0}'' 的建構函式
copy.constructor.misses.field.problem.descriptor.2=複製未複製欄位 ''{0}'' 和 ''{1}'' 的建構函式
copy.constructor.misses.field.problem.descriptor.3=複製未複製欄位 ''{0}''、''{1}'' 和 ''{2}'' 的建構函式
copy.constructor.misses.field.problem.descriptor.many=複製未複製 {0} 個欄位的建構函式
covariant.equals.display.name=協變 'equals()'
covariant.equals.problem.descriptor=<code>\\#ref()</code> 應當以 'Object' 作為其實參 \\#loc
create.default.branch.fix.family.name=建立 'default' 分支
create.missing.boolean.switch.branches.fix.family.name=建立缺少的布爾 switch 分支
create.missing.branches.with.null.branch.fix.family.name=建立缺少的分支和 'null' 分支
create.missing.enum.switch.branches.fix.family.name=建立缺少的枚舉 switch 分支
create.missing.record.deconstructions.switch.branches.fix.family.name=建立缺失記錄解構 switch 分支
create.missing.sealed.class.switch.branches.fix.family.name=建立缺少的密封類別 switch 分支
create.missing.switch.branch=建立缺少的分支 {0}
create.missing.switch.branches=建立缺少的分支 {0}
create.null.branch.fix.family.name=建立 'null' 分支
create.package.info.java.family.name=建立 'package-info.java'
cstyle.array.method.declaration.problem.descriptor=方法 <code>{0}()</code> 具有 C 樣式陣列返回值類型宣告 \\#loc
cstyle.array.variable.declaration.problem.descriptor={0, choice, 1\\#欄位|2\\#參數|3\\#記錄組件|4\\#區域變數} <code>{1}</code> 具有 C 樣式陣列類型宣告 \\#loc
custom.classloader.display.name=宣告了自訂的 'ClassLoader'
custom.classloader.problem.descriptor=自訂 ClassLoader 類別 <code>\\#ref</code> \\#loc
custom.security.manager.display.name=自訂 'SecurityManager'
custom.security.manager.problem.descriptor=自訂 SecurityManager 類別 <code>\\#ref</code> \\#loc
cyclic.class.dependency.1.problem.descriptor=類別 ''{0}'' 迴圈依賴於類別 ''{1}''
cyclic.class.dependency.2.problem.descriptor=類別 ''{0}'' 迴圈依賴於類別 ''{1}'' 和 ''{2}''
cyclic.class.dependency.display.name=迴圈類別相依
cyclic.class.dependency.ignore.in.same.file=忽略位於同一檔案中的類別之間的迴圈
cyclic.class.dependency.problem.descriptor=類別 ''{0}'' 迴圈依賴於其他 {1} 個類別
cyclic.package.dependency.1.problem.descriptor=軟體套件 ''{0}'' 迴圈依賴於軟體套件 ''{1}''
cyclic.package.dependency.2.problem.descriptor=軟體套件 ''{0}'' 迴圈依賴於軟體套件 ''{1}'' 和 ''{2}''
cyclic.package.dependency.display.name=迴圈軟體套件相依關係
cyclic.package.dependency.problem.descriptor=軟體套件 ''{0}'' 迴圈依賴於其他 {1} 個軟體套件
cyclomatic.complexity.display.name=過度複雜的方法
cyclomatic.complexity.limit.option=迴圈復雜度限制\\:
cyclomatic.complexity.problem.descriptor=過度複雜的方法 <code>\\#ref()</code> (迴圈復雜度 \\= {0}) \\#loc
dangling.javadoc.convert.line.comment.quickfix=取代為行註釋
dangling.javadoc.convert.quickfix=取代為塊註釋
dangling.javadoc.delete.quickfix=移除懸空的註釋
dangling.javadoc.display.name=懸空的 Javadoc 註釋
dangling.javadoc.ignore.copyright.option=忽略 JavaDoc 格式的檔案頭註釋
dangling.javadoc.problem.descriptor=懸空的 Javadoc 註釋 \\#loc
debug.level.and.lower.option=偵錯級別和更低
declare.collection.as.interface.fix.family.name=削弱類型
declare.collection.as.interface.quickfix=削弱為 ''{0}''
default.not.last.case.in.switch.display.name='default' 不是 'switch' 中的最後一個 case
default.not.last.case.in.switch.problem.descriptor=''default'' 分支不是 ''switch'' {0} 中的最後一個 case \\#loc
default.tostring.call.display.name=呼叫預設 'toString()'
default.tostring.call.problem.descriptor=呼叫 <code>\\#ref</code> 上的預設 'toString()' \\#loc
delete.catch.section.fix.family.name=刪除 catch 語句
delete.catch.section.quickfix=刪除 'catch' 部分
delete.import.quickfix=刪除不必要的匯入
delete.unnecessary.statement.fix.family.name=移除冗餘語句
deserializable.class.in.secure.context.problem.descriptor=類別 <code>\\#ref</code> 可能被反序列化，影響安全性 \\#loc
design.for.extension.display.name=為擴展設計
design.for.extension.problem.descriptor=方法 <code>\\#ref()</code> 可能被覆寫，其功能會被忽略 \\#loc
diamond.can.be.replaced.with.explicit.type.arguments.name=diamond 可被取代為顯式類型實參
diamond.can.be.replaced.with.explicit.type.arguments.quickfix=將 '<>' 取代為顯式類型實參
disjoint.package.display.name=具有不相交相依關係圖的軟體套件
disjoint.package.problem.descriptor=軟體套件 {0} 可以分解為 {1} 個獨立軟體套件
divide.by.zero.display.name=除以零
divide.by.zero.problem.descriptor=除以零 \\#loc
dollar.sign.in.name.display.name=在關鍵字中使用 '$'
dollar.sign.in.name.problem.descriptor=關鍵字 <code>\\#ref</code> 包含 '$' \\#loc
double.brace.initialization.display.name=雙大括號初始化
double.brace.initialization.quickfix=取代為正則初始化
double.checked.locking.display.name=雙重檢查鎖定
double.checked.locking.fix.family.name=將欄位設為 volatile
double.checked.locking.problem.descriptor=雙重檢查鎖定 \\#loc
double.checked.locking.quickfix=將 ''{0}'' 設為 volatile
double.literal.may.be.float.literal.display.name=轉換為 'float' 可以是 'float' 字面量
double.negation.display.name=雙重否定
double.negation.problem.descriptor=<code>\\#ref</code> 中的雙重否定 \\#loc
double.negation.quickfix=移除雙重否定
drivermanager.call.display.name=使用 'DriverManager' 獲取 JDBC 連線
drivermanager.call.problem.descriptor=呼叫 <code>DriverManager.\\#ref()</code> \\#loc
dumpstack.call.display.name=呼叫 'Thread.dumpStack()'
dumpstack.call.problem.descriptor=對 <code>Thread.\\#ref()</code> 的呼叫可能應當取代為更可靠的日誌 \\#loc
duplicate.condition.display.name=條件重複
duplicate.condition.ignore.method.calls.option=忽略可能有副作用的條件
duplicate.condition.ignore.method.calls.option.description=如果選中，則不會報告具有潛在副作用的條件(例如，未知的方法呼叫)。已知會產生副作用的方法在任何情況下都不會被報告。
duplicate.condition.problem.descriptor=重複條件 <code>\\#ref</code> \\#loc
dynamic.regex.replaceable.by.compiled.pattern.display.name=動態正則表達式可被取代為已編譯的 'Pattern'
dynamic.regex.replaceable.by.compiled.pattern.problem.descriptor=<code>\\#ref()</code> 可被取代為已編譯的 'java.util.regex.Pattern' 結構 \\#loc
dynamic.regex.replaceable.by.compiled.pattern.quickfix=取代為對已編譯 'Pattern' 常數的方法的呼叫
empty.anonymous.class.problem.descriptor=匿名類別為空 \\#loc
empty.class.display.name=空類別
empty.class.file.without.class.problem.descriptor=Java 檔案未宣告任何類別 \\#loc
empty.class.ignore.parameterization.option=如果類別是父類型的參數化，則將其忽略
empty.class.initializer.delete.quickfix=刪除空類別初始設定式
empty.class.initializer.display.name=空類別初始設定式
empty.class.initializer.problem.descriptor=空類別初始設定式 \\#loc
empty.class.problem.descriptor=類別 <code>\\#ref</code> 為空 \\#loc
empty.enum.problem.descriptor=枚舉 <code>\\#ref</code> 為空 \\#loc
empty.finally.block.display.name=空 'finally' 塊
empty.finally.block.problem.descriptor=空 <code>\\#ref</code> 塊 \\#loc
empty.synchronized.statement.display.name=空 'synchronized' 語句
empty.synchronized.statement.problem.descriptor=空 <code>\\#ref</code> 語句 \\#loc
empty.try.block.display.name=空 'try' 塊
empty.try.block.problem.descriptor=空 <code>\\#ref</code> 塊 \\#loc
encapsulate.variable.fix.family.name=封裝欄位
encapsulate.variable.quickfix=封裝欄位 ''{0}''
enum.singleton.problem.descriptor=枚舉 <code>\\#ref</code> 為單例 \\#loc
enum.switch.statement.which.misses.cases.display.name=缺少 case 的枚舉 'switch' 語句
enum.switch.statement.which.misses.cases.option=忽略具有預設分支的 switch 語句
enum.switch.statement.which.misses.cases.problem.descriptor=枚舉類型 ''{0}'' 上的 <code>\\#ref</code> 語句缺少 case {1} \\#loc
enum.switch.statement.which.misses.cases.problem.descriptor.single=枚舉類型 ''{0}'' 上的 <code>\\#ref</code> 語句缺少 case ''{1}'' \\#loc
enumerated.class.display.name=枚舉類別
enumerated.class.naming.convention.element.description=枚舉類別
enumerated.class.problem.descriptor=枚舉類別 <code>\\#ref</code> \\#loc
enumerated.constant.naming.convention.element.description=枚舉常數
enumeration.can.be.iteration.display.name=枚舉可以是迭代
enumeration.can.be.iteration.problem.descriptor=<code>\\#ref()</code> 可被取代為 ''{0}'' 結構 \\#loc
enumeration.can.be.iteration.quickfix=取代為 'Iterator' 結構
equality.to.safe.equals.quickfix=用 null 安全 'equals()' 取代 '\\=\\='
equals.between.inconvertible.types.display.name='equals()' 位於不可轉換類型的物件之間
equals.between.inconvertible.types.mutual.subclass.option=如果未找到相互子類別，則發出警告
equals.between.inconvertible.types.no.mutual.subclass.problem.descriptor=未找到屬於 ''{0}'' 和 ''{1}'' 這兩個子類型的類別 \\#loc
equals.between.inconvertible.types.problem.descriptor=<code>\\#ref</code> 位於 ''{0}'' 和 ''{1}'' 不可轉換類型的物件之間 \\#loc
equals.called.on.array.display.name=在陣列上呼叫了 'equals()'
equals.called.on.array.problem.descriptor=陣列之間的 <code>\\#ref()</code> 可能應當是 'Arrays.equals()' \\#loc
equals.called.on.enum.constant.display.name=對枚舉值呼叫了 'equals()'
equals.called.on.enum.constant.problem.descriptor=對枚舉值呼叫了 <code>\\#ref()</code> \\#loc
equals.called.on.suspicious.object.display.name=在不對其進行覆寫的類別上呼叫了 'equals()'
equals.called.on.suspicious.object.fix.family.name=取代為代表值的比較
equals.called.on.suspicious.object.fix.name=取代為 ''{0}()'' 呼叫結果的比較
equals.called.on.suspicious.object.problem.descriptor=''{0}'' 物件上存在可疑的 ''equals()'' 呼叫
equals.doesnt.check.class.parameter.display.name=不檢查其參數的類別的 'equals()' 方法
equals.doesnt.check.class.parameter.problem.descriptor=<code>\\#ref()</code> 應當檢查其參數的類別 \\#loc
equals.replaceable.by.objects.call.display.name='equals()' 表達式可被取代為 'Objects.equals()' 表達式
equals.replaceable.by.objects.call.problem.descriptor=<code>\\#ref</code> 可被取代為 'Objects.equals()' 表達式 \\#loc
equals.replaceable.by.objects.check.not.null.option=醒目提示與 'a \\!\\= null \\\\&\\\\& a.equals(b)' 類似的表達式
equals.with.itself.display.name=在自身上呼叫了 'equals()'
equals.with.itself.option=忽略可能的約定測試
equals.with.itself.option.description=選中後，某些情況(如 <code>assertEquals(myObj, myObj)</code>)將不會被報告，以避免在檢查 <code>equals()</code> 方法正確性的測試中出現警告。
equals.with.itself.problem.descriptor=在自身上呼叫了 <code>\\#ref()</code>
error.rethrown.display.name='Error' 未重新拋出
error.rethrown.problem.descriptor=錯誤 <code>\\#ref</code> 未重新拋出 \\#loc
exception.from.catch.which.doesnt.wrap.display.name='throw' 位於忽略已捕獲異常的 'catch' 塊內
exception.from.catch.which.doesnt.wrap.problem.descriptor='catch' 塊內的 <code>\\#ref</code> 忽略捕獲的異常 \\#loc
exception.from.catch.which.doesntwrap.ignore.cant.wrap.option=如果拋出的異常無法包裝異常，則忽略
exception.from.catch.which.doesntwrap.ignore.option=如果使用異常方法呼叫的結果，則忽略
exception.name.doesnt.end.with.exception.display.name=異常類別名不以 'Exception' 結尾
exception.name.doesnt.end.with.exception.problem.descriptor=異常類別名 <code>\\#ref</code> 未以 'Exception' 結尾 \\#loc
exception.package.display.name=異常軟體套件
exception.package.problem.descriptor=軟體套件 ''{0}'' 僅包含異常類別
explicit.array.to.string.problem.descriptor=呼叫陣列上的 '\\#ref()' \\#loc
expression.can.be.replaced.no.quotes.problem.descriptor={0} 可被取代為 {1}
expression.can.be.replaced.problem.descriptor=<code>\\#ref</code> 可被取代為 ''{0}'' \\#loc
expression.may.be.factorized.display.name=表達式可以因式分解
extend.exception.fix.family.name=使類別擴展 'Exception'
extended.for.statement.display.name=增強的 'for' 語句
extended.for.statement.problem.descriptor=擴展 <code>\\#ref</code> 語句 \\#loc
extended.for.statement.replace.quickfix=取代為舊式 'for' 語句
extends.annotation.display.name=類別擴展註解接口
extends.annotation.interface.problem.descriptor=接口 ''{0}'' 擴展註解接口 <code>\\#ref</code> \\#loc
extends.annotation.problem.descriptor=類別 ''{0}'' 實作註解接口 <code>\\#ref</code> \\#loc
extends.concrete.collection.display.name=類別顯式擴展 'Collection' 類別
extends.concrete.collection.problem.descriptor=類別 <code>\\#ref</code> 顯式擴展 ''{0}'' \\#loc
extends.object.display.name=類別顯式擴展 'Object'
extends.object.problem.descriptor=類別 <code>\\#ref</code> 顯式擴展 'java.lang.Object' \\#loc
extends.object.remove.quickfix=移除冗餘的 'extends Object'
extends.thread.display.name=類別直接擴展 'Thread'
extends.thread.problem.descriptor=類別 <code>\\#ref</code> 直接擴展 'java.lang.Thread' \\#loc
extends.throwable.display.name=類別直接擴展 'Throwable'
extends.throwable.problem.descriptor=類別 <code>\\#ref</code> 直接擴展 'java.lang.Throwable' \\#loc
externalizable.with.serialization.methods.display.name=具有 'readObject()' 或 'writeObject()' 的可外部化類別
externalizable.with.serialization.methods.problem.descriptor.both=可外部化{0, choice, 1\\#類別|2\\#接口|3\\#派生的匿名類別|4\\#註解類型|5\\#枚舉|6\\#記錄} <code>\\#ref</code> 定義 'readObject()' 和 'writeObject()' \\#loc
externalizable.with.serialization.methods.problem.descriptor.read=可外部化{0, choice, 1\\#類別|2\\#接口|3\\#派生的匿名類別|4\\#註解類型|5\\#枚舉|6\\#記錄} <code>\\#ref</code> 定義 'readObject()' \\#loc
externalizable.with.serialization.methods.problem.descriptor.write=可外部化{0, choice, 1\\#類別|2\\#接口|3\\#派生的匿名類別|4\\#註解類型|5\\#枚舉|6\\#記錄} <code>\\#ref</code> 定義 'writeObject()' \\#loc
externalizable.without.public.no.arg.constructor.display.name=沒有 'public' 無實參建構函式的 'Externalizable' 類別
externalizable.without.public.no.arg.constructor.problem.descriptor=可外部化類別 <code>\\#ref</code> 沒有 'public' 無實參建構函式 \\#loc
extract.method.quickfix=提取方法
extract.parameter.as.local.variable.quickfix=提取參數作為區域變數
fallthru.in.switch.statement.display.name='switch' 語句中的直落
fallthru.in.switch.statement.problem.descriptor='switch' 語句存在直落 \\#loc
fallthru.in.switch.statement.quickfix=新增 ''{0}''
feature.envy.display.name=特性依戀
feature.envy.problem.descriptor=類別 ''{0}'' 在方法 <code>\\#ref()</code> 中被重複存取 \\#loc
field.accessed.synchronized.and.unsynchronized.display.name=同時在 'synchronized' 和未同步上下文中存取欄位
field.accessed.synchronized.and.unsynchronized.option=簡單的 getter 和 setter 也被視為欄位存取
field.accessed.synchronized.and.unsynchronized.problem.descriptor=同時在同步和未同步上下文中存取欄位 <code>\\#ref</code> \\#loc
field.count.inspection.include.constant.fields.in.count.checkbox=在計數中包含常數欄位
field.count.inspection.include.enum.constants.in.count=在計數中包含枚舉常數
field.count.inspection.static.final.fields.count.as.constant.checkbox=將 'static final' 欄位計為常數
field.has.setter.but.no.getter.display.name=欄位具有 setter 但沒有 getter
field.has.setter.but.no.getter.problem.descriptor=欄位 <code>\\#ref</code> 有 setter 但沒有 getter \\#loc
field.has.static.modifier.problem.descriptor=欄位 ''{0}'' 具有 ''static'' 修飾符
field.incorrect.type.problem.descriptor=欄位 ''{0}'' 沒有類型 ''{1}''
field.may.be.final.display.name=欄位可能為 'final'
field.may.be.final.problem.descriptor=欄位 <code>\\#ref</code> 可能為 'final' \\#loc
field.may.be.static.display.name=欄位可以為 'static'
field.may.be.static.problem.descriptor=欄位 <code>\\#ref</code> 可能為 'static' \\#loc
field.missing.volatile.modifier.problem.descriptor=欄位 ''{0}'' 沒有 ''volatile'' 修飾符
field.name.hides.in.superclass.display.name=子類別欄位隱藏超類別欄位
field.name.hides.in.superclass.ignore.option=忽略不可存取欄位
field.name.hides.in.superclass.ignore.static.field.option=忽略隱藏 static 欄位的 static 欄位
field.name.hides.in.superclass.problem.descriptor=欄位 <code>\\#ref</code> 隱藏超類別中的欄位 \\#loc
field.naming.convention.display.name=欄位命名約定
field.not.found.in.class.problem.descriptor=類別 ''{1}'' 中未找到命名為 ''{0}'' 的欄位
final.class.display.name=類別禁止繼承
final.class.problem.descriptor=類別 ''{0}'' 宣告了 <code>\\#ref</code> \\#loc
final.method.display.name=不能覆寫方法
final.method.in.final.class.display.name='final' 類別位於 'final' 方法中
final.method.in.final.class.problem.descriptor=方法在 'final' 類別中被宣告為 <code>\\#ref</code> \\#loc
final.method.problem.descriptor=方法被宣告為 <code>\\#ref</code> \\#loc
final.private.method.display.name='private' 方法被宣告為 'final'
final.private.method.problem.descriptor='private' 方法被宣告為 <code>\\#ref</code> \\#loc
final.static.method.display.name='static' 方法被宣告為 'final'
final.static.method.problem.descriptor='static' 方法被宣告為 <code>\\#ref</code> \\#loc
finalize.called.explicitly.display.name='finalize()' 被顯式呼叫
finalize.called.explicitly.problem.descriptor=<code>\\#ref()</code> 被顯式呼叫 \\#loc
finalize.declaration.display.name='finalize()' 不應被覆寫
finalize.declaration.problem.descriptor='finalize()' 不應被覆寫 \\#loc
finalize.not.declared.protected.display.name='finalize()' 應為 protected，不應為 public
finalize.not.declared.protected.problem.descriptor='finalize()' 應具有 protected 存取權限，不應具有 public 存取權限 \\#loc
finally.block.cannot.complete.normally.display.name=不能正常完成的 'finally' 塊
finally.block.cannot.complete.normally.problem.descriptor=<code>\\#ref</code> 塊無法正常完成 \\#loc
fix.add.argument.family.name=新增實參
fix.add.argument.name=新增 ''{0}'' 實參
fix.eliminate.folded.if.present.description=可以消除折疊的 'ifPresent()' 呼叫
fix.eliminate.folded.if.present.name=移除折疊的 'ifPresent()' 呼叫
fix.replace.map.with.flat.map.description='map()' 可被取代為 'flatMap()'
flip.comparison.quickfix=翻轉比較
floating.point.equality.display.name=浮點相等比較
floating.point.equality.problem.descriptor=<code>\\#ref</code>\\: 比較浮點值以實作完全相等 \\#loc
for.can.be.foreach.display.name='for' 迴圈可被取代為增強的 for 迴圈
for.can.be.foreach.fix.no.indexed=不報告索引的 'java.util.List' 迴圈
for.can.be.foreach.option=報告索引的 'java.util.List' 迴圈
for.can.be.foreach.option2=不報告無類型集合上的迭代
for.can.be.foreach.problem.descriptor=<code>\\#ref</code> 迴圈可被取代為增強的 'for' \\#loc
for.loop.replaceable.by.while.display.name='for' 迴圈可被取代為 'while' 迴圈
for.loop.replaceable.by.while.ignore.option=忽略無條件迴圈的 'infinite'
for.loop.replaceable.by.while.problem.descriptor=<code>\\#ref</code> 迴圈語句可被取代為 'while' 迴圈 \\#loc
for.loop.with.missing.component.collection.loop.option=忽略集合迭代
for.loop.with.missing.component.display.name=缺少組件的 'for' 迴圈
for.loop.with.missing.component.problem.descriptor1=<code>\\#ref</code> 語句缺少初始設定式 \\#loc
for.loop.with.missing.component.problem.descriptor2=<code>\\#ref</code> 語句缺少條件 \\#loc
for.loop.with.missing.component.problem.descriptor3=<code>\\#ref</code> 語句缺少更新 \\#loc
for.loop.with.missing.component.problem.descriptor4=<code>\\#ref</code> 語句缺少初始設定式和條件 \\#loc
for.loop.with.missing.component.problem.descriptor5=<code>\\#ref</code> 語句缺少初始設定式和條件 \\#loc
for.loop.with.missing.component.problem.descriptor6=<code>\\#ref</code> 語句缺少條件和更新 \\#loc
for.loop.with.missing.component.problem.descriptor7=<code>\\#ref</code> 語句缺少初始設定式、條件和更新 \\#loc
foreach.replace.quickfix=取代為增強 'for'
format.string.error.duplicate.flag=''{1}'' 中存在重複的標誌 ''{0}''
format.string.error.flags.not.allowed=''{1}'' 中不允許使用{2, choice, 1\\#標誌|1<標誌} ''{0}''
format.string.error.illegal.flag.combination=''{2}'' 中的標誌組合 ''{0}'' 和 ''{1}'' 非法
format.string.error.illegal.position.specifier=''{1}'' 存在非法的位置說明符 ''{0}''
format.string.error.invalid.precision=''{0}'' 中指定的精度無效
format.string.error.left.justify.no.width=使用了左對齊標誌 ''-''，但 ''{0}'' 中未指定寬度
format.string.error.precision.not.allowed=''{1}'' 中不允許該精度 (''{0}'')
format.string.error.previous.element.not.found=使用了以前的標誌 '<'，但沒有找到 ''{0}'' 以前的格式說明符
format.string.error.unexpected.flag=''{1}'' 中出現意外字元 ''{0}''
format.string.error.unknown.conversion=''{0}'' 中存在未知的轉換
format.string.error.unnecessary.position.specifier=''{1}'' 存在不必要的實參位置說明符 ''{0}''
format.string.error.width.not.allowed=''{1}'' 中不允許該寬度 (''{0}'')
format.string.error.zero.padding.no.width=使用了零填充標誌 ''0''，但 ''{0}'' 中未指定寬度
gc.call.display.name=呼叫 'System.gc()' 或 'Runtime.gc()'
gc.call.problem.descriptor=<code>\\#ref</code> 不應在生產程式碼中呼叫 \\#loc
generate.to.string.quick.fix.family.name=生成
generate.to.string.quick.fix.text=生成 toString()
hardcoded.file.separator.display.name=硬編碼檔案分隔符
hardcoded.file.separator.ignore.methods.option=忽略以下方法的實參\\:
hardcoded.file.separator.include.option=在已識別的 MIME 媒體類型中包括 'example/*'
hardcoded.file.separator.problem.descriptor=硬編碼檔案分隔符 <code>\\#ref</code> \\#loc
hardcoded.line.separator.display.name=硬編碼行分隔符
hardcoded.line.separator.problem.descriptor=硬編碼行分隔符 <code>\\#ref</code> \\#loc
hibernate.resource.opened.not.closed.display.name=Hibernate 資源已開啟，但未安全關閉
html.tag.can.be.javadoc.tag.display.name='<code>…</code>' 可被取代為 '{@code …}'
html.tag.can.be.javadoc.tag.problem.descriptor=<code>\\#ref...\\\\&lt;/code\\\\&gt;</code> 可被取代為 '{@code …}' \\#loc
i.o.resource.opened.not.closed.display.name=I/O 資源已開啟，但未安全關閉
if.can.be.assertion.name=語句可被取代為 'assert' 或 'Objects.requireNonNull'
if.can.be.assertion.replace.with.assertion.quickfix=將語句取代為 'assert' 語句
if.can.be.assertion.replace.with.objects.requirenonnull.quickfix=將語句取代為 'Objects.requireNonNull()'
if.can.be.switch.display.name='if' 可被取代為 'switch'
if.can.be.switch.enum.option=對枚舉啟用 switch 建議
if.can.be.switch.int.option=對數字啟用 switch 建議
if.can.be.switch.minimum.branch.option='if' 條件分支的最小數量\\:
if.can.be.switch.null.safe.option=僅對 null-safe 表達式啟用建議
if.can.be.switch.problem.descriptor=<code>\\#ref</code> 語句可被取代為 'switch' 語句 \\#loc
if.may.be.conditional.problem.descriptor=<code>\\#ref</code> 可被取代為條件表達式 \\#loc
if.may.be.conditional.quickfix=取代為條件表達式
if.may.be.factorized.problem.descriptor=<code>\\#ref</code> 可以因式分解 \\#loc
if.may.be.factorized.quickfix=取代為因式分解表達式
if.statement.with.identical.branches.display.name=具有相同分支或通用部分的 'if' 語句
if.statement.with.too.many.branches.display.name='if' 語句的分支過多
if.statement.with.too.many.branches.max.option=最大分支數\\:
if.statement.with.too.many.branches.problem.descriptor=<code>\\#ref</code> 的分支過多 ({0}) \\#loc
ignore.accesses.from.equals.method=忽略來自 'equals()' 方法的存取
ignore.accesses.from.the.same.class=忽略來自同一類的存取
ignore.anonymous.inner.classes=忽略匿名類別
ignore.boolean.methods.in.an.interface.option=忽略 @&interface 中的布爾方法
ignore.branches.of.switch.statements=忽略 'switch' 語句的分支
ignore.calls.to.property.getters=忽略對屬性 getter 的呼叫
ignore.calls.to.static.methods=忽略對 static 方法的呼叫
ignore.classes.annotated.by=由以下物件註解時忽略類別\\:
ignore.classes.in.hierarchy.column.name=忽略以下物件的子類別\\:
ignore.cloneable.option=忽略 'java.lang.Cloneable'
ignore.constructor.method.references=忽略產生 AutoCloseable 的建構函式方法參照
ignore.enhanced.for.loop.statements=忽略增強型 for 迴圈
ignore.equals.hashcode.and.tostring=忽略 'equals()'、'hashCode()' 和 'toString()' 方法
ignore.exceptions.declared.on.library.override.option=忽略在覆寫庫方法的方法上宣告的異常(&L)
ignore.for.equals.methods.option=對 'equals()' 方法忽略(&E)
ignore.getters.returning.resource=忽略返回源的 getter
ignore.guard.clauses.option=忽略 guard 子句(&G)
ignore.if.annotated.by=由以下物件註解時忽略\\:
ignore.in.module.statements.option=在 Java 9 模組語句中忽略
ignore.instanceof.on.library.classes=忽略庫類別上的 instanceof
ignore.methods.in.anonymous.classes=忽略匿名類別中的方法
ignore.methods.overriding.super.method=忽略覆寫/實作 super 方法的方法(O&)
ignore.methods.with.boolean.return.type.option=忽略具有 'java.lang.Boolean' 返回值類型的方法(&B)
ignore.overflowing.byte.casts.option=忽略從 int 128-255 到位元組的轉換
ignore.parentheses.around.single.no.formal.type.lambda.parameter=忽略單個非正式類型 lambda 參數周圍的括號
ignore.private.methods.option=忽略 private 方法中的賦值和返回值
ignore.serializable.option=忽略 'java.io.Serializable'
ignore.single.field.static.imports.option=忽略單欄位 static import(&F)
ignore.single.method.static.imports.option=忽略單方法 static import(&M)
ignore.trivial.finalizers.option=對普通 'finalize()' 實作忽略
ignored.autocloseable.types.label=已忽略的 AutoCloseable 資源類型\\:
ignored.class.hierarchies.border.title=忽略以下物件的子類別\\:
ignored.class.label=已忽略類別(包括子類別)\\:
ignored.class.names=忽略類別(包括子類別)
ignored.io.resource.types.label=已忽略的 I/O 資源類型\\:
implicit.array.to.string.display.name=呼叫陣列上的 'toString()'
implicit.array.to.string.fix.family.name=將 Array.toString() 設為隱式
implicit.array.to.string.method.call.problem.descriptor=隱式呼叫呼叫 <code>\\#ref</code> 返回的陣列上的 'toString()' \\#loc
implicit.array.to.string.problem.descriptor=隱式呼叫陣列 <code>\\#ref</code> 上的 'toString()' \\#loc
implicit.array.to.string.quickfix=使用 ''{0}'' 表達式包裝
implicit.call.to.super.display.name=隱式呼叫 'super()'
implicit.call.to.super.ignore.option=對 'java.lang.Object' 的直接子類別忽略
implicit.call.to.super.make.explicit.quickfix=使對 'super()' 的呼叫顯式
implicit.call.to.super.problem.descriptor=隱式呼叫 'super()' \\#loc
implicit.default.charset.usage.constructor.problem.descriptor=<code>new \\#ref()</code> 呼叫使用平台的預設字符集
implicit.default.charset.usage.display.name=隱式平台預設字符集
implicit.default.charset.usage.fix.family.name=指定 UTF-8 字符集
implicit.default.charset.usage.problem.descriptor=對 <code>\\#ref()</code> 的呼叫使用平台的預設字符集
implicit.numeric.conversion.assignment.problem.descriptor=將結果值從 ''{0}'' 隱式數字轉換為 ''{1}'' \\#loc
implicit.numeric.conversion.display.name=隱式數字轉換
implicit.numeric.conversion.ignore.char.conversion.option=忽略 'char' 之間的轉換
implicit.numeric.conversion.ignore.constant.conversion.option=忽略從常數和字面量的轉換
implicit.numeric.conversion.ignore.widening.conversion.option=忽略擴大轉換
implicit.numeric.conversion.make.explicit.quickfix=使轉換顯式
implicit.numeric.conversion.problem.descriptor=將 <code>\\#ref</code> 從 ''{0}'' 隱式數字轉換為 ''{1}'' \\#loc
import.display.name='*' 匯入
import.from.same.package.display.name=相同軟體套件中的不必要 import
import.from.same.package.problem.descriptor=相同軟體套件 <code>\\#ref</code> 中有不必要的 import \\#loc
import.problem.descriptor=軟體套件匯入 <code>\\#ref</code> \\#loc
include.java.system.classes.option=包括與 Java 系統類別的耦合
include.library.classes.option=包括與庫類別的耦合
incompatible.mask.operation.display.name=不相容的位元遮罩運算
incompatible.mask.operation.problem.descriptor.always.false=<code>\\#ref</code> 始終為 false \\#loc
incompatible.mask.operation.problem.descriptor.always.true=<code>\\#ref</code> 始終為 true \\#loc
incorrect.date.format.fix.family.name=修復不正確的日期格式
increment.decrement.display.name=使用 '++' 或 '--' 的結果
increment.decrement.used.as.expression.fix.family.name=提取到分離語句中
increment.decrement.used.as.expression.quickfix=提取 ''{0}'' 以分離語句
inequality.to.safe.not.equals.quickfix=用 null 安全 '\\!equals()' 取代 '\\!\\='
infinite.loop.statement.display.name=無限迴圈語句
infinite.loop.statement.problem.descriptor=<code>\\#ref</code> 語句不能在未拋出異常的情況下完成 \\#loc
infinite.recursion.display.name=無限遞迴
infinite.recursion.problem.descriptor=方法 <code>\\#ref()</code> 無限遞迴，只能以拋出異常結束 \\#loc
info.level.and.lower.option=資訊級別和更低
inline.call.quickfix=內聯呼叫
inline.variable.quickfix=內聯變數
inner.class.field.hides.outer.display.name=內部類別欄位隱藏外部類別欄位
inner.class.field.hides.outer.ignore.option=忽略從內部類別不可見的外部欄位
inner.class.field.hides.outer.problem.descriptor=內部類別欄位 <code>\\#ref</code> 隱藏外部類別欄位 \\#loc
inner.class.may.be.static.display.name=內部類別可能為 'static'
inner.class.may.be.static.problem.descriptor=內部類別 <code>\\#ref</code> 可能為 'static' \\#loc
inner.class.on.interface.display.name=接口的內部類別
inner.class.on.interface.ignore.option=忽略接口的內部接口
inner.class.on.interface.problem.descriptor=接口 ''{0}'' 具有內部類別 <code>\\#ref</code> \\#loc
inner.class.referenced.via.subclass.display.name=通過子類別參照的內部類別
inner.class.referenced.via.subclass.problem.descriptor=內部類別 <code>\\#ref</code> 在類別 ''{0}'' 中宣告，但通過子類別 ''{1}'' 參照 \\#loc
inner.class.referenced.via.subclass.quickfix=使內部類別存取合理化
inner.class.too.deeply.nested.display.name=內部類別嵌套太深
inner.class.too.deeply.nested.nesting.limit.option=嵌套限制\\:
inner.class.too.deeply.nested.problem.descriptor=<code>\\#ref</code> 嵌套太深 (嵌套級別 \\= {0}) \\#loc
inspection.autocloseable.resource.ignored.methods.title=忽略從這些方法返回的 AutoCloseable 實例\\:
inspection.byte.array.output.stream.to.string.message=ByteArrayOutputStream 轉換低效
inspection.case.mismatch.display.name='String' 動作中不符合的大小寫
inspection.case.mismatch.message.arg.is.lower=方法 ''{0}()'' 始終返回 {1}\\: 實參包含小寫符號，而限定符不包含小寫符號
inspection.case.mismatch.message.arg.is.upper=方法 ''{0}()'' 始終返回 {1}\\: 實參包含大寫符號，而限定符不包含大寫符號
inspection.case.mismatch.message.label.is.lower=無法存取 switch 分支\\: 標籤包含小寫符號，而選擇器僅支援大寫
inspection.case.mismatch.message.label.is.upper=無法存取 switch 分支\\: 標籤包含大寫符號，而選擇器僅支援小寫
inspection.cast.can.be.replaced.with.variable.display.name=轉換可被取代為變數
inspection.cast.can.be.replaced.with.variable.family.name=用變數取代轉換
inspection.cast.can.be.replaced.with.variable.message=可以使用變數 ''{0}'' 替代 ''{1}''
inspection.catch.ignores.exception.display.name=catch 塊可能會忽略異常
inspection.catch.ignores.exception.empty.message=空 <code>\\#ref</code> 塊 \\#loc
inspection.catch.ignores.exception.option.comments=當 'catch' 塊包含註釋時不發出警告
inspection.catch.ignores.exception.option.ignored.used=當名稱為 'ignore(d)' 的異常實際上未被忽略時不發出警告
inspection.catch.ignores.exception.option.nonempty=當 'catch' 塊不為空時不發出警告
inspection.catch.ignores.exception.unused.message=未使用的 'catch' 參數 <code>\\#ref</code> \\#loc
inspection.catch.ignores.exception.used.message=已使用命名為 <code>\\#ref</code> 的 'catch' 參數 \\#loc
inspection.catch.ignores.exception.vm.ignored.message=<code>\\#ref</code> 塊中可能會忽略 ''{0}'' 之類的意外虛擬機異常 \\#loc
inspection.collection.must.have.initial.capacity.initializers.option=不報告欄位初始設定式
inspection.commented.out.code.disable.short.fragments=不報告此類別短片段
inspection.commented.out.code.display.name=註釋掉的程式碼
inspection.commented.out.code.min.lines.options=最少程式碼行數
inspection.commented.out.code.problem.descriptor=註釋掉的程式碼 ({0} {0, choice, 1\\#行|1<行})
inspection.common.if.parts.description.complete.duplicate=可以摺疊 ''if'' 語句{0}
inspection.common.if.parts.description.complete.duplicate.side.effect=可以通過提取副作用摺疊 'if' 語句
inspection.common.if.parts.description.variables.only=可以從 ''if'' 中提取變數{0}
inspection.common.if.parts.description.whole.branch=可以提取通用部分，同時移除分支{0}
inspection.common.if.parts.description.with.variables.extract=可以從 ''if'' 中提取包含變數的通用部分{0}
inspection.common.if.parts.description.without.variables.extract=可以從 ''if'' 中提取通用部分{0}
inspection.common.if.parts.message.complete.duplicate=摺疊 ''if'' 語句{0}
inspection.common.if.parts.message.complete.duplicate.side.effect=摺疊 'if' 語句並提取副作用
inspection.common.if.parts.message.variables.only=從 ''if'' 中提取變數{0}
inspection.common.if.parts.message.whole.branch=提取通用部分，同時移除分支{0}
inspection.common.if.parts.message.with.variables.extract=從 ''if'' 中提取包含變數的通用部分{0}
inspection.common.if.parts.message.without.variables.extract=從 ''if'' 中提取通用部分{0}
inspection.common.subexpression.in.switch.display.name=可以從 'switch' 中提取通用子表達式
inspection.common.subexpression.in.switch.fix.family.name=向下推送 'switch' 表達式
inspection.comparator.combinators.description=可被取代為 'Comparator' 鏈
inspection.comparator.combinators.description2=可被取代為 ''{0}''
inspection.comparator.combinators.fix.chain=取代為 'Comparator' 鏈
inspection.condition.covered.by.further.condition.descr=條件 ''{0}'' 由後面的{1, choice, 1\\#條件 ''''{2}''''|2\\#條件}覆蓋
inspection.constant.expression.display.name=可以對常數表達式求值
inspection.constant.expression.fix.family.name=計算常量值
inspection.constant.expression.fix.name=計算 ''{0}'' 的常量值
inspection.constant.expression.fix.name.short=取代為常量值
inspection.constant.expression.message=常數表達式的求值結果可以為 ''{0}''
inspection.constant.expression.report.compile.time=僅報告編譯時常量
inspection.constant.expression.report.compile.time.description=預設情況下，該檢查可以評估一些涉及庫方法呼叫的常數，甚至可以根據周圍程式碼推斷常量值。選中此選項可以根據 Java 語言規範僅報告編譯時常量。
inspection.constant.expression.skip.non.literal=不報告包含對已定義常數的參照的表達式
inspection.constant.expression.skip.non.literal.description=忽略包含對非字面量動作數(例如欄位和變數)參照的表達式。
inspection.deconstruction.can.be.used.display.name=可以使用記錄模式
inspection.deconstruction.can.be.used.fix.family.name=取代為記錄模式
inspection.deconstruction.can.be.used.message=可被取代為記錄模式
inspection.empty.catch.block.generate.body=從模板生成 'catch' 正文
inspection.empty.class.ignore.subclasses.option=忽略 {0} 的子類別
inspection.enhanced.for.with.record.pattern.can.be.used.components.option=要解構的記錄組件的最大數量\\:
inspection.enhanced.for.with.record.pattern.can.be.used.display.name=可以使用帶有記錄模式的增強 'for'
inspection.enhanced.for.with.record.pattern.can.be.used.fix.family.name=取代為記錄模式
inspection.enhanced.for.with.record.pattern.can.be.used.level.option=嵌套深度限制\\:
inspection.enhanced.for.with.record.pattern.can.be.used.maximum.depth.disabled=不建議帶有 {0} 種和更多嵌套模式的模式
inspection.enhanced.for.with.record.pattern.can.be.used.maximum.number.disabled=不建議帶有 {0} 個或更多組件的記錄
inspection.enhanced.for.with.record.pattern.can.be.used.message=可被取代為帶有記錄模式的增強 'for'
inspection.enhanced.for.with.record.pattern.can.be.used.not.used.option=未使用的記錄組件的最大數量\\:
inspection.excessive.range.check.fix.family.name=簡化過度範圍檢查
inspection.excessive.range.check.message=可被取代為 ''{0}''
inspection.if.statement.missing.break.in.loop.description=滿足條件後，可以終止迴圈
inspection.if.statement.missing.break.in.loop.name=在 'if' 條件下提前離開迴圈
inspection.if.statement.missing.break.in.loop.quickfix=新增 'break'
inspection.incorrect.date.format.display.name=不正確的 'DateTimeFormat' 模式
inspection.incorrect.date.format.message.literal=左單引號({0})後未跟隨右單引號
inspection.incorrect.date.format.message.padding=沒有連續模式字母的填充修飾符 ''{0}''
inspection.incorrect.date.format.message.reserved.character=使用保留字元 ''{0}''
inspection.incorrect.date.format.message.unpaired=在沒有事先開啟 ''{0}'' 的情況下關閉 <code>\\#ref</code>
inspection.incorrect.date.format.message.unsupported=非法模式字母 ''{0}''
inspection.incorrect.date.format.too.few.letters=連續模式字母 ''{0}'' 過少；最小\\: {1}；指定\\: {2}
inspection.incorrect.date.format.too.many.letters=連續模式字母 ''{0}'' 過多；最大\\: {1}；指定\\: {2}
inspection.incorrect.date.format.wrong.number.of.letters=連續模式字母 ''{0}'' 的數量錯誤；允許\\: {1}；指定\\: {2}
inspection.incorrect.message.custom.classes.methods=自訂 MessageFormat 方法\\:
inspection.incorrect.message.format.choice.limit.incorrect=選擇模式中的下限 ''{0}'' 不正確
inspection.incorrect.message.format.choice.limit.not.found=選擇模式中的下限為空
inspection.incorrect.message.format.display.name='MessageFormat' 模式不正確
inspection.incorrect.message.format.incorrect.index=索引 ''{0}'' 不正確
inspection.incorrect.message.format.incorrect.order.choice=選擇模式中的下限未按升序排列
inspection.incorrect.message.format.incorrect.quotes.number=引號的數量可能不正確，將列印超過 1 個引號
inspection.incorrect.message.format.not.found.argument=索引 ''{0}'' 沒有實參''
inspection.incorrect.message.format.not.found.arguments=索引沒有實參\\: {0}
inspection.incorrect.message.format.not.used.argument=模式中未使用索引為 ''{0}'' 的實參
inspection.incorrect.message.format.pattern=訊息格式模式 ''{1}'' 中的 {0}
inspection.incorrect.message.format.quotes.around.parameter=佔位符 ''{0}'' 不會被取代，因為它包含在引號中
inspection.incorrect.message.format.unclosed.brace=未閉合的大括號
inspection.incorrect.message.format.unknown.format.type=未知格式類型 ''{0}''
inspection.incorrect.message.format.unmatched.brace=不符合的大括號
inspection.incorrect.message.format.unpaired.quote=訊息模式中不成對的引號
inspection.list.remove.in.loop.display.name=在迴圈中呼叫了 'List.remove()'
inspection.list.remove.in.loop.message=可被取代為 'List.subList().clear()'
inspection.lossy.conversion.compound.assignment.display.name=複合賦值中從 ''{0}'' 到 ''{1}'' 的隱式轉換可能是有損的
inspection.lossy.conversion.compound.assignment.name=複合賦值中可能存在有損隱式轉換
inspection.meta.annotation.without.runtime.description={0} 應具有 @Retention(RetentionPolicy.RUNTIME)
inspection.method.call.in.loop.ignore.known.methods.option=忽略有副作用的已知方法
inspection.new.object.equality.display.name=使用 '\\=\\=' 比較新物件
inspection.new.object.equality.message=使用 ''{0}'' 比較新物件
inspection.non.strict.comparison.equality.display.name=非嚴格不等式 '>\\=' 或 '<\\=' 可被取代為 '\\=\\='
inspection.non.strict.comparison.equality.message=可被取代為等式
inspection.note.may.change.semantics=可能更改語意
inspection.only.one.element.used.array=僅使用了一個陣列元素
inspection.only.one.element.used.display.name=僅使用了一個元素
inspection.only.one.element.used.fix.family=取代為已存取的元素
inspection.only.one.element.used.list=僅使用了一個列表元素
inspection.only.one.element.used.string=僅使用了一個字串字元
inspection.option.ignore.as.initial.capacity=忽略 StringBuilders 和 Collections 的初始容量
inspection.option.ignore.assert=對斷言語句描述實參忽略
inspection.option.ignore.constant.initializers=對常數欄位的初始設定式忽略
inspection.option.ignore.exceptions=對 Throwable 子類別的建構函式實參忽略
inspection.option.ignore.in.annotations=在註解中忽略
inspection.option.ignore.in.hashcode=忽略 'hashCode()' 方法中的常數
inspection.option.ignore.in.tostring=在 toString() 方法內部忽略
inspection.option.ignore.nonnls=通過 @NonNls 進行註解時忽略
inspection.option.ignore.system.err=對 'System.err.print' 實參忽略
inspection.option.ignore.system.out=對 'System.out.print' 實參忽略
inspection.pattern.variable.can.be.used.display.name=可以使用模式變數
inspection.pattern.variable.can.be.used.existing.cast.message=可以使用現有模式變數 ''{0}'' 代替轉換表達式
inspection.pattern.variable.can.be.used.existing.fix.family.name=取代為現有模式變數
inspection.pattern.variable.can.be.used.existing.fix.name=將 ''{0}'' 取代為現有模式變數 ''{1}''
inspection.pattern.variable.can.be.used.existing.message=可以使用現有模式變數 ''{0}'' 代替 ''{1}''
inspection.pattern.variable.can.be.used.fix.family.name=取代為模式變數
inspection.pattern.variable.can.be.used.fix.name=將 ''{0}'' 取代為模式變數
inspection.pattern.variable.can.be.used.instead.of.cast.message=轉換表達式可被取代為模式變數
inspection.pattern.variable.can.be.used.message=變數 ''{0}'' 可被取代為模式變數
inspection.pattern.variable.can.be.used.report.cast.only=報告可被取代為新引入的模式變數的轉換表達式
inspection.pattern.variable.instead.of.cast.can.be.used.existing.fix.name=將轉換表達式取代為現有模式變數 ''{0}''
inspection.pattern.variable.instead.of.cast.can.be.used.fix.family.name=將轉換表達式取代為模式變數
inspection.redundant.arguments.message=不必要的實參
inspection.redundant.class.call.display.name=冗餘的 'isInstance()' 或 'cast()' 呼叫
inspection.redundant.collection.operation.display.name=冗餘的 'Collection' 動作
inspection.redundant.collection.operation.fix.family.name=簡化集合動作
inspection.redundant.collection.operation.problem.arraycopy=為複製陣列而建立的集合不必要
inspection.redundant.collection.removal.by.index.fix=使用按物件移除
inspection.redundant.collection.removal.by.index.problem=按索引移除可被取代為按物件移除
inspection.redundant.collection.unnecessary.contains.fix=移除 ''{0}()'' 檢查
inspection.redundant.collection.unnecessary.contains.problem=不必要的 ''{0}()'' 檢查
inspection.redundant.compare.call.display.name=冗餘的 'compare()' 方法呼叫
inspection.redundant.compare.call.fix.name=內聯 'compare()' 呼叫
inspection.redundant.embedded.expression.display.name=字串模板中的冗餘嵌入式表達式
inspection.redundant.embedded.expression.fix.family.name=內聯嵌入式表達式
inspection.redundant.embedded.expression.message.empty=冗餘的空嵌入式表達式
inspection.redundant.embedded.expression.message.literal=冗餘的嵌入式字面量
inspection.redundant.empty.string.argument.message=不必要的空字串實參
inspection.redundant.explicit.variable.type.description=可以省略區域變數的顯式類型
inspection.redundant.java.time.operation.compare.java.time.family.name=使用 'java.time' 'compareTo()' 呼叫簡化表達式
inspection.redundant.java.time.operation.compare.java.time.problem.descriptor=帶有 'java.time' <code>\\#ref()</code> 呼叫的表達式可以簡化
inspection.redundant.java.time.operation.creation.java.time.error.message=''{0}'' 物件的冗餘建立
inspection.redundant.java.time.operation.creation.java.time.error.remove.fix.message=移除 ''{0}'' 呼叫
inspection.redundant.java.time.operation.creation.java.time.error.replace.fix.message=取代為 ''{0}'' 呼叫
inspection.redundant.java.time.operation.creation.java.time.family.name=簡化 'java.time' 物件的建立
inspection.redundant.java.time.operation.creation.java.time.redundant.call.message=冗餘的 ''{0}'' 呼叫
inspection.redundant.java.time.operation.creation.java.time.remove.family.name=移除不必要的呼叫
inspection.redundant.java.time.operation.display.name='java.time' 物件上的冗餘動作
inspection.redundant.java.time.operation.explicit.chrono.field.family.name=簡化帶有顯式 'ChronoField' 或 'ChronoUnit' 實參的呼叫
inspection.redundant.java.time.operation.explicit.chrono.field.problem.descriptor=帶有顯式 'ChronoField' 或 'ChronoUnit' 實參的呼叫可以簡化
inspection.redundant.length.check.display.name=冗餘的陣列長度檢查
inspection.redundant.string.call.message=<code>\\#ref()</code> 的呼叫冗餘 \\#loc
inspection.redundant.string.constructor.message=<code>new \\#ref()</code> 冗餘 \\#loc
inspection.redundant.string.fix.family.name=移除冗餘呼叫
inspection.redundant.string.fix.remove.str.processor.description=字串模板可以轉換為普通字串字面量
inspection.redundant.string.intern.on.constant.message=編譯時常量上 <code>\\#ref()</code> 的呼叫不必要 \\#loc
inspection.redundant.string.length.argument.message=不必要的字串長度實參
inspection.redundant.string.new.array.message=<code>\\#ref</code> 冗餘 \\#loc
inspection.redundant.string.operation.display.name=冗餘的 'String' 動作
inspection.redundant.string.option.do.not.report.single.argument.substring=不報告冗餘的單實參 substring() 呼叫
inspection.redundant.string.option.do.not.report.string.constructors=不報告 String 建構函式呼叫
inspection.redundant.string.remove.argument.fix.name=移除實參
inspection.redundant.string.replace.with.arg.fix.name=取代為實參
inspection.redundant.string.replace.with.empty.fix.name=取代為空字串
inspection.redundant.zero.argument.message=不必要的零實參
inspection.refused.bequest.super.annotated.option=僅在通過以下方式註解 super 方法時報告\\:
inspection.remove.redundant.call.fix.name=移除冗餘的 ''{0}()'' 呼叫
inspection.replace.on.literal.display.name=取代動作不起任何作用
inspection.simplifiable.if.statement.display.name='if' 語句可被取代為條件或布爾表達式
inspection.simplifiable.if.statement.fix.family.name=將 'if else' 取代為條件運算符
inspection.simplifiable.if.statement.fix.name=將 ''if else'' 取代為 ''{0}''
inspection.simplifiable.if.statement.message=If 語句可被取代為 ''{0}''
inspection.simplifiable.if.statement.option.dont.warn.on.ternary=不建議使用 '?\\:' 運算符
inspection.suspicious.date.format.display.name=可疑的日期格式模式
inspection.suspicious.date.format.message.lower=使用了小寫 ''{0}'' ({1}) 模式\\: 預期可能為 ''{2}'' ({3})
inspection.suspicious.date.format.message.upper=使用了大寫 ''{0}'' ({1}) 模式\\: 預期可能為 ''{2}'' ({3})
inspection.suspicious.package.private.access.description={0} 是 {1}，但在不同的模組 ''{2}'' 中宣告
inspection.suspicious.package.private.access.from.tests.description={0} 是 {1} 且在測試中使用，但在生產源中宣告
inspection.suspicious.package.private.access.from.tests.problem=測試中的 {0} 重寫了生產源中宣告的 {1} 中的 package-private 方法
inspection.suspicious.package.private.access.problem={0} 重寫了來自在不同模組 ''{2}'' 中宣告的 {1} 的 package-private 方法
inspection.test.method.without.assertion.list.name=斷言方法\\:
inspection.test.method.without.assertions.exceptions.option=忽略宣告異常的測試方法
inspection.trivial.functional.expression.usage.description=可以簡化方法呼叫
inspection.type.may.be.weakened.add.stop.class.family=新增停止類別
inspection.type.may.be.weakened.add.stop.class.selection.popup=選擇停止類別
inspection.type.may.be.weakened.add.stop.class.selection.table=停止類別
inspection.type.may.be.weakened.add.stop.class.selection.table.label=停止類別\\:
inspection.type.may.be.weakened.add.stopper=作為停止類別添加以減弱
inspection.type.may.be.weakened.add.stopper.preview=停止類別將被新增到此檢查的停止類別列表中。
inspection.type.may.be.weakened.add.stopper.single=新增 {0} 作為停止類別以削弱
inspection.type.may.be.weakened.display.name=類型可能被削弱
inspection.type.may.be.weakened.do.not.weaken.inferred.variable.type=不建議削弱宣告為 'var' 的變數
inspection.type.may.be.weakened.field.problem.descriptor=欄位 <code>\\#ref</code> 的類型可能被削弱為 {0} \\#loc
inspection.type.may.be.weakened.method.problem.descriptor=方法 <code>\\#ref()</code> 的返回值類型可能被削弱為 {0} \\#loc
inspection.type.may.be.weakened.only.weaken.to.an.interface=僅削弱為接口
inspection.type.may.be.weakened.parameter.problem.descriptor=參數 <code>\\#ref</code> 的類型可能被削弱為 {0} \\#loc
inspection.type.may.be.weakened.problem.descriptor=變數 <code>\\#ref</code> 的類型可能被削弱為 {0} \\#loc
inspection.type.may.be.weakened.quickfix=將類型削弱為 ''{0}''
inspection.type.may.be.weakened.weaken.type.family=削弱類型
inspection.unnecessary.string.escape.report.char.literals.option=報告字元字面量
inspection.unsupported.chrono.field.unit.call.display.name=使用不受支援的 'java.time.temporal.ChronoUnit' 和 'java.time.temporal.ChronoField' 呼叫方法
inspection.unsupported.chrono.value.message=不支持的實參值\\: {0}
inspection.unsupported.chrono.values.message=不支持的實參值\\: {0}
inspection.use.of.private.field.inner.classes.option=忽略來自內部類別的存取
inspection.use.of.slash.s.display.name='\\\\s' 轉義序列的非終止使用
inspection.use.of.slash.s.fix.family=將 '\\\\s' 序列取代為空格
inspection.use.of.slash.s.message=使用轉義序列 '\\\\s' 作為非尾隨空格
inspection.use.of.slash.s.non.text.block.message=在文本塊之外使用轉義序列 '\\\\s'
inspection.while.can.be.replaced.with.do.while.display.name='while' 可被取代為 'do while'
inspection.while.can.be.replaced.with.do.while.family.name=將 'while' 取代為 'do while'
inspection.while.can.be.replaced.with.do.while.message=將 'while' 取代為 'do while'
inspection.x.call.can.be.replaced.with.y=<code>\\#ref()</code> 呼叫可被取代為 ''{0}()''
instance.Variable.may.not.be.initialized.problem.descriptor.junit=實例欄位 <code>\\#ref</code> 在物件建構或 'setUp()' 呼叫期間可能無法初始化 \\#loc
instance.method.naming.convention.element.description=實例方法
instance.variable.may.not.be.initialized.display.name=實例欄位可能無法初始化
instance.variable.may.not.be.initialized.problem.descriptor=實例欄位 <code>\\#ref</code> 在物件建構期間可能無法初始化 \\#loc
instance.variable.naming.convention.element.description=實例欄位
instance.variable.of.concrete.class.problem.descriptor=具體類別 <code>\\#ref</code> 的實例欄位 ''{0}'' \\#loc
instance.variable.used.before.initialized.display.name=實例欄位在初始化前使用
instance.variable.used.before.initialized.problem.descriptor=初始化前使用的實例欄位 <code>\\#ref</code> \\#loc
instanceof.catch.parameter.display.name='catch' 參數上的 'instanceof'
instanceof.catch.parameter.problem.descriptor='catch' 參數 <code>\\#ref</code> 上的 'instanceof' \\#loc
instanceof.check.for.this.display.name='this' 的 'instanceof' 檢查
instanceof.check.for.this.equality.problem.descriptor='this' 的類別比較 \\#loc
instanceof.check.for.this.problem.descriptor=<code>\\#ref</code> 的 'instanceof' 檢查 \\#loc
instanceof.concrete.class.equality.problem.descriptor=與具體類別 <code>\\#ref</code> 的類別比較 \\#loc
instanceof.concrete.class.pattern.problem.descriptor=針對具體類別 <code>\\#ref</code> 的模式測試 \\#loc
instanceof.concrete.class.problem.descriptor='instanceof' 具體類別 <code>\\#ref</code> \\#loc
instanceof.with.incompatible.interface.display.name=具有不相容類型的 'instanceof'
instanceof.with.incompatible.interface.problem.descriptor=類型為 ''{1}'' 的表達式中具有不相容{0, choice, 1\\#接口|2\\#類別}的 ''instanceof'' <code>\\#ref</code> \\#loc
instantiating.datetimeformatter.without.locale.problem.descriptor=在未在國際化上下文中指定區域設定的情況下呼叫 <code>DateTimeFormatter.\\#ref()</code> \\#loc
instantiating.object.to.get.class.object.display.name=實例化物件以獲取 'Class' 物件
instantiating.object.to.get.class.object.problem.descriptor=實例化物件以獲取類別物件 \\#loc
instantiating.object.to.get.class.object.replace.quickfix=取代為直接類別物件存取
instantiating.simpledateformat.without.locale.display.name=無區域設定的 'SimpleDateFormat'
instantiating.simpledateformat.without.locale.problem.descriptor=在未在國際化上下文中指定區域設定的情況下實例化 <code>\\#ref</code> \\#loc
instantiation.utility.class.display.name=實用程序類別的實例化
instantiation.utility.class.problem.descriptor=實用程序類別 <code>\\#ref</code> 的實例化 \\#loc
int.literal.may.be.long.literal.display.name=轉換為 'long' 可以是 'long' 字面量
int.literal.may.be.long.literal.problem.descriptor=<code>\\#ref</code> 可被取代為 ''{0}'' \\#loc
integer.division.in.floating.point.context.display.name=浮點上下文中的整數除法
integer.division.in.floating.point.context.fix.family.name=將分子轉換為浮點類型
integer.division.in.floating.point.context.fix.name=將分子轉換為 ''{0}''
integer.division.in.floating.point.context.problem.descriptor=<code>\\#ref</code>\\: 浮點上下文中的整數除法 \\#loc
integer.multiplication.implicit.cast.to.long.display.name=整數乘法或移位隱式轉換為 'long'
integer.multiplication.implicit.cast.to.long.option=<html>忽略靜態證明不可能溢出的表達式</html>
integer.multiplication.implicit.cast.to.long.problem.descriptor=\\#ref\\: 整數乘法隱式轉換為 long \\#loc
integer.multiplication.implicit.cast.to.long.quickfix=轉換為 long
integer.shift.implicit.cast.to.long.problem.descriptor=\\#ref\\: 整數移位隱式轉換為 long \\#loc
interface.clashes.with.object.class.display.name=接口方法與 'Object' 中的方法衝突
interface.clashes.with.object.class.problem.descriptor=<code>\\#ref()</code> 與 'java.lang.Object' 中的方法衝突
interface.may.be.annotated.functional.display.name=接口可以註解為 '@FunctionalInterface'
interface.may.be.annotated.functional.problem.descriptor=接口 <code>\\#ref</code> 可以使用 @FunctionalInterface 註解
interface.naming.convention.element.description=接口
interface.never.implemented.display.name=沒有具體子類別的接口
interface.never.implemented.option=忽略僅宣告常數的接口
interface.never.implemented.problem.descriptor=接口 <code>\\#ref</code> 沒有具體子類別 \\#loc
interface.one.inheritor.display.name=只有一個直接繼承者的接口
interface.one.inheritor.problem.descriptor=只有一個直接繼承者的接口 <code>\\#ref</code> \\#loc
introduce.holder.class.quickfix=引入 holder 類別
introduce.variable.may.change.semantics.quickfix=引入變數 (可能更改語意)
introduce.variable.quickfix=引入變數
invert.method.quickfix=反轉方法
invert.quickfix=反轉 ''{0}''
invert.quickfix.family.name=反轉布爾
iterator.hasnext.which.calls.next.display.name=呼叫 'next()' 的 'Iterator.hasNext()'
iterator.hasnext.which.calls.next.problem.descriptor=<code>Iterator.{0}()</code> 包含 ''\\#ref()'' 呼叫 \\#loc
iterator.next.does.not.throw.nosuchelementexception.display.name=無法拋出 'NoSuchElementException' 的 'Iterator.next()'
iterator.next.does.not.throw.nosuchelementexception.problem.descriptor=無法拋出 'NoSuchElementException' 的 <code>Iterator.\\#ref()</code> '\\#loc
java.lang.import.display.name='java.lang' 軟體套件中有不必要的 import
java.lang.import.problem.descriptor='java.lang' 軟體套件中有不必要的 import \\#loc
jdbc.execute.with.non.constant.string.display.name='Statement.execute()' 呼叫具有非常數字串
jdbc.execute.with.non.constant.string.problem.descriptor=<code>Statement.\\#ref()</code> 呼叫具有非常數實參 \\#loc
jdbc.prepare.statement.with.non.constant.string.display.name='Connection.prepare*()' 呼叫具有非常數字串
jdbc.prepare.statement.with.non.constant.string.problem.descriptor=<code>Connection.\\#ref()</code> 呼叫具有非常數實參 \\#loc
jdbc.resource.opened.not.closed.display.name=JDBC 資源已開啟，但未安全關閉
jndi.resource.opened.not.closed.display.name=JNDI 資源已開啟，但未安全關閉
junit.abstract.test.class.naming.convention.element.description=抽象測試類別
junit.test.class.naming.convention.element.description=測試類別
junit.test.suite.naming.convention.element.description=測試套件
junit3.method.naming.convention.element.description=JUnit 3 測試方法
junit4.method.naming.convention.element.description=JUnit 4+ 測試方法
key.set.iteration.may.use.entry.set.display.name=可以最佳化對 'keySet()' 的迭代
key.set.iteration.may.use.entry.set.problem.descriptor=<code>\\#ref</code> 上的迭代可被取代為 ''{0}'' 迭代 \\#loc
key.set.iteration.may.use.entry.set.quickfix=最佳化 Map 迭代
labeled.statement.display.name=標記語句
labeled.statement.problem.descriptor=標記語句 <code>\\#ref\\:</code> \\#loc
lambda.body.can.be.code.block.name=lambda 體可以是程式碼塊
lambda.body.can.be.code.block.quickfix=將 lambda 體擴展為 {...}
lambda.can.be.replaced.with.anonymous.name=lambda 可被取代為匿名類別
lambda.can.be.replaced.with.anonymous.quickfix=將 lambda 取代為匿名類別
lambda.parameter.hides.member.variable.display.name=lambda 參數隱藏欄位
lambda.parameter.hides.member.variable.ignore.invisible.option=忽略從 lambda 實際不可見的欄位
lambda.parameter.hides.member.variable.problem.descriptor=lambda 參數 <code>\\#ref</code> 隱藏類別 ''{0}'' 中的欄位 \\#loc
lambda.parameter.naming.convention.display.name=lambda 參數命名約定
lambda.parameter.naming.convention.element.description=lambda 參數
lambda.parameter.type.can.be.specified.descriptor=Lambda 參數類型可以擴展為{0}
lambda.parameter.type.can.be.specified.family.quickfix=指定 lambda 參數類型
lambda.parameter.type.can.be.specified.name=可以指定 lambda 參數類型
lambda.parameter.type.can.be.specified.quickfix=將參數類型擴展為{0}
lambda.unfriendly.constructor.overload.problem.descriptor=建構函式 <code>\\#ref()</code> 的多載對 lambda 不友好
lambda.unfriendly.method.overload.display.name=方法多載對 lambda 不友好
lambda.unfriendly.method.overload.problem.descriptor=方法 <code>\\#ref()</code> 的多載對 lambda 不友好
large.array.allocation.no.outofmemoryerror.display.name=沒有 OutOfMemoryError 檢查的大型陣列分配
large.array.allocation.no.outofmemoryerror.maximum.number.of.elements.option=最大元素數\\:
large.array.allocation.no.outofmemoryerror.problem.descriptor=未檢查記憶體不足情況的大型陣列分配 \\#loc
large.initializer.primitive.type.array.display.name=原始類型陣列的過大初始設定式
large.initializer.primitive.type.array.maximum.number.of.elements.option=最大元素數\\:
large.initializer.primitive.type.array.problem.descriptor=具有太多元素 ({0}) 的原始陣列初始設定式 \\#loc
law.of.demeter.display.name=迪米特法則
law.of.demeter.field.problem.descriptor=對 <code>\\#ref()</code> 的存取違反迪米特法則 \\#loc
law.of.demeter.ignore.library.calls.option=忽略對庫方法的呼叫和對庫欄位的存取
law.of.demeter.problem.descriptor=對 <code>\\#ref()</code> 的呼叫違反迪米特法則 \\#loc
length.one.string.in.indexof.display.name='String.indexOf()' 呼叫中的單字元字串實參
length.one.strings.in.concatenation.display.name=單字元字串串聯
length.one.strings.in.concatenation.replace.quickfix=取代為字元
limited.scope.inner.class.display.name=區域類別
limited.scope.inner.class.problem.descriptor=區域類別 <code>\\#ref</code> \\#loc
list.indexof.replaceable.by.contains.display.name='List.indexOf()' 表達式可被取代為 'contains()'
listener.may.use.adapter.display.name=類別可以擴展適配器而不是實作偵聽器
listener.may.use.adapter.emtpy.methods.option=僅在找到空實作方法時發出警告(&O)
listener.may.use.adapter.fix.family.name=取代為適配器
listener.may.use.adapter.problem.descriptor=類別 ''{0}'' 可以擴展 ''{1}'' 而不是實作 <code>\\#ref</code> \\#loc
literal.as.arg.to.string.equals.display.name=字串字面量可以為 'equals()' 限定符
literal.as.arg.to.string.equals.flip.quickfix=翻轉 ''{0}()''
literal.as.arg.to.string.equals.problem.descriptor=字面量 \\#ref 是 ''{0}()'' 的實參，而不是其限定符 \\#loc
load.library.with.non.constant.string.display.name='System.loadLibrary()' 呼叫具有非常數字串
load.library.with.non.constant.string.problem.descriptor=<code>{0}.\\#ref()</code> 呼叫具有非常數實參 \\#loc
local.variable.hides.member.variable.display.name=區域變數隱藏欄位
local.variable.hides.member.variable.ignore.option=忽略隱藏非 static 欄位的 static 上下文中的區域變數
local.variable.hides.member.variable.problem.descriptor=區域變數 <code>\\#ref</code> 隱藏類別 ''{0}'' 中的欄位 \\#loc
local.variable.naming.convention.display.name=區域變數命名約定
local.variable.naming.convention.element.description=區域變數
local.variable.naming.convention.ignore.catch.option=忽略 'catch' 塊參數
local.variable.naming.convention.ignore.option=忽略 for 迴圈參數
local.variable.of.concrete.class.problem.descriptor=具體類別 <code>\\#ref</code> 的區域變數 ''{0}'' \\#loc
log.condition.text=日誌條件文本
log.method.name=記錄方法名稱
log.statement.guarded.by.log.condition.display.name=日誌呼叫不受日誌條件保護
log.statement.guarded.by.log.condition.flag.all.unguarded.option=標記所有不受保護的日誌呼叫
log.statement.guarded.by.log.condition.problem.descriptor=<code>\\#ref()</code> 日誌呼叫不受日誌條件保護 \\#loc
log.statement.guarded.by.log.condition.quickfix=使用日誌條件包圍
log4j.use.parameterized.logger=對於 Log4j 2，請使用與參數化記錄器相同的修正
log4j.use.parameterized.logger.description=對於 Log4j 2，如果類型無法推斷，請使用與參數化記錄器相同的修正；否則，將不會建議修正
logger.class.name=記錄器類別名\\:
logger.factory.class.name=記錄器工廠類別名
logger.factory.method.name=記錄器工廠方法名稱
logger.initialized.with.foreign.class.display.name=使用外類別初始化記錄器
logger.initialized.with.foreign.class.fix.family.name=取代外類別
logger.initialized.with.foreign.class.ignore.non.public.classes.option=忽略非 public 類別中的記錄器
logger.initialized.with.foreign.class.ignore.not.final.field=忽略未在 final 欄位中初始化的記錄器
logger.initialized.with.foreign.class.ignore.super.class.option=忽略使用超類別初始化的記錄器
logger.initialized.with.foreign.class.problem.descriptor=使用外類別 <code>\\#ref</code> 初始化記錄器 \\#loc
logger.name.option=記錄器類別名(&C)\\:
long.literals.ending.with.lowercase.l.display.name='long' 字面量以 'l' 而不是 'L' 結尾
long.literals.ending.with.lowercase.l.problem.descriptor='long' 字面量 <code>\\#ref</code> 以小寫 'l' 結尾 \\#loc
loop.condition.not.updated.inside.loop.display.name=迴圈變數未在迴圈內更新
loop.condition.not.updated.inside.loop.problem.descriptor=條件 '\\#ref' 未在迴圈內更新\\#loc
loop.statements.that.dont.loop.display.name=不迴圈的迴圈語句
loop.statements.that.dont.loop.problem.descriptor=<code>\\#ref</code> 語句未迴圈 \\#loc
loop.variable.not.updated.inside.loop.option.nonlocal=忽略可能的非本地更改
loop.variable.not.updated.inside.loop.problem.descriptor=變數 '\\#ref' 未在迴圈內更新\\#loc
loop.with.implicit.termination.condition.display.name=具有隱式終止條件的迴圈
loop.with.implicit.termination.condition.dowhile.problem.descriptor=具有隱式終止條件的 <code>\\#ref-while</code> 迴圈 \\#loc
loop.with.implicit.termination.condition.problem.descriptor=具有隱式終止條件的 <code>\\#ref</code> 迴圈 \\#loc
loop.with.implicit.termination.condition.quickfix=使條件顯式
magic.character.display.name=魔幻字元
magic.character.problem.descriptor=國際化上下文中使用的魔幻字元 <code>\\#ref</code> \\#loc
magic.number.display.name=幻數
magic.number.problem.descriptor=幻數 <code>\\#ref</code> \\#loc
make.class.final.fix.family.name=將類別設為 final
make.class.final.fix.name=將類別 ''{0}'' 設為 ''final''
make.constructor.public=將建構函式設為 'public'
make.field.final.fix.family.name=設為 final
make.field.final.quickfix=將 ''{0}'' 設為 ''final''
make.field.static.final.fix.family.name=設為 static final
make.initialization.explicit.quickfix=使初始化顯式
make.method.ctr.quickfix=使方法成為建構函式
make.method.final.fix.family.name=將方法設為 'final'
make.method.final.fix.name=將方法 ''{0}()'' 設為 ''final''
make.package.private.fix.family.name=設為 package-private
make.static.final.quickfix=將 ''{0}'' 設為 static final
make.static.quickfix=設為 'static'
malformed.format.string.display.name=字串的格式錯誤
malformed.format.string.problem.descriptor.arguments.do.not.match.type=實參類型 ''{0}'' 與格式說明符 ''{1}'' 的類型不符合 \\#loc
malformed.format.string.problem.descriptor.at.least.too.few.arguments=格式字串的實參過少(實際\\: {0}，至少應為\\: {1}) \\#loc
malformed.format.string.problem.descriptor.illegal=非法格式字串指定符\\: {0} \\#loc
malformed.format.string.problem.descriptor.malformed=格式字串 <code>\\#ref</code> 的格式錯誤 \\#loc
malformed.format.string.problem.descriptor.too.few.arguments=格式字串的實參太少(實際\\: {0}，應為\\: {1}) \\#loc
malformed.format.string.problem.descriptor.too.many.arguments=格式字串的實參太多(實際\\: {0}，應為\\: {1}) \\#loc
manual.array.copy.display.name=手動陣列複製
manual.array.copy.problem.descriptor=手動陣列複製 \\#loc
manual.array.to.collection.copy.display.name=手動陣列到集合複製
manual.array.to.collection.copy.problem.descriptor=手動陣列到集合複製 \\#loc
map.replaceable.by.enum.map.display.name='Map' 可被取代為 'EnumMap'
map.replaceable.by.enum.map.problem.descriptor=<code>\\#ref</code> 可被取代為 'EnumMap' \\#loc
markdown.documentation.comments.migration.display.name=Javadoc 註釋可以是 Markdown 文檔註釋
markdown.documentation.comments.migration.fix=轉換為 Markdown 文檔註釋
marker.interface.display.name=標記接口
marker.interface.problem.descriptor=標記接口 <code>\\#ref</code> \\#loc
masked.assertion.display.name=斷言通過 'catch' 禁止
masked.assertion.problem.description=''{0}'' 不能失敗，因為它被包圍 ''catch'' 禁止
math.random.cast.to.int.display.name='Math.random()' 轉換為 'int'
math.random.cast.to.int.problem.descriptor=<code>\\#ref</code> 轉換為 ''{0}'' 時始終向下舍入為 ''0'' \\#loc
math.random.cast.to.int.quickfix=新增括號以在轉換前執行乘法
math.rounding.with.int.argument.display.name=使用 'int' 實參呼叫數學舍入
math.rounding.with.int.argument.family.name=簡化舍入呼叫
math.rounding.with.int.argument.problem.descriptor=帶有 'int' 類型實參的 <code>\\#ref()</code> \\#loc
math.rounding.with.int.argument.quickfix=簡化 ''{0}()'' 呼叫
meta.annotation.without.runtime.retention=不含 '@Retention(RUNTIME)' 註解的測試註解
method.call.in.loop.condition.display.name=迴圈條件下的方法呼叫
method.call.in.loop.condition.problem.descriptor=迴圈條件下呼叫方法 <code>\\#ref()</code> \\#loc
method.can.be.variable.arity.method.display.name=方法可以有 varargs 參數
method.can.be.variable.arity.method.ignore.all.primitive.arrays.option=忽略所有原始陣列類型
method.can.be.variable.arity.method.ignore.byte.short.option=忽略具類型為 byte[] 或 short[] 的參數
method.can.be.variable.arity.method.ignore.multidimensional.arrays.option=忽略多維陣列參數
method.can.be.variable.arity.method.ignore.multiple.arrays.option=忽略具有多個陣列參數的方法
method.can.be.variable.arity.method.problem.descriptor=<code>\\#ref()</code> 可以轉換為 vararg 方法 \\#loc
method.complexity.limit.option=方法復雜度限制\\:
method.count.ignore.getters.setters.option=忽略簡單的 getter 和 setter 方法(&I)
method.count.limit.option=方法計數限制\\:
method.coupling.display.name=過度耦合的方法
method.coupling.limit.option=方法耦合限制\\:
method.coupling.problem.descriptor=<code>\\#ref</code> 過度耦合 (\\# 參照的類別 \\= {0}) \\#loc
method.may.be.static.display.name=方法可以為 'static'
method.may.be.static.empty.option=忽略空方法
method.may.be.static.ignore.default.methods.option=忽略 'default' 方法
method.may.be.static.only.option=僅檢查 'private' 或 'final' 方法
method.may.be.static.problem.descriptor=方法 <code>\\#ref()</code> 可能為 'static' \\#loc
method.may.be.static.replaces.qualifiers.with.class.references.option=快速修復可將實例限定符取代為類別參照
method.may.be.synchronized.display.name=只有一個 'synchronized' 塊的方法可被取代為 'synchronized' 方法
method.may.be.synchronized.problem.descriptor=帶 synchronized 塊的方法 <code>\\#ref()</code> 可以是 synchronized 方法 \\#loc
method.may.be.synchronized.quickfix=將方法設為 synchronized 並移除 synchronized 塊
method.name.regex=方法名稱正則表達式
method.name.same.as.class.name.display.name=方法名稱與類別名相同
method.name.same.as.class.name.problem.descriptor=方法名稱 <code>\\#ref</code> 與其類別名相同 \\#loc
method.name.same.as.parent.name.display.name=方法名稱與父類別名相同
method.name.same.as.parent.name.problem.descriptor=方法名稱 <code>\\#ref</code> 與其父類別名相同 \\#loc
method.names.differ.only.by.case.display.name=方法名稱僅大小寫不同
method.names.differ.only.by.case.problem.descriptor=方法名稱 <code>\\#ref</code> 和方法名稱 ''{0}'' 僅大小寫不同 \\#loc
method.only.used.from.inner.class.display.name=僅在內部類中使用 private 方法
method.only.used.from.inner.class.ignore.option=忽略從匿名類別或區域類別呼叫的方法(&A)
method.only.used.from.inner.class.problem.descriptor=方法 <code>\\#ref()</code>\\#loc 只能從{0, choice, 1\\#內部|2\\#區域|3\\#}{1, choice, 1\\#類別|2\\#接口|3\\#派生的匿名類別|4\\#註解類型|5\\#枚舉|6\\#記錄} ''{2}'' 使用 \\#loc
method.overloads.display.name=可能是超類別方法意外多載
method.overloads.problem.descriptor=當可能打算覆寫時，方法 <code>\\#ref()</code> 多載超類別的相容方法 \\#loc
method.overloads.report.incompatible.option=即使參數類型不相容，也會報告
method.overrides.inaccessible.method.display.name=方法覆寫了超類別不可存取的方法
method.overrides.package.local.method.problem.descriptor=方法 <code>\\#ref()</code> 覆寫了位於另一個軟體套件中的超類別的 package-private 方法 \\#loc
method.overrides.private.display.name.problem.descriptor=方法 <code>\\#ref()</code> 重寫了超類別的 'private' 方法 \\#loc
method.overrides.static.display.name=方法嘗試覆寫超類別的 'static' 方法
method.overrides.static.problem.descriptor=方法 <code>\\#ref()</code> 嘗試覆寫超類別的 static 方法 \\#loc
method.ref.can.be.replaced.with.lambda.name=方法參照可被取代為 lambda
method.ref.can.be.replaced.with.lambda.quickfix=將方法參照取代為 lambda
method.ref.can.be.replaced.with.lambda.quickfix.no.side.effects=將可能的副作用保留在 lambda 內部
method.ref.can.be.replaced.with.lambda.quickfix.side.effects=將可能的副作用提取到變數中
method.return.always.constant.display.name=方法返回類別特定的常數
method.return.always.constant.problem.descriptor=方法 <code>\\#ref()</code> 及其所有派生方法始終返回常數
method.return.concrete.class.problem.descriptor=方法返回一個具體類別 <code>\\#ref</code> \\#loc
method.with.multiple.loops.display.name=具有多個迴圈的方法
method.with.multiple.loops.problem.descriptor=<code>\\#ref</code> 包含 {0} 個迴圈 \\#loc
mismatched.read.write.array.display.name=陣列的讀取和寫入不符合
mismatched.read.write.array.problem.descriptor.read.not.write=陣列 <code>\\#ref</code> 的內容已讀取，但從未被寫入 \\#loc
mismatched.read.write.array.problem.descriptor.write.not.read=陣列 <code>\\#ref</code> 的內容已寫入，但從未被讀取 \\#loc
mismatched.string.builder.queried.problem.descriptor=<code>{0} \\#ref</code> 的內容已查詢，但從未更新 \\#loc
mismatched.string.builder.query.update.display.name='StringBuilder' 的查詢和更新不符合
mismatched.string.builder.updated.problem.descriptor=<code>{0} \\#ref</code> 的內容已更新，但從未被查詢 \\#loc
mismatched.update.collection.display.name=不符合的集合查詢和更新
mismatched.update.collection.problem.description.no.effect.updates=對空集合 <code>\\#ref</code> 進行的更新動作無效 \\#loc
mismatched.update.collection.problem.description.queried.empty=空集合 <code>\\#ref</code> 的內容已被查詢，但從未填充 \\#loc
mismatched.update.collection.problem.description.queried.not.updated=集合 <code>\\#ref</code> 的內容已被查詢，但從未更新 \\#loc
mismatched.update.collection.problem.description.updated.not.queried=集合 <code>\\#ref</code> 的內容已更新，但從未被查詢 \\#loc
misordered.assert.equals.arguments.display.name=順序錯誤的 'assertEquals()' 實參
misordered.assert.equals.arguments.flip.quickfix=翻轉比較實參
misordered.assert.equals.arguments.problem.descriptor=<code>\\#ref()</code> 的實參順序錯誤 \\#loc
missing.add.deprecated.javadoc.tag.quickfix=新增 '@deprecated' Javadoc 標記說明
missing.deprecated.annotation.add.quickfix=新增 '@Deprecated' 註解
missing.deprecated.annotation.display.name=缺少 '@Deprecated' 註解
missing.deprecated.annotation.problem.descriptor=缺少 '@Deprecated' 註解 \\#loc
missing.deprecated.tag.option=警告缺少 @deprecated Javadoc 標記說明
missing.deprecated.tag.problem.descriptor=缺少 '@deprecated' Javadoc 標記說明 \\#loc
missing.override.annotation.display.name=缺少 '@Override' 註解
missing.override.annotation.in.overriding.problem.descriptor=覆寫方法未使用 '@Override' 註解
missing.override.annotation.problem.descriptor=缺少關於 <code>\\#ref()</code> 的 '@Override' 註解 \\#loc
missing.override.warn.on.super.option=當方法的覆寫方法並非全部具有 '@Override' 註解時，醒目提示該方法
missing.package.html.problem.descriptor=軟體套件 ''{0}'' 缺少 <code>package.html</code> 檔案
missing.package.info.display.name=缺少 'package-info.java'
missing.package.info.problem.descriptor=軟體套件 ''{0}'' 缺少 <code>package-info.java</code> 檔案
missing.serial.annotation.display.name=可以使用 '@Serial' 註解
missing.serial.annotation.on.field.problem.descriptor=<code>\\#ref</code> 可以使用 '@Serial' 進行註解
missing.serial.annotation.on.method.problem.descriptor=<code>\\#ref()</code> 可以使用 '@Serial' 進行註解
missorted.modifiers.allowed.place=TYPE_USE 註解遵循生成選項
missorted.modifiers.allowed.place.description=啟用此選項時，如果目標 TYPE_USE 註解的位置不符合<pre>設定 | 編輯器 | 程式碼樣式 | Java | 程式碼生成</pre>中的 <pre>{0}</pre> 選項，將報告目標 TYPE_USE 註解。停用此選項時，目標 TYPE_USE 註解可以直接位於類型之前或修飾符關鍵字之前。
missorted.modifiers.display.name=錯位修飾符
missorted.modifiers.problem.descriptor=錯位修飾符 <code>{0}</code> \\#loc
missorted.modifiers.require.option=檢查註解順序
missorted.modifiers.require.option.description=使用此選項可以報告錯誤位置的註解\\: 帶有 <code>ElementType.TYPE_USE</code> 的註解<em>不</em>直接位於類型之前且位於修飾符關鍵字之後，或者其他註解<em>不</em>位於修飾符關鍵字之前。停用此選項時，註解可以位於修飾符關鍵字之前或之後。將始終報告位於修飾符關鍵字之間的註解。
missorted.modifiers.sort.quickfix=對修飾符排序
misspelled.equals.display.name='equal()' 代替 'equals()'
misspelled.equals.problem.descriptor=<code>\\#ref()</code> 方法可能應當是 'equals()' \\#loc
module.with.too.few.classes.display.name=類別過少的模組
module.with.too.few.classes.min.option=最小類別數\\:
module.with.too.few.classes.problem.descriptor=模組 ''{0}'' 包含過少的類別 ({1} < {2})
module.with.too.many.classes.display.name=類別過多的模組
module.with.too.many.classes.max.option=最大類別數\\:
module.with.too.many.classes.problem.descriptor=模組 ''{0}'' 包含過多的類別 ({1} > {2})
move.anonymous.to.inner.quickfix=轉換為命名內部類別
move.class.quickfix=移動類別
move.exception.to.javadoc.fix.family.name=移至 Javadoc '@throws'
move.local.to.inner.quickfix=轉換為內部類別
multi.catch.can.be.split.name=多 catch 可拆分為單獨的 catch 塊
multi.catch.can.be.split.quickfix=將多 catch 拆分為單獨的 'catch' 塊
multiple.declaration.array.only.option=僅在單個宣告中對不同的陣列維度發出警告
multiple.declaration.display.name=一個宣告中的多個變數
multiple.declaration.ignore.for.option=忽略 'for' 迴圈宣告
multiple.declaration.problem.descriptor=一個宣告中的多個變數 \\#loc
multiple.loggers.display.name=具有多個記錄器的類別
multiple.loggers.problem.descriptor=類別 <code>\\#ref</code> 宣告多個記錄器 \\#loc
multiple.return.points.per.method.display.name=具有多個返回點的方法
multiple.return.points.per.method.problem.descriptor=<code>\\#ref</code> 具有 {0} 個返回點 \\#loc
multiple.top.level.classes.in.file.display.name=單個檔案中的多個頂級類別
multiple.top.level.classes.in.file.problem.descriptor=檔案中的多個頂級類別
multiple.typed.declaration.problem.descriptor=在一個宣告中具有不同陣列維度的變數 \\#loc
multiply.or.divide.by.power.of.two.display.name=乘以或除以 2 的冪
multiply.or.divide.by.power.of.two.divide.option=還通過 2 的冪檢查除法
multiply.or.divide.by.power.of.two.replace.quickfix=取代為移位
naked.notify.display.name=沒有相應狀態更改的 'notify()' 或 'notifyAll()'
naked.notify.problem.descriptor=在沒有相應狀態更改的情況下呼叫 <code>\\#ref()</code> \\#loc
naming.convention.problem.descriptor.long={0} 名稱 <code>\\#ref</code> 過長({1} > {2}) \\#loc
naming.convention.problem.descriptor.regex.mismatch={0} 名稱 <code>\\#ref</code> 不符合正則表達式 ''{1}'' \\#loc
naming.convention.problem.descriptor.short={0} 名稱 <code>\\#ref</code> 過短({1} < {2}) \\#loc
native.method.display.name=本地方法
native.method.naming.convention.element.description='native' 方法
native.method.problem.descriptor=宣告為 <code>\\#ref</code> 的方法不可移植 \\#loc
negated.conditional.display.name=具有否定條件的條件表達式
negated.conditional.expression.display.name=否定條件表達式
negated.conditional.expression.problem.descriptor=否定條件表達式 \\#loc
negated.conditional.expression.quickfix=移除否定
negated.conditional.invert.quickfix=反轉條件
negated.conditional.problem.descriptor=具有否定條件的條件表達式 \\#loc
negated.equality.expression.display.name=否定相等表達式
negated.equality.expression.problem.descriptor=否定 ''{0}'' \\#loc
negated.equality.expression.quickfix=移除否定
negated.if.else.display.name=具有否定條件的 'if' 語句
negated.if.else.ignore.negated.null.option=忽略 '\\!\\= null' 比較
negated.if.else.ignore.negated.zero.option=忽略 '\\!\\= 0' 比較
negated.if.else.invert.quickfix=反轉 'if' 條件
negated.if.else.problem.descriptor=帶嵌套條件的 <code>\\#ref</code> 語句 \\#loc
negative.int.constant.in.long.context.display.name=長整數型上下文中的負整數型十六進制常數
negative.int.constant.in.long.context.fix.add.suffix=新增 'L' 後綴(更改語意)
negative.int.constant.in.long.context.fix.convert=轉換為長整數型常數(保留語意)
negatively.named.boolean.variable.display.name=否定命名的布爾變數
negatively.named.boolean.variable.problem.descriptor=布爾變數 <code>\\#ref</code> 已否定命名 \\#loc
nested.assignment.display.name=嵌套賦值
nested.assignment.problem.descriptor=使用的賦值表達式的結果 \\#loc
nested.conditional.expression.display.name=嵌套條件表達式
nested.conditional.expression.problem.descriptor=嵌套條件表達式 <code>\\#ref</code> \\#loc
nested.method.call.display.name=嵌套方法呼叫
nested.method.call.ignore.option=忽略欄位初始設定式中的嵌套方法呼叫
nested.method.call.problem.descriptor=嵌套方法呼叫 <code>\\#ref()</code> \\#loc
nested.switch.statement.display.name=嵌套 'switch' 語句
nested.switch.statement.problem.descriptor=嵌套 <code>\\#ref</code> {0} \\#loc
nested.synchronized.statement.display.name=嵌套 'synchronized' 語句
nested.synchronized.statement.problem.descriptor=嵌套 <code>\\#ref</code> 語句 \\#loc
nested.try.statement.display.name=嵌套 'try' 語句
nested.try.statement.problem.descriptor=嵌套 <code>\\#ref</code> 語句 \\#loc
nesting.depth.display.name=過度嵌套的方法
nesting.depth.limit.option=嵌套深度限制\\:
nesting.depth.problem.descriptor=<code>\\#ref</code> 過度嵌套 (最大嵌套深度 \\= {0}) \\#loc
new.exception.without.arguments.display.name=未使用實參呼叫異常建構函式
new.exception.without.arguments.problem.descriptor=<code>new \\#ref()</code> 沒有實參 \\#loc
new.method.naming.convention.display.name=方法命名約定
new.string.buffer.replaceable.by.string.problem.descriptor=<code>\\#ref</code> 可被取代為 'String' \\#loc
new.string.buffer.with.char.argument.display.name=StringBuilder 建構函式呼叫具有 'char' 實參
new.string.buffer.with.char.argument.problem.descriptor=<code>new \\#ref()</code> 具有 'char' 類型的實參 \\#loc
new.string.buffer.with.char.argument.quickfix=將字元實參取代為字串字面量
no.logger.display.name=不帶記錄器的類別
no.logger.problem.descriptor=類別 <code>\\#ref</code> 未宣告記錄器 \\#loc
non.atomic.operation.on.volatile.field.display.name='volatile' 欄位上的非原子動作
non.atomic.operation.on.volatile.field.problem.descriptor=volatile 欄位 <code>\\#ref</code> 上的非原子動作 \\#loc
non.boolean.method.name.must.not.start.with.question.display.name=非布爾方法名稱不能以疑問詞開頭
non.boolean.method.name.must.not.start.with.question.problem.descriptor=非布爾方法名稱 <code>\\#ref</code> 以疑問詞開頭 \\#loc
non.comment.source.statements.display.name=過長的方法
non.comment.source.statements.limit.option=非註釋源語句限制\\:
non.comment.source.statements.problem.descriptor=<code>\\#ref</code> 過長 (\\# 非註釋源語句 \\= {0}) \\#loc
non.constant.logger.display.name=非常數記錄器
non.constant.logger.problem.descriptor=非常數記錄器欄位 <code>\\#ref</code> \\#loc
non.exception.name.ends.with.exception.display.name=非異常類別名以 'Exception' 結尾
non.exception.name.ends.with.exception.problem.descriptor=非異常類別名 <code>\\#ref</code> 以 'Exception' 結尾 \\#loc
non.exception.name.ends.with.exception.quickfix=使 ''{0}'' 擴展 ''java.lang.Exception''
non.final.clone.display.name=非 final 'clone()' 位於安全上下文中
non.final.clone.problem.descriptor=非 final <code>\\#ref()</code> 方法，影響安全性 \\#loc
non.final.field.compareto.display.name='compareTo()' 中參照了非 final 欄位
non.final.field.compareto.problem.descriptor=在 'compareTo()' 中存取了非 final 欄位 <code>\\#ref</code> \\#loc
non.final.field.in.enum.display.name='enum' 中的非 final 欄位
non.final.field.in.enum.problem.descriptor=枚舉 ''{0}'' 中存在非 final 欄位 <code>\\#ref</code> \\#loc
non.final.field.in.enum.quickfix.option=忽略無法成為 'final' 的欄位
non.final.field.in.equals.display.name='equals()' 中參照了非 final 欄位
non.final.field.in.equals.problem.descriptor=在 'equals()' 中存取了非 final 欄位 <code>\\#ref</code> \\#loc
non.final.field.in.hashcode.display.name='hashCode()' 中參照了非 final 欄位
non.final.field.in.hashcode.problem.descriptor=在 'hashCode()' 中存取了非 final 欄位 <code>\\#ref</code> \\#loc
non.final.field.of.exception.display.name='Exception' 類別的非 final 欄位
non.final.field.of.exception.problem.descriptor=異常類別的非 final 欄位 <code>\\#ref</code> \\#loc
non.final.static.variable.initialization.display.name=在類別初始化期間使用非 final static 欄位
non.final.static.variable.initialization.problem.descriptor=在類別初始化期間使用非 final static 欄位 <code>\\#ref</code> \\#loc
non.final.utility.class.display.name=實用程序類別不為 'final'
non.final.utility.class.problem.descriptor=實用程序類別 <code>\\#ref</code> 不為 'final' \\#loc
non.protected.constructor.in.abstract.class.display.name=抽象類別中的 public 建構函式
non.protected.constructor.in.abstract.class.ignore.option=對非 public 類別忽略
non.protected.constructor.in.abstract.class.problem.descriptor=抽象類別的建構函式 <code>\\#ref()</code> 不應宣告為 'public' \\#loc
non.public.clone.display.name='clone()' 方法不是 'public'
non.public.clone.problem.descriptor=<code>\\#ref()</code> 方法不是 'public' \\#loc
non.reproducible.math.call.display.name=對 'Math' 的不可重現呼叫
non.reproducible.math.call.problem.descriptor=<code>Math.\\#ref()</code> 可能產生不可重現的結果 \\#loc
non.reproducible.math.call.replace.quickfix=取代為 'StrictMath' 呼叫
non.serializable.@interface.with.serialversionuid.problem.descriptor=定義 'serialVersionUID' 欄位的不可序列化 @interface <code>\\#ref</code> \\#loc
non.serializable.anonymous.with.serialversionuid.problem.descriptor=派生自 <code>\\#ref</code> 的不可序列化匿名類別定義 'serialVersionUID' 欄位 \\#loc
non.serializable.class.with.readwriteobject.display.name=具有 'readObject()' 或 'writeObject()' 的不可序列化類別
non.serializable.class.with.readwriteobject.problem.descriptor.both=不可序列化{0, choice, 1\\#類別|2\\#接口|3\\#派生的匿名類別|4\\#註解類型|5\\#枚舉|6\\#記錄} <code>\\#ref</code> 定義 'readObject()' 和 'writeObject()' \\#loc
non.serializable.class.with.readwriteobject.problem.descriptor.read=不可序列化{0, choice, 1\\#類別|2\\#接口|3\\#派生的匿名類別|4\\#註解類型|5\\#枚舉|6\\#記錄} <code>\\#ref</code> 定義 'readObject()' \\#loc
non.serializable.class.with.readwriteobject.problem.descriptor.write=不可序列化{0, choice, 1\\#類別|2\\#接口|3\\#派生的匿名類別|4\\#註解類型|5\\#枚舉|6\\#記錄} <code>\\#ref</code> 定義 'writeObject()' \\#loc
non.serializable.class.with.serialversionuid.problem.descriptor=定義 'serialVersionUID' 欄位的不可序列化類別 <code>\\#ref</code> \\#loc
non.serializable.component.in.serializable.record.problem.descriptor=Serializable 記錄中存在非 Serializable 組件 '\\#ref' \\#loc
non.serializable.field.in.serializable.class.display.name='Serializable' 類別中有不可序列化的欄位
non.serializable.field.in.serializable.class.problem.descriptor=Serializable 類別中存在非 Serializable 欄位 '\\#ref' \\#loc
non.serializable.interface.with.serialversionuid.problem.descriptor=定義 'serialVersionUID' 欄位的不可序列化接口 <code>\\#ref</code> \\#loc
non.serializable.object.bound.to.http.session.display.name=不可序列化的物件被綁定到了 'HttpSession'
non.serializable.object.bound.to.http.session.problem.descriptor=傳遞給 HttpSession 的不可序列化物件 \\#loc
non.serializable.object.passed.to.object.stream.display.name=不可序列化的物件被傳遞給了 'ObjectOutputStream'
non.serializable.object.passed.to.object.stream.problem.descriptor=傳遞給 ObjectOutputStream 的不可序列化物件 \\#loc
non.serializable.with.serialversionuid.display.name=具有 'serialVersionUID' 的不可序列化類別
non.short.circuit.boolean.expression.display.name=非短路布爾表達式
non.short.circuit.boolean.expression.problem.descriptor=非短路布爾表達式 <code>\\#ref</code> \\#loc
non.short.circuit.boolean.expression.replace.quickfix=取代為短路表達式
non.synchronized.method.overrides.synchronized.method.display.name=未同步方法覆寫 'synchronized' 方法
non.synchronized.method.overrides.synchronized.method.problem.descriptor=未同步方法 <code>\\#ref()</code> 覆寫 synchronized 方法 \\#loc
non.thread.safe.lazy.initialization.display.name=不安全的 'static' 欄位延遲初始化
non.thread.safe.lazy.initialization.problem.descriptor='static' 欄位 <code>\\#ref</code> 的延遲初始化不是執行緒安全 \\#loc
none=無
noop.method.in.abstract.class.display.name='abstract' 類別中的無運算方法
noop.method.in.abstract.class.problem.descriptor=無動作方法 <code>\\#ref()</code> 應當設為 abstract \\#loc
normalize.declaration.quickfix=拆分為單獨的宣告
not.object.equals.can.be.equality.problem.descriptor=<code>\\!\\#ref()</code> 可被取代為 '\\!\\='
notify.called.on.condition.display.name=在 'java.util.concurrent.locks.Condition' 物件上呼叫了 'notify()' 或 'notifyAll()'
notify.called.on.condition.problem.descriptor=在條件物件上呼叫 <code>\\#ref()</code> \\#loc
notify.without.corresponding.wait.display.name=沒有相應 'wait()' 的 'notify()'
notify.without.corresponding.wait.problem.descriptor=在沒有相應 <code>wait()</code> 的情況下呼叫 <code>\\#ref()</code> \\#loc
null.argument.to.var.arg.method.display.name=引起混淆的 vararg 方法實參
null.argument.to.var.arg.method.problem.descriptor=引起混淆的實參 <code>\\#ref</code>，不清楚是否需要 vararg 或非 vararg 呼叫 \\#loc
null.thrown.display.name=已拋出 'null'
null.thrown.problem.descriptor=已拋出 <code>\\#ref</code> \\#loc
number.comparison.display.name=使用 '\\=\\=' 而不是 'equals()' 進行數字比較
number.comparison.problem.descriptor=使用 <code>\\#ref</code> 而不是 'equals()' 來比較數字物件 \\#loc
object.allocation.in.loop.display.name=迴圈中的物件分配
object.allocation.in.loop.new.descriptor=迴圈中的物件分配 <code>new \\#ref()</code> \\#loc
object.allocation.in.loop.problem.array.initializer.descriptor=迴圈中的陣列分配 \\#loc
object.allocation.in.loop.problem.call.descriptor=物件分配通過迴圈中的 <code>\\#ref()</code> 呼叫完成 \\#loc
object.allocation.in.loop.problem.lambda.descriptor=物件分配通過捕獲迴圈中的 lambda 完成 \\#loc
object.allocation.in.loop.problem.methodref.descriptor=物件分配通過迴圈中的實例綁定方法參照 <code>\\#ref()</code> 完成 \\#loc
object.allocation.in.loop.problem.string.concat=物件分配通過迴圈中的字串串聯完成 \\#loc
object.comparison.display.name=使用 '\\=\\=' 而不是 'equals()' 進行物件比較
object.comparison.enumerated.ignore.option=忽略枚舉變數之間的 '\\=\\='
object.comparison.klass.ignore.option=忽略沒有 'equals()' 實作的 final 類別類型之間的 '\\=\\='
object.comparison.problem.description=使用 <code>\\#ref</code> 而不是 'equals()' 來比較物件值 \\#loc
object.equality.ignore.between.objects.of.a.type.with.only.private.constructors.option=忽略只有 'private' 建構函式的類型物件之間的 '\\=\\='
object.equals.can.be.equality.display.name='equals()' 呼叫可被取代為 '\\=\\='
object.equals.can.be.equality.problem.descriptor=<code>\\#ref()</code> 可被取代為 '\\=\\='
object.instantiation.inside.equals.or.hashcode.display.name='equals()' 或 'hashCode()' 內部的物件實例化
object.instantiation.inside.equals.or.hashcode.problem.descriptor=''{0}()'' 內部的物件實例化 \\#loc
object.instantiation.inside.equals.or.hashcode.problem.descriptor2=''{0}()'' ({1}) 內部的物件實例化 \\#loc
object.notify.display.name=呼叫 'notify()' 而不是 'notifyAll()'
object.notify.problem.descriptor=<code>\\#ref</code> 可能應當取代為 'notifyAll()' \\#loc
objects.hash.fix.family.name=使用 'Arrays.hashCode()' 包裝
objects.hash.problem.descriptor=傳遞給 'Objects.hash()' 的陣列應包裝在 'Arrays.hashcode()' 中
octal.and.decimal.integers.in.same.array.display.name=同一陣列中的八進制和十進制整數
octal.and.decimal.integers.in.same.array.problem.descriptor=同一陣列初始設定式中的八進制和十進制整數 \\#loc
octal.literal.display.name=八進制整數
octal.literal.problem.descriptor=八進制整數 <code>\\#ref</code> \\#loc
only.report.public.methods.option=僅報告 'public' 方法
only.report.qualified.static.usages.option=僅報告來自 static 上下文的限定靜態存取
only.report.static.methods=僅報告 'static' 方法(&O)
only.warn.on.protected.clone.methods=僅對 'protected' 克隆方法發出警告
only.warn.on.public.clone.methods=僅對 'public' 克隆方法發出警告
optional.contains.array.problem.descriptor='Optional' 包含陣列 <code>\\#ref</code>
optional.contains.collection.display.name='Optional' 包含陣列或集合
optional.contains.collection.problem.descriptor='Optional' 包含集合 <code>\\#ref</code>
optional.used.as.field.or.parameter.type.display.name=用作欄位或參數類型的 'Optional'
optional.used.as.field.type.problem.descriptor=<code>\\#ref</code> 用作欄位 ''{0}'' 的類型
optional.used.as.parameter.type.problem.descriptor=<code>\\#ref</code> 用作參數 ''{0}'' 的類型
options.label.ignored.classes=已忽略的類別\\:
options.title.ignored.classes=已忽略的類別
overloaded.methods.with.same.number.parameters.display.name=具有相同參數數量的多載方法
overloaded.methods.with.same.number.parameters.option=<html>忽略參數類型絕對不相容的多載方法</html>
overloaded.methods.with.same.number.parameters.problem.descriptor=具有相同數量參數的多個方法命名 <code>\\#ref</code> \\#loc
overloaded.vararg.constructor.problem.descriptor=多載 vararg 建構函式 <code>\\#ref()</code> \\#loc
overloaded.vararg.method.display.name=多載 vararg 方法
overloaded.vararg.method.problem.descriptor=多載 vararg 方法 <code>\\#ref()</code> \\#loc
overloaded.vararg.method.problem.option=忽略參數類型絕對不相容的多載方法
overly.broad.throws.clause.display.name=過寬的 'throws' 子句
overly.broad.throws.clause.ignore.thrown.option=忽略隱藏其他異常但自身被拋出的異常(&H)
overly.broad.throws.clause.problem.descriptor1=<code>throws \\#ref</code> 過寬，遮罩異常 ''{0}'' \\#loc
overly.broad.throws.clause.problem.descriptor2=<code>throws \\#ref</code> 過寬，遮罩異常 ''{0}'' 和 ''{1}'' \\#loc
overly.broad.throws.clause.quickfix1=新增特定異常
overly.broad.throws.clause.quickfix2=取代為特定異常
overly.broad.throws.clause.threshold.option=要報告的最大隱藏異常數\\:
overly.complex.anonymous.inner.class.display.name=過度複雜的匿名類別
overly.complex.anonymous.inner.class.problem.descriptor=過度複雜的匿名類別 (迴圈復雜度 \\= {0}) \\#loc
overly.complex.arithmetic.expression.display.name=過於複雜的算術表達式
overly.complex.arithmetic.expression.max.number.option=最大項數\\:
overly.complex.arithmetic.expression.problem.descriptor=過於複雜的算術表達式 \\#loc
overly.complex.boolean.expression.display.name=過度複雜的布爾表達式
overly.complex.boolean.expression.ignore.option=忽略純合取和析取
overly.complex.boolean.expression.max.terms.option=最大項數\\:
overly.complex.boolean.expression.problem.descriptor=過度複雜的布爾表達式 ({0} 項) \\#loc
overly.complex.class.display.name=過度複雜的類別
overly.complex.class.problem.descriptor=過度複雜的類別<code>\\#ref</code> (迴圈復雜度 \\= {0}) \\#loc
overly.coupled.class.class.coupling.limit.option=類別耦合限制\\:
overly.coupled.class.display.name=過度耦合的類別
overly.coupled.class.problem.descriptor=<code>\\#ref</code> 過度耦合 (相依 \\= {0}) \\#loc
overly.long.lambda.display.name=過長的 lambda 表達式
overly.long.lambda.problem.descriptor=lambda 表達式過長 (\\# 非註釋源語句 \\= {0}) \\#loc
overly.strong.type.cast.display.name=過強的類型轉換
overly.strong.type.cast.ignore.in.matching.instanceof.option=忽略具有符合 instanceof 表達式的轉換
overly.strong.type.cast.problem.descriptor=到 <code>\\#ref</code> 的轉換可以被削弱為 ''{0}'' \\#loc
overly.strong.type.cast.weaken.quickfix=削弱過強的轉換
overridable.method.call.in.constructor.display.name=物件建構期間呼叫的可覆寫方法
overridable.method.call.in.constructor.problem.descriptor=物件建構期間呼叫可覆寫方法 <code>\\#ref()</code> \\#loc
overridden.method.call.in.constructor.display.name=覆寫的方法在物件建構期間呼叫
overridden.method.call.in.constructor.problem.descriptor=物件建構期間呼叫已覆寫方法 <code>\\#ref()</code> \\#loc
package.dot.html.may.be.package.info.convert.quickfix=轉換為 'package-info.java'
package.dot.html.may.be.package.info.delete.quickfix=刪除 'package.html'
package.dot.html.may.be.package.info.display.name='package.html' 可以轉換為 'package-info.java'
package.dot.html.may.be.package.info.exists.problem.descriptor=<code>package.html</code> 被忽略，因為 <code>package-info.java</code> 存在
package.dot.html.may.be.package.info.problem.descriptor=<code>package.html</code> 可以轉換為 <code>package-info.java</code>
package.in.multiple.modules.display.name=具有多個模組中的類別的軟體套件
package.in.multiple.modules.problem.descriptor.many=軟體套件 ''{0}'' 具有模組 ''{1}''、''{2}'' 以及其他 {3} 個模組中的類別
package.in.multiple.modules.problem.descriptor2=軟體套件 ''{0}'' 具有模組 ''{1}'' 和 ''{2}'' 中的類別
package.in.multiple.modules.problem.descriptor3=軟體套件 ''{0}'' 具有模組 ''{1}''、''{2}'' 和 ''{3}'' 中的類別
package.info.java.without.package.display.name=不帶 'package' 語句的 'package-info.java'
package.info.without.package.family.quickfix=新增 package 語句
package.info.without.package.problem.descriptor='package-info.java' 沒有 'package' 語句
package.info.without.package.quickfix=新增 ''package {0};''
package.local.field.not.accessible=package-private 欄位 ''{0}'' 無法從此處存取
package.local.private=package-private 與 private
package.naming.convention.display.name=軟體套件命名約定
package.naming.convention.problem.descriptor.long=軟體套件名稱 <code>{0}</code> 過長
package.naming.convention.problem.descriptor.regex.mismatch=軟體套件名稱 <code>{0}</code> 與正則表達式 ''{1}'' 不符合
package.naming.convention.problem.descriptor.short=軟體套件名稱 <code>{0}</code> 過短
package.visible.field.display.name=軟體套件可見欄位
package.visible.field.problem.descriptor=軟體套件可見欄位 <code>\\#ref</code> \\#loc
package.visible.inner.class.display.name=軟體套件可見的嵌套類別
package.visible.inner.class.ignore.enum.option=忽略軟體套件可見的內部枚舉
package.visible.inner.class.ignore.interface.option=忽略軟體套件可見的內部接口
package.visible.inner.class.problem.descriptor=軟體套件可見的嵌套類別 <code>\\#ref</code> \\#loc
package.with.too.few.classes.display.name=軟體套件具有過少類別
package.with.too.few.classes.min.option=最小類別數\\:
package.with.too.few.classes.problem.descriptor=軟體套件 ''{0}'' 包含過少的類別 ({1} < {2})
package.with.too.many.classes.display.name=類別過多的軟體套件
package.with.too.many.classes.max.option=最大類別數\\:
package.with.too.many.classes.problem.descriptor=軟體套件 ''{0}'' 包含過多的類別 ({1} > {2})
parameter.hides.member.variable.display.name=參數隱藏欄位
parameter.hides.member.variable.ignore.abstract.methods.option=對 abstract 方法忽略
parameter.hides.member.variable.ignore.constructors.option=對建構函式忽略
parameter.hides.member.variable.ignore.setters.option=對屬性 setter 忽略
parameter.hides.member.variable.ignore.static.parameters.option=對隱藏實例欄位的 static 方法參數忽略
parameter.hides.member.variable.ignore.superclass.option=忽略從子類別不可見的超類別欄位
parameter.hides.member.variable.problem.descriptor=參數 <code>\\#ref</code> 隱藏類別 ''{0}'' 中的欄位 \\#loc
parameter.limit.option=參數限制\\:
parameter.name.differs.from.overridden.parameter.display.name=參數名稱與覆寫或多載方法中的參數不同
parameter.name.differs.from.overridden.parameter.ignore.character.option=如果覆寫的參數僅包含一個字元，則忽略
parameter.name.differs.from.overridden.parameter.ignore.library.option=如果覆寫的參數來自庫，則忽略
parameter.name.differs.from.overridden.parameter.problem.descriptor=參數名 <code>\\#ref</code> 不同於{1, choice, 1\\#super 方法|2\\#多載方法|3\\#super 建構函式|4\\#多載建構函式}中的參數 ''{0}'' \\#loc
parameter.naming.convention.display.name=方法參數命名約定
parameter.naming.convention.element.description=參數
parameter.type.prevents.overriding.display.name=參數類型阻止覆寫
parameter.type.prevents.overriding.family.quickfix=更改參數類型
parameter.type.prevents.overriding.problem.descriptor=參數類型 <code>\\#ref</code> 位於 ''{0}''，而 super 方法參數類型位於 ''{1}''，可防止覆寫 \\#loc
parameter.type.prevents.overriding.quickfix=將參數類型更改為 ''{0}''
parameters.per.constructor.display.name=參數過多的建構函式
parameters.per.constructor.problem.descriptor=<code>\\#ref()</code> 的參數過多(參數數量 \\= {0}) \\#loc
parameters.per.method.display.name=參數過多的方法
parameters.per.method.problem.descriptor=<code>\\#ref()</code> 的參數過多(參數數量 \\= {0}) \\#loc
pattern.variable.hides.field.display.name=模式變數隱藏欄位
pattern.variable.hides.field.problem.descriptor=模式變數 <code>\\#ref</code> 隱藏類別 ''{0}'' 中的欄位 \\#loc
pointless.arithmetic.expression.display.name=無意義的算術表達式
pointless.bitwise.expression.display.name=無意義的按位表達式
pointless.bitwise.expression.simplify.quickfix=簡化
pointless.boolean.expression.display.name=無意義的布爾表達式
pointless.boolean.expression.ignore.option=在確定無意義表達式時忽略命名常數
pointless.indexof.comparison.always.false.problem.descriptor=<code>\\#ref</code> 始終為 false \\#loc
pointless.indexof.comparison.always.true.problem.descriptor=<code>\\#ref</code> 始終為 true \\#loc
pointless.indexof.comparison.display.name=無意義的 'indexOf()' 比較
pointless.nullcheck.display.name=方法呼叫前出現不必要的 'null' 檢查
pointless.nullcheck.problem.descriptor.call=''{0}()'' 呼叫之前的 ''null'' 檢查不必要
possible.throw.from.finally.block.problem.descriptor=<code>{0}</code> 可能在 ''finally'' 塊內拋出 \\#loc
prefer.empty.array.options.mode.always=始終
prefer.empty.array.options.mode.always.never=從不(首選預設大小的陣列)
prefer.empty.array.options.mode.by.level=根據語言級別
prefer.empty.array.options.title=首選空陣列\\:
prefix.operation.quickfix.family.name=取代為前綴運算符
press.escape.to.remove.highlighting.message=按 Esc 移除醒目提示
primitive.array.argument.to.var.arg.method.display.name=引起混淆的 vararg 方法基元陣列實參
primitive.array.argument.to.var.arg.method.problem.descriptor=引起混淆的 vararg 方法基元陣列實參 \\#loc
primitive.fields.ignore.option=忽略原始欄位
printstacktrace.call.display.name=呼叫 'printStackTrace()'
printstacktrace.call.problem.descriptor=對 <code>\\#ref()</code> 的呼叫可能應當取代為更可靠的日誌 \\#loc
private=private
private.field.not.accessible.problem.descriptor=''private'' 欄位 ''{0}'' 無法從此處存取
private.member.access.between.outer.and.inner.classes.display.name=合成存取器呼叫
private.member.access.between.outer.and.inner.classes.make.constructor.package.local.quickfix=將 ''{0}'' 建構函式設為 package-private
private.member.access.between.outer.and.inner.classes.make.local.quickfix=將 ''{0}'' 設為 package-private
private.member.access.between.outer.and.inner.classes.problem.descriptor=存取類別 ''{0}'' 的 ''private'' 成員需要合成存取器 \\#loc
problematic.varargs.method.display.name=非 vararg 方法覆寫 vararg 方法
problematic.varargs.method.override.problem.descriptor=非 vararg 方法 <code>\\#ref()</code> 覆寫 vararg 方法 \\#loc
progress.text.analyzing.package.0=正在分析軟體套件 {0}
properties.object.as.hashtable.display.name=將 'Properties' 物件用作 'Hashtable'
properties.object.as.hashtable.problem.descriptor=在屬性物件上呼叫 <code>Hashtable.\\#ref()</code> \\#loc
property.value.set.to.itself.display.name=屬性值設定為自身
protected.field.display.name=protected 欄位
protected.field.not.accessible.problem.descriptor=''protected'' 欄位 ''{0}'' 無法從此處存取
protected.field.problem.descriptor=protected 欄位 <code>\\#ref</code> \\#loc
protected.inner.class.display.name=protected 嵌套類別
protected.inner.class.ignore.enum.option=忽略 'protected' 內部枚舉
protected.inner.class.ignore.interface.option=忽略 'protected' 內部接口
protected.inner.class.problem.descriptor=protected 嵌套類別 <code>\\#ref</code> \\#loc
protected.member.in.final.class.display.name='protected' 成員位於 'final' 類別中
protected.member.in.final.class.problem.descriptor=類別成員在 'final' 類別中被宣告為 <code>\\#ref</code> \\#loc
protected.package.local.private=protected、package-private 和 private
public.constructor.display.name='public' 建構函式可被取代為工廠方法
public.constructor.in.non.public.class.display.name='public' 建構函式位於非 public 類別中
public.constructor.in.non.public.class.problem.descriptor=建構函式在非 public 類別 ''{0}'' 中被宣告為 <code>\\#ref</code> \\#loc
public.constructor.in.non.public.class.quickfix=將建構函式設為 private
public.constructor.problem.descriptor=public 建構函式 <code>\\#ref()</code> \\#loc
public.constructor.quickfix=將建構函式取代為工廠方法
public.default.constructor.problem.descriptor=類別 <code>\\#ref</code> 具有 'public' 預設建構函式
public.field.accessed.in.synchronized.context.display.name=在 'synchronized' 上下文中存取d了非 private 欄位
public.field.accessed.in.synchronized.context.problem.descriptor=在同步上下文中存取非 private 欄位 <code>\\#ref</code> \\#loc
public.field.display.name='public' 欄位
public.field.ignore.enum.type.fields.option=忽略枚舉類型的 'public final' 欄位
public.field.problem.descriptor='public' 欄位 <code>\\#ref</code> \\#loc
public.inner.class.display.name='public' 嵌套類別
public.inner.class.ignore.enum.option=忽略 'public' 內部枚舉
public.inner.class.ignore.interface.option=忽略 'public' 內部接口
public.inner.class.problem.descriptor='public' 嵌套類別 <code>\\#ref</code> \\#loc
public.method.not.in.interface.display.name='public' 方法在接口中未公開
public.method.not.in.interface.option=<html>如果包含類別未實作非庫接口，則忽略</html>
public.method.not.in.interface.problem.descriptor='public' 方法 <code>\\#ref()</code> 未通過接口公開 \\#loc
public.method.without.logging.display.name='public' 方法沒有日誌記錄
public.method.without.logging.problem.descriptor='public' 方法 <code>\\#ref()</code> 沒有日誌呼叫 \\#loc
public.static.array.field.display.name='public static' 陣列欄位
public.static.array.field.problem.descriptor='public static' 陣列欄位 <code>\\#ref</code>，影響安全性 \\#loc
public.static.collection.field.display.name='public static' 集合欄位
public.static.collection.field.problem.descriptor='public static' 集合欄位 <code>\\#ref</code>，影響安全性 \\#loc
qualify.call.fix.family.name=限定呼叫
query.label=查詢名稱開頭\\:
questionable.name.display.name=可疑名稱
questionable.name.list.label=報告的名稱\\:
questionable.name.problem.descriptor=可疑名稱 <code>\\#ref</code> \\#loc
random.double.for.random.integer.display.name=使用 'Random.nextDouble()' 獲取隨機整數
random.double.for.random.integer.problem.descriptor=使用 <code>Random.\\#ref</code> 建立隨機整數 \\#loc
raw.use.of.parameterized.type.display.name=參數化類別的原始使用
readobject.initialization.display.name=實例欄位可能無法被 'readObject()' 初始化
readobject.initialization.problem.descriptor=實例欄位 <code>\\#ref</code> 在 'readObject()' 呼叫期間可能無法初始化 \\#loc
readresolve.writereplace.protected.display.name='readResolve()' 或 'writeReplace()' 未被宣告為 'protected'
readresolve.writereplace.protected.problem.descriptor=<code>\\#ref()</code> 未被宣告為 'protected' \\#loc
readwriteobject.private.display.name='readObject()' 或 'writeObject()' 未被宣告為 'private'
readwriteobject.private.problem.descriptor=<code>\\#ref</code> 未被宣告為 'private' \\#loc
recordstore.opened.not.safely.closed.display.name=開啟了 'RecordStore'，但未安全關閉
redundant.as.list.for.iteration.fix.name=解包
redundant.as.list.for.iteration.problem=不必要的 'Arrays.asList()' 呼叫
redundant.call.problem.descriptor=冗餘呼叫 <code>\\#ref()</code> \\#loc
redundant.else.display.name=冗餘的 'else'
redundant.else.problem.descriptor=<code>\\#ref</code> 分支可以解包，因為 'if' 分支永遠不會正常完成 \\#loc
redundant.else.unwrap.quickfix=移除冗餘的 'else'
redundant.escape.in.regex.replacement.display.name=正則表達式取代字串中的冗餘轉義
redundant.escape.in.regex.replacement.problem.descriptor=''{0}'' 的冗餘轉義
redundant.escape.in.regex.replacement.quickfix=移除冗餘轉義
redundant.explicit.var.type.display.name=可以省略區域變數類型
redundant.field.initialization.display.name=冗餘欄位初始化
redundant.field.initialization.problem.descriptor=<code>\\#ref</code> 的欄位初始化是冗餘的 \\#loc
redundant.field.initialization.remove.quickfix=移除初始設定式
redundant.implements.display.name=冗餘接口宣告
redundant.implements.problem.descriptor=冗餘接口宣告 <code>\\#ref</code> \\#loc
redundant.implements.remove.quickfix=移除冗餘接口宣告
redundant.local.variable.annotation.option=忽略具有註解的變數
redundant.local.variable.display.name=冗餘區域變數
redundant.local.variable.ignore.option=忽略立即返回或拋出的變數
redundant.method.override.delegate.quickfix=將方法取代為到 super 的委託
redundant.method.override.delegates.to.super.problem.descriptor=方法 <code>\\#ref()</code> 僅委託給 super 方法 \\#loc
redundant.method.override.display.name=方法與其 super 方法相同
redundant.method.override.option.check.library.methods=檢查覆寫庫方法的方法
redundant.method.override.option.ignore.delegates=忽略到 super 方法的委託
redundant.method.override.problem.descriptor=方法 <code>\\#ref()</code> 與其 super 方法相同 \\#loc
redundant.method.override.quickfix=移除冗餘方法
redundant.string.format.call.display.name=冗餘呼叫 'String.format()'
redundant.string.format.call.quickfix=移除對 'String.format()' 的冗餘呼叫
redundant.string.formatted.call.quickfix=移除對 'String.formatted()' 的冗餘呼叫
referencing.subclass.0.from.superclass.1.initializer.might.lead.to.class.loading.deadlock=從超類別 {1} 初始設定式參照子類別 {0} 可能會導致類別載入死鎖
reflection.for.unavailable.annotation.display.name=對僅源註解的反射存取
reflection.for.unavailable.annotation.problem.descriptor=註解 '\\#ref' 不保留用於反射存取 \\#loc
refused.bequest.display.name=方法不呼叫 super 方法
refused.bequest.fix.family.name=將呼叫插入 super 方法
refused.bequest.ignore.default.super.methods.option=忽略 'default' super 方法
refused.bequest.ignore.empty.super.methods.option=忽略空 super 方法
refused.bequest.problem.descriptor=方法 <code>\\#ref()</code> 未呼叫 'super.\\#ref()' \\#loc
remove.annotation.parameter.0.fix.name=移除註解參數 ''{0}''
remove.call.fix.family.name=移除呼叫
remove.cloneable.quickfix=從 'implements' 子句中移除 'Cloneable'
remove.finally.block.quickfix=移除 'finally' 塊
remove.leading.zero.to.make.decimal.quickfix=移除前導零以變為十進制
remove.leading.zeroes.to.make.decimals.quickfix=移除前導零以變為十進制
remove.loop.fix.family.name=移除迴圈
remove.modifier.fix.family.name=移除修飾符
remove.modifier.quickfix=移除 ''{0}'' 修飾符
remove.redundant.polyadic.operand.fix.family.name=移除不必要的條件
remove.redundant.polyadic.operand.fix.name=移除不必要的 ''{0}'' 條件
remove.redundant.string.fix.text=使用 ''{0}()'' 並移除冗餘的 ''{1}()'' 呼叫
remove.redundant.substring.fix.family.name=移除冗餘的 'substring()' 呼叫
remove.try.finally.block.quickfix=移除 'try-finally' 塊
remove.unnecessary.0.call.quickfix=移除不必要的 ''{0}()'' 呼叫
rename.quickfix=重新命名
renameto.quickfix=重命名為 ''{0}''
replace.all.dot.display.name=可疑的正則表達式實參
replace.all.dot.problem.descriptor=''{0}()'' 呼叫中存在可疑的正則表達式 \\#ref \\#loc
replace.all.dot.quickfix=轉義正則表達式元字元
replace.all.file.separator.problem.descriptor=File.separator 用作正則表達式；無法在 Windows 上工作
replace.anonymous.with.lambda.body.fix.family.name=將呼叫取代為方法體
replace.case.default.null.with.null.default=將 'case default, null' 取代為 'case null, default'
replace.case.default.with.default=將 'case default' 取代為 'default'
replace.cast.fix.family.name=取代轉換類型
replace.casted.literal.with.just.literal.fix.family.name=取代為 {0} 字面量
replace.field.reference.fix.family.name=取代欄位參照
replace.field.reference.fix.text=將欄位參照取代為 ''{0}''
replace.inheritance.with.delegation.quickfix=將繼承取代為委託
replace.instanceof.fix.family.name=取代 instanceOf 類型
replace.method.call.fix.family.name=取代方法呼叫
replace.method.call.fix.text=將方法呼叫取代為 ''{0}''
replace.method.ref.with.qualifier.fix.family.name=取代為限定符
replace.method.ref.with.qualifier.problem.lambda=lambda 可被取代為呼叫限定符
replace.method.ref.with.qualifier.problem.method=方法參照可被取代為限定符
replace.with.cast.fix.family.name=取代為轉換
replace.with.catch.clause.for.runtime.exception.quickfix=針對 'RuntimeException' 取代為 'catch' 子句
replace.with.comparator.fix.family.name=使用 'Comparator' static 方法簡化比較器
replace.with.lambda.body.fix.family.name=將 lambda 上的方法呼叫取代為 lambda 體
replace.with.method.ref.fix.family.name=將 lambda 取代為方法參照
replace.with.method.ref.fix.name.may.change.semantics=將 lambda 取代為方法參照(可能更改語意)
replace.with.method.reference.fix.family.name=將方法參照上的方法呼叫取代為相應的方法呼叫
replace.with.var.fix.family.name=將顯式類型取代為 'var'
resource.opened.not.closed.problem.descriptor=''{0}'' 應在 ''try'' 塊之前開啟，並在相應的 ''finally'' 塊中關閉 \\#loc
result.of.method.call.ignored.class.column.title=類別名
result.of.method.call.ignored.display.name=方法呼叫的結果已忽略
result.of.method.call.ignored.non.library.option=報告所有忽略的非庫呼叫
result.of.method.call.ignored.problem.descriptor=<code>{0}.\\#ref()</code> 的結果已忽略 \\#loc
result.of.object.allocation.fix.name=忽略類型 ''{0}'' 的物件的分配
result.of.object.allocation.ignored.display.name=物件分配的結果已忽略
result.of.object.allocation.ignored.options.chooserTitle=選擇可以忽略物件分配的類別
result.of.object.allocation.ignored.problem.descriptor=<code>new \\#ref()</code> 的結果已忽略 \\#loc
result.of.object.allocation.ignored.problem.descriptor.methodRef=在 <code>\\#ref</code> 內部分配的物件已被捨棄 \\#loc
return.from.finally.block.display.name='return' 位於 'finally' 塊內
return.from.finally.block.problem.descriptor='return' 位於 'finally' 塊內 \\#loc
return.of.anonymous.class.problem.descriptor=返回匿名類別的實例 \\#loc
return.of.collection.field.fix.family.name=使返回集合 'unmodifiable'
return.of.field.with.mutable.type.problem.descriptor={0} 欄位 <code>\\#ref</code> 的返回值 \\#loc
return.of.inner.class.display.name=返回匿名、區域或內部類別的實例
return.of.inner.class.ignore.non.public.option=忽略非 public 方法的返回值
return.of.inner.class.problem.descriptor=返回非 static 內部類別 <code>{0}</code> 的實例 \\#loc
return.of.local.class.problem.descriptor=返回區域類別 <code>{0}</code> 的實例 \\#loc
return.of.null.arrays.option=報告返回陣列的方法
return.of.null.collections.option=報告返回集合物件的方法
return.of.null.display.name=返回 'null'
return.of.null.ignore.private.option=忽略 'private' 方法、匿名類別和 lambda
return.of.null.objects.option=報告返回物件的方法
return.of.null.problem.descriptor=返回 <code>\\#ref</code> \\#loc
return.point.limit.option=返回點限制(&R)\\:
return.this.display.name=返回 'this'
return.this.problem.descriptor=返回 <code>\\#ref</code> \\#loc
reuse.of.local.variable.display.name=區域變數的重用
reuse.of.local.variable.problem.descriptor=區域變數 <code>\\#ref</code> 的重用 \\#loc
reuse.of.local.variable.split.quickfix=拆分區域變數
runtime.exec.call.display.name=呼叫 'Runtime.exec()'
runtime.exec.call.problem.descriptor=對 <code>Runtime.\\#ref()</code> 的呼叫不可移植 \\#loc
runtime.exec.with.non.constant.string.display.name='Runtime.exec()' 呼叫具有非常數字串
runtime.exec.with.non.constant.string.problem.descriptor=<code>Runtime.\\#ref()</code> 呼叫具有非常數實參 \\#loc
safe.lock.display.name=已獲取但未安全解鎖的鎖
safe.lock.problem.descriptor=''{0}'' 應在 ''try'' 塊之前鎖定，並在相應的 ''finally'' 塊中解鎖 \\#loc
sequenced.collection.method.can.be.used.ignore.option=忽略用作實參的命名常數
serial.annotation.used.on.wrong.member.display.name=對錯誤的成員使用了 '@Serial' 註解
serial.annotation.used.on.wrong.member.problem.descriptor=註解的成員不是序列化機制的一部分
serializable.anonymous.class.stores.non.serializable.problem.descriptor=可序列化匿名類別隱式存儲類型為 ''{0}'' 的不可序列化物件
serializable.class.in.secure.context.display.name=安全上下文中的可序列化類別
serializable.class.in.secure.context.problem.descriptor=類別 <code>\\#ref</code> 可能被序列化，影響安全性 \\#loc
serializable.deserializable.class.in.secure.context.problem.descriptor=類別 <code>\\#ref</code> 可能被序列化和反序列化，影響安全性 \\#loc
serializable.has.serialization.methods.display.name=不帶 'readObject()' 和 'writeObject()' 的可序列化類別
serializable.has.serialization.methods.ignore.option=忽略未定義實例欄位的類別
serializable.has.serialization.methods.problem.descriptor=可序列化類別 <code>\\#ref</code> 未定義 'readObject()' 或 'writeObject()' \\#loc
serializable.has.serialization.methods.problem.descriptor1=可序列化類別 <code>\\#ref</code> 未定義 'writeObject()' \\#loc
serializable.has.serialization.methods.problem.descriptor2=可序列化類別 <code>\\#ref</code> 未定義 'readObject()' \\#loc
serializable.inner.class.has.serial.version.uid.field.display.name=沒有 'serialVersionUID' 的可序列化非 static 內部類別
serializable.inner.class.has.serial.version.uid.field.problem.descriptor=內部類別 <code>\\#ref</code> 未定義 'serialVersionUID' 欄位 \\#loc
serializable.inner.class.with.non.serializable.outer.class.display.name=可序列化非 'static' 內部類別具有不可序列化外部類
serializable.inner.class.with.non.serializable.outer.class.problem.descriptor=內部類別 <code>\\#ref</code> 可序列化，而其外部類別不可序列化 \\#loc
serializable.lambda.stores.non.serializable.problem.descriptor=可序列化 lambda 隱式存儲類型為 ''{0}'' 的不可序列化物件
serializable.local.class.stores.non.serializable.problem.descriptor=可序列化區域類別 ''{1}'' 隱式存儲類型為 ''{0}'' 的不可序列化物件
serializable.record.contains.ignored.field.problem.descriptor=在記錄序列化期間將忽略 <code>\\#ref</code>
serializable.record.contains.ignored.members.display.name='record' 包含被忽略的成員
serializable.record.contains.ignored.method.problem.descriptor=在記錄序列化期間將忽略 <code>\\#ref()</code>
serializable.stores.non.serializable.display.name='Serializable' 物件隱式存儲非 'Serializable' 物件
serializable.with.unconstructable.ancestor.display.name=具有不可建構上級的可序列化類別
serializable.with.unconstructable.ancestor.problem.descriptor=<code>\\#ref</code> 具有不帶無實參建構函式的不可序列化上級 ''{0}'' \\#loc
serialpersistentfields.with.wrong.signature.display.name='serialPersistentFields' 欄位未被宣告為 'private static final ObjectStreamField[]'
serialpersistentfields.with.wrong.signature.problem.descriptor=可序列化類別的 <code>\\#ref</code> 欄位未被宣告為 'private static final ObjectStreamField[]' \\#loc
serialversionuid.private.static.final.long.display.name='serialVersionUID' 欄位未被宣告為 'private static final long'
serialversionuid.private.static.final.long.problem.descriptor=可序列化類別的 <code>\\#ref</code> 欄位未被宣告為 'private static final long' \\#loc
serialversionuid.private.static.final.long.quickfix=將 serialVersionUID 設為 'private static final'
set.annotation.parameter.0.1.fix.name=將註解參數 {0} 設定為“{1}”
set.replaceable.by.enum.set.display.name='Set' 可被取代為 'EnumSet'
set.replaceable.by.enum.set.problem.descriptor=<code>\\#ref</code> 可被取代為 'EnumSet' \\#loc
shared.thread.local.random.display.name='ThreadLocalRandom' 實例可能是共享的
shared.thread.local.random.problem.descriptor='ThreadLocalRandom' 實例可能在線程之間共享
shift.operation.by.inappropriate.constant.display.name=按不當常數進行移位運算
shift.operation.by.inappropriate.constant.problem.descriptor.negative=對 <code>\\#ref</code> 進行移位運算時使用的常量值 {0} 為負 \\#loc
shift.operation.by.inappropriate.constant.problem.descriptor.out.of.bounds=按超出範圍的值 {0} 進行移位運算 <code>\\#ref</code> \\#loc
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=對 <code>\\#ref</code> 進行移位運算時使用的常量值 {0} 過大 \\#loc
shift.out.of.range.fix.family.name=修復移位值
signal.without.corresponding.await.display.name=沒有相應 'await()' 的 'signal()'
signal.without.corresponding.await.problem.descriptor=在沒有相應 <code>await()</code> 的情況下呼叫 <code>\\#ref()</code> \\#loc
simplifiable.annotation.braces.problem.descriptor=註解中 <code>{0}</code> 周圍不必要的圓括號 \\#loc
simplifiable.annotation.display.name=可簡化註解
simplifiable.annotation.problem.descriptor=註解中有不必要的 <code>\\#ref</code> \\#loc
simplifiable.annotation.quickfix=簡化註解
simplifiable.annotation.whitespace.problem.descriptor=註解中有不必要的空格 \\#loc
simplifiable.boolean.expression.display.name=可簡化的布爾表達式
simplifiable.conditional.expression.display.name=可簡化的條件表達式
simplifiable.conditional.expression.problem.descriptor=<code>{1}</code> 可以簡化為 ''{0}'' \\#loc
simplifiable.equals.expression.display.name='equals()' 呼叫之前的 'null' 檢查不必要
simplifiable.equals.expression.option.non.constant=報告具有非常數非 null 實參的等於
simplifiable.equals.expression.problem.descriptor=''{0}()'' 呼叫之前的 ''null'' 檢查不必要 \\#loc
simplifiable.equals.expression.quickfix=翻轉 ''.{0}()'' 並移除不必要的 ''null'' 檢查
simplifiable.junit.assertion.display.name=可簡化斷言
simplifiable.junit.assertion.problem.descriptor=<code>\\#ref()</code> 可以簡化為 ''{0}'' \\#loc
simplify.junit.assertion.simplify.quickfix=簡化斷言
single.character.startswith.display.name=單個字元 'startsWith()' 或 'endsWith()'
single.character.startswith.problem.descriptor=單個字元 <code>\\#ref()</code> 可被取代為 'charAt()' 表達式 \\#loc
single.character.startswith.quickfix=取代為 'charAt()' 表達式
single.class.import.display.name=單個類別匯入
single.class.import.problem.descriptor=單個類別匯入 <code>\\#ref</code> \\#loc
single.element.annotation.family.quickfix=將註解擴展為標準形式
single.element.annotation.name=非規范化註解
single.element.annotation.quickfix=新增 'value\\='
single.statement.in.block.descriptor=''{0}'' 包含單條語句
single.statement.in.block.family.quickfix=從語句中移除大括號
single.statement.in.block.name=程式碼塊包含單條語句
single.statement.in.block.quickfix=從 ''{0}'' 語句中移除大括號
singleton.display.name=單例
singleton.problem.descriptor=類別 <code>\\#ref</code> 為單例 \\#loc
size.replaceable.by.isempty.display.name='size() \\=\\= 0' 可被取代為 'isEmpty()'
size.replaceable.by.isempty.fix.ignore.calls=忽略類型 ''{1}'' 上的 ''.{0}()'' 呼叫
size.replaceable.by.isempty.negation.ignore.option=忽略將取代為 '\\!isEmpty()' 的表達式
sleep.while.holding.lock.display.name=同步時呼叫 'Thread.sleep()'
sleep.while.holding.lock.problem.descriptor=同步時呼叫 <code>Thread.\\#ref()</code> \\#loc
smth.unnecessary.remove.quickfix=移除不必要的 ''{0}''
socket.opened.not.closed.display.name=套接字已開啟，但未安全關閉
standard.variable.names.display.name=標準變數名稱
standard.variable.names.ignore.override.option=對與 super 方法參數相同的參數名稱忽略
standard.variable.names.problem.descriptor=變數命名 <code>\\#ref</code> 沒有類型 ''{0}'' \\#loc
standard.variable.names.problem.descriptor2=變數命名 <code>\\#ref</code> 沒有類型 ''{0}'' 或 ''{1}'' \\#loc
statement.problem.descriptor=<code>\\#ref</code> 語句 \\#loc
statement.with.empty.body.display.name=帶空體的語句
statement.with.empty.body.include.option=包含空程式碼塊語句正文
statement.with.empty.body.problem.descriptor=<code>\\#ref</code> 語句具有空體 \\#loc
static.collection.display.name=靜態集合
static.collection.ignore.option=忽略弱靜態集合或映射
static.collection.problem.descriptor=靜態集合 <code>\\#ref</code> \\#loc
static.field.via.subclass.display.name=static 欄位通過子類別參照
static.field.via.subclass.problem.descriptor=static 欄位 <code>\\#ref</code> 在類別 ''{0}'' 中宣告，但通過子類別 ''{1}'' 參照 \\#loc
static.field.via.subclass.rationalize.quickfix=使 static 欄位存取合理化
static.import.display.name=static import
static.import.fix.ignore.class=允許類別 ''{0}'' 的 static import
static.import.options.border.title=靜態可匯入類別\\:
static.import.options.chooserTitle=選擇靜態可匯入類別
static.import.problem.descriptor=static import <code>\\#ref</code>  \\#loc
static.import.replace.quickfix=取代為非 static import
static.inheritance.display.name=靜態繼承
static.inheritance.fix.family.name=將繼承取代為限定參照
static.inheritance.problem.descriptor=接口 <code>\\#ref</code> 僅針對其 static 常數實作 \\#loc
static.inheritance.replace.quickfix=將繼承取代為 {0} 中的限定參照
static.initializer.references.subclass.display.name=static 初始設定式參照子類別
static.method.naming.convention.element.description='static' 方法
static.method.only.used.in.one.anonymous.class.problem.descriptor=static {0, choice, 1\\#方法|2\\#欄位} <code>\\#ref{0, choice, 1\\#()|2\\#}</code> 僅在派生自 ''{1}'' 的匿名類別中使用 \\#loc
static.method.only.used.in.one.class.display.name=static 成員僅在其他一個類別中使用
static.method.only.used.in.one.class.ignore.anonymous.option=僅在匿名類別中使用時忽略
static.method.only.used.in.one.class.ignore.on.conflicts=當方法無法在不產生衝突的情況下移動時忽略
static.method.only.used.in.one.class.ignore.test.option=僅在測試類別中使用時忽略
static.method.only.used.in.one.class.ignore.utility.classes=忽略位於實用程序類別中的成員
static.method.only.used.in.one.class.problem.descriptor=static {0, choice, 1\\#方法|2\\#欄位} <code>\\#ref{0, choice, 1\\#()|2\\#}</code> 僅在 ''{1}'' 類別中使用 \\#loc
static.method.only.used.in.one.class.quickfix=將 {0} 移至使用類別
static.method.only.used.in.one.class.quickfix.preview=將 static 成員移至使用它的類別。
static.method.via.subclass.display.name=static 方法通過子類別參照
static.method.via.subclass.problem.descriptor=static 方法 <code>\\#ref()</code> 在類別 ''{0}'' 中宣告，但通過子類別 ''{1}'' 參照 \\#loc
static.method.via.subclass.rationalize.quickfix=使 static 方法呼叫合理化
static.non.final.field.display.name='static' 非 'final' 欄位
static.non.final.field.option=僅報告 'public' 欄位
static.non.final.field.problem.descriptor='static' 非 'final' 欄位 <code>\\#ref</code> \\#loc
static.variable.may.not.be.initialized.display.name=static 欄位可能無法初始化
static.variable.may.not.be.initialized.problem.descriptor=static 欄位 <code>\\#ref</code> 在類別初始化期間可能無法初始化 \\#loc
static.variable.naming.convention.element.description='static' 欄位
static.variable.of.concrete.class.problem.descriptor=具體類別 <code>\\#ref</code> 的 static 欄位 ''{0}'' \\#loc
static.variable.used.before.initialization.display.name=static 欄位在初始化前使用
static.variable.used.before.initialization.problem.descriptor=static 欄位 <code>\\#ref</code> 在初始化前使用 \\#loc
string.buffer.must.have.initial.capacity.display.name=沒有初始容量的 'StringBuilder'
string.buffer.must.have.initial.capacity.problem.descriptor=沒有初始容量的 <code>new \\#ref()</code> \\#loc
string.buffer.replaceable.by.string.builder.display.name='StringBuffer' 可能是 'StringBuilder'
string.buffer.replaceable.by.string.builder.problem.descriptor=<code>StringBuffer \\#ref</code> 可能被宣告為 'StringBuilder' \\#loc
string.buffer.replaceable.by.string.display.name='StringBuilder' 可被取代為 'String'
string.buffer.replaceable.by.string.problem.descriptor=<code>{0} \\#ref</code> 可被取代為 ''String'' \\#loc
string.comparison.display.name=使用 '\\=\\=' 而不是 'equals()' 進行字串比較
string.comparison.problem.descriptor=使用 <code>\\#ref</code> 而不是 'equals()' 來比較字串值 \\#loc
string.concatenation.argument.to.log.call.display.name=非常數字串串聯作為日誌呼叫的實參
string.concatenation.argument.to.log.call.problem.descriptor=非常數字串作為 <code>\\#ref()</code> 日誌記錄呼叫的實參 \\#loc
string.concatenation.argument.to.log.call.quickfix=將串聯取代為參數化的日誌訊息
string.concatenation.argument.to.log.message.format.call.quickfix=將 'Message.format()' 取代為參數化日誌訊息
string.concatenation.argument.to.log.string.format.call.quickfix=將 'String.format()' 取代為參數化日誌訊息
string.concatenation.display.name=字串串聯
string.concatenation.in.format.call.display.name=字串串聯作為 'format()' 呼叫的實參
string.concatenation.in.format.call.fix.family.name=將串聯取代為實參
string.concatenation.in.format.call.problem.descriptor=''{0}()'' 呼叫包含字串串聯實參
string.concatenation.in.format.call.quickfix=將串聯取代為單獨的實參
string.concatenation.in.loops.display.name=字串串聯在迴圈中
string.concatenation.in.loops.problem.descriptor=迴圈中的字串串聯 <code>\\#ref</code> \\#loc
string.concatenation.in.message.format.call.display.name=字串串聯作為 'MessageFormat.format()' 呼叫的實參
string.concatenation.in.message.format.call.problem.descriptor=字串串聯作為 'MessageFormat.format()' 呼叫的實參 \\#loc
string.concatenation.inside.string.buffer.append.display.name=字串串聯作為 'StringBuilder.append()' 呼叫的實參
string.concatenation.inside.string.buffer.append.problem.descriptor=字串串聯作為 <code>{0}.\\#ref()</code> 呼叫的實參 \\#loc
string.concatenation.inside.string.buffer.append.replace.quickfix=取代為鏈式 'append()' 呼叫
string.concatenation.introduce.fix=引入 StringBuilder
string.concatenation.introduce.fix.name=引入新的 {1} 以更新變數 ''{0}''
string.concatenation.introduce.fix.name.null.safe=引入新的 {1} 以更新變數 ''{0}'' (null 安全)
string.concatenation.missing.whitespace.display.name=字串串聯中可能缺少空格
string.concatenation.missing.whitespace.option=忽略具有變量字串的串聯
string.concatenation.missing.whitespace.problem.descriptor=字串串聯中可能缺少空格 \\#loc
string.concatenation.problem.descriptor=國際化上下文中的字串串聯 <code>\\#ref</code> \\#loc
string.concatenation.replace.fix=取代為 StringBuilder
string.concatenation.replace.fix.name=將變數 ''{0}'' 從字串轉換為 {1}
string.concatenation.replace.fix.name.null.safe=將變數 ''{0}'' 從字串轉換為 {1} (null 安全)
string.equals.char.sequence.display.name=使用 'CharSequence' 實參呼叫了 'String.equals()'
string.equals.char.sequence.problem.descriptor=使用 ''{0}'' 實參呼叫了 <code>String.equals()</code> \\#loc
string.equals.empty.string.display.name='String.equals()' 可被取代為 'String.isEmpty()'
string.equals.empty.string.fix.family.name=簡化空字串檢查
string.equals.empty.string.is.empty.problem.descriptor=<code>\\#ref("")</code> 可被取代為 'isEmpty()' \\#loc
string.equals.empty.string.option.do.not.add.null.check=當有必要進行 null 檢查時，不必報告
string.equals.empty.string.problem.descriptor=<code>\\#ref("")</code> 可被取代為 'length()\\=\\=0' \\#loc
string.format.choose.class=選擇格式化程序類別
string.format.class.label=附加格式化程序類別\\:
string.format.class.method.label=附加格式化程序方法\\:
string.indexof.replaceable.by.contains.display.name='String.indexOf()' 表達式可被取代為 'contains()'
string.replace.quickfix=移除空字串動作數
string.replaceable.by.string.buffer.display.name=非常數 'String' 可被取代為 'StringBuilder'
string.replaceable.by.string.buffer.in.loop.option=僅在迴圈中追加時發出警告
string.replaceable.by.string.buffer.problem.descriptor=非常數字串 <code>\\#ref</code> 可能應被宣告為 'StringBuilder' \\#loc
string.touppercase.tolowercase.without.locale.display.name=呼叫無區域設定的 'String.toUpperCase()' 或 'toLowerCase()'
string.touppercase.tolowercase.without.locale.problem.descriptor=在未使用國際化字串指定區域設定的情況下呼叫 <code>String.\\#ref()</code> \\#loc
stringbuffer.field.display.name='StringBuilder' 欄位
stringbuffer.field.problem.descriptor=''{0}'' 欄位 <code>\\#ref</code> \\#loc
subtraction.in.compareto.display.name='compareTo()' 中的減法
subtraction.in.compareto.problem.descriptor='compareTo()' 中的減法 <code>\\#ref</code> 可能導致溢出或精度損失 \\#loc
super.class.logger.option=在超類別有可存取的記錄器時忽略
suppress.for.tests.scope.quickfix=對 'Tests' 作用域禁止
suspicious.array.cast.display.name=可疑的陣列轉換
suspicious.array.cast.problem.descriptor=可疑轉換為 <code>\\#ref</code> \\#loc
suspicious.comparator.compare.descriptor.min.value=不建議從比較函式返回 Integer.MIN_VALUE
suspicious.comparator.compare.descriptor.non.negative=比較器從不返回負值
suspicious.comparator.compare.descriptor.non.positive=比較器從不返回正值
suspicious.comparator.compare.descriptor.non.reflexive=對於相等的元素，比較器不返回 0
suspicious.comparator.compare.descriptor.parameter.not.used=未使用 ''{0}()'' 參數 <code>\\#ref</code> \\#loc
suspicious.comparator.compare.display.name=可疑的 'Comparator.compare()' 實作
suspicious.getter.problem.descriptor=getter <code>\\#ref()</code> 返回欄位 ''{0}'' \\#loc
suspicious.getter.setter.display.name=可疑的 getter/setter
suspicious.indent.after.control.statement.display.name=沒有大括號的控制語句後存在可疑縮排
suspicious.indent.after.control.statement.problem.descriptor=''{0}'' 語句後存在可疑縮排 \\#loc
suspicious.integer.div.assignment.display.name=可疑的整數除法賦值
suspicious.integer.div.assignment.problem.descriptor=除法結果被截斷為整數
suspicious.integer.div.assignment.quickfix=轉換為 double
suspicious.literal.underscore.display.name=數字字面量中的可疑下劃線
suspicious.literal.underscore.problem.descriptor=帶下劃線的數字字面量中的組沒有長度 3 \\#loc
suspicious.package.private.access.display.name=可疑的 package-private 存取權限
suspicious.setter.problem.descriptor=setter <code>\\#ref()</code> 對欄位 ''{0}'' 賦值 \\#loc
suspicious.system.arraycopy.display.name=可疑的 'System.arraycopy()' 呼叫
suspicious.system.arraycopy.problem.descriptor.length.bigger.dest=長度始終大於 ''dest.length - destPos'' {0}
suspicious.system.arraycopy.problem.descriptor.length.bigger.src=長度始終大於 ''src.length - srcPos'' {0}
suspicious.system.arraycopy.problem.descriptor.ranges.intersect=複製到具有相交範圍的同一陣列
suspicious.system.arraycopy.problem.descriptor4=<code>\\#ref</code> 不是陣列類型 \\#loc
suspicious.system.arraycopy.problem.descriptor5=<code>\\#ref</code> 不是陣列類型 \\#loc
suspicious.system.arraycopy.problem.descriptor6=源參數類型 ''{0}'' 不可分配給類型為 ''{1}'' 的目標參數 <code>\\#ref</code> \\#loc
suspicious.to.array.call.display.name=可疑的 'Collection.toArray()' 呼叫
suspicious.to.array.call.fix.family.name=取代為正確陣列
suspicious.to.array.call.problem.descriptor=應為類型 ''{0}[]'' 的陣列，找到的是 ''{1}[]'' \\#loc
swap.equals.fix.family.name=翻轉方法呼叫
switch.expression.with.single.default.message='switch' 表達式只有 'default' case
switch.expression.with.too.few.branches.problem.descriptor=''switch'' 表達式的 case 標籤太少 ({0})，並且可能應當取代為 ''if'' 語句或條件運算符 \\#loc
switch.statement.density.display.name='switch' 語句的分支密度過低
switch.statement.density.min.option=分支的最小密度\\: %
switch.statement.density.problem.descriptor=<code>\\#ref</code> 分支密度過低({0}%) \\#loc
switch.statement.display.name='switch' 語句
switch.statement.with.confusing.declaration.display.name=在不同 'switch' 分支中使用並宣告的區域變數
switch.statement.with.confusing.declaration.problem.descriptor=區域變數 <code>\\#ref</code> 在一個 'switch' 分支中宣告，並在另一個分支中使用 \\#loc
switch.statement.with.single.default.message='switch' 語句只有 'default' case
switch.statement.with.too.few.branches.display.name=最小 'switch' 分支
switch.statement.with.too.few.branches.ignore.pattern.option=不報告模式 switch 語句
switch.statement.with.too.few.branches.min.option=最小分支數\\:
switch.statement.with.too.few.branches.problem.descriptor=''switch'' 語句的 case 標籤太少({0})，並且可能應當取代為 ''if'' 語句 \\#loc
switch.statement.with.too.many.branches.display.name=最大 'switch' 分支
switch.statement.without.default.ignore.option=忽略詳盡的 switch 語句
switch.statements.without.default.display.name=不帶 'default' 分支的 'switch' 語句
switch.statements.without.default.problem.descriptor=沒有 'default' 分支的 <code>\\#ref</code> 語句 \\#loc
synchronization.on.get.class.display.name=在 'getClass()' 上同步
synchronization.on.get.class.problem.descriptor=在 <code>\\#ref()</code> 上同步 \\#loc
synchronization.on.local.variable.or.method.parameter.display.name=在區域變數或方法參數上同步
synchronization.on.local.variable.problem.descriptor=在區域變數 <code>\\#ref</code> 上同步 \\#loc
synchronization.on.method.parameter.problem.descriptor=在方法參數 <code>\\#ref</code> 上同步 \\#loc
synchronization.on.static.field.display.name=在 'static' 欄位上同步
synchronization.on.static.field.problem.descriptor=在 'static' 欄位 <code>\\#ref</code> 上同步 \\#loc
synchronize.on.class.problem.descriptor=對類別的鎖定動作可能會產生不可預見的副作用 \\#loc
synchronize.on.lock.display.name=在 'Lock' 物件上同步
synchronize.on.lock.problem.descriptor=在 ''{0}'' 物件上同步不太可能是故意的 \\#loc
synchronize.on.non.final.field.display.name=在非 final 欄位上同步
synchronize.on.non.final.field.problem.descriptor=在非 final 欄位 <code>\\#ref</code> 上同步 \\#loc
synchronize.on.this.display.name=在 'this' 上同步
synchronize.on.this.problem.descriptor=對 'this' 的鎖定動作可能會產生不可預見的副作用 \\#loc
synchronized.method.display.name='synchronized' 方法
synchronized.method.ignore.synchronized.super.option=忽略覆寫 synchronized 方法的方法
synchronized.method.include.option=包含本地方法
synchronized.method.move.quickfix=將同步移至方法中
synchronized.method.problem.descriptor=方法 ''{0}()'' 被宣告為 <code>\\#ref</code> \\#loc
synchronized.on.direct.literal.object.problem.descriptor=在 {0} 字面量 <code>\\#ref</code> 上同步 \\#loc
synchronized.on.literal.object.name=在使用字面量初始化的物件上同步
synchronized.on.literal.object.problem.descriptor=在使用字面量初始化的 {0} <code>\\#ref</code> 上同步 \\#loc
synchronized.on.literal.object.warn.on.all.option=警告所有可能的字面量
synchronized.on.possibly.literal.object.problem.descriptor=在 {0} <code>\\#ref</code> 上同步 \\#loc
system.exit.call.display.name=呼叫 'System.exit()' 或相關方法
system.exit.call.ignore.option=在 main 方法中忽略
system.exit.call.problem.descriptor=對 <code>{0}.\\#ref()</code> 的呼叫不可移植 \\#loc
system.getenv.call.display.name=呼叫 'System.getenv()'
system.getenv.call.problem.descriptor=對 <code>System.\\#ref()</code> 的呼叫不可移植 \\#loc
system.properties.display.name=系統屬性的存取
system.properties.problem.descriptor=對 <code>Integer.\\#ref()</code> 的呼叫可能造成安全問題 \\#loc
system.properties.problem.descriptor1=對 <code>Boolean.\\#ref()</code> 的呼叫可能造成安全問題 \\#loc
system.run.finalizers.on.exit.display.name=呼叫 'System.runFinalizersOnExit()'
system.run.finalizers.on.exit.problem.descriptor=呼叫 <code>System.\\#ref()</code> \\#loc
system.set.problem.descriptor=對 <code>System.\\#ref()</code> 的呼叫可能造成安全問題 \\#loc
system.set.security.manager.display.name=呼叫 'System.setSecurityManager()'
system.set.security.manager.problem.descriptor=對 <code>System.\\#ref()</code> 的呼叫可能造成安全問題 \\#loc
tail.recursion.display.name=尾遞迴
tail.recursion.problem.descriptor=尾部遞迴呼叫 <code>\\#ref()</code> \\#loc
tail.recursion.replace.quickfix=用迭代替換尾部遞迴
text.label.in.switch.statement.display.name='switch' 語句中的文本標籤
text.label.in.switch.statement.problem.descriptor='switch' {0, choice, 1\\#語句|2\\#表達式}中存在文本標籤 <code>\\#ref\\:</code> \\#loc
the.whole.project=整個專案
this.class=此類別
this.reference.escaped.in.construction.display.name=物件建構中轉義的 'this' 參照
this.reference.escaped.in.construction.problem.descriptor=物件建構期間轉義 <code>\\#ref</code> \\#loc
thread.death.rethrown.display.name='ThreadDeath' 未重新拋出
thread.death.rethrown.problem.descriptor=ThreadDeath <code>\\#ref</code> 未重新拋出 \\#loc
thread.local.not.static.final.display.name='ThreadLocal' 欄位未被宣告為 'static final'
thread.local.not.static.final.problem.descriptor=ThreadLocal <code>\\#ref</code> 未被宣告為 'static final' \\#loc
thread.local.set.with.null.display.name=以 null 作為實參的 'ThreadLocal.set()'
thread.local.set.with.null.problem.descriptor=使用 null 作為實參的 'ThreadLocal.set()' 可能會導致記憶體泄漏
thread.local.set.with.null.quickfix=取代為 'ThreadLocal.remove()' 呼叫
thread.priority.display.name=呼叫 'Thread.setPriority()'
thread.priority.problem.descriptor=呼叫 <code>Thread.\\#ref()</code> \\#loc
thread.run.problem.descriptor=對 <code>\\#ref()</code> 的呼叫可能應當取代為 'start()' \\#loc
thread.start.in.construction.display.name=物件建構期間呼叫 'Thread.start()'
thread.start.in.construction.problem.descriptor=物件建構期間呼叫 <code>\\#ref()</code> \\#loc
thread.stop.suspend.resume.display.name=呼叫 'Thread.stop()'、'suspend()' 或 'resume()'
thread.stop.suspend.resume.problem.descriptor=呼叫 <code>Thread.\\#ref()</code> \\#loc
thread.with.default.run.method.display.name=使用預設的 'run()' 方法實例化 'Thread'
thread.with.default.run.method.problem.descriptor=使用預設的 'run()' 方法實例化 <code>\\#ref</code> \\#loc
thread.yield.display.name=呼叫 'Thread.yield()'
thread.yield.problem.descriptor=呼叫 <code>Thread.\\#ref()</code> \\#loc
three.negations.per.method.display.name=具有三個以上否定的方法
three.negations.per.method.ignore.assert.option=忽略 'assert' 語句中的否定
three.negations.per.method.ignore.option=忽略 'equals()' 方法中的否定
three.negations.per.method.problem.descriptor=<code>\\#ref</code> 包含 {0} 個否定 \\#loc
throw,from.finally.block.everywhere.option=在可能拋出已宣告異常的每一處發出警告
throw.caught.locally.display.name=通過包含 'try' 語句捕獲 'throw'
throw.caught.locally.ignore.option=忽略重新拋出的異常
throw.caught.locally.problem.descriptor=通過包含 'try' 語句捕獲 <code>\\#ref</code> \\#loc
throw.from.finally.block.display.name='throw' 位於 'finally' 塊內
throw.from.finally.block.problem.descriptor=<code>\\#ref</code> 位於 'finally' 塊內 \\#loc
throwable.instance.never.thrown.checked.exception.problem.descriptor=已檢查的異常實例 <code>\\#ref</code> 未拋出 \\#loc
throwable.instance.never.thrown.error.problem.descriptor=錯誤實例 <code>\\#ref</code> 未拋出 \\#loc
throwable.instance.never.thrown.problem.descriptor=Throwable 實例 <code>\\#ref</code> 未拋出 \\#loc
throwable.instance.never.thrown.runtime.exception.problem.descriptor=執行時異常實例 <code>new \\#ref()</code> 未拋出 \\#loc
throwable.not.thrown.display.name='Throwable' 未拋出
throwable.printed.to.system.out.display.name='Throwable' 列印到 'System.out'
throwable.printed.to.system.out.problem.descriptor=''Throwable'' 實參 <code>\\#ref</code> 到 ''System.{0}.{1}()'' 呼叫
throwable.printed.to.system.out.problem.fix.level.option=修正的日誌方法\\:
throwable.result.of.method.call.ignored.problem.descriptor=<code>\\#ref()</code> 的結果未拋出 \\#loc
throwable.supplier.only.throw.exception.name=Throwable 供應商從不返回值
throwable.supplier.only.throw.exception.problem.descriptor=Throwable 供應商不返回任何異常
throwable.supplier.only.throw.exception.quickfix=將 lambda 中的 'throw' 取代為 'return'
thrown.exceptions.per.method.display.name=方法宣告的異常過多
thrown.exceptions.per.method.limit.option=異常拋出限制\\:
thrown.exceptions.per.method.problem.descriptor=<code>\\#ref</code> 宣告的異常過多 (異常數量 \\= {0}) \\#loc
throws.runtime.exception.display.name=在 'throws' 子句中宣告的未檢查的異常
throws.runtime.exception.fix.family.name=從 'throws' 子句中移除
throws.runtime.exception.move.quickfix=將 ''{0}'' 移至 Javadoc ''@throws'' 標記中
throws.runtime.exception.problem.descriptor=在 'throws' 子句中宣告的未檢查的異常 <code>\\#ref</code> \\#loc
throws.runtime.exception.quickfix=從 ''throws'' 子句中移除 ''{0}''
time.tostring.call.display.name=呼叫 'Time.toString()'
time.tostring.call.problem.descriptor=國際化上下文中的 <code>Time.\\#ref()</code> \\#loc
to.array.call.style.display.name='Collection.toArray()' 呼叫樣式
to.array.call.style.problem.descriptor.presized=<code>\\#ref()</code> 呼叫具有預設大小的陣列實參 ''{0}'' \\#loc
to.array.call.style.problem.descriptor.zero=<code>\\#ref()</code> 呼叫具有空陣列實參 ''{0}'' \\#loc
to.array.call.style.quickfix.family.name=修復傳遞到 'toArray()' 呼叫的陣列的大小
to.array.call.style.quickfix.make.presized=將實參取代為預設大小的陣列
to.array.call.style.quickfix.make.zero=將實參取代為空陣列
too.broad.catch.display.name=過寬的 'catch' 塊
too.broad.catch.option=僅對 RuntimeException、異常、錯誤或 Throwable 發出警告(&O)
too.broad.catch.problem.descriptor=<code>\\#ref</code> 的 ''catch'' 過寬，遮罩異常 ''{0}'' \\#loc
too.broad.catch.problem.descriptor1=<code>\\#ref</code> 的 ''catch'' 過寬，遮罩異常 ''{0}'' 和 ''{1}'' \\#loc
too.broad.catch.quickfix=向 ''{0}'' 新增 ''catch'' 子句
too.broad.scope.allow.option=<html>報告使用新表達式作為初始設定式的變數<br>(可能不安全)</html>
too.broad.scope.display.name=變數作用域過寬
too.broad.scope.inspection.fix.family.name=限縮作用域
too.broad.scope.narrow.quickfix=將 ''{0}'' 的宣告移近用法
too.broad.scope.only.blocks.option=僅報告可移入內部塊的變數
too.broad.scope.problem.descriptor=變數 <code>\\#ref</code> 的作用域過寬 \\#loc
too.many.constructors.count.limit.option=建構函式計數限制\\:
too.many.constructors.display.name=建構函式過多的類別
too.many.constructors.ignore.deprecated.option=忽略棄用的建構函式
too.many.constructors.problem.descriptor=<code>\\#ref</code> 的建構函式過多 (建構函式計數 \\= {0}) \\#loc
too.many.fields.count.limit.option=欄位計數限制\\:
too.many.fields.display.name=欄位過多的類別
too.many.fields.problem.descriptor=<code>\\#ref</code> 的欄位過多 (欄位計數 \\= {0}) \\#loc
too.many.methods.display.name=方法過多的類別
too.many.methods.problem.descriptor=<code>\\#ref</code> 的方法過多 (方法計數 \\= {0}) \\#loc
trace.level.option=追蹤級別
transient.field.in.non.serializable.class.display.name=不可序列化類別中存在 transient 欄位
transient.field.in.non.serializable.class.problem.descriptor=欄位 ''{0}'' 已在不可序列化類別中標記為 <code>\\#ref</code> \\#loc
transient.field.not.initialized.display.name=transient 欄位在反序列化時未初始化
transient.field.not.initialized.problem.descriptor=transient 欄位 <code>\\#ref</code> 在反序列化時未初始化 \\#loc
trivial.if.display.name=冗餘的 'if' 語句
trivial.if.fix.family.name=簡化 'if else'
trivial.if.option.ignore.assert.statements=忽略帶有簡單 'assert' 的 'if' 語句
trivial.if.option.ignore.chained=忽略鏈式 'if' 語句
trivial.if.problem.descriptor=<code>\\#ref</code> 語句可以簡化 \\#loc
trivial.string.concatenation.display.name=與空字串串聯
trivial.string.concatenation.option.only.necessary=僅報告無需其他更改即可移除空字串的情況
trivial.string.concatenation.problem.descriptor=串聯中存在空字串
try.finally.can.be.try.with.resources.display.name='try finally' 可被取代為 'try' with resources
try.finally.can.be.try.with.resources.problem.descriptor=<code>\\#ref</code> 可以使用自動資源管理 \\#loc
try.finally.can.be.try.with.resources.quickfix=取代為 'try-with-resources'
try.statement.with.multiple.resources.name=可以拆分具有多個資源的 'try' 語句
try.statement.with.multiple.resources.quickfix=拆分具有多個資源的 'try' 語句
try.with.identical.catches.checkbox.different.comments=不報告帶有不同註釋的 catch 塊
try.with.identical.catches.display.name='try' 語句中的相同 'catch' 分支
try.with.identical.catches.problem.descriptor=''catch'' 分支與 ''{0}'' 分支相同 \\#loc
try.with.identical.catches.quickfix=摺疊 'catch' 塊
type.parameter.extends.enum.type.parameter.problem.descriptor=類型參數 <code>\\#ref</code> 隱式擴展 final 枚舉 ''{0}'' \\#loc
type.parameter.extends.enum.wildcard.problem.descriptor=萬用字元類型實參 <code>\\#ref</code> 隱式擴展了 final 枚舉 ''{0}'' \\#loc
type.parameter.extends.final.class.display.name=類型參數擴展 'final' 類別
type.parameter.extends.final.class.quickfix=將類型參數取代為實際類別
type.parameter.extends.final.class.type.parameter.problem.descriptor=類型參數 <code>\\#ref</code> 擴展 ''final'' 類別{0} \\#loc
type.parameter.extends.final.class.wildcard.problem.descriptor=萬用字元類型實參 <code>\\#ref</code> 擴展了 ''final'' 類別 ''{0}'' \\#loc
type.parameter.extends.object.display.name=類型參數顯式擴展 'Object'
type.parameter.extends.object.ignore.annotated=註解 java.lang.Object 時忽略
type.parameter.extends.object.problem.descriptor1=類型參數 <code>\\#ref</code> 顯式擴展 'java.lang.Object' \\#loc
type.parameter.extends.object.problem.descriptor2=萬用字元類型實參 <code>\\#ref</code> 顯式擴展 'java.lang.Object' \\#loc
type.parameter.hides.type.parameter.problem.descriptor=類型參數 <code>\\#ref</code> 隱藏類型參數 ''{0}'' \\#loc
type.parameter.hides.visible.type.display.name=類型參數隱藏可見類型
type.parameter.hides.visible.type.problem.descriptor=類型參數 <code>\\#ref</code> 隱藏可見類型 ''{0}'' \\#loc
type.parameter.naming.convention.element.description=類型參數
unary.plus.display.name=一元正號
unary.plus.problem.descriptor=一元 <code>\\#ref</code> 運算符 \\#loc
unary.plus.quickfix=移除一元 '+'
unchecked.exception.class.display.name=未檢查的 'Exception' 類別
unchecked.exception.class.problem.descriptor=未檢查的異常類別 <code>\\#ref</code> \\#loc
unclear.binary.expression.display.name=具有不同優先級的多個運算符
unclear.binary.expression.problem.descriptor=表達式可以使用澄清括號 \\#loc
unclear.binary.expression.quickfix=新增澄清括號
unconditional.wait.display.name=無條件的 'wait()' 呼叫
unconditional.wait.problem.descriptor=無條件呼叫 <code>\\#ref()</code> \\#loc
unnecessarily.qualified.inner.class.access.display.name=不必要的限定內部類別存取
unnecessarily.qualified.inner.class.access.option=忽略需要匯入的參照
unnecessarily.qualified.inner.class.access.problem.descriptor=使用 <code>\\#ref</code> 限定 ''{0}'' 不必要 \\#loc
unnecessarily.qualified.inner.class.access.quickfix=移除限定符
unnecessarily.qualified.static.usage.display.name=不必要的限定靜態存取
unnecessarily.qualified.static.usage.ignore.field.option=忽略不必要的限定欄位存取
unnecessarily.qualified.static.usage.ignore.method.option=忽略不必要的限定方法呼叫
unnecessarily.qualified.static.usage.problem.descriptor=對 static 方法 <code>{0}()</code> 不必要的限定呼叫 \\#loc
unnecessarily.qualified.static.usage.problem.descriptor1=對 static 欄位 <code>{0}</code> 不必要的限定存取 \\#loc
unnecessarily.qualified.statically.imported.element.display.name=不必要的限定靜態匯入元素
unnecessarily.qualified.statically.imported.element.problem.descriptor=靜態匯入元素 ''{0}'' 使用 <code>\\#ref</code> 不必要限定 \\#loc
unnecessarily.qualified.statically.imported.element.quickfix=移除不必要的限定符
unnecessary.block.statement.problem.descriptor=此語句周圍的大括號不必要 \\#loc
unnecessary.boxing.display.name=不必要的裝箱
unnecessary.boxing.inside.value.of.problem.descriptor=冗餘裝箱，可以改用 <code>{0}.{1}()</code> 呼叫 \\#loc
unnecessary.boxing.problem.descriptor=不必要的裝箱 \\#loc
unnecessary.boxing.remove.quickfix=移除裝箱
unnecessary.boxing.superfluous.option=僅報告真正多餘的裝箱表達式
unnecessary.break.display.name=不必要的 'break' 語句
unnecessary.break.problem.descriptor=<code>\\#ref</code> 語句不必要 \\#loc
unnecessary.code.block.display.name=不必要的程式碼塊
unnecessary.code.block.unwrap.quickfix=解包塊
unnecessary.constant.array.creation.expression.display.name=常數陣列建立中的冗餘 'new' 表達式
unnecessary.constant.array.creation.expression.family.quickfix=從新陣列表達式中移除類型規範
unnecessary.constant.array.creation.expression.problem.descriptor=可從新陣列表達式中移除 <code>\\#ref</code> \\#loc
unnecessary.constructor.annotation.option=忽略有註解的建構函式
unnecessary.constructor.display.name=冗餘無實參建構函式
unnecessary.constructor.problem.descriptor=無實參建構函式 <code>\\#ref()</code> 是冗餘的 \\#loc
unnecessary.constructor.remove.quickfix=移除冗餘建構函式
unnecessary.continue.display.name=不必要的 'continue' 語句
unnecessary.continue.problem.descriptor=<code>\\#ref</code> 不必要，因為是迴圈中的最後一條語句 \\#loc
unnecessary.conversion.to.string.display.name=到 'String' 的不必要轉換
unnecessary.default.display.name=枚舉 'switch' 語句的 'default' 不必要
unnecessary.default.expressions.option=僅報告 switch 表達式
unnecessary.default.problem.descriptor=<code>\\#ref</code> 分支不必要 \\#loc
unnecessary.default.quickfix=移除 'default' 分支
unnecessary.enum.constructor.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 對於枚舉建構函式是冗餘的 \\#loc
unnecessary.explicit.numeric.cast.display.name=不必要的顯式數字轉換
unnecessary.explicit.numeric.cast.problem.descriptor=''{0}'' 不必要轉換為 <code>\\#ref</code> \\#loc
unnecessary.explicit.numeric.cast.quickfix=移除轉換
unnecessary.final.on.local.variable.or.parameter.display.name=區域變數或參數上存在不必要的 'final'
unnecessary.final.on.local.variable.problem.descriptor=變數 ''{0}'' 上存在不必要的 <code>\\#ref</code> \\#loc
unnecessary.final.on.parameter.only.interface.option=僅對 abstract 或接口方法發出警告
unnecessary.final.on.parameter.problem.descriptor=參數 ''{0}'' 上存在不必要的 <code>\\#ref</code> \\#loc
unnecessary.final.report.local.variables.option=報告區域變數
unnecessary.final.report.parameters.option=報告參數
unnecessary.final.report.pattern.variables.option=報告模式變數
unnecessary.fully.qualified.name.display.name=不必要的完全限定名稱
unnecessary.fully.qualified.name.fix.family.name=取代完全限定名稱
unnecessary.fully.qualified.name.problem.descriptor1=限定符 <code>\\#ref</code> 不必要，可被取代為匯入 \\#loc
unnecessary.fully.qualified.name.problem.descriptor2=限定符 <code>\\#ref</code> 不必要，可以移除 \\#loc
unnecessary.fully.qualified.name.remove.quickfix=移除不必要的限定
unnecessary.fully.qualified.name.replace.quickfix=將限定名稱取代為匯入
unnecessary.inherit.doc.class.invalid.problem.descriptor=<code>\\#ref</code> 在類別上無效 \\#loc
unnecessary.inherit.doc.constructor.invalid.problem.descriptor=<code>\\#ref</code> 在建構函式上無效 \\#loc
unnecessary.inherit.doc.constructor.no.super.problem.descriptor=找不到繼承 Javadoc 的 super 方法 \\#loc
unnecessary.inherit.doc.display.name=不必要的 '{@inheritDoc}' Javadoc 註釋
unnecessary.inherit.doc.field.invalid.problem.descriptor=<code>\\#ref</code> 在欄位上無效 \\#loc
unnecessary.inherit.doc.module.invalid.problem.descriptor=<code>\\#ref</code> 在模組宣告上無效 \\#loc
unnecessary.inherit.doc.problem.descriptor=僅包含 <code>\\#ref</code> 的 Javadoc 註釋不必要 \\#loc
unnecessary.inherit.doc.quickfix=移除不必要的 {@inheritDoc}
unnecessary.initcause.display.name=對 'Throwable.initCause()' 的呼叫不必要
unnecessary.initcause.problem.descriptor=不必要的 <code>Throwable.\\#ref()</code> 呼叫
unnecessary.initcause.quickfix=移除 'Throwable.initCause()' 呼叫
unnecessary.inner.enum.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 對於內部枚舉是冗餘的 \\#loc
unnecessary.inner.interface.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 對於內部接口是冗餘的 \\#loc
unnecessary.inner.record.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 對於內部記錄是冗餘的
unnecessary.interface.field.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 對於接口欄位是冗餘的 \\#loc
unnecessary.interface.inner.class.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 對於接口的內部類別是冗餘的 \\#loc
unnecessary.interface.member.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 對於接口成員是冗餘的 \\#loc
unnecessary.interface.method.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 對於接口方法是冗餘的 \\#loc
unnecessary.interface.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 對於接口是冗餘的 \\#loc
unnecessary.java.doc.link.fix.family.name=移除冗餘標記
unnecessary.javadoc.link.display.name=不必要的 Javadoc 鏈接
unnecessary.javadoc.link.option=忽略 super 方法的內聯鏈接
unnecessary.javadoc.link.quickfix=移除不必要的 ''{0}''
unnecessary.javadoc.link.super.method.problem.descriptor=指向 super 方法的 <code>\\#ref</code> 不必要 \\#loc
unnecessary.javadoc.link.this.class.problem.descriptor=指向包含類別的 <code>\\#ref</code> 不必要 \\#loc
unnecessary.javadoc.link.this.method.problem.descriptor=指向此方法的 <code>\\#ref</code> 不必要 \\#loc
unnecessary.label.on.break.statement.display.name='break' 語句上的標籤不必要
unnecessary.label.on.break.statement.problem.descriptor=Break 語句上存在不必要的標籤 <code>\\#ref</code> \\#loc
unnecessary.label.on.continue.statement.display.name='continue' 語句上的不必要標籤
unnecessary.label.on.continue.statement.problem.descriptor=Continue 語句上存在不必要的標籤 <code>\\#ref</code> \\#loc
unnecessary.label.remove.quickfix=移除標籤
unnecessary.local.variable.problem.descriptor=區域變數 <code>\\#ref</code> 是冗餘的 \\#loc
unnecessary.main.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 對於 Java {0} 的 ''main'' 方法是冗餘的 \\#loc
unnecessary.modifier.display.name=不必要的修飾符
unnecessary.parentheses.conditional.option=忽略條件表達式條件周圍的圓括號
unnecessary.parentheses.display.name=不必要的圓括號
unnecessary.parentheses.option=忽略澄清圓括號
unnecessary.parentheses.problem.descriptor=<code>\\#ref</code> 周圍的圓括號不必要 \\#loc
unnecessary.parentheses.remove.quickfix=移除不必要的圓括號
unnecessary.qualifier.for.super.problem.descriptor='super' 上的限定符 <code>\\#ref</code> 在此上下文中不必要 \\#loc
unnecessary.qualifier.for.this.display.name='this' 或 'super' 的限定符不必要
unnecessary.qualifier.for.this.problem.descriptor='this' 上的限定符 <code>\\#ref</code> 在此上下文中不必要 \\#loc
unnecessary.qualifier.for.this.remove.quickfix=移除不必要的限定符
unnecessary.record.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 對於記錄是冗餘的
unnecessary.return.constructor.problem.descriptor=<code>\\#ref</code> 不必要，因為是建構函式中的最後一條語句 \\#loc
unnecessary.return.display.name=不必要的 'return' 語句
unnecessary.return.option=在具有 'else' 分支的 'if' 語句的 then 分支中忽略
unnecessary.return.problem.descriptor=<code>\\#ref</code> 不必要，因為是 'void' 方法中的最後一條語句 \\#loc
unnecessary.semicolon.display.name=不必要的分號
unnecessary.semicolon.ignore.after.enum.constants.option=忽略枚舉常數後的不必要分號
unnecessary.semicolon.problem.descriptor=不必要的分號 <code>\\#ref</code> \\#loc
unnecessary.semicolon.remove.quickfix=移除不必要的分號
unnecessary.strictfp.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 在 Java 17 和更高版本上是冗餘的
unnecessary.string.escape.display.name=不必要的轉義字元
unnecessary.string.escape.problem.descriptor=<code>{0}</code> 進行了不必要的轉義
unnecessary.string.escape.quickfix=移除不必要的轉義
unnecessary.super.constructor.display.name=對 'super()' 的呼叫不必要
unnecessary.super.constructor.problem.descriptor=<code>\\#ref</code> 不必要 \\#loc
unnecessary.super.constructor.remove.quickfix=移除不必要的 'super()'
unnecessary.super.qualifier.display.name=不必要的 'super' 限定符
unnecessary.super.qualifier.problem.descriptor=限定符 <code>\\#ref</code> 在此上下文中不必要 \\#loc
unnecessary.super.qualifier.quickfix=移除不必要的 'super' 限定符
unnecessary.temporary.object.fix.family.name=取代串聯
unnecessary.temporary.on.conversion.from.string.display.name=從 'String' 轉換時有不必要的臨時物件
unnecessary.temporary.on.conversion.to.string.display.name=轉換為 'String' 時有不必要的臨時物件
unnecessary.this.display.name=不必要的 'this' 限定符
unnecessary.this.ignore.assignments.option=忽略欄位賦值
unnecessary.this.problem.descriptor=<code>\\#ref</code> 在此上下文中不必要 \\#loc
unnecessary.this.remove.quickfix=移除不必要的 'this' 限定符
unnecessary.tostring.call.display.name=對 'toString()' 的呼叫不必要
unnecessary.tostring.call.option.report.with.empty.string=報告可被取代為帶空字串的串聯的呼叫
unnecessary.tostring.call.problem.descriptor=不必要的 <code>\\#ref()</code> 呼叫 \\#loc
unnecessary.tostring.call.problem.empty.string.descriptor=可以取代為帶空字串的串聯
unnecessary.transient.modifier.problem.descriptor=修飾符 <code>\\#ref</code> 對於 'static' 欄位是冗餘的
unnecessary.unary.minus.display.name=不必要的一元負號
unnecessary.unary.minus.problem.descriptor=不必要的一元 <code>\\#ref</code> 運算符 \\#loc
unnecessary.unary.minus.quickfix=移除一元負號並反轉父運算符號
unnecessary.unary.minus.remove.quickfix=移除雙一元減號
unnecessary.unboxing.display.name=不必要的拆箱
unnecessary.unboxing.problem.descriptor=不必要的拆箱 \\#loc
unnecessary.unboxing.remove.quickfix=移除拆箱
unnecessary.unboxing.superfluous.option=僅報告真正多餘的拆箱表達式
unnecessary.unicode.escape.display.name=不必要的 Unicode 轉義序列
unnecessary.unicode.escape.fix.family.name=取代為字元
unnecessary.unicode.escape.fix.text=取代為{0, choice, 1\\#新行|2\\#制表符|3\\#空格}字元
unnecessary.unicode.escape.problem.descriptor=Unicode 轉義序列 <code>\\#ref</code> 可被取代為 ''{0}'' \\#loc
unnecessary.unicode.escape.problem.newline.descriptor=Unicode 轉義序列 <code>\\#ref</code> 可被取代為換行字元 \\#loc
unpredictable.big.decimal.constructor.call.display.name=不可預知的 'BigDecimal' 建構函式呼叫
unpredictable.big.decimal.constructor.call.ignore.complex.literals.option=忽略具有多個字面量的建構函式呼叫 (例如 0.1 + 0.2)
unpredictable.big.decimal.constructor.call.ignore.references.option=忽略具有變量或方法呼叫實參的建構函式呼叫
unpredictable.big.decimal.constructor.call.problem.descriptor=不可預知的 <code>new \\#ref()</code> 呼叫 \\#loc
unqualified,static.usage.only.report.static.usages.option=僅報告來自非 static 上下文的靜態存取
unqualified.field.access.display.name=未使用 'this' 限定的實例欄位存取
unqualified.field.access.problem.descriptor=未使用 'this' 限定的實例欄位存取 <code>\\#ref</code> \\#loc
unqualified.inner.class.access.display.name=非限定內部類別存取
unqualified.inner.class.access.option=忽略對本地內部類別的參照
unqualified.inner.class.access.problem.descriptor=<code>\\#ref</code> 未使用外部類別限定 \\#loc
unqualified.inner.class.access.quickfix=使用外部類別限定
unqualified.method.access.display.name=未使用 'this' 限定的實例方法呼叫
unqualified.method.access.problem.descriptor=未使用 'this' 限定實例方法呼叫 <code>\\#ref()</code> \\#loc
unqualified.static.access.fix.family.name=限定靜態存取
unqualified.static.usage.display.name=非限定靜態存取
unqualified.static.usage.ignore.field.option=忽略非限定欄位存取
unqualified.static.usage.ignore.method.option=忽略非限定方法呼叫
unqualified.static.usage.problem.descriptor=非限定 static 方法呼叫 <code>\\#ref()</code> \\#loc
unqualified.static.usage.problem.descriptor1=非限定 static 欄位存取 <code>\\#ref</code> \\#loc
unqualified.static.usage.qualify.field.quickfix=限定 static 欄位存取
unqualified.static.usage.qualify.method.quickfix=限定 static 方法呼叫
unrunnable.main.method.problem.descriptor=無法執行方法 <code>\\#ref()</code>，因為包含類別沒有完全限定名稱
unsecure.random.number.generation.display.name=不安全的隨機數生成
unsecure.random.number.generation.problem.descriptor1=出於安全目的，請使用 'java.security.SecureRandom' 而不是 <code>java.lang.Math.\\#ref()</code> \\#loc
unsecure.random.number.generation.problem.descriptor2=出於安全目的，請使用 'java.security.SecureRandom' 而不是 <code>java.util.\\#ref</code> \\#loc
unsecure.random.number.generation.problem.descriptor3=出於安全目的，請使用 'java.security.SecureRandom' 而不是 <code>\\#ref</code> \\#loc
unused.import.problem.descriptor=未使用的 import <code>\\#ref</code> \\#loc
unused.label.display.name=未使用的標籤
unused.label.problem.descriptor=未使用的標籤 <code>\\#ref</code> \\#loc
unused.label.remove.quickfix=移除未使用的標籤
update.label=更新名稱開頭\\:
upper.case.field.name.not.constant.display.name=具有大寫名稱的非常數欄位
upper.case.field.name.not.constant.problem.descriptor=帶常數樣式名稱的非常數欄位 <code>\\#ref</code> \\#loc
use.0index.in.jdbc.prepared.statement.problem.descriptor=在 JDBC PreparedStatement 中使用索引 '0' \\#loc
use.0index.in.jdbc.resultset.display.name=在 JDBC ResultSet 中使用索引 0
use.0index.in.jdbc.resultset.problem.descriptor=在 JDBC ResultSet 中使用索引 '0' \\#loc
use.contentequals=使用 'contentEquals()' 與 'AbstractStringBuilder' 進行比較
use.equalsignorecase.for.case.insensitive.comparison=為不區分大小寫的比較使用 'equalsIgnoreCase()'
use.isblank.to.check.if.string.is.whitespace.or.empty=使用 'isBlank()' 檢查字串是否為空或者僅包含空格
use.obsolete.collection.type.display.name=使用廢棄的集合類型
use.obsolete.collection.type.ignore.library.arguments.option=在需要的位置忽略廢棄的集合類型
use.obsolete.collection.type.problem.descriptor=使用了廢棄的集合類型 <code>\\#ref</code> \\#loc
use.of.awt.peer.class.display.name=使用 AWT 對等類別
use.of.awt.peer.class.problem.descriptor=AWT 對等類別 <code>\\#ref</code> 的使用不可移植 \\#loc
use.of.clone.call.method.problem.descriptor=實作 <code>\\#ref()</code>
use.of.clone.call.problem.descriptor=呼叫 <code>\\#ref()</code>
use.of.clone.display.name=使用 'clone()' 或 'Cloneable'
use.of.clone.reference.problem.descriptor=使用 <code>\\#ref</code>
use.of.concrete.class.option.ignore.abstract=忽略抽象類別類型
use.of.concrete.class.option.ignore.records=忽略 Java 記錄
use.of.concrete.class.option.report.cast=報告轉換表達式中使用的類型
use.of.concrete.class.option.report.instance.fields=報告實例欄位類型
use.of.concrete.class.option.report.instanceof=報告 instanceof、patterns 或 getClass() 比較中使用的類型
use.of.concrete.class.option.report.local.variable=報告區域變數類型
use.of.concrete.class.option.report.method.returns=報告方法返回值類型
use.of.concrete.class.option.report.parameter=報告方法參數類型
use.of.concrete.class.option.report.static.fields=報告 static 欄位類型
use.of.concrete.jdbc.driver.class.display.name=使用具體的 JDBC 驅動程序類別
use.of.concrete.jdbc.driver.class.problem.descriptor=具體 JDBC 驅動程序類別 <code>\\#ref</code> 的使用不可移植 \\#loc
use.of.obsolete.date.time.api.display.name=使用廢棄的日期時間 API
use.of.obsolete.date.time.api.problem.descriptor=使用了廢棄的日期時間類型 <code>\\#ref</code> \\#loc
use.of.properties.as.hashtable.fix.family.name=修復屬性存取
use.processbuilder.class.display.name=使用 'java.lang.ProcessBuilder' 類別
use.processbuilder.class.problem.descriptor=<code>\\#ref</code> 的使用不可移植 \\#loc
use.stringtokenizer.display.name=使用 'StringTokenizer'
use.stringtokenizer.problem.descriptor=國際化上下文中的 <code>\\#ref</code> \\#loc
use.sun.classes.display.name=使用 'sun.*' 類別
use.sun.classes.problem.descriptor=Sun 提供的類別 <code>\\#ref</code> 的使用不可移植 \\#loc
use.system.out.err.display.name=使用 'System.out' 或 'System.err'
use.system.out.err.problem.descriptor=<code>\\#ref</code> 的使用可能應當取代為更可靠的日誌 \\#loc
use.system.out.err.problem.fix.err.option='System.err' 的日誌方法\\:
use.system.out.err.problem.fix.out.option='System.out' 的日誌方法\\:
utility.class.can.be.enum.display.name=實用程序類別可以是 'enum'
utility.class.code.can.be.enum.problem.descriptor=實用程序類別 <code>\\#ref</code> 可以是 'enum' \\#loc
utility.class.code.can.be.enum.quickfix=轉換為 'enum'
utility.class.display.name=實用程序類別
utility.class.problem.descriptor=類別 <code>\\#ref</code> 只有 'static' 成員，指示程序建構 \\#loc
utility.class.with.public.constructor.display.name=實用程序類別具有 'public' 建構函式
utility.class.with.public.constructor.fix.family.name=將建構函式設為非 public
utility.class.with.public.constructor.make.private.quickfix=將{0, choice, 1\\#建構函式|2\\#建構函式}設為 'private'
utility.class.with.public.constructor.make.protected.quickfix=將{0, choice, 1\\#建構函式|2\\#建構函式}設為 'protected'
utility.class.with.public.constructor.problem.descriptor=類別 <code>\\#ref</code> 只有 'static' 成員和 'public' 建構函式 \\#loc
utility.class.without.private.constructor.cant.generate.constructor.message=實用程序類別具有實例化，將不會建立 private 建構函式
utility.class.without.private.constructor.create.quickfix=生成空 'private' 建構函式
utility.class.without.private.constructor.display.name=實用程序類別沒有 'private' 建構函式
utility.class.without.private.constructor.make.quickfix=將建構函式設為 'private'
utility.class.without.private.constructor.option=忽略僅具有主方法的類別
utility.class.without.private.constructor.problem.descriptor=類別 <code>\\#ref</code> 只有 'static' 成員，缺少 'private' 建構函式 \\#loc
value.of.post.decrement.problem.descriptor=使用後減量表達式 <code>\\#ref</code> 的值 \\#loc
value.of.post.increment.problem.descriptor=使用後增量表達式 <code>\\#ref</code> 的值 \\#loc
value.of.pre.decrement.problem.descriptor=使用前減量表達式 <code>\\#ref</code> 的值 \\#loc
value.of.pre.increment.problem.descriptor=使用前增量表達式 <code>\\#ref</code> 的值 \\#loc
variable.argument.method.display.name=vararg 方法
variable.argument.method.problem.descriptor=vararg 方法 <code>\\#ref()</code> \\#loc
variable.argument.method.quickfix=將 vararg 參數轉換為數組
variable.not.used.inside.conditional.problem.descriptor=條件內未使用檢查為 'null' 的 <code>\\#ref</code> \\#loc
variable.not.used.inside.if.display.name='if' 內未使用檢查為 'null' 的參照
variable.not.used.inside.if.problem.descriptor='if' 內未使用檢查為 'null' 的 <code>\\#ref</code> \\#loc
variable.type.can.be.explicit.display.name=變數類型可以是顯式的
volatile.array.field.display.name=volatile 陣列欄位
volatile.field.problem.descriptor=類型 ''{0}'' 的 volatile 欄位 <code>\\#ref</code> \\#loc
wait.called.on.condition.display.name=在 'java.util.concurrent.locks.Condition' 物件上呼叫了 'wait()'
wait.called.on.condition.problem.descriptor=在條件物件上呼叫 <code>\\#ref()</code> \\#loc
wait.not.in.loop.display.name=未在迴圈中呼叫的 'wait()'
wait.not.in.loop.problem.descriptor=<code>\\#ref()</code> 呼叫不在迴圈中 \\#loc
wait.notify.not.in.synchronized.context.display.name='wait()' 或 'notify()' 不在同步的上下文中
wait.notify.while.not.synchronized.on.problem.descriptor=''{0}'' 未同步時呼叫 <code>\\#ref</code> \\#loc
wait.or.await.without.timeout.display.name=無超時的 'wait()' 或 'await()'
wait.or.await.without.timeout.problem.descriptor=無超時的 <code>\\#ref</code> \\#loc
wait.while.holding.two.locks.display.name=保持兩個鎖時 'wait()'
wait.while.holding.two.locks.problem.descriptor=在保持兩個鎖的情況下呼叫 <code>\\#ref()</code> \\#loc
wait.without.corresponding.notify.display.name=沒有相應 'notify()' 的 'wait()'
wait.without.corresponding.notify.problem.descriptor=在沒有相應 <code>notify()</code> 或 <code>notifyAll()</code> 的情況下呼叫 <code>\\#ref()</code> \\#loc
warn.level.and.lower.option=警告級別和更低
warn.on.label=警告物件\\:
weaken.visibility.quickfix=削弱可見性
while.can.be.foreach.display.name='while' 迴圈可被取代為增強的 'for' 迴圈
while.can.be.foreach.problem.descriptor=<code>\\#ref</code> 迴圈可被取代為增強的 'for' \\#loc
while.loop.spins.on.field.display.name='while' 迴圈在欄位上自旋
while.loop.spins.on.field.fix.family.name=修復自旋迴圈
while.loop.spins.on.field.fix.spinwait=新增 Thread.onSpinWait()
while.loop.spins.on.field.fix.volatile=將 ''{0}'' 設為 volatile
while.loop.spins.on.field.fix.volatile.spinwait=將 ''{0}'' 設為 volatile 並新增 Thread.onSpinWait()
while.loop.spins.on.field.ignore.non.empty.loops.option=僅當迴圈為空時才發出警告
while.loop.spins.on.field.problem.descriptor=<code>\\#ref</code> 迴圈在欄位上自旋 \\#loc
wrap.with.arrays.hash.code.quickfix=使用 ''{0}'' 包裝
write.only.object.display.name=只寫入物件
write.only.object.option.ignore.impure.constructors=忽略不純的建構函式
"
`;

exports[`src messages/JavaScriptBundle.properties 1`] = `
"0.is.not.a.legal.name=''{0}'' 不是合法的類別名
0.is.not.accessible.from.1=無法從 {1} 存取 {0}
0.is.not.allowed.in.interface=接口中不允許使用 {0} 
0.with.1.visibility.in.the.target.class.is.not.accessible.from.2=目標類別中可見性為 {1} 的 {0} 無法從 {2} 存取
0.with.1.visibility.is.not.accessible.from.2=可見性為 {1} 的 {0} 將無法從 {2} 存取
action.Anonymous.text.configure=組態
action.ES6.Generate.Index.description=生成 index.js/index.ts
action.ES6.Generate.Index.text=生成 index.js/index.ts
action.EnablePackageJsonMismatchedDependenciesNotification.text=啟用有關從 package.json 安裝相依項的通知
action.EslintImportCodeStyle.description=套用 ESLint 程式碼樣式規則
action.EslintImportCodeStyle.text=套用 ESLint 程式碼樣式規則
action.ExplainNodeModulesLibrariesAction.text=解釋 node__modules 庫
action.FindDuplicatedIndexedFilesInNodeModulesAction.text=在 node__modules 中尋找重複的索引檔案
action.FlowJS.Restart.All.Servers.description=重啟所有 Flow 伺服器
action.FlowJS.Restart.All.Servers.text=重啟所有 Flow 伺服器
action.Generate.Constructor.JavaScript.text=建構函式
action.Generate.GetAccessor.JavaScript.text=Getter
action.Generate.GetSetAccessor.JavaScript.text=Getter 和 Setter
action.Generate.Missing.Members.ES6.text=實作方法…
action.Generate.Missing.Members.TypeScript.text=實作成員…
action.Generate.SetAccessor.JavaScript.text=Setter
action.InstallNodeLocalDependencies$Root.text=在專案根目錄中執行 'npm install'
action.InstallNodeLocalDependencies$Root.text.template=為 {1} 執行 ''{0}''
action.InstallNodeLocalDependencies.text=安裝 Node.js 相依項
action.JS.TypeScript.Include.Generated.Declarations.description=在專案中包含 .d.ts 子檔案
action.JS.TypeScript.Include.Generated.Declarations.text=包括 '.d.ts' 子檔案
action.JSShowUsagesFloatingToolbar.description=顯示文字游標處符號的用法
action.JSShowUsagesFloatingToolbar.text=顯示用法(_S)
action.JasmineGenerateAfterEachMethodAction.text=Jasmine afterEach
action.JasmineGenerateBeforeEachMethodAction.text=Jasmine beforeEach
action.JasmineGenerateNewSpecAction.text=Jasmine Spec
action.JasmineGenerateNewSuiteAction.text=Jasmine Suite
action.JavaScript.SearchForComponentUsageAction.description=顯示當前所選組件的用法
action.JavaScript.SearchForComponentUsageAction.text=顯示組件用法
action.JavaScript.ShowComponentUsages.description=顯示當前所選組件的用法
action.JavaScript.ShowComponentUsages.text=顯示組件用法
action.JavaScriptGenerateDictionaries.text=生成 JavaScript 拼寫檢查器字典
action.LearnWebstormAction.description=檢視自定義和程式碼編輯提示以充分利用 WebStorm
action.LearnWebstormAction.text=學習 WebStorm
action.NewJavaScriptFile.description=從指定的模板建立 JavaScript 檔案
action.NewJavaScriptFile.text=JavaScript 檔案
action.NewPackageJsonFile.description=建立 package.json 檔案
action.NewPackageJsonFile.text=package.json
action.NewTypeScriptFile.description=建立新的 TypeScript 檔案
action.NewTypeScriptFile.text=TypeScript 檔案
action.NodeServicesProfilerAction.text=啟動 Node.js 服務分析
action.QUnitGenerateNewTestAction.text=QUnit Test
action.QUnitGenerateSetupAction.text=QUnit Setup
action.QUnitGenerateTearDownAction.text=QUnit TearDown
action.RestartEsLintServiceAction.description=停止執行 ESLint 服務，根據需要自動重啟
action.RestartEsLintServiceAction.text=根據需要停止和自動執行 ESLint 服務
action.RunJsbtTask.text=執行 Gulp/Grunt/npm 任務
action.StopSingleEsLintServiceAction.text=根據需要停止和自動執行服務
action.ToggleNodeCoreCodingAssistanceAction.text=切換 Node.js 的編碼輔助
action.TypeScript.Enable.Service.text=TypeScript 語言服務
action.TypeScript.Include.Sources.text=包括 JavaScript 檔案
action.TypeScript.Restart.Service.text=重啟 TypeScript 服務
action.TypeScript.Show.Structure.text=顯示 TypeScript 伺服器專案
action.TypeScript.Test.Slow.Server.text=測試慢速 TypeScript 伺服器
action.TypeScriptAddEnumTextInlayAction.text=新增枚舉顯式值
action.TypeScriptExtractTypeAlias.description=提取類型別名
action.TypeScriptExtractTypeAlias.text=類型別名…
action.already.set.for.containing.folder.or.project.description=已針對包含的目錄或專案進行設定。
action.creates.new.file.description=建立新的 {0} 檔案
action.don.t.ask.again.text=不再詢問
action.don.t.use.library.description=不使用庫
action.js.tagged.literal.injection.text=JS 標記字面量注入
action.jump.to.text=跳轉到…
action.name.disable.category=停用 {0}
action.restart.service=重啟服務
action.show.error.details.text=顯示錯誤詳細資訊
action.show.structure.text=顯示結構
action.structureview.show.object.inherited=從物件繼承
action.use.library.description=使用庫
action.view.install.text=檢視並安裝…
actionscript.space.after.dots.in.rest.parameter=在 rest 參數中的 '…' 後面
actionscript.validation.message.get.method.access.type.is.different.from.setter=Flash 編譯器錯誤 174646\\: Get 存取器方法存取類型不同於 set 存取器存取類型，應為 ''{0}''
actionscript.validation.message.set.method.access.type.is.different.from.getter=Flash 編譯器錯誤 174646\\: Set 存取器方法存取類型不同於 get 存取器存取類型，應為 ''{0}''
activity.key.node.js.name=Node.js
activity.tracker.node.modules.name=node_modules 追蹤器
add.import.binding.to.import=將匯入綁定新增到匯入
add.import.specifier.to.import=將匯入說明符新增到匯入
add.variable.to.require=新增 require 呼叫的變數
advanced.setting.js.FindInFiles.with.library.files=在“在檔案中尋找”中選擇“目錄”時，在庫檔案中搜尋
advanced.setting.js.fallback.to.old.eval.outside.of.import.graph=使用來自伺服器的類型時，回退到 IDE 類型評估器以處理當前匯入圖之外的檔案。
advanced.setting.js.fallback.to.old.eval.outside.of.import.graph.description=IDE 可以嘗試評估不在當前 TypeScript 專案(tsconfig.json) import 圖內的檔案中的類型。在這種情況下，伺服器可以載入和解析大量新檔案來提供類型。回退到 IDE 評估器可以顯著提高大型專案的性能。
advanced.setting.js.js.advanced.annotator=進階 JavaScript 註解器
advanced.setting.js.js.advanced.annotator.description=JavaScript 註解器會檢查 JS / JSX 中的基本語意 JS 錯誤。進階註解器可以發現更多錯誤，但可能會消耗更多 CPU 資源。
advanced.setting.js.jsx.advanced.annotator=進階 JSX 註解器
advanced.setting.js.jsx.advanced.annotator.description=JSX 註解器會驗證 JSX 和 TSX 中的 JSX 標籤。進階註解器可以發現更多錯誤，但可能消耗更多 CPU 資源。如果您使用 TypeScript 語言服務，請考慮停用此選項。
advanced.setting.js.jsx.client.components=醒目提示顯示 JSX 客戶端組件
advanced.setting.js.jsx.client.components.description=對 JSX 伺服器/客戶端組件使用不同的顏色。可能會消耗額外的 CPU 資源
advanced.setting.js.semantic.highlighting.accuracy=語意醒目提示準確性
advanced.setting.js.semantic.highlighting.accuracy.basic=基本
advanced.setting.js.semantic.highlighting.accuracy.description=語意醒目提示會為程式碼元素指定不同的顏色，以區分本地和全域、函式和物件等。更高的準確性可以更深入地分析程式碼，但可能會消耗更多的 CPU 資源。
advanced.setting.js.semantic.highlighting.accuracy.high=高
advanced.setting.js.semantic.highlighting.accuracy.limited=有限
advanced.setting.js.semantic.highlighting.accuracy.normal=正常
advanced.settings.js=JavaScript 和 TypeScript
and.more=以及更多…
anonymous.to.named.intention.function.name=函式名稱\\:
automatically.replace.with.template.string.on.typing=輸入 '\${' 時自動將字串字面量取代為模板字串
border.title.inspection.export.results.capitalized.location=位置
build.event.title.failed.to.list.tasks=無法列出 {0} 任務
buildTools.EditRunSettingsAction.text=編輯 ''{0}'' 設定(&E)…
buildTools.JsbtAddBuildfileAction.text=新增 {0}
buildTools.JsbtReloadTasksAction.npm.text=重新載入腳本
buildTools.JsbtReloadTasksAction.text=重新載入任務
buildTools.JsbtRemoveBuildfileAction.text=移除 {0}
buildTools.JsbtShowTasksAction.npm.text=顯示 npm 腳本
buildTools.JsbtShowTasksAction.text=顯示 {0} 任務
buildTools.ShowSettingsAction.npm.text=編輯 npm 組態(&E)…
buildTools.ShowSettingsAction.text={0}設定…
buildTools.add.with=使用 {1} 新增 {0}
buildTools.choose_buildfile.text=選擇 {0}
buildTools.edit.run.configuration=編輯執行組態
buildTools.failed.to.list.tasks=無法列出任務
buildTools.failed.to.list.tasks.details.reference=詳細資訊
buildTools.no.files.added=未新增檔案
buildTools.no.such.file=沒有此類別檔案
buildTools.no.tasks.found=未找到任務
buildTools.searchEverywhere.npm.text=執行 {0} npm 腳本
buildTools.searchEverywhere.text=執行“{0}”任務
buildTools.tooltip.click.to.show.error.details=點擊以顯示錯誤詳細資訊
buildTools.tree.sortBy.definitionOrder.text=定義順序
buildTools.tree.sortBy.name.text=名稱
buildTools.tree.sortBy.text=排序方式
bundler.configuration.automatic=自動
bundler.configuration.automatic.hint={0} 將使用當前檔案所在目錄或其任意父目錄中的 {1} 組態檔案內的模組解析規則。
bundler.configuration.automatic.how.it.works=運作方式
bundler.configuration.detect.description=檢測適合模組解析的 {0} 組態檔案\\:
bundler.configuration.disabled=已停用
bundler.configuration.field=組態檔案\\:
bundler.configuration.field.required.error=手動模式下需要組態檔案路徑
bundler.configuration.manual=手動
button.abort=中止
button.continue=繼續
button.install.update=安裝/更新
can.t.find.flow.executable=找不到 Flow 可執行檔案
cannot.modify.library.code=無法修改庫或 SDK 程式碼
cannot.parse.service.initialization.answer.0=無法解析服務初始化回復 {0}\\n
cannot.refactor.anonymous.function=現有非呼叫用法阻止呼叫點分析。
change.method.signature.and.update.delegating.call.fix.family.name=更改方法簽名並更新委託呼叫
change.method.signature.and.update.delegating.call.fix.text=更改 {0} 簽名以符合 {1} 呼叫和更新呼叫
change.method.signature.and.update.delegating.call.noname.fix.text=更改簽名以符合 {0} 呼叫和更新呼叫
change.method.signature.delegating.default.text=委託
change.method.signature.fix.family.name=更改方法簽名
change.method.signature.fix.text=更改 {0} 簽名
change.signature.call.expression.contains.spreads=函式呼叫包含傳播實參。用法將保持不變。
change.signature.column.name=名稱
change.signature.column.name.call.value=呼叫中的值
change.signature.column.name.default.parameter=預設參數
change.signature.column.name.initializer=初始設定式
change.signature.column.name.modifier=修飾符
change.signature.column.name.optional.flag=可選
change.signature.column.type=類型
change.signature.conflict.eliminating.parameter.property.breaks.usages=將參數-屬性轉換為簡單的參數將中斷 {0} 的欄位用法
change.signature.conflict.incompatible.implementation=實作 {0} 的參數個數與重構 {1} 的參數個數不同。重構期間將忽略 {2}。
change.signature.conflict.incompatible.override=覆寫 {0} 的參數個數與重構 {1} 的參數個數不同。重構期間將忽略 {2}。
change.signature.conflict.readonly.parameter.property.write.usage=將 {0} 變為唯讀將中斷非讀取用法
change.signature.dialog.title=更改 {0} 的簽名
change.signature.method.references.arguments=函式參照實參，更改簽名後代碼可能會中斷
change.signature.parameter.table.empty.message=使用  '+' 按鈕新增新參數
change.signature.tagged.template.issue=無法更新標記的模板呼叫。用法將保持不變。
change.signature.usage.view.declarations.header=要重構的方法
change.signature.value.column.title=值
changeSignature.vararg.not.last=Rest 參數應當為方法簽名中的最後一個參數
checkbox.collapse.array.literals=陣列字面量
checkbox.collapse.object.literals=物件字面量
checkbox.collapse.one.line.function.literals=JavaScript 和 TypeScript 中的單行函式
checkbox.collapse.xml.literals=XML 字面量
checkbox.enable=啟用
checkbox.move.simple.expressions.to.field.initializer=將簡單表達式移至欄位初始設定式
choose.base.component.title=選擇超類別
choose.class.to.import.title=要匯入的類別
choose.declaration.element=<html><body>選擇 TypeScript 宣告</body></html>
choose.destination.scope=選擇目標作用域
choose.field.type=選擇欄位類型
choose.implementing.class=<html><body>選擇 <b>{0}</b> 的實作(找到 {1})</body></html>
choose.implementing.method=<html><body>選擇 <b>{0}</b> 的實作(找到 {1} 個)</body></html>
choose.overriding.function=<html><body>選擇 <b>{0}</b> 的覆寫函式(找到 {1} 個)</body></html>
choose.overriding.method=<html><body>選擇 <b>{0}</b> 的覆寫方法(找到 {1} 個)</body></html>
choose.subclass=<html><body>選擇 <b>{0}</b> 的子類別(找到 {1})</body></html>
choose.super.class.title=選擇超類別
choose.super.classifier=<html><body>選擇 <b>{0}</b> 的超類別或接口(找到 {1})</body></html>
choose.super.field=<html><body>選擇 <b>{0}</b> 的 Super 欄位(找到 {1})</body></html>
choose.super.function=<html><body>選擇 <b>{0}</b> 的 Super 函式(找到 {1})</body></html>
choose.super.interface.title=選擇 Super 接口
choose.super.method=<html><body>選擇 <b>{0}</b> 的 Super 方法(找到 {1})</body></html>
class.0.cannot.be.created=無法建立目標類別 {0}，因為存在同名的限定元素
class.already.contains.field.warning=類別 ''{0}'' 已包含欄位 ''{1}''。\\n是否繼續?
class.already.contains.method.warning=類別 ''{0}''已經 {1, choice, 1\\# 包含|2\\#繼承} 方法 ''{2}()''。\\n是否繼續?
class.chooser.not.available.in.dumb.mode=正在進行索引更新，選擇器不可用。
class.does.not.have.inheritors.in.current.project={0} 在當前專案中沒有繼承者
class.names={0,choice,1\\#類別|2\\#類別} {1}
class.template.title=類別
class.with.supers.template.title=包含 Super 的類別
code.vision.implementations.hint={0, choice, 1\\#1 個實作|2\\#{0,number} 個實作}
code.vision.inheritors.hint={0, choice, 1\\#1 個繼承者|2\\#{0,number} 個繼承者}
code.vision.overrides.hint={0, choice, 1\\#1 個覆寫|2\\#{0,number} 個覆寫}
code.vision.performance.watcher.notification.configure=組態…
code.vision.performance.watcher.notification.disable.code.vision=停用提示
code.vision.performance.watcher.notification.message=停用 Code Vision 提示可以通過減少 CPU 負載來提高性能。
code.vision.performance.watcher.notification.title=Code Vision 提示評估緩慢
codestyle.ui.field.prefix=欄位前綴 (&F)\\:
codestyle.ui.file.name.style=檔案命名約定 (&N)\\:
codestyle.ui.generated.jsdoc.use.types.checkbox=在 JSDoc 中包括類型 (&T)
codestyle.ui.property.prefix=屬性前綴 (&P)\\:
collection.queried.but.not.update=查詢了集合 <code>\\#ref</code> 的內容，但從未寫入
collection.updated.but.not.queried=更新了集合 <code>\\#ref</code> 的內容，但從未被查詢
command.name.add.explicit.value=新增顯式值 ''{0}''
command.name.create.javascript.file=建立 JavaScript 檔案 {0}
command.name.create.typescript.file=建立 TypeScript 檔案 {0}
command.name.extract.named.type=提取已命名類型
command.name.import=匯入 {0}
complete.import.binding=完整的匯入綁定
complete.import.name=完整的匯入名稱
configurable.JSCodeCompletionConfigurable.display.name=JavaScript
configurable.JSSmartKeysConfigurable.display.name=JavaScript
configurable.JSTemplateLangConfigurable.display.name=模板
configurable.MyConfigurable.display.name=JSX
configure.code.completion.settings=組態程式碼補全設定
configure.node.interpreter.path=組態 Node.js 路徑…
copying.files=正在複製檔案
create.button.text=建立(&C)
create.class.interfaces.label=接口(&I)\\:
create.class.name.label=名稱(&N)\\:
create.class.ok.button.text=建立
create.class.package.label=軟體套件\\:
create.class.superclass.label=超類別(&S)\\:
create.class.template.label=模板(&T)\\:
create.constructor.dialog.title=建立建構函式
create.field.dialog.title=建立欄位
create.file.name=建立檔案 ''{0}''
create.file.name.with=使用 {1} 建立檔案 ''{0}''
create.file.name.with.and=使用 {1} 和 {2} 建立檔案 ''{0}''
create.method.dialog.title=建立方法
create.mobile.view=建立檢視 ''{0}''
create.react.app.warning.deprecated=不建議使用 <b>create-react-app</b> 建立 React 應用程式。在沒有框架的情況下使用 React 時，首選方式是使用帶 <a href\\="https\\://vitejs.dev/guide/\\#trying-vite-online">Vite Bundler</a> 的模板。
custom.template.variables=自訂模板變數(&C)\\:
custom.variables.step.title.label.text=模板 ''{0}'' 中的自訂變數 (&C)\\:
declare.event.0=宣告事件 ''{0}''
declare.static=宣告 static(&S)
diagram.element.not.found={0} (未找到)
dialog.kind.0.file={0} 檔案
dialog.message.cannot.compile.typescript.config.file.incorrect=無法編譯 TypeScript。組態檔案不正確。
dialog.message.cannot.create.argument.stubs.invoked.method.function=無法建立實參存根\\: 呼叫的方法不是函式
dialog.message.cannot.determine.package.json.directory=無法確定 package.json 目錄
dialog.message.cannot.find.file=找不到檔案 {0}
dialog.message.cannot.find.module.for.import=無法建置用於匯入的模組路徑
dialog.message.cannot.find.module.types=找不到模組 @types/{0}
dialog.message.cannot.find.npx.bundled.with=找不到使用 {0} 捆綁的 npx
dialog.message.cannot.infer.type.new.parameter=無法推斷新參數的類型
dialog.message.cannot.locate.wrapper.config.file=找不到包裝器組態檔案
dialog.message.cannot.proceed.when.having.non.read.usages.in.embedded.expressions=嵌入式表達式中有非讀取用法時，無法繼續
dialog.message.cannot.propagate.variable=無法傳播變數\\: {0}
dialog.message.cannot.propagate.when.having.usages.declarations.in.different.files=用法和宣告位於不同檔案中時，無法傳播
dialog.message.cannot.transform.object.array.destructuring.patterns.for.same.element=無法為相同的元素轉換物件和陣列解構模式
dialog.message.command.supported.by={1} 不支持指令 ''{0}''
dialog.message.component.name=組件名稱\\:
dialog.message.expression.indexed.by.non.numeric.value=表達式使用非數字值編制索引
dialog.message.failed.to.download.0.1=無法下載 {0}。{1}
dialog.message.incomplete.destructuring.pattern.encountered.in.code=在程式碼中遇到不完整的解構模式
dialog.message.incorrect.path.to.typescript.package=typescript 軟體套件的路徑不正確
dialog.message.invalid.npm.package=無效的 {0} 軟體套件\\: 無此類別檔案或目錄
dialog.message.invalid.npx.command=無效的 npx 指令
dialog.message.invalid.package.file.specified.but.directory.with.package.json.expected={0} 軟體套件無效\\: 指定了一個檔案，但應為包含 package.json 的目錄
dialog.message.invalid.package.no.such.directory=無效的 {0} 軟體套件\\: 無此類別目錄
dialog.message.no.npm.script=無 ''{0}'' npm 腳本
dialog.message.no.path.to.package.json.found=未找到 package.json 的路徑。
dialog.message.no.results.for.after={1} 之後沒有 {0} 的結果
dialog.message.no.such=沒有這樣的 {0}
dialog.message.node.interpreter.is.located.in.another.wsl.distribution=Node.js 解釋器位於與指定專案路徑不同的 WSL 發行版中。
dialog.message.node.interpreter.must.be.located.in.wsl=Node.js 解釋器必須位於 WSL 中，並具有指定的專案路徑。
dialog.message.node.interpreter.unspecified.error.text=請指定 Node.js 解釋器
dialog.message.package.yarn.installed.package.format.yarn.relative.path.to.package.json.package.name={0}軟體套件\\: Yarn 安裝的軟體套件格式為 ''yarn\\:[package.json 的相對路徑]\\:[軟體套件名稱]''。
dialog.message.please.select.distribution=請選擇發行版
dialog.message.please.specify.npm.scripts.to.run=請指定要執行的 npm 腳本
dialog.message.please.specify.package.json=請指定 package.json
dialog.message.please.specify.package.json.correctly=請正確指定 package.json
dialog.message.please.specify.wsl.path.to.node.js.interpreter=請指定 WSL 中安裝的 Node.js 解釋器的路徑
dialog.message.some.usages.cannot.be.updated.properly=有些用法無法正常更新。\\n匯入和匯出中的用法、字串用法或動態參照無法取代為解構。
dialog.message.some.usages.cannot.be.updated.properly.wrong.access=有些用法無法正常更新。\\n無法取代不按名稱存取屬性的用法或者不按索引存取元素的用法。
dialog.message.transforming.multiple.nested.patterns.not.supported=陣列解構不支持轉換多個嵌套模式
dialog.message.unspecified=未指定的 {0}
dialog.message.unspecified.package=未指定 {0} 軟體套件
dialog.message.unspecified.package.name=未指定軟體套件名稱。
dialog.message.unspecified.suite.name=未指定的套件名稱
dialog.message.unspecified.test.name=未指定的測試名稱
dialog.message.unsupported.destructuring.container=不支持的解構容器\\: {0}
dialog.message.usages.search.was.interrupted=用法搜尋被中斷
dialog.message.variables.from.destructuring.pattern.have.no.usages=來自於解構模式的變數沒有用法
dialog.message.write.usages.cannot.be.updated.with.destructuring=寫入用法無法通過重構進行更新
dialog.title.cannot.convert=無法轉換
dialog.title.cannot.introduce.new.interface=無法引入新接口
dialog.title.cannot.propagate=無法傳播
dialog.title.configure.coding.assistance.for.node.js.api=組態 Node.js API 編碼輔助
dialog.title.download.error=下載錯誤
dialog.title.edit.run.debug.configuration=編輯執行/偵錯組態\\: ''{0}''
dialog.title.grunt.settings=Grunt 設定
dialog.title.gulp.settings=Gulp 設定
dialog.title.missing.dependencies=缺少相依項
dialog.title.move.members=移動成員
dialog.title.new.javascript.file=新增 JavaScript 檔案
dialog.title.new.typescript.file=新增 TypeScript 檔案
dialog.title.select.navigation.target=選擇導覽目標
dialog.title.select.parameters.to.convert.to.parameter.properties=選擇要轉換為參數-屬性的參數
dialog.title.select.targets.to.convert.to.class=選擇要轉換為類別的目標
dialog.title.wsl.node.interpreter={0} WSL Node 解釋器
dialog.title.wsl.node.interpreter.edit=編輯
dialog.title.wsl.node.interpreter.edit.add=新增
directory.already.contains.file=目錄 ''{0}'' 已包含檔案 ''{1}''
duplicate.parameter.name=重複的參數名稱\\: {0}
editor.notification.label.enable.babel.file.watcher.question=是否啟用 File Watcher 以使用 Babel 將 ECMAScript 6 轉換為 ECMAScript 5?
element.name.anonymous=<匿名>
element.name.default=<預設>
entity.in.parent.description={0} ({1} 內)
env.variable.empty={0} 為空
env.variable.undefined={0} 未定義
environment.key.description.package_json.install.dependencies=指示 IDE 是否應安裝專案檔案中發現的 'package.json' 的相依項。\\n值為 'true' 或 'false'
error.not.available.in.javascript.code={0} 在 JavaScript 程式碼中不可用
error.wrong.caret.position.method.name=文字游標應置於要重構的方法的名稱處。
es6.auto.import.options.completion.add.imports=自動新增 JavaScript import
es6.auto.import.options.title=TypeScript / JavaScript
es6.change.to.default.fix=對 ''{0}'' 使用預設匯入
es6.change.to.named.import.fix=對 ''{0}'' 使用命名匯入
es6.changeSignature.call.value.not.allowed=參數 ''{0}'' 不允許使用呼叫中的值。因為沒有為前面的參數指定它。
es6.changeSignature.no.call.value=新參數 ''{0}'' 已新增。\\n指定要用於此方法的所有現有呼叫的預設值或值。
es6.code.style.path.mapping.always=始終
es6.code.style.path.mapping.different.paths=僅在指定路徑以外的檔案中
es6.code.style.path.mapping.never=從不
es6.default.export.not.declared=未在匯入的模組中宣告預設匯出
es6.extract.super.destination.label=目標檔案 (&D)\\:
es6.extract.super.different.name.expected=應為不同名稱
es6.extract.super.members.in.interface=新接口中的成員
es6.extract.super.members.in.superclass=新超類別中的成員
es6.extract.super.overload.declaration.without.implementation.conflict=類別中不允許沒有實作的多載宣告 {0}
es6.import.options.blacklist.title=不從指定路徑或路徑模式匯入\\:
es6.import.options.exts.help=此選項用於組態 import 語句中的副檔名。<br><br>選擇“自動”時，IDE 會向 vue 檔案、來自在 package.json 中具有 "type"\\: "module" 的專案的檔案，以及擴展名為 .mjs 或 .cjs 的檔案的名稱新增副檔名。<br><br>選擇“始終”時，IDE 會始終向檔名新增副檔名。<br><br>選擇“從不”時，IDE 會始終使用不帶副檔名的檔名。
es6.import.options.not.import.help=此選項會組態 IDE 在自動匯入符號期間跳過的確切路徑。相反，IDE 將尋找替代路徑來匯入符號。路徑應符合 glob 模式規則。
es6.import.options.paths=使用路徑別名\\:
es6.import.options.paths.help=此選項用於組態 import 語句中使用的路徑樣式。<br><br>選擇“始終”時，IDE 會始終使用來自 webpack、vite 或 jsconfig.json 組態的別名。<br><br>選擇“僅在指定路徑之外的檔案中”時，IDE 會針對為之定義了別名的檔案之間的匯入使用相對路徑。在所有其他檔案中，使用路徑映射。<br><br>選擇“從不”時，則從不使用別名。
es6.insert.await.fix=插入 await
es6.missing.await.report.for.promises=報告 return 語句中的 promise
es6.missing.await.report.for.promises.hint=在異步函式呼叫前插入 'await' 有助於 V8 提供異步堆疊追蹤
es6.move.module.members.cannot.detect.js.language=目標檔案不是 JS 檔案
es6.move.module.members.destination.contains.default.export=目標模組包含預設匯出
es6.move.module.members.destination.does.not.support.jsx={0} 包含 JSX 標籤，但目標語言不支持這些標籤
es6.move.module.members.destination.not.es6=目標檔案 {0} 不是 ES6 模組
es6.move.module.members.has.local.usage.message=檔案 {1} 中使用未匯出的 {0}
es6.move.module.members.incompatible.language=目標模組具有不相容的語言
es6.move.module.members.non.es6.module.usage=在非 ES6 模組的檔案 {1} 中使用 {0}
es6.move.module.members.refactoring.create.file=建立檔案
es6.move.module.members.refactoring.create.file.message=檔案 {0} 不存在。\\n是否要建立?
es6.move.module.members.refactoring.dialog.error.incorrect.module=目標模組不正確
es6.move.module.members.refactoring.dialog.error.invalid.file.name=目標檔名在此作業系統中無效
es6.move.module.members.refactoring.dialog.error.modules.same=源模組和目標模組應不同
es6.move.module.members.refactoring.dialog.error.no.script.tag=目標檔案不包含腳本標籤
es6.move.module.members.refactoring.dialog.error.no.selected.items=沒有要移動的選定成員
es6.move.module.members.refactoring.dialog.field.from=從\\:
es6.move.module.members.refactoring.dialog.field.to=到\\:
es6.move.module.members.refactoring.dialog.move.member.to=成員移動至
es6.move.module.members.refactoring.file.does.not.exist=檔案 {0} 不存在
es6.move.module.members.refactoring.name=移動模組成員
es6.move.module.members.references.local.message=選擇的 {0} 參照非匯出 {1}
es6.move.module.members.references.unresolved.import.message=選擇的 {0} 參照未解析匯入 {1}
es6.move.module.members.syntax.errors=移動 {0} 將引入語法錯誤，因為目標語言不同於源語言
es6.move.module.members.table.title=要移動的成員
es6.prefer.short.import.name=可以縮短匯入
es6.redundant.await.report.for.promises=報告 promise
es6.redundant.await.report.for.promises.hint=總是報告 'return await' 為冗餘，但這會破壞 V8 的異步堆疊追蹤功能
es6.replace.import.action.name=取代為 {0}
es6.replace.import.family.name=取代為較短的路徑
es6.validate.import.error=無法解析符號 ''{0}''
es6.validation.message.const.variable.without.initializer=不允許使用無初始設定式的 'const' 變數
escape.jsdoc.copy.pasted.text=在複製和貼上時轉義 JSDoc 前導星號
escape.pasted.text=在貼上字串字面量時轉義文本
eslint.action.fix.problems.description=通過呼叫 'eslint --fix' 修正 ESLint 問題
eslint.additional.rules.directory.field.name=其他規則目錄
eslint.code.style.apply.message=套用 ESLint 的程式碼樣式?
eslint.code.style.apply.text=是
eslint.code.style.dismiss.text=否
eslint.configurable.additionalRulesDir.browseDialogTitle=選擇 ESLint 其他規則目錄
eslint.configurable.additionalRulesDir.label=其他規則目錄 (&R)\\:
eslint.configurable.config.autoSearch.description.bodyInnerHtml=ESLint 將在要 lint 的檔案的目錄中以及連續的父目錄中尋找 .eslintrc.* 和 package.json 檔案，直至尋找到檔案系統的根目錄。<div style\\="padding-top\\:8px">要使用 package.json，請將您的組態新增到 <code>eslintConfig</code> 屬性下。</div>
eslint.configurable.config.select.config.text=選擇 ESLint 組態檔案(*.eslintrc.*)
eslint.configurable.eslintPackage.label=ESLint 軟體套件(&E)\\:
eslint.configurable.extraOptions.label=額外 eslint 選項 (&O)\\:
eslint.configurable.label.working.directories=工作目錄(&W)\\:
eslint.configurable.working.dir.field.empty.text=由最近的 .eslintrc 或 .eslintignore 檢出
eslint.configurable.working.directories.comment=路徑或 <a href\\='https\\://github.com/isaacs/node-glob\\#glob-primer'>glob 模式</a>，以分號分隔。為自動檢測留空。
eslint.configuration.file.field.name=ESLint 組態檔案
eslint.error.package.directory.expected=應為軟體套件目錄
eslint.files.pattern.comment=使用 <a href\\=''https\\://github.com/isaacs/node-glob\\#glob-primer''>glob 模式</a>，例如 <code>**/*.{js,ts}</code>
eslint.fix.problems.family.name={0}\\: 修復當前錯誤
eslint.fix.problems.text.current={0}\\: 修復當前錯誤
eslint.fix.problems.text.with.error.code={0}\\: 修復 ''{1}''
eslint.inspections.error.can.not.parse.message=無法解析訊息，應為 JSON 物件，但實際為\\: {0}
eslint.inspections.error.messages.not.array=訊息不是陣列\\: {0}
eslint.inspections.error.unexpected.language.service.response=意外的語言服務響應\\: {0}
eslint.inspections.error.unknown.message.severity=未知的訊息嚴重性\\: {0}\\n主體\\:\\n{1}
eslint.run.for.files.label=為檔案執行(&F)\\:
eslint.run.on.save=儲存時執行 eslint --fix(&U)
eslint.run.on.save.auto.configuration.comment=自動 ESLint 組態
eslint.run.on.save.checkbox.on.actions.on.save.page=執行 eslint --fix
eslint.run.on.save.disabled.comment=已停用 ESLint 整合
eslint.run.on.save.link.enable.eslint=啟用 ESLint…
eslint.run.on.save.manual.configuration.comment=手動 ESLint 組態
eslint.version.0.is.not.supported.please.upgrade.eslint=ESLint 版本 {0} 不受支援。請升級 ESLint。
extract.0.turn.refs=提取 {0} 並盡量使用 (&T)
extract.constant.type=類型(&T)\\:
extract.function.declare.arrow.function=&箭頭函式
extract.function.function=函式
extract.function.name=名稱(&N)\\:
extract.function.parameters=參數
extract.function.return.type=返回值類型(&T)\\:
extract.function.signature.preview=簽名預覽
extract.interface.command.name=提取接口
extract.method.declare.static=宣告 static(&S)
extract.subclass.command.name=從 {1} 提取子類別 {0}
extract.type.alias.command.name=提取類型別名
failed.to.download=無法下載
fetch.client.generator.title=JavaScript Fetch
field.initializer.is.not.specified=未指定欄位初始設定式
file.name.masks.to.skip.from.analysis=要在分析中排除的檔名遮罩\\:
filetype.actionscript.description=ActionScript
filetype.js.testing.snapshot.description=JavaScript 測試快照(Jest)
filetype.js.testing.snapshot.display.name=JavaScript 測試快照
filetype.jshint.config.description=JSHint 組態
filetype.jshint.config.display.name=JSHint 組態
filetype.yarn.lock.description=Yarn lock
filetype.yarn.lock.display.name=Yarn Lock
find.usages.of.base.class={1} 的方法 {0}\\n覆寫 {2} 的方法。\\n要{3}基方法嗎?
find.usages.of.base.interface={1} 的方法 {0}\\n實作 {2} 的方法。\\n要{3}基方法嗎?
flow.js.get.type=Flow JS\\:Get 類型
flow.js.show.settings=組態 Flow…
flow.js.version.not.supported=Flow JS 版本 {0} 不受支援
flow.js.widget.display.name=Flow JS
flow.js.widget.name=Flow
function.names={1}{0,choice,1\\#函式|2\\#函式} 
function.returns=函式返回值類型
function.returns.description=函式返回值類型
generate.constructor.overloads.and.fields.chooser.title=選擇要使用的多載和要初始化的欄位
generate.delegate.method.conflict.message=無法通過不同的屬性為同名成員生成委託
generate.delegate.method.conflict.message.title=無法生成委託
generate.filter.button.description=在列表中顯示 {0} 
generate.filter.button.tooltip=顯示 {0}
generate.filter.fields=欄位和屬性
generate.filter.indexers=索引器
generate.filter.methods=方法
generate.to.string.chooser.title=選擇要在 toString 函式中使用的欄位
generating.0=正在生成 {0}
generating.errors.cannot.generate=無法生成 {0}
generating.errors.in.console=檢視主控台中的錯誤(離開程式碼 {0}})
generating.installing.deps=正在安裝相依項…
generating.new.project=新增專案
generating.template.processing=模板處理
generating.with.tips=生成帶有入門提示的 Playground 專案
generating.with.tips.comment=基於 Vite 的計數器專案
generation.bindable.event=可綁定事件(&B)\\:
generation.event.constant=事件常數(&E)\\:
group.Editor.JSLibrariesMenu.description=選擇要與當前檔案一起使用的 JavaScript 庫
group.Editor.JSLibrariesMenu.text=使用 JavaScript 庫
group.Floating.CodeToolbar.JS.Refactor.text=重構
group.Floating.CodeToolbar.JS.text=浮動程式碼工具列 Web
grunt.before.run.task=執行 Grunt 任務
grunt.before.run.task.descr=執行 Grunt {0, choice, 0\\#任務|1\\#任務 |2\\#任務 }{1} [{2}]
grunt.gruntfile.not.found=未找到 Gruntfile
grunt.rc.arguments.label=實參(&R)\\:
grunt.rc.environmentVariables.label=環境(&E)\\:
grunt.rc.gruntCliPackage.label=軟體套件 grunt-cli (&P)\\:
grunt.rc.gruntfile.browseDialogTitle=選擇 Gruntfile
grunt.rc.gruntfile.label=Gruntfile (&F)\\:
grunt.rc.nodeInterpreter.label=Node 解釋器(&I)\\:
grunt.rc.nodeOptions.label=Node 選項(&O)\\:
grunt.rc.tasks.label=任務(&T)\\:
grunt.task.title=Grunt 任務
grunt.unspecified.gruntfile=未指定 Gruntfile
gulp.before.run.task=執行 gulp 任務
gulp.before.run.task.descr=執行 gulp {0, choice, 0\\#任務|1\\#任務 |2\\#任務 }{1} [{2}]
gulp.gulpfile.not.found=未找到 Gulpfile
gulp.gulpfile.unspecified=未指定 Gulpfile
gulp.rc.arguments.label=實參(&R)\\:
gulp.rc.environmentVariables.label=環境(&E)\\:
gulp.rc.gulpPackage.label=Gulp 軟體套件(&G)\\:
gulp.rc.gulpfile.browseDialogTitle=選擇 gulpfile.js
gulp.rc.gulpfile.label=Gulpfile (&F)\\:
gulp.rc.nodeInterpreter.label=Node 解釋器(&I)\\:
gulp.rc.nodeOptions.label=Node 選項(&O)\\:
gulp.rc.tasks.label=任務(&T)\\:
gulp.task.title=Gulp 任務
header.declarations.to.be.refactored=要重構的宣告
icon.icons.nodes.readonlyMark.tooltip=唯讀
ignore.unused.option.all=所有
ignore.unused.option.before.used=使用前
ignore.unused.option.none=無
implement.members.abstract=實作 abstract 成員
import.options.find.more.configuration.options=在<a>程式碼樣式</a>中尋找更多組態選項
initialize.fields.intention.visibility=可見性\\:
inlay.hints.max.one.usage.text={0,choice, 0\\#無用法|1\\#顯示用法}
inlay.hints.usages.text={0,choice, 0\\#無用法|1\\#1 個用法|2\\#{0,number}'{1,choice, |1\\#+}' 用法}
inlay.parameters.angular.show.names.for.all.args=Angular HTML 模板中的命名物件參數。<p style\\="padding-left\\: 5px; padding-top\\: 5px; font-size\\: 0.85em">注意\\: 啟用 TypeScript 服務後，請改用 "TypeScript" 組。</p>
inlay.parameters.angular.show.names.for.literal.args=Angular HTML 模板中的字面量參數。<p style\\="padding-left\\: 5px; padding-top\\: 5px; font-size\\: 0.85em">注意\\: 啟用 TypeScript 服務後，請改用 "TypeScript" 組。</p>
inlay.parameters.angular.show.names.for.pipes=<a href\\='https\\://angular.io/guide/pipes'>Angular HTML 模板中的管道。</a> <p style\\="padding-left\\: 5px; padding-top\\: 5px; font-size\\: 0.85em">注意\\: 啟用 TypeScript 服務後，請改用 "TypeScript" 組。</p>
inlay.parameters.js.only.show.names.for.all.args=非字面量實參，例如參照和表達式。
inlay.parameters.js.only.show.names.for.literal.args=字面量實參，例如基元、物件和陣列初始設定式。
inlay.parameters.js.only.show.names.for.pipes=<a href\\='https\\://github.com/tc39/proposal-pipeline-operator'>管道運算符中的參數。</a>
inlay.parameters.js.only.show.names.for.tagged=<a href\\='https\\://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals\\#tagged_templates'>標記模板中的實參<a>。
inlay.parameters.js.param.hints.show.names.for.all.args=非字面量實參，例如參照和表達式。
inlay.parameters.js.param.hints.show.names.for.tagged=標記模板中的實參。
inlay.parameters.ts.param.hints.show.names.for.literal.args=字面量實參，例如基元、物件和陣列初始設定式。<p style\\="padding-left\\: 5px; padding-top\\: 5px; font-size\\: 0.85em">注意\\: 從 TypeScript v4.4 開始，啟用“非字面量實參”時，停用此選項沒有任何效果。</p>
inlay.parameters.vuejs.show.names.for.all.args=非字面量實參。
inlay.parameters.vuejs.show.names.for.filters=<a href\\='https\\://v2.vuejs.org/v2/guide/filters.html'>篩選器(Vue 2)。</a>
inlay.parameters.vuejs.show.names.for.literal.args=字面量實參。
inline.cannot.inline.has.supers=無法內聯擴展其他類型的 {0} 
inline.cannot.inline.references.this.type=無法內聯參照 'this' 類型的接口
inline.type.used.in.reference.list=無法在''{0}'' 列表中內聯用法
insert.class.fix.name=新增類別名限定符
insert.new.keyword.fix.name=插入新關鍵字
insert.this.keyword.fix.name=新增 this 限定符
inspection.NodeCoreCodingAssistanceInspection.no.coding.assistance.message=Node.js 的編碼輔助已被停用
inspection.message.installed.version.doesn.t.match.version.range=安裝的版本 {0} 與版本範圍 {1} 不符合
inspection.message.package.installed=未安裝 {0} 軟體套件
inspection.message.package.version.specified=未指定軟體套件版本
inspection.message.reference.includes.files.outside.project=參照包括專案範圍之外的檔案
inspection.message.sm.test.runner.magnitude.assertion.failed.title=斷言失敗
inspection.update.package_json.dependency.action.text=將 ''{0}'' 更新到最新版本 {1}
inspection.update.package_json.dependency.message=有可用的 ''{0}'' 新版本\\: {1}
intellilang.tagged.literal.expression.border.title=模板標籤
intellilang.tagged.literal.injection.name.label=模式\\:
intention.category.ecmascript6=JavaScript/ECMAScript 6
intention.category.javascript=JavaScript
intention.category.react=React
intention.category.typescript=TypeScript
intention.family.name.add.required.property=新增所需的屬性
intention.family.name.enable.web.types=啟用 HTMX 支援
intention.family.name.introduce.parameter.properties.for.unused.parameters=轉換為參數屬性
intention.family.name.run.npm.install=執行 'npm install'
intention.family.name.select.in.test.tree=在測試樹中選擇
intention.family.name.suppress.with.ts.ignore=使用 @ts-ignore 禁止
intention.family.name.surround.with.tag=使用標記包圍
intention.name.add.file.to.tsconfig=將檔案 ''{0}'' 新增到 tsconfig.json
intention.name.create.library.with.files.outside.project=使用專案外部的檔案建立庫
intention.name.import.augmentation=匯入擴大 {0}
intention.name.loading.service.fixes=正在載入服務修正…
intention.name.navigate.to=導覽到 {0}
intention.name.run.npm=執行 ''{0}''
intention.name.surround.with.tag=使用 <{0}> 包圍
interface.cannot.be.extracted.from.enum=無法從枚舉中提取接口
interface.cannot.be.extracted.from.type.alias=無法從類型別名中提取接口
interface.template.title=接口
introduce.constant.target.class=目標類別(&A)\\:
introduce.field.class.constructor=類別建構函式(&C)
introduce.field.current.method=當前方法(&M)
introduce.field.declaration=欄位宣告(&D)
introduce.field.initialize.in=初始化位置
introduce.field.type=類型(&T)\\:
introduce.parameter.optional=可選參數(&O)
introduce.parameter.type=類型(&T)\\:
introduce.variable.const=const(&C)
introduce.variable.declaration=變數宣告
introduce.variable.let=let(&L)
introduce.variable.make.constant=設為常數(&C)
introduce.variable.var=var(&V)
introduce.variable.var.of.type=類型的變數(&T)\\:
invalid.field.type.expression=無效欄位類型\\: ''{0}''
invalid.identifier.value.0=無效關鍵字\\: ''{0}''
invalid.parameter.type.expression=參數類型 ''{0}'' 無效
invalid.return.type.expression=返回值類型 ''{0}'' 無效
item.already.exists={0} {1} 已存在
javascript.abstract.class.can.not.be.instantiated.message=無法實例化抽象類別
javascript.ambient.declaration.const.should.be.primitive=環境上下文中的 'const' 初始設定式必須是基元字面量或字面量枚舉參照
javascript.ambient.declaration.should.have.no.initializer=環境宣告不應有初始設定式
javascript.argument.type.mismatch=實參類型 {1} 不可分配給參數類型 {0}
javascript.argument.types.mismatch=實參類型與參數不符合
javascript.assign.parameter.to.field.intention.name=分配參數 ''{0}'' 給欄位
javascript.assigned.expression.type.mismatch=分配的表達式類型 {1} 不可分配給類型 {0}
javascript.assume.uppercase.functions.to.be.constructors=假設只有大寫的函式是建構函式
javascript.auto.import.options.add.imports.on.the.fly=動態明確 import
javascript.auto.import.options.add.on.code.completion=程式碼補全時
javascript.auto.import.options.show.popup=包含自動匯入工具提示
javascript.cannot.return.expression.from.function.with.void.result.type=無法從結果類型為 void 的函式返回值
javascript.cannot.return.expression.from.function.with.void.result.type.fix=移除返回值
javascript.change.jsdoc.type.family.name=更改 JSDoc 中元素的類型
javascript.change.language.level.family=更改 JavaScript 語言版本
javascript.change.language.level.message=更改 JavaScript 語言版本為 {0}
javascript.change.signature.invalid.function.name.0=無效函式名稱\\: ''{0}''
javascript.change.signature.invalid.parameter.declaration=無效參數\\: ''{0}''
javascript.changeSignature.call.value.not.allowed=參數 ''{0}'' 不允許使用預設值。因為沒有為前面的參數指定它。
javascript.changeSignature.no.call.value=新的必選參數 ''{0}'' 已新增。\\n指定要用於此方法的所有現有呼叫的預設值。
javascript.check.global.definitions=檢查全域作用域內的賦值
javascript.completion.several.definitions=(多個定義)
javascript.constructor.call.without.new.message=不帶 <code>new</code> 的建構函式呼叫
javascript.constructor.with.lower.case.name.used.message=建構函式名稱通常以大寫字母開頭。拼寫錯誤?
javascript.create.class.intention.name=建立類別 ''{0}''
javascript.create.constant.field.intention.name=建立常數欄位 ''{0}''
javascript.create.constant.holding.arrow.function.intention.name=建立含有常數 ''{0}'' 的箭頭函式
javascript.create.constant.intention.name=建立常數 ''{0}''
javascript.create.constructor.intention.name=在 ''{0}'' 類別中建立建構函式
javascript.create.event.handler.intention.name=建立事件處理程序 ''{0}''
javascript.create.field.holding.arrow.function.intention.name=建立含有欄位 ''{0}'' 的箭頭函式
javascript.create.field.intention.name=建立欄位 ''{0}''
javascript.create.function.intention.family=建立 JavaScript 函式或方法
javascript.create.function.intention.name=建立函式 ''{0}''
javascript.create.function.property.intention.name=建立函式屬性 ''{0}''
javascript.create.get.property.intention.name=建立 ''get'' 屬性 ''{0}''
javascript.create.interface.intention.name=建立接口 ''{0}''
javascript.create.method.intention.name=建立方法 ''{0}''
javascript.create.property.holding.arrow.function.intention.name=建立含有屬性 ''{0}'' 的箭頭函式
javascript.create.property.intention.name=建立屬性 ''{0}''
javascript.create.set.property.intention.name=建立 ''set'' 屬性 ''{0}''
javascript.create.variable.holding.arrow.function.intention.name=建立含有變數 ''{0}'' 的箭頭函式
javascript.create.variable.intention.family=建立 JavaScript 變數或屬性
javascript.create.variable.intention.name=建立變數 ''{0}''
javascript.declare.variable.in.previous.var.statement.intention.family=將 var 宣告插入之前的 var 語句
javascript.declare.variable.in.previous.var.statement.intention.name=將 ''{0}'' 的 var 宣告插入之前的 var 語句
javascript.declare.variable.intention.family.name=插入 var 宣告
javascript.declare.variable.intention.name=為 ''{1}'' 插入 {0} 宣告
javascript.deprecated.symbol.replace.fix=將棄用的程式碼取代為 {0}
javascript.deprecated.symbol.replace.fix.family=將棄用的程式碼取代為建議的取代
javascript.deprecated.symbol.used.name.message=使用了棄用的符號，請查閱文檔，以獲取更好的替代性 \\#loc
javascript.deprecated.symbol.used.name.message2=自版本 {0} 符號被標記為棄用以來，使用 {1} 作為取代用 \\#loc
javascript.destructuring.initializer=初始設定式 {0}
javascript.destructuring.variable.only=僅解構變數
javascript.element.default.instead.named=使用了預設匯入而不是命名匯入
javascript.element.is.not.accessible.message=元素不可存取 \\#loc
javascript.element.need.to.be.exported=未匯出元素
javascript.element.need.to.be.imported=未匯入元素
javascript.element.need.to.be.included.to.config=tsconfig.json 中不包含相應檔案
javascript.equality.comparison.with.coercion.display.name=相等運算符可能導致類型強制
javascript.equality.comparison.with.coercion.error.string=比較 \\#ref 可能導致意外類型強制 \\#loc
javascript.equality.comparison.with.coercion.family.name=取代但不進行類型強制
javascript.equality.comparison.with.coercion.fix=取代為 ''{0}''
javascript.equality.comparison.with.coercion.option.always=所有
javascript.equality.comparison.with.coercion.option.always.except.null=與 null 或 typeof 比較時除外
javascript.equality.comparison.with.coercion.option.only.suspicious=僅可疑表達式
javascript.equality.comparison.with.coercion.options.label=醒目提示顯示 '\\=\\=' 和 '\\!\\=' 的用法\\:
javascript.expected.class.or.descendant=應為類別 {0} 或後代
javascript.export.only.member=元素僅匯出
javascript.expression.type.implicitly.coerced.to.unrelated.type=表達式類型 {1} 隱式強制為不相關類型 {0}
javascript.extract.method.title=提取函式
javascript.falsy.typeof.guard=''typeof'' 檢查始終為 false\\: {0}'' 始終具有類型 ''{1}''
javascript.find.usages.destructuring.target.dialog=速記解構變數使用 {0} 初始化。\\n您想尋找哪些用法?
javascript.fix.add.enum.values=新增枚舉值
javascript.fix.add.override.modifier=新增覆寫修飾符
javascript.fix.add.string.enum.values=新增字串枚舉值
javascript.fix.change.parameter.type=參數 ''{0}'' 類型更改為 ''{1}''
javascript.fix.change.type=''{0}'' 類型更改為 ''{1}''
javascript.fix.create.constructor.invoke.super=建立符合 super 的建構函式
javascript.fix.create.extends=使 ''{0}'' 擴展 ''{1}''
javascript.fix.create.implements=使 ''{0}'' 實作 ''{1}''
javascript.fix.create.inheritor.family=從 super 類型繼承
javascript.fix.create.invoke.super=插入超類別建構函式呼叫
javascript.fix.create.parameter=建立參數 ''{0}''
javascript.fix.generate.argument.stubs=生成實參存根
javascript.fix.implement=實作 {0}
javascript.fix.implement.chooser.all=所有類別
javascript.fix.implement.chooser.title=從中實作成員
javascript.fix.implement.family=在派生類別中實作
javascript.fix.implement.members=實作成員
javascript.fix.implement.methods=實作方法
javascript.fix.initialize.parameter=初始化參數
javascript.fix.message.change.parameters.to.expected=將這些參數更改為預期參數
javascript.fix.message.change.return.type.to.expected=將返回值類型更改為預期類型
javascript.fix.optimize.imports=最佳化 import
javascript.fix.property.spelling.family=修復屬性名稱中可能的拼寫錯誤
javascript.fix.property.spelling.text=將拼寫調整為 ''{0}''
javascript.fix.remove.abstract.keyword=移除 'abstract' 修飾符
javascript.fix.remove.access.modifier=移除存取修飾符
javascript.fix.remove.circular.dependency=移除迴圈相依關係
javascript.fix.remove.comma=移除逗號
javascript.fix.remove.constructor=移除建構函式
javascript.fix.remove.default=移除預設子句
javascript.fix.remove.dynamic.modifier=移除動態修飾符
javascript.fix.remove.externally.visible.symbol=移除外部可見符號
javascript.fix.remove.final.modifier=移除 final 修飾符
javascript.fix.remove.initializer=移除初始設定式
javascript.fix.remove.modifier=移除修飾符
javascript.fix.remove.namespace.reference=移除命名空間參照
javascript.fix.remove.override.modifier=移除覆寫修飾符
javascript.fix.remove.parameter=移除參數
javascript.fix.remove.parameters=移除參數
javascript.fix.remove.setter.parameter.initializer=移除參數預設值
javascript.fix.remove.static.modifier=移除 static 修飾符
javascript.fix.remove.type.reference=移除類型參照
javascript.fix.remove.virtual.modifier=移除虛擬修飾符
javascript.fix.remove.visibility.modifier=移除可見性修飾符
javascript.fix.set.element.visibility=將 {0} 設為 {1}
javascript.fix.set.method.return.type=使 ''{0}'' 返回 ''{1}''
javascript.fix.visibility.family=修復可見性問題
javascript.formatting.options.panel.comments=註釋
javascript.formatting.options.panel.naming.conventions=命名約定
javascript.formatting.web.spacing.within.group=內部
javascript.formatting.web.spacing.within.interpolations=插值
javascript.formatting.web.wrapping.interpolations=插值
javascript.formatting.web.wrapping.new-line-after-start-delimiter=在 '{{' 後換行
javascript.formatting.web.wrapping.new-line-before-end-delimiter='}}' 前新起一行
javascript.ignore.unused.catch.parameters=忽略未使用的 catch 參數
javascript.ignore.unused.function.parameters=忽略未使用的參數\\:
javascript.illegal.variable.type.void=非法變數類型\\: 'void'
javascript.implement.all.interfaces=實作所有成員
javascript.implement.members.abstract=實作 abstract 成員
javascript.implement.required.interfaces=實作所需的所有成員
javascript.import.options.use.resource.root=使用相對於專案、資源或來源根目錄的路徑
javascript.incorrect.array.type.in.for-in=陣列鍵類型應為字串
javascript.incorrect.variable.type.mismatch=變數類型 {1} 不可分配給類型 {0}
javascript.indexed.property.instead.of.computed.name=索引屬性存取中括號位於單獨的行中。是否應為計算的名稱?
javascript.initializer.type.mismatch=初始設定式類型 {1} 不可分配給變數類型 {0}
javascript.inline.element.is.not.used={0} 從未使用
javascript.insert.cast.fix=插入轉換
javascript.insert.generic.wrapper.fix.family.name=使用泛型類型包裝
javascript.insert.primitive.wrapper.fix.family.name=使用基元類型包裝
javascript.insert.symbol.fix=插入{0}
javascript.insert.wrapper.fix.text=使用 ''{0}'' 包裝
javascript.instance.member.is.not.accessible.message=實例成員不可存取 \\#loc
javascript.intention.add.default.export.family.name=新增預設匯出
javascript.intention.add.export.family.name=新增匯出
javascript.intention.add.export.fix.text=將 {0} 匯出在檔案 {1} 中
javascript.intention.add.template.argument=插入模板字串實參
javascript.intention.call.chain.to.pipe=將嵌套呼叫取代為管道表達式
javascript.intention.code.optimizations.text=正在最佳化生成的程式碼
javascript.intention.create.getter=為 ''{0}'' 建立 getter
javascript.intention.create.getter.desc=建立 getter
javascript.intention.create.getter.setter=為 ''{0}'' 建立 getter 和 setter
javascript.intention.create.getter.setter.desc=建立 getter 和 setter
javascript.intention.create.setter=為 ''{0}'' 建立 setter
javascript.intention.create.setter.desc=建立 setter
javascript.intention.expand.nullish.coalescing=展開 null 合併
javascript.intention.expand.opt.chain=展開可選鏈接
javascript.intention.expand.opt.chain.and.nullish.coalescing=展開可選鏈接和 null 合併
javascript.intention.expand.opt.chain.and.or.coalescing=展開可選鏈接並使用 ?\\: 運算符
javascript.intention.expand.opt.chain.family=將可選鏈接或 null 合併擴展到顯式檢查
javascript.intention.expand.or.coalescing=使用 ?\\: 運算符
javascript.intention.explicit.fields=宣告顯式類別欄位
javascript.intention.explicit.fields.dialog.title=選擇要顯式宣告的欄位
javascript.intention.explicit.fields.single=宣告顯式類別欄位
javascript.intention.init.fields=從參數初始化新字段
javascript.intention.init.fields.dialog.title=選擇參數以初始化欄位
javascript.intention.opt.chain.chain.and.coalesce=使用可選鏈接和 null 合併
javascript.intention.opt.chain.chain.only=使用可選鏈接
javascript.intention.opt.chain.coalesce.only=使用 null 合併
javascript.intention.opt.chain.conditional.only=使用 '||'
javascript.intention.opt.chain.family=使用可選鏈接或 null 合併
javascript.intention.pipe.to.call.chain=將管道表達式取代為嵌套呼叫
javascript.intention.promise.to.async.name=轉換為異步函式
javascript.intention.remove.export.family.name=移除匯出
javascript.intention.remove.export.inaccessible.conflict.text={0} 在 {1} 中進行了使用
javascript.interface.can.not.be.instantiated.message=無法實例化接口
javascript.introduce.breaks.operator.precedence=無法呼叫重構。\\n通過引入將更改表達式中的運算符優先級。
javascript.introduce.constant.error.expression.has.void.type=無法引入常數。\\n選定的表達式類型無效。
javascript.introduce.constant.error.no.expression.selected=無法引入常數。\\n選定內容不構成表達式。
javascript.introduce.constant.error.not.constant.expression.selected=無法引入常數。\\n選定內容不是常數表達式。
javascript.introduce.constant.in.es5=無法呼叫重構。\\n無法在 ECMAScript 3 或 ECMAScript 5 程式碼中引入常數。
javascript.introduce.constant.title=引入常數
javascript.introduce.element.already.exists=作用域中已存在同名的 {0}。
javascript.introduce.field.before.super.call=無法引入欄位。\\n在"super"呼叫前無法存取"this"。
javascript.introduce.field.constructor=建構函式
javascript.introduce.field.current.method=當前方法
javascript.introduce.field.error.expression.has.void.type=無法引入變數。\\n選定的表達式類型無效。
javascript.introduce.field.error.no.enclosing.class=無法引入欄位。\\n沒有封閉類別。
javascript.introduce.field.error.no.expression.selected=無法引入欄位。\\n選定內容不構成表達式。
javascript.introduce.field.field.declaration=欄位宣告
javascript.introduce.field.initialize.in.scope=初始化位置(&I)\\:
javascript.introduce.field.keyboard.hint=按 {0} 用於鍵盤快捷鍵
javascript.introduce.field.make.readonly=設為唯讀(&R)
javascript.introduce.field.title=引入欄位
javascript.introduce.field.visibility=可見性(&V)\\:
javascript.introduce.in.embedded.expression=無法呼叫重構。\\n無法在嵌入式表達式中引入
javascript.introduce.incorrect.context=無法引入變數。\\n選定內容包含對"this"的參照
javascript.introduce.parameter.error.expression.has.void.type=無法引入參數。\\n選定的表達式類型無效。
javascript.introduce.parameter.error.no.containing.function=無法引入參數。\\n找不到要使用的包含函式。
javascript.introduce.parameter.error.no.expression.selected=無法引入參數。\\n選定內容不構成表達式。
javascript.introduce.parameter.error.not.async.context=無法為包含 'await' 的表達式引入參數。\\n並非所有用法都包含在異步函式中
javascript.introduce.parameter.error.target.not.async=無法為包含 'await' 的表達式引入參數。\\n目標函式不是異步函式
javascript.introduce.parameter.error.yield=無法為包含 'yield 的表達式引入參數。
javascript.introduce.parameter.generate.jsdoc=生成 JSDoc
javascript.introduce.parameter.introduced.variable.value=值(&V)\\:
javascript.introduce.parameter.optional.parameter=可選參數
javascript.introduce.parameter.title=提取參數
javascript.introduce.throw.expressions.unsupported=無法呼叫重構。\\n“提取”重構中當前不支持 throw 表達式。
javascript.introduce.variable.arrow.await.referenced=無法引入。\\n選定內容包含 await 表達式
javascript.introduce.variable.arrow.function.parameter.referenced=無法引入。\\n選定內容包含對箭頭函式參數的參照
javascript.introduce.variable.error.expression.has.void.type=無法引入變數。\\n選定的表達式類型無效。
javascript.introduce.variable.error.no.expression.selected=無法引入變數。\\n選定內容不構成表達式。
javascript.introduce.variable.invalid.name=請輸入有效名稱。
javascript.introduce.variable.make.constant=設為常數
javascript.introduce.variable.name.prompt=名稱(&N)\\:
javascript.introduce.variable.replace.all.occurrences=取代所有符合項(找到 {0} 個匹配項)(&A)
javascript.introduce.variable.title=提取變數
javascript.introduce.variable.title.local=引入區域變數
javascript.introduce.variable.xml.embedded=無法在嵌入式表達式中引入變數
javascript.invalid.delete.target.message=刪除運算符目標無效，應為欄位參照
javascript.invalid.extended.unicode.escape=擴展的 Unicode 轉義僅允許介於 0x0 和 0x10FFFF 之間的值
javascript.invalid.invoker.target=無效呼叫目標
javascript.invalid.number.of.parameters=實參數量無效，應為 {0} 個
javascript.jsdoc.private.member.is.not.accessible.message=private 成員不可存取 \\#loc
javascript.jsdoc.protected.member.is.not.accessible.message=protected 成員不可存取 \\#loc
javascript.kind.unknown=未知元素
javascript.known.props.only=物件字面量只能指定已知屬性，但以下為額外屬性\\: {0}
javascript.label.visibility.package_local=internal(&I)
javascript.label.visibility.private=private(&V)
javascript.label.visibility.protected=protected(&O)
javascript.label.visibility.public=公共 (&B)
javascript.language.service.cannot.get.results=無法從語言服務獲得結果
javascript.language.service.cannot.start=無法啟動語言服務程序
javascript.language.service.default.empty.text=無錯誤
javascript.language.service.start.timeout=啟動語言服務程序超時
javascript.language.service.tracking.disabled=錯誤追蹤已停用
javascript.language.service.tracking.is.not.started=服務未啟動
javascript.language.simple.name=JavaScript
javascript.language.term.attribute=特性
javascript.language.term.attribute.value=特性值
javascript.language.term.class=類別
javascript.language.term.const=常數
javascript.language.term.const.field=常數欄位
javascript.language.term.constructor=建構函式
javascript.language.term.decorator=裝飾器
javascript.language.term.default.export=預設匯出
javascript.language.term.definition=定義
javascript.language.term.destructuring.property=解構屬性
javascript.language.term.entity.name=實體名稱
javascript.language.term.enum=枚舉
javascript.language.term.export.specifier=匯出說明符
javascript.language.term.exported.default.binding=已匯出預設綁定
javascript.language.term.external.module.reference=外部模組參照
javascript.language.term.field=欄位
javascript.language.term.file=檔案
javascript.language.term.function=函式
javascript.language.term.import.specifier=匯入說明符
javascript.language.term.import.statement=import 語句
javascript.language.term.imported.default.binding=已匯入預設綁定
javascript.language.term.inner.class=內部類別
javascript.language.term.inner.function=內部函式
javascript.language.term.inner.interface=內部接口
javascript.language.term.interface=接口
javascript.language.term.jsdoc.tag=JSDoc 標記
javascript.language.term.label=標籤
javascript.language.term.local.const=區域常數
javascript.language.term.local.variable=區域變數
javascript.language.term.method=方法
javascript.language.term.module=模組
javascript.language.term.namespace=命名空間
javascript.language.term.namespace.export=命名空間匯出
javascript.language.term.namespace.import=命名空間匯入
javascript.language.term.package=軟體套件
javascript.language.term.parameter=參數
javascript.language.term.property=屬性
javascript.language.term.readonly.field=唯讀欄位
javascript.language.term.shorthand.property=速記屬性
javascript.language.term.tag=標記
javascript.language.term.top.level=頂層
javascript.language.term.type.alias=類型別名
javascript.language.term.type.parameter=類型參數
javascript.language.term.variable=變數
javascript.language.term.xml.tag=xml 標籤
javascript.library.built.in=內建
javascript.linter.action.edit.config=編輯 {0}
javascript.linter.action.edit.property=編輯 {1} 中的 {0}
javascript.linter.action.edit.settings.text={0}設定…
javascript.linter.action.fix.problems.file.text={0}\\: 修復當前檔案
javascript.linter.action.fix.problems.name=修復 {0} 問題
javascript.linter.action.fix.problems.name.finish=已結束修復 {0} 問題
javascript.linter.action.fix.problems.name.start=已開始修復 {0} 問題
javascript.linter.action.fix.prompt=使用 {0} 重新設定所選檔案的格式?
javascript.linter.configurable.config.autoSearch.title=自動搜尋 (&S)
javascript.linter.configuration.file.title=組態檔案
javascript.linter.error.can.not.find.document=找不到 {0} 的文檔
javascript.linter.error.can.not.find.psi.file=找不到 {0} 的 PSI 檔案
javascript.linter.error.empty.path=路徑為空
javascript.linter.error.failed.to.lint=Lint {0} 失敗
javascript.linter.error.invalid.path.to.package=指定 ''{0}'' 軟體套件的正確路徑
javascript.linter.error.no.path.to.package=指定 ''{0}'' 軟體套件的路徑
javascript.linter.error.no.such.file=沒有此類別檔案
javascript.linter.error.notification.problem.with.reformatting=重新設定 {0} 的格式時出現問題\\:<br/>{1}
javascript.linter.error.package.not.installed=安裝 ''{0}'' 軟體套件
javascript.linter.error.specify.correct.path.to=指定 {0} 的正確路徑
javascript.linter.import.error.bin.file.not.found=無法 ''{1}'' 軟體套件下找到 ''{0}''
javascript.linter.import.error.entry.point.not.found=無法在 ''{0}'' 軟體套件中找到入口點
javascript.linter.import.error.generic=套用組態檔案中的程式碼樣式規則時出錯，可能是組態檔案無效。
javascript.linter.import.error.package.not.found=找不到 ''{0}'' 軟體套件
javascript.linter.import.error.timeout.processing.configuration.file=處理組態檔案時超時
javascript.linter.import.nothing.to.import={0}\\: 已套用所有已知規則
javascript.linter.import.notification={0}\\: 專案程式碼樣式和編輯器設定基於 ''{1}'' 更新。
javascript.linter.import.notification.edit=編輯 ''{0}''
javascript.linter.import.notification.reset=重設
javascript.linter.import.notification.restored=預設程式碼樣式和編輯器設定已還原
javascript.linter.import.notification.rules.applied=套用了以下 {0}\\: {1}。
javascript.linter.import.translate.config.file.error=無法套用程式碼樣式規則
javascript.linter.import.translate.config.progress.title=套用 {0} 程式碼樣式規則
javascript.linter.intention.family.name.show.details={0}\\: 顯示詳細資訊
javascript.linter.intention.name.details=詳細資訊
javascript.linter.progress.reformatting.with=正在使用 {0} 重新設定格式…
javascript.linter.radio.button.configuration.file=組態檔案(&C)\\:
javascript.linter.suppress.all.rules.for.file.description=禁止當前檔案的所有 {0} 規則
javascript.linter.suppress.all.rules.for.line.description=禁止當前行的所有 {0} 規則
javascript.linter.suppress.rule.for.file.description=禁止當前檔案的 ''{0}''
javascript.linter.suppress.rule.for.line.description=禁止當前行的 ''{0}''
javascript.linter.suppress.rules.for.file.family.name=對當前檔案禁止
javascript.linter.suppress.rules.for.line.family.name=對當前行禁止
javascript.linter.use.severity.from.config.label=使用組態檔案中的規則嚴重性
javascript.member.from.unopened.namespace.message=未開啟命名空間的成員 \\#loc
javascript.missed.argument.for.parameter=參數 {0} 缺少實參
javascript.missing.read.property=未解析的讀取屬性 \\#loc
javascript.missing.write.property=未解析的寫入屬性 \\#loc
javascript.module.dependencies.empty.got.it.text=<div align\\='left'>當前檔案或目錄沒有任何相依關係。<br/>請嘗試使用其他檔案或目錄。</div>
javascript.module.dependencies.got.it.text=<div align\\='left'>此圖顯示所選檔案或目錄具有的模組相依關係。<br/>要檢視多個檔案或目錄的相依關係，請在<i>專案檢視</i><br/>中將其選定，然後從所選專案右鍵選單中選擇<i>圖 – 顯示圖</i>。</div>
javascript.module.dependencies.got.it.title=模組相依關係圖
javascript.mutable.variable.accessible.from.closure=可從閉包存取可變變數
javascript.no.call.signatures=分配的類型不包含呼叫簽名
javascript.not.a.constructor.call.message=不是建構函式呼叫
javascript.object.is.null={0} 為 null
javascript.object.is.null.or.undefined={0} 為 null 或 undefined
javascript.object.is.possibly.null={0} 可能為 null
javascript.object.is.possibly.null.or.undefined={0} 可能為 null 或 undefined
javascript.object.is.possibly.undefined={0} 可能為 undefined
javascript.object.is.undefined={0} 未定義
javascript.object.null.or.undefined.desc=物件為 'null' 或 'undefined'
javascript.octal.literals.are.not.allowed.es5.message=前綴為 '0' 的八進制字面量已過時，不建議使用
javascript.octal.literals.are.not.allowed.es6.message=不允許使用前綴為 '0' 的八進制字面量。改用 '0o' 前綴
javascript.octal.literals.are.not.allowed.in.strict.mode=在嚴格模式下不允許八進制字面量
javascript.octal.literals.warn.always=關於 ES5-程式碼中過時八進制字面量的警告
javascript.octal.sequences.are.not.allowed.message=不允許八進制轉義序列
javascript.potentially.invalid.target.of.indexed.property.access=索引的屬性存取的目標可能無效
javascript.potentially.invalid.usage.of.class.this=通過嵌套函式的 'this.' 對類別欄位的參照存取可能無效
javascript.potentially.invalid.usage.of.this=This 的用法可能無效
javascript.private.constructor.is.not.accessible.message=private 建構函式不可存取 \\#loc
javascript.private.member.is.not.accessible.message=private 成員不可存取 \\#loc
javascript.property.is.read.only.message=唯讀屬性 \\#loc
javascript.property.is.write.only.message=只寫屬性 \\#loc
javascript.protected.constructor.is.not.accessible.message=protected 建構函式不可存取 \\#loc
javascript.protected.member.is.not.accessible.message=protected 成員不可存取 \\#loc
javascript.qualified.class.name.expected=應為限定的類別名
javascript.qualified.name.is.not.imported.message=未匯入限定名稱 \\#loc
javascript.redundant.typeof.guard=''typeof'' 檢查冗餘\\: ''{0}'' 始終具有類型 ''{1}''
javascript.refactoring.asdoc.for.abstracts=abstract 的 ASDoc
javascript.refactoring.cannot.find.usages.of.definition.to.inline=找不到要內聯的定義的用法
javascript.refactoring.cannot.inline.ambient.function=無法內聯沒有實作的宣告
javascript.refactoring.cannot.inline.complex.expression.evaluation=無法內聯複雜表達式求值
javascript.refactoring.cannot.inline.constructor=無法內聯建構函式
javascript.refactoring.cannot.inline.destructuring.rest.variable=無法內聯解構 rest 變數
javascript.refactoring.cannot.inline.destructuring.variable.with.default=無法內聯使用預設值的解構變數
javascript.refactoring.cannot.inline.function.defined.in.library=無法內聯外部庫中定義的函式
javascript.refactoring.cannot.inline.function.referencing.arguments=無法內聯參照實參的函式
javascript.refactoring.cannot.inline.function.referencing.rest.parameter=無法內聯函式參照的 rest 參數
javascript.refactoring.cannot.inline.function.with.multiple.returns=無法內聯有多個離開點的函式
javascript.refactoring.cannot.inline.interface.method=無法內聯接口方法
javascript.refactoring.cannot.inline.jsx.usage=無法內聯 JSX 標籤用法
javascript.refactoring.cannot.inline.not.initialized.variable=無法內聯未初始化的變數
javascript.refactoring.cannot.inline.overrided.or.overridden.method=無法內聯參與層次結構的方法
javascript.refactoring.cannot.inline.recursive.function=無法內聯遞迴函式
javascript.refactoring.extract.function.already.exists.in.this.scope=此作用域中已存在 {0}
javascript.refactoring.extract.function.bad.selection=所選塊應代表一組語句或表達式
javascript.refactoring.extract.function.function.used.before.declaring=選定內容包含在宣告之前使用的函式
javascript.refactoring.extract.function.multiple.exit.points=所選程式碼段有多個離開點
javascript.refactoring.extract.function.no.loop.for.break=程式碼段內沒有用於 break 語句的相應迴圈
javascript.refactoring.extract.function.no.loop.for.continue=程式碼段內沒有用於 continue 語句的相應迴圈
javascript.refactoring.extract.function.no.switch.for.break=程式碼段內沒有用於 break 語句的相應 'switch'
javascript.refactoring.extract.function.title=提取函式
javascript.refactoring.extract.function.yield.and.return=所選片段同時包含 yield 表達式和 return 語句
javascript.refactoring.function.to.es6.class.command=將函式 {0} 轉換為類別
javascript.refactoring.function.to.es6.class.defineProperty.warning.text=警告\\: 將使用“Object.defineProperty”、“Object.defineProperties”或“Object.create”建立的屬性轉換為 ES6 語法可能會影響其可枚舉性和可組態性
javascript.refactoring.inline.all.message=內聯所有參照並移除 {0} ({1}) (&A)
javascript.refactoring.inline.dialog.title=內聯{0}
javascript.refactoring.inline.function.title=內聯函式
javascript.refactoring.inline.this.only=僅內聯此參照並保留 {0}(&K)
javascript.refactoring.inline.variable.title=內聯變數
javascript.refactoring.searching.usages=尋找用法
javascript.refactoring.variable.used.as.lvalue=要內聯的變數在賦值的左側使用
javascript.refactoring.variable.value.is.changed.when.accessed.from.closure=從閉包存取時變量值被更改
javascript.rename.choose.target.message=您要重新命名哪一個?
javascript.rename.containing.file.message=是否還要將該檔案重命名為 {0}?\\n{1} 的用法和 import 語句中的檔案路徑將進行相應更新。
javascript.rename.destructuring.target.dialog.title=速記解構變數使用 {0} 初始化
javascript.rename.element.with.related.elements.title=重新命名 {0}
javascript.rename.reference.intention.name=重新命名參照
javascript.rename.related.declaration.message=是否還要重新命名 {0}?\\nimport 語句中的 {0} 用法將進行相應更新。
javascript.rename.shorthand.target.dialog.title=速記屬性使用 {0} 初始化
javascript.rename.shorthand.target.option.both.label=兩者
javascript.rename.shorthand.target.option.property.label=屬性
javascript.rename.symbol.intention.name=重新命名符號
javascript.report.unused.definitions=報告未使用的定義
javascript.report.unused.properties=報告未使用的屬性
javascript.returned.expression.type.mismatch=返回的表達式類型 {1} 不可分配給類型 {0}
javascript.service.is.disabled.in.safe.mode=服務在安全模式下被停用
javascript.service.node.error=Node 解釋器路徑不正確。請檢查解釋器設定
javascript.starting.service=啟動 {0} 服務
javascript.static.member.is.not.accessible.message=static 成員不可存取 \\#loc
javascript.strictly.check.global.vars=將未宣告的全域符號報告為錯誤
javascript.strictly.check.object.properties=將未宣告的屬性報告為錯誤
javascript.surround.with.cast=Type(expr)
javascript.surround.with.do.while=do / while
javascript.surround.with.for=for
javascript.surround.with.function=函式
javascript.surround.with.function.expression=函式表達式
javascript.surround.with.if=if
javascript.surround.with.if.cond=if (cond)
javascript.surround.with.if.else=if / else
javascript.surround.with.if.else.cond=if (cond) / else
javascript.surround.with.not.parenthesis=\\!(expr)
javascript.surround.with.object.literal=物件字面量
javascript.surround.with.parenthesis=(expr)
javascript.surround.with.try.catch=try / catch
javascript.surround.with.try.catch.finally=try / catch / finally
javascript.surround.with.try.finally=try / finally
javascript.surround.with.while=while
javascript.surround.with.with=with
javascript.suspicious.type.guard.desc=類型 guard 檢查不健全
javascript.suspicious.typeof.guard=''typeof'' 檢查無效\\: ''{0}'' 不能具有類型 ''{1}''
javascript.template.context.type=JavaScript(&R)
javascript.term.does.not.evaluate.to.function=方法表達式不是函式類型
javascript.term.does.not.evaluate.to.function.line.break=表達式不可呼叫。如果這不應是呼叫，請檢查是否缺少分號
javascript.term.does.not.evaluate.to.function.nullable=方法表達式可以為 null 或 undefined
javascript.term.does.not.evaluate.to.function2=屬性不能作為函式呼叫
javascript.term.does.not.evaluate.to.function2.fix=移除實參列表
javascript.term.nullable.indexer.qualifier=索引的表達式可以為 null 或 undefined
javascript.type.is.not.assignable.to.type=類型 {1} 不可分配給類型 {0}
javascript.undeclared.variable.name.message=隱式宣告變數 {0} \\#loc
javascript.unfiltered.for.in.loop=可能迭代意外(自訂/繼承)成員，可能缺少 hasOwnProperty 檢查
javascript.unknown.metadata.attribute=未知元資料特性
javascript.unknown.metadata.tag=未知元資料標籤
javascript.unresolved.circle.definition=匯入的圓定義
javascript.unresolved.file.or.dir=無法解析 {0} {1}
javascript.unresolved.function.name.message=未解析的函式或方法 <code>{0}()</code> \\#loc
javascript.unresolved.symbol.message=未解析的符號
javascript.unresolved.type.name.message=未解析的類型 {0} \\#loc
javascript.unresolved.variable.name.message=未解析的變數 {0} \\#loc
javascript.unresolved.variable.null.or.undefined.qualifier.message=''{0}'' 的限定符可能為 null 或 undefined \\#loc
javascript.unresolved.variable.null.qualifier.message=''{0}'' 的限定符可能為 null \\#loc
javascript.unresolved.variable.or.type.name.message=未解析的變數或類型 {0} \\#loc
javascript.unresolved.variable.or.type.name.message2=未解析的變數或類型 {0}
javascript.unresolved.variable.undefined.qualifier.message=''{0}'' 的限定符可能未定義 \\#loc
javascript.unused.import.remove=移除未使用的 'import'
javascript.unused.import.remove.specifier=移除未使用的元素
javascript.validate.imports.name=未解析的已匯入名稱
javascript.validation.destructuring.without.initializer=解構宣告必須有初始設定式
javascript.validation.fqn.to.replace.with.import=限定名稱可被取代為 import 語句
javascript.validation.generators.yield.not.assignable.to.return=類型 ''{1}'' 不可分配給類型 ''{0}''
javascript.validation.generators.yield.not.in.generator=只允許在產生器正文中使用 'yield' 表達式。
javascript.validation.generators.yield.not.iterable=表達式類型沒有定義 [Symbol.iterator] 或 [Symbol.asyncIterator]
javascript.validation.initialized.var.in.for.loop=''{0}'' 迴圈中不允許變數初始設定式
javascript.validation.message.abstract.get.accessor.not.implemented=未實作類別 {1} 的 abstract get 存取器 {0}
javascript.validation.message.abstract.method.not.implemented=未實作類別 {1} 中的 abstract 方法 {0}
javascript.validation.message.abstract.set.accessor.not.implemented=未實作類別 {1} 的 abstract set 存取器 {0}
javascript.validation.message.accessor.could.not.be.nested.under.other.function=存取器方法不能嵌套在其他函式中
javascript.validation.message.arguments.is.readonly='arguments' 唯讀
javascript.validation.message.arguments.with.rest.parameter=使用 rest 參數時，'arguments' 物件不可用
javascript.validation.message.assignment.to.const=嘗試分配給常數或唯讀變數
javascript.validation.message.assignment.to.const.fix.remove.readonly=移除唯讀修飾符
javascript.validation.message.assignment.to.const.fix.replace=取代為 let
javascript.validation.message.attribute.was.specified.multiple.times=多次指定修飾符 {0}
javascript.validation.message.base.constructor.in.not.derived=僅允許在派生建構函式中呼叫基類別建構函式
javascript.validation.message.baseMethod.before.super.call=超類別建構函式呼叫前不允許有 'super'
javascript.validation.message.break.without.target=無法確定 'break' 的目標
javascript.validation.message.can.not.override.final.method=無法從{0}覆寫 final 方法
javascript.validation.message.circular.dependency=迴圈相依關係
javascript.validation.message.class.method.incompatible=''{1}'' 類別中的方法 ''{0}'' 不可分配給基類別 ''{2}'' 中的同一方法
javascript.validation.message.class.method.not.implemented=未實作類別 {1} 的方法 {0}
javascript.validation.message.class.name.expected.here=此處應為類別名
javascript.validation.message.class.property.incompatible=''{1}'' 類別中的屬性 ''{0}'' 不可分配給基類別 ''{2}'' 中的同一屬性
javascript.validation.message.class.property.not.implemented=未實作類別 {1} 的屬性 {0}
javascript.validation.message.class.setter.cannot.have.return.type='set' 存取器不能有返回值類型
javascript.validation.message.comma.is.not.allowed.after.last.parameter=最後一個參數後不允許有逗號
javascript.validation.message.comma.is.not.allowed.after.rest.element=rest 元素後不允許有逗號
javascript.validation.message.conflicting.definition.was.found.with.the.same.name=在命名空間 {1} 中發現衝突性的繼承宣告 {0}
javascript.validation.message.const.variable.without.initializer='const' 變數不包含初始設定式。以後無法賦予有意義的值。
javascript.validation.message.constructor.cannot.be.static=建構函式不能為 static
javascript.validation.message.constructor.cannot.have.custom.visibility=建構函式應為 public 或未指定可見性
javascript.validation.message.constructor.field.not.allowed=類別可能沒有名為 'constructor' 的非 static 欄位
javascript.validation.message.continue.outside.loop='continue' 在迴圈語句外部
javascript.validation.message.continue.without.target=無法確定 'continue' 的目標
javascript.validation.message.duplicate.catch.block=重複 catch 塊 \\#loc
javascript.validation.message.duplicate.catch.block.fix=移除重複的 catch 塊
javascript.validation.message.duplicate.declaration=重複宣告
javascript.validation.message.duplicate.declaration.fix.remove=移除類型
javascript.validation.message.duplicate.declaration.fix.text=導覽到上一個宣告 ''{0}''
javascript.validation.message.duplicate.declaration.fix.text.no.name=導覽到上一個宣告
javascript.validation.message.duplicate.default.export.declaration=一個模組不能有多個預設匯出
javascript.validation.message.duplicate.default.export.in.module=預設匯出只能在 ECMAScript-style 模組中使用
javascript.validation.message.duplicate.export.declaration=匯出宣告與已匯出的宣告 ''{0}'' 相衝突
javascript.validation.message.duplicate.label=重複標籤
javascript.validation.message.dynamic.can.be.applied.to.class=動態特性只能應用於類別宣告
javascript.validation.message.es5.function.declarations.allowed.on.top.level.or.function=禁止在程序或函式的頂層使用函式語句
javascript.validation.message.eval.cannot.be.assigned=不能在嚴格模式下分配 'eval'
javascript.validation.message.extend.final.class=無法擴展 final 類別 ''{0}''
javascript.validation.message.extend.multiple.classes=類別不能擴展多個類別
javascript.validation.message.final.modifier.allowed.only.for.methods=final 修飾符只能應用於類別和類別方法
javascript.validation.message.flowjs.path=Flow 路徑不正確
javascript.validation.message.for.await.no.async.context='for await' 只能在 'async' 函式中使用
javascript.validation.message.for.await.top.level=使用了頂層 'for await'
javascript.validation.message.function.method.invalid.overridden.parameter.type=不相容覆寫，應有類型 ''{0}''
javascript.validation.message.function.override.for.interface=對 {0} 中的方法進行了不相容的覆寫
javascript.validation.message.function.override.for.object.method=從 Object 繼承的方法無需覆寫
javascript.validation.message.function.override.incompatible.access.modifier=不相容覆寫，應有 ''{0}'' 存取修飾符
javascript.validation.message.function.override.incompatible.signature=不相容覆寫，應有簽名 ''{0}''
javascript.validation.message.function.override.incompatible.signature.generic=不相容覆寫
javascript.validation.message.function.override.incompatible.signature2=不相容覆寫，應有返回值類型 ''{0}''
javascript.validation.message.function.override.incompatible.signature3=不相容覆寫，應有種類 ''{0}''
javascript.validation.message.function.override.without.override.modifier=方法重寫了沒有 override 關鍵字的超類別 {0} 中的方法
javascript.validation.message.function.override.without.parent.method=方法不覆寫超類別的方法
javascript.validation.message.get.method.should.be.valid.type=getter 定義的返回值類型不應為 {0}
javascript.validation.message.get.method.should.have.no.parameter=getter 定義不得有形參
javascript.validation.message.get.method.type.is.different.from.setter=Get 存取器方法的類型與 set 存取器類型不相容，應為 ''{0}''
javascript.validation.message.identifier.not.allowed.in.strict.mode=在嚴格模式下不能將 ''{0}'' 用作關鍵字
javascript.validation.message.implements.for.interface.not.allowed=接口不允許有實作列表
javascript.validation.message.implements.is.not.allowed=標準 ECMAScript 中不允許有實作子句
javascript.validation.message.incompatible.override=對 {0} 中的成員進行了不相容的覆寫
javascript.validation.message.index.no.type=索引簽名參數必須具有類型註解
javascript.validation.message.index.wrong.type=索引簽名參數類型必須可以分配給 'string | number | symbol'
javascript.validation.message.interface.call.signature.not.implemented=未實作接口 {0} 的呼叫簽名
javascript.validation.message.interface.cannot.be.final.modifiers=接口不能為最終
javascript.validation.message.interface.get.accessor.not.implemented=未實作接口 {1} 的屬性 get 存取器 {0}
javascript.validation.message.interface.index.signature.not.implemented=未實作接口 {0} 的索引簽名
javascript.validation.message.interface.members.cannot.be.final.modifiers=接口成員不能為最終
javascript.validation.message.interface.members.cannot.have.access.modifiers=接口成員不能具有存取修飾符
javascript.validation.message.interface.members.cannot.have.namespace.attributes=接口成員不能具有命名空間特性
javascript.validation.message.interface.method.invalid.access.modifier=不相容實作，應有 'public' 存取修飾符
javascript.validation.message.interface.method.invalid.signature=不相容實作，應有簽名 ''{0}''
javascript.validation.message.interface.method.invalid.signature2=不相容實作，應有返回值類型 ''{0}''
javascript.validation.message.interface.method.invalid.signature3=不相容實作，應有 get / set ''{0}''
javascript.validation.message.interface.method.not.implemented=未實作來自接口 {1} 的方法 {0}
javascript.validation.message.interface.name.expected.here=此處應為接口名稱
javascript.validation.message.interface.property.not.implemented=未實作接口 {1} 的屬性 {0}
javascript.validation.message.interface.set.accessor.not.implemented=未實作接口 {1} 的屬性 set 存取器 {0}
javascript.validation.message.jsdoc.types.are.used=JSDoc 類型只能在文檔註釋內部使用
javascript.validation.message.missed.super.constructor.call=缺少超類別建構函式呼叫
javascript.validation.message.missing.catch.or.finally=缺少 catch 或 finally 子句
javascript.validation.message.must.be.lvalue={0} 中的左側無效
javascript.validation.message.nested.classes.are.not.allowed=不允許嵌套類別
javascript.validation.message.one.visibility.modifier.allowed=只允許一個可見性修飾符(public、protected、internal、private)
javascript.validation.message.only.one.default.is.allowed=\\ switch 中只允許一個預設子句
javascript.validation.message.override.can.be.applied.to.method=覆寫只能應用於函式宣告
javascript.validation.message.parameter.is.not.allowed.after.rest.parameter=rest 參數後不允許有任何參數
javascript.validation.message.parameter.non.optional.after.optional=必選參數不能位於可選參數後
javascript.validation.message.parameter.rest.optional=rest 參數不能是可選參數
javascript.validation.message.parameter.should.be.initialized=應初始化參數
javascript.validation.message.redeclaration.of.block.scope=不能重複宣告塊作用域變數
javascript.validation.message.redeclaration.of.block.scope.in.scope.of.var=塊作用域變數不能與同一塊作用域中的"var"變數或參數使用相同的名稱
javascript.validation.message.redeclaration.of.var.in.scope.of.block.scope="var" 變數不能與其可見性作用域內的塊作用域變數使用相同的名稱
javascript.validation.message.redefining.is.not.allowed=不允許重新定義 {0}
javascript.validation.message.redundant.type=顯式類型實參 {0} 可被取代為 {1}
javascript.validation.message.redundant.type.remove=可以移除顯式類型實參 {0}
javascript.validation.message.referencing.arguments.caller.callee.is.not.allowed=不允許從實參中參照 'caller' 和 'callee'
javascript.validation.message.referencing.function.arguments.property.is.not.allowed=不允許參照 'arguments' 函式屬性
javascript.validation.message.remove.unneeded.comma.fix=移除不需要的逗號
javascript.validation.message.rest.parameter.should.not.be.initialized=不應初始化 Rest 參數
javascript.validation.message.return.outside.function.definition='return' 在函式定義外部
javascript.validation.message.return.statement.required=非無效返回值類型必需具備 return 語句
javascript.validation.message.return.value.of.type.is.required=必需具備類型 {0} 的返回值
javascript.validation.message.set.method.should.be.void.or.without.type=setter 定義的返回值類型必須為未指定或無效
javascript.validation.message.set.method.should.have.one.parameter=setter 定義必須正好有一個參數
javascript.validation.message.set.method.type.is.different.from.getter=set 存取器方法的類型與 get 存取器類型不相容，應為 ''{0}''
javascript.validation.message.setter.parameter.cannot.have.initializer=Setter 定義不能具有可選參數
javascript.validation.message.static.method.cannot.be.final=靜態方法不能為最終
javascript.validation.message.static.modifier.is.allowed.only.for.class.members=僅允許類別成員使用 static 修飾符
javascript.validation.message.super.constructor.call.should.be.in.constructor=超類別建構函式呼叫應位於建構函式本體中
javascript.validation.message.super.referenced.from.static.context=在 static 上下文中參照了 'super'
javascript.validation.message.super.referenced.without.class.instance.context=在沒有類別實例上下文的情況下參照了'super'
javascript.validation.message.this.before.super.call=超類別建構函式呼叫前不允許有 'this'
javascript.validation.message.this.referenced.from.static.context=在 static 上下文中參照了 'this'
javascript.validation.message.unexpected.type.for.rest.parameter=Rest 參數不應有類型
javascript.validation.message.unknown.metadata.annotation.used=使用了未知的元資料特性
javascript.validation.message.unneeded.comma=不需要的逗號
javascript.validation.message.unresolved.component=未解析的組件 {0}
javascript.validation.message.use.namespace.reference.or.access.modifier=使用命名空間或存取修飾符
javascript.validation.multiple.var.in.for.loop=''{0}'' 迴圈中只允許一個變數
javascript.validation.new.target.not.in.function=僅允許函式宣告、函式表達式或建構函式的本體中有元屬性 'new.target'
javascript.validation.unused.import=未使用的 import
javascript.vector.literal.element.type.mismatch=矢量字面量元素類型 {1} 不可分配給類型 {0}
javascript.visibility.internal=internal
javascript.visibility.private=private
javascript.visibility.protected=protected
javascript.visibility.public=public
javascript.with.clause.assert.deprecated.message=import 特性的 'assert' 關鍵字已棄用。請改用 'with' 語法。
javascript.with.statement.is.not.allowed.in.strict.mode.message=嚴格模式下不允許使用 With 語句
jest.cannot.find.bin.file.for.package.dialog.message=找不到 ''{0}'' 軟體套件的 bin 檔案
jest.coverage.cannot.find.lcov.info.notification.content=無法顯示 Jest 覆蓋率\\: 找不到 {0}。
jest.coverage.directory.not.found.notification.content=無法從 Jest 組態中讀取 coverageDirectory 選項
jest.coverage.notification.title=Jest 覆蓋率
jest.go.to.snapshot.text=轉到 ''{0}'' 快照
jest.package.placeholder.text=軟體套件目錄的路徑，可選擇 jest、react-scripts 或 react-scripts 替代項
jest.rc.configurationFile.label=組態檔案(&C)\\:
jest.rc.configurationFile.title=選擇 Jest 組態檔案
jest.rc.jestOptions.emptyText=CLI 選項，例如 --watch 或 --env\\=jsdom
jest.rc.jestOptions.label=Jest 選項\\:
jest.rc.jestPackageField.label=Jest 軟體套件(&J)\\:
jest.snapshot.label=Jest 快照
jest.snapshot.update.all.tests.text=<link>點擊以更新所有失敗的快照</link>
jest.snapshot.update.rc.name=更新 {0} 的快照
jest.snapshot.update.single.test.text=<link>點擊以更新 ''{0}'' 的快照</link>
jest.snapshot.update.test.file.text=<link>點擊以更新 {0} 中失敗的快照</link>
jquery.documentation.not.found=找不到 jQuery 文檔
js.accessibility.check.inspection.name=已參照無法存取的 @private 和 @protected 成員
js.add.braces.to.arrow.function=向箭頭函式中新增大括號
js.add.members.to.type=將成員 {0} 新增到 ''{1}''
js.add.members.to.type.desc=將成員新增到類別或接口
js.add.then.fix=新增 '.then()'
js.align.multiline.extends.list=多行時對齊
js.align.properties.none=不對齊
js.align.properties.on.colon=冒號上
js.align.properties.on.value=值上
js.annotator.assignment.pattern.rhs=賦值模式必須位於賦值的左側
js.annotator.inspection.name=未遵循 ECMAScript 規範
js.annotator.newline.before.arrow=箭頭前不允許換行符
js.annotator.replace.with.fat.arrow=取代為粗箭頭
js.annotator.rest.element.must.be.last=rest 元素必須位於最後
js.annotator.thin.arrow.used=使用了細箭頭
js.annotator.unary.operator.within.exponential=一元運算符 ''{0}'' 不允許直接位於指數表達式之前。建議新增括號以解決歧義問題。
js.annotator.yield.cannot.be.used.inside.generator='yield' 不能用作產生器內部的關鍵字
js.anonymous.to.named.function=匿名函式轉換為命名函式
js.arrangement.group.arrow.fields.with.methods=使用包含方法的箭頭函式初始化的組欄位
js.array.new.line.after.left.bracket=在 '[' 後換行
js.array.new.line.before.right.bracket=將 ']' 置於新行中
js.arrow.function.braces.can.be.removed.fix.family.name=移除箭頭函式體周圍的大括號
js.arrow.function.braces.can.be.removed.key=箭頭函式體周圍的大括號冗餘
js.arrow.function.braces.can.be.removed.problem.description=可以移除箭頭函式體周圍的大括號
js.assigning.to.primitive.type.property=賦給基元的值將丟失
js.assignment.issues.group.name=賦值問題
js.assignment.used.as.condition.fix=將 ''\\='' 取代為 ''{0}''
js.assignment.used.as.condition.name=用作條件的賦值
js.assignment.used.as.condition.text=<code>\\#ref</code> 作為條件使用
js.await-using.in.synchronous.function='await using' 指令只能在 'async' 函式中使用
js.await.in.synchronous.function='await' 運算符只能在 'async' 函式中使用
js.await.promise.double.await.inspection=冗餘 'await await'
js.await.promise.reject.inspection=冗餘 'await Promise.reject()'
js.await.promise.resolve.fix=取代為 ''{0}''
js.await.promise.resolve.inspection=冗餘 'await Promise.resolve()'
js.await.promise.return.await.inspection=冗餘 'return await'
js.await.promise.trivial.await.inspection=非 promise 類型的冗餘 'await'
js.bitwise.operator.usage.name=按位運算符用法
js.bitwise.operator.usage.popup=使用了按位運算符
js.bitwise.operator.usage.quickfix=取代為 {0}
js.blank.lines.around.function=Around 函式\\:
js.blank.lines.around.method=方法周圍\\:
js.breadcrumbs.callback.for=\\ {0}({1}) 回調
js.chained.call.dot.on.next.line='.' 在新行
js.check.function.signature.guess.optionality=將非類型化參數視為必選
js.check.function.signature.guess.optionality.hint=如果停用，則所有未鍵入的參數均視為可選參數
js.checkbox.make.readonly=設為唯讀(&R)
js.class.context.type=類別/接口
js.class.member.expression.context.type=類別成員表達式
js.class.member.initialization.inspection.name=在 static 初始設定式中使用可能未分配的屬性
js.class.member.initialization.inspection.text=欄位 ''{1}'' 在 ''{0}'' 之後宣告，並且可能尚未分配
js.class.member.initialization.inspection.text.id=欄位 ''{0}'' 參照本身
js.class.member.statement.context.type=類別成員語句
js.closure.compiler.syntax.cyclic.inheritance=涉及 {0} 的迴圈繼承
js.closure.compiler.syntax.empty.type=空類型不可用
js.closure.compiler.syntax.implements.not.interface={0} 未用 @interface 進行註解
js.closure.compiler.syntax.inspection.name=JSDoc 標記不正確的用法
js.closure.compiler.syntax.invalid.type=類型語法無效
js.code.style.align.caption=對齊
js.code.style.align.from.clause.caption=對齊 'from' 子句
js.code.style.align.var.statements=當多行時
js.code.style.align.var.statements.and.assignments=分組時
js.code.style.array.group.name=陣列
js.code.style.do.not.align.var.statement=不對齊
js.code.style.file.name.camel.style=駝峰命名法 (appComponent)
js.code.style.file.name.lisp.style=中線命名法 (app-component)
js.code.style.file.name.mixed.style=帶後綴的中線命名法 (my-app.component)
js.code.style.file.name.pascal.style=帕斯卡命名法 (AppComponent)
js.code.style.file.name.relaxed.style=重用當前檔案的 case
js.code.style.file.name.snake.style=蛇形命名法 (app_component)
js.code.style.issues.group.name=程式碼樣式問題
js.code.style.object.literals.category.name=物件
js.code.style.punctuation.tab.title=標點
js.code.style.tab.name=JavaScript
js.code.vision.component.usages=組件用法
js.code.vision.component.usages.action=顯示組件用法
js.code.vision.component.usages.description=用於呼叫組件的“尋找用法”的可點擊提示。
js.code.vision.component.usages.tooltip=點擊檢視該組件的用法
js.command.name.auto-import-symbols=自動匯入外部符號
js.commandline.configure.language.version=為專案組態 JavaScript 語言版本
js.commandline.configure.nodejs=組態 NodeJS 解釋器並為 package.json 檔案安裝軟體套件
js.comment.matches.signature.inspection.name=不符合的 JSDoc 和函式簽名
js.comment.matches.signature.inspection.problem1=JSDoc 中未描述參數 {0}
js.comment.matches.signature.inspection.problem2=JSDoc 中描述的參數 {0} 未出現在函式簽名中
js.comment.matches.signature.inspection.quickfix=更新 JSDoc 註釋
js.comparison.with.nan.inspection.name=與 NaN 比較
js.comparison.with.nan.inspection.problem=與 NaN 的相等比較的求值結果始終為 false
js.comparison.with.nan.inspection.problem2=與 NaN 的不等比較的求值結果始終為 true
js.comparison.with.nan.inspection.quickfix=取代為 {0}isNaN(…)
js.component.usage.in.template.group.display.name=模板中的用法
js.component.usage.type.display.name=組件
js.consecutive.commas.in.array.literal.inspection.insert.undefined=插入 'undefined'
js.consecutive.commas.in.array.literal.inspection.message=陣列字面量中的連續逗號
js.consecutive.commas.in.array.literal.inspection.name=陣列字面量中的連續逗號
js.constructor.cant.have.return.type=建構函式不能有返回值類型
js.convert.default.export.to.named.intention.family=將 default export 轉換為命名 export
js.convert.default.export.to.named.intention.working=將 default export 和 import 轉換為命名 export 和 import…
js.convert.for.each.to.for.of.intention.family=將 'forEach' 取代為 'for..of' 迴圈
js.convert.for.each.to.indexed.intention.family=將 'forEach' 取代為索引的 'for' 迴圈
js.convert.for.in.to.for.of.family.name=將 'for..in' 轉換為 'for..of'
js.convert.for.in.to.for.of.inspection.text=使用了 'for..in' 而不是 'for..of'
js.convert.for.in.to.for.of.text=將 'for..in' 轉換為 'for..of'
js.convert.for.of.to.indexed.intention.family=將 'for..of' 取代為索引的 'for' 迴圈
js.convert.indexed.for.to.for.of.family.name=將帶索引的 'for' 轉換為 'for..of'
js.convert.indexed.for.to.for.of.inspection.text=已使用索引的 'for' 而不是 'for..of'
js.convert.indexed.for.to.for.of.text=將帶索引的 'for' 轉換為 'for..of'
js.convert.indexed.for.to.foreach.intention.family=將索引的 'for' 轉換為 'forEach' 呼叫
js.convert.let.to.const.inspection.text=已使用 'let' 而不是 'const'
js.convert.map.to.for.of.intention.family=將 'map' 陣列呼叫取代為 'for..of' 迴圈
js.convert.module.exports.into.es6.export.family.name=轉換為 export
js.convert.module.exports.into.es6.export.inspection.text=使用了 'module.exports' 而不是 'export'
js.convert.module.exports.into.es6.export.text=轉換為 export
js.convert.named.export.to.default.intention.family=將命名 export 轉換為 default export
js.convert.named.export.to.default.intention.working=正在將命名 export 和 import 轉換為 default export 和 import…
js.convert.parameters.to.object.intention.name=將參數轉換為物件
js.convert.parameters.to.object.non.call.usage.will.not.be.updated=不更新非呼叫用法
js.convert.parameters.to.object.usage.will.not.be.updated.for.contextual.type=方法會覆寫另一個方法。不會更新基方法
js.convert.parameters.to.object.usage.will.not.be.updated.for.spread=不會更新使用非終端傳播實參進行的呼叫
js.convert.parameters.to.object.with.interface.intention.name=將參數轉換為物件並引入接口
js.convert.require.into.es6.import.family.name=將 require() 轉換為 import
js.convert.require.into.es6.import.inspection.text=使用了 'require()' 而不是 'import'
js.convert.require.into.es6.import.inspection.withConditional.option=使用“全部修復”動作在內部作用域內轉換 require()
js.convert.require.into.es6.import.inspection.withConditional.option.description=在內部作用域內轉換 require() (例如 'if' 語句或內部函式)
js.convert.require.into.es6.import.text=將 require() 轉換為 import
js.convert.to.anonymous.function=轉換為匿名函式
js.convert.to.anonymous.function.family.name=箭頭函式轉換為匿名函式
js.convert.to.arrow.function=轉換為箭頭函式
js.convert.to.es6.class=轉換為類別
js.convert.to.es6.class.family.name=將函式及其成員宣告轉換為類別
js.convert.to.foreach.intention.name=將 'for-in' 轉換為 'forEach' 呼叫
js.convert.to.named.function=轉換為命名函式
js.convert.to.named.function.to.class.method=轉換為類別方法
js.convert.var.to.const.text=轉換為 const
js.convert.var.to.let.or.const=轉換為 let/const
js.convert.var.to.let.or.const.family.name=將 var 轉換為 let/const
js.convert.var.to.let.or.const.inspection.conservative.option=使用“全部修復”動作保守地轉換 var
js.convert.var.to.let.or.const.inspection.conservative.option.description=在第一次使用變數之前，宣告可能會移至函式器頂部。\\n要在使用“全部修復”動作時停用此行為，請選中“保守轉換 var”選項。
js.convert.var.to.let.or.const.inspection.text=已使用 'var' 而不是 'let' 或 'const'
js.convert.var.to.let.text=轉換為 let
js.copy.qualified.to.clipboard=將限定名稱複製到剪貼簿
js.create.derived.type.abstract.class=實作抽象類別
js.create.derived.type.class=建立派生類別
js.create.derived.type.family=建立派生類別/實作接口
js.create.derived.type.interface=實作接口
js.create.switch.cases=建立缺少的 'switch' 分支
js.create.switch.cases.fix=建立缺少的分支\\: {0}
js.declaration.is.not.at.scope.start=var 語句不在作用域開始
js.declarations.at.scope.start.inspection='var' 未在函式開頭宣告
js.deprecated.symbols.inspection.name=已使用棄用的符號
js.destructuring.merge.inspection=正在解構具有相同鍵的屬性
js.destructuring.merge.inspection.fix=合併解構屬性
js.destructuring.merge.inspection.text=可以合併具有多個相同鍵的解構屬性
js.dialect.settings.caption=
js.dialect.settings.dialog.title=JavaScript 語言版本
js.dialect.settings.empty.text=使用 + 按鈕新增目錄，並選擇 JavaScript 版本
js.dialect.settings.override.question=覆寫子目錄和檔案的語言版本?
js.dialect.settings.override.title=覆寫語言版本設定
js.dialect.settings.tableTitle=語言
js.dialects.customized.label=根據目錄自定義
js.documentation.fires=觸發\\:
js.documentation.jsdoc.aliases=別名\\:
js.documentation.jsdoc.dialect=方言\\:
js.documentation.jsdoc.supported-also-by=還受以下物件的支援\\:
js.documentation.more.overload=其他 +{0} 個多載
js.documentation.more.overloads=其他 +{0} 個多載
js.dot.property.access.context.type=點號屬性存取
js.duplicate.declaration.inspection.name=重複宣告
js.edit.object.literal=編輯物件字面量屬性的值
js.expand.shorthand.property.quick.fix=展開速記屬性
js.expression.context.type=表達式
js.extends.keyword.wrap=擴展關鍵字
js.extends.list.wrap=Extends 列表
js.extjs.unresolved.ext.xtype.inspection.name=未解析的 Ext JS xtype
js.file.references.inspection.ignore.complex.cases=忽略複雜 case
js.file.references.inspection.name=未解析的檔案參照
js.file.watcher.6to5.description=使用 Babel 將 ECMAScript 6 程式碼轉換成 ECMAScript 5
js.fix.change.member.access.to.sharp=使用 '\\#' 設為 private
js.flow.enable.flow.service.error=\\ 不正確的 Flow 路徑
js.flow.enable.flow.service.error.empty=Flow 可執行檔案的路徑為空
js.flow.enable.flow.service.error.message={0}。停用所有 Flow 服務或為可執行檔案提供有效路徑。
js.flow.enable.flow.service.error.on.checking=檢查 Flow 路徑時出錯\\: {0}
js.flow.enable.other.services=導覽、程式碼補全和類型提示
js.flow.enable.type.checking=類型檢查
js.flow.has.unsaved.files=由於修改了某些檔案，因此沒有執行醒目提示
js.flow.process.log=Flow 流程日誌
js.flow.services.label=為之使用 Flow 伺服器\\:
js.flow.settings.auto.save=自動儲存所有修改的檔案
js.flow.settings.auto.save.warning.lsp=這樣 Flow 將始終顯示最新的錯誤狀態。
js.flow.settings.executable.dialog.title=選擇 Flow 軟體套件或可執行檔案
js.flow.settings.executable.label=Flow 軟體套件或可執行檔案 (&F)\\:
js.flowjs.annotation.inspection.name=Flow 類型檢查器
js.flowjs.config.inspection.message=無關聯的 .flowconfig
js.flowjs.config.inspection.name=缺少 .flowconfig
js.flowjs.config.inspection.to.current.path.name=向當前目錄中新增 .flowconfig
js.flowjs.config.inspection.to.module.path.name=向模組內容根中新增 .flowconfig
js.flowjs.config.inspection.to.project.path.name=向專案根目錄中新增 .flowconfig
js.flowjs.flag.without.language.version=無 Flow 語言版本的 Flow 標誌
js.flowjs.group.name=Flow 類型檢查器
js.format.cstyle.comments=對齊多行
js.frameworks.sencha.xtype.not.found=找不到 xtype ''{0}'' 的 Ext JS 類別
js.function.brace.style=在函式宣告中
js.function.call.parentheses=函式呼叫括號
js.function.call.wrap=函式呼叫實參
js.function.declaration.parentheses=函式宣告括號
js.function.expression.brace.style=在函式表達式中
js.function.metrics.group.name=函式指標
js.function.parameters.wrap=函式宣告參數
js.generated.explicit.return.expression.types=函式表達式返回
js.generated.explicit.return.types=函式宣告返回
js.generated.explicit.types=此項的首選顯式類型\\:
js.generated.explicit.var.types=變數和欄位
js.generated.types=類型
js.generated.types.settings.link=顯式類型的程式碼樣式設定
js.generated.use.as.cast=首選 'as' 類型轉換
js.generated.use.public.modifier=使用 'public' 修飾符
js.import.options.merge.import=合併同一模組中成員的匯入
js.import.options.sort.members=對匯入的成員排序
js.import.options.sort.module.name=按模組對 import 排序
js.import.options.use.explicit.js.extension=使用檔案副檔名\\:
js.import.options.use.explicit.js.extension.auto=自動
js.import.options.use.explicit.js.extension.no=從不
js.import.options.use.explicit.js.extension.yes=始終
js.import.options.use.explicit.js.extension.yes.ts=始終為 ".js"
js.import.options.use.import-type=在 import 中使用 type 修飾符\\:
js.import.options.use.import-type.always=始終使用 type
js.import.options.use.import-type.auto=自動
js.import.options.use.import-type.help=此選項用於組態匯入類型時 TypeScript 'import type' 語句或類型說明符的用法。<br><br>選擇“始終使用 type”時，會始終使用 'import type' 或類型說明符。<br> <br>選擇“從不”時，所有類型都會像值一樣匯入，沒有 'type' 關鍵字。<br><br>選擇“自動”時，IDE 會檢查 TypeScript 版本和 tsconfig.json 以選擇最合適的選項。
js.import.options.use.import-type.never=從不
js.import.options.use.node.resolution=在 index.js 可用時使用目錄匯入(Node 樣式模組解析)
js.imports.dependencies.group.name=Import 和相依項
js.incompatible.types.comparison.inspection.name=類型不相容的表達式的比較
js.incompatible.types.comparison.message=條件始終為 {0, choice, 0\\#false|1\\#true}，因為類型 ''{1}'' 和 ''{2}'' 沒有重疊
js.indexer.to.property.intention=取代為屬性存取
js.infer.parameter.types.intention=從用法中推斷參數類型
js.infer.parameter.types.intention.failure.readonly.text=無法從用法中推斷類型\\: 為唯讀檔案
js.infer.parameter.types.intention.failure.text=無法從用法中推斷類型
js.infer.parameter.types.intention.failure.title=無法推斷類型
js.infer.parameter.types.intention.jsdoc=從用法中推斷 JSDoc 參數類型
js.infer.parameter.types.intention.progress.text=正在推斷類型
js.inject.dont.format.intention.text=停用注入內容的格式設定
js.inject.with.comment.intention.family.name=使用註釋對注射做出註解
js.inspection.amd.modules.dependencies.family.name=缺少 AMD 模組相依關係
js.inspection.async.group.name=Async 程式碼和 promise
js.inspection.bitwise.group.name=按位運算問題
js.inspection.convert.to.es6.group.name=ES2015 遷移協助
js.inspection.es6.modules.dependencies.family.name=缺少 import 語句
js.inspection.function.expression.is.used.instead.of.arrow=使用了函式表達式而不是箭頭函式
js.inspection.group.name=一般
js.inspection.group.path=JavaScript 和 TypeScript
js.inspection.missing.amd.dependency=缺少 AMD 模組相依關係
js.inspection.missing.import=缺少 import 語句
js.inspection.missing.module.dependency=缺少模組相依關係
js.inspection.package.json.dependencies=package.json 中的相依關係不符合
js.inspection.package.json.update.dependency.to.latest.version=將 package.json 相依項更新為最新版本
js.inspection.promise.ignored.display.name=返回 promise 的方法呼叫結果被忽略
js.inspection.promise.ignored.problem.descriptor=從 {0} 返回的 Promise 被忽略
js.inspection.promise.value.expected.problem.descriptor=應為值，但使用了從 {0} 返回的 Promise
js.inspection.switch.group.name=switch 語句問題
js.iterate=使用 'for..of' 進行迭代
js.iterate.async=使用 'for await..of' 進行迭代
js.join.declaration.assignment.inspection.fix=聯接變數宣告和賦值
js.join.declaration.assignment.inspection.name=變數宣告可與變數的第一個賦值合併
js.join.vars.intention=加入後續變數宣告
js.jquery.efficiency.inspection.allow.attribute.and.pseudo.selectors=允許特性和偽選擇器
js.jquery.efficiency.inspection.attribute.used.message=jQuery 特性選擇器可能低效
js.jquery.efficiency.inspection.duplicated.selector=重複的 jQuery 選擇器
js.jquery.efficiency.inspection.name=可以最佳化 JQuery 選擇器
js.jquery.efficiency.inspection.pseudoselector.used.message=jQuery 偽選擇器可能低效
js.language.version.label=JavaScript 語言版本
js.last.comma.in.array.literal.inspection.name=陣列字面量中的最後一個逗號多餘
js.last.comma.in.object.literal.inspection.name=物件字面量中的最後一個逗號多餘
js.library.attach.debug=附加偵錯版本(&D)…
js.library.attach.release=附加發佈版本(&R)…
js.library.configurable.name=庫
js.library.documentation=文檔
js.library.download.fix=下載庫
js.library.download.stubs.label=TypeScript 社區存根
js.library.downloading.library=正在下載庫
js.library.successfully.downloaded=已成功下載 {0}
js.library.unresolved.url.inspection.name=HTTP 鏈接缺少本地存儲的庫
js.linter.guesser.linter.disabled={0} 已停用。
js.linter.guesser.linter.enabled.because.of.config.file=已啟用 {0}\\: 組態檔案位於專案中。
js.linter.guesser.linter.enabled.because.of.dependency=已啟用 {0}\\: ''{1}'' 列出在 package.json 中。
js.linter.guesser.linter.enabled.because.of.package.json.section=已啟用 {0}\\: ''{1}'' 位於 package.json 中。
js.linters.detect.automatically.caption=從最近的 package.json 檢測軟體套件和組態檔案
js.linters.inspection.group.name=程式碼品質工具
js.make.single.var.statement=設為單變數語句
js.method.can.be.static=方法可以為 'static'
js.method.can.be.static.option=僅檢查 'private' 方法
js.mismatched.update.collection.inspection.name=不符合的集合查詢和更新
js.mismatched.update.collection.update.method.names=更新方法名稱\\:
js.missing.await.symbol.inspection.for.generator.name=異步產生器應使用 for-await 迴圈進行迭代
js.missing.await.symbol.inspection.for.returns=始終對異步函式呼叫使用 'await' 以避免錯誤，並幫助進行 V8 異步堆疊追蹤
js.missing.await.symbol.inspection.name=異步函式呼叫缺少 await
js.missing.switch.branches.ignore.with.default=忽略具有預設分支的 switch 語句
js.missing.switch.branches.inspection.desc=''switch'' 語句缺少 case\\: {0}
js.missing.switch.branches.inspection.name='switch' 語句缺少分支
js.module.uml.presentable.name=JavaScript 模組相依項
js.move.to.scope.start=將 var 語句移至作用域開始
js.move.type.to.file.family=移至名稱符合的檔案
js.move.type.to.file.text=將 {0} 移至檔案 {1}
js.named.to.anonymous.family.name=轉換為函式表達式
js.named.to.arrow.text=轉換為含有 {0} 的箭頭函式
js.named.to.function.expression.text=轉換為包含變數的函式表達式
js.named.to.function.hoisting.conflict.text=函式在宣告之前使用。轉換為變數後，將中斷使用
js.nested.template.literal.fix=內聯嵌套字面量
js.nested.template.literal.inspection=模板字面量中的冗餘嵌套
js.node.service.memory.configurable.autoIncrease=如果可用，自動增加記憶體
js.node.service.memory.configurable.autoIncrease.hint=當需要更多記憶體時，將新增 {0,number,\\#} MB 並重新啟動 LS。最大限制為 {1,number,\\#} MB
js.node.service.memory.configurable.footer=該設定適用於在 <code>node</code> 上執行的所有 TS 語言服務。<a href\\="{0}">詳細了解 LS 記憶體和故障排查。</a>
js.node.service.memory.configurable.header=語言服務記憶體
js.node.service.memory.configurable.manualIncrease=設定記憶體限制\\:
js.node.service.memory.configurable.manualIncrease.MB=MB
js.node.service.memory.configurable.manualIncrease.addMB=新增 {0,number,\\#} MB
js.node.service.memory.configurable.manualIncrease.validation.tooLarge=沒有此大小的可用 RAM。請使用小於 {0,number,\\#} MB 的值。
js.node.service.memory.oom.notification.actions.addMB=新增 {0,number,\\#} MB
js.node.service.memory.oom.notification.actions.configure=組態…
js.node.service.memory.oom.notification.actions.disableAutoIncrease=停用自動增加
js.node.service.memory.oom.notification.actions.enableAutoIncrease=啟用自動增加
js.node.service.memory.oom.notification.actions.howTo=如何手動修復
js.node.service.memory.oom.notification.autoIncreased=該項目的語言服務記憶體大小已自動增加 {0,number,\\#} MB
js.node.service.memory.oom.notification.content=這會影響自動補全和程式碼分析等基本功能。要解決此問題，請增加分配的記憶體。
js.node.service.memory.oom.notification.header=語言服務記憶體不足
js.node.services.profiler.disable=停止 Node.js 服務分析
js.node.services.profiler.enable=啟動 Node.js 服務分析
js.param.hints.blacklist.pattern.explanation=要停用方法或函式提示，請使用下面的其中一種模式\\: <p style\\="margin-left\\: 5px"><code><b>(*info)</b></code> - 所有參數名稱以 <em>info</em> 結尾的單參數方法<br><code><b>(key, value)</b></code> - 所有包含參數<em>鍵</em>和<em>值</em>的方法<br><code><b>*.put(key, value)</b></code>- 所有包含<em>鍵</em>和<em>值</em>參數的 <em>put</em> 方法<br><code><b>Console.log(*, *)</b></code> - 正好包含兩個參數的 <em>Console</em> 類型的 <em>log</em> 方法</p><br><p>必須為所有參數(包括可選參數)提供名稱或佔位符。<br>限定方法名稱必須包含類別或接口名稱或佔位符。<br>在編輯程式碼時，請使用“不為當前方法顯示提示”{0} 動作來新增模式。</p>
js.param.hints.show.names.for.all.args=非字面量實參
js.param.hints.show.names.for.literal.args=字面量實參
js.param.hints.show.names.for.pipes=管道運算符
js.param.hints.show.names.for.tagged=標記的模板實參
js.possibly.async.function.inspection=非異步函式中的 'await'
js.possibly.async.function.quick.fix=令函式 {0} 為異步函式
js.possibly.async.function.quick.fix.family.name=將函式設為異步
js.potentially.invalid.constructor.usages.inspection.name=可能無效的建構函式用法
js.potentially.invalid.target.of.indexed.property.access.inspection.name=索引的屬性存取的目標可能不正確
js.potentially.invalid.usage.of.class.this.inspection.name=從閉包對類別中 'this' 的參照可能無效
js.potentially.invalid.usage.of.this.inspection.name=從閉包對 'this' 的參照可能無效
js.primitive.type.improper.instantiation.inspection={0} 實例化可以簡化
js.primitive.type.wrapper.usage.inspection=使用了基元類型物件包裝器
js.probable.bugs.group.name=可能的 bug
js.progress.title.auto-importing-symbols-on-paste=貼上時自動匯入外部符號…
js.property.can.be.replaced.with.shorthand=屬性可被取代為速記形式
js.property.can.be.replaced.with.shorthand.method=屬性可被取代為速記方法
js.property.to.indexer.intention=取代為索引器存取
js.pull.up.will.be.made.abstract=非 abstract {0}將被設為 abstract
js.quote.unquote.intention.plural={0} 屬性名稱
js.quote.unquote.intention.quote=參照
js.quote.unquote.intention.quote.family=使用引號包裝屬性名稱
js.quote.unquote.intention.singular={0} 屬性名稱
js.quote.unquote.intention.unquote=取消參照
js.quote.unquote.intention.unquote.family=移除屬性名稱中的引號
js.react.group.name=React
js.redundant.await.inspection=冗餘 'await' 表達式
js.redundant.switch.problems.inspection.default='switch' 語句僅包含一個 'default' 子句
js.redundant.switch.problems.inspection.default.unwrap=解包 'switch' 語句
js.redundant.switch.problems.inspection.empty='switch' 語句為空
js.redundant.switch.problems.inspection.empty.remove=移除空的 'switch' 語句
js.redundant.switch.problems.inspection.name='switch' 語句冗餘，可以取代
js.redundant.switch.problems.inspection.side.effects=並提取副作用
js.redundant.switch.problems.inspection.single='switch' 語句僅包含一個非預設子句
js.redundant.switch.problems.inspection.single.replace=將 'switch' 取代為 'if'
js.referencing.mutable.variable.from.closure.inspection.name=從閉包中參照可變變數
js.regex.flag.d=符合索引 - 用於子字串符合的索引
js.regex.flag.g=全域符合 - 返回所有符合項
js.regex.flag.i=忽略大小寫 - 不區分大小寫的符合
js.regex.flag.m=多行 - ^ 和 $ 的每行符合
js.regex.flag.s=dotAll - . 符合換行符
js.regex.flag.u=unicode - 完整 unicode 支援
js.regex.flag.y=粘性 - 在確切的位置搜尋
js.remove.digit.separators=移除數字分隔符
js.remove.redundant.initializer.fix=移除冗餘的初始設定式
js.remove.unused.assignment=移除未使用的賦值
js.rename.base.member=重新命名基{0}
js.rename.component.usage.provide.name.error=組件名稱應為有效的 JavaScript 關鍵字
js.rename.component.usage.provide.name.message=輸入新組件名稱
js.rename.component.usage.provide.name.title=重新命名組件
js.rename.current.member=重新命名當前 {0}
js.rename.file.to.match.type.name=將檔案重命名為 {0} 以匹配 {1} 名稱
js.rename.file.to.match.type.name.family=重新命名檔案以符合類型名稱
js.rename.member.title={0} {1} {3} 的 {2}
js.rename.member.title.implements=實作
js.rename.member.title.overrides=覆寫
js.rename.search.for.component.usages=搜尋組件用法(&O)
js.replace.string.concatenation.with.es6.template.fix.text=取代為模板字串
js.replace.string.concatenation.with.es6.template.inspection.name=已使用字串串聯而不是模板字面量
js.replace.string.with.es6.template=取代為模板字串
js.replace.with.literal=取代為 {0} 字面量
js.replace.with.shorthand.method.quick.fix=取代為速記方法
js.replace.with.shorthand.property.quick.fix=取代為速記屬性
js.replace.with.type.cast.to.primitive=取代為 {0} 的類型轉換
js.search.for.default.imports=正在搜尋 default import…
js.search.for.named.imports=正在搜尋命名 import…
js.searching.for.component.usages=正在搜尋組件用法…
js.separate.bytes=分隔位元組
js.separate.digits=分隔數字
js.separate.nibbles=分隔半位元組
js.separate.thousands=分隔千分位
js.separate.thousands.in.integer.part=分隔整數中的千分位
js.separate.words=分隔 16 位單詞
js.show.dynamic.usages=顯示動態用法
js.show.type.info.action.error=找不到表達式
js.space.before.function.left.brace=函式左大括號
js.spaces.in.flow.category=在 Flow 中
js.split.declarations=拆分宣告
js.split.into.multiple.declarations=拆分為多個宣告
js.statement.context.type=語句
js.strict.mode.inspection.error={0} 不處於嚴格模式下
js.strict.mode.inspection.fix=新增“use strict”雜註
js.strict.mode.inspection.name=使用了非嚴格模式
js.strict.mode.inspection.redundant.pragma="use strict"雜註冗餘
js.strict.mode.remove.pragma=移除“use strict”雜註
js.string.template.line.separators.multispan=轉換為多行字串模板
js.string.template.line.separators.multispan.family.name=轉換為多行字串模板
js.string.template.line.separators.visible=轉換為可見行分隔符
js.string.template.line.separators.visible.family.name=轉換模板字串以使用可見行分隔符
js.suspicious.bind.with.arrow.function=箭頭函式 'bind' 用法可疑
js.suspicious.eq.plus.fix.name=取代為 '+\\='
js.suspicious.eq.plus.inspection.desc=可疑的 '\\=+' 賦值\\: '+\\=' 可能拼寫錯誤
js.suspicious.eq.plus.inspection.name=可疑的 '\\=+' 賦值
js.suspicious.name.assignment=''{0}'' 可能不應分配給 ''{1}''
js.suspicious.name.combination.inspection.name=可疑的變數/參數名稱組合
js.suspicious.name.parameter=''{0}'' 可能不應作為參數 ''{1}'' 傳遞
js.suspicious.name.return=''{0}'' 可能不應從方法 ''{1}'' 返回
js.switch.no.default='switch' 語句沒有 'default' 分支
js.switch.no.default.add=建立缺少的預設分支
js.switch.to.jsx.inspection.dismiss=關閉
js.testing.autoWatch.action.name=監視更改
js.testing.highlight.line=在測試程式碼中醒目提示失敗的行
js.testing.inspection.group.name=單元測試
js.tool.window.limit=顯示前 {0} 個錯誤。
js.tool.window.limit.all=檢視所有 {0} 個錯誤
js.top.level.await.expression.inspection=頂層 'await' 表達式
js.top.level.await.expression.inspection.description=使用了頂層 'await' 表達式
js.top.level.statement.context.type=頂級語句
js.trailing.comma.keep=保持
js.trailing.comma.remove=移除
js.trailing.comma.whenMultiline=多行時新增
js.undeclared.variable.inspection.name=隱式宣告的全域 JavaScript 變數
js.undefined.property.assignment.inspection.message=類型 {1} 中未定義屬性 {0}
js.undefined.property.assignment.inspection.name=未定義的屬性賦值
js.unfiltered.for.in.loop.inspection.name=未過濾 for..in 迴圈
js.unfiltered.for.in.loop.skip.primitives=使用陣列或物件初始設定式跳過參照迭代
js.unfiltered.for.in.loop.skip.primitives.tooltip=在未修改 Object.prototype 和 Array.prototype 時啟用它
js.unnecessary.semicolon.fix.name=移除不必要的分號
js.unnecessary.semicolon.inspection.name=不必要的分號
js.unnecessary.semicolon.problem=不必要的分號 \\#loc
js.unreachable.switch.branches.ignore.with.dynamic=不在動態類型的上下文中顯示此警告
js.unreachable.switch.branches.inspection.desc=不可到達的 'case' 分支
js.unreachable.switch.branches.inspection.name=不可到達 'switch' 語句的 'case' 分支
js.unreachable.switch.branches.remove=移除不可到達的 'case' 分支
js.unresolved.variable.inspection.name=未解析的參照
js.unused.assignment.inspection.name=未使用的賦值
js.unused.es6.import.inspection.name=未使用的 import
js.unused.global.symbol.inspection.name=未使用的全域符號
js.unused.local.symbol.inspection.name=未使用的區域符號
js.unused.symbol=未使用的 {0} \\#ref
js.unused.symbol.full=未使用的 {0}
js.unused.symbol.remove=移除未使用的 {0}
js.unused.symbols.group.name=未使用的符號
js.unwanted.symbols.group.name=可能不合需要的程式碼結構
js.url.import.usage.inspection.download.module.0.quick.fix.failed=下載模組 ''{0}'' 失敗
js.url.import.usage.inspection.download.module.0.quick.fix.progress=正在下載模組 ''{0}''
js.url.import.usage.inspection.download.module.0.quick.fix.success=模組 ''{0}'' 已成功下載
js.url.import.usage.inspection.download.module.0.quick.fix.warning=模組 ''{0}'' 已下載，但有錯誤
js.url.import.usage.inspection.download.module.0.quick.fix.warning.urls=失敗的 URL\\:
js.url.import.usage.inspection.download.module.quick.fix.name=下載模組
js.url.import.usage.inspection.name=使用了 URL 匯入
js.usage.type.call=函式呼叫中的用法
js.validate.jsdoc.inspection.name=JSDoc 中的語法錯誤和未解析的參照
js.validate.signature.inspection.name=簽名不符合
js.validate.types.inspection.name=類型不符合
js.validity.issues.group.name=有效性問題
js.value.assigned.is.never.used=從未使用過所賦之值 \\#loc
js.value.assigned.to.is.never.used=賦給 ''{0}'' 的值從未使用 \\#loc
js.variable.initializer.is.redundant=變數初始設定式冗餘 \\#loc
js.variable.might.not.been.initialized=變數可能尚未初始化 \\#loc
js.variable.problems.ignore.desc=對可變變數忽略
js.variable.problems.inspection.desc=變數 ''{0}'' 在子句 ''{1}'' 中宣告， 但在子句 ''{2}'' 中使用
js.variable.problems.inspection.desc.ref.error=存取時參照錯誤
js.variable.problems.inspection.name=宣告了變數並在不同的 'case' 子句中使用
js.void.function.result.used.description=使用了 void 函式返回值
js.void.function.result.used.name=使用了 void 函式返回值
js.wrap.settings.class.decorators=類別裝飾器
js.wrap.settings.class.field.decorators=類別欄位裝飾器
js.wrap.settings.class.method.decorators=類別方法裝飾器
js.wrap.settings.function.parameter.decorators=函式參數裝飾器
js.wrap.settings.import=ES6 匯入/匯出
js.wrap.settings.object.types=物件類型
js.wrap.settings.union.and.intersection.types=聯合體與相交類型
js.wrap.settings.var.group.name=變數宣告
jshint.clear.field.to.disable=清除要停用的欄位
jshint.config.default.description=<div style\\="padding-bottom\\:10px"><div><b>.jshintrc</b></div><div style\\="padding-left\\:10px; padding-top\\:4px;">對 JavaScript 檔案進行 Linting 檢查時，IDE 會從檔案所在的目錄開始尋找 .jshintrc，然後上行到檔案系統根目錄。</div></div><div><div><b>package.json</b></div><div style\\="padding-left\\:10px; padding-top\\:4px;">將您的組態新增到專案的 package.json 檔案中的 <code>jshintConfig</code> 屬性下。</div></div>
jshint.config.error.cannot.locate.ext.config=JSHint\\: 無法定位擴展組態
jshint.config.error.cannot.parse.ext.config=JSHint\\: 無法解析擴展組態
jshint.config.error.failed.to.read.property=無法從 package.json 讀取 ''{0}'' 屬性
jshint.config.extends.cyclically=JSHint 組態迴圈擴展
jshint.config.failed.to.read=無法讀取 JSHint 組態
jshint.config.option.custom.browser.title=選擇 JSHint 組態檔案 (*.jshintrc)
jshint.config.option.custom.name=自訂組態檔案
jshint.config.option.default.name=預設
jshint.exception.balloon.action.configure.proxy.or.retry=<a href\\=''{0}''>組態 HTTP 代理</a>或<a href\\=''{1}''>重試</a>
jshint.exception.balloon.action.retry=<a href\\=''{0}''>重試</a>
jshint.illegal.integer=非法整數
jshint.inspection.message.config.not.found=未找到 JSHint 組態
jshint.inspection.message.duplicate.options=重複 JSHint 選項\\: {0}，{1}。
jshint.inspection.message.expected.value=預期值\\: {0}
jshint.inspection.message.expected.values.x.or.y=預期值\\: {0} 或 {1}
jshint.inspection.message.malformed.config=JSHint 組態格式錯誤
jshint.inspection.message.not.loaded=未載入 JSHint {0}
jshint.inspection.message.object.or.array.expected=應為物件或陣列
jshint.inspection.message.prefix=JSHint\\:
jshint.inspection.message.unexpected.jshint.option.name=意外的 JSHint 選項名稱
jshint.inspection.message.unexpected.value=意外值
jshint.label.bundled.suffix=(捆綁)
jshint.label.no.version=無版本
jshint.latedef.false.text=不警告
jshint.latedef.nofunc.text=<html><body>禁止變數在未定義的情況下使用，<br>但允許函式宣告。</body></html>
jshint.latedef.true.text=禁止變數在未定義的情況下使用
jshint.option.asi.description.short=禁止缺少分號的警告
jshint.option.bitwise.description.short=有關使用逐位運算符的警告
jshint.option.boss.description.short=禁止有關 <code>if/for/…</code> 內部賦值的警告
jshint.option.browser.description.short=瀏覽器
jshint.option.camelcase.description.short=有關變數命名的警告
jshint.option.curly.description.short=塊省略 <code>{}</code> 時發出警告
jshint.option.debug.description.short=禁止有關偵錯模式的警告
jshint.option.devel.description.short=開發
jshint.option.edit.dialog.title=設定 ''{0}'' 選項
jshint.option.elision.description.short=禁止有關 ES3 陣列省略元素的警告
jshint.option.enforceall.description.short=程式碼未遵守最嚴格的組態時發出警告
jshint.option.eqeqeq.description.short=有關不安全比較的警告
jshint.option.eqnull.description.short=禁止有關 <code>\\=\\= null</code> 的警告
jshint.option.es3.description.short=有關與 ES3 規範不相容的警告
jshint.option.es5.description.short=有關與 ES5 規範不相容的警告
jshint.option.esnext.description.short=EcmaScript.next
jshint.option.esversion.description.short=在與指定的 ECMAScript 版本不相容時發出警告
jshint.option.evil.description.short=禁止有關 <code>eval</code> 的警告
jshint.option.expr.description.short=禁止有關將表達式用作語句的警告
jshint.option.forin.description.short=有關不安全 <code>for..in</code> 的警告
jshint.option.freeze.description.short=有關覆蓋原生物件原型的警告
jshint.option.funcscope.description.short=禁止有關在已宣告塊外部使用變數的警告
jshint.option.futurehostile.description.short=有關使用在以後的 JavaScript 版本中定義的關鍵字的警告
jshint.option.gcl.description.short=將 JSHint 設為與 Google Closure Compiler 相容
jshint.option.globalstrict.description.short=禁止有關使用全域嚴格模式的警告
jshint.option.immed.description.short=有關未使用括號包裝函式而直接呼叫函式的警告
jshint.option.indent.description.short=縮排
jshint.option.iterator.description.short=禁止有關 <code>__iterator__</code> 屬性的警告
jshint.option.lastsemic.description.short=禁止有關缺少分號的警告，但僅當單行塊中的最後一條語句省略分號時才顯示該警告
jshint.option.latedef.description.short=當變數在未定義的情況下使用時發出警告
jshint.option.laxbreak.description.short=禁止有關不安全換行的警告
jshint.option.laxcomma.description.short=禁止有關編碼樣式以逗號開頭的警告
jshint.option.loopfunc.description.short=禁止有關函式在迴圈內部的警告
jshint.option.maxcomplexity.description.short=程式碼中的最大迴圈復雜度
jshint.option.maxdepth.description.short=塊的最大深度
jshint.option.maxerr.description.short=最大錯誤數
jshint.option.maxlen.description.short=行的最大長度
jshint.option.maxparams.description.short=函式中的最大參數數量
jshint.option.maxstatements.description.short=函式中的最大語句數量
jshint.option.module.description.short=ECMAScript 6 模組
jshint.option.moz.description.short=檢查程式碼是否使用 Mozilla JavaScript 擴展
jshint.option.multistr.description.short=禁止有關多行字串的警告
jshint.option.newcap.description.short=有關使用非大寫形式的建構函式的警告
jshint.option.noarg.description.short=有關 <code>arguments.caller</code> 和 <code>.callee</code> 的警告
jshint.option.nocomma.description.short=有關使用逗號運算符的警告
jshint.option.noempty.description.short=有關空塊的警告
jshint.option.nomen.description.short=不允許使用 _ in 變數
jshint.option.nonbsp.description.short=有關“不間斷空格”字元的警告
jshint.option.nonew.description.short=有關副作用 <code>new</code> 用法的警告
jshint.option.nonstandard.description.short=轉義和未轉義
jshint.option.notypeof.description.short=禁止有關無效 <code>typeof</code> 運算符值的警告
jshint.option.noyield.description.short=禁止在產生器函式中無 yield 語句時有關產生器函式的警告
jshint.option.onevar.description.short=每個函式一個變數語句
jshint.option.passfail.description.short=出現第一個錯誤時停止
jshint.option.plusplus.description.short=有關使用一元遞增和遞減運算符的警告
jshint.option.predef.description.short=預定義(以 , 分隔)
jshint.option.predef.details=指定全域變數及其可分配狀態\\:\\n<pre>DISQUS\\:true、jQuery\\:false</pre>\\n<p/>此時，JSHint 允許您覆寫 DISQUS，但禁止覆寫 jQuery。
jshint.option.proto.description.short=禁止有關 <code>__proto__</code> 屬性的警告
jshint.option.quotmark.description.short=引號
jshint.option.scripturl.description.short=禁止有關使用以腳本為目標的 URL 的警告
jshint.option.shadow.description.short=禁止有關變數隱藏的警告
jshint.option.singlegroups.description.short=如果未嚴格要求使用分組運算符，禁止使用該運算符
jshint.option.smarttabs.description.short=在空格僅用於對齊時，禁止有關將制表符和空格混合使用的警告
jshint.option.strict.description.short=程式碼未採用嚴格模式時發出警告
jshint.option.sub.description.short=如果可以使用點符號表示 <code>[]</code> 符號，則禁止有關使用後者的警告
jshint.option.supernew.description.short=禁止有關“怪異”建構的警告
jshint.option.trailing.description.short=有關尾隨空格的警告
jshint.option.typed.description.short=輸入的陣列
jshint.option.undef.description.short=未定義變數時發出警告
jshint.option.unused.description.short=存在未使用的變數時發出警告
jshint.option.validthis.description.short=禁止有關可能違反嚴格要求的警告
jshint.option.varstmt.description.short=有關使用 VariableStatements 的警告
jshint.option.white.description.short=不允許使用雜亂的空格
jshint.option.withstmt.description.short=禁止有關使用 with 語句的警告
jshint.option.worker.description.short=Web 工作執行緒
jshint.option.wsh.description.short=Windows Script Host
jshint.options.tree.tooltip.set.a.new.value=設定新值
jshint.progress.title=JSHint {0}
jshint.progress.title.downloading=正在下載 {0}
jshint.progress.title.updating.jshint=正在將 JSHint 更新到 {0}
jshint.quotmark.double.text=僅允許雙引號
jshint.quotmark.false.text=允許兩種引號
jshint.quotmark.single.text=僅允許單引號
jshint.quotmark.true.text=僅允許單引號或雙引號
jshint.suppress.text.suppress.for.line=禁止行
jshint.tree.link.set=設定
jshint.unused.false.text=不檢查任何內容
jshint.unused.strict.text=檢查所有變量和參數
jshint.unused.true.text=<html><body>檢查所有變量和參數，但允許<br>使用的參數後存在未使用參數</body></html>
jshint.unused.vars.text=檢查變數，而不是函式參數
jshint.use.config.files=使用組態檔案
jshint.version.label=版本(&V)\\:
jsx.code.style.attribute.default.value=為 JSX 特性新增\\:
jsx.code.style.attribute.default.value.braces=大括號
jsx.code.style.attribute.default.value.none=無
jsx.code.style.attribute.default.value.quotes=引號
jsx.code.style.attribute.default.value.typebased=基於類型
jsx.convert.html.attributes.to.jsx=將程式碼貼上到 JSX 檔案時關閉 HTML 單一標記
jsx.convert.html.attributes.to.react=將程式碼貼上到 React JSX 檔案時轉換 HTML 特性名稱
jsx.convert.html.to.jsx.command.name=將 HTML 程式碼轉換為 JSX
jsx.convert.html.to.jsx.progress=正在將 HTML 程式碼轉換為 JSX…
jsx.dom.nesting.inspection.message=''{0}'' 不能作為 ''{1}'' 的子級出現
jsx.dom.nesting.inspection.message.text=文本節點不能顯示為 ''{0}'' 的子級
jsx.dom.nesting.inspection.message.tr=''{0}'' 不能作為 ''{1}'' 的子級出現。在您的程式碼中新增 <tbody>、<thead> 或 <tfoot> 以符合瀏覽器生成的 DOM 樹。
jsx.dom.nesting.inspection.name=無效的 DOM 元素嵌套
jsx.html.context.type=JSX HTML
jsx.missing.namespace.inspection.name=缺少 JSX 命名空間
jsx.missing.namespace.inspection.text=在未匯入 {0} 的情況下使用 JSX
jsx.syntax.used.description=已使用 JSX 語法
jsx.syntax.used.name=已使用 JSX 語法
jsx.unresolved.component.name=未解析的 JSX 組件
jsx.unresolved.prop.name=未解析的 JSX 屬性
label.compiles.js.files=編譯 .js 檔案
label.compress.js.files=壓縮 .js 檔案
label.exclude.methods.classes=排除類別方法\\:
label.import.popup=自動匯入工具提示
label.method.should.be.defined=方法應已定義
label.minimum.language.level=最低語言級別\\:
label.name.injection=名稱(&N)\\:
label.namespace=命名空間\\:
label.path=路徑(&P)\\:
label.wsl.node.interpreter=WSL Node.js 解釋器(&N)\\:
linemarker.implemented=已實作
linemarker.implementing=實作
linemarker.implements.invalid=<無效>
linemarker.implements.several=實作多種接口方法
linemarker.implements.text=實作 {1} 中的 {0}
linemarker.javascript.sources=JavaScript 源
linemarker.javascript.typescript=JavaScript/TypeScript 行標記
linemarker.overridden=覆寫
linemarker.overrides.text=覆寫 {1} 中的 {0}
linemarker.overriding=覆寫
linemarker.typescript.declaration=TypeScript 宣告
list.item.class.field=類別欄位
list.item.declarations.function.members.to.be.converted.to.class.members=要轉換為類別成員的函式成員的宣告
list.item.declarations.that.were.not.converted=未轉換的宣告
list.item.function.converted.to.class=轉換為類別的函式
list.item.function.to.be.converted.to.class=要轉換為類別的函式
list.item.global.or.module.constant=全域或模組常數
list.item.google.javascript.style.guide=Google JavaScript 樣式指南
list.item.javascript.file=JavaScript 檔案
list.item.javascript.jsx.file=JSX 檔案
list.item.javascript.standard.style=JavaScript 標準樣式
list.item.local.constant=區域常數
list.item.typescript.file=TypeScript 檔案
list.item.typescript.jsx.file=TypeScript JSX 檔案
live.template.con.description=帶 props 實參的建構函式
live.template.fsc.description=React Flow 箭頭函式組件
live.template.fsf.description=React Flow 函式組件
live.template.props.description=this.props.
live.template.rcc.description=React 類別組件
live.template.rccp.description=帶有 PropTypes 的 React 類別組件
live.template.rcfc.description=帶有 PropTypes 和生存期方法的 React 類別組件
live.template.rsc.description=React 箭頭函式組件
live.template.rscp.description=帶有 propTypes 的 React 箭頭函式組件
live.template.rsf.description=React 函式組件
live.template.rsfp.description=帶有 propTypes 的 React 函式組件
live.template.rsi.description=帶有隱式 return 的 React 箭頭函式組件
live.template.state.description=this.state.
livetemplate.description.arf=使用箭頭函式包圍
livetemplate.description.console.assert=console.assert()
livetemplate.description.console.error=console.error()
livetemplate.description.console.info=console.info()
livetemplate.description.console.log=console.log()
livetemplate.description.console.trace=console.trace()
livetemplate.description.console.warn=console.warn()
livetemplate.description.defi=插入 define() 表達式
livetemplate.description.exportall=匯出語句 - 從 'a' 匯出 *
livetemplate.description.exportfrom=匯出語句 - 從 ''a'' 匯出 {b} 
livetemplate.description.exportitems=匯出語句 - export {b}
livetemplate.description.flow=插入 @flow 註解
livetemplate.description.fori=建立迭代迴圈
livetemplate.description.importdefault=import 語句 - 從 'a' 匯入 b
livetemplate.description.importfrom=import 語句 - 從 ''a'' 匯入 {b}
livetemplate.description.importns=import 語句 - 從 'a' 匯入 * as b
livetemplate.description.itar=遍歷陣列元素
livetemplate.description.iter=迭代 (for..of)
livetemplate.description.itera=迭代 (for await..of)
livetemplate.description.itin=迭代(for..in)
livetemplate.description.moduleexports=匯出語句 - module.exports \\= a
livetemplate.description.ref=插入參照路徑註釋
livetemplate.description.ritar=以相反順序遍歷陣列的元素
livetemplate.description.us=插入 'use strict' 語句
lsp.executable.error=找不到 {0} 的可執行檔案。
lsp.interpreter.error=未組態本地或 WSL Node.js 解釋器。
macro.js.component.type.of=jsComponentTypeOf(Array)
macro.js.suggest.default.variable.kind=jsSuggestDefaultVariableKind(Boolean)
make.method.static=設為 'static'
make.private=設為 private
members.to.implement.chooser.title=選擇要實作的成員
members.to.override.chooser.title=選擇要覆寫的成員
merged.process.output.text={0}{2, choice, 0\\#\\n\\n標準錯誤\\:\\n{1}|1\\#}{4, choice, 0\\#\\n\\n標準輸出\\:\\n{3}|1\\#}\\n\\n{5}
method.return.types.in.call.chains=呼叫鏈中的函式返回值類型
modules.selected=選定
move.members.dialog.title=移動成員
move.members.refactoring.name=移動成員
multiple.inheritance=多重繼承
new.actionscript.class.dialog.title=新增 ActionScript 類別
new.actionscript.interface.dialog.title=新增 ActionScript 接口
new.constructor.action.description=建立建構函式
new.constructor.action.text=建構函式
new.field.action.description=在類別中建立新字段
new.field.action.text=欄位
new.method.action.description=在類別中建立新方法
new.method.action.text=方法
no.candidates=無候選項
no.executable.found.in.path=在 {0, choice, 0\\#%PATH%|1\\#$PATH} 中未找到可執行檔案
no.members.to.implement=找不到要實作的成員
no.members.to.override=找不到要覆寫的成員
no.methods.to.implement=找不到要實作的方法
no.methods.to.override=找不到要覆寫的方法
no.variables.for.getter=找不到沒有 getter 的欄位
no.variables.for.getter.setter=找不到沒有 getter 和 setter 的欄位
no.variables.for.setter=找不到沒有 setter 的欄位
node.core.core_modules_fetch_timed_out.dialog.message=無法提取核心模組\\: 已超時
node.core.enable_coding_assistance_intention.name=啟用 Node.js 的編碼輔助
node.core.failed_to_fetch_node_core_modules.dialog.message=無法提取 Node 核心模組
node.core.make.sure.javascript.debugger.plugin.enabled.dialog.message=確保已啟用 'JavaScript Debugger' 延伸模組
node.core.navigate_action_text.text=組態 Node.js…
node.core.not_ready_for_core_modules_configuration.dialog.message=未準備好進行核心模組組態
node.debug.cannot_connect_to_vm.error.message=無法連線到虛擬機 {0}
node.debug.cannot_get_localhost_IPv4.error.message=無法獲取 127.0.0.1 IPv4
node.download.broken.installation.error=Node.js 安裝損壞。
node.download.cannot_find_interpreter.error=找不到已下載的 Node.js 解釋器。
node.download.dialog.error.failed_to_fetch_versions=無法提取可用的 Node.js 版本
node.download.dialog.full.version.label=版本\\:
node.download.dialog.location.description=選擇下載 Node.js 的路徑\\:
node.download.dialog.location.error.blank=位置路徑為空
node.download.dialog.location.error.existing_non_empty_directory=位置指向現有的非空目錄
node.download.dialog.location.error.failed_to_resolve=無法解析位置
node.download.dialog.location.error.file.exists=位置指向現有檔案
node.download.dialog.location.label=位置\\:
node.download.dialog.major.version.label=發佈\\:
node.download.dialog.no_version.label=無版本
node.download.dialog.ok_text=下載
node.download.dialog.released_on.label={0} 發佈
node.download.dialog.unavailable.label=不可用
node.download.download.cancelled.error=動作已被取消。
node.download.editor.suggestion={0} 需要 Node.js 才能正常工作。
node.download.failure.notification=無法下載 Node.js {0}。{1}
node.download.fetching.version=正在提取 Node.js 版本…
node.download.node.archive=正在下載 Node.js {0}
node.download.open.settings=開啟設定
node.download.success.notification=Node.js {0} 已組態。
node.download.supported_later.platform=Node.js 在版本 {2} 或更高版本中支援 {0}，{1}
node.download.unsupported.platform=Node.js 不支持 {0}，{1}
node.execution.failed.to.prepare.target.environment.error=無法準備環境\\: {0}
node.execution.starting.process.progress.title=正在啟動 ''{0}''…
node.interpreter.command_timed_out.dialog.message=''{0}'' 指令執行超時(>{1} 毫秒)
node.interpreter.download=下載 Node.js
node.interpreter.field.add.item.text=新增…
node.interpreter.field.popup.download.item=下載…
node.interpreter.field.unexpected_value.text=意外值 {0}
node.interpreter.invalid_interpreter.error.message=無效 ''{0}''
node.interpreter.label=Node 解釋器(&I)\\:
node.interpreter.no_local_interpreter.error.message=沒有本地 Node.js 解釋器
node.interpreter.node_from_path.reference.name=node
node.interpreter.not.found=找不到 {0}
node.interpreter.project_node.reference.name=專案
node.interpreter.reference_not_found.text=未找到
node.interpreter.specified_interpreter_correctly.dialog.message=正確指定 Node.js 解釋器
node.interpreter.unavailable.target=不可用的目標\\: {0}
node.interpreter.unresolved_reference.error.message=未解析的解釋器 ''{0}''
node.interpreter.unspecified.error.text=指定 Node.js 解釋器
node.interpreter.unspecified_interpreter.dialog.message=指定 Node.js 解釋器
node.interpreter.unspecified_interpreter_with_link.dialog.message=指定 <a href\\="">Node.js 解釋器</a>
node.interpreter.unspecified_local_interpreter.dialog.message=指定本地 Node.js 解釋器
node.js.add.interpreter.action=新增{0}…
node.js.configure.interpreter=組態{0}
node.js.downloading=正在下載 Node.js {0}
node.js.inspection.group.name=Node.js
node.js.interpreters=Node.js 解釋器
node.js.invalid.node=該專案使用了無效的 Node.js 路徑。<br>它已更新為使用 {0} 中的 Node.js。
node.js.missing.require=缺少 require() 語句
node.js.quickfix.install.node.module.devDependencies.family.name=安裝模組作為開發相依關係
node.js.quickfix.install.node.module.error.no.interpreter.text=無法安裝 Node.js 模組\\: 請指定預設 Node.js 解釋器。
node.js.quickfix.install.node.module.error.no.interpreter.title=安裝 Node.js 模組
node.js.quickfix.install.node.module.error.prefix.text=無法安裝 Node.js 模組\\: {0}
node.js.quickfix.install.node.module.family.name=安裝模組
node.js.quickfix.install.node.module.text=安裝 ''{0}''
node.js.quickfix.install.node.module.update.modules.family.name=執行 'npm install'
node.js.quickfix.install.node.module.with.dev.dependencies.text=安裝 ''{0}'' 作為開發相依關係
node.js.quickfix.run.command=執行 ''{0}''
node.js.remote.interpreters.plugin.missing=缺少 Node.js 遠端解釋器延伸模組。請啟用 {0} 中的延伸模組
node.js.select.file=選擇 {0} 檔案
node.js.set.project.interpreter.action=設定為專案解釋器
node.js.unresolved.api=未解析的 Node.js API
node.no.interpreter=無解釋器
node.npm.cannot_find_package_by_reference.dialog.message=找不到軟體套件管理器 ''{0}''
node.npm.cannot_find_project_package_manager.dialog.message=找不到專案 Node.js 軟體套件管理器
node.npm.cannot_resolve_package_manager.dialog.message=無法解析 ''{0}'' 軟體套件管理器
node.npm.correct_path_to_npm_or_yarn_package.dialog.message=指定 npm 或 yarn 軟體套件的正確路徑\\: 無此類別目錄“{0}”
node.npm.invalid_package_manager.binary_file_not_found.dialog.message=指定有效的軟體套件管理器\\: 在 ''{0}'' 目錄內部找不到二進制檔案
node.npm.package_manager_link.text=軟體套件管理器
node.npm.project_package_manager_disallowed_here.dialog.message=無法在此處參照專案 npm 軟體套件
node.npm.specify_npm_or_yarn_package.dialog.message=指定 npm 或 yarn 軟體套件
node.npm.unspecified_package_manager.dialog.message=未指定軟體套件管理器
node.package.binary.file.hint=指向 {0} 的二進制檔案的路徑
node.package.cannot.find.bin.file.dialog.message=找不到 ''{0}'' 軟體套件的 bin 檔案
node.package.dropDownList.select=選擇…
node.package.empty.error.message=專案名稱為空
node.package.empty.hint={0} 軟體套件目錄路徑
node.package.empty.hint.pkg1.or.pkg2={0} 或 {1}
node.package.field.not_found.text=未找到
node.package.manager.label=軟體套件管理器 (&M)\\:
node.package.name.URL-friendly.characters.error.message=專案目錄名稱應僅包含適用於 URL 的字元
node.package.name.capital.letters.error.message=專案目錄名稱不應包含大寫字母
node.package.name.core.module.error.message=''{0}'' 不能用作專案名稱，因為它是 Node.js 核心模組的名稱
node.package.name.forbidden.error.message=''{0}'' 不能用作專案名稱
node.package.name.leading.or.trailing.spaces.error.message=專案目錄名稱不應包含前導空格或尾隨空格
node.package.name.period.error.message=專案目錄名稱不應以句點開頭
node.package.name.special.characters.error.message=專案目錄名稱不應包含特殊字元("~'\\!()*")
node.package.name.too.long.error.message=專案目錄名稱不應超過 214 個字元
node.package.name.underscore.error.message=專案目錄名稱不應以下劃線開頭
node.package.none=無軟體套件
node.package.selector.multiple.packages.binary.file.title=選擇 {0} 的軟體套件目錄或二進制檔案
node.package.selector.multiple.packages.description=選擇 {0}
node.package.selector.multiple.packages.title=選擇軟體套件目錄
node.package.selector.single.package.title=選擇 {0} 軟體套件目錄
node.package_documentation.installed_version.text=已安裝版本\\: {0}
node.package_documentation.latest_version.text=最新版本\\: {0}
node.wsl.network.connection.failure=無法建立從 WSL 到 Windows 主機的網絡連線(可能被防火牆阻止)。\\n要了解詳細資訊，請參閱\\: https\\://jb.gg/wsl-firewall
node.wsl.unavailable.dialog.message=WSL 不可用
non.ascii.identifiers.inspection.name=包含非 ASCII 符號的關鍵字
non.ascii.identifiers.mixed.set=<html>名稱同時包含 ASCII 和非 ASCII 符號\\: {0}</html>
non.ascii.identifiers.non.ascii.found=<html>名稱包含非 ASCII 符號\\: {0}</html>
non.ascii.identifiers.only.ascii=僅允許 ASCII 名稱
non.parenthesized.single.parameter=未使用括號括起來的單個參數
non.parenthesized.single.parameter.description=未使用括號括起來的單個參數
not.installed.package=未安裝軟體套件
notification.content.html.href.settings.show.inspection.settings.or.href.undo.undo.html=<html><a href\\='settings'>顯示檢查設定</a>或<a href\\='undo'>撤消</a></html>
notification.content.notifications.are.enabled.for.all.package.json.files=為所有 package.json 檔案啟用通知
notification.content.notifications.are.enabled.for.current.package.json=為當前 package.json 啟用通知
notification.content.show.details=顯示詳細資訊
notification.group.code.vision.performance.watcher=JavaScript\\: Code Vision 性能觀察程序
notification.group.grunt.console=Grunt 'watch' 任務狀態已更改
notification.group.jest=Jest 測試執行失敗
notification.group.linters=JavaScript linter
notification.group.narrowed.types=JavaScript\\: 已停用限縮的類型的著色
notification.group.nodejs.assistance=Node.js 編碼輔助失敗
notification.group.nodejs.interpreter=Node.js 解釋器路徑已更新
notification.group.package.json=來自 package.json 的相依項可用
notification.group.package.json.disabled=來自 package.json 的相依項\\: 通知已停用
notification.group.project.generator=JavaScript 專案生成失敗
notification.group.vitest=Vitest 測試執行失敗
notification.provideInlayHints.serviceDisabled=<code>provideInlayHints</code> 方法在 TypeScript 伺服器上失敗。請嘗試將 TypeScript 升級到至少 v5.9。<br/>當前正在使用內部嵌入提示實作。
notification.provideInlayHints.serviceRestored=<code>provideInlayHints</code> 方法已恢復正常執行。
notification.title.cannot.download.types.node=無法下載 @types/node
notification.title.cannot.enable.node.js.coding.assistance=無法啟用 Node.js 編碼輔助
notification.title.cannot.generate=無法生成 {0}
notification.title.coloring.types.narrowed.by.type.guard.was.disabled=按類型防護限縮類型著色被停用
notify.urls.more=…和其他 {0,number} 個
npm.before.run.task=執行 npm 腳本
npm.before.run.task.descr=執行 npm {0, choice, 0\\#腳本|1\\#腳本|2\\#腳本}{1} [{2}]
npm.dialog.message.cannot.resolve.package.manager=無法解析 ''{0}'' 軟體套件管理器
npm.downloading_package=正在下載 {0}…
npm.failed_to_install_package.title.message=無法安裝 {0}
npm.modules.inspection.content.of.require.module.not.installed.warning=未安裝模組
npm.modules.inspection.content.of.require.not.in.dependencies.warning=package.json 相依關係中未列出模組
npm.modules.install.global.types.dialog.title=安裝 TypeScript 定義
npm.modules.install.global.types.directory.error=無法建立所需的目錄
npm.modules.install.global.types.fix.name=安裝 TypeScript 定義以提供更好的類型資訊
npm.no.scripts.found=未找到腳本
npm.rc.command.label=指令\\:(&C)
npm.rc.environmentVariables.label=環境\\:
npm.rc.nodeInterpreter.label=Node 解釋器(&I)\\:
npm.rc.nodeOptions.label=Node 選項\\:
npm.rc.packageJson.browseDialogTitle=選擇 package.json 檔案
npm.rc.packageJson.label=package.json(&P)\\:
npm.rc.scripts.label=腳本 (&T)\\:
npm.rc.scriptsArguments.label=實參(&R)\\:
npm.searching_for_previously_installed_package=正在搜尋先前安裝的 {0}…
npm.task.title=NPM 腳本
numeric.enum.values=數值枚舉值
package.description=軟體套件 {0}
package.downloader.create.package.directory=正在建立軟體套件目錄…
package.json.install.types.fix.family.name=為軟體套件安裝 @types
package.version.range.hint={0, choice, 0\\#允許|1\\#允許次要更新\\:|2\\#允許補丁更新} {1} ≤ 版本 \\\\&lt; {2}
package.version.range.info={0, choice, 0\\#未安裝|1\\#已安裝\\: ?|2\\#已安裝\\: {1}}，最新\\: {2, choice, 0\\#正在載入…|1\\#找不到|2\\#{3}}
package_json.install_dependencies.notification.content=來自 {0}
package_json.install_dependencies.notification.title=安裝相依項
package_json.install_dependencies_multiple.notification.content=來自 {0} 和其他 {1} 個
package_json.notifications_are_disabled.notification.content=已停用從 {0} 安裝相依項的通知。<p>使用“{1}”動作重新啟用通知。
package_json.update_dependencies.notification.title=更新相依項
parameter.type.is.not.specified=參數 ''{0}'' 的類型未指定。\\n是否繼續?
parameters.in.parentheses=圓括號中的參數
parameters.in.parentheses.description=圓括號中的參數
please.specify.package.manager=指定<a href\\="">軟體套件管理器</a>。
popup.advertisement.latest.available.versions.for.all.distribution.tags=所有發行版標籤的最新可用版本
popup.advertisement.start.typing.package.name=開始輸入軟體套件名稱，以從 npm 官方公共註冊表中獲取更具體的結果
popup.content.cannot.edit.selected.node.js.interpreter=無法編輯選定的 Node.js 解釋器
popup.title.choose.class=選擇類別
popup.title.select.destructuring.assignment.target=選擇解構賦值目標
popup.title.target.function=目標函式
postfix.template.condition.array.name=陣列
postfix.template.condition.non.void.name=非 Void
postfix.template.provider.name=JavaScript 和 TypeScript
process.terminated=程序已終止
progress.subtitle.install=正在通過 {1} 安裝 {0}…
progress.text.initializing.opened.files=正在初始化開啟的檔案
progress.text.modifying=正在修改 {0}
progress.text.processing=正在處理 {0}{1}
progress.title.compiling.typescript.files=正在編譯 TypeScript 檔案
progress.title.configuring.node.js.coding.assistance=正在組態 Node.js 編碼輔助…
progress.title.detect.overridden.methods=檢查覆寫方法
progress.title.downloading.documentation=正在下載文檔
progress.title.downloading.library=正在下載庫
progress.title.downloading.typings=正在下載 typings
progress.title.executing.performance.task.on.files=正在檔案上執行性能任務
progress.title.find.usages=正在尋找用法…
progress.title.install=安裝 {0}
progress.title.install.npm.module=安裝 npm 模組 ''{0}''
project.generation=生成專案
protractor.rc.configurationFile.label=組態檔案(&C)\\:
protractor.rc.configurationFile.title=選擇 Protractor 組態檔案
protractor.rc.protractorOptions.emptyText=CLI 選項，例如 --browser 或 --rootElement
protractor.rc.protractorOptions.label=Protractor 選項 (&O)\\:
protractor.rc.protractorPackage.label=Protractor 軟體套件(&P)\\:
rc.browser.error.unspecified.url.text={0} 中未指定 URL
rc.browser.liveEdit.tab.name=瀏覽器 / Live Edit
rc.configuration.tab.name=組態
rc.environmentVariables.label=環境變數(&E)\\:
rc.nodeOptions.label=Node 選項 (&O)\\:
rc.testConfig.presentable.name={0} 中的所有測試
rc.testDirectory.presentable.name={0} 中的測試
rc.testOrSuiteScope.emptyTest=空測試名稱
rc.testOrSuiteScope.suite.label=套件名稱\\:
rc.testOrSuiteScope.suite.title=編輯套件名稱
rc.testOrSuiteScope.test.label=測試名稱\\:
rc.testOrSuiteScope.test.title=編輯測試名稱
rc.testRunScope.all=所有測試(&L)
rc.testRunScope.directory=目錄(&D)
rc.testRunScope.suite=套件
rc.testRunScope.test=測試(&T)
rc.testRunScope.testDirectory.browseTitle=選擇測試目錄
rc.testRunScope.testDirectory.label=測試目錄\\:
rc.testRunScope.testFile=測試檔案(&F)
rc.testRunScope.testFile.browseTitle=選擇測試檔案
rc.testRunScope.testFile.label=測試檔案\\:
rc.workingDirectory.browseDialogTitle=選擇工作目錄
rc.workingDirectory.label=工作目錄(&W)\\:
recursive.call=遞迴呼叫
refactoring.destructuring.vars.for.refactor.this=物件或陣列解構…
refactoring.destructuring.vars.intention.const.to.var.warning=在轉換期間，醒目提示顯示的 const 變數將轉換為 let 變數。\\n是否要繼續?
refactoring.destructuring.vars.intention.const.to.var.warning.title=變數關鍵字更改
refactoring.destructuring.vars.intention.deconstruct=生成解構模式
refactoring.destructuring.vars.intention.depropagate=將解構取代為屬性和索引存取
refactoring.destructuring.vars.intention.guard.conflict=通過類型 guard 將表達式類型限縮為 ''{0}''，該類型 guard 在重構後將不起作用
refactoring.destructuring.vars.intention.name=引入物件或陣列解構
refactoring.destructuring.vars.intention.name.array=引入陣列解構
refactoring.destructuring.vars.intention.name.object=引入物件解構
refactoring.destructuring.vars.intention.propagate=傳播到解構宣告
refactoring.destructuring.vars.intention.replace.array=取代為數組解構
refactoring.destructuring.vars.intention.replace.object=取代為物件解構
refactoring.destructuring.vars.intention.replace.promise=取代為 'await Promise.all'
refactoring.destructuring.vars.intention.replace.shorthand=取代為解構和速記屬性
reg.exp.tagged.template=''{1}'' 標記模板中的 {0}
remove.type.prefix=移除類型前綴
remove.unnecessary.parentheses.fix.text=移除不必要的圓括號
rename.accessors.dialog.text=是否將屬性存取器也重命名為 ''{0}''?
rename.accessors.dialog.title=重新命名欄位
rename.css.definition.description=檢測到 CSS 類型宣告的用法。應重新命名相關屬性，否則可能導致程式碼不一致。
rename.css.definition.title=重新命名類型宣告成員
rename.destructuring.property.description=解構屬性參照多個成員。應重新命名相關屬性，否則可能導致程式碼不一致。
rename.destructuring.property.title=重新命名解構屬性
rename.prompt.do.you.want.to.rename.base.method=是否要重新命名基方法?
rename.react.hook.variable.description=將相關狀態變數重命名為\\:
rename.react.hook.variable.title=重新命名狀態變數
rename.type.members.destructuring.description=檢測到解構屬性中的用法。應重新命名相關屬性，否則可能導致程式碼不一致。
rename.type.members.title=重新命名類型成員
rename.type.members.union.intersection.mapped.description=檢測到聯合體、相交或映射類型用法。應重新命名相關屬性，否則可能導致程式碼不一致。
replace.implements.keyword.fix.name=將 'implements' 更改為 'extends'
required.parameters.are.not.permitted.after.optional.parameters=必選參數不能位於可選參數後
return.type.is.not.resolved=返回值類型 ''{0}'' 未解析。\\n是否繼續?
service.configurable.default={0} (預設)
service.highlighting.progress={0} 服務醒目提示顯示
settings.code.style.Trailing.comma=尾隨逗號(&T)\\:
settings.code.style.always=始終
settings.code.style.dont.use=不使用
settings.code.style.double=雙
settings.code.style.in.new.code=在 IDE 生成的程式碼中
settings.code.style.indent.all.chained.calls.in.a.group=縮排組中的所有鏈式呼叫
settings.code.style.indent.chained.methods=縮排鏈式方法
settings.code.style.option.use=使用
settings.code.style.quotes=引號(&Q)
settings.code.style.semicolon.to.terminate.statements=分號(&S)
settings.code.style.single=單
settings.code.style.use=使用
settings.javascript.field.names.completion=為類別欄位建議名稱 (&F)
settings.javascript.lang.templates.configurable.name=模板
settings.javascript.linters.autodetect.configure.automatically=自動 {0} 組態 (&A)
settings.javascript.linters.autodetect.configure.automatically.help.text={0} 將使用 node_modules 目錄中的 {1} 軟體套件，還會使用與當前檔案或其任何父目錄位於同一目錄中的 {2} 組態檔案。
settings.javascript.linters.autodetect.configure.manually=手動 {0} 組態 (&M)
settings.javascript.linters.autodetect.disabled=停用 {0}(&D)
settings.javascript.linters.configurable.name=程式碼品質工具
settings.javascript.linters.eslint.configurable.name=ESLint
settings.javascript.linters.jshint.configurable.name=JSHint
settings.javascript.only.type.based.completion=僅基於類型補全 (&C)
settings.javascript.only.type.based.completion.tooltip=根據類型資訊顯示較少的補全建議。可能會顯著提高性能。
settings.javascript.opt.chain.completion=為可 null 類型建議包含可選鏈接的條目(&O)
settings.javascript.overrides.completion=在覆寫補全中展開方法體
settings.javascript.root.configurable.name=JavaScript
settings.javascript.runtime.configurable.name=JavaScript Runtime
settings.javascript.runtime.preferred.runtime.auto-detected.text=自動檢測
settings.javascript.runtime.preferred.runtime.context.help.description=For running and debugging within a project. Language services, ESLint, and tests will still use Node.js
settings.javascript.runtime.preferred.runtime.label.name=Preferred runtime\\:
settings.javascript.runtime.preferred.runtime.unavailable.text=不可用
settings.javascript.var.names.completion=建議變數和參數名稱(&V)
settings.javascript.var.names.completion.desc=補全名稱
settings.javascript.var.names.completion.names.only=無類型
settings.javascript.var.names.completion.types=為建議的參數名稱新增類型註解(&T)
settings.javascript.var.names.completion.types.everywhere=隨處都是類型
settings.javascript.var.names.completion.types.except.fields=隨處都是類型，欄位除外
settings.javascript.var.names.completion.types.for.params=具有函式參數的類型
settings.javascript.var.names.completion.types.for.params.fields=具有參數和欄位的類型
settings.nodejs.coding.assistance.label=Node.js 編碼協助 (&A)\\:
settings.nodejs.coding.assistance.manage.scopes.label=管理作用域…
settings.nodejs.name=Node.js
settings.typescript.root.configurable.name=TypeScript
space.after.dots.in.rest.spread=在 rest/spread 中的 '…' 後面
space.after.generator.mult=在產生器中的 '*' 後面 
space.after.name.value.separator=在屬性名稱-值分隔符 '\\:' 後面
space.after.type.colon=在類型參照冒號 '\\:' 後面
space.before.class.interface.module.lbrace=類別/接口/模組左大括號
space.before.class.lbrace=類別的左大括號
space.before.function.left.parenth=在函式表達式中
space.before.generator.mult=在產生器中的 '*' 前面 
space.before.name.value.separator=在屬性名稱-值分隔符 '\\:' 前面
space.before.type.colon=在類型參照冒號 '\\:' 前面
spaces.after.unary.not=在 'not' (\\!) 和 '\\!\\!' 後面
spaces.arrow.function=箭頭函式(\\=>)
spaces.async.arrow.function=在異步箭頭函式中
spaces.before.unary.not=在 'not' (\\!) 和 '\\!\\!' 前面
spaces.within.array.initializer=陣列中括號
spaces.within.import.braces=ES6 匯入/匯出大括號
spaces.within.indexer.brackets=索引存取中括號
spaces.within.interpolation.expressions=插值表達式
spaces.within.object.literal.braces=物件字面量大括號
spaces.within.object.type.braces=物件字面量類型大括號
spaces.within.type.assertion=類型斷言
spaces.within.unary.additive=一元加法運算符 (+,-,++,--)
spaces.within.union.and.intersection=聯合體與相交類型
standardjs.action.fix.problems.description=修正標準程式碼樣式問題
standardjs.codestyle.updated={0}\\: 專案程式碼樣式設定已更新
standardjs.codestyle.updated.config.section={0}\\: 專案程式碼樣式設定已根據 package.json 中的 ''standard'' 部分更新
standardjs.codestyle.updated.dependency={0}\\: 專案程式碼樣式設定已根據 package.json 中的 ''standard'' 相依項更新
standardjs.edit.settings.caption=ESlint/標準程式碼樣式
standardjs.editor.notification.action=是
standardjs.editor.notification.can.be.enabled.text=為此專案使用 JavaScript 標準程式碼樣式?
standardjs.editor.notification.do.not.show.text=否
standardjs.error.unsupported.package=不支持的軟體套件版本。請將 ''Standard'' 軟體套件升級到最低版本 {0}。
standardjs.name=標準程式碼樣式
start.template.string.interpolation.on.typing=鍵入 '$' 時啟動模板字串內插
status.text.add.interpreter.with=使用 {0} 新增解釋器
status.text.javascript.language.service.default.project.errors=顯示專案錯誤
status.text.javascript.language.service.suggestions=顯示建議
status.text.no.interpreters.added=未新增解釋器
status.text.project.structure.isn.t.available=專案結構不可用
status.text.running.which.node=正在執行 \`which node\`…
status.text.service.doesn.t.contain.open.projects=服務不包含開放專案
status.text.service.is.not.started=服務未啟動
structural.search.anonymous.functions=匿名函式
structural.search.classes=類別
structural.search.comparison.to.self=與自身比較
structural.search.console.log.calls=呼叫 console.log()
structural.search.constants=常數
structural.search.empty.functions=空函式
structural.search.function.calls=函式呼叫
structural.search.functions=函式
structural.search.functions.with.boolean.parameters=使用布爾參數的函式
structural.search.var.statements=Var 語句
structural.search.variables=變數
structural.search.while.loops=While 迴圈
structural.search.with.statements=With 語句
successfully.downloaded=已成功下載
superclass.cannot.be.extracted.from.enum=無法從枚舉中提取超類別
superclass.cannot.be.extracted.from.mxml.component=無法從 MXML 組件中提取超類別。
superclass.cannot.be.extracted.from.type.alias=無法從類型別名中提取超類別
superclass.label.text=超類別(&S)\\:
tab.title.compile.errors=編譯錯誤
tab.title.convert.to.class=轉換為類別
tab.title.project.errors=專案錯誤
tab.title.refactoring.preview=重構預覽
tab.title.refactoring.result=重構結果
template.add.imports=新增明確的 import
terminal.add_node_modules_bin_to_path.label=將 ''node_modules/.bin'' 從專案根目錄新增到 {0}
testing.select.in.test.tree.name=在測試樹中選擇 ''{0}''
testing.snapshot.update.all.tests.text=<link>點擊以更新所有失敗的快照</link>
testing.snapshot.update.single.test.text=<link>點擊以更新 ''{0}'' 的快照</link>
testing.snapshot.update.test.file.text=<link>點擊以更新 {0} 中所有失敗的快照</link>
text.cannot.download=無法下載 {0}。{1}
text.html.front.end.template.a.href.http.html5boilerplate.com=<html>前端模板<a href\\='http\\://html5boilerplate.com'>http\\://html5boilerplate.com</a></html>
text.html.sleek.intuitive.and.powerful.front.end.framework=<html>整潔、直觀、強大的前端框架，更快、更輕鬆地進行 Web 開發 <a href\\='http\\://getbootstrap.com'>http\\://getbootstrap.com</a></html>
titled.separator.predefined=預定義
top.level.package=頂層軟體套件
ts.add.import.all.family.name=新增所有 import
ts.add.import.hint.all.part=或全部使用 {0} 匯入
ts.add.import.hint.multiple.text=使用  {1} 為 {0} 新增匯入
ts.add.import.hint.text=使用 {1} 新增 {0}
ts.add.import.statement.dialog.title=新增 import 語句
ts.change.import.action.command=更改匯入
ts.change.import.action.dialog.title=匯入自…
ts.change.import.action.family.name=更改 ES6 匯入路徑
ts.change.import.action.many.title=更改匯入…
ts.change.import.action.one.title=更改為 {0}
ts.convert.alias.to.enum.action.family.name=將類型別名轉換為枚舉
ts.convert.alias.to.enum.action.title=將別名轉換為枚舉
ts.convert.alias.to.interface.action.family.name=將類型別名轉換為接口
ts.convert.alias.to.interface.action.title=將別名轉換為接口
ts.convert.field.to.parameter.property=將欄位轉換為參數屬性
ts.convert.parameter.property.to.field=將參數屬性轉換為欄位
ts.generate.reference.path.name=生成參照路徑註釋
ts.param.hints.blacklist.pattern.explanation=<b>棄用通知</b>\\: <p style\\="margin-left\\: 5px">從 TypeScript 4.4 開始，<code>provideInlayHints</code> 服務方法用於呈現提示。該方法有自己的啟發式方法；因此，不再使用此排除列表。
ts.param.hints.show.names.for.literal.args=字面量實參
ts.switch.to.jsx.inspection.name=更改檔案擴展名為 .tsx
ts.unresolved.variable.inspection.name=未解析的 TypeScript 參照
type.annotations=類型註解
type.is.not.resolved=類型 ''{0}'' 未解析。\\n是否繼續?
typescipt.import.options.paths.help=此選項用於組態 import 語句中使用的路徑樣式。<br><br>選擇“始終”時，IDE 會始終使用來自 tsconfig.json 組態的別名。<br><br>選擇“僅在指定路徑之外的檔案中”時，IDE 會為已定義別名的檔案之間的 import 使用相對路徑。在所有其他檔案中，將使用路徑映射。<br><br>選擇“從不”時，將從不使用別名。
typescript.abstract.class.constructor.can.be.made.protected=抽象類別建構函式可以設為 protected
typescript.auto.import.options.add.imports=自動新增 TypeScript import
typescript.before.task.check.errors=檢查錯誤
typescript.before.task.config.dialog.title=選擇 tsconfig.json
typescript.before.task.config.path=組態檔案\\:
typescript.before.task.title=TypeScript 編譯設定
typescript.code.style.tab.name=TypeScript
typescript.compiler.action.compile.all=全部編譯
typescript.compiler.action.compile.all.compile.config=組態 {0} 的編譯檔案
typescript.compiler.action.compile.all.description=編譯所有專案檔案
typescript.compiler.action.compile.current=編譯當前檔案
typescript.compiler.action.compile.description=編譯當前專案
typescript.compiler.action.compile.simple=編譯 TypeScript
typescript.compiler.action.compile.toolbar=編譯
typescript.compiler.action.compile.with.ellipsis=編譯…
typescript.compiler.action.no.compile.message=檔案未編譯，因為沒有從主檔案參照
typescript.compiler.before.run=編譯 TypeScript
typescript.compiler.configurable.name=TypeScript
typescript.compiler.configurable.options.command.line=選項\\:
typescript.compiler.configurable.options.command.line.localeNotSupportedForBundled=捆綁的 TypeScript 不支持區域設定
typescript.compiler.configurable.options.info.tsGo.local=<div>要使用本地克隆的 <a href\\='https\\://github.com/Microsoft/typescript-go/'>TypeScript-Go</a>，請先根據<a href\\='https\\://github.com/microsoft/typescript-go?tab\\=readme-ov-file\\#how-to-build-and-run'>說明</a>進行建置。</div><div>或者，您可以嘗試使用 <a href\\='https\\://github.com/microsoft/typescript-go?tab\\=readme-ov-file\\#preview'><code>@typescript/native-preview</code></a> 軟體套件。</div>
typescript.compiler.configurable.options.track.file.system=在更改時重新編譯
typescript.compiler.configurable.options.use.servicePoweredTypeEngine=啟用服務驅動的類型引擎
typescript.compiler.configurable.options.use.servicePoweredTypeEngine.comment=一種混合機制，結合了內部 IDE 模型<br>和語言服務的強大功能，以提高性能和類型推斷。<br>設定時需要啟用語言服務。
typescript.compiler.configurable.options.use.types.from.server=使用伺服器中的類型
typescript.compiler.configurable.options.use.types.from.server.description=啟用基於 TypeScript 編譯器的評估。
typescript.compiler.configurable.options.use.types.from.server.tsGoWarning=“啟用服務驅動的類型引擎”將被忽略，因為其尚不支持 TypeScript-Go
typescript.compiler.configurable.options.use.types.from.server.versionWarning=“啟用服務驅動的類型引擎”將被忽略，因為所選 TypeScript 版本低於 4.5
typescript.compiler.configurable.options.version=TypeScript\\:
typescript.compiler.configurable.options.version.bundled=已捆綁
typescript.compiler.loading.project=正在載入專案 {0}
typescript.compiler.starting=TypeScript 正在啟動…
typescript.compiler.structure.tab.title=結構
typescript.config.inspection=不一致的 Tsconfig.json 屬性
typescript.config.inspection.checkjs.info=屬性 checkJs 需要 allowJs 屬性
typescript.config.inspection.config.options.fix=向 tsconfig.json 中新增 ''{0}''
typescript.config.inspection.fix.pattern=新增 ''{0}'' 屬性
typescript.config.inspection.libs=缺少全域類別庫
typescript.config.inspection.libs.fix=在 tsconfig.json 中啟用庫 ''{0}''
typescript.config.inspection.missing.option=缺少 tsconfig.json 選項 
typescript.duplicate.typescript.union.inspection.name=重複的聯合體或相交類型組件
typescript.explicit.member.type.inspection.name=顯式類型
typescript.export.assignment.cannot.be.used.in.internal.modules=匯出不能在內部模組中使用的賦值
typescript.field.can.be.made.readonly=可以為唯讀欄位
typescript.fix.change.member.access=設為 ''{0}''
typescript.generics.should.not.be=類型 ''{0}'' 非泛型
typescript.go.bad.package=在 {0} 中找不到 TypeScript-Go 軟體套件
typescript.go.name=TypeScript-Go
typescript.import.options.exts.help=此選項用於組態 import 語句中的副檔名。<br><br>選擇“自動”時，IDE 會始終向 vue 檔案、來自在 tsconfig.json 中具有 "module"\\: "node16" 或 "module"\\: "nodenext" 和在 package.json 中具有 "type"\\: "module" 的專案的檔案，以及擴展名為 .mts 的檔案的名稱新增副檔名。<br><br>選擇“始終”時，IDE 會始終向 TypeScript 檔名新增 .js 副檔名。<br><br>選擇“從不”時，IDE 會始終使用不帶副檔名的檔名。
typescript.import.options.paths=使用 tsconfig.json 的路徑映射\\:
typescript.import.options.use.config=使用相對於 tsconfig.json 的路徑
typescript.include.js.sources.dialog.message=是否在此專案中包含 ''{0}'' 中的 JavaScript 檔案?
typescript.include.js.sources.dialog.title=包括軟體套件 {0}
typescript.include.js.sources.element=搜尋 JavaScript 宣告
typescript.insert.cast.fix=插入類型斷言
typescript.insert.type.guard.fix.family=插入類型 guard
typescript.insert.type.guard.nc=將限定符取代為 ''{0}''
typescript.insert.type.guard.nc.self=取代為 ''{0}''
typescript.insert.type.guard.postfix=使用 ''{0}'' 進行可選查詢
typescript.insert.type.guard.prefix=前綴為 ''{0}''
typescript.insert.type.guard.surround=封閉在 ''{0}''中
typescript.inspection.group.name=TypeScript
typescript.intention.convert.import.require=將 import require 轉換為 import from
typescript.intention.convert.import.require.text=轉換為 {0}
typescript.language.service.clean=正在重設快取…
typescript.language.service.compile.file=正在編譯檔案… {0}
typescript.language.service.compile.file.errors=正在計算錯誤… {0}
typescript.language.service.compile.project=正在編譯專案… {0}
typescript.language.service.compile.project.errors=正在計算專案錯誤… {0}
typescript.language.service.compile.project.open.file=正在開啟檔案… {0}
typescript.language.service.name=TypeScript 服務
typescript.language.simple.name=TypeScript
typescript.make.constructor.protected=將建構函式設為 protected
typescript.make.field.readonly=將欄位設為唯讀
typescript.missing.augmentation.import=缺少擴大匯入
typescript.narrowed.to=範圍限縮至 ''{0}''
typescript.private.field.modifiers.mix=使用不公開名稱的欄位不能具有 'public'、'private' 或 'protected' 存取修飾符
typescript.redundant.declaration=類型宣告與推斷的類型相符合，因此可以移除
typescript.redundant.instanceof.guard=''instanceof'' 檢查冗餘\\: ''{0}'' 具有類型 ''{1}'' 或 ''{1}'' 的子類型
typescript.redundant.instanceof.inheritor.guard=''instanceof'' 檢查冗餘\\: ''{0}'' 具有類型 ''{1}'' 或 ''{1}'' 的繼承者
typescript.redundant.typescript.type.argument.inspection.name=冗餘類型實參
typescript.reference.to.umd.global=已參照的 UMD 全域變數
typescript.remove.type.declaration=移除類型宣告
typescript.rename.dynamic.references=搜尋動態參照 (&D)
typescript.rename.javascript.references=在 JavaScript 檔案中搜尋(&J)
typescript.service.no.config=檔案未包括在任何 tsconfig.json 中
typescript.service.no.main.reference=檔案未處理，因為沒有從主檔案參照
typescript.smart.cast=範圍限縮的類型
typescript.smart.cast.hyperlink=設定字體和背景
typescript.specify.all.param.types.explicitly=顯式指定所有參數類型
typescript.specify.type.explicitly=顯式指定類型
typescript.suspicious.constructor.parameter.assignment=建構函式中的參數賦值可疑。您是否忘記了新增 'this.'?
typescript.suspicious.constructor.parameter.assignment.desc=已分配建構函式欄位參數
typescript.suspicious.instanceof.guard=''instanceof'' 檢查無效\\: ''{0}'' 的類型與 ''{1}'' 無關
typescript.type.guard.name=變數類型限縮為類型 guard
typescript.type.guard.name.disable=停用範圍限縮的類型的著色
typescript.type.predicate.destructuring=類型謂詞不能參照綁定模式中的元素。
typescript.type.predicate.incompatible.types=類型謂詞不可分配給 {0}
typescript.type.predicate.not.match.name=找不到參數 {0}
typescript.type.predicate.not.return=僅函式和方法的返回值類型位置允許類型謂詞
typescript.type.predicate.rest=類型謂詞不能參照 rest 參數
typescript.type.this.predicate.not.return=僅類別或接口成員、get 存取器或函式和方法的返回值類型位置允許基於 'this' 類型的謂詞。
typescript.types.intersection=相交
typescript.types.key=鍵參照
typescript.types.mapped=映射
typescript.types.merged=已合併
typescript.types.merged.accessor=合併存取器
typescript.types.merged.parts=參照的屬性\\:
typescript.types.module.not.installed.warning=無法解析模組 ''{0}'' 的定義
typescript.types.type.member={0} 類型屬性
typescript.types.union=聯合體
typescript.validate.generic.types.fix.add=新增泛型實參
typescript.validate.generic.types.fix.delete=移除泛型實參
typescript.validate.generic.types.inspection.error.argument.number=泛型類型 ''{0}'' 需要 ''{1}'' 類型實參
typescript.validate.generic.types.inspection.error.argument.number.between=泛型類型 ''{0}'' 需要介於 {1} 和 {2} 之間的類型實參
typescript.validate.generic.types.inspection.error.not.empty.argument=類型實參列表不能為空
typescript.validate.generic.types.inspection.error.not.empty.parameter=類型參數列表不能為空
typescript.validate.generic.types.inspection.name=不正確的泛型實參
typescript.validate.optional.parameter.inspection.error=參數不能有問號和初始設定式
typescript.validate.optional.parameter.inspection.fix.question=移除問號
typescript.validate.template.literal.types=模板類型 {1} 不可分配給約束類型 {0}
typescript.validation.async.incorrect.type.annotation=異步函式不能有 ''{0}'' 類型註解
typescript.validation.cannot.find.best.common.type=無法從用法推斷類型實參
typescript.validation.class.extend.constructor.return.not.class=基類別建構函式返回值類型 ''{0}'' 不是類別或接口類型。
typescript.validation.class.extend.cycled.definition=迴圈類別定義
typescript.validation.class.extend.many.constructors=基類別建構函式必須具有相同的返回值類型
typescript.validation.class.extend.no.type.arguments.type=沒有任何基類別建構函式具有指定數量的類型實參
typescript.validation.class.extend.not.constructor.type=類型 ''{0}'' 不是建構函式類型
typescript.validation.dissatisfies.type.annotation=類型 ''{0}'' 不滿足預期類型 ''{1}''
typescript.validation.expressionWithTypeArguments.compatibleSignatureNotFound=找不到相容的簽名
typescript.validation.generators.ambient=環境上下文中不允許使用產生器
typescript.validation.generators.async.no.yield=產生器隱式具有類型 'AsyncIterableIterator<any>'，因為它不產生任何值。請考慮提供返回值類型。
typescript.validation.generators.incorrect.type.annotation=發生器不能有 ''{0}'' 類型註解
typescript.validation.generators.incorrect.type.annotation.iterable=類型 ''{0}'' 不可分配給類型 ''{1}''。
typescript.validation.generators.no.yield=產生器隱式具有類型 'IterableIterator<any>'，因為它不產生任何值。請考慮提供返回值類型。
typescript.validation.generators.overload=多載簽名無法被宣告為產生器
typescript.validation.incorrect.rhs.in.private.brand=右側必須是一個物件，實際為\\: ''{0}''
typescript.validation.message.abstract.cannot.be.used=''{0}'' 修飾符不能與 ''abstract''修飾符一起使用
typescript.validation.message.abstract.cannot.have.body=方法不能具有實作，因為它被標記為 'abstract'
typescript.validation.message.abstract.class.be.created=無法建立抽象類別 ''{0}'' 的實例
typescript.validation.message.abstract.class.should.be=abstract 方法只能出現在抽象類別中
typescript.validation.message.abstract.member.access.super=無法通過 super 表達式存取 abstract 方法 ''{0}''。
typescript.validation.message.abstract.overload=多載簽名必須全部為 abstract 或非 abstract。
typescript.validation.message.constructor.cannot.be.abstract=建構函式不能為 'abstract'
typescript.validation.message.duplicate.modifier=已看到修飾符 {0}
typescript.validation.message.duplicate.modifier2=已看到可存取性修飾符
typescript.validation.message.function.implementation.missing=缺少函式實作或此宣告之後未緊隨函式實作
typescript.validation.message.getter.and.setter.must.have.same.access.type=Getter 和 setter 必須具有相同的存取類型
typescript.validation.message.invalid.modifier.cannot.be.here=修飾符 {0} 不能出現在此處
typescript.validation.message.invalid.module.member.modifier=''{0}'' 不是模組成員的有效修飾符
typescript.validation.message.misordered.in.modifier='in' 修飾符必須在 'out' 修飾符之前。
typescript.validation.message.unexpected.type.for.rest.parameter=Rest 參數必須為數組類型或具有陣列約束的泛型
typescript.validation.message.unexpected.type.for.rest.parameter.fix=取代為數組類型
typescript.validation.message.unique.symbol.mutable.non.static.field.declaration=類型為 'unique symbol' 類型的類別的屬性必須同時為 'static' 和 'readonly'
typescript.validation.message.unique.symbol.mutable.non.static.field.declaration.fix.add.static.readonly=新增 static 和 readonly 修飾符
typescript.validation.message.unique.symbol.mutable.property.signature=如果接口或類型字面量的類型是 'unique symbol' 類型，則其屬性必須為 'readonly'
typescript.validation.message.unique.symbol.mutable.variable=類型為 'unique symbol' 類型的變數必須為 'const'
typescript.validation.message.unique.symbol.wrong.usage=此處不允許使用 'unique symbol' 類型
typescript.validation.module.reference.with.extension=外部模組參照不能以擴展結束
unnecessary.parentheses.display.name=不必要的圓括號
unnecessary.parentheses.problem.descriptor=<code>\\#ref</code> 周圍的圓括號不必要 \\#loc
unresolved.project.interpreter.notification.content=要正常工作，{0} 需要 Node.js，但在您的計算機上找不到 Node.js。
unresolved.project.interpreter.notification.download.action.text=下載 Node.js
unresolved.project.interpreter.notification.download.action.url=https\\://nodejs.org/en/download
unwrap.with.kind=解包 ''{0}…''
variables.and.fields=變數和欄位
variables.and.fields.description=變數和欄位
varible.name.column.title=名稱
varible.value.column.title=值
visibility.level.details=詳細資訊
visibility.level.overview=概覽
vitest.coverage.cannot.copy.lcov.info.notification.content=無法顯示 Vitest 覆蓋率\\: 無法複製檔案。
vitest.coverage.cannot.find.lcov.info.notification.content=無法顯示 Vitest 覆蓋率\\: 找不到 {0}。
vitest.coverage.directory.not.found.notification.content=無法從 Vitest 組態中讀取 coverageDirectory 選項
vitest.coverage.notification.title=Vitest 覆蓋率
vitest.coverage.presentable.text=Vitest 覆蓋率
vitest.rc.configurationFile.label=組態檔案(&C)\\:
vitest.rc.configurationFile.title=選擇 Vitest 組態檔案
vitest.rc.vitestOptions.emptyText=CLI 選項，例如 --watch 或 --ui
vitest.rc.vitestOptions.label=Vitest 選項\\:
vitest.rc.vitestPackageField.label=Vitest 軟體套件(&V)\\:
vitest.snapshot.update.rc.name=更新 {0} 的快照
web.bundler.analyzing.configs.progress=正在分析 Web 捆綁程序的組態檔案
web.bundler.cannot.analyze=無法分析 {0}\\: 編碼輔助將忽略此檔案中的模組解析規則。
web.bundler.error.details=錯誤詳細資訊\\: {0}
web.bundler.failed.to.load=無法載入 {0}
web.bundler.possible.reasons=可能的原因\\: 此檔案不是有效的組態檔案，或者 IDE 目前不支持其格式。
web.template.file-type.description={0} 模板
yarn.package_requires_yarn.dialog.message=軟體套件“{0}”要求 Yarn {1}。
yarn.pnp.library_name=來自 {0} 的相依項
yarn.pnp.requires.yarn.package_manager.dialog.message=Yarn PnP 需要 Yarn <a href\\="">軟體套件管理器</a>
{0}.visibility.will.break.methods.hierarchy=可見性為 {1} 的{0}無法參與層次結構
"
`;

exports[`src messages/PhpBundle.properties 1`] = `
"0=\\ ({0})
0.1={0}，{1}
0.1.choice.0.extends.1.implements.2={0}{1, choice, 0\\# 擴展 |1\\# 執行 }{2}
0.12={0}\\:{1}
0.and.1.define.the.same.property.2=''{0}'' 和 ''{1}'' 定義相同的屬性 ''{2}''
0.by.remote.interpreter=通過遠端解釋器{0}
0.completion.shortcut=使用{1}進行{0}補全
0.extends.1={0} 擴展 {1}
0.for.1.run.configuration={1} 執行組態的 {0}
0.local={0}本地
0.location={0} 位置
0.path={0} 路徑\\:
0.pushing.members.down.will.result.in.them.being.deleted={0}\\n向下推送成員將導致它們被刪除
0.should.not.extend.itself={0} 不應自行擴展
0.with.same.name.already.defined.in.this.class=此類別中已經定義了具有相同名稱的{0}
02={0}\\:\\:
03=({0})
04={0}\\:
12.hour.format.of.an.hour.with.leading.zeros=帶前導零的 12 小時格式小時(01 到 12)
12.hour.format.of.an.hour.without.leading.zeros=不帶前導零的 12 小時格式小時(1 到 12)
24.hour.format.of.an.hour.with.leading.zeros=帶前導零的 24 小時格式小時(00 到 23)
24.hour.format.of.an.hour.without.leading.zeros=不帶前導零的 24 小時格式小時(0 到 23)
DBGPProxyConfigurable.display.name=DBGp 代理
DBGPProxyConfigurable.host=主機\\:
DBGPProxyConfigurable.ide.key=IDE 鍵\\:
DBGPProxyConfigurable.port=連接埠\\:
PhpBuiltInWebServerRunConfigurationEditor.configuration.description=PHP 內建 Web 伺服器組態
PhpBuiltInWebServerRunConfigurationEditor.configuration.display.name=PHP 內建 Web 伺服器
PhpBuiltInWebServerRunConfigurationEditor.document.root=文檔根\\:
PhpBuiltInWebServerRunConfigurationEditor.host=主機\\:
PhpBuiltInWebServerRunConfigurationEditor.port=連接埠\\:
PhpBuiltInWebServerRunConfigurationEditor.title=伺服器組態
PhpBuiltInWebServerRunConfigurationEditor.use.router.script=使用 router 腳本\\:
PhpCommandLineConfigurationEditor.command.line=命令行
PhpCommandLineConfigurationEditor.field.custom.working.directory=自訂工作目錄\\:
PhpCommandLineConfigurationEditor.field.environment.variables=環境變數\\:
PhpCommandLineConfigurationEditor.field.interpreter.options=解釋器選項\\:
PhpCommandLineConfigurationEditor.interpreter.options.editor.dialog.caption=解釋器選項
PhpDebugConfigurable.advanced.settings=進階設定
PhpDebugConfigurable.break.at.first.line=在 PHP 腳本中的第一行中斷
PhpDebugConfigurable.detect.path.mappings.from.deployment=檢測部署組態的路徑映射
PhpDebugConfigurable.evaluation=評估
PhpDebugConfigurable.external.connections=外部連線
PhpDebugConfigurable.ignore.external.connections.through.unregistered.server.configurations.label=通過未註冊的伺服器組態忽略外部連線
PhpDebugConfigurable.import.use.statements=從求值上下文匯入命名空間和 'use' 語句
PhpDebugConfigurable.notify.resolved.breakpoint=通知是否將中斷點解析為另一行(Xdebug 2.8+)
PhpDebugConfigurable.notify.session.stopped.without.pause=在偵錯會話完成而不暫停時通知
PhpDebugConfigurable.pass.required.configuration.options=通過命令行傳遞所需組態選項(仍需要手動啟用偵錯擴展)
PhpDebugConfigurable.remote.debug.listen.for.connections=3. 啟動“PHP 遠端偵錯”執行組態。
PhpDebugConfigurable.safe.evaluation.mode=值提示和監視框架下的安全求值模式
PhpDebugConfigurable.show.array.children.in.repl=在偵錯主控台中顯示陣列和物件子級
PhpDebugConfigurable.web.page.listen.for.connections=2. 啟動“PHP 網頁”執行組態。
PhpDebugConfigurable.web.page.pre.config.title=偵錯預組態
PhpDebugConfigurable.xdebug=Xdebug
PhpDebugConfigurable.xdebug.debug.port=Xdebug 偵錯連接埠
PhpDebugConfigurable.xdebug.force.break.no.path.mapping=未指定路徑映射時，在第一行強制中斷
PhpDebugConfigurable.xdebug.force.break.when.outside.project=當腳本在專案外部時，在第一行強制中斷
PhpDebugConfigurable.xdebug.resolve.breakpoints=如果中斷點在當前行不可用，則解析中斷點(Xdebug 2.8+)
PhpDebugConfigurable.zend.debug.port=Zend Debugger 偵錯連接埠
PhpDebugConfigurable.zend.debugger=Zend 偵錯器
PhpDebugConfigurable.zend.settings.broadcasting.port=Zend Debugger 設定廣播連接埠
PhpDebugConfigurable.zend.settings.ide.hosts=Zend Debugger IDE 主機
PhpDebugConfigurable.zend.settings.ide.hosts.detect=正在檢測…
PhpDebugConfigurable.zend.settings.ide.hosts.detect.progress=正在檢測 Zend Debugger 的 IP…
PhpDebugConfigurable.zero.configuration=預組態
PhpDebugConfigurable.zero.configuration.install.debugger.php.instruction=1. 安裝
PhpDebugConfigurable.zero.configuration.install.php.instruction=或
PhpDebugConfigurable.zero.configuration.install.php.validate=Web 伺服器上的偵錯器組態。
PhpDebugConfigurable.zero.configuration.install.php.validate.action=驗證
PhpDebugConfigurable.zero.configuration.install.toolbar.instruction=瀏覽器工具列或小書籤。
PhpDebugConfigurable.zero.configuration.install.toolbar.instruction.label=2. 安裝
PhpDebugConfigurable.zero.configuration.install.xdebug.php.instruction=Xdebug
PhpDebugConfigurable.zero.configuration.install.zend.debugger.php.action=Zend 偵錯器
PhpDebugConfigurable.zero.configuration.install.zend.debugger.php.instruction=在 Web 伺服器上。
PhpDebugConfigurable.zero.configuration.listen.for.connections=3. 啟用 PHP 偵錯連線偵聽\\:
PhpDebugConfigurable.zero.configuration.listen.for.connections.action=開始偵聽
PhpDebugConfigurable.zero.configuration.start.session=4. 使用工具列或小書籤在瀏覽器中啟動偵錯會話。
PhpDebugConfigurable.zero.configuration.stop.listen.for.connections.action=停止偵聽
PhpDebugConfigurable.zero.configuration.tutorial=有關更多資訊，請參見
PhpDebugConfigurable.zero.configuration.tutorial.action=“零組態偵錯”教程
PhpDebugSkippedPathsConfigurable.column.title=跳過的路徑
PhpDebugSkippedPathsConfigurable.display.name=跳過的路徑
PhpDebugSkippedPathsConfigurable.notify.about.skipped.files=通知跳過的檔案
PhpExtractMethodDialog.declare.static=宣告 static(&S)
PhpExtractMethodDialog.duplicates.count=檢查並取代重複項(找到 {0} 個)
PhpExtractMethodDialog.duplicates.pending=正在搜尋重複項…
PhpExtractMethodDialog.extract.function=提取函式
PhpExtractMethodDialog.extract.method=提取方法
PhpExtractMethodDialog.function=函式\\:
PhpExtractMethodDialog.generate.php.doc=生成 PhpDoc(&G)
PhpExtractMethodDialog.generate.php.doc.inplace=生成 PHPDoc
PhpExtractMethodDialog.method=方法\\:
PhpExtractMethodDialog.name=名稱(&A)\\:
PhpExtractMethodDialog.output.variables=輸出變數
PhpExtractMethodDialog.parameters=參數
PhpExtractMethodDialog.private=private(&V)
PhpExtractMethodDialog.protected=protected(&T)
PhpExtractMethodDialog.public=public(&B)
PhpExtractMethodDialog.replace.tail.break.continue.with.return=將尾“break/continue”語句取代為“return”語句(&T)
PhpExtractMethodDialog.return.output.through=通過以下方式返回輸出變數\\:
PhpExtractMethodDialog.return.output.through.ref.parameters=通過參照傳遞的參數(&P)
PhpExtractMethodDialog.return.output.through.return=return 語句(&E)
PhpExtractMethodDialog.signature.preview=簽名預覽
PhpExtractMethodDialog.transformation.options=轉換選項
PhpExtractMethodDialog.visibility=可見性\\:
PhpFrameworksCommonConfigurable.display.name=框架
PhpHttpRequestRunConfiguration.configuration.description=HTTP 請求組態
PhpHttpRequestRunConfiguration.configuration.display.name=PHP HTTP 請求
PhpHttpRequestRunConfiguration.error.fetch.result=響應正文不可用
PhpHttpRequestRunConfiguration.error.host.is.not.specified=伺服器 ''{0}'' 的主機未指定或無效
PhpHttpRequestRunConfiguration.error.server.configuration=無法執行 HTTP 請求\\: ''{0}''。請在“PHP|伺服器”下檢查伺服器組態。
PhpHttpRequestRunConfiguration.error.server.is.not.specified=找不到名稱為 ''{0}'' 的遠端伺服器
PhpHttpRequestRunConfiguration.error.url.is.not.specified=URL 未指定或無效\\: ''{0}''。
PhpIncomingConnectionDialog.file.path.on.server=伺服器上的檔案路徑\\:
PhpIncomingConnectionDialog.request.uri=請求 URI\\:
PhpIncomingConnectionDialog.server.name=伺服器名稱\\:
PhpIncomingConnectionDialog.server.port=伺服器連接埠\\:
PhpIncomingLocalConnectionDialog.file.path=檔案路徑\\:
PhpInterpreter.configuration.duplicate.interpreter.name=找到了具有非唯一名稱 ''{0}'' 的 PHP 解釋器。
PhpInterpreter.configuration.in.project.settings.message=無法將 PHP 解釋器指定為預設 SDK。您可以在“設定| PHP”中為當前專案組態
PhpInterpreter.configuration.in.project.settings.title=PHP 解釋器組態
PhpInterpreter.configuration.interpreter.is.invalid=啟用“PHP Remote Interpreters”延伸模組以編輯解釋器。
PhpInterpreter.configuration.selection.list.title=選擇 CLI 解釋器
PhpInterpreter.php.debugger.label=偵錯器\\:
PhpInterpreter.php.dependent.configuration.exists=所選 PHP 解釋器有{0}組態。確定要刪除此解釋器嗎?
PhpInterpreter.php.dependent.configuration.exists.title=PHP 解釋器相依組態
PhpInterpreter.php.general.title=一般
PhpInterpreter.php.home.path.label=PHP 可執行檔案\\:
PhpInterpreter.php.interpreter.name.conflict=發現專案級和應用程式級解釋程序名稱存在衝突。為解決該問題，以下專案級解釋器被重新命名\\:
PhpInterpreter.php.interpreter.name.conflict.title=解釋器名稱衝突
PhpInterpreter.php.sdk.type=PHP 解釋器
PhpInterpreterConfigurable.can.not.updated.phpinfo=無法更新 phpinfo
PhpInterpreterConfigurable.configuration.default.project.tooltip=無法僅為預設專案儲存解釋器。
PhpInterpreterConfigurable.configuration.file.can.not.find=無法通過路徑找到檔案\\: ''{0}''
PhpInterpreterConfigurable.configuration.file.can.not.find.title=找不到組態檔案
PhpInterpreterConfigurable.configuration.file.evaluate.dir=正在評估組態檔案目錄…
PhpInterpreterConfigurable.configuration.file.fix=在 {0} 目錄中建立 php.ini 檔案，<br><br>組態檔案模板可在 php 根目錄中找到\\:<br>“php.ini-development”- 預設設定<br>“php.ini-production”- 推薦設定。<br>
PhpInterpreterConfigurable.configuration.file.fix.failed.to.detect=使用“{0} --ini”指令確定組態檔案目錄。<br>
PhpInterpreterConfigurable.configuration.file.fix.link=<br>點擊此<a href\\="http\\://php.net/manual/en/configuration.file.php">鏈接</a>獲取更多資訊。
PhpInterpreterConfigurable.configuration.file.fix.title=組態 php.ini 檔案不存在
PhpInterpreterConfigurable.configuration.file.hhvm.fix=在 <b>/etc/hhvm</b> 目錄中建立 php.ini 檔案，<br><br>點擊此<a href\\="http\\://docs.hhvm.com/manual/en/configuration.file.php">>鏈接</a>獲取更多資訊。
PhpInterpreterConfigurable.configuration.file.path=組態檔案\\: {0}
PhpInterpreterConfigurable.configuration.file.path.not.found=組態 php.ini 檔案不存在
PhpInterpreterConfigurable.configuration.options.description=這些選項將使用 '-d' 命令行選項傳遞
PhpInterpreterConfigurable.configuration.options.dialog.caption=組態選項
PhpInterpreterConfigurable.configuration.options.label=組態選項\\:
PhpInterpreterConfigurable.configuration.options.table.empty.text=為 php.ini 中允許的任何組態指令設定自訂值
PhpInterpreterConfigurable.configuration.options.table.name=組態指令
PhpInterpreterConfigurable.configuration.options.table.value=值
PhpInterpreterConfigurable.configuration.options.with.empty.name.are.not.allowed=不允許名稱為空的組態選項
PhpInterpreterConfigurable.configuration.project.level=僅對此專案可見
PhpInterpreterConfigurable.configuration.project.tooltip=檢查是否不想在專案之間共享解釋器
PhpInterpreterConfigurable.configuration.title=其他
PhpInterpreterConfigurable.debugger.extension.description=將僅為從 CLI 執行組態啟動的偵錯會話載入偵錯器擴展
PhpInterpreterConfigurable.debugger.extension.label=偵錯器擴展\\:
PhpInterpreterConfigurable.debugger.extension.title=選擇偵錯器擴展路徑
PhpInterpreterConfigurable.download.xdebug.extension=下載 Xdebug 擴展程序
PhpInterpreterConfigurable.generate.xdebug.extension=生成安裝腳本
PhpInterpreterConfigurable.install.xdebug.extension=下載並安裝 Xdebug 擴展程序
PhpInterpreterConfigurable.not.installed=未安裝
PhpInterpreterConfigurable.php.ini.title=選擇組態檔案或目錄
PhpInterpreterConfigurable.php.version=PHP 版本\\: {0}
PhpInterpreterConfigurable.reload.phpinfo=重新載入 phpinfo
PhpInterpreterConfigurable.show.phpinfo=顯示 phpinfo
PhpInterpreterConfigurable.update.helpers.title=正在更新幫助程序目錄…
PhpInterpreterConfigurable.updated.phpinfo=已成功更新 phpinfo
PhpInterpreterConfigurable.xdebug.was.not.installed=Xdebug 安裝失敗
PhpInterpreterConfigurable.xdebug.was.successfully.installed=Xdebug 已成功安裝
PhpPathMappingsConfigurable.use.path.mappings.label=使用路徑映射(選擇伺服器是遠端伺服器還是使用符號鏈接)
PhpProjectConfigurable.advanced.settings=進階設定(&V)
PhpProjectConfigurable.analysis=分析
PhpProjectConfigurable.analysis.custom.format.functions=自訂格式函式
PhpProjectConfigurable.default.stubs.path=預設存根路徑(&D)\\:
PhpProjectConfigurable.docker.default.project.error.tooltip=開啟或建立專案以組態 Docker 容器
PhpProjectConfigurable.exception.analysis=異常分析
PhpProjectConfigurable.exception.analysis.depth=呼叫樹分析路徑\\:
PhpProjectConfigurable.exception.analysis.unchecked.exceptions=未檢查的異常\\:
PhpProjectConfigurable.include.analysis=Include 分析
PhpProjectConfigurable.include.path=Include 路徑
PhpProjectConfigurable.interpreter=CLI 解釋器\\:
PhpProjectConfigurable.language.level=PHP 語言級別(&P)\\:
PhpProjectConfigurable.php.runtime=PHP 執行時
PhpProjectConfigurable.select.default.stubs.path.description=選擇預設存根路徑
PhpProjectConfigurable.select.default.stubs.path.title=選擇預設存根路徑
PhpProjectConfigurable.select.document.root.path.description=選擇 $_SERVER['DOCUMENT_ROOT'] 路徑
PhpProjectConfigurable.select.document.root.path.title=選擇 $_SERVER['DOCUMENT_ROOT'] 路徑
PhpRemoteDebugRunConfigurationEditor.auto.config=通過 IDE 鍵篩選偵錯連線
PhpRemoteDebugRunConfigurationEditor.configuration.description=PHP 偵錯組態
PhpRemoteDebugRunConfigurationEditor.configuration.display.name=PHP 遠端偵錯
PhpRemoteDebugRunConfigurationEditor.filter.connections.help=適用於複雜伺服器設定，例如同一主機連接埠上有多個應用程式。<p/>保持未選中狀態以自動檢測組態，或使用<i>“偵聽偵錯連線”</i>動作。
PhpRemoteDebugRunConfigurationEditor.filter.connections.help.link=閱讀更多資訊
PhpRemoteDebugRunConfigurationEditor.filter.connections.help.title=進階選項
PhpRemoteDebugRunConfigurationEditor.server.label=伺服器(&E)\\:
PhpRemoteDebugRunConfigurationEditor.session.id.cannot.be.empty=IDE 鍵(會話 ID)不能為空
PhpRemoteDebugRunConfigurationEditor.session.id.label=IDE 鍵(會話 ID)(&K)\\:
PhpRemoteDebugRunConfigurationEditor.stop.zero.configuration=PhpStorm 已停止偵聽傳入偵錯連線。
PhpRemoteDebugRunConfigurationEditor.stop.zero.configuration.title=已停止偵聽傳入 PHP 偵錯連線
PhpRemoteDebugRunConfigurationEditor.zero.configuration.is.already.used=“偵聽傳入偵錯連線”已啟用，不會發生任何變化。<br/>檢視<a href\\="zero_config">零組態偵錯</a>獲取更多資訊。<br/><br/>要停止偵聽偵錯連線，請使用<a href\\="stop">執行|停止偵聽 PHP 偵錯連線</a>。
PhpRemoteDebugRunConfigurationEditor.zero.configuration.used=沒有為 <i>''{0}''</i> 執行組態指定<i>伺服器</i>，因此 PhpStorm 將偵聽所有傳入偵錯連線。<br/>檢視<a href\\="zero_config">零組態偵錯</a>獲取更多資訊。<br/><br/>要停止偵聽偵錯連線，請使用<a href\\="stop">執行|停止偵聽 PHP 偵錯連線</a>。
PhpRemoteDebugRunConfigurationEditor.zero.configuration.used.title=已開始偵聽傳入 PHP 偵錯連線
PhpScripRunConfigurationEditor.arguments=實參\\:
PhpScripRunConfigurationEditor.arguments.caption=實參
PhpScripRunConfigurationEditor.configuration.description=PHP 腳本組態
PhpScripRunConfigurationEditor.configuration.display.name=PHP 腳本
PhpScripRunConfigurationEditor.file=檔案\\:
PhpServerConfigurable.debugger.label=偵錯器(&D)
PhpServerConfigurable.host=主機
PhpServerConfigurable.host.label=主機(&H)\\:
PhpServerConfigurable.port=連接埠
PhpServerConfigurable.port.label=連接埠(&P)
PhpServerConfigurable.shared=共享(&S)
PhpStepFilters.log.frame=框架已被跳過。函式名稱\\: {0}。遠端檔案 URL\\: {1}
PhpStepFiltersConfigurable.add.method=新增方法
PhpStepFiltersConfigurable.display.name=步進篩選器
PhpStepFiltersConfigurable.skip.constructors=跳過建構函式
PhpStepFiltersConfigurable.skip.magic.methods=跳過魔術方法
PhpStepFiltersConfigurable.skipped.files=跳過的檔案
PhpStepFiltersConfigurable.skipped.methods=跳過的方法
PhpStepFiltersConfigurable.specify.method.name=指定方法名稱
PhpStepFiltersConfigurable.title.files=檔案
PhpStepFiltersConfigurable.title.methods=方法
PhpUnitConfigurableForm.can.not.find.custom.loader=在 ''{0}'' 下找不到自動載入器腳本
PhpUnitConfigurableForm.can.not.find.paratest=在 ''{0}'' 下找不到 ParaTest
PhpUnitConfigurableForm.can.not.find.phpunit.phar=在 ''{0}'' 下找不到 phpunit.phar
PhpUnitConfigurableForm.custom.loader.is.directory=自動載入器不應為目錄，對於預設 Composer 組態，將路徑設定為“vendor/autoload.php”
PhpUnitConfigurableForm.custom.loader.is.empty=自動載入器檔案的路徑為空
PhpUnitConfigurableForm.default.paratest.binary=預設 ParaTest 二進制檔案\\:
PhpUnitConfigurableForm.download.phpunit.phar.link.text=從 {0} 下載 phpunit.phar
PhpUnitConfigurableForm.paratest.path=預設 ParaTest 二進制檔案
PhpUnitConfigurableForm.path.to.phpunit.phar=phpunit.phar 路徑
PhpUnitConfigurableForm.path.to.script=腳本路徑\\:
PhpUnitConfigurableForm.phpunit.library=PHPUnit 庫
PhpUnitConfigurableForm.phpunit.paratest.is.empty=ParaTest 的路徑為空
PhpUnitConfigurableForm.phpunit.phar.is.empty=phpunit.phar 路徑為空
PhpUnitConfigurableForm.specified.wrong.paratest.binary=指定了錯誤的 ParaTest 二進制檔案，請改用 'paratest_for_phpstorm'
PhpUnitConfigurableForm.test.runner=測試執行程序
PhpUnitConfigurableForm.unsupported.paratest.version=<html>安裝的 ParaTest 版本不支持與 PHPStorm 整合。<br>請將 ParaTest 更新到 6.5.0 或更高版本。</html>
PhpUnitConfigurableForm.use.bootstrap.file=預設啟動檔案\\:
PhpUnitConfigurableForm.use.bootstrap.file.validation.warning=為 ''{0}'' 提供啟動檔案的路徑，或停用“預設啟動檔案”選項
PhpUnitConfigurableForm.use.configuration.file=預設組態檔案\\:
PhpUnitConfigurableForm.use.configuration.file.validation.warning=為 ''{0}'' 提供組態檔案的路徑，或停用“預設組態檔案”選項
PhpUnitConfigurableForm.use.custom.loader=使用 Composer 自動載入器
PhpUnitConfigurableForm.use.paratest=使用 ParaTest\\:
PhpUnitConfiguration.interpreter.conflict=發現應用程式級 PHPUnit 組態衝突。為解決該問題，建立了以下組態的專案級副本\\:
PhpUnitConfiguration.interpreter.conflict.title=PHPUnit 組態衝突
PhpUnitTestRunnerConfigurationEditor.dialog.caption.test.runner.options=測試執行程序選項
PhpUnitTestRunnerConfigurationEditor.field.class=類別\\:
PhpUnitTestRunnerConfigurationEditor.field.directory=目錄\\:
PhpUnitTestRunnerConfigurationEditor.field.file=檔案\\:
PhpUnitTestRunnerConfigurationEditor.field.method=方法\\:
PhpUnitTestRunnerConfigurationEditor.field.test.runner.coverage.engine=首選覆蓋率引擎\\:
PhpUnitTestRunnerConfigurationEditor.field.test.runner.options=測試執行程序選項(&O)\\:
PhpUnitTestRunnerConfigurationEditor.scope=測試作用域\\:
PhpUnitTestRunnerConfigurationEditor.scope.class=類別
PhpUnitTestRunnerConfigurationEditor.scope.directory=目錄
PhpUnitTestRunnerConfigurationEditor.scope.method=方法
PhpUnitTestRunnerConfigurationEditor.scope.xml=在組態檔案中定義
PhpUnitTestRunnerConfigurationEditor.test.runner=測試執行程序
PhpUnitTestRunnerConfigurationEditor.use.alt.bootstrap.file=使用替代啟動檔案(&U)\\:
PhpUnitTestRunnerConfigurationEditor.use.alt.configuration.file=使用替代組態檔案(&U)\\:
PhpUserDefinedConstantsGroup.name=常數
PhpWebAppRunConfigurationEditor.browser=瀏覽器(&B)\\:
PhpWebAppRunConfigurationEditor.configuration.description=PHP 網頁組態
PhpWebAppRunConfigurationEditor.configuration.display.name=PHP 網頁
PhpWebAppRunConfigurationEditor.malformed.start.url=起始 URL 的格式錯誤 - {0}
PhpWebAppRunConfigurationEditor.startUrl=起始 URL(&U)\\:
RunConfigurationEditor.configuration=組態
RunConfigurationEditor.error.server.is.not.exist=名稱為 ''{0}'' 的伺服器不存在
RunConfigurationEditor.error.server.is.not.selected=未選擇伺服器
RunConfigurationEditor.server=伺服器(&S)\\:
XdebugCloudConfigurable.base.host=Cloud 主機\\:
XdebugCloudConfigurable.cloud.id=Cloud ID\\:
XdebugCloudConfigurable.connect.via.xdebug.cloud=連線到 Xdebug Cloud
XdebugCloudConfigurable.custom.server=連線到預置 Xdebug Cloud
XdebugCloudConfigurable.display.name=Xdebug Cloud
XdebugCloudConfigurable.port=Cloud 連接埠\\:
a.class.constant.must.not.be.called.class.it.is.reserved.for.class.name.fetching=類別常數不得被稱為 'class'；後者被保留用於類別名提取
a.full.numeric.representation.of.a.year.at.least.4.digits.with.for.years.bce=年份的完整數字表示，至少 4 位數，使用 - 表示公元前的年份(2022 年)
a.full.textual.representation.of.a.month.such.as.january.or.march=月份的完整文本表示，英語(January 到 December)
a.full.textual.representation.of.the.day.of.the.week=星期几的完整文本表示(Sunday 到 Saturday)
a.short.textual.representation.of.a.month.three.letters=月份的短文本表示，三個英語字母(Jan 到 Dec)
a.textual.representation.of.a.day.three.letters=星期几的文本表示，三個英語字母(Mon 到 Sun)
a.trait.cannot.extend.a.class=特徵無法擴展類別
a.trait.cannot.implement.an.interface=特徵無法實作接口
a.two.digit.representation.of.a.year=年份的兩位數表示(22)
absolute.reference.is.not.allowed=不允許絕對參照
abstract.modifier.is.not.allowed.here=此處不允許使用 'Abstract' 修飾符
access.level.to.0.1.must.be.2.as.in.class.3.or.weaker=''{0}\\:\\:\${1}'' 的存取級別必須為 {2} (與類別 {3} 中一樣)或更低
access.level.to.0.1.must.be.2.as.in.class.3.or.weaker2=''{0}\\:\\:{1}'' 的存取級別必須為 {2} (與類別 {3} 中一樣)或更低
access.must.be.public=存取必須為 public
access.type.for.interface.member.must.be.omitted=接口成員的存取類型必須省略
action.ChangePHPInterpreter.description=更改專案 PHP 解釋器
action.ChangePHPInterpreter.text=更改 PHP 解釋器
action.ComposerAddDependencyAction.description=管理 Composer 相依項
action.ComposerAddDependencyAction.text=管理相依項…
action.ComposerClearCacheAction.description=刪除 Composer 快取目錄中的所有內容
action.ComposerClearCacheAction.text=清除快取
action.ComposerDiagnoseAction.description=檢查常見的 Composer 問題
action.ComposerDiagnoseAction.text=診斷
action.ComposerDryRunUpdate.description=模擬更新，但不實際更新
action.ComposerDryRunUpdate.text=模擬更新
action.ComposerDumpAutoloadAction.description=重新生成自動載入類別的列表
action.ComposerDumpAutoloadAction.text=傾印自動載入器…
action.ComposerInstallAction.description=考慮到 composer.lock，安裝 composer.json 中的軟體套件
action.ComposerInstallAction.text=安裝
action.ComposerLicensesAction.description=列出安裝的每個軟體套件的名稱、版本和授權
action.ComposerLicensesAction.text=列出授權
action.ComposerSelfUpdateAction.description=將 Composer 本身更新到最新版本
action.ComposerSelfUpdateAction.text=自我更新
action.ComposerShowLogAction.description=顯示包含此 composer.json 的 Composer 動作日誌
action.ComposerShowLogAction.text=顯示日誌
action.ComposerStatusAction.description=檢查任何相依項中有無本地更改
action.ComposerStatusAction.text=檢查相依項中的更改
action.ComposerUpdateAction.description=從 Composer.json 安裝最新適當版本的軟體套件
action.ComposerUpdateAction.text=更新
action.ComposerValidateAction.description=檢查 composer.json 是否有效
action.ComposerValidateAction.text=驗證…
action.DBGPProxy.Configuration.description=代理組態
action.DBGPProxy.Configuration.text=組態…
action.DBGPProxy.Init.description=代理初始化
action.DBGPProxy.Init.text=註冊 IDE
action.DBGPProxy.Stop.description=代理停止
action.DBGPProxy.Stop.text=取消 IDE 註冊
action.DisableXdebugDfaAssist.description=永久關閉數據流輔助偵錯
action.DisableXdebugDfaAssist.text=永久關閉數據流助手
action.IgnorePharAction.text=在專案中包含或排除 phar
action.MessDetectorAddToIgnored.description=新增到 PHP Mess Detector 忽略列表
action.MessDetectorAddToIgnored.text=新增到 PHPMD 忽略列表
action.NewComposerJsonFile.description=建立 composer.json 檔案
action.NewComposerJsonFile.text=composer.json 檔案
action.PhpCSAddToIgnored.description=新增到 PHP_CodeSniffer 忽略列表
action.PhpCSAddToIgnored.text=新增到 PHPCS 忽略列表
action.PhpCSFixerAddToIgnored.description=新增到 PHP CS Fixer 忽略列表
action.PhpCSFixerAddToIgnored.text=新增到 PHP CS Fixer 忽略列表
action.PhpDebugBreakAtFirstLine.text=在 PHP 腳本中的第一行中斷
action.PhpDebugHideEmptySuperGlobals.text=顯示空的超全域變數
action.PhpDebuggerCopyType.text=複製類型
action.PhpDetectPsroRoots.description=將檢測原始碼命名空間根
action.PhpDetectPsroRoots.text=檢測 PSR-0 命名空間根
action.PhpExtractClassAction.description=將元素提取到單獨的類別
action.PhpExtractClassAction.text=提取類別…
action.PhpGenerateConstructor.description=建立建構函式。
action.PhpGenerateConstructor.text=建構函式…
action.PhpGenerateGetters.description=為 private 類別欄位建立 getter。
action.PhpGenerateGetters.text=getter…
action.PhpGenerateGettersAndSetters.description=為 private 類別欄位建立 getter 和 setter。
action.PhpGenerateGettersAndSetters.text=getter 和 setter…
action.PhpGeneratePhpDocBlocks.description=為函式、類別和欄位新增 PHPDoc 塊。
action.PhpGeneratePhpDocBlocks.text=PHPDoc 塊…
action.PhpGeneratePropertyHooks.description=為非 abstract 類別欄位建立屬性掛鈎。
action.PhpGeneratePropertyHooks.text=屬性掛鈎…
action.PhpGenerateSetters.description=為 private 類別欄位建立 setter。
action.PhpGenerateSetters.text=setter…
action.PhpListenDebugAction.description=偵聽偵錯連線
action.PhpListenDebugAction.text=偵聽偵錯連線
action.PhpMakeStaticAction.description=將類別方法設為 static
action.PhpMakeStaticAction.text=設為 static
action.PhpNewClass.description=建立新的 PHP 類別
action.PhpNewClass.text=PHP 類別
action.PhpNewFile.description=建立新的 PHP 檔案
action.PhpNewFile.text=PHP 檔案
action.PhpNewTest.description=建立新的 PHP 測試
action.PhpNewTest.text=PHP 測試
action.PhpResetTestFrameworkSyncAction.text=重設與 Composer 同步的測試框架組態
action.PhpSimpleNewFile.description=建立新的 PHP 檔案
action.PhpSimpleNewFile.text=PHP 檔案
action.PhpStanAddToIgnored.description=新增到 PHPStan 忽略列表
action.PhpStanAddToIgnored.text=新增到 PHPStan 忽略列表
action.PhpStormMigrationGuide.text=PhpStorm 遷移指南
action.PhpUnitGenerateSetUpMethod.description=建立 PHPUnit setUp 方法
action.PhpUnitGenerateSetUpMethod.text=SetUp 方法
action.PhpUnitGenerateTearDownMethod.description=建立 PHPUnit tearDown 方法
action.PhpUnitGenerateTearDownMethod.text=TearDown 方法
action.PhpUnitGenerateTestMethod.description=建立 PHPUnit 測試方法
action.PhpUnitGenerateTestMethod.text=測試方法
action.ProfilerJumpToSource.description=跳轉到源
action.ProfilerJumpToSource.text=跳轉到源
action.ProjectFromVersionControl.ProjectWidgetPopup.text=克隆儲存庫…
action.ProjectFromVersionControl.text=從版本控制新增專案…
action.XDebugger.CopyPath.text=複製路徑
action.XdebugAddMethodToSkipListAction.text=將方法新增到跳過列表
action.XdebugAnalyzeProfilerSnapshotAction.text=分析 Xdebug 分析器快照…
action.XdebugDetachFromSessionAction.text=從會話中分離
action.XdebugShowUserDefinedConstants.description=將其停用會停止獲取使用者定義的常數資訊並提高偵錯器性能
action.XdebugShowUserDefinedConstants.text=顯示使用者定義的常數
action.add.file.s.to.list.text=向列表中新增檔案
action.com.jetbrains.php.composer.ComposerInitSupportAction.description=初始化 Composer
action.com.jetbrains.php.composer.ComposerInitSupportAction.text=初始化 Composer…
action.com.jetbrains.php.internal.PhpCreateYoutrackIssueFromFileAction.text=在 WI (PhpStorm) 專案中根據檔案內容建立 YouTrack 問題
action.com.jetbrains.php.internal.PhpCreateYoutrackIssueFromSelectionAction.text=在 WI (PhpStorm) 專案中根據所選內容建立 YouTrack 問題
action.com.jetbrains.php.internal.PhpShowFQNInternalAction.text=顯示 PHP FQN
action.com.jetbrains.php.internal.PhpViewControlFlowAction.text=當前檔案的 PHP 控制流
action.configure.php.runtime.text=組態 PHP 執行時…
action.configure.project.directories.text=組態專案目錄
action.copy.3v4l.link.text=將 3v4l 鏈接複製到剪貼簿
action.copy.port.to.clipboard.text=將連接埠值複製到剪貼簿
action.copy.to.clipboard.text=複製到剪貼簿
action.detect.composer.json.not.found=在路徑 {0} 下找不到 composer.json
action.detect.composer.json.not.found.title=找不到 composer.json
action.detect.composer.json.open=在編輯器中開啟
action.detect.settings.sync.turned.on=PHP 語言級別已與 composer.json 同步
action.detect.settings.sync.turned.on.title=已與 composer.json 同步
action.detect.user.settings.state.overwritten=如果開啟同步，IDE 設定(PHP 語言級別，PSR-0/PSR-4 根)可能會被覆蓋
action.detect.user.settings.state.overwritten.short=設定可能會被覆蓋\\: PSR-0/PSR-4 根和 PHP 語言級別。
action.detect.user.settings.state.supported=支援 PSR-0/PSR-4 根和 PHP 語言級別的同步
action.enable.plugin.text=啟用 ''{0}'' 延伸模組
action.migrate.text=是
action.open.3v4l.link.in.browser.text=在瀏覽器中開啟 3v4l 鏈接
action.quality.tools.provider=品質工具
action.quality.tools.provider.description=檔案被排除在外部品質工具分析和格式化程序外
action.retry.text=重試
action.revert.back.to.text=還原為 {0}
action.run.composer.install.text=執行 'composer install'
action.run.on.3v4l.org.promotion.tooltip=您現在可以在 3v4l.org 上執行不同 PHP 版本的臨時檔案
action.run.on.3v4l.org.text=在 3v4l.org 上執行
action.show.in.log.text=在日誌中顯示
action.submits.code.to.3v4l.org.show.result.in.preview.editor.description=將程式碼提交到 3v4l.org，並在預覽編輯器中顯示結果
action.synonym.listening=偵聽
action.synonym.start.listening=開始偵聽 PHP Xdebug 連線
action.synonym.stop.listening=停止偵聽 PHP Xdebug 連線
action.use.possibly.outdated.defaults.text=使用預設版本(可能已過時)
actions.detect.common.setting.from.composer.disable=不同步
actions.detect.common.setting.from.composer.enable=啟用同步
actions.detect.common.setting.from.composer.show.settings=顯示設定
actions.detect.common.setting.from.composer.suggest.title=將設定與 Composer 同步?
actions.detect.common.settings.composer.sync.state.title=與 composer.json 的同步{0}
actions.detect.common.settings.updated.from.composer.title={0} 設定已更新
actions.detect.language.level.loaded.from.composer.idea.title=語言級別
actions.detect.language.level.loaded.from.composer.title=PHP 語言級別
actions.detect.namespace.roots.finished=已完成 PSR-0 命名空間根檢測。
actions.detect.namespace.roots.from.composer.idea.title=來源根
actions.detect.namespace.roots.from.composer.title=PSR-0/PSR-4 根
actions.detect.namespace.roots.idea.view.configuration=您可以在 '專案結構 | 模組' 中修改設定。
actions.detect.namespace.roots.manual.configuration=手動組態
actions.detect.namespace.roots.no.new.roots.detected=未檢測到新的 PSR-0 命名空間根。
actions.detect.namespace.roots.notification.id=PHP PSR-0 命名空間根檢測已完成
actions.detect.namespace.roots.notification.title=檢測 PSR-0 命名空間根
actions.detect.namespace.roots.progress.title=正在檢測 PSR-0 命名空間根…
actions.detect.namespace.roots.view.configuration=檢視組態
actions.mark.directory.as.psr.0.root=<i>{0}</i>
actions.mark.directory.as.psr.0.root.mark.psr=標記為 {0} 根
actions.mark.directory.as.psr.0.root.title=是否要將目錄標記為 {0} 根?
actions.mark.directory.as.psr.0.root.with.prefix=<i>{0}</i>為前綴“{1}”?
actions.new.php.base.arrows.extension.tooltip=在編輯器中按向上或向下箭頭可更改檔案副檔名
actions.new.php.base.arrows.template.tooltip=在編輯器中按向上或向下箭頭可更改模板
actions.new.php.base.dialog.label.extension=檔案副檔名\\:
actions.new.php.base.dialog.label.file.name=檔名\\:
actions.new.php.class.dialog.border.title.class=類別
actions.new.php.class.dialog.label.class.name=名稱\\:
actions.new.php.class.dialog.label.directory=目錄\\:
actions.new.php.class.dialog.label.namespace=命名空間\\:
actions.new.php.class.dialog.label.superclasses.container=父類別
actions.new.php.class.dialog.label.superclasses.super.fqn=擴展\\:
actions.new.php.class.dialog.label.superinterfaces.add.interface=新增接口…
actions.new.php.class.dialog.label.superinterfaces.to.extend.empty=選擇要擴展的接口
actions.new.php.class.dialog.label.superinterfaces.to.implement=實作\\:
actions.new.php.class.dialog.label.superinterfaces.to.implement.empty=選擇要實作的接口
actions.new.php.class.dialog.label.template=模板\\:
actions.new.php.class.dialog.title=建立新的 PHP 類別
actions.new.php.file.dialog.title=建立新的 PHP 檔案
actions.new.phpunit.class.action.description=建立新的 PHPUnit 測試
actions.new.phpunit.class.action.name=PHPUnit 測試
actions.new.test.class.action.description=建立新的 PHP 測試
actions.new.test.class.action.name=新增 PHP 測試
actions.new.test.class.dialog.arrows.libraries.hint=在編輯器中按向上或向下箭頭可更改測試庫
actions.new.test.class.dialog.border.title.class.to.test=要測試的類別(可選)
actions.new.test.class.dialog.border.title.target.class.file.path=檔案路徑\\:
actions.new.test.class.dialog.border.title.test.class=測試類別
actions.new.test.class.dialog.label.directory=目錄\\:
actions.new.test.class.dialog.label.fqn=完全限定名稱\\:
actions.new.test.class.dialog.label.name=名稱\\:
actions.new.test.class.dialog.label.namespace=命名空間\\:
actions.new.test.class.dialog.select.methods.show.inherited.methods=顯示繼承的方法(&I)
actions.new.test.class.dialog.title=建立新的 PHP 測試
actions.new.test.class.dialog.title.named=為 {0} 建立新的 PHP 測試
add=新增
add.catch.clause.quick.fix=新增 'catch' 從句
add.clarifying.parentheses=新增澄清括號
add.class=新增類別…
add.class1=新增類別
add.constant.0.to.class.1.and.opens.containing.file.in.editor=將常數 ''{0}'' 新增到類別 ''{1}'' 並在編輯器中開啟包含的檔案
add.constant.declaration.quick.fix.text=新增常數
add.custom.format.function=新增自訂格式函式…
add.custom.format.function1=新增自訂格式函式
add.enum.declaration.quick.fix.text=新增枚舉 case
add.fluent.setter=新增 fluent setter
add.global.variable.quick.fix.family.name=新增全域變數
add.global.variable.quick.fix.text=新增 ''global \${0}''
add.phpunit.test.pattern=新增 PHPUnit 測試模式
add.port.in.ide.settings=將連接埠 {0} 新增到設定
add.property=新增 @property
add.property.hooks=新增屬性掛鈎
add.remote.interpreter=新增遠端解釋器
add.return.type=新增返回值類型
add.rule=新增規則
add.serialize.magic.method=新增{0}方法
add.serialize.magic.methods=新增{0}方法
add.setter=新增 setter
add.slash.to.the.start=在開頭新增 '/'
add.test.class.method=新增測試類別/方法…
add.throw.before.exception=在表達式前面新增 'throw'
add.to.composer.json.quick.fix=向 composer.json 中新增 ''{0}''
add.to.excluded.files.action=將 \`{0}\` 新增到忽略的檔案
advanced.setting.php.code.vision.hierarchy.limit=Code Vision\\: 要處理的最大繼承實體數
advanced.setting.php.code.vision.usages.limit=Code Vision\\: 要搜尋的最大用法數
advanced.setting.php.max.chain.resolve.depth=解析成員參照的最大深度
advanced.setting.php.sql.completion.recursive.jumps.limit=補全\\: 尋找 SQL 查詢時要解析的最大元素數量
advanced.setting.php.type.completion.complexity.limit=類型補全復雜度限制
advanced.setting.php.type.inference.complexity.limit=參數類型推斷復雜度限制
advanced.setting.php.use.internal.formatter=在外部格式化程序之前執行內建格式化程序
alias=別名
align.composer.log.console=對齊 Composer 日誌主控台
all.0=所有({0})
all.cases.of.backed.enum.must.have.a.value=備用枚舉的所有 case 必須包含值
all.exceptions.considered.checked=所有異常均被視為已檢查
all.scripts=<All scripts>
all.values=所有變數
all.versions=所有版本
always.show.pass.by.reference=始終顯示參照傳遞
an.alias.was.defined.for.method.0.which.exists.in.1=已為 {1} 中的方法 {0}() 定義別名
an.expanded.full.numeric.representation.if.requried.or.a.full.numeral.representation.like.y=擴展的完整數字表示(如果需要)，或完整數字表示(2022)
an.expanded.full.numeric.representation.of.a.year.at.least.4.digits.with.or=年份的擴展完整數字表示，至少 4 位數，帶 - 或 + (+2022)
an.object.s.clone.method.cannot.be.called.directly=無法直接呼叫物件的 '__clone()' 方法
analyzing.php.sdk=正在檢查 PHP 安裝…
and=和
annotation.expression.is.not.allowed.as.class.constant.value=表達式不允許為類別常量值
annotation.new.expression.abstract=無法實例化抽象類別 ''{0}''
annotation.new.expression.enum=無法實例化枚舉 ''{0}''
annotation.new.expression.interface=無法實例化接口 ''{0}''
annotation.new.expression.trait=無法實例化特徵 ''{0}''
annotation.variable.variable=可變變數
annotator.cannot.break.continue=無法中斷/繼續{0}級別
annotator.duplicate.default.match.condition=match 表達式只能包含一個 'default' 分支
annotator.duplicate.use.statement=無法使用 ''{0}''，因為該名稱已被使用
annotator.fix.remove=移除 ''{0}''
annotator.invalid.class.name=''{0}'' 是無效的類別名
annotator.jump.out.of.finally=不允許跳出 finally 塊
annotator.only.default.condition.allowed='default' arm 中僅允許單個 'default' 條件
annotator.reserved.class.name=無法使用 ''{0}'' 作為類別名，因為該名稱已被保留
annotator.special.class.name=無法將 {0} 用作 {1}，因為 ''{1}'' 是一個特殊的類別名
annotator.unhandled.match.argument=未處理的 'match' 實參
anonymous.0=匿名{0}
anonymous.class=匿名類別
anonymous.function=匿名函式
anonymous.function.expected=應為匿名函式
another.definition.with.same.name.exists.in.this.file=此檔案中存在另一個具有相同名稱的定義
argument.passed.must.be.of.the.type.0.1.given=傳遞的實參必須為 {0} 類型，給定的為 {1}
array.callback.must.have.exactly.two.elements=陣列回調必須正好有兩個元素
array.can.t.be.used.for.array.destructuring.assignment='array()' 不能用於陣列解構賦值
array.index=陣列索引
array.only.updated.but.never.queried=陣列僅被更新，但從未被查詢
arrays.are.not.supported.as.operands.for.0=不支持將陣列用作 ''{0}'' 的動作數
attribute.can.be.added.to.overridden.method=可以將特性新增到覆寫方法
attribute.can.be.added.to.overridden.parameter=可以將特性新增到覆寫參數
attribute.must.be.first.child.of.parent.element=特性必須是父元素的第一個子項
auto.import.from.global.space=處理來自全域空間的符號
auto.import.from.global.space.class=類別\\:
auto.import.from.global.space.constant=常數\\:
auto.import.from.global.space.function=函式\\:
auto.import.from.global.space.prefer.fallback=回退優先
auto.import.from.global.space.prefer.fqn=FQN 優先
auto.import.from.global.space.prefer.import=匯入優先
auto.import.in.file.scope=在檔案作用域內啟用自動匯入
auto.import.in.namespace.scope=在命名空間作用域內啟用自動匯入
background.task.detect.namespace.roots.progress.title=正在檢測命名空間根…
bit.shift.by.negative.number=按負數進行移位
border.title.additional.dependencies=其他相依項
border.title.constant.syntax=常數語法
border.title.include.analysis=Include 分析
border.title.initialize.in=初始化位置
border.title.introduce.field=引入屬性
border.title.introduce.variable=引入變數
border.title.options=選項
border.title.php=PHP
border.title.require.dependencies='require' 相依項
border.title.require.dev.dependencies='require-dev' 相依項
border.title.visibility=可見性
build.control.flow=建置控制流(&B)
build.control.flow.with.exit.points=使用出口點建置控制流(&E)
button.sync.extensions.with.interpreter=將擴展與解釋器同步
button.turn.off.listening=停用偵錯偵聽
button.turn.off.listening.descr=為所選專案停用偵錯偵聽
cache.creating=正在建立 psalm 快取…
call.to.0.1.construct.from.invalid.context=從無效上下文呼叫 ''{0} {1}\\:\\:__construct()''
call.to.method.clone.from.invalid.context=從無效上下文呼叫方法 '__clone'
call.tree=呼叫樹
callees=被呼叫方
callers=呼叫方
can.not.correctly.run.the.tool.with.parameters=無法使用參數正確執行該工具\\:
can.not.delete.temporary.file.because.it.was.not.created=無法刪除臨時檔案，因為未建立該檔案
can.not.execute.tests=無法執行測試
can.not.execute.transfer.task.project.is.already.disposed=無法執行傳輸任務\\: 專案已被處置
can.not.find.0.helper.script=找不到 ''{0}'' 幫助程序腳本
can.not.find.specified.interpreter=找不到指定的解釋器
can.not.parse.phpunit.version.output.0=無法解析 PHPUnit 版本輸出\\: {0}
can.not.run.command.composer.execution.plugin.was.unloaded=無法執行指令\\: Composer 執行延伸模組已移除
can.only.be.used.as.standalone.type={0} 僅可用作獨立類型
can.t.use.nullsafe.operator.in.write.context=在寫入上下文中不能使用 nullsafe 運算符
cancel=取消
cannot.apply.0.to.interface=無法將 {0} 應用於接口
cannot.apply.0.to.readonly.class=無法將 {0} 應用於 ''readonly'' 類別
cannot.apply.0.to.trait=無法將 {0} 應用於特徵
cannot.call.abstract.method.0.1=無法呼叫 abstract 方法 ''{0}\\:\\:{1}''
cannot.combine.nullsafe.operator.with.closure.creation=無法將 nullsafe 運算符與 'Closure' 建立組合
cannot.create.closure.for.new.expression=無法為 'new' 表達式建立 'Closure'
cannot.declare.dynamic.properties.in.readonly.class=不能在 'readonly' 類別中宣告動態屬性
cannot.declare.promoted.property.in.an.abstract.constructor=無法在 abstract 建構函式中宣告提升的屬性
cannot.declare.promoted.property.outside.a.constructor=無法在建構函式外部宣告提升的屬性
cannot.declare.self.referencing.constant=無法宣告自參照常數
cannot.declare.static.properties.in.readonly.class=不能在 'readonly' 類別中宣告 'static' 屬性
cannot.declare.variadic.promoted.property=無法宣告可變提升屬性
cannot.implement.interface.0=無法實作接口 ''{0}''
cannot.implement.interface.0.directly=無法直接實作接口 ''{0}''
cannot.inherit.previously.inherited.or.override.constant.0.from.interface.1=無法從接口 ''{1}'' 繼承先前繼承的常數 ''{0}'' 或將其覆寫
cannot.make.interface.method.non.static=無法將接口方法設為非 static
cannot.make.interface.method.static=無法將接口方法設為 static
cannot.mix.amp.and.pipe.in.type.declaration=類型宣告中不能混用 '\\\\&' 和 '|'
cannot.mix.and.list=不能混合 [] 與 list()
cannot.mix.keyed.and.unkeyed.array.entries.in.assignments=在賦值中不能混合鍵控和非鍵控陣列條目
cannot.override.final.constant=無法從 ''{1}'' 覆寫 final 常數 ''{0}''
cannot.redeclare.constant.0=無法重新宣告常數 ''{0}''
cannot.redeclare.methods.from.enum.implicit.interfaces=無法從枚舉隱式接口重新宣告方法
cannot.redeclare.non.static.0.1.as.static.2.3=無法將非 static ''{0}\\:\\:\${1}'' 重新宣告為 static ''{2}\\:\\:\${3}''
cannot.redeclare.static.0.1.as.non.static.2.3=無法將 static ''{0}\\:\\:\${1}'' 重新宣告為非 static ''{2}\\:\\:\${3}''
cannot.register.handler=無法註冊處理程序
cannot.use.0.as.lexical.variable=無法將 ''\${0}'' 用作詞法變數
cannot.use.class.on.primitive.type=只允許在物件上使用 '\\:\\:class'
cannot.use.empty.array.elements.in.arrays=無法在陣列中使用空陣列元素
cannot.use.empty.array.entries.in.keyed.array.assignment=在鍵控陣列賦值中不能使用空陣列條目
cannot.use.empty.list=無法使用空列表
cannot.use.for.reading=無法使用 '[]' 進行讀取
cannot.use.match.as.identifier=無法將 'match' 用作關鍵字，自 PHP 8.0 起作為預留關鍵字
cannot.use.positional.argument.after.argument.unpacking=無法在實參解包後使用位置實參
cannot.use.positional.argument.after.argument.unpacking.named.argument.81=實參解包後的位置實參從 PHP 8.1 起才可用
cannot.use.positional.argument.after.named.argument=無法在命名實參後面使用位置實參
cannot.use.readonly.as.identifier=無法將 'readonly' 用作關鍵字。自 PHP 8.1 起作為預留關鍵字
cannot.use.static.as.function.return.type.declaration=不允許 'static' 作為類別作用域外部的返回值類型宣告
cannot.use.this.as.parameter=不能將 $this 用作參數
cannot.use.traits.inside.of.interfaces=無法在接口內部使用特徵
cannot.use.unpacking.in.attribute.argument.list=無法在特性實參列表中使用解包
cannot.use.yield.from.inside.a.by.reference.generator=不能在參照傳遞產生器中使用 'yield from'
cant.save.interpreter=無法儲存 ''{0}''\\: {1}
cant.use.temporary.expression.in.write.context=在寫上下文中不能使用臨時表達式
case.of.non.backed.enum.must.not.have.a.value=非備用枚舉的 case 不得包含值
caused.by.0=原因是\\:“{0}”
change.member.access=更改成員存取
change.method.modifiers.to.0=將方法修飾符更改為 ''{0}''
change.php.language.level=更改 PHP 語言級別
change.signature.arg.type.incompatible=應為 ''{0}'' 類型的參數，提供的是 ''{1}''
change.signature.arg.type.miss.argument=應為 ''{0}'' 類型的參數
change.signature.column.name.parameter=參數\\:
change.signature.column.type.parameter=類型\\:
change.signature.error.wrong.caret.position=文字游標應置於要重構的函式的名稱處。
change.signature.find.usages.of.base.class=類別 {1} 的方法 {0}\\n重寫了類別 {2} 的方法。\\n要{3}基方法嗎?
change.signature.find.usages.of.base.interface=類別 {1} 的方法 {0}\\n實作了接口 {2} 的方法。\\n要{3}基方法嗎?
change.signature.initialize.new.parameters=建立並初始化類別屬性(&I)
change.signature.parameter.may.have.side.effect=用作參數“{1}”的表達式“{0}”可能會有副作用
change.signature.tooltip.default.value=要在此方法的所有現有呼叫中使用的值
change.signature.tooltip.parameter=$name \\= 'init' 或 &...$array \\= 'init'
change.signature.usage.view.declarations.header=要重構的函式
change.signature.visibility.not.accessible=可見性為 {1} 的{0}將無法從{2}存取
checkbox.add.override=新增 \\#[Override]
checkbox.add.packages.as.libraries=作為庫新增軟體套件(&A)
checkbox.add.phpdoc=新增 PHPDoc(&D)\\:
checkbox.always.enable.blade.template.highlighting=始終啟用 Blade 模板醒目提示顯示
checkbox.always.enable.php.code.background.highlighting=始終啟用 PHP 程式碼背景醒目提示顯示
checkbox.anonymous.classes=匿名類別
checkbox.check.clone.method=檢查 '__clone' 方法
checkbox.check.destruct.method=檢查 '__destruct' 方法
checkbox.check.sleep.method=檢查 '__sleep' 方法
checkbox.check.wakeup.method=檢查 '__wakeup' 方法
checkbox.ignore.empty.functions=忽略空函式
checkbox.ignore.test.methods=忽略測試方法
checkbox.lambdas=Lambda
checkbox.move.to.another.class=移至另一個類別(&M)
checkbox.rename.only.nearest.scope=僅重新命名最近作用域中的變數
checkbox.show.class.namespace.separators=顯示 PHP 類別和命名空間分隔符
checkbox.static=static
checkbox.use.as.a.default.template=用作預設模板
checkbox.use.composer=新增 'composer.json'
checkbox.use.fully.qualified.class.names=使用完全限定類別名
checking.for.changes.in.code.of.dependencies=正在檢查相依項程式碼中的更改
choose.a.valid.0.launcher=選擇有效的 {0} 啟動器
choose.an.alias.to.use=選擇要使用的別名
choose.class=選擇類別
choose.elements.to.generate.phpdoc.for=選擇要為其生成 PHPDoc 的元素
choose.executable.class.to.run.0=選擇用於執行 {0} 的可執行類別
choose.methods.to.implement=選擇要實作的方法
choose.methods.to.implement1=選擇要實作的方法
choose.methods.to.override=選擇要覆寫的方法
choose.php.home=選擇 PHP 可執行檔案
choose.properties=選擇屬性
choose.super.class.or.interface=選擇超類別或接口
choose.super.method=選擇 super 方法
choose.test.method.to.run.dataset.0=選擇測試方法以執行資料集 {0}
class=類別
class.cannot.extend.from.trait=類別無法從特徵擴展
class.cannot.implement.previously.implemented.interface=類別無法實作先前實作的接口
class.constant=類別常數
class.constant.reference.fetch.with.non.string.type=只有 'string' 類型的元素才能用於類別常數尋找
class.constant1=類別常數
class.constructor=類別建構函式
class.declarations.may.not.be.nested=類別宣告不能被嵌套
class.implements.solely.traversable=類別 ''{0}'' 必須將接口 Traversable 作為 Iterator 或 IteratorAggregate 的一部分來實作
class.implements.the.serializable.interface.which.is.deprecated=在不使用 '__serialize()'/'__unserialize()' 方法的情況下實作 'Serializable' 接口已棄用
class.name=類別名
class.ref.is.deprecated=類別 '\\#ref' 已棄用
class.reference=類別參照
class.should.not.implement.itself=類別不應自行實作
class1=類別
class2=類別
classes.can.not.have.backed.type=類別不能有備用類型
classes.named.never.is.forbidden.in.php.8.1=PHP 8.1 中禁止名為 'never' 的類別
classes.named.object.are.forbidden.in.php.7.2=PHP 7.2 中禁止名為 'object' 的類別
classes.named.void.and.iterable.are.forbidden.in.php.7.1=PHP 7.1 中禁止名為 'void' 和 'iterable' 的類別
classes.without.member=層次結構中不帶 ''{0}'' 的類別
cleaning.up=正在清理…
clear.log=清除日誌
clearing.cache=正在清除快取
cli.interpreters.name=CLI 解釋器
close=關閉(&C)
closest.scope=最近作用域中的變數
code.fully.qualified.classname.methodname.key.value.code.example.precise.match={0} 是一個精確排除的範例。
code.global.code.matches.function.with.two.parameters={0} 符合帶有兩個參數的函式。
code.info.code.matches.all.single.parameter.methods.where.the.parameter.name.ends.with.em.info.em={0} 符合參數名以 {1} 結尾的所有單參數方法。
code.key.value.code.matches.all.methods.with.parameters.em.key.em.and.em.value.em={0} 符合所有具有參數 {1} 和 {2} 的方法。
code.size.rules=程式碼大小規則
code.vision.implementations.hint={0, choice, 1\\#1 個實作|2\\#{0,number}'{1,choice, |1\\#+}' 實作}
code.vision.inheritors.hint={0, choice, 1\\#1 個繼承者|2\\#{0,number}'{1,choice, |1\\#+}' 繼承者}
code.vision.overrides.hint={0, choice, 1\\#1 個覆寫|2\\#{0,number}'{1,choice, |1\\#+}' 覆寫}
code.vision.used.in.hint=由 {0}{1, choice, |1\\#+} 使用
column.name.annotation.name=註解名稱
column.name.file.directory=檔案/目錄
column.name.parameter=參數
command.name.create.php.file=建立 PHP 檔案 {0}
command.name.disable.synchronisation.with.composer=停用與 composer.json 同步
command.name.make.method.static=將方法設為 static
command.name.new.file=新增檔案
completion.press.again.to.see.all.classes=再次按 {0} 以檢視所有類別
completion.press.again.to.see.global.variants=再次按 {0} 以檢視全域變體
completion.press.again.to.see.more.variants=再次按 {0} 以檢視更多變體
composer=composer
composer.autoloader.generation.settings.name=自動載入器生成設定
composer.border.title.execution=執行
composer.border.title.package=軟體套件
composer.change.setting.action.name=更改設定
composer.checkbox.allow.unbound.version.constraints=允許未綁定的版本約束
composer.checkbox.autoload.classes.from.the.classmap.only=僅從類別映射自動載入類別
composer.checkbox.check.if.composer.lock.is.up.to.date=檢查 composer.lock 是否為最新
composer.checkbox.check.if.the.package.is.packagist.ready=檢查軟體套件是否為 Packagist 就緒
composer.checkbox.disable.autoload.dev.dependencies=停用 autoload-dev 相依項
composer.checkbox.download.composer.phar.from.getcomposer.org=從 getcomposer.org 下載 composer-stable.phar
composer.checkbox.optimize.autoloader.convert.psr.0.4.rules.to.a.classmap=最佳化自動載入器(將 PSR-0/4 規則轉換為類別映射)
composer.checkbox.skip.scripts.execution=跳過腳本執行
composer.checkbox.synchronize.ide.settings.with.composer.json=將 IDE 設定與 composer.json 同步(&S)
composer.checkbox.use.apcu.to.cache.found.not.found.classes=使用 APCu 快取找到/未找到的類別
composer.checkbox.validate.package.dependencies=驗證軟體套件相依項
composer.checking.for.changes.in.code.of.dependencies.task.title=檢查相依項程式碼中的更改
composer.clearing.cache.action.name=清除快取
composer.diagnose.task.title=診斷
composer.executable='composer' 可執行檔案
composer.generate.list.popup.title=生成
composer.generating.autoloader.task.title=生成自動載入器
composer.json.custom.invalid.json=json 無效
composer.json.custom.packages.done=自訂儲存庫已載入
composer.json.custom.packages.empty=找不到軟體套件。請檢查您的儲存庫
composer.json.exec.not.configured=自訂儲存庫無法載入。未組態 Composer 可執行檔案路徑
composer.json.open.tool.settings.intention=開啟工具設定
composer.json.packages.loading.error=軟體套件未重新載入
composer.json.packages.refresh=軟體套件正在重新整理
composer.json.packagist.packages.done=僅載入了 packagist 儲存庫
composer.json.packagist.packages.reused=正在重用軟體套件列表而不更新
composer.json.path.not.configured=自訂儲存庫無法載入。未組態 composer.json 路徑
composer.label.can.be.time.consuming=可能較為耗時
composer.label.executable='composer' 可執行檔案
composer.label.filter.packages=篩選軟體套件(&F)\\:
composer.label.label=標籤
composer.label.package=軟體套件\\:
composer.label.path.to.composer.json=composer.json 路徑(&C)\\:
composer.label.phar=composer.phar
composer.label.the.settings.php.language.level.directories.may.be.updated=設定(Php 語言級別，目錄)可能已更新
composer.label.version.to.install=要安裝的版本\\:
composer.listing.licenses.task.title=列出授權
composer.packages.versions=Composer 軟體套件版本
composer.remove.action.name=移除(&R)
composer.require.package.task.title=需要 Composer 軟體套件
composer.revert.action.name=還原
composer.simulating.update.task.title=模擬更新
composer.update.composer.packages.task.title=更新 Composer 軟體套件
composer.update.composer.task.title=更新 Composer
composer.validate.dialog.action.button.title=驗證
composer.validating.task.title=驗證
composer.validation.settings.name=驗證設定
composer.version.update.hint=已安裝軟體套件的當前版本和可用更新。
composite.test.patterns=複合測試模式
config.file.doesnt.exist=組態檔案不存在
configurable.PhpDebugConfigurable.display.name=偵錯
configurable.PhpProjectConfigurable.display.name=PHP
configurable.PhpServerConfigurable.display.name=伺服器
configurable.PhpServersConfigurable.display.name=伺服器
configurable.PhpSmartKeysConfigurable.display.name=PHP
configurable.PhpTemplatesCommonConfigurable.display.name=模板
configurable.PhpTestFrameworksConfigurable.display.name=測試框架
configurable.QualityToolCommonConfigurable.display.name=品質工具
configurable.name.php.servers=PHP 伺服器
configurable.quality.tool.laravel.pint=Laravel Pint
configurable.quality.tool.mess.detector=Mess Detector
configurable.quality.tool.php.code.sniffer=PHP_CodeSniffer
configurable.quality.tool.php.cs.fixer=PHP CS Fixer
configure=組態
configure.php.include.paths=組態 PHP Include 路徑(&O)…
configure.suppressed.annotations=組態禁止的註解
configured.is.incorrect=組態的 {0} 不正確
conflict.class.constant.with.same.name.already.exists=此類別中已經定義了具有相同名稱的常數
conflict.class.with.same.name.already.exists=已經定義了具有相同名稱的類別
conflict.constant.with.same.name.already.exists=已經定義了具有相同名稱的常數
conflict.field.with.same.name.already.exists=此類別中已經定義了具有相同名稱的屬性
conflict.function.with.same.name.already.exists=已經定義了具有相同名稱的函式
conflict.method.with.same.name.already.exists=此類別中已經定義了具有相同名稱的方法
conflict.parameter.with.same.name.already.exists=已經定義了具有相同名稱的參數
conflict.tag.name.contains.close.tag=文本包含“{0}”
conflict.template.parameter.with.same.name.already.exists=已存在同名的模板參數
conflict.use.with.same.name.already.exists=已經定義名稱相同的 'Use' 語句
conflict.variable.with.same.name.already.exists=已經定義了具有相同名稱的變數
connection.failed.message=連線失敗。請檢查您的網絡連線並重試。
connection.port.is.busy=連接埠 {0} 繁忙
constant=常數
constant.0=常數 {0}
constant.expression.contains.invalid.operations=常數表達式包含無效運算
constant.ref.is.deprecated=常數 '\\#ref' 已棄用
constant.ref.is.deprecated1=常數 '\\#ref' 已棄用
constant.ref.not.found.in=在 {0} 中未找到常數 ''\\#ref''
constant.with.same.name.already.exists.in.0={0} 中已經存在名稱相同的常數
constant1=常數
constants.defined.using.the.const.keyword.must.be.declared.at.the.top.level.scope=使用 'const' 關鍵字定義的常數必須在頂層作用域宣告
constants.may.only.evaluate.to.scalar.values.arrays.or.resources=常數的求值結果只能為標量值、陣列或資源
constructor.already.exists=建構函式已存在
constructor.field=建構函式欄位
constructors=建構函式
controversial.rules=有爭議的規則
convert.closure.to.arrow.function=將閉包轉換為箭頭函式
convert.concatenation.to.sprintf.call=將串聯轉換為 'sprintf()' 呼叫
convert.string.interpolation.to.concatenation=將字串內插轉換為串聯
convert.string.interpolation.to.sprintf.call=將字串內插轉換為 'sprintf()' 呼叫
convert.the.arrow.function.to.a.traditional.closure=將箭頭函式轉換為傳統閉包
copy=複製
copy.concatenated.string.to.clipboard=將串聯的字串複製到剪貼簿
copy.handler.is.dumb.during.indexing=在索引編制進行時複製類別將只是簡單地複製包含的檔案。您將必須手動更改命名空間和匯入。是否仍要繼續?
copy.switch.branch=複製 'switch' 分支
copy.to.namespace=目標命名空間\\:
couldnt.update.php.ini=''zend_extension\\=xdebug'' 未新增到 {0}。存取被拒絕。
coverage.is.not.supported.for.selected.run.profile=程式碼覆蓋率與所選執行組態檔案不相容
create.missing.target.method.fix=建立缺少的目標方法修復
create.new.class.quickfix=建立一個新類別
create.new.field.dialog.title=建立新字段
create.target.class.quick.fix=建立目標類別快速修復
creates.new.class.0.in.a.separate.file=在單獨的檔案中建立名為 ''{0}'' 的新類別
creates.new.class.method.0.in.a.separate.file=在單獨的檔案中使用方法 ''{1}'' 建立名為 ''{0}'' 的新類別
custom.format.functions.dialog.class.placeholder=留空以新增純函式
custom.format.functions.dialog.format.index.title=格式字串模板的索引
custom.format.functions.dialog.validation.class.not.found=找不到類別 {0}
custom.format.functions.dialog.validation.format.index=索引必須為非負數
custom.format.functions.dialog.validation.function.not.found=找不到函式 {0}
custom.format.functions.dialog.validation.method.not.found=在 {1} 中找不到方法 {0}
day.of.the.month.2.digits.with.leading.zeros=月中幾號，2 位數，帶前導零(01到 31)
day.of.the.month.without.leading.zeros=月中幾號，不帶前導零(1 到 31)
days.numeric=天，數字(1、3、31)
days.numeric.at.least.2.digits.with.leading.0=天，數字，至少 2 位數，帶前導 0 (01、03、31)
dbgp.invalid.packet=無效數據包
dbgp.proxy=Xdebug 代理
dbgp.proxy.cannot.connect.to.host=無法連線到主機 ''{0}''
dbgp.proxy.cannot.connect.to.xdebug.proxy=無法連線到 ''{0}\\:{1}'' 上的 Xdebug 代理
dbgp.proxy.host=代理主機
dbgp.proxy.ide.key=IDE 鍵
dbgp.proxy.ide.register.error=無法使用 IDE 鍵 ''{0}'' 註冊 IDE
dbgp.proxy.ide.register.success=IDE 已成功使用 IDE 鍵 ''{0}'' 註冊
dbgp.proxy.ide.unregister.success=IDE 已成功註銷
dbgp.proxy.port=代理連接埠
dbgp.proxy.sending.request.to.xdebug.proxy=正在將請求發送到 Xdebug 代理…
dead.code.commented.out=註釋掉
dead.code.deleted=已刪除
debug.accept.connection=接受
debug.action.copy.as.title=將變數複製為 ''{0}''
debug.action.copy.as.was.fail.can.not.get.full.name=無法將變數複製為 ''{0}''，無法對完整的變數名求值
debug.breakpoint.move.disabled=中斷點移動到解析的位置已被停用，從下一個偵錯會話開始將不會移動中斷點。您可以稍後在 <a href\\="open">PHP|偵錯</a>下將其啟用。
debug.breakpoint.resolved.disabled=中斷點解析已被停用，從下一個偵錯會話開始將不會解析中斷點。 您可以稍後在 <a href\\="open">PHP|偵錯</a>下將其啟用。
debug.breakpoint.resolved.notify.disabled=中斷點解析通知已被停用。您可以在 <a href\\="open">PHP|偵錯|進階設定</a>下將其啟用。
debug.breakpoint.was.moved=<br/>中斷點也已移至此行。
debug.breakpoint.was.resolved=此處的偵錯會話已暫停，因為 ''{0}'' 處的中斷點已被解析到此行。<br/>您可以<a href\\="disable">停用</a>中斷點解析或<a href\\="more">了解詳情</a>。<a href\\="dontshow">不再顯示</a>
debug.cannot.find.port=找不到可用連接埠
debug.cannot.map.local.file=檔案路徑未映射到伺服器上的任何檔案路徑。編輯路徑映射以解決此問題。
debug.cannot.start=無法啟動 ''{0}''
debug.cannot.start.listening.for.connections.from.0=無法開始偵聽來自 ''{0}'' 的連線
debug.check.firewall=請檢查您的防火牆設定
debug.checkbox.can.accept.external.connections=可以接受外部連線
debug.checkbox.ignore.z.ray.system.requests=忽略 Z-Ray 系統請求
debug.composite.value.presentation=[{0}]
debug.configure.servers=組態伺服器
debug.debug.port=偵錯連接埠\\:
debug.edit.ignored.paths.list=<a href\\="\\#a">編輯</a>跳過的路徑。
debug.edit.path.mappings=點擊以設定路徑映射
debug.error=錯誤
debug.error.cannot.evaluate.expression=無法對表達式求值
debug.error.cannot.evaluate.expression0=無法對表達式 ''{0}'' 求值
debug.error.cannot.evaluate.variables=無法對變數求值
debug.error.cannot.modify.value=無法修改值
debug.error.cannot.parse.server.name=要修復，請在遠端伺服器上建立環境變數 <i><b>PHP_IDE_CONFIG</b></i>。<br/><br/><i>Windows\\:</i> 設定 PHP_IDE_CONFIG\\="serverName\\=SomeName"<br/> <i>Linux / Mac OS X\\:</i> 匯出 PHP_IDE_CONFIG\\="serverName\\=SomeName"。
debug.error.cannot.parse.server.name.for.external.connection=無法為外部 {0} 連線解析伺服器名稱。
debug.error.cannot.parse.ssh.connection=無法從 $_SERVER[''SSH_CONNECTION''] 解析連接埠\\: ''{0}''
debug.error.server.name.is.empty=<i><b>$_SERVER["SERVER_NAME"]</i></b> 為空，這可能是 Web 伺服器組態錯誤所致。<br/><br/><i>Nginx\\:</i> 將 fastcgi 參數新增至 nginx 組態，<a href\\="http\\://wiki.nginx.org/PHPFcgiExample">更多</a><br/><i>Apache\\:</i> 為當前 VirtualHost 組態 ServerName，<a href\\="https\\://httpd.apache.org/docs/2.4/vhosts/name-based.html">更多</a>
debug.error.title.cannot.accept.external.0.connection=無法接受外部 {0} 連線
debug.error.unknown.debugger.id=未檢測到偵錯器擴展
debug.error.wrong.debugger.id=不支持 {0}
debug.expression.evaluation.fail=由於返回值未知，無法對表達式求值
debug.file.is.ignored=檔案 ''{0}'' 被跳過。
debug.function.was.added.to.skip.list=''{0}'' 已新增到跳過列表。
debug.ignore.connection=忽略
debug.incoming.connection.title.0=來自 {0} 的傳入連線
debug.label.file.path.in.project=專案中的檔案路徑\\:
debug.label.file.path.on.server=伺服器上的檔案路徑\\:
debug.label.max.simultaneous.connections=最大同時連線數\\:
debug.label.select.a.project.or.a.file.to.debug=選擇一個專案或檔案進行偵錯
debug.label.select.a.project.to.debug=選擇一個專案進行偵錯
debug.log.cant.register.breakpoint.no.remote=無法註冊中斷點。沒有本地路徑 ''{0}'' 的路徑映射
debug.log.cant.register.breakpoint.no.template.mapping=無法註冊中斷點。沒有到 PHP 行 ''{0}'' 的映射
debug.log.connection.was.terminated=偵錯連線在 ''{0}''\\:''{1}'' 上意外終止
debug.log.exception.break=異常中斷\\: {0} ({1})
debug.log.invalid.xdebug.message=由於 Xdebug 訊息無效，無法在中斷點處停止。\\n要解決此問題，請切換到穩定版本的 Xdebug 或使用 'xdebug.remote_log' 選項收集日誌並建立錯誤報告。 
debug.log.path.mapping.remote.extracted=遠端\\: ''{0}'' <-> 提取\\: ''{1}''
debug.log.path.mapping.remote.local=遠端\\: ''{0}'' <-> 本地\\: ''{1}''
debug.log.stack.frame=框架\\: {0}\\:{1}，{2}
debug.log.stop=停止於 (''{0}''\\:{1})
debug.mapping.resolve.dialog.stop.debugger=停止偵錯器
debug.not.installed=<未安裝>
debug.output=輸出
debug.path.on.server=伺服器上的絕對路徑
debug.php.breakpoint.failed.to.register=無法註冊中斷點，請嘗試將其停用並重新啟用。
debug.php.exception.breakpoint.dialog.title=新增異常中斷點
debug.php.exception.breakpoint.exception.name=異常名稱\\:
debug.php.exception.breakpoint.not.supported=載入的偵錯擴展不支持異常中斷點
debug.php.exception.breakpoint.title=PHP 異常中斷點
debug.php.exception.breakpoint.zend.not.supported=Zend Debugger 不支持異常中斷點
debug.php.external.connection.finished.break.at.first.line=<b><i>'在第一行中斷'</i></b> 選項已啟用
debug.php.external.connection.finished.break.at.first.line.title=PHP 偵錯組態
debug.php.external.connection.finished.warning=這可能是由於路徑映射組態錯誤或本地和遠端專案未同步。<br/><br/>要找出問題，請在 <b><i><a href\\="servers">PHP|伺服器</a></i></b>下檢查 ''{0}'' 伺服器的路徑映射組態，或啟用 <b><i><a href\\="break">''在 PHP 腳本中的第一行中斷''</a></i></b> 選項(位於<i>執行</i>選單下)。<br/><a href\\="ignore">不再顯示</a>
debug.php.external.connection.finished.warning.title=偵錯會話已完成且未暫停
debug.php.line.breakpoint.title=PHP 行中斷點
debug.php.method.breakpoint.dialog.title=新增方法中斷點
debug.php.method.breakpoint.title=PHP 方法中斷點
debug.php.method.breakpoint.zend.not.supported=Zend Debugger 不支持方法中斷點
debug.port.is.updated=設定中指定的連接埠 {0} 正在使用中。連接埠 {1} 可用，可由 Xdebug 使用。請使用 {2} 更新 php.ini
debug.port.is.updated.descr=設定中指定的連接埠 {0} 正在使用中。連接埠 {1} 可用，可由 Xdebug 使用。
debug.ports.is.updated=設定中指定的所有連接埠都在使用中。連接埠 {0} 可用，可由 Xdebug 使用。請使用 {1} 更新 php.ini
debug.process.cannot.find.file=在本地找不到檔案 ''{0}''。\\n要修復，請通過環境變數 PHP_IDE_CONFIG 設定伺服器名稱，然後重啟偵錯會話。
debug.process.cannot.find.file.in.project=在專案中找不到路徑為 ''{0}'' 的檔案
debug.process.cannot.find.file.link=更多資訊
debug.process.cannot.find.local.file=在伺服器 {0} 上找不到檔案的本地副本\\n本地路徑為 {1}
debug.process.cannot.find.path.mapping=遠端檔案路徑 ''{0}'' 未映射到專案中的任何檔案路徑
debug.process.cannot.find.remote.copy.local.file=專案 ''{0}'' 中的檔案路徑未映射到伺服器上的任何檔案路徑
debug.process.cannot.find.server.name=找不到源位置。名稱為 ''{0}'' 的伺服器不存在。
debug.process.cant.compute.source.position=無法計算源位置。腳本 ''{0}'' 未與任何文本檔案類型關聯。
debug.process.console.error.format={0}\\: {1}，{2} 中的第 {3} 行\\n
debug.process.script.outside.project=腳本 ''{0}'' 在專案外部。
debug.process.smart.step.into.function.evaluation.error=無法對目標函式求值。將執行“單步跳入”。
debug.process.smart.step.into.function.was.not.executed=尚未呼叫所選函式。
debug.process.smart.step.into.popup=步入函式
debug.process.status.connected=已連線
debug.process.status.disconnected=已斷開連線
debug.process.status.wait=正在等待與{0} ''{1}'' 的傳入連線
debug.resolve.mapping.problem=解決路徑映射問題
debug.rest.client.error.cannot.evaluate.server.name=無法評估 '$_SERVER['SERVER_NAME']'。請確保為您的 Web 伺服器組態了正確的伺服器名稱。<br>點擊此<a href\\="help">鏈接</a>獲取更多資訊。
debug.rest.client.error.cannot.evaluate.server.name.title=無法通過伺服器名稱找到對應的“PHP|伺服器”
debug.server.can.not.detect.path.mappings.from.deployment=無法評估路徑映射\\: 未選擇目標部署伺服器
debug.server.detect.path.mappings.from.deployment=正在檢測現有路徑映射…
debug.server.detect.path.mappings.from.deployment.progress=正在為 ''{0}'' 專案分析路徑映射
debug.server.import.configuration.deployment=部署(&D)\\:
debug.server.import.configuration.dialog.title=從部署組態匯入
debug.server.import.configuration.local=本地(&L)
debug.server.import.configuration.local.file.path=本地檔案路徑\\:
debug.server.import.configuration.mounted=已掛載(&M)
debug.server.import.configuration.path.to.remote.root=部署根的絕對路徑(&R)\\:
debug.server.import.configuration.path.to.remote.root.mounted=本地\\: ''{0}'' -> 遠端\\: ''{1}''
debug.server.import.configuration.path.to.remote.root.mounted.label=已掛載目錄的遠端路徑(&R)\\:
debug.server.import.configuration.path.to.remote.root.mounted.tooltip=遠端檔案的絕對路徑\\:<br>"已掛載目錄的遠端路徑" . "伺服器上的相對部署路徑" (來自部署路徑映射)
debug.server.import.configuration.path.to.remote.root.sftp=絕對遠端根\\: ''{0}''
debug.server.import.configuration.path.to.remote.root.sftp.tooltip=遠端檔案的絕對路徑\\:<br>"遠端根的絕對路徑" . "根路徑" (來自部署設定) . "伺服器上的相對部署路徑" (來自部署路徑映射)
debug.server.import.configuration.preview.border.title=預覽
debug.server.import.configuration.project=專案(&P)\\:
debug.server.import.from.deployment.deployment.configurations.message=找到具有相關路徑映射的部署組態。
debug.server.import.from.deployment.deployment.root.label=部署根(&R)\\:
debug.server.import.from.deployment.no.deployment.configurations.message=找不到合適的部署組態
debug.server.import.from.deployment.no.deployment.configurations.tooltip=組態部署根(如果不為空)
debug.server.import.from.deployment.radio=從部署匯入映射(&I)
debug.server.manually.select.file.message=選擇一個專案或檔案進行偵錯
debug.server.manually.select.file.or.project=手動選擇本地檔案或專案(&M)
debug.server.select.file.mapping=組態本地檔案路徑
debug.settings.auto.detect.ide.host=自動檢測 IDE IP\\:
debug.settings.broadcasting.port=設定廣播連接埠\\:
debug.start.listen.debug.connections=開始偵聽 PHP 偵錯連線
debug.stop.listen.debug.connections=停止偵聽 PHP 偵錯連線
debug.type.float=浮點
debug.type.int=int
debug.type.resource=資源
debug.xdebug=Xdebug
debug.xdebug.error.unsupported.protocol.version=不支持的 Xdebug 協議版本
debug.zend.cannot.accept.incoming.connection=無法接受來自 Zend Debugger 的傳入連線
debug.zend.debugger=Zend 偵錯器
debug.zend.debugger.settings.broadcasting=Zend Debugger 設定廣播
debug.zend.error.title.cannot.accept.external.xdebug.connection=無法接受外部 Xdebug 連線
debug.zend.required.protocol.version.0.or.higher=所需協議版本為 ''{0}'' 或更高版本
debugger.method=方法
declaration.in.parent.class.is.incompatible.with.interface=父類別中的宣告與接口不相容
declaration.must.be.compatible.with.0=宣告必須與 {0} 相容
declaration.must.be.compatible.with.super=宣告必須與父級相容
default=預設\\:
default.value=預設值
delete.assignment=刪除賦值
delete.case=刪除 'case'
delete.catch.statement=刪除 'catch' 語句
delete.elseif=刪除 'elseif'
delete.if=刪除 'if'
delete.redundant.method.override=移除方法
delete.redundant.switch.branch=刪除冗餘 'switch' 分支
delete.unused.element=刪除未使用的元素
delete.void.return.type=刪除 'void' 返回值類型
deprecated.form.of.callables=已棄用的可調用對象形式
design.rules=設計規則
diagnosing=正在診斷
dialog.error.title.php.extract.class=PHP 提取類別
dialog.message.cannot.create.file.because.project.already.disposed=由於專案已被處置，無法建立檔案
dialog.message.could.not.find.network.interface=找不到 {0} 網絡接口
dialog.message.do.you.want.to.upload.content.scratch.file.to.3v4l.org.make.it.public=是否要將臨時檔案的內容上傳到 3v4l.org 並將其公開?
dialog.message.docker.account.not.found=找不到 Docker 帳戶
dialog.message.docker.account.not.specified=未指定 Docker 帳戶
dialog.message.execution.quality.tools.in.untrusted.project.prohibited=禁止在不受信任的專案中執行品質工具
dialog.message.no.interface.addresses.for.network.interface=沒有 {0} 網絡接口的接口地址
dialog.message.port.cannot.be.negative.number=端口號不能為負
dialog.message.query.string.cannot.start.with=查詢字串不能以 '?' 開頭
dialog.message.server.host.cannot.be.empty=伺服器主機不能為空
dialog.message.unable.to.create.configurations.with.same.executable.path=同一 Composer 專案的同一解釋器的組態發生衝突\\: {0}
dialog.title.configure.code.patterns=組態程式碼模式…
dialog.title.edit.phpunit.test.pattern=編輯 PHPUnit 測試模式
dialog.title.enter.tag.name=輸入標記名稱
dialog.title.inline.variable=內聯變數
dialog.title.new.php.file=新增 PHP 檔案
dialog.title.select.methods.to.propagate.safe.delete=選擇要傳播安全刪除的方法
dialog.title.select.parameters.to.propagate.safe.delete=選擇要傳播安全刪除的參數
dialog.title.select.properties.to.initialize=選擇要初始化的屬性
difference.to.greenwich.time.gmt.with.colon.between.hours.and.minutes=與格林威治時間(GMT)的差值，小時和分鐘之間有冒號(+02\\:00)
difference.to.greenwich.time.gmt.without.colon.between.hours.and.minutes=與格林威治時間(GMT)的差值，小時和分鐘之間沒有冒號(+0200)
directories=目錄
display.name.directory.0=目錄 ''{0}''
do.not.ask.again=不再詢問
do.not.override=不覆寫
docker.compose.border.title.lifecycle=生存期
docker.compose.coverage.file.failed.to.copy=無法從 Docker 容器複製覆蓋率結果
docker.compose.coverage.file.failed.to.extract=無法提取覆蓋率結果
docker.compose.coverage.file.is.not.found=找不到覆蓋率檔案
docker.compose.failed.to.start.container=啟動 docker-compose 服務失敗，請在命令行中啟動並重試
docker.compose.radio.button.always.start.a.new.container.docker.compose.run=始終啟動一個新容器('Docker-compose run')
docker.compose.radio.button.connect.to.existing.container.docker.compose.exec=連線到現有容器('Docker-compose exec')
docker.host.name.error=主機名與 <i>host.docker.internal</i> 不同
docker.host.name.error.descr=<i>host.docker.internal</i> 解析為主機使用的內部 IP 地址
doctrine.query.builder.completion.ascending.order.description=從最小到最大
doctrine.query.builder.completion.descending.order.description=從最大到最小
doctrine.query.builder.parameter.name=DQL 參數
doctrine.query.builder.table.name=DQL 表名稱
download.validation.script=下載 Xdebug 驗證腳本
duplicate.value.in.enum.for.cases.0.and.1=case ''{0}'' 和 ''{1}'' 的枚舉中的重複值
duplicate.variable.0=重複的變數 ''{0}''
dynamically.declared.field=動態宣告的欄位
edit.custom.format.function=編輯自定義格式函式
edit.template=編輯模板
empty.extends.list=空 extends 列表
empty.implements.list=空實作列表
empty.pattern=空模式
empty.type=空類型
enable=啟用
enable.navigate.links.for.class.and.member.references=為類別和成員參照啟用“… 導覽”鏈接
enable.return.function.value.debugging.xdebug.3.2=啟用返回函式值偵錯 (Xdebug 3.2+)
enable.support=啟用支援
enable.the.following.extension=在 PHP 執行時選項中啟用以下擴展存根\\:
enable.tostring.object.view=啟用 '__toString' 物件檢視
enables.inspection.0=啟用檢查 ''{0}''
english.ordinal.suffix.for.the.day.of.the.month.2.characters=月中幾號的英語序數後綴，2 個字元(st、nd、rd、th)
enter.annotation=輸入註解
entry.points=入口點
entry.points.tab=入口點
enum=枚舉
enum.backing.type.must.be.int.or.string=枚舉支援類型必須為 'int' 或 'string'
enum.backing.type.must.be.int.or.string.0.given=在給出 ''{0}'' 的情況下，枚舉支援類型必須為 ''int'' 或 ''string''
enum.case=枚舉 case
enum.case.should.be.located.only.inside.enum.classes=枚舉 case 只應位於枚舉類別內部
enum.case.type.0.does.not.match.enum.backing.type.1=枚舉 case 類型 ''{0}'' 與枚舉支援類型 ''{1}'' 不符合
enum.case.value.must.be.constant=枚舉 case 值必須為常數
enum.may.not.include.0=枚舉不得包含 ''{0}''
enum.may.not.include.extend=枚舉不得擴展其他類別
enum.properties.are.immutable=枚舉屬性不可變
enum.value.cannot.referer.to.enum.cases=枚舉值不能參照枚舉 case
enums.may.not.be.cloned=不得克隆枚舉
enums.may.not.implement.the.serializable.interface=枚舉可能不會實作 'Serializable' 接口
enums.may.not.include.properties=枚舉不得包含屬性
environment.key.description.run.composer.install=定義找不到 'vendor' 目錄時是否執行 'composer install'\\n值\\: 'false' (預設值)或 'true'
error.cannot.connect.to.0=無法連線到 ''{0}''
error.cannot.connect.to.0.1=無法連線到 ''{0}''\\: {1}
error.cant.create.edge=無法建立關係鏈接
error.during.access.to.3v4l.org=存取 3v4l.org 時出錯
error.file.unable.create.selected.directory=無法在所選目錄中建立檔案 {0}
error.template.unable.create.from.internal.template=無法從內部模板 {0} 建立檔案
error.template.unable.parse.internal.template=無法解析內部模板 {0}
exception.analysis.settings.path=PHP/分析
exception.class=異常類別
exclude.0.from.1.analysis.a=從{1}分析中排除{0}。
executable.0.was.not.found.in.path.please.make.sure.it.s.there.possible.solutions=在 %PATH% 中找不到可執行檔案 ''{0}''。請確保已指定有效路徑。可能的解決方案\\:
executable.0.was.not.found.in.path.please.make.sure.it.s.there.possible.solutions1=在 $PATH 中找不到可執行檔案 ''{0}''。請確保已指定有效路徑。可能的解決方案\\:
execution.result.is.null=執行結果為 null
execution.statistics=執行統計
expected.class.reference=應為\\: 類別參照
expected.expression.after.spread.operator=應為\\: 展開運算符後的表達式
expected.property=屬性
explore.migration.guides=探索遷移指南
expression=表達式
expression.0=表達式 {0}
expression.is.not.allowed.as.constant.value=表達式不允許作為常量值
expression.is.not.allowed.as.field.default.value=表達式不允許為欄位預設值
expression.is.not.allowed.as.parameter.default.value=表達式不允許為參數預設值
expression.is.not.allowed.as.static.initializer=表達式不允許為 static 初始設定式
expression.is.not.assignable=表達式不可賦值
expression1=表達式
expressions=表達式
extends=擴展
extends.implements.overrides=擴展/實作/覆寫
extends.or.implements=擴展或實作
external.formatter.after=啟用外部格式化程序會停用 IDE 的內建格式化程序
external.formatter.couldnt.run.tool={0} 無法啟動。請檢查您的組態。
external.formatter.phpcbf=PHP Code Beautifier and Fixer
external.formatter.phpcsfixer=PHP CS Fixer
extract.condition=提取條件
extract.method.link.label.more.options=更多選項
extract.method.parameter.name.column.title=參數
extract.method.selector.title=要提取的程式碼
extract.selected.string.part.as.concatenation.operand=將所選字串部分作為串聯動作數提取
extract.selected.string.part.as.format.function.argument=將所選字串部分作為格式函式實參提取
extract.side.effect=提取副作用
failed.to.find.interpreter=無法尋找解釋器
failed.to.find.valid.interpreter.path=無法尋找有效的解釋器路徑
failed.to.parse.php.ini.output.0=無法解析 php --ini 輸出\\: {0}
failed.to.retrieve.php.versions.from.3v4l.org=無法從 3v4l.org 檢索 PHP 版本資訊
failed.to.run.interpreter=無法執行解釋器
field=欄位
field.name=欄位名稱
field.ref.is.deprecated=欄位 '\\#ref' 已棄用
field.ref.not.found=找不到欄位 '\\#ref'
field1=欄位
fields.cannot.be.declared.abstract=屬性不能宣告為 abstract
fields.cannot.be.declared.final=屬性不能宣告為 final
fields.default.visibility.private=private
file=檔案
file.0.does.not.exist=檔案 {0} 不存在
file.0.does.not.exists=檔案 {0} 不存在
files.in.the.directory.should.be.accessible.by.0.request=目錄中的檔案應當可通過 {0} 請求進行存取。
files.in.the.remote.directory.should.be.accessible.by.0.request=遠端目錄中的檔案應當可通過 {0} 請求進行存取。
filetype.composer.log.description=Composer 日誌
filetype.doctrine.query.description=Doctrine 查詢語言
filetype.phar.description=Php Phar
filetype.phar.display.name=Php Phar
filetype.php.description=PHP
filetype.profiler.snapshot.description=分析器快照
final=final
final.class.cant.be.inherited=類別 {0} 為 final
final.modifier.is.not.allowed.here=此處不允許使用 'final' 修飾符
find.cause=尋找原因
find.classes.without.member=尋找沒有成員的類別
find.exception.cause.table.title=異常原因
find.field.accessors.text=是否要搜尋 ''{0}'' 的存取器?
find.field.accessors.title=搜尋存取器
find.options.include.child.methods.checkbox=包括覆寫/實作方法(&V)
find.usages.button.base.method=基方法
find.usages.button.current.method=當前方法
find.usages.prompt.dialog.implements=類別 ''{1}'' 的方法 ''{0}()'' 在 ''{2}'' 中實作了{3,choice,0\\#方法|1\\#方法}\\n是否要尋找基{3,choice,0\\#方法|1\\#方法}的用法?
find.usages.prompt.dialog.overrides=類別 ''{1}'' 的方法 ''{0}()'' 在 ''{2}'' 中重寫了{3,choice,0\\#方法|1\\#方法}\\n是否要尋找基{3,choice,0\\#方法|1\\#方法}的用法?
fix.not.available=修復不可用
fix.package.text=將命名空間 ''{0}'' 取代為 ''{1}''
fix.package.text.family=修復命名空間 
flip.key.value.intention.family.name=翻轉鍵和值
flip.key.value.intention.message.all.in.array=翻轉陣列中的所有鍵和值
flip.key.value.intention.message.single=翻轉鍵和值
fluent.setters=Fluent setter
folding.checkbox.collapse.attribute=特性
folding.checkbox.collapse.attribute.list=特性列表
folding.checkbox.collapse.classes=類別主體
folding.checkbox.collapse.function.body=函式體
folding.checkbox.collapse.heredocs.and.nowdocs=heredoc/nowdoc
folding.checkbox.collapse.imports=Import
folding.checkbox.collapse.method.body=方法體
folding.checkbox.collapse.php.tags=標記
follow.this.0.for.more.information.about.deployment=有關部署的詳細資訊，請參閱此{0}。
follow.this.0.for.more.information.about.path.mappings=有關路徑映射的詳細資訊，請參閱{0}。
follow.this.links.to.install.and.configure.0.or.1=點擊這些鏈接以安裝並組態 {0} 或 {1}。
for=for
foreach=foreach
found.roots.configured=檢測到並組態了 PSR-0 根
framework.composer=Composer
framework.composer.0.1.version.2={0} {1}，版本 {2}
framework.composer.add.composer.dependency.title=管理 Composer 相依項
framework.composer.add.dependency.available.packages.label=可用軟體套件
framework.composer.add.dependency.close.button=關閉(&C)
framework.composer.add.dependency.hide.tooltip=隱藏
framework.composer.add.dependency.install.button=安裝
framework.composer.add.dependency.no.new.version.found.for.0=找不到 {0} 的新版本。
framework.composer.add.dependency.no.package.selected=未選擇軟體套件
framework.composer.add.dependency.no.such.package=packagist 上無此類別軟體套件
framework.composer.add.dependency.no.version.selected=未選擇版本
framework.composer.add.dependency.running=正在執行
framework.composer.add.dependency.settings.cl.dialog.title=參數
framework.composer.add.dependency.settings.cl.label=命令行參數(&P)\\:
framework.composer.add.dependency.settings.interpreter.label=PHP 解釋器\\:
framework.composer.add.dependency.settings.title=設定(&S)
framework.composer.add.dependency.show.output=顯示輸出
framework.composer.add.dependency.successfully.installed.0.version.1=已成功安裝 {0}，版本 {1}。
framework.composer.add.dependency.successfully.removed.0=已成功移除 {0}。
framework.composer.add.dependency.successfully.updated.0=已成功更新 {0}。
framework.composer.add.dependency.task.title=新增相依項
framework.composer.add.dependency.update.button=更新
framework.composer.available.version=可用版本\\:
framework.composer.checking.for.update=正在檢查更新…
framework.composer.configurable.title=Composer
framework.composer.create.project.from=自以下建立專案
framework.composer.create.project.progress.title=建立專案
framework.composer.default.composer.interpreter.name=Composer 的解釋器
framework.composer.default.interpreter.for.this.project.is.remote=此專案的預設解釋器是遠端解釋器，無法使用。
framework.composer.default.interpreter.is.not.configured=尚未為此專案組態預設解釋器。
framework.composer.default.project.interpreter=預設專案解釋器
framework.composer.empty.package.name.in.0={0} 中的軟體套件名稱為空
framework.composer.empty.path.to.0={0} 的路徑為空
framework.composer.expected.name.0.versions.0.description.got.1=應為 <name> {0} <versions> {0} <description>，獲得的是 {1}
framework.composer.failed.check.for.update=無法執行 'update --dry-run' 指令。
framework.composer.failed.to.0=無法{0}。
framework.composer.failed.to.0.1.script.was.cancelled=無法{0} {1}。腳本已被取消。
framework.composer.failed.to.download.composer.phar=無法下載 composer-stable.phar
framework.composer.failed.to.load.package.names=無法載入軟體套件名稱。
framework.composer.failed.to.parse.package.description=無法解析軟體套件描述。
framework.composer.failed.to.parse.package.names=無法解析軟體套件名稱。
framework.composer.file.0.is.not.found=找不到檔案 ''{0}''。
framework.composer.file.0.set.as.composer.config.change.setting.a.href.here.a=檔案 ''{0}'' 設定為 Composer 組態。
framework.composer.init.dialog.title.composer.settings=Composer 設定
framework.composer.initialize.popup=找到了 Composer 組態檔案 {0}。專案設定與其同步。
framework.composer.initialize.popup.multi.composer=找到 {0} 個 composer 組態檔案。專案設定已與其同步。
framework.composer.install.action.name=安裝
framework.composer.install.task.title=正在安裝軟體套件
framework.composer.interpreters.combo.default.interpreter=< 預設解釋器 >
framework.composer.interpreters.combo.default.interpreter.no.php.path=預設解釋器未提供 PHP 路徑
framework.composer.interpreters.combo.default.project.interpreter=< 預設專案解釋器 >
framework.composer.interpreters.combo.no.default.interpreter=預設設定中沒有預設解釋器
framework.composer.interpreters.combo.no.default.interpreter.in.project=此專案中沒有預設解釋器
framework.composer.label.installed.version=已安裝的版本\\:
framework.composer.label.version.to.install=要安裝的版本(&V)\\:
framework.composer.load.update.availability=檢查可用軟體套件更新
framework.composer.loading.package.description=正在載入軟體套件描述
framework.composer.loading.packages=正在載入 Composer 軟體套件
framework.composer.loading.update.availability=正在檢查 Composer 軟體套件更新
framework.composer.name.composer=Composer
framework.composer.no.description.available=無可用描述。
framework.composer.no.package.versions.in.0={0} 中沒有軟體套件版本
framework.composer.notification.title.init.composer=初始化 Composer
framework.composer.notify.about.missing.vendor=缺少 'vendor' 目錄時通知
framework.composer.package.default.version=<預設>
framework.composer.package.version.available.0={0}的更新
framework.composer.packages.were.added.0.excluded.folders.popup=Composer 軟體套件已被新增到排除的目錄中。
framework.composer.packages.were.added.0.php.include.paths.popup=Composer 軟體套件已被新增到 PHP include 路徑中。
framework.composer.packages.were.changed.0.excluded.folders.popup=Composer 軟體套件已更改，因此更新了排除的目錄。
framework.composer.packages.were.changed.0.php.include.paths.popup=Composer 軟體套件已更改，因此更新了 PHP include 路徑。
framework.composer.packages.were.changed.0.test.config.popup={0} 組態已根據 composer.json 更新
framework.composer.packages.were.changed.0.test.config.title=Composer 軟體套件已被更改
framework.composer.packages.were.moved.to.0.php.include.paths.popup=Composer 軟體套件已從 Composer 外部庫移至 PHP include 路徑。
framework.composer.packages.were.removed.0.excluded.folders.popup=Composer 軟體套件已從排除的目錄中移除。
framework.composer.packages.were.removed.0.php.include.paths.popup=Composer 軟體套件已從 PHP include 路徑中移除。
framework.composer.path.dialog.path.to.composer=Composer 路徑
framework.composer.path.dialog.path.to.composer.json=composer.json 路徑
framework.composer.path.dialog.specify.composer.executable=指定 Composer 可執行檔案\\:
framework.composer.path.dialog.specify.composer.json=指定 composer.json\\:
framework.composer.path.dialog.specify.composer.phar=指定 Composer phar\\:
framework.composer.path.form.empty.path.to.composer.executable=Composer 可執行檔案路徑為空
framework.composer.path.form.empty.path.to.composer.json=composer.json 路徑為空
framework.composer.path.form.empty.path.to.composer.phar=composer.phar 路徑為空
framework.composer.path.form.execution.validation.wrapper=<html>執行未設定。<br/>{0}</html>
framework.composer.path.to.php.executable.titled=PHP 可執行檔案的路徑
framework.composer.path.validation.0.is.a.directory={0} 是目錄
framework.composer.project.generation.error.title=無法建立 Composer 專案
framework.composer.project.generator.description=通過 Composer 指令建立專案。
framework.composer.project.generator.failed.to.copy.temp.directory.0.content.to.project.root=無法將臨時目錄 ''{0}'' 內容複製到專案根目錄
framework.composer.project.generator.name=Composer 軟體套件專案
framework.composer.project.generator.notification.content.failed.to.find=找不到 {0}
framework.composer.project.generator.notification.content.failed.to.find.composer.json=無法在專案根目錄中找到 composer.json
framework.composer.remove.action.name=移除
framework.composer.removing.package.task.title=移除軟體套件
framework.composer.require.action.name=需要
framework.composer.require.task.title=正在安裝軟體套件 {0}
framework.composer.run.path.to.composer.json=composer.json 路徑\\:
framework.composer.run.script=腳本\\:
framework.composer.run.script.missing=未指定 Composer 腳本
framework.composer.script.run.configuration.description=Composer 腳本執行組態
framework.composer.script.run.configuration.name=Composer 腳本
framework.composer.selected.file.is.not.composer.json=所選檔案不是 composer.json
framework.composer.self.update.action.name=自我更新
framework.composer.self.update.task.title=更新 Composer
framework.composer.specify.php.executable.0=指定 PHP 可執行檔案 {0}
framework.composer.update.action.name=更新
framework.composer.update.task.title=正在更新軟體套件
framework.composer.updating.package.task.title=更新軟體套件
framework.composer.vendors.library.name=Composer 供應商
frameworks.composer.could.not.get.package.info=無法獲取軟體套件資訊。
frameworks.composer.could.not.get.packages.info.0=無法獲取軟體套件資訊。{0}
frameworks.settings.none.installed=沒有可用的框架設定提供程序。<br/>考慮安裝 Drupal Support、Joomla\\! Support 或 WordPress Support 延伸模組。
frameworl.composer.show.quick.actions=顯示具有快速動作的 composer.json 頂部面板
function=函式
function.call=函式呼叫
function.call.is.not.allowed.here=此處不允許使用函式呼叫
function.call.is.not.compatible.with.advance.callable.declaration=函式呼叫與 'callable' 宣告不相容
function.fqn=函式 FQN
function.has.parameter.with.incompatible.default.value.type=函式有一個預設值與其宣告的類型不相容的參數
function.name.must.be.callable.a.string.closure.or.class.implementing.invoke.currently.0=函式名稱必須可呼叫 - 字串、閉包或實作 ''__invoke'' 的類別，當前為 ''{0}''
function.ref.is.deprecated=函式 '\\#ref' 已棄用
function2=函式
functions.to.be.extracted=要提取的函式
generating.autoloader=正在生成自動載入器
getters.setters.configure=組態…
getting.installed.standards=正在獲取已安裝的標準…
global.code.should.be.enclosed.in.global.namespace.declaration=全域程式碼應包含在全域命名空間宣告中
global.namespace.should.use.braced.syntax=全域命名空間應使用帶大括號的語法
global.this.is.deprecated=不能將 $this 用作全域變數，它已在 PHP 7.1 中棄用
global.variable.from.globals.array.assignment=來自 $GLOBALS 陣列賦值的全域變數
globals.can.only.be.modified.using.the.globals.name.value.syntax='$GLOBALS' 只能使用 '$GLOBALS[$name] \\= $value' 語法進行修改
group.ComposerGroup.text=Composer
group.ComposerToolsGroup.text=Composer
group.DBGPProxyGroup.text=DBGp 代理
group.PHPQualityToolsAddToIgnoredList.text=新增到忽略列表…
group.PhpDebuggerCopyAsGroup.text=將值複製為…
group.PhpNewTestGroup.text=PHP 測試
group.advanced.settings.php=PHP
group.methods.by.type=按類型對方法分組
group.use.statements.by.selected.prefix=按所選前綴將 'use' 語句分組
guality.tool.configuration.show.ignored.files=顯示忽略的檔案
gutter.overriden.select.implementation.title=選擇 {0} 的實作
gutter.overriden.select.subclass.title=選擇 {0} 的子類別
gutter.overriding.select.title=選擇要導覽的父方法
gutter.pin.overriden.select.implementation.title={0} 的實作
gutter.pin.overriden.select.subclass.title={0} 的實作
gutter.pin.overriding.select.title={0} 的父項
guzzle.http.request.gutter.name=Guzzle HTTP 請求
guzzle.invalid.http.request.file=檔案 ''{0}'' 是無效的 HTTP 請求檔案
guzzle.name=Guzzle
guzzle.open.http.request=在 HTTP 請求編輯器中開啟
guzzle.unable.to.add.new.request.to.file=無法向 ''{0}'' 檔案新增新請求
guzzle.unable.to.extract.request.parameters=無法提取請求參數
halt.compiler.can.only.be.used.from.the.outermost.scope=僅可從最外側作用域使用 '__halt_compiler()'
handler.with.the.same.session.id.is.already.registered=已註冊使用相同會話 ID 的處理程序
hint.evaluation.fully.contains=求值結果完全覆蓋 ''{0}'' 的可能結果
hint.evaluation.makes.array.always.empty=求值使得陣列始終為空
hint.evaluation.makes.subsequent.condition.always.true=求值使後續條件始終為 ''{0,choice,0\\#false|1\\#true}'
hint.text.can.not.find.target.class.for.modification=找不到要修改的目標類別。
hint.text.element.doesn.t.have.fqn=元素沒有 FQN
hint.text.installed.version=已安裝的版本
hint.text.target.class.does.not.belong.to.project.can.not.be.modified=目標類別 {0} 不屬於該專案\\n並且無法修改。
hint.text.target.class.not.writable=目標類別 {0} 不可寫。
hint.text.use.statement.choice.s.removed={0} ''use'' 語句{1, choice, 0\\#|1\\#}已移除
hint.text.use.statements.checked.nothing.was.removed=已檢查 {0} ''use'' 語句，未移除任何內容
host.name.eg.localhost.example.com=主機名。例如，localhost.example.com
hours.numeric=小時，數字(1、3、23)
hours.numeric.at.least.2.digits.with.leading.0=小時，數字，至少 2 位數，帶前導 0 (01、03、23)
how.to.fix=修正方法
html.note.core.extensions.are.part.of.the.php.core.and.cannot.be.left.out.of.a.php.binary.with.compilation.options.html=<html>註\\: 核心擴展是 PHP 核心的一部分，不能放在包含編譯選項的 PHP 二進制檔案外部。</html>
http.client.request.init.debug.connection.title=正在初始化偵錯連線
identifier=關鍵字
if.with.common.parts=具有通用部分的 'if'
if.you.have.already.configured.debug.extension.in.php.ini.file.check.possible.reasons.why.it.was.not.loaded=如果已在 php.ini 檔案中組態偵錯擴展，請檢查未載入該擴展的可能原因\\:
if.you.ve.changed.the.path.recently.restart.the.ide=如果最近更改了 %PATH%，請重啟 IDE。
if.you.ve.changed.the.path.recently.restart.the.ide1=如果最近更改了 $PATH，請重啟 IDE。
ignore.imports.and.formatting=忽略匯入和格式設定
implement.method=實作方法
import=匯入
import.from.deployment.configuration=從部署組態匯入
import.references.on.paste.dialog.message=<html>貼上的程式碼段使用 {0}，後者在目標作用域中不能通過匯入存取。<br/>選擇您想要匯入到作用域中的{0}。</html>
import.references.on.paste.dialog.title=選擇要匯入的{0}
in=位置\\:
in.0=\\ ({0} 中)
include.eol.slow=包括 eol (慢)
include.path=Include 路徑
include.path.column.info=路徑
incorrect.null.safe.operator=錯誤的 nullsafe 運算符
info=資訊
information=資訊
init.cache=初始化快取
initialize.var.quick.fix.family.name=使用值初始化
initializer=初始設定式
inject.language.using.phpdoc=使用 PHPDoc 注入語言
inlay.hints.usages.text={0,choice, 0\\#無用法|1\\#1 個用法|2\\#{0,number}'{1,choice, |1\\#+}' 用法}
insert.default.branch=插入 'default' 分支
inspection.add.override.attribute=使用 \\#[Override] 標記覆寫的方法
inspection.array.access.can.be.replaced.with.foreach.value=陣列存取可被取代為 'foreach' 值
inspection.array.modification.will.not.have.any.effect=按值修改從函式返回的陣列不會有任何影響
inspection.array.to.string.conversion=陣列到字串的轉換
inspection.arrayall.can.be.converted.to.loop='array_all()' 呼叫可以轉換為迴圈
inspection.arrayany.can.be.converted.to.loop='array_any()' 呼叫可以轉換為迴圈
inspection.arrayfill.can.be.converted.to.loop='array_fill()' 呼叫可以轉換為迴圈
inspection.arrayfilter.can.be.converted.to.loop='array_filter()' 呼叫可以轉換為迴圈
inspection.arrayfind.can.be.converted.to.loop='array_find()' 呼叫可以轉換為迴圈
inspection.arrayfindkey.can.be.converted.to.loop='array_find_key()' 呼叫可以轉換為迴圈
inspection.arraymap.can.be.converted.to.loop='array_map()' 呼叫可以轉換為迴圈
inspection.assignment.in.condition=條件中的賦值
inspection.assignment.in.condition.move.assignment.out.of.condition.fix.name=從條件中移出賦值
inspection.assignment.replaceable.with=<code>\\#ref</code> 可被取代為 ''{0}'' \\#loc
inspection.cannot.indirectly.modify.property.outside.of.scope=無法間接修改 ''set'' 可見性作用域之外的 ''{0}'' 屬性
inspection.cannot.modify.property.outside.of.scope=無法修改 ''set'' 可見性作用域之外的 ''{0}'' 屬性
inspection.cannot.modify.property.with.limited.set.visibility.from.global.scope=無法修改 'set' 可見性作用域之外的屬性
inspection.cannot.unset.property.outside.of.scope=無法在 ''set'' 可見性作用域之外取消設定 ''{0}'' 屬性
inspection.closure.can.be.converted.to.arrow.function=閉包可以轉換為箭頭函式
inspection.closure.can.be.converted.to.first.class.callable='Closure\\:\\:fromCallable()' 可以轉換為一級可調用語法
inspection.code.patterns.panel.description.label=如果 fqn 名稱符合，則將程式碼標記為入口點
inspection.code.patterns.panel.description.text=將方法留空以表示建構函式 \\n任何 * 都將與 fqn 名稱中的一個或多個字元符合
inspection.code.patterns.panel.errors.class=模式必須是有效的 php fqn，僅接受 '*' 作為佔位符
inspection.code.patterns.panel.errors.member=方法模式 {0} 必須是有效的 php 關鍵字，僅接受 ''*'' 作為佔位符
inspection.codeSmell.class.call.is.not.casesensitive=類別用法中的大小寫與宣告中的大小寫不符合
inspection.codeSmell.function.call.is.not.casesensitive=函式/方法呼叫中的大小寫與宣告中的大小寫不符合
inspection.codeSmell.namespace.reference.is.not.casesensitive=命名空間參照中的大小寫與宣告中的大小寫不符合
inspection.codeSmell.overriding.method.visibility.description=方法可見性不應被覆寫
inspection.composer.file.reference.problem=路徑 ''{0}'' 未找到
inspection.composer.json.file.references.inspection.display.name=未解析的檔案參照
inspection.constructor.style=舊式建構函式
inspection.convert.to.json.validate='json_decode()' 和 'json_last_error()' 可以轉換為 'json_validate()'
inspection.curly.braces.access.syntax.usage=大括號存取語法自 PHP 7.4 已棄用
inspection.dead.code.problem.class.abstract.several.implementations={0} 具有{1, choice, 1\\#直接或間接實作|2\\# {1,number} 個直接或間接實作}，但<ul><li>其從未實例化或</li><li>不存在可從入口點到達的實例化。</li></ul>
inspection.dead.code.problem.class.nousages.synopsis=類別從未使用。
inspection.dead.code.problem.empty.constant.synopsis=常數從未使用。
inspection.dead.code.problem.empty.function.synopsis=函式從未使用。
inspection.dead.code.problem.multiple.constant.synopsis=常數有 {0, choice, 1\\#1 個用法|2\\#{0,number} 個用法}，但無法從入口點到達。
inspection.dead.code.problem.recursive.suspicious.function.synopsis=所有函式用法均屬於不存在可從入口點到達的成員的呼叫鏈。
inspection.dead.code.problem.single.constant.synopsis=常數有一個用法，但無法到達。
inspection.dead.code.problem.suspicious.function.synopsis=函式無法從入口點到達。
inspection.dead.code.problem.trait.additional.reachable=特徵具有可到達用法。
inspection.dead.code.problem.trait.additional.unreachable=特徵沒有可到達用法。
inspection.dead.code.problem.trait.synopsis=特徵從未使用。
inspection.deprecated.cast={0} 轉換自 PHP {1} 已棄用
inspection.deprecated.implode.usage=帶實參(陣列，字串)呼叫的 {0} 自 PHP 7.4 已棄用
inspection.disabled.quality.tool.inspection={0} 檢查已停用
inspection.disabled.quality.tool.inspection.fix=啟用檢查
inspection.disabled.quality.tool.inspection.open.fix=開啟檢查設定
inspection.division.by.zero=除以零
inspection.doc.field.type.mismatch={0, choice, 0\\#屬性|1\\#類別常數}類型不符合
inspection.doc.missing.return.tag.problem=函式/方法 PHPDoc 註釋中缺少 @return 標記
inspection.doc.throws.option.skip.on.empty.phpdoc=忽略沒有 @param/@return 的 PHPDoc
inspection.doc.throws.problem=PHPDoc 註釋不包含所有必需的 @throws 標記
inspection.duplicate.array.keys.display.name=重複的陣列鍵
inspection.duplicate.array.keys.problem=重複的陣列鍵
inspection.duplicate.array.keys.problem.0=值為 ''{0}'' 的重複陣列鍵
inspection.duplicate.match.arm.body=''match'' arm 是 ''{0}'' arm 的重複項
inspection.duplicate.match.condition.message=重複條件
inspection.duplicate.phpdoc.type.fix=從標記中移除重複類型
inspection.duplicate.phpdoc.type.problem=重複的類型 ''{0}''
inspection.duplicate.switch.case.body=''switch'' 中的分支是 ''{0}'' 分支的重複項
inspection.dynamic.method.called.as.static.problem=非 static 方法 '\\#ref' 不應被靜態呼叫
inspection.dynamic.method.called.as.static.problem.magic=非 static 方法 '\\#ref' 不應被靜態呼叫，但類別具有 '__magic' 方法。
inspection.export.results.back.traces=反向追蹤
inspection.export.results.const=常數
inspection.expression.have.same.operands=表達式有相同動作數
inspection.expression.result.unused.problem=表達式結果未在任何位置使用
inspection.ext.is.specified.in.require.dev.but.used.outside.tests=''{0}'' 在 ''require-dev'' 部分中指定，但在測試外部使用
inspection.ext.is.specified.in.suggest=''{0}'' 在 ''suggest'' 中指定，可能不可用
inspection.family.name.replace.implicit.octal.literal.with.explicit.one=將隱式八進制字面量取代為顯式八進制字面量
inspection.field.assignment.type.mismatch=類型不相容\\: 應為 ''{0}'' 類型的屬性，提供的是 ''{1}''
inspection.field.assignment.type.mismatch.multi.resolve=賦值的類型 ''{0}'' 與屬性的宣告類型不相容
inspection.field.can.be.promoted=可以提升屬性
inspection.foreach.array.is.used.as.value.problem=變數 ''{0}'' 已被用作 ''array expression''
inspection.format.function.parameters.mismatch.conversion.specification=轉換規範未映射到任何參數
inspection.format.function.parameters.mismatch.parameter=參數未映射到任何轉換規範
inspection.fully.qualified.name.usage=限定符可被取代為匯入
inspection.fully.qualified.name.usage.name.option.ignore.global.namespace=忽略全域命名空間
inspection.fully.qualified.name.usage.option.enable.file.scope=在檔案作用域內啟用
inspection.group=PHP
inspection.group.code.smell=程式碼異味
inspection.group.code.style=程式碼樣式
inspection.group.control.flow=控制流
inspection.group.general=一般
inspection.group.naming.convention=命名約定
inspection.group.php.doc=PHPDoc
inspection.group.probably.bug=可能的 bug
inspection.group.type.compatibility=類型相容性
inspection.group.undefined=未定義
inspection.group.unused=未使用
inspection.group.unused.quickfix.label=未使用的元素
inspection.group.unused.quickfix.message=未使用的元素\\: ''{0}''
inspection.hierarchyChecks=類別層次結構檢查
inspection.hierarchyChecks.descr=類別必須被宣告為 abstract 或實作 {0}
inspection.hierarchyChecks.field.type.redeclaration.match.super.type=類型必須為 ''{0}''(如基類別 ''{1}'' 中)
inspection.hierarchyChecks.field.type.redeclaration.must.not.be.defined=類型不得定義(如基類別 ''{0}'' 中)
inspection.hierarchyChecks.should.implement=類別必須實作 {0}
inspection.ignored.class.alias.declaration=忽略了類別名聲明
inspection.illegal.array.key.type.problem=非法陣列鍵類型
inspection.illegal.psr.class.path.class.is.not.matched.to.psr0={0}名稱與包含檔名不符合
inspection.illegal.psr.class.path.namespace.name.is.not.matched.to.psr0=命名空間名稱與 PSR-0/PSR-4 專案結構不符合
inspection.illegal.string.offset.problem=非法字串偏移 {0}
inspection.incompatible.return.type=返回值應為 ''{0}''，返回的是 ''{1}''
inspection.incompatible.return.type.batch=返回值類型與宣告不相容
inspection.incompatible.return.type.strict.type.checking=嚴格類型檢查
inspection.inconsistent.return.points.option.treat.return=在 'void' 函式/方法中以相同方式對待 'return null' 和 'return'
inspection.inconsistent.return.points.problem1=缺少 'return' 語句
inspection.inconsistent.return.points.problem1.yield=缺少 'yield' 語句
inspection.inconsistent.return.points.problem2=缺少返回實參
inspection.invalid.function.result.used.problem=使用了 ''{0}'' {1} ''{2}'' 結果
inspection.invalid.function.result.used.problem.function=函式
inspection.invalid.function.result.used.problem.method=方法
inspection.json.all.not.installed.packages=未安裝軟體套件
inspection.json.duplicated.packages.0=require 和 require-dev 中存在重複的 ''{0}'' 條目
inspection.json.duplicated.packages.fix=從 require-dev 中移除重複項
inspection.json.not.installed.package.update.fix=更新軟體套件
inspection.json.not.installed.packages=未安裝軟體套件
inspection.json.not.installed.packages.install.fix=安裝軟體套件
inspection.json.not.installed.packages.update.fix=更新所有軟體套件
inspection.key.getter.setter.can.be.replaced.property.hooks=getter 和 setter 可被取代為 get 和 set 屬性掛鈎
inspection.language.level.quick.fix.switch.language.level.in.composer.0=切換到 composer.json 中的 PHP {0} 語言級別
inspection.language.level.quick.fix.switch.language.level.in.composer.manually.0=手動切換到 composer.json 中的 PHP {0} 語言級別
inspection.language.level.quick.fix.switch.language.level.name.0=切換到 PHP {0} 語言級別
inspection.loop.can.be.converted.to.arrayall=迴圈可以轉換為 array_all()' 呼叫
inspection.loop.can.be.converted.to.arrayany=迴圈可以轉換為 array_any()' 呼叫
inspection.loop.can.be.converted.to.arrayfill=迴圈可以轉換為 'array_fill()' 呼叫
inspection.loop.can.be.converted.to.arrayfilter=迴圈可以轉換為 'array_filter()' 呼叫
inspection.loop.can.be.converted.to.arrayfind=迴圈可以轉換為 'array_find()' 呼叫
inspection.loop.can.be.converted.to.arrayfindkey=迴圈可以轉換為 'array_find_key()' 呼叫
inspection.loop.can.be.converted.to.arraymap=迴圈可以轉換為 'array_map()' 呼叫
inspection.magic.method.visibility.cannot.be.static=魔術方法 ''{0}'' 不能為 static
inspection.magic.method.visibility.must.be.public=魔術方法 ''{0}'' 必須為 public
inspection.magic.method.visibility.must.be.static=魔術方法 ''{0}'' 必須為 static
inspection.mess.detector.validation.inspection.display.name=PHP Mess Detector 驗證
inspection.message.0.extends.class.with.final.tag=''{0}'' 會擴展帶有 @final 標記的類別
inspection.message.0.overrides.method.with.final.tag=''{0}'' 會覆寫帶有 @final 標記的方法
inspection.message.absolute.method.reference.should.be.specified.for.insteadof.trait.use.rule=應為 'insteadof' 特徵 use 規則指定絕對方法參照
inspection.message.always.true=條件始終為 ''{0,choice,0\\#false|1\\#true}'
inspection.message.always.true.because=條件始終為 ''{0, choice, 0\\#false|1\\#true}''，因為此時 ''{1}'' 已經為 ''{2, choice, 0\\#false|1\\#true}''
inspection.message.always.true.because.evaluated=條件始終為 ''{0,choice,0\\#false|1\\#true}''，因為此時對 ''{1}'' 求值
inspection.message.argument.with.type.deprecated.for.this.call=類型為 ''{0}'' 的實參對此呼叫已棄用
inspection.message.argument.without.name.identifier=無名稱關鍵字的實參
inspection.message.array.always.empty.at.this.point=陣列在此點始終為空
inspection.message.array.index.immediately.rewritten.before.accessing=陣列索引在存取之前會被立即覆蓋
inspection.message.array.key.unused=陣列密鑰未使用
inspection.message.array.push.with.single.element=只有一個元素的 'array_push'
inspection.message.array.to.string.conversion=陣列到字串的轉換
inspection.message.array.traversable.can.be.replaced.with.iterable=類型提示 'array|Traversable' 可被取代為 'iterable'
inspection.message.array.values.call.redundant='array_values' 呼叫冗餘
inspection.message.array.write.access.unused=未使用陣列寫入存取
inspection.message.arrayshape.can.be.added=ArrayShape 可以新增
inspection.message.assert.always.will.be.false=實參類型不相容，因為 'assertTrue()' 執行與 'true' 的嚴格比較
inspection.message.assertion.always.true=斷言始終為 ''{0,choice,0\\#false|1\\#true}'
inspection.message.assertion.always.true.because=斷言始終為 ''{0, choice, 0\\#false|1\\#true}''，因為此時 ''{1}'' 已經為 ''{2, choice, 0\\#false|1\\#true}''
inspection.message.assertion.always.true.because.evaluated=斷言始終為 ''{0,choice,0\\#false|1\\#true}''，因為此時 ''{1}'' 已求值
inspection.message.attribute.can.t.be.applied.to.because.it.doest.contains=特性不能應用於 {0}，因為它不包含 ''{1}'' 標誌
inspection.message.attribute.is.not.repeatable=特性不可重複，因為它不包含 'Attribute\\:\\:IS_REPEATABLE' 標誌
inspection.message.behavior.unparenthesized.expressions.containing.both.will.change.in.php=同時包含 ''.'' 和 ''{0}'' 的無括號表達式可能會產生意外結果
inspection.message.branch.is.unused=從不執行 'switch' 分支
inspection.message.call.chain.too.long.to.analyse.break.it.into.fragments.up.to.calls=呼叫鏈過長，無法進行分析。請將其拆分為最多包含 {0} 個呼叫的片段
inspection.message.call.with.negative.width.deprecated=帶有負 'width' 實參的 'mb_strimwidth' 呼叫已棄用
inspection.message.call.with.two.arguments.deprecated=帶兩個實參的 ''{0}'' 呼叫已棄用
inspection.message.call.without.arguments.deprecated=不帶實參的 ''{0}'' 呼叫已棄用
inspection.message.calling.static.trait.member=直接呼叫 static 特徵成員已棄用。只應在使用特徵的類別上訪問。
inspection.message.can.be.final=可以為 'final'
inspection.message.can.be.merged.with=可以與 ''{0}'' 合併
inspection.message.can.be.removed=可以移除 ''{0}''
inspection.message.can.be.replaced.with=可被取代為 ''{0}''
inspection.message.can.be.replaced.with.assert.false=可被取代為 'assertFalse'
inspection.message.can.be.replaced.with.assert.true=可被取代為 'assertTrue'
inspection.message.can.be.replaced.with.const.syntax=可被取代為 'const' 語法
inspection.message.can.be.replaced.with.direct.parameter.access='func_get_arg' 可被取代為直接參數存取
inspection.message.can.be.replaced.with.fail=可被取代為 ''{0}''
inspection.message.can.be.replaced.with.in.array.call=可被取代為 ''{0}'' 呼叫
inspection.message.can.be.replaced.with.match.expression='if' 語句可被取代為 'match' 表達式
inspection.message.can.be.replaced.with.min.max.call=可被取代為 ''{0}'' 呼叫
inspection.message.can.be.replaced.with.named.argument=可被取代為命名實參
inspection.message.can.be.replaced.with.operator=可被取代為 '?->' 運算符
inspection.message.can.be.replaced.with.str.function=可被取代為 ''{0}''
inspection.message.can.be.replaced.with.version=表達式可被取代為 '??' 版本
inspection.message.cannot.assign.empty.string.to.string.offset=無法將空字串分配給字串偏移
inspection.message.cannot.create.references.to.from.string.offsets=無法建立到/從字串偏移的參照
inspection.message.cannot.increment.decrement.string.offsets=無法遞增/遞減字串偏移
inspection.message.cannot.make.method=無法將 {0} 方法設為 {1} {2}
inspection.message.cannot.make.method.visibility.lower.than.super.s=無法將方法的可見性設為低於父級的可見性
inspection.message.cannot.make.non.abstract.method.abstract=無法將非 abstract 方法設為 abstract
inspection.message.cannot.make.non.abstract.method.abstract.1=無法將非 abstract 方法 {0} 設為 abstract
inspection.message.cannot.make.non.static.method.static=無法將非 static 方法 {0} 設為 static
inspection.message.cannot.make.static.method.non.static=無法將 static 方法 {0} 設為非 static
inspection.message.cannot.override.final.method=無法覆寫 final 方法
inspection.message.cannot.override.final.method.1=無法覆寫 final 方法 {0}
inspection.message.cannot.override.final.property=無法覆寫 final 屬性
inspection.message.cannot.override.final.property.1=無法覆寫 final 屬性 ''{0}\\:\\:\${1}''
inspection.message.cannot.override.final.property.hook=無法覆寫 final 屬性掛鈎
inspection.message.cannot.override.final.property.hook.1=無法覆寫 final 屬性掛鈎 {0}
inspection.message.cannot.stub.or.mock.using.method.list.that.contains.duplicates=不能使用包含重複項的方法列表進行存根或模擬
inspection.message.cannot.unset.string.offsets=無法取消設定字串偏移
inspection.message.cannot.use.assign.op.operators.with.string.offsets=無法將組合運算符賦值與字串偏移一起使用
inspection.message.cannot.use.string.offset.as.array=無法將字串偏移用作陣列
inspection.message.cannot.use.string.offset.as.object=無法將字串偏移用作物件
inspection.message.cast.evaluable=轉換可被取代為 ''{0}''
inspection.message.cast.redundant=類型轉換冗餘
inspection.message.class.can.be.readonly=類別可以為 'readonly'
inspection.message.class.does.not.have.attribute=類別 ''{0}'' 未使用 ''Attribute'' 註解
inspection.message.class.may.inherit.from.final.class=類別可能無法繼承 final 類別
inspection.message.class.ref.marked.as.internal=類別 '\\#ref' 已標記為 @internal
inspection.message.classes.cannot.be.doubled=''{0}'' 類別無法重複
inspection.message.clone.method.cannot.be.static='Clone' 方法不能為 static
inspection.message.code.fragment.too.complex.to.parse.this.piece.code.will.be.treated.as.plain.text=程式碼段過於複雜，無法解析，因此將作為純文本處理
inspection.message.comment.can.be.replaced.with.named.argument=註釋可被取代為命名實參
inspection.message.comment.will.be.parsed.as.attribute.starting.with.php=從 PHP 8.0 起註釋被解析為特性
inspection.message.concatenation.can.be.merged.with.assignment.empty.string.literal=串聯可以與空字串字面量賦值合併
inspection.message.condition.is.never.matched=條件從未符合
inspection.message.constant.from.base.class.referenced.via.child.class=通過子類別參照的基類別 ''{0}'' 中的常數
inspection.message.constant.reassignment=常數重新賦值
inspection.message.constant.ref.marked.as.internal=常數 '\\#ref' 已標記為 @internal
inspection.message.constant.ref.not.found=未找到常數 '\\#ref'
inspection.message.constructor.cannot.be.static=建構函式不能為 static
inspection.message.continue.targeting.switch.equivalent.to.break=針對 'switch' 的 'continue' 相當於 'break'
inspection.message.control.flow.too.big.to.analyze=控制流太大，無法分析
inspection.message.count.used.as.array.index.to.append.element='count' 用作陣列索引以追加元素
inspection.message.dangerous.array.initialization=危險的陣列初始化
inspection.message.data.provider.method.should.be=資料提供程序方法應為 {0}
inspection.message.data.provider.method.should.not.require.arguments=資料提供程序方法不應需要實參
inspection.message.declaration.should.be.compatible.with=宣告應該與 {0} 相容
inspection.message.declaration.should.be.compatible.with.super=宣告應與父級相容
inspection.message.defining.custom.assert.function.deprecated=定義自定義 'assert()' 函式已棄用
inspection.message.defining.custom.assert.function.forbidden=禁止定義自定義 'assert()' 函式
inspection.message.deprecated.autoload.declaration='__autoload()' 宣告已棄用
inspection.message.destructor.cannot.be.static=解構函式不能為 static
inspection.message.doc.tag.without.variable.name.doesn.t.provide.type.information.for.any.expression=沒有變量名稱的 Doc 標記不提供任何表達式的類型資訊
inspection.message.double.quotes.are.unnecessary=雙引號不必要
inspection.message.duplicate.case.expression=重複 case 表達式
inspection.message.duplicate.case.expression.ref=重複 case 表達式\\: \\#ref
inspection.message.duplicate.character=重複字元
inspection.message.duplicates.catch.statement=重複 ''{0}'' 語句
inspection.message.element.already.covered.by=''{0}'' 已被 ''{1}'' 覆蓋
inspection.message.enum.field.reference.in.constant.expression.allowed.only.from.php=從 PHP 8.2 起才允許在常數表達式中參照枚舉欄位
inspection.message.exception.immediately.rethrown=立即重新拋出異常
inspection.message.exception.never.thrown.in.corresponding.try.block=相應的 ''try'' 塊中從未拋出異常 ''{0}''
inspection.message.existing.overriding.private.method.may.be.inaccessible=現有的覆寫 private 方法可能無法存取
inspection.message.existing.overriding.private.method.may.be.inaccessible.method=覆寫 private 方法 ''{0}'' 可能無法存取
inspection.message.exitpoint.attribute.can.be.added=可以新增 \\#[NoReturn] 特性
inspection.message.expression.always.choice=表達式始終為 ''{0}''
inspection.message.expression.have.duplicate.operand=表達式有重複的動作數 {0}
inspection.message.expression.not.changed.after.applying=套用 ''{0}'' 後，表達式不會改變
inspection.message.expression.without.parentheses=表達式沒有括號
inspection.message.extends.class.with.final.tag=擴展帶有 @final 標記的類別
inspection.message.field.assignment.can.be.converted.to.promoted.field=可以提升屬性
inspection.message.field.immediately.rewritten.before.accessing=屬性在存取之前會被立即覆蓋
inspection.message.field.ref.marked.as.internal=欄位 '\\#ref' 已標記為 @internal
inspection.message.for.loop.can.be.replaced.with.implode='foreach' 迴圈可被取代為 'implode()'
inspection.message.for.loop.can.be.replaced.with.str.repeat='for' 迴圈可被取代為 'str_repeat'
inspection.message.foreach.over.array.literal.with.single.element=對只有一個元素的陣列字面量執行 'foreach'
inspection.message.from.php.this.allowed={0}。從 PHP {1} 起才允許這樣。
inspection.message.function.deprecated.will.be.removed.in.phpunit=方法已棄用並已在 PHPUnit 10 中移除
inspection.message.function.deprecated.will.be.removed.in.phpunit.11=方法已棄用並已在 PHPUnit 11 中移除
inspection.message.function.may.produce.side.effects=函式可能會產生副作用
inspection.message.function.ref.marked.as.internal=函式 '\\#ref' 已標記為 @internal
inspection.message.generators.may.only.declare.return.type.generator.iterator.or.traversable.or.iterable.permitted=產生器只能宣告 ''Generator''、''Iterator''、''Traversable'' 或 ''iterable'' 的返回值類型，不允許 {0}
inspection.message.get.class.call.can.be.replaced.with.class.name.literal='get_class()' 呼叫可被取代為 '\\:\\:class'
inspection.message.getter.setter.can.be.replaced.property.hooks={0} 可被取代為 {1}
inspection.message.goto.labels.inside.loops.or.switch.statements.are.not.allowed=不允許在迴圈或 switch 語句中使用 'goto' 標籤
inspection.message.if.can.be.replaced.with.version='if' 可被取代為 '??' 版本
inspection.message.if.statement.with.common.parts=包含通用部分的 ''{0}'' 語句
inspection.message.illegal.array.offset.access=嘗試存取類型為 ''{0}'' 的值的陣列偏移
inspection.message.immutable.property.write.scope.does.not.allow.write.access.here=無效的不可變屬性寫入\\: 作用域 ''{0}'' 不允許在此處進行寫入存取
inspection.message.instanceof.checks.in.catch.can.be.replaced.with.specific.catches='catch' 塊中的 'instanceof' 檢查可被取代為特定的 catch
inspection.message.interpolated.string.dereferencing.available.in.php.only=從 PHP 8.0 起才允許插值字串解參照
inspection.message.key.element.cannot.be.reference=鍵元素不能為參照
inspection.message.leading.slash.in.constant.fqn.will.not.be.trimmed.by.php=PHP 不會修剪常數 FQN 中的前導斜杠
inspection.message.local.object.used.only.for.writing.properties=區域物件僅用於寫入屬性
inspection.message.loop.can.be.replaced.with.0=迴圈可被取代為 ''{0}()''
inspection.message.magic.constant.dereferencing.available.in.php.only=從 PHP 8.0 起才允許魔術常數解參照
inspection.message.match.can.be.replaced.with.switch='match' 表達式可轉換為 'switch' 語句。
inspection.message.match.can.be.replaced.with.switch.changing.semantics='match' 表達式可以轉換為 'switch' 語句。請注意，'switch' 語句依賴於鬆散比較，這可能會改變表達式語意。
inspection.message.match.can.be.replaced.with.ternary='match' 表達式可被取代為三元表達式
inspection.message.max.must.be.greater.than.or.equal.to.argument.min='max' 實參必須大於或等於 'min'
inspection.message.method.may.produce.side.effects=方法可能會產生副作用
inspection.message.method.ref.marked.as.internal=方法 '\\#ref' 已標記為 @internal
inspection.message.method.reference.resolves.to.method.with.containing.class=''Use'' 規則解析為包含類別 ''{0}'' 中的方法
inspection.message.methods.cannot.be.mocked=''{0}'' 方法無法模擬
inspection.message.multiple.isset.calls.can.be.combined.into.one=可將多個 'isset' 呼叫合併為一個
inspection.message.name.parameter.may.be.different.depending.on.instance.class=在 ''{0}.{1}'' 中可能未解析命名實參
inspection.message.named.argument.usage=命名實參用法
inspection.message.nested.call.can.be.unwrapped=嵌套的 ''{0}'' 呼叫可以解包
inspection.message.never.returning.function.must.not.return='never' 返回函式不得返回
inspection.message.non.readonly.class.cannot.extend.readonly.class=非 ''readonly'' 類別不能擴展 ''readonly'' 類別 ''{0}''
inspection.message.non.readonly.property.readonly=無法將非 'readonly' 屬性重新宣告為 'readonly'
inspection.message.not.valid.backing.value.for.enum={0} 不是枚舉的有效支援值
inspection.message.only.first.byte.will.be.assigned.to.string.offset=只有第一個位元組將被分配給字串偏移
inspection.message.only.variables.can.be.passed.by.reference=僅可通過參照傳遞變數
inspection.message.operands.have.incompatible.types=動作數具有不相容的類型
inspection.message.overrides.method.with.final.tag=覆寫帶有 @final 標記的方法
inspection.message.parameter.name.changed.from.to=參數名稱由 ''{0}'' 更改為 ''{1}''
inspection.message.parentheses.are.unnecessary=圓括號不必要
inspection.message.pointless.boolean.expression=可以簡化布爾表達式
inspection.message.primitive.types.can.t.be.used.as.instanceof.argument=僅物件或字串應用作 ''instanceof'' 實參，當前\\: ''{0}''
inspection.message.prohibited.autoload.declaration=禁止使用 '__autoload()' 宣告
inspection.message.promoted.field.usage=提升的屬性用法
inspection.message.property.can.be.readonly=屬性可以為 'readonly'
inspection.message.property.only.read.but.never.written=屬性只讀取，但從未寫入
inspection.message.property.only.written.but.never.read=屬性僅寫入，但從未讀取
inspection.message.psr.compound.namespace.with.depth.more.than.two.levels=PSR-12\\: 複合命名空間的深度超過兩級
inspection.message.psr.missing.parameter.list=PSR-12\\: 缺少參數列表
inspection.message.psr.missing.visibility.definition=PSR-12\\: 缺少可見性定義
inspection.message.psr.order.modifiers.incorrect=PSR-12\\: 修飾符的順序不正確
inspection.message.psr.short.form.type.keywords.should.be.used=PSR-12\\: 應當使用類型關鍵字的縮寫
inspection.message.psr.traits.must.be.included.one.per.line=PSR-12\\: 必須以每行一個的形式新增特徵
inspection.message.psr.usage.else.if.construct=PSR-12\\: 使用 'else if' 結構
inspection.message.psr.usage.var=PSR-12\\: 'var' 的用法
inspection.message.pure.can.be.added=可以新增 ''{0}''
inspection.message.qualified.name.can.t.contain.whitespaces=限定名稱不能包含空格
inspection.message.readonly.class.cannot.extend.non.readonly.class=''readonly'' 類別不能擴展非 ''readonly'' 類別 ''{0}''
inspection.message.readonly.modifier.redundant='readonly' 修飾符冗餘
inspection.message.readonly.property.non.readonly=無法將 'readonly' 屬性重新宣告為非 'readonly'
inspection.message.redundant.argument={0, choice, 0\\#實參|1\\#實參}{0,choice,0\\#符合|1\\#符合}{0, choice, 0\\#參數的|1\\#參數的}預設{0, choice, 0\\#值|1\\#值}
inspection.message.redundant.assignment=冗餘的提升屬性賦值
inspection.message.redundant.expression=冗餘表達式
inspection.message.redundant.method.override=方法覆寫冗餘
inspection.message.redundant.parenthesis=冗餘圓括號
inspection.message.redundant.static.in.final.class=final 類別中有冗餘的 'static'
inspection.message.remove.final.tag=移除 '@final' 標記
inspection.message.remove.final.tag.from.0=從 ''{0}'' PHPDoc 註釋中移除 ''@final'' 標記
inspection.message.replace.implicit.octal.literal.with.explicit.one=隱式八進制字面量可被取代為顯式八進制字面量
inspection.message.results.postfix.expression.unused=未使用後綴表達式的結果
inspection.message.return.type.declaration.must.be.compatible.with=返回值類型宣告必須與 {0} 相容\\: {1}
inspection.message.return.value.method.never.used=方法的返回值從未使用
inspection.message.returning.by.reference.from.void.function.deprecated=從 void 函式通過參照返回已棄用
inspection.message.second.write.to.readonly.property=無法修改 'readonly' 屬性
inspection.message.set.access.level.must.be.omitted=需要 'set' 的屬性不能是 'readonly'
inspection.message.should.be.one=值應為以下選項之一\\: {0}
inspection.message.should.probably.not.be.assigned=''{0}'' 可能不應分配給 ''{1}''
inspection.message.should.probably.not.be.passed.as.parameter=''{0}'' 可能不應作為參數 ''{1}'' 傳遞
inspection.message.spread.operator.can.be.unwrapped=展開運算符可以解包
inspection.message.spread.operator.over.literal.unnecessary.for.arguments.resolved.to.variadic.parameter=對於解析為可變參數的實參，字面量上的展開運算符不必要
inspection.message.statement.can.be.collapsed.into.parameter.default.value=語句可以摺疊到參數的預設值中
inspection.message.switch.can.be.replaced.with.match='switch' 語句無法轉換為 'match' 表達式
inspection.message.switch.has.only.default.case=switch 只有 'default' case
inspection.message.switch.has.only.single.case=switch 只有一個 case
inspection.message.too.many.messages.per.file.only.first.errors.warnings.are.shown=每個檔案中的訊息過多。僅顯示前 {0} 條。
inspection.message.too.many.messages.per.line=每行的訊息過多
inspection.message.tostring.method.must.return.string='__toString' 方法必須返回字串
inspection.message.trait.usage=不允許特徵用法
inspection.message.type.can.be.reduced.to=類型範圍可以限縮為 ''{0}''
inspection.message.type.mismatch.should.be.conditional.expression=類型不符合\\: 應為條件表達式
inspection.message.uncovered.enum.cases='match' 表達式具有未被覆蓋的 enum case
inspection.message.uncovered.enum.cases.switch='switch' 語句有未被覆蓋的枚舉 case
inspection.message.undefined.goto.label.ref=未定義的 goto 標籤 '\\#ref'
inspection.message.unnecessary.cast.to.string=不必要地轉換為 ''{0}''
inspection.message.unnecessary.curly.braces=不必要的大括號
inspection.message.unnecessary.else=不必要的 'else'
inspection.message.unnecessary.leading.slash=不必要的前導 ''
inspection.message.unused.private.property.ref=未使用的 private 屬性 '\\#ref'
inspection.message.use.statement.with.non.compound.name.ref.has.no.effect=包含非複合名稱 '\\#ref' 的 'use' 語句沒有任何作用
inspection.message.using.in.strings.deprecated.use.instead=在字串中使用 {0} 已棄用，請改用 {1}
inspection.message.using.variable.variables.in.strings.deprecated.use.instead=在字串中使用 {0} (可變變數)已棄用，請改用 {1}
inspection.message.value.parameter.always=參數值始終為 ''{0}''
inspection.message.value.ranges.mismatch.expected.actual=值範圍不符合。應為\\: {0}，實際為\\: {1}
inspection.message.var.export.with.return.argument.equals.false.always.returns.null=帶等於 ''false'' 的 ''return'' 實參的 ''{0}'' 始終返回 ''{1}''
inspection.message.var.export.without.return.argument.always.returns.null=不帶 ''return'' 實參的 ''{0}'' 始終返回 ''{1}''
inspection.message.variable.already.equal.to.assigned.value=變數已等於賦值
inspection.message.will.be.covered.by=非必要條件，因為它由 ''{0}'' 檢查
inspection.message.with.single.string.argument=帶單個字串實參的 ''{0}''
inspection.message.write.access.to.readonly.property.outside.declaration.scope=無法寫入宣告作用域之外的 'readonly' 屬性
inspection.message.write.access.to.readonly.property.outside.declaration.scope.ret.by.ref='readonly' 屬性通過參照返回，可能會泄漏到宣告作用域之外
inspection.message.write.access.to.variable.that.still.references.array.value=對仍參照 'foreach' 中先前所用陣列值的變數的寫入權限
inspection.method.does.not.override.super=方法未從其超類別覆寫方法
inspection.method.may.be.static=方法可以為 'static'
inspection.method.parameters.count.mismatch=為方法呼叫提供了 {0} 個參數，但方法簽名使用了 {1} 個參數
inspection.method.parameters.count.mismatch.option.ignore.func.get.arg=忽略帶有 func_get_arg/func_get_args 呼叫的函式/方法
inspection.method.parameters.count.mismatch.option.ignore.underscore=忽略最後一個參數為 $_ 的函式/方法
inspection.method.to.string.is.not.implemented=沒有為類別 ''{0}'' 實作方法 ''__toString''
inspection.method.to.string.is.not.implemented.strict.mode=檢查每種表達式類型是否存在 __toString
inspection.missing.break.statement.problem=缺少 'break' 語句
inspection.missing.class.constant.type=缺少類別常數類型
inspection.missing.doc.comment.options.panel.class=類別(&C)
inspection.missing.doc.comment.options.panel.class.constant=類別常數(&A)
inspection.missing.doc.comment.options.panel.constant=常數(&O)
inspection.missing.doc.comment.options.panel.field=屬性(&P)
inspection.missing.doc.comment.options.panel.function=函式(&F)
inspection.missing.doc.comment.options.panel.ignore.private.members=忽略 private 成員
inspection.missing.doc.comment.options.panel.method=方法(&M)
inspection.missing.doc.comment.problem=缺少 PHPDoc 註釋
inspection.missing.doc.comment.problem.batch={0} 缺少 PHPDoc 註釋
inspection.missing.ext.composer.json=composer.json 中缺少 ''{0}''
inspection.missing.ext.require.bundled=需要 PHP 捆綁的擴展
inspection.missing.field.type=缺少屬性的類型宣告
inspection.missing.parent.call.message=缺少父方法呼叫
inspection.missing.parent.constructor.call.message=缺少父建構函式呼叫
inspection.missing.strict.types.declaration=缺少嚴格類型宣告
inspection.missing.strict.types.declaration.add.declaration=新增嚴格類型宣告
inspection.missing_param=缺少所需參數 ''{0}''
inspection.mockery.protected.method.cannot.be.mocked=在不呼叫 'Mock.shouldAllowMockingProtectedMethods' 的情況下，無法對 'protected' 方法進行模擬
inspection.multiple.classes.declarations.in.one.file=在此檔案中宣告了另一個類別
inspection.naming.convention.element.description.class=類別
inspection.naming.convention.element.description.constant=常數
inspection.naming.convention.element.description.function=函式
inspection.naming.convention.element.description.method=方法
inspection.naming.convention.element.description.property=屬性
inspection.naming.convention.element.description.variable=變數
inspection.naming.convention.element.descriptor.regexp={0} 名稱 <code>\\#ref</code> 不符合正則表達式 ''{1}'' \\#loc
inspection.naming.convention.problem.descriptor.long={0} 名稱 <code>\\#ref</code> 過長({1} > {2}) \\#loc
inspection.naming.convention.problem.descriptor.short={0} 名稱 <code>\\#ref</code> 過短({1} < {2}) \\#loc
inspection.nested.ternary.expression=嵌套三元表達式自 PHP 7.4 已棄用
inspection.nested.vs.outer.foreach.variables.conflict.problem1=變數 ''{0}'' 作為鍵用於內部和外部 ''foreach'' 迴圈
inspection.nested.vs.outer.foreach.variables.conflict.problem2=變數 ''{0}'' 作為值用於內部和外部 ''foreach'' 迴圈
inspection.never.function.result.used.problem.type=從未
inspection.non.strict.object.equality=非嚴格物件相等比較
inspection.nullsafe.deref.unnecessary.because=Nullsafe 運算符{0,choice,0\\#將始終產生 ''null''|1\\#不必要}，因為此時 ''{1}'' 已經為 ''{2,choice,0\\#false|1\\#true}''
inspection.nullsafe.deref.unnecessary.because.evaluated=Nullsafe 運算符 ''{0,choice,0\\#將始終產生 ''null''|1\\#不必要}''，因為此時對 ''{1}'' 求值
inspection.option.label.php.severity=PHP {0} 嚴重性\\:
inspection.option.label.php73.severity=PHP 7.3 嚴重性\\:
inspection.option.label.php8.severity=PHP 8 嚴重性\\:
inspection.optional.before.required=可選參數在需要前提供
inspection.parentheses.around.new.call.can.be.omitted=可以省略 'new' 呼叫周圍的圓括號
inspection.php.CS.fixer.validation.inspection.display.name=PHP CS Fixer 驗證
inspection.php.CS.validation.inspection.display.name=PHP_CodeSniffer 驗證
inspection.php.abstract.static.method.description=PHP 嚴格標準\\: static 方法 '\\#ref' 不應為 abstract
inspection.php.abstract.static.method.inspection.display.name=static 函式不應為 abstract
inspection.php.accessed.array.is.always.empty=陣列在存取點始終為空
inspection.php.acessing.static.trait.members=正在存取 static 特徵成員
inspection.php.add.line.break.after.trailing.comma=在尾隨逗號後新增換行符
inspection.php.annotation.can.be.replaced.with.attribute={0} 註解可被取代為特性
inspection.php.annotation.must.be.replaced.with.attribute={0} 註解必須取代為特性
inspection.php.arg.trigger.error.is.deprecated=自 PHP 8.4 起，將 'E_USER_ERROR' 傳遞給 'trigger_error()' 已被棄用
inspection.php.argument.without.name.identifier=無名稱關鍵字的實參
inspection.php.arithmetic.type.check=帶有不支持動作數的算術運算
inspection.php.array.access.on.illegal.type.display.name=非法類型的陣列偏移存取
inspection.php.array.append.using.count=使用 'count()' 作為索引將值追加到陣列
inspection.php.array.fill.can.be.converted.to.loop.inspection.display.name='array_fill' 可以轉換為迴圈
inspection.php.array.filter.can.be.converted.to.loop.inspection.display.name='array_filter()' 呼叫可以轉換為迴圈
inspection.php.array.index.immediately.rewritten=陣列索引會被立即覆寫
inspection.php.array.key.does.not.match.array.shape=陣列鍵與陣列形狀不符合 
inspection.php.array.map.can.be.converted.to.loop.inspection.display.name='array_map()' 呼叫可以轉換為迴圈
inspection.php.array.push.with.single.element=只有一個元素的 'array_push()'
inspection.php.array.search.can.be.replaced.with.in.array='array_search()' 可被取代為 'in_array()' 呼叫
inspection.php.array.traversable.can.be.replaced.with.iterable=類型提示 'array|Traversable' 可被取代為 'iterable'
inspection.php.array.used.only.for.write.inspection.display.name=陣列僅用於寫存取
inspection.php.array.write.access.is.not.used=未使用陣列寫入存取
inspection.php.assert.declaration.is.deprecated=已棄用的 'assert()' 函式宣告
inspection.php.assignment.in.condition.inspection.display.name=條件中的賦值
inspection.php.assignment.replaceable.with.operator.assignment.inspection.display.name=賦值可被取代為運算符賦值
inspection.php.assignment.replaceable.with.prefix.expression.inspection.display.name=賦值可被取代為增量或減量
inspection.php.attribute.array.shape.can.be.added=可以新增 '\\#[ArrayShape]' 特性
inspection.php.attribute.can.be.overridden=可以將特性新增到覆寫成員
inspection.php.attribute.is.not.repeatable=不可重複的特性
inspection.php.attribute.no.return.can.be.added=可以新增 NoReturn 特性
inspection.php.autoload.declaration.is.deprecated=已棄用的 '__autoload()' 函式宣告
inspection.php.autovivification.on.false.values='false' 到陣列的自動轉換已棄用
inspection.php.autovivification.on.false.values.possible=可能會導致將 'false' 轉換為數組，這一轉換已棄用
inspection.php.backed.property.with.set.hook.cant.be.accessed.by.ref.key=帶有 'set' 掛鈎的備用屬性無法通過參照存取
inspection.php.boolean.expression.can.be.simplified=可以簡化布爾表達式
inspection.php.cannot.apply.to.multiple.constants=無法同時將特性應用於多個常數
inspection.php.cannot.define.the.same.hooked.property={0} 和 {1} 在組合中定義相同的掛鈎屬性。目前不支持掛鈎屬性之間的衝突解決。
inspection.php.cast.is.evaluable=對標量值進行類型轉換
inspection.php.cast.is.unnecessary=類型轉換不必要
inspection.php.class.cant.be.used.as.attribute=類別不能用作特性
inspection.php.class.constant.accessed.via.child.class=通過子類別參照的類別常數
inspection.php.class.constant.can.be.final=類別常數可以為 'final'
inspection.php.class.implements.solely.traversable.inspection.display.name=類別無法直接實作 Traversable
inspection.php.class.naming.convention.inspection.display.name=類別名未遵循編碼約定
inspection.php.class.static.member.accessed.via.instance.inspection.display.name=通過實例存取的類別 static 成員
inspection.php.clone.can.be.replaced.with.clone.with='clone' 可以取代為 'clone with'
inspection.php.closure.can.be.converted.to.first.class.callable.inspection.display.name='Closure\\:\\:fromCallable()' 可以轉換為一級可調用語法
inspection.php.closure.can.be.converted.to.short.arrow.function.inspection.display.name=閉包可以轉換為箭頭函式
inspection.php.comment.will.be.parsed.as.attribute=在 PHP 8.0 中註釋被解析為特性
inspection.php.composer.duplicated.requirement.inspection.display.name=composer.json 中存在重複的軟體套件條目
inspection.php.composer.extension.stubs.inspection.display.name=composer.json 中缺少擴展
inspection.php.compound.namespace.depth.inspection.display.name=複合命名空間深度大於 2
inspection.php.concatenation.with.arithmetic.usage=具有算術用法的串聯
inspection.php.concatenation.with.empty.string.can.be.merged=空字串的串聯可以與賦值合併
inspection.php.condition.always.evaluates.to.constant=條件的求值結果始終為 'true/false'
inspection.php.condition.can.be.replaced.with.min.max.call=條件可被取代為 'min()'/'max()' 呼叫
inspection.php.condition.checked.by.next.condition=邏輯表達式內部的條件由後續條件檢查
inspection.php.constant.naming.convention.inspection.display.name=常數名稱未遵循編碼約定
inspection.php.constant.reassignment.inspection.display.name=常數重新賦值
inspection.php.constructor.style.inspection.display.name=舊式建構函式
inspection.php.continue.targeting.switch='continue' 針對 'switch' 語句
inspection.php.covered.element.in.class=類別中的元素已被覆蓋
inspection.php.curly.brace.access.syntax.usage.inspection.display.name=使用了大括號存取語法
inspection.php.declaration.must.be.compatible.with.parent=宣告必須與父級相容並通過參照返回
inspection.php.define.constant.can.be.replaced.with.const.syntax=define 常數名稱可被取代為 'const' 語法
inspection.php.define.constant.name.with.leading.slash=使用前導斜杠定義的常數名稱
inspection.php.delete.redundant.isset.calls=刪除冗餘的 'isset' 呼叫
inspection.php.deprecated.cast.inspection.display.name=棄用的轉換
inspection.php.deprecated.dollar.brace.string.interpolation=已棄用的 '\${' 字串內插
inspection.php.deprecated.implode.usage.inspection.display.name=棄用的 'implode/join' 用法
inspection.php.deprecated.modifier=自 PHP {1} 起修飾符 ''{0}'' 已棄用
inspection.php.deprecated.partially.supported.callables.display.name=已棄用的部分支援可呼叫物件
inspection.php.deprecated.serializable.interface.usage.inspection.display.name=已棄用的 'Serializable' 接口用法
inspection.php.deprecated.stdlib.call=已棄用的標準庫呼叫
inspection.php.deprecation.inspection.display.name=已棄用
inspection.php.disabled.extension.stubs.description=已停用的 ''{0}'' 擴展存根
inspection.php.disabled.extension.stubs.inspection.display.name=已停用的擴展存根
inspection.php.disabled.quality.tool.composer.inspection.display.name=品質工具檢查已停用
inspection.php.division.by.zero.inspection.display.name=除以零
inspection.php.doc.duplicate.type.inspection.display.name=類型已存在於 PHPDoc 標記中
inspection.php.doc.field.type.mismatch.inspection.display.name=類型與屬性的宣告類型不符合
inspection.php.doc.is.not.complete.inspection.display.name=PHPDoc 註釋簽名不完整
inspection.php.doc.missing.throws.inspection.display.name=缺少 @throws 標記
inspection.php.doc.redundant.throws.inspection.display.name=冗餘 @throws 標記
inspection.php.doc.signature.description=重複的實參 PHPDoc
inspection.php.doc.signature.description2=返回值類型與宣告的不符合
inspection.php.doc.signature.description3=不存在實參的 PHPDoc
inspection.php.doc.signature.description5=實參類型與宣告的不符合
inspection.php.doc.signature.inspection.display.name=PHPDoc 註釋符合函式/方法簽名
inspection.php.doctrine.annotation.can.be.replaced.with.attribute=Doctrine 註解可被取代為特性
inspection.php.dql.builder.unknown.model=無法推斷 DQL 模型類別以啟用補全
inspection.php.dql.builder.unknown.model.quickfix.family.name=新增帶有模型類別類型的 PHPDoc
inspection.php.dql.builder.unknown.model.quickfix.name=新增帶有模型類別類型的 PHPDoc
inspection.php.duplicate.case.inspection.display.name=switch 語句中存在重複的 case
inspection.php.duplicate.character.in.str.function.call=函式呼叫中的重複字元
inspection.php.duplicate.match.arm.body.inspection.display.name='match' 表達式中的重複 arm
inspection.php.duplicate.match.condition.inspection.display.name=重複條件
inspection.php.duplicate.operand.in.comparison=比較中的重複動作數
inspection.php.duplicate.switch.case.body.inspection.display.name=switch 語句中存在重複分支
inspection.php.duplicate.switch.catch.body.inspection.display.name='catch' 語句中的重複分支
inspection.php.dynamic.as.static.method.call.inspection.display.name=動態方法被呼叫為 static
inspection.php.dynamic.field.declaration=動態屬性宣告
inspection.php.element.is.not.available.in.current.php.version.inspection.display.name=元素在組態的 PHP 版本中不可用
inspection.php.empty.index.operator.not.supported.for.strings=字串不支持 '[]' 運算符
inspection.php.empty.index.operator.not.supported.for.strings.display.name=字串不支持的空索引運算符
inspection.php.enforce.doc.comment.inspection.display.name=強制執行 PHPDoc 註釋
inspection.php.enum.case.with.value.not.found=枚舉中找不到包含指定值的 case
inspection.php.exception.is.immediately.rethrown=立即重新拋出異常
inspection.php.expected.values.should.be.used=應使用預期值
inspection.php.expression.always.constant.inspection.display.name=到達時，變數始終為 true/false
inspection.php.expression.always.null.description='\\#ref' 始終為 'null'
inspection.php.expression.always.null.inspection.display.name=表達式始終為 'null'
inspection.php.expression.result.unused.inspection.display.name=未使用表達式結果
inspection.php.expression.with.same.operands.inspection.display.name=邏輯表達式有相同動作數
inspection.php.expression.without.clarifying.parentheses.inspection.display.name=表達式不帶澄清括號
inspection.php.field.assignment.type.mismatch.inspection.display.name=屬性賦值中的類型不符合
inspection.php.field.immediately.rewritten=屬性會被立即覆寫
inspection.php.field.reference.does.not.match.object.shape=欄位參照與物件形狀不符合
inspection.php.foreach.array.is.used.as.value.inspection.display.name=Foreach 陣列用作值
inspection.php.foreach.nested.outer.key.value.variables.conflict.inspection.display.name=嵌套與外部 'foreach' 變數衝突
inspection.php.foreach.over.single.element=對只有一個元素的陣列字面量執行 Foreach
inspection.php.foreach.variable.overwrite.already.defined.variable='foreach' 變數覆寫已定義的變數
inspection.php.format.function.call.with.single.argument=使用單個實參格式化函式呼叫
inspection.php.format.function.parameters.mismatch.inspection.display.name=格式函式參數不符合
inspection.php.fully.qualified.name.usage.inspection.display.name=使用了完全限定名稱
inspection.php.func.get.arg.can.be.replaced.with.parameter.access='func_get_arg()' 呼叫可被取代為參數存取
inspection.php.function.naming.convention.inspection.display.name=函式名稱未遵循編碼約定
inspection.php.get.class.can.be.replaced.with.class.name.literal.inspection.display.name='get_class()' 呼叫可被取代為 '\\:\\:class'
inspection.php.get.hook.of.backed.property.with.set.hook.may.not.return.by.reference=如果定義了 'set' 掛鈎，無法通過 '\\\\&get' 返回備用屬性
inspection.php.goto.into.loop.inspection.display.name=Goto 轉入迴圈語句
inspection.php.group.attributes=特性
inspection.php.group.code.smell=程式碼異味
inspection.php.group.code.style=程式碼樣式
inspection.php.group.composer=Composer
inspection.php.group.control.flow=控制流
inspection.php.group.error.handling=錯誤處理
inspection.php.group.general=一般
inspection.php.group.naming.conventions=命名約定
inspection.php.group.phpdoc=PHPDoc
inspection.php.group.phpunit=PHPUnit
inspection.php.group.probable.bugs=可能的 bug
inspection.php.group.psr.12=PSR-12
inspection.php.group.quality.tools=品質工具
inspection.php.group.regexp=正則表達式
inspection.php.group.replacable.assignments=可取代賦值
inspection.php.group.strict.standards=PHP 嚴格標準
inspection.php.group.type.compatibility=類型相容性
inspection.php.group.undefined=未定義的符號
inspection.php.group.unused=未使用的符號
inspection.php.highlight.only.closures.with.multiple.statements.option=僅醒目提示包含多條語句的閉包
inspection.php.hooked.property.cant.be.unset=掛鈎屬性不能取消設定
inspection.php.idempotent.operation=二元表達式中的冪等運算
inspection.php.if.can.be.merged.with.sequential.condition='if' 可以與後續條件合併
inspection.php.if.can.be.replaced.with.match.expression='if' 可被取代為 'match' 表達式
inspection.php.ignored.class.alias.declaration.display.name=忽略的類別名聲明
inspection.php.illegal.array.key.type.description={0} {1}
inspection.php.illegal.array.key.type.inspection.display.name=非法陣列鍵類型
inspection.php.illegal.psr.class.path.inspection.display.name=類別路徑與專案結構不符合
inspection.php.illegal.string.offset.inspection.display.name=非法字串偏移
inspection.php.immutable.property.is.written.in.invalid.scope=在無效的作用域中寫入不可變屬性
inspection.php.implicit.octal.literal.can.be.replaced.with.explicit.one=隱式八進制字面量可被取代為顯式八進制字面量
inspection.php.implicitly.marking.parameter.as.nullable.is.deprecated=將參數隱式標記為可為 null 已被棄用
inspection.php.in.array.can.be.replaced.with.comparison='in_array' 可被取代為比較
inspection.php.inapplicable.attribute.target.declaration=不適用的特性目標宣告
inspection.php.inappropriate.inherit.doc.usage.class.description=@inheritDoc 用於沒有帶 doc 註釋的父類別的類別
inspection.php.inappropriate.inherit.doc.usage.description=@inheritDoc 用於沒有父級成員但含有 doc 註釋的成員
inspection.php.inappropriate.inherit.doc.usage.description2=@inheritDoc 應僅用於類別成員
inspection.php.inappropriate.inherit.doc.usage.inspection.display.name=使用了不當的 @inheritDoc
inspection.php.include.description=無法解析表達式 ''{0}'' 的目標
inspection.php.include.description2=未找到路徑 ''{0}''
inspection.php.include.inspection.display.name=未解析的 include
inspection.php.incompatible.return.type.inspection.display.name=返回值類型不相容
inspection.php.incomplete.array.shape.implementation=根據形狀宣告，陣列不完整。缺少鍵\\: {0}
inspection.php.inconsistent.return.points.inspection.display.name=不一致的返回點
inspection.php.incorrect.magic.method.signature.inspection.display.name=魔術方法簽名不正確
inspection.php.indirect.modification.on.property.is.not.allowed=不允許間接修改屬性
inspection.php.indirect.modification.on.property.potential=潛在禁止的間接屬性修改
inspection.php.instanceof.checks.in.catch.can.be.replaced.with.specific.catches='catch' 塊中的 'instanceof' 檢查可被取代為特定的 catch
inspection.php.instanceof.is.always.true='instanceof' 的結果始終為 'true'
inspection.php.int.ranges.mismatch=數字範圍不符合
inspection.php.internal.array.index.reset.is.unnecessary=無需陣列內部指針重設
inspection.php.internal.array.index.reset.is.unnecessary.navigate.to.function=導覽到重設陣列內部指針的函式
inspection.php.internal.entity.used.inspection.display.name=使用了內部實體
inspection.php.invalid.delimiter.key=無效分隔符
inspection.php.invalid.function.result.used.inspection.display.name=使用了無效的函式結果
inspection.php.invalid.instanceof.argument.type='instanceof' 的實參只應是物件或字串
inspection.php.invalid.magic.method.modifiers.inspection.display.name=魔術方法修飾符無效
inspection.php.invalid.string.offset.usage=字串偏移用法無效
inspection.php.isset.can.be.replaced.with.coalesce='isset' 可被取代為合併
inspection.php.isset.can.check.nested.access.directly='isset' 可以直接檢查嵌套存取
inspection.php.isset.can.check.nested.array.access.subproperties.directly='isset' 可以直接檢查嵌套陣列存取和子屬性
inspection.php.language.level.description='fn' 是 PHP 7.4 中的保留關鍵字
inspection.php.language.level.inspection.display.name=語言級別
inspection.php.laravel.pint.inspection.display.name=Laravel Pint 驗證
inspection.php.long.type.form.inspection.display.name=類型關鍵字的縮寫
inspection.php.loop.can.be.converted.to.array.fill.inspection.display.name=迴圈可以轉換為 'array_fill()' 呼叫
inspection.php.loop.can.be.converted.to.array.filter.inspection.display.name=迴圈可以轉換為 'array_filter()' 呼叫
inspection.php.loop.can.be.converted.to.array.map.inspection.display.name=迴圈可以轉換為 'array_map()' 呼叫
inspection.php.loop.can.be.replaced.with.implode=迴圈可被取代為 'implode()'
inspection.php.loop.can.be.replaced.with.in.array=迴圈可被取代為 'in_array()' 或 'array_key_exists()' 呼叫
inspection.php.loop.can.be.replaced.with.str.repeat=迴圈可被取代為 'str_repeat'
inspection.php.loop.never.iterates=''{0}'' 語句不迴圈
inspection.php.loop.never.iterates.name=迴圈未迭代
inspection.php.match.can.be.replaced.with.switch.statement='match' 可被取代為 'switch' 語句
inspection.php.match.expression.can.be.replaced.with.ternary='match' 表達式可被取代為三元表達式
inspection.php.method.may.be.static.inspection.display.name=方法可以為 'static'
inspection.php.method.naming.convention.inspection.display.name=方法名稱未遵循編碼約定
inspection.php.method.or.class.call.is.not.case.sensitive.inspection.display.name=方法呼叫或類別用法中的大小寫不符合
inspection.php.method.parameters.count.mismatch.inspection.display.name=參數數量與宣告不符合
inspection.php.method.return.value.is.never.used=方法的返回值從未使用
inspection.php.missing.break.statement.inspection.display.name=缺少 'break' 語句
inspection.php.missing.doc.comment.inspection.display.name=缺少 PHPDoc 註釋
inspection.php.missing.field.type.inspection.display.name=缺少屬性的類型宣告
inspection.php.missing.param.type.description=缺少參數的類型宣告
inspection.php.missing.parameter.type.inspection.display.name=缺少參數的類型宣告
inspection.php.missing.parent.call.common.inspection.display.name=方法缺少父呼叫
inspection.php.missing.parent.call.magic.inspection.display.name=魔術方法缺少父呼叫
inspection.php.missing.parent.constructor.inspection.display.name=建構函式缺少父呼叫
inspection.php.missing.return.type.description=缺少函式的返回值類型宣告
inspection.php.missing.return.type.inspection.display.name=缺少返回值類型宣告
inspection.php.missing.strict.types.declaration.inspection.display.name=缺少嚴格類型宣告
inspection.php.missing.visibility.inspection.display.name=缺少可見性
inspection.php.mixed.return.type.can.be.reduced=可以限縮 'mixed' 返回值類型的範圍
inspection.php.mockery.invalid.mocking.target=無效的 Mockery 模擬目標
inspection.php.modifier.order.inspection.display.name=修飾符順序
inspection.php.modulo.operation.with.one=以 '1' 為動作數的取模運算
inspection.php.move.variable.inside.closure=在閉包內移動變數賦值
inspection.php.multiple.class.declarations.inspection.display.name=多個類別宣告
inspection.php.multiple.classes.declarations.in.one.file.display.name=一個檔案中有多個類別宣告
inspection.php.multiple.isset.calls.can.be.replaced.with.one=可將多個 'isset' 呼叫取代為一個
inspection.php.name.variable.is.used.only.inside.closure=變數僅在閉包內使用
inspection.php.named.argument.may.be.unresolved=命名實參可能未解析
inspection.php.named.argument.usage=有名稱關鍵字的實參
inspection.php.named.arguments.with.changed.order=命名實參順序與參數順序不符合
inspection.php.navigate.to.variable.assignment=導覽到變數賦值
inspection.php.nested.dirname.call.can.be.replaced.with.levels.usage=嵌套的 'dirname()' 呼叫可被取代為 'levels' 參數用法
inspection.php.nested.min.max.call=嵌套的 'min/max' 呼叫
inspection.php.nested.ternary.expression.usage.inspection.display.name=使用了嵌套的三元運算符
inspection.php.never.typed.function.returning.value='never' 類型的函式返回一個值
inspection.php.new.class.missing.parameter.list.inspection.display.name=缺少參數列表
inspection.php.non.canonical.elements.order.description=變數及其類型以非規範順序列出
inspection.php.non.canonical.elements.order.inspection.display.name=元素的非規範順序
inspection.php.non.compound.use.inspection.display.name=不必要的語句使用
inspection.php.non.strict.object.equality.inspection.display.name=非嚴格物件相等
inspection.php.not.installed.packages.inspection.display.name=未安裝的 Composer 軟體套件
inspection.php.null.is.not.compatible.with.parameter='null' 與參數的宣告類型不相容
inspection.php.null.safe.operator.can.be.used=可以使用 Nullsafe 運算符 '?->'
inspection.php.object.fields.are.only.written=區域物件僅用於寫入屬性
inspection.php.object.shape.can.be.added=ObjectShape 可以新增
inspection.php.open.echo.tag.inspection.display.name=開啟 'echo' 標記用法
inspection.php.optional.before.required.parameters.inspection.display.name=可選參數在必選參數之前
inspection.php.overriding.method.extending.class.marked.as.final=被標記為 '@final' 的覆寫方法/擴展類別
inspection.php.overriding.method.visibility.inspection.display.name=方法可見性不應被覆寫
inspection.php.parameter.always.have.same.value=參數值始終相同
inspection.php.parameter.by.ref.is.not.used.as.reference.inspection.display.name=不必要的通過參照傳遞
inspection.php.parameter.name.chaged.during.inhertiance=在繼承期間更改了參數名稱
inspection.php.params.inspection.display.name=參數類型
inspection.php.pass.by.ref.description=僅變數可通過參照返回
inspection.php.pass.by.ref.inspection.display.name=通過參照傳遞參數
inspection.php.passing.0.dba.key.split.is.deprecated=自 PHP 8.4 起，將 ''{0}'' 傳遞給 ''dba_key_split()'' 已被棄用
inspection.php.passing.0.type.1.is.deprecated=自 PHP 8.4 起，傳遞除 ''{1}'' 之外的其他類型的 ''{0}'' 已被棄用
inspection.php.passing.non.callable.string.is.deprecated=自 PHP 8.4 版起，將不可呼叫字串傳遞給 'xml_set_*_handler()' 函式已被棄用
inspection.php.passing.non.empty.enclosure.to.csv.function.is.deprecated=自 PHP 8.4 起，為 '$escape' 參數傳遞非空字串已被棄用
inspection.php.passing.null.or.false.dba.key.split.is.deprecated=自 PHP 8.4 起，將 'null' 或 'false' 傳遞給 'dba_key_split()' 已被棄用
inspection.php.passing.option.type.is.deprecated=自 PHP 8.4 起，傳遞錯誤類型的選項已被棄用
inspection.php.plural.mixed.can.be.replaced.with.array='mixed' 類型可被取代為 'array'
inspection.php.pointless.boolean.expression='if' 條件內的無意義布爾表達式
inspection.php.possible.polymorphic.invocation.inspection.display.name=可能的多態呼叫
inspection.php.pow.call.can.be.replace.with.pow.operator='pow()' 呼叫可被取代為 '**' 運算符
inspection.php.preg.match.can.be.replaced.with.comparison='preg_match()' 可被取代為比較
inspection.php.preg.match.redundant.closure=冗餘閉包 '.*'
inspection.php.preg.match.without.regular.expression='preg_match' 可被取代為 'str_contains'
inspection.php.preg.replace.with.empty.replacement.name='preg_replace()' 可被取代為 '(l|r)trim' 呼叫
inspection.php.preg.split.can.be.replaced.with.explode='preg_split' 可被取代為 'explode'
inspection.php.private.field.can.be.local.variable.description=屬性可被取代為區域變數
inspection.php.private.field.can.be.local.variable.inspection.display.name=private 屬性可為區域
inspection.php.private.method.may.be.inaccessible.in.late.static.binding.call=在延遲 static 綁定呼叫期間可能無法存取 private 方法
inspection.php.promoted.field.usage=提升的屬性用法
inspection.php.property.can.be.promoted.with.private.set.modifier=可以使用 'private(set)' 可見性修飾符提升屬性
inspection.php.property.can.be.readonly=屬性可以為 'readonly'
inspection.php.property.can.be.replaced.with.private.set.modifier=屬性可以取代為 'private(set)' 可見性修飾符
inspection.php.property.naming.convention.inspection.display.name=屬性名稱未遵循編碼約定
inspection.php.property.only.written=屬性用法具有相同的存取權限
inspection.php.property.without.set.hook.can.be.replaced.with.private.set.visibility.modifier=沒有 'set' 掛鈎的屬性可以取代為 'private(set)' 可見性修飾符
inspection.php.psalm=Psalm
inspection.php.pure.contract.attribute.can.be.added=可以新增 '\\#[Pure]' 特性
inspection.php.pure.function.may.produce.side.effect=純函式可能會產生副作用
inspection.php.raising.zero.to.the.power.of.negative.number.is.deprecated=自 PHP 8.4 起，0 的負數次冪已被棄用。
inspection.php.rand.arguments.in.revers.order=順序錯誤的 'rand' 函式實參
inspection.php.ranges.in.class.can.re.merged=類別中的範圍可以合併
inspection.php.redeclaration.stdlib.function=標準庫函數的重複宣告
inspection.php.redeclaration.stdlib.function.description=不能重複宣告標準庫函數 ''{0}''
inspection.php.redundant.array.call.in.foreach.iterated.value=對 'foreach' 中迭代的值的冗餘 'array_values' 呼叫
inspection.php.redundant.assignment.to.promoted.field=冗餘的提升屬性賦值
inspection.php.redundant.attribute.parenthesis=特性中的冗餘圓括號
inspection.php.redundant.catch.clause.inspection.display.name=冗餘 catch 子句
inspection.php.redundant.closing.tag.inspection.display.name=冗餘結束標記
inspection.php.redundant.continue.break.argument=冗餘的 'continue/break' 實參
inspection.php.redundant.doc.comment.inspection.display.name=冗餘 PHPDoc 註釋
inspection.php.redundant.match.expression='match' 表達式只有 default arm，應當進行簡化
inspection.php.redundant.method.override=冗餘方法覆寫
inspection.php.redundant.modifier=冗餘的 ''{0}'' 修飾符
inspection.php.redundant.modifier.key=冗餘修飾符
inspection.php.redundant.optional.argument=冗餘的可選實參
inspection.php.redundant.type.in.union.type=類型宣告冗餘，可以簡化
inspection.php.redundant.type.in.union.type.fix.name=簡化冗餘類型
inspection.php.redundant.type.in.union.type.template=類型宣告可以簡化為 ''{0}''
inspection.php.redundant.variable.doc.type.description=@var 標記指定了已從原始碼推斷出的類型
inspection.php.redundant.variable.doc.type.inspection.display.name=冗餘 @var 標記
inspection.php.regexp.delimiter.is.alphanumeric.or.backslash=分隔符是字母數字或反斜杠
inspection.php.regexp.delimiter.is.used.in.reg.exp=在正則表達式中使用了分隔符
inspection.php.regexp.n.modifier.can.be.replaced.with.non.capturing.groups='n' 修飾符可被取代為非捕獲組
inspection.php.regexp.replace.n.modifier.with.non.capturing.groups=將 'n' 修飾符取代為非捕獲組
inspection.php.regexp.replace.with.valid.delimiter=取代為有效分隔符
inspection.php.remove.modifier=移除修飾符 ''{0}''
inspection.php.remove.useless.trailing.comma=移除無用的尾隨逗號
inspection.php.replace.annotation.with.attribute=將註解取代為特性
inspection.php.return.doc.type.mismatch=PHPDoc 中的返回值類型與實際返回值類型不符合
inspection.php.return.doc.type.mismatch.inspection.display.name=PHPDoc 註釋中的返回值類型與實際返回值類型不符合
inspection.php.second.write.to.readonly.property=第二次寫入 'readonly' 屬性
inspection.php.separate.else.if.inspection.display.name=Else if
inspection.php.short.echo.open.tag.description=短 echo 起始標記用法
inspection.php.short.open.echo.tag.inspection.display.name=短起始 'echo' 標記用法
inspection.php.short.open.tag.description=使用了短起始標記
inspection.php.short.open.tag.inspection.display.name=使用了短起始標記
inspection.php.signature.mismatch.during.inheritance.inspection.display.name=覆寫方法的宣告應與父類別相容
inspection.php.silly.assignment.inspection.display.name=冗餘賦值
inspection.php.single.statement.with.braces.inspection.display.name=單語句主體帶大括號
inspection.php.statement.has.empty.body.description=語句具有空體
inspection.php.statement.has.empty.body.inspection.display.name=語句具有空體
inspection.php.statement.without.braces.inspection.display.name=控制語句主體無大括號
inspection.php.static.as.dynamic.method.call.inspection.display.name=static 方法被呼叫為動態
inspection.php.str.functions.inspection.display.name='str*()' 呼叫可被取代為 PHP 8 'str_*()' 呼叫
inspection.php.strict.comparison.of.operands.with.different.types=嚴格比較類型不相容的動作數
inspection.php.strict.type.checking.inspection.display.name=嚴格類型檢查規則違反
inspection.php.super.class.incompatible.with.interface.inspection.display.name=父類別的方法宣告與實作的接口不相容
inspection.php.suspicious.name.combination.inspection.name=可疑名稱組合
inspection.php.switch.can.be.replaced.with.match.expression='switch' 可被取代為 'match' 表達式
inspection.php.switch.case.without.default.branch.inspection.display.name=switch 語句沒有 default 分支
inspection.php.symfony.annotation.can.be.replaced.with.attribute=Symfony 註解可被取代為特性
inspection.php.ternary.expression.can.be.replaced.with.condition.inspection.display.name=三元表達式可被取代為條件
inspection.php.ternary.expression.can.be.replaced.with.short.version=三元表達式可被取代為短版本
inspection.php.throwable.not.thrown.inspection.display.name=未拋出 Throwable
inspection.php.to.string.implementation.inspection.display.name=方法 '__toString' 實作
inspection.php.to.string.may.produce.exception='__toString' 可能會拋出異常
inspection.php.to.string.return.inspection.display.name=方法 '__toString' 返回值類型
inspection.php.too.long.member.reference.chain=成員參照鏈過長，無法分析
inspection.php.too.many.parameters.inspection.display.name=函式宣告中的參數過多
inspection.php.traditional.syntax.array.literal.inspection.display.name=檢測到傳統語法陣列字面量
inspection.php.trait.method.use.is.located.inside.different.target.class=特徵 use 規則已解析為使用不同包含類別的方法 
inspection.php.trait.usage=不允許特徵用法
inspection.php.traits.use.list.inspection.display.name=每行一個特徵 use
inspection.php.tried.to.read.from.virtual.property.without.getter=無法從未定義 getter 的 virtual 屬性中讀取
inspection.php.tried.to.write.to.virtual.property.without.setter=無法向未定義 setter 的 virtual 屬性寫入
inspection.php.type.tag.without.variable.name=不帶變數名稱的類型標記
inspection.php.typed.property.might.be.uninitialized.inspection.display.name=類型化屬性可能未初始化
inspection.php.typed.property.might.be.uninitialized.inspection.problem=類型化屬性 ''{0}'' 可能未初始化
inspection.php.uncovered.enum.cases=某些 enum case 未被覆蓋
inspection.php.undefined.callback.inspection.display.name=未定義的回調
inspection.php.undefined.class.constant.inspection.display.name=未定義的類別常數
inspection.php.undefined.class.description=類別 '\\#ref' 存在多個定義
inspection.php.undefined.class.description2=未定義的類別 '\\#ref'
inspection.php.undefined.class.description5=存在類別 '\\#ref' 的其他宣告
inspection.php.undefined.class.inspection.display.name=未定義的類別
inspection.php.undefined.class.other.declaration.exists={0} 處存在類別 ''\\#ref'' 的其他宣告
inspection.php.undefined.class.other.declaration.exists.and={0} 和另 {1} 處存在類別 ''\\#ref'' 的其他宣告
inspection.php.undefined.constant.inspection.display.name=未定義的常數
inspection.php.undefined.field.inspection.display.name=未定義的屬性
inspection.php.undefined.function.inspection.display.name=未定義的函式
inspection.php.undefined.goto.label.inspection.display.name=未定義的 goto 標籤
inspection.php.undefined.method.inspection.display.name=未定義的方法
inspection.php.undefined.namespace.description=未定義的命名空間 '\\#ref'
inspection.php.undefined.namespace.inspection.display.name=未定義的命名空間
inspection.php.undefined.variable.inspection.display.name=未定義的變數
inspection.php.underscore.as.class.name.is.deprecated=自 PHP 8.4 起，使用單下劃線 '_' 作為類別名已被棄用
inspection.php.unhandled.exception.inspection.display.name=未處理的異常
inspection.php.unit.annotation.can.be.replaced.with.attribute=PHPUnit 註解在 PHPUnit 11 中已棄用，可被取代為特性
inspection.php.unit.assert.always.execute.to.same.result=實參類型不相容的 'assertTrue()'
inspection.php.unit.assert.array.has.key.inspection.display.name=可以改用方法 'assertArrayHasKey/assertArrayNotHasKey'
inspection.php.unit.assert.can.be.replaced.with.assert.true.false=斷言可被取代為 'assertTrue/assertFalse'
inspection.php.unit.assert.can.be.replaced.with.fail=斷言可被取代為 'fail'
inspection.php.unit.assert.contains.inspection.display.name=棄用的 'assertContains/assertNotContains' 用法
inspection.php.unit.assert.count.inspection.display.name=使用了 'assertCount/assertSameSize' 方法而非 assertEquals
inspection.php.unit.assert.empty.inspection.display.name=斷言可被取代為 'assertEmpty/assertNotEmpty'
inspection.php.unit.assert.equals.inspection.display.name=棄用的 'assertEquals/assertNotEquals' 用法
inspection.php.unit.assert.file.equals.inspection.display.name=棄用的 'assertFileEquals/assertStringEqualsFile' 用法
inspection.php.unit.covers.by.access.modifier.is.deprecated.inspection.display.name=棄用的通過修飾符註解進行的 @covers/@uses
inspection.php.unit.covers.function.without.scope.resolution.operator.inspection.display.name=提供的覆蓋函式參照沒有 '\\:\\:'
inspection.php.unit.deprecated.call.in.phpunit.10=方法在 PHPUnit 10 中已棄用
inspection.php.unit.deprecated.call.in.phpunit.11=方法在 PHPUnit 11 中已棄用
inspection.php.unit.deprecated.data.provider.signature.inspection.display.name=自 PHPUnit 10 以來，已棄用資料提供程序
inspection.php.unit.deprecated.expect.exception.inspection.display.name=使用了棄用的 expectException
inspection.php.unit.expected.exception.doc.tag.is.deprecated.inspection.display.name=棄用的通過文檔標記進行的異常處理
inspection.php.unit.failed.line=測試中失敗的行
inspection.php.unit.invalid.mocking.target=無效的 PHPUnit 模擬目標
inspection.php.unit.misordered.assert.equals.arguments.inspection.display.name=順序錯誤的 PHPUnit 等式斷言方法實參
inspection.php.unit.missing.target.for.test.inspection.display.name=PHPUnit 測試缺少目標元素
inspection.php.unit.undefined.data.provider.inspection.display.name=未定義的 PHPUnit 資料提供程序
inspection.php.unknown.modifier=未知修飾符 ''{0}''
inspection.php.unnecessary.continue='continue' 不必要，因為是迴圈中的最後一條語句
inspection.php.unnecessary.curly.variable.syntax=變數的不必要大括號語法
inspection.php.unnecessary.double.quotes.display.name=不必要的雙引號
inspection.php.unnecessary.else.inspection.display.name=不必要的 'else' 分支
inspection.php.unnecessary.fully.qualified.name.inspection.display.name=不必要的完全限定名稱
inspection.php.unnecessary.leading.backslash.in.use.statement='use' 語句中有不必要的前導 ''
inspection.php.unnecessary.local.variable.inspection.display.name=不必要的區域變數
inspection.php.unnecessary.parentheses.inspection.display.name=不必要的圓括號
inspection.php.unnecessary.return.function='return' 不必要，因為是函式中的最後一條語句
inspection.php.unnecessary.return.inspection.display.name=不必要的 'return/continue' 語句
inspection.php.unnecessary.return.method='return' 不必要，因為是方法中的最後一條語句
inspection.php.unnecessary.semicolon.description=不必要的 ;
inspection.php.unnecessary.semicolon.inspection.display.name=不必要的分號
inspection.php.unnecessary.spread.operator.for.function.call.argument=函式呼叫實參的不必要展開運算符
inspection.php.unpacked.argument.type.mismatch.inspection.display.name=無效類型的解包實參
inspection.php.unpacking.arrays.with.string.keys.inspection=對於 PHP 8.1 之前的版本，禁止使用字串鍵解包陣列
inspection.php.unsupported.modifier=自 PHP {1} 起不支持修飾符 ''{0}''
inspection.php.unsupported.modifier.key=不支持的修飾符
inspection.php.unused.alias.description=匯入 '\\#ref' 不必要
inspection.php.unused.alias.description2=匯入 '\\#ref' 從未使用
inspection.php.unused.alias.inspection.display.name=未使用的 import
inspection.php.unused.display.name=未使用的宣告
inspection.php.unused.field.default.value.description=屬性初始設定式冗餘
inspection.php.unused.field.default.value.inspection.display.name=冗餘屬性初始設定式
inspection.php.unused.local.variable.inspection.display.name=未使用的區域變數
inspection.php.unused.match.arm.condition.inspection.display.name=未使用的 'match' 條件
inspection.php.unused.parameter.inspection.display.name=未使用的參數
inspection.php.unused.private.field.inspection.display.name=未使用的 private 屬性
inspection.php.unused.private.method.inspection.display.name=未使用的 private 方法
inspection.php.unused.switch.case.inspection.display.name=未使用的 'switch' 分支
inspection.php.usage.of.silence.operator.inspection.display.name=使用了靜默運算符
inspection.php.useless.trailing.comma.inspection.desc=無用的尾隨逗號
inspection.php.useless.trailing.comma.inspection.display.name=無用的尾隨逗號
inspection.php.var.export.used.without.return.argument=使用 'var_export' 或 'print_r' 調用時不帶 'return' 實參
inspection.php.var.usage.inspection.display.name=使用了 var
inspection.php.variable.naming.convention.inspection.display.name=變數名稱未遵循編碼約定
inspection.php.variable.variable.inspection.display.name=使用了可變變數
inspection.php.void.function.result.used.inspection.display.name=使用了 void 函式結果
inspection.php.write.access.to.readonly.property.outside.declaration.scope=對宣告作用域之外的 'readonly' 屬性的寫入權限
inspection.php.write.access.to.referenced.array.value.without.unset=對無 'unset' 的參照陣列值的寫入權限
inspection.php.wrong.catch.clauses.order.inspection.display.name=catch 子句順序錯誤
inspection.php.wrong.foreach.argument.type.inspection.display.name=為 'foreach()' 提供的無效實參
inspection.php.wrong.string.concatenation.inspection.display.name=字串串聯錯誤
inspection.phpunit.asserts.array.has.key.can.be.used.instead=可以改用方法 ''{0}''
inspection.phpunit.asserts.assert.with.count.function=可以使用方法 {0} 代替 {1}
inspection.phpunit.asserts.assertEquals.misordered.arguments=順序錯誤的 ''{0}()'' 實參
inspection.phpunit.asserts.assertEquals.parameters.empty=帶有此類別參數的呼叫已棄用
inspection.phpunit.asserts.assertEquals.parameters.many=可選的 {0} 個參數已棄用
inspection.phpunit.asserts.assertEquals.parameters.single=可選的 {0} 個參數已棄用
inspection.phpunit.covers.function.without.scope.resolution.operator=提供的覆蓋{0}參照沒有 ''\\:\\:''
inspection.phpunit.expectException=對將 expectException() 用於 {0} 的支援已棄用，將在 PHPUnit 10 中移除。請改用 {1}()。
inspection.phpunit.missing.target.element.ref=未找到 '\\#ref' 的測試目標元素
inspection.phpunit.will.deprecation=對使用 {0}() 的支援已棄用，將在 PHPUnit 12 中移除。請改用 {1}()。
inspection.probably.undefined.property=屬性 '\\#ref' 已動態宣告，可能未定義
inspection.property.declared.dynamically=動態宣告的屬性
inspection.property.declared.dynamically.deprecated=動態宣告的屬性，從 PHP 8.2 開始已棄用。
inspection.property.hook.can.be.can.be.shortened=屬性掛鈎可以縮短
inspection.redundant.closing.tag.fix.remove=移除結束標記
inspection.redundant.closing.tag.problem=冗餘結束標記
inspection.redundant.intersection.type=冗餘的交叉類型
inspection.redundant.intersection.type.fix=交叉類型可以簡化為 ''{0}''
inspection.redundant.intersection.type.fix.name=簡化交叉類型
inspection.redundant.phpdoc=冗餘 PHPDoc 註釋
inspection.redundant.phpdoc.tag=冗餘的 PHPDoc 標記
inspection.set.visibility.can.be.removed=可以移除 'set' 可見性
inspection.severity.with.magic=當 __magic 存在時顯示
inspection.silly.assignment.problem=賦值左右兩側相等
inspection.single.statement.with.braces=單語句主體帶大括號
inspection.single.statement.with.braces.fix.name=從 ''{0}'' 語句中移除大括號
inspection.statement.has.empty.body.comments.count.as.content=註釋計為內容
inspection.statement.has.empty.body.ignore.empty.for=忽略無主體的 'for' 迴圈
inspection.statement.has.empty.body.ignore.empty.while=忽略無主體的 'while' 迴圈
inspection.statement.without.braces=控制語句主體無大括號
inspection.statement.without.braces.fix.name=將大括號新增到 ''{0}'' 語句
inspection.static.member.accessed.via.instance.reference=通過實例參照存取 static 成員 ''{0}''
inspection.static.method.called.as.dynamic.problem=static 方法 '\\#ref' 不應被動態呼叫
inspection.static.method.called.as.dynamic.problem.magic=static 方法 '\\#ref' 不應被動態呼叫，但類別具有 '__magic' 方法。
inspection.str.functions.strpos.call.can.be.converted.to.strcontains='strpos()' 呼叫可以轉換為 'str_contains()'
inspection.str.functions.strpos.call.can.be.converted.to.strstartswith='strpos()' 呼叫可以轉換為 'str_starts_with()'
inspection.str.functions.substr.call.can.be.converted.to.strendswith='substr()' 呼叫可以轉換為 'str_ends_with()'
inspection.str.functions.substr.call.can.be.converted.to.strstartswith='substr()' 呼叫可以轉換為 'str_starts_with()'
inspection.strict.type.checking.field.assignment=屬性必須為 ''{0}'' 類型，提供的是 ''{1}''
inspection.strict.type.checking.field.assignment.multi.resolve=賦值的類型 ''{0}'' 與屬性的宣告類型不相容
inspection.strict.type.checking.option=為所有檔案啟用
inspection.strict.type.checking.parameter=應為 ''{0}'' 類型的參數，提供的是 ''{1}''
inspection.strict.type.checking.parameter.batch=參數 '\\#ref' 類型與宣告不相容
inspection.strict.type.checking.return=返回值必須為 ''{0}'' 類型，返回的是 ''{1}''
inspection.strict.type.checking.return.batch=返回值類型與宣告不相容
inspection.super.incompatible.with.interface.declaration.must.be.compatible=''{0}'' 的宣告必須與 ''{1}'' 相容
inspection.switch.with.single.case=只有一個 'case' 的 'switch'
inspection.switch.without.default.case='Switch' 沒有預設分支
inspection.too.many.parameters=參數數量超出指定限值
inspection.too.many.parameters.ignore.constructors=忽略建構函式
inspection.too.many.parameters.max.number.of.parameters=最大參數數量
inspection.traditional.syntax.array.literal.detected=使用了傳統語法陣列字面量
inspection.undefined.callback.class=未定義的類別 ''{0}''
inspection.undefined.callback.dont.report.ambiguity.checkbox=不明確時不報告
inspection.undefined.callback.dont.report.exist.checkbox=忽略來自 '*_exists' 和 'is_callable' 函式的回調
inspection.undefined.callback.field=在類別 ''{1}'' 中未找到屬性 ''{0}''
inspection.undefined.callback.function=未定義的函式 ''{0}''
inspection.undefined.callback.method=在類別 ''{1}'' 中未找到方法 ''{0}''
inspection.undefined.class.ignore.phpdoc=忽略 PHPDoc
inspection.undefined.constant.problem1=未定義的常數 '\\#ref'
inspection.undefined.constant.problem2=常數 '\\#ref' 可能未定義
inspection.undefined.field.notify.access.magic.method=通過魔術方法存取屬性的通知
inspection.undefined.field.notify.dynamic.declaration=動態屬性宣告的通知
inspection.undefined.field.notify.dynamic.read=通知對動態屬性的讀取權限
inspection.undefined.field.problem1=通過魔術方法存取的屬性
inspection.undefined.function.problem1=未定義的函式 '\\#ref'
inspection.undefined.function.problem2=函式 '\\#ref' 可能未定義
inspection.undefined.member.downgrade=如果類別中存在 __magic 方法則降級嚴重性(&D)
inspection.undefined.member.warnOnMixed=出現混合、物件、stdClass、未定義類型、null 的存取成員時通知
inspection.undefined.phpunit.provider=未定義的 PHPUnit 資料提供程序 ''{0}''
inspection.undefined.variable.option.description.enable.in.file.scope=在全域空間中啟用檢查
inspection.undefined.variable.option.description.ignore.include=在當前檔案外搜尋變數定義
inspection.undefined.variable.option.description.report.can.be.undefined=報告變數可能未定義
inspection.undefined.variable.problem1=未定義的變數 '\\#ref'
inspection.undefined.variable.problem2=變數 '\\#ref' 可能未定義
inspection.unnecessary.bool.cast=冗餘轉換為布林值
inspection.unnecessary.fully.qualified.name.option.enable.file.scope=在檔案作用域中啟用
inspection.unnecessary.fully.qualified.name.option.ignore.global.namespace=忽略全域命名空間
inspection.unnecessary.qualifier.already.imported.message=限定符不必要，可以移除
inspection.unnecessary.static.reference=final 類別中有冗餘的 'static'
inspection.unnecessary.string.cast=冗餘轉換為字串
inspection.unpacked.argument.type.mismatch=僅可解包陣列和 Traversable，獲得的是{0}
inspection.unreachable.statement=不可到達的語句
inspection.unreachable.statement.problem=不可到達的語句
inspection.unused.declaration.option.show.unused_from_entries=顯示所有宣告
inspection.unused.declaration.option.show_strictly_unused=僅顯示未使用項
inspection.unused.declaration.option.test.entry_points=假定測試宣告為入口點
inspection.unused.declaration.option.test.suppressGettersAndSetters=禁止 getter/setter
inspection.unused.description.code.suppressed.annotations=已禁止的註解
inspection.unused.local.variable.option.description.file.scope=在全域空間中啟用檢查
inspection.unused.local.variable.option.description.foreach=在 'list()' 中或存在 'foreach' 鍵時忽略 foreach 值
inspection.unused.local.variable.option.description.include=忽略 'include' 之前的變數
inspection.unused.local.variable.option.description.list=忽略 'list()' 中的變數
inspection.unused.local.variable.option.description.null=忽略 'null' 的賦值
inspection.unused.local.variable.option.indirect.access=忽略通過 'get_defined_vars()' 存取的變數
inspection.unused.local.variable.problem=未使用的區域變數 ''{0}''。{1}
inspection.unused.local.variable.problem.batch=區域變數 '\\#ref' 未在任何位置使用
inspection.unused.local.variable.problem.case1=變數的值未在任何位置使用。
inspection.unused.local.variable.problem.case2=變數的值被立即覆蓋。
inspection.unused.local.variable.problem.case3=變數中存儲的參照未在任何位置使用。
inspection.unused.local.variable.problem.case4=變數中存儲的參照被立即覆蓋。
inspection.unused.local.variable.problem.fix.side.effects.found.dialog.message=分配給 ''{0}'' 的表達式可能含有副作用。\\n您可以\\:\\n- 完全<b>移除</b>變數賦值\\n- 將分配的表達式<b>轉換</b>成單獨的語句
inspection.unused.local.variable.problem.fix.side.effects.found.dialog.title=發現副作用
inspection.unused.parameter.option.description.empty.abstract=忽略抽象類別方法的參數
inspection.unused.parameter.option.description.empty.anonymous=忽略匿名函式的參數
inspection.unused.parameter.option.description.empty.body=忽略帶有空體的方法/函式的參數
inspection.unused.parameter.option.description.empty.override=忽略覆寫方法的參數
inspection.unused.parameter.option.description.parameter.count=不報告通過 'func_num_args()' 存取的參數
inspection.unused.parameter.option.description.property.hook.param.type=當屬性掛鈎參數等於屬性類型時不報告
inspection.unused.parameter.problem=未使用的參數 ''{0}''。{1}
inspection.unused.parameter.problem.case1=參數值未在任何位置使用。
inspection.unused.parameter.problem.case2=參數值被立即覆蓋。
inspection.unused.parameter.problem.case3=參數中存儲的參照未在任何位置使用。
inspection.unused.parameter.problem.case4=參數中存儲的參照被立即覆蓋。
inspection.unused.parameter.problem.case5=參數類型等於屬性類型。
inspection.unused.private.method.option.ignore.clone=忽略方法 '__clone' 用法
inspection.unused.private.method.option.ignore.constructor=忽略方法 '__construct' 用法
inspection.unused.private.method.problem.batch=未使用的 private 方法 '\\#ref'
inspection.unused.symbol.check.anonymous_classes=匿名
inspection.unused.symbol.check.classes=類別
inspection.unused.symbol.check.constants=常數
inspection.unused.symbol.check.fields=屬性
inspection.unused.symbol.check.functions=函式
inspection.unused.symbol.check.magic_method=魔術方法
inspection.unused.symbol.check.methods=方法
inspection.unused.symbol.export.abstract=abstract
inspection.unused.symbol.export.call=呼叫
inspection.unused.symbol.export.calls=呼叫
inspection.unused.symbol.export.closure=結束
inspection.unused.symbol.export.entry=入口點
inspection.unused.symbol.export.label=標籤
inspection.unused.symbol.export.reachable_element=可到達
inspection.unused.symbol.export.test_method=測試
inspection.unusedd.description.code.patterns.button.label=程式碼模式
inspection.usage.of.silence.operator.problem=使用了沉默運算符
inspection.variable.variable=使用了可變變數
inspection.visibility.modifier.can.be.removed=可以移除可見性修飾符
inspection.void.function.result.used.problem.type=void
inspection.void.never.function.result.used.problem.type=void/never
inspection.wrong.exception.order.fix.move.display.name=將 ''catch'' 子句移至 ''{0}'' 前
inspection.wrong.exception.order.fix.move.family.name=移動 'catch' 子句
inspection.wrong.exception.order.problem.batch=已捕獲異常 '\\#ref'
inspection.wrong.exception.order.problem.same=已捕獲異常 ''{0}''
inspection.wrong.exception.order.problem.super=已捕獲異常類別 ''{1}'' 的超類別 ''{0}''
inspection.wrong.exception.type.problem.catch=無法捕獲非派生自 'Exception' 或 'Throwable' 基類別的物件
inspection.wrong.exception.type.problem.throw=已拋出物件必須為 'Exception' 或 'Throwable' 的實例
inspection.wrong.foreach.argument.type.problem=提供給 ''foreach'' 的實參無效。預期類型\\: ''array'' 或 ''object''，提供的是 ''{0}''。
inspection.wrong.foreach.argument.type.problem.batch=提供給 'foreach' 的無效實參
inspection.wrong.string.concatenation.operator.option.ignore.magic=忽略通過魔術方法存取的屬性
inspection.wrong.string.concatenation.operator.problem=字串串聯運算符錯誤
inspection.wrong.string.concatenation.operator.problem.batch=字串串聯運算符錯誤
inspection.wrong_param_type=應為 ''{1}'' 類型的參數，提供的是 ''{0}''
install.composer.packages.task.title=安裝 Composer 軟體套件
instanceof.is.always.true={0} 已位於 {1} 的層次結構中
intention.add.constructor.parameters=新增建構函式參數
intention.add.constructor.parameters.fields.chooser.dialog.title=選擇要在建構函式中初始化的屬性
intention.can.not.find.statement.to.surround=找不到要包圍的目標語句。
intention.convert.to.short.syntax=將陣列轉換為短語法
intention.convert.to.short.syntax.list=將列表轉換為短語法
intention.convert.to.traditional.syntax=將陣列轉換為傳統語法
intention.convert.to.traditional.syntax.list=將列表轉換為傳統語法
intention.declare.missing.field=宣告屬性
intention.declare.missing.property=新增 @property
intention.family.inline.value.for.parameter=內聯參數值
intention.family.name.add=新增 ''\${0}''
intention.family.name.add.arrayshape.attribute=新增 '\\#[ArrayShape]' 特性
intention.family.name.add.arrayshape.to.doc=將 ArrayShape 新增到 PHPDoc
intention.family.name.add.attribute=新增 ''\\#[{0}]''
intention.family.name.add.attribute.attribute=使用 'Attribute' 註解
intention.family.name.add.attribute.to=將 ''\\#[{0}]'' 新增到 ''{1}''
intention.family.name.add.attribute.to.overridden.method=將特性新增到覆寫方法
intention.family.name.add.attribute.to.overridden.method.of.abstract.method=將特性新增到抽象方法的覆寫方法
intention.family.name.add.attribute.to.overridden.parameter=將特性新增到覆寫參數
intention.family.name.add.break.as.last.statement=將 'break' 作為最後一條語句新增
intention.family.name.add.default.match.arm=新增 'default' 'match' arm
intention.family.name.add.doc.tag.with.throws.tags=使用 @throws 標記新增 PHPDoc 註釋
intention.family.name.add.getter=新增 getter
intention.family.name.add.getter.setter=新增 getter 和 setter
intention.family.name.add.missing.array.key=新增缺失的陣列鍵 ''{0}''
intention.family.name.add.missing.parameters=新增缺少的參數
intention.family.name.add.name.identifiers.to.all.arguments.starting.from.current=從當前位置開始將名稱關鍵字新增到所有實參
intention.family.name.add.number.separators=新增數字分隔符
intention.family.name.add.readonly.modifier=新增 'readonly' 修飾符
intention.family.name.add.remaining.enum.cases=新增剩餘 enum case
intention.family.name.add.should.allow.mocking.protected.methods.call=新增 'shouldAllowMockingProtectedMethods' 呼叫
intention.family.name.add.to.containing.enum=將 '' \\: {0}'' 新增到包含枚舉
intention.family.name.add.to.parameter=將 '\\\\&' 新增到參數
intention.family.name.add.trait.to.use.list=將特徵新增到 use 列表
intention.family.name.add.true.argument.to.var.export.call=將 'true' 實參新增到 'var_export' 呼叫
intention.family.name.add.variable.name=新增變數名稱
intention.family.name.append=追加 ''{0}''
intention.family.name.append.absolute.trait=追加 ''{0}\\:\\:''
intention.family.name.can.be.merged.with.sequential=''if'' 可以與後續 ''{0}'' 合併
intention.family.name.change.to.mixed=將類型更改為 'mixed'
intention.family.name.collapse.if.statement=摺疊 ''{0}'' 語句
intention.family.name.collapse.statement.into.parameter.default.value=將語句摺疊到參數的預設值中
intention.family.name.collapse.whitespaces=摺疊空格
intention.family.name.combine.multiple.isset.calls.into.one=將多個 'isset' 呼叫合併為一個
intention.family.name.convert.heredoc.nowdoc.to.string.literal=將 heredoc/nowdoc 轉換為字串字面量
intention.family.name.convert.heredoc.to.string.literal=將 heredoc 轉換為字串字面量
intention.family.name.convert.nowdoc.to.string.literal=將 nowdoc 轉換為字串字面量
intention.family.name.convert.string.literal.to.heredoc.nowdoc=將字串字面量轉換為 heredoc/nowdoc
intention.family.name.convert.to.promoted.field=轉換為提升的屬性
intention.family.name.convert.to.promoted.field.remove.doc.comment=轉換為提升的屬性並移除屬性 PHPDoc 註釋
intention.family.name.copy.phpdoc.from.parent=從父項複製 PHPDoc
intention.family.name.count.comments.as.content=將註釋計為內容
intention.family.name.delete.covered.element=刪除已覆蓋的元素
intention.family.name.delete.field=刪除屬性
intention.family.name.delete.initializer=刪除初始設定式
intention.family.name.delete.readonly=刪除 'readonly'
intention.family.name.evaluate.cast=取代為 ''{0}''
intention.family.name.extract.attribute.into.separate.list=將特性提取到單獨的列表
intention.family.name.extract.common.parts=提取通用部分
intention.family.name.extract.common.parts.with.removing.branch=提取通用部分，並移除分支
intention.family.name.flip=翻轉 '?\\:'
intention.family.name.flip.attributes.lists=翻轉特性列表
intention.family.name.force.fqcn.for.references.in.phpdoc=對 PHPDoc 中的參照強制 FQCN
intention.family.name.generate.phpdoc.comment=生成 PHPDoc 註釋
intention.family.name.group.intersection.types=對交叉類型分組
intention.family.name.initialize.properties=初始化屬性
intention.family.name.initialize.property.in.constructor=初始化建構函式中的屬性
intention.family.name.insert.space.after=在 '\\#' 後面插入一個空格
intention.family.name.insert.unset.before=在前面插入 ''unset(\${0});''
intention.family.name.invert.if.statement=反轉 'if' 語句
intention.family.name.make.class.readonly=將類別設定為 'readonly'
intention.family.name.make.containing.class.enum=將包含類別設為枚舉
intention.family.name.make.data.provider.method.public.static=將資料提供程序方法設定為 'public' 和 'static'
intention.family.name.make.final=設為 'final'
intention.family.name.make.function.return.by.reference=使函式按參照返回
intention.family.name.make.method.void=將方法設為 'void'
intention.family.name.mark.missing.array.key.as.optional=將缺失的陣列鍵 ''{0}'' 標記為可選
intention.family.name.merge.with.adjustment.range=與調整後的範圍合併
intention.family.name.merge.with.assignment=與賦值合併
intention.family.name.merge.with.duplicated.catch.statement=與重複的 'catch' 語句合併
intention.family.name.merge.with.duplicated.match.arm=與重複的 'match' arm 合併
intention.family.name.merge.with.following.attribute.list=將特性列表與以下內容合併
intention.family.name.merge.with.sequential=與後續 ''{0}'' 合併
intention.family.name.move.attribute.to.start.element=將特性移至元素開頭
intention.family.name.move.from.to.composer.json.section=將 ''{0}'' 從 ''{1}'' 移至 ''{2}'' composer.json 部分
intention.family.name.move.trait.use.rule.to.resolved.class.use.list=將特徵 'use' 規則移至解析的類別 'use' 列表
intention.family.name.navigate.to.cause=導覽到原因
intention.family.name.navigate.to.duplicate.method.name=導覽到重複的方法
intention.family.name.navigate.to.possibly.inaccessible.methods=導覽到可能無法存取的方法
intention.family.name.navigate.to.rewrite.expression=導覽到覆寫表達式
intention.family.name.remove=移除 {0}
intention.family.name.remove.argument.name=移除實參名稱
intention.family.name.remove.attribute=移除 ''\\#[{0}]''
intention.family.name.remove.backed.type.from.containing.enum=從包含枚舉中移除備用類型
intention.family.name.remove.duplicate.operand=移除重複動作數
intention.family.name.remove.empty.index.operator=移除 '[]' 運算符
intention.family.name.remove.leading=移除前導 ''
intention.family.name.remove.parenthesis=移除圓括號
intention.family.name.remove.readonly.modifier=移除 'readonly' 修飾符
intention.family.name.remove.redundant.arguments=移除冗餘{0, choice, 0\\#實參|1\\#實參}
intention.family.name.remove.unused.postfix.operation=移除未使用的後綴運算
intention.family.name.remove.unused.property=移除未使用的屬性
intention.family.name.rename.parameter.to.match.super=重新命名參數以符合父級
intention.family.name.replace.array.traversable.with.iterable=將 'array|Traversable '取代為'iterable'
intention.family.name.replace.elseif.with.else=將 'elseif' 取代為 'else'
intention.family.name.replace.if.with.match.expression=將 'if' 取代為 'match' 表達式
intention.family.name.replace.if.with.version=將 'if' 取代為 '??' 版本
intention.family.name.replace.in.array.with.disjunction=將 'in_array()' 取代為 '||'
intention.family.name.replace.instanceof.checks.in.catch.with.specific.catches=將 'catch' 塊中的 'instanceof' 檢查取代為特定的 catch
intention.family.name.replace.match.with.switch.statement=將 'match' 取代為 'switch' 語句
intention.family.name.replace.match.with.switch.statement.changing.semantics=將 'match' 取代為 'switch' 語句(可能會改變比較語意)
intention.family.name.replace.match.with.ternary=取代為三元表達式
intention.family.name.replace.readonly.with.public=將 'readonly' 取代為 'public'
intention.family.name.replace.switch.with.if=將 'switch' 取代為 'if'
intention.family.name.replace.switch.with.match.expression=將 'switch' 取代為 'match' 表達式
intention.family.name.replace.ternary.expression.with.true.branch=將三元表達式取代為 ''{0}'' 分支
intention.family.name.replace.true.argument.with.false=將 'true' 實參取代為 'false'
intention.family.name.replace.with=取代為 ''{0}''
intention.family.name.replace.with.argument=取代為實參
intention.family.name.replace.with.array=取代為數組
intention.family.name.replace.with.array.assignment=取代為數組賦值
intention.family.name.replace.with.array.merge.expression=取代為 'array_merge' 表達式
intention.family.name.replace.with.check=取代為 '\\!\\=\\=' 檢查
intention.family.name.replace.with.class.constant=取代為類別常數
intention.family.name.replace.with.class.name.literal=取代為 '\\:\\:class'
intention.family.name.replace.with.class.reference.with.base.class=取代為對基類別的類別參照
intention.family.name.replace.with.closure.fromCallable=取代為 'Closure\\:\\:fromCallable(...)'
intention.family.name.replace.with.comparison=取代為比較
intention.family.name.replace.with.compile.time.result=取代為編譯時結果
intention.family.name.replace.with.concatenation=取代為串聯
intention.family.name.replace.with.const.syntax=取代為 'const' 語法
intention.family.name.replace.with.define.call=取代為 'define()' 呼叫
intention.family.name.replace.with.dirname.call=取代為 'dirname()' 呼叫
intention.family.name.replace.with.dnf=取代為 DNF 類型宣告
intention.family.name.replace.with.get.class.call=取代為 'get_class()' 呼叫
intention.family.name.replace.with.if=取代為 'if'
intention.family.name.replace.with.implicit.octal.notation=取代為隱式八進制表示法
intention.family.name.replace.with.implode.call=取代為 'implode()' 呼叫
intention.family.name.replace.with.in.array.call=取代為 'in_array()' 呼叫
intention.family.name.replace.with.interpolation=取代為 '{$' 插值
intention.family.name.replace.with.list=取代為 'list'
intention.family.name.replace.with.min.max.call=取代為 'min()'/'max()' 呼叫
intention.family.name.replace.with.named.argument=取代為命名實參
intention.family.name.replace.with.operator=取代為 '?->' 運算符
intention.family.name.replace.with.parameter.access=取代為參數存取
intention.family.name.replace.with.public=取代為 'public'
intention.family.name.replace.with.self.access=取代為 'self\\:\\:' 存取
intention.family.name.replace.with.spl.autoload.register.call=取代為 'spl_autoload_register()' 呼叫
intention.family.name.replace.with.str.function.call=取代為 ''{0}'' 呼叫
intention.family.name.replace.with.str.repeat.call=取代為 'str_repeat()' 呼叫
intention.family.name.replace.with.suggested.call.in.phpunit=取代為 PHPUnit 10 中建議的呼叫
intention.family.name.replace.with.suggested.call.in.phpunit.11=取代為 PHPUnit 11 中建議的呼叫
intention.family.name.replace.with.ternary.expression=取代為三元表達式
intention.family.name.replace.with.traditional.property.declaration=取代為傳統屬性宣告
intention.family.name.replace.with.union.type=取代為聯合體類型
intention.family.name.replace.with.version=取代為 '??' 版本
intention.family.name.replace.with.zero=取代為 ''{0}''
intention.family.name.show.example.date.time.output=顯示範例日期時間輸出
intention.family.name.simplify.expression=簡化表達式
intention.family.name.simplify.ternary.expression=簡化 '?\\:'
intention.family.name.sort.arguments=對實參排序
intention.family.name.split.into.multiple.catch.statements=拆分為多個 'catch' 語句
intention.family.name.split.into.multiple.enum.cases=拆分為多個枚舉 case
intention.family.name.split.into.separate.case.statements=拆分為獨立的 'case' 語句
intention.family.name.split.into.two.separate.match.arms=將條件提取到單獨的 'match' arm
intention.family.name.unwrap.call=解包呼叫
intention.family.name.unwrap.cast=解包轉換
intention.family.name.unwrap.curly.braces=解包大括號
intention.family.name.unwrap.else=解包 'else'
intention.family.name.unwrap.foreach=解包 'foreach'
intention.family.name.unwrap.function.call=解包函式呼叫
intention.family.name.unwrap.intersection.type=解包交叉類型
intention.family.name.unwrap.spread.operator=解包展開運算符
intention.family.name.unwrap.type=解包類型
intention.flip.binary.expression.family.name=翻轉二元表達式
intention.flip.binary.expression.text1=翻轉 ''{0}''
intention.flip.binary.expression.text2=翻轉 ''{0}'' (可能更改語意)
intention.flip.binary.expression.text3=翻轉 ''{0}'' (更改語意)
intention.generate.phpdoc=生成 PHPDoc
intention.implement.interface=實作接口
intention.import.class=作為別名匯入類別
intention.import.class.alias.already.exists=已匯入具有相同別名的類別
intention.import.class.alias.name=別名\\:
intention.inline.alias=內聯別名
intention.inline.method.family.name=內聯方法
intention.join.comma.separated.values=將逗號分隔的值合併為一行
intention.line.split=在兩個字串和串聯中拆分字串
intention.merge.condition.with.outer=與外部條件合併
intention.message.replace.in.array.with.disjunction=將 ''in_array()'' 取代為 ''{0}''
intention.name.add.as.function.s.return.type=將 ''{0}'' 作為函式返回值類型新增
intention.name.add.enum.case.with.value=新增具有 ''{0}'' 值的枚舉 case
intention.name.add.method.stubs=新增方法存根
intention.name.add.name.identifier=新增名稱關鍵字 ''{0}''
intention.name.add.to.parameter=將 ''\\\\&'' 新增到參數 ''{0}''
intention.name.add.trait.to.use.list=將特徵 ''{0}'' 新增到 use 列表
intention.name.cast.to=將{0}轉換為{1}
intention.name.change.cast.to=將 {0} 轉換更改為 {1}
intention.name.change.method.to=將方法 ''{0}'' 更改為 {1}
intention.name.change.signature=更改 {0}({1}) 的簽名
intention.name.convert.array.syntax.to.short=將陣列轉換為短語法
intention.name.convert.concatenation.to.scalar.value=將串聯轉換為標量值
intention.name.convert.concatenation.to.string.interpolation=將串聯轉換為字串內插
intention.name.convert.sprintf.call.to.concatenation=將 'sprintf()' 呼叫轉換為串聯
intention.name.convert.sprintf.call.to.scalar.value=將 'sprintf()' 呼叫轉換為標量值
intention.name.convert.sprintf.call.to.string.interpolation=將 'sprintf()' 呼叫轉換為字串內插
intention.name.convert.string.literal.to.heredoc=將字串字面量轉換為 heredoc
intention.name.convert.string.literal.to.nowdoc=將字串字面量轉換為 nowdoc
intention.name.evaluate.cast=對轉換求值
intention.name.extract.if=提取 if ({0})
intention.name.flip=翻轉 {0} 和 {1}
intention.name.inline.value=內聯值 ''{0}''
intention.name.make.abstract=將{0}設為 abstract
intention.name.make.non.final=將 ''{0}'' 設為非 final
intention.name.merge.with=與 ''{0}'' 合併
intention.name.merge.with.match.arm=與 ''{0}'' arm 合併
intention.name.move.trait.use.rule.to.use.list=將特徵 ''use'' 規則移至 ''{0}'' ''use'' 列表
intention.name.prepend.default.case=預置 'default'
intention.name.remove=移除 {0}
intention.name.remove.argument.names.from.all.arguments.up.to.current=從截止到當前位置的所有實參中移除實參名稱
intention.name.remove.brackets=刪除中括號
intention.name.remove.duplicated.type=移除重複類型
intention.name.rename.to=重命名為 ''{0}''
intention.name.replace.brackets.with.types=取代為 'array'
intention.name.replace.coalesce.expression.with=將合併表達式取代為 ''{0}''
intention.name.replace.coalesce.expression.with.operand=將合併表達式取代為動作數
intention.name.replace.null.as.part.union.type.with.nullable.notation=將 '|null' 作為聯合體類型的一部分取代為 '?'
intention.name.replace.nullable.notation.with.null.as.part.union.type=用 '|null' 取代 '?' 作為聯合體類型的一部分
intention.name.replace.with=將 ''{0}'' 取代為 ''{1}''
intention.name.replace.with.min.max.call=取代為 ''{0}'' 呼叫
intention.name.suppress.for.statement=對語句禁止
intention.name.wrap.left.operand.in.parentheses=使用圓括號包裝左動作數
intention.name.wrap.right.operand.in.parentheses=使用圓括號包裝右動作數
intention.namespace.bracing=將命名空間轉換為帶大括號
intention.php.add.object.shape.attribute=新增 '\\#[ObjectShape]' 特性
intention.php.doc.add.object.shape=將 ObjectShape 新增到 PHPDoc
intention.php.replace.class.with.enum=將類別取代為枚舉
intention.php.replace.class.with.enum.error.message=由於建構函式呼叫，無法將類別取代為枚舉
intention.php.replace.class.with.enum.title=將類別取代為枚舉
intention.replace.class.with.alias=取代為別名
intention.replace.if.with.ternaryExpression=簡化 'if'
intention.replace.quotes=無法取代引號 - 轉義符號無效且\\\\r 不受支援
intention.replace.ternary.expression.with.if=將 '?\\:' 取代為 if
intention.replace.with.method.call=取代為對現有方法的呼叫
intention.split.comma.separated.values=將逗號分隔的值拆分為多行
intention.statement.to.surround.failed.message=無法使用 ''{0}'' 包圍語句。
intention.swap.call.arguments.family.name=交換呼叫實參
intention.swap.call.arguments.text1=交換 ''{0}'' 和 ''{1}''
intention.variable.add.phpdoc.comment.family.name=新增 PHPDoc 註釋
interface=接口
interface.cannot.extend.previously.extended.interface=接口無法擴展先前擴展的接口
interface.method.can.t.have.body=接口方法不能有主體
interface.name=接口名稱
interfaces.may.not.include.member.variables=接口可能不包括成員變數
interpreter=解釋器
intersection.types.and.the.nullable.type.notation.cannot.be.mixed=交叉類型和可 null 類型表示法不能混用
introduce.named.constant.for.value.0=為值 ''{0}'' 引入命名常數
introduce.variable.fix=引入變數
invalid.class.name=無效類別名
invalid.condition.to.body.separator.should.be.used=條件與主體之間的分隔符無效\\: 應改用 '\\=>'
invalid.octal.literal.won.t.be.reported.by.php.but.will.work.incorrectly=無效的八進制字面量\\: 不會由 PHP 報告，但無法正常工作
invalid.syntax.for.multiple.case.expressions=多個 'case' 表達式的語法無效
is.duplicated.by.0=類型被 ''{0}'' 重複
iso.8601.date=ISO 8601 日期({0})
iso.8601.numeric.representation.of.the.day.of.the.week=ISO 8601 星期几的數字表示(1 到 7)
iso.8601.week.number.of.year.weeks.starting.on.monday=ISO 8601 一年中的第幾周，周從星期一開始(42)
iso.8601.week.numbering.year=ISO 8601 周編號年份(2022)
isset.only.works.with.variables.and.arrays=isset 僅適用於變數和陣列
it.s.not.possible.to.unpack.array.argument.by.reference=無法通過參照對陣列實參解包
it.s.not.possible.to.unpack.array.key=無法解包陣列鍵
it.s.not.possible.to.unpack.array.value.with.associated.key=無法使用關聯鍵解包陣列值
jump.into.a.finally.block.is.disallowed=不允許跳入 'finally' 塊
key=鍵
label=標籤
label.authentication.data.not.specified=未指定身份驗證資料
label.can.be.configured.as.external.formatter=可組態為 {0}
label.class.fqn=類別 FQN
label.configured.as.external.formatter=已組態為 {0}
label.constant.syntax=常數語法(&C)
label.docker.container=Docker 容器\\:
label.failed=已失敗
label.global.namespace=<全域命名空間>
label.highlight.target.parameter.attributes.applied.to.promoted.property=僅允許具有提升屬性的 'TARGET_PARAMETER|TARGET_PROPERTY' 特性
label.initialize.in=初始化位置(&I)
label.insert.imports.on.paste=貼上時插入 import\\:
label.interpreter=解釋器\\: {0}
label.lt.no.server=<no server>
label.method.name=方法名稱
label.name=名稱\\:
label.new.name=新名稱\\:
label.predecessors=前驅
label.server.document.root=$_SERVER['DOCUMENT_ROOT']
label.successors=後繼
label.system.php=系統 PHP
label.visibility=可見性(&V)
label.visibility2=可見性\\:
label.with.same.name.already.defined.in.current.scope=當前作用域中已定義具有相同名稱的標籤
label1=標籤
lambda=Lambda
languages.frameworks.php.php.runtime=PHP / PHP 執行時
line.separator=行分隔符
link=鏈接
link.label.builtin.formatter=強制啟用內建格式化程序
link.label.go.to.documentation=轉到文檔
link.label.inspection={0} 檢查
link.label.languages.frameworks.php=PHP
list.is.not.allowed.as.class.reference=不允許將列表作為類別參照
list.item.php.file=PHP 檔案
list.item.update.phpdoc.comment=更新 PHPDoc 註釋
list.of.causes.0=// 可能拋出異常的位置列表\\:\\n{0}
listing.licenses=正在列出授權
literal.%=字面量 % (%)
live.template.class.member=類別成員
live.template.interface.member=接口成員
live.template.name.comment=註釋
live.template.name.empty.file=空 PHP 檔案
live.template.name.expression=表達式
live.template.name.method.expression=類別成員中的表達式
live.template.name.method.statement=類別成員中的宣告
live.template.name.statement=語句
live.template.name.string.literal=字串字面量
live.template.trait.member=特徵成員
local=本地
lowercase.ante.meridiem.and.post.meridiem.am.pm=小寫上午和下午(am/pm)
machine.type.eg.i386=機器類型。例如，i386
make.0.1=將 ''{0}'' 設為{1}
make.01=設為 ''{0}''
make.call.dynamic.quick.fix.family.name=使呼叫為動態
make.non.nullable=設為不可為 null
member.has.0.access=成員具備 {0} 可見性
member.has.0.access.but.class.has.magic.method.1=成員具備 {0} 可見性，但可以通過 ''{1}'' 魔術方法存取
members.to.report=要報告的成員
merge.into.elseif=合併到 'elseif' 中
merge.nested.conditions=合併嵌套的條件
merge.with.0.branch=與 ''{0}'' 分支合併
meta.declaration.exists=''{1}'' 存在元宣告 ''{0}''
meta.declaration.line.marker.name=存在元宣告
meta.multiple.declaration.exists=''{0}'' 存在多個元宣告
method=方法
method.0.can.t.be.overridden.with.same.trait.1=無法使用相同的特徵 ''{1}'' 覆寫方法 ''{0}''
method.0.clone.cannot.accept.any.arguments=方法 ''{0}\\:\\:__clone()'' 不能接受任何實參
method.call=方法呼叫
method.is.undefined=方法 '\\#ref' {0,choice,0\\#未定義|1\\#可能未定義}
method.is.undefined.in.class=方法 ''\\#ref'' 在 {0} 中{1,choice,0\\#未找到|1\\#可能未定義}
method.name=方法名稱
method.ref.is.deprecated=方法 '\\#ref' 已棄用
method.ref.not.found=找不到方法 '\\#ref'
method.should.either.have.body.or.be.abstract=方法應具有主體或為 abstract
method.should.not.be.finished.with=方法不應以 ';' 結束
method.template.parameter.shadows.class.template.parameter=方法模板參數 ''{0}'' 會隱藏類別模板參數
method.with.same.name.already.defined.in.this.class=此類別中已經定義了具有相同名稱的方法
method1=方法
microseconds=微秒(654321)
microseconds.numeric=微秒，數字(007701、052738、428291)
microseconds.numeric.at.least.6.digits.with.leading.0=微秒，數字，至少 6 位數，帶前導 0 (007701、052738、428291)
milliseconds=毫秒(654)
minutes.numeric=分鐘，數字(1、3、59)
minutes.numeric.at.least.2.digits.with.leading.0=分鐘，數字，至少 2 位數，帶前導 0 (01、03、59)
minutes.with.leading.zeros=帶前導零的分鐘(00 到 59)
modifier=修飾符
months.numeric=月份，數字(1、3、12)
months.numeric.at.least.2.digits.with.leading.0=月份，數字，至少 2 位數，帶前導 0 (01、03、12)
more.actions=更多動作…
move.class.to.separate.file.text.family=將類別移至單獨的檔案
move.from.another.ide.or.code.editor=從另一個 IDE 或程式碼編輯器遷移
move.xdebug.file.to.the.extensions.directory.and.update.configuration.file=將 'xdebug.so' 檔案移動到 PHP 擴展程序目錄並更新組態檔案
multiple.enum.identifiers.should.be.stated.in.different.cases=多個枚舉關鍵字應在不同的 case 中宣告
multiple.modifiers.are.not.allowed=不允許多個修飾符
multiple.namespaces.in.a.file.should.use.same.preferably.braced.syntax=檔案中的多個命名空間應使用相同的(最好帶大括號)語法
multiple.subsequent.underscores.in.a.numeric.literal.are.not.allowed=不允許在數字字面量中使用多個後續下劃線
mute.until.restart=重啟前靜音
name=名稱
named.parameter.overwrites.previous.argument=命名參數覆寫以前的實參
namespace=命名空間
namespace.cannot.start.with.namespace.due.to.conflict.with.ns.relative.names=由於與 ns 相關名稱衝突，命名空間不能以 "namespace" 開頭
namespace.declarations.cannot.be.nested=命名空間宣告不能被嵌套
naming.rules=命名規則
navigate=… 導覽
navigate.to.composer.json=導覽到 composer.json
navigate.to.meta.declaration=導覽到 ''{0}''
navigation.goto.super.method.is.not.available=索引更新期間無法在此處導覽
negate.boolean.expression=布爾表達式求反
nested.type.groups.are.not.allowed=不允許嵌套類型組
never.can.only.be.used.as.return.type='never' 只能用作返回值類型
newUiOnboarding.php.connections.header=正在偵聽 PHP 偵錯連線
newUiOnboarding.php.connections.link=使用 PhpStorm 進行偵錯\\: 終極指南
newUiOnboarding.php.connections.step.text=點擊以開始/停止偵聽傳入的 PHP 偵錯連線。有關詳情，請參閱{0}
no.candidate.methods.to.implement=沒有要實作的候選方法
no.candidate.methods.to.override=沒有要覆寫的候選方法
no.content.allowed.before.namespace.declaration=命名空間宣告之前不允許任何內容
no.elements.to.generate.phpdoc.for=沒有任何可為其生成 PHPDoc 的元素
no.expression.found=找不到表達式
no.external.formatter=無外部格式化程序
no.fields.to.generate.property.hooks.for=沒有要為其生成屬性掛鈎的欄位
no.in.line.parameter.name.hints.will.be.shown.for.methods.matching.any.of.these.patterns=對於符合其中任一模式的方法，都不會顯示任何嵌入參數名稱提示。
no.interpreter=<無解釋器>
no.item=沒有項
no.members.to.pull.up.found=未找到要向上拉取的成員
no.members.to.push.down.found=未找到要向下推送的成員
no.name=無名稱
no.private.fields.to.generate.both.getters.and.setters.for=沒有要為之同時生成 getter 和 setter 的 private 欄位
no.private.fields.to.generate.getters.for=沒有要為之生成 getter 的 private 欄位
no.private.fields.to.generate.setters.for=沒有要為之生成 setter 的 private 欄位
no.response.from.0.after.1.ms={1} 毫秒後 {0} 未響應
no.type=NO_TYPE
node.is.interface=接口只能擴展一個接口
non.backed.enum.cannot.implement.interface.backedenum=非備用枚舉無法實作接口 'BackedEnum'
non.enum.class.cannot.implement.interface=非枚舉類別無法實作接口 ''{0}''
notication.group.php.debugger=PHP 偵錯器
notification.content.composer.executable.was.automatically.set.to.global.composer=Composer 可執行檔案已被自動設定為全域 'composer'
notification.content.configure.manually=手動組態
notification.content.disable.breakpoint.move.to.resolved.position=停用中斷點移動到已解析的位置
notification.content.disable.paratest=停用 ParaTest
notification.content.formatter.couldn.t.apply.result.external.tool=格式化程序無法套用外部工具的結果
notification.content.language.level.synchronisation.with.composer.was.disabled=已停用與 composer.json 的語言級同步
notification.content.language.level.was.changed.to.based.on.project.usage=語言級別已根據專案中使用的功能設定為 {0}
notification.content.link.copied.to.clipboard=鏈接 {0} 已複製到剪貼簿
notification.content.phpunit.xml.configuration.file.was.migrated=PHPUnit XML 組態檔案已遷移
notification.content.process.exited.with.non.zero.code=程序以非零程式碼離開
notification.content.should.be.migrated=PHPUnit XML 組態使用了已棄用的架構。是否要使用 "--migrate-configuration" 遷移 XML 組態?
notification.content.tests.have.been.run.without.paratest=測試在沒有 ParaTest 的情況下執行
notification.content.timeout.while.fetching.data.from=從 {0} 提取資料時超時
notification.content.usage.found.in.project=在專案中找到了 {0} 用法
notification.content.vendor.directory.not.found=未找到 'vendor' 目錄
notification.content.xdebug.extension.not.installed=未安裝 Xdebug 擴展程序
notification.group.composer.install=建議使用 Composer 'install' 指令
notification.group.composer.language.level=已停用 Composer 語言級別同步
notification.group.dbgp.proxy=PHP 偵錯器代理
notification.group.debug.listener=PHP 偵錯偵聽器
notification.group.default.stubs=PHP 預設存根路徑不正確
notification.group.php=PHP
notification.group.php.3v4l=PHP 3v4l 整合
notification.group.php.birthday.discount=PHP 誕生 29 周年
notification.group.php.cgi=PHP-CGI 伺服器
notification.group.php.code.style=建議進行 PHP 程式碼樣式檢查
notification.group.php.interpreters=PHP 解釋器問題
notification.group.php.plugin.suggestion=PHP 延伸模組建議
notification.group.php.profiler=PHP 分析器問題
notification.group.phpunit=PHPUnit
notification.group.quality.tools=PHP 外部品質工具
notification.paratest.mute=忽略
notification.title.cannot.read.snapshot=無法讀取快照
notification.title.incorrect.profiler.snapshot.format=分析器快照格式不正確
notification.title.paratest.doesn.t.support.filter.option=ParaTest 不支持 --filter 選項
notification.title.phpunit=PHPUnit
null.cannot.be.marked.as.nullable='null' 不能被標記為可以為 null
number.of.days.in.the.given.month=給定月份中的天數(28 到 31)
numeric.representation.of.a.month.with.leading.zeros=月份的數字表示，帶前導零(01 到 12)
numeric.representation.of.a.month.without.leading.zeros=月份的數字表示，不帶前導零(1 到 12)
numeric.representation.of.the.day.of.the.week=星期几的數字表示(0 到 6)
object.property=物件屬性
older=較舊…
only.final.and.visibility.modifiers.can.be.applied.to.promoted.property=只有 'final' 和可見性修飾符可以應用於提升的屬性
only.intersection.type.can.be.used.for.grouping=只能使用交叉類型進行分組
only.intersection.type.can.be.used.for.grouping1=只能使用交叉類型進行分組
only.simple.expressions.are.allowed=只允許簡單表達式
only.the.last.parameter.can.be.variadic=只有最後一個參數可以是可變形參
open.in.editor=在編輯器中開啟
open.inspection.settings=開啟 {0} 檢查設定
open.tool.settings=開啟 {0} 設定
opens.composer.json.to.change.php.property=開啟 'composer.json' 以更改 'php' 屬性
opens.inspection.0.setting=開啟檢查 ''{0}'' 設定
operating.system.name.eg.freebsd=作業系統名稱。例如，FreeBSD
or.disable.inspection=或
output.phpinfo=輸出 phpinfo()\\:
output.phpinfo.title=輸出 phpinfo() 
override=覆寫
overriding.implementing.methods=覆寫/實作方法
overriding.private.methods=覆寫 private 方法
parameter=參數
parameter.is.deprecated=參數 ''{0}'' 已棄用
parameter.ref.type.is.not.compatible.with.declaration=參數 '\\#ref' 類型與宣告不相容
parameter.type.is.not.compatible.with.declaration=參數類型 ''{0}'' 與 ''{1}'' 不相容
parameter.type.is.not.convertible.from.null=參數類型不可從 'null' 轉換
parameter1=參數
paratest=ParaTest
paratest.is.not.supported.for.selected.run.profile=ParaTest 與所選執行組態檔案不相容
paratest.runner.description=使用 ParaTest 執行所選組態
pass.by.ref.is.not.effectively.used.inside.body=參照沒有必要，因為實參既不通過參照賦值，也不通過參照進一步傳遞
path.0.is.invalid=路徑 ''{0}'' 無效
path.to.php=<php 路徑>
patterns.are.matched.on.fully.qualified.name.parameter.count.and.parameter.names=模式會通過完全限定名稱、參數計數和參數名稱進行符合。
percentage.lines={0}% 行
phar.exclude.from.project.action.title=從專案中排除 phar
phar.failed.to.parse=無法解析
phar.include.into.project.action.title=將 phar 包含到專案中
php=PHP
php.5.6.is.not.supported=不支持下載 PHP 5.6 版本的 Xdebug 擴展程序
php.add.exception=將 ''{0}'' 新增到現有 @throws 標記
php.add.field.declaration.quick.fix.text=新增屬性
php.add.method.declaration.quick.fix.text=新增方法
php.add.tag.base.quick.fix.family.name=新增 {0} 標記
php.annotator.abstract.property.hook.cannot.have.a.body=abstract 屬性掛鈎不能有主體
php.annotator.abstract.property.must.specify.at.least.one.hook=abstract 屬性必須至少指定一個 abstract 掛鈎
php.annotator.cannot.declare.hooks.for.static.property=無法為 static 屬性宣告掛鈎
php.annotator.cannot.redeclare.property.hook.0=無法重新宣告屬性掛鈎 {0}
php.annotator.cannot.specify.default.value.for.virtual.hooked.property=無法為 virtual 掛鈎屬性指定預設值
php.annotator.cannot.use.the.0.modifier.on.a.property.hook=無法在屬性掛鈎上使用 {0} 修飾符
php.annotator.clone.as.callable='clone' 僅在 PHP 8.5 或更高版本中才可用作 callable
php.annotator.clone.expects.two.args='clone' 最多需要 2 個實參
php.annotator.exchange.extends.implements.keyword=將 ''{0} {2}'' 更改為 ''{1} {2}''
php.annotator.exit.or.die.as.callables='exit' 和 'die' 僅在 PHP 8.4 或更高版本中才可用作可調用對象
php.annotator.expecting.class=應為類別參照
php.annotator.expecting.interface=應為接口參照
php.annotator.get.hook.must.not.have.parameter.list='get' 掛鈎不能有參數列表
php.annotator.hooked.properties.cannot.be.readonly=掛鈎屬性不能為 'readonly'
php.annotator.interfaces.may.only.include.hooked.properties=接口只能包含掛鈎屬性
php.annotator.must.not.call.0.in.different.property=無法在另一個屬性(''{1}'')內呼叫 ''{0}'' 屬性的掛鈎
php.annotator.must.not.call.0.in.hook.1=無法從 ''{1}'' 屬性掛鈎呼叫 ''{0}'' 掛鈎
php.annotator.non.abstract.property.hook.must.have.a.body=非 abstract 屬性掛鈎必須有一個主體
php.annotator.only.hooked.properties.may.be.declared.abstract=只有掛鈎屬性才可以宣告為 abstract
php.annotator.parameter.of.set.hook.must.not.be.pass.by.ref='set' 掛鈎參數不能通過參照傳遞
php.annotator.parameter.of.set.hook.must.not.be.variadic='set' 掛鈎參數不能是可變的
php.annotator.parameter.of.set.hook.must.not.have.default.value='set' 掛鈎參數不能具有預設值
php.annotator.property.cannot.be.both.abstract.and.private=屬性不能同時為 abstract 和 private
php.annotator.property.cannot.be.both.final.and.private=屬性不能同時為 final 和 private
php.annotator.property.hook.cannot.be.both.abstract.and.final=屬性掛鈎不能同時為 abstract 和 final
php.annotator.property.hook.cannot.be.both.final.and.private=屬性掛鈎不能同時為 final 和 private
php.annotator.property.in.interface.cannot.be.explicitly.abstract=接口屬性不能為顯式 abstract。所有接口成員都是隱式 abstract
php.annotator.property.in.interface.cannot.be.final=接口中的屬性不能為 final
php.annotator.property.with.asymmetric.visibility.must.have.type=具有不對稱可見性的屬性必須指定類型
php.annotator.read.only.virtual.property.must.not.specify.asymmetric.visibility=無法為唯讀 virtual 屬性指定非對稱可見性
php.annotator.return.type.make.nullable.fix=使返回值類型可為 null
php.annotator.return.type.non.nullable.null.returned=無法返回 'null'\\: 返回值類型不可為 null
php.annotator.set.access.level.must.be.omitted=''{0}\\:\\:\${1}'' 的 ''set'' 存取級別必須省略(與類別 ''{2}'' 中一樣)
php.annotator.set.hook.must.accept.exactly.one.parameter='set' 掛鈎必須只接受一個參數
php.annotator.set.hook.type.parameter.must.compatible.property.type=參數類型必須與屬性類型相容
php.annotator.static.property.may.not.have.asymmetric.visibility=static 屬性不能具有不對稱可見性
php.annotator.strict.types.block.mode='strict_types' 宣告不能使用塊模式
php.annotator.strict.types.first.statement='strict_types' 宣告必須是腳本中的第一條語句
php.annotator.typed.class.constant.callable.is.illegal=類別常數不能具有 'callable' 類型
php.annotator.typed.parameter.type.mismatch.fix.change=將參數類型更改為 ''{0}''
php.annotator.typed.parameter.type.mismatch.fix.family=更改參數類型以符合預設值的類型
php.annotator.typed.parameter.type.mismatch.fix.nullable=使參數類型可為 null
php.annotator.typed.property.callable.is.illegal={0, choice, 0\\#屬性|1\\#類別常數}不能具有類型 'callable'
php.annotator.typed.property.illegal.value=類型 ''{1}'' 的{0, choice, 0\\#屬性|1\\#類別常數}可能沒有預設值
php.annotator.typed.property.type.mismatch=預設值只能是 ''{0}'' 類型
php.annotator.typed.property.type.mismatch.fix.change=將{0, choice, 0\\#屬性|1\\#類別常數}類型更改為 ''{1}''
php.annotator.typed.property.type.mismatch.fix.family=更改{0, choice, 0\\#屬性|1\\#類別常數}類型以符合預設值的類型
php.annotator.typed.property.type.mismatch.fix.nullable=使{0, choice, 0\\#屬性|1\\#類別常數}類型可為 null
php.annotator.visibility.of.property.must.not.be.weaker.than.set.visibility=屬性可見性不能比 'set' 可見性弱
php.annotator.void.function.must.not.return.value=void 函式不得返回值
php.annotator.with.properties.type=實參 '$withProperties' 必須是 'array' 類型
php.annotator.write.only.virtual.property.must.not.specify.asymmetric.visibility=無法為只寫 virtual 屬性指定不對稱可見性
php.append.doc.static.fix.family.name=在函式參照前追加 '\\:\\:'
php.birthday.button.buy=購買 PhpStorm
php.birthday.button.save=立即儲存
php.birthday.notification.1.content=為了慶祝 PHP 29 周年，新用戶可以享受特殊優惠。有效期至 2024 年 6 月 8 日。
php.birthday.notification.1.title=PhpStorm 可享受 29% 優惠
php.birthday.notification.2.content=PHP 29 周年慶，PhpStorm 優惠同步進行\\! 有效期至 2024 年 6 月 8 日。
php.birthday.notification.2.title=購買 PhpStorm 可節省 29%
php.cgi.not.found=請確保<a href\\="">組態的 PHP 解釋器</a>作為 CGI 程序建置(指定了 --enable-fastcgi)
php.cgi.not.found.title=找不到 {0}
php.change.cast.operation.quick.fix.family.name=將轉換更改為{0}
php.change.function.signature.from.usage.quick.fix.family.name=從用法改變函式簽名
php.change.function.signature.manually.quick.fix.family.name=手動更改簽名
php.change.method.modifiers.quick.fix.family.name=更改修飾符
php.change.method.modifiers.quick.fix.text=移除修飾符
php.change.signature.conflict.with.local.var=參數 ''{0}'' 與函式 ''{1}'' 內的區域變數衝突
php.change.signature.conflict.with.local.var.method=參數 ''{0}'' 與來自 ''{2}'' 的方法 ''{1}'' 內的區域變數衝突
php.check.validity.reg.exp=在專用對話框中檢查正則表達式的有效性
php.class=類別
php.codestyle.per.2.title=PER-CS 2.0.0
php.commit.checkin.configure.external.formatter=組態
php.commit.checkin.could.not.run.external.formatter=無法執行外部格式化程序
php.commit.checkin.progress.text.reformatting.code.with.external.formatter=正在使用外部格式化程序重新設定程式碼格式…
php.commit.checkin.run.external.formatter=執行外部格式化程序
php.configure.extensions.quick.fix.family.name=組態擴展存根
php.console=PHP 主控台
php.control.flow.viewer=PHP 控制流檢視器
php.control.flow.viewer.0=PHP 控制流檢視器\\: {0}
php.create.data.provider.quick.fix.family.name=建立資料提供程序
php.dead.code.entries=PHP 死碼條目
php.debug.action.include.return.value.breakpoint.step.description=啟用額外的“從函式返回”偵錯步驟
php.debug.action.watches.method.return.value.enable=啟用函式返回值偵錯
php.debug.action.watches.method.return.value.unavailable.reason=從 Xdebug 3.2 起才支援返回值偵錯
php.debug.state.widget=停止/啟動偵錯偵聽
php.debug.validate.got.it=偵錯驗證
php.debug.validate.got.it.descr=您可以使用偵錯驗證對話框驗證設定
php.delete.catch.clause.quick.fix=刪除 'catch' 子句
php.delete.exception.quick.fix=刪除異常
php.element.is.available.starting.with.php.version=''{0}'' 從 PHP 版本 {1} 開始可用
php.element.was.removed.in.php.version=''{0}'' 已在 PHP {1} 版本中被移除
php.embedded.stubs.incorrect.path.warning.message=組態的預設存根路徑 ''{0}'' 不存在，改為使用嵌入式存根。
php.embedded.stubs.incorrect.path.warning.title=預設存根路徑不正確
php.embedded.stubs.notification.provider.clone=在 GitHub 上克隆
php.embedded.stubs.notification.provider.do.not.show.again=不再顯示
php.embedded.stubs.notification.provider.notification=您正在檢視不可變的嵌入式存根。為了能夠編輯這些存根，您需要克隆一個存根專案，然後通過“PHP / PHP 執行時 / 進階設定”提供預設存根路徑。
php.embedded.stubs.notification.provider.provide=提供預設存根路徑
php.empty.project.generator.description=為 PHP 建立空專案
php.empty.project.generator.name=PHP 空專案
php.enable.extension.quick.fix.family.name=啟用擴展存根
php.enable.extension.quick.fix.text=啟用 ''{0}'' 擴展存根
php.enum=枚舉
php.exception.is.never.thrown=函式中從未拋出異常 ''{0}''
php.executable.macro.description=專案設定中組態的 Php 可執行檔案
php.external.formatter=PHP 外部格式化程序
php.external.formatter.title=外部格式化程序
php.extract.class=PHP 提取類別
php.find.clause.throws=可能拋出\\: {0}
php.flip.arguments.quick.fix.family.name=翻轉第一和第二個實參
php.flip.variable.and.type.quick.fix.family.name=翻轉變數和類型
php.framework.enable.plugin=啟用延伸模組
php.framework.install.plugin=安裝延伸模組
php.framework.laravel.plugin=Laravel Idea
php.framework.settings.page=設定
php.framework.symfony.plugin=Symfony
php.generation.code.style.title=程式碼生成
php.include.path.action.add.text=新增 Include 路徑
php.include.path.action.exclude.description=在此路徑下新增排除項以防止被編入索引
php.include.path.action.exclude.text=排除此路徑下的內容
php.include.path.excluded.file.description=從索引中排除
php.include.path.library.file.description=包括在索引中
php.info.parse.exception=無法解析 php 資訊\\: {0} 是空的
php.information.dialog.title=PHP 資訊
php.inline.variable.quick.fix.family.name=內聯變數
php.inspection.redundant.final.modifier='final' 修飾符冗餘，具有 private 'set' 可見性的屬性為隱式 final
php.intention.category=PHP
php.interface=接口
php.interpreter.base.configuration.fix.interpreter={0}。要修復，請<a href\\=''{1}''>更改</a>專案解釋器或<a href\\=''{2}''>檢查</a>設定。
php.interpreter.base.configuration.interpreter.is.invalid=無法執行 {0}，因為{1}組態的解釋器無效。
php.interpreter.base.configuration.is.not.provided.or.empty={1} 的 {0} 路徑未組態。您可以在“PHP|{0}”下進行修復
php.interpreter.base.configuration.working.directory=無法檢測工作目錄，請在執行組態中進行組態。
php.interpreter.configurable.description.laravel.herd=Herd
php.interpreter.configurable.description.main.laravel.herd=主要 Herd
php.interpreter.custom.ini.label=組態檔案\\:
php.interpreter.info.failed.to.parse.validation.script=無法解析驗證腳本輸出
php.interpreter.is.remote.message=請<a href\\="">選擇本地 PHP 解釋器</a>以使用內建 Web 伺服器
php.interpreter.is.remote.title=已組態遠端 PHP 解釋器
php.interpreter.label.label=標籤
php.interpreter.not.configured=請<a href\\="">組態 PHP 解釋器</a>以使用內建 Web 伺服器
php.interpreter.not.configured.title=未組態 PHP 解釋器
php.interpreters.configurable.group.name.laravel.herd.interpreters=Laravel Herd 解釋器
php.language.level.widget=PHP 語言級別
php.llm.smart.chat.searching.for.bundles=正在搜尋捆綁包…
php.llm.smart.chat.searching.for.controller=正在搜尋控制器…
php.llm.smart.chat.searching.for.entity=正在搜尋實體…
php.llm.smart.chat.searching.for.events=正在搜尋事件…
php.llm.smart.chat.searching.for.middlewares=正在搜尋中間件…
php.llm.smart.chat.searching.for.model=正在搜尋模型…
php.make.class.abstract.quick.fix.family.name=將類別設為 abstract
php.make.class.non.final.quick.fix.family.name=將類別設為非 final
php.make.field.non.final.quick.fix.family.name=將欄位設為非 final
php.make.method.non.abstract.quick.fix.family.name=將方法設為非 abstract
php.make.method.non.final.quick.fix.family.name=將方法設為非 final
php.make.method.non.static.quick.fix.family.name=將方法設為非 static
php.make.property.hook.non.final.quick.fix.family.name=將屬性掛鈎設為非 final
php.method.name.empty=未指定測試方法
php.method.not.found=在類別 ''{1}'' 中未找到方法 ''{0}''
php.non.strict.object.equality.quick.fix.text=取代為身份比較
php.not.test.method=類別 ''{1}'' 中的方法 ''{0}'' 不是測試方法
php.path.was.updated={0} 自訂
php.path.was.updated.text=專案預設解釋器已被新增到 {0}
php.prefdefined.codestyle.psr12.chosen.message=您可以啟用其他 PSR-12 檢查，這些檢查當前已停用。
php.prefdefined.codestyle.psr12.chosen.title=PSR-12 程式碼樣式
php.prefdefined.codestyle.psr12.enabled.message=PSR-12 檢查已啟用。
php.project.configurable.composer.configs.tab.name=Composer 檔案
php.project.configurable.composer.duplicate.configurations=已經存在具有相同 composer.json 的組態
php.project.configurable.composer.main=主
php.property.hooks.search.setter.getter.usages=正在搜尋 getter 和 setter 用法…
php.quick.documentation.namespace.classes=命名空間類別\\:
php.quick.fix.add.property.hooks=新增屬性掛鈎
php.quick.fix.change.append.field.declared.type=將參數類型更改為 {0}
php.quick.fix.leave.one.hook.parameter.family.name=只保留一個參數
php.quick.fix.remove.default.value=移除預設值
php.quick.fix.remove.parameter.list=移除參數列表
php.remote.debug.name=PHP 遠端偵錯
php.remote.interpreter.plugin.is.not.installed=PHP Remote Interpreter 延伸模組未安裝
php.remove.all.unused.parameters.quick.fix.text=移除所有未使用的參數
php.remove.doc.tag.quick.fix.family.name=移除 {0}
php.remove.exception.from.throws=從 @throws 標記中移除 ''{0}''
php.remove.parameters.quick.fix.text=移除未使用的參數
php.remove.pass.by.ref.from.parameter.quick.fix.family.name=從參數中移除 '&'
php.remove.ref.from.assignment.quick.fix.family.name=將 '\\=\\\\&' 取代為 '\\='
php.remove.ref.from.function.declaration.quick.fix.family.name=從函式宣告中移除 '&'
php.remove.statement.fix.family.name=移除
php.remove.throws.tag=從 @throws 標記移除
php.remove.unused.local.variable.without.successor.quick.fix.family.name=移除變數 ''{0}''
php.rename.wrong.reference.quick.fix.family.name=重新命名參照
php.replace.argument.with.cast.quick.fix.family.name=將實參轉換為{0}
php.replace.try.from.with.null.quick.fix.family.name=將 'tryFrom()' 呼叫取代為 'null'
php.replace.with=取代為 ''{0}''
php.replace.with.float.cast.quick.fix.family.name=取代為 '(float)' 轉換
php.replace.with.interface.quick.fix.family.name=取代為 {0}
php.replace.with.local.variable.quick.fix.family.name=將屬性取代為區域變數
php.replace.with.null.quick.fix.family.name=取代為 'null'
php.run.check.reg.exp=執行檢查 RegExp 意圖 {0}
php.run.http.border.title.configuration=組態
php.run.label.https=HTTPS\\:
php.run.label.interpreter=解釋器\\:
php.run.label.query.string=查詢字串\\:
php.run.label.request.body=請求正文\\:
php.run.label.request.method=請求方法\\:
php.run.label.send.request.body.as=將請求正文發送為\\:
php.run.label.server=伺服器\\:
php.run.label.url=URL\\:
php.run.radio.button.key.value=鍵值
php.run.radio.button.text=文本
php.structure.view.dumb.mode.resolving=正在解決…
php.surround.with.if=if
php.surround.with.try.catch.quick.fix=使用 'try-catch' 包圍
php.tag.is.deprecated={0} 已棄用，將在 PHPUnit 9 中移除
php.terminal.artisan.command.description=Laravel Artisan
php.terminal.composer.command.description=PHP 的相依項管理器
php.terminal.file.path.argument.description=用於執行分析的原始碼路徑
php.terminal.php.command.description=執行 PHP 解釋器
php.terminal.phpstan.command.description=PHPStan
php.terminal.psalm.command.description=Psalm
php.terminal.sail.command.description=Laravel Sail
php.terminal.symfony.command.description=Symfony 主控台
php.terminal.word.press.command.description=通過命令行管理 WordPress
php.terminal.word.press.info.option=列印有關 WP-CLI 環境的各種詳細資訊
php.test.framework.by.sdk.dialog.label=解釋器(&I)\\:
php.test.framework.by.sdk.new.settings.dialog.title=通過遠端解釋器{0}
php.test.framework.by.sdk.settings.already.exist=所選解釋器的 {0} 設定已存在
php.test.framework.by.sdk.settings.remote.path.title=選擇伺服器上的路徑
php.test.framework.by.sdk.settings.select.server=選擇遠端解釋器以組態遠端{0}
php.test.framework.configuration.can.not.update=無法更新 {0} 版本
php.test.framework.configuration.ui.library={0} 庫
php.test.framework.configuration.ui.not.installed=未安裝
php.test.framework.configuration.ui.path.to.exe={0} 可執行檔案路徑\\:
php.test.framework.configuration.ui.select.interpreter=請選擇 PHP 解釋器以載入 {0} 版本
php.test.framework.configuration.ui.select.local.interpreter=請選擇本地 PHP 解釋器以載入 {0} 版本
php.test.framework.configuration.ui.test.runner=測試執行程序
php.test.framework.configuration.ui.use.configuration.file=預設組態檔案\\:
php.test.framework.configuration.ui.version={0} 版本\\: {1}
php.test.framework.configuration.updated.version=已成功更新 {0} 版本
php.test.framework.default.interpreter.is.not.local=無法檢測到 {0} 版本。預設 PHP 解釋器不是本地解釋器
php.test.framework.download.hyperlink={0} 版本\\: <a href\\={1}>{1}</a>
php.test.framework.field.test.runner.options=測試執行程序選項(&O)\\:
php.test.framework.interpreter.conflict=發現應用程式級 {0} 組態衝突。為解決該問題，建立了以下組態的專案級副本\\:
php.test.framework.interpreter.conflict.title={0} 組態衝突
php.test.framework.no.configuration.types.are.available=沒有可用的其他組態類型
php.test.framework.project.level=(當前專案)
php.test.framework.run.configuration.ui.alternative.configuration.file=使用替代組態檔案(&U)\\:
php.test.framework.run.configuration.ui.alternative.custom.file=使用替代 {0}(&U)
php.test.framework.run.configuration.ui.configuration.radio.button=在組態檔案中定義(&C)
php.test.framework.run.configuration.ui.custom.file.radio.button=在 {0} 中定義
php.test.framework.run.configuration.ui.directory.radio.button=目錄 (&D)
php.test.framework.run.configuration.ui.directory.text.field=目錄\\:
php.test.framework.run.configuration.ui.file.radio.button=檔案(&F)
php.test.framework.run.configuration.ui.file.text.field=檔案\\:
php.test.framework.run.configuration.ui.scenario.radio.button=方法(&M)
php.test.framework.run.configuration.ui.scenario.text.field=方法\\:
php.test.framework.run.configuration.ui.scope=測試作用域\\:
php.test.framework.run.configuration.ui.type.combo.box=類型\\:
php.test.framework.run.configuration.ui.type.radio.button=類型(&T)
php.test.framework.run.confuguration.ui.dialog.caption.test.runner.options=測試執行程序選項
php.test.framework.select.type.of.settings.popup.title=選擇組態類型
php.test.framework.settings.is.not.provided.or.empty={1} 的 {0} 路徑未組態。按“修復”以編輯您的 {0} 組態。
php.test.framework.undefined.interpreter=未定義
php.test.framework.untrusted.reload=在安全模式下禁止重新整理測試框架的版本
php.test.framework.validation.run.configuration.file.working.directory=檔案應該是工作目錄的子項\\: ''{0}''
php.test.framework.validation.run.configuration.method=在 ''{1}'' 中找不到 ''{0}''
php.test.framework.validation.run.configuration.no.type=如果未選擇類型則無法執行測試。
php.test.framework.validation.run.configuration.unsupported.type=無法通過 ''{0}'' 指令執行測試。
php.test.framework.validation.run.configuration.working.directory=目錄應該是工作目錄的子目錄\\: ''{0}''
php.test.framework.version.configuration.ui.can.not.parse.version=無法解析版本指令輸出。\\n{0}
php.test.framework.version.detector.empty.output=''{0}'' 指令輸出為空。
php.test.framework.version.getting.version.title=正在獲取 {0} 版本…
php.test.framework.version.path.to.exe.is.invalid={0} 可執行檔案的路徑為空或無效。
php.test.frameworks.form.application=\\ (應用程式)
php.testframework.local.interpreter=本地解釋器
php.testframework.local.interpreter.version=本地 PHP {0}
php.testframework.remote.interpreter=遠端 {0}
php.title.docker.compose.settings=Docker Compose 設定
php.trait=特徵
php.turn.off.path.modification=關閉 {0} 自訂
php.uml.provider.presentable.name=PHP 類別圖
php.unit.checkbox.use.alternative.patterns.base.path=使用替代模式基路徑\\:
php.unit.create.target.class.quick.fix.family.name=建立缺少的目標類別
php.unit.create.target.method.quick.fix.family.name=建立缺少的目標方法
php.unit.label.test.file.template=測試檔案模板(&T)\\:
php.unit.local.run.description=PHPUnit
php.unit.local.run.display.name=PHPUnit
php.unit.optional=可選
php.unit.radio.button.composite=複合
php.unit.test.runner.options=測試執行程序選項
php.web.application.name=PHP Web 應用程式
php.web.server.validation.action.text=Web 伺服器偵錯驗證
php.web.server.validation.additional.configuration.files=<b>已解析的其他 .ini 檔案\\:</b> {0}
php.web.server.validation.chose.path.to.script=選擇驗證腳本的路徑
php.web.server.validation.chose.path.to.script.description=選擇本地目錄以建立驗證腳本
php.web.server.validation.client.host.is.reachable=<b>偵錯客戶端主機</b>\\: 可以存取
php.web.server.validation.client.host.is.unreachable=<b>偵錯客戶端主機</b>\\: 無法存取
php.web.server.validation.client.host.is.unreachable.descr=請確保已正確組態 <i>xdebug.remote_host</i> (適用於 Xdebug 2)、<i>xdebug.client_host</i> (適用於 Xdebug 3)或 zend_debugger。值可以是執行 PhpStorm 的機器的主機名(例如，localhost)或 IP 地址，並且必須可以從伺服器 ping 通。使用 Xdebug 時，<i>xdebug.remote_connect_back</i> (適用於 Xdebug 2)或 <i>xdebug.discover_client_host</i> (適用於 Xdebug 3)可用於故障排除。
php.web.server.validation.client.phpstorm.is.reachable=<b>PhpStorm\\:</b> 準備接收 Xdebug 連線
php.web.server.validation.client.phpstorm.is.unreachable=<b>PhpStorm\\:</b> 無法接收 Xdebug 連線
php.web.server.validation.client.phpstorm.is.unreachable.descr=偵聽傳入偵錯連線可能被停用，或者可能在設定中為傳入連線指定了錯誤的連接埠
php.web.server.validation.configuration.files=<b>已載入的 php.ini\\:</b> {0}
php.web.server.validation.configure.local=指定文檔根下的目錄路徑及其對應的 URL
php.web.server.validation.configure.phpinfo=請貼上 <i>phpinfo()</i> 的完整輸出
php.web.server.validation.configure.phpinfo.desc=複製並貼上 HTML 版本、HTML 原始碼或 <i>php -i</i> 輸出
php.web.server.validation.configure.remote=指定目錄路徑並選擇部署伺服器
php.web.server.validation.configure.validation.script=複製下載腳本指令，在正在執行的 Web 伺服器上執行，並檢查 URL 的輸出
php.web.server.validation.deployment.server=部署伺服器(&D)\\:
php.web.server.validation.deployment.server.tooltip=所選伺服器會用於將驗證腳本部署到遠端伺服器
php.web.server.validation.dialog.validate.button=驗證(&V)
php.web.server.validation.docker=<b>在 Docker 容器中</b>\\: {0}
php.web.server.validation.failed.to.deploy.validation.script=無法將驗證腳本部署到伺服器
php.web.server.validation.failed.to.execute.script=指定的 URL 不可到達，原因是\\: ''{0}''
php.web.server.validation.failed.to.fetch.script.result=無法提取驗證腳本的結果
php.web.server.validation.failed.to.find.deployment.settings=找不到伺服器的部署設定
php.web.server.validation.failed.to.find.web.path=請組態驗證腳本的 Web 路徑
php.web.server.validation.failed.to.map.deployment.folder=請為驗證目錄組態遠端路徑映射
php.web.server.validation.failed.to.map.deployment.folder.to.web=請為驗證目錄組態 Web 路徑映射
php.web.server.validation.failed.to.unzip=無法從 {0} 提取資料
php.web.server.validation.invalid.path.to.script=驗證目錄的路徑無效
php.web.server.validation.loaded.debugger.extension=<b>偵錯器擴展\\:</b> {0}
php.web.server.validation.local.path.to.script=放置驗證腳本的目錄(&D)\\:
php.web.server.validation.local.path.to.script.tooltip=所選路徑應可通過 Web 伺服器存取
php.web.server.validation.local.web.server.radio=本地 Web 伺服器或共享目錄(&L)
php.web.server.validation.multi.debugger.extension=Xdebug 和 Zend Debugger 擴展均已載入
php.web.server.validation.multi.debugger.extension.description=只有一個偵錯器擴展可在 php.ini 中載入。
php.web.server.validation.no.configuration.files=找不到 php.ini 檔案
php.web.server.validation.no.debugger.extension=未載入偵錯擴展
php.web.server.validation.os=<b>客戶端主機作業系統</b>\\: {0}
php.web.server.validation.os.server=<b>伺服器主機作業系統</b>\\: {0}
php.web.server.validation.process.title=驗證 Web 伺服器
php.web.server.validation.reference.to.documentation=請參閱<a href\\="{0}">{0}</a>獲取更多資訊。
php.web.server.validation.remote.web.server.radio=遠端 Web 伺服器(&R)
php.web.server.validation.script.local.result.path.mapping.check=請檢查是否為 <b>''{0}''</b> 目錄正確組態了驗證腳本的 Web 路徑
php.web.server.validation.script.result.is.empty=驗證腳本的結果為空
php.web.server.validation.script.result.path.mapping.check=請檢查是否在部署設定中為 <b>''{0}''</b> 目錄正確組態了遠端和 Web 路徑映射
php.web.server.validation.script.result.wrong.format=驗證腳本的結果具有意外格式
php.web.server.validation.server.name=<b>伺服器名稱\\:</b> {0}
php.web.server.validation.server.name.is.empty=伺服器名稱為空
php.web.server.validation.server.name.is.empty.description=PhpStorm 內部需要使用伺服器名稱進行識別。<br> 在 Web 伺服器組態檔案中組態伺服器名稱。
php.web.server.validation.synonym=驗證偵錯
php.web.server.validation.synonym2=驗證 Xdebug
php.web.server.validation.title=驗證 Web 伺服器上的偵錯器組態
php.web.server.validation.uploading.validation.script=正在將驗證腳本上傳至 {0}
php.web.server.validation.url.to.validation.script=指向包含腳本的目錄的 URL(&U)\\:
php.web.server.validation.url.to.validation.script.tooltip=所選 Web 路徑將用於執行驗證腳本
php.web.server.validation.xdebug.debugger.host=<b>遠端主機\\:</b> {0}
php.web.server.validation.xdebug.debugger.host.description=正在執行偵錯器<b>客戶端</b>的主機。
php.web.server.validation.xdebug.debugger.host.remote.addr=<br/><br/>在 php.ini 檔案中，將 <b>''{0}''</b> 設為 <i>''{1}''</i> 或自 Web 伺服器可見的本地機器 IP 地址。
php.web.server.validation.xdebug.debugger.localhost=儘管伺服器主機可能不在本地，但遠端主機仍組態為 ''{0}''
php.web.server.validation.xdebug.mode.is.not.supported=不支持遠端模式 ''{0}''
php.web.server.validation.xdebug.option.is.enabled=<b>{0}\\:</b> 選項已啟用
php.web.server.validation.xdebug.option.is.ignored.description=<b>{0}\\:</b> 選項將被忽略。
php.web.server.validation.xdebug.option.is.not.enabled.description=<b>{0}\\:</b> 選項未啟用
php.web.server.validation.xdebug.port=<b>遠端連接埠\\:</b> {0}
php.web.server.validation.xdebug.port.require.sudo=<b>遠端連接埠\\:</b> {0}，需要根權限才能使用
php.web.server.validation.xdebug.port.require.sudo.description=要在 Linux 和 Mac 上使用小於 1024 的連接埠，必須具有根權限。
php.web.server.validation.xdebug.protocol.is.not.supported=不支持偵錯協議 ''{0}''
php.web.server.validation.xdebug.remote.autostart.description=偵錯會話將嘗試為每個請求啟動。
php.web.server.validation.xdebug.remote.is.not.enable=遠端偵錯未啟用
php.web.server.validation.xdebug.remote.is.not.enable.description=將 <b>''{0}''</b> 行新增到 php.ini 檔案。
php.web.server.validation.xdebug.remote.log=<b>{0}\\:</b> {1}
php.web.server.validation.xdebug.remote.mode.jit=<b>遠端模式\\:</b> 'jit'
php.web.server.validation.xdebug.remote.mode.jit.description=偵錯會話將僅在出現錯誤後初始化。
php.web.server.validation.xdebug.remote.mode.req=<b>遠端模式\\:</b> 'req'
php.web.server.validation.xdebug.remote.mode.req.description=偵錯會話將在腳本啟動時初始化。
php.web.server.validation.xdebug.wrong.port=Xdebug 連接埠(''{0}'')與“PHP->偵錯 IDE”設定(''{1}'')不同
php.web.server.validation.xdebug.wrong.port.description=來自 php.ini (<b>{0}</b>)的 Xdebug 連接埠應與在 IDE 內(在 <b>PHP->偵錯</b>下)組態的連接埠相同。
php.web.server.validation.xdebug.wrong.port.format=<b>Xdebug 連接埠無效\\:</b> ''{0}''
php.web.server.validation.xdebug.zend.extension.load=Xdebug 必須通過 'zend_extension' 而不是 'extension' 載入
php.web.server.validation.xdebug.zend.extension.load.description=在 php.ini 檔案中使用 <b>'zend_extension\\=path_to_xdebug.so'</b> 行以載入 Xdebug 擴展。
php.web.server.validation.xdebug3.cloud.php.ini.xdebug.disabled.message=<b>Php.ini 雲偵錯\\:</b> 已停用。
php.web.server.validation.xdebug3.cloud.xdebug.correct.cloud.id.message=<b>IDE 中的雲 ID\\:</b> 與伺服器上的雲 ID 相同
php.web.server.validation.xdebug3.cloud.xdebug.disabled.message=<b>通過 Xdebug Cloud 連線</b>\\: 已停用。在 IDE 設定中啟用\\: <b>PHP->偵錯->XDebug Cloud</b>
php.web.server.validation.xdebug3.cloud.xdebug.doesnt.accept.connections.message=Xdebug 現在不接受外部連線
php.web.server.validation.xdebug3.cloud.xdebug.wrong.cloud.id.description=<b>IDE 中的雲 ID\\:</b> {0}<br><b>伺服器上的雲 ID\\:</b> {1}
php.web.server.validation.xdebug3.cloud.xdebug.wrong.cloud.id.message=<b>IDE 中的雲 ID\\:</b> 與伺服器上的雲 ID 不同
php.web.server.validation.xdebug3.discover.client=該設定預設處於停用狀態。如果啟用，Xdebug 會嘗試自動連線到發出 HTTP 請求的偵錯客戶端。
php.web.server.validation.xdebug3.discover.client.message=<b>發現客戶端主機</b>\\: Xdebug 將嘗試自動提取客戶端主機。
php.web.server.validation.xdebug3.discover.client.no=<b>發現客戶端主機</b>\\: 關閉
php.web.server.validation.xdebug3.discover.client.with.discover.header=根據 <b>$_SERVER[''{0}'']</b> 中的值，Xdebug 將嘗試自動連線到客戶端。若失敗，則以空的 <b>''xdebug.client_discovery_header''</b> 回到 <b>''xdebug.discover_client_host''</b>。
php.web.server.validation.xdebug3.option.in.invalid.mode=''{0}'' 選項設定為 ''{1}''，這對於 xdebug3 是無效模式。
php.web.server.validation.xdebug3.option.is.enabled.message=<b>{0}</b>\\: 選項被設定為 ''{1}''。
php.web.server.validation.xdebug3.remote.mode.emulation.description=偵錯會話將在腳本啟動時初始化，與 xdebug2 的 <b>remote_mode\\=''{0}''</b> 相同。
php.web.server.validation.xdebug3.remote.mode.emulation.message=<b>遠端模式\\:</b> xdebug2 的 ''{0}'' 已模擬。 
php.web.server.validation.xdebug3.start.upon.error.description=偵錯會話將嘗試根據相應組態在錯誤時自動啟動。
php.web.server.validation.xdebug3.start.with.request.description=偵錯會話將嘗試根據相應組態自動啟動。
php.web.server.validation.zend.debugger.deny.host=<b>拒絕主機\\:</b> {0}
php.web.server.validation.zend.debugger.deny.host.description=無法使用拒絕主機從客戶端進行偵錯。
php.web.server.validation.zend.debugger.host=<b>遠端主機\\:</b> {0}
php.web.server.validation.zend.debugger.localhost=儘管伺服器不在本地，但偵錯會話僅適用於本地主機。
php.web.server.validation.zend.debugger.localhost.description=將正在執行偵錯器<b>客戶端</b>的主機新增至 <b>'zend_debugger.allow_hosts'</b> 選項。
php.web.server.validation.zend.expose.remotely=<b>屬性 ''expose_remotely''</b> 設為 ''{0}''
php.web.server.validation.zend.expose.remotely.allowed.hosts.description=偵錯器會話將嘗試從 <b>'zend_debugger.allow_hosts'</b> 選項為主機啟動。
php.web.server.validation.zend.expose.remotely.always.description=偵錯器會話將嘗試為每個客戶端啟動。
php.web.server.validation.zend.expose.remotely.never.description=偵錯器會話將不會進行初始化，<b>'zend_debugger.allow_hosts'</b> 選項將被忽略。<br>將選項 <b>'zend_debugger.expose_remotely'</b> 設定為 'allowed_hosts' 或 'always' 以啟用 Web 伺服器偵錯。
php.web/server.validation.validation.script=偵錯驗證腳本
php.xdebug.enable.dfa.assist=預測分析程序數據流的未來條件值
php.xdebug.enable.dfa.assist.gray.mode=將預計不可到達的程式碼塊變灰
php.xdebug.move.to.resolve.breakpoint=如果中斷點與源不同，則將中斷點移動到已解析的位置
phpdoc.code.style.throws.analysis.depth.performance.note.message=不建議深入分析多個級別，因為這可能會影響 IDE 性能。要繼續嗎?
phpdoc.code.style.throws.analysis.depth.performance.note.title=性能註釋
phpunit.10.won.t.support.classname.annotations=PHPUnit 10 將不支持 ClassName\\:\\:<*> 註解
phpunit.can.not.rerun.failed.tests.title=無法執行失敗的 PHPUnit 測試。
phpunit.config.directory.label=目錄\\:
phpunit.config.empty.pattern=空模式
phpunit.config.label=測試根
phpunit.getting.phpunit.version=正在更新 PhpUnit 版本…
phpunit.label.data.set=資料集\\:
phpunit.not.tests.was.executed.message=要修復，為 <i>{0}</i> <a href\\="config">組態</a>自動載入檔案或 PHPUnit phar 路徑。
phpunit.not.tests.was.executed.title=未組態 PHPUnit
platform.reqs.are.missing=缺少平台要求。
plural.types.are.not.allowed.in.real.types=僅在 doc 類型中允許複數類型
popup.content.configuration.remains.unchanged=當前組態與解釋器同步
popup.content.enabled.disabled.extensions=已啟用{0}和已停用{1}擴展
popup.select.target.code.block.closure=箭頭函式體(轉換為閉包)
popup.select.target.code.block.containing.block=包含塊
popup.title.multiple.write.scopes.found=找到多個寫入作用域
popup.title.select.reference.to.remove=選擇要移除的類型
popup.title.select.target.code.block=選擇目標程式碼塊
possible.tool.process.hangup.after.0.sec={0} 秒後可能工具過程掛起。
postfix.template.provider.display.name=PHP
potentially.polymorphic.call.multiple.subclasses=潛在的多態呼叫。該程式碼可能無法動作，具體取決於作為實參傳遞的實際類別實例。
potentially.polymorphic.call.single.subclass=潛在的多態呼叫。{0} 的層次結構中沒有成員
primitive.hints.name.are.forbidden.in.php.7=PHP 7 中禁止名為 'int'、'string'、'float'、'bool'、'true'、'false' 和 'null' 的類別
private.constant.cannot.be.final='private' 常數不能為 'final'，因為它對其他類別不可見
private.methods.cannot.be.final=private 方法不能是 final，因為它們從不會被其他類別覆寫
proceed=繼續
profiler.button.refresh=重新整理
profiler.column.invocation.callable=可調用
profiler.column.invocation.count.title=呼叫
profiler.column.memory.title=記憶體(B)
profiler.column.own.memory.title=自身記憶體(B)
profiler.column.own.time.title=自用時間
profiler.column.script=腳本
profiler.column.time.title=時間
profiler.label.time=時間\\:
profiler.measurement.unit.microsecond=微秒
profiler.measurement.unit.microsecond.short=µs
profiler.measurement.unit.millisecond=毫秒
profiler.measurement.unit.millisecond.short=毫秒
profiler.measurement.unit.second=秒
profiler.measurement.unit.second.short=秒
profiler.view.call.tree.title=呼叫樹
profiler.view.callees.title=被呼叫方
profiler.view.callers.title=呼叫方
profiler.view.execution.statistics.title=執行統計
profiler.xdebug.file.chooser.title=選擇 Xdebug 分析器快照
profiler.xdebug.task.parsing=正在解析 ''{0}''
profiler.xdebug.task.title=分析 Xdebug 分析器快照
progress.text.fetching.result.from=正在從 {0} 提取結果
progress.text.submitting.code.to.3v4l.org=正在將程式碼提交到 3v4l.org
progress.title.executing.3v4l.org=正在 3v4l.org 上執行程式碼
progress.title.initializing.git.repository=正在初始化 Git 儲存庫
project.files=專案檔案
project.is.already.disposed=專案已被處置
promoted.property=提升屬性
property=屬性
property.declaration=屬性宣告
property.is.undefined=屬性 '\\#ref' {0,choice,0\\#未定義|1\\#可能未定義}
property.is.undefined.in.class=屬性 ''\\#ref'' 在 {0} 中{1,choice,0\\#未找到|1\\#可能未定義}
property.or.function=屬性或函式
property.read=@property-read
property.write=@property-write
provide.the.full.path.to.executable=提供可執行檔案的完整路徑。
psr.12.add.missing.parameter.list=PSR-12\\: 新增缺少的參數列表
psr.12.add.public.visibility=PSR-12\\: 新增 'public' 可見性
psr.12.convert.to.short.form=PSR-12\\: 轉換為縮寫
psr.12.extract.namespace=PSR-12\\: 提取命名空間
psr.12.fix.modifiers.order=PSR-12\\: 修復修飾符順序
psr.12.replace.var.with.public=PSR-12\\: 將 'var' 取代為 'public'
psr.12.split.to.several.use.statements=PSR-12\\: 拆分為多個 'use' 語句
psr.roots.revert=還原
public.and.static='public' 和 'static'
quality.inspection.button.tooltip=該按鈕顯示相應的檢查是否開啟
quality.tool.action.clean.list.text=清除列表
quality.tool.action.remove.file.s.from.list.text=從列表中移除檔案
quality.tool.border.title.ignored.files=已忽略的檔案
quality.tool.button.validate=驗證
quality.tool.can.not.create.temporary.file=PhpStorm 無法建立臨時檔案
quality.tool.can.not.determine.version=無法確定工具版本，得到 ''{0}''
quality.tool.can.not.retrieve.standards=無法檢索可用規則集，請檢查 PHP CS Fixer 工具組態。
quality.tool.checkbox.installed.standard.paths=已安裝的標準路徑\\:
quality.tool.checkbox.show.sniff.name=顯示 sniff 名稱
quality.tool.checkbox.show.warning.as=將警告顯示為\\:
quality.tool.coding.stardards.has.been.updated=已安裝的編碼標準列表已更新。
quality.tool.configuration.can.not.find.configuration.by.id=按 ID 找不到 {0} 組態\\: ''{1}''
quality.tool.configuration.default.interpreter.is.not.found=預設選擇 {0} 組態解釋器，但未指定解釋器
quality.tool.configuration.for.interpreter.is.not.found=找不到解釋器的 {0} 組態\\: ''{1}''
quality.tool.configuration.interpreter.is.undefined={0} 組態的解釋器未指定或無效
quality.tool.configuration.tool.path.is.empty=所選組態的 {0} 路徑為空
quality.tool.cs.fixer.allow.risky.rules=允許為內建規則集設定有風險的規則
quality.tool.cs.fixer.custom.rules.warning=選擇 'Custom' 類型以選擇您的組態。
quality.tool.cs.fixer.reformat.action=PHP CS Fixer\\: 修復整個檔案
quality.tool.cs.fixer.ruleset=規則集\\:
quality.tool.empty.path.phpcs={0} 的路徑為空
quality.tool.file.not.found=找不到檔案。
quality.tool.ignored.files={0} 忽略的檔案
quality.tool.label.check.files.with.extensions=檢查帶副檔名的檔案\\:
quality.tool.label.coding.standard=編碼標準\\:
quality.tool.label.configuration=組態\\:
quality.tool.label.custom.rulesets=自訂規則集\\:
quality.tool.label.label=標籤
quality.tool.label.tool.path=工具路徑\\:
quality.tool.label.tool.process.timeout=工具處理超時，[1...60] 秒\\:
quality.tool.label.validation.label=驗證標籤
quality.tool.laravel.pint=Laravel Pint
quality.tool.laravel.pint.json.path=pint.json 的路徑\\:
quality.tool.laravel.pint.quick.fix.text=Laravel Pint\\: 修正整個檔案
quality.tool.laravel.pint.reformat.only.uncommitted.files=僅重新設定未提交檔案的格式
quality.tool.laravel.pint.ruleset=規則集\\:
quality.tool.laravel.pint.should.be.json.file=選擇 .json 檔案
quality.tool.path.must.not.be.empty=路徑不得為空。
quality.tool.php.cs.fixer.required.phpcs.version=支援的 PHP CS Fixer 版本為 2.8.0 或更高，找到的是 {0}
quality.tool.php.dir.does.not.contain=該目錄不包含{0}
quality.tool.php_cs.custom.rules.validation.not.php_cs=PHP CS Fixer 不支持所選規則集
quality.tool.php_cs.dir.does.not.contain.custom=此目錄不包含任何受支援的檔案\\: {0}
quality.tool.phpcbf.location=PHPCBF 位置
quality.tool.phpcbf.location.descr=選擇有效的 phpcbf 啟動器
quality.tool.phpcbf.name=PHP Code Beautifier and Fixer
quality.tool.phpcbf.path=phpcbf 路徑\\:
quality.tool.phpcbf.reformat.action=PHP Code Beautifier and Fixer\\: 修復整個檔案
quality.tool.phpcbf.settings=PHP Code Beautifier and Fixer 設定
quality.tool.phpcs.can.not.retrieve.standards=無法檢索可用標準，請檢查 PHP_CodeSniffer 工具組態。
quality.tool.phpcs.custom.rules.validation.not.xml=所選規則集不是 XML
quality.tool.phpcs.custom.rules.warning=選擇 'Custom' 編碼標準類型以選擇自訂規則集。
quality.tool.phpcs.installed.paths=已安裝的標準路徑
quality.tool.phpcs.label.path.to.ruleset=規則集路徑\\:
quality.tool.phpcs.required.phpcs.version=所需的 PHP_CodeSniffer 版本為 1.5.0 或更高，找到的是 {0}
quality.tool.selected.file.is.not.phpcbf=所選檔案不是 phpcbf 可執行檔案
quality.tool.settings.link.inspection={0} 檢查\\:
quality.tool.stardards.has.been.updated=已安裝的規則集列表已更新。
quality.tools.0.added.to.ignored.files.list={0}已新增到忽略的檔案列表。
quality.tools.custom.coding.standard=自訂編碼標準
quality.tools.label.by.default.project.interpreter=預設為專案解釋器
quality.tools.provider.tooltip=此檔案被排除在外部品質工具分析和格式設定外。您可以從忽略的檔案列表中移除該檔案。
quick.fix.change.field.type.to.match.get.hook.return.type=更改欄位類型以符合 'get' 掛鈎返回類型
quick.fix.change.set.hook.parameter.type.to.match.field.type=將 ''set'' 掛鈎的參數更改為 {0}
quick.fix.delete=刪除 ''{0}''
quick.fix.error=快速修復錯誤
quick.fix.missing.class.constant.type=作為常數類型新增 ''{0}''
quick.fix.promote.property.with.private.set.visibility.modifier=使用 'private(set)' 可見性修飾符提升屬性
quick.fix.replace.clone.with.clone.with=將 'clone' 取代為 'clone with'
quick.fix.replace.getter.setter.with.hooks=將 {0} 取代為 {1}
quick.fix.replace.property.with.private.set.visibility.modifier=將屬性取代為 'private(set)' 可見性修飾符
quickfix.access.static.via.class.reference=取代為 ''{0}''
quickfix.add.parentheses.around.new.call=在 'new' 呼叫周圍新增圓括號
quickfix.add.to.use=新增到閉包 'use' 建構
quickfix.can.not.find.class.reference.name=無法按名稱尋找類別
quickfix.can.not.find.dynamic.method.reference=找不到動態方法參照
quickfix.can.not.find.static.method.reference=找不到 static 方法參照
quickfix.cannot.find.class.reference=找不到要解析的類別參照
quickfix.cannot.find.target.class=無法從參照 ''{0}'' 解析類別
quickfix.case.sensitive.name=更改 {0} 的大小寫以符合其宣告
quickfix.change.field.type.add.inferred.type.error.non.project=無法修改非專案檔案 ''{0}''
quickfix.change.field.type.add.inferred.type.error.read.only=無法修改唯讀檔案 ''{0}''
quickfix.change.field.type.add.inferred.type.family.name=作為屬性的類型新增推斷的類型
quickfix.change.field.type.add.inferred.type.name=作為屬性的類型新增 ''{0}''
quickfix.change.field.type.to.match.super=更改類型以符合父項
quickfix.change.field.type.to.match.super.0=將類型更改為 ''{0}'' 以匹配父項
quickfix.change.field.type.to.match.super.remove=移除類型宣告以符合父項
quickfix.change.type=更改為 ''{0}''
quickfix.change.type.declaration.family=更改類型
quickfix.convert.arrayall.to.loop=將 'array_all()' 呼叫轉換為迴圈
quickfix.convert.arrayany.to.loop=將 'array_any()' 呼叫轉換為迴圈
quickfix.convert.arrayfill.to.loop=將 'array_fill()' 呼叫轉換為迴圈
quickfix.convert.arrayfilter.to.loop=將 'array_filter()' 呼叫轉換為迴圈
quickfix.convert.arrayfind.to.loop=將 'array_find()' 呼叫轉換為迴圈
quickfix.convert.arrayfindkey.to.loop=將 'array_find_key()' 呼叫轉換為迴圈
quickfix.convert.arraymap.to.loop=將 'array_map()' 呼叫轉換為迴圈
quickfix.convert.loop.to.arrayall=將迴圈轉換為 'array_all()' 呼叫
quickfix.convert.loop.to.arrayany=將迴圈轉換為 'array_any()' 呼叫
quickfix.convert.loop.to.arrayfilll=將迴圈轉換為 'array_fill()' 呼叫
quickfix.convert.loop.to.arrayfilter=將迴圈轉換為 'array_filter()' 呼叫
quickfix.convert.loop.to.arrayfind=將迴圈轉換為 'array_find()' 呼叫
quickfix.convert.loop.to.arrayfindkey=將迴圈轉換為 'array_find_key()' 呼叫
quickfix.convert.loop.to.arraymap=將迴圈轉換為 'array_map()' 呼叫
quickfix.convert.to.json.validate=轉換為 'json_validate()'
quickfix.convert.to.new.style.constructor=將建構函式轉換為新樣式
quickfix.create.class=建立類別
quickfix.create.field.from.callback.invalid.element=無法從回調提取屬性名稱
quickfix.create.field.from.callback.name=從回調建立屬性
quickfix.create.field.from.callback.unresolved.class.ref=無法從回調建立屬性。無法解析目標類別參照。
quickfix.create.function.from.callback.family.name=從回調建立函式
quickfix.create.function.from.callback.name=新增函式
quickfix.create.method.from.callback.name=從回調建立方法
quickfix.create.parameter=建立參數
quickfix.delete.return.argument=刪除返回實參
quickfix.disable.inspection.for.global.namespace=為全域命名空間停用檢查
quickfix.failed.to.create.class=無法建立類別 ''{0}''
quickfix.import.base.no.candidates=找不到要匯入的候選項
quickfix.import.class.name=匯入類別
quickfix.import.class.popup.title=要匯入的類別
quickfix.import.constant.name=匯入常數
quickfix.import.constant.popup.title=要匯入的常數
quickfix.import.function.name=匯入函式
quickfix.import.function.popup.title=要匯入的函式
quickfix.is.not.available.in.dump.mode=在索引更新期間，''{0}'' 快速修復不可用
quickfix.make.call.static.name=將呼叫設為 static
quickfix.make.method.static=設為 'static'
quickfix.move.class.to.corresponding.directory=移至目錄 ''{0}''
quickfix.move.class.to.corresponding.directory.error.file.exists=檔案 {0} 已存在
quickfix.move.class.to.corresponding.directory.error.unable.create.directories=無法建立缺少的目錄\\: ''{0}''
quickfix.move.class.to.corresponding.directory.error.unable.move.file=無法將檔案移至目錄 ''{0}''
quickfix.multiple.target.class.resolve=類別 ''{0}'' 有多個宣告
quickfix.navigate.to.duplicate.array.key=導覽到重複鍵
quickfix.navigate.to.duplicate.case.value=導覽到重複的 case 值
quickfix.navigate.to.duplicate.condition=導覽到重複條件
quickfix.non.strict.object.equality=非嚴格物件相等比較
quickfix.omit.parentheses.around.new.call=省略 'new' 呼叫周圍的圓括號
quickfix.overriding.method.visibility=移除可見性覆寫
quickfix.php.missing.param.type.batch.description=作為屬性類型新增推斷的類型
quickfix.php.missing.param.type.description=作為參數類型新增 ''{0}''
quickfix.phpdoc.update.field.type=將{0, choice, 0\\#屬性|1\\#類別常數}類型更改為 ''{1}'' 以匹配 PHPDoc 註釋
quickfix.phpdoc.update.type=更新 PHPDoc 類型
quickfix.phpunit.assert.equals.flip.compared.arguments=翻轉比較實參
quickfix.phpunit.create.target.class.error.filename.exists=存在檔案 {0}
quickfix.phpunit.drop.redundant.optional.parameters=刪除冗餘的可選參數
quickfix.phpunit.replace.current.method.with.alternative=取代為 ''{0}''
quickfix.remove.condition.from.default.arm=從 'default' arm 中移除非 'default' 條件
quickfix.remove.default.arm=移除重複的 'default' match arm
quickfix.remove.duplicate.condition=移除重複條件
quickfix.remove.match.arm=移除 'match' arm
quickfix.remove.override.attribute=移除 '\\#[Override]'
quickfix.remove.phpdoc=移除冗餘 PHPDoc 註釋
quickfix.remove.phpdoc.param.tag=移除 @param 標記
quickfix.remove.phpdoc.return.tag=移除 @return 標記
quickfix.remove.phpdoc.signature.tags=移除不必要的 @param 和 @return 標記
quickfix.remove.redundant.phpdoc.tags=移除所有冗餘的 PHPDoc 標記
quickfix.remove.type=移除類型 ''{0}''
quickfix.remove.unnecessary.qualifier=移除不必要的限定符
quickfix.remove.unnecessary.qualifier.on.class.name=簡化 FQN
quickfix.remove.unused.condition=移除未使用的條件
quickfix.replace.assignment.operator.with.prefix.expression.family.name=將賦值運算符取代為前綴表達式
quickfix.replace.assignment.with.operator.assignment.family.name=將賦值取代為運算符賦值
quickfix.replace.assignment.with.operator.assignment.name=將 ''\\='' 取代為 ''{0}\\=''
quickfix.replace.assignment.with.prefix.expression.family.name=將賦值取代為前綴表達式
quickfix.replace.curly.braces.with.brackets=將大括號取代為中括號
quickfix.replace.nested.ternary.expression=將三元表達式取代為 {0} 關聯版本
quickfix.replace.one.operator.with.another=將 ''{0}'' 取代為 ''{1}''
quickfix.set.inheritance.between.classes=使{0} {1} {2}
quickfix.strict.type.checking.change.parameter.type.family=更改參數類型
quickfix.strict.type.checking.change.parameter.type.name=將{0, choice, 1\\#第 1 個|2\\#第 2 個|3\\#第 3 個|4\\#第 {0,number} 個}參數的類型從 ''{1}'' 更改為 ''{2}''
quickfix.strict.type.checking.change.return.type.family=更改返回值類型
quickfix.strict.type.checking.change.return.type.name=將返回值類型從 ''{0}'' 更改為 ''{1}''
quickfix.strict.type.checking.extend.return.type.family=擴展返回值類型
quickfix.strict.type.checking.extend.return.type.name=將返回值類型從 ''{0}'' 擴展為 ''{1}''
quickfix.undefined.function.add.function=新增函式
radio.button.by.concatenation=通過串聯(&C)
radio.button.by.embeding=通過嵌入(&E)
radio.button.class.constructor=類別建構函式(&S)
radio.button.const=const(&C)
radio.button.copy.from.base.class=從基類別複製(&P)
radio.button.current.method=當前方法(&T)
radio.button.default=預設(&F)
radio.button.default.empty.template=預設/空模板(&E)
radio.button.define=定義(&D)
radio.button.field.declaration=屬性宣告(&D)
radio.button.private=private(&I)
radio.button.protected=protected(&O)
radio.button.public=public(&U)
radio.button.setup=設定(&U)
radio.button.with.inheritdoc.tag=帶有 @inheritDoc 標記(&I)
radio.for.all.properties=適用於所有方法
radio.only.for.properties.without.declared.type=適用於沒有宣告類型的方法
reading.and.writing.creates.files.if.not.exists.fails.otherwise=讀/寫。如果檔案不存在則建立檔案，如果找到檔案則失敗。
reading.and.writing.start.at.the.beginning.of.the.file=讀/寫。從檔案開頭開始。
reading.and.writing.start.at.the.beginning.of.the.file.and.truncate.the.file.to.zero.length.creates.files.if.not.exists=讀/寫。從檔案開頭開始，將其截斷為零長度。如果檔案不存在則建立檔案。
reading.and.writing.start.at.the.the.end.of.the.file.creates.files.if.not.exists=讀/寫。從檔案末尾開始。如果檔案不存在則建立檔案。
reading.and.writing.starts.at.the.beginning.of.the.file.creates.files.if.not.exists=讀/寫。從檔案開頭開始。如果檔案不存在則建立檔案。
reading.only.start.at.the.beginning.of.the.file=唯讀。從檔案開頭開始。
readonly.property.cannot.have.default.value='readonly' 屬性不能具有預設值
readonly.property.must.have.type='readonly' 屬性必須指定類型
recursive.call=遞迴呼叫
redefinition.of.parameters.is.not.allowed=不允許參數重新定義
refactoring.common.fail.to.extract.expression=無法從所選程式碼段中提取表達式
refactoring.common.not.extractable.expression=不支持此類別表達式
refactoring.common.not.supported.context=當前上下文不支持{0}
refactoring.common.not.supported.expression.in.scope=當前作用域不支持此類別表達式的{0}
refactoring.common.ui.target.directory.edit=按 F2 編輯目標目錄
refactoring.common.ui.target.directory.label=目標目錄(&D)\\:
refactoring.common.ui.target.namespace.label=命名空間(&N)\\:
refactoring.common.validation.class.psi=無法執行重構\\: 目標類別“{0}”無效
refactoring.common.validation.namespace.name=“{0}”不是有效的命名空間名稱
refactoring.common.validation.target.directory.is.not.valid=目錄“{0}”的路徑無效
refactoring.common.validation.target.directory.not.inside.project=目錄“{0}”不在專案內部
refactoring.copy.class.name=複製類別
refactoring.extract.base.dialog.replace.all.occurrences=取代所有符合項(找到 {0} 個匹配項)(&A)
refactoring.extract.base.handler.no.expression.selected=選擇不構成正確的表達式
refactoring.extract.base.handler.not.supported.expression=此類別表達式不支持{0}
refactoring.extract.base.handler.not.supported.scope=當前作用域不支持{0}
refactoring.extract.base.validator.not.valid.identifier=“{0}”不是有效的 PHP 關鍵字。
refactoring.extract.base.validator.reserved.keyword=“{0}”是保留的 PHP 關鍵字。
refactoring.extract.class.conflicts.extract.class.refactoring.is.not.supported.for.dynamically.declared.properties.usages=動態宣告屬性用法不支持“提取類別”重構
refactoring.extract.class.conflicts.method.0.depends.on.1.constant.2=方法“{0}”依賴於 {1} 常數“{2}”
refactoring.extract.class.conflicts.method.0.depends.on.1.method.2=方法“{0}”依賴於 {1} 方法“{2}”
refactoring.extract.class.conflicts.method.0.depends.on.property.1.which.needs.getters.in.2=方法“{0}”依賴於屬性 "\${1}"，需要“{2}”中的 getter
refactoring.extract.class.conflicts.method.0.depends.on.property.1.which.needs.setters.in.2=方法“{0}”依賴於屬性 "\${1}"，需要“{2}”中的 setter
refactoring.extract.class.conflicts.unable.to.add.delegate.property.initialization.to.constructor=無法將委託的屬性初始化新增到類別建構函式
refactoring.extract.class.conflicts.unable.to.add.delegate.property.initialization.to.constructor.trait.constructor.will.be.overridden=無法將委託的屬性初始化新增到類別建構函式\\: 特徵建構函式將被覆寫
refactoring.extract.class.conflicts.using.write.access.for.non.public.properties.in.array.destructuring.expressions.is.not.supported.in.extract.class.refactoring=“提取類別”重構不支持將寫入權限用於陣列解構表達式中的非 public 屬性
refactoring.extract.class.conflicts.using.write.access.for.non.public.properties.in.multiple.assignment.expressions.in.extract.class.refactoring=“提取類別”重構不支持將寫入權限用於多個賦值表達式中的非 public 屬性
refactoring.extract.class.dialog.class=類別名\\:
refactoring.extract.class.dialog.generate.accessors=生成存取器(&G)
refactoring.extract.class.dialog.members.to.be.extracted=要提取的成員
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.abstract.methods=抽象方法不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.anonymous.classes=匿名類別不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.anonymous.functions=匿名函式不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.doc.methods=通過 PHPDoc 定義的魔術方法不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.doc.properties=通過 PHPDoc 定義的魔術屬性不支持 Extract Class 重構
refactoring.extract.class.error.failed.to.create.file=無法建立檔案
refactoring.extract.class.error.the.selected.function.should.belong.to.project.sources=所選函式必須屬於專案源
refactoring.extract.class.extract.to.class=提取到類別
refactoring.extract.class.extracting.from.class=正在從類別提取\\:
refactoring.extract.class.extracting.from.file=正在從檔案提取\\:
refactoring.extract.constant.conflict.already.exists=作用域中已經存在名稱為“{0}”的常數。
refactoring.extract.constant.conflict.cannot.override.interface.constant=無法覆寫接口“{1}”的常數“{0}”
refactoring.extract.constant.conflict.exists.in.subclass=“{0}\\:\\:{1}”將被此常數覆寫
refactoring.extract.constant.conflict.exists.in.subclass.with.weaker.access=“{0}”的存取級別必須為“{1}”(如在類別“{2}”中)或更弱
refactoring.extract.constant.name=提取常數
refactoring.extract.constant.unable.to.add.constant.declaration="無法新增常數宣告"
refactoring.extract.field.conflict.already.exists=該類中已經存在名稱為“{0}”的屬性。
refactoring.extract.field.name=提取屬性
refactoring.extract.field.validator.reserved.field.name=“{0}”是保留的屬性名稱
refactoring.extract.field.visibility=可見性
refactoring.extract.field.visibility.private=private(&I)
refactoring.extract.field.visibility.protected=protected(&O)
refactoring.extract.field.visibility.public=public(&U)
refactoring.extract.interface.fail.to.create.file=無法建立檔案 ''{0}''。
refactoring.extract.interface.field=接口名稱(&I)\\:
refactoring.extract.interface.invalid.caret.location=文字游標應置於要重構的類別名處。
refactoring.extract.interface.invalide.extract.from.trait=無法從特徵提取接口。
refactoring.extract.interface.members.title=要構成接口的成員(&B)
refactoring.extract.interface.name=提取接口
refactoring.extract.interface.no.methods=沒有要提取到接口的方法。
refactoring.extract.interface.phpdoc.copy=複製(&C)
refactoring.extract.interface.phpdoc.do.nothing=保留原樣(&A)
refactoring.extract.interface.phpdoc.move=移動(&M)
refactoring.extract.interface.phpdoc.title=PhpDoc
refactoring.extract.interface.title=從類別 ''{0}'' 提取接口
refactoring.extract.interface.validation.members.modifier=對於每個提取的方法，修飾符將更改為 public。
refactoring.extract.method.error.a.set.of.statements.should.be.from.the.same.code.block=一組語句應來自同一程式碼塊。
refactoring.extract.method.error.inconsistent.return.points.in.selected.code.fragment=所選程式碼段中的返回點不一致。
refactoring.extract.method.error.selected.block.should.represent.a.set.of.statement.or.an.expression=所選塊應代表一組語句或表達式。
refactoring.extract.method.error.there.are.break.continue.operators.which.can.interrupt.execution=存在會中斷執行的 break/continue 運算符。
refactoring.extract.method.from.duplicate.code=從重複的程式碼中提取方法
refactoring.extract.method.name=提取函式/方法
refactoring.extract.method.tooltip=輸入 $name \\= 'init'
refactoring.extract.parameter.name=提取參數
refactoring.extract.replace.class.reference=盡可能將類別參照取代為接口(&F)
refactoring.extract.variable.conflict.already.exists=作用域中已經存在名稱為“{0}”的變數。
refactoring.extract.variable.name=提取變數
refactoring.inline.cannot.find.variable.to.inline=找不到要內聯的變數
refactoring.inline.constant.all.references.and.keep=全部內聯並保留常數
refactoring.inline.constant.all.references.and.remove=全部內聯並移除常數
refactoring.inline.constant.cannot.extract.value=無法提取常數的值
refactoring.inline.constant.command=內聯常數
refactoring.inline.constant.is.never.used=常數 {0} 從未使用
refactoring.inline.constant.multiple.declarations=還有其他具有相同名稱的常數宣告。
refactoring.inline.constant.name=內聯常數
refactoring.inline.constant.this.reference.only=僅內聯此參照並保留常數
refactoring.inline.function.all.invocations.and.remove.the.method=全部內聯並移除{0}(&A)
refactoring.inline.function.all.invocations.keep.the.method=全部內聯並保留{0}(&E)
refactoring.inline.function.cannot.find.function.declaration=找不到函式宣告
refactoring.inline.function.cannot.inline.constructor=無法內聯建構函式
refactoring.inline.function.cannot.inline.first.class.callable.declaration=無法內聯一級可調用宣告
refactoring.inline.function.cannot.inline.function.with.global.usage=無法內聯{0}和 <code>global</code> 用法
refactoring.inline.function.cannot.inline.library.function=無法內聯庫函數
refactoring.inline.function.cannot.inline.magic.method=無法內聯魔術方法
refactoring.inline.function.cannot.inline.overridden.method=無法內聯被覆寫的方法
refactoring.inline.function.cannot.parse.function.body=無法解析函式體
refactoring.inline.function.command=正在內聯{0}
refactoring.inline.function.inline.function.refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow=當 return 語句中斷執行流程時，不支持內聯函式重構
refactoring.inline.function.not.accessible.from.caller.site=無法從呼叫者站點存取成員參照 <code>{0}</code>
refactoring.inline.function.only.static.method.is.supported=僅支援 static 方法
refactoring.inline.function.parent.reference.unresolved=<code>parent</code> 類別參照在 {0} 中未解析
refactoring.inline.function.reference.is.recursive=不支持遞迴呼叫
refactoring.inline.function.this.invocation.only.and.keep.the.method=僅內聯此呼叫並保留{0}(&K)
refactoring.inline.function.title=內聯{0}重構
refactoring.inline.function.yield.found.in.function.body=在函式體中找到 <code>yield</code> 用法
refactoring.inline.variable.cannot.extract.value=無法提取變數 ''\${0}'' 的值
refactoring.inline.variable.no.occurrences=沒有符合項可以被安全地內聯
refactoring.inline.variable.unary.operation=無法內聯到遞減或遞增運算
refactoring.inplace.extract.method.name=就地提取函式/方法
refactoring.make.method.static=將方法設為 static
refactoring.make.method.static.add.parameters.for.fields=新增屬性參數(&P)\\:
refactoring.make.method.static.doc.method.is.not.supported=不支持文檔方法
refactoring.make.method.static.dynamic.method.call.found=實例物件應作為參數傳遞，找到動態方法呼叫\\: {0}
refactoring.make.method.static.magic.method=魔術方法不能設為 static
refactoring.make.method.static.method.calls.found.in.static.context=在 static 上下文中找到方法呼叫
refactoring.make.method.static.method.converts.method.to.static=將方法轉換為 static
refactoring.make.method.static.method.is.overridden=方法 {0} 被覆寫
refactoring.make.method.static.object.is.needed=方法 {0} 使用未作為參數傳遞的屬性 {1}
refactoring.make.method.static.private.field.is.not.accessible=private 屬性 {0} 無法從類別外部存取
refactoring.make.method.static.protected.field.is.not.accessible=protected 屬性 {0} 無法從類別及其繼承者外部存取
refactoring.make.method.static.references.to.be.changed=待更改參照 {0}
refactoring.make.method.static.this.found=實例物件應作為參數傳遞，找到 $this
refactoring.make.method.static.writeAccess=檢測到 {0} 寫入存取，實例物件應作為參數傳遞。
refactoring.make.static.then.move.method.message=方法 ''{0}'' 將被設為 ''public static''
refactoring.make.static.then.move.method.select=將方法 ''{0}'' 移至類別
refactoring.move.class.action.name=移動類別…
refactoring.move.class.cannot.move.anonymous.class=無法移動匿名類別
refactoring.move.class.in.non.code.message=註釋和字串中的類別參照
refactoring.move.class.name=移動類別
refactoring.move.class.new.file=將類別提取到單獨的檔案(&E)
refactoring.move.class.title=將類別 {0} 移至命名空間(&C)\\:
refactoring.move.classes.dnd.files.with.the.same.name.error=單個目標中不允許有多個同名檔案。
refactoring.move.classes.dnd.name=移動類別
refactoring.move.classes.dnd.title=將所選{0,choice,0\\#類別|1\\#命名空間|2\\#類別和命名空間}移至命名空間\\:
refactoring.move.constant.action.name=移動常數…
refactoring.move.constant.class.already.contains.constant=類別 {0} 已包含常數 {1}
refactoring.move.constant.class.already.contains.method=類別 {0} 已包含方法 {1}
refactoring.move.constant.label.text.field=將常數 {0} 移至類別(&C)
refactoring.move.constant.title=移動常數
refactoring.move.constant.unable.to.resolve=無法解析 {0}
refactoring.move.function.action.name=移動函式…
refactoring.move.function.interface.cant.contain.method=接口中不允許帶有主體的方法
refactoring.move.function.label.text.field=將函式 {0} 移至類別(&C)
refactoring.move.function.title=移動函式
refactoring.move.instance.method=移動實例方法
refactoring.move.instance.method.action.name=移動實例方法…
refactoring.move.instance.method.preview.header=要移至另一個類別的方法
refactoring.move.instance.method.this.parameter.label=將取代類別 {0} 的 $this 參照的參數名稱
refactoring.move.instance.method.usage.will.not.be.accessible=用法 {0} 將無法存取。應提高方法可見性
refactoring.move.member.action.name=移動成員…
refactoring.move.member.method.is.overridden.in.a.sublclass={0} 在子類別 {1} 中被覆寫
refactoring.move.member.title=移動 static 成員
refactoring.move.members.0.will.be.hidden.in.1=成員 {0} 將在 {1} 中被隱藏
refactoring.move.members.cannot.find.target.class=找不到類別 {0}
refactoring.move.members.class.0.does.not.exist=類別 {0} 不存在。\\n是否要建立?
refactoring.move.members.enum.0.already.contains.case.with.name.0=枚舉 {0} 已經包含名稱為 ''{1}'' 的 case
refactoring.move.members.enum.0.already.contains.case.with.value.1=枚舉 {0} 已經包含值為 ''{1}'' 的 case
refactoring.move.members.is.not.a.valid.class.name=“{0}”不是有效的類別名
refactoring.move.members.is.not.accessible={0} 在 {1} 中無法存取
refactoring.move.members.late.static.binding.detected=檢測到延遲 static 綁定\\: {0}
refactoring.move.members.late.static.binding.detected.in.doc=在文檔中檢測到延遲 static 綁定
refactoring.move.members.member.will.change.visibility.to.public=成員 {0} 會將可見性更改為 public
refactoring.move.members.method.implements.abstract.method={0} 在 {1} 中實作 abstract 方法
refactoring.move.members.method.implements.method.in={0} 在 {1} 中實作方法
refactoring.move.members.move.as.enum.cases=作為枚舉 case 移動
refactoring.move.members.no.members.are.selected=未選擇成員
refactoring.move.members.only.constants.can.be.moved.to.interface=只有常數可以移至接口
refactoring.move.members.preview.header=要移至另一個類別的成員
refactoring.move.members.properties.can.not.be.moved.to.enum=屬性不能移動到枚舉
refactoring.move.members.self.from.anonymous.class=無法處理對匿名類別的自參照
refactoring.move.members.there.are.several.classes.with.specified.name=存在多個具有指定名稱 {0} 的類別
refactoring.move.members.to.be.moved=要移至另一個類別的成員(&B)
refactoring.move.members.unable.to.resolve.usage.callback.found=無法解析用法\\: 發現回調\\: {0}
refactoring.move.members.unable.to.resolve.usage.late.static.binding.detected=無法解析用法\\: 檢測到延遲 static 綁定\\: {0}
refactoring.move.method.cannot.move.constructor=無法移動建構函式
refactoring.move.method.cannot.move.magic.method=無法移動魔術方法
refactoring.move.method.label.text.field=將成員移至類別(&C)
refactoring.move.multiple.constant.label.text.field=將 {0} 個常數移至類別(&C)
refactoring.move.multiple.functions.label.text.field=將 {0} 個函式移至類別(&C)
refactoring.move.namespace.action.name=移動命名空間…
refactoring.move.namespace.header.message=移動命名空間
refactoring.move.namespace.in.non.code.message=註釋和字串中的命名空間參照
refactoring.move.namespace.message=要移動的命名空間
refactoring.move.namespace.name=移動命名空間
refactoring.move.namespace.new.namespace=新命名空間名稱(&N)\\:
refactoring.move.namespace.title=移動命名空間 {0}
refactoring.move.related.namespace.collect.title=收集子命名空間
refactoring.move.related.namespace.description=將具有相關命名空間的檔案移至新目錄\\:
refactoring.move.related.namespace.directory.column=新增目錄
refactoring.move.related.namespace.name.column=新命名空間名稱
refactoring.move.related.namespace.title=移動具有相關命名空間的檔案
refactoring.parameter.reserved.name=參數名稱“{0}”已保留
refactoring.parameter.validation=參數 {0} 無效
refactoring.parameter.validation.default.value=預設值表達式 ''{0}'' 無效
refactoring.parameter.validation.duplicate.parameter=重複的參數名稱\\: {0}
refactoring.parameter.validation.initializer=初始設定式 ''{0}'' 無效
refactoring.parameter.validation.initializer.last=必選參數不能位於可選參數後
refactoring.parameter.validation.initializer.type=具有類別類型提示的參數的預設值只能為 NULL
refactoring.parameter.validation.name.collision.with.use.list=參數名稱 ''{0}'' 無效。''{0}'' 已匯入 use 列表
refactoring.parameter.validation.no.default.value=應該為參數 ''{0}'' 提供初始設定式或預設值
refactoring.parameter.validation.pass.by.reference=僅變數可通過參照傳遞
refactoring.parameter.validation.type=參數類型 ''{0}'' 無效
refactoring.parameter.validation.variadic.can.have.default.value=可變形參不能具有預設值
refactoring.parameter.validation.variadic.last=只有最後一個參數可以是可變形參
refactoring.php.cannot.create.class=無法在預覽中建立新類別
refactoring.php.create.class=建立新類別
refactoring.php.extract.enum=提取枚舉
refactoring.pull.up.abstract.method=類別 {0} 將被標記為 abstract
refactoring.pull.up.class.does.not.have.base.classes.interfaces.in.project.files={0}在專案檔案中沒有基類別/接口
refactoring.pull.up.conflict.duplicate.constant={0} 將與 {1} 中的常數衝突。
refactoring.pull.up.implement.method=在實作接口的類別中建立方法存根(&S)
refactoring.pull.up.is.1.and.will.not.be.accessible.in.the.target.class={0} 為 private，在目標類別中將無法存取。
refactoring.pull.up.may.not.be.accessible.in.the.target.class={0} 在目標類別中可能無法存取。
refactoring.pull.up.private.access={0} 存取權限將更改為 {1}
refactoring.pull.up.static.reference.is.not.accessible.in.the.target.class=非 static 方法 {0} 不應在外部類中靜態呼叫
refactoring.pull.up.validation.field.into.interface=無法將屬性拉入接口
refactoring.pull.up.validation.static.method.into.interface={0} 為 static，不能為 abstract。
refactoring.pull.up.will.not.be.accessible.in.the.target.class={0} 在目標類別中將無法存取。
refactoring.push.down.method.implemented.in.interface={0} 必須被宣告為 abstract 或實作 {1}
refactoring.push.down.validation.magic.method=移動魔術方法會產生副作用
refactoring.rename.automatic.renamer.accessors.name=重新命名存取器(&C)
refactoring.rename.automatic.renamer.class.dialog.description=將具有以下名稱的類別重命名為\\:
refactoring.rename.automatic.renamer.class.dialog.title=重新命名類別
refactoring.rename.automatic.renamer.class.entity.name=類別
refactoring.rename.automatic.renamer.class.name=重新命名類別(&C)
refactoring.rename.automatic.renamer.field.accessors.dialog.description=將具有以下名稱的屬性存取器重命名為\\:
refactoring.rename.automatic.renamer.field.accessors.dialog.title=重新命名存取器
refactoring.rename.automatic.renamer.field.accessors.entity.name=存取器
refactoring.rename.entity.name.inheritor=繼承者/檔案
refactoring.rename.inheritors.and.related.files.with.the.following.names.to=將具有以下名稱的繼承者和相關檔案重命名為\\:
refactoring.rename.search.in.global.scope=在全域作用域中搜尋
refactoring.returnType.validation.type=返回值類型 ''{0}'' 無效
refactoring.validation.class.error.property.with.name.0.is.already.exists=已存在名稱為“{0}”的屬性
reference=參照
referenced.calls=參照的呼叫
reformats.file.with.0=使用 ''{0}'' 重新設定檔案格式
relationship.already.exists={0} 與 {1} 之間的關係已存在
release.name.eg.5.1.2.release=發佈名稱。例如，5.1.2-RELEASE
remote.connection.settings.default.remote.interpreter=預設遠端解釋器
remote.connection.settings.interpreter.is.not.remote=當前專案解釋器非遠端解釋器
remote.interpreter.browse.action.is.not.supported.for.docker=基於 Docker 的遠端解釋器不支持瀏覽動作
remote.interpreter.can.t.be.executed.please.enable.the.php.remote.interpreter.plugin=無法執行遠端解釋器。啟用 PHP Remote Interpreter 延伸模組。
remote.interpreter.path.mappings.validation.message=請檢查映射是否在 {0} 下正確組態。
remote.interpreter.path.mappings.validation.php.section=<b><i><a href\\="php_mappings">設定|PHP</a></i></b>
remote.interpreter.path.mappings.validation.title=沒有為所選解釋器組態路徑映射。
remove=移除
remove.assignment=移除賦值
remove.else=移除 else…
remove.from.function.0.declaration=從函式 ''{0}'' 宣告中移除 ''\\\\&''
remove.from.ignored.list=移除
remove.from.the.parameter.0=從參數 ''{0}'' 中移除 ''\\\\&''
remove.link.between.0.and.1=移除 {0} 與 {1} 之間的鏈接
remove.numeric.literals.separators=移除數字字面量分隔符
remove.pass.by.ref=移除 '\\\\&'
remove.pass.by.ref.sign=移除 '\\\\&'
remove.redundant.initializer=移除冗餘的初始設定式
remove.redundant.suppression.quick.fix.family.name=移除 ''{0}'' 禁止
remove.relationship.link=移除關係鏈接
remove.rule=移除規則
remove.unnecessary.parentheses=移除不必要的圓括號
remove.unnecessary.reset=移除不必要的 'reset'
remove.unnecessary.semicolon=移除不必要的分號
remove.variable=移除變數
rename=重新命名
rename.constructor=重新命名建構函式
rename.filename.quick.fix=將檔案 ''{0}'' 重命名為 ''{1}''
rename.parameter.dialog.description=將層次結構中的參數重命名為\\:
rename.parameters.dialog.title=重新命名參數
rename.psi.element.quick.fix=將{0} ''{1}'' 重命名為 ''{2}''
replace.all.occurrences.with.php=將所有符合項取代為 '<?php'
replace.all.occurrences.with.php.echo=將所有符合項取代為 '<?php echo'
replace.all.occurrences.with.short.php.echo=將所有符合項取代為 '<?\\='
replace.all.occurrences.without.side.effects=取代所有無副作用的符合項
replace.deprecated.from.of.callable=取代已棄用的可呼叫物件形式
replace.extends.implements=取代 'extends'/'implements'
replace.if.clause.with.ternary.expression=將 if 子句取代為三元表達式
replace.if.with.switch=將 'if' 取代為 'switch'
replace.plus.asgn.to.concat.asgn.quick.fix.family.name=將 '+\\=' 取代為 '.\\='
replace.plus.to.concat.quick.fix.family.name=將 '+' 取代為 '.'
replace.qualifier.with.an.import=將限定符取代為匯入
replace.quotes=取代引號
replace.ternary.expression.with.if.clause=將三元表達式取代為 if 子句
replace.unnecessary.double.quotes=取代不必要的雙引號
replace.variable.assignment.with.named.argument=將變數賦值取代為命名實參
replace.with.0=取代為 {0}
replace.with.01=取代為 {0}
replace.with.absolute.reference=取代為絕對參照
replace.with.alias=取代為別名
replace.with.alias.from.target.scope=取代為目標作用域中的別名
replace.with.anonymous.function=取代為匿名函式
replace.with.array=取代為直接賦值 '$array \\= array($value)'
replace.with.array.short.syntax=取代為直接賦值 '$array \\= [$value]'
replace.with.arrow.function=取代為箭頭函式
replace.with.coalesce.operator=取代為合併運算符
replace.with.first.class.callable.family.name=取代為一級可調用語法
replace.with.pow.operator=取代為 '**' 運算符
replace.with.quest=取代為 '?'
require='必需'
required.parameters.missing=缺少所需參數 ''{0}''
required.trait.0.wasn.t.added.to.1=必需特徵 ''{0}'' 未新增到 ''{1}''
rerun.with.ignore.platform.reqs=使用 --ignore-platform-reqs 重新執行
retrieving.php.version.data.from.3v4l.org=正在從 3v4l.org 檢索 PHP 版本資訊
return.type=返回值類型
return.type.declaration.is.not.allowed=不允許返回值類型宣告
return.type.declaration.must.be.compatible.with.super=返回值類型宣告必須與父級相容
returned.by.iterator.aggregate.should.be.traversable=\\\\IteratorAggregate\\:\\:getIterator() 返回的物件必須為 Traversable 或實作接口 Iterator
rfc.2822.rfc.5322.formatted.date=RFC 2822/RFC 5322 格式的日期({0})
run.install.update.with.platform.reqs=使用 --ignore-platform-reqs 執行安裝/更新(&R)
run.with.paratest=使用 ParaTest 執行
run.with.paratest.mnemonic=使用 ParaTest 執行 %s
searching.for.usages=正在搜尋用法…
seconds.numeric=秒，數字(1、3、57)
seconds.numeric.at.least.2.digits.with.leading.0=秒，數字，至少 2 位數，帶前導 0 (01、03、57)
seconds.since.the.unix.epoch.january.1.1970.00.00.00.gmt=自 Unix 時間戳 1970 年 1 月 1 日 00\\:00\\:00 GMT 以來的秒數({0})
seconds.with.leading.zeros=帶前導零的秒(00 到 59)
select.composer.phar.and.provide.the.full.path.to.it.or.select.download.composer.stable.phar.from.getcomposer.org=選擇 'composer.phar' 並提供其完整路徑，或者選擇“從 getcomposer.org 下載 composer-stable.phar”。
select.composer.phar.and.provide.the.full.path.to.it.or.select.download.composer.stable.phar.from.getcomposer.org1=選擇 'composer.phar' 並提供其完整路徑，或者選擇“從 getcomposer.org 下載 composer-stable.phar”。
server=伺服器
set=設定
set.access.level.to.0.1.must.be.2.as.in.class.3.or.weaker=''{0}\\:\\:\${1}'' 的 ''set'' 存取級別必須為 {2} (與類別 ''{3}'' 中一樣)或更低
set.close.on.exec.flag.on.the.opened.file.descriptor.only.available.in.php.compiled.on.posix.1.2008.conform.systems=在檔案檔案描述子上設定 close-on-exec 標誌。僅適用於符合 POSIX.1-2008 標準的系統。
set.the.following.option=設定以下選項\\:
settings.smart.keys.auto.insert.closing.html.tag.in.php.doc=在 PHPDoc 塊中自動插入 HTML 結束標記
settings.smart.keys.auto.insert.semicolon=在函式呼叫內部鍵入時自動插入分號 
settings.smart.keys.auto.insert.tag.after.typing=輸入 '<?' 後自動插入 '<?php' 標記
settings.smart.keys.enable.smart.function.parameters.completion=啟用智能函式參數補全
settings.smart.keys.escape.symbols.on.paste.in.string.literals=在字串字面量中貼上時轉義符號
settings.smart.keys.find.usages.of.base.method.prompt=搜尋方法用法時顯示其他選項
settings.smart.keys.remove.php.open.close.tags.while.pasting.in.php.context=在 PHP 上下文中貼上時移除 PHP 開始/結束標記
settings.smart.keys.replace.unnecessary.double.quotes.on.paste=貼上時取代不必要的雙引號
settings.smart.keys.select.variable.name.without.dollar.sign.on.double.click=在雙擊時選擇不帶 '$' 符號的變數名
settings.smart.keys.title=PHP
short.arrow.function.cannot.return.void=箭頭函式不能有 'void' 返回值類型
shorten.property.hook=縮短屬性掛鈎
show.0.settings.window=顯示 ''{0}'' 設定視窗
show.composer.settings.action.name=顯示 Composer 設定
show.constants=顯示常數
show.implementations.for.0={0} 的實作
show.includes=顯示 Include
show.log=顯示日誌
show.log.of.composer.related.actions=顯示 Composer 相關動作的日誌
show.name.for.all.arguments=顯示所有實參的名稱
show.private.members=顯示 private 成員
show.properties=顯示屬性
show.protected.members=顯示 protected 成員
show.settings=顯示設定
show.super.types.for.0=顯示 {0} 的父類型
show.validation.dialog=顯示“驗證偵錯器”對話框
shows.0.dialog=顯示 ''{0}'' 對話框
shows.dialog.with.methods.from.implemented.interface.selected.methods.will.be.inserted.into.the.class.after.dialog.confirmation=顯示包含已實作接口中方法的對話框。對話框確認後，所選方法將被插入到類別中。
shows.list.of.child.classes.with.inaccessible.methods=顯示具有不可存取方法的子類別列表
shows.list.of.child.classes.without.without.resolved.member=顯示沒有已解析成員的子類別列表
sign.minus.when.negative.empty.when.positive=負數時標記為 "-"，正數時留空(-、 )
sign.minus.when.negative.plus.when.positive=負數時標記為 "-"，正數時標記為 "+" (-、+)
simulating.update=正在模擬更新
skip.constant.params=跳過使用常數參數的呼叫
smarty=Smarty
smarty.configurable.title=Smarty
sort.by.visibility=按可見性排序
sort.the.elements.by.visibility.public.protected.private=按可見性對元素排序\\: public、protected、private
split.elseif=拆分 'elseif'
split.selected.group.use.statement=拆分所選 'use' 語句組
spread.operator.on.named.arguments.is.forbidden=禁止對命名實參使用展開運算符
spread.operators.in.arrays.are.not.supported.for.multiassignments.variables=多賦值變數不支持在陣列中使用展開運算符
squash.repetitive.underscores=壓縮重複下劃線
static.is.not.allowed.in.compile.time.constants=編譯時常量中不允許使用 'static\\:\\:'
static.is.not.allowed.in.parameter.type.declaration=參數類型宣告中不允許 'static'
static.modifier.is.not.allowed.here=此處不允許使用 'Static' 修飾符
static.property.cannot.be.readonly='static' 屬性不能為 'readonly'
static.property.cannot.be.unset=static 屬性不能取消設定
static.value=static 值
static.variable.with.same.name.already.defined.in.current.scope=static 變數 ''{0}'' 的宣告重複
status.text.no.dependencies=無相依項
strict.type.declaration.is.available.in.php.7.only=從 PHP 7.0 起才允許使用嚴格類型宣告
strict.types.declaration.must.have.0.or.1.as.its.value='strict_types' 宣告的值必須為 0 或 1
summary=摘要
suppress.all.for.file=對檔案全部禁止
suppress.for.field=對欄位禁止
suppress.for.file=對檔案禁止
suppress.for.function=對函式禁止
suppress.for.method=對方法禁止
suppress.for.phpdoc.comment=對 PhpDoc 註釋禁止
suppress.if.annotated.by.tag=如果用 ''{0}'' 註解，則禁止
suppress.unused.preview=對使用 ''{0}'' 註解的實體禁止“未使用的宣告”檢查
suppressed.annotation.title=已禁止的註解
surround.with.0=使用 ''{0}'' 包圍
surround.with.if.0.1=使用 ''if({0}({1}))'{'...'}''' 包圍
swatch.internet.time=Swatch 互聯網時間(000 到 999)
switch.statements.may.only.contain.one.default.clause.in.php.7=在 PHP 7 中，switch 語句只能包含一個 'default' 子句
switch.with.common.parts=包含通用部分的 'switch'
switching.from.another.vs.code.sublime.text.or.another.ide.check.out.our.migration.guides.to.get.started.faster=從 VS Code、Sublime Text 或其他 IDE 切換而來? 請檢視我們的遷移指南以更快地開始使用。
target=目標
target.class=目標類別\\:
target.directory.for.validation.script.is.not.public=驗證腳本的目標目錄不是 public。
target.trait.should.be.specified=應指定目標特徵
template.debug.cache.dir.is.incorrect=模板偵錯\\: 在設定中指定的快取目錄路徑無效
template.debug.cache.dir.is.not.specified=模板偵錯\\: 未在設定中指定快取目錄路徑
template.debug.cache.path=快取路徑\\:
template.debug.path.to.output.folder=快取目錄路徑
template.debug.path.to.output.folder.descr=指定快取目錄路徑
template.debug.php.file.not.found=模板偵錯\\: 未找到 {0} 的相應 PHP 檔案
template.parameter=模板參數
template.smart.completion.function.parameters.description=智能函式參數補全
terminal.add.interpreter.to.path=將預設專案 PHP 解釋器新增到 {0}
ternary.condition.can.be.replaced.with.condition.expression=表達式可以安全地取代為 ''{0}''
test.not.tests.was.executed.title=未組態 {0}。按 ''修正'' 安裝 composer 軟體套件。
text.plain=文本/純
the.button.shows.whether.inspection.is.on.or.off=該按鈕顯示檢查是開啟還是關閉
the.day.of.the.year.starting.from.0=一年中的第幾天(0 至 365)
the.original.class.0.does.not.belong.to.the.project.and.cannot.be.modified=原始類別 {0} 不屬於該專案\\n並且無法修改。
the.remote.hosts.access.plugin.is.missing.please.enable.the.plugin.in.0.plugins=缺少 ''FTP/SFTP/WebDAV Connectivity'' 和 ''Terminal'' 延伸模組中的一個或兩個。請在“{0} | 延伸模組”中啟用延伸模組。
the.result.of.validation.will.be.fetched.by.http.request=驗證輸出由 HTTP 請求提取。
the.same.as.p.but.returns.z.instead.of.00.00.available.as.of.php.8.0=與 P 相同，但返回 Z 而不是 +00\\:00，從 PHP 8.0 起可用(+02\\:00)
the.use.keyword.must.be.declared.in.the.outermost.scope.of.a.file.the.global.scope.or.inside.namespace.declarations=必須在檔案的最外側作用域(全域作用域)或命名空間宣告內部宣告 'use' 關鍵字
the.yield.expression.can.only.be.used.inside.a.function='yield' 表達式只能在函式中使用
there.are.errors.on.attempt.to.load.debug.extension.e.g.version.incompatibility=嘗試載入偵錯擴展時出錯，例如版本不相容。
this.is.the.default.contains.all.modes.in.the.sequence.s.n.r.v.m=這是預設值。包含序列 "s n r v m" 中的所有模式
this.reassignment.is.not.allowed=不能重新分配 $this
this.will.remove.relationship.link.between.classes=這將移除類別之間的關係鏈接並修改類別 {0}。繼續?
timezone.abbreviation.if.known.otherwise.the.gmt.offset=時區縮寫(如果已知)，否則為 GMT 偏移量(EST、MDT、+05)
timezone.identifier=時區關鍵字(UTC、GMT、大西洋/亞速爾群島)
timezone.offset.in.seconds=以秒為單位的時區偏移量(-43200 到 50400)
tooltip.configured.php.language.level.widget=已組態的 PHP 語言級別
tooltip.configured.php.language.level.widget.composer=通過 Composer 組態的 PHP 語言級別
tooltip.defaults.to.project.folder=預設為專案目錄
tooltip.from=來自{0}\\:
tooltip.from.volumes=來自{0}卷\\:
tooltip.update=更新 {0}
tooltip.wsl2.mappings=WSL2 映射
total.number.of.days.as.a.result.of.a.datetime.diff.or.unknown.otherwise=由 DateTime\\:\\:diff() 或(未知)方法得出的總天數(4、8、8123)
trailing.comma.is.not.allowed=不允許尾隨逗號
trait.already.contains.method=特徵 {0} 已包含方法 {1}
trait.expected.class.found=應為特徵，發現類別
trait.method.0.will.not.be.applied.because.it.collides.with.1=由於與 ''{1}'' 衝突，因此不會套用特徵方法 ''{0}''
trait.use.rule.type.name=特徵 use 規則方法
transform=轉換
turn.off.external.formatter=關閉外部格式化程序
turn.off.inspection.tool=關閉 {0} 檢查
type=類型
type.0.cannot.be.part.of.an.intersection.type=類型 ''{0}'' 不能是交叉類型的一部分
type.0.is.redundant.as.it.is.more.restrictive.than.type.1=類型 ''{0}'' 冗餘，因為它比類型 ''{1}'' 更加嚴格
type.contains.both.true.and.false.bool.should.be.used.instead=類型同時包含 true 和 false，應改用布爾
type.primitive.false.null.hints.names.are.forbidden=從 PHP 8.0 起才允許使用名為 'false' 和 'null' 的類型提示
type.primitive.true.hints.names.are.forbidden=從 PHP 8.2 起才允許使用名為 'true' 的類型提示
types.not.supported.as.operands.for.0.1.2=''{1} {0} {2}'' 中不受支援的動作數類型將導致 PHP 8 TypeError
uml.0.already.exists.in.class.1=類別 {1} 中已經存在 ''{0}''
uml.wrong.name=錯誤的名稱
undefined.interpreter=未定義的解釋器
unhandled.0=未處理的{0}
unhandled.exceptions=未處理的異常
union.types.and.the.nullable.type.notation.cannot.be.mixed=聯合體類型和可為 null 類型表示法不能混合
union.types.mixed.cannot.be.nullable=混合類型不能為可 null，'null' 已是混合類型的一部分
unknown=未知
unknown.debugger.type=未知偵錯器類型
unknown.named.parameter=未知命名參數 ''{0}''
unnamed.variable=(未命名)
unnecessary.local.variable=不必要的區域變數
unsupported.declare.0=不支持的宣告 ''{0}''
untrusted.composer.dialog.text=正在安裝或更新相依項，或者執行 Composer 指令可能會執行潛在的惡意程式碼。\\n\\n如果不信任此源，請繼續使用安全模式。
unused.code.rules=未使用的程式碼規則
unwrap.dowhile=解包 do-while…
unwrap.else=解包 else…
unwrap.elseif=解包 elseif…
unwrap.for=解包 for…
unwrap.foreach=解包 foreach…
unwrap.if=解包 if…
unwrap.method=解包 ''{0}''
unwrap.switch=解包 switch…
unwrap.try=解包 try…
unwrap.while=解包 while…
update.php.doc.type.comment=取代為 ''{0}''
update.php.doc.type.family.name=更新 PHPDoc 類型
update.signature.to.match.phpdoc.comment=更新簽名以符合 PHPDoc 註釋
uppercase.ante.meridiem.and.post.meridiem.am.pm=大寫上午和下午(AM/PM)
url.to.validation.script='驗證腳本的 URL'
usage.in.extends.clause=etends 子句中的用法
usage.in.implements.clause=implements 子句中的用法
usage.in.import.statement=import 語句中的用法
usage.in.return.type=返回值類型中的用法
usage.in.type.hinting=類型提示中的用法
usage.of.intersection.types.grouping.is.allowed.only.as.part.of.union.type=交叉類型分組僅允許作為聯合體類型的一部分使用
usages.show.this.self.references=顯示 $this/自參照
use.0.in.callables.is.deprecated=在可呼叫物件中使用 ''{0}'' 已棄用
using.this.when.not.in.object.context=不在物件上下文中時使用 '$this'
validated.web.server.is.not.running=驗證的 Web 伺服器未執行。
validating=正在驗證
validating1=正在驗證…
validation.0.extension.is.installed.check.configuration.options=已安裝 ''{0}'' 擴展。檢查組態選項。
validation.0.extension.is.not.installed=未安裝 ''{0}'' 擴展
validation.0.is.not.a.directory=''{0}'' 不是目錄
validation.0.not.found.at.1=在 ''{1}'' 中找不到 ''{0}''
validation.cannot.parse.value.of.0=無法解析 ''{0}'' 的值
validation.class.already.exists={0}中已經存在具有相同名稱的類別
validation.class.cannot.be.overridden=類別“{0}”不能被覆寫
validation.class.not.valid.name=“{0}”不是有效的類別名
validation.connection.was.not.established=未建立連線。
validation.connection.was.not.established.0=無法使用 ''{0}'' 啟動偵錯器會話
validation.connection.was.not.established.no.debug=未安裝偵錯擴展
validation.connection.was.not.established.update.info=更新解釋器資訊
validation.connection.was.not.established.validate.installation=驗證安裝
validation.debug.extension.is.updated=偵錯擴展設定已更新。請重新執行當前組態以使用新值。
validation.file.already.exists=檔案“{0}”已存在
validation.file.already.exists.in.dir=名稱為“{0}”的檔案已存在於“{1}”中
validation.file.not.valid.name=“{0}”不是有效的檔名
validation.function.already.exists=當前命名空間中已定義具有相同名稱的函式
validation.interface.cannot.be.overridden=無法實作接口“{0}”
validation.invalid.alias=“{0}”不是有效的別名
validation.invalid.identifier=“{0}”不是有效的關鍵字
validation.invalid.identifier.with.no.identifier=插入的關鍵字無效
validation.namespace.already.exists={1}中已定義名稱為 ''{0}'' 的命名空間
validation.namespace.not.valid.name=“{0}”不是有效的命名空間名稱
validation.no.debug.extension.is.installed=未安裝偵錯擴展。
validation.press.fix.to.edit.project.configuration=按“修復”編輯您的專案組態。
validation.script.was.created.but.it.cannot.be.executed.check.possible.reasons=驗證腳本已建立，但無法執行。可能的原因\\:
validation.script.will.be.created.in.0.directory=驗證腳本將在 {0} 目錄中建立。
validation.script.will.be.created.in.0.directory.and.deployed.to.the.1.server=驗證腳本將在 {0} 目錄中建立並部署到 {1} 伺服器。
validation.script.will.be.created.locally.and.deployed.to.the.remote.server=IDE 會在本地建立臨時驗證腳本並將其部署到遠端伺服器。
validation.script.will.be.created.locally.and.the.result.will.be.fetched.by.http.request=IDE 會在指定目錄中建立一個臨時驗證腳本，然後從 Web 伺服器 URL 提取並解析此腳本生成的 XML 輸出。之後，腳本將被移除。
validation.ssh.remote.code.coverage.support={0} 擴展不支持通過 ssh 進行程式碼覆蓋
validation.ssh.remote.debug.support=''{0}'' 擴展不支持通過 ssh 進行遠端偵錯。
validation.test.no.test.patterns=未新增任何模式
validation.value.is.invalid={0} 無效
validation.value.is.not.specified.or.invalid={0} 未指定或無效。
validation.value.is.not.specified.or.invalid.press.fix.project.configuration={0} 未指定或無效。按“修復”編輯您的專案組態。
validation.value.is.not.specified.press.fix.project.configuration={1} 組態中未指定 {0}。按“修復”以編輯 {1} 組態。
validation.value.path.to.value.is.invalid=無法通過 {1} 中提供的路徑找到 {0}
validation.value.path.to.value.is.invalid.press.fix.project.configuration=無法通過 {1} 中提供的路徑找到 {0}。按“修復”以編輯 {2} 組態。
validation.value.path.to.value.should.be.specified={0} 的路徑應在 {1} 中指定
validation.vendor.doesnt.exit=供應商目錄不存在
value=值
variable=變數
variable.always.have.value.0=到達時變數始終為 ''{0,choice,0\\#false|1\\#true}'
variable.dereferenced=已解參照變數
variable1=變數
variadic.parameter.cannot.have.a.default.value=可變形參不能具有預設值
version.information.varies.a.lot.between.operating.systems=版本資訊。不同作業系統之間差異很大
void.can.only.be.used.as.return.type=Void 只能用作返回值類型
void.type.cannot.be.nullable=void 類型不能是可為 null
waiting.for.3v4l.org.response=正在等待 3v4l.org 響應…
whether.it.s.a.leap.year.1.or.0=是否為閏年(1 或 0)
whether.or.not.the.date.is.in.daylight.saving.time.1.or.0=日期是否為夏令時(1 或 0)
while=while
with.data.set.0=使用資料集 {1} 的 {0}
working.directory.invalid=找不到工作目錄 ''{0}''
writing.only.creates.files.if.not.exists.fails.otherwise=只寫。如果檔案不存在則建立檔案，如果找到檔案則失敗。
writing.only.start.at.the.beginning.of.the.file.and.truncate.the.file.to.zero.length.creates.files.if.not.exists=只寫。從檔案開頭開始，將其截斷為零長度。如果檔案不存在則建立檔案。
writing.only.start.at.the.the.end.of.the.file.creates.files.if.not.exists=只寫。從檔案末尾開始。如果檔案不存在則建立檔案。
writing.only.starts.at.the.beginning.of.the.file.creates.files.if.not.exists=只寫。從檔案開頭開始。如果檔案不存在則建立檔案。
xdebug.cloud.cannot.connect=無法連線到 Xdebug Cloud
xdebug.cloud.cannot.connect.unknown.host=Xdebug Cloud 無法存取\\: {0}
xdebug.cloud.cannot.open.new.debug.connection=打不開新的偵錯連線
xdebug.cloud.cannot.register.cloud.id=無法在 Xdebug Cloud 上註冊 Cloud ID
xdebug.cloud.cannot.register.cloud.id.unexpected.response=由於意外響應，無法註冊 Cloud ID
xdebug.cloud.validation.cloud.id.not.defined=Cloud ID 未定義
xdebug.cloud.validation.host.not.defined=未定義本地部署 Xdebug Cloud 主機
xdebug.cloud.validation.port.invalid=本地部署 Xdebug Cloud 連接埠無效
xdebug.compile.task=編譯 Xdebug 擴展程序
xdebug.initializing.connection.debugger=偵錯器
xdebug.initializing.connection.failed.with.timeout=無法連線到 {0}\\: 超時
xdebug.initializing.connection.xdebug.cloud=Xdebug Cloud
xdebug.initializing.debugger.connection=正在連線到 {0}…
xdebug.validation.download.script.label=下載腳本指令\\:
xdebug.validation.ip.not.found=在自動檢測到的 IDE IP 中找不到 {0}
xdebug.validation.ip.not.found.descr=自動檢測的 IDE IP\\: {0}
years.numeric=年份，數字(1、3)
years.numeric.at.least.2.digits.with.leading.0=年份，數字，至少 2 位數，帶前導 0 (01、03)
you.are.configuring.debug.extension.in.the.wrong.php.ini.see.the.loaded.php.ini.files.below=您正在錯誤的 php.ini 中組態偵錯擴展(請參見下方已載入的 php.ini 檔案)。
you.can.always.add.a.precise.exclusion.via.alt.enter.and.then.edit.it.to.broaden.as.needed=您始終可以通過 Alt-Enter 組合鍵新增精確排除，然後根據需要對其進行編輯以擴大範圍。
you.did.not.reload.web.server.after.changes.in.php.ini.file=在 php.ini 檔案中進行更改後，未重新載入 Web 伺服器。
zend.debugger.settings.broadcasting.is.already.launched=Zend Debugger 設定廣播已啟動
"
`;

exports[`src messages/SvnBundle.properties 1`] = `
"action.DumbAware.RepositoryBrowserDialog.text.branch.or.tag=分支或標記…
action.DumbAware.RepositoryBrowserDialog.text.move.or.rename=移動或重新命名(_M)…
action.DumbAware.SvnConfigureProxiesComponent.description.add=新增
action.DumbAware.SvnConfigureProxiesComponent.description.copy=複製
action.DumbAware.SvnConfigureProxiesComponent.text.add=新增
action.DumbAware.SvnConfigureProxiesComponent.text.copy=複製
action.EditCommitMessage.description=編輯修訂註釋。覆寫上一條訊息。
action.EditCommitMessage.text=編輯修訂註釋
action.IntegrateChangeSetAction.text=整合到分支
action.Subversion.BrowseSVNRepository.description=瀏覽 Subversion 版本庫
action.Subversion.BrowseSVNRepository.text=瀏覽 Subversion 版本庫(_W)…
action.Subversion.CleanupProject.description=對專案中的所有工作副本目錄執行清理
action.Subversion.CleanupProject.text=清理專案
action.Subversion.Clenaup.description=解鎖鎖定的目錄，並執行其餘所有未完成的動作
action.Subversion.Clenaup.text=清理(_E)
action.Subversion.CompareWithBranch.text=與分支比較…
action.Subversion.ConfigureBranches.text=組態分支…
action.Subversion.Copy.description=將選定的檔案或目錄複製到新的版本庫位置
action.Subversion.Copy.text=分支或標記(_B)…
action.Subversion.Create.External.description=選擇 URL，新增 svn\\:external 屬性，然後可以選擇簽出
action.Subversion.Create.External.text=建立外部…
action.Subversion.Ignore.ExactMatch.description=將所有所選檔案的名稱新增到目錄忽略列表
action.Subversion.Ignore.ExactMatch.text=所選檔名
action.Subversion.Ignore.MatchExtension.description=將 {0} 遮罩新增到目錄忽略列表
action.Subversion.ImportToSVNRepository.text=匯入 Subversion(_M)…
action.Subversion.Lock.description=鎖定檔案
action.Subversion.Lock.text=鎖定(_L)…
action.Subversion.MarkResolved.description=將文本和屬性衝突標記為已解決
action.Subversion.MarkResolved.text=標記為已解決(_M)…
action.Subversion.MarkTreeResolved.text=將樹衝突標記為已解決…
action.Subversion.PropertiesView.AddProperty.description=新增新屬性
action.Subversion.PropertiesView.AddProperty.text=新增屬性
action.Subversion.PropertiesView.Close.description=關閉此工具視窗
action.Subversion.PropertiesView.Close.text=關閉
action.Subversion.PropertiesView.DeleteProperty.description=刪除選定屬性
action.Subversion.PropertiesView.DeleteProperty.text=刪除屬性
action.Subversion.PropertiesView.EditKeywords.description=管理 svn\\:keywords 屬性
action.Subversion.PropertiesView.EditKeywords.text=編輯關鍵字
action.Subversion.PropertiesView.EditProperty.description=編輯選定屬性值
action.Subversion.PropertiesView.EditProperty.text=編輯屬性
action.Subversion.PropertiesView.FollowSelection.description=跟隨選擇
action.Subversion.PropertiesView.FollowSelection.text=跟隨選擇
action.Subversion.PropertiesView.Refresh.description=重新載入屬性
action.Subversion.PropertiesView.Refresh.text=重新整理
action.Subversion.Relocate.description=將工作副本重定位到其他 URL
action.Subversion.Relocate.text=重定位…
action.Subversion.RepositoryBrowser.Checkout.text=簽出(_C)…
action.Subversion.RepositoryBrowser.CompareWith.text=比較物件…
action.Subversion.RepositoryBrowser.CopyUrl.text=複製 URL…
action.Subversion.RepositoryBrowser.Export.text=匯出(_E)…
action.Subversion.Resolve.description=解決檔案中的文本衝突
action.Subversion.Resolve.text=解決文本衝突(_S)…
action.Subversion.SelectAllRevisions.description=全選
action.Subversion.SelectAllRevisions.text=全選
action.Subversion.SetProperty.description=在檔案或目錄中設定版本化屬性
action.Subversion.SetProperty.text=設定屬性(_T)…
action.Subversion.Share.text=共享目錄(_S)…
action.Subversion.ShareWholeProject.text=共享專案(Subversion)…
action.Subversion.ShowIntegratePanel.text=顯示整合面板
action.Subversion.ShowMergeSourceDetails.text=顯示合併原始碼詳細資訊
action.Subversion.ShowProperties.text=編輯屬性(_P)
action.Subversion.TogglePropertiesDiff.description=顯示 SVN 屬性的差異
action.Subversion.TogglePropertiesDiff.text=顯示屬性
action.Subversion.UndoIgnore.description=從目錄忽略列表中移除檔名/遮罩
action.Subversion.UndoIgnore.text=所選檔名
action.Subversion.Unlock.description=解鎖檔案
action.Subversion.Unlock.text=解鎖(_O)
action.Subversion.UnselectAllRevisions.description=取消全選
action.Subversion.UnselectAllRevisions.text=取消全選
action.Subversion.cleanup.error.message=對 ''{0}'' 執行清理時出錯\\: {1}
action.Subversion.cleanup.progress.title=Subversion 清理
action.Subversion.integrate.changes.actionname=整合到分支…
action.Subversion.integrate.changes.branch.info.source.label.text=源分支 URL\\: {0}
action.Subversion.integrate.changes.branch.info.target.label.text=目標分支 URL\\: {0}
action.Subversion.integrate.changes.collecting.changes.to.commit.task.title=正在收集要提交的更改
action.Subversion.integrate.changes.description=將選定的更改列表/更改集整合到選定的分支
action.Subversion.integrate.changes.dialog.add.wc.text=新增
action.Subversion.integrate.changes.dialog.remove.wc.text=移除
action.Subversion.integrate.changes.error.unable.to.collect.changes.text=收集要提交的更改時出錯\\: {0}
action.Subversion.integrate.changes.message.another.wc.text=所選目標位於另一個版本庫的工作副本內。仍要繼續?
action.Subversion.integrate.changes.message.files.up.to.date.text=所有檔案均為最新
action.Subversion.integrate.changes.message.not.under.control.text=所選目標不在 Subversio 的控制下。仍要繼續?
action.Subversion.integrate.changes.messages.title=整合到分支
action.Subversion.integrate.changes.progress.integrating.text=正在合併更改
action.Subversion.integrate.changes.select.working.copy.text=整合到工作副本\\:
action.Subversion.integrate.difference.option.use.ancestry.text=使用以前的版本(&U)
action.Svn.RefreshWorkingCopies.description=重新整理工作副本資訊
action.Svn.RefreshWorkingCopies.text=重新整理
action.Svn.Show.Working.Copies.description=顯示工作副本資訊\\: 工作副本格式和 URL
action.Svn.Show.Working.Copies.text=顯示工作副本
action.mark.list.as.merged.description=將所選修訂版標記為已合併，但實際沒有合併
action.mark.list.as.merged.text=標記為已合併
action.mark.list.as.not.merged.description=將所選修訂版標記為未合併，但不會更改 svn\\:mergeinfo 之外的任何內容
action.mark.list.as.not.merged.text=標記為未合併
action.name.configure.branches=組態分支
action.name.ignore.files=新增忽略檔案遮罩
action.name.mark.resolved=標記已解決
action.name.merge.from=合併自
action.name.merge.from.ellipsis=合併自…
action.name.refresh=重新整理
action.name.resolve.conflict=解決衝突
action.name.revert=還原(&R)
action.name.set.property=設定屬性
action.name.show.properties=顯示屬性
action.name.switch=切換
action.name.undo.ignore.files=從忽略列表移除檔名(或遮罩)
action.new.remote.folder.text=新增遠端目錄…
action.repository.browser.history.description=顯示歷史記錄
action.repository.browser.history.text=顯示歷史記錄
action.share.whole.project.text=共享專案(Subversion)…
action.text.annotate=註解
action.title.select.configuration.directory=更改組態目錄
add.files.errors.title=新增檔案時出錯
annotation.original.revision=原始修訂
annotation.show.merge.sources.default.text=在歷史記錄和註解中顯示合併原始碼
browse.changes.settings.stop.on.copy=複製時停止(&S)
button.copy=複製
button.keep=保留
button.load.quantity=載入 +{0}
button.merge.all=全部合併
button.merge.selected=合併所選內容
button.move=移動
button.resolve.conflict.accept.theirs=接受他們的更改
button.resolve.conflict.accept.yours=接受您的更改
button.resolve.conflict.merge=合併
button.select=選擇
button.share=共享
button.text.clear.authentication.cache=清除身份驗證快取(&C)
button.text.deselect.all=取消全選(&D)
button.text.edit.proxies=編輯網絡選項(&O)…
button.text.select.all=全選(&A)
button.text.ssh.accept=是 (_Y)
button.text.ssh.reject=否 (_N)
button.text.ssl.accept=接受(_A)
button.text.ssl.reject=拒絕(_R)
changes.browser.revision.term=修訂
checkbox.auth.keep.for.current.session=儲存憑證(&S)
checkbox.changes.filter.filter.by.author=作者(&U)\\:
checkbox.checkin.auto.update.after.commit=提交後自動更新
checkbox.checkin.keep.files.locked=保持檔案鎖定(&K)
checkbox.checkout=簽出
checkbox.create.tags.branches=建立 /tags 和 /branches
checkbox.force.update=強制更新(&F)
checkbox.ignore.externals=忽略外部項(&E)
checkbox.ignore.whitespace.when.merge.text=&忽略空格
checkbox.include.externals.locations=包括外部項位置
checkbox.include.ignored.resources=包含忽略的資源
checkbox.replace.existing.files=取代現有檔案
checkbox.set.property.update.properties.recursively=遞迴更新屬性(&R)
checkbox.ssl.keep.for.current.session=儲存憑證(&S)
checkbox.svn.ssh.cache.fingerprint=將密鑰新增到 Subversion 快取(&A)
checkbox.switch.to.newly.created.branch.or.tag=將 {0} 切換到新增的分支或標記
checkbox.update.switch.configurable.to.specific.revision=更新/切換到特定版本(&R)\\:
checkbox.update.switch.configurable.try.merge.without.changes=嘗試合併，但不做任何更改(&T)
checkin.different.formats.involved={0,choice,0\\#版本庫|1\\#版本庫} {1} 的選定更改\\n屬於不同格式的 Subversion 工作副本。\\n提交將分為多個提交。\\n\\n您可以在“更改 | Subversion 工作副本資訊”中將所有工作副本轉換為相同格式。\\n是否要繼續提交?
checkin.operation.name=提交(_I)
checkout.dialog.button=檢出
checkout.dialog.title=從 Subversion 簽出
checkout.directory.chooser.prompt=選擇要從 Subversion 簽出的目錄
checkout.directory.chooser.title=簽出目錄
checkout.options.checkout.label=檢出\\:
checkout.options.dialog.title=SVN 簽出選項
checkout.repository=正在簽出版本庫…
checkout.repository.canceled=簽出已取消
checkout.repository.failed=簽出失敗
checkout.repository.tooltip=該專案將在完成簽出後開啟
checkout.stop.message.description=確定要停止簽出 {0} 版本庫嗎?
checkout.stop.message.title=停止簽出
cleanup.action.name=清理
column.name.merge.sources=合併原始碼
column.name.property.name=名稱
column.name.property.value=值
combobox.crlf.none=無
command.line.interactive.mode.description=模擬直接從終端執行 Subversion 指令時的行為(互動模式)。<br>這是處理 svn+ssh 版本庫的密碼/密碼短語提示以及信任 https 版本庫的無效伺服器憑證所必需的。
command.line.interactive.mode.title=啟用互動模式
committed.changes.action.enable.merge.highlighting=醒目提示已整合的更改列表
committed.changes.action.enable.merge.highlighting.description.text=選項僅適用於 SVN 版本庫和 1.5 版本的工作副本
committed.changes.action.merge.highlighting.refresh.description=重新整理合併的修訂資訊
committed.changes.action.merge.highlighting.refresh.text=重新整理
compare.with.branch.diff.title=與分支比較
compare.with.branch.error.title=與分支比較
compare.with.branch.location.error=在分支 ''{1}'' 下找不到檔案 ''{0}'' 的版本庫位置\\n請檢查您的分支組態。
compare.with.branch.popup.title=與分支比較
compare.with.branch.progress.loading.content=載入內容中…
configurable.SvnConfigureProxiesComponent.display.name=HTTP 代理組態
configurable.name.svn.general=Subversion
configurable.name.svn.network=網絡
configurable.name.svn.presentation=表示
configurable.name.svn.ssh=SSH
configure.branches.branch.locations=分支位置\\:
configure.branches.error.wrong.url=主幹位置必須在版本庫根 ''{0}'' 下
configure.branches.title=組態 Subversion 分支
configure.branches.trunk.location=主幹位置\\:
configure.revision.head.radio=HEAD
configure.revision.specified.radio=指定的
confirmation.resolve.tree.conflict.merge.moved=將 {0} 中的更改應用到本地移動的 {1}?
confirmation.resolve.tree.conflict.merge.renamed=將 {0} 中的更改套用到本地重新命名的 {1}?
confirmation.text.add.dir=是否要安排將以下目錄新增到 Subversion?\\n{0}
confirmation.text.add.file=是否要安排將以下檔案新增到 Subversion?\\n{0}
confirmation.text.delete.dir=是否要安排將以下目錄從 Subversion 刪除?\\n{0}\\n注意\\: 提交更改後，該目錄將從磁碟中刪除。
confirmation.text.delete.dir.17=是否要安排將以下目錄從 Subversion 刪除?\\n{0}
confirmation.text.delete.file=是否要安排將以下檔案從 Subversion 刪除?\\n{0}
confirmation.text.delete.stored.authentication.information=您將刪除所有存儲的 Subversion 身份驗證資訊。\\n確定要刪除嗎?
confirmation.text.edit.file=您要編輯的檔案在編輯前需要鎖定
confirmation.title.add.file=新增的時間表
confirmation.title.add.multiple.files=選擇要新增到 Subversion 的檔案
confirmation.title.clear.authentication.cache=清除身份驗證快取
confirmation.title.delete.file=計劃刪除
confirmation.title.delete.multiple.files=選擇要從 Subversion 刪除的檔案
conflict.action.add=新增
conflict.action.delete=刪除
conflict.action.edit=編輯
conflict.action.replace=取代
conflict.operation.merge=合併
conflict.operation.none=無
conflict.operation.switch=切換
conflict.operation.update=更新
conflict.reason.added=新增
conflict.reason.deleted=刪除
conflict.reason.edited=編輯
conflict.reason.missing=缺少
conflict.reason.moved.away=移開
conflict.reason.moved.here=已移到此處
conflict.reason.obstructed=障礙
conflict.reason.replaced=取代
conflict.reason.unversioned=未進行版本管理
copy.column.title=複製
copy.column.tooltip=從 {0} 複製
copy.dialog.title=分支或標籤
delete.files.errors.title=刪除檔案時出錯
dialog.Subversion.select.working.copy.title=組態工作副本路徑
dialog.Subversion.select.working.copy.wcopy.list.title=已知工作副本
dialog.create.branch.or.tag.from.working.copy.warning=<html>使用此變體建立<b>具有本地更改</b>的分支。<br/>通常，不僅是目標目錄，還將有幾個項“帶歷史記錄新增”。<br/><br/>具有與根不同的修訂的各個檔案將被分別複製。<br/>因此，建議先更新工作副本，然後再建立分支。</html>
dialog.description.select.configuration.directory=選擇 Subversion 組態目錄或建立新目錄
dialog.edit.http.proxies.settings.client.certificate.passphrase.text=SSL 客戶端憑證密碼短語(&H)\\:
dialog.edit.http.proxies.settings.connection.timeout.text=連線超時(&I)\\:
dialog.edit.http.proxies.settings.dialog.select.ssl.client.certificate.path.title=選擇憑證路徑
dialog.edit.http.proxies.settings.error.ambiguous.group.patterns.text=找到與多個組符合的版本庫 URL\\: {0}
dialog.edit.http.proxies.settings.error.ambiguous.group.patterns.to.text=URL {0} 符合 {1}
dialog.edit.http.proxies.settings.error.same.group.names.text=檢測到同名的組\\: ''{0}''
dialog.edit.http.proxies.settings.exceptions.text=異常(&X)\\:
dialog.edit.http.proxies.settings.panel.proxy.title=HTTP 代理設定
dialog.edit.http.proxies.settings.panel.repositories.title=版本庫
dialog.edit.http.proxies.settings.panel.ssl.title=SSL 設定
dialog.edit.http.proxies.settings.password.text=密碼(&W)\\:
dialog.edit.http.proxies.settings.paths.to.authority.certificates.text=CA 憑證檔案的逗號分隔的路徑(&P)\\:
dialog.edit.http.proxies.settings.patterns.text=URL 模式(&R)\\:
dialog.edit.http.proxies.settings.port.must.be.number.error=連接埠必須為數字(組 ''{0}'')
dialog.edit.http.proxies.settings.port.text=連接埠(&O)\\:
dialog.edit.http.proxies.settings.seconds.text=秒
dialog.edit.http.proxies.settings.server.text=伺服器(&S)\\:
dialog.edit.http.proxies.settings.ssl.client.certificate.file.text=SSL 客戶端憑證檔案(&C)\\:
dialog.edit.http.proxies.settings.tab.edit.system.file.title=系統檔案
dialog.edit.http.proxies.settings.tab.edit.user.file.title=使用者檔案
dialog.edit.http.proxies.settings.test.connection.button.text=測試連線(&T)
dialog.edit.http.proxies.settings.test.connection.error.title=連線測試失敗
dialog.edit.http.proxies.settings.test.connection.settings.will.be.stored.text=設定將被儲存
dialog.edit.http.proxies.settings.test.connection.settings.will.be.stored.title=警告
dialog.edit.http.proxies.settings.test.connection.success.text=連線測試成功
dialog.edit.http.proxies.settings.test.connection.success.title=連線測試成功
dialog.edit.http.proxies.settings.timeout.must.be.number.error=HTTP 超時必須為數字(組 ''{0}'')
dialog.edit.http.proxies.settings.trust.default.cas.text=信任預設 CA(&A)
dialog.edit.http.proxies.settings.user.text=使用者(&U)\\:
dialog.message.accept.theirs.for.path=接受他們對 {0} 的更改?
dialog.message.accept.yours.for.path=接受您對 {0} 的更改?
dialog.message.branch.name.is.empty=分支名稱為空
dialog.message.can.not.detect.repository.root.for.url=無法檢測 URL 的版本庫根\\: {0}
dialog.message.confirm.move.folder=您即將移動名稱為 ''{0}'' 的目錄。是否確定?
dialog.message.could.not.parse.url=無法解析 url
dialog.message.error.relocating.working.copy=重定位工作副本時出錯\\: {0}
dialog.message.integrate.changes.error.no.available.files=沒有可用於整合的檔案
dialog.message.integrate.changes.error.not.versioned=無法啟動整合\\: 目標目錄不在 Subversion 控制下或不屬於所選分支。
dialog.message.integrate.changes.error.same.source.and.target=無法啟動整合\\: 目標分支和源分支相同。
dialog.message.integrate.changes.error.target.not.dir=無法啟動整合\\: 目標目錄不存在或不是目錄。
dialog.message.invalid.branch.name=分支名稱無效
dialog.message.invalid.branch.url=分支 url 無效
dialog.message.invalid.repository.location=版本庫位置無效
dialog.message.invalid.revision=修訂無效
dialog.message.invalid.working.copy.root=無效的工作副本根\\: {0}
dialog.message.keep.newly.created.files.in.their.original.place=在其初始位置保留新增檔案?
dialog.message.mark.tree.conflict.resolved.confirmation=是否要將樹衝突標記為已解決?
dialog.message.merge.confirm.reintegrate=您將重新整合更改。<br><br>此舉將導致分支 ''{0}'' <b>不能再用於進一步的處理</b>。<br>此分支既無法正確吸收新的主幹({1})更改，<br>也無法正確地重新整合到主幹。<br> <br>確定嗎?
dialog.message.merge.from.theirs.create.binary.file=(根據其更改)建立二進制檔案 {0}?
dialog.message.merge.from.theirs.delete.binary.file=(根據其更改)刪除二進制檔案 {0}?
dialog.message.merge.from.theirs.modify.binary.file=(根據其更改)對二進制檔案 {0} 套用更改?
dialog.message.merge.intersects.with.local.changes.prompt=存在與合併更改衝突的本地更改。\\n是否要繼續?
dialog.message.merge.potentially.intersects.with.local.changes.prompt=存在與合併更改有可能相交的本地更改。\\n是否要繼續?
dialog.message.merge.with.switched.paths.in.working.copy=工作副本中有一些切換的路徑。是否要繼續?
dialog.message.no.branch.base.location.selected=未選擇分支基位置
dialog.message.repository.path.does.not.exist=版本庫路徑 ''{0}'' 不存在。要建立它嗎?
dialog.message.select.binary.files.to.patch=選擇要打補丁的二進制檔案
dialog.message.set.working.copy.infinity.depth=您將以 ''infinity'' 深度簽出到 ''{0}''。\\n您的工作副本也將隨之更新為 HEAD 修訂。
dialog.message.share.to.not.empty.directory=遠端目錄“{0}”非空。\\n是否要繼續共享?
dialog.message.switch.target.not.copy.current=切換目標 URL 不是當前副本。\\n是否要繼續?
dialog.message.target.file.already.exists=目標檔案已經存在
dialog.show.svn.map.title=Subversion 工作副本資訊
dialog.title.authentication.required=需要身份驗證
dialog.title.branch=建立分支或標記
dialog.title.can.not.invoke.action=無法呼叫 {0}
dialog.title.changes.in.url={0} 中的更改
dialog.title.check.out=從 Subversion 簽出
dialog.title.commit.will.split=Subversion\\: 提交將進行拆分
dialog.title.computing.difference=正在計算差異
dialog.title.convert.working.copy.format=轉換工作副本格式
dialog.title.destination.directory=目標目錄
dialog.title.edit.http.proxies.settings=編輯與網絡層相關的 Subversion 選項
dialog.title.error=錯誤
dialog.title.export.directory=匯出目錄
dialog.title.import.directory=匯入目錄
dialog.title.integrate.to.branch=整合到分支
dialog.title.lock.file=鎖定檔案
dialog.title.lock.files=鎖定檔案
dialog.title.mark.resolved=標記已解決
dialog.title.mark.tree.conflict.resolved=將樹衝突標記為已解決
dialog.title.merge.from.branch=合併自 {0}
dialog.title.new.remote.folder=新增遠端目錄
dialog.title.relocate.working.copy=重新定位工作副本
dialog.title.resolve.tree.conflict=解決樹衝突
dialog.title.save.unified.diff=補丁檔案
dialog.title.select.configuration.directory=選擇組態目錄
dialog.title.select.merge.variant=選擇合併變體
dialog.title.select.path.to.subversion.executable=Subversion
dialog.title.select.repository.location=選擇版本庫位置
dialog.title.select.share.target=選擇共享目標
dialog.title.select.target.for.external=選擇用於外部的目標
dialog.title.select.working.copy.location=選擇工作副本位置
dialog.title.set.property=設定屬性
dialog.title.set.working.copy.infinity.depth=設定工作副本無限深度
dialog.title.ssh.examine.server.fingerprints=驗證伺服器密鑰指紋
dialog.title.ssh.settings.browse.executable=SSH 可執行檔案
dialog.title.ssh.settings.browse.private.key=私鑰
dialog.title.ssl.examine.server.crertificate=檢查伺服器憑證
dialog.title.svn.delete=SVN 刪除
dialog.title.svn.export.options=SVN 匯出選項
dialog.title.svn.import.options=SVN 匯入選項
dialog.title.svn.keywords=SVN 關鍵字
dialog.title.svn.properties.diff=SVN 屬性差異
dialog.title.svn.repository.browser=SVN 版本庫瀏覽器
dialog.title.switch.target.problem=切換目標問題
dialog.upgrade.wcopy.format.title=Subversion 工作副本格式
diff.cant.get.properties.changes=無法顯示 SVN 屬性
diff.options.checkbox.reverse.diff=反轉差異
diff.options.label.compare=比較\\:
diff.options.label.compare.type=比較類型
diff.options.label.with=與\\:
diff.options.no.patch.file.error=請指定儲存補丁檔案的路徑
diff.options.no.url.error=請選擇一個 URL 進行比較
diff.options.radio.graphical.compare=圖形比較
diff.options.radio.unified.diff=統合差異
diff.options.same.url.error=請選擇其他 URL 進行比較
diff.options.title=與分支或標記比較
error.authentication.canceled.for.repository=已對版本庫取消身份驗證\\: {0}
error.can.not.access.file.base.revision.contents.administrative.area.is.locked=無法存取檔案的基礎修訂內容\\: 管理區域已被鎖定
error.can.not.create.directory=無法建立目錄\\: {0}
error.can.not.delete.file=無法刪除檔案\\: {0}
error.can.not.find.file=找不到檔案\\: {0}
error.can.not.find.relative.path.for.path.at.revision=找不到 {0}@{1} 的相對路徑
error.can.not.find.repository.root.for.url=找不到 URL 的版本庫根\\: {0}
error.can.not.find.repository.root.for.url.in.revision=在修訂 {1} 中找不到 URL\\: {0} 的版本庫根
error.can.not.find.url.for.file=找不到檔案的 url\\: {0}
error.can.not.find.working.copy.for.file=找不到檔案的工作副本\\: {0}
error.can.not.get.current.revision.for.path=無法獲取檔案 {0} 的當前修訂
error.can.not.get.last.changed.revision.for.path.please.file.an.issue=無法獲取檔案上次進行的修訂\\: {0}\\n請為此檔案執行 svn info 並提交問題。
error.can.not.load.theirs.content.for.file=無法為檔案 {0} 載入他們的內容
error.can.not.set.property=無法設定屬性\\: {0}
error.cannot.load.revisions=無法載入修訂列表
error.could.not.compare.local.file.and.remote.url.with.executable.for.svn.version=無法將本地檔案和遠端 Url 與 svn {0} 的可執行檔案相比較
error.could.not.determine.revision.number.for.file.and.revision=無法確定檔案 {0} 和修訂 {1} 的修訂號
error.could.not.find.separating.space=找不到分隔空間
error.could.not.find.start.quote=找不到起始引號
error.could.not.get.head.info.for.url=無法獲取 {0} 的標頭資訊
error.could.not.get.info.for.path=無法獲取 {0} 的資訊
error.could.not.get.relative.path.for.parent.and.child=無法獲取 {0} 和 {1} 的相對路徑
error.could.not.get.revision.for.url=無法獲取 {0} 的修訂
error.could.not.get.svn.version=離開程式碼\\: {0}，錯誤\\: {1}
error.could.not.parse.merge.info=無法解析 {0}
error.could.not.parse.svn.version=無法解析 svn 版本\\: {0}
error.file.is.not.under.subversion=檔案 {0} 未受到 Subversion 控制
error.file.is.not.under.version.control=檔案 {0} 未進行版本管理
error.format.is.not.supported=不支持 {0} 格式。支援的格式\\: {1}。
error.integration.was.canceled=整合已被取消
error.invalid.svn.revision=無效的 svn 修訂\\: {0}
error.invalid.url=無效 url\\: {0}
error.latest.existing.revision.found.for.url=已找到 {0} 的最新現有修訂
error.missing.committed.revision.number=缺少提交的修訂號\\: {0}
error.move.have.not.been.performed=尚未執行 Subversion 移動。
error.no.branch.point.found.for.target=找不到 {0} 的分支點
error.parse.file.status.unknown.state.on.line=第 {0} 行的狀態未知
error.properties.loading.for.revision.canceled=已取消為修訂 {0} 載入屬性。
error.revert.failed=還原失敗
error.revision.from.must.be.a.valid.number=“起始修訂”必須為有效數字
error.revision.to.must.be.a.valid.number=“結束修訂”須為有效數字
error.selected.destination.conflicts.with.existing=所選目標與現有目標相衝突\\: {0}
error.server.ssl.certificate.rejected=伺服器 SSL 憑證被拒
error.svn.exited.with.error.code=SVN 程序已離開，錯誤程式碼為\\: {0}
error.svn.status.not.in.working.copy=請求的狀態不在工作副本中\\: {0}
error.svn.status.with.no.output=狀態請求沒有為指令返回任何內容\\: {0}
error.target.not.found.in.paths=在 {1} 中找不到 {0}
error.target.of.move.operation.is.already.under.version.control=移動動作的目標已受到版本控制。
error.url.could.not.contain.fragment={0} 不能包含片段
error.url.could.not.contain.query={0} 不能包含查詢
error.url.is.not.absolute={0} 非絕對
error.url.is.not.hierarchical={0} 非層次結構
error.wrong.committed.revision.number=提交的修訂號錯誤\\: {0}
exception.text.cannot.annotate.directory=註解動作僅對檔案有意義
exception.text.cleanupaction.batchperform.not.implemented=CleanupAction.batchPerform 未實作
exception.text.failed.to.unlock.file=無法解鎖檔案\\: {0}
exception.text.file.miss.svn=檔案 ''{0}'' 為唯讀，但缺少 svn\\:needs-lock 屬性
exception.text.locking.file.failed=無法鎖定檔案\\: {0}
exception.text.root.was.not.properly.updated=svn\\: {0} 未正確更新; 可能是因為它已經與父級一起從版本庫中移除。
exportable.SvnDiffSettings.presentable.name=SVN 差異
file.conflict.property=屬性
file.conflict.text=文本
file.conflict.tree=樹
file.status.external=外部 (svn)
file.status.obstructed=受阻 (svn)
file.status.replaced=取代 (svn)
global.group=全域
group.IgnoreChoicesGroup.text=忽略
group.RevertIgnoreChoicesGroup.text=從忽略列表中移除
group.SubversionFilePopupGroup.text=Subversion(_S)
import.dialog.button=匯入
import.dialog.title=匯入 Subversion
integrate.configuration.description.label=將源之間的差異整合到工作副本中(比較源 2 和源 1)
integrate.configuration.revision1.label=修訂(&V)
integrate.configuration.revision2.label=修訂(&R)
integrate.configuration.source1.label=源 1\\:
integrate.configuration.source2.label=源 2\\:
integrate.display.name=整合
label.after.accepting.theirs.for.path=在接受他們對 {0} 的更改後
label.already.merged=已合併
label.auth.authentication.realm=身份驗證領域\\: ''{0}''
label.auth.password=密碼(&P)\\:
label.auth.user.name=用戶名(&U)\\:
label.before.accepting.theirs.for.path=在接受他們對 {0} 的更改前
label.branch.base.url=基 URL\\:
label.branch.name=名稱\\:
label.changelists.merging.faced.problems=更改列表\\:\\n{0}\\n合併面臨的問題
label.commit.message=提交訊息\\:
label.configure.change.label=將工作副本 ''{0}'' 格式更改為\\:
label.configure.create.label={0} 將要建立新的 Subversion 工作副本，\\n請選擇所需的工作副本格式\\:
label.configure.upgrade.label=工作副本升級策略\\:
label.conflict.directory.added=(目錄)已新增
label.conflict.directory.unversioned=(目錄)未進行版本管理
label.conflict.file.added=(檔案)已新增
label.conflict.file.unversioned=(檔案)未進行版本管理
label.conflict.left.side=左\\: {0}
label.conflict.right.side=右\\: {0}
label.copy.comment=&註釋
label.copy.from=複製自
label.copy.from.revision=修訂(&V)\\:
label.copy.select.location.dialog.copy.as=複製為(&A)\\:
label.copy.to=複製到
label.define.share.target=定義共享目標
label.depth.description=取代舊的“遞迴”選項。“遞迴”為 false 等效於“直接子級”，“遞迴”為 true 等效於“無限”
label.depth.empty=空
label.depth.exclude=排除
label.depth.files=檔案
label.depth.immediates=直接
label.depth.infinity=無限
label.depth.text=深度(&D)\\:
label.depth.unknown=未知
label.destination=目標\\:
label.export=匯出\\:
label.external.copy=外部副本
label.file.has.conflicts=檔案有 {0} 個衝突，無法提交
label.file.has.conflicts.before.and.after=檔案有 {0} 個衝突，無法提交\\n之前\\: {1}\\n之後\\: {2}
label.file.has.conflicts.before.or.after=檔案有 {0} 個衝突，無法提交\\n{1}
label.from.url=源 URL\\:
label.import.from=匯入自\\:
label.import.to=匯入到\\:
label.local.target=本地目標\\:
label.locally.deleted.file.has.conflicts=檔案有 {0} 個衝突
label.lock.comment=鎖定註釋(&L)\\:
label.locl.steal.existing=竊取現有鎖(&S)\\:
label.merge.all.from.branch=合併 {0} 中的全部內容
label.merge.all.from.branch.at.revision=合併 {1} 的 {0} 中的全部內容
label.merge.all.from.branch.at.revision.reintegrate=合併 {1} 的 {0} 中的全部內容(重新整合)
label.merge.all.from.branch.reintegrate=合併 {0} 中的全部內容(重新整合)
label.merge.from.url=從\\:
label.merge.local.changes.intersection=以下檔案具有與合併更改相交的本地更改\\:
label.merge.source.revision=合併原始碼修訂
label.merge.to.branch=到\\:
label.merged.from.branch=已合併自 {0}
label.mixed.revision.working.copy=混合修訂工作副本
label.nested.copy.type.external=外部
label.nested.copy.type.inner=嵌套
label.nested.copy.type.switched=已切換
label.no.subversion.1.5.working.copies=此專案中沒有 1.5 版本庫的 Subversion 1.5 工作副本
label.override.native.eols.with=覆寫 'native' EOL 的選項\\:
label.path.revisions.info={0}(當前\\: {1}，已提交\\: {2})
label.path.to.svn.executable=Subversion 可執行檔案的路徑\\:
label.point.to.repository.location=指向版本庫位置
label.recent.messages=最近的訊息\\:
label.remote.folder.name=遠端目錄名稱\\:
label.remote.folder.url=遠端目錄 URL\\:
label.repositories=版本庫\\:
label.revision=修訂
label.select.checkout.destination.directory=選擇簽出目標目錄
label.select.directory.to.export.from.subversion=選擇要從 Subversion 匯出的目錄
label.select.directory.to.import.into.repository=選擇要匯入版本庫的目錄
label.select.export.destination.directory=選擇匯出目標目錄
label.select.file.to.save.unified.diff=選擇用於存儲統合差異的檔案
label.select.files.and.directories.to.mark.resolved=選擇要標記為已解決的檔案和目錄\\:
label.select.keywords.to.set=選擇要設定的關鍵字\\:
label.select.location.to.copy.from=選擇要從中複製的位置\\:
label.select.path.to.subversion.executable=選擇 Subversion 可執行檔案(1.7+)的路徑
label.select.target.working.copy=選擇目標工作副本的路徑
label.set.property.property.name=屬性名稱(&N)\\:
label.skipped.changelists=已跳過的更改列表\\: {0}
label.source.url=源 URL\\:
label.specify.ssl.protocol.manually=請嘗試手動指定 SSL 協議 - SSLv3 或 TLSv1
label.ssh.key.file=密鑰檔案(&F)\\:
label.ssh.passphrase=密碼短語(&R)\\:
label.ssh.server.provided.fingerprints=無法建立主機 {0} 的驗證。
label.ssh.server.provided.fingerprints2={0} 密鑰指紋為
label.ssh.server.provided.fingerprints3=確定要繼續連線嗎?
label.ssl.certificate.password=憑證密碼短語\\:
label.ssl.certificate.path=憑證路徑\\:
label.ssl.server.provided.certificate=伺服器提供了以下憑證\\:
label.svn.phantom.change=技術記錄
label.svn.properties.changed=SVN 屬性已更改
label.switched.copy=已切換副本
label.target.location=目標位置\\:
label.target.name=目標名稱\\:
label.target.url=目標 URL\\:
label.text.delete.stored.credentials=刪除 'http'、'svn' 和 'svn+ssh' 協議的所有已存儲憑證
label.to.url=目標 URL\\:
label.update.switch.to.revision=更新/切換到修訂\\:
label.update.url=URL\\:
label.working.copy=工作副本
label.working.copy.depth=深度\\:
label.working.copy.format=格式\\:
label.working.copy.format.unknown=未知
label.working.copy.root=工作副本根
label.working.copy.root.outside.text=工作副本根位於“專案設定”中指定的目錄外部。\\n整個工作副本將被轉換。
label.working.copy.url=URL\\:
link.change.format=更改
link.fix.depth=修正
merge.chunk.changelist.description={0} [來自於修訂 {1}]
merge.source.details.title=合併 {0} [{1}] 的原始碼詳細資訊
message.text.cannot.checkout=無法從 svn 簽出\\: {0}
message.text.cannot.export=無法從 svn 匯出\\: {0}
message.text.cannot.import=無法匯入 svn\\: {0}
message.text.cannot.load.supported.formats=無法載入支援的格式\\: {0}
message.text.files.lock.failed={0,choice, 0\\#無法鎖定檔案。|1\\#無法鎖定檔案。}
message.text.files.locked={0,choice, 0\\#無法鎖定檔案。|1\\#已鎖定 1 個檔案|2\\#已鎖定 {0,number} 個檔案}
message.text.files.unlocked={0,choice, 0\\#無法解鎖檔案。|1\\#已解鎖 1 個檔案|2\\#已解鎖 {0,number} 個檔案}
message.text.no.conflicts.found=未找到衝突
message.text.update.no.directories.found=找不到要更新的版本管理目錄
message.theirs.accepted.for.file=已接受他們對 {0} 的更改
message.theirs.changes.merged.for.file=已針對 {0} 合併他們的更改
message.title.export=從 Subversion 匯出
message.title.import=匯入 Subversion
message.title.no.conflicts.found=無衝突
message.title.unlock.failures=解鎖失敗
message.yours.accepted.for.file=已接受您對 {0} 的更改
messate.text.update.error=SVN\\: 更新錯誤
move.dialog.title=移動或重新命名
move.files.errors.title=移動檔案時出錯
navigate.to.idea.proxy.settings=導覽到一般代理設定
no.differences.between.sources.error.message=源和相同源之間沒有區別
non.english.locale.detected.warning=使用了非英語區域設定。
notification.action.click.to.fix=點擊以修正。
notification.content.authentication.failed=身份驗證失敗\\: {0}
notification.content.branches.load.error=分支載入錯誤\\: {0}
notification.content.can.not.access.working.copy.database=存取 svn 工作副本資料庫時發生了若干錯誤。
notification.content.can.not.merge.from.self=無法自我合併
notification.content.everything.is.up.to.date=所有內容都已處於最新狀態
notification.content.merge.start.was.not.found=找不到合併起始點
notification.content.multiple.roots.unsupported.format=某些根的格式可能是不受支援的 Subversion 格式
notification.content.not.logged.into.subversion=未登錄到 Subversion ''{0}'' ({1})
notification.content.revision.commit.message.changed.to=修訂 \\#{0} 註釋更改為\\:\\n''{1}''
notification.content.single.root.unsupported.format=根 ''{0}'' 可能是不受支援的 Subversion 格式
notification.content.unknown.certificate.type.from.url=Subversion\\: {0} 中的憑證類型未知
notification.group.svn.roots=Subversion 根檢測失敗
notification.title.not.logged.into.subversion=未登錄到 Subversion
operation.merge=合併
popup.content.already.checking=正在檢查…
popup.content.failed.to.authenticate.to.proxy=代理驗證失敗。
popup.content.failed.to.authenticate.to.proxy.change.credentials=代理驗證失敗。您可以在 HTTP 代理設定中更改代理憑證。
popup.title.select.branch=選擇分支
popup.title.select.branch.to.integrate.to=選擇要整合到的分支…
progres.text2.merged=已合併 {0}
progres.text2.updated=已更新 {0}
progres.text2.updated.to.revision=已更新至修訂 {0}。
progress.details.merging.changelist.range=正在合併更改列表 {0}
progress.details.upgraded.path=已升級路徑 {0}
progress.live.provider.loading.revisions.details.text=正在從伺服器載入修訂…
progress.live.provider.loading.revisions.text=正在從伺服器載入修訂
progress.message.connecting.to.url=正在連線到 {0}
progress.searching.for.files.with.conflicts=正在搜尋有衝突的檔案
progress.text.browser.copying=正在拷貝{0}
progress.text.browser.creating=正在建立 {0}
progress.text.browser.moving=正在移動 {0}
progress.text.browser.remote.destination=到 {0}
progress.text.changes.collecting.changes=正在收集有關更改的資訊
progress.text.checking.out=正在將檔案簽出到 ''{0}''
progress.text.clearing.stored.credentials=正在清除 {0} 中存儲的憑證
progress.text.collecting.merge.information=正在收集合併資訊
progress.text.collecting.not.merged.revisions=正在收集未合併的修訂
progress.text.computing.annotation=正在計算 ''{0}'' 的註解
progress.text.converting.working.copy.format=將 {0} 格式的工作副本從 {1} 轉換為 {2}
progress.text.copy.to=複製到 ''{0}''
progress.text.create.remote.folder=建立遠端目錄
progress.text.deleting=正在刪除 {0}
progress.text.export=正在將檔案匯出到 ''{0}''
progress.text.import=匯入 {0}
progress.text.loading.contents=正在載入 ''{0}'' 的內容
progress.text.locking.files=正在鎖定版本庫中的檔案…
progress.text.merging.changes=正在將更改合併到 ''{0}''
progress.text.merging.dry.run.changes=正在將(dry run)更改合併到 ''{0}''
progress.text.performing.path.cleanup=正在執行 ''{0}'' 清理…
progress.text.unlocking.files=正在解鎖版本庫中的檔案…
progress.text.updating=正在更新 ''{0}''
progress.text.updating.external.location=正在更新 ''{0}'' 的外部位置
progress.text2.added=已新增 {0}
progress.text2.adding=正在新增 ''{0}''
progress.text2.changes.establishing.connection=正在建立與 ''{0}'' 的連線
progress.text2.checked.out=已簽出 {1} 個檔案，正在簽出 {0}
progress.text2.checked.out.revision=已簽出修訂 {0}。
progress.text2.collecting.history=正在收集 ''{0}'' 的修訂歷史記錄
progress.text2.conflicted={0} 存在衝突
progress.text2.deleted=已刪除 {0}
progress.text2.deleting=正在刪除 ''{0}''
progress.text2.exported=已匯出 {1} 個檔案，正在匯出 {0}
progress.text2.exported.revision=已匯出修訂 {0}。
progress.text2.fetching.external.location=正在獲取 ''{0}'' 的外部位置
progress.text2.processing.file=正在處理檔案 {0}
progress.text2.processing.revision=正在處理修訂 ''{0}''
progress.text2.replacing=正在取代 ''{0}''
progress.text2.restored.file=已還原 {0}
progress.text2.revision.information=修訂{0}
progress.text2.revision.processed=已處理修訂 ''{0}''
progress.text2.sending=正在發送 ''{0}''
progress.text2.skipped.file=已跳過 {0}
progress.text2.transmitting.delta=正在傳輸 ''{0}'' 的增量
progress.text2.treeconflicted=已衝突 {0}(樹衝突)
progress.title.accepting.theirs.for.path=正在接受他們對 {0} 的更改
progress.title.accepting.working.state=正在接受工作狀態
progress.title.accepting.yours.for.path=為之接受您的更改\\: {0}
progress.title.adding.file.to.subversion=正在將 {0} 新增到 Subversion
progress.title.adding.files.to.subversion=正在向 Subversion 新增檔案
progress.title.applying.binary.changes=正在套用二進制更改
progress.title.browser.copy=複製
progress.title.browser.delete=刪除
progress.title.browser.move=移動
progress.title.calculating.copy.revision=正在計算副本修訂
progress.title.check.out=從 Subversion 簽出
progress.title.check.out.cancel=停止從 Subversion 簽出
progress.title.check.remote.folder.contents=檢查遠端目錄內容
progress.title.checking.repository.capabilities=正在檢查版本庫容量
progress.title.checking.target.folder=正在檢查目標目錄
progress.title.cleanup.project=清理專案
progress.title.clear.authentication.cache=清除身份驗證快取(&C)
progress.title.commit=提交
progress.title.convert.working.copy.format=轉換工作副本格式
progress.title.copy=Subversion 副本
progress.title.creating.external=正在建立外部
progress.title.creating.patch.for.theirs.changes=正在為其更改建立補丁
progress.title.deleting.files.from.subversion=正在從 Subversion 中刪除檔案
progress.title.detecting.repository.root=正在檢測版本庫根
progress.title.edit.revision.comment=編輯修訂註釋
progress.title.filtering.branch.revisions=正在篩選 {0} 修訂
progress.title.getting.base.and.theirs.revisions.content=獲取基本內容及其修訂內容
progress.title.getting.latest.repository.revision=正在獲取最新的版本庫修訂
progress.title.loading.branches=正在載入分支
progress.title.loading.change.details=正在載入更改詳細資訊
progress.title.loading.child.entries=正在載入子條目
progress.title.loading.file.content=正在載入遠端檔案內容
progress.title.loading.file.properties=正在載入遠端檔案屬性
progress.title.loading.recent.branch.revisions=正在載入最近的 {0} 修訂
progress.title.loading.tree.conflict.details=正在載入樹衝突詳細資訊
progress.title.loading.working.copies.data=Subversion\\: 正在載入工作副本資料…
progress.title.lock.files=鎖定檔案
progress.title.looking.for.branch.origin=正在尋找分支來源
progress.title.looking.for.file.working.copy.root=正在尋找 ''{0}'' 工作副本根
progress.title.mark.tree.conflict.resolved=將樹衝突標記為已解決
progress.title.merging.all.from.branch=正在合併 {0} 中的全部內容
progress.title.merging.all.from.branch.reintegrate=正在合併 {0} 中的全部內容(重新整合)
progress.title.moving.files.in.subversion=正在移動 Subversion 中的檔案
progress.title.relocating.working.copy=正在重定位工作副本
progress.title.resolve.tree.conflict=解決樹衝突
progress.title.share.directory=共享目錄
progress.title.shelving.local.changes.before.merge=正在擱置合併前的本地更改
progress.title.svn.branches.preloader=Subversion 分支預載入程序
progress.title.svn.roots.authorization.checker=SVN VCS 根授權檢查器
progress.title.test.connection=測試連線
progress.title.unlock.files=解鎖檔案
quick.merge.variants.merge.all=全部合併
quick.merge.variants.merge.all.explanation=所有未合併的修訂將被合併。\\nSubversion 將使用本地副本中記錄的 svn\\:mergeinfo 屬性尋找未合併的修訂。
quick.merge.variants.pre.select=通過預篩選選擇
quick.merge.variants.pre.select.explanation=尋找涉及的一個分支複製自另一個分支的位置。\\n僅載入尚未合併的修訂以供選擇。執行可能需要很長時間。
quick.merge.variants.quick.select=快速手動選擇
quick.merge.variants.quick.select.explanation=顯示來自目標分支、已合併和未合併分支的所有修訂。\\n用於手動選擇。快速獲取結果。
radio.configure.change.auto.16format=1.6 格式(&6)
radio.configure.change.auto.17format=1.7 格式(&7)
radio.configure.change.auto.18format=1.8 格式(&8)
radio.configure.create.auto.16format=1.6 格式(&6)
radio.configure.create.auto.17format=1.7 格式(&7)
radio.configure.create.auto.18format=1.8 格式(&8)
radio.configure.upgrade.auto.16format=自動升級(使用 Subversion 1.6)(&6)
radio.configure.upgrade.auto.17format=自動升級(使用 Subversion 1.7)(&7)
radio.configure.upgrade.auto.18format=自動升級(使用 Subversion 1.8)(&8)
radio.copy.repository.location=版本庫位置(&R)\\:
radio.copy.to.any.location=任何位置
radio.copy.to.branch.or.tag=分支或標籤
radio.copy.working.copy=工作副本(&W)
radio.set.property.delete.property=刪除屬性(&D)
radio.set.property.set.property.value=設定屬性值(&S)\\:
radio.share.target.at.selected.repository.location=在所選版本庫位置
radio.share.target.in.new.folder=在所選版本庫位置的新“{0}”目錄中
refresh.branches.item=重新整理分支…
repository.browser.add.location.action.description=新增版本庫位置
repository.browser.add.location.action.text=新增版本庫位置
repository.browser.add.location.menu.item=版本庫位置(_R)…
repository.browser.add.location.prompt=版本庫 URL\\:
repository.browser.add.location.title=新增版本庫位置
repository.browser.browse.changes.action=瀏覽更改(_B)…
repository.browser.browse.changes.description=檢視選定節點中的更改歷史記錄
repository.browser.compare.title=比較 ''{0}'' 和 ''{1}''
repository.browser.details.action=顯示/隱藏詳細資訊
repository.browser.discard.location.action=捨棄位置(_L)
repository.browser.discard.location.prompt=要捨棄位置 ''{0}'' 嗎?
repository.browser.discard.location.title=捨棄位置
repository.browser.edit.location.dialog.title=編輯位置 URL
repository.browser.edit.location.menu.item=編輯位置 URL(_U)…
repository.browser.import.action=匯入(_I)…
repository.browser.new.folder.action=遠端目錄(_F)…
repository.browser.no.locations.added.info=未新增版本庫位置。
repository.browser.refresh.action=重新整理選定樹節點
revision.title=修訂
select.location.invalid.url.message=無效的 Subversion 版本庫 URL\\: ''{0}''
separator.commit.comment.prefix=提交註釋前綴
separator.property.changes=屬性更改
server.ssl.accept.temporary.action.name=接受臨時(_T)
settings.HTTP.timeout=HTTP 超時\\:
settings.SSH.connection.timeout=SSH 連線超時\\:
settings.SSH.read.timeout=SSH 讀取超時\\:
settings.check.mergeinfo=準備合併時檢查目標子樹中的 svn\\:mergeinfo
settings.edit.servers.subversion.runtime.configuration.file=編輯 'servers' Subversion 執行時組態檔案
settings.maximum.revisions.number=註解中可回顧的最大修訂數\\:
settings.seconds=秒
settings.ssl.protocols=SSL 協議\\:
settings.ssl.protocols.all=所有
settings.ssl.protocols.all.tlsv1=TLSv1
settings.ssl.protocols.sslv3=SSLv3
settings.use.custom.directory=使用自訂組態目錄(&U)\\:
share.directory.action=共享目錄…
share.directory.checkout.back.progress.text=正在簽出 {0}
share.directory.commit.message={2}\\n{1} 建立的目錄 ''{0}''
share.directory.create.dir.progress.text=正在建立遠端目錄 {0}
share.directory.info.message=要完成共享動作，請提交 ''{0}''。
share.directory.title=共享目錄
share.or.import.add.progress.text=正在排定 {0} 的新增時間表
show.properties.diff.progress.text.revision.information=修訂{0}
show.properties.diff.progress.text2.property.information=屬性 {0}
source.url.could.not.be.empty.error.message=源 URL 不能為空
ssh.settings.executable.label=SSH 可執行檔案\\:
ssh.settings.password.choice.title=密碼
ssh.settings.port.label=連接埠\\:
ssh.settings.private.key.choice.title=私鑰
ssh.settings.private.key.path.label=路徑\\:
ssh.settings.subversion.config.choice.title=Subversion 組態
ssh.settings.tunnel.label=SSH 隧道\\:
ssh.settings.update.tunnel.title=更新
ssh.settings.user.name.label=用戶名\\:
status.group.name.replaced=已取代
status.text.checked.out.revision=已簽出修訂 {0}。
status.text.committed.revision=提交的修訂 {0}。
status.text.merge.sources=合併原始碼
status.text.updated.to.revision=已更新至修訂 {0}。
subversion.executable.notification.cant.run.in.safe.mode=無法在安全模式下執行 Svn 指令
subversion.executable.notification.description=Subversion 可執行檔案的路徑可能是錯誤的。
subversion.executable.notification.title=無法使用 Subversion 命令行客戶端
subversion.executable.too.old=Subversion 命令行客戶端版本過舊({0})。
subversion.roots.detection.errors.found.action.text=修復
subversion.roots.detection.errors.found.description=檢測 Subversion 工作副本時發現錯誤。
svn.cannot.save.credentials.store-auth-creds=無法存儲憑證\\: “store-auth-creds \\= no”禁止
svn.edit.commit.message.attention=注意\\! 以前的訊息將丟失\\!
svn.edit.commit.message.prompt=新修訂註釋\\:
svn.edit.commit.message.title=編輯修訂 \\#{0} 註釋
svn.integrate.changelist.warning.unresolved.conflicts.text=整合中斷。存在未解決的衝突或跳過的項。
svn.name.with.mnemonic=Subversion(_S)
svn.option.ignore.whitespace.in.annotate=忽略註解中的空格差異
svn.phantom.changes.viewer=SVN 模擬更改檢視器
svn.properties.viewer=SVN 屬性檢視器
svn.short.name.with.mnemonic=SVN(_S)
svn.tree.conflict.viewer=SVN 樹衝突檢視器
tab.repository.merge.panel.filter.minus=篩選出未整合項
tab.repository.merge.panel.filter.others=篩選出其他
tab.repository.merge.panel.filter.plus=篩選出整合項
tab.title.create.external=建立外部
tab.title.edit.revision.comment=編輯修訂註釋
tab.title.failed.to.share.project=無法共享專案
tab.title.merge.local.changes.intersection={0}，本地更改相交
text.svn.phantom.change=已記錄此更改，因為其目標檔案被刪除，\\n並且某些父目錄已複製(或移動)到新位置。
tooltip.revision.number.message=修訂 {0}\\: {1}
tooltip.use.project.location=使用專案位置
toolwindow.stripe.SVN_Properties=SVN 屬性
toolwindow.stripe.SVN_Repositories=SVN 版本庫
toolwindow.working.copies.info.title=Subversion 工作副本資訊
tree.conflict.description=本地 {0}，{2} 時傳入 {1}
undo.integrate.to.branch=撤消整合到分支…
undo.integrate.to.branch.description=從分支中移除修訂中所做的更改
undo.integrate.to.branch.dialog.title=撤消整合到分支
update.configuration.specific.url=更新/切換到特定 URL(&U)\\:
update.switch.configurable.name=更新/切換
update.switch.to.branch.text=使用分支\\:
use.idea.proxy.as.default=將 {0} 一般代理設定用作 Subversion 的預設設定
use.idea.proxy.as.default.label.text=只有 HTTP 代理可以用作預設設定
value.new.branch.name=new_branch
value.new.folder.name=NewFolder
value.new.server.group.name=未命名
value.patch.file.name=TheirsChanges.patch
"
`;

exports[`src messages/VcsBundle.properties 1`] = `
"ChangesBrowserToolWindow.toolwindow.name=更改
RepositoryBrowser.toolwindow.name=版本庫
action.AnActionButton.text.add.jira.pattern=新增 JIRA 模式
action.AnActionButton.text.add.youtrack.pattern=新增 YouTrack 模式
action.Anonymous.text.remove.all.leading.directories=移除所有前導目錄
action.Anonymous.text.restore.all.leading.directories=還原所有前導目錄
action.ChangesView.ShowIgnored.description=顯示忽略的檔案
action.ChangesView.ShowIgnored.text=已忽略的檔案
action.DumbAware.ApplyPatchDifferentiatedDialog.description.refresh=重新整理
action.DumbAware.ApplyPatchDifferentiatedDialog.text.refresh=重新整理
action.DumbAwareAction.text.compare.with.local.content=與本地內容比較
action.ImportIntoShelfAction.description=將補丁檔案複製到擱置
action.ImportIntoShelfAction.text=匯入補丁…
action.NotificationAction.AllVcses.text.install=安裝
action.NotificationAction.AllVcses.text.open.plugin.page=開啟“延伸模組”頁面
action.NotificationAction.AllVcses.text.read.more=閱讀更多
action.NotificationAction.InactiveRangesDamagedNotification.text.view.changes=檢視更改…
action.NotificationAction.VFSListener.text.view.files=檢視檔案…
action.NotificationAction.VcsRootProblemNotifier.text.configure=組態…
action.NotificationAction.VcsRootProblemNotifier.text.enable.integration=啟用整合
action.NotificationAction.VcsRootProblemNotifier.text.ignore=忽略
action.SearchFieldAction.text.find=尋找\\: 
action.ShowAffectedFilesAction.show.affected.files.text=顯示受影響的檔案
action.ToggleAction.description.show.details=顯示詳細資訊面板
action.ToggleAction.text.preview.diff=預覽差異
action.ToggleAction.text.scope.filter=作用域篩選器
action.ToggleAction.text.show.details=顯示詳細資訊
action.Vcs.Commit.CloseDialog.text=關閉提交對話框
action.Vcs.Toolbar.QuickListPopupAction.text=VCS 動作
action.amend.commit.anyway.text=仍然修正
action.annotate.previous.revision.text=註解之前的修訂
action.annotate.revision.text=註解修訂
action.annotate.selected.revision.in.new.tab.description=在新頁籤中註解所選修訂
action.annotate.show.diff.preview.on.hover.text=懸停時顯示差異
action.annotate.successor.selected.revision.in.new.tab.description=在新頁籤中註解所選修訂的後繼者
action.clone.dialog.stub.click.to.continue=點擊“{0}”繼續
action.commit.anyway.text=仍然{0}
action.description.compare=比較版本
action.description.create.patch.for.selected.revisions=為所選修訂建立補丁
action.description.refresh=重新整理檔案歷史記錄
action.description.refresh.compare.with.local.panel=重新整理更改
action.display.name.check.scope.status=檢查{0}狀態
action.display.name.integrate.scope=整合{0}
action.display.name.update=更新
action.display.name.update.scope=更新{0}
action.enable.version.control.integration.text=啟用版本控制整合(_E)…
action.filter.filter.by.text=篩選依據
action.filter.moved.files.text=已移動且無更改
action.filter.non.important.files.text=包含不重要的更改
action.filter.separator.text=隱藏檔案
action.for.file.with.dialog.text={0}{1, choice, 1\\#檔案|2\\#檔案}…
action.import.to.shelf=匯入到 Shelf
action.message.use.selected.changes.description={0}所選更改
action.name.check.scope.status=檢查{0}狀態(_K)
action.name.check.status=檢查狀態(_K)
action.name.checkin.directory={0}{1,choice,1\\#目錄|2\\#目錄}
action.name.checkin.file={0}{1,choice,1\\#檔案|2\\#檔案}
action.name.compare=比較
action.name.create.patch=建立補丁…
action.name.get.file.content.from.repository=從修訂中獲取
action.name.group.by.packages=按軟體套件分組
action.name.integrate=合併 (_G)
action.name.integrate.scope=合併 {0}(_G)
action.name.refresh=重新整理
action.name.refresh.compare.with.local.panel=重新整理
action.name.show.difference=顯示差異
action.name.show.files.as.tree=作為樹顯示
action.name.show.history.for.class=類別
action.name.show.history.for.code.block=程式碼塊
action.name.show.history.for.field=欄位
action.name.show.history.for.function=函式
action.name.show.history.for.method=方法
action.name.show.history.for.selection=選區
action.name.show.history.for.statement=語句
action.name.update=更新(_U)
action.name.update.scope=更新{0}(_U)
action.presentation.ApplySelectedChangesAction.text=接受
action.presentation.DiffShelvedChangesWithLocalActionProvider.description=將擱置版本與當前版本進行比較
action.presentation.IgnoreSelectedChangesAction.text=忽略
action.presentation.ShowUpdatedDiffActionProvider.description=更新前顯示與版本的差異
action.vcs.log.show.separator=顯示
activity.name.amend.message=修正提交\\: {0}
activity.name.apply.patch=套用補丁
activity.name.commit=提交更改
activity.name.commit.message=提交更改\\: {0}
activity.name.get=從 VCS 獲取
activity.name.get.from=從 {0} 獲取
activity.name.rollback=回滾
activity.name.shelve=擱置更改
activity.name.unshelve=取消擱置
activity.name.update=從 VCS 更新
acton.name.get.revision=獲取修訂
add.issue.dialog.invalid.regular.expression=無效的正則表達式\\: {0}
add.issue.dialog.issue.example.border.title=範例
add.issue.dialog.issue.id.label=問題 ID\\:
add.issue.dialog.issue.id.regular.expression=問題 ID (正則表達式)\\:
add.issue.dialog.issue.link.label=問題鏈接\\:
add.issue.dialog.issue.link.replacement.expression=問題鏈接 (取代表達式)\\:
add.issue.dialog.issue.no.match=<無符合>
advanced.setting.vcs.annotations.preload=在編輯器中開啟檔案時載入 VCS 中的檔案註解
advanced.setting.vcs.annotations.preload.description=這樣就可以更快速地按需顯示。
advanced.setting.vcs.commit.tool.window=啟用“提交”工具視窗
advanced.setting.vcs.commit.tool.window.description=在單獨的“提交”工具視窗中顯示“本地更改”和“擱置”頁籤
advanced.setting.vcs.non.modal.commit.toggle.ui=切換提交控件
advanced.setting.vcs.non.modal.commit.toggle.ui.description=執行提交後隱藏提交面板和複選框，並允許在“本地更改”中切換提交 UI
advanced.setting.vcs.process.ignored=醒目提示忽略的檔案
advanced.setting.vcs.process.ignored.description=請求 VCS 中被忽略檔案的列表，並在 IDE 中顯示這些檔案的狀態
advanced.setting.vcs.push.all.with.commits=選擇包含要推送的新提交的所有版本庫
advanced.setting.vcs.push.all.with.commits.description=預設預先選擇包含要推送的提交的所有版本庫
advanced.settings.vcs=版本控制
amend.action.name=修正{0}
amend.commit.different.committer.warning=修正後提交的提交者與預設設定不同
amend.commit.load.details.task.title=正在載入提交詳細資訊
amend.commit.load.message.error.text=無法載入待修正提交的提交訊息。
amend.commit.load.message.error.title=提交訊息未載入
amend.commit.load.message.task.title=正在載入提交訊息
amend.commit.tree.node.loading=正在載入修正的提交…
annotate.action.description=註解檔案
annotate.action.name=註解
annotate.action.view.group.text=檢視
annotation.background=註解背景
annotation.commit.number=提交編號
annotation.original.revision.text=修訂\\: {0}
annotation.switch.to.merged.text=顯示合併原始碼
annotation.switch.to.original.text=隱藏合併原始碼
annotation.wrong.line.number.notification.text=<html>由 {0} 註解的行數與檔案中的行數不相等。請檢查檔案編碼和行分隔符。</html>
annotations.color.mode.author=作者
annotations.color.mode.group.colors=顏色
annotations.color.mode.hide=隱藏
annotations.color.mode.order=順序
annotations.short.name.type.email=電子郵件
annotations.short.name.type.first.name=名字
annotations.short.name.type.full.name=全名
annotations.short.name.type.group.names=姓名
annotations.short.name.type.initials=初始
annotations.short.name.type.last.name=姓氏
before.checkin.cleanup.code=清理(&L)
before.checkin.cleanup.code.profile=使用 ''{0}'' 組態檔案清理(&L)
before.checkin.error.in.plugin=無法檢查提交\\: 延伸模組 ''{0}'' 中存在錯誤
before.checkin.error.internal=無法檢查提交\\: 內部錯誤
before.checkin.error.multiple.changelists.selected=選擇了多個更改列表進行提交
before.checkin.error.unknown=無法檢查提交
before.checkin.error.unresolved.merge.conflicts=檔案有未解決的衝突
before.checkin.new.todo.check=檢查 TODO ({0})
before.checkin.new.todo.check.no.filter=檢查 TODO
before.checkin.options.check.smells.choose.profile=選擇組態檔案
before.checkin.options.check.smells.profile=使用 ''{0}'' 組態檔案分析程式碼(&A)
before.checkin.post.commit.error.dumb.mode=現在無法進行程式碼分析
before.checkin.standard.options.check.smells=分析程式碼(&A)
before.checkin.waiting.for.smart.mode=正在等待智能模式…
before.commit.file.contains.code.smells.edit.them.confirm.text=檔案 {0} 有問題。\\n{1,choice, 0\\#無錯誤|1\\#1 個錯誤|2\\#{1} 個錯誤}和{2,choice, 0\\#無警告|1\\#1 個警告|2\\#{2} 個警告}。\\n要檢視它們嗎?
before.commit.files.contain.code.smells.edit.them.confirm.text={0} 個檔案有問題。\\n{1,choice, 0\\#無錯誤|1\\#1 個錯誤|2\\#{1} 個錯誤}，{2,choice, 0\\#無警告|1\\#1 個警告|2\\#{2} 個警告} \\n要檢視它們嗎?
before.commit.run.configuration.failed=''{0}'' 失敗，離開程式碼為 {1}
before.commit.run.configuration.failed.edit.configuration=編輯執行組態
before.commit.run.configuration.failed.to.start=無法啟動 ''{0}''
before.commit.run.configuration.no.configuration.selected.checkbox=執行組態
before.commit.run.configuration.tests.failed=''{0}'' - {1}
border.changes.filter.change.number.filter=更改
border.changes.filter.date.filter=日期
border.selected.revision.commit.message=提交訊息
border.standard.after.checkin.options.group=在{0}之後
browse.changes.action=瀏覽更改
browse.changes.content.title={0}下的更改
browse.changes.error.message=存取 VCS 時發生問題\\: {0}
browse.changes.error.title=無法顯示更改
browse.changes.filter.title=指定搜尋條件
browse.changes.no.filter.prompt=尚未指定任何篩選條件。確定要檢視專案的整個歷史記錄嗎?
browse.changes.nothing.found=未找到與條件符合的任何更改
browse.changes.nothing.found.title=未找到任何更改
browse.changes.progress.title=正在搜尋更改
browse.changes.scope=影響 {0} 的更改
browse.changes.show.all.button=顯示所有更改
browse.changes.show.recent.button=顯示最近的更改
browse.changes.title=瀏覽更改
button.apply.patch=套用補丁
button.clear=清除
button.remove=移除
button.search.again=再次搜尋
button.skip=跳過
button.text.overwrite.modified.file=覆蓋已修改的檔案(&O)
button.text.overwrite.modified.files=覆蓋已修改的檔案(&O)
button.tooltip.remove.commit.author.date=移除
cache.settings.dialog.title=VCS 歷史記錄快取設定
cannot.apply.file.already.exists=無法將補丁套用到檔案 {0}\\: 它已存在。
cannot.create.directory.for.patch=不能建立檔案\\: {0}。{1}
cannot.find.file.to.patch=找不到要套用補丁的檔案\\: {0}
change.dialog.title.change.list.name={0} [{1}]
change.dialog.title.in.change.list.name={1} 中的 {0}
change.file.copied.from.text=- 已從 {0} 複製
change.file.moved.from.text=- 已從 {0} 移動
change.file.moved.to.text=- 已移至 {0}
change.file.renamed.from.text=- 已從 {0} 重新命名
change.file.renamed.to.text=- 已重命名為 {0}
change.file.replaced.text=- 已取代
change.list.manager.wait.lists.synchronization.background={1, choice, 0\\#正在等待 |1\\#{0}\\: }本地更改重新整理
change.list.manager.wait.lists.synchronization.modal={1, choice, 0\\#正在等待 |1\\#{0}\\: }本地更改重新整理
change.list.scope.provider.local.changes=本地更改
change.list.scope.provider.only.changes=所有檔案中僅未提交到 VCS 的更改
change.list.scope.provider.only.changes.in.file=檔案 {0} 中僅未提交到 VCS 的更改
change.lists.manager.add.unversioned=新增未進行版本管理的檔案
change.nodetitle.change.is.outdated=檔案在伺服器上已被更改
change.shelves.location.dialog.action.button=更改位置
change.shelves.location.dialog.custom.label=自訂目錄(&U)\\:
change.shelves.location.dialog.default.label=預設目錄\\:
change.shelves.location.dialog.group.title=將擱置存儲於\\:
change.shelves.location.dialog.location.browser.title=選擇要將擱置存儲在其中的目錄
change.shelves.location.dialog.title=更改擱置位置
changelist.details.committed.format=由 {0} {1} 提交
changelist.details.title=更改列表詳細資訊
changes.ExcludeChangedLinesFromCommit.chunks.action.text=從提交中排除所選區塊
changes.IncludeChangedLinesIntoCommit.chunks.action.text=將所選區塊包含到提交中
changes.action.include.in.operation.name=包含在 {0} 中(&I)
changes.action.rollback.custom.title={0}更改
changes.action.rollback.text=回滾
changes.action.rollback.title={0}更改
changes.another.change.list=另一個
changes.browse=瀏覽
changes.browser.details.marker=更多…
changes.button.newer=較新的 >
changes.button.older=< 較舊的
changes.can.not.find.patch.for.path.in.patch.file=在補丁檔案中找不到 {0} 的補丁。
changes.cant.load.changes=無法載入更改
changes.change.list.conflict.dialog.radio.button.ignore=忽略(&I)
changes.change.list.conflict.dialog.radio.button.shelve.changes=擱置更改(&S)
changes.changelists.to.cache.initially=最初要快取的更改列表\\:
changes.checkbox.delete.locally.added.files=刪除新增的檔案的本地副本(&D)
changes.checking.configuration.0.for.ignore=正在為忽略物件檢查組態 {0}…
changes.combined.diff=組合更改差異
changes.committed.changes=已提交更改
changes.configure=組態(&C)…
changes.days.of.history.to.cache.initially=最初要快取的歷史記錄的天數\\:
changes.default.change.list=預設
changes.default.changelist.name=更改
changes.default.changelist.name.old=預設更改列表
changes.deleting.added.files.locally=正在本地刪除已新增檔案…
changes.dialog.editchangelist.error.already.exists=名為 ''{0}'' 的更改列表已存在
changes.dialog.editchangelist.title=編輯更改列表
changes.dialog.message.failed.to.revert.apply.changes=無法{0, choice, 0\\#還原|1\\#套用}更改\\: 
changes.dialog.newchangelist.title=新增更改列表
changes.diff.separator=差異
changes.directory.does.not.belong.to.the.active.changelist={0, choice, 1\\#這一目錄|2\\#這些目錄}不屬於活動更改列表\\:
changes.do.cleanup=進行清理…
changes.editor.diff.preview.empty.title=更改
changes.editor.diff.preview.title=更改\\: {0}
changes.empty.changelists.no.longer.active={0,choice,1\\#空更改列表 ''''{1}'''' 已|2\\#空更改列表 '<br/>'{1} 已}不再活動。<br/>是否要將{0, choice,1\\#其|2\\#其}移除?
changes.error.can.t.get.revision.content=無法獲取修訂內容
changes.error.can.t.show.diff.for=無法顯示 ''{0}'' 的差異
changes.error.can.t.show.diff.for.binary.file=無法顯示二進制檔案 ''{0}'' 的差異
changes.error.cannot.find.base.for.path=找不到 ''{0}'' 的基
changes.error.content.for.0.was.removed=''{0}'' 的內容已被移除
changes.error.default.project.not.supported=不支持預設專案
changes.error.failed.to.create.content.for.current.revision=無法為當前修訂建立內容
changes.error.failed.to.fetch.current.revision=無法獲取當前修訂
changes.error.refreshing.vcs.history=重新整理 VCS 歷史記錄時出錯
changes.error.refreshing.view=重新整理檢視時出錯\\: {0}
changes.error.shelving.changes.failed=擱置更改失敗\\: {0}
changes.exclude.lines.from.commit=將行從提交中排除
changes.file.does.not.belong.to.the.active.changelist={0, choice, 1\\#這一檔案|2\\#這些檔案}不屬於活動更改列表\\:
changes.file.from.non.active.changelist.is.modified=停用更改列表中的檔案已修改
changes.finishing.changed.on.server.update=正在完成“在伺服器上被更改”更新
changes.hide.this.notification=隱藏此通知
changes.ignore.file=忽略檔案
changes.impossible.until.indices.are.up.to.date=在索引更新前不可行
changes.include.lines.into.commit=將行包含在提交中
changes.locked.by=被 {0} 鎖定
changes.minutes=分鐘
changes.move.changes.to.active.change.list.name=將更改移至活動更改列表({0})
changes.move.to.changelist=移至 ''{0}'' 更改列表
changes.new.changelist=新增更改列表
changes.no.incoming.changelists.available=無可用傳入更改列表
changes.no.tracking.branch=無追蹤分支
changes.no.tracking.branch.suffix=\\ (無追蹤分支)
changes.nodetitle.changecount={0,choice, 0\\#無檔案|1\\#1 個檔案|2\\#{0} 個檔案}
changes.nodetitle.directory.changecount={0,choice, 0\\#無目錄|1\\#1 個目錄|2\\#{0} 個目錄}
changes.nodetitle.directory.file.changecount={0,choice, 0\\#無目錄|1\\#1 個目錄|2\\#{0} 個目錄}，{1,choice, 0\\#無檔案|1\\#1 個檔案|2\\#{1} 個檔案}
changes.nodetitle.empty.changelist.name=<空名稱>
changes.nodetitle.filter.pending=未篩選
changes.nodetitle.filtered.out=已篩選
changes.nodetitle.have.outdated.files=某些檔案在伺服器上已被更改
changes.nodetitle.ignored.files=已忽略的檔案
changes.nodetitle.locally.deleted.files=本地已刪除的檔案
changes.nodetitle.locked.folders=鎖定的工作副本目錄
changes.nodetitle.locked.folders.tooltip=某些目錄已被鎖定；不允許對它們進行 VCS 動作。應執行清理。
changes.nodetitle.logicallt.locked.folders=明確鎖定的檔案
changes.nodetitle.merge.conflicts=合併衝突
changes.nodetitle.merge.conflicts.resolve.link.label=解決
changes.nodetitle.modified.without.editing=已修改，但未簽出的檔案
changes.nodetitle.resolved.conflicts=已解決的衝突
changes.nodetitle.switched.files=已切換的檔案
changes.nodetitle.switched.roots=根開關
changes.nodetitle.untracked.updating.delayed=檔案掃描期間未進行版本控制的檔案不可用
changes.nodetitle.unversioned.files=未進行版本管理的檔案
changes.nodetitle.updating=正在更新…
changes.none=<無>
changes.notification.content.repository.location.not.found.for=找不到 {0} 的版本庫位置
changes.please.enter.a.valid.regex=請輸入有效正則表達式
changes.progress.text.vcs.name.performing.operation.name={0}\\: 正在執行 {1}…
changes.progress.title.choice.revert.apply.changes={0, choice, 0\\#還原|1\\#套用}更改
changes.project.exclude.paths=專案排除路徑
changes.refresh.changelists.after.update=更新後重新整理更改列表
changes.refresh.changes.every=更改重新整理間隔
changes.remove.active.empty.prompt=選擇要設為活動的更改列表\\:
changes.remove.active.prompt=選擇應將更改移至其中的更改列表\\:
changes.remove.active.title=刪除活動更改列表
changes.removechangelist.all.lists.warning.text=確定要移除{0}個更改列表嗎?\\n所有更改都將移至新的預設更改列表。
changes.removechangelist.multiple.warning.text=確定要刪除{0}個更改列表?\\n所有的更改將會移至活動的更改列表中。
changes.removechangelist.warning.text=確定要移除更改列表 ''{0}'' 嗎?\\n所有更改都將移至活動更改列表。
changes.removechangelist.warning.title=刪除更改列表
changes.removing.configuration.0.from.ignore=正在從忽略物件中移除組態 {0}…
changes.revert.apply.change.list.name={0, choice, 0\\#還原\\: |1\\#套用\\: }{1}
changes.set.active.changelist.to.change.list.name=將活動更改列表設定為 ''{0}''
changes.switched.to.branch.name=已切換到 {0}
changes.tab.title.vcs.errors=VCS 錯誤
changes.text.default.ignored.files=預設忽略的檔案
changes.title.loading.changes=正在載入更改
changes.tree.accessible.name=更改
changes.tried.to.save.uncommitted.changes.in.shelve.before.s.but.failed.with.an.error=嘗試在{0}之前擱置未提交的更改，但因為錯誤而失敗。<br/>{1}
changes.view.conflicts.banner.default.resolve.action=解決…
changes.view.conflicts.banner.title=由於合併衝突，無法繼續
changes.warning.not.all.local.changes.may.be.shown.due.to.an.error=警告\\: 由於錯誤，可能不會顯示所有本地更改\\: {0}
checkbox.amend=修正(_M)
checkbox.checkin.options.optimize.imports=最佳化 import(&O)
checkbox.checkin.options.rearrange.code=重新整理程式碼(&N)
checkbox.checkin.options.reformat.code=重新設定程式碼格式(&R)
checkbox.clear.initial.commit.message=清除初始提交訊息(&I)
checkbox.include=包含(&I)
checkbox.include.issues.not.assigned.to.me=包括未指派給我的問題
checkbox.including.files.created.outside.ide=應用於在 {0} 外部建立的檔案
checkbox.remember.my.choice=記住我的選擇(&R)
checkbox.select.current.file.only=僅選擇當前檔案(&C)
checkbox.show.changed.revisions.only=僅更改
checkbox.show.changes.after.date=之後(&A)
checkbox.show.changes.after.num=從(&F)
checkbox.show.changes.before.date=之前(&B)
checkbox.show.changes.before.num=到(&T)\\:
checkbox.show.clear.read.only.status.dialog=如果嘗試編輯唯讀檔案，則要求將其解鎖
checkbox.show.dirty.recursively=在專案樹中醒目提示包含已修改檔案的目錄
checkin.can.not.load.current.revision=無法載入當前修訂
checkin.can.not.load.previous.revision=無法載入之前的修訂
checkin.commit.checks.failed=提交檢查失敗
checkin.commit.checks.failed.cancel.button=取消(&N)
checkin.dialog.title.todo=TODO
checkin.filter.filter.name=篩選器\\: {0}
checkin.invalid.file.s=無效檔案
checkin.title.for.commit.0=以供提交 ({0})
checkin.unresolved.merge.are.you.sure.you.want.to.commit.changes.with.unresolved.conflicts=確定要提交有未解決衝突的更改嗎?
checkin.unresolved.merge.unresolved.conflicts=未解決的衝突
checkin.wait=等待(&W)
checking.code.smells.progress.title=正在執行程式碼分析
checking.recent.changes=正在檢查最近的更改…
checking.vcs.status.progress=正在檢查 VCS 狀態…
clone.dialog.clone.button=克隆
clone.dialog.clone.failed.error=克隆失敗
clone.dialog.repository.url.item=版本庫 URL
clone.dialog.unable.create.destination.error=無法建立目標目錄
code.smells.error.messages.tab.name=程式碼分析
code.smells.review.button=檢查程式碼分析(&R)
column.info.configure.vcses.directory=目錄
column.name.configure.vcses.vcs=VCS
column.name.revision.date=日期
column.name.revision.list.author=作者
column.name.revision.list.committer=使用者
column.name.revision.list.date=日期
column.name.revision.list.description=描述
column.name.revision.list.number=數字
column.name.revision.list.revision=修訂
column.name.revision.version=版本
column.name.revisions.list.branch=分支
column.name.revisions.list.filter=日期
command.name.open.error.message.view=開啟訊息檢視
commit.amend.commit=修正提交
commit.changes=提交更改
commit.checks.error.indexing=現在無法進行程式碼分析
commit.checks.error.indexing.message=當 {0} 在背景更新索引時，無法執行提交檢查。\\n您可以在不執行檢查的情況下提交更改，也可以等到索引建立後再提交。
commit.checks.failed.notification.commit.anyway.action=仍然{0}
commit.checks.failed.notification.show.details.action=顯示詳細資訊
commit.checks.failed.notification.title={0} 檢查失敗
commit.checks.group={0} 檢查
commit.checks.group.post=進階 {0} 檢查
commit.checks.on.commit.progress.text=正在提交…
commit.checks.on.commit.progress.text.with.context=正在提交\\: {0}
commit.checks.only.progress.text=正在執行提交檢查…
commit.checks.only.progress.text.with.context=正在執行提交檢查\\: {0}
commit.description.tooltip.author=作者\\: {0}
commit.description.tooltip.commit=提交 {0}
commit.description.tooltip.date=日期\\: {0}
commit.description.tooltip.path=路徑\\: {0}
commit.dialog.changelist.label=更改列表(&T)\\:
commit.dialog.configurable=提交
commit.dialog.default.commit.operation.name=Comm&it
commit.dialog.include.action.name=包含到提交裡(&I)
commit.dialog.no.changes.detected.text=未檢測到更改
commit.dialog.no.changes.detected.title=沒有要提交的內容
commit.dialog.partial.commit.warning.body=不支持 ''{0}'' 的部分提交。\\n所選檔案中的所有更改都將提交。
commit.dialog.partial.commit.warning.title=不支持部分提交
commit.dialog.refresh.files=正在同步檔案…
commit.dialog.title=提交更改
commit.editor.diff.preview.empty.title=提交
commit.editor.diff.preview.title=提交\\: {0}
commit.from.gutter.placeholder=提交此更改
commit.legend.deleted=已刪除
commit.legend.modified=已修改
commit.legend.new=已新增
commit.message=提交訊息
commit.message.editor.accessible.name=提交訊息
commit.message.inspection.message.body.lines.should.not.exceed.characters=正文行不能超過 {0} 個字元
commit.message.inspection.message.subject.should.not.exceed.characters=主題不能超過 {0} 個字元
commit.message.intention.family.name.reformat.commit.message=重新設定提交訊息的格式
commit.message.intention.family.name.wrap.line=換行
commit.message.missing.blank.line.between.subject.and.body=主題與正文之間缺少空行
commit.message.placeholder=提交訊息
commit.progress.title=提交
commit.tooltip.merge.this.commit.with.the.previous.one=將此提交與前一個提交合併
commit.wait.util.synched.text=正在執行 VCS 重新整理…
committed.changes.empty.comment=<無註釋>
committed.changes.empty.message=版本庫沒有提交的更改
committed.changes.filter.all=所有
committed.changes.filter.none=<無>
committed.changes.filter.title=篩選依據
committed.changes.group.title=分組依據
committed.changes.incorrect.regex.message=篩選器中使用的正則表達式無效
committed.changes.not.loaded.message=按“重新整理”按鈕以載入版本庫更改
committed.changes.partial.list=[部分]
committed.changes.refresh.progress=正在重新整理 VCS 歷史記錄
committed.changes.regex.title=正則表達式(&G)
committed.changes.tab=版本庫
composite.change.provider.include.vcs.checkbox=包含{0}中的更改
configurable.ChangelistConflictConfigurable.display.name=更改列表
configurable.IssueNavigationConfigurationPanel.display.name=問題導覽
configurable.VcsContentAnnotationConfigurable.display.name=顯示最近更改
configurable.VcsDirectoryConfigurationPanel.display.name=目錄映射
configurable.VcsGeneralConfigurationConfigurable.display.name=確認
configurable.issue.link.edit=編輯
configurable.issue.link.remove=移除
configurable.shelf.storage.cant.find.or.create.new.shelf.directory=找不到或建立新的擱置目錄
configurable.shelf.storage.destination.shelf.directory.should.have.read.access=目標擱置目錄必須具備讀取權限
configurable.shelf.storage.destination.shelf.directory.should.have.write.access=目標擱置目錄必須具備寫入權限
configurable.vcs.manage.scopes=管理作用域
configuration.project.not.trusted.label=安全模式，版本控制不可用。信任該專案以存取完整的 IDE 功能。
confirmation.message.add.ignored.files.or.dirs=選擇要新增到 Git 的檔案
confirmation.message.add.ignored.single.directory=確定要將所選目錄新增到 Git 嗎?
confirmation.message.add.ignored.single.file=確定要將所選檔案新增到 Git 嗎?
confirmation.title.add.file.to=將檔案新增到 {0}?
confirmation.title.add.files.to=將檔案新增到 {0}?
confirmation.title.add.ignored.files.or.dirs=檔案位於 .gitignore 中
confirmation.title.add.ignored.single.directory=目錄位於 .gitignore 中
confirmation.title.add.ignored.single.file=檔案位於 .gitignore 中
copy.revision.number.action=複製修訂號
create.patch.commit.action.progress=正在建立補丁…
create.patch.commit.action.title=建立補丁
create.patch.encoding=編碼(&E)\\:
create.patch.error.title=建立補丁時出錯\\: {0}
create.patch.file.path=到檔案(&P)\\:
create.patch.loading.content.progress=正在載入內容修訂
create.patch.reverse.checkbox=反轉補丁(&R)
create.patch.settings.dialog.title=補丁檔案設定
create.patch.success.confirmation=已成功建立補丁 {0}
create.patch.to.clipboard=到剪貼簿(&C)
current.version.text={4}<br/><br/>當前版本為 {3}。<br/>修改者為 {0}<br/>{1}<br/>{2}
date.group.last.week=過去一周
date.group.title=日期
date.group.today=今天
description.text.option.applicable.to.vcses=適用於 {0}
dialog.enable.version.control.integration.hint.text=可在以下位置組態版本控制設定 
dialog.enable.version.control.integration.select.vcs.label.text=選擇要與{0}關聯的版本控制系統\\:
dialog.enable.version.control.integration.title=啟用版本控制整合
dialog.message.can.t.create.text.editor.for=無法為 {0} 建立文本編輯器
dialog.message.conflict.seems.to.be.resolved=衝突似乎已解決
dialog.message.enter.directory.name=為建立的專案輸入目錄名稱。留空可直接簽出到“{0}”。
dialog.message.no.changes.for.this.file=此檔案沒有更改
dialog.title.cannot.convert.module=無法轉換模組
dialog.title.changes.browser=更改瀏覽器
dialog.title.files.created=檔案已建立
dialog.title.ignored.files=已忽略的檔案
dialog.title.message=訊息
dialog.title.modified.without.checkout.files=已修改，但未簽出檔案
dialog.title.move.changes.to.active.changelist=將更改移至活動更改列表
dialog.title.no.conflict.found=未找到衝突
dialog.title.project.directory.name=專案目錄名稱
dialog.title.remove.empty.changelist=移除空更改列表
dialog.title.resolve.changelist.conflict=解決更改列表衝突
dialog.title.select.destination.folder=選擇目標目錄
dialog.title.unversioned.files=未進行版本管理的檔案
diff.content.title.revision.number=修訂 {0}
diff.producer.error.cant.get.revision.content=無法獲取修訂內容
diff.title.local=本地
diff.title.local.with.number=本地({0})
diff.title.revision.tooltip=[{0}] {1}<br/><br/>由 {2} 在 {3}
directory.mapping.add.title=新增 VCS 目錄映射
directory.mapping.checkbox.detect.vcs.mappings.automatically=啟用自動映射檢測
directory.mapping.checkbox.detect.vcs.mappings.automatically.hint=在專案結構更改時新增和移除映射。檢測新建立的 VCS 根。
directory.mapping.remove.title=編輯 VCS 目錄映射
edit.changelist.description=註釋(&C)\\:
edit.changelist.name=名稱(&N)\\:
edit.errors=編輯錯誤
edit.source.action.text=編輯源
error.adding.files.notification.title=無法新增檔案
error.adding.files.prompt=新增檔案時發生以下問題\\:
error.adding.files.title=無法新增檔案
error.annotated.line.out.of.bounds=帶註解的行超出界限\\: {0}，總行數\\: {1}
error.cant.get.local.file.for.non.local=無法獲取檔案 ''{0}'' 的本地位置
error.cant.load.affected.files=無法載入修訂 ''{1}'' 中路徑 ''{0}'' 的受影響檔案
error.cant.perform.operation.now=現在無法{0}
error.change.from.must.be.a.valid.number=起始日期必須是有效數字
error.change.to.must.be.a.valid.number=更改物件必須是有效數字
error.date.after.must.be.a.valid.date=之後的日期必須是有效日期
error.date.before.must.be.a.valid.date=之前的日期必須是有效日期
error.executing.commit=執行 ''{0}'' 時出錯\\: {1}
error.no.changes.no.commit.message=選擇要提交的檔案並指定提交訊息
error.no.changes.to.commit=選擇要提交的檔案
error.no.commit.message=指定提交訊息
error.text.check.in.with.empty.comment=在提交訊息欄位中新增更改摘要
error.title.check.in.with.empty.comment=無提交訊息
error.updating.changes=更新更改時出錯\\: {0}
ex.changelists=更改列表
ex.move.lines.to.another.changelist.0=將行移至另一個更改列表({0})
ex.new.changelist=新增更改列表…
exception.text.internal.error.method.should.not.be.called=不應呼叫
exception.text.internal.errror.could.not.implement.method=無法實作
exception.text.unknown.error=未知錯誤
executable.project.override=僅為當前專案設定此路徑
executable.project.override.reset.globalize=設為全域
executable.project.override.reset.message=為此專案組態的可執行檔案路徑既可以設為所有專案的全域路徑，也可以還原為當前全域可執行檔案
executable.project.override.reset.revert=還原
executable.project.override.reset.title=專案可執行檔案
executable.select.label={0} 可執行檔案路徑(&P)\\:
executable.select.title=選擇可執行檔案
executable.test=測試
external.files.add.notification.action.add=始終新增
external.files.add.notification.action.mute=不再詢問
external.files.add.notification.action.view=檢視檔案
external.files.add.notification.message=外部新增的檔案可以新增到 {0}
external.files.add.view.dialog.title=將檔案新增到 {0}
file.content.too.big.to.load.increase.property.suggestion=無法顯示 ''{0}'' 的內容。\\n該檔案大小大於 {1}。\\n\\n您可以通過在 ''idea.properties'' 檔案中增大{2}屬性來覆寫此限制。
file.history.checking.last.revision.process=正在檢查最新修訂
file.history.details.committer.info=由 {0} 提交
file.history.details.committer.tooltip.info=通過 {0}
file.history.details.empty.status=提交訊息
file.history.details.hash.author.on.date.at.time={0} {1}，{2} {3}
file.history.diff.handler.affected.changes.title={1} 中的初始提交 {0}
file.history.diff.handler.collecting.affected.process=正在收集受影響的更改…
file.history.diff.handler.comparing.process=正在比較修訂…
file.history.diff.handler.paths.diff.title={0} 與 {2} 中的 {1} 之間的差異
file.history.diff.handler.paths.diff.with.local.title={0} 與 {1} 中的本地版本之間的差異
file.history.diff.handler.process.error=任務期間出錯\\: {0}
file.history.diff.revisions.process=正在比較修訂…
file.history.exceeded.limit.message=檔案歷史記錄\\: 僅為 {1} 載入了 {0} 個修訂\\n要更改歷史記錄限制，請轉到 {2}
file.history.tab.name=歷史記錄
filetype.patch.description=補丁
filetype.patch.display.name=補丁
filter.none.name=無
filter.structure.name=結構
get.from.vcs.extension.list.accessible.name=版本庫位置
get.from.version.control=克隆版本庫
group.ChangesView.ViewOptions.text=檢視選項
group.mainmenu.vcs.current.file.text=當前檔案
group.name.version.control=VCS(&V)
gutter.name.version.control.ignored.directories=版本控制忽略目錄
handle.ro.file.status.type.using.vcs=使用 {0}
hide.this.notification=隱藏此通知
history.dialog.title.difference.between.versions.in={2} 中的 {0} 和 {1} 版本的差異
history.empty=歷史記錄為空
history.failed.to.load.content.for.revision.0=無法為修訂 {0} 載入內容
history.file.not.found=找不到檔案 {0}
history.loading.revisions=正在載入受影響的修訂…
history.tab.title.can.not.load.changelist.contents=無法載入更改列表內容
ignore.codeInspection.duplicateEntry=忽略檔案重複項
ignore.codeInspection.duplicateEntry.message=<code>\\#ref</code> 模式不止定義一次 \\#loc
ignore.codeInspection.group=版本控制
ignore.quick.fix.remove.entry=移除模式
ignore.to.exclude.no.directories.found=未找到要排除的目錄
ignore.to.exclude.notification.action.details=了解更多
ignore.to.exclude.notification.action.mute=不再顯示
ignore.to.exclude.notification.action.view=檢視目錄
ignore.to.exclude.notification.message=部分忽略的目錄未從索引和搜尋中排除
ignore.to.exclude.notification.notice=<html><b>註</b>\\: 建議在排除之前重新檢查目錄內容。一些目錄可能包含不應排除的項。</html>
ignore.to.exclude.view.dialog.exclude.action=排除(&E)
ignore.to.exclude.view.dialog.title=排除目錄
ignoreTokenType./=<斜杠>
ignoreTokenType.BRACKET_LEFT=<左括號>
ignoreTokenType.BRACKET_RIGHT=<右括號>
ignoreTokenType.COMMENT=<註釋>
ignoreTokenType.CRLF=<空行>
ignoreTokenType.HEADER=<標頭>
ignoreTokenType.SECTION=<部分>
ignoreTokenType.VALUE=<值>
ignoreTokenType.syntax=\\=<語法>
ignored.file.excluded.settings.title=排除目錄管理策略
ignored.file.excluded.to.ignored.label=將排除目錄新增到忽略檔案
ignored.file.general.settings.title=一般設定
ignored.file.ignored.to.excluded.label=自動從索引中排除被忽略的目錄
ignored.file.manage.all.project=在所有專案中
ignored.file.manage.all.projects.option=為所有專案管理
ignored.file.manage.always.ask.option=始終詢問
ignored.file.manage.message={0} 可以自動將經常被忽略的檔案新增到 {1}。
ignored.file.manage.notmanage=不新增
ignored.file.manage.policy.label=忽略檔案管理策略\\:
ignored.file.manage.this.project=在此專案中
ignored.file.manage.this.project.option=僅為此專案管理
ignored.file.manage.view=檢視
ignored.file.manage.view.dialog.ignore.action=忽略(&I)
ignored.file.manage.view.dialog.title=將檔案新增到忽略
ignored.file.manage.with.files.message={0} 可以自動將經常被忽略的檔案新增到 {1}。
ignored.file.not.manage.option=關閉套用範圍
ignored.file.not.manage.this.project.option=不只為此專案管理
ignored.file.tab.title=已忽略的檔案
ignoring.files.progress.title=正在忽略檔案…
impl.notification.content.could.not.find.plugin=找不到延伸模組 {0}
impl.notification.content.plugin.was.unbundled.needs.to.be.installed.manually={0} 延伸模組已解除捆綁，需要手動安裝
impl.notification.content.vcs.plugin.not.found.for.mapping.to=沒有為 ''{0}'' 的映射找到 VCS 延伸模組
impl.notification.title.failed.to.install.plugin=安裝延伸模組失敗
impl.progress.title.installing.plugin=正在安裝延伸模組…
impl.show.all.affected.files.for.path.at.revision.failed=為 {0} 顯示 {1} 失敗時所有受影響的檔案
import.patches=匯入補丁
import.patches.into.shelf=將補丁匯入到擱置…
incoming.changes.empty.message=沒有傳入的更改
incoming.changes.indicator.name=傳入更改
incoming.changes.indicator.tooltip={0} 個可用的傳入更改列表
incoming.changes.not.loaded.message=按“重新整理”按鈕以載入傳入的更改
incoming.changes.tab=傳入
inlay.vcs.code.author.description=根據 VCS 中的記錄獲得的程式碼作者。<br><br>作者是最後編輯類別、方法或函式的人。如果有來自不同作者的多個提交，擁有最多行的那個會被視為作者。
inspection.BodyLimitInspection.display.name=限制正文行
inspection.CommitMessageSpellCheckingInspection.display.name=拼寫
inspection.SubjectBodySeparationInspection.display.name=主題與正文之間的空白行
inspection.SubjectLimitInspection.display.name=限制主題行
issue.action.add.jira.issue.navigation.pattern.title=新增 JIRA 問題導覽模式
issue.action.add.youtrack.issue.navigation.pattern.title=新增 YouTrack 問題導覽模式
issue.action.enter.jira.installation.url.label=輸入 JIRA 安裝 URL\\:
issue.action.enter.youtrack.installation.url.label=輸入 YouTrack 安裝 URL\\:
issue.link.add.title=新增問題導覽鏈接
issue.link.delete.prompt=刪除所選導覽鏈接?
issue.link.delete.title=刪除問題導覽鏈接
issue.link.edit.title=編輯問題導覽鏈接
issue.link.issue.column=問題
issue.link.link.column=鏈接
issue.link.no.patterns=未組態模式
jb.protocol.no.provider=找不到 VCS 提供程序\\: ''{0}''
label.at.date.leading=在 {0}
label.at.date.middle=在 {0}
label.by.author=作者
label.code.author.inlay.hints=程式碼作者
label.commit.checks.failed.unknown.reason=檢查失敗
label.commit.checks.not.available.during.indexing=索引編制期間無法提交檢查
label.commit.comment=提交訊息(&M)
label.multi.author.modified.code={0} +{1} *
label.multi.author.not.modified.code={0} +{1}
label.new.code=新 *
label.project.vcs.root.mapping=<專案>
label.relative.project.path.presentation=<專案>/{0}
label.select.files.to.be.added.to.version.control=選擇要新增到版本控制中的檔案
label.selected.revision.commit.message=提交訊息
label.single.author.modified.code={0} *
label.todo.items.found={0} 個 TODO
line.annotation.aspect.author=作者
line.annotation.aspect.date=日期
line.annotation.aspect.revision=修訂
link.label.display.anyway=仍然顯示
link.label.hide=隱藏
link.label.ignore=忽略
link.label.move.changes=移動更改
link.label.switch.changelist=切換更改列表
loading.file.history.progress=正在載入檔案歷史記錄
loading.file.history.status=正在載入 {0} 的歷史記錄…
loading.file.history.up.to.revision.status=正在載入 {0} 截至 {1} 的歷史記錄…
loading.text2.file.history.progress=正在載入檔案歷史記錄
local.changes.freeze.message={0}完成之前，本地更改不可用
local.changes.tab=本地更改
local.history.update.from.vcs=從 VCS 更新
local.version.title=本地版本
looking.for.patch.files=正在尋找補丁檔案…
lookup.title.vcs.file.revisions=檔案修訂
lst.inactive.ranges.damaged.notification=部分更改已移至活動更改列表
merge.loading.merge.details=正在載入合併詳細資訊…
message.read.only.status.content=您以 <b>root</b> 身份登入，因此\\: <br><br>- {0} 無法看到唯讀狀態的檔案。<br>- 所有檔案都被視為可寫入。<br>- 修改時無法自動簽出檔案。
message.read.only.status.title={0}\\: 無法看到唯讀狀態
message.text.all.files.are.up.to.date=所有檔案都處於最新狀態
message.text.background.tasks=正在等待背景 VCS 任務完成…
message.text.cannot.edit.file=無法編輯檔案\\: {0}
message.text.cannot.load.revision=無法載入修訂\\: {0}
message.text.cannot.open.editor=無法開啟檔案 {0} 的文本編輯器
message.text.cannot.save.content=無法儲存內容\\: {0}
message.text.cannot.save.settings=無法執行動作\\: {0}
message.text.cannot.show.differences=無法顯示差異\\: {0}
message.text.commit.failed.with.error=提交失敗，有{0,choice,1\\#錯誤|2\\#錯誤}
message.text.commit.finished.with.warning=提交完成，有{0,choice,1\\#警告|2\\#警告}
message.text.commit.progress=正在提交…
message.text.could.not.load.virtual.file.content=無法載入檔案 {0} 的內容\\: {1}
message.text.file.is.up.to.date=檔案處於最新狀態
message.text.file.locally.modified=檔案 {0} 已在本地被修改。
message.text.several.files.locally.modified=某些檔案已在本地被修改。
message.title.annotate=註解
message.title.cannot.open.editor=無法開啟編輯器
message.title.could.not.load.content=無法載入內容
message.title.could.not.load.file.history=載入檔案歷史記錄時發生問題
message.title.edit.files=編輯檔案
message.title.get.revision.content=獲取修訂內容
message.title.get.version=獲取版本
message.title.show.differences=顯示差異
message.title.vcs.update.errors={0}錯誤
move.to.another.changelist.nothing.selected.notification=沒有選擇任何可以移動的專案
move.to.changelist=將更改移至活動更改列表(''{0}'')(&M)
multiple.file.merge.accept.theirs=接受他們的(&T)
multiple.file.merge.accept.yours=接受您的更改(&Y)
multiple.file.merge.column.name=名稱
multiple.file.merge.dialog.command.name.accept.theirs=接受他們的更改
multiple.file.merge.dialog.command.name.accept.yours=接受您的更改
multiple.file.merge.dialog.error.loading.revisions.to.merge=載入待合併修訂時出錯\\: {0}
multiple.file.merge.dialog.message.error.saving.merged.data=儲存合併資料時出錯\\: {0}
multiple.file.merge.dialog.message.file.too.big.to.be.loaded=檔案過大，無法載入
multiple.file.merge.dialog.progress.title.loading.revisions=正在載入修訂…
multiple.file.merge.dialog.progress.title.resolving.conflicts=正在解決衝突…
multiple.file.merge.dialog.title.can.t.show.merge.dialog=無法顯示“合併”對話框
multiple.file.merge.group.by.directory.checkbox=按目錄對檔案分組
multiple.file.merge.loading.progress.title=正在載入合併修訂…
multiple.file.merge.merge=合併(&M)…
multiple.file.merge.request.title=合併 {0} 的修訂
multiple.file.merge.title=衝突
new.changelist.duplicate.name.error=具有該名稱的更改列表已存在
new.changelist.empty.name.error=無法使用空名稱建立新的更改列表
new.changelist.make.active.checkbox=設為活動(&A)
new.changelist.new.label=新增
no.ignored.files=沒有忽略的檔案
none.vcs.presentation=<無>
notification.content.didn.t.update.repository.changes=由於發生錯誤，未使用新消息更新版本庫更改\\: {0}
notification.group.external.executable=VCS 外部可執行檔案驗證失敗
notification.group.vcs.common.messages=VCS 普通訊息
notification.group.vcs.important.messages=VCS 重要訊息
notification.group.vcs.messages=VCS 訊息
notification.group.vcs.notifications=VCS 通知
notification.group.vcs.silent.notifications=VCS 靜默通知
notification.showDetailsInConsole=在主控台中顯示詳細資訊
notification.title.cant.load.annotations=無法載入註解
notification.title.couldn.t.save.uncommitted.changes=無法儲存未提交的更改。
notification.title.vcs.name.repository.repositories.found=已找到 {0} {1, choice, 1\\#版本庫|2\\#版本庫}
open.repository.version.description=在編輯器中開啟檔案的所選修訂
open.repository.version.text=開啟版本庫版本
operation.name.annotate=註釋
outdated.version.show.diff.action=顯示差異
outdated.version.text=過時的版本。{0} 在 {1} {3,choice,0\\#修改|1\\#刪除}了以下訊息\\: {2}
outdated.version.update.project.action=更新專案
patch.apply.abort.action=中止…
patch.apply.abort.and.rollback.action=中止並回滾(_A)
patch.apply.abort.and.rollback.prompt=中止並回滾套用補丁還是跳過此檔案?
patch.apply.abort.title=中止補丁
patch.apply.aborted.message=“套用補丁”動作期間更改的所有檔案已被回滾
patch.apply.aborted.title=套用補丁中止
patch.apply.added.status=已新增
patch.apply.after.patch.label.text=補丁後
patch.apply.already.applied=指定補丁的所有更改均已包含在程式碼中
patch.apply.already.applied.status=已套用
patch.apply.already.exists.overwrite.prompt=檔案 {0} ({1})已存在。\\n是否要覆蓋它?
patch.apply.analyze.from.clipboard.on.the.fly.checkbox=動態分析和套用剪貼簿中的補丁
patch.apply.automatically.applied.status=已自動套用
patch.apply.bad.diff.title=補丁套用的結果
patch.apply.bad.diff.to.title=將補丁應用於 {0} 的結果
patch.apply.before.patch.label.text=補丁前
patch.apply.can.not.apply.additional.info.error=無法套用附加補丁資訊\\: {0}
patch.apply.can.t.find.patch.file.warning=找不到補丁檔案 {0}
patch.apply.cannot.apply.now=現在無法套用補丁
patch.apply.cannot.read.patch=無法讀取補丁 {0}\\: {1}
patch.apply.change.directory.paths.group=更改目錄路徑
patch.apply.changes.in.patch.resolve=在補丁解析中{0}
patch.apply.command=套用補丁
patch.apply.conflict.for.title={0}的補丁衝突
patch.apply.conflict.local.version=本地版本
patch.apply.conflict.merged.version=合併結果
patch.apply.conflict.patch=補丁
patch.apply.conflict.patched.somehow.version=結果
patch.apply.conflict.patched.version=補丁版本
patch.apply.conflict.title=補丁衝突
patch.apply.continue.resolve.action=繼續解析
patch.apply.deleted.status=已刪除
patch.apply.dialog.title=套用補丁
patch.apply.display.local.content.was.modified.error=無法顯示補丁套用者 - 本地內容已修改
patch.apply.error.conflict=套用補丁衝突
patch.apply.error.document.not.found=找不到文檔 {0}
patch.apply.error.file.not.found=找不到檔案 {0}
patch.apply.file.name.field=補丁檔名(&P)\\:
patch.apply.file.type.binary.error=無法從補丁套用 {0} 檔案，因為它是二進制檔案。
patch.apply.file.type.directory.error=無法從補丁套用 {0} 檔案的內容，因為它是目錄。
patch.apply.file.type.undefined.error=無法從補丁套用 {0} 檔案的內容，因為它的類型未定義。
patch.apply.hunk.warning=無法檢測到以下物件的區塊修改行\\: -{0},{1} +{2},{3}
patch.apply.incorrectly.processed.warning=VCS 可能未正確處理以下{0, choice, 1\\#檔案|2\\#檔案}。\\n請手動檢查{0, choice, 1\\#它|2\\#它們}\\: {1}
patch.apply.map.base.directory.action=映射基目錄…
patch.apply.marker.renderer=標記\\: {0}
patch.apply.missing.base.file.label=缺少基
patch.apply.modified.status=已修改
patch.apply.new.base.detected.node.description=檢測到新基
patch.apply.new.files.warning=套用補丁建立新檔案報錯
patch.apply.not.applied.status=未套用
patch.apply.not.patch=內容不是補丁
patch.apply.not.patch.clipboard=剪貼簿內容不是補丁
patch.apply.not.patch.type.file.error=所選檔案 {0} 不是補丁類型檔案
patch.apply.notification.title=套用補丁
patch.apply.old.new.base.info=更改前\\: {0} (基目錄\\: {1})<br/>更改後\\: {2} (基目錄\\: {3})
patch.apply.outside.content.root.message=在內容根外部找到補丁檔案\\: {0}
patch.apply.overwrite.existing.file.prompt=以下檔案應通過補丁建立，但它已經存在。\\n是否要覆蓋它?\\n{0}
patch.apply.overwrite.existing.files.prompt=以下檔案應通過補丁建立，但它們已經存在。\\n是否要覆蓋它們?
patch.apply.overwrite.existing.title=覆蓋現有檔案
patch.apply.partially.applied=指定補丁的某些更改已被跳過，因為它們已包含在程式碼中
patch.apply.partly.failed.title=補丁部分套用失敗
patch.apply.progress.title=正在套用補丁…
patch.apply.rollback.action=回滾
patch.apply.rollback.failed.message=嘗試使用“本地歷史記錄”對話框手動執行還原。
patch.apply.rollback.failed.title=回滾失敗
patch.apply.rollback.progress=回滾套用的更改…
patch.apply.rollback.progress.title=回滾套用的更改…
patch.apply.rollback.prompt=無法{0, choice, 0\\#套用補丁。|1\\#將補丁套用到檔案\\:|2\\#將補丁套用到檔案\\:}
patch.apply.rollback.prompt.bottom=補丁中的其他更改已成功套用，是否要回滾它們?
patch.apply.rollback.will.not.affect.binaries.info=回滾不會影響二進制檔案
patch.apply.select.base.for.a.path.message=為路徑選擇基
patch.apply.select.base.title=選擇{0, choice, 0\\#目錄|1\\#檔案}基
patch.apply.select.missing.base.link=選擇缺少的基
patch.apply.select.title=選擇補丁檔案
patch.apply.skip.action=跳過(_S)
patch.apply.somehow.diff.name=以某種方式套用補丁
patch.apply.stripped.description=\\ 去除的{0}
patch.apply.success.applied.text=已成功套用補丁
patch.apply.syntax.line=\\ (行\\: {0})
patch.apply.wrong.base.and.can.t.be.applied.warning={0} 的補丁的基錯誤，無法正確套用
patch.binary.decoder.char.error=無法解碼二進制檔案補丁\\: 字元大小符號錯誤
patch.binary.decoder.content.error=解碼的二進制內容{0,choice,0\\#少於|1\\#多於}預期
patch.binary.decoder.decompress.error=無法解碼二進制檔案補丁\\: 無法解壓資料
patch.binary.decoder.line.error=無法編碼二進制檔案補丁\\: 行大小錯誤
patch.can.t.detect.file.names.from.git.format.header.line=無法從 git 格式頭行檢測檔名
patch.contains.additional.information.without.patch.itself=包含附加資訊但不含補丁本身
patch.content.viewer.name=補丁檢視器
patch.content.viewer.side.by.side.name=並排補丁檢視器
patch.copied.to.clipboard=補丁已複製到剪貼簿
patch.creation.base.dir.does.not.exist.error=基目錄不存在
patch.creation.base.path.field=基路徑(&B)\\:
patch.creation.can.not.write.patch.error=無法將補丁寫入指定檔案\\: {0}
patch.creation.empty.base.path.error=基路徑不能為空\\!
patch.creation.failed=補丁建立失敗
patch.creation.name.too.long.error=檔案路徑不應過長。
patch.creation.save.patch.file.title=儲存補丁檔案
patch.creation.save.to.file.button=將補丁儲存到檔案
patch.creation.save.to.title=將補丁儲存到
patch.creation.wrong.base.path.for.changes.error=基路徑不包含所有所選更改(使用 {0})
patch.empty.0.data.section=空 ''{0}'' 資料分區
patch.empty.additional.info.header=空的附加資訊頭
patch.failed.to.fetch.old.content.for.file.name.in.revision=無法在修訂 {1} 中獲取檔案 {0} 的舊內容
patch.import.additional.info.error=無法匯入附加補丁資訊\\: {0}
patch.import.no.patches.found.warning=未找到補丁
patch.import.to.shelf.progress.title=將補丁匯入到 Shelf
patch.import.to.shelf.tab=將補丁匯入到 Shelf
patch.is.binary.text=二進制補丁檔案
patch.missing.after.hunk=缺少 after 區塊
patch.parse.error=無效的補丁檔案\\: {0}
patch.parse.error.empty.file=補丁檔案為空
patch.parse.no.document.error=無法解析補丁檔案
patch.second.file.name.expected=應為第二個檔名
patch.simple.apply.base.line.error=意外基線\\: 應為 - {0}，實際為 - {1}
patch.simple.apply.base.line.total.error=意外基線\\: 總行數 - {0}，實際行數 - {1}
patch.simple.apply.hunk.base.body.error=意外的區塊基主體\\: 應為 - {0}，實際為 - {1}
patch.simple.apply.hunk.base.end.error=意外的區塊基結束\\: 總行數為 - {0}，區塊結束為 - {1}
patch.simple.apply.hunk.base.start.error=意外的區塊基開始\\: 應為 - {0}，實際為 - {1}
patch.simple.apply.hunk.content.error=意外的區塊內容\\: 應為 - {0}，實際為 - {1}
patch.simple.apply.hunk.patched.body.error=意外的區塊補丁主體\\: 應為 - {0}，實際為 - {1}
patch.simple.apply.hunk.patched.start.error=意外的區塊補丁開始\\: 應為 - {0}，實際為 - {1}
patch.unexpected.end.of.binary.patch=二進制補丁意外結束
patch.unknown.after.hunk.start.syntax=未知的 after 區塊開始語法
patch.unknown.before.hunk.start.syntax=未知的 before 區塊開始語法
patch.unknown.hunk.start.syntax=未知的區塊開始語法
patch.unknown.line.prefix=未知行前綴
patched.version.name=補丁版本
path.apply.select.base.directory.for.a.path.popup=為路徑選擇基目錄
paths.affected.in.revision={0} 中的更改
post.commit.checks.failed.notification.ignore.action=忽略
post.commit.checks.failed.notification.title=提交包含問題
post.commit.checks.failed.push.dialog.notification.text=提交包含問題\\: {0}
post.commit.checks.not.finished.push.dialog.notification.text=提交檢查仍在進行中
post.commit.checks.progress.step.collecting.commits.text=正在收集受影響的提交…
post.commit.checks.progress.text=正在檢查提交中的檔案
progress.text.analyzing.code=正在分析程式碼…
progress.text.applying.fixes=正在套用修正…
progress.text.checking.for.todo=正在檢查 TODO…
progress.text.inspecting.code=正在檢查程式碼…
progress.text.loading.patch.base.revision=正在載入補丁基礎修訂
progress.text.optimizing.imports=正在最佳化 import…
progress.text.performing={0}\\: 正在執行 {1}…
progress.text.performing.rollback={0}\\: 正在執行回滾…
progress.text.rearranging.code=正在重新排列程式碼…
progress.text.reformatting.code=正在重新設定程式碼格式…
progress.text.searching.for.modified.files=正在搜尋修改的檔案
progress.text.synchronizing.files=正在同步檔案…
progress.text.updating.canceled=更新已取消
progress.text.updating.done=更新完成
progress.title.adding.files.to.vcs=正在將檔案新增到 VCS…
progress.title.commit.checks=提交檢查
progress.title.discovering.location=正在發現 {0} 的位置
progress.title.hey=嗨
progress.title.loading.current.revision=正在載入當前修訂…
progress.title.version.control.processing.changed.files=版本控制\\: 正在處理更改的檔案
project.configuration.files.add.notification.action.add=始終新增
project.configuration.files.add.notification.action.mute=不再詢問
project.configuration.files.add.notification.action.view=檢視檔案
project.configuration.files.add.notification.message=可以將 IDE 專案設定新增到 {0}
project.configuration.files.view.dialog.title=將檔案新增到 {0}
project.detected.n.roots.presentation=已檢測到 {0}
radio.after.creation.add.silently=無提示新增
radio.after.creation.do.not.add=不新增
radio.after.creation.show.options=詢問
radio.after.deletion.do.not.remove=不移除
radio.after.deletion.remove.silently=無提示移除
radio.after.deletion.show.options=詢問
radio.restore.workspace.on.branch.switching=切換分支時還原工作區(&B)
radio.restore.workspace.on.branch.switching.comment=工作區是一組開啟的檔案、當前執行組態以及與分支關聯的中斷點。
ranges.to.commit.of.ranges.size.changes={1} 個中的 {0} 個發生更改
remove.changelist.combobox.do.not.remove=不執行任何動作
remove.changelist.combobox.remove.silently=無提示移除
remove.changelist.combobox.show.options=顯示選項
retrieving.annotations=正在載入註解
revert.changes.changelist.chooser.title=選擇目標更改列表
rollback.modified.without.checkout.error.tab={0}未簽出時進行了修改
rollback.modified.without.editing.confirm.multiple=要將更改{0}到 {1} 個所選檔案嗎?
rollback.modified.without.editing.confirm.single=要將更改{0}到{1}嗎?
rolling.back.file=正在回滾{0}
roots.notification.content.added.vcs.name.roots=已新增 {0} 個{1,choice,1\\#根|2\\#根}\\: {2}
roots.notification.content.directory.registered.as.root.but.no.repositories.were.found.there=目錄 {0} 被註冊為 {1} 根，但在那裡沒有發現 {1} 版本庫。
roots.notification.title.invalid.vcs.root.choice.mapping.mappings=無效 VCS 根{0, choice, 1\\#映射|2\\#映射}
roots.notification.title.vcs.name.integration.enabled={0} 整合已啟用
roots.notification.title.vcs.root.configuration.problems=VCS 根組態問題
roots.the.following.directories.are.registered.as.vcs.roots.but.they.are.not=以下目錄被錯誤註冊為 VCS 根\\:
save.committing.files.confirmation.cancel=延遲儲存
save.committing.files.confirmation.ok=立即儲存
save.committing.files.confirmation.text=當前正在將以下{0,choice,1\\#檔案|2\\#檔案}提交到 VCS。立即儲存可能會導致提交的資料不一致。\\n{1}\\n立即儲存{0,choice,1\\#檔案|2\\#檔案}?
save.committing.files.confirmation.title=在提交期間儲存檔案
saved.patch.apply.action=套用(&A)
saved.patch.apply.pop.help.tooltip=<html>套用\\\\&mdash;套用並將隱藏保留在<br/>列表中。<br/>彈出\\\\&mdash;套用並從列表中<br/>移除隱藏。</html>
saved.patch.changes.empty=選擇隱藏或擱置以檢視檔案
saved.patch.changes.loading=正在載入…
saved.patch.created.on.date.at.time.tooltip={0} 在 {2} 建立於 {1}
saved.patch.editor.diff.preview.empty.title=隱藏和擱置
saved.patch.empty.text=未新增任何隱藏或擱置。
saved.patch.pop.action=彈出(&P)
scope.name.changelist.all.changed.files=所有更改的檔案
searching.for.code.smells.freezing.process=簽入前代碼分析
searching.for.code.smells.processing.file.progress.text=正在處理 {0}
selection.history.can.not.load.message=無法載入修訂內容
selection.history.commit.message.label=提交訊息\\:
selection.history.loading.revision.status=正在載入修訂 {0}…
selection.history.local.revision.text=本地更改
sequence.concatenation.a.and.b={0} 和 {1}
sequence.concatenation.separator=, 
sequence.concatenation.tail=和 {0}
sequence.concatenation.tail.n.others=和其他 {0} 個
settings.auto.detected=自動檢測\\:
settings.auto.detected.progress=正在檢測…
settings.border.when.files.are.created=當檔案被建立時\\:
settings.change.shelves.location=更改擱置位置…
settings.changelist.conflicts.group.title=衝突
settings.changelists.create.automatically.checkbox=自動建立更改列表(&A)
settings.changelists.option.group=更改列表
settings.check.every.minutes=分鐘
settings.checkbox.limit.history.to=將歷史記錄限制為
settings.checkbox.measure.days=天
settings.checkbox.rows=行
settings.checkbox.show.changed.in.last=醒目提示以下時間內更改的檔案\\:
settings.checkbox.show.changed.in.last.comment=修改的檔案將在外部堆疊追蹤和偵錯時醒目提示。
settings.commit.message.body.add.blank.line.fix=新增空白行
settings.commit.message.inspections=提交訊息檢查\\:
settings.commit.message.option.group=提交訊息
settings.commit.message.right.margin.label=右邊距\\:
settings.commit.message.show.right.margin.label=顯示右邊距
settings.commit.message.show.right.margin.n.columns.label=顯示 {0} 列中的右邊距
settings.commit.postpone.slow.checks=提交完成後執行進階檢查
settings.commit.postpone.slow.checks.description=失敗的檢查不會阻止提交
settings.commit.postpone.slow.checks.description.short=檢查失敗不會阻止提交
settings.commit.without.dialog.applies.to.git.mercurial=套用到 Git 和 Mercurial 下的專案
settings.confirmation.option.group=確認
settings.confirmation.option.text.ask=詢問
settings.confirmation.option.text.no=否
settings.confirmation.option.text.yes=是
settings.current.location=當前位置為
settings.default.location=預設位置為 
settings.file.status.color.added.in.not.active.changelist=已在停用更改列表中新增
settings.file.status.color.changelist.conflict=更改列表衝突
settings.file.status.color.modified.in.not.active.changelist=已在停用更改列表中修改
settings.files.with.ignored.conflicts.list.title=包含忽略衝突的檔案\\:
settings.filter.configure.link=組態
settings.filter.update.project.info.by.scope=按作用域篩選更新專案資訊
settings.general.changes.group.title=更改
settings.general.confirmation.group.title=確認
settings.general.show.options.before.command.label=進行以下動作之前顯示選項\\:
settings.highlight.files.from.non.active.changelist.checkbox=醒目提示停用更改列表中的檔案(&I)
settings.highlight.files.with.conflicts.checkbox=醒目提示存在更改列表衝突的檔案(&H)
settings.inactive.changelist.group.title=停用更改列表
settings.issue.navigation.patterns={0} 將在簽入註釋中搜尋指定的模式，並將它們鏈接到問題追蹤器中的問題\\:
settings.label.when.empty.changelist.becomes.inactive=當空更改列表變為停用狀態時\\:
settings.limit.history.to.n.rows.label=將歷史記錄限制為 {0} 行
settings.partial.changelists.enable.checkbox=允許將一個檔案中的更改放入不同的更改列表(&P)
settings.shelf.content.larger=大於 {0}K 的檔案的基內容不會被存儲
settings.show.changed.in.last.n.days.label=顯示過去 {0} 天的更改
settings.show.conflict.resolve.dialog.checkbox=試圖編輯停用更改列表中的檔案時顯示對話框(&D)
settings.vcs.mapping.browser.select.directory.description=選擇要映射到 VCS 的目錄
settings.vcs.mapping.browser.select.directory.title=選擇目錄
settings.vcs.mapping.invalid.vcs.options.error=無效的 VCS 選項\\: {0}
settings.vcs.mapping.project.description=所有模組的內容根，以及專案基目錄的所有直接後代
settings.vcs.mapping.project.description.with.idea.directory=所有模組的內容根、專案基目錄的所有直接後代以及 {0} 目錄內容
settings.vcs.mapping.status.looking.for.vcs.administrative.area=正在尋找 VCS 管理區域
settings.version.control.option.group=版本控制
settings.when.files.are.deleted=當檔案被刪除時\\:
shelf.apply.action.description=套用所選擱置
shelf.drop.action=刪除(&D)
shelf.drop.action.description=刪除所選擱置
shelf.pop.action.description=彈出所選擱置
shelf.root.node.title=擱置
shelf.tab=擱置
shelf.tooltip.title=擱置
shelf.unshelve.changes.action.description=取消擱置所選更改
shelf.unshelve.changes.action.text=取消擱置(&U)
shelf.unshelve.changes.remove.action.description=取消擱置所選更改並將其從擱置中移除
shelf.unshelve.changes.remove.action.text=取消擱置並移除(&R)
shelve.base.content.not.found.or.not.applicable.error=基內容未找到或不適用。顯示與本地版本的差異
shelve.changelist.not.found=未找到擱置的更改列表 {0}
shelve.changes.action=托管更改(_S)
shelve.changes.only.directories=所選更改僅影響目錄，不影響檔案，因此無法擱置它們
shelve.changes.progress.text=正在擱置更改…
shelve.changes.progress.title=正在擱置更改
shelve.changes.restore.error=無法完全還原{0, choice, 1\\#擱置的更改列表|2\\#{0}擱置的更改列表}，因為某些檔案已被永久刪除
shelve.copying.shelves.to.progress=正在將擱置複製到新目錄…
shelve.default.path.rendering=<專案根目錄>
shelve.delete.already.unshelved.label=刪除已擱置的更改列表\\:
shelve.delete.changelist.name.message=''{0}'' 更改列表
shelve.delete.changelists.count.message={0} 個更改列表
shelve.delete.files.from.changelist.error=無法從 {0} 刪除檔案
shelve.delete.files.successful.message={0,choice, 1\\#1 個檔案|2\\#{0} 個檔案}
shelve.delete.successful.message=已成功從擱置中刪除 {0}{1,choice, 0\\#|1\\# 和 }{2}
shelve.editor.diff.preview.title=擱置\\: {0}
shelve.error.title=Shelf 錯誤
shelve.failed.message={0,choice,1\\#更改列表|2\\#更改列表} [{1}] 的更改擱置失敗
shelve.failed.title=擱置失敗
shelve.file.is.locked.for.editing.message=在擱置期間檔案已鎖定，無法編輯
shelve.import.one.patch.file.prompt=找到一個補丁檔案({0})。\\n繼續匯入?
shelve.import.patches.prompt=找到 {0} 個補丁檔案。\\n繼續匯入?
shelve.import.to.progress=正在處理 
shelve.loading.patch.error=無法載入補丁檔案\\: {0}
shelve.moving.failed.prompt=Shelf 移動失敗。<br/>要使用新的 Shelf 目錄路徑還是將其還原為上一個路徑?
shelve.recently.deleted.node=最近刪除項
shelve.remove.successfully.applied.files.checkbox=從 Shelf 移除成功套用的檔案
shelve.revert.moving.button=還原(&R)
shelve.shelved.version=擱置的版本
shelve.show.already.unshelved.action=已取消擱置
shelve.successful.message=已成功擱置更改
shelve.tree.accessible.name=擱置
shelve.undo.deletion=撤消 Shelf 刪除
shelve.use.new.directory.button=使用新路徑(&U)
shelved.version.name=擱置的版本
show.diff.from.annotation.action.error.can.not.load.data.to.show.diff=無法載入資料以顯示差異
show.diff.in.editor.tab.got.it.tooltip=要在編輯器頁籤中再次顯示差異，請使用此選單。
show.diff.progress.title=正在載入內容
show.diff.progress.title.detailed=正在載入 {0} 的內容
show.history.action.name.template=顯示 {0} 的歷史記錄(_F)…
show.history.dialog.title.template={0} 的歷史記錄
show.patch.in.explorer.after.creation.combobox.text.ask=詢問
show.patch.in.explorer.after.creation.combobox.text.no=不執行任何動作
show.patch.in.explorer.after.creation.combobox.text.show.in.file.manager=在 {0} 中顯示
show.patch.in.explorer.after.creation.label=建立補丁時\\:
stash.changes.message=在{0}之前未提交的更改
stash.changes.message.with.date=在進行{0}之前於 {1} 取消提交了更改
stash.tree.accessible.name=隱藏
status.group.name.changed=已更改
status.group.name.changed.on.server=在伺服器上已更改
status.group.name.created=已建立
status.group.name.deleted=已刪除
status.group.name.locally.added=本地已新增
status.group.name.locally.removed=本地已移除
status.group.name.modified=已修改
status.group.name.not.in.repository=不在版本庫中
status.group.name.skipped=已跳過
status.group.name.switched=已切換
status.group.name.will.be.merged=將被合併
status.group.name.will.be.merged.with.conflicts=將在存在衝突的情況下被合併
status.group.name.will.be.merged.with.property.conflicts=將在存在屬性衝突的情況下合併
status.group.name.will.be.merged.with.tree.conflicts=將在存在樹衝突的情況下合併
status.group.name.will.be.restored=將被還原
status.text.commit.toolwindow.create.repository=建立 Git 版本庫…
status.text.commit.toolwindow.create.repository.prefix=要提交更改，
status.text.commit.toolwindow.local.history=本地歷史記錄…
status.text.commit.toolwindow.local.history.prefix=有關最近的更改，請參閱
status.text.vcs.toolwindow=要追蹤程式碼更改\\:
status.text.vcs.toolwindow.create.repository=建立 Git 版本庫…
status.text.vcs.toolwindow.emptyPrefix=—
status.text.vcs.toolwindow.help=版本控制整合
status.text.vcs.toolwindow.local.history=使用當地歷史記錄…
status.text.vcs.toolwindow.shareProject=將專案共享到
status.text.vcs.toolwindow.shareProject.orOn=或者
switch.to.changelist=切換到更改列表(''{0}'')(&T)
tab.title.commit=提交
tab.title.commit.to.branch=提交至 {0}
text.commit.message.truncated.by.ide.name={0}\\n\\n…提交訊息過長，被 {1} 截斷…
title.code.author.inlay.hints=程式碼作者
title.load.revision.contents=載入修訂內容
todo.handler.only.added=<html><body>發現{0,choice, 0\\#|1\\#一|2\\#{0}}個已被新增或編輯的 TODO {0,choice, 0\\#|1\\#專案|2\\#專案}。<br/>您是否想檢視{0,choice,1\\#它|2\\#它們}?<br/>{1,choice, 0\\#|1\\#1個檔案被跳過。|2\\#{1} 個檔案被跳過。}</body></html>
todo.handler.only.both=<html><body>{0, choice, 1\\#1|2\\#{0}} 個新增/編輯的 TODO {0,choice, 1\\#條目|2\\#條目}，<br/>並在更改的片段中找到 {1, choice, 1\\#1個條目|2\\#{1} 個條目}。<br/>要檢查它們嗎?<br/>{2,choice, 0\\#|1\\#1 個檔案被跳過。|2\\#{2} 個檔案被跳過。}</body></html>
todo.handler.only.in.changed=<html><body>{0,choice, 1\\#一|2\\#{0}}個 TODO {0,choice, 1\\#項|2\\#項} 在已改變的片段中找到。<br/>您是否需要查閱{0,choice,1\\#它|2\\#它們}?<br/>{1,choice, 0\\#|1\\#一個檔案被跳過|2\\#{1} 個檔案被跳過。}</body></html>
todo.handler.only.skipped=<html><body>TODO 檢查已經跳過 {0,choice, 0\\#|1\\#1 個檔案|2\\#{0}多個檔案}。<br/>沒有發現新的或已編輯的 TODO 條目，也沒有位於更改的文本片段中的條目。</body></html>
todo.in.new.review.button=審查 TODO(&R)
todo.tab.title.all.changes=本地更改
todo.tab.title.changelist.suffix=更改列表
tooltip.rerun.commit.checks=重新執行提交檢查
tooltip.show.options.dialog=顯示選項對話框
toolwindow.title.update.project=更新專案({0})
unknown.vcs.presentation=<未知 VCS> ({0})
unregistered.roots.label=未註冊的根\\:
unshelve.changelist.chooser.title=取消擱置更改列表的更改
unshelve.changes.action=取消托管更改
unshelve.changes.dialog.title=取消擱置更改
unshelve.changes.progress.title=正在取消擱置更改…
unshelve.loading.patch.error=無法載入補丁\\: {0}
update.can.t.load.content=無法載入內容
update.checkbox.don.t.show.again=不再顯示
update.directories.scope.name=目錄
update.directory.scope.name=目錄
update.error.label=錯誤\\: 
update.file.name.wasn.t.modified={0} 未修改
update.file.scope.name=檔案
update.files.scope.name=檔案
update.filtered.files.count.in.filter.name={0} ({1} 內)
update.group.name.created=已建立
update.group.name.deleted=已刪除
update.group.name.locally.added=本地已新增
update.group.name.locally.removed=本地已移除
update.group.name.merged=已合併
update.group.name.merged.with.conflicts=已合併，但存在衝突
update.group.name.merged.with.property.conflicts=已合併，但存在屬性衝突
update.group.name.merged.with.tree.conflicts=已合併，但存在樹衝突
update.group.name.modified=已修改
update.group.name.not.in.repository=不在版本庫中
update.group.name.restored=已還原
update.group.name.skipped=已跳過
update.group.name.switched=已切換
update.group.name.updated=已更新
update.group.name.updated.from.server=從伺服器更新
update.info.click.status.text.prefix=點擊
update.info.group.by.changelist=按更改列表分組
update.info.loading.changelists=正在載入更改列表…
update.info.refresh.link.status.text=重新整理
update.info.to.initialize.status.text.suffix=以初始化版本庫更改快取
update.label.after.update=更新後
update.label.before.update=更新前
update.notification.content.files.updated={0,choice,1\\#1 個檔案|2\\#{0} 個檔案}已更新
update.notification.content.view=檢視
update.notification.title.count.files.updated={0,choice,1\\#1 個檔案|2\\#{0} 個檔案}已更新
update.notification.title.project.partially.updated=專案已部分更新
update.project.scope.name=專案
update.tree.node.size.statistics={0,choice, 0\\#無條目|1\\#1 個條目|2\\#{0, number} 個條目}
user.group.title=使用者
vcs.add.to.ignore.file.action.group.description=將所選檔案新增到 {0}
vcs.add.to.ignore.file.action.group.text=新增到 {0}
vcs.add.to.ignore.file.create.ignore.file.confirmation.message=在 {1} 中建立 {0} 檔案?
vcs.add.to.ignore.file.create.ignore.file.confirmation.title=建立 {0}
vcs.command.name.add=新增
vcs.command.name.checkin=提交(_I)
vcs.command.name.checkout=簽出
vcs.command.name.edit=編輯
vcs.command.name.remove=移除
vcs.command.name.status=狀態
vcs.command.name.update=更新
vcs.commit.canceled=提交已取消
vcs.commit.files.committed={0,choice,0\\#無檔案|1\\#{0} 個檔案|2\\#{0} 個檔案}已提交
vcs.commit.files.committed.and.files.failed.to.commit={0,choice,0\\#無檔案|1\\#{0} 個檔案|2\\#{0} 個檔案}已提交，{1,choice,1\\#{1} 個檔案|2\\#{1} 個檔案}提交失敗
vcs.commit.notification.shareProjectOn=在 {0} 上共享專案
vcs.commit.notification.shareProjectOn.orOn=基於 {0}
vcs.common.labels.directory=目錄\\:
vcs.common.labels.url=URL\\:
vcs.common.labels.vcs=VCS\\:
vcs.common.labels.version.control=版本控制\\:
vcs.config.track.changed.on.server=檢查與伺服器衝突的時間間隔
vcs.console.toolwindow.display.name=主控台
vcs.dnd.image.text.n.files={0} 個{0, choice, 1\\#檔案|2\\#檔案}
vcs.error.failed.to.load.file.content.from.vcs=無法載入內容
vcs.generic.name=VCS
vcs.generic.name.with.mnemonic=VCS(_S)
vcs.local.changes.toolbar=VCS 本地更改工具列
vcs.operations.popup=VCS 動作彈出視窗
vcs.preview.panel.added.ignored.line=已新增忽略的行
vcs.preview.panel.added.line=已新增行
vcs.preview.panel.deleted.ignored.line.below=已刪除以下忽略的行
vcs.preview.panel.deleted.line.below=以下已刪除的行
vcs.preview.panel.last.commit.modified.line=上次提交中修改的行
vcs.preview.panel.line.with.modified.whitespaces=帶有修改的空格的行
vcs.preview.panel.line.with.modified.whitespaces.and.deletion.after=帶有修改的空格和後續刪除的行
vcs.preview.panel.modified.ignored.line=已修改忽略的行
vcs.preview.panel.modified.line=已修改的行
vcs.quicklist.popup.title=VCS 動作
vcs.revision.name.current=當前
vcs.settings.path=設定 | 版本控制
vcs.settings.path.mac=偏好設定 | 版本控制
vcs.shelf.action.restore.description=還原最近刪除的{0, choice, 1\\#更改列表|2\\#更改列表}
vcs.shelf.action.restore.text=還原
vcs.shelf.move.text=將擱置移至新位置(&M)
vcs.shelf.store.base.content=擱置分布式版本控制系統下檔案的基本修訂版本
vcs.shelving.changes=正在擱置更改…
vcs.unshelving.changes=正在取消擱置更改…
vcs.unshelving.conflict.left=您未提交的更改
vcs.unshelving.conflict.right=遠端更改
vcs.update.tab.name=更新資訊
version.control.main.configurable.description=<html><body>組態與專案中使用的版本控制相關的設定
version.control.main.configurable.name=版本控制
vfs.revision.author.unknown=未知
waiting.changelists.update.for.show.commit.dialog.message=提交
"
`;

exports[`src messages/VcsLogBundle.properties 1`] = `
"action.ShowCommitTooltipAction.description=在日誌中為當前所選提交顯示工具提示
action.ShowCommitTooltipAction.text=顯示提交工具提示
action.Vcs.Log.AlignLabels.description=在提交訊息左側顯示參照
action.Vcs.Log.AlignLabels.text=左側的參照
action.Vcs.Log.AnnotateRevisionAction.description=註解所選修訂
action.Vcs.Log.AnnotateRevisionAction.text=註解
action.Vcs.Log.CompactReferencesView.description=僅在表中顯示提交的第一個參照
action.Vcs.Log.CompactReferencesView.text=緊湊型參照檢視
action.Vcs.Log.CompareRevisions.description=比較選定版本
action.Vcs.Log.CompareRevisions.text=比較版本
action.Vcs.Log.EnableFilterByRegexAction.text=正則表達式
action.Vcs.Log.FocusTextFilter.description=聚焦文本篩選器或將焦點移回提交列表
action.Vcs.Log.FocusTextFilter.text=聚焦文本篩選器
action.Vcs.Log.GoToChild.description=導覽到提交圖中的子行
action.Vcs.Log.GoToChild.text=轉到子提交
action.Vcs.Log.GoToParent.description=導覽到提交圖中的父行
action.Vcs.Log.GoToParent.text=轉到父提交
action.Vcs.Log.GoToRef.description=指定分支或標記的雜湊或名稱，以導覽到其指向的提交
action.Vcs.Log.GoToRef.text=轉到雜湊/分支/標記
action.Vcs.Log.MatchCaseAction.text=區分大小寫
action.Vcs.Log.MoveDiffPreviewToBottom.description=在底部找到差異預覽
action.Vcs.Log.MoveDiffPreviewToBottom.text=底部
action.Vcs.Log.MoveDiffPreviewToRight.description=在右側找到差異預覽
action.Vcs.Log.MoveDiffPreviewToRight.text=右側
action.Vcs.Log.OpenRepositoryVersion.description=在編輯器中開啟檔案的所選修訂
action.Vcs.Log.OpenRepositoryVersion.text=按修訂顯示檔案
action.Vcs.Log.PreferCommitDate.description=顯示提交更改的時間，而不是建立時間
action.Vcs.Log.PreferCommitDate.text=提交時間戳
action.Vcs.Log.Refresh.description=檢查新提交，必要時重新整理日誌
action.Vcs.Log.Refresh.text=重新整理
action.Vcs.Log.ResumeIndexing.description=索引編制已暫停，因為它花費的時間比預期長。恢復。
action.Vcs.Log.ResumeIndexing.text=恢復索引編制
action.Vcs.Log.SelectInLog.text=在 VCS 日誌中顯示
action.Vcs.Log.SelectInLog.text.template=在 {0} 日誌中顯示
action.Vcs.Log.ShowAllAffected.description=顯示選中修訂中所做的所有更改
action.Vcs.Log.ShowAllAffected.text=顯示所有受影響的檔案
action.Vcs.Log.ShowBigRepositories.text=顯示已停用索引的版本庫
action.Vcs.Log.ShowChangesFromParents.description=分別顯示對每個合併提交所做的更改
action.Vcs.Log.ShowChangesFromParents.text=顯示對父項的更改
action.Vcs.Log.ShowDetailsAction.description=顯示詳細資訊面板
action.Vcs.Log.ShowDetailsAction.text=顯示詳細資訊
action.Vcs.Log.ShowDiffPreview.description=顯示差異預覽面板
action.Vcs.Log.ShowDiffPreview.text=顯示差異預覽
action.Vcs.Log.ShowLongEdges.description=即使提交在當前檢視中不可見，也顯示長分支邊。
action.Vcs.Log.ShowLongEdges.text=長邊
action.Vcs.Log.ShowOnlyAffectedChanges.description=僅顯示影響“路徑”選單中所選檔案的更改
action.Vcs.Log.ShowOnlyAffectedChanges.text=僅顯示受影響的更改
action.Vcs.Log.ShowRootsColumnAction.text=根名稱
action.Vcs.Log.ShowSettingsAction.GoToAction.text=VCS 日誌設定
action.Vcs.Log.ShowSettingsAction.text=設定
action.Vcs.Log.ShowTagNames.description=在表中顯示標籤名稱
action.Vcs.Log.ShowTagNames.text=標籤名稱
action.Vcs.Log.ShowTooltip.description=在日誌中為當前選定提交顯示工具提示
action.Vcs.Log.ShowTooltip.text=顯示提交工具提示
action.Vcs.Show.Log.text=顯示 VCS 日誌
action.Vcs.Show.Log.text.template=顯示 {0} 日誌
action.description.collapse.linear.branches=摺疊線性分支
action.description.collapse.merges=摺疊合併
action.description.expand.linear.branches=展開線性分支
action.description.expand.merges=展開合併
action.description.is.scheduled=為 {0} 編制索引已計劃。暫停。
action.description.was.disabled=索引 {0} 已停用。啟用。
action.description.was.paused=為 {0} 編制索引已暫停。恢復。
action.go.to.navigate.to=導覽到 {0}
action.go.to.select.child.to.navigate=選擇要導覽的子項
action.go.to.select.hash.subject.author.date.time={0} {1}，作者 {2}，{3} {4}
action.go.to.select.parent.to.navigate=選擇要導覽的父項
action.help.tooltip.resume.indexing=為專案版本庫編制索引可以改進整個 IDE 中對更改歷史記錄的處理\\:<br/>- 快速日誌篩選和計算精確歷史記錄<br/>- 用於修訂的檔案歷史記錄中的分支篩選器<br/>- 在“隨處搜尋”中跨歷史記錄進行搜尋
action.presentation.CompareRevisionsFromFileHistoryActionProvider.description.compare=比較所選版本
action.presentation.CompareRevisionsFromFileHistoryActionProvider.description.show.diff=顯示與之前版本的差異
action.presentation.CompareRevisionsFromFileHistoryActionProvider.text.compare=比較
action.presentation.CompareRevisionsFromFileHistoryActionProvider.text.show.diff=顯示差異
action.process.collapsing.linear.branches=正在摺疊線性分支…
action.process.collapsing.merges=正在摺疊合併…
action.process.expanding.linear.branches=正在展開線性分支…
action.process.expanding.merges=正在展開合併…
action.title.collapse.linear.branches=摺疊線性分支
action.title.collapse.merges=摺疊合併
action.title.enable.indexing=啟用 {0} 日誌索引
action.title.expand.linear.branches=展開線性分支
action.title.expand.merges=展開合併
action.title.match.case=區分大小寫
action.title.match.case.only.supported=區分大小寫(僅限 {0})
action.title.pause.indexing=暫停 {0} 日誌索引編制
action.title.resume.indexing=恢復 {0} 日誌索引編制
action.vcs.log.branches.separator=分支動作
action.vcs.log.graph.options.separator=選項
action.vcs.log.highlight.separator=醒目提示顯示
action.vcs.log.show.separator=顯示
action.vcs.log.sort.type.separator=排序
activity.tracker.vcs.log=VCS 日誌索引
dialog.title.paths.affected.by.commit=受提交 {0} 影響的路徑
file.history.action.could.not.load.selected.commits.message=無法載入所選提交\\: {0}
file.history.commit.not.found={1} 的歷史記錄中不存在 {0}
file.history.commit.not.found.in.branch=所選分支中 {1} 的歷史記錄中沒有 {0}
file.history.commit.not.found.view.and.show.all.branches.link=檢視並顯示所有分支
file.history.commit.not.found.view.in.log.link=在日誌中檢視
file.history.diff.preview.editor.tab.name=歷史記錄\\: {0}
file.history.empty.status=檔案歷史記錄
file.history.error.status=計算檔案歷史記錄時出錯
file.history.reset.filters.status.action=重設篩選器
file.history.show.commit.in.history.process=正在檔案歷史記錄中搜尋提交 {0}
file.history.toolbar=檔案歷史工具列
filetype.vcs.log.description=VSC 日誌
graph.options.first.parent=第一個父項
graph.options.first.parent.description=看到合併提交後，僅跟隨第一個父提交
graph.options.linear=線性化合併
graph.options.linear.description=合併時，在 main 分支提交的頂部顯示傳入提交，就好像對它們進行重定基底
graph.options.linear.presentation=已線性化
graph.sort.off=按提交日期
graph.sort.off.description=按提交日期以拓撲方式對提交進行排序
graph.sort.standard=以拓撲方式
graph.sort.standard.description=合併時，首先在合併提交正下方顯示傳入提交
group.Log.KeymapGroup.text=日誌
group.Vcs.FileHistory.PresentationSettings.description=組態檔案歷史記錄的表示
group.Vcs.FileHistory.PresentationSettings.text=檢視選項
group.Vcs.Log.ChangesBrowser.PresentationSettings.text=檢視選項
group.Vcs.Log.Diff.Preview.Location.text=差異預覽位置
group.Vcs.Log.GraphOptionsGroup.description=VCS 日誌圖選項和動作
group.Vcs.Log.GraphOptionsGroup.text=圖選項
group.Vcs.Log.Internal.text=VSC 日誌
group.Vcs.Log.LayoutConfiguration.description=組態視窗布局
group.Vcs.Log.LayoutConfiguration.separator.text=布局
group.Vcs.Log.LayoutConfiguration.text=組態布局
group.Vcs.Log.PresentationSettings.description=組態日誌的表示
group.Vcs.Log.PresentationSettings.text=檢視選項
group.Vcs.Log.TextFilterSettings.description=選擇文本篩選器選項
group.Vcs.Log.TextFilterSettings.text=文本篩選器設定
group.Vcs.Log.ToggleColumns.description=選擇要在表中檢視的列
group.Vcs.Log.ToggleColumns.text=列
loading.commit.changes=正在載入提交更改
prefer.commit.timestamp.action.text.show=顯示提交時間戳
vcs=VCS
vcs.log.action.description.open.new.tab.with.log=開啟包含 {0} 日誌的新頁籤
vcs.log.action.description.open.new.tab.with.log.in.editor=在編輯器中開啟包含 {0} 日誌的新頁籤
vcs.log.action.highlight.current.branch=當前分支
vcs.log.action.highlight.indexed.commits=已編制索引的提交
vcs.log.action.highlight.merge.commits=合併提交
vcs.log.action.highlight.my.commits=我的提交
vcs.log.action.open.new.tab.with.log=開啟新的 {0} 日誌頁籤
vcs.log.action.open.new.tab.with.log.in.editor=開啟新的 {0} 日誌編輯器頁籤
vcs.log.action.show.in.file.history.text=在檔案歷史記錄中顯示
vcs.log.applying.filters.process=正在套用篩選器…
vcs.log.big.repositories.dialog.title=已停用索引的版本庫
vcs.log.bookmark.description.empty.subject=(無訊息)
vcs.log.bookmark.label=書籤
vcs.log.bookmark.label.mnemonic=為 ''{0}'' 新增書籤
vcs.log.branch.filter.action.text=按分支篩選
vcs.log.branch.filter.favorites=收藏夾
vcs.log.branch.filter.label=分支
vcs.log.changes.accessible.name=提交更改瀏覽器
vcs.log.changes.browser.toolbar=VCS 日誌更改瀏覽器工具列
vcs.log.changes.changes.to.parent.node=對 {0} 的更改
vcs.log.changes.details.no.commits.selected.status=未選擇提交
vcs.log.changes.no.changes.that.affect.selected.paths.status=沒有影響所選路徑的更改。
vcs.log.changes.no.merge.conflicts.node=沒有合併的衝突
vcs.log.changes.no.merge.conflicts.status=沒有合併的衝突。
vcs.log.changes.select.commits.to.view.changes.status=選擇要檢視更改的提交
vcs.log.changes.show.all.paths.status.action=顯示所有路徑的更改
vcs.log.changes.show.changes.to.parents.status.action=顯示對父項的更改
vcs.log.changes.too.many.show.anyway.status.action=仍然顯示
vcs.log.changes.too.many.status={0,choice,1\\#此提交|2\\#所選提交之一}具有 {1} 個更改
vcs.log.clear.caches.checkbox.description=清除 VCS 日誌快取和索引
vcs.log.click.to.collapse.paths.column.tooltip=點擊以摺疊
vcs.log.click.to.expand.paths.column.tooltip=點擊以展開
vcs.log.column.author=作者
vcs.log.column.date=日期
vcs.log.column.hash=雜湊
vcs.log.column.subject=主題
vcs.log.commit.details.status=提交詳細資訊
vcs.log.commit.does.not.match={0} 與篩選器不符合
vcs.log.commit.does.not.match.view.and.reset.link=檢視並重設篩選器
vcs.log.commit.does.not.match.view.in.tab.link=在新頁籤中檢視
vcs.log.commit.not.found=找不到 {0}
vcs.log.commit.or.reference.prefix=提交或參照 ''{0}''
vcs.log.commit.prefix=提交 ''{0}''
vcs.log.commit.status.action=提交本地更改
vcs.log.creating.process=正在載入提交…
vcs.log.date.filter.action.last.day=過去 24 小時
vcs.log.date.filter.action.last.week=過去 7 天
vcs.log.date.filter.action.text=按日期篩選
vcs.log.date.filter.label=日期
vcs.log.date.filter.select.period.dialog.title=選擇期間
vcs.log.date.filter.since=自 {0}
vcs.log.date.filter.until=到 {0}
vcs.log.default.status=更改日誌
vcs.log.details.author.on.date.at.time=作者 {0}，{1} {2}
vcs.log.details.committer.info.date.time=在 {0} {1} 提交
vcs.log.details.committer.info.user=由 {0} 提交
vcs.log.details.committer.info.user.date.time=由 {0} 於 {1} {2} 提交
vcs.log.details.in.branches=在 {0,choice,1\\#{0} 個分支|2\\#{0} 個分支}中\\:
vcs.log.details.in.branches.empty=不在任何分支中
vcs.log.details.in.branches.hide=隱藏
vcs.log.details.in.branches.loading=在分支中\\: 正在載入…
vcs.log.details.in.branches.show.all=全部顯示
vcs.log.details.references.more.label=…其他 {0} 個
vcs.log.details.showing.selected.commits=(正在顯示 {0}/{1} 個所選提交)
vcs.log.diff.preview.editor.empty.tab.name=版本庫差異
vcs.log.diff.preview.editor.tab.name=版本庫差異\\: {0}
vcs.log.duplicated.tab.id.error=“VCS 日誌”頁籤不能開啟兩次
vcs.log.editor.name=VCS 日誌編輯器
vcs.log.error.filtering.status=篩選提交時出錯
vcs.log.error.loading.changes.status=載入更改時出錯
vcs.log.error.loading.commits.status=載入提交時出錯
vcs.log.error.loading.details.status=載入提交詳細資訊時出錯
vcs.log.failed.loading.details=無法在 {1} 中載入提交 {0} 的詳細資訊
vcs.log.fatal.error.message=無法使 {0} 下的快取失效。\\n請手動刪除快取目錄，然後重啟 {1}。
vcs.log.filter.accessible.name={0}\\: {1}
vcs.log.filter.action.select=選擇…
vcs.log.filter.all=所有
vcs.log.filter.branch.presentation.with.prefix=在 {0} 上
vcs.log.filter.clear=清除
vcs.log.filter.date.display.name.after=自 {0}
vcs.log.filter.date.display.name.before=到 {0}
vcs.log.filter.date.display.name.between={0} 和 {1} 之間
vcs.log.filter.date.presentation.with.prefix.made.after=生成自 {0}
vcs.log.filter.date.presentation.with.prefix.made.before=生成到 {0}
vcs.log.filter.date.presentation.with.prefix.made.between=在 {0} 與 {1} 之間進行
vcs.log.filter.edit.folders=選擇…
vcs.log.filter.no.merges=無合併
vcs.log.filter.popup.advertisement.text=選擇一個或多個用 {0} 分隔的值
vcs.log.filter.popup.advertisement.text.new.lines=新行
vcs.log.filter.popup.advertisement.text.or.suffix=或{0}
vcs.log.filter.popup.advertisement.with.key.text=選擇一個或多個用 {0} 分隔的值，並使用 {1} 完成
vcs.log.filter.popup.no.folders=無路徑
vcs.log.filter.popup.no.items=沒有項
vcs.log.filter.popup.no.roots=沒有根
vcs.log.filter.popup.paths=路徑
vcs.log.filter.recent=最近
vcs.log.filter.root.presentation.with.prefix=在 {0} 中
vcs.log.filter.roots=根
vcs.log.filter.select.folders=在樹中選擇…
vcs.log.filter.structure.presentation.with.prefix=用於 {0}
vcs.log.filter.text.hash.empty.text=文本或雜湊
vcs.log.filter.text.hash.tooltip=按提交訊息或雜湊篩選
vcs.log.filter.text.presentation.with.prefix=包含 {0}
vcs.log.filter.tooltip.click.to.see.only={0}+點擊以僅檢視“{1}”
vcs.log.filter.tooltip.folders=路徑\\:
vcs.log.filter.tooltip.no.roots.selected=未選擇根
vcs.log.filter.tooltip.roots=根\\:
vcs.log.filter.user.presentation.with.prefix=被 {0} 使用
vcs.log.filters.structure.label=已選擇\\: {0}
vcs.log.filters.structure.max.selected.error.message=您已新增 {0} 個元素。不允許更多元素。
vcs.log.go.to.hash.popup.label=輸入雜湊或分支/標記名稱\\:
vcs.log.graph.arrow.tooltip.jump.to.hash=跳轉到提交 {0}
vcs.log.graph.arrow.tooltip.jump.to.hash.in.root=跳轉到 {1} 中的提交 {0}
vcs.log.graph.arrow.tooltip.jump.to.subject.author.date.time=跳轉到 {0} (作者 {1}，{2} {3})
vcs.log.index.diagnostic.action.title=檢查舊提交的 VCS 日誌索引資料
vcs.log.index.diagnostic.error.attribute.name.author=作者
vcs.log.index.diagnostic.error.attribute.name.author.time=作者日期
vcs.log.index.diagnostic.error.attribute.name.committer=提交者
vcs.log.index.diagnostic.error.attribute.name.committer.time=提交日期
vcs.log.index.diagnostic.error.attribute.name.message=訊息
vcs.log.index.diagnostic.error.attribute.name.parents=父項
vcs.log.index.diagnostic.error.filter=按 {0} 篩選不會返回 {1}
vcs.log.index.diagnostic.error.for.commit=提交 {0} 的差異\\n{1}
vcs.log.index.diagnostic.error.message=應為 {0}\\: {1}，實際為 {0}\\: {2}
vcs.log.index.diagnostic.progress.title=正在執行 VCS 日誌索引診斷
vcs.log.index.diagnostic.report.title=VCS 日誌索引診斷報告 {0}
vcs.log.index.diagnostic.selected.action.title=檢查所選提交的 VCS 日誌索引資料
vcs.log.index.diagnostic.selected.non.indexed.warning.message=所選提交未編制索引
vcs.log.index.diagnostic.success.message={0} 個已檢查{0,choice,1\\#提交|2\\#提交}的 VCS 日誌索引資料正確
vcs.log.invalidate.caches.progress=正在使 {0} 日誌快取和索引失效
vcs.log.invalidate.caches.text=使 {0} 日誌快取和索引失效
vcs.log.is.loading=正在載入 VCS 日誌…
vcs.log.is.not.available=VCS 日誌不可用
vcs.log.loading.selected.details.process=正在載入所選詳細資訊
vcs.log.loading.status=正在載入提交…
vcs.log.no.commits.matching.status=沒有與篩選器符合的提交
vcs.log.no.commits.status=未提交更改。
vcs.log.path.filter.action.text=按路徑篩選
vcs.log.references.more.tooltip=…詳細資訊窗格中的其他 {0} 項
vcs.log.refresh.status.action=重新整理
vcs.log.reset.filters.status.action=重設篩選器
vcs.log.right.corner.toolbar=VCS 日誌工具列
vcs.log.select.folder.dialog.title=選擇要篩選的路徑
vcs.log.settings.diff.preview.location=位置\\:
vcs.log.settings.enable.index.checkbox=為專案啟用索引編制{0,choice,0\\#|1\\# (僅 {1})}
vcs.log.settings.enable.index.checkbox.comment=改進跨 IDE 的更改歷史記錄的處理
vcs.log.settings.group.file.history.title=檔案歷史記錄
vcs.log.settings.group.indexing.title=正在編制索引
vcs.log.settings.group.title=日誌
vcs.log.settings.show.file.names=顯示檔名
vcs.log.settings.visible.columns=可見列
vcs.log.show.commit.in.log.process=正在日誌中搜尋提交 {0}
vcs.log.status.bar.indexing={0} 日誌正在編制索引…
vcs.log.status.bar.indexing.cancel.cancelling=正在取消
vcs.log.status.bar.indexing.cancel.tooltip=取消索引編制。可以從 {0} 日誌工具列手動重啟索引編制。
vcs.log.string.is.not.a.hash=''{0}'' 看起來不像提交雜湊
vcs.log.tab.name=日誌
vcs.log.table.accessible.name={0} 日誌
vcs.log.text.filter.accessible.name={0} 日誌文本或雜湊篩選器
vcs.log.text.filter.action.text=按文本或雜湊篩選
vcs.log.user.filter.action.text=按使用者篩選
vcs.log.user.filter.label=使用者
vcs.log.user.filter.me=我
vcs.log.wip.label=新增提交…
"
`;

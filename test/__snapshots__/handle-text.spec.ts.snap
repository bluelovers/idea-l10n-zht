// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`dev inspectionDescriptions/LeakableMapKey.html 1`] = `
"<html>
<body>
報告在套件程式碼中將 <code>Language</code> 或 <code>FileType</code> 用作映射鍵。
<p>
  此類用法可能導致無法正確解除安裝套件。
</p>
<p>
  請考慮使用 <code>String</code> 作為鍵。
</p>
<p>
  有關更多資訊，請參閱 SDK 文檔中的<a href=\\"https://plugins.jetbrains.com/docs/intellij/dynamic-plugins.html\\">動態套件</a>。
</p>
</body>
</html>"
`;

exports[`dev messages/ActionsBundle.properties 1`] = `
"# IDEA core action texts and descriptions go here.
# The key patterns are \\"action.\\" + id + \\".text\\" and \\"action.\\" + id + \\".description\\"

action.ContextHelp.text=上下文幫助(_X)
action.ContextHelp.description=顯示上下文幫助
action.RunConfiguration.text=選擇執行/調試配置
action.SwitchCoverage.text=顯示程式碼覆蓋率資料(_V)
action.GenerateCoverageReport.text=生成覆蓋率報告(_G)
action.RunConfiguration.description=選擇執行/調試配置
action.ShowIntentionActions.text=顯示上下文操作
action.ToggleReadOnlyAttribute.text=切換唯讀特性
action.ToggleReadOnlyAttribute.synonym=將檔案設為可寫
action.ToggleReadOnlyAttribute.synonym2=將檔案設為唯讀
action.ToggleReadOnlyAttribute.description=切換當前檔案的唯讀特性
# suppress inspection \\"UnusedMessageFormatParameter\\"
action.ToggleReadOnlyAttribute.files=使{2,choice,1#檔案|2#檔案}{0,choice,0#唯讀|1#可寫}
# suppress inspection \\"UnusedMessageFormatParameter\\"
action.ToggleReadOnlyAttribute.dirs=使{3,choice,1#目錄|2#目錄}{0,choice,0#唯讀|1#可寫}
# suppress inspection \\"UnusedMessageFormatParameter\\"
action.ToggleReadOnlyAttribute.mixed=使檔案/目錄{0,choice,0#唯讀|1#可寫}
action.TogglePopupHints.text=切換當前檔案的彈出視窗提示
action.ShowPopupMenu.text=顯示右鍵選單
action.Vcs.ShowMessageHistory.text=提交訊息歷史記錄
action.Vcs.ShowMessageHistory.description=顯示提交訊息歷史記錄
action.Vcs.ShowHistoryForBlock.text=顯示選擇的歷史記錄(_F)
action.Vcs.ShowHistoryForBlock.description=顯示編輯器選擇的歷史記錄
action.Vcs.ShowHistoryForRevision.text=迄今為止的歷史記錄
action.Vcs.ShowHistoryForRevision.description=顯示檔案的歷史記錄，直到所選修訂版本
action.Vcs.ShowTabbedFileHistory.text=顯示歷史記錄(_H)
action.Vcs.ShowTabbedFileHistory.description=顯示檔案的歷史記錄
action.AddToFavoritesPopup.text=添加到收藏夾
action.AddToFavoritesPopup.description=將所選節點添加到收藏夾
group.AddToFavorites.text=添加到收藏夾(_A)
group.AddAllToFavorites.text=全部添加到收藏夾(_L)
action.AddNewFavoritesList.text=添加新收藏夾列表
action.AddNewFavoritesList.description=添加新收藏夾列表
action.EditFavorites.text=重命名收藏夾列表
group.SendToFavoritesGroup.text=發送至收藏夾(_S)
action.ActivateNavBar.text=啟用導航欄(_B)
action.ActivateNavBar.description=啟用導航欄
action.CreateRunConfiguration.text=創建執行配置
action.CreateRunConfiguration.description=根據當前上下文創建執行配置
group.RunContextPopupGroup.text=執行配置
group.EditorActions.text=編輯器操作
action.EditorChooseLookupItem.text=選擇查詢條目
action.EditorChooseLookupItemReplace.text=選擇查詢條目取代
action.EditorChooseLookupItemCompleteStatement.text=選擇查詢條目並調用語句補全
action.EditorChooseLookupItemDot.text=選擇查詢條目並插入點
action.NextTemplateVariable.text=下一個模板變數或完成就地重構
action.SelectVirtualTemplateElement.text=顯示用於就地重構的選項彈出視窗
action.PreviousTemplateVariable.text=上一個模板變數
action.NextParameter.text=下一個參數
action.PrevParameter.text=上一個參數
action.EditorPageUp.text=向上翻頁
action.EditorPageDown.text=向下翻頁
action.EditorPageUpWithSelection.text=在保持選區的情況下向上翻頁
action.EditorPageDownWithSelection.text=在保持選區的情況下向下翻頁
action.EditorCopy.text=複製
action.EditorCut.text=剪下
action.EditorPaste.text=貼上
action.EditorPasteSimple.text=貼上為純文本(_L)
action.EditorPasteSimple.description=貼上，不進行格式化、自動匯入、文字轉義等。
action.EditorPasteFromX11.text=從 X 剪貼簿貼上
action.EditorDelete.text=刪除
action.EditorBackSpace.text=退格
action.EditorHungryBackSpace.text=飢餓退格
action.EditorHungryBackSpace.description=與退格鍵的作用相同，但也會移除文本游標前的所有空白符號(如有)
action.EditorMoveToPageTop.text=將文本游標移至頁面頂部
action.EditorMoveToPageBottom.text=將文本游標移至頁面底部
action.EditorMoveToPageTopWithSelection.text=在保持選區的情況下將文本游標移至頁面頂部
action.EditorMoveToPageBottomWithSelection.text=在保持選區的情況下將文本游標移至頁面底部
action.EditorEnter.text=Enter
action.EditorEscape.text=Esc
action.FocusEditor.text=聚焦編輯器
action.EditorUp.text=上
action.EditorDown.text=下
action.EditorLeft.text=左
action.EditorRight.text=右
action.EditorUpWithSelection.text=在保持選區的情況下向上
action.EditorDownWithSelection.text=在保持選區的情況下向下
action.EditorLeftWithSelection.text=在保持選區的情況下向左
action.EditorRightWithSelection.text=在保持選區的情況下向右
action.EditorLookupUp.text=向上尋找
action.EditorLookupDown.text=向下尋找
action.EditorIndentSelection.text=縮排選區
action.EditorUnindentSelection.text=取消縮排行或選區
action.EditorIndentLineOrSelection.text=縮排行或選區
action.EditorTab.text=頁籤
action.EditorResetFontSize.text=重置字體大小
action.EmacsStyleIndent.text=Emacs 頁籤
action.EditorScrollUp.text=向上滾動
action.EditorScrollDown.text=向下滾動
action.EditorScrollUpAndMove.text=向上滾動並根據需要移動
action.EditorScrollDownAndMove.text=向下滾動並根據需要移動
action.EditorScrollLeft.text=向左滾動
action.EditorScrollRight.text=向右滾動
action.EditorScrollTop.text=滾動到頂部
action.EditorScrollBottom.text=滾動到底部
action.EditorMoveUpAndScroll.text=向上移動並滾動
action.EditorMoveDownAndScroll.text=向下移動並滾動
action.EditorMoveUpAndScrollWithSelection.text=在保持選區的情況下向上移動並滾動
action.EditorMoveDownAndScrollWithSelection.text=在保持選區的情況下向下移動並滾動
action.EditorAddOrRemoveCaret.text=添加或移除文本游標
action.EditorAddOrRemoveCaret.description=在當前檔案中設定多個游標，以同時編輯多行程式碼。
action.EditorCreateRectangularSelection.text=創建矩形選區
action.EditorAddRectangularSelectionOnMouseDrag.text=拖動滑鼠時添加矩形選區
action.EditorCreateRectangularSelectionOnMouseDrag.text=拖動滑鼠創建矩形選區
action.EditorCloneCaretBelow.text=在下方克隆文本游標
action.EditorCloneCaretBelow.description=在下面的行中插入一個輔助游標，以同時編輯多行程式碼。
action.EditorCloneCaretAbove.text=在上方克隆文本游標
action.EditorCloneCaretAbove.description=在上面的行中插入一個輔助游標，以同時編輯多行程式碼。
action.SelectNextOccurrence.text=將下一個符合項添加到選擇
action.SelectNextOccurrence.description=通過將當前單詞的下一個符合項添加到選區來設定多個游標。
action.SelectAllOccurrences.text=選擇所有符合項
action.SelectAllOccurrences.description=通過將當前單詞的所有符合項添加到選區來設定多個游標。
action.UnselectPreviousOccurrence.text=取消選擇符合項
action.UnselectPreviousOccurrence.description=從選區中移除單詞的當前符合項。
action.EditorAddCaretPerSelectedLine.text=在所選行的末尾添加文本游標
action.EditorToggleStickySelection.text=切換粘性選區
action.EditorSwapSelectionBoundaries.text=交換選區邊界
action.EditorLineStart.text=將文本游標移至行首
action.EditorLineEnd.text=將文本游標移至行尾
action.EditorDeleteToLineStart.text=刪除到行首
action.EditorDeleteToLineEnd.text=刪除到行尾
action.EditorCutLineBackward.text=反向剪下行
action.EditorCutLineEnd.text=剪下到行尾
action.EditorTextStart.text=將文本游標移至文本開始
action.EditorTextEnd.text=將文本游標移至文本結束
action.EditorForwardParagraph.text = 將文本游標前移一段
action.EditorBackwardParagraph.text = 將文本游標後移一段
action.EditorForwardParagraphWithSelection.text = 在保持選區的情況下將文本游標前移一段
action.EditorBackwardParagraphWithSelection.text = 在保持選區的情況下將文本游標後移一段
action.EditorLineStartWithSelection.text=在保持選區的情況下將文本游標移至行首
action.EditorLineEndWithSelection.text=在保持選區的情況下將文本游標移至行尾
action.EditorTextStartWithSelection.text=在保持選區的情況下將文本游標移至文本開始
action.EditorTextEndWithSelection.text=在保持選區的情況下將文本游標移至文本結束
action.EditorNextWord.text=將文本游標移至下一個單詞
action.EditorNextWordInDifferentHumpsMode.text=在不同的 \\"CamelHumps\\" 模式下將文本游標移至下一個單詞
action.EditorPreviousWord.text=將文本游標移至上一個單詞
action.EditorPreviousWordInDifferentHumpsMode.text=在不同的 \\"CamelHumps\\" 模式下將文本游標移至上一個單詞
action.EditorNextWordWithSelection.text=在保持選區的情況下將文本游標移至下一個單詞
action.EditorNextWordInDifferentHumpsModeWithSelection.text=在不同的 \\"CamelHumps\\" 模式下保持選區的情況下將文本游標移至下一個單詞
action.EditorPreviousWordWithSelection.text=在保持選區的情況下將文本游標移至上一個單詞
action.EditorPreviousWordInDifferentHumpsModeWithSelection.text=在不同的 \\"CamelHumps\\" 模式下保持選區的情況下將文本游標移至上一個單詞
action.EditorCodeBlockStart.text=將文本游標移至程式碼塊開始
action.EditorCodeBlockEnd.text=將文本游標移至程式碼塊結束
action.EditorCodeBlockStartWithSelection.text=在保持選區的情況下將文本游標移至程式碼塊開始
action.EditorCodeBlockEndWithSelection.text=在保持選區的情況下將文本游標移至程式碼塊結束
action.EditorMatchBrace.text=將文本游標移至符合的大括號
action.EditorDeleteToWordStart.text=刪除到詞首
action.EditorDeleteToWordStartInDifferentHumpsMode.text=在不同的 \\"CamelHumps\\" 模式下刪除到詞首
action.EditorDeleteToWordEnd.text=刪除到詞尾
action.EditorDeleteToWordEndInDifferentHumpsMode.text=在不同的 \\"CamelHumps\\" 模式下刪除到詞尾
action.EditorDeleteLine.text=刪除行
action.EditorKillToWordStart.text=終止至詞首
action.EditorKillToWordEnd.text=終止至詞尾
action.EditorKillRegion.text=終止所選區域
action.EditorKillRingSave.text=儲存至終止環
action.EditorDuplicate.text=重複行或選區
action.EditorDuplicateLines.text=重複整行
action.EditorSortLines.text=排序行
action.EditorReverseLines.text=反轉行
action.EditorSelectWord.text=擴展選區
action.EditorUnSelectWord.text=收縮選區
group.EditorBidiTextDirection.text=雙向文本基礎方向
group.EditorBidiTextDirection.description=混合 LTR/RTL 文本的主要方向
action.EditorSetContentBasedBidiTextDirection.text=基於內容
action.EditorSetContentBasedBidiTextDirection.description=方向由初始字符決定
action.EditorSetLtrBidiTextDirection.text=左到右
action.EditorSetRtlBidiTextDirection.text=右到左
action.EditorToggleInsertState.text=切換插入/覆蓋
action.EditorToggleColumnMode.text=列選擇模式(_M)
action.EditorToggleColumnMode.description=在當前編輯器中切換列選擇模式
action.EditorToggleShowWhitespaces.text=顯示空白(_O)
action.EditorToggleShowWhitespaces.description=在當前編輯器中切換顯示空白
action.EditorToggleShowIndentLines.text=顯示縮排參考線(_O)
action.EditorToggleShowIndentLines.description=在當前編輯器中切換顯示縮排參考線
action.EditorToggleShowBreadcrumbs.text=顯示路徑導航
action.EditorToggleShowBreadcrumbs.description=在當前編輯器中切換顯示路徑導航欄
action.EditorToggleShowLineNumbers.text=顯示行號(_I)
action.EditorToggleShowLineNumbers.description=在當前編輯器中切換顯示行號
action.EditorToggleShowGutterIcons.text=顯示間距圖標 (_O)
action.EditorToggleShowGutterIcons.description=在當前編輯器中切換顯示間距圖標
action.EditorToggleUseSoftWraps.text=自動換行
action.EditorToggleUseSoftWraps.description=在當前編輯器中切換使用自動換行
action.EditorToggleUseSoftWrapsInPreview.text=自動換行預覽編輯器
action.EditorToggleUseSoftWrapsInPreview.description=在預覽編輯器中切換使用自動換行
action.RestoreFontPreviewTextAction.text=恢復預覽文本
action.fontEditorPreview.ToggleBoldFont.text=切換加粗的字體
action.EditorConsoleScrollToTheEnd.text=滾動到結尾
action.EditorIncreaseFontSize.text=增大字體大小
action.EditorDecreaseFontSize.text=減小字體大小
action.ViewImportPopups.text=顯示匯入彈出視窗
action.ViewImportPopups.description=在當前檔案中切換顯示匯入彈出視窗
action.EditorScrollToCenter.text=滾動到中心
action.EditorToggleCase.text=切換大小寫
action.EditorJoinLines.text=連接行
action.EditorSelectLine.text=擴展行選區
action.EditorSelectSingleLineAtCaret.text=選擇文本游標處的一行
action.EditorSplitLine.text=拆分行
action.EditorStartNewLine.text=開始新行
action.EditorStartNewLineBefore.text=在當前位置之前開始新行
action.EditorCompleteStatement.text=補全當前語句
action.ExpandAll.text=全部展開
action.CollapseAll.text=全部摺疊
action.ExportToTextFile.text=匯出到文本檔案
action.ExpandTreeNode.text=展開樹節點
action.CollapseTreeNode.text=摺疊樹節點
action.FullyExpandTreeNode.text=完全展開樹節點
group.GenerateGroup.text=生成(_G)
action.GenerateTestMethod.text=測試方法
action.GenerateSetUpMethod.text=SetUp 方法
action.GenerateBeforeClassMethod.text=BeforeClass 方法
action.GenerateTearDownMethod.text=TearDown 方法
action.GenerateAfterClassMethod.text=AfterClass 方法
action.GenerateDataMethod.text=參數方法
action.GenerateConstructor.text=構造函數
action.GenerateConstructor.description=生成構造函數
action.GenerateCreateUI.text=createUI(...)
action.GenerateCreateUI.description=生成 createUI(...)
action.GenerateGetter.text=Getter
action.GenerateGetter.description=生成 getter
action.GenerateSetter.text=Setter
action.GenerateSetter.description=生成 setter
action.GenerateGetterAndSetter.text=Getter 和 Setter
action.GenerateGetterAndSetter.description=生成 getter 和 setter
action.GenerateEquals.text=equals() 和 hashCode()
action.GenerateEquals.description=生成 equals() 和 hashCode()
action.OverrideMethods.text=覆寫方法(_O)…
action.OverrideMethods.description=在當前類中覆寫基類方法
action.ImplementMethods.text=實作方法(_I)…
action.ImplementMethods.description=在當前類中實作基接口/類方法
action.DelegateMethods.text=委託方法...(_D)
action.DelegateMethods.description=為欄位/getter 生成委託方法
action.GenerateSuperMethodCall.text=super 方法調用
action.GenerateSuperMethodCall.description=生成 super 方法調用
action.NextDiff.text=下一個差異
action.NextDiff.description=移至下一個差異
action.PreviousDiff.text=上一個差異
action.PreviousDiff.description=移至上一個差異
action.Diff.NextConflict.text=下一個衝突
action.Diff.NextConflict.description=移至下一個未解決的衝突
action.Diff.PreviousConflict.text=上一個衝突
action.Diff.PreviousConflict.description=移至上一個未解決的衝突
action.GotoChangedFile.text=轉到更改的檔案…
action.GotoChangedFile.description=按名稱快速導航到更改的檔案
action.Refresh.text=刷新(_E)
action.CheckinProject.text=提交(_I)…
action.CheckinFiles.text=提交檔案(_I)
action.CheckinFiles.description=提交選中的檔案或目錄
action.UpdateFiles.text=更新(_U)
action.CheckStatusForFiles.text=檢查狀態(_K)
action.Annotate.text=註解(_N)
action.Annotate.with.Blame.text=使用 Git 追溯註解(_N)
action.Annotate.synonym1=追溯
action.Annotate.description=顯示每行的最新修改日期和作者(也稱為“追溯”)
action.Compare.SameVersion.text=與同一個儲存庫版本進行比較(_Y)
action.Compare.LastVersion.text=與最新的儲存庫版本進行比較(_V)
action.Compare.Selected.text=與修訂比較(_C)…
group.NewGroup.text=新建(_N)
group.NewElement.text=新建(_N)
group.NewElementMenu.text=新建(_N)
group.NewElementInMenuGroup.text=新建(_N)
group.WeighingNewGroup.text=新建(_N)
action.NewClass.text=Java 類
action.NewFile.text=檔案
action.NewDir.text=目錄/軟體套件
action.NewFromTemplate.text=從模板
action.ImportModule.text=來自現有源的模組…
action.ProjectFromVersionControl.text=來自版本控制的專案…
action.ImportProject.text=來自現有源的專案…
action.SaveAsNewFormat.text=另存為基於目錄的格式…
action.JShell.Console.text=JShell 控制台…
action.JShell.Console.description=啟動 JShell 控制台
action.ChangesView.GroupBy.Module.text=模組
action.Actions.ActionsPlugin.GenerateToString.text=to_String()
action.Actions.ActionsPlugin.GenerateToString.description=生成 toString() 方法
action.DumpThreads.text=獲取執行緒轉儲
action.Debugger.ShowRelatedStack.text=顯示相關堆疊…
action.Debugger.ShowTypes.text=顯示類型
action.Debugger.AddSteppingFilter.text=添加步進篩選器…
action.Debugger.StepOutOfBlock.text=單步跳出程式碼塊
action.Debugger.CreateRenderer.text=創建…
action.Debugger.CreateRenderer.XDebuggerTreeInlayPopup.text=創建呈現器
action.Debugger.MuteRenderers.text=靜默呈現器
action.Debugger.AsyncStacks.text=異步堆疊跟踪
action.Debugger.SwitchToTheNextContext.text=切換到下一個停止的斷點
action.Debugger.CallTracer.text=跟踪調用
action.Debugger.ReloadFile.text=編譯並重新載入檔案
action.MemoryView.ShowInstancesFromDebuggerTree.text=顯示實例
action.Memory.CalculateRetainedSize.text=計算保留大小…
action.MemoryView.ShowAllocationStackTrace.text=跳轉到分配位置
action.MemoryView.ShowOnlyWithInstances.text=僅顯示實例
action.MemoryView.ShowOnlyTracked.text=僅顯示跟踪類
action.MemoryView.EnableTrackingWithClosedWindow.text=啟用具有隱藏記憶體檢視的跟踪
action.MemoryView.ShowInstances.text=顯示實例
action.MemoryView.ShowNewInstances.text=顯示新實例
action.MemoryView.JumpToTypeSource.text=跳轉到類型源
action.MemoryView.TrackingAction.NewInstancesTracking.text=跟踪新實例
action.Diff.ShowDiff.text=顯示差異
action.Diff.ShowDiff.description=比較檔案或修訂。
action.CompareTwoFiles.text=比較檔案(_F)
action.CompareTwoFiles.description=比較兩個所選檔案或資料夾
action.CompareFileWithEditor.text=與編輯器比較檔案(_M)
action.CompareFileWithEditor.description=將所選檔案與編輯器中的檔案進行比較
action.JumpToColorsAndFonts.text=跳轉到顏色和字體
action.JumpToColorsAndFonts.description=跳轉到文本游標處的顏色和字體選項
group.ViewAppearanceGroup.text=外觀(_A)

group.LocalHistory.text=本地歷史記錄(_H)
action.LocalHistory.ShowHistory.text=顯示歷史記錄(_H)
action.LocalHistory.ShowHistory.GoToAction.text=顯示本地歷史記錄
action.LocalHistory.ShowSelectionHistory.text=顯示選區的歷史記錄
action.LocalHistory.ShowSelectionHistory.GoToAction.text=顯示選中的本地歷史記錄
action.LocalHistory.PutLabel.text=放置標籤(_L)…

group.VcsGroups.text=_Git
group.VcsGlobalGroup.text=VCS 組
action.Vcs.UpdateProject.text=更新專案(_U)
group.VcsGroup.text=版本控制
group.VcsFileGroupPopup.text=版本控制組
group.FileMenu.text=檔案(_F)
action.NewProject.text=專案(_P)…
action.NewProject.description=從頭創建一個新項目
action.NewModule.text=模組(_M)…
action.NewModule.description=從頭創建新模組並將其添加到專案
action.ImportProject.description=為包含現有源的目錄創建專案結構或者轉換現有專案模型
action.ImportModule.description=從包含現有源的目錄或者現有專案模型匯入模組
action.OpenFile.text=打開(_O)…
action.OpenFile.description=在編輯器中打開專案或檔案
group.reopen.win.text=重新打開專案(_R)
group.reopen.mac.text=打開最近(_R)
group.$LRU.text=打開最近(_R)
group.$LRU.GoToAction.text=打開最近的專案
action.ManageRecentProjects.text=管理專案…
group.$LRU.description=最近打開專案的列表
action.CloseProject.text=關閉專案(_J)
action.CloseProject.description=關閉當前專案
action.CloseAllProjects.text=關閉所有專案
action.CloseAllProjects.description=關閉所有專案
action.CloseOtherProjects.text=關閉其他專案
action.CloseOtherProjects.description=關閉其他專案
action.ShowProjectStructureSettings.text=專案結構...
action.ShowProjectStructureSettings.description=配置專案結構
action.SaveAll.text=全部儲存(_S)
action.SaveAll.description=儲存所有檔案和設定
action.ExportSettings.text=匯出設定(_E)…
action.ExportSettings.description=匯出全域設定
action.ImportSettings.text=匯入設定…
action.ImportSettings.description=匯入全域設定
action.RestoreDefaultSettings.text=恢復預設設定…
action.RestoreDefaultSettings.description=將所有設定重置為其預設值
action.ExportToEclipse.text=匯出到 Eclipse…
action.ExportToEclipse.description=為每個模組創建 Eclipse 專案
action.Synchronize.text=從磁碟全部重新載入
action.Synchronize.description=檢測所有外部更改的檔案，並從磁碟重新載入
action.InvalidateCaches.text=清除快取...
action.InvalidateCaches.description=在下次啟動時強制重新構建所有快取和索引
action.RestartIde.text=重啟 IDE…
action.ExportToHTML.text=將檔案或選區匯出到 HTML(_H)…
action.ExportToHTML.MainMenu.text=將檔案或選區匯出到 HTML(_H)…
action.ExportToHTML.description=以 HTML 格式儲存檔案內容，包括語法顏色
action.Print.text=列印(_P)…
action.Print.description=列印檔案
action.Exit.text=退出(_X)
action.Exit.description=退出 IDE
group.EditMenu.text=編輯(_E)
group.FindMenuGroup.text=尋找(_F)
action.undo.text=撤消{0}(_U)
action.undo.description=撤消{0}
action.undo.description.empty=最後操作
action.redo.text=重做{0}(_R)
action.redo.description=重做{0}
action.redo.description.empty=最後的撤消操作
action.$Cut.text=剪下(_T)
action.$Cut.description=剪下到剪貼簿
action.$Copy.text=複製(_C)
action.$Copy.description=複製到剪貼簿
action.$SearchWeb.text=使用 Google 搜尋(_S)
action.$SearchWeb.description=使用 Google 搜尋選區
action.CopyUrl.text=複製 URL
action.CopyUrl.description=將文本游標下的 URL 複製到剪貼簿
action.CopyPaths.text=複製路徑(_O)
action.CopyPaths.description=將與所選檔案或目錄對應的路徑複製到剪貼簿
action.CopyReference.text=複製引用(_Y)
action.CopyReference.description=複製對所選類、方法、函數或所選檔案的相對路徑的引用
action.CopySettingsPath.text=複製設定路徑
action.CopySettingsPath.mac.text=複製首選項路徑
action.CopySettingsPath.description=複製選定可配置選項的相對路徑
action.CopyAsRichText.text=複製為富文本
action.CopyAsRichText.description=將選區複製到剪貼簿作為富文本(以 RTF 和 HTML 格式)
action.CopyAsPlainText.text=複製為純文本
action.CopyAsPlainText.description=將選區複製到剪貼簿作為純文本
group.Copy.Paste.Special.text=複製/貼上特殊
group.Copy.Paste.Special.description=複製/貼上特殊編輯器操作
action.$Paste.text=貼上(_P)
action.$Paste.description=從剪貼簿貼上
action.PasteMultiple.text=從歷史記錄貼上(_E)…
action.PasteMultiple.description=從最近的剪貼簿貼上
action.$SelectAll.text=全選(_A)
action.$SelectAll.description=全選
action.NewElement.text=新建(_N)…
action.NewElement.description=創建新的類、接口、檔案或目錄
action.NewElementSamePlace.text=在當前目錄新建(_N)…
action.NewElementSamePlace.description=在此目錄中創建新的類、接口、檔案或目錄
action.$Delete.text=刪除(_D)
action.$Delete.description=刪除所選條目
action.Find.text=尋找(_F)…
action.Find.description=在活動編輯器中尋找字串
action.Replace.text=取代(_R)…
action.Replace.description=使用另一個字串取代活動編輯器中的字串
action.FindNext.text=尋找下一個/移至下一個符合項(_N)
action.FindNext.MainMenu.text=尋找下一個符合項(_N)
action.FindNext.description=重複上一次尋找/取代操作，或移至所選文本的下一個符合項
action.FindPrevious.text=尋找上一個/移至上一個符合項(_V)
action.FindPrevious.MainMenu.text=尋找上一個符合項(_V)
action.FindPrevious.description=反向重複上一次尋找/取代操作，或移至所選文本的上一個符合項
action.FindWordAtCaret.text=尋找文本游標處的字
action.FindWordAtCaret.description=尋找文本游標處單詞的下一個符合項
action.ToggleFindInSelection.text=僅在選擇範圍內搜尋
action.IncrementalSearch.text=增量搜尋(_L)
action.IncrementalSearch.description=啟動增量搜尋(輸入時搜尋字串)，IntelliJ IDEA 6.0 實作。
action.FindUsages.text=尋找用法(_U)
action.FindUsages.description=尋找文本游標處符號的用法
action.ShowUsages.text=顯示用法(_S)
action.ShowUsages.description=顯示文本游標處符號的用法
action.ShowSettingsAndFindUsages.text=尋找用法設定…
action.ShowSettingsAndFindUsages.description=為“尋找用法”操作選擇範圍和編輯選項
action.FindUsagesInFile.text=在檔案中尋找用法(_I)
action.FindUsagesInFile.description=在活動編輯器中尋找文本游標處符號的用法
action.HighlightUsagesInFile.text=高亮顯示檔案中的用法(_H)
action.HighlightUsagesInFile.description=在活動編輯器中高亮顯示文本游標處符號的用法
action.HighlightUsagesInFile.not.ready=此用法搜尋需要索引，在索引構建之前無法執行
action.FindInPath.text=在檔案中尋找…
action.FindInPath.description=在多個檔案中尋找字串
action.FindInPath.synonym1=在路徑中尋找
action.ReplaceInPath.text=在檔案中取代(_A)…
action.ReplaceInPath.synonym1=在路徑中取代(_A)
action.ReplaceInPath.description=在多個檔案中使用另一個字串取代一個字串
group.ViewMenu.text=檢視(_V)
action.ViewToolBar.text=工具欄(_T)
action.ViewObsoleteToolbarAction.text=工具欄經典
action.ViewObsoleteNavBarAction.text=導航欄
action.ViewNewToolbarAction.text=工具欄
action.ViewToolBar.description=顯示/隱藏主工具欄
action.QuickPreview.text=快速預覽
action.ViewStatusBar.text=狀態欄(_S)
action.ViewStatusBar.description=顯示/隱藏狀態欄
group.ViewStatusBarWidgetsGroup.text=狀態欄微件(_W)
group.ViewToolbarNewGroup.text=主工具欄
group.ViewStatusBarWidgetsGroup.description=顯示/隱藏狀態欄微件
action.ViewMainMenu.text=主選單
action.ViewMainMenu.description=顯示/隱藏主菜單
action.ViewToolButtons.text=工具視窗
action.ViewToolButtons.description=顯示/隱藏工具視窗按鈕
action.ViewNavigationBar.text=導航欄(_V)
action.ViewNavigationBar.description=顯示/隱藏導航欄
action.ViewNavigationBar.NavBar.text=顯示導航欄
action.ViewMembersInNavigationBar.text=導航欄中的成員
action.ViewMembersInNavigationBar.description=在導航欄中顯示/隱藏宣告
action.ViewMembersInNavigationBar.NavBar.text=在導航欄中顯示成員
action.ViewInplaceComments.text=樹檢視中的詳細資訊
action.ViewInplaceComments.description=在樹檢視中顯示/隱藏額外資訊
action.FileStructurePopup.text=檔案結構(_I)
action.FileStructurePopup.description=當前檔案的彈出視窗結構，用於快速導航
action.ShowFilePath.text=檔案路徑(_P)
action.ShowFilePath.description=當前檔案的彈出視窗路徑，用於在外部檔案管理器中打開
action.ShowFilePath.file=檔案路徑(_P)
action.ShowFilePath.directory=目錄路徑(_P)
action.SelectIn.text=選擇(_L)…
action.SelectIn.description=在任意檢視下選擇當前的類或方法
action.FixDocComment.text=修正文檔註釋
action.FixDocComment.description=生成或修正當前上下文的文檔註釋
action.QuickJavaDoc.text=快速文檔(_D)
action.QuickJavaDoc.description=顯示包含文本游標處符號的文檔的彈出視窗
action.QuickImplementations.text=快速定義(_K)
action.QuickImplementations.description=顯示包含符號(及其實作)內容的彈出視窗
action.QuickTypeDefinition.text=快速類型定義
action.QuickTypeDefinition.description=顯示包含文本游標處符號的類型定義的彈出視窗
action.ToggleRenderedDocPresentation.text=切換渲染檢視
action.ToggleRenderedDocPresentation.description=在查看原始碼和文檔註釋的渲染表示之間切換
action.ToggleRenderedDocPresentationForAll.text=渲染所有文檔註釋
action.ToggleRenderedDocPresentationForAll.description=切換到所有文檔註釋的渲染檢視
action.ShowSiblings.text=顯示同級
action.ShowSiblings.description=顯示包含符號同級內容的彈出視窗
action.ParameterInfo.text=參數資訊(_P)
action.ParameterInfo.description=顯示文本游標處方法的參數
action.ToggleInlineHintsAction.text=切換參數名稱提示
action.ToggleInlineHintsAction.description=切換參數名稱提示
action.ToggleCompletionHintsAction.text=補全時顯示參數名稱提示
action.ShowParameterHintsSettings.text=提示設定…
action.ShowParameterHintsSettings.description=打開參數名稱提示設定
action.ExpressionTypeInfo.text=類型資訊(_E)
action.ExpressionTypeInfo.description=顯示所選表達式的類型
action.EditorContextInfo.text=上下文資訊(_C)
action.EditorContextInfo.description=不可見時，顯示當前方法或類宣告
action.ShowErrorDescription.text=錯誤描述(_R)
action.ShowErrorDescription.description=顯示文本游標處錯誤或警告的說明
action.EditSource.text=跳轉到原始碼(_J)
action.EditSource.description=打開所選條目的編輯器並使之獲得焦點
action.EditSourceInNewWindow.text=在新窗口中打開源
action.EditSourceInNewWindow.description=在新窗口打開所選條目的編輯器並使之獲得焦點
action.EditSourceInNewWindow.EditorTabPopup.text=將頁籤移動到新窗口
action.ViewSource.text=顯示源(_W)
action.ViewSource.description=打開所選條目的編輯器
action.ExternalJavaDoc.text=外部文檔(_X)
action.ExternalJavaDoc.description=打開包含所選條目文檔的瀏覽器

group.SwitcherAndRecentFiles.text=切換器(RecentFiles)操作
action.Switcher.text=切換器
action.SwitcherForward.text=選擇下一行
action.SwitcherBackward.text=選擇上一行
action.SwitcherRecentEditedChangedToggleCheckBox.text=切換僅更改的檔案
action.SwitcherIterateItems.text=迭代最近的檔案
action.SwitcherNextProblem.text=選擇下一個問題檔案
action.SwitcherPreviousProblem.text=選擇上一個問題檔案
action.RecentFiles.text=最近的檔案(_N)
action.RecentFiles.description=顯示最近查看檔案的列表
action.RecentChangedFiles.text=最近更改的檔案
action.RecentChangedFiles.description=顯示最近更改檔案的列表
action.RecentLocations.text=最近的位置
action.RecentLocations.description=顯示最近查看/更改的位置列表
action.QuickChangeScheme.text=快速切換方案(_Q)…
action.QuickChangeScheme.description=更改當前的程式碼樣式方案、顏色與字體方案、鍵盤映射或外觀
action.TypeHierarchy.text=類型層次結構(_H)
action.TypeHierarchy.description=瀏覽所選類的層次結構
action.MethodHierarchy.text=方法層次結構(_M)
action.MethodHierarchy.description=瀏覽所選方法的方法層次結構
action.CallHierarchy.text=調用層次結構(_Y)
action.CallHierarchy.description=瀏覽所選方法的調用層次結構
group.FoldingGroup.text=折疊
group.ExpandToLevel.text=展開到級別(_E)
action.ExpandToLevel1.text=_1
action.ExpandToLevel2.text=_2
action.ExpandToLevel3.text=_3
action.ExpandToLevel4.text=_4
action.ExpandToLevel5.text=_5
group.ExpandAllToLevel.text=全部展開到級別(_L)
action.ExpandAllToLevel1.text=_1
action.ExpandAllToLevel2.text=_2
action.ExpandAllToLevel3.text=_3
action.ExpandAllToLevel4.text=_4
action.ExpandAllToLevel5.text=_5
action.ExpandRegion.text=展開(_X)
action.ExpandRegion.description=展開文本游標處的折疊區域
action.ExpandRegionRecursively.text=遞歸展開(_R)
action.ExpandRegionRecursively.description=遞歸展開文本游標處的塊
action.CollapseRegion.text=摺疊(_C)
action.CollapseRegion.description=摺疊文本游標處的折疊區域
action.CollapseRegionRecursively.text=遞歸折疊(_A)
action.CollapseRegionRecursively.description=遞歸摺疊文本游標處的塊
action.ExpandAllRegions.text=全部展開(_E)
action.ExpandAllRegions.description=展開所有折疊區域(選區中)
action.CollapseAllRegions.text=全部摺疊(_A)
action.CollapseAllRegions.description=摺疊所有折疊區域(選區中)
action.ExpandDocComments.text=展開文檔註釋(_D)
action.ExpandDocComments.description=展開所有文檔註釋
action.CollapseDocComments.text=摺疊文檔註釋(_O)
action.CollapseDocComments.description=摺疊所有文檔註釋
action.CollapseSelection.text=折疊選區/移除區域(_S)
action.CollapseSelection.description=折疊所選塊
action.CollapseBlock.text=折疊程式碼塊(_B)
action.CollapseBlock.description=折疊當前程式碼塊
action.RecentChanges.text=最近的變更(_E)
group.GoToMenu.text=導航(_N)
action.SearchEverywhere.text=隨處搜尋
action.SearchEverywhereToolbar.text=隨處搜尋 
action.SearchEverywhereToolbarHotKey.text=隨處搜尋 {0}
action.SearchEverywhere.description=搜尋類、檔案、工具視窗、操作和偏好設定
action.SmartSelect.text=擴展選區
action.SmartUnSelect.text=收縮選區
action.GotoClass.text=類...(_C)
action.GotoClass.description=通過名稱快速導航到類
action.GotoFile.text=轉到檔案...
action.GotoFile.MainMenu.text=檔案(_F)…
action.GotoFile.description=通過名稱快速導航到檔案
action.GotoSymbol.text=轉到符號...
action.GotoSymbol.MainMenu.text=符號(_S)…
action.GotoSymbol.description=通過名稱快速導航到任意符號
action.GotoCustomRegion.text=自訂折疊…
action.GotoAction.text=尋找操作(_F)…
action.GotoAction.description=通過名稱快速導航到操作
action.GotoLine.text=轉到行:列…
action.GotoLine.MainMenu.text=行:列(_L)...
action.GotoLine.description=通過編號在編輯器中導航到某一行(和/或列)
action.GotoDeclarationOnly.text=轉到宣告
action.GotoDeclarationOnly.description=導航到文本游標處符號的宣告
action.GotoDeclaration.text=前往宣告或用法
action.GotoDeclaration.MainMenu.text=宣告或用例(_D)
action.GotoDeclaration.description=導航到文本游標處符號的宣告或顯示其用法
action.GotoImplementation.text=轉到實作(_M)
action.GotoImplementation.MainMenu.text=實作(_M)
action.GotoImplementation.description=導航到所選類或方法的實作
action.GotoNextElementUnderCaretUsage.text=下一個高亮顯示用例
action.GotoNextElementUnderCaretUsage.description=導航到下一個高亮的元素用法
action.GotoPrevElementUnderCaretUsage.text=轉到上一個高亮的元素用法
action.GotoPrevElementUnderCaretUsage.description=導航到上一個高亮的元素用法
action.GotoTypeDeclaration.text=轉到類型宣告
action.GotoTypeDeclaration.MainMenu.text=類型宣告(_T)
action.GotoTypeDeclaration.description=導航到文本游標處符號類型的宣告
action.GotoSuperMethod.text=轉到 Super 方法
action.GotoSuperMethod.MainMenu.text=super 方法(_U)
action.GotoSuperMethod.description=導航到當前方法覆寫或實作的方法的宣告
action.GotoTest.text=轉到測試
action.GotoTest.MainMenu.text=測試(_E)
action.GotoTest.description=導航到所選類的測試
action.GotoTestSubject.text=轉到測試主題(_E)
action.GotoTestSubject.MainMenu.text=測試物件(_E)
action.GotoTestSubject.description=導航到所選測試的物件
action.GotoNextError.text=下一個高亮顯示錯誤(_N)
action.GotoNextError.description=在活動編輯器中導航到下一個高亮顯示的錯誤
action.GotoPreviousError.text=上一個高亮顯示錯誤(_P)
action.GotoPreviousError.description=在活動編輯器中導航到上一個高亮顯示的錯誤
action.GotoRelated.text=相關符號(_R)…
action.GotoRelated.description=導航到一個相關或鏈接的符號
action.MethodDown.text=下一個方法(_E)
action.MethodDown.description=在活動編輯器中導航到下一個方法
action.MethodUp.text=上一個方法(_I)
action.MethodUp.description=在活動編輯器中導航到上一個方法
action.Back.text=後退(_B)
action.Back.description=撤消上次導航操作
action.Forward.text=前進(_W)
action.Forward.description=恢復上次撤消的導航操作
action.JumpToLastChange.text=最後編輯位置(_O)
action.JumpToLastChange.description=在最近的變更點中移動
action.JumpToNextChange.text=下一個編輯位置
action.JumpToNextChange.description=在最近的變更點中移動
action.PreviousOccurence.text=上一個符合項(_O)
action.PreviousOccurence.description=導航到上一個符合項
action.NextOccurence.text=下一個符合項(_X)
action.NextOccurence.description=導航到下一個符合項
action.VcsShowCurrentChangeMarker.text=文本游標下的變更(_H)
action.VcsShowCurrentChangeMarker.description=顯示當前所選變更的彈出視窗
action.VcsShowNextChangeMarker.text=下一個變更(_H)
action.VcsShowNextChangeMarker.description=轉到下一個變更
action.VcsShowPrevChangeMarker.text=上一個變更(_A)
action.VcsShowPrevChangeMarker.description=轉到上一個變更
group.CodeMenu.text=程式碼(_C)
action.SurroundWith.text=環繞方式(_S)…
action.SurroundWith.description=使用 if/while/try-catch 或其他結構環繞所選程式碼段
action.Generate.text=生成…
action.Generate.description=生成構造函數、getter 或 setter 方法等
action.Unwrap.text=解開/移除(_W)…
action.Unwrap.description=安全地解開或移除所選範圍
group.CodeCompletionGroup.text=程式碼補全(_C)
group.EditorToggleActions.text=活動編輯器
action.CodeCompletion.text=基本(_B)
action.CodeCompletion.description=補全程式碼
action.HippieCompletion.text=迴圈擴展詞(_E)
action.HippieCompletion.description=迴圈擴展詞
action.HippieBackwardCompletion.text=迴圈擴展詞(向後)(_E)
action.HippieBackwardCompletion.description=迴圈擴展詞(向後)
action.SmartTypeCompletion.text=類型符合
action.SmartTypeCompletion.description=基於預期類型補全程式碼
action.SmartTypeCompletion.synonym=SmartType
action.ClassNameCompletion.text=第二基本補全
action.ClassNameCompletion.description=與雙擊基本補全快捷鍵相同(可用於補全非匯入類名)
action.InsertLiveTemplate.text=插入實時模板(_T)…
action.InsertLiveTemplate.description=顯示以指定前綴開頭的實時模板的彈出視窗列表
action.ExpandLiveTemplateByTab.text=按 Tab 展開實時模板
action.ExpandLiveTemplateCustom.text=展開實時模板/Emmet 縮寫
action.ExpandLiveTemplateCustom.description=使用在編輯器中鍵入的前綴調用綁定到 '自訂快捷鍵' 的實時模板
action.SurroundWithLiveTemplate.text=使用實時模板環繞(_P)…
action.SurroundWithLiveTemplate.description=使用一個模板環繞選區
action.CommentByLineComment.text=使用行註釋進行註釋(_L)
action.CommentByLineComment.description=使用行註釋註釋/取消註釋當前行或所選塊
action.CommentByBlockComment.text=使用塊註釋進行註釋(_B)
action.CommentByBlockComment.description=使用塊註釋註釋/取消程式碼
action.ReformatCode.text=重新格式化程式碼(_R)
action.ReformatCode.description=重新格式化程式碼
action.ReformatCode.synonym1=格式程式碼
action.AutoIndentLines.text=自動縮排行(_A)
action.AutoIndentLines.description=根據程式碼樣式設定縮排當前行或所選塊
action.OptimizeImports.text=優化 import(_Z)
action.OptimizeImports.description=移除未使用的 import 並重新排列/重新組織 import
action.RearrangeCode.text=重新排列程式碼
action.RearrangeCode.description=重新排列程式碼
action.ShowReformatFileDialog.text=重新格式化檔案...
action.ShowRecentTests.text=最近的測試
action.MoveStatementDown.text=向下移動語句(_W)
action.MoveStatementDown.description=將所選語句向下移動一行
action.MoveStatementUp.text=向上移動語句(_U)
action.MoveStatementUp.description=將所選語句向上移動一行
action.MoveElementLeft.text=向左移動元素
action.MoveElementLeft.description=將當前元素移至包含元素列表的上一個位置
action.MoveElementRight.text=向右移動元素
action.MoveElementRight.description=將當前元素移至包含元素列表的下一個位置
action.MoveLineDown.text=下移行(_W)
action.MoveLineDown.description=將所選行向下移動一行
action.MoveLineUp.text=上移行(_U)
action.MoveLineUp.description=將所選行向上移動一行
group.AnalyzeMenu.text=分析(_Z)
action.CodeCleanup.text=程式碼清理(_C)…
action.CodeCleanup.description=執行清理檢查並套用快速修復
action.SilentCodeCleanup.text=靜默程式碼清理
action.SilentCodeCleanup.description=執行清理檢查並使用當前檢查配置檔案套用快速修復
action.InspectCode.text=檢查程式碼(_I)…
action.InspectCode.description=檢查程式碼
action.InferNullity.text=推斷可空性...(_N)
action.InferNullity.description=推斷可空性
action.ViewOfflineInspection.text=查看離線檢查結果(_O)…
action.ViewOfflineInspection.description=載入離線檢查結果
action.ShowPackageDeps.text=分析依賴關係(_D)…
action.ShowPackageDeps.MainMenu.text=依賴項(_D)…
action.ShowPackageDeps.description=瀏覽所選分析項所依賴的程式碼
action.ShowBackwardPackageDeps.text=分析向後依賴關係(_B)…
action.ShowBackwardPackageDeps.MainMenu.text=向後依賴關係(_B)…
action.ShowBackwardPackageDeps.description=瀏覽使用的程式碼所選分析條目
action.ShowPackageCycles.text=分析迴圈依賴關係(_C)…
action.ShowPackageCycles.MainMenu.text=迴圈依賴關係(_C)…
action.ShowPackageCycles.description=瀏覽迴圈中使用的程式碼所選分析條目
action.ShowModulesDependencies.text=分析模組依賴關係(_M)…
action.ShowModulesDependencies.MainMenu.text=模組依賴項(_M)...
action.ShowModulesDependencies.description=顯示專案中模組之間的依賴關係
action.ShowDependenciesOnTarget.text=分析指定目標上的依賴項
action.ShowDependenciesOnTarget.MainMenu.text=指定目標上的依賴項
action.GenerateModuleDescriptors.text=生成 module-info 描述符
action.GenerateModuleDescriptors.description=為專案中的所有模組 module-info 檔案 (適用於 Java 9 及更高版本)
action.Unscramble.text=分析堆疊跟踪或執行緒轉儲(_S)…
action.Unscramble.description=打開包含可導航堆疊跟踪或執行緒轉儲的控制台
action.IdeScriptingConsole.text=IDE 腳本控制台
action.IdeScriptingConsole.description=打開 IDE 腳本控制台
action.NewScratchFile.text=臨時檔案
action.NewScratchFile.text.with.new=新建臨時檔案
action.NewScratchFile.description=與所選語言創建新的臨時檔案
action.NewScratchBuffer.text=新建臨時緩衝區
action.NewScratchBuffer.description=創建新的臨時緩衝區或重用現有的臨時緩衝區
action.Scratch.ChangeLanguage.text=更改檔案語言
action.Scratch.ChangeLanguage.description=更改臨時檔案語言
group.RefactoringMenu.text=重構(_R)
action.RenameElement.text=重命名(_R)…
action.RenameElement.description=重命名所選符號並更正所有引用
action.ChangeSignature.text=更改簽名(_G)…
action.ChangeSignature.description=更改所選方法或類的簽名，並更正所有引用
action.ChangeTypeSignature.text=類型遷移(_Y)…
action.ChangeTypeSignature.description=更改方法、欄位、參數、變數或類類型實參的返回類型的類型，並更正所有引用
action.MakeStatic.text=設為 static(_T)…
action.MakeStatic.description=將方法或內部類轉換為 static 並更正所有引用
action.ConvertToInstanceMethod.text=轉換為實例方法(_O)…
action.ConvertToInstanceMethod.description=將 static 方法轉換為實例方法並更正所有引用
action.Move.text=移動(_M)…
action.Move.description=將選中類、方法、包或 static 成員移動到另一個軟體套件或類，並更正所有引用
action.CopyElement.text=複製(_O)…
action.CopyElement.description=創建所選類、檔案或目錄的副本
action.SafeDelete.text=安全刪除(_D)…
action.SafeDelete.description=刪除所選類、方法或欄位，並檢查使用
action.ExtractMethod.text=提取方法(_M)…
action.ExtractMethod.description=將所選程式碼段轉換為一個方法
action.MethodDuplicates.text=尋找並取代程式碼重複項(_C)…
action.MethodDuplicates.field.text=尋找欄位重複項並取代為引用…
action.MethodDuplicates.method.text=尋找方法重複項並取代為調用…
action.MethodDuplicates.description=尋找所選範圍內可以轉換為所選方法/常數的調用的程式碼
action.InvertBoolean.text=反轉布林值(_B)…
action.InvertBoolean.description=使方法返回值或變數包含相反的值並更正引用
action.IntroduceParameterObject.text=引入參數物件(_J)…
action.IntroduceParameterObject.description=使用物件取代方法參數列表
action.ExtractClass.text=提取委託(_D)…
action.ExtractClass.description=提取委託
action.IntroduceVariable.text=引入變數(_V)…
action.IntroduceVariable.description=將所選表達式的結果放入變數中
action.IntroduceField.text=引入欄位(_F)…
action.IntroduceField.description=將所選表達式的結果放入欄位中
action.IntroduceConstant.text=引入常數(_C)…
action.IntroduceConstant.description=將所選表達式取代為常數
action.IntroduceParameter.text=引入參數(_P)…
action.IntroduceParameter.description=將所選表達式轉換為方法參數
action.IntroduceFunctionalParameter.text=引入功能參數(_L)…
action.IntroduceFunctionalParameter.description=通過調用新的函數方法參數來取代所選的語句
action.IntroduceFunctionalVariable.text=引入函數變數...
action.IntroduceFunctionalVariable.description=通過調用新的函數變數來取代所選的語句
action.ExtractInterface.text=提取接口(_I)…
action.ExtractInterface.description=從所選類提取接口
action.ExtractModule.text=提取模組...(_M)
action.ExtractModule.description=從所選類提取模組
action.ExtractSuperclass.text=提取超類(_U)…
action.ExtractSuperclass.description=從所選類提取超類
group.IntroduceActionsGroup.text=提取/引入(_X)
action.TurnRefsToSuper.text=盡可能使用接口(_W)…
action.TurnRefsToSuper.description=將類的用法更改為其超類或接口的用法
action.MembersPullUp.text=向上拉取成員(_L)…
action.MembersPullUp.description=將類成員拉取至超類或實作的接口
action.MemberPushDown.text=向下推送成員(_S)…
action.MemberPushDown.description=將類成員向下推送到直接繼承子類
action.InheritanceToDelegation.text=將繼承取代為委託(_I)…
action.InheritanceToDelegation.description=將繼承取代為委託
action.RenameFile.text=重命名檔案…
action.RenameFile.description=重命名所選檔案
action.Inline.text=內聯(_N)…
action.Inline.description=內聯所選方法或變數
action.AnonymousToInner.text=將匿名轉換成內部(_Y)…
action.AnonymousToInner.description=將匿名類轉換為內部類
action.EncapsulateFields.text=封裝欄位(_E)…
action.EncapsulateFields.description=使用存取器方法取代所選類中欄位的直接存取
action.ReplaceMethodWithMethodObject.text=用方法物件取代方法(_j)...
action.ReplaceMethodWithMethodObject.description=將方法轉換為自己的物件，以便所有參數都成為該物件上的欄位
action.Generify.text=將原始類型轉換為泛型…
action.Generify.description=轉換程式碼以使用泛型類型
action.Migrate.text=遷移…
action.Migrate.description=打開遷移對話框
action.ExtractInclude.text=包含檔案(_I)…
action.ExtractInclude.description=將所選程式碼段轉換為包含的檔案
group.BuildMenu.text=構建(_B)
action.CompileProject.text=重新構建專案(_R)
action.CompileProject.description=重新編譯專案中的所有檔案
action.CompileDirty.text=構建專案(_P)
action.CompileDirty.description=編譯專案中的所有修改和依賴檔案
action.BuildArtifact.text=構建工件…
action.BuildArtifact.description=選擇並構建專案中配置的工件
action.MakeModule.text=構建模組(_M)
action.MakeModule.description=編譯模組中的所有修改和依賴檔案
action.Compile.text=重新構建(_E)
action.CompileFile.text=重新編譯(_E)
action.Compile.description=強制重新編譯所選模組、檔案或軟體套件
action.DebugBuildProcess.text=調試構建過程
action.DebugBuildProcess.description=如果啟用，構建過程將在啟動時等待調試連接
group.BuildArtifactsGroup.text=構建工件
group.RunMenu.text=執行(_U)
group.RunnerActions.text=執行/調試
action.editRunConfigurations.text=編輯配置(_R)…
action.editRunConfigurations.description=打開“編輯執行/調試配置”對話框
action.Stop.text=停止
action.Stop.description=停止進程
action.StopBackgroundProcesses.text=停止背景進程...
action.StopBackgroundProcesses.description=停止背景進程
action.Hotswap.text=重新載入已更改的類(_A)
action.Hotswap.description=將所有更改的類重新載入到被調試的應用程式中 (熱插拔)
action.StepOver.text=步過(_O)
action.StepOver.description=單步執行至此檔案中的下一行
action.StepInto.text=步入(_I)
action.StepInto.description=單步執行至已執行的下一行
action.SmartStepInto.text=智能步入(_P)
action.SmartStepInto.description=單步進入特定方法
action.StepOut.text=步出(_T)
action.StepOut.description=單步執行至從此方法返回後執行的第一行
action.ForceStepOver.text=強制步過(_V)
action.ForceStepOver.description=步過，在步進前禁用所有斷點。
action.ForceStepInto.text=強制步入(_N)
action.ForceStepInto.description=步入，忽略庫、構造函數等的步進篩選器。
action.RunToCursor.text=執行到游標處(_C)
action.RunToCursor.description=跳轉到文本游標所在的行
action.ForceRunToCursor.text=強制執行到游標(_S)
action.ForceRunToCursor.description=執行到文本游標所在的行，忽略任何斷點
action.Debugger.PopFrame.text=丟幀(_F)
action.Debugger.PopFrame.description=將執行點移回方法調用，從堆疊中丟棄當前的方法幀
action.Debugger.ForceEarlyReturn.text=強制返回
action.Debugger.ForceEarlyReturn.description=強制方法在到達 return 語句之前返回
action.Debugger.ThrowException.text=拋出異常
action.Debugger.ThrowException.description=拋出一個異常
action.Debugger.ShowLibraryFrames.text=顯示/隱藏庫框架
action.XDebugger.PinToTop.text=固定至頂部
action.MemoryView.SwitchUpdateMode.text=在調試器停止時更新已載入的類
action.MemoryView.SwitchUpdateMode.description=在調試器暫停時載入類 (可能會增加調試器步進的開銷)
action.MemoryView.ShowOnlyWithDiff.text=僅顯示非零差異
action.Pause.text=暫停程序(_P)
action.Pause.description=掛起程序執行並啟用調試
action.Resume.text=恢復程序(_G)
action.Resume.description=恢復程序執行
action.EvaluateExpression.text=評估表達式(_X)…
action.EvaluateExpression.description=評估任意表達式
action.QuickEvaluateExpression.text=快速評估表達式(_Q)
action.QuickEvaluateExpression.description=評估所選表達式
action.ShowExecutionPoint.text=顯示執行點(_X)
action.ShowExecutionPoint.description=顯示當前程序執行點
action.Debugger.RestoreBreakpoint.text=恢復斷點
action.Debugger.RestoreBreakpoint.description=恢復上次刪除的斷點
action.ToggleLineBreakpoint.text=切換行斷點(_L)
action.ToggleLineBreakpoint.description=切換文本游標處的行斷點
action.ToggleLineBreakpoint.MainMenu.text=行斷點(_L)
action.ToggleMethodBreakpoint.text=切換方法斷點(_M)
action.ToggleMethodBreakpoint.MainMenu.text=方法斷點(_M)
action.ToggleMethodBreakpoint.description=為文本游標處的方法切換方法斷點
action.ToggleFieldBreakpoint.text=切換欄位觀察點(_F)
action.ToggleFieldBreakpoint.MainMenu.text= 欄位觀察點
action.ToggleFieldBreakpoint.description=為文本游標處的欄位切換欄位觀察點
action.ToggleBreakpointEnabled.text=切換斷點啟用狀態(_B)
action.ToggleBreakpointEnabled.description=啟用/禁用當前行的斷點
action.ToggleTemporaryLineBreakpoint.text=切換臨時行斷點
action.ToggleTemporaryLineBreakpoint.MainMenu.text=臨時行斷點
action.ToggleTemporaryLineBreakpoint.description=切換文本游標處的臨時行斷點
action.ViewBreakpoints.text=查看斷點(_K)…
action.ViewBreakpoints.description=查看和管理所有斷點和觀察點
action.EditBreakpoint.text=編輯斷點
action.ExportThreads.text=匯出執行緒(_H)…
action.ExportThreads.description=將所有執行緒資訊儲存到文本檔案或剪貼簿
action.Runner.RestoreLayout.text=恢復預設布局
action.Runner.RestoreLayout.description=將調試器會話的可視元素恢復為預設狀態
group.Runner.Layout.text=布局
group.Runner.Layout.description=布局配置
action.Runner.CloseView.text=關閉
action.Runner.CloseView.description=關閉檢視
action.Runner.CloseOtherViews.text=關閉其他
action.Runner.CloseOtherViews.description=關閉其他檢視
action.Runner.CloseAllViews.text=關閉所有
action.Runner.CloseAllViews.description=關閉所有檢視
action.Runner.CloseAllUnpinnedViews.text=關閉所有未固定的
action.Runner.CloseAllUnpinnedViews.description=關閉所有未固定的頁籤
action.Runner.FocusOnStartup.text=在啟動時獲取焦點
action.Runner.FocusOnStartup.description=當 UI 顯示時預設切換到該檢視
action.Debugger.FocusOnBreakpoint.text=在斷點時獲取焦點
action.Debugger.FocusOnBreakpoint.description=到達斷點時預設切換到此檢視
group.ToolsMenu.text=工具(_T)
action.SaveAsTemplate.text=儲存為實時模板(_I)…
action.SaveAsTemplate.description=將所選文本儲存為實時模板
action.SaveFileAsTemplate.text=將檔案另存為模板(_L)…
action.SaveFileAsTemplate.description=將當前檔案另存為模板
action.GenerateJavadoc.text=生成 JavaDoc(_D)…
action.GenerateJavadoc.description=執行 JavaDoc 工具
group.Macros.text=巨集(_S)
group.Macros.description=查看、更改、錄製、執行巨集
group.StandardMacroActions.text=標準巨集操作
action.PlaybackLastMacro.text=回放上一個巨集(_Y)
action.PlaybackLastMacro.description=播放上次使用的巨集
action.StartStopMacroRecording.text=啟動/停止巨集錄製(_R)
action.StartStopMacroRecording.description=啟動/停止新巨集錄製
action.EditMacros.text=編輯巨集(_E)
action.EditMacros.description=配置現有巨集
action.PlaySavedMacrosAction.text=播放儲存的巨集…
action.PlaySavedMacrosAction.description=播放儲存的巨集
group.MacrosGroup.text=巨集操作
action.ValidateXml.text=驗證(_V)
action.ValidateXml.description=驗證當前的 XML 檔案
action.GenerateDTD.text=從 XML 檔案生成 DTD(_X)
action.EmmetPreviousEditPoint.text=上一個 Emmet 編輯點
action.EmmetPreviousEditPoint.description=轉到上一個 Emmet 編輯點
action.EmmetNextEditPoint.text=下一個 Emmet 編輯點
action.EmmetNextEditPoint.description=轉到下一個 Emmet 編輯點
action.EmmetUpdateTag.text=使用 Emmet 更新標記
action.EmmetUpdateTag.description=使用 Emmet 縮寫更新現有 HTML 標記
action.EmmetPreview.text=Emmet 預覽
action.EmmetPreview.description=顯示 Emmet 縮寫的預覽
action.SurroundWithEmmet.text=使用 Emmet 環繞
action.SurroundWithEmmet.description=使用 Emmet 縮寫環繞選定程式碼
group.Emmet.text=Emmet
group.OpenInBrowserEditorContextBarGroupAction.description=打開位置…
action.OpenInBrowser.text=在預設瀏覽器中打開(_B)
action.OpenInBrowser.description=在預設瀏覽器中打開所選檔案
action.EscapeEntities.text=編碼 XML/HTML 特殊字符
action.EscapeEntities.description=使用實體轉義 XML/HTML 特殊字符
action.GenerateXmlTag.text=XML 標記…
action.GenerateXmlTag.description=根據架構資訊生成新的 XML 標記
group.NewXmlDescriptor.text=XML 配置檔案
group.NewXml.text=XML
action.DomCollectionControl.Remove.text=移除
action.DomCollectionControl.Edit.text=編輯
action.DomCollectionControl.Add.text=添加
action.DomElementsTreeView.DeleteElement.text=刪除元素
action.DomElementsTreeView.AddElement.text=插入元素
action.DomElementsTreeView.GotoDomElementDeclarationAction.text=轉到元素
action.Document2XSD.text=從 XSD 架構生成 XML 文檔…
action.XSD2Document.text=從 XML 檔案生成 XSD 架構…
group.ExternalToolsGroup.text=外部工具
action.PsiViewer.text=查看 PSI 結構(_V)…
action.PsiViewerForContext.text=查看當前檔案的 PSI 結構(_R)…
action.DebugListen.text=拋出調試異常
action.VirtualFileInfo.text=虛擬檔案資訊
action.Merge3Files.text=合併
action.DecodeBytesAction.text=解碼位元組…
action.ReloadProjectAction.text=重新載入專案
action.ShowMainMenu.text=顯示主菜單
action.DumpInspectionDescriptions.text=轉儲檢查描述
action.DumpIntentionsDescriptions.text=轉儲意圖描述
group.WindowMenu.text=視窗(_W)
group.ToolWindowsGroup.text=工具視窗(_T)
group.BackgroundTasks.text=背景任務
action.ShowProcessWindow.text=顯示
action.ShowProcessWindow.description=顯示/隱藏背景任務視窗
action.ShowProcessWindow.double.click=點擊以顯示/隱藏背景任務視窗
action.AutoShowProcessWindow.text=自動顯示
action.AutoShowProcessWindow.description=啟動任何進程時顯示背景任務視窗
action.StoreDefaultLayout.text=將當前布局存儲為預設(_Y)
action.StoreDefaultLayout.description=將當前布局存儲為預設
action.MinimizeCurrentWindow.text=最小化
action.MinimizeCurrentWindow.description=最小化當前視窗
action.ZoomCurrentWindow.text=縮放
action.ZoomCurrentWindow.description=縮放當前視窗
action.TogglePresentationMode.text.enter=進入演示模式
action.TogglePresentationMode.text.exit=退出演示模式
action.TogglePresentationMode.text=切換演示模式
action.TogglePresentationMode.description=切換演示模式
action.ToggleDistractionFreeMode.text=切換免打擾模式
action.ToggleDistractionFreeMode.description=切換免打擾模式
action.ToggleFullScreen.text.enter=進入全屏
action.ToggleFullScreen.text.exit=退出全屏
action.ToggleFullScreen.text=切換全屏模式
action.ToggleFullScreen.description=切換全屏模式
action.ToggleZenMode.text=切換 Zen 模式
action.ToggleZenMode.description=同時切換免打擾和全屏模式
action.RestoreDefaultLayout.text=恢復預設布局(_F)
action.RestoreDefaultLayout.description=恢復預設布局
action.HideActiveWindow.text=隱藏活動工具視窗(_D)
action.HideActiveWindow.description=隱藏活動工具視窗
action.HideSideWindows.text=隱藏本側工具視窗
action.HideSideWindows.description=隱藏本側所有視窗
action.HideAllWindows.text=隱藏所有工具視窗(_T)
action.HideAllWindows.description=隱藏所有工具視窗
action.PinToolwindowTab.text=固定活動工具視窗頁籤(_I)
action.PinToolwindowTab.description=固定活動工具視窗頁籤
action.JumpToLastWindow.text=跳轉到上一個工具視窗(_J)
action.JumpToLastWindow.description=啟用上一個聚焦的工具視窗
group.ActiveToolwindowGroup.text=活動工具視窗
group.TW.ViewModeGroup.text=檢視模式
action.DockPinnedMode.text=停靠固定(_P)
action.DockPinnedMode.description=使工具視窗停靠並固定
action.DockUnpinnedMode.text=停靠不固定(_U)
action.DockUnpinnedMode.description=使工具視窗停靠但焦點丟失時自動隱藏
action.UndockMode.text=取消停靠(_D)
action.UndockMode.description=使工具視窗滑動並在焦點丟失時自動隱藏
action.FloatMode.text=浮動(_F)
action.FloatMode.description=將工具視窗移動到單獨的對話框
action.WindowMode.text=視窗(_W)
action.WindowMode.description=將工具視窗移動到單獨的框架
action.TogglePinnedMode.text=固定模式(_P)
action.TogglePinnedMode.description=固定/取消固定活動工具視窗
action.ToggleDockMode.text=停靠模式(_E)
action.ToggleDockMode.description=停靠/取消停靠活動工具視窗
action.ToggleFloatingMode.text=浮動模式(_M)
action.ToggleFloatingMode.description=浮動/取消浮動活動工具視窗
action.ToggleWindowedMode.text=視窗化模式(_W)
action.ToggleWindowedMode.description=視窗化/取消視窗化活動工具視窗
action.ToggleSideMode.text=拆分模式
action.ToggleSideMode.description=開啟/關閉工具視窗拆分模式
action.ToggleContentUiTypeMode.text=頁籤分組
action.ShowToolbar.text=顯示工具欄
action.ToggleContentUiTypeMode.description=切換內容的標籤式/組合式顯示
action.RemoveStripeButton.text=從邊欄中移除
action.RemoveStripeButton.description=從邊欄移除工具視窗按鈕
action.ShowContent.text=顯示頁籤列表
action.ShowContent.description=顯示一個包含工具視窗頁籤列表的彈出視窗
action.ShowContent.views.text=顯示檢視列表
group.ResizeToolWindowGroup.text=調整大小
action.ResizeToolWindowLeft.text=延伸至左側
action.ResizeToolWindowLeft.description=將活動工具視窗延伸至左側
action.ResizeToolWindowRight.text=延伸至右側
action.ResizeToolWindowRight.description=將活動工具視窗延伸至右側
action.ResizeToolWindowUp.text=延伸至頂部
action.ResizeToolWindowUp.description=將活動工具視窗延伸至頂部
action.ResizeToolWindowDown.text=延伸至底部
action.ResizeToolWindowDown.description=將活動工具視窗延伸至底部
action.ResizeToolWindowMaximize.text=最大化工具視窗
action.ResizeToolWindowMaximize.text.alternative=恢復工具視窗大小
action.IncrementWindowWidth.text=增大寬度
action.DecrementWindowWidth.text=減小寬度
action.IncrementWindowHeight.text=增大高度
action.DecrementWindowHeight.text=減小高度
action.NextTab.text=選擇下一個頁籤(_X)
action.NextTab.description=啟用下一個頁籤
action.PreviousTab.text=選擇上一個頁籤(_L)
action.PreviousTab.description=啟用上一個頁籤
action.GoToTab.text=選擇頁籤 #{0}
action.GoToTab.description=啟用頁籤 #{0}
action.GoToLastTab.text=選擇最後一個頁籤
action.GoToLastTab.description=啟用最後一個頁籤
action.NextEditorTab.text=在多編輯器檔案中選擇下一個頁籤
action.PreviousEditorTab.text=在多編輯器檔案中選擇上一個頁籤
action.CloseActiveTab.text=關閉活動頁籤(_O)
action.CloseActiveTab.description=關閉活動工具視窗頁籤
action.PinActiveTab.text=固定活動頁籤(_I)
action.PinActiveTab.description=固定活動編輯器或工具視窗頁籤
action.PinActiveTabToggle.text=固定活動頁籤
action.PinActiveTabToggle.description=固定活動編輯器或工具視窗頁籤
action.PinActiveEditorTab.text=固定活動頁籤(_I)
action.PinActiveEditorTab.description=固定活動編輯器頁籤
action.CloseEditor.text=關閉活動編輯器(_C)
action.CloseEditor.description=關閉活動編輯器
action.CloseEditor.EditorPopup.text=關閉 (_C)
action.CloseEditor.EditorTabPopup.text=關閉(_C)
action.CloseAllEditors.text=關閉所有頁籤(_A)
action.CloseAllEditors.description=在活動頁籤組中關閉所有編輯視窗
action.CloseAllEditorsButActive.text=關閉其他頁籤(_O)
action.CloseAllEditorsButActive.description=除活動編輯視窗外關閉所有其他視窗
action.CloseAllUnmodifiedEditors.text=關閉未修改頁籤(_U)
action.CloseAllUnmodifiedEditors.description=關閉所有未修改的編輯視窗
action.CloseAllUnpinnedEditors.text=關閉所有未固定
action.CloseAllUnpinnedEditors.description=關閉所有未固定的編輯視窗
action.CloseAllToTheRight.text=關閉右側頁籤
action.CloseAllToTheRight.description=關閉右邊的所有編輯器
action.CloseAllToTheLeft.text=關閉左側頁籤
action.CloseAllToTheLeft.description=關閉左邊的所有編輯器
action.CloseAllReadonly.text=關閉所有唯讀頁籤
action.CloseAllReadonly.description=關閉具有唯讀檔案的所有編輯器
action.CloseContent.text=關閉頁籤(_C)
action.CloseContent.description=關閉當前焦點的內容
group.EditorTabsGroup.text=編輯器頁籤(_T)
action.CloseFirstNotification.text=關閉第一個
action.CloseAllNotifications.text=關閉所有
group.Notifications.text=通知
action.SplitVertically.text=向右拆分
action.SplitVertically.synonym=垂直拆分
action.SplitVertically.description=將編輯器區域拆分為 2 個頁籤組，然後將當前檔案移至右側組
action.SplitHorizontally.text=向下拆分
action.SplitHorizontally.synonym=水平拆分
action.SplitHorizontally.description=將編輯器區域拆分為 2 個頁籤組，然後將當前檔案移至底部組
action.OpenInRightSplit.description=將編輯器區域拆分為 2 個頁籤組，然後將當前檔案打開到右側組
action.OpenInRightSplit.text=在右側拆分部分打開
action.StretchSplitToTop.text=將編輯器延伸至頂部
action.StretchSplitToTop.description=將拆分的編輯器延伸至頂部
action.StretchSplitToLeft.text=將編輯器延伸至左側
action.StretchSplitToLeft.description=將拆分的編輯器延伸至左側
action.StretchSplitToBottom.text=將編輯器延伸至底部
action.StretchSplitToBottom.description=將拆分的編輯器延伸至底部
action.StretchSplitToRight.text=將編輯器延伸至右側
action.StretchSplitToRight.description=將拆分的編輯器延伸至右側
action.MoveTabRight.text=拆分並右移
action.MoveTabRight.description=將編輯器區域拆分為 2 個頁籤組，然後將當前頁籤移至右側組並關閉左側編輯器
action.MoveTabDown.text=拆分並下移
action.MoveTabDown.description=將編輯器區域拆分為 2 個頁籤組，然後將當前頁籤移至底部組並關閉頂部編輯器
action.SplitChooser.text=通過選擇器以拆分方式打開…
action.SplitChooser.description=允許在編輯器中交互選擇拆分位置，並在該處打開/移動所選檔案
action.SplitChooser.NextWindow.text=下一個拆分
action.SplitChooser.PreviousWindow.text=上一個拆分
action.SplitChooser.Exit.text=退出選擇器
action.SplitChooser.Split.text=拆分
action.SplitChooser.Duplicate.text=複製
action.SplitChooser.SplitCenter.text=無拆分
action.SplitChooser.SplitTop.text=使用頂部拆分或向上切換
action.SplitChooser.SplitLeft.text=使用左拆分或左切換
action.SplitChooser.SplitDown.text=使用向下拆分或向下切換
action.SplitChooser.SplitRight.text=使用右拆分或右切換
action.ChangeSplitOrientation.text=更改拆分器方向(_R)
action.ChangeSplitOrientation.description=更改拆分器方向
action.Unsplit.text=取消拆分(_S)
action.Unsplit.description=取消拆分視窗
action.UnsplitAll.text=取消全部拆分(_N)
action.UnsplitAll.description=移除所有拆分器
action.NextSplitter.text=轉到下一個拆分器(_G)
action.NextSplitter.description=轉到下一個拆分視窗
action.PrevSplitter.text=轉到上一個拆分器
action.PrevSplitter.description=轉到上一個拆分視窗
action.NextProjectWindow.text=下一個專案視窗
action.NextProjectWindow.description=切換到下一個專案視窗
action.PreviousProjectWindow.text=上一個專案視窗
action.PreviousProjectWindow.description=切換到上一個專案視窗
group.OpenProjectWindows.text=打開專案視窗
group.HelpMenu.text=幫助(_H)
action.HelpTopics.text=幫助(_H)
action.HelpTopics.description=顯示幫助內容
action.ShowTips.text=每日小技巧(_T)
action.ShowTips.description=學習如何提高編碼效率。
action.DumpFeaturesAndTips.text=轉儲功能和提示資訊(_D)
action.DumpFeaturesAndTips.description=將有關功能和提示檔案的資訊複製到剪貼簿
action.ProductivityGuide.text=我的工作效率(_P)
action.ProductivityGuide.description=顯示工作效率功能使用統計
action.OnlineDocAction.text=入門指南(_G)
action.OnlineDocAction.description=顯示在線文檔
action.WhatsNewAction.text=最新變化(_N)
action.WhatsNewAction.description=了解此版本 IDE 中的新功能
action.Help.KeymapReference.text=鍵盤快捷鍵 PDF(_K)
action.Help.KeymapReference.description=打開帶有預設鍵盤映射參考卡的 PDF 檔案。
action.Help.JetBrainsTV.text=YouTube 上的產品
action.Help.JetBrainsTV.description=查看介紹 JetBrains 產品功能的簡短現場演示。
action.CheckForUpdate.text=檢查更新(_C)…
action.CheckForUpdate.description=檢查可用的 IDE 和套件更新
action.CheckForUpdate.WelcomeScreen.text=檢查更新
action.About.text=關於(_A)
action.About.description=顯示有關 IDE 的資訊
action.About.description.specialized=顯示有關 {0} 的資訊
group.OtherMenu.text=其他
group.OtherMenu.description=未正確註冊的操作
group.MainToolBar.text=主工具欄
group.Bookmarks.text=書籤
group.Bookmarks.Goto.text=轉到類型
group.Bookmarks.Toggle.text=切換類型

action.XDebugger.SetValue.text=設定值…
action.XDebugger.SetValue.XDebuggerTreeInlayPopup.text=設定值
action.XDebugger.SetValue.description=修改所選節點的值
action.XDebugger.CopyValue.text=複製值
action.XDebugger.CopyValue.description=將所選節點的值複製到剪貼簿
action.XDebugger.CompareValueWithClipboard.text=與剪貼簿比較值
action.XDebugger.CompareValueWithClipboard.description=將所選節點的值與剪貼簿文本進行比較
action.XDebugger.CopyName.text=複製名稱
action.XDebugger.CopyName.description=將所選節點的名稱複製到剪貼簿
action.XDebugger.JumpToSource.text=跳轉到原始碼
action.XDebugger.JumpToSource.description=打開所選條目的源
action.XDebugger.JumpToTypeSource.text=跳轉到類型源
action.XDebugger.JumpToTypeSource.description=打開所選值類型的源
action.XDebugger.Inspect.text=檢查…

action.Debugger.Tree.EvaluateInConsole.text=在控制台中評估

action.XDebugger.RemoveWatch.text=移除監視
action.XDebugger.RemoveAllWatches.text=移除所有監視
action.XDebugger.NewWatch.text=新建監視…
action.XDebugger.EditWatch.text=編輯…
action.XDebugger.CopyWatch.text=複製監視
action.XDebugger.MoveWatchUp.text=上移監視
action.XDebugger.MoveWatchDown.text=下移監視
action.XDebugger.SwitchWatchesInVariables.text=在變數頁籤中顯示監視
action.XDebugger.Inline.text=在編輯器中顯示變量值
action.XDebugger.Inline.description=在編輯器中顯示可用的調試器會話值
action.XDebugger.ToggleSortValues.text=按字母順序對變數進行排序
action.XDebugger.ToggleSortValues.description=在調試器檢視中按字母順序排列值
group.XDebugger.settings.text=設定

action.Debugger.AdjustArrayRange.text=調整範圍…
action.Debugger.FilterArray.text=篩選…
action.Debugger.ViewEditText.text=查看/編輯文本
action.Debugger.ViewText.text=查看文本
action.Debugger.ViewText.description=在單獨的窗格中查看所選節點的文本值
action.Debugger.EditCustomField.text=編輯…
action.Debugger.NewCustomField.text=新建類級別監視…
action.Debugger.RemoveCustomField.text=移除監視
action.Debugger.EditArrayFilter.text=編輯…
action.Debugger.RemoveArrayFilter.text=移除篩選器
action.Debugger.ShowReferring.text=顯示引用物件…
action.Debugger.CustomizeContextView.text=自訂資料檢視…
action.Debugger.CustomizeThreadsView.text=自訂執行緒檢視…
action.Debugger.EditFrameSource.text=EditFrameSource
action.Debugger.EditNodeSource.text=EditNodeSource
action.Debugger.ViewAsGroup.text=查看方式
action.Debugger.ResumeThread.text=恢復
action.Debugger.FreezeThread.text=掛起
action.Debugger.InterruptThread.text=中斷
action.Debugger.MarkObject.text=標記物件…
action.Debugger.MarkObject.unmark.text=取消標記物件
action.Debugger.MarkObject.description=標記/取消標記物件，以便可以在調試器檢視中直觀區分
action.Debugger.AddToWatch.text=添加到監視
action.Debugger.AddInlineWatch.text=添加內聯監視
action.Debugger.EvaluateInConsole.text=在控制台中評估
action.XDebugger.UnmuteOnStop.text=在會話完成時取消靜音斷點
action.Debugger.AutoRenderer.text=自動
group.EditorPopupMenu.text=編輯器彈出視窗選單
group.EditorPopupMenu.description=編輯器彈出視窗選單
group.EditorPopupMenu.GoTo.text=轉到
group.EditorPopupMenu.GoTo.description=轉到編輯器彈出視窗選單組
action.CompareClipboardWithSelection.text=與剪貼簿比較(_B)
action.CompareClipboardWithSelection.description=將當前選區與剪貼簿進行比較
action.ShowBlankDiffWindow.text=打開空白差異視窗
action.ShowBlankDiffWindow.synonym1=打開空的差異視窗
action.ShowBlankDiffWindow.synonym2=打開新的差異視窗
action.ShowBlankDiffWindow.description=並排打開兩個編輯器並比較他們的內容
action.ChangeColorScheme.text=編輯器配色方案
action.ChangeColorScheme.description=更改當前編輯器配色方案
action.ChangeCodeStyleScheme.text=程式碼樣式方案
action.ChangeCodeStyleScheme.description=更改當前程式碼樣式方案
action.ChangeKeymap.text=鍵盤映射
action.ChangeKeymap.description=更改當前鍵盤映射
action.ChangeLaf.text=主題
action.ChangeLaf.description=更改當前主題
action.ChangeView.text=檢視模式
action.ChangeView.description=更改檢視模式
action.ChangeInspectionProfile.text=錯誤高亮顯示
action.ChangeInspectionProfile.description=更改當前編輯器檢查配置檔案
action.MoveEditorToOppositeTabGroup.text=移至相反的組(_M)
action.MoveEditorToOppositeTabGroup.description=將編輯器移至相反的頁籤組
action.OpenEditorInOppositeTabGroup.text=在相反的組中打開(_O)
action.OpenEditorInOppositeTabGroup.description=在相反的頁籤組中打開此編輯器的副本
action.OpenModuleSettings.text=模組設定
action.ModuleSettings.text=模組設定(_S)
action.ModuleSettings.description=為所選模組打開設定對話框
group.MoveModuleToGroup.text=將模組移至組
group.MoveModuleToGroup.description=移動模組(_M)
action.AssociateWithFileType.text=與檔案類型關聯…
action.AssociateWithFileType.description=將所選檔案關聯到某種檔案類型
action.RestoreDefaultExtensionScripts.text=重置預設擴展
action.RestoreDefaultExtensionScripts.description=重置此目錄的捆綁擴展
action.SynchronizeCurrentFile.text=從磁碟重新載入
action.TypeHierarchy.Class.text=類層次結構
action.TypeHierarchy.Subtypes.text=子類型層次結構
action.TypeHierarchy.Supertypes.text=父類型層次結構
action.MethodHierarchy.ImplementMethodAction.text=實作方法
action.MethodHierarchy.ImplementMethodAction.description=實作方法(從方法層次結構)
action.MethodHierarchy.OverrideMethodAction.text=覆寫方法
action.MethodHierarchy.OverrideMethodAction.description=覆寫方法(從方法層次結構)
action.Vcs.MoveChangedLinesToChangelist.text=將行移到另一個變更列表…
action.Vcs.MoveChangedLinesToChangelist.description=將所選行中的變更移動到另一個變更列表…
action.Vcs.Diff.ExcludeChangedLinesFromCommit.text=將行包含在提交中
action.Vcs.Diff.IncludeOnlyChangedLinesIntoCommit.text=僅將這些行包含在提交中
action.Vcs.Diff.ShowDiffInEditorTab.text=在編輯器頁籤中顯示差異
action.Vcs.Diff.ShowDiffInNewWindow.text=在單獨的視窗中顯示差異
action.Vcs.RollbackChangedLines.text=回滾行
action.Vcs.RollbackChangedLines.description=回滾所選行中的變更
action.openAssertEqualsDiff.text=查看 assertEquals 差異
action.UsageView.Rerun.text=重新執行
action.UsageView.Rerun.description=重新執行搜尋
action.UsageView.Include.text=包含
action.UsageView.Include.description=將此用法包含到處理中
action.UsageView.Exclude.text=排除
action.UsageView.Exclude.description=將此用法從處理中排除
action.UsageView.Remove.text=移除
action.UsageView.Remove.description=將此用法從處理中移除
action.UsageView.ShowRecentFindUsages.text=最近的尋找用法(_E)
action.UsageView.ShowRecentFindUsages.description=選擇並重新執行最近的尋找用法
group.ShowRecentFindUsagesGroup.text=最近的尋找用法
group.ShowRecentFindUsagesGroup.description=選擇並重新執行最近的尋找用法

action.IntegrateFiles.text=集成
action.IntegrateFiles.description=集成所選檔案或目錄
action.Vcs.IntegrateProject.text=集成專案(_G)
action.Vcs.IntegrateProject.description=集成專案

action.ShowNavBar.text=跳轉到導航欄(_J)
action.ShowNavBar.ShortText=導航欄

group.ProjectView.ToolWindow.SecondaryActions.text=專案檢視選項
action.ProjectView.AbbreviatePackageNames.text=縮寫限定軟體套件名稱
action.ProjectView.AbbreviatePackageNames.description=以簡短形式顯示限定軟體套件名稱
action.ProjectView.AutoscrollFromSource.text=始終選擇打開的檔案
action.ProjectView.AutoscrollFromSource.description=選擇編輯器頁籤時，在專案檢視中選擇相應的檔案
action.ProjectView.AutoscrollToSource.text=一鍵打開檔案
action.ProjectView.AutoscrollToSource.description=選擇檔案後，將其打開進行編輯
action.ProjectView.OpenInPreviewTab.text=啟用預覽頁籤
action.ProjectView.CompactDirectories.text=壓縮目錄
action.ProjectView.CompactDirectories.description=如果第一個目錄僅包含第二個目錄，則將兩個類似的目錄合併到單個節點中
action.ProjectView.FlattenModules.text=平展模組
action.ProjectView.FlattenModules.description=以簡單列表顯示模組
action.ProjectView.FlattenPackages.text=平展軟體套件
action.ProjectView.FlattenPackages.description=以簡單列表顯示包
action.ProjectView.FoldersAlwaysOnTop.text=資料夾總在最前
action.ProjectView.FoldersAlwaysOnTop.description=單獨對檔案和資料夾排序
action.ProjectView.HideEmptyMiddlePackages.text=隱藏空的中間軟體套件
action.ProjectView.HideEmptyMiddlePackages.description=隱藏空的中間軟體套件
action.ProjectView.ManualOrder.text=手動排序
action.ProjectView.ManualOrder.description=手動對檔案排序
action.ProjectView.ShowExcludedFiles.text=顯示排除的檔案
action.ProjectView.ShowExcludedFiles.description=顯示排除的檔案
action.ProjectView.ShowLibraryContents.text=顯示庫內容
action.ProjectView.ShowLibraryContents.description=顯示庫內容
action.ProjectView.ShowMembers.text=顯示成員
action.ProjectView.ShowMembers.description=顯示類成員
action.ProjectView.ShowModules.text=顯示模組
action.ProjectView.ShowModules.description=顯示相應根的模組名稱
action.ProjectView.ShowVisibilityIcons.text=顯示可見性圖標
action.ProjectView.ShowVisibilityIcons.description=在元素名稱之前顯示其可見性的圖標
action.ProjectView.SortByType.text=按類型排序
action.ProjectView.SortByType.description=單獨對不同類型的檔案排序
action.ScopeView.EditScopes.text=編輯範圍(_I)…
action.ScopeView.EditScopes.description=編輯範圍…
action.ProjectView.FileNesting.text=檔案嵌套…
action.ProjectView.FileNesting.description=配置檔案嵌套

action.CodeInspection.OnEditor.text=使用編輯器設定檢查程式碼(_E)
action.CodeInspection.OnEditor.description=使用編輯器設定檢查程式碼(_E)

action.SendFeedback.text=提交反饋...(_F)
action.SendFeedback.detailed.description=提交反饋給 {0}
action.OpenLog.text=在編輯器中打開日誌
action.ShowLog.text=在檔案管理器中顯示日誌(_L)
action.ShowLog.Explorer.text=在資源管理器中顯示日誌(_L)
action.ShowLog.Finder.text=在訪達中顯示日誌(_L)
action.ShowLog.description=打開帶日誌檔案的資料夾
action.CollectZippedLogs.text=收集日誌和診斷資料
action.CollectZippedLogs.description=將日誌和設定壓縮到檔案中
action.DeleteOldAppDirs.text=刪除殘留的 IDE 目錄…
action.DeleteOldAppDirs.description=尋找以前 IDE 版本中的設定、快取和日誌目錄
action.EditCustomProperties.text=編輯自定義屬性…
action.EditCustomProperties.description=打開帶有自訂屬性檔案的編輯器頁籤
action.EditCustomVmOptions.text=編輯自定義 VM 選項…
action.EditCustomVmOptions.description=打開帶有自訂 VM 選項檔案的編輯器頁籤
action.LogDebugConfigure.text=調試日誌設定(_E)…
action.LogDebugConfigure.description=啟用或禁用額外的日誌類別。允許通過請求向支援團隊提供更多資訊。
action.TechnicalSupport.text=聯繫支援(_S)…
action.TechnicalSupport.description=聯繫 JetBrains 網站上的技術支援
action.ReportProblem.text=提交錯誤報告...
action.ReportProblem.description=在 JetBrains 問題跟踪器中提交錯誤報告

action.TextComponent.ClearAction.text=清除文本
action.TextComponent.ClearAction.description=清除文本組件中的文本

action.ChangesView.Refresh.text=刷新
action.ChangesView.Refresh.MainMenu.text=刷新 VCS 變更
action.ChangesView.Refresh.description=刷新 VCS 變更
action.ChangesView.NewChangeList.text=新建變更列表…
action.ChangesView.NewChangeList.description=創建新的變更列表
action.ChangesView.Revert.text=回滾(_R)...
action.ChangesView.RevertFiles.text=回滾檔案(_R)...
action.ChangesView.RemoveChangeList.text=刪除變更列表
action.ChangesView.RemoveChangeList.description=移除變更列表並將所有變更移至其他變更列表
action.ChangesView.RemoveChangeList.text.template=刪除{0,choice,0#變更列表|2#變更列表}
action.ChangesView.RemoveChangeList.description.template=移除{0,choice,0#變更列表|2#變更列表}和移動所有的改變到{1}
action.ChangesView.SetDefault.text=設定活動變更列表
action.ChangesView.SetDefault.description=設定預設情況下放置新變更的變更列表
action.ChangesView.Move.text=移至另一個變更列表…
action.ChangesView.Move.Files.text=將檔案移動到另一個變更列表…
action.ChangesView.Move.description=將所選變更移至另一個變更列表
action.ChangesView.Diff.text=顯示差異
action.ChangesView.Diff.description=比較檔案或修訂
action.ChangesView.AddUnversioned.text=添加到 VCS
action.ChangesView.AddUnversioned.description=排定將所選檔案添加到 VCS 的時間表
action.ChangesView.RemoveDeleted.text=從 VCS 移除
action.ChangesView.RemoveDeleted.description=排定將所選檔案從 VCS 移除的時間表
action.ChangesView.Rename.text=編輯變更列表…
action.ChangesView.Rename.description=編輯所選變更列表的名稱和描述
action.ChangesView.CreatePatch.text=從本地更改創建補丁...
action.ChangesView.CreatePatch.description=從所選變更創建補丁
action.ChangesView.ApplyPatch.text=套用補丁…
action.ChangesView.ApplyPatch.description=將補丁套用到專案的源
action.ChangesView.ApplyPatchFromClipboard.text=從剪貼簿套用補丁…
action.ChangesView.ApplyPatchFromClipboard.description=將補丁套用到專案的源
action.ChangesView.Shelve.text=擱置變更…
action.ChangesView.Shelve.description=將變更儲存到外部補丁檔案，並將其從程式碼中移除
action.ShelvedChanges.Rename.text=重命名…
action.ShelvedChanges.Rename.description=重命名擱置的變更列表
action.ChangesView.Browse.text=瀏覽變更…
action.ChangesView.Browse.description=查看已提交變更的歷史記錄
action.ChangesView.Edit.text=簽出
action.ChangesView.Edit.description=簽出所選檔案進行編輯
action.ChangesView.CreatePatchFromChanges.text=創建補丁…
action.ChangesView.CreatePatchFromChanges.description=從所選變更創建補丁
action.ChangesView.CreatePatchToClipboard.text=作為補丁複製到剪貼簿
action.ChangesView.CreatePatchToClipboard.description=從變更創建補丁並將其複製到剪貼簿
action.CommittedChanges.Refresh.text=刷新
action.CommittedChanges.Refresh.description=刷新已提交變更的列表
action.CommittedChanges.Filter.text=篩選
action.CommittedChanges.Filter.description=更改篩選條件
action.CommittedChanges.Details.text=顯示詳細資訊
action.CommittedChanges.Details.description=查看所選變更列表的完整資訊
action.CommittedChanges.Clear.text=清除
action.CommittedChanges.Clear.description=清除快取的修訂版本
action.IncomingChanges.Refresh.text=刷新
action.IncomingChanges.Refresh.description=刷新傳入變更的列表
action.FileChooser.TogglePathShowing.text=顯示/隱藏路徑文本
action.ChangeFileEncodingAction.text=檔案編碼
action.ChangeFileEncodingAction.description=更改檔案編碼
action.VcsHistory.ShowAllAffected.text=顯示所有受影響的檔案
action.VcsHistory.ShowAllAffected.description=顯示選中修訂中所做的所有變更
action.Vcs.Show.Shelf.text=顯示 Shelf
action.Vcs.Show.Local.Changes.text=顯示本地變更
group.FileHistory.KeymapGroup.text=檔案歷史記錄
group.Shelve.KeymapGroup.text=擱置
action.Vcs.CopyRevisionNumberAction.text=複製修訂號
action.Vcs.CopyRevisionNumberAction.description=將選定提交的修訂號複製到剪貼簿
action.VcsToolbarLabelAction.text=VCS 標籤
group.CommitView.ShowOnDoubleClick.text=雙擊時顯示
action.CommitView.ShowOnDoubleClick.EditorPreview.text=雙擊時顯示差異
action.CommitView.ShowOnDoubleClick.EditorPreview.ToolwindowPopup.text=差異
action.CommitView.ShowOnDoubleClick.Source.text=雙擊時顯示源
action.CommitView.ShowOnDoubleClick.Source.ToolwindowPopup.text=源
action.CommitView.SwitchToCommitDialog.text=切換到“提交”對話框
action.Vcs.ToggleAmendCommitMode.text=修正提交
action.Vcs.ToggleAmendCommitMode.description=修改當前分支的最新提交
action.ChangesView.ShowCommitOptions.text=顯示提交選項
action.Vcs.ApplySelectedChanges.text=優選所選變更
action.Vcs.RevertSelectedChanges.text=還原所選變更
action.Vcs.EditSource.text=編輯源
action.ChangesView.UnshelveSilently.text=靜默取消擱置
action.ChangesView.UnshelveSilently.description=取消擱置對相應變更列表的變更
action.ShelvedChanges.CleanMarkedToDelete.text=清理已取消擱置變更…
action.ShelvedChanges.CleanMarkedToDelete.description=刪除已取消擱置的變更列表
action.ShelvedChanges.ShowRecentlyDeleted.text=顯示最近刪除項
action.ShelvedChanges.ShowRecentlyDeleted.description=顯示最近刪除的擱置
action.ShelvedChanges.ShowHideDeleted.description=顯示/隱藏已取消擱置變更
action.ShelveChanges.UnshelveWithDialog.text=取消擱置…
action.ShelveChanges.UnshelveWithDialog.description=更正套用補丁的路徑並取消擱置
action.ChangesView.ShelveSilently.text=靜默擱置
action.ChangesView.ShelveSilently.description=擱置對適當的已擱置變更列表的變更
action.ChangesView.SaveToShelve.text=儲存到擱置
action.ChangesView.SaveToShelve.description=將所選變更複製到擱置的變更列表
action.ChangesView.GroupBy.Directory.text=目錄
group.ChangesView.GroupBy.text=分組依據
action.Vcs.QuickListPopupAction.text=VCS 操作彈出視窗…
action.Vcs.QuickListPopupAction.description=包含常用 VCS 操作列表的上下文感知彈出視窗
action.Vcs.VcsClone.text=從版本控制中獲取…
action.Vcs.VcsClone.text.synonym1=簽出
action.Vcs.VcsClone.text.synonym2=克隆
Vcs.VcsClone.Welcome.text=從版本控制中獲取
Vcs.VcsClone.Tabbed.Welcome.text=從 VCS 獲取
Vcs.VcsClone.Project.text=來自版本控制的專案…
action.Vcs.ShowDiffWithLocal.text=與本地比較
action.Vcs.ShowDiffWithLocal.description=將所選修訂中的版本與當前版本進行比較
action.Vcs.ShowDiffWithLocal.Before.text=將之前版本與本地版本進行比較
action.Vcs.ShowDiffWithLocal.Before.description=將之前的所選修訂中的版本與當前版本進行比較
action.Compare.Specified.text=與指定修訂比較(_P)…
action.Show.Current.Revision.text=顯示當前修訂
group.ChangesView.Changelists.text=變更列表
separator.Local.History.text=本地歷史記錄

action.AddFrameworkSupport.text=添加框架支援…

action.Diff.FocusOppositePane.text=選擇相對差異窗格
action.Diff.FocusOppositePane.description=在差異檢視中選擇相對窗格
action.Diff.FocusOppositePaneAndScroll.text=在相對差異窗格中選擇位置
action.Diff.FocusOppositePaneAndScroll.description=在差異檢視的相對窗格中選擇相同的位置
action.Diff.PrevChange.text=比較上一個檔案
action.Diff.NextChange.text=比較下一個檔案
action.Diff.ApplyLeftSide.text=接受左側
action.Diff.ApplyRightSide.text=接受右側
action.Diff.AppendLeftSide.text=追加左側
action.Diff.AppendRightSide.text=追加右側
action.Diff.IgnoreLeftSide.text=忽略左側
action.Diff.IgnoreRightSide.text=忽略右側
action.Diff.ResolveConflict.text=自動解決
action.Diff.ApplyNonConflicts.text=套用所有不衝突的變更
action.Diff.ApplyNonConflicts.Left.text=從左側套用不衝突的變更
action.Diff.ApplyNonConflicts.Right.text=從右側套用不衝突的變更
action.Diff.MagicResolveConflicts.text=解決簡單的衝突
action.Diff.ComparePartial.Base.Left.text=左和中
action.Diff.ComparePartial.Base.Right.text=中和右
action.Diff.ComparePartial.Left.Right.text=左和右
action.Diff.CompareWithBase.Left.text=基礎和左
action.Diff.CompareWithBase.Result.text=基礎和中
action.Diff.CompareWithBase.Right.text=基礎和右
action.Diff.ComparePartial.Generic={0,choice,0#左|1#中|2#右} 和 {1,choice,0#左|1#中|2#右}

action.FileChooser.Refresh.text=刷新
action.FileChooser.Refresh.description=刷新檔案系統樹
action.FileChooser.Delete.text=刪除…
action.FileChooser.Delete.description=刪除
action.FileChooser.NewFolder.text=新建資料夾…
action.FileChooser.NewFolder.description=創建新目錄
action.FileChooser.NewFile.text=新建檔案…
action.FileChooser.NewFile.description=創建新檔案
action.FileChooser.GotoHome.text=主目錄
action.FileChooser.GotoHome.description=轉到主目錄
action.FileChooser.GotoDesktop.text=桌面目錄
action.FileChooser.GotoDesktop.description=轉到桌面目錄
action.FileChooser.GotoProject.text=專案目錄
action.FileChooser.GotoProject.description=轉到專案目錄
action.FileChooser.GotoModule.text=模組目錄
action.FileChooser.GotoModule.description=轉到模組目錄

action.WelcomeScreen.DevelopPlugins.text=套件開發
action.WelcomeScreen.DevelopPlugins.description=開始開發套件。
action.WelcomeScreen.OpenProject.text=打開或匯入
action.WelcomeScreen.OpenProject.description=打開檔案或專案。您也可以通過拖放到歡迎頁面來打開專案或編輯檔案。
action.Tabbed.WelcomeScreen.OpenProject.text=打開
action.WelcomeScreen.CreateNewProject.text=新建專案
action.WelcomeScreen.CreateNewProject.description=啟動“新項目”嚮導，它將引導您創建一個新項目。
action.WelcomeScreen.Plugins.text=套件
action.WelcomeScreen.Plugins.Extensions.text=擴展
action.WelcomeScreen.Plugins.description=管理已安裝的套件，以及從儲存庫下載新套件
action.WelcomeScreen.Configure.Import.text=匯入設定…
action.WelcomeScreen.Configure.Export.text=匯出設定
action.WelcomeScreen.Configure.RestoreDefault.text=恢復預設設定…
group.WelcomeScreen.Options.text=選項選單

action.CommittedChanges.Revert.text=還原變更
action.CommittedChanges.Revert.description=將所選變更的反向操作應用於工作副本

action.WelcomeScreen.OpenDirectoryProject.text=打開
action.WelcomeScreen.OpenDirectoryProject.description=開始在指定的檔案或目錄中編輯程式碼。
action.WelcomeScreen.CreateDirectoryProject.text=新建專案
action.WelcomeScreen.CreateDirectoryProject.description=創建一個新項目。
action.NewDirectoryProject.text=新建專案…
action.NewDirectoryProject.description=創建一個新項目
action.NewDirectoryProject.title=創建專案
action.NewDirectoryProject.cannot.create.dir=無法創建目錄 ''{0}''。
action.NewDirectoryProject.not.empty.dialog.title=目錄不為空
action.NewDirectoryProject.not.empty.dialog.text=目錄 ''{0}'' 不為空。想從現有的源創建專案嗎?
action.NewDirectoryProject.not.empty.dialog.create.new=從現有的源創建
action.NewDirectoryProject.not.empty.dialog.open.existing=打開專案

action.SliceBackward.text=分析流入此處的資料(_T)…
action.SliceBackward.MainMenu.text=流入此處的資料(_T)…
action.SliceBackward.description=搜尋可以分配給所選表達式的值

action.SliceForward.text=分析流出此處的資料(_F)…
action.SliceForward.MainMenu.text=流出此處的資料(_F)…
action.SliceForward.description=搜尋從此位置轉義的值

action.ChangeTemplateDataLanguage.text=更改模板資料語言

group.FileOpenGroup.text=檔案打開操作
group.FileOtherSettingsGroup.text=新項目設定
group.FileMainSettingsGroup.text=設定操作
group.FileSettingsGroup.text=設定操作
group.ExportImportGroup.text=管理 IDE 設定
group.PrintExportGroup.text=列印/匯出操作
group.EditSelectGroup.text=編輯器選擇操作
group.EditCreateDeleteGroup.text=編輯器創建/刪除操作
group.CutCopyPasteGroup.text=剪下/複製/貼上操作
group.EditSelectWordGroup.text=選擇單詞操作
group.EditBookmarksGroup.text=書籤(_K)
group.OpenProjectGroup.text=打開專案操作
group.EditSmartGroup.text=編輯程式碼操作
group.CodeEditorViewGroup.text=程式碼檢視操作
group.CodeEditorBaseGroup.text=程式碼編輯器檢視操作
group.HierarchyGroup.text=層次結構操作
group.DebugMainMenu.text=調試器操作
group.DebuggingActionsGroup.text=調試操作
group.BreakpointActionsGroup.text=切換斷點
group.ToggleBreakpointAction.text=斷點操作
group.CommentGroup.text=註釋操作
group.CodeFormatGroup.text=程式碼格式化操作
group.GoToTargetEx.text=通過名稱轉到操作
group.GoToErrorGroup.text=轉到錯誤/書籤操作
group.GoToCodeGroup.text=通過引用轉到操作
group.GoToChangeMarkerGroup.text=更改導航操作
group.CoverageMenu.text=程式碼覆蓋率操作
group.ToolsXmlGroup.text=XML 操作
group.XmlGenerateToolsGroup.text=XML 生成操作
group.EditorPopupMenuDebug.text=調試操作
group.VersionControlsGroup.text=VCS/LVCS 操作
group.EditorPopupMenu.Run.text=編譯/執行操作
group.ProjectViewCompileGroup.text=編譯/調試操作
group.ProjectViewAnalysisGroup.text=分析操作
group.PairFileActions.text=檔案對的操作
group.RefactoringMenu1.text=重構操作(1)
group.RefactoringMenu2.text=重構操作(2)
group.ToolbarFindGroup.text=工具欄尋找操作
group.ToolbarRunGroup.text=工具欄執行操作
group.ToolbarMakeGroup.text=工具欄設定操作
group.EditorPopupMenu1.text=編輯器彈出視窗選單操作(1)
group.EditorLangPopupMenu.text=編輯器彈出視窗選單操作(2)
group.CloseEditorsGroup.text=編輯器關閉操作
group.EditorTabPopupMenuEx.text=編輯器頁籤彈出視窗選單操作(1)
group.ProjectViewPopupMenuModifyGroup.text=專案檢視彈出視窗選單修改組
group.ProjectViewPopupMenuRunGroup.text=專案檢視彈出視窗選單執行組
group.ProjectViewPopupMenuSettingsGroup.text=專案檢視彈出視窗選單設定組
group.ProjectViewPopupMenuRefactoringGroup.text = 專案檢視彈出視窗重構組
group.ViewRecentActions.text=查看最近的操作組
group.NewGroup1.text=新組(1)
action.NewModuleInGroup.text=模組
action.ShelvedChanges.ShowHideDeleted.text=顯示/隱藏已套用的擱置變更
action.XDebugger.MuteBreakpoints.text=靜音斷點
action.ShelvedChanges.Restore.text=恢復已套用的擱置變更
group.VcsToolbarActions.text=VCS 操作
action.ChangesView.GroupBy.Repository.text=儲存庫
action.CheckIgnoredAndNotExcludedDirectories.text=檢查已忽略但未排除的目錄
action.CheckIgnoredAndNotExcludedDirectories.description=檢查是否存在可以排除在索引和搜尋之外的已忽略目錄
action.CheckIgnoredAndNotExcludedDirectories.progress=正在檢查已忽略但未排除的目錄…
action.Vcs.Push.Force.text=強制推送(_F)
action.Vcs.Push.text=推送…
action.PopupHector.text=配置當前檔案分析…
action.PopupHector.description=顯示面板來為當前檔案配置高亮顯示模式
group.EditorTabPopupMenu.text=編輯器頁籤彈出視窗選單
group.MainMenu.text=主選單
group.ProjectViewPopupMenu.text=專案檢視彈出視窗選單
group.FavoritesViewPopupMenu.text=收藏夾檢視彈出視窗選單
group.NavbarPopupMenu.text=導航欄
action.RerunFailedTests.text=重新執行失敗的測試
action.RerunFailedTests.description=僅執行上次執行後失敗/崩潰的測試；按 Shift 鍵選擇“執行/調試”模式
group.AnalyzeJavaMenu.text=分析 Java 選單
group.AnalyzeJavaMenu.description=分析 Java 選單
group.ToolsBasicGroup.text=基本工具組
group.ToolsBasicGroup.description=基本工具組
action.ShowRegistry.text=註冊表…
action.ShowExperiments.text=實驗性功能…
action.UiDebugger.text=UI 調試器…
action.ExportTestResults.text=匯出測試結果…
action.ExportTestResults.description=將測試結果匯出到檔案
action.TogglePowerSave.text=省電模式
action.TogglePowerSave.description=省電模式將禁用背景程式碼分析和其他背景操作
group.ConvertIndentsGroup.text=轉換縮排
action.ConvertIndentsToSpaces.text=轉換為空格
action.ConvertIndentsToSpaces.description=轉換檔案或所選塊中的縮排，以使用空格代替制表符
action.ConvertIndentsToTabs.text=轉換為制表符
action.ConvertIndentsToTabs.description=轉換檔案或所選塊中的縮排，以使用制表符代替空格
group.Vcs.Import.text=匯入到版本控制
group.Vcs.Browse.text=瀏覽 VCS 儲存庫
action.Graph.print.reset=重置
action.MarkExcludeRoot.text=已排除
action.UnmarkRoot.text=取消標記
action.MarkAsContentRoot.text=不排除
action.MarkAsContentRoot.description=取消所選目錄的排除，使其檔案可以被 IDE 的操作處理
action.CreateLibraryFromFile.text=添加為庫…
action.ExtractModuleFromPackage.text=提取模組…
action.ExtractModuleFromPackage.description=將軟體套件提取到單獨的模組
action.ImportModuleFromImlFile.text=匯入模組
action.ImportModuleFromImlFile.description=將 iml 檔案作為一個模組匯入到專案
group.MarkRootGroup.text=將目錄標記為
action.CreateLauncherScript.text=創建命令行啟動器…
action.CreateLauncherScript.description=創建一個腳本，用於從命令行打開檔案和專案
action.CreateDesktopEntry.text=創建桌面條目…
action.CreateDesktopEntry.description=創建桌面條目以與系統套用程序選單集成
group.EditorGutterPopupMenu.text=編輯器間距彈出選單
action.ConfigureSoftWraps.text=配置自動換行
action.EditorGutterToggleLocalSoftWraps.gutterText=自動換行當前編輯器
action.EditorGutterToggleGlobalLineNumbers.text=顯示行號
action.EditorGutterToggleGlobalIndentLines.text=顯示縮排參考線
action.ShowGutterIconsSettings.text=配置間距圖標...
action.ShowGutterIconsSettings.description=顯示對話框以配置間距圖標

group.EditorBreadcrumbsSettings.text=路徑導航
group.EditorBreadcrumbsSettings.description=切換路徑導航欄設定
action.EditorBreadcrumbsShowAbove.text=頂部
action.EditorBreadcrumbsShowAbove.description=在文本編輯器上方顯示路徑導航欄
action.EditorBreadcrumbsShowBelow.text=底部
action.EditorBreadcrumbsShowBelow.description=在文本編輯器下方顯示路徑導航欄
action.EditorBreadcrumbsHideBoth.text=不顯示
action.EditorBreadcrumbsHideBoth.description=隱藏路徑導航欄

group.MarkFileAs.text=將檔案標記為
action.OverrideFileTypeAction.text=覆寫檔案類型
action.OverrideFileTypeAction.description=將當前檔案視為不同檔案類型的檔案
group.OverrideFileTypeAction.title=選擇檔案類型
group.OverrideFileTypeAction.bundledPlugin=捆綁
group.OverrideFileTypeAction.fromNamedPlugin=自 ''{0}'' 套件
action.ChangeToThisFileTypeAction.description=將檔案類型覆蓋為 ''{0}''

action.Console.Open.text=打開控制台
action.Console.Open.description=為所選實體打開控制台
action.Console.Execute.text=在單行控制台中執行當前語句
action.Console.Execute.description=在單行控制台中執行當前語句
action.Console.Execute.Multiline.text=在多行控制台中執行當前語句
action.Console.Execute.Multiline.description=在多行控制台中執行當前語句
action.Console.SplitLine.text=拆分行
action.Console.History.Previous.text=控制台歷史記錄中的上一個條目
action.Console.History.Previous.description=控制台歷史記錄中的上一個條目
action.Console.History.Next.text=控制台歷史記錄中的下一個條目
action.Console.History.Next.description=控制台歷史記錄中的下一個條目
action.Console.History.Browse.text=瀏覽查詢歷史記錄
action.Console.History.Browse.description=瀏覽查詢歷史記錄
action.RevealIn.description=在平台的檔案管理器中高亮顯示檔案
action.RevealIn.name.mac=在訪達中顯示
action.RevealIn.name.other=在 {0} 中顯示
show.log.in.action.text=在 {0} 中顯示日誌
show.log.notification.text=查看日誌
action.GoToLinkTarget.text=轉到鏈接目標
action.GoToLinkTarget.description=在專案檢視中打開此符號鏈接的目標

action.TabList.text=顯示隱藏的頁籤
action.TabList.description=使用包含在單行頁籤布局中不適合螢幕的頁籤列表的下拉列表

action.FillParagraph.text=填充段落
action.FillParagraph.description=重新格式化字串文字或註釋以適應最大寬度(通常為80)

action.SaveDocument.text=儲存文檔
action.SaveDocument.description=只儲存在當前編輯器中打開的檔案

action.StructuralSearchPlugin.StructuralSearchAction.text=結構搜尋(_T)…
action.StructuralSearchPlugin.StructuralSearchAction.description=結構搜尋
action.StructuralSearchPlugin.StructuralReplaceAction.text=結構取代(_C)…
action.StructuralSearchPlugin.StructuralReplaceAction.description=結構取代

action.ModuleSettings.navigate=打開模組設定
action.LibrarySettings.navigate=打開庫設定
action.ToggleDistractionFreeMode.enter=進入免打擾模式
action.ToggleDistractionFreeMode.exit=退出免打擾模式
action.TogglePresentationMode.exit=退出演示模式
action.TogglePresentationMode.enter=進入演示模式
action.ToggleZenMode.enter=進入 Zen 模式
action.ToggleZenMode.exit=退出 Zen 模式

action.EmojiAndSymbols.description=使用 macOS 系統調色板輸入特殊字符

action.MethodOverloadSwitchUp.text=上一個方法多載
action.MethodOverloadSwitchDown.text=下一個方法多載

action.BraceOrQuoteOut.text=跳到當前括號/引號

action.SetShortcutAction.text=添加快捷鍵…

action.EditorFocusGutter.text=焦點間距(無障礙功能)
action.EditorShowGutterIconTooltip.text=顯示間距圖標工具提示(無障礙功能)

action.ConfigureEditorTabs.text=配置編輯器頁籤...
action.ConfigureEditorTabs.description=配置編輯器頁籤的外觀，行為和順序

group.FilePropertiesGroup.text=檔案屬性
group.FileExportGroup.text=匯出
group.PasteGroup.text=貼上
group.FindUsagesMenuGroup.text=尋找用法
group.NavigateInFileGroup.text=在檔案中導航
group.HelpDiagnosticTools.text=診斷工具
group.ChangeLineSeparators.text=行分隔符

group.CopyReferencePopupGroup.text=複製路徑/引用…

action.CompareDirs.text=比較目錄
action.compare.files.text=比較檔案
action.compare.with.text=比較物件…
action.compare.text=比較
action.compare.archives.text=比較歸檔

action.List-selectFirstRow.text=選擇第一行
action.List-selectFirstRow.description=選擇第一行。
action.List-selectFirstRowExtendSelection.text=將選擇範圍擴展到第一行
action.List-selectFirstRowExtendSelection.description=滾動到第一行並將相應的行添加到選擇範圍。
action.List-selectLastRow.text=選擇最後一行
action.List-selectLastRow.description=選擇最後一行。
action.List-selectLastRowExtendSelection.text=將選擇範圍擴展到最後一行
action.List-selectLastRowExtendSelection.description=滾動到最後一行並將相應的行添加到選擇範圍。
action.List-selectPreviousRow.text=選擇上一行
action.List-selectPreviousRow.description=選擇上一行。
action.List-selectPreviousRowExtendSelection.text=將選擇範圍擴展到上一行
action.List-selectPreviousRowExtendSelection.description=將上一行添加到選擇範圍。
action.List-selectNextRow.text=選擇下一行
action.List-selectNextRow.description=選擇下一行。
action.List-selectNextRowExtendSelection.text=將選擇範圍擴展到下一行
action.List-selectNextRowExtendSelection.description=將下一行添加到選擇範圍。
action.List-selectPreviousColumn.text=選擇上一列
action.List-selectPreviousColumn.description=選擇上一列。
action.List-selectPreviousColumnExtendSelection.text=將選擇範圍擴展到上一列
action.List-selectPreviousColumnExtendSelection.description=將上一列添加到選擇範圍。
action.List-selectNextColumn.text=選擇下一列
action.List-selectNextColumn.description=選擇下一列。
action.List-selectNextColumnExtendSelection.text=將選擇範圍擴展到下一列
action.List-selectNextColumnExtendSelection.description=將下一列添加到選擇範圍。
action.List-scrollUp.text=向上滾動頁面並選擇行
action.List-scrollUp.description=將周圍的可滾動區域向上滾動一頁，然後選擇相應的行。
action.List-scrollUpExtendSelection.text=向上滾動頁面並擴展選擇範圍
action.List-scrollUpExtendSelection.description=將周圍的可滾動區域向上滾動一頁，然後將相應的行添加到選擇範圍。
action.List-scrollDown.text=向下滾動頁面並選擇行
action.List-scrollDown.description=將周圍的可滾動區域向下滾動一頁，然後選擇相應的行。
action.List-scrollDownExtendSelection.text=向下滾動頁面並擴展選擇範圍
action.List-scrollDownExtendSelection.description=將周圍的可滾動區域向下滾動一頁，然後將相應的行添加到選擇範圍。
action.Table-selectFirstRow.text=選擇第一行
action.Table-selectFirstRow.description=選擇第一行。
action.Table-selectFirstRowExtendSelection.text=將選擇範圍擴展到第一行
action.Table-selectFirstRowExtendSelection.description=滾動到第一行並將相應的行添加到選擇範圍。
action.Table-selectLastRow.text=選擇最後一行
action.Table-selectLastRow.description=選擇最後一行。
action.Table-selectLastRowExtendSelection.text=將選擇範圍擴展到最後一行
action.Table-selectLastRowExtendSelection.description=滾動到最後一行並將相應的行添加到選擇範圍。
action.Table-selectPreviousRow.text=選擇上一行
action.Table-selectPreviousRow.description=選擇上一行。
action.Table-selectPreviousRowExtendSelection.text=將選擇範圍擴展到上一行
action.Table-selectPreviousRowExtendSelection.description=將上一行添加到選擇範圍。
action.Table-selectNextRow.text=選擇下一行
action.Table-selectNextRow.description=選擇下一行。
action.Table-selectNextRowExtendSelection.text=將選擇範圍擴展到下一行
action.Table-selectNextRowExtendSelection.description=將下一行添加到選擇範圍。
action.Table-selectPreviousColumn.text=選擇上一列
action.Table-selectPreviousColumn.description=選擇上一列。
action.Table-selectPreviousColumnExtendSelection.text=將選擇範圍擴展到上一列
action.Table-selectPreviousColumnExtendSelection.description=將上一列添加到選擇範圍。
action.Table-selectNextColumn.text=選擇下一列
action.Table-selectNextColumn.description=選擇下一列。
action.Table-selectNextColumnExtendSelection.text=將選擇範圍擴展到下一列
action.Table-selectNextColumnExtendSelection.description=將下一列添加到選擇範圍。
action.Table-scrollUpChangeSelection.text=向上滾動頁面並選擇行
action.Table-scrollUpChangeSelection.description=將周圍的可滾動區域向上滾動一頁，然後選擇相應的行。
action.Table-scrollUpExtendSelection.text=向上滾動頁面並擴展選擇範圍
action.Table-scrollUpExtendSelection.description=將周圍的可滾動區域向上滾動一頁，然後將相應的行添加到選擇範圍。
action.Table-scrollDownChangeSelection.text=向下滾動頁面並選擇行
action.Table-scrollDownChangeSelection.description=將周圍的可滾動區域向下滾動一頁，然後選擇相應的行。
action.Table-scrollDownExtendSelection.text=向下滾動頁面並擴展選擇範圍
action.Table-scrollDownExtendSelection.description=將周圍的可滾動區域向下滾動一頁，然後將相應的行添加到選擇範圍。
action.Tree-selectFirst.text=選擇第一個節點
action.Tree-selectFirst.description=選擇第一個節點。
action.Tree-selectFirstExtendSelection.text=將選擇範圍擴展到第一個節點
action.Tree-selectFirstExtendSelection.description=滾動到第一個節點並將相應的節點添加到選擇範圍。
action.Tree-selectLast.text=選擇最後一個節點
action.Tree-selectLast.description=選擇最後一個節點。
action.Tree-selectLastExtendSelection.text=將選擇範圍擴展到最後一個節點
action.Tree-selectLastExtendSelection.description=滾動到最後一個節點並將相應的節點添加到選擇範圍。
action.Tree-selectPrevious.text=選擇上一個節點
action.Tree-selectPrevious.description=選擇上一個節點。
action.Tree-selectPreviousExtendSelection.text=將選擇範圍擴展到上一個節點
action.Tree-selectPreviousExtendSelection.description=將上一個節點添加到選擇範圍。
action.Tree-selectNext.text=選擇下一個節點
action.Tree-selectNext.description=選擇下一個節點。
action.Tree-selectNextExtendSelection.text=將選擇範圍擴展到下一個節點
action.Tree-selectNextExtendSelection.description=將下一個節點添加到選擇範圍。
action.Tree-selectParentNoCollapse.text=選擇父節點
action.Tree-selectParentNoCollapse.description=選擇父節點(不摺疊展開的節點)。
action.Tree-selectParent.text=選擇父節點
action.Tree-selectParent.description=摺疊展開的節點或選擇父節點。
action.Tree-selectParentExtendSelection.text=將選擇範圍擴展到父節點
action.Tree-selectParentExtendSelection.description=滾動到父節點並將相應的節點添加到選擇範圍。
action.Tree-selectChild.text=選擇子節點
action.Tree-selectChild.description=展開摺疊的節點或選擇子節點。
action.Tree-selectChildExtendSelection.text=將選擇範圍擴展到子節點
action.Tree-selectChildExtendSelection.description=展開摺疊的節點或將子節點添加到選擇範圍。
action.Tree-scrollUpChangeSelection.text=向上滾動頁面並選擇節點
action.Tree-scrollUpChangeSelection.description=將周圍的可滾動區域向上滾動一頁，然後選擇相應的節點。
action.Tree-scrollUpExtendSelection.text=向上滾動頁面並擴展選擇範圍
action.Tree-scrollUpExtendSelection.description=將周圍的可滾動區域向上滾動一頁，然後將相應的節點添加到選擇範圍。
action.Tree-scrollDownChangeSelection.text=向下滾動頁面並選擇節點
action.Tree-scrollDownChangeSelection.description=將周圍的可滾動區域向下滾動一頁，然後選擇相應的節點。
action.Tree-scrollDownExtendSelection.text=向下滾動頁面並擴展選擇範圍
action.Tree-scrollDownExtendSelection.description=將周圍的可滾動區域向下滾動一頁，然後將相應的節點添加到選擇範圍。
action.Tree-selectNextSibling.text=選擇下一個同級節點
action.Tree-selectNextSibling.description=選擇下一個同級節點。
action.Tree-selectPreviousSibling.text=選擇上一個同級節點
action.Tree-selectPreviousSibling.description=選擇上一個同級節點。
action.PopupMenu-selectPrevious.text=選擇上一個菜單項
action.PopupMenu-selectPrevious.description=選擇上一個菜單項。
action.PopupMenu-selectNext.text=選擇下一個菜單項
action.PopupMenu-selectNext.description=選擇下一個菜單項。
action.PopupMenu-selectParent.text=選擇父菜單項
action.PopupMenu-selectParent.description=關閉子選單並在父選單中選擇相應的項。
action.PopupMenu-selectChild.text=選擇子菜單項
action.PopupMenu-selectChild.description=打開子選單並在其中選擇相應的項。
action.PopupMenu-return.text=調用選定操作
action.PopupMenu-return.description=打開子選單或從選定的菜單項中調用操作。
action.PopupMenu-cancel.text=關閉右鍵選單
action.PopupMenu-cancel.description=關閉右鍵選單。
action.ScrollPane-scrollHome.text=滾動至頁首
action.ScrollPane-scrollHome.description=將周圍的可滾動區域滾動到頂部。
action.ScrollPane-scrollEnd.text=滾動至頁尾
action.ScrollPane-scrollEnd.description=將周圍的可滾動區域滾動到底部。
action.ScrollPane-unitScrollUp.text=向上滾動
action.ScrollPane-unitScrollUp.description=將周圍的可滾動區域向上滾動一個單位。
action.ScrollPane-unitScrollDown.text=向下滾動
action.ScrollPane-unitScrollDown.description=將周圍的可滾動區域向下滾動一個單位。
action.ScrollPane-unitScrollLeft.text=向左滾動
action.ScrollPane-unitScrollLeft.description=將周圍的可滾動區域向左滾動一個單位。
action.ScrollPane-unitScrollRight.text=向右滾動
action.ScrollPane-unitScrollRight.description=將周圍的可滾動區域向右滾動一個單位。
action.ScrollPane-scrollUp.text=向上滾動頁面
action.ScrollPane-scrollUp.description=將周圍的可滾動區域向上滾動一頁。
action.ScrollPane-scrollDown.text=向下滾動頁面
action.ScrollPane-scrollDown.description=將周圍的可滾動區域向下滾動一頁。
action.ScrollPane-scrollLeft.text=向左滾動頁面
action.ScrollPane-scrollLeft.description=將周圍的可滾動區域向左滾動一頁。
action.ScrollPane-scrollRight.text=向右滾動頁面
action.ScrollPane-scrollRight.description=將周圍的可滾動區域向右滾動一頁。
action.RunAnything.text=執行任何內容
action.RunAnything.description=允許執行任何命令
action.Performance.ActivityMonitor.text=活動監視器…
action.Performance.ActivityMonitor.description=用於檢查哪些套件和子系統消耗大多數資源的工具
action.performancePlugin.ShowMemoryDialogAction.text=更改記憶體設定
action.performancePlugin.ShowMemoryDialogAction.description=顯示更改記憶體對話框
action.DisablePCE.text=禁用 ProcessCanceledException
action.DisablePCE.description=禁用讀取操作期間在背景執行緒中引發的 ProcessCanceledException 以簡化調試
action.SearchEverywhere.NextTab.text=下一個頁籤
action.SearchEverywhere.NextTab.description=在 Search Everywhere 對話框中切換到下一個頁籤
action.SearchEverywhere.PrevTab.text=上一個頁籤
action.SearchEverywhere.PrevTab.description=在 Search Everywhere 對話框中切換到上一個頁籤
action.SearchEverywhere.CompleteCommand.text=補全命令
action.SearchEverywhere.CompleteCommand.description=在 Search Everywhere 對話框中自動補全命令
action.SearchEverywhere.SelectItem.text=選擇項
action.SearchEverywhere.SelectItem.description=在 Search Everywhere 對話框中選擇項
action.SearchEverywhere.NavigateToNextGroup.text=下一個組元素
action.SearchEverywhere.NavigateToNextGroup.description=在 Search Everywhere 對話框中導航到下一個組
action.SearchEverywhere.NavigateToPrevGroup.text=上一個組元素
action.SearchEverywhere.NavigateToPrevGroup.description=在 Search Everywhere 對話框中導航到上一個組

action.QuickActionPopup.text=顯示快速操作彈出視窗
action.NavBar-selectHome.text=選擇第一項
action.NavBar-selectEnd.text=選擇最後一項
action.NavBar-selectUp.text=打開相應的彈出選單
action.NavBar-selectDown.text=打開相應的彈出選單
action.NavBar-selectLeft.text=選擇上一項
action.NavBar-selectRight.text=選擇下一項
action.NavBar-cancel.text=關閉浮動導航欄
action.NavBar-return.text=對選定項執行操作
action.NavBar-navigate.text=從選定項導航
action.CollapseExpandableComponent.text=摺疊組件
action.ExpandExpandableComponent.text=展開組件
action.ShowColorPicker.text=顯示取色器
action.ToolwindowSwitcher.text=工具視窗切換器
action.QuickDocCopy.text=複製快速文檔
action.OpenElementInNewWindow.text=在新編輯器視窗中打開
action.ForceRefresh.text=強制刷新
action.Diff.OpenDiffInEditor.text=作為編輯器頁籤打開選定的差異請求
action.Diff.ShowSettingsPopup.text=顯示差異設定彈出視窗…
action.Diff.ShowInExternalTool.text=在外部工具中顯示差異
action.ScrollTreeToCenter.text=滾動到中心
action.IconsLoadTime.text=日誌圖標載入時間
action.NewDummyProject.text=新建虛擬專案
action.NextTemplateParameter.text=下一個實時模板參數
action.PrevTemplateParameter.text=上一個實時模板參數
action.Performance.DumpThreads.text=轉儲執行緒
action.CollectTroubleshootingInformation.text=收集故障排除資訊
action.WelcomeScreen.OpenSelected.text=打開選定項
action.WelcomeScreen.NewGroup.text=新建專案組
action.WelcomeScreen.EditGroup.text=編輯…
action.WelcomeScreen.ChangeProjectIcon.text=更改專案圖標…
action.WelcomeScreen.CopyProjectPath.text=複製路徑
action.WelcomeScreen.RemoveSelected.text=從最近的專案中移除
action.JBTabsDemo.text=JBTabs 演示
action.JTabbedPaneDemo.text=JTabbedPane 演示
action.DumbMode.text=沉默模式
action.LaggingMode.text=滯後模式
action.AddInlayInternalAction.text=添加嵌入…
action.EditorRenderingBenchmarkAction.text=編輯器渲染基準
action.NotificationTestAction.text=添加測試通知
action.LabelSizeDemoAction.text=測試標籤大小
action.TestMessageBoxAction.text=顯示測試對話框
action.ComponentPanelTestAction.text=顯示標準面板
action.ResetGotItTooltips.text=重置“知道了”工具提示
action.CloseGotItTooltip.text=關閉“知道了”工具提示
action.CheckMessagesButtonsOrderAction.text=檢查訊息按鈕順序
action.ShowDelayedMessageInternalAction.text=顯示延遲訊息
action.ManualMacMessagesTest.text=用於測試 Mac 訊息的手動測試
action.MacMessagesSequencesTest.text=測試 Mac 訊息序列
action.FocusDebugger.text=啟動焦點調試器
action.DumpFocusableComponentHierarchyAction.text=轉儲可聚焦組件層次結構
action.ChooseRuntime.text=選擇 IDE 的啟動 Java 執行時…
action.FocusTracer.text=啟動焦點跟踪
action.LogFocusRequests.text=日誌焦點請求
action.UiInspector.text=UI 檢查器(&I)
action.ToggleUiInspectorHierarchyTrace.text=切換 UI 檢查器層次結構跟踪
action.ToggleUiInspectorHierarchyTrace.text.enable=啟用 UI 檢查器層次結構跟踪
action.ToggleUiInspectorHierarchyTrace.text.disable=禁用 UI 檢查器層次結構跟踪
action.GrayFilterConfig.text=灰色篩選器(&G)
action.TextGrayFilterConfig.text=文本灰色篩選器(&T)
action.ShowSplash.text=顯示初始頁面
action.ShowAboutPopupInDebugModeAction.text=在調試模式下顯示“關於”彈出視窗
action.ValidationTest.text=驗證對話框測試
action.MacMessagesTest.text=測試 Mac 訊息
action.ColorBlindnessTest.text=測試色盲
action.TreeExpandAll.text=展開樹
action.UIDefaults.text=LaF 預設設定
action.RulerGuide.text=標尺參考線
action.WriteActionUnderProgress.text=正在測試寫入操作
action.TestProgressWindow.text=測試進度視窗
action.TestGestureAction.text=測試手勢操作
action.TestDndAction.text=測試 Dnd
action.AnimatorTestAction.text=測試 Animator
action.PositionTrackerTestAction.text=測試位置跟踪器
action.ShowProgressTestDialogAction.text=測試進度指示器
action.ShowSouthPanelTestDialogAction.text=測試 DialogWrapper 南側面板
action.TestTextFieldAction.text=測試文本欄位
action.ShowNotificationIconsDialogAction.text=測試通知圖標
action.DebugMigLayoutAction.text=UI DSL 調試模式
action.WebBrowser.text=顯示 Web 瀏覽器(&W)
action.ImageDuplicates.text=尋找圖片重複項
action.ShowNonRetinaImages.text=顯示非視網膜圖片
action.ShowUpdateDialogAction.text=顯示“更新”對話框
action.ApplyFixedWindowSize.text=套用特定大小
action.ConfigureDefaultSize.text=配置預設大小…
action.ShowEditorHighlighterTokens.text=顯示編輯器螢光筆令牌
action.DirDiffMenu.SynchronizeDiff.text=同步選定項
action.DirDiffMenu.SynchronizeDiff.All.text=全部同步
action.DirDiffMenu.SetCopyToRight.text=設定複製到右側
action.DirDiffMenu.SetCopyToLeft.text=設定複製到左側
action.DirDiffMenu.SetDelete.text=設定刪除
action.DirDiffMenu.SetNoOperation.text=設定不執行任何操作
action.DirDiffMenu.MirrorToRight.text=設定鏡像到右側
action.DirDiffMenu.MirrorToLeft.text=設定鏡像到左側
action.DirDiffMenu.SetDefault.text=設定預設值
action.DirDiffMenu.WarnOnDeletion.text=刪除時發出警告
action.DirDiffMenu.EnableLeft.text=在左側顯示新檔案
action.DirDiffMenu.EnableRight.text=在右側顯示新檔案
action.DirDiffMenu.EnableEqual.text=顯示相同的檔案
action.DirDiffMenu.EnableNotEqual.text=顯示差異
action.DirDiffMenu.CompareNewFilesWithEachOtherAction.text=相互比較新檔案
action.DirDiffMenu.CancelComparingNewFilesWithEachOther.text=取消相互比較新檔案
action.OpenBlankEditorInBlankDiffWindow.text=切換到空白編輯器
action.OpenFileEditorInBlankDiffWindow.text=切換到檔案…
group.OpenRecentEditorInBlankDiffWindow.text=切換到“最近”
action.SwapSidesInDiffWindow.text=交換兩側
action.ToggleThreeSideInBlankDiffWindow.text=切換三向查看器
action.ToggleThreeSideInBlankDiffWindow.text.enable=切換到三向查看器
action.ToggleThreeSideInBlankDiffWindow.text.disable=切換到兩向查看器
action.SwapThreeWayColorModeInDiffWindow.text=更改三向查看器模式
action.Rerun.text=重新執行
action.RerunTests.text=重新執行測試
action.MaximizeActiveDialog.text=最大化/恢復活動對話框
action.SelectInProjectView.text=在專案檢視中選擇檔案
action.SelectInProjectView.description=在專案檢視中選擇上下文檔案
action.SelectOpenedFileInProjectView.text=選擇打開的檔案
# suppress inspection \\"UnusedProperty\\" - used from SelectFileAction
action.SelectOpenedFileInProjectView.description=在專案檢視中選擇已打開的檔案
action.ShowFilterPopup.text=顯示篩選器彈出視窗
action.ShowSearchHistory.text=顯示搜尋歷史記錄
action.HidpiInfo.text=顯示 HiDPI 資訊(&H)
action.UserInvokedFullAnalysis.text=創建並立即分析堆轉儲
action.SilentHeapDumpSnapshot.text=創建並計劃堆轉儲分析 (非使用者調用)
action.NextWindow.text=啟用下一個視窗
action.PreviousWindow.text=啟用上一個視窗
action.CopyAbsolutePath.text=絕對路徑
action.CopyPathWithLineNumber.text=帶行號的路徑
action.CopyContentRootPath.text=來自內容根的路徑
action.CopySourceRootPath.text=來自源根的路徑
action.CopyTBXReference.text=工具箱 URL
action.CopyFileName.text=文件名

EmojiAndSymbols.text=表情 \\\\\\\\& 符號
action.ToggleFocusMode.text=僅高亮顯示當前宣告

group.ListActions.text=列表操作
group.TableActions.text=表操作
group.TreeActions.text=樹操作
group.PopupMenuActions.text=彈出選單操作
group.NavBarActions.text=導航欄操作
group.ScrollPaneActions.text=滾動
group.Diff.KeymapGroup.text=差異與合併
group.compare.contents.text=比較內容
group.TabsActions.text=制表符
group.TWViewModes.text=工具視窗檢視模式
group.TWViewModesLegacy.text=工具視窗傳統檢視模式 (已棄用)
group.SearchEverywhereActions.text=隨處搜尋
group.Internal.HeapAnalysis.text=堆分析
group.Internal.UI.Demos.text=演示

action.ChooseRunConfiguration.text=執行…
action.ChooseRunConfiguration.description=選擇並執行配置
action.ChooseDebugConfiguration.text=調試…
action.ChooseDebugConfiguration.description=選擇並調試配置
action.Refactorings.QuickListPopupAction.text=重構此…
action.Refactorings.QuickListPopupAction.description=包含重構操作列表的上下文感知彈出視窗

action.GeneratePattern.text=按模式生成…
action.ProjectViewEditSource.text=編輯源
action.TypeHierarchyBase.BaseOnThisType.text=基於此類型
action.MethodHierarchy.BaseOnThisMethod.text=基於此方法
action.CallHierarchy.BaseOnThisMethod.text=基於此方法
action.Debugger.RemoveAllBreakpoints.text=移除所有斷點
action.Debugger.RemoveAllBreakpointsInFile.text=移除當前檔案中的所有斷點
action.Debugger.CopyStack.text=複製堆疊
action.Vcs.Operations.Popup.Annotate.text=註解行操作
action.SendEOF.text=發送 EOF
action.ImportTests.text=匯入測試結果
action.ImportTestsFromFile.text=從檔案匯入測試
action.DumpLookupElementWeights.text=將尋找元素權重轉儲到日誌
action.RunDashboard.Run.text=執行
action.RunDashboard.Debug.text=調試
action.RunDashboard.Stop.text=停止
action.RunDashboard.EditConfiguration.text=編輯所選配置
action.RunDashboard.CopyConfiguration.text=複製配置
action.RunDashboard.HideConfiguration.text=隱藏配置
action.RunDashboard.RestoreHiddenConfigurations.text=恢復隱藏的配置
action.RunDashboard.RemoveType.text=從服務中移除配置類型
action.RunDashboard.OpenRunningConfigInNewTab.text=在新頁籤中打開執行配置
action.RunDashboard.ClearContent.text=清除內容
action.RunDashboard.RestoreConfiguration.text=恢復配置
action.RunDashboard.GroupConfigurations.text=分組配置
action.RunDashboard.UngroupConfigurations.text=對配置取消分組
action.ServiceView.GroupByContributor.text=服務類型
action.ServiceView.GroupByServiceGroups.text=服務組
action.ServiceView.OpenInNewTab.text=在新頁籤中打開
action.ServiceView.OpenEachInNewTab.text=在新頁籤中打開每個項
action.ServiceView.SplitByType.text=在新頁籤中打開每個類型
action.ServiceView.JumpToServices.text=跳轉到服務
action.ServiceView.ShowServices.text=顯示服務樹
action.RunDashboard.GroupByType.text=類型
action.RunDashboard.GroupByStatus.text=狀態
action.RunDashboard.AddType.text=執行配置類型
action.UpdateRunningApplication.text=更新正在執行的應用程式
action.TypingLatencyReport.text=輸入延遲報告
action.RetypeFile.text=重新輸入當前檔案
action.CompletionQualityStats.text=補全品質統計資訊
action.ShowControlFlowAction.text=顯示控制流

action.AnalyzePluginStartupPerformance.text=分析套件啟動性能
action.TriggerLowMemoryNotification.text=觸發低記憶體通知

action.WelcomeScreen.ManageLicense.text=管理許可證…
action.AskForLicense.text=顯示“使用者協議”對話框
action.Register.text=註冊(_R)…
action.Register.description=輸入註冊資料
group.RegistrationActions.text=註冊操作

group.TodoMainGroup.text=TODO
group.TodoViewGroupByGroup.text=分組依據
group.TouchBarDebug.ForceStepButtons.text=調試器強制步操作
group.TouchBarDebug_alt.text=使用 Alt 鍵的調試器
group.TouchBarDebug.StepButtons.text=調試器步操作
group.TouchBarDebug.text=調試器
group.TouchBarDefault_shift.text=預設使用 Shift 鍵
group.TouchBarDefault_cmd.alt.text=預設使用 Alt+Cmd 鍵
group.TouchBarDefault_cmd.text=預設使用 Cmd 鍵
group.TouchBarDefault_alt.text=預設使用 Alt 鍵
group.TouchBarDefault_ctrl.text=預設使用 Ctrl 鍵
group.TouchBarDefaultOptionalGroup.text=可選操作
group.RunnerActionsTouchbar.text=Touch Bar 執行/調試操作
group.TouchBarDefault.text=預設
group.RunDashboard.Filter.text=配置狀態
group.RunDashboard.GroupBy.text=配置
group.ServiceView.AddService.text=添加服務
group.ServiceView.OpenInNewTabGroup.text=在新頁籤中打開
group.ServiceView.Filter.text=篩選器
group.ServiceView.GroupBy.text=分組依據
group.ShowAnnotateOperationsPopupGroup.text=註解行

action.Graph.Layout.CompactOrthogonalLayouter.text=緊湊
action.Graph.Layout.HierarchicGroupLayouter.text=層次結構組
action.Graph.Layout.HierarchicLayouter.text=分層
action.Graph.Layout.OrthogonalGroupLayouter.text=正交群
action.Graph.Layout.ChannelLayouter.text=通道
action.Graph.Layout.SeriesParallelLayouter.text=串並聯
action.Graph.Layout.CircularLayouter.text=迴圈
action.Graph.Layout.CircularEdgeBundledLayouter.text=邊緣捆綁(圓形)
action.Graph.Layout.RadialLayouter.text=徑向
action.Graph.Layout.RadialEdgeBundledLayouter.text=邊緣捆綁(徑向)
action.Graph.Layout.SingleCycleLayouter.text=單迴圈
action.Graph.Layout.ARTreeLayouter.text=緊湊
action.Graph.Layout.BalloonLayouter.text=氣球
action.Graph.Layout.BalloonEdgeBundledLayouter.text=邊緣捆綁(氣球)
action.Graph.Layout.FamilyLayouter.text=系列
action.Graph.Layout.GenericLayouter.text=泛型
action.Graph.Layout.HVTreeLayouter.text=寬
action.Graph.Layout.OrganicLayouter.text=有機
action.Graph.Layout.OrganicEdgeBundledLayouter.text=邊緣捆綁(有機)
action.Graph.Layout.RandomLayouter.text=隨機
action.Graph.Layout.CustomLayouter.text=圖特定
action.Graph.Layout.Fit.Content.text=在布局後調整內容

group.Graph.CommonLayoutGroup.text=布局
group.Graph.NetsLayoutGroup.text=網狀
group.Graph.OrthogonalLayoutGroup.text=正交
group.Graph.RadialLayoutGroup.text=徑向
group.Graph.TreeLayoutGroup.text=樹
action.Graph.ApplyCurrentLayout.text=套用當前布局
action.Graph.RouteEdges.text=自動路由邊緣
action.Graph.Current.Node.Dependencies.Filter.text=顯示所選節點與依賴關係
action.Graph.Show.Edge.Labels.text=顯示邊緣標籤
action.Graph.Show.Bridges.text=顯示鏈接橋
action.Graph.Delete.text=刪除選區
action.Graph.FitContent.text=調整內容
action.Graph.SnapToGrid.text=對齊到網格
action.Graph.ShowHideGrid.text=顯示網格
action.Graph.ExportToFile.text=匯出到圖片檔案…
action.Graph.ExportToFile.description=匯出到 PNG、JPG、GIF、SVG 或 SVGZ 檔案
action.Graph.ActualSize.text=實際尺寸
action.Graph.ZoomOut.text=縮小
action.Graph.ZoomIn.text=放大

action.JsonCopyPointer.text=複製 JSON 指針
action.JsonCopyPointer.description=複製 JSON 指針

action.JsonPathEvaluateAction.text=評估 JSONPath 表達式…
action.JsonPathExportEvaluateResultAction.text=匯出結果

action.ExternalSystem.RemoveRunConfiguration.text=移除執行配置
action.ExternalSystem.EditRunConfiguration.text=編輯執行配置…
action.ExternalSystem.ShowIgnored.text=顯示忽略項
action.ExternalSystem.ShowInheritedTasks.text=顯示從子專案繼承的任務
action.ExternalSystem.GroupModules.text=組模組
action.ExternalSystem.GroupTasks.text=組任務
action.ExternalSystem.BeforeRun.text=在執行/調試之前執行…
action.ExternalSystem.BeforeRun.description=在啟動執行/調試配置之前執行選定任務
action.ExternalSystem.AfterRebuild.text=重新構建後執行
action.ExternalSystem.AfterRebuild.description=在完全重新構建後執行選定任務
action.ExternalSystem.BeforeRebuild.text=重新構建前執行
action.ExternalSystem.BeforeRebuild.description=在完全重新構建前執行選定任務
action.ExternalSystem.AfterCompile.text=構建後執行
action.ExternalSystem.AfterCompile.description=在構建後執行選定任務
action.ExternalSystem.BeforeCompile.text=構建前執行
action.ExternalSystem.BeforeCompile.description=在構建前執行選定任務
action.ExternalSystem.AfterSync.text=同步後執行
action.ExternalSystem.AfterSync.description=在專案匯入後執行選定任務
action.ExternalSystem.BeforeSync.text=同步前執行
action.ExternalSystem.BeforeSync.description=在專案匯入前執行選定任務
action.ExternalSystem.AssignRunConfigurationShortcut.text=分配快捷鍵…
action.ExternalSystem.AssignRunConfigurationShortcut.description=將快捷鍵分配給選定執行配置
action.ExternalSystem.AssignShortcut.text=分配快捷鍵…
action.ExternalSystem.AssignShortcut.description=將快捷鍵分配給選定任務
action.ExternalSystem.RunTask.text=執行任務(_R)
action.ExternalSystem.RunTask.description=執行選定任務
action.ExternalSystem.SelectProjectDataToImport.text=選擇要匯入的專案資料
action.ExternalSystem.CollapseAll.text=全部摺疊
action.ExternalSystem.ExpandAll.text=全部展開
group.ExternalSystem.ShowSettingsGroup.text=構建工具設定
action.ExternalSystem.ShowCommonSettings.text=自動重新載入設定…
action.ExternalSystem.ShowCommonSettings.description=為當前專案編輯構建工具設定

action.NewDatabaseProject.text=專案…
action.DetachDirectory.text=從專案中分離目錄…
action.AttachDirectory.text=將目錄附加到專案…
action.ConsoleView.FoldLinesLikeThis.text=像這樣折疊行
action.ManageProjectTemplates.text=管理專案模板…
action.SaveProjectAsTemplate.text=將專案另存為模板…
action.InsertRubyInjectionWithoutOutput.text=插入 '<% %>'
action.InsertRubyInjectionWithoutOutput.description=在 Erb 檔案中插入 '<% %>'
action.InsertRubyInjection.text=插入 '<%= %>'
action.InsertRubyInjection.description=在 Erb 檔案中插入 '<%= %>'
action.GemRequirements.ShowSettings.text=Ruby SDK 和 Gem
action.RubyMineDeveloperCommunity.text=開發者社區
action.RubyMineDeveloperCommunity.description=RubyMine 開發者社區論壇
action.RubyMineDemos.text=演示和教程
action.RubyMineDemos.description=查看介紹 RubyMine 功能的簡短現場演示
action.NewRubyMineDirectoryProject.text=專案…
group.Internal.PMM.text=PMM 實用工具
group.TopAnomalies.text=頂級異常
group.Internal.focusAndModality.text=焦點和模式測試
group.Internal.UI.text=UI(&U)
group.Internal.Editor.text=編輯器(&E)
group.Internal.Performance.text=性能
group.Internal.Errors.text=異常
group.Internal.text=內部操作(&I)
group.WelcomeScreen.MoveToGroup.text=移動到組
action.$Redo.text=重做
action.$Undo.text=撤消
group.Vcs.KeymapGroup.text=版本控制系統
group.InspectCodeGroup.text=檢查程式碼操作
action.OpenStatisticsEventLogAction.text=打開統計事件日誌
action.OpenStatisticsEventLogAction.description=打開具有統計事件日誌的工具視窗
action.ConfigureEventsSchemeFileAction.text=配置事件方案檔案
action.ConfigureEventsSchemeFileAction.description=載入自訂資料夾中的事件方案
action.ReportSettingsToFUS.text=將更改的設定記錄到事件日誌
action.CleanupEventsTestSchemeAction.text=清理事件測試方案
action.CleanupEventsTestSchemeAction.description=移除測試方案中註冊的所有組
action.RecordStateCollectors.text=將狀態收集器記錄到事件日誌
action.RecordStateCollectors.description=將所有狀態收集器和記錄結果調用到事件日誌
action.ShowChangedStateStatisticsAction.text=僅顯示已更改的狀態事件
action.ShowChangedStateStatisticsAction.description=調用所有狀態收集器，並僅顯示自上一個記錄以來已更改的事件
action.AddGroupToTestSchemeAction.text=將組添加到事件測試方案
action.AddGroupToTestSchemeAction.description=允許來自組的所有資料。使用它在本地測試新的收集器。
action.EditTestSchemeAction.text=編輯事件測試方案
action.EditTestSchemeAction.description=允許來自組的所有資料。使用它在本地測試新的收集器。
group.OpenEventLogFileAction.text=在編輯器中打開事件日誌
group.OpenEventLogFileAction.description=在 IDE 中打開活動事件日誌檔案
group.OpenEventsTestSchemeFileAction.description=在 IDE 中打開事件測試方案檔案
group.OpenEventsSchemeFileAction.description=在 IDE 中打開事件方案檔案
group.UpdateEventsSchemeAction.description=必要時更新伺服器中的主要事件方案。也重新載入該檔案中的事件測試方案。
action.SendEventLogStatistics.text=發送功能用法事件日誌
action.SendEventLogStatistics.description=將事件日誌檔案發送到 QA 伺服器
group.FeatureUsage.Internal.text=功能用法統計資訊
group.CleanupEventLog.text=清理事件日誌
group.CleanupEventLog.description=移除所有未發送事件日誌檔案
action.GenerateEventsScheme.text=顯示 FUS 收集器方案
action.GenerateEventsScheme.description=從正在執行的 IDE 實例中收集統計資訊收集器的方案
action.StaticIconFields.text=列出 static 欄位初始值設定項
action.ExpressionStatistics.text=收集 Java 表達式統計資訊
action.UsedIconsListing.text=列出使用的圖標
action.GenerateVisitorByHierarchy.text=生成層次結構訪問者…
group.Internal.Java.text=Java
action.CollectFUStatisticsAction.text=從收集器收集統計資訊…
action.TestParseEventsSchemeAction.text=測試解析事件方案…
action.ValidateLocalHistory.text=驗證本地歷史記錄存儲
action.FixLineSeparators.text=修復行分隔符
action.PruneEmptyDirectories.text=刪除空目錄
action.LoadAllVFSContent.text=載入所有 VFS 存儲的檔案內容
action.LoadAllContent.text=載入所有檔案內容
action.CheckVfsSanity.text=檢查 VFS 健全性
action.MarkFileDirty.text=將檔案標記為髒
action.DumpWatchedRoots.text=顯示監視的 VFS 根
group.Internal.VFS.text=VFS
action.TurnOnOffCachedValueProfilerAction.text=打開快取值分析器
action.DumpScreenConfiguration.text=轉儲螢幕配置
action.ScanSourceCommentsAction.text=轉儲專案中的所有註釋
action.DumpExtensions.text=轉儲副檔名
group.Internal.Dump.text=轉儲
group.Internal1.text=IDEA 內部操作
action.FindUsedTestData.text=尋找未使用的測試資料
action.ShowDiscoveredTests.text=顯示受影響的測試
action.RenameAction.text=重命名…
action.LightEditExitAction.text=退出(&X)
action.LightEditNewFileAction.text=新建(&N)
action.FileChooser.LightEditGotoOpenedFile.text=選擇打開的檔案
action.LightEditOpenFileInProjectAction.text=在專案中打開檔案…
action.SaveAs.text=另存為…
action.AttachProject.text=附加專案…
action.DumpVfsInfoForExcludedFilesAction.text=轉儲排除根下檔案的 VFS 內容
action.ResetFilterAction.text=重置篩選器
action.ChangeSortingAction.text=按名稱排序
action.RestoreShelvedChange.text=恢復
action.ComputeVirtualFileNameStatAction.text=計算 VF 名稱統計資訊
action.CustomizeUIAction.text=自訂選單和工具欄…
action.ShowDetailedInformationAction.text=顯示間接依賴項
action.RemoveFromScopeAction.text=從範圍中移除
action.AddToScopeAction.text=添加到範圍
action.DumpConfigurationTypesAction.text=轉儲配置
action.DumpDirectoryInfoAction.text=轉儲目錄資訊
action.DumpInspectionDescriptionsAction.text=轉儲檢查描述
action.DumpIntentionsAction.text=轉儲意圖
action.DumpFormattingModelAction.text=轉儲格式化模型
action.ConfigureScopesAction.text=配置…
action.MaintenanceAction.text=維護
action.ReopenClosedTabAction.text=重新打開關閉的頁籤
action.SeverityEditorDialogAction.text=顯示嚴重性編輯器
action.ConfigureTemplatesAction.text=配置實時模板…
action.ShowFontsUsedByEditor.text=顯示編輯器使用的字體
action.ShowFontsUsedByEditor.description=允許找出編輯器中實際使用的回退字體

action.Profiler.OpenMergedCalleesAction.text=方法合並被調用方
action.Profiler.OpenMergedCalleesAction.description=在新頁籤中打開選定的方法合並被調用方樹
action.Profiler.ExcludeCallAction.text=排除調用
action.Profiler.ExcludeSubTreeAction.text=排除子樹
action.Profiler.FocusOnCallAction.text=聚焦於調用
action.Profiler.FocusOnSubtreeAction.text=聚焦於子樹
action.Profiler.FocusOnSubtreeAction.description=在新頁籤中打開選定的子樹
action.Profiler.OpenBackTracesAction.text=方法回溯
action.Profiler.OpenBackTracesAction.description=在新頁籤中打開選定的方法回溯樹

action.OpenMouseWheelSmoothScrollSettings.text=平滑滾動選項
save.file.as.template=將檔案另存為模板

action.DupLocate.text=定位重複項(_L)…
action.DupLocate.description=尋找專案中的重複程式碼
action.InspectionFilterAction.filter.inspections.text=篩選器檢查
action.InspectionFilterAction.filter.by.language.text=按語言篩選

action.AnnotateStackTraceAction.show.files.modification.info.text=顯示檔案修改資訊

group.ProblemsView.Options.text=檢視選項
group.ProblemsView.Options.description=允許對問題進行分類和篩選
action.ProblemsView.AutoscrollToSource.text=一鍵打開檔案
action.ProblemsView.AutoscrollToSource.description=為所選檔案打開編輯器，並在更改選擇後導航到選定問題
action.ProblemsView.ShowPreview.text=打開編輯器預覽
action.ProblemsView.ShowPreview.description=為所選檔案打開預覽，並在更改選擇後導航到選定問題
action.ProblemsView.GroupByToolId.text=按檢查分組
action.ProblemsView.GroupByToolId.description=允許按檢查對問題分組
action.ProblemsView.SortFoldersFirst.text=資料夾總在最前面
action.ProblemsView.SortFoldersFirst.description=單獨對檔案和資料夾排序
action.ProblemsView.SortBySeverity.text=按嚴重程度排序
action.ProblemsView.SortBySeverity.description=允許按嚴重程度對問題進行排序
action.ProblemsView.SortByName.text=按名稱排序
action.ProblemsView.SortByName.description=允許按名稱對問題進行排序
action.ProblemsView.QuickFixes.text=顯示快速修復
action.ProblemsView.QuickFixes.description=顯示所選問題的可用快速修復
action.ProblemsView.CopyProblemDescription.text=複製問題描述
action.ProblemsView.CopyProblemDescription.description=將問題描述複製到剪貼簿

group.Patch.MainMenu.text=補丁檔案

action.LoadUnloadModules.text=載入/移除模組…
group.ArrangementRulesGroup.text=排列規則
group.FileChooserToolbar.text=檔案選擇器

action.EditorTranspose.text=轉置
action.EditSourceNotInEditor.text=編輯源(不在編輯器中)
action.ActivateFindToolWindow.text=尋找
action.ActivateRunToolWindow.text=執行
action.ActivateDebugToolWindow.text=調試
action.ActivateHierarchyToolWindow.text=層次結構
group.RunContextGroupMore.text=更多執行/調試
group.RevealGroup.text=打開於
group.OpenInBrowserGroup.EditorTabPopup.text=瀏覽器
action.ResetWindowsDefenderNotification.text=重置 Windows Defender 通知
action.FindSelectionInPath.text=在檔案中尋找

group.Internal.Trust.text=原始碼安全性
action.UnsureProject.text=不確定
action.TrustProject.text=信任
action.UntrustProject.text=不信任
action.FixWSLFirewall.text=修正 WSL 防火牆設定

action.RunConfigurationTemplatesForNewProjects.MainMenu.text=執行配置模板…
action.TemplateProjectStructure.MainMenu.text=結構…
action.ClickLink.text=點擊鏈接

action.SetCaretVisualAttributesInternalAction.text=設定文本游標視覺特性…
action.XDebugger.PreviewTab.text=在預覽頁籤中打開檔案
group.Diff.Binary.Settings.text=設定
action.Graph.MergeEdges.BySources.text=按源
action.Graph.MergeEdges.ByTargets.text=按目標
group.Graph.MergeEdgesGroup.text=合併邊緣
action.DockToolWindow.text=Dock
action.Unscramble.EditorPopup.text=堆疊跟踪或執行緒轉儲(_S)…
group.AnalyzeActionsPopup.text=分析程式碼
action.Vcs.RunCommitChecks.text=執行提交檢查
action.Help.JetBrainsTV.templateText=YouTube 上的 {0}
action.DefaultBundleIndex.text=生成預設捆綁操作列表
action.Scratch.ShowFilesPopup.text=顯示臨時檔案
action.Scratch.ShowFilesPopup.description=在彈出視窗中顯示臨時檔案
action.Scratch.ExportToScratch.text=匯出到臨時檔案
action.Scratch.ExportToScratch.description=作為文本匯出到新的臨時檔案
action.RunToolbarWidgetAction.text=執行/調試微件
action.RunToolbarProcessStartedAction.text=活動進程
action.RunToolbarRunConfigurationsAction.text=添加配置…
action.RunToolbarRerunAction.text=重新執行
action.RunToolbarStopAction.text=停止
action.RunToolbarMainMultipleStopAction.text=停止
action.RunToolbarResumeAction.text=恢復
action.RunToolbarPauseAction.text=暫停
group.Graph.AppearanceGroup.text=外觀
group.Graph.EdgeRealizerGroup.text=邊緣形狀
action.Graph.EdgeRealizer.ArcEdgeRealizer.text=弧形
action.Graph.EdgeRealizer.BezierEdgeRealizer.text=貝塞爾曲線
action.Graph.EdgeRealizer.QuadCurveEdgeRealizer.text=二次曲線
action.Graph.EdgeRealizer.SplineEdgeRealizer.text=樣條
action.Graph.EdgeRealizer.StraightPolylineEdgeRealizer.text=直多段線
action.Graph.EdgeRealizer.SmoothedPolylineEdgeRealizer.text=平滑多段線
group.LocalChangesView.ShowOnDoubleClick.text=雙擊時顯示
action.LocalChangesView.ShowOnDoubleClick.EditorPreview.text=雙擊時顯示差異
action.LocalChangesView.ShowOnDoubleClick.EditorPreview.ToolwindowPopup.text=差異
action.LocalChangesView.ShowOnDoubleClick.Source.text=雙擊時顯示源
action.LocalChangesView.ShowOnDoubleClick.Source.ToolwindowPopup.text=源
group.Graph.LayoutOrientationGroup.text=方向
action.Graph.LayoutOrientation.BottomToTop.text=🠉 從下到上
action.Graph.LayoutOrientation.TopToBottom.text=🠋 從上到下
action.Graph.LayoutOrientation.LeftToRight.text=🠊 從左到右
action.Graph.LayoutOrientation.RightToLeft.text=🠈 從右到左
action.Graph.CopyEntireDiagramToClipboard.text=將圖表複製到剪貼簿
action.Graph.CopyDiagramSelectionToClipboard.text=將選區複製到剪貼簿
action.Diff.ShowDiffPreview.description=選區變更時取代差異內容
action.Diff.ShowStandaloneDiff.text=在新頁籤或視窗中顯示差異
action.Diff.ShowStandaloneDiff.description=在新頁籤或視窗中打開每個選區的差異
action.Diff.ShowStandaloneDiff.tab.text=在新頁籤中顯示差異
action.Diff.ShowStandaloneDiff.tab.description=在新頁籤中打開每個選區的差異
action.Diff.ShowStandaloneDiff.window.text=在新窗口中顯示差異
action.Diff.ShowStandaloneDiff.window.description=在新窗口中打開每個選區的差異
action.PluginManagerFiltersConfigureTrustOnlyJetBrainsDebugAction.text=Org 套件篩選器: 僅信任 JetBrains
action.PluginManagerFiltersConfigureResetTrustDebugAction.text=Org 套件篩選器: 重置
action.RunToolbarHotSwapAction.text=熱交換
action.CloseContent.EditorTabPopup.text=關閉 (_C)
action.MarkVfsCorrupted.text=將 VFS 標記為已損壞
action.ForceIndexRescanning.text=同步索引
action.ForceIndexRebuild.text=重建索引
action.Vcs.Diff.ShowCombinedDiff.text=顯示組合差異
action.Vcs.Diff.ShowCombinedDiff.description=在一處顯示全部所選變更的差異
group.ProjectView.ToolWindow.Appearance.Actions.text=樹外觀
action.RunToolbarShowHidePopupAction.text=同時啟動多個配置
action.RunToolbarShowHidePopupAction.show.text=顯示停靠的配置
action.RunToolbarShowHidePopupAction.hide.text=隱藏停靠的配置
group.MoreActionGroup.text=更多
action.CallSaul.text=修復 IDE
action.CallSaul.description=執行快取診斷並嘗試恢復其狀態
action.SwitchFileBasedIndexStorageAction.text=切換基於檔案的索引存儲
action.RunToolbarMainSlotInfoAction.text=活動進程
group.CacheRecovery.text=快取恢復
action.Table-startEditing.text=編輯表單元
action.Tree-startEditing.text=編輯樹節點
action.SearchEverywhereToolbar.searching.text=正在搜尋…
action.RunToolbarMainSlotActive.text=活動進程
group.Graph.NeighborhoodViewPopup.LayoutGroup.text=布局
group.Graph.NeighborhoodViewPopup.AppearanceGroup.text=外觀
group.Graph.BehaviourGroup.text=行為
group.Graph.ExportGroup.text=匯出圖
action.Graph.NeighborhoodViewPopup.CompactMode.text=緊湊地顯示節點
action.Graph.NeighborhoodViewPopup.SameAsModelLayouter.text=與 Main 相同
action.Graph.ShowStructureViewForSelectedNode.text=顯示所選節點的結構檢視
tiny.spacer=微型分隔
small.spacer=小型分隔
big.spacer=大型分隔
action.RunToolbarMoveToTopAction.text=將配置移至頂部
action.RunToolbarEditConfigurationAction.text=編輯配置…
action.RunToolbarRemoveSlotAction.text=移除
action.RunToolbarMainRunConfigurationsAction.text=添加配置…
action.ListPersistentStateComponents.text=列出持久狀態組件
action.Documentation.ToggleShowInPopup.text=首先顯示文檔彈出視窗
action.Documentation.ToggleShowInPopup.description=切換是否應在工具視窗之前顯示文檔彈出視窗
action.RunToolbarShowHidePopupAction.show.popup.text=顯示或隱藏停靠的配置
action.RunToolbarShowHidePopupAction.click.to.show.popup.text=點擊以顯示或隱藏停靠配置
action.RunToolbarShowHidePopupAction.click.to.open.toolwindow.text=點擊以打開進程工具視窗
action.RunToolbarShowHidePopupAction.click.to.open.combo.text=點擊以選擇執行配置
action.ProblemsView.OpenInPreviewTab.text=啟用預覽頁籤
action.EditorLookupSelectionUp.text=選擇上一個補全選項
action.EditorLookupSelectionDown.text=選擇下一個補全選項
action.JBLogin.text=JetBrains 登錄(_J)…
action.JBLogin.description=登錄 JetBrains Account
action.RunToolbarRemoveSlotAction.terminating=正在終止
action.OverrideFileTypeAction.verbose.description=將檔案 ''{0}''{1,choice,0#|1# (和 {1} 個其他檔案)}視為具有不同檔案類型的檔案
action.Vcs.Diff.ToggleDiffAligningMode.text=在並排差異中對齊變更
action.Vcs.Diff.ToggleDiffAligningMode.popup@DiffToolbar.text=對齊變更高亮顯示
action.Vcs.Diff.ToggleDiffAligningMode.description=啟用雙面差異的變更對齊
action.RunToolbarShowToolWindowTab.text=顯示進程工具視窗
action.XDebugger.ToggleEvaluateExpressionField.text=顯示評估表達式欄位
group.XDebugger.Watches.Presentation.text=演示設定
action.NewMigration.text=創建新的遷移...
group.MigrationMenu.text=遷移軟體套件和類
action.Documentation.ViewExternal.text=查看外部文檔
action.JBCefOsrMeasureFps.text=測量 OSR JCEF FPS
action.Documentation.Back.text=後退
action.Documentation.Forward.text=前進
action.Documentation.EditSource.text=編輯源
action.Documentation.ToggleAutoShow.text=在補全期間自動顯示
action.Documentation.ToggleAutoShow.description=切換是否使用補全彈出視窗自動顯示文檔
group.popup@ExpandableBookmarkContextMenu.text=書籤
action.DeleteRecentFiles.text=從最近的檔案刪除
action.DeleteRecentFiles.description=從最近的檔案中刪除選定的檔案或關閉選定的工具視窗
action.ExcludeFromProjectAction.text=從專案中排除
action.IncludeToProjectAction.text=包含到專案中
group.EditorTabsEntryPoint.text=最近的檔案、頁籤操作等
action.Documentation.KeepTab.text=保留此文檔
action.Documentation.KeepTab.description=關閉當前頁籤中的所有更新，使下一個操作調用打開新的頁籤
action.Documentation.ToggleAutoUpdate.text=從源自動更新
action.Documentation.ToggleAutoUpdate.description=選擇變更時自動刷新文檔
action.DumpInvalidTipsOfTheDay.text=轉儲無效的每日小技巧
action.CheckSuggestedPlugins.text=檢查建議的套件
group.UpdateEventsSchemeAction.text=更新事件方案
action.AnalyzeHeapDumpSnapshot.text=分析堆轉儲
action.Debugger.FocusOnFinish.text=完成後聚焦
action.Debugger.FocusOnFinish.description=預設情況下，在調試會話結束時聚焦此檢視
action.EnableMetalRendering.text=Metal 呈現流水線
group.Graph.AlignNodesGroup.text=對齊
group.Graph.DistributeNodesGroup.text=分散排列
action.Graph.AlignNodes.Top.text=頂部
action.Graph.AlignNodes.Middle.text=居中排列
action.Graph.AlignNodes.Bottom.text=底部
action.Graph.AlignNodes.Left.text=左
action.Graph.AlignNodes.Center.text=中心
action.Graph.AlignNodes.Right.text=右
action.Graph.DistributeNodes.Horizontally.text=水平排列
action.Graph.DistributeNodes.Vertically.text=垂直排列
action.GotoDeclarationOnly.MainMenu.text=宣告
action.FileChooser.ShowHidden.text=顯示隱藏的檔案和目錄
action.FileChooser.ShowHidden.description=顯示隱藏的檔案和目錄
action.RunWithDropDown.text=通過選項執行
action.StopWithDropDown.text=通過選項停止
action.ReverteOverrideFileTypeAction.text=還原檔案類型覆蓋
action.ReverteOverrideFileTypeAction.description=撤消“覆蓋檔案類型”操作並恢復舊檔案類型
action.ReverteOverrideFileTypeAction.verbose.description=撤消“覆蓋檔案類型”操作並為檔案 ''{0}''{1,choice,0#|1# (和其他 {1} 個檔案)}恢復舊的檔案類型
action.VcsQuickActionsToolbarPopup.text=版本控制
action.SegmentedVcsControlAction.text=VCS 微件
action.SearchEverywhereNewToolbarAction.text=隨處搜尋
action.Vcs.CopyCommitSubjectAction.text=複製提交主題
action.Vcs.CopyCommitSubjectAction.description=將所選提交的主題複製到剪貼簿
action.CollapsiblePanel-toggle.text=展開/摺疊可折疊面板
action.FileChooser.TogglePathBar.text=顯示/隱藏路徑輸入欄位
action.FileChooser.TogglePathBar.description=切換路徑輸入欄位的可見性
action.LibraryUsageStatistics.text=顯示匯入的庫用法資訊
action.DumpLibraryUsageStatistics.text=轉儲庫用法的統計資訊
action.UiDslShowcaseAction.text=UI DSL 展示
action.ProgressIconShowcaseAction.text=進度圖標展示
action.TestCoroutineProgress.text=測試協同程序進度
action.SearchEverywhereToolbarHotKey.hotkey=Shift+Shift"
`;

exports[`dev messages/DiffBundle.properties 1`] = `
"diff.application.usage.parameters.and.description=用法: {0} 差異 <left file> <right file> [<base file>]
merge.application.usage.parameters.and.description=用法: {0} 合併 <left file> <right file> [<base file>] <output file>

cannot.find.file.error=找不到檔案: {0}
cannot.create.file.error=無法創建檔案: {0}

dialog.title.diff.for.range=範圍的差異
diff.content.title.up.to.date=基本修訂
diff.content.title.current.range=當前

refresh.failed.message=刷新失敗: {0}

rollback.change.command.name=回滾變更
diff.content.editor.content.title=編輯器
diff.content.clipboard.content.title=來自剪貼簿
diff.clipboard.vs.editor.dialog.title=剪貼簿與編輯器
diff.content.selection.from.file.content.title={0}中的選區

diff.files.generic.request.title=變更
diff.element.qualified.name.vs.element.qualified.name.dialog.title={0} 與 {1}
merge.files.dialog.title=合併
diff.files.dialog.title=差異
diff.count.differences.status.text={0, choice, 0#沒有|1#1個|2#{0, number}個}差異
merge.differences.status.text={0, choice, 0#沒有變更|1#1 個變更|2#{0, number} 個變更}。{1, choice, 0#沒有衝突|1#1 個衝突|2#{1, number} 個衝突}。
diff.inactive.count.differences.status.text=({0} 非活動)
diff.all.differences.ignored.text=已忽略差異
diff.highlighting.disabled.text=差異高亮顯示處於關閉狀態
error.cant.show.diff.message=錯誤: 無法顯示差異
select.external.diff.program.dialog.title=選擇外部差異程序
select.external.merge.program.dialog.title=選擇外部合併程序
diff.cant.calculate.diff=無法計算差異
diff.contents.are.identical.message.text=內容相同
error.files.too.large.to.compare.text=檔案太大，無法比較
diff.contents.have.differences.only.in.line.separators.message.text=內容僅在行分隔符中有差異
diff.contents.have.differences.only.in.charset.message.text=內容僅在編碼中有差異
diff.contents.have.differences.only.in.charset.and.line.separators.message.text=內容僅在行分隔符和編碼中有差異
binary.diff.contents.are.identical.message.text=檔案內容相同
binary.diff.contents.are.different.message.text=檔案內容不同
action.presentation.diff.accept.text=接受
action.presentation.diff.revert.text=還原
action.presentation.diff.append.text=追加
action.presentation.diff.include.into.commit.text=包含到提交中
action.presentation.diff.append.to.the.side.text=追加到 {0, choice, 0#左側|1#右側}
action.presentation.merge.ignore.text=忽略
action.presentation.merge.resolve.text=解決
action.presentation.merge.resolve.using.side.text=使用{0, choice, 0#左側|1#右側} 解決
action.presentation.merge.resolve.automatically.text=自動解決
merge.dialog.all.conflicts.resolved.message.text=已解決所有衝突
merge.dialog.accept.change.command=接受變更
merge.dialog.ignore.change.command=忽略變更
merge.dialog.resolve.conflict.command=解決衝突
merge.dialog.apply.non.conflicted.changes.command=套用不衝突的變更
cancel.visual.merge.dialog.title=取消檔案合併
apply.somehow.status.message.all.applied=已解決所有區塊
apply.somehow.status.message.already.applied={0, number} 個{0, choice, 1#區塊|2#區塊}已套用
apply.somehow.status.message.cant.apply=無法套用 {0, number} 個{0, choice, 1#區塊|2#區塊}
apply.somehow.status.message.cant.apply.some=無法套用 {0, number} 個區塊，共 {1, number} 個
merge.dialog.apply.partially.resolved.changes.confirmation.message={0, choice, 0#'{1, choice, 1#有|2#有}'|1#有|2#有} {0, choice, 0#|1#1 個更改|2#{0, number} 個更改}{0, choice, 0#|1#'{1, choice, 0#|1#和 }'}{1, choice, 0#|1#1 個衝突|2#{1, number} 個衝突}未處理。\\\\n仍要儲存更改並將衝突標記為解決嗎?
apply.patch.partially.resolved.changes.confirmation.message={0, choice, 1#1 個區塊|2#{0, number} 個區塊}未處理。\\\\n要儲存更改並完成解決嗎?
apply.partially.resolved.merge.dialog.title=套用變更
merge.all.changes.processed.message.text=所有變更均已被處理。<br><a href=\\"\\">儲存變更並完成合併</a>
apply.patch.all.changes.processed.message.text=所有區塊均已被處理。<br><a href=\\"\\">儲存變更並完成解決</a>
merge.save.and.finish.button=儲存並完成(&F)
merge.continue.button=繼續(&C)
merge.color.options.background.color.label=重要
merge.color.options.ignored.color.label=已忽略
merge.color.options.dialog.title=合併顏色選項
diff.type.inserted.name=已插入
diff.type.changed.name=已更改
diff.type.deleted.name=已刪除
diff.type.conflict.name=衝突
diff.content.selected.value=所選值
diff.clipboard.vs.value.dialog.title=剪貼簿與所選值

merge.window.title.file=合併 {0}
merge.version.title.our=您的版本
merge.version.title.their=來自伺服器的變更
merge.version.title.their.with.revision=來自伺服器的變更 (修訂版 {0})
merge.version.title.base=基礎版本
merge.version.title.merged=合併版本
merge.version.title.merged.result=結果
merge.version.title.current=當前版本:
diff.version.title.before=之前
diff.version.title.after=之後
configurable.DiffSettingsConfigurable.display.name=差異與合併
configurable.ExternalDiffSettingsConfigurable.display.name=外部差異工具
settings.diff.name=差異
settings.context.lines=上下文行:
settings.go.to.the.next.file.after.reaching.last.change=到達上次更改後轉到下一個檔案
settings.merge.text=合併
settings.automatically.apply.non.conflicting.changes=自動套用不衝突的變更
settings.highlight.modified.lines.in.gutter=在間距中高亮顯示修改的行
settings.external.diff.enable.external.diff.tool=啟用外部差異工具
settings.external.diff.path.to.executable=\\\\ 可執行檔案路徑:
settings.external.diff.parameters=參數:
settings.external.diff.use.by.default=預設情況下使用
settings.external.diff.test.diff=測試差異
settings.external.diff.test.three.side.diff=測試三向差異
settings.external.diff.enable.external.merge.tool=啟用外部合併工具
settings.external.diff.path.to.executable.merge=\\\\ 可執行檔案路徑:
settings.external.diff.parameters.merge=參數:
settings.external.diff.trust.process.exit.code=信任進程退出程式碼
settings.external.diff.test.merge=測試合併
settings.diff.tools.parameters=<html>不同的工具具有不同的參數。以正確順序指定所有必要的參數至關重要<br><b>%1</b> - 左側 (本地變更)<br><b>%2</b> - 右側 (伺服器內容)<br><b>%3</b> - 基礎 (當前版本，無本地變更)<br><b>%4</b> - 輸出 (合併結果)</html>
settings.external.diff.left.file.content=左側檔案內容
settings.external.diff.right.file.content=右側檔案內容
settings.external.diff.base.file.content=基檔案內容
settings.external.diff.original.output.file.content=原始輸出檔案內容
settings.external.diff.merge.conflict.resolve.was.canceled=合併衝突解決已取消。
settings.external.diff.merge.conflict.resolve.successful=合併衝突解決成功。\\\\n已解決的內容為:\\\\n{0}
settings.external.diff.test.complete=測試完成
error.cannot.show.diff=無法顯示差異
error.cannot.show.merge=無法顯示合併
error.message.cannot.show.diff=無法顯示差異
error.message.cannot.show.merge=無法顯示合併
label.cant.show.diff.with.description=無法顯示差異: {0}
label.cant.show.merge.with.description=無法顯示合併: {0}
action.Anonymous.text.apply.non.conflicting.changes=套用不衝突的變更:
action.presentation.RefreshDirDiffAction.text=刷新
continue.merge=繼續合併
discard.changes.and.restart.merge=放棄更改並重新啟動合併
update.highlighting.settings=更新高亮顯示設定
changing.highlighting.requires.the.file.merge.restart=更改高亮顯示需要重新啟動檔案合併。是否放棄未儲存的變更並重新啟動合併?
apply.changes.and.mark.resolved=套用更改並標記為已解決
synchronize.editors.settings=同步編輯器設定
directory.viewer=目錄查看器
side.by.side.viewer=並排查看器
compare.by=比較依據:
hide.this.notification=隱藏此通知
error.viewer=錯誤查看器
directory.diff=目錄差異
use.space.button.to.change.operation=使用空格按鈕更改操作
use.space.button.or.mouse.click=使用空格按鈕或滑鼠點擊來更改選定元素的操作。按回車鍵執行。
can.t.copy.file=無法複製檔案
copy.content.to.side=將內容複製到{0, choice, 0#左側|1#右側}
merge.conflict.is.outdated=合併衝突已過時。在衝突解決開始之前恢復檔案內容?
binary.file.viewer=二進制檔案查看器
highlighting.level=高亮顯示級別
editor.settings=設定
highlight.words=高亮顯示單詞
synchronize.document.and.its.fragment=同步文檔及其片段
synchronize.document.and.its.fragment.range.error=選擇範圍無效
vcs.marker.changed.line=VCS 標記: 更改的行
do.not.ask.me.again=不再詢問
delete.0.items=刪除 {0} 項?
confirm.delete=確認刪除
data.has.been.changed.externally.reloading.data=資料已在外部更改。正在重新載入資料…
select.file.to.compare=選擇要比較的檔案
diff.actions=差異操作
can.t.show.diff.in.external.tool=無法在外部工具中顯示差異
can.t.finish.merge.resolve=無法完成合併解析
disable.editing=禁用編輯
collapse.unchanged.fragments=摺疊未更改的片段
synchronize.scrolling=同步滾動
compare.selected.new.files=將左側和右側的所選新檔案相互比較。
compare.0.with.1=比較 ''{0}'' 和 ''{1}''
unified.viewer=統合查看器
mark.as.resolved=標記為已解決
merge.in.external.tool=在外部工具中合併
press.mark.as.resolve=在外部工具中解決完衝突時，按“標記為已解決”
launching.external.tool=正在啟動外部工具…
waiting.for.external.tool=正在等待外部工具…
can.t.load.some.changes=無法載入某些變更
directory.diff.actions=目錄差異操作
can.t.show.merge.in.external.tool=無法在外部工具中顯示合併
file.is.too.big.and.there.are.too.many.changes=檔案太大且變更太多。
dirdiff.mode.size.and.timestamp=大小和時間戳
dirdiff.mode.size=大小
dirdiff.mode.text=文本
dirdiff.mode.binary.content=二進制內容
button.dirdiff.filter=過濾(&F):
option.inherit.ignored.color=繼承忽略的顏色
error.content.decoded.with.wrong.charset=內容解碼出錯(使用 ''{0}'' 字符集)
label.default.diff.editor.tab.name=差異
diff.file.editor.name=差異
filetype.diff.description=差異
message.init.merge.content.command=初始化合併內容
message.replace.change.command=取代變更
message.resolve.simple.conflicts.command=解決簡單的衝突變更
message.use.selected.changes.command={0}所選變更
message.do.in.merge.command=合併時 {0}
action.presentation.go.to.change.text=轉到變更
button.continue.merge=繼續合併
button.cancel.merge=取消合併
button.discard.changes.and.do=放棄變更並{0}
label.merge.unsaved.changes.discard.and.do.anyway=結果檔案中有未儲存的變更。放棄變更並繼續{0}嗎?
button.merge.resolve.apply=套用
button.merge.resolve.accept.right=接受右側
button.merge.resolve.accept.left=接受左側
button.merge.resolve.cancel=取消
tooltip.merge.ctrl.click.to.resolve.conflict=Ctrl+點擊來解決衝突
error.operation.canceled=操作已被取消
error.cant.show.diff.for.unknown.file=無法顯示未知檔案類型的差異
error.cant.show.diff.file.not.found=無法顯示差異: 找不到檔案
error.cant.show.diff.content.not.found=無法顯示差異: 找不到內容
error.cant.show.diff.cant.load.revision.content=無法獲取此修訂中的內容
error.cant.show.diff.cant.show.for.directory=無法顯示目錄的差異
error.cant.show.merge.operation.not.supported=無法顯示合併衝突: 此操作不受支援
error.cant.show.merge.project.not.found=無法顯示合併衝突: 未知專案類型
error.cant.show.merge.file.not.found=無法顯示合併衝突: 找不到檔案
error.cant.show.dirdiff.preview.cant.load.content=無法獲取內容
button.associate.file.type=關聯
button.reload.diff.request=重新載入
option.highlighting.level.inspections=檢查
option.highlighting.level.syntax=語法
option.highlighting.level.none=無
option.highlighting.policy.lines=高亮顯示行
option.highlighting.policy.words=高亮顯示單詞
option.highlighting.policy.split=高亮顯示拆分的變更
option.highlighting.policy.symbols=高亮顯示字符
option.highlighting.policy.none=不高亮顯示
option.ignore.policy.none=不忽略
option.ignore.policy.trim=修整空白
option.ignore.policy.whitespaces=忽略空格
option.ignore.policy.whitespaces.empty.lines=忽略空格和空行
option.ignore.policy.formatting=忽略格式化
option.three.side.color.policy.left.to.right=左到右
option.three.side.color.policy.merge.conflict=合併衝突
option.three.side.color.policy.merge.resolved=解決的合併衝突
notification.action.text.blank.diff.select.file=選擇檔案…
notification.action.text.blank.diff.recent=最近
editing.viewer.hint.enable.editing.text=此檢視為唯讀。<a href=\\"\\">啟用編輯</a>
column.dirdiff.name=名稱
column.dirdiff.size=大小
column.dirdiff.date=日期
label.dirdiff.loading.file=正在載入… {0}
configurable.diff.collapse.unchanged.ranges.disable=禁用
error.file.is.too.large.only.preview.is.loaded=檔案太大。僅載入預覽。
error.can.not.calculate.diff.operation.canceled=無法計算差異。操作已取消。
error.can.not.calculate.diff.file.too.big=無法計算差異。檔案太大且變更太多。
progress.title.loading.requests=正在載入請求
notification.status.content.removed=內容已移除
notification.status.content.added=內容已添加
button.hide.notification=隱藏
notification.you.can.disable.this.feature.in.0=您可以在 {0} 中禁用此功能
label.diff.settings.path=設定 | 工具 | 差異和合併
label.diff.settings.path.macos=偏好設定 | 工具 | 差異和合併
press.again.to.go.to.the.previous.file=再按一次轉到上一個檔案
press.again.to.go.to.the.next.file=再按一次轉到下一個檔案
error.cant.show.file=無法顯示檔案
error.conflict.is.not.valid.and.no.longer.can.be.resolved=衝突無效，無法再解決。
button.abort.resolve=中止解決
error.cant.resolve.conflicts.in.a.read.only.file=無法解決唯讀檔案中的衝突
action.merge.apply.non.conflicts.left.text=左側
action.merge.apply.non.conflicts.right.text=右側
action.merge.apply.non.conflicts.all.text=所有
diff.utf.charset.name.bom.suffix={0} BOM
blank.diff.recent.content.summary.text.date={0} ({1})
blank.diff.recent.content.summary.text.length.date={0} ({1} 字符，{2})
advanced.settings.vcs=版本控制
advanced.setting.show.diff.as.editor.tab=作為編輯器頁籤打開差異
advanced.setting.show.diff.as.editor.tab.description=如果啟用，請使用編輯器頁籤代替框架視窗來顯示差異
combined.side.by.side.viewer=拆分
combined.unified.viewer=統合
diff.files.count.files.in.text=在 {0} 中
diff.files.count.hyperlink.text={0} 個檔案
option.highlighting.policy.group.name=高亮顯示模式
option.ignore.policy.group.name=忽略變更
action.Combined.Diff.PrevChange.text=上一個檔案
action.Combined.Diff.NextChange.text=下一個檔案"
`;

exports[`dev messages/GitBundle.properties 1`] = `
"git4idea.vcs.name=Git
git4idea.vcs.name.with.mnemonic=&Git
activity.name.rebase=變基

abort=中止
abort.operation.progress.title=正在中止 {0} 進程
abort.operation.dialog.title=中止 {0}
abort.operation.dialog.msg=中止 {0}{1}?
abort.operation.failed={0} 中止失敗
abort.operation.succeeded={0} 中止成功
abort.operation.merge.name=合併
abort.operation.cherry.pick.name=優選
abort.operation.revert.name=還原
abort.operation.indicator.text=git {0} --abort{1}

add.adding=正在添加檔案…

annotate.cannot.annotate.dir=無法註解目錄
annotate.output.lack.data=第 {0} 行的輸出缺少必要的資料
annotate.line.mismatch.exception=正在為第 {0} 行添加資訊，但應當為第 {1} 行添加資訊

apply.changes.would.be.overwritten=您的本地變更將被 {0} 覆蓋。\\\\n提交您的變更，或儲藏變更以繼續。
apply.changes.operation.successful={0}成功
apply.changes.nothing.to.do=沒要有{0}的內容
apply.changes.resolving.conflicts.progress.title=正在解決衝突…
apply.changes.applied.for.commits={0} {1,choice,1#項提交|2#{1,number} 項提交} 來自於 {2}
apply.changes.operation.canceled={0} 已取消
apply.changes.operation.failed={0} 失敗
apply.changes.operation.performed.with.conflicts={0}已執行，但存在衝突
apply.changes.operation.successful.for.commits=但是，對以下{1, choice,1#提交|2#提交}成功進行了{0}:
apply.changes.skipped={0} {1,choice,1#被|2#被}跳過，因為所有變更已被{2}。
apply.changes.everything.applied={0} 中的所有變更已被{1}

apply.conflict.dialog.description.label.text=在由 {2} 執行的提交 {1} 的{0}過程中發生衝突{3}

blob.not.found=找不到 Blob: {0} - {1}

changes.retrieving=檢索修訂 {0} 的變更

commit.action.commit.and.rebase.text=提交並變基…
commit.action.name=提交 (&I)
commit.author.diffs=<html>作者與預設不同</html>
commit.author=作者(&A):
commit.partial.merge.message=不允許在{0,choice,1#合併|2#優選}期間進行部分提交。\\\\n提交中未包含以下檔案。\\\\n要在包含所有檔案的情況下執行提交嗎?
commit.partial.merge.title=部分合併提交
common.current.branch.tooltip=當前已簽出的分支。
common.current.branch=當前分支:
common.git.root.tooltip=選擇 Git VCS 根
common.git.root=Git 根(&R):
common.no.active.branch=<無活動分支>
common.refreshing=正在刷新檔案
common.suffix.in.one.repository=在 {0} 中
common.suffix.in.several.repositories=在 {0} 個版本庫中

conflict.resolver.unmerged.files.check.error.notification.description.text=由於錯誤，無法檢查工作樹中是否有未合併的檔案。{0}

login.dialog.label.login.to.url=登錄 {0}
login.dialog.button.login=登錄
login.dialog.prompt.enter.credentials=輸入憑證:
login.dialog.select.login.way.credentials=輸入憑證
login.dialog.select.login.way.use.helper=使用憑證幫助程序
login.dialog.username.label=用戶名：
login.dialog.password.label=密碼:
login.dialog.error.username.cant.be.empty=用戶名不能為空
login.dialog.error.password.cant.be.empty=密碼不能為空
login.dialog.login.with.selected.provider=使用 {0} 登錄…

computing.annotation=正在計算 {0} 的註解
diff.find.error=正在尋找差異的修訂: {0}
error.dialog.title=錯誤
error.list.title={0} 錯誤:
error.occurred.during=''{0}'' 時出錯
errors.message.item=\\\\n{0}
errors.message=Git 操作以多個錯誤結束: {0}

# suppress inspection \\"UnusedProperty\\": used by 3-party plugins
fetch.action.name=獲取
fetch.pruned.obsolete.remote.references=刪除過時的遠端 {0,choice,1#引用|2#引用}: {1}

# suppress inspection \\"UnusedProperty\\": used by 3-party plugins
find.git.error.title=執行 Git 時出錯
# suppress inspection \\"UnusedProperty\\": used by 3-party plugins
find.git.success.title=Git 執行成功
# suppress inspection \\"UnusedProperty\\": used by 3-party plugins
find.git.unsupported.message=<html><tt>{0}</tt><br>此版本不受支援，某些套件功能可能無法工作。<br>支援的最低版本是 <em>{1}</em>。</html>

local.changes.freeze.message.git.operation.prefix=Git {0}
git.error.exit=Git 進程退出，程式碼為 {0}
git.running=執行: {0}

init.destination.directory.description=選擇將在其中創建新 Git 版本庫的目錄。
init.destination.directory.title=創建 Git 版本庫
init.warning.already.under.git=所選目錄 <tt>{0}</tt> 已在 Git 下。\\\\n確定要創建新的 VCS 根嗎?
init.warning.title=Git Init
initializing.title=正在初始化版本庫…

mention.in=\\\\ ({0} 內)

merge.action.name=合併
merge.action.operation.failed=Git {0} 失敗
merge.action.before.update.label=更新前
merge.action.after.update.label=更新後
merge.branch.title=合併變更
merge.branch.into.current.title=合併到 {0}
merge.branch.loading.branches.progress=正在載入未合併的分支...
merge.no.branch.selected.error=應選擇該合併分支。
merge.no.matching.branch.error=沒有符合分支。
merge.commit.message.label=提交訊息:
merge.options.modify=修改選項
merge.options.modify.popup.title=添加合併選項
merge.option.no.ff=即使可以快進也創建合併提交
merge.option.ff.only=僅在可以快進時合併
merge.option.squash=為所有合併變更創建一個提交
merge.option.msg=指定合併提交的訊息
merge.option.no.commit=不提交合併結果
merge.option.no.verify=繞過預合併和提交訊息掛鈎
merge.branch.popup.empty.text=無分支
merge.branch.field.placeholder=指定分支
merge.tool.column.status.deleted=已刪除
merge.tool.column.status.modified=已修改
merge.tool.column.theirs.status=他人的變更
merge.tool.column.theirs.with.branch.status=他人的變更({0})
merge.tool.column.yours.status=您的變更
merge.tool.column.yours.with.branch.status=您的變更({0})
merging.title=將變更合併到 {0}
paths.affected.title=提交 {0} 中受影響的路徑
pull.action.name=拉取
pull.button=拉取
pulling.title=從 {0} 中拉取變更
pull.branch.not.selected.error=應選擇要從中拉取的分支。
pull.branch.nothing.to.pull=無分支
pull.branch.no.matching.remotes=無遠端
pull.branch.field.placeholder=指定分支
pull.options.modify.popup.title=添加拉取選項
pull.option.ff.only=僅在可以快進時合併
pull.option.no.ff=即使可以快進也創建合併提交
pull.option.squash.commit=為所有拉取變更創建一個提交
pull.option.no.commit=合併，但不提交結果
pull.option.rebase=在當前分支的頂部變基傳入變更

pull.dialog.title=拉取
pull.dialog.with.branch.title=拉取到 {0}
pull.dialog.fetch.shortcuts.hint=按 {0} 更新分支

operation.action.message=多個 Git 根有未完成的 {0} 進程，請選擇要對其執行操作的根。

rebase.abort.and.rollback.dialog.message=僅中止 {0} 中的變基還是同時回滾 {1} 中的變基?
rebase.abort.and.rollback.dialog.no.button.text=僅中止
rebase.abort.and.rollback.dialog.yes.button.text=中止並回滾
rebase.abort.dialog.message=中止{0} 中的變基?
rebase.abort.dialog.ok.button.text=中止
rebase.abort.dialog.title=中止變基
rebase.abort.notification.failed.title=中止變基失敗
rebase.abort.notification.successful.message=中止變基成功
rebase.abort.notification.warning.rollback.failed.message={0}中的回滾失敗:{1}{2}
rebase.abort.notification.warning.rollback.failed.title=變基回滾失敗
rebase.abort.notification.warning.rollback.failed.with.repo.message=成功中止 {0} 中的變基，但 {1}:{2}{3} 中的回滾失敗
rebase.abort.progress.indicator.command.in.repo.title={0} ({1} 內)
rebase.abort.rollback.successful.rebase.dialog.message=要回滾 {0} 中成功的變基嗎?
rebase.abort.rollback.successful.rebase.dialog.ok.button.text=回滾
rebase.confirmation.dialog.published.commits.button.cancel.text=取消
rebase.confirmation.dialog.published.commits.button.rebase.text=仍然變基
rebase.confirmation.dialog.published.commits.message.first=您正在嘗試變基一些已推送到受保護分支的提交。
rebase.confirmation.dialog.published.commits.message.second=對它們進行變基將導致重複提交，不建議這樣做，並且很可能不必這樣做。
rebase.confirmation.dialog.published.commits.title=變基已發佈的提交
rebase.conflict.diff.dialog.left.title=正在從 {1} 變基 {0}
rebase.conflict.diff.dialog.right.simple.title=已變基的提交
rebase.conflict.diff.dialog.right.with.branch.title=已變基的提交和來自 {0} 的提交
rebase.couldnt.resolve.file=無法解決 {0}
rebase.dialog.error.upstream.not.selected=選擇上游
rebase.dialog.error.base.not.selected=選擇新基
rebase.dialog.error.branch.or.tag.not.exist=沒有這樣的分支或標記
rebase.dialog.error.branch.not.selected=選擇要切換到的分支
rebase.dialog.error.branch.invalid=分支 ''{0}'' 不存在
rebase.dialog.error.rebase.in.progress=此 Git 根目錄已經在進行交互式變基
rebase.dialog.root.invalid.label.text=(無效)
rebase.dialog.progress.loading.tags=正在載入標記…
rebase.dialog.help=顯示 Git 變基幫助
rebase.dialog.start.rebase=變基
rebase.dialog.title=變基
rebase.dialog.target=分支或哈希
rebase.dialog.new.base=新基礎(分支或哈希)
rebase.dialog.old.base=原基礎(分支或哈希)
rebase.dialog.branch.field=源分支
rebase.options.modify.dialog.title=添加變基選項
rebase.option.onto=為變基的提交指定新基
rebase.option.interactive=在變基之前編輯提交
rebase.option.rebase.merges=重新創建提交拓撲
rebase.option.switch.to.branch=選擇另一個要變基的分支
rebase.option.keep.empty=變基期間不移除空提交
rebase.option.root=變基分支中的所有提交
rebase.help.popup.ad.text=按空格打開外部鏈接
rebase.help.rebase.branch=將基於一個分支的分支變基到另一個分支:
rebase.help.link=git-scm.com 上的 git 變基
rebase.entry.action.name.drop=刪除
rebase.entry.action.name.edit=編輯
rebase.entry.action.name.fixup=Fixup
rebase.entry.action.name.pick=選取
rebase.entry.action.name.reword=改寫
rebase.entry.action.name.squash=壓縮
rebase.entry.action.name.unknown=未知
rebase.git.operation.name=變基
rebase.interactive.dialog.discard.modifications.cancel=取消變基
rebase.interactive.dialog.discard.modifications.continue=繼續變基
rebase.interactive.dialog.discard.modifications.discard=捨棄
rebase.interactive.dialog.discard.modifications.message=放棄變更並取消變基?
rebase.interactive.dialog.git.commands.column.action=操作
rebase.interactive.dialog.git.commands.column.hash=哈希
rebase.interactive.dialog.git.commands.column.subject=主題
rebase.interactive.dialog.git.commands=Git 命令
rebase.interactive.dialog.reset.link.text=重置
rebase.interactive.dialog.reword.hint.text=按 {0} 套用變更
rebase.interactive.dialog.start.rebase=啟動變基
rebase.interactive.dialog.stop.to.edit.text=停止以編輯
rebase.interactive.dialog.title=正在變基提交
rebase.interactive.dialog.view.git.commands.text=查看 Git 命令
rebase.interactive.edit.commit.message.dialog.title=Git 提交訊息
rebase.interactive.edit.commit.message.ok.action.title=繼續變基
rebase.interactive.noop.dialog.text=由於當前分支直接位於基礎分支的正下方或它們指向同一個提交，因此沒有要變基的提交('noop' 情況)。\\\\n繼續嗎? (這會將當前分支重置為基礎分支)
rebase.interactive.noop.dialog.title=Git 變基
rebase.interactive.unstructured.editor.dialog.root.label=Git 根: {0}
rebase.log.action.operation.rebase.name=變基
rebase.log.action.operation.reword.name=改寫
rebase.log.commit.editing.action.commit.not.in.head.error.text=該提交不在當前分支中
rebase.log.commit.editing.action.commit.pushed.to.protected.branch.error.text=該提交已被推送到受保護分支 ''{0}''
rebase.log.commit.editing.action.disabled.parents.description=所選提交已{0}父項
rebase.log.multiple.commit.editing.action.disabled.external.repository.description=所選{0, choice, 1#提交|2#提交}{0, choice,1#|2#}來自外部版本庫
rebase.log.multiple.commit.editing.action.disabled.multiple.repository.description=所選{0, choice, 1#提交|2#提交}{0, choice,1#|2#}來自不同的版本庫
rebase.log.commit.editing.action.progress.containing.branches.title=正在搜尋包含所選提交的分支…
rebase.log.commit.editing.action.prohibit.state.grafting=優選期間不能{0}
rebase.log.commit.editing.action.prohibit.state.merging=合併期間不能{0}
rebase.log.commit.editing.action.prohibit.state.rebasing=變基期間不能{0}
rebase.log.commit.editing.action.prohibit.state.reverting=還原期間不能{0}
rebase.log.commit.editing.action.prohibit.state=不能{0}
rebase.log.undo.impossible.pushed.to.protected.branch.notification.text=來自當前分支的提交已被推送到受保護的分支 {0}
rebase.log.drop.action.custom.text=刪除{0,choice,1#提交|2#提交}
rebase.log.drop.action.failure.title=無法刪除提交
rebase.log.drop.progress.indicator.title=正在刪除{0, choice, 1#提交|2#提交}…
rebase.log.drop.success.notification.title=已刪除{0, choice, 1#提交|2#提交}
rebase.log.drop.undo.failed.title=撤消刪除失敗
rebase.log.drop.undo.impossible.title=無法撤消刪除
rebase.log.drop.undo.progress.title=正在撤消刪除…
rebase.log.multiple.commit.editing.action.cant.find.head=在包含選定{0,choice,1#提交|2#提交}的版本庫中找不到 HEAD 分支
rebase.log.multiple.commit.editing.action.progress.indicator.action.possibility.check=正在檢查是否允許編輯所選提交…
rebase.log.multiple.commit.editing.action.specific.commit.not.in.head=提交 {0} 不在當前分支中
rebase.log.multiple.commit.editing.action.specific.commit.root.or.merge=提交 {0} 有 {1} 個父項
rebase.log.create.fixup.commit.action.failure.title=無法創建 Fixup 提交
rebase.log.create.squash.commit.action.failure.title=無法創建壓縮提交
rebase.log.interactive.action.failure.title=無法啟動變基
rebase.log.reword.action.failure.title=無法編輯提交訊息
rebase.log.action.loading.commit.message.failed.message=無法載入{0,choice,1#提交|2#提交}的變更
rebase.log.reword.action.notification.successful.title=已更改提交訊息
rebase.log.reword.action.notification.undo.failed.title=撤消提交訊息編輯失敗
rebase.log.reword.action.notification.undo.not.allowed.repository.changed.message=版本庫已被更改
rebase.log.reword.action.notification.undo.not.allowed.title=無法撤消提交訊息編輯
rebase.log.action.progress.indicator.loading.commit.message.title=正在載入{0,choice,1#提交|2#提交}詳細資訊…
rebase.log.squash.action.failure.title=無法壓縮提交
rebase.log.squash.new.message.dialog.label=編輯已壓縮提交的訊息
rebase.log.squash.new.message.dialog.title=已壓縮提交訊息
rebase.log.squash.progress.indicator.title=正在壓縮…
rebase.log.squash.success.notification.title=提交已壓縮
rebase.log.squash.undo.failed.title=撤消壓縮失敗
rebase.log.squash.undo.impossible.title=無法撤消壓縮
rebase.log.squash.undo.progress.title=正在撤消壓縮…
rebase.log.reword.action.progress.indicator.title=正在改寫…
rebase.log.reword.action.progress.indicator.undo.title=正在撤消改寫…
rebase.log.reword.dialog.description.label=編輯由 {1} 執行的提交 {0} 的訊息
rebase.log.reword.dialog.failed.pushed.to.protected.message=無法編輯所選{0,choice,1#提交|2#提交}: 提交 {1} 已被推送至受保護分支 ''{2}''
rebase.log.reword.dialog.failed.repository.changed.message=無法編輯選定{0,choice,1#提交|2#提交}: 版本庫狀態已被更改
rebase.log.reword.dialog.title=編輯提交訊息
rebase.notification.action.abort.text=中止
rebase.notification.action.continue.text=繼續
rebase.notification.action.retry.text=重試
rebase.notification.action.view.shelf.text=查看擱置…
rebase.notification.action.view.stash.text=查看儲藏…
rebase.notification.conflict.title=由於衝突，變基停止
rebase.notification.editing.title=變基已停止，可以進行編輯
rebase.notification.failed.continue.title=繼續變基失敗
rebase.notification.failed.rebase.title=變基失敗
rebase.notification.failed.shelf.text=無法擱置本地未提交的變更:
rebase.notification.failed.stash.text=無法儲藏本地未提交的變更:
rebase.notification.no.rebase.in.progress.abort.title=無法中止變基
rebase.notification.no.rebase.in.progress.continue.title=無法繼續變基
rebase.notification.no.rebase.in.progress.message=沒有正在進行的變基
rebase.notification.not.allowed.detached.message.first=您在 {0} 中處於游離的 HEAD 狀態。
rebase.notification.not.allowed.detached.message.second=無法變基。
rebase.notification.not.allowed.empty.repository.message=版本庫 {0} 為空。
rebase.notification.not.allowed.grafting.message.first={0} 中有一個未完成的優選進程。
rebase.notification.not.allowed.grafting.message.second=在開始變基前，應先完成這項操作。
rebase.notification.not.allowed.merging.message.first={0} 中有一個未完成的合併進程。
rebase.notification.not.allowed.merging.message.second=在開始變基前，應先完成合併。
rebase.notification.not.allowed.message=無法在 {0} 中進行變基。
rebase.notification.not.allowed.rebasing.message.first={0} 中有一個未完成的變基進程。
rebase.notification.not.allowed.rebasing.message.second=在開始另一個變基前，應先完成這項操作。
rebase.notification.not.allowed.reverting.message.first={0} 中有一個未完成的還原進程。
rebase.notification.not.allowed.reverting.message.second=在開始變基前，應先完成這項操作。
rebase.notification.not.allowed.title=不允許變基
rebase.notification.not.started.title=變基未啟動
rebase.notification.saved.local.changes.part.shelf.text=變基前已擱置本地變更。
rebase.notification.saved.local.changes.part.stash.text=變基前已儲藏本地變更。
rebase.notification.successful.rebased.checkout.message=已簽出{0,choice,0#|1# {1} }並將其變基{2,choice,0#|1#到 {3}}
rebase.notification.successful.rebased.message=已{0,choice,0#|1#將 {1} }變基{2,choice,0#|1#到 {3}}
rebase.notification.successful.title=變基成功
rebase.notification.all.conflicts.resolved.title=解決衝突
rebase.notification.all.conflicts.resolved.text=所有衝突都已解決。要繼續變基嗎?
rebase.notification.all.conflicts.resolved.continue.rebase.action.text=繼續變基(&T)
rebase.progress.indicator.aborting.title=正在中止變基進程…
rebase.progress.indicator.conflicts.collecting.title=正在收集要解決的衝突…
rebase.progress.indicator.continue.title=正在繼續變基進程…
rebase.progress.indicator.preparing.title=正在準備變基…
rebase.progress.indicator.retry.title=正在重試變基進程…
rebase.progress.indicator.title=正在變基…
rebase.simple.editor.dialog.title=Git 編輯器
rebase.update.project.abort.task.title=正在中止變基…
rebase.update.project.conflict.error.notification.description=然後，您可以<b>繼續變基</b>。<br/>您也可以<b>中止變基</b>以恢復原始分支並停止變基。
rebase.update.project.conflict.error.notification.title=無法繼續變基
rebase.update.project.conflict.merge.description.label=檢測到合併衝突。請先解決這些衝突，然後再繼續變基。
rebase.update.project.notification.abort.cancel.message=已取消中止變基
rebase.update.project.notification.abort.error.message=中止變基時出錯
rebase.update.project.notification.abort.success.message=已中止變基
rebase.update.project.notification.failed.message=無法繼續變基。{0}
rebase.update.project.notification.failed.title=變基錯誤
rebase.using.log.couldnt.start.error=由於 IDE 生成的 'git-rebase-todo' 檔案無效，因此無法執行變基。要使用 Git 原生檔案生成來重試變基嗎?
merge.update.project.generic.error.title=無法完成更新
merge.update.project.conflict.merge.description.label=檢測到合併衝突。請先解決這些衝突，然後再繼續更新。

remove.removing=正在移除檔案…
repository.action.missing.roots.misconfigured=配置的 Git 根都不在 Git 下。配置的目錄中必須包含“.git”目錄。
repository.action.missing.roots.title=沒有 Git 根
repository.action.missing.roots.unconfigured.message=沒有為專案配置 Git 根。
repository.not.found.error=找不到 {0} 的已配置 git 版本庫
reset.action.name=重置 Head…
reset.commit.invalid=指定的提交表達式未通過驗證。
reset.commit.label=為提交(&C):
reset.commit.tooltip=由於重置操作而將成為當前 HEAD 的提交。
reset.title=重置 Head
reset.type.tooltip=<html>重置類型(另請參閱 <code>git reset</code> man 頁面):<ul><li><b>Mixed</b> 將重置索引，但不會重置工作樹</li><li><b>Soft</b> 將保留索引和工作樹，只是移動 HEAD 指針</li><li><b>Hard</b> 將重置索引和工作樹。<em>工作樹中的變更會丟失</em></li></ul></html>
reset.type=重置類型(&T):
reset.validate=驗證(&V)
resetting.title=正在重置 HEAD…
restore.conflict.dialog.description.label.text=在 {0} 之前儲存的未提交變更與 {1} 中的檔案衝突
restore.conflict.diff.dialog.left.shelf.title=擱置中的未提交變更
restore.conflict.diff.dialog.left.stash.title=儲藏中的未提交變更
restore.conflict.diff.dialog.right.title=來自 {0} 的變更
preserving.process.local.changes.not.restored.error.title=未恢復本地變更
restore.notification.failed.shelf.message=在更新之前，未提交的變更已儲存到<a href='saver'>擱置</a>。<br/>更新未完成，您的工作樹中有未解決的合併<br/>請解決衝突，完成更新並手動恢復變更。
restore.notification.failed.stash.message=在更新之前，未提交的變更已儲存到<a href='saver'>儲藏</a>。<br/>更新未完成，您的工作樹中有未解決的合併<br/>請解決衝突，完成更新並手動恢復變更。
restore.notification.failed.title=未恢復本地變更

revision.load.contents=載入修訂內容

reference.validating.progress.indicator.title=正在驗證修訂…

save.load.conflict.dialog.diff.left.title=您未提交的變更
save.load.conflict.dialog.diff.right.title=遠端變更
save.notification.failed.shelf.text=試圖在 {0} 之前在擱置中儲存未提交的變更，但失敗並出現錯誤。<br/>{1}
save.notification.failed.stash.text=試圖在{0}之前在儲藏中儲存未提交的變更，但失敗並出現錯誤。<br/>{1}
save.notification.failed.title=無法儲存未提交的變更

smart.operation.dialog.north.panel.label.shelf.text=<html>您對以下檔案的本地變更將被{0}覆蓋。<br/>{1} 可以擱置這些變更，{0}，並在之後取消擱置。</html>
smart.operation.dialog.north.panel.label.stash.text=<html>您對以下檔案的本地變更將被{0}覆蓋。<br/>{1} 可以儲藏這些變更，{0}，並在之後取消儲藏。</html>
smart.operation.dialog.ok.action.shelf.description=擱置本地變更，{0}，取消擱置
smart.operation.dialog.ok.action.stash.description=儲藏本地變更，{0}，取消儲藏
smart.operation.dialog.operation.name.and.overwrite.local.changes={0}並覆蓋本地變更
smart.operation.dialog.git.operation.name.problem=Git {0} 問題
smart.operation.dialog.smart.operation.name=智能{0}
smart.operation.dialog.don.t.operation.name=不{0}
ssh.ask.passphrase.title=SSH 密鑰密碼短語
ssh.ask.passphrase.message=SSH 密鑰“{0}”的密碼:
ssh.keyboard.interactive.title=SSH 鍵盤交互式
ssh.password.message=使用者 {0} 的密碼:
ssh.password.title=SSH 密碼登錄

stash.action.name=儲藏
stash.button=創建儲藏
stash.error.can.not.stash.changes.now=現在無法儲藏變更
stash.keep.index.tooltip=如果選中此復選框，已建立索引的變更將保留在索引中。
stash.keep.index=保留索引(&I)
stash.message.tooltip=在此處輸入儲藏訊息。
stash.message=訊息(&M):
stash.progress.indicator.title=正在儲藏來自 ''{0}'' 的變更…
stash.title=儲藏
stash.unstash.conflict.dialog.description.label.text=更新前儲藏的未提交變更與更新後的檔案衝突。
stash.unstash.progress.indicator.title=正在消除對 ''{0}'' 的變更…
stash.unstash.unresolved.conflict.warning.notification.message=您的未提交變更已儲存到<a href='saver'>儲藏</a>。<br/>取消儲藏未完成，您的工作樹中有未解決的合併<br/>請<a href='resolve'>解決</a>衝突並刪除儲藏。
stash.unstash.unresolved.conflict.warning.notification.title=本地變更已恢復，但存在衝突
stash.error=無法儲藏 {0}
# suppress inspection \\"UnusedProperty\\" - used in third-party plugins
stashing.title=正在儲藏變更…
stashing.progress.title=正在儲藏變更…
stash.editor.diff.preview.empty.title=儲藏

stash.tab.name=儲藏
stash.empty.text=找不到儲藏
action.Git.Stash.Pop.text=彈出
action.Git.Stash.Pop.description=彈出所選儲藏
action.Git.Stash.Apply.text=套用
action.Git.Stash.Apply.description=套用所選儲藏
action.Git.Stash.UnstashAs.text=取消儲藏…
action.Git.Stash.UnstashAs.description=彈出或套用選定的儲藏作為新分支(帶或不帶索引)
action.Git.Stash.Drop.text=刪除
action.Git.Stash.Drop.description=丟棄所選儲藏
action.Git.Show.Stash.text=顯示 Git 儲藏
action.Git.Show.Stash.description=顯示“Git 儲藏”工具視窗頁籤
action.Git.Stash.Refresh.text=刷新儲藏
action.Git.Stash.Refresh.description=刷新儲藏列表

stash.unstash.changes.in.root.dialog.title=取消儲藏 {0} 中的變更
stash.unstash.changes.current.branch.label=當前分支:

tag.action.name=標記
tag.button=創建標籤
tag.commit.label=提交(&C)
tag.commit.tooltip=輸入要標記的提交或物件的名稱，或留空以使用 HEAD。
tag.error.creating.message.file.message=無法創建訊息檔案: {0}
tag.error.invalid.commit=該提交或物件名稱無效。
tag.error.tag.exists=存在同名的標記。
tag.force.tooltip=強制創建標記，即使已存在另一個具有此名稱的標記。
tag.force=強制(&F)
tag.getting.existing.tags=正在獲取現有標記…
tag.message.label=訊息(&M):
tag.message.tooltip=如果訊息不為空，則創建帶註解的標記。
tag.name.label=標記名稱(&N):
tag.name.tooltip=在此處輸入新的標記名稱。
tag.title=標記
tag.validate.tooltip=點擊此按鈕驗證要標記的提交
tag.validate=驗證(&V)
tag.progress.title=正在添加標記…

unstash.action.name=取消儲藏
unstash.branch.label=作為新分支(&B):
unstash.branch.tooltip=如果輸入非空名稱，該儲藏將作為新分支簽出。
unstash.button.apply=套用儲藏
unstash.button.branch=分支
unstash.button.pop=消除儲藏
unstash.clear.tooltip=刪除版本庫中的所有儲藏。
unstash.clear=清除(&C)
unstash.clearing.stashes=正在清除儲藏…
unstash.drop.tooltip=刪除所選儲藏
unstash.drop=刪除(&D)
unstash.conflict.dialog.description.label.text=取消儲藏 {0} 時發生衝突
unstash.conflict.diff.dialog.left.title=本地變更
unstash.conflict.diff.dialog.right.title=來自儲藏的變更
unstash.dialog.remove.stash.progress.indicator.title=正在移除儲藏 {0}…
unstash.dialog.show.stashes.error.dialog.title=無法顯示儲藏列表
unstash.dialog.stash.list.load.progress.indicator.title=正在載入儲藏列表…
unstash.dialog.unresolved.conflict.warning.notification.message=取消儲藏未完成，您的工作樹中存在未解決的合併<br/>請<a href='resolve'>解決</a>衝突。
unstash.dialog.unresolved.conflict.warning.notification.title=取消儲藏期間未解決衝突
unstash.pop.stash.tooltip=如果選中，則該儲藏在套用後會被刪除。
unstash.pop.stash=消除儲藏(&P)
unstash.reinstate.index.tooltip=嘗試復原索引以及工作樹變更。
unstash.reinstate.index=復原索引(&I)
unstash.stashes=儲藏(&S):
unstash.title=取消儲藏變更
unstash.unstashing=正在取消儲藏…
unstash.view.tooltip=查看所選儲藏
unstash.view=查看(&V)
unstash.view.dialog.title=受 {0} 影響的路徑
unstash.error.can.not.unstash.changes.now=現在無法取消儲藏變更
unstash.unstashed.with.conflicts.error.title=已取消儲藏，但存在衝突

update.options.display.name=Git 更新設定
update.notification.update.error=無法更新
update.notification.choose.upstream.branch=選擇上游分支
update.skip.root.reason.no.tracked.branch=無跟踪分支
update.skip.root.reason.detached.head=游離的 HEAD

util.remote.renderer.none=無
vfs.listener.add.single.prompt=要將以下檔案添加到 Git 嗎?\\\\n{0}\\\\n\\\\n如果您選擇“取消”，以後仍可以手動添加。
vfs.listener.add.single.title=將檔案添加到 Git
vfs.listener.add.title=將檔案添加到 Git
vfs.listener.checking.ignored=正在檢查忽略的檔案…
vfs.listener.delete.single.prompt=要從 Git 中刪除以下檔案嗎?\\\\n{0}\\\\n\\\\n如果您選擇“取消”，以後仍可以手動刪除。
vfs.listener.delete.single.title=從 Git 中刪除檔案
vfs.listener.delete.title=從 Git 中刪除檔案

git.commit.message.empty=請指定提交訊息
git.commit.message.empty.title=提交訊息為空

git.executable.detect.progress.title=正在檢測 Git 可執行檔案
git.executable.version.progress.title=正在識別 Git 版本
git.executable.version.is=Git 版本為 {0}
git.executable.error.file.not.found=沒有此類檔案: {0}

git.executable.validation.error.start.title=無法執行 Git
git.executable.validation.error.version.title=Git 版本 {0} 不受支援
git.executable.validation.error.version.message=至少需要 {0}
git.executable.validation.error.wsl1.unsupported.message=不支持 WSL 版本 1，請參閱 <a href='https://youtrack.jetbrains.com/issue/IDEA-242469'>IDEA-242469</a>
git.executable.validation.error.xcode.title=接受 XCode/iOS 許可證以執行 Git
git.executable.validation.error.xcode.message=執行“sudo xcodebuild -license”並重試(需要管理員權限)
git.executable.validation.cant.identify.executable.message=無法識別 git 可執行檔案 {0} 的版本
git.executable.unknown.error.message=無法啟動 Git 進程: {0}
git.error.cant.process.output=無法處理 Git 輸出: {0}

git.executable.notification.title=無法啟動 Git
git.executable.notification.description=Git 可執行檔案的路徑可能無效。

executable.error.git.not.installed=未安裝 Git
executable.mac.fix.path.action=修正路徑
executable.mac.error.invalid.path.to.command.line.tools=Command Line Tools 的路徑無效

git.unstash.clear.confirmation.message=移除所有儲藏? 此操作無法撤消。
git.unstash.clear.confirmation.title=移除所有儲藏?
git.unstash.drop.confirmation.message=<html>要移除 {0} 嗎?<br/>“{1}”</html>
git.unstash.drop.confirmation.title=移除儲藏 {0}?
vcs.history.action.gitlog=在 Git 日誌中顯示

# suppress inspection \\"UnusedProperty\\": used by 3-party plugins

exportable.Git.Application.Settings.presentable.name=Git

git.add.to.exclude.file.action.text=.git/info/exclude
git.add.to.exclude.file.action.description=將條目添加到 .git/info/exclude
git.open.exclude.file.action.text=打開 .git/info/exclude
git.open.exclude.file.action.description=在編輯器中打開 .git/info/exclude

git.fetch.progress=正在獲取…

action.CopyPathFromRepositoryRootProvider.text=版本庫根路徑
action.git4idea.commands.TestGitHttpLoginDialogAction.text=測試 Git 登錄對話框
action.Git.Log.DeepCompare.text=無優選提交
action.Git.Log.DeepCompare.description=高亮顯示尚未優選到當前分支的提交
group.Git.ContextMenu.text=&Git
group.Git.Menu.text=&Git
group.Git.MainMenu.RebaseActions.text=變基(_R)
group.Git.MainMenu.MergeActions.text=合併(_M)
group.Git.MainMenu.LocalChanges.text=未提交的變更(_U)
action.Git.Rebase.Skip.text=跳過提交
action.Git.Rebase.Skip.progress.title=變基期間跳過提交…
action.Git.Rebase.Continue.text=繼續變基
action.Git.Revert.Abort.text=中止還原
action.Git.CherryPick.Abort.text=中止優選
action.Git.Merge.Abort.text=中止合併
action.Git.Rebase.Abort.text=中止變基
action.Git.Rebase.text=變基…
action.Git.Rebase.operation.name=變基
action.Git.Pull.text=拉取…
action.Git.Fetch.text=獲取
action.Git.Clone.text=克隆…
action.Git.Configure.Remotes.text=管理遠端…
action.Git.Reset.text=重置 HEAD…
action.Git.Unstash.text=取消儲藏變更…
action.Git.Stash.text=儲藏變更…
action.Git.Stash.Silently.text=靜默儲藏
action.Git.Merge.text=合併…
action.Git.Tag.text=新建標記…
action.Git.Branches.text=分支(_B)…
action.Git.ResolveConflicts.text=解決衝突…
action.Git.CompareWithBranch.text=與分支比較…
action.Git.Add.text=添加
action.Git.Interactive.Rebase.text=從這裡進行交互式變基…
action.Git.Interactive.Rebase.description=顯示交互式變基的對話框，可以在該對話中對提交執行壓縮、fixup、重新排序、移除和改寫
action.Git.Squash.Into.Commit.text=壓縮到…
action.Git.Squash.Into.Commit.description=創建壓縮提交
action.Git.Fixup.To.Commit.text=Fixup…
action.Git.Fixup.To.Commit.description=創建 fixup 提交
action.Git.Rename.Local.Branch.text=重命名…
action.Git.Rename.Local.Branch.description=重命名本地分支
action.Git.New.Branch.description=僅選擇一個分支以繼續創建新分支
action.Git.New.Branch.dialog.title=從 {0} 創建分支
action.Git.Update.Selected.text=更新所選內容
action.Git.Update.Selected.description=從跟踪的遠端獲取並使用 {1} 或像 \`git fetch branch:branch\` 一樣的快進(如果可能)更新所選{0,choice,1#分支|2#分支}
action.Git.Update.Selected.description.already.running=更新已在執行
action.Git.Update.Selected.description.select.non.current=僅選擇非當前分支
action.Git.Update.Selected.description.tracking.not.configured=沒有為所選{0,choice,1#分支|2#分支}配置跟踪分支
action.Git.Delete.Branch.title=刪除{0,choice,1#分支|2#分支}
action.Git.Compare.With.Current.title=與當前分支進行比較
action.Git.Compare.Selected.title=比較分支
action.Git.Compare.Selected.description=相互比較選定分支
action.Git.Compare.Selected.description.disabled=從同一版本庫中選擇分支
action.Git.Show.My.Branches.title=顯示我的分支
action.Git.Show.My.Branches.description.not.support.indexing=某些版本庫不支持索引。
action.Git.Show.My.Branches.description.not.all.roots.indexed=並沒有為所有版本庫編制索引。
action.Git.Show.My.Branches.description.not.graph.ready=該日志尚未就緒，請稍候。
action.Git.Show.My.Branches.description.is.my.branch=如果分支的所有獨佔提交都是由“我”(即當前 Git 作者)執行的，則此分支為“我的”。
action.Git.Show.My.Branches.description.calculating.branches.progress=正在計算我的分支
action.Git.Fetch.title=獲取所有遠端
action.Git.Fetch.description.fetch.in.progress=正在獲取…
action.Git.Toggle.Favorite.title=標記/取消標記為收藏項
action.Git.Loading.Branches.progress=正在載入分支…
group.Git.Log.Branches.Settings.text=分支窗格設定
group.Git.Log.Branches.Grouping.Settings.text=分組依據
group.Git.Log.Branches.Settings.Separator.text=單擊時
action.Git.Log.Branches.Change.Branch.Filter.On.Selection.text=更新分支篩選器
action.Git.Log.Branches.Change.Branch.Filter.On.Selection.description=選擇分支後，按此分支篩選日誌
action.Git.Log.Branches.Navigate.Log.To.Branch.On.Selection.text=在日誌中導航到分支 Head
action.Git.Log.Branches.Navigate.Log.To.Branch.On.Selection.description=選擇分支後，在日誌中導航到該分支 HEAD
action.Git.Log.Branches.Navigate.Log.To.Selected.Branch.text=在日誌中導航到所選分支 Head
action.Git.Log.Branches.Change.Branch.Filter.text=更新日誌中的分支篩選器
action.Git.Log.Branches.Change.Branch.Filter.description=使用所選分支更新日誌中的分支篩選器
action.Git.Log.Edit.Remote.text=編輯遠端
action.Git.Log.Remove.Remote.text=移除 {0,choice,1#遠端|2#遠端}
group.Git.HEAD.Branch.Filter.title=HEAD(當前分支)
group.Git.Local.Branch.title=本地
group.Git.Remote.Branch.title=遠端
action.Git.Checkout.Branch.text=簽出所選…
action.Git.Checkout.Branch.description=簽出所選分支
action.Git.Log.Hide.Branches.text=隱藏 Git 分支
action.Git.Log.Show.Branches.text=分支
action.Git.Reword.Commit.text=編輯提交訊息…
action.Git.Reword.Commit.description=通過 git rebase 或 amend 的改寫選項更改提交訊息
action.Git.Squash.Commits.text=壓縮提交…
action.Git.Drop.Commits.text=刪除提交
action.Git.Uncommit.text=撤消提交…
action.Git.Uncommit.description=撤消上次提交，並將其更改置於選定的更改列表
action.Git.Revert.In.Log.text=還原提交
action.Git.Revert.In.Log.template.text=還原{0,choice,1#提交|2#提交}
action.Git.Revert.In.Log.description=生成新提交，這會還原在原始提交中所做的變更
action.Git.Reset.In.Log.text=將當前分支重置到此處…
action.Git.CreateNewTag.text=新建標記…
action.Git.CreateNewTag.description=創建指向此提交的新標籤
action.Git.CreateNewBranch.text=新建分支…
action.Git.CreateNewBranch.description=從所選提交開始創建新分支
group.Git.CheckoutGroup.text=簽出
group.Git.CheckoutGroup.description=簽出所選修訂或所選提交中的分支
action.Git.BrowseRepoAtRevision.text=在修訂版中顯示版本庫
action.Git.Log.text=顯示 Git 版本庫日誌…
action.Git.Init.text=創建 Git 版本庫…
action.Git.Init.error=Git init 失敗
checkbox.dont.warn.again=不再警告
checkbox.run.git.hooks=執行 Git 掛鈎
tooltip.run.git.hooks=如果未選中，將使用 '--no-verify' 參數跳過 Git hook
action.NotificationAction.text.resolve=解決…
action.NotificationAction.GitDeleteBranchOperation.text.restore=恢復
action.NotificationAction.GitDeleteBranchOperation.text.view.commits=查看提交
action.NotificationAction.GitDeleteBranchOperation.text.delete.tracked.branch=刪除跟踪的分支
action.NotificationAction.GitDeleteTagOperation.text.restore=恢復
action.NotificationAction.GithubNotifications.text.configure=配置…
action.NotificationAction.GitMergeAction.text.view.commits=查看提交
action.NotificationAction.GitRewordOperation.text.undo=撤消
action.NotificationAction.GitUpdateSession.text.view.commits=查看提交
action.not.possible.in.fresh.repo.show.diff=正在比較修訂
action.not.possible.in.fresh.repo.rename.branch=正在重命名分支
action.not.possible.in.fresh.repo.checkout=簽出
action.not.possible.in.fresh.repo.push=正在推送提交

settings.git.option.group=Git
settings.add.suffix=在挑選推送到受保護分支的提交時，添加 'cherry-picked from <hash>' 後綴
settings.crlf=即將提交 CRLF 行分隔符時發出警告
settings.detached.head=在游離的 HEAD 中或變基期間提交時發出警告
settings.update.method=更新方法：
settings.auto.update.on.push.rejected=如果當前分支的推送被拒，則自動更新
settings.push.dialog=為提交和推送顯示推送對話框
settings.push.dialog.for.protected.branches=僅在提交到受保護分支時顯示推送對話框
settings.protected.branched=受保護分支:
settings.synchronize.branch.protection.rules=從 GitHub 載入分支保護規則
settings.synchronize.branch.protection.rules.description=將 GitHub 規則添加到本地規則中，並在每次獲取時進行同步
settings.credential.helper=使用憑證幫助程序
settings.filter.update.info=按路徑過濾“更新專案”資訊:
settings.explicitly.check=顯式檢查遠端上的傳入提交:
settings.clean.working.tree=使用何種操作清理工作樹:
settings.git.incoming.change.strategy.text.auto=自動
settings.git.incoming.change.strategy.text.always=始終
settings.git.incoming.change.strategy.text.never=從不
settings.git.update.method.rebase.description=在傳入變更上變基當前分支
settings.git.update.method.rebase=變基
settings.git.update.method.merge.description=將傳入變更合併到當前分支
settings.git.update.method.merge=合併
settings.git.update.method.branch.default=分支預設
settings.enable.staging.area=啟用暫存區域
settings.enable.staging.area.comment=這將禁用變更列表支援並刪除專案中的所有變更列表。僅適用於非強制回應提交介面。

clone.dialog.checking.git.version=正在檢查 Git 版本…
push.dialog.push.tags=推送標記
push.dialog.push.tags.combo.current.branch=當前分支
push.dialog.push.tags.combo.all=所有
push.dialog.target.panel.define.remote=定義遠端
push.dialog.target.panel.add.remote=添加遠端
push.dialog.target.panel.couldnt.add.remote=無法添加遠端: {0}
push.dialog.target.panel.adding.remote=正在添加遠端…
push.dialog.target.panel.can.t.push=無法推送
push.dialog.target.panel.empty.repository=空版本庫
push.dialog.target.panel.detached.head=游離的 HEAD
push.dialog.target.panel.new=新建
push.dialog.preview.commits.before.push=對於向不受保護分支的提交和推送，應在推送之前預覽提交
push.local.history.system.label.after=推送後
push.local.history.system.label.before=推送前
push.notification.description.force.pushed=強制推送 {0} 到 {1}
push.notification.description.new.branch.with.many.tags=推送 {0} 到新分支 {1}，並將 {2} 標籤到 {3}
push.notification.description.new.branch.with.single.tag=推送 {0} 到新分支 {1}，並將 {2} 標籤到 {3}
push.notification.description.new.branch=已推送 {0} 到新分支 {1}
push.notification.description.push.with.lease.rejected=使用 Force-with-lease 推送 {0} 到 {1} 被拒
push.notification.description.pushed.many.tags=已推送 {0} 標籤到 {1}
push.notification.description.pushed.single.tag=已推送標籤 {0} 到 {1}
push.notification.description.pushed.with.many.tags=已將 {0} 個{0,choice,1#提交|2#提交} 推送到 {1}，將 {2} 標籤推送到 {3}
push.notification.description.pushed.with.single.tag=已將 {0} 個{0,choice,1#提交|2#提交} 推送到 {1}，將標籤 {2} 推送到 {3}
push.notification.description.pushed=已將 {0} 個{0,choice,1#提交|2#提交} 推送到 {1}
push.notification.description.rejected.and.cancelled=推送被拒，更新被取消
push.notification.description.rejected.and.conflicts=由於更新期間發生衝突，推送被取消。<br/>檢查是否已正確解決衝突，然後再次調用推送。
push.notification.description.rejected.and.failed=因發生錯誤，推送被拒，更新失敗
push.notification.description.rejected.and.incomplete=由於更新過程中並未解決所有衝突，推送被取消。<br/>請解決衝突並再次調用推送
push.notification.description.rejected.by.remote=推送 {0} 到 {1} 被遠端拒絕
push.notification.description.rejected=推送到 {0} 被拒
push.notification.description.up.to.date=所有內容都已處於最新狀態
push.notification.force.push.anyway.action=仍然強制推送
push.notification.force.push.progress.title.pushing=正在推送…
push.notification.force.with.lease.help.description.first=Force-with-lease 推送阻止覆寫尚未獲取到本地版本庫的遠端更改
push.notification.force.with.lease.help.description.second=獲取最新變更，以確認能否安全丟棄變更並重複執行推送操作
push.notification.force.with.lease.help=何為 Force-with-Lease?
push.notification.partially.failed.title=推送部分失敗
push.notification.partially.rejected.title=推送部分被拒
push.notification.push.failed.title=推送失敗
push.notification.rejected.title=推送被拒
push.notification.single.repo.success.description=推送操作期間收到 {0} 個{0, choice,1#提交|2#提交}
push.notification.successful.title=推送成功
push.notification.update.action=更新
push.notification.view.files.action=查看在推送期間更新的檔案
push.notification.view.filtered.commits.actions=查看與篩選器符合的 {0} 個{0,choice,1#提交|2#提交}
push.notification.view.received.commits.action=查看收到的{0,choice,1#提交|2#提交}
push.rejected.dialog.title=推送被拒
push.rejected.many.repos.item={1} 中的 {0}
push.rejected.many.repos.single.branch=當前分支 \\"{0}\\" 的推送被拒。
push.rejected.many.repos=當前分支的推送被拒:
push.rejected.merge.needed.with.problem=在推送前，必須先合併遠端更改。<br/><br/>在這種情況下，強烈建議進行<b>合併</b>，因為存在未推送的合併提交。\\\\n<br/>進行變基可能導致問題。
push.rejected.merge.needed=推送前需要合併遠端變更。
push.rejected.merge=&Merge
push.rejected.only.one.git.repo=當前分支 \\"{0}\\" 的推送被拒。
push.rejected.rebase.anyway=仍然變基
push.rejected.rebase=變基(&R)
push.rejected.update.not.rejected.repositories.as.well.checkbox=更新所有版本庫(&U)

install.download.and.install.action=下載並安裝
install.installing.progress=正在安裝…
install.downloading.progress=正在下載…
install.success.message=已安裝 Git
install.general.error=無法安裝 Git
install.mac.error.couldnt.start.command.line.tools=無法啟動 Command Line Tools 安裝
install.mac.requesting.command.line.tools=正在請求 XCode Command Line Developer Tools
git.status.not.changed=未更改
git.status.renamed=已重命名
git.status.copied=已複製
git.status.type.changed=已更改類型
git.status.unmerged=已取消合併
git.status.untracked=已取消跟踪
git.status.index=在暫存區域中{0}
git.status.work.tree=在工作目錄中{0}
git.status.unmerged.index=由我們{0}
git.status.unmerged.work.tree=由他人{0}
git.status.unmerged.both=兩者{0}

git.status.bar.widget.name=Git 分支
git.status.bar.widget.text.cherry.pick=正在 {0} 中優選
git.status.bar.widget.text.revert=正在 {0} 中還原
git.status.bar.widget.text.merge=正在合併 {0}
git.status.bar.widget.text.rebase=正在變基 {0}
git.status.bar.widget.tooltip.detached=Git: 游離的 HEAD 不指向任何分支

git.light.status.bar.display.name=Git
git.light.status.bar.tooltip=當前 Git 分支: {0}
git.light.status.bar.text=Git: {0}
git.light.cant.find.current.revision.exception.message=找不到 {0} 的當前修訂

status.exception.message.unexpected.xstatus.ystatus=意外的狀態符號: ''{0}{1}''
status.exception.message.unexpected.status=意外的狀態符號: ''{0}''
status.exception.message.line.is.too.short=此行過短
status.exception.message.unexpected=意外的狀態符號
status.exception.message.missing.path=缺少初始路徑
status.exception.message.format.message.xstatus.ystatus.line.output={0} xStatus=[{1}]，yStatus=[{2}]，行=[{3}]\\\\n輸出:\\\\n{4}

stage.tree.node.staged=已暫存
stage.tree.node.unstaged=已取消暫存
stage.tree.node.unmerged=已取消合併
stage.tree.node.untracked=已取消跟踪
stage.tree.node.ignored=已忽略
stage.content.staged=已暫存
stage.content.local=本地
error.no.selected.roots.to.commit=選擇要提交的根
error.no.staged.changes.to.commit=暫存要提交的檔案
error.no.staged.changes.no.commit.message=暫存要提交的檔案並指定提交訊息
stage.commit.process=正在提交暫存變更…
stage.commit.successful=已提交 {0}: {1}
stage.commit.failed=無法提交 {0}
stage.loading.status=正在載入變更…
stage.add.action.text=暫存
stage.add.process=正在暫存檔案…
stage.add.error.title=無法暫存檔案
stage.reset.action.text=取消暫存
stage.reset.process=正在取消暫存檔案…
stage.reset.error.title=無法取消暫存檔案
stage.revert.action.text=回滾
stage.revert.process=正在回滾檔案…
stage.revert.error.title=無法回滾檔案
stage.add.range.command.name=暫存變更
stage.revert.unstaged.range.command.name=回滾未暫存的變更
stage.revert.staged.range.command.name=回滾暫存的變更
action.label.add.unstaged.range=暫存
action.label.add.unstaged.range.tooltip=向索引中添加新的變更
action.label.reset.staged.range=取消暫存
action.label.reset.staged.range.tooltip=移除索引中的變更
stage.vfs.write.process=正在將 {0} 寫入 Git 索引
stage.vfs.read.process=正在從 Git 索引讀取 {0}
stage.vfs.refresh.process=正在刷新 Git 索引檔案
stage.vfs.presentable.file.name=已暫存: {0}
stage.vfs.editor.tab.tooltip=''{0}'' 的暫存版本
stage.vfs.editor.notification.text=這是暫存版本的 ''{0}''
stage.vfs.editor.notification.link=打開本地版本
stage.diff.local.content.exception.message=無法獲取本地檔案: ''{0}''
changes.view.merge.action.text=合併

action.Git.Show.Stage.text=顯示暫存區域
action.Git.Stage.Add.All.text=全部暫存
action.Git.Stage.Add.All.description=將所有未暫存的變更和未跟踪的檔案添加到索引
action.Git.Stage.Add.Tracked.text=暫存全部已跟踪項
action.Git.Stage.Add.Tracked.description=將跟踪檔案中所有未暫存的變更添加到索引
group.Git.Stage.Ui.Settings.text=檢視選項
action.Git.Stage.Show.Staged.text=顯示暫存版本
action.Git.Stage.Show.Staged.description=在編輯器中顯示當前檔案的暫存內容
action.Git.Stage.Show.Local.text=顯示本地版本
action.Git.Stage.Show.Local.description=在編輯器中顯示當前檔案的本地內容
action.Git.Stage.Compare.Local.Staged.text=與暫存版本比較
action.Git.Stage.Compare.Staged.Local.text=與本地版本比較
action.Git.Stage.Compare.Staged.Head.text=與 HEAD 版本比較
action.Git.Stage.Compare.Three.Versions.text=比較 HEAD 版本、暫存版本和本地版本
action.Git.Stage.ThreeSideDiff.text=比較 HEAD 版本、暫存版本和本地版本
action.Git.Stage.ThreeSideDiff.description=顯示包含 HEAD、暫存和本地版本的差異視窗，從中可以交互式地將變更添加到暫存區域
group.Git.Stage.Index.File.Menu.text=Git


branches.selected.branches.updated.title=已更新{0,choice,1#分支|2#分支}:\\\\n\\\\n{1}
branches.update.failed=更新失敗
branches.updating.process=正在更新分支…
branches.checkout.failed.description=無法覆蓋 {0} 分支，因為某些提交可能會丟失
branches.creation.failed.title=新分支創建失敗
branches.checkout.failed.title=簽出失敗
branches.checking.existing.commits.process=正在檢查現有提交…
branches.create.new.branch.dialog.title=創建新分支
branches.tag.0=標記 ''{0}''
branches.branch.0=分支 ''{0}''
in.branches.all.repositories=在所有版本庫中
branches.tags=標記
branches.branches=分支
repositories=版本庫
common.remote.branches=公共遠端分支
common.local.branches=公共本地分支
update.checks.not.supported.git.2.9.required=不支持更新檢查。需要 Git 2.9 及以上版本
action.fetch.text=獲取
fetching=正在獲取…
branches.current.branch=當前分支
branches.tracking.branch.doesn.t.configured.for.s=沒有為 {0} 配置跟踪分支
branches.update.is.already.running=更新已在執行
branches.update=更新
branches.current.branch.name=當前
branches.selected.branch.name=已選擇
branches.checkout.and.rebase.onto.in.one.step=簽出 {0}，並在一個步驟中將其變基到 {1} (類似於 \`git rebase HEAD {2}\`)
branches.checkout.and.rebase.onto.current=簽出並變基到當前分支
branches.checkout.and.rebase.onto.branch=簽出並變基到 {0}
branches.rebase.is.not.possible.in.the.detached.head.state=在游離的 HEAD 狀態下無法變基
branches.rebase.onto=將 {0} 變基到 {1}
branches.rebase.current.onto.selected=將當前分支變基到所選分支
branches.merge.into=將 {0} 合併到 {1} 中
branches.merge.into.current=合併到當前分支
branches.compare.the.current.working.tree.with=將當前工作樹與 {0} 中的樹進行比較
branches.show.diff.with.working.tree=顯示與工作樹的差異
branches.show.commits.in=在{0}中顯示{1}中缺少的提交
branches.compare.with.current=與當前分支進行比較
branches.compare.with.branch=與{0}比較
branches.new.branch.from.branch=從 {0} 新建分支…
branches.new.branch.from.branch.description=從 {0} 創建新分支
branches.checkout.s=簽出 {0}
checkout.and.rebase=變基到遠端
checkout.0=簽出 {0}
branches.drop.local.commits=刪除本地提交
branches.checkout=簽出
branches.rename.branch=重命名分支 {0}
branches.there.are.outgoing.commits=存在傳出提交
branches.there.are.incoming.commits=存在傳入提交
branches.there.are.incoming.and.outgoing.commits=存在傳入和傳出提交
branches.checkout.tag.or.revision=簽出標記或修訂…
branches.enter.reference.branch.tag.name.or.commit.hash=輸入引用(分支、標記)名稱或提交哈希:
branches.remote.branches=遠端分支
branches.remote.branches.in.repo={0} 中的遠端分支
branches.local.branches=本地分支
branches.local.branches.in.repo={0} 中的本地分支
branches.update.info.process=更新分支資訊…
branches.action.pull.into.branch.using.merge=使用合並拉入 {0}(_M)
branches.action.pull.into.branch.using.merge.description=使用合並拉入 {0}
branches.action.pull.into.branch.using.rebase=使用變基拉入 {0}(_R)
branches.action.pull.into.branch.using.rebase.description=使用變基拉入 {0}
git.rollback=回滾(&R)

new.branch.dialog.operation.create.name=創建
new.branch.dialog.operation.create.description=在其他版本庫中創建新分支
new.branch.dialog.operation.checkout.name=簽出
new.branch.dialog.operation.checkout.description=簽出現有分支，並在其他版本庫中創建新分支
new.branch.dialog.operation.rename.name=重命名
new.branch.dialog.branch.name=新分支名稱:
new.branch.dialog.checkout.branch.checkbox=簽出分支
new.branch.dialog.set.tracking.branch.checkbox=設定跟踪分支
new.branch.dialog.overwrite.existing.branch.checkbox=覆蓋現有分支
new.branch.dialog.overwrite.existing.branch.warning=更改名稱或覆蓋現有分支
new.branch.dialog.error.branch.name.invalid=分支名稱 {0} 無效
new.branch.dialog.error.branch.name.empty=指定新分支的名稱
new.branch.dialog.error.branch.name.head=HEAD 是保留關鍵字
new.branch.dialog.error.branch.already.exists=分支名稱 {0} 已存在
new.branch.dialog.error.branch.clashes.with.remote=分支名稱 {0} 與同名的遠端分支衝突
git.reset.mode.soft=軟
git.reset.mode.soft.description=檔案不會更改，差異將暫存以進行提交。
git.reset.mode.mixed=混合
git.reset.mode.mixed.description=檔案不會更改，差異也不進行暫存。
git.reset.mode.hard=硬
git.reset.mode.hard.description=<nobr>檔案將還原為所選提交的狀態。<nobr/><br><nobr>警告: 任何本地變更都將丟失。<nobr/>
git.reset.mode.keep=保留
git.reset.mode.keep.description=<nobr>檔案將還原為所選提交的狀態，<nobr/><br><nobr>但本地變更將保持不變。<nobr/>
git.reset.dialog.title=Git 重置
git.reset.dialog.description=<nobr>這會將當前分支 HEAD 重置為所選提交，<nobr/><br><nobr>並根據所選模式更新工作樹和索引:<nobr/>
git.reset.dialog.description.commit.details.by.author={0}，作者 {1}
git.reset.dialog.description.source.in.repository={0} ({1} 內)
git.reset.process=Git 重置
git.reset.operation=重置
git.reset.button=重置
git.reset.hard.button=硬重置(&H)
git.reset.successful.notification.message=重置成功
git.reset.partially.failed.notification.title=重置部分失敗
git.reset.partially.failed.notification.msg={0} 重置成功\\\\n但 {1} 重置失敗:\\\\n{2}
git.reset.failed.notification.title=重置失敗
git.undo.action.cant.undo.commit.failure=無法撤消提交
git.undo.action.description=所選提交不是當前分支中的最後一次提交
git.undo.action.select.target.changelist.title=選擇目標變更列表
git.undo.action.undoing.last.commit.process=正在撤消最後一次提交…
git.undo.action.refreshing.changes.process=正在刷新變更…
git.undo.action.could.not.load.changes.of.commit=無法載入 {0} 的變更
git.new.tag.dialog.title=在 {0}上創建新標記
git.new.tag.dialog.tag.name.label=輸入新標記的名稱

git.log.external.tab.description={0} 的日誌
git.log.external.window.title=Git 日誌
git.log.external.loading.process=正在載入 Git 日誌…

git.log.cherry.picked.highlighter.select.branch.popup=選擇源分支
git.log.cherry.picked.highlighter.process=正在比較分支…
git.log.cherry.picked.highlighter.error.message=無法與分支 {0} 進行比較
git.log.cherry.picked.highlighter.cancelled.message=已取消對 ''{0}'' 中未選取提交的高亮顯示，因為分支篩選器已被更改。

git.log.action.checkout.group=簽出
git.log.action.checkout.revision.short.text=修訂 ''{0}''
git.log.action.checkout.revision.full.text=簽出修訂 ''{0}''
action.Git.CheckoutRevision.text=簽出修訂

git.log.diff.handler.local.version.name=本地版本
git.log.diff.handler.local.version.content.title=本地

git.log.refGroup.local=本地

log.parser.exception.message.error.parsing.line=解析第 \\"{0}\\" 行時出錯
log.parser.exception.message.could.not.parse.output=無法解析 Git 日誌輸出 \\"{0}\\"
log.parser.exception.message.error.command.line={0}\\\\n命令行: [{1}]

history.indexing.disabled.notification.text=由於索引不可用，顯示的是舊式檔案歷史記錄
history.indexing.disabled.notification.resume.link=恢復 Git 日誌索引
history.indexing.disabled.notification.dismiss.link=不再顯示

git.history.diff.handler.choose.parent.popup=選擇要比較的父項
git.history.diff.handler.load.changes.process=正在載入變更…
git.history.diff.handler.git.show.error=執行 git show {0}:{1} 時出錯
git.history.diff.handler.no.changes.in.file.info=此合併提交中的檔案 {0} 無變更
git.log.show.commit.in.log.process=搜尋修訂 {0}
git.compare.branches.empty.status={0} 包含來自 {1} 的所有提交
git.compare.branches.explanation.message=存在於 {0} 中但不存在於 {1} 中的提交
git.compare.branches.tab.name=比較
git.compare.branches.tab.suffix={0} 和 {1}
git.update.files.updated.in.commits=已更新 {1,choice,1#{1} 個提交|2#{1} 個提交}中的 {0,choice,1#{0} 個檔案|2#{0} 個檔案}
git.update.no.commits.matching.filters=沒有與篩選器符合的提交
git.update.commits.matching.filters={0,choice,1#{0} 個提交|2#{0} 個提交}與篩選器匹配
git.update.project.partially.updated.title=專案已部分更新
git.update.skipped.repositories=已跳過 {0} 個版本庫:
git.update.repo.was.skipped=已跳過 {0} ({1})

git.integration.created.git.repository.in=已在 {0} 中創建 Git 版本庫
git.integration.could.not.git.init=無法 git init {0}

git.tag.could.not.create.tag=無法創建標記
git.tag.created.tag.successfully=已成功創建標記 {0}。

rename.branch.operation.name=重命名
git.rename.branch.rollback.successful=回滾成功
git.rename.branch.renamed.back.to=已重命名回 {0}
git.rename.branch.rollback.failed=回滾失敗
git.rename.branch.could.not.rename.from.to=無法將 {0} 重命名為 {1}
git.rename.branch.was.renamed.to=分支 {0} 已被重命名為 {1}
git.rename.branch.you.may.rename.branch.back=您可以回滾(將分支重命名回 {0})以使分支不出現分叉。
git.rename.branch.has.succeeded.for.the.following.repositories=不過，以下{0,choice,1#版本庫|2#版本庫}的重命名已成功:

update.process.progress.title=正在更新…
update.process.generic.error.title=無法更新
update.process.error.message.unfinished.merge=您有未完成的合併。必須先解決這些衝突，然後才能更新。
update.process.error.message.unmerged.files=檢測到未合併的檔案。必須先解決這些衝突，然後才能更新。
update.process.error.description.unfinished.rebase=您有未完成的變基進程。必須先解決這些衝突，然後才能更新。
update.process.error.additional.description.unfinished.rebase=然後，您可以<b>繼續變基</b>。<br/>您也可以<b>中止變基</b>以恢復原始分支並停止變基。
update.process.nothing.to.update=沒有要更新的內容

checkout.operation.could.not.checkout.error=無法簽出 {0}
checkout.operation.revision.not.found=在{0,choice,0#|1#{1}中}未找到修訂
checkout.operation.rollback=回滾
checkout.operation.could.not.checkout.error.title=無法簽出 {0}
checkout.operation.checked.out=已簽出 {0}
checkout.operation.checked.out.new.branch.from=已從 {1} 中簽出新分支 {0}
checkout.operation.in={1,choice,0#|1#{2}中的}{0}
checkout.operation.force.checkout=強制簽出(&F)
checkout.operation.name=簽出
checkout.operation.error.during.rollback=回滾期間出錯
checkout.operation.errors.during.deleting=刪除 {0} 期間出錯:
checkout.operation.errors.during.checkout=簽出期間出錯:
checkout.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滾(簽回 {0})以使分支不出現分叉。
checkout.operation.previous.branch=上一個分支
checkout.operation.however.checkout.has.succeeded.for.the.following=不過，以下{0,choice,1#版本庫|2#版本庫}的簽出已成功:

delete.branch.operation.collecting.unmerged.commits.process=正在收集未合併的提交…
delete.branch.operation.restoring.branch.process=正在恢復分支 {0}…
delete.branch.operation.error.during.rollback.of.branch.deletion=分支刪除回滾期間出錯
delete.branch.operation.could.not.restore.branch.error=無法恢復 {0}
delete.branch.operation.branch.was.not.deleted.error=分支 {0} 未刪除
delete.branch.operation.deleted.branch=已刪除分支 {0}
delete.branch.operation.deleted.branch.bold=<b>已刪除的分支:</b> {0}
delete.branch.operation.unmerged.commits.were.discarded=未合併的提交已被丟棄
delete.branch.operation.however.branch.deletion.has.succeeded.for.the.following=不過，以下{0,choice,1#版本庫|2#版本庫}的分支刪除已成功:
delete.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滾(在這些根中重新創建 {0})以使分支不出現分叉。

branch.operation.could.not.0.operation.name.1.reference=無法{0} {1}
branch.operation.in={0} ({1} 中)

checkout.new.branch.operation.could.not.create.new.branch=無法創建新分支 {0}
checkout.new.branch.operation.error.during.rollback=回滾期間出錯
checkout.new.branch.operation.errors.during.deleting=刪除 {0} 期間出錯:
checkout.new.branch.operation.errors.during.checkout=簽出期間出錯:
checkout.new.branch.operation.rollback.successful=回滾成功
checkout.new.branch.operation.checked.out.0.and.deleted.1.on.2.3=已在{2,choice,1#根|2#根}{3}上簽出 {0} 並刪除 {1}
checkout.new.branch.operation.branch.was.created=已創建分支 {0}
checkout.new.branch.operation.however.checkout.has.succeeded.for.the.following=不過，{0,choice,1#版本庫|2#版本庫} 的簽出已成功:
checkout.new.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滾(簽回上一個分支並刪除 {0})以使分支不出現分叉。

delete.branch.operation.name=分支刪除
delete.remote.branch.operation.deleting.process=正在刪除 {0}
delete.remote.branch.operation.deleted.remote.branch=已刪除遠端分支 {0}
delete.remote.branch.operation.also.deleted.local.branches=同時刪除了本地 {0,choice,1#分支|2#分支}: {1}
delete.remote.branch.operation.failed.to.delete.remote.branch=無法刪除遠端分支 {0}
delete.remote.branch.operation.couldn.t.find.remote.by.name=無法按名稱尋找遠端: {0}

delete.remote.tag.operation.deleted.tag.on.remotes=<b>已刪除 {0,choice,1#遠端|2#遠端}上的標記:</b> {1}
delete.remote.tag.operation.tag.does.not.exist.on.remotes=<b>標記在 {0,choice,1#遠端|2#遠端} 上不存在:</b> {1}
delete.remote.tag.operation.failed.to.delete.tag.on.remotes=無法刪除 {1,choice,1#遠端|2#遠端} 上的標記 {0}

merge.dialog.description.cherry.pick.label.text=在優選{2,choice,0#|1#由 {3}{4} 執行的}{0,choice,1#提交 {1}|2#多個提交}期間出現衝突
merge.dialog.description.merge.label.text=將 {0,choice,1#分支 {1}|2#分叉的分支} 合併到 {2,choice,1#分支 {3}|2#分叉的分支}
merge.dialog.description.rebase.with.hash.label.text=正在{0,choice,0#|1#將分支 {1} }變基到 {2}
merge.dialog.description.rebase.with.onto.branch.label.text=正在{0,choice,0#|1#將分支 {1} }變基到分支 {2}{3,choice,0#|1#，修訂 {4}}
merge.dialog.description.rebase.without.onto.info.label.text=正在{0,choice,0#|1#將分支 {1} }變基到分叉的分支
merge.dialog.diff.left.title.cherry.pick.label.text=本地變更
merge.dialog.diff.left.title.default.branch.label.text=您的版本，分支 {0}
merge.dialog.diff.left.title.rebase.label.text=正在從 {1} 變基 {0}
merge.dialog.diff.right.title.cherry.pick.label.text=來自優選 {0} 的變更
merge.dialog.diff.right.title.default.with.hash.label.text=來自 {0} 的變更
merge.dialog.diff.right.title.default.with.onto.branch.label.text=來自分支 {0}{1,choice,0#|1#，修訂 {2}} 的變更
merge.dialog.diff.right.title.default.without.onto.info.label.text=來自分叉分支的變更
merge.dialog.diff.right.title.rebase.with.branch.label.text=已變基的提交和來自 {0} 的提交
merge.dialog.diff.right.title.rebase.without.branch.label.text=已變基的提交
merge.dialog.diff.title.changes.from.branch.label.text=來自 {0} 的變更
merge.error.unable.to.read.merge.head=無法讀取檔案 {0}: {1}
merge.operation.name=合併
rebase.operation.name=變基
unstash.operation.name=取消儲藏
merge.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滾(重置為合併之前的提交)以使分支不出現分叉。
merge.operation.error.during.rollback=回滾期間出錯
merge.operation.branch.merged.with.conflicts={0} 已合併，但存在衝突
merge.operation.could.not.merge.branch=無法合併 {0}
merge.operation.already.up.to.date=已是最新
merge.operation.however.merge.has.succeeded.for.the.following.repositories=不過，以下 {0,choice,1#版本庫|2#版本庫} 的合併已成功:
merge.operation.merged.to=已將 {0} 合併到 {1}
merge.operation.delete.branch=刪除 {0}
merge.progress.indicator.loading.unmerged.files.title=正在載入未合併的檔案…

merge.unresolved.conflicts.remaining.notification.title=正在掛起未解決的衝突
merge.unresolved.conflicts.remaining.notification.body=有掛起的未解決的衝突。

create.branch.operation.name=創建分支
create.branch.operation.could.not.create.new.branch=無法創建新分支 {0}
create.branch.operation.rollback.successful=回滾成功
create.branch.operation.deleted.branch=已刪除 {0}
create.branch.operation.error.during.rollback=回滾期間出錯
create.branch.operation.branch.created=已創建分支 {0}
create.branch.operation.however.the.branch.was.created.in.the.following.repositories=不過，已在以下 {0,choice,1#版本庫|2#版本庫} 中創建分支:
create.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滾(刪除 {0})以使分支不出現分叉。

branch.ui.handler.can.not.operation.name.because.of.unmerged.files=由於存在未合併的檔案而無法{0}
branch.ui.handler.unmerged.files.error.notification=您必須先<a href=''{0}''>解決</a>所有合併衝突，然後才能{1}。<br/>解決衝突之後，您可能還需要將檔案提交到當前分支。
branch.ui.handler.merge.notification.description=以下檔案存在未解決的衝突。您需要先解決它們，然後再{0}。
branch.ui.handler.merge.error.notification.title=仍然存在未解決的檔案。
branch.ui.handler.rollback=回滾
branch.ui.handler.do.not.rollback=不回滾
branch.ui.handler.you.have.to.resolve.all.conflicts.before.operation.name=您必須先解決所有合併衝突，然後才能{0}。<br/>{1}
branch.ui.handler.delete.remote.branches=刪除遠端 {0,choice,1#分支|2#分支}
branch.ui.handler.delete.all=全部刪除
branch.ui.handler.delete.remote.branches.question=刪除遠端 {0,choice,1#分支|2#分支} {1}?
branch.ui.handler.delete.tracking.local.branch.as.well=同時刪除跟踪本地分支 {0}
branch.ui.handler.delete.tracking.local.branches=刪除跟踪本地分支:

delete.tag.operation.could.not.restore.tag=無法恢復 {0}
delete.tag.operation.error.during.rollback.of.tag.deletion=標記刪除回滾期間出錯
delete.tag.operation.restored.tag=已恢復標記 {0}
delete.tag.operation.rollback.successful=回滾成功
delete.tag.operation.restoring.tag.process=正在恢復標記 {0}…
delete.tag.operation.deleted.tag=<b>已刪除的標記:</b> {0}
delete.tag.operation.delete.on.remote=在 {0,choice,1#遠端|2#遠端} 上刪除
delete.tag.operation.could.not.find.tag=無法找到標記 {0}
delete.tag.operation.could.not.find.tag.in=在 {0} 中找不到標記
delete.tag.operation.tag.was.not.deleted=未刪除標記 {0}
delete.tag.operation.however.tag.deletion.has.succeeded.for.the.following=不過，以下{0,choice,1#版本庫|2#版本庫}的標記刪除已成功:
delete.tag.operation.you.may.rollback.not.to.let.tags.diverge=您可以回滾(在這些根中重新創建 {0})以使標記不出現分叉。

branch.renaming.branch.process=正在將 {0} 重命名為 {1}…
branch.rebasing.process=正在變基 {0}…
branch.rebasing.onto.process=正在變基到 ''{0}''…
branch.merging.process=正在合併 {0}…
branch.deleting.tag.process=正在刪除標記 {0}…
branch.deleting.tag.on.remote.process=正在刪除遠端上的標記 {0}…
branch.deleting.remote.branch=正在刪除 {0}…
branch.deleting.branch.process=正在刪除 {0}…
branch.checking.out.new.branch.process=正在簽出新分支 {0}…
branch.creating.branch.process=正在創建分支 {0}…
branch.checking.out.branch.from.process=正在從 {1} 簽出 {0}…
branch.checking.out.process=正在簽出 {0}…

branch.not.fully.merged.dialog.repository.label=版本庫:
branch.not.fully.merged.dialog.title=分支未完全合併
branch.not.fully.merged.dialog.restore.button=恢復(&R)
branch.not.fully.merged.dialog.all.commits.from.branch.were.merged=已合併來自分支 {0} 的所有提交
branch.not.fully.merged.dialog.the.branch.was.not.fully.merged.to=分支 {0} 未完全合併到 {1}。<br/>以下是未合併提交的列表。

merge.dialog.customizer.filter.by.conflicted.file.checkbox=按衝突檔案篩選
merge.dialog.customizer.show.details.link.label=顯示詳細資訊
merge.dialog.customizer.collecting.details.progress=正在收集提交詳細資訊…

branch.worker.could.not.create.tag=無法在 {1,choice,0#|1#|2#在 {2} 中} 創建標記 {0}

commit.options.sign.off.commit.checkbox=Sign-off 提交
commit.options.sign.off.commit.message.line=在提交訊息結尾添加以下行:<br/>Signed-off by: {0}
commit.options.create.extra.commit.with.file.movements=使用檔案移動創建額外提交

show.diff.between.dialog.title={0}與當前工作樹之間的變更
show.diff.between.dialog.no.differences.empty.text=無差異
show.diff.between.dialog.could.not.load.diff.with.branch.error=無法載入與 {0} 的差異: {1}
annotations.options.detect.movements.across.files=檢測跨檔案的移動
annotations.options.detect.movements.within.file=檢測檔案內的移動
annotations.options.ignore.whitespaces=忽略空格
annotations.options.group=選項
progress.title.moving.files=正在移動檔案…

editor.promo.commit.text=使用提交接口直接從 {0} 提交。
editor.promo.commit.try.link=嘗試
editor.promo.help.link=了解詳情
editor.promo.close.link=不再顯示

tracked.branch.fix.dialog.title=更新
tracked.branch.fix.dialog.ok.button.text=更新
tracked.branch.fix.dialog.set.as.tracked=設為跟踪分支
tracked.branch.fix.dialog.branch.placeholder=指定分支
tracked.branch.fix.dialog.not.on.branch.title=游離的 HEAD 中的 Git 版本庫
tracked.branch.fix.dialog.not.on.branch.message=將跳過以下版本庫:
progress.title.enabling.git=正在啟用 Git…

action.selected.file.text=選定{0,choice,1#檔案|2#檔案}
action.selected.directory.text=選定{0,choice,1#目錄|2#目錄}
action.New.Branch.disabled.several.commits.description=選擇單個提交以創建新分支
action.New.Branch.disabled.fresh.description=無法在空版本庫中創建新分支。首先進行初始提交

conflicts.type.both.deleted=均已刪除
conflicts.type.both.added=均已添加
conflicts.type.both.modified=均已修改
conflicts.type.deleted.by.you=由您刪除
conflicts.type.deleted.by.them=由他們刪除
conflicts.type.added.by.you=由您添加
conflicts.type.added.by.them=由他們添加
conflicts.merge.window.error.title=無法解決衝突
conflicts.merge.window.error.message=找不到 {0} 的檔案
conflicts.accept.progress=正在解析 {0,choice,1#個衝突|2#個衝突}
conflicts.loading.status=正在載入合併衝突…
conflicts.resolve.action.text=解決
conflicts.accept.theirs.action.text=接受他們的變更
conflicts.accept.yours.action.text=接受您的變更

remotes.dialog.title=Git 遠端
remotes.dialog.adding.remote=正在添加遠端…
remote.dialog.add.remote=添加遠端
remotes.dialog.cannot.add.remote.error.message=無法添加遠端 {0} ''{1}''
remotes.dialog.remove.remote.message=移除 {0,choice,1#遠端|2#遠端}{1}?
remotes.dialog.remove.remote.title=移除 {0,choice,1#遠端|2#遠端}
remotes.dialog.removing.remote.progress=正在移除{0,choice,1#遠端|2#遠端}…
remotes.dialog.removing.remote.error.title=移除 {0,choice,1#遠端|2#遠端}
remotes.dialog.removing.remote.error.message=無法移除{0, choice, 1#遠端|2#遠端} {1}
remotes.changing.remote.progress=正在更改遠端…
remotes.changing.remote.error.title=更改遠端
remotes.changing.remote.error.message=無法將遠端 {0} 更改為 {1} ''{2}''
remotes.operation.not.executed.message=操作未執行
remotes.operation.error.message=在 {1} 中{0}:\\\\n{2}
remotes.remote.column.name=名稱
remotes.remote.column.url=URL
remotes.define.remote=定義遠端
remotes.define.remote.name=名稱:
remotes.define.remote.url=URL:
remotes.define.empty.remote.name.validation.message=遠端名稱不能為空
remotes.define.empty.remote.url.validation.message=遠端 URL 不能為空
remotes.define.invalid.remote.name.validation.message=遠端名稱包含非法字符
remotes.define.duplicate.remote.name.validation.message=遠端名稱 ''{0}'' 已被使用
tab.title.repo.root.name.at.revision={1} 的 {0}
tab.title.conflicts=衝突

button.crlf.fix.dialog.commit.as.is=按原樣提交
button.crlf.fix.dialog.fix.and.commit=修復並提交
title.crlf.fix.dialog=行分隔符警告
text.crlf.fix.dialog.description.warning=您即將把 CRLF 行分隔符提交到 Git 版本庫。<br/>建議將 {0} Git 特性設定為 {1}，以免發生行分隔符問題。
text.crlf.fix.dialog.description.proposed.fix=如果選擇<b>修正並提交</b>，將執行 {0}。<br/>如果選擇<b>按原樣提交</b>，則不會更改配置值。
progress.finishing.conflict.resolve=正在解決衝突
link.label.editor.notification.merge.conflicts.resolve.in.progress=正在解決合併衝突
link.label.merge.conflicts.resolve.in.progress.focus.window=使視窗獲得焦點
link.label.merge.conflicts.resolve.in.progress.cancel.resolve=取消解決
label.diff.content.title.submodule.suffix={0} (子模組)
error.git.version.check.failed=執行 ''git --version'' 時出錯。退出程式碼: {0}，錯誤: {1}

local.changes.save.policy.stash=儲藏
local.changes.save.policy.shelve=擱置
notification.title.fetch.failure=獲取失敗
notification.title.fetch.success=獲取成功
title.sudo.command.install.git=安裝 Git

activity.name.unstash=取消儲藏
notification.title.unstash.failed=取消儲藏失敗
exception.message.could.not.stash.root.error=無法儲藏 {0}: {1}
error.git.parse.unknown.file.status=未知檔案狀態: {0}
error.git.parse.not.a.revision.number=字串 ''{0}'' 不表示修訂號
error.git.repository.not.found=該版本庫不再存在: {0}

title.changes.excluded.from.commit=已從合併提交中排除變更
label.changes.excluded.from.commit.are.you.sure.want.to.continue=是否確定要從合併提交中排除這些變更過的檔案?
button.changes.excluded.from.commit.commit.anyway=仍然提交
title.unresolved.conflicts.pre.commit.check=未解決的衝突
message.unresolved.conflicts.prevent.commit=由於有未解決的衝突，無法提交變更。

label.user.name=名稱:
label.user.email=電子郵件:
checkbox.set.config.property.globally=全域設定屬性
title.user.name.email.not.specified=未定義 Git 用戶名
button.set.name.and.commit=設定並提交
validation.warning.set.name.email.for.git=您必須為 Git 指定用戶名和電子郵件
label.name.email.not.defined.in.n.roots={0,choice,1#根|2#根}中未定義 Git 的 user.name 和 user.email 屬性
error.cant.set.user.name.email=無法設定 user.name 和 user.email
progress.checking.user.name.email=正在檢查 Git 用戶名…
progress.setting.user.name.email=正在設定 Git 用戶名…
progress.setting.config.value=正在更新 Git 配置…
progress.checking.line.separator.issues=正在檢查行分隔符問題…
error.title.git.version.does.not.define.home.env=HOME 變數未定義
error.message.git.version.does.not.define.home.env=您正在使用 Git {0}，它沒有正確定義 %HOME% 環境變數。\\\\n不妨將 Git 更新到較新的版本，或將 %HOME% 定義為指向全域 .gitconfig 的存儲位置\\\\n(通常為 %USERPROFILE% 或 %HOMEDRIVE%%HOMEPATH%)。
warning.title.commit.with.unfinished.rebase=未完成變基進程
warning.message.commit.with.unfinished.rebase=以下路徑中的 Git 版本庫有一個<b>未完成的變基</b>進程: <br/> {0}<br/>您可能想<b>繼續變基</b>而不是提交。<br/>在變基期間提交可能會導致提交丟失。
link.label.commit.with.unfinished.rebase.read.more=閱讀有關 Git 變基的更多資訊
warning.title.commit.with.detached.head=在游離的 HEAD 中提交
warning.message.commit.with.detached.head=以下路徑中的 Git 版本庫處於<b>游離的 HEAD</b> 狀態: <br/>{0}<br/>您可以進行檢查，嘗試做出變更並提交，但務必簽出分支，以免丟失您的工作。<br/>否則，可能會丟失所做的變更。
link.label.commit.with.detached.head.read.more=閱讀有關游離的 HEAD 的更多資訊
error.commit.cant.collect.partial.changes=無法收集要提交的部分變更
error.commit.cant.commit.multiple.changelists=無法一次提交多個變更列表中的變更
error.commit.cant.commit.with.unmerged.paths=由於您有未合併的檔案，因此無法提交。
error.commit.cant.create.message.file=創建提交訊息檔案失敗
button.commit.all.files=提交所有檔案
title.ssh.confirmation=SSH 確認
label.credential.store.key.ssh.passphrase=Git SSH 密碼短語
label.credential.store.key.ssh.password=Git SSH 密碼
label.credential.store.key.http.password=Git HTTP
error.cannot.delete.file=無法刪除檔案: {0}
action.description.cant.revert.merge.commit=不允許還原合併提交
progress.title.reverting.n.commits=正在還原{0,choice,1#提交|2#提交}
progress.title.validating.revision=正在驗證修訂…

revision.number.cannot.parse.output=無法解析輸出: [{0}]

unexpected.tree.entries.error=意外的樹條目: {0}
unexpected.tree.object.error=意外的樹物件: {0}
revert.operation.name=還原
revert.operation.applied=還原
cherry.pick.name=優選
cherry.pick.applied=套用
operation.name.validating.revision.0=驗證修訂 {0}
operation.name.loading.revision=載入修訂
combobox.item.file.invalid=(無效)
warning.your.local.changes.would.be.overwritten.by.merge=您的本地變更將被合併覆蓋。\\\\n提交、存儲或還原您的變更以繼續。
link.label.local.changes.would.be.overwritten.by.merge.view.them=查看這些變更
dialog.title.local.changes.prevent.from.operation=本地變更阻止{0}
notification.title.git.operation.failed=Git {0} 失敗
notification.title.untracked.files.prevent.operation=未跟踪的檔案會阻止{0}
notification.content.untracked.files.prevent.operation.move.or.commit=在 {0} 前移動或提交<br/>{1}
dialog.title.could.not.operation=無法{0}
dialog.title.untracked.files.preventing.operation=阻止{0}的未跟踪檔案
dialog.message.untracked.files.will.be.overwritten.by.operation=這些未跟踪的檔案將被{0}覆蓋
button.rollback=回滾
button.don.t.rollback=不回滾
progress.title.update=更新
notification.content.fetched.successfully=已成功獲取
notification.content.fetch.cancelled.by.user=使用者取消了獲取
notification.content.fetch.failed.couldn.t.authorize=獲取失敗: 授權錯誤
notification.content.couldn.t.authorize=授權錯誤
notification.title.fetch.failed=獲取失敗
notification.title.fetch.details=獲取詳細資訊
notification.title.couldn.t.reset.merge=無法中止合併操作
notification.title.error.merging=合併錯誤
progress.text.merging.repository=正在合併 {0}…
dialog.title.rebasing.merge.commits=正在變基合併提交
dialog.message.rebasing.merge.commits=您即將變基存在衝突的合併提交。\\\\n\\\\n如果您不想再次解決衝突，請選擇“合併”; 如果要將歷史記錄線性化，仍可進行變基。
rebasing.merge.commits.button.merge=合併
rebasing.merge.commits.button.rebase=變基
rebasing.merge.commits.button.cancel=取消
progress.details.refreshing.files.for.root=正在刷新根 {0} 的檔案
activity.name.update=VCS 更新
notification.title.couldnt.collect.updated.files.info=無法收集已更新檔案的資訊
notification.content.couldnt.collect.updated.files.info={0} 更新成功，但由於發生了一個錯誤，無法收集更新的變更
notification.title.update.failed=更新失敗
notification.title.can.t.update.no.current.branch=無法更新: 無當前分支
notification.content.detached.state.in.root.checkout.branch=您處於“游離的 HEAD”狀態，這表明您不在任何分支 {0} 上<br/>簽出分支以更新專案。
notification.content.branch.in.repo.has.no.tracked.branch={0} {1} 沒有跟踪的分支
notification.title.error.updating.root=更新 {0} 期間出錯
notification.content.updating.root.failed.with.error=更新 {0} 失敗，出現錯誤: {1}
git.update.operation=更新
progress.update.destination.remote=遠端
no.revisions.available=無修訂
search.everywhere.group.name=Git
search.everywhere.group.full.name=Git 引用
search.everywhere.items.commit.by.hash=提交(按哈希)
search.everywhere.items.local.branch=本地分支
search.everywhere.items.remote.branch=遠端分支
search.everywhere.items.tag=標記
search.everywhere.items.commit.by.message=提交(按訊息)
commit.author.with.committer={0}，通過 {1}

stage.diff.staged.content.exception.message=無法獲取暫存內容: ''{0}''
stage.vfs.shutdown.process=正在關閉 Git 索引 VFS
apply.changes.unresolved.conflicts.text=工作樹中有未解決的衝突。
apply.changes.unresolved.conflicts.notification.resolve.action.text=解決…
apply.changes.unresolved.conflicts.notification.abort.action.text=中止{0}
action.Git.Commit.Stage.text=提交…
git.executable.error.bash.not.found=找不到 bash 可執行檔案
settings.label.sign.gpg.commits.loading.text=使用 GPG 密鑰簽署提交: 正在讀取配置…
settings.label.sign.gpg.commits.not.configured.text=未配置使用 GPG 密鑰簽署提交
settings.label.sign.gpg.commits.enabled.text=提交使用 GPG 密鑰簽署: {0}
settings.label.sign.gpg.commits.enabled.different.keys.text=提交使用不同的 GPG 密鑰簽署
settings.label.sign.gpg.commits.enabled.n.roots.of.m.text=提交使用 {1} 的 {0} 個{0,choice,1#根|2#根}中的 GPG 密鑰簽署
settings.sign.gpg.configure.link.text=配置 GPG 密鑰…
settings.configure.sign.gpg.synced.with.gitconfig.text=與 gitconfig 同步
settings.configure.sign.gpg.for.repo.dialog.title=配置 GPG 密鑰 {0}
settings.configure.sign.gpg.for.repos.dialog.title=配置 GPG 密鑰
settings.configure.sign.gpg.with.key.checkbox.text=使用 GPG 密鑰簽署提交:
settings.configure.sign.gpg.root.table.column.name=根
settings.configure.sign.gpg.gpg.kep.table.column.name=GPG 密鑰
settings.configure.sign.gpg.do.not.sign.table.text=不簽署
settings.configure.sign.gpg.error.table.text=錯誤: {0}
settings.configure.sign.gpg.error.no.available.keys.found.text=找不到適用的私鑰
settings.configure.sign.gpg.loading.table.text=正在載入…
column.name.commit.signature=GPG 簽名
tooltip.no.commit.signature=無 GPG 簽名
tooltip.commit.signature.verify.failure=GPG 簽名未驗證
tooltip.commit.signature.verify.success=GPG 簽名已驗證
branch.direction.panel.branch.label=分支:
branch.direction.panel.save.button=儲存
branch.direction.panel.base.repo.label=基礎版本庫:
branch.direction.panel.head.repo.label=Head 版本庫:
branch.direction.panel.select.link=選擇…
branch.direction.panel.warning.push=''{0}'' 沒有遠端分支。\\\\n將在 ''{1}'' 上創建新的遠端分支。
branch.direction.panel.warning.not.synced=本地分支未與遠端分支同步。\\\\n''{0}'' 分支將與 ''{1}'' 同步。
push.failed.error.message=推送失敗: {0}
advanced.settings.git=版本控制。Git
advanced.setting.git.clone.recurse.submodules=遞歸克隆專案中的子模組
advanced.setting.git.clone.recurse.submodules.description=啟用後，從 Git 調用 'git clone --recurse-submodules' 簽出，即克隆主版本庫與所有子模組 (如有)
advanced.setting.git.use.push.force.with.lease=使用安全強制推送
advanced.setting.git.use.push.force.with.lease.description=從 IDE 調用強制推送時使用 '--force-with-lease'，而非僅使用 '--force'
advanced.setting.git.update.incoming.outgoing.info=檢查傳入和傳出提交
advanced.setting.git.update.incoming.outgoing.info.description=在“分支”彈出視窗中更新具有傳入/傳出提交的分支資訊
advanced.setting.git.read.content.with=從 Git 讀取時套用內容轉換
advanced.setting.git.read.content.with.description=從 Git 讀取檔案內容時為 'git cat-file' 命令使用 '--filters' 或 '--textconv' 標誌
advanced.setting.git.use.schannel.on.windows=使用 Windows 證書存儲
advanced.setting.git.use.schannel.on.windows.description=強制 Git 使用 Windows 證書存儲來驗證 SSL 連接。適用於 Git 2.14 及更高版本。
git.content.transform.none=無
git.content.transform.filters=篩選器
git.content.transform.textconv=TextConv
settings.label.sign.gpg.commits.no.roots.text=專案中沒有 Git 根
gpg.error.see.documentation.link.text=參閱 GPG 設定指南
gpg.jb.manual.link=Set_up_GPG_commit_signing
settings.commit.group.title=提交
settings.push.group.title=推送
settings.update.group.title=更新
error.unresolved.conflicts=解決衝突以提交
stash.changes.empty=選擇儲藏以查看變更
stash.changes.loading=正在載入…
branches.checkout.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。將 ''{0}'' 變基到 ''{1}''，還是簽出 ''{0}''?
branches.checkout.with.reset.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。將 ''{0}'' 變基到 ''{1}''，還是刪除本地提交?
branches.create.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。要在其他版本庫中創建分支嗎?
branches.create.with.reset.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。要刪除本地提交嗎?
branches.checkout.local=簽出本地分支
notification.title.unstash.failed.index.conflict=由於索引衝突，取消儲藏失敗
branches.checkout.and.rebase.failed=簽出和變基失敗
branches.checkout.and.rebase.error.current.with.same.name=無法覆蓋當前分支 {0}
branches.checkout.and.rebase.onto.current.process=正在簽出 {0} 並變基到當前分支
progress.title.creating.git.repository=正在創建 Git 版本庫…
stash.load.changes.error=無法在解析為 {1} 的儲藏中載入根 {0} 中的變更
git.log.diff.handler.changes.between.revisions.title={0} 與 {1} 之間的變更
git.log.diff.handler.changes.between.revisions.in.paths.title={2} 中 {0} 與 {1} 之間的變更
commit.signature.verified=已驗證的 GPG 簽名
commit.signature.unverified=未驗證的 GPG 簽名
action.Git.PushUpToCommit.text=推送此前所有提交…
action.Git.PushUpToCommit.description=推送所有之前的提交，包括所選提交
push.upto.here.not.supported.notification.title=無法啟動推送
push.upto.here.not.supported.notification.message=“推送此前所有提交”僅支援包含在本地分支中的提交
push.upto.here.failed.dialog.title=無法啟動推送
push.up.to.commit.allowed.progress.title=正在檢查是否允許推送到所選提交…
push.up.to.commit.getting.reference.progress.title=正在獲取對 HEAD 的提交引用…
git.toolbar.widget.no.repo=無版本庫
push.rejected.remember.checkbox=請記住更新方法，並在日後進行靜默更新(&S)。稍後可以在“{0} | 版本控制”中進行更改。<br/>
push.rejected.specific.repo=版本庫 \\"{1}\\" 中的當前分支 \\"{0}\\" 推送被拒。
git.status.bar.widget.text.unknown=<未知>
git.toolbar.widget.tooltip=Git 分支: {0}
action.Git.Toolbar.ShowMoreActions.text=版本控制
action.Git.ShowBranches.text=顯示分支
action.Git.ShowBranches.description=顯示分支
action.Git.Toolbar.ShowMoreActions.description=VCS 操作
stash.editor.diff.preview.id.change.title={0}：{1}"
`;

exports[`dev messages/GithubBundle.properties 1`] = `
"#general
accessing.github=正在存取 GitHub
retry.action=重試
retry.link=重試
open.in.browser.link=在瀏覽器中打開
user.someone=某人
progress.title.not.visible=不可見
action.comment.text=評論
group.GitHub.MainMenu.text=GitHub
#settings
settings.clone.ssh=使用 ssh 克隆 Git 版本庫
settings.timeout=連接超時:
settings.timeout.seconds=秒
#accounts
action.Github.Accounts.AddGHAccount.text=通過 GitHub 登錄…
action.Github.Accounts.AddGHAccountWithToken.text=通過令牌登錄…
action.Github.Accounts.AddGHEAccount.text=登錄 GitHub Enterprise…
dialog.title.add.github.account=添加 GitHub 帳戶
dialog.message.account.cannot.be.empty=帳戶不能為空
accounts.remove=移除帳戶
accounts.set.default=設定為預設值
accounts.log.out=退出…
accounts.relogin=重新登錄
accounts.label.no.accounts=無帳戶
accounts.default.missing=缺少預設的 GitHub 帳戶
button.login.mnemonic=登錄(&L)
login.link=登錄
login.action=登錄
login.via.github.action=通過 GitHub 登錄…
login.with.token.action=通過令牌登錄…
login.to.github.enterprise.action=登錄 GitHub Enterprise…
button.use.token=使用令牌…
dialog.message.login.to.continue=登錄到 GitHub 以繼續
login.to.github=登錄 GitHub
login.to.github.enterprise=登錄 GitHub Enterprise
label.login.progress=正在登錄…
label.login.option.separator=或
link.label.use.token=使用令牌…
login.use.token=使用令牌
login.token.cannot.be.empty=令牌不能為空
login.account.already.added=已添加帳戶 ''{0}''
login.insufficient.scopes=必須為存取令牌授予以下範圍: {0}
login.sign.up=註冊 GitHub
login.use.credentials=使用憑證
credentials.server.field=伺服器:
credentials.server.cannot.be.empty=伺服器不能為空
credentials.server.path.invalid=伺服器 URL 無效
credentials.token.field=令牌:
credentials.button.generate=生成…
credentials.incorrect=憑證不正確。\\\\n{0}
credentials.invalid.auth.data=身份驗證資料無效。\\\\n{0}
credentials.invalid.server.path=伺服器路徑無效
credentials.login.cannot.be.empty=登錄名不能為空
credentials.login.field=登錄名:
credentials.password.cannot.be.empty=密碼不能為空
credentials.password.field=密碼:
credentials.password.not.saved=該密碼未儲存，僅用於生成 GitHub 令牌
credentials.2fa.dialog.title=GitHub 雙重身份驗證
credentials.2fa.dialog.code.field=身份驗證程式碼:
account.choose.for=選擇 GitHub 帳戶: {0}
account.choose.title=選擇 GitHub 帳戶
account.choose.link=選擇帳戶
account.choose.button=選擇
account.choose.not.selected=未選擇帳戶
account.choose.as.default=設定為當前專案的預設帳戶
account.token.missing.for=缺少 {0} 的存取令牌
account.token.missing=缺少存取令牌
#clone
clone.button=克隆
clone.dialog.clone.failed=克隆失敗
clone.dialog.directory.field=目錄:
clone.dialog.text=克隆 ''{0}''
clone.error.load.repositories=無法載入版本庫
clone.error.unable.to.create.dest.dir=無法創建目標目錄
clone.error.unable.to.find.dest=無法找到目標
#tasks
task.repo.host.field=主機:
task.repo.repository.field=版本庫:
task.repo.owner.field.empty.hint=版本庫所有者
task.repo.name.field.empty.hint=版本庫名稱
task.repo.token.field=API 令牌:
task.repo.token.field.empty.hint=OAuth2 令牌
task.repo.token.create.button=創建 API 令牌
task.comment.author=作者:
task.comment.date=日期:
#gist
create.gist.action.title=創建 Gist…
create.gist.action.description=創建 GitHub gist
create.gist.dialog.title=創建 Gist
create.gist.dialog.copy.url=複製 URL
create.gist.dialog.create.for.field=為以下帳戶創建:
create.gist.dialog.description.field=描述:
create.gist.dialog.filename.field=文件名:
create.gist.dialog.open.browser=在瀏覽器中打開
create.gist.dialog.secret=密鑰
create.gist.process=正在創建 gist…
create.gist.success=已成功創建 Gist
create.gist.url=您的 gist url
create.gist.error.empty=無法創建空 gist
create.gist.error.binary.file=無法上傳二進制檔案: {0}
create.gist.error.content.read=無法讀取檔案 {0} 的內容
#open on github
open.on.github.action=在 GitHub 上打開
action.Github.Open.In.Browser.EditorTabPopup.text=GitHub
open.on.github.action.description=在瀏覽器中打開相應鏈接
open.on.github.file.is.not.under.repository=檔案不在版本庫根下
open.on.github.getting.last.revision=正在獲取最新修訂
#rebase
rebase.action=同步復刻
rebase.action.description=相對於來源變基 GitHub 復刻版本庫
rebase.process=正在變基 GitHub 復刻…
rebase.process.adding.github.parent.as.remote.host=正在將 GitHub 父項添加為遠端主機…
rebase.process.configuring.upstream.remote=正在配置上游遠端…
rebase.process.fetching.upstream=正在獲取上游…
rebase.process.operation.title=正在變基
rebase.process.rebasing.branch.onto=正在將當前分支變基到 ''{0}''…
rebase.process.rebasing.onto=正在變基到 ''{0}''…
rebase.process.success=已成功變基 GitHub 復刻
rebase.error=無法執行 GitHub 變基
rebase.error.multi.repo.not.supported=不支持多版本庫專案
rebase.error.remote.origin.not.found=找不到 Git 遠端 'origin'
rebase.error.no.suitable.account.found=找不到合適的 GitHub 帳戶
rebase.error.failed.to.match.gh.repo=無法符合本地版本庫和 GitHub 版本庫
rebase.error.repo.not.found=找不到版本庫 {0}
rebase.error.upstream.not.found=未添加遠端 {0}
rebase.error.no.default.branch=無法確定上游分支 - 沒有為版本庫設定預設分支
#share
share.action=在 GitHub 上共享專案
share.action.description=在 GitHub 上輕鬆共享專案
share.action.remote.is.on.github=遠端已經在 GitHub 上:
share.action.remotes.are.on.github=GitHub 上已經有以下遠端:
share.anyway.button=仍然共享
share.on.github=在 GitHub 上共享專案
share.button=共享
share.dialog.account.info.load.error.prefix=無法載入 {0} 的資訊:
share.dialog.account.info.load.process.canceled=已取消進程
share.dialog.description=描述:
share.dialog.private=私有
share.dialog.remote=遠端:
share.dialog.repo.name=版本庫名稱:
share.dialog.share.by=共享者:
share.process.loading.account.info=正在載入 {0} 的帳戶資訊
share.process=正在 GitHub 上共享專案…
share.process.creating.git.repository=正在創建空 git 版本庫…
share.process.adding.files=正在將檔案添加到 git…
share.process.performing.commit=正在執行提交…
share.process.retrieving.username=正在檢索用戶名…
share.process.creating.repository=正在創建 GitHub 版本庫…
share.process.adding.gh.as.remote.host=正在將 GitHub 添加為遠端主機…
share.process.pushing.to.github.master=正在推送到 GitHub master…
share.process.empty.project.created=已在 GitHub 上成功創建空版本庫
share.process.successfully.shared=已在 GitHub 上成功共享專案
share.error.cannot.finish=無法完成 GitHub 共享過程
share.error.remote.with.selected.name.exists=已存在具有所選名稱的遠端
share.error.repo.with.selected.name.exists=已存在具有所選名稱的版本庫
share.error.failed.to.create.repo=無法創建 GitHub 版本庫
share.error.private.repos.not.supported=您的帳戶不支持私有版本庫
share.error.project.is.on.github=專案已在 GitHub 上
share.error.created.project=已在 GitHub 上成功創建專案
share.error.init.commit.failed=，但初始提交失敗:<br/>
share.error.push.failed=，但初始推送失敗:<br/>{0}
share.error.push.no.current.branch=，但初始推送失敗: 沒有當前分支
share.validation.no.remote.name=未選擇遠端名稱
share.validation.no.repo.name=未選擇版本庫名稱
share.validation.invalid.repo.name=版本庫名稱無效。名稱應由字母、數字、短划線、點和下划線組成
untracked.files.dialog.title=為初始提交添加檔案
#create PR
tab.title.pull.requests.new=在 {0} 新建拉取請求
pull.request.create.show.form.action=創建拉取請求…
pull.request.create.direction.base.repo=基礎版本庫:
pull.request.create.direction.head.repo=Head 版本庫:
pull.request.create.process.title=正在創建拉取請求…
pull.request.existing.process.title=正在檢查是否已存在拉取請求…
pull.request.create.title=標題
pull.request.create.description=描述
pull.request.create.loading.template=正在載入模板…
pull.request.create.input.remote.branch.name=遠端分支名稱:
pull.request.create.input.remote.branch.title=拉取請求分支
pull.request.create.input.remote.branch.comment=必須推送更改才能創建拉取請求，並且本地分支 ''{0}'' 不會跟踪 ''{1}'' 處的遠端分支
pull.request.create.action=創建拉取請求
pull.request.create.draft.action=創建草稿拉取請求
pull.request.create.discard.title=刪除拉取請求草稿
pull.request.create.discard.message=要刪除新拉取請求的草稿嗎?
pull.request.create.discard.approve=刪除草稿
pull.request.create.no.changes=''{0}'' 和 ''{1}'' 之間沒有變更
pull.request.create.already.exists=拉取請求已存在
pull.request.create.already.exists.view=查看
pull.request.create.select.branches=已選擇拉取請求的 base 和 head 來查看變更

pull.request.num=拉取請求 #{0,number,#}
# TW content
toolwindow.stripe.Pull_Requests=拉取請求
tab.title.pull.requests.at={0} 中的拉取請求
pull.request.view.list=查看拉取請求
pull.request.login.note=稍後在齒輪圖標下更改版本庫或帳戶
pull.request.change.remote.or.account=更改版本庫或帳戶…
pull.request.loading.data=正在載入資料…
pull.request.loading.account.info=正在載入帳戶資訊
pull.request.loading.repo.info=正在載入版本庫資訊
pull.request.loading.user.teams.info=正在載入使用者團隊資訊
pull.request.list.item.info=#{0,number,#} {1}，{2}
pull.request.list.no.matches=沒有與篩選器符合的拉取請求。
pull.request.list.nothing.loaded=無拉取請求
pull.request.list.outdated=該列表已過時。
pull.request.list.refresh=刷新
pull.request.list.search.history=搜尋歷史記錄 {0}
pull.request.list.reset.filters=重置篩選器
pull.request.list.cannot.load=無法載入拉取請求
pull.request.open.action=查看拉取請求
pull.request.select.action=選擇開放的拉取請求
pull.request.back.to.list=返回列表
pull.request.info=資訊
pull.request.files=檔案
pull.request.commits=提交
pull.request.select.commit.to.view.changes=選擇要查看變更的提交
pull.request.does.not.contain.changes=拉取請求不包含任何變更
pull.request.does.not.contain.commits=拉取請求不包含任何提交
pull.request.commit.does.not.contain.changes=提交不包含任何變更
pull.request.open.action.description=查看拉取請求資訊和時間線
pull.request.view.conversations.action=查看對話
pull.request.view.conversations.action.description=查看拉取請求時間線
pull.request.refresh.changes.action=刷新拉取請求變更
pull.request.refresh.comments.action=刷新拉取請求評論
pull.request.refresh.details.action=刷新拉取請求詳細資訊
pull.request.refresh.state.action=刷新拉取請求狀態
pull.request.refresh.list.action=刷新列表
pull.request.editor.diff=拉取請求差異
pull.request.editor.timeline=拉取請求時間線
#branch checkout
pull.request.branch.checkout.create.action=簽出本地分支…
pull.request.branch.checkout.create.action.description=簽出拉取請求分支
pull.request.branch.checkout.create.dialog.title=從拉取請求 {0,number,#} 創建分支
pull.request.branch.checkout.create.task.title=從拉取請求創建分支
pull.request.branch.checkout.create.task.indicator=正在創建分支
pull.request.branch.checkout.task.title=從拉取請求簽出分支
pull.request.branch.checkout.task.indicator=正在簽出分支
pull.request.branch.checkout.set.tracking.branch.failed=無法設定跟踪分支
pull.request.branch.checkout.resolve.author.failed=無法解析拉取請求作者
pull.request.branch.checkout.resolve.remote.failed=無法解析拉取請求遠端
#branch update
pull.request.branch.update.action=更新本地分支…
pull.request.branch.update.action.description=更新拉取請求本地分支
#branch actions
pull.request.branch.action.group.name=操作(&A)
# details
pull.request.assignees=被指派者
pull.request.unassigned=未分配
pull.request.labels=標籤
pull.request.no.labels=無標籤
pull.request.reviewers=審查者
pull.request.no.reviewers=無審查者
pull.request.adding.reviewers=正在添加審查者
pull.request.removing.reviewers=正在移除審查者
pull.request.adjustment.failed=無法調整列表
#state
pull.request.state.open=開放
pull.request.state.closed=已關閉
pull.request.state.merged=已合併
pull.request.state.draft=草稿
pull.request.state.closed.long=拉取請求已關閉
pull.request.state.merged.long=拉取請求已合併
pull.request.loading.status=正在載入拉取請求狀態
pull.request.state.cannot.load=無法載入狀態
pull.request.conflicts.checking=正在檢查自動合併的能力…
pull.request.conflicts.none=分支與基礎分支沒有衝突
pull.request.conflicts.must.be.resolved=分支存在必須解決的衝突
pull.request.branch.out.of.sync=拉取請求分支與基礎分支不同步
pull.request.checks.failing={0} 個失敗
pull.request.checks.pending={0} 個掛起
pull.request.checks.successful={0} 個成功
pull.request.checks={0, choice, 1#檢查|2#檢查}
pull.request.merge.commit.action=合併…
pull.request.merge.squash.action=壓縮並合併…
pull.request.merge.rebase.action=變基並合併
pull.request.merge.message.dialog.title=合併拉取請求
pull.request.merge.pull.request=合併拉取請求 #{0,number,#}
merge.commit.dialog.message=合併提交訊息:
merge.commit.dialog.merge.button=合併
pull.request.not.authorized.to.merge=您無權將拉取請求合併到此分支
pull.request.merge.disabled=此專案已禁用合併
pull.request.mark.ready.for.review=標記為可供審查
pull.request.close.action=關閉拉取請求
pull.request.reopen.action=重新打開拉取請求
pull.request.repo.access.required=必須具有版本庫存取權限才能管理拉取請求
pull.request.repo.write.access.required=必須具有版本庫寫存取權限才能合併拉取請求
pull.request.reviewers.required=需要由具有寫入權限的審查者至少進行 {0} 次審批審查
#review
pull.request.diff.review.label=審查:
pull.request.diff.view.options=檢視選項
pull.request.diff.editor.title=拉取請求 #{0,number,#} 的差異
pull.request.new.diff.editor.title=新拉取請求的差異
pull.request.diff.editor.add.review.comment=添加審查評論
pull.request.diff.editor.add.single.comment=添加一條評論
pull.request.diff.editor.add.multiline.comment=添加一條多行評論
pull.request.diff.editor.start.review.with.multiline.comment=以多行評論開始審查
pull.request.diff.editor.add.multiline.review.comment=添加多行審查評論
pull.request.diff.editor.review.comment=評論
pull.request.diff.editor.review.start=開始審查
pull.request.diff.editor.review.with.comment=以評論開始審查
pull.request.review.submit.request.changes=請求變更
pull.request.review.submit.approve.button=批准
pull.request.review.submit.comment.button=評論
pull.request.review.submit.comment.description=提交不需要明確批准的常規反饋
pull.request.review.submit.error=提交審查時發生錯誤
pull.request.review.comment.delete.dialog.msg=確定要刪除此評論嗎?
pull.request.review.comment.delete.dialog.title=刪除評論
pull.request.discard.pending.comments.dialog.title=放棄待定審查
pull.request.discard.pending.comments.dialog.msg=確定要刪除所有待定評論嗎?
pull.request.discard.pending.comments=放棄待定評論
pull.request.review.comment.pending=待定
pull.request.review.comment.resolved=已解決
pull.request.review.comment.empty.text=審查評論
pull.request.review.commented={0} 在 {1} 添加了評論
pull.request.review.show.comments.action=顯示評論
pull.request.review.show.comments.action.description=顯示或隱藏拉取請求審查執行緒
pull.request.review.show.resolved.threads=顯示已解決的執行緒
pull.request.review.show.resolved.threads.description=顯示或隱藏已解決的拉取請求審查執行緒
pull.request.review.submit=提交
pull.request.review.submit.review=提交審查
pull.request.review.pending.comments.count={0} 個待定{0, choice, 1#註釋|2#註釋}
pull.request.review.submit.action.description=提交拉取請求審查
pull.request.review.thread.outdated=過時
pull.request.review.thread.reply=回復
pull.request.review.thread.resolve=解決
pull.request.review.thread.unresolve=取消解決
pull.request.review.refresh.data.task=刷新審查資料
pull.request.review.refresh.data.task.description=刷新 GitHub 拉取請求審查資訊
#timeline
pull.request.timeline.refresh.action=刷新時間線
pull.request.timeline.refresh.action.description=檢查新時間線事件
pull.request.timeline.and=和
pull.request.timeline.created=已創建
pull.request.timeline.commented=添加了評論
pull.request.timeline.added.label=添加了 {0} 標籤
pull.request.timeline.added.labels=添加了標籤
pull.request.timeline.removed.label=移除了 {0} 標籤
pull.request.timeline.removed.labels=移除了標籤
pull.request.timeline.assigned=分配給
pull.request.timeline.unassigned=取消分配給
pull.request.timeline.renamed=將此請求從 <b>{0}</b> 重命名為 <b>{1}</b>
pull.request.timeline.reopened=重新打開了此請求
pull.request.timeline.closed=關閉了此請求
pull.request.timeline.merged=合併了此請求
pull.request.timeline.merged.commit=已將提交 {0} 合併到 {1}
pull.request.timeline.requested.review=請求以下使用者執行審查:
pull.request.timeline.removed.review.request=移除了向以下使用者發出的審查請求:
pull.request.timeline.started.review=開始了審查
pull.request.timeline.reviewed=審查了
pull.request.timeline.review.thread.collapse=隱藏執行緒
pull.request.timeline.review.thread.expand=顯示執行緒
pull.request.timeline.approved.changes=批准了這些變更
pull.request.timeline.requested.changes=請求了變更
pull.request.timeline.marked.as.draft=將此拉取請求標記為草稿
pull.request.timeline.marked.as.ready=將此拉取請求標記為可供審查
pull.request.timeline.mentioned=提及了此物件
pull.request.timeline.connected=鏈接了可能由此物件關閉的問題
pull.request.timeline.disconnected=移除了一個指向問題的鏈接
pull.request.timeline.stale.review.dismissed=忽略了 <b>{0}</b> 過時的審查
pull.request.timeline.stale.review.author=作者
pull.request.timeline.changed.base.branch=更改了基礎分支
pull.request.timeline.branch.deleted=刪除了 {0} 分支
pull.request.timeline.branch.force.pushed=強制推送了 {0} 分支
pull.request.timeline.branch.head.restored=恢復了 head 分支
pull.request.timeline.cannot.load=無法載入時間線條目
#various errors
cannot.collect.additional.data=無法收集其他資料
cannot.collect.diff.data=無法收集差異資料
cannot.configure.remote=無法配置 ''{0}'' 遠端:\\\\n{1}
cannot.create.gist=無法創建 Gist
cannot.display.item=無法顯示條目 - {0}
cannot.find.fork=無法找到所選用戶的復刻
cannot.find.git.repo=無法找到 Git 版本庫
cannot.find.repository=無法找到版本庫
cannot.get.last.revision=無法獲取最新修訂。
cannot.get.user.info=無法獲取使用者資訊
cannot.load.changes=無法載入變更
cannot.load.commits=無法載入提交
cannot.load.data.from.github=無法從 GitHub 載入資料
cannot.load.data=無法載入資料
cannot.load.details=無法載入詳細資訊
cannot.load.repo.info=無法載入版本庫資訊
cannot.open.in.browser=無法在瀏覽器中打開
cannot.process.remote=無法處理遠端: {0}
cannot.retrieve.upstream.info=無法檢索 {0} 的上游資訊
unknown.loading.error=未知載入錯誤
server.unreachable=伺服器無法到達
gql.error.in.field={1} 的“{2}”欄位中存在 {0} 錯誤
pull.request.review.not.supported.non.linear=非線性提交歷史記錄不支持按提交審查
#issues
issue.state.open=開放
issue.state.closed=已關閉

#protected branches
progress.text.loading.protected.branches=正在載入 GitHub 分支保護規則

pull.request.details.adjusting.reviewers=正在調整審查者…
pull.request.details.adjusting.assignees=正在調整被指派者…
pull.request.details.adjusting.labels=正在調整標籤…
accounts.add.dropdown.link=添加帳戶
accounts.add.button=添加帳戶
account.scopes.insufficient=安全範圍不足
pull.request.create.error=無法創建新的拉取請求:
pull.request.list.reset.filters.to.default=重置為{0}
action.GithubCopyPathProvider.text=GitHub 版本庫 URL"
`;

exports[`dev messages/InspectionGadgetsBundle.properties 1`] = `
"cast.to.concrete.class.problem.descriptor=轉換為具體類 <code>{0}</code> #loc
class.references.subclass.display.name=類引用其子類之一
class.references.subclass.problem.descriptor=類 ''{0}'' 引用子類 <code>#ref</code> #loc
class.references.subclass.problem.descriptor.anonymous=匿名類引用子類 <code>#ref</code> #loc
collection.declared.by.class.display.name=按類 (而不是接口) 宣告的集合
collection.declared.by.class.problem.descriptor=<code>#ref</code> 的宣告可能應當被削弱為 ''{0}'' #loc
collection.declared.by.class.ignore.locals.option=忽略局部變數
collection.declared.by.class.ignore.private.members.option=忽略 'private' 欄位和方法
feature.envy.display.name=特性依戀
feature.envy.problem.descriptor=類 ''{0}'' 在方法 <code>#ref()</code> 中被重複存取 #loc
bounded.wildcard.display.name=可以使用有界萬用字元
bounded.wildcard.contravariant.descriptor=可以泛化為 <code>? super #ref</code> #loc
bounded.wildcard.covariant.descriptor=可以泛化為 <code>? extends #ref</code> #loc
bounded.wildcard.report.invariant.option=報告固定類
bounded.wildcard.report.private.option=報告 private 方法
bounded.wildcard.report.instance.option=報告實例方法
instance.variable.of.concrete.class.problem.descriptor=具體類 <code>#ref</code> 的實例欄位 ''{0}'' #loc
chain.of.instanceof.checks.display.name='instanceof' 檢查鏈
chain.of.instanceof.checks.problem.descriptor='instanceof' 檢查鏈指示抽象失敗 #loc
chain.of.class.equality.checks.problem.descriptor=類相等檢查鏈指示抽象失敗 #loc
instanceof.concrete.class.problem.descriptor='instanceof' 具體類 <code>#ref</code> #loc
instanceof.concrete.class.equality.problem.descriptor=與具體類 <code>#ref</code> 的類比較 #loc
instanceof.check.for.this.display.name='this' 的 'instanceof' 檢查
instanceof.check.for.this.problem.descriptor=<code>#ref</code> 的 'instanceof' 檢查 #loc
instanceof.check.for.this.equality.problem.descriptor='this' 的類比較 #loc
local.variable.of.concrete.class.problem.descriptor=具體類 <code>#ref</code> 的局部變數 ''{0}'' #loc
magic.number.display.name=幻數
magic.number.problem.descriptor=幻數 <code>#ref</code> #loc
concrete.class.use.display.name=具體類的使用
method.return.concrete.class.problem.descriptor=方法返回一個具體類 <code>#ref</code> #loc
overly.strong.type.cast.display.name=過強的類型轉換
overly.strong.type.cast.weaken.quickfix=削弱過強的轉換
concrete.class.method.parameter.problem.descriptor=具體類 <code>#ref</code> 的參數 ''{0}'' #loc
public.method.not.in.interface.display.name='public' 方法在接口中未公開
public.method.not.in.interface.problem.descriptor='public' 方法 <code>#ref()</code> 未通過接口公開 #loc
public.method.not.in.interface.option=<html>如果包含類未實作非庫接口，則忽略</html>
static.variable.of.concrete.class.problem.descriptor=具體類 <code>#ref</code> 的 static 欄位 ''{0}'' #loc
incompatible.mask.operation.display.name=不相容的位元遮罩運算
incompatible.mask.operation.problem.descriptor.always.false=<code>#ref</code> 始終為 false #loc
incompatible.mask.operation.problem.descriptor.always.true=<code>#ref</code> 始終為 true #loc
pointless.bitwise.expression.display.name=無意義的按位表達式
pointless.bitwise.expression.simplify.quickfix=簡化
shift.operation.by.inappropriate.constant.display.name=按不當常數進行移位運算
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=對 <code>#ref</code> 進行移位運算時使用的常量值 {0} 過大 #loc
shift.operation.by.inappropriate.constant.problem.descriptor.negative=對 <code>#ref</code> 進行移位運算時使用的常量值 {0} 為負 #loc
shift.operation.by.inappropriate.constant.problem.descriptor.out.of.bounds=按超出範圍的值 {0} 進行移位運算 <code>#ref</code> #loc
equals.called.on.array.display.name=在陣列上調用了 'equals()'
equals.called.on.array.problem.descriptor=陣列之間的 <code>#ref()</code> 可能應當是 'Arrays.equals()' #loc
assignment.to.null.display.name='null' 賦值
assignment.to.null.problem.descriptor='null' 已賦值給變數 <code>#ref</code> #loc
assignment.to.null.option=忽略對欄位的賦值
assignment.to.static.field.from.instance.method.display.name=從實例上下文賦值給 static 欄位
assignment.to.static.field.from.instance.method.problem.descriptor=從實例上下文賦值給 static 欄位 <code>#ref</code> #loc
assignment.used.as.condition.display.name=用作條件的賦值
assignment.used.as.condition.problem.descriptor=賦值 <code>#ref</code> 作為條件使用 #loc
cast.conflicts.with.instanceof.display.name=轉換與 'instanceof' 衝突
cast.conflicts.with.instanceof.problem.descriptor=轉換為 ''{0}'' 類型將與前面的 ''instanceof {1}'' 檢查衝突
casting.to.incompatible.interface.display.name=轉換為不相容的接口
casting.to.incompatible.interface.problem.descriptor=轉換為不相容的接口 <code>#ref</code> #loc
collection.added.to.self.display.name=集合已添加到自身
collection.added.to.self.problem.descriptor=在以自身作為實參的集合 <code>#ref</code> 上調用了 ''{0}()'' #loc
non.final.field.compareto.display.name='compareTo()' 中引用了非最終欄位
non.final.field.compareto.problem.descriptor=在 'compareTo()' 中存取了非 final 欄位 <code>#ref</code> #loc
covariant.equals.display.name=協變 'equals()'
covariant.equals.problem.descriptor=<code>#ref()</code> 應當以 'Object' 作為其實參 #loc
empty.class.initializer.display.name=空類初始值設定項
empty.class.initializer.problem.descriptor=空類初始值設定項 #loc
empty.class.initializer.delete.quickfix=刪除空類初始值設定項
statement.with.empty.body.display.name=帶空體的語句
statement.with.empty.body.problem.descriptor=<code>#ref</code> 語句具有空體 #loc
statement.with.empty.body.include.option=包含空程式碼塊語句正文
equals.between.inconvertible.types.display.name='equals()' 位於不可轉換類型的物件之間
equals.between.inconvertible.types.problem.descriptor=<code>#ref</code> 位於 ''{0}'' 和 ''{1}'' 不可轉換類型的物件之間 #loc
equals.between.inconvertible.types.no.mutual.subclass.problem.descriptor=未找到屬於 ''{0}'' 和 ''{1}'' 這兩個子類型的類 #loc
equals.between.inconvertible.types.mutual.subclass.option=如果未找到相互子類，則發出警告
equals.called.on.suspicious.object.display.name=在 'StringBuilder'上調用了 'equals()'
equals.called.on.suspicious.object.problem.descriptor=''{0}'' 物件上存在可疑的 ''equals()'' 調用
non.final.field.in.equals.display.name='equals()' 中引用了非最終欄位
non.final.field.in.equals.problem.descriptor=在 'equals()' 中存取了非 final 欄位 <code>#ref</code> #loc
equals.doesnt.check.class.parameter.display.name=不檢查參數的類的 'equals()' 方法
equals.doesnt.check.class.parameter.problem.descriptor=<code>#ref()</code> 應當檢查其參數的類 #loc
non.final.field.in.hashcode.display.name='hashCode()' 中引用了非最終欄位
non.final.field.in.hashcode.problem.descriptor=在 'hashCode()' 中存取了非 final 欄位 <code>#ref</code> #loc
result.of.method.call.ignored.display.name=方法調用的結果已忽略
write.only.object.display.name=只寫入物件
write.only.object.option.ignore.impure.constructors=忽略不純的構造函數
result.of.method.call.ignored.problem.descriptor=<code>{0}.#ref()</code> 的結果已忽略 #loc
result.of.method.call.ignored.class.column.title=類名
result.of.method.call.ignored.method.column.title=方法名稱正則表達式
result.of.method.call.ignored.non.library.option=報告所有忽略的非庫調用
infinite.recursion.display.name=無限遞歸
infinite.recursion.problem.descriptor=方法 <code>#ref()</code> 無限遞歸，只能以拋出異常結束 #loc
instanceof.with.incompatible.interface.display.name=具有不相容接口的 'instanceof'
instanceof.with.incompatible.interface.problem.descriptor=具有不相容接口 <code>#ref</code> 的 'instanceof' #loc
instantiation.utility.class.display.name=實用程序類的實例化
instantiation.utility.class.problem.descriptor=實用程序類 <code>#ref</code> 的實例化 #loc
iterator.hasnext.which.calls.next.display.name=調用 'next()' 的 'Iterator.hasNext()'
iterator.hasnext.which.calls.next.problem.descriptor=<code>Iterator.{0}()</code> 包含 ''#ref()'' 調用 #loc
iterator.next.does.not.throw.nosuchelementexception.display.name=無法拋出 'NoSuchElementException' 的 'Iterator.next()'
malformed.format.string.display.name=字串的格式錯誤
malformed.format.string.problem.descriptor.malformed=格式字串 <code>#ref</code> 的格式錯誤 #loc
malformed.format.string.problem.descriptor.illegal=非法格式字串指定符: {0} #loc
malformed.format.string.problem.descriptor.too.many.arguments=格式字串的實參太多(實際: {0}，應為: {1}) #loc
malformed.format.string.problem.descriptor.too.few.arguments=格式字串的實參太少(實際: {0}，應為: {1}) #loc
malformed.format.string.problem.descriptor.arguments.do.not.match.type=實參類型 ''{0}'' 與格式說明符 ''{1}'' 的類型不符合 #loc
format.string.error.flags.not.allowed=''{1}'' 中不允許使用{2, choice, 1#標誌|1<標誌} ''{0}''
format.string.error.unexpected.flag=''{1}'' 中出現意外字符 ''{0}''
format.string.error.duplicate.flag=''{1}'' 中存在重複的標誌 ''{0}''
format.string.error.width.not.allowed=''{1}'' 中不允許該寬度 (''{0}'')
format.string.error.precision.not.allowed=''{1}'' 中不允許該精度 (''{0}'')
format.string.error.unnecessary.position.specifier=''{1}'' 存在不必要的實參位置說明符 ''{0}''
format.string.error.illegal.position.specifier=''{1}'' 存在非法的位置說明符 ''{0}''
format.string.error.previous.element.not.found=使用了以前的標誌 '<'，但沒有找到 ''{0}'' 以前的格式說明符
format.string.error.unknown.conversion=''{0}'' 中存在未知的轉換
format.string.error.invalid.precision=''{0}'' 中指定的精度無效
format.string.error.illegal.flag.combination=''{2}'' 中的標誌組合 ''{0}'' 和 ''{1}'' 非法
format.string.error.left.justify.no.width=使用了左對齊標誌 ''-''，但 ''{0}'' 中未指定寬度
format.string.error.zero.padding.no.width=使用了零填充標誌 ''0''，但 ''{0}'' 中未指定寬度
mismatched.read.write.array.display.name=陣列的讀取和寫入不符合
mismatched.read.write.array.problem.descriptor.write.not.read=陣列 <code>#ref</code> 的內容已寫入，但從未被讀取 #loc
mismatched.read.write.array.problem.descriptor.read.not.write=陣列 <code>#ref</code> 的內容已讀取，但從未被寫入 #loc
mismatched.update.collection.display.name=不符合的集合查詢和更新
mismatched.update.collection.problem.descriptor.updated.not.queried=集合 <code>#ref</code> 的內容已更新，但從未被查詢 #loc
mismatched.update.collection.problem.description.queried.not.updated=集合 <code>#ref</code> 的內容已被查詢，但從未更新 #loc
rename.quickfix=重命名
renameto.quickfix=重命名為 ''{0}''
misspelled.equals.display.name='equal()' 代替 'equals()'
misspelled.equals.problem.descriptor=<code>#ref()</code> 方法可能應當是 'equals()' #loc
non.short.circuit.boolean.expression.display.name=非短路邏輯布爾表達式
non.short.circuit.boolean.expression.problem.descriptor=非短路邏輯布爾表達式 <code>#ref</code> #loc
non.short.circuit.boolean.expression.replace.quickfix=取代為短路表達式
null.argument.to.var.arg.method.display.name=引起混淆的 vararg 方法實參
null.argument.to.var.arg.method.problem.descriptor=引起混淆的實參 <code>#ref</code>，不清楚是否需要 vararg 或非 vararg 調用 #loc
primitive.array.argument.to.var.arg.method.display.name=引起混淆的 vararg 方法基元陣列實參
primitive.array.argument.to.var.arg.method.problem.descriptor=引起混淆的 vararg 方法基元陣列實參 #loc
object.comparison.display.name=使用 '==' 而不是 'equals()' 進行物件比較
object.comparison.enumerated.ignore.option=忽略枚舉變數之間的 '=='
object.comparison.klass.ignore.option=忽略沒有 'equals()' 實作的 final 類類型之間的 '=='
object.comparison.problem.description=使用 <code>#ref</code> 而不是 'equals()' 來比較物件值 #loc
equality.to.safe.equals.quickfix=用 null 安全 'equals()' 取代 '=='
inequality.to.safe.not.equals.quickfix=用 null 安全 '!equals()' 取代 '!='
default.tostring.call.display.name=調用預設 'toString()'
default.tostring.call.problem.descriptor=調用 <code>#ref</code> 上的預設 'toString()' #loc
octal.and.decimal.integers.in.same.array.display.name=同一陣列中的八進制和十進制整數
octal.and.decimal.integers.in.same.array.problem.descriptor=同一陣列初始值設定項中的八進制和十進制整數 #loc
result.of.object.allocation.ignored.display.name=物件分配的結果已忽略
result.of.object.allocation.ignored.problem.descriptor=<code>new #ref()</code> 的結果已忽略 #loc
result.of.object.allocation.ignored.options.chooserTitle=選擇可以忽略物件分配的類
result.of.object.allocation.fix.name=忽略類型 ''{0}'' 的物件的分配
use.0index.in.jdbc.resultset.display.name=在 JDBC ResultSet 中使用索引 0
use.0index.in.jdbc.resultset.problem.descriptor=在 JDBC ResultSet 中使用索引 '0' #loc
use.0index.in.jdbc.prepared.statement.problem.descriptor=在 JDBC PreparedStatement 中使用索引 '0' #loc
return.of.null.display.name=返回 'null'
return.of.null.problem.descriptor=返回 <code>#ref</code> #loc
return.of.null.arrays.option=報告返回陣列的方法
return.of.null.objects.option=報告返回物件的方法
return.of.null.collections.option=報告返回集合物件的方法
return.of.null.ignore.private.option=忽略 'private' 方法、匿名類和 lambda
static.method.via.subclass.display.name=static 方法通過子類引用
static.method.via.subclass.problem.descriptor=static 方法 <code>#ref()</code> 在類 ''{0}'' 中宣告，但通過子類 ''{1}'' 引用 #loc
static.method.via.subclass.rationalize.quickfix=使 static 方法調用合理化
static.field.via.subclass.display.name=static 欄位通過子類引用
static.field.via.subclass.problem.descriptor=static 欄位 <code>#ref</code> 在類 ''{0}'' 中宣告，但通過子類 ''{1}'' 引用 #loc
static.field.via.subclass.rationalize.quickfix=使 static 欄位存取合理化
string.comparison.display.name=使用 '==' 而不是 'equals()' 進行字串比較
number.comparison.display.name=使用 '==' 而不是 'equals()' 進行數字比較
string.comparison.problem.descriptor=使用 <code>#ref</code> 而不是 'equals()' 來比較字串值 #loc
number.comparison.problem.descriptor=使用 <code>#ref</code> 而不是 'equals()' 來比較數字物件 #loc
subtraction.in.compareto.display.name='compareTo()' 中的減法
subtraction.in.compareto.problem.descriptor='compareTo()' 中的減法 <code>#ref</code> 可能導致溢出或精度損失 #loc
text.label.in.switch.statement.display.name='switch' 語句中的文本標籤
text.label.in.switch.statement.problem.descriptor='switch' {0, choice, 1#語句|2#表達式}中存在文本標籤 <code>#ref:</code> #loc
properties.object.as.hashtable.display.name=將 'Properties' 物件用作 'Hashtable'
properties.object.as.hashtable.problem.descriptor=在屬性物件上調用 <code>Hashtable.#ref()</code> #loc
assignment.replaceable.with.operator.assignment.display.name=賦值可以取代為運算符賦值
unnecessary.code.block.display.name=不必要的程式碼塊
unnecessary.code.block.unwrap.quickfix=解開塊
redundant.local.variable.display.name=冗餘局部變數
redundant.local.variable.ignore.option=忽略立即返回或拋出的變數
redundant.local.variable.annotation.option=忽略具有註解的變數
static.collection.display.name=靜態集合
static.collection.problem.descriptor=靜態集合 <code>#ref</code> #loc
static.collection.ignore.option=忽略弱靜態集合或映射
stringbuffer.field.display.name='StringBuilder' 欄位
stringbuffer.field.problem.descriptor=''{0}'' 欄位 <code>#ref</code> #loc
gc.call.display.name=調用 'System.gc()' 或 'Runtime.gc()'
gc.call.problem.descriptor=<code>#ref</code> 不應在生產程式碼中調用 #loc
array.allocation.zero.length.display.name=零長度陣列分配
array.allocation.zero.length.problem.descriptor=零長度陣列的分配 #loc
constant.for.zero.length.array.display.name=不必要的零長度陣列用法
constant.for.zero.length.array.problem.descriptor=零長度陣列可更改為常數 #loc
constant.for.zero.length.array.quickfix.family=取代為常數
multiple.loggers.display.name=具有多個記錄器的類
logger.name.option=記錄器類名(&C):
multiple.loggers.problem.descriptor=類 <code>#ref</code> 宣告多個記錄器 #loc
no.logger.display.name=不帶記錄器的類
no.logger.problem.descriptor=類 <code>#ref</code> 未宣告記錄器 #loc
non.constant.logger.display.name=非常數記錄器
non.constant.logger.problem.descriptor=非常數記錄器欄位 <code>#ref</code> #loc
public.method.without.logging.display.name='public' 方法沒有日誌記錄
public.method.without.logging.problem.descriptor='public' 方法 <code>#ref()</code> 沒有日誌調用 #loc
ignore.trivial.finalizers.option=對普通 'finalize()' 實作忽略
finalize.declaration.display.name='finalize()' 不應被覆寫
finalize.declaration.problem.descriptor='finalize()' 不應被覆寫 #loc
finalize.not.declared.protected.display.name='finalize()' 應為 protected，不應為 public
finalize.not.declared.protected.problem.descriptor='finalize()' 應具有 protected 存取權限，不應具有 public 存取權限 #loc
finalize.called.explicitly.display.name='finalize()' 被顯式調用
finalize.called.explicitly.problem.descriptor=<code>#ref()</code> 被顯式調用 #loc
java.lang.import.display.name='java.lang' 軟體套件中有不必要的 import
java.lang.import.problem.descriptor='java.lang' 軟體套件中有不必要的 import #loc
import.display.name='*' 匯入
import.problem.descriptor=軟體套件匯入 <code>#ref</code> #loc
import.from.same.package.display.name=相同軟體套件中的不必要 import
import.from.same.package.problem.descriptor=相同軟體套件 <code>#ref</code> 中有不必要的 import #loc
single.class.import.display.name=單個類匯入
single.class.import.problem.descriptor=單個類匯入 <code>#ref</code> #loc
static.import.display.name=靜態匯入
static.import.problem.descriptor=靜態匯入 <code>#ref</code>  #loc
static.import.replace.quickfix=取代為非靜態匯入
static.import.fix.ignore.class=允許類 ''{0}'' 的靜態匯入
static.import.options.border.title=靜態可匯入類:
static.import.options.chooserTitle=選擇靜態可匯入類
unused.import.problem.descriptor=未使用的 import <code>#ref</code> #loc
clone.instantiates.objects.with.constructor.display.name='clone()' 用構造函數實例化物件
clone.instantiates.objects.with.constructor.problem.descriptor='clone()' 創建新的 <code>#ref</code> 實例 #loc
clone.instantiates.new.array.problem.descriptor=''clone()'' 創建新的 {0} 陣列 #loc
clone.doesnt.declare.clonenotsupportedexception.display.name='clone()' 未宣告 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.problem.descriptor=<code>#ref()</code> #loc 未宣告 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.declare.quickfix=將 'CloneNotSupportedException' 添加到 throws 子句
clone.method.in.non.cloneable.class.display.name=不可克隆類中的 'clone()' 方法
clone.method.in.non.cloneable.class.problem.descriptor=<code>#ref()</code> 在不可克隆類 ''{0}'' 中定義 #loc
clone.method.in.non.cloneable.anonymous.class.problem.descriptor=<code>#ref()</code> 在派生自 ''{0}'' 的不可克隆匿名類中定義 #loc
clone.method.in.non.cloneable.interface.problem.descriptor=<code>#ref()</code> 在不可克隆接口 ''{0}'' 中定義 #loc
cloneable.class.without.clone.display.name=沒有 'clone()' 方法的可克隆類
cloneable.class.without.clone.problem.descriptor=<code>#ref</code> 為 'Cloneable'，但未定義 'clone()' 方法 #loc
cloneable.class.without.clone.ignore.option=忽略由於繼承而可克隆的類
cloneable.class.without.clone.quickfix=生成 'clone()' 方法
use.obsolete.collection.type.display.name=使用廢棄的集合類型
use.obsolete.collection.type.problem.descriptor=使用了廢棄的集合類型 <code>#ref</code> #loc
use.obsolete.collection.type.ignore.library.arguments.option=在需要的位置忽略廢棄的集合類型
inspection.suppression.annotation.display.name=檢查禁止註解
inspection.suppression.annotation.problem.descriptor=檢查禁止註解 <code>#ref</code> #loc
use.system.out.err.display.name=使用 'System.out' 或 'System.err'
use.system.out.err.problem.descriptor=<code>#ref</code> 的使用可能應當取代為更可靠的日誌 #loc
dumpstack.call.display.name=調用 'Thread.dumpStack()'
dumpstack.call.problem.descriptor=對 <code>Thread.#ref()</code> 的調用可能應當取代為更可靠的日誌 #loc
printstacktrace.call.display.name=調用 'printStackTrace()'
printstacktrace.call.problem.descriptor=對 <code>#ref()</code> 的調用可能應當取代為更可靠的日誌 #loc
abstract.method.call.in.constructor.display.name=物件構造期間調用的 abstract 方法
abstract.method.call.in.constructor.problem.descriptor=物件構造期間調用 'abstract' 方法 <code>#ref()</code> #loc
instance.variable.may.not.be.initialized.display.name=實例欄位可能無法初始化
instance.variable.may.not.be.initialized.problem.descriptor=實例欄位 <code>#ref</code> 在物件構造期間可能無法初始化 #loc
instance.Variable.may.not.be.initialized.problem.descriptor.junit=實例欄位 <code>#ref</code> 在物件構造或 'setUp()' 調用期間可能無法初始化 #loc
primitive.fields.ignore.option=忽略原始欄位
instance.variable.used.before.initialized.display.name=實例欄位在初始化前使用
instance.variable.used.before.initialized.problem.descriptor=初始化前使用的實例欄位 <code>#ref</code> #loc
non.final.static.variable.initialization.display.name=在類初始化期間使用非 final static 欄位
non.final.static.variable.initialization.problem.descriptor=在類初始化期間使用非 final static 欄位 <code>#ref</code> #loc
overridable.method.call.in.constructor.display.name=物件構造期間調用的可覆寫方法
overridable.method.call.in.constructor.problem.descriptor=物件構造期間調用可覆寫方法 <code>#ref()</code> #loc
overridden.method.call.in.constructor.display.name=覆寫的方法在物件構造期間調用
overridden.method.call.in.constructor.problem.descriptor=物件構造期間調用已覆寫方法 <code>#ref()</code> #loc
static.variable.may.not.be.initialized.display.name=static 欄位可能無法初始化
static.variable.may.not.be.initialized.problem.descriptor=static 欄位 <code>#ref</code> 在類初始化期間可能無法初始化 #loc
static.variable.used.before.initialization.display.name=static 欄位在初始化前使用
static.variable.used.before.initialization.problem.descriptor=static 欄位 <code>#ref</code> 在初始化前使用 #loc
this.reference.escaped.in.construction.display.name=物件構造中轉義的 'this' 引用
this.reference.escaped.in.construction.problem.descriptor=物件構造期間轉義 <code>#ref</code> #loc
assignment.to.catch.block.parameter.display.name=賦值給 'catch' 塊參數
extract.parameter.as.local.variable.quickfix=提取參數作為局部變數
assignment.to.for.loop.parameter.display.name=賦值給 'for' 迴圈參數
assignment.to.for.loop.parameter.check.foreach.option=檢查增強型 'for' 迴圈參數
assignment.to.for.loop.parameter.problem.descriptor=賦值給 for 迴圈參數 <code>#ref</code> #loc
assignment.to.method.parameter.display.name=賦值給方法參數
chained.equality.comparisons.display.name=鏈式相等比較
confusing.octal.escape.sequence.display.name=引起混淆的八進制轉義序列
increment.decrement.display.name=使用 '++' 或 '--' 的結果
nested.assignment.display.name=嵌套賦值
nested.assignment.problem.descriptor=使用的賦值表達式的結果 #loc
overloaded.methods.with.same.number.parameters.display.name=具有相同參數數量的多載方法
overloaded.vararg.method.display.name=多載 vararg 方法
refused.bequest.display.name=方法不調用 super 方法
reuse.of.local.variable.display.name=局部變數的重用
reuse.of.local.variable.split.quickfix=拆分局部變數
character.comparison.display.name=字符比較
character.comparison.problem.descriptor=國際化上下文中的字符比較 <code>#ref</code> #loc
package.visible.field.display.name=軟體套件可見欄位
package.visible.field.problem.descriptor=軟體套件可見欄位 <code>#ref</code> #loc
package.visible.inner.class.display.name=軟體套件可見的嵌套類
package.visible.inner.class.problem.descriptor=軟體套件可見的嵌套類 <code>#ref</code> #loc
package.visible.inner.class.ignore.enum.option=忽略軟體套件可見的內部枚舉
package.visible.inner.class.ignore.interface.option=忽略軟體套件可見的內部接口
protected.field.display.name=protected 欄位
protected.field.problem.descriptor=protected 欄位 <code>#ref</code> #loc
protected.inner.class.display.name=protected 嵌套類
protected.inner.class.problem.descriptor=protected 嵌套類 <code>#ref</code> #loc
protected.inner.class.ignore.enum.option=忽略 'protected' 內部枚舉
protected.inner.class.ignore.interface.option=忽略 'protected' 內部接口
public.field.display.name='public' 欄位
public.field.problem.descriptor='public' 欄位 <code>#ref</code> #loc
public.field.ignore.enum.type.fields.option=忽略枚舉類型的 'public final' 欄位
public.inner.class.display.name='public' 嵌套類
public.inner.class.problem.descriptor='public' 嵌套類 <code>#ref</code> #loc
public.inner.class.ignore.enum.option=忽略 'public' 內部枚舉
public.inner.class.ignore.interface.option=忽略 'public' 內部接口
accessing.non.public.field.of.another.object.display.name=存取另一個物件的非 public 欄位
accessing.non.public.field.of.another.object.problem.descriptor=直接存取另一個物件的非 public 欄位 <code>#ref</code> #loc
call.to.date.tostring.display.name=調用 'Date.toString()'
call.to.date.tostring.problem.descriptor=國際化上下文中使用的 <code>Date.#ref()</code> #loc
magic.character.display.name=魔幻字符
magic.character.problem.descriptor=國際化上下文中使用的魔幻字符 <code>#ref</code> #loc
call.to.numeric.tostring.display.name=調用 'Number.toString()'
call.to.numeric.tostring.problem.descriptor=國際化上下文中調用的 <code>Number.#ref()</code> #loc
instantiating.simpledateformat.without.locale.display.name=無區域設定的 'SimpleDateFormat'
instantiating.simpledateformat.without.locale.problem.descriptor=在未在國際化上下文中指定區域設定的情況下實例化 <code>#ref</code> #loc
string.concatenation.display.name=字串串聯
string.concatenation.problem.descriptor=國際化上下文中的字串串聯 <code>#ref</code> #loc
inspection.option.ignore.system.out=對 'System.out.print' 實參忽略
inspection.option.ignore.system.err=對 'System.err.print' 實參忽略
inspection.option.ignore.assert=對斷言語句描述實參忽略
inspection.option.ignore.exceptions=對 Throwable 子類的構造函數實參忽略
inspection.option.ignore.nonnls=通過 @NonNls 進行註解時忽略
inspection.option.ignore.constant.initializers=對常數欄位的初始值設定項忽略
inspection.option.ignore.in.annotations=在註解中忽略
inspection.option.ignore.in.tostring=在 toString() 方法內部忽略
inspection.option.ignore.as.initial.capacity=忽略 StringBuilders 和 Collections 的初始容量
inspection.option.ignore.in.hashcode=忽略 'hashCode()' 方法中的常數
string.touppercase.tolowercase.without.locale.display.name=調用無區域設定的 'String.toUpperCase()' 或 'toLowerCase()'
string.touppercase.tolowercase.without.locale.problem.descriptor=在未使用國際化字串指定區域設定的情況下調用 <code>String.#ref()</code> #loc
use.stringtokenizer.display.name=使用 'StringTokenizer'
use.stringtokenizer.problem.descriptor=國際化上下文中的 <code>#ref</code> #loc
time.tostring.call.display.name=調用 'Time.toString()'
time.tostring.call.problem.descriptor=國際化上下文中的 <code>Time.#ref()</code> #loc
class.escapes.defined.scope.display.name=公開不可存取的 'class'
class.escapes.defined.scope.display.module.option=模組的 API 公開未匯出的類(Java 9+)
class.escapes.defined.scope.display.public.option=公共 API 公開不可存取的類
class.escapes.defined.scope.display.package.option=Package-local API 公開 private 類
class.escapes.defined.scope.problem.descriptor=類 <code>#ref</code> 在其定義範圍之外公開 #loc
class.escapes.defined.scope.java9.modules.descriptor=類 <code>#ref</code> 未從模組 ''{0}'' 匯出
field.name.hides.in.superclass.display.name=子類欄位隱藏超類欄位
field.name.hides.in.superclass.problem.descriptor=欄位 <code>#ref</code> 隱藏超類中的欄位 #loc
field.name.hides.in.superclass.ignore.option=忽略不可存取欄位
field.name.hides.in.superclass.ignore.static.field.option=忽略隱藏 static 欄位的 static 欄位
inner.class.field.hides.outer.display.name=內部類欄位隱藏外部類欄位
inner.class.field.hides.outer.ignore.option=忽略從內部類不可見的外部欄位
inner.class.field.hides.outer.problem.descriptor=內部類欄位 <code>#ref</code> 隱藏外部類欄位 #loc
local.variable.hides.member.variable.display.name=局部變數隱藏欄位
local.variable.hides.member.variable.problem.descriptor=局部變數 <code>#ref</code> 隱藏類 ''{0}'' 中的欄位 #loc
local.variable.hides.member.variable.ignore.option=忽略隱藏非 static 欄位的 static 上下文中的局部變數
method.overloads.display.name=可能是超類方法意外多載
method.overloads.problem.descriptor=當可能打算覆寫時，方法 <code>#ref()</code> 多載超類的相容方法 #loc
method.overloads.report.incompatible.option=即使參數類型不相容，也會報告
method.overrides.private.display.name.problem.descriptor=方法 <code>#ref()</code> 重寫了超類的 'private' 方法 #loc
method.overrides.static.display.name=方法嘗試覆寫超類的 'static' 方法
method.overrides.static.problem.descriptor=方法 <code>#ref()</code> 嘗試覆寫超類的 static 方法 #loc
parameter.hides.member.variable.display.name=參數隱藏欄位
parameter.hides.member.variable.problem.descriptor=參數 <code>#ref</code> 隱藏類 ''{0}'' 中的欄位 #loc
parameter.hides.member.variable.ignore.setters.option=對屬性 setter 忽略
parameter.hides.member.variable.ignore.superclass.option=忽略從子類不可見的超類欄位
parameter.hides.member.variable.ignore.constructors.option=對構造函數忽略
parameter.hides.member.variable.ignore.abstract.methods.option=對 abstract 方法忽略
parameter.hides.member.variable.ignore.static.parameters.option=對隱藏實例欄位的 static 方法參數忽略
type.parameter.hides.visible.type.display.name=類型參數隱藏可見類型
type.parameter.hides.visible.type.problem.descriptor=類型參數 <code>#ref</code> 隱藏可見類型 ''{0}'' #loc
type.parameter.hides.type.parameter.problem.descriptor=類型參數 <code>#ref</code> 隱藏類型參數 ''{0}'' #loc
anonymous.class.variable.hides.containing.method.variable.display.name=匿名類變數隱藏包含方法中的變數
anonymous.class.parameter.hides.containing.method.variable.problem.descriptor=匿名類參數 <code>#ref</code> 隱藏包含方法中的變數 #loc
anonymous.class.field.hides.containing.method.variable.problem.descriptor=匿名類欄位 <code>#ref</code> 隱藏包含方法中的變數 #loc
anonymous.class.variable.hides.containing.method.variable.problem.descriptor=匿名類局部變數 <code>#ref</code> 隱藏包含方法中的變數 #loc
channel.opened.not.closed.display.name=打開了 'Channel'，但未安全關閉
drivermanager.call.display.name=使用 'DriverManager' 獲取 JDBC 連接
drivermanager.call.problem.descriptor=調用 <code>DriverManager.#ref()</code> #loc
hibernate.resource.opened.not.closed.display.name=Hibernate 資源已打開，但未安全關閉
i.o.resource.opened.not.closed.display.name=I/O 資源已打開，但未安全關閉
resource.opened.not.closed.problem.descriptor=''{0}'' 應在 ''try'' 塊之前打開，並在相應的 ''finally'' 塊中關閉 #loc
jdbc.resource.opened.not.closed.display.name=JDBC 資源已打開，但未安全關閉
jndi.resource.opened.not.closed.display.name=JNDI 資源已打開，但未安全關閉
socket.opened.not.closed.display.name=套接字已打開，但未安全關閉
annotation.class.display.name=註解類
annotation.class.problem.descriptor=註解類 <code>#ref</code> #loc
annotation.display.name=註解
annotation.problem.descriptor=註解 <code>#ref</code> #loc
assert.statement.display.name='assert' 語句
statement.problem.descriptor=<code>#ref</code> 語句 #loc
auto.boxing.display.name=自動裝箱
auto.boxing.problem.descriptor=自動裝箱 <code>#ref</code> #loc
auto.boxing.make.boxing.explicit.quickfix=使裝箱顯式
auto.boxing.ignore.added.to.collection.option=忽略添加到集合的表達式
auto.unboxing.display.name=自動拆箱
auto.unboxing.problem.descriptor=自動拆箱 <code>#ref</code> #loc
auto.unboxing.make.unboxing.explicit.quickfix=使拆箱顯式
enumerated.class.display.name=枚舉類
enumerated.class.problem.descriptor=枚舉類 <code>#ref</code> #loc
extended.for.statement.display.name=增強的 'for' 語句
extended.for.statement.replace.quickfix=取代為舊式 'for' 語句
variable.argument.method.display.name=vararg 方法
variable.argument.method.problem.descriptor=vararg 方法 <code>#ref()</code> #loc
variable.argument.method.quickfix=將 vararg 參數轉換為數組
hardcoded.file.separator.display.name=硬編碼檔案分隔符
hardcoded.file.separator.problem.descriptor=硬編碼檔案分隔符 <code>#ref</code> #loc
hardcoded.file.separator.include.option=在已識別的 MIME 介質類型中包括 \\"example/*\\"
hardcoded.line.separator.display.name=硬編碼行分隔符
hardcoded.line.separator.problem.descriptor=硬編碼行分隔符 <code>#ref</code> #loc
native.method.display.name=本地方法
native.method.problem.descriptor=宣告為 <code>#ref</code> 的方法不可移植 #loc
runtime.exec.call.display.name=調用 'Runtime.exec()'
runtime.exec.call.problem.descriptor=對 <code>Runtime.#ref()</code> 的調用不可移植 #loc
system.exit.call.display.name=調用 'System.exit()' 或相關方法
system.exit.call.problem.descriptor=對 <code>{0}.#ref()</code> 的調用不可移植 #loc
system.exit.call.ignore.option=在主方法中忽略
system.getenv.call.display.name=調用 'System.getenv()'
system.getenv.call.problem.descriptor=對 <code>System.#ref()</code> 的調用不可移植 #loc
use.of.awt.peer.class.display.name=使用 AWT 對等類
use.of.awt.peer.class.problem.descriptor=AWT 對等類 <code>#ref</code> 的使用不可移植 #loc
use.of.concrete.jdbc.driver.class.display.name=使用具體的 JDBC 驅動程序類
use.of.concrete.jdbc.driver.class.problem.descriptor=具體 JDBC 驅動程序類 <code>#ref</code> 的使用不可移植 #loc
use.processbuilder.class.display.name=使用 'java.lang.ProcessBuilder' 類
use.processbuilder.class.problem.descriptor=<code>#ref</code> 的使用不可移植 #loc
use.sun.classes.display.name=使用 'sun.*' 類
use.sun.classes.problem.descriptor=Sun 提供的類 <code>#ref</code> 的使用不可移植 #loc
abstract.class.with.only.one.direct.inheritor.display.name=只有一個直接繼承者的 abstract 類
anonymous.inner.may.be.named.static.inner.class.display.name=匿名類可能是命名為 'static' 的內部類
anonymous.inner.may.be.named.static.inner.class.problem.descriptor=匿名類 <code>#ref</code> 可能是命名為 'static' 的內部類 #loc
array.length.in.loop.condition.display.name=迴圈條件下的 Array.length
array.length.in.loop.condition.problem.descriptor=檢查迴圈條件下的陣列 <code>#ref</code> #loc
large.array.allocation.no.outofmemoryerror.display.name=沒有 OutOfMemoryError 檢查的大型陣列分配
large.array.allocation.no.outofmemoryerror.problem.descriptor=未檢查記憶體不足情況的大型陣列分配 #loc
large.array.allocation.no.outofmemoryerror.maximum.number.of.elements.option=最大元素數:
connection.opened.not.safely.closed.display.name=集合已打開，但未安全關閉
interface.one.inheritor.display.name=只有一個直接繼承者的接口
interface.one.inheritor.problem.descriptor=只有一個直接繼承者的接口 <code>#ref</code> #loc
method.call.in.loop.condition.display.name=迴圈條件下的方法調用
method.call.in.loop.condition.problem.descriptor=迴圈條件下調用方法 <code>#ref()</code> #loc
large.initializer.primitive.type.array.display.name=原始類型陣列的過大初始值設定項
large.initializer.primitive.type.array.problem.descriptor=具有太多元素 ({0}) 的原始陣列初始值設定項 #loc
large.initializer.primitive.type.array.maximum.number.of.elements.option=最大元素數:
private.member.access.between.outer.and.inner.classes.display.name=合成存取器調用
private.member.access.between.outer.and.inner.classes.problem.descriptor=存取類 ''{0}'' 的 ''private'' 成員需要合成存取器 #loc
private.member.access.between.outer.and.inner.classes.make.local.quickfix=將 ''{0}'' 設為 package-private
private.member.access.between.outer.and.inner.classes.make.constructor.package.local.quickfix=將 ''{0}'' 構造函數設為 package-private
recordstore.opened.not.safely.closed.display.name=打開了 'RecordStore'，但未安全關閉
overly.complex.anonymous.inner.class.display.name=過度複雜的匿名類
cyclomatic.complexity.limit.option=迴圈復雜度限制:
overly.complex.anonymous.inner.class.problem.descriptor=過度複雜的匿名類 (迴圈復雜度 = {0}) #loc
anonymous.inner.class.with.too.many.methods.display.name=具有太多方法的匿名內部類
method.count.limit.option=方法計數限制:
anonymous.inner.class.with.too.many.methods.problem.descriptor=具有太多方法的匿名內部類 (方法計數 = {0}) #loc
overly.complex.class.display.name=過度複雜的類
overly.complex.class.problem.descriptor=過度複雜的類<code>#ref</code> (迴圈復雜度 = {0}) #loc
overly.coupled.class.display.name=過度耦合的類
overly.coupled.class.class.coupling.limit.option=類耦合限制:
include.java.system.classes.option=包括與 Java 系統類的耦合
include.library.classes.option=包括與庫類的耦合
overly.coupled.class.problem.descriptor=<code>#ref</code> 過度耦合 (依賴 = {0}) #loc
class.too.deep.display.name=類在繼承樹中太深
class.too.deep.inheritance.depth.limit.option=繼承深度限制:
class.too.deep.problem.descriptor=<code>#ref</code> 在繼承樹中太深 (繼承深度 = {0}) #loc
inner.class.too.deeply.nested.display.name=內部類嵌套太深
inner.class.too.deeply.nested.nesting.limit.option=嵌套限制:
inner.class.too.deeply.nested.problem.descriptor=<code>#ref</code> 嵌套太深 (嵌套級別 = {0}) #loc
too.many.constructors.display.name=構造函數過多的類
too.many.constructors.count.limit.option=構造函數計數限制:
too.many.constructors.ignore.deprecated.option=忽略棄用的構造函數
too.many.constructors.problem.descriptor=<code>#ref</code> 的構造函數過多 (構造函數計數 = {0}) #loc
too.many.fields.display.name=欄位過多的類
too.many.fields.count.limit.option=欄位計數限制:
too.many.fields.problem.descriptor=<code>#ref</code> 的欄位過多 (欄位計數 = {0}) #loc
too.many.methods.display.name=方法過多的類
too.many.methods.problem.descriptor=<code>#ref</code> 的方法過多 (方法計數 = {0}) #loc
externalizable.with.serialization.methods.display.name=具有 'readObject()' 或 'writeObject()' 的可外部化類
externalizable.with.serialization.methods.problem.descriptor.both=可外部化{0, choice, 1#類|2#接口|3#派生的匿名類|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'readObject()' 和 'writeObject()' #loc
externalizable.with.serialization.methods.problem.descriptor.write=可外部化{0, choice, 1#類|2#接口|3#派生的匿名類|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'writeObject()' #loc
externalizable.with.serialization.methods.problem.descriptor.read=可外部化{0, choice, 1#類|2#接口|3#派生的匿名類|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'readObject()' #loc
non.serializable.with.serialversionuid.display.name=具有 'serialVersionUID' 的不可序列化類
non.serializable.class.with.serialversionuid.problem.descriptor=定義 'serialVersionUID' 欄位的不可序列化類 <code>#ref</code> #loc
non.serializable.interface.with.serialversionuid.problem.descriptor=定義 'serialVersionUID' 欄位的不可序列化接口 <code>#ref</code> #loc
non.serializable.@interface.with.serialversionuid.problem.descriptor=定義 'serialVersionUID' 欄位的不可序列化 @interface <code>#ref</code> #loc
non.serializable.anonymous.with.serialversionuid.problem.descriptor=派生自 <code>#ref</code> 的不可序列化匿名類定義 'serialVersionUID' 欄位 #loc
non.serializable.class.with.readwriteobject.display.name=具有 'readObject()' 或 'writeObject()' 的不可序列化類
non.serializable.class.with.readwriteobject.problem.descriptor.both=不可序列化{0, choice, 1#類|2#接口|3#派生的匿名類|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'readObject()' 和 'writeObject()' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.write=不可序列化{0, choice, 1#類|2#接口|3#派生的匿名類|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'writeObject()' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.read=不可序列化{0, choice, 1#類|2#接口|3#派生的匿名類|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'readObject()' #loc
readwriteobject.private.display.name='readObject()' 或 'writeObject()' 未被宣告為 'private'
readwriteobject.private.problem.descriptor=<code>#ref</code> 未被宣告為 'private' #loc
readobject.initialization.display.name=實例欄位可能無法被 'readObject()' 初始化
readobject.initialization.problem.descriptor=實例欄位 <code>#ref</code> 在 'readObject()' 調用期間可能無法初始化 #loc
readresolve.writereplace.protected.display.name='readResolve()' 或 'writeReplace()' 未被宣告為 'protected'
readresolve.writereplace.protected.problem.descriptor=<code>#ref()</code> 未被宣告為 'protected' #loc
missing.serial.annotation.display.name=可以使用 '@Serial' 註解
missing.serial.annotation.on.field.problem.descriptor=<code>#ref</code> 可以使用 '@Serial' 進行註解
missing.serial.annotation.on.method.problem.descriptor=<code>#ref()</code> 可以使用 '@Serial' 進行註解
serial.annotation.used.on.wrong.member.display.name=對錯誤的成員使用了 '@Serial' 註解
serial.annotation.used.on.wrong.member.problem.descriptor=註解的成員不是序列化機制的一部分
serializable.record.contains.ignored.members.display.name='record' 包含被忽略的成員
serializable.record.contains.ignored.field.problem.descriptor=在記錄序列化期間將忽略 <code>#ref</code>
serializable.record.contains.ignored.method.problem.descriptor=在記錄序列化期間將忽略 <code>#ref()</code>
serialpersistentfields.with.wrong.signature.display.name='serialPersistentFields' 欄位未被宣告為 'private static final ObjectStreamField[]'
serialpersistentfields.with.wrong.signature.problem.descriptor=可序列化類的 <code>#ref</code> 欄位未被宣告為 'private static final ObjectStreamField[]' #loc
serialversionuid.private.static.final.long.display.name='serialVersionUID' 欄位未被宣告為 'private static final long'
serialversionuid.private.static.final.long.problem.descriptor=可序列化類的 <code>#ref</code> 欄位未被宣告為 'private static final long' #loc
serialversionuid.private.static.final.long.quickfix=將 serialVersionUID 設為 'private static final'

#dynamic
non.protected.constructor.in.abstract.class.display.name=abstract 類中的 public 構造函數
unnecessary.qualifier.for.this.display.name='this' 或 'super' 的限定符不必要
multiple.declaration.display.name=一個宣告中的多個變數
thread.priority.display.name=調用 'Thread.setPriority()'
too.broad.scope.display.name=變數範圍過寬
infinite.loop.statement.display.name=無限迴圈語句
asserts.without.messages.display.name=斷言上缺少訊息
constant.naming.convention.element.description=常數
constant.with.mutable.field.naming.convention.element.description=具有可變欄位類型的常數
random.double.for.random.integer.display.name=使用 'Random.nextDouble()' 獲取隨機整數
test.method.without.assertion.display.name=沒有任何斷言的 JUnit 測試方法
string.buffer.replaceable.by.string.builder.display.name='StringBuffer' 可能是 'StringBuilder'
comparison.of.short.and.char.display.name=比較 'short' 和 'char' 值
unnecessary.fully.qualified.name.display.name=不必要的完全限定名稱
ignore.in.module.statements.option=在 Java 9 模組語句中忽略
unnecessary.label.on.break.statement.display.name='break' 語句上的標籤不必要
exception.name.doesnt.end.with.exception.display.name=異常類名不以 'Exception' 結尾
bad.exception.declared.display.name=已宣告禁止異常
pointless.boolean.expression.display.name=無意義的語句或布爾表達式
class.without.constructor.display.name=不帶構造函數的類
break.statement.display.name='break' 語句
unconditional.wait.display.name=無條件的 'wait()' 調用
cyclomatic.complexity.display.name=過度複雜的方法
final.class.display.name=類禁止繼承
labeled.statement.display.name=標記語句
notify.called.on.condition.display.name=在 'java.util.concurrent.locks.Condition' 物件上調用了 'notify()' 或 'notifyAll()'
loop.statements.that.dont.loop.display.name=不迴圈的迴圈語句
ignore.enhanced.for.loop.statements=忽略增強型 for 迴圈
non.synchronized.method.overrides.synchronized.method.display.name=未同步方法覆寫 'synchronized' 方法
synchronize.on.this.display.name=在 'this' 上同步
switch.statement.with.too.many.branches.display.name=最大 'switch' 分支
utility.class.without.private.constructor.display.name=實用程序類沒有 'private' 構造函數
throw.caught.locally.display.name=通過包含 'try' 語句捕獲 'throw'
exception.from.catch.which.doesnt.wrap.display.name='throw' 位於忽略已捕獲異常的 'catch' 塊內
type.parameter.naming.convention.element.description=類型參數
multiply.or.divide.by.power.of.two.display.name=乘以或除以 2 的冪
multiply.or.divide.by.power.of.two.divide.option=還通過 2 的冪檢查除法
serializable.with.unconstructable.ancestor.display.name=具有不可構造上級的可序列化類
missorted.modifiers.display.name=錯位修飾符
sleep.while.holding.lock.display.name=同步時調用 'Thread.sleep()'
singleton.display.name=單例
thread.death.rethrown.display.name='ThreadDeath' 未重新拋出
if.statement.with.too.many.branches.display.name='if' 語句的分支過多
redundant.implements.display.name=冗餘接口宣告
nesting.depth.display.name=過度嵌套的方法
return.this.display.name=返回 'this'
busy.wait.display.name=忙等待
utility.class.display.name=實用程序類
instantiating.object.to.get.class.object.display.name=實例化物件以獲取 'Class' 物件
abstract.class.extends.concrete.class.display.name=abstract 類擴展具體類
parameter.naming.convention.display.name=方法參數命名慣例
parameter.naming.convention.element.description=參數
integer.division.in.floating.point.context.display.name=浮點上下文中的整數除法
interface.naming.convention.element.description=接口
length.one.strings.in.concatenation.display.name=單字符字串串聯
length.one.string.in.indexof.display.name= 'String.indexOf()' 調用中的單字符字串實參
thread.yield.display.name=調用 'Thread.yield()'
confusing.floating.point.literal.display.name=浮點文字會引起混淆
wait.not.in.loop.display.name=未在迴圈中調用的 'wait()'
string.concatenation.inside.string.buffer.append.display.name=字串串聯作為 'StringBuilder.append()' 調用的實參
class.initializer.display.name=非 'static' 初始值設定項
enumerated.class.naming.convention.element.description=枚舉
non.thread.safe.lazy.initialization.display.name=不安全的 'static' 欄位延遲初始化
call.to.simple.setter.in.class.display.name=從類內調用簡單 setter
comparison.to.nan.display.name=與 'Double.NaN' 或 'Float.NaN' 比較
new.method.naming.convention.display.name=方法命名慣例
instance.method.naming.convention.element.description=實例
unnecessary.semicolon.display.name=不必要的分號
fallthru.in.switch.statement.display.name='switch' 語句中的直落
call.to.native.method.while.locked.display.name=鎖定時調用 'native' 方法
switch.statement.display.name='switch' 語句
custom.classloader.display.name=宣告了自訂的 'ClassLoader'
nested.conditional.expression.display.name=嵌套條件表達式
duplicate.condition.display.name=條件重複
method.with.multiple.loops.display.name=具有多個迴圈的方法
non.comment.source.statements.display.name=過長的方法
local.variable.naming.convention.display.name=局部變數命名慣例
local.variable.naming.convention.element.description=局部變數
negated.if.else.display.name=具有否定條件的 'if' 語句
class.naming.convention.display.name=類命名慣例
class.naming.convention.element.description=類
abstract.class.naming.convention.element.description=abstract 類
serializable.inner.class.with.non.serializable.outer.class.display.name=可序列化非 'static' 內部類具有不可序列化外部類
pointless.arithmetic.expression.display.name=無意義的算術表達式
method.name.same.as.class.name.display.name=方法名稱與類名相同
unnecessary.temporary.on.conversion.to.string.display.name=轉換為 'String' 時有不必要的臨時物件
unnecessary.continue.display.name=不必要的 'continue' 語句
inner.class.on.interface.display.name=接口的內部類
unused.label.display.name=未使用的標籤
overly.complex.boolean.expression.display.name=過度複雜的布爾表達式
continue.statement.with.label.display.name=帶標籤的 'continue' 語句
class.loader.instantiation.display.name='ClassLoader' 實例化
return.from.finally.block.display.name='return' 位於 'finally' 塊內
unnecessary.boxing.display.name=不必要的裝箱
annotation.naming.convention.element.description=註解
checked.exception.class.display.name=已檢查的異常類
switch.statement.with.confusing.declaration.display.name=在不同 'switch' 分支中使用並宣告的局部變數
cast.that.loses.precision.display.name=損失精度的數字轉換
manual.array.copy.display.name=手動陣列複製
manual.array.to.collection.copy.display.name=手動陣列到集合複製
long.literals.ending.with.lowercase.l.display.name='long' 文字以 'l' 而不是 'L' 結尾
overly.complex.arithmetic.expression.display.name=過於複雜的算術表達式
junit.abstract.test.class.naming.convention.element.description=abstract 測試
unnecessary.parentheses.display.name=不必要的圓括號
test.case.in.product.code.display.name=產品源中的 JUnit 'TestCase'
test.method.in.product.code.display.name=產品源中的 JUnit 測試方法
serializable.class.in.secure.context.display.name=安全上下文中的可序列化類
static.variable.naming.convention.element.description='static' 欄位
nested.method.call.display.name=嵌套方法調用
throw.from.finally.block.display.name='throw' 位於 'finally' 塊內
field.accessed.synchronized.and.unsynchronized.display.name=同時在 'synchronized' 和未同步上下文中存取欄位
abstract.method.overrides.abstract.method.display.name=abstract 方法覆寫 abstract 方法
static.non.final.field.display.name='static' 非 'final' 欄位
static.non.final.field.option=僅報告 'public' 欄位
class.without.no.arg.constructor.display.name=沒有無參構造函數的類
unnecessary.return.display.name=不必要的 'return' 語句
final.static.method.display.name='static' 方法被宣告為 'final'
constant.declared.in.abstract.class.display.name=在 'abstract' 類中宣告的常數
too.broad.catch.display.name=過寬的 'catch' 塊
floating.point.equality.display.name=浮點相等比較
thrown.exceptions.per.method.display.name=方法宣告的異常過多
public.static.array.field.display.name='public static' 陣列欄位
await.not.in.loop.display.name=未在迴圈中調用的 'await()'
method.names.differ.only.by.case.display.name=方法名稱僅大小寫不同
unsecure.random.number.generation.display.name=不安全的隨機數生成
parameters.per.method.display.name=參數過多的方法
parameters.per.constructor.display.name=參數過多的構造函數
unnecessary.unboxing.display.name=不必要的拆箱
extends.thread.display.name=類直接擴展 'Thread'
test.case.with.constructor.display.name=具有非普通構造函數的 JUnit TestCase
parameter.name.differs.from.overridden.parameter.display.name=參數名稱與覆寫方法中的參數不同
final.private.method.display.name='private' 方法被宣告為 'final'
enum.switch.statement.which.misses.cases.display.name=缺少 case 的枚舉 'switch' 語句
enum.switch.statement.which.misses.cases.option=忽略具有預設分支的 switch 語句
unconstructable.test.case.display.name=不可構造的 JUnit 'TestCase'
string.buffer.must.have.initial.capacity.display.name=沒有初始容量的 'StringBuilder'
method.may.be.static.display.name=方法可以為 'static'
class.initializer.may.be.static.display.name=類初始值設定項可能為 'static'
class.initializer.option=僅在類具有一個或多個構造函數時警告
class.initializer.move.code.to.constructor.quickfix=將初始值設定項程式碼移動到構造函數
nested.switch.statement.display.name=嵌套 'switch' 語句
c.style.array.declaration.display.name=C 樣式陣列宣告
final.method.in.final.class.display.name='final' 類位於 'final' 方法中
extends.annotation.display.name=類擴展註解接口
naked.notify.display.name=沒有相應狀態更改的 'notify()' 或 'notifyAll()'
switch.statement.density.display.name='switch' 語句的分支密度過低
switch.statement.with.too.few.branches.display.name=最小 'switch' 分支
upper.case.field.name.not.constant.display.name=具有大寫名稱的非常數欄位
unnecessary.label.on.continue.statement.display.name='continue' 語句上的不必要標籤
jdbc.prepare.statement.with.non.constant.string.display.name='Connection.prepare*()' 調用具有非常數字串
synchronize.on.non.final.field.display.name=在非 final 欄位上同步
noop.method.in.abstract.class.display.name='abstract' 類中的無運算方法
non.final.field.of.exception.display.name='Exception' 類的非 final 欄位
nested.try.statement.display.name=嵌套 'try' 語句
condition.signal.display.name=調用 'signal()' 而不是 'signalAll()'
jdbc.execute.with.non.constant.string.display.name='Statement.execute()' 調用具有非常數字串
system.set.security.manager.display.name=調用 'System.setSecurityManager()'
system.set.security.manager.problem.descriptor=對 <code>System.#ref()</code> 的調用可能造成安全問題 #loc
control.flow.statement.without.braces.display.name=不帶大括號的控制流語句
trivial.if.display.name=冗餘的 'if' 語句
trivial.if.fix.family.name=簡化 'if else'
trivial.if.option.ignore.chained=忽略鏈式 'if' 語句
thread.with.default.run.method.display.name=使用預設的 'run()' 方法實例化 'Thread'
while.loop.spins.on.field.display.name='while' 迴圈在欄位上自旋
while.loop.spins.on.field.fix.family.name=修復自旋迴圈
while.loop.spins.on.field.fix.volatile=將 ''{0}'' 設為 volatile
while.loop.spins.on.field.fix.spinwait=添加 Thread.onSpinWait()
while.loop.spins.on.field.fix.volatile.spinwait=將 ''{0}'' 設為 volatile 並添加 Thread.onSpinWait()
test.method.is.public.void.no.arg.display.name=測試方法的格式錯誤
if.statement.with.identical.branches.display.name='if' 語句的分支相同
inspection.common.if.parts.message.variables.only=從 ''if'' 中提取變數{0}
inspection.common.if.parts.message.with.variables.extract=從 ''if'' 中提取包含變數的通用部分{0}
inspection.common.if.parts.message.without.variables.extract=從 ''if'' 中提取通用部分{0}
inspection.common.if.parts.message.whole.branch=提取通用部分，同時移除分支{0}
inspection.common.if.parts.message.complete.duplicate=摺疊 ''if'' 語句{0}
inspection.common.if.parts.message.complete.duplicate.side.effect=摺疊 'if' 語句並提取副作用
inspection.common.if.parts.description.variables.only=可以從 ''if'' 中提取變數{0}
inspection.common.if.parts.description.with.variables.extract=可以從 ''if'' 中提取包含變數的通用部分{0}
inspection.common.if.parts.description.without.variables.extract=可以從 ''if'' 中提取通用部分{0}
inspection.common.if.parts.description.whole.branch=可以提取通用部分，同時移除分支{0}
inspection.common.if.parts.description.complete.duplicate=可以摺疊 ''if'' 語句{0}
inspection.common.if.parts.description.complete.duplicate.side.effect=可以通過提取副作用摺疊 'if' 語句
inspection.note.may.change.semantics=可能更改語意
multiple.return.points.per.method.display.name=具有多個返回點的方法
break.statement.with.label.display.name=帶標籤的 'break' 語句
public.constructor.in.non.public.class.display.name='public' 構造函數位於非 public 類中
questionable.name.display.name=可疑名稱
empty.finally.block.display.name=空 'finally' 塊
abstract.method.overrides.concrete.method.display.name=abstract 方法覆寫具體方法
thread.stop.suspend.resume.display.name=調用 'Thread.stop()'、'suspend()' 或 'resume()'
constant.math.call.display.name=對 'Math' 的常數調用
volatile.array.field.display.name=volatile 陣列欄位
literal.as.arg.to.string.equals.display.name=字串文字可以為 'equals()' 限定符
inner.class.may.be.static.display.name=內部類可能為 'static'
static.suite.display.name='suite()' 方法未被宣告為 'static'
redundant.field.initialization.display.name=冗餘欄位初始化
string.buffer.to.string.in.concatenation.display.name=連接中的 'StringBuilder.toString()'
utility.class.with.public.constructor.display.name=實用程序類具有 'public' 構造函數
for.loop.replaceable.by.while.display.name='for' 迴圈可以取代為 'while' 迴圈
missing.deprecated.annotation.display.name=缺少 '@Deprecated' 註解
cloneable.class.in.secure.context.display.name=安全上下文中的可克隆類
static.inheritance.display.name=靜態繼承
class.name.prefixed.with.package.name.display.name=使用軟體套件名稱作為前綴的類名
call.to.simple.getter.in.class.display.name=從類內調用簡單 getter
class.name.differs.from.file.name.display.name=類名與文件名不同
protected.member.in.final.class.display.name='protected' 成員位於 'final' 類中
load.library.with.non.constant.string.display.name='System.loadLibrary()' 調用具有非常數字串
instanceof.catch.parameter.display.name='catch' 參數上的 'instanceof'
implicit.numeric.conversion.display.name=隱式數字轉換
unnecessary.interface.modifier.display.name=不必要的 'interface' 修飾符
confusing.main.method.display.name=引起混淆的 'main()' 方法
octal.literal.display.name=八進制整數
misordered.assert.equals.arguments.display.name=順序錯誤的 'assertEquals()' 實參
unnecessary.constructor.display.name=冗餘無參構造函數
method.name.same.as.parent.name.display.name=方法名稱與父類名相同
while.can.be.foreach.display.name='while' 迴圈可取代為增強的 'for' 迴圈
big.decimal.equals.display.name=在 'BigDecimal' 上調用了 'equals()'
implicit.call.to.super.display.name=隱式調用 'super()'
unqualified.static.usage.display.name=非限定靜態存取
simplifiable.junit.assertion.display.name=可簡化斷言
object.notify.display.name=調用 'notify()' 而不是 'notifyAll()'
thread.start.in.construction.display.name=物件構造期間調用 'Thread.start()'
non.final.clone.display.name=非 final 'clone()' 位於安全上下文中
unnecessary.temporary.on.conversion.from.string.display.name=從 'String' 轉換時有不必要的臨時物件
unnecessary.this.display.name=不必要的 'this' 限定符
unnecessary.this.ignore.assignments.option=忽略欄位賦值
runtime.exec.with.non.constant.string.display.name='Runtime.exec()' 調用具有非常數字串
system.properties.display.name=系統屬性的存取
chained.method.call.display.name=鏈式方法調用
safe.lock.display.name=已獲取但未安全解鎖的鎖
system.run.finalizers.on.exit.display.name=調用 'System.runFinalizersOnExit()'
for.can.be.foreach.display.name='for' 迴圈可取代為增強的 for 迴圈
type.parameter.extends.object.display.name=類型參數顯式擴展 'Object'
type.parameter.extends.object.ignore.annotated=註解 java.lang.Object 時忽略
marker.interface.display.name=標記接口
limited.scope.inner.class.display.name=局部類
switch.statements.without.default.display.name=不帶 'default' 分支的 'switch' 語句
unchecked.exception.class.display.name=未檢查的 'Exception' 類
for.loop.with.missing.component.display.name=缺少組件的 'for' 迴圈
for.loop.with.missing.component.collection.loop.option=忽略集合迭代
double.checked.locking.display.name=雙重檢查鎖定
double.checked.locking.problem.descriptor=雙重檢查鎖定 #loc
string.buffer.replaceable.by.string.display.name='StringBuilder' 可以取代為 'String'
boolean.method.name.must.start.with.question.display.name=布爾方法名稱必須以疑問詞開頭
class.name.same.as.ancestor.name.display.name=類名與上級名稱相同
error.rethrown.display.name='Error' 未重新拋出
serializable.has.serialization.methods.display.name=不帶 'readObject()' 和 'writeObject()' 的可序列化類
serializable.has.serialization.methods.ignore.option=忽略未定義實例欄位的類
missing.override.annotation.display.name=缺少 '@Override' 註解
wait.while.holding.two.locks.display.name=保持兩個鎖時 'wait()'
empty.class.display.name=冗餘空類
trivial.string.concatenation.display.name=與空字串串聯
empty.synchronized.statement.display.name=空 'synchronized' 語句
unnecessary.default.display.name=枚舉 'switch' 語句的 'default' 不必要
simplifiable.conditional.expression.display.name=可簡化的條件表達式
unnecessary.super.constructor.display.name=對 'super()' 的調用不必要
unnecessarily.qualified.static.usage.display.name=不必要的限定靜態存取
bad.exception.caught.display.name=已捕獲禁止的 'Exception'
custom.security.manager.display.name=自訂 'SecurityManager'
string.concatenation.in.loops.display.name=字串串聯在迴圈中
boolean.constructor.display.name=布爾構造函數調用
continue.statement.display.name='continue' 語句
extends.object.display.name=類顯式擴展 'Object'
serializable.inner.class.has.serial.version.uid.field.display.name=沒有 'serialVersionUID' 的可序列化非 static 內部類
static.method.naming.convention.element.description='static'
empty.try.block.display.name=空 'try' 塊
field.has.setter.but.no.getter.display.name=欄位具有 setter 但沒有 getter
three.negations.per.method.display.name=具有三個以上否定的方法
conditional.expression.display.name=條件表達式
unnecessary.enum.modifier.display.name=不必要的 enum' 修飾符
string.equals.empty.string.display.name='String.equals()' 可以取代為 'String.isEmpty()'
synchronize.on.lock.display.name=在 'Lock' 物件上同步
synchronized.on.literal.object.name=在使用文字初始化的物件上同步
field.may.be.static.display.name=欄位可以為 'static'
class.may.be.interface.display.name='abstract' 類可以是 'interface'
abstract.class.without.abstract.methods.display.name=沒有 'abstract' 方法的 abstract 類
divide.by.zero.display.name=除以零
default.not.last.case.in.switch.display.name='default' 不是 'switch' 中的最後一個 case
nested.synchronized.statement.display.name=嵌套 'synchronized' 語句
constant.conditional.expression.display.name=恒定條件表達式
redundant.else.display.name=冗餘的 'else'
public.field.accessed.in.synchronized.context.display.name=在 'synchronized' 上下文中存取d了非 private 欄位
string.replaceable.by.string.buffer.display.name=非常數 'String' 可取代為 'StringBuilder'
junit.test.class.naming.convention.element.description=測試
junit.test.suite.naming.convention.element.description=測試套件
method.coupling.display.name=過度耦合的方法
collections.must.have.initial.capacity.display.name=沒有初始容量的集合
anonymous.inner.class.display.name=匿名內部類可以取代為內部類
negated.conditional.display.name=具有否定條件的條件表達式
non.reproducible.math.call.display.name=對 'Math' 的不可重現調用
multiple.top.level.classes.in.file.display.name=單個檔案中的多個頂級類
set.replaceable.by.enum.set.display.name='Set' 可取代為 'EnumSet'
tail.recursion.display.name=尾遞歸
finally.block.cannot.complete.normally.display.name=不能正常完成的 'finally' 塊
non.atomic.operation.on.volatile.field.display.name='volatile' 欄位上的非原子操作
public.static.collection.field.display.name='public static' 集合欄位
non.exception.name.ends.with.exception.display.name=非異常類名以 'Exception' 結尾
synchronized.method.display.name='synchronized' 方法
enumerated.constant.naming.convention.element.description=枚舉常數
final.method.display.name=不能覆寫方法
transient.field.in.non.serializable.class.display.name=不可序列化類中存在 transient 欄位
bad.exception.thrown.display.name=已拋出禁止異常
conditional.expression.with.identical.branches.display.name=具有相同分支的條件表達式
conditional.can.be.pushed.inside.expression.display.name=可以在分支表達式內推送條件
conditional.can.be.pushed.inside.expression.option=在條件將僅作為方法調用的實參時忽略
conditional.can.be.pushed.inside.expression.quickfix=在分支內推送條件表達式
raw.use.of.parameterized.type.display.name=參數化類的原始使用
standard.variable.names.display.name=標準變數名稱
field.naming.convention.display.name=欄位命名慣例
instance.variable.naming.convention.element.description=實例欄位
dollar.sign.in.name.display.name=在關鍵字中使用 '$'
map.replaceable.by.enum.map.display.name='Map' 可取代為 'EnumMap'
extends.concrete.collection.display.name=類顯式擴展 'Collection' 類
continue.or.break.from.finally.block.display.name='continue' 或 'break' 位於 'finally' 塊內
abstract.method.with.missing.implementations.display.name=缺少實作的 abstract 方法
object.allocation.in.loop.display.name=迴圈中的物件分配
wait.called.on.condition.display.name=在 'java.util.concurrent.locks.Condition' 物件上調用了 'wait()'
test.case.with.no.test.methods.display.name=沒有測試的測試類
abstract.class.never.implemented.display.name=沒有具體子類的 abstract 類
interface.never.implemented.display.name=沒有具體子類的接口
constant.declared.in.interface.display.name=在接口中宣告的常數


#problem descriptors
exception.name.doesnt.end.with.exception.problem.descriptor=異常類名 <code>#ref</code> 未以 'Exception' 結尾 #loc
non.exception.name.ends.with.exception.problem.descriptor=非異常類名 <code>#ref</code> 以 'Exception' 結尾 #loc
class.name.prefixed.with.package.name.problem.descriptor=類名 <code>#ref</code> 以其軟體套件名稱開始 #loc
class.name.same.as.ancestor.name.problem.descriptor=類名 <code>#ref</code> 與其超類的名稱之一相同 #loc
method.name.same.as.class.name.problem.descriptor=方法名稱 <code>#ref</code> 與其類名相同 #loc
method.name.same.as.parent.name.problem.descriptor=方法名稱 <code>#ref</code> 與其父類名相同 #loc
boolean.method.name.must.start.with.question.problem.descriptor=布爾方法名稱 <code>#ref</code> 未以疑問詞開頭 #loc
questionable.name.problem.descriptor=可疑名稱 <code>#ref</code> #loc
confusing.main.method.problem.descriptor=方法名稱 <code>#ref</code> 沒有簽名 'public static void main(String[])' #loc
upper.case.field.name.not.constant.problem.descriptor=帶常數樣式名稱的非常數欄位 <code>#ref</code> #loc
dollar.sign.in.name.problem.descriptor=關鍵字 <code>#ref</code> 包含 '$' #loc
integer.division.in.floating.point.context.problem.descriptor=<code>#ref</code>: 浮點上下文中的整數除法 #loc
comparison.of.short.and.char.problem.descriptor=short 和 char 值的相等比較 <code>#ref</code> #loc
big.decimal.equals.problem.descriptor=BigDecimal 值之間的 <code>#ref()</code> 可能應當是 'compareTo()' #loc
divide.by.zero.problem.descriptor=除以零 #loc
non.reproducible.math.call.problem.descriptor=<code>Math.#ref()</code> 可能產生不可重現的結果 #loc
constant.math.call.problem.descriptor=對 <code>#ref()</code> 的常數調用可以簡化 #loc
floating.point.equality.problem.descriptor=<code>#ref</code>: 比較浮點值以實作完全相等 #loc
fallthru.in.switch.statement.problem.descriptor='switch' 語句存在直落 #loc
switch.statements.without.default.problem.descriptor=沒有 'default' 分支的 <code>#ref</code> 語句 #loc
default.not.last.case.in.switch.problem.descriptor=<code>#ref</code> 分支不是 ''switch'' {0} 中的最後一個 case #loc
loop.statements.that.dont.loop.problem.descriptor=<code>#ref</code> 語句未迴圈 #loc
conditional.expression.with.identical.branches.problem.descriptor=具有相同分支的條件表達式 <code>#ref</code> #loc
conditional.can.be.pushed.inside.expression.problem.descriptor=條件表達式可以推送到分支內 #loc
duplicate.condition.problem.descriptor=重複條件 <code>#ref</code> #loc
duplicate.condition.ignore.method.calls.option=忽略有副作用的條件
iterator.next.does.not.throw.nosuchelementexception.problem.descriptor=無法拋出 'NoSuchElementException' 的 <code>Iterator.#ref()</code> '#loc
infinite.loop.statement.problem.descriptor=<code>#ref</code> 語句不能在未拋出異常的情況下完成 #loc
confusing.floating.point.literal.problem.descriptor=引起混淆的浮點文字 <code>#ref</code> #loc
overly.complex.arithmetic.expression.problem.descriptor=過於複雜的算術表達式 #loc
overly.complex.boolean.expression.problem.descriptor=過度複雜的布爾表達式 ({0} 項) #loc
labeled.statement.problem.descriptor=標記語句 <code>#ref:</code> #loc
break.statement.with.label.problem.descriptor=帶標籤的 <code>#ref</code> 語句 #loc
continue.statement.with.label.problem.descriptor=帶標籤的 <code>#ref</code> 語句 #loc
conditional.expression.problem.descriptor=條件表達式 <code>#ref</code> #loc
conditional.expression.option=對簡單賦值和返回值忽略
conditional.expression.expression.context.option=忽略無法使用 if 語句的位置
conditional.expression.quickfix=取代為 'if' 語句
nested.conditional.expression.problem.descriptor=嵌套條件表達式 <code>#ref</code> #loc
long.literals.ending.with.lowercase.l.problem.descriptor='long' 文字 <code>#ref</code> 以小寫 'l' 結尾 #loc
nested.switch.statement.problem.descriptor=嵌套 <code>#ref</code> {0} #loc
chained.method.call.problem.descriptor=鏈式方法調用 <code>#ref()</code> #loc
nested.method.call.problem.descriptor=嵌套方法調用 <code>#ref()</code> #loc
octal.literal.problem.descriptor=八進制整數 <code>#ref</code> #loc
implicit.call.to.super.problem.descriptor=隱式調用 'super()' #loc
negated.if.else.problem.descriptor=帶嵌套條件的 <code>#ref</code> 語句 #loc
negated.conditional.problem.descriptor=具有否定條件的條件表達式 #loc
redundant.else.problem.descriptor=<code>#ref</code> 分支可以解開，因為 'if' 分支永遠不會正常完成 #loc
switch.statement.with.confusing.declaration.problem.descriptor=局部變數 <code>#ref</code> 在一個 'switch' 分支中宣告，並在另一個分支中使用 #loc
final.class.problem.descriptor=類被宣告為 <code>#ref</code> #loc
empty.class.problem.descriptor=類 <code>#ref</code> 為空 #loc
empty.enum.problem.descriptor=枚舉 <code>#ref</code> 為空 #loc
empty.class.file.without.class.problem.descriptor=Java 檔案未宣告任何類 #loc
empty.anonymous.class.problem.descriptor=匿名類為空 #loc
anonymous.inner.class.problem.descriptor=匿名內部類 <code>#ref</code> #loc
limited.scope.inner.class.problem.descriptor=局部類 <code>#ref</code> #loc
final.method.problem.descriptor=方法被宣告為 <code>#ref</code> #loc
class.initializer.problem.descriptor=非 'static' 初始值設定項 #loc
class.may.be.interface.problem.descriptor=abstract 類 <code>#ref</code> 可能是接口 #loc
non.protected.constructor.in.abstract.class.problem.descriptor=abstract 類的構造函數 <code>#ref()</code> 不應宣告為 'public' #loc
class.without.constructor.problem.descriptor=類 <code>#ref</code> 沒有構造函數 #loc
abstract.class.without.abstract.methods.problem.descriptor=類 <code>#ref</code> 被宣告為 'abstract'，並且沒有 'abstract' 方法 #loc
final.method.in.final.class.problem.descriptor=方法在 'final' 類中被宣告為 <code>#ref</code> #loc
protected.member.in.final.class.problem.descriptor=類成員在 'final' 類中被宣告為 <code>#ref</code> #loc
utility.class.with.public.constructor.problem.descriptor=類 <code>#ref</code> 只有 'static' 成員和 'public' 構造函數 #loc
utility.class.without.private.constructor.problem.descriptor=類 <code>#ref</code> 只有 'static' 成員，缺少 'private' 構造函數 #loc
abstract.method.overrides.concrete.method.problem.descriptor=abstract 方法 <code>#ref()</code> 覆寫具體方法 #loc
abstract.method.with.missing.implementations.problem.descriptor=abstract 方法 <code>#ref()</code> 未在每個子類中實作 #loc
abstract.method.overrides.abstract.method.problem.descriptor=abstract 方法 <code>#ref()</code> 覆寫 abstract 方法 #loc
abstract.method.overrides.abstract.method.ignore.different.javadoc.option=忽略 Javadoc 與其 super 方法不同的方法
abstract.class.extends.concrete.class.problem.descriptor=類 <code>#ref</code> 被宣告為 'abstract'，並擴展一個具體類 #loc
static.non.final.field.problem.descriptor='static' 非 'final' 欄位 <code>#ref</code> #loc
constant.declared.in.abstract.class.problem.descriptor=常數 <code>#ref</code> 在 abstract 類中宣告 #loc
constant.declared.in.interface.problem.descriptor=常數 <code>#ref</code> 在接口中宣告 #loc
static.inheritance.problem.descriptor=接口 <code>#ref</code> 僅針對其 static 常數實作 #loc
utility.class.problem.descriptor=類 <code>#ref</code> 只有 'static' 成員，指示程序構造 #loc
singleton.problem.descriptor=類 <code>#ref</code> 為單例 #loc
enum.singleton.problem.descriptor=枚舉 <code>#ref</code> 為單例 #loc
final.private.method.problem.descriptor='private' 方法被宣告為 <code>#ref</code> #loc
noop.method.in.abstract.class.problem.descriptor=無操作方法 <code>#ref()</code> 應當設為 abstract #loc
final.static.method.problem.descriptor='static' 方法被宣告為 <code>#ref</code> #loc
class.without.no.arg.constructor.problem.descriptor=<code>#ref</code> 沒有無參構造函數 #loc
multiple.top.level.classes.in.file.problem.descriptor=檔案中的多個頂級類
class.name.differs.from.file.name.problem.descriptor=類名 <code>#ref</code> 與文件名不同 #loc
marker.interface.problem.descriptor=標記接口 <code>#ref</code> #loc
field.has.setter.but.no.getter.problem.descriptor=欄位 <code>#ref</code> 有 setter 但沒有 getter #loc
abstract.class.never.implemented.problem.descriptor=abstract 類 <code>#ref</code> 沒有具體子類 #loc
interface.never.implemented.problem.descriptor=接口 <code>#ref</code> 沒有具體子類 #loc
missing.deprecated.annotation.problem.descriptor=缺少 '@Deprecated' 註解 #loc
missing.deprecated.tag.problem.descriptor=缺少 '@deprecated' Javadoc 標記說明 #loc
missing.deprecated.tag.option=警告缺少 @deprecated Javadoc 標記說明
missing.override.annotation.problem.descriptor=缺少關於 <code>#ref()</code> 的 '@Override' 註解 #loc
missing.override.annotation.in.overriding.problem.descriptor=覆寫方法未使用 '@Override' 註解
non.thread.safe.lazy.initialization.problem.descriptor='static' 欄位 <code>#ref</code> 的延遲初始化不是執行緒安全 #loc
empty.finally.block.problem.descriptor=空 <code>#ref</code> 塊 #loc
finally.block.cannot.complete.normally.problem.descriptor=<code>#ref</code> 塊無法正常完成 #loc
empty.try.block.problem.descriptor=空 <code>#ref</code> 塊 #loc
throw.from.finally.block.problem.descriptor=<code>#ref</code> 位於 'finally' 塊內 #loc
possible.throw.from.finally.block.problem.descriptor=<code>{0}</code> 可能在 ''finally'' 塊內引發 #loc
throw,from.finally.block.everywhere.option=警告隨處都可能引發宣告的異常
throw.caught.locally.problem.descriptor=通過包含 'try' 語句捕獲 <code>#ref</code> #loc
throw.caught.locally.ignore.option=忽略重新拋出的異常
return.from.finally.block.problem.descriptor='return' 位於 'finally' 塊內 #loc
continue.or.break.from.finally.block.problem.descriptor=<code>#ref</code> 位於 'finally' 塊內 #loc
bad.exception.declared.problem.descriptor=已宣告禁止異常 <code>#ref</code> #loc
bad.exception.caught.problem.descriptor=已捕獲禁止異常 <code>#ref</code> #loc
checked.exception.class.problem.descriptor=已檢查的異常類 <code>#ref</code> #loc
unchecked.exception.class.problem.descriptor=未檢查的異常類 <code>#ref</code> #loc
thread.death.rethrown.problem.descriptor=ThreadDeath <code>#ref</code> 未重新拋出 #loc
error.rethrown.problem.descriptor=錯誤 <code>#ref</code> 未重新拋出 #loc
nested.try.statement.problem.descriptor=嵌套 <code>#ref</code> 語句 #loc
exception.from.catch.which.doesnt.wrap.problem.descriptor='catch' 塊內的 <code>#ref</code> 忽略捕獲的異常 #loc
instanceof.catch.parameter.problem.descriptor='catch' 參數 <code>#ref</code> 上的 'instanceof' #loc
non.final.field.of.exception.problem.descriptor=異常類的非 final 欄位 <code>#ref</code> #loc
unnecessary.label.on.break.statement.problem.descriptor=<code>#ref</code> 語句上的標籤不必要 #loc
unnecessary.label.on.continue.statement.problem.descriptor=<code>#ref</code> 語句上的標籤不必要 #loc
trivial.if.problem.descriptor=<code>#ref</code> 語句可以簡化 #loc
unnecessary.parentheses.problem.descriptor=<code>#ref</code> 周圍的圓括號不必要 #loc
unnecessary.local.variable.problem.descriptor=局部變數 <code>#ref</code> 是冗餘的 #loc
unnecessary.this.problem.descriptor=<code>#ref</code> 在此上下文中不必要 #loc
unnecessary.block.statement.problem.descriptor=此語句周圍的大括號不必要 #loc
unnecessary.continue.problem.descriptor=<code>#ref</code> 不必要，因為是迴圈中的最後一條語句 #loc
unnecessary.semicolon.problem.descriptor=不必要的分號 <code>#ref</code> #loc
unnecessary.semicolon.ignore.after.enum.constants.option=忽略枚舉常數後的不必要分號
unnecessary.fully.qualified.name.problem.descriptor1=限定符 <code>#ref</code> 不必要，可以取代為匯入 #loc
unnecessary.fully.qualified.name.problem.descriptor2=限定符 <code>#ref</code> 不必要，可以移除 #loc
unnecessary.qualifier.for.this.problem.descriptor='this' 上的限定符 <code>#ref</code> 在此上下文中不必要 #loc
unnecessary.qualifier.for.super.problem.descriptor='super' 上的限定符 <code>#ref</code> 在此上下文中不必要 #loc
unused.label.problem.descriptor=未使用的標籤 <code>#ref</code> #loc
redundant.field.initialization.problem.descriptor=<code>#ref</code> 的欄位初始化是冗餘的 #loc
redundant.implements.problem.descriptor=冗餘接口宣告 <code>#ref</code> #loc
extends.object.problem.descriptor=類 <code>#ref</code> 顯式擴展 'java.lang.Object' #loc
type.parameter.extends.object.problem.descriptor1=類型參數 <code>#ref</code> 顯式擴展 'java.lang.Object' #loc
type.parameter.extends.object.problem.descriptor2=萬用字元類型實參 <code>#ref</code> 顯式擴展 'java.lang.Object' #loc
unnecessary.super.constructor.problem.descriptor=<code>#ref</code> 不必要 #loc
unnecessary.constructor.problem.descriptor=無參構造函數 <code>#ref()</code> 是冗餘的 #loc
unnecessary.constructor.annotation.option=忽略有註解的構造函數
for.loop.replaceable.by.while.problem.descriptor=<code>#ref</code> 迴圈語句可以取代為 'while' 迴圈 #loc
unnecessary.default.problem.descriptor=<code>#ref</code> 分支不必要 #loc
unnecessary.default.expressions.option=僅報告 switch 表達式
unnecessary.default.quickfix=移除 'default' 分支
unnecessary.boxing.problem.descriptor=不必要的裝箱 <code>#ref</code> #loc
unnecessary.boxing.inside.value.of.problem.descriptor=<code>#ref</code> 內的裝箱冗餘 #loc
unnecessary.unboxing.problem.descriptor=不必要的拆箱 <code>#ref</code> #loc
unnecessary.boxing.superfluous.option=僅報告真正多餘的裝箱表達式
unnecessary.unboxing.superfluous.option=僅報告真正多餘的拆箱表達式
for.can.be.foreach.problem.descriptor=<code>#ref</code> 迴圈可取代為增強的 'for' #loc
while.can.be.foreach.problem.descriptor=<code>#ref</code> 迴圈可取代為增強的 'for' #loc
too.broad.scope.problem.descriptor=變數 <code>#ref</code> 的範圍過寬 #loc
return.this.problem.descriptor=返回 <code>#ref</code> #loc
constant.on.side.of.comparison.display.name=常數位於比較的錯誤一側
constant.on.lhs.of.comparison.problem.descriptor=常數 <code>#ref</code> 位於比較的左側 #loc
constant.on.rhs.of.comparison.problem.descriptor=常數 <code>#ref</code> 位於比較的右側 #loc
control.flow.statement.without.braces.problem.descriptor=不帶大括號的 <code>{0}</code> #loc
missorted.modifiers.problem.descriptor=錯位修飾符 <code>{0}</code> #loc
cstyle.array.variable.declaration.problem.descriptor={0, choice, 1#欄位|2#參數|3#記錄組件|4#局部變數} <code>#ref</code> 的 C 樣式陣列宣告 #loc
cstyle.array.method.declaration.problem.descriptor=方法 <code>#ref()</code> 返回類型的 C 樣式陣列宣告 #loc
multiple.declaration.problem.descriptor=一個宣告中的多個變數 #loc
multiple.typed.declaration.problem.descriptor=在一個宣告中具有不同陣列維度的變數 #loc
serializable.inner.class.has.serial.version.uid.field.problem.descriptor=內部類 <code>#ref</code> 未定義 'serialVersionUID' 欄位 #loc
serializable.inner.class.with.non.serializable.outer.class.problem.descriptor=內部類 <code>#ref</code> 可序列化，而其外部類不可序列化 #loc
busy.wait.problem.descriptor=在迴圈中調用 <code>Thread.#ref()</code>，可能處於忙等待 #loc
sleep.while.holding.lock.problem.descriptor=同步時調用 <code>Thread.#ref()</code> #loc
non.atomic.operation.on.volatile.field.problem.descriptor=volatile 欄位 <code>#ref</code> 上的非原子操作 #loc
call.to.native.method.while.locked.problem.descriptor=在同步上下文中調用本地方法 <code>#ref()</code> #loc
object.notify.problem.descriptor=<code>#ref</code> 可能應當取代為 'notifyAll()' #loc
condition.signal.problem.descriptor=<code>#ref</code> 可能應當取代為 'signalAll()' #loc
thread.with.default.run.method.problem.descriptor=使用預設的 'run()' 方法實例化 <code>#ref</code> #loc
extends.thread.problem.descriptor=類 <code>#ref</code> 直接擴展 'java.lang.Thread' #loc
anonymous.extends.thread.problem.descriptor=匿名類直接擴展 'java.lang.Thread' #loc
naked.notify.problem.descriptor=在沒有相應狀態更改的情況下調用 <code>#ref()</code> #loc
unconditional.wait.problem.descriptor=無條件調用 <code>#ref()</code> #loc
system.run.finalizers.on.exit.problem.descriptor=調用 <code>System.#ref()</code> #loc
thread.priority.problem.descriptor=調用 <code>Thread.#ref()</code> #loc
thread.yield.problem.descriptor=調用 <code>Thread.#ref()</code> #loc
thread.stop.suspend.resume.problem.descriptor=調用 <code>Thread.#ref()</code> #loc
while.loop.spins.on.field.problem.descriptor=<code>#ref</code> 迴圈在欄位上自旋 #loc
wait.not.in.loop.problem.descriptor=<code>#ref()</code> 調用不在迴圈中 #loc
await.not.in.loop.problem.descriptor=<code>#ref()</code> 調用不在迴圈中 #loc
wait.called.on.condition.problem.descriptor=在條件物件上調用 <code>#ref()</code> #loc
notify.called.on.condition.problem.descriptor=在條件物件上調用 <code>#ref()</code> #loc
wait.while.holding.two.locks.problem.descriptor=在保持兩個鎖的情況下調用 <code>#ref()</code> #loc
thread.run.problem.descriptor=對 <code>#ref()</code> 的調用可能應當取代為 'start()' #loc
thread.start.in.construction.problem.descriptor=物件構造期間調用 <code>#ref()</code> #loc
synchronize.on.lock.problem.descriptor=在 ''{0}'' 物件上同步不太可能是故意的 #loc
synchronized.on.literal.object.problem.descriptor=在由文字初始化的 {0} <code>#ref</code> 上同步 #loc
synchronized.on.direct.literal.object.problem.descriptor=在 {0} 文字 <code>#ref</code> 上同步 #loc
synchronized.on.possibly.literal.object.problem.descriptor=在 {0} <code>#ref</code> 上同步 #loc
synchronize.on.non.final.field.problem.descriptor=在非 final 欄位 <code>#ref</code> 上同步 #loc
synchronized.on.literal.object.warn.on.all.option=警告所有可能的文字
synchronize.on.this.problem.descriptor=對 'this' 的鎖定操作可能會產生不可預見的副作用 #loc
synchronize.on.class.problem.descriptor=對類的鎖定操作可能會產生不可預見的副作用 #loc
nested.synchronized.statement.problem.descriptor=嵌套 <code>#ref</code> 語句 #loc
empty.synchronized.statement.problem.descriptor=空 <code>#ref</code> 語句 #loc
non.synchronized.method.overrides.synchronized.method.problem.descriptor=未同步方法 <code>#ref()</code> 覆寫 synchronized 方法 #loc
public.field.accessed.in.synchronized.context.problem.descriptor=在同步上下文中存取非 private 欄位 <code>#ref</code> #loc
field.accessed.synchronized.and.unsynchronized.problem.descriptor=同時在同步和未同步上下文中存取欄位 <code>#ref</code> #loc
extended.for.statement.problem.descriptor=擴展 <code>#ref</code> 語句 #loc
object.allocation.in.loop.new.descriptor=迴圈中的物件分配 <code>new #ref()</code> #loc
object.allocation.in.loop.problem.array.initializer.descriptor=迴圈中的陣列分配 #loc
object.allocation.in.loop.problem.call.descriptor=物件分配通過迴圈中的 <code>#ref()</code> 調用完成 #loc
object.allocation.in.loop.problem.methodref.descriptor=物件分配通過迴圈中的實例綁定方法引用 <code>#ref()</code> 完成 #loc
object.allocation.in.loop.problem.lambda.descriptor=物件分配通過捕獲迴圈中的 lambda 完成 #loc
object.allocation.in.loop.problem.string.concat=物件分配通過迴圈中的字串串聯完成 #loc
instantiating.object.to.get.class.object.problem.descriptor=實例化物件以獲取類物件 #loc
field.may.be.static.problem.descriptor=欄位 <code>#ref</code> 可能為 'static' #loc
method.may.be.static.problem.descriptor=方法 <code>#ref()</code> 可能為 'static' #loc
class.initializer.may.be.static.problem.descriptor=類初始值設定項可能為 'static' #loc
map.replaceable.by.enum.map.problem.descriptor=<code>#ref</code> 可取代為 'EnumMap' #loc
set.replaceable.by.enum.set.problem.descriptor=<code>#ref</code> 可取代為 'EnumSet' #loc
inner.class.may.be.static.problem.descriptor=內部類 <code>#ref</code> 可能為 'static' #loc
string.buffer.must.have.initial.capacity.problem.descriptor=沒有初始容量的 <code>new #ref()</code> #loc
string.buffer.replaceable.by.string.builder.problem.descriptor=<code>StringBuffer #ref</code> 可能被宣告為 'StringBuilder' #loc
string.buffer.replaceable.by.string.problem.descriptor=<code>{0} #ref</code> 可以取代為 ''String'' #loc
new.string.buffer.replaceable.by.string.problem.descriptor=<code>#ref</code> 可以取代為 'String' #loc
string.replaceable.by.string.buffer.problem.descriptor=非常數 <code>String #ref</code> 可能應被宣告為 'StringBuilder' #loc
collections.must.have.initial.capacity.problem.descriptor=沒有初始容量的 <code>new #ref()</code> #loc
string.concatenation.in.loops.problem.descriptor=迴圈中的字串串聯 <code>#ref</code> #loc
string.concatenation.inside.string.buffer.append.problem.descriptor=字串串聯作為 <code>{0}.#ref()</code> 調用的實參 #loc
boolean.constructor.problem.descriptor=布爾構造函數調用 #loc
string.buffer.to.string.in.concatenation.problem.descriptor=在串聯中調用 <code>{0}.#ref()</code> #loc
tail.recursion.problem.descriptor=尾部遞歸調用 <code>#ref()</code> #loc
string.equals.empty.string.problem.descriptor=<code>#ref(\\"\\")</code> 可以取代為 'length()==0' #loc
string.equals.empty.string.is.empty.problem.descriptor=<code>#ref(\\"\\")</code> 可以取代為 'isEmpty()' #loc
random.double.for.random.integer.problem.descriptor=使用 <code>Random.#ref</code> 創建隨機整數 #loc
manual.array.copy.problem.descriptor=手動陣列複製 #loc
manual.array.to.collection.copy.problem.descriptor=手動陣列到集合複製 #loc
call.to.simple.getter.in.class.problem.descriptor=從類內調用簡單 getter <code>#ref()</code> #loc
call.to.simple.setter.in.class.problem.descriptor=從類內調用簡單 setter <code>#ref()</code> #loc
assert.without.message.problem.descriptor=沒有訊息的 <code>#ref()</code> #loc
assert.without.message.quick.fix.family.name=添加錯誤訊息
test.case.with.constructor.problem.descriptor=構造函數 <code>#ref()</code> 中的初始化邏輯，而不是 'setUp()' #loc
test.case.with.constructor.problem.descriptor.initializer=初始值設定項中的初始化邏輯，而不是 'setUp()'
misordered.assert.equals.arguments.problem.descriptor=<code>#ref()</code> 的實參順序錯誤 #loc
static.suite.problem.descriptor=Junit <code>#ref()</code> 方法未被宣告為 'static' #loc
simplifiable.junit.assertion.problem.descriptor=<code>#ref()</code> 可以簡化為 ''{0}'' #loc
test.method.without.assertion.problem.descriptor=JUnit 測試方法 <code>#ref()</code> 不包含斷言 #loc
test.case.with.no.test.methods.problem.descriptor=測試類 <code>#ref</code> 沒有測試 #loc
test.case.in.product.code.problem.descriptor=測試用例 <code>#ref</code> 可能應當放置在測試源樹中 #loc
test.method.in.product.code.problem.descriptor=測試方法 <code>#ref()</code> 可能應當放置在測試源樹中 #loc
unconstructable.test.case.problem.descriptor=測試用例 <code>#ref</code> 不能被大多數測試運行程序構造 #loc
deserializable.class.in.secure.context.problem.descriptor=類 <code>#ref</code> 可能被反序列化，影響安全性 #loc
serializable.class.in.secure.context.problem.descriptor=類 <code>#ref</code> 可能被序列化，影響安全性 #loc
serializable.deserializable.class.in.secure.context.problem.descriptor=類 <code>#ref</code> 可能被序列化和反序列化，影響安全性 #loc
cloneable.class.in.secure.context.problem.descriptor=類 <code>#ref</code> 可能被克隆，影響安全性 #loc
cloneable.class.in.secure.context.quickfix=生成始終拋出異常的 'clone()' 方法
remove.cloneable.quickfix=從 'implements' 子句中移除 'Cloneable'
non.final.clone.problem.descriptor=非 final <code>#ref()</code> 方法，影響安全性 #loc
runtime.exec.with.non.constant.string.problem.descriptor=<code>Runtime.#ref()</code> 調用具有非常數實參 #loc
load.library.with.non.constant.string.problem.descriptor=<code>{0}.#ref()</code> 調用具有非常數實參 #loc
jdbc.execute.with.non.constant.string.problem.descriptor=<code>Statement.#ref()</code> 調用具有非常數實參 #loc
jdbc.prepare.statement.with.non.constant.string.problem.descriptor=<code>Connection.#ref()</code> 調用具有非常數實參 #loc
custom.classloader.problem.descriptor=自訂 ClassLoader 類 <code>#ref</code> #loc
custom.security.manager.problem.descriptor=自訂 SecurityManager 類 <code>#ref</code> #loc
system.set.problem.descriptor=對 <code>System.#ref()</code> 的調用可能造成安全問題 #loc
class.loader.instantiation.problem.descriptor=實例化 <code>#ref</code> 可能造成安全問題 #loc
public.static.array.field.problem.descriptor='public static' 陣列欄位 <code>#ref</code>，影響安全性 #loc
public.static.collection.field.problem.descriptor='public static' 集合欄位 <code>#ref</code>，影響安全性 #loc
abstract.class.with.only.one.direct.inheritor.problem.descriptor=只有一個直接繼承者的 abstract 類 <code>#ref</code> #loc

#other
abstract.method.overrides.abstract.method.remove.quickfix=移除冗餘 abstract 方法宣告
class.may.be.interface.convert.quickfix=將類轉換為接口
class.without.constructor.create.quickfix=生成空構造函數
class.without.no.arg.constructor.ignore.option=如果類具有預設構造函數，則忽略
extends.annotation.problem.descriptor=類 ''{0}'' 實作註解接口 <code>#ref</code> #loc
extends.annotation.interface.problem.descriptor=接口 ''{0}'' 擴展註解接口 <code>#ref</code> #loc
extends.concrete.collection.problem.descriptor=類 <code>#ref</code> 顯式擴展 ''{0}'' #loc
anonymous.extends.concrete.collection.problem.descriptor=匿名類顯式擴展 ''{0}'' #loc
inner.class.on.interface.ignore.option=忽略接口的內部接口
inner.class.on.interface.problem.descriptor=接口 ''{0}'' 具有內部類 <code>#ref</code> #loc
missing.deprecated.annotation.add.quickfix=添加 @Deprecated 註解
missing.add.deprecated.javadoc.tag.quickfix=添加 '@deprecated' Javadoc 標記
non.protected.constructor.in.abstract.class.ignore.option=對非 public 類忽略
public.constructor.in.non.public.class.problem.descriptor=構造函數在非 public 類 ''{0}'' 中被宣告為 <code>#ref</code> #loc
static.inheritance.replace.quickfix=將繼承取代為 {0} 中的限定引用
utility.class.with.public.constructor.make.quickfix=將{0, choice, 1#構造函數|2#構造函數}設為 'private'
utility.class.without.private.constructor.create.quickfix=生成空 'private' 構造函數
utility.class.without.private.constructor.make.quickfix=將構造函數設為 'private'
naming.convention.problem.descriptor.short={0} 名稱 <code>#ref</code> 過短({1} < {2}) #loc
naming.convention.problem.descriptor.long={0} 名稱 <code>#ref</code> 過長({1} > {2}) #loc
naming.convention.problem.descriptor.regex.mismatch={0} 名稱 <code>#ref</code> 不符合正則表達式 ''{1}'' #loc
local.variable.naming.convention.ignore.option=忽略 for 迴圈參數
local.variable.naming.convention.ignore.catch.option=忽略 'catch' 塊參數
method.names.differ.only.by.case.problem.descriptor=方法名稱 <code>#ref</code> 和方法名稱 ''{0}'' 僅大小寫不同 #loc
parameter.name.differs.from.overridden.parameter.ignore.character.option=如果覆寫的參數僅包含一個字符，則忽略
parameter.name.differs.from.overridden.parameter.ignore.library.option=如果覆寫的參數來自庫，則忽略
parameter.name.differs.from.overridden.parameter.problem.descriptor=參數名稱 <code>#ref</code> 與覆寫的參數 ''{0}'' 不同 #loc
questionable.name.column.title=名稱
questionable.name.list.label=報告的名稱:
standard.variable.names.problem.descriptor=變數命名 <code>#ref</code> 沒有類型 ''{0}'' #loc
standard.variable.names.problem.descriptor2=變數命名 <code>#ref</code> 沒有類型 ''{0}'' 或 ''{1}'' #loc
standard.variable.names.ignore.override.option=對與 super 方法參數相同的參數名稱忽略
boolean.method.name.must.start.with.question.table.column.name=布爾方法名稱前綴
boolean.method.name.must.start.with.question.table.label=布爾方法名稱前綴:
conditional.expression.with.identical.branches.collapse.quickfix=摺疊條件表達式
redundant.else.unwrap.quickfix=移除冗餘的 'else'
constant.conditional.expression.problem.descriptor=<code>#ref</code> 可以簡化為 ''{0}'' #loc
constant.conditional.expression.simplify.quickfix=簡化
constant.conditional.expression.simplify.quickfix.sideEffect=提取副作用並簡化
enum.switch.statement.which.misses.cases.problem.descriptor.single=枚舉類型 ''{0}'' 上的 <code>#ref</code> 語句缺少 case ''{1}'' #loc
enum.switch.statement.which.misses.cases.problem.descriptor=枚舉類型 ''{0}'' 上的 <code>#ref</code> 語句缺少 case: {1} #loc
for.loop.replaceable.by.while.ignore.option=忽略無條件的 'infinite' for 迴圈
for.loop.with.missing.component.problem.descriptor1=<code>#ref</code> 語句缺少初始值設定項 #loc
for.loop.with.missing.component.problem.descriptor2=<code>#ref</code> 語句缺少條件 #loc
for.loop.with.missing.component.problem.descriptor3=<code>#ref</code> 語句缺少更新 #loc
for.loop.with.missing.component.problem.descriptor4=<code>#ref</code> 語句缺少初始值設定項和條件 #loc
for.loop.with.missing.component.problem.descriptor5=<code>#ref</code> 語句缺少初始值設定項和條件 #loc
for.loop.with.missing.component.problem.descriptor6=<code>#ref</code> 語句缺少條件和更新 #loc
for.loop.with.missing.component.problem.descriptor7=<code>#ref</code> 語句缺少初始值設定項、條件和更新 #loc
foreach.replace.quickfix=取代為增強 'for'
unnecessary.boxing.remove.quickfix=移除裝箱
unnecessary.unboxing.remove.quickfix=移除拆箱
misordered.assert.equals.arguments.flip.quickfix=翻轉比較實參
simplify.junit.assertion.simplify.quickfix=簡化斷言
test.method.is.public.void.no.arg.problem.descriptor1=測試方法 <code>#ref()</code> 不應具有參數 #loc
test.method.is.public.void.no.arg.problem.descriptor2=測試方法 <code>#ref()</code> 未被宣告為 'public void' #loc
test.method.is.public.void.no.arg.problem.descriptor3=測試方法 <code>#ref()</code> 不應為 'static' #loc
system.properties.problem.descriptor=對 <code>Integer.#ref()</code> 的調用可能造成安全問題 #loc
system.properties.problem.descriptor1=對 <code>Boolean.#ref()</code> 的調用可能造成安全問題 #loc
unsecure.random.number.generation.problem.descriptor1=出於安全目的，請使用 'java.security.SecureRandom' 而不是 <code>java.lang.Math.#ref()</code> #loc
unsecure.random.number.generation.problem.descriptor2=出於安全目的，請使用 'java.security.SecureRandom' 而不是 <code>java.util.#ref</code> #loc
unsecure.random.number.generation.problem.descriptor3=出於安全目的，請使用 'java.security.SecureRandom' 而不是 <code>#ref</code> #loc
serializable.has.serialization.methods.problem.descriptor=可序列化類 <code>#ref</code> 未定義 'readObject()' 或 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor1=可序列化類 <code>#ref</code> 未定義 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor2=可序列化類 <code>#ref</code> 未定義 'readObject()' #loc
serializable.with.unconstructable.ancestor.problem.descriptor=<code>#ref</code> 具有不帶無參構造函數的不可序列化上級 ''{0}'' #loc
transient.field.in.non.serializable.class.problem.descriptor=欄位 ''{0}'' 已在不可序列化類中標記為 <code>#ref</code> #loc
safe.lock.problem.descriptor=''{0}'' 應在 ''try'' 塊之前鎖定，並在相應的 ''finally'' 塊中解鎖 #loc
synchronized.method.problem.descriptor=方法 ''{0}()'' 被宣告為 <code>#ref</code> #loc
synchronized.method.include.option=包含本地方法
synchronized.method.ignore.synchronized.super.option=忽略覆寫 synchronized 方法的方法
synchronized.method.move.quickfix=將同步移動到方法中
volatile.field.problem.descriptor=類型 ''{0}'' 的 volatile 欄位 <code>#ref</code> #loc
string.format.choose.class=選擇格式化程序類
string.format.class.column.name=附加格式化程序類
string.format.class.label=附加格式化程序類:
string.format.class.method.name=附加格式化程序方法
string.format.class.method.label=附加格式化程序方法:
exception.class.column.name=異常類
bad.exception.thrown.problem.descriptor=已拋出禁止異常 ''{0}'' #loc
too.broad.catch.problem.descriptor=<code>#ref</code> 的 ''catch'' 過寬，遮罩異常 ''{0}'' #loc
too.broad.catch.problem.descriptor1=<code>#ref</code> 的 ''catch'' 過寬，遮罩異常 ''{0}'' 和 ''{1}'' #loc
add.serialversionuidfield.quickfix=添加 'serialVersionUID' 欄位
delete.import.quickfix=刪除不必要的匯入
encapsulate.variable.quickfix=封裝欄位 ''{0}''
extract.method.quickfix=提取方法
inline.call.quickfix=內聯調用
inline.variable.quickfix=內聯變數
pointless.nullcheck.display.name=方法調用前出現不必要的 'null' 檢查
pointless.nullcheck.problem.descriptor.call=''{0}()'' 調用之前的 ''null'' 檢查不必要
remove.redundant.polyadic.operand.fix.name=移除不必要的 ''{0}'' 條件
remove.redundant.polyadic.operand.fix.family.name=移除不必要的條件
introduce.constant.quickfix=引入常數
make.initialization.explicit.quickfix=使初始化顯式
move.anonymous.to.inner.quickfix=轉換為命名內部類
anonymous.inner.may.be.named.static.inner.class.quickfix=轉換為命名 'static' 內部類
move.class.quickfix=移動類
normalize.declaration.quickfix=拆分為單獨的宣告
remove.modifier.quickfix=移除 ''{0}'' 修飾符
replace.inheritance.with.delegation.quickfix=將繼承取代為委託
cast.that.loses.precision.problem.descriptor=''{0}'' 到 <code>#ref</code> 的轉換可能導致精度損失 #loc
cast.that.loses.precision.negative.problem.descriptor=''{0}'' 到 <code>#ref</code> 的轉換可能導致負實參的精度損失 #loc
comparison.to.nan.problem.descriptor1=與 <code>#ref</code> 的比較始終為 false #loc
comparison.to.nan.problem.descriptor2=與 <code>#ref</code> 的比較始終為 true #loc
confusing.floating.point.literal.change.quickfix=更改為規範形式
implicit.numeric.conversion.ignore.widening.conversion.option=忽略擴大轉換
implicit.numeric.conversion.ignore.char.conversion.option=忽略 'char' 之間的轉換
implicit.numeric.conversion.ignore.constant.conversion.option=忽略從常數和文字的轉換
implicit.numeric.conversion.problem.descriptor=將 <code>#ref</code> 從 ''{0}'' 隱式數字轉換為 ''{1}'' #loc
implicit.numeric.conversion.assignment.problem.descriptor=將結果值從 ''{0}'' 隱式數字轉換為 ''{1}'' #loc
implicit.numeric.conversion.make.explicit.quickfix=使轉換顯式
non.reproducible.math.call.replace.quickfix=取代為 'StrictMath' 調用
overly.complex.arithmetic.expression.max.number.option=最大項數:
expression.can.be.replaced.problem.descriptor=<code>#ref</code> 可以取代為 ''{0}'' #loc
method.complexity.limit.option=方法復雜度限制:
expression.can.be.replaced.no.quotes.problem.descriptor={0} 可以取代為 {1}
cyclomatic.complexity.problem.descriptor=過度複雜的方法 <code>#ref()</code> (迴圈復雜度 = {0}) #loc
method.coupling.limit.option=方法耦合限制:
method.coupling.problem.descriptor=<code>#ref</code> 過度耦合 (# 引用的類 = {0}) #loc
method.with.multiple.loops.problem.descriptor=<code>#ref</code> 包含 {0} 個迴圈 #loc
return.point.limit.option=返回點限制(&R):
multiple.return.points.per.method.problem.descriptor=<code>#ref</code> 具有 {0} 個返回點 #loc
nesting.depth.limit.option=嵌套深度限制:
nesting.depth.problem.descriptor=<code>#ref</code> 過度嵌套 (最大嵌套深度 = {0}) #loc
non.comment.source.statements.limit.option=非註釋源語句限制:
non.comment.source.statements.problem.descriptor=<code>#ref</code> 過長 (# 非註釋源語句 = {0}) #loc
parameters.per.method.problem.descriptor=<code>#ref()</code> 的參數過多(參數數量 = {0}) #loc
parameters.per.constructor.problem.descriptor=<code>#ref()</code> 的參數過多(參數數量 = {0}) #loc
parameter.limit.option=參數限制:
constructor.visibility.option=忽略具有以下可見性的構造函數:
three.negations.per.method.ignore.option=忽略 'equals()' 方法中的否定
three.negations.per.method.ignore.assert.option=忽略 'assert' 語句中的否定
three.negations.per.method.problem.descriptor=<code>#ref</code> 包含 {0} 個否定 #loc
thrown.exceptions.per.method.problem.descriptor=<code>#ref</code> 宣告的異常過多 (異常數量 = {0}) #loc
thrown.exceptions.per.method.limit.option=異常拋出限制:
call.to.simple.getter.in.class.ignore.option=忽略其他物件上的 getter 調用
call.to.private.simple.getter.in.class.option=僅在 getter 為 'private' 時報告
call.to.simple.getter.in.class.inline.quickfix=內聯調用 getter
call.to.simple.setter.in.class.ignore.option=忽略其他物件上的 setter 調用
call.to.private.setter.in.class.option=僅在 setter 為 'private' 時報告
call.to.simple.setter.in.class.inline.quickfix=內聯調用 setter
make.static.quickfix=設為 'static'
length.one.strings.in.concatenation.replace.quickfix=取代為字符
multiply.or.divide.by.power.of.two.replace.quickfix=取代為移位
boolean.expression.can.be.simplified.problem.descriptor=<code>#ref</code> 可以簡化為 ''{0}'' #loc
boolean.expression.does.not.modify.problem.descriptor=<code>#ref</code> 未修改 ''{0}'' 的值 #loc
boolean.expression.remove.compound.assignment.quickfix=移除無意義的復合賦值
trivial.string.concatenation.problem.descriptor=串聯中使用的空字串
string.replace.quickfix=將串聯取代為 ''{0}''
instantiating.object.to.get.class.object.replace.quickfix=取代為直接類物件存取
method.may.be.static.only.option=僅檢查 'private' 或 'final' 方法
method.may.be.static.empty.option=忽略空方法
string.concatenation.inside.string.buffer.append.replace.quickfix=取代為鏈式 'append()' 調用
string.equals.empty.string.option.do.not.add.null.check=當有必要進行 null 檢查時，不必報告
tail.recursion.replace.quickfix=用迭代替換尾部遞歸
if.statement.with.too.many.branches.max.option=最大分支數:
if.statement.with.too.many.branches.problem.descriptor=<code>#ref</code> 的分支過多 ({0}) #loc
negated.conditional.invert.quickfix=反轉條件
negated.if.else.ignore.negated.null.option=忽略 '!= null' 比較
negated.if.else.ignore.negated.zero.option=忽略 '!= 0' 比較
negated.if.else.invert.quickfix=反轉 'if' 條件
overly.complex.boolean.expression.max.terms.option=最大項數:
pointless.boolean.expression.ignore.option=在確定無意義表達式時忽略命名常數
simplifiable.conditional.expression.problem.descriptor=<code>#ref</code> 可以簡化為 ''{0}'' #loc
switch.statement.density.min.option=分支的最小密度: %
switch.statement.density.problem.descriptor=<code>#ref</code> 的分支密度過低 ({0}%) #loc
switch.statement.with.too.few.branches.min.option=最小分支數:
switch.statement.with.too.few.branches.problem.descriptor=''switch'' 語句的 case 標籤太少({0})，並且可能應當取代為 ''if'' 語句 #loc
switch.statement.with.single.default.message='switch' 語句只有 'default' case
switch.expression.with.too.few.branches.problem.descriptor=''switch'' 表達式的 case 標籤太少 ({0})，並且可能應當取代為 ''if'' 語句或條件運算符 #loc
switch.expression.with.single.default.message='switch' 表達式只有 'default' case
switch.statement.without.default.ignore.option=忽略詳盡的 switch 語句
unnecessary.label.remove.quickfix=移除標籤
unnecessary.return.problem.descriptor=<code>#ref</code> 不必要，因為是 'void' 方法中的最後一條語句 #loc
unnecessary.return.constructor.problem.descriptor=<code>#ref</code> 不必要，因為是構造函數中的最後一條語句 #loc
unused.label.remove.quickfix=移除未使用的標籤
unnecessarily.qualified.static.usage.problem.descriptor=不必要的限定 static 方法調用 <code>{0}()</code> #loc
unnecessarily.qualified.static.usage.problem.descriptor1=不必要的限定靜態存取 <code>{0}</code> #loc
unnecessarily.qualified.static.usage.ignore.field.option=忽略不必要的限定欄位存取
unnecessarily.qualified.static.usage.ignore.method.option=忽略不必要的限定方法調用
unnecessary.interface.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於接口是冗餘的 #loc
unnecessary.interface.modifier.inner.interface.of.interface.problem.descriptor=修飾符 <code>#ref</code> 對於內部接口是冗餘的 #loc
unnecessary.interface.modifier.problem.descriptor2=修飾符 <code>#ref</code> 對於接口方法是冗餘的 #loc
unnecessary.interface.modifier.problem.descriptor3=修飾符 <code>#ref</code> 對於接口的內部類是冗餘的 #loc
unnecessary.interface.modifier.problem.descriptor4=修飾符 <code>#ref</code> 對於接口欄位是冗餘的 #loc
smth.unnecessary.remove.quickfix=移除不必要的 ''{0}''
unqualified.static.usage.problem.descriptor=非限定 static 方法調用 <code>#ref()</code> #loc
unqualified.static.usage.problem.descriptor1=非限定 static 欄位存取 <code>#ref</code> #loc
unqualified.static.usage.ignore.field.option=忽略非限定欄位存取
unqualified.static.usage.ignore.method.option=忽略非限定方法調用
unqualified.static.usage.qualify.field.quickfix=限定 static 欄位存取
unqualified.static.usage.qualify.method.quickfix=限定 static 方法調用
too.broad.scope.allow.option=<html>報告使用新表達式作為初始值設定項的變數<br>(可能不安全)</html>
too.broad.scope.only.blocks.option=僅報告可移入內部塊的變數
too.broad.scope.narrow.quickfix=將 ''{0}'' 的宣告移近用法
press.escape.to.remove.highlighting.message=按 Esc 移除高亮顯示
unnecessary.enum.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於枚舉構造函數是冗餘的 #loc
unnecessary.enum.modifier.problem.descriptor1=修飾符 <code>#ref</code> 對於內部枚舉是冗餘的 #loc
literal.as.arg.to.string.equals.problem.descriptor=文字 #ref 是 ''{0}()'' 的實參，而不是其限定符 #loc
literal.as.arg.to.string.equals.flip.quickfix=翻轉 ''{0}()''
c.style.array.declaration.replace.quickfix=取代為 Java 樣式陣列宣告
chained.method.call.ignore.option=忽略欄位初始值設定項中的鏈式方法調用
chained.method.call.ignore.self.types.option=忽略對返回類型與其封閉類相同的方法的調用
introduce.variable.quickfix=引入變數
introduce.variable.may.change.semantics.quickfix=引入變數 (可能更改語意)
flip.comparison.quickfix=翻轉比較
control.flow.statement.without.braces.add.quickfix=將大括號添加到語句
control.flow.statement.without.braces.message=將大括號添加到 ''{0}'' 語句
extends.object.remove.quickfix=移除冗餘的 'extends Object'
implicit.call.to.super.ignore.option=對 'java.lang.Object' 的直接子類忽略
implicit.call.to.super.make.explicit.quickfix=使對 'super()' 的調用顯式
missorted.modifiers.require.option=檢查註解順序
missorted.modifiers.typeuse.before.type.option=目標 TYPE_USE 註解始終位於類型前
missorted.modifiers.sort.quickfix=對修飾符排序
nested.method.call.ignore.option=忽略欄位初始值設定項中的嵌套方法調用
ignore.calls.to.static.methods=忽略對 static 方法的調用
ignore.calls.to.property.getters=忽略對屬性 getter 的調用
redundant.field.initialization.remove.quickfix=移除初始值設定項
redundant.implements.remove.quickfix=移除冗餘接口宣告
unnecessary.constructor.remove.quickfix=移除冗餘構造函數
unnecessary.fully.qualified.name.replace.quickfix=將限定名稱取代為匯入
unnecessary.fully.qualified.name.remove.quickfix=移除不必要的限定
unnecessary.fully.qualified.name.status.bar.escape.highlighting.message={0} 個完全限定{0, choice, 1#名稱|2#名稱}取代為匯入 (按 Esc 移除高亮顯示)
unnecessary.parentheses.remove.quickfix=移除不必要的圓括號
unnecessary.qualifier.for.this.remove.quickfix=移除不必要的限定符
unnecessary.semicolon.remove.quickfix=移除不必要的分號
unnecessary.super.constructor.remove.quickfix=移除不必要的 'super()'
unnecessary.this.remove.quickfix=移除不必要的 'this' 限定符
overly.strong.type.cast.problem.descriptor=到 <code>#ref</code> 的轉換可以被削弱為 ''{0}'' #loc
field.count.inspection.include.constant.fields.in.count.checkbox=在計數中包含常數欄位
field.count.inspection.static.final.fields.count.as.constant.checkbox=將 'static final' 欄位計為常數
field.count.inspection.include.enum.constants.in.count=在計數中包含枚舉常數
make.method.final.fix.name=將方法 ''{0}()'' 設為 ''final''
make.class.final.fix.name=將類 ''{0}'' 設為 ''final''
non.boolean.method.name.must.not.start.with.question.display.name=非布爾方法名稱不能以疑問詞開頭
non.boolean.method.name.must.not.start.with.question.problem.descriptor=非布爾方法名稱 <code>#ref</code> 以疑問詞開頭 #loc
boolean.constructor.simplify.quickfix=簡化
unnecessary.temporary.on.conversion.from.string.problem.descriptor=<code>#ref</code> #loc 可以簡化為 ''{0}''
only.report.qualified.static.usages.option=僅報告來自 static 上下文的限定靜態存取
unqualified,static.usage.only.report.static.usages.option=僅報告來自非 static 上下文的靜態存取
assignment.to.catch.block.parameter.problem.descriptor=賦值給 'catch' 塊參數 <code>#ref</code> #loc
assignment.to.method.parameter.problem.descriptor=賦值給方法參數 <code>#ref</code> #loc
value.of.post.increment.problem.descriptor=使用後增量表達式 <code>#ref</code> 的值 #loc
value.of.post.decrement.problem.descriptor=使用後減量表達式 <code>#ref</code> 的值 #loc
value.of.pre.increment.problem.descriptor=使用前增量表達式 <code>#ref</code> 的值 #loc
value.of.pre.decrement.problem.descriptor=使用前減量表達式 <code>#ref</code> 的值 #loc
assignment.replaceable.with.operator.assignment.problem.descriptor=<code>#ref</code> 可以簡化為 ''{0}'' #loc
assignment.replaceable.with.operator.assignment.ignore.conditional.operators.option=忽略條件運算符
assignment.replaceable.with.operator.assignment.ignore.obscure.operators.option=忽略模糊的 ^ 和 % 運算符
object.equality.ignore.between.objects.of.a.type.with.only.private.constructors.option=忽略只有 'private' 構造函數的類型物件之間的 '=='
redundant.method.override.display.name=方法與其 super 方法相同
redundant.method.override.delegates.to.super.problem.descriptor=方法 <code>#ref()</code> 僅委託給 super 方法 #loc
redundant.method.override.problem.descriptor=方法 <code>#ref()</code> 與其 super 方法相同 #loc
redundant.method.override.quickfix=移除冗餘方法
redundant.method.override.option.check.library.methods=檢查覆寫庫方法的方法
refused.bequest.problem.descriptor=方法 <code>#ref()</code> 未調用 'super.#ref()' #loc
refused.bequest.ignore.empty.super.methods.option=忽略空 super 方法
refused.bequest.ignore.default.super.methods.option=忽略 'default' super 方法
overly.complex.boolean.expression.ignore.option=忽略純合取和析取
pointless.indexof.comparison.display.name=無意義的 'indexOf()' 比較
pointless.indexof.comparison.always.true.problem.descriptor=<code>#ref</code> 始終為 true #loc
pointless.indexof.comparison.always.false.problem.descriptor=<code>#ref</code> 始終為 false #loc
reuse.of.local.variable.problem.descriptor=局部變數 <code>#ref</code> 的重用 #loc
single.character.startswith.display.name=單個字符 'startsWith()' 或 'endsWith()'
single.character.startswith.problem.descriptor=單個字符 <code>#ref()</code> 可以取代為 'charAt()' 表達式 #loc
list.indexof.replaceable.by.contains.display.name='List.indexOf()' 表達式可取代為 'contains()'
string.indexof.replaceable.by.contains.display.name='String.indexOf()' 表達式可取代為 'contains()'
overloaded.methods.with.same.number.parameters.problem.descriptor=具有相同數量參數的多個方法命名 <code>#ref</code> #loc
overloaded.vararg.method.problem.descriptor=多載 vararg 方法 <code>#ref()</code> #loc
overloaded.vararg.constructor.problem.descriptor=多載 vararg 構造函數 <code>#ref()</code> #loc
cached.number.constructor.call.display.name=數字構造函數調用具有基元實參
cached.number.constructor.call.problem.descriptor=數字構造函數調用具有基元實參 #loc
cached.number.constructor.call.ignore.string.arguments.option=忽略具有字串實參的新數字表達式
cached.number.constructor.call.report.only.deprecated=僅在構造函數為 @Deprecated 時報告
chained.equality.comparisons.problem.descriptor=鏈式相等比較 <code>#ref</code> #loc
confusing.octal.escape.sequence.problem.descriptor=八進制轉義序列 <code>#ref</code> 後面緊跟數字 #loc
field.accessed.synchronized.and.unsynchronized.option=簡單的 getter 和 setter 也被視為欄位存取
method.overrides.inaccessible.method.display.name=方法覆寫了超類不可存取的方法
method.overrides.package.local.method.problem.descriptor=方法 <code>#ref()</code> 覆寫了位於另一個軟體套件中的超類的 package-private 方法 #loc
suspicious.to.array.call.display.name=可疑的 'Collection.toArray()' 調用
suspicious.to.array.call.problem.descriptor=應為類型 ''{0}[]'' 的陣列，找到的是 ''{1}[]'' #loc
suspicious.system.arraycopy.display.name=可疑的 'System.arraycopy()' 調用
suspicious.system.arraycopy.problem.descriptor4=<code>#ref</code> 不是陣列類型 #loc
suspicious.system.arraycopy.problem.descriptor5=<code>#ref</code> 不是陣列類型 #loc
suspicious.system.arraycopy.problem.descriptor6=源參數類型 ''{0}'' 不可分配給類型為 ''{1}'' 的目標參數 <code>#ref</code> #loc
suspicious.system.arraycopy.problem.descriptor.length.bigger.src=長度始終大於 ''src.length - srcPos'' {0}
suspicious.system.arraycopy.problem.descriptor.length.bigger.dest=長度始終大於 ''dest.length - destPos'' {0}
suspicious.system.arraycopy.problem.descriptor.ranges.intersect=複製到具有相交範圍的同一陣列
method.only.used.from.inner.class.display.name=僅在內部類中使用 private 方法
method.only.used.from.inner.class.problem.descriptor=方法 <code>#ref()</code>#loc 只能從{0, choice, 1#內部|2#局部|3#}{1, choice, 1#類|2#接口|3#派生的匿名類|4#註解類型|5#枚舉|6#記錄} ''{2}'' 使用 #loc
method.only.used.from.inner.class.ignore.option=忽略從匿名類或局部類調用的方法(&A)
only.report.static.methods=僅報告 'static' 方法(&O)
single.character.startswith.quickfix=取代為 'charAt()' 表達式
interface.never.implemented.option=忽略僅宣告常數的接口
size.replaceable.by.isempty.display.name='size() == 0' 可取代為 'isEmpty()'
size.replaceable.by.isempty.negation.ignore.option=忽略將取代為 '!isEmpty()' 的表達式
size.replaceable.by.isempty.fix.ignore.calls=忽略類型 ''{1}'' 上的 ''.{0}()'' 調用
choose.class.type.to.ignore=選擇要忽略的類
loop.condition.not.updated.inside.loop.display.name=迴圈變數未在迴圈內更新
loop.variable.not.updated.inside.loop.problem.descriptor=變數 '#ref' 未在迴圈內更新#loc
loop.condition.not.updated.inside.loop.problem.descriptor=條件 '#ref' 未在迴圈內更新#loc
loop.variable.not.updated.inside.loop.option.nonlocal=忽略可能的非本地變更
utility.class.without.private.constructor.option=忽略僅具有主方法的類
super.class.logger.option=在超類有可存取的記錄器時忽略
static.method.only.used.in.one.class.display.name=static 成員僅在其他一個類中使用
static.method.only.used.in.one.class.problem.descriptor=static {0, choice, 1#方法|2#欄位} <code>#ref{0, choice, 1#()|2#}</code> 僅在 ''{1}'' 類中使用 #loc
static.method.only.used.in.one.anonymous.class.problem.descriptor=static {0, choice, 1#方法|2#欄位} <code>#ref{0, choice, 1#()|2#}</code> 僅在派生自 ''{1}'' 的匿名類中使用 #loc
static.method.only.used.in.one.class.quickfix=將 {0} 移至使用類
static.method.only.used.in.one.class.ignore.test.option=僅在測試類中使用時忽略
static.method.only.used.in.one.class.ignore.anonymous.option=僅在匿名類中使用時忽略
static.method.only.used.in.one.class.ignore.on.conflicts=當方法無法在不產生衝突的情況下移動時忽略
static.method.only.used.in.one.class.ignore.utility.classes=忽略位於實用程序類中的成員
unary.plus.display.name=一元正號
unary.plus.problem.descriptor=一元 <code>#ref</code> 運算符 #loc
await.without.corresponding.signal.display.name=沒有相應 'signal()' 的 'await()'
await.without.corresponding.signal.problem.descriptor=在沒有相應 <code>signal()</code> 或 <code>signalAll()</code> 的情況下調用 <code>#ref()</code> #loc
signal.without.corresponding.await.display.name=沒有相應 'await()' 的 'signal()'
signal.without.corresponding.await.problem.descriptor=在沒有相應 <code>await()</code> 的情況下調用 <code>#ref()</code> #loc
wait.without.corresponding.notify.display.name=沒有相應 'notify()' 的 'wait()'
wait.without.corresponding.notify.problem.descriptor=在沒有相應 <code>notify()</code> 或 <code>notifyAll()</code> 的情況下調用 <code>#ref()</code> #loc
notify.without.corresponding.wait.display.name=沒有相應 'wait()' 的 'notify()'
notify.without.corresponding.wait.problem.descriptor=在沒有相應 <code>wait()</code> 的情況下調用 <code>#ref()</code> #loc
integer.multiplication.implicit.cast.to.long.display.name=整數乘法或移位隱式轉換為 'long'
integer.multiplication.implicit.cast.to.long.problem.descriptor=#ref: 整數乘法隱式轉換為 long #loc
integer.multiplication.implicit.cast.to.long.quickfix=轉換為 long
integer.shift.implicit.cast.to.long.problem.descriptor=#ref: 整數移位隱式轉換為 long #loc
integer.multiplication.implicit.cast.to.long.option=<html>忽略靜態證明不可能溢出的表達式</html>
wait.or.await.without.timeout.display.name=無超時的 'wait()' 或 'await()'
wait.or.await.without.timeout.problem.descriptor=無超時的 <code>#ref</code> #loc
method.return.always.constant.display.name=方法返回類特定的常數
method.return.always.constant.problem.descriptor=方法 <code>#ref()</code> 及其所有派生方法始終返回常數
class.with.too.many.dependencies.display.name=依賴過多的類
class.with.too.many.dependencies.problem.descriptor=類 ''{0}'' 的依賴過多 ({1} > {2})
class.with.too.many.transitive.dependencies.display.name=可傳遞依賴項過多的類
class.with.too.many.transitive.dependencies.problem.descriptor=類 ''{0}'' 的可傳遞依賴項過多({1} > {2})
class.with.too.many.dependents.display.name=依賴項過多的類
class.with.too.many.dependents.problem.descriptor=類 ''{0}'' 的依賴項過多 ({1} > {2})
class.with.too.many.transitive.dependents.display.name=傳遞依賴項過多的類
class.with.too.many.transitive.dependents.problem.descriptor=類 ''{0}'' 的可傳遞依賴項過多({1} > {2})
class.with.too.many.dependencies.max.option=最大依賴項數
class.with.too.many.dependents.max.option=最大依賴項數
class.with.too.many.transitive.dependencies.max.option=最大可傳遞依賴項數
class.with.too.many.transitive.dependents.max.option=最大傳遞依賴項數
cyclic.class.dependency.display.name=迴圈類依賴
cyclic.class.dependency.problem.descriptor=類 ''{0}'' 迴圈依賴於其他 {1} 個類
cyclic.class.dependency.1.problem.descriptor=類 ''{0}'' 迴圈依賴於類 ''{1}''
cyclic.class.dependency.2.problem.descriptor=類 ''{0}'' 迴圈依賴於類 ''{1}'' 和 ''{2}''
cyclic.package.dependency.display.name=迴圈軟體套件依賴關係
cyclic.package.dependency.problem.descriptor=軟體套件 ''{0}'' 迴圈依賴於其他 {1} 個軟體套件
cyclic.package.dependency.1.problem.descriptor=軟體套件 ''{0}'' 迴圈依賴於軟體套件 ''{1}''
cyclic.package.dependency.2.problem.descriptor=軟體套件 ''{0}'' 迴圈依賴於軟體套件 ''{1}'' 和 ''{2}''
class.unconnected.to.package.display.name=獨立於其軟體套件的類
class.unconnected.to.package.problem.descriptor=類 <code>#ref</code> 在其軟體套件中沒有依賴或依賴項
exception.package.display.name=異常軟體套件
exception.package.problem.descriptor=軟體套件 ''{0}'' 僅包含異常類
package.with.too.many.classes.display.name=類過多的軟體套件
package.with.too.many.classes.problem.descriptor=軟體套件 ''{0}'' 包含過多的類 ({1} > {2})
package.with.too.many.classes.max.option=最大類數:
package.with.too.few.classes.display.name=軟體套件具有過少類
package.with.too.few.classes.problem.descriptor=軟體套件 ''{0}'' 包含過少的類 ({1} < {2})
package.with.too.few.classes.min.option=最小類數:
suspicious.package.private.access.display.name=可疑的 package-private 存取權限
groups.of.modules.loaded.together.label=一起載入的模組組:
groups.of.modules.loaded.together.description=每行指定以逗號分隔的模組名稱列表，已知這些模組名稱是由同一 ClassLoader 載入的，因此，不應報告對此類模組之間的 package-private 成員的存取。
module.with.too.many.classes.display.name=類過多的模組
module.with.too.many.classes.problem.descriptor=模組 ''{0}'' 包含過多的類 ({1} > {2})
module.with.too.many.classes.max.option=最大類數:
module.with.too.few.classes.display.name=類過少的模組
module.with.too.few.classes.problem.descriptor=模組 ''{0}'' 包含過少的類 ({1} < {2})
module.with.too.few.classes.min.option=最小類數:
package.in.multiple.modules.display.name=具有多個模組中的類的軟體套件
disjoint.package.display.name=具有不相交依賴關係圖的軟體套件
disjoint.package.problem.descriptor=軟體套件 {0} 可以分解為 {1} 個獨立軟體套件
package.naming.convention.display.name=軟體套件命名慣例
package.naming.convention.problem.descriptor.short=軟體套件名稱 <code>{0}</code> 過短
package.naming.convention.problem.descriptor.long=軟體套件名稱 <code>{0}</code> 過長
package.naming.convention.problem.descriptor.regex.mismatch=軟體套件名稱 <code>{0}</code> 與正則表達式 ''{1}'' 不符合
before.or.after.is.public.void.no.arg.display.name='@Before' 或 '@After' 方法的格式錯誤
before.or.after.is.public.void.no.arg.problem.descriptor=<code>#ref()</code> 的 @Before 或 @After 方法的簽名不正確 #loc
before.class.or.after.class.is.public.static.void.no.arg.display.name='@BeforeClass'/'@BeforeAll' 或 '@AfterClass'/'@AfterAll' 方法的格式錯誤
before.class.or.after.class.is.public.static.void.no.arg.problem.descriptor=<code>#ref()</code> 的 @{0} 方法的簽名不正確 #loc
design.for.extension.display.name=為擴展設計
design.for.extension.problem.descriptor=方法 <code>#ref()</code> 可能被覆寫，其功能會被忽略 #loc
bad.oddness.display.name=可疑的奇數檢查
bad.oddness.problem.descriptor=對負值進行奇數檢查將會失敗 #loc
comparator.not.serializable.display.name='Comparator' 類未被宣告為 'Serializable'
comparator.not.serializable.problem.descriptor=比較器類 <code>#ref</code> 未被宣告為可序列化 #loc
non.serializable.field.in.serializable.class.display.name='Serializable' 類中有不可序列化的欄位
non.serializable.field.in.serializable.class.problem.descriptor=可序列化類中不可序列化的欄位 '#ref' #loc
non.serializable.object.passed.to.object.stream.display.name=不可序列化的物件被傳遞給了 'ObjectOutputStream'
non.serializable.object.passed.to.object.stream.problem.descriptor=傳遞給 ObjectOutputStream 的不可序列化物件 #loc
non.serializable.object.bound.to.http.session.display.name=不可序列化的物件被綁定到了 'HttpSession'
non.serializable.object.bound.to.http.session.problem.descriptor=傳遞給 HttpSession 的不可序列化物件 #loc
reflection.for.unavailable.annotation.display.name=對僅源註解的反射存取
reflection.for.unavailable.annotation.problem.descriptor=註解 '#ref' 不保留用於反射存取 #loc
access.to.static.field.locked.on.instance.display.name=存取實例資料上鎖定的 'static' 欄位
access.to.static.field.locked.on.instance.problem.descriptor=存取實例資料上鎖定的 static 欄位 <code>#ref</code> #loc
access.to.static.field.locked.on.instance.fix.name=忽略類型 ''{0}'' 的 static 欄位
make.method.ctr.quickfix=使方法成為構造函數
replace.all.dot.display.name=可疑的正則表達式實參
replace.all.dot.problem.descriptor=''{0}()'' 調用中存在可疑的正則表達式 #ref #loc
replace.all.dot.quickfix=轉義正則表達式元字符
class.extends.utility.class.display.name=類擴展實用程序類
class.extends.utility.class.problem.descriptor=類 <code>#ref</code> 擴展實用程序類 ''{0}'' #loc
class.extends.utility.class.ignore.utility.class.option=如果覆寫類為實用程序類，則忽略
public.constructor.in.non.public.class.quickfix=將構造函數設為 private
assignment.to.method.parameter.ignore.transformation.option=<html>如果賦值是原始參數的轉換，則忽略</html>
type.parameter.extends.final.class.display.name=類型參數擴展 'final' 類
type.parameter.extends.final.class.type.parameter.problem.descriptor=類型參數 <code>#ref</code> 擴展 ''final'' 類{0} #loc
type.parameter.extends.enum.type.parameter.problem.descriptor=類型參數 <code>#ref</code> 隱式擴展 final 枚舉 ''{0}'' #loc
type.parameter.extends.final.class.wildcard.problem.descriptor=萬用字元類型實參 <code>#ref</code> 擴展了 ''final'' 類 ''{0}'' #loc
type.parameter.extends.enum.wildcard.problem.descriptor=萬用字元類型實參 <code>#ref</code> 隱式擴展了 final 枚舉 ''{0}'' #loc
type.parameter.extends.final.class.quickfix=將類型參數取代為實際類
double.negation.display.name=雙重否定
double.negation.problem.descriptor=<code>#ref</code> 中的雙重否定 #loc
double.negation.quickfix=移除雙重否定
exception.from.catch.which.doesntwrap.ignore.option=如果使用異常方法調用的結果，則忽略
exception.from.catch.which.doesntwrap.ignore.cant.wrap.option=如果拋出的異常無法包裝異常，則忽略
comparable.implemented.but.equals.not.overridden.display.name=已實作 'Comparable'，但 'equals()' 未被覆寫
comparable.implemented.but.equals.not.overridden.problem.descriptor=類 <code>#ref</code> 實作 'java.lang.Comparable'，但未覆寫 'equals()' #loc
comparable.implemented.but.equals.not.overridden.fix.add.note.name=添加 'ordering inconsistent with equals' JavaDoc 記錄
comparable.implemented.but.equals.not.overridden.fix.generate.equals.name=生成 'equals()' 方法
unqualified.field.access.display.name=未使用 'this' 限定的實例欄位存取
unqualified.field.access.problem.descriptor=未使用 'this' 限定的實例欄位存取 <code>#ref</code> #loc
unqualified.method.access.display.name=未使用 'this' 限定的實例方法調用
unqualified.method.access.problem.descriptor=未使用 'this' 限定實例方法調用 <code>#ref()</code> #loc
add.this.qualifier.quickfix=添加 'this' 限定符
while.loop.spins.on.field.ignore.non.empty.loops.option=僅當迴圈為空時才發出警告
method.may.be.synchronized.problem.descriptor=帶 synchronized 塊的方法 <code>#ref()</code> 可以是 synchronized 方法 #loc
method.may.be.synchronized.display.name=只有一個 'synchronized' 塊的方法可取代為 'synchronized' 方法
method.may.be.synchronized.quickfix=將方法設為 synchronized 並移除 synchronized 塊
fallthru.in.switch.statement.quickfix=添加 ''{0}''
law.of.demeter.display.name=方法調用違反迪米特法則
law.of.demeter.problem.descriptor=<code>#ref()</code> 調用違反迪米特法則 #loc
law.of.demeter.ignore.library.calls.option=忽略庫方法上的調用
assertequals.between.inconvertible.types.display.name='assertEquals()' 位於不可轉換類型的物件之間
assertequals.between.inconvertible.types.problem.descriptor=<code>#ref()</code> 位於 ''{0}'' 和 ''{1}'' 不可轉換類型的物件之間 #loc
assertnotequals.between.inconvertible.types.problem.descriptor=可能的冗餘斷言: 比較不相容的類型 ''{0}'' 和 ''{1}''
assertnotsame.between.inconvertible.types.problem.descriptor=冗餘斷言: 比較不相容的類型 ''{0}'' 和 ''{1}''
masked.assertion.display.name=斷言通過 'catch' 屏蔽
masked.assertion.problem.description=''{0}'' 不能失敗，因為它通過 ''catch'' 屏蔽
enumeration.can.be.iteration.display.name=枚舉可以是迭代
enumeration.can.be.iteration.problem.descriptor=<code>#ref()</code> 可以取代為 ''{0}'' 結構 #loc
enumeration.can.be.iteration.quickfix=取代為 'Iterator' 結構
equals.hashcode.called.on.url.display.name=在 'URL' 物件上調用了 'equals()' 或 'hashCode()'
equals.hashcode.called.on.url.problem.descriptor=在 URL 物件上調用 <code>#ref()</code> #loc
collection.contains.url.problem.decriptor={0} <code>#ref</code> 可能包含 URL 物件 #loc
collection.contains.url.display.name='Map' 或 'Set' 可能包含 'URL' 物件
implicit.array.to.string.problem.descriptor=隱式調用陣列 <code>#ref</code> 上的 'toString()' #loc
explicit.array.to.string.problem.descriptor=調用陣列上的 '#ref()' #loc
implicit.array.to.string.method.call.problem.descriptor=隱式調用調用 <code>#ref</code> 返回的陣列上的 'toString()' #loc
implicit.array.to.string.display.name=調用陣列上的 'toString()'
implicit.array.to.string.quickfix=使用 ''{0}'' 表達式包裝
suspicious.indent.after.control.statement.problem.descriptor=''{0}'' 語句後存在可疑縮排 #loc
suspicious.indent.after.control.statement.display.name=沒有大括號的控制語句後存在可疑縮排
unpredictable.big.decimal.constructor.call.display.name=不可預知的 'BigDecimal' 構造函數調用
unpredictable.big.decimal.constructor.call.problem.descriptor=不可預知的 <code>new #ref()</code> 調用 #loc
unpredictable.big.decimal.constructor.call.ignore.references.option=忽略具有變量或方法調用實參的構造函數調用
unpredictable.big.decimal.constructor.call.ignore.complex.literals.option=忽略具有多個文字的構造函數調用 (例如 0.1 + 0.2)
unnecessary.unary.minus.display.name=不必要的一元負號
unnecessary.unary.minus.problem.descriptor=不必要的一元 <code>#ref</code> 運算符 #loc
unnecessary.unary.minus.quickfix=移除一元負號並反轉父運算符號
unnecessary.unary.minus.remove.quickfix=移除雙一元減號
make.field.final.quickfix=將 ''{0}'' 設為 ''final''
increment.decrement.used.as.expression.quickfix=提取 ''{0}'' 以分離語句
ignore.classes.in.hierarchy.column.name=忽略以下物件的子類:
overly.strong.type.cast.ignore.in.matching.instanceof.option=忽略具有符合 instanceof 表達式的轉換
access.to.non.thread.safe.static.field.from.instance.display.name=非執行緒安全的 'static' 欄位存取
access.to.non.thread.safe.static.field.from.instance.field.problem.descriptor=存取類型為 ''{0}'' 的非執行緒安全 static 欄位 <code>#ref</code> #loc
access.to.non.thread.safe.static.field.from.instance.option.title=非執行緒安全類:
access.to.non.thread.safe.static.field.from.instance.class.chooser.title=選擇非執行緒安全類
transient.field.not.initialized.display.name=transient 欄位在反序列化時未初始化
transient.field.not.initialized.problem.descriptor=transient 欄位 <code>#ref</code> 在反序列化時未初始化 #loc
call.to.string.concat.can.be.replaced.by.operator.display.name=對 'String.concat()' 的調用可以取代為 '+'
call.to.string.concat.can.be.replaced.by.operator.problem.descriptor=對 <code>#ref()</code> 的調用可以取代為 '+' 表達式 #loc
call.to.string.concat.can.be.replaced.by.operator.quickfix=用 '+' 取代 'concat()'
new.string.buffer.with.char.argument.display.name=StringBuilder 構造函數調用具有 'char' 實參
new.string.buffer.with.char.argument.problem.descriptor=<code>new #ref()</code> 具有 'char' 類型的實參 #loc
new.string.buffer.with.char.argument.quickfix=將字符實參取代為字串文字
suspicious.comparator.compare.display.name=可疑的 'Comparator.compare()' 實作
suspicious.comparator.compare.descriptor.parameter.not.used=未使用 'compare()' 參數 <code>#ref</code> #loc
suspicious.comparator.compare.descriptor.non.reflexive=對於相等的元素，比較器不返回 0
to.array.call.style.display.name='Collection.toArray()' 調用樣式
to.array.call.style.problem.descriptor.zero=<code>#ref()</code> 調用具有空陣列實參 ''{0}'' #loc
to.array.call.style.problem.descriptor.presized=<code>#ref()</code> 調用具有預設大小的陣列實參 ''{0}'' #loc
to.array.call.style.quickfix.family.name=修復傳遞到 'toArray()' 調用的陣列的大小
to.array.call.style.quickfix.make.presized=將實參取代為預設大小的陣列
to.array.call.style.quickfix.make.zero=將實參取代為空陣列
throwable.instance.never.thrown.runtime.exception.problem.descriptor=執行時異常實例 <code>#ref</code> 未拋出 #loc
throwable.instance.never.thrown.checked.exception.problem.descriptor=已檢查的異常實例 <code>#ref</code> 未拋出 #loc
throwable.instance.never.thrown.error.problem.descriptor=錯誤實例 <code>#ref</code> 未拋出 #loc
throwable.instance.never.thrown.problem.descriptor=Throwable 實例 <code>#ref</code> 未拋出 #loc
ignore.guard.clauses.option=忽略臨界子句(&G)
ignore.for.equals.methods.option=對 'equals()' 方法忽略(&E)
caught.exception.immediately.rethrown.display.name=捕獲的異常被立即重新拋出
caught.exception.immediately.rethrown.problem.descriptor=捕獲的異常 <code>#ref</code> 被立即重新拋出 #loc
delete.catch.section.quickfix=刪除 'catch' 部分
loop.with.implicit.termination.condition.display.name=具有隱式終止條件的迴圈
loop.with.implicit.termination.condition.dowhile.problem.descriptor=具有隱式終止條件的 <code>#ref-while</code> 迴圈 #loc
loop.with.implicit.termination.condition.problem.descriptor=具有隱式終止條件的 <code>#ref</code> 迴圈 #loc
loop.with.implicit.termination.condition.quickfix=使條件顯式
rename.catch.parameter.to.ignored=將 ''catch'' 參數重命名為 ''{0}''
inspection.empty.catch.block.generate.body=從模板生成 'catch' 正文
unnecessary.super.qualifier.display.name=不必要的 'super' 限定符
unnecessary.super.qualifier.problem.descriptor=限定符 <code>#ref</code> 在此上下文中不必要 #loc
unnecessary.super.qualifier.quickfix=移除不必要的 'super' 限定符
collections.field.access.replaceable.by.method.call.display.name=對空集合欄位的引用可以取代為方法調用
collections.field.access.replaceable.by.method.call.problem.descriptor=<code>#ref</code> 可取代為 ''Collections.{0}'' #loc
synchronization.on.local.variable.or.method.parameter.display.name=在局部變數或方法參數上同步
synchronization.on.local.variable.problem.descriptor=在局部變數 <code>#ref</code> 上同步 #loc
synchronization.on.method.parameter.problem.descriptor=在方法參數 <code>#ref</code> 上同步 #loc
too.broad.catch.quickfix=向 ''{0}'' 添加 ''catch'' 子句
replace.with.catch.clause.for.runtime.exception.quickfix=針對 'RuntimeException' 取代為 'catch' 子句
too.broad.catch.option=僅對 RuntimeException、異常、錯誤或 Throwable 發出警告(&O)
unnecessary.conversion.to.string.display.name=到 'String' 的不必要轉換
unnecessary.tostring.call.display.name=對 'toString()' 的調用不必要
unnecessary.tostring.call.problem.descriptor=不必要的 <code>#ref()</code> 調用 #loc
throwable.not.thrown.display.name='Throwable' 未拋出
throwable.result.of.method.call.ignored.problem.descriptor=<code>#ref()</code> 的結果未拋出 #loc
char.used.in.arithmetic.context.display.name=在算術上下文中使用 'char' 表達式
char.used.in.arithmetic.context.problem.descriptor=算術上下文中使用了 'char' #loc
char.used.in.arithmetic.context.quickfix=轉換為字串文字
char.used.in.arithmetic.context.cast.quickfix=插入到 {0} 的轉換
unnecessary.constant.array.creation.expression.display.name=常數陣列創建中的冗餘 'new' 表達式
unnecessary.constant.array.creation.expression.problem.descriptor=可從新陣列表達式中移除 <code>#ref</code> #loc
unnecessary.constant.array.creation.expression.family.quickfix=從新陣列表達式中移除類型規範
ambiguous.method.call.display.name=對繼承方法的調用類似於對本地方法的調用
ambiguous.method.call.problem.descriptor=對來自超類 ''{0}'' 的方法 <code>#ref()</code> 的調用類似於對來自類 ''{1}'' 的方法的調用 #loc
ambiguous.method.call.quickfix=向方法調用中添加 'super' 限定符
change.modifier.quickfix=設為 ''{0}''
the.whole.project=整個專案
this.class=此類
assertequals.may.be.assertsame.display.name='assertEquals()' 可能是 'assertSame()'
assertequals.may.be.assertsame.problem.descriptor=<code>#ref()</code> 可能是 'assertSame()' #loc
logger.initialized.with.foreign.class.problem.descriptor=使用外類 <code>#ref</code> 初始化記錄器 #loc
logger.initialized.with.foreign.class.display.name=使用外類初始化記錄器
logger.factory.method.name=記錄器工廠方法名稱
logger.factory.class.name=記錄器工廠類名
make.static.final.quickfix=將 ''{0}'' 設為 static final
logging.condition.disagrees.with.log.statement.display.name=日誌條件與日誌記錄調用不符合
logging.condition.disagrees.with.log.statement.problem.descriptor=日誌條件 <code>#ref()</code> 與 ''{0}()'' 日誌調用不符合 #loc
log.statement.guarded.by.log.condition.display.name=日誌調用不受日誌條件保護
log.statement.guarded.by.log.condition.problem.descriptor=<code>#ref()</code> 日誌調用不受日誌條件保護 #loc
log.statement.guarded.by.log.condition.quickfix=用日誌條件環繞
log.statement.guarded.by.log.condition.flag.all.unguarded.option=標記所有不受保護的日誌調用
key.set.iteration.may.use.entry.set.display.name=可以優化對 'keySet()' 的迭代
key.set.iteration.may.use.entry.set.problem.descriptor=<code>#ref</code> 上的迭代可以取代為 ''{0}'' 迭代 #loc
key.set.iteration.may.use.entry.set.quickfix=優化 Map 迭代
string.replaceable.by.string.buffer.in.loop.option=僅在迴圈中追加時發出警告
declare.collection.as.interface.quickfix=削弱為 ''{0}''
non.exception.name.ends.with.exception.quickfix=使 ''{0}'' 擴展 ''java.lang.Exception''
constant.value.variable.use.display.name=使用已知值為常數的變數
constant.value.variable.use.problem.descriptor=<code>#ref</code> 的值已知為常數 #loc
unnecessary.parentheses.option=忽略澄清圓括號
unnecessary.parentheses.conditional.option=忽略條件表達式條件周圍的圓括號
field.may.be.final.display.name=欄位可能為 'final'
field.may.be.final.problem.descriptor=欄位 <code>#ref</code> 可能為 'final' #loc
cast.that.loses.precision.option=忽略從 int 到 char 的轉換
ignore.overflowing.byte.casts.option=忽略從 int 128-255 到位元組的轉換
variable.not.used.inside.if.display.name='if' 內未使用檢查為 'null' 的引用
variable.not.used.inside.if.problem.descriptor='if' 內未使用檢查為 'null' 的 <code>#ref</code> #loc
variable.not.used.inside.conditional.problem.descriptor=條件內未使用檢查為 'null' 的 <code>#ref</code> #loc
boolean.expression.may.be.conditional.display.name=布爾表達式可以取代為條件表達式
if.may.be.conditional.problem.descriptor=<code>#ref</code> 可以取代為條件表達式 #loc
if.may.be.conditional.quickfix=取代為條件表達式
redundant.string.format.call.display.name=冗餘調用 'String.format()'
redundant.call.problem.descriptor=冗餘調用 <code>#ref()</code> #loc
redundant.string.format.call.quickfix=移除對 'String.format()' 的冗餘調用
redundant.string.formatted.call.quickfix=移除對 'String.formatted()' 的冗餘調用
junit4.test.method.in.class.extending.junit3.testcase.display.name=擴展 JUnit 3 TestCase 中的 JUnit 4 測試方法
convert.junit3.test.case.error.string=<code>#ref</code> 可以轉換為 JUnit4 測試用例
convert.junit3.test.case.family.name=轉換為 JUnit 4 測試用例
convert.junit3.test.case.display.name=JUnit 3 測試可以是 JUnit 4
junit4.test.method.in.class.extending.junit3.testcase.problem.descriptor=方法 <code>#ref()</code> 在擴展 JUnit 3 TestCase 的類內使用 '@Test' 註解 #loc
ignore.test.method.in.class.extending.junit3.testcase.problem.descriptor=使用 '@Ignore' 註解的 JUnit 3 測試方法 <code>#ref()</code> 不會被忽略 #loc
ignore.test.method.in.class.extending.junit3.testcase.quickfix=移除 ''@Ignore'' 並將方法重命名為 ''{0}''
convert.junit3.test.class.quickfix=將 JUnit 3 類 ''{0}'' 轉換為 JUnit 4
remove.junit4.test.annotation.quickfix=移除 '@Test' 註解
remove.junit4.test.annotation.and.rename.quickfix=移除 ''@Test'' 註解並重命名為 ''{0}''
equals.called.on.enum.constant.display.name=對枚舉值調用了 'equals()'
equals.called.on.enum.constant.problem.descriptor=對枚舉值調用了 <code>#ref()</code> #loc
int.literal.may.be.long.literal.display.name=轉換為 'long' 可以是 'long' 文字
int.literal.may.be.long.literal.problem.descriptor=<code>#ref</code> 可以取代為 ''{0}'' #loc
constant.assert.condition.display.name='assert' 語句中的常數條件
constant.assert.condition.problem.descriptor=斷言條件 <code>#ref</code> 是常數 #loc
assert.with.side.effects.display.name=具有副作用的 'assert' 語句
assert.with.side.effects.problem.descriptor=<code>#ref</code> 具有副作用: {0} #loc
method.count.ignore.getters.setters.option=忽略簡單的 getter 和 setter 方法(&I)
class.new.instance.display.name=對 'Class.newInstance()' 的調用不安全
class.new.instance.problem.descriptor=對 <code>#ref()</code> 的調用可能會拋出未宣告的已檢查的異常 #loc
dynamic.regex.replaceable.by.compiled.pattern.display.name=動態正則表達式可以取代為已編譯的 'Pattern'
dynamic.regex.replaceable.by.compiled.pattern.problem.descriptor=<code>#ref()</code> 可以取代為已編譯的 'java.util.regex.Pattern' 結構 #loc
dynamic.regex.replaceable.by.compiled.pattern.quickfix=取代為對已編譯 'Pattern' 常數的方法的調用
ignore.serializable.option=忽略 'java.io.Serializable'
ignore.cloneable.option=忽略 'java.lang.Cloneable'
listener.may.use.adapter.display.name=類可以會擴展適配器而不是實作偵聽器
listener.may.use.adapter.problem.descriptor=類 ''{0}'' 可以擴展 ''{1}'' 而不是實作 <code>#ref</code> #loc
listener.may.use.adapter.emtpy.methods.option=僅在找到空實作方法時發出警告(&O)
unnecessary.inherit.doc.display.name=不必要的 '{@inheritDoc}' Javadoc 註釋
unnecessary.inherit.doc.problem.descriptor=僅包含 <code>#ref</code> 的 Javadoc 註釋不必要 #loc
unnecessary.inherit.doc.field.invalid.problem.descriptor=<code>#ref</code> 在欄位上無效 #loc
unnecessary.inherit.doc.constructor.invalid.problem.descriptor=<code>#ref</code> 在構造函數上無效 #loc
unnecessary.inherit.doc.class.invalid.problem.descriptor=<code>#ref</code> 在類上無效 #loc
unnecessary.inherit.doc.module.invalid.problem.descriptor=<code>#ref</code> 在模組宣告上無效 #loc
unnecessary.inherit.doc.constructor.no.super.problem.descriptor=找不到繼承 Javadoc 的 super 方法 #loc
unnecessary.inherit.doc.quickfix=移除不必要的 {@inheritDoc}
multiple.exceptions.declared.on.test.method.display.name=在測試方法上宣告的多個異常
multiple.exceptions.declared.on.test.method.problem.descriptor=<code>#ref</code> 可以取代為 'throws Exception' #loc
unnecessary.javadoc.link.display.name=不必要的 Javadoc 鏈接
unnecessary.javadoc.link.super.method.problem.descriptor=指向 super 方法的 <code>#ref</code> 不必要 #loc
unnecessary.javadoc.link.this.method.problem.descriptor=指向此方法的 <code>#ref</code> 不必要 #loc
unnecessary.javadoc.link.this.class.problem.descriptor=指向包含類的 <code>#ref</code> 不必要 #loc
unnecessary.javadoc.link.quickfix=移除不必要的 ''{0}''
thread.local.not.static.final.display.name='ThreadLocal' 欄位未被宣告為 'static final'
thread.local.not.static.final.problem.descriptor=ThreadLocal <code>#ref</code> 未被宣告為 'static final' #loc
remove.try.finally.block.quickfix=移除 'try-finally' 塊
remove.finally.block.quickfix=移除 'finally' 塊
remove.leading.zero.to.make.decimal.quickfix=移除前導零以變為十進制
remove.leading.zeroes.to.make.decimals.quickfix=移除前導零以變為十進制
convert.octal.literal.to.decimal.literal.quickfix=將八進制文字轉換為十進制文字
convert.octal.literals.to.decimal.literals.quickfix=將八進制文字轉換為十進制文字
ignore.single.field.static.imports.option=忽略單欄位靜態匯入(&F)
ignore.single.method.static.imports.option=忽略單方法靜態匯入(&M)
ignore.methods.with.boolean.return.type.option=忽略具有 'java.lang.Boolean' 返回類型的方法(&B)
ignore.boolean.methods.in.an.interface.option=忽略 @&interface 中的布爾方法
ignore.methods.overriding.super.method=忽略覆寫/實作 super 方法的方法(O&)
ignored.io.resource.types=已忽略的 I/O 資源類型
ignored.io.resource.types.label=已忽略的 I/O 資源類型:
choose.io.resource.type.to.ignore=選擇要忽略的 I/O 資源類型
ignore.accesses.from.the.same.class=忽略來自同一類的存取
ignore.accesses.from.equals.method=忽略來自 'equals()' 方法的存取
ignore.branches.of.switch.statements=忽略 'switch' 語句的分支
ignore.equals.hashcode.and.tostring=忽略 'equals()'、'hashCode()' 和 'toString()' 方法
ignore.methods.in.anonymous.classes=忽略匿名類中的方法
class.name=類名
method.name.regex=方法名稱正則表達式
column.assertion.class.name=斷言類名
choose.class=選擇類
query.column.name=查詢名稱開頭
query.label=查詢名稱開頭:
update.column.name=更新名稱開頭
update.label=更新名稱開頭:
assert.keyword.is.considered.an.assertion='assert' 關鍵字被視為斷言
expected.exception.never.thrown.display.name=從未在測試方法正文中拋出預期異常
expected.exception.never.thrown.problem.descriptor=從未在 ''{0}()'' 的正文中拋出預期 <code>#ref</code> #loc
choose.logger.class=選擇記錄器類
logger.class.name=記錄器類名:
ignore.exceptions.declared.on.library.override.option=忽略在覆寫庫方法的方法上宣告的異常(&L)
allow.resource.to.be.opened.inside.a.try.block=允許在 'try' 塊內打開資源
any.method.may.close.resource.argument=任何方法都可能關閉作為實參傳遞的資源
ignore.constructor.method.references=忽略產生 AutoCloseable 的構造函數方法引用
ignore.getters.returning.resource=忽略返回源的 getter
log.method.name=記錄方法名稱
log.condition.text=日誌條件文本
ignore.if.annotated.by=有註解時忽略:
ignore.parameter.if.annotated.by=有註解時忽略參數:
ignore.classes.annotated.by=由以下物件註解時忽略類:
ignored.class.hierarchies.border.title=忽略以下物件的子類:
choose.class.hierarchy.to.ignore.title=選擇要忽略的類層次結構
unqualified.inner.class.access.display.name=非限定內部類存取
unqualified.inner.class.access.problem.descriptor=<code>#ref</code> 未使用外部類限定 #loc
unqualified.inner.class.access.quickfix=使用外部類限定
unnecessarily.qualified.inner.class.access.problem.descriptor=使用 <code>#ref</code> 限定 ''{0}'' 不必要 #loc
unnecessarily.qualified.inner.class.access.display.name=不必要的限定內部類存取
unnecessarily.qualified.inner.class.access.quickfix=移除限定符
synchronization.on.static.field.display.name=在 'static' 欄位上同步
synchronization.on.static.field.problem.descriptor=在 'static' 欄位 <code>#ref</code> 上同步 #loc
assertequals.called.on.arrays.display.name=在陣列上調用了 'assertEquals()'
assertequals.called.on.arrays.problem.descriptor=在陣列上調用了 <code>#ref()</code> #loc
overly.broad.throws.clause.display.name=過寬的 'throws' 子句
overly.broad.throws.clause.problem.descriptor1=<code>throws #ref</code> 過寬，遮罩異常 ''{0}'' #loc
overly.broad.throws.clause.problem.descriptor2=<code>throws #ref</code> 過寬，遮罩異常 ''{0}'' 和 ''{1}'' #loc
overly.broad.throws.clause.quickfix1=添加特定異常
overly.broad.throws.clause.quickfix2=取代為特定異常
overly.broad.throws.clause.ignore.thrown.option=忽略隱藏其他異常但自身被拋出的異常(&H)
unnecessarily.qualified.statically.imported.element.display.name=不必要的限定靜態匯入元素
unnecessarily.qualified.statically.imported.element.problem.descriptor=靜態匯入元素 ''{0}'' 使用 <code>#ref</code> 不必要限定 #loc
unnecessarily.qualified.statically.imported.element.quickfix=移除不必要的限定符
ignore.instanceof.on.library.classes=忽略庫類上的 instanceof
for.can.be.foreach.option=報告索引的 'java.util.List' 迴圈
for.can.be.foreach.option2=不報告無類型集合上的迭代
cast.conflicts.with.instanceof.quickfix1=在轉換中將 ''{0}'' 取代為 ''{1}''
cast.conflicts.with.instanceof.quickfix2=在 instanceof 中將 ''{0}'' 取代為 ''{1}''
double.checked.locking.quickfix=將 ''{0}'' 設為 volatile
double.literal.may.be.float.literal.display.name=轉換為 'float' 可以是 'float' 文字
multiple.declaration.ignore.for.option=忽略 'for' 迴圈宣告
multiple.declaration.array.only.option=僅在單個宣告中對不同的陣列維度發出警告
simplifiable.annotation.display.name=可簡化註解
simplifiable.annotation.problem.descriptor=註解中有不必要的 <code>#ref</code> #loc
simplifiable.annotation.whitespace.problem.descriptor=註解中有不必要的空格 #loc
simplifiable.annotation.quickfix=簡化註解
overloaded.methods.with.same.number.parameters.option=<html>忽略參數類型絕對不相容的多載方法</html>
string.concatenation.in.format.call.display.name=字串串聯作為 'format()' 調用的實參
string.concatenation.in.format.call.problem.descriptor=''{0}()'' 調用包含字串串聯實參
string.concatenation.in.format.call.quickfix=將串聯取代為單獨的實參
string.concatenation.in.message.format.call.display.name=字串串聯作為 'MessageFormat.format()' 調用的實參
string.concatenation.in.message.format.call.problem.descriptor=字串串聯作為 'MessageFormat.format()' 調用的實參 #loc
boxing.boxed.value.display.name=裝箱已裝箱的值
boxing.boxed.value.problem.descriptor=裝箱已裝箱的 <code>#ref</code> #loc
boxing.boxed.value.quickfix=移除不必要的裝箱
unnecessary.javadoc.link.option=忽略 super 方法的內聯鏈接
constant.junit.assert.argument.display.name=常數斷言實參
constant.junit.assert.argument.problem.descriptor=實參 <code>#ref</code> 是常數 #loc
test.case.with.no.test.methods.option=忽略具有帶測試方法的超類的測試用例
package.dot.html.may.be.package.info.display.name='package.html' 可以轉換為 'package-info.java'
package.dot.html.may.be.package.info.exists.problem.descriptor=<code>package.html</code> 被忽略，因為 <code>package-info.java</code> 存在
package.dot.html.may.be.package.info.problem.descriptor=<code>package.html</code> 可以轉換為 <code>package-info.java</code>
package.dot.html.may.be.package.info.delete.quickfix=刪除 'package.html'
package.dot.html.may.be.package.info.convert.quickfix=轉換為 'package-info.java'
ignore.anonymous.inner.classes=忽略匿名內部類
try.with.identical.catches.display.name='try' 語句中的相同 'catch' 分支
try.with.identical.catches.problem.descriptor=''catch'' 分支與 ''{0}'' 分支相同 #loc
if.can.be.switch.display.name='if' 可以取代為 'switch'
if.can.be.switch.problem.descriptor=<code>#ref</code> 語句可取代為 'switch' 語句 #loc
if.can.be.switch.minimum.branch.option='if' 條件分支的最小數量:
if.can.be.switch.int.option=對數字啟用 switch 建議
if.can.be.switch.enum.option=對枚舉啟用 switch 建議
if.can.be.switch.null.safe.option=僅對 null-safe 表達式啟用建議
unnecessarily.qualified.inner.class.access.option=忽略需要匯入的引用
unqualified.inner.class.access.option=忽略對本地內部類的引用
try.with.identical.catches.quickfix=摺疊 'catch' 塊
confusing.else.option=當 'if' 語句之後沒有其他語句時報告
html.tag.can.be.javadoc.tag.display.name='<code>...</code>' 可取代為 '{@code ...}'
html.tag.can.be.javadoc.tag.problem.descriptor=<code>#ref...\\\\\\\\&lt;/code\\\\\\\\&gt;</code> 可以取代為 '{@code ...}' #loc
try.finally.can.be.try.with.resources.display.name='try finally' 可取代為 'try' with resources
try.finally.can.be.try.with.resources.problem.descriptor=<code>#ref</code> 可以使用自動資源管理 #loc
try.finally.can.be.try.with.resources.quickfix=取代為 'try-with-resources'
array.comparison.display.name=使用 '==' 而不是 'Arrays.equals()' 進行陣列比較
array.comparison.problem.descriptor=使用 <code>#ref</code> 而不是 'Arrays.equals()' 來比較陣列物件 #loc
array.hash.code.display.name=在陣列上調用了 'hashCode()'
array.hash.code.problem.descriptor=陣列上調用的 <code>#ref()</code> 可能應當是 'Arrays.hashCode()' #loc
objects.hash.problem.descriptor=傳遞給 'Objects.hash()' 的陣列應包裝在 'Arrays.hashcode()' 中
wrap.with.arrays.hash.code.quickfix=使用 ''{0}'' 包裝
method.can.be.variable.arity.method.display.name=方法可以有 varargs 參數
method.can.be.variable.arity.method.problem.descriptor=<code>#ref()</code> 可以轉換為 vararg 方法 #loc
method.can.be.variable.arity.method.ignore.byte.short.option=忽略具類型為 byte[] 或 short[] 的參數
method.can.be.variable.arity.method.ignore.all.primitive.arrays.option=忽略所有原始陣列類型
method.can.be.variable.arity.method.ignore.multiple.arrays.option=忽略具有多個陣列參數的方法
method.can.be.variable.arity.method.ignore.multidimensional.arrays.option=忽略多維陣列參數
convert.to.variable.arity.method.quickfix=轉換為 vararg 方法
mismatched.string.builder.query.update.display.name='StringBuilder' 的查詢和更新不符合
mismatched.string.builder.updated.problem.descriptor=<code>{0} #ref</code> 的內容已更新，但從未被查詢 #loc
mismatched.string.builder.queried.problem.descriptor=<code>{0} #ref</code> 的內容已查詢，但從未更新 #loc
math.random.cast.to.int.display.name='Math.random()' 轉換為 'int'
math.random.cast.to.int.problem.descriptor=<code>#ref</code> 轉換為 ''{0}'' 時始終向下舍入為 ''0'' #loc
math.random.cast.to.int.quickfix=添加括號以在轉換前執行乘法
boolean.variable.always.inverted.display.name=布爾變數始終反轉
boolean.field.always.inverted.problem.descriptor=布爾欄位 <code>#ref</code> 始終反轉 #loc
boolean.variable.always.inverted.problem.descriptor=布爾變數 <code>#ref</code> 始終反轉 #loc
unnecessary.explicit.numeric.cast.display.name=不必要的顯式數字轉換
unnecessary.explicit.numeric.cast.problem.descriptor=''{0}'' 不必要轉換為 <code>#ref</code> #loc
unnecessary.explicit.numeric.cast.quickfix=移除轉換
null.thrown.display.name=已拋出 'null'
null.thrown.problem.descriptor=已引發 <code>#ref</code> #loc
unnecessary.final.on.local.variable.or.parameter.display.name=局部變數或參數上存在不必要的 'final'
unnecessary.final.on.local.variable.problem.descriptor=變數 ''{0}'' 上存在不必要的 <code>#ref</code> #loc
unnecessary.final.on.parameter.problem.descriptor=參數 ''{0}'' 上存在不必要的 <code>#ref</code> #loc
unnecessary.final.report.local.variables.option=報告局部變數
unnecessary.final.report.parameters.option=報告參數
unnecessary.final.on.parameter.only.interface.option=僅對 abstract 或接口方法發出警告
choose.exception.class=選擇異常類
choose.exception.label=被禁止的異常:
class.independent.of.module.display.name=獨立於其模組的類
class.independent.of.module.problem.descriptor=類 <code>#ref</code> 在其模組中沒有依賴或依賴項 #loc
class.only.used.in.one.module.display.name=僅在其他模組中使用的類
class.only.used.in.one.module.problem.descriptor=類 <code>#ref</code> 在其模組 ''{0}'' 中只有依賴和/或依賴性 #loc
simplifiable.equals.expression.option.non.constant=報告具有非常數非空實參的等於
simplifiable.equals.expression.display.name='equals()' 調用之前的 'null' 檢查不必要
simplifiable.equals.expression.problem.descriptor=''{0}()'' 調用之前的 ''null'' 檢查不必要 #loc
simplifiable.equals.expression.quickfix=翻轉 ''.{0}()'' 並移除不必要的 ''null'' 檢查
use.of.concrete.class.option.ignore.abstract=忽略抽象類類型
use.of.concrete.class.option.report.method.returns=報告方法返回類型
use.of.concrete.class.option.report.local.variable=報告局部變數類型
use.of.concrete.class.option.report.parameter=報告方法參數類型
use.of.concrete.class.option.report.static.fields=報告 static 欄位類型
use.of.concrete.class.option.report.instance.fields=報告實例欄位類型
use.of.concrete.class.option.report.instanceof=報告 instanceof、patterns 或 getClass() 比較中使用的類型
use.of.concrete.class.option.report.cast=報告轉換表達式中使用的類型
class.only.used.in.one.package.display.name=僅在其他軟體套件中使用的類
class.only.used.in.one.package.problem.descriptor=類 <code>#ref</code> 在其軟體套件 ''{0}'' 中只有依賴和/或依賴項 #loc
unnecessary.return.option=在具有 'else' 分支的 'if' 語句的 then 分支中忽略
usage.of.obsolete.assert.display.name=使用廢棄的 'junit.framework.Assert' 方法
use.of.obsolete.assert.problem.descriptor=對來自 ''{0}'' 的 <code>#ref()</code> 的調用應取代為對來自 ''org.junit.Assert'' 的方法的調用 #loc
use.of.obsolete.assert.quickfix=取代為 'org.junit.Assert' 方法調用
ignored.junit.test.display.name=使用 '@Ignore'/'@Disabled' 註解的 JUnit 測試
ignored.junit.test.classproblem.descriptor=使用 <code>#ref</code> 註解的測試類 ''{0}'' #loc
ignored.junit.test.method.problem.descriptor=使用 <code>#ref</code> 註解的測試方法 ''{0}()'' #loc
ignored.junit.test.ignore.reason.option=只報告沒有原因的註解
unclear.binary.expression.display.name=具有不同優先級的多個運算符
unclear.binary.expression.problem.descriptor=表達式可以使用澄清括號 #loc
unclear.binary.expression.quickfix=添加澄清括號
new.exception.without.arguments.display.name=未使用實參調用異常構造函數
new.exception.without.arguments.problem.descriptor=<code>new #ref()</code> 沒有實參 #loc
absolute.alignment.in.user.interface.display.name=AWT/Swing 程式碼中的絕對對齊
absolute.alignment.in.user.interface.problem.descriptor=使用了絕對對齊常數 <code>{0}.#ref</code> #loc
throws.runtime.exception.display.name=在 'throws' 子句中宣告的未檢查的異常
throws.runtime.exception.problem.descriptor=在 'throws' 子句中宣告的未檢查的異常 <code>#ref</code> #loc
throws.runtime.exception.quickfix=從 ''throws'' 子句中移除 ''{0}''
throws.runtime.exception.move.quickfix=將 ''{0}'' 移動到 Javadoc ''@throws'' 標記中
empty.class.ignore.parameterization.option=如果類是父類型的參數化，則將其忽略
ambiguous.field.access.display.name=對繼承欄位的存取類似於對周圍程式碼中元素的存取
ambiguous.field.access.hides.local.variable.problem.descriptor=存取超類 ''{0}'' 中的 <code>#ref</code> 欄位類似於存取局部變數 #loc
ambiguous.field.access.hides.parameter.problem.descriptor=存取超類 ''{0}'' 中的 <code>#ref</code> 欄位類似於存取參數 #loc
ambiguous.field.access.hides.field.problem.descriptor=存取超類 ''{0}'' 中的 <code>#ref</code> 欄位類似於存取周圍類中的欄位 #loc
ambiguous.field.access.quickfix=將 'super' 限定符添加到欄位存取
add.0.to.ignore.if.annotated.by.list.quickfix=將 ''{0}'' 添加到“有註解時忽略”列表中
non.final.field.in.enum.display.name='enum' 中的非 final 欄位
non.final.field.in.enum.problem.descriptor=枚舉 ''{0}'' 中存在非 final 欄位 <code>#ref</code> #loc
externalizable.without.public.no.arg.constructor.display.name=沒有 'public' 無參構造函數的 'Externalizable' 類
externalizable.without.public.no.arg.constructor.problem.descriptor=可外部化類 <code>#ref</code> 沒有 'public' 無參構造函數 #loc
make.constructor.public=將構造函數設為 'public'
string.concatenation.missing.whitespace.display.name=字串串聯中可能缺少空格
string.concatenation.missing.whitespace.problem.descriptor=字串串聯中可能缺少空格 #loc
string.concatenation.missing.whitespace.option=忽略具有變量字串的串聯
negated.equality.expression.display.name=否定相等表達式
negated.equality.expression.problem.descriptor=否定 ''{0}'' #loc
negated.equality.expression.quickfix=移除否定
negated.conditional.expression.display.name=否定條件表達式
negated.conditional.expression.problem.descriptor=否定條件表達式 #loc
negated.conditional.expression.quickfix=移除否定
suspicious.array.cast.display.name=可疑的陣列轉換
suspicious.array.cast.problem.descriptor=可疑轉換為 <code>#ref</code> #loc
public.constructor.display.name='public' 構造函數可以取代為工廠方法
public.default.constructor.problem.descriptor=類 <code>#ref</code> 具有 'public' 預設構造函數
public.constructor.problem.descriptor=public 構造函數 <code>#ref()</code> #loc
public.constructor.quickfix=將構造函數取代為工廠方法
junit3.style.test.method.in.junit4.class.display.name=JUnit 4 類中的舊樣式 JUnit 測試方法
junit3.style.test.method.in.junit4.class.problem.descriptor=JUnit 4 類中的舊樣式 JUnit 測試方法 <code>#ref()</code> #loc
none=無
private=private
package.local.private=package-private 與 private
protected.package.local.private=protected、package-private 和 private
non.final.utility.class.display.name=實用程序類不為 'final'
non.final.utility.class.problem.descriptor=實用程序類 <code>#ref</code> 不為 'final' #loc
0.will.no.longer.be.overridable.by.1={0} 將不再可被 {1} 覆寫
arrays.as.list.with.zero.or.one.argument.display.name='Arrays.asList()' 調用的實參過少
arrays.as.list.with.one.argument.problem.descriptor=僅使用一個實參調用 <code>#ref()</code> #loc
arrays.as.list.with.zero.arguments.problem.descriptor=調用 <code>#ref()</code> 以創建空列表 #loc
string.concatenation.argument.to.log.call.display.name=非常數字串串聯作為日誌調用的實參
string.concatenation.argument.to.log.call.problem.descriptor=非常數字串串聯作為 <code>#ref()</code> 日誌調用的實參 #loc
string.concatenation.argument.to.log.call.quickfix=將串聯取代為參數化的日誌訊息
placeholder.count.matches.argument.count.display.name=佔位符數量與日誌調用中的實參數量不符合
placeholder.count.matches.argument.count.more.problem.descriptor=提供的實參數量({0})多於指定的佔位符({1}) #loc
placeholder.count.matches.argument.count.fewer.problem.descriptor=提供的實參數量({0})少於指定的佔位符數({1}) #loc
assignment.to.superclass.field.display.name=構造函數將值賦給在超類中定義的欄位
assignment.to.superclass.field.problem.descriptor=賦值給在超類 ''{1}'' 中定義的欄位 ''{0}'' #loc
junit.datapoint.display.name='@DataPoint' 欄位的格式錯誤
junit.datapoint.problem.descriptor=使用 @DataPoint 註解的 {1} 應當為 {0}
inner.class.referenced.via.subclass.display.name=通過子類引用的內部類
inner.class.referenced.via.subclass.problem.descriptor=內部類 <code>#ref</code> 在類 ''{0}'' 中宣告，但通過子類 ''{1}'' 引用 #loc
inner.class.referenced.via.subclass.quickfix=使內部類存取合理化
boolean.parameter.display.name='public' 方法具有 'boolean' 參數
boolean.parameter.problem.descriptor='public' 方法 <code>#ref()</code> 具有 'boolean' 參數 #loc
boolean.parameters.problem.descriptor='public' 方法 <code>#ref()</code> 具有 'boolean' 參數 #loc
boolean.parameter.constructor.problem.descriptor='public' 構造函數 <code>#ref()</code> 具有 'boolean' 參數 #loc
boolean.parameters.constructor.problem.descriptor='public' 構造函數 <code>#ref()</code> 具有 'boolean' 參數 #loc
boolean.parameter.only.report.multiple.option=僅報告具有多個布爾參數的方法
unnecessary.unicode.escape.display.name=不必要的 Unicode 轉義序列
unnecessary.unicode.escape.problem.descriptor=Unicode 轉義序列 <code>#ref</code> 可以取代為 ''{0}'' #loc
unnecessary.unicode.escape.problem.tab.descriptor=Unicode 轉義序列 <code>#ref</code> 可以取代為制表符 #loc
unnecessary.unicode.escape.problem.newline.descriptor=Unicode 轉義序列 <code>#ref</code> 可以取代為換行字符 #loc
missing.package.info.display.name=缺少 'package-info.java'
missing.package.info.problem.descriptor=軟體套件 ''{0}'' 缺少 <code>package-info.java</code> 檔案
missing.package.html.problem.descriptor=軟體套件 ''{0}'' 缺少 <code>package.html</code> 檔案
package.info.java.without.package.display.name=不帶 'package' 語句的 'package-info.java'
package.info.without.package.problem.descriptor='package-info.java' 沒有 'package' 語句
package.info.without.package.quickfix=添加 ''package {0};''
package.info.without.package.family.quickfix=添加 package 語句
auto.closeable.resource.display.name=在沒有 'try-with-resources' 的情況下使用 AutoCloseable
auto.closeable.resource.problem.descriptor=在沒有 ''try-with-resources'' 語句的情況下使用 ''{0}'' #loc
auto.closeable.resource.quickfix=忽略此方法返回的 'AutoCloseable'
auto.closeable.resource.returned.option=忽略從所有方法調用返回的 AutoCloseable 實例
problematic.varargs.method.display.name=非 vararg 方法覆寫 vararg 方法
problematic.varargs.method.override.problem.descriptor=非 vararg 方法 <code>#ref()</code> 覆寫 vararg 方法 #loc
negatively.named.boolean.variable.problem.descriptor=布爾變數 <code>#ref</code> 已否定命名 #loc
negatively.named.boolean.variable.display.name=否定命名的布爾變數
invert.quickfix.family.name=反轉布爾
invert.method.quickfix=反轉方法
invert.quickfix=反轉 ''{0}''
throwable.printed.to.system.out.display.name='Throwable' 列印到 'System.out'
throwable.printed.to.system.out.problem.descriptor=''Throwable'' 實參 <code>#ref</code> 到 ''System.{0}.{1}()'' 調用
suppress.for.tests.scope.quickfix=對 'Tests' 範圍禁止
implicit.default.charset.usage.display.name=隱式平台預設字符集
implicit.default.charset.usage.problem.descriptor=對 <code>#ref()</code> 的調用使用平台的預設字符集
implicit.default.charset.usage.constructor.problem.descriptor=<code>new #ref()</code> 調用使用平台的預設字符集
interface.may.be.annotated.functional.display.name=接口可以註解為 '@FunctionalInterface'
interface.may.be.annotated.functional.problem.descriptor=接口 <code>#ref</code> 可以使用 @FunctionalInterface 註解
only.report.public.methods.option=僅報告 'public' 方法
lambda.parameter.hides.member.variable.display.name=lambda 參數隱藏欄位
static.initializer.references.subclass.display.name=static 初始值設定項引用子類
lambda.parameter.hides.member.variable.problem.descriptor=lambda 參數 <code>#ref</code> 隱藏類 ''{0}'' 中的欄位 #loc
lambda.parameter.hides.member.variable.ignore.invisible.option=忽略從 lambda 實際不可見的欄位
shared.thread.local.random.display.name='ThreadLocalRandom' 實例可能是共享的
shared.thread.local.random.problem.descriptor='ThreadLocalRandom' 實例可能在線程之間共享
native.method.naming.convention.element.description='原生'
use.of.obsolete.date.time.api.display.name=使用廢棄的日期時間 API
use.of.obsolete.date.time.api.problem.descriptor=使用了廢棄的日期時間類型 <code>#ref</code> #loc
warn.on.label=警告物件:
all.levels.option=所有日誌級別
warn.level.and.lower.option=警告級別和更低
info.level.and.lower.option=資訊級別和更低
debug.level.and.lower.option=調試級別和更低
trace.level.option=跟踪級別
ignored.autocloseable.types.column.label=已忽略 AutoCloseable 資源類型
ignored.autocloseable.types.label=已忽略的 AutoCloseable 資源類型:
choose.autocloseable.type.to.ignore.title=選擇要忽略的 AutoCloseable 資源類型
big.decimal.method.without.rounding.called.display.name='BigDecimal' 方法調用沒有舍入模式實參
big.decimal.method.without.rounding.called.problem.descriptor=在沒有舍入模式實參的情況下調用了 'BigDecimal.#ref()'
bigdecimal.legacy.method.display.name=調用了 'BigDecimal' 遺留方法
bigdecimal.legacy.method.problem.descriptor=對 'BigDecimal.#ref()' 的調用可以使用 'RoundingMode' 枚舉常數
bigdecimal.legacy.method.quickfix=使用 'RoundingMode' 枚舉常數
serializable.stores.non.serializable.display.name='Serializable' 物件隱式存儲非 'Serializable' 物件
serializable.lambda.stores.non.serializable.problem.descriptor=可序列化 lambda 隱式存儲類型為 ''{0}'' 的不可序列化物件
serializable.local.class.stores.non.serializable.problem.descriptor=可序列化局部類 ''{1}'' 隱式存儲類型為 ''{0}'' 的不可序列化物件
serializable.anonymous.class.stores.non.serializable.problem.descriptor=可序列化匿名類隱式存儲類型為 ''{0}'' 的不可序列化物件
assignment.to.lambda.parameter.display.name=賦值給 lambda 參數
assignment.to.lambda.parameter.problem.descriptor=賦值給 lambda 參數 <code>#ref</code> #loc
class.with.only.private.constructors.display.name=僅包含 'private' 構造函數的類應被宣告為 'final'
class.with.only.private.constructors.problem.descriptor=僅包含 'private' 構造函數的類 <code>#ref</code> 應被宣告為 'final'
property.value.set.to.itself.display.name=屬性值設定為自身
equals.with.itself.display.name=在自身上調用了 'equals()'
equals.with.itself.problem.descriptor=在自身上調用了 <code>#ref()</code>
junit4.method.naming.convention.element.description=JUnit 4+ 測試
junit3.method.naming.convention.element.description=JUnit 3 測試
introduce.holder.class.quickfix=引入 holder 類
double.brace.initialization.display.name=雙大括號初始化
double.brace.initialization.quickfix=取代為正則初始化
return.of.inner.class.display.name=返回匿名、局部或內部類的實例
return.of.anonymous.class.problem.descriptor=返回匿名類的實例 #loc
return.of.local.class.problem.descriptor=返回局部類 <code>{0}</code> 的實例 #loc
return.of.inner.class.problem.descriptor=返回非 static 內部類 <code>{0}</code> 的實例 #loc
return.of.inner.class.ignore.non.public.option=忽略非 public 方法的返回值
parameter.type.prevents.overriding.display.name=參數類型阻止覆寫
parameter.type.prevents.overriding.problem.descriptor=參數類型 <code>#ref</code> 位於 ''{0}''，而 super 方法參數類型位於 ''{1}''，可防止覆寫 #loc
parameter.type.prevents.overriding.quickfix=將參數類型更改為 ''{0}''
parameter.type.prevents.overriding.family.quickfix=更改參數類型
suspicious.getter.setter.display.name=可疑的 getter/setter
suspicious.setter.problem.descriptor=setter <code>#ref()</code> 對欄位 ''{0}'' 賦值 #loc
suspicious.getter.problem.descriptor=getter <code>#ref()</code> 返回欄位 ''{0}'' #loc
unnecessary.break.display.name=不必要的 'break' 語句
unnecessary.break.problem.descriptor=<code>#ref</code> 語句不必要 #loc
utility.class.can.be.enum.display.name=實用程序類可以是 'enum'
utility.class.code.can.be.enum.problem.descriptor=實用程序類 <code>#ref</code> 可以是 'enum' #loc
utility.class.code.can.be.enum.quickfix=轉換為 'enum'
non.public.clone.display.name='clone()' 方法不是 'public'
non.public.clone.problem.descriptor=<code>#ref()</code> 方法不是 'public' #loc
only.warn.on.public.clone.methods=僅對 'public' 克隆方法發出警告
only.warn.on.protected.clone.methods=僅對 'protected' 克隆方法發出警告
clone.returns.class.type.display.name='clone()' 應當具有等於其所包含類的返回類型
clone.returns.class.type.problem.descriptor=''clone()'' 應當具有返回類型 ''{0}'' #loc
clone.returns.class.type.quickfix=將返回類型更改為 ''{0}''
clone.returns.class.type.family.quickfix=將返回類型更改為類類型
use.of.clone.display.name=使用 'clone()' 或 'Cloneable'
use.of.clone.call.problem.descriptor=調用 <code>#ref()</code>
use.of.clone.call.method.problem.descriptor=實作 <code>#ref()</code>
use.of.clone.reference.problem.descriptor=使用 <code>#ref</code>
dangling.javadoc.display.name=懸空的 Javadoc 註釋
dangling.javadoc.problem.descriptor=懸空的 Javadoc 註釋 #loc
dangling.javadoc.convert.quickfix=取代為塊註釋
dangling.javadoc.delete.quickfix=移除懸空的註釋
equals.replaceable.by.objects.call.display.name='equals()' 表達式可取代為 'Objects.equals()' 表達式
equals.replaceable.by.objects.call.problem.descriptor=<code>#ref</code> 可取代為 'Objects.equals()' 表達式 #loc
equals.replaceable.by.objects.check.not.null.option=高亮顯示與 'a != null \\\\\\\\&\\\\\\\\& a.equals(b)' 類似的表達式
array.objects.equals.display.name=對陣列使用淺層方法或 'Objects' 方法
array.equals.problem.descriptor=或許應當使用 ''{0}'' 完成陣列比較''
array.hashcode.problem.descriptor=或許應當使用 ''{0}'' 完成陣列哈希程式碼計算
extends.throwable.display.name=類直接擴展 'Throwable'
anonymous.extends.throwable.problem.descriptor=匿名類直接擴展 'java.lang.Throwable' #loc
extends.throwable.problem.descriptor=類 <code>#ref</code> 直接擴展 'java.lang.Throwable' #loc
lambda.parameter.naming.convention.display.name=lambda 參數命名慣例
lambda.parameter.naming.convention.element.description=lambda 參數
assert.message.not.string.display.name='assert' 訊息不是字串
assert.message.of.type.boolean.problem.descriptor=類型為 ''{0}'' 的 ''assert'' 訊息 #loc
assert.message.not.string.only.warn.boolean.option=僅當 'assert' 訊息為 'boolean' 或 'java.lang.Boolean' 時發出警告
suspicious.literal.underscore.display.name=數字文字中的可疑下划線
suspicious.literal.underscore.problem.descriptor=帶下划線的數字文字中的組沒有長度 3 #loc
unary.plus.quickfix=移除一元 '+'
convert.double.unary.quickfix=取代為 ''{0}{1}''
prefix.operation.quickfix.family.name=取代為前綴運算符
super.tear.down.in.finally.display.name=未從 'finally' 塊調用 'super.tearDown()'
super.tear.down.in.finally.problem.descriptor=未從 'finally' 塊調用 <code>#ref()</code> #loc
confusing.floating.point.literal.option=忽略科學記數法中的浮點文字
class.may.be.interface.java8.option=使用 Java 8 時報告包含非 abstract 方法的類
simplifiable.boolean.expression.display.name=可簡化的布爾表達式
unnecessary.initcause.display.name=對 'Throwable.initCause()' 的調用不必要
unnecessary.initcause.problem.descriptor=不必要的 <code>Throwable.#ref()</code> 調用
unnecessary.initcause.quickfix=移除 'Throwable.initCause()' 調用
consider.static.final.fields.constant.option=考慮 'static final' 欄位常數
atomic.field.updater.not.static.final.display.name='AtomicFieldUpdater' 欄位未被宣告為 'static final'
atomic.field.updater.not.static.final.problem.descriptor={0} 欄位 <code>#ref</code> 未被宣告為 ''static final'' #loc
atomic.field.updater.issues.display.name='AtomicFieldUpdater' 宣告不一致
field.not.found.in.class.problem.descriptor=類 ''{1}'' 中未找到命名為 ''{0}'' 的欄位
field.incorrect.type.problem.descriptor=欄位 ''{0}'' 沒有類型 ''{1}''
field.missing.volatile.modifier.problem.descriptor=欄位 ''{0}'' 沒有 ''volatile'' 修飾符
field.has.static.modifier.problem.descriptor=欄位 ''{0}'' 具有 ''static'' 修飾符
private.field.not.accessible.problem.descriptor=''private'' 欄位 ''{0}'' 無法從此處存取
package.local.field.not.accessible=package-private 欄位 ''{0}'' 無法從此處存取
protected.field.not.accessible.problem.descriptor=''protected'' 欄位 ''{0}'' 無法從此處存取
interface.clashes.with.object.class.display.name=接口方法與 'Object' 中的方法衝突
interface.clashes.with.object.class.problem.descriptor=<code>#ref()</code> 與 'java.lang.Object' 中的方法衝突
optional.used.as.field.or.parameter.type.display.name=用作欄位或參數類型的 'Optional'
optional.used.as.field.type.problem.descriptor=<code>#ref</code> 用作欄位 ''{0}'' 的類型
optional.used.as.parameter.type.problem.descriptor=<code>#ref</code> 用作參數 ''{0}'' 的類型
lambda.unfriendly.method.overload.display.name=方法多載對 lambda 不友好
lambda.unfriendly.method.overload.problem.descriptor=方法 <code>#ref()</code> 的多載對 lambda 不友好
lambda.unfriendly.constructor.overload.problem.descriptor=構造函數 <code>#ref()</code> 的多載對 lambda 不友好
optional.contains.collection.display.name='Optional' 包含陣列或集合
optional.contains.collection.problem.descriptor='Optional' 包含集合 <code>#ref</code>
optional.contains.array.problem.descriptor='Optional' 包含陣列 <code>#ref</code>
synchronization.on.get.class.display.name=在 'getClass()' 上同步
synchronization.on.get.class.problem.descriptor=在 <code>#ref()</code> 上同步 #loc
object.instantiation.inside.equals.or.hashcode.display.name='equals()' 或 'hashCode()' 內部的物件實例化
object.instantiation.inside.equals.or.hashcode.problem.descriptor=''{0}()'' 內部的物件實例化 #loc
object.instantiation.inside.equals.or.hashcode.problem.descriptor2=''{0}()'' ({1}) 內部的物件實例化 #loc
lambda.body.can.be.code.block.name=lambda 體可以是程式碼塊
lambda.body.can.be.code.block.quickfix=將 lambda 體擴展為 {...}
lambda.parameter.type.can.be.specified.name=可以指定 lambda 參數類型
lambda.parameter.type.can.be.specified.descriptor=Lambda 參數類型可以擴展為{0}
lambda.parameter.type.can.be.specified.quickfix=將參數類型擴展為{0}
lambda.parameter.type.can.be.specified.family.quickfix=指定 lambda 參數類型
diamond.can.be.replaced.with.explicit.type.arguments.name=diamond 可以取代為顯式類型實參
diamond.can.be.replaced.with.explicit.type.arguments.quickfix=將 '<>' 取代為顯式類型實參
lambda.can.be.replaced.with.anonymous.name=lambda 可以取代為匿名類
lambda.can.be.replaced.with.anonymous.quickfix=將 lambda 取代為匿名類
method.ref.can.be.replaced.with.lambda.name=方法引用可以取代為 lambda
method.ref.can.be.replaced.with.lambda.quickfix=將方法引用取代為 lambda
try.statement.with.multiple.resources.name=可以拆分具有多個資源的 'try' 語句
try.statement.with.multiple.resources.quickfix=拆分具有多個資源的 'try' 語句
multi.catch.can.be.split.name=多 catch 可拆分為單獨的 catch 塊
multi.catch.can.be.split.quickfix=將多 catch 拆分為單獨的 'catch' 塊
assertion.can.be.if.name=斷言可以取代為 'if' 語句
assert.can.be.if.quickfix=將 'assert' 取代為 'if' 語句
if.can.be.assertion.name=語句可以取代為 'assert' 或 'Objects.requireNonNull'
if.can.be.assertion.replace.with.assertion.quickfix=將語句取代為 'assert' 語句
if.can.be.assertion.replace.with.objects.requirenonnull.quickfix=將語句取代為 'Objects.requireNonNull()'
single.statement.in.block.name=程式碼塊包含單條語句
single.statement.in.block.descriptor=''{0}'' 包含單條語句
single.statement.in.block.quickfix=從 ''{0}'' 語句中移除大括號
single.statement.in.block.family.quickfix=從語句中移除大括號
single.element.annotation.name=非規范化註解
single.element.annotation.quickfix=添加 'value='
single.element.annotation.family.quickfix=將註解擴展為標準形式
array.creation.without.new.keyword.name=創建不帶 'new' 表達式的陣列
array.creation.without.new.keyword.quickfix=添加 ''new {0}''
array.creation.without.new.keyword.family.quickfix=添加 'new' 表達式
malformed.set.up.tear.down.display.name='setUp()' 或 'tearDown()' 方法的格式錯誤 
malformed.set.up.tear.down.problem.descriptor='#ref()' 的簽名不正確 #loc
overly.long.lambda.display.name=過長的 lambda 表達式
overly.long.lambda.problem.descriptor=lambda 表達式過長 (# 非註釋源語句 = {0}) #loc
wait.notify.not.in.synchronized.context.display.name='wait()' 或 'notify()' 不在同步的上下文中
wait.notify.while.not.synchronized.on.problem.descriptor=''{0}'' 未同步時調用 <code>#ref</code> #loc
call.to.suspicious.string.method.display.name=調用可疑的 'String' 方法
call.to.suspicious.string.method.problem.descriptor=國際化上下文中調用的 <code>String.#ref()</code> #loc
unnecessary.string.escape.display.name=不必要的轉義字符
unnecessary.string.escape.problem.descriptor=<code>#ref</code> 進行了不必要的轉義
unnecessary.string.escape.quickfix=將不必要的轉義字符取代為未轉義字符

array.can.be.replaced.with.enum.values = 可以將陣列取代為枚舉值
array.can.be.replaced.with.enum.values.quickfix = 將陣列取代為 {0}.values()
array.can.be.replaced.with.enum.values.family.quickfix = 將陣列取代為 EnumType.values()

string.concatenation.replace.fix=取代為 StringBuilder
string.concatenation.replace.fix.name=將變數 ''{0}'' 從字串轉換為 {1}
string.concatenation.replace.fix.name.null.safe=將變數 ''{0}'' 從字串轉換為 {1} (null 安全)
string.concatenation.introduce.fix=引入 StringBuilder
string.concatenation.introduce.fix.name=引入新的 {1} 以更新變數 ''{0}''
string.concatenation.introduce.fix.name.null.safe=引入新的 {1} 以更新變數 ''{0}'' (null 安全)

ignored.class.names=忽略類(包括子類)
ignored.class.label=已忽略類(包括子類):
meta.annotation.without.runtime.retention=不含 '@Retention(RUNTIME)' 註解的測試註解
string.equals.char.sequence.display.name=使用 'CharSequence' 實參調用了 'String.equals()'
string.equals.char.sequence.problem.descriptor=使用 ''{0}'' 實參調用了 <code>String.equals()</code> #loc
object.equals.can.be.equality.display.name='equals()' 調用可以取代為 '=='
object.equals.can.be.equality.problem.descriptor=<code>#ref()</code> 可以取代為 '=='
not.object.equals.can.be.equality.problem.descriptor=<code>!#ref()</code> 可以取代為 '!='
redundant.explicit.var.type.display.name=可以省略局部變數類型
variable.type.can.be.explicit.display.name=變數類型可以是顯式的
assignment.or.return.of.field.with.mutable.type.display.name=具有可變類型的欄位的賦值或返回
assignment.of.field.with.mutable.type.problem.descriptor=賦值給參數 <code>#ref</code> 中的 {0} 欄位 ''{1}'' #loc
return.of.field.with.mutable.type.problem.descriptor=返回 {0} 欄位 <code>{1}</code> #loc
ignore.private.methods.option=忽略 private 方法中的賦值和返回值

inspection.redundant.string.operation.display.name=冗餘的 'String' 操作
inspection.redundant.string.remove.fix.name=移除冗餘的 ''{0}()'' 調用
inspection.redundant.string.fix.family.name=移除冗餘調用
inspection.redundant.string.call.message=<code>#ref()</code> 的調用冗餘 #loc
inspection.redundant.empty.string.argument.message=不必要的空字串實參
inspection.redundant.string.length.argument.message=不必要的字串長度實參
inspection.redundant.zero.argument.message=不必要的零實參
inspection.redundant.string.remove.argument.fix.name=移除實參
inspection.redundant.string.intern.on.constant.message=編譯時常量上 <code>#ref()</code> 的調用不必要 #loc
inspection.redundant.string.constructor.message=<code>#ref</code> 是冗餘的 #loc
inspection.redundant.string.replace.with.arg.fix.name=取代為實參
inspection.redundant.string.replace.with.empty.fix.name=取代為空字串
inspection.redundant.string.option.do.not.report.string.constructors=不報告字串構造函數
inspection.x.call.can.be.replaced.with.y=''{0}'' 調用可以取代為 ''{1}''

inspection.type.may.be.weakened.display.name=類型可能被削弱
inspection.type.may.be.weakened.problem.descriptor=變數 <code>#ref</code> 的類型可能被削弱為 {0} #loc
inspection.type.may.be.weakened.method.problem.descriptor=方法 <code>#ref()</code> 的返回類型可能被削弱為 {0} #loc
inspection.type.may.be.weakened.parameter.problem.descriptor=參數 <code>#ref</code> 的類型可能被削弱為 {0} #loc
inspection.type.may.be.weakened.field.problem.descriptor=欄位 <code>#ref</code> 的類型可能被削弱為 {0} #loc
inspection.type.may.be.weakened.quickfix=將類型削弱為 ''{0}''
inspection.type.may.be.weakened.ignore.option=在賦值中使用右手類型作為最弱的類型(&R)
inspection.type.may.be.weakened.collection.method.option=對方法調用實參使用參數化集合類型(&P)
inspection.type.may.be.weakened.do.not.weaken.to.object.option=不削弱為 'java.lang.Object'(&W)
inspection.type.may.be.weakened.add.stopper=作為停止類添加以減弱
inspection.type.may.be.weakened.add.stopper.single=添加 {0} 作為停止類以削弱
inspection.type.may.be.weakened.only.weaken.to.an.interface=僅削弱為接口
inspection.type.may.be.weakened.do.not.weaken.return.type=不削弱返回類型
inspection.type.may.be.weakened.add.stop.class.family=添加停止類
inspection.type.may.be.weakened.weaken.type.family=削弱類型
inspection.type.may.be.weakened.add.stop.class.selection.table=停止類
inspection.type.may.be.weakened.add.stop.class.selection.table.label=停止類:
inspection.type.may.be.weakened.add.stop.class.selection.popup=選擇停止類
inspection.type.may.be.weakened.do.not.weaken.inferred.variable.type=不建議削弱宣告為 'var' 的變數

inspection.commented.out.code.display.name=註釋掉的程式碼
inspection.commented.out.code.problem.descriptor=註釋掉的程式碼 ({0} {0, choice, 1#行|1<行})
commented.out.code.delete.quickfix=刪除註釋
commented.out.code.uncomment.quickfix=撤消程式碼註釋
inspection.commented.out.code.min.lines.options=最少程式碼行數

inspection.catch.ignores.exception.display.name=catch 塊可能會忽略異常
inspection.catch.ignores.exception.option.comments=當 'catch' 塊包含註釋時不發出警告
inspection.catch.ignores.exception.option.nonempty=當 'catch' 塊不為空時不發出警告
inspection.catch.ignores.exception.option.ignored.used=當名稱為 'ignore(d)' 的異常實際上未被忽略時不發出警告
inspection.catch.ignores.exception.used.message=已使用命名為 <code>#ref</code> 的 'catch' 參數 #loc
inspection.catch.ignores.exception.empty.message=空 <code>#ref</code> 塊 #loc
inspection.catch.ignores.exception.unused.message=未使用的 'catch' 參數 <code>#ref</code> #loc
inspection.catch.ignores.exception.vm.ignored.message=<code>#ref</code> 塊中可能會忽略 ''{0}'' 之類的意外虛擬機異常 #loc

inspection.redundant.collection.operation.display.name=冗餘的 'Collection' 操作
inspection.redundant.collection.operation.fix.family.name=簡化集合操作
inspection.redundant.collection.operation.problem.arraycopy=為複製陣列而創建的集合不必要
inspection.redundant.collection.removal.by.index.problem=按索引移除可以取代為按物件移除
inspection.redundant.collection.removal.by.index.fix=使用按物件移除
inspection.redundant.collection.unnecessary.contains.problem=不必要的 ''{0}()'' 檢查
inspection.redundant.collection.unnecessary.contains.fix=移除 ''{0}()'' 檢查

comments.as.content.option=註釋計為內容
copy.constructor.misses.field.display.name=複製缺少欄位的構造函數
copy.constructor.misses.field.problem.descriptor.1=複製未複製欄位 ''{0}'' 的構造函數
copy.constructor.misses.field.problem.descriptor.2=複製未複製欄位 ''{0}'' 和 ''{1}'' 的構造函數
copy.constructor.misses.field.problem.descriptor.3=複製未複製欄位 ''{0}''、''{1}'' 和 ''{2}'' 的構造函數
copy.constructor.misses.field.problem.descriptor.many=複製未複製 {0} 個欄位的構造函數

fix.add.argument.family.name=添加實參
fix.add.argument.name=添加 ''{0}'' 實參

inspection.constant.expression.display.name=可以計算常數表達式
inspection.constant.expression.message=常數表達式可以計算為 ''{0}''
inspection.constant.expression.fix.name=計算 ''{0}'' 的常量值
inspection.constant.expression.fix.name.with.value=將 ''{0}'' 取代為常量值 ''{1}''
inspection.constant.expression.fix.family.name=計算常量值

inspection.redundant.compare.call.display.name=冗餘的 'compare()' 方法調用
inspection.redundant.compare.call.fix.name=內聯 'compare()' 調用

inspection.simplifiable.if.statement.display.name='if' 語句可以取代為條件或布爾表達式
inspection.simplifiable.if.statement.message=If 語句可以取代為 ''{0}''
inspection.simplifiable.if.statement.option.dont.warn.on.ternary=不建議使用 '?:' 運算符
inspection.simplifiable.if.statement.fix.name=將 ''if else'' 取代為 ''{0}''
inspection.simplifiable.if.statement.fix.family.name=將 'if else' 取代為條件運算符

inspection.list.remove.in.loop.display.name=在迴圈中調用了 'List.remove()'
inspection.list.remove.in.loop.message=可以取代為 'List.subList().clear()'

implicit.default.charset.usage.fix.family.name=指定 UTF-8 字符集

inspection.redundant.class.call.display.name=冗餘的 'isInstance()' 或 'cast()' 調用
inspection.new.object.equality.display.name=使用 '==' 比較新物件
inspection.new.object.equality.message=使用 ''{0}'' 比較新物件
inspection.excessive.range.check.message=可以取代為 ''{0}''
inspection.excessive.range.check.fix.family.name=簡化過度範圍檢查
suspicious.integer.div.assignment.problem.descriptor=除法結果被截斷為整數
suspicious.integer.div.assignment.display.name=可疑的整數除法賦值
suspicious.integer.div.assignment.quickfix=轉換為 double
inspection.if.statement.missing.break.in.loop.name=在 'if' 條件下提前退出迴圈
inspection.if.statement.missing.break.in.loop.description=滿足條件後，可以終止迴圈
inspection.if.statement.missing.break.in.loop.quickfix=添加 'break'

inspection.case.mismatch.display.name='String' 操作中不符合的大小寫
inspection.case.mismatch.message.arg.is.lower=方法 ''{0}()'' 始終返回 {1}: 實參包含小寫符號，而限定符僅為大寫
inspection.case.mismatch.message.arg.is.upper=方法 ''{0}()'' 始終返回 {1}: 實參包含大寫符號，而限定符僅為小寫

inspection.suspicious.date.format.display.name=可疑的日期格式模式
inspection.suspicious.date.format.message.upper=使用了大寫 ''{0}'' ({1}) 模式: 預期可能為 ''{2}'' ({3})
inspection.suspicious.date.format.message.lower=使用了小寫 ''{0}'' ({1}) 模式: 預期可能為 ''{2}'' ({3})

fix.replace.map.with.flat.map.description='map()' 可以取代為 'flatMap()'

fix.eliminate.folded.if.present.name=移除折疊的 'ifPresent()' 調用
fix.eliminate.folded.if.present.description=可以消除折疊的 'ifPresent()' 調用

inspection.pattern.variable.can.be.used.display.name=可以使用模式變數
inspection.pattern.variable.can.be.used.message=變數 ''{0}'' 可以取代為模式變數
inspection.pattern.variable.can.be.used.fix.family.name=取代為模式變數
inspection.pattern.variable.can.be.used.fix.name=將 ''{0}'' 取代為模式變數
inspection.pattern.variable.can.be.used.existing.message=可以使用現有模式變數 ''{0}'' 代替 ''{1}''
inspection.pattern.variable.can.be.used.existing.fix.family.name=取代為現有模式變數
inspection.pattern.variable.can.be.used.existing.fix.name=將 ''{0}'' 取代為現有模式變數 ''{1}''

array.hash.code.fix.family.name=取代為隱式 'hashCode'
objects.hash.fix.family.name=使用 'Arrays.hashCode()' 包裝
unqualified.static.access.fix.family.name=限定靜態存取
replace.field.reference.fix.family.name=取代欄位引用
replace.field.reference.fix.text=將欄位引用取代為 {0}
replace.method.call.fix.family.name=取代方法調用
replace.method.call.fix.text=將方法調用取代為 {0}
delete.unnecessary.statement.fix.family.name=移除冗餘語句
increment.decrement.used.as.expression.fix.family.name=提取到分離語句中
use.of.properties.as.hashtable.fix.family.name=修復屬性存取
unnecessary.java.doc.link.fix.family.name=移除冗餘標記
swap.equals.fix.family.name=翻轉方法調用
remove.modifier.fix.family.name=移除修飾符
shift.out.of.range.fix.family.name=修復移位值
unnecessary.unicode.escape.fix.family.name=取代為字符
unnecessary.unicode.escape.fix.text=取代為換行字符
absolute.alignment.in.user.interface.fix.family.name=取代為常數
static.inheritance.fix.family.name=將繼承取代為限定引用
suspicious.to.array.call.fix.family.name=取代為正確陣列
incorrect.date.format.fix.family.name=修復不正確的日期格式
referencing.subclass.0.from.superclass.1.initializer.might.lead.to.class.loading.deadlock=從超類 {1} 初始值設定項引用子類 {0} 可能會導致類載入死鎖
collections.field.access.replaceable.by.method.call.fix.family.name=將 Collections.EMPTY_* 取代為調用
delete.catch.section.fix.family.name=刪除 catch 語句
make.field.static.final.fix.family.name=設為 static final
string.concatenation.in.format.call.fix.family.name=將串聯取代為實參
implicit.array.to.string.fix.family.name=將 Array.toString() 設為隱式
listener.may.use.adapter.fix.family.name=取代為適配器
unnecessary.temporary.object.fix.family.name=取代串聯
make.public.static.fix.family.name=設為 public/static
utility.class.with.public.constructor.fix.family.name=將構造函數設為 private
change.modifier.fix.family.name=更改修飾符
unnecessary.interface.modifiers.fix.family.name=移除不必要的修飾符
make.field.final.fix.family.name=設為 final
generate.to.string.quick.fix.family.name=生成
generate.to.string.quick.fix.text=生成 toString()
replace.instanceof.fix.family.name=取代 instanceOf 類型
replace.cast.fix.family.name=取代轉換類型
make.package.private.fix.family.name=設為 package-private
make.method.final.fix.family.name=將方法設為 'final'
replace.casted.literal.with.just.literal.fix.family.name=取代為 {0} 文字
char.used.in.arithmetic.content.cast.fix.family.name=插入轉換
ignore.parentheses.around.single.no.formal.type.lambda.parameter=忽略單個非正式類型 lambda 參數周圍的括號
double.checked.locking.fix.family.name=將欄位設為 volatile
declare.collection.as.interface.fix.family.name=削弱類型
string.equals.empty.string.fix.family.name=簡化空字串檢查
class.without.logger.annotations.tab=註解
class.without.logger.loggers.tab=記錄器
options.title.ignored.classes=已忽略的類
options.label.ignored.classes=已忽略的類:
add.catch.section.fix.family.name=添加 'catch' 子句
inspection.autocloseable.resource.ignored.methods.title=忽略從這些方法返回的 AutoCloseable 實例:
logger.initialized.with.foreign.class.fix.family.name=取代外類
extend.exception.fix.family.name=使類擴展 'Exception'
inspection.use.of.private.field.inner.classes.option=忽略來自內部類的存取
refused.bequest.fix.family.name=將調用插入 super 方法
mark.modules.as.loaded.together.fix.family.name=將模組標記為一起載入
mark.modules.as.loaded.together.fix.text=將 ''{0}'' 和 ''{1}'' 模組標記為一起載入
inspection.suspicious.package.private.access.description={0} 是 {1}，但在不同的模組 ''{2}'' 中宣告
ignore.class.fix.family.name=對這些類型忽略
create.default.branch.fix.family.name=插入 'default' 分支
unnecessary.fully.qualified.name.fix.family.name=取代完全限定名稱
return.of.collection.field.fix.family.name=使返回集合 'unmodifiable'
remove.redundant.substring.fix.family.name=移除冗餘的 'substring()' 調用
remove.redundant.string.fix.text=使用 ''{0}()'' 並移除冗餘的 ''{1}()'' 調用
use.equalsignorecase.for.case.insensitive.comparison=為不區分大小寫的比較使用 equalsIgnoreCase()
make.class.final.fix.family.name=將類設為 final
side.effects.method.ref.to.lambda.fix.family.name={0} (副作用)
encapsulate.variable.fix.family.name=封裝欄位
method.may.be.static.replaces.qualifiers.with.class.references.option=快速修復可將實例限定符取代為類引用
method.may.be.static.ignore.default.methods.option=忽略 'default' 方法
make.public.static.void.fix.family.name=修復修飾符
make.public.static.void.fix.name=將 ''{0}'' 的簽名更改為 ''{1}''
convert.empty.anonymous.to.new.fix.family.name=移除 '{}'
replace.method.ref.with.qualifier.fix.family.name=取代為限定符
replace.method.ref.with.qualifier.problem.method=方法引用可以取代為限定符
replace.method.ref.with.qualifier.problem.lambda=lambda 可以取代為調用限定符
add.throws.clause.fix.family.name=修復 'throws' 子句
prefer.empty.array.options.title=首選空陣列:
prefer.empty.array.options.mode.always=始終
prefer.empty.array.options.mode.by.level=根據語言級別
prefer.empty.array.options.mode.always.never=從不(首選預設大小的陣列)
too.broad.scope.inspection.fix.family.name=限縮範圍
replace.with.cast.fix.family.name=取代為轉換
replace.anonymous.with.lambda.body.fix.family.name=將調用取代為方法體
replace.with.method.reference.fix.family.name=將方法引用上的方法調用取代為相應的方法調用
replace.with.lambda.body.fix.family.name=將 lambda 上的方法調用取代為 lambda 體
inspection.trivial.functional.expression.usage.description=可以簡化方法調用
replace.with.var.fix.family.name=將顯式類型取代為 'var'
inspection.redundant.explicit.variable.type.description=可以省略局部變數的顯式類型
add.read.write.object.methods.fix.family.name=添加始終拋出異常的 'readObject()' 和 'writeObject()' 方法
add.read.write.object.methods.fix.text=添加始終拋出異常的 'writeObject()' 方法
add.read.write.object.methods.fix.text2=添加始終拋出異常的 'readObject()' 方法
replace.with.method.ref.fix.family.name=將 lambda 取代為方法引用
replace.with.method.ref.fix.name.may.change.semantics=將 lambda 取代為方法引用(可能更改語意)
qualify.call.fix.family.name=限定調用
replace.with.comparator.fix.family.name=使用 'Comparator' static 方法簡化比較器
inspection.comparator.combinators.description=可以取代為 'Comparator' 鏈
inspection.comparator.combinators.description2=可以取代為 ''{0}''
inspection.unnecessary.string.escape.report.char.literals.option=報告字符文字
inspection.method.call.in.loop.ignore.known.methods.option=忽略有副作用的已知方法
fix.data.provider.signature.family.name=修正資料提供程序方法簽名
allow.suppressions.fix.family.name=允許禁止
allow.suppressions.fix.text=允許這些禁止
remove.suppress.comment.fix.family.name=移除 //{0}
convert.to.j.unit.4.fix.family.name=將 JUnit 3 類轉換為 JUnit 4
throws.runtime.exception.fix.family.name=從 'throws' 子句中移除
move.exception.to.javadoc.fix.family.name=移動到 Javadoc '@throws'
create.package.info.java.family.name=創建 'package-info.java'
remove.loop.fix.family.name=移除迴圈
remove.call.fix.family.name=移除調用
inspection.meta.annotation.without.runtime.description={0} 應具有 @Retention(RetentionPolicy.RUNTIME)
inspection.refused.bequest.super.annotated.option=僅在通過以下方式註解 super 方法時報告:
inspection.empty.class.ignore.subclasses.option=忽略 {0} 的子類
inspection.test.method.without.assertions.exceptions.option=忽略宣告異常的測試方法
inspection.collection.must.have.initial.capacity.initializers.option=不報告欄位初始值設定項
utility.class.without.private.constructor.cant.generate.constructor.title=無法生成構造函數
utility.class.without.private.constructor.cant.generate.constructor.message=實用程序類具有實例化，將不會創建 private 構造函數
inspection.suspicious.package.private.access.problem={0} 重寫了來自在不同模組 ''{2}'' 中宣告的 {1} 的 package-private 方法
inspection.condition.covered.by.further.condition.descr=條件 ''{0}'' 由後面的{1, choice, 1#條件 ''''{2}''''|2#條件}覆蓋
inspection.parameterized.parameters.static.collection.display.name=沒有資料提供程序方法的參數化測試類
create.missing.switch.branch=創建缺少的 switch 分支 ''{0}''
create.missing.switch.branches=創建缺少的分支: {0}
redundant.as.list.for.iteration.problem=不必要的 'Arrays.asList()' 調用
redundant.as.list.for.iteration.fix.name=解開
assert.with.side.effects.call.mutates.expression=調用 ''{0}()'' 會改變 ''{1}''
assert.with.side.effects.call.mutates.field=調用 ''{0}()'' 會改變欄位 ''{1}''
inspection.comparator.combinators.fix.chain=取代為 'Comparator' 鏈
logger.initialized.with.foreign.options.title=選擇記錄器工廠類
test.without.assertion.options.choose.class=選擇斷言類
constant.on.lhs.of.comparison.options.item.left=左
constant.on.lhs.of.comparison.options.item.right=右
convert.junit3.test.fix.conflict.semantics=如果 {1} 轉換為 JUnit 4，方法調用 {0} 可能會更改語意
convert.junit3.test.fix.conflict.compile=如果 {1} 轉換為 JUnit 4，方法調用 {0} 將不編譯
convert.junit3.test.fix.conflict.compile.2=如果 {1} 轉換為 JUnit 4，引用 {0} 將不編譯
inspection.byte.array.output.stream.to.string.message=ByteArrayOutputStream 轉換低效

fix.data.provider.signature.fix.name=將方法簽名更改為 ''{0}''
fix.data.provider.create.method.fix.name=創建資料提供程序方法 '@Parameters public static Iterable<Object> parameters()'
fix.data.provider.signature.missing.method.problem=參數化測試類 <code>#ref</code> 缺少用 '@Parameters' 註解的資料提供程序方法
fix.data.provider.signature.incorrect.problem=資料提供程序方法 <code>#ref()</code> 的簽名不正確
fix.data.provider.multiple.methods.problem=類 <code>#ref</code> 中存在多個 @Parameters 資料提供程序方法
cloneable.class.without.clone.todo.message=TODO: 複製此處的可變狀態，這樣此克隆就不能更改初始克隆的內部
cloneable.class.without.clone.ignore.when.clone.called.option=如果調用超類的 clone() 方法需要 Cloneable，則忽略
trivial.if.option.ignore.assert.statements=忽略 'assert' 語句
if.may.be.factorized.problem.descriptor=<code>#ref</code> 可以因式分解 #loc
if.may.be.factorized.quickfix=取代為因式分解表達式
weaken.visibility.quickfix=削弱可見性
non.final.field.in.enum.quickfix.option=在快速修復不可用時忽略欄位
checkbox.ignore.null.on.wrong.side=<html>忽略錯誤側的 <code>null</code></html>
cyclic.class.dependency.ignore.in.same.file=忽略位於同一檔案中的類之間的迴圈
ambiguous.field.access.navigate.quickfix=導航到明顯存取過的{0, choice, 1#局部變數|2#參數|3#欄位}
unnecessary.record.modifier.display.name=不必要的 'record' 修飾符
unnecessary.redundant.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於記錄是冗餘的
logger.initialized.with.foreign.class.ignore.super.class.option=忽略使用超類初始化的記錄器
logger.initialized.with.foreign.class.ignore.non.public.classes.option=忽略非 public 類中的記錄器
dangling.javadoc.ignore.copyright.option=忽略 JavaDoc 格式的檔案頭註釋
package.in.multiple.modules.problem.descriptor2=軟體套件 ''{0}'' 具有模組 ''{1}'' 和 ''{2}'' 中的類
package.in.multiple.modules.problem.descriptor3=軟體套件 ''{0}'' 具有模組 ''{1}''、''{2}'' 和 ''{3}'' 中的類
package.in.multiple.modules.problem.descriptor.many=軟體套件 ''{0}'' 具有模組 ''{1}''、''{2}'' 以及其他 {3} 個模組中的類
use.isblank.to.check.if.string.is.whitespace.or.empty=使用 'isBlank()' 檢查字串是否為空或者僅包含空格
expression.may.be.factorized.display.name=表達式可以因式分解
create.missing.enum.switch.branches.fix.family.name=創建缺少的枚舉 switch 分支
create.missing.sealed.class.switch.branches.fix.family.name=創建缺少的密封類 switch 分支
inspection.case.mismatch.message.label.is.lower=無法存取 switch 分支: 標籤包含小寫符號，而選擇器僅支援大寫
inspection.case.mismatch.message.label.is.upper=無法存取 switch 分支: 標籤包含大寫符號，而選擇器僅支援小寫
for.can.be.foreach.fix.no.indexed=不報告索引的 'java.util.List' 迴圈
use.of.concrete.class.option.ignore.records=忽略 Java 記錄
create.null.branch.fix.family.name=插入 'null' 分支
instanceof.concrete.class.pattern.problem.descriptor=針對具體類 <code>#ref</code> 的模式測試 #loc
remove.annotation.parameter.0.fix.name=移除註解參數 ''{0}''
set.annotation.parameter.0.1.fix.name=將註解參數 {0} 設定為 \\"{1}\\"
class.with.too.many.dependents.interfaces.option=忽略接口
progress.text.analyzing.package.0=正在分析軟體套件 {0}
unnecessary.transient.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於 'static' 欄位是冗餘的"
`;

exports[`dev messages/JavaScriptBundle.properties 1`] = `
"# File Types
filetype.javascript.description=JavaScript
filetype.actionscript.description=ActionScript
filetype.typescript.description=TypeScript
filetype.typescript.jsx.description=TypeScript JSX
filetype.ecmascript6.description=ECMAScript 6
filetype.jsx.description=React JSX
filetype.jsx.display.name=React JSX
filetype.flow.description=Flow JS
filetype.flow.display.name=Flow JS
javascript.file=JavaScript 檔案
typescript.file=TypeScript 檔案
filetype.typescript.config.description=TypeScript 配置
filetype.typescript.config.display.name=TypeScript 配置

# Languages
javascript.language.simple.name=JavaScript
typescript.language.simple.name=TypeScript

# Language terms
javascript.language.term.function=函數
javascript.language.term.inner.function=內部函數
javascript.language.term.method=方法
javascript.language.term.constructor=構造函數
javascript.language.term.class=類
javascript.language.term.inner.class=內部類
javascript.language.term.interface=接口
javascript.language.term.inner.interface=內部接口
javascript.language.term.enum=枚舉
javascript.language.term.type.alias=類型別名
javascript.language.term.definition=定義
javascript.language.term.namespace=命名空間
javascript.language.term.parameter=參數
javascript.language.term.property=屬性
javascript.language.term.variable=變數
javascript.language.term.const=常數
javascript.language.term.const.field=常數欄位
javascript.language.term.readonly.field=唯讀欄位
javascript.language.term.local.variable=局部變數
javascript.language.term.local.const=局部常數
javascript.language.term.field=欄位
javascript.language.term.tag=標記
javascript.language.term.label=標籤
javascript.language.term.attribute=特性
javascript.language.term.decorator=裝飾器
javascript.language.term.attribute.value=特性值
javascript.language.term.package=軟體套件
javascript.language.term.module=模組
javascript.language.term.external.module.reference=外部模組引用
javascript.language.term.import.specifier=匯入說明符
javascript.language.term.export.specifier=匯出說明符
javascript.language.term.entity.name=實體名稱
javascript.language.term.jsdoc.tag=JSDoc 標籤
javascript.language.term.imported.default.binding=已匯入預設綁定
javascript.language.term.exported.default.binding=已匯出預設綁定
javascript.language.term.namespace.import=命名空間匯入
javascript.language.term.namespace.export=命名空間匯出
javascript.language.term.import.statement=import 語句
javascript.language.term.type.parameter=類型參數
javascript.language.term.destructuring.property=析構屬性
javascript.language.term.default.export=預設匯出
javascript.language.term.file=檔案
javascript.language.term.global=全域
javascript.language.term.xml.tag=xml 標籤

# Parser error messages
javascript.parser.message.expected.expression=應為表達式
javascript.parser.message.expected.xml.element=應為 XML 元素
javascript.parser.property.expected=應為屬性
javascript.parser.message.expected.lbrace=應為 {
javascript.parser.message.expected.at=應為 @
javascript.parser.message.expected.rbrace=應為 }
javascript.parser.message.expected.identifier.string.literal.or.numeric.literal=應為關鍵字、字串文字或數字文字
javascript.parser.message.expected.colon=應為 :
javascript.parser.message.expected.colon.or.comma=應為 : 或 ,
javascript.parser.message.expected.semicolon=應為 ;
javascript.parser.message.expected.lbrace.or.semicolon=應為 { 或 ;
javascript.parser.message.expected.rbracket=應為 ]
javascript.parser.message.expected.lparen=應為 (
javascript.parser.message.expected.rparen=應為 )
javascript.parser.message.expected.name=應為名稱
javascript.parser.message.expected.comma.or.rparen=應為 , 或 )
javascript.parser.message.expected.function.name=應為函數名稱
javascript.parser.message.expected.formal.parameter.name=應為參數名稱
javascript.parser.message.expected.statement=應為語句
javascript.parser.message.expected.parameter.name=應為參數名稱
javascript.parser.message.expected.property.name=應為屬性名稱
javascript.parser.message.expected.case.or.default=應為 'case' 或 'default'
javascript.parser.message.expected.forloop.left.hand.side.expression.or.variable.declaration='in' 前面應為左側表達式或變數宣告
javascript.parser.message.expected.forloop.in.or.semicolon=應為 'in' 或 ;
javascript.parser.message.expected.while.keyword=應為 'while'
javascript.parser.message.expected.comma=應為 ,
javascript.parser.message.expected.comma.or.rbrace=應為 , 或 }
javascript.parser.message.expected.variable.name=應為變數名稱
javascript.parser.message.expected.mult.or.lbrace=應為 * 或 {
javascript.parser.message.missing.rbrace=缺少 }
javascript.parser.message.missing.or_rbrace=缺少 |}
javascript.parser.message.missing.attribute.name=缺少特性名稱
javascript.parser.message.unexpected.end.of.file=意外的檔案結尾
javascript.parser.message.expected.type.name=應為類型名稱
javascript.parser.message.unclosed.string.literal=未閉合的字串文字
javascript.parser.message.unclosed.comment=未閉合註釋
javascript.parser.message.are.not.supported.by.dialect=當前 JavaScript 版本不支持 {0}
javascript.parser.message.expected.from=應為 'from'
javascript.parser.message.expected.typename=應為類型名稱
javascript.parser.message.expected.typename.or.*=* 應為 * 或類型名稱
javascript.parser.message.expected.name.or.lbrace=應為軟體套件名稱或 {
javascript.parser.message.expected.declaration=應為宣告
javascript.parser.message.expected.namespace=應為 'namespace'
javascript.parser.message.expected.string.literal=應為字串文字
javascript.parser.message.expected.xml=應為 XML 上下文關鍵字
javascript.parser.message.expected.equal=應為 =
javascript.parser.message.expected.identifier.lbrace.or.lbracket=應為關鍵字、{ 或 [
javascript.parser.message.expected.eqgt=應為 =>
javascript.parser.message.expected.identifier=應為關鍵字
javascript.parser.message.expected.instanceof=應為 'instanceof'
javascript.parser.message.expected.in=應為 'in'
javascript.parser.message.expected.value=應為值
javascript.parser.message.expected.identifier.or.value=應為關鍵字或值
javascript.parser.message.expected.as=應為 'as'
javascript.parser.message.expected.identifier.string.literal.or.lbrace=應為關鍵字、字串文字或 {
javascript.parser.message.expected.import.value=應為匯入綁定或說明符
javascript.parser.message.expected.import.specifier=應為匯入說明符
javascript.parser.message.expected.heredoc.closing.identifier=應為 heredoc 結束關鍵字
javascript.parser.message.expected.type.member=應為類型成員
javascript.parser.message.expected.tuple.comma.or.rbracket=應為 , 或 ]
javascript.parser.message.expected.target=僅接受 'target' 作為要新建的元屬性
javascript.parser.message.expected.meta=僅接受 'meta' 作為要匯入的元屬性
javascript.parser.message.expected.declare=應為 'declare'
javascript.parser.message.expected.exports=應為 'exports'
javascript.parser.message.expected.checks=應為 'checks'
javascript.parser.message.expected.type.keyword=應為 'type'
javascript.parser.message.expected.type=應為類型
javascript.parser.message.expected.question=應為 ?
javascript.parser.message.expected.class=應為 'class'

# Validation messages
javascript.validation.message.conflicting.definition.was.found.with.the.same.name=在命名空間 {1} 中發現衝突性的繼承宣告 {0}
javascript.validation.message.duplicate.declaration=重複宣告
javascript.validation.message.duplicate.declaration.fix.remove=移除類型
javascript.validation.message.redundant.type=顯式類型實參 {0} 可以取代為 {1}
javascript.validation.message.redundant.type.remove=可以移除顯式類型實參 {0}
javascript.validation.message.duplicate.export.declaration=匯出宣告與已匯出的宣告 ''{0}'' 相衝突
javascript.validation.message.duplicate.default.export.declaration=一個模組不能有多個預設匯出
javascript.validation.message.duplicate.default.export.in.module=預設匯出只能在 ECMAScript-style 模組中使用
javascript.validation.message.duplicate.declaration.fix.text=導航到上一個宣告 ''{0}''
javascript.validation.message.duplicate.declaration.fix.text.no.name=導航到上一個宣告
javascript.validation.message.redeclaration.of.block.scope=無法重新宣告塊範圍變數
javascript.validation.message.redeclaration.of.block.scope.in.scope.of.var=塊範圍變數不能與同一塊範圍中的\\"var\\"變數或參數使用相同的名稱
javascript.validation.message.redeclaration.of.var.in.scope.of.block.scope=\\"var\\" 變數不能與其可見性範圍內的塊範圍變數使用相同的名稱
javascript.validation.message.assignment.to.const=嘗試賦值給常數或唯讀變數
javascript.validation.message.assignment.to.const.fix.replace=取代為 let
javascript.validation.message.assignment.to.const.fix.remove.readonly=移除唯讀修飾符
javascript.validation.message.must.be.lvalue={0} 中的左側無效
javascript.validation.message.const.variable.without.initializer='const' 變數不包含初始值設定項。以後無法賦予有意義的值。
javascript.validation.message.constructor.field.not.allowed=類可能沒有名為 'constructor' 的非 static 欄位
es6.validation.message.const.variable.without.initializer=不允許使用無初始值設定項的 'const' 變數
javascript.validation.message.continue.without.target=無法確定 'continue' 的目標
javascript.validation.message.break.without.target=無法確定 'break' 的目標
javascript.validation.message.continue.outside.loop='continue' 在迴圈語句外部
javascript.validation.message.return.outside.function.definition='return' 在函數定義外部
javascript.validation.message.duplicate.label=重複標籤
javascript.validation.message.extend.multiple.classes=類不能擴展多個類
javascript.validation.message.extend.final.class=無法擴展 final 類 ''{0}''
javascript.validation.message.identifier.not.allowed.in.strict.mode=在嚴格模式下不能將 ''{0}'' 用作關鍵字
javascript.validation.message.for.await.top.level=使用了頂層 'for await'
javascript.validation.message.for.await.no.async.context='for await' 只能在 'async' 函數中使用
typescript.validation.message.invalid.modifier.cannot.be.here=修飾符 {0} 不能出現在此處
typescript.validation.message.duplicate.modifier=已看到修飾符 {0}
typescript.validation.message.duplicate.modifier2=已看到可存取性修飾符
typescript.validation.message.abstract.cannot.be.used=''{0}'' 修飾符不能與 ''abstract''修飾符結合使用
typescript.validation.message.abstract.class.be.created=無法創建 abstract 類 ''{0}'' 的實例
typescript.validation.message.abstract.member.access.super=無法通過 super 表達式存取 abstract 方法 ''{0}''。
typescript.validation.message.abstract.cannot.have.body=方法不能具有實作，因為它被標記為 'abstract'
typescript.validation.message.abstract.overload=多載簽名必須全部為 abstract 或非 abstract。
typescript.validation.message.constructor.cannot.be.abstract=構造函數不能為 'abstract'
typescript.validation.message.function.implementation.missing=缺少函數實作或此宣告之後未緊隨函數實作
typescript.validation.message.abstract.class.should.be=abstract 方法只能出現在 abstract 類中
typescript.validation.module.reference.with.extension=外部模組引用不能以擴展結束
typescript.validation.class.extend.not.constructor.type=類型 ''{0}'' 不是構造函數類型
typescript.validation.class.extend.no.type.arguments.type=沒有任何基類構造函數具有指定數量的類型實參
typescript.validation.class.extend.many.constructors=基類構造函數必須具有相同的返回類型
typescript.validation.class.extend.cycled.definition=迴圈類定義
typescript.validation.class.extend.constructor.return.not.class=基類構造函數返回類型 ''{0}'' 不是類或接口類型。
javascript.validation.generators.yield.not.iterable=表達式類型沒有定義 [Symbol.iterator] 或 [Symbol.asyncIterator]
javascript.validation.generators.yield.not.assignable.to.return=類型 ''{1}'' 不可分配給類型 ''{0}''
typescript.validation.generators.incorrect.type.annotation=發生器不能有 ''{0}'' 類型註解
typescript.validation.async.incorrect.type.annotation=異步函數不能有 ''{0}'' 類型註解
typescript.validation.generators.incorrect.type.annotation.iterable=類型 ''{0}'' 不可分配給類型 ''{1}''。
typescript.validation.generators.overload=多載簽名無法被宣告為生成器
typescript.validation.generators.ambient=環境上下文中不允許使用生成器
typescript.validation.generators.no.yield=生成器隱式具有類型 'IterableIterator<any>'，因為它不產生任何值。請考慮提供返回類型。
typescript.validation.generators.async.no.yield=生成器隱式具有類型 'AsyncIterableIterator<any>'，因為它不產生任何值。請考慮提供返回類型。
typescript.validation.cannot.find.best.common.type=無法從用法推斷類型實參


# Surround with names
javascript.surround.with.do.while=do / while
javascript.surround.with.for=for
javascript.surround.with.if=if
javascript.surround.with.if.else=if / else
javascript.surround.with.if.cond=if (cond)
javascript.surround.with.if.else.cond=if (cond) / else
javascript.surround.with.parenthesis=(expr)
javascript.surround.with.not.parenthesis=!(expr)
javascript.surround.with.cast=Type(expr)
javascript.surround.with.try.catch=try / catch
javascript.surround.with.try.finally=try / finally
javascript.surround.with.try.catch.finally=try / catch / finally
javascript.surround.with.while=while
javascript.surround.with.with=with
javascript.surround.with.function=函數
javascript.surround.with.function.expression=函數表達式
javascript.surround.with.object.literal=物件文字

# Introduce variable
javascript.introduce.variable.title=提取變數
javascript.introduce.variable.title.local=引入局部變數
javascript.introduce.variable.error.no.expression.selected=無法引入變數。\\\\n選定內容不構成表達式。
javascript.introduce.variable.error.expression.has.void.type=無法引入變數。\\\\n選定的表達式類型無效。
javascript.introduce.variable.name.prompt=名稱(&N):
javascript.introduce.variable.replace.all.occurrences=取代所有符合項(找到 {0} 個匹配項)(&A)
javascript.introduce.variable.invalid.name=請輸入有效名稱。
javascript.introduce.element.already.exists=範圍中已存在同名的 {0}。
javascript.introduce.variable.arrow.function.parameter.referenced=無法引入。\\\\n選定內容包含對箭頭函數參數的引用
javascript.introduce.variable.arrow.await.referenced=無法引入。\\\\n選定內容包含 await 表達式
javascript.introduce.variable.xml.embedded=無法在嵌入式表達式中引入變數
javascript.introduce.incorrect.context=無法引入變數。\\\\n選定內容包含對\\"this\\"的引用
javascript.introduce.field.title=引入欄位
javascript.introduce.field.error.no.expression.selected=無法引入欄位。\\\\n選定內容不構成表達式。
javascript.introduce.field.error.expression.has.void.type=無法引入變數。\\\\n選定的表達式類型無效。
javascript.introduce.field.error.no.enclosing.class=無法引入欄位。\\\\n沒有封閉類。
javascript.introduce.field.make.readonly=設為唯讀(&R)
javascript.introduce.field.initialize.in.scope=初始化在(&I):
javascript.introduce.field.visibility=可見性(&V):
javascript.introduce.field.keyboard.hint=按 {0} 用於鍵盤快捷鍵
javascript.introduce.field.before.super.call=無法引入欄位。\\\\n在\\"super\\"調用前無法存取\\"this\\"。
javascript.introduce.field.current.method=當前方法
javascript.introduce.field.field.declaration=欄位宣告
javascript.introduce.field.constructor=構造函數
javascript.introduce.constant.title=引入常數
javascript.introduce.constant.error.no.expression.selected=無法引入常數。\\\\n選定內容不構成表達式。
javascript.introduce.constant.error.expression.has.void.type=無法引入常數。\\\\n選定的表達式類型無效。
javascript.introduce.constant.error.not.constant.expression.selected=無法引入常數。\\\\n選定內容不是常數表達式。
javascript.introduce.parameter.title=提取參數
javascript.introduce.parameter.error.no.expression.selected=無法引入參數。\\\\n選定內容不構成表達式。
javascript.introduce.parameter.error.no.containing.function=無法引入參數。\\\\n找不到要使用的包含函數。
javascript.introduce.parameter.error.expression.has.void.type=無法引入參數。\\\\n選定的表達式類型無效。
javascript.introduce.parameter.error.not.async.context=無法為包含 'await' 的表達式引入參數。\\\\n並非所有用法都包含在異步函數中
javascript.introduce.parameter.error.target.not.async=無法為包含 'await' 的表達式引入參數。\\\\n目標函數不是異步函數
javascript.introduce.parameter.error.yield=無法為包含 'yield 的表達式引入參數。
javascript.introduce.parameter.generate.jsdoc=生成 JSDoc
javascript.introduce.parameter.optional.parameter=可選參數
javascript.introduce.throw.expressions.unsupported=無法調用重構。\\\\n\\"Extract\\"重構中當前不支持 Throw 表達式。
javascript.introduce.breaks.operator.precedence=無法調用重構。\\\\n通過引入將更改表達式中的運算符優先級。
javascript.introduce.constant.in.es5=無法調用重構。\\\\n無法在 ECMAScript 3 或 ECMAScript 5 程式碼中引入常數。
javascript.introduce.in.embedded.expression=無法調用重構。\\\\n無法在嵌入式表達式中引入
javascript.introduce.variable.make.constant=設為常數
list.item.class.field=類欄位
list.item.global.or.module.constant=全域或模組常數
list.item.local.constant=局部常數

# Highlighting categories
javascript.keyword=關鍵字
javascript.string=字串
javascript.number=數字
javascript.linecomment=行註釋
javascript.doccomment=文檔註釋
javascript.blockcomment=塊註釋
javascript.regexp=正則表達式
javascript.operation=運算
javascript.parens=括號
javascript.brackets=中括號
javascript.braces=大括號
javascript.semicolon=分號
javascript.badcharacter=錯誤字符
jsdoc.text=JSDoc 文本
jsdoc.tag=JSDoc 標籤
jsdoc.tag.value=JSDoc 標記值
jsdoc.type=JSDoc 類型
javascript.doctag=文檔標籤
javascript.doctagvalue=文檔標記值
javascript.valid.string.escape=有效字串轉義
javascript.invalid.string.escape=無效字串轉義
javascript.comma=逗號
javascript.dot=點

# Errors with intentions
javascript.unresolved.function.name.message=未解析的函數或方法 {0}() #loc
javascript.unresolved.variable.name.message=未解析的變數 {0} #loc
javascript.unresolved.variable.null.qualifier.message=''{0}'' 的限定符可能為 null #loc
javascript.unresolved.variable.undefined.qualifier.message=''{0}'' 的限定符可能未定義 #loc
javascript.unresolved.variable.null.or.undefined.qualifier.message=''{0}'' 的限定符可能為 null 或 undefined #loc
javascript.unresolved.type.name.message=未解析的類型 {0} #loc
javascript.unresolved.circle.definition=匯入的圓定義
javascript.missing.read.property=未解析的讀取屬性 #loc
javascript.missing.write.property=未解析的寫入屬性 #loc
javascript.unresolved.variable.or.type.name.message=未解析的變數或類型 {0} #loc
javascript.unresolved.variable.or.type.name.message2=未解析的變數或類型 {0}
javascript.unresolved.symbol.message=未解析的符號
javascript.unresolved.file=找不到檔案 {0}
javascript.unknown.metadata.tag=未知元資料標籤
javascript.unknown.metadata.attribute=未知元資料特性
javascript.undeclared.variable.name.message=隱式宣告變數 {0} #loc
javascript.create.function.intention.name=創建函數 ''{0}''
javascript.create.variable.intention.name=創建變數 ''{0}''
javascript.create.constant.intention.name=創建常數 ''{0}''
javascript.declare.variable.intention.name=為 ''{1}'' 插入 {0} 宣告
javascript.declare.variable.intention.family.name=插入 var 宣告
javascript.declare.variable.in.previous.var.statement.intention.name=將 ''{0}'' 的 var 宣告插入之前的 var 語句
javascript.declare.variable.in.previous.var.statement.intention.family=將 var 宣告插入之前的 var 語句
javascript.create.field.intention.name=創建欄位 ''{0}''
javascript.create.constant.field.intention.name=創建常數欄位 ''{0}''
javascript.create.method.intention.name=創建方法 ''{0}''
javascript.create.property.intention.name=創建屬性 ''{0}''
javascript.create.function.property.intention.name=創建函數屬性 ''{0}''
javascript.create.constructor.intention.name=在 ''{0}'' 類中創建構造函數
javascript.create.get.property.intention.name=創建 ''get'' 屬性 ''{0}''
javascript.create.set.property.intention.name=創建 ''set'' 屬性 ''{0}''
javascript.create.function.intention.family=創建 JavaScript 函數或方法
javascript.create.variable.intention.family=創建 JavaScript 變數或屬性
javascript.intention.create.getter.setter=為 ''{0}'' 創建 getter 和 setter
javascript.intention.create.getter.setter.desc=創建 getter 和 setter
javascript.intention.create.setter=為 ''{0}'' 創建 setter
javascript.intention.create.setter.desc=創建 setter
javascript.intention.create.getter=為 ''{0}'' 創建 getter
javascript.intention.create.getter.desc=創建 getter
create.mobile.view=創建檢視 ''{0}''
javascript.rename.reference.intention.name=重命名引用
typescript.rename.javascript.references=在 JavaScript 檔案中搜尋(&J)
typescript.rename.dynamic.references=搜尋動態引用 (&D)
js.usage.type.call=函數調用中的用法
js.anonymous.to.named.function=匿名函數轉換為命名函數
js.convert.to.named.function=轉換為命名函數
js.convert.to.named.function.to.class.method=轉換為類方法
js.convert.to.arrow.function=轉換為箭頭函數
js.add.braces.to.arrow.function=向箭頭函數中添加大括號
js.inspection.function.expression.is.used.instead.of.arrow=使用了函數表達式而不是箭頭函數
js.arrow.function.braces.can.be.removed.key=箭頭函數體周圍的大括號冗餘
js.arrow.function.braces.can.be.removed.problem.description=可以移除箭頭函數體周圍的大括號
js.arrow.function.braces.can.be.removed.fix.family.name=移除箭頭函數體周圍的大括號
js.convert.to.anonymous.function.family.name=箭頭函數轉換為匿名函數
js.convert.to.anonymous.function=轉換為匿名函數
js.named.to.anonymous.family.name=轉換為函數表達式
js.named.to.function.expression.text = 轉換為包含變數的函數表達式
js.named.to.function.hoisting.conflict.text=函數在宣告之前使用。轉換為變數後，將中斷使用
js.named.to.arrow.text = 轉換為含有 {0} 的箭頭函數
js.split.into.multiple.declarations=拆分為多個宣告
js.remove.digit.separators=移除數字分隔符
js.copy.qualified.to.clipboard=將限定名稱複製到剪貼簿
js.iterate=使用 'for..of' 進行迭代
js.iterate.async=使用 'for await..of' 進行迭代
js.separate.digits=分隔數字
js.separate.nibbles=分隔半位元組
js.separate.bytes=分隔位元組
js.separate.words=分隔 16 位單詞
js.separate.thousands=分隔千位數
js.separate.thousands.in.integer.part=將千位數分隔成整數
js.split.declarations=拆分宣告
js.replace.string.with.es6.template=取代為模板字串
js.replace.string.concatenation.with.es6.template.inspection.name=已使用字串串聯而不是模板文字
js.replace.string.concatenation.with.es6.template.fix.text=取代為模板字串
js.string.template.line.separators.visible=轉換為可見行分隔符
js.string.template.line.separators.multispan=轉換為多行字串模板
js.string.template.line.separators.visible.family.name=轉換模板字串以使用可見行分隔符
js.string.template.line.separators.multispan.family.name=轉換為多行字串模板
js.convert.var.to.let.text=轉換為 let
js.convert.var.to.const.text=轉換為 const
js.convert.var.to.let.or.const=轉換為 let/const
js.convert.var.to.let.or.const.family.name=將 var 轉換為 let/const
js.convert.var.to.let.or.const.inspection.text=已使用 'var' 而不是 'let' 或 'const'
js.convert.let.to.const.inspection.text=已使用 'let' 而不是 'const'
js.convert.var.to.let.or.const.inspection.conservative.option=使用“全部修復”操作保守地轉換 var
js.convert.var.to.let.or.const.inspection.conservative.option.description=在第一次使用變數之前，宣告可能會移至函數器頂部。\\\\n要在使用“全部修復”操作時禁用此行為，請選中“保守轉換 var”選項。
js.convert.require.into.es6.import.text=將 require() 轉換為 import
js.convert.require.into.es6.import.family.name=將 require() 轉換為 import
js.convert.require.into.es6.import.inspection.text=使用了 'require()' 而不是 'import'
js.convert.require.into.es6.import.inspection.withConditional.option=使用“全部修復”操作在內部範圍內轉換 require()
js.convert.require.into.es6.import.inspection.withConditional.option.description=在內部範圍內轉換 require()（例如 'if' 語句或內部函數）
js.convert.module.exports.into.es6.export.text=轉換為 export
js.convert.module.exports.into.es6.export.family.name=轉換為 export
js.convert.module.exports.into.es6.export.inspection.text=使用了 'module.exports' 而不是 'export'
js.convert.for.in.to.for.of.text=將 'for..in' 轉換為 'for..of'
js.convert.for.in.to.for.of.family.name=將 'for..in' 轉換為 'for..of'
js.convert.for.in.to.for.of.inspection.text=使用了 'for..in' 而不是 'for..of'
js.convert.indexed.for.to.for.of.text=將帶索引的 'for' 轉換為 'for..of'
js.convert.indexed.for.to.for.of.family.name=將帶索引的 'for' 轉換為 'for..of'
js.convert.indexed.for.to.for.of.inspection.text=已使用索引的 'for' 而不是 'for..of'
js.convert.for.each.to.for.of.intention.family=將 'forEach' 取代為 'for..of' 迴圈
js.convert.for.each.to.indexed.intention.family=將 'forEach' 取代為索引的 'for' 迴圈
js.convert.for.of.to.indexed.intention.family=將 'for..of' 取代為索引的 'for' 迴圈
js.convert.map.to.for.of.intention.family=將 'map' 陣列調用取代為 'for..of' 迴圈
js.convert.indexed.for.to.foreach.intention.family=將索引的 'for' 轉換為 'forEach' 調用
js.add.then.fix=添加 '.then()'
js.quote.unquote.intention.plural={0} 屬性名稱
js.quote.unquote.intention.singular={0} 屬性名稱
js.quote.unquote.intention.quote=引用
js.quote.unquote.intention.quote.family=使用引號包裝屬性名稱
js.quote.unquote.intention.unquote=取消引用
js.quote.unquote.intention.unquote.family=移除屬性名稱中的引號
js.property.to.indexer.intention=取代為索引器存取
js.indexer.to.property.intention=取代為屬性存取
js.join.vars.intention=加入後續變數宣告
js.infer.parameter.types.intention=從用法中推斷參數類型
js.infer.parameter.types.intention.jsdoc=從用法中推斷 JSDoc 參數類型
js.infer.parameter.types.intention.failure.title=無法推斷類型
js.infer.parameter.types.intention.progress.text=正在推斷類型
js.infer.parameter.types.intention.failure.text=無法從用法中推斷類型
js.infer.parameter.types.intention.failure.readonly.text=無法從用法中推斷類型：為唯讀檔案

# Move module members
es6.move.module.members.refactoring.name=移動模組成員
es6.move.module.members.table.title=要移動的成員
es6.move.module.members.refactoring.create.file=創建檔案
es6.move.module.members.refactoring.file.does.not.exist=檔案 {0} 不存在
es6.move.module.members.refactoring.create.file.message=檔案 {0} 不存在。\\\\n要創建嗎?
es6.move.module.members.refactoring.dialog.error.no.script.tag=目標檔案不包含腳本標籤
es6.move.module.members.refactoring.dialog.error.invalid.file.name=目標文件名在此操作系統中無效
es6.move.module.members.refactoring.dialog.error.no.selected.items=沒有要移動的選定成員
es6.move.module.members.refactoring.dialog.error.incorrect.module=目標模組不正確
es6.move.module.members.refactoring.dialog.error.modules.same=源模組和目標模組應不同
es6.move.module.members.refactoring.dialog.move.member.to=成員移動至
es6.move.module.members.refactoring.dialog.field.from=從:
es6.move.module.members.refactoring.dialog.field.to=到:
es6.move.module.members.references.unresolved.import.message=選擇的 {0} 引用未解析匯入 {1}
es6.move.module.members.references.local.message=選擇的 {0} 引用非匯出 {1}
es6.move.module.members.has.local.usage.message=檔案 {1} 中使用未匯出的 {0}
es6.move.module.members.non.es6.module.usage=在非 ES6 模組的檔案 {1} 中使用 {0}
es6.move.module.members.destination.not.es6=目標檔案 {0} 不是 ES6 模組
es6.move.module.members.cannot.detect.js.language=目標檔案不是 JS 檔案
es6.move.module.members.destination.contains.default.export=目標模組包含預設匯出
es6.move.module.members.destination.does.not.support.jsx={0} 包含 JSX 標籤，但目標語言不支持這些標籤
es6.move.module.members.syntax.errors=移動 {0} 將引入語法錯誤，因為目標語言不同於源語言
es6.move.module.members.incompatible.language=目標模組具有不相容的語言
dialog.title.move.members=移動成員

js.pull.up.will.be.made.abstract=非 abstract {0} 將被設為 abstract
es6.extract.super.destination.label=目標檔案 (&D)：
es6.extract.super.members.in.interface=新接口中的成員
es6.extract.super.members.in.superclass=新超類中的成員
es6.extract.super.overload.declaration.without.implementation.conflict=類中不允許沒有實作的多載宣告 {0}
es6.extract.super.different.name.expected=應為不同名稱

# Unit testing
js.testing.inspection.group.name=單元測試
js.testing.highlight.line=在測試程式碼中高亮顯示失敗的行
rc.environmentVariables.label=環境變數(&E)：
rc.testRunScope.all=所有測試(&L)
rc.testRunScope.testFile=測試檔案 (&F)
rc.testRunScope.suite=套件
rc.testRunScope.test=測試(&T)
rc.nodeOptions.label=節點選項 (&O)：
rc.workingDirectory.label=工作目錄(&W):
rc.workingDirectory.browseDialogTitle=選擇工作目錄
rc.testOrSuiteScope.suite.title=編輯套件名稱
rc.testOrSuiteScope.suite.label=套件名稱:
rc.testOrSuiteScope.test.title=編輯測試名稱
rc.testOrSuiteScope.test.label=測試名稱：
rc.testOrSuiteScope.emptyTest=空測試名稱
rc.testRunScope.testFile.label=測試檔案：
rc.testRunScope.testFile.browseTitle=選擇測試檔案

# Unit testing: Jest
jest.snapshot.update.rc.name=更新 {0} 的快照
jest.snapshot.update.single.test.text=<link>點擊以更新 ''{0}'' 的快照</link>
jest.snapshot.update.test.file.text=<link>點擊以更新 {0} 中失敗的快照</link>
jest.snapshot.update.all.tests.text=<link>點擊以更新所有失敗的快照</link>
jest.rc.configurationFile.label=配置檔案(&C):
jest.rc.configurationFile.title=選擇 Jest 配置檔案
jest.rc.jestPackageField.label=Jest 軟體套件(&J)：
jest.rc.jestOptions.label=Jest 選項：
jest.rc.jestOptions.emptyText=CLI 選項，例如 --watch 或 --env=jsdom
jest.coverage.notification.title=Jest 覆蓋率
jest.coverage.directory.not.found.notification.content=無法從 Jest 配置中讀取 coverageDirectory 選項
jest.coverage.cannot.find.lcov.info.notification.content=無法顯示 Jest 覆蓋率: 找不到 {0}。

# Unit testing: Protractor
protractor.rc.configurationFile.label=配置檔案(&C):
protractor.rc.configurationFile.title=選擇 Protractor 配置檔案
protractor.rc.protractorPackage.label=Protractor 軟體套件(&P)：
protractor.rc.protractorOptions.label=Protractor 選項 (&O)：
protractor.rc.protractorOptions.emptyText=CLI 選項，例如 --browser 或 --rootElement

# Node.js
node.js.inspection.group.name=Node.js
node.js.missing.require=缺少 require() 語句
node.js.unresolved.api=未解析的 Node.js API
node.js.invalid.node=該專案使用了無效的 Node.js 路徑。<br>它已更新為使用 {0} 中的 Node.js。
node.js.downloading=正在下載 Node.js {0}
node.js.interpreters=Node.js 解釋器
node.js.set.project.interpreter.action=設定為專案解釋器
node.js.add.interpreter.action=添加{0}…
notification.title.cannot.enable.node.js.coding.assistance=無法啟用 Node.js 編碼輔助
notification.title.cannot.download.types.node=無法下載 @types/node
status.text.add.interpreter.with=使用 {0} 添加解釋器
status.text.no.interpreters.added=未添加解釋器
popup.content.cannot.edit.selected.node.js.interpreter=無法編輯選定的 Node.js 解釋器
node.no.interpreter=無解釋器
node.interpreter.not.found=找不到 {0}
no.executable.found.in.path=在 {0, choice, 0#%PATH%|1#$PATH} 中未找到可執行檔案
merged.process.output.text={0}{2, choice, 0#\\\\n\\\\n標準錯誤:\\\\n{1}|1#}{4, choice, 0#\\\\n\\\\n標準輸出:\\\\n{3}|1#}\\\\n\\\\n{5}
node.interpreter.download=下載 Node.js
node.interpreter.project_node.reference.name=專案
node.interpreter.node_from_path.reference.name=node

# Inspections
js.inspection.group.name=常規
typescript.inspection.group.name=TypeScript
js.inspection.bitwise.group.name=按位運算問題
js.code.style.issues.group.name=程式碼樣式問題
js.probable.bugs.group.name=可能的錯誤
js.annotator.inspection.name=未遵循 ECMAScript 規範
js.inspection.convert.to.es6.group.name=ES2015 遷移協助
js.inspection.switch.group.name=切換語句問題
js.inspection.async.group.name=Async 程式碼和 promise
js.function.metrics.group.name=函數指標
js.validity.issues.group.name=有效性問題
js.imports.dependencies.group.name=匯入和依賴關係
js.unused.symbols.group.name=未使用的符號
js.unwanted.symbols.group.name=可能不合需要的程式碼結構
js.assignment.issues.group.name=賦值問題
js.potentially.invalid.usage.of.this.inspection.name=從閉包對 'this' 的引用可能無效
js.potentially.invalid.usage.of.class.this.inspection.name=從閉包對類中 'this' 的引用可能無效
js.potentially.invalid.target.of.indexed.property.access.inspection.name=索引的屬性存取的目標可能不正確
javascript.potentially.invalid.usage.of.this=This 的用法可能無效
javascript.potentially.invalid.usage.of.class.this=通過嵌套函數的 'this.' 對類欄位的引用存取可能無效
javascript.potentially.invalid.target.of.indexed.property.access=索引的屬性存取的目標可能無效
js.unfiltered.for.in.loop.inspection.name=未過濾 for..in 迴圈
javascript.unfiltered.for.in.loop=可能迭代意外(自訂/繼承)成員，可能缺少 hasOwnProperty 檢查
js.unfiltered.for.in.loop.skip.primitives=使用陣列或物件初始值設定項跳過引用迭代
js.unfiltered.for.in.loop.skip.primitives.tooltip=在未修改 Object.prototype 和 Array.prototype 時啟用它
js.referencing.mutable.variable.from.closure.inspection.name=從閉包中引用可變變數
javascript.mutable.variable.accessible.from.closure=可從閉包存取可變變數
js.unresolved.variable.inspection.name=未解析的 JavaScript 變數
ts.unresolved.variable.inspection.name=未解析的 TypeScript 變數
js.undeclared.variable.inspection.name=隱式宣告的全域 JavaScript 變數
js.duplicate.declaration.inspection.name=重複宣告
# WI-11522 only the first word should start with uppercase letter
js.linters.inspection.group.name=程式碼品質工具
js.linters.detect.automatically.caption=從最近的 package.json 檢測軟體套件和配置檔案
js.unused.local.symbol.inspection.name=未使用的局部符號
js.unused.es6.import.inspection.name=未使用的 import
js.unused.assignment.inspection.name=未使用的賦值
js.join.declaration.assignment.inspection.name=變數宣告可與變數的第一個賦值合併
js.join.declaration.assignment.inspection.fix=聯接變數宣告和賦值
js.unused.global.symbol.inspection.name=未使用的全域符號
js.missing.await.symbol.inspection.name=異步函數調用缺少 await
js.missing.await.symbol.inspection.for.returns=始終對異步函數調用使用 'await' 以避免錯誤，並幫助進行 V8 異步堆疊跟踪
js.missing.await.symbol.inspection.for.generator.name=異步生成器應使用 for-await 迴圈進行迭代
jsx.missing.namespace.inspection.name=JSX 程式碼中缺少 'React' 命名空間匯入
jsx.missing.namespace.inspection.text=在未匯入 {0} 的情況下使用 JSX
tsx.missing.name.quick.fix.name=\\"添加 {0} import 語句
js.destructuring.merge.inspection=正在析構具有相同鍵的屬性
js.destructuring.merge.inspection.text=可以合併具有多個相同鍵的析構屬性
js.destructuring.merge.inspection.fix=合併析構屬性
js.nested.template.literal.inspection=模板文字中的冗餘嵌套
js.nested.template.literal.fix=內聯嵌套文字
js.redundant.await.inspection=冗餘 'await' 表達式
js.await.promise.resolve.inspection=冗餘 'await Promise.resolve()'
js.await.promise.reject.inspection=冗餘 'await Promise.reject()'
js.await.promise.double.await.inspection=冗餘 'await await'
js.await.promise.return.await.inspection=冗餘 'return await'
js.await.promise.trivial.await.inspection=非 promise 類型的冗餘 'await'
js.await.promise.resolve.fix=取代為 ''{0}''
js.top.level.await.expression.inspection= 頂層 'await' 表達式
js.top.level.await.expression.inspection.description= 使用了頂層 'await' 表達式
js.possibly.async.function.inspection=非異步函數中的 'await'
js.await.in.synchronous.function='await' 運算符只能在 'async' 函數中使用
js.possibly.async.function.quick.fix=令函數 {0} 為異步函數
js.possibly.async.function.quick.fix.family.name=將函數設為異步
js.property.can.be.replaced.with.shorthand=屬性可以取代為速記形式
js.property.can.be.replaced.with.shorthand.method=屬性可以取代為速記方法
js.replace.with.shorthand.property.quick.fix=取代為速記屬性
js.replace.with.shorthand.method.quick.fix=取代為速記方法
js.expand.shorthand.property.quick.fix=展開速記屬性
js.unresolved.function.inspection.name=未解析的 JavaScript 函數
ts.unresolved.function.inspection.name=未解析的 TypeScript 函數
js.unresolved.react.component.name=未解析的 React 組件
js.deprecated.symbols.inspection.name=已使用棄用的符號
js.suspicious.eq.plus.inspection.name=可疑的 '=+' 賦值
js.suspicious.eq.plus.inspection.desc=可疑的 '=+' 賦值：'+=' 可能拼寫錯誤
js.suspicious.eq.plus.fix.name=取代為 '+='
js.suspicious.name.combination.inspection.name=可疑的變數/參數名稱組合
js.bitwise.operator.usage.name=按位運算符用法
js.bitwise.operator.usage.popup=使用了按位運算符
js.bitwise.operator.usage.quickfix=取代為 {0}
js.potentially.invalid.constructor.usages.inspection.name=可能無效的構造函數用法
js.mismatched.update.collection.inspection.name=不符合的集合查詢和更新
js.mismatched.update.collection.update.method.names=更新方法名稱
js.closure.compiler.syntax.inspection.name=JSDoc 標記不正確的用法
js.closure.compiler.syntax.implements.not.interface={0} 未用 @interface 進行註解
js.closure.compiler.syntax.cyclic.inheritance=涉及 {0} 的迴圈繼承
js.closure.compiler.syntax.empty.type=空類型不可用
js.closure.compiler.syntax.invalid.type=類型語法無效
collection.updated.but.not.queried=更新了集合 <code>#ref</code> 的內容，但從未被查詢
collection.queried.but.not.update=查詢了集合 <code>#ref</code> 的內容，但從未寫入
javascript.constructor.with.lower.case.name.used.message=構造函數名稱通常以大寫字母開頭。拼寫錯誤？
interface.function.declaration.should.have.no.body=接口函數宣告不應有本體
javascript.ambient.declaration.should.have.no.body=環境宣告不應有本體
javascript.ambient.declaration.should.have.no.initializer=環境宣告不應有初始值設定項
javascript.ambient.declaration.const.should.be.primitive=環境上下文中的 'const' 初始值設定項必須是基元文字或文字枚舉引用
javascript.deprecated.symbol.used.name.message=使用了棄用的符號，請查閱文檔，以獲取更好的替代性 #loc
javascript.deprecated.symbol.used.name.message2=自版本 {0} 符號被標記為棄用以來，使用 {1} 作為取代用 #loc
js.unused.symbol=未使用的 {0} #ref
js.unused.symbol.full=未使用的 {0}
js.unused.symbol.remove=移除未使用的 {0}
js.suspicious.name.assignment=''{0}'' 可能不應分配給 ''{1}''
js.suspicious.name.parameter=''{0}'' 可能不應作為參數 ''{1}'' 傳遞
js.suspicious.name.return=''{0}'' 可能不應從方法 ''{1}'' 返回
js.constructor.cant.have.return.type=構造函數不能有返回類型
invalid.identifier.value.0=無效關鍵字：''{0}''
js.suspicious.bind.with.arrow.function=箭頭函數 'bind' 用法可疑
javascript.change.signature.invalid.parameter.declaration=無效參數：''{0}''
javascript.change.signature.invalid.function.name.0=無效函數名稱：''{0}''
javascript.validation.generators.yield.not.in.generator=只允許在生成器本體中使用 'yield' 表達式。
javascript.validation.new.target.not.in.function=僅允許函數宣告、函數表達式或構造函數的本體中有元屬性 'new.target'
javascript.validation.message.this.referenced.from.static.context=在 static 上下文中引用了 'this'
javascript.validation.message.super.referenced.without.class.instance.context=在沒有類實例上下文的情況下引用了'super'
javascript.validation.message.super.referenced.from.static.context=在 static 上下文中引用了 'super'
javascript.validation.message.function.override.without.override.modifier=方法重寫了沒有 override 關鍵字的超類 {0} 中的方法
javascript.validation.multiple.var.in.for.loop=''{0}'' 迴圈中只允許一個變數
javascript.validation.initialized.var.in.for.loop=''{0}'' 迴圈中不允許變數初始值設定項
javascript.fix.add.override.modifier=添加覆寫修飾符
javascript.fix.property.spelling.family=修復屬性名稱中可能的拼寫錯誤
javascript.fix.property.spelling.text=將拼寫調整為 ''{0}''
js.code.style.tab.name=JavaScript
js.code.style.file.name.relaxed.style=重用當前檔案的 case
js.code.style.file.name.camel.style=駝峰命名法 (appComponent)
js.code.style.file.name.pascal.style=帕斯卡命名法 (AppComponent)
js.code.style.file.name.snake.style=蛇形命名法 (app_component)
js.code.style.file.name.lisp.style=中線命名法 (app-component)
js.code.style.file.name.mixed.style=帶後綴的中線命名法 (my-app.component)
es6.code.style.path.mapping.always=始終
es6.code.style.path.mapping.never=從不
es6.code.style.path.mapping.different.paths=僅在指定路徑以外的檔案中
typescript.code.style.tab.name=TypeScript
jsx.code.style.attribute.default.value=為 JSX 特性添加：
jsx.code.style.attribute.default.value.braces=大括號
jsx.code.style.attribute.default.value.quotes=引號
jsx.code.style.attribute.default.value.none=無
jsx.code.style.attribute.default.value.typebased=基於類型
javascript.formatting.options.panel.naming.conventions=命名慣例
javascript.formatting.options.panel.comments=註釋
js.convert.parameters.to.object.intention.name=將參數轉換為物件
js.convert.parameters.to.object.with.interface.intention.name=將參數轉換為物件並引入接口
js.convert.parameters.to.object.non.call.usage.will.not.be.updated=不更新非調用用法
js.convert.parameters.to.object.usage.will.not.be.updated.for.contextual.type=方法實作接口方法。不會更新基方法
js.convert.parameters.to.object.usage.will.not.be.updated.for.spread=不會更新使用非終端傳播實參進行的調用
js.undefined.property.assignment.inspection.name=未定義的屬性賦值
js.undefined.property.assignment.inspection.message=類型 {1} 中未定義屬性 {0}
js.jquery.efficiency.inspection.name=可以優化 JQuery 選擇器
js.jquery.efficiency.inspection.allow.attribute.and.pseudo.selectors=允許特性和偽選擇器
js.jquery.efficiency.inspection.attribute.used.message=jQuery 特性選擇器可能低效
js.jquery.efficiency.inspection.pseudoselector.used.message=jQuery 偽選擇器可能低效
js.jquery.efficiency.inspection.duplicated.selector=重複的 jQuery 選擇器
js.accessibility.check.inspection.name=已引用無法存取的 @private 和 @protected 成員
js.convert.to.foreach.intention.name=將 'for-in' 轉換為 'forEach' 調用
js.consecutive.commas.in.array.literal.inspection.name=陣列文字中的連續逗號
js.consecutive.commas.in.array.literal.inspection.message=陣列文字中的連續逗號
js.consecutive.commas.in.array.literal.inspection.insert.undefined=插入 'undefined'
js.check.function.signature.guess.optionality=將非類型化參數視為必選
js.check.function.signature.guess.optionality.hint=如果禁用，則所有未鍵入的參數均視為可選參數
es6.redundant.await.report.for.promises=報告 promise
es6.redundant.await.report.for.promises.hint=總是報告 'return await' 為冗餘，但這會破壞 V8 的異步堆疊跟踪功能
es6.missing.await.report.for.promises=報告 return 語句中的 promise
es6.missing.await.report.for.promises.hint=在異步函數調用前插入 'await' 有助於 V8 提供異步堆疊跟踪
js.file.references.inspection.name=未解析的檔案引用
js.file.references.inspection.ignore.complex.cases=忽略複雜 case
js.inspection.es6.modules.dependencies.family.name=缺少 import 語句
js.inspection.amd.modules.dependencies.family.name=缺少 AMD 模組依賴關係
js.inspection.promise.ignored.display.name=返回 promise 的方法調用結果被忽略
js.inspection.promise.ignored.problem.descriptor=從 {0} 返回的 Promise 被忽略
js.inspection.promise.value.expected.problem.descriptor=應為值，但使用了從 {0} 返回的 Promise
js.flowjs.group.name=Flow 類型檢查器
js.flowjs.config.inspection.name=缺少 .flowconfig
js.flowjs.config.inspection.message=無關聯的 .flowconfig
js.flowjs.coverage.inspection.name=Flow 不涵蓋程式碼
js.flowjs.coverage.inspection.error.text=Flow 不涵蓋此元素
js.flowjs.config.inspection.to.project.path.name=向專案根中添加 .flowconfig
js.flowjs.config.inspection.to.module.path.name=向模組內容根中添加 .flowconfig
js.flowjs.config.inspection.to.current.path.name=向當前目錄中添加 .flowconfig
js.flowjs.annotation.inspection.name=Flow 類型檢查器
js.flowjs.flag.comment.placement.inspection.name=位置錯誤的 @flow 標記
js.flowjs.flag.comment.placement.inspection.error=Flow 標誌註釋不在檔案起始處
js.flowjs.flag.comment.placement.inspection.fix=將 Flow 標誌註釋移至檔案起始處
js.flowjs.flag.without.language.version=無 Flow 語言版本的 Flow 標誌
js.extjs.unresolved.ext.xtype.inspection.name=未解析的 Ext JS xtype
js.frameworks.sencha.xtype.not.found=找不到 xtype ''{0}'' 的 Ext JS 類
javascript.equality.comparison.with.coercion.family.name=取代但不進行類型強制
javascript.equality.comparison.with.coercion.display.name=相等運算符可能導致類型強制
javascript.equality.comparison.with.coercion.error.string=比較 #ref 可能導致意外類型強制 #loc
javascript.equality.comparison.with.coercion.fix=取代為 ''{0}''
javascript.equality.comparison.with.coercion.options.label=高亮顯示 '==' 和 '!=' 的用法：
javascript.equality.comparison.with.coercion.option.always=所有
javascript.equality.comparison.with.coercion.option.always.except.null=與 null 或 typeof 比較時除外
javascript.equality.comparison.with.coercion.option.only.suspicious=僅可疑表達式
js.strict.mode.inspection.name=使用了非嚴格模式
js.strict.mode.inspection.error={0} 不處於嚴格模式下
js.strict.mode.inspection.fix=添加“use strict”雜注
js.strict.mode.inspection.redundant.pragma=\\"use strict\\"雜注冗餘
js.strict.mode.remove.pragma=移除“use strict”雜注
js.class.member.initialization.inspection.name=在 static 初始值設定項中使用可能未分配的屬性
js.class.member.initialization.inspection.text=欄位 ''{1}'' 在 ''{0}'' 之後宣告，並且可能尚未分配
js.class.member.initialization.inspection.text.id=欄位 ''{0}'' 引用本身
js.assignment.used.as.condition.name=用作條件的賦值
js.assignment.used.as.condition.text=<code>#ref</code> 作為條件使用
js.assignment.used.as.condition.fix=將 ''='' 取代為 ''{0}''
js.missing.switch.branches.inspection.name='switch' 語句缺少分支
js.missing.switch.branches.inspection.desc=''switch'' 語句缺少 case：{0}
js.missing.switch.branches.ignore.with.default=忽略具有預設分支的 switch 語句
js.unreachable.switch.branches.inspection.name=不可到達 'switch' 語句的 'case' 分支
js.unreachable.switch.branches.inspection.desc=不可到達的 'case' 分支
js.unreachable.switch.branches.ignore.with.dynamic=不在動態類型的上下文中顯示此警告
js.unreachable.switch.branches.remove=移除不可到達的 'case' 分支
js.redundant.switch.problems.inspection.name='switch' 語句冗餘，可以取代
js.redundant.switch.problems.inspection.empty='switch' 語句為空
js.redundant.switch.problems.inspection.empty.remove=移除空的 'switch' 語句
js.redundant.switch.problems.inspection.default='switch' 語句僅包含一個 'default' 子句
js.redundant.switch.problems.inspection.default.unwrap=解開 'switch' 語句
js.redundant.switch.problems.inspection.side.effects=並提取副作用
js.redundant.switch.problems.inspection.single='switch' 語句僅包含一個非預設子句
js.redundant.switch.problems.inspection.single.replace=將 'switch' 取代為 'if'
js.switch.no.default='switch' 語句沒有 'default' 分支
js.switch.no.default.add=創建缺少的預設分支
js.variable.problems.inspection.name=宣告了變數並在不同的 'case' 子句中使用
js.variable.problems.inspection.desc=變數 ''{0}'' 在子句 ''{1}'' 中宣告， 但在子句 ''{2}'' 中使用
js.variable.problems.inspection.desc.ref.error=存取時引用錯誤
js.variable.problems.ignore.desc=對可變變數忽略
js.inspection.package.json.dependencies=package.json 中的依賴關係不符合
js.inspection.missing.amd.dependency=缺少 AMD 模組依賴關係
js.inspection.missing.import=缺少 import 語句
js.inspection.missing.module.dependency=缺少模組依賴關係
typescript.narrowed.to=範圍限縮至 ''{0}''
label.exclude.methods.classes=排除類方法:
dialog.title.add.classes=添加類
typescript.suspicious.constructor.parameter.assignment=構造函數中的參數賦值可疑。您忘了添加  'this.' 嗎？
typescript.suspicious.constructor.parameter.assignment.desc=已分配構造函數欄位參數
typescript.abstract.class.constructor.can.be.made.protected=abstract 類構造函數可以設為 protected
typescript.make.constructor.protected=將構造函數設為 protected
typescript.private.field.modifiers.mix=使用私有名稱的欄位不能具有 'public'、'private' 或 'protected' 存取修飾符
javascript.validation.message.flowjs.path=Flow 路徑不正確
javascript.validation.message.interface.members.cannot.have.access.modifiers=接口成員不能具有存取修飾符
javascript.validation.message.interface.members.cannot.have.namespace.attributes=接口成員不能具有命名空間特性
javascript.validation.message.interface.members.cannot.be.final.modifiers=接口成員不能為 final
javascript.validation.message.static.modifier.is.allowed.only.for.class.members=僅允許類成員使用 static 修飾符
javascript.validation.message.interface.cannot.be.final.modifiers=接口不能為最終
javascript.template.context.type=JavaSc&ript 和 TypeScript
interface.should.have.no.variable.declarations=接口不應有變量宣告
javascript.validation.message.implements.for.interface.not.allowed=接口不允許有實作列表
javascript.validation.message.interface.name.expected.here=此處應為接口名稱
javascript.validation.message.class.name.expected.here=此處應為類名
javascript.validation.message.circular.dependency=迴圈依賴關係
javascript.validation.message.index.no.type=索引簽名參數必須具有類型註解
javascript.validation.message.index.wrong.type=索引簽名參數類型必須可以分配給 'string | number | symbol'
javascript.fix.remove.circular.dependency=移除迴圈依賴關係
react.jsx.syntax.used.name=已使用 React JSX 語法
react.jsx.syntax.used.description=已使用 React JSX 語法
js.void.function.result.used.name=使用了 void 函數返回值
js.void.function.result.used.description=使用了 void 函數返回值

# JSDoc validation
javascript.validation.message.interface.method.not.implemented=未實作來自於接口 {1} 的方法 {0}
javascript.validation.message.abstract.method.not.implemented=未實作類 {1} 中的 abstract 方法 {0}
javascript.validation.message.abstract.get.accessor.not.implemented=未實作類 {1} 的 abstract get 存取器 {0}
javascript.validation.message.abstract.set.accessor.not.implemented=未實作類 {1} 的 abstract set 存取器 {0}
javascript.validation.message.interface.property.not.implemented=未實作接口 {1} 的屬性 {0}
javascript.validation.message.interface.get.accessor.not.implemented=未實作接口 {1} 的屬性 get 存取器 {0}
javascript.validation.message.interface.set.accessor.not.implemented=未實作接口 {1} 的屬性 set 存取器 {0}

javascript.validation.message.class.method.incompatible= ''{1}'' 類中的方法 ''{0}'' 不可分配給基類 ''{2}'' 中的同一方法
javascript.validation.message.class.property.incompatible= ''{1}'' 類中的屬性 ''{0}'' 不可分配給基類 ''{2}'' 中的同一屬性
javascript.validation.message.class.method.not.implemented=未實作類 {1} 的方法 {0}
javascript.validation.message.class.property.not.implemented=未實作類 {1} 的屬性 {0}
javascript.validation.message.interface.call.signature.not.implemented=未實作接口 {0} 的調用簽名
javascript.validation.message.interface.index.signature.not.implemented=未實作接口 {0} 的索引簽名
javascript.validation.message.class.setter.cannot.have.return.type='set' 存取器不能有返回類型
javascript.fix.remove.externally.visible.symbol=移除外部可見符號
javascript.fix.remove.abstract.keyword=移除 'abstract' 修飾符
javascript.fix.remove.modifier=移除修飾符
javascript.fix.implement.members=實作成員
javascript.fix.implement.methods=實作方法
javascript.implement.all.interfaces=實作所有成員
javascript.implement.required.interfaces=實作所需的所有成員
javascript.implement.members.abstract=實作 abstract 成員

# Symbols
javascript.parameter=參數
javascript.local.variable=局部變數
javascript.global.variable=全域變數
javascript.global.function=全域函數
javascript.local.function=局部函數
javascript.global.decorator=裝飾器
javascript.static.member.function=static 成員函數
javascript.static.member.variable=static 成員變數
javascript.instance.member.variable=實例成員變數
javascript.instance.member.function=實例成員函數
javascript.create.class.intention.name=創建類 ''{0}''
javascript.create.interface.intention.name=創建接口 ‘’{0}''
choose.class.to.import.title=要匯入的類
javascript.fix.remove.override.modifier=移除覆寫修飾符
javascript.fix.remove.virtual.modifier=移除虛擬修飾符
javascript.validation.message.attribute.was.specified.multiple.times=多次指定修飾符 {0}
javascript.fix.remove.dynamic.modifier=移除動態修飾符
javascript.validation.message.function.override.for.object.method=從 Object 繼承的方法無需覆寫
javascript.validation.message.function.override.without.parent.method=方法不覆寫超類的方法
javascript.module.name=模組名稱
javascript.exported.variable=匯出的變數
javascript.exported.function=匯出的函數
javascript.exported.class=匯出的類
javascript.fix.create.function.component.jsx.name=創建函數組件 ''{0}''
javascript.fix.create.function.component.jsx.family=創建函數組件
javascript.fix.create.class.component.jsx.name=創建類組件 ''{0}''
javascript.fix.create.class.component.jsx.family=創建類組件
typescript.module.name=模組名稱
typescript.type.alias.name=類型別名
typescript.type.guard.name=變數類型限縮為類型防護
typescript.type.guard.name.disable=禁用範圍限縮的類型的著色
typescript.primitive.types.name=基元類型
typescript.type.parameter=類型參數
typescript.remove.type.declaration=移除類型宣告

generate.constructor.overloads.and.fields.chooser.title=選擇要使用的多載和要初始化的欄位
generate.to.string.chooser.title=選擇要在 toString 函數中使用的欄位
members.to.implement.chooser.title=選擇要實作的成員
members.to.override.chooser.title=選擇要覆寫的成員
no.candidates=無候選項
no.methods.to.implement=找不到要實作的方法
no.members.to.implement=找不到要實作的成員
implement.members.abstract=實作 abstract 成員
no.methods.to.override=找不到要覆寫的方法
no.members.to.override=找不到要覆寫的成員
no.variables.for.getter=找不到沒有 getter 的欄位
no.variables.for.setter=找不到沒有 setter 的欄位
no.variables.for.getter.setter=找不到沒有 getter 和 setter 的欄位
javascript.validation.unused.import=未使用的 import
javascript.validation.fqn.to.replace.with.import=限定名稱可取代為 import 語句
javascript.fix.optimize.imports=優化 import
javascript.invalid.number.of.parameters=實參數量無效，應為 {0} 個
javascript.expression.type.implicitly.coerced.to.unrelated.type=表達式類型 {1} 隱式強制為不相關類型 {0}
javascript.argument.type.mismatch=實參類型 {1} 不可分配給參數類型 {0}
javascript.initializer.type.mismatch=初始值設定項類型 {1} 不可分配給變數類型 {0}
javascript.incorrect.variable.type.mismatch=變數類型 {1} 不可分配給類型 {0}
javascript.term.does.not.evaluate.to.function=方法表達式不是函數類型
javascript.term.does.not.evaluate.to.function.nullable=方法表達式可以為 null 或 undefined
javascript.term.does.not.evaluate.to.function2=屬性不能作為函數調用
javascript.term.does.not.evaluate.to.function.line.break=表達式不可調用。如果這不應是調用，請檢查是否缺少分號
javascript.term.does.not.evaluate.to.function2.fix=移除實參列表
javascript.term.nullable.indexer.qualifier=索引的表達式可以為 null 或 undefined
javascript.unused.import.remove=移除未使用的 'import'
javascript.unused.import.remove.specifier=移除未使用的元素
javascript.assigned.expression.type.mismatch=分配的表達式類型 {1} 不可分配給類型 {0}
javascript.vector.literal.element.type.mismatch=矢量文字元素類型 {1} 不可分配給類型 {0}
javascript.type.is.not.assignable.to.type=類型 {1} 不可分配給類型 {0}
javascript.no.call.signatures=分配的類型不包含調用簽名
javascript.known.props.only=物件文字只能指定已知屬性，但以下為額外屬性：{0}
javascript.returned.expression.type.mismatch=返回的表達式類型 {1} 不可分配給類型 {0}
javascript.insert.cast.fix=插入轉換
javascript.insert.primitive.wrapper.fix.family.name=使用基元類型包裝
javascript.insert.generic.wrapper.fix.family.name=使用泛型類型包裝
javascript.insert.wrapper.fix.text=使用 ''{0}'' 包裝
typescript.insert.cast.fix=插入類型斷言
es6.insert.await.fix=插入 await
es6.change.to.default.fix=對 ''{0}'' 使用預設匯入
es6.change.to.named.import.fix=對 ''{0}'' 使用命名匯入
typescript.insert.type.guard.fix.family=插入類型防護
typescript.insert.type.guard.surround=封閉在 ''{0}''中
typescript.insert.type.guard.prefix=前綴為 ''{0}''
typescript.insert.type.guard.postfix=使用 ''{0}'' 進行可選查詢
typescript.insert.type.guard.nc=將限定符取代為 ''{0}''
typescript.insert.type.guard.nc.self=取代為 ''{0}''
error.not.available.in.javascript.code={0} 在 JavaScript 程式碼中不可用
cannot.modify.library.code=無法修改庫或 SDK 程式碼
javascript.extract.method.title=提取函數
javascript.validation.message.function.override.incompatible.signature.generic=不相容覆寫
javascript.validation.message.function.override.incompatible.access.modifier=不相容覆寫，應有 ''{0}'' 存取修飾符
javascript.validation.message.function.override.incompatible.signature=不相容覆寫，應有簽名 ''{0}''
javascript.validation.message.function.override.incompatible.signature2=不相容覆寫，應有返回類型 ''{0}''
javascript.validation.message.function.override.incompatible.signature3=不相容覆寫，應有種類 ''{0}''
javascript.validation.message.function.method.invalid.overridden.parameter.type=不相容覆寫，應有類型 ''{0}''
javascript.validation.message.interface.method.invalid.access.modifier=不相容實作，應有 'public' 存取修飾符
javascript.validation.message.interface.method.invalid.signature=不相容實作，應有簽名 ''{0}''
javascript.validation.message.interface.method.invalid.signature2=不相容實作，應有返回類型 ''{0}''
javascript.validation.message.interface.method.invalid.signature3=不相容實作，應有 get / set ''{0}''
javascript.validation.message.duplicate.catch.block=重複 catch 塊 #loc
javascript.validation.message.duplicate.catch.block.fix=移除重複的 catch 塊
javascript.validation.message.missing.catch.or.finally=缺少 catch 或 finally 子句
javascript.validation.message.return.value.of.type.is.required=必需具備類型 {0} 的返回值
javascript.validation.message.return.statement.required=非無效返回類型必需具備 return 語句
typescript.validation.message.invalid.module.member.modifier=''{0}'' 不是模組成員的有效修飾符
javascript.validation.message.unresolved.component=未解析的組件 {0}
javascript.validation.message.super.constructor.call.should.be.in.constructor=超類構造函數調用應位於構造函數本體中
javascript.fix.remove.constructor=移除構造函數
javascript.metadata=元資料
javascript.class=類
javascript.interface=接口
javascript.label=標籤
javascript.function.arrow=箭頭函數
javascript.validation.message.unneeded.comma=不需要的逗號
javascript.validation.message.remove.unneeded.comma.fix=移除不需要的逗號
javascript.validation.message.constructor.cannot.be.static=構造函數不能為 static
javascript.create.event.handler.intention.name=創建事件處理程序 ''{0}''
javascript.validation.message.missed.super.constructor.call=缺少超類構造函數調用
javascript.validation.message.this.before.super.call=超類構造函數調用前不允許有 'this'
javascript.validation.message.baseMethod.before.super.call=超類構造函數調用前不允許有 'super'
javascript.validation.message.base.constructor.in.not.derived=僅允許在派生構造函數中調用基類構造函數
typescript.validation.message.base.constructor.must.be.first.statement=如果類包含初始化屬性或具有參數屬性，則基類構造函數調用必須為構造函數中的第一條語句
javascript.fix.create.constructor.invoke.super=創建符合 super 的構造函數
javascript.fix.create.invoke.super=插入超類構造函數調用
javascript.interface.can.not.be.instantiated.message=無法實例化接口
javascript.abstract.class.can.not.be.instantiated.message=無法實例化 abstract 類
javascript.validation.message.set.method.should.be.void.or.without.type=setter 定義的返回類型必須為未指定或無效
javascript.validation.message.set.method.should.have.one.parameter=setter 定義必須正好有一個參數
javascript.validation.message.get.method.should.have.no.parameter=getter 定義不得有參數
javascript.validation.message.get.method.should.be.valid.type=getter 定義的返回類型不應為 {0}
javascript.validation.message.use.namespace.reference.or.access.modifier=使用命名空間或存取修飾符
javascript.validation.message.one.visibility.modifier.allowed=只允許一個可見性修飾符(public、protected、internal、private)
javascript.validation.destructuring.without.initializer=析構宣告必須有初始值設定項
javascript.fix.remove.access.modifier=移除存取修飾符
javascript.fix.remove.final.modifier=移除 final 修飾符
javascript.validation.message.final.modifier.allowed.only.for.methods=final 修飾符只能應用於類和類方法
javascript.fix.remove.namespace.reference=移除命名空間引用
javascript.fix.remove.visibility.modifier=移除可見性修飾符
javascript.incorrect.array.type.in.for-in=陣列鍵類型應為字串
javascript.validation.message.unexpected.type.for.rest.parameter=Rest 參數不應有類型
typescript.validation.message.unexpected.type.for.rest.parameter=Rest 參數必須為數組類型或具有陣列約束的泛型
typescript.validation.message.unexpected.type.for.rest.parameter.fix=取代為數組類型
javascript.fix.remove.type.reference=移除類型引用
javascript.validation.message.parameter.is.not.allowed.after.rest.parameter=rest 參數後不允許有任何參數
javascript.validation.message.comma.is.not.allowed.after.rest.element=rest 元素後不允許有逗號
javascript.validation.message.comma.is.not.allowed.after.last.parameter=最後一個參數後不允許有逗號
javascript.fix.remove.comma=移除逗號
javascript.fix.remove.parameter=移除參數
javascript.fix.remove.parameters=移除參數
javascript.fix.remove.initializer=移除初始值設定項
javascript.validation.message.parameter.should.be.initialized=應初始化參數
javascript.validation.message.parameter.non.optional.after.optional=必選參數不能位於可選參數後
javascript.validation.message.parameter.rest.optional=rest 參數不能是可選參數
javascript.fix.initialize.parameter=初始化參數
javascript.validation.message.rest.parameter.should.not.be.initialized=不應初始化 Rest 參數
javascript.validation.message.nested.classes.are.not.allowed=不允許嵌套類
javascript.validation.message.implements.is.not.allowed=標準 ECMAScript 中不允許有實作子句
javascript.validation.message.arguments.with.rest.parameter=使用 rest 參數時，'arguments' 物件不可用
js.validate.types.inspection.name=類型不符合
typescript.validate.optional.parameter.inspection.error=參數不能有問號和初始值設定項
typescript.validate.optional.parameter.inspection.fix.question=移除問號
typescript.validate.generic.types.inspection.name=不正確的泛型實參
typescript.redundant.typescript.type.argument.inspection.name=冗餘類型實參
typescript.duplicate.typescript.union.inspection.name=聯合或相交類型組件重複
typescript.validate.generic.types.fix.delete=移除泛型實參
typescript.validate.generic.types.fix.add=添加泛型實參
typescript.validate.generic.types.inspection.error.argument.number=泛型類型 ''{0}'' 需要 ''{1}'' 類型實參
typescript.validate.generic.types.inspection.error.argument.number.between=泛型類型 ''{0}'' 需要介於 {1} 和 {2} 之間的類型實參
typescript.validate.generic.types.inspection.error.not.empty.argument=類型實參列表不能為空
typescript.validate.generic.types.inspection.error.not.empty.parameter=類型參數列表不能為空
typescript.validate.types.any.inspection.name='any' 類型的類型不符合
typescript.validate.template.literal.types=模板類型 {1} 不可分配給約束類型 {0}
js.incompatible.types.comparison.inspection.name=類型不相容的表達式的比較
js.incompatible.types.comparison.message=條件始終為 {0, choice,0#false|1#true}，因為類型 ''{1}'' 和 ''{2}'' 沒有重疊
javascript.validate.imports.name=未解析的已匯入名稱
es6.validate.import.error=無法解析符號 ''{0}''
es6.prefer.short.import.name=可以縮短匯入
typescript.reference.to.umd.global=已引用的 UMD 全域變數
typescript.field.can.be.made.readonly=可以為唯讀欄位
javascript.suspicious.type.guard.desc=類型防護檢查不健全
javascript.object.null.or.undefined.desc=物件為 'null' 或 'undefined'
javascript.suspicious.typeof.guard=''typeof'' 檢查無效：''{0}'' 不能具有類型 ''{1}''
javascript.redundant.typeof.guard=''typeof'' 檢查冗餘：''{0}'' 始終具有類型 ''{1}''
javascript.falsy.typeof.guard=''typeof'' 檢查始終為 false：{0}'' 始終具有類型 ''{1}''
typescript.suspicious.instanceof.guard=''instanceof'' 檢查無效：''{0}'' 的類型與 ''{1}'' 無關
typescript.redundant.instanceof.guard=''instanceof'' 檢查冗餘：''{0}'' 具有類型 ''{1}'' 或 ''{1}'' 的子類型
typescript.redundant.instanceof.inheritor.guard=''instanceof'' 檢查冗餘：''{0}'' 具有類型 ''{1}'' 或 ''{1}'' 的繼承者
javascript.object.is.null={0} 為 null
javascript.object.is.possibly.null={0} 可能為 null
javascript.object.is.undefined={0} 未定義
javascript.object.is.possibly.undefined={0} 可能為 undefined
javascript.object.is.null.or.undefined={0} 為 null 或 undefined
javascript.object.is.possibly.null.or.undefined={0} 可能為 null 或 undefined
typescript.smart.cast=範圍限縮的類型
typescript.smart.cast.hyperlink=設定字體和背景
typescript.missing.augmentation.import=缺少增強匯入
typescript.explicit.member.type.inspection.name=顯式類型
typescript.config.inspection=不一致的 Tsconfig.json 屬性
typescript.config.inspection.libs=缺少全域類別庫
typescript.config.inspection.missing.option=缺少 tsconfig.json 選項 
typescript.config.inspection.libs.fix=在 tsconfig.json 中啟用庫 ''{0}''
typescript.config.inspection.config.options.fix=向 tsconfig.json 中添加 ''{0}''
typescript.config.inspection.fix.pattern=添加 ''{0}'' 屬性
typescript.config.inspection.path.mapping.info=路徑映射需要 baseUrl 屬性
typescript.config.inspection.checkjs.info=屬性 checkJs 需要 allowJs 屬性
typescript.redundant.declaration=類型宣告與推斷的類型相符合，因此可以移除
unnecessary.parentheses.display.name=不必要的圓括號
unnecessary.parentheses.problem.descriptor=<code>#ref</code> 周圍的圓括號不必要 #loc
remove.unnecessary.parentheses.fix.text=移除不必要的圓括號
typescript.specify.type.explicitly=顯式指定類型
typescript.specify.type.explicitly.from.hint=添加顯式類型註解
typescript.specify.all.param.types.explicitly=顯式指定所有參數類型
typescript.specify.all.param.types.explicitly.from.hint=向所有參數中添加顯式類型註解
typescript.make.field.readonly=將欄位設為唯讀
es6.replace.import.action.name=取代為 {0}
es6.replace.import.family.name=取代為較短的路徑
js.validate.signature.inspection.name=簽名不符合
find.usages.of.base.interface={1} 的方法 {0}\\\\n實作 {2} 的方法。\\\\n要{3}基方法嗎?
find.usages.of.base.class={1} 的方法 {0}\\\\n覆寫 {2} 的方法。\\\\n要{3}基方法嗎?
javascript.fix.visibility.family=修復可見性問題
javascript.fix.set.element.visibility=將 {0} 設為 {1}
javascript.fix.set.method.return.type=使 ''{0}'' 返回 ''{1}''
javascript.fix.generate.argument.stubs=生成實參存根
javascript.deprecated.symbol.replace.fix=將棄用的程式碼取代為 {0}
javascript.deprecated.symbol.replace.fix.family=將棄用的程式碼取代為建議的取代
javascript.label.visibility.public=public(&B)
javascript.label.visibility.package_local=internal(&I)
javascript.label.visibility.private=private(&V)
javascript.label.visibility.protected=protected(&O)
move.members.refactoring.name=移動成員
move.members.dialog.title=移動成員
class.0.cannot.be.created=無法創建目標類 {0}，因為存在同名的限定元素
# Used in JSFormatUtil.formatVisibility
javascript.visibility.public=public
javascript.visibility.internal=internal
javascript.visibility.private=private
javascript.visibility.protected=protected
entity.in.parent.description={0} ({1} 內)
package.description=軟體套件 {0}
0.with.1.visibility.in.the.target.class.is.not.accessible.from.2=目標類中可見性為 {1} 的 {0} 無法從 {2} 存取
0.with.1.visibility.is.not.accessible.from.2=可見性為 {1} 的 {0} 將無法從 {2} 存取

# Refactoring
javascript.refactoring.variable.used.as.lvalue=要內聯的變數在賦值的左側使用
javascript.refactoring.variable.value.is.changed.when.accessed.from.closure=從閉包存取時變量值被更改
javascript.refactoring.inline.variable.title=內聯變數
javascript.refactoring.inline.function.title=內聯函數
javascript.refactoring.cannot.find.usages.of.definition.to.inline=無法找到要內聯的定義的用法.
javascript.refactoring.searching.usages=尋找用法
javascript.refactoring.cannot.inline.not.initialized.variable=無法內聯未初始化的變數
javascript.refactoring.cannot.inline.destructuring.variable.with.default=無法內聯使用預設值的析構變數
javascript.refactoring.cannot.inline.destructuring.rest.variable=無法內聯析構 rest 變數
javascript.inline.element.is.not.used={0} 從未使用
javascript.refactoring.inline.dialog.title=內聯 {0}
javascript.refactoring.inline.all.message=內聯所有引用並移除 {0} ({1}) (&A)
javascript.refactoring.inline.this.only=僅內聯此引用並保留 {0}(&K)
javascript.refactoring.cannot.inline.function.defined.in.library=無法內聯外部庫中定義的函數
javascript.refactoring.cannot.inline.function.referencing.arguments=無法內聯引用實參的函數
javascript.refactoring.cannot.inline.interface.method=無法內聯接口方法
javascript.refactoring.cannot.inline.function.referencing.rest.parameter=無法內聯函數引用的 rest 參數
javascript.refactoring.cannot.inline.overrided.or.overridden.method=無法內聯參與層次結構的方法
javascript.refactoring.cannot.inline.recursive.function=無法內聯遞歸函數
javascript.refactoring.cannot.inline.function.with.multiple.returns=無法內聯有多個退出點的函數
javascript.refactoring.cannot.inline.complex.expression.evaluation=無法內聯複雜表達式評估
javascript.refactoring.cannot.inline.constructor=無法內聯構造函數
javascript.refactoring.cannot.inline.jsx.usage=無法內聯 JSX 標籤用法
javascript.refactoring.cannot.inline.ambient.function=無法內聯沒有實作的宣告
javascript.refactoring.function.to.es6.class.command=將函數 {0} 轉換為類
js.convert.to.es6.class=轉換為類
js.convert.to.es6.class.family.name=將函數及其成員宣告轉換為類
js.move.type.to.file.family=移至名稱符合的檔案
js.create.derived.type.family=創建派生類/實作接口
js.create.derived.type.class=創建派生類
js.create.switch.cases=創建缺少的 'switch' 分支
js.create.switch.cases.fix=創建缺少的分支：{0}
js.edit.object.literal=編輯物件文字屬性的值
js.create.derived.type.interface=實作接口
js.create.derived.type.abstract.class=實作 abstract 類
js.rename.file.to.match.type.name.family=重命名檔案以符合類型名稱
js.rename.file.to.match.type.name=將檔案重命名為 {0} 以匹配 {1} 名稱
js.move.type.to.file.text=將 {0} 移至檔案 {1}
javascript.refactoring.function.to.es6.class.defineProperty.warning.text=警告：將使用“Object.defineProperty”、“Object.defineProperties”或“Object.create”創建的屬性轉換為 ES6 語法可能會影響其可枚舉性和可配置性
rename.destructuring.property.title=重命名析構屬性
rename.destructuring.property.description=析構屬性引用多個成員。應重命名相關屬性，否則可能導致程式碼不一致。
rename.type.members.title=重命名類型成員
rename.type.members.union.intersection.mapped.description=檢測到聯合、相交或映射類型用法。應重命名相關屬性，否則可能導致程式碼不一致。
rename.type.members.destructuring.description=檢測到析構屬性中的用法。應重命名相關屬性，否則可能導致程式碼不一致。
make.private=設為 private
choose.destination.scope=選擇目標範圍
list.item.function.to.be.converted.to.class=要轉換為類的函數
list.item.declarations.function.members.to.be.converted.to.class.members=要轉換為類成員的函數成員的宣告
tab.title.convert.to.class=轉換為類
tab.title.refactoring.preview=重構預覽
list.item.function.converted.to.class=轉換為類的函數
list.item.declarations.that.were.not.converted=未轉換的宣告
tab.title.refactoring.result=重構結果
extract.method.declare.static=宣告 static(&S)
extract.function.declare.functional.expression=宣告函數表達式(&F)
extract.function.return.type=返回類型(&T):
extract.function.parameters=參數
extract.function.signature.preview=簽名預覽
extract.function.function=函數
extract.function.name=名稱(&N):
extract.constant.type=類型(&T):
introduce.constant.target.class=目標類(&A):
introduce.field.type=類型(&T):
introduce.field.initialize.in=初始化位置
introduce.field.declaration=欄位宣告(&D)
introduce.field.current.method=當前方法(&M)
introduce.field.class.constructor=類構造函數(&C)
introduce.parameter.type=類型(&T):
introduce.parameter.optional=可選參數(&O)
introduce.variable.declaration=變數宣告
introduce.variable.const=const(&C)
introduce.variable.let=let(&L)
introduce.variable.var=var(&V)
introduce.variable.var.of.type=類型的變數(&T):
introduce.variable.make.constant=設為常數(&C)
custom.template.variables=自訂模板變數(&C):

# Destructuring
javascript.find.usages.destructuring.target.dialog=速記析構變數使用 {0} 初始化。\\\\n您想尋找哪些用法?
javascript.destructuring.initializer=初始值設定項 {0}
javascript.destructuring.variable.only=僅析構變數
javascript.rename.destructuring.target.dialog.title=速記析構變數使用 {0} 初始化
javascript.rename.choose.target.message=您要重命名哪一個？
javascript.rename.shorthand.target.dialog.title=速記屬性使用 {0} 初始化
javascript.rename.shorthand.property.description=屬性
javascript.rename.file.with.related.title=重命名檔案
javascript.rename.containing.file.message=是否也想將檔案及其用法重命名為 {0}?
javascript.rename.related.declaration.message=是否想將 {0} 及其用法重命名為 {1}?
dialog.message.some.usages.cannot.be.updated.properly=有些用法無法正常更新。\\\\n匯入和匯出中的用法、字串用法或動態引用無法取代為析構。
dialog.message.cannot.propagate.when.having.usages.declarations.in.different.files=用法和宣告位於不同檔案中時，無法傳播
dialog.message.write.usages.cannot.be.updated.with.destructuring=寫入用法無法通過重構進行更新
dialog.message.expression.indexed.by.non.numeric.value=表達式使用非數字值編制索引
dialog.message.incomplete.destructuring.pattern.encountered.in.code=在程式碼中遇到不完整的析構模式
dialog.message.unsupported.destructuring.container=不支持的析構容器: {0}
dialog.message.some.usages.cannot.be.updated.properly.wrong.access=有些用法無法正常更新。\\\\n無法取代不按名稱存取屬性的用法或者不按索引存取元素的用法。
dialog.message.cannot.transform.object.array.destructuring.patterns.for.same.element=無法為相同的元素轉換物件和陣列析構模式
dialog.message.transforming.multiple.nested.patterns.not.supported=陣列析構不支持轉換多個嵌套模式

javascript.refactoring.asdoc.for.abstracts=摘要的 ASDoc
0.is.not.allowed.in.interface=接口中不允許使用 {0} 
javascript.fix.remove.static.modifier=移除 static 修飾符
javascript.validation.message.override.can.be.applied.to.method=覆寫只能應用於函數宣告
javascript.validation.message.dynamic.can.be.applied.to.class=動態特性只能應用於類宣告
javascript.illegal.variable.type.void=非法變數類型：'void'
javascript.cannot.return.expression.from.function.with.void.result.type=無法從結果類型為 void 的函數返回值
javascript.cannot.return.expression.from.function.with.void.result.type.fix=移除返回值
javascript.validation.message.function.override.for.interface=對 {0} 中的方法進行了不相容的覆寫
javascript.validation.message.incompatible.override=對 {0} 中的成員進行了不相容的覆寫
class.does.not.have.inheritors.in.current.project={0} 在當前專案中沒有繼承者
javascript.kind.unknown=未知元素
js.unnecessary.semicolon.inspection.name=不必要的分號
js.unnecessary.semicolon.problem=不必要的分號 #loc
js.unnecessary.semicolon.fix.name=移除不必要的分號
javascript.refactoring.extract.function.title=提取函數
javascript.refactoring.extract.function.bad.selection=所選塊應代表一組語句或表達式
javascript.refactoring.extract.function.multiple.exit.points=所選程式碼段有多個退出點
javascript.refactoring.extract.function.yield.and.return=所選片段同時包含 yield 表達式和 return 語句
javascript.refactoring.extract.function.no.loop.for.continue=程式碼段內沒有用於 continue 語句的相應迴圈
javascript.refactoring.extract.function.no.loop.for.break=程式碼段內沒有用於 break 語句的相應迴圈
javascript.refactoring.extract.function.no.switch.for.break=程式碼段內沒有用於 break 語句的相應 'switch'
javascript.refactoring.extract.function.function.used.before.declaring=選定內容包含在宣告之前使用的函數
javascript.refactoring.extract.function.already.exists.in.this.scope=此範圍中已存在 {0}
javascript.validation.message.constructor.cannot.have.custom.visibility=構造函數應為 public 或未指定可見性
javascript.validation.message.can.not.override.final.method=無法從{0}覆寫最終方法
top.level.package=頂層軟體套件
js.comparison.with.nan.inspection.name=與 NaN 比較
js.comparison.with.nan.inspection.problem=與 NaN 的相等比較始終評估為 false
js.comparison.with.nan.inspection.problem2=與 NaN 的不等比較始終評估為 true
js.comparison.with.nan.inspection.quickfix=取代為 {0}isNaN(...)
js.constructor.returns.primitive.inspection.name=構造函數返回基元值
js.constructor.returns.primitive.inspection.problem=使用 'new' 調用時從構造函數返回的基元值將丟失
js.constructor.returns.primitive.inspection.quickfix=返回類型顯式設定為 {0}
js.comment.matches.signature.inspection.name=不符合的 JSDoc 和函數簽名
js.comment.matches.signature.inspection.problem1=JSDoc 中未描述參數 {0}
js.comment.matches.signature.inspection.problem2=JSDoc 中描述的參數 {0} 未出現在函數簽名中
js.comment.matches.signature.inspection.quickfix=更新 JSDoc 註釋

livetemplate.description.fori=創建迭代迴圈
livetemplate.description.iter=迭代 (for..of)
livetemplate.description.itera=迭代 (for await..of)
livetemplate.description.itin=迭代 (for..in)
livetemplate.description.itar=遍歷陣列元素
livetemplate.description.ritar=反序遍歷陣列元素
livetemplate.description.us=插入 'use strict' 語句
livetemplate.description.ref=插入引用路徑註釋
livetemplate.description.defi=插入 define() 表達式
livetemplate.description.flow=插入 @flow 註解
livetemplate.description.importfrom=import 語句 - 從 ''a'' 匯入 {b}
livetemplate.description.importns=import 語句 - 從 'a' 匯入 * as b
livetemplate.description.importdefault=import 語句 - 從 'a' 匯入 b
livetemplate.description.exportall=匯出語句 - 從 'a' 匯出 *
livetemplate.description.exportfrom=匯出語句 - 從 ''a'' 匯出 {b} 
livetemplate.description.exportitems=匯出語句 - export {b}
livetemplate.description.moduleexports=匯出語句 - module.exports = a
livetemplate.description.arf=使用箭頭函數環繞

livetemplate.description.console.log=console.log()
livetemplate.description.console.warn=console.warn()
livetemplate.description.console.error=console.error()
livetemplate.description.console.info=console.info()
livetemplate.description.console.trace=console.trace()
livetemplate.description.console.assert=console.assert()

postfix.template.provider.name=JavaScript 和 TypeScript
postfix.template.condition.non.void.name=非 Void
postfix.template.condition.array.name=陣列

macro.js.component.type.of=jsComponentTypeOf(Array)
macro.js.suggest.default.variable.kind=jsSuggestDefaultVariableKind(Boolean)

# Line markers
linemarker.implements.invalid=<無效>
linemarker.implements.text=實作 {1} 中的 {0}
linemarker.overrides.text=覆寫 {1} 中的 {0}
linemarker.implements.several=實作多種接口方法
linemarker.overridden=覆寫
linemarker.implemented=已實作
linemarker.overriding=覆寫
linemarker.implementing=實作
linemarker.javascript.typescript=JavaScript/TypeScript 行標記

js.validate.jsdoc.inspection.name=JSDoc 中的語法錯誤和未解析的引用
javascript.expected.class.or.descendant=應為類 {0} 或後代
javascript.qualified.class.name.expected=應為限定的類名
javascript.validation.message.unknown.metadata.annotation.used=使用了未知的元資料特性
javascript.validation.message.set.method.type.is.different.from.getter=Set 存取器方法的類型與 get 存取器類型不相容，應為 ''{0}''
javascript.validation.message.get.method.type.is.different.from.setter=Get 存取器方法的類型與 set 存取器類型不相容，應為 ''{0}''
typescript.validation.message.getter.and.setter.must.have.same.access.type=Getter 和 setter 必須具有相同的存取類型
actionscript.validation.message.set.method.access.type.is.different.from.getter=Flash 編譯器錯誤 174646：Set 存取器方法存取類型不同於 get 存取器存取類型，應為 ''{0}''
actionscript.validation.message.get.method.access.type.is.different.from.setter=Flash 編譯器錯誤 174646：Get 存取器方法存取類型不同於 set 存取器存取類型，應為 ''{0}''
javascript.validation.message.static.method.cannot.be.final=靜態方法不能為最終
javascript.assign.parameter.to.field.intention.name=分配參數 ''{0}'' 給欄位
javascript.fix.create.parameter=創建參數 ''{0}''
javascript.introduce.parameter.introduced.variable.value=值(&V):
0.is.not.a.legal.name=''{0}'' 不是合法的類名
item.already.exists={0} {1} 已存在
directory.already.contains.file=目錄 ''{0}'' 已包含檔案 ''{1}''
extract.subclass.command.name=從 {1} 提取子類 {0}
extract.interface.command.name=提取接口
extract.type.alias.command.name=提取類型別名
new.actionscript.class.dialog.title=新建 ActionScript 類
new.actionscript.interface.dialog.title=新建 ActionScript 接口
class.template.title=類
class.with.supers.template.title=包含 Super 的類
interface.template.title=接口
extract.0.turn.refs=提取 {0} 並盡量使用 (&T)
superclass.cannot.be.extracted.from.mxml.component=無法從 MXML 組件中提取超類。
superclass.cannot.be.extracted.from.type.alias=無法從類型別名中提取超類
superclass.cannot.be.extracted.from.enum=無法從枚舉中提取超類
interface.cannot.be.extracted.from.type.alias=無法從類型別名中提取接口
interface.cannot.be.extracted.from.enum=無法從枚舉中提取接口
javascript.fix.message.change.parameters.to.expected=將這些參數更改為預期參數
javascript.fix.message.change.return.type.to.expected=將返回類型更改為預期類型
js.last.comma.in.array.literal.inspection.name=陣列文字中的最後一個逗號多餘
js.last.comma.in.object.literal.inspection.name=物件文字中的最後一個逗號多餘
error.wrong.caret.position.method.name=文本游標應置於要重構的方法的名稱處。
changeSignature.vararg.not.last=Rest 參數應當為方法簽名中的最後一個參數
parameter.type.is.not.specified=參數 ''{0}'' 的類型未指定。\\\\n是否繼續？
return.type.is.not.resolved=返回類型 ''{0}'' 未解析。\\\\n是否繼續？
change.signature.column.name.initializer=初始值設定項
change.signature.column.name.default.parameter=預設參數
change.signature.column.name.call.value=調用中的值
change.signature.parameter.table.empty.message=使用  '+' 按鈕添加新參數
required.parameters.are.not.permitted.after.optional.parameters=必選參數不能位於可選參數後
javascript.fix.remove.setter.parameter.initializer=移除參數預設值
javascript.validation.message.setter.parameter.cannot.have.initializer=Setter 定義不能具有可選參數
javascript.changeSignature.no.call.value=新的必選參數 ''{0}'' 已添加。\\\\n指定要用於此方法的所有現有調用的預設值。
es6.changeSignature.no.call.value=新參數 ''{0}'' 已添加。\\\\n指定要用於此方法的所有現有調用的預設值或值。
javascript.changeSignature.call.value.not.allowed=參數 ''{0}'' 不允許使用預設值。因為沒有為前面的參數指定它。
es6.changeSignature.call.value.not.allowed=參數 ''{0}'' 不允許使用調用中的值。因為沒有為前面的參數指定它。
change.signature.usage.view.declarations.header=要重構的方法
{0}.visibility.will.break.methods.hierarchy=可見性為 {1} 的{0}無法參與層次結構
generate.delegate.method.conflict.message=無法通過不同的屬性為同名成員生成委託
generate.delegate.method.conflict.message.title=無法生成委託
invalid.return.type.expression=返回類型 ''{0}'' 無效
invalid.parameter.type.expression=參數類型 ''{0}'' 無效
type.is.not.resolved=類型 ''{0}'' 未解析。\\\\n是否繼續？
invalid.field.type.expression=無效欄位類型：''{0}''
choose.field.type=選擇欄位類型
new.field.action.text=欄位
new.field.action.description=在類中創建新字段
create.field.dialog.title=創建欄位
field.initializer.is.not.specified=未指定欄位初始值設定項
new.method.action.text=方法
new.method.action.description=在類中創建新方法
create.method.dialog.title=創建方法
create.button.text=創建(&C)
class.already.contains.method.warning=類 ''{0}''''已經 {1, choice, 1# 包含|2#繼承] 方法 ''{2}()''。\\\\n是否繼續？
class.already.contains.field.warning=類 ''{0}'' 已包含欄位 ''{1}''。\\\\n是否繼續？
declare.static=宣告 static(&S)
new.constructor.action.text=構造函數
new.constructor.action.description=創建構造函數
create.constructor.dialog.title=創建構造函數
change.method.signature.fix.text=更改 {0} 簽名
change.method.signature.and.update.delegating.call.fix.text=更改 {0} 簽名以符合 {1} 調用和更新調用
change.method.signature.and.update.delegating.call.noname.fix.text=更改簽名以符合 {0} 調用和更新調用
change.method.signature.delegating.default.text=委託
change.method.signature.fix.family.name=更改方法簽名
change.method.signature.and.update.delegating.call.fix.family.name=更改方法簽名並更新委託調用

# Settings
settings.javascript.root.configurable.name=JavaScript
settings.typescript.root.configurable.name=TypeScript
settings.javascript.linters.configurable.name=程式碼品質工具
settings.javascript.linters.autodetect.disabled=禁用 {0}(&D)
settings.javascript.linters.autodetect.configure.automatically=自動 {0} 配置 (&A)
settings.javascript.linters.autodetect.configure.automatically.help.text={0} 將使用 node_modules 目錄中的 {1} 軟體套件，還會使用與當前檔案或其任何父資料夾位於同一資料夾中的 {2} 配置檔案。
settings.javascript.linters.autodetect.configure.manually=手動 {0} 配置 (&M)
settings.javascript.linters.jshint.configurable.name=JSHint
settings.javascript.only.type.based.completion=僅基於類型補全 (&C)
settings.javascript.opt.chain.completion=為可 null 類型建議包含可選鏈接的條目(&O)
settings.javascript.overrides.completion=在覆寫補全中展開方法體
settings.javascript.var.names.completion=建議變數和參數名稱(&V)
settings.javascript.field.names.completion=為類欄位建議名稱 (&F)
settings.javascript.var.names.completion.desc=補全名稱
settings.javascript.var.names.completion.types=為建議的參數名稱添加類型註解(&T)
settings.javascript.var.names.completion.names.only=無類型
settings.javascript.var.names.completion.types.for.params=具有函數參數的類型
settings.javascript.var.names.completion.types.for.params.fields=具有參數和欄位的類型
settings.javascript.var.names.completion.types.except.fields=隨處都是類型，欄位除外
settings.javascript.var.names.completion.types.everywhere=隨處都是類型
settings.javascript.only.type.based.completion.tooltip=根據類型資訊顯示較少的補全建議。可能會顯著提高性能。
settings.javascript.lang.templates.configurable.name=模板
es6.auto.import.options.completion.add.imports=在程式碼補全時添加 ES6 匯入
es6.auto.import.options.title=TypeScript / JavaScript
typescript.auto.import.options.add.imports=自動添加 TypeScript 匯入
typescript.auto.import.options.add.imports.on.the.fly=即時明確匯入
typescript.auto.import.options.add.on.code.completion=程式碼補全
typescript.auto.import.options.show.popup=包含自動匯入工具提示
js.import.options.merge.import=合併同一模組中成員的匯入
js.import.options.use.node.resolution=在 index.js 可用時使用目錄匯入（節點樣式模組解析）
js.import.options.use.explicit.js.extension=使用檔案副檔名: 
js.add.members.to.type.desc=將成員添加到類或接口
js.add.members.to.type=將成員 {0} 添加到 ''{1}''
js.import.options.sort.members=對匯入的成員排序
js.import.options.sort.module.name=按模組對匯入排序
es6.import.options.paths=使用路徑別名：
es6.import.options.paths.help=此選項配置 import 語句中使用的路徑樣式。<br><br>選擇“始終”時，IDE 在添加匯入時始終使用來自 webpack、system.js 或 jsconfig.json 配置的別名。<br><br>選擇“僅在指定路徑之外的檔案中”時，IDE 針對為之定義了別名的檔案之間的匯入使用相對路徑。在所有其他檔案中使用路徑映射。<br><br>選擇“從不”時，則不使用別名。
typescipt.import.options.paths.help=此選項配置 import 語句中使用的路徑樣式。<br><br>選擇“始終”時，IDE 在添加匯入時始終使用從 tsconfig.json 映射的路徑。<br><br>選擇“僅在指定路徑之外的檔案中”時，IDE 針對為之定義了映射的檔案之間的匯入使用相對路徑。在所有其他檔案中使用路徑映射。<br><br>選擇“從不”時，則不使用路徑映射。
typescript.import.options.paths=使用 tsconfig.json 的路徑映射：
typescript.import.options.use.config=使用相對於 tsconfig.json 的路徑
javascript.import.options.use.resource.root=使用相對於專案、資源或源根目錄的路徑
typescript.import.options.blacklist.title=不要完全從此匯入：
js.flow.settings.executable.label=Flow 軟體套件或可執行檔案 (&F)：
js.flow.settings.executable.dialog.title=選擇 Flow 軟體套件或可執行檔案
js.flow.services.label=為之使用 Flow 伺服器：
js.flow.enable.type.checking=類型檢查
js.flow.enable.other.services=導航、程式碼補全和類型提示
js.flow.enable.flow.service.error=\\\\ 不正確的 Flow 路徑
js.flow.enable.flow.service.error.empty=Flow 可執行檔案的路徑為空
js.flow.enable.flow.service.error.on.checking=檢查 Flow 路徑時出錯：{0}
js.flow.enable.flow.service.error.message={0}。禁用所有 Flow 服務或為可執行檔案提供有效路徑。
js.flow.settings.auto.save=自動儲存所有修改的檔案
js.flow.settings.auto.save.warning=只有儲存其他所有修改過的檔案時，Flow 才會檢查當前檔案。
js.flow.settings.auto.save.warning.lsp=這樣 Flow 將始終顯示最新的錯誤狀態。
js.dialect.settings.dialog.title=JavaScript 語言版本
js.dialect.settings.caption=
js.dialect.settings.tableTitle=語言
js.dialect.settings.override.question=覆寫子目錄和檔案的語言版本？
js.dialect.settings.override.title=覆寫語言版本設定
js.dialect.settings.empty.text=使用 + 按鈕添加目錄，並選擇 JavaScript 版本
js.dialects.customized.label=根據目錄自定義
configure.code.completion.settings=配置程式碼補全設定

# Bower
settings.javascript.bower.configurable.name=Bower
bower.packages.view.dependencies=依賴項:
bower.package=Bower 軟體套件(&B):
bower.json=bower.json (&O)：
bower.correct.path=請更正 {0} 的路徑
bower.package.name=Bower 軟體套件
bower.dialog.message.specify.package=指定正確的 bower 軟體套件: 未找到 \\"{0}\\" 檔案
bower.required.version.notification.content=要查看 bower 軟體套件，您需要 bower@1.0.0 或更高版本
bower.no_description_available.text=無可用描述
dialog.message.command.timed.out=命令 ''{0}'' 超時
dialog.message.command.cancelled=命令 ''{0}'' 已取消
dialog.message.command.finished.with.exit.code=命令 ''{0}'' 已完成，退出程式碼為 {1}。Stdout:\\\\n{2}\\\\n\\\\nstderr:\\\\n{3}

# JS language version management
js.language.version.combo.es5=ECMAScript 5.1
js.language.version.combo.js185=JavaScript 1.8.5
js.language.version.combo.js185.description=已棄用特定於 Firefox 的 ECMAScript 實作。請考慮切換。
js.language.version.combo.es6=ECMAScript 6+
js.language.version.combo.es6.description=ECMAScript 2015+、一些提案和 JSX
js.language.version.combo.nashorn=Nashorn JS
js.language.version.combo.nashorn.description=Java 中的 JavaScript 實作
js.language.version.combo.flow=Flow
js.language.version.combo.flow.description=ECMAScript 6 中的 Flow 和 JSX
js.language.version.label=JavaScript 語言版本
js.switch.to.jsx.inspection.dismiss=關閉
ts.switch.to.jsx.inspection.name=更改檔案擴展名為 .tsx
javascript.change.language.level.message=更改 JavaScript 語言版本為 {0}
javascript.change.language.level.family=更改 JavaScript 語言版本

# JS library management
js.library.attach.debug=附加調試版本(&D)…
js.library.attach.release=附加發佈版本(&R)…
js.library.unresolved.url.inspection.name=HTTP 鏈接缺少本地存儲的庫
js.library.download.fix=下載庫
js.library.downloading.library=正在下載庫
js.library.documentation=文檔
js.library.configurable.name=庫
js.library.download.stubs.label=TypeScript 社區存根
js.library.successfully.downloaded=已成功下載 {0}

choose.super.method=<html><body>選擇 <b>{0}</b> 的 Super 方法（找到 {1}）</body></html>
choose.super.function=<html><body>選擇 <b>{0}</b> 的 Super 函數（找到 {1}）</body></html>
choose.super.field=<html><body>選擇 <b>{0}</b> 的 Super 欄位（找到 {1}）</body></html>
choose.super.classifier=<html><body>選擇 <b>{0}</b> 的超類或接口（找到 {1}）</body></html>
choose.subclass=<html><body>選擇 <b>{0}</b> 的子類（找到 {1}）</body></html>
choose.implementing.class=<html><body>選擇 <b>{0}</b> 的實作（找到 {1}）</body></html>
choose.overridden.method=<html><body>選擇 <b>{0}</b> 的覆寫方法（找到 {1}）</body></html>
choose.overridden.function=<html><body>選擇 <b>{0}</b> 的覆寫函數（找到 {1}）</body></html>
choose.implementing.method=<html><body>選擇 <b>{0}</b> 的實作(找到 {1} 個)</body></html>
javascript.invalid.delete.target.message=刪除運算符目標無效，應為欄位引用
javascript.with.statement.is.not.allowed.in.strict.mode.message=嚴格模式下不允許使用 With 語句
javascript.validation.message.redefining.is.not.allowed=不允許重新定義 {0}
javascript.validation.message.referencing.arguments.caller.callee.is.not.allowed=不允許從實參中引用 'caller' 和 'callee'
javascript.validation.message.referencing.function.arguments.property.is.not.allowed=不允許引用 'arguments' 函數屬性
javascript.validation.message.arguments.is.readonly='arguments' 唯讀
javascript.validation.message.eval.cannot.be.assigned=不能在嚴格模式下分配 'eval'
javascript.octal.literals.are.not.allowed.es6.message=不允許使用前綴為 '0' 的八進制文字。改用 '0o' 前綴
javascript.octal.literals.are.not.allowed.es5.message=前綴為 '0' 的八進制文字已過時，不建議使用
javascript.octal.sequences.are.not.allowed.message=不允許八進制轉義序列
javascript.invalid.extended.unicode.escape=擴展的 Unicode 轉義僅允許介於 0x0 和 0x10FFFF 之間的值
javascript.octal.literals.are.not.allowed.in.strict.mode=在嚴格模式下不允許八進制文字
javascript.octal.literals.warn.always=關於 ES5-程式碼中過時八進制文字的警告
javascript.validation.message.only.one.default.is.allowed=\\\\ switch 中只允許一個預設子句
javascript.fix.remove.default=移除預設子句
javascript.validation.message.accessor.could.not.be.nested.under.other.function=存取器方法不能嵌套在其他函數中
javascript.validation.message.es5.function.declarations.allowed.on.top.level.or.function=禁止在程序或函數的頂層使用函數語句
class.chooser.not.available.in.dumb.mode=正在進行索引更新，選擇器不可用。
choose.super.class.title=選擇超類
choose.base.component.title=選擇超類
choose.super.interface.title=選擇 Super 接口
0.is.not.accessible.from.1=無法從 {1} 存取 {0}
javascript.constructor.call.without.new.message=沒有 new 的構造函數調用
javascript.qualified.name.is.not.imported.message=未匯入限定名稱 #loc
javascript.element.is.not.accessible.message=元素不可存取 #loc
javascript.protected.member.is.not.accessible.message=protected 成員不可存取 #loc
javascript.protected.constructor.is.not.accessible.message=protected 構造函數不可存取 #loc
javascript.private.member.is.not.accessible.message=private 成員不可存取 #loc
javascript.export.only.member=元素僅匯出
javascript.private.constructor.is.not.accessible.message=private 構造函數不可存取 #loc
javascript.jsdoc.protected.member.is.not.accessible.message=protected 成員不可存取 #loc
javascript.jsdoc.private.member.is.not.accessible.message=private 成員不可存取 #loc
javascript.static.member.is.not.accessible.message=static 成員不可存取 #loc
javascript.instance.member.is.not.accessible.message=實例成員不可存取 #loc
javascript.element.need.to.be.exported=未匯出元素
javascript.element.need.to.be.imported=未匯入元素
javascript.element.default.instead.named=使用了預設匯入而不是命名匯入
javascript.element.need.to.be.included.to.config=tsconfig.json 中不包含相應檔案
javascript.argument.types.mismatch=實參類型與參數不符合
javascript.member.from.unopened.namespace.message=未打開命名空間的成員 #loc
javascript.property.is.read.only.message=唯讀屬性 #loc
javascript.property.is.write.only.message=只寫屬性 #loc
javascript.assume.uppercase.functions.to.be.constructors=假設只有大寫的函數是構造函數
javascript.not.a.constructor.call.message=不是構造函數調用
cannot.refactor.anonymous.function=現有非調用用法阻止調用站點分析。
change.signature.method.references.arguments=函數引用實參，更改簽名後代碼可能會中斷
change.signature.call.expression.contains.spreads=函數調用包含傳播實參。用法將保持不變。
change.signature.tagged.template.issue=無法更新標記的模板調用。用法將保持不變。
change.signature.conflict.incompatible.override=覆寫 {0} 的參數個數與重構 {1} 的參數個數不同。重構期間將忽略 {2}。
change.signature.conflict.incompatible.implementation=實作 {0} 的參數個數與重構 {1} 的參數個數不同。重構期間將忽略 {2}。
change.signature.conflict.eliminating.parameter.property.breaks.usages=將參數-屬性轉換為簡單的參數將中斷 {0} 的欄位用法
change.signature.conflict.readonly.parameter.property.write.usage=將 {0} 變為唯讀將中斷非讀取用法
javascript.missed.argument.for.parameter=參數 {0} 缺少實參

# Code folding settings
checkbox.collapse.object.literals=物件文字
checkbox.collapse.one.line.function.literals=JavaScript 和 TypeScript 中的單行函數
checkbox.collapse.array.literals=陣列文字
checkbox.collapse.xml.literals=XML 文字
change.signature.value.column.title=值
change.signature.column.name.optional.flag=可選
change.signature.column.name.modifier=修飾符

# Flow general
js.flow.all.servers.action.restart=重啟所有 Flow 伺服器
js.flow.has.unsaved.files=由於修改了某些檔案，因此沒有執行高亮顯示
flow.js.get.type=Flow JS:Get 類型
flow.show.error.details=顯示錯誤詳情
can.t.find.flow.executable=找不到 Flow 可執行檔案
process.terminated=進程已終止
progress.text.modifying=正在修改 {0}
progress.text.initializing.opened.files=正在初始化打開的檔案

# Code style settings
js.code.style.punctuation.tab.title=標點
space.before.name.value.separator=在屬性名稱-值分隔符 ':' 前面
space.after.name.value.separator=在屬性名稱-值分隔符 ':' 後面
space.before.function.left.parenth=在函數表達式中
actionscript.space.after.dots.in.rest.parameter=在 rest 參數中的 '...' 後面
space.after.dots.in.rest.spread=在 rest/spread 中的 '...' 後面
space.before.generator.mult=在生成器中的 '*' 前面 
space.after.generator.mult=在生成器中的 '*' 後面 
spaces.within.object.type.braces=物件文字類型大括號
space.before.type.colon=在類型引用冒號 ':' 前面
space.after.type.colon=在類型引用冒號 ':' 後面
space.before.class.lbrace=類的左大括號
space.before.class.interface.module.lbrace=類/接口/模組左大括號
spaces.within.object.literal.braces=物件文字大括號
spaces.within.import.braces=ES6 匯入/匯出大括號
spaces.within.indexer.brackets=索引存取中括號
spaces.within.array.initializer=陣列中括號
spaces.within.union.and.intersection=聯合和相交類型
spaces.within.type.assertion=類型斷言
spaces.arrow.function=箭頭函數(=>)
spaces.async.arrow.function=在異步箭頭函數中
spaces.within.interpolation.expressions=插值表達式
spaces.within.unary.additive=一元加法運算符 (+,-,++,--)
spaces.after.unary.not=在 'not' (!) 和 '!!' 後面
spaces.before.unary.not=在 'not' (!) 和 '!!' 前面
js.blank.lines.around.method=環繞方法:
js.blank.lines.around.function=Around 函數：
js.spaces.in.flow.category=在 Flow 中
js.wrap.settings.import=ES6 匯入/匯出
js.align.properties.none=不對齊
js.align.properties.on.colon=冒號上
js.align.properties.on.value=值上
js.function.call.parentheses=函數調用括號
js.function.declaration.parentheses=函數宣告括號
js.function.brace.style=在函數宣告中
js.function.expression.brace.style=在函數表達式中
js.function.parameters.wrap=函數宣告參數
js.function.call.wrap=函數調用實參
js.space.before.function.left.brace=函數左大括號
js.format.cstyle.comments=對齊多行
js.chained.call.dot.on.next.line='.' 在新行
js.generated.use.public.modifier=使用 'public' 修飾符
js.generated.use.as.cast=首選 'as' 類型轉換
js.generated.types=類型
js.generated.types.settings.link=顯式類型的程式碼樣式設定
js.generated.explicit.types=此項的首選顯式類型：
js.generated.explicit.var.types=變數和欄位
js.generated.explicit.return.types=函數宣告返回
js.generated.explicit.return.expression.types=函數表達式返回
js.trailing.comma.keep=保持
js.trailing.comma.remove=移除
js.trailing.comma.whenMultiline=多行時添加
js.extends.list.wrap=Extends 列表
js.align.multiline.extends.list=多行時對齊
js.extends.keyword.wrap=擴展關鍵字
js.wrap.settings.union.and.intersection.types=聯合和相交類型
js.code.style.object.literals.category.name=物件
js.code.style.align.caption=對齊
js.code.style.align.from.clause.caption=對齊 'from' 子句
js.wrap.settings.var.group.name=變數宣告
js.code.style.do.not.align.var.statement=不對齊
js.code.style.align.var.statements=當多行時
js.code.style.align.var.statements.and.assignments=分組時
js.code.style.array.group.name=陣列
js.array.new.line.after.left.bracket=在 '[' 後換行
js.array.new.line.before.right.bracket=將 ']' 置於新行中

js.method.can.be.static=方法可以為 'static'
js.method.can.be.static.option=僅檢查 'private' 方法
make.method.static=設為 'static'
typescript.fix.change.member.access=設為 ''{0}''
js.fix.change.member.access.to.sharp=使用 '#' 設為 private
declare.event.0=宣告事件 ''{0}''
js.variable.might.not.been.initialized=變數可能尚未初始化 #loc
js.variable.initializer.is.redundant=變數初始值設定項冗餘 #loc
js.value.assigned.is.never.used=從未使用過所賦之值 #loc
js.value.assigned.to.is.never.used=賦給 ''{0}'' 的值從未使用 #loc
javascript.fix.change.type=''{0}'' 類型更改為 ''{1}''
javascript.fix.change.parameter.type=參數 ''{0}'' 類型更改為 ''{1}''
javascript.change.jsdoc.type.family.name=更改 JSDoc 中元素的類型
change.signature.dialog.title=更改 {0} 的簽名
javascript.fix.add.enum.values=添加枚舉值
javascript.fix.add.string.enum.values=添加字串枚舉值
typescript.intention.convert.import.require=將 import require 轉換為 import from
typescript.intention.convert.import.require.text=轉換為 {0}
javascript.fix.create.implements=使 ''{0}'' 實作 ''{1}''
javascript.fix.create.inheritor.family=從 super 類型繼承
javascript.fix.implement.family=在派生類中實作
javascript.fix.implement.chooser.title=從中實作成員
javascript.fix.implement.chooser.all=所有類
javascript.fix.implement=實作 {0}
javascript.fix.create.extends=使 ''{0}'' 擴展 ''{1}''
javascript.report.unused.properties=報告未使用的屬性
javascript.report.unused.definitions=報告未使用的定義
javascript.check.global.definitions=檢查全域範圍內的賦值
javascript.strictly.check.global.vars=將未宣告的全域變數報告為錯誤
javascript.strictly.check.object.properties=將未宣告的屬性報告為錯誤
javascript.strictly.check.global.functions=將未宣告的全域函數報告為錯誤
change.signature.column.type=類型
change.signature.column.name=名稱
javascript.invalid.invoker.target=無效調用目標
js.declarations.at.scope.start.inspection='var' 未在函數開頭宣告
js.make.single.var.statement=設為單變數語句
js.declaration.is.not.at.scope.start=var 語句不在範圍開始
js.move.to.scope.start=將 var 語句移至範圍開始
js.primitive.type.wrapper.usage.inspection=使用了基元類型物件包裝器
js.replace.with.type.cast.to.primitive=取代為 {0} 的類型轉換
js.assigning.to.primitive.type.property=賦給基元的值將丟失
js.primitive.type.improper.instantiation.inspection={0} 實例化可以簡化
js.replace.with.literal=取代為 {0} 文字
non.ascii.identifiers.inspection.name=包含非 ASCII 符號的關鍵字
non.ascii.identifiers.only.ascii=僅允許 ASCII 名稱
non.ascii.identifiers.non.ascii.found=<html>名稱包含非 ASCII 符號：{0}</html>
non.ascii.identifiers.mixed.set=<html>名稱同時包含 ASCII 和非 ASCII 符號：{0}</html>

element.name.anonymous=<anonymous>
element.name.default=<預設>
duplicate.parameter.name=重複的參數名稱: {0}
rename.accessors.dialog.title=重命名欄位
rename.accessors.dialog.text=是否將屬性存取器也重命名為 ''{0}''？
insert.new.keyword.fix.name=插入新關鍵字
insert.this.keyword.fix.name=添加 this 限定符
insert.class.fix.name=添加類名限定符
replace.implements.keyword.fix.name=將 'implements' 更改為 'extends'
superclass.label.text=超類(&S):
varible.name.column.title=名稱
varible.value.column.title=值
custom.variables.step.title.label.text=模板 ''{0}'' 中的自訂變數 (&C)：
create.class.ok.button.text=創建
create.class.name.label=名稱(&N):
create.class.package.label=軟體套件:
create.class.template.label=模板(&T):
create.class.superclass.label=超類(&S):
create.class.interfaces.label=接口(&I):
action.structureview.show.object.inherited=從物件繼承

# JSHint
jshint.option.edit.dialog.title=設定 ''{0}'' 選項
jshint.clear.field.to.disable=清除要禁用的欄位
jshint.illegal.integer=非法整數
jshint.use.config.files=使用配置檔案
jshint.version.label=版本(&V):
jshint.label.bundled.suffix=(捆綁)
jshint.tree.link.set=設定
jshint.label.no.version=無版本
jshint.exception.balloon.action.retry=<a href=''{0}''>重試</a>
jshint.exception.balloon.action.configure.proxy.or.retry=<a href=''{0}''>配置 HTTP 代理</a>或<a href=''{1}''>重試</a>
filetype.jshint.config.description=JSHint 配置
filetype.jshint.config.display.name=JSHint 配置
jshint.suppress.text.suppress.for.line=禁止行
jshint.options.tree.tooltip.set.a.new.value=設定新值
jshint.config.option.default.name=預設
jshint.config.default.description=<div style=\\"padding-bottom:10px\\"><div><b>.jshintrc</b></div><div style=\\"padding-left:10px; padding-top:4px;\\">對 JavaScript 檔案進行 Linting 檢查時，IDE 會從檔案所在的資料夾開始尋找 .jshintrc，然後上行到檔案系統根目錄。</div></div><div><div><b>package.json</b></div><div style=\\"padding-left:10px; padding-top:4px;\\">將您的配置添加到專案的 package.json 檔案中的 <code>jshintConfig</code> 屬性下。</div></div>
jshint.config.option.custom.name=自訂配置檔案
jshint.config.option.custom.browser.title=選擇 JSHint 配置檔案 （*.jshintrc）
jshint.config.failed.to.read=無法讀取 JSHint 配置
jshint.config.extends.cyclically=JSHint 配置迴圈擴展
jshint.config.error.failed.to.read.property=無法從 package.json 讀取 ''{0}'' 屬性
jshint.config.error.cannot.locate.ext.config=JSHint: 無法定位擴展配置
jshint.config.error.cannot.parse.ext.config=JSHint: 無法解析擴展配置
jshint.latedef.false.text=不警告
jshint.latedef.true.text=禁止變數在未定義的情況下使用
jshint.latedef.nofunc.text=<html><body>禁止變數在未定義的情況下使用，<br>但允許函數宣告。</body></html>
jshint.unused.false.text=不檢查任何內容
jshint.unused.true.text=<html><body>檢查所有變量和參數，但允許<br>使用的參數後存在未使用參數</body></html>
jshint.unused.vars.text=檢查變數，而不是函數參數
jshint.unused.strict.text=檢查所有變量和參數
jshint.progress.title.updating.jshint=正在將 JSHint 更新到 {0}
jshint.progress.title.downloading=正在下載 {0}
jshint.progress.title=JSHint {0}
jshint.quotmark.false.text=允許兩種引號
jshint.quotmark.true.text=僅允許單引號或雙引號
jshint.quotmark.single.text=僅允許單引號
jshint.quotmark.double.text=僅允許雙引號
jshint.inspection.message.duplicate.options=重複 JSHint 選項: {0}，{1}。
jshint.inspection.message.unexpected.jshint.option.name=意外的 JSHint 選項名稱
jshint.inspection.message.unexpected.value=意外值
jshint.inspection.message.expected.values.x.or.y=預期值: {0} 或 {1}
jshint.inspection.message.expected.value=預期值: {0}
jshint.inspection.message.object.or.array.expected=應為物件或陣列
jshint.inspection.message.not.loaded=未載入 JSHint {0}
jshint.inspection.message.config.not.found=未找到 JSHint 配置
jshint.inspection.message.malformed.config=JSHint 配置格式錯誤
jshint.inspection.message.prefix=JSHint:

jshint.option.esversion.description.short=在與指定的 ECMAScript 版本不相容時發出警告
jshint.option.latedef.description.short=當變數在未定義的情況下使用時發出警告
jshint.option.unused.description.short=存在未使用的變數時發出警告
jshint.option.indent.description.short=縮排
jshint.option.quotmark.description.short=引號
jshint.option.predef.details=指定全域變數及其可分配狀態:\\\\n<pre>DISQUS:true、jQuery:false</pre>\\\\n<p/>此時，JSHint 允許您覆寫 DISQUS，但禁止覆寫 jQuery。
jshint.option.bitwise.description.short=有關使用逐位運算符的警告
jshint.option.camelcase.description.short=有關變數命名的警告
jshint.option.curly.description.short=塊省略 <code>{}</code> 時發出警告
jshint.option.enforceall.description.short=程式碼未遵守最嚴格的配置時發出警告
jshint.option.eqeqeq.description.short=有關不安全比較的警告
jshint.option.es3.description.short=有關與 ES3 規範不相容的警告
jshint.option.es5.description.short=有關與 ES5 規範不相容的警告
jshint.option.forin.description.short=有關不安全 <code>for..in</code> 的警告
jshint.option.freeze.description.short=有關覆蓋原生物件原型的警告
jshint.option.immed.description.short=有關未使用括號將函數括起來而直接調用函數的警告
jshint.option.newcap.description.short=有關使用非大寫形式的構造函數的警告
jshint.option.noarg.description.short=有關 <code>arguments.caller</code> 和 <code>.callee</code> 的警告
jshint.option.nocomma.description.short=有關使用逗號運算符的警告
jshint.option.noempty.description.short=有關空塊的警告
jshint.option.nonbsp.description.short=有關“不間斷空格”字符的警告
jshint.option.nonew.description.short=有關副作用 <code>new</code> 用法的警告
jshint.option.plusplus.description.short=有關使用一元遞增和遞減運算符的警告
jshint.option.undef.description.short=未定義變數時發出警告
jshint.option.varstmt.description.short=有關使用 VariableStatements 的警告
jshint.option.strict.description.short=程式碼未採用嚴格模式時發出警告
jshint.option.trailing.description.short=有關尾隨空格的警告
jshint.option.maxparams.description.short=函數中的最大參數數量
jshint.option.maxdepth.description.short=塊的最大深度
jshint.option.maxstatements.description.short=函數中的最大語句數量
jshint.option.maxcomplexity.description.short=程式碼中的最大迴圈復雜度
jshint.option.maxlen.description.short=行的最大長度
jshint.option.asi.description.short=禁止缺少分號的警告
jshint.option.boss.description.short=禁止有關 <code>if/for/…</code> 內部賦值的警告
jshint.option.debug.description.short=禁止有關調試模式的警告
jshint.option.elision.description.short=禁止有關 ES3 陣列省略元素的警告
jshint.option.eqnull.description.short=禁止有關 <code>== null</code> 的警告
jshint.option.esnext.description.short=EcmaScript.next
jshint.option.evil.description.short=禁止有關 <code>eval</code> 的警告
jshint.option.expr.description.short=禁止有關將表達式用作語句的警告
jshint.option.funcscope.description.short=禁止有關在已宣告塊外部使用變數的警告
jshint.option.futurehostile.description.short=有關使用在以後的 JavaScript 版本中定義的關鍵字的警告
jshint.option.gcl.description.short=將 JSHint 設為與 Google Closure Compiler 相容
jshint.option.globalstrict.description.short=禁止有關使用全域嚴格模式的警告
jshint.option.iterator.description.short=禁止有關 <code>__iterator__</code> 屬性的警告
jshint.option.lastsemic.description.short=禁止有關缺少分號的警告，但僅當單行塊中的最後一條語句省略分號時才顯示該警告
jshint.option.laxbreak.description.short=禁止有關不安全換行的警告
jshint.option.laxcomma.description.short=禁止有關編碼樣式以逗號開頭的警告
jshint.option.loopfunc.description.short=禁止有關函數在迴圈內部的警告
jshint.option.moz.description.short=檢查程式碼是否使用 Mozilla JavaScript 擴展
jshint.option.multistr.description.short=禁止有關多行字串的警告
jshint.option.notypeof.description.short=禁止有關無效 <code>typeof</code> 運算符值的警告
jshint.option.proto.description.short=禁止有關 <code>__proto__</code> 屬性的警告
jshint.option.scripturl.description.short=禁止有關使用以腳本為目標的 URL 的警告
jshint.option.smarttabs.description.short=在空格僅用於對齊時，禁止有關將制表符和空格混合使用的警告
jshint.option.shadow.description.short=禁止有關變數隱藏的警告
jshint.option.singlegroups.description.short=如果未嚴格要求使用分組運算符，禁止使用該運算符
jshint.option.sub.description.short=如果可以使用點符號表示 <code>[]</code> 符號，則禁止有關使用後者的警告
jshint.option.supernew.description.short=禁止有關“怪異”構造的警告
jshint.option.validthis.description.short=禁止有關可能違反嚴格要求的警告
jshint.option.withstmt.description.short=禁止有關使用 with 語句的警告
jshint.option.noyield.description.short=禁止在生成器函數中無 yield 語句時有關生成器函數的警告
jshint.option.browser.description.short=瀏覽器
jshint.option.devel.description.short=開發
jshint.option.nonstandard.description.short=轉義和未轉義
jshint.option.typed.description.short=輸入的陣列
jshint.option.worker.description.short=Web 工作執行緒
jshint.option.wsh.description.short=Windows Script Host
jshint.option.module.description.short=ECMAScript 6 模組
jshint.option.nomen.description.short=不允許使用 _ in 變數
jshint.option.onevar.description.short=每個函數一個變數語句
jshint.option.passfail.description.short=出現第一個錯誤時停止
jshint.option.white.description.short=不允許使用雜亂的空格
jshint.option.maxerr.description.short=最大錯誤數
jshint.option.predef.description.short=預定義(以 , 分隔)

#common linters
javascript.linter.import.error.timeout.processing.configuration.file=處理配置檔案時超時
javascript.linter.import.error.generic=套用配置檔案中的程式碼樣式規則時出錯，可能是配置檔案無效。
javascript.linter.import.error.package.not.found=無法找到 ''{0}'' 軟體套件
javascript.linter.import.error.entry.point.not.found=無法在 ''{0}'' 軟體套件中找到入口點
javascript.linter.import.error.bin.file.not.found=無法 ''{1}'' 軟體套件下找到 ''{0}''
javascript.linter.import.notification={0}：專案程式碼樣式和編輯器設定基於 ''{1}'' 更新。
javascript.linter.import.notification.edit=編輯 ''{0}''
javascript.linter.import.notification.rules.applied=套用了以下 {0}：{1}。
javascript.linter.import.notification.reset=重置
javascript.linter.import.notification.restored=預設程式碼樣式和編輯器設定已恢復
javascript.linter.import.translate.config.title=套用 ESLint 程式碼樣式規則
javascript.linter.import.translate.config.description=套用 ESLint 程式碼樣式規則
javascript.linter.import.translate.config.progress.title=套用 {0} 程式碼樣式規則
javascript.linter.import.translate.config.file.error=無法套用程式碼樣式規則
javascript.linter.import.nothing.to.import={0}：已套用所有已知規則
javascript.linter.use.severity.from.config.label=使用配置檔案中的規則嚴重性
javascript.linter.configuration.file.title=配置檔案
javascript.linter.radio.button.configuration.file=配置檔案(&C):
javascript.linter.error.empty.path=路徑為空
javascript.linter.error.no.such.file=沒有此類檔案
javascript.linter.error.specify.correct.path.to=指定 {0} 的正確路徑
javascript.linter.error.failed.to.lint=Lint {0} 失敗
javascript.linter.error.can.not.find.psi.file=無法找到 {0} 的 PSI 檔案
javascript.linter.error.can.not.find.document=無法找到 {0} 的文檔
javascript.linter.error.notification.problem.with.reformatting=重新設定 {0} 的格式時出現問題:<br/>{1}
javascript.linter.error.no.path.to.package=指定 ''{0}'' 軟體套件的路徑
javascript.linter.error.package.not.installed=安裝 ''{0}'' 軟體套件
javascript.linter.error.invalid.path.to.package=指定 ''{0}'' 軟體套件的正確路徑
dialog.message.please.specify.stylelint.package.correctly=正確指定 Stylelint 軟體套件: 找不到 Stylelint 二進制檔案
stylelint.action.fix.problems.description=通過調用 'stylelint --fix' 修正 Stylelint 問題
stylelint.action.modal.title=Stylelint 修正
stylelint.action.background.title=正在執行 stylelint --fix…

javascript.linter.action.edit.config=編輯 {0}
javascript.linter.action.edit.property=編輯 {1} 中的 {0}
javascript.linter.action.edit.settings.text={0}設定…
javascript.linter.action.fix.prompt=使用 {0} 重新格式化選定的檔案?
javascript.linter.action.fix.problems.file.text={0}：修復當前檔案
javascript.linter.action.fix.problems.name=修復 {0} 問題
javascript.linter.action.fix.problems.name.start=已開始修復 {0} 問題
javascript.linter.action.fix.problems.name.finish=已結束修復 {0} 問題
javascript.linter.configurable.config.autoSearch.title=自動搜尋 (&S)
javascript.linter.suppress.rules.for.line.family.name=對當前行禁止
javascript.linter.suppress.rule.for.line.description=禁止當前行的 ''{0}''
javascript.linter.suppress.all.rules.for.line.description=禁止當前行的所有 {0} 規則
javascript.linter.suppress.rules.for.file.family.name=對當前檔案禁止
javascript.linter.suppress.rule.for.file.description=禁止當前檔案的 ''{0}''
javascript.linter.suppress.all.rules.for.file.description=禁止當前檔案的所有 {0} 規則
javascript.linter.progress.reformatting.with=正在使用 {0} 重新格式化…

javascript.linter.intention.name.details=詳細資訊
javascript.linter.intention.family.name.show.details={0}: 顯示詳細資訊

# eslint
settings.javascript.linters.eslint.configurable.name=ESLint
eslint.configurable.eslintPackage.label=ESLint 軟體套件(&E)：
eslint.configurable.config.autoSearch.description.bodyInnerHtml=ESLint 將在要 lint 的檔案的目錄中以及連續的父目錄中尋找 .eslintrc.* 和 package.json 檔案，直至尋找到檔案系統的根目錄。<div style=\\"padding-top:8px\\">要使用 package.json，請將您的配置添加到 <code>eslintConfig</code> 屬性下。</div>
eslint.configurable.label.working.directories=工作目錄(&W):
eslint.configurable.working.dir.field.empty.text=由最近的 .eslintrc 或 .eslintignore 檢出
eslint.configurable.working.directories.comment=<html>路徑或 <a href='https://github.com/isaacs/node-glob#glob-primer'>glob 模式</a>，以分號分隔。為自動檢測留空。</html>
eslint.configurable.config.select.config.text=選擇 ESLint 配置檔案（*.eslintrc.*）
eslint.configurable.additionalRulesDir.label=其他規則目錄 (&R)：
eslint.configurable.additionalRulesDir.browseDialogTitle=選擇 ESLint 其他規則目錄
eslint.configurable.extraOptions.label=額外 eslint 選項 (&O)：
eslint.run.for.files.label=為檔案執行(&F):
eslint.files.pattern.comment=<html>使用 <a href=''https://github.com/isaacs/node-glob#glob-primer''>glob 模式</a>，例如，<code>{**/*,*}.{js,ts}</code></html>
eslint.run.on.save=儲存時執行 eslint --fix(&U)
eslint.action.fix.problems.description=通過調用 'eslint --fix' 修正 ESLint 問題
eslint.fix.problems.text.with.error.code={0}: 修復 ''{1}''
eslint.fix.problems.text.current={0}: 修復當前錯誤
eslint.fix.problems.family.name={0}: 修復當前錯誤
eslint.error.package.directory.expected=應為軟體套件目錄
eslint.code.style.apply.message=套用 ESLint 的程式碼樣式?
eslint.code.style.dismiss.text=否
eslint.code.style.apply.text=是
eslint.version.0.is.not.supported.please.upgrade.eslint=ESLint 版本 {0} 不受支援。請升級 ESLint。
eslint.additional.rules.directory.field.name=其他規則目錄
eslint.configuration.file.field.name=ESLint 配置檔案
eslint.inspections.error.can.not.parse.message=無法解析訊息，應為 JSON 物件，但實際為: {0}
eslint.inspections.error.messages.not.array=訊息不是陣列: {0}
eslint.inspections.error.unexpected.language.service.response=意外的語言服務響應: {0}
eslint.inspections.error.unknown.message.severity=未知的訊息嚴重程度: {0}\\\\n主體:\\\\n{1}

#standardJS
standardjs.name=標準程式碼樣式
standardjs.editor.notification.can.be.enabled.text=為此專案使用 JavaScript 標準程式碼樣式？
standardjs.editor.notification.action=是
standardjs.editor.notification.do.not.show.text=否
standardjs.edit.settings.caption=ESlint/標準程式碼樣式
standardjs.action.fix.problems.description=修正標準程式碼樣式問題
standardjs.error.unsupported.package=不支持的軟體套件版本。請將 ''Standard'' 軟體套件升級到最低版本 {0}。
standardjs.codestyle.updated={0}: 專案程式碼樣式設定已更新
standardjs.codestyle.updated.config.section={0}: 專案程式碼樣式設定已根據 package.json 中的 ''standard'' 部分更新
standardjs.codestyle.updated.dependency={0}: 專案程式碼樣式設定已根據 package.json 中的 ''standard'' 依賴項更新

# Actions
js.show.type.info.action.error=找不到表達式
javascript.ignore.unused.function.parameters=忽略未使用的參數:
javascript.ignore.unused.catch.parameters=忽略未使用的 catch 參數
complete.import.binding=完整的匯入綁定
complete.import.name=完整的匯入名稱
remove.type.prefix=移除類型前綴
add.import.binding.to.import=將匯入綁定添加到匯入
add.import.specifier.to.import=將匯入說明符添加到匯入
create.js.file.description=從指定的模板創建 JavaScript 檔案
create.ts.file.description=創建新的 TypeScript 檔案
create.file.name=創建檔案 ''{0}''
create.file.name.with=使用 {1} 創建檔案 ''{0}''
create.file.name.with.and=使用 {1} 和 {2} 創建檔案 ''{0}''
class.names={0,choice,1#類|2#類} {1}
function.names={1}{0,choice,1#函數|2#函數} 

# todo remove, has external usages
javascript.completion.several.definitions=（多個定義）

# File watchers
js.file.watcher.6to5.description=使用 Babel 將 ECMAScript 6 程式碼轉成 ECMAScript 5
editor.notification.label.enable.babel.file.watcher.question=是否啟用 File Watcher 以使用 Babel 將 ECMAScript 6 轉換為 ECMAScript 5?

# Annotator
typescript.export.assignment.cannot.be.used.in.internal.modules=匯出不能在內部模組中使用的賦值
typescript.type.predicate.not.return=僅函數和方法的返回類型位置允許類型謂詞
typescript.type.this.predicate.not.return=僅類或接口成員、get 存取器或函數和方法的返回類型位置允許基於 'this' 類型的謂詞。
typescript.type.predicate.not.match.name=找不到參數 {0}
typescript.type.predicate.rest=類型謂詞不能引用 rest 參數
typescript.type.predicate.destructuring=類型謂詞不能引用綁定模式中的元素。
typescript.type.predicate.incompatible.types=類型謂詞不可分配給 {0}
typescript.generics.should.not.be=類型 ''{0}'' 非泛型
es6.default.export.not.declared=未在匯入的模組中宣告預設匯出
js.annotator.assignment.pattern.rhs=賦值模式必須位於賦值的左側
es6.generate.index.action=生成 index.js/index.ts
es6.generate.index.action.description=生成 index.js/index.ts
js.annotator.thin.arrow.used=使用了細箭頭
js.annotator.newline.before.arrow=箭頭前不允許換行符
js.annotator.replace.with.fat.arrow=取代為粗箭頭
js.annotator.unary.operator.within.exponential=一元運算符 ''{0}'' 不允許直接位於指數表達式之前。建議添加括號以解決歧義問題。

# Live templates
jsx.html.context.type=JSX HTML
js.expression.context.type=表達式
js.statement.context.type=語句
js.top.level.statement.context.type=頂級語句
js.class.context.type=類/接口
ecmascript.6.or.higher=ECMAScript 6 或更高版本

# Gulp
gulp.rc.gulpfile.label=Gulpfile (&F)：
gulp.rc.gulpfile.browseDialogTitle=選擇 gulpfile.js
gulp.rc.tasks.label=任務(&T):
gulp.rc.arguments.label=參數 (&R)：
gulp.rc.nodeInterpreter.label=節點解釋器(&I):
gulp.rc.nodeOptions.label=節點選項(&O):
gulp.rc.gulpPackage.label=Gulp 軟體套件(&G)：
gulp.rc.environmentVariables.label=環境(&E):
gulp.task.title=Gulp 任務
gulp.before.run.task=執行 gulp 任務
gulp.before.run.task.descr=執行 gulp {0, choice,0#任務|1#任務 |2#任務 }{1} [{2}]
gulp.gulpfile.unspecified=未指定 Gulpfile
gulp.gulpfile.not.found=未找到 Gulpfile

# Grunt
grunt.rc.gruntfile.label=Gruntfile (&F)：
grunt.rc.gruntfile.browseDialogTitle=選擇 Gruntfile
grunt.rc.tasks.label=任務(&T):
grunt.rc.arguments.label=參數 (&R)：
grunt.rc.nodeInterpreter.label=節點解釋器(&I):
grunt.rc.nodeOptions.label=節點選項(&O):
grunt.rc.gruntCliPackage.label=軟體套件 grunt-cli (&P)：
grunt.rc.environmentVariables.label=環境(&E):
grunt.task.title=Grunt 任務
grunt.before.run.task=執行 Grunt 任務
grunt.before.run.task.descr=執行 Grunt {0, choice,0#任務|1#任務 |2#任務 }{1} [{2}]
grunt.unspecified.gruntfile=未指定 Gruntfile
grunt.gruntfile.not.found=未找到 Gruntfile

#node
settings.nodejs.name=Node.js
settings.nodejs.coding.assistance.label=Node.js 編碼協助 (&A)：
settings.nodejs.coding.assistance.manage.scopes.label=管理範圍…

node.interpreter.label=Node 解釋器(&I):
node.interpreter.unspecified.error.text=指定 Node.js 解釋器
node.package.manager.label=軟體套件管理器 (&M)：
node.package.empty.hint={0} 軟體套件目錄路徑
node.package.empty.hint.pkg1.or.pkg2={0} 或 {1}
node.package.selector.single.package.title=選擇 {0} 軟體套件目錄
node.package.selector.multiple.packages.title=選擇軟體套件目錄
node.package.selector.multiple.packages.description=選擇 {0}
node.package.none=無軟體套件
node.package.dropDownList.select=選擇…

node.js.modules.dependencies.missing.family.name=缺少 require() 調用
inspection.NodeCoreCodingAssistanceInspection.no.coding.assistance.message=Node.js 的編碼輔助已禁用
action.ToggleNodeCoreCodingAssistanceAction.toggle.coding.assistance.for.node.js.text=切換 Node.js 的編碼輔助

# npm
npm.rc.packageJson.label=package.json (&P)：
npm.rc.packageJson.browseDialogTitle=選擇 package.json 檔案
npm.rc.command.label=命令(&C):
npm.rc.scripts.label=腳本 (&T)：
npm.rc.scriptsArguments.label=參數 (&R)：
npm.rc.nodeInterpreter.label=節點解釋器(&I):
npm.rc.nodeOptions.label=節點選項 (&O)：
npm.rc.environmentVariables.label=環境:
npm.task.title=NPM 腳本
npm.before.run.task=執行 npm 腳本
npm.before.run.task.descr=執行 npm {0, choice,0#腳本|1#腳本|2#腳本}{1} [{2}]
npm.dialog.message.cannot.resolve.package.manager=無法解析 ''{0}'' 軟體套件管理器
npm.no.scripts.found=未找到腳本
dialog.message.unspecified.package=未指定 {0} 軟體套件
dialog.message.invalid.package.file.specified.but.directory.with.package.json.expected={0} 軟體套件無效: 指定了一個檔案，但應為包含 package.json 的目錄
dialog.message.invalid.package.no.such.directory=無效的 {0} 軟體套件: 無此類目錄
dialog.message.invalid.npx.command=無效的 npx 命令
dialog.message.package.yarn.installed.package.format.yarn.relative.path.to.package.json.package.name={0}軟體套件: Yarn 安裝的軟體套件格式為 ''yarn:[package.json 的相對路徑]:[軟體套件名稱]''。
dialog.message.no.path.to.package.json.found=未找到 package.json 的路徑。
dialog.message.unspecified.package.name=未指定軟體套件名稱。
dialog.message.invalid.package.no.such.file=無效的 {0} 軟體套件: 無此類檔案
enable.notifications.about.installing.dependencies.from.package.json=啟用有關從 package.json 安裝依賴項的通知
notification.content.notifications.are.enabled.for.current.package.json=為當前 package.json 啟用通知
notification.content.notifications.are.enabled.for.all.package.json.files=為所有 package.json 檔案啟用通知
dialog.message.please.specify.npm.or.yarn.package.cannot.find.inside.directory=請指定 npm 或 yarn 軟體套件: 在“{1}”中找不到“{0}”
dialog.message.please.correct.path.to.npm.or.yarn.package.no.such.directory=請更正 npm 或 yarn 軟體套件的路徑: 無此類目錄“{0}”

# Build tools
buildTools.JsbtRunTaskAction.text=執行 Gulp/Grunt/npm 任務
buildTools.JsbtAddBuildfileAction.text=添加 {0}
buildTools.choose_buildfile.text=選擇 {0}
buildTools.JsbtRemoveBuildfileAction.text=移除 {0}
buildTools.JsbtReloadTasksAction.text=重新載入任務
buildTools.JsbtReloadTasksAction.npm.text=重新載入腳本
buildTools.JsbtShowTasksAction.text=顯示 {0} 任務
buildTools.JsbtShowTasksAction.npm.text=顯示 npm 腳本
buildTools.searchEverywhere.text=執行 ''{0}'' 任務
buildTools.searchEverywhere.npm.text=執行 ''{0}'' npm 腳本
buildTools.ShowSettingsAction.text={0}設定…
buildTools.ShowSettingsAction.npm.text=編輯 npm 配置(&E)…
buildTools.EditRunSettingsAction.text=編輯 ''{0}'' 設定(&E)…
buildTools.tree.sortBy.text=排序方式
buildTools.tree.sortBy.definitionOrder.text=定義順序
buildTools.tree.sortBy.name.text=名稱
buildTools.no.tasks.found=未找到任務
buildTools.edit.run.configuration=編輯執行配置
buildTools.no.files.added=未添加檔案
buildTools.add.with=使用 {1} 添加 {0}
buildTools.no.such.file=沒有此類檔案
buildTools.failed.to.list.tasks=無法列出任務
buildTools.failed.to.list.tasks.details.reference=詳細資訊
buildTools.tooltip.click.to.show.error.details=點擊以顯示錯誤詳細資訊

#npm modules
npm.modules.inspection.content.of.require.not.in.dependencies.warning=package.json 依賴關係中未列出模組
npm.modules.inspection.content.of.require.module.not.installed.warning=未安裝模組
npm.modules.install.global.types.fix.name=安裝 TypeScript 定義以提供更好的類型資訊
package.json.install.types.fix.family.name=為軟體套件安裝 @types
node.js.quickfix.install.node.module.with.dev.dependencies.text=安裝 ''{0}'' 作為開發依賴關係
node.js.quickfix.install.node.module.text=安裝 ‘’{0}''
node.js.quickfix.install.node.module.family.name=安裝模組
node.js.quickfix.install.node.module.devDependencies.family.name=安裝模組作為開發依賴關係
node.js.quickfix.install.node.module.update.modules.family.name=執行 'npm install'
node.js.quickfix.run.command=執行 ''{0}''
node.js.quickfix.install.node.module.error.prefix.text=無法安裝 Node.js 模組：{0}
node.js.quickfix.install.node.module.error.no.interpreter.text=無法安裝 Node.js 模組：請指定預設 Node.js 解釋器。
node.js.quickfix.install.node.module.error.no.interpreter.title=安裝 Node.js 模組
node.js.select.file=選擇 {0} 檔案
dialog.message.cannot.determine.package.json.directory=無法確定 package.json 目錄
action.InstallNodeLocalDependencies.text=安裝 Node.js 依賴項
action.InstallNodeLocalDependencies$Root.text=為 {1} 執行 ''{0}''

typescript.types.module.not.installed.warning=無法解析模組 ''{0}'' 的定義
npm.modules.install.global.types.directory.error=無法創建所需的目錄
npm.modules.install.global.types.dialog.title=安裝 TypeScript 定義

typescript.types.union=聯合
typescript.types.intersection=相交
typescript.types.mapped=映射
typescript.types.key=鍵引用
typescript.types.merged=已合併
typescript.types.merged.accessor=合併存取器
typescript.types.type.member={0} 類型屬性
typescript.types.merged.parts=引用的屬性：

# Intentions
ts.generate.reference.path.name=生成引用路徑註釋
ts.add.import.statement.family.name=添加 import 語句
ts.add.import.statement.dialog.title=添加 import 語句
ts.add.import.all.family.name=添加所有明確的匯入
ts.add.import.hint.text=使用 {1} 添加 {0}
ts.add.import.hint.multiple.text=使用  {1} 為 {0} 添加匯入
ts.add.import.hint.all.part=或全部使用 {0} 匯入
ts.change.import.action.one.title=更改為 {0}
ts.change.import.action.many.title=更改匯入…
ts.change.import.action.command=更改匯入
ts.change.import.action.family.name=更改 ES6 匯入路徑
ts.change.import.action.dialog.title=匯入自…
ts.convert.alias.to.interface.action.title=將別名轉換為接口
ts.convert.alias.to.interface.action.family.name=將類型別名轉換為接口
ts.convert.alias.to.enum.action.title=將別名轉換為枚舉
ts.convert.alias.to.enum.action.family.name=將類型別名轉換為枚舉
ts.convert.parameter.property.to.field=將參數屬性轉換為欄位
ts.convert.field.to.parameter.property=將欄位轉換為參數屬性
anonymous.to.named.intention.function.name=函數名稱：
initialize.fields.intention.visibility=可見性:
command.name.import=匯入 {0}
please.specify.package.manager=指定<a href=\\"\\">軟體套件管理器</a>。
intention.name.add.file.to.tsconfig=將檔案 ''{0}'' 添加到 tsconfig.json
intention.name.import.augmentation=匯入增強 {0}

# Language Service
javascript.language.service.default.empty.text=無錯誤
javascript.language.service.tracking.disabled=錯誤跟踪已禁用
javascript.language.service.tracking.is.not.started=服務未啟動
javascript.language.service.default.project.errors=顯示專案錯誤
javascript.service.node.error=節點解釋器路徑不正確。請檢查解釋器設定
javascript.starting.service=啟動 {0} 服務
javascript.language.service.cannot.get.results=無法從語言服務獲得結果
javascript.language.service.start.timeout=啟動語言服務進程超時
javascript.language.service.cannot.start=無法啟動語言服務進程
cannot.parse.service.initialization.answer.0=無法解析服務初始化回復 {0}\\\\n
tab.title.errors=錯誤
tab.title.project.errors=專案錯誤
tab.title.compile.errors=編譯錯誤
dialog.message.no.results.for.after={1} 之後沒有 {0} 的結果
intention.name.loading.service.fixes=正在載入服務修正…

# TypeScript Compiler
typescript.compiler.notification.editor.configure=配置 TypeScript…
typescript.compiler.configurable.name=TypeScript
typescript.use.service.configurable.options.enable=TypeScript 語言服務
typescript.compiler.configurable.options.output.path=使用輸出路徑：
typescript.compiler.configurable.options.compile.main=僅編譯主檔案：
typescript.compiler.configurable.options.compile.main.error=主檔案的路徑不正確
typescript.compiler.configurable.options.version=TypeScript:
typescript.compiler.configurable.options.generate.source.map=生成源映射
typescript.compiler.configurable.options.enable.no.config=也針對沒有 tsconfig.json 的專案
typescript.compiler.configurable.options.track.file.system=在更改時重新編譯
typescript.compiler.configurable.options.scope=編譯範圍：
typescript.compiler.configurable.options.command.line=選項:
dialog.message.cannot.compile.typescript.config.file.incorrect=無法編譯 TypeScript。配置檔案不正確。
intention.family.name.suppress.with.ts.ignore=使用 @ts-ignore 禁止
typescript.compiler.structure.tab.title=結構
typescript.compiler.starting=TypeScript 正在啟動…

typescript.service.no.config=檔案未包括在任何 tsconfig.json 中
typescript.service.no.main.reference=檔案未處理，因為沒有從主檔案引用


js.tool.window.limit=顯示前 {0} 個錯誤。
js.tool.window.limit.all=查看所有 {0} 個錯誤
typescript.compiler.action.compile.all=全部編譯
typescript.compiler.action.compile.toolbar=編譯
typescript.compiler.action.compile.all.description=編譯所有專案檔案
typescript.service.action.restart=重啟{0}
typescript.compiler.action.compile.all.compile.config=配置 {0} 的編譯檔案
typescript.compiler.action.compile.current=編譯當前檔案
typescript.compiler.action.compile.simple=編譯 TypeScript
typescript.compiler.action.compile.description=編譯當前專案
typescript.compiler.action.no.compile.message=檔案未編譯，因為沒有從主檔案引用
typescript.compiler.before.run=編譯 TypeScript

typescript.language.service.clean=正在重置快取…
typescript.language.service.compile.file=正在編譯檔案... {0}
typescript.language.service.compile.project=正在編譯專案… {0}
typescript.language.service.compile.file.errors=正在計算錯誤... {0}
typescript.language.service.compile.project.errors=正在計算專案錯誤... {0}
typescript.language.service.compile.project.open.file=正在打開檔案... {0}

typescript.before.task.check.errors=檢查錯誤
typescript.before.task.config.path=配置檔案：
typescript.before.task.title=TypeScript 編譯設定
typescript.before.task.config.dialog.title=選擇 tsconfig.json

# Documentation
js.documentation.fires=觸發：
js.documentation.more.overload=其他 {0} 個多載
js.documentation.more.overloads=其他 {0} 個多載

node.js.remote.interpreters.plugin.missing=缺少 Node.js 遠端解釋器套件。請啟用 {0} 中的套件

# Module Dependencies
javascript.module.dependencies.got.it.title=模組依賴關係圖
javascript.module.dependencies.got.it.text=<div align='left'>此圖顯示所選檔案或目錄具有的模組依賴關係。<br/>要查看多個檔案或目錄的依賴關係，請在<i>專案檢視</i><br/>中將其選定，然後從所選專案右鍵選單中選擇<i>圖 – 顯示圖</i>。</div>
javascript.module.dependencies.empty.got.it.text=<div align='left'>當前檔案或資料夾沒有任何依賴關係。<br/>請嘗試使用其他檔案或資料夾。</div>
modules.selected=選定

js.remove.redundant.initializer.fix=移除冗餘的初始值設定項
js.remove.unused.assignment=移除未使用的賦值
js.inject.with.comment.intention.family.name=使用註釋對注射做出註解
js.inject.dont.format.intention.text=禁用注入內容的格式設定

js.webpack.config.highlighting.name=Webpack 配置符合 JSON 架構

js.linter.guesser.linter.enabled.because.of.dependency=已啟用 {0}：''{1}'' 列出在 package.json 中。
js.linter.guesser.linter.enabled.because.of.package.json.section=已啟用 {0}：''{1}'' 位於 package.json 中。
js.linter.guesser.linter.enabled.because.of.config.file=已啟用 {0}：配置檔案位於專案中。
js.linter.guesser.linter.disabled={0} 已禁用。

# Breadcrumbs
js.breadcrumbs.callback.for=\\\\ {0}() 回調

typescript.extract.type.alias.name=類型別名…
typescript.include.js.sources.element=搜尋 JavaScript 宣告
typescript.include.js.sources.dialog.title=包括軟體套件 {0}
typescript.include.js.sources.dialog.message=是否在此專案中包含 ''{0}'' 中的 JavaScript 檔案?
start.template.string.interpolation.on.typing=鍵入 '$' 時啟動模板字串插值
typescript.include.js.sources.action=包括 JavaScript 檔案
escape.pasted.text=在貼上字串文字時轉義文本
jsx.convert.html.attributes.to.jsx=將 HTML 貼上到 JSX 檔案時轉換特性

# Rename member
rename.prompt.do.you.want.to.rename.base.method=要重命名基方法嗎?
js.rename.base.member=重命名基{0}
js.rename.current.member=重命名當前 {0}
js.rename.member.title={0} {1} {3} 的 {2}
js.rename.member.title.implements=實作
js.rename.member.title.overrides=覆寫

# Generate dialog
generate.filter.indexers=索引器
generate.filter.methods=方法
generate.filter.fields=欄位和屬性
generate.filter.button.tooltip=顯示 {0}
generate.filter.button.description=在列表中顯示 {0} 
codestyle.ui.field.prefix=欄位前綴 (&F)：
codestyle.ui.property.prefix=屬性前綴 (&P)：
codestyle.ui.file.name.style=檔案命名慣例 (&N)：
codestyle.ui.generated.jsdoc.use.types.checkbox=在 JSDoc 中包括類型 (&T)
inline.type.used.in.reference.list=無法在''{0}'' 列表中內聯用法
inline.cannot.inline.references.this.type=無法內聯引用 'this' 類型的接口
inline.cannot.inline.has.supers=無法內聯擴展其他類型的 {0} 
generation.bindable.event=可綁定事件(&B):
generation.event.constant=事件常數(&E):

refactoring.extract.react.component.component.for.refactor.this=提取組件…
refactoring.extract.react.component.title=提取組件
refactoring.extract.react.component.no.expression=所選內容不構成 JSX 表達式
refactoring.extract.react.component.no.scope=找不到用於放置所創建組件的範圍
refactoring.create.react.component.title=創建組件
refactoring.react.function.to.class.refactoring.title=轉換為類組件
refactoring.react.function.to.class.intention.title=轉換為類組件
refactoring.react.function.to.class.used.in.new.conflict=\\\\ ''new'' 表達式中使用了 {0}
refactoring.react.function.to.class.used.in.call.conflict=調用表達式中使用了 {0}
refactoring.react.class.to.function.conflict.used.with.ref={0} 與 ''ref'' 特性結合使用。無法為無狀態函數組件提供 ref
refactoring.react.class.to.function.refactoring.title=轉換為函數組件
refactoring.react.class.to.function.intention.title=轉換為函數組件
refactoring.react.could.not.find.in.template=無法重構。找不到名稱為 {0} 的元素。可能的程式碼模板 {1} 無效嗎？
react.function.to.class.caret.at.function=文本游標應置於要轉換的函數處
react.class.to.function.caret.at.class=文本游標應置於要轉換的類處
react.class.component.type.class=類
react.class.component.type.function=函數

js.arrangement.group.arrow.fields.with.methods=使用包含方法的箭頭函數初始化組欄位
intellilang.tagged.literal.injection.name.label=模式:
intellilang.tagged.literal.expression.border.title=模板標籤

refactoring.destructuring.vars.for.refactor.this=物件或陣列析構…
refactoring.destructuring.vars.intention.name=引入物件或陣列析構
refactoring.destructuring.vars.intention.name.object=引入物件析構
refactoring.destructuring.vars.intention.name.array=引入陣列析構
refactoring.destructuring.vars.intention.replace.object=取代為物件析構
refactoring.destructuring.vars.intention.replace.array=取代為數組析構
refactoring.destructuring.vars.intention.replace.promise=取代為 'await Promise.all'
refactoring.destructuring.vars.intention.propagate=傳播到析構宣告
refactoring.destructuring.vars.intention.depropagate=將析構取代為屬性和索引存取
refactoring.destructuring.vars.intention.deconstruct=生成析構模式
refactoring.destructuring.vars.intention.replace.shorthand=取代為析構和速記屬性
refactoring.destructuring.vars.intention.const.to.var.warning=在轉換期間，高亮顯示的 const 變數將轉換為 let 變數。\\\\n要繼續嗎？
refactoring.destructuring.vars.intention.const.to.var.warning.title=變數關鍵字更改
refactoring.destructuring.vars.intention.guard.conflict=通過類型防護將表達式類型限縮為 ''{0}''，該類型防護在重構後將不起作用
javascript.intention.add.export.family.name=添加匯出
javascript.intention.add.export.fix.text=將 {0} 匯出在檔案 {1} 中
javascript.intention.add.default.export.family.name=添加預設匯出
javascript.intention.remove.export.family.name=移除匯出
javascript.intention.remove.export.inaccessible.conflict.text={0} 在 {1} 中進行了使用
javascript.intention.promise.to.async.name=轉換為異步功能
javascript.intention.code.optimizations.text=正在優化生成的程式碼
javascript.intention.add.template.argument=插入模板字串實參
javascript.intention.call.chain.to.pipe=將嵌套調用取代為管道表達式
javascript.intention.pipe.to.call.chain=將管道表達式取代為嵌套調用
javascript.intention.opt.chain.family=使用可選鏈接或空值合併
javascript.intention.opt.chain.chain.only=使用可選鏈接
javascript.intention.opt.chain.coalesce.only=使用空值合併
javascript.intention.opt.chain.conditional.only=使用 '||'
javascript.intention.opt.chain.chain.and.coalesce=使用可選鏈接和空值合併
javascript.intention.expand.opt.chain.family=將可選鏈接或空值合併擴展到顯式檢查
javascript.intention.expand.opt.chain=展開可選鏈接
javascript.intention.expand.nullish.coalescing=展開空值合併
javascript.intention.expand.or.coalescing=使用 ?: 運算符
javascript.intention.expand.opt.chain.and.nullish.coalescing=展開可選鏈接和空值合併
javascript.intention.expand.opt.chain.and.or.coalescing=展開可選鏈接並使用 ?: 運算符
javascript.intention.explicit.fields=宣告顯式類欄位
javascript.intention.explicit.fields.single=宣告顯式類欄位
javascript.intention.explicit.fields.dialog.title=選擇要顯式宣告的欄位
javascript.intention.init.fields=從參數初始化新字段
javascript.intention.init.fields.dialog.title=選擇參數以初始化欄位

js.param.hints.show.names.for.all.args=Non-literal arguments
js.param.hints.show.names.for.tagged=對於標記的模板實參
js.param.hints.show.names.for.pipes=對於管道運算符
js.param.hints.blacklist.pattern.explanation=要禁用方法或函數提示，請使用下面的其中一種模式: <p style=\\"margin-left: 5px\\"><code><b>(*info)</b></code> - 所有參數名稱以 <em>info</em> 結尾的單參數方法<br><code><b>(key, value)</b></code> - 所有包含參數<em>鍵</em>和<em>值</em>的方法<br><code><b>*.put(key, value)</b></code>- 所有包含<em>鍵</em>和<em>值</em>參數的 <em>put</em> 方法<br><code><b>Console.log(*, *)</b></code> - 正好包含兩個參數的 <em>Console</em> 類型的 <em>log</em> 方法</p><br><p>必須為所有參數(包括可選參數)提供名稱或佔位符。<br>限定方法名稱必須包含類或接口名稱或佔位符。<br>在編輯程式碼時，請使用“不為當前方法顯示提示”{0} 操作來添加模式。</p>

js.checkbox.make.readonly=設為唯讀(&R)

action.JavaScriptGenerateDictionaries.text=生成 JavaScript 拼寫檢查器字典
action.ReactClassToFunctionComponentAction.description=轉換為函數組件
action.ReactFunctionToClassComponentAction.description=轉換為類組件
action.ReactExtractComponentAction.description=提取組件
action.EslintImportCodeStyle.description=套用 ESLint 程式碼樣式
action.TypeScriptExtractTypeAlias.description=提取類型別名
action.JS.TypeScript.Include.Generated.Declarations.text=包括 '.d.ts' 子檔案
action.JS.TypeScript.Include.Generated.Declarations.description=在專案中包含 .d.ts 子檔案
action.Generate.GetSetAccessor.JavaScript.text=Getter 和 Setter
action.Generate.SetAccessor.JavaScript.text=Setter
action.Generate.GetAccessor.JavaScript.text=Getter
action.Generate.Constructor.JavaScript.text=構造函數
action.Generate.Missing.Members.ES6.text=實作方法…
action.Generate.Missing.Members.TypeScript.text=實作成員…
group.Editor.JSLibrariesMenu.LibraryList.text=使用庫
group.Editor.JSLibrariesMenu.LibraryList.description=設定使用的 JS 庫
group.Editor.JSLibrariesMenu.text=使用 JavaScript 庫
group.Editor.JSLibrariesMenu.description=選擇要與當前檔案一起使用的 JavaScript 庫
configurable.JSTemplateLangConfigurable.display.name=模板
configurable.JSCodeCompletionConfigurable.display.name=JavaScript
configurable.JSSmartKeysConfigurable.display.name=JavaScript
configurable.MyConfigurable.display.name=JSX
import.options.find.more.configuration.options=在<a>程式碼樣式</a>中尋找更多配置選項
settings.code.style.indent.chained.methods=縮排鏈式方法
settings.code.style.indent.all.chained.calls.in.a.group=縮排組中的所有鏈式調用
settings.code.style.semicolon.to.terminate.statements=分號終止語句(&S)
settings.code.style.use=使用
settings.code.style.quotes=引號(&Q)
settings.code.style.Trailing.comma=尾隨逗號(&T):
settings.code.style.single=單
settings.code.style.double=雙
settings.code.style.in.new.code=(在新程式碼中)
settings.code.style.always=始終
settings.code.style.option.use=使用
settings.code.style.dont.use=不使用
checkbox.enable=啟用
webpack.configuration.title=Webpack
webpack.configuration.detect.description=檢測適合模組解析的 webpack 配置檔案:
webpack.configuration.manual=手動
webpack.configuration.automatic=自動
webpack.configuration.disabled=已禁用
webpack.configuration.automatic.how.it.works=運作方式
webpack.configuration.automatic.hint={0} 將使用當前檔案所在資料夾或其任意父資料夾中的 webpack 配置檔案內的模組解析規則。
webpack.configuration.field=配置檔案:
webpack.configuration.field.required.error=手動模式下需要配置檔案路徑
create.react.app.name=React
create.react.app.description=<a href=\\"https://github.com/facebookincubator/create-react-app\\">創建 React 套用</a>是官方支援的一種創建單頁 React 套用程序的新方法。它提供了沒有配置的現代構建設定。
create.react.app.scripts.version=腳本版本 (&V)
create.react.app.typescript.checkbox=創建 TypeScript 專案 (&T)
dialog.title.new.javascript.file=新建 JavaScript 檔案
list.item.javascript.file=JavaScript 檔案
dialog.title.new.typescript.file=新建 TypeScript 檔案
list.item.typescript.file=TypeScript 檔案
list.item.typescript.jsx.file=TypeScript JSX 檔案
dialog.kind.0.file={0} 檔案
action.creates.new.file.description=創建新的 {0} 檔案
build.event.title.failed.to.list.tasks=無法列出 {0} 任務
action.show.error.details.text=顯示錯誤詳細資訊
dialog.title.grunt.settings=Grunt 設定
dialog.title.gulp.settings=Gulp 設定
dialog.title.error.details=錯誤詳細資訊
dialog.message.failed.to.download.0.1=下載 {0} 失敗。{1}
dialog.title.download.error=下載錯誤
label.import.popup=自動匯入工具提示:
label.namespace=命名空間:
dialog.message.cannot.infer.type.new.parameter=無法推斷新參數的類型
dialog.title.cannot.introduce.new.interface=無法引入新接口
notification.title.coloring.types.narrowed.by.type.guard.was.disabled=按類型防護限縮類型著色被禁用
notification.content.html.href.settings.show.inspection.settings.or.href.undo.undo.html=<html><a href='settings'>顯示檢查設定</a>或<a href='undo'>撤消</a></html>
dialog.message.cannot.propagate.variable=無法傳播變數: {0}
dialog.title.cannot.propagate=無法傳播
dialog.message.usages.search.was.interrupted=用法搜尋被中斷
dialog.title.cannot.convert=無法轉換
dialog.message.cannot.proceed.when.having.non.read.usages.in.embedded.expressions=嵌入式表達式中有非讀取用法時，無法繼續
dialog.message.variables.from.destructuring.pattern.have.no.usages=來自於析構模式的變數沒有用法
button.continue=繼續
button.abort=中止
action.don.t.use.library.description=不使用庫
action.already.set.for.containing.folder.or.project.description=已針對包含的資料夾或專案進行設定。
action.use.library.description=使用庫
text.cannot.download=無法下載 {0}。{1}
notification.content.show.details=顯示詳細資訊
action.name.disable.category=禁用 {0}
progress.text.processing=正在處理 {0}{1}
label.path=路徑(&P):
border.title.inspection.export.results.capitalized.location=位置
border.title.inspection.description.title=描述:
progress.title.install.npm.module=安裝 npm 模組 ''{0}''
dialog.message.cannot.find.module.types=找不到模組 @types/{0}
action.jump.to.text=跳轉到…
dialog.title.select.navigation.target=選擇導航目標
dialog.title.select.targets.to.convert.to.class=選擇要轉換為類的目標
dialog.message.component.name=組件名稱:
label.name=名稱: 
label.type=類型: 
label.minimum.language.level=最低語言級別:
dialog.message.cannot.create.argument.stubs.invoked.method.function=無法創建實參存根: 調用的方法不是函數
action.show.structure.text=顯示結構
status.text.no.errors.in.current.file=當前檔案中沒有錯誤。
status.text.javascript.language.service.default.project.errors=顯示專案錯誤
progress.title.compiling.typescript.files=正在編譯 TypeScript 檔案
dialog.message.cannot.find.file=找不到檔案 {0}
radio.set.options.manually=手動設定選項
radio.use.tsconfig.json=使用 tsconfig.json
separator.deprecated.settings=棄用的設定
dialog.title.main.file=主檔案
label.choose.main.file=選擇主檔案
dialog.title.output.directory=輸出目錄
label.choose.output.directory=選擇輸出目錄
dialog.message.incorrect.path.to.typescript.package=typescript 軟體套件的路徑不正確
status.text.project.structure.isn.t.available=專案結構不可用
status.text.service.doesn.t.contain.open.projects=服務不包含開放專案
status.text.refresh.required=需要刷新
dialog.message.cannot.find.module.for.import=無法構建用於匯入的模組路徑
action.js.tagged.literal.injection.text=JS 標記文字注入
dialog.title.wsl.node.interpreter={0} WSL Node 解釋器
dialog.title.wsl.node.interpreter.edit=編輯
dialog.title.wsl.node.interpreter.edit.add=添加
label.wsl.node.interpreter=WSL Node.js 解釋器(&N):
dialog.message.please.select.distribution=請選擇分發版
dialog.message.please.specify.wsl.path.to.node.js.interpreter=請指定 WSL 中安裝的 Node.js 解釋器的路徑
status.text.running.which.node=正在執行 \`which node\`…
progress.title.configuring.node.js.coding.assistance=正在配置 Node.js 編碼輔助…
action.PackageJsonNewFile.text={0}檔案
action.PackageJsonNewFile.description=創建 {0} 檔案
progress.title.install=安裝 {0}
progress.subtitle.install=正在通過 {1} 安裝 {0}…
inspection.message.package.installed=未安裝 {0} 軟體套件
inspection.message.package.version.specified=未指定軟體套件版本
inspection.message.installed.version.doesn.t.match.version.range=安裝的版本 {0} 與版本範圍 {1} 不符合
dialog.title.missing.dependencies=缺少依賴項
button.install.update=安裝/更新
action.view.install.text=查看並安裝…
action.don.t.ask.again.text=不再詢問
dialog.title.configure.coding.assistance.for.node.js.api=配置 Node.js API 編碼輔助
action.Anonymous.text.configure=配置
inspection.message.sm.test.runner.magnitude.assertion.failed.title=斷言失敗
text.html.front.end.template.a.href.http.html5boilerplate.com=<html>前端模板<a href='http://html5boilerplate.com'>http://html5boilerplate.com</a></html>
dialog.message.node.interpreter.unspecified.error.text=請指定 Node.js 解釋器
text.html.sleek.intuitive.and.powerful.front.end.framework=<html>整潔、直觀、強大的前端框架，更快、更輕鬆地進行 Web 開發 <a href='http://getbootstrap.com'>http://getbootstrap.com</a></html>
popup.title.target.function=目標函數
popup.title.select.destructuring.assignment.target=選擇析構賦值目標
visibility.level.overview=概覽
visibility.level.details=詳細資訊
js.module.uml.presentable.name=JavaScript 模組依賴項
intention.family.name.run.npm.install=執行 'npm install'
intention.name.run.npm=執行 ''{0}''
intention.family.name.navigate.to.package.json=導航到 package.json
intention.name.navigate.to.0.package.json=導航到 {0}/package.json
popup.advertisement.start.typing.package.name=開始輸入軟體套件名稱，以從 npm 官方公共註冊表中獲取更具體的結果
popup.advertisement.latest.available.versions.for.all.distribution.tags=所有發行版標籤的最新可用版本
intention.family.name.select.in.test.tree=在測試樹中選擇
intention.family.name.introduce.parameter.properties.for.unused.parameters=轉換為參數屬性
dialog.title.select.parameters.to.convert.to.parameter.properties=選擇要轉換為參數-屬性的參數
intention.family.name.add.required.property=添加所需的屬性
intention.name.create.library.with.files.outside.project=使用專案外部的檔案創建庫
dialog.message.unspecified.suite.name=未指定的套件名稱
dialog.message.unspecified.test.name=未指定的測試名稱
dialog.message.unspecified=未指定的 {0}
dialog.message.no.such=沒有此類{0}
dialog.message.please.specify.package.json=請指定 package.json
dialog.message.please.specify.package.json.correctly=請正確指定 package.json
dialog.message.please.specify.npm.scripts.to.run=請指定要執行的 npm 腳本
dialog.message.command.supported.by={1} 不支持命令 ''{0}''
dialog.message.no.npm.script=無 ''{0}'' npm 腳本
titled.separator.predefined=預定義
label.compiles.js.files=編譯 .js 檔案
label.compress.js.files=壓縮 .js 檔案
dialog.title.edit.run.debug.configuration=編輯執行/調試配置: ''{0}''
js.commandline.configure.language.version=為專案配置 JavaScript 語言版本
js.commandline.configure.nodejs=配置 NodeJS 解釋器並為 package.json 檔案安裝軟體套件

# Language features
js.language.feature.xml.tags=XML 標記
js.language.feature.for.each.statements=針對每條語句
js.language.feature.for.of.loops=for..of 迴圈
js.language.feature.let.definitions=Let 定義
js.language.feature.const.definitions=Const 定義
js.language.feature.generators=生成器
js.language.feature.destructuring.assignments=析構賦值
js.language.feature.let.statements=Let 語句
js.language.feature.array.comprehensions=陣列推導式
js.language.feature.top.level.yield.expressions=頂層 yield 表達式
js.language.feature.reference.namespace=引用命名空間
js.language.feature.default.parameter.values=預設參數值
js.language.feature.pipe.expressions=管道表達式
js.language.feature.decorator.declarations=裝飾器宣告
js.language.feature.throw.expressions=拋出表達式
js.language.feature.ecmascript.syntax.for.private.members=私有成員的 ECMAScript #- 語法
js.language.feature.class.member.visibility.modifiers=類成員可見性修飾符
js.language.feature.optional.chaining.operator=可選鏈接運算符
js.language.feature.arbitrary.precision.integers=任意精度整數
js.language.feature.trailing.commas.in.function.parameter.lists.and.calls=函數參數列表和調用中的尾隨逗號
js.language.feature.unicode.escapes.with.braces=使用大括號的 Unicode 轉義
js.language.feature.bind.expressions=綁定表達式
js.language.feature.optional.catch.bindings=可選 catch 綁定
js.language.feature.string.templates=字串模板
js.language.feature.method.definition.shorthands=方法定義速記形式
js.language.feature.computed.property.names=計算的屬性名稱
js.language.feature.shorthand.property.names=速記屬性名稱
js.language.feature.binary.0b.and.new.octal.0o.literals=二進制(0b)和新的八進制(0o)文字
js.language.feature.async.await=async/await
js.language.feature.types=類型
js.language.feature.annotations=註解
js.language.feature.interfaces=接口
js.language.feature.classes=類
js.language.feature.es6.export.declarations=ES6 匯出宣告
js.language.feature.es6.import.declarations=ES6 匯入宣告
js.language.feature.generics=泛型
js.language.feature.rest.parameters=rest 參數
js.language.feature.arrow.functions=箭頭函數
js.language.feature.getters.and.setters=getter 和 setter
js.language.feature.generator.expressions=生成器表達式
js.language.feature.expression.closures=表達式結束
js.language.feature.destructuring.parameters=析構參數

# Webpack
webpack.failed.to.load=無法載入 {0}
webpack.analyzing.configs.progress=正在分析 Webpack 配置
webpack.cannot.analyze=無法分析 {0}: 編碼輔助將忽略此檔案中的模組解析規則。\\\\n可能的原因: 此檔案不是有效的 webpack 配置檔案，或者 IDE 目前不支持其格式。
file.name.masks.to.skip.from.analysis=要在分析中跳過的文件名遮罩:

# Node
node.core.enable_coding_assistance_intention.name=啟用 Node.js 的編碼輔助
node.interpreter.unresolved_reference.error.message=未解析的解釋器 ''{0}''
node.interpreter.invalid_interpreter.error.message=無效 ''{0}''
node.interpreter.no_local_interpreter.error.message=沒有本地 Node.js 解釋器
node.debug.cannot_connect_to_vm.error.message=無法連接到虛擬機 {0}
node.debug.cannot_get_localhost_IPv4.error.message=無法獲取 127.0.0.1 IPv4
node.core.make.sure.javascript.debugger.plugin.enabled.dialog.message=確保已啟用 'JavaScript Debugger' 套件
node.core.failed_to_fetch_node_core_modules.dialog.message=無法提取 Node 核心模組
node.core.core_modules_fetch_timed_out.dialog.message=無法提取核心模組: 已超時
node.core.not_ready_for_core_modules_configuration.dialog.message=未準備好進行核心模組配置
node.core.navigate_action_text.text=配置 Node.js…
node.core.failed_to_install.title.message=無法安裝 {0}
node.interpreter.field.add.item.text=添加…
node.interpreter.field.unexpected_value.text=意外值 {0}
node.interpreter.unspecified_interpreter.dialog.message=指定 Node.js 解釋器
node.interpreter.unspecified_local_interpreter.dialog.message=指定本地 Node.js 解釋器
node.interpreter.specified_interpreter_correctly.dialog.message=正確指定 Node.js 解釋器
configure.node.interpreter.path=配置 Node.js 路徑…
node.interpreter.reference_not_found.text=未找到
node.interpreter.command_timed_out.dialog.message=''{0}'' 命令執行超時(>{1} ms)
node.package_documentation.installed_version.text=已安裝版本: {0}
node.package_documentation.latest_version.text=最新版本: {0}
node.packages.cannot_find_working_directory.text=無法確定 {0} 的工作目錄: {1}
node.package.field.not_found.text=未找到
node.npm.cannot_find_package_by_reference.dialog.message=找不到軟體套件管理器 ''{0}''
node.npm.specify_npm_or_yarn_package.dialog.message=指定 npm 或 yarn 軟體套件
node.npm.correct_path_to_npm_or_yarn_package.dialog.message=指定 npm 或 yarn 軟體套件的正確路徑: 無此類目錄 \\"{0}\\"
node.npm.invalid_package_manager.binary_file_not_found.dialog.message=指定有效的軟體套件管理器: 在 ''{0}'' 目錄內部找不到二進制檔案
node.npm.project_package_manager_disallowed_here.dialog.message=無法在此處引用專案 npm 軟體套件
node.npm.unspecified_package_manager.dialog.message=未指定軟體套件管理器
node.npm.cannot_resolve_package_manager.dialog.message=無法解析 ''{0}'' 軟體套件管理器
node.npm.no_bundled_npm_detected.dialog.message=未檢測到 {0} 的捆綁 npm
package_json.install_dependencies.notification.title=安裝依賴項
package_json.install_dependencies_multiple.notification.content=來自 {0} 和其他 {1} 個
package_json.install_dependencies.notification.content=來自 {0}
package_json.update_dependencies.notification.title=更新依賴項
package_json.notifications_are_disabled.notification.content=已禁用從 {0} 安裝依賴項的通知。<p>使用 \\"{1}\\" 操作重新啟用通知。
node.wsl.unavailable.dialog.message=WSL 不可用
node.wsl.unavailable_distribution.dialog.message=WSL {0} 不可用
node.npm.cannot_find_project_package_manager.dialog.message=找不到專案 Node.js 軟體套件管理器
node.npm.package_manager_link.text=軟體套件管理器
yarn.package_requires_yarn.dialog.message=軟體套件 \\"{0}\\" 要求 Yarn {1}。

# Jest
jest.package.placeholder.text=軟體套件目錄的路徑，可選擇 jest、react-scripts 或 react-scripts 替代項
jest.snapshot.label=Jest 快照
filetype.jest.snapshot.description=Jest 快照
filetype.jest.snapshot.display.name=Jest 快照
jest.go.to.snapshot.text=轉到 ''{0}'' 快照
jest.cannot.find.bin.file.for.package.dialog.message=找不到 ''{0}'' 軟體套件的 bin 檔案

# Protractor
dialog.message.cannot.locate.wrapper.config.file=找不到包裝器配置檔案

# Style guides
list.item.google.javascript.style.guide=Google JavaScript 樣式指南
list.item.javascript.standard.style=JavaScript 標準樣式

# Inlay hints
method.return.types.in.call.chains=調用鏈中的方法返回類型
type.annotations=類型註解
parameters.in.parentheses=用括號括起來的參數
non.parenthesized.single.parameter=未使用括號括起來的單個參數
function.returns=函數返回
variables.and.fields=變數和欄位
command.name.add.explicit.value=添加顯式值 ''{0}''
numeric.enum.values=數值枚舉值

# Libraries
progress.title.downloading.library=正在下載庫
progress.title.downloading.documentation=正在下載文檔
successfully.downloaded=已成功下載
failed.to.download=無法下載
progress.title.downloading.typings=正在下載 typings
notify.urls.more=… 和另外 {0,number} 個

# Structural Search
structural.search.anonymous.functions=匿名函數
structural.search.functions=函數
structural.search.variables=變數
structural.search.function.calls=函數調用
structural.search.while.loops=While 迴圈
structural.search.constants=常數
structural.search.classes=類
structural.search.empty.functions=空函數
structural.search.console.log.calls=調用 console.log()
structural.search.with.statements=With 語句
structural.search.var.statements=Var 語句
structural.search.functions.with.boolean.parameters=使用布爾參數的函數
structural.search.comparison.to.self=與自身比較

# Project Generators
copying.files=正在複製檔案
project.generation=生成專案
notification.title.cannot.generate=無法生成 {0}
dialog.message.cannot.find.npx.bundled.with=找不到使用 {0} 捆綁的 npx
generating.0=正在生成 {0}

# Find Usages
js.show.dynamic.usages=顯示動態用法

# Test Runners
action.JasmineGenerateNewSuiteAction.text=Jasmine Suite
action.JasmineGenerateNewSpecAction.text=Jasmine Spec
action.JasmineGenerateBeforeEachMethodAction.text=Jasmine beforeEach
action.JasmineGenerateAfterEachMethodAction.text=Jasmine afterEach
action.QUnitGenerateNewTestAction.text=QUnit Test
action.QUnitGenerateSetupAction.text=QUnit Setup
action.QUnitGenerateTearDownAction.text=QUnit TearDown

# Diagrams
diagram.element.not.found={0} (未找到)

# Web frameworks
web.template.file-type.description={0} 模板
web.inspection.message.attribute.does.not.accept.value={0} 不接受任何值

# Other
command.name.create.javascript.file=創建 JavaScript 檔案 {0}
command.name.create.typescript.file=創建 TypeScript 檔案 {0}
checkbox.move.simple.expressions.to.field.initializer=將簡單表達式移動到欄位初始值設定項
popup.title.choose.class=選擇類
multiple.inheritance=多重繼承
label.method.should.be.defined=方法應已定義
recursive.call=遞歸調用
command.name.extract.named.type=提取已命名類型
inspection.message.reference.includes.files.outside.project=引用包括專案範圍之外的檔案
progress.title.executing.performance.task.on.files=正在檔案上執行性能任務
terminal.add_node_modules_bin_to_path.label=將 ''node_modules/.bin'' 從專案根添加到 {0}
label.name.injection=名稱(&N):
reg.exp.tagged.template=''{1}'' 標記模板中的 {0}
unwrap.with.kind=解開 ''{0}…''
header.declarations.to.be.refactored=要重構的宣告
filetype.yarn.lock.display.name=Yarn Lock
filetype.yarn.lock.description=Yarn lock



javascript.validation.message.jsdoc.types.are.used=JSDoc 類型只能在文檔註釋內部使用
eslint.run.on.save.checkbox.on.actions.on.save.page=執行 eslint --fix
javascript.parser.message.missing.back.quote=缺少 \`
eslint.run.on.save.disabled.comment=已禁用 ESLint 集成
eslint.run.on.save.auto.configuration.comment=自動 ESLint 配置
eslint.run.on.save.manual.configuration.comment=手動 ESLint 配置
eslint.run.on.save.link.enable.eslint=啟用 ESLint…
node.execution.failed.to.prepare.target.environment.error=無法準備環境: {0}
node.interpreter.unavailable.target=不可用的目標: {0}
rename.react.hook.variable.title=重命名狀態變數
rename.react.hook.variable.description=將相關狀態變數重命名為:
web.inspection.message.attribute.value.no.valid={0} 不是 {1} 的有效值。預期值: {2}
add.variable.to.require=添加 require 調用的變數
js.regex.flag.g=全域符合 - 返回所有符合項
js.regex.flag.i=忽略大小寫 - 不區分大小寫的符合
js.regex.flag.m=多行 - ^ 和 $ 的每行符合
js.regex.flag.s=dotAll - . 符合換行符
js.regex.flag.u=unicode - 完整 unicode 支援
js.regex.flag.y=粘性 - 在確切的位置搜尋
js.regex.flag.d=符合索引 - 用於子字串符合的索引
node.execution.starting.process.progress.title=正在啟動 ''{0}''…
node.wsl.network.connection.failure=無法建立從 WSL 到 Windows 主機的網絡連接(可能被防火牆阻止)。\\\\n要了解詳細資訊，請參閱: https://jb.gg/wsl-firewall
insert.parentheses.on.completion=完成時插入圓括號
intention.category.javascript=JavaScript
intention.category.typescript=TypeScript
intention.category.ecmascript6=JavaScript/ECMAScript 6
intention.category.react=React
js.annotator.rest.element.must.be.last=rest 元素必須位於最後
web.inspection.message.segment.missing=缺少 {0}
web.inspection.message.segment.unrecognized-identifier=無法識別的 {0}
web.inspection.message.segment.duplicated=重複的 {0}
web.inspection.message.segment.default-subject=名稱
not.installed.package=未安裝軟體套件
package.version.range.info={0, choice, 0#未安裝|1#已安裝: ?|2#已安裝: {1}}，最新: {2, choice, 0#正在載入…|1#未找到|2#{3}}
package.version.range.hint={0, choice, 0#允許|1#允許次要更新:|2#允許補丁更新:} {1} \\\\\\\\&gt;= 版本 \\\\\\\\&lt; {2}
env.variable.undefined={0} 未定義
env.variable.empty={0} 為空
jquery.documentation.not.found=找不到 jQuery 文檔
typescript.language.service.name=TypeScript 服務
js.annotator.yield.cannot.be.used.inside.generator='yield' 不能用作生成器內部的關鍵字
js.invalid.expression.result.type.inspection.name=表達式類型無效
linemarker.javascript.sources=JavaScript 源
linemarker.typescript.declaration=TypeScript 宣告
choose.declaration.element=<html><body>選擇 TypeScript 宣告</body></html>
js.dot.property.access.context.type=點號屬性存取
javascript.library.built.in=內建
inlay.parameters.js.only.show.names.for.all.args=文字和非文字實參、調用表達式、物件和陣列初始值設定項。
inlay.parameters.js.only.show.names.for.tagged=<a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates'>Arguments in tagged templates.<a><br>This setting takes effect only over non-literal arguments and is only available when the \\"Non-Literal arguments\\" option is enabled. 
inlay.parameters.js.only.show.names.for.pipes=<a href='https://github.com/tc39/proposal-pipeline-operator'>管道運算符中的參數。</a>
inlay.parameters.js.param.hints.show.names.for.all.args=方法調用中的文字和命名物件參數。
inlay.parameters.js.param.hints.show.names.for.tagged=標記模板中的實參。
inlay.parameters.angular.show.names.for.all.args=Angular HTML 模板中的文字和命名物件參數。
inlay.parameters.angular.show.names.for.pipes=<a href='https://angular.io/guide/pipes'>Angular HTML 模板中的管道。</a>
inlay.parameters.vuejs.show.names.for.all.args=文字和命名物件。
inlay.parameters.vuejs.show.names.for.filters=<a href='https://vuejs.org/v2/guide/filters.html'>篩選器。</a>
js.url.import.usage.inspection.name=使用了 URL 匯入
js.url.import.usage.inspection.download.module.quick.fix.name=下載模組
js.url.import.usage.inspection.download.module.0.quick.fix.failed=下載模組 ''{0}'' 失敗
js.url.import.usage.inspection.download.module.0.quick.fix.warning=模組 ''{0}'' 已下載，但有錯誤
js.url.import.usage.inspection.download.module.0.quick.fix.warning.urls=失敗的 URL:
js.url.import.usage.inspection.download.module.0.quick.fix.success=模組 ''{0}'' 已成功下載
js.url.import.usage.inspection.download.module.0.quick.fix.progress=正在下載模組 ''{0}''
js.inspection.package.json.update.dependency.to.latest.version=將 package.json 依賴項更新為最新版本
inspection.update.package_json.dependency.message=有可用的 ''{0}'' 新版本: {1}
inspection.update.package_json.dependency.action.text=將 ''{0}'' 更新到最新版本 {1}
react.native.config.name=React Native
react.native.project.generator.description=借助 <a href='https://facebook.github.io/react-native/'>React Native</a>，只需使用 JavaScript 即可構建移動套用。它使用的設計與 React 相同，讓您可以通過宣告性組件構建豐富的移動 UI。
react.native.project.generator.package.name=React Native:
react.native.project.generator.validation={0} 不是有效的專案名稱。請使用由字母數字構成的專案名稱。
escape.jsdoc.copy.pasted.text=在複製和貼上時轉義 JSDoc 前導星號
node.package.empty.error.message=專案名稱為空
node.package.name.period.error.message=專案資料夾名稱不應以句點開頭
node.package.name.underscore.error.message=專案資料夾名稱不應以下划線開頭
node.package.name.leading.or.trailing.spaces.error.message=專案資料夾名稱不應包含前導空格或尾隨空格
node.package.name.forbidden.error.message=''{0}'' 不能用作專案名稱
node.package.name.core.module.error.message=''{0}'' 不能用作專案名稱，因為它是 Node.js 核心模組的名稱
node.package.name.too.long.error.message=專案資料夾名稱不應超過 214 個字符
node.package.name.capital.letters.error.message=專案資料夾名稱不應包含大寫字母
node.package.name.special.characters.error.message=專案資料夾名稱不應包含特殊字符(\\"~'!()*\\")
node.package.name.URL-friendly.characters.error.message=專案資料夾名稱應僅包含適用於 URL 的字符
javascript.parser.message.expected.identifier.string.literal.or.rbrace=應為關鍵字、字串文字或 }
js.import.options.use.explicit.js.extension.auto=自動
js.import.options.use.explicit.js.extension.yes=始終
js.import.options.use.explicit.js.extension.yes.ts=始終為 \\".js\\"
js.import.options.use.explicit.js.extension.no=從不
js.flow.process.log=Flow 流程日誌
flow.js.show.settings=配置 Flow…
flow.js.widget.name=Flow
flow.js.widget.display.name=Flow JS
javascript.indexed.property.instead.of.computed.name=索引屬性存取中括號位於單獨的行中。是否應為計算的名稱?
javascript.insert.symbol.fix=插入{0}
javascript.parser.message.expected.dot=應為 .
javascript.parser.message.expected.newline.or.semicolon=需要換行符或分號
javascript.parser.message.expected.gt=應為 >
javascript.parser.message.expected.lbracket=應為 [
javascript.parser.message.expected.readonly=應為 'readonly'
node.js.configure.interpreter=配置 {0}
yarn.pnp.library_name=來自 {0} 的依賴項
typescript.enum.name=枚舉
typescript.enum.member.name=枚舉成員
icon.icons.nodes.readonlyMark.tooltip=readonly"
`;

exports[`dev messages/PhpBundle.properties 1`] = `
"action.ChangePHPInterpreter.text=更改 PHP 解釋器
action.ChangePHPInterpreter.description=更改專案 PHP 解釋器
action.MessDetectorAddToIgnored.text=添加到 PHPMD 忽略列表
action.MessDetectorAddToIgnored.description=添加到 PHP Mess Detector 忽略列表
action.PhpCSFixerAddToIgnored.text=添加到 PHP CS Fixer 忽略列表
action.PhpCSFixerAddToIgnored.description=添加到 PHP CS Fixer 忽略列表
action.PhpCSAddToIgnored.text=添加到 PHPCS 忽略列表
action.PhpCSAddToIgnored.description=添加到 PHP_CodeSniffer 忽略列表
group.PHPQualityToolsAddToIgnoredList.text=添加到忽略列表…
action.ComposerShowLogAction.text=顯示日誌
action.ComposerShowLogAction.description=顯示包含此 composer.json 的 Composer 操作日誌
action.ComposerClearCacheAction.text=清除快取
action.ComposerClearCacheAction.description=刪除 Composer 快取目錄中的所有內容
action.ComposerSelfUpdateAction.text=自我更新
action.ComposerSelfUpdateAction.description=將 Composer 本身更新到最新版本
group.ComposerToolsGroup.text=Composer
action.com.jetbrains.php.composer.ComposerInitSupportAction.text=初始化 Composer…
action.com.jetbrains.php.composer.ComposerInitSupportAction.description=初始化 Composer
group.ComposerGroup.text=Composer
action.ComposerDiagnoseAction.text=診斷
action.ComposerDiagnoseAction.description=檢查常見的 Composer 問題
action.ComposerLicensesAction.text=列出許可證
action.ComposerLicensesAction.description=列出安裝的每個軟體套件的名稱、版本和許可證
action.ComposerStatusAction.text=檢查依賴項中的變更
action.ComposerStatusAction.description=檢查任何依賴項中有無本地變更
action.ComposerDryRunUpdate.text=模擬更新
action.ComposerDryRunUpdate.description=模擬更新，但不實際更新
action.ComposerDumpAutoloadAction.text=轉儲自動載入器…
action.ComposerDumpAutoloadAction.description=重新生成自動載入類的列表
action.ComposerValidateAction.text=驗證…
action.ComposerValidateAction.description=檢查 composer.json 是否有效
action.ComposerAddDependencyAction.text=管理依賴項…
action.ComposerAddDependencyAction.description=管理 Composer 依賴項
action.ComposerUpdateAction.text=更新
action.ComposerUpdateAction.description=從 Composer.json 安裝最新適當版本的軟體套件
action.ComposerInstallAction.text=安裝
action.ComposerInstallAction.description=考慮到 composer.lock，安裝 composer.json 中的軟體套件
action.com.jetbrains.php.internal.PhpViewControlFlowAction.text=當前檔案的 PHP 控制流
action.com.jetbrains.php.internal.PhpShowFQNInternalAction.text=顯示 PHP FQN
action.ProfilerJumpToSource.text=跳轉到原始碼
action.ProfilerJumpToSource.description=跳轉到原始碼
action.XdebugAnalyzeProfilerSnapshotAction.text=分析 Xdebug 分析器快照…
group.DBGPProxyGroup.text=DBGp 代理
action.PhpDebuggerCopyType.text=複製類型
action.XDebugger.CopyPath.text=複製路徑
action.PhpDetectPsroRoots.text=檢測 PSR-0 命名空間根
action.PhpDetectPsroRoots.description=將檢測原始碼命名空間根
action.PhpListenDebugAction.text=偵聽調試連接
action.PhpListenDebugAction.description=偵聽調試連接
action.PhpMakeStaticAction.text=設為 static
action.PhpMakeStaticAction.description=將類方法設為 static
action.PhpExtractClassAction.text=提取類…
action.PhpExtractClassAction.description=將元素提取到單獨的類

action.PhpNewTest.text=PHP 測試
action.PhpNewTest.description=創建新的 PHP 測試
group.PhpNewTestGroup.text=PHP 測試
action.PhpUnitGenerateTearDownMethod.text=TearDown 方法
action.PhpUnitGenerateTearDownMethod.description=創建 PHPUnit tearDown 方法
action.PhpUnitGenerateSetUpMethod.text=SetUp 方法
action.PhpUnitGenerateSetUpMethod.description=創建 PHPUnit setUp 方法
action.PhpUnitGenerateTestMethod.text=測試方法
action.PhpUnitGenerateTestMethod.description=創建 PHPUnit 測試方法
action.PhpGeneratePhpDocBlocks.text=PHPDoc 塊…
action.PhpGeneratePhpDocBlocks.description=為函數、類和欄位添加 PHPDoc 塊。
action.PhpGenerateSetters.text=setter…
action.PhpGenerateSetters.description=為 private 類欄位創建 setter。
action.PhpGenerateGettersAndSetters.text=getter 和 setter…
action.PhpGenerateGettersAndSetters.description=為 private 類欄位創建 getter 和 setter。
action.PhpGenerateGetters.text=getter…
action.PhpGenerateGetters.description=為 private 類欄位創建 getter。
action.PhpGenerateConstructor.text=構造函數…
action.PhpGenerateConstructor.description=創建構造函數。

# php colors page elements
color.settings.name=PHP
color.settings.php.scripting=PHP 程式碼//背景
color.settings.php.tags=PHP 程式碼//標記
color.settings.keyword=關鍵字
color.settings.comment=註釋
color.settings.number=數字
color.settings.string=字串//字符
color.settings.escape_sequence=字串//轉義序列
color.settings.operation=大括號和運算符//運算符
color.settings.brackets=大括號和運算符//中括號
color.settings.parentheses=大括號和運算符//圓括號
color.settings.braces=大括號和運算符//大括號
color.settings.bad_character=未知字符
color.settings.comma=大括號和運算符//逗號
color.settings.semicolon=大括號和運算符//分號
color.settings.heredoc_id=Heredoc//Heredoc ID
color.settings.heredoc_content=Heredoc//Heredoc 內容
color.settings.var=關鍵字//變數
color.settings.var_var=關鍵字//可變變數
color.settings.this.var=關鍵字//'$this' 變數
color.settings.identifier=關鍵字//預設
color.settings.constant=關鍵字//常數
color.settings.function=函數和方法//宣告
color.settings.parameter=函數和方法//參數
color.settings.function.call=函數和方法//函數調用
color.settings.instance.method=函數和方法//實例方法調用
color.settings.instance.protected.method=函數和方法//protected 實例方法調用
color.settings.instance.private.method=函數和方法//private 實例方法調用
color.settings.static.method=函數和方法//static 方法調用
color.settings.magic.member=關鍵字//魔幻成員存取
color.settings.class=類和屬性//類
color.settings.interface=類和屬性//接口
color.settings.static.field=類和屬性//static 屬性
color.settings.instance.field=類和屬性//實例屬性
color.settings.instance.protected.field=類和屬性//protected 實例屬性
color.settings.instance.private.field=類和屬性//private 實例屬性
color.settings.doccomment=PHPDoc//文本
color.settings.doctag=PHPDoc//標記
color.settings.docmarkup=PHPDoc//標記
color.settings.doc.identifier=PHPDoc//關鍵字
color.settings.doc.parameter=PHPDoc//參數
color.settings.doc.var=PHPDoc//變數
color.settings.doc.method.identifier=PHPDoc//方法宣告
color.settings.doc.property.identifier=PHPDoc//屬性
color.settings.exec_command=Shell 命令
color.settings.concatenation=字串//串聯
color.settings.predefined.symbols=關鍵字//預定義符號
color.settings.goto.label=關鍵字//轉到標籤
color.settings.alias.reference=關鍵字//別名引用
color.settings.alias.primitive.type.hint=關鍵字//基元類型提示
color.settings.named.arguments=命名實參
color.settings.attributes=特性

# annotations
annotation.variable.variable=可變變數
annotation.new.expression.interface=無法實例化接口 ''{0}''
annotation.new.expression.trait=無法實例化特徵 ''{0}''
annotation.new.expression.abstract=無法實例化 abstract 類 ''{0}''
annotation.expression.is.not.allowed.as.class.constant.value=表達式不允許為類常量值

#folding
folding.checkbox.collapse.imports=Import
folding.checkbox.collapse.method.body=方法體
folding.checkbox.collapse.function.body=函數體
folding.checkbox.collapse.php.tags=標記
folding.checkbox.collapse.heredocs.and.nowdocs=HEREDOC\\\\\\\\NOWDOC
folding.checkbox.collapse.classes=類主體

#gutter
gutter.overriding.select.title=選擇要導航的父方法
gutter.overriden.select.subclass.title=選擇 {0} 的子類
gutter.overriden.select.implementation.title=選擇 {0} 的實作
#gutter-pinned
gutter.pin.overriding.select.title={0} 的父項
gutter.pin.overriden.select.subclass.title={0} 的實作
gutter.pin.overriden.select.implementation.title={0} 的實作

# inspections
inspection.group=PHP
inspection.group.general=常規
inspection.group.unused=未使用
inspection.group.unused.quickfix.label=未使用的元素
inspection.group.unused.quickfix.message=未使用的元素: ''{0}''
inspection.group.undefined=未定義
inspection.group.control.flow=控制流
inspection.group.php.doc=PHPDoc
inspection.group.probably.bug=可能的錯誤
inspection.group.type.compatibility=類型相容性
inspection.group.code.style=程式碼樣式
inspection.group.code.smell=程式碼異味
inspection.group.naming.convention=命名慣例


inspection.dead.code.problem.empty.constant.synopsis=常數從未使用。
inspection.dead.code.problem.single.constant.synopsis=常數有一個用法，但無法到達。
inspection.dead.code.problem.multiple.constant.synopsis=常數有 {0, choice, 1#1 個用法|2#{0,number} 個用法}，但無法從入口點到達。
inspection.dead.code.problem.empty.function.synopsis=函數從未使用。
inspection.dead.code.problem.recursive.suspicious.function.synopsis=所有函數用法均屬於不存在可從入口點到達的成員的調用鏈。
inspection.dead.code.problem.suspicious.function.synopsis=函數無法從入口點到達。
inspection.dead.code.problem.trait.synopsis=特徵從未使用。
inspection.dead.code.problem.class.nousages.synopsis=類從未使用。
inspection.dead.code.problem.trait.additional.unreachable=特徵沒有可到達用法。
inspection.dead.code.problem.trait.additional.reachable=特徵具有可到達用法。
inspection.dead.code.problem.class.abstract.several.implementations={0} 具有{1, choice, 1#直接或間接實作|2# {1,number} 個直接或間接實作}，但<ul><li>其從未實例化或</li><li>不存在可從入口點到達的實例化。</li></ul>

inspection.hierarchyChecks=類層次結構檢查
inspection.hierarchyChecks.descr=類必須被宣告為 abstract 或實作 {0}
inspection.hierarchyChecks.should.implement=類必須實作 {0}
inspection.hierarchyChecks.field.type.redeclaration.must.not.be.defined=類型不得定義(如基類 ''{0}'' 中)
inspection.hierarchyChecks.field.type.redeclaration.match.super.type=類型必須為 ''{0}''(如基類 ''{1}'' 中)
inspection.wrong_param_type=應為 ''{1}'' 類型的參數，提供的是 ''{0}''
inspection.missing_param=缺少所需參數 ''{0}''
inspection.optional.before.required=可選參數在需要前提供
#inspection -> Super class incompatible with interface
inspection.super.incompatible.with.interface.declaration.must.be.compatible=''{0}'' 的宣告必須與 ''{1}'' 相容

#inspection -> Wrong Exception order
inspection.wrong.exception.order.problem.batch=已捕獲異常 '#ref'
inspection.wrong.exception.order.problem.same=已捕獲異常 ''{0}''
inspection.wrong.exception.order.problem.super=已捕獲異常類 ''{1}'' 的超類 ''{0}''

inspection.wrong.exception.order.fix.move.display.name=將 ''catch'' 子句移動到 ''{0}'' 前
inspection.wrong.exception.order.fix.move.family.name=移動 'catch' 子句
#inspection -> Wrong Exception class
inspection.wrong.exception.type.problem.throw = 已拋出物件必須為 'Exception' 或 'Throwable' 的實例
inspection.wrong.exception.type.problem.catch = 無法捕獲非派生自 'Exception' 或 'Throwable' 基類的物件

#inspection -> Assigned value never used
#inspection -> Wrong foreach argument
inspection.wrong.foreach.argument.type.problem.batch=提供給 'foreach' 的無效實參
inspection.wrong.foreach.argument.type.problem=提供給 ''foreach'' 的實參無效。預期類型: ''array'' 或 ''object''，提供的是 ''{0}''。

#inspection -> Redundant PHPDoc
inspection.redundant.phpdoc=冗餘 PHPDoc 註釋

#inspection -> Unused local variable
inspection.unused.local.variable.problem=未使用的局部變數 ''{0}''。{1}
inspection.unused.local.variable.problem.batch=局部變數 '#ref' 未在任何位置使用
inspection.unused.local.variable.problem.case1=變數的值未在任何位置使用。
inspection.unused.local.variable.problem.case2=變數的值被立即覆蓋。
inspection.unused.local.variable.problem.case3=變數中存儲的引用未在任何位置使用。
inspection.unused.local.variable.problem.case4=變數中存儲的引用被立即覆蓋。
inspection.unused.local.variable.option.description.foreach=在 'list()' 中或存在 'foreach' 鍵時忽略 foreach 值
inspection.unused.local.variable.option.description.list=忽略 'list()' 中的變數
inspection.unused.local.variable.option.description.file.scope=在全域空間中啟用檢查
inspection.unused.local.variable.option.description.null=忽略 'null' 的賦值
inspection.unused.local.variable.option.indirect.access=忽略通過 'get_defined_vars()' 存取的變數
inspection.unused.local.variable.problem.fix.side.effects.found.dialog.title=發現副作用
inspection.unused.local.variable.problem.fix.side.effects.found.dialog.message=分配給 ''{0}'' 的表達式可能含有副作用。\\\\n\\\\
您可以:\\\\n\\\\
- 完全<b>移除</b>變數賦值\\\\n\\\\
- 將分配的表達式<b>轉換</b>成單獨的語句

#inspection -> Unused parameter
inspection.unused.parameter.problem=未使用的參數 ''{0}''。{1}
inspection.unused.parameter.problem.case1=參數值未在任何位置使用。
inspection.unused.parameter.problem.case2=參數值被立即覆蓋。
inspection.unused.parameter.problem.case3=參數中存儲的引用未在任何位置使用。
inspection.unused.parameter.problem.case4=參數中存儲的引用被立即覆蓋。
inspection.unused.parameter.option.description.empty.body=忽略帶有空體的方法/函數的參數
inspection.unused.parameter.option.description.empty.abstract=忽略 abstract 類方法的參數
inspection.unused.parameter.option.description.empty.override=忽略覆寫方法的參數
inspection.unused.parameter.option.description.empty.anonymous=忽略匿名函數的參數
inspection.unused.parameter.option.description.parameter.count=不報告通過 'func_num_args()' 存取的參數

#inspection -> Unused private method
inspection.unused.private.method.problem.batch=未使用的 private 方法 '#ref'
inspection.unused.private.method.option.ignore.constructor=忽略方法 '__construct' 用法
inspection.unused.private.method.option.ignore.clone=忽略方法 '__clone' 用法

#inspection -> Undefined callback
inspection.undefined.callback.method=在類 ''{1}'' 中未找到方法 ''{0}''
inspection.undefined.callback.field=在類 ''{1}'' 中未找到屬性 ''{0}''
inspection.undefined.callback.class=未定義的類 ''{0}''
inspection.undefined.callback.function=未定義的函數 ''{0}''
inspection.undefined.callback.dont.report.exist.checkbox=忽略來自 '*_exists' 和 'is_callable' 函數的回調
inspection.undefined.callback.dont.report.ambiguity.checkbox=不明確時不報告

#inspection -> Missing parent call
inspection.missing.parent.call.message=缺少父方法調用

#inspection -> Missing parent constructor call
inspection.missing.parent.constructor.call.message=缺少父構造函數調用

#inspection - > Undefined variable
inspection.undefined.variable.problem1=未定義的變數 '#ref'
inspection.undefined.variable.problem2=變數 '#ref' 可能未定義
inspection.undefined.variable.option.description.enable.in.file.scope=在全域空間中啟用檢查
inspection.undefined.variable.option.description.report.can.be.undefined=報告變數可能未定義
inspection.undefined.variable.option.description.ignore.include=在當前檔案外搜尋變數定義

#inspection -> Wrong String concatenation operator
inspection.wrong.string.concatenation.operator.problem=字串串聯運算符錯誤
inspection.wrong.string.concatenation.operator.problem.batch=字串串聯運算符錯誤
inspection.wrong.string.concatenation.operator.option.ignore.magic=忽略通過魔術方法存取的屬性

#inspection -> Dynamic method called as static
inspection.dynamic.method.called.as.static.problem=非 static 方法 '#ref' 不應被靜態調用
inspection.dynamic.method.called.as.static.problem.magic=非 static 方法 '#ref' 不應被靜態調用，但類具有 '__magic' 方法。

#inspection -> Static method called as dynamic
inspection.static.method.called.as.dynamic.problem=static 方法 '#ref' 不應被動態調用
inspection.static.method.called.as.dynamic.problem.magic=static 方法 '#ref' 不應被動態調用，但類具有 '__magic' 方法。

#inspection -> Assignment in condition
inspection.assignment.in.condition=條件中的賦值
inspection.assignment.in.condition.move.assignment.out.of.condition.fix.name=從條件中移出賦值

#inspection -> Division by zero
inspection.division.by.zero=除以零

#inspection -> Dynamic namepsace
#inspection -> Unreachable Statement
inspection.unreachable.statement=不可到達的語句
inspection.unreachable.statement.problem=不可到達的語句

#inspection -> Missing doc comment
inspection.missing.doc.comment.problem=缺少 PHPDoc 註釋
inspection.missing.doc.comment.problem.batch={0} 缺少 PHPDoc 註釋
inspection.missing.doc.comment.options.panel.constant=常數(&O)
inspection.missing.doc.comment.options.panel.function=函數(&F)
inspection.missing.doc.comment.options.panel.class=類(&C)
inspection.missing.doc.comment.options.panel.method=方法(&M)
inspection.missing.doc.comment.options.panel.field=屬性(&P)
inspection.missing.doc.comment.options.panel.class.constant=類常數(&A)

#inspection -> Silly assignment
inspection.silly.assignment.problem=賦值左右兩側相等

#inspection -> Illegal array key type
inspection.illegal.array.key.type.problem=非法陣列鍵類型

#inspection -> Illegal string offset
inspection.illegal.string.offset.problem=非法字串偏移 {0}

#inspection -> Missing @return tag
inspection.doc.missing.return.tag.problem=函數/方法 PHPDoc 註釋中缺少 @return 標記

#inspection -> Doc signature inspection

#inspection -> Missing @throws tag
inspection.doc.throws.problem=PHPDoc 註釋不包含所有必需的 @throws 標記
inspection.doc.throws.option.skip.on.empty.phpdoc=忽略沒有 @param/@return 的 PHPDoc

#inspection -> Inconsistent return points
inspection.inconsistent.return.points.problem1=缺少 'return' 語句
inspection.inconsistent.return.points.problem1.yield=缺少 'yield' 語句
inspection.inconsistent.return.points.problem2=缺少返回實參
inspection.inconsistent.return.points.option.treat.return=在 'void' 函數/方法中以相同方式對待 'return null' 和 'return'

#inspection -> Redundant closing tag
inspection.redundant.closing.tag.problem=冗餘結束標記
inspection.redundant.closing.tag.fix.remove=移除結束標記

#inspection -> Void function result used
inspection.void.function.result.used.problem1=使用了 ''void'' 函數 ''{0}'' 結果
inspection.void.function.result.used.problem2=使用了 ''void'' 方法 ''{0}'' 結果

#inspection -> Expression result unused
inspection.expression.result.unused.problem=表達式結果未在任何位置使用

#inspection -> Missing 'break' statement
inspection.missing.break.statement.problem=缺少 'break' 語句

#inspection -> Nested vs outer 'foreach' variables conflict
inspection.nested.vs.outer.foreach.variables.conflict.problem1=變數 ''{0}'' 作為鍵用於內部和外部 ''foreach'' 迴圈
inspection.nested.vs.outer.foreach.variables.conflict.problem2=變數 ''{0}'' 作為值用於內部和外部 ''foreach'' 迴圈

#inspection -> Foreach array is used as value
inspection.foreach.array.is.used.as.value.problem=變數 ''{0}'' 已用作 ''array expression''

#inspection -> Usage of a silence operator
inspection.usage.of.silence.operator.problem=使用了沉默運算符

#inspection -> Language level
#switch language level quick fix
inspection.language.level.quick.fix.switch.language.level.name.0=切換到 PHP {0} 語言級別

#switch language level in composer file manually quick fix
inspection.language.level.quick.fix.switch.language.level.in.composer.manually.0=手動切換到 composer.json 中的 PHP {0} 語言級別
inspection.language.level.quick.fix.switch.language.level.in.composer.0=切換到 composer.json 中的 PHP {0} 語言級別


inspection.disabled.quality.tool.inspection.fix=啟用檢查
inspection.disabled.quality.tool.inspection.open.fix=打開檢查設定

inspection.disabled.quality.tool.inspection= {0} 檢查已禁用

inspection.json.not.installed.packages=未安裝軟體套件
inspection.json.all.not.installed.packages=未安裝軟體套件
inspection.json.not.installed.packages.update.fix=更新所有軟體套件
inspection.json.not.installed.package.update.fix=更新軟體套件
inspection.json.not.installed.packages.install.fix=安裝軟體套件
inspection.json.duplicated.packages.0=require 和 require-dev 中存在重複的 ''{0}'' 條目
inspection.json.duplicated.packages.fix=從 require-dev 中移除重複項

#inspection -> Duplicate array keys
inspection.duplicate.array.keys.display.name=重複的陣列鍵
inspection.duplicate.array.keys.problem=重複的陣列鍵
inspection.duplicate.array.keys.problem.0=值為 ''{0}'' 的重複陣列鍵

#inspection -> Duplicate PhpDoc type
inspection.duplicate.phpdoc.type.problem=重複的類型 ''{0}''
inspection.duplicate.phpdoc.type.fix=從標記中移除重複類型

#inspection -> Undefined constant
inspection.undefined.constant.problem1=未定義的常數 '#ref'
inspection.undefined.constant.problem2=常數 '#ref' 可能未定義

#inspection -> Undefined function
inspection.undefined.function.problem1=未定義的函數 '#ref'
inspection.undefined.function.problem2=函數 '#ref' 可能未定義

#inspection -> Undefined property
inspection.undefined.field.problem1=通過魔術方法存取的屬性
inspection.undefined.field.problem2=屬性動態宣告
inspection.undefined.field.notify.access.magic.method=通過魔術方法存取屬性的通知
inspection.undefined.field.notify.dynamic.declaration=動態屬性宣告的通知

#inspection -> Undefined provider
inspection.undefined.phpunit.provider=未定義的 PHPUnit 資料提供程序 ''{0}''

#inspection -> PHPUnit missing target for test
inspection.phpunit.missing.target.element.ref=未找到 '#ref' 的測試目標元素

#inspection -> Covered function reference is provided without '::'
inspection.phpunit.covers.function.without.scope.resolution.operator=提供的覆蓋{0}引用沒有 ''::''

#inspection -> Deprecated assertEquals/assertNotEquals usage
inspection.phpunit.asserts.assertEquals.parameters.many=可選的 {0} 個參數已棄用
inspection.phpunit.asserts.assertEquals.parameters.single=可選的 {0} 個參數已棄用
inspection.phpunit.asserts.assertEquals.parameters.empty=帶有此類參數的調用已棄用

#inspection -> Usage assertCount/assertSameSize methods instead of assertEquals
inspection.phpunit.asserts.assert.with.count.function=可以使用方法 {0} 代替 {1}

#inspection -> Misordered assertEquals/assertNotEquals arguments
inspection.phpunit.asserts.assertEquals.misordered.arguments=順序錯誤的 ''{0}()'' 實參

#inspection -> Method assertArrayHasKey/assertArrayNotHasKey can be used instead
inspection.phpunit.asserts.array.has.key.can.be.used.instead=可以改用方法 ''{0}''

#inspection -> Deprecated expectException usage
inspection.phpunit.expectException=對將 expectException() 用於 {0} 的支援已棄用，將在 PHPUnit 10 中移除。請改用 {1}()。

#inspection -> Unnecessary fully qualified name
inspection.unnecessary.qualifier.already.imported.message=限定符不必要，可以移除
inspection.unnecessary.fully.qualified.name.option.enable.file.scope=在檔案範圍內啟用
inspection.unnecessary.fully.qualified.name.option.ignore.global.namespace=忽略全域命名空間

#inspection -> Fully qualified name usage
inspection.fully.qualified.name.usage=限定符可以取代為匯入
inspection.fully.qualified.name.usage.option.enable.file.scope=在檔案範圍內啟用
inspection.fully.qualified.name.usage.name.option.ignore.global.namespace=忽略全域命名空間

#inspection -> Multiple classes declaration in one file
inspection.multiple.classes.declarations.in.one.file=在此檔案中宣告了另一個類
#inspection -> Namespace name is not matched with project structure
inspection.illegal.psr.class.path.namespace.name.is.not.matched.to.psr0=命名空間名稱與 PSR-0/PSR-4 專案結構不符合
inspection.illegal.psr.class.path.class.is.not.matched.to.psr0={0}名稱與包含文件名不符合

#inspection -> Traditional Syntax Array Declaration Inspection
inspection.traditional.syntax.array.literal.detected=使用了傳統語法陣列文字

#inspection -> Too Many Parameters
inspection.too.many.parameters=參數數量超出指定限值
inspection.too.many.parameters.max.number.of.parameters=最大參數數量
inspection.too.many.parameters.ignore.constructors=忽略構造函數

#inspection -> Parameters count mismatch
inspection.method.parameters.count.mismatch=為方法調用提供了 {0} 個參數，但方法簽名使用了 {1} 個參數
inspection.method.parameters.count.mismatch.option.ignore.underscore=忽略最後一個參數為 $_ 的函數/方法
inspection.method.parameters.count.mismatch.option.ignore.func.get.arg=忽略帶有 func_get_arg/func_get_args 調用的函數/方法

#inspection -> Method __toString is not implemented
inspection.method.to.string.is.not.implemented.strict.mode=檢查每種表達式類型是否存在 __toString
inspection.method.to.string.is.not.implemented=沒有為類 ''{0}'' 實作方法 ''__toString''

#inspection -> Method or class is not case sensitive
inspection.codeSmell.function.call.is.not.casesensitive=函數/方法調用中的大小寫與宣告中的大小寫不符合
inspection.codeSmell.class.call.is.not.casesensitive=類用法中的大小寫與宣告中的大小寫不符合
inspection.codeSmell.namespace.reference.is.not.casesensitive=命名空間引用中的大小寫與宣告中的大小寫不符合

#inspection -> Method visibility shouldn't be overridden
inspection.codeSmell.overriding.method.visibility.description=方法可見性不應被覆寫

#inspection -> Usage of a variable variable
inspection.variable.variable=使用了可變變數

#inspection -> Strict type checking rules violation
inspection.strict.type.checking.parameter=應為 ''{0}'' 類型的參數，提供的是 ''{1}''
inspection.strict.type.checking.parameter.batch=參數 '#ref' 類型與宣告不相容
inspection.strict.type.checking.return=返回值必須為 ''{0}'' 類型，返回的是 ''{1}''
inspection.strict.type.checking.return.batch=返回值類型與宣告不相容
inspection.strict.type.checking.option=為所有檔案啟用
inspection.strict.type.checking.field.assignment=屬性必須為 ''{0}'' 類型，提供的是 ''{1}''
inspection.strict.type.checking.field.assignment.multi.resolve=賦值的類型 ''{0}'' 與屬性的宣告類型不相容

#inspection -> Incompatible return type
inspection.incompatible.return.type=返回值應為 ''{0}''，返回的是 ''{1}''
inspection.incompatible.return.type.batch=返回值類型與宣告不相容
inspection.incompatible.return.type.strict.type.checking=嚴格類型檢查
#inspection -> Missing strict types declaration
inspection.missing.strict.types.declaration=缺少嚴格類型宣告
inspection.missing.strict.types.declaration.add.declaration=添加嚴格類型宣告

#inspection -> Magic method visibility
inspection.magic.method.visibility.must.be.public=魔術方法 ''{0}'' 必須為 public
inspection.magic.method.visibility.must.be.static=魔術方法 ''{0}'' 必須為 static
inspection.magic.method.visibility.cannot.be.static=魔術方法 ''{0}'' 不能為 static

#inspection -> Naming convention
inspection.naming.convention.problem.descriptor.short={0} 名稱 <code>#ref</code> 過短({1} < {2}) #loc
inspection.naming.convention.problem.descriptor.long={0} 名稱 <code>#ref</code> 過長({1} > {2}) #loc
inspection.naming.convention.element.descriptor.regexp={0} 名稱 <code>#ref</code> 不符合正則表達式 ''{1}'' #loc
inspection.naming.convention.element.description.class=類
inspection.naming.convention.element.description.method=方法
inspection.naming.convention.element.description.property=屬性
inspection.naming.convention.element.description.variable=變數
inspection.naming.convention.element.description.function=函數
inspection.naming.convention.element.description.constant=常數

#inspection -> Replaceable assignment
inspection.assignment.replaceable.with=<code>#ref</code> 可以取代為 ''{0}'' #loc

#inspection -> Constructor style
inspection.constructor.style=舊式構造函數

#inspection -> Statement has empty body
inspection.statement.has.empty.body.comments.count.as.content=註釋計為內容
inspection.statement.has.empty.body.ignore.empty.while=忽略無主體的 'while' 迴圈
inspection.statement.has.empty.body.ignore.empty.for=忽略無主體的 'for' 迴圈

#inspection -> Convert loop to array_map
inspection.loop.can.be.converted.to.arraymap=迴圈可以轉換為 'array_map()' 調用

#inspection -> Convert loop to array_filter
inspection.loop.can.be.converted.to.arrayfilter=迴圈可以轉換為 'array_filter()' 調用

#inspection -> Convert loop to array_fill
inspection.loop.can.be.converted.to.arrayfill=迴圈可以轉換為 'array_fill()' 調用

#inspection -> Convert str_pos to str_contains
inspection.str.functions.strpos.call.can.be.converted.to.strcontains='strpos()' 調用可以轉換為 'str_contains()'
inspection.str.functions.substr.call.can.be.converted.to.strstartswith='substr()' 調用可以轉換為 'str_starts_with()'
inspection.str.functions.strpos.call.can.be.converted.to.strstartswith='strpos()' 調用可以轉換為 'str_starts_with()'
inspection.str.functions.substr.call.can.be.converted.to.strendswith='substr()' 調用可以轉換為 'str_ends_with()'
#inspection -> Convert array_map to loop
inspection.arraymap.can.be.converted.to.loop='array_map()' 調用可以轉換為迴圈

#inspection -> Convert array_filter to loop
inspection.arrayfilter.can.be.converted.to.loop='array_filter()' 調用可以轉換為迴圈

#inspection -> Convert array_fill to loop
inspection.arrayfill.can.be.converted.to.loop='array_fill()' 調用可以轉換為迴圈

#inspection -> Ignored class alias declaration
inspection.ignored.class.alias.declaration=忽略了類別名聲明

#inspection -> Format function parameters mismatch
inspection.format.function.parameters.mismatch.parameter=參數未映射到任何轉換規範
inspection.format.function.parameters.mismatch.conversion.specification=轉換規範未映射到任何參數

inspection.export.results.const=常數
inspection.export.results.back.traces=反向跟踪

inspection.unused.symbol.check.fields=屬性
inspection.unused.symbol.check.methods=方法
inspection.unused.symbol.check.classes=類
inspection.unused.symbol.check.constants=常數
inspection.unused.symbol.check.anonymous_classes=匿名
inspection.unused.symbol.check.functions=函數
inspection.unused.symbol.check.magic_method=魔術方法
inspection.unused.symbol.export.calls=調用
inspection.unused.symbol.export.call=調用
inspection.unused.symbol.export.label=標籤
inspection.unused.symbol.export.reachable_element=可到達
inspection.unused.symbol.export.entry=入口點
inspection.unused.symbol.export.abstract=abstract
inspection.unused.symbol.export.closure=結束
inspection.unused.symbol.export.test_method=測試

inspection.composer.file.reference.problem=路徑 ''{0}'' 未找到

#inspection -> Method may be static
inspection.method.may.be.static=方法可以為 'static'

#inspection -> Missing field type
inspection.missing.field.type=缺少屬性的類型宣告

inspection.unpacked.argument.type.mismatch=僅可解包陣列和 Traversable，獲得的是{0}

inspection.closure.can.be.converted.to.arrow.function=閉包可以轉換為箭頭函數

inspection.field.assignment.type.mismatch=類型不相容: 應為 ''{0}'' 類型的屬性，提供的是 ''{1}''
inspection.field.assignment.type.mismatch.multi.resolve=賦值的類型 ''{0}'' 與屬性的宣告類型不相容

inspection.duplicate.switch.case.body=''switch'' 中的分支是 ''{0}'' 分支的重複項

inspection.duplicate.match.arm.body=''match'' arm 是 ''{0}'' arm 的重複項

inspection.switch.without.default.case='Switch' 沒有預設分支

inspection.doc.field.type.mismatch=屬性類型不符合

inspection.nested.ternary.expression=嵌套三元表達式自 PHP 7.4 已棄用

inspection.statement.without.braces=控制語句主體無大括號
inspection.statement.without.braces.fix.name=將大括號添加到 ''{0}'' 語句

inspection.single.statement.with.braces=單語句主體帶大括號
inspection.single.statement.with.braces.fix.name=從 ''{0}'' 語句中移除大括號

inspection.curly.braces.access.syntax.usage=大括號存取語法自 PHP 7.4 已棄用

inspection.expression.have.same.operands=表達式有相同操作數

inspection.deprecated.cast={0} 轉換自 PHP {1} 已棄用
inspection.deprecated.implode.usage=帶實參(陣列，字串)調用的 {0} 自 PHP 7.4 已棄用

quickfix.replace.curly.braces.with.brackets=將大括號取代為中括號

#quickfix
quickfix.is.not.available.in.dump.mode=在索引更新期間，''{0}'' 快速修復不可用
quickfix.cannot.find.class.reference=無法找到要解析的類引用
quickfix.cannot.find.target.class=無法從引用 ''{0}'' 解析類
quickfix.multiple.target.class.resolve=類 ''{0}'' 有多個宣告
quickfix.import.base.no.candidates=無法找到要匯入的候選項

#quickfix -> PhpCaseSensitiveQuickFix
quickfix.overriding.method.visibility=移除可見性覆寫

#quickfix -> PhpMoveClassToCorrespondingDirectoryQuickFix
quickfix.move.class.to.corresponding.directory=移至目錄 ''{0}''
quickfix.move.class.to.corresponding.directory.error.file.exists=檔案 {0} 已存在
quickfix.move.class.to.corresponding.directory.error.unable.create.directories=無法創建缺少的目錄: ''{0}''
quickfix.move.class.to.corresponding.directory.error.unable.move.file=無法將檔案移動到目錄 ''{0}''

#quick fix for:
quickfix.create.class=創建類
quickfix.failed.to.create.class=無法創建類 ''{0}''

#quic fix for:{PhpConstructorStyleInspection} -> Convert constructor to new style
quickfix.convert.to.new.style.constructor=將構造函數轉換為新樣式

#quick fix for: {PhpUnderfinedVariableInspection} -> Create parameter
quickfix.create.parameter=創建參數
#quick fix for: {PhpUnderfinedVariableInspection} -> Add to use
quickfix.add.to.use=添加到閉包 'use' 結構

#quickfix -> PhpImportClassQuickFix
quickfix.import.class.name=匯入類
quickfix.import.class.popup.title=要匯入的類

#quickfix -> PhpImportConstantQuickFix
quickfix.import.constant.name=匯入常數
quickfix.import.constant.popup.title=要匯入的常數

#quickfix -> PhpImportFunctionQuickFix
quickfix.import.function.name=匯入函數
quickfix.import.function.popup.title=要匯入的函數

#quickfix -> PhpAddFieldDeclarationQuickFix
#quickfix -> PhpAddMethodDeclarationQuickFix
#quickfix -> MakeCallDynamicQuickFix
quickfix.can.not.find.static.method.reference=無法找到 static 方法引用

#quickfix -> MakeCallStaticQuickFix
quickfix.make.call.static.name=將調用設為 static
quickfix.can.not.find.dynamic.method.reference=無法找到動態方法引用

#quickfix -> PhpAddFunctionFromCallback/PhpAddMethodFromCallback/PhpAddFieldFromCallback
quickfix.create.field.from.callback.name=從回調創建屬性
quickfix.create.field.from.callback.invalid.element=無法從回調提取屬性名稱
quickfix.create.field.from.callback.unresolved.class.ref=無法從回調創建屬性。無法解析目標類引用。
quickfix.create.field.from.callback.ambiguity.class.ref=無法從回調創建屬性。解析的類引用不明確。
quickfix.create.method.from.callback.name=從回調創建方法
quickfix.create.method.from.callback.invalid.element=無法從回調提取方法名稱
quickfix.create.method.from.callback.unresolved.class.ref=無法從回調創建方法。無法解析目標類引用。
quickfix.create.method.from.callback.ambiguity.class.ref=無法從回調創建方法。解析的類引用不明確。
quickfix.create.function.from.callback.family.name=從回調創建函數
quickfix.create.function.from.callback.name=添加函數
quickfix.create.function.from.callback.invalid.element=無法從函數回調提取 FQN
quickfix.create.function.from.callback.another.namespace=無法在 ''{0}'' 命名空間中創建函數

#quickfix -> PhpChangeParameterTypeQuickFix/PhpChangeReturnTypeQuickFix/PhpExtendReturnTypeQuickFix
quickfix.strict.type.checking.change.parameter.type.name=將{0, choice, 1#第 1 個|2#第 2 個|3#第 3 個|4#第 {0,number} 個}參數的類型從 ''{1}'' 更改為 ''{2}''
quickfix.strict.type.checking.change.parameter.type.family=更改參數類型
quickfix.strict.type.checking.change.return.type.name=將返回類型從 ''{0}'' 更改為 ''{1}''
quickfix.strict.type.checking.change.return.type.family=更改返回類型
quickfix.strict.type.checking.extend.return.type.name=將返回類型從 ''{0}'' 擴展為 ''{1}''
quickfix.strict.type.checking.extend.return.type.family=擴展返回類型

#quickfix -> PhpChangeTypeDeclarationQuickFix
quickfix.change.type=更改為 ''{0}''
quickfix.remove.type=移除類型 ''{0}''
quickfix.change.type.declaration.family=更改類型

#quickfix -> PhpCaseSensitiveQuickFix
quickfix.case.sensitive.name=更改 {0} 的大小寫以符合其宣告

#quickfix -> Replace assignment with operator assignment
quickfix.replace.assignment.with.operator.assignment.family.name=將賦值取代為運算符賦值
quickfix.replace.assignment.with.operator.assignment.name=將 ''='' 取代為 ''{0}=''

#quickfix -> Replace assignment with prefix expression
quickfix.replace.assignment.with.prefix.expression.family.name=將賦值取代為前綴表達式
quickfix.replace.assignment.operator.with.prefix.expression.family.name=將賦值運算符取代為前綴表達式

quickfix.replace.one.operator.with.another=將 ''{0}'' 取代為 ''{1}''

#quickfix -> Convert loop to array_map
quickfix.convert.loop.to.arraymap=將迴圈轉換為 'array_map()' 調用

#quickfix -> Convert loop to array_filter
quickfix.convert.loop.to.arrayfilter=將迴圈轉換為 'array_filter()' 調用

#quickfix -> Convert loop to array_fill
quickfix.convert.loop.to.arrayfilll=將迴圈轉換為 'array_fill()' 調用

#quickfix -> Convert array_map to loop
quickfix.convert.arraymap.to.loop=將 'array_map()' 調用轉換為迴圈

#quickfix -> Convert array_filter to loop
quickfix.convert.arrayfilter.to.loop=將 'array_filter()' 調用轉換為迴圈

#quickfix -> Convert array_fill to loop
quickfix.convert.arrayfill.to.loop=將 'array_fill()' 調用轉換為迴圈

#quickfix -> PHPUnit create missing target class
quickfix.phpunit.create.target.class.error.filename.exists=存在檔案 {0}

#quickfix -> Replace current method with alternative 
quickfix.phpunit.replace.current.method.with.alternative=取代為 ''{0}''

#quickfix -> Drop redundant optional parameters
quickfix.phpunit.drop.redundant.optional.parameters=刪除冗餘的可選參數

#quickfix -> Flip misordered assertEquals/assertNotEquals arguments
quickfix.phpunit.assert.equals.flip.compared.arguments=翻轉比較實參

#quickfix -> Unnecessary qualifier
quickfix.remove.unnecessary.qualifier=移除不必要的限定符
quickfix.remove.unnecessary.qualifier.on.class.name=簡化 FQN

#quickfix -> Disable for global namespace
quickfix.disable.inspection.for.global.namespace=為全域命名空間禁用檢查

#quickfix -> Make method static
quickfix.make.method.static=設為 'static'

#quickfix -> Change field type
quickfix.change.field.type.to.match.super=更改類型以符合父項
quickfix.change.field.type.add.inferred.type.family.name=作為屬性的類型添加推斷的類型
quickfix.change.field.type.add.inferred.type.name=作為屬性的類型添加 ''{0}''
quickfix.change.field.type.add.inferred.type.error.read.only=無法修改唯讀檔案 ''{0}''
quickfix.change.field.type.add.inferred.type.error.non.project=無法修改非專案檔案 ''{0}''

#quickfix -> Remove redundant PHPDoc
quickfix.remove.phpdoc=移除冗餘 PHPDoc 註釋

quickfix.remove.phpdoc.signature.tags=移除不必要的 @param 和 @return 標記
quickfix.remove.phpdoc.param.tag=移除 @param 標記
quickfix.remove.phpdoc.return.tag=移除 @return 標記

quickfix.phpdoc.update.type=更新 PHPDoc 類型
quickfix.phpdoc.update.field.type=將屬性類型更改為 ''{0}'' 以匹配 PHPDoc 註釋

quickfix.replace.nested.ternary.expression=將三元表達式取代為 {0} 關聯版本

quickfix.set.inheritance.between.classes=使{0} {1} {2}

quickfix.navigate.to.duplicate.array.key=導航到重複鍵
quickfix.navigate.to.duplicate.condition=導航到重複條件

#quickfix -> Delete return argument
quickfix.delete.return.argument=刪除返回實參

quickfix.remove.default.arm=移除重複的 'default' match arm
#intentions

#intentions Replace ?: expression with If
intention.replace.ternary.expression.with.if=將 '?:' 取代為 if

#intentions Replace If with ?: expression
intention.replace.if.with.ternaryExpression=簡化 'if'

#intentions -> Convert To Short Syntax
intention.convert.to.short.syntax=將陣列轉換為短語法
intention.convert.to.traditional.syntax=將陣列轉換為傳統語法

#intentions -> Convert To Short Syntax (list)
intention.convert.to.short.syntax.list=將列表轉換為短語法
intention.convert.to.traditional.syntax.list=將列表轉換為傳統語法

#intentions -> Declare Field
intention.declare.missing.field=宣告屬性

#intentions -> Declare Property
intention.declare.missing.property=添加 @property

#intentions -> Flip Binary Expression
intention.flip.binary.expression.family.name=翻轉二進制表達式
intention.flip.binary.expression.text1=翻轉 ''{0}''
intention.flip.binary.expression.text2=翻轉 ''{0}'' (可能更改語意)
intention.flip.binary.expression.text3=翻轉 ''{0}'' (更改語意)

#intentions -> Namespace Bracing
intention.namespace.bracing=將命名空間轉換為帶大括號

#intentions -> Smart Line Split
intention.line.split=在兩個字串和串聯中拆分字串

#intentions -> Split comma-separated values
intention.split.comma.separated.values=將逗號分隔的值拆分為多行
intention.join.comma.separated.values=將逗號分隔的值合併為一行

#intentions -> Swap Call Arguments
intention.swap.call.arguments.family.name=交換調用實參
intention.swap.call.arguments.text1=交換 ''{0}'' 和 ''{1}''

#intention -> Add variable PHPDoc comment
intention.variable.add.phpdoc.comment.family.name=添加 PHPDoc 註釋

#intention -> Import class
intention.import.class=作為別名匯入類
intention.import.class.alias.name=別名:
intention.import.class.alias.already.exists=已匯入具有相同別名的類

#intention -> Simplify FQN
#intention -> Generate PHPDoc
intention.generate.phpdoc=生成 PHPDoc

#intention -> Surround With Call
intention.can.not.find.statement.to.surround=無法找到要環繞的目標語句。
intention.statement.to.surround.failed.message=無法用 ''{0}'' 環繞語句。

#intention -> Replace quotes
intention.replace.quotes=無法取代引號 - 轉義符號無效且\\\\\\\\r 不受支援

#intention -> Replace with alias
intention.replace.class.with.alias=取代為別名

#intention -> Inline alias
intention.inline.alias=內聯別名

#intention -> Add constructor parameters
intention.add.constructor.parameters=添加構造函數參數
intention.add.constructor.parameters.fields.chooser.dialog.title=選擇要在構造函數中初始化的屬性

#intention -> Implement the interface
intention.implement.interface=實作接口

intention.merge.condition.with.outer=與外部條件合併

#navigation -> Goto Super Method
navigation.goto.super.method.is.not.available=索引更新期間無法在此處導航

#run and debug
#dbgp debugging protocol
dbgp.invalid.packet=無效數據包

#annotator
annotator.duplicate.use.statement=無法使用 ''{0}''，因為該名稱已被使用
annotator.duplicate.default.match.condition=match 表達式只能包含一個 'default' 分支
annotator.unhandled.match.argument=未處理的 'match' 實參
annotator.reserved.class.name=無法使用 ''{0}'' 作為類名，因為該名稱已被保留
annotator.invalid.class.name=''{0}'' 是無效的類名
annotator.special.class.name=無法將 {0} 用作 {1}，因為 ''{1}'' 是一個特殊的類名
annotator.cannot.break.continue=無法中斷/繼續{0}級別
annotator.jump.out.of.finally=不允許跳出 finally 塊
php.annotator.expecting.interface=應為接口引用
php.annotator.expecting.class=應為類引用
php.annotator.exchange.extends.implements.keyword=將 ''{0} {2}'' 更改為 ''{1} {2}''
php.annotator.strict.types.first.statement='strict_types' 宣告必須是腳本中的第一條語句
php.annotator.strict.types.block.mode='strict_types' 宣告不能使用塊模式
php.annotator.heredoc.indent.validation.mixed.space.and.tab.characters=結束關鍵字縮排中混用了空格和制表符字符
php.annotator.heredoc.indent.validation.wrong.content.indent=縮排錯誤:應與結束標記縮排相同
php.annotator.typed.property.illegal.value=''{0}'' 類型的屬性可能沒有預設值
php.annotator.typed.property.type.mismatch=預設值只能是 ''{0}'' 類型
php.annotator.typed.property.type.mismatch.fix.nullable=使屬性類型可為 null
php.annotator.typed.parameter.type.mismatch.fix.nullable=使參數類型可為 null
php.annotator.typed.property.type.mismatch.fix.change=將屬性類型更改為 ''{0}''
php.annotator.typed.parameter.type.mismatch.fix.change=將參數類型更改為 ''{0}''
php.annotator.typed.property.type.mismatch.fix.family=更改屬性類型以符合預設值的類型
php.annotator.typed.parameter.type.mismatch.fix.family=更改參數類型以符合預設值的類型
php.annotator.typed.property.callable.is.illegal=屬性不能有 'callable' 類型
php.annotator.return.type.non.nullable.null.returned=無法返回 'null': 返回類型不可為 null
php.annotator.return.type.make.nullable.fix=使返回類型可為 null
php.annotator.void.function.must.not.return.value=void 函數不得返回值
php.surround.with.if=if

#quality tool
quality.tool.configuration.tool.path.is.empty=所選配置的 {0} 路徑為空
quality.tool.configuration.can.not.find.configuration.by.id=按 ID 無法找到 {0} 配置: ''{1}''
quality.tool.configuration.default.interpreter.is.not.found=預設選擇 {0} 配置解釋器，但未指定解釋器
quality.tool.configuration.for.interpreter.is.not.found=找不到解釋器的 {0} 配置: ''{1}''
quality.tool.configuration.interpreter.is.undefined={0} 配置的解釋器未指定或無效
quality.tool.phpcs.custom.rules.warning=選擇 'Custom' 編碼標準類型以選擇自訂規則集。
quality.tool.phpcs.custom.rules.validation.not.xml=所選規則集不是 XML
guality.tool.configuration.show.ignored.files=顯示忽略的檔案
quality.tool.phpcs.installed.paths=已安裝的標準路徑
quality.tool.empty.path.phpcs={0} 的路徑為空
quality.tool.phpcbf.location=PHPCBF 位置
quality.tool.phpcbf.location.descr=選擇有效的 phpcbf 啟動器
quality.tool.phpcbf.settings=PHP Code Beautifier and Fixer 設定
quality.tool.phpcbf.path=phpcbf 路徑:
quality.tool.phpcbf.reformat.action=PHP Code Beautifier and Fixer: 修復整個檔案
quality.tool.phpcbf.name=PHP Code Beautifier and Fixer
quality.tool.selected.file.is.not.phpcbf=所選檔案不是 phpcbf 可執行檔案
quality.tool.cs.fixer.custom.rules.warning=選擇 'Custom' 類型以選擇您的配置。
quality.tool.php_cs.custom.rules.validation.not.php_cs=PHP CS Fixer 不支持選定的規則集
quality.tool.php_cs.dir.does.not.contain.custom=此目錄不包含任何受支援的檔案: {0}
quality.tool.php.dir.does.not.contain=該目錄不包含{0}
quality.tool.can.not.determine.version=無法確定工具版本，得到 ‘{0}’
quality.tool.file.not.found=找不到檔案。
quality.tool.path.must.not.be.empty=路徑不能為空。
quality.tool.can.not.retrieve.standards=無法檢索可用規則集，請檢查 PHP CS Fixer 工具配置。
quality.tool.phpcs.can.not.retrieve.standards=無法檢索可用標準，請檢查 PHP_CodeSniffer 工具配置。
quality.tool.stardards.has.been.updated=已安裝的規則集列表已更新。
quality.tool.coding.stardards.has.been.updated=已安裝的編碼標準列表已更新。
quality.tool.cs.fixer.allow.risky.rules=允許為內建規則集設定有風險的規則
quality.tool.cs.fixer.reformat.action=PHP CS Fixer: 修復整個檔案
quality.tool.cs.fixer.ruleset=規則集:

quality.tool.phpcs.required.phpcs.version=所需的 PHP_CodeSniffer 版本為 1.5.0 或更高，找到的是 {0}
quality.tool.php.cs.fixer.required.phpcs.version=支援的 PHP CS Fixer 版本為 2.8.0 或更高，找到的是 {0}

quality.tool.label.check.files.with.extensions=檢查帶副檔名的檔案:
quality.tool.label.coding.standard=編碼標準:
quality.tool.checkbox.installed.standard.paths=已安裝的標準路徑:
quality.tool.checkbox.show.sniff.name=顯示 sniff 名稱
quality.tool.checkbox.show.warning.as=將警告顯示為:
quality.tool.label.tool.path=工具路徑:
quality.tool.label.tool.process.timeout=工具處理超時，[1...60] 秒:
quality.tool.button.validate=驗證
quality.tool.label.validation.label=驗證標籤
quality.tool.label.custom.rulesets=自訂規則集:
quality.tool.phpcs.label.path.to.ruleset=規則集路徑:
quality.tool.label.label=標籤
quality.tool.label.configuration=配置:

#phpunit messages
php.unit.local.run.display.name=PHPUnit
php.unit.local.run.description=PHPUnit
php.not.test.method=類 ''{1}'' 中的方法 ''{0}'' 不是測試方法
php.method.not.found=在類 ''{1}'' 中未找到方法 ''{0}''
php.method.name.empty=未指定測試方法
php.unit.radio.button.composite=復合
php.unit.test.runner.options=測試執行程序選項
php.unit.checkbox.use.alternative.patterns.base.path=使用替代模式基路徑:
php.unit.optional=可選
php.unit.label.test.file.template=測試檔案模板(&T):

choose.php.home=選擇 PHP 可執行檔案
cleaning.up=正在清理…
this.reassignment.is.not.allowed=不能重新分配 $this
cant.use.temporary.expression.in.write.context=在寫上下文中不能使用臨時表達式
parsing.error.statement.expected=應為語句
smarty.configurable.title=Smarty
analyzing.php.sdk=正在檢查 PHP 安裝…
include.path.column.info=路徑
working.directory.invalid=找不到工作資料夾 ''{0}''
#control flow
#validation common
validation.file.already.exists.in.dir=名稱為“{0}”的檔案已存在於“{1}”中
validation.file.already.exists=檔案 \\"{0}\\" 已存在
validation.file.not.valid.name=“{0}”不是有效的文件名
validation.class.not.valid.name=\\"{0}\\" 不是有效的類名
validation.namespace.not.valid.name=“{0}”不是有效的命名空間名稱
validation.invalid.identifier=“{0}”不是有效的關鍵字
validation.invalid.identifier.with.no.identifier=插入的關鍵字無效
validation.invalid.alias=“{0}”不是有效的別名
validation.value.is.not.specified.or.invalid={0} 未指定或無效。
validation.value.path.to.value.should.be.specified={0} 的路徑應在 {1} 中指定
validation.value.path.to.value.is.invalid=無法通過 {1} 中提供的路徑找到 {0}
validation.value.path.to.value.is.invalid.press.fix.project.configuration=無法通過 {1} 中提供的路徑找到 {0}。按“修復”以編輯 {2} 配置。
validation.value.is.not.specified.or.invalid.press.fix.project.configuration={0} 未指定或無效。按“修復”編輯您的專案配置。
validation.value.is.not.specified.press.fix.project.configuration={1} 配置中未指定 {0}。按“修復”以編輯 {1} 配置。
validation.press.fix.to.edit.project.configuration=按“修復”編輯您的專案配置。
validation.value.is.invalid={0} 無效
validation.0.not.found.at.1=在 ''{1}'' 中找不到 ''{0}''
validation.0.is.not.a.directory=''{0}'' 不是目錄
validation.0.extension.is.not.installed=未安裝 ''{0}'' 擴展
validation.debug.extension.is.updated=調試擴展設定已更新。請重新執行當前配置以使用新值。
validation.0.extension.is.installed.check.configuration.options=已安裝 ''{0}'' 擴展。檢查配置選項。
validation.no.debug.extension.is.installed=未安裝調試擴展。
validation.cannot.parse.value.of.0=無法解析 ''{0}'' 的值
validation.connection.was.not.established=未建立連接。
validation.connection.was.not.established.0=無法使用 ''{0}'' 啟動調試器會話
validation.connection.was.not.established.no.debug=未安裝調試擴展
validation.connection.was.not.established.update.info=更新解釋器資訊
validation.connection.was.not.established.validate.installation=驗證安裝
validation.function.already.exists = 當前命名空間中已定義具有相同名稱的函數
validation.namespace.already.exists = {1}中已定義名稱為 ''{0}'' 的命名空間
validation.class.already.exists = {0}中已經存在具有相同名稱的類
validation.class.cannot.be.overridden = 類“{0}”不能被覆寫
validation.interface.cannot.be.overridden = 無法實作接口“{0}”
validation.test.no.test.patterns = 未添加任何模式

validation.ssh.remote.debug.support=''{0}'' 擴展不支持通過 ssh 進行遠端調試。
validation.ssh.remote.code.coverage.support={0} 擴展不支持通過 ssh 進行程式碼覆蓋
remote.interpreter.path.mappings.validation.title=沒有為所選解釋器配置路徑映射。
remote.interpreter.path.mappings.validation.message=請檢查映射是否在 {0} 下正確配置。
remote.interpreter.path.mappings.validation.php.section=<b><i><a href=\\"php_mappings\\">設定|PHP</a></i></b>
docker.compose.coverage.file.is.not.found=找不到覆蓋率檔案
docker.compose.coverage.file.failed.to.copy=無法從 Docker 容器複製覆蓋率結果
docker.compose.coverage.file.failed.to.extract=無法提取覆蓋率結果
docker.compose.radio.button.always.start.a.new.container.docker.compose.run=始終啟動一個新容器('Docker-compose run')
docker.compose.radio.button.connect.to.existing.container.docker.compose.exec=連接到現有容器('Docker-compose exec')
docker.compose.failed.to.start.container=啟動 docker-compose 服務失敗，請在命令行中啟動並重試

#errors common
error.template.unable.parse.internal.template=無法解析內部模板 {0}
error.template.unable.create.from.internal.template=無法從內部模板 {0} 創建檔案
error.file.unable.create.selected.directory=無法在所選目錄中創建檔案 {0}
error.cannot.connect.to.0.1=無法連接到 ''{0}'': {1}
error.cannot.connect.to.0=無法連接到 ''{0}''

#messages common
0.completion.shortcut=使用{1}進行{0}補全

#completion
completion.press.again.to.see.more.variants=再次按 {0} 以查看更多變體
completion.press.again.to.see.global.variants=再次按 {0} 以查看全域變體
completion.press.again.to.see.all.classes=再次按 {0} 以查看所有類

#unwrap
unwrap.if=解開 if…
unwrap.while=解開 while...
unwrap.for=解開 for...
unwrap.try=解開 try...
unwrap.else=解開 else...
unwrap.elseif=解開 elseif…
unwrap.dowhile=解開 do-while…
unwrap.foreach=解開 foreach…
unwrap.method=解開 ''{0}''
remove.else=移除 else...


#refactoring
refactoring.common.not.supported.expression.in.scope=當前範圍不支持此類表達式的{0}
refactoring.common.not.supported.context=當前上下文不支持{0}
refactoring.common.not.extractable.expression=不支持此類表達式
refactoring.common.fail.to.extract.expression=無法從所選程式碼段中提取表達式

refactoring.common.ui.target.namespace.label=命名空間(&N):
refactoring.common.ui.target.directory.label=目標目錄(&D):
refactoring.common.ui.target.directory.edit = 按 F2 編輯目標目錄

refactoring.common.validation.namespace.name=“{0}”不是有效的命名空間名稱
refactoring.common.validation.class.psi=無法執行重構: 目標類“{0}”無效
refactoring.common.validation.target.directory.is.not.valid=目錄“{0}”的路徑無效
refactoring.common.validation.target.directory.not.inside.project=目錄“{0}”不在專案內部

refactoring.parameter.reserved.name = 參數名稱“{0}”已保留
refactoring.parameter.validation = 參數 {0} 無效
refactoring.parameter.validation.duplicate.parameter=重複的參數名稱: {0}
refactoring.parameter.validation.initializer.last=必選參數不能位於可選參數後
refactoring.parameter.validation.variadic.last=只有最後一個參數可以是可變形參
refactoring.parameter.validation.variadic.can.have.default.value=可變參數不能具有預設值
refactoring.parameter.validation.initializer.type=具有類類型提示的參數的預設值只能為 NULL
refactoring.parameter.validation.pass.by.reference=僅變數可通過引用傳遞
refactoring.parameter.validation.type=參數類型 ''{0}'' 無效
refactoring.parameter.validation.default.value=預設值表達式 ''{0}'' 無效
refactoring.parameter.validation.initializer=初始值設定項 ''{0}'' 無效
refactoring.parameter.validation.no.default.value=應該為參數 ''{0}'' 提供初始值設定項或預設值
refactoring.parameter.validation.name.collision.with.use.list=參數名稱 ''{0}'' 無效。''{0}'' 已匯入 use 列表
refactoring.returnType.validation.type=返回類型 ''{0}'' 無效

#refactoring - > extract base
refactoring.extract.base.validator.not.valid.identifier=“{0}”不是有效的 PHP 關鍵字。
refactoring.extract.base.validator.reserved.keyword=“{0}”是保留的 PHP 關鍵字。
refactoring.extract.base.handler.no.expression.selected=選擇不構成正確的表達式
refactoring.extract.base.handler.not.supported.expression=此類表達式不支持{0}
refactoring.extract.base.handler.not.supported.scope=當前範圍不支持{0}
refactoring.extract.base.dialog.replace.all.occurrences=取代所有符合項(找到 {0} 個匹配項)(&A)
#refactoring -> extract class
refactoring.extract.class.extract.to.class=提取到類
refactoring.extract.class.extracting.from.file=正在從檔案提取:
refactoring.extract.class.extracting.from.class=正在從類提取:
refactoring.extract.class.dialog.class=類名:
refactoring.extract.class.dialog.generate.accessors=生成存取器
refactoring.extract.class.dialog.members.to.be.extracted=要提取的成員
refactoring.extract.class.error.failed.to.create.file=無法創建檔案
refactoring.extract.class.preview=已提取的類預覽
refactoring.extract.class.conflicts.extract.class.refactoring.is.not.supported.for.dynamically.declared.properties.usages=動態宣告屬性用法不支持“提取類”重構
refactoring.extract.class.conflicts.method.0.depends.on.property.1.which.needs.getters.in.2=方法 \\"{0}\\" 依賴於屬性 \\"\${1}\\"，需要 \\"{2}\\" 中的 getter
refactoring.extract.class.conflicts.method.0.depends.on.property.1.which.needs.setters.in.2=方法 \\"{0}\\" 依賴於屬性 \\"\${1}\\"，需要 \\"{2}\\" 中的 setter
refactoring.extract.class.conflicts.method.0.depends.on.1.method.2=方法 \\"{0}\\" 依賴於 {1} 方法 \\"{2}\\"
refactoring.extract.class.conflicts.method.0.depends.on.1.constant.2=方法 \\"{0}\\" 依賴於 {1} 常數 \\"{2}\\"
refactoring.extract.class.conflicts.unable.to.add.delegate.property.initialization.to.constructor=無法將委託的屬性初始化添加到類構造函數
refactoring.extract.class.conflicts.unable.to.add.delegate.property.initialization.to.constructor.trait.constructor.will.be.overridden=無法將委託的屬性初始化添加到類構造函數: 特徵構造函數將被覆寫
refactoring.extract.class.conflicts.using.write.access.for.non.public.properties.in.array.destructuring.expressions.is.not.supported.in.extract.class.refactoring=“提取類”重構不支持將寫入權限用於陣列析構表達式中的非 public 屬性
refactoring.extract.class.conflicts.using.write.access.for.non.public.properties.in.multiple.assignment.expressions.in.extract.class.refactoring=“提取類”重構不支持將寫入權限用於多個賦值表達式中的非 public 屬性
refactoring.extract.class.error.the.selected.function.should.belong.to.project.sources=所選函數必須屬於專案源
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.anonymous.functions=匿名函數不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.anonymous.classes=匿名類不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.abstract.methods=抽象方法不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.doc.methods=通過 PHPDoc 定義的魔術方法不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.doc.properties=通過 PHPDoc 定義的魔術屬性不支持 Extract Class 重構
refactoring.validation.class.error.property.with.name.0.is.already.exists=已存在名稱為 \\"{0}\\" 的屬性

#refactoring -> extract variable
refactoring.extract.variable.name=提取變數
refactoring.extract.variable.conflict.already.exists=範圍中已經存在名稱為“{0}”的變數。
#refactoring -> extract constant
refactoring.extract.constant.name=提取常數
refactoring.extract.constant.conflict.already.exists=範圍中已經存在名稱為“{0}”的常數。
refactoring.extract.constant.conflict.exists.in.subclass.with.weaker.access=“{0}”的存取級別必須為“{1}”(如在類“{2}”中)或更弱
refactoring.extract.constant.conflict.exists.in.subclass=“{0}::{1}”將被此常數覆寫
refactoring.extract.constant.conflict.cannot.override.interface.constant=無法覆寫接口“{1}”的常數“{0}”
refactoring.extract.constant.unable.to.add.constant.declaration=\\"無法添加常數宣告\\"

#refactoring -> extract field
refactoring.extract.field.name=提取屬性
refactoring.extract.field.validator.reserved.field.name=“{0}”是保留的屬性名稱
refactoring.extract.field.conflict.already.exists=該類中已經存在名稱為“{0}”的屬性。
refactoring.extract.field.visibility=可見性
refactoring.extract.field.visibility.public=public(&U)
refactoring.extract.field.visibility.protected=protected(&O)
refactoring.extract.field.visibility.private=private(&I)

#refactoring -> extract parameter
refactoring.extract.parameter.name=提取參數

#refactoring -> rename - > element processor
conflict.method.with.same.name.already.exists=此類中已經定義了具有相同名稱的方法
conflict.field.with.same.name.already.exists=此類中已經定義了具有相同名稱的屬性
conflict.class.constant.with.same.name.already.exists=此類中已經定義了具有相同名稱的常數
conflict.variable.with.same.name.already.exists=已經定義了具有相同名稱的變數
conflict.parameter.with.same.name.already.exists=已經定義了具有相同名稱的參數
conflict.tag.name.contains.close.tag=文本包含“{0}”
conflict.use.with.same.name.already.exists=已經定義名稱相同的 'Use' 語句
conflict.class.with.same.name.already.exists=已經定義了具有相同名稱的類
conflict.function.with.same.name.already.exists=已經定義了具有相同名稱的函數
conflict.constant.with.same.name.already.exists=已經定義了具有相同名稱的常數
refactoring.rename.search.in.global.scope=在全域範圍中搜尋

#refactoring -> rename - > automatic renamers
refactoring.rename.automatic.renamer.accessors.name=重命名存取器(&C)
refactoring.rename.automatic.renamer.field.accessors.dialog.title=重命名存取器
refactoring.rename.automatic.renamer.field.accessors.dialog.description=將具有以下名稱的屬性存取器重命名為:
refactoring.rename.automatic.renamer.field.accessors.entity.name=存取器


refactoring.rename.automatic.renamer.class.name=重命名類(&C)
refactoring.rename.automatic.renamer.class.dialog.title=重命名類
refactoring.rename.automatic.renamer.class.dialog.description=將具有以下名稱的類重命名為:
refactoring.rename.automatic.renamer.class.entity.name=類

refactoring.rename.entity.name.inheritor=繼承者/檔案
refactoring.rename.inheritors.and.related.files.with.the.following.names.to=將具有以下名稱的繼承者和相關檔案重命名為:


#refactoring->inline variable
refactoring.inline.variable.cannot.extract.value=無法提取變數 ''\${0}'' 的值
refactoring.inline.cannot.find.variable.to.inline=無法找到要內聯的變數
refactoring.inline.variable.no.occurrences=沒有符合項可以被安全地內聯

#refactoring->inline function
refactoring.inline.function.title=內聯{0}重構
refactoring.inline.function.all.invocations.and.remove.the.method=全部內聯並移除{0}(&A)
refactoring.inline.function.all.invocations.keep.the.method=全部內聯並保留{0}(&E)
refactoring.inline.function.this.invocation.only.and.keep.the.method=僅內聯此調用並保留{0}(&K)
refactoring.inline.function.command=正在內聯{0}
refactoring.inline.function.cannot.inline.function.with.global.usage=無法內聯{0}和 <code>global</code> 用法
refactoring.inline.function.not.accessible.from.caller.site=無法從調用者站點存取成員引用 <code>{0}</code>
refactoring.inline.function.cannot.parse.function.body=無法解析函數體
refactoring.inline.function.cannot.inline.library.function=無法內聯庫函數
refactoring.inline.function.only.static.method.is.supported=僅支援 static 方法
refactoring.inline.function.reference.is.recursive=不支持遞歸調用
refactoring.inline.function.inline.function.refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow=當 return 語句中斷執行流程時，不支持內聯函數重構
refactoring.inline.function.parent.reference.unresolved=<code>parent</code> 類引用在 {0} 中未解析
refactoring.inline.function.yield.found.in.function.body=在函數體中找到 <code>yield</code> 用法

#refactoring->inline constant
refactoring.inline.constant.name=內聯常數
refactoring.inline.constant.command=內聯常數
refactoring.inline.constant.this.reference.only=僅內聯此引用並保留常數
refactoring.inline.constant.all.references.and.remove=全部內聯並移除常數
refactoring.inline.constant.all.references.and.keep=全部內聯並保留常數
refactoring.inline.constant.cannot.extract.value=無法提取常數的值
refactoring.inline.constant.is.never.used=常數 {0} 從未使用
refactoring.inline.constant.multiple.declarations=還有其他具有相同名稱的常數宣告。

#refactoring -> extact method/function
refactoring.extract.method.name=提取函數/方法
refactoring.extract.method.error.selected.block.should.represent.a.set.of.statement.or.an.expression=所選塊應代表一組語句或表達式。
refactoring.extract.method.error.a.set.of.statements.should.be.from.the.same.code.block=一組語句應來自同一程式碼塊。
refactoring.extract.method.error.there.are.break.continue.operators.which.can.interrupt.execution=存在會中斷執行的 break/continue 運算符。
refactoring.extract.method.error.inconsistent.return.points.in.selected.code.fragment=所選程式碼段中的返回點不一致。
refactoring.extract.method.tooltip=輸入 $name = 'init'
PhpExtractMethodDialog.extract.method=提取方法
PhpExtractMethodDialog.extract.function=提取函數
PhpExtractMethodDialog.visibility=可見性:
PhpExtractMethodDialog.public=public(&B)
PhpExtractMethodDialog.protected=protected(&T)
PhpExtractMethodDialog.private=private(&V)
PhpExtractMethodDialog.method=方法:
PhpExtractMethodDialog.function=函數:
PhpExtractMethodDialog.name=名稱(&A):
PhpExtractMethodDialog.declare.static=宣告 static(&S)
PhpExtractMethodDialog.generate.php.doc=生成 PhpDoc(&G)
PhpExtractMethodDialog.parameters=參數
PhpExtractMethodDialog.signature.preview=簽名預覽
PhpExtractMethodDialog.replace.tail.break.continue.with.return=將尾“break/continue”語句取代為“return”語句(&T)
PhpExtractMethodDialog.return.output.through=通過以下方式返回輸出變數:
PhpExtractMethodDialog.return.output.through.return=return 語句(&E)
PhpExtractMethodDialog.return.output.through.ref.parameters=通過引用傳遞的參數(&P)
PhpExtractMethodDialog.transformation.options=轉換選項
PhpExtractMethodDialog.output.variables=輸出變數
PhpExtractMethodDialog.duplicates.count=檢查並取代重複項(找到 {0} 個)
PhpExtractMethodDialog.duplicates.pending=正在搜尋重複項…
refactoring.extract.method.from.duplicate.code=從重複的程式碼中提取方法

#find usages
find.options.include.child.methods.checkbox=包括覆寫/實作方法(&V)
find.field.accessors.title=搜尋存取器
find.field.accessors.text=要搜尋 ''{0}'' 的存取器嗎?
usages.show.this.self.references=顯示 $this/自引用

#refactoring -> change signature
change.signature.find.usages.of.base.interface=類 {1} 的方法 {0}\\\\n\\\\
實作了接口 {2} 的方法。\\\\n\\\\
要{3}基方法嗎?
change.signature.find.usages.of.base.class=類 {1} 的方法 {0}\\\\n\\\\
重寫了類 {2} 的方法。\\\\n\\\\
要{3}基方法嗎?
change.signature.tooltip.parameter=$name = 'init' 或 &...$array = 'init'
change.signature.tooltip.default.value=要在此方法的所有現有調用中使用的值
change.signature.error.wrong.caret.position=文本游標應置於要重構的函數的名稱處。
change.signature.usage.view.declarations.header=要重構的函數
change.signature.column.name.parameter=參數:
change.signature.column.type.parameter=類型:
change.signature.initialize.new.parameters=創建並初始化類屬性(&I)
change.signature.parameter.may.have.side.effect=用作參數“{1}”的表達式“{0}”可能會有副作用
change.signature.arg.type.miss.argument=應為 ''{0}'' 類型的參數
change.signature.arg.type.incompatible=應為 ''{0}'' 類型的參數，提供的是 ''{1}''
change.signature.visibility.not.accessible=可見性為 {1} 的{0}將無法從{2}存取

#refactoring -> pull up/push down
refactoring.pull.up.class.does.not.have.base.classes.interfaces.in.project.files={0}在專案檔案中沒有基類/接口
refactoring.pull.up.implement.method = 在實作接口的類中創建方法存根(&S)
refactoring.pull.up.validation.field.into.interface = 無法將屬性拉入接口
refactoring.pull.up.validation.static.method.into.interface = {0} 為 static，不能為 abstract。
refactoring.pull.up.private.access = {0} 存取權限將更改為 {1}
refactoring.pull.up.abstract.method = 類 {0} 將被標記為 abstract
refactoring.pull.up.conflict.duplicate.constant = {0} 將與 {1} 中的常數衝突。
refactoring.pull.up.will.not.be.accessible.in.the.target.class={0} 在目標類中將無法存取。
refactoring.pull.up.static.reference.is.not.accessible.in.the.target.class=非 static 方法 {0} 不應在外部類中靜態調用
refactoring.pull.up.may.not.be.accessible.in.the.target.class={0} 在目標類中可能無法存取。
refactoring.pull.up.is.1.and.will.not.be.accessible.in.the.target.class={0} 為 private，在目標類中將無法存取。
refactoring.push.down.method.implemented.in.interface={0} 必須被宣告為 abstract 或實作 {1}
refactoring.push.down.validation.magic.method=移動魔術方法會產生副作用

#refactoring -> move class
refactoring.move.class.name = 移動類
refactoring.move.class.title = 將類 {0} 移至命名空間(&C):
refactoring.move.class.new.file = 將類提取到單獨的檔案(&E)
refactoring.move.class.in.non.code.message=註釋和字串中的類引用
refactoring.move.class.cannot.move.anonymous.class=無法移動匿名類

#refactoring -> move namespace
refactoring.move.namespace.name=移動命名空間
refactoring.move.namespace.title=移動命名空間 {0}
refactoring.move.namespace.new.namespace=新命名空間名稱(&N):
refactoring.move.related.namespace.description=將具有相關命名空間的檔案移至新目錄:
refactoring.move.related.namespace.title=移動具有相關命名空間的檔案
refactoring.move.related.namespace.name.column=新命名空間名稱
refactoring.move.related.namespace.directory.column=新建目錄
refactoring.move.related.namespace.collect.title=收集子命名空間
refactoring.move.namespace.header.message=移動命名空間
refactoring.move.namespace.message=要移動的命名空間
refactoring.move.namespace.in.non.code.message=註釋和字串中的命名空間引用

#refactoring -> move member
refactoring.move.method.label.text.field=將成員移至類(&C)
refactoring.move.member.method.is.overridden.in.a.sublclass={0} 在子類 {1} 中被覆寫
refactoring.move.members.there.are.several.classes.with.specified.name=存在多個具有指定名稱 {0} 的類
refactoring.move.members.is.not.a.valid.class.name=\\"{0}\\" 不是有效的類名
refactoring.move.member.title=移動 static 成員
refactoring.move.member.action.name=移動成員…
refactoring.move.members.to.be.moved=要移至另一個類的成員(&B)
refactoring.move.members.preview.header=要移至另一個類的成員
refactoring.move.members.unable.to.resolve.usage.callback.found=無法解析用法: 發現回調: {0}
refactoring.move.members.unable.to.resolve.usage.late.static.binding.detected=無法解析用法: 檢測到延遲 static 綁定: {0}
refactoring.move.members.late.static.binding.detected=檢測到延遲 static 綁定: {0}
refactoring.move.members.self.from.anonymous.class=無法處理對匿名類的自引用
refactoring.move.members.late.static.binding.detected.in.doc=在文檔中檢測到延遲 static 綁定
refactoring.move.members.is.not.accessible={0} 在 {1} 中無法存取
refactoring.move.members.cannot.find.target.class=找不到類 {0}
refactoring.move.members.member.will.change.visibility.to.public=成員 {0} 會將可見性更改為 public
refactoring.move.members.method.implements.abstract.method={0} 在 {1} 中實作 abstract 方法
refactoring.move.members.method.implements.method.in={0} 在 {1} 中實作方法
refactoring.move.members.0.will.be.hidden.in.1=成員 {0} 將在 {1} 中被隱藏
refactoring.move.members.only.constants.can.be.moved.to.interface = 只有常數可以移至接口

#refactoring -> move file constant
refactoring.move.constant.title=移動常數
refactoring.move.constant.label.text.field=將常數 {0} 移至類(&C)
refactoring.move.multiple.constant.label.text.field=將 {0} 個常數移至類(&C)
refactoring.move.constant.unable.to.resolve=無法解析 {0}
refactoring.move.constant.class.already.contains.constant=類 {0} 已包含常數 {1}

#refactoring -> move function
refactoring.move.function.title=移動函數
refactoring.move.function.label.text.field=將函數 {0} 移至類(&C)
refactoring.move.multiple.functions.label.text.field=將 {0} 個函數移至類(&C)
refactoring.move.constant.class.already.contains.method=類 {0} 已包含方法 {1}
refactoring.move.function.interface.cant.contain.method=接口中不允許帶有主體的方法

#refactoring -> move instance
refactoring.move.method.cannot.move.constructor=無法移動構造函數
refactoring.move.method.cannot.move.magic.method=無法移動魔術方法
refactoring.move.instance.method=移動實例方法
refactoring.move.instance.method.action.name=移動實例方法…
refactoring.move.instance.method.preview.header=要移至另一個類的方法
refactoring.move.instance.method.this.parameter.label=將取代類 {0} 的 $this 引用的參數名稱
refactoring.move.instance.method.usage.will.not.be.accessible=用法 {0} 將無法存取。應提高方法可見性

#refactoring -> make static then move method
refactoring.make.static.then.move.method.select=將方法 ''{0}'' 移至類
refactoring.make.static.then.move.method.message=方法 ''{0}'' 將被設為 ''public static''

#refactoring -> extract interface
refactoring.extract.interface.name=提取接口
refactoring.extract.interface.title=從類 ''{0}'' 提取接口
refactoring.extract.interface.invalid.caret.location=文本游標應置於要重構的類名處。
refactoring.extract.interface.invalide.extract.from.trait=無法從特徵提取接口。
refactoring.extract.interface.no.methods=沒有要提取到接口的方法。
refactoring.extract.interface.field=接口名稱(&I):
refactoring.extract.replace.class.reference=盡可能將類引用取代為接口(&F)
refactoring.extract.interface.members.title=要構成接口的成員(&B)
refactoring.extract.interface.phpdoc.title=PhpDoc
refactoring.extract.interface.phpdoc.do.nothing=保留原樣(&A)
refactoring.extract.interface.phpdoc.copy=複製(&C)
refactoring.extract.interface.phpdoc.move=移動(&M)
refactoring.extract.interface.validation.members.modifier=對於每個提取的方法，修飾符將更改為 public。
refactoring.extract.interface.fail.to.create.file=無法創建檔案 ''{0}''。

#refactoring -> make method static
refactoring.make.method.static=將方法設為 static
refactoring.make.method.static.method.calls.found.in.static.context=在 static 上下文中找到方法調用
refactoring.make.method.static.method.converts.method.to.static=將方法轉換為 static
refactoring.make.method.static.dynamic.method.call.found=實例物件應作為參數傳遞，找到動態方法調用: {0}
refactoring.make.method.static.this.found=實例物件應作為參數傳遞，找到 $this
refactoring.make.method.static.references.to.be.changed=待變更引用 {0}
refactoring.make.method.static.doc.method.is.not.supported=不支持文檔方法
refactoring.make.method.static.method.is.overridden=方法 {0} 被覆寫
refactoring.make.method.static.object.is.needed=方法 {0} 使用未作為參數傳遞的屬性 {1}
refactoring.make.method.static.private.field.is.not.accessible=private 屬性 {0} 無法從類外部存取
refactoring.make.method.static.protected.field.is.not.accessible=protected 屬性 {0} 無法從類及其繼承者外部存取
refactoring.make.method.static.writeAccess=檢測到 {0} 寫入存取，實例物件應作為參數傳遞。
refactoring.make.method.static.magic.method=魔術方法不能設為 static
refactoring.make.method.static.add.parameters.for.fields=添加屬性參數(&P):

#actions
#action -> detect namespace roots
actions.detect.namespace.roots.notification.id=PHP PSR-0 命名空間根檢測
actions.detect.namespace.roots.notification.title=檢測 PSR-0 命名空間根
actions.detect.namespace.roots.title=正在檢測 PSR-0 命名空間根…
actions.detect.namespace.roots.finished=已完成 PSR-0 命名空間根檢測。
actions.detect.namespace.roots.no.new.roots.detected=未檢測到新的 PSR-0 命名空間根。
actions.detect.namespace.roots.view.configuration=檢視配置
actions.detect.namespace.roots.manual.configuration=手動配置
actions.detect.namespace.roots.idea.view.configuration=您可以在 '專案結構 | 模組' 中修改設定。
actions.detect.namespace.roots.from.composer.title=PSR-0/PSR-4 根
actions.detect.namespace.roots.from.composer.idea.title=源根

#action -> detect language level
actions.detect.language.level.loaded.from.composer.title=PHP 語言級別
actions.detect.language.level.loaded.from.composer.idea.title=語言級別

#action --> common settings
actions.detect.common.setting.from.composer.suggest.title=將設定與 Composer 同步?
actions.detect.common.setting.from.composer.enable=啟用同步
actions.detect.common.setting.from.composer.disable=不同步
actions.detect.common.settings.updated.from.composer.title={0} 設定已更新
actions.detect.common.settings.composer.sync.state.title=與 composer.json 的同步{0}
actions.detect.common.setting.from.composer.show.settings=顯示設定

action.detect.user.settings.state.overwritten=如果打開同步，IDE 設定(PHP 語言級別，PSR-0/PSR-4 根)可能會被覆蓋
action.detect.user.settings.state.supported=支援 PSR-0/PSR-4 根和 PHP 語言級別的同步
action.detect.user.settings.state.overwritten.short=設定可能會被覆蓋: PSR-0/PSR-4 根和 PHP 語言級別。
action.detect.settings.sync.turned.on.title=已與 composer.json 同步
action.detect.settings.sync.turned.on=PHP 語言級別已與 composer.json 同步
action.detect.composer.json.not.found.title=找不到 composer.json
action.detect.composer.json.not.found=在路徑 {0} 下找不到 composer.json
action.detect.composer.json.open=在編輯器中打開

#action -> mark directory as namespace root
actions.mark.directory.as.psr.0.root.title=要將資料夾標記為 {0} 根嗎?
actions.mark.directory.as.psr.0.root=<i>{0}</i>
actions.mark.directory.as.psr.0.root.with.prefix=<i>{0}</i>為前綴“{1}”?
actions.mark.directory.as.psr.0.root.mark.psr=標記為 {0} 根

#action - > new php base
actions.new.php.base.dialog.label.file.name=文件名:
actions.new.php.base.dialog.label.extension=檔案副檔名:
actions.new.php.base.arrows.extension.tooltip=在編輯器中按向上或向下箭頭可更改檔案副檔名
actions.new.php.base.arrows.template.tooltip=在編輯器中按向上或向下箭頭可更改模板

#action -> new php file
actions.new.php.file.action.name=PHP 檔案
actions.new.php.file.action.description=創建新的 PHP 檔案
actions.new.php.file.dialog.title=創建新的 PHP 檔案

#action -> new php class
actions.new.php.class.action.name=PHP 類
actions.new.php.class.action.description=創建新的 PHP 類
actions.new.php.class.dialog.title=創建新的 PHP 類
actions.new.php.class.dialog.label.class.name=名稱:
actions.new.php.class.dialog.label.namespace=命名空間:
actions.new.php.class.dialog.label.directory=目錄:
actions.new.php.class.dialog.label.template=模板:
actions.new.php.class.dialog.label.superclasses.container=父類
actions.new.php.class.dialog.label.superclasses.super.fqn=擴展:
actions.new.php.class.dialog.label.superinterfaces.add.interface=添加接口…
actions.new.php.class.dialog.label.superinterfaces.to.implement=實作:
actions.new.php.class.dialog.label.superinterfaces.to.implement.empty=選擇要實作的接口
actions.new.php.class.dialog.label.superinterfaces.to.extend.empty=選擇要擴展的接口
actions.new.php.class.dialog.border.title.class=類

#action -> new php test
actions.new.test.class.action.name=新建 PHP 測試
actions.new.test.class.action.description=創建新的 PHP 測試
actions.new.test.class.dialog.title=創建新的 PHP 測試
actions.new.test.class.dialog.title.named=為 {0} 創建新的 PHP 測試
actions.new.test.class.dialog.label.name=名稱:
actions.new.test.class.dialog.label.namespace=命名空間:
actions.new.test.class.dialog.label.directory=目錄:
actions.new.test.class.dialog.label.fqn=完全限定名稱:
actions.new.test.class.dialog.border.title.class.to.test=要測試的類(可選)
actions.new.test.class.dialog.border.title.test.class=測試類
actions.new.test.class.dialog.border.title.target.class.file.path=檔案路徑:
actions.new.test.class.dialog.arrows.libraries.hint=在編輯器中按向上或向下箭頭可更改測試庫
actions.new.test.class.dialog.select.methods.show.inherited.methods=顯示繼承的方法(&I)

#action -> new PHPUnit test
actions.new.phpunit.class.action.name=PHPUnit 測試
actions.new.phpunit.class.action.description=創建新的 PHPUnit 測試

#action -> generate php doc
actions.generate.php.doc.is.not.available=PHPDoc 生成在索引更新期間不可用

unnamed.variable=(未命名)
server=伺服器
#Connection -> Server Connection
connection.port.is.busy=連接埠 {0} 繁忙

#Server configuration
debug.server.import.configuration.dialog.title=從部署配置匯入
debug.server.import.configuration.preview.border.title=預覽
debug.server.import.configuration.path.to.remote.root=部署根的絕對路徑(&R):
debug.server.import.configuration.path.to.remote.root.sftp=絕對遠端根: ''{0}''
debug.server.import.configuration.path.to.remote.root.sftp.tooltip=遠端檔案的絕對路徑:<br>\\"遠端根的絕對路徑\\" . \\"根路徑\\" (來自部署設定) . \\"伺服器上的相對部署路徑\\" (來自部署路徑映射)
debug.server.import.configuration.path.to.remote.root.mounted=本地: ''{0}'' -> 遠端: ''{1}''
debug.server.import.configuration.path.to.remote.root.mounted.label=已掛載資料夾的遠端路徑(&R):
debug.server.import.configuration.path.to.remote.root.mounted.tooltip=遠端檔案的絕對路徑:<br>\\"已掛載資料夾的遠端路徑\\" . \\"伺服器上的相對部署路徑\\" (來自部署路徑映射)
debug.server.import.configuration.deployment=部署(&D):
debug.server.import.configuration.local=本地(&L)
debug.server.import.configuration.mounted=已掛載(&M)

debug.server.import.configuration.local.file.path=本地檔案路徑:
debug.server.import.configuration.project=專案(&P):
debug.server.import.from.deployment.deployment.configurations.message=找到具有相關路徑映射的部署配置。
debug.server.import.from.deployment.no.deployment.configurations.message=找不到合適的部署配置
debug.server.import.from.deployment.no.deployment.configurations.tooltip=配置部署根(如果不為空)
debug.server.import.from.deployment.deployment.root.label=部署根(&R):
debug.server.import.from.deployment.radio=從部署匯入映射(&I)
debug.server.manually.select.file.or.project=手動選擇本地檔案或專案(&M)
debug.server.manually.select.file.message=選擇一個專案或檔案進行調試
debug.server.select.file.mapping=配置本地檔案路徑
debug.server.detect.path.mappings.from.deployment.progress=正在為 ''{0}'' 專案分析路徑映射
debug.server.detect.path.mappings.from.deployment=正在檢測現有路徑映射…
debug.server.can.not.detect.path.mappings.from.deployment=無法評估路徑映射: 未選擇目標部署伺服器

#Debug
debug.accept.connection=接受
debug.ignore.connection=忽略
debug.incoming.connection.title.0=來自 {0} 的傳入連接
debug.path.on.server=伺服器上的絕對路徑
debug.error.cannot.modify.value=無法修改值
debug.error.cannot.evaluate.variables=無法評估變數
debug.error.cannot.evaluate.expression0=無法評估表達式 ''{0}''
debug.error.cannot.evaluate.expression=無法評估表達式
debug.process.cannot.find.file.in.project=在專案中找不到路徑為 ''{0}'' 的檔案
debug.process.cannot.find.server.name=找不到源位置。名稱為 ''{0}'' 的伺服器不存在。
debug.process.status.disconnected=已斷開連接
debug.process.status.wait=正在等待與{0} ''{1}'' 的傳入連接
debug.process.status.connected=已連接
debug.process.console.error.format={0}: {1}，{2} 中的第 {3} 行\\\\n\\\\

debug.mapping.resolve.dialog.stop.debugger=停止調試器
debug.zend.error.title.cannot.accept.external.xdebug.connection=無法接受外部 Xdebug 連接
debug.zend.required.protocol.version.0.or.higher=所需協議版本為 ''{0}'' 或更高版本
debug.error.title.cannot.accept.external.0.connection=無法接受外部 {0} 連接
debug.zend.cannot.accept.incoming.connection=無法接受來自 Zend Debugger 的傳入連接
debug.zend.debugger.settings.broadcasting=Zend Debugger 設定廣播
debug.zend.debugger=Zend 調試器
debug.xdebug=Xdebug
debug.not.installed=<未安裝>
debug.process.cannot.find.file.link=更多資訊
debug.process.cannot.find.file=在本地找不到檔案 ''{0}''。\\\\n\\\\
要修復，請通過環境變數 PHP_IDE_CONFIG 設定伺服器名稱，然後重新啟動調試會話。
debug.process.cannot.find.local.file=在伺服器 {0} 上找不到檔案的本地副本\\\\n\\\\
本地路徑為 {1}
debug.process.cannot.find.path.mapping=遠端檔案路徑 ''{0}'' 未映射到專案中的任何檔案路徑
debug.process.script.outside.project=腳本 ''{0}'' 在專案外部。
debug.process.cant.compute.source.position=無法計算源位置。腳本 ''{0}'' 未與任何文本檔案類型關聯。
debug.edit.path.mappings=點擊以設定路徑映射
debug.configure.servers=配置伺服器
debug.settings.broadcasting.port=設定廣播連接埠:
debug.settings.auto.detect.ide.host=自動檢測 IDE IP:
debug.debug.port=調試連接埠:
debug.error=錯誤
debug.process.cannot.find.remote.copy.local.file=專案 ''{0}'' 中的檔案路徑未映射到伺服器上的任何檔案路徑
debug.cannot.map.local.file=檔案路徑未映射到伺服器上的任何檔案路徑。編輯路徑映射以解決此問題。
debug.resolve.mapping.problem=解決路徑映射問題
debug.cannot.start.listening.for.connections.from.0=無法開始偵聽來自 ''{0}'' 的連接
debug.cannot.start=無法啟動 ''{0}''
debug.stop.listen.debug.connections=停止偵聽 PHP 調試連接
debug.start.listen.debug.connections=開始偵聽 PHP 調試連接
debug.breakpoint.was.resolved=此處的調試會話已暫停，因為 ''{0}'' 處的斷點已被解析到此位置。<br/>您可以<a href=\\"disable\\">禁用</a>斷點解析或<a href=\\"more\\">了解詳情</a>。<a href=\\"dontshow\\">不再顯示</a>
debug.breakpoint.resolved.disabled=斷點解析已被禁用，從下一個調試會話開始將不會解析斷點。 您可以稍後在 <a href=\\"open\\">PHP|調試</a>下將其啟用。
debug.breakpoint.resolved.notify.disabled=斷點解析通知已被禁用。您可以在 <a href=\\"open\\">PHP|調試|高級設定</a>下將其啟用。
debug.log.invalid.xdebug.message=由於 Xdebug 訊息無效，無法在斷點處停止。\\\\n\\\\
要解決此問題，請切換到穩定版本的 Xdebug 或使用 'xdebug.remote_log' 選項收集日誌並創建錯誤報告。 
debug.log.stop=停止於 (''{0}'':{1})
debug.log.path.mapping.remote.local=遠端: ''{0}'' <-> 本地: ''{1}''
debug.log.path.mapping.remote.extracted=遠端: ''{0}'' <-> 提取: ''{1}''
debug.log.stack.frame=框架: {0}:{1}，{2}
debug.log.connection.was.terminated=調試連接在 ''{0}'':''{1}'' 上意外終止
debug.log.cant.register.breakpoint.no.remote=無法註冊斷點。沒有本地路徑 ''{0}'' 的路徑映射
debug.log.cant.register.breakpoint.no.template.mapping=無法註冊斷點。沒有到 PHP 行 ''{0}'' 的映射
debug.log.exception.break=異常中斷: {0} ({1})
debug.file.is.ignored=檔案 ''{0}'' 被跳過。
debug.edit.ignored.paths.list=<a href=\\"#a\\">編輯</a>跳過的路徑。
debug.composite.value.presentation=[{0}]
debug.error.unknown.debugger.id=未檢測到調試器擴展
debug.error.wrong.debugger.id=不支持 {0}
debug.type.array=陣列
debug.type.resource=資源
debug.type.int=int
debug.type.float=浮點
debug.xdebug.error.unsupported.protocol.version=不支持的 Xdebug 協議版本
debug.php.line.breakpoint.title=PHP 行斷點
debug.php.exception.breakpoint.title=PHP 異常斷點
debug.php.exception.breakpoint.not.supported=載入的調試擴展不支持異常斷點
debug.php.exception.breakpoint.zend.not.supported=Zend Debugger 不支持異常斷點
debug.php.exception.breakpoint.dialog.title=添加異常斷點
debug.php.exception.breakpoint.exception.name=異常名稱:
debug.php.method.breakpoint.title=PHP 方法斷點
debug.php.method.breakpoint.dialog.title=添加方法斷點
debug.php.method.breakpoint.zend.not.supported=Zend Debugger 不支持方法斷點
debug.php.breakpoint.failed.to.register=無法註冊斷點，請嘗試將其禁用並重新啟用。
debug.error.cannot.parse.ssh.connection=無法從 $_SERVER[''SSH_CONNECTION''] 解析連接埠: ''{0}''
debug.error.cannot.parse.server.name.for.external.connection=無法為外部 {0} 連接解析伺服器名稱。
debug.error.cannot.parse.server.name=要修復，請在遠端伺服器上創建環境變數 <i><b>PHP_IDE_CONFIG</b></i>。<br/><br/><i>Windows:</i> 設定 PHP_IDE_CONFIG=\\"serverName=SomeName\\"<br/> <i>Linux / Mac OS X:</i> 匯出 PHP_IDE_CONFIG=\\"serverName=SomeName\\"。
debug.error.server.name.is.empty=<i><b>$_SERVER[\\"SERVER_NAME\\"]</i></b> 為空，這可能是 Web 伺服器配置錯誤所致。<br/><br/><i>Nginx:</i> 將 fastcgi 參數添加至 nginx 配置，<a href=\\"http://wiki.nginx.org/PHPFcgiExample\\">更多</a><br/><i>Apache:</i> 為當前 VirtualHost 配置 ServerName，<a href=\\"https://httpd.apache.org/docs/2.4/vhosts/name-based.html\\">更多</a>

debug.php.external.connection.finished.warning.title=調試會話已完成且未暫停
debug.php.external.connection.finished.warning=這可能是由於路徑映射配置錯誤或本地和遠端專案未同步。<br/><br/>要找出問題，請在 <b><i><a href=\\"servers\\">PHP|伺服器</a></i></b>下檢查 ''{0}'' 伺服器的路徑映射配置，或啟用 <b><i><a href=\\"break\\">''在 PHP 腳本中的第一行中斷''</a></i></b> 選項(位於<i>執行</i>選單下)。<br/><a href=\\"ignore\\">不再顯示</a>
debug.php.external.connection.finished.break.at.first.line.title=PHP 調試配置
debug.php.external.connection.finished.break.at.first.line=<b><i>'在第一行中斷'</i></b> 選項已啟用

debug.process.smart.step.into.popup=單步進入函數
debug.process.smart.step.into.function.evaluation.error =無法評估目標函數。將執行“單步跳入”。
debug.process.smart.step.into.function.was.not.executed=尚未調用所選函數。

#rest client
debug.rest.client.error.cannot.evaluate.server.name.title=無法通過伺服器名稱找到對應的“PHP|伺服器”
debug.rest.client.error.cannot.evaluate.server.name=無法評估 '$_SERVER['SERVER_NAME']'。請確保為您的 Web 伺服器配置了正確的伺服器名稱。<br>點擊此<a href=\\"help\\">鏈接</a>獲取更多資訊。

# custom actions
debug.function.was.added.to.skip.list=''{0}'' 已添加到跳過列表。
debug.action.copy.as.title=將變數複製為 ''{0}''
debug.action.copy.as.was.fail.can.not.get.full.name=無法將變數複製為 ''{0}''，無法評估完整的變數名
debug.action.copy.value.as.text=將值複製為…

debug.label.select.a.project.or.a.file.to.debug=選擇一個專案或檔案進行調試
debug.label.select.a.project.to.debug=選擇一個專案進行調試
debug.label.file.path.on.server=伺服器上的檔案路徑:
debug.label.file.path.in.project=專案中的檔案路徑:
debug.checkbox.can.accept.external.connections=可以接受外部連接
debug.checkbox.ignore.z.ray.system.requests=忽略 Z-Ray 系統請求
debug.label.max.simultaneous.connections=最大同時連接數:

# templates
template.debug.path.to.output.folder.descr=指定快取目錄路徑
template.debug.path.to.output.folder=快取目錄路徑
template.debug.cache.path=快取路徑:
template.debug.cache.dir.is.incorrect=模板調試: 在設定中指定的快取目錄路徑無效
template.debug.cache.dir.is.not.specified=模板調試: 未在設定中指定快取目錄路徑
template.debug.php.file.not.found=模板調試: 未找到 {0} 的相應 PHP 檔案

postfix.template.provider.display.name=PHP

template.smart.completion.function.parameters.description=智能函數參數補全

debug.expression.evaluation.fail=由於返回值未知，無法評估表達式

dbgp.proxy=Xdebug 代理
dbgp.proxy.port=代理連接埠
dbgp.proxy.host=代理主機
dbgp.proxy.ide.key=IDE 鍵
dbgp.proxy.ide.register.success=IDE 已成功使用 IDE 鍵 ''{0}'' 註冊
dbgp.proxy.ide.unregister.success=IDE 已成功註銷
dbgp.proxy.ide.register.error=無法使用 IDE 鍵 ''{0}'' 註冊 IDE
dbgp.proxy.cannot.connect.to.host=無法連接到主機 ''{0}''
dbgp.proxy.cannot.connect.to.xdebug.proxy=無法連接到 ''{0}:{1}'' 上的 Xdebug 代理
dbgp.proxy.sending.request.to.xdebug.proxy=正在將請求发送到 Xdebug 代理…

profiler.xdebug.task.title=分析 Xdebug 分析器快照
profiler.xdebug.task.parsing=正在解析 ''{0}''
profiler.xdebug.file.chooser.title=選擇 Xdebug 分析器快照

profiler.view.execution.statistics.title=執行統計
profiler.view.call.tree.title=調用樹
profiler.view.callees.title=被調用方
profiler.view.callers.title=調用方
profiler.column.time.title=時間
profiler.column.memory.title=內存(B)
profiler.column.own.memory.title=自身記憶體(B)
profiler.column.own.time.title=自用時間
profiler.column.invocation.count.title=調用
profiler.column.invocation.callable=可調用
profiler.column.script=腳本

profiler.measurement.unit.second=秒
profiler.measurement.unit.second.short=秒
profiler.measurement.unit.millisecond=毫秒
profiler.measurement.unit.millisecond.short=毫秒
profiler.measurement.unit.microsecond=微秒
profiler.measurement.unit.microsecond.short=µs
profiler.button.refresh=刷新
profiler.label.time=時間:

#phpunit
php.uml.provider.presentable.name=PHP 類圖

#coverage
coverage.is.not.supported.for.selected.run.profile=程式碼覆蓋率與所選執行配置檔案不相容

#UI

#run configurations -> components -> command line
PhpCommandLineConfigurationEditor.interpreter.options.editor.dialog.caption=解釋器選項
PhpCommandLineConfigurationEditor.command.line=命令行
PhpCommandLineConfigurationEditor.field.interpreter.options=解釋器選項:
PhpCommandLineConfigurationEditor.field.custom.working.directory=自訂工作目錄:
PhpCommandLineConfigurationEditor.field.environment.variables=環境變數:

#run configurations -> components -> test runner
PhpUnitTestRunnerConfigurationEditor.test.runner=測試執行程序
PhpUnitTestRunnerConfigurationEditor.scope=測試範圍:
PhpUnitTestRunnerConfigurationEditor.scope.directory=目錄
PhpUnitTestRunnerConfigurationEditor.scope.class=類
PhpUnitTestRunnerConfigurationEditor.scope.method=方法
PhpUnitTestRunnerConfigurationEditor.scope.xml=在配置檔案中定義
PhpUnitTestRunnerConfigurationEditor.field.directory=目錄:
PhpUnitTestRunnerConfigurationEditor.field.method=方法:
PhpUnitTestRunnerConfigurationEditor.field.class=類:
PhpUnitTestRunnerConfigurationEditor.field.file=檔案:
PhpUnitTestRunnerConfigurationEditor.use.alt.configuration.file=使用替代配置檔案(&U):
PhpUnitTestRunnerConfigurationEditor.use.alt.bootstrap.file=使用替代啟動檔案(&U):
PhpUnitTestRunnerConfigurationEditor.field.test.runner.options=測試執行程序選項(&O):
PhpUnitTestRunnerConfigurationEditor.field.test.runner.coverage.engine=首選覆蓋率引擎:
PhpUnitTestRunnerConfigurationEditor.dialog.caption.test.runner.options=測試執行程序選項

# run configurations
PhpScripRunConfigurationEditor.configuration.display.name=PHP 腳本
PhpScripRunConfigurationEditor.configuration.description=PHP 腳本配置
PhpScripRunConfigurationEditor.file=檔案:
PhpScripRunConfigurationEditor.arguments=實參:
PhpScripRunConfigurationEditor.arguments.caption=實參

PhpHttpRequestRunConfiguration.configuration.display.name=PHP HTTP 請求
PhpHttpRequestRunConfiguration.configuration.description=HTTP 請求配置
PhpHttpRequestRunConfiguration.error.fetch.result=響應正文不可用
PhpHttpRequestRunConfiguration.error.server.is.not.specified=找不到名稱為 ''{0}'' 的遠端伺服器
PhpHttpRequestRunConfiguration.error.host.is.not.specified=伺服器 ''{0}'' 的主機未指定或無效
PhpHttpRequestRunConfiguration.error.url.is.not.specified=URL 未指定或無效: ''{0}''。
PhpHttpRequestRunConfiguration.error.server.configuration=無法執行 HTTP 請求: ''{0}''。請在“PHP|伺服器”下檢查伺服器配置。

RunConfigurationEditor.configuration=配置
RunConfigurationEditor.server=伺服器(&S):
RunConfigurationEditor.error.server.is.not.selected=未選擇伺服器
RunConfigurationEditor.error.server.is.not.exist=名稱為 ''{0}'' 的伺服器不存在

PhpWebAppRunConfigurationEditor.configuration.display.name=PHP Web 頁面
PhpWebAppRunConfigurationEditor.configuration.description=PHP Web 頁面配置
PhpWebAppRunConfigurationEditor.startUrl=起始 URL(&U):
PhpWebAppRunConfigurationEditor.browser=瀏覽器(&B):
PhpWebAppRunConfigurationEditor.malformed.start.url=起始 URL 的格式錯誤 - {0}

PhpRemoteDebugRunConfigurationEditor.configuration.display.name=PHP 遠端調試
PhpRemoteDebugRunConfigurationEditor.configuration.description=PHP 調試配置
PhpRemoteDebugRunConfigurationEditor.server.label=伺服器(&E)：
PhpRemoteDebugRunConfigurationEditor.session.id.label=IDE 鍵(會話 ID)(&K):
PhpRemoteDebugRunConfigurationEditor.auto.config=通過 IDE 鍵篩選調試連接
PhpRemoteDebugRunConfigurationEditor.session.id.cannot.be.empty=IDE 鍵(會話 ID)不能為空
PhpRemoteDebugRunConfigurationEditor.zero.configuration.used.title=已開始偵聽傳入 PHP 調試連接
PhpRemoteDebugRunConfigurationEditor.filter.connections.help.title=高級選項
PhpRemoteDebugRunConfigurationEditor.filter.connections.help=適用於複雜伺服器設定，例如同一主機連接埠上有多個應用程式。<p/>保持未選中狀態以自動檢測配置，或使用<i>“偵聽調試連接”</i>操作。
PhpRemoteDebugRunConfigurationEditor.filter.connections.help.link=閱讀更多資訊
PhpRemoteDebugRunConfigurationEditor.zero.configuration.used=沒有為 <i>''{0}''</i> 執行配置指定<i>伺服器</i>，因此 PhpStorm 將偵聽所有傳入調試連接。<br/>查看<a href=\\"zero_config\\">零配置調試</a>獲取更多資訊。<br/><br/>要停止偵聽調試連接，請使用<a href=\\"stop\\">執行|停止偵聽 PHP 調試連接</a>。
PhpRemoteDebugRunConfigurationEditor.zero.configuration.is.already.used=“偵聽傳入調試連接”已啟用，不會發生任何變化。<br/>查看<a href=\\"zero_config\\">零配置調試</a>獲取更多資訊。<br/><br/>要停止偵聽調試連接，請使用<a href=\\"stop\\">執行|停止偵聽 PHP 調試連接</a>。
PhpRemoteDebugRunConfigurationEditor.stop.zero.configuration.title=已停止偵聽傳入 PHP 調試連接
PhpRemoteDebugRunConfigurationEditor.stop.zero.configuration=PhpStorm 已停止偵聽傳入調試連接。

PhpBuiltInWebServerRunConfigurationEditor.configuration.display.name=PHP 內建 Web 伺服器
PhpBuiltInWebServerRunConfigurationEditor.configuration.description=PHP 內建 Web 伺服器配置
PhpBuiltInWebServerRunConfigurationEditor.title=伺服器配置
PhpBuiltInWebServerRunConfigurationEditor.host=主機:
PhpBuiltInWebServerRunConfigurationEditor.port=連接埠:
PhpBuiltInWebServerRunConfigurationEditor.document.root=文檔根:
PhpBuiltInWebServerRunConfigurationEditor.use.router.script=使用 router 腳本:

PhpDebugConfigurable.ignore.external.connections.through.unregistered.server.configurations.label=通過未註冊的伺服器配置忽略外部連接
PhpDebugConfigurable.xdebug.resolve.breakpoints=如果斷點在當前行不可用，則解析斷點(Xdebug 2.8+)
PhpDebugConfigurable.xdebug.force.break.no.path.mapping=未指定路徑映射時，在第一行強制中斷
PhpDebugConfigurable.xdebug.force.break.when.outside.project=當腳本在專案外部時，在第一行強制中斷
PhpDebugConfigurable.xdebug.debug.port=Xdebug 調試連接埠
PhpDebugConfigurable.zend.debug.port=Zend Debugger 調試連接埠
PhpDebugConfigurable.zend.settings.broadcasting.port=Zend Debugger 設定廣播連接埠
PhpDebugConfigurable.zend.settings.ide.hosts=Zend Debugger IDE 主機
PhpDebugConfigurable.zend.settings.ide.hosts.detect=正在檢測…
PhpDebugConfigurable.zend.settings.ide.hosts.detect.progress=正在檢測 Zend Debugger 的 IP…
PhpDebugConfigurable.xdebug=Xdebug
PhpDebugConfigurable.zend.debugger=Zend 調試器
PhpDebugConfigurable.safe.evaluation.mode=值提示和監視框架下的安全評估模式
PhpDebugConfigurable.import.use.statements=從評估上下文匯入命名空間和 'use' 語句
PhpDebugConfigurable.show.array.children.in.repl=在調試控制台中顯示陣列和物件子級
PhpDebugConfigurable.external.connections=外部連接
PhpDebugConfigurable.pass.required.configuration.options=通過命令行傳遞所需配置選項(仍需要手動啟用調試擴展)
PhpDebugConfigurable.advanced.settings=高級設定
PhpDebugConfigurable.notify.session.stopped.without.pause=在調試會話完成而不暫停時通知
PhpDebugConfigurable.notify.resolved.breakpoint=通知是否將斷點解析為另一行(Xdebug 2.8+)
PhpDebugConfigurable.detect.path.mappings.from.deployment=檢測部署配置的路徑映射
PhpDebugConfigurable.break.at.first.line=在 PHP 腳本中的第一行中斷
PhpDebugConfigurable.evaluation=評估
PhpDebugConfigurable.zero.configuration=預配置
PhpDebugConfigurable.zero.configuration.install.debugger.php.instruction=1. 安裝
PhpDebugConfigurable.zero.configuration.install.xdebug.php.instruction=Xdebug
PhpDebugConfigurable.zero.configuration.install.php.instruction=或
PhpDebugConfigurable.zero.configuration.install.zend.debugger.php.action=Zend 調試器
PhpDebugConfigurable.zero.configuration.install.zend.debugger.php.instruction=在 Web 伺服器上。
PhpDebugConfigurable.zero.configuration.install.php.validate.action=驗證
PhpDebugConfigurable.zero.configuration.install.php.validate=Web 伺服器上的調試器配置。
PhpDebugConfigurable.zero.configuration.install.toolbar.instruction.label=2. 安裝
PhpDebugConfigurable.zero.configuration.install.toolbar.instruction=瀏覽器工具欄或小書籤。
PhpDebugConfigurable.zero.configuration.listen.for.connections=3. 啟用 PHP 調試連接偵聽:
PhpDebugConfigurable.zero.configuration.start.session=4. 使用工具欄或小書籤在瀏覽器中啟動調試會話。
PhpDebugConfigurable.zero.configuration.tutorial=有關更多資訊，請參見
PhpDebugConfigurable.zero.configuration.tutorial.action=“零配置調試”教程

PhpDebugConfigurable.zero.configuration.listen.for.connections.action=開始偵聽
PhpDebugConfigurable.zero.configuration.stop.listen.for.connections.action=停止偵聽
PhpDebugConfigurable.remote.debug.listen.for.connections=3. 啟動“PHP 遠端調試”執行配置。
PhpDebugConfigurable.web.page.pre.config.title=調試預配置
PhpDebugConfigurable.web.page.listen.for.connections=2. 啟動“PHP Web 頁面”執行配置。

PhpDebugSkippedPathsConfigurable.display.name=跳過的路徑
PhpDebugSkippedPathsConfigurable.notify.about.skipped.files=通知跳過的檔案
PhpDebugSkippedPathsConfigurable.column.title=跳過的路徑

PhpFrameworksCommonConfigurable.display.name=框架

PhpStepFiltersConfigurable.title.methods=方法
PhpStepFiltersConfigurable.specify.method.name=指定方法名稱
PhpStepFiltersConfigurable.add.method=添加方法
PhpStepFiltersConfigurable.skip.magic.methods=跳過魔術方法
PhpStepFiltersConfigurable.skip.constructors=跳過構造函數
PhpStepFiltersConfigurable.skipped.methods=跳過的方法
PhpStepFiltersConfigurable.title.files=檔案
PhpStepFiltersConfigurable.skipped.files=跳過的檔案
PhpStepFilters.log.frame=框架已被跳過。函數名稱: {0}。遠端檔案 URL: {1}

PhpServerConfigurable.shared=共享(&S)
PhpServerConfigurable.host=主機
PhpServerConfigurable.host.label=主機(&H):
PhpServerConfigurable.port=連接埠
PhpServerConfigurable.port.label=連接埠(&P)
PhpServerConfigurable.debugger.label=調試器(&D)

# web server validation for debug
php.web.server.validation.title=驗證 Web 伺服器上的調試器配置
php.web.server.validation.action.text=Web 伺服器調試驗證
php.web.server.validation.local.web.server.radio=本地 Web 伺服器或共享資料夾(&L)
php.web.server.validation.remote.web.server.radio=遠端 Web 伺服器(&R)
php.web.server.validation.local.path.to.script=創建驗證腳本的路徑(&P):
php.web.server.validation.local.path.to.script.tooltip=所選路徑應可通過 Web 伺服器存取
php.web.server.validation.url.to.validation.script=驗證腳本的 URL(&U):
php.web.server.validation.url.to.validation.script.tooltip=所選 Web 路徑將用於執行驗證腳本
php.web.server.validation.deployment.server=部署伺服器(&D):
php.web.server.validation.deployment.server.tooltip=所選伺服器會用於將驗證腳本部署到遠端伺服器
php.web.server.validation.process.title=驗證 Web 伺服器
php.web.server.validation.dialog.validate.button=驗證(&V)
php.web.server.validation.chose.path.to.script=選擇驗證腳本的路徑
php.web.server.validation.chose.path.to.script.description=選擇本地資料夾以創建驗證腳本
php.web.server.validation.invalid.path.to.script=驗證目錄的路徑無效
php.web.server.validation.configure.local=請配置驗證腳本的本地和 Web 路徑
php.web.server.validation.configure.remote=請配置驗證腳本的路徑並選擇部署伺服器
php.web.server.validation.failed.to.find.web.path=請配置驗證腳本的 Web 路徑
php.web.server.validation.failed.to.find.deployment.settings=無法找到伺服器的部署設定
php.web.server.validation.failed.to.map.deployment.folder=請為驗證目錄配置遠端路徑映射
php.web.server.validation.failed.to.map.deployment.folder.to.web=請為驗證目錄配置 Web 路徑映射
php.web.server.validation.uploading.validation.script=正在將驗證腳本上傳至 {0}
php.web.server.validation.failed.to.deploy.validation.script=無法將驗證腳本部署到伺服器
php.web.server.validation.failed.to.fetch.script.result=無法提取驗證腳本的結果
php.web.server.validation.script.result.is.empty=驗證腳本的結果為空
php.web.server.validation.script.result.wrong.format=驗證腳本的結果具有意外格式
php.web.server.validation.script.local.result.path.mapping.check=請檢查是否為 <b>''{0}''</b> 目錄正確配置了驗證腳本的 Web 路徑
php.web.server.validation.script.result.path.mapping.check=請檢查是否在部署設定中為 <b>''{0}''</b> 目錄正確配置了遠端和 Web 路徑映射
php.web.server.validation.failed.to.execute.script=指定的 URL 不可到達，原因是: ''{0}''
php.web.server.validation.configuration.files=<b>已載入的 php.ini:</b> {0}
php.web.server.validation.additional.configuration.files=<b>已解析的其他 .ini 檔案:</b> {0}
php.web.server.validation.no.configuration.files=找不到 php.ini 檔案
php.web.server.validation.server.name=<b>伺服器名稱:</b> {0}
php.web.server.validation.server.name.is.empty=伺服器名稱為空
php.web.server.validation.server.name.is.empty.description=伺服器名稱對於 PhpStorm 中的標識是必要的。<br>請在 Web 伺服器配置檔案中進行配置。
php.web.server.validation.no.debugger.extension=未載入調試擴展
php.web.server.validation.multi.debugger.extension=Xdebug 和 Zend Debugger 擴展均已載入
php.web.server.validation.multi.debugger.extension.description=只有一個調試器擴展可在 php.ini 中載入。
php.web.server.validation.loaded.debugger.extension=<b>調試器擴展:</b> {0}
php.web.server.validation.xdebug.debugger.host=<b>遠端主機:</b> {0}
php.web.server.validation.xdebug.debugger.localhost=儘管伺服器主機可能不在本地，但遠端主機仍配置為 ''{0}''
php.web.server.validation.xdebug.debugger.host.remote.addr=<br/><br/>在 php.ini 檔案中，將 <b>''{0}''</b> 設為 <i>''{1}''</i> 或自 Web 伺服器可見的本地機器 IP 地址。
php.web.server.validation.xdebug.debugger.host.description=正在執行調試器<b>客戶端</b>的主機。
php.web.server.validation.xdebug.zend.extension.load=Xdebug 必須通過 'zend_extension' 而不是 'extension' 載入
php.web.server.validation.xdebug.zend.extension.load.description=在 php.ini 檔案中使用 <b>'zend_extension=path_to_xdebug.so'</b> 行以載入 Xdebug 擴展。
php.web.server.validation.xdebug.port=<b>遠端連接埠:</b> {0}
php.web.server.validation.xdebug.port.require.sudo=<b>遠端連接埠:</b> {0}，需要根權限才能使用
php.web.server.validation.xdebug.port.require.sudo.description=要在 Linux 和 Mac 上使用小於 1024 的連接埠，必須具有根權限。
php.web.server.validation.xdebug.wrong.port.format=<b>Xdebug 連接埠無效:</b> ''{0}''
php.web.server.validation.xdebug.wrong.port=Xdebug 連接埠(''{0}'')與“PHP->調試 IDE”設定(''{1}'')不同
php.web.server.validation.xdebug.wrong.port.description=來自 php.ini (<b>{0}</b>)的 Xdebug 連接埠應與在 IDE 內(在 <b>PHP->調試</b>下)配置的連接埠相同。
php.web.server.validation.xdebug.remote.is.not.enable=遠端調試未啟用
php.web.server.validation.xdebug.remote.is.not.enable.description=將 <b>''{0}''</b> 行添加到 php.ini 檔案。
php.web.server.validation.xdebug3.option.in.invalid.mode=''{0}'' 選項設定為 ''{1}''，這對於 xdebug3 是無效模式。
php.web.server.validation.xdebug.remote.autostart.description=調試會話將嘗試為每個請求啟動。
php.web.server.validation.xdebug3.start.with.request.description=調試會話將嘗試根據相應配置自動啟動。
php.web.server.validation.xdebug3.option.is.enabled.message=<b>{0}:</b> 選項設定為 ''{1}''。
php.web.server.validation.xdebug.option.is.not.enabled.description=<b>{0}:</b> 選項未啟用
php.web.server.validation.xdebug3.start.upon.error.description=調試會話將嘗試根據相應配置在錯誤時自動啟動。
php.web.server.validation.xdebug.option.is.enabled=<b>{0}:</b> 選項已啟用
php.web.server.validation.xdebug3.discover.client.with.discover.header=根據 <b>$_SERVER[''{0}'']</b> 中的值，Xdebug 將嘗試自動連接到客戶端。若失敗，則以空的 <b>''xdebug.client_discovery_header''</b> 回到 <b>''xdebug.discover_client_host''</b>。
php.web.server.validation.xdebug3.discover.client=根據 <b>$_SERVER['HTTP_X_FORWARDED_FOR']</b> 和 <b>$_SERVER['REMOTE_ADDR']</b> 中的值，Xdebug 將嘗試自動連接到客戶端。若失敗，則回到 <b>'xdebug.client_host'</b>。
php.web.server.validation.xdebug3.discover.client.message=<b>發現客戶端主機:</b> xdebug 將嘗試自動提取客戶端主機。
php.web.server.validation.xdebug.option.is.ignored.description=<b>{0}:</b> 選項將被忽略。
php.web.server.validation.xdebug.remote.mode.jit=<b>遠端模式:</b> 'jit'
php.web.server.validation.xdebug.remote.mode.jit.description=調試會話將僅在出現錯誤後初始化。
php.web.server.validation.xdebug.remote.mode.req=<b>遠端模式:</b> 'req'
php.web.server.validation.xdebug.remote.mode.req.description=調試會話將在腳本啟動時初始化。
php.web.server.validation.xdebug3.remote.mode.emulation.description=調試會話將在腳本啟動時初始化，與 xdebug2 的 <b>remote_mode=''{0}''</b> 相同。
php.web.server.validation.xdebug3.remote.mode.emulation.message=<b>遠端模式:</b> xdebug2 的 ''{0}'' 已模擬。 
php.web.server.validation.xdebug3.cloud.xdebug.doesnt.accept.connections.message=Xdebug 現在不接受外部連接
php.web.server.validation.xdebug3.cloud.xdebug.wrong.cloud.id.message=<b>IDE 中的云 ID:</b> 與伺服器上的云 ID 不同
php.web.server.validation.xdebug3.cloud.xdebug.wrong.cloud.id.description=<b>IDE 中的云 ID:</b> {0}<br><b>伺服器上的云 ID:</b> {1}
php.web.server.validation.xdebug3.cloud.xdebug.disabled.message=<b>通過 Xdebug Cloud 連接:</b> 已禁用。請在 IDE 設定中進行啟用: <b>PHP->調試->XDebug Cloud</b>
php.web.server.validation.xdebug3.cloud.php.ini.xdebug.disabled.message=<b>Php.ini 云調試:</b> 已禁用。
php.web.server.validation.xdebug3.cloud.xdebug.correct.cloud.id.message=<b>IDE 中的云 ID:</b> 與伺服器上的云 ID 相同
php.web.server.validation.xdebug.mode.is.not.supported=不支持遠端模式 ''{0}''
php.web.server.validation.xdebug.remote.log=<b>{0}:</b> {1}
php.web.server.validation.xdebug.protocol.is.not.supported=不支持調試協議 ''{0}''
php.web.server.validation.zend.debugger.host=<b>遠端主機:</b> {0}
php.web.server.validation.zend.debugger.localhost=儘管伺服器不在本地，但調試會話僅適用於本地主機。
php.web.server.validation.zend.debugger.localhost.description=將正在執行調試器<b>客戶端</b>的主機添加至 <b>'zend_debugger.allow_hosts'</b> 選項。
php.web.server.validation.zend.debugger.deny.host=<b>拒絕主機:</b> {0}
php.web.server.validation.zend.debugger.deny.host.description=無法使用拒絕主機從客戶端進行調試。
php.web.server.validation.zend.expose.remotely=<b>屬性 ''expose_remotely''</b> 設為 ''{0}''
php.web.server.validation.zend.expose.remotely.allowed.hosts.description=調試器會話將嘗試從 <b>'zend_debugger.allow_hosts'</b> 選項為主機啟動。
php.web.server.validation.zend.expose.remotely.always.description=調試器會話將嘗試為每個客戶端啟動。
php.web.server.validation.zend.expose.remotely.never.description=調試器會話將不會進行初始化，<b>'zend_debugger.allow_hosts'</b> 選項將被忽略。<br>將選項 <b>'zend_debugger.expose_remotely'</b> 設定為 'allowed_hosts' 或 'always' 以啟用 Web 伺服器調試。
php.web.server.validation.reference.to.documentation=請參閱<a href=\\"{0}\\">{0}</a>獲取更多資訊。

PhpPathMappingsConfigurable.use.path.mappings.label=使用路徑映射(選擇伺服器是遠端伺服器還是使用符號鏈接)

PhpMappingSimpleResolveDialog.title=為伺服器上的檔案路徑選擇本地檔案

DBGPProxyConfigurable.display.name=DBGp 代理
DBGPProxyConfigurable.ide.key=IDE 鍵:
DBGPProxyConfigurable.host=主機:
DBGPProxyConfigurable.port=連接埠:

xdebug.initializing.debugger.connection=正在連接到 {0}…
xdebug.initializing.connection.failed.with.timeout=無法連接到 {0}: 超時
xdebug.initializing.connection.debugger=調試器
xdebug.initializing.connection.xdebug.cloud=Xdebug Cloud

XdebugCloudConfigurable.display.name=Xdebug Cloud
XdebugCloudConfigurable.connect.via.xdebug.cloud=連接到 Xdebug Cloud
XdebugCloudConfigurable.cloud.id=Cloud ID:
XdebugCloudConfigurable.custom.server=連接到預置 Xdebug Cloud
XdebugCloudConfigurable.base.host=Cloud 主機:
XdebugCloudConfigurable.port=Cloud 連接埠:

xdebug.cloud.validation.cloud.id.not.defined=Cloud ID 未定義
xdebug.cloud.validation.host.not.defined=未定義預置 Xdebug Cloud 主機
xdebug.cloud.validation.port.invalid=預置 Xdebug Cloud 連接埠無效

xdebug.cloud.cannot.connect=無法連接到 Xdebug Cloud
xdebug.cloud.cannot.connect.unknown.host=Xdebug Cloud 無法存取: {0}
xdebug.cloud.cannot.register.cloud.id=無法在 Xdebug Cloud 上註冊 Cloud ID
xdebug.cloud.cannot.register.cloud.id.unexpected.response=由於意外響應，無法註冊 Cloud ID
xdebug.cloud.cannot.open.new.debug.connection=打不開新的調試連接

PhpIncomingLocalConnectionDialog.file.path=檔案路徑:

PhpIncomingConnectionDialog.server.name=伺服器名稱:
PhpIncomingConnectionDialog.server.port=伺服器連接埠:
PhpIncomingConnectionDialog.request.uri=請求 URI:
PhpIncomingConnectionDialog.file.path.on.server=伺服器上的檔案路徑:

PhpInterpreter.php.sdk.type=PHP 解釋器
PhpInterpreter.php.dependent.configuration.exists.title=PHP 解釋器依賴配置
PhpInterpreter.php.dependent.configuration.exists=所選 PHP 解釋器有{0}配置。確定要刪除此解釋器嗎?
PhpInterpreter.php.home.path.label=PHP 可執行檔案:
PhpInterpreter.php.debugger.label=調試器:
PhpInterpreter.php.general.title=常規
PhpInterpreter.configuration.in.project.settings.title=PHP 解釋器配置
PhpInterpreter.configuration.in.project.settings.message=無法將 PHP 解釋器指定為預設 SDK。您可以在“設定| PHP”中為當前專案配置
PhpInterpreter.configuration.duplicate.interpreter.name=找到了具有非唯一名稱 ''{0}'' 的 PHP 解釋器。
PhpInterpreter.configuration.selection.list.title=選擇 CLI 解釋器
PhpInterpreter.configuration.interpreter.is.invalid=啟用“PHP Remote Interpreters”套件以編輯解釋器。
PhpInterpreterConfigurable.configuration.title=其他
PhpInterpreterConfigurable.reload.phpinfo=重新載入 phpinfo
PhpInterpreterConfigurable.show.phpinfo=顯示 phpinfo
PhpInterpreterConfigurable.updated.phpinfo=已成功更新 phpinfo
PhpInterpreterConfigurable.can.not.updated.phpinfo=無法更新 phpinfo
PhpInterpreterConfigurable.php.version=PHP 版本: {0}
PhpInterpreterConfigurable.not.installed=未安裝
PhpInterpreterConfigurable.configuration.project.level=僅對此專案可見
PhpInterpreterConfigurable.configuration.project.tooltip=檢查是否不想在專案之間共享解釋器
PhpInterpreterConfigurable.configuration.default.project.tooltip=無法僅為預設專案儲存解釋器。
PhpInterpreterConfigurable.debugger.extension.label=調試器擴展:
PhpInterpreterConfigurable.debugger.extension.title=選擇調試器擴展路徑
PhpInterpreterConfigurable.debugger.extension.description=將僅為從 CLI 執行配置啟動的調試會話載入調試器擴展
PhpInterpreterConfigurable.configuration.options.table.empty.text=為 php.ini 中允許的任何配置指令設定自訂值
PhpInterpreterConfigurable.configuration.options.with.empty.name.are.not.allowed=不允許名稱為空的配置選項
PhpInterpreterConfigurable.configuration.options.dialog.caption=配置選項
PhpInterpreterConfigurable.configuration.options.label=配置選項:
PhpInterpreterConfigurable.configuration.options.table.name=配置指令
PhpInterpreterConfigurable.configuration.options.table.value=值
PhpInterpreterConfigurable.configuration.options.description=這些選項將使用 '-d' 命令行選項傳遞
PhpInterpreterConfigurable.configuration.file.path=配置檔案: {0}
PhpInterpreterConfigurable.configuration.file.path.not.found=配置 php.ini 檔案不存在
PhpInterpreterConfigurable.configuration.file.evaluate.dir=正在評估配置檔案目錄…
PhpInterpreterConfigurable.configuration.file.fix.title=配置 php.ini 檔案不存在
PhpInterpreterConfigurable.configuration.file.hhvm.fix=在 <b>/etc/hhvm</b> 目錄中創建 php.ini 檔案，<br><br>點擊此<a href=\\"http://docs.hhvm.com/manual/en/configuration.file.php\\">>鏈接</a>獲取更多資訊。
PhpInterpreterConfigurable.configuration.file.fix=在 {0} 目錄中創建 php.ini 檔案，<br><br>配置檔案模板可在 php 根資料夾中找到:<br>“php.ini-development”- 預設設定<br>“php.ini-production”- 推薦設定。<br>
PhpInterpreterConfigurable.configuration.file.fix.failed.to.detect=使用“{0} --ini”命令確定配置檔案目錄。<br>
PhpInterpreterConfigurable.configuration.file.fix.link=<br>點擊此<a href=\\"http://php.net/manual/en/configuration.file.php\\">鏈接</a>獲取更多資訊。
PhpInterpreterConfigurable.configuration.file.can.not.find.title=無法找到配置檔案
PhpInterpreterConfigurable.configuration.file.can.not.find=無法通過路徑找到檔案: ''{0}''
php.info.parse.exception=無法解析 php 資訊: {0} 是空的
PhpInterpreterConfigurable.update.helpers.title=正在更新幫助程序目錄…
PhpInterpreter.php.interpreter.name.conflict.title=解釋器名稱衝突
PhpInterpreter.php.interpreter.name.conflict=發現專案級和套用程序級解釋程序名稱存在衝突。為解決該問題，以下專案級解釋器被重命名:
remote.interpreter.browse.action.is.not.supported.for.docker=基於 Docker 的遠端解釋器不支持瀏覽操作
php.interpreter.info.failed.to.parse.validation.script=無法解析驗證腳本輸出

php.interpreter.base.configuration.interpreter.is.invalid=無法執行 {0}，因為 {1} 配置的解釋器無效。
php.interpreter.base.configuration.is.not.provided.or.empty={1} 的 {0} 路徑未配置。您可以在“PHP|{0}”下進行修復
php.interpreter.base.configuration.working.directory=無法檢測工作目錄，請在執行配置中進行配置。
php.interpreter.base.configuration.fix.interpreter={0}。要修復，請<a href=''{1}''>更改</a>專案解釋器或<a href=''{2}''>檢查</a>設定。

PhpProjectConfigurable.language.level=PHP 語言級別:
PhpProjectConfigurable.interpreter=CLI 解釋器:
PhpProjectConfigurable.include.path=Include 路徑
PhpProjectConfigurable.0.interpreter.include.path=''{0}'' 解釋器 include 路徑
PhpProjectConfigurable.specify.other=指定其他…
PhpProjectConfigurable.all=所有
PhpProjectConfigurable.provide.include.path=提供 include 路徑
PhpProjectConfigurable.docker.default.project.error.tooltip=打開或創建專案以配置 Docker 容器
PhpProjectConfigurable.php.runtime=PHP 執行時
PhpProjectConfigurable.advanced.settings=高級設定(&V)
PhpProjectConfigurable.default.stubs.path=預設存根路徑(&D):
PhpProjectConfigurable.select.default.stubs.path.title=選擇預設存根路徑
PhpProjectConfigurable.select.default.stubs.path.description=選擇預設存根路徑
PhpProjectConfigurable.analysis=分析
PhpProjectConfigurable.exception.analysis=異常分析
PhpProjectConfigurable.exception.analysis.depth=調用樹分析路徑:
PhpProjectConfigurable.exception.analysis.unchecked.exceptions=未檢查的異常
PhpProjectConfigurable.analysis.custom.format.functions=自訂格式函數
PhpProjectConfigurable.include.analysis=Include 分析
PhpProjectConfigurable.select.document.root.path.title=選擇 $_SERVER['DOCUMENT_ROOT'] 路徑
PhpProjectConfigurable.select.document.root.path.description=選擇 $_SERVER['DOCUMENT_ROOT'] 路徑

custom.format.functions.dialog.validation.class.not.found=找不到類 {0}
custom.format.functions.dialog.validation.function.not.found=找不到函數 {0}
custom.format.functions.dialog.validation.method.not.found=在 {1} 中找不到方法 {0}
custom.format.functions.dialog.validation.format.index=索引必須為非負數
custom.format.functions.dialog.format.index.title=格式字串模板的索引
custom.format.functions.dialog.class.placeholder=留空以添加純函數

PhpUnitConfigurableForm.phpunit.library=PHPUnit 庫
PhpUnitConfigurableForm.use.custom.loader=使用 Composer 自動載入器
PhpUnitConfigurableForm.custom.loader.is.empty=自動載入器檔案的路徑為空
PhpUnitConfigurableForm.can.not.find.custom.loader=在 ''{0}'' 下找不到自動載入器腳本
PhpUnitConfigurableForm.phpunit.phar.is.empty=phpunit.phar 路徑為空
PhpUnitConfigurableForm.can.not.find.phpunit.phar=在 ''{0}'' 下找不到 phpunit.phar
PhpUnitConfigurableForm.custom.loader.is.directory=自動載入器不應為目錄，對於預設 Composer 配置，將路徑設定為“vendor/autoload.php”
PhpUnitConfigurableForm.download.phpunit.phar.link.text=從 {0} 下載 phpunit.phar
PhpUnitConfigurableForm.path.to.script=腳本路徑:
PhpUnitConfigurableForm.path.to.phpunit.phar=phpunit.phar 路徑
PhpUnitConfigurableForm.test.runner=測試執行程序
PhpUnitConfigurableForm.use.configuration.file=預設配置檔案:
PhpUnitConfigurableForm.use.bootstrap.file=預設啟動檔案:
PhpUnitConfigurableForm.use.configuration.file.validation.warning=為 ''{0}'' 提供配置檔案的路徑，或禁用“預設配置檔案”選項
PhpUnitConfigurableForm.use.bootstrap.file.validation.warning=為 ''{0}'' 提供啟動檔案的路徑，或禁用“預設啟動檔案”選項

phpunit.config.label=測試根
phpunit.config.directory.label=目錄:
phpunit.config.empty.pattern=空模式
phpunit.getting.phpunit.version=正在更新 PhpUnit 版本…
phpunit.not.tests.was.executed.title=未配置 PHPUnit
phpunit.not.tests.was.executed.message=要修復，為 <i>{0}</i> <a href=\\"config\\">配置</a>自動載入檔案或 PHPUnit phar 路徑。
phpunit.can.not.rerun.failed.tests.title=無法執行失敗的 PHPUnit 測試。
frameworks.settings.none.installed=<html>沒有可用的框架設定提供程序。<br/>考慮安裝 Drupal Support、Joomla! Support 或 WordPress Support 套件。</html>
framework.composer.packages.were.changed.0.test.config.title=Composer 軟體套件已被更改
framework.composer.packages.were.changed.0.test.config.popup={0} 配置已根據 composer.json 更新

PhpUnitConfiguration.interpreter.conflict=發現應用程式級 PHPUnit 配置衝突。為解決該問題，創建了以下配置的專案級副本:
PhpUnitConfiguration.interpreter.conflict.title=PHPUnit 配置衝突

# php test framework
php.test.framework.select.type.of.settings.popup.title=選擇配置類型
php.test.framework.configuration.ui.library={0} 庫
php.test.framework.configuration.ui.test.runner=測試執行程序
php.test.framework.configuration.ui.path.to.exe={0} 可執行檔案路徑:
php.test.framework.configuration.ui.use.configuration.file=預設配置檔案:
php.test.framework.download.hyperlink={0} 版本: <a href={1}>{1}</a>
php.test.framework.configuration.ui.version={0} 版本: {1}
php.test.framework.configuration.ui.not.installed=未安裝
php.test.framework.configuration.ui.select.interpreter=請選擇 PHP 解釋器以載入 {0} 版本
php.test.framework.configuration.ui.select.local.interpreter=請選擇本地 PHP 解釋器以載入 {0} 版本
php.test.framework.configuration.updated.version=已成功更新 {0} 版本
php.test.framework.configuration.can.not.update=無法更新 {0} 版本
php.test.framework.default.interpreter.is.not.local=無法檢測到 {0} 版本。預設 PHP 解釋器不是本地解釋器

php.test.framework.version.getting.version.title=正在獲取 {0} 版本…
php.test.framework.version.path.to.exe.is.invalid={0} 可執行檔案的路徑為空或無效。
php.test.framework.version.detector.empty.output=''{0}'' 命令輸出為空。
php.test.framework.version.configuration.ui.can.not.parse.version=無法解析版本命令輸出。\\\\n\\\\
{0}

php.test.framework.by.sdk.new.settings.dialog.title=通過遠端解釋器{0}
php.test.framework.by.sdk.dialog.label=解釋器(&I):
php.test.framework.by.sdk.settings.select.server=選擇遠端解釋器以配置遠端{0}
php.test.framework.by.sdk.settings.already.exist=所選解釋器的 {0} 設定已存在
php.test.framework.by.sdk.settings.remote.path.title=選擇伺服器上的路徑

php.test.framework.run.configuration.ui.scope=測試範圍:
php.test.framework.run.configuration.ui.type.radio.button=類型(&T)
php.test.framework.run.configuration.ui.directory.radio.button=目錄 (&D)
php.test.framework.run.configuration.ui.file.radio.button=檔案(&F)
php.test.framework.run.configuration.ui.scenario.radio.button=方法(&M)
php.test.framework.run.configuration.ui.configuration.radio.button=在配置檔案中定義(&C)
php.test.framework.run.configuration.ui.type.combo.box=類型:
php.test.framework.run.configuration.ui.directory.text.field=目錄:
php.test.framework.run.configuration.ui.file.text.field=檔案:
php.test.framework.run.configuration.ui.scenario.text.field=方法:
php.test.framework.run.configuration.ui.alternative.configuration.file=使用替代配置檔案(&U):
php.test.framework.run.confuguration.ui.dialog.caption.test.runner.options=測試執行程序選項
php.test.framework.field.test.runner.options=測試執行程序選項(&O):
php.test.framework.run.configuration.ui.custom.file.radio.button=在 {0} 中定義
php.test.framework.run.configuration.ui.alternative.custom.file=使用替代 {0}(&U)
php.test.framework.settings.is.not.provided.or.empty={1} 的 {0} 路徑未配置。按“修復”以編輯您的 {0} 配置。

php.test.framework.interpreter.conflict=發現應用程式級 {0} 配置衝突。為解決該問題，創建了以下配置的專案級副本:
php.test.framework.interpreter.conflict.title={0} 配置衝突
php.test.framework.project.level=(當前專案)
php.test.framework.no.configuration.types.are.available=沒有可用的其他配置類型

# validation
php.test.framework.validation.run.configuration.no.type=如果未選擇類型則無法執行測試。
php.test.framework.validation.run.configuration.unsupported.type=無法通過 ''{0}'' 命令執行測試。
php.test.framework.validation.run.configuration.working.directory=目錄應該是工作目錄的子資料夾: ''{0}''
php.test.framework.validation.run.configuration.file.working.directory=檔案應該是工作目錄的子項: ''{0}''
php.test.framework.validation.run.configuration.method=在 ''{1}'' 中找不到 ''{0}''

php.executable.macro.description=專案設定中配置的 Php 可執行檔案
inspection.undefined.class.ignore.phpdoc=忽略 PHPDoc

inspection.missing.ext.composer.json=composer.json 中缺少 ''{0}''
inspection.ext.is.specified.in.require.dev.but.used.outside.tests=''{0}'' 在 ''require-dev'' 部分中指定，但在測試外部使用
inspection.ext.is.specified.in.suggest=''{0}'' 在 ''suggest'' 中指定，可能不可用
inspection.missing.ext.require.bundled=需要 PHP 捆綁的擴展
add.to.composer.json.quick.fix=向 composer.json 中添加 ''{0}''

configure.php.include.paths=配置 PHP Include 路徑(&O)…

interpreter=解釋器

XdebugShowUserDefinedConstantsToggleAction.text=顯示使用者定義的常數
XdebugShowUserDefinedConstantsToggleAction.description=將其禁用會停止獲取使用者定義的常數資訊並提高調試器性能
XdebugAddMethodToSkipListToggleAction.text=將方法添加到跳過列表
PhpDebugHideEmptySuperGlobalsToggleAction.text=顯示空的超全域變數
PhpDebugBreakAtFirstLineToggleAction.text=在 PHP 腳本中的第一行中斷
PhpUserDefinedConstantsGroup.name=常數

PhpLanguageLevel.5.3.0.presentable.name=5.3
PhpLanguageLevel.5.3.0.short.description=命名空間，閉包
PhpLanguageLevel.5.4.0.presentable.name=5.4
PhpLanguageLevel.5.4.0.short.description=特徵，短陣列語法
PhpLanguageLevel.5.5.0.presentable.name=5.5
PhpLanguageLevel.5.5.0.short.description=finally，生成器
PhpLanguageLevel.5.6.0.presentable.name=5.6
PhpLanguageLevel.5.6.0.short.description=可變函數，實參解包
PhpLanguageLevel.7.0.0.presentable.name=7.0
PhpLanguageLevel.7.0.0.short.description=返回類型，標量類型提示
PhpLanguageLevel.7.1.0.presentable.name=7.1
PhpLanguageLevel.7.1.0.short.description=常數可見性，可為 null，多個異常
PhpLanguageLevel.7.2.0.presentable.name=7.2
PhpLanguageLevel.7.2.0.short.description=物件類型提示，abstract 函數覆寫
PhpLanguageLevel.7.3.0.presentable.name=7.3
PhpLanguageLevel.7.3.0.short.description=列表賦值中的引用，靈活的 heredoc
PhpLanguageLevel.7.4.0.presentable.name=7.4
PhpLanguageLevel.7.4.0.short.description=類型屬性，短閉包，null 合併運算符
PhpLanguageLevel.8.0.0.presentable.name=8.0
PhpLanguageLevel.8.0.0.short.description=聯合類型，命名實參，特性，match 表達式

PhpLanguageFeature.traits.not.supported=從 PHP 5.4 起才允許使用特徵
PhpLanguageFeature.short.array.syntax.not.supported=從 PHP 5.4 起才允許使用短陣列語法
PhpLanguageFeature.array.dereferencing.not.supported=從 PHP 5.4 起才允許對調用進行陣列解引用
PhpLanguageFeature.class.member.access.on.instantiation.not.supported=從 PHP 5.4 起才允許對實例化進行類成員存取
PhpLanguageFeature.this.in.closure.not.supported=從 PHP 5.4 起才允許在閉包中使用 $this
PhpLanguageFeature.self.in.closure.not.supported=從 PHP 5.4 起才允許在閉包中使用 self
PhpLanguageFeature.parent.in.closure.not.supported=從 PHP 5.4 起才允許在閉包中使用 parent
PhpLanguageFeature.static.in.closure.not.supported=從 PHP 5.4 起才允許在閉包中使用 static
PhpLanguageFeature.binary.literal.not.supported=從 PHP 5.4 起才允許使用二進制文字
PhpLanguageFeature.literal.in.static.call.not.supported=從 PHP 5.4 起才允許在 static 調用中使用文字
PhpLanguageFeature.built.in.web.server=內建 Web 伺服器僅自 PHP 5.4 起可用
PhpLanguageFeature.var.break.argument.not.supported=PHP 5.4 不再支援具有非常數操作數的 'break' 運算符
PhpLanguageFeature.var.break.zero.argument.not.supported=自 PHP 5.4 起，'break' 運算符僅接受正數
PhpLanguageFeature.var.continue.not.supported=PHP 5.4 不再支援具有非常數操作數的 'continue' 運算符
PhpLanguageFeature.var.continue.zero.not.supported=自 PHP 5.4 起，'continue' 運算符僅接受正數
PhpLanguageFeature.call.time.pass.by.reference.not.supported=調用時通過引用傳遞在 PHP 5.4 中已被移除

PhpLanguageFeature.finally.not.supported=從 PHP 5.5 起才允許使用 'Finally' 子句
PhpLanguageFeature.generators.not.supported=從 PHP 5.5 起才允許使用生成器
PhpLanguageFeature.foreach.list.not.supported=從 PHP 5.5 起才允許在 foreach 中使用列表
PhpLanguageFeature.empty.any.expression.not.supported=從 PHP 5.5 起才允許在 'empty' 中使用任意表達式
PhpLanguageFeature.immediate.dereferencing.not.supported=從 PHP 5.5 起才允許直接解引用
PhpLanguageFeature.class.name.const.not.supported=從 PHP 5.5 起才允許使用類名常數

PhpLanguageFeature.constant.scalar.expressions=從 PHP 5.6 起才允許使用常數標量表達式
PhpLanguageFeature.variadic.functions=從 PHP 5.6 起才允許使用可變函數
PhpLanguageFeature.argument.unpacking=從 PHP 5.6 起才允許使用實參解包
PhpLanguageFeature.exponentiation=從 PHP 5.6 起才允許使用求冪
PhpLanguageFeature.use.function.and.const=從 PHP 5.6 起才允許 use function 和 use const

PhpLanguageFeature.return.types=從 PHP 7.0 起才允許使用返回類型宣告
PhpLanguageFeature.scalar.type.hints=從 PHP 7.0 起才允許使用標量類型提示
PhpLanguageFeature.spaceship.operator=從 PHP 7.0 起才允許使用宇宙飛船運算符
PhpLanguageFeature.coalesce.operator=從 PHP 7.0 起才允許使用合並運算符
PhpLanguageFeature.grouped.use=從 PHP 7.0 起才允許分組 use 宣告
PhpLanguageFeature.keyword.names=在 PHP 7.0 中關鍵字可用作名稱
PhpLanguageFeature.uniform.variable.syntax=從 PHP 7.0 起才允許統一變數語法
PhpLanguageFeature.anonymous.classes=從 PHP 7.0 起才允許使用匿名類

PhpLanguageFeature.return.void=從 PHP 7.1 起才允許使用返回類型 'void'
PhpLanguageFeature.nullables=從 PHP 7.1 起才允許可為 null
PhpLanguageFeature.iterable.type.hint=從 PHP 7.1 起才允許迭代類型提示
PhpLanguageFeature.catch.multiple=從 PHP 7.1 起才允許捕獲多條語句
PhpLanguageFeature.class.constant.visibility=從 PHP 7.1 起才允許類常數可見性
PhpLanguageFeature.list.keys=從 PHP 7.1 起才允許列表解包中的密鑰
PhpLanguageFeature.list.assign=從 PHP 7.1 起才允許列表解包中的 []
PhpLanguageFeature.negative.numeric.indices=從 PHP 7.1 起才允許負數值索引

PhpLanguageFeature.object.type.hint=從 PHP 7.2 起才允許物件類型提示
PhpLanguageFeature.abstract.function.override=從 PHP 7.2 起才允許抽象函數覆寫

PhpLanguageFeature.literal.in.instanceof=從 PHP 7.3 起才允許將文字作為第一個操作數
PhpLanguageFeature.references.in.list=從 PHP 7.3 起才允許在 [] 和 list() 賦值中使用引用
PhpLanguageFeature.trailing.comma.in.function.calls=從 PHP 7.3 起才允許在函數調用中使用尾隨逗號
PhpLanguageFeature.trailing.comma.in.parameter.list=從 PHP 8.0 起才允許在參數列表中使用尾隨逗號
PhpLanguageFeature.trailing.comma.in.closure.use.list=只有 PHP 8.0 支援在閉包 use 列表中使用尾隨逗號
PhpLanguageFeature.flexible.heredocs=靈活的 heredoc/nowdoc 語法

PhpLanguageFeature.typed.properties=從 PHP 7.4 起才允許使用類型化屬性
PhpLanguageFeature.spread.operator.in.array=從 PHP 7.4 起才允許在陣列中使用展開運算符
PhpLanguageFeature.coalesce.assign=從 PHP 7.4 起才允許使用 '??='
PhpLanguageFeature.arrow.function=從 PHP 7.4 起才允許箭頭函數語法
PhpLanguageFeature.numeric.literals.separators=從 PHP 7.4 起才允許使用數值文字分隔符
PhpLanguageFeature.exception.throw.from.toString=從 PHP 7.4 起才允許從 ''__toString'' 拋出異常，''{0}.__toString'' 可能會拋出異常

PhpLanguageFeature.union.types=從 PHP 8.0 起才允許聯合類型
PhpLanguageFeature.namespaced.name.as.single.token=從 PHP 8.0 起才允許關鍵字作為命名空間的一部分
PhpLanguageFeature.nullsafe.dereferencing=從 PHP 8.0 起才允許 Nullsafe 運算符
PhpLanguageFeature.abstract.private.trait.methods=從 PHP 8.0 起才允許使用 abstract private 特徵方法
PhpLanguageFeature.mixed.type.hint=從 PHP 8.0 起才允許 'mixed' 類型提示
PhpLanguageFeature.static.type.hint=從 PHP 8.0 起才允許 'static' 返回類型宣告
PhpLanguageFeature.named.arguments=從 PHP 8.0 起才允許使用命名實參
PhpLanguageFeature.match.expression=從 PHP 8.0 起才允許符合表達式
PhpLanguageFeature.throw.expression=從 PHP 8.0 起才允許使用 throw 表達式
PhpLanguageFeature.non.capturing.catches=從 PHP 8.0 起才允許捕捉異常而又不將異常捕獲到變數中
PhpLanguageFeature.class.name.literal.on.object=從 PHP 8.0 起才允許在物件上使用 '::class'
PhpLanguageFeature.attributes=從 PHP 8.0 起才允許使用特性
PhpLanguageFeature.property.promotion=從 PHP 8.0 起才允許構造函數屬性提升

#Empty project generation
php.empty.project.generator.name=PHP 空專案
php.empty.project.generator.description=為 PHP 創建空專案

#UML
error.cant.create.edge=無法創建關係鏈接
relationship.already.exists={0}和{1}之間的關係已存在
this.will.remove.relationship.link.between.classes=這將移除類之間的關係鏈接並修改類 {0}。繼續？
remove.relationship.link=移除關係鏈接
final.class.cant.be.inherited=類 {0} 為 final
node.is.interface=接口只能繼承一個接口
inspection.undefined.member.downgrade=如果類中存在 __magic 方法則降級嚴重性(&D)

#Phar
phar.include.into.project.action.title=將 phar 包含到專案中
phar.exclude.from.project.action.title=從專案中排除 phar
phar.exclude.or.include.into.project.action.title=在專案中包含或排除 Phar
phar.failed.to.parse=無法解析
filetype.phar.description=Php Phar
filetype.phar.display.name=Php Phar

#Composer

framework.composer.name.composer=Composer
framework.composer.path.dialog.path.to.composer=Composer 路徑
framework.composer.path.dialog.path.to.composer.json=composer.json 路徑
framework.composer.path.dialog.specify.composer.phar=指定 Composer phar:
framework.composer.path.dialog.specify.composer.executable=指定 Composer 可執行檔案:
framework.composer.path.dialog.specify.composer.json=指定 composer.json:
framework.composer.configurable.title=Composer
framework.composer.init.dialog.title.composer.settings=Composer 設定
framework.composer.file.0.is.not.found=找不到檔案 ''{0}''。

framework.composer.add.dependency.task.title=添加依賴項
framework.composer.add.dependency.install.button=安裝
framework.composer.add.dependency.update.button=更新
framework.composer.add.dependency.close.button=關閉(&C)
framework.composer.failed.to.0=無法{0}。
framework.composer.0.1.version.2={0} {1}，版本 {2}
framework.composer.add.dependency.show.output=顯示輸出
framework.composer.add.dependency.hide.tooltip=隱藏
framework.composer.add.dependency.successfully.installed.0.version.1=已成功安裝 {0}，版本 {1}。
framework.composer.add.dependency.running=正在執行
framework.composer.add.composer.dependency.title=管理 Composer 依賴項
frameworks.composer.could.not.get.packages.info.0=無法獲取軟體套件資訊。{0}
frameworks.composer.could.not.get.package.info=無法獲取軟體套件資訊。
framework.composer.label.version.to.install=要安裝的版本(&V):
framework.composer.empty.package.name.in.0={0} 中的軟體套件名稱為空
framework.composer.no.package.versions.in.0={0} 中沒有軟體套件版本
framework.composer.expected.name.0.versions.0.description.got.1=應為 <name> {0} <versions> {0} <description>，獲得的是 {1}
framework.composer.add.dependency.available.packages.label=可用軟體套件
framework.composer.package.default.version=<預設>
framework.composer.add.dependency.no.package.selected=未選擇軟體套件
framework.composer.add.dependency.no.such.package=packagist 上無此類軟體套件
framework.composer.path.form.execution.validation.wrapper=<html>執行未設定。<br/>{0}</html>
framework.composer.path.form.empty.path.to.composer.phar=composer.phar 路徑為空
framework.composer.path.form.empty.path.to.composer.executable=Composer 可執行檔案路徑為空
framework.composer.project.generator.name=Composer 專案
framework.composer.project.generator.description=通過 Composer 命令創建專案。
framework.composer.failed.to.download.composer.phar=無法下載 composer-stable.phar
framework.composer.project.generator.failed.to.copy.temp.directory.0.content.to.project.root=無法將臨時目錄 ''{0}'' 內容複製到專案根
framework.composer.project.generation.error.title=無法創建 Composer 專案
framework.composer.project.generator.notification.content.failed.to.find=無法找到 {0}
framework.composer.project.generator.notification.content.failed.to.find.composer.json=無法在專案根中找到 composer.json
framework.composer=Composer
framework.composer.create.project.progress.title=創建專案
framework.composer.create.project.from=自以下創建專案
framework.composer.install.action.name=安裝
framework.composer.path.validation.0.is.a.directory={0} 是目錄
framework.composer.path.form.empty.path.to.composer.json=composer.json 路徑為空
framework.composer.vendors.library.name=Composer 供應商
framework.composer.selected.file.is.not.composer.json=所選檔案不是 composer.json
framework.composer.notification.title.init.composer=初始化 Composer
framework.composer.file.0.set.as.composer.config.change.setting.a.href.here.a=檔案 ''{0}'' 設定為 Composer 配置。
framework.composer.failed.to.parse.package.names=無法解析軟體套件名稱。
framework.composer.failed.to.load.package.names=無法載入軟體套件名稱。
framework.composer.failed.to.parse.package.description=無法解析軟體套件描述。
framework.composer.add.dependency.no.version.selected=未選擇版本
framework.composer.add.dependency.settings.cl.dialog.title=參數
framework.composer.add.dependency.settings.cl.label=命令行參數(&P):
framework.composer.add.dependency.settings.interpreter.label=PHP 解釋器:
framework.composer.add.dependency.settings.title=設定(&S)
framework.composer.no.description.available=無可用描述。
framework.composer.packages.were.moved.to.0.php.include.paths.popup=Composer 軟體套件已從 Composer 外部庫移至 PHP include 路徑。
framework.composer.packages.were.changed.0.excluded.folders.popup=Composer 軟體套件已更改，因此更新了排除的資料夾。
framework.composer.packages.were.changed.0.php.include.paths.popup=Composer 軟體套件已更改，因此更新了 PHP include 路徑。
framework.composer.packages.were.removed.0.excluded.folders.popup=Composer 軟體套件已從排除的資料夾中移除。
framework.composer.packages.were.removed.0.php.include.paths.popup=Composer 軟體套件已從 PHP include 路徑中移除。
framework.composer.packages.were.added.0.excluded.folders.popup=Composer 軟體套件已被添加到排除的資料夾中。
framework.composer.packages.were.added.0.php.include.paths.popup=Composer 軟體套件已被添加到 PHP include 路徑中。
framework.composer.failed.to.0.1.script.was.cancelled=無法{0} {1}。腳本已被取消。
framework.composer.add.dependency.successfully.updated.0=已成功更新 {0}。
framework.composer.add.dependency.no.new.version.found.for.0=找不到 {0} 的新版本。
framework.composer.add.dependency.successfully.removed.0=已成功移除 {0}。
framework.composer.updating.package.task.title=更新軟體套件
framework.composer.removing.package.task.title=移除軟體套件
framework.composer.update.action.name=更新
framework.composer.remove.action.name=移除
framework.composer.self.update.action.name=自我更新
framework.composer.label.installed.version=已安裝的版本:
framework.composer.path.to.php.executable.titled=PHP 可執行檔案的路徑
framework.composer.specify.php.executable.0=指定 PHP 可執行檔案 {0}
framework.composer.empty.path.to.0={0} 的路徑為空
framework.composer.default.project.interpreter=預設專案解釋器
framework.composer.default.interpreter.is.not.configured=尚未為此專案配置預設解釋器。
framework.composer.default.interpreter.for.this.project.is.remote=此專案的預設解釋器是遠端解釋器，無法使用。
framework.composer.default.composer.interpreter.name=Composer 的解釋器
framework.composer.interpreters.combo.default.interpreter=< 預設解釋器 >
framework.composer.interpreters.combo.default.project.interpreter=< 預設專案解釋器 >
framework.composer.interpreters.combo.no.default.interpreter=預設設定中沒有預設解釋器
framework.composer.interpreters.combo.no.default.interpreter.in.project=此專案中沒有預設解釋器
framework.composer.interpreters.combo.default.interpreter.no.php.path=預設解釋器未提供 PHP 路徑
framework.composer.initialize.popup=找到了 Composer 配置檔案 {0}。專案設定與其同步。
framework.composer.install.task.title=正在安裝軟體套件
framework.composer.update.task.title=更新軟體套件
framework.composer.self.update.task.title=更新 Composer
framework.composer.script.run.configuration.name=Composer 腳本
framework.composer.script.run.configuration.description=Composer 腳本執行配置
framework.composer.run.path.to.composer.json=composer.json 路徑:
framework.composer.run.script=腳本:
framework.composer.run.script.missing=未指定 Composer 腳本
framework.composer.available.version=可用版本:
framework.composer.package.version.available.0={0}的更新
framework.composer.failed.check.for.update=無法執行 'update --dry-run' 命令。
framework.composer.checking.for.update=正在檢查更新…
framework.composer.loading.packages=正在載入 Composer 軟體套件
framework.composer.loading.package.description=正在載入軟體套件描述
framework.composer.load.update.availability=檢查可用軟體套件更新
framework.composer.loading.update.availability=正在檢查 Composer 軟體套件更新

# Guzzle
guzzle.name=Guzzle
guzzle.http.request.gutter.name=Guzzle HTTP 請求
guzzle.open.http.request=在 HTTP 請求編輯器中打開
guzzle.unable.to.add.new.request.to.file=無法向 ''{0}'' 檔案添加新請求
guzzle.invalid.http.request.file=檔案 ''{0}'' 是無效的 HTTP 請求檔案
guzzle.unable.to.extract.request.parameters=無法提取請求參數
http.client.request.init.debug.connection.title=正在初始化調試連接

php.interpreter.not.configured.title=未配置 PHP 解釋器
php.interpreter.not.configured=請<a href=\\"\\">配置 PHP 解釋器</a>以使用內建 Web 伺服器
php.interpreter.is.remote.title=已配置遠端 PHP 解釋器
php.interpreter.is.remote.message=請<a href=\\"\\">選擇本地 PHP 解釋器</a>以使用內建 Web 伺服器

php.cgi.not.found.title=找不到 {0}
php.cgi.not.found=請確保<a href=\\"\\">配置的 PHP 解釋器</a>作為 CGI 程序構建(指定了 --enable-fastcgi)

php.smart.indent.codestyle.indent.in.php=縮排 PHP 標記中的程式碼

phpdoc.code.style.title=PHPDoc

phpdoc.code.style.generated.doc.blocks=生成的 PHPDoc 標記
phpdoc.code.style.sort.doc.blocks=PHPDoc 標籤順序

phpdoc.code.style.force.null.position=將 ‘null’ 置於以下類型中:
phpdoc.code.style.in.beginning.position=在開頭
phpdoc.code.style.in.end.position=在末尾

phpdoc.code.style.convert.true.false.to=將 True/False 常數轉換為:
phpdoc.code.style.convert.null.to=將 Null 常數轉換為：
php.code.style.convert.keyword.to.lowercase=將關鍵字轉換為小寫
php.code.style.convert.lower.case=小寫
php.code.style.convert.upper.case=大寫
php.code.style.sort.use.stmt=對 'use' 語句排序:
php.code.style.sort.alphabetically=按字母順序
php.code.style.sort.by.length=按長度

phpdoc.code.style.convert.else.if.to=將 else if/elseif 轉換為:
phpdoc.code.style.convert.else.if.separate=else if
phpdoc.code.style.convert.else.if.combine=elseif

phpdoc.code.style.throws.analysis.depth.performance.note.title=性能註釋
phpdoc.code.style.throws.analysis.depth.performance.note.message=不建議深入分析多個級別，因為這可能會影響 IDE 性能。要繼續嗎?

phpdoc.code.style.param.spaces.panel=PHPDoc '@param' 空間
phpdoc.code.style.param.spaces.between.tag.and.type=在標籤和類型之間：
phpdoc.code.style.param.spaces.between.type.and.name=類型和名稱之間：
phpdoc.code.style.param.spaces.between.name.and.description=在名稱和描述之間：

php.conversion.code.style.title=程式碼轉換

php.generation.code.style.title=程式碼生成

array.declaration.style=陣列/列表宣告樣式

variable.naming.style.panel=變數命名樣式
variable.naming.style.mixed=混合
variable.naming.style.camel.case=駝峰式命名法
variable.naming.style.snake.case=snake_case

php.prefdefined.codestyle.psr12.chosen.title=PSR-12 程式碼樣式
php.prefdefined.codestyle.psr12.chosen.message=您可以啟用其他 PSR-12 檢查，這些檢查當前已禁用。
php.prefdefined.codestyle.psr12.enabled.message=PSR-12 檢查已啟用。

fields.default.visibility.panel=屬性預設可見性
fields.default.visibility.private=private
fields.default.visibility.protected=protected
fields.default.visibility.public=public

getters.setters.style=Getter/Setter 樣式
getters.setters.order=Getter/Setter 順序:
getters.setters.getters.first=getter 優先
getters.setters.setters.first=setter 優先
getters.setters.naming.style=命名樣式:
getters.setters.configure=配置…

php.embedded.stubs.incorrect.path.warning.title=預設存根路徑不正確
php.embedded.stubs.incorrect.path.warning.message=配置的預設存根路徑 ''{0}'' 不存在，改為使用嵌入式存根。
php.embedded.stubs.notification.provider.notification=您正在查看不可變的嵌入式存根。為了能夠編輯這些存根，您需要克隆一個存根專案，然後通過“PHP / PHP 執行時 / 高級設定”提供預設存根路徑。
php.embedded.stubs.notification.provider.clone=在 GitHub 上克隆
php.embedded.stubs.notification.provider.provide=提供預設存根路徑
php.embedded.stubs.notification.provider.do.not.show.again=不再顯示

auto.import.in.file.scope=在檔案範圍內啟用自動匯入
auto.import.in.namespace.scope=在命名空間範圍內啟用自動匯入
auto.import.from.global.space=處理來自全域空間的符號
auto.import.from.global.space.class=類:
auto.import.from.global.space.function=函數:
auto.import.from.global.space.constant=常數:
auto.import.from.global.space.prefer.fallback=回退優先
auto.import.from.global.space.prefer.import=匯入優先
auto.import.from.global.space.prefer.fqn=FQN 優先
# non-strict
quickfix.non.strict.object.equality=非嚴格物件相等比較
inspection.non.strict.object.equality=非嚴格物件相等比較

exception.analysis.settings.path=PHP/分析
inspection.severity.with.magic=當 __magic 存在時顯示

import.references.on.paste.dialog.title=選擇要匯入的{0}
import.references.on.paste.dialog.message=<html>貼上的程式碼段使用 {0}，後者在目標範圍中不能通過匯入存取。<br/>選擇您想要匯入到範圍中的{0}。</html>
skip.constant.params=使用常數參數跳過調用
inspection.unused.declaration.option.test.entry_points=假定測試宣告為入口點
inspection.unused.declaration.option.show.unused_from_entries=顯示所有宣告
inspection.unused.declaration.option.show_strictly_unused=僅顯示未使用項
inspection.unused.declaration.option.test.suppressGettersAndSetters=禁止 getter/setter
inspection.code.patterns.panel.errors.class = 模式必須是有效的 php fqn，僅接受 '*' 作為佔位符
inspection.code.patterns.panel.errors.member = 方法模式 {0} 必須是有效的 php 關鍵字，僅接受 ''*'' 作為佔位符
inspection.code.patterns.panel.description.label = 如果 fqn 名稱符合，則將程式碼標記為入口點
inspection.code.patterns.panel.description.text = 將方法留空以表示構造函數 \\\\n\\\\
 任何 * 都將與 fqn 名稱中的一個或多個字符符合
inspection.unusedd.description.code.patterns.button.label=程式碼模式
inspection.unused.description.code.suppressed.annotations=已禁止的註解
inspection.undefined.member.warnOnMixed=出現混合、物件、stdClass、未定義類型、null 的存取成員時通知
configurable.PhpServerConfigurable.display.name=伺服器
configurable.PhpDebugConfigurable.display.name=調試
configurable.PhpProjectConfigurable.display.name=PHP
configurable.PhpSmartKeysConfigurable.display.name=PHP
configurable.QualityToolCommonConfigurable.display.name=品質工具
class.implements.solely.traversable=類 ''{0}'' 必須將接口 Traversable 作為 Iterator 或 IteratorAggregate 的一部分來實作
configurable.PhpServersConfigurable.display.name=伺服器
configurable.PhpTestFrameworksConfigurable.display.name=測試框架
configurable.PhpTemplatesCommonConfigurable.display.name=模板
PhpStepFiltersConfigurable.display.name=步進篩選器
remote.connection.settings.interpreter.is.not.remote=當前專案解釋器非遠端解釋器
remote.connection.settings.default.remote.interpreter=預設遠端解釋器
php.element.is.available.starting.with.php.version=''{0}'' 從 PHP 版本 {1} 開始可用
php.element.was.removed.in.php.version=''{0}'' 已在 PHP {1} 版本中被移除
settings.smart.keys.title=PHP
settings.smart.keys.enable.smart.function.parameters.completion=啟用智能函數參數補全
settings.smart.keys.select.variable.name.without.dollar.sign.on.double.click=雙擊時選擇不含 '$' 符號的變數名稱
settings.smart.keys.remove.php.open.close.tags.while.pasting.in.php.context=在 PHP 上下文中貼上時移除 PHP 開始/結束標記
settings.smart.keys.escape.symbols.on.paste.in.string.literals=在字串文字中貼上時轉義符號
settings.smart.keys.auto.insert.tag.after.typing=輸入 '<?' 後自動插入 '<?php' 標記
settings.smart.keys.find.usages.of.base.method.prompt=搜尋方法用法時顯示其他選項
settings.smart.keys.replace.unnecessary.double.quotes.on.paste=貼上時取代不必要的雙引號
php.exception.is.never.thrown=函數中從未拋出異常 ''{0}''
php.remove.exception.from.throws=從 @throws 標記中移除 ''{0}''
php.remove.throws.tag=從 @throws 標記移除
php.add.exception=將 ''{0}'' 添加到現有 @throws 標記
ternary.condition.can.be.replaced.with.condition.expression=表達式可以安全地取代為 ''{0}''
php.replace.with=取代為 ''{0}''
php.tag.is.deprecated={0} 已棄用，將在 PHPUnit 9 中移除
potentially.polymorphic.call.multiple.subclasses=潛在的多態調用。該程式碼可能無法操作，具體取決於作為實參傳遞的實際類實例。
trait.already.contains.method=特徵 {0} 已包含方法 {1}
potentially.polymorphic.call.single.subclass=潛在的多態調用。{0} 的層次結構中沒有成員
navigate.to.meta.declaration=導航到 ''{0}''
meta.declaration.exists=''{1}'' 存在元宣告 ''{0}''
meta.multiple.declaration.exists=''{0}'' 存在多個元宣告
meta.declaration.line.marker.name=存在元宣告
unnecessary.local.variable=不必要的局部變數
phpunit.10.won.t.support.classname.annotations=PHPUnit 10 將不支持 ClassName::<*> 註解
returned.by.iterator.aggregate.should.be.traversable=\\\\\\\\IteratorAggregate::getIterator() 返回的物件必須為 Traversable 或實作接口 Iterator
inspection.probably.undefined.property=屬性 '#ref' 已動態宣告，可能未定義
find.classes.without.member=尋找沒有成員的類
classes.without.member=層次結構中不帶 ''{0}'' 的類
remove.pass.by.ref=移除 '\\\\\\\\&'
pass.by.ref.is.not.effectively.used.inside.body=引用沒有必要，因為實參既不通過引用賦值，也不通過引用進一步傳遞
suppress.if.annotated.by.tag=如果用 ''{0}'' 註解，則禁止
configure.suppressed.annotations=配置禁止的註解
enter.annotation=輸入註解
suppressed.annotation.title=已禁止的註解
move.class.to.separate.file.text.family=將類移至單獨的檔案
type.primitive.hints.names.are.forbidden=禁止名為 'true'、'false' 和 'null' 的類型提示
primitive.hints.name.are.forbidden.in.php.7=PHP 7 中禁止名為 'int'、'string'、'float'、'bool'、'true'、'false' 和 'null' 的類
classes.named.void.and.iterable.are.forbidden.in.php.7.1=PHP 7.1 中禁止名為 'void' 和 'iterable' 的類
classes.named.object.are.forbidden.in.php.7.2=PHP 7.2 中禁止名為 'object' 的類
switch.statements.may.only.contain.one.default.clause.in.php.7=在 PHP 7 中，switch 語句只能包含一個 'default' 子句
show.composer.settings.action.name=顯示 Composer 設定
composer.change.setting.action.name=更改設定
composer.diagnose.task.title=診斷
composer.simulating.update.task.title=模擬更新
composer.generating.autoloader.task.title=生成自動載入器
composer.autoloader.generation.settings.name=自動載入器生成設定
composer.generate.list.popup.title=生成
install.composer.packages.task.title=安裝 Composer 軟體套件
composer.listing.licenses.task.title=列出許可證
composer.update.composer.task.title=更新 Composer
composer.checking.for.changes.in.code.of.dependencies.task.title=檢查依賴項程式碼中的變更
composer.update.composer.packages.task.title=更新 Composer 軟體套件
composer.validating.task.title=驗證
composer.validation.settings.name=驗證設定
composer.validate.dialog.action.button.title=驗證
composer.revert.action.name=還原
composer.clearing.cache.action.name=清除快取
composer.remove.action.name=移除(&R)
composer.checkbox.download.composer.phar.from.getcomposer.org=從 getcomposer.org 下載 composer-stable.phar
composer.label.phar=composer.phar
composer.label.executable='composer' 可執行檔案
composer.checkbox.check.if.composer.lock.is.up.to.date=檢查 composer.lock 是否為最新
composer.checkbox.autoload.classes.from.the.classmap.only=僅從類映射自動載入類
composer.label.can.be.time.consuming=可能較為耗時
composer.checkbox.disable.autoload.dev.dependencies=禁用 autoload-dev 依賴項
composer.checkbox.optimize.autoloader.convert.psr.0.4.rules.to.a.classmap=優化自動載入器(將 PSR-0/4 規則轉換為類映射)
composer.checkbox.skip.scripts.execution=跳過腳本執行
composer.checkbox.use.apcu.to.cache.found.not.found.classes=使用 APCu 快取找到/未找到的類
composer.checkbox.allow.unbound.version.constraints=允許未綁定的版本約束
composer.checkbox.check.if.the.package.is.packagist.ready=檢查軟體套件是否為 Packagist 就緒
composer.checkbox.validate.package.dependencies=驗證軟體套件依賴項
composer.checkbox.synchronize.ide.settings.with.composer.json=將 IDE 設定與 composer.json 同步(&S)
composer.label.path.to.composer.json=composer.json 路徑(&C):
composer.label.the.settings.php.language.level.directories.may.be.updated=設定(Php 語言級別，目錄)可能已更新
composer.border.title.package=軟體套件
composer.label.package=軟體套件:
composer.label.version.to.install=要安裝的版本:
composer.label.filter.packages=篩選軟體套件(&F):
composer.label.label=標籤
composer.border.title.execution=執行
php.run.label.server=伺服器:
php.run.label.https=HTTPS:
php.run.label.url=URL:
php.run.label.query.string=查詢字串:
php.run.label.request.body=請求正文:
php.run.label.request.method=請求方法:
php.run.label.send.request.body.as=將請求正文發送為:
php.run.radio.button.key.value=鍵值
php.run.http.border.title.configuration=配置
php.run.label.interpreter=解釋器:
php.run.radio.button.text=文本
replace.with.alias.from.target.scope=取代為目標範圍中的別名
php.information.dialog.title=PHP 資訊
extract.method.parameter.name.column.title=參數
constant.with.same.name.already.exists.in.0={0} 中已經存在名稱相同的常數
path.0.is.invalid=路徑 ''{0}'' 無效
rename.parameters.dialog.title=重命名參數
rename.parameter.dialog.description=將層次結構中的參數重命名為:
quality.tools.custom.coding.standard=自訂編碼標準
quality.tools.0.added.to.ignored.files.list={0}已添加到忽略的檔案列表。
exclude.0.from.1.analysis.a=從{1}分析中排除{0}。
create.new.field.dialog.title=創建新字段
uml.wrong.name=錯誤的名稱
uml.0.already.exists.in.class.1=類 {1} 中已經存在 ''{0}''
rename.filename.quick.fix=將檔案 ''{0}'' 重命名為 ''{1}''
rename.psi.element.quick.fix=將{0} ''{1}'' 重命名為 ''{2}''
fix.package.text=將命名空間 ''{0}'' 取代為 ''{1}''
fix.package.text.family=修復命名空間 
variable.always.have.value.0=到達時變數始終為 '{0,choice,0#false|1#true}'
introduce.named.constant.for.value.0=為值 ''{0}'' 引入命名常數


checkbox.add.packages.as.libraries=作為庫添加軟體套件(&A)
phpunit.label.data.set=資料集:
label.insert.imports.on.paste=貼上時插入匯入:
border.title.php=PHP
label.class.fqn=類 FQN
label.method.name=方法名稱
checkbox.move.to.another.class=移動到另一個類(&M)
label.visibility=可見性(&V)
label.initialize.in=初始化在(&I)
radio.button.const=const(&C)
radio.button.define=定義(&D)
border.title.constant.syntax=常數語法
border.title.visibility=可見性
radio.button.default=預設(&F)
radio.button.public=public(&U)
radio.button.private=private(&I)
radio.button.protected=protected(&O)
radio.button.by.concatenation=通過串聯(&C)
radio.button.by.embeding=通過嵌入(&E)
radio.button.class.constructor=類構造函數(&S)
radio.button.current.method=當前方法(&T)
radio.button.field.declaration=屬性宣告(&D)
border.title.initialize.in=初始化位置
border.title.introduce.field=引入屬性
radio.button.setup=設定(&U)
border.title.introduce.variable=引入變數
label.name=名稱:
label.visibility2=可見性:
checkbox.static=static
checkbox.check.clone.method=檢查 '__clone' 方法
checkbox.check.destruct.method=檢查 '__destruct' 方法
checkbox.check.sleep.method=檢查 '__sleep' 方法
checkbox.check.wakeup.method=檢查 '__wakeup' 方法
checkbox.align.parameter.property.names=對齊參數/屬性名稱
checkbox.align.tag.comments=對齊標記註釋
checkbox.blank.line.before.the.first.tag=在第一個標記前使用空行
checkbox.blank.lines.around.parameters=在參數周圍使用空行
checkbox.keep.blank.lines=保留空行
checkbox.sort.phpdoc.tags=對 PHPDoc 標記排序
checkbox.use.fully.qualified.class.names=使用完全限定類名
checkbox.wrap.long.lines=長行換行
checkbox.use.as.a.default.template=用作預設模板
label.server.document.root=$_SERVER['DOCUMENT_ROOT']
tooltip.defaults.to.project.folder=預設為專案資料夾
border.title.include.analysis=Include 分析
button.sync.extensions.with.interpreter=將擴展與解釋器同步
checkbox.add.a.comma.after.last.element.in.multiline.array=在多行陣列中的最後一個元素之後添加逗號
checkbox.force.short.declaration.style=強制短宣告樣式
checkbox.add.phpdoc=添加 PHPDoc(&D):
radio.button.copy.from.base.class=從基類複製(&P)
radio.button.default.empty.template=預設/空模板(&E)
radio.button.with.inheritdoc.tag=帶有 @inheritDoc 標記(&I)
label.constant.syntax=常數語法(&C)
php.interpreter.label.label=標籤
no.expression.found=找不到表達式
empty.type=空類型
add.catch.clause.quick.fix=添加 'catch' 從句
php.delete.catch.clause.quick.fix=刪除 'catch' 子句
php.delete.exception.quick.fix=刪除異常
php.surround.with.try.catch.quick.fix=使用 'try-catch' 環繞
trait.use.rule.type.name=特徵 use 規則方法
member.has.0.access.but.class.has.magic.method.1=成員具備 {0} 可見性，但可以通過 ''{1}'' 魔術方法存取
member.has.0.access=成員具備 {0} 可見性
declaration.must.be.compatible.with.0=宣告必須與 {0} 相容
declaration.must.be.compatible.with.super=宣告必須與父級相容
return.type.declaration.must.be.compatible.with.super=返回類型宣告必須與父級相容
array.only.updated.but.never.queried=陣列僅被更新，但從未被查詢
composer.json.open.tool.settings.intention=打開工具設定
composer.json.path.not.configured=自訂儲存庫無法載入。未配置 composer.json 路徑
composer.json.exec.not.configured=自訂儲存庫無法載入。未配置 Composer 可執行檔案路徑
composer.json.custom.packages.done=自訂儲存庫已載入
composer.json.custom.packages.empty=找不到軟體套件。請檢查您的儲存庫
composer.json.custom.invalid.json=json 無效
composer.json.packagist.packages.done=僅載入了 packagist 儲存庫
composer.json.packages.loading.error=軟體套件未重新載入
composer.json.packages.refresh=軟體套件正在刷新
cant.save.interpreter=無法儲存 ''{0}'': {1}
method.is.undefined.in.class=方法 ''#ref'' 在 {0} 中{1,choice,0#未找到|1#可能未定義}
method.is.undefined=方法 '#ref' {0,choice,0#未定義|1#可能未定義}
property.is.undefined.in.class=屬性 ''#ref'' 在 {0} 中{1,choice,0#未找到|1#可能未定義}
property.is.undefined=屬性 '#ref' {0,choice,0#未定義|1#可能未定義}
find.cause=尋找原因
find.exception.cause.table.title=異常原因
php.find.clause.throws=可能拋出: {0}
action.PhpStanAddToIgnored.text=添加到 PHPStan 忽略列表
action.PhpStanAddToIgnored.description=添加到 PHPStan 忽略列表
inspection.php.unused.display.name=未使用的宣告
inspection.php.expression.always.constant.inspection.display.name=到達時，變數始終為 true/false
inspection.composer.json.file.references.inspection.display.name=未解析的檔案引用
inspection.php.doc.duplicate.type.inspection.display.name=類型已存在於 PHPDoc 標記中
inspection.php.class.implements.solely.traversable.inspection.display.name=類無法直接實作 Traversable
inspection.php.array.used.only.for.write.inspection.display.name=陣列僅用於寫存取
inspection.php.private.field.can.be.local.variable.inspection.display.name=private 屬性可為局部
inspection.php.foreach.variable.overwrite.already.defined.variable='foreach' 變數覆寫已定義的變數
inspection.php.inappropriate.inherit.doc.usage.inspection.display.name=使用了不當的 @inheritDoc
inspection.php.expression.with.same.operands.inspection.display.name=邏輯表達式有相同操作數
inspection.php.traits.use.list.inspection.display.name=每行一個特徵 use
inspection.php.long.type.form.inspection.display.name=類型關鍵字的縮寫
inspection.php.compound.namespace.depth.inspection.display.name=復合命名空間深度大於 2
inspection.php.separate.else.if.inspection.display.name=Else if
inspection.php.new.class.missing.parameter.list.inspection.display.name=缺少參數列表
inspection.php.var.usage.inspection.display.name=使用了 var
inspection.php.modifier.order.inspection.display.name=修飾符順序
inspection.php.missing.visibility.inspection.display.name=缺少可見性
inspection.php.parameter.by.ref.is.not.used.as.reference.inspection.display.name=不必要的通過引用傳遞
inspection.php.accessed.array.is.always.empty=陣列在存取點始終為空
inspection.php.if.can.be.merged.with.sequential.condition='if' 可以與後續條件合併
inspection.php.instanceof.is.always.true='instanceof' 的結果始終為 'true'
inspection.php.in.array.can.be.replaced.with.comparison='in_array' 可以取代為比較
inspection.php.func.get.arg.can.be.replaced.with.parameter.access='func_get_arg()' 調用可以取代為參數存取
inspection.php.format.function.call.with.single.argument=使用單個實參格式化函數調用
inspection.php.invalid.instanceof.argument.type='instanceof' 的實參只應是物件或字串
inspection.php.condition.always.evaluates.to.constant=條件始終評估為 'true/false'
inspection.php.condition.checked.by.next.condition=邏輯表達式內部的條件由後續條件檢查
inspection.php.array.write.access.is.not.used=未使用陣列寫入存取
inspection.php.redundant.optional.argument=冗餘的可選實參
inspection.php.property.only.written=屬性用法具有相同的存取權限
inspection.php.to.string.may.produce.exception='__toString' 可能會拋出異常
inspection.php.loop.never.iterates.name=迴圈未迭代
inspection.php.loop.never.iterates=''{0}'' 語句不迴圈
inspection.php.ternary.expression.can.be.replaced.with.condition.inspection.display.name=三元表達式可以取代為條件
inspection.php.ternary.expression.can.be.replaced.with.short.version=三元表達式可以取代為短版本
inspection.php.unnecessary.local.variable.inspection.display.name=不必要的局部變數
inspection.php.unnecessary.semicolon.inspection.display.name=不必要的分號
inspection.php.curly.brace.access.syntax.usage.inspection.display.name=使用了大括號存取語法
inspection.php.single.statement.with.braces.inspection.display.name=單語句主體帶大括號
inspection.php.statement.without.braces.inspection.display.name=控制語句主體無大括號
inspection.php.str.functions.inspection.display.name='str*()' 調用可以取代為 PHP 8 'str_*()' 調用
inspection.php.nested.ternary.expression.usage.inspection.display.name=使用了嵌套的三元運算符
inspection.php.doc.field.type.mismatch.inspection.display.name=類型與屬性的宣告類型不符合
inspection.php.switch.case.without.default.branch.inspection.display.name=switch 語句沒有 default 分支
inspection.php.strict.comparison.of.operands.with.different.types=嚴格比較類型不相容的操作數
inspection.php.suspicious.name.combination.inspection.name=可疑名稱組合
inspection.php.duplicate.switch.case.body.inspection.display.name=switch 語句中存在重複分支
inspection.php.duplicate.switch.catch.body.inspection.display.name='catch' 語句中的重複分支
inspection.php.exception.is.immediately.rethrown=立即重新拋出異常
inspection.php.continue.targeting.switch='continue' 針對 'switch' 語句
inspection.php.redundant.continue.break.argument=冗餘的 'continue/break' 實參
inspection.php.duplicate.match.arm.body.inspection.display.name='match' 表達式中的重複 arm
inspection.php.field.assignment.type.mismatch.inspection.display.name=屬性賦值中的類型不符合
inspection.php.closure.can.be.converted.to.short.arrow.function.inspection.display.name=閉包可以轉換為箭頭函數
inspection.php.concatenation.with.arithmetic.usage=具有算術用法的串聯
inspection.php.parameter.always.have.same.value=參數值始終相同
inspection.php.method.return.value.is.never.used=方法的返回值從未使用
inspection.php.isset.can.be.replaced.with.coalesce='isset' 可以取代為合併
inspection.php.cast.is.unnecessary=類型轉換不必要
inspection.php.unnecessary.curly.variable.syntax=變數的不必要大括號語法
inspection.php.unpacked.argument.type.mismatch.inspection.display.name=無效類型的解包實參
inspection.php.missing.return.type.inspection.display.name=缺少返回類型宣告
inspection.php.missing.parameter.type.inspection.display.name=缺少參數的類型宣告
inspection.php.missing.field.type.inspection.display.name=缺少屬性的類型宣告
inspection.php.expression.without.clarifying.parentheses.inspection.display.name=表達式不帶澄清括號
inspection.php.unnecessary.parentheses.inspection.display.name=不必要的圓括號
inspection.php.method.may.be.static.inspection.display.name=方法可以為 'static'
inspection.php.format.function.parameters.mismatch.inspection.display.name=格式函數參數不符合
inspection.php.ignored.class.alias.declaration.display.name=忽略的類別名聲明
inspection.php.composer.duplicated.requirement.inspection.display.name=composer.json 中存在重複的軟體套件條目
inspection.php.not.installed.packages.inspection.display.name=未安裝的 Composer 軟體套件
inspection.php.disabled.quality.tool.composer.inspection.display.name=品質工具檢查已禁用
inspection.php.composer.extension.stubs.inspection.display.name=composer.json 中缺少擴展
inspection.php.disabled.extension.stubs.inspection.display.name=已禁用的擴展存根
inspection.php.array.fill.can.be.converted.to.loop.inspection.display.name='array_fill' 可以轉換為迴圈
inspection.php.loop.can.be.converted.to.array.fill.inspection.display.name=迴圈可以轉換為 'array_fill()' 調用
inspection.php.get.class.can.be.replaced.with.class.name.literal.inspection.display.name='get_class()' 調用可以取代為 '::class'
inspection.php.array.filter.can.be.converted.to.loop.inspection.display.name='array_filter()' 調用可以轉換為迴圈
inspection.php.loop.can.be.converted.to.array.filter.inspection.display.name=迴圈可以轉換為 'array_filter()' 調用
inspection.php.loop.can.be.converted.to.array.map.inspection.display.name=迴圈可以轉換為 'array_map()' 調用
inspection.php.array.map.can.be.converted.to.loop.inspection.display.name='array_map()' 調用可以轉換為迴圈
inspection.php.short.open.tag.inspection.display.name=使用了短起始標記
inspection.php.constructor.style.inspection.display.name=舊式構造函數
inspection.php.assignment.replaceable.with.prefix.expression.inspection.display.name=賦值可取代為增量或減量
inspection.php.assignment.replaceable.with.operator.assignment.inspection.display.name=賦值可以取代為運算符賦值
inspection.php.invalid.magic.method.modifiers.inspection.display.name=魔術方法修飾符無效
inspection.php.incorrect.magic.method.signature.inspection.display.name=魔術方法簽名不正確
inspection.php.array.access.on.illegal.type.display.name=非法類型的陣列偏移存取
inspection.php.parameter.name.chaged.during.inhertiance=在繼承期間更改了參數名稱
inspection.php.named.argument.may.be.unresolved=命名實參可能未解析
inspection.php.argument.without.name.identifier=無名稱關鍵字的實參
inspection.php.named.argument.usage=有名稱關鍵字的實參
inspection.php.named.arguments.with.changed.order=命名實參順序與參數順序不符合
inspection.php.mixed.return.type.can.be.reduced=可以限縮 'mixed' 返回類型的範圍
inspection.php.null.is.not.compatible.with.parameter='null' 與參數的宣告類型不相容
inspection.php.nested.dirname.call.can.be.replaced.with.levels.usage=嵌套的 'dirname()' 調用可以取代為 'levels' 參數用法
inspection.php.trait.method.use.is.located.inside.different.target.class=特徵 use 規則已解析為使用不同包含類的方法 
inspection.php.trait.usage=不允許特徵用法
inspection.php.class.cant.be.used.as.attribute=類不能用作特性
inspection.php.redundant.match.expression='match' 表達式只有 default arm，應當進行簡化
inspection.php.loop.can.be.replaced.with.str.repeat=迴圈可以取代為 'str_repeat'
inspection.php.concatenation.with.empty.string.can.be.merged=空字串的串聯可以與賦值合併
inspection.php.match.expression.can.be.replaced.with.ternary='match' 表達式可以取代為三元表達式
inspection.php.switch.can.be.replaced.with.match.expression='switch' 可以取代為 'match' 表達式
inspection.php.inapplicable.attribute.target.declaration=不適用的特性目標宣告
inspection.php.expected.values.should.be.used=應使用預期值
inspection.php.immutable.property.is.written.in.invalid.scope=在無效的作用域中寫入不可變屬性
inspection.php.attribute.is.not.repeatable=不可重複的特性
inspection.php.attribute.no.return.can.be.added=可以添加 NoReturn 特性
inspection.php.pure.contract.attribute.can.be.added=可以添加 '#[Pure]' 特性
inspection.php.pure.function.may.produce.side.effect=純函數可能會產生副作用
inspection.php.attribute.array.shape.can.be.added=可以添加 '#[ArrayShape]' 特性
inspection.php.attribute.can.be.overridden=可以將特性添加到覆寫成員
inspection.php.array.key.does.not.match.array.shape=陣列鍵與陣列形狀不符合 
inspection.php.missing.strict.types.declaration.inspection.display.name=缺少嚴格類型宣告
inspection.php.incompatible.return.type.inspection.display.name=返回類型不相容
inspection.php.strict.type.checking.inspection.display.name=嚴格類型檢查規則違反
inspection.php.non.canonical.elements.order.inspection.display.name=元素的非規範順序
inspection.php.null.safe.operator.can.be.used=可以使用 Nullsafe 運算符 '?->'
inspection.php.variable.variable.inspection.display.name=使用了可變變數
inspection.php.traditional.syntax.array.literal.inspection.display.name=檢測到傳統語法陣列文字
inspection.php.illegal.psr.class.path.inspection.display.name=類路徑與專案結構不符合
inspection.php.multiple.classes.declarations.in.one.file.display.name=一個檔案中有多個類宣告
inspection.php.redundant.catch.clause.inspection.display.name=冗餘 catch 子句
inspection.php.unhandled.exception.inspection.display.name=未處理的異常
inspection.php.non.strict.object.equality.inspection.display.name=非嚴格物件相等
inspection.php.duplicate.case.inspection.display.name=switch 語句中存在重複的 case
inspection.php.duplicate.match.condition.inspection.display.name=重複條件
inspection.php.unused.match.arm.condition.inspection.display.name=未使用的 'match' 條件
inspection.php.comment.will.be.parsed.as.attribute=在 PHP 8.0 中註釋被解析為特性
inspection.php.redundant.attribute.parenthesis=特性中的冗餘圓括號
inspection.php.fully.qualified.name.usage.inspection.display.name=使用了完全限定名稱
inspection.php.unnecessary.fully.qualified.name.inspection.display.name=不必要的完全限定名稱
inspection.mess.detector.validation.inspection.display.name=PHP Mess Detector 驗證
inspection.php.CS.fixer.validation.inspection.display.name=PHP CS Fixer 驗證
inspection.php.CS.validation.inspection.display.name=PHP_CodeSniffer 驗證
inspection.php.usage.of.silence.operator.inspection.display.name=使用了靜默運算符
inspection.php.useless.trailing.comma.inspection.display.name=無用的尾隨逗號
inspection.php.useless.trailing.comma.inspection.desc=無用的尾隨逗號
inspection.php.remove.useless.trailing.comma=移除無用的尾隨逗號
inspection.php.add.line.break.after.trailing.comma=在尾隨逗號後添加換行符
inspection.php.foreach.array.is.used.as.value.inspection.display.name=Foreach 陣列用作值
inspection.php.foreach.nested.outer.key.value.variables.conflict.inspection.display.name=嵌套與外部 'foreach' 變數衝突
inspection.php.missing.break.statement.inspection.display.name=缺少 'break' 語句
inspection.php.unit.covers.by.access.modifier.is.deprecated.inspection.display.name=棄用的通過修飾符註解進行的 @covers/@uses
inspection.php.unit.expected.exception.doc.tag.is.deprecated.inspection.display.name=棄用的通過文檔標記進行的異常處理
inspection.php.unit.deprecated.expect.exception.inspection.display.name=使用了棄用的 expectException
inspection.php.unit.assert.array.has.key.inspection.display.name=可以改用方法 'assertArrayHasKey/assertArrayNotHasKey'
inspection.php.unit.misordered.assert.equals.arguments.inspection.display.name=順序錯誤的 PHPUnit 等式斷言方法實參
inspection.php.unit.assert.count.inspection.display.name=使用了 'assertCount/assertSameSize' 方法而非 assertEquals
inspection.php.unit.assert.contains.inspection.display.name=棄用的 'assertContains/assertNotContains' 用法
inspection.php.unit.assert.can.be.replaced.with.fail=斷言可以取代為 'fail'
inspection.php.unit.assert.empty.inspection.display.name=斷言可以取代為 'assertEmpty/assertNotEmpty'
inspection.php.unit.assert.file.equals.inspection.display.name=棄用的 'assertFileEquals/assertStringEqualsFile' 用法
inspection.php.unit.assert.equals.inspection.display.name=棄用的 'assertEquals/assertNotEquals' 用法
inspection.php.unit.covers.function.without.scope.resolution.operator.inspection.display.name=提供的覆蓋函數引用沒有 ‘::’
inspection.php.unit.undefined.data.provider.inspection.display.name=未定義的 PHPUnit 資料提供程序
inspection.php.unit.missing.target.for.test.inspection.display.name=PHPUnit 測試缺少目標元素
inspection.php.constant.naming.convention.inspection.display.name=常數名稱未遵循編碼慣例
inspection.php.variable.naming.convention.inspection.display.name=變數名稱未遵循編碼慣例
inspection.php.property.naming.convention.inspection.display.name=屬性名稱未遵循編碼慣例
inspection.php.method.naming.convention.inspection.display.name=方法名稱未遵循編碼慣例
inspection.php.function.naming.convention.inspection.display.name=函數名稱未遵循編碼慣例
inspection.php.class.naming.convention.inspection.display.name=類名未遵循編碼慣例
inspection.php.overriding.method.visibility.inspection.display.name=方法可見性不應被覆寫
inspection.php.method.or.class.call.is.not.case.sensitive.inspection.display.name=方法調用或類用法中的大小寫不符合
inspection.php.expression.result.unused.inspection.display.name=未使用表達式結果
inspection.php.throwable.not.thrown.inspection.display.name=未拋出 Throwable
inspection.php.void.function.result.used.inspection.display.name=使用了 void 函數結果
inspection.php.redundant.closing.tag.inspection.display.name=冗餘結束標記
inspection.php.too.many.parameters.inspection.display.name=函數宣告中的參數過多
inspection.php.method.parameters.count.mismatch.inspection.display.name=參數數量與宣告不符合
inspection.php.inconsistent.return.points.inspection.display.name=不一致的返回點
inspection.php.redundant.variable.doc.type.inspection.display.name=冗餘 @var 標記
inspection.php.doc.redundant.throws.inspection.display.name=冗餘 @throws 標記
inspection.php.doc.missing.throws.inspection.display.name=缺少 @throws 標記
inspection.php.redundant.doc.comment.inspection.display.name=冗餘 PHPDoc 註釋
inspection.php.doc.signature.inspection.display.name=PHPDoc 註釋符合函數/方法簽名
inspection.php.doc.is.not.complete.inspection.display.name=PHPDoc 註釋簽名不完整
inspection.php.return.doc.type.mismatch.inspection.display.name=PHPDoc 註釋中的返回類型與實際返回類型不符合
inspection.php.illegal.string.offset.inspection.display.name=非法字串偏移
inspection.php.illegal.array.key.type.inspection.display.name=非法陣列鍵類型
inspection.php.silly.assignment.inspection.display.name=冗餘賦值
inspection.php.missing.doc.comment.inspection.display.name=缺少 PHPDoc 註釋
inspection.php.unused.parameter.inspection.display.name=未使用的參數
inspection.php.wrong.foreach.argument.type.inspection.display.name=為 'foreach()' 提供的無效實參
inspection.php.division.by.zero.inspection.display.name=除以零
inspection.php.assignment.in.condition.inspection.display.name=條件中的賦值
inspection.php.wrong.catch.clauses.order.inspection.display.name=catch 子句順序錯誤
inspection.php.wrong.string.concatenation.inspection.display.name=字串串聯錯誤
inspection.php.constant.reassignment.inspection.display.name=常數重新賦值
inspection.php.non.compound.use.inspection.display.name=不必要的語句使用
inspection.php.to.string.implementation.inspection.display.name=方法 '__toString' 實作
inspection.php.to.string.return.inspection.display.name=方法 '__toString' 返回類型
inspection.php.internal.entity.used.inspection.display.name=使用了內部實體
inspection.php.deprecated.implode.usage.inspection.display.name=棄用的 'implode/join' 用法
inspection.php.expression.always.null.inspection.display.name=表達式始終為 'null'
inspection.php.deprecated.cast.inspection.display.name=棄用的轉換
inspection.php.define.constant.name.with.leading.slash=使用前導斜杠定義的常數名稱
inspection.php.define.constant.can.be.replaced.with.const.syntax=define 常數名稱可以取代為 'const' 語法
inspection.php.element.is.not.available.in.current.php.version.inspection.display.name=元素在配置的 PHP 版本中不可用
inspection.php.deprecation.inspection.display.name=已棄用
inspection.php.plural.mixed.can.be.replaced.with.array='mixed' 類型可以取代為 'array'
inspection.php.language.level.inspection.display.name=語言級別
inspection.php.unused.field.default.value.inspection.display.name=冗餘屬性初始值設定項
inspection.php.unused.alias.inspection.display.name=未使用的 import
inspection.php.unused.local.variable.inspection.display.name=未使用的局部變數
inspection.php.write.access.to.referenced.array.value.without.unset=對無 'unset' 的引用陣列值的寫入權限
inspection.php.boolean.expression.can.be.simplified=可以簡化布爾表達式
inspection.array.access.can.be.replaced.with.foreach.value=陣列存取可以取代為 'foreach' 值
inspection.php.unused.private.field.inspection.display.name=未使用的 private 屬性
inspection.php.unused.private.method.inspection.display.name=未使用的 private 方法
inspection.php.goto.into.loop.inspection.display.name=Goto 轉入迴圈語句
inspection.php.pass.by.ref.inspection.display.name=通過引用傳遞參數
inspection.php.optional.before.required.parameters.inspection.display.name=可選參數在必選參數之前
inspection.php.params.inspection.display.name=參數類型
inspection.php.include.inspection.display.name=未解析的 include
inspection.php.undefined.constant.inspection.display.name=未定義的常數
inspection.php.undefined.field.inspection.display.name=未定義的屬性
inspection.php.statement.has.empty.body.inspection.display.name=語句具有空體
inspection.php.missing.parent.call.magic.inspection.display.name=魔術方法缺少父調用
inspection.php.missing.parent.call.common.inspection.display.name=方法缺少父調用
inspection.php.missing.parent.constructor.inspection.display.name=構造函數缺少父調用
inspection.php.undefined.class.constant.inspection.display.name=未定義的類常數
inspection.php.super.class.incompatible.with.interface.inspection.display.name=父類的方法宣告與實作的接口不相容
inspection.php.signature.mismatch.during.inheritance.inspection.display.name=覆寫方法的宣告應與父類相容
inspection.php.abstract.static.method.inspection.display.name=static 函數不應為 abstract
inspection.php.static.as.dynamic.method.call.inspection.display.name=static 方法被調用為動態
inspection.php.dynamic.as.static.method.call.inspection.display.name=動態方法被調用為 static
inspection.php.possible.polymorphic.invocation.inspection.display.name=可能的多態調用
inspection.php.promoted.field.usage=提升的屬性用法
inspection.field.can.be.promoted=可以提升屬性
inspection.php.redundant.assignment.to.promoted.field=冗餘的提升屬性賦值
inspection.php.undefined.callback.inspection.display.name=未定義的回調
inspection.php.undefined.function.inspection.display.name=未定義的函數
inspection.php.undefined.class.inspection.display.name=未定義的類
inspection.php.multiple.class.declarations.inspection.display.name=多個類宣告
inspection.php.undefined.namespace.inspection.display.name=未定義的命名空間
inspection.php.undefined.method.inspection.display.name=未定義的方法
inspection.php.undefined.variable.inspection.display.name=未定義的變數
inspection.php.undefined.goto.label.inspection.display.name=未定義的 goto 標籤
inspection.php.group.undefined=未定義的符號
inspection.php.group.probable.bugs=可能的錯誤
inspection.php.group.general=常規
inspection.php.group.strict.standards=PHP 嚴格標準
inspection.php.group.type.compatibility=類型相容性
inspection.php.group.control.flow=控制流
inspection.php.group.code.smell=程式碼異味
inspection.php.group.psr.12=PSR-12
inspection.php.group.phpdoc=PHPDoc
inspection.php.group.code.style=程式碼樣式
inspection.php.group.composer=Composer
inspection.php.group.unused=未使用的符號
inspection.php.group.naming.conventions=命名慣例
inspection.php.group.phpunit=PHPUnit
inspection.php.group.quality.tools=品質工具
inspection.php.group.replacable.assignments=可取代賦值
inspection.php.group.error.handling=錯誤處理
inspection.php.group.attributes=特性
list.item.update.phpdoc.comment=更新 PHPDoc 註釋
inspection.php.unnecessary.return.inspection.display.name=不必要的 'return/continue' 語句
inspection.php.unnecessary.else.inspection.display.name=不必要的 'else' 分支
inspection.php.unnecessary.return.function='return' 不必要，因為是函數中的最後一條語句
inspection.php.unnecessary.return.method='return' 不必要，因為是方法中的最後一條語句
inspection.php.unnecessary.continue='continue' 不必要，因為是迴圈中的最後一條語句
php.unit.create.target.method.quick.fix.family.name=創建缺少的目標方法
inspection.php.missing.return.type.description=缺少函數的返回類型宣告
inspection.php.missing.param.type.description=缺少參數的類型宣告
quickfix.php.missing.param.type.description=作為參數類型添加 ''{0}''
quickfix.php.missing.param.type.batch.description=作為屬性類型添加推斷的類型
php.add.method.declaration.quick.fix.text=添加方法
php.add.tag.base.quick.fix.family.name=添加 {0} 標記
inspection.php.unused.field.default.value.description=屬性初始值設定項冗餘
php.change.function.signature.manually.quick.fix.family.name=手動更改簽名
php.change.function.signature.from.usage.quick.fix.family.name=從用法改變函數簽名
searching.for.usages=正在搜尋用法…
php.replace.with.local.variable.quick.fix.family.name=將屬性取代為局部變數
inspection.php.private.field.can.be.local.variable.description=屬性可以取代為局部變數
inspection.php.abstract.static.method.description=PHP 嚴格標準: static 方法 '#ref' 不應為 abstract
php.replace.argument.with.cast.quick.fix.family.name=將實參轉換為{0}
php.change.cast.operation.quick.fix.family.name=將轉換更改為{0}
php.replace.with.null.quick.fix.family.name=取代為 'null'
inspection.php.expression.always.null.description='#ref' 始終為 'null'
inspection.unnecessary.static.reference=final 類中有冗餘的 'static'
inspection.unnecessary.string.cast=冗餘轉換為字串
inspection.unnecessary.bool.cast=冗餘轉換為布林值
php.configure.extensions.quick.fix.family.name=配置擴展存根
php.enable.extension.quick.fix.family.name=啟用擴展存根
php.enable.extension.quick.fix.text=啟用 ''{0}'' 擴展存根
inspection.php.disabled.extension.stubs.description=已禁用的 ''{0}'' 擴展存根
inspection.php.unnecessary.semicolon.description=不必要的 ;
inspection.php.inappropriate.inherit.doc.usage.description=@inheritDoc 用於沒有父級成員但含有 doc 註釋的成員
inspection.php.inappropriate.inherit.doc.usage.description2=@inheritDoc 應僅用於類成員
php.inline.variable.quick.fix.family.name=內聯變數
update.php.doc.type.family.name=更新 PHPDoc 類型
update.php.doc.type.comment=取代為 ''{0}''
inspection.php.return.doc.type.mismatch=PHPDoc 中的返回類型與實際返回類型不符合
inspection.php.doc.signature.description=重複的實參 PHPDoc
inspection.php.doc.signature.description2=返回類型與宣告的不符合
inspection.php.doc.signature.description3=不存在實參的 PHPDoc
inspection.php.doc.signature.description5=實參類型與宣告的不符合
php.flip.variable.and.type.quick.fix.family.name=翻轉變數和類型
inspection.php.non.canonical.elements.order.description=變數及其類型以非規範順序列出
php.make.class.abstract.quick.fix.family.name=將類設為 abstract
php.remove.doc.tag.quick.fix.family.name=移除 {0}
php.make.method.non.final.quick.fix.family.name=將方法設為非 final
inspection.php.short.open.tag.description=使用了短起始標記
php.make.method.non.static.quick.fix.family.name=將方法設為非 static
php.flip.arguments.quick.fix.family.name=翻轉第一和第二個實參
inspection.php.unused.alias.description=匯入 '#ref' 不必要
inspection.php.unused.alias.description2=匯入 '#ref' 從未使用
php.rename.wrong.reference.quick.fix.family.name=重命名引用
php.append.doc.static.fix.family.name=在函數引用前追加 '::'
inspection.php.include.description=無法解析表達式 ''{0}'' 的目標
inspection.php.include.description2=未找到路徑 ''{0}''
make.call.dynamic.quick.fix.family.name=使調用為動態
inspection.php.undefined.class.description=類 '#ref' 存在多個定義
inspection.php.undefined.class.description2=未定義的類 '#ref'
inspection.php.undefined.class.description5=存在類 '#ref' 的其他宣告
php.dead.code.entries=PHP 死碼條目
inspection.php.redundant.variable.doc.type.description=@var 標記指定了已從原始碼推斷出的類型
php.remove.all.unused.parameters.quick.fix.text=移除所有未使用的參數
transform=轉換
remove=移除
php.remove.unused.local.variable.without.successor.quick.fix.family.name=移除變數 ''{0}''
php.replace.with.float.cast.quick.fix.family.name=取代為 '(float)' 轉換
php.create.data.provider.quick.fix.family.name=創建資料提供程序
inspection.php.undefined.namespace.description=未定義的命名空間 '#ref'
fix.not.available=修復不可用
php.unit.create.target.class.quick.fix.family.name=創建缺少的目標類
initialize.var.quick.fix.family.name=使用值初始化
inspection.php.statement.has.empty.body.description=語句具有空體
php.replace.with.interface.quick.fix.family.name=取代為 {0}
remove.redundant.suppression.quick.fix.family.name=移除 ''{0}'' 禁止
php.change.method.modifiers.quick.fix.family.name=更改修飾符
php.change.method.modifiers.quick.fix.text=移除修飾符
php.remove.statement.fix.family.name=移除
php.make.method.non.abstract.quick.fix.family.name=將方法設為非 abstract
replace.plus.asgn.to.concat.asgn.quick.fix.family.name=將 '+=' 取代為 '.='
replace.plus.to.concat.quick.fix.family.name=將 '+' 取代為 '.'
replace.with.0=取代為 {0}
php.remove.ref.from.function.declaration.quick.fix.family.name=從函數宣告中移除 '&'
php.remove.ref.from.assignment.quick.fix.family.name=將 '=\\\\\\\\&' 取代為 '='
php.remove.pass.by.ref.from.parameter.quick.fix.family.name=從參數中移除 '&'
inspection.php.pass.by.ref.description=僅變數可通過引用返回
php.non.strict.object.equality.quick.fix.text=取代為身份比較
php.add.field.declaration.quick.fix.text=添加屬性
quick.fix.error=快速修復錯誤
the.original.class.0.does.not.belong.to.the.project.and.cannot.be.modified=原始類 {0} 不屬於該專案\\\\n\\\\
並且無法修改。
add.constant.declaration.quick.fix.text=添加常數
constant.ref.not.found.in=在 {0} 中未找到常數 ''#ref''
php.remove.parameters.quick.fix.text=移除未使用的參數
replace.extends.implements=取代 'extends'/'implements'
inspection.php.undefined.class.other.declaration.exists={0} 處存在類 ''#ref'' 的其他宣告
inspection.php.undefined.class.other.declaration.exists.and={0} 和另 {1} 處存在類 ''#ref'' 的其他宣告
show.implementations.for.0={0} 的實作
show.super.types.for.0=顯示 {0} 的父類型
display.name.directory.0=目錄 ''{0}''
hint.text.element.doesn.t.have.fqn=元素沒有 FQN
instanceof.is.always.true={0} 已位於 {1} 的層次結構中
dialog.message.server.host.cannot.be.empty=伺服器主機不能為空
dialog.message.port.cannot.be.negative.number=端口號不能為負
dialog.message.query.string.cannot.start.with=查詢字串不能以 '?' 開頭
inspection.message.code.fragment.too.complex.to.parse.this.piece.code.will.be.treated.as.plain.text=程式碼段過於複雜，無法解析，因此將作為純文本處理
inspection.message.control.flow.too.big.to.analyze=控制流太大，無法分析
remove.variable=移除變數
annotator.fix.remove=移除 ''{0}''
inspection.message.class.may.inherit.from.final.class=類可能無法繼承 final 類
inspection.message.key.element.cannot.be.reference=鍵元素不能為引用
inspection.message.absolute.method.reference.should.be.specified.for.insteadof.trait.use.rule=應為 'insteadof' 特徵 use 規則指定絕對方法引用
inspection.message.generators.may.only.declare.return.type.generator.iterator.or.traversable.or.iterable.permitted=生成器只能宣告 ''Generator''、''Iterator''、''Traversable'' 或 ''iterable'' 的返回類型，不允許 {0}
find.usages.button.base.method=基方法
find.usages.button.current.method=當前方法
find.usages.prompt.dialog.implements=類 ''{1}'' 的方法 ''{0}()'' 在 ''{2}'' 中實作了{3,choice,0#方法|1#方法}\\\\n\\\\
要尋找基{3,choice,0#方法|1#方法}的用法嗎?
find.usages.prompt.dialog.overrides=類 ''{1}'' 的方法 ''{0}()'' 在 ''{2}'' 中重寫了{3,choice,0#方法|1#方法}\\\\n\\\\
要尋找基{3,choice,0#方法|1#方法}的用法嗎?
more.actions=更多操作…
show.log.of.composer.related.actions=顯示 Composer 相關操作的日誌
show.log=顯示日誌
members.to.report=要報告的成員
entry.points=入口點
constructors=構造函數
inspection.message.type.mismatch.should.be.conditional.expression=類型不符合: 應為條件表達式
filetype.doctrine.query.description=Doctrine 查詢語言
inspection.php.typed.property.might.be.uninitialized.inspection.display.name=類型化屬性可能未初始化
inspection.php.typed.property.might.be.uninitialized.inspection.problem=類型化屬性 ''{0}'' 可能未初始化
inspection.message.primitive.types.can.t.be.used.as.instanceof.argument=僅物件或字串應用作 ''instanceof'' 實參，當前: ''{0}''
another.definition.with.same.name.exists.in.this.file=此檔案中存在另一個具有相同名稱的定義
method.with.same.name.already.defined.in.this.class=此類中已經定義了具有相同名稱的方法
global.code.should.be.enclosed.in.global.namespace.declaration=全域程式碼應包含在全域命名空間宣告中
static.property.cannot.be.unset=static 屬性不能取消設定
the.yield.expression.can.only.be.used.inside.a.function='yield' 表達式只能在函數中使用
multiple.modifiers.are.not.allowed=不允許多個修飾符
access.type.for.interface.member.must.be.omitted=接口成員的存取類型必須省略
final.modifier.is.not.allowed.here=此處不允許使用 'final' 修飾符
fields.cannot.be.declared.final=屬性不能宣告為 final
abstract.modifier.is.not.allowed.here=此處不允許使用 'Abstract' 修飾符
fields.cannot.be.declared.abstract=屬性不能宣告為 abstract
static.modifier.is.not.allowed.here=此處不允許使用 'Static' 修飾符
jump.into.a.finally.block.is.disallowed=不允許跳入 'finally' 塊
cannot.use.static.as.function.return.type.declaration=不允許 'static' 作為類範圍外部的返回類型宣告
void.type.cannot.be.nullable=void 類型不能是可為 null
can.only.be.used.as.standalone.type={0} 僅可用作獨立類型
void.can.only.be.used.as.return.type=Void 只能用作返回類型
static.is.not.allowed.in.parameter.type.declaration=參數類型宣告中不允許 'static'
cannot.use.this.as.parameter=不能將 $this 用作參數
only.the.last.parameter.can.be.variadic=只有最後一個參數可以是可變形參
expression.is.not.allowed.as.parameter.default.value=表達式不允許為參數預設值
argument.passed.must.be.of.the.type.0.1.given=傳遞的實參必須為 {0} 類型，給定的為 {1}
variadic.parameter.cannot.have.a.default.value=可變參數不能具有預設值
only.simple.expressions.are.allowed=只允許簡單表達式
target.trait.should.be.specified=應指定目標特徵
call.to.0.1.construct.from.invalid.context=從無效上下文調用 ''{0} {1}::__construct()''
constants.defined.using.the.const.keyword.must.be.declared.at.the.top.level.scope=使用 'const' 關鍵字定義的常數必須在頂層範圍宣告
expression.is.not.allowed.as.constant.value=表達式不允許作為常量值
cannot.redeclare.constant.0=無法重新宣告常數 ''{0}''
expression.is.not.allowed.as.field.default.value=表達式不允許為欄位預設值
cannot.declare.self.referencing.constant=無法宣告自引用常數
a.class.constant.must.not.be.called.class.it.is.reserved.for.class.name.fetching=類常數不得被稱為 'class'；後者被保留用於類名提取
traits.cannot.have.constants=特征不能有常數
redefinition.of.parameters.is.not.allowed=不允許參數重新定義
method.0.clone.cannot.accept.any.arguments=方法 ''{0}::__clone()'' 不能接受任何實參
return.type.declaration.is.not.allowed=不允許返回類型宣告
method.should.not.be.finished.with=方法不應以 ';' 結束
method.should.either.have.body.or.be.abstract=方法應具有主體或為 abstract
interface.method.can.t.have.body=接口方法不能有主體
anonymous.function.expected=應為匿名函數
label.with.same.name.already.defined.in.current.scope=當前範圍中已定義具有相同名稱的標籤
interfaces.may.not.include.member.variables=接口可能不包括成員變數
0.with.same.name.already.defined.in.this.class=此類中已經定義了具有相同名稱的{0}
field=欄位
cannot.redeclare.static.0.1.as.non.static.2.3=無法將 static ''{0}::\${1}'' 重新宣告為非 static ''{2}::\${3}''
cannot.redeclare.non.static.0.1.as.static.2.3=無法將非 static ''{0}::\${1}'' 重新宣告為 static ''{2}::\${3}''
0.and.1.define.the.same.property.2=''{0}'' 和 ''{1}'' 定義相同的屬性 ''{2}''
access.level.to.0.1.must.be.2.as.in.class.3.or.weaker=''{0}::\${1}'' 的存取級別必須為 {2} (與類 {3} 中一樣)或更低
access.level.to.0.1.must.be.2.as.in.class.3.or.weaker2=''{0}::{1}'' 的存取級別必須為 {2} (與類 {3} 中一樣)或更低
cannot.inherit.previously.inherited.or.override.constant.0.from.interface.1=無法從接口 ''{1}'' 繼承先前繼承的常數 ''{0}'' 或將其覆寫
empty.implements.list=空實作列表
a.trait.cannot.implement.an.interface=特徵無法實作接口
class.cannot.implement.previously.implemented.interface=類無法實作先前實作的接口
class.should.not.implement.itself=類不應自行實作
empty.extends.list=空 extends 列表
a.trait.cannot.extend.a.class=特徵無法擴展類
interface.cannot.extend.previously.extended.interface=接口無法擴展先前擴展的接口
class.cannot.extend.from.trait=類無法從特徵擴展
0.should.not.extend.itself={0} 不應自行擴展
class=類
class.declarations.may.not.be.nested=類宣告不能被嵌套
cannot.use.traits.inside.of.interfaces=無法在接口內部使用特徵
trait.expected.class.found=應為特徵，發現類
absolute.reference.is.not.allowed=不允許絕對引用
cannot.use.0.as.lexical.variable=無法將 ''\${0}'' 用作詞法變數
duplicate.variable.0=重複的變數 ''{0}''
trailing.comma.is.not.allowed=不允許尾隨逗號
the.use.keyword.must.be.declared.in.the.outermost.scope.of.a.file.the.global.scope.or.inside.namespace.declarations=必須在檔案的最外側範圍(全域範圍)或命名空間宣告內部宣告 'use' 關鍵字
static.is.not.allowed.in.compile.time.constants=編譯時常量中不允許使用 'static::'
multiple.namespaces.in.a.file.should.use.same.preferably.braced.syntax=檔案中的多個命名空間應使用相同的(最好帶大括號)語法
no.content.allowed.before.namespace.declaration=命名空間宣告之前不允許任何內容
an.object.s.clone.method.cannot.be.called.directly=無法直接調用物件的 '__clone()' 方法
property.write=@property-write
property.read=@property-read
isset.only.works.with.variables.and.arrays=isset 僅適用於變數和陣列
cannot.use.positional.argument.after.argument.unpacking=無法在實參解包後使用位置實參
function.name.must.be.callable.a.string.closure.or.class.implementing.invoke.currently.0=函數名稱必須可調用 - 字串、閉包或實作 ''__invoke'' 的類，當前為 ''{0}''
using.this.when.not.in.object.context=不在物件上下文中時使用 '$this'
array.can.t.be.used.for.array.destructuring.assignment='array()' 不能用於陣列析構賦值
function.call.is.not.allowed.here=此處不允許使用函數調用
expression.is.not.assignable=表達式不可賦值
call.to.method.clone.from.invalid.context=從無效上下文調用方法 '__clone'
cannot.use.for.reading=無法使用 '[]' 進行讀取
it.s.not.possible.to.unpack.array.argument.by.reference=無法通過引用對陣列實參解包
spread.operators.in.arrays.are.not.supported.for.multiassignments.variables=多賦值變數不支持在陣列中使用展開運算符
it.s.not.possible.to.unpack.array.value.with.associated.key=無法使用關聯鍵解包陣列值
it.s.not.possible.to.unpack.array.key=無法解包陣列鍵
cannot.use.empty.array.elements.in.arrays=無法在陣列中使用空陣列元素
invalid.octal.literal.won.t.be.reported.by.php.but.will.work.incorrectly=無效的八進制文字: 不會由 PHP 報告，但無法正常工作
multiple.subsequent.underscores.in.a.numeric.literal.are.not.allowed=不允許在數字文字中使用多個後續下划線
expression.is.not.allowed.as.static.initializer=表達式不允許為 static 初始值設定項
namespace.declarations.cannot.be.nested=命名空間宣告不能被嵌套
global.namespace.should.use.braced.syntax=全域命名空間應使用帶大括號的語法
halt.compiler.can.only.be.used.from.the.outermost.scope=僅可從最外側範圍使用 '__halt_compiler()'
cannot.use.match.as.identifier=無法將 'match' 用作關鍵字，自 PHP 8.0 起作為預留關鍵字
cannot.use.class.on.primitive.type=只允許在物件上使用 '::class'
intention.name.replace.nullable.notation.with.null.as.part.union.type=用 '|null' 取代 '?' 作為聯合類型的一部分
intention.name.replace.null.as.part.union.type.with.nullable.notation=將 '|null' 作為聯合類型的一部分取代為 '?'
union.types.and.the.nullable.type.notation.cannot.be.mixed=聯合類型和可為 null 類型表示法不能混合
union.types.mixed.cannot.be.nullable=混合類型不能為可 null，'null' 已是混合類型的一部分
quick.fix.delete=刪除 ''{0}''
type.null.and.false.cannot.be.used.as.as.standalone.type='null' 和 'false' 不可用作獨立類型
is.duplicated.by.0=類型被 ''{0}'' 重複
intention.name.remove.duplicated.type=移除重複類型
popup.title.select.reference.to.remove=選擇要移除的類型
intention.family.name.append=追加 ''{0}''
intention.family.name.change.to.mixed=將類型更改為 'mixed'
inspection.php.redundant.type.in.union.type=類型宣告冗餘，可以簡化
inspection.php.redundant.type.in.union.type.template=類型宣告可以簡化為 ''{0}''
inspection.php.redundant.type.in.union.type.fix.name=簡化冗餘類型

inspection.message.always.true.because=條件始終為 ''{0, choice, 0#false|1#true}''，因為此時 ''{1}'' 已經為 ''{2, choice, 0#false|1#true}''
inspection.nullsafe.deref.unnecessary.because=Nullsafe 運算符{0,choice,0#將始終產生 ''null''|1#不必要}，因為此時 ''{1}'' 已經為 ''{2,choice,0#false|1#true}''
inspection.nullsafe.deref.unnecessary.because.evaluated=Nullsafe 運算符 ''{0,choice,0#將始終產生 ''null''|1#不必要}''，因為此時已評估 ''{1}''
inspection.message.always.true.because.evaluated=條件始終為 ''{0,choice,0#false|1#true}''，因為此時已評估 ''{1}''
hint.evaluation.makes.subsequent.condition.always.true=評估使後續條件始終為 'true'
hint.evaluation.fully.contains=評估結果完全覆蓋 ''{0}'' 的可能結果
hint.evaluation.makes.array.always.empty=評估使得陣列始終為空
intention.family.name.navigate.to.cause=導航到原因
intention.family.name.replace.ternary.expression.with.true.branch=將三元表達式取代為 ''{0}'' 分支
intention.family.name.replace.elseif.with.else=將 'elseif' 取代為 'else'
extract.condition=提取條件
delete.if=刪除 'if'
delete.elseif=刪除 'elseif'
action.show.in.log.text=在日誌中顯示
action.add.file.s.to.list.text=向列表中添加檔案
quality.tool.action.remove.file.s.from.list.text=從列表中移除檔案
quality.tool.action.clean.list.text=清除列表
quality.tool.border.title.ignored.files=已忽略的檔案
quality.tool.ignored.files={0} 忽略的檔案
intention.family.name.remove.redundant.arguments=移除冗餘的 {0, choice, 0#實參|1#實參}
inspection.message.redundant.argument={0, choice, 0#實參|1#實參}{0,choice,0#符合|1#符合}{0, choice, 0#參數的|1#參數的}預設{0, choice, 0#值|1#值}
plural.types.are.not.allowed.in.real.types=僅在 doc 類型中允許複數類型
intention.name.remove.brackets=刪除中括號
intention.name.replace.brackets.with.types=取代為 'array'
inspection.message.only.variables.can.be.passed.by.reference=僅可通過引用傳遞變數
expression.0=表達式 {0}
expression=表達式
notification.content.language.level.was.changed.to.based.on.project.usage=語言級別已根據專案中使用的功能設定為 {0}
action.revert.back.to.text=還原為 {0}
expected.class.reference=應為: 類引用
expected.expression=應為: 表達式
parser.unexpected=意外: {0}
parser.expected=應為: {0}
namespace.cannot.start.with.namespace.due.to.conflict.with.ns.relative.names=由於與 ns 相關名稱衝突，命名空間不能以 \\"namespace\\" 開頭
inspection.php.language.level.description='fn' 是 PHP 7.4 中的保留關鍵字
incorrect.null.safe.operator=錯誤的 nullsafe 運算符
replace.with.quest=取代為 '?'
required.parameters.missing=缺少所需參數 ''{0}''
parameter.ref.type.is.not.compatible.with.declaration=參數 '#ref' 類型與宣告不相容
add.remote.interpreter=添加遠端解釋器
the.remote.hosts.access.plugin.is.missing.please.enable.the.plugin.in.0.plugins=缺少 Remote Hosts Access 套件。請在“{0} | 套件”中啟用此套件。
extract.side.effect=提取副作用
delete.unused.element=刪除未使用的元素
suppress.all.for.file=對檔案全部禁止
callers=調用方
callees=被調用方
call.tree=調用樹
execution.statistics=執行統計
suppress.for.method=對方法禁止
suppress.for.function=對函數禁止
delete.redundant.switch.branch=刪除冗餘 'switch' 分支
suppress.for.phpdoc.comment=對 PhpDoc 註釋禁止
dynamically.declared.field=動態宣告的欄位
convert.closure.to.arrow.function=將閉包轉換為箭頭函數
suppress.for.file=對檔案禁止
choose.a.valid.0.launcher=選擇有效的 {0} 啟動器
0.location={0} 位置
0.path={0} 路徑:
configure=配置
file.0.does.not.exists=檔案 {0} 不存在
expressions=表達式
target=目標
creates.a.composer.json.file=創建 composer.json 檔案
composer.json.file=composer.json 檔案
implement.method=實作方法
split.elseif=拆分 'elseif'
add.setter=添加 setter
php=PHP
filetype.php.description=PHP
remove.redundant.initializer=移除冗餘的初始值設定項
delete.assignment=刪除賦值
in.0=\\\\ ({0} 內)
merge.nested.conditions=合併嵌套的條件
replace.quotes=取代引號
variable.dereferenced=已取消引用變數
0.1={0}，{1}
declaration.in.parent.class.is.incompatible.with.interface=父類中的宣告與接口不相容
copy.switch.branch=複製 'switch' 分支
default=預設:
replace.if.with.switch=將 'if' 取代為 'switch'
choose.an.alias.to.use=選擇要使用的別名
update.signature.to.match.phpdoc.comment=更新簽名以符合 PHPDoc 註釋
no.members.to.pull.up.found=未找到要向上拉取的成員
inject.language.using.phpdoc=使用 PHPDoc 注入語言
negate.boolean.expression=布爾表達式求反
no.members.to.push.down.found=未找到要向下推送的成員
replace.if.clause.with.ternary.expression=將 if 子句取代為三元表達式
0.pushing.members.down.will.result.in.them.being.deleted={0}\\\\n\\\\
向下推送成員將導致它們被刪除
remove.pass.by.ref.sign=移除 '\\\\\\\\&'
make.non.nullable=設為不可 null
reference=引用
function=函數
foreach=foreach
while=while
0=\\\\ ({0})
for=for
filetype.composer.log.description=Composer 日誌
clear.log=清除日誌
align.composer.log.console=對齊 Composer 日誌控制台
all.0=所有({0})
choose.executable.class.to.run.0=選擇用於執行 {0} 的可執行類
show.settings=顯示設定
enable=啟用
composite.test.patterns=復合測試模式
add.test.class.method=添加測試類/方法…
empty.pattern=空模式
ignore.imports.and.formatting=忽略匯入和格式設定
sort.the.elements.by.visibility.public.protected.private=按可見性對元素排序: public、protected、private
sort.by.visibility=按可見性排序
copy=複製
add=添加
replace.ternary.expression.with.if.clause=將三元表達式取代為 if 子句
information=資訊
always.show.pass.by.reference=始終顯示引用傳遞
show.name.for.all.arguments=顯示所有實參的名稱
composer.packages.versions=Composer 軟體套件版本
constructor.field=構造函數欄位
inspection.php.illegal.array.key.type.description={0} {1}
edit.template=編輯模板
remove.rule=移除規則
add.rule=添加規則
choose.super.class.or.interface=選擇超類或接口
choose.super.method=選擇 super 方法
extends.implements.overrides=擴展/實作/覆寫
remove.unnecessary.semicolon=移除不必要的分號
choose.properties=選擇屬性
composer=composer
composer.executable='composer' 可執行檔案
0.12={0}:{1}
label=標籤
namespace=命名空間
alias=別名
constant=常數
field1=欄位
class.constant=類常數
function2=函數
method=方法
class1=類
interface=接口
parameter=參數
variable=變數
cancel=取消
do.not.override=不覆寫
override=覆寫
method.name=方法名稱
proceed=繼續
add.custom.format.function=添加自訂格式函數…
02={0}::
add.class=添加類…
all.exceptions.considered.checked=所有異常均被視為已檢查
html.note.core.extensions.are.part.of.the.php.core.and.cannot.be.left.out.of.a.php.binary.with.compilation.options.html=<html>注: 核心擴展是 PHP 核心的一部分，不能放在包含編譯選項的 PHP 二進制檔案外部。</html>
choose.elements.to.generate.phpdoc.for=選擇要為其生成 PHPDoc 的元素
no.elements.to.generate.phpdoc.for=沒有任何可為其生成 PHPDoc 的元素
invalid.class.name=無效類名
target.class=目標類:
03=({0})
constant.0=常數 {0}
usage.in.return.type=返回類型中的用法
usage.in.import.statement=import 語句中的用法
overriding.implementing.methods=覆寫/實作方法
usage.in.type.hinting=類型提示中的用法
usage.in.implements.clause=implements 子句中的用法
usage.in.extends.clause=etends 子句中的用法
method.call=方法調用
function.call=函數調用
04={0}:
field.ref.not.found=找不到欄位 '#ref'
method.ref.not.found=找不到方法 '#ref'
0.extends.1={0} 擴展 {1}
0.1.choice.0.extends.1.implements.2={0}{1, choice, 0# 擴展 |1# 執行 }{2}
remove.link.between.0.and.1=移除 {0} 與 {1} 之間的鏈接
import.from.deployment.configuration=從部署配置匯入
import=匯入
php.control.flow.viewer.0=PHP 控制流查看器: {0}
php.control.flow.viewer=PHP 控制流查看器
close=關閉(&C)
build.control.flow=構建控制流(&B)
change.member.access=更改成員存取
php.make.class.non.final.quick.fix.family.name=將類設為非 final
squash.repetitive.underscores=壓縮重複下划線
replace.with.01=取代為 {0}
filetype.profiler.snapshot.description=分析器快照
proxy.configuration=代理配置
surround.with.0=使用 ''{0}'' 環繞
rename.constructor=重命名構造函數
rename=重命名
replace.with.alias=取代為別名
strict.type.declaration.is.available.in.php.7.only=從 PHP 7.0 起才允許使用嚴格類型宣告
recursive.call=遞歸調用
smarty=Smarty
add.property=添加 @property
all.scripts=<All scripts>
summary=摘要
can.t.use.nullsafe.operator.in.write.context=在寫入上下文中不能使用 nullsafe 運算符
intention.family.name.collapse.whitespaces=摺疊空格
inspection.message.qualified.name.can.t.contain.whitespaces=限定名稱不能包含空格
php.language.level.widget=PHP 語言級別
tooltip.configured.php.language.level.widget=已配置的 PHP 語言級別
tooltip.configured.php.language.level.widget.composer=通過 Composer 配置的 PHP 語言級別
change.php.language.level=更改 PHP 語言級別
function.fqn=函數 FQN
choose.class=選擇類
older=較舊…
intention.family.name.replace.with=取代為 ''{0}''
inspection.message.redundant.static.in.final.class=final 類中有冗餘的 'static'
link.label.inspection={0} 檢查
intention.name.add.as.function.s.return.type=將 ''{0}'' 作為函數返回類型添加
add.return.type=添加返回類型
php.class=類
php.interface=接口
php.trait=特徵
clearing.cache=清除快取
diagnosing=診斷
simulating.update=模擬更新
generating.autoloader=生成自動載入器
listing.licenses=列出許可證
checking.for.changes.in.code.of.dependencies=檢查依賴項程式碼中的變更
validating=驗證
add.custom.format.function1=添加自訂格式函數
edit.custom.format.function=編輯自定義格式函數
no.item=沒有項
no.interpreter=<無解釋器>
open.in.editor=在編輯器中打開
how.to.fix=修正方法
path.to.php=<php 路徑>
constructor.already.exists=構造函數已存在
fluent.setters=Fluent setter
no.private.fields.to.generate.getters.for=沒有要為之生成 getter 的 private 欄位
no.private.fields.to.generate.both.getters.and.setters.for=沒有要為之同時生成 getter 和 setter 的 private 欄位
no.private.fields.to.generate.setters.for=沒有要為之生成 setter 的 private 欄位
choose.methods.to.implement=選擇要實作的方法
make.0.1=將 ''{0}'' 設為{1}
arrays.are.not.supported.as.operands.for.0=不支持將陣列用作 ''{0}'' 的操作數
types.not.supported.as.operands.for.0.1.2=''{1} {0} {2}'' 中不受支援的操作數類型將導致 PHP 8 TypeError
trait.method.0.will.not.be.applied.because.it.collides.with.1=由於與 ''{1}'' 衝突，因此不會套用特徵方法 ''{0}''
method.0.can.t.be.overridden.with.same.trait.1=無法使用相同的特徵 ''{1}'' 覆寫方法 ''{0}''
intention.name.make.non.final=將{0}設為非 final
replace.with.absolute.reference=取代為絕對引用
debug.output=輸出
no.candidate.methods.to.implement=沒有要實作的候選方法
choose.methods.to.implement1=選擇要實作的方法
choose.methods.to.override=選擇要覆寫的方法
no.candidate.methods.to.override=沒有要覆寫的候選方法
cannot.call.abstract.method.0.1=無法調用 abstract 方法 ''{0}::{1}''
intention.name.flip=翻轉 {0} 和 {1}
method.ref.is.deprecated=方法 '#ref' 已棄用
parameter.is.deprecated=參數 ''{0}'' 已棄用
function.ref.is.deprecated=函數 '#ref' 已棄用
class.ref.is.deprecated=類 '#ref' 已棄用
constant.ref.is.deprecated=常數 '#ref' 已棄用
field.ref.is.deprecated=欄位 '#ref' 已棄用
constant.ref.is.deprecated1=常數 '#ref' 已棄用
inspection.message.duplicate.case.expression=重複 case 表達式
inspection.message.duplicate.case.expression.ref=重複 case 表達式: #ref
replace.qualifier.with.an.import=將限定符取代為匯入
inspection.message.method.ref.marked.as.internal=方法 '#ref' 已標記為 @internal
inspection.message.function.ref.marked.as.internal=函數 '#ref' 已標記為 @internal
inspection.message.class.ref.marked.as.internal=類 '#ref' 已標記為 @internal
inspection.message.constant.ref.marked.as.internal=常數 '#ref' 已標記為 @internal
inspection.message.field.ref.marked.as.internal=欄位 '#ref' 已標記為 @internal
remove.from.the.parameter.0=從參數 ''{0}'' 中移除 ''\\\\\\\\&''
remove.from.function.0.declaration=從函數 ''{0}'' 宣告中移除 ''\\\\\\\\&''
remove.numeric.literals.separators=移除數字文字分隔符
intention.name.remove=移除 {0}
intention.name.convert.array.syntax.to.short=將陣列轉換為短語法
inspection.message.call.chain.too.long.to.analyse.break.it.into.fragments.up.to.calls=調用鏈過長，無法進行分析。請將其拆分為最多包含 {0} 個調用的片段
inspection.message.undefined.goto.label.ref=未定義的 goto 標籤 '#ref'
inspection.message.unused.private.property.ref=未使用的 private 屬性 '#ref'
intention.name.add.method.stubs=添加方法存根
inspection.message.from.php.this.allowed={0}。從 PHP {1} 起才允許這樣。
intention.name.make.abstract=將{0}設為 abstract
inspection.message.expression.without.parentheses=表達式沒有括號
add.clarifying.parentheses=添加澄清括號
replace.all.occurrences.with.php=將所有符合項取代為 '<?php'
inspection.message.parentheses.are.unnecessary=圓括號不必要
remove.unnecessary.parentheses=移除不必要的圓括號
inspection.message.goto.labels.inside.loops.or.switch.statements.are.not.allowed=不允許在迴圈或 switch 語句中使用 'goto' 標籤
dialog.title.configure.code.patterns=配置程式碼模式…
intention.family.name.generate.phpdoc.comment=生成 PHPDoc 註釋
intention.family.name.copy.phpdoc.from.parent=從父項複製 PHPDoc
inspection.message.constant.reassignment=常數重新賦值
merge.with.0.branch=與 ''{0}'' 分支合併
inspection.message.use.statement.with.non.compound.name.ref.has.no.effect=包含非復合名稱 '#ref' 的 'use' 語句沒有任何作用
insert.default.branch=插入 'default' 分支
inspection.message.tostring.method.must.return.string='__toString' 方法必須返回字串
inspection.message.psr.compound.namespace.with.depth.more.than.two.levels=PSR-12: 復合命名空間的深度超過兩級
psr.12.extract.namespace=PSR-12: 提取命名空間
inspection.message.psr.short.form.type.keywords.should.be.used=PSR-12: 應當使用類型關鍵字的縮寫
psr.12.convert.to.short.form=PSR-12: 轉換為縮寫
inspection.message.psr.missing.visibility.definition=PSR-12: 缺少可見性定義
psr.12.add.public.visibility=PSR-12: 添加 'public' 可見性
inspection.message.psr.order.modifiers.incorrect=PSR-12: 修飾符的順序不正確
psr.12.fix.modifiers.order=PSR-12: 修復修飾符順序
inspection.message.psr.missing.parameter.list=PSR-12: 缺少參數列表
psr.12.add.missing.parameter.list=PSR-12: 添加缺少的參數列表
inspection.message.psr.usage.else.if.construct=PSR-12: 使用 'else if' 結構
inspection.message.psr.traits.must.be.included.one.per.line=PSR-12: 必須以每行一個的形式添加特徵
psr.12.split.to.several.use.statements=PSR-12: 拆分為多個 'use' 語句
inspection.message.psr.usage.var=PSR-12: 'var' 的用法
psr.12.replace.var.with.public=PSR-12: 將 'var' 取代為 'public'
change.method.modifiers.to.0=將方法修飾符更改為 ''{0}''
intention.family.name.remove=移除 {0}
create.new.class.quickfix=創建新類
add.class1=添加類
intention.name.suppress.for.statement=對語句禁止
intention.name.change.cast.to=將 {0} 轉換更改為 {1}
intention.name.cast.to=將 {0} 轉換為 {1}
add.fluent.setter=添加 fluent setter
intention.family.name.add.getter.setter=添加 getter 和 setter
intention.family.name.add.getter=添加 getter
intention.family.name.add.number.separators=添加數字分隔符
convert.the.arrow.function.to.a.traditional.closure=將箭頭函數轉換為傳統閉包
intention.name.extract.if=提取 if ({0})
intention.family.name.initialize.properties=初始化屬性
merge.into.elseif=合併到 'elseif' 中
intention.family.name.replace.switch.with.if=將 'switch' 取代為 'if'
make.01=設為 ''{0}''
group.use.statements.by.selected.prefix=按所選前綴將 'use' 語句分組
intention.family.name.convert.heredoc.nowdoc.to.string.literal=將 HEREDOC/NOWDOC 轉換為字串文字
intention.family.name.convert.heredoc.to.string.literal=將 HEREDOC 轉換為字串文字
intention.family.name.convert.nowdoc.to.string.literal=將 NOWDOC 轉換為字串文字
convert.concatenation.to.sprintf.call=將串聯轉換為 'sprintf()' 調用
convert.string.interpolation.to.concatenation=將字串插值轉換為串聯
convert.string.interpolation.to.sprintf.call=將字串插值轉換為 'sprintf()' 調用
intention.name.convert.sprintf.call.to.concatenation=將 'sprintf()' 調用轉換為串聯
copy.concatenated.string.to.clipboard=將串聯的字串複製到剪貼簿
extract.selected.string.part.as.concatenation.operand=將所選字串部分作為串聯操作數提取
extract.selected.string.part.as.format.function.argument=將所選字串部分作為格式函數實參提取
surround.with.if.0.1=使用 ''if({0}({1}))'{'...'}''' 環繞
command.name.new.file=新建檔案
dialog.title.inline.variable=內聯變數
property.declaration=屬性宣告
class.constructor=類構造函數
label.global.namespace=<全域命名空間>
cannot.use.positional.argument.after.named.argument=無法在命名實參後面使用位置實參
named.parameter.overwrites.previous.argument=命名參數覆寫以前的實參
unknown.named.parameter=未知命名參數 ''{0}''
docker.compose.border.title.lifecycle=生命周期
action.configuration.text=配置…
inspection.message.constructor.cannot.be.static=構造函數不能為 static
inspection.message.destructor.cannot.be.static=析構函數不能為 static
inspection.message.clone.method.cannot.be.static='Clone' 方法不能為 static
inspection.message.cannot.make.non.abstract.method.abstract=無法將非 abstract 方法設為 abstract
inspection.message.cannot.override.final.method=無法覆寫 final 方法
inspection.message.cannot.make.method.visibility.lower.than.super.s=無法將方法的可見性設為低於父級的可見性
parsing.error.not.allowed=不允許使用 ''{0}''
parsing.error.unexpected.token=意外的標記: {0}
parsing.error.expression.not.assignable=表達式不可賦值
live.template.name.comment=註釋
php.remote.debug.name=PHP 遠端調試
php.web.application.name=PHP Web 套用程序
live.template.name.statement=語句
live.template.name.string.literal=字串文字
live.template.name.expression=表達式
cli.interpreters.name=CLI 解釋器
code.style.option.group.use=將 'use' 分組
code.style.option.attributes=特性
code.style.option.parameter.attributes=參數特性
code.style.option.in.namespace=在命名空間中
code.style.option.php.opening.tag=PHP 起始標記
code.style.option.new.line.after.php.tag=在 '<?php' 標記後換行
code.style.option.align.inline.comments=對齊內聯註釋
code.style.option.function.return.type=函數返回類型
code.style.option.return.type.on.new.line=返回類型位於新行中
code.style.option.align.key.value.pairs=對齊鍵值對
code.style.option.match.expression='match' 表達式
code.style.option.match.expression.align.match.arm.bodies=對齊 'match' arm 主體
code.style.option.place.on.new.line=將 ';' 置於新行中
code.style.option.class.field.constant.groups=類屬性/常數組
code.style.option.align.properties.in.columns=對齊列中屬性
code.style.option.align.constants=對齊常數
code.style.option.align.consecutive.assignments=對齊連續賦值
code.style.option.keep.and.on.one.line=將 ')' 和 '{' 保持在同一行
code.style.option.for.foreach.statements=for()/foreach() 語句
code.style.option.place.for.constructor=放置構造函數的 '()'
code.style.option.in.anonymous.class.declaration=在匿名類宣告中
code.style.option.function.constructor.call.arguments=函數/構造函數調用實參
code.style.option.function.declaration.parameters=函數宣告參數
code.style.option.in.closure.declaration=在閉包宣告中
code.style.option.in.function.declaration=在函數宣告中
code.style.option.place.on.new.line2=在最後一個元素後換行
code.style.option.new.line.after=在第一個元素後換行
code.style.option.after='{' 之後:
code.style.option.before.return.statement=在 'return' 語句前:
code.style.option.after.function=函數之後:
code.style.option.after.opening.tag=起始標記之後:
code.style.option.between.group.use.statements=在 'Use' 語句組之間:
code.style.option.around.class.constants=環繞類常數:
code.style.option.after.class.body=類主體之後:
code.style.option.before.class.body=類主體之前:
code.style.option.after.use.statements=在 'Use' 語句後:
code.style.option.before.use.statements=在 'Use' 語句前:
code.style.option.after.namespace=命名空間之後:
code.style.option.before.namespace=命名空間之前:
code.style.option.around.property=環繞屬性:
code.style.option.multiplicative.operators=乘法運算符(*, /, %, **)
code.style.option.arrow.function.parentheses=箭頭函數括號
code.style.option.anonymous.function.parentheses=匿名函數括號
code.style.option.shift.operators=移位運算符(<<,>>)
code.style.option.and=<?= 和 ?>
code.style.option.brackets.around.variable.expression=使用中括號將變數/表達式括起來
code.style.option.between.and='?' 與 ':' 之間
code.style.option.unary.additive.operators=一元加法運算符(+,-,++,--)
code.style.option.after.unary.not=一元非(!)之後
code.style.option.before.unary.not=一元非(!)之前
code.style.option.array.initializer.parentheses=陣列初始值設定項圓括號
code.style.option.function.left.brace=函數左大括號
code.style.option.function.declaration.parentheses=函數宣告括號
code.style.option.function.call.parentheses=函數調用括號
code.style.option.after.colon.in.return.type=返回類型中的冒號之後
code.style.option.space.around.pipe.in.union.types=聯合類型的 | 周圍
code.style.option.before.colon.in.return.type=返回類型中的冒號之前
code.style.option.before.colon.in.named.argument=命名實參中的冒號之前
code.style.option.after.colon.in.named.argument=命名實參中的冒號之後
code.style.option.assignment.in.declare.statement=在 declare 語句中賦值
code.style.option.null.coalescing.operator=null 合併運算符(??)
code.style.option.object.access.operator=物件存取運算符(->)
code.style.option.concatenation=串聯(.)
code.style.option.relational.operators=關係運算符(<, >, <=, >=, <=>)
link.label.languages.frameworks.php=PHP
inspection.message.cannot.make.static.method.non.static=無法將 static 方法 {0} 設為非 static
inspection.message.cannot.make.non.static.method.static=無法將非 static 方法 {0} 設為 static
dialog.title.select.properties.to.initialize=選擇要初始化的屬性
split.selected.group.use.statement=拆分所選 'use' 語句組
intention.family.name.convert.string.literal.to.heredoc.nowdoc=將字串文字轉換為 HEREDOC/NOWDOC
intention.name.convert.string.literal.to.heredoc=將字串文字轉換為 HEREDOC
intention.name.convert.string.literal.to.nowdoc=將字串文字轉換為 NOWDOC
intention.name.convert.concatenation.to.string.interpolation=將串聯轉換為字串插值
intention.name.convert.concatenation.to.scalar.value=將串聯轉換為標量值
intention.name.convert.sprintf.call.to.string.interpolation=將 'sprintf()' 調用轉換為字串插值
intention.name.convert.sprintf.call.to.scalar.value=將 'sprintf()' 調用轉換為標量值
parsing.error,at.expected=應為 '@'
parsing.error.method.label.expected=應為方法標籤
live.template.class.member=類成員
live.template.interface.member=接口成員
live.template.trait.member=特徵成員
dialog.error.title.php.extract.class=PHP 提取類
quality.tools.label.by.default.project.interpreter=預設為專案解釋器
file.0.does.not.exist=檔案 {0} 不存在
languages.frameworks.php.php.runtime=PHP / PHP 執行時
do.not.ask.again=不再詢問
enable.support=啟用支援
validating1=正在驗證…
cache.creating=正在創建 psalm 快取…
can.not.parse.phpunit.version.output.0=無法解析 PHPUnit 版本輸出: {0}
zend.debugger.settings.broadcasting.is.already.launched=Zend Debugger 設定廣播已啟動
directories=目錄
can.not.run.command.composer.execution.plugin.was.unloaded=無法執行命令: Composer 執行套件已移除
can.not.find.specified.interpreter=找不到指定的解釋器
no.response.from.0.after.1.ms={1} ms 後 {0} 未響應
cannot.register.handler=無法註冊處理程序
handler.with.the.same.session.id.is.already.registered=已註冊使用相同會話 ID 的處理程序
unknown.debugger.type=未知調試器類型
functions.to.be.extracted=要提取的函數
failed.to.parse.php.ini.output.0=無法解析 php --ini 輸出: {0}
can.not.find.0.helper.script=找不到 ''{0}'' 幫助程序腳本
can.not.execute.tests=無法執行測試
failed.to.run.interpreter=無法執行解釋器
failed.to.find.interpreter=無法尋找解釋器
set=設定
proxy.init=代理初始化
register.ide=註冊 IDE
0.for.1.run.configuration={1} 執行配置的 {0}
project.is.already.disposed=專案已處置
can.not.execute.transfer.task.project.is.already.disposed=無法執行傳輸任務: 專案已處置
proxy.stop=代理停止
cancel.ide.registration=取消 IDE 註冊
getting.installed.standards=正在獲取已安裝的標準…
php.remote.interpreter.plugin.is.not.installed=PHP Remote Interpreter 套件未安裝
execution.result.is.null=執行結果為 null
can.not.delete.temporary.file.because.it.was.not.created=無法刪除臨時檔案，因為未創建該檔案
0.inspection={0} 檢查
failed.to.find.valid.interpreter.path=無法尋找有效的解釋器路徑
with.data.set.0=使用資料集 {1} 的 {0}
add.phpunit.test.pattern=添加 PHPUnit 測試模式
unused.code.rules=未使用的程式碼規則
naming.rules=命名規則
design.rules=設計規則
controversial.rules=有爭議的規則
code.size.rules=程式碼大小規則
remote.interpreter.can.t.be.executed.please.enable.the.php.remote.interpreter.plugin=無法執行遠端解釋器。啟用 PHP Remote Interpreter 套件。
create.target.class.quick.fix=創建目標類快速修復
create.missing.target.method.fix=創建缺少的目標方法修復
php.extract.class=PHP 提取類
local=本地
project.files=專案檔案
include.path=include 路徑
inspection.message.parameter.name.changed.from.to=參數名稱由 ''{0}'' 更改為 ''{1}''
intention.family.name.rename.parameter.to.match.super=重命名參數以符合父級
intention.name.rename.to=重命名為 ''{0}''
inspection.message.name.parameter.may.be.different.depending.on.instance.class=在 ''{0}.{1}'' 中可能未解析命名實參
tooltip.update=更新 {0}
inspection.message.constant.ref.not.found=未找到常數 '#ref'
hint.text.can.not.find.target.class.for.modification=找不到要修改的目標類。
hint.text.target.class.not.writable=目標類 {0} 不可寫。
hint.text.target.class.does.not.belong.to.project.can.not.be.modified=目標類 {0} 不屬於該專案\\\\n\\\\
並且無法修改。
inspection.message.cannot.make.non.abstract.method.abstract.1=無法將非 abstract 方法 {0} 設為 abstract
inspection.message.cannot.override.final.method.1=無法覆寫 final 方法 {0}
inspection.message.return.type.declaration.must.be.compatible.with=返回類型宣告必須與 {0} 相容: {1}
inspection.message.cannot.make.method=無法將 {0} 方法設為 {1} {2}
inspection.message.declaration.should.be.compatible.with=宣告應該與 {0} 相容
inspection.message.declaration.should.be.compatible.with.super=宣告應與父級相容
command.name.make.method.static=將方法設為 static
show.constants=顯示常數
show.properties=顯示屬性
show.includes=顯示 include
show.private.members=顯示 private 成員
show.protected.members=顯示 protected 成員
undefined.interpreter=未定義的解釋器
column.name.annotation.name=註解名稱
inspection.message.exception.never.thrown.in.corresponding.try.block=相應的 ''try'' 塊中從未拋出異常 ''{0}''
dialog.title.edit.phpunit.test.pattern=編輯 PHPUnit 測試模式
notification.title.incorrect.profiler.snapshot.format=分析器快照格式不正確
notification.title.cannot.read.snapshot=無法讀取快照
label.lt.no.server=<no server>
executable.0.was.not.found.in.path.please.make.sure.it.s.there.possible.solutions=在 %PATH% 中找不到可執行檔案 ''{0}''。請確保已指定有效路徑。可能的解決方案:
if.you.ve.changed.the.path.recently.restart.the.ide=如果最近更改了 %PATH%，請重啟 IDE。
provide.the.full.path.to.executable=提供可執行檔案的完整路徑。
select.composer.phar.and.provide.the.full.path.to.it.or.select.download.composer.stable.phar.from.getcomposer.org=選擇 'composer.phar' 並提供其完整路徑，或者選擇“從 getcomposer.org 下載 composer-stable.phar”。
executable.0.was.not.found.in.path.please.make.sure.it.s.there.possible.solutions1=在 $PATH 中找不到可執行檔案 ''{0}''。請確保已指定有效路徑。可能的解決方案:
if.you.ve.changed.the.path.recently.restart.the.ide1=如果最近更改了 $PATH，請重啟 IDE。
select.composer.phar.and.provide.the.full.path.to.it.or.select.download.composer.stable.phar.from.getcomposer.org1=選擇 'composer.phar' 並提供其完整路徑，或者選擇“從 getcomposer.org 下載 composer-stable.phar”。
label.authentication.data.not.specified=未指定身份驗證資料
configured.is.incorrect=配置的 {0} 不正確
validation.script.was.created.but.it.cannot.be.executed.check.possible.reasons=驗證腳本已創建，但無法執行。可能的原因:
validated.web.server.is.not.running=驗證的 Web 伺服器未執行。
target.directory.for.validation.script.is.not.public=驗證腳本的目標目錄不是 public。
url.to.validation.script='驗證腳本的 URL'
follow.this.links.to.install.and.configure.0.or.1=點擊這些鏈接以安裝並配置 {0} 或 {1}。
if.you.have.already.configured.debug.extension.in.php.ini.file.check.possible.reasons.why.it.was.not.loaded=如果已在 php.ini 檔案中配置調試擴展，請檢查未載入該擴展的可能原因:
you.did.not.reload.web.server.after.changes.in.php.ini.file=在 php.ini 檔案中進行更改後，未重新載入 Web 伺服器。
you.are.configuring.debug.extension.in.the.wrong.php.ini.see.the.loaded.php.ini.files.below=您正在錯誤的 php.ini 中配置調試擴展(請參見下方已載入的 php.ini 檔案)。
there.are.errors.on.attempt.to.load.debug.extension.e.g.version.incompatibility=嘗試載入調試擴展時出錯，例如版本不相容。
intention.name.change.signature=更改 {0}({1}) 的簽名
dialog.title.enter.tag.name=輸入標記名稱
method1=方法
open.inspection.settings=打開 {0} 檢查設定
popup.content.enabled.disabled.extensions=已啟用{0}和已禁用{1}擴展
popup.content.configuration.remains.unchanged=當前配置與解釋器同步
unhandled.0=未處理的{0}
unhandled.exceptions=未處理的異常
label.docker.container=Docker 容器:
dialog.message.docker.account.not.specified=未指定 Docker 帳戶
dialog.message.docker.account.not.found=找不到 Docker 帳戶
dialog.message.could.not.find.network.interface=找不到 {0} 網絡接口
dialog.message.no.interface.addresses.for.network.interface=沒有 {0} 網絡接口的接口地址
validation.script.will.be.created.in.0.directory=驗證腳本將在 {0} 目錄中創建。
files.in.the.directory.should.be.accessible.by.0.request=目錄中的檔案應當可通過 {0} 請求進行存取。
caused.by.0=原因是:“{0}”
validation.script.will.be.created.in.0.directory.and.deployed.to.the.1.server=驗證腳本將在 {0} 目錄中創建並部署到 {1} 伺服器。
files.in.the.remote.directory.should.be.accessible.by.0.request=遠端目錄中的檔案應當可通過 {0} 請求進行存取。
follow.this.0.for.more.information.about.path.mappings=有關路徑映射的詳細資訊，請參閱{0}。
validation.script.will.be.created.locally.and.the.result.will.be.fetched.by.http.request=驗證腳本將在本地創建，其結果將通過 http 請求提取。
validation.script.will.be.created.locally.and.deployed.to.the.remote.server=驗證腳本將在本地創建並部署到遠端伺服器。
the.result.of.validation.will.be.fetched.by.http.request=驗證結果將通過 http 請求提取。
follow.this.0.for.more.information.about.deployment=有關部署的詳細資訊，請參閱此{0}。
link=鏈接
no.type=NO_TYPE
in=位於
action.configure.php.runtime.text=配置 PHP 執行時…
action.configure.project.directories.text=配置專案目錄
inspection.message.interpolated.string.dereferencing.available.in.php.only=從 PHP 8.0 起才允許插值字串解引用
inspection.message.magic.constant.dereferencing.available.in.php.only=從 PHP 8.0 起才允許魔術常數解引用
intention.family.name.add.name.identifiers.to.all.arguments.starting.from.current=從當前位置開始將名稱關鍵字添加到所有實參
intention.name.add.name.identifier=添加名稱關鍵字 ''{0}''
inspection.message.argument.without.name.identifier=無名稱關鍵字的實參
tooltip.wsl2.mappings=WSL2 映射
name=名稱
file=檔案
tooltip.from=來自{0}:
tooltip.from.volumes=來自{0}卷:
intention.family.name.sort.arguments=對實參排序
open.tool.settings=打開 {0} 設定
init.cache=初始化快取
or.disable.inspection=或
inspection.message.type.can.be.reduced.to=類型範圍可以限縮為 ''{0}''
an.alias.was.defined.for.method.0.which.exists.in.1=已為 {1} 中的方法 {0}() 定義別名
intention.family.name.append.absolute.trait=追加 ''{0}::''
intention.family.name.remove.argument.name=移除實參名稱
intention.name.remove.argument.names.from.all.arguments.up.to.current=從截止到當前位置的所有實參中移除實參名稱
frameworl.composer.show.quick.actions=顯示具有快速操作的 composer.json 頂部面板
framework.composer.notify.about.missing.vendor=缺少 'vendor' 目錄時通知
cannot.make.interface.method.non.static=無法將接口方法設為非 static
cannot.make.interface.method.static=無法將接口方法設為 static
access.must.be.public=存取必須為 public
inspection.message.method.reference.resolves.to.method.with.containing.class=''Use'' 規則解析為包含類 ''{0}'' 中的方法
intention.name.move.trait.use.rule.to.use.list=將特徵 ''use'' 規則移動到 ''{0}'' ''use'' 列表
intention.family.name.move.trait.use.rule.to.resolved.class.use.list=將特徵 'use' 規則移動到解析的類 'use' 列表
required.trait.0.wasn.t.added.to.1=所需特徵 ''{0}'' 未添加到 ''{1}''
intention.family.name.add.trait.to.use.list=將特徵添加到 use 列表
intention.name.add.trait.to.use.list=將特徵 ''{0}'' 添加到 use 列表
intention.family.name.add.break.as.last.statement=將 'break' 作為最後一條語句添加
inspection.message.class.does.not.have.attribute=類 ''{0}'' 未使用 ''Attribute'' 註解
intention.family.name.add.attribute.attribute=使用 'Attribute' 註解
constant.expression.contains.invalid.operations=常數表達式包含無效運算
attribute.must.be.first.child.of.parent.element=特性必須是父元素的第一個子項
intention.family.name.move.attribute.to.start.element=將特性移動到元素開頭
quickfix.remove.match.arm=移除 'match' arm
quickfix.remove.duplicate.condition=移除重複條件
quickfix.remove.unused.condition=移除未使用的條件
inspection.duplicate.match.condition.message=重複條件
inspection.message.attribute.can.t.be.applied.to.because.it.doest.contains=特性不能應用於 {0}，因為它不包含 ''{1}'' 標誌
inspection.message.attribute.is.not.repeatable=特性不可重複，因為它不包含 'Attribute::IS_REPEATABLE' 標誌
class2=類
class.constant1=類常數
property=屬性
parameter1=參數
inspection.message.comment.will.be.parsed.as.attribute.starting.with.php=從 PHP 8.0 起註釋被解析為特性
intention.family.name.insert.space.after=在 '#' 後面插入一個空格
inspection.message.condition.is.never.matched=條件從未符合
inspection.php.arithmetic.type.check=帶有不支持操作數的算術運算
introduce.variable.fix=引入變數
hint.text.use.statement.choice.s.removed={0} ''use'' 語句{1, choice, 0#|1#}已移除
hint.text.use.statements.checked.nothing.was.removed=已檢查 {0} ''use'' 語句，未移除任何內容
no.name=無名稱
debugger.method=方法
inspection.message.named.argument.usage=命名實參用法
percentage.lines={0}% 行
column.name.parameter=參數
column.name.file.directory=檔案/目錄
unknown=未知
intention.family.name.replace.with.get.class.call=取代為 'get_class()' 調用
intention.family.name.replace.with.class.name.literal=取代為 '::class'
inspection.message.get.class.call.can.be.replaced.with.class.name.literal='get_class()' 調用可以取代為 '::class'
intention.family.name.remove.parenthesis=移除圓括號
inspection.message.redundant.parenthesis=冗餘圓括號
intention.family.name.simplify.expression=簡化表達式
intention.family.name.replace.match.with.ternary=取代為三元表達式
attribute.can.be.added.to.overridden.method=可以將特性添加到覆寫方法
attribute.can.be.added.to.overridden.parameter=可以將特性添加到覆寫參數
intention.family.name.add.attribute.to.overridden.method=將特性添加到覆寫方法
intention.family.name.add.attribute.to.overridden.method.of.abstract.method=將特性添加到抽象方法的覆寫方法
intention.family.name.add.attribute.to.overridden.parameter=將特性添加到覆寫參數
inspection.message.match.can.be.replaced.with.ternary='match' 表達式可以取代為三元表達式
intention.family.name.replace.with.traditional.property.declaration=取代為傳統屬性宣告
cannot.declare.promoted.property.outside.a.constructor=無法在構造函數外部宣告提升的屬性
only.visibility.modifiers.can.be.applied.to.promoted.property=只能將可見性修飾符套用到提升的屬性
intention.family.name.replace.with.public=取代為 'public'
cannot.declare.variadic.promoted.property=無法宣告可變提升屬性
cannot.declare.promoted.property.in.an.abstract.constructor=無法在 abstract 構造函數中宣告提升的屬性
inspection.message.promoted.field.usage=提升的屬性用法
inspection.message.redundant.assignment=冗餘的提升屬性賦值
remove.assignment=移除賦值
inspection.message.switch.can.be.replaced.with.match='switch' 語句無法轉換為 'match' 表達式
intention.family.name.replace.switch.with.match.expression=將 'switch' 取代為 'match' 表達式
intention.family.name.split.into.multiple.catch.statements=拆分為多個 'catch' 語句
exception.class=異常類
variable1=變數
identifier=關鍵字
field.name=欄位名稱
object.property=物件屬性
class.reference=類引用
array.index=陣列索引
line.separator=行分隔符
initializer=初始值設定項
label1=標籤
expression1=表達式
type=類型
static.value=static 值
property.or.function=屬性或函數
default.value=預設值
extends=擴展
interface.name=接口名稱
extends.or.implements=擴展或實作
class.name=類名
modifier=修飾符
return.type=返回類型
inspection.message.duplicates.catch.statement=重複 ''{0}'' 語句
intention.name.merge.with=與 ''{0}'' 合併
intention.family.name.merge.with.duplicated.catch.statement=與重複的 'catch' 語句合併
intention.name.merge.with.match.arm=與 ''{0}'' arm 合併
intention.family.name.merge.with.duplicated.match.arm=與重複的 'match' arm 合併
intention.family.name.add.default.match.arm=添加 'default' 'match' arm
intention.family.name.add.attribute=添加 ''#[{0}]''
inspection.message.exitpoint.attribute.can.be.added=可以添加 #[NoReturn] 特性
intention.family.name.convert.to.promoted.field=轉換為提升的屬性
intention.family.name.convert.to.promoted.field.remove.doc.comment=轉換為提升的屬性並移除屬性 PHPDoc 註釋
inspection.message.field.assignment.can.be.converted.to.promoted.field=可以提升屬性
cannot.use.unpacking.in.attribute.argument.list=無法在特性實參列表中使用解包
spread.operator.on.named.arguments.is.forbidden=禁止對命名實參使用展開運算符
inspection.message.should.be.one=值應為以下選項之一: {0}
0.by.remote.interpreter=通過遠端解釋器{0}
0.local={0}本地
inspection.message.double.quotes.are.unnecessary=雙引號不必要
inspection.php.unnecessary.double.quotes.display.name=不必要的雙引號
inspection.php.unnecessary.leading.backslash.in.use.statement='use' 語句中有不必要的前導 '\\\\'
replace.unnecessary.double.quotes=取代不必要的雙引號
quality.tool.can.not.create.temporary.file=PhpStorm 無法創建臨時檔案
dialog.message.cannot.create.file.because.project.already.disposed=由於專案已處置，無法創建檔案
dead.code.commented.out=註釋掉
dead.code.deleted=已刪除
intention.family.name.add.arrayshape.attribute=添加 '#[ArrayShape]' 特性
inspection.message.arrayshape.can.be.added=可以添加 '#[ArrayShape]'
inspection.option.label.php8.severity=PHP 8 嚴重性:
inspection.message.pure.can.be.added=可以添加 ''{0}''
intention.name.add.to.parameter=將 ''\\\\\\\\&'' 添加到參數 ''{0}''
intention.family.name.add.to.parameter=將 '\\\\\\\\&' 添加到參數
inspection.message.array.write.access.unused=未使用陣列寫入存取
intention.family.name.remove.pure=移除 '#[Pure]'
inspection.message.function.may.produce.side.effects=函數可能會產生副作用
inspection.message.method.may.produce.side.effects=方法可能會產生副作用
inspection.message.immutable.property.write.scope.does.not.allow.write.access.here=無效的不可變屬性寫入: 作用域 ''{0}'' 不允許在此處進行寫入存取
php.console=PHP 控制台
inspection.message.illegal.array.offset.access=嘗試存取類型為 ''{0}'' 的值的陣列偏移
attributes.are.inapplicable.for.constants=特性不適用於常數
intention.family.name.replace.with.define.call=取代為 'define()' 調用
inspection.message.leading.slash.in.constant.fqn.will.not.be.trimmed.by.php=PHP 不會修剪常數 FQN 中的前導斜杠
intention.family.name.remove.leading=移除前導 '\\\\'
intention.family.name.replace.with.const.syntax=取代為 'const' 語法
inspection.message.can.be.replaced.with.const.syntax=可以取代為 'const' 語法
intention.family.name.force.fqcn.for.references.in.phpdoc=對 PHPDoc 中的引用強制 FQCN
constants.may.only.evaluate.to.scalar.values.arrays.or.resources=常數只能計算為標量值、陣列或資源
intention.family.name.merge.with.following.attribute.list=將特性列表與以下內容合併
intention.family.name.extract.attribute.into.separate.list=將特性提取到單獨的列表
intention.family.name.flip.attributes.lists=翻轉特性列表
inspection.message.too.many.messages.per.line=每行的訊息過多
inspection.message.too.many.messages.per.file.only.first.errors.warnings.are.shown=每個檔案中的訊息過多。僅顯示前 {0} 條。
can.not.correctly.run.the.tool.with.parameters=無法使用參數正確執行該工具:
possible.tool.process.hangup.after.0.sec={0} 秒後可能工具過程掛起。
inspection.message.write.access.to.variable.that.still.references.array.value=對仍引用 'foreach' 中先前所用陣列值的變數的寫入權限
if.with.common.parts=具有通用部分的 'if'
switch.with.common.parts=包含通用部分的 'switch'
intention.family.name.insert.unset.before=在前面插入 ''unset(\${0});''
intention.family.name.collapse.if.statement=摺疊 ''{0}'' 語句
intention.family.name.extract.common.parts.with.removing.branch=提取通用部分，並移除分支
intention.family.name.extract.common.parts=提取通用部分
inspection.message.if.statement.with.common.parts=包含通用部分的 ''{0}'' 語句
intention.name.replace.with=將 ''{0}'' 取代為 ''{1}''
inspection.message.property.only.written.but.never.read=屬性僅寫入，但從未讀取
inspection.message.property.only.read.but.never.written=屬性只讀取，但從未寫入
intention.family.name.delete.field=刪除屬性
intention.family.name.replace.with.class.constant=取代為類常數
invalid.condition.to.body.separator.should.be.used=條件與主體之間的分隔符無效: 應改用 '=>'
intention.family.name.invert.if.statement=反轉 'if' 語句
intention.family.name.unwrap.else=解開 'else'
inspection.message.unnecessary.else=不必要的 'else'
inspection.message.array.always.empty.at.this.point=陣列在此點始終為空
intention.family.name.can.be.merged.with.sequential=''if'' 可以與後續 ''{0}'' 合併
intention.family.name.merge.with.sequential=與後續 ''{0}'' 合併
inspection.message.behavior.unparenthesized.expressions.containing.both.will.change.in.php=同時包含 ''.'' 和 ''{0}'' 的無括號表達式可能會產生意外結果
intention.name.wrap.left.operand.in.parentheses=在圓括號中包裝左操作數
intention.name.wrap.right.operand.in.parentheses=在圓括號中包裝右操作數
parameter.type.is.not.convertible.from.null=參數類型不可從 'null' 轉換
inspection.message.value.parameter.always=參數值始終為 ''{0}''
intention.family.inline.value.for.parameter=內聯參數值
intention.name.inline.value=內聯值 ''{0}''
inspection.message.can.be.replaced.with.version=表達式可以取代為 '??' 版本
inspection.message.if.can.be.replaced.with.version='if' 可以取代為 '??' 版本
intention.family.name.replace.with.version=取代為 '??' 版本
intention.family.name.replace.with.ternary.expression=取代為三元表達式
popup.title.multiple.write.scopes.found=找到多個寫入範圍
closest.scope=最近範圍中的變數
all.values=所有變數
checkbox.rename.only.nearest.scope=僅重命名最近範圍中的變數
intention.family.name.make.method.void=將方法設為 'void'
inspection.message.return.value.method.never.used=方法的返回值從未使用
inspection.message.unnecessary.leading.slash=不必要的前導 '\\\\'
inspection.message.cast.redundant=類型轉換冗餘
inspection.message.unnecessary.curly.braces=不必要的大括號
intention.family.name.unwrap.curly.braces=解開大括號
command.name.disable.synchronisation.with.composer=禁用與 composer.json 同步
navigate.to.composer.json=導航到 composer.json
notification.content.language.level.synchronisation.with.composer.was.disabled=已禁用與 composer.json 的語言級同步
inspection.message.can.be.replaced.with.direct.parameter.access='func_get_arg' 可以取代為直接參數存取
intention.family.name.replace.with.parameter.access=取代為參數存取
intention.family.name.unwrap.function.call=解開函數調用
inspection.message.with.single.string.argument=帶單個字串實參的 ''{0}''
inspection.message.for.loop.can.be.replaced.with.str.repeat='for' 迴圈可以取代為 'str_repeat'
intention.family.name.replace.with.str.repeat.call=取代為 'str_repeat()' 調用
inspection.message.for.loop.can.be.replaced.with.implode='foreach' 迴圈可以取代為 'implode()'
intention.family.name.replace.with.implode.call=取代為 'implode()' 調用
intention.family.name.unwrap.cast=解開轉換
inspection.message.unnecessary.cast.to.string=不必要地轉換為 ''{0}''
intention.family.name.merge.with.assignment=與賦值合併
inspection.message.concatenation.can.be.merged.with.assignment.empty.string.literal=串聯可以與空字串文字賦值合併
inspection.message.operands.have.incompatible.types=操作數具有不相容的類型
short.arrow.function.cannot.return.void=箭頭函數不能有 'void' 返回類型
delete.void.return.type=刪除 'void' 返回類型
array.callback.must.have.exactly.two.elements=陣列回調必須正好有兩個元素
intention.family.name.split.into.separate.case.statements=拆分為獨立的 'case' 語句
invalid.syntax.for.multiple.case.expressions=多個 'case' 表達式的語法無效
cannot.mix.keyed.and.unkeyed.array.entries.in.assignments=在賦值中不能混合鍵控和非鍵控陣列條目
cannot.use.empty.array.entries.in.keyed.array.assignment=在鍵控陣列賦值中不能使用空陣列條目
cannot.use.empty.list=無法使用空列表
unsupported.declare.0=不支持的宣告 ''{0}''
inspection.message.continue.targeting.switch.equivalent.to.break=針對 'switch' 的 'continue' 相當於 'break'
inspection.message.redundant.expression=冗餘表達式
strict.types.declaration.must.have.0.or.1.as.its.value='strict_types' 宣告的值必須為 0 或 1
private.methods.cannot.be.final=private 方法不能是 final，因為它們從不會被其他類覆寫
cannot.use.yield.from.inside.a.by.reference.generator=不能在引用傳遞生成器中使用 'yield from'
intention.family.name.replace.with.check=取代為 '!==' 檢查
dialog.title.select.methods.to.propagate.safe.delete=選擇要傳播安全刪除的方法
dialog.title.select.parameters.to.propagate.safe.delete=選擇要傳播安全刪除的參數
referenced.calls=引用的調用
cannot.mix.and.list=不能混合 [] 與 list()
intention.family.name.replace.with.array=取代為數組
intention.family.name.replace.with.list=取代為 'list'
inspection.message.can.be.replaced.with=可以取代為 ''{0}''
intention.family.name.remove.unused.postfix.operation=移除未使用的後綴運算
inspection.message.results.postfix.expression.unused=未使用後綴表達式的結果
intention.family.name.add.doc.tag.with.throws.tags=使用 @throws 標記添加 PHPDoc 註釋
replace.variable.assignment.with.named.argument=將變數賦值取代為命名實參
action.run.composer.install.text=執行 'composer install'
notification.content.vendor.directory.not.found=未找到 'vendor' 目錄
intention.family.name.move.from.to.composer.json.section=將 ''{0}'' 從 ''{1}'' 移至 ''{2}'' composer.json 部分
intention.family.name.flip=翻轉 '?:'
inspection.message.can.be.removed=可以移除 ''{0}''
intention.family.name.remove.unused.property=移除未使用的屬性
intention.family.name.simplify.ternary.expression=簡化 '?:'
inspection.message.should.probably.not.be.passed.as.parameter=''{0}'' 可能不應作為參數 ''{1}'' 傳遞
inspection.message.should.probably.not.be.assigned=''{0}'' 可能不應分配給 ''{1}''
extract.method.selector.title=要提取的程式碼
intention.family.name.replace.with.operator=取代為 '?->' 運算符
inspection.message.can.be.replaced.with.operator=可以取代為 '?->' 運算符
add.throw.before.exception=在表達式前面添加 'throw'
intention.family.name.replace.with.dirname.call=取代為 'dirname()' 調用
inspection.php.redundant.method.override=冗餘方法覆寫
inspection.php.loop.can.be.replaced.with.implode=迴圈可以取代為 'implode()'
inspection.message.redundant.method.override=方法覆寫冗餘
delete.redundant.method.override=移除方法
intention.family.name.replace.if.with.version=將 'if' 取代為 '??' 版本
anonymous.class=匿名類
anonymous.0=匿名{0}
lambda=Lambda
checkbox.anonymous.classes=匿名類
checkbox.lambdas=Lambda
inspection.message.trait.usage=不允許特徵用法
inspection.message.will.be.covered.by=非必要條件，因為它由 ''{0}'' 檢查
inspection.message.can.be.replaced.with.fail=可以取代為 ''{0}''
intention.name.replace.coalesce.expression.with.operand=將合併表達式取代為操作數
intention.name.replace.coalesce.expression.with=將合併表達式取代為 ''{0}''
label.align.named.arguments=對齊命名實參
delete.catch.statement=刪除 'catch' 語句
inspection.message.exception.immediately.rethrown=立即重新拋出異常
inspection.message.dangerous.array.initialization=危險的陣列初始化
replace.with.array=取代為直接賦值 '$array = array($value)'
intention.family.name.replace.with.comparison=取代為比較
quickfix.undefined.function.add.function=添加函數
PhpLanguageLevel.8.1.0.presentable.name=8.1
PhpLanguageLevel.8.1.0.short.description=枚舉、'never' 返回類型、交叉類型、'readonly' 屬性
PhpLanguageFeature.enum.classes=從 PHP 8.1 起才允許使用枚舉
annotation.new.expression.enum=無法實例化枚舉 ''{0}''
enum.may.not.include.0=枚舉不得包含 ''{0}''
enum.may.not.include.extend=枚舉不得擴展其他類
enums.may.not.include.properties=枚舉不得包含屬性
enums.may.not.be.cloned=不得克隆枚舉
intention.family.name.make.containing.class.enum=將包含類設為枚舉
enum.properties.are.immutable=枚舉屬性不可變
enum.backing.type.must.be.int.or.string=枚舉支援類型必須為 'int' 或 'string'
enum.case.type.0.does.not.match.enum.backing.type.1=枚舉 case 類型 ''{0}'' 與枚舉支援類型 ''{1}'' 不符合
all.cases.of.backed.enum.must.have.a.value=備用枚舉的所有 case 必須包含值
case.of.non.backed.enum.must.not.have.a.value=非備用枚舉的 case 不得包含值
intention.family.name.delete.initializer=刪除初始值設定項
intention.family.name.add.to.containing.enum=將 '' : {0}'' 添加到包含枚舉
intention.family.name.remove.backed.type.from.containing.enum=從包含枚舉中移除備用類型
enum.case.should.be.located.only.inside.enum.classes=枚舉 case 只應位於枚舉類內部
enum.case.value.must.be.constant=枚舉 case 值必須為常數
enum.backing.type.must.be.int.or.string.0.given=在給出 ''{0}'' 的情況下，枚舉支援類型必須為 ''int'' 或 ''string''
code.style.option.before.colon.in.enum.backed.type=在備用枚舉中類型宣告旁邊的冒號前面
code.style.option.after.colon.in.enum.backed.type=在備用枚舉中類型宣告旁邊的冒號後面
enum.case=枚舉 case
enums.may.not.implement.the.serializable.interface=枚舉可能不會實作 'Serializable' 接口
cannot.redeclare.methods.from.enum.implicit.interfaces=無法從枚舉隱式接口重新宣告方法
cannot.implement.interface.0=無法實作接口 ''{0}''
cannot.implement.interface.0.directly=無法直接實作接口 ''{0}''
non.enum.class.cannot.implement.interface=非枚舉類無法實作接口 ''{0}''
non.backed.enum.cannot.implement.interface.backedenum=非備用枚舉無法實作接口 'BackedEnum'
intention.family.name.count.comments.as.content=將註釋計為內容
inspection.php.class.constant.accessed.via.child.class=通過子類引用的類常數
inspection.message.constant.from.base.class.referenced.via.child.class=通過子類引用的基類 ''{0}'' 中的常數
intention.family.name.replace.with.class.reference.with.base.class=取代為對基類的類引用
intention.replace.with.method.call=取代為對現有方法的調用
inspection.php.uncovered.enum.cases=某些 enum case 未被覆蓋
inspection.message.uncovered.enum.cases='match' 表達式具有未被覆蓋的 enum case
intention.family.name.add.remaining.enum.cases=添加剩餘 enum case
add.enum.declaration.quick.fix.text=添加枚舉 case
intention.family.name.split.into.two.separate.match.arms=將條件提取到單獨的 'match' arm
multiple.enum.identifiers.should.be.stated.in.different.cases=多個枚舉關鍵字應在不同的 case 中宣告
replace.with.array.short.syntax=取代為直接賦值 '$array = [$value]'
intention.family.name.split.into.multiple.enum.cases=拆分為多個枚舉 case
inspection.message.uncovered.enum.cases.switch='switch' 語句有未被覆蓋的枚舉 case
inspection.php.unused.switch.case.inspection.display.name=未使用的 'switch' 分支
inspection.message.branch.is.unused=從不執行 'switch' 分支
inspection.php.enum.case.with.value.not.found=枚舉中找不到包含指定值的 case
inspection.message.not.valid.backing.value.for.enum={0} 不是枚舉的有效支援值
intention.name.add.enum.case.with.value=添加具有 ''{0}'' 值的枚舉 case
inspection.php.empty.index.operator.not.supported.for.strings.display.name=字串不支持的空索引運算符
inspection.php.empty.index.operator.not.supported.for.strings=字串不支持 '[]' 運算符
intention.family.name.replace.with.concatenation=取代為串聯
intention.family.name.remove.empty.index.operator=移除 '[]' 運算符
refactoring.move.class.action.name = 移動類…
refactoring.move.namespace.action.name=移動命名空間…
refactoring.move.constant.action.name=移動常數…
refactoring.move.function.action.name=移動函數…
refactoring.inline.function.cannot.inline.magic.method=無法內聯魔術方法
refactoring.inline.function.cannot.inline.constructor=無法內聯構造函數
inspection.missing.doc.comment.options.panel.ignore.private.members=忽略 private 成員
code.style.option.place.braces.for.constructor.as.is=保留原樣
code.style.option.place.braces.for.constructor.always=始終
code.style.option.place.braces.for.constructor.never=從不
settings.smart.keys.auto.insert.semicolon=在函數調用內部鍵入時自動插入分號 
inspection.php.foreach.over.single.element=對只有一個元素的陣列文字執行 Foreach
intention.family.name.unwrap.foreach=解開 'foreach'
inspection.message.foreach.over.array.literal.with.single.element=對只有一個元素的陣列文字執行 ‘foreach’
inspection.php.condition.can.be.replaced.with.min.max.call=條件可以取代為 'min()'/'max()' 調用
inspection.message.can.be.replaced.with.min.max.call=可以取代為 ''{0}'' 調用
intention.family.name.replace.with.min.max.call=取代為 'min()'/'max()' 調用
intention.name.replace.with.min.max.call=取代為 ''{0}'' 調用
quickfix.navigate.to.duplicate.case.value=導航到重複的 case 值
duplicate.value.in.enum.for.cases.0.and.1=case ''{0}'' 和 ''{1}'' 的枚舉中的重複值
inspection.php.idempotent.operation=二進制表達式中的冪等運算
inspection.message.expression.not.changed.after.applying=套用 ''{0}'' 後，表達式不會改變
inspection.php.array.push.with.single.element=只有一個元素的 'array_push()'
inspection.message.array.push.with.single.element=只有一個元素的 'array_push'
unwrap.switch=解開 switch…
inspection.switch.with.single.case=只有一個 'case' 的 'switch'
inspection.message.switch.has.only.default.case=switch 只有 'default' case
inspection.message.switch.has.only.single.case=switch 只有一個 case
intention.family.name.replace.with.if=取代為 'if'
PhpLanguageFeature.return.never=自 PHP 8.1 起才允許使用返回類型 'never'
classes.named.never.is.forbidden.in.php.8.1=PHP 8.1 中禁止名為 'never' 的類
inspection.php.never.typed.function.returning.value='never' 類型的函數返回一個值
never.can.only.be.used.as.return.type='never' 只能用作返回類型
inspection.message.never.returning.function.must.not.return='never' 返回函數不得返回
delete.case=刪除 'case'
inspection.php.internal.array.index.reset.is.unnecessary=無需陣列內部指針重置
inspection.php.enforce.doc.comment.inspection.display.name=強制執行 PHPDoc 註釋
remove.unnecessary.reset=移除不必要的 'reset'
refactoring.inline.function.cannot.inline.overridden.method=無法內聯被覆寫的方法
intention.family.name.replace.with.array.assignment=取代為數組賦值
inspection.php.array.search.can.be.replaced.with.in.array='array_search()' 可取代為 'in_array()' 調用
intention.family.name.replace.with.in.array.call=取代為 'in_array()' 調用
inspection.message.can.be.replaced.with.in.array.call=可以取代為 ''{0}'' 調用
inspection.php.preg.match.without.regular.expression='preg_match' 可取代為 'str_contains'
inspection.message.can.be.replaced.with.str.function=可以取代為 ''{0}''
intention.family.name.replace.with.str.function.call=取代為 ''{0}'' 調用
inspection.php.group.regexp=正則表達式
PhpLanguageFeature.final.class.constants=自 PHP 8.1 起只允許使用 'final' 類常數
intention.family.name.replace.in.array.with.disjunction=將 'in_array()' 取代為 '||'
intention.message.replace.in.array.with.disjunction=將 ''in_array()'' 取代為 ''{0}''
intersection.types.and.the.nullable.type.notation.cannot.be.mixed=交叉類型和可 null 類型表示法不能混用
cannot.mix.amp.and.pipe.in.type.declaration=類型宣告中不能混用 '\\\\\\\\&' 和 '|'
PhpLanguageFeature.intersection.types=從 PHP 8.1 起才允許交叉類型
intention.family.name.evaluate.cast=取代為 ''{0}''
intention.name.evaluate.cast=評估轉換
inspection.message.cast.evaluable=轉換可取代為 ''{0}''
inspection.php.cast.is.evaluable=對標量值進行類型轉換
cannot.use.readonly.as.identifier=無法將 'readonly' 用作關鍵字。自 PHP 8.1 起作為預留關鍵字
PhpLanguageFeature.readonly.properties=從 PHP 8.1 起才允許使用 'readonly' 屬性
PhpLanguageFeature.new.in.init=從 PHP 8.1 起才允許在初始值設定項中使用 'new'
globals.can.only.be.modified.using.the.globals.name.value.syntax='$GLOBALS' 只能使用 '$GLOBALS[$name] = $value' 語法進行修改
inspection.php.match.can.be.replaced.with.switch.statement='match' 可取代為 'switch' 語句
inspection.message.match.can.be.replaced.with.switch='match' 表達式可轉換為 'switch' 語句。
intention.family.name.replace.match.with.switch.statement=將 'match' 取代為 'switch' 語句
intention.family.name.replace.match.with.switch.statement.changing.semantics=將 'match' 取代為 'switch' 語句(可能會改變比較語意)
PhpLanguageFeature.explicit.octal.literal=自 PHP 8.1 起只允許顯式八進制文字
inspection.php.acessing.static.trait.members=正在存取 static 特徵成員
inspection.message.calling.static.trait.member=不推薦直接調用 static 特徵成員。它只能在使用特徵的類上訪問。
intention.family.name.replace.with.self.access=取代為 'self::' 存取
inspection.message.returning.by.reference.from.void.function.deprecated=不推薦從 void 函數通過引用返回
intention.family.name.collapse.statement.into.parameter.default.value=將語句摺疊到參數的預設值中
inspection.message.statement.can.be.collapsed.into.parameter.default.value=語句可以摺疊到參數的預設值中
label.successors=後繼
label.predecessors=前驅
inspection.php.covered.element.in.class=類中的元素已覆蓋
inspection.message.element.already.covered.by=''{0}'' 已被 ''{1}'' 覆蓋
intention.family.name.delete.covered.element=刪除已覆蓋的元素
inspection.php.ranges.in.class.can.re.merged=類中的範圍可以合併
inspection.message.can.be.merged.with=可以與 ''{0}'' 合併
intention.family.name.merge.with.adjustment.range=與調整後的範圍合併
intention.name.prepend.default.case=預置 'default'
popup.title.select.target.code.block=選擇目標程式碼塊
popup.select.target.code.block.closure=箭頭函數體(轉換為閉包)
popup.select.target.code.block.containing.block=包含塊
refactoring.inline.function.cannot.find.function.declaration=找不到函數宣告
private.constant.cannot.be.final='private' 常數不能為 'final'，因為它對其他類不可見
cannot.override.final.constant=無法從 ''{1}'' 覆蓋 final 常數 ''{0}''
intention.family.name.replace.with.implicit.octal.notation=取代為隱式八進制表示法
inspection.message.match.can.be.replaced.with.switch.changing.semantics='match' 表達式可以轉換為 'switch' 語句。請注意，'switch' 語句依賴於鬆散比較，這可能會改變表達式語意。
php.intention.category=PHP
inspection.php.deprecated.stdlib.call=已棄用的標準庫調用
inspection.message.argument.with.type.deprecated.for.this.call=此調用不推薦使用類型為 ''{0}'' 的實參
inspection.message.call.without.arguments.deprecated=不帶實參的 ''{0}'' 調用已棄用
inspection.php.array.index.immediately.rewritten=陣列索引會被立即覆寫
intention.family.name.navigate.to.rewrite.expression=導航到覆寫表達式
inspection.message.array.index.immediately.rewritten.before.accessing=陣列索引在存取之前會被立即覆寫
inspection.php.implicit.octal.literal.can.be.replaced.with.explicit.one=隱式八進制文字可以取代為顯式文字
inspection.message.replace.implicit.octal.literal.with.explicit.one=隱式八進制文字可以取代為顯式文字
inspection.family.name.replace.implicit.octal.literal.with.explicit.one=將隱式八進制文字取代為顯式八進制文字
inspection.php.object.fields.are.only.written=局部物件僅用於寫入屬性
inspection.message.local.object.used.only.for.writing.properties=局部物件僅用於寫入屬性
inspection.php.redundant.array.call.in.foreach.iterated.value=對 'foreach' 中迭代的值的冗餘 'array_values' 調用
intention.family.name.replace.with.argument=取代為實參
inspection.message.array.values.call.redundant='array_values' 調用冗餘
readonly.property.must.have.type=唯讀屬性必須指定類型
inspection.php.unit.assert.always.execute.to.same.result='assertTrue()' 的實參類型不相容
inspection.message.assert.always.will.be.false=實參類型不相容，因為 'assertTrue()' 執行與 'true' 的嚴格比較
expected.property=屬性
inspection.array.to.string.conversion=陣列到字串的轉換
inspection.message.array.to.string.conversion=陣列到字串的轉換
inspection.php.invalid.string.offset.usage=字串偏移用法無效
inspection.message.cannot.use.string.offset.as.object=無法將字串偏移用作物件
inspection.message.cannot.use.assign.op.operators.with.string.offsets=無法將組合運算符賦值與字串偏移一起使用
inspection.message.cannot.unset.string.offsets=無法取消設定字串偏移
inspection.message.cannot.increment.decrement.string.offsets=無法遞增/遞減字串偏移
inspection.message.cannot.create.references.to.from.string.offsets=無法創建到/從字串偏移的引用
inspection.message.cannot.use.string.offset.as.array=無法將字串偏移用作陣列
intention.inline.method.family.name=內聯方法
inspection.message.cannot.assign.empty.string.to.string.offset=無法將空字串分配給字串偏移
inspection.message.only.first.byte.will.be.assigned.to.string.offset=只有第一個位元組將被分配給字串偏移
static.property.cannot.be.readonly='static' 屬性不能為 'readonly'
inspection.message.second.write.to.readonly.property=無法修改 'readonly' 屬性
inspection.php.second.write.to.readonly.property=第二次寫入 'readonly' 屬性
inspection.php.unnecessary.spread.operator.for.function.call.argument=函數調用實參的展開運算符不必要
inspection.message.spread.operator.can.be.unwrapped=展開運算符可以解開
inspection.message.spread.operator.over.literal.unnecessary.for.arguments.resolved.to.variadic.parameter=對於解析為可變參數的實參，文字上的展開運算符不必要
intention.family.name.unwrap.spread.operator=解開展開運算符
inspection.message.write.access.to.readonly.property.outside.declaration.scope=無法寫入宣告範圍之外的 'readonly' 屬性
inspection.php.write.access.to.readonly.property.outside.declaration.scope=對宣告範圍之外的 'readonly' 屬性的寫入權限
build.control.flow.with.exit.points=使用出口點構建控制流(&E)
inspection.message.comment.can.be.replaced.with.named.argument=註釋可以取代為命名實參
intention.family.name.replace.with.named.argument=取代為命名實參
inspection.message.can.be.replaced.with.named.argument=可以取代為命名實參
PhpLanguageFeature.first.class.callable.syntax=僅在 PHP 8.1 之後的版本中才允許一級可調用語法
intention.family.name.replace.with.closure.fromCallable=取代為 'Closure::fromCallable(...)'
cannot.create.closure.for.new.expression=無法為 'new' 表達式創建 'Closure'
replace.with.arrow.function=取代為箭頭函數
replace.with.anonymous.function=取代為匿名函數
label.interpreter=解釋器: {0}
cannot.combine.nullsafe.operator.with.closure.creation=無法將 nullsafe 運算符與 'Closure' 創建組合
replace.with.coalesce.operator=取代為合併運算符
intention.family.name.initialize.property.in.constructor=初始化構造函數中的屬性
inspection.php.field.immediately.rewritten=屬性會被立即覆寫
inspection.message.field.immediately.rewritten.before.accessing=屬性在存取之前會被立即覆寫
inspection.redundant.intersection.type=冗餘的交叉點類型
inspection.redundant.intersection.type.fix=交叉點類型可以簡化為 ''{0}''
inspection.redundant.intersection.type.fix.name=簡化交叉點類型
anonymous.function=匿名函數
expected.expression.after.spread.operator=預期: 展開運算符後的表達式
action.com.jetbrains.php.internal.PhpCreateYoutrackIssueFromFileAction.text=在 WI (PhpStorm) 專案中根據檔案內容創建 YouTrack 問題
action.com.jetbrains.php.internal.PhpCreateYoutrackIssueFromSelectionAction.text=在 WI (PhpStorm) 專案中根據所選內容創建 YouTrack 問題
inspection.php.nested.min.max.call=嵌套的 'min/max' 調用
inspection.message.nested.call.can.be.unwrapped=嵌套的 ''{0}'' 調用可以解開
intention.family.name.unwrap.call=解開調用
type.0.cannot.be.part.of.an.intersection.type=類型 ''{0}'' 不能是交叉點類型的一部分
inspection.closure.can.be.converted.to.first.class.callable='Closure::fromCallable()' 可以轉換為一級可調用語法
inspection.php.closure.can.be.converted.to.first.class.callable.inspection.display.name='Closure::fromCallable()' 可以轉換為一級可調用語法
replace.with.first.class.callable.family.name=取代為一級可調用語法
inspection.php.duplicate.character.in.str.function.call=函數調用中的重複字符
inspection.message.duplicate.character=重複字符
quickfix.remove.condition.from.default.arm=從 'default' arm 中移除非 'default' 條件
annotator.only.default.condition.allowed='default' arm 中僅允許單個 'default' 條件
inspection.php.autovivification.on.false.values='false' 到陣列的自動轉換已棄用
inspection.message.write.access.to.readonly.property.outside.declaration.scope.ret.by.ref='readonly' 屬性通過引用返回，可能會泄漏到宣告範圍之外
inspection.message.array.key.unused=陣列密鑰未使用
refactoring.inline.variable.unary.operation=無法內聯到遞減或遞增操作
inspection.message.variable.already.equal.to.assigned.value=變數已等於賦值
inspection.php.modulo.operation.with.one=以 '1' 為操作數的取模運算
intention.family.name.replace.with.zero=取代為 ''{0}''
inspection.message.expression.always.choice=表達式始終為 ''{0}''
intention.family.name.replace.with.compile.time.result=取代為編譯時結果
inspection.php.deprecated.serializable.interface.usage.inspection.display.name='Serializable' 接口用法已棄用
class.implements.the.serializable.interface.which.is.deprecated=不推薦在不使用 '__serialize()'/'__unserialize()' 方法的情況下實作 'Serializable' 接口
add.serialize.magic.methods=添加 {0} 方法
add.serialize.magic.method=添加 {0} 方法
refactoring.move.classes.dnd.name=移動類
refactoring.move.classes.dnd.title=將所選的{0,choice,0#類|1#命名空間|2#類和命名空間}移動到命名空間:
group.advanced.settings.php=PHP
advanced.setting.php.max.chain.resolve.depth=解析成員引用的最大深度
function.has.parameter.with.incompatible.default.value.type=函數有一個其預設值與其宣告的類型不相容的參數
inspection.php.unit.deprecated.call.in.phpunit.10=方法在 PHPUnit 10 中已棄用
intention.family.name.replace.with.suggested.call.in.phpunit=取代為 PHPUnit 10 中建議的調用
inspection.message.function.deprecated.will.be.removed.in.phpunit=方法已棄用並已在 PHPUnit 10 中移除
code.style.option.force.empty.functions.braces.in.one.line=將空函數/方法的大括號放在一行
inspection.php.autovivification.on.false.values.possible=可能會導致將 'false' 轉換為數組，這一轉換已棄用
php.change.signature.conflict.with.local.var=參數 ''{0}'' 與函數 ''{1}'' 內的局部變數衝突
php.change.signature.conflict.with.local.var.method=參數 ''{0}'' 與來自 ''{2}'' 的方法 ''{1}'' 內的局部變數衝突
refactoring.move.classes.dnd.files.with.the.same.name.error=單個目標中不允許有多個同名檔案。
dialog.message.execution.quality.tools.in.untrusted.project.prohibited=禁止在不受信任的專案中執行品質工具
untrusted.composer.dialog.text=正在安裝或更新依賴項，或者執行 Composer 命令可能會執行潛在的惡意程式碼。\\\\n\\\\
\\\\n\\\\
如果不信任此源，請保持在安全模式下。
inspection.undefined.field.notify.dynamic.read=通知對動態屬性的讀取權限
inspection.php.too.long.member.reference.chain=成員引用鏈過長，無法分析
php.test.framework.untrusted.reload=在安全模式下禁止刷新測試框架的版本
inspection.message.instanceof.checks.in.catch.can.be.replaced.with.specific.catches='catch' 塊中的 'instanceof' 檢查可以取代為特定的 catch
inspection.php.instanceof.checks.in.catch.can.be.replaced.with.specific.catches='catch' 塊中的 'instanceof' 檢查可以取代為特定的 catch
intention.family.name.replace.instanceof.checks.in.catch.with.specific.catches=將 'catch' 塊中的 'instanceof' 檢查取代為特定的 catch
no.in.line.parameter.name.hints.will.be.shown.for.methods.matching.any.of.these.patterns=對於符合其中任一模式的方法，都不會顯示任何嵌入參數名稱提示。
patterns.are.matched.on.fully.qualified.name.parameter.count.and.parameter.names=模式會通過完全限定名稱、參數計數和參數名稱進行符合。
you.can.always.add.a.precise.exclusion.via.alt.enter.and.then.edit.it.to.broaden.as.needed=您始終可以通過 Alt-Enter 組合鍵添加精確排除，然後根據需要對其進行編輯以擴大範圍。
code.global.code.matches.function.with.two.parameters={0} 符合帶有兩個參數的函數。
code.info.code.matches.all.single.parameter.methods.where.the.parameter.name.ends.with.em.info.em={0} 符合參數名以 {1} 結尾的所有單參數方法。
code.key.value.code.matches.all.methods.with.parameters.em.key.em.and.em.value.em={0} 符合所有具有參數 {1} 和 {2} 的方法。
code.fully.qualified.classname.methodname.key.value.code.example.precise.match={0} 是一個精確排除的範例。
key=密鑰
value=值
info=資訊
inspection.php.if.can.be.replaced.with.match.expression='if' 可以取代為 'match' 表達式
intention.family.name.replace.if.with.match.expression=將 'if' 取代為 'match' 表達式
inspection.message.can.be.replaced.with.match.expression='if' 語句可以取代為 'match' 表達式
inspection.php.duplicate.operand.in.comparison=比較中的重複操作數
intention.family.name.remove.duplicate.operand=移除重複操作數
inspection.message.expression.have.duplicate.operand=表達式有重複的操作數 {0}
refactoring.inline.function.cannot.inline.first.class.callable.declaration=無法內聯第一類可調用宣告
php.replace.try.from.with.null.quick.fix.family.name=用 'null' 取代 'tryFrom()' 調用
replace.all.occurrences.without.side.effects=取代所有符合項，無副作用
inspection.php.class.constant.can.be.final=類常數可為 'final'
inspection.message.can.be.final=可為 'final'
intention.family.name.make.final=設為 'final'
inspection.php.array.append.using.count=使用 'count()' 作為索引將值追加到陣列
inspection.message.count.used.as.array.index.to.append.element='count' 用作陣列索引以追加元素
inspection.php.pointless.boolean.expression='if' 條件內的無意義布爾表達式
intention.name.simplify.to=簡化為 ''{0}''
inspection.message.pointless.boolean.expression=可以簡化布爾表達式
inspection.php.rand.arguments.in.revers.order=順序錯誤的 'rand' 函數實參
inspection.message.max.must.be.greater.than.or.equal.to.argument.min='max' 實參必須大於或等於 'min'
quickfix.change.field.type.to.match.super.0=將類型更改為 ''{0}'' 以匹配父項
quickfix.change.field.type.to.match.super.remove=移除類型宣告以符合父項
inspection.message.readonly.property.non.readonly=無法將 'readonly' 屬性重新宣告為非 'readonly'
inspection.message.non.readonly.property.readonly=無法將非 'readonly' 屬性重新宣告為 'readonly'
intention.family.name.remove.readonly.modifier=移除 'readonly' 修飾符
intention.family.name.add.readonly.modifier=添加 'readonly' 修飾符
inspection.php.unit.invalid.mocking.target=無效的模擬目標
inspection.message.methods.cannot.be.mocked=''{0}'' 方法無法模擬
final=final
enum=枚舉
inspection.message.classes.cannot.be.doubled=''{0}'' 類無法重複
inspection.message.cannot.stub.or.mock.using.method.list.that.contains.duplicates=不能使用包含重複項的方法列表進行存根或模擬
intention.family.name.navigate.to.duplicate.method.name=導航到重複的方法
inspection.php.property.can.be.readonly=屬性可為 'readonly'
inspection.message.property.can.be.readonly=屬性可為 'readonly'
text.plain=文本/純
enum.value.cannot.referer.to.enum.cases=枚舉值不能引用枚舉 case
inspection.php.internal.array.index.reset.is.unnecessary.navigate.to.function=導航到重置陣列內部指針的函數
inspection.php.pow.call.can.be.replace.with.pow.operator='pow()' 調用可取代為 '**' 運算符
replace.with.pow.operator=取代為 '**' 運算符
group.methods.by.type=按類型對方法分組
inspection.php.private.method.may.be.inaccessible.in.late.static.binding.call=Private method may be inaccessible during late static binding call
inspection.message.existing.overriding.private.method.may.be.inaccessible=Existing overriding private method may be inaccessible
inspection.message.existing.overriding.private.method.may.be.inaccessible.method=Overriding private method ''{0}'' may be inaccessible
intention.family.name.navigate.to.possibly.inaccessible.methods=Navigate to possibly inaccessible methods
overriding.private.methods=Overriding private methods
refactoring.inplace.extract.method.name=Inplace Extract Function/Method
PhpExtractMethodDialog.generate.php.doc.inplace=生成 PHPDoc
extract.method.link.label.more.options=更多選項"
`;

exports[`dev messages/SvnBundle.properties 1`] = `
"subversion.executable.notification.title=無法使用 Subversion 命令行客戶端
subversion.executable.notification.description=Subversion 可執行檔案的路徑可能是錯誤的。
subversion.executable.too.old=Subversion 命令行客戶端版本過舊({0})。

subversion.roots.detection.errors.found.description=檢測 svn 工作副本時發現錯誤。
subversion.roots.detection.errors.found.action.text=修復

#Actions&Plugin info
action.Subversion.BrowseSVNRepository.text=瀏覽 Subversion 版本庫(_W)…
action.Subversion.BrowseSVNRepository.description=瀏覽 Subversion 版本庫
group.SubversionFilePopupGroup.text=Subversion(_S)
group.IgnoreChoicesGroup.text=忽略
group.RevertIgnoreChoicesGroup.text=從忽略列表中移除
action.Subversion.UndoIgnore.text=所選文件名
action.Subversion.UndoIgnore.description=從資料夾忽略列表中移除文件名/遮罩
action.Subversion.Ignore.ExactMatch.text=所選文件名
action.Subversion.Ignore.ExactMatch.description=將所有所選檔案的名稱添加到資料夾忽略列表
action.Subversion.Ignore.MatchExtension.description=將 {0} 遮罩添加到資料夾忽略列表
action.Subversion.SetProperty.text=設定屬性(_T)…
action.Subversion.SetProperty.description=在檔案或目錄中設定版本化屬性
action.Subversion.ShowProperties.text=編輯屬性(_P)
action.name.show.properties=顯示屬性
action.Subversion.PropertiesView.AddProperty.text=添加屬性
action.Subversion.PropertiesView.AddProperty.description=添加新屬性
action.Subversion.PropertiesView.EditProperty.text=編輯屬性
action.Subversion.PropertiesView.EditProperty.description=編輯選定屬性值
action.Subversion.PropertiesView.EditKeywords.text=編輯關鍵字
action.Subversion.PropertiesView.EditKeywords.description=管理 svn:keywords 屬性
action.Subversion.PropertiesView.DeleteProperty.text=刪除屬性
action.Subversion.PropertiesView.DeleteProperty.description=刪除選定屬性
action.Subversion.PropertiesView.FollowSelection.text=跟隨選擇
action.Subversion.PropertiesView.FollowSelection.description=跟隨選擇
action.Subversion.PropertiesView.Refresh.text=刷新
action.Subversion.PropertiesView.Refresh.description=重新載入屬性
action.Subversion.PropertiesView.Close.text=關閉
action.Subversion.PropertiesView.Close.description=關閉此工具視窗
toolwindow.stripe.SVN_Properties=SVN 屬性
column.name.property.name=名稱
column.name.property.value=值
error.can.not.set.property=無法設定屬性: {0}
dialog.title.svn.keywords=SVN 關鍵字
label.select.keywords.to.set=選擇要設定的關鍵字:
action.Subversion.Resolve.text=解決文本衝突(_S)…
action.Subversion.Resolve.description=解決檔案中的文本衝突
action.Subversion.MarkResolved.text=標記為已解決(_M)…
action.Subversion.MarkResolved.description=將文本和屬性衝突標記為已解決
action.Subversion.Clenaup.text=清理(_E)
action.Subversion.Clenaup.description=解鎖鎖定的目錄，並執行其餘所有未完成的操作
action.Subversion.Copy.text=分支或標記(_B)…
action.Subversion.Copy.description=將選定的檔案或目錄複製到新的版本庫位置
action.Subversion.Lock.text=鎖定(_L)…
action.Subversion.Lock.description=鎖定檔案
action.Subversion.Unlock.text=解鎖(_O)
action.Subversion.Unlock.description=解鎖檔案
action.name.refresh=刷新
action.Subversion.ImportToSVNRepository.text=匯入 Subversion(_M)…
action.Subversion.Share.text=共享目錄(_S)…
action.Subversion.ConfigureBranches.text=配置分支…
action.Subversion.CompareWithBranch.text=與分支比較…
action.Subversion.Relocate.text=重定位…
action.Subversion.Relocate.description=將工作副本重定位到其他 URL
action.Subversion.CleanupProject.text=清理專案
action.Subversion.CleanupProject.description=對專案中的所有工作副本目錄執行清理
action.Svn.Show.Working.Copies.text=顯示工作副本
action.Svn.Show.Working.Copies.description=顯示工作副本資訊：工作副本格式和 URL
action.Svn.RefreshWorkingCopies.text=刷新
action.Svn.RefreshWorkingCopies.description=刷新工作副本資訊
action.EditCommitMessage.text=編輯修訂註釋
action.EditCommitMessage.description=編輯修訂註釋。覆寫上一條訊息。
action.Subversion.ShareWholeProject.text=共享專案(Subversion)…

#New Remote Folder dialog
dialog.title.new.remote.folder=新建遠端資料夾
label.remote.folder.url=遠端資料夾 URL:
label.remote.folder.name=遠端資料夾名稱:
label.commit.message=提交訊息:
label.recent.messages=最近的訊息:
value.new.folder.name=NewFolder
button.copy=複製
action.new.remote.folder.text=新建遠端資料夾…

#Copy dialog
dialog.title.branch=創建分支或標記
label.copy.from=複製自
label.copy.to=複製到
label.copy.from.revision=修訂(&V):
label.branch.base.url=基 URL:
label.branch.name=名稱:
value.new.branch.name=new_branch
tooltip.use.project.location=使用專案位置
radio.copy.working.copy=工作副本(&W)
radio.copy.repository.location=版本庫位置(&R):
radio.copy.to.branch.or.tag=分支或標籤
radio.copy.to.any.location=任何位置
label.copy.comment=&註釋
label.copy.select.location.dialog.copy.as=複製為(&A):
notification.content.branches.load.error=分支載入錯誤: {0}
progress.title.checking.target.folder=正在檢查目標資料夾
dialog.message.repository.path.does.not.exist=版本庫路徑 ''{0}'' 不存在。要創建它嗎?
dialog.title.select.working.copy.location=選擇工作副本位置
label.select.location.to.copy.from=選擇要從中複製的位置:
dialog.message.branch.name.is.empty=分支名稱為空
dialog.message.invalid.branch.name=分支名稱無效
dialog.message.invalid.branch.url=分支 url 無效
dialog.message.no.branch.base.location.selected=未選擇分支基位置
dialog.message.invalid.revision=修訂無效
dialog.message.invalid.repository.location=版本庫位置無效
checkbox.switch.to.newly.created.branch.or.tag=將 {0} 切換到新建的分支或標記
error.can.not.find.url.for.file=找不到檔案的 url: {0}
error.can.not.find.working.copy.for.file=找不到檔案的工作副本: {0}
progress.title.svn.branches.preloader=Subversion 分支預載入程序

#Relocate dialog
dialog.title.relocate.working.copy=重新定位工作副本
label.from.url=源 URL:
label.to.url=目標 URL:
dialog.message.error.relocating.working.copy=重定位工作副本時出錯: {0}
progress.title.relocating.working.copy=正在重定位工作副本

#Lock dialog
dialog.title.lock.files=鎖定檔案
dialog.title.lock.file=鎖定檔案
label.lock.comment=鎖定註釋(&L):
label.locl.steal.existing=竊取現有鎖(&S):

label.ssh.key.file=密鑰檔案(&F):
label.ssh.passphrase=密碼短語(&R):

label.ssl.certificate.path=證書路徑:
label.ssl.certificate.password=證書密碼短語:
checkbox.ssl.keep.for.current.session=儲存憑證(&S)

progress.text.create.remote.folder=創建遠端資料夾
dialog.title.error=錯誤

#Repository Browser
progress.text.deleting=正在刪除 {0}
progress.title.browser.delete=刪除
progress.text.browser.creating=正在創建 {0}
progress.text.browser.moving=正在移動 {0}
progress.text.browser.copying=正在拷貝{0}
progress.text.browser.remote.destination=到 {0}
progress.title.browser.move=移動
progress.title.browser.copy=複製
dialog.message.could.not.parse.url=無法解析 url
dialog.title.changes.in.url={0} 中的變更
action.Subversion.RepositoryBrowser.Checkout.text=簽出(_C)…
dialog.title.svn.repository.browser=SVN 版本庫瀏覽器
action.Subversion.RepositoryBrowser.CompareWith.text=比較物件…
dialog.message.confirm.move.folder=您即將移動名稱為 ''{0}'' 的資料夾。是否確定?
action.Subversion.RepositoryBrowser.CopyUrl.text=複製 URL…
action.Subversion.RepositoryBrowser.Export.text=匯出(_E)…
dialog.title.import.directory=匯入目錄
label.select.directory.to.import.into.repository=選擇要匯入版本庫的目錄
dialog.title.destination.directory=目標目錄
label.select.checkout.destination.directory=選擇簽出目標目錄
label.select.export.destination.directory=選擇匯出目標目錄
progress.title.loading.child.entries=正在載入子條目
dialog.title.svn.import.options=SVN 匯入選項
dialog.title.svn.export.options=SVN 匯出選項
dialog.title.export.directory=匯出目錄
label.select.directory.to.export.from.subversion=選擇要從 Subversion 匯出的目錄
dialog.title.svn.delete=SVN 刪除
label.source.url=源 URL:
label.target.location=目標位置:
label.target.name=目標名稱:
label.target.url=目標 URL:
label.export=匯出:
checkbox.replace.existing.files=取代現有檔案
label.destination=目標:
checkbox.include.externals.locations=包括外部項位置
label.override.native.eols.with=覆寫 'native' EOL 的選項:
combobox.crlf.none=無
checkbox.include.ignored.resources=包含忽略的資源
label.import.from=匯入自:
label.import.to=匯入到:
label.repositories=版本庫:
label.point.to.repository.location=指向版本庫位置
dialog.title.select.share.target=選擇共享目標
button.share=共享
label.define.share.target=定義共享目標
radio.share.target.at.selected.repository.location=在所選版本庫位置
radio.share.target.in.new.folder=在所選版本庫位置的新 \\"{0}\\" 資料夾中
checkbox.create.tags.branches=創建 /tags 和 /branches
separator.commit.comment.prefix=提交註釋前綴
toolwindow.stripe.SVN_Repositories=SVN 版本庫

#authentication
label.auth.authentication.realm=身份驗證領域: ''{0}''
label.auth.user.name=用戶名(&U):
label.auth.password=密碼(&P):
checkbox.auth.keep.for.current.session=儲存憑證(&S)
dialog.title.authentication.required=需要身份驗證
notification.content.unknown.certificate.type.from.url=Subversion: {0} 中的證書類型未知
notification.content.authentication.failed=身份驗證失敗: {0}
popup.content.already.checking=正在檢查…
progress.title.svn.roots.authorization.checker=SVN VCS 根授權檢查器
progress.title.looking.for.file.working.copy.root=正在尋找 ''{0}'' 工作副本根
progress.text.clearing.stored.credentials=正在清除 {0} 中存儲的憑證
notification.title.not.logged.into.subversion=未登錄到 Subversion
notification.content.not.logged.into.subversion=未登錄到 Subversion ''{0}'' ({1})
notification.action.click.to.fix=點擊以修正。
progress.title.clear.authentication.cache=清除身份驗證快取(&C)
label.specify.ssl.protocol.manually=請嘗試手動指定 SSL 協議 - SSLv3 或 TLSv1
popup.content.failed.to.authenticate.to.proxy.change.credentials=代理驗證失敗。您可以在 HTTP 代理設定中更改代理憑證。
popup.content.failed.to.authenticate.to.proxy=代理驗證失敗。
error.server.ssl.certificate.rejected=伺服器 SSL 證書被拒

#history
progress.text2.collecting.history=正在收集 ''{0}'' 的修訂歷史記錄
checkbox.changes.filter.filter.by.author=作者(&U):
progress.text2.processing.revision=正在處理修訂 ''{0}''
progress.text.changes.collecting.changes=正在收集有關變更的資訊
progress.text2.changes.establishing.connection=正在建立與 ''{0}'' 的連接
progress.text2.revision.processed=已處理修訂 ''{0}''
action.Subversion.ShowMergeSourceDetails.text=顯示合併原始碼詳細資訊
action.Subversion.ShowIntegratePanel.text=顯示集成面板
progress.title.loading.working.copies.data=Subversion: 正在載入工作副本資料…
progress.title.edit.revision.comment=編輯修訂註釋
tab.title.edit.revision.comment=編輯修訂註釋
progress.title.getting.latest.repository.revision=正在獲取最新的版本庫修訂
notification.content.revision.commit.message.changed.to=修訂 #{0} 註釋更改為:\\\\n\\\\
''{1}''
column.name.merge.sources=合併原始碼
status.text.merge.sources=合併原始碼
label.no.subversion.1.5.working.copies=此專案中沒有 1.5 版本庫的 Subversion 1.5 工作副本
label.merge.from.url=從:
label.merge.to.branch=到:
label.mixed.revision.working.copy=混合修訂工作副本
label.select.target.working.copy=選擇目標工作副本的路徑

#Configuration
configurable.name.svn.general=Subversion
configurable.name.svn.presentation=表示
configurable.name.svn.network=網絡
configurable.name.svn.ssh=SSH
dialog.title.select.configuration.directory=選擇配置目錄
action.title.select.configuration.directory=更改配置目錄
dialog.description.select.configuration.directory=選擇 Subversion 配置目錄或創建新目錄
button.text.clear.authentication.cache=清除身份驗證快取(&C)
label.text.delete.stored.credentials=刪除為 'http'、'svn' 和 'svn+ssh' 協議存儲的所有憑證
button.text.edit.proxies=編輯網絡選項(&O)…
dialog.title.edit.http.proxies.settings = 編輯與網絡層相關的 Subversion 選項
dialog.edit.http.proxies.settings.error.same.group.names.text=檢測到同名的組: ''{0}''
dialog.edit.http.proxies.settings.error.ambiguous.group.patterns.text=找到與多個組符合的版本庫 URL: {0}
dialog.edit.http.proxies.settings.error.ambiguous.group.patterns.to.text=URL {0} 符合 {1}
dialog.edit.http.proxies.settings.tab.edit.user.file.title=使用者檔案
dialog.edit.http.proxies.settings.tab.edit.system.file.title=系統檔案
dialog.edit.http.proxies.settings.port.must.be.number.error=連接埠必須為數字(組 ''{0}'')
dialog.edit.http.proxies.settings.timeout.must.be.number.error=HTTP 超時必須為數字(組 ''{0}'')
dialog.edit.http.proxies.settings.dialog.select.ssl.client.certificate.path.title=選擇證書路徑
dialog.edit.http.proxies.settings.panel.proxy.title=HTTP 代理設定
dialog.edit.http.proxies.settings.panel.ssl.title=SSL 設定
dialog.edit.http.proxies.settings.panel.repositories.title=版本庫
dialog.edit.http.proxies.settings.patterns.text=URL 模式(&R):
dialog.edit.http.proxies.settings.exceptions.text=異常(&X):
dialog.edit.http.proxies.settings.server.text=伺服器(&S):
dialog.edit.http.proxies.settings.user.text=使用者(&U):
dialog.edit.http.proxies.settings.port.text=連接埠(&O):
dialog.edit.http.proxies.settings.password.text=密碼(&W)：
dialog.edit.http.proxies.settings.connection.timeout.text=連接超時(&I):
dialog.edit.http.proxies.settings.seconds.text=秒
dialog.edit.http.proxies.settings.paths.to.authority.certificates.text=CA 證書檔案的逗號分隔路徑(&P):
dialog.edit.http.proxies.settings.ssl.client.certificate.file.text=SSL 客戶端證書檔案(&C):
dialog.edit.http.proxies.settings.client.certificate.passphrase.text=SSL 客戶端證書密碼短語(&H):
dialog.edit.http.proxies.settings.trust.default.cas.text=信任預設 CA(&A)
dialog.edit.http.proxies.settings.test.connection.button.text=測試連接(&T)
dialog.edit.http.proxies.settings.test.connection.settings.will.be.stored.title=警告
dialog.edit.http.proxies.settings.test.connection.settings.will.be.stored.text=設定將被儲存
dialog.edit.http.proxies.settings.test.connection.error.title=連接測試失敗
dialog.edit.http.proxies.settings.test.connection.success.title=連接測試成功
dialog.edit.http.proxies.settings.test.connection.success.text=連接測試成功
progress.title.test.connection=測試連接
progress.message.connecting.to.url=正在連接到 {0}
confirmation.text.delete.stored.authentication.information=您將刪除所有存儲的 Subversion 身份驗證資訊。\\\\n\\\\
確定要刪除嗎?
confirmation.title.clear.authentication.cache=清除身份驗證快取
dialog.title.select.path.to.subversion.executable=Subversion
label.select.path.to.subversion.executable=選擇 Subversion 可執行檔案(1.7+)的路徑
label.path.to.svn.executable=Subversion 可執行檔案的路徑:
command.line.interactive.mode.title=啟用交互模式
command.line.interactive.mode.description=<html>模擬直接從終端執行 Subversion 命令時的行為(交互模式)。<br>這是處理 svn+ssh 版本庫的密碼/密碼短語提示以及信任 https 版本庫的無效伺服器證書所必需的。</html>
non.english.locale.detected.warning=使用了非英語區域設定。

ssh.settings.executable.label=SSH 可執行檔案:
dialog.title.ssh.settings.browse.executable=SSH 可執行檔案
ssh.settings.user.name.label=用戶名:
ssh.settings.port.label=連接埠:
ssh.settings.password.choice.title=密碼
ssh.settings.private.key.choice.title=私鑰
ssh.settings.private.key.path.label=路徑:
dialog.title.ssh.settings.browse.private.key=私鑰
ssh.settings.subversion.config.choice.title=Subversion 配置
ssh.settings.tunnel.label=SSH 隧道:
ssh.settings.update.tunnel.title=更新

label.working.copy.format.unknown=未知
error.format.is.not.supported=不支持 {0} 格式。支援的格式: {1}。

label.configure.upgrade.label=工作副本升級策略:
radio.configure.upgrade.auto.16format=自動升級(使用 Subversion 1.6)(&6)
radio.configure.upgrade.auto.17format=自動升級(使用 Subversion 1.7)(&7)
radio.configure.upgrade.auto.18format=自動升級(使用 Subversion 1.8)(&8)

label.configure.create.label={0} 將要創建新的 Subversion 工作副本，\\\\n\\\\
請選擇所需的工作副本格式:
radio.configure.create.auto.16format=1.6 格式(&6)
radio.configure.create.auto.17format=1.7 格式(&7)
radio.configure.create.auto.18format=1.8 格式(&8)

label.configure.change.label=將工作副本 ''{0}'' 格式更改為:
radio.configure.change.auto.16format=1.6 格式(&6)
radio.configure.change.auto.17format=1.7 格式(&7)
radio.configure.change.auto.18format=1.8 格式(&8)

dialog.upgrade.wcopy.format.title=Subversion 工作副本格式
label.working.copy.root.outside.text=工作副本根位於“專案設定”中指定的目錄外部。\\\\n\\\\
整個工作副本將被轉換。

progress.text.loading.contents=正在載入 ''{0}'' 的內容
progress.text2.revision.information=修訂{0}
progress.title.loading.file.content=正在載入遠端檔案內容
progress.title.loading.file.properties=正在載入遠端檔案屬性
exception.text.file.miss.svn=檔案 ''{0}'' 為唯讀，但缺少 svn:needs-lock 屬性
confirmation.text.edit.file=您要編輯的檔案在編輯前需要鎖定

#File statuses
file.status.external=外部 (svn)
file.status.obstructed=受阻 (svn)
file.status.replaced=取代 (svn)
status.group.name.replaced=已取代

#Adding
confirmation.text.add.file=您是否計劃將以下檔案添加到 Subversion?\\\\n\\\\
{0}
confirmation.text.add.dir=您是否計劃將以下目錄添加到 Subversion?\\\\n\\\\
{0}
confirmation.title.add.file=計劃添加
confirmation.title.add.multiple.files=選擇要添加到 Subversion 的檔案

#Ignore
action.name.ignore.files=添加忽略檔案遮罩
action.name.undo.ignore.files=從忽略列表移除文件名(或遮罩)

# Delete
confirmation.text.delete.file=您是否計劃將以下檔案從 Subversion 刪除?\\\\n\\\\
{0}
confirmation.text.delete.dir=您是否計劃將以下目錄從 Subversion 刪除?\\\\n\\\\
{0}\\\\n\\\\
注意: 提交變更後，該目錄將從磁碟中刪除。
confirmation.text.delete.dir.17=您是否計劃將以下目錄從 Subversion 刪除?\\\\n\\\\
{0}
confirmation.title.delete.file=計劃刪除
confirmation.title.delete.multiple.files=選擇要從 Subversion 刪除的檔案

#Lock/Unlock
progress.text.locking.files=正在鎖定版本庫中的檔案…
progress.text2.processing.file=正在處理檔案 {0}
progress.title.lock.files=鎖定檔案
exception.text.locking.file.failed=無法鎖定檔案: {0}
message.text.files.lock.failed={0,choice, 0#無法鎖定檔案。|1#無法鎖定檔案。}
message.text.files.locked={0,choice, 0#鎖定檔案失敗。|1#已鎖定 1 個檔案|2#已鎖定 {0,number} 個檔案}
progress.text.unlocking.files=正在解鎖版本庫中的檔案…
progress.title.unlock.files=解鎖檔案
exception.text.failed.to.unlock.file=無法解鎖檔案: {0}
message.title.unlock.failures=解鎖失敗
message.text.files.unlocked={0,choice, 0#解鎖檔案失敗。|1#已解鎖 1 個檔案|2#已解鎖 {0,number} 個檔案}

exception.text.cleanupaction.batchperform.not.implemented=CleanupAction.batchPerform 未實作
progress.text2.adding=正在添加 ''{0}''
progress.text2.deleting=正在刪除 ''{0}''
progress.text2.sending=正在發送 ''{0}''
progress.text2.replacing=正在取代 ''{0}''
progress.text2.transmitting.delta=正在傳輸 ''{0}'' 的增量
progress.title.copy=Subversion 副本
progress.text.copy.to=複製到 ''{0}''
message.text.no.conflicts.found=未找到衝突
message.title.no.conflicts.found=無衝突
label.select.files.and.directories.to.mark.resolved=選擇要標記為已解決的檔案和目錄:
dialog.title.mark.resolved=標記已解決
action.name.mark.resolved=標記已解決
action.name.resolve.conflict=解決衝突
action.name.revert=還原(&R)
error.revert.failed=還原失敗
action.name.set.property=設定屬性
exception.text.cannot.annotate.directory=註解操作僅對檔案有意義
progress.text.computing.annotation=正在計算 ''{0}'' 的註解
action.text.annotate=註解
label.revision=修訂
label.merge.source.revision=合併原始碼修訂
tooltip.revision.number.message=修訂 {0}: {1}
error.can.not.find.relative.path.for.path.at.revision=找不到 {0}@{1} 的相對路徑
error.can.not.get.current.revision.for.path=無法獲取檔案 {0} 的當前修訂
error.can.not.get.last.changed.revision.for.path.please.file.an.issue=無法獲取檔案上次進行的修訂: {0}\\\\n\\\\
請為此檔案執行 svn info 並提交問題。
checkbox.checkin.keep.files.locked=保持檔案鎖定(&K)
checkbox.checkin.auto.update.after.commit=提交後自動更新
progress.title.commit=提交
status.text.committed.revision=提交的修訂 {0}。
checkin.operation.name=提交(_I)
checkin.different.formats.involved={0,choice,0#版本庫|1#版本庫} {1} 的選定變更\\\\n\\\\
屬於不同格式的 Subversion 工作副本。\\\\n\\\\
提交將分為多個提交。\\\\n\\\\
\\\\n\\\\
您可以在“變更 | Subversion 工作副本資訊”中將所有工作副本轉換為相同格式。\\\\n\\\\
是否要繼續提交?
dialog.title.commit.will.split=Subversion: 提交將進行拆分
error.wrong.committed.revision.number=提交的修訂號錯誤: {0}
error.missing.committed.revision.number=缺少提交的修訂號: {0}
progress.text2.fetching.external.location=正在獲取 ''{0}'' 的外部位置
progress.text2.checked.out=已簽出 {1} 個檔案，正在簽出 {0}
progress.text2.exported=已匯出 {1} 個檔案，正在匯出 {0}
progress.text2.checked.out.revision=已簽出修訂 {0}。
progress.text2.exported.revision=已匯出修訂 {0}。
status.text.checked.out.revision=已簽出修訂 {0}。
message.text.cannot.load.supported.formats=無法載入支援的格式: {0}
message.text.cannot.checkout=無法從 svn 簽出: {0}
message.text.cannot.export=無法從 svn 匯出: {0}
dialog.title.check.out=從 Subversion 簽出
progress.title.check.out=從 Subversion 簽出
message.title.export=從 Subversion 匯出
progress.text.checking.out=正在將檔案簽出到 ''{0}''
progress.text.export=正在將檔案匯出到 ''{0}''
button.text.select.all=全選(&A)
button.text.deselect.all=取消全選(&D)
dialog.title.select.repository.location=選擇版本庫位置
dialog.message.can.not.detect.repository.root.for.url=無法檢測 URL 的版本庫根: {0}
progress.title.detecting.repository.root=正在檢測版本庫根
button.text.ssl.accept=接受(_A)
button.text.ssl.reject=拒絕(_R)
button.text.ssh.accept=是 (_Y)
button.text.ssh.reject=否 (_N)
dialog.title.ssl.examine.server.crertificate=檢查伺服器證書
dialog.title.ssh.examine.server.fingerprints=驗證伺服器密鑰指紋
label.ssl.server.provided.certificate=伺服器提供了以下證書:
label.ssh.server.provided.fingerprints=無法建立主機 {0} 的驗證。
label.ssh.server.provided.fingerprints2={0} 密鑰指紋為
label.ssh.server.provided.fingerprints3=確定要繼續連接嗎?
checkbox.svn.ssh.cache.fingerprint=將密鑰添加到 Subversion 快取(&A)
dialog.title.set.property=設定屬性
label.set.property.property.name=屬性名稱(&N):
radio.set.property.set.property.value=設定屬性值(&S):
radio.set.property.delete.property=刪除屬性(&D)
checkbox.set.property.update.properties.recursively=遞歸更新屬性(&R)

#update
update.switch.configurable.name=更新/切換
label.update.url=URL:
checkbox.update.switch.configurable.to.specific.revision=更新/切換到特定版本(&R):
checkbox.force.update=強制更新(&F)
checkbox.ignore.externals=忽略外部項(&E)
checkbox.update.switch.configurable.try.merge.without.changes=嘗試合併，但不做任何變更(&T)
progress.text.merging.dry.run.changes=正在將(dry run)變更合併到 ''{0}''
progress.text.merging.changes=正在將變更合併到 ''{0}''
progress.text.updating=正在更新 ''{0}''
exception.text.root.was.not.properly.updated=svn: {0} 未正確更新; 可能是因為它已經與父級一起從版本庫中移除。
message.text.update.no.directories.found=找不到要更新的版本管理目錄
messate.text.update.error=SVN: 更新錯誤
label.external.copy=外部副本
label.switched.copy=已切換副本

progress.text2.added=已添加 {0}
progress.text2.deleted=已刪除 {0}
progress.text2.conflicted={0} 存在衝突
progress.text2.treeconflicted=已衝突 {0}(樹衝突)
progres.text2.merged=已合併 {0}
progres.text2.updated=已更新 {0}
progress.text2.restored.file=已恢復 {0}
progres.text2.updated.to.revision=已更新至修訂 {0}。
status.text.updated.to.revision=已更新至修訂 {0}。
progress.text2.skipped.file=已跳過 {0}
progress.text.updating.external.location=正在更新 ''{0}'' 的外部位置
server.ssl.accept.temporary.action.name=接受臨時(_T)
integrate.display.name=整合
error.invalid.svn.revision=無效的 svn 修訂: {0}
error.invalid.url=無效 url: {0}
integrate.configuration.revision1.label=修訂(&V)
integrate.configuration.source2.label=源 2:
integrate.configuration.revision2.label=修訂(&R)
integrate.configuration.source1.label=源 1:
integrate.configuration.description.label=將源之間的差異集成到工作副本中(比較源 2 和源 1)
source.url.could.not.be.empty.error.message=源 URL 不能為空
no.differences.between.sources.error.message=源和相同源之間沒有區別
label.update.switch.to.revision=更新/切換到修訂:
configure.revision.specified.radio=指定的
configure.revision.head.radio=HEAD
update.configuration.specific.url=更新/切換到特定 URL(&U):
progress.text.import=匯入 {0}
message.text.cannot.import=無法匯入 svn: {0}
message.title.import=匯入 Subversion
revision.title=修訂
error.revision.from.must.be.a.valid.number=“起始修訂”必須為有效數字
error.revision.to.must.be.a.valid.number=“結束修訂”須為有效數字
checkout.dialog.title=從 Subversion 簽出
checkout.dialog.button=檢出
checkout.directory.chooser.title=簽出目錄
checkout.directory.chooser.prompt=選擇要從 Subversion 簽出的目錄
checkout.options.dialog.title=SVN 簽出選項
checkout.options.checkout.label=檢出:
configure.branches.title=配置 Subversion 分支
configure.branches.error.wrong.url=主幹位置必須在版本庫根 ''{0}'' 下
configure.branches.trunk.location=主幹位置:
configure.branches.branch.locations=分支位置:
refresh.branches.item=刷新分支…
copy.column.title=複製
copy.column.tooltip=從 {0} 複製
progress.title.loading.branches=正在載入分支
compare.with.branch.progress.loading.content=載入內容中...
compare.with.branch.diff.title=與分支比較
compare.with.branch.error.title=與分支比較
compare.with.branch.popup.title=與分支比較
compare.with.branch.location.error=在分支 ''{1}'' 下找不到檔案 ''{0}'' 的版本庫位置\\\\n\\\\
請檢查您的分支配置。
action.name.switch=切換
import.dialog.title=匯入 Subversion
import.dialog.button=匯入
repository.browser.add.location.action.text=添加版本庫位置
repository.browser.add.location.action.description=添加版本庫位置
repository.browser.no.locations.added.info=未添加版本庫位置。
repository.browser.add.location.prompt=版本庫 URL:
repository.browser.add.location.title=新建版本庫位置
repository.browser.details.action=顯示/隱藏詳細資訊
repository.browser.refresh.action=刷新選定樹節點
repository.browser.add.location.menu.item=版本庫位置(_R)…
repository.browser.edit.location.menu.item= 編輯位置 URL(_U)…
repository.browser.discard.location.action=丟棄位置(_L)
repository.browser.discard.location.prompt=要丟棄位置 ''{0}'' 嗎?
repository.browser.discard.location.title=丟棄位置
repository.browser.new.folder.action=遠端資料夾(_F)…
action.repository.browser.history.text=顯示歷史記錄
action.repository.browser.history.description=顯示歷史記錄
repository.browser.import.action=匯入(_I)…
diff.options.title=與分支或標記比較
diff.options.label.compare=比較:
diff.options.label.with=與:
diff.options.label.compare.type=比較類型
diff.options.checkbox.reverse.diff=反轉差異
diff.options.radio.graphical.compare=圖形比較
diff.options.radio.unified.diff=統合差異
diff.options.no.url.error=請選擇一個 URL 進行比較
diff.options.same.url.error=請選擇其他 URL 進行比較
diff.options.no.patch.file.error=請指定儲存補丁檔案的路徑
dialog.title.save.unified.diff=補丁檔案
label.select.file.to.save.unified.diff=選擇用於存儲統合差異的檔案
diff.cant.get.properties.changes=無法顯示 SVN 屬性
repository.browser.browse.changes.action=瀏覽變更(_B)…
repository.browser.browse.changes.description=查看選定節點中的變更歷史記錄
repository.browser.compare.title=比較 ''{0}'' 和 ''{1}''
error.could.not.compare.local.file.and.remote.url.with.executable.for.svn.version=無法將本地檔案和遠端 Url 與 svn {0} 的可執行檔案相比較
cleanup.action.name=清理
changes.browser.revision.term=修訂
dialog.title.computing.difference=正在計算差異
progress.searching.for.files.with.conflicts=正在搜尋有衝突的檔案
add.files.errors.title=添加檔案時出錯
move.files.errors.title=移動檔案時出錯
error.target.of.move.operation.is.already.under.version.control=移動操作的目標已受到版本控制。
error.move.have.not.been.performed=尚未執行 Subversion 移動。
delete.files.errors.title=刪除檔案時出錯
progress.title.adding.files.to.subversion=正在向 Subversion 添加檔案
progress.title.deleting.files.from.subversion=正在從 Subversion 中刪除檔案
progress.title.moving.files.in.subversion=正在移動 Subversion 中的檔案
copy.dialog.title=分支或標籤
move.dialog.title=移動或重命名
select.location.invalid.url.message=無效的 Subversion 版本庫 URL: ''{0}''
share.directory.action=共享目錄…
share.directory.commit.message={2}\\\\n\\\\
{1} 創建的目錄 ''{0}''
share.directory.title=共享目錄
dialog.message.share.to.not.empty.directory=遠端資料夾 \\"{0}\\" 非空。\\\\n\\\\
要繼續共享嗎?
share.directory.info.message=要完成共享操作，請提交 ''{0}''。
share.directory.create.dir.progress.text=正在創建遠端資料夾 {0}
share.directory.checkout.back.progress.text=正在簽出 {0}
share.or.import.add.progress.text=正在排定 {0} 的添加時間表
progress.title.share.directory=共享目錄
progress.title.check.remote.folder.contents=檢查遠端資料夾內容
tab.title.failed.to.share.project=無法共享專案
action.share.whole.project.text=共享專案(Subversion)…
action.Subversion.integrate.changes.select.working.copy.text=集成到工作副本：
dialog.title.integrate.to.branch=集成到分支
action.Subversion.integrate.changes.message.not.under.control.text=所選目標不在 Subversio 的控制下。仍要繼續？
action.Subversion.integrate.changes.message.another.wc.text=所選目標位於另一個版本庫的工作副本內。仍要繼續？
action.Subversion.integrate.changes.branch.info.source.label.text=源分支 URL：{0}
action.Subversion.integrate.changes.branch.info.target.label.text=目標分支 URL：{0}
action.Subversion.integrate.changes.actionname=集成到分支…
action.Subversion.integrate.changes.description=將選定的變更列表/變更集集成到選定的分支
action.Subversion.integrate.changes.messages.title=集成到分支
dialog.message.integrate.changes.error.no.available.files=沒有可用於集成的檔案
popup.title.select.branch.to.integrate.to=選擇要集成到的分支…
dialog.message.integrate.changes.error.same.source.and.target=無法啟動集成: 目標分支和源分支相同。
dialog.message.integrate.changes.error.target.not.dir=無法啟動集成: 目標目錄不存在或不是目錄。
dialog.message.integrate.changes.error.not.versioned=無法啟動集成: 目標目錄不在 Subversion 控制下或不屬於所選分支。
action.Subversion.integrate.changes.dialog.add.wc.text=添加
action.Subversion.integrate.changes.dialog.remove.wc.text=移除
action.Subversion.integrate.changes.message.files.up.to.date.text=所有檔案均為最新
action.Subversion.integrate.changes.collecting.changes.to.commit.task.title=正在收集要提交的變更
action.Subversion.integrate.changes.error.unable.to.collect.changes.text=收集要提交的更改時出錯：{0}
error.cannot.load.revisions=無法載入修訂列表
action.Subversion.integrate.changes.progress.integrating.text=正在合併更改
update.switch.to.branch.text=使用分支:
popup.title.select.branch=選擇分支
progress.live.provider.loading.revisions.text=正在從伺服器載入修訂
progress.live.provider.loading.revisions.details.text=正在從伺服器載入修訂…
dialog.show.svn.map.title=Subversion 工作副本資訊
label.working.copy.url=URL:
label.working.copy.format=格式:
link.change.format=已改變
label.working.copy.depth=深度:
link.fix.depth=修正
label.working.copy.root=工作副本根
label.nested.copy.type.external=外部
label.nested.copy.type.switched=已切換
label.nested.copy.type.inner=嵌套
dialog.title.convert.working.copy.format=轉換工作副本格式
progress.title.convert.working.copy.format=轉換工作副本格式
progress.text.converting.working.copy.format=將 {0} 格式的工作副本從 {1} 轉換為 {2}
progress.details.upgraded.path=已升級路徑 {0}
dialog.message.invalid.working.copy.root=無效的工作副本根: {0}
dialog.title.can.not.invoke.action=無法調用 {0}
dialog.title.set.working.copy.infinity.depth=設定工作副本無限深度
dialog.message.set.working.copy.infinity.depth=您將以 ''infinity'' 深度簽出到 ''{0}''。\\\\n\\\\
您的工作副本也將隨之更新為 HEAD 修訂。
action.name.configure.branches=配置分支
action.name.merge.from=合併自
action.name.merge.from.ellipsis=合併自…
notification.content.can.not.access.working.copy.database=存取 svn 工作副本資料庫時發生了若干錯誤。
notification.content.single.root.unsupported.format=根 ''{0}'' 可能是不受支援的 Subversion 格式
notification.content.multiple.roots.unsupported.format=某些根的格式可能是不受支援的 Subversion 格式

committed.changes.action.enable.merge.highlighting=高亮顯示集成項
committed.changes.action.enable.merge.highlighting.description.text=選項僅適用於 SVN 版本庫和 1.5 版本的工作副本
committed.changes.action.merge.highlighting.refresh.text=刷新
committed.changes.action.merge.highlighting.refresh.description=刷新合併的修訂資訊
dialog.Subversion.select.working.copy.title=配置工作副本路徑
dialog.Subversion.select.working.copy.wcopy.list.title=已知工作副本
action.Subversion.cleanup.progress.title=Subversion 清理
progress.text.performing.path.cleanup=正在執行 ''{0}'' 清理…
progress.title.cleanup.project=清理專案
action.Subversion.cleanup.error.message=對 ''{0}'' 執行清理時出錯: {1}
action.Subversion.integrate.difference.option.use.ancestry.text=使用以前的版本(&U)
use.idea.proxy.as.default=將 {0} 常規代理設定用作 Subversion 的預設設定
use.idea.proxy.as.default.label.text=僅 HTTP 代理可用作預設值
navigate.to.idea.proxy.settings=導航到常規代理設定
dialog.message.switch.target.not.copy.current=切換目標 URL 不是當前副本。\\\\n\\\\
要繼續嗎?
dialog.title.switch.target.problem=切換目標問題
tab.repository.merge.panel.filter.plus=篩選出集成項
tab.repository.merge.panel.filter.minus=篩選出未集成項
tab.repository.merge.panel.filter.others=篩選出其他
browse.changes.settings.stop.on.copy=複製時停止(&S)
action.mark.list.as.merged.text=標記為已合併
action.mark.list.as.merged.description=將所選修訂版標記為已合併，但實際沒有合併
action.mark.list.as.not.merged.text=標記為未合併
action.mark.list.as.not.merged.description=將所選修訂版標記為未合併，但不會更改 svn:mergeinfo 之外的任何內容
label.depth.text=深度(&D):
label.depth.description=取代舊的“遞歸”選項。“遞歸”為 false 等效於“直接子級”，“遞歸”為 true 等效於“無限”
label.working.copy=工作副本
label.depth.empty=空
label.depth.files=檔案
label.depth.immediates=直接
label.depth.infinity=無限
label.depth.exclude=排除
label.depth.unknown=未知
undo.integrate.to.branch=撤消集成到分支…
undo.integrate.to.branch.description=從分支中移除修訂中所做的變更
undo.integrate.to.branch.dialog.title=撤消集成到分支
merge.source.details.title=合併 {0} [{1}] 的原始碼詳細資訊
repository.browser.edit.location.dialog.title= 編輯位置 URL
action.Subversion.TogglePropertiesDiff.text=顯示屬性
action.Subversion.TogglePropertiesDiff.description=顯示 SVN 屬性的差異
action.IntegrateChangeSetAction.text=集成到分支
show.properties.diff.progress.text.revision.information=修訂{0}
show.properties.diff.progress.text2.property.information=屬性 {0}
checkbox.ignore.whitespace.when.merge.text=&忽略空格
label.file.has.conflicts=檔案有 {0} 個衝突，無法提交
label.file.has.conflicts.before.or.after=檔案有 {0} 個衝突，無法提交\\\\n\\\\
{1}
label.file.has.conflicts.before.and.after=檔案有 {0} 個衝突，無法提交\\\\n\\\\
之前: {1}\\\\n\\\\
之後: {2}
label.locally.deleted.file.has.conflicts=檔案有 {0} 個衝突
file.conflict.tree=樹
file.conflict.text=文本
file.conflict.property=屬性
action.Subversion.MarkTreeResolved.text=將樹衝突標記為已解決…
dialog.message.mark.tree.conflict.resolved.confirmation=是否要將樹衝突標記為已解決？
dialog.title.mark.tree.conflict.resolved=將樹衝突標記為已解決
progress.title.mark.tree.conflict.resolved=將樹衝突標記為已解決
svn.integrate.changelist.warning.unresolved.conflicts.text=集成中斷。存在未解決的衝突或跳過的項。
error.integration.was.canceled=集成已取消
svn.option.ignore.whitespace.in.annotate=忽略註解中的空格差異
annotation.show.merge.sources.default.text=在歷史記錄和註解中顯示合併原始碼
svn.cannot.save.credentials.store-auth-creds=無法存儲憑證: “store-auth-creds = no”禁止
annotation.original.revision=原始修訂
confirmation.resolve.tree.conflict.merge.moved=將 {0} 中的變更應用到本地移動的 {1}?
confirmation.resolve.tree.conflict.merge.renamed=將 {0} 中的變更套用到本地重命名的 {1}?
svn.create.external.below.action=創建外部…
svn.create.external.below.description=選擇 URL，添加 svn:external 屬性，然後可以選擇簽出
button.select=選擇
dialog.title.select.target.for.external=選擇用於外部的目標
dialog.message.target.file.already.exists=目標檔案已經存在
progress.title.creating.external=正在創建外部
tab.title.create.external=創建外部
error.selected.destination.conflicts.with.existing=所選目標與現有目標相衝突: {0}
label.local.target=本地目標:
checkbox.checkout=簽出
svn.edit.commit.message.title=編輯修訂 #{0} 註釋
svn.edit.commit.message.attention=注意! 以前的訊息將丟失!
svn.edit.commit.message.prompt=新修訂註釋:

#Merge
quick.merge.variants.merge.all=全部合併
quick.merge.variants.merge.all.explanation=所有未合併的修訂將被合併。\\\\n\\\\
Subversion 將使用本地副本中記錄的 svn:mergeinfo 屬性尋找未合併的修訂。
quick.merge.variants.quick.select=快速手動選擇
quick.merge.variants.quick.select.explanation=顯示來自目標分支、已合並和未合併分支的所有修訂。\\\\n\\\\
用於手動選擇。快速獲取結果。
quick.merge.variants.pre.select=通過預篩選選擇
quick.merge.variants.pre.select.explanation=尋找涉及的一個分支複製自另一個分支的位置。\\\\n\\\\
僅載入尚未合併的修訂以供選擇。執行可能需要很長時間。
progress.title.merging.all.from.branch=正在合併 {0} 中的全部內容
progress.title.merging.all.from.branch.reintegrate=正在合併 {0} 中的全部內容(重新集成)
progress.title.shelving.local.changes.before.merge=正在擱置合併前的本地變更
progress.title.checking.repository.capabilities=正在檢查版本庫容量
progress.title.loading.recent.branch.revisions=正在載入最近的 {0} 修訂
progress.title.looking.for.branch.origin=正在尋找分支來源
progress.title.filtering.branch.revisions=正在篩選 {0} 修訂
progress.title.calculating.copy.revision=正在計算副本修訂
progress.text.collecting.merge.information=正在收集合併資訊
progress.text.collecting.not.merged.revisions=正在收集未合併的修訂
progress.details.merging.changelist.range=正在合併變更列表 {0}
error.could.not.parse.merge.info=無法解析 {0}
action.Subversion.SelectAllRevisions.text=全選
action.Subversion.SelectAllRevisions.description=全選
action.Subversion.UnselectAllRevisions.text=取消全選
action.Subversion.UnselectAllRevisions.description=取消全選
button.merge.selected=合併所選內容
button.merge.all=全部合併
dialog.title.select.merge.variant=選擇合併變體
dialog.message.merge.with.switched.paths.in.working.copy=工作副本中有一些切換的路徑。要繼續嗎?
dialog.message.merge.confirm.reintegrate=您將重新集成變更。<br><br>此舉將導致分支 ''{0}'' <b>不能再用於進一步的處理</b>。<br>此分支既無法正確吸收新的主幹({1})變更，<br>也無法正確地重新集成到主幹。<br> <br>確定嗎?
dialog.message.merge.intersects.with.local.changes.prompt=存在與合併變更衝突的本地變更。\\\\n\\\\
是否繼續?
dialog.message.merge.potentially.intersects.with.local.changes.prompt=存在與合併變更有可能相交的本地變更。\\\\n\\\\
要繼續嗎?
tab.title.merge.local.changes.intersection={0}，本地變更相交
label.merge.local.changes.intersection=以下檔案具有與合併變更相交的本地變更:
notification.content.merge.start.was.not.found=找不到合併起始點
notification.content.can.not.merge.from.self=無法自我合併
notification.content.everything.is.up.to.date=所有內容都已處於最新狀態
operation.merge=合併
button.load.quantity=載入 +{0}
label.already.merged=已合併
dialog.title.merge.from.branch=合併自 {0}
label.merge.all.from.branch=合併 {0} 中的全部內容
label.merge.all.from.branch.reintegrate=合併 {0} 中的全部內容(重新集成)
label.merge.all.from.branch.at.revision=合併 {1} 的 {0} 中的全部內容
label.merge.all.from.branch.at.revision.reintegrate=合併 {1} 的 {0} 中的全部內容(重新集成)
label.skipped.changelists=已跳過變更列表：{0}
label.changelists.merging.faced.problems=變更列表:\\\\n\\\\
{0}\\\\n\\\\
合併面臨的問題
label.merged.from.branch=已合併自 {0}
merge.chunk.changelist.description={0} [來自於修訂 {1}]

#Conflicts
progress.title.getting.base.and.theirs.revisions.content=獲取基本內容及其修訂內容
progress.title.creating.patch.for.theirs.changes=正在為其變更創建補丁
progress.title.accepting.working.state=正在接受工作狀態
progress.title.adding.file.to.subversion=正在將 {0} 添加到 Subversion
progress.title.applying.binary.changes=正在套用二進制變更
progress.title.resolve.tree.conflict=解決樹衝突
dialog.title.resolve.tree.conflict=解決樹衝突
dialog.message.keep.newly.created.files.in.their.original.place=在其初始位置保留新建檔案?
dialog.message.accept.theirs.for.path=接受他們對 {0} 的變更?
dialog.message.accept.yours.for.path=針對 {0} 接受您的變更?
progress.title.accepting.theirs.for.path=為之接受他們的變更: {0}
progress.title.accepting.yours.for.path=為之接受您的變更: {0}
dialog.message.select.binary.files.to.patch=選擇要打補丁的二進制檔案
dialog.message.merge.from.theirs.delete.binary.file=(根據其變更)刪除二進制檔案 {0}?
dialog.message.merge.from.theirs.create.binary.file=(根據其變更)創建二進制檔案 {0}?
dialog.message.merge.from.theirs.modify.binary.file=(根據其變更)對二進制檔案 {0} 套用變更?
button.keep=保留
button.move=移動
button.resolve.conflict.merge=合併
button.resolve.conflict.accept.yours=接受您的變更
button.resolve.conflict.accept.theirs=接受他們的變更
label.path.revisions.info={0}(當前: {1}，已提交: {2})
label.conflict.left.side=左: {0}
label.conflict.right.side=右: {0}
label.conflict.directory.added=(目錄)已添加
label.conflict.file.added=(檔案)已添加
label.conflict.directory.unversioned=(目錄)未進行版本管理
label.conflict.file.unversioned=(檔案)未進行版本管理
label.before.accepting.theirs.for.path=在針對 {0} 接受他們的變更前
label.after.accepting.theirs.for.path=在針對 {0} 接受他們的變更後
message.theirs.changes.merged.for.file=已針對 {0} 合併他們的變更
message.theirs.accepted.for.file=已針對 {0} 接受了他們的變更
message.yours.accepted.for.file=已針對 {0} 接受了您的變更
value.patch.file.name=TheirsChanges.patch
error.can.not.load.theirs.content.for.file=無法為檔案 {0} 載入他們的內容
tree.conflict.description=本地 {0}，{2} 時傳入 {1}
conflict.reason.edited=編輯
conflict.reason.obstructed=障礙
conflict.reason.deleted=刪除
conflict.reason.missing=缺少
conflict.reason.unversioned=未進行版本管理
conflict.reason.added=添加
conflict.reason.replaced=取代
conflict.reason.moved.away=移開
conflict.reason.moved.here=已移到此處
conflict.action.edit=編輯
conflict.action.add=添加
conflict.action.delete=刪除
conflict.action.replace=取代
conflict.operation.update=更新
conflict.operation.switch=切換
conflict.operation.merge=合併
conflict.operation.none=無

dialog.create.branch.or.tag.from.working.copy.warning=<html>使用此變體創建<b>具有本地變更</b>的分支。<br/>通常，不僅是目標目錄，還將有幾個項“帶歷史記錄添加”。<br/><br/>具有與根不同的修訂的各個檔案將被分別複製。<br/>因此，建議先更新工作副本，然後再創建分支。</html>

exportable.SvnDiffSettings.presentable.name=SVN 差異
configurable.SvnConfigureProxiesComponent.display.name=HTTP 代理配置
value.new.server.group.name=未命名
settings.use.custom.directory=使用自訂配置目錄(&U):
settings.check.mergeinfo=在準備合併時檢查目標子樹中的 svn:mergeinfo
settings.maximum.revisions.number=要在註解中回溯的最大修訂數：
settings.HTTP.timeout=HTTP 超時：
settings.seconds=秒
settings.SSH.connection.timeout=SSH 連接超時：
settings.SSH.read.timeout=SSH 讀取超時：
settings.edit.servers.subversion.runtime.configuration.file=編輯 'servers' Subversion 執行時配置檔案
settings.ssl.protocols=SSL 協議:
settings.ssl.protocols.all=所有
settings.ssl.protocols.sslv3=SSLv3
settings.ssl.protocols.all.tlsv1=TLSv1
action.DumbAware.SvnConfigureProxiesComponent.text.add=添加
action.DumbAware.SvnConfigureProxiesComponent.description.add=添加
action.DumbAware.SvnConfigureProxiesComponent.text.copy=複製
action.DumbAware.SvnConfigureProxiesComponent.description.copy=複製
action.DumbAware.RepositoryBrowserDialog.text.branch.or.tag=分支或標記…
action.DumbAware.RepositoryBrowserDialog.text.move.or.rename=移動或重命名(_M)…

svn.properties.viewer=SVN 屬性查看器
svn.tree.conflict.viewer=SVN 樹衝突查看器
svn.phantom.changes.viewer=SVN 模擬變更查看器
label.svn.phantom.change=技術記錄
text.svn.phantom.change=已記錄此變更，因為其目標檔案被刪除，\\\\n\\\\
並且某些父目錄已複製(或移動)到新位置。
dialog.title.svn.properties.diff=SVN 屬性差異
progress.title.loading.change.details=正在載入變更詳細資訊
progress.title.loading.tree.conflict.details=正在載入樹衝突詳細資訊
label.svn.properties.changed=SVN 屬性已更改
separator.property.changes=屬性變更

error.no.branch.point.found.for.target=找不到 {0} 的分支點
error.target.not.found.in.paths=在 {1} 中找不到 {0}
error.file.is.not.under.version.control=檔案 {0} 未進行版本管理
error.file.is.not.under.subversion=檔案 {0} 未受到 Subversion 控制
error.can.not.find.file=找不到檔案: {0}
error.can.not.find.repository.root.for.url=找不到 URL 的版本庫根: {0}
error.can.not.find.repository.root.for.url.in.revision=在修訂 {1} 中找不到 URL: {0} 的版本庫根
error.could.not.get.info.for.path=無法獲取 {0} 的資訊
error.could.not.get.head.info.for.url=無法獲取 {0} 的標頭資訊
error.could.not.get.revision.for.url=無法獲取 {0} 的修訂
error.properties.loading.for.revision.canceled=已取消為修訂 {0} 載入屬性。
error.can.not.access.file.base.revision.contents.administrative.area.is.locked=無法存取檔案的基本修訂內容: 管理區域已鎖定
error.url.is.not.absolute={0} 非絕對
error.url.is.not.hierarchical={0} 非層次結構
error.url.could.not.contain.query={0} 不能包含查詢
error.url.could.not.contain.fragment={0} 不能包含片段
error.can.not.delete.file=無法刪除檔案: {0}
error.can.not.create.directory=無法創建目錄: {0}
error.could.not.determine.revision.number.for.file.and.revision=無法確定檔案 {0} 和修訂 {1} 的修訂號
error.could.not.find.start.quote=找不到起始引號
error.could.not.find.separating.space=找不到分隔空間
error.latest.existent.revision.found.for.url=已找到 {0} 的最新現有修訂
error.could.not.get.relative.path.for.parent.and.child=無法獲取 {0} 和 {1} 的相對路徑
error.could.not.parse.svn.version=無法解析 svn 版本: {0}
error.could.not.get.svn.version=退出程式碼: {0}，錯誤: {1}
error.parse.file.status.unknown.state.on.line=第 {0} 行的狀態未知
error.svn.exited.with.error.code=SVN 進程已退出，錯誤程式碼為: {0}
error.authentication.canceled.for.repository=已對版本庫取消身份驗證: {0}
error.svn.status.with.no.output=狀態請求沒有為命令返回任何內容: {0}
error.svn.status.not.in.working.copy=請求的狀態不在工作副本中: {0}
toolwindow.working.copies.info.title=Subversion 工作副本資訊
svn.short.name.with.mnemonic=SVN(_S)"
`;

exports[`dev messages/VcsBundle.properties 1`] = `
"none.vcs.presentation=<無>
vcs.command.name.add=添加
vcs.command.name.remove=移除
vcs.command.name.checkin=提交(_I)
vcs.command.name.edit=編輯
vcs.command.name.checkout=簽出
vcs.command.name.status=狀態
vcs.command.name.update=更新
vcs.settings.path=設定 | 版本控制
vcs.settings.path.mac=偏好設定 | 版本控制
history.empty=歷史記錄為空
history.loading.revisions=正在載入受影響的修訂
exception.text.unknown.error=未知錯誤
exception.text.internal.error.method.should.not.be.called=不應調用
vcs.revision.name.current=當前
error.no.changes.to.commit=選擇要提交的檔案
error.no.commit.message=指定提交訊息
error.no.changes.no.commit.message=選擇要提交的檔案並指定提交訊息
label.commit.checks.not.available.during.indexing=編制索引期間無法提交檢查
label.commit.checks.failed=檢查失敗: {0}
confirmation.text.check.in.with.empty.comment=在註釋為空的情況下提交?
confirmation.title.check.in.with.empty.comment=註釋為空
action.commit.anyway.text=仍然{0}
amend.action.name=修正{0}
action.amend.commit.anyway.text=仍然修正
commit.message.placeholder=提交訊息
label.commit.comment=提交訊息(&M)
border.standard.checkin.options.group=在{0}之前
border.standard.after.checkin.options.group=在{0}之後
checkbox.checkin.options.optimize.imports=優化 import(&O)
checkbox.checkin.options.reformat.code=格式化程式碼(&R)
checkbox.checkin.options.rearrange.code=重新整理程式碼(&N)
progress.title.commit.checks=提交檢查
progress.text.inspecting.code=正在檢查程式碼…
progress.text.applying.fixes=正在套用修正…
progress.text.reformatting.code=正在重新格式化程式碼…
progress.text.rearranging.code=正在重新排列程式碼…
progress.text.optimizing.imports=正在優化 import…
progress.text.analyzing.code=正在分析程式碼…
progress.text.checking.for.todo=正在檢查 TODO…
progress.text.searching.for.modified.files=正在搜尋修改的檔案
button.text.overwrite.modified.file=覆蓋已修改的檔案(&O)
button.text.overwrite.modified.files=覆蓋已修改的檔案(&O)
message.text.file.locally.modified=檔案 {0} 已在本地被修改。
message.text.several.files.locally.modified=某些檔案已在本地被修改。
update.group.name.updated.from.server=從伺服器更新
update.group.name.updated=已更新
update.group.name.created=已創建
update.group.name.deleted=已刪除
update.group.name.restored=已恢復
update.group.name.modified=已修改
update.group.name.skipped=已跳過
update.group.name.merged.with.property.conflicts=已合併，但存在屬性衝突
update.group.name.merged.with.tree.conflicts=已合併，但存在樹衝突
update.group.name.merged.with.conflicts=已合併，但存在衝突
update.group.name.merged=已合併
update.group.name.not.in.repository=不在版本庫中
update.group.name.locally.added=本地已添加
update.group.name.locally.removed=本地已移除
update.group.name.switched=已切換
status.group.name.changed.on.server=在伺服器上已更改
status.group.name.changed=已更改
status.group.name.created=已創建
status.group.name.deleted=已刪除
status.group.name.modified=已修改
status.group.name.skipped=已跳過
status.group.name.will.be.restored=將被恢復
status.group.name.will.be.merged.with.property.conflicts=將在存在屬性衝突的情況下合併
status.group.name.will.be.merged.with.tree.conflicts=將在存在樹衝突的情況下合併
status.group.name.will.be.merged.with.conflicts=將在存在衝突的情況下被合併
status.group.name.will.be.merged=將被合併
status.group.name.not.in.repository=不在版本庫中
status.group.name.locally.added=本地已添加
status.group.name.locally.removed=本地已移除
status.group.name.switched=已切換
border.changes.filter.change.number.filter=更改
border.changes.filter.date.filter=日期
checkbox.show.changes.after.num=從(&F)
checkbox.show.changes.before.num=到(&T):
checkbox.show.changes.before.date=之前(&B)
checkbox.show.changes.after.date=之後(&A)
exception.text.internal.errror.could.not.implement.method=無法實作
message.text.could.not.load.virtual.file.content=無法載入檔案 {0} 的內容: {1}
message.title.could.not.load.content=無法載入內容
message.text.commit.progress=正在提交…
message.text.commit.failed.with.error=提交失敗，有{0,choice,1#錯誤|2#錯誤}
message.text.commit.finished.with.warning=提交完成，有{0,choice,1#警告|2#警告}
message.text.background.tasks=正在等待背景 VCS 任務完成…
diff.title.local=本地
diff.title.local.with.number=本地({0})
message.title.annotate=註解
action.name.checkin.directory={0}{1,choice,1#目錄|2#目錄}
action.name.checkin.file={0}{1,choice,1#檔案|2#檔案}
action.for.file.with.dialog.text={0}{1, choice, 1#檔案|2#檔案}…
column.name.revision.list.author=作者
column.name.revisions.list.filter=日期
column.name.revisions.list.branch=分支
column.name.revision.list.revision=修訂
lookup.title.vcs.file.revisions=檔案修訂
border.selected.revision.commit.message=提交訊息
loading.file.history.progress=正在載入檔案歷史記錄
loading.text2.file.history.progress=正在載入檔案歷史記錄
loading.file.history.status=正在載入 {0} 的歷史記錄…
loading.file.history.up.to.revision.status=正在載入 {0} 截至 {1} 的歷史記錄…
message.title.could.not.load.file.history=載入檔案歷史記錄時發生問題
group.name.version.control=VCS(&V)
message.text.cannot.open.editor=無法打開檔案 {0} 的文本編輯器
message.title.cannot.open.editor=無法打開編輯器

#configuration
column.info.configure.vcses.directory=目錄
column.name.configure.vcses.vcs=VCS
checkbox.show.clear.read.only.status.dialog=如果嘗試編輯檔案，則提示解鎖設為唯讀的檔案
radio.after.deletion.do.not.remove=不移除
radio.after.deletion.show.options=詢問
radio.after.deletion.remove.silently=靜默移除
radio.after.creation.do.not.add=不添加
radio.after.creation.add.silently=靜默添加
radio.after.creation.show.options=詢問
checkbox.force.non.empty.messages=強制非空提交註釋(&E)
checkbox.clear.initial.commit.message=清除初始提交訊息(&I)
version.control.main.configurable.name=版本控制
action.name.show.difference=顯示差異
settings.filter.update.project.info.by.scope=按範圍篩選更新專案資訊
settings.partial.changelists.enable.checkbox=允許將一個檔案中的變更放入不同的變更列表(&P)
settings.show.conflict.resolve.dialog.checkbox=試圖編輯非活動變更列表中的檔案時顯示對話框(&D)
settings.highlight.files.with.conflicts.checkbox=高亮顯示存在變更列表衝突的檔案(&H)
settings.highlight.files.from.non.active.changelist.checkbox=高亮顯示非活動變更列表中的檔案(&I)
settings.files.with.ignored.conflicts.list.title=包含忽略衝突的檔案:
settings.inactive.changelist.group.title=非活動變更列表
settings.changelist.conflicts.group.title=衝突
#file view
action.name.show.files.as.tree=作為樹顯示
label.selected.revision.commit.message=提交訊息
column.name.revision.version=版本
column.name.revision.date=日期

#history
action.name.compare=比較
action.description.compare=比較版本
message.text.cannot.show.differences=無法顯示差異: {0}
message.title.show.differences=顯示差異
action.name.refresh=刷新
action.description.refresh=刷新檔案歷史記錄
action.name.get.file.content.from.repository=獲取
action.description.get.file.content.from.repository=從版本庫獲取版本
acton.name.get.revision=獲取修訂
action.name.create.patch=創建補丁…
action.description.create.patch.for.selected.revisions=為所選修訂創建補丁
message.title.get.version=獲取版本
message.text.cannot.load.revision=無法載入修訂: {0}
message.text.cannot.save.content=無法儲存內容: {0}
message.title.get.revision.content=獲取修訂內容
action.name.for.file.get.version={0}: 獲取版本 {1}
column.name.revision.list.date=日期
checkbox.show.changed.revisions.only=僅變更
progress.text.loading.patch.base.revision=正在載入補丁基礎修訂
diff.content.title.revision.number=修訂 {0}
command.name.open.error.message.view=打開訊息檢視
message.text.cannot.edit.file=無法編輯檔案: {0}
message.title.edit.files=編輯檔案
vcs.console.toolwindow.display.name=控制台
handle.ro.file.status.type.using.vcs=使用 {0}
message.text.file.is.up.to.date=檔案處於最新狀態
message.text.all.files.are.up.to.date=所有檔案都處於最新狀態
progress.text.synchronizing.files=正在同步檔案…
progress.text.updating.done=更新完成
progress.text.updating.canceled=更新已取消
message.title.vcs.update.errors={0}錯誤
update.tree.node.size.statistics={0,choice, 0#無條目|1#1 個條目|2#{0, number} 個條目}
toolwindow.title.update.project=更新專案({0})
action.name.group.by.packages=按軟體套件分組
message.text.cannot.save.settings=無法執行操作: {0}
action.name.check.status=檢查狀態(_K)
action.name.check.scope.status=檢查{0}狀態(_K)
action.display.name.check.scope.status=檢查{0}狀態
action.name.update=更新(_U)
action.display.name.update=更新
action.name.update.scope=更新{0}(_U)
action.display.name.update.scope=更新{0}
action.name.integrate=合併 (_G)
action.name.integrate.scope=合併 {0}(_G)
action.display.name.integrate.scope=集成{0}
update.files.scope.name=檔案
update.directory.scope.name=目錄
update.file.scope.name=檔案
update.directories.scope.name=目錄
update.project.scope.name=專案
dialog.title.changes.browser=變更瀏覽器
code.smells.error.messages.tab.name=程式碼分析
code.smells.error.indexing=現在無法進行程式碼分析
code.smells.error.indexing.message={0} 在背景更新索引時，無法執行程式碼分析。\\\\n\\\\
您可以在不執行檢查的情況下提交更改，也可以等到索引建立後再提交。
searching.for.code.smells.freezing.process=在簽入程式碼分析之前
checking.code.smells.progress.title=正在執行程式碼分析
before.commit.files.contain.code.smells.edit.them.confirm.text={0} 個檔案有問題。\\\\n\\\\
{1,choice, 0#無錯誤|1#1 個錯誤|2#{1} 個錯誤}，{2,choice, 0#無警告|1#1 個警告|2#{2} 個警告} \\\\n\\\\
要查看它們嗎?
before.commit.file.contains.code.smells.edit.them.confirm.text=檔案 {0} 有問題。\\\\n\\\\
{1,choice, 0#無錯誤|1#1 個錯誤|2#{1} 個錯誤}和{2,choice, 0#無警告|1#1 個警告|2#{2} 個警告}。\\\\n\\\\
要查看它們嗎?
code.smells.review.button=審查(&R)
todo.in.new.review.button=審查(&R)
before.checkin.standard.options.check.smells=分析程式碼(&A)
before.checkin.options.check.smells.profile=使用 ''{0}'' 配置檔案分析程式碼(&A)
before.checkin.options.check.smells.choose.profile=選擇配置檔案
before.checkin.waiting.for.smart.mode=正在等待智能模式…
before.checkin.new.todo.check=檢查 TODO ({0})
before.checkin.cleanup.code=清理(&L)
# Changes view
changes.nodetitle.unversioned.files=未進行版本管理的檔案
changes.nodetitle.locally.deleted.files=本地已刪除的檔案
changes.nodetitle.modified.without.editing=已修改，但未簽出的檔案
changes.nodetitle.ignored.files=已忽略的檔案
changes.nodetitle.locked.folders=鎖定的工作副本資料夾
changes.nodetitle.locked.folders.tooltip=某些資料夾已被鎖定；不允許對它們進行 VCS 操作。應執行清理。
changes.nodetitle.logicallt.locked.folders=明確鎖定的檔案
changes.nodetitle.switched.files=已切換的檔案
changes.nodetitle.switched.roots=根開關
changes.nodetitle.filter.pending=未篩選
changes.nodetitle.filtered.out=已篩選
changes.nodetitle.updating=正在更新…
changes.nodetitle.have.outdated.files=某些檔案在伺服器上已被更改
changes.nodetitle.empty.changelist.name=<空名稱>
change.nodetitle.change.is.outdated=檔案在伺服器上已被更改
changes.nodetitle.changecount={0,choice, 0#無檔案|1#1 個檔案|2#{0} 個檔案}
changes.nodetitle.directory.changecount={0,choice, 0#無目錄|1#1 個目錄|2#{0} 個目錄}
changes.nodetitle.directory.file.changecount={0,choice, 0#無目錄|1#1 個目錄|2#{0} 個目錄}，{1,choice, 0#無檔案|1#1 個檔案|2#{1} 個檔案}
changes.nodetitle.merge.conflicts=合併衝突
changes.nodetitle.merge.conflicts.resolve.link.label=解決
changes.default.changelist.name=變更
changes.action.show.ignored.text=顯示忽略的檔案
changes.action.show.ignored.description=顯示忽略的檔案
changes.dialog.newchangelist.title=新建變更列表
changes.dialog.editchangelist.title=編輯變更列表
changes.removechangelist.warning.text=確定要移除變更列表 ''{0}'' 嗎?\\\\n\\\\
所有變更都將移至活動變更列表。
changes.removechangelist.multiple.warning.text=確定要刪除{0}個變更列表？\\\\n\\\\
所有的變更將會移動到活動的變更列表中。
changes.removechangelist.warning.title=刪除變更列表
changes.removechangelist.all.lists.warning.text=確定要移除{0}個變更列表嗎?\\\\n\\\\
所有變更都將移動到新的預設變更列表。
scope.name.changelist.all.changed.files=所有更改的檔案
commit.dialog.no.changes.detected.text=未檢測到變更
commit.dialog.no.changes.detected.title=沒有要提交的內容
commit.dialog.title=提交變更
commit.dialog.default.commit.operation.name=Comm&it
commit.dialog.include.action.name=包含到提交裡(&I)
commit.dialog.failed.commit.template=提交失敗: {0}
commit.dialog.completed.successfully=已成功完成
commit.dialog.refresh.files=正在同步檔案…
commit.dialog.rejected.commit.template=拒絕提交: {0}
commit.dialog.changelist.label=變更列表(&T):
commit.dialog.partial.commit.warning.title=不支持部分提交
commit.dialog.partial.commit.warning.body=不支持 ''{0}'' 的部分提交。\\\\n\\\\
所選檔案中的所有變更都將提交。
commit.dialog.configurable=提交
change.list.manager.wait.lists.synchronization.modal={1, choice, 0#正在等待 |1#{0}: }本地變更刷新
change.list.manager.wait.lists.synchronization.background={1, choice, 0#正在等待 |1#{0}: }本地變更刷新
commit.wait.util.synched.text=正在執行 VCS 刷新…
edit.changelist.name=名稱(&N):
edit.changelist.description=註釋(&C):
changes.commit.partial.offer.to.move.text=提交時，您從活動變更列表中排除了某些檔案。\\\\n\\\\
要將剩餘變更移至其他變更列表嗎?
changes.commit.partial.offer.to.move.title=部分提交活動變更列表
checkbox.changelist.move.offer=建議將未提交的變更移至其他變更列表(&T)
checkbox.show.dirty.recursively=在專案樹中高亮顯示包含已修改檔案的目錄

commit.legend.modified=已修改
commit.legend.new=已添加
commit.legend.deleted=已刪除

commit.editor.diff.preview.title=提交: {0}
commit.editor.diff.preview.empty.title=提交

save.committing.files.confirmation.title=在提交期間儲存檔案
save.committing.files.confirmation.text=當前正在將以下{0,choice,1#檔案|2#檔案}提交到 VCS。立即儲存可能會導致提交的資料不一致。\\\\n\\\\
{1}\\\\n\\\\
立即儲存{0,choice,1#檔案|2#檔案}?
save.committing.files.confirmation.ok=立即儲存
save.committing.files.confirmation.cancel=延遲儲存

amend.commit.different.committer.warning=修正後提交的提交者與預設設定不同
amend.commit.load.details.task.title=正在載入提交詳細資訊
amend.commit.load.message.task.title=正在載入提交訊息
amend.commit.load.message.error.title=提交訊息未載入
amend.commit.load.message.error.text=無法載入待修正提交的提交訊息。
checkbox.amend=修正(_M)
label.by.author=作者

non.modal.commit.promoter.text=新的非強制回應提交介面可用。從工具視窗提交並在編輯器中查看差異。
non.modal.commit.promoter.use.non.modal.action.text=切換到工具視窗
non.modal.commit.promoter.dont.show.again.action.text=不再顯示
switch.to.commit.dialog.hint.text=要切換回“提交”對話框，請使用齒輪圖標下的選單

error.executing.commit=執行 ''{0}'' 時出錯: {1}
changes.action.rollback.title={0}變更
changes.action.rollback.custom.title={0}變更
changes.action.rollback.nothing=沒要有{0}的內容
changes.dialog.editchangelist.error.already.exists=名為 ''{0}'' 的變更列表已存在
error.adding.files.prompt=添加檔案時發生以下問題:
error.adding.files.title=無法添加檔案
column.name.revision.list.committer=使用者
column.name.revision.list.number=數字
column.name.revision.list.description=描述
browse.changes.nothing.found=未找到與條件符合的任何變更
browse.changes.nothing.found.title=未找到任何變更
browse.changes.progress.title=正在搜尋變更
browse.changes.error.title=無法顯示變更
browse.changes.error.message=存取 VCS 時發生問題: {0}
button.search.again=再次搜尋
browse.changes.filter.title=指定搜尋條件
changes.checkbox.delete.locally.added.files=刪除添加的檔案的本地副本(&D)
changes.action.rollback.text=回滾
patch.apply.file.name.field=補丁文件名(&P):
create.patch.commit.action.title=創建補丁
create.patch.commit.action.progress=正在創建補丁…
create.patch.error.title=創建補丁時出錯: {0}
create.patch.settings.dialog.title=補丁檔案設定
button.apply.patch=套用補丁
patch.apply.dialog.title=套用補丁
patch.apply.notification.title=套用補丁
filetype.patch.description=補丁
filetype.patch.display.name=補丁
patch.apply.conflict.for.title={0}的補丁衝突
patch.apply.conflict.title=補丁衝突
patch.apply.conflict.local.version=本地版本
patch.apply.conflict.merged.version=合併結果
patch.apply.conflict.patched.version=補丁版本
patch.apply.conflict.patched.somehow.version=結果
patch.apply.conflict.patch=補丁
patch.apply.select.title=選擇補丁檔案
patch.apply.before.patch.label.text=補丁前
patch.apply.after.patch.label.text=補丁後
patch.apply.aborted.title=套用補丁中止
patch.apply.aborted.message=“套用補丁”操作期間更改的所有檔案已被回滾
patch.apply.rollback.failed.title=回滾失敗
patch.apply.rollback.failed.message=嘗試使用“本地歷史記錄”對話框手動執行還原。
patch.apply.rollback.progress.title=回滾套用的變更…
patch.apply.rollback.progress=回滾套用的變更…
patch.apply.outside.content.root.message=在內容根外部找到補丁檔案: {0}
patch.apply.overwrite.existing.title=覆蓋現有檔案
patch.apply.overwrite.existing.files.prompt=以下檔案應通過補丁創建，但它們已經存在。\\\\n\\\\
要覆蓋它們嗎?
patch.apply.overwrite.existing.file.prompt=以下檔案應通過補丁創建，但它已經存在。\\\\n\\\\
要覆蓋嗎?\\\\n\\\\
{0}
patch.apply.file.type.directory.error=無法從補丁套用 {0} 檔案的內容，因為它是目錄。
patch.apply.file.type.undefined.error=無法從補丁套用 {0} 檔案的內容，因為它的類型未定義。
patch.apply.file.type.binary.error=無法從補丁套用 {0} 檔案，因為它是二進制檔案。
patch.apply.incorrectly.processed.warning=VCS 可能未正確處理以下{0, choice, 1#檔案|2#檔案}。\\\\n\\\\
請手動檢查{0, choice, 1#它|2#它們}: {1}
patch.apply.rollback.prompt=無法套用下面的{0, choice, 0#|1#檔案|2#檔案}。<br>是否要回滾套用的所有內容?
patch.apply.rollback.will.not.affect.binaries.info=回滾不會影響二進制檔案
patch.apply.partly.failed.title=補丁部分套用失敗
patch.apply.rollback.action=回滾
patch.apply.new.files.warning=套用補丁創建新檔案報錯
patch.apply.cannot.apply.now=現在無法套用補丁
patch.apply.abort.action=中止…
patch.apply.abort.and.rollback.prompt=中止並回滾套用補丁還是跳過此檔案?
patch.apply.abort.title=中止補丁
patch.apply.abort.and.rollback.action=中止並回滾(_A)
patch.apply.skip.action=跳過(_S)
patch.apply.continue.resolve.action=繼續解析
patch.apply.can.t.find.patch.file.warning=無法找到補丁檔案 {0}
patch.apply.not.patch.type.file.error=所選檔案 {0} 不是補丁類型檔案
patch.apply.can.not.apply.additional.info.error=無法套用附加補丁資訊: {0}
patch.apply.missing.base.file.label=缺少基
patch.apply.change.directory.paths.group=更改目錄路徑
patch.apply.cannot.read.patch=無法讀取補丁 {0}: {1}
patch.apply.map.base.directory.action=映射基目錄…
patch.apply.select.base.for.a.path.message=為路徑選擇基
path.apply.select.base.directory.for.a.path.popup=為路徑選擇基目錄
patch.apply.new.base.detected.node.description=檢測到新基
patch.apply.select.missing.base.link=選擇缺少的基
patch.apply.modified.status=已修改
patch.apply.deleted.status=已刪除
patch.apply.added.status=已添加
patch.apply.stripped.description=\\\\ 去除的{0}
patch.apply.old.new.base.info=更改前: {0} (基目錄: {1})<br/>更改後: {2} (基目錄: {3})
patch.apply.select.base.title=選擇{0, choice, 0#目錄|1#檔案}基
patch.apply.analyze.from.clipboard.on.the.fly.checkbox=實時分析和套用剪貼簿中的補丁
patch.apply.wrong.base.and.can.t.be.applied.warning={0} 的補丁的基錯誤，無法正確套用
patch.apply.already.exists.overwrite.prompt=檔案 {0} ({1}) 已存在。\\\\n\\\\
要覆蓋它嗎?
patch.apply.bad.diff.to.title=將補丁應用於 {0} 的結果
patch.apply.bad.diff.title=補丁套用的結果
patch.apply.already.applied.status=已套用
patch.apply.automatically.applied.status=已自動套用
patch.apply.not.applied.status=未套用
patch.apply.somehow.diff.name=以某種方式套用補丁
patch.apply.changes.in.patch.resolve=在補丁解析中{0}
patch.apply.display.local.content.was.modified.error=無法顯示補丁套用者 - 本地內容已修改
patch.content.viewer.name=補丁內容查看器
patch.apply.marker.renderer=標記: {0}
patch.apply.syntax.line=\\\\ (行: {0})
patch.apply.hunk.warning=無法檢測到下列項的區塊修改行: -{0},{1} +{2},{3}
patch.binary.decoder.content.error=解碼的二進制內容{0,choice,0#少於|1#多於}預期
patch.binary.decoder.line.error=無法編碼二進制檔案補丁: 行大小錯誤
patch.binary.decoder.char.error=無法解碼二進制檔案補丁: 字符大小符號錯誤
patch.binary.decoder.decompress.error=無法解碼二進制檔案補丁: 無法解壓縮資料
patch.simple.apply.base.line.error=意外的基行: 應為 - {0}，實際為 - {1}
patch.simple.apply.base.line.total.error=意外的基行: 總行數為 - {0}，實際為 - {1}
patch.simple.apply.hunk.base.start.error=意外的區塊基開始: 應為 - {0}，實際為 - {1}
patch.simple.apply.hunk.patched.start.error=意外的區塊補丁開始: 應為 - {0}，實際為 - {1}
patch.simple.apply.hunk.base.end.error=意外的區塊基結束: 總行數為 - {0}，區塊結束為 - {1}
patch.simple.apply.hunk.base.body.error=意外的區塊基主體: 應為 - {0}，實際為 - {1}
patch.simple.apply.hunk.patched.body.error=意外的區塊補丁主體: 應為 - {0}，實際為 - {1}
patch.simple.apply.hunk.content.error=意外的區塊內容: 應為 - {0}，實際為 - {1}
patch.copied.to.clipboard=補丁已複製到剪貼簿
patch.creation.failed=補丁創建失敗
patch.creation.save.patch.file.title=儲存補丁檔案
patch.creation.can.not.write.patch.error=無法將補丁寫入指定檔案: {0}
patch.creation.save.to.title=將補丁儲存到
patch.creation.save.to.file.button=將補丁儲存到檔案
patch.creation.base.path.field=基路徑(&B):
patch.creation.wrong.base.path.for.changes.error=基路徑不包含所有所選變更(使用 {0})
patch.creation.base.dir.does.not.exist.error=基目錄不存在
patch.creation.empty.base.path.error=基路徑不能為空!
patch.creation.name.too.long.error=檔案路徑不應過長。
patch.import.to.shelf.progress.title=將補丁匯入到 Shelf
patch.import.to.shelf.tab=將補丁匯入到 Shelf
patch.import.no.patches.found.warning=未找到補丁
patch.import.additional.info.error=無法匯入附加補丁資訊: {0}
action.import.to.shelf=匯入到 Shelf
shelve.changes.action=托管更改(_S)
shelve.changes.progress.title=正在擱置更改
shelve.changes.progress.text=正在擱置變更…
shelve.deletion.title=Shelf 刪除
shelve.file.is.locked.for.editing.message=在擱置期間檔案已鎖定，無法編輯
shelve.remove.successfully.applied.files.checkbox=從 Shelf 移除成功套用的檔案
shelve.clean.unshelved.changelists.title=清理取消擱置的變更列表
shelve.clean.changelists.older.than.one.button=超過 1
shelve.clean.changelists.all.button=所有
shelve.clean.timeperiod.week=周
shelve.clean.timeperiod.month=月
shelve.clean.timeperiod.year=年
shelve.delete.already.unshelved.label=刪除已擱置的變更列表:
shelve.base.content.not.found.or.not.applicable.error=基內容未找到或不適用。顯示與本地版本的差異
shelve.shelved.version=擱置的版本
shelve.import.one.patch.file.prompt=找到一個補丁檔案({0})。\\\\n\\\\
繼續匯入?
shelve.import.patches.prompt=找到 {0} 個補丁檔案。\\\\n\\\\
繼續匯入?
shelve.hide.already.unshelved.action=隱藏已取消擱置變更
shelve.show.already.unshelved.action=顯示已取消擱置變更
shelve.delete.files.successful.message={0,choice, 1#1 個檔案|2#{0} 個檔案}
shelve.delete.changelists.message={0,choice, 1#1 個變更列表|2#{0} 個變更列表} {1}
shelve.delete.successful.message=已成功刪除 {0}{1,choice, 0#|1# 和 }{2}
shelve.undo.deletion=撤消 Shelf 刪除
shelve.recently.deleted.node=最近刪除項
shelve.changelist.not.found=未找到擱置的變更列表 {0}
shelve.default.path.rendering=<專案根>
shelve.copying.shelves.to.progress=正在將擱置複製到新目錄…
shelve.moving.failed.prompt=Shelf 移動失敗。<br/>要使用新的 Shelf 目錄路徑還是將其還原為上一個路徑?
shelve.error.title=Shelf 錯誤
shelve.use.new.directory.button=使用新路徑(&U)
shelve.revert.moving.button=還原(&R)
shelve.import.to.progress=正在處理 
shelve.delete.files.from.changelist.error=無法從 {0} 刪除檔案
shelve.failed.title=擱置失敗
shelve.failed.message={0,choice,1#變更列表|2#變更列表} [{1}] 的變更擱置失敗
shelve.successful.message=已成功擱置變更
unshelve.loading.patch.error=無法載入補丁: {0}
unshelve.changes.action=取消托管更改
patch.apply.already.applied=指定補丁的所有變更均已包含在程式碼中
patch.apply.partially.applied=指定補丁的某些變更已被跳過，因為它們已包含在程式碼中
patch.apply.success.applied.text=已成功套用補丁
patch.apply.command=套用補丁
patch.apply.progress.title=正在套用補丁…
shelve.changes.restore.error=無法完全還原{0, choice, 1#擱置的變更列表|2# {0} 個擱置的變更列表}，因為某些檔案已被永久刪除
create.patch.success.confirmation=已成功創建補丁 {0}
shelve.changes.only.directories=所選變更僅影響目錄，不影響檔案，因此無法擱置它們
shelve.editor.diff.preview.title=擱置: {0}
stash.changes.message=在{0}之前未提交的更改
stash.changes.message.with.date=在進行{0}之前於 {1} 取消提交了變更
edit.errors=編輯錯誤
rollback.modified.without.editing.confirm.single=要將變更{0}到{1}嗎?
rollback.modified.without.editing.confirm.multiple=要將變更{0}到 {1} 個所選檔案嗎?
error.updating.changes=更新變更時出錯: {0}
no.ignored.files=沒有忽略的檔案
ignored.file.tab.title=已忽略的檔案
ignored.file.general.settings.title=常規設定
ignored.file.manage.policy.label=忽略檔案管理策略
ignored.file.manage.always.ask.option=始終詢問
ignored.file.manage.all.projects.option=為所有專案管理
ignored.file.manage.this.project.option=僅為此專案管理
ignored.file.not.manage.this.project.option=不只為此專案管理
ignored.file.not.manage.option=關閉套用範圍
ignored.file.excluded.settings.title=排除目錄管理策略
ignored.file.excluded.to.ignored.label=將排除目錄添加到忽略檔案
ignored.file.ignored.to.excluded.label=將忽略目錄標記為已排除
ignored.file.manage.view=查看
ignored.file.manage.with.files.message={0} 可以自動將經常被忽略的檔案添加到 {1}。
ignored.file.manage.message={0} 可以自動將經常被忽略的檔案添加到 {1}。
ignored.file.manage.this.project=在此專案中
ignored.file.manage.all.project=在所有專案中
ignored.file.manage.notmanage=不添加
ignored.file.manage.view.dialog.title=將檔案添加到忽略
ignored.file.manage.view.dialog.ignore.action=忽略(&I)
ignoring.files.progress.title=正在忽略檔案…
browse.changes.content.title={0}下的變更
browse.changes.no.filter.prompt=尚未指定任何篩選條件。確定要查看專案的整個歷史記錄嗎?
browse.changes.title=瀏覽變更
browse.changes.show.all.button=顯示所有變更
browse.changes.show.recent.button=顯示最近的變更
new.changelist.make.active.checkbox=設為活動(&A)
new.changelist.new.label=新建
move.to.another.changelist.nothing.selected.notification=沒有選擇任何可以移動的專案
composite.change.provider.include.vcs.checkbox=包含{0}中的變更
shelf.tab=擱置
directory.mapping.remove.title=編輯 VCS 目錄映射
directory.mapping.add.title=添加 VCS 目錄映射
settings.vcs.mapping.browser.select.directory.title=選擇目錄
settings.vcs.mapping.browser.select.directory.description=選擇要映射到 VCS 的目錄
settings.vcs.mapping.status.looking.for.vcs.administrative.area=正在尋找 VCS 管理區域
settings.vcs.mapping.invalid.vcs.options.error=無效的 VCS 選項: {0}
settings.vcs.mapping.project.description=所有模組的內容根，以及專案基目錄的所有直接後代
settings.vcs.mapping.project.description.with.idea.directory=所有模組的內容根、專案基目錄的所有直接後代以及 {0} 目錄內容
unshelve.changelist.chooser.title=取消擱置變更列表的變更
revert.changes.changelist.chooser.title=選擇目標變更列表
retrieving.annotations=正在載入註解
multiple.file.merge.title=衝突
multiple.file.merge.accept.yours=接受您的變更(&Y)
multiple.file.merge.accept.theirs=接受他們的(&T)
multiple.file.merge.merge=合併(&M)…
multiple.file.merge.column.name=名稱
multiple.file.merge.request.title=合併 {0} 的修訂
multiple.file.merge.loading.progress.title=正在載入合併修訂…
multiple.file.merge.group.by.directory.checkbox=按目錄對檔案分組
unknown.vcs.presentation=<未知 VCS> ({0})
show.diff.progress.title=正在載入內容
# suppress inspection \\"UnusedProperty\\": used by 3-party plugins
show.diff.progress.title.detailed=正在載入 {0} 的內容
new.changelist.duplicate.name.error=具有該名稱的變更列表已存在
new.changelist.empty.name.error=無法使用空名稱創建新的變更列表
# suppress inspection \\"UnusedProperty\\": used by 3-party plugins
browse.changes.action=瀏覽變更
# suppress inspection \\"UnusedProperty\\": used by 3-party plugins
browse.changes.scope=影響 {0} 的變更
rollback.modified.without.checkout.error.tab={0}未簽出時進行了修改
annotate.action.name=註解
annotate.action.description=註解檔案
operation.name.annotate=註解
changes.remove.active.prompt=選擇應將變更移至其中的變更列表:
changes.remove.active.empty.prompt=選擇要設為活動的變更列表:
changes.remove.active.title=刪除活動變更列表
create.patch.loading.content.progress=正在載入內容修訂
create.patch.reverse.checkbox=反轉補丁(&R)
create.patch.file.path=到檔案(&P):
create.patch.to.clipboard=到剪貼簿(&C)
create.patch.encoding=編碼(&E):
committed.changes.refresh.progress=正在刷新 VCS 歷史記錄
cache.settings.dialog.title=VCS 歷史記錄快取設定
changes.browser.details.marker=更多…
changelist.details.title=變更列表詳細資訊
date.group.title=日期
date.group.today=今天
date.group.last.week=過去一周
user.group.title=使用者
filter.structure.name=結構
filter.none.name=無
issue.link.issue.column=問題
issue.link.link.column=鏈接
issue.link.add.title=添加問題導航鏈接
issue.link.edit.title=編輯問題導航鏈接
issue.link.delete.prompt=刪除所選導航鏈接?
issue.link.delete.title=刪除問題導航鏈接
issue.link.no.patterns=未配置模式
issue.action.add.jira.issue.navigation.pattern.title=添加 JIRA 問題導航模式
issue.action.enter.jira.installation.url.label=輸入 JIRA 安裝 URL:
issue.action.add.youtrack.issue.navigation.pattern.title=添加 YouTrack 問題導航模式
issue.action.enter.youtrack.installation.url.label=輸入 YouTrack 安裝 URL:
add.issue.dialog.invalid.regular.expression=無效的正則表達式: {0}
add.issue.dialog.issue.link.label=問題鏈接:
add.issue.dialog.issue.id.label=問題 ID:
add.issue.dialog.issue.example.border.title=範例
add.issue.dialog.issue.link.replacement.expression=問題鏈接 (取代表達式):
add.issue.dialog.issue.id.regular.expression=問題 ID (正則表達式):
add.issue.dialog.issue.no.match=<無符合>
committed.changes.empty.comment=<無註釋>
committed.changes.filter.all=所有
committed.changes.filter.none=<無>
committed.changes.partial.list=[部分]
update.info.loading.changelists=正在載入變更列表…
update.info.group.by.changelist=按變更列表分組
update.info.click.status.text.prefix=點擊
update.info.to.initialize.status.text.suffix=以初始化版本庫變更快取
update.info.refresh.link.status.text=刷新
outdated.version.show.diff.action=顯示差異
outdated.version.update.project.action=更新專案
# 0 - author, 1 - pretty date, 2 - commit message, 3 - deletion/modification
outdated.version.text=過時的版本。{0} 在 {1} {3,choice,0#修改|1#刪除}了以下訊息: {2}
current.version.text={4}<br/><br/>當前版本為 {3}。<br/>修改者為 {0}<br/>{1}<br/>{2}
committed.changes.filter.title=篩選依據
committed.changes.group.title=分組依據
committed.changes.regex.title=正則表達式(&G)
changelist.details.committed.format=由 {0} {1} 提交
incoming.changes.indicator.tooltip={0} 個可用的傳入變更列表
# suppress inspection \\"UnusedProperty\\": used by 3-party plugins
committed.changes.incorrect.regex.message=篩選器中使用的正則表達式無效
committed.changes.empty.message=版本庫沒有提交的變更
committed.changes.not.loaded.message=按“刷新”按鈕以載入版本庫變更
incoming.changes.not.loaded.message=按“刷新”按鈕以載入傳入的變更
incoming.changes.empty.message=沒有傳入的變更

show.history.action.name.template=顯示 {0} 的歷史記錄(_F)
show.history.dialog.title.template={0} 的歷史記錄
action.name.show.history.for.selection=選區
action.name.show.history.for.class=類
action.name.show.history.for.field=欄位
action.name.show.history.for.method=方法
action.name.show.history.for.function=函數
action.name.show.history.for.code.block=程式碼塊
action.name.show.history.for.statement=語句
open.repository.version.text=打開版本庫版本
open.repository.version.description=在編輯器中打開檔案的所選修訂
edit.source.action.text=編輯源
local.history.update.from.vcs=從 VCS 更新
create.changelist.on.failed.commit=在提交失敗時創建變更列表:
commit.failed.confirm.prompt=要將提交失敗的檔案移至單獨的變更列表嗎?
commit.failed.confirm.title=提交失敗
unshelve.changes.dialog.title=取消擱置變更
unshelve.changes.progress.title=正在取消擱置變更…
shelved.version.name=擱置的版本
patched.version.name=補丁版本
local.version.title=本地版本
change.file.renamed.from.text=- 已從 {0} 重命名
change.file.moved.from.text=- 已從 {0} 移動
change.file.copied.from.text=- 已從 {0} 複製
change.file.replaced.text=- 已取代
change.file.renamed.to.text=- 已重命名為 {0}
change.file.moved.to.text=- 已移至 {0}
cannot.create.directory.for.patch=無法創建檔案: {0}. {1}
cannot.find.file.to.patch=找不到要套用補丁的檔案: {0}
cannot.apply.file.already.exists=無法將補丁套用到檔案 {0}: 它已存在。
change.lists.manager.add.unversioned=添加未進行版本管理的檔案
vcs.shelf.action.restore.text=恢復
vcs.shelf.action.restore.description=恢復最近刪除的{0, choice, 1#變更列表|2#變更列表}
vcs.shelf.move.text=將擱置變更移動到新位置
vcs.shelf.store.base.content=擱置分布式版本控制系統下檔案的基本修訂版本
vcs.shelving.changes=正在擱置變更…
vcs.unshelving.changes=正在取消擱置變更…
vcs.unshelving.conflict.left=您未提交的變更
vcs.unshelving.conflict.right=遠端變更
action.enable.version.control.integration.text=啟用版本控制集成(_E)…
dialog.enable.version.control.integration.title=啟用版本控制集成
dialog.enable.version.control.integration.select.vcs.label.text=選擇要與 {0} 關聯的版本控制系統:
dialog.enable.version.control.integration.hint.text=可在以下位置配置版本控制設定 
confirmation.title.add.file.to=將檔案添加到 {0}?
confirmation.title.add.files.to=將檔案添加到 {0}?
confirmation.title.add.ignored.single.file=確認添加忽略的檔案
confirmation.title.add.ignored.single.directory=確認添加忽略的目錄
confirmation.message.add.ignored.single.file=添加忽略的檔案?
confirmation.message.add.ignored.single.directory=添加忽略的目錄?
confirmation.title.add.ignored.files.or.dirs=確認添加忽略檔案和目錄
waiting.changelists.update.for.show.commit.dialog.message=提交
rolling.back.file=正在回滾{0}
annotation.original.revision.text=修訂: {0}
annotation.switch.to.original.text=隱藏合併原始碼
annotation.switch.to.merged.text=顯示合併原始碼
switch.to.changelist=切換到變更列表(''{0}'')(&T)
move.to.changelist=將變更移至活動變更列表(''{0}'')(&M)
vcs.config.track.changed.on.server=檢查與伺服器衝突的時間間隔
vcs.quicklist.popup.title=VCS 操作
action.Vcs.Toolbar.QuickListPopupAction.text=VCS 操作
options.check.changed.on.server.title=“在伺服器上已更改”衝突
line.annotation.aspect.author=作者
line.annotation.aspect.date=日期
line.annotation.aspect.revision=修訂
annotation.commit.number=提交編號
annotation.wrong.line.number.notification.text=<html>由 {0} 註解的行數與檔案中的行數不相等。請檢查檔案編碼和行分隔符。</html>
lst.inactive.ranges.damaged.notification=部分變更已移動到活動變更列表
todo.handler.only.skipped=<html><body>TODO 檢查已經跳過 {0,choice, 0#|1#單個檔案|2#{0}多個檔案}.<br/>沒有新的,編輯,或位於片段的 TODO 項改變發現。</body></html>
todo.handler.only.added=<html><body>發現{0,choice, 0#|1#一|2#{0}}個已被添加或編輯的 TODO {0,choice, 0#|1#專案|2#專案}。<br/>您是否想查看{0,choice,1#它|2#它們}?<br/>{1,choice, 0#|1#1個檔案被跳過。|2#{1} 個檔案被跳過。}</body></html>
todo.handler.only.in.changed=<html><body>{0,choice, 1#一|2#{0}}個 TODO {0,choice, 1#項|2#項} 在已改變的片段中找到。<br/>您是否需要查閱{0,choice,1#它|2#它們}?<br/>{1,choice, 0#|1#一個檔案被跳過|2#{1} 個檔案被跳過。}</body></html>
todo.handler.only.both=<html><body>{0, choice, 1#一|2#{0}}個添加/編輯到 TODO {0,choice, 1#專案|2#專案},<br/>並且 {1, choice, 1#一個專案|2#{1}專案} 未在變更的片段中找到。<br/>您是否項查閱它們?<br/>{2,choice, 0#|1#一個檔案被跳過。|2#{2}個檔案被跳過。}</body></html>
label.todo.items.found={0} 個 TODO

paths.affected.in.revision={0} 中的變更

executable.select.label={0} 可執行檔案路徑(&P):
executable.select.title=選擇可執行檔案
executable.test=測試
executable.project.override=僅為當前專案設定此路徑
executable.project.override.reset.title=專案可執行檔案
executable.project.override.reset.message=為此專案配置的可執行檔案路徑既可以設為所有專案的全域路徑，也可以還原為當前全域可執行檔案
executable.project.override.reset.globalize=設為全域
executable.project.override.reset.revert=還原

project.configuration.files.add.notification.message=專案配置檔案可以添加到 {0}
project.configuration.files.add.notification.action.view=查看檔案
project.configuration.files.add.notification.action.add=始終添加
project.configuration.files.add.notification.action.mute=不再詢問
project.configuration.files.view.dialog.title=將檔案添加到 {0}

external.files.add.notification.message=外部添加的檔案可以添加到 {0}
external.files.add.notification.action.view=查看檔案
external.files.add.notification.action.add=始終添加
external.files.add.notification.action.mute=不再詢問
external.files.add.view.dialog.title=將檔案添加到 {0}

ignore.to.exclude.notification.message=部分忽略的目錄未從索引和搜尋中排除
ignore.to.exclude.notification.notice=<html><b>注</b>: 建議在排除之前重新檢查目錄內容。一些目錄可能包含不應排除的項。</html>
ignore.to.exclude.notification.action.view=查看目錄
ignore.to.exclude.notification.action.mute=不再詢問
ignore.to.exclude.notification.action.details=了解更多
ignore.to.exclude.view.dialog.title=排除目錄
ignore.to.exclude.view.dialog.exclude.action=排除(&E)
ignore.to.exclude.no.directories.found=未找到要排除的目錄

# suppress inspection \\"UnusedProperty\\": dynamic property key
ignoreTokenType./=<斜杠>
# suppress inspection \\"UnusedProperty\\": dynamic property key
ignoreTokenType.BRACKET_LEFT=<左括號>
# suppress inspection \\"UnusedProperty\\": dynamic property key
ignoreTokenType.BRACKET_RIGHT=<右括號>
# suppress inspection \\"UnusedProperty\\": dynamic property key
ignoreTokenType.COMMENT=<註釋>
# suppress inspection \\"UnusedProperty\\": dynamic property key
ignoreTokenType.CRLF=<空行>
# suppress inspection \\"UnusedProperty\\": dynamic property key
ignoreTokenType.HEADER=<標題>
# suppress inspection \\"UnusedProperty\\": dynamic property key
ignoreTokenType.SECTION=<部分>
# suppress inspection \\"UnusedProperty\\": dynamic property key
ignoreTokenType.VALUE=<值>
# suppress inspection \\"UnusedProperty\\": dynamic property key
# suppress inspection \\"WrongPropertyKeyValueDelimiter\\"
ignoreTokenType.syntax:=<語法>

ignore.codeInspection.group=版本控制
ignore.codeInspection.duplicateEntry=忽略檔案重複項
ignore.codeInspection.duplicateEntry.message=<code>#ref</code> 模式不止定義一次 #loc
ignore.quick.fix.remove.entry=移除模式

vcs.add.to.ignore.file.action.group.text=添加到 {0}
vcs.add.to.ignore.file.action.group.description=將所選檔案添加到 {0}
vcs.add.to.ignore.file.create.ignore.file.confirmation.title=創建 {0}
vcs.add.to.ignore.file.create.ignore.file.confirmation.message=在 {1} 中創建 {0} 檔案?

#Annotate actions
annotate.action.view.group.text=檢視

prefer.commit.timestamp.action.text=顯示提交時間戳
prefer.commit.timestamp.action.description=顯示提交變更的時間，而不是創建時間。
configurable.ChangelistConflictConfigurable.display.name=變更列表
configurable.VcsDirectoryConfigurationPanel.display.name=目錄映射
configurable.VcsGeneralConfigurationConfigurable.display.name=確認
configurable.IssueNavigationConfigurationPanel.display.name=問題導航
configurable.VcsContentAnnotationConfigurable.display.name=顯示最近更改
vcs.operations.popup=VCS 操作彈出視窗
vcs.local.changes.toolbar=VCS 本地變更工具欄
vcs.log.changes.browser.toolbar=VCS 日誌更改瀏覽器工具欄
settings.checkbox.limit.history.to=將歷史記錄限制為
settings.checkbox.rows=行
settings.limit.history.to.n.rows.label=將歷史記錄限制為 {0} 行
settings.checkbox.show.changed.in.last=高亮顯示以下時間內更改的檔案:
settings.checkbox.measure.days=天
settings.show.changed.in.last.n.days.label=顯示過去 {0} 天的變更
settings.check.every.minutes=分鐘的更改項
settings.show.unversioned.files=顯示未進行版本管理的檔案
settings.commit.message.inspections=提交訊息檢查
inspection.SubjectBodySeparationInspection.display.name=主題與正文之間的空白行
inspection.BodyLimitInspection.display.name=限制正文行
inspection.CommitMessageSpellCheckingInspection.display.name=拼寫
inspection.SubjectLimitInspection.display.name=限制主題行
settings.commit.without.dialog=使用非強制回應提交介面
settings.confirmation.option.text.ask=詢問
settings.confirmation.option.text.no=否
settings.confirmation.option.text.yes=是
settings.commit.without.dialog.applies.to.git.mercurial=套用到 Git 和 Mercurial 下的專案
settings.filter.configure.link=配置
radio.restore.workspace.on.branch.switching=切換分支時恢復工作區(&B)
settings.when.files.are.deleted=當檔案被刪除時:
settings.border.when.files.are.created=當檔案被創建時:
settings.file.status.color.modified.in.not.active.changelist=已在非活動變更列表中修改
settings.file.status.color.added.in.not.active.changelist=已在非活動變更列表中添加
settings.file.status.color.changelist.conflict=變更列表衝突
settings.issue.navigation.patterns={0} 將在簽入註釋中搜尋指定的模式，並將它們鏈接到問題跟踪器中的問題:
settings.shelf.content.larger=大於 {0}K 的檔案的基內容不會被存儲
settings.change.shelves.location=更改擱置位置…
change.shelves.location.dialog.title=更改擱置位置
change.shelves.location.dialog.action.button=更改位置
change.shelves.location.dialog.group.title=將擱置存儲於:
change.shelves.location.dialog.location.browser.title=選擇要將擱置存儲在其中的目錄
change.shelves.location.dialog.default.label=預設目錄:
change.shelves.location.dialog.custom.label=自訂目錄:
settings.current.location=當前位置為
settings.default.location=預設位置為 
settings.auto.detected=自動檢測:
checkbox.include.issues.not.assigned.to.me=包括未分配給我的問題
checkbox.select.current.file.only=僅選擇當前檔案
action.Anonymous.text.restore.all.leading.directories=恢復所有前導目錄
action.Anonymous.text.remove.all.leading.directories=移除所有前導目錄
action.SearchFieldAction.text.find=尋找: 
action.DumbAware.ApplyPatchDifferentiatedDialog.text.refresh=刷新
action.DumbAware.ApplyPatchDifferentiatedDialog.description.refresh=刷新
action.NotificationAction.VcsRootProblemNotifier.text.enable.integration=啟用集成
action.NotificationAction.VcsRootProblemNotifier.text.ignore=忽略
action.NotificationAction.VcsRootProblemNotifier.text.configure=配置…
action.NotificationAction.AllVcses.text.install=安裝
action.NotificationAction.AllVcses.text.read.more=閱讀更多
action.NotificationAction.AllVcses.text.open.plugin.page=打開“套件”頁面
action.NotificationAction.InactiveRangesDamagedNotification.text.view.changes=查看變更…
action.AnActionButton.text.add.jira.pattern=添加 JIRA 模式
action.AnActionButton.text.add.youtrack.pattern=添加 YouTrack 模式
action.ToggleAction.text.show.unversioned.files=顯示未進行版本管理的檔案
action.ToggleAction.text.preview.diff=預覽差異
action.ToggleAction.text.show.details=顯示詳細資訊
action.ToggleAction.description.show.details=顯示詳細資訊面板
action.ToggleAction.text.scope.filter=範圍篩選器
action.DumbAwareAction.text.compare.with.local.content=與本地內容比較
action.NotificationAction.VFSListener.text.view.files=查看檔案…

action.ImportIntoShelfAction.text=匯入補丁…
action.ImportIntoShelfAction.description=將補丁檔案複製到擱置
action.presentation.ApplySelectedChangesAction.text=接受
action.presentation.IgnoreSelectedChangesAction.text=忽略
action.presentation.DiffShelvedChangesWithLocalActionProvider.description=將擱置版本與當前版本進行比較
action.presentation.ShowUpdatedDiffActionProvider.description=更新前顯示與版本的差異
button.clear=清除
import.patches.into.shelf=將補丁匯入到擱置…
import.patches=匯入補丁
looking.for.patch.files=正在尋找補丁檔案…

title.load.revision.contents=載入修訂內容
message.read.only.status.title={0}: 無法看到唯讀狀態
message.read.only.status.content=您以 <b>root</b> 身份登錄，因此: <br><br>- {0} 無法看到檔案的唯讀狀態。<br>- 所有檔案都被視為可寫入。<br>- 修改時無法自動簽出檔案。
action.clone.dialog.stub.click.to.continue=點擊“{0}”繼續
vcs.generic.name=VCS
vcs.generic.name.with.mnemonic=VCS(_S)
vcs.common.labels.directory=目錄:
vcs.common.labels.vcs=VCS:
vcs.common.labels.version.control=版本控制:
vcs.common.labels.url=URL:
settings.commit.message.right.margin.label=右邊距:
settings.commit.message.show.right.margin.label=顯示右邊距
settings.commit.message.show.right.margin.n.columns.label=顯示 {0} 列中的右邊距
settings.commit.message.body.add.blank.line.fix=添加空白行
get.from.version.control=從版本控制獲取
clone.dialog.repository.url.item=版本庫 URL
clone.dialog.clone.button=克隆
clone.dialog.unable.create.destination.error=無法創建目標目錄
clone.dialog.clone.failed.error=克隆失敗
committed.changes.tab=版本庫
incoming.changes.tab=傳入
local.changes.tab=本地變更
error.cant.perform.operation.now=現在無法{0}
local.changes.freeze.message={0}完成之前，本地變更不可用

file.history.checking.last.revision.process=正在檢查最新修訂
file.history.diff.revisions.process=正在比較修訂…
file.history.exceeded.limit.message=檔案歷史記錄: 僅為 {1} 載入了 {0} 個修訂\\\\n\\\\
要更改歷史記錄限制，請轉到 {2}
file.history.details.empty.status=提交訊息
file.history.details.hash.author.on.date.at.time={0} {1}，{2} {3}
file.history.details.committer.info=由 {0} 提交
file.history.details.committer.tooltip.info=通過 {0}
file.history.diff.handler.paths.diff.title={0} 與 {2} 中的 {1} 之間的差異
file.history.diff.handler.paths.diff.with.local.title={0} 與 {1} 中的本地版本之間的差異
file.history.diff.handler.affected.changes.title={1} 中的初始提交 {0}
file.history.diff.handler.collecting.affected.process=正在收集受影響的變更…
file.history.diff.handler.comparing.process=正在比較修訂…
file.history.diff.handler.process.error=任務期間出錯: {0}

selection.history.loading.revision.status=正在載入修訂 {0}…
selection.history.commit.message.label=提交訊息:
selection.history.local.revision.text=本地變更
selection.history.can.not.load.message=無法載入修訂內容

vcs.update.tab.name=更新資訊
file.history.tab.name=歷史記錄

vcs.commit.files.committed={0,choice,1#{0} 個檔案|2#{0} 個檔案}已提交
vcs.commit.files.committed.and.files.failed.to.commit={0,choice,1#{0} 個檔案|2#{0} 個檔案}已提交，{1,choice,1#{1} 個檔案|2#{1} 個檔案}提交失敗
vcs.commit.canceled=提交已取消

checking.vcs.status.progress=正在檢查 VCS 狀態…

notification.showDetailsInConsole = 在控制台中顯示詳細資訊

unregistered.roots.label=未註冊的根:
copy.revision.number.action=複製修訂號

annotations.color.mode.author=作者
annotations.color.mode.order=順序
annotations.color.mode.hide=隱藏
annotations.color.mode.group.colors=顏色
annotations.short.name.type.initials=初始
annotations.short.name.type.first.name=名
annotations.short.name.type.last.name=姓
annotations.short.name.type.full.name=全名
annotations.short.name.type.group.names=姓名

commit.description.tooltip.commit=提交 {0}
commit.description.tooltip.author=作者: {0}
commit.description.tooltip.date=日期: {0}
commit.description.tooltip.path=路徑: {0}

settings.version.control.option.group=版本控制
settings.commit.message.option.group=提交訊息
settings.commit.option.group=提交
settings.changelists.option.group=變更列表
settings.confirmation.option.group=確認
dialog.title.files.created=檔案已創建
label.select.files.to.be.added.to.version.control=選擇要添加到版本控制中的檔案
dialog.title.cannot.convert.module=無法轉換模組
dialog.title.select.destination.folder=選擇目標資料夾
dialog.message.enter.directory.name=為創建的專案輸入目錄名稱。留空可直接簽出到“{0}”。
dialog.title.project.directory.name=專案目錄名稱
progress.title.hey=嗨
progress.title.version.control.processing.changed.files=版本控制: 正在處理更改的檔案
dialog.message.can.t.create.text.editor.for=無法為 {0} 創建文本編輯器
link.label.display.anyway=仍然顯示
link.label.hide=隱藏
action.ShowAffectedFilesAction.show.affected.files.text=顯示受影響的檔案
progress.title.loading.current.revision=正在載入當前修訂…
dialog.title.remove.empty.changelist=移除空變更列表
button.remove=移除
checkbox.remember.my.choice=記住我的選擇(&R)
action.ChangesViewToolWindowPanel.text=檢視選項
notification.title.couldn.t.save.uncommitted.changes=無法儲存未提交的變更。
dialog.title.ignored.files=已忽略的檔案
dialog.title.unversioned.files=未進行版本管理的檔案
button.skip=跳過
progress.text.performing={0}: 正在執行 {1}…
action.message.use.selected.changes.description={0}所選變更
progress.text.performing.rollback={0}: 正在執行回滾…
progress.title.adding.files.to.vcs=正在將檔案添加到 VCS…
notification.content.didn.t.update.repository.changes=由於發生錯誤，未使用新消息更新版本庫變更: {0}
progress.title.discovering.location=正在發現 {0} 的位置
dialog.title.resolve.changelist.conflict=解決變更列表衝突
link.label.move.changes=移動變更
link.label.switch.changelist=切換變更列表
dialog.message.no.changes.for.this.file=此檔案沒有變更
dialog.title.message=訊息
link.label.ignore=忽略
tooltip.show.options.dialog=顯示選項對話框
dialog.message.conflict.seems.to.be.resolved=衝突似乎已解決
dialog.title.no.conflict.found=未找到衝突
dialog.title.move.changes.to.active.changelist=將變更移至活動變更列表
checkbox.include=包含(&I)
status.text.unversioned.files.available=未進行版本管理的檔案可用。
plugins.configurable.show=status.text.Show

action.filter.filter.by.text=篩選依據
action.filter.moved.files.text=隱藏移動時未更改的檔案
action.filter.non.important.files.text=隱藏包含不重要更改的檔案

group.mainmenu.vcs.current.file.text=當前檔案

multiple.file.merge.dialog.progress.title.resolving.conflicts=正在解決衝突…
multiple.file.merge.dialog.message.error.saving.merged.data=儲存合併資料時出錯: {0}
multiple.file.merge.dialog.command.name.accept.yours=接受您的變更
multiple.file.merge.dialog.command.name.accept.theirs=接受他們的變更
multiple.file.merge.dialog.progress.title.loading.revisions=正在載入修訂…
multiple.file.merge.dialog.error.loading.revisions.to.merge=載入待合併修訂時出錯: {0}
multiple.file.merge.dialog.message.file.too.big.to.be.loaded=檔案過大，無法載入
multiple.file.merge.dialog.title.can.t.show.merge.dialog=無法顯示“合併”對話框

text.commit.message.truncated.by.ide.name={0}\\\\n\\\\
\\\\n\\\\
…提交訊息過長，被 {1} 截斷…
label.project.vcs.root.mapping=<專案>
label.relative.project.path.presentation=<專案>/{0}
file.content.too.big.to.load.increase.property.suggestion=無法顯示 ''{0}'' 的內容。\\\\n\\\\
該檔案大小大於 {1}。\\\\n\\\\
\\\\n\\\\
您可以通過在 ''idea.properties'' 檔案中增大{2}屬性來覆寫此限制。
error.date.before.must.be.a.valid.date=之前的日期必須是有效日期
error.date.after.must.be.a.valid.date=之後的日期必須是有效日期
error.change.from.must.be.a.valid.number=起始日期必須是有效數字
error.change.to.must.be.a.valid.number=變更物件必須是有效數字

action.annotate.revision.text=註解修訂
action.annotate.selected.revision.in.new.tab.description=在新頁籤中註解所選修訂
action.annotate.previous.revision.text=註解前一個修訂
action.annotate.successor.selected.revision.in.new.tab.description=在新頁籤中註解所選修訂的後繼者
notification.title.cant.load.annotations=無法載入註解
hide.this.notification=隱藏此通知
vcs.error.failed.to.load.file.content.from.vcs=無法載入內容
diff.producer.error.cant.get.revision.content=無法獲取修訂內容
show.diff.from.annotation.action.error.can.not.load.data.to.show.diff=無法載入資料以顯示差異
vcs.preview.panel.added.ignored.line=已添加忽略的行
vcs.preview.panel.modified.ignored.line=已修改忽略的行
vcs.preview.panel.deleted.ignored.line.below=已刪除以下忽略的行
vcs.preview.panel.line.with.modified.whitespaces.and.deletion.after=帶有修改的空格和後續刪除的行
vcs.preview.panel.added.line=已添加行
vcs.preview.panel.line.with.modified.whitespaces=帶有修改的空格的行
vcs.preview.panel.modified.line=已修改的行
vcs.preview.panel.deleted.line.below=以下已刪除的行
annotation.background=註解背景
changes.error.shelving.changes.failed=擱置變更失敗: {0}
changes.error.can.t.get.revision.content=無法獲取修訂內容
changes.error.failed.to.create.content.for.current.revision=無法為當前修訂創建內容
changes.error.failed.to.fetch.current.revision=無法獲取當前修訂
changes.finishing.changed.on.server.update=正在完成“在伺服器上被更改”更新
changes.tried.to.save.uncommitted.changes.in.shelve.before.s.but.failed.with.an.error=嘗試在{0}之前擱置未提交的變更，但因為錯誤而失敗。<br/>{1}
changes.refresh.changelists.after.update=更新後刷新變更列表
changes.deleting.added.files.locally=正在本地刪除已添加檔案…
changes.progress.text.vcs.name.performing.operation.name={0}: 正在執行 {1}…
changes.project.exclude.paths=專案排除路徑
changes.error.default.project.not.supported=不支持預設專案
changes.removing.configuration.0.from.ignore=正在從忽略物件中移除配置 {0}…
changes.checking.configuration.0.for.ignore=正在為忽略物件檢查配置 {0}…
changes.cant.load.changes=無法載入變更
changes.switched.to.branch.name=已切換到 {0}
changes.do.cleanup=進行清理…
changes.locked.by=被 {0} 鎖定
changes.browse=瀏覽
changes.diff.separator=差異
changes.warning.not.all.local.changes.may.be.shown.due.to.an.error=警告: 由於錯誤，可能不會顯示所有本地變更: {0}
changes.new.changelist=新的變更列表
changes.action.include.in.operation.name=包含在 {0} 中(&I)
changes.error.content.for.0.was.removed=''{0}'' 的內容已被移除
changes.error.can.t.show.diff.for=無法顯示 ''{0}'' 的差異
changes.can.not.find.patch.for.path.in.patch.file=無法在補丁檔案中找到 {0} 的補丁。
changes.error.cannot.find.base.for.path=找不到 ''{0}'' 的基
changes.error.can.t.show.diff.for.binary.file=無法顯示二進制檔案 ''{0}'' 的差異
changes.impossible.until.indices.are.up.to.date=在索引更新前不可行
changes.empty.changelists.no.longer.active={0,choice,1#空變更列表 ''''{1}'''' 已|2#空變更列表 '<br/>'{1} 已}不再活動。<br/>要將{0, choice,1#其|2#其}移除嗎?
changes.text.default.ignored.files=預設忽略的檔案
changes.tab.title.vcs.errors=VCS 錯誤
changes.progress.title.choice.revert.apply.changes={0, choice, 0#還原|1#套用}變更
changes.dialog.message.failed.to.revert.apply.changes=無法{0, choice, 0#還原|1#套用}變更: 
changes.revert.apply.change.list.name={0, choice, 0#還原: |1#套用: }{1}
change.dialog.title.change.list.name={0} [{1}]
change.dialog.title.in.change.list.name={1} 中的 {0}
changes.none=<無>
changes.button.newer=較新的 >
changes.button.older=< 較舊的
changes.directory.does.not.belong.to.the.active.changelist={0, choice, 1#這一目錄|2#這些目錄}不屬於活動變更列表:
changes.file.does.not.belong.to.the.active.changelist={0, choice, 1#這一檔案|2#這些檔案}不屬於活動變更列表:
changes.configure=配置(&C)…
changes.hide.this.notification=隱藏此通知
changes.set.active.changelist.to.change.list.name=將活動變更列表設定為 ''{0}''
changes.move.changes.to.active.change.list.name=將變更移動到活動變更列表({0})
changes.file.from.non.active.changelist.is.modified=非活動變更列表中的檔案已修改
changes.another.change.list=另一個
changes.default.change.list=預設
changes.include.lines.into.commit=將行包含在提交中
changes.exclude.lines.from.commit=將行從提交中排除
changes.move.to.changelist=移動到 ''{0}'' 變更列表
changes.notification.content.repository.location.not.found.for=找不到 {0} 的版本庫位置
changes.days.of.history.to.cache.initially=最初要快取的歷史記錄的天數:
changes.changelists.to.cache.initially=最初要快取的變更列表:
changes.minutes=分鐘
changes.refresh.changes.every=刷新變更，每
changes.please.enter.a.valid.regex=請輸入有效正則表達式
changes.no.incoming.changelists.available=無可用傳入變更列表
changes.error.refreshing.vcs.history=刷新 VCS 歷史記錄時出錯
changes.committed.changes=已提交變更
changes.error.refreshing.view=刷新檢視時出錯: {0}
changes.title.loading.changes=正在載入變更
changes.no.tracking.branch=無跟踪分支
changes.no.tracking.branch.suffix=\\\\ (無跟踪分支)
changes.ignore.file=忽略檔案

impl.notification.content.vcs.plugin.not.found.for.mapping.to=沒有為 ''{0}'' 的映射找到 VCS 套件
impl.progress.title.installing.plugin=正在安裝套件…
impl.notification.title.failed.to.install.plugin=安裝套件失敗
impl.notification.content.could.not.find.plugin=找不到套件 {0}
impl.notification.content.plugin.was.unbundled.needs.to.be.installed.manually={0} 套件已解除捆綁，需要手動安裝
impl.vcs.initialization=VCS 初始化
impl.show.all.affected.files.for.path.at.revision.failed=為 {0} 顯示 {1} 失敗時所有受影響的檔案
merge.loading.merge.details=正在載入合併詳細資訊…

commit.message=提交訊息
commit.message.intention.family.name.reformat.commit.message=重新格式化提交訊息
commit.message.inspection.message.body.lines.should.not.exceed.characters=正文行不能超過 {0} 個字符
commit.message.intention.family.name.wrap.line=換行
commit.message.missing.blank.line.between.subject.and.body=主題與正文之間缺少空行
commit.message.inspection.message.subject.should.not.exceed.characters=主題不能超過 {0} 個字符
commit.amend.commit=修正提交
commit.tooltip.merge.this.commit.with.the.previous.one=將此提交與前一個提交合併
ranges.to.commit.of.ranges.size.changes={1} 個中的 {0} 個發生變更
commit.changes=提交變更
commit.progress.title=提交
tab.title.commit=提交
tab.title.commit.to.branch=提交至 {0}
history.file.not.found=找不到檔案 {0}
compare.with.dialog.get.from.vcs.action.title=從 VCS 獲取
history.dialog.title.difference.between.versions.in={2} 中的 {0} 和 {1} 版本的差異
history.failed.to.load.content.for.revision.0=無法為修訂 {0} 載入內容
history.tab.title.can.not.load.changelist.contents=無法載入變更列表內容
update.label.before.update=更新前
update.notification.title.project.partially.updated=專案已部分更新
update.notification.title.count.files.updated={0,choice,1#1 個檔案|2#{0} 個檔案}已更新
update.notification.content.files.updated={0,choice,1#1 個檔案|2#{0} 個檔案}已更新
update.file.name.wasn.t.modified={0} 未修改
update.filtered.files.count.in.filter.name={0} ({1} 內)
update.label.after.update=更新後
update.notification.content.view=查看
update.checkbox.don.t.show.again=不再顯示
update.can.t.load.content=無法載入內容
update.error.label=錯誤: 
roots.notification.content.added.vcs.name.roots=已添加 {0} 個{1,choice,1#根|2#根}: {2}
roots.notification.content.directory.registered.as.root.but.no.repositories.were.found.there=目錄 {0} 被註冊為 {1} 根，但在那裡沒有發現 {1} 版本庫。
roots.notification.title.invalid.vcs.root.choice.mapping.mappings=無效 VCS 根{0, choice, 1#映射|2#映射}
roots.notification.title.vcs.root.configuration.problems=VCS 根配置問題
roots.notification.title.vcs.name.integration.enabled={0} 集成已啟用
notification.title.vcs.name.repository.repositories.found=已找到 {0} 個{1, choice, 1#版本庫|2#版本庫}
roots.the.following.directories.are.registered.as.vcs.roots.but.they.are.not=以下目錄被錯誤註冊為 VCS 根:
configurable.issue.link.remove=移除
configurable.issue.link.edit=編輯
configurable.shelf.storage.destination.shelf.directory.should.have.write.access=目標擱置目錄必須具備寫入權限
configurable.shelf.storage.destination.shelf.directory.should.have.read.access=目標擱置目錄必須具備讀取權限
configurable.shelf.storage.cant.find.or.create.new.shelf.directory=無法找到或創建新的擱置目錄
configurable.vcs.manage.scopes=管理範圍
ex.new.changelist=新建變更列表…
ex.move.lines.to.another.changelist.0=將行移動到另一個變更列表({0})
ex.changelists=變更列表
checkin.cancel=取消(&N)
checkin.commit=提交(&C)
checkin.code.analysis.failed=程式碼分析失敗
checkin.code.analysis.failed.with.exception.name.message=程式碼分析失敗，出現異常: {0}: {1}
checkin.wait=等待(&W)
checkin.can.not.load.current.revision=無法載入當前修訂
checkin.can.not.load.previous.revision=無法載入前一個修訂
checkin.invalid.file.s=無效檔案
checkin.dialog.title.not.possible.right.now=現在無法檢查 TODO
checkin.dialog.message.cant.be.performed={0} 在背景更新索引時，無法執行 TODO 檢查。\\\\n\\\\
您可以在不執行檢查的情況下提交更改，也可以等到索引建立後再提交。
checkin.dialog.title.looking.for.new.edited.todo.items=正在尋找新的和編輯的 TODO 條目…
checkin.dialog.title.todo=TODO
checkin.filter.filter.name=篩選器: {0}
checkin.title.for.commit.0=以供提交 ({0})
checkin.unresolved.merge.unresolved.conflicts=未解決的衝突
checkin.unresolved.merge.are.you.sure.you.want.to.commit.changes.with.unresolved.conflicts=確定要提交有未解決衝突的變更嗎?
patch.unknown.line.prefix=未知行前綴
patch.unknown.after.hunk.start.syntax=未知的 after 區塊開始語法
patch.missing.after.hunk=缺少 after 區塊
patch.unknown.before.hunk.start.syntax=未知的 before 區塊開始語法
patch.unknown.hunk.start.syntax=未知的區塊開始語法
patch.second.file.name.expected=應為第二個文件名
patch.empty.0.data.section=空 ''{0}'' 資料分區
patch.empty.additional.info.header=空的附加資訊頭
patch.contains.additional.information.without.patch.itself=包含附加資訊但不含補丁本身
patch.can.t.detect.file.names.from.git.format.header.line=無法從 git 格式頭行檢測文件名
patch.unexpected.end.of.binary.patch=二進制補丁意外結束
patch.failed.to.fetch.old.content.for.file.name.in.revision=無法在修訂 {1} 中獲取檔案 {0} 的舊內容
vcs.tab.title.vcs.name.operations.errors={0} 個操作錯誤
vfs.revision.author.unknown=未知
change.list.scope.provider.local.changes=本地變更
changes.change.list.conflict.dialog.radio.button.ignore=忽略(&I)
changes.change.list.conflict.dialog.radio.button.shelve.changes=擱置變更(&S)
todo.tab.title.all.changes=本地變更
todo.tab.title.changelist.suffix=變更列表
get.from.vcs.extension.list.accessible.name=版本庫位置
vcs.dnd.image.text.n.files={0}{0, choice, 1#檔案|2#檔案}
checking.recent.changes=正在檢查最近的變更…
show.diff.in.editor.tab.got.it.tooltip=要在編輯器頁籤中再次顯示差異，請使用此選單。
intention.name.rollback.changes.in.current.line=回滾當前行中的變更
advanced.settings.vcs=版本控制
advanced.setting.vcs.annotations.preload=在編輯器中打開檔案時載入 VCS 中的檔案註解
advanced.setting.vcs.annotations.preload.description=這樣就可以更快速地按需顯示。

before.checkin.cleanup.code.profile=使用 ''{0}'' 配置檔案清理(&L)
label.at.date.leading=在 {0}
label.at.date.middle=在 {0}
button.tooltip.remove.commit.author.date=移除
settings.changelists.create.automatically.checkbox=自動創建變更列表(&A)
changes.default.changelist.name.old=預設變更列表
advanced.setting.vcs.commit.tool.window=啟用“提交”工具視窗
advanced.setting.vcs.commit.tool.window.description=在單獨的“提交”工具視窗中顯示“本地變更”和“擱置”頁籤
advanced.setting.vcs.non.modal.commit.toggle.ui=切換提交控件
advanced.setting.vcs.non.modal.commit.toggle.ui.description=執行提交後隱藏提交面板和復選框，並允許在“本地變更”中切換提交 UI
advanced.setting.vcs.push.all.with.commits=選擇包含要推送的新提交的所有版本庫
advanced.setting.vcs.push.all.with.commits.description=預設預先選擇包含要推送的提交的所有版本庫
advanced.setting.vcs.process.ignored=高亮顯示忽略的檔案
advanced.setting.vcs.process.ignored.description=請求 VCS 中被忽略檔案的列表，並在 IDE 中顯示這些檔案的狀態
tooltip.rerun.commit.checks=重新執行提交檢查
change.list.scope.provider.only.changes=所有檔案中僅未提交到 VCS 的變更
change.list.scope.provider.only.changes.in.file=檔案 {0} 中僅未提交到 VCS 的變更
settings.general.show.options.before.command.label=進行以下操作之前顯示選項:
show.patch.in.explorer.after.creation.label=創建補丁時:
show.patch.in.explorer.after.creation.combobox.text.ask=詢問
show.patch.in.explorer.after.creation.combobox.text.show.in.file.manager=在 {0} 中顯示
show.patch.in.explorer.after.creation.combobox.text.no=不執行任何操作
settings.checkbox.show.changed.in.last.comment=修改的檔案將在外部堆疊跟踪和調試時高亮顯示。
remove.changelist.combobox.show.options=顯示選項
remove.changelist.combobox.remove.silently=靜默移除
remove.changelist.combobox.do.not.remove=不執行任何操作
radio.restore.workspace.on.branch.switching.comment=工作區是一組打開的檔案、當前執行配置以及與分支關聯的斷點。
settings.general.confirmation.group.title=確認
settings.general.changes.group.title=變更
checkbox.including.files.created.outside.ide=應用於在 {0} 外部創建的檔案
settings.label.when.empty.changelist.becomes.inactive=當空變更列表變為非活動狀態時:
description.text.option.applicable.to.vcses=適用於 {0}
sequence.concatenation.a.and.b={0} 和 {1}
sequence.concatenation.separator=、
sequence.concatenation.tail=和 {0}
sequence.concatenation.tail.n.others=和其他 {0} 個
changes.combined.diff=組合變更差異
label.code.author.inlay.hints=程式碼作者
label.new.code=新 *
label.multi.author.modified.code={0} +{1} *
label.multi.author.not.modified.code={0} +{1}
label.single.author.modified.code={0} *
searching.for.code.smells.processing.file.progress.text=正在處理 {0}
title.code.author.inlay.hints=程式碼作者
version.control.main.configurable.description=<html><body>配置與專案中使用的版本控制相關的設定
incoming.changes.indicator.name=傳入變更
RepositoryBrowser.toolwindow.name=版本庫
ChangesBrowserToolWindow.toolwindow.name=變更
changes.editor.diff.preview.title=變更: {0}
changes.editor.diff.preview.empty.title=變更
jb.protocol.no.provider=找不到 VCS 提供程序: ''{0}''
settings.auto.detected.progress=正在檢測…
annotations.short.name.type.email=電子郵件
action.Vcs.Toolbar.ShowMoreActions.text=版本控制
Vcs.Toolbar.ShowMoreActions.description=VCS 操作
notification.group.external.executable=VCS 外部可執行檔案驗證失敗"
`;

exports[`dev messages/VcsLogBundle.properties 1`] = `
"# actions
vcs.log.action.align.labels=將引用對齊到左側
vcs.log.action.description.align.labels=在提交訊息左側顯示引用
vcs.log.action.description.show.all.branches=在僅顯示當前分支和顯示所有分支之間切換
vcs.log.action.description.show.all.changes.from.parent=分別顯示對每個合併提交所做的更改
vcs.log.action.description.show.compact.references.view=僅在表中顯示提交的第一個引用
vcs.log.action.description.show.details=顯示詳細資訊面板
vcs.log.action.description.show.diff.preview=顯示差異預覽面板
vcs.log.action.description.show.long.edges=即使提交在當前檢視中不可見，也顯示長分支邊緣。
vcs.log.action.description.show.only.affected.changes=僅顯示影響“路徑”選單中所選檔案的變更
vcs.log.action.description.show.tag.names=在表中顯示標籤名稱
vcs.log.action.description.open.new.tab.with.log=打開包含 {0} 日誌的新頁籤
vcs.log.action.show.all.branches=顯示所有分支
vcs.log.action.show.diff.preview=顯示差異預覽
action.Vcs.Log.MoveDiffPreviewToBottom.text=底部
action.Vcs.Log.MoveDiffPreviewToBottom.description=在底部找到差異預覽
action.Vcs.Log.MoveDiffPreviewToRight.text=右側
action.Vcs.Log.MoveDiffPreviewToRight.description=在右側找到差異預覽
vcs.log.action.show.all.changes.from.parent=顯示對父項的變更
vcs.log.action.show.compact.references.view=緊湊型引用檢視
vcs.log.action.show.details=顯示詳細資訊
vcs.log.action.show.long.edges=顯示長邊
vcs.log.action.show.only.affected.changes=僅顯示受影響的變更
vcs.log.action.show.root.names=顯示根名稱
vcs.log.action.show.tag.names=顯示標籤名稱
vcs.log.action.open.new.tab.with.log=打開新的 {0} 日誌頁籤
action.process.expanding.linear.branches=正在展開線性分支…
action.process.expanding.merges=正在展開合併…
action.description.expand.merges=展開合併
action.title.expand.merges=展開合併
action.description.expand.linear.branches=展開線性分支
action.title.expand.linear.branches=展開線性分支
action.process.collapsing.linear.branches=正在摺疊線性分支…
action.process.collapsing.merges=正在摺疊合併…
action.description.collapse.merges=摺疊合併
action.title.collapse.merges=摺疊合併
action.description.collapse.linear.branches=摺疊線性分支
action.title.collapse.linear.branches=摺疊線性分支
action.title.match.case=區分大小寫
action.title.match.case.only.supported=區分大小寫(僅限 {0})
action.go.to.navigate.to=導航到 {0}
action.go.to.select.child.to.navigate=選擇要導航的子項
action.go.to.select.parent.to.navigate=選擇要導航的父項
action.go.to.select.hash.subject.author.date.time={0} {1}，作者 {2}，{3} {4}
action.name.refresh.log=刷新
action.description.refresh.log=檢查新提交，必要時刷新日誌
action.description.was.paused=為 {0} 編制索引已暫停。恢復。
action.title.resume.indexing=恢復 {0} 日誌索引編制
action.description.is.scheduled=為 {0} 編制索引已計劃。暫停。
action.title.pause.indexing=暫停 {0} 日誌索引編制
action.description.select.columns.to.see=選擇要在表中查看的列
action.title.select.columns.to.see=顯示列
action.FocusTextFilterAction.text=聚焦文本篩選器
action.FocusTextFilterAction.description=聚焦文本篩選器或將焦點移回提交列表
action.IntelliSortChooserPopupAction.text=IntelliSort
action.IntelliSortChooserPopupAction.description=更改 IntelliSort 類型
action.ShowCommitTooltipAction.text=顯示提交工具提示
action.ShowCommitTooltipAction.description=在日誌中為當前所選提交顯示工具提示
action.presentation.CompareRevisionsFromFileHistoryActionProvider.text.compare=比較
action.presentation.CompareRevisionsFromFileHistoryActionProvider.text.show.diff=顯示差異
action.presentation.CompareRevisionsFromFileHistoryActionProvider.description.compare=比較所選版本
action.presentation.CompareRevisionsFromFileHistoryActionProvider.description.show.diff=顯示與之前版本的差異
vcs.log.action.intellisort.title=IntelliSort: {0}
vcs.log.action.intellisort.text=IntelliSort
vcs.log.action.intellisort.description=開啟/關閉 IntelliSort
vcs.log.action.turn.intellisort.on=開啟 IntelliSort: {0}。
vcs.log.action.turn.intellisort.off=關閉 IntelliSort: {0}。
action.Vcs.Log.GoToRef.text=轉到哈希/分支/標記
action.Vcs.Log.GoToRef.description=指定分支或標記的哈希或名稱，以導航到其指向的提交
action.Vcs.Log.GoToParent.text=轉到父提交
action.Vcs.Log.GoToParent.description=導航到提交圖中的父行
action.Vcs.Log.GoToChild.text=轉到子提交
action.Vcs.Log.GoToChild.description=導航到提交圖中的子行
action.Vcs.Show.Log.text=顯示 VCS 日誌
action.Vcs.Show.Log.text.template=顯示 {0} 日誌
action.Vcs.Log.ShowTooltip.text=顯示提交工具提示
action.Vcs.Log.ShowTooltip.description=在日誌中為當前選定提交顯示工具提示
action.Vcs.Log.EnableFilterByRegexAction.text=正則表達式
action.Vcs.Log.MatchCaseAction.text=區分大小寫
action.Vcs.Log.OpenRepositoryVersion.text=按修訂顯示檔案
action.Vcs.Log.OpenRepositoryVersion.description=在編輯器中打開檔案的所選修訂
action.Vcs.Log.GetVersion.text=獲取
action.Vcs.Log.GetVersion.description=從版本庫獲取版本
action.Vcs.Log.AnnotateRevisionAction.text=註解
action.Vcs.Log.AnnotateRevisionAction.description=註解所選修訂
action.Vcs.Log.ShowAllAffected.text=顯示所有受影響的檔案
action.Vcs.Log.ShowAllAffected.description=顯示選中修訂中所做的所有變更
action.Vcs.Log.CompareRevisions.text=比較版本
action.Vcs.Log.CompareRevisions.description=比較選定版本
action.Vcs.Log.ResumeIndexing.text=恢復索引編制
action.Vcs.Log.ResumeIndexing.description=索引編制已暫停，因為它花費的時間比預期長。恢復。
group.Vcs.Log.PresentationSettings.text=演示設定
group.Vcs.Log.PresentationSettings.description=配置日誌的演示
group.Vcs.Log.TextFilterSettings.text=文本篩選器設定
group.Vcs.Log.TextFilterSettings.description=選擇文本篩選器選項
group.Vcs.Log.LayoutConfiguration.text=配置布局
group.Vcs.Log.LayoutConfiguration.description=配置視窗布局
group.Vcs.FileHistory.PresentationSettings.text=演示設定
group.Vcs.FileHistory.PresentationSettings.description=配置檔案歷史記錄的演示
group.Log.KeymapGroup.text=日誌
group.Vcs.Log.Diff.Preview.Location.text=差異預覽位置

dialog.title.paths.affected.by.commit=受提交 {0} 影響的路徑

# tooltips
vcs.log.click.to.collapse.paths.column.tooltip=點擊以摺疊
vcs.log.click.to.expand.paths.column.tooltip=點擊以展開
vcs.log.graph.arrow.tooltip.jump.to.subject.author.date.time=跳轉到 {0} (作者 {1}，{2} {3})
vcs.log.graph.arrow.tooltip.jump.to.hash=跳轉到提交 {0}
vcs.log.graph.arrow.tooltip.jump.to.hash.in.root=跳轉到 {1} 中的提交 {0}
vcs.log.references.more.tooltip=…詳細資訊窗格中的其他 {0} 項

# log in editor
filetype.vcs.log.description=Vcs 日誌

# replacement for specific vcs name
vcs=Vcs

# empty text
vcs.log.is.loading=正在載入 VCS 日誌…
vcs.log.loading.status=正在載入提交…
vcs.log.error.loading.status=載入提交時出錯
vcs.log.no.commits.status=未提交變更。
vcs.log.commit.status.action=提交本地變更
vcs.log.error.filtering.status=篩選提交時出錯
vcs.log.no.commits.matching.status=沒有與篩選器符合的提交
vcs.log.reset.filters.status.action=重置篩選器
vcs.log.refresh.status.action=刷新
vcs.log.default.status=變更日誌
vcs.log.duplicated.tab.id.error=VCS 日誌頁籤不能打開兩次

# file history
file.history.error.status=計算檔案歷史記錄時出錯
file.history.empty.status=檔案歷史記錄
file.history.action.could.not.load.selected.commits.message=無法載入所選提交: {0}
file.history.diff.preview.editor.tab.name=歷史記錄: {0}

# jump to commit
vcs.log.go.to.hash.popup.label=輸入哈希或分支/標記名稱:
vcs.log.commit.or.reference.not.found=未找到提交或引用 ''{0}''
vcs.log.commit.not.found=未找到提交 {0}
vcs.log.commit.does.not.match=提交 {0} 與篩選器不符合
vcs.log.commit.does.not.match.view.and.reset.link=查看並重置篩選器
vcs.log.commit.does.not.match.view.in.tab.link=在新頁籤中查看
file.history.commit.not.found.in.branch=當前分支中 {1} 的歷史記錄中不存在提交 {0}
file.history.commit.not.found={1} 的歷史記錄中不存在提交 {0}
file.history.commit.not.found.view.and.show.all.branches.link=查看並顯示所有分支
file.history.commit.not.found.view.in.log.link=在日誌中查看

# indexing progress
vcs.log.status.bar.indexing.cancel.tooltip=取消索引編制。可以從 {0} 日誌工具欄手動重新啟動索引編制。
vcs.log.status.bar.indexing.cancel.cancelling=正在取消
vcs.log.status.bar.indexing={0} 日誌正在編制索引…

# processes
vcs.log.creating.process=正在載入提交…
vcs.log.initial.loading.process=正在載入歷史記錄…
vcs.log.refreshing.process=正在刷新歷史記錄…
vcs.log.closing.process=正在關閉 VCS 日誌
vcs.log.loading.selected.details.process=正在載入所選詳細資訊
vcs.log.applying.filters.process=正在套用篩選器…

# tab name
vcs.log.tab.name=日誌
vcs.log.diff.preview.editor.empty.tab.name=版本庫差異
vcs.log.diff.preview.editor.tab.name=版本庫差異: {0}
vcs.log.editor.name=Vcs 日誌編輯器

# filters
vcs.log.filter.all=所有
vcs.log.filter.recent=最近
vcs.log.filter.structure.presentation.with.prefix=用於 {0}
vcs.log.filter.root.presentation.with.prefix=在 {0} 中
vcs.log.filter.branch.presentation.with.prefix=在 {0} 上
vcs.log.filter.date.presentation.with.prefix.made=生成於 {0}
vcs.log.filter.date.presentation.with.prefix.made.after={0} 後生成
vcs.log.filter.date.presentation.with.prefix.made.before={0} 前生成
vcs.log.filter.date.display.name.after=在 {0} 後
vcs.log.filter.date.display.name.before=在 {0} 前
vcs.log.filter.user.presentation.with.prefix=被 {0} 使用
vcs.log.filter.text.presentation.with.prefix=包含 {0}
vcs.log.filter.text.hash.tooltip=文本或哈希篩選器
vcs.log.filter.popup.no.roots=沒有根
vcs.log.filter.popup.no.folders=無路徑
vcs.log.filter.popup.no.items=沒有項
vcs.log.filter.popup.paths=路徑
vcs.log.Accessibility.filter.label={0}: {1}
vcs.log.date.filter.label=日期
vcs.log.branch.filter.label=分支
vcs.log.branch.filter.favorites=收藏夾
vcs.log.user.filter.label=使用者
vcs.log.user.filter.me=我
vcs.log.date.filter.since=自 {0}
vcs.log.date.filter.until=直到 {0}
vcs.log.date.filter.action.last.day=過去 24 小時
vcs.log.date.filter.action.last.week=過去 7 天
vcs.log.date.filter.select.period.dialog.title=選擇期間
vcs.log.filter.action.select=選擇…
vcs.log.select.folder.dialog.title=選擇要篩選的路徑
vcs.log.filters.structure.label=已選擇: {0}
vcs.log.filters.structure.max.selected.error.message=您已添加 {0} 個元素。不允許更多元素。
vcs.log.filter.roots=根
vcs.log.filter.tooltip.click.to.see.only={0}+點擊以僅查看“{1}”
vcs.log.filter.tooltip.no.roots.selected=未選擇根
vcs.log.filter.tooltip.roots=根:
vcs.log.filter.tooltip.folders=路徑:
vcs.log.filter.popup.advertisement.text=選擇一個或多個用 {0} 分隔的值
vcs.log.filter.popup.advertisement.text.new.lines=新行
vcs.log.filter.popup.advertisement.text.or.suffix=或{0}
vcs.log.filter.popup.advertisement.with.key.text=選擇一個或多個用 {0} 分隔的值，並使用 {1} 完成
vcs.log.filter.select.folders=在樹中選擇…
vcs.log.filter.edit.folders=選擇…
vcs.log.text.filter.action.text=按文本或哈希篩選
vcs.log.branch.filter.action.text=按分支篩選
vcs.log.user.filter.action.text=按使用者篩選
vcs.log.date.filter.action.text=按日期篩選
vcs.log.path.filter.action.text=按路徑篩選

# commit details
vcs.log.details.in.branches.loading=在分支中: 正在載入…
vcs.log.details.in.branches.empty=不在任何分支中
vcs.log.details.in.branches.hide=隱藏
vcs.log.details.in.branches.show.all=全部顯示
vcs.log.details.in.branches=在 {0,choice,1#{0} 個分支|2#{0} 個分支}中:
vcs.log.details.committer.info.user.date.time=由 {0} 於 {1} {2} 提交
vcs.log.details.committer.info.date.time=在 {0} {1} 提交
vcs.log.details.author.on.date.at.time=作者 {0}，{1} {2}
vcs.log.details.committer.info.user=由 {0} 提交
vcs.log.details.showing.selected.commits=(正在顯示 {0}/{1} 個所選提交)
vcs.log.details.references.more.label=…其他 {0} 個
loading.commit.changes=正在載入提交變更
vcs.log.commit.details.status=提交詳細資訊

# changes browser
vcs.log.changes.select.commits.to.view.changes.status=選擇提交以查看變更
vcs.log.changes.no.merge.conflicts.status=沒有合併的衝突。
vcs.log.changes.show.changes.to.parents.status.action=顯示對父項的變更
vcs.log.changes.no.changes.that.affect.selected.paths.status=沒有影響所選路徑的變更。
vcs.log.changes.show.all.paths.status.action=顯示所有路徑的變更
vcs.log.changes.no.changes.that.affect.selected.filters.status=沒有與所選篩選器符合的變更。
vcs.log.changes.show.all.changes.status.action=顯示所有變更
vcs.log.changes.details.no.commits.selected.status=未選擇提交
vcs.log.changes.too.many.status={0,choice,1#此提交|2#所選提交之一}具有 {1} 個變更
vcs.log.changes.too.many.show.anyway.status.action=仍然顯示
vcs.log.changes.no.merge.conflicts.node=沒有合併的衝突
vcs.log.changes.changes.to.parent.node=對 {0} 的變更

# highlighters
vcs.log.action.highlight.current.branch=當前分支
vcs.log.action.highlight.indexed.commits=已編制索引的提交
vcs.log.action.highlight.merge.commits=合併提交
vcs.log.action.highlight.my.commits=我的提交

# messages
vcs.log.recreated.due.to.corruption=由於資料損壞，{0} 日誌已重新創建 {1} 次。\\\\n如果經常發生這種情況，請刪除 {2} 目錄並重新啟動 {3}。
vcs.log.fatal.error.message=無法清除 {0} 下的快取。\\\\n請手動刪除快取目錄，然後重新啟動 {1}。
vcs.log.is.not.available=VCS 日誌不可用

# caches invalidator
vcs.log.clear.caches.checkbox.description=清除 VCS 日誌快取和索引

# columns
vcs.log.column.subject=主題
vcs.log.column.author=作者
vcs.log.column.date=日期
vcs.log.column.hash=哈希

# graph
graph.sort.linear=線性
graph.sort.linear.description=合併時，在主分支提交的頂部顯示傳入提交，就好像對它們進行變基
graph.sort.standard=標準
graph.sort.standard.description=合併時，首先顯示傳入提交(合併提交正下方)
graph.sort.off=關閉
graph.sort.off.description=按日期以拓撲方式對提交進行排序
"
`;

exports[`src inspectionDescriptions/LeakableMapKey.html 1`] = `
"<html>
<body>
報告在套件程式碼中將 <code>Language</code> 或 <code>FileType</code> 用作映射鍵。
<p>
  此類用法可能導致無法正確解除安裝套件。
</p>
<p>
  請考慮使用 <code>String</code> 作為鍵。
</p>
<p>
  有關更多資訊，請參閱 SDK 文檔中的<a href=\\"https://plugins.jetbrains.com/docs/intellij/dynamic-plugins.html\\">動態套件</a>。
</p>
</body>
</html>"
`;

exports[`src messages/ActionsBundle.properties 1`] = `
"# IDEA core action texts and descriptions go here.
# The key patterns are \\"action.\\" + id + \\".text\\" and \\"action.\\" + id + \\".description\\"

action.ContextHelp.text=上下文幫助(_X)
action.ContextHelp.description=顯示上下文幫助
action.RunConfiguration.text=選擇執行/調試配置
action.SwitchCoverage.text=顯示程式碼覆蓋率資料(_V)
action.GenerateCoverageReport.text=生成覆蓋率報告(_G)
action.RunConfiguration.description=選擇執行/調試配置
action.ShowIntentionActions.text=顯示上下文操作
action.ToggleReadOnlyAttribute.text=切換唯讀特性
action.ToggleReadOnlyAttribute.synonym=將檔案設為可寫
action.ToggleReadOnlyAttribute.synonym2=將檔案設為唯讀
action.ToggleReadOnlyAttribute.description=切換當前檔案的唯讀特性
# suppress inspection \\"UnusedMessageFormatParameter\\"
action.ToggleReadOnlyAttribute.files=使{2,choice,1#檔案|2#檔案}{0,choice,0#唯讀|1#可寫}
# suppress inspection \\"UnusedMessageFormatParameter\\"
action.ToggleReadOnlyAttribute.dirs=使{3,choice,1#目錄|2#目錄}{0,choice,0#唯讀|1#可寫}
# suppress inspection \\"UnusedMessageFormatParameter\\"
action.ToggleReadOnlyAttribute.mixed=使檔案/目錄{0,choice,0#唯讀|1#可寫}
action.TogglePopupHints.text=切換當前檔案的彈出視窗提示
action.ShowPopupMenu.text=顯示右鍵選單
action.Vcs.ShowMessageHistory.text=提交訊息歷史記錄
action.Vcs.ShowMessageHistory.description=顯示提交訊息歷史記錄
action.Vcs.ShowHistoryForBlock.text=顯示選擇的歷史記錄(_F)
action.Vcs.ShowHistoryForBlock.description=顯示編輯器選擇的歷史記錄
action.Vcs.ShowHistoryForRevision.text=迄今為止的歷史記錄
action.Vcs.ShowHistoryForRevision.description=顯示檔案的歷史記錄，直到所選修訂版本
action.Vcs.ShowTabbedFileHistory.text=顯示歷史記錄(_H)
action.Vcs.ShowTabbedFileHistory.description=顯示檔案的歷史記錄
action.AddToFavoritesPopup.text=添加到收藏夾
action.AddToFavoritesPopup.description=將所選節點添加到收藏夾
group.AddToFavorites.text=添加到收藏夾(_A)
group.AddAllToFavorites.text=全部添加到收藏夾(_L)
action.AddNewFavoritesList.text=添加新收藏夾列表
action.AddNewFavoritesList.description=添加新收藏夾列表
action.EditFavorites.text=重命名收藏夾列表
group.SendToFavoritesGroup.text=發送至收藏夾(_S)
action.ActivateNavBar.text=啟用導航欄(_B)
action.ActivateNavBar.description=啟用導航欄
action.CreateRunConfiguration.text=創建執行配置
action.CreateRunConfiguration.description=根據當前上下文創建執行配置
group.RunContextPopupGroup.text=執行配置
group.EditorActions.text=編輯器操作
action.EditorChooseLookupItem.text=選擇查詢條目
action.EditorChooseLookupItemReplace.text=選擇查詢條目取代
action.EditorChooseLookupItemCompleteStatement.text=選擇查詢條目並調用語句補全
action.EditorChooseLookupItemDot.text=選擇查詢條目並插入點
action.NextTemplateVariable.text=下一個模板變數或完成就地重構
action.SelectVirtualTemplateElement.text=顯示用於就地重構的選項彈出視窗
action.PreviousTemplateVariable.text=上一個模板變數
action.NextParameter.text=下一個參數
action.PrevParameter.text=上一個參數
action.EditorPageUp.text=向上翻頁
action.EditorPageDown.text=向下翻頁
action.EditorPageUpWithSelection.text=在保持選區的情況下向上翻頁
action.EditorPageDownWithSelection.text=在保持選區的情況下向下翻頁
action.EditorCopy.text=複製
action.EditorCut.text=剪下
action.EditorPaste.text=貼上
action.EditorPasteSimple.text=貼上為純文本(_L)
action.EditorPasteSimple.description=貼上，不進行格式化、自動匯入、文字轉義等。
action.EditorPasteFromX11.text=從 X 剪貼簿貼上
action.EditorDelete.text=刪除
action.EditorBackSpace.text=退格
action.EditorHungryBackSpace.text=飢餓退格
action.EditorHungryBackSpace.description=與退格鍵的作用相同，但也會移除文本游標前的所有空白符號(如有)
action.EditorMoveToPageTop.text=將文本游標移至頁面頂部
action.EditorMoveToPageBottom.text=將文本游標移至頁面底部
action.EditorMoveToPageTopWithSelection.text=在保持選區的情況下將文本游標移至頁面頂部
action.EditorMoveToPageBottomWithSelection.text=在保持選區的情況下將文本游標移至頁面底部
action.EditorEnter.text=Enter
action.EditorEscape.text=Esc
action.FocusEditor.text=聚焦編輯器
action.EditorUp.text=上
action.EditorDown.text=下
action.EditorLeft.text=左
action.EditorRight.text=右
action.EditorUpWithSelection.text=在保持選區的情況下向上
action.EditorDownWithSelection.text=在保持選區的情況下向下
action.EditorLeftWithSelection.text=在保持選區的情況下向左
action.EditorRightWithSelection.text=在保持選區的情況下向右
action.EditorLookupUp.text=向上尋找
action.EditorLookupDown.text=向下尋找
action.EditorIndentSelection.text=縮排選區
action.EditorUnindentSelection.text=取消縮排行或選區
action.EditorIndentLineOrSelection.text=縮排行或選區
action.EditorTab.text=頁籤
action.EditorResetFontSize.text=重置字體大小
action.EmacsStyleIndent.text=Emacs 頁籤
action.EditorScrollUp.text=向上滾動
action.EditorScrollDown.text=向下滾動
action.EditorScrollUpAndMove.text=向上滾動並根據需要移動
action.EditorScrollDownAndMove.text=向下滾動並根據需要移動
action.EditorScrollLeft.text=向左滾動
action.EditorScrollRight.text=向右滾動
action.EditorScrollTop.text=滾動到頂部
action.EditorScrollBottom.text=滾動到底部
action.EditorMoveUpAndScroll.text=向上移動並滾動
action.EditorMoveDownAndScroll.text=向下移動並滾動
action.EditorMoveUpAndScrollWithSelection.text=在保持選區的情況下向上移動並滾動
action.EditorMoveDownAndScrollWithSelection.text=在保持選區的情況下向下移動並滾動
action.EditorAddOrRemoveCaret.text=添加或移除文本游標
action.EditorAddOrRemoveCaret.description=在當前檔案中設定多個游標，以同時編輯多行程式碼。
action.EditorCreateRectangularSelection.text=創建矩形選區
action.EditorAddRectangularSelectionOnMouseDrag.text=拖動滑鼠時添加矩形選區
action.EditorCreateRectangularSelectionOnMouseDrag.text=拖動滑鼠創建矩形選區
action.EditorCloneCaretBelow.text=在下方克隆文本游標
action.EditorCloneCaretBelow.description=在下面的行中插入一個輔助游標，以同時編輯多行程式碼。
action.EditorCloneCaretAbove.text=在上方克隆文本游標
action.EditorCloneCaretAbove.description=在上面的行中插入一個輔助游標，以同時編輯多行程式碼。
action.SelectNextOccurrence.text=將下一個符合項添加到選擇
action.SelectNextOccurrence.description=通過將當前單詞的下一個符合項添加到選區來設定多個游標。
action.SelectAllOccurrences.text=選擇所有符合項
action.SelectAllOccurrences.description=通過將當前單詞的所有符合項添加到選區來設定多個游標。
action.UnselectPreviousOccurrence.text=取消選擇符合項
action.UnselectPreviousOccurrence.description=從選區中移除單詞的當前符合項。
action.EditorAddCaretPerSelectedLine.text=在所選行的末尾添加文本游標
action.EditorToggleStickySelection.text=切換粘性選區
action.EditorSwapSelectionBoundaries.text=交換選區邊界
action.EditorLineStart.text=將文本游標移至行首
action.EditorLineEnd.text=將文本游標移至行尾
action.EditorDeleteToLineStart.text=刪除到行首
action.EditorDeleteToLineEnd.text=刪除到行尾
action.EditorCutLineBackward.text=反向剪下行
action.EditorCutLineEnd.text=剪下到行尾
action.EditorTextStart.text=將文本游標移至文本開始
action.EditorTextEnd.text=將文本游標移至文本結束
action.EditorForwardParagraph.text = 將文本游標前移一段
action.EditorBackwardParagraph.text = 將文本游標後移一段
action.EditorForwardParagraphWithSelection.text = 在保持選區的情況下將文本游標前移一段
action.EditorBackwardParagraphWithSelection.text = 在保持選區的情況下將文本游標後移一段
action.EditorLineStartWithSelection.text=在保持選區的情況下將文本游標移至行首
action.EditorLineEndWithSelection.text=在保持選區的情況下將文本游標移至行尾
action.EditorTextStartWithSelection.text=在保持選區的情況下將文本游標移至文本開始
action.EditorTextEndWithSelection.text=在保持選區的情況下將文本游標移至文本結束
action.EditorNextWord.text=將文本游標移至下一個單詞
action.EditorNextWordInDifferentHumpsMode.text=在不同的 \\"CamelHumps\\" 模式下將文本游標移至下一個單詞
action.EditorPreviousWord.text=將文本游標移至上一個單詞
action.EditorPreviousWordInDifferentHumpsMode.text=在不同的 \\"CamelHumps\\" 模式下將文本游標移至上一個單詞
action.EditorNextWordWithSelection.text=在保持選區的情況下將文本游標移至下一個單詞
action.EditorNextWordInDifferentHumpsModeWithSelection.text=在不同的 \\"CamelHumps\\" 模式下保持選區的情況下將文本游標移至下一個單詞
action.EditorPreviousWordWithSelection.text=在保持選區的情況下將文本游標移至上一個單詞
action.EditorPreviousWordInDifferentHumpsModeWithSelection.text=在不同的 \\"CamelHumps\\" 模式下保持選區的情況下將文本游標移至上一個單詞
action.EditorCodeBlockStart.text=將文本游標移至程式碼塊開始
action.EditorCodeBlockEnd.text=將文本游標移至程式碼塊結束
action.EditorCodeBlockStartWithSelection.text=在保持選區的情況下將文本游標移至程式碼塊開始
action.EditorCodeBlockEndWithSelection.text=在保持選區的情況下將文本游標移至程式碼塊結束
action.EditorMatchBrace.text=將文本游標移至符合的大括號
action.EditorDeleteToWordStart.text=刪除到詞首
action.EditorDeleteToWordStartInDifferentHumpsMode.text=在不同的 \\"CamelHumps\\" 模式下刪除到詞首
action.EditorDeleteToWordEnd.text=刪除到詞尾
action.EditorDeleteToWordEndInDifferentHumpsMode.text=在不同的 \\"CamelHumps\\" 模式下刪除到詞尾
action.EditorDeleteLine.text=刪除行
action.EditorKillToWordStart.text=終止至詞首
action.EditorKillToWordEnd.text=終止至詞尾
action.EditorKillRegion.text=終止所選區域
action.EditorKillRingSave.text=儲存至終止環
action.EditorDuplicate.text=重複行或選區
action.EditorDuplicateLines.text=重複整行
action.EditorSortLines.text=排序行
action.EditorReverseLines.text=反轉行
action.EditorSelectWord.text=擴展選區
action.EditorUnSelectWord.text=收縮選區
group.EditorBidiTextDirection.text=雙向文本基礎方向
group.EditorBidiTextDirection.description=混合 LTR/RTL 文本的主要方向
action.EditorSetContentBasedBidiTextDirection.text=基於內容
action.EditorSetContentBasedBidiTextDirection.description=方向由初始字符決定
action.EditorSetLtrBidiTextDirection.text=左到右
action.EditorSetRtlBidiTextDirection.text=右到左
action.EditorToggleInsertState.text=切換插入/覆蓋
action.EditorToggleColumnMode.text=列選擇模式(_M)
action.EditorToggleColumnMode.description=在當前編輯器中切換列選擇模式
action.EditorToggleShowWhitespaces.text=顯示空白(_O)
action.EditorToggleShowWhitespaces.description=在當前編輯器中切換顯示空白
action.EditorToggleShowIndentLines.text=顯示縮排參考線(_O)
action.EditorToggleShowIndentLines.description=在當前編輯器中切換顯示縮排參考線
action.EditorToggleShowBreadcrumbs.text=顯示路徑導航
action.EditorToggleShowBreadcrumbs.description=在當前編輯器中切換顯示路徑導航欄
action.EditorToggleShowLineNumbers.text=顯示行號(_I)
action.EditorToggleShowLineNumbers.description=在當前編輯器中切換顯示行號
action.EditorToggleShowGutterIcons.text=顯示間距圖標 (_O)
action.EditorToggleShowGutterIcons.description=在當前編輯器中切換顯示間距圖標
action.EditorToggleUseSoftWraps.text=自動換行
action.EditorToggleUseSoftWraps.description=在當前編輯器中切換使用自動換行
action.EditorToggleUseSoftWrapsInPreview.text=自動換行預覽編輯器
action.EditorToggleUseSoftWrapsInPreview.description=在預覽編輯器中切換使用自動換行
action.RestoreFontPreviewTextAction.text=恢復預覽文本
action.fontEditorPreview.ToggleBoldFont.text=切換加粗的字體
action.EditorConsoleScrollToTheEnd.text=滾動到結尾
action.EditorIncreaseFontSize.text=增大字體大小
action.EditorDecreaseFontSize.text=減小字體大小
action.ViewImportPopups.text=顯示匯入彈出視窗
action.ViewImportPopups.description=在當前檔案中切換顯示匯入彈出視窗
action.EditorScrollToCenter.text=滾動到中心
action.EditorToggleCase.text=切換大小寫
action.EditorJoinLines.text=連接行
action.EditorSelectLine.text=擴展行選區
action.EditorSelectSingleLineAtCaret.text=選擇文本游標處的一行
action.EditorSplitLine.text=拆分行
action.EditorStartNewLine.text=開始新行
action.EditorStartNewLineBefore.text=在當前位置之前開始新行
action.EditorCompleteStatement.text=補全當前語句
action.ExpandAll.text=全部展開
action.CollapseAll.text=全部摺疊
action.ExportToTextFile.text=匯出到文本檔案
action.ExpandTreeNode.text=展開樹節點
action.CollapseTreeNode.text=摺疊樹節點
action.FullyExpandTreeNode.text=完全展開樹節點
group.GenerateGroup.text=生成(_G)
action.GenerateTestMethod.text=測試方法
action.GenerateSetUpMethod.text=SetUp 方法
action.GenerateBeforeClassMethod.text=BeforeClass 方法
action.GenerateTearDownMethod.text=TearDown 方法
action.GenerateAfterClassMethod.text=AfterClass 方法
action.GenerateDataMethod.text=參數方法
action.GenerateConstructor.text=構造函數
action.GenerateConstructor.description=生成構造函數
action.GenerateCreateUI.text=createUI(...)
action.GenerateCreateUI.description=生成 createUI(...)
action.GenerateGetter.text=Getter
action.GenerateGetter.description=生成 getter
action.GenerateSetter.text=Setter
action.GenerateSetter.description=生成 setter
action.GenerateGetterAndSetter.text=Getter 和 Setter
action.GenerateGetterAndSetter.description=生成 getter 和 setter
action.GenerateEquals.text=equals() 和 hashCode()
action.GenerateEquals.description=生成 equals() 和 hashCode()
action.OverrideMethods.text=覆寫方法(_O)…
action.OverrideMethods.description=在當前類中覆寫基類方法
action.ImplementMethods.text=實作方法(_I)…
action.ImplementMethods.description=在當前類中實作基接口/類方法
action.DelegateMethods.text=委託方法...(_D)
action.DelegateMethods.description=為欄位/getter 生成委託方法
action.GenerateSuperMethodCall.text=super 方法調用
action.GenerateSuperMethodCall.description=生成 super 方法調用
action.NextDiff.text=下一個差異
action.NextDiff.description=移至下一個差異
action.PreviousDiff.text=上一個差異
action.PreviousDiff.description=移至上一個差異
action.Diff.NextConflict.text=下一個衝突
action.Diff.NextConflict.description=移至下一個未解決的衝突
action.Diff.PreviousConflict.text=上一個衝突
action.Diff.PreviousConflict.description=移至上一個未解決的衝突
action.GotoChangedFile.text=轉到更改的檔案…
action.GotoChangedFile.description=按名稱快速導航到更改的檔案
action.Refresh.text=刷新(_E)
action.CheckinProject.text=提交(_I)…
action.CheckinFiles.text=提交檔案(_I)
action.CheckinFiles.description=提交選中的檔案或目錄
action.UpdateFiles.text=更新(_U)
action.CheckStatusForFiles.text=檢查狀態(_K)
action.Annotate.text=註解(_N)
action.Annotate.with.Blame.text=使用 Git 追溯註解(_N)
action.Annotate.synonym1=追溯
action.Annotate.description=顯示每行的最新修改日期和作者(也稱為“追溯”)
action.Compare.SameVersion.text=與同一個儲存庫版本進行比較(_Y)
action.Compare.LastVersion.text=與最新的儲存庫版本進行比較(_V)
action.Compare.Selected.text=與修訂比較(_C)…
group.NewGroup.text=新建(_N)
group.NewElement.text=新建(_N)
group.NewElementMenu.text=新建(_N)
group.NewElementInMenuGroup.text=新建(_N)
group.WeighingNewGroup.text=新建(_N)
action.NewClass.text=Java 類
action.NewFile.text=檔案
action.NewDir.text=目錄/軟體套件
action.NewFromTemplate.text=從模板
action.ImportModule.text=來自現有源的模組…
action.ProjectFromVersionControl.text=來自版本控制的專案…
action.ImportProject.text=來自現有源的專案…
action.SaveAsNewFormat.text=另存為基於目錄的格式…
action.JShell.Console.text=JShell 控制台…
action.JShell.Console.description=啟動 JShell 控制台
action.ChangesView.GroupBy.Module.text=模組
action.Actions.ActionsPlugin.GenerateToString.text=to_String()
action.Actions.ActionsPlugin.GenerateToString.description=生成 toString() 方法
action.DumpThreads.text=獲取執行緒轉儲
action.Debugger.ShowRelatedStack.text=顯示相關堆疊…
action.Debugger.ShowTypes.text=顯示類型
action.Debugger.AddSteppingFilter.text=添加步進篩選器…
action.Debugger.StepOutOfBlock.text=單步跳出程式碼塊
action.Debugger.CreateRenderer.text=創建…
action.Debugger.CreateRenderer.XDebuggerTreeInlayPopup.text=創建呈現器
action.Debugger.MuteRenderers.text=靜默呈現器
action.Debugger.AsyncStacks.text=異步堆疊跟踪
action.Debugger.SwitchToTheNextContext.text=切換到下一個停止的斷點
action.Debugger.CallTracer.text=跟踪調用
action.Debugger.ReloadFile.text=編譯並重新載入檔案
action.MemoryView.ShowInstancesFromDebuggerTree.text=顯示實例
action.Memory.CalculateRetainedSize.text=計算保留大小…
action.MemoryView.ShowAllocationStackTrace.text=跳轉到分配位置
action.MemoryView.ShowOnlyWithInstances.text=僅顯示實例
action.MemoryView.ShowOnlyTracked.text=僅顯示跟踪類
action.MemoryView.EnableTrackingWithClosedWindow.text=啟用具有隱藏記憶體檢視的跟踪
action.MemoryView.ShowInstances.text=顯示實例
action.MemoryView.ShowNewInstances.text=顯示新實例
action.MemoryView.JumpToTypeSource.text=跳轉到類型源
action.MemoryView.TrackingAction.NewInstancesTracking.text=跟踪新實例
action.Diff.ShowDiff.text=顯示差異
action.Diff.ShowDiff.description=比較檔案或修訂。
action.CompareTwoFiles.text=比較檔案(_F)
action.CompareTwoFiles.description=比較兩個所選檔案或資料夾
action.CompareFileWithEditor.text=與編輯器比較檔案(_M)
action.CompareFileWithEditor.description=將所選檔案與編輯器中的檔案進行比較
action.JumpToColorsAndFonts.text=跳轉到顏色和字體
action.JumpToColorsAndFonts.description=跳轉到文本游標處的顏色和字體選項
group.ViewAppearanceGroup.text=外觀(_A)

group.LocalHistory.text=本地歷史記錄(_H)
action.LocalHistory.ShowHistory.text=顯示歷史記錄(_H)
action.LocalHistory.ShowHistory.GoToAction.text=顯示本地歷史記錄
action.LocalHistory.ShowSelectionHistory.text=顯示選區的歷史記錄
action.LocalHistory.ShowSelectionHistory.GoToAction.text=顯示選中的本地歷史記錄
action.LocalHistory.PutLabel.text=放置標籤(_L)…

group.VcsGroups.text=_Git
group.VcsGlobalGroup.text=VCS 組
action.Vcs.UpdateProject.text=更新專案(_U)
group.VcsGroup.text=版本控制
group.VcsFileGroupPopup.text=版本控制組
group.FileMenu.text=檔案(_F)
action.NewProject.text=專案(_P)…
action.NewProject.description=從頭創建一個新項目
action.NewModule.text=模組(_M)…
action.NewModule.description=從頭創建新模組並將其添加到專案
action.ImportProject.description=為包含現有源的目錄創建專案結構或者轉換現有專案模型
action.ImportModule.description=從包含現有源的目錄或者現有專案模型匯入模組
action.OpenFile.text=打開(_O)…
action.OpenFile.description=在編輯器中打開專案或檔案
group.reopen.win.text=重新打開專案(_R)
group.reopen.mac.text=打開最近(_R)
group.$LRU.text=打開最近(_R)
group.$LRU.GoToAction.text=打開最近的專案
action.ManageRecentProjects.text=管理專案…
group.$LRU.description=最近打開專案的列表
action.CloseProject.text=關閉專案(_J)
action.CloseProject.description=關閉當前專案
action.CloseAllProjects.text=關閉所有專案
action.CloseAllProjects.description=關閉所有專案
action.CloseOtherProjects.text=關閉其他專案
action.CloseOtherProjects.description=關閉其他專案
action.ShowProjectStructureSettings.text=專案結構...
action.ShowProjectStructureSettings.description=配置專案結構
action.SaveAll.text=全部儲存(_S)
action.SaveAll.description=儲存所有檔案和設定
action.ExportSettings.text=匯出設定(_E)…
action.ExportSettings.description=匯出全域設定
action.ImportSettings.text=匯入設定…
action.ImportSettings.description=匯入全域設定
action.RestoreDefaultSettings.text=恢復預設設定…
action.RestoreDefaultSettings.description=將所有設定重置為其預設值
action.ExportToEclipse.text=匯出到 Eclipse…
action.ExportToEclipse.description=為每個模組創建 Eclipse 專案
action.Synchronize.text=從磁碟全部重新載入
action.Synchronize.description=檢測所有外部更改的檔案，並從磁碟重新載入
action.InvalidateCaches.text=清除快取...
action.InvalidateCaches.description=在下次啟動時強制重新構建所有快取和索引
action.RestartIde.text=重啟 IDE…
action.ExportToHTML.text=將檔案或選區匯出到 HTML(_H)…
action.ExportToHTML.MainMenu.text=將檔案或選區匯出到 HTML(_H)…
action.ExportToHTML.description=以 HTML 格式儲存檔案內容，包括語法顏色
action.Print.text=列印(_P)…
action.Print.description=列印檔案
action.Exit.text=退出(_X)
action.Exit.description=退出 IDE
group.EditMenu.text=編輯(_E)
group.FindMenuGroup.text=尋找(_F)
action.undo.text=撤消{0}(_U)
action.undo.description=撤消{0}
action.undo.description.empty=最後操作
action.redo.text=重做{0}(_R)
action.redo.description=重做{0}
action.redo.description.empty=最後的撤消操作
action.$Cut.text=剪下(_T)
action.$Cut.description=剪下到剪貼簿
action.$Copy.text=複製(_C)
action.$Copy.description=複製到剪貼簿
action.$SearchWeb.text=使用 Google 搜尋(_S)
action.$SearchWeb.description=使用 Google 搜尋選區
action.CopyUrl.text=複製 URL
action.CopyUrl.description=將文本游標下的 URL 複製到剪貼簿
action.CopyPaths.text=複製路徑(_O)
action.CopyPaths.description=將與所選檔案或目錄對應的路徑複製到剪貼簿
action.CopyReference.text=複製引用(_Y)
action.CopyReference.description=複製對所選類、方法、函數或所選檔案的相對路徑的引用
action.CopySettingsPath.text=複製設定路徑
action.CopySettingsPath.mac.text=複製首選項路徑
action.CopySettingsPath.description=複製選定可配置選項的相對路徑
action.CopyAsRichText.text=複製為富文本
action.CopyAsRichText.description=將選區複製到剪貼簿作為富文本(以 RTF 和 HTML 格式)
action.CopyAsPlainText.text=複製為純文本
action.CopyAsPlainText.description=將選區複製到剪貼簿作為純文本
group.Copy.Paste.Special.text=複製/貼上特殊
group.Copy.Paste.Special.description=複製/貼上特殊編輯器操作
action.$Paste.text=貼上(_P)
action.$Paste.description=從剪貼簿貼上
action.PasteMultiple.text=從歷史記錄貼上(_E)…
action.PasteMultiple.description=從最近的剪貼簿貼上
action.$SelectAll.text=全選(_A)
action.$SelectAll.description=全選
action.NewElement.text=新建(_N)…
action.NewElement.description=創建新的類、接口、檔案或目錄
action.NewElementSamePlace.text=在當前目錄新建(_N)…
action.NewElementSamePlace.description=在此目錄中創建新的類、接口、檔案或目錄
action.$Delete.text=刪除(_D)
action.$Delete.description=刪除所選條目
action.Find.text=尋找(_F)…
action.Find.description=在活動編輯器中尋找字串
action.Replace.text=取代(_R)…
action.Replace.description=使用另一個字串取代活動編輯器中的字串
action.FindNext.text=尋找下一個/移至下一個符合項(_N)
action.FindNext.MainMenu.text=尋找下一個符合項(_N)
action.FindNext.description=重複上一次尋找/取代操作，或移至所選文本的下一個符合項
action.FindPrevious.text=尋找上一個/移至上一個符合項(_V)
action.FindPrevious.MainMenu.text=尋找上一個符合項(_V)
action.FindPrevious.description=反向重複上一次尋找/取代操作，或移至所選文本的上一個符合項
action.FindWordAtCaret.text=尋找文本游標處的字
action.FindWordAtCaret.description=尋找文本游標處單詞的下一個符合項
action.ToggleFindInSelection.text=僅在選擇範圍內搜尋
action.IncrementalSearch.text=增量搜尋(_L)
action.IncrementalSearch.description=啟動增量搜尋(輸入時搜尋字串)，IntelliJ IDEA 6.0 實作。
action.FindUsages.text=尋找用法(_U)
action.FindUsages.description=尋找文本游標處符號的用法
action.ShowUsages.text=顯示用法(_S)
action.ShowUsages.description=顯示文本游標處符號的用法
action.ShowSettingsAndFindUsages.text=尋找用法設定…
action.ShowSettingsAndFindUsages.description=為“尋找用法”操作選擇範圍和編輯選項
action.FindUsagesInFile.text=在檔案中尋找用法(_I)
action.FindUsagesInFile.description=在活動編輯器中尋找文本游標處符號的用法
action.HighlightUsagesInFile.text=高亮顯示檔案中的用法(_H)
action.HighlightUsagesInFile.description=在活動編輯器中高亮顯示文本游標處符號的用法
action.HighlightUsagesInFile.not.ready=此用法搜尋需要索引，在索引構建之前無法執行
action.FindInPath.text=在檔案中尋找…
action.FindInPath.description=在多個檔案中尋找字串
action.FindInPath.synonym1=在路徑中尋找
action.ReplaceInPath.text=在檔案中取代(_A)…
action.ReplaceInPath.synonym1=在路徑中取代(_A)
action.ReplaceInPath.description=在多個檔案中使用另一個字串取代一個字串
group.ViewMenu.text=檢視(_V)
action.ViewToolBar.text=工具欄(_T)
action.ViewObsoleteToolbarAction.text=工具欄經典
action.ViewObsoleteNavBarAction.text=導航欄
action.ViewNewToolbarAction.text=工具欄
action.ViewToolBar.description=顯示/隱藏主工具欄
action.QuickPreview.text=快速預覽
action.ViewStatusBar.text=狀態欄(_S)
action.ViewStatusBar.description=顯示/隱藏狀態欄
group.ViewStatusBarWidgetsGroup.text=狀態欄微件(_W)
group.ViewToolbarNewGroup.text=主工具欄
group.ViewStatusBarWidgetsGroup.description=顯示/隱藏狀態欄微件
action.ViewMainMenu.text=主選單
action.ViewMainMenu.description=顯示/隱藏主菜單
action.ViewToolButtons.text=工具視窗
action.ViewToolButtons.description=顯示/隱藏工具視窗按鈕
action.ViewNavigationBar.text=導航欄(_V)
action.ViewNavigationBar.description=顯示/隱藏導航欄
action.ViewNavigationBar.NavBar.text=顯示導航欄
action.ViewMembersInNavigationBar.text=導航欄中的成員
action.ViewMembersInNavigationBar.description=在導航欄中顯示/隱藏宣告
action.ViewMembersInNavigationBar.NavBar.text=在導航欄中顯示成員
action.ViewInplaceComments.text=樹檢視中的詳細資訊
action.ViewInplaceComments.description=在樹檢視中顯示/隱藏額外資訊
action.FileStructurePopup.text=檔案結構(_I)
action.FileStructurePopup.description=當前檔案的彈出視窗結構，用於快速導航
action.ShowFilePath.text=檔案路徑(_P)
action.ShowFilePath.description=當前檔案的彈出視窗路徑，用於在外部檔案管理器中打開
action.ShowFilePath.file=檔案路徑(_P)
action.ShowFilePath.directory=目錄路徑(_P)
action.SelectIn.text=選擇(_L)…
action.SelectIn.description=在任意檢視下選擇當前的類或方法
action.FixDocComment.text=修正文檔註釋
action.FixDocComment.description=生成或修正當前上下文的文檔註釋
action.QuickJavaDoc.text=快速文檔(_D)
action.QuickJavaDoc.description=顯示包含文本游標處符號的文檔的彈出視窗
action.QuickImplementations.text=快速定義(_K)
action.QuickImplementations.description=顯示包含符號(及其實作)內容的彈出視窗
action.QuickTypeDefinition.text=快速類型定義
action.QuickTypeDefinition.description=顯示包含文本游標處符號的類型定義的彈出視窗
action.ToggleRenderedDocPresentation.text=切換渲染檢視
action.ToggleRenderedDocPresentation.description=在查看原始碼和文檔註釋的渲染表示之間切換
action.ToggleRenderedDocPresentationForAll.text=渲染所有文檔註釋
action.ToggleRenderedDocPresentationForAll.description=切換到所有文檔註釋的渲染檢視
action.ShowSiblings.text=顯示同級
action.ShowSiblings.description=顯示包含符號同級內容的彈出視窗
action.ParameterInfo.text=參數資訊(_P)
action.ParameterInfo.description=顯示文本游標處方法的參數
action.ToggleInlineHintsAction.text=切換參數名稱提示
action.ToggleInlineHintsAction.description=切換參數名稱提示
action.ToggleCompletionHintsAction.text=補全時顯示參數名稱提示
action.ShowParameterHintsSettings.text=提示設定…
action.ShowParameterHintsSettings.description=打開參數名稱提示設定
action.ExpressionTypeInfo.text=類型資訊(_E)
action.ExpressionTypeInfo.description=顯示所選表達式的類型
action.EditorContextInfo.text=上下文資訊(_C)
action.EditorContextInfo.description=不可見時，顯示當前方法或類宣告
action.ShowErrorDescription.text=錯誤描述(_R)
action.ShowErrorDescription.description=顯示文本游標處錯誤或警告的說明
action.EditSource.text=跳轉到原始碼(_J)
action.EditSource.description=打開所選條目的編輯器並使之獲得焦點
action.EditSourceInNewWindow.text=在新窗口中打開源
action.EditSourceInNewWindow.description=在新窗口打開所選條目的編輯器並使之獲得焦點
action.EditSourceInNewWindow.EditorTabPopup.text=將頁籤移動到新窗口
action.ViewSource.text=顯示源(_W)
action.ViewSource.description=打開所選條目的編輯器
action.ExternalJavaDoc.text=外部文檔(_X)
action.ExternalJavaDoc.description=打開包含所選條目文檔的瀏覽器

group.SwitcherAndRecentFiles.text=切換器(RecentFiles)操作
action.Switcher.text=切換器
action.SwitcherForward.text=選擇下一行
action.SwitcherBackward.text=選擇上一行
action.SwitcherRecentEditedChangedToggleCheckBox.text=切換僅更改的檔案
action.SwitcherIterateItems.text=迭代最近的檔案
action.SwitcherNextProblem.text=選擇下一個問題檔案
action.SwitcherPreviousProblem.text=選擇上一個問題檔案
action.RecentFiles.text=最近的檔案(_N)
action.RecentFiles.description=顯示最近查看檔案的列表
action.RecentChangedFiles.text=最近更改的檔案
action.RecentChangedFiles.description=顯示最近更改檔案的列表
action.RecentLocations.text=最近的位置
action.RecentLocations.description=顯示最近查看/更改的位置列表
action.QuickChangeScheme.text=快速切換方案(_Q)…
action.QuickChangeScheme.description=更改當前的程式碼樣式方案、顏色與字體方案、鍵盤映射或外觀
action.TypeHierarchy.text=類型層次結構(_H)
action.TypeHierarchy.description=瀏覽所選類的層次結構
action.MethodHierarchy.text=方法層次結構(_M)
action.MethodHierarchy.description=瀏覽所選方法的方法層次結構
action.CallHierarchy.text=調用層次結構(_Y)
action.CallHierarchy.description=瀏覽所選方法的調用層次結構
group.FoldingGroup.text=折疊
group.ExpandToLevel.text=展開到級別(_E)
action.ExpandToLevel1.text=_1
action.ExpandToLevel2.text=_2
action.ExpandToLevel3.text=_3
action.ExpandToLevel4.text=_4
action.ExpandToLevel5.text=_5
group.ExpandAllToLevel.text=全部展開到級別(_L)
action.ExpandAllToLevel1.text=_1
action.ExpandAllToLevel2.text=_2
action.ExpandAllToLevel3.text=_3
action.ExpandAllToLevel4.text=_4
action.ExpandAllToLevel5.text=_5
action.ExpandRegion.text=展開(_X)
action.ExpandRegion.description=展開文本游標處的折疊區域
action.ExpandRegionRecursively.text=遞歸展開(_R)
action.ExpandRegionRecursively.description=遞歸展開文本游標處的塊
action.CollapseRegion.text=摺疊(_C)
action.CollapseRegion.description=摺疊文本游標處的折疊區域
action.CollapseRegionRecursively.text=遞歸折疊(_A)
action.CollapseRegionRecursively.description=遞歸摺疊文本游標處的塊
action.ExpandAllRegions.text=全部展開(_E)
action.ExpandAllRegions.description=展開所有折疊區域(選區中)
action.CollapseAllRegions.text=全部摺疊(_A)
action.CollapseAllRegions.description=摺疊所有折疊區域(選區中)
action.ExpandDocComments.text=展開文檔註釋(_D)
action.ExpandDocComments.description=展開所有文檔註釋
action.CollapseDocComments.text=摺疊文檔註釋(_O)
action.CollapseDocComments.description=摺疊所有文檔註釋
action.CollapseSelection.text=折疊選區/移除區域(_S)
action.CollapseSelection.description=折疊所選塊
action.CollapseBlock.text=折疊程式碼塊(_B)
action.CollapseBlock.description=折疊當前程式碼塊
action.RecentChanges.text=最近的變更(_E)
group.GoToMenu.text=導航(_N)
action.SearchEverywhere.text=隨處搜尋
action.SearchEverywhereToolbar.text=隨處搜尋 
action.SearchEverywhereToolbarHotKey.text=隨處搜尋 {0}
action.SearchEverywhere.description=搜尋類、檔案、工具視窗、操作和偏好設定
action.SmartSelect.text=擴展選區
action.SmartUnSelect.text=收縮選區
action.GotoClass.text=類...(_C)
action.GotoClass.description=通過名稱快速導航到類
action.GotoFile.text=轉到檔案...
action.GotoFile.MainMenu.text=檔案(_F)…
action.GotoFile.description=通過名稱快速導航到檔案
action.GotoSymbol.text=轉到符號...
action.GotoSymbol.MainMenu.text=符號(_S)…
action.GotoSymbol.description=通過名稱快速導航到任意符號
action.GotoCustomRegion.text=自訂折疊…
action.GotoAction.text=尋找操作(_F)…
action.GotoAction.description=通過名稱快速導航到操作
action.GotoLine.text=轉到行:列…
action.GotoLine.MainMenu.text=行:列(_L)...
action.GotoLine.description=通過編號在編輯器中導航到某一行(和/或列)
action.GotoDeclarationOnly.text=轉到宣告
action.GotoDeclarationOnly.description=導航到文本游標處符號的宣告
action.GotoDeclaration.text=前往宣告或用法
action.GotoDeclaration.MainMenu.text=宣告或用例(_D)
action.GotoDeclaration.description=導航到文本游標處符號的宣告或顯示其用法
action.GotoImplementation.text=轉到實作(_M)
action.GotoImplementation.MainMenu.text=實作(_M)
action.GotoImplementation.description=導航到所選類或方法的實作
action.GotoNextElementUnderCaretUsage.text=下一個高亮顯示用例
action.GotoNextElementUnderCaretUsage.description=導航到下一個高亮的元素用法
action.GotoPrevElementUnderCaretUsage.text=轉到上一個高亮的元素用法
action.GotoPrevElementUnderCaretUsage.description=導航到上一個高亮的元素用法
action.GotoTypeDeclaration.text=轉到類型宣告
action.GotoTypeDeclaration.MainMenu.text=類型宣告(_T)
action.GotoTypeDeclaration.description=導航到文本游標處符號類型的宣告
action.GotoSuperMethod.text=轉到 Super 方法
action.GotoSuperMethod.MainMenu.text=super 方法(_U)
action.GotoSuperMethod.description=導航到當前方法覆寫或實作的方法的宣告
action.GotoTest.text=轉到測試
action.GotoTest.MainMenu.text=測試(_E)
action.GotoTest.description=導航到所選類的測試
action.GotoTestSubject.text=轉到測試主題(_E)
action.GotoTestSubject.MainMenu.text=測試物件(_E)
action.GotoTestSubject.description=導航到所選測試的物件
action.GotoNextError.text=下一個高亮顯示錯誤(_N)
action.GotoNextError.description=在活動編輯器中導航到下一個高亮顯示的錯誤
action.GotoPreviousError.text=上一個高亮顯示錯誤(_P)
action.GotoPreviousError.description=在活動編輯器中導航到上一個高亮顯示的錯誤
action.GotoRelated.text=相關符號(_R)…
action.GotoRelated.description=導航到一個相關或鏈接的符號
action.MethodDown.text=下一個方法(_E)
action.MethodDown.description=在活動編輯器中導航到下一個方法
action.MethodUp.text=上一個方法(_I)
action.MethodUp.description=在活動編輯器中導航到上一個方法
action.Back.text=後退(_B)
action.Back.description=撤消上次導航操作
action.Forward.text=前進(_W)
action.Forward.description=恢復上次撤消的導航操作
action.JumpToLastChange.text=最後編輯位置(_O)
action.JumpToLastChange.description=在最近的變更點中移動
action.JumpToNextChange.text=下一個編輯位置
action.JumpToNextChange.description=在最近的變更點中移動
action.PreviousOccurence.text=上一個符合項(_O)
action.PreviousOccurence.description=導航到上一個符合項
action.NextOccurence.text=下一個符合項(_X)
action.NextOccurence.description=導航到下一個符合項
action.VcsShowCurrentChangeMarker.text=文本游標下的變更(_H)
action.VcsShowCurrentChangeMarker.description=顯示當前所選變更的彈出視窗
action.VcsShowNextChangeMarker.text=下一個變更(_H)
action.VcsShowNextChangeMarker.description=轉到下一個變更
action.VcsShowPrevChangeMarker.text=上一個變更(_A)
action.VcsShowPrevChangeMarker.description=轉到上一個變更
group.CodeMenu.text=程式碼(_C)
action.SurroundWith.text=環繞方式(_S)…
action.SurroundWith.description=使用 if/while/try-catch 或其他結構環繞所選程式碼段
action.Generate.text=生成…
action.Generate.description=生成構造函數、getter 或 setter 方法等
action.Unwrap.text=解開/移除(_W)…
action.Unwrap.description=安全地解開或移除所選範圍
group.CodeCompletionGroup.text=程式碼補全(_C)
group.EditorToggleActions.text=活動編輯器
action.CodeCompletion.text=基本(_B)
action.CodeCompletion.description=補全程式碼
action.HippieCompletion.text=迴圈擴展詞(_E)
action.HippieCompletion.description=迴圈擴展詞
action.HippieBackwardCompletion.text=迴圈擴展詞(向後)(_E)
action.HippieBackwardCompletion.description=迴圈擴展詞(向後)
action.SmartTypeCompletion.text=類型符合
action.SmartTypeCompletion.description=基於預期類型補全程式碼
action.SmartTypeCompletion.synonym=SmartType
action.ClassNameCompletion.text=第二基本補全
action.ClassNameCompletion.description=與雙擊基本補全快捷鍵相同(可用於補全非匯入類名)
action.InsertLiveTemplate.text=插入實時模板(_T)…
action.InsertLiveTemplate.description=顯示以指定前綴開頭的實時模板的彈出視窗列表
action.ExpandLiveTemplateByTab.text=按 Tab 展開實時模板
action.ExpandLiveTemplateCustom.text=展開實時模板/Emmet 縮寫
action.ExpandLiveTemplateCustom.description=使用在編輯器中鍵入的前綴調用綁定到 '自訂快捷鍵' 的實時模板
action.SurroundWithLiveTemplate.text=使用實時模板環繞(_P)…
action.SurroundWithLiveTemplate.description=使用一個模板環繞選區
action.CommentByLineComment.text=使用行註釋進行註釋(_L)
action.CommentByLineComment.description=使用行註釋註釋/取消註釋當前行或所選塊
action.CommentByBlockComment.text=使用塊註釋進行註釋(_B)
action.CommentByBlockComment.description=使用塊註釋註釋/取消程式碼
action.ReformatCode.text=重新格式化程式碼(_R)
action.ReformatCode.description=重新格式化程式碼
action.ReformatCode.synonym1=格式程式碼
action.AutoIndentLines.text=自動縮排行(_A)
action.AutoIndentLines.description=根據程式碼樣式設定縮排當前行或所選塊
action.OptimizeImports.text=優化 import(_Z)
action.OptimizeImports.description=移除未使用的 import 並重新排列/重新組織 import
action.RearrangeCode.text=重新排列程式碼
action.RearrangeCode.description=重新排列程式碼
action.ShowReformatFileDialog.text=重新格式化檔案...
action.ShowRecentTests.text=最近的測試
action.MoveStatementDown.text=向下移動語句(_W)
action.MoveStatementDown.description=將所選語句向下移動一行
action.MoveStatementUp.text=向上移動語句(_U)
action.MoveStatementUp.description=將所選語句向上移動一行
action.MoveElementLeft.text=向左移動元素
action.MoveElementLeft.description=將當前元素移至包含元素列表的上一個位置
action.MoveElementRight.text=向右移動元素
action.MoveElementRight.description=將當前元素移至包含元素列表的下一個位置
action.MoveLineDown.text=下移行(_W)
action.MoveLineDown.description=將所選行向下移動一行
action.MoveLineUp.text=上移行(_U)
action.MoveLineUp.description=將所選行向上移動一行
group.AnalyzeMenu.text=分析(_Z)
action.CodeCleanup.text=程式碼清理(_C)…
action.CodeCleanup.description=執行清理檢查並套用快速修復
action.SilentCodeCleanup.text=靜默程式碼清理
action.SilentCodeCleanup.description=執行清理檢查並使用當前檢查配置檔案套用快速修復
action.InspectCode.text=檢查程式碼(_I)…
action.InspectCode.description=檢查程式碼
action.InferNullity.text=推斷可空性...(_N)
action.InferNullity.description=推斷可空性
action.ViewOfflineInspection.text=查看離線檢查結果(_O)…
action.ViewOfflineInspection.description=載入離線檢查結果
action.ShowPackageDeps.text=分析依賴關係(_D)…
action.ShowPackageDeps.MainMenu.text=依賴項(_D)…
action.ShowPackageDeps.description=瀏覽所選分析項所依賴的程式碼
action.ShowBackwardPackageDeps.text=分析向後依賴關係(_B)…
action.ShowBackwardPackageDeps.MainMenu.text=向後依賴關係(_B)…
action.ShowBackwardPackageDeps.description=瀏覽使用的程式碼所選分析條目
action.ShowPackageCycles.text=分析迴圈依賴關係(_C)…
action.ShowPackageCycles.MainMenu.text=迴圈依賴關係(_C)…
action.ShowPackageCycles.description=瀏覽迴圈中使用的程式碼所選分析條目
action.ShowModulesDependencies.text=分析模組依賴關係(_M)…
action.ShowModulesDependencies.MainMenu.text=模組依賴項(_M)...
action.ShowModulesDependencies.description=顯示專案中模組之間的依賴關係
action.ShowDependenciesOnTarget.text=分析指定目標上的依賴項
action.ShowDependenciesOnTarget.MainMenu.text=指定目標上的依賴項
action.GenerateModuleDescriptors.text=生成 module-info 描述符
action.GenerateModuleDescriptors.description=為專案中的所有模組 module-info 檔案 (適用於 Java 9 及更高版本)
action.Unscramble.text=分析堆疊跟踪或執行緒轉儲(_S)…
action.Unscramble.description=打開包含可導航堆疊跟踪或執行緒轉儲的控制台
action.IdeScriptingConsole.text=IDE 腳本控制台
action.IdeScriptingConsole.description=打開 IDE 腳本控制台
action.NewScratchFile.text=臨時檔案
action.NewScratchFile.text.with.new=新建臨時檔案
action.NewScratchFile.description=與所選語言創建新的臨時檔案
action.NewScratchBuffer.text=新建臨時緩衝區
action.NewScratchBuffer.description=創建新的臨時緩衝區或重用現有的臨時緩衝區
action.Scratch.ChangeLanguage.text=更改檔案語言
action.Scratch.ChangeLanguage.description=更改臨時檔案語言
group.RefactoringMenu.text=重構(_R)
action.RenameElement.text=重命名(_R)…
action.RenameElement.description=重命名所選符號並更正所有引用
action.ChangeSignature.text=更改簽名(_G)…
action.ChangeSignature.description=更改所選方法或類的簽名，並更正所有引用
action.ChangeTypeSignature.text=類型遷移(_Y)…
action.ChangeTypeSignature.description=更改方法、欄位、參數、變數或類類型實參的返回類型的類型，並更正所有引用
action.MakeStatic.text=設為 static(_T)…
action.MakeStatic.description=將方法或內部類轉換為 static 並更正所有引用
action.ConvertToInstanceMethod.text=轉換為實例方法(_O)…
action.ConvertToInstanceMethod.description=將 static 方法轉換為實例方法並更正所有引用
action.Move.text=移動(_M)…
action.Move.description=將選中類、方法、包或 static 成員移動到另一個軟體套件或類，並更正所有引用
action.CopyElement.text=複製(_O)…
action.CopyElement.description=創建所選類、檔案或目錄的副本
action.SafeDelete.text=安全刪除(_D)…
action.SafeDelete.description=刪除所選類、方法或欄位，並檢查使用
action.ExtractMethod.text=提取方法(_M)…
action.ExtractMethod.description=將所選程式碼段轉換為一個方法
action.MethodDuplicates.text=尋找並取代程式碼重複項(_C)…
action.MethodDuplicates.field.text=尋找欄位重複項並取代為引用…
action.MethodDuplicates.method.text=尋找方法重複項並取代為調用…
action.MethodDuplicates.description=尋找所選範圍內可以轉換為所選方法/常數的調用的程式碼
action.InvertBoolean.text=反轉布林值(_B)…
action.InvertBoolean.description=使方法返回值或變數包含相反的值並更正引用
action.IntroduceParameterObject.text=引入參數物件(_J)…
action.IntroduceParameterObject.description=使用物件取代方法參數列表
action.ExtractClass.text=提取委託(_D)…
action.ExtractClass.description=提取委託
action.IntroduceVariable.text=引入變數(_V)…
action.IntroduceVariable.description=將所選表達式的結果放入變數中
action.IntroduceField.text=引入欄位(_F)…
action.IntroduceField.description=將所選表達式的結果放入欄位中
action.IntroduceConstant.text=引入常數(_C)…
action.IntroduceConstant.description=將所選表達式取代為常數
action.IntroduceParameter.text=引入參數(_P)…
action.IntroduceParameter.description=將所選表達式轉換為方法參數
action.IntroduceFunctionalParameter.text=引入功能參數(_L)…
action.IntroduceFunctionalParameter.description=通過調用新的函數方法參數來取代所選的語句
action.IntroduceFunctionalVariable.text=引入函數變數...
action.IntroduceFunctionalVariable.description=通過調用新的函數變數來取代所選的語句
action.ExtractInterface.text=提取接口(_I)…
action.ExtractInterface.description=從所選類提取接口
action.ExtractModule.text=提取模組...(_M)
action.ExtractModule.description=從所選類提取模組
action.ExtractSuperclass.text=提取超類(_U)…
action.ExtractSuperclass.description=從所選類提取超類
group.IntroduceActionsGroup.text=提取/引入(_X)
action.TurnRefsToSuper.text=盡可能使用接口(_W)…
action.TurnRefsToSuper.description=將類的用法更改為其超類或接口的用法
action.MembersPullUp.text=向上拉取成員(_L)…
action.MembersPullUp.description=將類成員拉取至超類或實作的接口
action.MemberPushDown.text=向下推送成員(_S)…
action.MemberPushDown.description=將類成員向下推送到直接繼承子類
action.InheritanceToDelegation.text=將繼承取代為委託(_I)…
action.InheritanceToDelegation.description=將繼承取代為委託
action.RenameFile.text=重命名檔案…
action.RenameFile.description=重命名所選檔案
action.Inline.text=內聯(_N)…
action.Inline.description=內聯所選方法或變數
action.AnonymousToInner.text=將匿名轉換成內部(_Y)…
action.AnonymousToInner.description=將匿名類轉換為內部類
action.EncapsulateFields.text=封裝欄位(_E)…
action.EncapsulateFields.description=使用存取器方法取代所選類中欄位的直接存取
action.ReplaceMethodWithMethodObject.text=用方法物件取代方法(_j)...
action.ReplaceMethodWithMethodObject.description=將方法轉換為自己的物件，以便所有參數都成為該物件上的欄位
action.Generify.text=將原始類型轉換為泛型…
action.Generify.description=轉換程式碼以使用泛型類型
action.Migrate.text=遷移…
action.Migrate.description=打開遷移對話框
action.ExtractInclude.text=包含檔案(_I)…
action.ExtractInclude.description=將所選程式碼段轉換為包含的檔案
group.BuildMenu.text=構建(_B)
action.CompileProject.text=重新構建專案(_R)
action.CompileProject.description=重新編譯專案中的所有檔案
action.CompileDirty.text=構建專案(_P)
action.CompileDirty.description=編譯專案中的所有修改和依賴檔案
action.BuildArtifact.text=構建工件…
action.BuildArtifact.description=選擇並構建專案中配置的工件
action.MakeModule.text=構建模組(_M)
action.MakeModule.description=編譯模組中的所有修改和依賴檔案
action.Compile.text=重新構建(_E)
action.CompileFile.text=重新編譯(_E)
action.Compile.description=強制重新編譯所選模組、檔案或軟體套件
action.DebugBuildProcess.text=調試構建過程
action.DebugBuildProcess.description=如果啟用，構建過程將在啟動時等待調試連接
group.BuildArtifactsGroup.text=構建工件
group.RunMenu.text=執行(_U)
group.RunnerActions.text=執行/調試
action.editRunConfigurations.text=編輯配置(_R)…
action.editRunConfigurations.description=打開“編輯執行/調試配置”對話框
action.Stop.text=停止
action.Stop.description=停止進程
action.StopBackgroundProcesses.text=停止背景進程...
action.StopBackgroundProcesses.description=停止背景進程
action.Hotswap.text=重新載入已更改的類(_A)
action.Hotswap.description=將所有更改的類重新載入到被調試的應用程式中 (熱插拔)
action.StepOver.text=步過(_O)
action.StepOver.description=單步執行至此檔案中的下一行
action.StepInto.text=步入(_I)
action.StepInto.description=單步執行至已執行的下一行
action.SmartStepInto.text=智能步入(_P)
action.SmartStepInto.description=單步進入特定方法
action.StepOut.text=步出(_T)
action.StepOut.description=單步執行至從此方法返回後執行的第一行
action.ForceStepOver.text=強制步過(_V)
action.ForceStepOver.description=步過，在步進前禁用所有斷點。
action.ForceStepInto.text=強制步入(_N)
action.ForceStepInto.description=步入，忽略庫、構造函數等的步進篩選器。
action.RunToCursor.text=執行到游標處(_C)
action.RunToCursor.description=跳轉到文本游標所在的行
action.ForceRunToCursor.text=強制執行到游標(_S)
action.ForceRunToCursor.description=執行到文本游標所在的行，忽略任何斷點
action.Debugger.PopFrame.text=丟幀(_F)
action.Debugger.PopFrame.description=將執行點移回方法調用，從堆疊中丟棄當前的方法幀
action.Debugger.ForceEarlyReturn.text=強制返回
action.Debugger.ForceEarlyReturn.description=強制方法在到達 return 語句之前返回
action.Debugger.ThrowException.text=拋出異常
action.Debugger.ThrowException.description=拋出一個異常
action.Debugger.ShowLibraryFrames.text=顯示/隱藏庫框架
action.XDebugger.PinToTop.text=固定至頂部
action.MemoryView.SwitchUpdateMode.text=在調試器停止時更新已載入的類
action.MemoryView.SwitchUpdateMode.description=在調試器暫停時載入類 (可能會增加調試器步進的開銷)
action.MemoryView.ShowOnlyWithDiff.text=僅顯示非零差異
action.Pause.text=暫停程序(_P)
action.Pause.description=掛起程序執行並啟用調試
action.Resume.text=恢復程序(_G)
action.Resume.description=恢復程序執行
action.EvaluateExpression.text=評估表達式(_X)…
action.EvaluateExpression.description=評估任意表達式
action.QuickEvaluateExpression.text=快速評估表達式(_Q)
action.QuickEvaluateExpression.description=評估所選表達式
action.ShowExecutionPoint.text=顯示執行點(_X)
action.ShowExecutionPoint.description=顯示當前程序執行點
action.Debugger.RestoreBreakpoint.text=恢復斷點
action.Debugger.RestoreBreakpoint.description=恢復上次刪除的斷點
action.ToggleLineBreakpoint.text=切換行斷點(_L)
action.ToggleLineBreakpoint.description=切換文本游標處的行斷點
action.ToggleLineBreakpoint.MainMenu.text=行斷點(_L)
action.ToggleMethodBreakpoint.text=切換方法斷點(_M)
action.ToggleMethodBreakpoint.MainMenu.text=方法斷點(_M)
action.ToggleMethodBreakpoint.description=為文本游標處的方法切換方法斷點
action.ToggleFieldBreakpoint.text=切換欄位觀察點(_F)
action.ToggleFieldBreakpoint.MainMenu.text= 欄位觀察點
action.ToggleFieldBreakpoint.description=為文本游標處的欄位切換欄位觀察點
action.ToggleBreakpointEnabled.text=切換斷點啟用狀態(_B)
action.ToggleBreakpointEnabled.description=啟用/禁用當前行的斷點
action.ToggleTemporaryLineBreakpoint.text=切換臨時行斷點
action.ToggleTemporaryLineBreakpoint.MainMenu.text=臨時行斷點
action.ToggleTemporaryLineBreakpoint.description=切換文本游標處的臨時行斷點
action.ViewBreakpoints.text=查看斷點(_K)…
action.ViewBreakpoints.description=查看和管理所有斷點和觀察點
action.EditBreakpoint.text=編輯斷點
action.ExportThreads.text=匯出執行緒(_H)…
action.ExportThreads.description=將所有執行緒資訊儲存到文本檔案或剪貼簿
action.Runner.RestoreLayout.text=恢復預設布局
action.Runner.RestoreLayout.description=將調試器會話的可視元素恢復為預設狀態
group.Runner.Layout.text=布局
group.Runner.Layout.description=布局配置
action.Runner.CloseView.text=關閉
action.Runner.CloseView.description=關閉檢視
action.Runner.CloseOtherViews.text=關閉其他
action.Runner.CloseOtherViews.description=關閉其他檢視
action.Runner.CloseAllViews.text=關閉所有
action.Runner.CloseAllViews.description=關閉所有檢視
action.Runner.CloseAllUnpinnedViews.text=關閉所有未固定的
action.Runner.CloseAllUnpinnedViews.description=關閉所有未固定的頁籤
action.Runner.FocusOnStartup.text=在啟動時獲取焦點
action.Runner.FocusOnStartup.description=當 UI 顯示時預設切換到該檢視
action.Debugger.FocusOnBreakpoint.text=在斷點時獲取焦點
action.Debugger.FocusOnBreakpoint.description=到達斷點時預設切換到此檢視
group.ToolsMenu.text=工具(_T)
action.SaveAsTemplate.text=儲存為實時模板(_I)…
action.SaveAsTemplate.description=將所選文本儲存為實時模板
action.SaveFileAsTemplate.text=將檔案另存為模板(_L)…
action.SaveFileAsTemplate.description=將當前檔案另存為模板
action.GenerateJavadoc.text=生成 JavaDoc(_D)…
action.GenerateJavadoc.description=執行 JavaDoc 工具
group.Macros.text=巨集(_S)
group.Macros.description=查看、更改、錄製、執行巨集
group.StandardMacroActions.text=標準巨集操作
action.PlaybackLastMacro.text=回放上一個巨集(_Y)
action.PlaybackLastMacro.description=播放上次使用的巨集
action.StartStopMacroRecording.text=啟動/停止巨集錄製(_R)
action.StartStopMacroRecording.description=啟動/停止新巨集錄製
action.EditMacros.text=編輯巨集(_E)
action.EditMacros.description=配置現有巨集
action.PlaySavedMacrosAction.text=播放儲存的巨集…
action.PlaySavedMacrosAction.description=播放儲存的巨集
group.MacrosGroup.text=巨集操作
action.ValidateXml.text=驗證(_V)
action.ValidateXml.description=驗證當前的 XML 檔案
action.GenerateDTD.text=從 XML 檔案生成 DTD(_X)
action.EmmetPreviousEditPoint.text=上一個 Emmet 編輯點
action.EmmetPreviousEditPoint.description=轉到上一個 Emmet 編輯點
action.EmmetNextEditPoint.text=下一個 Emmet 編輯點
action.EmmetNextEditPoint.description=轉到下一個 Emmet 編輯點
action.EmmetUpdateTag.text=使用 Emmet 更新標記
action.EmmetUpdateTag.description=使用 Emmet 縮寫更新現有 HTML 標記
action.EmmetPreview.text=Emmet 預覽
action.EmmetPreview.description=顯示 Emmet 縮寫的預覽
action.SurroundWithEmmet.text=使用 Emmet 環繞
action.SurroundWithEmmet.description=使用 Emmet 縮寫環繞選定程式碼
group.Emmet.text=Emmet
group.OpenInBrowserEditorContextBarGroupAction.description=打開位置…
action.OpenInBrowser.text=在預設瀏覽器中打開(_B)
action.OpenInBrowser.description=在預設瀏覽器中打開所選檔案
action.EscapeEntities.text=編碼 XML/HTML 特殊字符
action.EscapeEntities.description=使用實體轉義 XML/HTML 特殊字符
action.GenerateXmlTag.text=XML 標記…
action.GenerateXmlTag.description=根據架構資訊生成新的 XML 標記
group.NewXmlDescriptor.text=XML 配置檔案
group.NewXml.text=XML
action.DomCollectionControl.Remove.text=移除
action.DomCollectionControl.Edit.text=編輯
action.DomCollectionControl.Add.text=添加
action.DomElementsTreeView.DeleteElement.text=刪除元素
action.DomElementsTreeView.AddElement.text=插入元素
action.DomElementsTreeView.GotoDomElementDeclarationAction.text=轉到元素
action.Document2XSD.text=從 XSD 架構生成 XML 文檔…
action.XSD2Document.text=從 XML 檔案生成 XSD 架構…
group.ExternalToolsGroup.text=外部工具
action.PsiViewer.text=查看 PSI 結構(_V)…
action.PsiViewerForContext.text=查看當前檔案的 PSI 結構(_R)…
action.DebugListen.text=拋出調試異常
action.VirtualFileInfo.text=虛擬檔案資訊
action.Merge3Files.text=合併
action.DecodeBytesAction.text=解碼字節…
action.ReloadProjectAction.text=重新載入專案
action.ShowMainMenu.text=顯示主菜單
action.DumpInspectionDescriptions.text=轉儲檢查描述
action.DumpIntentionsDescriptions.text=轉儲意圖描述
group.WindowMenu.text=視窗(_W)
group.ToolWindowsGroup.text=工具視窗(_T)
group.BackgroundTasks.text=背景任務
action.ShowProcessWindow.text=顯示
action.ShowProcessWindow.description=顯示/隱藏背景任務視窗
action.ShowProcessWindow.double.click=點擊以顯示/隱藏背景任務視窗
action.AutoShowProcessWindow.text=自動顯示
action.AutoShowProcessWindow.description=啟動任何進程時顯示背景任務視窗
action.StoreDefaultLayout.text=將當前布局存儲為預設(_Y)
action.StoreDefaultLayout.description=將當前布局存儲為預設
action.MinimizeCurrentWindow.text=最小化
action.MinimizeCurrentWindow.description=最小化當前視窗
action.ZoomCurrentWindow.text=縮放
action.ZoomCurrentWindow.description=縮放當前視窗
action.TogglePresentationMode.text.enter=進入演示模式
action.TogglePresentationMode.text.exit=退出演示模式
action.TogglePresentationMode.text=切換演示模式
action.TogglePresentationMode.description=切換演示模式
action.ToggleDistractionFreeMode.text=切換免打擾模式
action.ToggleDistractionFreeMode.description=切換免打擾模式
action.ToggleFullScreen.text.enter=進入全屏
action.ToggleFullScreen.text.exit=退出全屏
action.ToggleFullScreen.text=切換全屏模式
action.ToggleFullScreen.description=切換全屏模式
action.ToggleZenMode.text=切換 Zen 模式
action.ToggleZenMode.description=同時切換免打擾和全屏模式
action.RestoreDefaultLayout.text=恢復預設布局(_F)
action.RestoreDefaultLayout.description=恢復預設布局
action.HideActiveWindow.text=隱藏活動工具視窗(_D)
action.HideActiveWindow.description=隱藏活動工具視窗
action.HideSideWindows.text=隱藏本側工具視窗
action.HideSideWindows.description=隱藏本側所有視窗
action.HideAllWindows.text=隱藏所有工具視窗(_T)
action.HideAllWindows.description=隱藏所有工具視窗
action.PinToolwindowTab.text=固定活動工具視窗頁籤(_I)
action.PinToolwindowTab.description=固定活動工具視窗頁籤
action.JumpToLastWindow.text=跳轉到上一個工具視窗(_J)
action.JumpToLastWindow.description=啟用上一個聚焦的工具視窗
group.ActiveToolwindowGroup.text=活動工具視窗
group.TW.ViewModeGroup.text=檢視模式
action.DockPinnedMode.text=停靠固定(_P)
action.DockPinnedMode.description=使工具視窗停靠並固定
action.DockUnpinnedMode.text=停靠不固定(_U)
action.DockUnpinnedMode.description=使工具視窗停靠但焦點丟失時自動隱藏
action.UndockMode.text=取消停靠(_D)
action.UndockMode.description=使工具視窗滑動並在焦點丟失時自動隱藏
action.FloatMode.text=浮動(_F)
action.FloatMode.description=將工具視窗移動到單獨的對話框
action.WindowMode.text=視窗(_W)
action.WindowMode.description=將工具視窗移動到單獨的框架
action.TogglePinnedMode.text=固定模式(_P)
action.TogglePinnedMode.description=固定/取消固定活動工具視窗
action.ToggleDockMode.text=停靠模式(_E)
action.ToggleDockMode.description=停靠/取消停靠活動工具視窗
action.ToggleFloatingMode.text=浮動模式(_M)
action.ToggleFloatingMode.description=浮動/取消浮動活動工具視窗
action.ToggleWindowedMode.text=視窗化模式(_W)
action.ToggleWindowedMode.description=視窗化/取消視窗化活動工具視窗
action.ToggleSideMode.text=拆分模式
action.ToggleSideMode.description=開啟/關閉工具視窗拆分模式
action.ToggleContentUiTypeMode.text=頁籤分組
action.ShowToolbar.text=顯示工具欄
action.ToggleContentUiTypeMode.description=切換內容的標籤式/組合式顯示
action.RemoveStripeButton.text=從邊欄中移除
action.RemoveStripeButton.description=從邊欄移除工具視窗按鈕
action.ShowContent.text=顯示頁籤列表
action.ShowContent.description=顯示一個包含工具視窗頁籤列表的彈出視窗
action.ShowContent.views.text=顯示檢視列表
group.ResizeToolWindowGroup.text=調整大小
action.ResizeToolWindowLeft.text=延伸至左側
action.ResizeToolWindowLeft.description=將活動工具視窗延伸至左側
action.ResizeToolWindowRight.text=延伸至右側
action.ResizeToolWindowRight.description=將活動工具視窗延伸至右側
action.ResizeToolWindowUp.text=延伸至頂部
action.ResizeToolWindowUp.description=將活動工具視窗延伸至頂部
action.ResizeToolWindowDown.text=延伸至底部
action.ResizeToolWindowDown.description=將活動工具視窗延伸至底部
action.ResizeToolWindowMaximize.text=最大化工具視窗
action.ResizeToolWindowMaximize.text.alternative=恢復工具視窗大小
action.IncrementWindowWidth.text=增大寬度
action.DecrementWindowWidth.text=減小寬度
action.IncrementWindowHeight.text=增大高度
action.DecrementWindowHeight.text=減小高度
action.NextTab.text=選擇下一個頁籤(_X)
action.NextTab.description=啟用下一個頁籤
action.PreviousTab.text=選擇上一個頁籤(_L)
action.PreviousTab.description=啟用上一個頁籤
action.GoToTab.text=選擇頁籤 #{0}
action.GoToTab.description=啟用頁籤 #{0}
action.GoToLastTab.text=選擇最後一個頁籤
action.GoToLastTab.description=啟用最後一個頁籤
action.NextEditorTab.text=在多編輯器檔案中選擇下一個頁籤
action.PreviousEditorTab.text=在多編輯器檔案中選擇上一個頁籤
action.CloseActiveTab.text=關閉活動頁籤(_O)
action.CloseActiveTab.description=關閉活動工具視窗頁籤
action.PinActiveTab.text=固定活動頁籤(_I)
action.PinActiveTab.description=固定活動編輯器或工具視窗頁籤
action.PinActiveTabToggle.text=固定活動頁籤
action.PinActiveTabToggle.description=固定活動編輯器或工具視窗頁籤
action.PinActiveEditorTab.text=固定活動頁籤(_I)
action.PinActiveEditorTab.description=固定活動編輯器頁籤
action.CloseEditor.text=關閉活動編輯器(_C)
action.CloseEditor.description=關閉活動編輯器
action.CloseEditor.EditorPopup.text=關閉 (_C)
action.CloseEditor.EditorTabPopup.text=關閉(_C)
action.CloseAllEditors.text=關閉所有頁籤(_A)
action.CloseAllEditors.description=在活動頁籤組中關閉所有編輯視窗
action.CloseAllEditorsButActive.text=關閉其他頁籤(_O)
action.CloseAllEditorsButActive.description=除活動編輯視窗外關閉所有其他視窗
action.CloseAllUnmodifiedEditors.text=關閉未修改頁籤(_U)
action.CloseAllUnmodifiedEditors.description=關閉所有未修改的編輯視窗
action.CloseAllUnpinnedEditors.text=關閉所有未固定
action.CloseAllUnpinnedEditors.description=關閉所有未固定的編輯視窗
action.CloseAllToTheRight.text=關閉右側頁籤
action.CloseAllToTheRight.description=關閉右邊的所有編輯器
action.CloseAllToTheLeft.text=關閉左側頁籤
action.CloseAllToTheLeft.description=關閉左邊的所有編輯器
action.CloseAllReadonly.text=關閉所有唯讀頁籤
action.CloseAllReadonly.description=關閉具有唯讀檔案的所有編輯器
action.CloseContent.text=關閉頁籤(_C)
action.CloseContent.description=關閉當前焦點的內容
group.EditorTabsGroup.text=編輯器頁籤(_T)
action.CloseFirstNotification.text=關閉第一個
action.CloseAllNotifications.text=關閉所有
group.Notifications.text=通知
action.SplitVertically.text=向右拆分
action.SplitVertically.synonym=垂直拆分
action.SplitVertically.description=將編輯器區域拆分為 2 個頁籤組，然後將當前檔案移至右側組
action.SplitHorizontally.text=向下拆分
action.SplitHorizontally.synonym=水平拆分
action.SplitHorizontally.description=將編輯器區域拆分為 2 個頁籤組，然後將當前檔案移至底部組
action.OpenInRightSplit.description=將編輯器區域拆分為 2 個頁籤組，然後將當前檔案打開到右側組
action.OpenInRightSplit.text=在右側拆分部分打開
action.StretchSplitToTop.text=將編輯器延伸至頂部
action.StretchSplitToTop.description=將拆分的編輯器延伸至頂部
action.StretchSplitToLeft.text=將編輯器延伸至左側
action.StretchSplitToLeft.description=將拆分的編輯器延伸至左側
action.StretchSplitToBottom.text=將編輯器延伸至底部
action.StretchSplitToBottom.description=將拆分的編輯器延伸至底部
action.StretchSplitToRight.text=將編輯器延伸至右側
action.StretchSplitToRight.description=將拆分的編輯器延伸至右側
action.MoveTabRight.text=拆分並右移
action.MoveTabRight.description=將編輯器區域拆分為 2 個頁籤組，然後將當前頁籤移至右側組並關閉左側編輯器
action.MoveTabDown.text=拆分並下移
action.MoveTabDown.description=將編輯器區域拆分為 2 個頁籤組，然後將當前頁籤移至底部組並關閉頂部編輯器
action.SplitChooser.text=通過選擇器以拆分方式打開…
action.SplitChooser.description=允許在編輯器中交互選擇拆分位置，並在該處打開/移動所選檔案
action.SplitChooser.NextWindow.text=下一個拆分
action.SplitChooser.PreviousWindow.text=上一個拆分
action.SplitChooser.Exit.text=退出選擇器
action.SplitChooser.Split.text=拆分
action.SplitChooser.Duplicate.text=複製
action.SplitChooser.SplitCenter.text=無拆分
action.SplitChooser.SplitTop.text=使用頂部拆分或向上切換
action.SplitChooser.SplitLeft.text=使用左拆分或左切換
action.SplitChooser.SplitDown.text=使用向下拆分或向下切換
action.SplitChooser.SplitRight.text=使用右拆分或右切換
action.ChangeSplitOrientation.text=更改拆分器方向(_R)
action.ChangeSplitOrientation.description=更改拆分器方向
action.Unsplit.text=取消拆分(_S)
action.Unsplit.description=取消拆分視窗
action.UnsplitAll.text=取消全部拆分(_N)
action.UnsplitAll.description=移除所有拆分器
action.NextSplitter.text=轉到下一個拆分器(_G)
action.NextSplitter.description=轉到下一個拆分視窗
action.PrevSplitter.text=轉到上一個拆分器
action.PrevSplitter.description=轉到上一個拆分視窗
action.NextProjectWindow.text=下一個專案視窗
action.NextProjectWindow.description=切換到下一個專案視窗
action.PreviousProjectWindow.text=上一個專案視窗
action.PreviousProjectWindow.description=切換到上一個專案視窗
group.OpenProjectWindows.text=打開專案視窗
group.HelpMenu.text=幫助(_H)
action.HelpTopics.text=幫助(_H)
action.HelpTopics.description=顯示幫助內容
action.ShowTips.text=每日小技巧(_T)
action.ShowTips.description=學習如何提高編碼效率。
action.DumpFeaturesAndTips.text=轉儲功能和提示資訊(_D)
action.DumpFeaturesAndTips.description=將有關功能和提示檔案的資訊複製到剪貼簿
action.ProductivityGuide.text=我的工作效率(_P)
action.ProductivityGuide.description=顯示工作效率功能使用統計
action.OnlineDocAction.text=入門指南(_G)
action.OnlineDocAction.description=顯示在線文檔
action.WhatsNewAction.text=最新變化(_N)
action.WhatsNewAction.description=了解此版本 IDE 中的新功能
action.Help.KeymapReference.text=鍵盤快捷鍵 PDF(_K)
action.Help.KeymapReference.description=打開帶有預設鍵盤映射參考卡的 PDF 檔案。
action.Help.JetBrainsTV.text=YouTube 上的產品
action.Help.JetBrainsTV.description=查看介紹 JetBrains 產品功能的簡短現場演示。
action.CheckForUpdate.text=檢查更新(_C)…
action.CheckForUpdate.description=檢查可用的 IDE 和套件更新
action.CheckForUpdate.WelcomeScreen.text=檢查更新
action.About.text=關於(_A)
action.About.description=顯示有關 IDE 的資訊
action.About.description.specialized=顯示有關 {0} 的資訊
group.OtherMenu.text=其他
group.OtherMenu.description=未正確註冊的操作
group.MainToolBar.text=主工具欄
group.Bookmarks.text=書籤
group.Bookmarks.Goto.text=轉到類型
group.Bookmarks.Toggle.text=切換類型

action.XDebugger.SetValue.text=設定值…
action.XDebugger.SetValue.XDebuggerTreeInlayPopup.text=設定值
action.XDebugger.SetValue.description=修改所選節點的值
action.XDebugger.CopyValue.text=複製值
action.XDebugger.CopyValue.description=將所選節點的值複製到剪貼簿
action.XDebugger.CompareValueWithClipboard.text=與剪貼簿比較值
action.XDebugger.CompareValueWithClipboard.description=將所選節點的值與剪貼簿文本進行比較
action.XDebugger.CopyName.text=複製名稱
action.XDebugger.CopyName.description=將所選節點的名稱複製到剪貼簿
action.XDebugger.JumpToSource.text=跳轉到原始碼
action.XDebugger.JumpToSource.description=打開所選條目的源
action.XDebugger.JumpToTypeSource.text=跳轉到類型源
action.XDebugger.JumpToTypeSource.description=打開所選值類型的源
action.XDebugger.Inspect.text=檢查…

action.Debugger.Tree.EvaluateInConsole.text=在控制台中評估

action.XDebugger.RemoveWatch.text=移除監視
action.XDebugger.RemoveAllWatches.text=移除所有監視
action.XDebugger.NewWatch.text=新建監視…
action.XDebugger.EditWatch.text=編輯…
action.XDebugger.CopyWatch.text=複製監視
action.XDebugger.MoveWatchUp.text=上移監視
action.XDebugger.MoveWatchDown.text=下移監視
action.XDebugger.SwitchWatchesInVariables.text=在變數頁籤中顯示監視
action.XDebugger.Inline.text=在編輯器中顯示變量值
action.XDebugger.Inline.description=在編輯器中顯示可用的調試器會話值
action.XDebugger.ToggleSortValues.text=按字母順序對變數進行排序
action.XDebugger.ToggleSortValues.description=在調試器檢視中按字母順序排列值
group.XDebugger.settings.text=設定

action.Debugger.AdjustArrayRange.text=調整範圍…
action.Debugger.FilterArray.text=篩選…
action.Debugger.ViewEditText.text=查看/編輯文本
action.Debugger.ViewText.text=查看文本
action.Debugger.ViewText.description=在單獨的窗格中查看所選節點的文本值
action.Debugger.EditCustomField.text=編輯…
action.Debugger.NewCustomField.text=新建類級別監視…
action.Debugger.RemoveCustomField.text=移除監視
action.Debugger.EditArrayFilter.text=編輯…
action.Debugger.RemoveArrayFilter.text=移除篩選器
action.Debugger.ShowReferring.text=顯示引用物件…
action.Debugger.CustomizeContextView.text=自訂資料檢視…
action.Debugger.CustomizeThreadsView.text=自訂執行緒檢視…
action.Debugger.EditFrameSource.text=EditFrameSource
action.Debugger.EditNodeSource.text=EditNodeSource
action.Debugger.ViewAsGroup.text=查看方式
action.Debugger.ResumeThread.text=恢復
action.Debugger.FreezeThread.text=掛起
action.Debugger.InterruptThread.text=中斷
action.Debugger.MarkObject.text=標記物件…
action.Debugger.MarkObject.unmark.text=取消標記物件
action.Debugger.MarkObject.description=標記/取消標記物件，以便可以在調試器檢視中直觀區分
action.Debugger.AddToWatch.text=添加到監視
action.Debugger.AddInlineWatch.text=添加內聯監視
action.Debugger.EvaluateInConsole.text=在控制台中評估
action.XDebugger.UnmuteOnStop.text=在會話完成時取消靜音斷點
action.Debugger.AutoRenderer.text=自動
group.EditorPopupMenu.text=編輯器彈出視窗選單
group.EditorPopupMenu.description=編輯器彈出視窗選單
group.EditorPopupMenu.GoTo.text=轉到
group.EditorPopupMenu.GoTo.description=轉到編輯器彈出視窗選單組
action.CompareClipboardWithSelection.text=與剪貼簿比較(_B)
action.CompareClipboardWithSelection.description=將當前選區與剪貼簿進行比較
action.ShowBlankDiffWindow.text=打開空白差異視窗
action.ShowBlankDiffWindow.synonym1=打開空的差異視窗
action.ShowBlankDiffWindow.synonym2=打開新的差異視窗
action.ShowBlankDiffWindow.description=並排打開兩個編輯器並比較他們的內容
action.ChangeColorScheme.text=編輯器配色方案
action.ChangeColorScheme.description=更改當前編輯器配色方案
action.ChangeCodeStyleScheme.text=程式碼樣式方案
action.ChangeCodeStyleScheme.description=更改當前程式碼樣式方案
action.ChangeKeymap.text=鍵盤映射
action.ChangeKeymap.description=更改當前鍵盤映射
action.ChangeLaf.text=主題
action.ChangeLaf.description=更改當前主題
action.ChangeView.text=檢視模式
action.ChangeView.description=更改檢視模式
action.ChangeInspectionProfile.text=錯誤高亮顯示
action.ChangeInspectionProfile.description=更改當前編輯器檢查配置檔案
action.MoveEditorToOppositeTabGroup.text=移至相反的組(_M)
action.MoveEditorToOppositeTabGroup.description=將編輯器移至相反的頁籤組
action.OpenEditorInOppositeTabGroup.text=在相反的組中打開(_O)
action.OpenEditorInOppositeTabGroup.description=在相反的頁籤組中打開此編輯器的副本
action.OpenModuleSettings.text=模組設定
action.ModuleSettings.text=模組設定(_S)
action.ModuleSettings.description=為所選模組打開設定對話框
group.MoveModuleToGroup.text=將模組移至組
group.MoveModuleToGroup.description=移動模組(_M)
action.AssociateWithFileType.text=與檔案類型關聯…
action.AssociateWithFileType.description=將所選檔案關聯到某種檔案類型
action.RestoreDefaultExtensionScripts.text=重置預設擴展
action.RestoreDefaultExtensionScripts.description=重置此目錄的捆綁擴展
action.SynchronizeCurrentFile.text=從磁碟重新載入
action.TypeHierarchy.Class.text=類層次結構
action.TypeHierarchy.Subtypes.text=子類型層次結構
action.TypeHierarchy.Supertypes.text=父類型層次結構
action.MethodHierarchy.ImplementMethodAction.text=實作方法
action.MethodHierarchy.ImplementMethodAction.description=實作方法(從方法層次結構)
action.MethodHierarchy.OverrideMethodAction.text=覆寫方法
action.MethodHierarchy.OverrideMethodAction.description=覆寫方法(從方法層次結構)
action.Vcs.MoveChangedLinesToChangelist.text=將行移到另一個變更列表…
action.Vcs.MoveChangedLinesToChangelist.description=將所選行中的變更移動到另一個變更列表…
action.Vcs.Diff.ExcludeChangedLinesFromCommit.text=將行包含在提交中
action.Vcs.Diff.IncludeOnlyChangedLinesIntoCommit.text=僅將這些行包含在提交中
action.Vcs.Diff.ShowDiffInEditorTab.text=在編輯器頁籤中顯示差異
action.Vcs.Diff.ShowDiffInNewWindow.text=在單獨的視窗中顯示差異
action.Vcs.RollbackChangedLines.text=回滾行
action.Vcs.RollbackChangedLines.description=回滾所選行中的變更
action.openAssertEqualsDiff.text=查看 assertEquals 差異
action.UsageView.Rerun.text=重新執行
action.UsageView.Rerun.description=重新執行搜尋
action.UsageView.Include.text=包含
action.UsageView.Include.description=將此用法包含到處理中
action.UsageView.Exclude.text=排除
action.UsageView.Exclude.description=將此用法從處理中排除
action.UsageView.Remove.text=移除
action.UsageView.Remove.description=將此用法從處理中移除
action.UsageView.ShowRecentFindUsages.text=最近的尋找用法(_E)
action.UsageView.ShowRecentFindUsages.description=選擇並重新執行最近的尋找用法
group.ShowRecentFindUsagesGroup.text=最近的尋找用法
group.ShowRecentFindUsagesGroup.description=選擇並重新執行最近的尋找用法

action.IntegrateFiles.text=集成
action.IntegrateFiles.description=集成所選檔案或目錄
action.Vcs.IntegrateProject.text=集成專案(_G)
action.Vcs.IntegrateProject.description=集成專案

action.ShowNavBar.text=跳轉到導航欄(_J)
action.ShowNavBar.ShortText=導航欄

group.ProjectView.ToolWindow.SecondaryActions.text=專案檢視選項
action.ProjectView.AbbreviatePackageNames.text=縮寫限定軟體套件名稱
action.ProjectView.AbbreviatePackageNames.description=以簡短形式顯示限定軟體套件名稱
action.ProjectView.AutoscrollFromSource.text=始終選擇打開的檔案
action.ProjectView.AutoscrollFromSource.description=選擇編輯器頁籤時，在專案檢視中選擇相應的檔案
action.ProjectView.AutoscrollToSource.text=一鍵打開檔案
action.ProjectView.AutoscrollToSource.description=選擇檔案後，將其打開進行編輯
action.ProjectView.OpenInPreviewTab.text=啟用預覽頁籤
action.ProjectView.CompactDirectories.text=壓縮目錄
action.ProjectView.CompactDirectories.description=如果第一個目錄僅包含第二個目錄，則將兩個類似的目錄合併到單個節點中
action.ProjectView.FlattenModules.text=平展模組
action.ProjectView.FlattenModules.description=以簡單列表顯示模組
action.ProjectView.FlattenPackages.text=平展軟體套件
action.ProjectView.FlattenPackages.description=以簡單列表顯示包
action.ProjectView.FoldersAlwaysOnTop.text=資料夾總在最前
action.ProjectView.FoldersAlwaysOnTop.description=單獨對檔案和資料夾排序
action.ProjectView.HideEmptyMiddlePackages.text=隱藏空的中間軟體套件
action.ProjectView.HideEmptyMiddlePackages.description=隱藏空的中間軟體套件
action.ProjectView.ManualOrder.text=手動排序
action.ProjectView.ManualOrder.description=手動對檔案排序
action.ProjectView.ShowExcludedFiles.text=顯示排除的檔案
action.ProjectView.ShowExcludedFiles.description=顯示排除的檔案
action.ProjectView.ShowLibraryContents.text=顯示庫內容
action.ProjectView.ShowLibraryContents.description=顯示庫內容
action.ProjectView.ShowMembers.text=顯示成員
action.ProjectView.ShowMembers.description=顯示類成員
action.ProjectView.ShowModules.text=顯示模組
action.ProjectView.ShowModules.description=顯示相應根的模組名稱
action.ProjectView.ShowVisibilityIcons.text=顯示可見性圖標
action.ProjectView.ShowVisibilityIcons.description=在元素名稱之前顯示其可見性的圖標
action.ProjectView.SortByType.text=按類型排序
action.ProjectView.SortByType.description=單獨對不同類型的檔案排序
action.ScopeView.EditScopes.text=編輯範圍(_I)…
action.ScopeView.EditScopes.description=編輯範圍…
action.ProjectView.FileNesting.text=檔案嵌套…
action.ProjectView.FileNesting.description=配置檔案嵌套

action.CodeInspection.OnEditor.text=使用編輯器設定檢查程式碼(_E)
action.CodeInspection.OnEditor.description=使用編輯器設定檢查程式碼(_E)

action.SendFeedback.text=提交反饋...(_F)
action.SendFeedback.detailed.description=提交反饋給 {0}
action.OpenLog.text=在編輯器中打開日誌
action.ShowLog.text=在檔案管理器中顯示日誌(_L)
action.ShowLog.Explorer.text=在資源管理器中顯示日誌(_L)
action.ShowLog.Finder.text=在訪達中顯示日誌(_L)
action.ShowLog.description=打開帶日誌檔案的資料夾
action.CollectZippedLogs.text=收集日誌和診斷資料
action.CollectZippedLogs.description=將日誌和設定壓縮到檔案中
action.DeleteOldAppDirs.text=刪除殘留的 IDE 目錄…
action.DeleteOldAppDirs.description=尋找以前 IDE 版本中的設定、快取和日誌目錄
action.EditCustomProperties.text=編輯自定義屬性…
action.EditCustomProperties.description=打開帶有自訂屬性檔案的編輯器頁籤
action.EditCustomVmOptions.text=編輯自定義 VM 選項…
action.EditCustomVmOptions.description=打開帶有自訂 VM 選項檔案的編輯器頁籤
action.LogDebugConfigure.text=調試日誌設定(_E)…
action.LogDebugConfigure.description=啟用或禁用額外的日誌類別。允許通過請求向支援團隊提供更多資訊。
action.TechnicalSupport.text=聯繫支援(_S)…
action.TechnicalSupport.description=聯繫 JetBrains 網站上的技術支援
action.ReportProblem.text=提交錯誤報告...
action.ReportProblem.description=在 JetBrains 問題跟踪器中提交錯誤報告

action.TextComponent.ClearAction.text=清除文本
action.TextComponent.ClearAction.description=清除文本組件中的文本

action.ChangesView.Refresh.text=刷新
action.ChangesView.Refresh.MainMenu.text=刷新 VCS 變更
action.ChangesView.Refresh.description=刷新 VCS 變更
action.ChangesView.NewChangeList.text=新建變更列表…
action.ChangesView.NewChangeList.description=創建新的變更列表
action.ChangesView.Revert.text=回滾(_R)...
action.ChangesView.RevertFiles.text=回滾檔案(_R)...
action.ChangesView.RemoveChangeList.text=刪除變更列表
action.ChangesView.RemoveChangeList.description=移除變更列表並將所有變更移至其他變更列表
action.ChangesView.RemoveChangeList.text.template=刪除{0,choice,0#變更列表|2#變更列表}
action.ChangesView.RemoveChangeList.description.template=移除{0,choice,0#變更列表|2#變更列表}和移動所有的改變到{1}
action.ChangesView.SetDefault.text=設定活動變更列表
action.ChangesView.SetDefault.description=設定預設情況下放置新變更的變更列表
action.ChangesView.Move.text=移至另一個變更列表…
action.ChangesView.Move.Files.text=將檔案移動到另一個變更列表…
action.ChangesView.Move.description=將所選變更移至另一個變更列表
action.ChangesView.Diff.text=顯示差異
action.ChangesView.Diff.description=比較檔案或修訂
action.ChangesView.AddUnversioned.text=添加到 VCS
action.ChangesView.AddUnversioned.description=排定將所選檔案添加到 VCS 的時間表
action.ChangesView.RemoveDeleted.text=從 VCS 移除
action.ChangesView.RemoveDeleted.description=排定將所選檔案從 VCS 移除的時間表
action.ChangesView.Rename.text=編輯變更列表…
action.ChangesView.Rename.description=編輯所選變更列表的名稱和描述
action.ChangesView.CreatePatch.text=從本地更改創建補丁...
action.ChangesView.CreatePatch.description=從所選變更創建補丁
action.ChangesView.ApplyPatch.text=套用補丁…
action.ChangesView.ApplyPatch.description=將補丁套用到專案的源
action.ChangesView.ApplyPatchFromClipboard.text=從剪貼簿套用補丁…
action.ChangesView.ApplyPatchFromClipboard.description=將補丁套用到專案的源
action.ChangesView.Shelve.text=擱置變更…
action.ChangesView.Shelve.description=將變更儲存到外部補丁檔案，並將其從程式碼中移除
action.ShelvedChanges.Rename.text=重命名…
action.ShelvedChanges.Rename.description=重命名擱置的變更列表
action.ChangesView.Browse.text=瀏覽變更…
action.ChangesView.Browse.description=查看已提交變更的歷史記錄
action.ChangesView.Edit.text=簽出
action.ChangesView.Edit.description=簽出所選檔案進行編輯
action.ChangesView.CreatePatchFromChanges.text=創建補丁…
action.ChangesView.CreatePatchFromChanges.description=從所選變更創建補丁
action.ChangesView.CreatePatchToClipboard.text=作為補丁複製到剪貼簿
action.ChangesView.CreatePatchToClipboard.description=從變更創建補丁並將其複製到剪貼簿
action.CommittedChanges.Refresh.text=刷新
action.CommittedChanges.Refresh.description=刷新已提交變更的列表
action.CommittedChanges.Filter.text=篩選
action.CommittedChanges.Filter.description=更改篩選條件
action.CommittedChanges.Details.text=顯示詳細資訊
action.CommittedChanges.Details.description=查看所選變更列表的完整資訊
action.CommittedChanges.Clear.text=清除
action.CommittedChanges.Clear.description=清除快取的修訂版本
action.IncomingChanges.Refresh.text=刷新
action.IncomingChanges.Refresh.description=刷新傳入變更的列表
action.FileChooser.TogglePathShowing.text=顯示/隱藏路徑文本
action.ChangeFileEncodingAction.text=檔案編碼
action.ChangeFileEncodingAction.description=更改檔案編碼
action.VcsHistory.ShowAllAffected.text=顯示所有受影響的檔案
action.VcsHistory.ShowAllAffected.description=顯示選中修訂中所做的所有變更
action.Vcs.Show.Shelf.text=顯示 Shelf
action.Vcs.Show.Local.Changes.text=顯示本地變更
group.FileHistory.KeymapGroup.text=檔案歷史記錄
group.Shelve.KeymapGroup.text=擱置
action.Vcs.CopyRevisionNumberAction.text=複製修訂號
action.Vcs.CopyRevisionNumberAction.description=將選定提交的修訂號複製到剪貼簿
action.VcsToolbarLabelAction.text=VCS 標籤
group.CommitView.ShowOnDoubleClick.text=雙擊時顯示
action.CommitView.ShowOnDoubleClick.EditorPreview.text=雙擊時顯示差異
action.CommitView.ShowOnDoubleClick.EditorPreview.ToolwindowPopup.text=差異
action.CommitView.ShowOnDoubleClick.Source.text=雙擊時顯示源
action.CommitView.ShowOnDoubleClick.Source.ToolwindowPopup.text=源
action.CommitView.SwitchToCommitDialog.text=切換到“提交”對話框
action.Vcs.ToggleAmendCommitMode.text=修正提交
action.Vcs.ToggleAmendCommitMode.description=修改當前分支的最新提交
action.ChangesView.ShowCommitOptions.text=顯示提交選項
action.Vcs.ApplySelectedChanges.text=優選所選變更
action.Vcs.RevertSelectedChanges.text=還原所選變更
action.Vcs.EditSource.text=編輯源
action.ChangesView.UnshelveSilently.text=靜默取消擱置
action.ChangesView.UnshelveSilently.description=取消擱置對相應變更列表的變更
action.ShelvedChanges.CleanMarkedToDelete.text=清理已取消擱置變更…
action.ShelvedChanges.CleanMarkedToDelete.description=刪除已取消擱置的變更列表
action.ShelvedChanges.ShowRecentlyDeleted.text=顯示最近刪除項
action.ShelvedChanges.ShowRecentlyDeleted.description=顯示最近刪除的擱置
action.ShelvedChanges.ShowHideDeleted.description=顯示/隱藏已取消擱置變更
action.ShelveChanges.UnshelveWithDialog.text=取消擱置…
action.ShelveChanges.UnshelveWithDialog.description=更正套用補丁的路徑並取消擱置
action.ChangesView.ShelveSilently.text=靜默擱置
action.ChangesView.ShelveSilently.description=擱置對適當的已擱置變更列表的變更
action.ChangesView.SaveToShelve.text=儲存到擱置
action.ChangesView.SaveToShelve.description=將所選變更複製到擱置的變更列表
action.ChangesView.GroupBy.Directory.text=目錄
group.ChangesView.GroupBy.text=分組依據
action.Vcs.QuickListPopupAction.text=VCS 操作彈出視窗…
action.Vcs.QuickListPopupAction.description=包含常用 VCS 操作列表的上下文感知彈出視窗
action.Vcs.VcsClone.text=從版本控制中獲取…
action.Vcs.VcsClone.text.synonym1=簽出
action.Vcs.VcsClone.text.synonym2=克隆
Vcs.VcsClone.Welcome.text=從版本控制中獲取
Vcs.VcsClone.Tabbed.Welcome.text=從 VCS 獲取
Vcs.VcsClone.Project.text=來自版本控制的專案…
action.Vcs.ShowDiffWithLocal.text=與本地比較
action.Vcs.ShowDiffWithLocal.description=將所選修訂中的版本與當前版本進行比較
action.Vcs.ShowDiffWithLocal.Before.text=將之前版本與本地版本進行比較
action.Vcs.ShowDiffWithLocal.Before.description=將之前的所選修訂中的版本與當前版本進行比較
action.Compare.Specified.text=與指定修訂比較(_P)…
action.Show.Current.Revision.text=顯示當前修訂
group.ChangesView.Changelists.text=變更列表
separator.Local.History.text=本地歷史記錄

action.AddFrameworkSupport.text=添加框架支援…

action.Diff.FocusOppositePane.text=選擇相對差異窗格
action.Diff.FocusOppositePane.description=在差異檢視中選擇相對窗格
action.Diff.FocusOppositePaneAndScroll.text=在相對差異窗格中選擇位置
action.Diff.FocusOppositePaneAndScroll.description=在差異檢視的相對窗格中選擇相同的位置
action.Diff.PrevChange.text=比較上一個檔案
action.Diff.NextChange.text=比較下一個檔案
action.Diff.ApplyLeftSide.text=接受左側
action.Diff.ApplyRightSide.text=接受右側
action.Diff.AppendLeftSide.text=追加左側
action.Diff.AppendRightSide.text=追加右側
action.Diff.IgnoreLeftSide.text=忽略左側
action.Diff.IgnoreRightSide.text=忽略右側
action.Diff.ResolveConflict.text=自動解決
action.Diff.ApplyNonConflicts.text=套用所有不衝突的變更
action.Diff.ApplyNonConflicts.Left.text=從左側套用不衝突的變更
action.Diff.ApplyNonConflicts.Right.text=從右側套用不衝突的變更
action.Diff.MagicResolveConflicts.text=解決簡單的衝突
action.Diff.ComparePartial.Base.Left.text=左和中
action.Diff.ComparePartial.Base.Right.text=中和右
action.Diff.ComparePartial.Left.Right.text=左和右
action.Diff.CompareWithBase.Left.text=基礎和左
action.Diff.CompareWithBase.Result.text=基礎和中
action.Diff.CompareWithBase.Right.text=基礎和右
action.Diff.ComparePartial.Generic={0,choice,0#左|1#中|2#右} 和 {1,choice,0#左|1#中|2#右}

action.FileChooser.Refresh.text=刷新
action.FileChooser.Refresh.description=刷新檔案系統樹
action.FileChooser.Delete.text=刪除…
action.FileChooser.Delete.description=刪除
action.FileChooser.NewFolder.text=新建資料夾…
action.FileChooser.NewFolder.description=創建新目錄
action.FileChooser.NewFile.text=新建檔案…
action.FileChooser.NewFile.description=創建新檔案
action.FileChooser.GotoHome.text=主目錄
action.FileChooser.GotoHome.description=轉到主目錄
action.FileChooser.GotoDesktop.text=桌面目錄
action.FileChooser.GotoDesktop.description=轉到桌面目錄
action.FileChooser.GotoProject.text=專案目錄
action.FileChooser.GotoProject.description=轉到專案目錄
action.FileChooser.GotoModule.text=模組目錄
action.FileChooser.GotoModule.description=轉到模組目錄

action.WelcomeScreen.DevelopPlugins.text=套件開發
action.WelcomeScreen.DevelopPlugins.description=開始開發套件。
action.WelcomeScreen.OpenProject.text=打開或匯入
action.WelcomeScreen.OpenProject.description=打開檔案或專案。您也可以通過拖放到歡迎頁面來打開專案或編輯檔案。
action.Tabbed.WelcomeScreen.OpenProject.text=打開
action.WelcomeScreen.CreateNewProject.text=新建專案
action.WelcomeScreen.CreateNewProject.description=啟動“新項目”嚮導，它將引導您創建一個新項目。
action.WelcomeScreen.Plugins.text=套件
action.WelcomeScreen.Plugins.Extensions.text=擴展
action.WelcomeScreen.Plugins.description=管理已安裝的套件，以及從儲存庫下載新套件
action.WelcomeScreen.Configure.Import.text=匯入設定…
action.WelcomeScreen.Configure.Export.text=匯出設定
action.WelcomeScreen.Configure.RestoreDefault.text=恢復預設設定…
group.WelcomeScreen.Options.text=選項選單

action.CommittedChanges.Revert.text=還原變更
action.CommittedChanges.Revert.description=將所選變更的反向操作應用於工作副本

action.WelcomeScreen.OpenDirectoryProject.text=打開
action.WelcomeScreen.OpenDirectoryProject.description=開始在指定的檔案或目錄中編輯程式碼。
action.WelcomeScreen.CreateDirectoryProject.text=新建專案
action.WelcomeScreen.CreateDirectoryProject.description=創建一個新項目。
action.NewDirectoryProject.text=新建專案…
action.NewDirectoryProject.description=創建一個新項目
action.NewDirectoryProject.title=創建專案
action.NewDirectoryProject.cannot.create.dir=無法創建目錄 ''{0}''。
action.NewDirectoryProject.not.empty.dialog.title=目錄不為空
action.NewDirectoryProject.not.empty.dialog.text=目錄 ''{0}'' 不為空。想從現有的源創建專案嗎?
action.NewDirectoryProject.not.empty.dialog.create.new=從現有的源創建
action.NewDirectoryProject.not.empty.dialog.open.existing=打開專案

action.SliceBackward.text=分析流入此處的資料(_T)…
action.SliceBackward.MainMenu.text=流入此處的資料(_T)…
action.SliceBackward.description=搜尋可以分配給所選表達式的值

action.SliceForward.text=分析流出此處的資料(_F)…
action.SliceForward.MainMenu.text=流出此處的資料(_F)…
action.SliceForward.description=搜尋從此位置轉義的值

action.ChangeTemplateDataLanguage.text=更改模板資料語言

group.FileOpenGroup.text=檔案打開操作
group.FileOtherSettingsGroup.text=新項目設定
group.FileMainSettingsGroup.text=設定操作
group.FileSettingsGroup.text=設定操作
group.ExportImportGroup.text=管理 IDE 設定
group.PrintExportGroup.text=列印/匯出操作
group.EditSelectGroup.text=編輯器選擇操作
group.EditCreateDeleteGroup.text=編輯器創建/刪除操作
group.CutCopyPasteGroup.text=剪下/複製/貼上操作
group.EditSelectWordGroup.text=選擇單詞操作
group.EditBookmarksGroup.text=書籤(_K)
group.OpenProjectGroup.text=打開專案操作
group.EditSmartGroup.text=編輯程式碼操作
group.CodeEditorViewGroup.text=程式碼檢視操作
group.CodeEditorBaseGroup.text=程式碼編輯器檢視操作
group.HierarchyGroup.text=層次結構操作
group.DebugMainMenu.text=調試器操作
group.DebuggingActionsGroup.text=調試操作
group.BreakpointActionsGroup.text=切換斷點
group.ToggleBreakpointAction.text=斷點操作
group.CommentGroup.text=註釋操作
group.CodeFormatGroup.text=程式碼格式化操作
group.GoToTargetEx.text=通過名稱轉到操作
group.GoToErrorGroup.text=轉到錯誤/書籤操作
group.GoToCodeGroup.text=通過引用轉到操作
group.GoToChangeMarkerGroup.text=更改導航操作
group.CoverageMenu.text=程式碼覆蓋率操作
group.ToolsXmlGroup.text=XML 操作
group.XmlGenerateToolsGroup.text=XML 生成操作
group.EditorPopupMenuDebug.text=調試操作
group.VersionControlsGroup.text=VCS/LVCS 操作
group.EditorPopupMenu.Run.text=編譯/執行操作
group.ProjectViewCompileGroup.text=編譯/調試操作
group.ProjectViewAnalysisGroup.text=分析操作
group.PairFileActions.text=檔案對的操作
group.RefactoringMenu1.text=重構操作(1)
group.RefactoringMenu2.text=重構操作(2)
group.ToolbarFindGroup.text=工具欄尋找操作
group.ToolbarRunGroup.text=工具欄執行操作
group.ToolbarMakeGroup.text=工具欄設定操作
group.EditorPopupMenu1.text=編輯器彈出視窗選單操作(1)
group.EditorLangPopupMenu.text=編輯器彈出視窗選單操作(2)
group.CloseEditorsGroup.text=編輯器關閉操作
group.EditorTabPopupMenuEx.text=編輯器頁籤彈出視窗選單操作(1)
group.ProjectViewPopupMenuModifyGroup.text=專案檢視彈出視窗選單修改組
group.ProjectViewPopupMenuRunGroup.text=專案檢視彈出視窗選單執行組
group.ProjectViewPopupMenuSettingsGroup.text=專案檢視彈出視窗選單設定組
group.ProjectViewPopupMenuRefactoringGroup.text = 專案檢視彈出視窗重構組
group.ViewRecentActions.text=查看最近的操作組
group.NewGroup1.text=新組(1)
action.NewModuleInGroup.text=模組
action.ShelvedChanges.ShowHideDeleted.text=顯示/隱藏已套用的擱置變更
action.XDebugger.MuteBreakpoints.text=靜音斷點
action.ShelvedChanges.Restore.text=恢復已套用的擱置變更
group.VcsToolbarActions.text=VCS 操作
action.ChangesView.GroupBy.Repository.text=儲存庫
action.CheckIgnoredAndNotExcludedDirectories.text=檢查已忽略但未排除的目錄
action.CheckIgnoredAndNotExcludedDirectories.description=檢查是否存在可以排除在索引和搜尋之外的已忽略目錄
action.CheckIgnoredAndNotExcludedDirectories.progress=正在檢查已忽略但未排除的目錄…
action.Vcs.Push.Force.text=強制推送(_F)
action.Vcs.Push.text=推送…
action.PopupHector.text=配置當前檔案分析…
action.PopupHector.description=顯示面板來為當前檔案配置高亮顯示模式
group.EditorTabPopupMenu.text=編輯器頁籤彈出視窗選單
group.MainMenu.text=主選單
group.ProjectViewPopupMenu.text=專案檢視彈出視窗選單
group.FavoritesViewPopupMenu.text=收藏夾檢視彈出視窗選單
group.NavbarPopupMenu.text=導航欄
action.RerunFailedTests.text=重新執行失敗的測試
action.RerunFailedTests.description=僅執行上次執行後失敗/崩潰的測試；按 Shift 鍵選擇“執行/調試”模式
group.AnalyzeJavaMenu.text=分析 Java 選單
group.AnalyzeJavaMenu.description=分析 Java 選單
group.ToolsBasicGroup.text=基本工具組
group.ToolsBasicGroup.description=基本工具組
action.ShowRegistry.text=註冊表…
action.ShowExperiments.text=實驗性功能…
action.UiDebugger.text=UI 調試器…
action.ExportTestResults.text=匯出測試結果…
action.ExportTestResults.description=將測試結果匯出到檔案
action.TogglePowerSave.text=省電模式
action.TogglePowerSave.description=省電模式將禁用背景程式碼分析和其他背景操作
group.ConvertIndentsGroup.text=轉換縮排
action.ConvertIndentsToSpaces.text=轉換為空格
action.ConvertIndentsToSpaces.description=轉換檔案或所選塊中的縮排，以使用空格代替制表符
action.ConvertIndentsToTabs.text=轉換為制表符
action.ConvertIndentsToTabs.description=轉換檔案或所選塊中的縮排，以使用制表符代替空格
group.Vcs.Import.text=匯入到版本控制
group.Vcs.Browse.text=瀏覽 VCS 儲存庫
action.Graph.print.reset=重置
action.MarkExcludeRoot.text=已排除
action.UnmarkRoot.text=取消標記
action.MarkAsContentRoot.text=不排除
action.MarkAsContentRoot.description=取消所選目錄的排除，使其檔案可以被 IDE 的操作處理
action.CreateLibraryFromFile.text=添加為庫…
action.ExtractModuleFromPackage.text=提取模組…
action.ExtractModuleFromPackage.description=將軟體套件提取到單獨的模組
action.ImportModuleFromImlFile.text=匯入模組
action.ImportModuleFromImlFile.description=將 iml 檔案作為一個模組匯入到專案
group.MarkRootGroup.text=將目錄標記為
action.CreateLauncherScript.text=創建命令行啟動器…
action.CreateLauncherScript.description=創建一個腳本，用於從命令行打開檔案和專案
action.CreateDesktopEntry.text=創建桌面條目…
action.CreateDesktopEntry.description=創建桌面條目以與系統套用程序選單集成
group.EditorGutterPopupMenu.text=編輯器間距彈出選單
action.ConfigureSoftWraps.text=配置自動換行
action.EditorGutterToggleLocalSoftWraps.gutterText=自動換行當前編輯器
action.EditorGutterToggleGlobalLineNumbers.text=顯示行號
action.EditorGutterToggleGlobalIndentLines.text=顯示縮排參考線
action.ShowGutterIconsSettings.text=配置間距圖標...
action.ShowGutterIconsSettings.description=顯示對話框以配置間距圖標

group.EditorBreadcrumbsSettings.text=路徑導航
group.EditorBreadcrumbsSettings.description=切換路徑導航欄設定
action.EditorBreadcrumbsShowAbove.text=頂部
action.EditorBreadcrumbsShowAbove.description=在文本編輯器上方顯示路徑導航欄
action.EditorBreadcrumbsShowBelow.text=底部
action.EditorBreadcrumbsShowBelow.description=在文本編輯器下方顯示路徑導航欄
action.EditorBreadcrumbsHideBoth.text=不顯示
action.EditorBreadcrumbsHideBoth.description=隱藏路徑導航欄

group.MarkFileAs.text=將檔案標記為
action.OverrideFileTypeAction.text=覆寫檔案類型
action.OverrideFileTypeAction.description=將當前檔案視為不同檔案類型的檔案
group.OverrideFileTypeAction.title=選擇檔案類型
group.OverrideFileTypeAction.bundledPlugin=捆綁
group.OverrideFileTypeAction.fromNamedPlugin=自 ''{0}'' 套件
action.ChangeToThisFileTypeAction.description=將檔案類型覆蓋為 ''{0}''

action.Console.Open.text=打開控制台
action.Console.Open.description=為所選實體打開控制台
action.Console.Execute.text=在單行控制台中執行當前語句
action.Console.Execute.description=在單行控制台中執行當前語句
action.Console.Execute.Multiline.text=在多行控制台中執行當前語句
action.Console.Execute.Multiline.description=在多行控制台中執行當前語句
action.Console.SplitLine.text=拆分行
action.Console.History.Previous.text=控制台歷史記錄中的上一個條目
action.Console.History.Previous.description=控制台歷史記錄中的上一個條目
action.Console.History.Next.text=控制台歷史記錄中的下一個條目
action.Console.History.Next.description=控制台歷史記錄中的下一個條目
action.Console.History.Browse.text=瀏覽查詢歷史記錄
action.Console.History.Browse.description=瀏覽查詢歷史記錄
action.RevealIn.description=在平台的檔案管理器中高亮顯示檔案
action.RevealIn.name.mac=在訪達中顯示
action.RevealIn.name.other=在 {0} 中顯示
show.log.in.action.text=在 {0} 中顯示日誌
show.log.notification.text=查看日誌
action.GoToLinkTarget.text=轉到鏈接目標
action.GoToLinkTarget.description=在專案檢視中打開此符號鏈接的目標

action.TabList.text=顯示隱藏的頁籤
action.TabList.description=使用包含在單行頁籤布局中不適合螢幕的頁籤列表的下拉列表

action.FillParagraph.text=填充段落
action.FillParagraph.description=重新格式化字串文字或註釋以適應最大寬度(通常為80)

action.SaveDocument.text=儲存文檔
action.SaveDocument.description=只儲存在當前編輯器中打開的檔案

action.StructuralSearchPlugin.StructuralSearchAction.text=結構搜尋(_T)…
action.StructuralSearchPlugin.StructuralSearchAction.description=結構搜尋
action.StructuralSearchPlugin.StructuralReplaceAction.text=結構取代(_C)…
action.StructuralSearchPlugin.StructuralReplaceAction.description=結構取代

action.ModuleSettings.navigate=打開模組設定
action.LibrarySettings.navigate=打開庫設定
action.ToggleDistractionFreeMode.enter=進入免打擾模式
action.ToggleDistractionFreeMode.exit=退出免打擾模式
action.TogglePresentationMode.exit=退出演示模式
action.TogglePresentationMode.enter=進入演示模式
action.ToggleZenMode.enter=進入 Zen 模式
action.ToggleZenMode.exit=退出 Zen 模式

action.EmojiAndSymbols.description=使用 macOS 系統調色板輸入特殊字符

action.MethodOverloadSwitchUp.text=上一個方法多載
action.MethodOverloadSwitchDown.text=下一個方法多載

action.BraceOrQuoteOut.text=跳到當前括號/引號

action.SetShortcutAction.text=添加快捷鍵…

action.EditorFocusGutter.text=焦點間距(無障礙功能)
action.EditorShowGutterIconTooltip.text=顯示間距圖標工具提示(無障礙功能)

action.ConfigureEditorTabs.text=配置編輯器頁籤...
action.ConfigureEditorTabs.description=配置編輯器頁籤的外觀，行為和順序

group.FilePropertiesGroup.text=檔案屬性
group.FileExportGroup.text=匯出
group.PasteGroup.text=貼上
group.FindUsagesMenuGroup.text=尋找用法
group.NavigateInFileGroup.text=在檔案中導航
group.HelpDiagnosticTools.text=診斷工具
group.ChangeLineSeparators.text=行分隔符

group.CopyReferencePopupGroup.text=複製路徑/引用…

action.CompareDirs.text=比較目錄
action.compare.files.text=比較檔案
action.compare.with.text=比較物件…
action.compare.text=比較
action.compare.archives.text=比較歸檔

action.List-selectFirstRow.text=選擇第一行
action.List-selectFirstRow.description=選擇第一行。
action.List-selectFirstRowExtendSelection.text=將選擇範圍擴展到第一行
action.List-selectFirstRowExtendSelection.description=滾動到第一行並將相應的行添加到選擇範圍。
action.List-selectLastRow.text=選擇最後一行
action.List-selectLastRow.description=選擇最後一行。
action.List-selectLastRowExtendSelection.text=將選擇範圍擴展到最後一行
action.List-selectLastRowExtendSelection.description=滾動到最後一行並將相應的行添加到選擇範圍。
action.List-selectPreviousRow.text=選擇上一行
action.List-selectPreviousRow.description=選擇上一行。
action.List-selectPreviousRowExtendSelection.text=將選擇範圍擴展到上一行
action.List-selectPreviousRowExtendSelection.description=將上一行添加到選擇範圍。
action.List-selectNextRow.text=選擇下一行
action.List-selectNextRow.description=選擇下一行。
action.List-selectNextRowExtendSelection.text=將選擇範圍擴展到下一行
action.List-selectNextRowExtendSelection.description=將下一行添加到選擇範圍。
action.List-selectPreviousColumn.text=選擇上一列
action.List-selectPreviousColumn.description=選擇上一列。
action.List-selectPreviousColumnExtendSelection.text=將選擇範圍擴展到上一列
action.List-selectPreviousColumnExtendSelection.description=將上一列添加到選擇範圍。
action.List-selectNextColumn.text=選擇下一列
action.List-selectNextColumn.description=選擇下一列。
action.List-selectNextColumnExtendSelection.text=將選擇範圍擴展到下一列
action.List-selectNextColumnExtendSelection.description=將下一列添加到選擇範圍。
action.List-scrollUp.text=向上滾動頁面並選擇行
action.List-scrollUp.description=將周圍的可滾動區域向上滾動一頁，然後選擇相應的行。
action.List-scrollUpExtendSelection.text=向上滾動頁面並擴展選擇範圍
action.List-scrollUpExtendSelection.description=將周圍的可滾動區域向上滾動一頁，然後將相應的行添加到選擇範圍。
action.List-scrollDown.text=向下滾動頁面並選擇行
action.List-scrollDown.description=將周圍的可滾動區域向下滾動一頁，然後選擇相應的行。
action.List-scrollDownExtendSelection.text=向下滾動頁面並擴展選擇範圍
action.List-scrollDownExtendSelection.description=將周圍的可滾動區域向下滾動一頁，然後將相應的行添加到選擇範圍。
action.Table-selectFirstRow.text=選擇第一行
action.Table-selectFirstRow.description=選擇第一行。
action.Table-selectFirstRowExtendSelection.text=將選擇範圍擴展到第一行
action.Table-selectFirstRowExtendSelection.description=滾動到第一行並將相應的行添加到選擇範圍。
action.Table-selectLastRow.text=選擇最後一行
action.Table-selectLastRow.description=選擇最後一行。
action.Table-selectLastRowExtendSelection.text=將選擇範圍擴展到最後一行
action.Table-selectLastRowExtendSelection.description=滾動到最後一行並將相應的行添加到選擇範圍。
action.Table-selectPreviousRow.text=選擇上一行
action.Table-selectPreviousRow.description=選擇上一行。
action.Table-selectPreviousRowExtendSelection.text=將選擇範圍擴展到上一行
action.Table-selectPreviousRowExtendSelection.description=將上一行添加到選擇範圍。
action.Table-selectNextRow.text=選擇下一行
action.Table-selectNextRow.description=選擇下一行。
action.Table-selectNextRowExtendSelection.text=將選擇範圍擴展到下一行
action.Table-selectNextRowExtendSelection.description=將下一行添加到選擇範圍。
action.Table-selectPreviousColumn.text=選擇上一列
action.Table-selectPreviousColumn.description=選擇上一列。
action.Table-selectPreviousColumnExtendSelection.text=將選擇範圍擴展到上一列
action.Table-selectPreviousColumnExtendSelection.description=將上一列添加到選擇範圍。
action.Table-selectNextColumn.text=選擇下一列
action.Table-selectNextColumn.description=選擇下一列。
action.Table-selectNextColumnExtendSelection.text=將選擇範圍擴展到下一列
action.Table-selectNextColumnExtendSelection.description=將下一列添加到選擇範圍。
action.Table-scrollUpChangeSelection.text=向上滾動頁面並選擇行
action.Table-scrollUpChangeSelection.description=將周圍的可滾動區域向上滾動一頁，然後選擇相應的行。
action.Table-scrollUpExtendSelection.text=向上滾動頁面並擴展選擇範圍
action.Table-scrollUpExtendSelection.description=將周圍的可滾動區域向上滾動一頁，然後將相應的行添加到選擇範圍。
action.Table-scrollDownChangeSelection.text=向下滾動頁面並選擇行
action.Table-scrollDownChangeSelection.description=將周圍的可滾動區域向下滾動一頁，然後選擇相應的行。
action.Table-scrollDownExtendSelection.text=向下滾動頁面並擴展選擇範圍
action.Table-scrollDownExtendSelection.description=將周圍的可滾動區域向下滾動一頁，然後將相應的行添加到選擇範圍。
action.Tree-selectFirst.text=選擇第一個節點
action.Tree-selectFirst.description=選擇第一個節點。
action.Tree-selectFirstExtendSelection.text=將選擇範圍擴展到第一個節點
action.Tree-selectFirstExtendSelection.description=滾動到第一個節點並將相應的節點添加到選擇範圍。
action.Tree-selectLast.text=選擇最後一個節點
action.Tree-selectLast.description=選擇最後一個節點。
action.Tree-selectLastExtendSelection.text=將選擇範圍擴展到最後一個節點
action.Tree-selectLastExtendSelection.description=滾動到最後一個節點並將相應的節點添加到選擇範圍。
action.Tree-selectPrevious.text=選擇上一個節點
action.Tree-selectPrevious.description=選擇上一個節點。
action.Tree-selectPreviousExtendSelection.text=將選擇範圍擴展到上一個節點
action.Tree-selectPreviousExtendSelection.description=將上一個節點添加到選擇範圍。
action.Tree-selectNext.text=選擇下一個節點
action.Tree-selectNext.description=選擇下一個節點。
action.Tree-selectNextExtendSelection.text=將選擇範圍擴展到下一個節點
action.Tree-selectNextExtendSelection.description=將下一個節點添加到選擇範圍。
action.Tree-selectParentNoCollapse.text=選擇父節點
action.Tree-selectParentNoCollapse.description=選擇父節點(不摺疊展開的節點)。
action.Tree-selectParent.text=選擇父節點
action.Tree-selectParent.description=摺疊展開的節點或選擇父節點。
action.Tree-selectParentExtendSelection.text=將選擇範圍擴展到父節點
action.Tree-selectParentExtendSelection.description=滾動到父節點並將相應的節點添加到選擇範圍。
action.Tree-selectChild.text=選擇子節點
action.Tree-selectChild.description=展開摺疊的節點或選擇子節點。
action.Tree-selectChildExtendSelection.text=將選擇範圍擴展到子節點
action.Tree-selectChildExtendSelection.description=展開摺疊的節點或將子節點添加到選擇範圍。
action.Tree-scrollUpChangeSelection.text=向上滾動頁面並選擇節點
action.Tree-scrollUpChangeSelection.description=將周圍的可滾動區域向上滾動一頁，然後選擇相應的節點。
action.Tree-scrollUpExtendSelection.text=向上滾動頁面並擴展選擇範圍
action.Tree-scrollUpExtendSelection.description=將周圍的可滾動區域向上滾動一頁，然後將相應的節點添加到選擇範圍。
action.Tree-scrollDownChangeSelection.text=向下滾動頁面並選擇節點
action.Tree-scrollDownChangeSelection.description=將周圍的可滾動區域向下滾動一頁，然後選擇相應的節點。
action.Tree-scrollDownExtendSelection.text=向下滾動頁面並擴展選擇範圍
action.Tree-scrollDownExtendSelection.description=將周圍的可滾動區域向下滾動一頁，然後將相應的節點添加到選擇範圍。
action.Tree-selectNextSibling.text=選擇下一個同級節點
action.Tree-selectNextSibling.description=選擇下一個同級節點。
action.Tree-selectPreviousSibling.text=選擇上一個同級節點
action.Tree-selectPreviousSibling.description=選擇上一個同級節點。
action.PopupMenu-selectPrevious.text=選擇上一個菜單項
action.PopupMenu-selectPrevious.description=選擇上一個菜單項。
action.PopupMenu-selectNext.text=選擇下一個菜單項
action.PopupMenu-selectNext.description=選擇下一個菜單項。
action.PopupMenu-selectParent.text=選擇父菜單項
action.PopupMenu-selectParent.description=關閉子選單並在父選單中選擇相應的項。
action.PopupMenu-selectChild.text=選擇子菜單項
action.PopupMenu-selectChild.description=打開子選單並在其中選擇相應的項。
action.PopupMenu-return.text=調用選定操作
action.PopupMenu-return.description=打開子選單或從選定的菜單項中調用操作。
action.PopupMenu-cancel.text=關閉右鍵選單
action.PopupMenu-cancel.description=關閉右鍵選單。
action.ScrollPane-scrollHome.text=滾動至頁首
action.ScrollPane-scrollHome.description=將周圍的可滾動區域滾動到頂部。
action.ScrollPane-scrollEnd.text=滾動至頁尾
action.ScrollPane-scrollEnd.description=將周圍的可滾動區域滾動到底部。
action.ScrollPane-unitScrollUp.text=向上滾動
action.ScrollPane-unitScrollUp.description=將周圍的可滾動區域向上滾動一個單位。
action.ScrollPane-unitScrollDown.text=向下滾動
action.ScrollPane-unitScrollDown.description=將周圍的可滾動區域向下滾動一個單位。
action.ScrollPane-unitScrollLeft.text=向左滾動
action.ScrollPane-unitScrollLeft.description=將周圍的可滾動區域向左滾動一個單位。
action.ScrollPane-unitScrollRight.text=向右滾動
action.ScrollPane-unitScrollRight.description=將周圍的可滾動區域向右滾動一個單位。
action.ScrollPane-scrollUp.text=向上滾動頁面
action.ScrollPane-scrollUp.description=將周圍的可滾動區域向上滾動一頁。
action.ScrollPane-scrollDown.text=向下滾動頁面
action.ScrollPane-scrollDown.description=將周圍的可滾動區域向下滾動一頁。
action.ScrollPane-scrollLeft.text=向左滾動頁面
action.ScrollPane-scrollLeft.description=將周圍的可滾動區域向左滾動一頁。
action.ScrollPane-scrollRight.text=向右滾動頁面
action.ScrollPane-scrollRight.description=將周圍的可滾動區域向右滾動一頁。
action.RunAnything.text=執行任何內容
action.RunAnything.description=允許執行任何命令
action.Performance.ActivityMonitor.text=活動監視器…
action.Performance.ActivityMonitor.description=用於檢查哪些套件和子系統消耗大多數資源的工具
action.performancePlugin.ShowMemoryDialogAction.text=更改記憶體設定
action.performancePlugin.ShowMemoryDialogAction.description=顯示更改記憶體對話框
action.DisablePCE.text=禁用 ProcessCanceledException
action.DisablePCE.description=禁用讀取操作期間在背景執行緒中引發的 ProcessCanceledException 以簡化調試
action.SearchEverywhere.NextTab.text=下一個頁籤
action.SearchEverywhere.NextTab.description=在 Search Everywhere 對話框中切換到下一個頁籤
action.SearchEverywhere.PrevTab.text=上一個頁籤
action.SearchEverywhere.PrevTab.description=在 Search Everywhere 對話框中切換到上一個頁籤
action.SearchEverywhere.CompleteCommand.text=補全命令
action.SearchEverywhere.CompleteCommand.description=在 Search Everywhere 對話框中自動補全命令
action.SearchEverywhere.SelectItem.text=選擇項
action.SearchEverywhere.SelectItem.description=在 Search Everywhere 對話框中選擇項
action.SearchEverywhere.NavigateToNextGroup.text=下一個組元素
action.SearchEverywhere.NavigateToNextGroup.description=在 Search Everywhere 對話框中導航到下一個組
action.SearchEverywhere.NavigateToPrevGroup.text=上一個組元素
action.SearchEverywhere.NavigateToPrevGroup.description=在 Search Everywhere 對話框中導航到上一個組

action.QuickActionPopup.text=顯示快速操作彈出視窗
action.NavBar-selectHome.text=選擇第一項
action.NavBar-selectEnd.text=選擇最後一項
action.NavBar-selectUp.text=打開相應的彈出選單
action.NavBar-selectDown.text=打開相應的彈出選單
action.NavBar-selectLeft.text=選擇上一項
action.NavBar-selectRight.text=選擇下一項
action.NavBar-cancel.text=關閉浮動導航欄
action.NavBar-return.text=對選定項執行操作
action.NavBar-navigate.text=從選定項導航
action.CollapseExpandableComponent.text=摺疊組件
action.ExpandExpandableComponent.text=展開組件
action.ShowColorPicker.text=顯示取色器
action.ToolwindowSwitcher.text=工具視窗切換器
action.QuickDocCopy.text=複製快速文檔
action.OpenElementInNewWindow.text=在新編輯器視窗中打開
action.ForceRefresh.text=強制刷新
action.Diff.OpenDiffInEditor.text=作為編輯器頁籤打開選定的差異請求
action.Diff.ShowSettingsPopup.text=顯示差異設定彈出視窗…
action.Diff.ShowInExternalTool.text=在外部工具中顯示差異
action.ScrollTreeToCenter.text=滾動到中心
action.IconsLoadTime.text=日誌圖標載入時間
action.NewDummyProject.text=新建虛擬專案
action.NextTemplateParameter.text=下一個實時模板參數
action.PrevTemplateParameter.text=上一個實時模板參數
action.Performance.DumpThreads.text=轉儲執行緒
action.CollectTroubleshootingInformation.text=收集故障排除資訊
action.WelcomeScreen.OpenSelected.text=打開選定項
action.WelcomeScreen.NewGroup.text=新建專案組
action.WelcomeScreen.EditGroup.text=編輯…
action.WelcomeScreen.ChangeProjectIcon.text=更改專案圖標…
action.WelcomeScreen.CopyProjectPath.text=複製路徑
action.WelcomeScreen.RemoveSelected.text=從最近的專案中移除
action.JBTabsDemo.text=JBTabs 演示
action.JTabbedPaneDemo.text=JTabbedPane 演示
action.DumbMode.text=沉默模式
action.LaggingMode.text=滯後模式
action.AddInlayInternalAction.text=添加嵌入…
action.EditorRenderingBenchmarkAction.text=編輯器渲染基準
action.NotificationTestAction.text=添加測試通知
action.LabelSizeDemoAction.text=測試標籤大小
action.TestMessageBoxAction.text=顯示測試對話框
action.ComponentPanelTestAction.text=顯示標準面板
action.ResetGotItTooltips.text=重置“知道了”工具提示
action.CloseGotItTooltip.text=關閉“知道了”工具提示
action.CheckMessagesButtonsOrderAction.text=檢查訊息按鈕順序
action.ShowDelayedMessageInternalAction.text=顯示延遲訊息
action.ManualMacMessagesTest.text=用於測試 Mac 訊息的手動測試
action.MacMessagesSequencesTest.text=測試 Mac 訊息序列
action.FocusDebugger.text=啟動焦點調試器
action.DumpFocusableComponentHierarchyAction.text=轉儲可聚焦組件層次結構
action.ChooseRuntime.text=選擇 IDE 的啟動 Java 執行時…
action.FocusTracer.text=啟動焦點跟踪
action.LogFocusRequests.text=日誌焦點請求
action.UiInspector.text=UI 檢查器(&I)
action.ToggleUiInspectorHierarchyTrace.text=切換 UI 檢查器層次結構跟踪
action.ToggleUiInspectorHierarchyTrace.text.enable=啟用 UI 檢查器層次結構跟踪
action.ToggleUiInspectorHierarchyTrace.text.disable=禁用 UI 檢查器層次結構跟踪
action.GrayFilterConfig.text=灰色篩選器(&G)
action.TextGrayFilterConfig.text=文本灰色篩選器(&T)
action.ShowSplash.text=顯示初始頁面
action.ShowAboutPopupInDebugModeAction.text=在調試模式下顯示“關於”彈出視窗
action.ValidationTest.text=驗證對話框測試
action.MacMessagesTest.text=測試 Mac 訊息
action.ColorBlindnessTest.text=測試色盲
action.TreeExpandAll.text=展開樹
action.UIDefaults.text=LaF 預設設定
action.RulerGuide.text=標尺參考線
action.WriteActionUnderProgress.text=正在測試寫入操作
action.TestProgressWindow.text=測試進度視窗
action.TestGestureAction.text=測試手勢操作
action.TestDndAction.text=測試 Dnd
action.AnimatorTestAction.text=測試 Animator
action.PositionTrackerTestAction.text=測試位置跟踪器
action.ShowProgressTestDialogAction.text=測試進度指示器
action.ShowSouthPanelTestDialogAction.text=測試 DialogWrapper 南側面板
action.TestTextFieldAction.text=測試文本欄位
action.ShowNotificationIconsDialogAction.text=測試通知圖標
action.DebugMigLayoutAction.text=UI DSL 調試模式
action.WebBrowser.text=顯示 Web 瀏覽器(&W)
action.ImageDuplicates.text=尋找圖片重複項
action.ShowNonRetinaImages.text=顯示非視網膜圖片
action.ShowUpdateDialogAction.text=顯示“更新”對話框
action.ApplyFixedWindowSize.text=套用特定大小
action.ConfigureDefaultSize.text=配置預設大小…
action.ShowEditorHighlighterTokens.text=顯示編輯器螢光筆令牌
action.DirDiffMenu.SynchronizeDiff.text=同步選定項
action.DirDiffMenu.SynchronizeDiff.All.text=全部同步
action.DirDiffMenu.SetCopyToRight.text=設定複製到右側
action.DirDiffMenu.SetCopyToLeft.text=設定複製到左側
action.DirDiffMenu.SetDelete.text=設定刪除
action.DirDiffMenu.SetNoOperation.text=設定不執行任何操作
action.DirDiffMenu.MirrorToRight.text=設定鏡像到右側
action.DirDiffMenu.MirrorToLeft.text=設定鏡像到左側
action.DirDiffMenu.SetDefault.text=設定預設值
action.DirDiffMenu.WarnOnDeletion.text=刪除時發出警告
action.DirDiffMenu.EnableLeft.text=在左側顯示新檔案
action.DirDiffMenu.EnableRight.text=在右側顯示新檔案
action.DirDiffMenu.EnableEqual.text=顯示相同的檔案
action.DirDiffMenu.EnableNotEqual.text=顯示差異
action.DirDiffMenu.CompareNewFilesWithEachOtherAction.text=相互比較新檔案
action.DirDiffMenu.CancelComparingNewFilesWithEachOther.text=取消相互比較新檔案
action.OpenBlankEditorInBlankDiffWindow.text=切換到空白編輯器
action.OpenFileEditorInBlankDiffWindow.text=切換到檔案…
group.OpenRecentEditorInBlankDiffWindow.text=切換到“最近”
action.SwapSidesInDiffWindow.text=交換兩側
action.ToggleThreeSideInBlankDiffWindow.text=切換三向查看器
action.ToggleThreeSideInBlankDiffWindow.text.enable=切換到三向查看器
action.ToggleThreeSideInBlankDiffWindow.text.disable=切換到兩向查看器
action.SwapThreeWayColorModeInDiffWindow.text=更改三向查看器模式
action.Rerun.text=重新執行
action.RerunTests.text=重新執行測試
action.MaximizeActiveDialog.text=最大化/恢復活動對話框
action.SelectInProjectView.text=在專案檢視中選擇檔案
action.SelectInProjectView.description=在專案檢視中選擇上下文檔案
action.SelectOpenedFileInProjectView.text=選擇打開的檔案
# suppress inspection \\"UnusedProperty\\" - used from SelectFileAction
action.SelectOpenedFileInProjectView.description=在專案檢視中選擇已打開的檔案
action.ShowFilterPopup.text=顯示篩選器彈出視窗
action.ShowSearchHistory.text=顯示搜尋歷史記錄
action.HidpiInfo.text=顯示 HiDPI 資訊(&H)
action.UserInvokedFullAnalysis.text=創建並立即分析堆轉儲
action.SilentHeapDumpSnapshot.text=創建並計劃堆轉儲分析 (非使用者調用)
action.NextWindow.text=啟用下一個視窗
action.PreviousWindow.text=啟用上一個視窗
action.CopyAbsolutePath.text=絕對路徑
action.CopyPathWithLineNumber.text=帶行號的路徑
action.CopyContentRootPath.text=來自內容根的路徑
action.CopySourceRootPath.text=來自源根的路徑
action.CopyTBXReference.text=工具箱 URL
action.CopyFileName.text=文件名

EmojiAndSymbols.text=表情 \\\\\\\\& 符號
action.ToggleFocusMode.text=僅高亮顯示當前宣告

group.ListActions.text=列表操作
group.TableActions.text=表操作
group.TreeActions.text=樹操作
group.PopupMenuActions.text=彈出選單操作
group.NavBarActions.text=導航欄操作
group.ScrollPaneActions.text=滾動
group.Diff.KeymapGroup.text=差異與合併
group.compare.contents.text=比較內容
group.TabsActions.text=制表符
group.TWViewModes.text=工具視窗檢視模式
group.TWViewModesLegacy.text=工具視窗傳統檢視模式 (已棄用)
group.SearchEverywhereActions.text=隨處搜尋
group.Internal.HeapAnalysis.text=堆分析
group.Internal.UI.Demos.text=演示

action.ChooseRunConfiguration.text=執行…
action.ChooseRunConfiguration.description=選擇並執行配置
action.ChooseDebugConfiguration.text=調試…
action.ChooseDebugConfiguration.description=選擇並調試配置
action.Refactorings.QuickListPopupAction.text=重構此…
action.Refactorings.QuickListPopupAction.description=包含重構操作列表的上下文感知彈出視窗

action.GeneratePattern.text=按模式生成…
action.ProjectViewEditSource.text=編輯源
action.TypeHierarchyBase.BaseOnThisType.text=基於此類型
action.MethodHierarchy.BaseOnThisMethod.text=基於此方法
action.CallHierarchy.BaseOnThisMethod.text=基於此方法
action.Debugger.RemoveAllBreakpoints.text=移除所有斷點
action.Debugger.RemoveAllBreakpointsInFile.text=移除當前檔案中的所有斷點
action.Debugger.CopyStack.text=複製堆疊
action.Vcs.Operations.Popup.Annotate.text=註解行操作
action.SendEOF.text=發送 EOF
action.ImportTests.text=匯入測試結果
action.ImportTestsFromFile.text=從檔案匯入測試
action.DumpLookupElementWeights.text=將尋找元素權重轉儲到日誌
action.RunDashboard.Run.text=執行
action.RunDashboard.Debug.text=調試
action.RunDashboard.Stop.text=停止
action.RunDashboard.EditConfiguration.text=編輯所選配置
action.RunDashboard.CopyConfiguration.text=複製配置
action.RunDashboard.HideConfiguration.text=隱藏配置
action.RunDashboard.RestoreHiddenConfigurations.text=恢復隱藏的配置
action.RunDashboard.RemoveType.text=從服務中移除配置類型
action.RunDashboard.OpenRunningConfigInNewTab.text=在新頁籤中打開執行配置
action.RunDashboard.ClearContent.text=清除內容
action.RunDashboard.RestoreConfiguration.text=恢復配置
action.RunDashboard.GroupConfigurations.text=分組配置
action.RunDashboard.UngroupConfigurations.text=對配置取消分組
action.ServiceView.GroupByContributor.text=服務類型
action.ServiceView.GroupByServiceGroups.text=服務組
action.ServiceView.OpenInNewTab.text=在新頁籤中打開
action.ServiceView.OpenEachInNewTab.text=在新頁籤中打開每個項
action.ServiceView.SplitByType.text=在新頁籤中打開每個類型
action.ServiceView.JumpToServices.text=跳轉到服務
action.ServiceView.ShowServices.text=顯示服務樹
action.RunDashboard.GroupByType.text=類型
action.RunDashboard.GroupByStatus.text=狀態
action.RunDashboard.AddType.text=執行配置類型
action.UpdateRunningApplication.text=更新正在執行的應用程式
action.TypingLatencyReport.text=輸入延遲報告
action.RetypeFile.text=重新輸入當前檔案
action.CompletionQualityStats.text=補全品質統計資訊
action.ShowControlFlowAction.text=顯示控制流

action.AnalyzePluginStartupPerformance.text=分析套件啟動性能
action.TriggerLowMemoryNotification.text=觸發低記憶體通知

action.WelcomeScreen.ManageLicense.text=管理許可證…
action.AskForLicense.text=顯示“使用者協議”對話框
action.Register.text=註冊(_R)…
action.Register.description=輸入註冊資料
group.RegistrationActions.text=註冊操作

group.TodoMainGroup.text=TODO
group.TodoViewGroupByGroup.text=分組依據
group.TouchBarDebug.ForceStepButtons.text=調試器強制步操作
group.TouchBarDebug_alt.text=使用 Alt 鍵的調試器
group.TouchBarDebug.StepButtons.text=調試器步操作
group.TouchBarDebug.text=調試器
group.TouchBarDefault_shift.text=預設使用 Shift 鍵
group.TouchBarDefault_cmd.alt.text=預設使用 Alt+Cmd 鍵
group.TouchBarDefault_cmd.text=預設使用 Cmd 鍵
group.TouchBarDefault_alt.text=預設使用 Alt 鍵
group.TouchBarDefault_ctrl.text=預設使用 Ctrl 鍵
group.TouchBarDefaultOptionalGroup.text=可選操作
group.RunnerActionsTouchbar.text=Touch Bar 執行/調試操作
group.TouchBarDefault.text=預設
group.RunDashboard.Filter.text=配置狀態
group.RunDashboard.GroupBy.text=配置
group.ServiceView.AddService.text=添加服務
group.ServiceView.OpenInNewTabGroup.text=在新頁籤中打開
group.ServiceView.Filter.text=篩選器
group.ServiceView.GroupBy.text=分組依據
group.ShowAnnotateOperationsPopupGroup.text=註解行

action.Graph.Layout.CompactOrthogonalLayouter.text=緊湊
action.Graph.Layout.HierarchicGroupLayouter.text=層次結構組
action.Graph.Layout.HierarchicLayouter.text=分層
action.Graph.Layout.OrthogonalGroupLayouter.text=正交群
action.Graph.Layout.ChannelLayouter.text=通道
action.Graph.Layout.SeriesParallelLayouter.text=串並聯
action.Graph.Layout.CircularLayouter.text=迴圈
action.Graph.Layout.CircularEdgeBundledLayouter.text=邊緣捆綁(圓形)
action.Graph.Layout.RadialLayouter.text=徑向
action.Graph.Layout.RadialEdgeBundledLayouter.text=邊緣捆綁(徑向)
action.Graph.Layout.SingleCycleLayouter.text=單迴圈
action.Graph.Layout.ARTreeLayouter.text=緊湊
action.Graph.Layout.BalloonLayouter.text=氣球
action.Graph.Layout.BalloonEdgeBundledLayouter.text=邊緣捆綁(氣球)
action.Graph.Layout.FamilyLayouter.text=系列
action.Graph.Layout.GenericLayouter.text=泛型
action.Graph.Layout.HVTreeLayouter.text=寬
action.Graph.Layout.OrganicLayouter.text=有機
action.Graph.Layout.OrganicEdgeBundledLayouter.text=邊緣捆綁(有機)
action.Graph.Layout.RandomLayouter.text=隨機
action.Graph.Layout.CustomLayouter.text=圖特定
action.Graph.Layout.Fit.Content.text=在布局後調整內容

group.Graph.CommonLayoutGroup.text=布局
group.Graph.NetsLayoutGroup.text=網狀
group.Graph.OrthogonalLayoutGroup.text=正交
group.Graph.RadialLayoutGroup.text=徑向
group.Graph.TreeLayoutGroup.text=樹
action.Graph.ApplyCurrentLayout.text=套用當前布局
action.Graph.RouteEdges.text=自動路由邊緣
action.Graph.Current.Node.Dependencies.Filter.text=顯示所選節點與依賴關係
action.Graph.Show.Edge.Labels.text=顯示邊緣標籤
action.Graph.Show.Bridges.text=顯示鏈接橋
action.Graph.Delete.text=刪除選區
action.Graph.FitContent.text=調整內容
action.Graph.SnapToGrid.text=對齊到網格
action.Graph.ShowHideGrid.text=顯示網格
action.Graph.ExportToFile.text=匯出到圖片檔案…
action.Graph.ExportToFile.description=匯出到 PNG、JPG、GIF、SVG 或 SVGZ 檔案
action.Graph.ActualSize.text=實際尺寸
action.Graph.ZoomOut.text=縮小
action.Graph.ZoomIn.text=放大

action.JsonCopyPointer.text=複製 JSON 指針
action.JsonCopyPointer.description=複製 JSON 指針

action.JsonPathEvaluateAction.text=評估 JSONPath 表達式…
action.JsonPathExportEvaluateResultAction.text=匯出結果

action.ExternalSystem.RemoveRunConfiguration.text=移除執行配置
action.ExternalSystem.EditRunConfiguration.text=編輯執行配置…
action.ExternalSystem.ShowIgnored.text=顯示忽略項
action.ExternalSystem.ShowInheritedTasks.text=顯示從子專案繼承的任務
action.ExternalSystem.GroupModules.text=組模組
action.ExternalSystem.GroupTasks.text=組任務
action.ExternalSystem.BeforeRun.text=在執行/調試之前執行…
action.ExternalSystem.BeforeRun.description=在啟動執行/調試配置之前執行選定任務
action.ExternalSystem.AfterRebuild.text=重新構建後執行
action.ExternalSystem.AfterRebuild.description=在完全重新構建後執行選定任務
action.ExternalSystem.BeforeRebuild.text=重新構建前執行
action.ExternalSystem.BeforeRebuild.description=在完全重新構建前執行選定任務
action.ExternalSystem.AfterCompile.text=構建後執行
action.ExternalSystem.AfterCompile.description=在構建後執行選定任務
action.ExternalSystem.BeforeCompile.text=構建前執行
action.ExternalSystem.BeforeCompile.description=在構建前執行選定任務
action.ExternalSystem.AfterSync.text=同步後執行
action.ExternalSystem.AfterSync.description=在專案匯入後執行選定任務
action.ExternalSystem.BeforeSync.text=同步前執行
action.ExternalSystem.BeforeSync.description=在專案匯入前執行選定任務
action.ExternalSystem.AssignRunConfigurationShortcut.text=分配快捷鍵…
action.ExternalSystem.AssignRunConfigurationShortcut.description=將快捷鍵分配給選定執行配置
action.ExternalSystem.AssignShortcut.text=分配快捷鍵…
action.ExternalSystem.AssignShortcut.description=將快捷鍵分配給選定任務
action.ExternalSystem.RunTask.text=執行任務(_R)
action.ExternalSystem.RunTask.description=執行選定任務
action.ExternalSystem.SelectProjectDataToImport.text=選擇要匯入的專案資料
action.ExternalSystem.CollapseAll.text=全部摺疊
action.ExternalSystem.ExpandAll.text=全部展開
group.ExternalSystem.ShowSettingsGroup.text=構建工具設定
action.ExternalSystem.ShowCommonSettings.text=自動重新載入設定…
action.ExternalSystem.ShowCommonSettings.description=為當前專案編輯構建工具設定

action.NewDatabaseProject.text=專案…
action.DetachDirectory.text=從專案中分離目錄…
action.AttachDirectory.text=將目錄附加到專案…
action.ConsoleView.FoldLinesLikeThis.text=像這樣折疊行
action.ManageProjectTemplates.text=管理專案模板…
action.SaveProjectAsTemplate.text=將專案另存為模板…
action.InsertRubyInjectionWithoutOutput.text=插入 '<% %>'
action.InsertRubyInjectionWithoutOutput.description=在 Erb 檔案中插入 '<% %>'
action.InsertRubyInjection.text=插入 '<%= %>'
action.InsertRubyInjection.description=在 Erb 檔案中插入 '<%= %>'
action.GemRequirements.ShowSettings.text=Ruby SDK 和 Gem
action.RubyMineDeveloperCommunity.text=開發者社區
action.RubyMineDeveloperCommunity.description=RubyMine 開發者社區論壇
action.RubyMineDemos.text=演示和教程
action.RubyMineDemos.description=查看介紹 RubyMine 功能的簡短現場演示
action.NewRubyMineDirectoryProject.text=專案…
group.Internal.PMM.text=PMM 實用工具
group.TopAnomalies.text=頂級異常
group.Internal.focusAndModality.text=焦點和模式測試
group.Internal.UI.text=UI(&U)
group.Internal.Editor.text=編輯器(&E)
group.Internal.Performance.text=性能
group.Internal.Errors.text=異常
group.Internal.text=內部操作(&I)
group.WelcomeScreen.MoveToGroup.text=移動到組
action.$Redo.text=重做
action.$Undo.text=撤消
group.Vcs.KeymapGroup.text=版本控制系統
group.InspectCodeGroup.text=檢查程式碼操作
action.OpenStatisticsEventLogAction.text=打開統計事件日誌
action.OpenStatisticsEventLogAction.description=打開具有統計事件日誌的工具視窗
action.ConfigureEventsSchemeFileAction.text=配置事件方案檔案
action.ConfigureEventsSchemeFileAction.description=載入自訂資料夾中的事件方案
action.ReportSettingsToFUS.text=將更改的設定記錄到事件日誌
action.CleanupEventsTestSchemeAction.text=清理事件測試方案
action.CleanupEventsTestSchemeAction.description=移除測試方案中註冊的所有組
action.RecordStateCollectors.text=將狀態收集器記錄到事件日誌
action.RecordStateCollectors.description=將所有狀態收集器和記錄結果調用到事件日誌
action.ShowChangedStateStatisticsAction.text=僅顯示已更改的狀態事件
action.ShowChangedStateStatisticsAction.description=調用所有狀態收集器，並僅顯示自上一個記錄以來已更改的事件
action.AddGroupToTestSchemeAction.text=將組添加到事件測試方案
action.AddGroupToTestSchemeAction.description=允許來自組的所有資料。使用它在本地測試新的收集器。
action.EditTestSchemeAction.text=編輯事件測試方案
action.EditTestSchemeAction.description=允許來自組的所有資料。使用它在本地測試新的收集器。
group.OpenEventLogFileAction.text=在編輯器中打開事件日誌
group.OpenEventLogFileAction.description=在 IDE 中打開活動事件日誌檔案
group.OpenEventsTestSchemeFileAction.description=在 IDE 中打開事件測試方案檔案
group.OpenEventsSchemeFileAction.description=在 IDE 中打開事件方案檔案
group.UpdateEventsSchemeAction.description=必要時更新伺服器中的主要事件方案。也重新載入該檔案中的事件測試方案。
action.SendEventLogStatistics.text=發送功能用法事件日誌
action.SendEventLogStatistics.description=將事件日誌檔案发送到 QA 伺服器
group.FeatureUsage.Internal.text=功能用法統計資訊
group.CleanupEventLog.text=清理事件日誌
group.CleanupEventLog.description=移除所有未發送事件日誌檔案
action.GenerateEventsScheme.text=顯示 FUS 收集器方案
action.GenerateEventsScheme.description=從正在執行的 IDE 實例中收集統計資訊收集器的方案
action.StaticIconFields.text=列出 static 欄位初始值設定項
action.ExpressionStatistics.text=收集 Java 表達式統計資訊
action.UsedIconsListing.text=列出使用的圖標
action.GenerateVisitorByHierarchy.text=生成層次結構訪問者…
group.Internal.Java.text=Java
action.CollectFUStatisticsAction.text=從收集器收集統計資訊…
action.TestParseEventsSchemeAction.text=測試解析事件方案…
action.ValidateLocalHistory.text=驗證本地歷史記錄存儲
action.FixLineSeparators.text=修復行分隔符
action.PruneEmptyDirectories.text=刪除空目錄
action.LoadAllVFSContent.text=載入所有 VFS 存儲的檔案內容
action.LoadAllContent.text=載入所有檔案內容
action.CheckVfsSanity.text=檢查 VFS 健全性
action.MarkFileDirty.text=將檔案標記為髒
action.DumpWatchedRoots.text=顯示監視的 VFS 根
group.Internal.VFS.text=VFS
action.TurnOnOffCachedValueProfilerAction.text=打開快取值分析器
action.DumpScreenConfiguration.text=轉儲螢幕配置
action.ScanSourceCommentsAction.text=轉儲專案中的所有註釋
action.DumpExtensions.text=轉儲副檔名
group.Internal.Dump.text=轉儲
group.Internal1.text=IDEA 內部操作
action.FindUsedTestData.text=尋找未使用的測試資料
action.ShowDiscoveredTests.text=顯示受影響的測試
action.RenameAction.text=重命名…
action.LightEditExitAction.text=退出(&X)
action.LightEditNewFileAction.text=新建(&N)
action.FileChooser.LightEditGotoOpenedFile.text=選擇打開的檔案
action.LightEditOpenFileInProjectAction.text=在專案中打開檔案…
action.SaveAs.text=另存為…
action.AttachProject.text=附加專案…
action.DumpVfsInfoForExcludedFilesAction.text=轉儲排除根下檔案的 VFS 內容
action.ResetFilterAction.text=重置篩選器
action.ChangeSortingAction.text=按名稱排序
action.RestoreShelvedChange.text=恢復
action.ComputeVirtualFileNameStatAction.text=計算 VF 名稱統計資訊
action.CustomizeUIAction.text=自訂選單和工具欄…
action.ShowDetailedInformationAction.text=顯示間接依賴項
action.RemoveFromScopeAction.text=從範圍中移除
action.AddToScopeAction.text=添加到範圍
action.DumpConfigurationTypesAction.text=轉儲配置
action.DumpDirectoryInfoAction.text=轉儲目錄資訊
action.DumpInspectionDescriptionsAction.text=轉儲檢查描述
action.DumpIntentionsAction.text=轉儲意圖
action.DumpFormattingModelAction.text=轉儲格式化模型
action.ConfigureScopesAction.text=配置…
action.MaintenanceAction.text=維護
action.ReopenClosedTabAction.text=重新打開關閉的頁籤
action.SeverityEditorDialogAction.text=顯示嚴重性編輯器
action.ConfigureTemplatesAction.text=配置實時模板…
action.ShowFontsUsedByEditor.text=顯示編輯器使用的字體
action.ShowFontsUsedByEditor.description=允許找出編輯器中實際使用的回退字體

action.Profiler.OpenMergedCalleesAction.text=方法合並被調用方
action.Profiler.OpenMergedCalleesAction.description=在新頁籤中打開選定的方法合並被調用方樹
action.Profiler.ExcludeCallAction.text=排除調用
action.Profiler.ExcludeSubTreeAction.text=排除子樹
action.Profiler.FocusOnCallAction.text=聚焦於調用
action.Profiler.FocusOnSubtreeAction.text=聚焦於子樹
action.Profiler.FocusOnSubtreeAction.description=在新頁籤中打開選定的子樹
action.Profiler.OpenBackTracesAction.text=方法回溯
action.Profiler.OpenBackTracesAction.description=在新頁籤中打開選定的方法回溯樹

action.OpenMouseWheelSmoothScrollSettings.text=平滑滾動選項
save.file.as.template=將檔案另存為模板

action.DupLocate.text=定位重複項(_L)…
action.DupLocate.description=尋找專案中的重複程式碼
action.InspectionFilterAction.filter.inspections.text=篩選器檢查
action.InspectionFilterAction.filter.by.language.text=按語言篩選

action.AnnotateStackTraceAction.show.files.modification.info.text=顯示檔案修改資訊

group.ProblemsView.Options.text=檢視選項
group.ProblemsView.Options.description=允許對問題進行分類和篩選
action.ProblemsView.AutoscrollToSource.text=一鍵打開檔案
action.ProblemsView.AutoscrollToSource.description=為所選檔案打開編輯器，並在更改選擇後導航到選定問題
action.ProblemsView.ShowPreview.text=打開編輯器預覽
action.ProblemsView.ShowPreview.description=為所選檔案打開預覽，並在更改選擇後導航到選定問題
action.ProblemsView.GroupByToolId.text=按檢查分組
action.ProblemsView.GroupByToolId.description=允許按檢查對問題分組
action.ProblemsView.SortFoldersFirst.text=資料夾總在最前面
action.ProblemsView.SortFoldersFirst.description=單獨對檔案和資料夾排序
action.ProblemsView.SortBySeverity.text=按嚴重程度排序
action.ProblemsView.SortBySeverity.description=允許按嚴重程度對問題進行排序
action.ProblemsView.SortByName.text=按名稱排序
action.ProblemsView.SortByName.description=允許按名稱對問題進行排序
action.ProblemsView.QuickFixes.text=顯示快速修復
action.ProblemsView.QuickFixes.description=顯示所選問題的可用快速修復
action.ProblemsView.CopyProblemDescription.text=複製問題描述
action.ProblemsView.CopyProblemDescription.description=將問題描述複製到剪貼簿

group.Patch.MainMenu.text=補丁檔案

action.LoadUnloadModules.text=載入/移除模組…
group.ArrangementRulesGroup.text=排列規則
group.FileChooserToolbar.text=檔案選擇器

action.EditorTranspose.text=轉置
action.EditSourceNotInEditor.text=編輯源(不在編輯器中)
action.ActivateFindToolWindow.text=尋找
action.ActivateRunToolWindow.text=執行
action.ActivateDebugToolWindow.text=調試
action.ActivateHierarchyToolWindow.text=層次結構
group.RunContextGroupMore.text=更多執行/調試
group.RevealGroup.text=打開於
group.OpenInBrowserGroup.EditorTabPopup.text=瀏覽器
action.ResetWindowsDefenderNotification.text=重置 Windows Defender 通知
action.FindSelectionInPath.text=在檔案中尋找

group.Internal.Trust.text=原始碼安全性
action.UnsureProject.text=不確定
action.TrustProject.text=信任
action.UntrustProject.text=不信任
action.FixWSLFirewall.text=修正 WSL 防火牆設定

action.RunConfigurationTemplatesForNewProjects.MainMenu.text=執行配置模板…
action.TemplateProjectStructure.MainMenu.text=結構…
action.ClickLink.text=點擊鏈接

action.SetCaretVisualAttributesInternalAction.text=設定文本游標視覺特性…
action.XDebugger.PreviewTab.text=在預覽頁籤中打開檔案
group.Diff.Binary.Settings.text=設定
action.Graph.MergeEdges.BySources.text=按源
action.Graph.MergeEdges.ByTargets.text=按目標
group.Graph.MergeEdgesGroup.text=合併邊緣
action.DockToolWindow.text=Dock
action.Unscramble.EditorPopup.text=堆疊跟踪或執行緒轉儲(_S)…
group.AnalyzeActionsPopup.text=分析程式碼
action.Vcs.RunCommitChecks.text=執行提交檢查
action.Help.JetBrainsTV.templateText=YouTube 上的 {0}
action.DefaultBundleIndex.text=生成預設捆綁操作列表
action.Scratch.ShowFilesPopup.text=顯示臨時檔案
action.Scratch.ShowFilesPopup.description=在彈出視窗中顯示臨時檔案
action.Scratch.ExportToScratch.text=匯出到臨時檔案
action.Scratch.ExportToScratch.description=作為文本匯出到新的臨時檔案
action.RunToolbarWidgetAction.text=執行/調試微件
action.RunToolbarProcessStartedAction.text=活動進程
action.RunToolbarRunConfigurationsAction.text=添加配置…
action.RunToolbarRerunAction.text=重新執行
action.RunToolbarStopAction.text=停止
action.RunToolbarMainMultipleStopAction.text=停止
action.RunToolbarResumeAction.text=恢復
action.RunToolbarPauseAction.text=暫停
group.Graph.AppearanceGroup.text=外觀
group.Graph.EdgeRealizerGroup.text=邊緣形狀
action.Graph.EdgeRealizer.ArcEdgeRealizer.text=弧形
action.Graph.EdgeRealizer.BezierEdgeRealizer.text=貝塞爾曲線
action.Graph.EdgeRealizer.QuadCurveEdgeRealizer.text=二次曲線
action.Graph.EdgeRealizer.SplineEdgeRealizer.text=樣條
action.Graph.EdgeRealizer.StraightPolylineEdgeRealizer.text=直多段線
action.Graph.EdgeRealizer.SmoothedPolylineEdgeRealizer.text=平滑多段線
group.LocalChangesView.ShowOnDoubleClick.text=雙擊時顯示
action.LocalChangesView.ShowOnDoubleClick.EditorPreview.text=雙擊時顯示差異
action.LocalChangesView.ShowOnDoubleClick.EditorPreview.ToolwindowPopup.text=差異
action.LocalChangesView.ShowOnDoubleClick.Source.text=雙擊時顯示源
action.LocalChangesView.ShowOnDoubleClick.Source.ToolwindowPopup.text=源
group.Graph.LayoutOrientationGroup.text=方向
action.Graph.LayoutOrientation.BottomToTop.text=🠉 從下到上
action.Graph.LayoutOrientation.TopToBottom.text=🠋 從上到下
action.Graph.LayoutOrientation.LeftToRight.text=🠊 從左到右
action.Graph.LayoutOrientation.RightToLeft.text=🠈 從右到左
action.Graph.CopyEntireDiagramToClipboard.text=將圖表複製到剪貼簿
action.Graph.CopyDiagramSelectionToClipboard.text=將選區複製到剪貼簿
action.Diff.ShowDiffPreview.description=選區變更時取代差異內容
action.Diff.ShowStandaloneDiff.text=在新頁籤或視窗中顯示差異
action.Diff.ShowStandaloneDiff.description=在新頁籤或視窗中打開每個選區的差異
action.Diff.ShowStandaloneDiff.tab.text=在新頁籤中顯示差異
action.Diff.ShowStandaloneDiff.tab.description=在新頁籤中打開每個選區的差異
action.Diff.ShowStandaloneDiff.window.text=在新窗口中顯示差異
action.Diff.ShowStandaloneDiff.window.description=在新窗口中打開每個選區的差異
action.PluginManagerFiltersConfigureTrustOnlyJetBrainsDebugAction.text=Org 套件篩選器: 僅信任 JetBrains
action.PluginManagerFiltersConfigureResetTrustDebugAction.text=Org 套件篩選器: 重置
action.RunToolbarHotSwapAction.text=熱交換
action.CloseContent.EditorTabPopup.text=關閉 (_C)
action.MarkVfsCorrupted.text=將 VFS 標記為已損壞
action.ForceIndexRescanning.text=同步索引
action.ForceIndexRebuild.text=重建索引
action.Vcs.Diff.ShowCombinedDiff.text=顯示組合差異
action.Vcs.Diff.ShowCombinedDiff.description=在一處顯示全部所選變更的差異
group.ProjectView.ToolWindow.Appearance.Actions.text=樹外觀
action.RunToolbarShowHidePopupAction.text=同時啟動多個配置
action.RunToolbarShowHidePopupAction.show.text=顯示停靠的配置
action.RunToolbarShowHidePopupAction.hide.text=隱藏停靠的配置
group.MoreActionGroup.text=更多
action.CallSaul.text=修復 IDE
action.CallSaul.description=執行快取診斷並嘗試恢復其狀態
action.SwitchFileBasedIndexStorageAction.text=切換基於檔案的索引存儲
action.RunToolbarMainSlotInfoAction.text=活動進程
group.CacheRecovery.text=快取恢復
action.Table-startEditing.text=編輯表單元
action.Tree-startEditing.text=編輯樹節點
action.SearchEverywhereToolbar.searching.text=正在搜尋…
action.RunToolbarMainSlotActive.text=活動進程
group.Graph.NeighborhoodViewPopup.LayoutGroup.text=布局
group.Graph.NeighborhoodViewPopup.AppearanceGroup.text=外觀
group.Graph.BehaviourGroup.text=行為
group.Graph.ExportGroup.text=匯出圖
action.Graph.NeighborhoodViewPopup.CompactMode.text=緊湊地顯示節點
action.Graph.NeighborhoodViewPopup.SameAsModelLayouter.text=與 Main 相同
action.Graph.ShowStructureViewForSelectedNode.text=顯示所選節點的結構檢視
tiny.spacer=微型分隔
small.spacer=小型分隔
big.spacer=大型分隔
action.RunToolbarMoveToTopAction.text=將配置移至頂部
action.RunToolbarEditConfigurationAction.text=編輯配置…
action.RunToolbarRemoveSlotAction.text=移除
action.RunToolbarMainRunConfigurationsAction.text=添加配置…
action.ListPersistentStateComponents.text=列出持久狀態組件
action.Documentation.ToggleShowInPopup.text=首先顯示文檔彈出視窗
action.Documentation.ToggleShowInPopup.description=切換是否應在工具視窗之前顯示文檔彈出視窗
action.RunToolbarShowHidePopupAction.show.popup.text=顯示或隱藏停靠的配置
action.RunToolbarShowHidePopupAction.click.to.show.popup.text=點擊以顯示或隱藏停靠配置
action.RunToolbarShowHidePopupAction.click.to.open.toolwindow.text=點擊以打開進程工具視窗
action.RunToolbarShowHidePopupAction.click.to.open.combo.text=點擊以選擇執行配置
action.ProblemsView.OpenInPreviewTab.text=啟用預覽頁籤
action.EditorLookupSelectionUp.text=選擇上一個補全選項
action.EditorLookupSelectionDown.text=選擇下一個補全選項
action.JBLogin.text=JetBrains 登錄(_J)…
action.JBLogin.description=登錄 JetBrains Account
action.RunToolbarRemoveSlotAction.terminating=正在終止
action.OverrideFileTypeAction.verbose.description=將檔案 ''{0}''{1,choice,0#|1# (和 {1} 個其他檔案)}視為具有不同檔案類型的檔案
action.Vcs.Diff.ToggleDiffAligningMode.text=在並排差異中對齊變更
action.Vcs.Diff.ToggleDiffAligningMode.popup@DiffToolbar.text=對齊變更高亮顯示
action.Vcs.Diff.ToggleDiffAligningMode.description=啟用雙面差異的變更對齊
action.RunToolbarShowToolWindowTab.text=顯示進程工具視窗
action.XDebugger.ToggleEvaluateExpressionField.text=顯示評估表達式欄位
group.XDebugger.Watches.Presentation.text=演示設定
action.NewMigration.text=創建新的遷移...
group.MigrationMenu.text=遷移軟體套件和類
action.Documentation.ViewExternal.text=查看外部文檔
action.JBCefOsrMeasureFps.text=測量 OSR JCEF FPS
action.Documentation.Back.text=後退
action.Documentation.Forward.text=前進
action.Documentation.EditSource.text=編輯源
action.Documentation.ToggleAutoShow.text=在補全期間自動顯示
action.Documentation.ToggleAutoShow.description=切換是否使用補全彈出視窗自動顯示文檔
group.popup@ExpandableBookmarkContextMenu.text=書籤
action.DeleteRecentFiles.text=從最近的檔案刪除
action.DeleteRecentFiles.description=從最近的檔案中刪除選定的檔案或關閉選定的工具視窗
action.ExcludeFromProjectAction.text=從專案中排除
action.IncludeToProjectAction.text=包含到專案中
group.EditorTabsEntryPoint.text=最近的檔案、頁籤操作等
action.Documentation.KeepTab.text=保留此文檔
action.Documentation.KeepTab.description=關閉當前頁籤中的所有更新，使下一個操作調用打開新的頁籤
action.Documentation.ToggleAutoUpdate.text=從源自動更新
action.Documentation.ToggleAutoUpdate.description=選擇變更時自動刷新文檔
action.DumpInvalidTipsOfTheDay.text=轉儲無效的每日小技巧
action.CheckSuggestedPlugins.text=檢查建議的套件
group.UpdateEventsSchemeAction.text=更新事件方案
action.AnalyzeHeapDumpSnapshot.text=分析堆轉儲
action.Debugger.FocusOnFinish.text=完成後聚焦
action.Debugger.FocusOnFinish.description=預設情況下，在調試會話結束時聚焦此檢視
action.EnableMetalRendering.text=Metal 呈現流水線
group.Graph.AlignNodesGroup.text=對齊
group.Graph.DistributeNodesGroup.text=分散排列
action.Graph.AlignNodes.Top.text=頂部
action.Graph.AlignNodes.Middle.text=居中排列
action.Graph.AlignNodes.Bottom.text=底部
action.Graph.AlignNodes.Left.text=左
action.Graph.AlignNodes.Center.text=中心
action.Graph.AlignNodes.Right.text=右
action.Graph.DistributeNodes.Horizontally.text=水平排列
action.Graph.DistributeNodes.Vertically.text=垂直排列
action.GotoDeclarationOnly.MainMenu.text=宣告
action.FileChooser.ShowHidden.text=顯示隱藏的檔案和目錄
action.FileChooser.ShowHidden.description=顯示隱藏的檔案和目錄
action.RunWithDropDown.text=通過選項執行
action.StopWithDropDown.text=通過選項停止
action.ReverteOverrideFileTypeAction.text=還原檔案類型覆蓋
action.ReverteOverrideFileTypeAction.description=撤消“覆蓋檔案類型”操作並恢復舊檔案類型
action.ReverteOverrideFileTypeAction.verbose.description=撤消“覆蓋檔案類型”操作並為檔案 ''{0}''{1,choice,0#|1# (和其他 {1} 個檔案)}恢復舊的檔案類型
action.VcsQuickActionsToolbarPopup.text=版本控制
action.SegmentedVcsControlAction.text=VCS 微件
action.SearchEverywhereNewToolbarAction.text=隨處搜尋
action.Vcs.CopyCommitSubjectAction.text=複製提交主題
action.Vcs.CopyCommitSubjectAction.description=將所選提交的主題複製到剪貼簿
action.CollapsiblePanel-toggle.text=展開/摺疊可折疊面板
action.FileChooser.TogglePathBar.text=顯示/隱藏路徑輸入欄位
action.FileChooser.TogglePathBar.description=切換路徑輸入欄位的可見性
action.LibraryUsageStatistics.text=顯示匯入的庫用法資訊
action.DumpLibraryUsageStatistics.text=轉儲庫用法的統計資訊
action.UiDslShowcaseAction.text=UI DSL 展示
action.ProgressIconShowcaseAction.text=進度圖標展示
action.TestCoroutineProgress.text=測試協同程序進度
action.SearchEverywhereToolbarHotKey.hotkey=Shift+Shift"
`;

exports[`src messages/DiffBundle.properties 1`] = `
"diff.application.usage.parameters.and.description=用法: {0} 差異 <left file> <right file> [<base file>]
merge.application.usage.parameters.and.description=用法: {0} 合併 <left file> <right file> [<base file>] <output file>

cannot.find.file.error=找不到檔案: {0}
cannot.create.file.error=無法創建檔案: {0}

dialog.title.diff.for.range=範圍的差異
diff.content.title.up.to.date=基本修訂
diff.content.title.current.range=當前

refresh.failed.message=刷新失敗: {0}

rollback.change.command.name=回滾變更
diff.content.editor.content.title=編輯器
diff.content.clipboard.content.title=來自剪貼簿
diff.clipboard.vs.editor.dialog.title=剪貼簿與編輯器
diff.content.selection.from.file.content.title={0}中的選區

diff.files.generic.request.title=變更
diff.element.qualified.name.vs.element.qualified.name.dialog.title={0} 與 {1}
merge.files.dialog.title=合併
diff.files.dialog.title=差異
diff.count.differences.status.text={0, choice, 0#沒有|1#1個|2#{0, number}個}差異
merge.differences.status.text={0, choice, 0#沒有變更|1#1 個變更|2#{0, number} 個變更}。{1, choice, 0#沒有衝突|1#1 個衝突|2#{1, number} 個衝突}。
diff.inactive.count.differences.status.text=({0} 非活動)
diff.all.differences.ignored.text=已忽略差異
diff.highlighting.disabled.text=差異高亮顯示處於關閉狀態
error.cant.show.diff.message=錯誤: 無法顯示差異
select.external.diff.program.dialog.title=選擇外部差異程序
select.external.merge.program.dialog.title=選擇外部合併程序
diff.cant.calculate.diff=無法計算差異
diff.contents.are.identical.message.text=內容相同
error.files.too.large.to.compare.text=檔案太大，無法比較
diff.contents.have.differences.only.in.line.separators.message.text=內容僅在行分隔符中有差異
diff.contents.have.differences.only.in.charset.message.text=內容僅在編碼中有差異
diff.contents.have.differences.only.in.charset.and.line.separators.message.text=內容僅在行分隔符和編碼中有差異
binary.diff.contents.are.identical.message.text=檔案內容相同
binary.diff.contents.are.different.message.text=檔案內容不同
action.presentation.diff.accept.text=接受
action.presentation.diff.revert.text=還原
action.presentation.diff.append.text=追加
action.presentation.diff.include.into.commit.text=包含到提交中
action.presentation.diff.append.to.the.side.text=追加到 {0, choice, 0#左側|1#右側}
action.presentation.merge.ignore.text=忽略
action.presentation.merge.resolve.text=解決
action.presentation.merge.resolve.using.side.text=使用{0, choice, 0#左側|1#右側} 解決
action.presentation.merge.resolve.automatically.text=自動解決
merge.dialog.all.conflicts.resolved.message.text=已解決所有衝突
merge.dialog.accept.change.command=接受變更
merge.dialog.ignore.change.command=忽略變更
merge.dialog.resolve.conflict.command=解決衝突
merge.dialog.apply.non.conflicted.changes.command=套用不衝突的變更
cancel.visual.merge.dialog.title=取消檔案合併
apply.somehow.status.message.all.applied=已解決所有區塊
apply.somehow.status.message.already.applied={0, number} 個{0, choice, 1#區塊|2#區塊}已套用
apply.somehow.status.message.cant.apply=無法套用 {0, number} 個{0, choice, 1#區塊|2#區塊}
apply.somehow.status.message.cant.apply.some=無法套用 {0, number} 個區塊，共 {1, number} 個
merge.dialog.apply.partially.resolved.changes.confirmation.message={0, choice, 0#'{1, choice, 1#有|2#有}'|1#有|2#有} {0, choice, 0#|1#1 個更改|2#{0, number} 個更改}{0, choice, 0#|1#'{1, choice, 0#|1#和 }'}{1, choice, 0#|1#1 個衝突|2#{1, number} 個衝突}未處理。\\\\n仍要儲存更改並將衝突標記為解決嗎?
apply.patch.partially.resolved.changes.confirmation.message={0, choice, 1#1 個區塊|2#{0, number} 個區塊}未處理。\\\\n要儲存更改並完成解決嗎?
apply.partially.resolved.merge.dialog.title=套用變更
merge.all.changes.processed.message.text=所有變更均已被處理。<br><a href=\\"\\">儲存變更並完成合併</a>
apply.patch.all.changes.processed.message.text=所有區塊均已被處理。<br><a href=\\"\\">儲存變更並完成解決</a>
merge.save.and.finish.button=儲存並完成(&F)
merge.continue.button=繼續(&C)
merge.color.options.background.color.label=重要
merge.color.options.ignored.color.label=已忽略
merge.color.options.dialog.title=合併顏色選項
diff.type.inserted.name=已插入
diff.type.changed.name=已更改
diff.type.deleted.name=已刪除
diff.type.conflict.name=衝突
diff.content.selected.value=所選值
diff.clipboard.vs.value.dialog.title=剪貼簿與所選值

merge.window.title.file=合併 {0}
merge.version.title.our=您的版本
merge.version.title.their=來自伺服器的變更
merge.version.title.their.with.revision=來自伺服器的變更 (修訂版 {0})
merge.version.title.base=基礎版本
merge.version.title.merged=合併版本
merge.version.title.merged.result=結果
merge.version.title.current=當前版本:
diff.version.title.before=之前
diff.version.title.after=之後
configurable.DiffSettingsConfigurable.display.name=差異與合併
configurable.ExternalDiffSettingsConfigurable.display.name=外部差異工具
settings.diff.name=差異
settings.context.lines=上下文行:
settings.go.to.the.next.file.after.reaching.last.change=到達上次更改後轉到下一個檔案
settings.merge.text=合併
settings.automatically.apply.non.conflicting.changes=自動套用不衝突的變更
settings.highlight.modified.lines.in.gutter=在間距中高亮顯示修改的行
settings.external.diff.enable.external.diff.tool=啟用外部差異工具
settings.external.diff.path.to.executable=\\\\ 可執行檔案路徑:
settings.external.diff.parameters=參數:
settings.external.diff.use.by.default=預設情況下使用
settings.external.diff.test.diff=測試差異
settings.external.diff.test.three.side.diff=測試三向差異
settings.external.diff.enable.external.merge.tool=啟用外部合併工具
settings.external.diff.path.to.executable.merge=\\\\ 可執行檔案路徑:
settings.external.diff.parameters.merge=參數:
settings.external.diff.trust.process.exit.code=信任進程退出程式碼
settings.external.diff.test.merge=測試合併
settings.diff.tools.parameters=<html>不同的工具具有不同的參數。以正確順序指定所有必要的參數至關重要<br><b>%1</b> - 左側 (本地變更)<br><b>%2</b> - 右側 (伺服器內容)<br><b>%3</b> - 基礎 (當前版本，無本地變更)<br><b>%4</b> - 輸出 (合併結果)</html>
settings.external.diff.left.file.content=左側檔案內容
settings.external.diff.right.file.content=右側檔案內容
settings.external.diff.base.file.content=基檔案內容
settings.external.diff.original.output.file.content=原始輸出檔案內容
settings.external.diff.merge.conflict.resolve.was.canceled=合併衝突解決已取消。
settings.external.diff.merge.conflict.resolve.successful=合併衝突解決成功。\\\\n已解決的內容為:\\\\n{0}
settings.external.diff.test.complete=測試完成
error.cannot.show.diff=無法顯示差異
error.cannot.show.merge=無法顯示合併
error.message.cannot.show.diff=無法顯示差異
error.message.cannot.show.merge=無法顯示合併
label.cant.show.diff.with.description=無法顯示差異: {0}
label.cant.show.merge.with.description=無法顯示合併: {0}
action.Anonymous.text.apply.non.conflicting.changes=套用不衝突的變更:
action.presentation.RefreshDirDiffAction.text=刷新
continue.merge=繼續合併
discard.changes.and.restart.merge=放棄更改並重新啟動合併
update.highlighting.settings=更新高亮顯示設定
changing.highlighting.requires.the.file.merge.restart=更改高亮顯示需要重新啟動檔案合併。是否放棄未儲存的變更並重新啟動合併?
apply.changes.and.mark.resolved=套用更改並標記為已解決
synchronize.editors.settings=同步編輯器設定
directory.viewer=目錄查看器
side.by.side.viewer=並排查看器
compare.by=比較依據:
hide.this.notification=隱藏此通知
error.viewer=錯誤查看器
directory.diff=目錄差異
use.space.button.to.change.operation=使用空格按鈕更改操作
use.space.button.or.mouse.click=使用空格按鈕或滑鼠點擊來更改選定元素的操作。按回車鍵執行。
can.t.copy.file=無法複製檔案
copy.content.to.side=將內容複製到{0, choice, 0#左側|1#右側}
merge.conflict.is.outdated=合併衝突已過時。在衝突解決開始之前恢復檔案內容?
binary.file.viewer=二進制檔案查看器
highlighting.level=高亮顯示級別
editor.settings=設定
highlight.words=高亮顯示單詞
synchronize.document.and.its.fragment=同步文檔及其片段
synchronize.document.and.its.fragment.range.error=選擇範圍無效
vcs.marker.changed.line=VCS 標記: 更改的行
do.not.ask.me.again=不再詢問
delete.0.items=刪除 {0} 項?
confirm.delete=確認刪除
data.has.been.changed.externally.reloading.data=資料已在外部更改。正在重新載入資料…
select.file.to.compare=選擇要比較的檔案
diff.actions=差異操作
can.t.show.diff.in.external.tool=無法在外部工具中顯示差異
can.t.finish.merge.resolve=無法完成合併解析
disable.editing=禁用編輯
collapse.unchanged.fragments=摺疊未更改的片段
synchronize.scrolling=同步滾動
compare.selected.new.files=將左側和右側的所選新檔案相互比較。
compare.0.with.1=比較 ''{0}'' 和 ''{1}''
unified.viewer=統合查看器
mark.as.resolved=標記為已解決
merge.in.external.tool=在外部工具中合併
press.mark.as.resolve=在外部工具中解決完衝突時，按“標記為已解決”
launching.external.tool=正在啟動外部工具…
waiting.for.external.tool=正在等待外部工具…
can.t.load.some.changes=無法載入某些變更
directory.diff.actions=目錄差異操作
can.t.show.merge.in.external.tool=無法在外部工具中顯示合併
file.is.too.big.and.there.are.too.many.changes=檔案太大且變更太多。
dirdiff.mode.size.and.timestamp=大小和時間戳
dirdiff.mode.size=大小
dirdiff.mode.text=文本
dirdiff.mode.binary.content=二進制內容
button.dirdiff.filter=過濾(&F):
option.inherit.ignored.color=繼承忽略的顏色
error.content.decoded.with.wrong.charset=內容解碼出錯(使用 ''{0}'' 字符集)
label.default.diff.editor.tab.name=差異
diff.file.editor.name=差異
filetype.diff.description=差異
message.init.merge.content.command=初始化合併內容
message.replace.change.command=取代變更
message.resolve.simple.conflicts.command=解決簡單的衝突變更
message.use.selected.changes.command={0}所選變更
message.do.in.merge.command=合併時 {0}
action.presentation.go.to.change.text=轉到變更
button.continue.merge=繼續合併
button.cancel.merge=取消合併
button.discard.changes.and.do=放棄變更並{0}
label.merge.unsaved.changes.discard.and.do.anyway=結果檔案中有未儲存的變更。放棄變更並繼續{0}嗎?
button.merge.resolve.apply=套用
button.merge.resolve.accept.right=接受右側
button.merge.resolve.accept.left=接受左側
button.merge.resolve.cancel=取消
tooltip.merge.ctrl.click.to.resolve.conflict=Ctrl+點擊來解決衝突
error.operation.canceled=操作已被取消
error.cant.show.diff.for.unknown.file=無法顯示未知檔案類型的差異
error.cant.show.diff.file.not.found=無法顯示差異: 找不到檔案
error.cant.show.diff.content.not.found=無法顯示差異: 找不到內容
error.cant.show.diff.cant.load.revision.content=無法獲取此修訂中的內容
error.cant.show.diff.cant.show.for.directory=無法顯示目錄的差異
error.cant.show.merge.operation.not.supported=無法顯示合併衝突: 此操作不受支援
error.cant.show.merge.project.not.found=無法顯示合併衝突: 未知專案類型
error.cant.show.merge.file.not.found=無法顯示合併衝突: 找不到檔案
error.cant.show.dirdiff.preview.cant.load.content=無法獲取內容
button.associate.file.type=關聯
button.reload.diff.request=重新載入
option.highlighting.level.inspections=檢查
option.highlighting.level.syntax=語法
option.highlighting.level.none=無
option.highlighting.policy.lines=高亮顯示行
option.highlighting.policy.words=高亮顯示單詞
option.highlighting.policy.split=高亮顯示拆分的變更
option.highlighting.policy.symbols=高亮顯示字符
option.highlighting.policy.none=不高亮顯示
option.ignore.policy.none=不忽略
option.ignore.policy.trim=修整空白
option.ignore.policy.whitespaces=忽略空格
option.ignore.policy.whitespaces.empty.lines=忽略空格和空行
option.ignore.policy.formatting=忽略格式化
option.three.side.color.policy.left.to.right=左到右
option.three.side.color.policy.merge.conflict=合併衝突
option.three.side.color.policy.merge.resolved=解決的合併衝突
notification.action.text.blank.diff.select.file=選擇檔案…
notification.action.text.blank.diff.recent=最近
editing.viewer.hint.enable.editing.text=此檢視為唯讀。<a href=\\"\\">啟用編輯</a>
column.dirdiff.name=名稱
column.dirdiff.size=大小
column.dirdiff.date=日期
label.dirdiff.loading.file=正在載入… {0}
configurable.diff.collapse.unchanged.ranges.disable=禁用
error.file.is.too.large.only.preview.is.loaded=檔案太大。僅載入預覽。
error.can.not.calculate.diff.operation.canceled=無法計算差異。操作已取消。
error.can.not.calculate.diff.file.too.big=無法計算差異。檔案太大且變更太多。
progress.title.loading.requests=正在載入請求
notification.status.content.removed=內容已移除
notification.status.content.added=內容已添加
button.hide.notification=隱藏
notification.you.can.disable.this.feature.in.0=您可以在 {0} 中禁用此功能
label.diff.settings.path=設定 | 工具 | 差異和合併
label.diff.settings.path.macos=偏好設定 | 工具 | 差異和合併
press.again.to.go.to.the.previous.file=再按一次轉到上一個檔案
press.again.to.go.to.the.next.file=再按一次轉到下一個檔案
error.cant.show.file=無法顯示檔案
error.conflict.is.not.valid.and.no.longer.can.be.resolved=衝突無效，無法再解決。
button.abort.resolve=中止解決
error.cant.resolve.conflicts.in.a.read.only.file=無法解決唯讀檔案中的衝突
action.merge.apply.non.conflicts.left.text=左側
action.merge.apply.non.conflicts.right.text=右側
action.merge.apply.non.conflicts.all.text=所有
diff.utf.charset.name.bom.suffix={0} BOM
blank.diff.recent.content.summary.text.date={0} ({1})
blank.diff.recent.content.summary.text.length.date={0} ({1} 字符，{2})
advanced.settings.vcs=版本控制
advanced.setting.show.diff.as.editor.tab=作為編輯器頁籤打開差異
advanced.setting.show.diff.as.editor.tab.description=如果啟用，請使用編輯器頁籤代替框架視窗來顯示差異
combined.side.by.side.viewer=拆分
combined.unified.viewer=統合
diff.files.count.files.in.text=在 {0} 中
diff.files.count.hyperlink.text={0} 個檔案
option.highlighting.policy.group.name=高亮顯示模式
option.ignore.policy.group.name=忽略變更
action.Combined.Diff.PrevChange.text=上一個檔案
action.Combined.Diff.NextChange.text=下一個檔案"
`;

exports[`src messages/GitBundle.properties 1`] = `
"git4idea.vcs.name=Git
git4idea.vcs.name.with.mnemonic=Git(_G)
activity.name.rebase=變基

abort=中止
abort.operation.progress.title=正在中止 {0} 進程
abort.operation.dialog.title=中止 {0}
abort.operation.dialog.msg=中止 {0}{1}?
abort.operation.failed={0} 中止失敗
abort.operation.succeeded={0} 中止成功
abort.operation.merge.name=合併
abort.operation.cherry.pick.name=優選
abort.operation.revert.name=還原
abort.operation.indicator.text=git {0} --abort{1}

add.adding=正在添加檔案…

annotate.cannot.annotate.dir=無法註解目錄
annotate.output.lack.data=第 {0} 行的輸出缺少必要的資料
annotate.line.mismatch.exception=正在為第 {0} 行添加資訊，但應當為第 {1} 行添加資訊

apply.changes.would.be.overwritten=您的本地變更將被 {0} 覆蓋。\\\\n\\\\
提交您的變更，或儲藏變更以繼續。
apply.changes.operation.successful={0}成功
apply.changes.nothing.to.do=沒要有{0}的內容
apply.changes.resolving.conflicts.progress.title=正在解決衝突…
apply.changes.applied.for.commits={0} {1,choice,1#項提交|2#{1,number} 項提交} 來自於 {2}
apply.changes.operation.canceled={0} 已取消
apply.changes.operation.failed={0} 失敗
apply.changes.operation.performed.with.conflicts={0}已執行，但存在衝突
apply.changes.operation.successful.for.commits=但是，對以下{1, choice,1#提交|2#提交}成功進行了{0}:
apply.changes.skipped={0} {1,choice,1#被|2#被}跳過，因為所有變更已被{2}。
apply.changes.everything.applied={0} 中的所有變更已被{1}

apply.conflict.dialog.description.label.text=在由 {2} 執行的提交 {1} 的{0}過程中發生衝突{3}

blob.not.found=找不到 Blob: {0} - {1}

changes.retrieving=檢索修訂 {0} 的變更

commit.action.commit.and.rebase.text=提交並變基…
commit.action.name=提交 (&I)
commit.author.diffs=<html>作者與預設不同</html>
commit.author=作者(&A):
commit.partial.merge.message=不允許在{0,choice,1#合併|2#優選}期間進行部分提交。\\\\n\\\\
提交中未包含以下檔案。\\\\n\\\\
要在包含所有檔案的情況下執行提交嗎?
commit.partial.merge.title=部分合併提交
common.current.branch.tooltip=當前已簽出的分支。
common.current.branch=當前分支:
common.git.root.tooltip=選擇 Git VCS 根
common.git.root=Git 根(&R):
common.no.active.branch=<無活動分支>
common.refreshing=正在刷新檔案
common.suffix.in.one.repository=在 {0} 中
common.suffix.in.several.repositories=在 {0} 個版本庫中

conflict.resolver.unmerged.files.check.error.notification.description.text=由於錯誤，無法檢查工作樹中是否有未合併的檔案。{0}

login.dialog.label.login.to.url=登錄 {0}
login.dialog.button.login=登錄
login.dialog.prompt.enter.credentials=輸入憑證:
login.dialog.select.login.way.credentials=輸入憑證
login.dialog.select.login.way.use.helper=使用憑證幫助程序
login.dialog.username.label=用戶名：
login.dialog.password.label=密碼:
login.dialog.error.username.cant.be.empty=用戶名不能為空
login.dialog.error.password.cant.be.empty=密碼不能為空
login.dialog.login.with.selected.provider=使用 {0} 登錄…

computing.annotation=正在計算 {0} 的註解
diff.find.error=正在尋找差異的修訂: {0}
error.dialog.title=錯誤
error.list.title={0} 錯誤:
error.occurred.during=''{0}'' 時出錯
errors.message.item=\\\\n\\\\
   {0}
errors.message=Git 操作以多個錯誤結束: {0}

# suppress inspection \\"UnusedProperty\\": used by 3-party plugins
fetch.action.name=獲取
fetch.pruned.obsolete.remote.references=刪除過時的遠端 {0,choice,1#引用|2#引用}: {1}

# suppress inspection \\"UnusedProperty\\": used by 3-party plugins
find.git.error.title=執行 Git 時出錯
# suppress inspection \\"UnusedProperty\\": used by 3-party plugins
find.git.success.title=Git 執行成功
# suppress inspection \\"UnusedProperty\\": used by 3-party plugins
find.git.unsupported.message=<html><tt>{0}</tt><br>此版本不受支援，某些套件功能可能無法工作。<br>支援的最低版本是 <em>{1}</em>。</html>

local.changes.freeze.message.git.operation.prefix=Git {0}
git.error.exit=Git 進程退出，程式碼為 {0}
git.running=執行: {0}

init.destination.directory.description=選擇將在其中創建新 Git 版本庫的目錄。
init.destination.directory.title=創建 Git 版本庫
init.warning.already.under.git=所選目錄 <tt>{0}</tt> 已在 Git 下。\\\\n\\\\
確定要創建新的 VCS 根嗎?
init.warning.title=Git Init
initializing.title=正在初始化版本庫…

mention.in=\\\\ ({0} 內)

merge.action.name=合併
merge.action.operation.failed=Git {0} 失敗
merge.action.before.update.label=更新前
merge.action.after.update.label=更新後
merge.branch.title=合併變更
merge.branch.into.current.title=合併到 {0}
merge.branch.loading.branches.progress=正在載入未合併的分支...
merge.no.branch.selected.error=應選擇該合併分支。
merge.no.matching.branch.error=沒有符合分支。
merge.commit.message.label=提交訊息:
merge.options.modify=修改選項
merge.options.modify.popup.title=添加合併選項
merge.option.no.ff=即使可以快進也創建合併提交
merge.option.ff.only=僅在可以快進時合併
merge.option.squash=為所有合併變更創建一個提交
merge.option.msg=指定合併提交的訊息
merge.option.no.commit=不提交合併結果
merge.option.no.verify=繞過預合併和提交訊息掛鈎
merge.branch.popup.empty.text=無分支
merge.branch.field.placeholder=指定分支
merge.tool.column.status.deleted=已刪除
merge.tool.column.status.modified=已修改
merge.tool.column.theirs.status=他人的變更
merge.tool.column.theirs.with.branch.status=他人的變更({0})
merge.tool.column.yours.status=您的變更
merge.tool.column.yours.with.branch.status=您的變更({0})
merging.title=將變更合併到 {0}
paths.affected.title=提交 {0} 中受影響的路徑
pull.action.name=拉取
pull.button=拉取
pulling.title=從 {0} 中拉取變更
pull.branch.not.selected.error=應選擇要從中拉取的分支。
pull.branch.nothing.to.pull=無分支
pull.branch.no.matching.remotes=無遠端
pull.branch.field.placeholder=指定分支
pull.options.modify.popup.title=添加拉取選項
pull.option.ff.only=僅在可以快進時合併
pull.option.no.ff=即使可以快進也創建合併提交
pull.option.squash.commit=為所有拉取變更創建一個提交
pull.option.no.commit=合併，但不提交結果
pull.option.rebase=在當前分支的頂部變基傳入變更

pull.dialog.title=拉取
pull.dialog.with.branch.title=拉取到 {0}
pull.dialog.fetch.shortcuts.hint=按 {0} 更新分支

operation.action.message=多個 Git 根有未完成的 {0} 進程，請選擇要對其執行操作的根。

rebase.abort.and.rollback.dialog.message=僅中止 {0} 中的變基還是同時回滾 {1} 中的變基?
rebase.abort.and.rollback.dialog.no.button.text=僅中止
rebase.abort.and.rollback.dialog.yes.button.text=中止並回滾
rebase.abort.dialog.message=中止{0} 中的變基?
rebase.abort.dialog.ok.button.text=中止
rebase.abort.dialog.title=中止變基
rebase.abort.notification.failed.title=中止變基失敗
rebase.abort.notification.successful.message=中止變基成功
rebase.abort.notification.warning.rollback.failed.message={0}中的回滾失敗:{1}{2}
rebase.abort.notification.warning.rollback.failed.title=變基回滾失敗
rebase.abort.notification.warning.rollback.failed.with.repo.message=成功中止 {0} 中的變基，但 {1}:{2}{3} 中的回滾失敗
rebase.abort.progress.indicator.command.in.repo.title={0} ({1} 內)
rebase.abort.rollback.successful.rebase.dialog.message=要回滾 {0} 中成功的變基嗎?
rebase.abort.rollback.successful.rebase.dialog.ok.button.text=回滾
rebase.confirmation.dialog.published.commits.button.cancel.text=取消
rebase.confirmation.dialog.published.commits.button.rebase.text=仍然變基
rebase.confirmation.dialog.published.commits.message.first=您正在嘗試變基一些已推送到受保護分支的提交。
rebase.confirmation.dialog.published.commits.message.second=對它們進行變基將導致重複提交，不建議這樣做，並且很可能不必這樣做。
rebase.confirmation.dialog.published.commits.title=變基已發佈的提交
rebase.conflict.diff.dialog.left.title=正在從 {1} 變基 {0}
rebase.conflict.diff.dialog.right.simple.title=已變基的提交
rebase.conflict.diff.dialog.right.with.branch.title=已變基的提交和來自 {0} 的提交
rebase.couldnt.resolve.file=無法解決 {0}
rebase.dialog.error.upstream.not.selected=選擇上游
rebase.dialog.error.base.not.selected=選擇新基
rebase.dialog.error.branch.or.tag.not.exist=沒有這樣的分支或標記
rebase.dialog.error.branch.not.selected=選擇要切換到的分支
rebase.dialog.error.branch.invalid=分支 ''{0}'' 不存在
rebase.dialog.error.rebase.in.progress=此 Git 根目錄已經在進行交互式變基
rebase.dialog.root.invalid.label.text=(無效)
rebase.dialog.progress.loading.tags=正在載入標記…
rebase.dialog.help=顯示 Git 變基幫助
rebase.dialog.start.rebase=變基
rebase.dialog.title=變基
rebase.dialog.target=分支或哈希
rebase.dialog.new.base=新基礎(分支或哈希)
rebase.dialog.old.base=原基礎(分支或哈希)
rebase.dialog.branch.field=源分支
rebase.options.modify.dialog.title=添加變基選項
rebase.option.onto=為變基的提交指定新基
rebase.option.interactive=在變基之前編輯提交
rebase.option.rebase.merges=重新創建提交拓撲
rebase.option.switch.to.branch=選擇另一個要變基的分支
rebase.option.keep.empty=變基期間不移除空提交
rebase.option.root=變基分支中的所有提交
rebase.help.popup.ad.text=按空格打開外部鏈接
rebase.help.rebase.branch=將基於一個分支的分支變基到另一個分支:
rebase.help.link=git-scm.com 上的 git 變基
rebase.entry.action.name.drop=刪除
rebase.entry.action.name.edit=編輯
rebase.entry.action.name.fixup=Fixup
rebase.entry.action.name.pick=選取
rebase.entry.action.name.reword=改寫
rebase.entry.action.name.squash=壓縮
rebase.entry.action.name.unknown=未知
rebase.git.operation.name=變基
rebase.interactive.dialog.discard.modifications.cancel=取消變基
rebase.interactive.dialog.discard.modifications.continue=繼續變基
rebase.interactive.dialog.discard.modifications.discard=捨棄
rebase.interactive.dialog.discard.modifications.message=放棄變更並取消變基?
rebase.interactive.dialog.git.commands.column.action=操作
rebase.interactive.dialog.git.commands.column.hash=哈希
rebase.interactive.dialog.git.commands.column.subject=主題
rebase.interactive.dialog.git.commands=Git 命令
rebase.interactive.dialog.reset.link.text=重置
rebase.interactive.dialog.reword.hint.text=按 {0} 套用變更
rebase.interactive.dialog.start.rebase=啟動變基
rebase.interactive.dialog.stop.to.edit.text=停止以編輯
rebase.interactive.dialog.title=正在變基提交
rebase.interactive.dialog.view.git.commands.text=查看 Git 命令
rebase.interactive.edit.commit.message.dialog.title=Git 提交訊息
rebase.interactive.edit.commit.message.ok.action.title=繼續變基
rebase.interactive.noop.dialog.text=由於當前分支直接位於基礎分支的正下方或它們指向同一個提交，因此沒有要變基的提交('noop' 情況)。\\\\n\\\\
 繼續嗎? (這會將當前分支重置為基礎分支)
rebase.interactive.noop.dialog.title=Git 變基
rebase.interactive.unstructured.editor.dialog.root.label=Git 根: {0}
rebase.log.action.operation.rebase.name=變基
rebase.log.action.operation.reword.name=改寫
rebase.log.commit.editing.action.commit.not.in.head.error.text=該提交不在當前分支中
rebase.log.commit.editing.action.commit.pushed.to.protected.branch.error.text=該提交已被推送到受保護分支 ''{0}''
rebase.log.commit.editing.action.disabled.parents.description=所選提交已{0}父項
rebase.log.multiple.commit.editing.action.disabled.external.repository.description=所選{0, choice, 1#提交|2#提交}{0, choice,1#|2#}來自外部版本庫
rebase.log.multiple.commit.editing.action.disabled.multiple.repository.description=所選{0, choice, 1#提交|2#提交}{0, choice,1#|2#}來自不同的版本庫
rebase.log.commit.editing.action.progress.containing.branches.title=正在搜尋包含所選提交的分支…
rebase.log.commit.editing.action.prohibit.state.grafting=優選期間不能{0}
rebase.log.commit.editing.action.prohibit.state.merging=合併期間不能{0}
rebase.log.commit.editing.action.prohibit.state.rebasing=變基期間不能{0}
rebase.log.commit.editing.action.prohibit.state.reverting=還原期間不能{0}
rebase.log.commit.editing.action.prohibit.state=不能{0}
rebase.log.undo.impossible.pushed.to.protected.branch.notification.text=來自當前分支的提交已被推送到受保護的分支 {0}
rebase.log.drop.action.custom.text=刪除{0,choice,1#提交|2#提交}
rebase.log.drop.action.failure.title=無法刪除提交
rebase.log.drop.progress.indicator.title=正在刪除{0, choice, 1#提交|2#提交}…
rebase.log.drop.success.notification.title=已刪除{0, choice, 1#提交|2#提交}
rebase.log.drop.undo.failed.title=撤消刪除失敗
rebase.log.drop.undo.impossible.title=無法撤消刪除
rebase.log.drop.undo.progress.title=正在撤消刪除…
rebase.log.multiple.commit.editing.action.cant.find.head=在包含選定{0,choice,1#提交|2#提交}的版本庫中找不到 HEAD 分支
rebase.log.multiple.commit.editing.action.progress.indicator.action.possibility.check=正在檢查是否允許編輯所選提交…
rebase.log.multiple.commit.editing.action.specific.commit.not.in.head=提交 {0} 不在當前分支中
rebase.log.multiple.commit.editing.action.specific.commit.root.or.merge=提交 {0} 有 {1} 個父項
rebase.log.create.fixup.commit.action.failure.title=無法創建 Fixup 提交
rebase.log.create.squash.commit.action.failure.title=無法創建壓縮提交
rebase.log.interactive.action.failure.title=無法啟動變基
rebase.log.reword.action.failure.title=無法編輯提交訊息
rebase.log.action.loading.commit.message.failed.message=無法載入{0,choice,1#提交|2#提交}的變更
rebase.log.reword.action.notification.successful.title=已更改提交訊息
rebase.log.reword.action.notification.undo.failed.title=撤消提交訊息編輯失敗
rebase.log.reword.action.notification.undo.not.allowed.repository.changed.message=版本庫已被更改
rebase.log.reword.action.notification.undo.not.allowed.title=無法撤消提交訊息編輯
rebase.log.action.progress.indicator.loading.commit.message.title=正在載入{0,choice,1#提交|2#提交}詳細資訊…
rebase.log.squash.action.failure.title=無法壓縮提交
rebase.log.squash.new.message.dialog.label=編輯已壓縮提交的訊息
rebase.log.squash.new.message.dialog.title=已壓縮提交訊息
rebase.log.squash.progress.indicator.title=正在壓縮…
rebase.log.squash.success.notification.title=提交已壓縮
rebase.log.squash.undo.failed.title=撤消壓縮失敗
rebase.log.squash.undo.impossible.title=無法撤消壓縮
rebase.log.squash.undo.progress.title=正在撤消壓縮…
rebase.log.reword.action.progress.indicator.title=正在改寫…
rebase.log.reword.action.progress.indicator.undo.title=正在撤消改寫…
rebase.log.reword.dialog.description.label=編輯由 {1} 執行的提交 {0} 的訊息
rebase.log.reword.dialog.failed.pushed.to.protected.message=無法編輯所選{0,choice,1#提交|2#提交}: 提交 {1} 已被推送至受保護分支 ''{2}''
rebase.log.reword.dialog.failed.repository.changed.message=無法編輯選定{0,choice,1#提交|2#提交}: 版本庫狀態已被更改
rebase.log.reword.dialog.title=編輯提交訊息
rebase.notification.action.abort.text=中止
rebase.notification.action.continue.text=繼續
rebase.notification.action.retry.text=重試
rebase.notification.action.view.shelf.text=查看擱置…
rebase.notification.action.view.stash.text=查看儲藏…
rebase.notification.conflict.title=由於衝突，變基停止
rebase.notification.editing.title=變基已停止，可以進行編輯
rebase.notification.failed.continue.title=繼續變基失敗
rebase.notification.failed.rebase.title=變基失敗
rebase.notification.failed.shelf.text=無法擱置本地未提交的變更:
rebase.notification.failed.stash.text=無法儲藏本地未提交的變更:
rebase.notification.no.rebase.in.progress.abort.title=無法中止變基
rebase.notification.no.rebase.in.progress.continue.title=無法繼續變基
rebase.notification.no.rebase.in.progress.message=沒有正在進行的變基
rebase.notification.not.allowed.detached.message.first=您在 {0} 中處於游離的 HEAD 狀態。
rebase.notification.not.allowed.detached.message.second=無法變基。
rebase.notification.not.allowed.empty.repository.message=版本庫 {0} 為空。
rebase.notification.not.allowed.grafting.message.first={0} 中有一個未完成的優選進程。
rebase.notification.not.allowed.grafting.message.second=在開始變基前，應先完成這項操作。
rebase.notification.not.allowed.merging.message.first={0} 中有一個未完成的合併進程。
rebase.notification.not.allowed.merging.message.second=在開始變基前，應先完成合併。
rebase.notification.not.allowed.message=無法在 {0} 中進行變基。
rebase.notification.not.allowed.rebasing.message.first={0} 中有一個未完成的變基進程。
rebase.notification.not.allowed.rebasing.message.second=在開始另一個變基前，應先完成這項操作。
rebase.notification.not.allowed.reverting.message.first={0} 中有一個未完成的還原進程。
rebase.notification.not.allowed.reverting.message.second=在開始變基前，應先完成這項操作。
rebase.notification.not.allowed.title=不允許變基
rebase.notification.not.started.title=變基未啟動
rebase.notification.saved.local.changes.part.shelf.text=變基前已擱置本地變更。
rebase.notification.saved.local.changes.part.stash.text=變基前已儲藏本地變更。
rebase.notification.successful.rebased.checkout.message=已簽出{0,choice,0#|1# {1} }並將其變基{2,choice,0#|1#到 {3}}
rebase.notification.successful.rebased.message=已{0,choice,0#|1#將 {1} }變基{2,choice,0#|1#到 {3}}
rebase.notification.successful.title=變基成功
rebase.notification.all.conflicts.resolved.title=解決衝突
rebase.notification.all.conflicts.resolved.text=所有衝突都已解決。要繼續變基嗎?
rebase.notification.all.conflicts.resolved.continue.rebase.action.text=繼續變基(&T)
rebase.progress.indicator.aborting.title=正在中止變基進程…
rebase.progress.indicator.conflicts.collecting.title=正在收集要解決的衝突…
rebase.progress.indicator.continue.title=正在繼續變基進程…
rebase.progress.indicator.preparing.title=正在準備變基…
rebase.progress.indicator.retry.title=正在重試變基進程…
rebase.progress.indicator.title=正在變基…
rebase.simple.editor.dialog.title=Git 編輯器
rebase.update.project.abort.task.title=正在中止變基…
rebase.update.project.conflict.error.notification.description=然後，您可以<b>繼續變基</b>。<br/>您也可以<b>中止變基</b>以恢復原始分支並停止變基。
rebase.update.project.conflict.error.notification.title=無法繼續變基
rebase.update.project.conflict.merge.description.label=檢測到合併衝突。請先解決這些衝突，然後再繼續變基。
rebase.update.project.notification.abort.cancel.message=已取消中止變基
rebase.update.project.notification.abort.error.message=中止變基時出錯
rebase.update.project.notification.abort.success.message=已中止變基
rebase.update.project.notification.failed.message=無法繼續變基。{0}
rebase.update.project.notification.failed.title=變基錯誤
rebase.using.log.couldnt.start.error=由於 IDE 生成的 'git-rebase-todo' 檔案無效，因此無法執行變基。要使用 Git 原生檔案生成來重試變基嗎?
merge.update.project.generic.error.title=無法完成更新
merge.update.project.conflict.merge.description.label=檢測到合併衝突。請先解決這些衝突，然後再繼續更新。

remove.removing=正在移除檔案…
repository.action.missing.roots.misconfigured=配置的 Git 根都不在 Git 下。配置的目錄中必須包含“.git”目錄。
repository.action.missing.roots.title=沒有 Git 根
repository.action.missing.roots.unconfigured.message=沒有為專案配置 Git 根。
repository.not.found.error=找不到 {0} 的已配置 git 版本庫
reset.action.name=重置 Head…
reset.commit.invalid=指定的提交表達式未通過驗證。
reset.commit.label=為提交(&C):
reset.commit.tooltip=由於重置操作而將成為當前 HEAD 的提交。
reset.title=重置 Head
reset.type.tooltip=<html>重置類型(另請參閱 <code>git reset</code> man 頁面):<ul><li><b>Mixed</b> 將重置索引，但不會重置工作樹</li><li><b>Soft</b> 將保留索引和工作樹，只是移動 HEAD 指針</li><li><b>Hard</b> 將重置索引和工作樹。<em>工作樹中的變更會丟失</em></li></ul></html>
reset.type=重置類型(&T):
reset.validate=驗證(&V)
resetting.title=正在重置 HEAD…
restore.conflict.dialog.description.label.text=在 {0} 之前儲存的未提交變更與 {1} 中的檔案衝突
restore.conflict.diff.dialog.left.shelf.title=擱置中的未提交變更
restore.conflict.diff.dialog.left.stash.title=儲藏中的未提交變更
restore.conflict.diff.dialog.right.title=來自 {0} 的變更
preserving.process.local.changes.not.restored.error.title=未恢復本地變更
restore.notification.failed.shelf.message=在更新之前，未提交的變更已儲存到<a href='saver'>擱置</a>。<br/>更新未完成，您的工作樹中有未解決的合併<br/>請解決衝突，完成更新並手動恢復變更。
restore.notification.failed.stash.message=在更新之前，未提交的變更已儲存到<a href='saver'>儲藏</a>。<br/>更新未完成，您的工作樹中有未解決的合併<br/>請解決衝突，完成更新並手動恢復變更。
restore.notification.failed.title=未恢復本地變更

revision.load.contents=載入修訂內容

reference.validating.progress.indicator.title=正在驗證修訂…

save.load.conflict.dialog.diff.left.title=您未提交的變更
save.load.conflict.dialog.diff.right.title=遠端變更
save.notification.failed.shelf.text=試圖在 {0} 之前在擱置中儲存未提交的變更，但失敗並出現錯誤。<br/>{1}
save.notification.failed.stash.text=試圖在{0}之前在儲藏中儲存未提交的變更，但失敗並出現錯誤。<br/>{1}
save.notification.failed.title=無法儲存未提交的變更

smart.operation.dialog.north.panel.label.shelf.text=<html>您對以下檔案的本地變更將被{0}覆蓋。<br/>{1} 可以擱置這些變更，{0}，並在之後取消擱置。</html>
smart.operation.dialog.north.panel.label.stash.text=<html>您對以下檔案的本地變更將被{0}覆蓋。<br/>{1} 可以儲藏這些變更，{0}，並在之後取消儲藏。</html>
smart.operation.dialog.ok.action.shelf.description=擱置本地變更，{0}，取消擱置
smart.operation.dialog.ok.action.stash.description=儲藏本地變更，{0}，取消儲藏
smart.operation.dialog.operation.name.and.overwrite.local.changes={0}並覆蓋本地變更
smart.operation.dialog.git.operation.name.problem=Git {0} 問題
smart.operation.dialog.smart.operation.name=智能{0}
smart.operation.dialog.don.t.operation.name=不{0}
ssh.ask.passphrase.title=SSH 密鑰密碼短語
ssh.ask.passphrase.message=SSH 密鑰“{0}”的密碼:
ssh.keyboard.interactive.title=SSH 鍵盤交互式
ssh.password.message=使用者 {0} 的密碼:
ssh.password.title=SSH 密碼登錄

stash.action.name=儲藏
stash.button=創建儲藏
stash.error.can.not.stash.changes.now=現在無法儲藏變更
stash.keep.index.tooltip=如果選中此復選框，已建立索引的變更將保留在索引中。
stash.keep.index=保留索引(&I)
stash.message.tooltip=在此處輸入儲藏訊息。
stash.message=訊息(&M):
stash.progress.indicator.title=正在儲藏來自 ''{0}'' 的變更…
stash.title=儲藏
stash.unstash.conflict.dialog.description.label.text=更新前儲藏的未提交變更與更新後的檔案衝突。
stash.unstash.progress.indicator.title=正在消除對 ''{0}'' 的變更…
stash.unstash.unresolved.conflict.warning.notification.message=您的未提交變更已儲存到<a href='saver'>儲藏</a>。<br/>取消儲藏未完成，您的工作樹中有未解決的合併<br/>請<a href='resolve'>解決</a>衝突並刪除儲藏。
stash.unstash.unresolved.conflict.warning.notification.title=本地變更已恢復，但存在衝突
stash.error=無法儲藏 {0}
# suppress inspection \\"UnusedProperty\\" - used in third-party plugins
stashing.title=正在儲藏變更…
stashing.progress.title=正在儲藏變更…
stash.editor.diff.preview.empty.title=儲藏

stash.tab.name=儲藏
stash.empty.text=找不到儲藏
action.Git.Stash.Pop.text=彈出
action.Git.Stash.Pop.description=彈出所選儲藏
action.Git.Stash.Apply.text=套用
action.Git.Stash.Apply.description=套用所選儲藏
action.Git.Stash.UnstashAs.text=取消儲藏…
action.Git.Stash.UnstashAs.description=彈出或套用選定的儲藏作為新分支(帶或不帶索引)
action.Git.Stash.Drop.text=刪除
action.Git.Stash.Drop.description=丟棄所選儲藏
action.Git.Show.Stash.text=顯示 Git 儲藏
action.Git.Show.Stash.description=顯示“Git 儲藏”工具視窗頁籤
action.Git.Stash.Refresh.text=刷新儲藏
action.Git.Stash.Refresh.description=刷新儲藏列表

stash.unstash.changes.in.root.dialog.title=取消儲藏 {0} 中的變更
stash.unstash.changes.current.branch.label=當前分支:

tag.action.name=標記
tag.button=創建標籤
tag.commit.label=提交(&C)
tag.commit.tooltip=輸入要標記的提交或物件的名稱，或留空以使用 HEAD。
tag.error.creating.message.file.message=無法創建訊息檔案: {0}
tag.error.invalid.commit=該提交或物件名稱無效。
tag.error.tag.exists=存在同名的標記。
tag.force.tooltip=強制創建標記，即使已存在另一個具有此名稱的標記。
tag.force=強制(&F)
tag.getting.existing.tags=正在獲取現有標記…
tag.message.label=訊息(&M):
tag.message.tooltip=如果訊息不為空，則創建帶註解的標記。
tag.name.label=標記名稱(&N):
tag.name.tooltip=在此處輸入新的標記名稱。
tag.title=標記
tag.validate.tooltip=點擊此按鈕驗證要標記的提交
tag.validate=驗證(&V)
tag.progress.title=正在添加標記…

unstash.action.name=取消儲藏
unstash.branch.label=作為新分支(&B):
unstash.branch.tooltip=如果輸入非空名稱，該儲藏將作為新分支簽出。
unstash.button.apply=套用儲藏
unstash.button.branch=分支
unstash.button.pop=消除儲藏
unstash.clear.tooltip=刪除版本庫中的所有儲藏。
unstash.clear=清除(&C)
unstash.clearing.stashes=正在清除儲藏…
unstash.drop.tooltip=刪除所選儲藏
unstash.drop=刪除(&D)
unstash.conflict.dialog.description.label.text=取消儲藏 {0} 時發生衝突
unstash.conflict.diff.dialog.left.title=本地變更
unstash.conflict.diff.dialog.right.title=來自儲藏的變更
unstash.dialog.remove.stash.progress.indicator.title=正在移除儲藏 {0}…
unstash.dialog.show.stashes.error.dialog.title=無法顯示儲藏列表
unstash.dialog.stash.list.load.progress.indicator.title=正在載入儲藏列表…
unstash.dialog.unresolved.conflict.warning.notification.message=取消儲藏未完成，您的工作樹中存在未解決的合併<br/>請<a href='resolve'>解決</a>衝突。
unstash.dialog.unresolved.conflict.warning.notification.title=取消儲藏期間未解決衝突
unstash.pop.stash.tooltip=如果選中，則該儲藏在套用後會被刪除。
unstash.pop.stash=消除儲藏(&P)
unstash.reinstate.index.tooltip=嘗試復原索引以及工作樹變更。
unstash.reinstate.index=復原索引(&I)
unstash.stashes=儲藏(&S):
unstash.title=取消儲藏變更
unstash.unstashing=正在取消儲藏…
unstash.view.tooltip=查看所選儲藏
unstash.view=查看(&V)
unstash.view.dialog.title=受 {0} 影響的路徑
unstash.error.can.not.unstash.changes.now=現在無法取消儲藏變更
unstash.unstashed.with.conflicts.error.title=已取消儲藏，但存在衝突

update.options.display.name=Git 更新設定
update.notification.update.error=無法更新
update.notification.choose.upstream.branch=選擇上游分支
update.skip.root.reason.no.tracked.branch=無跟踪分支
update.skip.root.reason.detached.head=游離的 HEAD

util.remote.renderer.none=無
vfs.listener.add.single.prompt=要將以下檔案添加到 Git 嗎?\\\\n\\\\
{0}\\\\n\\\\
\\\\n\\\\
如果您選擇“取消”，以後仍可以手動添加。
vfs.listener.add.single.title=將檔案添加到 Git
vfs.listener.add.title=將檔案添加到 Git
vfs.listener.checking.ignored=正在檢查忽略的檔案…
vfs.listener.delete.single.prompt=要從 Git 中刪除以下檔案嗎?\\\\n\\\\
{0}\\\\n\\\\
\\\\n\\\\
如果您選擇“取消”，以後仍可以手動刪除。
vfs.listener.delete.single.title=從 Git 中刪除檔案
vfs.listener.delete.title=從 Git 中刪除檔案

git.commit.message.empty=請指定提交訊息
git.commit.message.empty.title=提交訊息為空

git.executable.detect.progress.title=正在檢測 Git 可執行檔案
git.executable.version.progress.title=正在識別 Git 版本
git.executable.version.is=Git 版本為 {0}
git.executable.error.file.not.found=沒有此類檔案: {0}

git.executable.validation.error.start.title=無法執行 Git
git.executable.validation.error.version.title=Git 版本 {0} 不受支援
git.executable.validation.error.version.message=至少需要 {0}
git.executable.validation.error.wsl1.unsupported.message=不支持 WSL 版本 1，請參閱 <a href='https://youtrack.jetbrains.com/issue/IDEA-242469'>IDEA-242469</a>
git.executable.validation.error.xcode.title=接受 XCode/iOS 許可證以執行 Git
git.executable.validation.error.xcode.message=執行“sudo xcodebuild -license”並重試(需要管理員權限)
git.executable.validation.cant.identify.executable.message=無法識別 git 可執行檔案 {0} 的版本
git.executable.unknown.error.message=無法啟動 Git 進程: {0}
git.error.cant.process.output=無法處理 Git 輸出: {0}

git.executable.notification.title=無法啟動 Git
git.executable.notification.description=Git 可執行檔案的路徑可能無效。

executable.error.git.not.installed=未安裝 Git
executable.mac.fix.path.action=修正路徑
executable.mac.error.invalid.path.to.command.line.tools=Command Line Tools 的路徑無效

git.unstash.clear.confirmation.message=移除所有儲藏? 此操作無法撤消。
git.unstash.clear.confirmation.title=移除所有儲藏?
git.unstash.drop.confirmation.message=<html>要移除 {0} 嗎?<br/>“{1}”</html>
git.unstash.drop.confirmation.title=移除儲藏 {0}?
vcs.history.action.gitlog=在 Git 日誌中顯示

# suppress inspection \\"UnusedProperty\\": used by 3-party plugins

exportable.Git.Application.Settings.presentable.name=Git

git.add.to.exclude.file.action.text=.git/info/exclude
git.add.to.exclude.file.action.description=將條目添加到 .git/info/exclude
git.open.exclude.file.action.text=打開 .git/info/exclude
git.open.exclude.file.action.description=在編輯器中打開 .git/info/exclude

git.fetch.progress=正在獲取…

action.CopyPathFromRepositoryRootProvider.text=版本庫根路徑
action.git4idea.commands.TestGitHttpLoginDialogAction.text=測試 Git 登錄對話框
action.Git.Log.DeepCompare.text=無優選提交
action.Git.Log.DeepCompare.description=高亮顯示尚未優選到當前分支的提交
group.Git.ContextMenu.text=Git(_G)
group.Git.Menu.text=Git(_G)
group.Git.MainMenu.RebaseActions.text=變基(_R)
group.Git.MainMenu.MergeActions.text=合併(_M)
group.Git.MainMenu.LocalChanges.text=未提交的變更(_U)
action.Git.Rebase.Skip.text=跳過提交
action.Git.Rebase.Skip.progress.title=變基期間跳過提交…
action.Git.Rebase.Continue.text=繼續變基
action.Git.Revert.Abort.text=中止還原
action.Git.CherryPick.Abort.text=中止優選
action.Git.Merge.Abort.text=中止合併
action.Git.Rebase.Abort.text=中止變基
action.Git.Rebase.text=變基…
action.Git.Rebase.operation.name=變基
action.Git.Pull.text=拉取…
action.Git.Fetch.text=獲取
action.Git.Clone.text=克隆…
action.Git.Configure.Remotes.text=管理遠端…
action.Git.Reset.text=重置 HEAD…
action.Git.Unstash.text=取消儲藏變更…
action.Git.Stash.text=儲藏變更…
action.Git.Stash.Silently.text=靜默儲藏
action.Git.Merge.text=合併…
action.Git.Tag.text=新建標記…
action.Git.Branches.text=分支(_B)…
action.Git.ResolveConflicts.text=解決衝突…
action.Git.CompareWithBranch.text=與分支比較…
action.Git.Add.text=添加
action.Git.Interactive.Rebase.text=從這裡進行交互式變基…
action.Git.Interactive.Rebase.description=顯示交互式變基的對話框，可以在該對話中對提交執行壓縮、fixup、重新排序、移除和改寫
action.Git.Squash.Into.Commit.text=壓縮到…
action.Git.Squash.Into.Commit.description=創建壓縮提交
action.Git.Fixup.To.Commit.text=Fixup…
action.Git.Fixup.To.Commit.description=創建 fixup 提交
action.Git.Rename.Local.Branch.text=重命名…
action.Git.Rename.Local.Branch.description=重命名本地分支
action.Git.New.Branch.description=僅選擇一個分支以繼續創建新分支
action.Git.New.Branch.dialog.title=從 {0} 創建分支
action.Git.Update.Selected.text=更新所選內容
action.Git.Update.Selected.description=從跟踪的遠端獲取並使用 {1} 或像 \`git fetch branch:branch\` 一樣的快進(如果可能)更新所選{0,choice,1#分支|2#分支}
action.Git.Update.Selected.description.already.running=更新已在執行
action.Git.Update.Selected.description.select.non.current=僅選擇非當前分支
action.Git.Update.Selected.description.tracking.not.configured=沒有為所選{0,choice,1#分支|2#分支}配置跟踪分支
action.Git.Delete.Branch.title=刪除{0,choice,1#分支|2#分支}
action.Git.Compare.With.Current.title=與當前分支進行比較
action.Git.Compare.Selected.title=比較分支
action.Git.Compare.Selected.description=相互比較選定分支
action.Git.Compare.Selected.description.disabled=從同一版本庫中選擇分支
action.Git.Show.My.Branches.title=顯示我的分支
action.Git.Show.My.Branches.description.not.support.indexing=某些版本庫不支持索引。
action.Git.Show.My.Branches.description.not.all.roots.indexed=並沒有為所有版本庫編制索引。
action.Git.Show.My.Branches.description.not.graph.ready=該日志尚未就緒，請稍候。
action.Git.Show.My.Branches.description.is.my.branch=如果分支的所有獨佔提交都是由“我”(即當前 Git 作者)執行的，則此分支為“我的”。
action.Git.Show.My.Branches.description.calculating.branches.progress=正在計算我的分支
action.Git.Fetch.title=獲取所有遠端
action.Git.Fetch.description.fetch.in.progress=正在獲取…
action.Git.Toggle.Favorite.title=標記/取消標記為收藏項
action.Git.Loading.Branches.progress=正在載入分支…
group.Git.Log.Branches.Settings.text=分支窗格設定
group.Git.Log.Branches.Grouping.Settings.text=分組依據
group.Git.Log.Branches.Settings.Separator.text=單擊時
action.Git.Log.Branches.Change.Branch.Filter.On.Selection.text=更新分支篩選器
action.Git.Log.Branches.Change.Branch.Filter.On.Selection.description=選擇分支後，按此分支篩選日誌
action.Git.Log.Branches.Navigate.Log.To.Branch.On.Selection.text=在日誌中導航到分支 Head
action.Git.Log.Branches.Navigate.Log.To.Branch.On.Selection.description=選擇分支後，在日誌中導航到該分支 HEAD
action.Git.Log.Branches.Navigate.Log.To.Selected.Branch.text=在日誌中導航到所選分支 Head
action.Git.Log.Branches.Change.Branch.Filter.text=更新日誌中的分支篩選器
action.Git.Log.Branches.Change.Branch.Filter.description=使用所選分支更新日誌中的分支篩選器
action.Git.Log.Edit.Remote.text=編輯遠端
action.Git.Log.Remove.Remote.text=移除 {0,choice,1#遠端|2#遠端}
group.Git.HEAD.Branch.Filter.title=HEAD(當前分支)
group.Git.Local.Branch.title=本地
group.Git.Remote.Branch.title=遠端
action.Git.Checkout.Branch.text=簽出所選…
action.Git.Checkout.Branch.description=簽出所選分支
action.Git.Log.Hide.Branches.text=隱藏 Git 分支
action.Git.Log.Show.Branches.text=分支
action.Git.Reword.Commit.text=編輯提交訊息…
action.Git.Reword.Commit.description=通過 git rebase 或 amend 的改寫選項更改提交訊息
action.Git.Squash.Commits.text=壓縮提交…
action.Git.Drop.Commits.text=刪除提交
action.Git.Uncommit.text=撤消提交…
action.Git.Uncommit.description=撤消上次提交，並將其更改置於選定的更改列表
action.Git.Revert.In.Log.text=還原提交
action.Git.Revert.In.Log.template.text=還原{0,choice,1#提交|2#提交}
action.Git.Revert.In.Log.description=生成新提交，這會還原在原始提交中所做的變更
action.Git.Reset.In.Log.text=將當前分支重置到此處…
action.Git.CreateNewTag.text=新建標記…
action.Git.CreateNewTag.description=創建指向此提交的新標籤
action.Git.CreateNewBranch.text=新建分支…
action.Git.CreateNewBranch.description=從所選提交開始創建新分支
group.Git.CheckoutGroup.text=簽出
group.Git.CheckoutGroup.description=簽出所選修訂或所選提交中的分支
action.Git.BrowseRepoAtRevision.text=在修訂版中顯示版本庫
action.Git.Log.text=顯示 Git 版本庫日誌…
action.Git.Init.text=創建 Git 版本庫…
action.Git.Init.error=Git init 失敗
checkbox.dont.warn.again=不再警告
checkbox.run.git.hooks=執行 Git 掛鈎
tooltip.run.git.hooks=如果未選中，將使用 '--no-verify' 參數跳過 Git hook
action.NotificationAction.text.resolve=解決…
action.NotificationAction.GitDeleteBranchOperation.text.restore=恢復
action.NotificationAction.GitDeleteBranchOperation.text.view.commits=查看提交
action.NotificationAction.GitDeleteBranchOperation.text.delete.tracked.branch=刪除跟踪的分支
action.NotificationAction.GitDeleteTagOperation.text.restore=恢復
action.NotificationAction.GithubNotifications.text.configure=配置…
action.NotificationAction.GitMergeAction.text.view.commits=查看提交
action.NotificationAction.GitRewordOperation.text.undo=撤消
action.NotificationAction.GitUpdateSession.text.view.commits=查看提交
action.not.possible.in.fresh.repo.show.diff=正在比較修訂
action.not.possible.in.fresh.repo.rename.branch=正在重命名分支
action.not.possible.in.fresh.repo.checkout=簽出
action.not.possible.in.fresh.repo.push=正在推送提交

settings.git.option.group=Git
settings.add.suffix=在挑選推送到受保護分支的提交時，添加 'cherry-picked from <hash>' 後綴
settings.crlf=即將提交 CRLF 行分隔符時發出警告
settings.detached.head=在游離的 HEAD 中或變基期間提交時發出警告
settings.update.method=更新方法：
settings.auto.update.on.push.rejected=如果當前分支的推送被拒，則自動更新
settings.push.dialog=為提交和推送顯示推送對話框
settings.push.dialog.for.protected.branches=僅在提交到受保護分支時顯示推送對話框
settings.protected.branched=受保護分支:
settings.synchronize.branch.protection.rules=從 GitHub 載入分支保護規則
settings.synchronize.branch.protection.rules.description=將 GitHub 規則添加到本地規則中，並在每次獲取時進行同步
settings.credential.helper=使用憑證幫助程序
settings.filter.update.info=按路徑過濾“更新專案”資訊:
settings.explicitly.check=顯式檢查遠端上的傳入提交:
settings.clean.working.tree=使用何種操作清理工作樹:
settings.git.incoming.change.strategy.text.auto=自動
settings.git.incoming.change.strategy.text.always=始終
settings.git.incoming.change.strategy.text.never=從不
settings.git.update.method.rebase.description=在傳入變更上變基當前分支
settings.git.update.method.rebase=變基
settings.git.update.method.merge.description=將傳入變更合併到當前分支
settings.git.update.method.merge=合併
settings.git.update.method.branch.default=分支預設
settings.enable.staging.area=啟用暫存區域
settings.enable.staging.area.comment=這將禁用變更列表支援並刪除專案中的所有變更列表。僅適用於非強制回應提交介面。

clone.dialog.checking.git.version=正在檢查 Git 版本…
push.dialog.push.tags=推送標記
push.dialog.push.tags.combo.current.branch=當前分支
push.dialog.push.tags.combo.all=所有
push.dialog.target.panel.define.remote=定義遠端
push.dialog.target.panel.add.remote=添加遠端
push.dialog.target.panel.couldnt.add.remote=無法添加遠端: {0}
push.dialog.target.panel.adding.remote=正在添加遠端…
push.dialog.target.panel.can.t.push=無法推送
push.dialog.target.panel.empty.repository=空版本庫
push.dialog.target.panel.detached.head=游離的 HEAD
push.dialog.target.panel.new=新建
push.dialog.preview.commits.before.push=對於向不受保護分支的提交和推送，應在推送之前預覽提交
push.local.history.system.label.after=推送後
push.local.history.system.label.before=推送前
push.notification.description.force.pushed=強制推送 {0} 到 {1}
push.notification.description.new.branch.with.many.tags=推送 {0} 到新分支 {1}，並將 {2} 標籤到 {3}
push.notification.description.new.branch.with.single.tag=推送 {0} 到新分支 {1}，並將 {2} 標籤到 {3}
push.notification.description.new.branch=已推送 {0} 到新分支 {1}
push.notification.description.push.with.lease.rejected=使用 Force-with-lease 推送 {0} 到 {1} 被拒
push.notification.description.pushed.many.tags=已推送 {0} 標籤到 {1}
push.notification.description.pushed.single.tag=已推送標籤 {0} 到 {1}
push.notification.description.pushed.with.many.tags=已將 {0} 個{0,choice,1#提交|2#提交} 推送到 {1}，將 {2} 標籤推送到 {3}
push.notification.description.pushed.with.single.tag=已將 {0} 個{0,choice,1#提交|2#提交} 推送到 {1}，將標籤 {2} 推送到 {3}
push.notification.description.pushed=已將 {0} 個{0,choice,1#提交|2#提交} 推送到 {1}
push.notification.description.rejected.and.cancelled=推送被拒，更新被取消
push.notification.description.rejected.and.conflicts=由於更新期間發生衝突，推送被取消。<br/>檢查是否已正確解決衝突，然後再次調用推送。
push.notification.description.rejected.and.failed=因發生錯誤，推送被拒，更新失敗
push.notification.description.rejected.and.incomplete=由於更新過程中並未解決所有衝突，推送被取消。<br/>請解決衝突並再次調用推送
push.notification.description.rejected.by.remote=推送 {0} 到 {1} 被遠端拒絕
push.notification.description.rejected=推送到 {0} 被拒
push.notification.description.up.to.date=所有內容都已處於最新狀態
push.notification.force.push.anyway.action=仍然強制推送
push.notification.force.push.progress.title.pushing=正在推送…
push.notification.force.with.lease.help.description.first=Force-with-lease 推送阻止覆寫尚未獲取到本地版本庫的遠端更改
push.notification.force.with.lease.help.description.second=獲取最新變更，以確認能否安全丟棄變更並重複執行推送操作
push.notification.force.with.lease.help=何為 Force-with-Lease?
push.notification.partially.failed.title=推送部分失敗
push.notification.partially.rejected.title=推送部分被拒
push.notification.push.failed.title=推送失敗
push.notification.rejected.title=推送被拒
push.notification.single.repo.success.description=推送操作期間收到 {0} 個{0, choice,1#提交|2#提交}
push.notification.successful.title=推送成功
push.notification.update.action=更新
push.notification.view.files.action=查看在推送期間更新的檔案
push.notification.view.filtered.commits.actions=查看與篩選器符合的 {0} 個{0,choice,1#提交|2#提交}
push.notification.view.received.commits.action=查看收到的{0,choice,1#提交|2#提交}
push.rejected.dialog.title=推送被拒
push.rejected.many.repos.item={1} 中的 {0}
push.rejected.many.repos.single.branch=當前分支 \\"{0}\\" 的推送被拒。
push.rejected.many.repos=當前分支的推送被拒:
push.rejected.merge.needed.with.problem=在推送前，必須先合併遠端更改。<br/><br/>在這種情況下，強烈建議進行<b>合併</b>，因為存在未推送的合併提交。\\\\n\\\\
<br/>進行變基可能導致問題。
push.rejected.merge.needed=推送前需要合並遠端變更。
push.rejected.merge=&Merge
push.rejected.only.one.git.repo=當前分支 \\"{0}\\" 的推送被拒。
push.rejected.rebase.anyway=仍然變基
push.rejected.rebase=變基(&R)
push.rejected.update.not.rejected.repositories.as.well.checkbox=更新所有版本庫(&U)

install.download.and.install.action=下載並安裝
install.installing.progress=正在安裝…
install.downloading.progress=正在下載…
install.success.message=已安裝 Git
install.general.error=無法安裝 Git
install.mac.error.couldnt.start.command.line.tools=無法啟動 Command Line Tools 安裝
install.mac.requesting.command.line.tools=正在請求 XCode Command Line Developer Tools
git.status.not.changed=未更改
git.status.renamed=已重命名
git.status.copied=已複製
git.status.type.changed=已更改類型
git.status.unmerged=已取消合併
git.status.untracked=已取消跟踪
git.status.index=在暫存區域中{0}
git.status.work.tree=在工作目錄中{0}
git.status.unmerged.index=由我們{0}
git.status.unmerged.work.tree=由他人{0}
git.status.unmerged.both=兩者{0}

git.status.bar.widget.name=Git 分支
git.status.bar.widget.text.cherry.pick=正在 {0} 中優選
git.status.bar.widget.text.revert=正在 {0} 中還原
git.status.bar.widget.text.merge=正在合併 {0}
git.status.bar.widget.text.rebase=正在變基 {0}
git.status.bar.widget.tooltip.detached=Git: 游離的 HEAD 不指向任何分支

git.light.status.bar.display.name=Git
git.light.status.bar.tooltip=當前 Git 分支: {0}
git.light.status.bar.text=Git: {0}
git.light.cant.find.current.revision.exception.message=找不到 {0} 的當前修訂

status.exception.message.unexpected.xstatus.ystatus=意外的狀態符號: ''{0}{1}''
status.exception.message.unexpected.status=意外的狀態符號: ''{0}''
status.exception.message.line.is.too.short=此行過短
status.exception.message.unexpected=意外的狀態符號
status.exception.message.missing.path=缺少初始路徑
status.exception.message.format.message.xstatus.ystatus.line.output={0} xStatus=[{1}]，yStatus=[{2}]，行=[{3}]\\\\n\\\\
輸出:\\\\n\\\\
{4}

stage.tree.node.staged=已暫存
stage.tree.node.unstaged=已取消暫存
stage.tree.node.unmerged=已取消合併
stage.tree.node.untracked=已取消跟踪
stage.tree.node.ignored=已忽略
stage.content.staged=已暫存
stage.content.local=本地
error.no.selected.roots.to.commit=選擇要提交的根
error.no.staged.changes.to.commit=暫存要提交的檔案
error.no.staged.changes.no.commit.message=暫存要提交的檔案並指定提交訊息
stage.commit.process=正在提交暫存變更…
stage.commit.successful=已提交 {0}: {1}
stage.commit.failed=無法提交 {0}
stage.loading.status=正在載入變更…
stage.add.action.text=暫存
stage.add.process=正在暫存檔案…
stage.add.error.title=無法暫存檔案
stage.reset.action.text=取消暫存
stage.reset.process=正在取消暫存檔案…
stage.reset.error.title=無法取消暫存檔案
stage.revert.action.text=回滾
stage.revert.process=正在回滾檔案…
stage.revert.error.title=無法回滾檔案
stage.add.range.command.name=暫存變更
stage.revert.unstaged.range.command.name=回滾未暫存的變更
stage.revert.staged.range.command.name=回滾暫存的變更
action.label.add.unstaged.range=暫存
action.label.add.unstaged.range.tooltip=向索引中添加新的變更
action.label.reset.staged.range=取消暫存
action.label.reset.staged.range.tooltip=移除索引中的變更
stage.vfs.write.process=正在將 {0} 寫入 Git 索引
stage.vfs.read.process=正在從 Git 索引讀取 {0}
stage.vfs.refresh.process=正在刷新 Git 索引檔案
stage.vfs.presentable.file.name=已暫存: {0}
stage.vfs.editor.tab.tooltip=''{0}'' 的暫存版本
stage.vfs.editor.notification.text=這是暫存版本的 ''{0}''
stage.vfs.editor.notification.link=打開本地版本
stage.diff.local.content.exception.message=無法獲取本地檔案: ''{0}''
changes.view.merge.action.text=合併

action.Git.Show.Stage.text=顯示暫存區域
action.Git.Stage.Add.All.text=全部暫存
action.Git.Stage.Add.All.description=將所有未暫存的變更和未跟踪的檔案添加到索引
action.Git.Stage.Add.Tracked.text=暫存全部已跟踪項
action.Git.Stage.Add.Tracked.description=將跟踪檔案中所有未暫存的變更添加到索引
group.Git.Stage.Ui.Settings.text=檢視選項
action.Git.Stage.Show.Staged.text=顯示暫存版本
action.Git.Stage.Show.Staged.description=在編輯器中顯示當前檔案的暫存內容
action.Git.Stage.Show.Local.text=顯示本地版本
action.Git.Stage.Show.Local.description=在編輯器中顯示當前檔案的本地內容
action.Git.Stage.Compare.Local.Staged.text=與暫存版本比較
action.Git.Stage.Compare.Staged.Local.text=與本地版本比較
action.Git.Stage.Compare.Staged.Head.text=與 HEAD 版本比較
action.Git.Stage.Compare.Three.Versions.text=比較 HEAD 版本、暫存版本和本地版本
action.Git.Stage.ThreeSideDiff.text=比較 HEAD 版本、暫存版本和本地版本
action.Git.Stage.ThreeSideDiff.description=顯示包含 HEAD、暫存和本地版本的差異視窗，從中可以交互式地將變更添加到暫存區域
group.Git.Stage.Index.File.Menu.text=Git


branches.selected.branches.updated.title=已更新{0,choice,1#分支|2#分支}:\\\\n\\\\
\\\\n\\\\
{1}
branches.update.failed=更新失敗
branches.updating.process=正在更新分支…
branches.checkout.failed.description=無法覆蓋 {0} 分支，因為某些提交可能會丟失
branches.creation.failed.title=新分支創建失敗
branches.checkout.failed.title=簽出失敗
branches.checking.existing.commits.process=正在檢查現有提交…
branches.create.new.branch.dialog.title=創建新分支
branches.tag.0=標記 ''{0}''
branches.branch.0=分支 ''{0}''
in.branches.all.repositories=在所有版本庫中
branches.tags=標記
branches.branches=分支
repositories=版本庫
common.remote.branches=公共遠端分支
common.local.branches=公共本地分支
update.checks.not.supported.git.2.9.required=不支持更新檢查。需要 Git 2.9 及以上版本
action.fetch.text=獲取
fetching=正在獲取…
branches.current.branch=當前分支
branches.tracking.branch.doesn.t.configured.for.s=沒有為 {0} 配置跟踪分支
branches.update.is.already.running=更新已在執行
branches.update=更新
branches.current.branch.name=當前
branches.selected.branch.name=已選擇
branches.checkout.and.rebase.onto.in.one.step=簽出 {0}，並在一個步驟中將其變基到 {1} (類似於 \`git rebase HEAD {2}\`)
branches.checkout.and.rebase.onto.current=簽出並變基到當前分支
branches.checkout.and.rebase.onto.branch=簽出並變基到 {0}
branches.rebase.is.not.possible.in.the.detached.head.state=在游離的 HEAD 狀態下無法變基
branches.rebase.onto=將 {0} 變基到 {1}
branches.rebase.current.onto.selected=將當前分支變基到所選分支
branches.merge.into=將 {0} 合併到 {1} 中
branches.merge.into.current=合併到當前分支
branches.compare.the.current.working.tree.with=將當前工作樹與 {0} 中的樹進行比較
branches.show.diff.with.working.tree=顯示與工作樹的差異
branches.show.commits.in=在{0}中顯示{1}中缺少的提交
branches.compare.with.current=與當前分支進行比較
branches.compare.with.branch=與{0}比較
branches.new.branch.from.branch=從 {0} 新建分支…
branches.new.branch.from.branch.description=從 {0} 創建新分支
branches.checkout.s=簽出 {0}
checkout.and.rebase=變基到遠端
checkout.0=簽出 {0}
branches.drop.local.commits=刪除本地提交
branches.checkout=簽出
branches.rename.branch=重命名分支 {0}
branches.there.are.outgoing.commits=存在傳出提交
branches.there.are.incoming.commits=存在傳入提交
branches.there.are.incoming.and.outgoing.commits=存在傳入和傳出提交
branches.checkout.tag.or.revision=簽出標記或修訂…
branches.enter.reference.branch.tag.name.or.commit.hash=輸入引用(分支、標記)名稱或提交哈希:
branches.remote.branches=遠端分支
branches.remote.branches.in.repo={0} 中的遠端分支
branches.local.branches=本地分支
branches.local.branches.in.repo={0} 中的本地分支
branches.update.info.process=更新分支資訊…
branches.action.pull.into.branch.using.merge=使用合並拉入 {0}(_M)
branches.action.pull.into.branch.using.merge.description=使用合並拉入 {0}
branches.action.pull.into.branch.using.rebase=使用變基拉入 {0}(_R)
branches.action.pull.into.branch.using.rebase.description=使用變基拉入 {0}
git.rollback=回滾(&R)

new.branch.dialog.operation.create.name=創建
new.branch.dialog.operation.create.description=在其他版本庫中創建新分支
new.branch.dialog.operation.checkout.name=簽出
new.branch.dialog.operation.checkout.description=簽出現有分支，並在其他版本庫中創建新分支
new.branch.dialog.operation.rename.name=重命名
new.branch.dialog.branch.name=新分支名稱:
new.branch.dialog.checkout.branch.checkbox=簽出分支
new.branch.dialog.set.tracking.branch.checkbox=設定跟踪分支
new.branch.dialog.overwrite.existing.branch.checkbox=覆蓋現有分支
new.branch.dialog.overwrite.existing.branch.warning=更改名稱或覆蓋現有分支
new.branch.dialog.error.branch.name.invalid=分支名稱 {0} 無效
new.branch.dialog.error.branch.name.empty=指定新分支的名稱
new.branch.dialog.error.branch.name.head=HEAD 是保留關鍵字
new.branch.dialog.error.branch.already.exists=分支名稱 {0} 已存在
new.branch.dialog.error.branch.clashes.with.remote=分支名稱 {0} 與同名的遠端分支衝突
git.reset.mode.soft=軟
git.reset.mode.soft.description=檔案不會更改，差異將暫存以進行提交。
git.reset.mode.mixed=混合
git.reset.mode.mixed.description=檔案不會更改，差異也不進行暫存。
git.reset.mode.hard=硬
git.reset.mode.hard.description=<nobr>檔案將還原為所選提交的狀態。<nobr/><br><nobr>警告: 任何本地變更都將丟失。<nobr/>
git.reset.mode.keep=保留
git.reset.mode.keep.description=<nobr>檔案將還原為所選提交的狀態，<nobr/><br><nobr>但本地變更將保持不變。<nobr/>
git.reset.dialog.title=Git 重置
git.reset.dialog.description=<nobr>這會將當前分支 HEAD 重置為所選提交，<nobr/><br><nobr>並根據所選模式更新工作樹和索引:<nobr/>
git.reset.dialog.description.commit.details.by.author={0}，作者 {1}
git.reset.dialog.description.source.in.repository={0} ({1} 內)
git.reset.process=Git 重置
git.reset.operation=重置
git.reset.button=重置
git.reset.hard.button=硬重置(&H)
git.reset.successful.notification.message=重置成功
git.reset.partially.failed.notification.title=重置部分失敗
git.reset.partially.failed.notification.msg={0} 重置成功\\\\n\\\\
但 {1} 重置失敗:\\\\n\\\\
{2}
git.reset.failed.notification.title=重置失敗
git.undo.action.cant.undo.commit.failure=無法撤消提交
git.undo.action.description=所選提交不是當前分支中的最後一次提交
git.undo.action.select.target.changelist.title=選擇目標變更列表
git.undo.action.undoing.last.commit.process=正在撤消最後一次提交…
git.undo.action.refreshing.changes.process=正在刷新變更…
git.undo.action.could.not.load.changes.of.commit=無法載入 {0} 的變更
git.new.tag.dialog.title=在 {0}上創建新標記
git.new.tag.dialog.tag.name.label=輸入新標記的名稱

git.log.external.tab.description={0} 的日誌
git.log.external.window.title=Git 日誌
git.log.external.loading.process=正在載入 Git 日誌…

git.log.cherry.picked.highlighter.select.branch.popup=選擇源分支
git.log.cherry.picked.highlighter.process=正在比較分支…
git.log.cherry.picked.highlighter.error.message=無法與分支 {0} 進行比較
git.log.cherry.picked.highlighter.cancelled.message=已取消對 ''{0}'' 中未選取提交的高亮顯示，因為分支篩選器已被更改。

git.log.action.checkout.group=簽出
git.log.action.checkout.revision.short.text=修訂 ''{0}''
git.log.action.checkout.revision.full.text=簽出修訂 ''{0}''
action.Git.CheckoutRevision.text=簽出修訂

git.log.diff.handler.local.version.name=本地版本
git.log.diff.handler.local.version.content.title=本地

git.log.refGroup.local=本地

log.parser.exception.message.error.parsing.line=解析第 \\"{0}\\" 行時出錯
log.parser.exception.message.could.not.parse.output=無法解析 Git 日誌輸出 \\"{0}\\"
log.parser.exception.message.error.command.line={0}\\\\n\\\\
命令行: [{1}]

history.indexing.disabled.notification.text=由於索引不可用，顯示的是舊式檔案歷史記錄
history.indexing.disabled.notification.resume.link=恢復 Git 日誌索引
history.indexing.disabled.notification.dismiss.link=不再顯示

git.history.diff.handler.choose.parent.popup=選擇要比較的父項
git.history.diff.handler.load.changes.process=正在載入變更…
git.history.diff.handler.git.show.error=執行 git show {0}:{1} 時出錯
git.history.diff.handler.no.changes.in.file.info=此合併提交中的檔案 {0} 無變更
git.log.show.commit.in.log.process=搜尋修訂 {0}
git.compare.branches.empty.status={0} 包含來自 {1} 的所有提交
git.compare.branches.explanation.message=存在於 {0} 中但不存在於 {1} 中的提交
git.compare.branches.tab.name=比較
git.compare.branches.tab.suffix={0} 和 {1}
git.update.files.updated.in.commits=已更新 {1,choice,1#{1} 個提交|2#{1} 個提交}中的 {0,choice,1#{0} 個檔案|2#{0} 個檔案}
git.update.no.commits.matching.filters=沒有與篩選器符合的提交
git.update.commits.matching.filters={0,choice,1#{0} 個提交|2#{0} 個提交}與篩選器匹配
git.update.project.partially.updated.title=專案已部分更新
git.update.skipped.repositories=已跳過 {0} 個版本庫:
git.update.repo.was.skipped=已跳過 {0} ({1})

git.integration.created.git.repository.in=已在 {0} 中創建 Git 版本庫
git.integration.could.not.git.init=無法 git init {0}

git.tag.could.not.create.tag=無法創建標記
git.tag.created.tag.successfully=已成功創建標記 {0}。

rename.branch.operation.name=重命名
git.rename.branch.rollback.successful=回滾成功
git.rename.branch.renamed.back.to=已重命名回 {0}
git.rename.branch.rollback.failed=回滾失敗
git.rename.branch.could.not.rename.from.to=無法將 {0} 重命名為 {1}
git.rename.branch.was.renamed.to=分支 {0} 已被重命名為 {1}
git.rename.branch.you.may.rename.branch.back=您可以回滾(將分支重命名回 {0})以使分支不出現分叉。
git.rename.branch.has.succeeded.for.the.following.repositories=不過，以下{0,choice,1#版本庫|2#版本庫}的重命名已成功:

update.process.progress.title=正在更新…
update.process.generic.error.title=無法更新
update.process.error.message.unfinished.merge=您有未完成的合併。必須先解決這些衝突，然後才能更新。
update.process.error.message.unmerged.files=檢測到未合併的檔案。必須先解決這些衝突，然後才能更新。
update.process.error.description.unfinished.rebase=您有未完成的變基進程。必須先解決這些衝突，然後才能更新。
update.process.error.additional.description.unfinished.rebase=然後，您可以<b>繼續變基</b>。<br/>您也可以<b>中止變基</b>以恢復原始分支並停止變基。
update.process.nothing.to.update=沒有要更新的內容

checkout.operation.could.not.checkout.error=無法簽出 {0}
checkout.operation.revision.not.found=在{0,choice,0#|1#{1}中}未找到修訂
checkout.operation.rollback=回滾
checkout.operation.could.not.checkout.error.title=無法簽出 {0}
checkout.operation.checked.out=已簽出 {0}
checkout.operation.checked.out.new.branch.from=已從 {1} 中簽出新分支 {0}
checkout.operation.in={1,choice,0#|1#{2}中的}{0}
checkout.operation.force.checkout=強制簽出(&F)
checkout.operation.name=簽出
checkout.operation.error.during.rollback=回滾期間出錯
checkout.operation.errors.during.deleting=刪除 {0} 期間出錯:
checkout.operation.errors.during.checkout=簽出期間出錯:
checkout.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滾(簽回 {0})以使分支不出現分叉。
checkout.operation.previous.branch=上一個分支
checkout.operation.however.checkout.has.succeeded.for.the.following=不過，以下{0,choice,1#版本庫|2#版本庫}的簽出已成功:

delete.branch.operation.collecting.unmerged.commits.process=正在收集未合併的提交…
delete.branch.operation.restoring.branch.process=正在恢復分支 {0}…
delete.branch.operation.error.during.rollback.of.branch.deletion=分支刪除回滾期間出錯
delete.branch.operation.could.not.restore.branch.error=無法恢復 {0}
delete.branch.operation.branch.was.not.deleted.error=分支 {0} 未刪除
delete.branch.operation.deleted.branch=已刪除分支 {0}
delete.branch.operation.deleted.branch.bold=<b>已刪除的分支:</b> {0}
delete.branch.operation.unmerged.commits.were.discarded=未合併的提交已被丟棄
delete.branch.operation.however.branch.deletion.has.succeeded.for.the.following=不過，以下{0,choice,1#版本庫|2#版本庫}的分支刪除已成功:
delete.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滾(在這些根中重新創建 {0})以使分支不出現分叉。

branch.operation.could.not.0.operation.name.1.reference=無法{0} {1}
branch.operation.in={0} ({1} 中)

checkout.new.branch.operation.could.not.create.new.branch=無法創建新分支 {0}
checkout.new.branch.operation.error.during.rollback=回滾期間出錯
checkout.new.branch.operation.errors.during.deleting=刪除 {0} 期間出錯:
checkout.new.branch.operation.errors.during.checkout=簽出期間出錯:
checkout.new.branch.operation.rollback.successful=回滾成功
checkout.new.branch.operation.checked.out.0.and.deleted.1.on.2.3=已在{2,choice,1#根|2#根}{3}上簽出 {0} 並刪除 {1}
checkout.new.branch.operation.branch.was.created=已創建分支 {0}
checkout.new.branch.operation.however.checkout.has.succeeded.for.the.following=不過，{0,choice,1#版本庫|2#版本庫} 的簽出已成功:
checkout.new.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滾(簽回上一個分支並刪除 {0})以使分支不出現分叉。

delete.branch.operation.name=分支刪除
delete.remote.branch.operation.deleting.process=正在刪除 {0}
delete.remote.branch.operation.deleted.remote.branch=已刪除遠端分支 {0}
delete.remote.branch.operation.also.deleted.local.branches=同時刪除了本地 {0,choice,1#分支|2#分支}: {1}
delete.remote.branch.operation.failed.to.delete.remote.branch=無法刪除遠端分支 {0}
delete.remote.branch.operation.couldn.t.find.remote.by.name=無法按名稱尋找遠端: {0}

delete.remote.tag.operation.deleted.tag.on.remotes=<b>已刪除 {0,choice,1#遠端|2#遠端}上的標記:</b> {1}
delete.remote.tag.operation.tag.does.not.exist.on.remotes=<b>標記在 {0,choice,1#遠端|2#遠端} 上不存在:</b> {1}
delete.remote.tag.operation.failed.to.delete.tag.on.remotes=無法刪除 {1,choice,1#遠端|2#遠端} 上的標記 {0}

merge.dialog.description.cherry.pick.label.text=在優選{2,choice,0#|1#由 {3}{4} 執行的}{0,choice,1#提交 {1}|2#多個提交}期間出現衝突
merge.dialog.description.merge.label.text=將 {0,choice,1#分支 {1}|2#分叉的分支} 合併到 {2,choice,1#分支 {3}|2#分叉的分支}
merge.dialog.description.rebase.with.hash.label.text=正在{0,choice,0#|1#將分支 {1} }變基到 {2}
merge.dialog.description.rebase.with.onto.branch.label.text=正在{0,choice,0#|1#將分支 {1} }變基到分支 {2}{3,choice,0#|1#，修訂 {4}}
merge.dialog.description.rebase.without.onto.info.label.text=正在{0,choice,0#|1#將分支 {1} }變基到分叉的分支
merge.dialog.diff.left.title.cherry.pick.label.text=本地變更
merge.dialog.diff.left.title.default.branch.label.text=您的版本，分支 {0}
merge.dialog.diff.left.title.rebase.label.text=正在從 {1} 變基 {0}
merge.dialog.diff.right.title.cherry.pick.label.text=來自優選 {0} 的變更
merge.dialog.diff.right.title.default.with.hash.label.text=來自 {0} 的變更
merge.dialog.diff.right.title.default.with.onto.branch.label.text=來自分支 {0}{1,choice,0#|1#，修訂 {2}} 的變更
merge.dialog.diff.right.title.default.without.onto.info.label.text=來自分叉分支的變更
merge.dialog.diff.right.title.rebase.with.branch.label.text=已變基的提交和來自 {0} 的提交
merge.dialog.diff.right.title.rebase.without.branch.label.text=已變基的提交
merge.dialog.diff.title.changes.from.branch.label.text=來自 {0} 的變更
merge.error.unable.to.read.merge.head=無法讀取檔案 {0}: {1}
merge.operation.name=合併
rebase.operation.name=變基
unstash.operation.name=取消儲藏
merge.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滾(重置為合併之前的提交)以使分支不出現分叉。
merge.operation.error.during.rollback=回滾期間出錯
merge.operation.branch.merged.with.conflicts={0} 已合併，但存在衝突
merge.operation.could.not.merge.branch=無法合併 {0}
merge.operation.already.up.to.date=已是最新
merge.operation.however.merge.has.succeeded.for.the.following.repositories=不過，以下 {0,choice,1#版本庫|2#版本庫} 的合併已成功:
merge.operation.merged.to=已將 {0} 合併到 {1}
merge.operation.delete.branch=刪除 {0}
merge.progress.indicator.loading.unmerged.files.title=正在載入未合併的檔案…

merge.unresolved.conflicts.remaining.notification.title=正在掛起未解決的衝突
merge.unresolved.conflicts.remaining.notification.body=有掛起的未解決的衝突。

create.branch.operation.name=創建分支
create.branch.operation.could.not.create.new.branch=無法創建新分支 {0}
create.branch.operation.rollback.successful=回滾成功
create.branch.operation.deleted.branch=已刪除 {0}
create.branch.operation.error.during.rollback=回滾期間出錯
create.branch.operation.branch.created=已創建分支 {0}
create.branch.operation.however.the.branch.was.created.in.the.following.repositories=不過，已在以下 {0,choice,1#版本庫|2#版本庫} 中創建分支:
create.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滾(刪除 {0})以使分支不出現分叉。

branch.ui.handler.can.not.operation.name.because.of.unmerged.files=由於存在未合併的檔案而無法{0}
branch.ui.handler.unmerged.files.error.notification=您必須先<a href=''{0}''>解決</a>所有合併衝突，然後才能{1}。<br/>解決衝突之後，您可能還需要將檔案提交到當前分支。
branch.ui.handler.merge.notification.description=以下檔案存在未解決的衝突。您需要先解決它們，然後再{0}。
branch.ui.handler.merge.error.notification.title=仍然存在未解決的檔案。
branch.ui.handler.rollback=回滾
branch.ui.handler.do.not.rollback=不回滾
branch.ui.handler.you.have.to.resolve.all.conflicts.before.operation.name=您必須先解決所有合併衝突，然後才能{0}。<br/>{1}
branch.ui.handler.delete.remote.branches=刪除遠端 {0,choice,1#分支|2#分支}
branch.ui.handler.delete.all=全部刪除
branch.ui.handler.delete.remote.branches.question=刪除遠端 {0,choice,1#分支|2#分支} {1}?
branch.ui.handler.delete.tracking.local.branch.as.well=同時刪除跟踪本地分支 {0}
branch.ui.handler.delete.tracking.local.branches=刪除跟踪本地分支:

delete.tag.operation.could.not.restore.tag=無法恢復 {0}
delete.tag.operation.error.during.rollback.of.tag.deletion=標記刪除回滾期間出錯
delete.tag.operation.restored.tag=已恢復標記 {0}
delete.tag.operation.rollback.successful=回滾成功
delete.tag.operation.restoring.tag.process=正在恢復標記 {0}…
delete.tag.operation.deleted.tag=<b>已刪除的標記:</b> {0}
delete.tag.operation.delete.on.remote=在 {0,choice,1#遠端|2#遠端} 上刪除
delete.tag.operation.could.not.find.tag=無法找到標記 {0}
delete.tag.operation.could.not.find.tag.in=在 {0} 中找不到標記
delete.tag.operation.tag.was.not.deleted=未刪除標記 {0}
delete.tag.operation.however.tag.deletion.has.succeeded.for.the.following=不過，以下{0,choice,1#版本庫|2#版本庫}的標記刪除已成功:
delete.tag.operation.you.may.rollback.not.to.let.tags.diverge=您可以回滾(在這些根中重新創建 {0})以使標記不出現分叉。

branch.renaming.branch.process=正在將 {0} 重命名為 {1}…
branch.rebasing.process=正在變基 {0}…
branch.rebasing.onto.process=正在變基到 ''{0}''…
branch.merging.process=正在合併 {0}…
branch.deleting.tag.process=正在刪除標記 {0}…
branch.deleting.tag.on.remote.process=正在刪除遠端上的標記 {0}…
branch.deleting.remote.branch=正在刪除 {0}…
branch.deleting.branch.process=正在刪除 {0}…
branch.checking.out.new.branch.process=正在簽出新分支 {0}…
branch.creating.branch.process=正在創建分支 {0}…
branch.checking.out.branch.from.process=正在從 {1} 簽出 {0}…
branch.checking.out.process=正在簽出 {0}…

branch.not.fully.merged.dialog.repository.label=版本庫:
branch.not.fully.merged.dialog.title=分支未完全合併
branch.not.fully.merged.dialog.restore.button=恢復(&R)
branch.not.fully.merged.dialog.all.commits.from.branch.were.merged=已合併來自分支 {0} 的所有提交
branch.not.fully.merged.dialog.the.branch.was.not.fully.merged.to=分支 {0} 未完全合併到 {1}。<br/>以下是未合併提交的列表。

merge.dialog.customizer.filter.by.conflicted.file.checkbox=按衝突檔案篩選
merge.dialog.customizer.show.details.link.label=顯示詳細資訊
merge.dialog.customizer.collecting.details.progress=正在收集提交詳細資訊…

branch.worker.could.not.create.tag=無法在 {1,choice,0#|1#|2#在 {2} 中} 創建標記 {0}

commit.options.sign.off.commit.checkbox=Sign-off 提交
commit.options.sign.off.commit.message.line=在提交訊息結尾添加以下行:<br/>Signed-off by: {0}
commit.options.create.extra.commit.with.file.movements=使用檔案移動創建額外提交

show.diff.between.dialog.title={0}與當前工作樹之間的變更
show.diff.between.dialog.no.differences.empty.text=無差異
show.diff.between.dialog.could.not.load.diff.with.branch.error=無法載入與 {0} 的差異: {1}
annotations.options.detect.movements.across.files=檢測跨檔案的移動
annotations.options.detect.movements.within.file=檢測檔案內的移動
annotations.options.ignore.whitespaces=忽略空格
annotations.options.group=選項
progress.title.moving.files=正在移動檔案…

editor.promo.commit.text=使用提交接口直接從 {0} 提交。
editor.promo.commit.try.link=嘗試
editor.promo.help.link=了解詳情
editor.promo.close.link=不再顯示

tracked.branch.fix.dialog.title=更新
tracked.branch.fix.dialog.ok.button.text=更新
tracked.branch.fix.dialog.set.as.tracked=設為跟踪分支
tracked.branch.fix.dialog.branch.placeholder=指定分支
tracked.branch.fix.dialog.not.on.branch.title=游離的 HEAD 中的 Git 版本庫
tracked.branch.fix.dialog.not.on.branch.message=將跳過以下版本庫:
progress.title.enabling.git=正在啟用 Git…

action.selected.file.text=選定{0,choice,1#檔案|2#檔案}
action.selected.directory.text=選定{0,choice,1#目錄|2#目錄}
action.New.Branch.disabled.several.commits.description=選擇單個提交以創建新分支
action.New.Branch.disabled.fresh.description=無法在空版本庫中創建新分支。首先進行初始提交

conflicts.type.both.deleted=均已刪除
conflicts.type.both.added=均已添加
conflicts.type.both.modified=均已修改
conflicts.type.deleted.by.you=由您刪除
conflicts.type.deleted.by.them=由他們刪除
conflicts.type.added.by.you=由您添加
conflicts.type.added.by.them=由他們添加
conflicts.merge.window.error.title=無法解決衝突
conflicts.merge.window.error.message=找不到 {0} 的檔案
conflicts.accept.progress=正在解析 {0,choice,1#個衝突|2#個衝突}
conflicts.loading.status=正在載入合併衝突…
conflicts.resolve.action.text=解決
conflicts.accept.theirs.action.text=接受他們的變更
conflicts.accept.yours.action.text=接受您的變更

remotes.dialog.title=Git 遠端
remotes.dialog.adding.remote=正在添加遠端…
remote.dialog.add.remote=添加遠端
remotes.dialog.cannot.add.remote.error.message=無法添加遠端 {0} ''{1}''
remotes.dialog.remove.remote.message=移除 {0,choice,1#遠端|2#遠端}{1}?
remotes.dialog.remove.remote.title=移除 {0,choice,1#遠端|2#遠端}
remotes.dialog.removing.remote.progress=正在移除{0,choice,1#遠端|2#遠端}…
remotes.dialog.removing.remote.error.title=移除 {0,choice,1#遠端|2#遠端}
remotes.dialog.removing.remote.error.message=無法移除{0, choice, 1#遠端|2#遠端} {1}
remotes.changing.remote.progress=正在更改遠端…
remotes.changing.remote.error.title=更改遠端
remotes.changing.remote.error.message=無法將遠端 {0} 更改為 {1} ''{2}''
remotes.operation.not.executed.message=操作未執行
remotes.operation.error.message=在 {1} 中{0}:\\\\n\\\\
{2}
remotes.remote.column.name=名稱
remotes.remote.column.url=URL
remotes.define.remote=定義遠端
remotes.define.remote.name=名稱:
remotes.define.remote.url=URL:
remotes.define.empty.remote.name.validation.message=遠端名稱不能為空
remotes.define.empty.remote.url.validation.message=遠端 URL 不能為空
remotes.define.invalid.remote.name.validation.message=遠端名稱包含非法字符
remotes.define.duplicate.remote.name.validation.message=遠端名稱 ''{0}'' 已被使用
tab.title.repo.root.name.at.revision={1} 的 {0}
tab.title.conflicts=衝突

button.crlf.fix.dialog.commit.as.is=按原樣提交
button.crlf.fix.dialog.fix.and.commit=修復並提交
title.crlf.fix.dialog=行分隔符警告
text.crlf.fix.dialog.description.warning=您即將把 CRLF 行分隔符提交到 Git 版本庫。<br/>建議將 {0} Git 特性設定為 {1}，以免發生行分隔符問題。
text.crlf.fix.dialog.description.proposed.fix=如果選擇<b>修正並提交</b>，將執行 {0}。<br/>如果選擇<b>按原樣提交</b>，則不會更改配置值。
progress.finishing.conflict.resolve=正在解決衝突
link.label.editor.notification.merge.conflicts.resolve.in.progress=正在解決合併衝突
link.label.merge.conflicts.resolve.in.progress.focus.window=使視窗獲得焦點
link.label.merge.conflicts.resolve.in.progress.cancel.resolve=取消解決
label.diff.content.title.submodule.suffix={0} (子模組)
error.git.version.check.failed=執行 ''git --version'' 時出錯。退出程式碼: {0}，錯誤: {1}

local.changes.save.policy.stash=儲藏
local.changes.save.policy.shelve=擱置
notification.title.fetch.failure=獲取失敗
notification.title.fetch.success=獲取成功
title.sudo.command.install.git=安裝 Git

activity.name.unstash=取消儲藏
notification.title.unstash.failed=取消儲藏失敗
exception.message.could.not.stash.root.error=無法儲藏 {0}: {1}
error.git.parse.unknown.file.status=未知檔案狀態: {0}
error.git.parse.not.a.revision.number=字串 ''{0}'' 不表示修訂號
error.git.repository.not.found=該版本庫不再存在: {0}

title.changes.excluded.from.commit=已從合併提交中排除變更
label.changes.excluded.from.commit.are.you.sure.want.to.continue=是否確定要從合併提交中排除這些變更過的檔案?
button.changes.excluded.from.commit.commit.anyway=仍然提交
title.unresolved.conflicts.pre.commit.check=未解決的衝突
message.unresolved.conflicts.prevent.commit=由於有未解決的衝突，無法提交變更。

label.user.name=名稱:
label.user.email=電子郵件:
checkbox.set.config.property.globally=全域設定屬性
title.user.name.email.not.specified=未定義 Git 用戶名
button.set.name.and.commit=設定並提交
validation.warning.set.name.email.for.git=您必須為 Git 指定用戶名和電子郵件
label.name.email.not.defined.in.n.roots={0,choice,1#根|2#根}中未定義 Git 的 user.name 和 user.email 屬性
error.cant.set.user.name.email=無法設定 user.name 和 user.email
progress.checking.user.name.email=正在檢查 Git 用戶名…
progress.setting.user.name.email=正在設定 Git 用戶名…
progress.setting.config.value=正在更新 Git 配置…
progress.checking.line.separator.issues=正在檢查行分隔符問題…
error.title.git.version.does.not.define.home.env=HOME 變數未定義
error.message.git.version.does.not.define.home.env=您正在使用 Git {0}，它沒有正確定義 %HOME% 環境變數。\\\\n\\\\
不妨將 Git 更新到較新的版本，或將 %HOME% 定義為指向全域 .gitconfig 的存儲位置\\\\n\\\\
(通常為 %USERPROFILE% 或 %HOMEDRIVE%%HOMEPATH%)。
warning.title.commit.with.unfinished.rebase=未完成變基進程
warning.message.commit.with.unfinished.rebase=以下路徑中的 Git 版本庫有一個<b>未完成的變基</b>進程: <br/> {0}<br/>您可能想<b>繼續變基</b>而不是提交。<br/>在變基期間提交可能會導致提交丟失。
link.label.commit.with.unfinished.rebase.read.more=閱讀有關 Git 變基的更多資訊
warning.title.commit.with.detached.head=在游離的 HEAD 中提交
warning.message.commit.with.detached.head=以下路徑中的 Git 版本庫處於<b>游離的 HEAD</b> 狀態: <br/>{0}<br/>您可以進行檢查，嘗試做出變更並提交，但務必簽出分支，以免丟失您的工作。<br/>否則，可能會丟失所做的變更。
link.label.commit.with.detached.head.read.more=閱讀有關游離的 HEAD 的更多資訊
error.commit.cant.collect.partial.changes=無法收集要提交的部分變更
error.commit.cant.commit.multiple.changelists=無法一次提交多個變更列表中的變更
error.commit.cant.commit.with.unmerged.paths=由於您有未合併的檔案，因此無法提交。
error.commit.cant.create.message.file=創建提交訊息檔案失敗
button.commit.all.files=提交所有檔案
title.ssh.confirmation=SSH 確認
label.credential.store.key.ssh.passphrase=Git SSH 密碼短語
label.credential.store.key.ssh.password=Git SSH 密碼
label.credential.store.key.http.password=Git HTTP
error.cannot.delete.file=無法刪除檔案: {0}
action.description.cant.revert.merge.commit=不允許還原合併提交
progress.title.reverting.n.commits=正在還原{0,choice,1#提交|2#提交}
progress.title.validating.revision=正在驗證修訂…

revision.number.cannot.parse.output=無法解析輸出: [{0}]

unexpected.tree.entries.error=意外的樹條目: {0}
unexpected.tree.object.error=意外的樹物件: {0}
revert.operation.name=還原
revert.operation.applied=還原
cherry.pick.name=優選
cherry.pick.applied=套用
operation.name.validating.revision.0=驗證修訂 {0}
operation.name.loading.revision=載入修訂
combobox.item.file.invalid=(無效)
warning.your.local.changes.would.be.overwritten.by.merge=您的本地變更將被合併覆蓋。\\\\n\\\\
提交、存儲或還原您的變更以繼續。
link.label.local.changes.would.be.overwritten.by.merge.view.them=查看這些變更
dialog.title.local.changes.prevent.from.operation=本地變更阻止{0}
notification.title.git.operation.failed=Git {0} 失敗
notification.title.untracked.files.prevent.operation=未跟踪的檔案會阻止{0}
notification.content.untracked.files.prevent.operation.move.or.commit=在 {0} 前移動或提交<br/>{1}
dialog.title.could.not.operation=無法{0}
dialog.title.untracked.files.preventing.operation=阻止{0}的未跟踪檔案
dialog.message.untracked.files.will.be.overwritten.by.operation=這些未跟踪的檔案將被{0}覆蓋
button.rollback=回滾
button.don.t.rollback=不回滾
progress.title.update=更新
notification.content.fetched.successfully=已成功獲取
notification.content.fetch.cancelled.by.user=使用者取消了獲取
notification.content.fetch.failed.couldn.t.authorize=獲取失敗: 授權錯誤
notification.content.couldn.t.authorize=授權錯誤
notification.title.fetch.failed=獲取失敗
notification.title.fetch.details=獲取詳細資訊
notification.title.couldn.t.reset.merge=無法中止合併操作
notification.title.error.merging=合併錯誤
progress.text.merging.repository=正在合併 {0}…
dialog.title.rebasing.merge.commits=正在變基合併提交
dialog.message.rebasing.merge.commits=您即將變基存在衝突的合併提交。\\\\n\\\\
\\\\n\\\\
如果您不想再次解決衝突，請選擇“合併”; 如果要將歷史記錄線性化，仍可進行變基。
rebasing.merge.commits.button.merge=合併
rebasing.merge.commits.button.rebase=變基
rebasing.merge.commits.button.cancel=取消
progress.details.refreshing.files.for.root=正在刷新根 {0} 的檔案
activity.name.update=VCS 更新
notification.title.couldnt.collect.updated.files.info=無法收集已更新檔案的資訊
notification.content.couldnt.collect.updated.files.info={0} 更新成功，但由於發生了一個錯誤，無法收集更新的變更
notification.title.update.failed=更新失敗
notification.title.can.t.update.no.current.branch=無法更新: 無當前分支
notification.content.detached.state.in.root.checkout.branch=您處於“游離的 HEAD”狀態，這表明您不在任何分支 {0} 上<br/>簽出分支以更新專案。
notification.content.branch.in.repo.has.no.tracked.branch={0} {1} 沒有跟踪的分支
notification.title.error.updating.root=更新 {0} 期間出錯
notification.content.updating.root.failed.with.error=更新 {0} 失敗，出現錯誤: {1}
git.update.operation=更新
progress.update.destination.remote=遠端
no.revisions.available=無修訂
search.everywhere.group.name=Git
search.everywhere.group.full.name=Git 引用
search.everywhere.items.commit.by.hash=提交(按哈希)
search.everywhere.items.local.branch=本地分支
search.everywhere.items.remote.branch=遠端分支
search.everywhere.items.tag=標記
search.everywhere.items.commit.by.message=提交(按訊息)
commit.author.with.committer={0}，通過 {1}

stage.diff.staged.content.exception.message=無法獲取暫存內容: ''{0}''
stage.vfs.shutdown.process=正在關閉 Git 索引 VFS
apply.changes.unresolved.conflicts.text=工作樹中有未解決的衝突。
apply.changes.unresolved.conflicts.notification.resolve.action.text=解決…
apply.changes.unresolved.conflicts.notification.abort.action.text=中止{0}
action.Git.Commit.Stage.text=提交…
git.executable.error.bash.not.found=找不到 bash 可執行檔案
settings.label.sign.gpg.commits.loading.text=使用 GPG 密鑰簽署提交: 正在讀取配置…
settings.label.sign.gpg.commits.not.configured.text=未配置使用 GPG 密鑰簽署提交
settings.label.sign.gpg.commits.enabled.text=提交使用 GPG 密鑰簽署: {0}
settings.label.sign.gpg.commits.enabled.different.keys.text=提交使用不同的 GPG 密鑰簽署
settings.label.sign.gpg.commits.enabled.n.roots.of.m.text=提交使用 {1} 的 {0} 個{0,choice,1#根|2#根}中的 GPG 密鑰簽署
settings.sign.gpg.configure.link.text=配置 GPG 密鑰…
settings.configure.sign.gpg.synced.with.gitconfig.text=與 gitconfig 同步
settings.configure.sign.gpg.for.repo.dialog.title=配置 GPG 密鑰 {0}
settings.configure.sign.gpg.for.repos.dialog.title=配置 GPG 密鑰
settings.configure.sign.gpg.with.key.checkbox.text=使用 GPG 密鑰簽署提交:
settings.configure.sign.gpg.root.table.column.name=根
settings.configure.sign.gpg.gpg.kep.table.column.name=GPG 密鑰
settings.configure.sign.gpg.do.not.sign.table.text=不簽署
settings.configure.sign.gpg.error.table.text=錯誤: {0}
settings.configure.sign.gpg.error.no.available.keys.found.text=找不到適用的私鑰
settings.configure.sign.gpg.loading.table.text=正在載入…
column.name.commit.signature=GPG 簽名
tooltip.no.commit.signature=無 GPG 簽名
tooltip.commit.signature.verify.failure=GPG 簽名未驗證
tooltip.commit.signature.verify.success=GPG 簽名已驗證
branch.direction.panel.branch.label=分支:
branch.direction.panel.save.button=儲存
branch.direction.panel.base.repo.label=基礎版本庫:
branch.direction.panel.head.repo.label=Head 版本庫:
branch.direction.panel.select.link=選擇…
branch.direction.panel.warning.push=''{0}'' 沒有遠端分支。\\\\n\\\\
將在 ''{1}'' 上創建新的遠端分支。
branch.direction.panel.warning.not.synced=本地分支未與遠端分支同步。\\\\n\\\\
''{0}'' 分支將與 ''{1}'' 同步。
push.failed.error.message=推送失敗: {0}
advanced.settings.git=版本控制。Git
advanced.setting.git.clone.recurse.submodules=遞歸克隆專案中的子模組
advanced.setting.git.clone.recurse.submodules.description=啟用後，從 Git 調用 'git clone --recurse-submodules' 簽出，即克隆主版本庫與所有子模組 (如有)
advanced.setting.git.use.push.force.with.lease=使用安全強制推送
advanced.setting.git.use.push.force.with.lease.description=從 IDE 調用強制推送時使用 '--force-with-lease'，而非僅使用 '--force'
advanced.setting.git.update.incoming.outgoing.info=檢查傳入和傳出提交
advanced.setting.git.update.incoming.outgoing.info.description=在“分支”彈出視窗中更新具有傳入/傳出提交的分支資訊
advanced.setting.git.read.content.with=從 Git 讀取時套用內容轉換
advanced.setting.git.read.content.with.description=從 Git 讀取檔案內容時為 'git cat-file' 命令使用 '--filters' 或 '--textconv' 標誌
advanced.setting.git.use.schannel.on.windows=使用 Windows 證書存儲
advanced.setting.git.use.schannel.on.windows.description=強制 Git 使用 Windows 證書存儲來驗證 SSL 連接。適用於 Git 2.14 及更高版本。
git.content.transform.none=無
git.content.transform.filters=篩選器
git.content.transform.textconv=TextConv
settings.label.sign.gpg.commits.no.roots.text=專案中沒有 Git 根
gpg.error.see.documentation.link.text=參閱 GPG 設定指南
gpg.jb.manual.link=Set_up_GPG_commit_signing
settings.commit.group.title=提交
settings.push.group.title=推送
settings.update.group.title=更新
error.unresolved.conflicts=解決衝突以提交
stash.changes.empty=選擇儲藏以查看變更
stash.changes.loading=正在載入…
branches.checkout.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。將 ''{0}'' 變基到 ''{1}''，還是簽出 ''{0}''?
branches.checkout.with.reset.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。將 ''{0}'' 變基到 ''{1}''，還是刪除本地提交?
branches.create.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。要在其他版本庫中創建分支嗎?
branches.create.with.reset.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。要刪除本地提交嗎?
branches.checkout.local=簽出本地分支
notification.title.unstash.failed.index.conflict=由於索引衝突，取消儲藏失敗
branches.checkout.and.rebase.failed=簽出和變基失敗
branches.checkout.and.rebase.error.current.with.same.name=無法覆蓋當前分支 {0}
branches.checkout.and.rebase.onto.current.process=正在簽出 {0} 並變基到當前分支
progress.title.creating.git.repository=正在創建 Git 版本庫…
stash.load.changes.error=無法在解析為 {1} 的儲藏中載入根 {0} 中的變更
git.log.diff.handler.changes.between.revisions.title={0} 與 {1} 之間的變更
git.log.diff.handler.changes.between.revisions.in.paths.title={2} 中 {0} 與 {1} 之間的變更
commit.signature.verified=已驗證的 GPG 簽名
commit.signature.unverified=未驗證的 GPG 簽名
action.Git.PushUpToCommit.text=推送此前所有提交…
action.Git.PushUpToCommit.description=推送所有之前的提交，包括所選提交
push.upto.here.not.supported.notification.title=無法啟動推送
push.upto.here.not.supported.notification.message=“推送此前所有提交”僅支援包含在本地分支中的提交
push.upto.here.failed.dialog.title=無法啟動推送
push.up.to.commit.allowed.progress.title=正在檢查是否允許推送到所選提交…
push.up.to.commit.getting.reference.progress.title=正在獲取對 HEAD 的提交引用…
git.toolbar.widget.no.repo=無版本庫
push.rejected.remember.checkbox=請記住更新方法，並在日後進行靜默更新(&S)。稍後可以在“{0} | 版本控制”中進行更改。<br/>
push.rejected.specific.repo=版本庫 \\"{1}\\" 中的當前分支 \\"{0}\\" 推送被拒。
git.status.bar.widget.text.unknown=<未知>
git.toolbar.widget.tooltip=Git 分支: {0}
action.Git.Toolbar.ShowMoreActions.text=版本控制
action.Git.ShowBranches.text=顯示分支
action.Git.ShowBranches.description=顯示分支
action.Git.Toolbar.ShowMoreActions.description=VCS 操作
stash.editor.diff.preview.id.change.title={0}：{1}"
`;

exports[`src messages/GithubBundle.properties 1`] = `
"#general
accessing.github=正在存取 GitHub
retry.action=重試
retry.link=重試
open.in.browser.link=在瀏覽器中打開
user.someone=某人
progress.title.not.visible=不可見
action.comment.text=評論
group.GitHub.MainMenu.text=GitHub
#settings
settings.clone.ssh=使用 ssh 克隆 Git 版本庫
settings.timeout=連接超時:
settings.timeout.seconds=秒
#accounts
action.Github.Accounts.AddGHAccount.text=通過 GitHub 登錄…
action.Github.Accounts.AddGHAccountWithToken.text=通過令牌登錄…
action.Github.Accounts.AddGHEAccount.text=登錄 GitHub Enterprise…
dialog.title.add.github.account=添加 GitHub 帳戶
dialog.message.account.cannot.be.empty=帳戶不能為空
accounts.remove=移除帳戶
accounts.set.default=設定為預設值
accounts.log.out=退出…
accounts.relogin=重新登錄
accounts.label.no.accounts=無帳戶
accounts.default.missing=缺少預設的 GitHub 帳戶
button.login.mnemonic=登錄(&L)
login.link=登錄
login.action=登錄
login.via.github.action=通過 GitHub 登錄…
login.with.token.action=通過令牌登錄…
login.to.github.enterprise.action=登錄 GitHub Enterprise…
button.use.token=使用令牌…
dialog.message.login.to.continue=登錄到 GitHub 以繼續
login.to.github=登錄 GitHub
login.to.github.enterprise=登錄 GitHub Enterprise
label.login.progress=正在登錄…
label.login.option.separator=或
link.label.use.token=使用令牌…
login.use.token=使用令牌
login.token.cannot.be.empty=令牌不能為空
login.account.already.added=已添加帳戶 ''{0}''
login.insufficient.scopes=必須為存取令牌授予以下範圍: {0}
login.sign.up=註冊 GitHub
login.use.credentials=使用憑證
credentials.server.field=伺服器:
credentials.server.cannot.be.empty=伺服器不能為空
credentials.server.path.invalid=伺服器 URL 無效
credentials.token.field=令牌:
credentials.button.generate=生成…
credentials.incorrect=憑證不正確。\\\\n{0}
credentials.invalid.auth.data=身份驗證資料無效。\\\\n{0}
credentials.invalid.server.path=伺服器路徑無效
credentials.login.cannot.be.empty=登錄名不能為空
credentials.login.field=登錄名:
credentials.password.cannot.be.empty=密碼不能為空
credentials.password.field=密碼:
credentials.password.not.saved=該密碼未儲存，僅用於生成 GitHub 令牌
credentials.2fa.dialog.title=GitHub 雙重身份驗證
credentials.2fa.dialog.code.field=身份驗證程式碼:
account.choose.for=選擇 GitHub 帳戶: {0}
account.choose.title=選擇 GitHub 帳戶
account.choose.link=選擇帳戶
account.choose.button=選擇
account.choose.not.selected=未選擇帳戶
account.choose.as.default=設定為當前專案的預設帳戶
account.token.missing.for=缺少 {0} 的存取令牌
account.token.missing=缺少存取令牌
#clone
clone.button=克隆
clone.dialog.clone.failed=克隆失敗
clone.dialog.directory.field=目錄:
clone.dialog.text=克隆 ''{0}''
clone.error.load.repositories=無法載入版本庫
clone.error.unable.to.create.dest.dir=無法創建目標目錄
clone.error.unable.to.find.dest=無法找到目標
#tasks
task.repo.host.field=主機:
task.repo.repository.field=版本庫:
task.repo.owner.field.empty.hint=版本庫所有者
task.repo.name.field.empty.hint=版本庫名稱
task.repo.token.field=API 令牌:
task.repo.token.field.empty.hint=OAuth2 令牌
task.repo.token.create.button=創建 API 令牌
task.comment.author=作者:
task.comment.date=日期:
#gist
create.gist.action.title=創建 Gist…
create.gist.action.description=創建 GitHub gist
create.gist.dialog.title=創建 Gist
create.gist.dialog.copy.url=複製 URL
create.gist.dialog.create.for.field=為以下帳戶創建:
create.gist.dialog.description.field=描述:
create.gist.dialog.filename.field=文件名:
create.gist.dialog.open.browser=在瀏覽器中打開
create.gist.dialog.secret=密鑰
create.gist.process=正在創建 gist…
create.gist.success=已成功創建 Gist
create.gist.url=您的 gist url
create.gist.error.empty=無法創建空 gist
create.gist.error.binary.file=無法上傳二進制檔案: {0}
create.gist.error.content.read=無法讀取檔案 {0} 的內容
#open on github
open.on.github.action=在 GitHub 上打開
action.Github.Open.In.Browser.EditorTabPopup.text=GitHub
open.on.github.action.description=在瀏覽器中打開相應鏈接
open.on.github.file.is.not.under.repository=檔案不在版本庫根下
open.on.github.getting.last.revision=正在獲取最新修訂
#rebase
rebase.action=同步復刻
rebase.action.description=相對於來源變基 GitHub 復刻版本庫
rebase.process=正在變基 GitHub 復刻…
rebase.process.adding.github.parent.as.remote.host=正在將 GitHub 父項添加為遠端主機…
rebase.process.configuring.upstream.remote=正在配置上游遠端…
rebase.process.fetching.upstream=正在獲取上游…
rebase.process.operation.title=正在變基
rebase.process.rebasing.branch.onto=正在將當前分支變基到 ''{0}''…
rebase.process.rebasing.onto=正在變基到 ''{0}''…
rebase.process.success=已成功變基 GitHub 復刻
rebase.error=無法執行 GitHub 變基
rebase.error.multi.repo.not.supported=不支持多版本庫專案
rebase.error.remote.origin.not.found=找不到 Git 遠端 'origin'
rebase.error.no.suitable.account.found=找不到合適的 GitHub 帳戶
rebase.error.failed.to.match.gh.repo=無法符合本地版本庫和 GitHub 版本庫
rebase.error.repo.not.found=找不到版本庫 {0}
rebase.error.upstream.not.found=未添加遠端 {0}
rebase.error.no.default.branch=無法確定上游分支 - 沒有為版本庫設定預設分支
#share
share.action=在 GitHub 上共享專案
share.action.description=在 GitHub 上輕鬆共享專案
share.action.remote.is.on.github=遠端已經在 GitHub 上:
share.action.remotes.are.on.github=GitHub 上已經有以下遠端:
share.anyway.button=仍然共享
share.on.github=在 GitHub 上共享專案
share.button=共享
share.dialog.account.info.load.error.prefix=無法載入 {0} 的資訊:
share.dialog.account.info.load.process.canceled=已取消進程
share.dialog.description=描述:
share.dialog.private=私有
share.dialog.remote=遠端:
share.dialog.repo.name=版本庫名稱:
share.dialog.share.by=共享者:
share.process.loading.account.info=正在載入 {0} 的帳戶資訊
share.process=正在 GitHub 上共享專案…
share.process.creating.git.repository=正在創建空 git 版本庫…
share.process.adding.files=正在將檔案添加到 git…
share.process.performing.commit=正在執行提交…
share.process.retrieving.username=正在檢索用戶名…
share.process.creating.repository=正在創建 GitHub 版本庫…
share.process.adding.gh.as.remote.host=正在將 GitHub 添加為遠端主機…
share.process.pushing.to.github.master=正在推送到 GitHub master…
share.process.empty.project.created=已在 GitHub 上成功創建空版本庫
share.process.successfully.shared=已在 GitHub 上成功共享專案
share.error.cannot.finish=無法完成 GitHub 共享過程
share.error.remote.with.selected.name.exists=已存在具有所選名稱的遠端
share.error.repo.with.selected.name.exists=已存在具有所選名稱的版本庫
share.error.failed.to.create.repo=無法創建 GitHub 版本庫
share.error.private.repos.not.supported=您的帳戶不支持私有版本庫
share.error.project.is.on.github=專案已在 GitHub 上
share.error.created.project=已在 GitHub 上成功創建專案
share.error.init.commit.failed=，但初始提交失敗:<br/>
share.error.push.failed=，但初始推送失敗:<br/>{0}
share.error.push.no.current.branch=，但初始推送失敗: 沒有當前分支
share.validation.no.remote.name=未選擇遠端名稱
share.validation.no.repo.name=未選擇版本庫名稱
share.validation.invalid.repo.name=版本庫名稱無效。名稱應由字母、數字、短划線、點和下划線組成
untracked.files.dialog.title=為初始提交添加檔案
#create PR
tab.title.pull.requests.new=在 {0} 新建拉取請求
pull.request.create.show.form.action=創建拉取請求…
pull.request.create.direction.base.repo=基礎版本庫:
pull.request.create.direction.head.repo=Head 版本庫:
pull.request.create.process.title=正在創建拉取請求…
pull.request.existing.process.title=正在檢查是否已存在拉取請求…
pull.request.create.title=標題
pull.request.create.description=描述
pull.request.create.loading.template=正在載入模板…
pull.request.create.input.remote.branch.name=遠端分支名稱:
pull.request.create.input.remote.branch.title=拉取請求分支
pull.request.create.input.remote.branch.comment=必須推送更改才能創建拉取請求，並且本地分支 ''{0}'' 不會跟踪 ''{1}'' 處的遠端分支
pull.request.create.action=創建拉取請求
pull.request.create.draft.action=創建草稿拉取請求
pull.request.create.discard.title=刪除拉取請求草稿
pull.request.create.discard.message=要刪除新拉取請求的草稿嗎?
pull.request.create.discard.approve=刪除草稿
pull.request.create.no.changes=''{0}'' 和 ''{1}'' 之間沒有變更
pull.request.create.already.exists=拉取請求已存在
pull.request.create.already.exists.view=查看
pull.request.create.select.branches=已選擇拉取請求的 base 和 head 來查看變更

pull.request.num=拉取請求 #{0,number,#}
# TW content
toolwindow.stripe.Pull_Requests=拉取請求
tab.title.pull.requests.at={0} 中的拉取請求
pull.request.view.list=查看拉取請求
pull.request.login.note=稍後在齒輪圖標下更改版本庫或帳戶
pull.request.change.remote.or.account=更改版本庫或帳戶…
pull.request.loading.data=正在載入資料…
pull.request.loading.account.info=正在載入帳戶資訊
pull.request.loading.repo.info=正在載入版本庫資訊
pull.request.loading.user.teams.info=正在載入使用者團隊資訊
pull.request.list.item.info=#{0,number,#} {1}，{2}
pull.request.list.no.matches=沒有與篩選器符合的拉取請求。
pull.request.list.nothing.loaded=無拉取請求
pull.request.list.outdated=該列表已過時。
pull.request.list.refresh=刷新
pull.request.list.search.history=搜尋歷史記錄 {0}
pull.request.list.reset.filters=重置篩選器
pull.request.list.cannot.load=無法載入拉取請求
pull.request.open.action=查看拉取請求
pull.request.select.action=選擇開放的拉取請求
pull.request.back.to.list=返回列表
pull.request.info=資訊
pull.request.files=檔案
pull.request.commits=提交
pull.request.select.commit.to.view.changes=選擇要查看變更的提交
pull.request.does.not.contain.changes=拉取請求不包含任何變更
pull.request.does.not.contain.commits=拉取請求不包含任何提交
pull.request.commit.does.not.contain.changes=提交不包含任何變更
pull.request.open.action.description=查看拉取請求資訊和時間線
pull.request.view.conversations.action=查看對話
pull.request.view.conversations.action.description=查看拉取請求時間線
pull.request.refresh.changes.action=刷新拉取請求變更
pull.request.refresh.comments.action=刷新拉取請求評論
pull.request.refresh.details.action=刷新拉取請求詳細資訊
pull.request.refresh.state.action=刷新拉取請求狀態
pull.request.refresh.list.action=刷新列表
pull.request.editor.diff=拉取請求差異
pull.request.editor.timeline=拉取請求時間線
#branch checkout
pull.request.branch.checkout.create.action=簽出本地分支…
pull.request.branch.checkout.create.action.description=簽出拉取請求分支
pull.request.branch.checkout.create.dialog.title=從拉取請求 {0,number,#} 創建分支
pull.request.branch.checkout.create.task.title=從拉取請求創建分支
pull.request.branch.checkout.create.task.indicator=正在創建分支
pull.request.branch.checkout.task.title=從拉取請求簽出分支
pull.request.branch.checkout.task.indicator=正在簽出分支
pull.request.branch.checkout.set.tracking.branch.failed=無法設定跟踪分支
pull.request.branch.checkout.resolve.author.failed=無法解析拉取請求作者
pull.request.branch.checkout.resolve.remote.failed=無法解析拉取請求遠端
#branch update
pull.request.branch.update.action=更新本地分支…
pull.request.branch.update.action.description=更新拉取請求本地分支
#branch actions
pull.request.branch.action.group.name=操作(&A)
# details
pull.request.assignees=被指派者
pull.request.unassigned=未分配
pull.request.labels=標籤
pull.request.no.labels=無標籤
pull.request.reviewers=審查者
pull.request.no.reviewers=無審查者
pull.request.adding.reviewers=正在添加審查者
pull.request.removing.reviewers=正在移除審查者
pull.request.adjustment.failed=無法調整列表
#state
pull.request.state.open=開放
pull.request.state.closed=已關閉
pull.request.state.merged=已合併
pull.request.state.draft=草稿
pull.request.state.closed.long=拉取請求已關閉
pull.request.state.merged.long=拉取請求已合併
pull.request.loading.status=正在載入拉取請求狀態
pull.request.state.cannot.load=無法載入狀態
pull.request.conflicts.checking=正在檢查自動合併的能力…
pull.request.conflicts.none=分支與基礎分支沒有衝突
pull.request.conflicts.must.be.resolved=分支存在必須解決的衝突
pull.request.branch.out.of.sync=拉取請求分支與基礎分支不同步
pull.request.checks.failing={0} 個失敗
pull.request.checks.pending={0} 個掛起
pull.request.checks.successful={0} 個成功
pull.request.checks={0, choice, 1#檢查|2#檢查}
pull.request.merge.commit.action=合併…
pull.request.merge.squash.action=壓縮並合併…
pull.request.merge.rebase.action=變基並合併
pull.request.merge.message.dialog.title=合併拉取請求
pull.request.merge.pull.request=合併拉取請求 #{0,number,#}
merge.commit.dialog.message=合併提交訊息:
merge.commit.dialog.merge.button=合併
pull.request.not.authorized.to.merge=您無權將拉取請求合併到此分支
pull.request.merge.disabled=此專案已禁用合併
pull.request.mark.ready.for.review=標記為可供審查
pull.request.close.action=關閉拉取請求
pull.request.reopen.action=重新打開拉取請求
pull.request.repo.access.required=必須具有版本庫存取權限才能管理拉取請求
pull.request.repo.write.access.required=必須具有版本庫寫存取權限才能合併拉取請求
pull.request.reviewers.required=需要由具有寫入權限的審查者至少進行 {0} 次審批審查
#review
pull.request.diff.review.label=審查:
pull.request.diff.view.options=檢視選項
pull.request.diff.editor.title=拉取請求 #{0,number,#} 的差異
pull.request.new.diff.editor.title=新拉取請求的差異
pull.request.diff.editor.add.review.comment=添加審查評論
pull.request.diff.editor.add.single.comment=添加一條評論
pull.request.diff.editor.add.multiline.comment=添加一條多行評論
pull.request.diff.editor.start.review.with.multiline.comment=以多行評論開始審查
pull.request.diff.editor.add.multiline.review.comment=添加多行審查評論
pull.request.diff.editor.review.comment=評論
pull.request.diff.editor.review.start=開始審查
pull.request.diff.editor.review.with.comment=以評論開始審查
pull.request.review.submit.request.changes=請求變更
pull.request.review.submit.approve.button=批准
pull.request.review.submit.comment.button=評論
pull.request.review.submit.comment.description=提交不需要明確批准的常規反饋
pull.request.review.submit.error=提交審查時發生錯誤
pull.request.review.comment.delete.dialog.msg=確定要刪除此評論嗎?
pull.request.review.comment.delete.dialog.title=刪除評論
pull.request.discard.pending.comments.dialog.title=放棄待定審查
pull.request.discard.pending.comments.dialog.msg=確定要刪除所有待定評論嗎?
pull.request.discard.pending.comments=放棄待定評論
pull.request.review.comment.pending=待定
pull.request.review.comment.resolved=已解決
pull.request.review.comment.empty.text=審查評論
pull.request.review.commented={0} 在 {1} 添加了評論
pull.request.review.show.comments.action=顯示評論
pull.request.review.show.comments.action.description=顯示或隱藏拉取請求審查執行緒
pull.request.review.show.resolved.threads=顯示已解決的執行緒
pull.request.review.show.resolved.threads.description=顯示或隱藏已解決的拉取請求審查執行緒
pull.request.review.submit=提交
pull.request.review.submit.review=提交審查
pull.request.review.pending.comments.count={0} 個待定{0, choice, 1#註釋|2#註釋}
pull.request.review.submit.action.description=提交拉取請求審查
pull.request.review.thread.outdated=過時
pull.request.review.thread.reply=回復
pull.request.review.thread.resolve=解決
pull.request.review.thread.unresolve=取消解決
pull.request.review.refresh.data.task=刷新審查資料
pull.request.review.refresh.data.task.description=刷新 GitHub 拉取請求審查資訊
#timeline
pull.request.timeline.refresh.action=刷新時間線
pull.request.timeline.refresh.action.description=檢查新時間線事件
pull.request.timeline.and=和
pull.request.timeline.created=已創建
pull.request.timeline.commented=添加了評論
pull.request.timeline.added.label=添加了 {0} 標籤
pull.request.timeline.added.labels=添加了標籤
pull.request.timeline.removed.label=移除了 {0} 標籤
pull.request.timeline.removed.labels=移除了標籤
pull.request.timeline.assigned=分配給
pull.request.timeline.unassigned=取消分配給
pull.request.timeline.renamed=將此請求從 <b>{0}</b> 重命名為 <b>{1}</b>
pull.request.timeline.reopened=重新打開了此請求
pull.request.timeline.closed=關閉了此請求
pull.request.timeline.merged=合併了此請求
pull.request.timeline.merged.commit=已將提交 {0} 合併到 {1}
pull.request.timeline.requested.review=請求以下使用者執行審查:
pull.request.timeline.removed.review.request=移除了向以下使用者發出的審查請求:
pull.request.timeline.started.review=開始了審查
pull.request.timeline.reviewed=審查了
pull.request.timeline.review.thread.collapse=隱藏執行緒
pull.request.timeline.review.thread.expand=顯示執行緒
pull.request.timeline.approved.changes=批准了這些變更
pull.request.timeline.requested.changes=請求了變更
pull.request.timeline.marked.as.draft=將此拉取請求標記為草稿
pull.request.timeline.marked.as.ready=將此拉取請求標記為可供審查
pull.request.timeline.mentioned=提及了此物件
pull.request.timeline.connected=鏈接了可能由此物件關閉的問題
pull.request.timeline.disconnected=移除了一個指向問題的鏈接
pull.request.timeline.stale.review.dismissed=忽略了 <b>{0}</b> 過時的審查
pull.request.timeline.stale.review.author=作者
pull.request.timeline.changed.base.branch=更改了基礎分支
pull.request.timeline.branch.deleted=刪除了 {0} 分支
pull.request.timeline.branch.force.pushed=強制推送了 {0} 分支
pull.request.timeline.branch.head.restored=恢復了 head 分支
pull.request.timeline.cannot.load=無法載入時間線條目
#various errors
cannot.collect.additional.data=無法收集其他資料
cannot.collect.diff.data=無法收集差異資料
cannot.configure.remote=無法配置 ''{0}'' 遠端:\\\\n{1}
cannot.create.gist=無法創建 Gist
cannot.display.item=無法顯示條目 - {0}
cannot.find.fork=無法找到所選用戶的復刻
cannot.find.git.repo=無法找到 Git 版本庫
cannot.find.repository=無法找到版本庫
cannot.get.last.revision=無法獲取最新修訂。
cannot.get.user.info=無法獲取使用者資訊
cannot.load.changes=無法載入變更
cannot.load.commits=無法載入提交
cannot.load.data.from.github=無法從 GitHub 載入資料
cannot.load.data=無法載入資料
cannot.load.details=無法載入詳細資訊
cannot.load.repo.info=無法載入版本庫資訊
cannot.open.in.browser=無法在瀏覽器中打開
cannot.process.remote=無法處理遠端: {0}
cannot.retrieve.upstream.info=無法檢索 {0} 的上游資訊
unknown.loading.error=未知載入錯誤
server.unreachable=伺服器無法到達
gql.error.in.field={1} 的“{2}”欄位中存在 {0} 錯誤
pull.request.review.not.supported.non.linear=非線性提交歷史記錄不支持按提交審查
#issues
issue.state.open=開放
issue.state.closed=已關閉

#protected branches
progress.text.loading.protected.branches=正在載入 GitHub 分支保護規則

pull.request.details.adjusting.reviewers=正在調整審查者…
pull.request.details.adjusting.assignees=正在調整被指派者…
pull.request.details.adjusting.labels=正在調整標籤…
accounts.add.dropdown.link=添加帳戶
accounts.add.button=添加帳戶
account.scopes.insufficient=安全範圍不足
pull.request.create.error=無法創建新的拉取請求:
pull.request.list.reset.filters.to.default=重置為{0}
action.GithubCopyPathProvider.text=GitHub 版本庫 URL"
`;

exports[`src messages/InspectionGadgetsBundle.properties 1`] = `
"cast.to.concrete.class.problem.descriptor=轉換為具體類 <code>{0}</code> #loc
class.references.subclass.display.name=類引用其子類之一
class.references.subclass.problem.descriptor=類 ''{0}'' 引用子類 <code>#ref</code> #loc
class.references.subclass.problem.descriptor.anonymous=匿名類引用子類 <code>#ref</code> #loc
collection.declared.by.class.display.name=按類 (而不是接口) 宣告的集合
collection.declared.by.class.problem.descriptor=<code>#ref</code> 的宣告可能應當被削弱為 ''{0}'' #loc
collection.declared.by.class.ignore.locals.option=忽略局部變數
collection.declared.by.class.ignore.private.members.option=忽略 'private' 欄位和方法
feature.envy.display.name=特性依戀
feature.envy.problem.descriptor=類 ''{0}'' 在方法 <code>#ref()</code> 中被重複存取 #loc
bounded.wildcard.display.name=可以使用有界萬用字元
bounded.wildcard.contravariant.descriptor=可以泛化為 <code>? super #ref</code> #loc
bounded.wildcard.covariant.descriptor=可以泛化為 <code>? extends #ref</code> #loc
bounded.wildcard.report.invariant.option=報告固定類
bounded.wildcard.report.private.option=報告 private 方法
bounded.wildcard.report.instance.option=報告實例方法
instance.variable.of.concrete.class.problem.descriptor=具體類 <code>#ref</code> 的實例欄位 ''{0}'' #loc
chain.of.instanceof.checks.display.name='instanceof' 檢查鏈
chain.of.instanceof.checks.problem.descriptor='instanceof' 檢查鏈指示抽象失敗 #loc
chain.of.class.equality.checks.problem.descriptor=類相等檢查鏈指示抽象失敗 #loc
instanceof.concrete.class.problem.descriptor='instanceof' 具體類 <code>#ref</code> #loc
instanceof.concrete.class.equality.problem.descriptor=與具體類 <code>#ref</code> 的類比較 #loc
instanceof.check.for.this.display.name='this' 的 'instanceof' 檢查
instanceof.check.for.this.problem.descriptor=<code>#ref</code> 的 'instanceof' 檢查 #loc
instanceof.check.for.this.equality.problem.descriptor='this' 的類比較 #loc
local.variable.of.concrete.class.problem.descriptor=具體類 <code>#ref</code> 的局部變數 ''{0}'' #loc
magic.number.display.name=幻數
magic.number.problem.descriptor=幻數 <code>#ref</code> #loc
concrete.class.use.display.name=具體類的使用
method.return.concrete.class.problem.descriptor=方法返回一個具體類 <code>#ref</code> #loc
overly.strong.type.cast.display.name=過強的類型轉換
overly.strong.type.cast.weaken.quickfix=削弱過強的轉換
concrete.class.method.parameter.problem.descriptor=具體類 <code>#ref</code> 的參數 ''{0}'' #loc
public.method.not.in.interface.display.name='public' 方法在接口中未公開
public.method.not.in.interface.problem.descriptor='public' 方法 <code>#ref()</code> 未通過接口公開 #loc
public.method.not.in.interface.option=<html>如果包含類未實作非庫接口，則忽略</html>
static.variable.of.concrete.class.problem.descriptor=具體類 <code>#ref</code> 的 static 欄位 ''{0}'' #loc
incompatible.mask.operation.display.name=不相容的位元遮罩運算
incompatible.mask.operation.problem.descriptor.always.false=<code>#ref</code> 始終為 false #loc
incompatible.mask.operation.problem.descriptor.always.true=<code>#ref</code> 始終為 true #loc
pointless.bitwise.expression.display.name=無意義的按位表達式
pointless.bitwise.expression.simplify.quickfix=簡化
shift.operation.by.inappropriate.constant.display.name=按不當常數進行移位運算
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=對 <code>#ref</code> 進行移位運算時使用的常量值 {0} 過大 #loc
shift.operation.by.inappropriate.constant.problem.descriptor.negative=對 <code>#ref</code> 進行移位運算時使用的常量值 {0} 為負 #loc
shift.operation.by.inappropriate.constant.problem.descriptor.out.of.bounds=按超出範圍的值 {0} 進行移位運算 <code>#ref</code> #loc
equals.called.on.array.display.name=在陣列上調用了 'equals()'
equals.called.on.array.problem.descriptor=陣列之間的 <code>#ref()</code> 可能應當是 'Arrays.equals()' #loc
assignment.to.null.display.name='null' 賦值
assignment.to.null.problem.descriptor='null' 已賦值給變數 <code>#ref</code> #loc
assignment.to.null.option=忽略對欄位的賦值
assignment.to.static.field.from.instance.method.display.name=從實例上下文賦值給 static 欄位
assignment.to.static.field.from.instance.method.problem.descriptor=從實例上下文賦值給 static 欄位 <code>#ref</code> #loc
assignment.used.as.condition.display.name=用作條件的賦值
assignment.used.as.condition.problem.descriptor=賦值 <code>#ref</code> 作為條件使用 #loc
cast.conflicts.with.instanceof.display.name=轉換與 'instanceof' 衝突
cast.conflicts.with.instanceof.problem.descriptor=轉換為 ''{0}'' 類型將與前面的 ''instanceof {1}'' 檢查衝突
casting.to.incompatible.interface.display.name=轉換為不相容的接口
casting.to.incompatible.interface.problem.descriptor=轉換為不相容的接口 <code>#ref</code> #loc
collection.added.to.self.display.name=集合已添加到自身
collection.added.to.self.problem.descriptor=在以自身作為實參的集合 <code>#ref</code> 上調用了 ''{0}()'' #loc
non.final.field.compareto.display.name='compareTo()' 中引用了非最終欄位
non.final.field.compareto.problem.descriptor=在 'compareTo()' 中存取了非 final 欄位 <code>#ref</code> #loc
covariant.equals.display.name=協變 'equals()'
covariant.equals.problem.descriptor=<code>#ref()</code> 應當以 'Object' 作為其實參 #loc
empty.class.initializer.display.name=空類初始值設定項
empty.class.initializer.problem.descriptor=空類初始值設定項 #loc
empty.class.initializer.delete.quickfix=刪除空類初始值設定項
statement.with.empty.body.display.name=帶空體的語句
statement.with.empty.body.problem.descriptor=<code>#ref</code> 語句具有空體 #loc
statement.with.empty.body.include.option=包含空程式碼塊語句正文
equals.between.inconvertible.types.display.name='equals()' 位於不可轉換類型的物件之間
equals.between.inconvertible.types.problem.descriptor=<code>#ref</code> 位於 ''{0}'' 和 ''{1}'' 不可轉換類型的物件之間 #loc
equals.between.inconvertible.types.no.mutual.subclass.problem.descriptor=未找到屬於 ''{0}'' 和 ''{1}'' 這兩個子類型的類 #loc
equals.between.inconvertible.types.mutual.subclass.option=如果未找到相互子類，則發出警告
equals.called.on.suspicious.object.display.name=在 'StringBuilder'上調用了 'equals()'
equals.called.on.suspicious.object.problem.descriptor=''{0}'' 物件上存在可疑的 ''equals()'' 調用
non.final.field.in.equals.display.name='equals()' 中引用了非最終欄位
non.final.field.in.equals.problem.descriptor=在 'equals()' 中存取了非 final 欄位 <code>#ref</code> #loc
equals.doesnt.check.class.parameter.display.name=不檢查參數的類的 'equals()' 方法
equals.doesnt.check.class.parameter.problem.descriptor=<code>#ref()</code> 應當檢查其參數的類 #loc
non.final.field.in.hashcode.display.name='hashCode()' 中引用了非最終欄位
non.final.field.in.hashcode.problem.descriptor=在 'hashCode()' 中存取了非 final 欄位 <code>#ref</code> #loc
result.of.method.call.ignored.display.name=方法調用的結果已忽略
write.only.object.display.name=只寫入物件
write.only.object.option.ignore.impure.constructors=忽略不純的構造函數
result.of.method.call.ignored.problem.descriptor=<code>{0}.#ref()</code> 的結果已忽略 #loc
result.of.method.call.ignored.class.column.title=類名
result.of.method.call.ignored.method.column.title=方法名稱正則表達式
result.of.method.call.ignored.non.library.option=報告所有忽略的非庫調用
infinite.recursion.display.name=無限遞歸
infinite.recursion.problem.descriptor=方法 <code>#ref()</code> 無限遞歸，只能以拋出異常結束 #loc
instanceof.with.incompatible.interface.display.name=具有不相容接口的 'instanceof'
instanceof.with.incompatible.interface.problem.descriptor=具有不相容接口 <code>#ref</code> 的 'instanceof' #loc
instantiation.utility.class.display.name=實用程序類的實例化
instantiation.utility.class.problem.descriptor=實用程序類 <code>#ref</code> 的實例化 #loc
iterator.hasnext.which.calls.next.display.name=調用 'next()' 的 'Iterator.hasNext()'
iterator.hasnext.which.calls.next.problem.descriptor=<code>Iterator.{0}()</code> 包含 ''#ref()'' 調用 #loc
iterator.next.does.not.throw.nosuchelementexception.display.name=無法拋出 'NoSuchElementException' 的 'Iterator.next()'
malformed.format.string.display.name=字串的格式錯誤
malformed.format.string.problem.descriptor.malformed=格式字串 <code>#ref</code> 的格式錯誤 #loc
malformed.format.string.problem.descriptor.illegal=非法格式字串指定符: {0} #loc
malformed.format.string.problem.descriptor.too.many.arguments=格式字串的實參太多(實際: {0}，應為: {1}) #loc
malformed.format.string.problem.descriptor.too.few.arguments=格式字串的實參太少(實際: {0}，應為: {1}) #loc
malformed.format.string.problem.descriptor.arguments.do.not.match.type=實參類型 ''{0}'' 與格式說明符 ''{1}'' 的類型不符合 #loc
format.string.error.flags.not.allowed=''{1}'' 中不允許使用{2, choice, 1#標誌|1<標誌} ''{0}''
format.string.error.unexpected.flag=''{1}'' 中出現意外字符 ''{0}''
format.string.error.duplicate.flag=''{1}'' 中存在重複的標誌 ''{0}''
format.string.error.width.not.allowed=''{1}'' 中不允許該寬度 (''{0}'')
format.string.error.precision.not.allowed=''{1}'' 中不允許該精度 (''{0}'')
format.string.error.unnecessary.position.specifier=''{1}'' 存在不必要的實參位置說明符 ''{0}''
format.string.error.illegal.position.specifier=''{1}'' 存在非法的位置說明符 ''{0}''
format.string.error.previous.element.not.found=使用了以前的標誌 '<'，但沒有找到 ''{0}'' 以前的格式說明符
format.string.error.unknown.conversion=''{0}'' 中存在未知的轉換
format.string.error.invalid.precision=''{0}'' 中指定的精度無效
format.string.error.illegal.flag.combination=''{2}'' 中的標誌組合 ''{0}'' 和 ''{1}'' 非法
format.string.error.left.justify.no.width=使用了左對齊標誌 ''-''，但 ''{0}'' 中未指定寬度
format.string.error.zero.padding.no.width=使用了零填充標誌 ''0''，但 ''{0}'' 中未指定寬度
mismatched.read.write.array.display.name=陣列的讀取和寫入不符合
mismatched.read.write.array.problem.descriptor.write.not.read=陣列 <code>#ref</code> 的內容已寫入，但從未被讀取 #loc
mismatched.read.write.array.problem.descriptor.read.not.write=陣列 <code>#ref</code> 的內容已讀取，但從未被寫入 #loc
mismatched.update.collection.display.name=不符合的集合查詢和更新
mismatched.update.collection.problem.descriptor.updated.not.queried=集合 <code>#ref</code> 的內容已更新，但從未被查詢 #loc
mismatched.update.collection.problem.description.queried.not.updated=集合 <code>#ref</code> 的內容已被查詢，但從未更新 #loc
rename.quickfix=重命名
renameto.quickfix=重命名為 ''{0}''
misspelled.equals.display.name='equal()' 代替 'equals()'
misspelled.equals.problem.descriptor=<code>#ref()</code> 方法可能應當是 'equals()' #loc
non.short.circuit.boolean.expression.display.name=非短路邏輯布爾表達式
non.short.circuit.boolean.expression.problem.descriptor=非短路邏輯布爾表達式 <code>#ref</code> #loc
non.short.circuit.boolean.expression.replace.quickfix=取代為短路表達式
null.argument.to.var.arg.method.display.name=引起混淆的 vararg 方法實參
null.argument.to.var.arg.method.problem.descriptor=引起混淆的實參 <code>#ref</code>，不清楚是否需要 vararg 或非 vararg 調用 #loc
primitive.array.argument.to.var.arg.method.display.name=引起混淆的 vararg 方法基元陣列實參
primitive.array.argument.to.var.arg.method.problem.descriptor=引起混淆的 vararg 方法基元陣列實參 #loc
object.comparison.display.name=使用 '==' 而不是 'equals()' 進行物件比較
object.comparison.enumerated.ignore.option=忽略枚舉變數之間的 '=='
object.comparison.klass.ignore.option=忽略沒有 'equals()' 實作的 final 類類型之間的 '=='
object.comparison.problem.description=使用 <code>#ref</code> 而不是 'equals()' 來比較物件值 #loc
equality.to.safe.equals.quickfix=用 null 安全 'equals()' 取代 '=='
inequality.to.safe.not.equals.quickfix=用 null 安全 '!equals()' 取代 '!='
default.tostring.call.display.name=調用預設 'toString()'
default.tostring.call.problem.descriptor=調用 <code>#ref</code> 上的預設 'toString()' #loc
octal.and.decimal.integers.in.same.array.display.name=同一陣列中的八進制和十進制整數
octal.and.decimal.integers.in.same.array.problem.descriptor=同一陣列初始值設定項中的八進制和十進制整數 #loc
result.of.object.allocation.ignored.display.name=物件分配的結果已忽略
result.of.object.allocation.ignored.problem.descriptor=<code>new #ref()</code> 的結果已忽略 #loc
result.of.object.allocation.ignored.options.chooserTitle=選擇可以忽略物件分配的類
result.of.object.allocation.fix.name=忽略類型 ''{0}'' 的物件的分配
use.0index.in.jdbc.resultset.display.name=在 JDBC ResultSet 中使用索引 0
use.0index.in.jdbc.resultset.problem.descriptor=在 JDBC ResultSet 中使用索引 '0' #loc
use.0index.in.jdbc.prepared.statement.problem.descriptor=在 JDBC PreparedStatement 中使用索引 '0' #loc
return.of.null.display.name=返回 'null'
return.of.null.problem.descriptor=返回 <code>#ref</code> #loc
return.of.null.arrays.option=報告返回陣列的方法
return.of.null.objects.option=報告返回物件的方法
return.of.null.collections.option=報告返回集合物件的方法
return.of.null.ignore.private.option=忽略 'private' 方法、匿名類和 lambda
static.method.via.subclass.display.name=static 方法通過子類引用
static.method.via.subclass.problem.descriptor=static 方法 <code>#ref()</code> 在類 ''{0}'' 中宣告，但通過子類 ''{1}'' 引用 #loc
static.method.via.subclass.rationalize.quickfix=使 static 方法調用合理化
static.field.via.subclass.display.name=static 欄位通過子類引用
static.field.via.subclass.problem.descriptor=static 欄位 <code>#ref</code> 在類 ''{0}'' 中宣告，但通過子類 ''{1}'' 引用 #loc
static.field.via.subclass.rationalize.quickfix=使 static 欄位存取合理化
string.comparison.display.name=使用 '==' 而不是 'equals()' 進行字串比較
number.comparison.display.name=使用 '==' 而不是 'equals()' 進行數字比較
string.comparison.problem.descriptor=使用 <code>#ref</code> 而不是 'equals()' 來比較字串值 #loc
number.comparison.problem.descriptor=使用 <code>#ref</code> 而不是 'equals()' 來比較數字物件 #loc
subtraction.in.compareto.display.name='compareTo()' 中的減法
subtraction.in.compareto.problem.descriptor='compareTo()' 中的減法 <code>#ref</code> 可能導致溢出或精度損失 #loc
text.label.in.switch.statement.display.name='switch' 語句中的文本標籤
text.label.in.switch.statement.problem.descriptor='switch' {0, choice, 1#語句|2#表達式}中存在文本標籤 <code>#ref:</code> #loc
properties.object.as.hashtable.display.name=將 'Properties' 物件用作 'Hashtable'
properties.object.as.hashtable.problem.descriptor=在屬性物件上調用 <code>Hashtable.#ref()</code> #loc
assignment.replaceable.with.operator.assignment.display.name=賦值可以取代為運算符賦值
unnecessary.code.block.display.name=不必要的程式碼塊
unnecessary.code.block.unwrap.quickfix=解開塊
redundant.local.variable.display.name=冗餘局部變數
redundant.local.variable.ignore.option=忽略立即返回或拋出的變數
redundant.local.variable.annotation.option=忽略具有註解的變數
static.collection.display.name=靜態集合
static.collection.problem.descriptor=靜態集合 <code>#ref</code> #loc
static.collection.ignore.option=忽略弱靜態集合或映射
stringbuffer.field.display.name='StringBuilder' 欄位
stringbuffer.field.problem.descriptor=''{0}'' 欄位 <code>#ref</code> #loc
gc.call.display.name=調用 'System.gc()' 或 'Runtime.gc()'
gc.call.problem.descriptor=<code>#ref</code> 不應在生產程式碼中調用 #loc
array.allocation.zero.length.display.name=零長度陣列分配
array.allocation.zero.length.problem.descriptor=零長度陣列的分配 #loc
constant.for.zero.length.array.display.name=不必要的零長度陣列用法
constant.for.zero.length.array.problem.descriptor=零長度陣列可更改為常數 #loc
constant.for.zero.length.array.quickfix.family=取代為常數
multiple.loggers.display.name=具有多個記錄器的類
logger.name.option=記錄器類名(&C):
multiple.loggers.problem.descriptor=類 <code>#ref</code> 宣告多個記錄器 #loc
no.logger.display.name=不帶記錄器的類
no.logger.problem.descriptor=類 <code>#ref</code> 未宣告記錄器 #loc
non.constant.logger.display.name=非常數記錄器
non.constant.logger.problem.descriptor=非常數記錄器欄位 <code>#ref</code> #loc
public.method.without.logging.display.name='public' 方法沒有日誌記錄
public.method.without.logging.problem.descriptor='public' 方法 <code>#ref()</code> 沒有日誌調用 #loc
ignore.trivial.finalizers.option=對普通 'finalize()' 實作忽略
finalize.declaration.display.name='finalize()' 不應被覆寫
finalize.declaration.problem.descriptor='finalize()' 不應被覆寫 #loc
finalize.not.declared.protected.display.name='finalize()' 應為 protected，不應為 public
finalize.not.declared.protected.problem.descriptor='finalize()' 應具有 protected 存取權限，不應具有 public 存取權限 #loc
finalize.called.explicitly.display.name='finalize()' 被顯式調用
finalize.called.explicitly.problem.descriptor=<code>#ref()</code> 被顯式調用 #loc
java.lang.import.display.name='java.lang' 軟體套件中有不必要的 import
java.lang.import.problem.descriptor='java.lang' 軟體套件中有不必要的 import #loc
import.display.name='*' 匯入
import.problem.descriptor=軟體套件匯入 <code>#ref</code> #loc
import.from.same.package.display.name=相同軟體套件中的不必要 import
import.from.same.package.problem.descriptor=相同軟體套件 <code>#ref</code> 中有不必要的 import #loc
single.class.import.display.name=單個類匯入
single.class.import.problem.descriptor=單個類匯入 <code>#ref</code> #loc
static.import.display.name=靜態匯入
static.import.problem.descriptor=靜態匯入 <code>#ref</code>  #loc
static.import.replace.quickfix=取代為非靜態匯入
static.import.fix.ignore.class=允許類 ''{0}'' 的靜態匯入
static.import.options.border.title=靜態可匯入類:
static.import.options.chooserTitle=選擇靜態可匯入類
unused.import.problem.descriptor=未使用的 import <code>#ref</code> #loc
clone.instantiates.objects.with.constructor.display.name='clone()' 用構造函數實例化物件
clone.instantiates.objects.with.constructor.problem.descriptor='clone()' 創建新的 <code>#ref</code> 實例 #loc
clone.instantiates.new.array.problem.descriptor=''clone()'' 創建新的 {0} 陣列 #loc
clone.doesnt.declare.clonenotsupportedexception.display.name='clone()' 未宣告 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.problem.descriptor=<code>#ref()</code> #loc 未宣告 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.declare.quickfix=將 'CloneNotSupportedException' 添加到 throws 子句
clone.method.in.non.cloneable.class.display.name=不可克隆類中的 'clone()' 方法
clone.method.in.non.cloneable.class.problem.descriptor=<code>#ref()</code> 在不可克隆類 ''{0}'' 中定義 #loc
clone.method.in.non.cloneable.anonymous.class.problem.descriptor=<code>#ref()</code> 在派生自 ''{0}'' 的不可克隆匿名類中定義 #loc
clone.method.in.non.cloneable.interface.problem.descriptor=<code>#ref()</code> 在不可克隆接口 ''{0}'' 中定義 #loc
cloneable.class.without.clone.display.name=沒有 'clone()' 方法的可克隆類
cloneable.class.without.clone.problem.descriptor=<code>#ref</code> 為 'Cloneable'，但未定義 'clone()' 方法 #loc
cloneable.class.without.clone.ignore.option=忽略由於繼承而可克隆的類
cloneable.class.without.clone.quickfix=生成 'clone()' 方法
use.obsolete.collection.type.display.name=使用廢棄的集合類型
use.obsolete.collection.type.problem.descriptor=使用了廢棄的集合類型 <code>#ref</code> #loc
use.obsolete.collection.type.ignore.library.arguments.option=在需要的位置忽略廢棄的集合類型
inspection.suppression.annotation.display.name=檢查禁止註解
inspection.suppression.annotation.problem.descriptor=檢查禁止註解 <code>#ref</code> #loc
use.system.out.err.display.name=使用 'System.out' 或 'System.err'
use.system.out.err.problem.descriptor=<code>#ref</code> 的使用可能應當取代為更可靠的日誌 #loc
dumpstack.call.display.name=調用 'Thread.dumpStack()'
dumpstack.call.problem.descriptor=對 <code>Thread.#ref()</code> 的調用可能應當取代為更可靠的日誌 #loc
printstacktrace.call.display.name=調用 'printStackTrace()'
printstacktrace.call.problem.descriptor=對 <code>#ref()</code> 的調用可能應當取代為更可靠的日誌 #loc
abstract.method.call.in.constructor.display.name=物件構造期間調用的 abstract 方法
abstract.method.call.in.constructor.problem.descriptor=物件構造期間調用 'abstract' 方法 <code>#ref()</code> #loc
instance.variable.may.not.be.initialized.display.name=實例欄位可能無法初始化
instance.variable.may.not.be.initialized.problem.descriptor=實例欄位 <code>#ref</code> 在物件構造期間可能無法初始化 #loc
instance.Variable.may.not.be.initialized.problem.descriptor.junit=實例欄位 <code>#ref</code> 在物件構造或 'setUp()' 調用期間可能無法初始化 #loc
primitive.fields.ignore.option=忽略原始欄位
instance.variable.used.before.initialized.display.name=實例欄位在初始化前使用
instance.variable.used.before.initialized.problem.descriptor=初始化前使用的實例欄位 <code>#ref</code> #loc
non.final.static.variable.initialization.display.name=在類初始化期間使用非 final static 欄位
non.final.static.variable.initialization.problem.descriptor=在類初始化期間使用非 final static 欄位 <code>#ref</code> #loc
overridable.method.call.in.constructor.display.name=物件構造期間調用的可覆寫方法
overridable.method.call.in.constructor.problem.descriptor=物件構造期間調用可覆寫方法 <code>#ref()</code> #loc
overridden.method.call.in.constructor.display.name=覆寫的方法在物件構造期間調用
overridden.method.call.in.constructor.problem.descriptor=物件構造期間調用已覆寫方法 <code>#ref()</code> #loc
static.variable.may.not.be.initialized.display.name=static 欄位可能無法初始化
static.variable.may.not.be.initialized.problem.descriptor=static 欄位 <code>#ref</code> 在類初始化期間可能無法初始化 #loc
static.variable.used.before.initialization.display.name=static 欄位在初始化前使用
static.variable.used.before.initialization.problem.descriptor=static 欄位 <code>#ref</code> 在初始化前使用 #loc
this.reference.escaped.in.construction.display.name=物件構造中轉義的 'this' 引用
this.reference.escaped.in.construction.problem.descriptor=物件構造期間轉義 <code>#ref</code> #loc
assignment.to.catch.block.parameter.display.name=賦值給 'catch' 塊參數
extract.parameter.as.local.variable.quickfix=提取參數作為局部變數
assignment.to.for.loop.parameter.display.name=賦值給 'for' 迴圈參數
assignment.to.for.loop.parameter.check.foreach.option=檢查增強型 'for' 迴圈參數
assignment.to.for.loop.parameter.problem.descriptor=賦值給 for 迴圈參數 <code>#ref</code> #loc
assignment.to.method.parameter.display.name=賦值給方法參數
chained.equality.comparisons.display.name=鏈式相等比較
confusing.octal.escape.sequence.display.name=引起混淆的八進制轉義序列
increment.decrement.display.name=使用 '++' 或 '--' 的結果
nested.assignment.display.name=嵌套賦值
nested.assignment.problem.descriptor=使用的賦值表達式的結果 #loc
overloaded.methods.with.same.number.parameters.display.name=具有相同參數數量的多載方法
overloaded.vararg.method.display.name=多載 vararg 方法
refused.bequest.display.name=方法不調用 super 方法
reuse.of.local.variable.display.name=局部變數的重用
reuse.of.local.variable.split.quickfix=拆分局部變數
character.comparison.display.name=字符比較
character.comparison.problem.descriptor=國際化上下文中的字符比較 <code>#ref</code> #loc
package.visible.field.display.name=軟體套件可見欄位
package.visible.field.problem.descriptor=軟體套件可見欄位 <code>#ref</code> #loc
package.visible.inner.class.display.name=軟體套件可見的嵌套類
package.visible.inner.class.problem.descriptor=軟體套件可見的嵌套類 <code>#ref</code> #loc
package.visible.inner.class.ignore.enum.option=忽略軟體套件可見的內部枚舉
package.visible.inner.class.ignore.interface.option=忽略軟體套件可見的內部接口
protected.field.display.name=protected 欄位
protected.field.problem.descriptor=protected 欄位 <code>#ref</code> #loc
protected.inner.class.display.name=protected 嵌套類
protected.inner.class.problem.descriptor=protected 嵌套類 <code>#ref</code> #loc
protected.inner.class.ignore.enum.option=忽略 'protected' 內部枚舉
protected.inner.class.ignore.interface.option=忽略 'protected' 內部接口
public.field.display.name='public' 欄位
public.field.problem.descriptor='public' 欄位 <code>#ref</code> #loc
public.field.ignore.enum.type.fields.option=忽略枚舉類型的 'public final' 欄位
public.inner.class.display.name='public' 嵌套類
public.inner.class.problem.descriptor='public' 嵌套類 <code>#ref</code> #loc
public.inner.class.ignore.enum.option=忽略 'public' 內部枚舉
public.inner.class.ignore.interface.option=忽略 'public' 內部接口
accessing.non.public.field.of.another.object.display.name=存取另一個物件的非 public 欄位
accessing.non.public.field.of.another.object.problem.descriptor=直接存取另一個物件的非 public 欄位 <code>#ref</code> #loc
call.to.date.tostring.display.name=調用 'Date.toString()'
call.to.date.tostring.problem.descriptor=國際化上下文中使用的 <code>Date.#ref()</code> #loc
magic.character.display.name=魔幻字符
magic.character.problem.descriptor=國際化上下文中使用的魔幻字符 <code>#ref</code> #loc
call.to.numeric.tostring.display.name=調用 'Number.toString()'
call.to.numeric.tostring.problem.descriptor=國際化上下文中調用的 <code>Number.#ref()</code> #loc
instantiating.simpledateformat.without.locale.display.name=無區域設定的 'SimpleDateFormat'
instantiating.simpledateformat.without.locale.problem.descriptor=在未在國際化上下文中指定區域設定的情況下實例化 <code>#ref</code> #loc
string.concatenation.display.name=字串串聯
string.concatenation.problem.descriptor=國際化上下文中的字串串聯 <code>#ref</code> #loc
inspection.option.ignore.system.out=對 'System.out.print' 實參忽略
inspection.option.ignore.system.err=對 'System.err.print' 實參忽略
inspection.option.ignore.assert=對斷言語句描述實參忽略
inspection.option.ignore.exceptions=對 Throwable 子類的構造函數實參忽略
inspection.option.ignore.nonnls=通過 @NonNls 進行註解時忽略
inspection.option.ignore.constant.initializers=對常數欄位的初始值設定項忽略
inspection.option.ignore.in.annotations=在註解中忽略
inspection.option.ignore.in.tostring=在 toString() 方法內部忽略
inspection.option.ignore.as.initial.capacity=忽略 StringBuilders 和 Collections 的初始容量
inspection.option.ignore.in.hashcode=忽略 'hashCode()' 方法中的常數
string.touppercase.tolowercase.without.locale.display.name=調用無區域設定的 'String.toUpperCase()' 或 'toLowerCase()'
string.touppercase.tolowercase.without.locale.problem.descriptor=在未使用國際化字串指定區域設定的情況下調用 <code>String.#ref()</code> #loc
use.stringtokenizer.display.name=使用 'StringTokenizer'
use.stringtokenizer.problem.descriptor=國際化上下文中的 <code>#ref</code> #loc
time.tostring.call.display.name=調用 'Time.toString()'
time.tostring.call.problem.descriptor=國際化上下文中的 <code>Time.#ref()</code> #loc
class.escapes.defined.scope.display.name=公開不可存取的 'class'
class.escapes.defined.scope.display.module.option=模組的 API 公開未匯出的類(Java 9+)
class.escapes.defined.scope.display.public.option=公共 API 公開不可存取的類
class.escapes.defined.scope.display.package.option=Package-local API 公開 private 類
class.escapes.defined.scope.problem.descriptor=類 <code>#ref</code> 在其定義範圍之外公開 #loc
class.escapes.defined.scope.java9.modules.descriptor=類 <code>#ref</code> 未從模組 ''{0}'' 匯出
field.name.hides.in.superclass.display.name=子類欄位隱藏超類欄位
field.name.hides.in.superclass.problem.descriptor=欄位 <code>#ref</code> 隱藏超類中的欄位 #loc
field.name.hides.in.superclass.ignore.option=忽略不可存取欄位
field.name.hides.in.superclass.ignore.static.field.option=忽略隱藏 static 欄位的 static 欄位
inner.class.field.hides.outer.display.name=內部類欄位隱藏外部類欄位
inner.class.field.hides.outer.ignore.option=忽略從內部類不可見的外部欄位
inner.class.field.hides.outer.problem.descriptor=內部類欄位 <code>#ref</code> 隱藏外部類欄位 #loc
local.variable.hides.member.variable.display.name=局部變數隱藏欄位
local.variable.hides.member.variable.problem.descriptor=局部變數 <code>#ref</code> 隱藏類 ''{0}'' 中的欄位 #loc
local.variable.hides.member.variable.ignore.option=忽略隱藏非 static 欄位的 static 上下文中的局部變數
method.overloads.display.name=可能是超類方法意外多載
method.overloads.problem.descriptor=當可能打算覆寫時，方法 <code>#ref()</code> 多載超類的相容方法 #loc
method.overloads.report.incompatible.option=即使參數類型不相容，也會報告
method.overrides.private.display.name.problem.descriptor=方法 <code>#ref()</code> 重寫了超類的 'private' 方法 #loc
method.overrides.static.display.name=方法嘗試覆寫超類的 'static' 方法
method.overrides.static.problem.descriptor=方法 <code>#ref()</code> 嘗試覆寫超類的 static 方法 #loc
parameter.hides.member.variable.display.name=參數隱藏欄位
parameter.hides.member.variable.problem.descriptor=參數 <code>#ref</code> 隱藏類 ''{0}'' 中的欄位 #loc
parameter.hides.member.variable.ignore.setters.option=對屬性 setter 忽略
parameter.hides.member.variable.ignore.superclass.option=忽略從子類不可見的超類欄位
parameter.hides.member.variable.ignore.constructors.option=對構造函數忽略
parameter.hides.member.variable.ignore.abstract.methods.option=對 abstract 方法忽略
parameter.hides.member.variable.ignore.static.parameters.option=對隱藏實例欄位的 static 方法參數忽略
type.parameter.hides.visible.type.display.name=類型參數隱藏可見類型
type.parameter.hides.visible.type.problem.descriptor=類型參數 <code>#ref</code> 隱藏可見類型 ''{0}'' #loc
type.parameter.hides.type.parameter.problem.descriptor=類型參數 <code>#ref</code> 隱藏類型參數 ''{0}'' #loc
anonymous.class.variable.hides.containing.method.variable.display.name=匿名類變數隱藏包含方法中的變數
anonymous.class.parameter.hides.containing.method.variable.problem.descriptor=匿名類參數 <code>#ref</code> 隱藏包含方法中的變數 #loc
anonymous.class.field.hides.containing.method.variable.problem.descriptor=匿名類欄位 <code>#ref</code> 隱藏包含方法中的變數 #loc
anonymous.class.variable.hides.containing.method.variable.problem.descriptor=匿名類局部變數 <code>#ref</code> 隱藏包含方法中的變數 #loc
channel.opened.not.closed.display.name=打開了 'Channel'，但未安全關閉
drivermanager.call.display.name=使用 'DriverManager' 獲取 JDBC 連接
drivermanager.call.problem.descriptor=調用 <code>DriverManager.#ref()</code> #loc
hibernate.resource.opened.not.closed.display.name=Hibernate 資源已打開，但未安全關閉
i.o.resource.opened.not.closed.display.name=I/O 資源已打開，但未安全關閉
resource.opened.not.closed.problem.descriptor=''{0}'' 應在 ''try'' 塊之前打開，並在相應的 ''finally'' 塊中關閉 #loc
jdbc.resource.opened.not.closed.display.name=JDBC 資源已打開，但未安全關閉
jndi.resource.opened.not.closed.display.name=JNDI 資源已打開，但未安全關閉
socket.opened.not.closed.display.name=套接字已打開，但未安全關閉
annotation.class.display.name=註解類
annotation.class.problem.descriptor=註解類 <code>#ref</code> #loc
annotation.display.name=註解
annotation.problem.descriptor=註解 <code>#ref</code> #loc
assert.statement.display.name='assert' 語句
statement.problem.descriptor=<code>#ref</code> 語句 #loc
auto.boxing.display.name=自動裝箱
auto.boxing.problem.descriptor=自動裝箱 <code>#ref</code> #loc
auto.boxing.make.boxing.explicit.quickfix=使裝箱顯式
auto.boxing.ignore.added.to.collection.option=忽略添加到集合的表達式
auto.unboxing.display.name=自動拆箱
auto.unboxing.problem.descriptor=自動拆箱 <code>#ref</code> #loc
auto.unboxing.make.unboxing.explicit.quickfix=使拆箱顯式
enumerated.class.display.name=枚舉類
enumerated.class.problem.descriptor=枚舉類 <code>#ref</code> #loc
extended.for.statement.display.name=增強的 'for' 語句
extended.for.statement.replace.quickfix=取代為舊式 'for' 語句
variable.argument.method.display.name=vararg 方法
variable.argument.method.problem.descriptor=vararg 方法 <code>#ref()</code> #loc
variable.argument.method.quickfix=將 vararg 參數轉換為數組
hardcoded.file.separator.display.name=硬編碼檔案分隔符
hardcoded.file.separator.problem.descriptor=硬編碼檔案分隔符 <code>#ref</code> #loc
hardcoded.file.separator.include.option=在已識別的 MIME 介質類型中包括 \\"example/*\\"
hardcoded.line.separator.display.name=硬編碼行分隔符
hardcoded.line.separator.problem.descriptor=硬編碼行分隔符 <code>#ref</code> #loc
native.method.display.name=本地方法
native.method.problem.descriptor=宣告為 <code>#ref</code> 的方法不可移植 #loc
runtime.exec.call.display.name=調用 'Runtime.exec()'
runtime.exec.call.problem.descriptor=對 <code>Runtime.#ref()</code> 的調用不可移植 #loc
system.exit.call.display.name=調用 'System.exit()' 或相關方法
system.exit.call.problem.descriptor=對 <code>{0}.#ref()</code> 的調用不可移植 #loc
system.exit.call.ignore.option=在主方法中忽略
system.getenv.call.display.name=調用 'System.getenv()'
system.getenv.call.problem.descriptor=對 <code>System.#ref()</code> 的調用不可移植 #loc
use.of.awt.peer.class.display.name=使用 AWT 對等類
use.of.awt.peer.class.problem.descriptor=AWT 對等類 <code>#ref</code> 的使用不可移植 #loc
use.of.concrete.jdbc.driver.class.display.name=使用具體的 JDBC 驅動程序類
use.of.concrete.jdbc.driver.class.problem.descriptor=具體 JDBC 驅動程序類 <code>#ref</code> 的使用不可移植 #loc
use.processbuilder.class.display.name=使用 'java.lang.ProcessBuilder' 類
use.processbuilder.class.problem.descriptor=<code>#ref</code> 的使用不可移植 #loc
use.sun.classes.display.name=使用 'sun.*' 類
use.sun.classes.problem.descriptor=Sun 提供的類 <code>#ref</code> 的使用不可移植 #loc
abstract.class.with.only.one.direct.inheritor.display.name=只有一個直接繼承者的 abstract 類
anonymous.inner.may.be.named.static.inner.class.display.name=匿名類可能是命名為 'static' 的內部類
anonymous.inner.may.be.named.static.inner.class.problem.descriptor=匿名類 <code>#ref</code> 可能是命名為 'static' 的內部類 #loc
array.length.in.loop.condition.display.name=迴圈條件下的 Array.length
array.length.in.loop.condition.problem.descriptor=檢查迴圈條件下的陣列 <code>#ref</code> #loc
large.array.allocation.no.outofmemoryerror.display.name=沒有 OutOfMemoryError 檢查的大型陣列分配
large.array.allocation.no.outofmemoryerror.problem.descriptor=未檢查記憶體不足情況的大型陣列分配 #loc
large.array.allocation.no.outofmemoryerror.maximum.number.of.elements.option=最大元素數:
connection.opened.not.safely.closed.display.name=集合已打開，但未安全關閉
interface.one.inheritor.display.name=只有一個直接繼承者的接口
interface.one.inheritor.problem.descriptor=只有一個直接繼承者的接口 <code>#ref</code> #loc
method.call.in.loop.condition.display.name=迴圈條件下的方法調用
method.call.in.loop.condition.problem.descriptor=迴圈條件下調用方法 <code>#ref()</code> #loc
large.initializer.primitive.type.array.display.name=原始類型陣列的過大初始值設定項
large.initializer.primitive.type.array.problem.descriptor=具有太多元素 ({0}) 的原始陣列初始值設定項 #loc
large.initializer.primitive.type.array.maximum.number.of.elements.option=最大元素數:
private.member.access.between.outer.and.inner.classes.display.name=合成存取器調用
private.member.access.between.outer.and.inner.classes.problem.descriptor=存取類 ''{0}'' 的 ''private'' 成員需要合成存取器 #loc
private.member.access.between.outer.and.inner.classes.make.local.quickfix=將 ''{0}'' 設為 package-private
private.member.access.between.outer.and.inner.classes.make.constructor.package.local.quickfix=將 ''{0}'' 構造函數設為 package-private
recordstore.opened.not.safely.closed.display.name=打開了 'RecordStore'，但未安全關閉
overly.complex.anonymous.inner.class.display.name=過度複雜的匿名類
cyclomatic.complexity.limit.option=迴圈復雜度限制:
overly.complex.anonymous.inner.class.problem.descriptor=過度複雜的匿名類 (迴圈復雜度 = {0}) #loc
anonymous.inner.class.with.too.many.methods.display.name=具有太多方法的匿名內部類
method.count.limit.option=方法計數限制:
anonymous.inner.class.with.too.many.methods.problem.descriptor=具有太多方法的匿名內部類 (方法計數 = {0}) #loc
overly.complex.class.display.name=過度複雜的類
overly.complex.class.problem.descriptor=過度複雜的類<code>#ref</code> (迴圈復雜度 = {0}) #loc
overly.coupled.class.display.name=過度耦合的類
overly.coupled.class.class.coupling.limit.option=類耦合限制:
include.java.system.classes.option=包括與 Java 系統類的耦合
include.library.classes.option=包括與庫類的耦合
overly.coupled.class.problem.descriptor=<code>#ref</code> 過度耦合 (依賴 = {0}) #loc
class.too.deep.display.name=類在繼承樹中太深
class.too.deep.inheritance.depth.limit.option=繼承深度限制:
class.too.deep.problem.descriptor=<code>#ref</code> 在繼承樹中太深 (繼承深度 = {0}) #loc
inner.class.too.deeply.nested.display.name=內部類嵌套太深
inner.class.too.deeply.nested.nesting.limit.option=嵌套限制:
inner.class.too.deeply.nested.problem.descriptor=<code>#ref</code> 嵌套太深 (嵌套級別 = {0}) #loc
too.many.constructors.display.name=構造函數過多的類
too.many.constructors.count.limit.option=構造函數計數限制:
too.many.constructors.ignore.deprecated.option=忽略棄用的構造函數
too.many.constructors.problem.descriptor=<code>#ref</code> 的構造函數過多 (構造函數計數 = {0}) #loc
too.many.fields.display.name=欄位過多的類
too.many.fields.count.limit.option=欄位計數限制:
too.many.fields.problem.descriptor=<code>#ref</code> 的欄位過多 (欄位計數 = {0}) #loc
too.many.methods.display.name=方法過多的類
too.many.methods.problem.descriptor=<code>#ref</code> 的方法過多 (方法計數 = {0}) #loc
externalizable.with.serialization.methods.display.name=具有 'readObject()' 或 'writeObject()' 的可外部化類
externalizable.with.serialization.methods.problem.descriptor.both=可外部化{0, choice, 1#類|2#接口|3#派生的匿名類|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'readObject()' 和 'writeObject()' #loc
externalizable.with.serialization.methods.problem.descriptor.write=可外部化{0, choice, 1#類|2#接口|3#派生的匿名類|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'writeObject()' #loc
externalizable.with.serialization.methods.problem.descriptor.read=可外部化{0, choice, 1#類|2#接口|3#派生的匿名類|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'readObject()' #loc
non.serializable.with.serialversionuid.display.name=具有 'serialVersionUID' 的不可序列化類
non.serializable.class.with.serialversionuid.problem.descriptor=定義 'serialVersionUID' 欄位的不可序列化類 <code>#ref</code> #loc
non.serializable.interface.with.serialversionuid.problem.descriptor=定義 'serialVersionUID' 欄位的不可序列化接口 <code>#ref</code> #loc
non.serializable.@interface.with.serialversionuid.problem.descriptor=定義 'serialVersionUID' 欄位的不可序列化 @interface <code>#ref</code> #loc
non.serializable.anonymous.with.serialversionuid.problem.descriptor=派生自 <code>#ref</code> 的不可序列化匿名類定義 'serialVersionUID' 欄位 #loc
non.serializable.class.with.readwriteobject.display.name=具有 'readObject()' 或 'writeObject()' 的不可序列化類
non.serializable.class.with.readwriteobject.problem.descriptor.both=不可序列化{0, choice, 1#類|2#接口|3#派生的匿名類|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'readObject()' 和 'writeObject()' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.write=不可序列化{0, choice, 1#類|2#接口|3#派生的匿名類|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'writeObject()' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.read=不可序列化{0, choice, 1#類|2#接口|3#派生的匿名類|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'readObject()' #loc
readwriteobject.private.display.name='readObject()' 或 'writeObject()' 未被宣告為 'private'
readwriteobject.private.problem.descriptor=<code>#ref</code> 未被宣告為 'private' #loc
readobject.initialization.display.name=實例欄位可能無法被 'readObject()' 初始化
readobject.initialization.problem.descriptor=實例欄位 <code>#ref</code> 在 'readObject()' 調用期間可能無法初始化 #loc
readresolve.writereplace.protected.display.name='readResolve()' 或 'writeReplace()' 未被宣告為 'protected'
readresolve.writereplace.protected.problem.descriptor=<code>#ref()</code> 未被宣告為 'protected' #loc
missing.serial.annotation.display.name=可以使用 '@Serial' 註解
missing.serial.annotation.on.field.problem.descriptor=<code>#ref</code> 可以使用 '@Serial' 進行註解
missing.serial.annotation.on.method.problem.descriptor=<code>#ref()</code> 可以使用 '@Serial' 進行註解
serial.annotation.used.on.wrong.member.display.name=對錯誤的成員使用了 '@Serial' 註解
serial.annotation.used.on.wrong.member.problem.descriptor=註解的成員不是序列化機制的一部分
serializable.record.contains.ignored.members.display.name='record' 包含被忽略的成員
serializable.record.contains.ignored.field.problem.descriptor=在記錄序列化期間將忽略 <code>#ref</code>
serializable.record.contains.ignored.method.problem.descriptor=在記錄序列化期間將忽略 <code>#ref()</code>
serialpersistentfields.with.wrong.signature.display.name='serialPersistentFields' 欄位未被宣告為 'private static final ObjectStreamField[]'
serialpersistentfields.with.wrong.signature.problem.descriptor=可序列化類的 <code>#ref</code> 欄位未被宣告為 'private static final ObjectStreamField[]' #loc
serialversionuid.private.static.final.long.display.name='serialVersionUID' 欄位未被宣告為 'private static final long'
serialversionuid.private.static.final.long.problem.descriptor=可序列化類的 <code>#ref</code> 欄位未被宣告為 'private static final long' #loc
serialversionuid.private.static.final.long.quickfix=將 serialVersionUID 設為 'private static final'

#dynamic
non.protected.constructor.in.abstract.class.display.name=abstract 類中的 public 構造函數
unnecessary.qualifier.for.this.display.name='this' 或 'super' 的限定符不必要
multiple.declaration.display.name=一個宣告中的多個變數
thread.priority.display.name=調用 'Thread.setPriority()'
too.broad.scope.display.name=變數範圍過寬
infinite.loop.statement.display.name=無限迴圈語句
asserts.without.messages.display.name=斷言上缺少訊息
constant.naming.convention.element.description=常數
constant.with.mutable.field.naming.convention.element.description=具有可變欄位類型的常數
random.double.for.random.integer.display.name=使用 'Random.nextDouble()' 獲取隨機整數
test.method.without.assertion.display.name=沒有任何斷言的 JUnit 測試方法
string.buffer.replaceable.by.string.builder.display.name='StringBuffer' 可能是 'StringBuilder'
comparison.of.short.and.char.display.name=比較 'short' 和 'char' 值
unnecessary.fully.qualified.name.display.name=不必要的完全限定名稱
ignore.in.module.statements.option=在 Java 9 模組語句中忽略
unnecessary.label.on.break.statement.display.name='break' 語句上的標籤不必要
exception.name.doesnt.end.with.exception.display.name=異常類名不以 'Exception' 結尾
bad.exception.declared.display.name=已宣告禁止異常
pointless.boolean.expression.display.name=無意義的語句或布爾表達式
class.without.constructor.display.name=不帶構造函數的類
break.statement.display.name='break' 語句
unconditional.wait.display.name=無條件的 'wait()' 調用
cyclomatic.complexity.display.name=過度複雜的方法
final.class.display.name=類禁止繼承
labeled.statement.display.name=標記語句
notify.called.on.condition.display.name=在 'java.util.concurrent.locks.Condition' 物件上調用了 'notify()' 或 'notifyAll()'
loop.statements.that.dont.loop.display.name=不迴圈的迴圈語句
ignore.enhanced.for.loop.statements=忽略增強型 for 迴圈
non.synchronized.method.overrides.synchronized.method.display.name=未同步方法覆寫 'synchronized' 方法
synchronize.on.this.display.name=在 'this' 上同步
switch.statement.with.too.many.branches.display.name=最大 'switch' 分支
utility.class.without.private.constructor.display.name=實用程序類沒有 'private' 構造函數
throw.caught.locally.display.name=通過包含 'try' 語句捕獲 'throw'
exception.from.catch.which.doesnt.wrap.display.name='throw' 位於忽略已捕獲異常的 'catch' 塊內
type.parameter.naming.convention.element.description=類型參數
multiply.or.divide.by.power.of.two.display.name=乘以或除以 2 的冪
multiply.or.divide.by.power.of.two.divide.option=還通過 2 的冪檢查除法
serializable.with.unconstructable.ancestor.display.name=具有不可構造上級的可序列化類
missorted.modifiers.display.name=錯位修飾符
sleep.while.holding.lock.display.name=同步時調用 'Thread.sleep()'
singleton.display.name=單例
thread.death.rethrown.display.name='ThreadDeath' 未重新拋出
if.statement.with.too.many.branches.display.name='if' 語句的分支過多
redundant.implements.display.name=冗餘接口宣告
nesting.depth.display.name=過度嵌套的方法
return.this.display.name=返回 'this'
busy.wait.display.name=忙等待
utility.class.display.name=實用程序類
instantiating.object.to.get.class.object.display.name=實例化物件以獲取 'Class' 物件
abstract.class.extends.concrete.class.display.name=abstract 類擴展具體類
parameter.naming.convention.display.name=方法參數命名慣例
parameter.naming.convention.element.description=參數
integer.division.in.floating.point.context.display.name=浮點上下文中的整數除法
interface.naming.convention.element.description=接口
length.one.strings.in.concatenation.display.name=單字符字串串聯
length.one.string.in.indexof.display.name= 'String.indexOf()' 調用中的單字符字串實參
thread.yield.display.name=調用 'Thread.yield()'
confusing.floating.point.literal.display.name=浮點文字會引起混淆
wait.not.in.loop.display.name=未在迴圈中調用的 'wait()'
string.concatenation.inside.string.buffer.append.display.name=字串串聯作為 'StringBuilder.append()' 調用的實參
class.initializer.display.name=非 'static' 初始值設定項
enumerated.class.naming.convention.element.description=枚舉
non.thread.safe.lazy.initialization.display.name=不安全的 'static' 欄位延遲初始化
call.to.simple.setter.in.class.display.name=從類內調用簡單 setter
comparison.to.nan.display.name=與 'Double.NaN' 或 'Float.NaN' 比較
new.method.naming.convention.display.name=方法命名慣例
instance.method.naming.convention.element.description=實例
unnecessary.semicolon.display.name=不必要的分號
fallthru.in.switch.statement.display.name='switch' 語句中的直落
call.to.native.method.while.locked.display.name=鎖定時調用 'native' 方法
switch.statement.display.name='switch' 語句
custom.classloader.display.name=宣告了自訂的 'ClassLoader'
nested.conditional.expression.display.name=嵌套條件表達式
duplicate.condition.display.name=條件重複
method.with.multiple.loops.display.name=具有多個迴圈的方法
non.comment.source.statements.display.name=過長的方法
local.variable.naming.convention.display.name=局部變數命名慣例
local.variable.naming.convention.element.description=局部變數
negated.if.else.display.name=具有否定條件的 'if' 語句
class.naming.convention.display.name=類命名慣例
class.naming.convention.element.description=類
abstract.class.naming.convention.element.description=abstract 類
serializable.inner.class.with.non.serializable.outer.class.display.name=可序列化非 'static' 內部類具有不可序列化外部類
pointless.arithmetic.expression.display.name=無意義的算術表達式
method.name.same.as.class.name.display.name=方法名稱與類名相同
unnecessary.temporary.on.conversion.to.string.display.name=轉換為 'String' 時有不必要的臨時物件
unnecessary.continue.display.name=不必要的 'continue' 語句
inner.class.on.interface.display.name=接口的內部類
unused.label.display.name=未使用的標籤
overly.complex.boolean.expression.display.name=過度複雜的布爾表達式
continue.statement.with.label.display.name=帶標籤的 'continue' 語句
class.loader.instantiation.display.name='ClassLoader' 實例化
return.from.finally.block.display.name='return' 位於 'finally' 塊內
unnecessary.boxing.display.name=不必要的裝箱
annotation.naming.convention.element.description=註解
checked.exception.class.display.name=已檢查的異常類
switch.statement.with.confusing.declaration.display.name=在不同 'switch' 分支中使用並宣告的局部變數
cast.that.loses.precision.display.name=損失精度的數字轉換
manual.array.copy.display.name=手動陣列複製
manual.array.to.collection.copy.display.name=手動陣列到集合複製
long.literals.ending.with.lowercase.l.display.name='long' 文字以 'l' 而不是 'L' 結尾
overly.complex.arithmetic.expression.display.name=過於複雜的算術表達式
junit.abstract.test.class.naming.convention.element.description=abstract 測試
unnecessary.parentheses.display.name=不必要的圓括號
test.case.in.product.code.display.name=產品源中的 JUnit 'TestCase'
test.method.in.product.code.display.name=產品源中的 JUnit 測試方法
serializable.class.in.secure.context.display.name=安全上下文中的可序列化類
static.variable.naming.convention.element.description='static' 欄位
nested.method.call.display.name=嵌套方法調用
throw.from.finally.block.display.name='throw' 位於 'finally' 塊內
field.accessed.synchronized.and.unsynchronized.display.name=同時在 'synchronized' 和未同步上下文中存取欄位
abstract.method.overrides.abstract.method.display.name=abstract 方法覆寫 abstract 方法
static.non.final.field.display.name='static' 非 'final' 欄位
static.non.final.field.option=僅報告 'public' 欄位
class.without.no.arg.constructor.display.name=沒有無參構造函數的類
unnecessary.return.display.name=不必要的 'return' 語句
final.static.method.display.name='static' 方法被宣告為 'final'
constant.declared.in.abstract.class.display.name=在 'abstract' 類中宣告的常數
too.broad.catch.display.name=過寬的 'catch' 塊
floating.point.equality.display.name=浮點相等比較
thrown.exceptions.per.method.display.name=方法宣告的異常過多
public.static.array.field.display.name='public static' 陣列欄位
await.not.in.loop.display.name=未在迴圈中調用的 'await()'
method.names.differ.only.by.case.display.name=方法名稱僅大小寫不同
unsecure.random.number.generation.display.name=不安全的隨機數生成
parameters.per.method.display.name=參數過多的方法
parameters.per.constructor.display.name=參數過多的構造函數
unnecessary.unboxing.display.name=不必要的拆箱
extends.thread.display.name=類直接擴展 'Thread'
test.case.with.constructor.display.name=具有非普通構造函數的 JUnit TestCase
parameter.name.differs.from.overridden.parameter.display.name=參數名稱與覆寫方法中的參數不同
final.private.method.display.name='private' 方法被宣告為 'final'
enum.switch.statement.which.misses.cases.display.name=缺少 case 的枚舉 'switch' 語句
enum.switch.statement.which.misses.cases.option=忽略具有預設分支的 switch 語句
unconstructable.test.case.display.name=不可構造的 JUnit 'TestCase'
string.buffer.must.have.initial.capacity.display.name=沒有初始容量的 'StringBuilder'
method.may.be.static.display.name=方法可以為 'static'
class.initializer.may.be.static.display.name=類初始值設定項可能為 'static'
class.initializer.option=僅在類具有一個或多個構造函數時警告
class.initializer.move.code.to.constructor.quickfix=將初始值設定項程式碼移動到構造函數
nested.switch.statement.display.name=嵌套 'switch' 語句
c.style.array.declaration.display.name=C 樣式陣列宣告
final.method.in.final.class.display.name='final' 類位於 'final' 方法中
extends.annotation.display.name=類擴展註解接口
naked.notify.display.name=沒有相應狀態更改的 'notify()' 或 'notifyAll()'
switch.statement.density.display.name='switch' 語句的分支密度過低
switch.statement.with.too.few.branches.display.name=最小 'switch' 分支
upper.case.field.name.not.constant.display.name=具有大寫名稱的非常數欄位
unnecessary.label.on.continue.statement.display.name='continue' 語句上的不必要標籤
jdbc.prepare.statement.with.non.constant.string.display.name='Connection.prepare*()' 調用具有非常數字串
synchronize.on.non.final.field.display.name=在非 final 欄位上同步
noop.method.in.abstract.class.display.name='abstract' 類中的無運算方法
non.final.field.of.exception.display.name='Exception' 類的非 final 欄位
nested.try.statement.display.name=嵌套 'try' 語句
condition.signal.display.name=調用 'signal()' 而不是 'signalAll()'
jdbc.execute.with.non.constant.string.display.name='Statement.execute()' 調用具有非常數字串
system.set.security.manager.display.name=調用 'System.setSecurityManager()'
system.set.security.manager.problem.descriptor=對 <code>System.#ref()</code> 的調用可能造成安全問題 #loc
control.flow.statement.without.braces.display.name=不帶大括號的控制流語句
trivial.if.display.name=冗餘的 'if' 語句
trivial.if.fix.family.name=簡化 'if else'
trivial.if.option.ignore.chained=忽略鏈式 'if' 語句
thread.with.default.run.method.display.name=使用預設的 'run()' 方法實例化 'Thread'
while.loop.spins.on.field.display.name='while' 迴圈在欄位上自旋
while.loop.spins.on.field.fix.family.name=修復自旋迴圈
while.loop.spins.on.field.fix.volatile=將 ''{0}'' 設為 volatile
while.loop.spins.on.field.fix.spinwait=添加 Thread.onSpinWait()
while.loop.spins.on.field.fix.volatile.spinwait=將 ''{0}'' 設為 volatile 並添加 Thread.onSpinWait()
test.method.is.public.void.no.arg.display.name=測試方法的格式錯誤
if.statement.with.identical.branches.display.name='if' 語句的分支相同
inspection.common.if.parts.message.variables.only=從 ''if'' 中提取變數{0}
inspection.common.if.parts.message.with.variables.extract=從 ''if'' 中提取包含變數的通用部分{0}
inspection.common.if.parts.message.without.variables.extract=從 ''if'' 中提取通用部分{0}
inspection.common.if.parts.message.whole.branch=提取通用部分，同時移除分支{0}
inspection.common.if.parts.message.complete.duplicate=摺疊 ''if'' 語句{0}
inspection.common.if.parts.message.complete.duplicate.side.effect=摺疊 'if' 語句並提取副作用
inspection.common.if.parts.description.variables.only=可以從 ''if'' 中提取變數{0}
inspection.common.if.parts.description.with.variables.extract=可以從 ''if'' 中提取包含變數的通用部分{0}
inspection.common.if.parts.description.without.variables.extract=可以從 ''if'' 中提取通用部分{0}
inspection.common.if.parts.description.whole.branch=可以提取通用部分，同時移除分支{0}
inspection.common.if.parts.description.complete.duplicate=可以摺疊 ''if'' 語句{0}
inspection.common.if.parts.description.complete.duplicate.side.effect=可以通過提取副作用摺疊 'if' 語句
inspection.note.may.change.semantics=可能更改語意
multiple.return.points.per.method.display.name=具有多個返回點的方法
break.statement.with.label.display.name=帶標籤的 'break' 語句
public.constructor.in.non.public.class.display.name='public' 構造函數位於非 public 類中
questionable.name.display.name=可疑名稱
empty.finally.block.display.name=空 'finally' 塊
abstract.method.overrides.concrete.method.display.name=abstract 方法覆寫具體方法
thread.stop.suspend.resume.display.name=調用 'Thread.stop()'、'suspend()' 或 'resume()'
constant.math.call.display.name=對 'Math' 的常數調用
volatile.array.field.display.name=volatile 陣列欄位
literal.as.arg.to.string.equals.display.name=字串文字可以為 'equals()' 限定符
inner.class.may.be.static.display.name=內部類可能為 'static'
static.suite.display.name='suite()' 方法未被宣告為 'static'
redundant.field.initialization.display.name=冗餘欄位初始化
string.buffer.to.string.in.concatenation.display.name=連接中的 'StringBuilder.toString()'
utility.class.with.public.constructor.display.name=實用程序類具有 'public' 構造函數
for.loop.replaceable.by.while.display.name='for' 迴圈可以取代為 'while' 迴圈
missing.deprecated.annotation.display.name=缺少 '@Deprecated' 註解
cloneable.class.in.secure.context.display.name=安全上下文中的可克隆類
static.inheritance.display.name=靜態繼承
class.name.prefixed.with.package.name.display.name=使用軟體套件名稱作為前綴的類名
call.to.simple.getter.in.class.display.name=從類內調用簡單 getter
class.name.differs.from.file.name.display.name=類名與文件名不同
protected.member.in.final.class.display.name='protected' 成員位於 'final' 類中
load.library.with.non.constant.string.display.name='System.loadLibrary()' 調用具有非常數字串
instanceof.catch.parameter.display.name='catch' 參數上的 'instanceof'
implicit.numeric.conversion.display.name=隱式數字轉換
unnecessary.interface.modifier.display.name=不必要的 'interface' 修飾符
confusing.main.method.display.name=引起混淆的 'main()' 方法
octal.literal.display.name=八進制整數
misordered.assert.equals.arguments.display.name=順序錯誤的 'assertEquals()' 實參
unnecessary.constructor.display.name=冗餘無參構造函數
method.name.same.as.parent.name.display.name=方法名稱與父類名相同
while.can.be.foreach.display.name='while' 迴圈可取代為增強的 'for' 迴圈
big.decimal.equals.display.name=在 'BigDecimal' 上調用了 'equals()'
implicit.call.to.super.display.name=隱式調用 'super()'
unqualified.static.usage.display.name=非限定靜態存取
simplifiable.junit.assertion.display.name=可簡化斷言
object.notify.display.name=調用 'notify()' 而不是 'notifyAll()'
thread.start.in.construction.display.name=物件構造期間調用 'Thread.start()'
non.final.clone.display.name=非 final 'clone()' 位於安全上下文中
unnecessary.temporary.on.conversion.from.string.display.name=從 'String' 轉換時有不必要的臨時物件
unnecessary.this.display.name=不必要的 'this' 限定符
unnecessary.this.ignore.assignments.option=忽略欄位賦值
runtime.exec.with.non.constant.string.display.name='Runtime.exec()' 調用具有非常數字串
system.properties.display.name=系統屬性的存取
chained.method.call.display.name=鏈式方法調用
safe.lock.display.name=已獲取但未安全解鎖的鎖
system.run.finalizers.on.exit.display.name=調用 'System.runFinalizersOnExit()'
for.can.be.foreach.display.name='for' 迴圈可取代為增強的 for 迴圈
type.parameter.extends.object.display.name=類型參數顯式擴展 'Object'
type.parameter.extends.object.ignore.annotated=註解 java.lang.Object 時忽略
marker.interface.display.name=標記接口
limited.scope.inner.class.display.name=局部類
switch.statements.without.default.display.name=不帶 'default' 分支的 'switch' 語句
unchecked.exception.class.display.name=未檢查的 'Exception' 類
for.loop.with.missing.component.display.name=缺少組件的 'for' 迴圈
for.loop.with.missing.component.collection.loop.option=忽略集合迭代
double.checked.locking.display.name=雙重檢查鎖定
double.checked.locking.problem.descriptor=雙重檢查鎖定 #loc
string.buffer.replaceable.by.string.display.name='StringBuilder' 可以取代為 'String'
boolean.method.name.must.start.with.question.display.name=布爾方法名稱必須以疑問詞開頭
class.name.same.as.ancestor.name.display.name=類名與上級名稱相同
error.rethrown.display.name='Error' 未重新拋出
serializable.has.serialization.methods.display.name=不帶 'readObject()' 和 'writeObject()' 的可序列化類
serializable.has.serialization.methods.ignore.option=忽略未定義實例欄位的類
missing.override.annotation.display.name=缺少 '@Override' 註解
wait.while.holding.two.locks.display.name=保持兩個鎖時 'wait()'
empty.class.display.name=冗餘空類
trivial.string.concatenation.display.name=與空字串串聯
empty.synchronized.statement.display.name=空 'synchronized' 語句
unnecessary.default.display.name=枚舉 'switch' 語句的 'default' 不必要
simplifiable.conditional.expression.display.name=可簡化的條件表達式
unnecessary.super.constructor.display.name=對 'super()' 的調用不必要
unnecessarily.qualified.static.usage.display.name=不必要的限定靜態存取
bad.exception.caught.display.name=已捕獲禁止的 'Exception'
custom.security.manager.display.name=自訂 'SecurityManager'
string.concatenation.in.loops.display.name=字串串聯在迴圈中
boolean.constructor.display.name=布爾構造函數調用
continue.statement.display.name='continue' 語句
extends.object.display.name=類顯式擴展 'Object'
serializable.inner.class.has.serial.version.uid.field.display.name=沒有 'serialVersionUID' 的可序列化非 static 內部類
static.method.naming.convention.element.description='static'
empty.try.block.display.name=空 'try' 塊
field.has.setter.but.no.getter.display.name=欄位具有 setter 但沒有 getter
three.negations.per.method.display.name=具有三個以上否定的方法
conditional.expression.display.name=條件表達式
unnecessary.enum.modifier.display.name=不必要的 enum' 修飾符
string.equals.empty.string.display.name='String.equals()' 可以取代為 'String.isEmpty()'
synchronize.on.lock.display.name=在 'Lock' 物件上同步
synchronized.on.literal.object.name=在使用文字初始化的物件上同步
field.may.be.static.display.name=欄位可以為 'static'
class.may.be.interface.display.name='abstract' 類可以是 'interface'
abstract.class.without.abstract.methods.display.name=沒有 'abstract' 方法的 abstract 類
divide.by.zero.display.name=除以零
default.not.last.case.in.switch.display.name='default' 不是 'switch' 中的最後一個 case
nested.synchronized.statement.display.name=嵌套 'synchronized' 語句
constant.conditional.expression.display.name=恒定條件表達式
redundant.else.display.name=冗餘的 'else'
public.field.accessed.in.synchronized.context.display.name=在 'synchronized' 上下文中存取d了非 private 欄位
string.replaceable.by.string.buffer.display.name=非常數 'String' 可取代為 'StringBuilder'
junit.test.class.naming.convention.element.description=測試
junit.test.suite.naming.convention.element.description=測試套件
method.coupling.display.name=過度耦合的方法
collections.must.have.initial.capacity.display.name=沒有初始容量的集合
anonymous.inner.class.display.name=匿名內部類可以取代為內部類
negated.conditional.display.name=具有否定條件的條件表達式
non.reproducible.math.call.display.name=對 'Math' 的不可重現調用
multiple.top.level.classes.in.file.display.name=單個檔案中的多個頂級類
set.replaceable.by.enum.set.display.name='Set' 可取代為 'EnumSet'
tail.recursion.display.name=尾遞歸
finally.block.cannot.complete.normally.display.name=不能正常完成的 'finally' 塊
non.atomic.operation.on.volatile.field.display.name='volatile' 欄位上的非原子操作
public.static.collection.field.display.name='public static' 集合欄位
non.exception.name.ends.with.exception.display.name=非異常類名以 'Exception' 結尾
synchronized.method.display.name='synchronized' 方法
enumerated.constant.naming.convention.element.description=枚舉常數
final.method.display.name=不能覆寫方法
transient.field.in.non.serializable.class.display.name=不可序列化類中存在 transient 欄位
bad.exception.thrown.display.name=已拋出禁止異常
conditional.expression.with.identical.branches.display.name=具有相同分支的條件表達式
conditional.can.be.pushed.inside.expression.display.name=可以在分支表達式內推送條件
conditional.can.be.pushed.inside.expression.option=在條件將僅作為方法調用的實參時忽略
conditional.can.be.pushed.inside.expression.quickfix=在分支內推送條件表達式
raw.use.of.parameterized.type.display.name=參數化類的原始使用
standard.variable.names.display.name=標準變數名稱
field.naming.convention.display.name=欄位命名慣例
instance.variable.naming.convention.element.description=實例欄位
dollar.sign.in.name.display.name=在關鍵字中使用 '$'
map.replaceable.by.enum.map.display.name='Map' 可取代為 'EnumMap'
extends.concrete.collection.display.name=類顯式擴展 'Collection' 類
continue.or.break.from.finally.block.display.name='continue' 或 'break' 位於 'finally' 塊內
abstract.method.with.missing.implementations.display.name=缺少實作的 abstract 方法
object.allocation.in.loop.display.name=迴圈中的物件分配
wait.called.on.condition.display.name=在 'java.util.concurrent.locks.Condition' 物件上調用了 'wait()'
test.case.with.no.test.methods.display.name=沒有測試的測試類
abstract.class.never.implemented.display.name=沒有具體子類的 abstract 類
interface.never.implemented.display.name=沒有具體子類的接口
constant.declared.in.interface.display.name=在接口中宣告的常數


#problem descriptors
exception.name.doesnt.end.with.exception.problem.descriptor=異常類名 <code>#ref</code> 未以 'Exception' 結尾 #loc
non.exception.name.ends.with.exception.problem.descriptor=非異常類名 <code>#ref</code> 以 'Exception' 結尾 #loc
class.name.prefixed.with.package.name.problem.descriptor=類名 <code>#ref</code> 以其軟體套件名稱開始 #loc
class.name.same.as.ancestor.name.problem.descriptor=類名 <code>#ref</code> 與其超類的名稱之一相同 #loc
method.name.same.as.class.name.problem.descriptor=方法名稱 <code>#ref</code> 與其類名相同 #loc
method.name.same.as.parent.name.problem.descriptor=方法名稱 <code>#ref</code> 與其父類名相同 #loc
boolean.method.name.must.start.with.question.problem.descriptor=布爾方法名稱 <code>#ref</code> 未以疑問詞開頭 #loc
questionable.name.problem.descriptor=可疑名稱 <code>#ref</code> #loc
confusing.main.method.problem.descriptor=方法名稱 <code>#ref</code> 沒有簽名 'public static void main(String[])' #loc
upper.case.field.name.not.constant.problem.descriptor=帶常數樣式名稱的非常數欄位 <code>#ref</code> #loc
dollar.sign.in.name.problem.descriptor=關鍵字 <code>#ref</code> 包含 '$' #loc
integer.division.in.floating.point.context.problem.descriptor=<code>#ref</code>: 浮點上下文中的整數除法 #loc
comparison.of.short.and.char.problem.descriptor=short 和 char 值的相等比較 <code>#ref</code> #loc
big.decimal.equals.problem.descriptor=BigDecimal 值之間的 <code>#ref()</code> 可能應當是 'compareTo()' #loc
divide.by.zero.problem.descriptor=除以零 #loc
non.reproducible.math.call.problem.descriptor=<code>Math.#ref()</code> 可能產生不可重現的結果 #loc
constant.math.call.problem.descriptor=對 <code>#ref()</code> 的常數調用可以簡化 #loc
floating.point.equality.problem.descriptor=<code>#ref</code>: 比較浮點值以實作完全相等 #loc
fallthru.in.switch.statement.problem.descriptor='switch' 語句存在直落 #loc
switch.statements.without.default.problem.descriptor=沒有 'default' 分支的 <code>#ref</code> 語句 #loc
default.not.last.case.in.switch.problem.descriptor=<code>#ref</code> 分支不是 ''switch'' {0} 中的最後一個 case #loc
loop.statements.that.dont.loop.problem.descriptor=<code>#ref</code> 語句未迴圈 #loc
conditional.expression.with.identical.branches.problem.descriptor=具有相同分支的條件表達式 <code>#ref</code> #loc
conditional.can.be.pushed.inside.expression.problem.descriptor=條件表達式可以推送到分支內 #loc
duplicate.condition.problem.descriptor=重複條件 <code>#ref</code> #loc
duplicate.condition.ignore.method.calls.option=忽略有副作用的條件
iterator.next.does.not.throw.nosuchelementexception.problem.descriptor=無法拋出 'NoSuchElementException' 的 <code>Iterator.#ref()</code> '#loc
infinite.loop.statement.problem.descriptor=<code>#ref</code> 語句不能在未拋出異常的情況下完成 #loc
confusing.floating.point.literal.problem.descriptor=引起混淆的浮點文字 <code>#ref</code> #loc
overly.complex.arithmetic.expression.problem.descriptor=過於複雜的算術表達式 #loc
overly.complex.boolean.expression.problem.descriptor=過度複雜的布爾表達式 ({0} 項) #loc
labeled.statement.problem.descriptor=標記語句 <code>#ref:</code> #loc
break.statement.with.label.problem.descriptor=帶標籤的 <code>#ref</code> 語句 #loc
continue.statement.with.label.problem.descriptor=帶標籤的 <code>#ref</code> 語句 #loc
conditional.expression.problem.descriptor=條件表達式 <code>#ref</code> #loc
conditional.expression.option=對簡單賦值和返回值忽略
conditional.expression.expression.context.option=忽略無法使用 if 語句的位置
conditional.expression.quickfix=取代為 'if' 語句
nested.conditional.expression.problem.descriptor=嵌套條件表達式 <code>#ref</code> #loc
long.literals.ending.with.lowercase.l.problem.descriptor='long' 文字 <code>#ref</code> 以小寫 'l' 結尾 #loc
nested.switch.statement.problem.descriptor=嵌套 <code>#ref</code> {0} #loc
chained.method.call.problem.descriptor=鏈式方法調用 <code>#ref()</code> #loc
nested.method.call.problem.descriptor=嵌套方法調用 <code>#ref()</code> #loc
octal.literal.problem.descriptor=八進制整數 <code>#ref</code> #loc
implicit.call.to.super.problem.descriptor=隱式調用 'super()' #loc
negated.if.else.problem.descriptor=帶嵌套條件的 <code>#ref</code> 語句 #loc
negated.conditional.problem.descriptor=具有否定條件的條件表達式 #loc
redundant.else.problem.descriptor=<code>#ref</code> 分支可以解開，因為 'if' 分支永遠不會正常完成 #loc
switch.statement.with.confusing.declaration.problem.descriptor=局部變數 <code>#ref</code> 在一個 'switch' 分支中宣告，並在另一個分支中使用 #loc
final.class.problem.descriptor=類被宣告為 <code>#ref</code> #loc
empty.class.problem.descriptor=類 <code>#ref</code> 為空 #loc
empty.enum.problem.descriptor=枚舉 <code>#ref</code> 為空 #loc
empty.class.file.without.class.problem.descriptor=Java 檔案未宣告任何類 #loc
empty.anonymous.class.problem.descriptor=匿名類為空 #loc
anonymous.inner.class.problem.descriptor=匿名內部類 <code>#ref</code> #loc
limited.scope.inner.class.problem.descriptor=局部類 <code>#ref</code> #loc
final.method.problem.descriptor=方法被宣告為 <code>#ref</code> #loc
class.initializer.problem.descriptor=非 'static' 初始值設定項 #loc
class.may.be.interface.problem.descriptor=abstract 類 <code>#ref</code> 可能是接口 #loc
non.protected.constructor.in.abstract.class.problem.descriptor=abstract 類的構造函數 <code>#ref()</code> 不應宣告為 'public' #loc
class.without.constructor.problem.descriptor=類 <code>#ref</code> 沒有構造函數 #loc
abstract.class.without.abstract.methods.problem.descriptor=類 <code>#ref</code> 被宣告為 'abstract'，並且沒有 'abstract' 方法 #loc
final.method.in.final.class.problem.descriptor=方法在 'final' 類中被宣告為 <code>#ref</code> #loc
protected.member.in.final.class.problem.descriptor=類成員在 'final' 類中被宣告為 <code>#ref</code> #loc
utility.class.with.public.constructor.problem.descriptor=類 <code>#ref</code> 只有 'static' 成員和 'public' 構造函數 #loc
utility.class.without.private.constructor.problem.descriptor=類 <code>#ref</code> 只有 'static' 成員，缺少 'private' 構造函數 #loc
abstract.method.overrides.concrete.method.problem.descriptor=abstract 方法 <code>#ref()</code> 覆寫具體方法 #loc
abstract.method.with.missing.implementations.problem.descriptor=abstract 方法 <code>#ref()</code> 未在每個子類中實作 #loc
abstract.method.overrides.abstract.method.problem.descriptor=abstract 方法 <code>#ref()</code> 覆寫 abstract 方法 #loc
abstract.method.overrides.abstract.method.ignore.different.javadoc.option=忽略 Javadoc 與其 super 方法不同的方法
abstract.class.extends.concrete.class.problem.descriptor=類 <code>#ref</code> 被宣告為 'abstract'，並擴展一個具體類 #loc
static.non.final.field.problem.descriptor='static' 非 'final' 欄位 <code>#ref</code> #loc
constant.declared.in.abstract.class.problem.descriptor=常數 <code>#ref</code> 在 abstract 類中宣告 #loc
constant.declared.in.interface.problem.descriptor=常數 <code>#ref</code> 在接口中宣告 #loc
static.inheritance.problem.descriptor=接口 <code>#ref</code> 僅針對其 static 常數實作 #loc
utility.class.problem.descriptor=類 <code>#ref</code> 只有 'static' 成員，指示程序構造 #loc
singleton.problem.descriptor=類 <code>#ref</code> 為單例 #loc
enum.singleton.problem.descriptor=枚舉 <code>#ref</code> 為單例 #loc
final.private.method.problem.descriptor='private' 方法被宣告為 <code>#ref</code> #loc
noop.method.in.abstract.class.problem.descriptor=無操作方法 <code>#ref()</code> 應當設為 abstract #loc
final.static.method.problem.descriptor='static' 方法被宣告為 <code>#ref</code> #loc
class.without.no.arg.constructor.problem.descriptor=<code>#ref</code> 沒有無參構造函數 #loc
multiple.top.level.classes.in.file.problem.descriptor=檔案中的多個頂級類
class.name.differs.from.file.name.problem.descriptor=類名 <code>#ref</code> 與文件名不同 #loc
marker.interface.problem.descriptor=標記接口 <code>#ref</code> #loc
field.has.setter.but.no.getter.problem.descriptor=欄位 <code>#ref</code> 有 setter 但沒有 getter #loc
abstract.class.never.implemented.problem.descriptor=abstract 類 <code>#ref</code> 沒有具體子類 #loc
interface.never.implemented.problem.descriptor=接口 <code>#ref</code> 沒有具體子類 #loc
missing.deprecated.annotation.problem.descriptor=缺少 '@Deprecated' 註解 #loc
missing.deprecated.tag.problem.descriptor=缺少 '@deprecated' Javadoc 標記說明 #loc
missing.deprecated.tag.option=警告缺少 @deprecated Javadoc 標記說明
missing.override.annotation.problem.descriptor=缺少關於 <code>#ref()</code> 的 '@Override' 註解 #loc
missing.override.annotation.in.overriding.problem.descriptor=覆寫方法未使用 '@Override' 註解
non.thread.safe.lazy.initialization.problem.descriptor='static' 欄位 <code>#ref</code> 的延遲初始化不是執行緒安全 #loc
empty.finally.block.problem.descriptor=空 <code>#ref</code> 塊 #loc
finally.block.cannot.complete.normally.problem.descriptor=<code>#ref</code> 塊無法正常完成 #loc
empty.try.block.problem.descriptor=空 <code>#ref</code> 塊 #loc
throw.from.finally.block.problem.descriptor=<code>#ref</code> 位於 'finally' 塊內 #loc
possible.throw.from.finally.block.problem.descriptor=<code>{0}</code> 可能在 ''finally'' 塊內引發 #loc
throw,from.finally.block.everywhere.option=警告隨處都可能引發宣告的異常
throw.caught.locally.problem.descriptor=通過包含 'try' 語句捕獲 <code>#ref</code> #loc
throw.caught.locally.ignore.option=忽略重新拋出的異常
return.from.finally.block.problem.descriptor='return' 位於 'finally' 塊內 #loc
continue.or.break.from.finally.block.problem.descriptor=<code>#ref</code> 位於 'finally' 塊內 #loc
bad.exception.declared.problem.descriptor=已宣告禁止異常 <code>#ref</code> #loc
bad.exception.caught.problem.descriptor=已捕獲禁止異常 <code>#ref</code> #loc
checked.exception.class.problem.descriptor=已檢查的異常類 <code>#ref</code> #loc
unchecked.exception.class.problem.descriptor=未檢查的異常類 <code>#ref</code> #loc
thread.death.rethrown.problem.descriptor=ThreadDeath <code>#ref</code> 未重新拋出 #loc
error.rethrown.problem.descriptor=錯誤 <code>#ref</code> 未重新拋出 #loc
nested.try.statement.problem.descriptor=嵌套 <code>#ref</code> 語句 #loc
exception.from.catch.which.doesnt.wrap.problem.descriptor='catch' 塊內的 <code>#ref</code> 忽略捕獲的異常 #loc
instanceof.catch.parameter.problem.descriptor='catch' 參數 <code>#ref</code> 上的 'instanceof' #loc
non.final.field.of.exception.problem.descriptor=異常類的非 final 欄位 <code>#ref</code> #loc
unnecessary.label.on.break.statement.problem.descriptor=<code>#ref</code> 語句上的標籤不必要 #loc
unnecessary.label.on.continue.statement.problem.descriptor=<code>#ref</code> 語句上的標籤不必要 #loc
trivial.if.problem.descriptor=<code>#ref</code> 語句可以簡化 #loc
unnecessary.parentheses.problem.descriptor=<code>#ref</code> 周圍的圓括號不必要 #loc
unnecessary.local.variable.problem.descriptor=局部變數 <code>#ref</code> 是冗餘的 #loc
unnecessary.this.problem.descriptor=<code>#ref</code> 在此上下文中不必要 #loc
unnecessary.block.statement.problem.descriptor=此語句周圍的大括號不必要 #loc
unnecessary.continue.problem.descriptor=<code>#ref</code> 不必要，因為是迴圈中的最後一條語句 #loc
unnecessary.semicolon.problem.descriptor=不必要的分號 <code>#ref</code> #loc
unnecessary.semicolon.ignore.after.enum.constants.option=忽略枚舉常數後的不必要分號
unnecessary.fully.qualified.name.problem.descriptor1=限定符 <code>#ref</code> 不必要，可以取代為匯入 #loc
unnecessary.fully.qualified.name.problem.descriptor2=限定符 <code>#ref</code> 不必要，可以移除 #loc
unnecessary.qualifier.for.this.problem.descriptor='this' 上的限定符 <code>#ref</code> 在此上下文中不必要 #loc
unnecessary.qualifier.for.super.problem.descriptor='super' 上的限定符 <code>#ref</code> 在此上下文中不必要 #loc
unused.label.problem.descriptor=未使用的標籤 <code>#ref</code> #loc
redundant.field.initialization.problem.descriptor=<code>#ref</code> 的欄位初始化是冗餘的 #loc
redundant.implements.problem.descriptor=冗餘接口宣告 <code>#ref</code> #loc
extends.object.problem.descriptor=類 <code>#ref</code> 顯式擴展 'java.lang.Object' #loc
type.parameter.extends.object.problem.descriptor1=類型參數 <code>#ref</code> 顯式擴展 'java.lang.Object' #loc
type.parameter.extends.object.problem.descriptor2=萬用字元類型實參 <code>#ref</code> 顯式擴展 'java.lang.Object' #loc
unnecessary.super.constructor.problem.descriptor=<code>#ref</code> 不必要 #loc
unnecessary.constructor.problem.descriptor=無參構造函數 <code>#ref()</code> 是冗餘的 #loc
unnecessary.constructor.annotation.option=忽略有註解的構造函數
for.loop.replaceable.by.while.problem.descriptor=<code>#ref</code> 迴圈語句可以取代為 'while' 迴圈 #loc
unnecessary.default.problem.descriptor=<code>#ref</code> 分支不必要 #loc
unnecessary.default.expressions.option=僅報告 switch 表達式
unnecessary.default.quickfix=移除 'default' 分支
unnecessary.boxing.problem.descriptor=不必要的裝箱 <code>#ref</code> #loc
unnecessary.boxing.inside.value.of.problem.descriptor=<code>#ref</code> 內的裝箱冗餘 #loc
unnecessary.unboxing.problem.descriptor=不必要的拆箱 <code>#ref</code> #loc
unnecessary.boxing.superfluous.option=僅報告真正多餘的裝箱表達式
unnecessary.unboxing.superfluous.option=僅報告真正多餘的拆箱表達式
for.can.be.foreach.problem.descriptor=<code>#ref</code> 迴圈可取代為增強的 'for' #loc
while.can.be.foreach.problem.descriptor=<code>#ref</code> 迴圈可取代為增強的 'for' #loc
too.broad.scope.problem.descriptor=變數 <code>#ref</code> 的範圍過寬 #loc
return.this.problem.descriptor=返回 <code>#ref</code> #loc
constant.on.side.of.comparison.display.name=常數位於比較的錯誤一側
constant.on.lhs.of.comparison.problem.descriptor=常數 <code>#ref</code> 位於比較的左側 #loc
constant.on.rhs.of.comparison.problem.descriptor=常數 <code>#ref</code> 位於比較的右側 #loc
control.flow.statement.without.braces.problem.descriptor=不帶大括號的 <code>{0}</code> #loc
missorted.modifiers.problem.descriptor=錯位修飾符 <code>{0}</code> #loc
cstyle.array.variable.declaration.problem.descriptor={0, choice, 1#欄位|2#參數|3#記錄組件|4#局部變數} <code>#ref</code> 的 C 樣式陣列宣告 #loc
cstyle.array.method.declaration.problem.descriptor=方法 <code>#ref()</code> 返回類型的 C 樣式陣列宣告 #loc
multiple.declaration.problem.descriptor=一個宣告中的多個變數 #loc
multiple.typed.declaration.problem.descriptor=在一個宣告中具有不同陣列維度的變數 #loc
serializable.inner.class.has.serial.version.uid.field.problem.descriptor=內部類 <code>#ref</code> 未定義 'serialVersionUID' 欄位 #loc
serializable.inner.class.with.non.serializable.outer.class.problem.descriptor=內部類 <code>#ref</code> 可序列化，而其外部類不可序列化 #loc
busy.wait.problem.descriptor=在迴圈中調用 <code>Thread.#ref()</code>，可能處於忙等待 #loc
sleep.while.holding.lock.problem.descriptor=同步時調用 <code>Thread.#ref()</code> #loc
non.atomic.operation.on.volatile.field.problem.descriptor=volatile 欄位 <code>#ref</code> 上的非原子操作 #loc
call.to.native.method.while.locked.problem.descriptor=在同步上下文中調用本地方法 <code>#ref()</code> #loc
object.notify.problem.descriptor=<code>#ref</code> 可能應當取代為 'notifyAll()' #loc
condition.signal.problem.descriptor=<code>#ref</code> 可能應當取代為 'signalAll()' #loc
thread.with.default.run.method.problem.descriptor=使用預設的 'run()' 方法實例化 <code>#ref</code> #loc
extends.thread.problem.descriptor=類 <code>#ref</code> 直接擴展 'java.lang.Thread' #loc
anonymous.extends.thread.problem.descriptor=匿名類直接擴展 'java.lang.Thread' #loc
naked.notify.problem.descriptor=在沒有相應狀態更改的情況下調用 <code>#ref()</code> #loc
unconditional.wait.problem.descriptor=無條件調用 <code>#ref()</code> #loc
system.run.finalizers.on.exit.problem.descriptor=調用 <code>System.#ref()</code> #loc
thread.priority.problem.descriptor=調用 <code>Thread.#ref()</code> #loc
thread.yield.problem.descriptor=調用 <code>Thread.#ref()</code> #loc
thread.stop.suspend.resume.problem.descriptor=調用 <code>Thread.#ref()</code> #loc
while.loop.spins.on.field.problem.descriptor=<code>#ref</code> 迴圈在欄位上自旋 #loc
wait.not.in.loop.problem.descriptor=<code>#ref()</code> 調用不在迴圈中 #loc
await.not.in.loop.problem.descriptor=<code>#ref()</code> 調用不在迴圈中 #loc
wait.called.on.condition.problem.descriptor=在條件物件上調用 <code>#ref()</code> #loc
notify.called.on.condition.problem.descriptor=在條件物件上調用 <code>#ref()</code> #loc
wait.while.holding.two.locks.problem.descriptor=在保持兩個鎖的情況下調用 <code>#ref()</code> #loc
thread.run.problem.descriptor=對 <code>#ref()</code> 的調用可能應當取代為 'start()' #loc
thread.start.in.construction.problem.descriptor=物件構造期間調用 <code>#ref()</code> #loc
synchronize.on.lock.problem.descriptor=在 ''{0}'' 物件上同步不太可能是故意的 #loc
synchronized.on.literal.object.problem.descriptor=在由文字初始化的 {0} <code>#ref</code> 上同步 #loc
synchronized.on.direct.literal.object.problem.descriptor=在 {0} 文字 <code>#ref</code> 上同步 #loc
synchronized.on.possibly.literal.object.problem.descriptor=在 {0} <code>#ref</code> 上同步 #loc
synchronize.on.non.final.field.problem.descriptor=在非 final 欄位 <code>#ref</code> 上同步 #loc
synchronized.on.literal.object.warn.on.all.option=警告所有可能的文字
synchronize.on.this.problem.descriptor=對 'this' 的鎖定操作可能會產生不可預見的副作用 #loc
synchronize.on.class.problem.descriptor=對類的鎖定操作可能會產生不可預見的副作用 #loc
nested.synchronized.statement.problem.descriptor=嵌套 <code>#ref</code> 語句 #loc
empty.synchronized.statement.problem.descriptor=空 <code>#ref</code> 語句 #loc
non.synchronized.method.overrides.synchronized.method.problem.descriptor=未同步方法 <code>#ref()</code> 覆寫 synchronized 方法 #loc
public.field.accessed.in.synchronized.context.problem.descriptor=在同步上下文中存取非 private 欄位 <code>#ref</code> #loc
field.accessed.synchronized.and.unsynchronized.problem.descriptor=同時在同步和未同步上下文中存取欄位 <code>#ref</code> #loc
extended.for.statement.problem.descriptor=擴展 <code>#ref</code> 語句 #loc
object.allocation.in.loop.new.descriptor=迴圈中的物件分配 <code>new #ref()</code> #loc
object.allocation.in.loop.problem.array.initializer.descriptor=迴圈中的陣列分配 #loc
object.allocation.in.loop.problem.call.descriptor=物件分配通過迴圈中的 <code>#ref()</code> 調用完成 #loc
object.allocation.in.loop.problem.methodref.descriptor=物件分配通過迴圈中的實例綁定方法引用 <code>#ref()</code> 完成 #loc
object.allocation.in.loop.problem.lambda.descriptor=物件分配通過捕獲迴圈中的 lambda 完成 #loc
object.allocation.in.loop.problem.string.concat=物件分配通過迴圈中的字串串聯完成 #loc
instantiating.object.to.get.class.object.problem.descriptor=實例化物件以獲取類物件 #loc
field.may.be.static.problem.descriptor=欄位 <code>#ref</code> 可能為 'static' #loc
method.may.be.static.problem.descriptor=方法 <code>#ref()</code> 可能為 'static' #loc
class.initializer.may.be.static.problem.descriptor=類初始值設定項可能為 'static' #loc
map.replaceable.by.enum.map.problem.descriptor=<code>#ref</code> 可取代為 'EnumMap' #loc
set.replaceable.by.enum.set.problem.descriptor=<code>#ref</code> 可取代為 'EnumSet' #loc
inner.class.may.be.static.problem.descriptor=內部類 <code>#ref</code> 可能為 'static' #loc
string.buffer.must.have.initial.capacity.problem.descriptor=沒有初始容量的 <code>new #ref()</code> #loc
string.buffer.replaceable.by.string.builder.problem.descriptor=<code>StringBuffer #ref</code> 可能被宣告為 'StringBuilder' #loc
string.buffer.replaceable.by.string.problem.descriptor=<code>{0} #ref</code> 可以取代為 ''String'' #loc
new.string.buffer.replaceable.by.string.problem.descriptor=<code>#ref</code> 可以取代為 'String' #loc
string.replaceable.by.string.buffer.problem.descriptor=非常數 <code>String #ref</code> 可能應被宣告為 'StringBuilder' #loc
collections.must.have.initial.capacity.problem.descriptor=沒有初始容量的 <code>new #ref()</code> #loc
string.concatenation.in.loops.problem.descriptor=迴圈中的字串串聯 <code>#ref</code> #loc
string.concatenation.inside.string.buffer.append.problem.descriptor=字串串聯作為 <code>{0}.#ref()</code> 調用的實參 #loc
boolean.constructor.problem.descriptor=布爾構造函數調用 #loc
string.buffer.to.string.in.concatenation.problem.descriptor=在串聯中調用 <code>{0}.#ref()</code> #loc
tail.recursion.problem.descriptor=尾部遞歸調用 <code>#ref()</code> #loc
string.equals.empty.string.problem.descriptor=<code>#ref(\\"\\")</code> 可以取代為 'length()==0' #loc
string.equals.empty.string.is.empty.problem.descriptor=<code>#ref(\\"\\")</code> 可以取代為 'isEmpty()' #loc
random.double.for.random.integer.problem.descriptor=使用 <code>Random.#ref</code> 創建隨機整數 #loc
manual.array.copy.problem.descriptor=手動陣列複製 #loc
manual.array.to.collection.copy.problem.descriptor=手動陣列到集合複製 #loc
call.to.simple.getter.in.class.problem.descriptor=從類內調用簡單 getter <code>#ref()</code> #loc
call.to.simple.setter.in.class.problem.descriptor=從類內調用簡單 setter <code>#ref()</code> #loc
assert.without.message.problem.descriptor=沒有訊息的 <code>#ref()</code> #loc
assert.without.message.quick.fix.family.name=添加錯誤訊息
test.case.with.constructor.problem.descriptor=構造函數 <code>#ref()</code> 中的初始化邏輯，而不是 'setUp()' #loc
test.case.with.constructor.problem.descriptor.initializer=初始值設定項中的初始化邏輯，而不是 'setUp()'
misordered.assert.equals.arguments.problem.descriptor=<code>#ref()</code> 的實參順序錯誤 #loc
static.suite.problem.descriptor=Junit <code>#ref()</code> 方法未被宣告為 'static' #loc
simplifiable.junit.assertion.problem.descriptor=<code>#ref()</code> 可以簡化為 ''{0}'' #loc
test.method.without.assertion.problem.descriptor=JUnit 測試方法 <code>#ref()</code> 不包含斷言 #loc
test.case.with.no.test.methods.problem.descriptor=測試類 <code>#ref</code> 沒有測試 #loc
test.case.in.product.code.problem.descriptor=測試用例 <code>#ref</code> 可能應當放置在測試源樹中 #loc
test.method.in.product.code.problem.descriptor=測試方法 <code>#ref()</code> 可能應當放置在測試源樹中 #loc
unconstructable.test.case.problem.descriptor=測試用例 <code>#ref</code> 不能被大多數測試運行程序構造 #loc
deserializable.class.in.secure.context.problem.descriptor=類 <code>#ref</code> 可能被反序列化，影響安全性 #loc
serializable.class.in.secure.context.problem.descriptor=類 <code>#ref</code> 可能被序列化，影響安全性 #loc
serializable.deserializable.class.in.secure.context.problem.descriptor=類 <code>#ref</code> 可能被序列化和反序列化，影響安全性 #loc
cloneable.class.in.secure.context.problem.descriptor=類 <code>#ref</code> 可能被克隆，影響安全性 #loc
cloneable.class.in.secure.context.quickfix=生成始終拋出異常的 'clone()' 方法
remove.cloneable.quickfix=從 'implements' 子句中移除 'Cloneable'
non.final.clone.problem.descriptor=非 final <code>#ref()</code> 方法，影響安全性 #loc
runtime.exec.with.non.constant.string.problem.descriptor=<code>Runtime.#ref()</code> 調用具有非常數實參 #loc
load.library.with.non.constant.string.problem.descriptor=<code>{0}.#ref()</code> 調用具有非常數實參 #loc
jdbc.execute.with.non.constant.string.problem.descriptor=<code>Statement.#ref()</code> 調用具有非常數實參 #loc
jdbc.prepare.statement.with.non.constant.string.problem.descriptor=<code>Connection.#ref()</code> 調用具有非常數實參 #loc
custom.classloader.problem.descriptor=自訂 ClassLoader 類 <code>#ref</code> #loc
custom.security.manager.problem.descriptor=自訂 SecurityManager 類 <code>#ref</code> #loc
system.set.problem.descriptor=對 <code>System.#ref()</code> 的調用可能造成安全問題 #loc
class.loader.instantiation.problem.descriptor=實例化 <code>#ref</code> 可能造成安全問題 #loc
public.static.array.field.problem.descriptor='public static' 陣列欄位 <code>#ref</code>，影響安全性 #loc
public.static.collection.field.problem.descriptor='public static' 集合欄位 <code>#ref</code>，影響安全性 #loc
abstract.class.with.only.one.direct.inheritor.problem.descriptor=只有一個直接繼承者的 abstract 類 <code>#ref</code> #loc

#other
abstract.method.overrides.abstract.method.remove.quickfix=移除冗餘 abstract 方法宣告
class.may.be.interface.convert.quickfix=將類轉換為接口
class.without.constructor.create.quickfix=生成空構造函數
class.without.no.arg.constructor.ignore.option=如果類具有預設構造函數，則忽略
extends.annotation.problem.descriptor=類 ''{0}'' 實作註解接口 <code>#ref</code> #loc
extends.annotation.interface.problem.descriptor=接口 ''{0}'' 擴展註解接口 <code>#ref</code> #loc
extends.concrete.collection.problem.descriptor=類 <code>#ref</code> 顯式擴展 ''{0}'' #loc
anonymous.extends.concrete.collection.problem.descriptor=匿名類顯式擴展 ''{0}'' #loc
inner.class.on.interface.ignore.option=忽略接口的內部接口
inner.class.on.interface.problem.descriptor=接口 ''{0}'' 具有內部類 <code>#ref</code> #loc
missing.deprecated.annotation.add.quickfix=添加 @Deprecated 註解
missing.add.deprecated.javadoc.tag.quickfix=添加 '@deprecated' Javadoc 標記
non.protected.constructor.in.abstract.class.ignore.option=對非 public 類忽略
public.constructor.in.non.public.class.problem.descriptor=構造函數在非 public 類 ''{0}'' 中被宣告為 <code>#ref</code> #loc
static.inheritance.replace.quickfix=將繼承取代為 {0} 中的限定引用
utility.class.with.public.constructor.make.quickfix=將{0, choice, 1#構造函數|2#構造函數}設為 'private'
utility.class.without.private.constructor.create.quickfix=生成空 'private' 構造函數
utility.class.without.private.constructor.make.quickfix=將構造函數設為 'private'
naming.convention.problem.descriptor.short={0} 名稱 <code>#ref</code> 過短({1} < {2}) #loc
naming.convention.problem.descriptor.long={0} 名稱 <code>#ref</code> 過長({1} > {2}) #loc
naming.convention.problem.descriptor.regex.mismatch={0} 名稱 <code>#ref</code> 不符合正則表達式 ''{1}'' #loc
local.variable.naming.convention.ignore.option=忽略 for 迴圈參數
local.variable.naming.convention.ignore.catch.option=忽略 'catch' 塊參數
method.names.differ.only.by.case.problem.descriptor=方法名稱 <code>#ref</code> 和方法名稱 ''{0}'' 僅大小寫不同 #loc
parameter.name.differs.from.overridden.parameter.ignore.character.option=如果覆寫的參數僅包含一個字符，則忽略
parameter.name.differs.from.overridden.parameter.ignore.library.option=如果覆寫的參數來自庫，則忽略
parameter.name.differs.from.overridden.parameter.problem.descriptor=參數名稱 <code>#ref</code> 與覆寫的參數 ''{0}'' 不同 #loc
questionable.name.column.title=名稱
questionable.name.list.label=報告的名稱:
standard.variable.names.problem.descriptor=變數命名 <code>#ref</code> 沒有類型 ''{0}'' #loc
standard.variable.names.problem.descriptor2=變數命名 <code>#ref</code> 沒有類型 ''{0}'' 或 ''{1}'' #loc
standard.variable.names.ignore.override.option=對與 super 方法參數相同的參數名稱忽略
boolean.method.name.must.start.with.question.table.column.name=布爾方法名稱前綴
boolean.method.name.must.start.with.question.table.label=布爾方法名稱前綴:
conditional.expression.with.identical.branches.collapse.quickfix=摺疊條件表達式
redundant.else.unwrap.quickfix=移除冗餘的 'else'
constant.conditional.expression.problem.descriptor=<code>#ref</code> 可以簡化為 ''{0}'' #loc
constant.conditional.expression.simplify.quickfix=簡化
constant.conditional.expression.simplify.quickfix.sideEffect=提取副作用並簡化
enum.switch.statement.which.misses.cases.problem.descriptor.single=枚舉類型 ''{0}'' 上的 <code>#ref</code> 語句缺少 case ''{1}'' #loc
enum.switch.statement.which.misses.cases.problem.descriptor=枚舉類型 ''{0}'' 上的 <code>#ref</code> 語句缺少 case: {1} #loc
for.loop.replaceable.by.while.ignore.option=忽略無條件的 'infinite' for 迴圈
for.loop.with.missing.component.problem.descriptor1=<code>#ref</code> 語句缺少初始值設定項 #loc
for.loop.with.missing.component.problem.descriptor2=<code>#ref</code> 語句缺少條件 #loc
for.loop.with.missing.component.problem.descriptor3=<code>#ref</code> 語句缺少更新 #loc
for.loop.with.missing.component.problem.descriptor4=<code>#ref</code> 語句缺少初始值設定項和條件 #loc
for.loop.with.missing.component.problem.descriptor5=<code>#ref</code> 語句缺少初始值設定項和條件 #loc
for.loop.with.missing.component.problem.descriptor6=<code>#ref</code> 語句缺少條件和更新 #loc
for.loop.with.missing.component.problem.descriptor7=<code>#ref</code> 語句缺少初始值設定項、條件和更新 #loc
foreach.replace.quickfix=取代為增強 'for'
unnecessary.boxing.remove.quickfix=移除裝箱
unnecessary.unboxing.remove.quickfix=移除拆箱
misordered.assert.equals.arguments.flip.quickfix=翻轉比較實參
simplify.junit.assertion.simplify.quickfix=簡化斷言
test.method.is.public.void.no.arg.problem.descriptor1=測試方法 <code>#ref()</code> 不應具有參數 #loc
test.method.is.public.void.no.arg.problem.descriptor2=測試方法 <code>#ref()</code> 未被宣告為 'public void' #loc
test.method.is.public.void.no.arg.problem.descriptor3=測試方法 <code>#ref()</code> 不應為 'static' #loc
system.properties.problem.descriptor=對 <code>Integer.#ref()</code> 的調用可能造成安全問題 #loc
system.properties.problem.descriptor1=對 <code>Boolean.#ref()</code> 的調用可能造成安全問題 #loc
unsecure.random.number.generation.problem.descriptor1=出於安全目的，請使用 'java.security.SecureRandom' 而不是 <code>java.lang.Math.#ref()</code> #loc
unsecure.random.number.generation.problem.descriptor2=出於安全目的，請使用 'java.security.SecureRandom' 而不是 <code>java.util.#ref</code> #loc
unsecure.random.number.generation.problem.descriptor3=出於安全目的，請使用 'java.security.SecureRandom' 而不是 <code>#ref</code> #loc
serializable.has.serialization.methods.problem.descriptor=可序列化類 <code>#ref</code> 未定義 'readObject()' 或 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor1=可序列化類 <code>#ref</code> 未定義 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor2=可序列化類 <code>#ref</code> 未定義 'readObject()' #loc
serializable.with.unconstructable.ancestor.problem.descriptor=<code>#ref</code> 具有不帶無參構造函數的不可序列化上級 ''{0}'' #loc
transient.field.in.non.serializable.class.problem.descriptor=欄位 ''{0}'' 已在不可序列化類中標記為 <code>#ref</code> #loc
safe.lock.problem.descriptor=''{0}'' 應在 ''try'' 塊之前鎖定，並在相應的 ''finally'' 塊中解鎖 #loc
synchronized.method.problem.descriptor=方法 ''{0}()'' 被宣告為 <code>#ref</code> #loc
synchronized.method.include.option=包含本地方法
synchronized.method.ignore.synchronized.super.option=忽略覆寫 synchronized 方法的方法
synchronized.method.move.quickfix=將同步移動到方法中
volatile.field.problem.descriptor=類型 ''{0}'' 的 volatile 欄位 <code>#ref</code> #loc
string.format.choose.class=選擇格式化程序類
string.format.class.column.name=附加格式化程序類
string.format.class.label=附加格式化程序類:
string.format.class.method.name=附加格式化程序方法
string.format.class.method.label=附加格式化程序方法:
exception.class.column.name=異常類
bad.exception.thrown.problem.descriptor=已拋出禁止異常 ''{0}'' #loc
too.broad.catch.problem.descriptor=<code>#ref</code> 的 ''catch'' 過寬，遮罩異常 ''{0}'' #loc
too.broad.catch.problem.descriptor1=<code>#ref</code> 的 ''catch'' 過寬，遮罩異常 ''{0}'' 和 ''{1}'' #loc
add.serialversionuidfield.quickfix=添加 'serialVersionUID' 欄位
delete.import.quickfix=刪除不必要的匯入
encapsulate.variable.quickfix=封裝欄位 ''{0}''
extract.method.quickfix=提取方法
inline.call.quickfix=內聯調用
inline.variable.quickfix=內聯變數
pointless.nullcheck.display.name=方法調用前出現不必要的 'null' 檢查
pointless.nullcheck.problem.descriptor.call=''{0}()'' 調用之前的 ''null'' 檢查不必要
remove.redundant.polyadic.operand.fix.name=移除不必要的 ''{0}'' 條件
remove.redundant.polyadic.operand.fix.family.name=移除不必要的條件
introduce.constant.quickfix=引入常數
make.initialization.explicit.quickfix=使初始化顯式
move.anonymous.to.inner.quickfix=轉換為命名內部類
anonymous.inner.may.be.named.static.inner.class.quickfix=轉換為命名 'static' 內部類
move.class.quickfix=移動類
normalize.declaration.quickfix=拆分為單獨的宣告
remove.modifier.quickfix=移除 ''{0}'' 修飾符
replace.inheritance.with.delegation.quickfix=將繼承取代為委託
cast.that.loses.precision.problem.descriptor=''{0}'' 到 <code>#ref</code> 的轉換可能導致精度損失 #loc
cast.that.loses.precision.negative.problem.descriptor=''{0}'' 到 <code>#ref</code> 的轉換可能導致負實參的精度損失 #loc
comparison.to.nan.problem.descriptor1=與 <code>#ref</code> 的比較始終為 false #loc
comparison.to.nan.problem.descriptor2=與 <code>#ref</code> 的比較始終為 true #loc
confusing.floating.point.literal.change.quickfix=更改為規範形式
implicit.numeric.conversion.ignore.widening.conversion.option=忽略擴大轉換
implicit.numeric.conversion.ignore.char.conversion.option=忽略 'char' 之間的轉換
implicit.numeric.conversion.ignore.constant.conversion.option=忽略從常數和文字的轉換
implicit.numeric.conversion.problem.descriptor=將 <code>#ref</code> 從 ''{0}'' 隱式數字轉換為 ''{1}'' #loc
implicit.numeric.conversion.assignment.problem.descriptor=將結果值從 ''{0}'' 隱式數字轉換為 ''{1}'' #loc
implicit.numeric.conversion.make.explicit.quickfix=使轉換顯式
non.reproducible.math.call.replace.quickfix=取代為 'StrictMath' 調用
overly.complex.arithmetic.expression.max.number.option=最大項數:
expression.can.be.replaced.problem.descriptor=<code>#ref</code> 可以取代為 ''{0}'' #loc
method.complexity.limit.option=方法復雜度限制:
expression.can.be.replaced.no.quotes.problem.descriptor={0} 可以取代為 {1}
cyclomatic.complexity.problem.descriptor=過度複雜的方法 <code>#ref()</code> (迴圈復雜度 = {0}) #loc
method.coupling.limit.option=方法耦合限制:
method.coupling.problem.descriptor=<code>#ref</code> 過度耦合 (# 引用的類 = {0}) #loc
method.with.multiple.loops.problem.descriptor=<code>#ref</code> 包含 {0} 個迴圈 #loc
return.point.limit.option=返回點限制(&R):
multiple.return.points.per.method.problem.descriptor=<code>#ref</code> 具有 {0} 個返回點 #loc
nesting.depth.limit.option=嵌套深度限制:
nesting.depth.problem.descriptor=<code>#ref</code> 過度嵌套 (最大嵌套深度 = {0}) #loc
non.comment.source.statements.limit.option=非註釋源語句限制:
non.comment.source.statements.problem.descriptor=<code>#ref</code> 過長 (# 非註釋源語句 = {0}) #loc
parameters.per.method.problem.descriptor=<code>#ref()</code> 的參數過多(參數數量 = {0}) #loc
parameters.per.constructor.problem.descriptor=<code>#ref()</code> 的參數過多(參數數量 = {0}) #loc
parameter.limit.option=參數限制:
constructor.visibility.option=忽略具有以下可見性的構造函數:
three.negations.per.method.ignore.option=忽略 'equals()' 方法中的否定
three.negations.per.method.ignore.assert.option=忽略 'assert' 語句中的否定
three.negations.per.method.problem.descriptor=<code>#ref</code> 包含 {0} 個否定 #loc
thrown.exceptions.per.method.problem.descriptor=<code>#ref</code> 宣告的異常過多 (異常數量 = {0}) #loc
thrown.exceptions.per.method.limit.option=異常拋出限制:
call.to.simple.getter.in.class.ignore.option=忽略其他物件上的 getter 調用
call.to.private.simple.getter.in.class.option=僅在 getter 為 'private' 時報告
call.to.simple.getter.in.class.inline.quickfix=內聯調用 getter
call.to.simple.setter.in.class.ignore.option=忽略其他物件上的 setter 調用
call.to.private.setter.in.class.option=僅在 setter 為 'private' 時報告
call.to.simple.setter.in.class.inline.quickfix=內聯調用 setter
make.static.quickfix=設為 'static'
length.one.strings.in.concatenation.replace.quickfix=取代為字符
multiply.or.divide.by.power.of.two.replace.quickfix=取代為移位
boolean.expression.can.be.simplified.problem.descriptor=<code>#ref</code> 可以簡化為 ''{0}'' #loc
boolean.expression.does.not.modify.problem.descriptor=<code>#ref</code> 未修改 ''{0}'' 的值 #loc
boolean.expression.remove.compound.assignment.quickfix=移除無意義的復合賦值
trivial.string.concatenation.problem.descriptor=串聯中使用的空字串
string.replace.quickfix=將串聯取代為 ''{0}''
instantiating.object.to.get.class.object.replace.quickfix=取代為直接類物件存取
method.may.be.static.only.option=僅檢查 'private' 或 'final' 方法
method.may.be.static.empty.option=忽略空方法
string.concatenation.inside.string.buffer.append.replace.quickfix=取代為鏈式 'append()' 調用
string.equals.empty.string.option.do.not.add.null.check=當有必要進行 null 檢查時，不必報告
tail.recursion.replace.quickfix=用迭代替換尾部遞歸
if.statement.with.too.many.branches.max.option=最大分支數:
if.statement.with.too.many.branches.problem.descriptor=<code>#ref</code> 的分支過多 ({0}) #loc
negated.conditional.invert.quickfix=反轉條件
negated.if.else.ignore.negated.null.option=忽略 '!= null' 比較
negated.if.else.ignore.negated.zero.option=忽略 '!= 0' 比較
negated.if.else.invert.quickfix=反轉 'if' 條件
overly.complex.boolean.expression.max.terms.option=最大項數:
pointless.boolean.expression.ignore.option=在確定無意義表達式時忽略命名常數
simplifiable.conditional.expression.problem.descriptor=<code>#ref</code> 可以簡化為 ''{0}'' #loc
switch.statement.density.min.option=分支的最小密度: %
switch.statement.density.problem.descriptor=<code>#ref</code> 的分支密度過低 ({0}%) #loc
switch.statement.with.too.few.branches.min.option=最小分支數:
switch.statement.with.too.few.branches.problem.descriptor=''switch'' 語句的 case 標籤太少({0})，並且可能應當取代為 ''if'' 語句 #loc
switch.statement.with.single.default.message='switch' 語句只有 'default' case
switch.expression.with.too.few.branches.problem.descriptor=''switch'' 表達式的 case 標籤太少 ({0})，並且可能應當取代為 ''if'' 語句或條件運算符 #loc
switch.expression.with.single.default.message='switch' 表達式只有 'default' case
switch.statement.without.default.ignore.option=忽略詳盡的 switch 語句
unnecessary.label.remove.quickfix=移除標籤
unnecessary.return.problem.descriptor=<code>#ref</code> 不必要，因為是 'void' 方法中的最後一條語句 #loc
unnecessary.return.constructor.problem.descriptor=<code>#ref</code> 不必要，因為是構造函數中的最後一條語句 #loc
unused.label.remove.quickfix=移除未使用的標籤
unnecessarily.qualified.static.usage.problem.descriptor=不必要的限定 static 方法調用 <code>{0}()</code> #loc
unnecessarily.qualified.static.usage.problem.descriptor1=不必要的限定靜態存取 <code>{0}</code> #loc
unnecessarily.qualified.static.usage.ignore.field.option=忽略不必要的限定欄位存取
unnecessarily.qualified.static.usage.ignore.method.option=忽略不必要的限定方法調用
unnecessary.interface.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於接口是冗餘的 #loc
unnecessary.interface.modifier.inner.interface.of.interface.problem.descriptor=修飾符 <code>#ref</code> 對於內部接口是冗餘的 #loc
unnecessary.interface.modifier.problem.descriptor2=修飾符 <code>#ref</code> 對於接口方法是冗餘的 #loc
unnecessary.interface.modifier.problem.descriptor3=修飾符 <code>#ref</code> 對於接口的內部類是冗餘的 #loc
unnecessary.interface.modifier.problem.descriptor4=修飾符 <code>#ref</code> 對於接口欄位是冗餘的 #loc
smth.unnecessary.remove.quickfix=移除不必要的 ''{0}''
unqualified.static.usage.problem.descriptor=非限定 static 方法調用 <code>#ref()</code> #loc
unqualified.static.usage.problem.descriptor1=非限定 static 欄位存取 <code>#ref</code> #loc
unqualified.static.usage.ignore.field.option=忽略非限定欄位存取
unqualified.static.usage.ignore.method.option=忽略非限定方法調用
unqualified.static.usage.qualify.field.quickfix=限定 static 欄位存取
unqualified.static.usage.qualify.method.quickfix=限定 static 方法調用
too.broad.scope.allow.option=<html>報告使用新表達式作為初始值設定項的變數<br>(可能不安全)</html>
too.broad.scope.only.blocks.option=僅報告可移入內部塊的變數
too.broad.scope.narrow.quickfix=將 ''{0}'' 的宣告移近用法
press.escape.to.remove.highlighting.message=按 Esc 移除高亮顯示
unnecessary.enum.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於枚舉構造函數是冗餘的 #loc
unnecessary.enum.modifier.problem.descriptor1=修飾符 <code>#ref</code> 對於內部枚舉是冗餘的 #loc
literal.as.arg.to.string.equals.problem.descriptor=文字 #ref 是 ''{0}()'' 的實參，而不是其限定符 #loc
literal.as.arg.to.string.equals.flip.quickfix=翻轉 ''{0}()''
c.style.array.declaration.replace.quickfix=取代為 Java 樣式陣列宣告
chained.method.call.ignore.option=忽略欄位初始值設定項中的鏈式方法調用
chained.method.call.ignore.self.types.option=忽略對返回類型與其封閉類相同的方法的調用
introduce.variable.quickfix=引入變數
introduce.variable.may.change.semantics.quickfix=引入變數 (可能更改語意)
flip.comparison.quickfix=翻轉比較
control.flow.statement.without.braces.add.quickfix=將大括號添加到語句
control.flow.statement.without.braces.message=將大括號添加到 ''{0}'' 語句
extends.object.remove.quickfix=移除冗餘的 'extends Object'
implicit.call.to.super.ignore.option=對 'java.lang.Object' 的直接子類忽略
implicit.call.to.super.make.explicit.quickfix=使對 'super()' 的調用顯式
missorted.modifiers.require.option=檢查註解順序
missorted.modifiers.typeuse.before.type.option=目標 TYPE_USE 註解始終位於類型前
missorted.modifiers.sort.quickfix=對修飾符排序
nested.method.call.ignore.option=忽略欄位初始值設定項中的嵌套方法調用
ignore.calls.to.static.methods=忽略對 static 方法的調用
ignore.calls.to.property.getters=忽略對屬性 getter 的調用
redundant.field.initialization.remove.quickfix=移除初始值設定項
redundant.implements.remove.quickfix=移除冗餘接口宣告
unnecessary.constructor.remove.quickfix=移除冗餘構造函數
unnecessary.fully.qualified.name.replace.quickfix=將限定名稱取代為匯入
unnecessary.fully.qualified.name.remove.quickfix=移除不必要的限定
unnecessary.fully.qualified.name.status.bar.escape.highlighting.message={0} 個完全限定{0, choice, 1#名稱|2#名稱}取代為匯入 (按 Esc 移除高亮顯示)
unnecessary.parentheses.remove.quickfix=移除不必要的圓括號
unnecessary.qualifier.for.this.remove.quickfix=移除不必要的限定符
unnecessary.semicolon.remove.quickfix=移除不必要的分號
unnecessary.super.constructor.remove.quickfix=移除不必要的 'super()'
unnecessary.this.remove.quickfix=移除不必要的 'this' 限定符
overly.strong.type.cast.problem.descriptor=到 <code>#ref</code> 的轉換可以被削弱為 ''{0}'' #loc
field.count.inspection.include.constant.fields.in.count.checkbox=在計數中包含常數欄位
field.count.inspection.static.final.fields.count.as.constant.checkbox=將 'static final' 欄位計為常數
field.count.inspection.include.enum.constants.in.count=在計數中包含枚舉常數
make.method.final.fix.name=將方法 ''{0}()'' 設為 ''final''
make.class.final.fix.name=將類 ''{0}'' 設為 ''final''
non.boolean.method.name.must.not.start.with.question.display.name=非布爾方法名稱不能以疑問詞開頭
non.boolean.method.name.must.not.start.with.question.problem.descriptor=非布爾方法名稱 <code>#ref</code> 以疑問詞開頭 #loc
boolean.constructor.simplify.quickfix=簡化
unnecessary.temporary.on.conversion.from.string.problem.descriptor=<code>#ref</code> #loc 可以簡化為 ''{0}''
only.report.qualified.static.usages.option=僅報告來自 static 上下文的限定靜態存取
unqualified,static.usage.only.report.static.usages.option=僅報告來自非 static 上下文的靜態存取
assignment.to.catch.block.parameter.problem.descriptor=賦值給 'catch' 塊參數 <code>#ref</code> #loc
assignment.to.method.parameter.problem.descriptor=賦值給方法參數 <code>#ref</code> #loc
value.of.post.increment.problem.descriptor=使用後增量表達式 <code>#ref</code> 的值 #loc
value.of.post.decrement.problem.descriptor=使用後減量表達式 <code>#ref</code> 的值 #loc
value.of.pre.increment.problem.descriptor=使用前增量表達式 <code>#ref</code> 的值 #loc
value.of.pre.decrement.problem.descriptor=使用前減量表達式 <code>#ref</code> 的值 #loc
assignment.replaceable.with.operator.assignment.problem.descriptor=<code>#ref</code> 可以簡化為 ''{0}'' #loc
assignment.replaceable.with.operator.assignment.ignore.conditional.operators.option=忽略條件運算符
assignment.replaceable.with.operator.assignment.ignore.obscure.operators.option=忽略模糊的 ^ 和 % 運算符
object.equality.ignore.between.objects.of.a.type.with.only.private.constructors.option=忽略只有 'private' 構造函數的類型物件之間的 '=='
redundant.method.override.display.name=方法與其 super 方法相同
redundant.method.override.delegates.to.super.problem.descriptor=方法 <code>#ref()</code> 僅委託給 super 方法 #loc
redundant.method.override.problem.descriptor=方法 <code>#ref()</code> 與其 super 方法相同 #loc
redundant.method.override.quickfix=移除冗餘方法
redundant.method.override.option.check.library.methods=檢查覆寫庫方法的方法
refused.bequest.problem.descriptor=方法 <code>#ref()</code> 未調用 'super.#ref()' #loc
refused.bequest.ignore.empty.super.methods.option=忽略空 super 方法
refused.bequest.ignore.default.super.methods.option=忽略 'default' super 方法
overly.complex.boolean.expression.ignore.option=忽略純合取和析取
pointless.indexof.comparison.display.name=無意義的 'indexOf()' 比較
pointless.indexof.comparison.always.true.problem.descriptor=<code>#ref</code> 始終為 true #loc
pointless.indexof.comparison.always.false.problem.descriptor=<code>#ref</code> 始終為 false #loc
reuse.of.local.variable.problem.descriptor=局部變數 <code>#ref</code> 的重用 #loc
single.character.startswith.display.name=單個字符 'startsWith()' 或 'endsWith()'
single.character.startswith.problem.descriptor=單個字符 <code>#ref()</code> 可以取代為 'charAt()' 表達式 #loc
list.indexof.replaceable.by.contains.display.name='List.indexOf()' 表達式可取代為 'contains()'
string.indexof.replaceable.by.contains.display.name='String.indexOf()' 表達式可取代為 'contains()'
overloaded.methods.with.same.number.parameters.problem.descriptor=具有相同數量參數的多個方法命名 <code>#ref</code> #loc
overloaded.vararg.method.problem.descriptor=多載 vararg 方法 <code>#ref()</code> #loc
overloaded.vararg.constructor.problem.descriptor=多載 vararg 構造函數 <code>#ref()</code> #loc
cached.number.constructor.call.display.name=數字構造函數調用具有基元實參
cached.number.constructor.call.problem.descriptor=數字構造函數調用具有基元實參 #loc
cached.number.constructor.call.ignore.string.arguments.option=忽略具有字串實參的新數字表達式
cached.number.constructor.call.report.only.deprecated=僅在構造函數為 @Deprecated 時報告
chained.equality.comparisons.problem.descriptor=鏈式相等比較 <code>#ref</code> #loc
confusing.octal.escape.sequence.problem.descriptor=八進制轉義序列 <code>#ref</code> 後面緊跟數字 #loc
field.accessed.synchronized.and.unsynchronized.option=簡單的 getter 和 setter 也被視為欄位存取
method.overrides.inaccessible.method.display.name=方法覆寫了超類不可存取的方法
method.overrides.package.local.method.problem.descriptor=方法 <code>#ref()</code> 覆寫了位於另一個軟體套件中的超類的 package-private 方法 #loc
suspicious.to.array.call.display.name=可疑的 'Collection.toArray()' 調用
suspicious.to.array.call.problem.descriptor=應為類型 ''{0}[]'' 的陣列，找到的是 ''{1}[]'' #loc
suspicious.system.arraycopy.display.name=可疑的 'System.arraycopy()' 調用
suspicious.system.arraycopy.problem.descriptor4=<code>#ref</code> 不是陣列類型 #loc
suspicious.system.arraycopy.problem.descriptor5=<code>#ref</code> 不是陣列類型 #loc
suspicious.system.arraycopy.problem.descriptor6=源參數類型 ''{0}'' 不可分配給類型為 ''{1}'' 的目標參數 <code>#ref</code> #loc
suspicious.system.arraycopy.problem.descriptor.length.bigger.src=長度始終大於 ''src.length - srcPos'' {0}
suspicious.system.arraycopy.problem.descriptor.length.bigger.dest=長度始終大於 ''dest.length - destPos'' {0}
suspicious.system.arraycopy.problem.descriptor.ranges.intersect=複製到具有相交範圍的同一陣列
method.only.used.from.inner.class.display.name=僅在內部類中使用 private 方法
method.only.used.from.inner.class.problem.descriptor=方法 <code>#ref()</code>#loc 只能從{0, choice, 1#內部|2#局部|3#}{1, choice, 1#類|2#接口|3#派生的匿名類|4#註解類型|5#枚舉|6#記錄} ''{2}'' 使用 #loc
method.only.used.from.inner.class.ignore.option=忽略從匿名類或局部類調用的方法(&A)
only.report.static.methods=僅報告 'static' 方法(&O)
single.character.startswith.quickfix=取代為 'charAt()' 表達式
interface.never.implemented.option=忽略僅宣告常數的接口
size.replaceable.by.isempty.display.name='size() == 0' 可取代為 'isEmpty()'
size.replaceable.by.isempty.negation.ignore.option=忽略將取代為 '!isEmpty()' 的表達式
size.replaceable.by.isempty.fix.ignore.calls=忽略類型 ''{1}'' 上的 ''.{0}()'' 調用
choose.class.type.to.ignore=選擇要忽略的類
loop.condition.not.updated.inside.loop.display.name=迴圈變數未在迴圈內更新
loop.variable.not.updated.inside.loop.problem.descriptor=變數 '#ref' 未在迴圈內更新#loc
loop.condition.not.updated.inside.loop.problem.descriptor=條件 '#ref' 未在迴圈內更新#loc
loop.variable.not.updated.inside.loop.option.nonlocal=忽略可能的非本地變更
utility.class.without.private.constructor.option=忽略僅具有主方法的類
super.class.logger.option=在超類有可存取的記錄器時忽略
static.method.only.used.in.one.class.display.name=static 成員僅在其他一個類中使用
static.method.only.used.in.one.class.problem.descriptor=static {0, choice, 1#方法|2#欄位} <code>#ref{0, choice, 1#()|2#}</code> 僅在 ''{1}'' 類中使用 #loc
static.method.only.used.in.one.anonymous.class.problem.descriptor=static {0, choice, 1#方法|2#欄位} <code>#ref{0, choice, 1#()|2#}</code> 僅在派生自 ''{1}'' 的匿名類中使用 #loc
static.method.only.used.in.one.class.quickfix=將 {0} 移至使用類
static.method.only.used.in.one.class.ignore.test.option=僅在測試類中使用時忽略
static.method.only.used.in.one.class.ignore.anonymous.option=僅在匿名類中使用時忽略
static.method.only.used.in.one.class.ignore.on.conflicts=當方法無法在不產生衝突的情況下移動時忽略
static.method.only.used.in.one.class.ignore.utility.classes=忽略位於實用程序類中的成員
unary.plus.display.name=一元正號
unary.plus.problem.descriptor=一元 <code>#ref</code> 運算符 #loc
await.without.corresponding.signal.display.name=沒有相應 'signal()' 的 'await()'
await.without.corresponding.signal.problem.descriptor=在沒有相應 <code>signal()</code> 或 <code>signalAll()</code> 的情況下調用 <code>#ref()</code> #loc
signal.without.corresponding.await.display.name=沒有相應 'await()' 的 'signal()'
signal.without.corresponding.await.problem.descriptor=在沒有相應 <code>await()</code> 的情況下調用 <code>#ref()</code> #loc
wait.without.corresponding.notify.display.name=沒有相應 'notify()' 的 'wait()'
wait.without.corresponding.notify.problem.descriptor=在沒有相應 <code>notify()</code> 或 <code>notifyAll()</code> 的情況下調用 <code>#ref()</code> #loc
notify.without.corresponding.wait.display.name=沒有相應 'wait()' 的 'notify()'
notify.without.corresponding.wait.problem.descriptor=在沒有相應 <code>wait()</code> 的情況下調用 <code>#ref()</code> #loc
integer.multiplication.implicit.cast.to.long.display.name=整數乘法或移位隱式轉換為 'long'
integer.multiplication.implicit.cast.to.long.problem.descriptor=#ref: 整數乘法隱式轉換為 long #loc
integer.multiplication.implicit.cast.to.long.quickfix=轉換為 long
integer.shift.implicit.cast.to.long.problem.descriptor=#ref: 整數移位隱式轉換為 long #loc
integer.multiplication.implicit.cast.to.long.option=<html>忽略靜態證明不可能溢出的表達式</html>
wait.or.await.without.timeout.display.name=無超時的 'wait()' 或 'await()'
wait.or.await.without.timeout.problem.descriptor=無超時的 <code>#ref</code> #loc
method.return.always.constant.display.name=方法返回類特定的常數
method.return.always.constant.problem.descriptor=方法 <code>#ref()</code> 及其所有派生方法始終返回常數
class.with.too.many.dependencies.display.name=依賴過多的類
class.with.too.many.dependencies.problem.descriptor=類 ''{0}'' 的依賴過多 ({1} > {2})
class.with.too.many.transitive.dependencies.display.name=可傳遞依賴項過多的類
class.with.too.many.transitive.dependencies.problem.descriptor=類 ''{0}'' 的可傳遞依賴項過多({1} > {2})
class.with.too.many.dependents.display.name=依賴項過多的類
class.with.too.many.dependents.problem.descriptor=類 ''{0}'' 的依賴項過多 ({1} > {2})
class.with.too.many.transitive.dependents.display.name=傳遞依賴項過多的類
class.with.too.many.transitive.dependents.problem.descriptor=類 ''{0}'' 的可傳遞依賴項過多({1} > {2})
class.with.too.many.dependencies.max.option=最大依賴項數
class.with.too.many.dependents.max.option=最大依賴項數
class.with.too.many.transitive.dependencies.max.option=最大可傳遞依賴項數
class.with.too.many.transitive.dependents.max.option=最大傳遞依賴項數
cyclic.class.dependency.display.name=迴圈類依賴
cyclic.class.dependency.problem.descriptor=類 ''{0}'' 迴圈依賴於其他 {1} 個類
cyclic.class.dependency.1.problem.descriptor=類 ''{0}'' 迴圈依賴於類 ''{1}''
cyclic.class.dependency.2.problem.descriptor=類 ''{0}'' 迴圈依賴於類 ''{1}'' 和 ''{2}''
cyclic.package.dependency.display.name=迴圈軟體套件依賴關係
cyclic.package.dependency.problem.descriptor=軟體套件 ''{0}'' 迴圈依賴於其他 {1} 個軟體套件
cyclic.package.dependency.1.problem.descriptor=軟體套件 ''{0}'' 迴圈依賴於軟體套件 ''{1}''
cyclic.package.dependency.2.problem.descriptor=軟體套件 ''{0}'' 迴圈依賴於軟體套件 ''{1}'' 和 ''{2}''
class.unconnected.to.package.display.name=獨立於其軟體套件的類
class.unconnected.to.package.problem.descriptor=類 <code>#ref</code> 在其軟體套件中沒有依賴或依賴項
exception.package.display.name=異常軟體套件
exception.package.problem.descriptor=軟體套件 ''{0}'' 僅包含異常類
package.with.too.many.classes.display.name=類過多的軟體套件
package.with.too.many.classes.problem.descriptor=軟體套件 ''{0}'' 包含過多的類 ({1} > {2})
package.with.too.many.classes.max.option=最大類數:
package.with.too.few.classes.display.name=軟體套件具有過少類
package.with.too.few.classes.problem.descriptor=軟體套件 ''{0}'' 包含過少的類 ({1} < {2})
package.with.too.few.classes.min.option=最小類數:
suspicious.package.private.access.display.name=可疑的 package-private 存取權限
groups.of.modules.loaded.together.label=一起載入的模組組:
groups.of.modules.loaded.together.description=每行指定以逗號分隔的模組名稱列表，已知這些模組名稱是由同一 ClassLoader 載入的，因此，不應報告對此類模組之間的 package-private 成員的存取。
module.with.too.many.classes.display.name=類過多的模組
module.with.too.many.classes.problem.descriptor=模組 ''{0}'' 包含過多的類 ({1} > {2})
module.with.too.many.classes.max.option=最大類數:
module.with.too.few.classes.display.name=類過少的模組
module.with.too.few.classes.problem.descriptor=模組 ''{0}'' 包含過少的類 ({1} < {2})
module.with.too.few.classes.min.option=最小類數:
package.in.multiple.modules.display.name=具有多個模組中的類的軟體套件
disjoint.package.display.name=具有不相交依賴關係圖的軟體套件
disjoint.package.problem.descriptor=軟體套件 {0} 可以分解為 {1} 個獨立軟體套件
package.naming.convention.display.name=軟體套件命名慣例
package.naming.convention.problem.descriptor.short=軟體套件名稱 <code>{0}</code> 過短
package.naming.convention.problem.descriptor.long=軟體套件名稱 <code>{0}</code> 過長
package.naming.convention.problem.descriptor.regex.mismatch=軟體套件名稱 <code>{0}</code> 與正則表達式 ''{1}'' 不符合
before.or.after.is.public.void.no.arg.display.name='@Before' 或 '@After' 方法的格式錯誤
before.or.after.is.public.void.no.arg.problem.descriptor=<code>#ref()</code> 的 @Before 或 @After 方法的簽名不正確 #loc
before.class.or.after.class.is.public.static.void.no.arg.display.name='@BeforeClass'/'@BeforeAll' 或 '@AfterClass'/'@AfterAll' 方法的格式錯誤
before.class.or.after.class.is.public.static.void.no.arg.problem.descriptor=<code>#ref()</code> 的 @{0} 方法的簽名不正確 #loc
design.for.extension.display.name=為擴展設計
design.for.extension.problem.descriptor=方法 <code>#ref()</code> 可能被覆寫，其功能會被忽略 #loc
bad.oddness.display.name=可疑的奇數檢查
bad.oddness.problem.descriptor=對負值進行奇數檢查將會失敗 #loc
comparator.not.serializable.display.name='Comparator' 類未被宣告為 'Serializable'
comparator.not.serializable.problem.descriptor=比較器類 <code>#ref</code> 未被宣告為可序列化 #loc
non.serializable.field.in.serializable.class.display.name='Serializable' 類中有不可序列化的欄位
non.serializable.field.in.serializable.class.problem.descriptor=可序列化類中不可序列化的欄位 '#ref' #loc
non.serializable.object.passed.to.object.stream.display.name=不可序列化的物件被傳遞給了 'ObjectOutputStream'
non.serializable.object.passed.to.object.stream.problem.descriptor=傳遞給 ObjectOutputStream 的不可序列化物件 #loc
non.serializable.object.bound.to.http.session.display.name=不可序列化的物件被綁定到了 'HttpSession'
non.serializable.object.bound.to.http.session.problem.descriptor=傳遞給 HttpSession 的不可序列化物件 #loc
reflection.for.unavailable.annotation.display.name=對僅源註解的反射存取
reflection.for.unavailable.annotation.problem.descriptor=註解 '#ref' 不保留用於反射存取 #loc
access.to.static.field.locked.on.instance.display.name=存取實例資料上鎖定的 'static' 欄位
access.to.static.field.locked.on.instance.problem.descriptor=存取實例資料上鎖定的 static 欄位 <code>#ref</code> #loc
access.to.static.field.locked.on.instance.fix.name=忽略類型 ''{0}'' 的 static 欄位
make.method.ctr.quickfix=使方法成為構造函數
replace.all.dot.display.name=可疑的正則表達式實參
replace.all.dot.problem.descriptor=''{0}()'' 調用中存在可疑的正則表達式 #ref #loc
replace.all.dot.quickfix=轉義正則表達式元字符
class.extends.utility.class.display.name=類擴展實用程序類
class.extends.utility.class.problem.descriptor=類 <code>#ref</code> 擴展實用程序類 ''{0}'' #loc
class.extends.utility.class.ignore.utility.class.option=如果覆寫類為實用程序類，則忽略
public.constructor.in.non.public.class.quickfix=將構造函數設為 private
assignment.to.method.parameter.ignore.transformation.option=<html>如果賦值是原始參數的轉換，則忽略</html>
type.parameter.extends.final.class.display.name=類型參數擴展 'final' 類
type.parameter.extends.final.class.type.parameter.problem.descriptor=類型參數 <code>#ref</code> 擴展 ''final'' 類{0} #loc
type.parameter.extends.enum.type.parameter.problem.descriptor=類型參數 <code>#ref</code> 隱式擴展 final 枚舉 ''{0}'' #loc
type.parameter.extends.final.class.wildcard.problem.descriptor=萬用字元類型實參 <code>#ref</code> 擴展了 ''final'' 類 ''{0}'' #loc
type.parameter.extends.enum.wildcard.problem.descriptor=萬用字元類型實參 <code>#ref</code> 隱式擴展了 final 枚舉 ''{0}'' #loc
type.parameter.extends.final.class.quickfix=將類型參數取代為實際類
double.negation.display.name=雙重否定
double.negation.problem.descriptor=<code>#ref</code> 中的雙重否定 #loc
double.negation.quickfix=移除雙重否定
exception.from.catch.which.doesntwrap.ignore.option=如果使用異常方法調用的結果，則忽略
exception.from.catch.which.doesntwrap.ignore.cant.wrap.option=如果拋出的異常無法包裝異常，則忽略
comparable.implemented.but.equals.not.overridden.display.name=已實作 'Comparable'，但 'equals()' 未被覆寫
comparable.implemented.but.equals.not.overridden.problem.descriptor=類 <code>#ref</code> 實作 'java.lang.Comparable'，但未覆寫 'equals()' #loc
comparable.implemented.but.equals.not.overridden.fix.add.note.name=添加 'ordering inconsistent with equals' JavaDoc 記錄
comparable.implemented.but.equals.not.overridden.fix.generate.equals.name=生成 'equals()' 方法
unqualified.field.access.display.name=未使用 'this' 限定的實例欄位存取
unqualified.field.access.problem.descriptor=未使用 'this' 限定的實例欄位存取 <code>#ref</code> #loc
unqualified.method.access.display.name=未使用 'this' 限定的實例方法調用
unqualified.method.access.problem.descriptor=未使用 'this' 限定實例方法調用 <code>#ref()</code> #loc
add.this.qualifier.quickfix=添加 'this' 限定符
while.loop.spins.on.field.ignore.non.empty.loops.option=僅當迴圈為空時才發出警告
method.may.be.synchronized.problem.descriptor=帶 synchronized 塊的方法 <code>#ref()</code> 可以是 synchronized 方法 #loc
method.may.be.synchronized.display.name=只有一個 'synchronized' 塊的方法可取代為 'synchronized' 方法
method.may.be.synchronized.quickfix=將方法設為 synchronized 並移除 synchronized 塊
fallthru.in.switch.statement.quickfix=添加 ''{0}''
law.of.demeter.display.name=方法調用違反迪米特法則
law.of.demeter.problem.descriptor=<code>#ref()</code> 調用違反迪米特法則 #loc
law.of.demeter.ignore.library.calls.option=忽略庫方法上的調用
assertequals.between.inconvertible.types.display.name='assertEquals()' 位於不可轉換類型的物件之間
assertequals.between.inconvertible.types.problem.descriptor=<code>#ref()</code> 位於 ''{0}'' 和 ''{1}'' 不可轉換類型的物件之間 #loc
assertnotequals.between.inconvertible.types.problem.descriptor=可能的冗餘斷言: 比較不相容的類型 ''{0}'' 和 ''{1}''
assertnotsame.between.inconvertible.types.problem.descriptor=冗餘斷言: 比較不相容的類型 ''{0}'' 和 ''{1}''
masked.assertion.display.name=斷言通過 'catch' 屏蔽
masked.assertion.problem.description=''{0}'' 不能失敗，因為它通過 ''catch'' 屏蔽
enumeration.can.be.iteration.display.name=枚舉可以是迭代
enumeration.can.be.iteration.problem.descriptor=<code>#ref()</code> 可以取代為 ''{0}'' 結構 #loc
enumeration.can.be.iteration.quickfix=取代為 'Iterator' 結構
equals.hashcode.called.on.url.display.name=在 'URL' 物件上調用了 'equals()' 或 'hashCode()'
equals.hashcode.called.on.url.problem.descriptor=在 URL 物件上調用 <code>#ref()</code> #loc
collection.contains.url.problem.decriptor={0} <code>#ref</code> 可能包含 URL 物件 #loc
collection.contains.url.display.name='Map' 或 'Set' 可能包含 'URL' 物件
implicit.array.to.string.problem.descriptor=隱式調用陣列 <code>#ref</code> 上的 'toString()' #loc
explicit.array.to.string.problem.descriptor=調用陣列上的 '#ref()' #loc
implicit.array.to.string.method.call.problem.descriptor=隱式調用調用 <code>#ref</code> 返回的陣列上的 'toString()' #loc
implicit.array.to.string.display.name=調用陣列上的 'toString()'
implicit.array.to.string.quickfix=使用 ''{0}'' 表達式包裝
suspicious.indent.after.control.statement.problem.descriptor=''{0}'' 語句後存在可疑縮排 #loc
suspicious.indent.after.control.statement.display.name=沒有大括號的控制語句後存在可疑縮排
unpredictable.big.decimal.constructor.call.display.name=不可預知的 'BigDecimal' 構造函數調用
unpredictable.big.decimal.constructor.call.problem.descriptor=不可預知的 <code>new #ref()</code> 調用 #loc
unpredictable.big.decimal.constructor.call.ignore.references.option=忽略具有變量或方法調用實參的構造函數調用
unpredictable.big.decimal.constructor.call.ignore.complex.literals.option=忽略具有多個文字的構造函數調用 (例如 0.1 + 0.2)
unnecessary.unary.minus.display.name=不必要的一元負號
unnecessary.unary.minus.problem.descriptor=不必要的一元 <code>#ref</code> 運算符 #loc
unnecessary.unary.minus.quickfix=移除一元負號並反轉父運算符號
unnecessary.unary.minus.remove.quickfix=移除雙一元減號
make.field.final.quickfix=將 ''{0}'' 設為 ''final''
increment.decrement.used.as.expression.quickfix=提取 ''{0}'' 以分離語句
ignore.classes.in.hierarchy.column.name=忽略以下物件的子類:
overly.strong.type.cast.ignore.in.matching.instanceof.option=忽略具有符合 instanceof 表達式的轉換
access.to.non.thread.safe.static.field.from.instance.display.name=非執行緒安全的 'static' 欄位存取
access.to.non.thread.safe.static.field.from.instance.field.problem.descriptor=存取類型為 ''{0}'' 的非執行緒安全 static 欄位 <code>#ref</code> #loc
access.to.non.thread.safe.static.field.from.instance.option.title=非執行緒安全類:
access.to.non.thread.safe.static.field.from.instance.class.chooser.title=選擇非執行緒安全類
transient.field.not.initialized.display.name=transient 欄位在反序列化時未初始化
transient.field.not.initialized.problem.descriptor=transient 欄位 <code>#ref</code> 在反序列化時未初始化 #loc
call.to.string.concat.can.be.replaced.by.operator.display.name=對 'String.concat()' 的調用可以取代為 '+'
call.to.string.concat.can.be.replaced.by.operator.problem.descriptor=對 <code>#ref()</code> 的調用可以取代為 '+' 表達式 #loc
call.to.string.concat.can.be.replaced.by.operator.quickfix=用 '+' 取代 'concat()'
new.string.buffer.with.char.argument.display.name=StringBuilder 構造函數調用具有 'char' 實參
new.string.buffer.with.char.argument.problem.descriptor=<code>new #ref()</code> 具有 'char' 類型的實參 #loc
new.string.buffer.with.char.argument.quickfix=將字符實參取代為字串文字
suspicious.comparator.compare.display.name=可疑的 'Comparator.compare()' 實作
suspicious.comparator.compare.descriptor.parameter.not.used=未使用 'compare()' 參數 <code>#ref</code> #loc
suspicious.comparator.compare.descriptor.non.reflexive=對於相等的元素，比較器不返回 0
to.array.call.style.display.name='Collection.toArray()' 調用樣式
to.array.call.style.problem.descriptor.zero=<code>#ref()</code> 調用具有空陣列實參 ''{0}'' #loc
to.array.call.style.problem.descriptor.presized=<code>#ref()</code> 調用具有預設大小的陣列實參 ''{0}'' #loc
to.array.call.style.quickfix.family.name=修復傳遞到 'toArray()' 調用的陣列的大小
to.array.call.style.quickfix.make.presized=將實參取代為預設大小的陣列
to.array.call.style.quickfix.make.zero=將實參取代為空陣列
throwable.instance.never.thrown.runtime.exception.problem.descriptor=執行時異常實例 <code>#ref</code> 未拋出 #loc
throwable.instance.never.thrown.checked.exception.problem.descriptor=已檢查的異常實例 <code>#ref</code> 未拋出 #loc
throwable.instance.never.thrown.error.problem.descriptor=錯誤實例 <code>#ref</code> 未拋出 #loc
throwable.instance.never.thrown.problem.descriptor=Throwable 實例 <code>#ref</code> 未拋出 #loc
ignore.guard.clauses.option=忽略臨界子句(&G)
ignore.for.equals.methods.option=對 'equals()' 方法忽略(&E)
caught.exception.immediately.rethrown.display.name=捕獲的異常被立即重新拋出
caught.exception.immediately.rethrown.problem.descriptor=捕獲的異常 <code>#ref</code> 被立即重新拋出 #loc
delete.catch.section.quickfix=刪除 'catch' 部分
loop.with.implicit.termination.condition.display.name=具有隱式終止條件的迴圈
loop.with.implicit.termination.condition.dowhile.problem.descriptor=具有隱式終止條件的 <code>#ref-while</code> 迴圈 #loc
loop.with.implicit.termination.condition.problem.descriptor=具有隱式終止條件的 <code>#ref</code> 迴圈 #loc
loop.with.implicit.termination.condition.quickfix=使條件顯式
rename.catch.parameter.to.ignored=將 ''catch'' 參數重命名為 ''{0}''
inspection.empty.catch.block.generate.body=從模板生成 'catch' 正文
unnecessary.super.qualifier.display.name=不必要的 'super' 限定符
unnecessary.super.qualifier.problem.descriptor=限定符 <code>#ref</code> 在此上下文中不必要 #loc
unnecessary.super.qualifier.quickfix=移除不必要的 'super' 限定符
collections.field.access.replaceable.by.method.call.display.name=對空集合欄位的引用可以取代為方法調用
collections.field.access.replaceable.by.method.call.problem.descriptor=<code>#ref</code> 可取代為 ''Collections.{0}'' #loc
synchronization.on.local.variable.or.method.parameter.display.name=在局部變數或方法參數上同步
synchronization.on.local.variable.problem.descriptor=在局部變數 <code>#ref</code> 上同步 #loc
synchronization.on.method.parameter.problem.descriptor=在方法參數 <code>#ref</code> 上同步 #loc
too.broad.catch.quickfix=向 ''{0}'' 添加 ''catch'' 子句
replace.with.catch.clause.for.runtime.exception.quickfix=針對 'RuntimeException' 取代為 'catch' 子句
too.broad.catch.option=僅對 RuntimeException、異常、錯誤或 Throwable 發出警告(&O)
unnecessary.conversion.to.string.display.name=到 'String' 的不必要轉換
unnecessary.tostring.call.display.name=對 'toString()' 的調用不必要
unnecessary.tostring.call.problem.descriptor=不必要的 <code>#ref()</code> 調用 #loc
throwable.not.thrown.display.name='Throwable' 未拋出
throwable.result.of.method.call.ignored.problem.descriptor=<code>#ref()</code> 的結果未拋出 #loc
char.used.in.arithmetic.context.display.name=在算術上下文中使用 'char' 表達式
char.used.in.arithmetic.context.problem.descriptor=算術上下文中使用了 'char' #loc
char.used.in.arithmetic.context.quickfix=轉換為字串文字
char.used.in.arithmetic.context.cast.quickfix=插入到 {0} 的轉換
unnecessary.constant.array.creation.expression.display.name=常數陣列創建中的冗餘 'new' 表達式
unnecessary.constant.array.creation.expression.problem.descriptor=可從新陣列表達式中移除 <code>#ref</code> #loc
unnecessary.constant.array.creation.expression.family.quickfix=從新陣列表達式中移除類型規範
ambiguous.method.call.display.name=對繼承方法的調用類似於對本地方法的調用
ambiguous.method.call.problem.descriptor=對來自超類 ''{0}'' 的方法 <code>#ref()</code> 的調用類似於對來自類 ''{1}'' 的方法的調用 #loc
ambiguous.method.call.quickfix=向方法調用中添加 'super' 限定符
change.modifier.quickfix=設為 ''{0}''
the.whole.project=整個專案
this.class=此類
assertequals.may.be.assertsame.display.name='assertEquals()' 可能是 'assertSame()'
assertequals.may.be.assertsame.problem.descriptor=<code>#ref()</code> 可能是 'assertSame()' #loc
logger.initialized.with.foreign.class.problem.descriptor=使用外類 <code>#ref</code> 初始化記錄器 #loc
logger.initialized.with.foreign.class.display.name=使用外類初始化記錄器
logger.factory.method.name=記錄器工廠方法名稱
logger.factory.class.name=記錄器工廠類名
make.static.final.quickfix=將 ''{0}'' 設為 static final
logging.condition.disagrees.with.log.statement.display.name=日誌條件與日誌記錄調用不符合
logging.condition.disagrees.with.log.statement.problem.descriptor=日誌條件 <code>#ref()</code> 與 ''{0}()'' 日誌調用不符合 #loc
log.statement.guarded.by.log.condition.display.name=日誌調用不受日誌條件保護
log.statement.guarded.by.log.condition.problem.descriptor=<code>#ref()</code> 日誌調用不受日誌條件保護 #loc
log.statement.guarded.by.log.condition.quickfix=用日誌條件環繞
log.statement.guarded.by.log.condition.flag.all.unguarded.option=標記所有不受保護的日誌調用
key.set.iteration.may.use.entry.set.display.name=可以優化對 'keySet()' 的迭代
key.set.iteration.may.use.entry.set.problem.descriptor=<code>#ref</code> 上的迭代可以取代為 ''{0}'' 迭代 #loc
key.set.iteration.may.use.entry.set.quickfix=優化 Map 迭代
string.replaceable.by.string.buffer.in.loop.option=僅在迴圈中追加時發出警告
declare.collection.as.interface.quickfix=削弱為 ''{0}''
non.exception.name.ends.with.exception.quickfix=使 ''{0}'' 擴展 ''java.lang.Exception''
constant.value.variable.use.display.name=使用已知值為常數的變數
constant.value.variable.use.problem.descriptor=<code>#ref</code> 的值已知為常數 #loc
unnecessary.parentheses.option=忽略澄清圓括號
unnecessary.parentheses.conditional.option=忽略條件表達式條件周圍的圓括號
field.may.be.final.display.name=欄位可能為 'final'
field.may.be.final.problem.descriptor=欄位 <code>#ref</code> 可能為 'final' #loc
cast.that.loses.precision.option=忽略從 int 到 char 的轉換
ignore.overflowing.byte.casts.option=忽略從 int 128-255 到字節的轉換
variable.not.used.inside.if.display.name='if' 內未使用檢查為 'null' 的引用
variable.not.used.inside.if.problem.descriptor='if' 內未使用檢查為 'null' 的 <code>#ref</code> #loc
variable.not.used.inside.conditional.problem.descriptor=條件內未使用檢查為 'null' 的 <code>#ref</code> #loc
boolean.expression.may.be.conditional.display.name=布爾表達式可以取代為條件表達式
if.may.be.conditional.problem.descriptor=<code>#ref</code> 可以取代為條件表達式 #loc
if.may.be.conditional.quickfix=取代為條件表達式
redundant.string.format.call.display.name=冗餘調用 'String.format()'
redundant.call.problem.descriptor=冗餘調用 <code>#ref()</code> #loc
redundant.string.format.call.quickfix=移除對 'String.format()' 的冗餘調用
redundant.string.formatted.call.quickfix=移除對 'String.formatted()' 的冗餘調用
junit4.test.method.in.class.extending.junit3.testcase.display.name=擴展 JUnit 3 TestCase 中的 JUnit 4 測試方法
convert.junit3.test.case.error.string=<code>#ref</code> 可以轉換為 JUnit4 測試用例
convert.junit3.test.case.family.name=轉換為 JUnit 4 測試用例
convert.junit3.test.case.display.name=JUnit 3 測試可以是 JUnit 4
junit4.test.method.in.class.extending.junit3.testcase.problem.descriptor=方法 <code>#ref()</code> 在擴展 JUnit 3 TestCase 的類內使用 '@Test' 註解 #loc
ignore.test.method.in.class.extending.junit3.testcase.problem.descriptor=使用 '@Ignore' 註解的 JUnit 3 測試方法 <code>#ref()</code> 不會被忽略 #loc
ignore.test.method.in.class.extending.junit3.testcase.quickfix=移除 ''@Ignore'' 並將方法重命名為 ''{0}''
convert.junit3.test.class.quickfix=將 JUnit 3 類 ''{0}'' 轉換為 JUnit 4
remove.junit4.test.annotation.quickfix=移除 '@Test' 註解
remove.junit4.test.annotation.and.rename.quickfix=移除 ''@Test'' 註解並重命名為 ''{0}''
equals.called.on.enum.constant.display.name=對枚舉值調用了 'equals()'
equals.called.on.enum.constant.problem.descriptor=對枚舉值調用了 <code>#ref()</code> #loc
int.literal.may.be.long.literal.display.name=轉換為 'long' 可以是 'long' 文字
int.literal.may.be.long.literal.problem.descriptor=<code>#ref</code> 可以取代為 ''{0}'' #loc
constant.assert.condition.display.name='assert' 語句中的常數條件
constant.assert.condition.problem.descriptor=斷言條件 <code>#ref</code> 是常數 #loc
assert.with.side.effects.display.name=具有副作用的 'assert' 語句
assert.with.side.effects.problem.descriptor=<code>#ref</code> 具有副作用: {0} #loc
method.count.ignore.getters.setters.option=忽略簡單的 getter 和 setter 方法(&I)
class.new.instance.display.name=對 'Class.newInstance()' 的調用不安全
class.new.instance.problem.descriptor=對 <code>#ref()</code> 的調用可能會拋出未宣告的已檢查的異常 #loc
dynamic.regex.replaceable.by.compiled.pattern.display.name=動態正則表達式可以取代為已編譯的 'Pattern'
dynamic.regex.replaceable.by.compiled.pattern.problem.descriptor=<code>#ref()</code> 可以取代為已編譯的 'java.util.regex.Pattern' 結構 #loc
dynamic.regex.replaceable.by.compiled.pattern.quickfix=取代為對已編譯 'Pattern' 常數的方法的調用
ignore.serializable.option=忽略 'java.io.Serializable'
ignore.cloneable.option=忽略 'java.lang.Cloneable'
listener.may.use.adapter.display.name=類可以會擴展適配器而不是實作偵聽器
listener.may.use.adapter.problem.descriptor=類 ''{0}'' 可以擴展 ''{1}'' 而不是實作 <code>#ref</code> #loc
listener.may.use.adapter.emtpy.methods.option=僅在找到空實作方法時發出警告(&O)
unnecessary.inherit.doc.display.name=不必要的 '{@inheritDoc}' Javadoc 註釋
unnecessary.inherit.doc.problem.descriptor=僅包含 <code>#ref</code> 的 Javadoc 註釋不必要 #loc
unnecessary.inherit.doc.field.invalid.problem.descriptor=<code>#ref</code> 在欄位上無效 #loc
unnecessary.inherit.doc.constructor.invalid.problem.descriptor=<code>#ref</code> 在構造函數上無效 #loc
unnecessary.inherit.doc.class.invalid.problem.descriptor=<code>#ref</code> 在類上無效 #loc
unnecessary.inherit.doc.module.invalid.problem.descriptor=<code>#ref</code> 在模組宣告上無效 #loc
unnecessary.inherit.doc.constructor.no.super.problem.descriptor=找不到繼承 Javadoc 的 super 方法 #loc
unnecessary.inherit.doc.quickfix=移除不必要的 {@inheritDoc}
multiple.exceptions.declared.on.test.method.display.name=在測試方法上宣告的多個異常
multiple.exceptions.declared.on.test.method.problem.descriptor=<code>#ref</code> 可以取代為 'throws Exception' #loc
unnecessary.javadoc.link.display.name=不必要的 Javadoc 鏈接
unnecessary.javadoc.link.super.method.problem.descriptor=指向 super 方法的 <code>#ref</code> 不必要 #loc
unnecessary.javadoc.link.this.method.problem.descriptor=指向此方法的 <code>#ref</code> 不必要 #loc
unnecessary.javadoc.link.this.class.problem.descriptor=指向包含類的 <code>#ref</code> 不必要 #loc
unnecessary.javadoc.link.quickfix=移除不必要的 ''{0}''
thread.local.not.static.final.display.name='ThreadLocal' 欄位未被宣告為 'static final'
thread.local.not.static.final.problem.descriptor=ThreadLocal <code>#ref</code> 未被宣告為 'static final' #loc
remove.try.finally.block.quickfix=移除 'try-finally' 塊
remove.finally.block.quickfix=移除 'finally' 塊
remove.leading.zero.to.make.decimal.quickfix=移除前導零以變為十進制
remove.leading.zeroes.to.make.decimals.quickfix=移除前導零以變為十進制
convert.octal.literal.to.decimal.literal.quickfix=將八進制文字轉換為十進制文字
convert.octal.literals.to.decimal.literals.quickfix=將八進制文字轉換為十進制文字
ignore.single.field.static.imports.option=忽略單欄位靜態匯入(&F)
ignore.single.method.static.imports.option=忽略單方法靜態匯入(&M)
ignore.methods.with.boolean.return.type.option=忽略具有 'java.lang.Boolean' 返回類型的方法(&B)
ignore.boolean.methods.in.an.interface.option=忽略 @&interface 中的布爾方法
ignore.methods.overriding.super.method=忽略覆寫/實作 super 方法的方法(O&)
ignored.io.resource.types=已忽略的 I/O 資源類型
ignored.io.resource.types.label=已忽略的 I/O 資源類型:
choose.io.resource.type.to.ignore=選擇要忽略的 I/O 資源類型
ignore.accesses.from.the.same.class=忽略來自同一類的存取
ignore.accesses.from.equals.method=忽略來自 'equals()' 方法的存取
ignore.branches.of.switch.statements=忽略 'switch' 語句的分支
ignore.equals.hashcode.and.tostring=忽略 'equals()'、'hashCode()' 和 'toString()' 方法
ignore.methods.in.anonymous.classes=忽略匿名類中的方法
class.name=類名
method.name.regex=方法名稱正則表達式
column.assertion.class.name=斷言類名
choose.class=選擇類
query.column.name=查詢名稱開頭
query.label=查詢名稱開頭:
update.column.name=更新名稱開頭
update.label=更新名稱開頭:
assert.keyword.is.considered.an.assertion='assert' 關鍵字被視為斷言
expected.exception.never.thrown.display.name=從未在測試方法正文中拋出預期異常
expected.exception.never.thrown.problem.descriptor=從未在 ''{0}()'' 的正文中拋出預期 <code>#ref</code> #loc
choose.logger.class=選擇記錄器類
logger.class.name=記錄器類名:
ignore.exceptions.declared.on.library.override.option=忽略在覆寫庫方法的方法上宣告的異常(&L)
allow.resource.to.be.opened.inside.a.try.block=允許在 'try' 塊內打開資源
any.method.may.close.resource.argument=任何方法都可能關閉作為實參傳遞的資源
ignore.constructor.method.references=忽略產生 AutoCloseable 的構造函數方法引用
ignore.getters.returning.resource=忽略返回源的 getter
log.method.name=記錄方法名稱
log.condition.text=日誌條件文本
ignore.if.annotated.by=有註解時忽略:
ignore.parameter.if.annotated.by=有註解時忽略參數:
ignore.classes.annotated.by=由以下物件註解時忽略類:
ignored.class.hierarchies.border.title=忽略以下物件的子類:
choose.class.hierarchy.to.ignore.title=選擇要忽略的類層次結構
unqualified.inner.class.access.display.name=非限定內部類存取
unqualified.inner.class.access.problem.descriptor=<code>#ref</code> 未使用外部類限定 #loc
unqualified.inner.class.access.quickfix=使用外部類限定
unnecessarily.qualified.inner.class.access.problem.descriptor=使用 <code>#ref</code> 限定 ''{0}'' 不必要 #loc
unnecessarily.qualified.inner.class.access.display.name=不必要的限定內部類存取
unnecessarily.qualified.inner.class.access.quickfix=移除限定符
synchronization.on.static.field.display.name=在 'static' 欄位上同步
synchronization.on.static.field.problem.descriptor=在 'static' 欄位 <code>#ref</code> 上同步 #loc
assertequals.called.on.arrays.display.name=在陣列上調用了 'assertEquals()'
assertequals.called.on.arrays.problem.descriptor=在陣列上調用了 <code>#ref()</code> #loc
overly.broad.throws.clause.display.name=過寬的 'throws' 子句
overly.broad.throws.clause.problem.descriptor1=<code>throws #ref</code> 過寬，遮罩異常 ''{0}'' #loc
overly.broad.throws.clause.problem.descriptor2=<code>throws #ref</code> 過寬，遮罩異常 ''{0}'' 和 ''{1}'' #loc
overly.broad.throws.clause.quickfix1=添加特定異常
overly.broad.throws.clause.quickfix2=取代為特定異常
overly.broad.throws.clause.ignore.thrown.option=忽略隱藏其他異常但自身被拋出的異常(&H)
unnecessarily.qualified.statically.imported.element.display.name=不必要的限定靜態匯入元素
unnecessarily.qualified.statically.imported.element.problem.descriptor=靜態匯入元素 ''{0}'' 使用 <code>#ref</code> 不必要限定 #loc
unnecessarily.qualified.statically.imported.element.quickfix=移除不必要的限定符
ignore.instanceof.on.library.classes=忽略庫類上的 instanceof
for.can.be.foreach.option=報告索引的 'java.util.List' 迴圈
for.can.be.foreach.option2=不報告無類型集合上的迭代
cast.conflicts.with.instanceof.quickfix1=在轉換中將 ''{0}'' 取代為 ''{1}''
cast.conflicts.with.instanceof.quickfix2=在 instanceof 中將 ''{0}'' 取代為 ''{1}''
double.checked.locking.quickfix=將 ''{0}'' 設為 volatile
double.literal.may.be.float.literal.display.name=轉換為 'float' 可以是 'float' 文字
multiple.declaration.ignore.for.option=忽略 'for' 迴圈宣告
multiple.declaration.array.only.option=僅在單個宣告中對不同的陣列維度發出警告
simplifiable.annotation.display.name=可簡化註解
simplifiable.annotation.problem.descriptor=註解中有不必要的 <code>#ref</code> #loc
simplifiable.annotation.whitespace.problem.descriptor=註解中有不必要的空格 #loc
simplifiable.annotation.quickfix=簡化註解
overloaded.methods.with.same.number.parameters.option=<html>忽略參數類型絕對不相容的多載方法</html>
string.concatenation.in.format.call.display.name=字串串聯作為 'format()' 調用的實參
string.concatenation.in.format.call.problem.descriptor=''{0}()'' 調用包含字串串聯實參
string.concatenation.in.format.call.quickfix=將串聯取代為單獨的實參
string.concatenation.in.message.format.call.display.name=字串串聯作為 'MessageFormat.format()' 調用的實參
string.concatenation.in.message.format.call.problem.descriptor=字串串聯作為 'MessageFormat.format()' 調用的實參 #loc
boxing.boxed.value.display.name=裝箱已裝箱的值
boxing.boxed.value.problem.descriptor=裝箱已裝箱的 <code>#ref</code> #loc
boxing.boxed.value.quickfix=移除不必要的裝箱
unnecessary.javadoc.link.option=忽略 super 方法的內聯鏈接
constant.junit.assert.argument.display.name=常數斷言實參
constant.junit.assert.argument.problem.descriptor=實參 <code>#ref</code> 是常數 #loc
test.case.with.no.test.methods.option=忽略具有帶測試方法的超類的測試用例
package.dot.html.may.be.package.info.display.name='package.html' 可以轉換為 'package-info.java'
package.dot.html.may.be.package.info.exists.problem.descriptor=<code>package.html</code> 被忽略，因為 <code>package-info.java</code> 存在
package.dot.html.may.be.package.info.problem.descriptor=<code>package.html</code> 可以轉換為 <code>package-info.java</code>
package.dot.html.may.be.package.info.delete.quickfix=刪除 'package.html'
package.dot.html.may.be.package.info.convert.quickfix=轉換為 'package-info.java'
ignore.anonymous.inner.classes=忽略匿名內部類
try.with.identical.catches.display.name='try' 語句中的相同 'catch' 分支
try.with.identical.catches.problem.descriptor=''catch'' 分支與 ''{0}'' 分支相同 #loc
if.can.be.switch.display.name='if' 可以取代為 'switch'
if.can.be.switch.problem.descriptor=<code>#ref</code> 語句可取代為 'switch' 語句 #loc
if.can.be.switch.minimum.branch.option='if' 條件分支的最小數量:
if.can.be.switch.int.option=對數字啟用 switch 建議
if.can.be.switch.enum.option=對枚舉啟用 switch 建議
if.can.be.switch.null.safe.option=僅對 null-safe 表達式啟用建議
unnecessarily.qualified.inner.class.access.option=忽略需要匯入的引用
unqualified.inner.class.access.option=忽略對本地內部類的引用
try.with.identical.catches.quickfix=摺疊 'catch' 塊
confusing.else.option=當 'if' 語句之後沒有其他語句時報告
html.tag.can.be.javadoc.tag.display.name='<code>...</code>' 可取代為 '{@code ...}'
html.tag.can.be.javadoc.tag.problem.descriptor=<code>#ref...\\\\\\\\&lt;/code\\\\\\\\&gt;</code> 可以取代為 '{@code ...}' #loc
try.finally.can.be.try.with.resources.display.name='try finally' 可取代為 'try' with resources
try.finally.can.be.try.with.resources.problem.descriptor=<code>#ref</code> 可以使用自動資源管理 #loc
try.finally.can.be.try.with.resources.quickfix=取代為 'try-with-resources'
array.comparison.display.name=使用 '==' 而不是 'Arrays.equals()' 進行陣列比較
array.comparison.problem.descriptor=使用 <code>#ref</code> 而不是 'Arrays.equals()' 來比較陣列物件 #loc
array.hash.code.display.name=在陣列上調用了 'hashCode()'
array.hash.code.problem.descriptor=陣列上調用的 <code>#ref()</code> 可能應當是 'Arrays.hashCode()' #loc
objects.hash.problem.descriptor=傳遞給 'Objects.hash()' 的陣列應包裝在 'Arrays.hashcode()' 中
wrap.with.arrays.hash.code.quickfix=使用 ''{0}'' 包裝
method.can.be.variable.arity.method.display.name=方法可以有 varargs 參數
method.can.be.variable.arity.method.problem.descriptor=<code>#ref()</code> 可以轉換為 vararg 方法 #loc
method.can.be.variable.arity.method.ignore.byte.short.option=忽略具類型為 byte[] 或 short[] 的參數
method.can.be.variable.arity.method.ignore.all.primitive.arrays.option=忽略所有原始陣列類型
method.can.be.variable.arity.method.ignore.multiple.arrays.option=忽略具有多個陣列參數的方法
method.can.be.variable.arity.method.ignore.multidimensional.arrays.option=忽略多維陣列參數
convert.to.variable.arity.method.quickfix=轉換為 vararg 方法
mismatched.string.builder.query.update.display.name='StringBuilder' 的查詢和更新不符合
mismatched.string.builder.updated.problem.descriptor=<code>{0} #ref</code> 的內容已更新，但從未被查詢 #loc
mismatched.string.builder.queried.problem.descriptor=<code>{0} #ref</code> 的內容已查詢，但從未更新 #loc
math.random.cast.to.int.display.name='Math.random()' 轉換為 'int'
math.random.cast.to.int.problem.descriptor=<code>#ref</code> 轉換為 ''{0}'' 時始終向下舍入為 ''0'' #loc
math.random.cast.to.int.quickfix=添加括號以在轉換前執行乘法
boolean.variable.always.inverted.display.name=布爾變數始終反轉
boolean.field.always.inverted.problem.descriptor=布爾欄位 <code>#ref</code> 始終反轉 #loc
boolean.variable.always.inverted.problem.descriptor=布爾變數 <code>#ref</code> 始終反轉 #loc
unnecessary.explicit.numeric.cast.display.name=不必要的顯式數字轉換
unnecessary.explicit.numeric.cast.problem.descriptor=''{0}'' 不必要轉換為 <code>#ref</code> #loc
unnecessary.explicit.numeric.cast.quickfix=移除轉換
null.thrown.display.name=已拋出 'null'
null.thrown.problem.descriptor=已引發 <code>#ref</code> #loc
unnecessary.final.on.local.variable.or.parameter.display.name=局部變數或參數上存在不必要的 'final'
unnecessary.final.on.local.variable.problem.descriptor=變數 ''{0}'' 上存在不必要的 <code>#ref</code> #loc
unnecessary.final.on.parameter.problem.descriptor=參數 ''{0}'' 上存在不必要的 <code>#ref</code> #loc
unnecessary.final.report.local.variables.option=報告局部變數
unnecessary.final.report.parameters.option=報告參數
unnecessary.final.on.parameter.only.interface.option=僅對 abstract 或接口方法發出警告
choose.exception.class=選擇異常類
choose.exception.label=被禁止的異常:
class.independent.of.module.display.name=獨立於其模組的類
class.independent.of.module.problem.descriptor=類 <code>#ref</code> 在其模組中沒有依賴或依賴項 #loc
class.only.used.in.one.module.display.name=僅在其他模組中使用的類
class.only.used.in.one.module.problem.descriptor=類 <code>#ref</code> 在其模組 ''{0}'' 中只有依賴和/或依賴性 #loc
simplifiable.equals.expression.option.non.constant=報告具有非常數非空實參的等於
simplifiable.equals.expression.display.name='equals()' 調用之前的 'null' 檢查不必要
simplifiable.equals.expression.problem.descriptor=''{0}()'' 調用之前的 ''null'' 檢查不必要 #loc
simplifiable.equals.expression.quickfix=翻轉 ''.{0}()'' 並移除不必要的 ''null'' 檢查
use.of.concrete.class.option.ignore.abstract=忽略抽象類類型
use.of.concrete.class.option.report.method.returns=報告方法返回類型
use.of.concrete.class.option.report.local.variable=報告局部變數類型
use.of.concrete.class.option.report.parameter=報告方法參數類型
use.of.concrete.class.option.report.static.fields=報告 static 欄位類型
use.of.concrete.class.option.report.instance.fields=報告實例欄位類型
use.of.concrete.class.option.report.instanceof=報告 instanceof、patterns 或 getClass() 比較中使用的類型
use.of.concrete.class.option.report.cast=報告轉換表達式中使用的類型
class.only.used.in.one.package.display.name=僅在其他軟體套件中使用的類
class.only.used.in.one.package.problem.descriptor=類 <code>#ref</code> 在其軟體套件 ''{0}'' 中只有依賴和/或依賴項 #loc
unnecessary.return.option=在具有 'else' 分支的 'if' 語句的 then 分支中忽略
usage.of.obsolete.assert.display.name=使用廢棄的 'junit.framework.Assert' 方法
use.of.obsolete.assert.problem.descriptor=對來自 ''{0}'' 的 <code>#ref()</code> 的調用應取代為對來自 ''org.junit.Assert'' 的方法的調用 #loc
use.of.obsolete.assert.quickfix=取代為 'org.junit.Assert' 方法調用
ignored.junit.test.display.name=使用 '@Ignore'/'@Disabled' 註解的 JUnit 測試
ignored.junit.test.classproblem.descriptor=使用 <code>#ref</code> 註解的測試類 ''{0}'' #loc
ignored.junit.test.method.problem.descriptor=使用 <code>#ref</code> 註解的測試方法 ''{0}()'' #loc
ignored.junit.test.ignore.reason.option=只報告沒有原因的註解
unclear.binary.expression.display.name=具有不同優先級的多個運算符
unclear.binary.expression.problem.descriptor=表達式可以使用澄清括號 #loc
unclear.binary.expression.quickfix=添加澄清括號
new.exception.without.arguments.display.name=未使用實參調用異常構造函數
new.exception.without.arguments.problem.descriptor=<code>new #ref()</code> 沒有實參 #loc
absolute.alignment.in.user.interface.display.name=AWT/Swing 程式碼中的絕對對齊
absolute.alignment.in.user.interface.problem.descriptor=使用了絕對對齊常數 <code>{0}.#ref</code> #loc
throws.runtime.exception.display.name=在 'throws' 子句中宣告的未檢查的異常
throws.runtime.exception.problem.descriptor=在 'throws' 子句中宣告的未檢查的異常 <code>#ref</code> #loc
throws.runtime.exception.quickfix=從 ''throws'' 子句中移除 ''{0}''
throws.runtime.exception.move.quickfix=將 ''{0}'' 移動到 Javadoc ''@throws'' 標記中
empty.class.ignore.parameterization.option=如果類是父類型的參數化，則將其忽略
ambiguous.field.access.display.name=對繼承欄位的存取類似於對周圍程式碼中元素的存取
ambiguous.field.access.hides.local.variable.problem.descriptor=存取超類 ''{0}'' 中的 <code>#ref</code> 欄位類似於存取局部變數 #loc
ambiguous.field.access.hides.parameter.problem.descriptor=存取超類 ''{0}'' 中的 <code>#ref</code> 欄位類似於存取參數 #loc
ambiguous.field.access.hides.field.problem.descriptor=存取超類 ''{0}'' 中的 <code>#ref</code> 欄位類似於存取周圍類中的欄位 #loc
ambiguous.field.access.quickfix=將 'super' 限定符添加到欄位存取
add.0.to.ignore.if.annotated.by.list.quickfix=將 ''{0}'' 添加到“有註解時忽略”列表中
non.final.field.in.enum.display.name='enum' 中的非 final 欄位
non.final.field.in.enum.problem.descriptor=枚舉 ''{0}'' 中存在非 final 欄位 <code>#ref</code> #loc
externalizable.without.public.no.arg.constructor.display.name=沒有 'public' 無參構造函數的 'Externalizable' 類
externalizable.without.public.no.arg.constructor.problem.descriptor=可外部化類 <code>#ref</code> 沒有 'public' 無參構造函數 #loc
make.constructor.public=將構造函數設為 'public'
string.concatenation.missing.whitespace.display.name=字串串聯中可能缺少空格
string.concatenation.missing.whitespace.problem.descriptor=字串串聯中可能缺少空格 #loc
string.concatenation.missing.whitespace.option=忽略具有變量字串的串聯
negated.equality.expression.display.name=否定相等表達式
negated.equality.expression.problem.descriptor=否定 ''{0}'' #loc
negated.equality.expression.quickfix=移除否定
negated.conditional.expression.display.name=否定條件表達式
negated.conditional.expression.problem.descriptor=否定條件表達式 #loc
negated.conditional.expression.quickfix=移除否定
suspicious.array.cast.display.name=可疑的陣列轉換
suspicious.array.cast.problem.descriptor=可疑轉換為 <code>#ref</code> #loc
public.constructor.display.name='public' 構造函數可以取代為工廠方法
public.default.constructor.problem.descriptor=類 <code>#ref</code> 具有 'public' 預設構造函數
public.constructor.problem.descriptor=public 構造函數 <code>#ref()</code> #loc
public.constructor.quickfix=將構造函數取代為工廠方法
junit3.style.test.method.in.junit4.class.display.name=JUnit 4 類中的舊樣式 JUnit 測試方法
junit3.style.test.method.in.junit4.class.problem.descriptor=JUnit 4 類中的舊樣式 JUnit 測試方法 <code>#ref()</code> #loc
none=無
private=private
package.local.private=package-private 與 private
protected.package.local.private=protected、package-private 和 private
non.final.utility.class.display.name=實用程序類不為 'final'
non.final.utility.class.problem.descriptor=實用程序類 <code>#ref</code> 不為 'final' #loc
0.will.no.longer.be.overridable.by.1={0} 將不再可被 {1} 覆寫
arrays.as.list.with.zero.or.one.argument.display.name='Arrays.asList()' 調用的實參過少
arrays.as.list.with.one.argument.problem.descriptor=僅使用一個實參調用 <code>#ref()</code> #loc
arrays.as.list.with.zero.arguments.problem.descriptor=調用 <code>#ref()</code> 以創建空列表 #loc
string.concatenation.argument.to.log.call.display.name=非常數字串串聯作為日誌調用的實參
string.concatenation.argument.to.log.call.problem.descriptor=非常數字串串聯作為 <code>#ref()</code> 日誌調用的實參 #loc
string.concatenation.argument.to.log.call.quickfix=將串聯取代為參數化的日誌訊息
placeholder.count.matches.argument.count.display.name=佔位符數量與日誌調用中的實參數量不符合
placeholder.count.matches.argument.count.more.problem.descriptor=提供的實參數量({0})多於指定的佔位符({1}) #loc
placeholder.count.matches.argument.count.fewer.problem.descriptor=提供的實參數量({0})少於指定的佔位符數({1}) #loc
assignment.to.superclass.field.display.name=構造函數將值賦給在超類中定義的欄位
assignment.to.superclass.field.problem.descriptor=賦值給在超類 ''{1}'' 中定義的欄位 ''{0}'' #loc
junit.datapoint.display.name='@DataPoint' 欄位的格式錯誤
junit.datapoint.problem.descriptor=使用 @DataPoint 註解的 {1} 應當為 {0}
inner.class.referenced.via.subclass.display.name=通過子類引用的內部類
inner.class.referenced.via.subclass.problem.descriptor=內部類 <code>#ref</code> 在類 ''{0}'' 中宣告，但通過子類 ''{1}'' 引用 #loc
inner.class.referenced.via.subclass.quickfix=使內部類存取合理化
boolean.parameter.display.name='public' 方法具有 'boolean' 參數
boolean.parameter.problem.descriptor='public' 方法 <code>#ref()</code> 具有 'boolean' 參數 #loc
boolean.parameters.problem.descriptor='public' 方法 <code>#ref()</code> 具有 'boolean' 參數 #loc
boolean.parameter.constructor.problem.descriptor='public' 構造函數 <code>#ref()</code> 具有 'boolean' 參數 #loc
boolean.parameters.constructor.problem.descriptor='public' 構造函數 <code>#ref()</code> 具有 'boolean' 參數 #loc
boolean.parameter.only.report.multiple.option=僅報告具有多個布爾參數的方法
unnecessary.unicode.escape.display.name=不必要的 Unicode 轉義序列
unnecessary.unicode.escape.problem.descriptor=Unicode 轉義序列 <code>#ref</code> 可以取代為 ''{0}'' #loc
unnecessary.unicode.escape.problem.tab.descriptor=Unicode 轉義序列 <code>#ref</code> 可以取代為制表符 #loc
unnecessary.unicode.escape.problem.newline.descriptor=Unicode 轉義序列 <code>#ref</code> 可以取代為換行字符 #loc
missing.package.info.display.name=缺少 'package-info.java'
missing.package.info.problem.descriptor=軟體套件 ''{0}'' 缺少 <code>package-info.java</code> 檔案
missing.package.html.problem.descriptor=軟體套件 ''{0}'' 缺少 <code>package.html</code> 檔案
package.info.java.without.package.display.name=不帶 'package' 語句的 'package-info.java'
package.info.without.package.problem.descriptor='package-info.java' 沒有 'package' 語句
package.info.without.package.quickfix=添加 ''package {0};''
package.info.without.package.family.quickfix=添加 package 語句
auto.closeable.resource.display.name=在沒有 'try-with-resources' 的情況下使用 AutoCloseable
auto.closeable.resource.problem.descriptor=在沒有 ''try-with-resources'' 語句的情況下使用 ''{0}'' #loc
auto.closeable.resource.quickfix=忽略此方法返回的 'AutoCloseable'
auto.closeable.resource.returned.option=忽略從所有方法調用返回的 AutoCloseable 實例
problematic.varargs.method.display.name=非 vararg 方法覆寫 vararg 方法
problematic.varargs.method.override.problem.descriptor=非 vararg 方法 <code>#ref()</code> 覆寫 vararg 方法 #loc
negatively.named.boolean.variable.problem.descriptor=布爾變數 <code>#ref</code> 已否定命名 #loc
negatively.named.boolean.variable.display.name=否定命名的布爾變數
invert.quickfix.family.name=反轉布爾
invert.method.quickfix=反轉方法
invert.quickfix=反轉 ''{0}''
throwable.printed.to.system.out.display.name='Throwable' 列印到 'System.out'
throwable.printed.to.system.out.problem.descriptor=''Throwable'' 實參 <code>#ref</code> 到 ''System.{0}.{1}()'' 調用
suppress.for.tests.scope.quickfix=對 'Tests' 範圍禁止
implicit.default.charset.usage.display.name=隱式平台預設字符集
implicit.default.charset.usage.problem.descriptor=對 <code>#ref()</code> 的調用使用平台的預設字符集
implicit.default.charset.usage.constructor.problem.descriptor=<code>new #ref()</code> 調用使用平台的預設字符集
interface.may.be.annotated.functional.display.name=接口可以註解為 '@FunctionalInterface'
interface.may.be.annotated.functional.problem.descriptor=接口 <code>#ref</code> 可以使用 @FunctionalInterface 註解
only.report.public.methods.option=僅報告 'public' 方法
lambda.parameter.hides.member.variable.display.name=lambda 參數隱藏欄位
static.initializer.references.subclass.display.name=static 初始值設定項引用子類
lambda.parameter.hides.member.variable.problem.descriptor=lambda 參數 <code>#ref</code> 隱藏類 ''{0}'' 中的欄位 #loc
lambda.parameter.hides.member.variable.ignore.invisible.option=忽略從 lambda 實際不可見的欄位
shared.thread.local.random.display.name='ThreadLocalRandom' 實例可能是共享的
shared.thread.local.random.problem.descriptor='ThreadLocalRandom' 實例可能在線程之間共享
native.method.naming.convention.element.description='原生'
use.of.obsolete.date.time.api.display.name=使用廢棄的日期時間 API
use.of.obsolete.date.time.api.problem.descriptor=使用了廢棄的日期時間類型 <code>#ref</code> #loc
warn.on.label=警告物件:
all.levels.option=所有日誌級別
warn.level.and.lower.option=警告級別和更低
info.level.and.lower.option=資訊級別和更低
debug.level.and.lower.option=調試級別和更低
trace.level.option=跟踪級別
ignored.autocloseable.types.column.label=已忽略 AutoCloseable 資源類型
ignored.autocloseable.types.label=已忽略的 AutoCloseable 資源類型:
choose.autocloseable.type.to.ignore.title=選擇要忽略的 AutoCloseable 資源類型
big.decimal.method.without.rounding.called.display.name='BigDecimal' 方法調用沒有舍入模式實參
big.decimal.method.without.rounding.called.problem.descriptor=在沒有舍入模式實參的情況下調用了 'BigDecimal.#ref()'
bigdecimal.legacy.method.display.name=調用了 'BigDecimal' 遺留方法
bigdecimal.legacy.method.problem.descriptor=對 'BigDecimal.#ref()' 的調用可以使用 'RoundingMode' 枚舉常數
bigdecimal.legacy.method.quickfix=使用 'RoundingMode' 枚舉常數
serializable.stores.non.serializable.display.name='Serializable' 物件隱式存儲非 'Serializable' 物件
serializable.lambda.stores.non.serializable.problem.descriptor=可序列化 lambda 隱式存儲類型為 ''{0}'' 的不可序列化物件
serializable.local.class.stores.non.serializable.problem.descriptor=可序列化局部類 ''{1}'' 隱式存儲類型為 ''{0}'' 的不可序列化物件
serializable.anonymous.class.stores.non.serializable.problem.descriptor=可序列化匿名類隱式存儲類型為 ''{0}'' 的不可序列化物件
assignment.to.lambda.parameter.display.name=賦值給 lambda 參數
assignment.to.lambda.parameter.problem.descriptor=賦值給 lambda 參數 <code>#ref</code> #loc
class.with.only.private.constructors.display.name=僅包含 'private' 構造函數的類應被宣告為 'final'
class.with.only.private.constructors.problem.descriptor=僅包含 'private' 構造函數的類 <code>#ref</code> 應被宣告為 'final'
property.value.set.to.itself.display.name=屬性值設定為自身
equals.with.itself.display.name=在自身上調用了 'equals()'
equals.with.itself.problem.descriptor=在自身上調用了 <code>#ref()</code>
junit4.method.naming.convention.element.description=JUnit 4+ 測試
junit3.method.naming.convention.element.description=JUnit 3 測試
introduce.holder.class.quickfix=引入 holder 類
double.brace.initialization.display.name=雙大括號初始化
double.brace.initialization.quickfix=取代為正則初始化
return.of.inner.class.display.name=返回匿名、局部或內部類的實例
return.of.anonymous.class.problem.descriptor=返回匿名類的實例 #loc
return.of.local.class.problem.descriptor=返回局部類 <code>{0}</code> 的實例 #loc
return.of.inner.class.problem.descriptor=返回非 static 內部類 <code>{0}</code> 的實例 #loc
return.of.inner.class.ignore.non.public.option=忽略非 public 方法的返回值
parameter.type.prevents.overriding.display.name=參數類型阻止覆寫
parameter.type.prevents.overriding.problem.descriptor=參數類型 <code>#ref</code> 位於 ''{0}''，而 super 方法參數類型位於 ''{1}''，可防止覆寫 #loc
parameter.type.prevents.overriding.quickfix=將參數類型更改為 ''{0}''
parameter.type.prevents.overriding.family.quickfix=更改參數類型
suspicious.getter.setter.display.name=可疑的 getter/setter
suspicious.setter.problem.descriptor=setter <code>#ref()</code> 對欄位 ''{0}'' 賦值 #loc
suspicious.getter.problem.descriptor=getter <code>#ref()</code> 返回欄位 ''{0}'' #loc
unnecessary.break.display.name=不必要的 'break' 語句
unnecessary.break.problem.descriptor=<code>#ref</code> 語句不必要 #loc
utility.class.can.be.enum.display.name=實用程序類可以是 'enum'
utility.class.code.can.be.enum.problem.descriptor=實用程序類 <code>#ref</code> 可以是 'enum' #loc
utility.class.code.can.be.enum.quickfix=轉換為 'enum'
non.public.clone.display.name='clone()' 方法不是 'public'
non.public.clone.problem.descriptor=<code>#ref()</code> 方法不是 'public' #loc
only.warn.on.public.clone.methods=僅對 'public' 克隆方法發出警告
only.warn.on.protected.clone.methods=僅對 'protected' 克隆方法發出警告
clone.returns.class.type.display.name='clone()' 應當具有等於其所包含類的返回類型
clone.returns.class.type.problem.descriptor=''clone()'' 應當具有返回類型 ''{0}'' #loc
clone.returns.class.type.quickfix=將返回類型更改為 ''{0}''
clone.returns.class.type.family.quickfix=將返回類型更改為類類型
use.of.clone.display.name=使用 'clone()' 或 'Cloneable'
use.of.clone.call.problem.descriptor=調用 <code>#ref()</code>
use.of.clone.call.method.problem.descriptor=實作 <code>#ref()</code>
use.of.clone.reference.problem.descriptor=使用 <code>#ref</code>
dangling.javadoc.display.name=懸空的 Javadoc 註釋
dangling.javadoc.problem.descriptor=懸空的 Javadoc 註釋 #loc
dangling.javadoc.convert.quickfix=取代為塊註釋
dangling.javadoc.delete.quickfix=移除懸空的註釋
equals.replaceable.by.objects.call.display.name='equals()' 表達式可取代為 'Objects.equals()' 表達式
equals.replaceable.by.objects.call.problem.descriptor=<code>#ref</code> 可取代為 'Objects.equals()' 表達式 #loc
equals.replaceable.by.objects.check.not.null.option=高亮顯示與 'a != null \\\\\\\\&\\\\\\\\& a.equals(b)' 類似的表達式
array.objects.equals.display.name=對陣列使用淺層方法或 'Objects' 方法
array.equals.problem.descriptor=或許應當使用 ''{0}'' 完成陣列比較''
array.hashcode.problem.descriptor=或許應當使用 ''{0}'' 完成陣列哈希程式碼計算
extends.throwable.display.name=類直接擴展 'Throwable'
anonymous.extends.throwable.problem.descriptor=匿名類直接擴展 'java.lang.Throwable' #loc
extends.throwable.problem.descriptor=類 <code>#ref</code> 直接擴展 'java.lang.Throwable' #loc
lambda.parameter.naming.convention.display.name=lambda 參數命名慣例
lambda.parameter.naming.convention.element.description=lambda 參數
assert.message.not.string.display.name='assert' 訊息不是字串
assert.message.of.type.boolean.problem.descriptor=類型為 ''{0}'' 的 ''assert'' 訊息 #loc
assert.message.not.string.only.warn.boolean.option=僅當 'assert' 訊息為 'boolean' 或 'java.lang.Boolean' 時發出警告
suspicious.literal.underscore.display.name=數字文字中的可疑下划線
suspicious.literal.underscore.problem.descriptor=帶下划線的數字文字中的組沒有長度 3 #loc
unary.plus.quickfix=移除一元 '+'
convert.double.unary.quickfix=取代為 ''{0}{1}''
prefix.operation.quickfix.family.name=取代為前綴運算符
super.tear.down.in.finally.display.name=未從 'finally' 塊調用 'super.tearDown()'
super.tear.down.in.finally.problem.descriptor=未從 'finally' 塊調用 <code>#ref()</code> #loc
confusing.floating.point.literal.option=忽略科學記數法中的浮點文字
class.may.be.interface.java8.option=使用 Java 8 時報告包含非 abstract 方法的類
simplifiable.boolean.expression.display.name=可簡化的布爾表達式
unnecessary.initcause.display.name=對 'Throwable.initCause()' 的調用不必要
unnecessary.initcause.problem.descriptor=不必要的 <code>Throwable.#ref()</code> 調用
unnecessary.initcause.quickfix=移除 'Throwable.initCause()' 調用
consider.static.final.fields.constant.option=考慮 'static final' 欄位常數
atomic.field.updater.not.static.final.display.name='AtomicFieldUpdater' 欄位未被宣告為 'static final'
atomic.field.updater.not.static.final.problem.descriptor={0} 欄位 <code>#ref</code> 未被宣告為 ''static final'' #loc
atomic.field.updater.issues.display.name='AtomicFieldUpdater' 宣告不一致
field.not.found.in.class.problem.descriptor=類 ''{1}'' 中未找到命名為 ''{0}'' 的欄位
field.incorrect.type.problem.descriptor=欄位 ''{0}'' 沒有類型 ''{1}''
field.missing.volatile.modifier.problem.descriptor=欄位 ''{0}'' 沒有 ''volatile'' 修飾符
field.has.static.modifier.problem.descriptor=欄位 ''{0}'' 具有 ''static'' 修飾符
private.field.not.accessible.problem.descriptor=''private'' 欄位 ''{0}'' 無法從此處存取
package.local.field.not.accessible=package-private 欄位 ''{0}'' 無法從此處存取
protected.field.not.accessible.problem.descriptor=''protected'' 欄位 ''{0}'' 無法從此處存取
interface.clashes.with.object.class.display.name=接口方法與 'Object' 中的方法衝突
interface.clashes.with.object.class.problem.descriptor=<code>#ref()</code> 與 'java.lang.Object' 中的方法衝突
optional.used.as.field.or.parameter.type.display.name=用作欄位或參數類型的 'Optional'
optional.used.as.field.type.problem.descriptor=<code>#ref</code> 用作欄位 ''{0}'' 的類型
optional.used.as.parameter.type.problem.descriptor=<code>#ref</code> 用作參數 ''{0}'' 的類型
lambda.unfriendly.method.overload.display.name=方法多載對 lambda 不友好
lambda.unfriendly.method.overload.problem.descriptor=方法 <code>#ref()</code> 的多載對 lambda 不友好
lambda.unfriendly.constructor.overload.problem.descriptor=構造函數 <code>#ref()</code> 的多載對 lambda 不友好
optional.contains.collection.display.name='Optional' 包含陣列或集合
optional.contains.collection.problem.descriptor='Optional' 包含集合 <code>#ref</code>
optional.contains.array.problem.descriptor='Optional' 包含陣列 <code>#ref</code>
synchronization.on.get.class.display.name=在 'getClass()' 上同步
synchronization.on.get.class.problem.descriptor=在 <code>#ref()</code> 上同步 #loc
object.instantiation.inside.equals.or.hashcode.display.name='equals()' 或 'hashCode()' 內部的物件實例化
object.instantiation.inside.equals.or.hashcode.problem.descriptor=''{0}()'' 內部的物件實例化 #loc
object.instantiation.inside.equals.or.hashcode.problem.descriptor2=''{0}()'' ({1}) 內部的物件實例化 #loc
lambda.body.can.be.code.block.name=lambda 體可以是程式碼塊
lambda.body.can.be.code.block.quickfix=將 lambda 體擴展為 {...}
lambda.parameter.type.can.be.specified.name=可以指定 lambda 參數類型
lambda.parameter.type.can.be.specified.descriptor=Lambda 參數類型可以擴展為{0}
lambda.parameter.type.can.be.specified.quickfix=將參數類型擴展為{0}
lambda.parameter.type.can.be.specified.family.quickfix=指定 lambda 參數類型
diamond.can.be.replaced.with.explicit.type.arguments.name=diamond 可以取代為顯式類型實參
diamond.can.be.replaced.with.explicit.type.arguments.quickfix=將 '<>' 取代為顯式類型實參
lambda.can.be.replaced.with.anonymous.name=lambda 可以取代為匿名類
lambda.can.be.replaced.with.anonymous.quickfix=將 lambda 取代為匿名類
method.ref.can.be.replaced.with.lambda.name=方法引用可以取代為 lambda
method.ref.can.be.replaced.with.lambda.quickfix=將方法引用取代為 lambda
try.statement.with.multiple.resources.name=可以拆分具有多個資源的 'try' 語句
try.statement.with.multiple.resources.quickfix=拆分具有多個資源的 'try' 語句
multi.catch.can.be.split.name=多 catch 可拆分為單獨的 catch 塊
multi.catch.can.be.split.quickfix=將多 catch 拆分為單獨的 'catch' 塊
assertion.can.be.if.name=斷言可以取代為 'if' 語句
assert.can.be.if.quickfix=將 'assert' 取代為 'if' 語句
if.can.be.assertion.name=語句可以取代為 'assert' 或 'Objects.requireNonNull'
if.can.be.assertion.replace.with.assertion.quickfix=將語句取代為 'assert' 語句
if.can.be.assertion.replace.with.objects.requirenonnull.quickfix=將語句取代為 'Objects.requireNonNull()'
single.statement.in.block.name=程式碼塊包含單條語句
single.statement.in.block.descriptor=''{0}'' 包含單條語句
single.statement.in.block.quickfix=從 ''{0}'' 語句中移除大括號
single.statement.in.block.family.quickfix=從語句中移除大括號
single.element.annotation.name=非規范化註解
single.element.annotation.quickfix=添加 'value='
single.element.annotation.family.quickfix=將註解擴展為標準形式
array.creation.without.new.keyword.name=創建不帶 'new' 表達式的陣列
array.creation.without.new.keyword.quickfix=添加 ''new {0}''
array.creation.without.new.keyword.family.quickfix=添加 'new' 表達式
malformed.set.up.tear.down.display.name='setUp()' 或 'tearDown()' 方法的格式錯誤 
malformed.set.up.tear.down.problem.descriptor='#ref()' 的簽名不正確 #loc
overly.long.lambda.display.name=過長的 lambda 表達式
overly.long.lambda.problem.descriptor=lambda 表達式過長 (# 非註釋源語句 = {0}) #loc
wait.notify.not.in.synchronized.context.display.name='wait()' 或 'notify()' 不在同步的上下文中
wait.notify.while.not.synchronized.on.problem.descriptor=''{0}'' 未同步時調用 <code>#ref</code> #loc
call.to.suspicious.string.method.display.name=調用可疑的 'String' 方法
call.to.suspicious.string.method.problem.descriptor=國際化上下文中調用的 <code>String.#ref()</code> #loc
unnecessary.string.escape.display.name=不必要的轉義字符
unnecessary.string.escape.problem.descriptor=<code>#ref</code> 進行了不必要的轉義
unnecessary.string.escape.quickfix=將不必要的轉義字符取代為未轉義字符

array.can.be.replaced.with.enum.values = 可以將陣列取代為枚舉值
array.can.be.replaced.with.enum.values.quickfix = 將陣列取代為 {0}.values()
array.can.be.replaced.with.enum.values.family.quickfix = 將陣列取代為 EnumType.values()

string.concatenation.replace.fix=取代為 StringBuilder
string.concatenation.replace.fix.name=將變數 ''{0}'' 從字串轉換為 {1}
string.concatenation.replace.fix.name.null.safe=將變數 ''{0}'' 從字串轉換為 {1} (null 安全)
string.concatenation.introduce.fix=引入 StringBuilder
string.concatenation.introduce.fix.name=引入新的 {1} 以更新變數 ''{0}''
string.concatenation.introduce.fix.name.null.safe=引入新的 {1} 以更新變數 ''{0}'' (null 安全)

ignored.class.names=忽略類(包括子類)
ignored.class.label=已忽略類(包括子類):
meta.annotation.without.runtime.retention=不含 '@Retention(RUNTIME)' 註解的測試註解
string.equals.char.sequence.display.name=使用 'CharSequence' 實參調用了 'String.equals()'
string.equals.char.sequence.problem.descriptor=使用 ''{0}'' 實參調用了 <code>String.equals()</code> #loc
object.equals.can.be.equality.display.name='equals()' 調用可以取代為 '=='
object.equals.can.be.equality.problem.descriptor=<code>#ref()</code> 可以取代為 '=='
not.object.equals.can.be.equality.problem.descriptor=<code>!#ref()</code> 可以取代為 '!='
redundant.explicit.var.type.display.name=可以省略局部變數類型
variable.type.can.be.explicit.display.name=變數類型可以是顯式的
assignment.or.return.of.field.with.mutable.type.display.name=具有可變類型的欄位的賦值或返回
assignment.of.field.with.mutable.type.problem.descriptor=賦值給參數 <code>#ref</code> 中的 {0} 欄位 ''{1}'' #loc
return.of.field.with.mutable.type.problem.descriptor=返回 {0} 欄位 <code>{1}</code> #loc
ignore.private.methods.option=忽略 private 方法中的賦值和返回值

inspection.redundant.string.operation.display.name=冗餘的 'String' 操作
inspection.redundant.string.remove.fix.name=移除冗餘的 ''{0}()'' 調用
inspection.redundant.string.fix.family.name=移除冗餘調用
inspection.redundant.string.call.message=<code>#ref()</code> 的調用冗餘 #loc
inspection.redundant.empty.string.argument.message=不必要的空字串實參
inspection.redundant.string.length.argument.message=不必要的字串長度實參
inspection.redundant.zero.argument.message=不必要的零實參
inspection.redundant.string.remove.argument.fix.name=移除實參
inspection.redundant.string.intern.on.constant.message=編譯時常量上 <code>#ref()</code> 的調用不必要 #loc
inspection.redundant.string.constructor.message=<code>#ref</code> 是冗餘的 #loc
inspection.redundant.string.replace.with.arg.fix.name=取代為實參
inspection.redundant.string.replace.with.empty.fix.name=取代為空字串
inspection.redundant.string.option.do.not.report.string.constructors=不報告字串構造函數
inspection.x.call.can.be.replaced.with.y=''{0}'' 調用可以取代為 ''{1}''

inspection.type.may.be.weakened.display.name=類型可能被削弱
inspection.type.may.be.weakened.problem.descriptor=變數 <code>#ref</code> 的類型可能被削弱為 {0} #loc
inspection.type.may.be.weakened.method.problem.descriptor=方法 <code>#ref()</code> 的返回類型可能被削弱為 {0} #loc
inspection.type.may.be.weakened.parameter.problem.descriptor=參數 <code>#ref</code> 的類型可能被削弱為 {0} #loc
inspection.type.may.be.weakened.field.problem.descriptor=欄位 <code>#ref</code> 的類型可能被削弱為 {0} #loc
inspection.type.may.be.weakened.quickfix=將類型削弱為 ''{0}''
inspection.type.may.be.weakened.ignore.option=在賦值中使用右手類型作為最弱的類型(&R)
inspection.type.may.be.weakened.collection.method.option=對方法調用實參使用參數化集合類型(&P)
inspection.type.may.be.weakened.do.not.weaken.to.object.option=不削弱為 'java.lang.Object'(&W)
inspection.type.may.be.weakened.add.stopper=作為停止類添加以減弱
inspection.type.may.be.weakened.add.stopper.single=添加 {0} 作為停止類以削弱
inspection.type.may.be.weakened.only.weaken.to.an.interface=僅削弱為接口
inspection.type.may.be.weakened.do.not.weaken.return.type=不削弱返回類型
inspection.type.may.be.weakened.add.stop.class.family=添加停止類
inspection.type.may.be.weakened.weaken.type.family=削弱類型
inspection.type.may.be.weakened.add.stop.class.selection.table=停止類
inspection.type.may.be.weakened.add.stop.class.selection.table.label=停止類:
inspection.type.may.be.weakened.add.stop.class.selection.popup=選擇停止類
inspection.type.may.be.weakened.do.not.weaken.inferred.variable.type=不建議削弱宣告為 'var' 的變數

inspection.commented.out.code.display.name=註釋掉的程式碼
inspection.commented.out.code.problem.descriptor=註釋掉的程式碼 ({0} {0, choice, 1#行|1<行})
commented.out.code.delete.quickfix=刪除註釋
commented.out.code.uncomment.quickfix=撤消程式碼註釋
inspection.commented.out.code.min.lines.options=最少程式碼行數

inspection.catch.ignores.exception.display.name=catch 塊可能會忽略異常
inspection.catch.ignores.exception.option.comments=當 'catch' 塊包含註釋時不發出警告
inspection.catch.ignores.exception.option.nonempty=當 'catch' 塊不為空時不發出警告
inspection.catch.ignores.exception.option.ignored.used=當名稱為 'ignore(d)' 的異常實際上未被忽略時不發出警告
inspection.catch.ignores.exception.used.message=已使用命名為 <code>#ref</code> 的 'catch' 參數 #loc
inspection.catch.ignores.exception.empty.message=空 <code>#ref</code> 塊 #loc
inspection.catch.ignores.exception.unused.message=未使用的 'catch' 參數 <code>#ref</code> #loc
inspection.catch.ignores.exception.vm.ignored.message=<code>#ref</code> 塊中可能會忽略 ''{0}'' 之類的意外虛擬機異常 #loc

inspection.redundant.collection.operation.display.name=冗餘的 'Collection' 操作
inspection.redundant.collection.operation.fix.family.name=簡化集合操作
inspection.redundant.collection.operation.problem.arraycopy=為複製陣列而創建的集合不必要
inspection.redundant.collection.removal.by.index.problem=按索引移除可以取代為按物件移除
inspection.redundant.collection.removal.by.index.fix=使用按物件移除
inspection.redundant.collection.unnecessary.contains.problem=不必要的 ''{0}()'' 檢查
inspection.redundant.collection.unnecessary.contains.fix=移除 ''{0}()'' 檢查

comments.as.content.option=註釋計為內容
copy.constructor.misses.field.display.name=複製缺少欄位的構造函數
copy.constructor.misses.field.problem.descriptor.1=複製未複製欄位 ''{0}'' 的構造函數
copy.constructor.misses.field.problem.descriptor.2=複製未複製欄位 ''{0}'' 和 ''{1}'' 的構造函數
copy.constructor.misses.field.problem.descriptor.3=複製未複製欄位 ''{0}''、''{1}'' 和 ''{2}'' 的構造函數
copy.constructor.misses.field.problem.descriptor.many=複製未複製 {0} 個欄位的構造函數

fix.add.argument.family.name=添加實參
fix.add.argument.name=添加 ''{0}'' 實參

inspection.constant.expression.display.name=可以計算常數表達式
inspection.constant.expression.message=常數表達式可以計算為 ''{0}''
inspection.constant.expression.fix.name=計算 ''{0}'' 的常量值
inspection.constant.expression.fix.name.with.value=將 ''{0}'' 取代為常量值 ''{1}''
inspection.constant.expression.fix.family.name=計算常量值

inspection.redundant.compare.call.display.name=冗餘的 'compare()' 方法調用
inspection.redundant.compare.call.fix.name=內聯 'compare()' 調用

inspection.simplifiable.if.statement.display.name='if' 語句可以取代為條件或布爾表達式
inspection.simplifiable.if.statement.message=If 語句可以取代為 ''{0}''
inspection.simplifiable.if.statement.option.dont.warn.on.ternary=不建議使用 '?:' 運算符
inspection.simplifiable.if.statement.fix.name=將 ''if else'' 取代為 ''{0}''
inspection.simplifiable.if.statement.fix.family.name=將 'if else' 取代為條件運算符

inspection.list.remove.in.loop.display.name=在迴圈中調用了 'List.remove()'
inspection.list.remove.in.loop.message=可以取代為 'List.subList().clear()'

implicit.default.charset.usage.fix.family.name=指定 UTF-8 字符集

inspection.redundant.class.call.display.name=冗餘的 'isInstance()' 或 'cast()' 調用
inspection.new.object.equality.display.name=使用 '==' 比較新物件
inspection.new.object.equality.message=使用 ''{0}'' 比較新物件
inspection.excessive.range.check.message=可以取代為 ''{0}''
inspection.excessive.range.check.fix.family.name=簡化過度範圍檢查
suspicious.integer.div.assignment.problem.descriptor=除法結果被截斷為整數
suspicious.integer.div.assignment.display.name=可疑的整數除法賦值
suspicious.integer.div.assignment.quickfix=轉換為 double
inspection.if.statement.missing.break.in.loop.name=在 'if' 條件下提前退出迴圈
inspection.if.statement.missing.break.in.loop.description=滿足條件後，可以終止迴圈
inspection.if.statement.missing.break.in.loop.quickfix=添加 'break'

inspection.case.mismatch.display.name='String' 操作中不符合的大小寫
inspection.case.mismatch.message.arg.is.lower=方法 ''{0}()'' 始終返回 {1}: 實參包含小寫符號，而限定符僅為大寫
inspection.case.mismatch.message.arg.is.upper=方法 ''{0}()'' 始終返回 {1}: 實參包含大寫符號，而限定符僅為小寫

inspection.suspicious.date.format.display.name=可疑的日期格式模式
inspection.suspicious.date.format.message.upper=使用了大寫 ''{0}'' ({1}) 模式: 預期可能為 ''{2}'' ({3})
inspection.suspicious.date.format.message.lower=使用了小寫 ''{0}'' ({1}) 模式: 預期可能為 ''{2}'' ({3})

fix.replace.map.with.flat.map.description='map()' 可以取代為 'flatMap()'

fix.eliminate.folded.if.present.name=移除折疊的 'ifPresent()' 調用
fix.eliminate.folded.if.present.description=可以消除折疊的 'ifPresent()' 調用

inspection.pattern.variable.can.be.used.display.name=可以使用模式變數
inspection.pattern.variable.can.be.used.message=變數 ''{0}'' 可以取代為模式變數
inspection.pattern.variable.can.be.used.fix.family.name=取代為模式變數
inspection.pattern.variable.can.be.used.fix.name=將 ''{0}'' 取代為模式變數
inspection.pattern.variable.can.be.used.existing.message=可以使用現有模式變數 ''{0}'' 代替 ''{1}''
inspection.pattern.variable.can.be.used.existing.fix.family.name=取代為現有模式變數
inspection.pattern.variable.can.be.used.existing.fix.name=將 ''{0}'' 取代為現有模式變數 ''{1}''

array.hash.code.fix.family.name=取代為隱式 'hashCode'
objects.hash.fix.family.name=使用 'Arrays.hashCode()' 包裝
unqualified.static.access.fix.family.name=限定靜態存取
replace.field.reference.fix.family.name=取代欄位引用
replace.field.reference.fix.text=將欄位引用取代為 {0}
replace.method.call.fix.family.name=取代方法調用
replace.method.call.fix.text=將方法調用取代為 {0}
delete.unnecessary.statement.fix.family.name=移除冗餘語句
increment.decrement.used.as.expression.fix.family.name=提取到分離語句中
use.of.properties.as.hashtable.fix.family.name=修復屬性存取
unnecessary.java.doc.link.fix.family.name=移除冗餘標記
swap.equals.fix.family.name=翻轉方法調用
remove.modifier.fix.family.name=移除修飾符
shift.out.of.range.fix.family.name=修復移位值
unnecessary.unicode.escape.fix.family.name=取代為字符
unnecessary.unicode.escape.fix.text=取代為換行字符
absolute.alignment.in.user.interface.fix.family.name=取代為常數
static.inheritance.fix.family.name=將繼承取代為限定引用
suspicious.to.array.call.fix.family.name=取代為正確陣列
incorrect.date.format.fix.family.name=修復不正確的日期格式
referencing.subclass.0.from.superclass.1.initializer.might.lead.to.class.loading.deadlock=從超類 {1} 初始值設定項引用子類 {0} 可能會導致類載入死鎖
collections.field.access.replaceable.by.method.call.fix.family.name=將 Collections.EMPTY_* 取代為調用
delete.catch.section.fix.family.name=刪除 catch 語句
make.field.static.final.fix.family.name=設為 static final
string.concatenation.in.format.call.fix.family.name=將串聯取代為實參
implicit.array.to.string.fix.family.name=將 Array.toString() 設為隱式
listener.may.use.adapter.fix.family.name=取代為適配器
unnecessary.temporary.object.fix.family.name=取代串聯
make.public.static.fix.family.name=設為 public/static
utility.class.with.public.constructor.fix.family.name=將構造函數設為 private
change.modifier.fix.family.name=更改修飾符
unnecessary.interface.modifiers.fix.family.name=移除不必要的修飾符
make.field.final.fix.family.name=設為 final
generate.to.string.quick.fix.family.name=生成
generate.to.string.quick.fix.text=生成 toString()
replace.instanceof.fix.family.name=取代 instanceOf 類型
replace.cast.fix.family.name=取代轉換類型
make.package.private.fix.family.name=設為 package-private
make.method.final.fix.family.name=將方法設為 'final'
replace.casted.literal.with.just.literal.fix.family.name=取代為 {0} 文字
char.used.in.arithmetic.content.cast.fix.family.name=插入轉換
ignore.parentheses.around.single.no.formal.type.lambda.parameter=忽略單個非正式類型 lambda 參數周圍的括號
double.checked.locking.fix.family.name=將欄位設為 volatile
declare.collection.as.interface.fix.family.name=削弱類型
string.equals.empty.string.fix.family.name=簡化空字串檢查
class.without.logger.annotations.tab=註解
class.without.logger.loggers.tab=記錄器
options.title.ignored.classes=已忽略的類
options.label.ignored.classes=已忽略的類:
add.catch.section.fix.family.name=添加 'catch' 子句
inspection.autocloseable.resource.ignored.methods.title=忽略從這些方法返回的 AutoCloseable 實例:
logger.initialized.with.foreign.class.fix.family.name=取代外類
extend.exception.fix.family.name=使類擴展 'Exception'
inspection.use.of.private.field.inner.classes.option=忽略來自內部類的存取
refused.bequest.fix.family.name=將調用插入 super 方法
mark.modules.as.loaded.together.fix.family.name=將模組標記為一起載入
mark.modules.as.loaded.together.fix.text=將 ''{0}'' 和 ''{1}'' 模組標記為一起載入
inspection.suspicious.package.private.access.description={0} 是 {1}，但在不同的模組 ''{2}'' 中宣告
ignore.class.fix.family.name=對這些類型忽略
create.default.branch.fix.family.name=插入 'default' 分支
unnecessary.fully.qualified.name.fix.family.name=取代完全限定名稱
return.of.collection.field.fix.family.name=使返回集合 'unmodifiable'
remove.redundant.substring.fix.family.name=移除冗餘的 'substring()' 調用
remove.redundant.string.fix.text=使用 ''{0}()'' 並移除冗餘的 ''{1}()'' 調用
use.equalsignorecase.for.case.insensitive.comparison=為不區分大小寫的比較使用 equalsIgnoreCase()
make.class.final.fix.family.name=將類設為 final
side.effects.method.ref.to.lambda.fix.family.name={0} (副作用)
encapsulate.variable.fix.family.name=封裝欄位
method.may.be.static.replaces.qualifiers.with.class.references.option=快速修復可將實例限定符取代為類引用
method.may.be.static.ignore.default.methods.option=忽略 'default' 方法
make.public.static.void.fix.family.name=修復修飾符
make.public.static.void.fix.name=將 ''{0}'' 的簽名更改為 ''{1}''
convert.empty.anonymous.to.new.fix.family.name=移除 '{}'
replace.method.ref.with.qualifier.fix.family.name=取代為限定符
replace.method.ref.with.qualifier.problem.method=方法引用可以取代為限定符
replace.method.ref.with.qualifier.problem.lambda=lambda 可以取代為調用限定符
add.throws.clause.fix.family.name=修復 'throws' 子句
prefer.empty.array.options.title=首選空陣列:
prefer.empty.array.options.mode.always=始終
prefer.empty.array.options.mode.by.level=根據語言級別
prefer.empty.array.options.mode.always.never=從不(首選預設大小的陣列)
too.broad.scope.inspection.fix.family.name=限縮範圍
replace.with.cast.fix.family.name=取代為轉換
replace.anonymous.with.lambda.body.fix.family.name=將調用取代為方法體
replace.with.method.reference.fix.family.name=將方法引用上的方法調用取代為相應的方法調用
replace.with.lambda.body.fix.family.name=將 lambda 上的方法調用取代為 lambda 體
inspection.trivial.functional.expression.usage.description=可以簡化方法調用
replace.with.var.fix.family.name=將顯式類型取代為 'var'
inspection.redundant.explicit.variable.type.description=可以省略局部變數的顯式類型
add.read.write.object.methods.fix.family.name=添加始終拋出異常的 'readObject()' 和 'writeObject()' 方法
add.read.write.object.methods.fix.text=添加始終拋出異常的 'writeObject()' 方法
add.read.write.object.methods.fix.text2=添加始終拋出異常的 'readObject()' 方法
replace.with.method.ref.fix.family.name=將 lambda 取代為方法引用
replace.with.method.ref.fix.name.may.change.semantics=將 lambda 取代為方法引用(可能更改語意)
qualify.call.fix.family.name=限定調用
replace.with.comparator.fix.family.name=使用 'Comparator' static 方法簡化比較器
inspection.comparator.combinators.description=可以取代為 'Comparator' 鏈
inspection.comparator.combinators.description2=可以取代為 ''{0}''
inspection.unnecessary.string.escape.report.char.literals.option=報告字符文字
inspection.method.call.in.loop.ignore.known.methods.option=忽略有副作用的已知方法
fix.data.provider.signature.family.name=修正資料提供程序方法簽名
allow.suppressions.fix.family.name=允許禁止
allow.suppressions.fix.text=允許這些禁止
remove.suppress.comment.fix.family.name=移除 //{0}
convert.to.j.unit.4.fix.family.name=將 JUnit 3 類轉換為 JUnit 4
throws.runtime.exception.fix.family.name=從 'throws' 子句中移除
move.exception.to.javadoc.fix.family.name=移動到 Javadoc '@throws'
create.package.info.java.family.name=創建 'package-info.java'
remove.loop.fix.family.name=移除迴圈
remove.call.fix.family.name=移除調用
inspection.meta.annotation.without.runtime.description={0} 應具有 @Retention(RetentionPolicy.RUNTIME)
inspection.refused.bequest.super.annotated.option=僅在通過以下方式註解 super 方法時報告:
inspection.empty.class.ignore.subclasses.option=忽略 {0} 的子類
inspection.test.method.without.assertions.exceptions.option=忽略宣告異常的測試方法
inspection.collection.must.have.initial.capacity.initializers.option=不報告欄位初始值設定項
utility.class.without.private.constructor.cant.generate.constructor.title=無法生成構造函數
utility.class.without.private.constructor.cant.generate.constructor.message=實用程序類具有實例化，將不會創建 private 構造函數
inspection.suspicious.package.private.access.problem={0} 重寫了來自在不同模組 ''{2}'' 中宣告的 {1} 的 package-private 方法
inspection.condition.covered.by.further.condition.descr=條件 ''{0}'' 由後面的{1, choice, 1#條件 ''''{2}''''|2#條件}覆蓋
inspection.parameterized.parameters.static.collection.display.name=沒有資料提供程序方法的參數化測試類
create.missing.switch.branch=創建缺少的 switch 分支 ''{0}''
create.missing.switch.branches=創建缺少的分支: {0}
redundant.as.list.for.iteration.problem=不必要的 'Arrays.asList()' 調用
redundant.as.list.for.iteration.fix.name=解開
assert.with.side.effects.call.mutates.expression=調用 ''{0}()'' 會改變 ''{1}''
assert.with.side.effects.call.mutates.field=調用 ''{0}()'' 會改變欄位 ''{1}''
inspection.comparator.combinators.fix.chain=取代為 'Comparator' 鏈
logger.initialized.with.foreign.options.title=選擇記錄器工廠類
test.without.assertion.options.choose.class=選擇斷言類
constant.on.lhs.of.comparison.options.item.left=左
constant.on.lhs.of.comparison.options.item.right=右
convert.junit3.test.fix.conflict.semantics=如果 {1} 轉換為 JUnit 4，方法調用 {0} 可能會更改語意
convert.junit3.test.fix.conflict.compile=如果 {1} 轉換為 JUnit 4，方法調用 {0} 將不編譯
convert.junit3.test.fix.conflict.compile.2=如果 {1} 轉換為 JUnit 4，引用 {0} 將不編譯
inspection.byte.array.output.stream.to.string.message=ByteArrayOutputStream 轉換低效

fix.data.provider.signature.fix.name=將方法簽名更改為 ''{0}''
fix.data.provider.create.method.fix.name=創建資料提供程序方法 '@Parameters public static Iterable<Object> parameters()'
fix.data.provider.signature.missing.method.problem=參數化測試類 <code>#ref</code> 缺少用 '@Parameters' 註解的資料提供程序方法
fix.data.provider.signature.incorrect.problem=資料提供程序方法 <code>#ref()</code> 的簽名不正確
fix.data.provider.multiple.methods.problem=類 <code>#ref</code> 中存在多個 @Parameters 資料提供程序方法
cloneable.class.without.clone.todo.message=TODO: 複製此處的可變狀態，這樣此克隆就不能更改初始克隆的內部
cloneable.class.without.clone.ignore.when.clone.called.option=如果調用超類的 clone() 方法需要 Cloneable，則忽略
trivial.if.option.ignore.assert.statements=忽略 'assert' 語句
if.may.be.factorized.problem.descriptor=<code>#ref</code> 可以因式分解 #loc
if.may.be.factorized.quickfix=取代為因式分解表達式
weaken.visibility.quickfix=削弱可見性
non.final.field.in.enum.quickfix.option=在快速修復不可用時忽略欄位
checkbox.ignore.null.on.wrong.side=<html>忽略錯誤側的 <code>null</code></html>
cyclic.class.dependency.ignore.in.same.file=忽略位於同一檔案中的類之間的迴圈
ambiguous.field.access.navigate.quickfix=導航到明顯存取過的{0, choice, 1#局部變數|2#參數|3#欄位}
unnecessary.record.modifier.display.name=不必要的 'record' 修飾符
unnecessary.redundant.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於記錄是冗餘的
logger.initialized.with.foreign.class.ignore.super.class.option=忽略使用超類初始化的記錄器
logger.initialized.with.foreign.class.ignore.non.public.classes.option=忽略非 public 類中的記錄器
dangling.javadoc.ignore.copyright.option=忽略 JavaDoc 格式的檔案頭註釋
package.in.multiple.modules.problem.descriptor2=軟體套件 ''{0}'' 具有模組 ''{1}'' 和 ''{2}'' 中的類
package.in.multiple.modules.problem.descriptor3=軟體套件 ''{0}'' 具有模組 ''{1}''、''{2}'' 和 ''{3}'' 中的類
package.in.multiple.modules.problem.descriptor.many=軟體套件 ''{0}'' 具有模組 ''{1}''、''{2}'' 以及其他 {3} 個模組中的類
use.isblank.to.check.if.string.is.whitespace.or.empty=使用 'isBlank()' 檢查字串是否為空或者僅包含空格
expression.may.be.factorized.display.name=表達式可以因式分解
create.missing.enum.switch.branches.fix.family.name=創建缺少的枚舉 switch 分支
create.missing.sealed.class.switch.branches.fix.family.name=創建缺少的密封類 switch 分支
inspection.case.mismatch.message.label.is.lower=無法存取 switch 分支: 標籤包含小寫符號，而選擇器僅支援大寫
inspection.case.mismatch.message.label.is.upper=無法存取 switch 分支: 標籤包含大寫符號，而選擇器僅支援小寫
for.can.be.foreach.fix.no.indexed=不報告索引的 'java.util.List' 迴圈
use.of.concrete.class.option.ignore.records=忽略 Java 記錄
create.null.branch.fix.family.name=插入 'null' 分支
instanceof.concrete.class.pattern.problem.descriptor=針對具體類 <code>#ref</code> 的模式測試 #loc
remove.annotation.parameter.0.fix.name=移除註解參數 ''{0}''
set.annotation.parameter.0.1.fix.name=將註解參數 {0} 設定為 \\"{1}\\"
class.with.too.many.dependents.interfaces.option=忽略接口
progress.text.analyzing.package.0=正在分析軟體套件 {0}
unnecessary.transient.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於 'static' 欄位是冗餘的"
`;

exports[`src messages/JavaScriptBundle.properties 1`] = `
"# File Types
filetype.javascript.description=JavaScript
filetype.actionscript.description=ActionScript
filetype.typescript.description=TypeScript
filetype.typescript.jsx.description=TypeScript JSX
filetype.ecmascript6.description=ECMAScript 6
filetype.jsx.description=React JSX
filetype.jsx.display.name=React JSX
filetype.flow.description=Flow JS
filetype.flow.display.name=Flow JS
javascript.file=JavaScript 檔案
typescript.file=TypeScript 檔案
filetype.typescript.config.description=TypeScript 配置
filetype.typescript.config.display.name=TypeScript 配置

# Languages
javascript.language.simple.name=JavaScript
typescript.language.simple.name=TypeScript

# Language terms
javascript.language.term.function=函數
javascript.language.term.inner.function=內部函數
javascript.language.term.method=方法
javascript.language.term.constructor=構造函數
javascript.language.term.class=類
javascript.language.term.inner.class=內部類
javascript.language.term.interface=接口
javascript.language.term.inner.interface=內部接口
javascript.language.term.enum=枚舉
javascript.language.term.type.alias=類型別名
javascript.language.term.definition=定義
javascript.language.term.namespace=命名空間
javascript.language.term.parameter=參數
javascript.language.term.property=屬性
javascript.language.term.variable=變數
javascript.language.term.const=常數
javascript.language.term.const.field=常數欄位
javascript.language.term.readonly.field=唯讀欄位
javascript.language.term.local.variable=局部變數
javascript.language.term.local.const=局部常數
javascript.language.term.field=欄位
javascript.language.term.tag=標記
javascript.language.term.label=標籤
javascript.language.term.attribute=特性
javascript.language.term.decorator=裝飾器
javascript.language.term.attribute.value=特性值
javascript.language.term.package=軟體套件
javascript.language.term.module=模組
javascript.language.term.external.module.reference=外部模組引用
javascript.language.term.import.specifier=匯入說明符
javascript.language.term.export.specifier=匯出說明符
javascript.language.term.entity.name=實體名稱
javascript.language.term.jsdoc.tag=JSDoc 標籤
javascript.language.term.imported.default.binding=已匯入預設綁定
javascript.language.term.exported.default.binding=已匯出預設綁定
javascript.language.term.namespace.import=命名空間匯入
javascript.language.term.namespace.export=命名空間匯出
javascript.language.term.import.statement=import 語句
javascript.language.term.type.parameter=類型參數
javascript.language.term.destructuring.property=析構屬性
javascript.language.term.default.export=預設匯出
javascript.language.term.file=檔案
javascript.language.term.global=全域
javascript.language.term.xml.tag=xml 標籤

# Parser error messages
javascript.parser.message.expected.expression=應為表達式
javascript.parser.message.expected.xml.element=應為 XML 元素
javascript.parser.property.expected=應為屬性
javascript.parser.message.expected.lbrace=應為 {
javascript.parser.message.expected.at=應為 @
javascript.parser.message.expected.rbrace=應為 }
javascript.parser.message.expected.identifier.string.literal.or.numeric.literal=應為關鍵字、字串文字或數字文字
javascript.parser.message.expected.colon=應為 :
javascript.parser.message.expected.colon.or.comma=應為 : 或 ,
javascript.parser.message.expected.semicolon=應為 ;
javascript.parser.message.expected.lbrace.or.semicolon=應為 { 或 ;
javascript.parser.message.expected.rbracket=應為 ]
javascript.parser.message.expected.lparen=應為 (
javascript.parser.message.expected.rparen=應為 )
javascript.parser.message.expected.name=應為名稱
javascript.parser.message.expected.comma.or.rparen=應為 , 或 )
javascript.parser.message.expected.function.name=應為函數名稱
javascript.parser.message.expected.formal.parameter.name=應為參數名稱
javascript.parser.message.expected.statement=應為語句
javascript.parser.message.expected.parameter.name=應為參數名稱
javascript.parser.message.expected.property.name=應為屬性名稱
javascript.parser.message.expected.case.or.default=應為 'case' 或 'default'
javascript.parser.message.expected.forloop.left.hand.side.expression.or.variable.declaration='in' 前面應為左側表達式或變數宣告
javascript.parser.message.expected.forloop.in.or.semicolon=應為 'in' 或 ;
javascript.parser.message.expected.while.keyword=應為 'while'
javascript.parser.message.expected.comma=應為 ,
javascript.parser.message.expected.comma.or.rbrace=應為 , 或 }
javascript.parser.message.expected.variable.name=應為變數名稱
javascript.parser.message.expected.mult.or.lbrace=應為 * 或 {
javascript.parser.message.missing.rbrace=缺少 }
javascript.parser.message.missing.or_rbrace=缺少 |}
javascript.parser.message.missing.attribute.name=缺少特性名稱
javascript.parser.message.unexpected.end.of.file=意外的檔案結尾
javascript.parser.message.expected.type.name=應為類型名稱
javascript.parser.message.unclosed.string.literal=未閉合的字串文字
javascript.parser.message.unclosed.comment=未閉合註釋
javascript.parser.message.are.not.supported.by.dialect=當前 JavaScript 版本不支持 {0}
javascript.parser.message.expected.from=應為 'from'
javascript.parser.message.expected.typename=應為類型名稱
javascript.parser.message.expected.typename.or.*=* 應為 * 或類型名稱
javascript.parser.message.expected.name.or.lbrace=應為軟體套件名稱或 {
javascript.parser.message.expected.declaration=應為宣告
javascript.parser.message.expected.namespace=應為 'namespace'
javascript.parser.message.expected.string.literal=應為字串文字
javascript.parser.message.expected.xml=應為 XML 上下文關鍵字
javascript.parser.message.expected.equal=應為 =
javascript.parser.message.expected.identifier.lbrace.or.lbracket=應為關鍵字、{ 或 [
javascript.parser.message.expected.eqgt=應為 =>
javascript.parser.message.expected.identifier=應為關鍵字
javascript.parser.message.expected.instanceof=應為 'instanceof'
javascript.parser.message.expected.in=應為 'in'
javascript.parser.message.expected.value=應為值
javascript.parser.message.expected.identifier.or.value=應為關鍵字或值
javascript.parser.message.expected.as=應為 'as'
javascript.parser.message.expected.identifier.string.literal.or.lbrace=應為關鍵字、字串文字或 {
javascript.parser.message.expected.import.value=應為匯入綁定或說明符
javascript.parser.message.expected.import.specifier=應為匯入說明符
javascript.parser.message.expected.heredoc.closing.identifier=應為 heredoc 結束關鍵字
javascript.parser.message.expected.type.member=應為類型成員
javascript.parser.message.expected.tuple.comma.or.rbracket=應為 , 或 ]
javascript.parser.message.expected.target=僅接受 'target' 作為要新建的元屬性
javascript.parser.message.expected.meta=僅接受 'meta' 作為要匯入的元屬性
javascript.parser.message.expected.declare=應為 'declare'
javascript.parser.message.expected.exports=應為 'exports'
javascript.parser.message.expected.checks=應為 'checks'
javascript.parser.message.expected.type.keyword=應為 'type'
javascript.parser.message.expected.type=應為類型
javascript.parser.message.expected.question=應為 ?
javascript.parser.message.expected.class=應為 'class'

# Validation messages
javascript.validation.message.conflicting.definition.was.found.with.the.same.name=在命名空間 {1} 中發現衝突性的繼承宣告 {0}
javascript.validation.message.duplicate.declaration=重複宣告
javascript.validation.message.duplicate.declaration.fix.remove=移除類型
javascript.validation.message.redundant.type=顯式類型實參 {0} 可以取代為 {1}
javascript.validation.message.redundant.type.remove=可以移除顯式類型實參 {0}
javascript.validation.message.duplicate.export.declaration=匯出宣告與已匯出的宣告 ''{0}'' 相衝突
javascript.validation.message.duplicate.default.export.declaration=一個模組不能有多個預設匯出
javascript.validation.message.duplicate.default.export.in.module=預設匯出只能在 ECMAScript-style 模組中使用
javascript.validation.message.duplicate.declaration.fix.text=導航到上一個宣告 ''{0}''
javascript.validation.message.duplicate.declaration.fix.text.no.name=導航到上一個宣告
javascript.validation.message.redeclaration.of.block.scope=無法重新宣告塊範圍變數
javascript.validation.message.redeclaration.of.block.scope.in.scope.of.var=塊範圍變數不能與同一塊範圍中的\\"var\\"變數或參數使用相同的名稱
javascript.validation.message.redeclaration.of.var.in.scope.of.block.scope=\\"var\\" 變數不能與其可見性範圍內的塊範圍變數使用相同的名稱
javascript.validation.message.assignment.to.const=嘗試賦值給常數或唯讀變數
javascript.validation.message.assignment.to.const.fix.replace=取代為 let
javascript.validation.message.assignment.to.const.fix.remove.readonly=移除唯讀修飾符
javascript.validation.message.must.be.lvalue={0} 中的左側無效
javascript.validation.message.const.variable.without.initializer='const' 變數不包含初始值設定項。以後無法賦予有意義的值。
javascript.validation.message.constructor.field.not.allowed=類可能沒有名為 'constructor' 的非 static 欄位
es6.validation.message.const.variable.without.initializer=不允許使用無初始值設定項的 'const' 變數
javascript.validation.message.continue.without.target=無法確定 'continue' 的目標
javascript.validation.message.break.without.target=無法確定 'break' 的目標
javascript.validation.message.continue.outside.loop='continue' 在迴圈語句外部
javascript.validation.message.return.outside.function.definition='return' 在函數定義外部
javascript.validation.message.duplicate.label=重複標籤
javascript.validation.message.extend.multiple.classes=類不能擴展多個類
javascript.validation.message.extend.final.class=無法擴展 final 類 ''{0}''
javascript.validation.message.identifier.not.allowed.in.strict.mode=在嚴格模式下不能將 ''{0}'' 用作關鍵字
javascript.validation.message.for.await.top.level=使用了頂層 'for await'
javascript.validation.message.for.await.no.async.context='for await' 只能在 'async' 函數中使用
typescript.validation.message.invalid.modifier.cannot.be.here=修飾符 {0} 不能出現在此處
typescript.validation.message.duplicate.modifier=已看到修飾符 {0}
typescript.validation.message.duplicate.modifier2=已看到可存取性修飾符
typescript.validation.message.abstract.cannot.be.used=''{0}'' 修飾符不能與 ''abstract''修飾符結合使用
typescript.validation.message.abstract.class.be.created=無法創建 abstract 類 ''{0}'' 的實例
typescript.validation.message.abstract.member.access.super=無法通過 super 表達式存取 abstract 方法 ''{0}''。
typescript.validation.message.abstract.cannot.have.body=方法不能具有實作，因為它被標記為 'abstract'
typescript.validation.message.abstract.overload=多載簽名必須全部為 abstract 或非 abstract。
typescript.validation.message.constructor.cannot.be.abstract=構造函數不能為 'abstract'
typescript.validation.message.function.implementation.missing=缺少函數實作或此宣告之後未緊隨函數實作
typescript.validation.message.abstract.class.should.be=abstract 方法只能出現在 abstract 類中
typescript.validation.module.reference.with.extension=外部模組引用不能以擴展結束
typescript.validation.class.extend.not.constructor.type=類型 ''{0}'' 不是構造函數類型
typescript.validation.class.extend.no.type.arguments.type=沒有任何基類構造函數具有指定數量的類型實參
typescript.validation.class.extend.many.constructors=基類構造函數必須具有相同的返回類型
typescript.validation.class.extend.cycled.definition=迴圈類定義
typescript.validation.class.extend.constructor.return.not.class=基類構造函數返回類型 ''{0}'' 不是類或接口類型。
javascript.validation.generators.yield.not.iterable=表達式類型沒有定義 [Symbol.iterator] 或 [Symbol.asyncIterator]
javascript.validation.generators.yield.not.assignable.to.return=類型 ''{1}'' 不可分配給類型 ''{0}''
typescript.validation.generators.incorrect.type.annotation=發生器不能有 ''{0}'' 類型註解
typescript.validation.async.incorrect.type.annotation=異步函數不能有 ''{0}'' 類型註解
typescript.validation.generators.incorrect.type.annotation.iterable=類型 ''{0}'' 不可分配給類型 ''{1}''。
typescript.validation.generators.overload=多載簽名無法被宣告為生成器
typescript.validation.generators.ambient=環境上下文中不允許使用生成器
typescript.validation.generators.no.yield=生成器隱式具有類型 'IterableIterator<any>'，因為它不產生任何值。請考慮提供返回類型。
typescript.validation.generators.async.no.yield=生成器隱式具有類型 'AsyncIterableIterator<any>'，因為它不產生任何值。請考慮提供返回類型。
typescript.validation.cannot.find.best.common.type=無法從用法推斷類型實參


# Surround with names
javascript.surround.with.do.while=do / while
javascript.surround.with.for=for
javascript.surround.with.if=if
javascript.surround.with.if.else=if / else
javascript.surround.with.if.cond=if (cond)
javascript.surround.with.if.else.cond=if (cond) / else
javascript.surround.with.parenthesis=(expr)
javascript.surround.with.not.parenthesis=!(expr)
javascript.surround.with.cast=Type(expr)
javascript.surround.with.try.catch=try / catch
javascript.surround.with.try.finally=try / finally
javascript.surround.with.try.catch.finally=try / catch / finally
javascript.surround.with.while=while
javascript.surround.with.with=with
javascript.surround.with.function=函數
javascript.surround.with.function.expression=函數表達式
javascript.surround.with.object.literal=物件文字

# Introduce variable
javascript.introduce.variable.title=提取變數
javascript.introduce.variable.title.local=引入局部變數
javascript.introduce.variable.error.no.expression.selected=無法引入變數。\\\\n選定內容不構成表達式。
javascript.introduce.variable.error.expression.has.void.type=無法引入變數。\\\\n選定的表達式類型無效。
javascript.introduce.variable.name.prompt=名稱(&N):
javascript.introduce.variable.replace.all.occurrences=取代所有符合項(找到 {0} 個匹配項)(&A)
javascript.introduce.variable.invalid.name=請輸入有效名稱。
javascript.introduce.element.already.exists=範圍中已存在同名的 {0}。
javascript.introduce.variable.arrow.function.parameter.referenced=無法引入。\\\\n選定內容包含對箭頭函數參數的引用
javascript.introduce.variable.arrow.await.referenced=無法引入。\\\\n選定內容包含 await 表達式
javascript.introduce.variable.xml.embedded=無法在嵌入式表達式中引入變數
javascript.introduce.incorrect.context=無法引入變數。\\\\n選定內容包含對\\"this\\"的引用
javascript.introduce.field.title=引入欄位
javascript.introduce.field.error.no.expression.selected=無法引入欄位。\\\\n選定內容不構成表達式。
javascript.introduce.field.error.expression.has.void.type=無法引入變數。\\\\n選定的表達式類型無效。
javascript.introduce.field.error.no.enclosing.class=無法引入欄位。\\\\n沒有封閉類。
javascript.introduce.field.make.readonly=設為唯讀(&R)
javascript.introduce.field.initialize.in.scope=初始化在(&I):
javascript.introduce.field.visibility=可見性(&V):
javascript.introduce.field.keyboard.hint=按 {0} 用於鍵盤快捷鍵
javascript.introduce.field.before.super.call=無法引入欄位。\\\\n在\\"super\\"調用前無法存取\\"this\\"。
javascript.introduce.field.current.method=當前方法
javascript.introduce.field.field.declaration=欄位宣告
javascript.introduce.field.constructor=構造函數
javascript.introduce.constant.title=引入常數
javascript.introduce.constant.error.no.expression.selected=無法引入常數。\\\\n選定內容不構成表達式。
javascript.introduce.constant.error.expression.has.void.type=無法引入常數。\\\\n選定的表達式類型無效。
javascript.introduce.constant.error.not.constant.expression.selected=無法引入常數。\\\\n選定內容不是常數表達式。
javascript.introduce.parameter.title=提取參數
javascript.introduce.parameter.error.no.expression.selected=無法引入參數。\\\\n選定內容不構成表達式。
javascript.introduce.parameter.error.no.containing.function=無法引入參數。\\\\n找不到要使用的包含函數。
javascript.introduce.parameter.error.expression.has.void.type=無法引入參數。\\\\n選定的表達式類型無效。
javascript.introduce.parameter.error.not.async.context=無法為包含 'await' 的表達式引入參數。\\\\n並非所有用法都包含在異步函數中
javascript.introduce.parameter.error.target.not.async=無法為包含 'await' 的表達式引入參數。\\\\n目標函數不是異步函數
javascript.introduce.parameter.error.yield=無法為包含 'yield 的表達式引入參數。
javascript.introduce.parameter.generate.jsdoc=生成 JSDoc
javascript.introduce.parameter.optional.parameter=可選參數
javascript.introduce.throw.expressions.unsupported=無法調用重構。\\\\n\\"Extract\\"重構中當前不支持 Throw 表達式。
javascript.introduce.breaks.operator.precedence=無法調用重構。\\\\n通過引入將更改表達式中的運算符優先級。
javascript.introduce.constant.in.es5=無法調用重構。\\\\n無法在 ECMAScript 3 或 ECMAScript 5 程式碼中引入常數。
javascript.introduce.in.embedded.expression=無法調用重構。\\\\n無法在嵌入式表達式中引入
javascript.introduce.variable.make.constant=設為常數
list.item.class.field=類欄位
list.item.global.or.module.constant=全域或模組常數
list.item.local.constant=局部常數

# Highlighting categories
javascript.keyword=關鍵字
javascript.string=字串
javascript.number=數字
javascript.linecomment=行註釋
javascript.doccomment=文檔註釋
javascript.blockcomment=塊註釋
javascript.regexp=正則表達式
javascript.operation=運算
javascript.parens=括號
javascript.brackets=中括號
javascript.braces=大括號
javascript.semicolon=分號
javascript.badcharacter=錯誤字符
jsdoc.text=JSDoc 文本
jsdoc.tag=JSDoc 標籤
jsdoc.tag.value=JSDoc 標記值
jsdoc.type=JSDoc 類型
javascript.doctag=文檔標籤
javascript.doctagvalue=文檔標記值
javascript.valid.string.escape=有效字串轉義
javascript.invalid.string.escape=無效字串轉義
javascript.comma=逗號
javascript.dot=點

# Errors with intentions
javascript.unresolved.function.name.message=未解析的函數或方法 {0}() #loc
javascript.unresolved.variable.name.message=未解析的變數 {0} #loc
javascript.unresolved.variable.null.qualifier.message=''{0}'' 的限定符可能為 null #loc
javascript.unresolved.variable.undefined.qualifier.message=''{0}'' 的限定符可能未定義 #loc
javascript.unresolved.variable.null.or.undefined.qualifier.message=''{0}'' 的限定符可能為 null 或 undefined #loc
javascript.unresolved.type.name.message=未解析的類型 {0} #loc
javascript.unresolved.circle.definition=匯入的圓定義
javascript.missing.read.property=未解析的讀取屬性 #loc
javascript.missing.write.property=未解析的寫入屬性 #loc
javascript.unresolved.variable.or.type.name.message=未解析的變數或類型 {0} #loc
javascript.unresolved.variable.or.type.name.message2=未解析的變數或類型 {0}
javascript.unresolved.symbol.message=未解析的符號
javascript.unresolved.file=找不到檔案 {0}
javascript.unknown.metadata.tag=未知元資料標籤
javascript.unknown.metadata.attribute=未知元資料特性
javascript.undeclared.variable.name.message=隱式宣告變數 {0} #loc
javascript.create.function.intention.name=創建函數 ''{0}''
javascript.create.variable.intention.name=創建變數 ''{0}''
javascript.create.constant.intention.name=創建常數 ''{0}''
javascript.declare.variable.intention.name=為 ''{1}'' 插入 {0} 宣告
javascript.declare.variable.intention.family.name=插入 var 宣告
javascript.declare.variable.in.previous.var.statement.intention.name=將 ''{0}'' 的 var 宣告插入之前的 var 語句
javascript.declare.variable.in.previous.var.statement.intention.family=將 var 宣告插入之前的 var 語句
javascript.create.field.intention.name=創建欄位 ''{0}''
javascript.create.constant.field.intention.name=創建常數欄位 ''{0}''
javascript.create.method.intention.name=創建方法 ''{0}''
javascript.create.property.intention.name=創建屬性 ''{0}''
javascript.create.function.property.intention.name=創建函數屬性 ''{0}''
javascript.create.constructor.intention.name=在 ''{0}'' 類中創建構造函數
javascript.create.get.property.intention.name=創建 ''get'' 屬性 ''{0}''
javascript.create.set.property.intention.name=創建 ''set'' 屬性 ''{0}''
javascript.create.function.intention.family=創建 JavaScript 函數或方法
javascript.create.variable.intention.family=創建 JavaScript 變數或屬性
javascript.intention.create.getter.setter=為 ''{0}'' 創建 getter 和 setter
javascript.intention.create.getter.setter.desc=創建 getter 和 setter
javascript.intention.create.setter=為 ''{0}'' 創建 setter
javascript.intention.create.setter.desc=創建 setter
javascript.intention.create.getter=為 ''{0}'' 創建 getter
javascript.intention.create.getter.desc=創建 getter
create.mobile.view=創建檢視 ''{0}''
javascript.rename.reference.intention.name=重命名引用
typescript.rename.javascript.references=在 JavaScript 檔案中搜尋(&J)
typescript.rename.dynamic.references=搜尋動態引用 (&D)
js.usage.type.call=函數調用中的用法
js.anonymous.to.named.function=匿名函數轉換為命名函數
js.convert.to.named.function=轉換為命名函數
js.convert.to.named.function.to.class.method=轉換為類方法
js.convert.to.arrow.function=轉換為箭頭函數
js.add.braces.to.arrow.function=向箭頭函數中添加大括號
js.inspection.function.expression.is.used.instead.of.arrow=使用了函數表達式而不是箭頭函數
js.arrow.function.braces.can.be.removed.key=箭頭函數體周圍的大括號冗餘
js.arrow.function.braces.can.be.removed.problem.description=可以移除箭頭函數體周圍的大括號
js.arrow.function.braces.can.be.removed.fix.family.name=移除箭頭函數體周圍的大括號
js.convert.to.anonymous.function.family.name=箭頭函數轉換為匿名函數
js.convert.to.anonymous.function=轉換為匿名函數
js.named.to.anonymous.family.name=轉換為函數表達式
js.named.to.function.expression.text = 轉換為包含變數的函數表達式
js.named.to.function.hoisting.conflict.text=函數在宣告之前使用。轉換為變數後，將中斷使用
js.named.to.arrow.text = 轉換為含有 {0} 的箭頭函數
js.split.into.multiple.declarations=拆分為多個宣告
js.remove.digit.separators=移除數字分隔符
js.copy.qualified.to.clipboard=將限定名稱複製到剪貼簿
js.iterate=使用 'for..of' 進行迭代
js.iterate.async=使用 'for await..of' 進行迭代
js.separate.digits=分隔數字
js.separate.nibbles=分隔半字節
js.separate.bytes=分隔字節
js.separate.words=分隔 16 位單詞
js.separate.thousands=分隔千位數
js.separate.thousands.in.integer.part=將千位數分隔成整數
js.split.declarations=拆分宣告
js.replace.string.with.es6.template=取代為模板字串
js.replace.string.concatenation.with.es6.template.inspection.name=已使用字串串聯而不是模板文字
js.replace.string.concatenation.with.es6.template.fix.text=取代為模板字串
js.string.template.line.separators.visible=轉換為可見行分隔符
js.string.template.line.separators.multispan=轉換為多行字串模板
js.string.template.line.separators.visible.family.name=轉換模板字串以使用可見行分隔符
js.string.template.line.separators.multispan.family.name=轉換為多行字串模板
js.convert.var.to.let.text=轉換為 let
js.convert.var.to.const.text=轉換為 const
js.convert.var.to.let.or.const=轉換為 let/const
js.convert.var.to.let.or.const.family.name=將 var 轉換為 let/const
js.convert.var.to.let.or.const.inspection.text=已使用 'var' 而不是 'let' 或 'const'
js.convert.let.to.const.inspection.text=已使用 'let' 而不是 'const'
js.convert.var.to.let.or.const.inspection.conservative.option=使用“全部修復”操作保守地轉換 var
js.convert.var.to.let.or.const.inspection.conservative.option.description=在第一次使用變數之前，宣告可能會移至函數器頂部。\\\\n要在使用“全部修復”操作時禁用此行為，請選中“保守轉換 var”選項。
js.convert.require.into.es6.import.text=將 require() 轉換為 import
js.convert.require.into.es6.import.family.name=將 require() 轉換為 import
js.convert.require.into.es6.import.inspection.text=使用了 'require()' 而不是 'import'
js.convert.require.into.es6.import.inspection.withConditional.option=使用“全部修復”操作在內部範圍內轉換 require()
js.convert.require.into.es6.import.inspection.withConditional.option.description=在內部範圍內轉換 require()（例如 'if' 語句或內部函數）
js.convert.module.exports.into.es6.export.text=轉換為 export
js.convert.module.exports.into.es6.export.family.name=轉換為 export
js.convert.module.exports.into.es6.export.inspection.text=使用了 'module.exports' 而不是 'export'
js.convert.for.in.to.for.of.text=將 'for..in' 轉換為 'for..of'
js.convert.for.in.to.for.of.family.name=將 'for..in' 轉換為 'for..of'
js.convert.for.in.to.for.of.inspection.text=使用了 'for..in' 而不是 'for..of'
js.convert.indexed.for.to.for.of.text=將帶索引的 'for' 轉換為 'for..of'
js.convert.indexed.for.to.for.of.family.name=將帶索引的 'for' 轉換為 'for..of'
js.convert.indexed.for.to.for.of.inspection.text=已使用索引的 'for' 而不是 'for..of'
js.convert.for.each.to.for.of.intention.family=將 'forEach' 取代為 'for..of' 迴圈
js.convert.for.each.to.indexed.intention.family=將 'forEach' 取代為索引的 'for' 迴圈
js.convert.for.of.to.indexed.intention.family=將 'for..of' 取代為索引的 'for' 迴圈
js.convert.map.to.for.of.intention.family=將 'map' 陣列調用取代為 'for..of' 迴圈
js.convert.indexed.for.to.foreach.intention.family=將索引的 'for' 轉換為 'forEach' 調用
js.add.then.fix=添加 '.then()'
js.quote.unquote.intention.plural={0} 屬性名稱
js.quote.unquote.intention.singular={0} 屬性名稱
js.quote.unquote.intention.quote=引用
js.quote.unquote.intention.quote.family=使用引號包裝屬性名稱
js.quote.unquote.intention.unquote=取消引用
js.quote.unquote.intention.unquote.family=移除屬性名稱中的引號
js.property.to.indexer.intention=取代為索引器存取
js.indexer.to.property.intention=取代為屬性存取
js.join.vars.intention=加入後續變數宣告
js.infer.parameter.types.intention=從用法中推斷參數類型
js.infer.parameter.types.intention.jsdoc=從用法中推斷 JSDoc 參數類型
js.infer.parameter.types.intention.failure.title=無法推斷類型
js.infer.parameter.types.intention.progress.text=正在推斷類型
js.infer.parameter.types.intention.failure.text=無法從用法中推斷類型
js.infer.parameter.types.intention.failure.readonly.text=無法從用法中推斷類型：為唯讀檔案

# Move module members
es6.move.module.members.refactoring.name=移動模組成員
es6.move.module.members.table.title=要移動的成員
es6.move.module.members.refactoring.create.file=創建檔案
es6.move.module.members.refactoring.file.does.not.exist=檔案 {0} 不存在
es6.move.module.members.refactoring.create.file.message=檔案 {0} 不存在。\\\\n要創建嗎?
es6.move.module.members.refactoring.dialog.error.no.script.tag=目標檔案不包含腳本標籤
es6.move.module.members.refactoring.dialog.error.invalid.file.name=目標文件名在此操作系統中無效
es6.move.module.members.refactoring.dialog.error.no.selected.items=沒有要移動的選定成員
es6.move.module.members.refactoring.dialog.error.incorrect.module=目標模組不正確
es6.move.module.members.refactoring.dialog.error.modules.same=源模組和目標模組應不同
es6.move.module.members.refactoring.dialog.move.member.to=成員移動至
es6.move.module.members.refactoring.dialog.field.from=從:
es6.move.module.members.refactoring.dialog.field.to=到:
es6.move.module.members.references.unresolved.import.message=選擇的 {0} 引用未解析匯入 {1}
es6.move.module.members.references.local.message=選擇的 {0} 引用非匯出 {1}
es6.move.module.members.has.local.usage.message=檔案 {1} 中使用未匯出的 {0}
es6.move.module.members.non.es6.module.usage=在非 ES6 模組的檔案 {1} 中使用 {0}
es6.move.module.members.destination.not.es6=目標檔案 {0} 不是 ES6 模組
es6.move.module.members.cannot.detect.js.language=目標檔案不是 JS 檔案
es6.move.module.members.destination.contains.default.export=目標模組包含預設匯出
es6.move.module.members.destination.does.not.support.jsx={0} 包含 JSX 標籤，但目標語言不支持這些標籤
es6.move.module.members.syntax.errors=移動 {0} 將引入語法錯誤，因為目標語言不同於源語言
es6.move.module.members.incompatible.language=目標模組具有不相容的語言
dialog.title.move.members=移動成員

js.pull.up.will.be.made.abstract=非 abstract {0} 將被設為 abstract
es6.extract.super.destination.label=目標檔案 (&D)：
es6.extract.super.members.in.interface=新接口中的成員
es6.extract.super.members.in.superclass=新超類中的成員
es6.extract.super.overload.declaration.without.implementation.conflict=類中不允許沒有實作的多載宣告 {0}
es6.extract.super.different.name.expected=應為不同名稱

# Unit testing
js.testing.inspection.group.name=單元測試
js.testing.highlight.line=在測試程式碼中高亮顯示失敗的行
rc.environmentVariables.label=環境變數(&E)：
rc.testRunScope.all=所有測試(&L)
rc.testRunScope.testFile=測試檔案 (&F)
rc.testRunScope.suite=套件
rc.testRunScope.test=測試(&T)
rc.nodeOptions.label=節點選項 (&O)：
rc.workingDirectory.label=工作目錄(&W):
rc.workingDirectory.browseDialogTitle=選擇工作目錄
rc.testOrSuiteScope.suite.title=編輯套件名稱
rc.testOrSuiteScope.suite.label=套件名稱:
rc.testOrSuiteScope.test.title=編輯測試名稱
rc.testOrSuiteScope.test.label=測試名稱：
rc.testOrSuiteScope.emptyTest=空測試名稱
rc.testRunScope.testFile.label=測試檔案：
rc.testRunScope.testFile.browseTitle=選擇測試檔案

# Unit testing: Jest
jest.snapshot.update.rc.name=更新 {0} 的快照
jest.snapshot.update.single.test.text=<link>點擊以更新 ''{0}'' 的快照</link>
jest.snapshot.update.test.file.text=<link>點擊以更新 {0} 中失敗的快照</link>
jest.snapshot.update.all.tests.text=<link>點擊以更新所有失敗的快照</link>
jest.rc.configurationFile.label=配置檔案(&C):
jest.rc.configurationFile.title=選擇 Jest 配置檔案
jest.rc.jestPackageField.label=Jest 軟體套件(&J)：
jest.rc.jestOptions.label=Jest 選項：
jest.rc.jestOptions.emptyText=CLI 選項，例如 --watch 或 --env=jsdom
jest.coverage.notification.title=Jest 覆蓋率
jest.coverage.directory.not.found.notification.content=無法從 Jest 配置中讀取 coverageDirectory 選項
jest.coverage.cannot.find.lcov.info.notification.content=無法顯示 Jest 覆蓋率: 找不到 {0}。

# Unit testing: Protractor
protractor.rc.configurationFile.label=配置檔案(&C):
protractor.rc.configurationFile.title=選擇 Protractor 配置檔案
protractor.rc.protractorPackage.label=Protractor 軟體套件(&P)：
protractor.rc.protractorOptions.label=Protractor 選項 (&O)：
protractor.rc.protractorOptions.emptyText=CLI 選項，例如 --browser 或 --rootElement

# Node.js
node.js.inspection.group.name=Node.js
node.js.missing.require=缺少 require() 語句
node.js.unresolved.api=未解析的 Node.js API
node.js.invalid.node=該專案使用了無效的 Node.js 路徑。<br>它已更新為使用 {0} 中的 Node.js。
node.js.downloading=正在下載 Node.js {0}
node.js.interpreters=Node.js 解釋器
node.js.set.project.interpreter.action=設定為專案解釋器
node.js.add.interpreter.action=添加{0}…
notification.title.cannot.enable.node.js.coding.assistance=無法啟用 Node.js 編碼輔助
notification.title.cannot.download.types.node=無法下載 @types/node
status.text.add.interpreter.with=使用 {0} 添加解釋器
status.text.no.interpreters.added=未添加解釋器
popup.content.cannot.edit.selected.node.js.interpreter=無法編輯選定的 Node.js 解釋器
node.no.interpreter=無解釋器
node.interpreter.not.found=找不到 {0}
no.executable.found.in.path=在 {0, choice, 0#%PATH%|1#$PATH} 中未找到可執行檔案
merged.process.output.text={0}{2, choice, 0#\\\\n\\\\n標準錯誤:\\\\n{1}|1#}{4, choice, 0#\\\\n\\\\n標準輸出:\\\\n{3}|1#}\\\\n\\\\n{5}
node.interpreter.download=下載 Node.js
node.interpreter.project_node.reference.name=專案
node.interpreter.node_from_path.reference.name=node

# Inspections
js.inspection.group.name=常規
typescript.inspection.group.name=TypeScript
js.inspection.bitwise.group.name=按位運算問題
js.code.style.issues.group.name=程式碼樣式問題
js.probable.bugs.group.name=可能的錯誤
js.annotator.inspection.name=未遵循 ECMAScript 規範
js.inspection.convert.to.es6.group.name=ES2015 遷移協助
js.inspection.switch.group.name=切換語句問題
js.inspection.async.group.name=Async 程式碼和 promise
js.function.metrics.group.name=函數指標
js.validity.issues.group.name=有效性問題
js.imports.dependencies.group.name=匯入和依賴關係
js.unused.symbols.group.name=未使用的符號
js.unwanted.symbols.group.name=可能不合需要的程式碼結構
js.assignment.issues.group.name=賦值問題
js.potentially.invalid.usage.of.this.inspection.name=從閉包對 'this' 的引用可能無效
js.potentially.invalid.usage.of.class.this.inspection.name=從閉包對類中 'this' 的引用可能無效
js.potentially.invalid.target.of.indexed.property.access.inspection.name=索引的屬性存取的目標可能不正確
javascript.potentially.invalid.usage.of.this=This 的用法可能無效
javascript.potentially.invalid.usage.of.class.this=通過嵌套函數的 'this.' 對類欄位的引用存取可能無效
javascript.potentially.invalid.target.of.indexed.property.access=索引的屬性存取的目標可能無效
js.unfiltered.for.in.loop.inspection.name=未過濾 for..in 迴圈
javascript.unfiltered.for.in.loop=可能迭代意外(自訂/繼承)成員，可能缺少 hasOwnProperty 檢查
js.unfiltered.for.in.loop.skip.primitives=使用陣列或物件初始值設定項跳過引用迭代
js.unfiltered.for.in.loop.skip.primitives.tooltip=在未修改 Object.prototype 和 Array.prototype 時啟用它
js.referencing.mutable.variable.from.closure.inspection.name=從閉包中引用可變變數
javascript.mutable.variable.accessible.from.closure=可從閉包存取可變變數
js.unresolved.variable.inspection.name=未解析的 JavaScript 變數
ts.unresolved.variable.inspection.name=未解析的 TypeScript 變數
js.undeclared.variable.inspection.name=隱式宣告的全域 JavaScript 變數
js.duplicate.declaration.inspection.name=重複宣告
# WI-11522 only the first word should start with uppercase letter
js.linters.inspection.group.name=程式碼品質工具
js.linters.detect.automatically.caption=從最近的 package.json 檢測軟體套件和配置檔案
js.unused.local.symbol.inspection.name=未使用的局部符號
js.unused.es6.import.inspection.name=未使用的 import
js.unused.assignment.inspection.name=未使用的賦值
js.join.declaration.assignment.inspection.name=變數宣告可與變數的第一個賦值合併
js.join.declaration.assignment.inspection.fix=聯接變數宣告和賦值
js.unused.global.symbol.inspection.name=未使用的全域符號
js.missing.await.symbol.inspection.name=異步函數調用缺少 await
js.missing.await.symbol.inspection.for.returns=始終對異步函數調用使用 'await' 以避免錯誤，並幫助進行 V8 異步堆疊跟踪
js.missing.await.symbol.inspection.for.generator.name=異步生成器應使用 for-await 迴圈進行迭代
jsx.missing.namespace.inspection.name=JSX 程式碼中缺少 'React' 命名空間匯入
jsx.missing.namespace.inspection.text=在未匯入 {0} 的情況下使用 JSX
tsx.missing.name.quick.fix.name=\\"添加 {0} import 語句
js.destructuring.merge.inspection=正在析構具有相同鍵的屬性
js.destructuring.merge.inspection.text=可以合併具有多個相同鍵的析構屬性
js.destructuring.merge.inspection.fix=合併析構屬性
js.nested.template.literal.inspection=模板文字中的冗餘嵌套
js.nested.template.literal.fix=內聯嵌套文字
js.redundant.await.inspection=冗餘 'await' 表達式
js.await.promise.resolve.inspection=冗餘 'await Promise.resolve()'
js.await.promise.reject.inspection=冗餘 'await Promise.reject()'
js.await.promise.double.await.inspection=冗餘 'await await'
js.await.promise.return.await.inspection=冗餘 'return await'
js.await.promise.trivial.await.inspection=非 promise 類型的冗餘 'await'
js.await.promise.resolve.fix=取代為 ''{0}''
js.top.level.await.expression.inspection= 頂層 'await' 表達式
js.top.level.await.expression.inspection.description= 使用了頂層 'await' 表達式
js.possibly.async.function.inspection=非異步函數中的 'await'
js.await.in.synchronous.function='await' 運算符只能在 'async' 函數中使用
js.possibly.async.function.quick.fix=令函數 {0} 為異步函數
js.possibly.async.function.quick.fix.family.name=將函數設為異步
js.property.can.be.replaced.with.shorthand=屬性可以取代為速記形式
js.property.can.be.replaced.with.shorthand.method=屬性可以取代為速記方法
js.replace.with.shorthand.property.quick.fix=取代為速記屬性
js.replace.with.shorthand.method.quick.fix=取代為速記方法
js.expand.shorthand.property.quick.fix=展開速記屬性
js.unresolved.function.inspection.name=未解析的 JavaScript 函數
ts.unresolved.function.inspection.name=未解析的 TypeScript 函數
js.unresolved.react.component.name=未解析的 React 組件
js.deprecated.symbols.inspection.name=已使用棄用的符號
js.suspicious.eq.plus.inspection.name=可疑的 '=+' 賦值
js.suspicious.eq.plus.inspection.desc=可疑的 '=+' 賦值：'+=' 可能拼寫錯誤
js.suspicious.eq.plus.fix.name=取代為 '+='
js.suspicious.name.combination.inspection.name=可疑的變數/參數名稱組合
js.bitwise.operator.usage.name=按位運算符用法
js.bitwise.operator.usage.popup=使用了按位運算符
js.bitwise.operator.usage.quickfix=取代為 {0}
js.potentially.invalid.constructor.usages.inspection.name=可能無效的構造函數用法
js.mismatched.update.collection.inspection.name=不符合的集合查詢和更新
js.mismatched.update.collection.update.method.names=更新方法名稱
js.closure.compiler.syntax.inspection.name=JSDoc 標記不正確的用法
js.closure.compiler.syntax.implements.not.interface={0} 未用 @interface 進行註解
js.closure.compiler.syntax.cyclic.inheritance=涉及 {0} 的迴圈繼承
js.closure.compiler.syntax.empty.type=空類型不可用
js.closure.compiler.syntax.invalid.type=類型語法無效
collection.updated.but.not.queried=更新了集合 <code>#ref</code> 的內容，但從未被查詢
collection.queried.but.not.update=查詢了集合 <code>#ref</code> 的內容，但從未寫入
javascript.constructor.with.lower.case.name.used.message=構造函數名稱通常以大寫字母開頭。拼寫錯誤？
interface.function.declaration.should.have.no.body=接口函數宣告不應有本體
javascript.ambient.declaration.should.have.no.body=環境宣告不應有本體
javascript.ambient.declaration.should.have.no.initializer=環境宣告不應有初始值設定項
javascript.ambient.declaration.const.should.be.primitive=環境上下文中的 'const' 初始值設定項必須是基元文字或文字枚舉引用
javascript.deprecated.symbol.used.name.message=使用了棄用的符號，請查閱文檔，以獲取更好的替代性 #loc
javascript.deprecated.symbol.used.name.message2=自版本 {0} 符號被標記為棄用以來，使用 {1} 作為取代用 #loc
js.unused.symbol=未使用的 {0} #ref
js.unused.symbol.full=未使用的 {0}
js.unused.symbol.remove=移除未使用的 {0}
js.suspicious.name.assignment=''{0}'' 可能不應分配給 ''{1}''
js.suspicious.name.parameter=''{0}'' 可能不應作為參數 ''{1}'' 傳遞
js.suspicious.name.return=''{0}'' 可能不應從方法 ''{1}'' 返回
js.constructor.cant.have.return.type=構造函數不能有返回類型
invalid.identifier.value.0=無效關鍵字：''{0}''
js.suspicious.bind.with.arrow.function=箭頭函數 'bind' 用法可疑
javascript.change.signature.invalid.parameter.declaration=無效參數：''{0}''
javascript.change.signature.invalid.function.name.0=無效函數名稱：''{0}''
javascript.validation.generators.yield.not.in.generator=只允許在生成器本體中使用 'yield' 表達式。
javascript.validation.new.target.not.in.function=僅允許函數宣告、函數表達式或構造函數的本體中有元屬性 'new.target'
javascript.validation.message.this.referenced.from.static.context=在 static 上下文中引用了 'this'
javascript.validation.message.super.referenced.without.class.instance.context=在沒有類實例上下文的情況下引用了'super'
javascript.validation.message.super.referenced.from.static.context=在 static 上下文中引用了 'super'
javascript.validation.message.function.override.without.override.modifier=方法重寫了沒有 override 關鍵字的超類 {0} 中的方法
javascript.validation.multiple.var.in.for.loop=''{0}'' 迴圈中只允許一個變數
javascript.validation.initialized.var.in.for.loop=''{0}'' 迴圈中不允許變數初始值設定項
javascript.fix.add.override.modifier=添加覆寫修飾符
javascript.fix.property.spelling.family=修復屬性名稱中可能的拼寫錯誤
javascript.fix.property.spelling.text=將拼寫調整為 ''{0}''
js.code.style.tab.name=JavaScript
js.code.style.file.name.relaxed.style=重用當前檔案的 case
js.code.style.file.name.camel.style=駝峰命名法 (appComponent)
js.code.style.file.name.pascal.style=帕斯卡命名法 (AppComponent)
js.code.style.file.name.snake.style=蛇形命名法 (app_component)
js.code.style.file.name.lisp.style=中線命名法 (app-component)
js.code.style.file.name.mixed.style=帶後綴的中線命名法 (my-app.component)
es6.code.style.path.mapping.always=始終
es6.code.style.path.mapping.never=從不
es6.code.style.path.mapping.different.paths=僅在指定路徑以外的檔案中
typescript.code.style.tab.name=TypeScript
jsx.code.style.attribute.default.value=為 JSX 特性添加：
jsx.code.style.attribute.default.value.braces=大括號
jsx.code.style.attribute.default.value.quotes=引號
jsx.code.style.attribute.default.value.none=無
jsx.code.style.attribute.default.value.typebased=基於類型
javascript.formatting.options.panel.naming.conventions=命名慣例
javascript.formatting.options.panel.comments=註釋
js.convert.parameters.to.object.intention.name=將參數轉換為物件
js.convert.parameters.to.object.with.interface.intention.name=將參數轉換為物件並引入接口
js.convert.parameters.to.object.non.call.usage.will.not.be.updated=不更新非調用用法
js.convert.parameters.to.object.usage.will.not.be.updated.for.contextual.type=方法實作接口方法。不會更新基方法
js.convert.parameters.to.object.usage.will.not.be.updated.for.spread=不會更新使用非終端傳播實參進行的調用
js.undefined.property.assignment.inspection.name=未定義的屬性賦值
js.undefined.property.assignment.inspection.message=類型 {1} 中未定義屬性 {0}
js.jquery.efficiency.inspection.name=可以優化 JQuery 選擇器
js.jquery.efficiency.inspection.allow.attribute.and.pseudo.selectors=允許特性和偽選擇器
js.jquery.efficiency.inspection.attribute.used.message=jQuery 特性選擇器可能低效
js.jquery.efficiency.inspection.pseudoselector.used.message=jQuery 偽選擇器可能低效
js.jquery.efficiency.inspection.duplicated.selector=重複的 jQuery 選擇器
js.accessibility.check.inspection.name=已引用無法存取的 @private 和 @protected 成員
js.convert.to.foreach.intention.name=將 'for-in' 轉換為 'forEach' 調用
js.consecutive.commas.in.array.literal.inspection.name=陣列文字中的連續逗號
js.consecutive.commas.in.array.literal.inspection.message=陣列文字中的連續逗號
js.consecutive.commas.in.array.literal.inspection.insert.undefined=插入 'undefined'
js.check.function.signature.guess.optionality=將非類型化參數視為必選
js.check.function.signature.guess.optionality.hint=如果禁用，則所有未鍵入的參數均視為可選參數
es6.redundant.await.report.for.promises=報告 promise
es6.redundant.await.report.for.promises.hint=總是報告 'return await' 為冗餘，但這會破壞 V8 的異步堆疊跟踪功能
es6.missing.await.report.for.promises=報告 return 語句中的 promise
es6.missing.await.report.for.promises.hint=在異步函數調用前插入 'await' 有助於 V8 提供異步堆疊跟踪
js.file.references.inspection.name=未解析的檔案引用
js.file.references.inspection.ignore.complex.cases=忽略複雜 case
js.inspection.es6.modules.dependencies.family.name=缺少 import 語句
js.inspection.amd.modules.dependencies.family.name=缺少 AMD 模組依賴關係
js.inspection.promise.ignored.display.name=返回 promise 的方法調用結果被忽略
js.inspection.promise.ignored.problem.descriptor=從 {0} 返回的 Promise 被忽略
js.inspection.promise.value.expected.problem.descriptor=應為值，但使用了從 {0} 返回的 Promise
js.flowjs.group.name=Flow 類型檢查器
js.flowjs.config.inspection.name=缺少 .flowconfig
js.flowjs.config.inspection.message=無關聯的 .flowconfig
js.flowjs.coverage.inspection.name=Flow 不涵蓋程式碼
js.flowjs.coverage.inspection.error.text=Flow 不涵蓋此元素
js.flowjs.config.inspection.to.project.path.name=向專案根中添加 .flowconfig
js.flowjs.config.inspection.to.module.path.name=向模組內容根中添加 .flowconfig
js.flowjs.config.inspection.to.current.path.name=向當前目錄中添加 .flowconfig
js.flowjs.annotation.inspection.name=Flow 類型檢查器
js.flowjs.flag.comment.placement.inspection.name=位置錯誤的 @flow 標記
js.flowjs.flag.comment.placement.inspection.error=Flow 標誌註釋不在檔案起始處
js.flowjs.flag.comment.placement.inspection.fix=將 Flow 標誌註釋移至檔案起始處
js.flowjs.flag.without.language.version=無 Flow 語言版本的 Flow 標誌
js.extjs.unresolved.ext.xtype.inspection.name=未解析的 Ext JS xtype
js.frameworks.sencha.xtype.not.found=找不到 xtype ''{0}'' 的 Ext JS 類
javascript.equality.comparison.with.coercion.family.name=取代但不進行類型強制
javascript.equality.comparison.with.coercion.display.name=相等運算符可能導致類型強制
javascript.equality.comparison.with.coercion.error.string=比較 #ref 可能導致意外類型強制 #loc
javascript.equality.comparison.with.coercion.fix=取代為 ''{0}''
javascript.equality.comparison.with.coercion.options.label=高亮顯示 '==' 和 '!=' 的用法：
javascript.equality.comparison.with.coercion.option.always=所有
javascript.equality.comparison.with.coercion.option.always.except.null=與 null 或 typeof 比較時除外
javascript.equality.comparison.with.coercion.option.only.suspicious=僅可疑表達式
js.strict.mode.inspection.name=使用了非嚴格模式
js.strict.mode.inspection.error={0} 不處於嚴格模式下
js.strict.mode.inspection.fix=添加“use strict”雜注
js.strict.mode.inspection.redundant.pragma=\\"use strict\\"雜注冗餘
js.strict.mode.remove.pragma=移除“use strict”雜注
js.class.member.initialization.inspection.name=在 static 初始值設定項中使用可能未分配的屬性
js.class.member.initialization.inspection.text=欄位 ''{1}'' 在 ''{0}'' 之後宣告，並且可能尚未分配
js.class.member.initialization.inspection.text.id=欄位 ''{0}'' 引用本身
js.assignment.used.as.condition.name=用作條件的賦值
js.assignment.used.as.condition.text=<code>#ref</code> 作為條件使用
js.assignment.used.as.condition.fix=將 ''='' 取代為 ''{0}''
js.missing.switch.branches.inspection.name='switch' 語句缺少分支
js.missing.switch.branches.inspection.desc=''switch'' 語句缺少 case：{0}
js.missing.switch.branches.ignore.with.default=忽略具有預設分支的 switch 語句
js.unreachable.switch.branches.inspection.name=不可到達 'switch' 語句的 'case' 分支
js.unreachable.switch.branches.inspection.desc=不可到達的 'case' 分支
js.unreachable.switch.branches.ignore.with.dynamic=不在動態類型的上下文中顯示此警告
js.unreachable.switch.branches.remove=移除不可到達的 'case' 分支
js.redundant.switch.problems.inspection.name='switch' 語句冗餘，可以取代
js.redundant.switch.problems.inspection.empty='switch' 語句為空
js.redundant.switch.problems.inspection.empty.remove=移除空的 'switch' 語句
js.redundant.switch.problems.inspection.default='switch' 語句僅包含一個 'default' 子句
js.redundant.switch.problems.inspection.default.unwrap=解開 'switch' 語句
js.redundant.switch.problems.inspection.side.effects=並提取副作用
js.redundant.switch.problems.inspection.single='switch' 語句僅包含一個非預設子句
js.redundant.switch.problems.inspection.single.replace=將 'switch' 取代為 'if'
js.switch.no.default='switch' 語句沒有 'default' 分支
js.switch.no.default.add=創建缺少的預設分支
js.variable.problems.inspection.name=宣告了變數並在不同的 'case' 子句中使用
js.variable.problems.inspection.desc=變數 ''{0}'' 在子句 ''{1}'' 中宣告， 但在子句 ''{2}'' 中使用
js.variable.problems.inspection.desc.ref.error=存取時引用錯誤
js.variable.problems.ignore.desc=對可變變數忽略
js.inspection.package.json.dependencies=package.json 中的依賴關係不符合
js.inspection.missing.amd.dependency=缺少 AMD 模組依賴關係
js.inspection.missing.import=缺少 import 語句
js.inspection.missing.module.dependency=缺少模組依賴關係
typescript.narrowed.to=範圍限縮至 ''{0}''
label.exclude.methods.classes=排除類方法:
dialog.title.add.classes=添加類
typescript.suspicious.constructor.parameter.assignment=構造函數中的參數賦值可疑。您忘了添加  'this.' 嗎？
typescript.suspicious.constructor.parameter.assignment.desc=已分配構造函數欄位參數
typescript.abstract.class.constructor.can.be.made.protected=abstract 類構造函數可以設為 protected
typescript.make.constructor.protected=將構造函數設為 protected
typescript.private.field.modifiers.mix=使用私有名稱的欄位不能具有 'public'、'private' 或 'protected' 存取修飾符
javascript.validation.message.flowjs.path=Flow 路徑不正確
javascript.validation.message.interface.members.cannot.have.access.modifiers=接口成員不能具有存取修飾符
javascript.validation.message.interface.members.cannot.have.namespace.attributes=接口成員不能具有命名空間特性
javascript.validation.message.interface.members.cannot.be.final.modifiers=接口成員不能為 final
javascript.validation.message.static.modifier.is.allowed.only.for.class.members=僅允許類成員使用 static 修飾符
javascript.validation.message.interface.cannot.be.final.modifiers=接口不能為最終
javascript.template.context.type=JavaSc&ript 和 TypeScript
interface.should.have.no.variable.declarations=接口不應有變量宣告
javascript.validation.message.implements.for.interface.not.allowed=接口不允許有實作列表
javascript.validation.message.interface.name.expected.here=此處應為接口名稱
javascript.validation.message.class.name.expected.here=此處應為類名
javascript.validation.message.circular.dependency=迴圈依賴關係
javascript.validation.message.index.no.type=索引簽名參數必須具有類型註解
javascript.validation.message.index.wrong.type=索引簽名參數類型必須可以分配給 'string | number | symbol'
javascript.fix.remove.circular.dependency=移除迴圈依賴關係
react.jsx.syntax.used.name=已使用 React JSX 語法
react.jsx.syntax.used.description=已使用 React JSX 語法
js.void.function.result.used.name=使用了 void 函數返回值
js.void.function.result.used.description=使用了 void 函數返回值

# JSDoc validation
javascript.validation.message.interface.method.not.implemented=未實作來自於接口 {1} 的方法 {0}
javascript.validation.message.abstract.method.not.implemented=未實作類 {1} 中的 abstract 方法 {0}
javascript.validation.message.abstract.get.accessor.not.implemented=未實作類 {1} 的 abstract get 存取器 {0}
javascript.validation.message.abstract.set.accessor.not.implemented=未實作類 {1} 的 abstract set 存取器 {0}
javascript.validation.message.interface.property.not.implemented=未實作接口 {1} 的屬性 {0}
javascript.validation.message.interface.get.accessor.not.implemented=未實作接口 {1} 的屬性 get 存取器 {0}
javascript.validation.message.interface.set.accessor.not.implemented=未實作接口 {1} 的屬性 set 存取器 {0}

javascript.validation.message.class.method.incompatible= ''{1}'' 類中的方法 ''{0}'' 不可分配給基類 ''{2}'' 中的同一方法
javascript.validation.message.class.property.incompatible= ''{1}'' 類中的屬性 ''{0}'' 不可分配給基類 ''{2}'' 中的同一屬性
javascript.validation.message.class.method.not.implemented=未實作類 {1} 的方法 {0}
javascript.validation.message.class.property.not.implemented=未實作類 {1} 的屬性 {0}
javascript.validation.message.interface.call.signature.not.implemented=未實作接口 {0} 的調用簽名
javascript.validation.message.interface.index.signature.not.implemented=未實作接口 {0} 的索引簽名
javascript.validation.message.class.setter.cannot.have.return.type='set' 存取器不能有返回類型
javascript.fix.remove.externally.visible.symbol=移除外部可見符號
javascript.fix.remove.abstract.keyword=移除 'abstract' 修飾符
javascript.fix.remove.modifier=移除修飾符
javascript.fix.implement.members=實作成員
javascript.fix.implement.methods=實作方法
javascript.implement.all.interfaces=實作所有成員
javascript.implement.required.interfaces=實作所需的所有成員
javascript.implement.members.abstract=實作 abstract 成員

# Symbols
javascript.parameter=參數
javascript.local.variable=局部變數
javascript.global.variable=全域變數
javascript.global.function=全域函數
javascript.local.function=局部函數
javascript.global.decorator=裝飾器
javascript.static.member.function=static 成員函數
javascript.static.member.variable=static 成員變數
javascript.instance.member.variable=實例成員變數
javascript.instance.member.function=實例成員函數
javascript.create.class.intention.name=創建類 ''{0}''
javascript.create.interface.intention.name=創建接口 ‘’{0}''
choose.class.to.import.title=要匯入的類
javascript.fix.remove.override.modifier=移除覆寫修飾符
javascript.fix.remove.virtual.modifier=移除虛擬修飾符
javascript.validation.message.attribute.was.specified.multiple.times=多次指定修飾符 {0}
javascript.fix.remove.dynamic.modifier=移除動態修飾符
javascript.validation.message.function.override.for.object.method=從 Object 繼承的方法無需覆寫
javascript.validation.message.function.override.without.parent.method=方法不覆寫超類的方法
javascript.module.name=模組名稱
javascript.exported.variable=匯出的變數
javascript.exported.function=匯出的函數
javascript.exported.class=匯出的類
javascript.fix.create.function.component.jsx.name=創建函數組件 ''{0}''
javascript.fix.create.function.component.jsx.family=創建函數組件
javascript.fix.create.class.component.jsx.name=創建類組件 ''{0}''
javascript.fix.create.class.component.jsx.family=創建類組件
typescript.module.name=模組名稱
typescript.type.alias.name=類型別名
typescript.type.guard.name=變數類型限縮為類型防護
typescript.type.guard.name.disable=禁用範圍限縮的類型的著色
typescript.primitive.types.name=基元類型
typescript.type.parameter=類型參數
typescript.remove.type.declaration=移除類型宣告

generate.constructor.overloads.and.fields.chooser.title=選擇要使用的多載和要初始化的欄位
generate.to.string.chooser.title=選擇要在 toString 函數中使用的欄位
members.to.implement.chooser.title=選擇要實作的成員
members.to.override.chooser.title=選擇要覆寫的成員
no.candidates=無候選項
no.methods.to.implement=找不到要實作的方法
no.members.to.implement=找不到要實作的成員
implement.members.abstract=實作 abstract 成員
no.methods.to.override=找不到要覆寫的方法
no.members.to.override=找不到要覆寫的成員
no.variables.for.getter=找不到沒有 getter 的欄位
no.variables.for.setter=找不到沒有 setter 的欄位
no.variables.for.getter.setter=找不到沒有 getter 和 setter 的欄位
javascript.validation.unused.import=未使用的 import
javascript.validation.fqn.to.replace.with.import=限定名稱可取代為 import 語句
javascript.fix.optimize.imports=優化 import
javascript.invalid.number.of.parameters=實參數量無效，應為 {0} 個
javascript.expression.type.implicitly.coerced.to.unrelated.type=表達式類型 {1} 隱式強制為不相關類型 {0}
javascript.argument.type.mismatch=實參類型 {1} 不可分配給參數類型 {0}
javascript.initializer.type.mismatch=初始值設定項類型 {1} 不可分配給變數類型 {0}
javascript.incorrect.variable.type.mismatch=變數類型 {1} 不可分配給類型 {0}
javascript.term.does.not.evaluate.to.function=方法表達式不是函數類型
javascript.term.does.not.evaluate.to.function.nullable=方法表達式可以為 null 或 undefined
javascript.term.does.not.evaluate.to.function2=屬性不能作為函數調用
javascript.term.does.not.evaluate.to.function.line.break=表達式不可調用。如果這不應是調用，請檢查是否缺少分號
javascript.term.does.not.evaluate.to.function2.fix=移除實參列表
javascript.term.nullable.indexer.qualifier=索引的表達式可以為 null 或 undefined
javascript.unused.import.remove=移除未使用的 'import'
javascript.unused.import.remove.specifier=移除未使用的元素
javascript.assigned.expression.type.mismatch=分配的表達式類型 {1} 不可分配給類型 {0}
javascript.vector.literal.element.type.mismatch=矢量文字元素類型 {1} 不可分配給類型 {0}
javascript.type.is.not.assignable.to.type=類型 {1} 不可分配給類型 {0}
javascript.no.call.signatures=分配的類型不包含調用簽名
javascript.known.props.only=物件文字只能指定已知屬性，但以下為額外屬性：{0}
javascript.returned.expression.type.mismatch=返回的表達式類型 {1} 不可分配給類型 {0}
javascript.insert.cast.fix=插入轉換
javascript.insert.primitive.wrapper.fix.family.name=使用基元類型包裝
javascript.insert.generic.wrapper.fix.family.name=使用泛型類型包裝
javascript.insert.wrapper.fix.text=使用 ''{0}'' 包裝
typescript.insert.cast.fix=插入類型斷言
es6.insert.await.fix=插入 await
es6.change.to.default.fix=對 ''{0}'' 使用預設匯入
es6.change.to.named.import.fix=對 ''{0}'' 使用命名匯入
typescript.insert.type.guard.fix.family=插入類型防護
typescript.insert.type.guard.surround=封閉在 ''{0}''中
typescript.insert.type.guard.prefix=前綴為 ''{0}''
typescript.insert.type.guard.postfix=使用 ''{0}'' 進行可選查詢
typescript.insert.type.guard.nc=將限定符取代為 ''{0}''
typescript.insert.type.guard.nc.self=取代為 ''{0}''
error.not.available.in.javascript.code={0} 在 JavaScript 程式碼中不可用
cannot.modify.library.code=無法修改庫或 SDK 程式碼
javascript.extract.method.title=提取函數
javascript.validation.message.function.override.incompatible.signature.generic=不相容覆寫
javascript.validation.message.function.override.incompatible.access.modifier=不相容覆寫，應有 ''{0}'' 存取修飾符
javascript.validation.message.function.override.incompatible.signature=不相容覆寫，應有簽名 ''{0}''
javascript.validation.message.function.override.incompatible.signature2=不相容覆寫，應有返回類型 ''{0}''
javascript.validation.message.function.override.incompatible.signature3=不相容覆寫，應有種類 ''{0}''
javascript.validation.message.function.method.invalid.overridden.parameter.type=不相容覆寫，應有類型 ''{0}''
javascript.validation.message.interface.method.invalid.access.modifier=不相容實作，應有 'public' 存取修飾符
javascript.validation.message.interface.method.invalid.signature=不相容實作，應有簽名 ''{0}''
javascript.validation.message.interface.method.invalid.signature2=不相容實作，應有返回類型 ''{0}''
javascript.validation.message.interface.method.invalid.signature3=不相容實作，應有 get / set ''{0}''
javascript.validation.message.duplicate.catch.block=重複 catch 塊 #loc
javascript.validation.message.duplicate.catch.block.fix=移除重複的 catch 塊
javascript.validation.message.missing.catch.or.finally=缺少 catch 或 finally 子句
javascript.validation.message.return.value.of.type.is.required=必需具備類型 {0} 的返回值
javascript.validation.message.return.statement.required=非無效返回類型必需具備 return 語句
typescript.validation.message.invalid.module.member.modifier=''{0}'' 不是模組成員的有效修飾符
javascript.validation.message.unresolved.component=未解析的組件 {0}
javascript.validation.message.super.constructor.call.should.be.in.constructor=超類構造函數調用應位於構造函數本體中
javascript.fix.remove.constructor=移除構造函數
javascript.metadata=元資料
javascript.class=類
javascript.interface=接口
javascript.label=標籤
javascript.function.arrow=箭頭函數
javascript.validation.message.unneeded.comma=不需要的逗號
javascript.validation.message.remove.unneeded.comma.fix=移除不需要的逗號
javascript.validation.message.constructor.cannot.be.static=構造函數不能為 static
javascript.create.event.handler.intention.name=創建事件處理程序 ''{0}''
javascript.validation.message.missed.super.constructor.call=缺少超類構造函數調用
javascript.validation.message.this.before.super.call=超類構造函數調用前不允許有 'this'
javascript.validation.message.baseMethod.before.super.call=超類構造函數調用前不允許有 'super'
javascript.validation.message.base.constructor.in.not.derived=僅允許在派生構造函數中調用基類構造函數
typescript.validation.message.base.constructor.must.be.first.statement=如果類包含初始化屬性或具有參數屬性，則基類構造函數調用必須為構造函數中的第一條語句
javascript.fix.create.constructor.invoke.super=創建符合 super 的構造函數
javascript.fix.create.invoke.super=插入超類構造函數調用
javascript.interface.can.not.be.instantiated.message=無法實例化接口
javascript.abstract.class.can.not.be.instantiated.message=無法實例化 abstract 類
javascript.validation.message.set.method.should.be.void.or.without.type=setter 定義的返回類型必須為未指定或無效
javascript.validation.message.set.method.should.have.one.parameter=setter 定義必須正好有一個參數
javascript.validation.message.get.method.should.have.no.parameter=getter 定義不得有參數
javascript.validation.message.get.method.should.be.valid.type=getter 定義的返回類型不應為 {0}
javascript.validation.message.use.namespace.reference.or.access.modifier=使用命名空間或存取修飾符
javascript.validation.message.one.visibility.modifier.allowed=只允許一個可見性修飾符(public、protected、internal、private)
javascript.validation.destructuring.without.initializer=析構宣告必須有初始值設定項
javascript.fix.remove.access.modifier=移除存取修飾符
javascript.fix.remove.final.modifier=移除 final 修飾符
javascript.validation.message.final.modifier.allowed.only.for.methods=final 修飾符只能應用於類和類方法
javascript.fix.remove.namespace.reference=移除命名空間引用
javascript.fix.remove.visibility.modifier=移除可見性修飾符
javascript.incorrect.array.type.in.for-in=陣列鍵類型應為字串
javascript.validation.message.unexpected.type.for.rest.parameter=Rest 參數不應有類型
typescript.validation.message.unexpected.type.for.rest.parameter=Rest 參數必須為數組類型或具有陣列約束的泛型
typescript.validation.message.unexpected.type.for.rest.parameter.fix=取代為數組類型
javascript.fix.remove.type.reference=移除類型引用
javascript.validation.message.parameter.is.not.allowed.after.rest.parameter=rest 參數後不允許有任何參數
javascript.validation.message.comma.is.not.allowed.after.rest.element=rest 元素後不允許有逗號
javascript.validation.message.comma.is.not.allowed.after.last.parameter=最後一個參數後不允許有逗號
javascript.fix.remove.comma=移除逗號
javascript.fix.remove.parameter=移除參數
javascript.fix.remove.parameters=移除參數
javascript.fix.remove.initializer=移除初始值設定項
javascript.validation.message.parameter.should.be.initialized=應初始化參數
javascript.validation.message.parameter.non.optional.after.optional=必選參數不能位於可選參數後
javascript.validation.message.parameter.rest.optional=rest 參數不能是可選參數
javascript.fix.initialize.parameter=初始化參數
javascript.validation.message.rest.parameter.should.not.be.initialized=不應初始化 Rest 參數
javascript.validation.message.nested.classes.are.not.allowed=不允許嵌套類
javascript.validation.message.implements.is.not.allowed=標準 ECMAScript 中不允許有實作子句
javascript.validation.message.arguments.with.rest.parameter=使用 rest 參數時，'arguments' 物件不可用
js.validate.types.inspection.name=類型不符合
typescript.validate.optional.parameter.inspection.error=參數不能有問號和初始值設定項
typescript.validate.optional.parameter.inspection.fix.question=移除問號
typescript.validate.generic.types.inspection.name=不正確的泛型實參
typescript.redundant.typescript.type.argument.inspection.name=冗餘類型實參
typescript.duplicate.typescript.union.inspection.name=聯合或相交類型組件重複
typescript.validate.generic.types.fix.delete=移除泛型實參
typescript.validate.generic.types.fix.add=添加泛型實參
typescript.validate.generic.types.inspection.error.argument.number=泛型類型 ''{0}'' 需要 ''{1}'' 類型實參
typescript.validate.generic.types.inspection.error.argument.number.between=泛型類型 ''{0}'' 需要介於 {1} 和 {2} 之間的類型實參
typescript.validate.generic.types.inspection.error.not.empty.argument=類型實參列表不能為空
typescript.validate.generic.types.inspection.error.not.empty.parameter=類型參數列表不能為空
typescript.validate.types.any.inspection.name='any' 類型的類型不符合
typescript.validate.template.literal.types=模板類型 {1} 不可分配給約束類型 {0}
js.incompatible.types.comparison.inspection.name=類型不相容的表達式的比較
js.incompatible.types.comparison.message=條件始終為 {0, choice,0#false|1#true}，因為類型 ''{1}'' 和 ''{2}'' 沒有重疊
javascript.validate.imports.name=未解析的已匯入名稱
es6.validate.import.error=無法解析符號 ''{0}''
es6.prefer.short.import.name=可以縮短匯入
typescript.reference.to.umd.global=已引用的 UMD 全域變數
typescript.field.can.be.made.readonly=可以為唯讀欄位
javascript.suspicious.type.guard.desc=類型防護檢查不健全
javascript.object.null.or.undefined.desc=物件為 'null' 或 'undefined'
javascript.suspicious.typeof.guard=''typeof'' 檢查無效：''{0}'' 不能具有類型 ''{1}''
javascript.redundant.typeof.guard=''typeof'' 檢查冗餘：''{0}'' 始終具有類型 ''{1}''
javascript.falsy.typeof.guard=''typeof'' 檢查始終為 false：{0}'' 始終具有類型 ''{1}''
typescript.suspicious.instanceof.guard=''instanceof'' 檢查無效：''{0}'' 的類型與 ''{1}'' 無關
typescript.redundant.instanceof.guard=''instanceof'' 檢查冗餘：''{0}'' 具有類型 ''{1}'' 或 ''{1}'' 的子類型
typescript.redundant.instanceof.inheritor.guard=''instanceof'' 檢查冗餘：''{0}'' 具有類型 ''{1}'' 或 ''{1}'' 的繼承者
javascript.object.is.null={0} 為 null
javascript.object.is.possibly.null={0} 可能為 null
javascript.object.is.undefined={0} 未定義
javascript.object.is.possibly.undefined={0} 可能為 undefined
javascript.object.is.null.or.undefined={0} 為 null 或 undefined
javascript.object.is.possibly.null.or.undefined={0} 可能為 null 或 undefined
typescript.smart.cast=範圍限縮的類型
typescript.smart.cast.hyperlink=設定字體和背景
typescript.missing.augmentation.import=缺少增強匯入
typescript.explicit.member.type.inspection.name=顯式類型
typescript.config.inspection=不一致的 Tsconfig.json 屬性
typescript.config.inspection.libs=缺少全域類別庫
typescript.config.inspection.missing.option=缺少 tsconfig.json 選項 
typescript.config.inspection.libs.fix=在 tsconfig.json 中啟用庫 ''{0}''
typescript.config.inspection.config.options.fix=向 tsconfig.json 中添加 ''{0}''
typescript.config.inspection.fix.pattern=添加 ''{0}'' 屬性
typescript.config.inspection.path.mapping.info=路徑映射需要 baseUrl 屬性
typescript.config.inspection.checkjs.info=屬性 checkJs 需要 allowJs 屬性
typescript.redundant.declaration=類型宣告與推斷的類型相符合，因此可以移除
unnecessary.parentheses.display.name=不必要的圓括號
unnecessary.parentheses.problem.descriptor=<code>#ref</code> 周圍的圓括號不必要 #loc
remove.unnecessary.parentheses.fix.text=移除不必要的圓括號
typescript.specify.type.explicitly=顯式指定類型
typescript.specify.type.explicitly.from.hint=添加顯式類型註解
typescript.specify.all.param.types.explicitly=顯式指定所有參數類型
typescript.specify.all.param.types.explicitly.from.hint=向所有參數中添加顯式類型註解
typescript.make.field.readonly=將欄位設為唯讀
es6.replace.import.action.name=取代為 {0}
es6.replace.import.family.name=取代為較短的路徑
js.validate.signature.inspection.name=簽名不符合
find.usages.of.base.interface={1} 的方法 {0}\\\\n實作 {2} 的方法。\\\\n要{3}基方法嗎?
find.usages.of.base.class={1} 的方法 {0}\\\\n覆寫 {2} 的方法。\\\\n要{3}基方法嗎?
javascript.fix.visibility.family=修復可見性問題
javascript.fix.set.element.visibility=將 {0} 設為 {1}
javascript.fix.set.method.return.type=使 ''{0}'' 返回 ''{1}''
javascript.fix.generate.argument.stubs=生成實參存根
javascript.deprecated.symbol.replace.fix=將棄用的程式碼取代為 {0}
javascript.deprecated.symbol.replace.fix.family=將棄用的程式碼取代為建議的取代
javascript.label.visibility.public=public(&B)
javascript.label.visibility.package_local=internal(&I)
javascript.label.visibility.private=private(&V)
javascript.label.visibility.protected=protected(&O)
move.members.refactoring.name=移動成員
move.members.dialog.title=移動成員
class.0.cannot.be.created=無法創建目標類 {0}，因為存在同名的限定元素
# Used in JSFormatUtil.formatVisibility
javascript.visibility.public=public
javascript.visibility.internal=internal
javascript.visibility.private=private
javascript.visibility.protected=protected
entity.in.parent.description={0} ({1} 內)
package.description=軟體套件 {0}
0.with.1.visibility.in.the.target.class.is.not.accessible.from.2=目標類中可見性為 {1} 的 {0} 無法從 {2} 存取
0.with.1.visibility.is.not.accessible.from.2=可見性為 {1} 的 {0} 將無法從 {2} 存取

# Refactoring
javascript.refactoring.variable.used.as.lvalue=要內聯的變數在賦值的左側使用
javascript.refactoring.variable.value.is.changed.when.accessed.from.closure=從閉包存取時變量值被更改
javascript.refactoring.inline.variable.title=內聯變數
javascript.refactoring.inline.function.title=內聯函數
javascript.refactoring.cannot.find.usages.of.definition.to.inline=無法找到要內聯的定義的用法.
javascript.refactoring.searching.usages=尋找用法
javascript.refactoring.cannot.inline.not.initialized.variable=無法內聯未初始化的變數
javascript.refactoring.cannot.inline.destructuring.variable.with.default=無法內聯使用預設值的析構變數
javascript.refactoring.cannot.inline.destructuring.rest.variable=無法內聯析構 rest 變數
javascript.inline.element.is.not.used={0} 從未使用
javascript.refactoring.inline.dialog.title=內聯 {0}
javascript.refactoring.inline.all.message=內聯所有引用並移除 {0} ({1}) (&A)
javascript.refactoring.inline.this.only=僅內聯此引用並保留 {0}(&K)
javascript.refactoring.cannot.inline.function.defined.in.library=無法內聯外部庫中定義的函數
javascript.refactoring.cannot.inline.function.referencing.arguments=無法內聯引用實參的函數
javascript.refactoring.cannot.inline.interface.method=無法內聯接口方法
javascript.refactoring.cannot.inline.function.referencing.rest.parameter=無法內聯函數引用的 rest 參數
javascript.refactoring.cannot.inline.overrided.or.overridden.method=無法內聯參與層次結構的方法
javascript.refactoring.cannot.inline.recursive.function=無法內聯遞歸函數
javascript.refactoring.cannot.inline.function.with.multiple.returns=無法內聯有多個退出點的函數
javascript.refactoring.cannot.inline.complex.expression.evaluation=無法內聯複雜表達式評估
javascript.refactoring.cannot.inline.constructor=無法內聯構造函數
javascript.refactoring.cannot.inline.jsx.usage=無法內聯 JSX 標籤用法
javascript.refactoring.cannot.inline.ambient.function=無法內聯沒有實作的宣告
javascript.refactoring.function.to.es6.class.command=將函數 {0} 轉換為類
js.convert.to.es6.class=轉換為類
js.convert.to.es6.class.family.name=將函數及其成員宣告轉換為類
js.move.type.to.file.family=移至名稱符合的檔案
js.create.derived.type.family=創建派生類/實作接口
js.create.derived.type.class=創建派生類
js.create.switch.cases=創建缺少的 'switch' 分支
js.create.switch.cases.fix=創建缺少的分支：{0}
js.edit.object.literal=編輯物件文字屬性的值
js.create.derived.type.interface=實作接口
js.create.derived.type.abstract.class=實作 abstract 類
js.rename.file.to.match.type.name.family=重命名檔案以符合類型名稱
js.rename.file.to.match.type.name=將檔案重命名為 {0} 以匹配 {1} 名稱
js.move.type.to.file.text=將 {0} 移至檔案 {1}
javascript.refactoring.function.to.es6.class.defineProperty.warning.text=警告：將使用“Object.defineProperty”、“Object.defineProperties”或“Object.create”創建的屬性轉換為 ES6 語法可能會影響其可枚舉性和可配置性
rename.destructuring.property.title=重命名析構屬性
rename.destructuring.property.description=析構屬性引用多個成員。應重命名相關屬性，否則可能導致程式碼不一致。
rename.type.members.title=重命名類型成員
rename.type.members.union.intersection.mapped.description=檢測到聯合、相交或映射類型用法。應重命名相關屬性，否則可能導致程式碼不一致。
rename.type.members.destructuring.description=檢測到析構屬性中的用法。應重命名相關屬性，否則可能導致程式碼不一致。
make.private=設為 private
choose.destination.scope=選擇目標範圍
list.item.function.to.be.converted.to.class=要轉換為類的函數
list.item.declarations.function.members.to.be.converted.to.class.members=要轉換為類成員的函數成員的宣告
tab.title.convert.to.class=轉換為類
tab.title.refactoring.preview=重構預覽
list.item.function.converted.to.class=轉換為類的函數
list.item.declarations.that.were.not.converted=未轉換的宣告
tab.title.refactoring.result=重構結果
extract.method.declare.static=宣告 static(&S)
extract.function.declare.functional.expression=宣告函數表達式(&F)
extract.function.return.type=返回類型(&T):
extract.function.parameters=參數
extract.function.signature.preview=簽名預覽
extract.function.function=函數
extract.function.name=名稱(&N):
extract.constant.type=類型(&T):
introduce.constant.target.class=目標類(&A):
introduce.field.type=類型(&T):
introduce.field.initialize.in=初始化位置
introduce.field.declaration=欄位宣告(&D)
introduce.field.current.method=當前方法(&M)
introduce.field.class.constructor=類構造函數(&C)
introduce.parameter.type=類型(&T):
introduce.parameter.optional=可選參數(&O)
introduce.variable.declaration=變數宣告
introduce.variable.const=const(&C)
introduce.variable.let=let(&L)
introduce.variable.var=var(&V)
introduce.variable.var.of.type=類型的變數(&T):
introduce.variable.make.constant=設為常數(&C)
custom.template.variables=自訂模板變數(&C):

# Destructuring
javascript.find.usages.destructuring.target.dialog=速記析構變數使用 {0} 初始化。\\\\n您想尋找哪些用法?
javascript.destructuring.initializer=初始值設定項 {0}
javascript.destructuring.variable.only=僅析構變數
javascript.rename.destructuring.target.dialog.title=速記析構變數使用 {0} 初始化
javascript.rename.choose.target.message=您要重命名哪一個？
javascript.rename.shorthand.target.dialog.title=速記屬性使用 {0} 初始化
javascript.rename.shorthand.property.description=屬性
javascript.rename.file.with.related.title=重命名檔案
javascript.rename.containing.file.message=是否也想將檔案及其用法重命名為 {0}?
javascript.rename.related.declaration.message=是否想將 {0} 及其用法重命名為 {1}?
dialog.message.some.usages.cannot.be.updated.properly=有些用法無法正常更新。\\\\n匯入和匯出中的用法、字串用法或動態引用無法取代為析構。
dialog.message.cannot.propagate.when.having.usages.declarations.in.different.files=用法和宣告位於不同檔案中時，無法傳播
dialog.message.write.usages.cannot.be.updated.with.destructuring=寫入用法無法通過重構進行更新
dialog.message.expression.indexed.by.non.numeric.value=表達式使用非數字值編制索引
dialog.message.incomplete.destructuring.pattern.encountered.in.code=在程式碼中遇到不完整的析構模式
dialog.message.unsupported.destructuring.container=不支持的析構容器: {0}
dialog.message.some.usages.cannot.be.updated.properly.wrong.access=有些用法無法正常更新。\\\\n無法取代不按名稱存取屬性的用法或者不按索引存取元素的用法。
dialog.message.cannot.transform.object.array.destructuring.patterns.for.same.element=無法為相同的元素轉換物件和陣列析構模式
dialog.message.transforming.multiple.nested.patterns.not.supported=陣列析構不支持轉換多個嵌套模式

javascript.refactoring.asdoc.for.abstracts=摘要的 ASDoc
0.is.not.allowed.in.interface=接口中不允許使用 {0} 
javascript.fix.remove.static.modifier=移除 static 修飾符
javascript.validation.message.override.can.be.applied.to.method=覆寫只能應用於函數宣告
javascript.validation.message.dynamic.can.be.applied.to.class=動態特性只能應用於類宣告
javascript.illegal.variable.type.void=非法變數類型：'void'
javascript.cannot.return.expression.from.function.with.void.result.type=無法從結果類型為 void 的函數返回值
javascript.cannot.return.expression.from.function.with.void.result.type.fix=移除返回值
javascript.validation.message.function.override.for.interface=對 {0} 中的方法進行了不相容的覆寫
javascript.validation.message.incompatible.override=對 {0} 中的成員進行了不相容的覆寫
class.does.not.have.inheritors.in.current.project={0} 在當前專案中沒有繼承者
javascript.kind.unknown=未知元素
js.unnecessary.semicolon.inspection.name=不必要的分號
js.unnecessary.semicolon.problem=不必要的分號 #loc
js.unnecessary.semicolon.fix.name=移除不必要的分號
javascript.refactoring.extract.function.title=提取函數
javascript.refactoring.extract.function.bad.selection=所選塊應代表一組語句或表達式
javascript.refactoring.extract.function.multiple.exit.points=所選程式碼段有多個退出點
javascript.refactoring.extract.function.yield.and.return=所選片段同時包含 yield 表達式和 return 語句
javascript.refactoring.extract.function.no.loop.for.continue=程式碼段內沒有用於 continue 語句的相應迴圈
javascript.refactoring.extract.function.no.loop.for.break=程式碼段內沒有用於 break 語句的相應迴圈
javascript.refactoring.extract.function.no.switch.for.break=程式碼段內沒有用於 break 語句的相應 'switch'
javascript.refactoring.extract.function.function.used.before.declaring=選定內容包含在宣告之前使用的函數
javascript.refactoring.extract.function.already.exists.in.this.scope=此範圍中已存在 {0}
javascript.validation.message.constructor.cannot.have.custom.visibility=構造函數應為 public 或未指定可見性
javascript.validation.message.can.not.override.final.method=無法從{0}覆寫最終方法
top.level.package=頂層軟體套件
js.comparison.with.nan.inspection.name=與 NaN 比較
js.comparison.with.nan.inspection.problem=與 NaN 的相等比較始終評估為 false
js.comparison.with.nan.inspection.problem2=與 NaN 的不等比較始終評估為 true
js.comparison.with.nan.inspection.quickfix=取代為 {0}isNaN(...)
js.constructor.returns.primitive.inspection.name=構造函數返回基元值
js.constructor.returns.primitive.inspection.problem=使用 'new' 調用時從構造函數返回的基元值將丟失
js.constructor.returns.primitive.inspection.quickfix=返回類型顯式設定為 {0}
js.comment.matches.signature.inspection.name=不符合的 JSDoc 和函數簽名
js.comment.matches.signature.inspection.problem1=JSDoc 中未描述參數 {0}
js.comment.matches.signature.inspection.problem2=JSDoc 中描述的參數 {0} 未出現在函數簽名中
js.comment.matches.signature.inspection.quickfix=更新 JSDoc 註釋

livetemplate.description.fori=創建迭代迴圈
livetemplate.description.iter=迭代 (for..of)
livetemplate.description.itera=迭代 (for await..of)
livetemplate.description.itin=迭代 (for..in)
livetemplate.description.itar=遍歷陣列元素
livetemplate.description.ritar=反序遍歷陣列元素
livetemplate.description.us=插入 'use strict' 語句
livetemplate.description.ref=插入引用路徑註釋
livetemplate.description.defi=插入 define() 表達式
livetemplate.description.flow=插入 @flow 註解
livetemplate.description.importfrom=import 語句 - 從 ''a'' 匯入 {b}
livetemplate.description.importns=import 語句 - 從 'a' 匯入 * as b
livetemplate.description.importdefault=import 語句 - 從 'a' 匯入 b
livetemplate.description.exportall=匯出語句 - 從 'a' 匯出 *
livetemplate.description.exportfrom=匯出語句 - 從 ''a'' 匯出 {b} 
livetemplate.description.exportitems=匯出語句 - export {b}
livetemplate.description.moduleexports=匯出語句 - module.exports = a
livetemplate.description.arf=使用箭頭函數環繞

livetemplate.description.console.log=console.log()
livetemplate.description.console.warn=console.warn()
livetemplate.description.console.error=console.error()
livetemplate.description.console.info=console.info()
livetemplate.description.console.trace=console.trace()
livetemplate.description.console.assert=console.assert()

postfix.template.provider.name=JavaScript 和 TypeScript
postfix.template.condition.non.void.name=非 Void
postfix.template.condition.array.name=陣列

macro.js.component.type.of=jsComponentTypeOf(Array)
macro.js.suggest.default.variable.kind=jsSuggestDefaultVariableKind(Boolean)

# Line markers
linemarker.implements.invalid=<無效>
linemarker.implements.text=實作 {1} 中的 {0}
linemarker.overrides.text=覆寫 {1} 中的 {0}
linemarker.implements.several=實作多種接口方法
linemarker.overridden=覆寫
linemarker.implemented=已實作
linemarker.overriding=覆寫
linemarker.implementing=實作
linemarker.javascript.typescript=JavaScript/TypeScript 行標記

js.validate.jsdoc.inspection.name=JSDoc 中的語法錯誤和未解析的引用
javascript.expected.class.or.descendant=應為類 {0} 或後代
javascript.qualified.class.name.expected=應為限定的類名
javascript.validation.message.unknown.metadata.annotation.used=使用了未知的元資料特性
javascript.validation.message.set.method.type.is.different.from.getter=Set 存取器方法的類型與 get 存取器類型不相容，應為 ''{0}''
javascript.validation.message.get.method.type.is.different.from.setter=Get 存取器方法的類型與 set 存取器類型不相容，應為 ''{0}''
typescript.validation.message.getter.and.setter.must.have.same.access.type=Getter 和 setter 必須具有相同的存取類型
actionscript.validation.message.set.method.access.type.is.different.from.getter=Flash 編譯器錯誤 174646：Set 存取器方法存取類型不同於 get 存取器存取類型，應為 ''{0}''
actionscript.validation.message.get.method.access.type.is.different.from.setter=Flash 編譯器錯誤 174646：Get 存取器方法存取類型不同於 set 存取器存取類型，應為 ''{0}''
javascript.validation.message.static.method.cannot.be.final=靜態方法不能為最終
javascript.assign.parameter.to.field.intention.name=分配參數 ''{0}'' 給欄位
javascript.fix.create.parameter=創建參數 ''{0}''
javascript.introduce.parameter.introduced.variable.value=值(&V):
0.is.not.a.legal.name=''{0}'' 不是合法的類名
item.already.exists={0} {1} 已存在
directory.already.contains.file=目錄 ''{0}'' 已包含檔案 ''{1}''
extract.subclass.command.name=從 {1} 提取子類 {0}
extract.interface.command.name=提取接口
extract.type.alias.command.name=提取類型別名
new.actionscript.class.dialog.title=新建 ActionScript 類
new.actionscript.interface.dialog.title=新建 ActionScript 接口
class.template.title=類
class.with.supers.template.title=包含 Super 的類
interface.template.title=接口
extract.0.turn.refs=提取 {0} 並盡量使用 (&T)
superclass.cannot.be.extracted.from.mxml.component=無法從 MXML 組件中提取超類。
superclass.cannot.be.extracted.from.type.alias=無法從類型別名中提取超類
superclass.cannot.be.extracted.from.enum=無法從枚舉中提取超類
interface.cannot.be.extracted.from.type.alias=無法從類型別名中提取接口
interface.cannot.be.extracted.from.enum=無法從枚舉中提取接口
javascript.fix.message.change.parameters.to.expected=將這些參數更改為預期參數
javascript.fix.message.change.return.type.to.expected=將返回類型更改為預期類型
js.last.comma.in.array.literal.inspection.name=陣列文字中的最後一個逗號多餘
js.last.comma.in.object.literal.inspection.name=物件文字中的最後一個逗號多餘
error.wrong.caret.position.method.name=文本游標應置於要重構的方法的名稱處。
changeSignature.vararg.not.last=Rest 參數應當為方法簽名中的最後一個參數
parameter.type.is.not.specified=參數 ''{0}'' 的類型未指定。\\\\n是否繼續？
return.type.is.not.resolved=返回類型 ''{0}'' 未解析。\\\\n是否繼續？
change.signature.column.name.initializer=初始值設定項
change.signature.column.name.default.parameter=預設參數
change.signature.column.name.call.value=調用中的值
change.signature.parameter.table.empty.message=使用  '+' 按鈕添加新參數
required.parameters.are.not.permitted.after.optional.parameters=必選參數不能位於可選參數後
javascript.fix.remove.setter.parameter.initializer=移除參數預設值
javascript.validation.message.setter.parameter.cannot.have.initializer=Setter 定義不能具有可選參數
javascript.changeSignature.no.call.value=新的必選參數 ''{0}'' 已添加。\\\\n指定要用於此方法的所有現有調用的預設值。
es6.changeSignature.no.call.value=新參數 ''{0}'' 已添加。\\\\n指定要用於此方法的所有現有調用的預設值或值。
javascript.changeSignature.call.value.not.allowed=參數 ''{0}'' 不允許使用預設值。因為沒有為前面的參數指定它。
es6.changeSignature.call.value.not.allowed=參數 ''{0}'' 不允許使用調用中的值。因為沒有為前面的參數指定它。
change.signature.usage.view.declarations.header=要重構的方法
{0}.visibility.will.break.methods.hierarchy=可見性為 {1} 的{0}無法參與層次結構
generate.delegate.method.conflict.message=無法通過不同的屬性為同名成員生成委託
generate.delegate.method.conflict.message.title=無法生成委託
invalid.return.type.expression=返回類型 ''{0}'' 無效
invalid.parameter.type.expression=參數類型 ''{0}'' 無效
type.is.not.resolved=類型 ''{0}'' 未解析。\\\\n是否繼續？
invalid.field.type.expression=無效欄位類型：''{0}''
choose.field.type=選擇欄位類型
new.field.action.text=欄位
new.field.action.description=在類中創建新字段
create.field.dialog.title=創建欄位
field.initializer.is.not.specified=未指定欄位初始值設定項
new.method.action.text=方法
new.method.action.description=在類中創建新方法
create.method.dialog.title=創建方法
create.button.text=創建(&C)
class.already.contains.method.warning=類 ''{0}''''已經 {1, choice, 1# 包含|2#繼承] 方法 ''{2}()''。\\\\n是否繼續？
class.already.contains.field.warning=類 ''{0}'' 已包含欄位 ''{1}''。\\\\n是否繼續？
declare.static=宣告 static(&S)
new.constructor.action.text=構造函數
new.constructor.action.description=創建構造函數
create.constructor.dialog.title=創建構造函數
change.method.signature.fix.text=更改 {0} 簽名
change.method.signature.and.update.delegating.call.fix.text=更改 {0} 簽名以符合 {1} 調用和更新調用
change.method.signature.and.update.delegating.call.noname.fix.text=更改簽名以符合 {0} 調用和更新調用
change.method.signature.delegating.default.text=委託
change.method.signature.fix.family.name=更改方法簽名
change.method.signature.and.update.delegating.call.fix.family.name=更改方法簽名並更新委託調用

# Settings
settings.javascript.root.configurable.name=JavaScript
settings.typescript.root.configurable.name=TypeScript
settings.javascript.linters.configurable.name=程式碼品質工具
settings.javascript.linters.autodetect.disabled=禁用 {0}(&D)
settings.javascript.linters.autodetect.configure.automatically=自動 {0} 配置 (&A)
settings.javascript.linters.autodetect.configure.automatically.help.text={0} 將使用 node_modules 目錄中的 {1} 軟體套件，還會使用與當前檔案或其任何父資料夾位於同一資料夾中的 {2} 配置檔案。
settings.javascript.linters.autodetect.configure.manually=手動 {0} 配置 (&M)
settings.javascript.linters.jshint.configurable.name=JSHint
settings.javascript.only.type.based.completion=僅基於類型補全 (&C)
settings.javascript.opt.chain.completion=為可 null 類型建議包含可選鏈接的條目(&O)
settings.javascript.overrides.completion=在覆寫補全中展開方法體
settings.javascript.var.names.completion=建議變數和參數名稱(&V)
settings.javascript.field.names.completion=為類欄位建議名稱 (&F)
settings.javascript.var.names.completion.desc=補全名稱
settings.javascript.var.names.completion.types=為建議的參數名稱添加類型註解(&T)
settings.javascript.var.names.completion.names.only=無類型
settings.javascript.var.names.completion.types.for.params=具有函數參數的類型
settings.javascript.var.names.completion.types.for.params.fields=具有參數和欄位的類型
settings.javascript.var.names.completion.types.except.fields=隨處都是類型，欄位除外
settings.javascript.var.names.completion.types.everywhere=隨處都是類型
settings.javascript.only.type.based.completion.tooltip=根據類型資訊顯示較少的補全建議。可能會顯著提高性能。
settings.javascript.lang.templates.configurable.name=模板
es6.auto.import.options.completion.add.imports=在程式碼補全時添加 ES6 匯入
es6.auto.import.options.title=TypeScript / JavaScript
typescript.auto.import.options.add.imports=自動添加 TypeScript 匯入
typescript.auto.import.options.add.imports.on.the.fly=即時明確匯入
typescript.auto.import.options.add.on.code.completion=程式碼補全
typescript.auto.import.options.show.popup=包含自動匯入工具提示
js.import.options.merge.import=合併同一模組中成員的匯入
js.import.options.use.node.resolution=在 index.js 可用時使用目錄匯入（節點樣式模組解析）
js.import.options.use.explicit.js.extension=使用檔案副檔名: 
js.add.members.to.type.desc=將成員添加到類或接口
js.add.members.to.type=將成員 {0} 添加到 ''{1}''
js.import.options.sort.members=對匯入的成員排序
js.import.options.sort.module.name=按模組對匯入排序
es6.import.options.paths=使用路徑別名：
es6.import.options.paths.help=此選項配置 import 語句中使用的路徑樣式。<br><br>選擇“始終”時，IDE 在添加匯入時始終使用來自 webpack、system.js 或 jsconfig.json 配置的別名。<br><br>選擇“僅在指定路徑之外的檔案中”時，IDE 針對為之定義了別名的檔案之間的匯入使用相對路徑。在所有其他檔案中使用路徑映射。<br><br>選擇“從不”時，則不使用別名。
typescipt.import.options.paths.help=此選項配置 import 語句中使用的路徑樣式。<br><br>選擇“始終”時，IDE 在添加匯入時始終使用從 tsconfig.json 映射的路徑。<br><br>選擇“僅在指定路徑之外的檔案中”時，IDE 針對為之定義了映射的檔案之間的匯入使用相對路徑。在所有其他檔案中使用路徑映射。<br><br>選擇“從不”時，則不使用路徑映射。
typescript.import.options.paths=使用 tsconfig.json 的路徑映射：
typescript.import.options.use.config=使用相對於 tsconfig.json 的路徑
javascript.import.options.use.resource.root=使用相對於專案、資源或源根目錄的路徑
typescript.import.options.blacklist.title=不要完全從此匯入：
js.flow.settings.executable.label=Flow 軟體套件或可執行檔案 (&F)：
js.flow.settings.executable.dialog.title=選擇 Flow 軟體套件或可執行檔案
js.flow.services.label=為之使用 Flow 伺服器：
js.flow.enable.type.checking=類型檢查
js.flow.enable.other.services=導航、程式碼補全和類型提示
js.flow.enable.flow.service.error=\\\\ 不正確的 Flow 路徑
js.flow.enable.flow.service.error.empty=Flow 可執行檔案的路徑為空
js.flow.enable.flow.service.error.on.checking=檢查 Flow 路徑時出錯：{0}
js.flow.enable.flow.service.error.message={0}。禁用所有 Flow 服務或為可執行檔案提供有效路徑。
js.flow.settings.auto.save=自動儲存所有修改的檔案
js.flow.settings.auto.save.warning=只有儲存其他所有修改過的檔案時，Flow 才會檢查當前檔案。
js.flow.settings.auto.save.warning.lsp=這樣 Flow 將始終顯示最新的錯誤狀態。
js.dialect.settings.dialog.title=JavaScript 語言版本
js.dialect.settings.caption=
js.dialect.settings.tableTitle=語言
js.dialect.settings.override.question=覆寫子目錄和檔案的語言版本？
js.dialect.settings.override.title=覆寫語言版本設定
js.dialect.settings.empty.text=使用 + 按鈕添加目錄，並選擇 JavaScript 版本
js.dialects.customized.label=根據目錄自定義
configure.code.completion.settings=配置程式碼補全設定

# Bower
settings.javascript.bower.configurable.name=Bower
bower.packages.view.dependencies=依賴項:
bower.package=Bower 軟體套件(&B):
bower.json=bower.json (&O)：
bower.correct.path=請更正 {0} 的路徑
bower.package.name=Bower 軟體套件
bower.dialog.message.specify.package=指定正確的 bower 軟體套件: 未找到 \\"{0}\\" 檔案
bower.required.version.notification.content=要查看 bower 軟體套件，您需要 bower@1.0.0 或更高版本
bower.no_description_available.text=無可用描述
dialog.message.command.timed.out=命令 ''{0}'' 超時
dialog.message.command.cancelled=命令 ''{0}'' 已取消
dialog.message.command.finished.with.exit.code=命令 ''{0}'' 已完成，退出程式碼為 {1}。Stdout:\\\\n{2}\\\\n\\\\nstderr:\\\\n{3}

# JS language version management
js.language.version.combo.es5=ECMAScript 5.1
js.language.version.combo.js185=JavaScript 1.8.5
js.language.version.combo.js185.description=已棄用特定於 Firefox 的 ECMAScript 實作。請考慮切換。
js.language.version.combo.es6=ECMAScript 6+
js.language.version.combo.es6.description=ECMAScript 2015+、一些提案和 JSX
js.language.version.combo.nashorn=Nashorn JS
js.language.version.combo.nashorn.description=Java 中的 JavaScript 實作
js.language.version.combo.flow=Flow
js.language.version.combo.flow.description=ECMAScript 6 中的 Flow 和 JSX
js.language.version.label=JavaScript 語言版本
js.switch.to.jsx.inspection.dismiss=關閉
ts.switch.to.jsx.inspection.name=更改檔案擴展名為 .tsx
javascript.change.language.level.message=更改 JavaScript 語言版本為 {0}
javascript.change.language.level.family=更改 JavaScript 語言版本

# JS library management
js.library.attach.debug=附加調試版本(&D)…
js.library.attach.release=附加發佈版本(&R)…
js.library.unresolved.url.inspection.name=HTTP 鏈接缺少本地存儲的庫
js.library.download.fix=下載庫
js.library.downloading.library=正在下載庫
js.library.documentation=文檔
js.library.configurable.name=庫
js.library.download.stubs.label=TypeScript 社區存根
js.library.successfully.downloaded=已成功下載 {0}

choose.super.method=<html><body>選擇 <b>{0}</b> 的 Super 方法（找到 {1}）</body></html>
choose.super.function=<html><body>選擇 <b>{0}</b> 的 Super 函數（找到 {1}）</body></html>
choose.super.field=<html><body>選擇 <b>{0}</b> 的 Super 欄位（找到 {1}）</body></html>
choose.super.classifier=<html><body>選擇 <b>{0}</b> 的超類或接口（找到 {1}）</body></html>
choose.subclass=<html><body>選擇 <b>{0}</b> 的子類（找到 {1}）</body></html>
choose.implementing.class=<html><body>選擇 <b>{0}</b> 的實作（找到 {1}）</body></html>
choose.overridden.method=<html><body>選擇 <b>{0}</b> 的覆寫方法（找到 {1}）</body></html>
choose.overridden.function=<html><body>選擇 <b>{0}</b> 的覆寫函數（找到 {1}）</body></html>
choose.implementing.method=<html><body>選擇 <b>{0}</b> 的實作(找到 {1} 個)</body></html>
javascript.invalid.delete.target.message=刪除運算符目標無效，應為欄位引用
javascript.with.statement.is.not.allowed.in.strict.mode.message=嚴格模式下不允許使用 With 語句
javascript.validation.message.redefining.is.not.allowed=不允許重新定義 {0}
javascript.validation.message.referencing.arguments.caller.callee.is.not.allowed=不允許從實參中引用 'caller' 和 'callee'
javascript.validation.message.referencing.function.arguments.property.is.not.allowed=不允許引用 'arguments' 函數屬性
javascript.validation.message.arguments.is.readonly='arguments' 唯讀
javascript.validation.message.eval.cannot.be.assigned=不能在嚴格模式下分配 'eval'
javascript.octal.literals.are.not.allowed.es6.message=不允許使用前綴為 '0' 的八進制文字。改用 '0o' 前綴
javascript.octal.literals.are.not.allowed.es5.message=前綴為 '0' 的八進制文字已過時，不建議使用
javascript.octal.sequences.are.not.allowed.message=不允許八進制轉義序列
javascript.invalid.extended.unicode.escape=擴展的 Unicode 轉義僅允許介於 0x0 和 0x10FFFF 之間的值
javascript.octal.literals.are.not.allowed.in.strict.mode=在嚴格模式下不允許八進制文字
javascript.octal.literals.warn.always=關於 ES5-程式碼中過時八進制文字的警告
javascript.validation.message.only.one.default.is.allowed=\\\\ switch 中只允許一個預設子句
javascript.fix.remove.default=移除預設子句
javascript.validation.message.accessor.could.not.be.nested.under.other.function=存取器方法不能嵌套在其他函數中
javascript.validation.message.es5.function.declarations.allowed.on.top.level.or.function=禁止在程序或函數的頂層使用函數語句
class.chooser.not.available.in.dumb.mode=正在進行索引更新，選擇器不可用。
choose.super.class.title=選擇超類
choose.base.component.title=選擇超類
choose.super.interface.title=選擇 Super 接口
0.is.not.accessible.from.1=無法從 {1} 存取 {0}
javascript.constructor.call.without.new.message=沒有 new 的構造函數調用
javascript.qualified.name.is.not.imported.message=未匯入限定名稱 #loc
javascript.element.is.not.accessible.message=元素不可存取 #loc
javascript.protected.member.is.not.accessible.message=protected 成員不可存取 #loc
javascript.protected.constructor.is.not.accessible.message=protected 構造函數不可存取 #loc
javascript.private.member.is.not.accessible.message=private 成員不可存取 #loc
javascript.export.only.member=元素僅匯出
javascript.private.constructor.is.not.accessible.message=private 構造函數不可存取 #loc
javascript.jsdoc.protected.member.is.not.accessible.message=protected 成員不可存取 #loc
javascript.jsdoc.private.member.is.not.accessible.message=private 成員不可存取 #loc
javascript.static.member.is.not.accessible.message=static 成員不可存取 #loc
javascript.instance.member.is.not.accessible.message=實例成員不可存取 #loc
javascript.element.need.to.be.exported=未匯出元素
javascript.element.need.to.be.imported=未匯入元素
javascript.element.default.instead.named=使用了預設匯入而不是命名匯入
javascript.element.need.to.be.included.to.config=tsconfig.json 中不包含相應檔案
javascript.argument.types.mismatch=實參類型與參數不符合
javascript.member.from.unopened.namespace.message=未打開命名空間的成員 #loc
javascript.property.is.read.only.message=唯讀屬性 #loc
javascript.property.is.write.only.message=只寫屬性 #loc
javascript.assume.uppercase.functions.to.be.constructors=假設只有大寫的函數是構造函數
javascript.not.a.constructor.call.message=不是構造函數調用
cannot.refactor.anonymous.function=現有非調用用法阻止調用站點分析。
change.signature.method.references.arguments=函數引用實參，更改簽名後代碼可能會中斷
change.signature.call.expression.contains.spreads=函數調用包含傳播實參。用法將保持不變。
change.signature.tagged.template.issue=無法更新標記的模板調用。用法將保持不變。
change.signature.conflict.incompatible.override=覆寫 {0} 的參數個數與重構 {1} 的參數個數不同。重構期間將忽略 {2}。
change.signature.conflict.incompatible.implementation=實作 {0} 的參數個數與重構 {1} 的參數個數不同。重構期間將忽略 {2}。
change.signature.conflict.eliminating.parameter.property.breaks.usages=將參數-屬性轉換為簡單的參數將中斷 {0} 的欄位用法
change.signature.conflict.readonly.parameter.property.write.usage=將 {0} 變為唯讀將中斷非讀取用法
javascript.missed.argument.for.parameter=參數 {0} 缺少實參

# Code folding settings
checkbox.collapse.object.literals=物件文字
checkbox.collapse.one.line.function.literals=JavaScript 和 TypeScript 中的單行函數
checkbox.collapse.array.literals=陣列文字
checkbox.collapse.xml.literals=XML 文字
change.signature.value.column.title=值
change.signature.column.name.optional.flag=可選
change.signature.column.name.modifier=修飾符

# Flow general
js.flow.all.servers.action.restart=重啟所有 Flow 伺服器
js.flow.has.unsaved.files=由於修改了某些檔案，因此沒有執行高亮顯示
flow.js.get.type=Flow JS:Get 類型
flow.show.error.details=顯示錯誤詳情
can.t.find.flow.executable=找不到 Flow 可執行檔案
process.terminated=進程已終止
progress.text.modifying=正在修改 {0}
progress.text.initializing.opened.files=正在初始化打開的檔案

# Code style settings
js.code.style.punctuation.tab.title=標點
space.before.name.value.separator=在屬性名稱-值分隔符 ':' 前面
space.after.name.value.separator=在屬性名稱-值分隔符 ':' 後面
space.before.function.left.parenth=在函數表達式中
actionscript.space.after.dots.in.rest.parameter=在 rest 參數中的 '...' 後面
space.after.dots.in.rest.spread=在 rest/spread 中的 '...' 後面
space.before.generator.mult=在生成器中的 '*' 前面 
space.after.generator.mult=在生成器中的 '*' 後面 
spaces.within.object.type.braces=物件文字類型大括號
space.before.type.colon=在類型引用冒號 ':' 前面
space.after.type.colon=在類型引用冒號 ':' 後面
space.before.class.lbrace=類的左大括號
space.before.class.interface.module.lbrace=類/接口/模組左大括號
spaces.within.object.literal.braces=物件文字大括號
spaces.within.import.braces=ES6 匯入/匯出大括號
spaces.within.indexer.brackets=索引存取中括號
spaces.within.array.initializer=陣列中括號
spaces.within.union.and.intersection=聯合和相交類型
spaces.within.type.assertion=類型斷言
spaces.arrow.function=箭頭函數(=>)
spaces.async.arrow.function=在異步箭頭函數中
spaces.within.interpolation.expressions=插值表達式
spaces.within.unary.additive=一元加法運算符 (+,-,++,--)
spaces.after.unary.not=在 'not' (!) 和 '!!' 後面
spaces.before.unary.not=在 'not' (!) 和 '!!' 前面
js.blank.lines.around.method=環繞方法:
js.blank.lines.around.function=Around 函數：
js.spaces.in.flow.category=在 Flow 中
js.wrap.settings.import=ES6 匯入/匯出
js.align.properties.none=不對齊
js.align.properties.on.colon=冒號上
js.align.properties.on.value=值上
js.function.call.parentheses=函數調用括號
js.function.declaration.parentheses=函數宣告括號
js.function.brace.style=在函數宣告中
js.function.expression.brace.style=在函數表達式中
js.function.parameters.wrap=函數宣告參數
js.function.call.wrap=函數調用實參
js.space.before.function.left.brace=函數左大括號
js.format.cstyle.comments=對齊多行
js.chained.call.dot.on.next.line='.' 在新行
js.generated.use.public.modifier=使用 'public' 修飾符
js.generated.use.as.cast=首選 'as' 類型轉換
js.generated.types=類型
js.generated.types.settings.link=顯式類型的程式碼樣式設定
js.generated.explicit.types=此項的首選顯式類型：
js.generated.explicit.var.types=變數和欄位
js.generated.explicit.return.types=函數宣告返回
js.generated.explicit.return.expression.types=函數表達式返回
js.trailing.comma.keep=保持
js.trailing.comma.remove=移除
js.trailing.comma.whenMultiline=多行時添加
js.extends.list.wrap=Extends 列表
js.align.multiline.extends.list=多行時對齊
js.extends.keyword.wrap=擴展關鍵字
js.wrap.settings.union.and.intersection.types=聯合和相交類型
js.code.style.object.literals.category.name=物件
js.code.style.align.caption=對齊
js.code.style.align.from.clause.caption=對齊 'from' 子句
js.wrap.settings.var.group.name=變數宣告
js.code.style.do.not.align.var.statement=不對齊
js.code.style.align.var.statements=當多行時
js.code.style.align.var.statements.and.assignments=分組時
js.code.style.array.group.name=陣列
js.array.new.line.after.left.bracket=在 '[' 後換行
js.array.new.line.before.right.bracket=將 ']' 置於新行中

js.method.can.be.static=方法可以為 'static'
js.method.can.be.static.option=僅檢查 'private' 方法
make.method.static=設為 'static'
typescript.fix.change.member.access=設為 ''{0}''
js.fix.change.member.access.to.sharp=使用 '#' 設為 private
declare.event.0=宣告事件 ''{0}''
js.variable.might.not.been.initialized=變數可能尚未初始化 #loc
js.variable.initializer.is.redundant=變數初始值設定項冗餘 #loc
js.value.assigned.is.never.used=從未使用過所賦之值 #loc
js.value.assigned.to.is.never.used=賦給 ''{0}'' 的值從未使用 #loc
javascript.fix.change.type=''{0}'' 類型更改為 ''{1}''
javascript.fix.change.parameter.type=參數 ''{0}'' 類型更改為 ''{1}''
javascript.change.jsdoc.type.family.name=更改 JSDoc 中元素的類型
change.signature.dialog.title=更改 {0} 的簽名
javascript.fix.add.enum.values=添加枚舉值
javascript.fix.add.string.enum.values=添加字串枚舉值
typescript.intention.convert.import.require=將 import require 轉換為 import from
typescript.intention.convert.import.require.text=轉換為 {0}
javascript.fix.create.implements=使 ''{0}'' 實作 ''{1}''
javascript.fix.create.inheritor.family=從 super 類型繼承
javascript.fix.implement.family=在派生類中實作
javascript.fix.implement.chooser.title=從中實作成員
javascript.fix.implement.chooser.all=所有類
javascript.fix.implement=實作 {0}
javascript.fix.create.extends=使 ''{0}'' 擴展 ''{1}''
javascript.report.unused.properties=報告未使用的屬性
javascript.report.unused.definitions=報告未使用的定義
javascript.check.global.definitions=檢查全域範圍內的賦值
javascript.strictly.check.global.vars=將未宣告的全域變數報告為錯誤
javascript.strictly.check.object.properties=將未宣告的屬性報告為錯誤
javascript.strictly.check.global.functions=將未宣告的全域函數報告為錯誤
change.signature.column.type=類型
change.signature.column.name=名稱
javascript.invalid.invoker.target=無效調用目標
js.declarations.at.scope.start.inspection='var' 未在函數開頭宣告
js.make.single.var.statement=設為單變數語句
js.declaration.is.not.at.scope.start=var 語句不在範圍開始
js.move.to.scope.start=將 var 語句移至範圍開始
js.primitive.type.wrapper.usage.inspection=使用了基元類型物件包裝器
js.replace.with.type.cast.to.primitive=取代為 {0} 的類型轉換
js.assigning.to.primitive.type.property=賦給基元的值將丟失
js.primitive.type.improper.instantiation.inspection={0} 實例化可以簡化
js.replace.with.literal=取代為 {0} 文字
non.ascii.identifiers.inspection.name=包含非 ASCII 符號的關鍵字
non.ascii.identifiers.only.ascii=僅允許 ASCII 名稱
non.ascii.identifiers.non.ascii.found=<html>名稱包含非 ASCII 符號：{0}</html>
non.ascii.identifiers.mixed.set=<html>名稱同時包含 ASCII 和非 ASCII 符號：{0}</html>

element.name.anonymous=<anonymous>
element.name.default=<預設>
duplicate.parameter.name=重複的參數名稱: {0}
rename.accessors.dialog.title=重命名欄位
rename.accessors.dialog.text=是否將屬性存取器也重命名為 ''{0}''？
insert.new.keyword.fix.name=插入新關鍵字
insert.this.keyword.fix.name=添加 this 限定符
insert.class.fix.name=添加類名限定符
replace.implements.keyword.fix.name=將 'implements' 更改為 'extends'
superclass.label.text=超類(&S):
varible.name.column.title=名稱
varible.value.column.title=值
custom.variables.step.title.label.text=模板 ''{0}'' 中的自訂變數 (&C)：
create.class.ok.button.text=創建
create.class.name.label=名稱(&N):
create.class.package.label=軟體套件:
create.class.template.label=模板(&T):
create.class.superclass.label=超類(&S):
create.class.interfaces.label=接口(&I):
action.structureview.show.object.inherited=從物件繼承

# JSHint
jshint.option.edit.dialog.title=設定 ''{0}'' 選項
jshint.clear.field.to.disable=清除要禁用的欄位
jshint.illegal.integer=非法整數
jshint.use.config.files=使用配置檔案
jshint.version.label=版本(&V):
jshint.label.bundled.suffix=(捆綁)
jshint.tree.link.set=設定
jshint.label.no.version=無版本
jshint.exception.balloon.action.retry=<a href=''{0}''>重試</a>
jshint.exception.balloon.action.configure.proxy.or.retry=<a href=''{0}''>配置 HTTP 代理</a>或<a href=''{1}''>重試</a>
filetype.jshint.config.description=JSHint 配置
filetype.jshint.config.display.name=JSHint 配置
jshint.suppress.text.suppress.for.line=禁止行
jshint.options.tree.tooltip.set.a.new.value=設定新值
jshint.config.option.default.name=預設
jshint.config.default.description=<div style=\\"padding-bottom:10px\\"><div><b>.jshintrc</b></div><div style=\\"padding-left:10px; padding-top:4px;\\">對 JavaScript 檔案進行 Linting 檢查時，IDE 會從檔案所在的資料夾開始尋找 .jshintrc，然後上行到檔案系統根目錄。</div></div><div><div><b>package.json</b></div><div style=\\"padding-left:10px; padding-top:4px;\\">將您的配置添加到專案的 package.json 檔案中的 <code>jshintConfig</code> 屬性下。</div></div>
jshint.config.option.custom.name=自訂配置檔案
jshint.config.option.custom.browser.title=選擇 JSHint 配置檔案 （*.jshintrc）
jshint.config.failed.to.read=無法讀取 JSHint 配置
jshint.config.extends.cyclically=JSHint 配置迴圈擴展
jshint.config.error.failed.to.read.property=無法從 package.json 讀取 ''{0}'' 屬性
jshint.config.error.cannot.locate.ext.config=JSHint: 無法定位擴展配置
jshint.config.error.cannot.parse.ext.config=JSHint: 無法解析擴展配置
jshint.latedef.false.text=不警告
jshint.latedef.true.text=禁止變數在未定義的情況下使用
jshint.latedef.nofunc.text=<html><body>禁止變數在未定義的情況下使用，<br>但允許函數宣告。</body></html>
jshint.unused.false.text=不檢查任何內容
jshint.unused.true.text=<html><body>檢查所有變量和參數，但允許<br>使用的參數後存在未使用參數</body></html>
jshint.unused.vars.text=檢查變數，而不是函數參數
jshint.unused.strict.text=檢查所有變量和參數
jshint.progress.title.updating.jshint=正在將 JSHint 更新到 {0}
jshint.progress.title.downloading=正在下載 {0}
jshint.progress.title=JSHint {0}
jshint.quotmark.false.text=允許兩種引號
jshint.quotmark.true.text=僅允許單引號或雙引號
jshint.quotmark.single.text=僅允許單引號
jshint.quotmark.double.text=僅允許雙引號
jshint.inspection.message.duplicate.options=重複 JSHint 選項: {0}，{1}。
jshint.inspection.message.unexpected.jshint.option.name=意外的 JSHint 選項名稱
jshint.inspection.message.unexpected.value=意外值
jshint.inspection.message.expected.values.x.or.y=預期值: {0} 或 {1}
jshint.inspection.message.expected.value=預期值: {0}
jshint.inspection.message.object.or.array.expected=應為物件或陣列
jshint.inspection.message.not.loaded=未載入 JSHint {0}
jshint.inspection.message.config.not.found=未找到 JSHint 配置
jshint.inspection.message.malformed.config=JSHint 配置格式錯誤
jshint.inspection.message.prefix=JSHint:

jshint.option.esversion.description.short=在與指定的 ECMAScript 版本不相容時發出警告
jshint.option.latedef.description.short=當變數在未定義的情況下使用時發出警告
jshint.option.unused.description.short=存在未使用的變數時發出警告
jshint.option.indent.description.short=縮排
jshint.option.quotmark.description.short=引號
jshint.option.predef.details=指定全域變數及其可分配狀態:\\\\n<pre>DISQUS:true、jQuery:false</pre>\\\\n<p/>此時，JSHint 允許您覆寫 DISQUS，但禁止覆寫 jQuery。
jshint.option.bitwise.description.short=有關使用逐位運算符的警告
jshint.option.camelcase.description.short=有關變數命名的警告
jshint.option.curly.description.short=塊省略 <code>{}</code> 時發出警告
jshint.option.enforceall.description.short=程式碼未遵守最嚴格的配置時發出警告
jshint.option.eqeqeq.description.short=有關不安全比較的警告
jshint.option.es3.description.short=有關與 ES3 規範不相容的警告
jshint.option.es5.description.short=有關與 ES5 規範不相容的警告
jshint.option.forin.description.short=有關不安全 <code>for..in</code> 的警告
jshint.option.freeze.description.short=有關覆蓋原生物件原型的警告
jshint.option.immed.description.short=有關未使用括號將函數括起來而直接調用函數的警告
jshint.option.newcap.description.short=有關使用非大寫形式的構造函數的警告
jshint.option.noarg.description.short=有關 <code>arguments.caller</code> 和 <code>.callee</code> 的警告
jshint.option.nocomma.description.short=有關使用逗號運算符的警告
jshint.option.noempty.description.short=有關空塊的警告
jshint.option.nonbsp.description.short=有關“不間斷空格”字符的警告
jshint.option.nonew.description.short=有關副作用 <code>new</code> 用法的警告
jshint.option.plusplus.description.short=有關使用一元遞增和遞減運算符的警告
jshint.option.undef.description.short=未定義變數時發出警告
jshint.option.varstmt.description.short=有關使用 VariableStatements 的警告
jshint.option.strict.description.short=程式碼未採用嚴格模式時發出警告
jshint.option.trailing.description.short=有關尾隨空格的警告
jshint.option.maxparams.description.short=函數中的最大參數數量
jshint.option.maxdepth.description.short=塊的最大深度
jshint.option.maxstatements.description.short=函數中的最大語句數量
jshint.option.maxcomplexity.description.short=程式碼中的最大迴圈復雜度
jshint.option.maxlen.description.short=行的最大長度
jshint.option.asi.description.short=禁止缺少分號的警告
jshint.option.boss.description.short=禁止有關 <code>if/for/…</code> 內部賦值的警告
jshint.option.debug.description.short=禁止有關調試模式的警告
jshint.option.elision.description.short=禁止有關 ES3 陣列省略元素的警告
jshint.option.eqnull.description.short=禁止有關 <code>== null</code> 的警告
jshint.option.esnext.description.short=EcmaScript.next
jshint.option.evil.description.short=禁止有關 <code>eval</code> 的警告
jshint.option.expr.description.short=禁止有關將表達式用作語句的警告
jshint.option.funcscope.description.short=禁止有關在已宣告塊外部使用變數的警告
jshint.option.futurehostile.description.short=有關使用在以後的 JavaScript 版本中定義的關鍵字的警告
jshint.option.gcl.description.short=將 JSHint 設為與 Google Closure Compiler 相容
jshint.option.globalstrict.description.short=禁止有關使用全域嚴格模式的警告
jshint.option.iterator.description.short=禁止有關 <code>__iterator__</code> 屬性的警告
jshint.option.lastsemic.description.short=禁止有關缺少分號的警告，但僅當單行塊中的最後一條語句省略分號時才顯示該警告
jshint.option.laxbreak.description.short=禁止有關不安全換行的警告
jshint.option.laxcomma.description.short=禁止有關編碼樣式以逗號開頭的警告
jshint.option.loopfunc.description.short=禁止有關函數在迴圈內部的警告
jshint.option.moz.description.short=檢查程式碼是否使用 Mozilla JavaScript 擴展
jshint.option.multistr.description.short=禁止有關多行字串的警告
jshint.option.notypeof.description.short=禁止有關無效 <code>typeof</code> 運算符值的警告
jshint.option.proto.description.short=禁止有關 <code>__proto__</code> 屬性的警告
jshint.option.scripturl.description.short=禁止有關使用以腳本為目標的 URL 的警告
jshint.option.smarttabs.description.short=在空格僅用於對齊時，禁止有關將制表符和空格混合使用的警告
jshint.option.shadow.description.short=禁止有關變數隱藏的警告
jshint.option.singlegroups.description.short=如果未嚴格要求使用分組運算符，禁止使用該運算符
jshint.option.sub.description.short=如果可以使用點符號表示 <code>[]</code> 符號，則禁止有關使用後者的警告
jshint.option.supernew.description.short=禁止有關“怪異”構造的警告
jshint.option.validthis.description.short=禁止有關可能違反嚴格要求的警告
jshint.option.withstmt.description.short=禁止有關使用 with 語句的警告
jshint.option.noyield.description.short=禁止在生成器函數中無 yield 語句時有關生成器函數的警告
jshint.option.browser.description.short=瀏覽器
jshint.option.devel.description.short=開發
jshint.option.nonstandard.description.short=轉義和未轉義
jshint.option.typed.description.short=輸入的陣列
jshint.option.worker.description.short=Web 工作執行緒
jshint.option.wsh.description.short=Windows Script Host
jshint.option.module.description.short=ECMAScript 6 模組
jshint.option.nomen.description.short=不允許使用 _ in 變數
jshint.option.onevar.description.short=每個函數一個變數語句
jshint.option.passfail.description.short=出現第一個錯誤時停止
jshint.option.white.description.short=不允許使用雜亂的空格
jshint.option.maxerr.description.short=最大錯誤數
jshint.option.predef.description.short=預定義(以 , 分隔)

#common linters
javascript.linter.import.error.timeout.processing.configuration.file=處理配置檔案時超時
javascript.linter.import.error.generic=套用配置檔案中的程式碼樣式規則時出錯，可能是配置檔案無效。
javascript.linter.import.error.package.not.found=無法找到 ''{0}'' 軟體套件
javascript.linter.import.error.entry.point.not.found=無法在 ''{0}'' 軟體套件中找到入口點
javascript.linter.import.error.bin.file.not.found=無法 ''{1}'' 軟體套件下找到 ''{0}''
javascript.linter.import.notification={0}：專案程式碼樣式和編輯器設定基於 ''{1}'' 更新。
javascript.linter.import.notification.edit=編輯 ''{0}''
javascript.linter.import.notification.rules.applied=套用了以下 {0}：{1}。
javascript.linter.import.notification.reset=重置
javascript.linter.import.notification.restored=預設程式碼樣式和編輯器設定已恢復
javascript.linter.import.translate.config.title=套用 ESLint 程式碼樣式規則
javascript.linter.import.translate.config.description=套用 ESLint 程式碼樣式規則
javascript.linter.import.translate.config.progress.title=套用 {0} 程式碼樣式規則
javascript.linter.import.translate.config.file.error=無法套用程式碼樣式規則
javascript.linter.import.nothing.to.import={0}：已套用所有已知規則
javascript.linter.use.severity.from.config.label=使用配置檔案中的規則嚴重性
javascript.linter.configuration.file.title=配置檔案
javascript.linter.radio.button.configuration.file=配置檔案(&C):
javascript.linter.error.empty.path=路徑為空
javascript.linter.error.no.such.file=沒有此類檔案
javascript.linter.error.specify.correct.path.to=指定 {0} 的正確路徑
javascript.linter.error.failed.to.lint=Lint {0} 失敗
javascript.linter.error.can.not.find.psi.file=無法找到 {0} 的 PSI 檔案
javascript.linter.error.can.not.find.document=無法找到 {0} 的文檔
javascript.linter.error.notification.problem.with.reformatting=重新設定 {0} 的格式時出現問題:<br/>{1}
javascript.linter.error.no.path.to.package=指定 ''{0}'' 軟體套件的路徑
javascript.linter.error.package.not.installed=安裝 ''{0}'' 軟體套件
javascript.linter.error.invalid.path.to.package=指定 ''{0}'' 軟體套件的正確路徑
dialog.message.please.specify.stylelint.package.correctly=正確指定 Stylelint 軟體套件: 找不到 Stylelint 二進制檔案
stylelint.action.fix.problems.description=通過調用 'stylelint --fix' 修正 Stylelint 問題
stylelint.action.modal.title=Stylelint 修正
stylelint.action.background.title=正在執行 stylelint --fix…

javascript.linter.action.edit.config=編輯 {0}
javascript.linter.action.edit.property=編輯 {1} 中的 {0}
javascript.linter.action.edit.settings.text={0}設定…
javascript.linter.action.fix.prompt=使用 {0} 重新格式化選定的檔案?
javascript.linter.action.fix.problems.file.text={0}：修復當前檔案
javascript.linter.action.fix.problems.name=修復 {0} 問題
javascript.linter.action.fix.problems.name.start=已開始修復 {0} 問題
javascript.linter.action.fix.problems.name.finish=已結束修復 {0} 問題
javascript.linter.configurable.config.autoSearch.title=自動搜尋 (&S)
javascript.linter.suppress.rules.for.line.family.name=對當前行禁止
javascript.linter.suppress.rule.for.line.description=禁止當前行的 ''{0}''
javascript.linter.suppress.all.rules.for.line.description=禁止當前行的所有 {0} 規則
javascript.linter.suppress.rules.for.file.family.name=對當前檔案禁止
javascript.linter.suppress.rule.for.file.description=禁止當前檔案的 ''{0}''
javascript.linter.suppress.all.rules.for.file.description=禁止當前檔案的所有 {0} 規則
javascript.linter.progress.reformatting.with=正在使用 {0} 重新格式化…

javascript.linter.intention.name.details=詳細資訊
javascript.linter.intention.family.name.show.details={0}: 顯示詳細資訊

# eslint
settings.javascript.linters.eslint.configurable.name=ESLint
eslint.configurable.eslintPackage.label=ESLint 軟體套件(&E)：
eslint.configurable.config.autoSearch.description.bodyInnerHtml=ESLint 將在要 lint 的檔案的目錄中以及連續的父目錄中尋找 .eslintrc.* 和 package.json 檔案，直至尋找到檔案系統的根目錄。<div style=\\"padding-top:8px\\">要使用 package.json，請將您的配置添加到 <code>eslintConfig</code> 屬性下。</div>
eslint.configurable.label.working.directories=工作目錄(&W):
eslint.configurable.working.dir.field.empty.text=由最近的 .eslintrc 或 .eslintignore 檢出
eslint.configurable.working.directories.comment=<html>路徑或 <a href='https://github.com/isaacs/node-glob#glob-primer'>glob 模式</a>，以分號分隔。為自動檢測留空。</html>
eslint.configurable.config.select.config.text=選擇 ESLint 配置檔案（*.eslintrc.*）
eslint.configurable.additionalRulesDir.label=其他規則目錄 (&R)：
eslint.configurable.additionalRulesDir.browseDialogTitle=選擇 ESLint 其他規則目錄
eslint.configurable.extraOptions.label=額外 eslint 選項 (&O)：
eslint.run.for.files.label=為檔案執行(&F):
eslint.files.pattern.comment=<html>使用 <a href=''https://github.com/isaacs/node-glob#glob-primer''>glob 模式</a>，例如，<code>{**/*,*}.{js,ts}</code></html>
eslint.run.on.save=儲存時執行 eslint --fix(&U)
eslint.action.fix.problems.description=通過調用 'eslint --fix' 修正 ESLint 問題
eslint.fix.problems.text.with.error.code={0}: 修復 ''{1}''
eslint.fix.problems.text.current={0}: 修復當前錯誤
eslint.fix.problems.family.name={0}: 修復當前錯誤
eslint.error.package.directory.expected=應為軟體套件目錄
eslint.code.style.apply.message=套用 ESLint 的程式碼樣式?
eslint.code.style.dismiss.text=否
eslint.code.style.apply.text=是
eslint.version.0.is.not.supported.please.upgrade.eslint=ESLint 版本 {0} 不受支援。請升級 ESLint。
eslint.additional.rules.directory.field.name=其他規則目錄
eslint.configuration.file.field.name=ESLint 配置檔案
eslint.inspections.error.can.not.parse.message=無法解析訊息，應為 JSON 物件，但實際為: {0}
eslint.inspections.error.messages.not.array=訊息不是陣列: {0}
eslint.inspections.error.unexpected.language.service.response=意外的語言服務響應: {0}
eslint.inspections.error.unknown.message.severity=未知的訊息嚴重程度: {0}\\\\n主體:\\\\n{1}

#standardJS
standardjs.name=標準程式碼樣式
standardjs.editor.notification.can.be.enabled.text=為此專案使用 JavaScript 標準程式碼樣式？
standardjs.editor.notification.action=是
standardjs.editor.notification.do.not.show.text=否
standardjs.edit.settings.caption=ESlint/標準程式碼樣式
standardjs.action.fix.problems.description=修正標準程式碼樣式問題
standardjs.error.unsupported.package=不支持的軟體套件版本。請將 ''Standard'' 軟體套件升級到最低版本 {0}。
standardjs.codestyle.updated={0}: 專案程式碼樣式設定已更新
standardjs.codestyle.updated.config.section={0}: 專案程式碼樣式設定已根據 package.json 中的 ''standard'' 部分更新
standardjs.codestyle.updated.dependency={0}: 專案程式碼樣式設定已根據 package.json 中的 ''standard'' 依賴項更新

# Actions
js.show.type.info.action.error=找不到表達式
javascript.ignore.unused.function.parameters=忽略未使用的參數:
javascript.ignore.unused.catch.parameters=忽略未使用的 catch 參數
complete.import.binding=完整的匯入綁定
complete.import.name=完整的匯入名稱
remove.type.prefix=移除類型前綴
add.import.binding.to.import=將匯入綁定添加到匯入
add.import.specifier.to.import=將匯入說明符添加到匯入
create.js.file.description=從指定的模板創建 JavaScript 檔案
create.ts.file.description=創建新的 TypeScript 檔案
create.file.name=創建檔案 ''{0}''
create.file.name.with=使用 {1} 創建檔案 ''{0}''
create.file.name.with.and=使用 {1} 和 {2} 創建檔案 ''{0}''
class.names={0,choice,1#類|2#類} {1}
function.names={1}{0,choice,1#函數|2#函數} 

# todo remove, has external usages
javascript.completion.several.definitions=（多個定義）

# File watchers
js.file.watcher.6to5.description=使用 Babel 將 ECMAScript 6 程式碼轉成 ECMAScript 5
editor.notification.label.enable.babel.file.watcher.question=是否啟用 File Watcher 以使用 Babel 將 ECMAScript 6 轉換為 ECMAScript 5?

# Annotator
typescript.export.assignment.cannot.be.used.in.internal.modules=匯出不能在內部模組中使用的賦值
typescript.type.predicate.not.return=僅函數和方法的返回類型位置允許類型謂詞
typescript.type.this.predicate.not.return=僅類或接口成員、get 存取器或函數和方法的返回類型位置允許基於 'this' 類型的謂詞。
typescript.type.predicate.not.match.name=找不到參數 {0}
typescript.type.predicate.rest=類型謂詞不能引用 rest 參數
typescript.type.predicate.destructuring=類型謂詞不能引用綁定模式中的元素。
typescript.type.predicate.incompatible.types=類型謂詞不可分配給 {0}
typescript.generics.should.not.be=類型 ''{0}'' 非泛型
es6.default.export.not.declared=未在匯入的模組中宣告預設匯出
js.annotator.assignment.pattern.rhs=賦值模式必須位於賦值的左側
es6.generate.index.action=生成 index.js/index.ts
es6.generate.index.action.description=生成 index.js/index.ts
js.annotator.thin.arrow.used=使用了細箭頭
js.annotator.newline.before.arrow=箭頭前不允許換行符
js.annotator.replace.with.fat.arrow=取代為粗箭頭
js.annotator.unary.operator.within.exponential=一元運算符 ''{0}'' 不允許直接位於指數表達式之前。建議添加括號以解決歧義問題。

# Live templates
jsx.html.context.type=JSX HTML
js.expression.context.type=表達式
js.statement.context.type=語句
js.top.level.statement.context.type=頂級語句
js.class.context.type=類/接口
ecmascript.6.or.higher=ECMAScript 6 或更高版本

# Gulp
gulp.rc.gulpfile.label=Gulpfile (&F)：
gulp.rc.gulpfile.browseDialogTitle=選擇 gulpfile.js
gulp.rc.tasks.label=任務(&T):
gulp.rc.arguments.label=參數 (&R)：
gulp.rc.nodeInterpreter.label=節點解釋器(&I):
gulp.rc.nodeOptions.label=節點選項(&O):
gulp.rc.gulpPackage.label=Gulp 軟體套件(&G)：
gulp.rc.environmentVariables.label=環境(&E):
gulp.task.title=Gulp 任務
gulp.before.run.task=執行 gulp 任務
gulp.before.run.task.descr=執行 gulp {0, choice,0#任務|1#任務 |2#任務 }{1} [{2}]
gulp.gulpfile.unspecified=未指定 Gulpfile
gulp.gulpfile.not.found=未找到 Gulpfile

# Grunt
grunt.rc.gruntfile.label=Gruntfile (&F)：
grunt.rc.gruntfile.browseDialogTitle=選擇 Gruntfile
grunt.rc.tasks.label=任務(&T):
grunt.rc.arguments.label=參數 (&R)：
grunt.rc.nodeInterpreter.label=節點解釋器(&I):
grunt.rc.nodeOptions.label=節點選項(&O):
grunt.rc.gruntCliPackage.label=軟體套件 grunt-cli (&P)：
grunt.rc.environmentVariables.label=環境(&E):
grunt.task.title=Grunt 任務
grunt.before.run.task=執行 Grunt 任務
grunt.before.run.task.descr=執行 Grunt {0, choice,0#任務|1#任務 |2#任務 }{1} [{2}]
grunt.unspecified.gruntfile=未指定 Gruntfile
grunt.gruntfile.not.found=未找到 Gruntfile

#node
settings.nodejs.name=Node.js
settings.nodejs.coding.assistance.label=Node.js 編碼協助 (&A)：
settings.nodejs.coding.assistance.manage.scopes.label=管理範圍…

node.interpreter.label=Node 解釋器(&I):
node.interpreter.unspecified.error.text=指定 Node.js 解釋器
node.package.manager.label=軟體套件管理器 (&M)：
node.package.empty.hint={0} 軟體套件目錄路徑
node.package.empty.hint.pkg1.or.pkg2={0} 或 {1}
node.package.selector.single.package.title=選擇 {0} 軟體套件目錄
node.package.selector.multiple.packages.title=選擇軟體套件目錄
node.package.selector.multiple.packages.description=選擇 {0}
node.package.none=無軟體套件
node.package.dropDownList.select=選擇…

node.js.modules.dependencies.missing.family.name=缺少 require() 調用
inspection.NodeCoreCodingAssistanceInspection.no.coding.assistance.message=Node.js 的編碼輔助已禁用
action.ToggleNodeCoreCodingAssistanceAction.toggle.coding.assistance.for.node.js.text=切換 Node.js 的編碼輔助

# npm
npm.rc.packageJson.label=package.json (&P)：
npm.rc.packageJson.browseDialogTitle=選擇 package.json 檔案
npm.rc.command.label=命令(&C):
npm.rc.scripts.label=腳本 (&T)：
npm.rc.scriptsArguments.label=參數 (&R)：
npm.rc.nodeInterpreter.label=節點解釋器(&I):
npm.rc.nodeOptions.label=節點選項 (&O)：
npm.rc.environmentVariables.label=環境:
npm.task.title=NPM 腳本
npm.before.run.task=執行 npm 腳本
npm.before.run.task.descr=執行 npm {0, choice,0#腳本|1#腳本|2#腳本}{1} [{2}]
npm.dialog.message.cannot.resolve.package.manager=無法解析 ''{0}'' 軟體套件管理器
npm.no.scripts.found=未找到腳本
dialog.message.unspecified.package=未指定 {0} 軟體套件
dialog.message.invalid.package.file.specified.but.directory.with.package.json.expected={0} 軟體套件無效: 指定了一個檔案，但應為包含 package.json 的目錄
dialog.message.invalid.package.no.such.directory=無效的 {0} 軟體套件: 無此類目錄
dialog.message.invalid.npx.command=無效的 npx 命令
dialog.message.package.yarn.installed.package.format.yarn.relative.path.to.package.json.package.name={0}軟體套件: Yarn 安裝的軟體套件格式為 ''yarn:[package.json 的相對路徑]:[軟體套件名稱]''。
dialog.message.no.path.to.package.json.found=未找到 package.json 的路徑。
dialog.message.unspecified.package.name=未指定軟體套件名稱。
dialog.message.invalid.package.no.such.file=無效的 {0} 軟體套件: 無此類檔案
enable.notifications.about.installing.dependencies.from.package.json=啟用有關從 package.json 安裝依賴項的通知
notification.content.notifications.are.enabled.for.current.package.json=為當前 package.json 啟用通知
notification.content.notifications.are.enabled.for.all.package.json.files=為所有 package.json 檔案啟用通知
dialog.message.please.specify.npm.or.yarn.package.cannot.find.inside.directory=請指定 npm 或 yarn 軟體套件: 在“{1}”中找不到“{0}”
dialog.message.please.correct.path.to.npm.or.yarn.package.no.such.directory=請更正 npm 或 yarn 軟體套件的路徑: 無此類目錄“{0}”

# Build tools
buildTools.JsbtRunTaskAction.text=執行 Gulp/Grunt/npm 任務
buildTools.JsbtAddBuildfileAction.text=添加 {0}
buildTools.choose_buildfile.text=選擇 {0}
buildTools.JsbtRemoveBuildfileAction.text=移除 {0}
buildTools.JsbtReloadTasksAction.text=重新載入任務
buildTools.JsbtReloadTasksAction.npm.text=重新載入腳本
buildTools.JsbtShowTasksAction.text=顯示 {0} 任務
buildTools.JsbtShowTasksAction.npm.text=顯示 npm 腳本
buildTools.searchEverywhere.text=執行 ''{0}'' 任務
buildTools.searchEverywhere.npm.text=執行 ''{0}'' npm 腳本
buildTools.ShowSettingsAction.text={0}設定…
buildTools.ShowSettingsAction.npm.text=編輯 npm 配置(&E)…
buildTools.EditRunSettingsAction.text=編輯 ''{0}'' 設定(&E)…
buildTools.tree.sortBy.text=排序方式
buildTools.tree.sortBy.definitionOrder.text=定義順序
buildTools.tree.sortBy.name.text=名稱
buildTools.no.tasks.found=未找到任務
buildTools.edit.run.configuration=編輯執行配置
buildTools.no.files.added=未添加檔案
buildTools.add.with=使用 {1} 添加 {0}
buildTools.no.such.file=沒有此類檔案
buildTools.failed.to.list.tasks=無法列出任務
buildTools.failed.to.list.tasks.details.reference=詳細資訊
buildTools.tooltip.click.to.show.error.details=點擊以顯示錯誤詳細資訊

#npm modules
npm.modules.inspection.content.of.require.not.in.dependencies.warning=package.json 依賴關係中未列出模組
npm.modules.inspection.content.of.require.module.not.installed.warning=未安裝模組
npm.modules.install.global.types.fix.name=安裝 TypeScript 定義以提供更好的類型資訊
package.json.install.types.fix.family.name=為軟體套件安裝 @types
node.js.quickfix.install.node.module.with.dev.dependencies.text=安裝 ''{0}'' 作為開發依賴關係
node.js.quickfix.install.node.module.text=安裝 ‘’{0}''
node.js.quickfix.install.node.module.family.name=安裝模組
node.js.quickfix.install.node.module.devDependencies.family.name=安裝模組作為開發依賴關係
node.js.quickfix.install.node.module.update.modules.family.name=執行 'npm install'
node.js.quickfix.run.command=執行 ''{0}''
node.js.quickfix.install.node.module.error.prefix.text=無法安裝 Node.js 模組：{0}
node.js.quickfix.install.node.module.error.no.interpreter.text=無法安裝 Node.js 模組：請指定預設 Node.js 解釋器。
node.js.quickfix.install.node.module.error.no.interpreter.title=安裝 Node.js 模組
node.js.select.file=選擇 {0} 檔案
dialog.message.cannot.determine.package.json.directory=無法確定 package.json 目錄
action.InstallNodeLocalDependencies.text=安裝 Node.js 依賴項
action.InstallNodeLocalDependencies$Root.text=為 {1} 執行 ''{0}''

typescript.types.module.not.installed.warning=無法解析模組 ''{0}'' 的定義
npm.modules.install.global.types.directory.error=無法創建所需的目錄
npm.modules.install.global.types.dialog.title=安裝 TypeScript 定義

typescript.types.union=聯合
typescript.types.intersection=相交
typescript.types.mapped=映射
typescript.types.key=鍵引用
typescript.types.merged=已合併
typescript.types.merged.accessor=合併存取器
typescript.types.type.member={0} 類型屬性
typescript.types.merged.parts=引用的屬性：

# Intentions
ts.generate.reference.path.name=生成引用路徑註釋
ts.add.import.statement.family.name=添加 import 語句
ts.add.import.statement.dialog.title=添加 import 語句
ts.add.import.all.family.name=添加所有明確的匯入
ts.add.import.hint.text=使用 {1} 添加 {0}
ts.add.import.hint.multiple.text=使用  {1} 為 {0} 添加匯入
ts.add.import.hint.all.part=或全部使用 {0} 匯入
ts.change.import.action.one.title=更改為 {0}
ts.change.import.action.many.title=更改匯入…
ts.change.import.action.command=更改匯入
ts.change.import.action.family.name=更改 ES6 匯入路徑
ts.change.import.action.dialog.title=匯入自…
ts.convert.alias.to.interface.action.title=將別名轉換為接口
ts.convert.alias.to.interface.action.family.name=將類型別名轉換為接口
ts.convert.alias.to.enum.action.title=將別名轉換為枚舉
ts.convert.alias.to.enum.action.family.name=將類型別名轉換為枚舉
ts.convert.parameter.property.to.field=將參數屬性轉換為欄位
ts.convert.field.to.parameter.property=將欄位轉換為參數屬性
anonymous.to.named.intention.function.name=函數名稱：
initialize.fields.intention.visibility=可見性:
command.name.import=匯入 {0}
please.specify.package.manager=指定<a href=\\"\\">軟體套件管理器</a>。
intention.name.add.file.to.tsconfig=將檔案 ''{0}'' 添加到 tsconfig.json
intention.name.import.augmentation=匯入增強 {0}

# Language Service
javascript.language.service.default.empty.text=無錯誤
javascript.language.service.tracking.disabled=錯誤跟踪已禁用
javascript.language.service.tracking.is.not.started=服務未啟動
javascript.language.service.default.project.errors=顯示專案錯誤
javascript.service.node.error=節點解釋器路徑不正確。請檢查解釋器設定
javascript.starting.service=啟動 {0} 服務
javascript.language.service.cannot.get.results=無法從語言服務獲得結果
javascript.language.service.start.timeout=啟動語言服務進程超時
javascript.language.service.cannot.start=無法啟動語言服務進程
cannot.parse.service.initialization.answer.0=無法解析服務初始化回復 {0}\\\\n
tab.title.errors=錯誤
tab.title.project.errors=專案錯誤
tab.title.compile.errors=編譯錯誤
dialog.message.no.results.for.after={1} 之後沒有 {0} 的結果
intention.name.loading.service.fixes=正在載入服務修正…

# TypeScript Compiler
typescript.compiler.notification.editor.configure=配置 TypeScript…
typescript.compiler.configurable.name=TypeScript
typescript.use.service.configurable.options.enable=TypeScript 語言服務
typescript.compiler.configurable.options.output.path=使用輸出路徑：
typescript.compiler.configurable.options.compile.main=僅編譯主檔案：
typescript.compiler.configurable.options.compile.main.error=主檔案的路徑不正確
typescript.compiler.configurable.options.version=TypeScript:
typescript.compiler.configurable.options.generate.source.map=生成源映射
typescript.compiler.configurable.options.enable.no.config=也針對沒有 tsconfig.json 的專案
typescript.compiler.configurable.options.track.file.system=在更改時重新編譯
typescript.compiler.configurable.options.scope=編譯範圍：
typescript.compiler.configurable.options.command.line=選項:
dialog.message.cannot.compile.typescript.config.file.incorrect=無法編譯 TypeScript。配置檔案不正確。
intention.family.name.suppress.with.ts.ignore=使用 @ts-ignore 禁止
typescript.compiler.structure.tab.title=結構
typescript.compiler.starting=TypeScript 正在啟動…

typescript.service.no.config=檔案未包括在任何 tsconfig.json 中
typescript.service.no.main.reference=檔案未處理，因為沒有從主檔案引用


js.tool.window.limit=顯示前 {0} 個錯誤。
js.tool.window.limit.all=查看所有 {0} 個錯誤
typescript.compiler.action.compile.all=全部編譯
typescript.compiler.action.compile.toolbar=編譯
typescript.compiler.action.compile.all.description=編譯所有專案檔案
typescript.service.action.restart=重啟{0}
typescript.compiler.action.compile.all.compile.config=配置 {0} 的編譯檔案
typescript.compiler.action.compile.current=編譯當前檔案
typescript.compiler.action.compile.simple=編譯 TypeScript
typescript.compiler.action.compile.description=編譯當前專案
typescript.compiler.action.no.compile.message=檔案未編譯，因為沒有從主檔案引用
typescript.compiler.before.run=編譯 TypeScript

typescript.language.service.clean=正在重置快取…
typescript.language.service.compile.file=正在編譯檔案... {0}
typescript.language.service.compile.project=正在編譯專案… {0}
typescript.language.service.compile.file.errors=正在計算錯誤... {0}
typescript.language.service.compile.project.errors=正在計算專案錯誤... {0}
typescript.language.service.compile.project.open.file=正在打開檔案... {0}

typescript.before.task.check.errors=檢查錯誤
typescript.before.task.config.path=配置檔案：
typescript.before.task.title=TypeScript 編譯設定
typescript.before.task.config.dialog.title=選擇 tsconfig.json

# Documentation
js.documentation.fires=觸發：
js.documentation.more.overload=其他 {0} 個多載
js.documentation.more.overloads=其他 {0} 個多載

node.js.remote.interpreters.plugin.missing=缺少 Node.js 遠端解釋器套件。請啟用 {0} 中的套件

# Module Dependencies
javascript.module.dependencies.got.it.title=模組依賴關係圖
javascript.module.dependencies.got.it.text=<div align='left'>此圖顯示所選檔案或目錄具有的模組依賴關係。<br/>要查看多個檔案或目錄的依賴關係，請在<i>專案檢視</i><br/>中將其選定，然後從所選專案右鍵選單中選擇<i>圖 – 顯示圖</i>。</div>
javascript.module.dependencies.empty.got.it.text=<div align='left'>當前檔案或資料夾沒有任何依賴關係。<br/>請嘗試使用其他檔案或資料夾。</div>
modules.selected=選定

js.remove.redundant.initializer.fix=移除冗餘的初始值設定項
js.remove.unused.assignment=移除未使用的賦值
js.inject.with.comment.intention.family.name=使用註釋對注射做出註解
js.inject.dont.format.intention.text=禁用注入內容的格式設定

js.webpack.config.highlighting.name=Webpack 配置符合 JSON 架構

js.linter.guesser.linter.enabled.because.of.dependency=已啟用 {0}：''{1}'' 列出在 package.json 中。
js.linter.guesser.linter.enabled.because.of.package.json.section=已啟用 {0}：''{1}'' 位於 package.json 中。
js.linter.guesser.linter.enabled.because.of.config.file=已啟用 {0}：配置檔案位於專案中。
js.linter.guesser.linter.disabled={0} 已禁用。

# Breadcrumbs
js.breadcrumbs.callback.for=\\\\ {0}() 回調

typescript.extract.type.alias.name=類型別名…
typescript.include.js.sources.element=搜尋 JavaScript 宣告
typescript.include.js.sources.dialog.title=包括軟體套件 {0}
typescript.include.js.sources.dialog.message=是否在此專案中包含 ''{0}'' 中的 JavaScript 檔案?
start.template.string.interpolation.on.typing=鍵入 '$' 時啟動模板字串插值
typescript.include.js.sources.action=包括 JavaScript 檔案
escape.pasted.text=在貼上字串文字時轉義文本
jsx.convert.html.attributes.to.jsx=將 HTML 貼上到 JSX 檔案時轉換特性

# Rename member
rename.prompt.do.you.want.to.rename.base.method=要重命名基方法嗎?
js.rename.base.member=重命名基{0}
js.rename.current.member=重命名當前 {0}
js.rename.member.title={0} {1} {3} 的 {2}
js.rename.member.title.implements=實作
js.rename.member.title.overrides=覆寫

# Generate dialog
generate.filter.indexers=索引器
generate.filter.methods=方法
generate.filter.fields=欄位和屬性
generate.filter.button.tooltip=顯示 {0}
generate.filter.button.description=在列表中顯示 {0} 
codestyle.ui.field.prefix=欄位前綴 (&F)：
codestyle.ui.property.prefix=屬性前綴 (&P)：
codestyle.ui.file.name.style=檔案命名慣例 (&N)：
codestyle.ui.generated.jsdoc.use.types.checkbox=在 JSDoc 中包括類型 (&T)
inline.type.used.in.reference.list=無法在''{0}'' 列表中內聯用法
inline.cannot.inline.references.this.type=無法內聯引用 'this' 類型的接口
inline.cannot.inline.has.supers=無法內聯擴展其他類型的 {0} 
generation.bindable.event=可綁定事件(&B):
generation.event.constant=事件常數(&E):

refactoring.extract.react.component.component.for.refactor.this=提取組件…
refactoring.extract.react.component.title=提取組件
refactoring.extract.react.component.no.expression=所選內容不構成 JSX 表達式
refactoring.extract.react.component.no.scope=找不到用於放置所創建組件的範圍
refactoring.create.react.component.title=創建組件
refactoring.react.function.to.class.refactoring.title=轉換為類組件
refactoring.react.function.to.class.intention.title=轉換為類組件
refactoring.react.function.to.class.used.in.new.conflict=\\\\ ''new'' 表達式中使用了 {0}
refactoring.react.function.to.class.used.in.call.conflict=調用表達式中使用了 {0}
refactoring.react.class.to.function.conflict.used.with.ref={0} 與 ''ref'' 特性結合使用。無法為無狀態函數組件提供 ref
refactoring.react.class.to.function.refactoring.title=轉換為函數組件
refactoring.react.class.to.function.intention.title=轉換為函數組件
refactoring.react.could.not.find.in.template=無法重構。找不到名稱為 {0} 的元素。可能的程式碼模板 {1} 無效嗎？
react.function.to.class.caret.at.function=文本游標應置於要轉換的函數處
react.class.to.function.caret.at.class=文本游標應置於要轉換的類處
react.class.component.type.class=類
react.class.component.type.function=函數

js.arrangement.group.arrow.fields.with.methods=使用包含方法的箭頭函數初始化組欄位
intellilang.tagged.literal.injection.name.label=模式:
intellilang.tagged.literal.expression.border.title=模板標籤

refactoring.destructuring.vars.for.refactor.this=物件或陣列析構…
refactoring.destructuring.vars.intention.name=引入物件或陣列析構
refactoring.destructuring.vars.intention.name.object=引入物件析構
refactoring.destructuring.vars.intention.name.array=引入陣列析構
refactoring.destructuring.vars.intention.replace.object=取代為物件析構
refactoring.destructuring.vars.intention.replace.array=取代為數組析構
refactoring.destructuring.vars.intention.replace.promise=取代為 'await Promise.all'
refactoring.destructuring.vars.intention.propagate=傳播到析構宣告
refactoring.destructuring.vars.intention.depropagate=將析構取代為屬性和索引存取
refactoring.destructuring.vars.intention.deconstruct=生成析構模式
refactoring.destructuring.vars.intention.replace.shorthand=取代為析構和速記屬性
refactoring.destructuring.vars.intention.const.to.var.warning=在轉換期間，高亮顯示的 const 變數將轉換為 let 變數。\\\\n要繼續嗎？
refactoring.destructuring.vars.intention.const.to.var.warning.title=變數關鍵字更改
refactoring.destructuring.vars.intention.guard.conflict=通過類型防護將表達式類型限縮為 ''{0}''，該類型防護在重構後將不起作用
javascript.intention.add.export.family.name=添加匯出
javascript.intention.add.export.fix.text=將 {0} 匯出在檔案 {1} 中
javascript.intention.add.default.export.family.name=添加預設匯出
javascript.intention.remove.export.family.name=移除匯出
javascript.intention.remove.export.inaccessible.conflict.text={0} 在 {1} 中進行了使用
javascript.intention.promise.to.async.name=轉換為異步功能
javascript.intention.code.optimizations.text=正在優化生成的程式碼
javascript.intention.add.template.argument=插入模板字串實參
javascript.intention.call.chain.to.pipe=將嵌套調用取代為管道表達式
javascript.intention.pipe.to.call.chain=將管道表達式取代為嵌套調用
javascript.intention.opt.chain.family=使用可選鏈接或空值合併
javascript.intention.opt.chain.chain.only=使用可選鏈接
javascript.intention.opt.chain.coalesce.only=使用空值合併
javascript.intention.opt.chain.conditional.only=使用 '||'
javascript.intention.opt.chain.chain.and.coalesce=使用可選鏈接和空值合併
javascript.intention.expand.opt.chain.family=將可選鏈接或空值合併擴展到顯式檢查
javascript.intention.expand.opt.chain=展開可選鏈接
javascript.intention.expand.nullish.coalescing=展開空值合併
javascript.intention.expand.or.coalescing=使用 ?: 運算符
javascript.intention.expand.opt.chain.and.nullish.coalescing=展開可選鏈接和空值合併
javascript.intention.expand.opt.chain.and.or.coalescing=展開可選鏈接並使用 ?: 運算符
javascript.intention.explicit.fields=宣告顯式類欄位
javascript.intention.explicit.fields.single=宣告顯式類欄位
javascript.intention.explicit.fields.dialog.title=選擇要顯式宣告的欄位
javascript.intention.init.fields=從參數初始化新字段
javascript.intention.init.fields.dialog.title=選擇參數以初始化欄位

js.param.hints.show.names.for.all.args=Non-literal arguments
js.param.hints.show.names.for.tagged=對於標記的模板實參
js.param.hints.show.names.for.pipes=對於管道運算符
js.param.hints.blacklist.pattern.explanation=要禁用方法或函數提示，請使用下面的其中一種模式: <p style=\\"margin-left: 5px\\"><code><b>(*info)</b></code> - 所有參數名稱以 <em>info</em> 結尾的單參數方法<br><code><b>(key, value)</b></code> - 所有包含參數<em>鍵</em>和<em>值</em>的方法<br><code><b>*.put(key, value)</b></code>- 所有包含<em>鍵</em>和<em>值</em>參數的 <em>put</em> 方法<br><code><b>Console.log(*, *)</b></code> - 正好包含兩個參數的 <em>Console</em> 類型的 <em>log</em> 方法</p><br><p>必須為所有參數(包括可選參數)提供名稱或佔位符。<br>限定方法名稱必須包含類或接口名稱或佔位符。<br>在編輯程式碼時，請使用“不為當前方法顯示提示”{0} 操作來添加模式。</p>

js.checkbox.make.readonly=設為唯讀(&R)

action.JavaScriptGenerateDictionaries.text=生成 JavaScript 拼寫檢查器字典
action.ReactClassToFunctionComponentAction.description=轉換為函數組件
action.ReactFunctionToClassComponentAction.description=轉換為類組件
action.ReactExtractComponentAction.description=提取組件
action.EslintImportCodeStyle.description=套用 ESLint 程式碼樣式
action.TypeScriptExtractTypeAlias.description=提取類型別名
action.JS.TypeScript.Include.Generated.Declarations.text=包括 '.d.ts' 子檔案
action.JS.TypeScript.Include.Generated.Declarations.description=在專案中包含 .d.ts 子檔案
action.Generate.GetSetAccessor.JavaScript.text=Getter 和 Setter
action.Generate.SetAccessor.JavaScript.text=Setter
action.Generate.GetAccessor.JavaScript.text=Getter
action.Generate.Constructor.JavaScript.text=構造函數
action.Generate.Missing.Members.ES6.text=實作方法…
action.Generate.Missing.Members.TypeScript.text=實作成員…
group.Editor.JSLibrariesMenu.LibraryList.text=使用庫
group.Editor.JSLibrariesMenu.LibraryList.description=設定使用的 JS 庫
group.Editor.JSLibrariesMenu.text=使用 JavaScript 庫
group.Editor.JSLibrariesMenu.description=選擇要與當前檔案一起使用的 JavaScript 庫
configurable.JSTemplateLangConfigurable.display.name=模板
configurable.JSCodeCompletionConfigurable.display.name=JavaScript
configurable.JSSmartKeysConfigurable.display.name=JavaScript
configurable.MyConfigurable.display.name=JSX
import.options.find.more.configuration.options=在<a>程式碼樣式</a>中尋找更多配置選項
settings.code.style.indent.chained.methods=縮排鏈式方法
settings.code.style.indent.all.chained.calls.in.a.group=縮排組中的所有鏈式調用
settings.code.style.semicolon.to.terminate.statements=分號終止語句(&S)
settings.code.style.use=使用
settings.code.style.quotes=引號(&Q)
settings.code.style.Trailing.comma=尾隨逗號(&T):
settings.code.style.single=單
settings.code.style.double=雙
settings.code.style.in.new.code=(在新程式碼中)
settings.code.style.always=始終
settings.code.style.option.use=使用
settings.code.style.dont.use=不使用
checkbox.enable=啟用
webpack.configuration.title=Webpack
webpack.configuration.detect.description=檢測適合模組解析的 webpack 配置檔案:
webpack.configuration.manual=手動
webpack.configuration.automatic=自動
webpack.configuration.disabled=已禁用
webpack.configuration.automatic.how.it.works=運作方式
webpack.configuration.automatic.hint={0} 將使用當前檔案所在資料夾或其任意父資料夾中的 webpack 配置檔案內的模組解析規則。
webpack.configuration.field=配置檔案:
webpack.configuration.field.required.error=手動模式下需要配置檔案路徑
create.react.app.name=React
create.react.app.description=<a href=\\"https://github.com/facebookincubator/create-react-app\\">創建 React 套用</a>是官方支援的一種創建單頁 React 套用程序的新方法。它提供了沒有配置的現代構建設定。
create.react.app.scripts.version=腳本版本 (&V)
create.react.app.typescript.checkbox=創建 TypeScript 專案 (&T)
dialog.title.new.javascript.file=新建 JavaScript 檔案
list.item.javascript.file=JavaScript 檔案
dialog.title.new.typescript.file=新建 TypeScript 檔案
list.item.typescript.file=TypeScript 檔案
list.item.typescript.jsx.file=TypeScript JSX 檔案
dialog.kind.0.file={0} 檔案
action.creates.new.file.description=創建新的 {0} 檔案
build.event.title.failed.to.list.tasks=無法列出 {0} 任務
action.show.error.details.text=顯示錯誤詳細資訊
dialog.title.grunt.settings=Grunt 設定
dialog.title.gulp.settings=Gulp 設定
dialog.title.error.details=錯誤詳細資訊
dialog.message.failed.to.download.0.1=下載 {0} 失敗。{1}
dialog.title.download.error=下載錯誤
label.import.popup=自動匯入工具提示:
label.namespace=命名空間:
dialog.message.cannot.infer.type.new.parameter=無法推斷新參數的類型
dialog.title.cannot.introduce.new.interface=無法引入新接口
notification.title.coloring.types.narrowed.by.type.guard.was.disabled=按類型防護限縮類型著色被禁用
notification.content.html.href.settings.show.inspection.settings.or.href.undo.undo.html=<html><a href='settings'>顯示檢查設定</a>或<a href='undo'>撤消</a></html>
dialog.message.cannot.propagate.variable=無法傳播變數: {0}
dialog.title.cannot.propagate=無法傳播
dialog.message.usages.search.was.interrupted=用法搜尋被中斷
dialog.title.cannot.convert=無法轉換
dialog.message.cannot.proceed.when.having.non.read.usages.in.embedded.expressions=嵌入式表達式中有非讀取用法時，無法繼續
dialog.message.variables.from.destructuring.pattern.have.no.usages=來自於析構模式的變數沒有用法
button.continue=繼續
button.abort=中止
action.don.t.use.library.description=不使用庫
action.already.set.for.containing.folder.or.project.description=已針對包含的資料夾或專案進行設定。
action.use.library.description=使用庫
text.cannot.download=無法下載 {0}。{1}
notification.content.show.details=顯示詳細資訊
action.name.disable.category=禁用 {0}
progress.text.processing=正在處理 {0}{1}
label.path=路徑(&P):
border.title.inspection.export.results.capitalized.location=位置
border.title.inspection.description.title=描述:
progress.title.install.npm.module=安裝 npm 模組 ''{0}''
dialog.message.cannot.find.module.types=找不到模組 @types/{0}
action.jump.to.text=跳轉到…
dialog.title.select.navigation.target=選擇導航目標
dialog.title.select.targets.to.convert.to.class=選擇要轉換為類的目標
dialog.message.component.name=組件名稱:
label.name=名稱: 
label.type=類型: 
label.minimum.language.level=最低語言級別:
dialog.message.cannot.create.argument.stubs.invoked.method.function=無法創建實參存根: 調用的方法不是函數
action.show.structure.text=顯示結構
status.text.no.errors.in.current.file=當前檔案中沒有錯誤。
status.text.javascript.language.service.default.project.errors=顯示專案錯誤
progress.title.compiling.typescript.files=正在編譯 TypeScript 檔案
dialog.message.cannot.find.file=找不到檔案 {0}
radio.set.options.manually=手動設定選項
radio.use.tsconfig.json=使用 tsconfig.json
separator.deprecated.settings=棄用的設定
dialog.title.main.file=主檔案
label.choose.main.file=選擇主檔案
dialog.title.output.directory=輸出目錄
label.choose.output.directory=選擇輸出目錄
dialog.message.incorrect.path.to.typescript.package=typescript 軟體套件的路徑不正確
status.text.project.structure.isn.t.available=專案結構不可用
status.text.service.doesn.t.contain.open.projects=服務不包含開放專案
status.text.refresh.required=需要刷新
dialog.message.cannot.find.module.for.import=無法構建用於匯入的模組路徑
action.js.tagged.literal.injection.text=JS 標記文字注入
dialog.title.wsl.node.interpreter={0} WSL Node 解釋器
dialog.title.wsl.node.interpreter.edit=編輯
dialog.title.wsl.node.interpreter.edit.add=添加
label.wsl.node.interpreter=WSL Node.js 解釋器(&N):
dialog.message.please.select.distribution=請選擇分發版
dialog.message.please.specify.wsl.path.to.node.js.interpreter=請指定 WSL 中安裝的 Node.js 解釋器的路徑
status.text.running.which.node=正在執行 \`which node\`…
progress.title.configuring.node.js.coding.assistance=正在配置 Node.js 編碼輔助…
action.PackageJsonNewFile.text={0}檔案
action.PackageJsonNewFile.description=創建 {0} 檔案
progress.title.install=安裝 {0}
progress.subtitle.install=正在通過 {1} 安裝 {0}…
inspection.message.package.installed=未安裝 {0} 軟體套件
inspection.message.package.version.specified=未指定軟體套件版本
inspection.message.installed.version.doesn.t.match.version.range=安裝的版本 {0} 與版本範圍 {1} 不符合
dialog.title.missing.dependencies=缺少依賴項
button.install.update=安裝/更新
action.view.install.text=查看並安裝…
action.don.t.ask.again.text=不再詢問
dialog.title.configure.coding.assistance.for.node.js.api=配置 Node.js API 編碼輔助
action.Anonymous.text.configure=配置
inspection.message.sm.test.runner.magnitude.assertion.failed.title=斷言失敗
text.html.front.end.template.a.href.http.html5boilerplate.com=<html>前端模板<a href='http://html5boilerplate.com'>http://html5boilerplate.com</a></html>
dialog.message.node.interpreter.unspecified.error.text=請指定 Node.js 解釋器
text.html.sleek.intuitive.and.powerful.front.end.framework=<html>整潔、直觀、強大的前端框架，更快、更輕鬆地進行 Web 開發 <a href='http://getbootstrap.com'>http://getbootstrap.com</a></html>
popup.title.target.function=目標函數
popup.title.select.destructuring.assignment.target=選擇析構賦值目標
visibility.level.overview=概覽
visibility.level.details=詳細資訊
js.module.uml.presentable.name=JavaScript 模組依賴項
intention.family.name.run.npm.install=執行 'npm install'
intention.name.run.npm=執行 ''{0}''
intention.family.name.navigate.to.package.json=導航到 package.json
intention.name.navigate.to.0.package.json=導航到 {0}/package.json
popup.advertisement.start.typing.package.name=開始輸入軟體套件名稱，以從 npm 官方公共註冊表中獲取更具體的結果
popup.advertisement.latest.available.versions.for.all.distribution.tags=所有發行版標籤的最新可用版本
intention.family.name.select.in.test.tree=在測試樹中選擇
intention.family.name.introduce.parameter.properties.for.unused.parameters=轉換為參數屬性
dialog.title.select.parameters.to.convert.to.parameter.properties=選擇要轉換為參數-屬性的參數
intention.family.name.add.required.property=添加所需的屬性
intention.name.create.library.with.files.outside.project=使用專案外部的檔案創建庫
dialog.message.unspecified.suite.name=未指定的套件名稱
dialog.message.unspecified.test.name=未指定的測試名稱
dialog.message.unspecified=未指定的 {0}
dialog.message.no.such=沒有此類{0}
dialog.message.please.specify.package.json=請指定 package.json
dialog.message.please.specify.package.json.correctly=請正確指定 package.json
dialog.message.please.specify.npm.scripts.to.run=請指定要執行的 npm 腳本
dialog.message.command.supported.by={1} 不支持命令 ''{0}''
dialog.message.no.npm.script=無 ''{0}'' npm 腳本
titled.separator.predefined=預定義
label.compiles.js.files=編譯 .js 檔案
label.compress.js.files=壓縮 .js 檔案
dialog.title.edit.run.debug.configuration=編輯執行/調試配置: ''{0}''
js.commandline.configure.language.version=為專案配置 JavaScript 語言版本
js.commandline.configure.nodejs=配置 NodeJS 解釋器並為 package.json 檔案安裝軟體套件

# Language features
js.language.feature.xml.tags=XML 標記
js.language.feature.for.each.statements=針對每條語句
js.language.feature.for.of.loops=for..of 迴圈
js.language.feature.let.definitions=Let 定義
js.language.feature.const.definitions=Const 定義
js.language.feature.generators=生成器
js.language.feature.destructuring.assignments=析構賦值
js.language.feature.let.statements=Let 語句
js.language.feature.array.comprehensions=陣列推導式
js.language.feature.top.level.yield.expressions=頂層 yield 表達式
js.language.feature.reference.namespace=引用命名空間
js.language.feature.default.parameter.values=預設參數值
js.language.feature.pipe.expressions=管道表達式
js.language.feature.decorator.declarations=裝飾器宣告
js.language.feature.throw.expressions=拋出表達式
js.language.feature.ecmascript.syntax.for.private.members=私有成員的 ECMAScript #- 語法
js.language.feature.class.member.visibility.modifiers=類成員可見性修飾符
js.language.feature.optional.chaining.operator=可選鏈接運算符
js.language.feature.arbitrary.precision.integers=任意精度整數
js.language.feature.trailing.commas.in.function.parameter.lists.and.calls=函數參數列表和調用中的尾隨逗號
js.language.feature.unicode.escapes.with.braces=使用大括號的 Unicode 轉義
js.language.feature.bind.expressions=綁定表達式
js.language.feature.optional.catch.bindings=可選 catch 綁定
js.language.feature.string.templates=字串模板
js.language.feature.method.definition.shorthands=方法定義速記形式
js.language.feature.computed.property.names=計算的屬性名稱
js.language.feature.shorthand.property.names=速記屬性名稱
js.language.feature.binary.0b.and.new.octal.0o.literals=二進制(0b)和新的八進制(0o)文字
js.language.feature.async.await=async/await
js.language.feature.types=類型
js.language.feature.annotations=註解
js.language.feature.interfaces=接口
js.language.feature.classes=類
js.language.feature.es6.export.declarations=ES6 匯出宣告
js.language.feature.es6.import.declarations=ES6 匯入宣告
js.language.feature.generics=泛型
js.language.feature.rest.parameters=rest 參數
js.language.feature.arrow.functions=箭頭函數
js.language.feature.getters.and.setters=getter 和 setter
js.language.feature.generator.expressions=生成器表達式
js.language.feature.expression.closures=表達式結束
js.language.feature.destructuring.parameters=析構參數

# Webpack
webpack.failed.to.load=無法載入 {0}
webpack.analyzing.configs.progress=正在分析 Webpack 配置
webpack.cannot.analyze=無法分析 {0}: 編碼輔助將忽略此檔案中的模組解析規則。\\\\n可能的原因: 此檔案不是有效的 webpack 配置檔案，或者 IDE 目前不支持其格式。
file.name.masks.to.skip.from.analysis=要在分析中跳過的文件名遮罩:

# Node
node.core.enable_coding_assistance_intention.name=啟用 Node.js 的編碼輔助
node.interpreter.unresolved_reference.error.message=未解析的解釋器 ''{0}''
node.interpreter.invalid_interpreter.error.message=無效 ''{0}''
node.interpreter.no_local_interpreter.error.message=沒有本地 Node.js 解釋器
node.debug.cannot_connect_to_vm.error.message=無法連接到虛擬機 {0}
node.debug.cannot_get_localhost_IPv4.error.message=無法獲取 127.0.0.1 IPv4
node.core.make.sure.javascript.debugger.plugin.enabled.dialog.message=確保已啟用 'JavaScript Debugger' 套件
node.core.failed_to_fetch_node_core_modules.dialog.message=無法提取 Node 核心模組
node.core.core_modules_fetch_timed_out.dialog.message=無法提取核心模組: 已超時
node.core.not_ready_for_core_modules_configuration.dialog.message=未準備好進行核心模組配置
node.core.navigate_action_text.text=配置 Node.js…
node.core.failed_to_install.title.message=無法安裝 {0}
node.interpreter.field.add.item.text=添加…
node.interpreter.field.unexpected_value.text=意外值 {0}
node.interpreter.unspecified_interpreter.dialog.message=指定 Node.js 解釋器
node.interpreter.unspecified_local_interpreter.dialog.message=指定本地 Node.js 解釋器
node.interpreter.specified_interpreter_correctly.dialog.message=正確指定 Node.js 解釋器
configure.node.interpreter.path=配置 Node.js 路徑…
node.interpreter.reference_not_found.text=未找到
node.interpreter.command_timed_out.dialog.message=''{0}'' 命令執行超時(>{1} ms)
node.package_documentation.installed_version.text=已安裝版本: {0}
node.package_documentation.latest_version.text=最新版本: {0}
node.packages.cannot_find_working_directory.text=無法確定 {0} 的工作目錄: {1}
node.package.field.not_found.text=未找到
node.npm.cannot_find_package_by_reference.dialog.message=找不到軟體套件管理器 ''{0}''
node.npm.specify_npm_or_yarn_package.dialog.message=指定 npm 或 yarn 軟體套件
node.npm.correct_path_to_npm_or_yarn_package.dialog.message=指定 npm 或 yarn 軟體套件的正確路徑: 無此類目錄 \\"{0}\\"
node.npm.invalid_package_manager.binary_file_not_found.dialog.message=指定有效的軟體套件管理器: 在 ''{0}'' 目錄內部找不到二進制檔案
node.npm.project_package_manager_disallowed_here.dialog.message=無法在此處引用專案 npm 軟體套件
node.npm.unspecified_package_manager.dialog.message=未指定軟體套件管理器
node.npm.cannot_resolve_package_manager.dialog.message=無法解析 ''{0}'' 軟體套件管理器
node.npm.no_bundled_npm_detected.dialog.message=未檢測到 {0} 的捆綁 npm
package_json.install_dependencies.notification.title=安裝依賴項
package_json.install_dependencies_multiple.notification.content=來自 {0} 和其他 {1} 個
package_json.install_dependencies.notification.content=來自 {0}
package_json.update_dependencies.notification.title=更新依賴項
package_json.notifications_are_disabled.notification.content=已禁用從 {0} 安裝依賴項的通知。<p>使用 \\"{1}\\" 操作重新啟用通知。
node.wsl.unavailable.dialog.message=WSL 不可用
node.wsl.unavailable_distribution.dialog.message=WSL {0} 不可用
node.npm.cannot_find_project_package_manager.dialog.message=找不到專案 Node.js 軟體套件管理器
node.npm.package_manager_link.text=軟體套件管理器
yarn.package_requires_yarn.dialog.message=軟體套件 \\"{0}\\" 要求 Yarn {1}。

# Jest
jest.package.placeholder.text=軟體套件目錄的路徑，可選擇 jest、react-scripts 或 react-scripts 替代項
jest.snapshot.label=Jest 快照
filetype.jest.snapshot.description=Jest 快照
filetype.jest.snapshot.display.name=Jest 快照
jest.go.to.snapshot.text=轉到 ''{0}'' 快照
jest.cannot.find.bin.file.for.package.dialog.message=找不到 ''{0}'' 軟體套件的 bin 檔案

# Protractor
dialog.message.cannot.locate.wrapper.config.file=找不到包裝器配置檔案

# Style guides
list.item.google.javascript.style.guide=Google JavaScript 樣式指南
list.item.javascript.standard.style=JavaScript 標準樣式

# Inlay hints
method.return.types.in.call.chains=調用鏈中的方法返回類型
type.annotations=類型註解
parameters.in.parentheses=用括號括起來的參數
non.parenthesized.single.parameter=未使用括號括起來的單個參數
function.returns=函數返回
variables.and.fields=變數和欄位
command.name.add.explicit.value=添加顯式值 ''{0}''
numeric.enum.values=數值枚舉值

# Libraries
progress.title.downloading.library=正在下載庫
progress.title.downloading.documentation=正在下載文檔
successfully.downloaded=已成功下載
failed.to.download=無法下載
progress.title.downloading.typings=正在下載 typings
notify.urls.more=… 和另外 {0,number} 個

# Structural Search
structural.search.anonymous.functions=匿名函數
structural.search.functions=函數
structural.search.variables=變數
structural.search.function.calls=函數調用
structural.search.while.loops=While 迴圈
structural.search.constants=常數
structural.search.classes=類
structural.search.empty.functions=空函數
structural.search.console.log.calls=調用 console.log()
structural.search.with.statements=With 語句
structural.search.var.statements=Var 語句
structural.search.functions.with.boolean.parameters=使用布爾參數的函數
structural.search.comparison.to.self=與自身比較

# Project Generators
copying.files=正在複製檔案
project.generation=生成專案
notification.title.cannot.generate=無法生成 {0}
dialog.message.cannot.find.npx.bundled.with=找不到使用 {0} 捆綁的 npx
generating.0=正在生成 {0}

# Find Usages
js.show.dynamic.usages=顯示動態用法

# Test Runners
action.JasmineGenerateNewSuiteAction.text=Jasmine Suite
action.JasmineGenerateNewSpecAction.text=Jasmine Spec
action.JasmineGenerateBeforeEachMethodAction.text=Jasmine beforeEach
action.JasmineGenerateAfterEachMethodAction.text=Jasmine afterEach
action.QUnitGenerateNewTestAction.text=QUnit Test
action.QUnitGenerateSetupAction.text=QUnit Setup
action.QUnitGenerateTearDownAction.text=QUnit TearDown

# Diagrams
diagram.element.not.found={0} (未找到)

# Web frameworks
web.template.file-type.description={0} 模板
web.inspection.message.attribute.does.not.accept.value={0} 不接受任何值

# Other
command.name.create.javascript.file=創建 JavaScript 檔案 {0}
command.name.create.typescript.file=創建 TypeScript 檔案 {0}
checkbox.move.simple.expressions.to.field.initializer=將簡單表達式移動到欄位初始值設定項
popup.title.choose.class=選擇類
multiple.inheritance=多重繼承
label.method.should.be.defined=方法應已定義
recursive.call=遞歸調用
command.name.extract.named.type=提取已命名類型
inspection.message.reference.includes.files.outside.project=引用包括專案範圍之外的檔案
progress.title.executing.performance.task.on.files=正在檔案上執行性能任務
terminal.add_node_modules_bin_to_path.label=將 ''node_modules/.bin'' 從專案根添加到 {0}
label.name.injection=名稱(&N):
reg.exp.tagged.template=''{1}'' 標記模板中的 {0}
unwrap.with.kind=解開 ''{0}…''
header.declarations.to.be.refactored=要重構的宣告
filetype.yarn.lock.display.name=Yarn Lock
filetype.yarn.lock.description=Yarn lock



javascript.validation.message.jsdoc.types.are.used=JSDoc 類型只能在文檔註釋內部使用
eslint.run.on.save.checkbox.on.actions.on.save.page=執行 eslint --fix
javascript.parser.message.missing.back.quote=缺少 \`
eslint.run.on.save.disabled.comment=已禁用 ESLint 集成
eslint.run.on.save.auto.configuration.comment=自動 ESLint 配置
eslint.run.on.save.manual.configuration.comment=手動 ESLint 配置
eslint.run.on.save.link.enable.eslint=啟用 ESLint…
node.execution.failed.to.prepare.target.environment.error=無法準備環境: {0}
node.interpreter.unavailable.target=不可用的目標: {0}
rename.react.hook.variable.title=重命名狀態變數
rename.react.hook.variable.description=將相關狀態變數重命名為:
web.inspection.message.attribute.value.no.valid={0} 不是 {1} 的有效值。預期值: {2}
add.variable.to.require=添加 require 調用的變數
js.regex.flag.g=全域符合 - 返回所有符合項
js.regex.flag.i=忽略大小寫 - 不區分大小寫的符合
js.regex.flag.m=多行 - ^ 和 $ 的每行符合
js.regex.flag.s=dotAll - . 符合換行符
js.regex.flag.u=unicode - 完整 unicode 支援
js.regex.flag.y=粘性 - 在確切的位置搜尋
js.regex.flag.d=符合索引 - 用於子字串符合的索引
node.execution.starting.process.progress.title=正在啟動 ''{0}''…
node.wsl.network.connection.failure=無法建立從 WSL 到 Windows 主機的網絡連接(可能被防火牆阻止)。\\\\n要了解詳細資訊，請參閱: https://jb.gg/wsl-firewall
insert.parentheses.on.completion=完成時插入圓括號
intention.category.javascript=JavaScript
intention.category.typescript=TypeScript
intention.category.ecmascript6=JavaScript/ECMAScript 6
intention.category.react=React
js.annotator.rest.element.must.be.last=rest 元素必須位於最後
web.inspection.message.segment.missing=缺少 {0}
web.inspection.message.segment.unrecognized-identifier=無法識別的 {0}
web.inspection.message.segment.duplicated=重複的 {0}
web.inspection.message.segment.default-subject=名稱
not.installed.package=未安裝軟體套件
package.version.range.info={0, choice, 0#未安裝|1#已安裝: ?|2#已安裝: {1}}，最新: {2, choice, 0#正在載入…|1#未找到|2#{3}}
package.version.range.hint={0, choice, 0#允許|1#允許次要更新:|2#允許補丁更新:} {1} \\\\\\\\&gt;= 版本 \\\\\\\\&lt; {2}
env.variable.undefined={0} 未定義
env.variable.empty={0} 為空
jquery.documentation.not.found=找不到 jQuery 文檔
typescript.language.service.name=TypeScript 服務
js.annotator.yield.cannot.be.used.inside.generator='yield' 不能用作生成器內部的關鍵字
js.invalid.expression.result.type.inspection.name=表達式類型無效
linemarker.javascript.sources=JavaScript 源
linemarker.typescript.declaration=TypeScript 宣告
choose.declaration.element=<html><body>選擇 TypeScript 宣告</body></html>
js.dot.property.access.context.type=點號屬性存取
javascript.library.built.in=內建
inlay.parameters.js.only.show.names.for.all.args=文字和非文字實參、調用表達式、物件和陣列初始值設定項。
inlay.parameters.js.only.show.names.for.tagged=<a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates'>Arguments in tagged templates.<a><br>This setting takes effect only over non-literal arguments and is only available when the \\"Non-Literal arguments\\" option is enabled. 
inlay.parameters.js.only.show.names.for.pipes=<a href='https://github.com/tc39/proposal-pipeline-operator'>管道運算符中的參數。</a>
inlay.parameters.js.param.hints.show.names.for.all.args=方法調用中的文字和命名物件參數。
inlay.parameters.js.param.hints.show.names.for.tagged=標記模板中的實參。
inlay.parameters.angular.show.names.for.all.args=Angular HTML 模板中的文字和命名物件參數。
inlay.parameters.angular.show.names.for.pipes=<a href='https://angular.io/guide/pipes'>Angular HTML 模板中的管道。</a>
inlay.parameters.vuejs.show.names.for.all.args=文字和命名物件。
inlay.parameters.vuejs.show.names.for.filters=<a href='https://vuejs.org/v2/guide/filters.html'>篩選器。</a>
js.url.import.usage.inspection.name=使用了 URL 匯入
js.url.import.usage.inspection.download.module.quick.fix.name=下載模組
js.url.import.usage.inspection.download.module.0.quick.fix.failed=下載模組 ''{0}'' 失敗
js.url.import.usage.inspection.download.module.0.quick.fix.warning=模組 ''{0}'' 已下載，但有錯誤
js.url.import.usage.inspection.download.module.0.quick.fix.warning.urls=失敗的 URL:
js.url.import.usage.inspection.download.module.0.quick.fix.success=模組 ''{0}'' 已成功下載
js.url.import.usage.inspection.download.module.0.quick.fix.progress=正在下載模組 ''{0}''
js.inspection.package.json.update.dependency.to.latest.version=將 package.json 依賴項更新為最新版本
inspection.update.package_json.dependency.message=有可用的 ''{0}'' 新版本: {1}
inspection.update.package_json.dependency.action.text=將 ''{0}'' 更新到最新版本 {1}
react.native.config.name=React Native
react.native.project.generator.description=借助 <a href='https://facebook.github.io/react-native/'>React Native</a>，只需使用 JavaScript 即可構建移動套用。它使用的設計與 React 相同，讓您可以通過宣告性組件構建豐富的移動 UI。
react.native.project.generator.package.name=React Native:
react.native.project.generator.validation={0} 不是有效的專案名稱。請使用由字母數字構成的專案名稱。
escape.jsdoc.copy.pasted.text=在複製和貼上時轉義 JSDoc 前導星號
node.package.empty.error.message=專案名稱為空
node.package.name.period.error.message=專案資料夾名稱不應以句點開頭
node.package.name.underscore.error.message=專案資料夾名稱不應以下划線開頭
node.package.name.leading.or.trailing.spaces.error.message=專案資料夾名稱不應包含前導空格或尾隨空格
node.package.name.forbidden.error.message=''{0}'' 不能用作專案名稱
node.package.name.core.module.error.message=''{0}'' 不能用作專案名稱，因為它是 Node.js 核心模組的名稱
node.package.name.too.long.error.message=專案資料夾名稱不應超過 214 個字符
node.package.name.capital.letters.error.message=專案資料夾名稱不應包含大寫字母
node.package.name.special.characters.error.message=專案資料夾名稱不應包含特殊字符(\\"~'!()*\\")
node.package.name.URL-friendly.characters.error.message=專案資料夾名稱應僅包含適用於 URL 的字符
javascript.parser.message.expected.identifier.string.literal.or.rbrace=應為關鍵字、字串文字或 }
js.import.options.use.explicit.js.extension.auto=自動
js.import.options.use.explicit.js.extension.yes=始終
js.import.options.use.explicit.js.extension.yes.ts=始終為 \\".js\\"
js.import.options.use.explicit.js.extension.no=從不
js.flow.process.log=Flow 流程日誌
flow.js.show.settings=配置 Flow…
flow.js.widget.name=Flow
flow.js.widget.display.name=Flow JS
javascript.indexed.property.instead.of.computed.name=索引屬性存取中括號位於單獨的行中。是否應為計算的名稱?
javascript.insert.symbol.fix=插入{0}
javascript.parser.message.expected.dot=應為 .
javascript.parser.message.expected.newline.or.semicolon=需要換行符或分號
javascript.parser.message.expected.gt=應為 >
javascript.parser.message.expected.lbracket=應為 [
javascript.parser.message.expected.readonly=應為 'readonly'
node.js.configure.interpreter=配置 {0}
yarn.pnp.library_name=來自 {0} 的依賴項
typescript.enum.name=枚舉
typescript.enum.member.name=枚舉成員
icon.icons.nodes.readonlyMark.tooltip=readonly"
`;

exports[`src messages/PhpBundle.properties 1`] = `
"action.ChangePHPInterpreter.text=更改 PHP 解釋器
action.ChangePHPInterpreter.description=更改專案 PHP 解釋器
action.MessDetectorAddToIgnored.text=添加到 PHPMD 忽略列表
action.MessDetectorAddToIgnored.description=添加到 PHP Mess Detector 忽略列表
action.PhpCSFixerAddToIgnored.text=添加到 PHP CS Fixer 忽略列表
action.PhpCSFixerAddToIgnored.description=添加到 PHP CS Fixer 忽略列表
action.PhpCSAddToIgnored.text=添加到 PHPCS 忽略列表
action.PhpCSAddToIgnored.description=添加到 PHP_CodeSniffer 忽略列表
group.PHPQualityToolsAddToIgnoredList.text=添加到忽略列表…
action.ComposerShowLogAction.text=顯示日誌
action.ComposerShowLogAction.description=顯示包含此 composer.json 的 Composer 操作日誌
action.ComposerClearCacheAction.text=清除快取
action.ComposerClearCacheAction.description=刪除 Composer 快取目錄中的所有內容
action.ComposerSelfUpdateAction.text=自我更新
action.ComposerSelfUpdateAction.description=將 Composer 本身更新到最新版本
group.ComposerToolsGroup.text=Composer
action.com.jetbrains.php.composer.ComposerInitSupportAction.text=初始化 Composer…
action.com.jetbrains.php.composer.ComposerInitSupportAction.description=初始化 Composer
group.ComposerGroup.text=Composer
action.ComposerDiagnoseAction.text=診斷
action.ComposerDiagnoseAction.description=檢查常見的 Composer 問題
action.ComposerLicensesAction.text=列出許可證
action.ComposerLicensesAction.description=列出安裝的每個軟體套件的名稱、版本和許可證
action.ComposerStatusAction.text=檢查依賴項中的變更
action.ComposerStatusAction.description=檢查任何依賴項中有無本地變更
action.ComposerDryRunUpdate.text=模擬更新
action.ComposerDryRunUpdate.description=模擬更新，但不實際更新
action.ComposerDumpAutoloadAction.text=轉儲自動載入器…
action.ComposerDumpAutoloadAction.description=重新生成自動載入類的列表
action.ComposerValidateAction.text=驗證…
action.ComposerValidateAction.description=檢查 composer.json 是否有效
action.ComposerAddDependencyAction.text=管理依賴項…
action.ComposerAddDependencyAction.description=管理 Composer 依賴項
action.ComposerUpdateAction.text=更新
action.ComposerUpdateAction.description=從 Composer.json 安裝最新適當版本的軟體套件
action.ComposerInstallAction.text=安裝
action.ComposerInstallAction.description=考慮到 composer.lock，安裝 composer.json 中的軟體套件
action.com.jetbrains.php.internal.PhpViewControlFlowAction.text=當前檔案的 PHP 控制流
action.com.jetbrains.php.internal.PhpShowFQNInternalAction.text=顯示 PHP FQN
action.ProfilerJumpToSource.text=跳轉到原始碼
action.ProfilerJumpToSource.description=跳轉到原始碼
action.XdebugAnalyzeProfilerSnapshotAction.text=分析 Xdebug 分析器快照…
group.DBGPProxyGroup.text=DBGp 代理
action.PhpDebuggerCopyType.text=複製類型
action.XDebugger.CopyPath.text=複製路徑
action.PhpDetectPsroRoots.text=檢測 PSR-0 命名空間根
action.PhpDetectPsroRoots.description=將檢測原始碼命名空間根
action.PhpListenDebugAction.text=偵聽調試連接
action.PhpListenDebugAction.description=偵聽調試連接
action.PhpMakeStaticAction.text=設為 static
action.PhpMakeStaticAction.description=將類方法設為 static
action.PhpExtractClassAction.text=提取類…
action.PhpExtractClassAction.description=將元素提取到單獨的類

action.PhpNewTest.text=PHP 測試
action.PhpNewTest.description=創建新的 PHP 測試
group.PhpNewTestGroup.text=PHP 測試
action.PhpUnitGenerateTearDownMethod.text=TearDown 方法
action.PhpUnitGenerateTearDownMethod.description=創建 PHPUnit tearDown 方法
action.PhpUnitGenerateSetUpMethod.text=SetUp 方法
action.PhpUnitGenerateSetUpMethod.description=創建 PHPUnit setUp 方法
action.PhpUnitGenerateTestMethod.text=測試方法
action.PhpUnitGenerateTestMethod.description=創建 PHPUnit 測試方法
action.PhpGeneratePhpDocBlocks.text=PHPDoc 塊…
action.PhpGeneratePhpDocBlocks.description=為函數、類和欄位添加 PHPDoc 塊。
action.PhpGenerateSetters.text=setter…
action.PhpGenerateSetters.description=為 private 類欄位創建 setter。
action.PhpGenerateGettersAndSetters.text=getter 和 setter…
action.PhpGenerateGettersAndSetters.description=為 private 類欄位創建 getter 和 setter。
action.PhpGenerateGetters.text=getter…
action.PhpGenerateGetters.description=為 private 類欄位創建 getter。
action.PhpGenerateConstructor.text=構造函數…
action.PhpGenerateConstructor.description=創建構造函數。

# php colors page elements
color.settings.name=PHP
color.settings.php.scripting=PHP 程式碼//背景
color.settings.php.tags=PHP 程式碼//標記
color.settings.keyword=關鍵字
color.settings.comment=註釋
color.settings.number=數字
color.settings.string=字串//字符
color.settings.escape_sequence=字串//轉義序列
color.settings.operation=大括號和運算符//運算符
color.settings.brackets=大括號和運算符//中括號
color.settings.parentheses=大括號和運算符//圓括號
color.settings.braces=大括號和運算符//大括號
color.settings.bad_character=未知字符
color.settings.comma=大括號和運算符//逗號
color.settings.semicolon=大括號和運算符//分號
color.settings.heredoc_id=Heredoc//Heredoc ID
color.settings.heredoc_content=Heredoc//Heredoc 內容
color.settings.var=關鍵字//變數
color.settings.var_var=關鍵字//可變變數
color.settings.this.var=關鍵字//'$this' 變數
color.settings.identifier=關鍵字//預設
color.settings.constant=關鍵字//常數
color.settings.function=函數和方法//宣告
color.settings.parameter=函數和方法//參數
color.settings.function.call=函數和方法//函數調用
color.settings.instance.method=函數和方法//實例方法調用
color.settings.instance.protected.method=函數和方法//protected 實例方法調用
color.settings.instance.private.method=函數和方法//private 實例方法調用
color.settings.static.method=函數和方法//static 方法調用
color.settings.magic.member=關鍵字//魔幻成員存取
color.settings.class=類和屬性//類
color.settings.interface=類和屬性//接口
color.settings.static.field=類和屬性//static 屬性
color.settings.instance.field=類和屬性//實例屬性
color.settings.instance.protected.field=類和屬性//protected 實例屬性
color.settings.instance.private.field=類和屬性//private 實例屬性
color.settings.doccomment=PHPDoc//文本
color.settings.doctag=PHPDoc//標記
color.settings.docmarkup=PHPDoc//標記
color.settings.doc.identifier=PHPDoc//關鍵字
color.settings.doc.parameter=PHPDoc//參數
color.settings.doc.var=PHPDoc//變數
color.settings.doc.method.identifier=PHPDoc//方法宣告
color.settings.doc.property.identifier=PHPDoc//屬性
color.settings.exec_command=Shell 命令
color.settings.concatenation=字串//串聯
color.settings.predefined.symbols=關鍵字//預定義符號
color.settings.goto.label=關鍵字//轉到標籤
color.settings.alias.reference=關鍵字//別名引用
color.settings.alias.primitive.type.hint=關鍵字//基元類型提示
color.settings.named.arguments=命名實參
color.settings.attributes=特性

# annotations
annotation.variable.variable=可變變數
annotation.new.expression.interface=無法實例化接口 ''{0}''
annotation.new.expression.trait=無法實例化特徵 ''{0}''
annotation.new.expression.abstract=無法實例化 abstract 類 ''{0}''
annotation.expression.is.not.allowed.as.class.constant.value=表達式不允許為類常量值

#folding
folding.checkbox.collapse.imports=Import
folding.checkbox.collapse.method.body=方法體
folding.checkbox.collapse.function.body=函數體
folding.checkbox.collapse.php.tags=標記
folding.checkbox.collapse.heredocs.and.nowdocs=HEREDOC\\\\\\\\NOWDOC
folding.checkbox.collapse.classes=類主體

#gutter
gutter.overriding.select.title=選擇要導航的父方法
gutter.overriden.select.subclass.title=選擇 {0} 的子類
gutter.overriden.select.implementation.title=選擇 {0} 的實作
#gutter-pinned
gutter.pin.overriding.select.title={0} 的父項
gutter.pin.overriden.select.subclass.title={0} 的實作
gutter.pin.overriden.select.implementation.title={0} 的實作

# inspections
inspection.group=PHP
inspection.group.general=常規
inspection.group.unused=未使用
inspection.group.unused.quickfix.label=未使用的元素
inspection.group.unused.quickfix.message=未使用的元素: ''{0}''
inspection.group.undefined=未定義
inspection.group.control.flow=控制流
inspection.group.php.doc=PHPDoc
inspection.group.probably.bug=可能的錯誤
inspection.group.type.compatibility=類型相容性
inspection.group.code.style=程式碼樣式
inspection.group.code.smell=程式碼異味
inspection.group.naming.convention=命名慣例


inspection.dead.code.problem.empty.constant.synopsis=常數從未使用。
inspection.dead.code.problem.single.constant.synopsis=常數有一個用法，但無法到達。
inspection.dead.code.problem.multiple.constant.synopsis=常數有 {0, choice, 1#1 個用法|2#{0,number} 個用法}，但無法從入口點到達。
inspection.dead.code.problem.empty.function.synopsis=函數從未使用。
inspection.dead.code.problem.recursive.suspicious.function.synopsis=所有函數用法均屬於不存在可從入口點到達的成員的調用鏈。
inspection.dead.code.problem.suspicious.function.synopsis=函數無法從入口點到達。
inspection.dead.code.problem.trait.synopsis=特徵從未使用。
inspection.dead.code.problem.class.nousages.synopsis=類從未使用。
inspection.dead.code.problem.trait.additional.unreachable=特徵沒有可到達用法。
inspection.dead.code.problem.trait.additional.reachable=特徵具有可到達用法。
inspection.dead.code.problem.class.abstract.several.implementations={0} 具有{1, choice, 1#直接或間接實作|2# {1,number} 個直接或間接實作}，但<ul><li>其從未實例化或</li><li>不存在可從入口點到達的實例化。</li></ul>

inspection.hierarchyChecks=類層次結構檢查
inspection.hierarchyChecks.descr=類必須被宣告為 abstract 或實作 {0}
inspection.hierarchyChecks.should.implement=類必須實作 {0}
inspection.hierarchyChecks.field.type.redeclaration.must.not.be.defined=類型不得定義(如基類 ''{0}'' 中)
inspection.hierarchyChecks.field.type.redeclaration.match.super.type=類型必須為 ''{0}''(如基類 ''{1}'' 中)
inspection.wrong_param_type=應為 ''{1}'' 類型的參數，提供的是 ''{0}''
inspection.missing_param=缺少所需參數 ''{0}''
inspection.optional.before.required=可選參數在需要前提供
#inspection -> Super class incompatible with interface
inspection.super.incompatible.with.interface.declaration.must.be.compatible=''{0}'' 的宣告必須與 ''{1}'' 相容

#inspection -> Wrong Exception order
inspection.wrong.exception.order.problem.batch=已捕獲異常 '#ref'
inspection.wrong.exception.order.problem.same=已捕獲異常 ''{0}''
inspection.wrong.exception.order.problem.super=已捕獲異常類 ''{1}'' 的超類 ''{0}''

inspection.wrong.exception.order.fix.move.display.name=將 ''catch'' 子句移動到 ''{0}'' 前
inspection.wrong.exception.order.fix.move.family.name=移動 'catch' 子句
#inspection -> Wrong Exception class
inspection.wrong.exception.type.problem.throw = 已拋出物件必須為 'Exception' 或 'Throwable' 的實例
inspection.wrong.exception.type.problem.catch = 無法捕獲非派生自 'Exception' 或 'Throwable' 基類的物件

#inspection -> Assigned value never used
#inspection -> Wrong foreach argument
inspection.wrong.foreach.argument.type.problem.batch=提供給 'foreach' 的無效實參
inspection.wrong.foreach.argument.type.problem=提供給 ''foreach'' 的實參無效。預期類型: ''array'' 或 ''object''，提供的是 ''{0}''。

#inspection -> Redundant PHPDoc
inspection.redundant.phpdoc=冗餘 PHPDoc 註釋

#inspection -> Unused local variable
inspection.unused.local.variable.problem=未使用的局部變數 ''{0}''。{1}
inspection.unused.local.variable.problem.batch=局部變數 '#ref' 未在任何位置使用
inspection.unused.local.variable.problem.case1=變數的值未在任何位置使用。
inspection.unused.local.variable.problem.case2=變數的值被立即覆蓋。
inspection.unused.local.variable.problem.case3=變數中存儲的引用未在任何位置使用。
inspection.unused.local.variable.problem.case4=變數中存儲的引用被立即覆蓋。
inspection.unused.local.variable.option.description.foreach=在 'list()' 中或存在 'foreach' 鍵時忽略 foreach 值
inspection.unused.local.variable.option.description.list=忽略 'list()' 中的變數
inspection.unused.local.variable.option.description.file.scope=在全域空間中啟用檢查
inspection.unused.local.variable.option.description.null=忽略 'null' 的賦值
inspection.unused.local.variable.option.indirect.access=忽略通過 'get_defined_vars()' 存取的變數
inspection.unused.local.variable.problem.fix.side.effects.found.dialog.title=發現副作用
inspection.unused.local.variable.problem.fix.side.effects.found.dialog.message=分配給 ''{0}'' 的表達式可能含有副作用。\\\\n\\\\
您可以:\\\\n\\\\
- 完全<b>移除</b>變數賦值\\\\n\\\\
- 將分配的表達式<b>轉換</b>成單獨的語句

#inspection -> Unused parameter
inspection.unused.parameter.problem=未使用的參數 ''{0}''。{1}
inspection.unused.parameter.problem.case1=參數值未在任何位置使用。
inspection.unused.parameter.problem.case2=參數值被立即覆蓋。
inspection.unused.parameter.problem.case3=參數中存儲的引用未在任何位置使用。
inspection.unused.parameter.problem.case4=參數中存儲的引用被立即覆蓋。
inspection.unused.parameter.option.description.empty.body=忽略帶有空體的方法/函數的參數
inspection.unused.parameter.option.description.empty.abstract=忽略 abstract 類方法的參數
inspection.unused.parameter.option.description.empty.override=忽略覆寫方法的參數
inspection.unused.parameter.option.description.empty.anonymous=忽略匿名函數的參數
inspection.unused.parameter.option.description.parameter.count=不報告通過 'func_num_args()' 存取的參數

#inspection -> Unused private method
inspection.unused.private.method.problem.batch=未使用的 private 方法 '#ref'
inspection.unused.private.method.option.ignore.constructor=忽略方法 '__construct' 用法
inspection.unused.private.method.option.ignore.clone=忽略方法 '__clone' 用法

#inspection -> Undefined callback
inspection.undefined.callback.method=在類 ''{1}'' 中未找到方法 ''{0}''
inspection.undefined.callback.field=在類 ''{1}'' 中未找到屬性 ''{0}''
inspection.undefined.callback.class=未定義的類 ''{0}''
inspection.undefined.callback.function=未定義的函數 ''{0}''
inspection.undefined.callback.dont.report.exist.checkbox=忽略來自 '*_exists' 和 'is_callable' 函數的回調
inspection.undefined.callback.dont.report.ambiguity.checkbox=不明確時不報告

#inspection -> Missing parent call
inspection.missing.parent.call.message=缺少父方法調用

#inspection -> Missing parent constructor call
inspection.missing.parent.constructor.call.message=缺少父構造函數調用

#inspection - > Undefined variable
inspection.undefined.variable.problem1=未定義的變數 '#ref'
inspection.undefined.variable.problem2=變數 '#ref' 可能未定義
inspection.undefined.variable.option.description.enable.in.file.scope=在全域空間中啟用檢查
inspection.undefined.variable.option.description.report.can.be.undefined=報告變數可能未定義
inspection.undefined.variable.option.description.ignore.include=在當前檔案外搜尋變數定義

#inspection -> Wrong String concatenation operator
inspection.wrong.string.concatenation.operator.problem=字串串聯運算符錯誤
inspection.wrong.string.concatenation.operator.problem.batch=字串串聯運算符錯誤
inspection.wrong.string.concatenation.operator.option.ignore.magic=忽略通過魔術方法存取的屬性

#inspection -> Dynamic method called as static
inspection.dynamic.method.called.as.static.problem=非 static 方法 '#ref' 不應被靜態調用
inspection.dynamic.method.called.as.static.problem.magic=非 static 方法 '#ref' 不應被靜態調用，但類具有 '__magic' 方法。

#inspection -> Static method called as dynamic
inspection.static.method.called.as.dynamic.problem=static 方法 '#ref' 不應被動態調用
inspection.static.method.called.as.dynamic.problem.magic=static 方法 '#ref' 不應被動態調用，但類具有 '__magic' 方法。

#inspection -> Assignment in condition
inspection.assignment.in.condition=條件中的賦值
inspection.assignment.in.condition.move.assignment.out.of.condition.fix.name=從條件中移出賦值

#inspection -> Division by zero
inspection.division.by.zero=除以零

#inspection -> Dynamic namepsace
#inspection -> Unreachable Statement
inspection.unreachable.statement=不可到達的語句
inspection.unreachable.statement.problem=不可到達的語句

#inspection -> Missing doc comment
inspection.missing.doc.comment.problem=缺少 PHPDoc 註釋
inspection.missing.doc.comment.problem.batch={0} 缺少 PHPDoc 註釋
inspection.missing.doc.comment.options.panel.constant=常數(&O)
inspection.missing.doc.comment.options.panel.function=函數(&F)
inspection.missing.doc.comment.options.panel.class=類(&C)
inspection.missing.doc.comment.options.panel.method=方法(&M)
inspection.missing.doc.comment.options.panel.field=屬性(&P)
inspection.missing.doc.comment.options.panel.class.constant=類常數(&A)

#inspection -> Silly assignment
inspection.silly.assignment.problem=賦值左右兩側相等

#inspection -> Illegal array key type
inspection.illegal.array.key.type.problem=非法陣列鍵類型

#inspection -> Illegal string offset
inspection.illegal.string.offset.problem=非法字串偏移 {0}

#inspection -> Missing @return tag
inspection.doc.missing.return.tag.problem=函數/方法 PHPDoc 註釋中缺少 @return 標記

#inspection -> Doc signature inspection

#inspection -> Missing @throws tag
inspection.doc.throws.problem=PHPDoc 註釋不包含所有必需的 @throws 標記
inspection.doc.throws.option.skip.on.empty.phpdoc=忽略沒有 @param/@return 的 PHPDoc

#inspection -> Inconsistent return points
inspection.inconsistent.return.points.problem1=缺少 'return' 語句
inspection.inconsistent.return.points.problem1.yield=缺少 'yield' 語句
inspection.inconsistent.return.points.problem2=缺少返回實參
inspection.inconsistent.return.points.option.treat.return=在 'void' 函數/方法中以相同方式對待 'return null' 和 'return'

#inspection -> Redundant closing tag
inspection.redundant.closing.tag.problem=冗餘結束標記
inspection.redundant.closing.tag.fix.remove=移除結束標記

#inspection -> Void function result used
inspection.void.function.result.used.problem1=使用了 ''void'' 函數 ''{0}'' 結果
inspection.void.function.result.used.problem2=使用了 ''void'' 方法 ''{0}'' 結果

#inspection -> Expression result unused
inspection.expression.result.unused.problem=表達式結果未在任何位置使用

#inspection -> Missing 'break' statement
inspection.missing.break.statement.problem=缺少 'break' 語句

#inspection -> Nested vs outer 'foreach' variables conflict
inspection.nested.vs.outer.foreach.variables.conflict.problem1=變數 ''{0}'' 作為鍵用於內部和外部 ''foreach'' 迴圈
inspection.nested.vs.outer.foreach.variables.conflict.problem2=變數 ''{0}'' 作為值用於內部和外部 ''foreach'' 迴圈

#inspection -> Foreach array is used as value
inspection.foreach.array.is.used.as.value.problem=變數 ''{0}'' 已用作 ''array expression''

#inspection -> Usage of a silence operator
inspection.usage.of.silence.operator.problem=使用了沉默運算符

#inspection -> Language level
#switch language level quick fix
inspection.language.level.quick.fix.switch.language.level.name.0=切換到 PHP {0} 語言級別

#switch language level in composer file manually quick fix
inspection.language.level.quick.fix.switch.language.level.in.composer.manually.0=手動切換到 composer.json 中的 PHP {0} 語言級別
inspection.language.level.quick.fix.switch.language.level.in.composer.0=切換到 composer.json 中的 PHP {0} 語言級別


inspection.disabled.quality.tool.inspection.fix=啟用檢查
inspection.disabled.quality.tool.inspection.open.fix=打開檢查設定

inspection.disabled.quality.tool.inspection= {0} 檢查已禁用

inspection.json.not.installed.packages=未安裝軟體套件
inspection.json.all.not.installed.packages=未安裝軟體套件
inspection.json.not.installed.packages.update.fix=更新所有軟體套件
inspection.json.not.installed.package.update.fix=更新軟體套件
inspection.json.not.installed.packages.install.fix=安裝軟體套件
inspection.json.duplicated.packages.0=require 和 require-dev 中存在重複的 ''{0}'' 條目
inspection.json.duplicated.packages.fix=從 require-dev 中移除重複項

#inspection -> Duplicate array keys
inspection.duplicate.array.keys.display.name=重複的陣列鍵
inspection.duplicate.array.keys.problem=重複的陣列鍵
inspection.duplicate.array.keys.problem.0=值為 ''{0}'' 的重複陣列鍵

#inspection -> Duplicate PhpDoc type
inspection.duplicate.phpdoc.type.problem=重複的類型 ''{0}''
inspection.duplicate.phpdoc.type.fix=從標記中移除重複類型

#inspection -> Undefined constant
inspection.undefined.constant.problem1=未定義的常數 '#ref'
inspection.undefined.constant.problem2=常數 '#ref' 可能未定義

#inspection -> Undefined function
inspection.undefined.function.problem1=未定義的函數 '#ref'
inspection.undefined.function.problem2=函數 '#ref' 可能未定義

#inspection -> Undefined property
inspection.undefined.field.problem1=通過魔術方法存取的屬性
inspection.undefined.field.problem2=屬性動態宣告
inspection.undefined.field.notify.access.magic.method=通過魔術方法存取屬性的通知
inspection.undefined.field.notify.dynamic.declaration=動態屬性宣告的通知

#inspection -> Undefined provider
inspection.undefined.phpunit.provider=未定義的 PHPUnit 資料提供程序 ''{0}''

#inspection -> PHPUnit missing target for test
inspection.phpunit.missing.target.element.ref=未找到 '#ref' 的測試目標元素

#inspection -> Covered function reference is provided without '::'
inspection.phpunit.covers.function.without.scope.resolution.operator=提供的覆蓋{0}引用沒有 ''::''

#inspection -> Deprecated assertEquals/assertNotEquals usage
inspection.phpunit.asserts.assertEquals.parameters.many=可選的 {0} 個參數已棄用
inspection.phpunit.asserts.assertEquals.parameters.single=可選的 {0} 個參數已棄用
inspection.phpunit.asserts.assertEquals.parameters.empty=帶有此類參數的調用已棄用

#inspection -> Usage assertCount/assertSameSize methods instead of assertEquals
inspection.phpunit.asserts.assert.with.count.function=可以使用方法 {0} 代替 {1}

#inspection -> Misordered assertEquals/assertNotEquals arguments
inspection.phpunit.asserts.assertEquals.misordered.arguments=順序錯誤的 ''{0}()'' 實參

#inspection -> Method assertArrayHasKey/assertArrayNotHasKey can be used instead
inspection.phpunit.asserts.array.has.key.can.be.used.instead=可以改用方法 ''{0}''

#inspection -> Deprecated expectException usage
inspection.phpunit.expectException=對將 expectException() 用於 {0} 的支援已棄用，將在 PHPUnit 10 中移除。請改用 {1}()。

#inspection -> Unnecessary fully qualified name
inspection.unnecessary.qualifier.already.imported.message=限定符不必要，可以移除
inspection.unnecessary.fully.qualified.name.option.enable.file.scope=在檔案範圍內啟用
inspection.unnecessary.fully.qualified.name.option.ignore.global.namespace=忽略全域命名空間

#inspection -> Fully qualified name usage
inspection.fully.qualified.name.usage=限定符可以取代為匯入
inspection.fully.qualified.name.usage.option.enable.file.scope=在檔案範圍內啟用
inspection.fully.qualified.name.usage.name.option.ignore.global.namespace=忽略全域命名空間

#inspection -> Multiple classes declaration in one file
inspection.multiple.classes.declarations.in.one.file=在此檔案中宣告了另一個類
#inspection -> Namespace name is not matched with project structure
inspection.illegal.psr.class.path.namespace.name.is.not.matched.to.psr0=命名空間名稱與 PSR-0/PSR-4 專案結構不符合
inspection.illegal.psr.class.path.class.is.not.matched.to.psr0={0}名稱與包含文件名不符合

#inspection -> Traditional Syntax Array Declaration Inspection
inspection.traditional.syntax.array.literal.detected=使用了傳統語法陣列文字

#inspection -> Too Many Parameters
inspection.too.many.parameters=參數數量超出指定限值
inspection.too.many.parameters.max.number.of.parameters=最大參數數量
inspection.too.many.parameters.ignore.constructors=忽略構造函數

#inspection -> Parameters count mismatch
inspection.method.parameters.count.mismatch=為方法調用提供了 {0} 個參數，但方法簽名使用了 {1} 個參數
inspection.method.parameters.count.mismatch.option.ignore.underscore=忽略最後一個參數為 $_ 的函數/方法
inspection.method.parameters.count.mismatch.option.ignore.func.get.arg=忽略帶有 func_get_arg/func_get_args 調用的函數/方法

#inspection -> Method __toString is not implemented
inspection.method.to.string.is.not.implemented.strict.mode=檢查每種表達式類型是否存在 __toString
inspection.method.to.string.is.not.implemented=沒有為類 ''{0}'' 實作方法 ''__toString''

#inspection -> Method or class is not case sensitive
inspection.codeSmell.function.call.is.not.casesensitive=函數/方法調用中的大小寫與宣告中的大小寫不符合
inspection.codeSmell.class.call.is.not.casesensitive=類用法中的大小寫與宣告中的大小寫不符合
inspection.codeSmell.namespace.reference.is.not.casesensitive=命名空間引用中的大小寫與宣告中的大小寫不符合

#inspection -> Method visibility shouldn't be overridden
inspection.codeSmell.overriding.method.visibility.description=方法可見性不應被覆寫

#inspection -> Usage of a variable variable
inspection.variable.variable=使用了可變變數

#inspection -> Strict type checking rules violation
inspection.strict.type.checking.parameter=應為 ''{0}'' 類型的參數，提供的是 ''{1}''
inspection.strict.type.checking.parameter.batch=參數 '#ref' 類型與宣告不相容
inspection.strict.type.checking.return=返回值必須為 ''{0}'' 類型，返回的是 ''{1}''
inspection.strict.type.checking.return.batch=返回值類型與宣告不相容
inspection.strict.type.checking.option=為所有檔案啟用
inspection.strict.type.checking.field.assignment=屬性必須為 ''{0}'' 類型，提供的是 ''{1}''
inspection.strict.type.checking.field.assignment.multi.resolve=賦值的類型 ''{0}'' 與屬性的宣告類型不相容

#inspection -> Incompatible return type
inspection.incompatible.return.type=返回值應為 ''{0}''，返回的是 ''{1}''
inspection.incompatible.return.type.batch=返回值類型與宣告不相容
inspection.incompatible.return.type.strict.type.checking=嚴格類型檢查
#inspection -> Missing strict types declaration
inspection.missing.strict.types.declaration=缺少嚴格類型宣告
inspection.missing.strict.types.declaration.add.declaration=添加嚴格類型宣告

#inspection -> Magic method visibility
inspection.magic.method.visibility.must.be.public=魔術方法 ''{0}'' 必須為 public
inspection.magic.method.visibility.must.be.static=魔術方法 ''{0}'' 必須為 static
inspection.magic.method.visibility.cannot.be.static=魔術方法 ''{0}'' 不能為 static

#inspection -> Naming convention
inspection.naming.convention.problem.descriptor.short={0} 名稱 <code>#ref</code> 過短({1} < {2}) #loc
inspection.naming.convention.problem.descriptor.long={0} 名稱 <code>#ref</code> 過長({1} > {2}) #loc
inspection.naming.convention.element.descriptor.regexp={0} 名稱 <code>#ref</code> 不符合正則表達式 ''{1}'' #loc
inspection.naming.convention.element.description.class=類
inspection.naming.convention.element.description.method=方法
inspection.naming.convention.element.description.property=屬性
inspection.naming.convention.element.description.variable=變數
inspection.naming.convention.element.description.function=函數
inspection.naming.convention.element.description.constant=常數

#inspection -> Replaceable assignment
inspection.assignment.replaceable.with=<code>#ref</code> 可以取代為 ''{0}'' #loc

#inspection -> Constructor style
inspection.constructor.style=舊式構造函數

#inspection -> Statement has empty body
inspection.statement.has.empty.body.comments.count.as.content=註釋計為內容
inspection.statement.has.empty.body.ignore.empty.while=忽略無主體的 'while' 迴圈
inspection.statement.has.empty.body.ignore.empty.for=忽略無主體的 'for' 迴圈

#inspection -> Convert loop to array_map
inspection.loop.can.be.converted.to.arraymap=迴圈可以轉換為 'array_map()' 調用

#inspection -> Convert loop to array_filter
inspection.loop.can.be.converted.to.arrayfilter=迴圈可以轉換為 'array_filter()' 調用

#inspection -> Convert loop to array_fill
inspection.loop.can.be.converted.to.arrayfill=迴圈可以轉換為 'array_fill()' 調用

#inspection -> Convert str_pos to str_contains
inspection.str.functions.strpos.call.can.be.converted.to.strcontains='strpos()' 調用可以轉換為 'str_contains()'
inspection.str.functions.substr.call.can.be.converted.to.strstartswith='substr()' 調用可以轉換為 'str_starts_with()'
inspection.str.functions.strpos.call.can.be.converted.to.strstartswith='strpos()' 調用可以轉換為 'str_starts_with()'
inspection.str.functions.substr.call.can.be.converted.to.strendswith='substr()' 調用可以轉換為 'str_ends_with()'
#inspection -> Convert array_map to loop
inspection.arraymap.can.be.converted.to.loop='array_map()' 調用可以轉換為迴圈

#inspection -> Convert array_filter to loop
inspection.arrayfilter.can.be.converted.to.loop='array_filter()' 調用可以轉換為迴圈

#inspection -> Convert array_fill to loop
inspection.arrayfill.can.be.converted.to.loop='array_fill()' 調用可以轉換為迴圈

#inspection -> Ignored class alias declaration
inspection.ignored.class.alias.declaration=忽略了類別名聲明

#inspection -> Format function parameters mismatch
inspection.format.function.parameters.mismatch.parameter=參數未映射到任何轉換規範
inspection.format.function.parameters.mismatch.conversion.specification=轉換規範未映射到任何參數

inspection.export.results.const=常數
inspection.export.results.back.traces=反向跟踪

inspection.unused.symbol.check.fields=屬性
inspection.unused.symbol.check.methods=方法
inspection.unused.symbol.check.classes=類
inspection.unused.symbol.check.constants=常數
inspection.unused.symbol.check.anonymous_classes=匿名
inspection.unused.symbol.check.functions=函數
inspection.unused.symbol.check.magic_method=魔術方法
inspection.unused.symbol.export.calls=調用
inspection.unused.symbol.export.call=調用
inspection.unused.symbol.export.label=標籤
inspection.unused.symbol.export.reachable_element=可到達
inspection.unused.symbol.export.entry=入口點
inspection.unused.symbol.export.abstract=abstract
inspection.unused.symbol.export.closure=結束
inspection.unused.symbol.export.test_method=測試

inspection.composer.file.reference.problem=路徑 ''{0}'' 未找到

#inspection -> Method may be static
inspection.method.may.be.static=方法可以為 'static'

#inspection -> Missing field type
inspection.missing.field.type=缺少屬性的類型宣告

inspection.unpacked.argument.type.mismatch=僅可解包陣列和 Traversable，獲得的是{0}

inspection.closure.can.be.converted.to.arrow.function=閉包可以轉換為箭頭函數

inspection.field.assignment.type.mismatch=類型不相容: 應為 ''{0}'' 類型的屬性，提供的是 ''{1}''
inspection.field.assignment.type.mismatch.multi.resolve=賦值的類型 ''{0}'' 與屬性的宣告類型不相容

inspection.duplicate.switch.case.body=''switch'' 中的分支是 ''{0}'' 分支的重複項

inspection.duplicate.match.arm.body=''match'' arm 是 ''{0}'' arm 的重複項

inspection.switch.without.default.case='Switch' 沒有預設分支

inspection.doc.field.type.mismatch=屬性類型不符合

inspection.nested.ternary.expression=嵌套三元表達式自 PHP 7.4 已棄用

inspection.statement.without.braces=控制語句主體無大括號
inspection.statement.without.braces.fix.name=將大括號添加到 ''{0}'' 語句

inspection.single.statement.with.braces=單語句主體帶大括號
inspection.single.statement.with.braces.fix.name=從 ''{0}'' 語句中移除大括號

inspection.curly.braces.access.syntax.usage=大括號存取語法自 PHP 7.4 已棄用

inspection.expression.have.same.operands=表達式有相同操作數

inspection.deprecated.cast={0} 轉換自 PHP {1} 已棄用
inspection.deprecated.implode.usage=帶實參(陣列，字串)調用的 {0} 自 PHP 7.4 已棄用

quickfix.replace.curly.braces.with.brackets=將大括號取代為中括號

#quickfix
quickfix.is.not.available.in.dump.mode=在索引更新期間，''{0}'' 快速修復不可用
quickfix.cannot.find.class.reference=無法找到要解析的類引用
quickfix.cannot.find.target.class=無法從引用 ''{0}'' 解析類
quickfix.multiple.target.class.resolve=類 ''{0}'' 有多個宣告
quickfix.import.base.no.candidates=無法找到要匯入的候選項

#quickfix -> PhpCaseSensitiveQuickFix
quickfix.overriding.method.visibility=移除可見性覆寫

#quickfix -> PhpMoveClassToCorrespondingDirectoryQuickFix
quickfix.move.class.to.corresponding.directory=移至目錄 ''{0}''
quickfix.move.class.to.corresponding.directory.error.file.exists=檔案 {0} 已存在
quickfix.move.class.to.corresponding.directory.error.unable.create.directories=無法創建缺少的目錄: ''{0}''
quickfix.move.class.to.corresponding.directory.error.unable.move.file=無法將檔案移動到目錄 ''{0}''

#quick fix for:
quickfix.create.class=創建類
quickfix.failed.to.create.class=無法創建類 ''{0}''

#quic fix for:{PhpConstructorStyleInspection} -> Convert constructor to new style
quickfix.convert.to.new.style.constructor=將構造函數轉換為新樣式

#quick fix for: {PhpUnderfinedVariableInspection} -> Create parameter
quickfix.create.parameter=創建參數
#quick fix for: {PhpUnderfinedVariableInspection} -> Add to use
quickfix.add.to.use=添加到閉包 'use' 結構

#quickfix -> PhpImportClassQuickFix
quickfix.import.class.name=匯入類
quickfix.import.class.popup.title=要匯入的類

#quickfix -> PhpImportConstantQuickFix
quickfix.import.constant.name=匯入常數
quickfix.import.constant.popup.title=要匯入的常數

#quickfix -> PhpImportFunctionQuickFix
quickfix.import.function.name=匯入函數
quickfix.import.function.popup.title=要匯入的函數

#quickfix -> PhpAddFieldDeclarationQuickFix
#quickfix -> PhpAddMethodDeclarationQuickFix
#quickfix -> MakeCallDynamicQuickFix
quickfix.can.not.find.static.method.reference=無法找到 static 方法引用

#quickfix -> MakeCallStaticQuickFix
quickfix.make.call.static.name=將調用設為 static
quickfix.can.not.find.dynamic.method.reference=無法找到動態方法引用

#quickfix -> PhpAddFunctionFromCallback/PhpAddMethodFromCallback/PhpAddFieldFromCallback
quickfix.create.field.from.callback.name=從回調創建屬性
quickfix.create.field.from.callback.invalid.element=無法從回調提取屬性名稱
quickfix.create.field.from.callback.unresolved.class.ref=無法從回調創建屬性。無法解析目標類引用。
quickfix.create.field.from.callback.ambiguity.class.ref=無法從回調創建屬性。解析的類引用不明確。
quickfix.create.method.from.callback.name=從回調創建方法
quickfix.create.method.from.callback.invalid.element=無法從回調提取方法名稱
quickfix.create.method.from.callback.unresolved.class.ref=無法從回調創建方法。無法解析目標類引用。
quickfix.create.method.from.callback.ambiguity.class.ref=無法從回調創建方法。解析的類引用不明確。
quickfix.create.function.from.callback.family.name=從回調創建函數
quickfix.create.function.from.callback.name=添加函數
quickfix.create.function.from.callback.invalid.element=無法從函數回調提取 FQN
quickfix.create.function.from.callback.another.namespace=無法在 ''{0}'' 命名空間中創建函數

#quickfix -> PhpChangeParameterTypeQuickFix/PhpChangeReturnTypeQuickFix/PhpExtendReturnTypeQuickFix
quickfix.strict.type.checking.change.parameter.type.name=將{0, choice, 1#第 1 個|2#第 2 個|3#第 3 個|4#第 {0,number} 個}參數的類型從 ''{1}'' 更改為 ''{2}''
quickfix.strict.type.checking.change.parameter.type.family=更改參數類型
quickfix.strict.type.checking.change.return.type.name=將返回類型從 ''{0}'' 更改為 ''{1}''
quickfix.strict.type.checking.change.return.type.family=更改返回類型
quickfix.strict.type.checking.extend.return.type.name=將返回類型從 ''{0}'' 擴展為 ''{1}''
quickfix.strict.type.checking.extend.return.type.family=擴展返回類型

#quickfix -> PhpChangeTypeDeclarationQuickFix
quickfix.change.type=更改為 ''{0}''
quickfix.remove.type=移除類型 ''{0}''
quickfix.change.type.declaration.family=更改類型

#quickfix -> PhpCaseSensitiveQuickFix
quickfix.case.sensitive.name=更改 {0} 的大小寫以符合其宣告

#quickfix -> Replace assignment with operator assignment
quickfix.replace.assignment.with.operator.assignment.family.name=將賦值取代為運算符賦值
quickfix.replace.assignment.with.operator.assignment.name=將 ''='' 取代為 ''{0}=''

#quickfix -> Replace assignment with prefix expression
quickfix.replace.assignment.with.prefix.expression.family.name=將賦值取代為前綴表達式
quickfix.replace.assignment.operator.with.prefix.expression.family.name=將賦值運算符取代為前綴表達式

quickfix.replace.one.operator.with.another=將 ''{0}'' 取代為 ''{1}''

#quickfix -> Convert loop to array_map
quickfix.convert.loop.to.arraymap=將迴圈轉換為 'array_map()' 調用

#quickfix -> Convert loop to array_filter
quickfix.convert.loop.to.arrayfilter=將迴圈轉換為 'array_filter()' 調用

#quickfix -> Convert loop to array_fill
quickfix.convert.loop.to.arrayfilll=將迴圈轉換為 'array_fill()' 調用

#quickfix -> Convert array_map to loop
quickfix.convert.arraymap.to.loop=將 'array_map()' 調用轉換為迴圈

#quickfix -> Convert array_filter to loop
quickfix.convert.arrayfilter.to.loop=將 'array_filter()' 調用轉換為迴圈

#quickfix -> Convert array_fill to loop
quickfix.convert.arrayfill.to.loop=將 'array_fill()' 調用轉換為迴圈

#quickfix -> PHPUnit create missing target class
quickfix.phpunit.create.target.class.error.filename.exists=存在檔案 {0}

#quickfix -> Replace current method with alternative 
quickfix.phpunit.replace.current.method.with.alternative=取代為 ''{0}''

#quickfix -> Drop redundant optional parameters
quickfix.phpunit.drop.redundant.optional.parameters=刪除冗餘的可選參數

#quickfix -> Flip misordered assertEquals/assertNotEquals arguments
quickfix.phpunit.assert.equals.flip.compared.arguments=翻轉比較實參

#quickfix -> Unnecessary qualifier
quickfix.remove.unnecessary.qualifier=移除不必要的限定符
quickfix.remove.unnecessary.qualifier.on.class.name=簡化 FQN

#quickfix -> Disable for global namespace
quickfix.disable.inspection.for.global.namespace=為全域命名空間禁用檢查

#quickfix -> Make method static
quickfix.make.method.static=設為 'static'

#quickfix -> Change field type
quickfix.change.field.type.to.match.super=更改類型以符合父項
quickfix.change.field.type.add.inferred.type.family.name=作為屬性的類型添加推斷的類型
quickfix.change.field.type.add.inferred.type.name=作為屬性的類型添加 ''{0}''
quickfix.change.field.type.add.inferred.type.error.read.only=無法修改唯讀檔案 ''{0}''
quickfix.change.field.type.add.inferred.type.error.non.project=無法修改非專案檔案 ''{0}''

#quickfix -> Remove redundant PHPDoc
quickfix.remove.phpdoc=移除冗餘 PHPDoc 註釋

quickfix.remove.phpdoc.signature.tags=移除不必要的 @param 和 @return 標記
quickfix.remove.phpdoc.param.tag=移除 @param 標記
quickfix.remove.phpdoc.return.tag=移除 @return 標記

quickfix.phpdoc.update.type=更新 PHPDoc 類型
quickfix.phpdoc.update.field.type=將屬性類型更改為 ''{0}'' 以匹配 PHPDoc 註釋

quickfix.replace.nested.ternary.expression=將三元表達式取代為 {0} 關聯版本

quickfix.set.inheritance.between.classes=使{0} {1} {2}

quickfix.navigate.to.duplicate.array.key=導航到重複鍵
quickfix.navigate.to.duplicate.condition=導航到重複條件

#quickfix -> Delete return argument
quickfix.delete.return.argument=刪除返回實參

quickfix.remove.default.arm=移除重複的 'default' match arm
#intentions

#intentions Replace ?: expression with If
intention.replace.ternary.expression.with.if=將 '?:' 取代為 if

#intentions Replace If with ?: expression
intention.replace.if.with.ternaryExpression=簡化 'if'

#intentions -> Convert To Short Syntax
intention.convert.to.short.syntax=將陣列轉換為短語法
intention.convert.to.traditional.syntax=將陣列轉換為傳統語法

#intentions -> Convert To Short Syntax (list)
intention.convert.to.short.syntax.list=將列表轉換為短語法
intention.convert.to.traditional.syntax.list=將列表轉換為傳統語法

#intentions -> Declare Field
intention.declare.missing.field=宣告屬性

#intentions -> Declare Property
intention.declare.missing.property=添加 @property

#intentions -> Flip Binary Expression
intention.flip.binary.expression.family.name=翻轉二進制表達式
intention.flip.binary.expression.text1=翻轉 ''{0}''
intention.flip.binary.expression.text2=翻轉 ''{0}'' (可能更改語意)
intention.flip.binary.expression.text3=翻轉 ''{0}'' (更改語意)

#intentions -> Namespace Bracing
intention.namespace.bracing=將命名空間轉換為帶大括號

#intentions -> Smart Line Split
intention.line.split=在兩個字串和串聯中拆分字串

#intentions -> Split comma-separated values
intention.split.comma.separated.values=將逗號分隔的值拆分為多行
intention.join.comma.separated.values=將逗號分隔的值合併為一行

#intentions -> Swap Call Arguments
intention.swap.call.arguments.family.name=交換調用實參
intention.swap.call.arguments.text1=交換 ''{0}'' 和 ''{1}''

#intention -> Add variable PHPDoc comment
intention.variable.add.phpdoc.comment.family.name=添加 PHPDoc 註釋

#intention -> Import class
intention.import.class=作為別名匯入類
intention.import.class.alias.name=別名:
intention.import.class.alias.already.exists=已匯入具有相同別名的類

#intention -> Simplify FQN
#intention -> Generate PHPDoc
intention.generate.phpdoc=生成 PHPDoc

#intention -> Surround With Call
intention.can.not.find.statement.to.surround=無法找到要環繞的目標語句。
intention.statement.to.surround.failed.message=無法用 ''{0}'' 環繞語句。

#intention -> Replace quotes
intention.replace.quotes=無法取代引號 - 轉義符號無效且\\\\\\\\r 不受支援

#intention -> Replace with alias
intention.replace.class.with.alias=取代為別名

#intention -> Inline alias
intention.inline.alias=內聯別名

#intention -> Add constructor parameters
intention.add.constructor.parameters=添加構造函數參數
intention.add.constructor.parameters.fields.chooser.dialog.title=選擇要在構造函數中初始化的屬性

#intention -> Implement the interface
intention.implement.interface=實作接口

intention.merge.condition.with.outer=與外部條件合併

#navigation -> Goto Super Method
navigation.goto.super.method.is.not.available=索引更新期間無法在此處導航

#run and debug
#dbgp debugging protocol
dbgp.invalid.packet=無效數據包

#annotator
annotator.duplicate.use.statement=無法使用 ''{0}''，因為該名稱已被使用
annotator.duplicate.default.match.condition=match 表達式只能包含一個 'default' 分支
annotator.unhandled.match.argument=未處理的 'match' 實參
annotator.reserved.class.name=無法使用 ''{0}'' 作為類名，因為該名稱已被保留
annotator.invalid.class.name=''{0}'' 是無效的類名
annotator.special.class.name=無法將 {0} 用作 {1}，因為 ''{1}'' 是一個特殊的類名
annotator.cannot.break.continue=無法中斷/繼續{0}級別
annotator.jump.out.of.finally=不允許跳出 finally 塊
php.annotator.expecting.interface=應為接口引用
php.annotator.expecting.class=應為類引用
php.annotator.exchange.extends.implements.keyword=將 ''{0} {2}'' 更改為 ''{1} {2}''
php.annotator.strict.types.first.statement='strict_types' 宣告必須是腳本中的第一條語句
php.annotator.strict.types.block.mode='strict_types' 宣告不能使用塊模式
php.annotator.heredoc.indent.validation.mixed.space.and.tab.characters=結束關鍵字縮排中混用了空格和制表符字符
php.annotator.heredoc.indent.validation.wrong.content.indent=縮排錯誤:應與結束標記縮排相同
php.annotator.typed.property.illegal.value=''{0}'' 類型的屬性可能沒有預設值
php.annotator.typed.property.type.mismatch=預設值只能是 ''{0}'' 類型
php.annotator.typed.property.type.mismatch.fix.nullable=使屬性類型可為 null
php.annotator.typed.parameter.type.mismatch.fix.nullable=使參數類型可為 null
php.annotator.typed.property.type.mismatch.fix.change=將屬性類型更改為 ''{0}''
php.annotator.typed.parameter.type.mismatch.fix.change=將參數類型更改為 ''{0}''
php.annotator.typed.property.type.mismatch.fix.family=更改屬性類型以符合預設值的類型
php.annotator.typed.parameter.type.mismatch.fix.family=更改參數類型以符合預設值的類型
php.annotator.typed.property.callable.is.illegal=屬性不能有 'callable' 類型
php.annotator.return.type.non.nullable.null.returned=無法返回 'null': 返回類型不可為 null
php.annotator.return.type.make.nullable.fix=使返回類型可為 null
php.annotator.void.function.must.not.return.value=void 函數不得返回值
php.surround.with.if=if

#quality tool
quality.tool.configuration.tool.path.is.empty=所選配置的 {0} 路徑為空
quality.tool.configuration.can.not.find.configuration.by.id=按 ID 無法找到 {0} 配置: ''{1}''
quality.tool.configuration.default.interpreter.is.not.found=預設選擇 {0} 配置解釋器，但未指定解釋器
quality.tool.configuration.for.interpreter.is.not.found=找不到解釋器的 {0} 配置: ''{1}''
quality.tool.configuration.interpreter.is.undefined={0} 配置的解釋器未指定或無效
quality.tool.phpcs.custom.rules.warning=選擇 'Custom' 編碼標準類型以選擇自訂規則集。
quality.tool.phpcs.custom.rules.validation.not.xml=所選規則集不是 XML
guality.tool.configuration.show.ignored.files=顯示忽略的檔案
quality.tool.phpcs.installed.paths=已安裝的標準路徑
quality.tool.empty.path.phpcs={0} 的路徑為空
quality.tool.phpcbf.location=PHPCBF 位置
quality.tool.phpcbf.location.descr=選擇有效的 phpcbf 啟動器
quality.tool.phpcbf.settings=PHP Code Beautifier and Fixer 設定
quality.tool.phpcbf.path=phpcbf 路徑:
quality.tool.phpcbf.reformat.action=PHP Code Beautifier and Fixer: 修復整個檔案
quality.tool.phpcbf.name=PHP Code Beautifier and Fixer
quality.tool.selected.file.is.not.phpcbf=所選檔案不是 phpcbf 可執行檔案
quality.tool.cs.fixer.custom.rules.warning=選擇 'Custom' 類型以選擇您的配置。
quality.tool.php_cs.custom.rules.validation.not.php_cs=PHP CS Fixer 不支持選定的規則集
quality.tool.php_cs.dir.does.not.contain.custom=此目錄不包含任何受支援的檔案: {0}
quality.tool.php.dir.does.not.contain=該目錄不包含{0}
quality.tool.can.not.determine.version=無法確定工具版本，得到 ‘{0}’
quality.tool.file.not.found=找不到檔案。
quality.tool.path.must.not.be.empty=路徑不能為空。
quality.tool.can.not.retrieve.standards=無法檢索可用規則集，請檢查 PHP CS Fixer 工具配置。
quality.tool.phpcs.can.not.retrieve.standards=無法檢索可用標準，請檢查 PHP_CodeSniffer 工具配置。
quality.tool.stardards.has.been.updated=已安裝的規則集列表已更新。
quality.tool.coding.stardards.has.been.updated=已安裝的編碼標準列表已更新。
quality.tool.cs.fixer.allow.risky.rules=允許為內建規則集設定有風險的規則
quality.tool.cs.fixer.reformat.action=PHP CS Fixer: 修復整個檔案
quality.tool.cs.fixer.ruleset=規則集:

quality.tool.phpcs.required.phpcs.version=所需的 PHP_CodeSniffer 版本為 1.5.0 或更高，找到的是 {0}
quality.tool.php.cs.fixer.required.phpcs.version=支援的 PHP CS Fixer 版本為 2.8.0 或更高，找到的是 {0}

quality.tool.label.check.files.with.extensions=檢查帶副檔名的檔案:
quality.tool.label.coding.standard=編碼標準:
quality.tool.checkbox.installed.standard.paths=已安裝的標準路徑:
quality.tool.checkbox.show.sniff.name=顯示 sniff 名稱
quality.tool.checkbox.show.warning.as=將警告顯示為:
quality.tool.label.tool.path=工具路徑:
quality.tool.label.tool.process.timeout=工具處理超時，[1...60] 秒:
quality.tool.button.validate=驗證
quality.tool.label.validation.label=驗證標籤
quality.tool.label.custom.rulesets=自訂規則集:
quality.tool.phpcs.label.path.to.ruleset=規則集路徑:
quality.tool.label.label=標籤
quality.tool.label.configuration=配置:

#phpunit messages
php.unit.local.run.display.name=PHPUnit
php.unit.local.run.description=PHPUnit
php.not.test.method=類 ''{1}'' 中的方法 ''{0}'' 不是測試方法
php.method.not.found=在類 ''{1}'' 中未找到方法 ''{0}''
php.method.name.empty=未指定測試方法
php.unit.radio.button.composite=復合
php.unit.test.runner.options=測試執行程序選項
php.unit.checkbox.use.alternative.patterns.base.path=使用替代模式基路徑:
php.unit.optional=可選
php.unit.label.test.file.template=測試檔案模板(&T):

choose.php.home=選擇 PHP 可執行檔案
cleaning.up=正在清理…
this.reassignment.is.not.allowed=不能重新分配 $this
cant.use.temporary.expression.in.write.context=在寫上下文中不能使用臨時表達式
parsing.error.statement.expected=應為語句
smarty.configurable.title=Smarty
analyzing.php.sdk=正在檢查 PHP 安裝…
include.path.column.info=路徑
working.directory.invalid=找不到工作資料夾 ''{0}''
#control flow
#validation common
validation.file.already.exists.in.dir=名稱為“{0}”的檔案已存在於“{1}”中
validation.file.already.exists=檔案 \\"{0}\\" 已存在
validation.file.not.valid.name=“{0}”不是有效的文件名
validation.class.not.valid.name=\\"{0}\\" 不是有效的類名
validation.namespace.not.valid.name=“{0}”不是有效的命名空間名稱
validation.invalid.identifier=“{0}”不是有效的關鍵字
validation.invalid.identifier.with.no.identifier=插入的關鍵字無效
validation.invalid.alias=“{0}”不是有效的別名
validation.value.is.not.specified.or.invalid={0} 未指定或無效。
validation.value.path.to.value.should.be.specified={0} 的路徑應在 {1} 中指定
validation.value.path.to.value.is.invalid=無法通過 {1} 中提供的路徑找到 {0}
validation.value.path.to.value.is.invalid.press.fix.project.configuration=無法通過 {1} 中提供的路徑找到 {0}。按“修復”以編輯 {2} 配置。
validation.value.is.not.specified.or.invalid.press.fix.project.configuration={0} 未指定或無效。按“修復”編輯您的專案配置。
validation.value.is.not.specified.press.fix.project.configuration={1} 配置中未指定 {0}。按“修復”以編輯 {1} 配置。
validation.press.fix.to.edit.project.configuration=按“修復”編輯您的專案配置。
validation.value.is.invalid={0} 無效
validation.0.not.found.at.1=在 ''{1}'' 中找不到 ''{0}''
validation.0.is.not.a.directory=''{0}'' 不是目錄
validation.0.extension.is.not.installed=未安裝 ''{0}'' 擴展
validation.debug.extension.is.updated=調試擴展設定已更新。請重新執行當前配置以使用新值。
validation.0.extension.is.installed.check.configuration.options=已安裝 ''{0}'' 擴展。檢查配置選項。
validation.no.debug.extension.is.installed=未安裝調試擴展。
validation.cannot.parse.value.of.0=無法解析 ''{0}'' 的值
validation.connection.was.not.established=未建立連接。
validation.connection.was.not.established.0=無法使用 ''{0}'' 啟動調試器會話
validation.connection.was.not.established.no.debug=未安裝調試擴展
validation.connection.was.not.established.update.info=更新解釋器資訊
validation.connection.was.not.established.validate.installation=驗證安裝
validation.function.already.exists = 當前命名空間中已定義具有相同名稱的函數
validation.namespace.already.exists = {1}中已定義名稱為 ''{0}'' 的命名空間
validation.class.already.exists = {0}中已經存在具有相同名稱的類
validation.class.cannot.be.overridden = 類“{0}”不能被覆寫
validation.interface.cannot.be.overridden = 無法實作接口“{0}”
validation.test.no.test.patterns = 未添加任何模式

validation.ssh.remote.debug.support=''{0}'' 擴展不支持通過 ssh 進行遠端調試。
validation.ssh.remote.code.coverage.support={0} 擴展不支持通過 ssh 進行程式碼覆蓋
remote.interpreter.path.mappings.validation.title=沒有為所選解釋器配置路徑映射。
remote.interpreter.path.mappings.validation.message=請檢查映射是否在 {0} 下正確配置。
remote.interpreter.path.mappings.validation.php.section=<b><i><a href=\\"php_mappings\\">設定|PHP</a></i></b>
docker.compose.coverage.file.is.not.found=找不到覆蓋率檔案
docker.compose.coverage.file.failed.to.copy=無法從 Docker 容器複製覆蓋率結果
docker.compose.coverage.file.failed.to.extract=無法提取覆蓋率結果
docker.compose.radio.button.always.start.a.new.container.docker.compose.run=始終啟動一個新容器('Docker-compose run')
docker.compose.radio.button.connect.to.existing.container.docker.compose.exec=連接到現有容器('Docker-compose exec')
docker.compose.failed.to.start.container=啟動 docker-compose 服務失敗，請在命令行中啟動並重試

#errors common
error.template.unable.parse.internal.template=無法解析內部模板 {0}
error.template.unable.create.from.internal.template=無法從內部模板 {0} 創建檔案
error.file.unable.create.selected.directory=無法在所選目錄中創建檔案 {0}
error.cannot.connect.to.0.1=無法連接到 ''{0}'': {1}
error.cannot.connect.to.0=無法連接到 ''{0}''

#messages common
0.completion.shortcut=使用{1}進行{0}補全

#completion
completion.press.again.to.see.more.variants=再次按 {0} 以查看更多變體
completion.press.again.to.see.global.variants=再次按 {0} 以查看全域變體
completion.press.again.to.see.all.classes=再次按 {0} 以查看所有類

#unwrap
unwrap.if=解開 if…
unwrap.while=解開 while...
unwrap.for=解開 for...
unwrap.try=解開 try...
unwrap.else=解開 else...
unwrap.elseif=解開 elseif…
unwrap.dowhile=解開 do-while…
unwrap.foreach=解開 foreach…
unwrap.method=解開 ''{0}''
remove.else=移除 else...


#refactoring
refactoring.common.not.supported.expression.in.scope=當前範圍不支持此類表達式的{0}
refactoring.common.not.supported.context=當前上下文不支持{0}
refactoring.common.not.extractable.expression=不支持此類表達式
refactoring.common.fail.to.extract.expression=無法從所選程式碼段中提取表達式

refactoring.common.ui.target.namespace.label=命名空間(&N):
refactoring.common.ui.target.directory.label=目標目錄(&D):
refactoring.common.ui.target.directory.edit = 按 F2 編輯目標目錄

refactoring.common.validation.namespace.name=“{0}”不是有效的命名空間名稱
refactoring.common.validation.class.psi=無法執行重構: 目標類“{0}”無效
refactoring.common.validation.target.directory.is.not.valid=目錄“{0}”的路徑無效
refactoring.common.validation.target.directory.not.inside.project=目錄“{0}”不在專案內部

refactoring.parameter.reserved.name = 參數名稱“{0}”已保留
refactoring.parameter.validation = 參數 {0} 無效
refactoring.parameter.validation.duplicate.parameter=重複的參數名稱: {0}
refactoring.parameter.validation.initializer.last=必選參數不能位於可選參數後
refactoring.parameter.validation.variadic.last=只有最後一個參數可以是可變形參
refactoring.parameter.validation.variadic.can.have.default.value=可變形參不能具有預設值
refactoring.parameter.validation.initializer.type=具有類類型提示的參數的預設值只能為 NULL
refactoring.parameter.validation.pass.by.reference=僅變數可通過引用傳遞
refactoring.parameter.validation.type=參數類型 ''{0}'' 無效
refactoring.parameter.validation.default.value=預設值表達式 ''{0}'' 無效
refactoring.parameter.validation.initializer=初始值設定項 ''{0}'' 無效
refactoring.parameter.validation.no.default.value=應該為參數 ''{0}'' 提供初始值設定項或預設值
refactoring.parameter.validation.name.collision.with.use.list=參數名稱 ''{0}'' 無效。''{0}'' 已匯入 use 列表
refactoring.returnType.validation.type=返回類型 ''{0}'' 無效

#refactoring - > extract base
refactoring.extract.base.validator.not.valid.identifier=“{0}”不是有效的 PHP 關鍵字。
refactoring.extract.base.validator.reserved.keyword=“{0}”是保留的 PHP 關鍵字。
refactoring.extract.base.handler.no.expression.selected=選擇不構成正確的表達式
refactoring.extract.base.handler.not.supported.expression=此類表達式不支持{0}
refactoring.extract.base.handler.not.supported.scope=當前範圍不支持{0}
refactoring.extract.base.dialog.replace.all.occurrences=取代所有符合項(找到 {0} 個匹配項)(&A)
#refactoring -> extract class
refactoring.extract.class.extract.to.class=提取到類
refactoring.extract.class.extracting.from.file=正在從檔案提取:
refactoring.extract.class.extracting.from.class=正在從類提取:
refactoring.extract.class.dialog.class=類名:
refactoring.extract.class.dialog.generate.accessors=生成存取器
refactoring.extract.class.dialog.members.to.be.extracted=要提取的成員
refactoring.extract.class.error.failed.to.create.file=無法創建檔案
refactoring.extract.class.preview=已提取的類預覽
refactoring.extract.class.conflicts.extract.class.refactoring.is.not.supported.for.dynamically.declared.properties.usages=動態宣告屬性用法不支持“提取類”重構
refactoring.extract.class.conflicts.method.0.depends.on.property.1.which.needs.getters.in.2=方法 \\"{0}\\" 依賴於屬性 \\"\${1}\\"，需要 \\"{2}\\" 中的 getter
refactoring.extract.class.conflicts.method.0.depends.on.property.1.which.needs.setters.in.2=方法 \\"{0}\\" 依賴於屬性 \\"\${1}\\"，需要 \\"{2}\\" 中的 setter
refactoring.extract.class.conflicts.method.0.depends.on.1.method.2=方法 \\"{0}\\" 依賴於 {1} 方法 \\"{2}\\"
refactoring.extract.class.conflicts.method.0.depends.on.1.constant.2=方法 \\"{0}\\" 依賴於 {1} 常數 \\"{2}\\"
refactoring.extract.class.conflicts.unable.to.add.delegate.property.initialization.to.constructor=無法將委託的屬性初始化添加到類構造函數
refactoring.extract.class.conflicts.unable.to.add.delegate.property.initialization.to.constructor.trait.constructor.will.be.overridden=無法將委託的屬性初始化添加到類構造函數: 特徵構造函數將被覆寫
refactoring.extract.class.conflicts.using.write.access.for.non.public.properties.in.array.destructuring.expressions.is.not.supported.in.extract.class.refactoring=“提取類”重構不支持將寫入權限用於陣列析構表達式中的非 public 屬性
refactoring.extract.class.conflicts.using.write.access.for.non.public.properties.in.multiple.assignment.expressions.in.extract.class.refactoring=“提取類”重構不支持將寫入權限用於多個賦值表達式中的非 public 屬性
refactoring.extract.class.error.the.selected.function.should.belong.to.project.sources=所選函數必須屬於專案源
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.anonymous.functions=匿名函數不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.anonymous.classes=匿名類不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.abstract.methods=抽象方法不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.doc.methods=通過 PHPDoc 定義的魔術方法不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.doc.properties=通過 PHPDoc 定義的魔術屬性不支持 Extract Class 重構
refactoring.validation.class.error.property.with.name.0.is.already.exists=已存在名稱為 \\"{0}\\" 的屬性

#refactoring -> extract variable
refactoring.extract.variable.name=提取變數
refactoring.extract.variable.conflict.already.exists=範圍中已經存在名稱為“{0}”的變數。
#refactoring -> extract constant
refactoring.extract.constant.name=提取常數
refactoring.extract.constant.conflict.already.exists=範圍中已經存在名稱為“{0}”的常數。
refactoring.extract.constant.conflict.exists.in.subclass.with.weaker.access=“{0}”的存取級別必須為“{1}”(如在類“{2}”中)或更弱
refactoring.extract.constant.conflict.exists.in.subclass=“{0}::{1}”將被此常數覆寫
refactoring.extract.constant.conflict.cannot.override.interface.constant=無法覆寫接口“{1}”的常數“{0}”
refactoring.extract.constant.unable.to.add.constant.declaration=\\"無法添加常數宣告\\"

#refactoring -> extract field
refactoring.extract.field.name=提取屬性
refactoring.extract.field.validator.reserved.field.name=“{0}”是保留的屬性名稱
refactoring.extract.field.conflict.already.exists=該類中已經存在名稱為“{0}”的屬性。
refactoring.extract.field.visibility=可見性
refactoring.extract.field.visibility.public=public(&U)
refactoring.extract.field.visibility.protected=protected(&O)
refactoring.extract.field.visibility.private=private(&I)

#refactoring -> extract parameter
refactoring.extract.parameter.name=提取參數

#refactoring -> rename - > element processor
conflict.method.with.same.name.already.exists=此類中已經定義了具有相同名稱的方法
conflict.field.with.same.name.already.exists=此類中已經定義了具有相同名稱的屬性
conflict.class.constant.with.same.name.already.exists=此類中已經定義了具有相同名稱的常數
conflict.variable.with.same.name.already.exists=已經定義了具有相同名稱的變數
conflict.parameter.with.same.name.already.exists=已經定義了具有相同名稱的參數
conflict.tag.name.contains.close.tag=文本包含“{0}”
conflict.use.with.same.name.already.exists=已經定義名稱相同的 'Use' 語句
conflict.class.with.same.name.already.exists=已經定義了具有相同名稱的類
conflict.function.with.same.name.already.exists=已經定義了具有相同名稱的函數
conflict.constant.with.same.name.already.exists=已經定義了具有相同名稱的常數
refactoring.rename.search.in.global.scope=在全域範圍中搜尋

#refactoring -> rename - > automatic renamers
refactoring.rename.automatic.renamer.accessors.name=重命名存取器(&C)
refactoring.rename.automatic.renamer.field.accessors.dialog.title=重命名存取器
refactoring.rename.automatic.renamer.field.accessors.dialog.description=將具有以下名稱的屬性存取器重命名為:
refactoring.rename.automatic.renamer.field.accessors.entity.name=存取器


refactoring.rename.automatic.renamer.class.name=重命名類(&C)
refactoring.rename.automatic.renamer.class.dialog.title=重命名類
refactoring.rename.automatic.renamer.class.dialog.description=將具有以下名稱的類重命名為:
refactoring.rename.automatic.renamer.class.entity.name=類

refactoring.rename.entity.name.inheritor=繼承者/檔案
refactoring.rename.inheritors.and.related.files.with.the.following.names.to=將具有以下名稱的繼承者和相關檔案重命名為:


#refactoring->inline variable
refactoring.inline.variable.cannot.extract.value=無法提取變數 ''\${0}'' 的值
refactoring.inline.cannot.find.variable.to.inline=無法找到要內聯的變數
refactoring.inline.variable.no.occurrences=沒有符合項可以被安全地內聯

#refactoring->inline function
refactoring.inline.function.title=內聯{0}重構
refactoring.inline.function.all.invocations.and.remove.the.method=全部內聯並移除{0}(&A)
refactoring.inline.function.all.invocations.keep.the.method=全部內聯並保留{0}(&E)
refactoring.inline.function.this.invocation.only.and.keep.the.method=僅內聯此調用並保留{0}(&K)
refactoring.inline.function.command=正在內聯{0}
refactoring.inline.function.cannot.inline.function.with.global.usage=無法內聯{0}和 <code>global</code> 用法
refactoring.inline.function.not.accessible.from.caller.site=無法從調用者站點存取成員引用 <code>{0}</code>
refactoring.inline.function.cannot.parse.function.body=無法解析函數體
refactoring.inline.function.cannot.inline.library.function=無法內聯庫函數
refactoring.inline.function.only.static.method.is.supported=僅支援 static 方法
refactoring.inline.function.reference.is.recursive=不支持遞歸調用
refactoring.inline.function.inline.function.refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow=當 return 語句中斷執行流程時，不支持內聯函數重構
refactoring.inline.function.parent.reference.unresolved=<code>parent</code> 類引用在 {0} 中未解析
refactoring.inline.function.yield.found.in.function.body=在函數體中找到 <code>yield</code> 用法

#refactoring->inline constant
refactoring.inline.constant.name=內聯常數
refactoring.inline.constant.command=內聯常數
refactoring.inline.constant.this.reference.only=僅內聯此引用並保留常數
refactoring.inline.constant.all.references.and.remove=全部內聯並移除常數
refactoring.inline.constant.all.references.and.keep=全部內聯並保留常數
refactoring.inline.constant.cannot.extract.value=無法提取常數的值
refactoring.inline.constant.is.never.used=常數 {0} 從未使用
refactoring.inline.constant.multiple.declarations=還有其他具有相同名稱的常數宣告。

#refactoring -> extact method/function
refactoring.extract.method.name=提取函數/方法
refactoring.extract.method.error.selected.block.should.represent.a.set.of.statement.or.an.expression=所選塊應代表一組語句或表達式。
refactoring.extract.method.error.a.set.of.statements.should.be.from.the.same.code.block=一組語句應來自同一程式碼塊。
refactoring.extract.method.error.there.are.break.continue.operators.which.can.interrupt.execution=存在會中斷執行的 break/continue 運算符。
refactoring.extract.method.error.inconsistent.return.points.in.selected.code.fragment=所選程式碼段中的返回點不一致。
refactoring.extract.method.tooltip=輸入 $name = 'init'
PhpExtractMethodDialog.extract.method=提取方法
PhpExtractMethodDialog.extract.function=提取函數
PhpExtractMethodDialog.visibility=可見性:
PhpExtractMethodDialog.public=public(&B)
PhpExtractMethodDialog.protected=protected(&T)
PhpExtractMethodDialog.private=private(&V)
PhpExtractMethodDialog.method=方法:
PhpExtractMethodDialog.function=函數:
PhpExtractMethodDialog.name=名稱(&A):
PhpExtractMethodDialog.declare.static=宣告 static(&S)
PhpExtractMethodDialog.generate.php.doc=生成 PhpDoc(&G)
PhpExtractMethodDialog.parameters=參數
PhpExtractMethodDialog.signature.preview=簽名預覽
PhpExtractMethodDialog.replace.tail.break.continue.with.return=將尾“break/continue”語句取代為“return”語句(&T)
PhpExtractMethodDialog.return.output.through=通過以下方式返回輸出變數:
PhpExtractMethodDialog.return.output.through.return=return 語句(&E)
PhpExtractMethodDialog.return.output.through.ref.parameters=通過引用傳遞的參數(&P)
PhpExtractMethodDialog.transformation.options=轉換選項
PhpExtractMethodDialog.output.variables=輸出變數
PhpExtractMethodDialog.duplicates.count=檢查並取代重複項(找到 {0} 個)
PhpExtractMethodDialog.duplicates.pending=正在搜尋重複項…
refactoring.extract.method.from.duplicate.code=從重複的程式碼中提取方法

#find usages
find.options.include.child.methods.checkbox=包括覆寫/實作方法(&V)
find.field.accessors.title=搜尋存取器
find.field.accessors.text=要搜尋 ''{0}'' 的存取器嗎?
usages.show.this.self.references=顯示 $this/自引用

#refactoring -> change signature
change.signature.find.usages.of.base.interface=類 {1} 的方法 {0}\\\\n\\\\
實作了接口 {2} 的方法。\\\\n\\\\
要{3}基方法嗎?
change.signature.find.usages.of.base.class=類 {1} 的方法 {0}\\\\n\\\\
重寫了類 {2} 的方法。\\\\n\\\\
要{3}基方法嗎?
change.signature.tooltip.parameter=$name = 'init' 或 &...$array = 'init'
change.signature.tooltip.default.value=要在此方法的所有現有調用中使用的值
change.signature.error.wrong.caret.position=文本游標應置於要重構的函數的名稱處。
change.signature.usage.view.declarations.header=要重構的函數
change.signature.column.name.parameter=參數:
change.signature.column.type.parameter=類型:
change.signature.initialize.new.parameters=創建並初始化類屬性(&I)
change.signature.parameter.may.have.side.effect=用作參數“{1}”的表達式“{0}”可能會有副作用
change.signature.arg.type.miss.argument=應為 ''{0}'' 類型的參數
change.signature.arg.type.incompatible=應為 ''{0}'' 類型的參數，提供的是 ''{1}''
change.signature.visibility.not.accessible=可見性為 {1} 的{0}將無法從{2}存取

#refactoring -> pull up/push down
refactoring.pull.up.class.does.not.have.base.classes.interfaces.in.project.files={0}在專案檔案中沒有基類/接口
refactoring.pull.up.implement.method = 在實作接口的類中創建方法存根(&S)
refactoring.pull.up.validation.field.into.interface = 無法將屬性拉入接口
refactoring.pull.up.validation.static.method.into.interface = {0} 為 static，不能為 abstract。
refactoring.pull.up.private.access = {0} 存取權限將更改為 {1}
refactoring.pull.up.abstract.method = 類 {0} 將被標記為 abstract
refactoring.pull.up.conflict.duplicate.constant = {0} 將與 {1} 中的常數衝突。
refactoring.pull.up.will.not.be.accessible.in.the.target.class={0} 在目標類中將無法存取。
refactoring.pull.up.static.reference.is.not.accessible.in.the.target.class=非 static 方法 {0} 不應在外部類中靜態調用
refactoring.pull.up.may.not.be.accessible.in.the.target.class={0} 在目標類中可能無法存取。
refactoring.pull.up.is.1.and.will.not.be.accessible.in.the.target.class={0} 為 private，在目標類中將無法存取。
refactoring.push.down.method.implemented.in.interface={0} 必須被宣告為 abstract 或實作 {1}
refactoring.push.down.validation.magic.method=移動魔術方法會產生副作用

#refactoring -> move class
refactoring.move.class.name = 移動類
refactoring.move.class.title = 將類 {0} 移至命名空間(&C):
refactoring.move.class.new.file = 將類提取到單獨的檔案(&E)
refactoring.move.class.in.non.code.message=註釋和字串中的類引用
refactoring.move.class.cannot.move.anonymous.class=無法移動匿名類

#refactoring -> move namespace
refactoring.move.namespace.name=移動命名空間
refactoring.move.namespace.title=移動命名空間 {0}
refactoring.move.namespace.new.namespace=新命名空間名稱(&N):
refactoring.move.related.namespace.description=將具有相關命名空間的檔案移至新目錄:
refactoring.move.related.namespace.title=移動具有相關命名空間的檔案
refactoring.move.related.namespace.name.column=新命名空間名稱
refactoring.move.related.namespace.directory.column=新建目錄
refactoring.move.related.namespace.collect.title=收集子命名空間
refactoring.move.namespace.header.message=移動命名空間
refactoring.move.namespace.message=要移動的命名空間
refactoring.move.namespace.in.non.code.message=註釋和字串中的命名空間引用

#refactoring -> move member
refactoring.move.method.label.text.field=將成員移至類(&C)
refactoring.move.member.method.is.overridden.in.a.sublclass={0} 在子類 {1} 中被覆寫
refactoring.move.members.there.are.several.classes.with.specified.name=存在多個具有指定名稱 {0} 的類
refactoring.move.members.is.not.a.valid.class.name=\\"{0}\\" 不是有效的類名
refactoring.move.member.title=移動 static 成員
refactoring.move.member.action.name=移動成員…
refactoring.move.members.to.be.moved=要移至另一個類的成員(&B)
refactoring.move.members.preview.header=要移至另一個類的成員
refactoring.move.members.unable.to.resolve.usage.callback.found=無法解析用法: 發現回調: {0}
refactoring.move.members.unable.to.resolve.usage.late.static.binding.detected=無法解析用法: 檢測到延遲 static 綁定: {0}
refactoring.move.members.late.static.binding.detected=檢測到延遲 static 綁定: {0}
refactoring.move.members.self.from.anonymous.class=無法處理對匿名類的自引用
refactoring.move.members.late.static.binding.detected.in.doc=在文檔中檢測到延遲 static 綁定
refactoring.move.members.is.not.accessible={0} 在 {1} 中無法存取
refactoring.move.members.cannot.find.target.class=找不到類 {0}
refactoring.move.members.member.will.change.visibility.to.public=成員 {0} 會將可見性更改為 public
refactoring.move.members.method.implements.abstract.method={0} 在 {1} 中實作 abstract 方法
refactoring.move.members.method.implements.method.in={0} 在 {1} 中實作方法
refactoring.move.members.0.will.be.hidden.in.1=成員 {0} 將在 {1} 中被隱藏
refactoring.move.members.only.constants.can.be.moved.to.interface = 只有常數可以移至接口

#refactoring -> move file constant
refactoring.move.constant.title=移動常數
refactoring.move.constant.label.text.field=將常數 {0} 移至類(&C)
refactoring.move.multiple.constant.label.text.field=將 {0} 個常數移至類(&C)
refactoring.move.constant.unable.to.resolve=無法解析 {0}
refactoring.move.constant.class.already.contains.constant=類 {0} 已包含常數 {1}

#refactoring -> move function
refactoring.move.function.title=移動函數
refactoring.move.function.label.text.field=將函數 {0} 移至類(&C)
refactoring.move.multiple.functions.label.text.field=將 {0} 個函數移至類(&C)
refactoring.move.constant.class.already.contains.method=類 {0} 已包含方法 {1}
refactoring.move.function.interface.cant.contain.method=接口中不允許帶有主體的方法

#refactoring -> move instance
refactoring.move.method.cannot.move.constructor=無法移動構造函數
refactoring.move.method.cannot.move.magic.method=無法移動魔術方法
refactoring.move.instance.method=移動實例方法
refactoring.move.instance.method.action.name=移動實例方法…
refactoring.move.instance.method.preview.header=要移至另一個類的方法
refactoring.move.instance.method.this.parameter.label=將取代類 {0} 的 $this 引用的參數名稱
refactoring.move.instance.method.usage.will.not.be.accessible=用法 {0} 將無法存取。應提高方法可見性

#refactoring -> make static then move method
refactoring.make.static.then.move.method.select=將方法 ''{0}'' 移至類
refactoring.make.static.then.move.method.message=方法 ''{0}'' 將被設為 ''public static''

#refactoring -> extract interface
refactoring.extract.interface.name=提取接口
refactoring.extract.interface.title=從類 ''{0}'' 提取接口
refactoring.extract.interface.invalid.caret.location=文本游標應置於要重構的類名處。
refactoring.extract.interface.invalide.extract.from.trait=無法從特徵提取接口。
refactoring.extract.interface.no.methods=沒有要提取到接口的方法。
refactoring.extract.interface.field=接口名稱(&I):
refactoring.extract.replace.class.reference=盡可能將類引用取代為接口(&F)
refactoring.extract.interface.members.title=要構成接口的成員(&B)
refactoring.extract.interface.phpdoc.title=PhpDoc
refactoring.extract.interface.phpdoc.do.nothing=保留原樣(&A)
refactoring.extract.interface.phpdoc.copy=複製(&C)
refactoring.extract.interface.phpdoc.move=移動(&M)
refactoring.extract.interface.validation.members.modifier=對於每個提取的方法，修飾符將更改為 public。
refactoring.extract.interface.fail.to.create.file=無法創建檔案 ''{0}''。

#refactoring -> make method static
refactoring.make.method.static=將方法設為 static
refactoring.make.method.static.method.calls.found.in.static.context=在 static 上下文中找到方法調用
refactoring.make.method.static.method.converts.method.to.static=將方法轉換為 static
refactoring.make.method.static.dynamic.method.call.found=實例物件應作為參數傳遞，找到動態方法調用: {0}
refactoring.make.method.static.this.found=實例物件應作為參數傳遞，找到 $this
refactoring.make.method.static.references.to.be.changed=待變更引用 {0}
refactoring.make.method.static.doc.method.is.not.supported=不支持文檔方法
refactoring.make.method.static.method.is.overridden=方法 {0} 被覆寫
refactoring.make.method.static.object.is.needed=方法 {0} 使用未作為參數傳遞的屬性 {1}
refactoring.make.method.static.private.field.is.not.accessible=private 屬性 {0} 無法從類外部存取
refactoring.make.method.static.protected.field.is.not.accessible=protected 屬性 {0} 無法從類及其繼承者外部存取
refactoring.make.method.static.writeAccess=檢測到 {0} 寫入存取，實例物件應作為參數傳遞。
refactoring.make.method.static.magic.method=魔術方法不能設為 static
refactoring.make.method.static.add.parameters.for.fields=添加屬性參數(&P):

#actions
#action -> detect namespace roots
actions.detect.namespace.roots.notification.id=PHP PSR-0 命名空間根檢測
actions.detect.namespace.roots.notification.title=檢測 PSR-0 命名空間根
actions.detect.namespace.roots.title=正在檢測 PSR-0 命名空間根…
actions.detect.namespace.roots.finished=已完成 PSR-0 命名空間根檢測。
actions.detect.namespace.roots.no.new.roots.detected=未檢測到新的 PSR-0 命名空間根。
actions.detect.namespace.roots.view.configuration=檢視配置
actions.detect.namespace.roots.manual.configuration=手動配置
actions.detect.namespace.roots.idea.view.configuration=您可以在 '專案結構 | 模組' 中修改設定。
actions.detect.namespace.roots.from.composer.title=PSR-0/PSR-4 根
actions.detect.namespace.roots.from.composer.idea.title=源根

#action -> detect language level
actions.detect.language.level.loaded.from.composer.title=PHP 語言級別
actions.detect.language.level.loaded.from.composer.idea.title=語言級別

#action --> common settings
actions.detect.common.setting.from.composer.suggest.title=將設定與 Composer 同步?
actions.detect.common.setting.from.composer.enable=啟用同步
actions.detect.common.setting.from.composer.disable=不同步
actions.detect.common.settings.updated.from.composer.title={0} 設定已更新
actions.detect.common.settings.composer.sync.state.title=與 composer.json 的同步{0}
actions.detect.common.setting.from.composer.show.settings=顯示設定

action.detect.user.settings.state.overwritten=如果打開同步，IDE 設定(PHP 語言級別，PSR-0/PSR-4 根)可能會被覆蓋
action.detect.user.settings.state.supported=支援 PSR-0/PSR-4 根和 PHP 語言級別的同步
action.detect.user.settings.state.overwritten.short=設定可能會被覆蓋: PSR-0/PSR-4 根和 PHP 語言級別。
action.detect.settings.sync.turned.on.title=已與 composer.json 同步
action.detect.settings.sync.turned.on=PHP 語言級別已與 composer.json 同步
action.detect.composer.json.not.found.title=找不到 composer.json
action.detect.composer.json.not.found=在路徑 {0} 下找不到 composer.json
action.detect.composer.json.open=在編輯器中打開

#action -> mark directory as namespace root
actions.mark.directory.as.psr.0.root.title=要將資料夾標記為 {0} 根嗎?
actions.mark.directory.as.psr.0.root=<i>{0}</i>
actions.mark.directory.as.psr.0.root.with.prefix=<i>{0}</i>為前綴“{1}”?
actions.mark.directory.as.psr.0.root.mark.psr=標記為 {0} 根

#action - > new php base
actions.new.php.base.dialog.label.file.name=文件名:
actions.new.php.base.dialog.label.extension=檔案副檔名:
actions.new.php.base.arrows.extension.tooltip=在編輯器中按向上或向下箭頭可更改檔案副檔名
actions.new.php.base.arrows.template.tooltip=在編輯器中按向上或向下箭頭可更改模板

#action -> new php file
actions.new.php.file.action.name=PHP 檔案
actions.new.php.file.action.description=創建新的 PHP 檔案
actions.new.php.file.dialog.title=創建新的 PHP 檔案

#action -> new php class
actions.new.php.class.action.name=PHP 類
actions.new.php.class.action.description=創建新的 PHP 類
actions.new.php.class.dialog.title=創建新的 PHP 類
actions.new.php.class.dialog.label.class.name=名稱:
actions.new.php.class.dialog.label.namespace=命名空間:
actions.new.php.class.dialog.label.directory=目錄:
actions.new.php.class.dialog.label.template=模板:
actions.new.php.class.dialog.label.superclasses.container=父類
actions.new.php.class.dialog.label.superclasses.super.fqn=擴展:
actions.new.php.class.dialog.label.superinterfaces.add.interface=添加接口…
actions.new.php.class.dialog.label.superinterfaces.to.implement=實作:
actions.new.php.class.dialog.label.superinterfaces.to.implement.empty=選擇要實作的接口
actions.new.php.class.dialog.label.superinterfaces.to.extend.empty=選擇要擴展的接口
actions.new.php.class.dialog.border.title.class=類

#action -> new php test
actions.new.test.class.action.name=新建 PHP 測試
actions.new.test.class.action.description=創建新的 PHP 測試
actions.new.test.class.dialog.title=創建新的 PHP 測試
actions.new.test.class.dialog.title.named=為 {0} 創建新的 PHP 測試
actions.new.test.class.dialog.label.name=名稱:
actions.new.test.class.dialog.label.namespace=命名空間:
actions.new.test.class.dialog.label.directory=目錄:
actions.new.test.class.dialog.label.fqn=完全限定名稱:
actions.new.test.class.dialog.border.title.class.to.test=要測試的類(可選)
actions.new.test.class.dialog.border.title.test.class=測試類
actions.new.test.class.dialog.border.title.target.class.file.path=檔案路徑:
actions.new.test.class.dialog.arrows.libraries.hint=在編輯器中按向上或向下箭頭可更改測試庫
actions.new.test.class.dialog.select.methods.show.inherited.methods=顯示繼承的方法(&I)

#action -> new PHPUnit test
actions.new.phpunit.class.action.name=PHPUnit 測試
actions.new.phpunit.class.action.description=創建新的 PHPUnit 測試

#action -> generate php doc
actions.generate.php.doc.is.not.available=PHPDoc 生成在索引更新期間不可用

unnamed.variable=(未命名)
server=伺服器
#Connection -> Server Connection
connection.port.is.busy=連接埠 {0} 繁忙

#Server configuration
debug.server.import.configuration.dialog.title=從部署配置匯入
debug.server.import.configuration.preview.border.title=預覽
debug.server.import.configuration.path.to.remote.root=部署根的絕對路徑(&R):
debug.server.import.configuration.path.to.remote.root.sftp=絕對遠端根: ''{0}''
debug.server.import.configuration.path.to.remote.root.sftp.tooltip=遠端檔案的絕對路徑:<br>\\"遠端根的絕對路徑\\" . \\"根路徑\\" (來自部署設定) . \\"伺服器上的相對部署路徑\\" (來自部署路徑映射)
debug.server.import.configuration.path.to.remote.root.mounted=本地: ''{0}'' -> 遠端: ''{1}''
debug.server.import.configuration.path.to.remote.root.mounted.label=已掛載資料夾的遠端路徑(&R):
debug.server.import.configuration.path.to.remote.root.mounted.tooltip=遠端檔案的絕對路徑:<br>\\"已掛載資料夾的遠端路徑\\" . \\"伺服器上的相對部署路徑\\" (來自部署路徑映射)
debug.server.import.configuration.deployment=部署(&D):
debug.server.import.configuration.local=本地(&L)
debug.server.import.configuration.mounted=已掛載(&M)

debug.server.import.configuration.local.file.path=本地檔案路徑:
debug.server.import.configuration.project=專案(&P):
debug.server.import.from.deployment.deployment.configurations.message=找到具有相關路徑映射的部署配置。
debug.server.import.from.deployment.no.deployment.configurations.message=找不到合適的部署配置
debug.server.import.from.deployment.no.deployment.configurations.tooltip=配置部署根(如果不為空)
debug.server.import.from.deployment.deployment.root.label=部署根(&R):
debug.server.import.from.deployment.radio=從部署匯入映射(&I)
debug.server.manually.select.file.or.project=手動選擇本地檔案或專案(&M)
debug.server.manually.select.file.message=選擇一個專案或檔案進行調試
debug.server.select.file.mapping=配置本地檔案路徑
debug.server.detect.path.mappings.from.deployment.progress=正在為 ''{0}'' 專案分析路徑映射
debug.server.detect.path.mappings.from.deployment=正在檢測現有路徑映射…
debug.server.can.not.detect.path.mappings.from.deployment=無法評估路徑映射: 未選擇目標部署伺服器

#Debug
debug.accept.connection=接受
debug.ignore.connection=忽略
debug.incoming.connection.title.0=來自 {0} 的傳入連接
debug.path.on.server=伺服器上的絕對路徑
debug.error.cannot.modify.value=無法修改值
debug.error.cannot.evaluate.variables=無法評估變數
debug.error.cannot.evaluate.expression0=無法評估表達式 ''{0}''
debug.error.cannot.evaluate.expression=無法評估表達式
debug.process.cannot.find.file.in.project=在專案中找不到路徑為 ''{0}'' 的檔案
debug.process.cannot.find.server.name=找不到源位置。名稱為 ''{0}'' 的伺服器不存在。
debug.process.status.disconnected=已斷開連接
debug.process.status.wait=正在等待與{0} ''{1}'' 的傳入連接
debug.process.status.connected=已連接
debug.process.console.error.format={0}: {1}，{2} 中的第 {3} 行\\\\n\\\\

debug.mapping.resolve.dialog.stop.debugger=停止調試器
debug.zend.error.title.cannot.accept.external.xdebug.connection=無法接受外部 Xdebug 連接
debug.zend.required.protocol.version.0.or.higher=所需協議版本為 ''{0}'' 或更高版本
debug.error.title.cannot.accept.external.0.connection=無法接受外部 {0} 連接
debug.zend.cannot.accept.incoming.connection=無法接受來自 Zend Debugger 的傳入連接
debug.zend.debugger.settings.broadcasting=Zend Debugger 設定廣播
debug.zend.debugger=Zend 調試器
debug.xdebug=Xdebug
debug.not.installed=<未安裝>
debug.process.cannot.find.file.link=更多資訊
debug.process.cannot.find.file=在本地找不到檔案 ''{0}''。\\\\n\\\\
要修復，請通過環境變數 PHP_IDE_CONFIG 設定伺服器名稱，然後重新啟動調試會話。
debug.process.cannot.find.local.file=在伺服器 {0} 上找不到檔案的本地副本\\\\n\\\\
本地路徑為 {1}
debug.process.cannot.find.path.mapping=遠端檔案路徑 ''{0}'' 未映射到專案中的任何檔案路徑
debug.process.script.outside.project=腳本 ''{0}'' 在專案外部。
debug.process.cant.compute.source.position=無法計算源位置。腳本 ''{0}'' 未與任何文本檔案類型關聯。
debug.edit.path.mappings=點擊以設定路徑映射
debug.configure.servers=配置伺服器
debug.settings.broadcasting.port=設定廣播連接埠:
debug.settings.auto.detect.ide.host=自動檢測 IDE IP:
debug.debug.port=調試連接埠:
debug.error=錯誤
debug.process.cannot.find.remote.copy.local.file=專案 ''{0}'' 中的檔案路徑未映射到伺服器上的任何檔案路徑
debug.cannot.map.local.file=檔案路徑未映射到伺服器上的任何檔案路徑。編輯路徑映射以解決此問題。
debug.resolve.mapping.problem=解決路徑映射問題
debug.cannot.start.listening.for.connections.from.0=無法開始偵聽來自 ''{0}'' 的連接
debug.cannot.start=無法啟動 ''{0}''
debug.stop.listen.debug.connections=停止偵聽 PHP 調試連接
debug.start.listen.debug.connections=開始偵聽 PHP 調試連接
debug.breakpoint.was.resolved=此處的調試會話已暫停，因為 ''{0}'' 處的斷點已被解析到此位置。<br/>您可以<a href=\\"disable\\">禁用</a>斷點解析或<a href=\\"more\\">了解詳情</a>。<a href=\\"dontshow\\">不再顯示</a>
debug.breakpoint.resolved.disabled=斷點解析已被禁用，從下一個調試會話開始將不會解析斷點。 您可以稍後在 <a href=\\"open\\">PHP|調試</a>下將其啟用。
debug.breakpoint.resolved.notify.disabled=斷點解析通知已被禁用。您可以在 <a href=\\"open\\">PHP|調試|高級設定</a>下將其啟用。
debug.log.invalid.xdebug.message=由於 Xdebug 訊息無效，無法在斷點處停止。\\\\n\\\\
要解決此問題，請切換到穩定版本的 Xdebug 或使用 'xdebug.remote_log' 選項收集日誌並創建錯誤報告。 
debug.log.stop=停止於 (''{0}'':{1})
debug.log.path.mapping.remote.local=遠端: ''{0}'' <-> 本地: ''{1}''
debug.log.path.mapping.remote.extracted=遠端: ''{0}'' <-> 提取: ''{1}''
debug.log.stack.frame=框架: {0}:{1}，{2}
debug.log.connection.was.terminated=調試連接在 ''{0}'':''{1}'' 上意外終止
debug.log.cant.register.breakpoint.no.remote=無法註冊斷點。沒有本地路徑 ''{0}'' 的路徑映射
debug.log.cant.register.breakpoint.no.template.mapping=無法註冊斷點。沒有到 PHP 行 ''{0}'' 的映射
debug.log.exception.break=異常中斷: {0} ({1})
debug.file.is.ignored=檔案 ''{0}'' 被跳過。
debug.edit.ignored.paths.list=<a href=\\"#a\\">編輯</a>跳過的路徑。
debug.composite.value.presentation=[{0}]
debug.error.unknown.debugger.id=未檢測到調試器擴展
debug.error.wrong.debugger.id=不支持 {0}
debug.type.array=陣列
debug.type.resource=資源
debug.type.int=int
debug.type.float=浮點
debug.xdebug.error.unsupported.protocol.version=不支持的 Xdebug 協議版本
debug.php.line.breakpoint.title=PHP 行斷點
debug.php.exception.breakpoint.title=PHP 異常斷點
debug.php.exception.breakpoint.not.supported=載入的調試擴展不支持異常斷點
debug.php.exception.breakpoint.zend.not.supported=Zend Debugger 不支持異常斷點
debug.php.exception.breakpoint.dialog.title=添加異常斷點
debug.php.exception.breakpoint.exception.name=異常名稱:
debug.php.method.breakpoint.title=PHP 方法斷點
debug.php.method.breakpoint.dialog.title=添加方法斷點
debug.php.method.breakpoint.zend.not.supported=Zend Debugger 不支持方法斷點
debug.php.breakpoint.failed.to.register=無法註冊斷點，請嘗試將其禁用並重新啟用。
debug.error.cannot.parse.ssh.connection=無法從 $_SERVER[''SSH_CONNECTION''] 解析連接埠: ''{0}''
debug.error.cannot.parse.server.name.for.external.connection=無法為外部 {0} 連接解析伺服器名稱。
debug.error.cannot.parse.server.name=要修復，請在遠端伺服器上創建環境變數 <i><b>PHP_IDE_CONFIG</b></i>。<br/><br/><i>Windows:</i> 設定 PHP_IDE_CONFIG=\\"serverName=SomeName\\"<br/> <i>Linux / Mac OS X:</i> 匯出 PHP_IDE_CONFIG=\\"serverName=SomeName\\"。
debug.error.server.name.is.empty=<i><b>$_SERVER[\\"SERVER_NAME\\"]</i></b> 為空，這可能是 Web 伺服器配置錯誤所致。<br/><br/><i>Nginx:</i> 將 fastcgi 參數添加至 nginx 配置，<a href=\\"http://wiki.nginx.org/PHPFcgiExample\\">更多</a><br/><i>Apache:</i> 為當前 VirtualHost 配置 ServerName，<a href=\\"https://httpd.apache.org/docs/2.4/vhosts/name-based.html\\">更多</a>

debug.php.external.connection.finished.warning.title=調試會話已完成且未暫停
debug.php.external.connection.finished.warning=這可能是由於路徑映射配置錯誤或本地和遠端專案未同步。<br/><br/>要找出問題，請在 <b><i><a href=\\"servers\\">PHP|伺服器</a></i></b>下檢查 ''{0}'' 伺服器的路徑映射配置，或啟用 <b><i><a href=\\"break\\">''在 PHP 腳本中的第一行中斷''</a></i></b> 選項(位於<i>執行</i>選單下)。<br/><a href=\\"ignore\\">不再顯示</a>
debug.php.external.connection.finished.break.at.first.line.title=PHP 調試配置
debug.php.external.connection.finished.break.at.first.line=<b><i>'在第一行中斷'</i></b> 選項已啟用

debug.process.smart.step.into.popup=單步進入函數
debug.process.smart.step.into.function.evaluation.error =無法評估目標函數。將執行“單步跳入”。
debug.process.smart.step.into.function.was.not.executed=尚未調用所選函數。

#rest client
debug.rest.client.error.cannot.evaluate.server.name.title=無法通過伺服器名稱找到對應的“PHP|伺服器”
debug.rest.client.error.cannot.evaluate.server.name=無法評估 '$_SERVER['SERVER_NAME']'。請確保為您的 Web 伺服器配置了正確的伺服器名稱。<br>點擊此<a href=\\"help\\">鏈接</a>獲取更多資訊。

# custom actions
debug.function.was.added.to.skip.list=''{0}'' 已添加到跳過列表。
debug.action.copy.as.title=將變數複製為 ''{0}''
debug.action.copy.as.was.fail.can.not.get.full.name=無法將變數複製為 ''{0}''，無法評估完整的變數名
debug.action.copy.value.as.text=將值複製為…

debug.label.select.a.project.or.a.file.to.debug=選擇一個專案或檔案進行調試
debug.label.select.a.project.to.debug=選擇一個專案進行調試
debug.label.file.path.on.server=伺服器上的檔案路徑:
debug.label.file.path.in.project=專案中的檔案路徑:
debug.checkbox.can.accept.external.connections=可以接受外部連接
debug.checkbox.ignore.z.ray.system.requests=忽略 Z-Ray 系統請求
debug.label.max.simultaneous.connections=最大同時連接數:

# templates
template.debug.path.to.output.folder.descr=指定快取目錄路徑
template.debug.path.to.output.folder=快取目錄路徑
template.debug.cache.path=快取路徑:
template.debug.cache.dir.is.incorrect=模板調試: 在設定中指定的快取目錄路徑無效
template.debug.cache.dir.is.not.specified=模板調試: 未在設定中指定快取目錄路徑
template.debug.php.file.not.found=模板調試: 未找到 {0} 的相應 PHP 檔案

postfix.template.provider.display.name=PHP

template.smart.completion.function.parameters.description=智能函數參數補全

debug.expression.evaluation.fail=由於返回值未知，無法評估表達式

dbgp.proxy=Xdebug 代理
dbgp.proxy.port=代理連接埠
dbgp.proxy.host=代理主機
dbgp.proxy.ide.key=IDE 鍵
dbgp.proxy.ide.register.success=IDE 已成功使用 IDE 鍵 ''{0}'' 註冊
dbgp.proxy.ide.unregister.success=IDE 已成功註銷
dbgp.proxy.ide.register.error=無法使用 IDE 鍵 ''{0}'' 註冊 IDE
dbgp.proxy.cannot.connect.to.host=無法連接到主機 ''{0}''
dbgp.proxy.cannot.connect.to.xdebug.proxy=無法連接到 ''{0}:{1}'' 上的 Xdebug 代理
dbgp.proxy.sending.request.to.xdebug.proxy=正在將請求发送到 Xdebug 代理…

profiler.xdebug.task.title=分析 Xdebug 分析器快照
profiler.xdebug.task.parsing=正在解析 ''{0}''
profiler.xdebug.file.chooser.title=選擇 Xdebug 分析器快照

profiler.view.execution.statistics.title=執行統計
profiler.view.call.tree.title=調用樹
profiler.view.callees.title=被調用方
profiler.view.callers.title=調用方
profiler.column.time.title=時間
profiler.column.memory.title=內存(B)
profiler.column.own.memory.title=自身記憶體(B)
profiler.column.own.time.title=自用時間
profiler.column.invocation.count.title=調用
profiler.column.invocation.callable=可調用
profiler.column.script=腳本

profiler.measurement.unit.second=秒
profiler.measurement.unit.second.short=秒
profiler.measurement.unit.millisecond=毫秒
profiler.measurement.unit.millisecond.short=毫秒
profiler.measurement.unit.microsecond=微秒
profiler.measurement.unit.microsecond.short=µs
profiler.button.refresh=刷新
profiler.label.time=時間:

#phpunit
php.uml.provider.presentable.name=PHP 類圖

#coverage
coverage.is.not.supported.for.selected.run.profile=程式碼覆蓋率與所選執行配置檔案不相容

#UI

#run configurations -> components -> command line
PhpCommandLineConfigurationEditor.interpreter.options.editor.dialog.caption=解釋器選項
PhpCommandLineConfigurationEditor.command.line=命令行
PhpCommandLineConfigurationEditor.field.interpreter.options=解釋器選項:
PhpCommandLineConfigurationEditor.field.custom.working.directory=自訂工作目錄:
PhpCommandLineConfigurationEditor.field.environment.variables=環境變數:

#run configurations -> components -> test runner
PhpUnitTestRunnerConfigurationEditor.test.runner=測試執行程序
PhpUnitTestRunnerConfigurationEditor.scope=測試範圍:
PhpUnitTestRunnerConfigurationEditor.scope.directory=目錄
PhpUnitTestRunnerConfigurationEditor.scope.class=類
PhpUnitTestRunnerConfigurationEditor.scope.method=方法
PhpUnitTestRunnerConfigurationEditor.scope.xml=在配置檔案中定義
PhpUnitTestRunnerConfigurationEditor.field.directory=目錄:
PhpUnitTestRunnerConfigurationEditor.field.method=方法:
PhpUnitTestRunnerConfigurationEditor.field.class=類:
PhpUnitTestRunnerConfigurationEditor.field.file=檔案:
PhpUnitTestRunnerConfigurationEditor.use.alt.configuration.file=使用替代配置檔案(&U):
PhpUnitTestRunnerConfigurationEditor.use.alt.bootstrap.file=使用替代啟動檔案(&U):
PhpUnitTestRunnerConfigurationEditor.field.test.runner.options=測試執行程序選項(&O):
PhpUnitTestRunnerConfigurationEditor.field.test.runner.coverage.engine=首選覆蓋率引擎:
PhpUnitTestRunnerConfigurationEditor.dialog.caption.test.runner.options=測試執行程序選項

# run configurations
PhpScripRunConfigurationEditor.configuration.display.name=PHP 腳本
PhpScripRunConfigurationEditor.configuration.description=PHP 腳本配置
PhpScripRunConfigurationEditor.file=檔案:
PhpScripRunConfigurationEditor.arguments=實參:
PhpScripRunConfigurationEditor.arguments.caption=實參

PhpHttpRequestRunConfiguration.configuration.display.name=PHP HTTP 請求
PhpHttpRequestRunConfiguration.configuration.description=HTTP 請求配置
PhpHttpRequestRunConfiguration.error.fetch.result=響應正文不可用
PhpHttpRequestRunConfiguration.error.server.is.not.specified=找不到名稱為 ''{0}'' 的遠端伺服器
PhpHttpRequestRunConfiguration.error.host.is.not.specified=伺服器 ''{0}'' 的主機未指定或無效
PhpHttpRequestRunConfiguration.error.url.is.not.specified=URL 未指定或無效: ''{0}''。
PhpHttpRequestRunConfiguration.error.server.configuration=無法執行 HTTP 請求: ''{0}''。請在“PHP|伺服器”下檢查伺服器配置。

RunConfigurationEditor.configuration=配置
RunConfigurationEditor.server=伺服器(&S):
RunConfigurationEditor.error.server.is.not.selected=未選擇伺服器
RunConfigurationEditor.error.server.is.not.exist=名稱為 ''{0}'' 的伺服器不存在

PhpWebAppRunConfigurationEditor.configuration.display.name=PHP Web 頁面
PhpWebAppRunConfigurationEditor.configuration.description=PHP Web 頁面配置
PhpWebAppRunConfigurationEditor.startUrl=起始 URL(&U):
PhpWebAppRunConfigurationEditor.browser=瀏覽器(&B):
PhpWebAppRunConfigurationEditor.malformed.start.url=起始 URL 的格式錯誤 - {0}

PhpRemoteDebugRunConfigurationEditor.configuration.display.name=PHP 遠端調試
PhpRemoteDebugRunConfigurationEditor.configuration.description=PHP 調試配置
PhpRemoteDebugRunConfigurationEditor.server.label=伺服器(&E)：
PhpRemoteDebugRunConfigurationEditor.session.id.label=IDE 鍵(會話 ID)(&K):
PhpRemoteDebugRunConfigurationEditor.auto.config=通過 IDE 鍵篩選調試連接
PhpRemoteDebugRunConfigurationEditor.session.id.cannot.be.empty=IDE 鍵(會話 ID)不能為空
PhpRemoteDebugRunConfigurationEditor.zero.configuration.used.title=已開始偵聽傳入 PHP 調試連接
PhpRemoteDebugRunConfigurationEditor.filter.connections.help.title=高級選項
PhpRemoteDebugRunConfigurationEditor.filter.connections.help=適用於複雜伺服器設定，例如同一主機連接埠上有多個應用程式。<p/>保持未選中狀態以自動檢測配置，或使用<i>“偵聽調試連接”</i>操作。
PhpRemoteDebugRunConfigurationEditor.filter.connections.help.link=閱讀更多資訊
PhpRemoteDebugRunConfigurationEditor.zero.configuration.used=沒有為 <i>''{0}''</i> 執行配置指定<i>伺服器</i>，因此 PhpStorm 將偵聽所有傳入調試連接。<br/>查看<a href=\\"zero_config\\">零配置調試</a>獲取更多資訊。<br/><br/>要停止偵聽調試連接，請使用<a href=\\"stop\\">執行|停止偵聽 PHP 調試連接</a>。
PhpRemoteDebugRunConfigurationEditor.zero.configuration.is.already.used=“偵聽傳入調試連接”已啟用，不會發生任何變化。<br/>查看<a href=\\"zero_config\\">零配置調試</a>獲取更多資訊。<br/><br/>要停止偵聽調試連接，請使用<a href=\\"stop\\">執行|停止偵聽 PHP 調試連接</a>。
PhpRemoteDebugRunConfigurationEditor.stop.zero.configuration.title=已停止偵聽傳入 PHP 調試連接
PhpRemoteDebugRunConfigurationEditor.stop.zero.configuration=PhpStorm 已停止偵聽傳入調試連接。

PhpBuiltInWebServerRunConfigurationEditor.configuration.display.name=PHP 內建 Web 伺服器
PhpBuiltInWebServerRunConfigurationEditor.configuration.description=PHP 內建 Web 伺服器配置
PhpBuiltInWebServerRunConfigurationEditor.title=伺服器配置
PhpBuiltInWebServerRunConfigurationEditor.host=主機:
PhpBuiltInWebServerRunConfigurationEditor.port=連接埠:
PhpBuiltInWebServerRunConfigurationEditor.document.root=文檔根:
PhpBuiltInWebServerRunConfigurationEditor.use.router.script=使用 router 腳本:

PhpDebugConfigurable.ignore.external.connections.through.unregistered.server.configurations.label=通過未註冊的伺服器配置忽略外部連接
PhpDebugConfigurable.xdebug.resolve.breakpoints=如果斷點在當前行不可用，則解析斷點(Xdebug 2.8+)
PhpDebugConfigurable.xdebug.force.break.no.path.mapping=未指定路徑映射時，在第一行強制中斷
PhpDebugConfigurable.xdebug.force.break.when.outside.project=當腳本在專案外部時，在第一行強制中斷
PhpDebugConfigurable.xdebug.debug.port=Xdebug 調試連接埠
PhpDebugConfigurable.zend.debug.port=Zend Debugger 調試連接埠
PhpDebugConfigurable.zend.settings.broadcasting.port=Zend Debugger 設定廣播連接埠
PhpDebugConfigurable.zend.settings.ide.hosts=Zend Debugger IDE 主機
PhpDebugConfigurable.zend.settings.ide.hosts.detect=正在檢測…
PhpDebugConfigurable.zend.settings.ide.hosts.detect.progress=正在檢測 Zend Debugger 的 IP…
PhpDebugConfigurable.xdebug=Xdebug
PhpDebugConfigurable.zend.debugger=Zend 調試器
PhpDebugConfigurable.safe.evaluation.mode=值提示和監視框架下的安全評估模式
PhpDebugConfigurable.import.use.statements=從評估上下文匯入命名空間和 'use' 語句
PhpDebugConfigurable.show.array.children.in.repl=在調試控制台中顯示陣列和物件子級
PhpDebugConfigurable.external.connections=外部連接
PhpDebugConfigurable.pass.required.configuration.options=通過命令行傳遞所需配置選項(仍需要手動啟用調試擴展)
PhpDebugConfigurable.advanced.settings=高級設定
PhpDebugConfigurable.notify.session.stopped.without.pause=在調試會話完成而不暫停時通知
PhpDebugConfigurable.notify.resolved.breakpoint=通知是否將斷點解析為另一行(Xdebug 2.8+)
PhpDebugConfigurable.detect.path.mappings.from.deployment=檢測部署配置的路徑映射
PhpDebugConfigurable.break.at.first.line=在 PHP 腳本中的第一行中斷
PhpDebugConfigurable.evaluation=評估
PhpDebugConfigurable.zero.configuration=預配置
PhpDebugConfigurable.zero.configuration.install.debugger.php.instruction=1. 安裝
PhpDebugConfigurable.zero.configuration.install.xdebug.php.instruction=Xdebug
PhpDebugConfigurable.zero.configuration.install.php.instruction=或
PhpDebugConfigurable.zero.configuration.install.zend.debugger.php.action=Zend 調試器
PhpDebugConfigurable.zero.configuration.install.zend.debugger.php.instruction=在 Web 伺服器上。
PhpDebugConfigurable.zero.configuration.install.php.validate.action=驗證
PhpDebugConfigurable.zero.configuration.install.php.validate=Web 伺服器上的調試器配置。
PhpDebugConfigurable.zero.configuration.install.toolbar.instruction.label=2. 安裝
PhpDebugConfigurable.zero.configuration.install.toolbar.instruction=瀏覽器工具欄或小書籤。
PhpDebugConfigurable.zero.configuration.listen.for.connections=3. 啟用 PHP 調試連接偵聽:
PhpDebugConfigurable.zero.configuration.start.session=4. 使用工具欄或小書籤在瀏覽器中啟動調試會話。
PhpDebugConfigurable.zero.configuration.tutorial=有關更多資訊，請參見
PhpDebugConfigurable.zero.configuration.tutorial.action=“零配置調試”教程

PhpDebugConfigurable.zero.configuration.listen.for.connections.action=開始偵聽
PhpDebugConfigurable.zero.configuration.stop.listen.for.connections.action=停止偵聽
PhpDebugConfigurable.remote.debug.listen.for.connections=3. 啟動“PHP 遠端調試”執行配置。
PhpDebugConfigurable.web.page.pre.config.title=調試預配置
PhpDebugConfigurable.web.page.listen.for.connections=2. 啟動“PHP Web 頁面”執行配置。

PhpDebugSkippedPathsConfigurable.display.name=跳過的路徑
PhpDebugSkippedPathsConfigurable.notify.about.skipped.files=通知跳過的檔案
PhpDebugSkippedPathsConfigurable.column.title=跳過的路徑

PhpFrameworksCommonConfigurable.display.name=框架

PhpStepFiltersConfigurable.title.methods=方法
PhpStepFiltersConfigurable.specify.method.name=指定方法名稱
PhpStepFiltersConfigurable.add.method=添加方法
PhpStepFiltersConfigurable.skip.magic.methods=跳過魔術方法
PhpStepFiltersConfigurable.skip.constructors=跳過構造函數
PhpStepFiltersConfigurable.skipped.methods=跳過的方法
PhpStepFiltersConfigurable.title.files=檔案
PhpStepFiltersConfigurable.skipped.files=跳過的檔案
PhpStepFilters.log.frame=框架已被跳過。函數名稱: {0}。遠端檔案 URL: {1}

PhpServerConfigurable.shared=共享(&S)
PhpServerConfigurable.host=主機
PhpServerConfigurable.host.label=主機(&H):
PhpServerConfigurable.port=連接埠
PhpServerConfigurable.port.label=連接埠(&P)
PhpServerConfigurable.debugger.label=調試器(&D)

# web server validation for debug
php.web.server.validation.title=驗證 Web 伺服器上的調試器配置
php.web.server.validation.action.text=Web 伺服器調試驗證
php.web.server.validation.local.web.server.radio=本地 Web 伺服器或共享資料夾(&L)
php.web.server.validation.remote.web.server.radio=遠端 Web 伺服器(&R)
php.web.server.validation.local.path.to.script=創建驗證腳本的路徑(&P):
php.web.server.validation.local.path.to.script.tooltip=所選路徑應可通過 Web 伺服器存取
php.web.server.validation.url.to.validation.script=驗證腳本的 URL(&U):
php.web.server.validation.url.to.validation.script.tooltip=所選 Web 路徑將用於執行驗證腳本
php.web.server.validation.deployment.server=部署伺服器(&D):
php.web.server.validation.deployment.server.tooltip=所選伺服器會用於將驗證腳本部署到遠端伺服器
php.web.server.validation.process.title=驗證 Web 伺服器
php.web.server.validation.dialog.validate.button=驗證(&V)
php.web.server.validation.chose.path.to.script=選擇驗證腳本的路徑
php.web.server.validation.chose.path.to.script.description=選擇本地資料夾以創建驗證腳本
php.web.server.validation.invalid.path.to.script=驗證目錄的路徑無效
php.web.server.validation.configure.local=請配置驗證腳本的本地和 Web 路徑
php.web.server.validation.configure.remote=請配置驗證腳本的路徑並選擇部署伺服器
php.web.server.validation.failed.to.find.web.path=請配置驗證腳本的 Web 路徑
php.web.server.validation.failed.to.find.deployment.settings=無法找到伺服器的部署設定
php.web.server.validation.failed.to.map.deployment.folder=請為驗證目錄配置遠端路徑映射
php.web.server.validation.failed.to.map.deployment.folder.to.web=請為驗證目錄配置 Web 路徑映射
php.web.server.validation.uploading.validation.script=正在將驗證腳本上傳至 {0}
php.web.server.validation.failed.to.deploy.validation.script=無法將驗證腳本部署到伺服器
php.web.server.validation.failed.to.fetch.script.result=無法提取驗證腳本的結果
php.web.server.validation.script.result.is.empty=驗證腳本的結果為空
php.web.server.validation.script.result.wrong.format=驗證腳本的結果具有意外格式
php.web.server.validation.script.local.result.path.mapping.check=請檢查是否為 <b>''{0}''</b> 目錄正確配置了驗證腳本的 Web 路徑
php.web.server.validation.script.result.path.mapping.check=請檢查是否在部署設定中為 <b>''{0}''</b> 目錄正確配置了遠端和 Web 路徑映射
php.web.server.validation.failed.to.execute.script=指定的 URL 不可到達，原因是: ''{0}''
php.web.server.validation.configuration.files=<b>已載入的 php.ini:</b> {0}
php.web.server.validation.additional.configuration.files=<b>已解析的其他 .ini 檔案:</b> {0}
php.web.server.validation.no.configuration.files=找不到 php.ini 檔案
php.web.server.validation.server.name=<b>伺服器名稱:</b> {0}
php.web.server.validation.server.name.is.empty=伺服器名稱為空
php.web.server.validation.server.name.is.empty.description=伺服器名稱對於 PhpStorm 中的標識是必要的。<br>請在 Web 伺服器配置檔案中進行配置。
php.web.server.validation.no.debugger.extension=未載入調試擴展
php.web.server.validation.multi.debugger.extension=Xdebug 和 Zend Debugger 擴展均已載入
php.web.server.validation.multi.debugger.extension.description=只有一個調試器擴展可在 php.ini 中載入。
php.web.server.validation.loaded.debugger.extension=<b>調試器擴展:</b> {0}
php.web.server.validation.xdebug.debugger.host=<b>遠端主機:</b> {0}
php.web.server.validation.xdebug.debugger.localhost=儘管伺服器主機可能不在本地，但遠端主機仍配置為 ''{0}''
php.web.server.validation.xdebug.debugger.host.remote.addr=<br/><br/>在 php.ini 檔案中，將 <b>''{0}''</b> 設為 <i>''{1}''</i> 或自 Web 伺服器可見的本地機器 IP 地址。
php.web.server.validation.xdebug.debugger.host.description=正在執行調試器<b>客戶端</b>的主機。
php.web.server.validation.xdebug.zend.extension.load=Xdebug 必須通過 'zend_extension' 而不是 'extension' 載入
php.web.server.validation.xdebug.zend.extension.load.description=在 php.ini 檔案中使用 <b>'zend_extension=path_to_xdebug.so'</b> 行以載入 Xdebug 擴展。
php.web.server.validation.xdebug.port=<b>遠端連接埠:</b> {0}
php.web.server.validation.xdebug.port.require.sudo=<b>遠端連接埠:</b> {0}，需要根權限才能使用
php.web.server.validation.xdebug.port.require.sudo.description=要在 Linux 和 Mac 上使用小於 1024 的連接埠，必須具有根權限。
php.web.server.validation.xdebug.wrong.port.format=<b>Xdebug 連接埠無效:</b> ''{0}''
php.web.server.validation.xdebug.wrong.port=Xdebug 連接埠(''{0}'')與“PHP->調試 IDE”設定(''{1}'')不同
php.web.server.validation.xdebug.wrong.port.description=來自 php.ini (<b>{0}</b>)的 Xdebug 連接埠應與在 IDE 內(在 <b>PHP->調試</b>下)配置的連接埠相同。
php.web.server.validation.xdebug.remote.is.not.enable=遠端調試未啟用
php.web.server.validation.xdebug.remote.is.not.enable.description=將 <b>''{0}''</b> 行添加到 php.ini 檔案。
php.web.server.validation.xdebug3.option.in.invalid.mode=''{0}'' 選項設定為 ''{1}''，這對於 xdebug3 是無效模式。
php.web.server.validation.xdebug.remote.autostart.description=調試會話將嘗試為每個請求啟動。
php.web.server.validation.xdebug3.start.with.request.description=調試會話將嘗試根據相應配置自動啟動。
php.web.server.validation.xdebug3.option.is.enabled.message=<b>{0}:</b> 選項設定為 ''{1}''。
php.web.server.validation.xdebug.option.is.not.enabled.description=<b>{0}:</b> 選項未啟用
php.web.server.validation.xdebug3.start.upon.error.description=調試會話將嘗試根據相應配置在錯誤時自動啟動。
php.web.server.validation.xdebug.option.is.enabled=<b>{0}:</b> 選項已啟用
php.web.server.validation.xdebug3.discover.client.with.discover.header=根據 <b>$_SERVER[''{0}'']</b> 中的值，Xdebug 將嘗試自動連接到客戶端。若失敗，則以空的 <b>''xdebug.client_discovery_header''</b> 回到 <b>''xdebug.discover_client_host''</b>。
php.web.server.validation.xdebug3.discover.client=根據 <b>$_SERVER['HTTP_X_FORWARDED_FOR']</b> 和 <b>$_SERVER['REMOTE_ADDR']</b> 中的值，Xdebug 將嘗試自動連接到客戶端。若失敗，則回到 <b>'xdebug.client_host'</b>。
php.web.server.validation.xdebug3.discover.client.message=<b>發現客戶端主機:</b> xdebug 將嘗試自動提取客戶端主機。
php.web.server.validation.xdebug.option.is.ignored.description=<b>{0}:</b> 選項將被忽略。
php.web.server.validation.xdebug.remote.mode.jit=<b>遠端模式:</b> 'jit'
php.web.server.validation.xdebug.remote.mode.jit.description=調試會話將僅在出現錯誤後初始化。
php.web.server.validation.xdebug.remote.mode.req=<b>遠端模式:</b> 'req'
php.web.server.validation.xdebug.remote.mode.req.description=調試會話將在腳本啟動時初始化。
php.web.server.validation.xdebug3.remote.mode.emulation.description=調試會話將在腳本啟動時初始化，與 xdebug2 的 <b>remote_mode=''{0}''</b> 相同。
php.web.server.validation.xdebug3.remote.mode.emulation.message=<b>遠端模式:</b> xdebug2 的 ''{0}'' 已模擬。 
php.web.server.validation.xdebug3.cloud.xdebug.doesnt.accept.connections.message=Xdebug 現在不接受外部連接
php.web.server.validation.xdebug3.cloud.xdebug.wrong.cloud.id.message=<b>IDE 中的云 ID:</b> 與伺服器上的云 ID 不同
php.web.server.validation.xdebug3.cloud.xdebug.wrong.cloud.id.description=<b>IDE 中的云 ID:</b> {0}<br><b>伺服器上的云 ID:</b> {1}
php.web.server.validation.xdebug3.cloud.xdebug.disabled.message=<b>通過 Xdebug Cloud 連接:</b> 已禁用。請在 IDE 設定中進行啟用: <b>PHP->調試->XDebug Cloud</b>
php.web.server.validation.xdebug3.cloud.php.ini.xdebug.disabled.message=<b>Php.ini 云調試:</b> 已禁用。
php.web.server.validation.xdebug3.cloud.xdebug.correct.cloud.id.message=<b>IDE 中的云 ID:</b> 與伺服器上的云 ID 相同
php.web.server.validation.xdebug.mode.is.not.supported=不支持遠端模式 ''{0}''
php.web.server.validation.xdebug.remote.log=<b>{0}:</b> {1}
php.web.server.validation.xdebug.protocol.is.not.supported=不支持調試協議 ''{0}''
php.web.server.validation.zend.debugger.host=<b>遠端主機:</b> {0}
php.web.server.validation.zend.debugger.localhost=儘管伺服器不在本地，但調試會話僅適用於本地主機。
php.web.server.validation.zend.debugger.localhost.description=將正在執行調試器<b>客戶端</b>的主機添加至 <b>'zend_debugger.allow_hosts'</b> 選項。
php.web.server.validation.zend.debugger.deny.host=<b>拒絕主機:</b> {0}
php.web.server.validation.zend.debugger.deny.host.description=無法使用拒絕主機從客戶端進行調試。
php.web.server.validation.zend.expose.remotely=<b>屬性 ''expose_remotely''</b> 設為 ''{0}''
php.web.server.validation.zend.expose.remotely.allowed.hosts.description=調試器會話將嘗試從 <b>'zend_debugger.allow_hosts'</b> 選項為主機啟動。
php.web.server.validation.zend.expose.remotely.always.description=調試器會話將嘗試為每個客戶端啟動。
php.web.server.validation.zend.expose.remotely.never.description=調試器會話將不會進行初始化，<b>'zend_debugger.allow_hosts'</b> 選項將被忽略。<br>將選項 <b>'zend_debugger.expose_remotely'</b> 設定為 'allowed_hosts' 或 'always' 以啟用 Web 伺服器調試。
php.web.server.validation.reference.to.documentation=請參閱<a href=\\"{0}\\">{0}</a>獲取更多資訊。

PhpPathMappingsConfigurable.use.path.mappings.label=使用路徑映射(選擇伺服器是遠端伺服器還是使用符號鏈接)

PhpMappingSimpleResolveDialog.title=為伺服器上的檔案路徑選擇本地檔案

DBGPProxyConfigurable.display.name=DBGp 代理
DBGPProxyConfigurable.ide.key=IDE 鍵:
DBGPProxyConfigurable.host=主機:
DBGPProxyConfigurable.port=連接埠:

xdebug.initializing.debugger.connection=正在連接到 {0}…
xdebug.initializing.connection.failed.with.timeout=無法連接到 {0}: 超時
xdebug.initializing.connection.debugger=調試器
xdebug.initializing.connection.xdebug.cloud=Xdebug Cloud

XdebugCloudConfigurable.display.name=Xdebug Cloud
XdebugCloudConfigurable.connect.via.xdebug.cloud=連接到 Xdebug Cloud
XdebugCloudConfigurable.cloud.id=Cloud ID:
XdebugCloudConfigurable.custom.server=連接到預置 Xdebug Cloud
XdebugCloudConfigurable.base.host=Cloud 主機:
XdebugCloudConfigurable.port=Cloud 連接埠:

xdebug.cloud.validation.cloud.id.not.defined=Cloud ID 未定義
xdebug.cloud.validation.host.not.defined=未定義預置 Xdebug Cloud 主機
xdebug.cloud.validation.port.invalid=預置 Xdebug Cloud 連接埠無效

xdebug.cloud.cannot.connect=無法連接到 Xdebug Cloud
xdebug.cloud.cannot.connect.unknown.host=Xdebug Cloud 無法存取: {0}
xdebug.cloud.cannot.register.cloud.id=無法在 Xdebug Cloud 上註冊 Cloud ID
xdebug.cloud.cannot.register.cloud.id.unexpected.response=由於意外響應，無法註冊 Cloud ID
xdebug.cloud.cannot.open.new.debug.connection=打不開新的調試連接

PhpIncomingLocalConnectionDialog.file.path=檔案路徑:

PhpIncomingConnectionDialog.server.name=伺服器名稱:
PhpIncomingConnectionDialog.server.port=伺服器連接埠:
PhpIncomingConnectionDialog.request.uri=請求 URI:
PhpIncomingConnectionDialog.file.path.on.server=伺服器上的檔案路徑:

PhpInterpreter.php.sdk.type=PHP 解釋器
PhpInterpreter.php.dependent.configuration.exists.title=PHP 解釋器依賴配置
PhpInterpreter.php.dependent.configuration.exists=所選 PHP 解釋器有{0}配置。確定要刪除此解釋器嗎?
PhpInterpreter.php.home.path.label=PHP 可執行檔案:
PhpInterpreter.php.debugger.label=調試器:
PhpInterpreter.php.general.title=常規
PhpInterpreter.configuration.in.project.settings.title=PHP 解釋器配置
PhpInterpreter.configuration.in.project.settings.message=無法將 PHP 解釋器指定為預設 SDK。您可以在“設定| PHP”中為當前專案配置
PhpInterpreter.configuration.duplicate.interpreter.name=找到了具有非唯一名稱 ''{0}'' 的 PHP 解釋器。
PhpInterpreter.configuration.selection.list.title=選擇 CLI 解釋器
PhpInterpreter.configuration.interpreter.is.invalid=啟用“PHP Remote Interpreters”套件以編輯解釋器。
PhpInterpreterConfigurable.configuration.title=其他
PhpInterpreterConfigurable.reload.phpinfo=重新載入 phpinfo
PhpInterpreterConfigurable.show.phpinfo=顯示 phpinfo
PhpInterpreterConfigurable.updated.phpinfo=已成功更新 phpinfo
PhpInterpreterConfigurable.can.not.updated.phpinfo=無法更新 phpinfo
PhpInterpreterConfigurable.php.version=PHP 版本: {0}
PhpInterpreterConfigurable.not.installed=未安裝
PhpInterpreterConfigurable.configuration.project.level=僅對此專案可見
PhpInterpreterConfigurable.configuration.project.tooltip=檢查是否不想在專案之間共享解釋器
PhpInterpreterConfigurable.configuration.default.project.tooltip=無法僅為預設專案儲存解釋器。
PhpInterpreterConfigurable.debugger.extension.label=調試器擴展:
PhpInterpreterConfigurable.debugger.extension.title=選擇調試器擴展路徑
PhpInterpreterConfigurable.debugger.extension.description=將僅為從 CLI 執行配置啟動的調試會話載入調試器擴展
PhpInterpreterConfigurable.configuration.options.table.empty.text=為 php.ini 中允許的任何配置指令設定自訂值
PhpInterpreterConfigurable.configuration.options.with.empty.name.are.not.allowed=不允許名稱為空的配置選項
PhpInterpreterConfigurable.configuration.options.dialog.caption=配置選項
PhpInterpreterConfigurable.configuration.options.label=配置選項:
PhpInterpreterConfigurable.configuration.options.table.name=配置指令
PhpInterpreterConfigurable.configuration.options.table.value=值
PhpInterpreterConfigurable.configuration.options.description=這些選項將使用 '-d' 命令行選項傳遞
PhpInterpreterConfigurable.configuration.file.path=配置檔案: {0}
PhpInterpreterConfigurable.configuration.file.path.not.found=配置 php.ini 檔案不存在
PhpInterpreterConfigurable.configuration.file.evaluate.dir=正在評估配置檔案目錄…
PhpInterpreterConfigurable.configuration.file.fix.title=配置 php.ini 檔案不存在
PhpInterpreterConfigurable.configuration.file.hhvm.fix=在 <b>/etc/hhvm</b> 目錄中創建 php.ini 檔案，<br><br>點擊此<a href=\\"http://docs.hhvm.com/manual/en/configuration.file.php\\">>鏈接</a>獲取更多資訊。
PhpInterpreterConfigurable.configuration.file.fix=在 {0} 目錄中創建 php.ini 檔案，<br><br>配置檔案模板可在 php 根資料夾中找到:<br>“php.ini-development”- 預設設定<br>“php.ini-production”- 推薦設定。<br>
PhpInterpreterConfigurable.configuration.file.fix.failed.to.detect=使用“{0} --ini”命令確定配置檔案目錄。<br>
PhpInterpreterConfigurable.configuration.file.fix.link=<br>點擊此<a href=\\"http://php.net/manual/en/configuration.file.php\\">鏈接</a>獲取更多資訊。
PhpInterpreterConfigurable.configuration.file.can.not.find.title=無法找到配置檔案
PhpInterpreterConfigurable.configuration.file.can.not.find=無法通過路徑找到檔案: ''{0}''
php.info.parse.exception=無法解析 php 資訊: {0} 是空的
PhpInterpreterConfigurable.update.helpers.title=正在更新幫助程序目錄…
PhpInterpreter.php.interpreter.name.conflict.title=解釋器名稱衝突
PhpInterpreter.php.interpreter.name.conflict=發現專案級和套用程序級解釋程序名稱存在衝突。為解決該問題，以下專案級解釋器被重命名:
remote.interpreter.browse.action.is.not.supported.for.docker=基於 Docker 的遠端解釋器不支持瀏覽操作
php.interpreter.info.failed.to.parse.validation.script=無法解析驗證腳本輸出

php.interpreter.base.configuration.interpreter.is.invalid=無法執行 {0}，因為 {1} 配置的解釋器無效。
php.interpreter.base.configuration.is.not.provided.or.empty={1} 的 {0} 路徑未配置。您可以在“PHP|{0}”下進行修復
php.interpreter.base.configuration.working.directory=無法檢測工作目錄，請在執行配置中進行配置。
php.interpreter.base.configuration.fix.interpreter={0}。要修復，請<a href=''{1}''>更改</a>專案解釋器或<a href=''{2}''>檢查</a>設定。

PhpProjectConfigurable.language.level=PHP 語言級別:
PhpProjectConfigurable.interpreter=CLI 解釋器:
PhpProjectConfigurable.include.path=Include 路徑
PhpProjectConfigurable.0.interpreter.include.path=''{0}'' 解釋器 include 路徑
PhpProjectConfigurable.specify.other=指定其他…
PhpProjectConfigurable.all=所有
PhpProjectConfigurable.provide.include.path=提供 include 路徑
PhpProjectConfigurable.docker.default.project.error.tooltip=打開或創建專案以配置 Docker 容器
PhpProjectConfigurable.php.runtime=PHP 執行時
PhpProjectConfigurable.advanced.settings=高級設定(&V)
PhpProjectConfigurable.default.stubs.path=預設存根路徑(&D):
PhpProjectConfigurable.select.default.stubs.path.title=選擇預設存根路徑
PhpProjectConfigurable.select.default.stubs.path.description=選擇預設存根路徑
PhpProjectConfigurable.analysis=分析
PhpProjectConfigurable.exception.analysis=異常分析
PhpProjectConfigurable.exception.analysis.depth=調用樹分析路徑:
PhpProjectConfigurable.exception.analysis.unchecked.exceptions=未檢查的異常
PhpProjectConfigurable.analysis.custom.format.functions=自訂格式函數
PhpProjectConfigurable.include.analysis=Include 分析
PhpProjectConfigurable.select.document.root.path.title=選擇 $_SERVER['DOCUMENT_ROOT'] 路徑
PhpProjectConfigurable.select.document.root.path.description=選擇 $_SERVER['DOCUMENT_ROOT'] 路徑

custom.format.functions.dialog.validation.class.not.found=找不到類 {0}
custom.format.functions.dialog.validation.function.not.found=找不到函數 {0}
custom.format.functions.dialog.validation.method.not.found=在 {1} 中找不到方法 {0}
custom.format.functions.dialog.validation.format.index=索引必須為非負數
custom.format.functions.dialog.format.index.title=格式字串模板的索引
custom.format.functions.dialog.class.placeholder=留空以添加純函數

PhpUnitConfigurableForm.phpunit.library=PHPUnit 庫
PhpUnitConfigurableForm.use.custom.loader=使用 Composer 自動載入器
PhpUnitConfigurableForm.custom.loader.is.empty=自動載入器檔案的路徑為空
PhpUnitConfigurableForm.can.not.find.custom.loader=在 ''{0}'' 下找不到自動載入器腳本
PhpUnitConfigurableForm.phpunit.phar.is.empty=phpunit.phar 路徑為空
PhpUnitConfigurableForm.can.not.find.phpunit.phar=在 ''{0}'' 下找不到 phpunit.phar
PhpUnitConfigurableForm.custom.loader.is.directory=自動載入器不應為目錄，對於預設 Composer 配置，將路徑設定為“vendor/autoload.php”
PhpUnitConfigurableForm.download.phpunit.phar.link.text=從 {0} 下載 phpunit.phar
PhpUnitConfigurableForm.path.to.script=腳本路徑:
PhpUnitConfigurableForm.path.to.phpunit.phar=phpunit.phar 路徑
PhpUnitConfigurableForm.test.runner=測試執行程序
PhpUnitConfigurableForm.use.configuration.file=預設配置檔案:
PhpUnitConfigurableForm.use.bootstrap.file=預設啟動檔案:
PhpUnitConfigurableForm.use.configuration.file.validation.warning=為 ''{0}'' 提供配置檔案的路徑，或禁用“預設配置檔案”選項
PhpUnitConfigurableForm.use.bootstrap.file.validation.warning=為 ''{0}'' 提供啟動檔案的路徑，或禁用“預設啟動檔案”選項

phpunit.config.label=測試根
phpunit.config.directory.label=目錄:
phpunit.config.empty.pattern=空模式
phpunit.getting.phpunit.version=正在更新 PhpUnit 版本…
phpunit.not.tests.was.executed.title=未配置 PHPUnit
phpunit.not.tests.was.executed.message=要修復，為 <i>{0}</i> <a href=\\"config\\">配置</a>自動載入檔案或 PHPUnit phar 路徑。
phpunit.can.not.rerun.failed.tests.title=無法執行失敗的 PHPUnit 測試。
frameworks.settings.none.installed=<html>沒有可用的框架設定提供程序。<br/>考慮安裝 Drupal Support、Joomla! Support 或 WordPress Support 套件。</html>
framework.composer.packages.were.changed.0.test.config.title=Composer 軟體套件已被更改
framework.composer.packages.were.changed.0.test.config.popup={0} 配置已根據 composer.json 更新

PhpUnitConfiguration.interpreter.conflict=發現應用程式級 PHPUnit 配置衝突。為解決該問題，創建了以下配置的專案級副本:
PhpUnitConfiguration.interpreter.conflict.title=PHPUnit 配置衝突

# php test framework
php.test.framework.select.type.of.settings.popup.title=選擇配置類型
php.test.framework.configuration.ui.library={0} 庫
php.test.framework.configuration.ui.test.runner=測試執行程序
php.test.framework.configuration.ui.path.to.exe={0} 可執行檔案路徑:
php.test.framework.configuration.ui.use.configuration.file=預設配置檔案:
php.test.framework.download.hyperlink={0} 版本: <a href={1}>{1}</a>
php.test.framework.configuration.ui.version={0} 版本: {1}
php.test.framework.configuration.ui.not.installed=未安裝
php.test.framework.configuration.ui.select.interpreter=請選擇 PHP 解釋器以載入 {0} 版本
php.test.framework.configuration.ui.select.local.interpreter=請選擇本地 PHP 解釋器以載入 {0} 版本
php.test.framework.configuration.updated.version=已成功更新 {0} 版本
php.test.framework.configuration.can.not.update=無法更新 {0} 版本
php.test.framework.default.interpreter.is.not.local=無法檢測到 {0} 版本。預設 PHP 解釋器不是本地解釋器

php.test.framework.version.getting.version.title=正在獲取 {0} 版本…
php.test.framework.version.path.to.exe.is.invalid={0} 可執行檔案的路徑為空或無效。
php.test.framework.version.detector.empty.output=''{0}'' 命令輸出為空。
php.test.framework.version.configuration.ui.can.not.parse.version=無法解析版本命令輸出。\\\\n\\\\
{0}

php.test.framework.by.sdk.new.settings.dialog.title=通過遠端解釋器{0}
php.test.framework.by.sdk.dialog.label=解釋器(&I):
php.test.framework.by.sdk.settings.select.server=選擇遠端解釋器以配置遠端{0}
php.test.framework.by.sdk.settings.already.exist=所選解釋器的 {0} 設定已存在
php.test.framework.by.sdk.settings.remote.path.title=選擇伺服器上的路徑

php.test.framework.run.configuration.ui.scope=測試範圍:
php.test.framework.run.configuration.ui.type.radio.button=類型(&T)
php.test.framework.run.configuration.ui.directory.radio.button=目錄 (&D)
php.test.framework.run.configuration.ui.file.radio.button=檔案(&F)
php.test.framework.run.configuration.ui.scenario.radio.button=方法(&M)
php.test.framework.run.configuration.ui.configuration.radio.button=在配置檔案中定義(&C)
php.test.framework.run.configuration.ui.type.combo.box=類型:
php.test.framework.run.configuration.ui.directory.text.field=目錄:
php.test.framework.run.configuration.ui.file.text.field=檔案:
php.test.framework.run.configuration.ui.scenario.text.field=方法:
php.test.framework.run.configuration.ui.alternative.configuration.file=使用替代配置檔案(&U):
php.test.framework.run.confuguration.ui.dialog.caption.test.runner.options=測試執行程序選項
php.test.framework.field.test.runner.options=測試執行程序選項(&O):
php.test.framework.run.configuration.ui.custom.file.radio.button=在 {0} 中定義
php.test.framework.run.configuration.ui.alternative.custom.file=使用替代 {0}(&U)
php.test.framework.settings.is.not.provided.or.empty={1} 的 {0} 路徑未配置。按“修復”以編輯您的 {0} 配置。

php.test.framework.interpreter.conflict=發現應用程式級 {0} 配置衝突。為解決該問題，創建了以下配置的專案級副本:
php.test.framework.interpreter.conflict.title={0} 配置衝突
php.test.framework.project.level=(當前專案)
php.test.framework.no.configuration.types.are.available=沒有可用的其他配置類型

# validation
php.test.framework.validation.run.configuration.no.type=如果未選擇類型則無法執行測試。
php.test.framework.validation.run.configuration.unsupported.type=無法通過 ''{0}'' 命令執行測試。
php.test.framework.validation.run.configuration.working.directory=目錄應該是工作目錄的子資料夾: ''{0}''
php.test.framework.validation.run.configuration.file.working.directory=檔案應該是工作目錄的子項: ''{0}''
php.test.framework.validation.run.configuration.method=在 ''{1}'' 中找不到 ''{0}''

php.executable.macro.description=專案設定中配置的 Php 可執行檔案
inspection.undefined.class.ignore.phpdoc=忽略 PHPDoc

inspection.missing.ext.composer.json=composer.json 中缺少 ''{0}''
inspection.ext.is.specified.in.require.dev.but.used.outside.tests=''{0}'' 在 ''require-dev'' 部分中指定，但在測試外部使用
inspection.ext.is.specified.in.suggest=''{0}'' 在 ''suggest'' 中指定，可能不可用
inspection.missing.ext.require.bundled=需要 PHP 捆綁的擴展
add.to.composer.json.quick.fix=向 composer.json 中添加 ''{0}''

configure.php.include.paths=配置 PHP Include 路徑(&O)…

interpreter=解釋器

XdebugShowUserDefinedConstantsToggleAction.text=顯示使用者定義的常數
XdebugShowUserDefinedConstantsToggleAction.description=將其禁用會停止獲取使用者定義的常數資訊並提高調試器性能
XdebugAddMethodToSkipListToggleAction.text=將方法添加到跳過列表
PhpDebugHideEmptySuperGlobalsToggleAction.text=顯示空的超全域變數
PhpDebugBreakAtFirstLineToggleAction.text=在 PHP 腳本中的第一行中斷
PhpUserDefinedConstantsGroup.name=常數

PhpLanguageLevel.5.3.0.presentable.name=5.3
PhpLanguageLevel.5.3.0.short.description=命名空間，閉包
PhpLanguageLevel.5.4.0.presentable.name=5.4
PhpLanguageLevel.5.4.0.short.description=特徵，短陣列語法
PhpLanguageLevel.5.5.0.presentable.name=5.5
PhpLanguageLevel.5.5.0.short.description=finally，生成器
PhpLanguageLevel.5.6.0.presentable.name=5.6
PhpLanguageLevel.5.6.0.short.description=可變函數，實參解包
PhpLanguageLevel.7.0.0.presentable.name=7.0
PhpLanguageLevel.7.0.0.short.description=返回類型，標量類型提示
PhpLanguageLevel.7.1.0.presentable.name=7.1
PhpLanguageLevel.7.1.0.short.description=常數可見性，可為 null，多個異常
PhpLanguageLevel.7.2.0.presentable.name=7.2
PhpLanguageLevel.7.2.0.short.description=物件類型提示，abstract 函數覆寫
PhpLanguageLevel.7.3.0.presentable.name=7.3
PhpLanguageLevel.7.3.0.short.description=列表賦值中的引用，靈活的 heredoc
PhpLanguageLevel.7.4.0.presentable.name=7.4
PhpLanguageLevel.7.4.0.short.description=類型屬性，短閉包，null 合併運算符
PhpLanguageLevel.8.0.0.presentable.name=8.0
PhpLanguageLevel.8.0.0.short.description=聯合類型，命名實參，特性，match 表達式

PhpLanguageFeature.traits.not.supported=從 PHP 5.4 起才允許使用特徵
PhpLanguageFeature.short.array.syntax.not.supported=從 PHP 5.4 起才允許使用短陣列語法
PhpLanguageFeature.array.dereferencing.not.supported=從 PHP 5.4 起才允許對調用進行陣列解引用
PhpLanguageFeature.class.member.access.on.instantiation.not.supported=從 PHP 5.4 起才允許對實例化進行類成員存取
PhpLanguageFeature.this.in.closure.not.supported=從 PHP 5.4 起才允許在閉包中使用 $this
PhpLanguageFeature.self.in.closure.not.supported=從 PHP 5.4 起才允許在閉包中使用 self
PhpLanguageFeature.parent.in.closure.not.supported=從 PHP 5.4 起才允許在閉包中使用 parent
PhpLanguageFeature.static.in.closure.not.supported=從 PHP 5.4 起才允許在閉包中使用 static
PhpLanguageFeature.binary.literal.not.supported=從 PHP 5.4 起才允許使用二進制文字
PhpLanguageFeature.literal.in.static.call.not.supported=從 PHP 5.4 起才允許在 static 調用中使用文字
PhpLanguageFeature.built.in.web.server=內建 Web 伺服器僅自 PHP 5.4 起可用
PhpLanguageFeature.var.break.argument.not.supported=PHP 5.4 不再支援具有非常數操作數的 'break' 運算符
PhpLanguageFeature.var.break.zero.argument.not.supported=自 PHP 5.4 起，'break' 運算符僅接受正數
PhpLanguageFeature.var.continue.not.supported=PHP 5.4 不再支援具有非常數操作數的 'continue' 運算符
PhpLanguageFeature.var.continue.zero.not.supported=自 PHP 5.4 起，'continue' 運算符僅接受正數
PhpLanguageFeature.call.time.pass.by.reference.not.supported=調用時通過引用傳遞在 PHP 5.4 中已被移除

PhpLanguageFeature.finally.not.supported=從 PHP 5.5 起才允許使用 'Finally' 子句
PhpLanguageFeature.generators.not.supported=從 PHP 5.5 起才允許使用生成器
PhpLanguageFeature.foreach.list.not.supported=從 PHP 5.5 起才允許在 foreach 中使用列表
PhpLanguageFeature.empty.any.expression.not.supported=從 PHP 5.5 起才允許在 'empty' 中使用任意表達式
PhpLanguageFeature.immediate.dereferencing.not.supported=從 PHP 5.5 起才允許直接解引用
PhpLanguageFeature.class.name.const.not.supported=從 PHP 5.5 起才允許使用類名常數

PhpLanguageFeature.constant.scalar.expressions=從 PHP 5.6 起才允許使用常數標量表達式
PhpLanguageFeature.variadic.functions=從 PHP 5.6 起才允許使用可變函數
PhpLanguageFeature.argument.unpacking=從 PHP 5.6 起才允許使用實參解包
PhpLanguageFeature.exponentiation=從 PHP 5.6 起才允許使用求冪
PhpLanguageFeature.use.function.and.const=從 PHP 5.6 起才允許 use function 和 use const

PhpLanguageFeature.return.types=從 PHP 7.0 起才允許使用返回類型宣告
PhpLanguageFeature.scalar.type.hints=從 PHP 7.0 起才允許使用標量類型提示
PhpLanguageFeature.spaceship.operator=從 PHP 7.0 起才允許使用宇宙飛船運算符
PhpLanguageFeature.coalesce.operator=從 PHP 7.0 起才允許使用合並運算符
PhpLanguageFeature.grouped.use=從 PHP 7.0 起才允許分組 use 宣告
PhpLanguageFeature.keyword.names=在 PHP 7.0 中關鍵字可用作名稱
PhpLanguageFeature.uniform.variable.syntax=從 PHP 7.0 起才允許統一變數語法
PhpLanguageFeature.anonymous.classes=從 PHP 7.0 起才允許使用匿名類

PhpLanguageFeature.return.void=從 PHP 7.1 起才允許使用返回類型 'void'
PhpLanguageFeature.nullables=從 PHP 7.1 起才允許可為 null
PhpLanguageFeature.iterable.type.hint=從 PHP 7.1 起才允許迭代類型提示
PhpLanguageFeature.catch.multiple=從 PHP 7.1 起才允許捕獲多條語句
PhpLanguageFeature.class.constant.visibility=從 PHP 7.1 起才允許類常數可見性
PhpLanguageFeature.list.keys=從 PHP 7.1 起才允許列表解包中的密鑰
PhpLanguageFeature.list.assign=從 PHP 7.1 起才允許列表解包中的 []
PhpLanguageFeature.negative.numeric.indices=從 PHP 7.1 起才允許負數值索引

PhpLanguageFeature.object.type.hint=從 PHP 7.2 起才允許物件類型提示
PhpLanguageFeature.abstract.function.override=從 PHP 7.2 起才允許抽象函數覆寫

PhpLanguageFeature.literal.in.instanceof=從 PHP 7.3 起才允許將文字作為第一個操作數
PhpLanguageFeature.references.in.list=從 PHP 7.3 起才允許在 [] 和 list() 賦值中使用引用
PhpLanguageFeature.trailing.comma.in.function.calls=從 PHP 7.3 起才允許在函數調用中使用尾隨逗號
PhpLanguageFeature.trailing.comma.in.parameter.list=從 PHP 8.0 起才允許在參數列表中使用尾隨逗號
PhpLanguageFeature.trailing.comma.in.closure.use.list=只有 PHP 8.0 支援在閉包 use 列表中使用尾隨逗號
PhpLanguageFeature.flexible.heredocs=靈活的 heredoc/nowdoc 語法

PhpLanguageFeature.typed.properties=從 PHP 7.4 起才允許使用類型化屬性
PhpLanguageFeature.spread.operator.in.array=從 PHP 7.4 起才允許在陣列中使用展開運算符
PhpLanguageFeature.coalesce.assign=從 PHP 7.4 起才允許使用 '??='
PhpLanguageFeature.arrow.function=從 PHP 7.4 起才允許箭頭函數語法
PhpLanguageFeature.numeric.literals.separators=從 PHP 7.4 起才允許使用數值文字分隔符
PhpLanguageFeature.exception.throw.from.toString=從 PHP 7.4 起才允許從 ''__toString'' 拋出異常，''{0}.__toString'' 可能會拋出異常

PhpLanguageFeature.union.types=從 PHP 8.0 起才允許聯合類型
PhpLanguageFeature.namespaced.name.as.single.token=從 PHP 8.0 起才允許關鍵字作為命名空間的一部分
PhpLanguageFeature.nullsafe.dereferencing=從 PHP 8.0 起才允許 Nullsafe 運算符
PhpLanguageFeature.abstract.private.trait.methods=從 PHP 8.0 起才允許使用 abstract private 特徵方法
PhpLanguageFeature.mixed.type.hint=從 PHP 8.0 起才允許 'mixed' 類型提示
PhpLanguageFeature.static.type.hint=從 PHP 8.0 起才允許 'static' 返回類型宣告
PhpLanguageFeature.named.arguments=從 PHP 8.0 起才允許使用命名實參
PhpLanguageFeature.match.expression=從 PHP 8.0 起才允許符合表達式
PhpLanguageFeature.throw.expression=從 PHP 8.0 起才允許使用 throw 表達式
PhpLanguageFeature.non.capturing.catches=從 PHP 8.0 起才允許捕捉異常而又不將異常捕獲到變數中
PhpLanguageFeature.class.name.literal.on.object=從 PHP 8.0 起才允許在物件上使用 '::class'
PhpLanguageFeature.attributes=從 PHP 8.0 起才允許使用特性
PhpLanguageFeature.property.promotion=從 PHP 8.0 起才允許構造函數屬性提升

#Empty project generation
php.empty.project.generator.name=PHP 空專案
php.empty.project.generator.description=為 PHP 創建空專案

#UML
error.cant.create.edge=無法創建關係鏈接
relationship.already.exists={0}和{1}之間的關係已存在
this.will.remove.relationship.link.between.classes=這將移除類之間的關係鏈接並修改類 {0}。繼續？
remove.relationship.link=移除關係鏈接
final.class.cant.be.inherited=類 {0} 為 final
node.is.interface=接口只能繼承一個接口
inspection.undefined.member.downgrade=如果類中存在 __magic 方法則降級嚴重性(&D)

#Phar
phar.include.into.project.action.title=將 phar 包含到專案中
phar.exclude.from.project.action.title=從專案中排除 phar
phar.exclude.or.include.into.project.action.title=在專案中包含或排除 Phar
phar.failed.to.parse=無法解析
filetype.phar.description=Php Phar
filetype.phar.display.name=Php Phar

#Composer

framework.composer.name.composer=Composer
framework.composer.path.dialog.path.to.composer=Composer 路徑
framework.composer.path.dialog.path.to.composer.json=composer.json 路徑
framework.composer.path.dialog.specify.composer.phar=指定 Composer phar:
framework.composer.path.dialog.specify.composer.executable=指定 Composer 可執行檔案:
framework.composer.path.dialog.specify.composer.json=指定 composer.json:
framework.composer.configurable.title=Composer
framework.composer.init.dialog.title.composer.settings=Composer 設定
framework.composer.file.0.is.not.found=找不到檔案 ''{0}''。

framework.composer.add.dependency.task.title=添加依賴項
framework.composer.add.dependency.install.button=安裝
framework.composer.add.dependency.update.button=更新
framework.composer.add.dependency.close.button=關閉(&C)
framework.composer.failed.to.0=無法{0}。
framework.composer.0.1.version.2={0} {1}，版本 {2}
framework.composer.add.dependency.show.output=顯示輸出
framework.composer.add.dependency.hide.tooltip=隱藏
framework.composer.add.dependency.successfully.installed.0.version.1=已成功安裝 {0}，版本 {1}。
framework.composer.add.dependency.running=正在執行
framework.composer.add.composer.dependency.title=管理 Composer 依賴項
frameworks.composer.could.not.get.packages.info.0=無法獲取軟體套件資訊。{0}
frameworks.composer.could.not.get.package.info=無法獲取軟體套件資訊。
framework.composer.label.version.to.install=要安裝的版本(&V):
framework.composer.empty.package.name.in.0={0} 中的軟體套件名稱為空
framework.composer.no.package.versions.in.0={0} 中沒有軟體套件版本
framework.composer.expected.name.0.versions.0.description.got.1=應為 <name> {0} <versions> {0} <description>，獲得的是 {1}
framework.composer.add.dependency.available.packages.label=可用軟體套件
framework.composer.package.default.version=<預設>
framework.composer.add.dependency.no.package.selected=未選擇軟體套件
framework.composer.add.dependency.no.such.package=packagist 上無此類軟體套件
framework.composer.path.form.execution.validation.wrapper=<html>執行未設定。<br/>{0}</html>
framework.composer.path.form.empty.path.to.composer.phar=composer.phar 路徑為空
framework.composer.path.form.empty.path.to.composer.executable=Composer 可執行檔案路徑為空
framework.composer.project.generator.name=Composer 專案
framework.composer.project.generator.description=通過 Composer 命令創建專案。
framework.composer.failed.to.download.composer.phar=無法下載 composer-stable.phar
framework.composer.project.generator.failed.to.copy.temp.directory.0.content.to.project.root=無法將臨時目錄 ''{0}'' 內容複製到專案根
framework.composer.project.generation.error.title=無法創建 Composer 專案
framework.composer.project.generator.notification.content.failed.to.find=無法找到 {0}
framework.composer.project.generator.notification.content.failed.to.find.composer.json=無法在專案根中找到 composer.json
framework.composer=Composer
framework.composer.create.project.progress.title=創建專案
framework.composer.create.project.from=自以下創建專案
framework.composer.install.action.name=安裝
framework.composer.path.validation.0.is.a.directory={0} 是目錄
framework.composer.path.form.empty.path.to.composer.json=composer.json 路徑為空
framework.composer.vendors.library.name=Composer 供應商
framework.composer.selected.file.is.not.composer.json=所選檔案不是 composer.json
framework.composer.notification.title.init.composer=初始化 Composer
framework.composer.file.0.set.as.composer.config.change.setting.a.href.here.a=檔案 ''{0}'' 設定為 Composer 配置。
framework.composer.failed.to.parse.package.names=無法解析軟體套件名稱。
framework.composer.failed.to.load.package.names=無法載入軟體套件名稱。
framework.composer.failed.to.parse.package.description=無法解析軟體套件描述。
framework.composer.add.dependency.no.version.selected=未選擇版本
framework.composer.add.dependency.settings.cl.dialog.title=參數
framework.composer.add.dependency.settings.cl.label=命令行參數(&P):
framework.composer.add.dependency.settings.interpreter.label=PHP 解釋器:
framework.composer.add.dependency.settings.title=設定(&S)
framework.composer.no.description.available=無可用描述。
framework.composer.packages.were.moved.to.0.php.include.paths.popup=Composer 軟體套件已從 Composer 外部庫移至 PHP include 路徑。
framework.composer.packages.were.changed.0.excluded.folders.popup=Composer 軟體套件已更改，因此更新了排除的資料夾。
framework.composer.packages.were.changed.0.php.include.paths.popup=Composer 軟體套件已更改，因此更新了 PHP include 路徑。
framework.composer.packages.were.removed.0.excluded.folders.popup=Composer 軟體套件已從排除的資料夾中移除。
framework.composer.packages.were.removed.0.php.include.paths.popup=Composer 軟體套件已從 PHP include 路徑中移除。
framework.composer.packages.were.added.0.excluded.folders.popup=Composer 軟體套件已被添加到排除的資料夾中。
framework.composer.packages.were.added.0.php.include.paths.popup=Composer 軟體套件已被添加到 PHP include 路徑中。
framework.composer.failed.to.0.1.script.was.cancelled=無法{0} {1}。腳本已被取消。
framework.composer.add.dependency.successfully.updated.0=已成功更新 {0}。
framework.composer.add.dependency.no.new.version.found.for.0=找不到 {0} 的新版本。
framework.composer.add.dependency.successfully.removed.0=已成功移除 {0}。
framework.composer.updating.package.task.title=更新軟體套件
framework.composer.removing.package.task.title=移除軟體套件
framework.composer.update.action.name=更新
framework.composer.remove.action.name=移除
framework.composer.self.update.action.name=自我更新
framework.composer.label.installed.version=已安裝的版本:
framework.composer.path.to.php.executable.titled=PHP 可執行檔案的路徑
framework.composer.specify.php.executable.0=指定 PHP 可執行檔案 {0}
framework.composer.empty.path.to.0={0} 的路徑為空
framework.composer.default.project.interpreter=預設專案解釋器
framework.composer.default.interpreter.is.not.configured=尚未為此專案配置預設解釋器。
framework.composer.default.interpreter.for.this.project.is.remote=此專案的預設解釋器是遠端解釋器，無法使用。
framework.composer.default.composer.interpreter.name=Composer 的解釋器
framework.composer.interpreters.combo.default.interpreter=< 預設解釋器 >
framework.composer.interpreters.combo.default.project.interpreter=< 預設專案解釋器 >
framework.composer.interpreters.combo.no.default.interpreter=預設設定中沒有預設解釋器
framework.composer.interpreters.combo.no.default.interpreter.in.project=此專案中沒有預設解釋器
framework.composer.interpreters.combo.default.interpreter.no.php.path=預設解釋器未提供 PHP 路徑
framework.composer.initialize.popup=找到了 Composer 配置檔案 {0}。專案設定與其同步。
framework.composer.install.task.title=正在安裝軟體套件
framework.composer.update.task.title=更新軟體套件
framework.composer.self.update.task.title=更新 Composer
framework.composer.script.run.configuration.name=Composer 腳本
framework.composer.script.run.configuration.description=Composer 腳本執行配置
framework.composer.run.path.to.composer.json=composer.json 路徑:
framework.composer.run.script=腳本:
framework.composer.run.script.missing=未指定 Composer 腳本
framework.composer.available.version=可用版本:
framework.composer.package.version.available.0={0}的更新
framework.composer.failed.check.for.update=無法執行 'update --dry-run' 命令。
framework.composer.checking.for.update=正在檢查更新…
framework.composer.loading.packages=正在載入 Composer 軟體套件
framework.composer.loading.package.description=正在載入軟體套件描述
framework.composer.load.update.availability=檢查可用軟體套件更新
framework.composer.loading.update.availability=正在檢查 Composer 軟體套件更新

# Guzzle
guzzle.name=Guzzle
guzzle.http.request.gutter.name=Guzzle HTTP 請求
guzzle.open.http.request=在 HTTP 請求編輯器中打開
guzzle.unable.to.add.new.request.to.file=無法向 ''{0}'' 檔案添加新請求
guzzle.invalid.http.request.file=檔案 ''{0}'' 是無效的 HTTP 請求檔案
guzzle.unable.to.extract.request.parameters=無法提取請求參數
http.client.request.init.debug.connection.title=正在初始化調試連接

php.interpreter.not.configured.title=未配置 PHP 解釋器
php.interpreter.not.configured=請<a href=\\"\\">配置 PHP 解釋器</a>以使用內建 Web 伺服器
php.interpreter.is.remote.title=已配置遠端 PHP 解釋器
php.interpreter.is.remote.message=請<a href=\\"\\">選擇本地 PHP 解釋器</a>以使用內建 Web 伺服器

php.cgi.not.found.title=找不到 {0}
php.cgi.not.found=請確保<a href=\\"\\">配置的 PHP 解釋器</a>作為 CGI 程序構建(指定了 --enable-fastcgi)

php.smart.indent.codestyle.indent.in.php=縮排 PHP 標記中的程式碼

phpdoc.code.style.title=PHPDoc

phpdoc.code.style.generated.doc.blocks=生成的 PHPDoc 標記
phpdoc.code.style.sort.doc.blocks=PHPDoc 標籤順序

phpdoc.code.style.force.null.position=將 ‘null’ 置於以下類型中:
phpdoc.code.style.in.beginning.position=在開頭
phpdoc.code.style.in.end.position=在末尾

phpdoc.code.style.convert.true.false.to=將 True/False 常數轉換為:
phpdoc.code.style.convert.null.to=將 Null 常數轉換為：
php.code.style.convert.keyword.to.lowercase=將關鍵字轉換為小寫
php.code.style.convert.lower.case=小寫
php.code.style.convert.upper.case=大寫
php.code.style.sort.use.stmt=對 'use' 語句排序:
php.code.style.sort.alphabetically=按字母順序
php.code.style.sort.by.length=按長度

phpdoc.code.style.convert.else.if.to=將 else if/elseif 轉換為:
phpdoc.code.style.convert.else.if.separate=else if
phpdoc.code.style.convert.else.if.combine=elseif

phpdoc.code.style.throws.analysis.depth.performance.note.title=性能註釋
phpdoc.code.style.throws.analysis.depth.performance.note.message=不建議深入分析多個級別，因為這可能會影響 IDE 性能。要繼續嗎?

phpdoc.code.style.param.spaces.panel=PHPDoc '@param' 空間
phpdoc.code.style.param.spaces.between.tag.and.type=在標籤和類型之間：
phpdoc.code.style.param.spaces.between.type.and.name=類型和名稱之間：
phpdoc.code.style.param.spaces.between.name.and.description=在名稱和描述之間：

php.conversion.code.style.title=程式碼轉換

php.generation.code.style.title=程式碼生成

array.declaration.style=陣列/列表宣告樣式

variable.naming.style.panel=變數命名樣式
variable.naming.style.mixed=混合
variable.naming.style.camel.case=駝峰式命名法
variable.naming.style.snake.case=snake_case

php.prefdefined.codestyle.psr12.chosen.title=PSR-12 程式碼樣式
php.prefdefined.codestyle.psr12.chosen.message=您可以啟用其他 PSR-12 檢查，這些檢查當前已禁用。
php.prefdefined.codestyle.psr12.enabled.message=PSR-12 檢查已啟用。

fields.default.visibility.panel=屬性預設可見性
fields.default.visibility.private=private
fields.default.visibility.protected=protected
fields.default.visibility.public=public

getters.setters.style=Getter/Setter 樣式
getters.setters.order=Getter/Setter 順序:
getters.setters.getters.first=getter 優先
getters.setters.setters.first=setter 優先
getters.setters.naming.style=命名樣式:
getters.setters.configure=配置…

php.embedded.stubs.incorrect.path.warning.title=預設存根路徑不正確
php.embedded.stubs.incorrect.path.warning.message=配置的預設存根路徑 ''{0}'' 不存在，改為使用嵌入式存根。
php.embedded.stubs.notification.provider.notification=您正在查看不可變的嵌入式存根。為了能夠編輯這些存根，您需要克隆一個存根專案，然後通過“PHP / PHP 執行時 / 高級設定”提供預設存根路徑。
php.embedded.stubs.notification.provider.clone=在 GitHub 上克隆
php.embedded.stubs.notification.provider.provide=提供預設存根路徑
php.embedded.stubs.notification.provider.do.not.show.again=不再顯示

auto.import.in.file.scope=在檔案範圍內啟用自動匯入
auto.import.in.namespace.scope=在命名空間範圍內啟用自動匯入
auto.import.from.global.space=處理來自全域空間的符號
auto.import.from.global.space.class=類:
auto.import.from.global.space.function=函數:
auto.import.from.global.space.constant=常數:
auto.import.from.global.space.prefer.fallback=回退優先
auto.import.from.global.space.prefer.import=匯入優先
auto.import.from.global.space.prefer.fqn=FQN 優先
# non-strict
quickfix.non.strict.object.equality=非嚴格物件相等比較
inspection.non.strict.object.equality=非嚴格物件相等比較

exception.analysis.settings.path=PHP/分析
inspection.severity.with.magic=當 __magic 存在時顯示

import.references.on.paste.dialog.title=選擇要匯入的{0}
import.references.on.paste.dialog.message=<html>貼上的程式碼段使用 {0}，後者在目標範圍中不能通過匯入存取。<br/>選擇您想要匯入到範圍中的{0}。</html>
skip.constant.params=使用常數參數跳過調用
inspection.unused.declaration.option.test.entry_points=假定測試宣告為入口點
inspection.unused.declaration.option.show.unused_from_entries=顯示所有宣告
inspection.unused.declaration.option.show_strictly_unused=僅顯示未使用項
inspection.unused.declaration.option.test.suppressGettersAndSetters=禁止 getter/setter
inspection.code.patterns.panel.errors.class = 模式必須是有效的 php fqn，僅接受 '*' 作為佔位符
inspection.code.patterns.panel.errors.member = 方法模式 {0} 必須是有效的 php 關鍵字，僅接受 ''*'' 作為佔位符
inspection.code.patterns.panel.description.label = 如果 fqn 名稱符合，則將程式碼標記為入口點
inspection.code.patterns.panel.description.text = 將方法留空以表示構造函數 \\\\n\\\\
 任何 * 都將與 fqn 名稱中的一個或多個字符符合
inspection.unusedd.description.code.patterns.button.label=程式碼模式
inspection.unused.description.code.suppressed.annotations=已禁止的註解
inspection.undefined.member.warnOnMixed=出現混合、物件、stdClass、未定義類型、null 的存取成員時通知
configurable.PhpServerConfigurable.display.name=伺服器
configurable.PhpDebugConfigurable.display.name=調試
configurable.PhpProjectConfigurable.display.name=PHP
configurable.PhpSmartKeysConfigurable.display.name=PHP
configurable.QualityToolCommonConfigurable.display.name=品質工具
class.implements.solely.traversable=類 ''{0}'' 必須將接口 Traversable 作為 Iterator 或 IteratorAggregate 的一部分來實作
configurable.PhpServersConfigurable.display.name=伺服器
configurable.PhpTestFrameworksConfigurable.display.name=測試框架
configurable.PhpTemplatesCommonConfigurable.display.name=模板
PhpStepFiltersConfigurable.display.name=步進篩選器
remote.connection.settings.interpreter.is.not.remote=當前專案解釋器非遠端解釋器
remote.connection.settings.default.remote.interpreter=預設遠端解釋器
php.element.is.available.starting.with.php.version=''{0}'' 從 PHP 版本 {1} 開始可用
php.element.was.removed.in.php.version=''{0}'' 已在 PHP {1} 版本中被移除
settings.smart.keys.title=PHP
settings.smart.keys.enable.smart.function.parameters.completion=啟用智能函數參數補全
settings.smart.keys.select.variable.name.without.dollar.sign.on.double.click=雙擊時選擇不含 '$' 符號的變數名稱
settings.smart.keys.remove.php.open.close.tags.while.pasting.in.php.context=在 PHP 上下文中貼上時移除 PHP 開始/結束標記
settings.smart.keys.escape.symbols.on.paste.in.string.literals=在字串文字中貼上時轉義符號
settings.smart.keys.auto.insert.tag.after.typing=輸入 '<?' 後自動插入 '<?php' 標記
settings.smart.keys.find.usages.of.base.method.prompt=搜尋方法用法時顯示其他選項
settings.smart.keys.replace.unnecessary.double.quotes.on.paste=貼上時取代不必要的雙引號
php.exception.is.never.thrown=函數中從未拋出異常 ''{0}''
php.remove.exception.from.throws=從 @throws 標記中移除 ''{0}''
php.remove.throws.tag=從 @throws 標記移除
php.add.exception=將 ''{0}'' 添加到現有 @throws 標記
ternary.condition.can.be.replaced.with.condition.expression=表達式可以安全地取代為 ''{0}''
php.replace.with=取代為 ''{0}''
php.tag.is.deprecated={0} 已棄用，將在 PHPUnit 9 中移除
potentially.polymorphic.call.multiple.subclasses=潛在的多態調用。該程式碼可能無法操作，具體取決於作為實參傳遞的實際類實例。
trait.already.contains.method=特徵 {0} 已包含方法 {1}
potentially.polymorphic.call.single.subclass=潛在的多態調用。{0} 的層次結構中沒有成員
navigate.to.meta.declaration=導航到 ''{0}''
meta.declaration.exists=''{1}'' 存在元宣告 ''{0}''
meta.multiple.declaration.exists=''{0}'' 存在多個元宣告
meta.declaration.line.marker.name=存在元宣告
unnecessary.local.variable=不必要的局部變數
phpunit.10.won.t.support.classname.annotations=PHPUnit 10 將不支持 ClassName::<*> 註解
returned.by.iterator.aggregate.should.be.traversable=\\\\\\\\IteratorAggregate::getIterator() 返回的物件必須為 Traversable 或實作接口 Iterator
inspection.probably.undefined.property=屬性 '#ref' 已動態宣告，可能未定義
find.classes.without.member=尋找沒有成員的類
classes.without.member=層次結構中不帶 ''{0}'' 的類
remove.pass.by.ref=移除 '\\\\\\\\&'
pass.by.ref.is.not.effectively.used.inside.body=引用沒有必要，因為實參既不通過引用賦值，也不通過引用進一步傳遞
suppress.if.annotated.by.tag=如果用 ''{0}'' 註解，則禁止
configure.suppressed.annotations=配置禁止的註解
enter.annotation=輸入註解
suppressed.annotation.title=已禁止的註解
move.class.to.separate.file.text.family=將類移至單獨的檔案
type.primitive.hints.names.are.forbidden=禁止名為 'true'、'false' 和 'null' 的類型提示
primitive.hints.name.are.forbidden.in.php.7=PHP 7 中禁止名為 'int'、'string'、'float'、'bool'、'true'、'false' 和 'null' 的類
classes.named.void.and.iterable.are.forbidden.in.php.7.1=PHP 7.1 中禁止名為 'void' 和 'iterable' 的類
classes.named.object.are.forbidden.in.php.7.2=PHP 7.2 中禁止名為 'object' 的類
switch.statements.may.only.contain.one.default.clause.in.php.7=在 PHP 7 中，switch 語句只能包含一個 'default' 子句
show.composer.settings.action.name=顯示 Composer 設定
composer.change.setting.action.name=更改設定
composer.diagnose.task.title=診斷
composer.simulating.update.task.title=模擬更新
composer.generating.autoloader.task.title=生成自動載入器
composer.autoloader.generation.settings.name=自動載入器生成設定
composer.generate.list.popup.title=生成
install.composer.packages.task.title=安裝 Composer 軟體套件
composer.listing.licenses.task.title=列出許可證
composer.update.composer.task.title=更新 Composer
composer.checking.for.changes.in.code.of.dependencies.task.title=檢查依賴項程式碼中的變更
composer.update.composer.packages.task.title=更新 Composer 軟體套件
composer.validating.task.title=驗證
composer.validation.settings.name=驗證設定
composer.validate.dialog.action.button.title=驗證
composer.revert.action.name=還原
composer.clearing.cache.action.name=清除快取
composer.remove.action.name=移除(&R)
composer.checkbox.download.composer.phar.from.getcomposer.org=從 getcomposer.org 下載 composer-stable.phar
composer.label.phar=composer.phar
composer.label.executable='composer' 可執行檔案
composer.checkbox.check.if.composer.lock.is.up.to.date=檢查 composer.lock 是否為最新
composer.checkbox.autoload.classes.from.the.classmap.only=僅從類映射自動載入類
composer.label.can.be.time.consuming=可能較為耗時
composer.checkbox.disable.autoload.dev.dependencies=禁用 autoload-dev 依賴項
composer.checkbox.optimize.autoloader.convert.psr.0.4.rules.to.a.classmap=優化自動載入器(將 PSR-0/4 規則轉換為類映射)
composer.checkbox.skip.scripts.execution=跳過腳本執行
composer.checkbox.use.apcu.to.cache.found.not.found.classes=使用 APCu 快取找到/未找到的類
composer.checkbox.allow.unbound.version.constraints=允許未綁定的版本約束
composer.checkbox.check.if.the.package.is.packagist.ready=檢查軟體套件是否為 Packagist 就緒
composer.checkbox.validate.package.dependencies=驗證軟體套件依賴項
composer.checkbox.synchronize.ide.settings.with.composer.json=將 IDE 設定與 composer.json 同步(&S)
composer.label.path.to.composer.json=composer.json 路徑(&C):
composer.label.the.settings.php.language.level.directories.may.be.updated=設定(Php 語言級別，目錄)可能已更新
composer.border.title.package=軟體套件
composer.label.package=軟體套件:
composer.label.version.to.install=要安裝的版本:
composer.label.filter.packages=篩選軟體套件(&F):
composer.label.label=標籤
composer.border.title.execution=執行
php.run.label.server=伺服器:
php.run.label.https=HTTPS:
php.run.label.url=URL:
php.run.label.query.string=查詢字串:
php.run.label.request.body=請求正文:
php.run.label.request.method=請求方法:
php.run.label.send.request.body.as=將請求正文發送為:
php.run.radio.button.key.value=鍵值
php.run.http.border.title.configuration=配置
php.run.label.interpreter=解釋器:
php.run.radio.button.text=文本
replace.with.alias.from.target.scope=取代為目標範圍中的別名
php.information.dialog.title=PHP 資訊
extract.method.parameter.name.column.title=參數
constant.with.same.name.already.exists.in.0={0} 中已經存在名稱相同的常數
path.0.is.invalid=路徑 ''{0}'' 無效
rename.parameters.dialog.title=重命名參數
rename.parameter.dialog.description=將層次結構中的參數重命名為:
quality.tools.custom.coding.standard=自訂編碼標準
quality.tools.0.added.to.ignored.files.list={0}已添加到忽略的檔案列表。
exclude.0.from.1.analysis.a=從{1}分析中排除{0}。
create.new.field.dialog.title=創建新字段
uml.wrong.name=錯誤的名稱
uml.0.already.exists.in.class.1=類 {1} 中已經存在 ''{0}''
rename.filename.quick.fix=將檔案 ''{0}'' 重命名為 ''{1}''
rename.psi.element.quick.fix=將{0} ''{1}'' 重命名為 ''{2}''
fix.package.text=將命名空間 ''{0}'' 取代為 ''{1}''
fix.package.text.family=修復命名空間 
variable.always.have.value.0=到達時變數始終為 '{0,choice,0#false|1#true}'
introduce.named.constant.for.value.0=為值 ''{0}'' 引入命名常數


checkbox.add.packages.as.libraries=作為庫添加軟體套件(&A)
phpunit.label.data.set=資料集:
label.insert.imports.on.paste=貼上時插入匯入:
border.title.php=PHP
label.class.fqn=類 FQN
label.method.name=方法名稱
checkbox.move.to.another.class=移動到另一個類(&M)
label.visibility=可見性(&V)
label.initialize.in=初始化在(&I)
radio.button.const=const(&C)
radio.button.define=定義(&D)
border.title.constant.syntax=常數語法
border.title.visibility=可見性
radio.button.default=預設(&F)
radio.button.public=public(&U)
radio.button.private=private(&I)
radio.button.protected=protected(&O)
radio.button.by.concatenation=通過串聯(&C)
radio.button.by.embeding=通過嵌入(&E)
radio.button.class.constructor=類構造函數(&S)
radio.button.current.method=當前方法(&T)
radio.button.field.declaration=屬性宣告(&D)
border.title.initialize.in=初始化位置
border.title.introduce.field=引入屬性
radio.button.setup=設定(&U)
border.title.introduce.variable=引入變數
label.name=名稱:
label.visibility2=可見性:
checkbox.static=static
checkbox.check.clone.method=檢查 '__clone' 方法
checkbox.check.destruct.method=檢查 '__destruct' 方法
checkbox.check.sleep.method=檢查 '__sleep' 方法
checkbox.check.wakeup.method=檢查 '__wakeup' 方法
checkbox.align.parameter.property.names=對齊參數/屬性名稱
checkbox.align.tag.comments=對齊標記註釋
checkbox.blank.line.before.the.first.tag=在第一個標記前使用空行
checkbox.blank.lines.around.parameters=在參數周圍使用空行
checkbox.keep.blank.lines=保留空行
checkbox.sort.phpdoc.tags=對 PHPDoc 標記排序
checkbox.use.fully.qualified.class.names=使用完全限定類名
checkbox.wrap.long.lines=長行換行
checkbox.use.as.a.default.template=用作預設模板
label.server.document.root=$_SERVER['DOCUMENT_ROOT']
tooltip.defaults.to.project.folder=預設為專案資料夾
border.title.include.analysis=Include 分析
button.sync.extensions.with.interpreter=將擴展與解釋器同步
checkbox.add.a.comma.after.last.element.in.multiline.array=在多行陣列中的最後一個元素之後添加逗號
checkbox.force.short.declaration.style=強制短宣告樣式
checkbox.add.phpdoc=添加 PHPDoc(&D):
radio.button.copy.from.base.class=從基類複製(&P)
radio.button.default.empty.template=預設/空模板(&E)
radio.button.with.inheritdoc.tag=帶有 @inheritDoc 標記(&I)
label.constant.syntax=常數語法(&C)
php.interpreter.label.label=標籤
no.expression.found=找不到表達式
empty.type=空類型
add.catch.clause.quick.fix=添加 'catch' 從句
php.delete.catch.clause.quick.fix=刪除 'catch' 子句
php.delete.exception.quick.fix=刪除異常
php.surround.with.try.catch.quick.fix=使用 'try-catch' 環繞
trait.use.rule.type.name=特徵 use 規則方法
member.has.0.access.but.class.has.magic.method.1=成員具備 {0} 可見性，但可以通過 ''{1}'' 魔術方法存取
member.has.0.access=成員具備 {0} 可見性
declaration.must.be.compatible.with.0=宣告必須與 {0} 相容
declaration.must.be.compatible.with.super=宣告必須與父級相容
return.type.declaration.must.be.compatible.with.super=返回類型宣告必須與父級相容
array.only.updated.but.never.queried=陣列僅被更新，但從未被查詢
composer.json.open.tool.settings.intention=打開工具設定
composer.json.path.not.configured=自訂儲存庫無法載入。未配置 composer.json 路徑
composer.json.exec.not.configured=自訂儲存庫無法載入。未配置 Composer 可執行檔案路徑
composer.json.custom.packages.done=自訂儲存庫已載入
composer.json.custom.packages.empty=找不到軟體套件。請檢查您的儲存庫
composer.json.custom.invalid.json=json 無效
composer.json.packagist.packages.done=僅載入了 packagist 儲存庫
composer.json.packages.loading.error=軟體套件未重新載入
composer.json.packages.refresh=軟體套件正在刷新
cant.save.interpreter=無法儲存 ''{0}'': {1}
method.is.undefined.in.class=方法 ''#ref'' 在 {0} 中{1,choice,0#未找到|1#可能未定義}
method.is.undefined=方法 '#ref' {0,choice,0#未定義|1#可能未定義}
property.is.undefined.in.class=屬性 ''#ref'' 在 {0} 中{1,choice,0#未找到|1#可能未定義}
property.is.undefined=屬性 '#ref' {0,choice,0#未定義|1#可能未定義}
find.cause=尋找原因
find.exception.cause.table.title=異常原因
php.find.clause.throws=可能拋出: {0}
action.PhpStanAddToIgnored.text=添加到 PHPStan 忽略列表
action.PhpStanAddToIgnored.description=添加到 PHPStan 忽略列表
inspection.php.unused.display.name=未使用的宣告
inspection.php.expression.always.constant.inspection.display.name=到達時，變數始終為 true/false
inspection.composer.json.file.references.inspection.display.name=未解析的檔案引用
inspection.php.doc.duplicate.type.inspection.display.name=類型已存在於 PHPDoc 標記中
inspection.php.class.implements.solely.traversable.inspection.display.name=類無法直接實作 Traversable
inspection.php.array.used.only.for.write.inspection.display.name=陣列僅用於寫存取
inspection.php.private.field.can.be.local.variable.inspection.display.name=private 屬性可為局部
inspection.php.foreach.variable.overwrite.already.defined.variable='foreach' 變數覆寫已定義的變數
inspection.php.inappropriate.inherit.doc.usage.inspection.display.name=使用了不當的 @inheritDoc
inspection.php.expression.with.same.operands.inspection.display.name=邏輯表達式有相同操作數
inspection.php.traits.use.list.inspection.display.name=每行一個特徵 use
inspection.php.long.type.form.inspection.display.name=類型關鍵字的縮寫
inspection.php.compound.namespace.depth.inspection.display.name=復合命名空間深度大於 2
inspection.php.separate.else.if.inspection.display.name=Else if
inspection.php.new.class.missing.parameter.list.inspection.display.name=缺少參數列表
inspection.php.var.usage.inspection.display.name=使用了 var
inspection.php.modifier.order.inspection.display.name=修飾符順序
inspection.php.missing.visibility.inspection.display.name=缺少可見性
inspection.php.parameter.by.ref.is.not.used.as.reference.inspection.display.name=不必要的通過引用傳遞
inspection.php.accessed.array.is.always.empty=陣列在存取點始終為空
inspection.php.if.can.be.merged.with.sequential.condition='if' 可以與後續條件合併
inspection.php.instanceof.is.always.true='instanceof' 的結果始終為 'true'
inspection.php.in.array.can.be.replaced.with.comparison='in_array' 可以取代為比較
inspection.php.func.get.arg.can.be.replaced.with.parameter.access='func_get_arg()' 調用可以取代為參數存取
inspection.php.format.function.call.with.single.argument=使用單個實參格式化函數調用
inspection.php.invalid.instanceof.argument.type='instanceof' 的實參只應是物件或字串
inspection.php.condition.always.evaluates.to.constant=條件始終評估為 'true/false'
inspection.php.condition.checked.by.next.condition=邏輯表達式內部的條件由後續條件檢查
inspection.php.array.write.access.is.not.used=未使用陣列寫入存取
inspection.php.redundant.optional.argument=冗餘的可選實參
inspection.php.property.only.written=屬性用法具有相同的存取權限
inspection.php.to.string.may.produce.exception='__toString' 可能會拋出異常
inspection.php.loop.never.iterates.name=迴圈未迭代
inspection.php.loop.never.iterates=''{0}'' 語句不迴圈
inspection.php.ternary.expression.can.be.replaced.with.condition.inspection.display.name=三元表達式可以取代為條件
inspection.php.ternary.expression.can.be.replaced.with.short.version=三元表達式可以取代為短版本
inspection.php.unnecessary.local.variable.inspection.display.name=不必要的局部變數
inspection.php.unnecessary.semicolon.inspection.display.name=不必要的分號
inspection.php.curly.brace.access.syntax.usage.inspection.display.name=使用了大括號存取語法
inspection.php.single.statement.with.braces.inspection.display.name=單語句主體帶大括號
inspection.php.statement.without.braces.inspection.display.name=控制語句主體無大括號
inspection.php.str.functions.inspection.display.name='str*()' 調用可以取代為 PHP 8 'str_*()' 調用
inspection.php.nested.ternary.expression.usage.inspection.display.name=使用了嵌套的三元運算符
inspection.php.doc.field.type.mismatch.inspection.display.name=類型與屬性的宣告類型不符合
inspection.php.switch.case.without.default.branch.inspection.display.name=switch 語句沒有 default 分支
inspection.php.strict.comparison.of.operands.with.different.types=嚴格比較類型不相容的操作數
inspection.php.suspicious.name.combination.inspection.name=可疑名稱組合
inspection.php.duplicate.switch.case.body.inspection.display.name=switch 語句中存在重複分支
inspection.php.duplicate.switch.catch.body.inspection.display.name='catch' 語句中的重複分支
inspection.php.exception.is.immediately.rethrown=立即重新拋出異常
inspection.php.continue.targeting.switch='continue' 針對 'switch' 語句
inspection.php.redundant.continue.break.argument=冗餘的 'continue/break' 實參
inspection.php.duplicate.match.arm.body.inspection.display.name='match' 表達式中的重複 arm
inspection.php.field.assignment.type.mismatch.inspection.display.name=屬性賦值中的類型不符合
inspection.php.closure.can.be.converted.to.short.arrow.function.inspection.display.name=閉包可以轉換為箭頭函數
inspection.php.concatenation.with.arithmetic.usage=具有算術用法的串聯
inspection.php.parameter.always.have.same.value=參數值始終相同
inspection.php.method.return.value.is.never.used=方法的返回值從未使用
inspection.php.isset.can.be.replaced.with.coalesce='isset' 可以取代為合併
inspection.php.cast.is.unnecessary=類型轉換不必要
inspection.php.unnecessary.curly.variable.syntax=變數的不必要大括號語法
inspection.php.unpacked.argument.type.mismatch.inspection.display.name=無效類型的解包實參
inspection.php.missing.return.type.inspection.display.name=缺少返回類型宣告
inspection.php.missing.parameter.type.inspection.display.name=缺少參數的類型宣告
inspection.php.missing.field.type.inspection.display.name=缺少屬性的類型宣告
inspection.php.expression.without.clarifying.parentheses.inspection.display.name=表達式不帶澄清括號
inspection.php.unnecessary.parentheses.inspection.display.name=不必要的圓括號
inspection.php.method.may.be.static.inspection.display.name=方法可以為 'static'
inspection.php.format.function.parameters.mismatch.inspection.display.name=格式函數參數不符合
inspection.php.ignored.class.alias.declaration.display.name=忽略的類別名聲明
inspection.php.composer.duplicated.requirement.inspection.display.name=composer.json 中存在重複的軟體套件條目
inspection.php.not.installed.packages.inspection.display.name=未安裝的 Composer 軟體套件
inspection.php.disabled.quality.tool.composer.inspection.display.name=品質工具檢查已禁用
inspection.php.composer.extension.stubs.inspection.display.name=composer.json 中缺少擴展
inspection.php.disabled.extension.stubs.inspection.display.name=已禁用的擴展存根
inspection.php.array.fill.can.be.converted.to.loop.inspection.display.name='array_fill' 可以轉換為迴圈
inspection.php.loop.can.be.converted.to.array.fill.inspection.display.name=迴圈可以轉換為 'array_fill()' 調用
inspection.php.get.class.can.be.replaced.with.class.name.literal.inspection.display.name='get_class()' 調用可以取代為 '::class'
inspection.php.array.filter.can.be.converted.to.loop.inspection.display.name='array_filter()' 調用可以轉換為迴圈
inspection.php.loop.can.be.converted.to.array.filter.inspection.display.name=迴圈可以轉換為 'array_filter()' 調用
inspection.php.loop.can.be.converted.to.array.map.inspection.display.name=迴圈可以轉換為 'array_map()' 調用
inspection.php.array.map.can.be.converted.to.loop.inspection.display.name='array_map()' 調用可以轉換為迴圈
inspection.php.short.open.tag.inspection.display.name=使用了短起始標記
inspection.php.constructor.style.inspection.display.name=舊式構造函數
inspection.php.assignment.replaceable.with.prefix.expression.inspection.display.name=賦值可取代為增量或減量
inspection.php.assignment.replaceable.with.operator.assignment.inspection.display.name=賦值可以取代為運算符賦值
inspection.php.invalid.magic.method.modifiers.inspection.display.name=魔術方法修飾符無效
inspection.php.incorrect.magic.method.signature.inspection.display.name=魔術方法簽名不正確
inspection.php.array.access.on.illegal.type.display.name=非法類型的陣列偏移存取
inspection.php.parameter.name.chaged.during.inhertiance=在繼承期間更改了參數名稱
inspection.php.named.argument.may.be.unresolved=命名實參可能未解析
inspection.php.argument.without.name.identifier=無名稱關鍵字的實參
inspection.php.named.argument.usage=有名稱關鍵字的實參
inspection.php.named.arguments.with.changed.order=命名實參順序與參數順序不符合
inspection.php.mixed.return.type.can.be.reduced=可以限縮 'mixed' 返回類型的範圍
inspection.php.null.is.not.compatible.with.parameter='null' 與參數的宣告類型不相容
inspection.php.nested.dirname.call.can.be.replaced.with.levels.usage=嵌套的 'dirname()' 調用可以取代為 'levels' 參數用法
inspection.php.trait.method.use.is.located.inside.different.target.class=特徵 use 規則已解析為使用不同包含類的方法 
inspection.php.trait.usage=不允許特徵用法
inspection.php.class.cant.be.used.as.attribute=類不能用作特性
inspection.php.redundant.match.expression='match' 表達式只有 default arm，應當進行簡化
inspection.php.loop.can.be.replaced.with.str.repeat=迴圈可以取代為 'str_repeat'
inspection.php.concatenation.with.empty.string.can.be.merged=空字串的串聯可以與賦值合併
inspection.php.match.expression.can.be.replaced.with.ternary='match' 表達式可以取代為三元表達式
inspection.php.switch.can.be.replaced.with.match.expression='switch' 可以取代為 'match' 表達式
inspection.php.inapplicable.attribute.target.declaration=不適用的特性目標宣告
inspection.php.expected.values.should.be.used=應使用預期值
inspection.php.immutable.property.is.written.in.invalid.scope=在無效的作用域中寫入不可變屬性
inspection.php.attribute.is.not.repeatable=不可重複的特性
inspection.php.attribute.no.return.can.be.added=可以添加 NoReturn 特性
inspection.php.pure.contract.attribute.can.be.added=可以添加 '#[Pure]' 特性
inspection.php.pure.function.may.produce.side.effect=純函數可能會產生副作用
inspection.php.attribute.array.shape.can.be.added=可以添加 '#[ArrayShape]' 特性
inspection.php.attribute.can.be.overridden=可以將特性添加到覆寫成員
inspection.php.array.key.does.not.match.array.shape=陣列鍵與陣列形狀不符合 
inspection.php.missing.strict.types.declaration.inspection.display.name=缺少嚴格類型宣告
inspection.php.incompatible.return.type.inspection.display.name=返回類型不相容
inspection.php.strict.type.checking.inspection.display.name=嚴格類型檢查規則違反
inspection.php.non.canonical.elements.order.inspection.display.name=元素的非規範順序
inspection.php.null.safe.operator.can.be.used=可以使用 Nullsafe 運算符 '?->'
inspection.php.variable.variable.inspection.display.name=使用了可變變數
inspection.php.traditional.syntax.array.literal.inspection.display.name=檢測到傳統語法陣列文字
inspection.php.illegal.psr.class.path.inspection.display.name=類路徑與專案結構不符合
inspection.php.multiple.classes.declarations.in.one.file.display.name=一個檔案中有多個類宣告
inspection.php.redundant.catch.clause.inspection.display.name=冗餘 catch 子句
inspection.php.unhandled.exception.inspection.display.name=未處理的異常
inspection.php.non.strict.object.equality.inspection.display.name=非嚴格物件相等
inspection.php.duplicate.case.inspection.display.name=switch 語句中存在重複的 case
inspection.php.duplicate.match.condition.inspection.display.name=重複條件
inspection.php.unused.match.arm.condition.inspection.display.name=未使用的 'match' 條件
inspection.php.comment.will.be.parsed.as.attribute=在 PHP 8.0 中註釋被解析為特性
inspection.php.redundant.attribute.parenthesis=特性中的冗餘圓括號
inspection.php.fully.qualified.name.usage.inspection.display.name=使用了完全限定名稱
inspection.php.unnecessary.fully.qualified.name.inspection.display.name=不必要的完全限定名稱
inspection.mess.detector.validation.inspection.display.name=PHP Mess Detector 驗證
inspection.php.CS.fixer.validation.inspection.display.name=PHP CS Fixer 驗證
inspection.php.CS.validation.inspection.display.name=PHP_CodeSniffer 驗證
inspection.php.usage.of.silence.operator.inspection.display.name=使用了靜默運算符
inspection.php.useless.trailing.comma.inspection.display.name=無用的尾隨逗號
inspection.php.useless.trailing.comma.inspection.desc=無用的尾隨逗號
inspection.php.remove.useless.trailing.comma=移除無用的尾隨逗號
inspection.php.add.line.break.after.trailing.comma=在尾隨逗號後添加換行符
inspection.php.foreach.array.is.used.as.value.inspection.display.name=Foreach 陣列用作值
inspection.php.foreach.nested.outer.key.value.variables.conflict.inspection.display.name=嵌套與外部 'foreach' 變數衝突
inspection.php.missing.break.statement.inspection.display.name=缺少 'break' 語句
inspection.php.unit.covers.by.access.modifier.is.deprecated.inspection.display.name=棄用的通過修飾符註解進行的 @covers/@uses
inspection.php.unit.expected.exception.doc.tag.is.deprecated.inspection.display.name=棄用的通過文檔標記進行的異常處理
inspection.php.unit.deprecated.expect.exception.inspection.display.name=使用了棄用的 expectException
inspection.php.unit.assert.array.has.key.inspection.display.name=可以改用方法 'assertArrayHasKey/assertArrayNotHasKey'
inspection.php.unit.misordered.assert.equals.arguments.inspection.display.name=順序錯誤的 PHPUnit 等式斷言方法實參
inspection.php.unit.assert.count.inspection.display.name=使用了 'assertCount/assertSameSize' 方法而非 assertEquals
inspection.php.unit.assert.contains.inspection.display.name=棄用的 'assertContains/assertNotContains' 用法
inspection.php.unit.assert.can.be.replaced.with.fail=斷言可以取代為 'fail'
inspection.php.unit.assert.empty.inspection.display.name=斷言可以取代為 'assertEmpty/assertNotEmpty'
inspection.php.unit.assert.file.equals.inspection.display.name=棄用的 'assertFileEquals/assertStringEqualsFile' 用法
inspection.php.unit.assert.equals.inspection.display.name=棄用的 'assertEquals/assertNotEquals' 用法
inspection.php.unit.covers.function.without.scope.resolution.operator.inspection.display.name=提供的覆蓋函數引用沒有 ‘::’
inspection.php.unit.undefined.data.provider.inspection.display.name=未定義的 PHPUnit 資料提供程序
inspection.php.unit.missing.target.for.test.inspection.display.name=PHPUnit 測試缺少目標元素
inspection.php.constant.naming.convention.inspection.display.name=常數名稱未遵循編碼慣例
inspection.php.variable.naming.convention.inspection.display.name=變數名稱未遵循編碼慣例
inspection.php.property.naming.convention.inspection.display.name=屬性名稱未遵循編碼慣例
inspection.php.method.naming.convention.inspection.display.name=方法名稱未遵循編碼慣例
inspection.php.function.naming.convention.inspection.display.name=函數名稱未遵循編碼慣例
inspection.php.class.naming.convention.inspection.display.name=類名未遵循編碼慣例
inspection.php.overriding.method.visibility.inspection.display.name=方法可見性不應被覆寫
inspection.php.method.or.class.call.is.not.case.sensitive.inspection.display.name=方法調用或類用法中的大小寫不符合
inspection.php.expression.result.unused.inspection.display.name=未使用表達式結果
inspection.php.throwable.not.thrown.inspection.display.name=未拋出 Throwable
inspection.php.void.function.result.used.inspection.display.name=使用了 void 函數結果
inspection.php.redundant.closing.tag.inspection.display.name=冗餘結束標記
inspection.php.too.many.parameters.inspection.display.name=函數宣告中的參數過多
inspection.php.method.parameters.count.mismatch.inspection.display.name=參數數量與宣告不符合
inspection.php.inconsistent.return.points.inspection.display.name=不一致的返回點
inspection.php.redundant.variable.doc.type.inspection.display.name=冗餘 @var 標記
inspection.php.doc.redundant.throws.inspection.display.name=冗餘 @throws 標記
inspection.php.doc.missing.throws.inspection.display.name=缺少 @throws 標記
inspection.php.redundant.doc.comment.inspection.display.name=冗餘 PHPDoc 註釋
inspection.php.doc.signature.inspection.display.name=PHPDoc 註釋符合函數/方法簽名
inspection.php.doc.is.not.complete.inspection.display.name=PHPDoc 註釋簽名不完整
inspection.php.return.doc.type.mismatch.inspection.display.name=PHPDoc 註釋中的返回類型與實際返回類型不符合
inspection.php.illegal.string.offset.inspection.display.name=非法字串偏移
inspection.php.illegal.array.key.type.inspection.display.name=非法陣列鍵類型
inspection.php.silly.assignment.inspection.display.name=冗餘賦值
inspection.php.missing.doc.comment.inspection.display.name=缺少 PHPDoc 註釋
inspection.php.unused.parameter.inspection.display.name=未使用的參數
inspection.php.wrong.foreach.argument.type.inspection.display.name=為 'foreach()' 提供的無效實參
inspection.php.division.by.zero.inspection.display.name=除以零
inspection.php.assignment.in.condition.inspection.display.name=條件中的賦值
inspection.php.wrong.catch.clauses.order.inspection.display.name=catch 子句順序錯誤
inspection.php.wrong.string.concatenation.inspection.display.name=字串串聯錯誤
inspection.php.constant.reassignment.inspection.display.name=常數重新賦值
inspection.php.non.compound.use.inspection.display.name=不必要的語句使用
inspection.php.to.string.implementation.inspection.display.name=方法 '__toString' 實作
inspection.php.to.string.return.inspection.display.name=方法 '__toString' 返回類型
inspection.php.internal.entity.used.inspection.display.name=使用了內部實體
inspection.php.deprecated.implode.usage.inspection.display.name=棄用的 'implode/join' 用法
inspection.php.expression.always.null.inspection.display.name=表達式始終為 'null'
inspection.php.deprecated.cast.inspection.display.name=棄用的轉換
inspection.php.define.constant.name.with.leading.slash=使用前導斜杠定義的常數名稱
inspection.php.define.constant.can.be.replaced.with.const.syntax=define 常數名稱可以取代為 'const' 語法
inspection.php.element.is.not.available.in.current.php.version.inspection.display.name=元素在配置的 PHP 版本中不可用
inspection.php.deprecation.inspection.display.name=已棄用
inspection.php.plural.mixed.can.be.replaced.with.array='mixed' 類型可以取代為 'array'
inspection.php.language.level.inspection.display.name=語言級別
inspection.php.unused.field.default.value.inspection.display.name=冗餘屬性初始值設定項
inspection.php.unused.alias.inspection.display.name=未使用的 import
inspection.php.unused.local.variable.inspection.display.name=未使用的局部變數
inspection.php.write.access.to.referenced.array.value.without.unset=對無 'unset' 的引用陣列值的寫入權限
inspection.php.boolean.expression.can.be.simplified=可以簡化布爾表達式
inspection.array.access.can.be.replaced.with.foreach.value=陣列存取可以取代為 'foreach' 值
inspection.php.unused.private.field.inspection.display.name=未使用的 private 屬性
inspection.php.unused.private.method.inspection.display.name=未使用的 private 方法
inspection.php.goto.into.loop.inspection.display.name=Goto 轉入迴圈語句
inspection.php.pass.by.ref.inspection.display.name=通過引用傳遞參數
inspection.php.optional.before.required.parameters.inspection.display.name=可選參數在必選參數之前
inspection.php.params.inspection.display.name=參數類型
inspection.php.include.inspection.display.name=未解析的 include
inspection.php.undefined.constant.inspection.display.name=未定義的常數
inspection.php.undefined.field.inspection.display.name=未定義的屬性
inspection.php.statement.has.empty.body.inspection.display.name=語句具有空體
inspection.php.missing.parent.call.magic.inspection.display.name=魔術方法缺少父調用
inspection.php.missing.parent.call.common.inspection.display.name=方法缺少父調用
inspection.php.missing.parent.constructor.inspection.display.name=構造函數缺少父調用
inspection.php.undefined.class.constant.inspection.display.name=未定義的類常數
inspection.php.super.class.incompatible.with.interface.inspection.display.name=父類的方法宣告與實作的接口不相容
inspection.php.signature.mismatch.during.inheritance.inspection.display.name=覆寫方法的宣告應與父類相容
inspection.php.abstract.static.method.inspection.display.name=static 函數不應為 abstract
inspection.php.static.as.dynamic.method.call.inspection.display.name=static 方法被調用為動態
inspection.php.dynamic.as.static.method.call.inspection.display.name=動態方法被調用為 static
inspection.php.possible.polymorphic.invocation.inspection.display.name=可能的多態調用
inspection.php.promoted.field.usage=提升的屬性用法
inspection.field.can.be.promoted=可以提升屬性
inspection.php.redundant.assignment.to.promoted.field=冗餘的提升屬性賦值
inspection.php.undefined.callback.inspection.display.name=未定義的回調
inspection.php.undefined.function.inspection.display.name=未定義的函數
inspection.php.undefined.class.inspection.display.name=未定義的類
inspection.php.multiple.class.declarations.inspection.display.name=多個類宣告
inspection.php.undefined.namespace.inspection.display.name=未定義的命名空間
inspection.php.undefined.method.inspection.display.name=未定義的方法
inspection.php.undefined.variable.inspection.display.name=未定義的變數
inspection.php.undefined.goto.label.inspection.display.name=未定義的 goto 標籤
inspection.php.group.undefined=未定義的符號
inspection.php.group.probable.bugs=可能的錯誤
inspection.php.group.general=常規
inspection.php.group.strict.standards=PHP 嚴格標準
inspection.php.group.type.compatibility=類型相容性
inspection.php.group.control.flow=控制流
inspection.php.group.code.smell=程式碼異味
inspection.php.group.psr.12=PSR-12
inspection.php.group.phpdoc=PHPDoc
inspection.php.group.code.style=程式碼樣式
inspection.php.group.composer=Composer
inspection.php.group.unused=未使用的符號
inspection.php.group.naming.conventions=命名慣例
inspection.php.group.phpunit=PHPUnit
inspection.php.group.quality.tools=品質工具
inspection.php.group.replacable.assignments=可取代賦值
inspection.php.group.error.handling=錯誤處理
inspection.php.group.attributes=特性
list.item.update.phpdoc.comment=更新 PHPDoc 註釋
inspection.php.unnecessary.return.inspection.display.name=不必要的 'return/continue' 語句
inspection.php.unnecessary.else.inspection.display.name=不必要的 'else' 分支
inspection.php.unnecessary.return.function='return' 不必要，因為是函數中的最後一條語句
inspection.php.unnecessary.return.method='return' 不必要，因為是方法中的最後一條語句
inspection.php.unnecessary.continue='continue' 不必要，因為是迴圈中的最後一條語句
php.unit.create.target.method.quick.fix.family.name=創建缺少的目標方法
inspection.php.missing.return.type.description=缺少函數的返回類型宣告
inspection.php.missing.param.type.description=缺少參數的類型宣告
quickfix.php.missing.param.type.description=作為參數類型添加 ''{0}''
quickfix.php.missing.param.type.batch.description=作為屬性類型添加推斷的類型
php.add.method.declaration.quick.fix.text=添加方法
php.add.tag.base.quick.fix.family.name=添加 {0} 標記
inspection.php.unused.field.default.value.description=屬性初始值設定項冗餘
php.change.function.signature.manually.quick.fix.family.name=手動更改簽名
php.change.function.signature.from.usage.quick.fix.family.name=從用法改變函數簽名
searching.for.usages=正在搜尋用法…
php.replace.with.local.variable.quick.fix.family.name=將屬性取代為局部變數
inspection.php.private.field.can.be.local.variable.description=屬性可以取代為局部變數
inspection.php.abstract.static.method.description=PHP 嚴格標準: static 方法 '#ref' 不應為 abstract
php.replace.argument.with.cast.quick.fix.family.name=將實參轉換為{0}
php.change.cast.operation.quick.fix.family.name=將轉換更改為{0}
php.replace.with.null.quick.fix.family.name=取代為 'null'
inspection.php.expression.always.null.description='#ref' 始終為 'null'
inspection.unnecessary.static.reference=final 類中有冗餘的 'static'
inspection.unnecessary.string.cast=冗餘轉換為字串
inspection.unnecessary.bool.cast=冗餘轉換為布林值
php.configure.extensions.quick.fix.family.name=配置擴展存根
php.enable.extension.quick.fix.family.name=啟用擴展存根
php.enable.extension.quick.fix.text=啟用 ''{0}'' 擴展存根
inspection.php.disabled.extension.stubs.description=已禁用的 ''{0}'' 擴展存根
inspection.php.unnecessary.semicolon.description=不必要的 ;
inspection.php.inappropriate.inherit.doc.usage.description=@inheritDoc 用於沒有父級成員但含有 doc 註釋的成員
inspection.php.inappropriate.inherit.doc.usage.description2=@inheritDoc 應僅用於類成員
php.inline.variable.quick.fix.family.name=內聯變數
update.php.doc.type.family.name=更新 PHPDoc 類型
update.php.doc.type.comment=取代為 ''{0}''
inspection.php.return.doc.type.mismatch=PHPDoc 中的返回類型與實際返回類型不符合
inspection.php.doc.signature.description=重複的實參 PHPDoc
inspection.php.doc.signature.description2=返回類型與宣告的不符合
inspection.php.doc.signature.description3=不存在實參的 PHPDoc
inspection.php.doc.signature.description5=實參類型與宣告的不符合
php.flip.variable.and.type.quick.fix.family.name=翻轉變數和類型
inspection.php.non.canonical.elements.order.description=變數及其類型以非規範順序列出
php.make.class.abstract.quick.fix.family.name=將類設為 abstract
php.remove.doc.tag.quick.fix.family.name=移除 {0}
php.make.method.non.final.quick.fix.family.name=將方法設為非 final
inspection.php.short.open.tag.description=使用了短起始標記
php.make.method.non.static.quick.fix.family.name=將方法設為非 static
php.flip.arguments.quick.fix.family.name=翻轉第一和第二個實參
inspection.php.unused.alias.description=匯入 '#ref' 不必要
inspection.php.unused.alias.description2=匯入 '#ref' 從未使用
php.rename.wrong.reference.quick.fix.family.name=重命名引用
php.append.doc.static.fix.family.name=在函數引用前追加 '::'
inspection.php.include.description=無法解析表達式 ''{0}'' 的目標
inspection.php.include.description2=未找到路徑 ''{0}''
make.call.dynamic.quick.fix.family.name=使調用為動態
inspection.php.undefined.class.description=類 '#ref' 存在多個定義
inspection.php.undefined.class.description2=未定義的類 '#ref'
inspection.php.undefined.class.description5=存在類 '#ref' 的其他宣告
php.dead.code.entries=PHP 死碼條目
inspection.php.redundant.variable.doc.type.description=@var 標記指定了已從原始碼推斷出的類型
php.remove.all.unused.parameters.quick.fix.text=移除所有未使用的參數
transform=轉換
remove=移除
php.remove.unused.local.variable.without.successor.quick.fix.family.name=移除變數 ''{0}''
php.replace.with.float.cast.quick.fix.family.name=取代為 '(float)' 轉換
php.create.data.provider.quick.fix.family.name=創建資料提供程序
inspection.php.undefined.namespace.description=未定義的命名空間 '#ref'
fix.not.available=修復不可用
php.unit.create.target.class.quick.fix.family.name=創建缺少的目標類
initialize.var.quick.fix.family.name=使用值初始化
inspection.php.statement.has.empty.body.description=語句具有空體
php.replace.with.interface.quick.fix.family.name=取代為 {0}
remove.redundant.suppression.quick.fix.family.name=移除 ''{0}'' 禁止
php.change.method.modifiers.quick.fix.family.name=更改修飾符
php.change.method.modifiers.quick.fix.text=移除修飾符
php.remove.statement.fix.family.name=移除
php.make.method.non.abstract.quick.fix.family.name=將方法設為非 abstract
replace.plus.asgn.to.concat.asgn.quick.fix.family.name=將 '+=' 取代為 '.='
replace.plus.to.concat.quick.fix.family.name=將 '+' 取代為 '.'
replace.with.0=取代為 {0}
php.remove.ref.from.function.declaration.quick.fix.family.name=從函數宣告中移除 '&'
php.remove.ref.from.assignment.quick.fix.family.name=將 '=\\\\\\\\&' 取代為 '='
php.remove.pass.by.ref.from.parameter.quick.fix.family.name=從參數中移除 '&'
inspection.php.pass.by.ref.description=僅變數可通過引用返回
php.non.strict.object.equality.quick.fix.text=取代為身份比較
php.add.field.declaration.quick.fix.text=添加屬性
quick.fix.error=快速修復錯誤
the.original.class.0.does.not.belong.to.the.project.and.cannot.be.modified=原始類 {0} 不屬於該專案\\\\n\\\\
並且無法修改。
add.constant.declaration.quick.fix.text=添加常數
constant.ref.not.found.in=在 {0} 中未找到常數 ''#ref''
php.remove.parameters.quick.fix.text=移除未使用的參數
replace.extends.implements=取代 'extends'/'implements'
inspection.php.undefined.class.other.declaration.exists={0} 處存在類 ''#ref'' 的其他宣告
inspection.php.undefined.class.other.declaration.exists.and={0} 和另 {1} 處存在類 ''#ref'' 的其他宣告
show.implementations.for.0={0} 的實作
show.super.types.for.0=顯示 {0} 的父類型
display.name.directory.0=目錄 ''{0}''
hint.text.element.doesn.t.have.fqn=元素沒有 FQN
instanceof.is.always.true={0} 已位於 {1} 的層次結構中
dialog.message.server.host.cannot.be.empty=伺服器主機不能為空
dialog.message.port.cannot.be.negative.number=端口號不能為負
dialog.message.query.string.cannot.start.with=查詢字串不能以 '?' 開頭
inspection.message.code.fragment.too.complex.to.parse.this.piece.code.will.be.treated.as.plain.text=程式碼段過於複雜，無法解析，因此將作為純文本處理
inspection.message.control.flow.too.big.to.analyze=控制流太大，無法分析
remove.variable=移除變數
annotator.fix.remove=移除 ''{0}''
inspection.message.class.may.inherit.from.final.class=類可能無法繼承 final 類
inspection.message.key.element.cannot.be.reference=鍵元素不能為引用
inspection.message.absolute.method.reference.should.be.specified.for.insteadof.trait.use.rule=應為 'insteadof' 特徵 use 規則指定絕對方法引用
inspection.message.generators.may.only.declare.return.type.generator.iterator.or.traversable.or.iterable.permitted=生成器只能宣告 ''Generator''、''Iterator''、''Traversable'' 或 ''iterable'' 的返回類型，不允許 {0}
find.usages.button.base.method=基方法
find.usages.button.current.method=當前方法
find.usages.prompt.dialog.implements=類 ''{1}'' 的方法 ''{0}()'' 在 ''{2}'' 中實作了{3,choice,0#方法|1#方法}\\\\n\\\\
要尋找基{3,choice,0#方法|1#方法}的用法嗎?
find.usages.prompt.dialog.overrides=類 ''{1}'' 的方法 ''{0}()'' 在 ''{2}'' 中重寫了{3,choice,0#方法|1#方法}\\\\n\\\\
要尋找基{3,choice,0#方法|1#方法}的用法嗎?
more.actions=更多操作…
show.log.of.composer.related.actions=顯示 Composer 相關操作的日誌
show.log=顯示日誌
members.to.report=要報告的成員
entry.points=入口點
constructors=構造函數
inspection.message.type.mismatch.should.be.conditional.expression=類型不符合: 應為條件表達式
filetype.doctrine.query.description=Doctrine 查詢語言
inspection.php.typed.property.might.be.uninitialized.inspection.display.name=類型化屬性可能未初始化
inspection.php.typed.property.might.be.uninitialized.inspection.problem=類型化屬性 ''{0}'' 可能未初始化
inspection.message.primitive.types.can.t.be.used.as.instanceof.argument=僅物件或字串應用作 ''instanceof'' 實參，當前: ''{0}''
another.definition.with.same.name.exists.in.this.file=此檔案中存在另一個具有相同名稱的定義
method.with.same.name.already.defined.in.this.class=此類中已經定義了具有相同名稱的方法
global.code.should.be.enclosed.in.global.namespace.declaration=全域程式碼應包含在全域命名空間宣告中
static.property.cannot.be.unset=static 屬性不能取消設定
the.yield.expression.can.only.be.used.inside.a.function='yield' 表達式只能在函數中使用
multiple.modifiers.are.not.allowed=不允許多個修飾符
access.type.for.interface.member.must.be.omitted=接口成員的存取類型必須省略
final.modifier.is.not.allowed.here=此處不允許使用 'final' 修飾符
fields.cannot.be.declared.final=屬性不能宣告為 final
abstract.modifier.is.not.allowed.here=此處不允許使用 'Abstract' 修飾符
fields.cannot.be.declared.abstract=屬性不能宣告為 abstract
static.modifier.is.not.allowed.here=此處不允許使用 'Static' 修飾符
jump.into.a.finally.block.is.disallowed=不允許跳入 'finally' 塊
cannot.use.static.as.function.return.type.declaration=不允許 'static' 作為類範圍外部的返回類型宣告
void.type.cannot.be.nullable=void 類型不能是可為 null
can.only.be.used.as.standalone.type={0} 僅可用作獨立類型
void.can.only.be.used.as.return.type=Void 只能用作返回類型
static.is.not.allowed.in.parameter.type.declaration=參數類型宣告中不允許 'static'
cannot.use.this.as.parameter=不能將 $this 用作參數
only.the.last.parameter.can.be.variadic=只有最後一個參數可以是可變形參
expression.is.not.allowed.as.parameter.default.value=表達式不允許為參數預設值
argument.passed.must.be.of.the.type.0.1.given=傳遞的實參必須為 {0} 類型，給定的為 {1}
variadic.parameter.cannot.have.a.default.value=可變形參不能具有預設值
only.simple.expressions.are.allowed=只允許簡單表達式
target.trait.should.be.specified=應指定目標特徵
call.to.0.1.construct.from.invalid.context=從無效上下文調用 ''{0} {1}::__construct()''
constants.defined.using.the.const.keyword.must.be.declared.at.the.top.level.scope=使用 'const' 關鍵字定義的常數必須在頂層範圍宣告
expression.is.not.allowed.as.constant.value=表達式不允許作為常量值
cannot.redeclare.constant.0=無法重新宣告常數 ''{0}''
expression.is.not.allowed.as.field.default.value=表達式不允許為欄位預設值
cannot.declare.self.referencing.constant=無法宣告自引用常數
a.class.constant.must.not.be.called.class.it.is.reserved.for.class.name.fetching=類常數不得被稱為 'class'；後者被保留用於類名提取
traits.cannot.have.constants=特征不能有常數
redefinition.of.parameters.is.not.allowed=不允許參數重新定義
method.0.clone.cannot.accept.any.arguments=方法 ''{0}::__clone()'' 不能接受任何實參
return.type.declaration.is.not.allowed=不允許返回類型宣告
method.should.not.be.finished.with=方法不應以 ';' 結束
method.should.either.have.body.or.be.abstract=方法應具有主體或為 abstract
interface.method.can.t.have.body=接口方法不能有主體
anonymous.function.expected=應為匿名函數
label.with.same.name.already.defined.in.current.scope=當前範圍中已定義具有相同名稱的標籤
interfaces.may.not.include.member.variables=接口可能不包括成員變數
0.with.same.name.already.defined.in.this.class=此類中已經定義了具有相同名稱的{0}
field=欄位
cannot.redeclare.static.0.1.as.non.static.2.3=無法將 static ''{0}::\${1}'' 重新宣告為非 static ''{2}::\${3}''
cannot.redeclare.non.static.0.1.as.static.2.3=無法將非 static ''{0}::\${1}'' 重新宣告為 static ''{2}::\${3}''
0.and.1.define.the.same.property.2=''{0}'' 和 ''{1}'' 定義相同的屬性 ''{2}''
access.level.to.0.1.must.be.2.as.in.class.3.or.weaker=''{0}::\${1}'' 的存取級別必須為 {2} (與類 {3} 中一樣)或更低
access.level.to.0.1.must.be.2.as.in.class.3.or.weaker2=''{0}::{1}'' 的存取級別必須為 {2} (與類 {3} 中一樣)或更低
cannot.inherit.previously.inherited.or.override.constant.0.from.interface.1=無法從接口 ''{1}'' 繼承先前繼承的常數 ''{0}'' 或將其覆寫
empty.implements.list=空實作列表
a.trait.cannot.implement.an.interface=特徵無法實作接口
class.cannot.implement.previously.implemented.interface=類無法實作先前實作的接口
class.should.not.implement.itself=類不應自行實作
empty.extends.list=空 extends 列表
a.trait.cannot.extend.a.class=特徵無法擴展類
interface.cannot.extend.previously.extended.interface=接口無法擴展先前擴展的接口
class.cannot.extend.from.trait=類無法從特徵擴展
0.should.not.extend.itself={0} 不應自行擴展
class=類
class.declarations.may.not.be.nested=類宣告不能被嵌套
cannot.use.traits.inside.of.interfaces=無法在接口內部使用特徵
trait.expected.class.found=應為特徵，發現類
absolute.reference.is.not.allowed=不允許絕對引用
cannot.use.0.as.lexical.variable=無法將 ''\${0}'' 用作詞法變數
duplicate.variable.0=重複的變數 ''{0}''
trailing.comma.is.not.allowed=不允許尾隨逗號
the.use.keyword.must.be.declared.in.the.outermost.scope.of.a.file.the.global.scope.or.inside.namespace.declarations=必須在檔案的最外側範圍(全域範圍)或命名空間宣告內部宣告 'use' 關鍵字
static.is.not.allowed.in.compile.time.constants=編譯時常量中不允許使用 'static::'
multiple.namespaces.in.a.file.should.use.same.preferably.braced.syntax=檔案中的多個命名空間應使用相同的(最好帶大括號)語法
no.content.allowed.before.namespace.declaration=命名空間宣告之前不允許任何內容
an.object.s.clone.method.cannot.be.called.directly=無法直接調用物件的 '__clone()' 方法
property.write=@property-write
property.read=@property-read
isset.only.works.with.variables.and.arrays=isset 僅適用於變數和陣列
cannot.use.positional.argument.after.argument.unpacking=無法在實參解包後使用位置實參
function.name.must.be.callable.a.string.closure.or.class.implementing.invoke.currently.0=函數名稱必須可調用 - 字串、閉包或實作 ''__invoke'' 的類，當前為 ''{0}''
using.this.when.not.in.object.context=不在物件上下文中時使用 '$this'
array.can.t.be.used.for.array.destructuring.assignment='array()' 不能用於陣列析構賦值
function.call.is.not.allowed.here=此處不允許使用函數調用
expression.is.not.assignable=表達式不可賦值
call.to.method.clone.from.invalid.context=從無效上下文調用方法 '__clone'
cannot.use.for.reading=無法使用 '[]' 進行讀取
it.s.not.possible.to.unpack.array.argument.by.reference=無法通過引用對陣列實參解包
spread.operators.in.arrays.are.not.supported.for.multiassignments.variables=多賦值變數不支持在陣列中使用展開運算符
it.s.not.possible.to.unpack.array.value.with.associated.key=無法使用關聯鍵解包陣列值
it.s.not.possible.to.unpack.array.key=無法解包陣列鍵
cannot.use.empty.array.elements.in.arrays=無法在陣列中使用空陣列元素
invalid.octal.literal.won.t.be.reported.by.php.but.will.work.incorrectly=無效的八進制文字: 不會由 PHP 報告，但無法正常工作
multiple.subsequent.underscores.in.a.numeric.literal.are.not.allowed=不允許在數字文字中使用多個後續下划線
expression.is.not.allowed.as.static.initializer=表達式不允許為 static 初始值設定項
namespace.declarations.cannot.be.nested=命名空間宣告不能被嵌套
global.namespace.should.use.braced.syntax=全域命名空間應使用帶大括號的語法
halt.compiler.can.only.be.used.from.the.outermost.scope=僅可從最外側範圍使用 '__halt_compiler()'
cannot.use.match.as.identifier=無法將 'match' 用作關鍵字，自 PHP 8.0 起作為預留關鍵字
cannot.use.class.on.primitive.type=只允許在物件上使用 '::class'
intention.name.replace.nullable.notation.with.null.as.part.union.type=用 '|null' 取代 '?' 作為聯合類型的一部分
intention.name.replace.null.as.part.union.type.with.nullable.notation=將 '|null' 作為聯合類型的一部分取代為 '?'
union.types.and.the.nullable.type.notation.cannot.be.mixed=聯合類型和可為 null 類型表示法不能混合
union.types.mixed.cannot.be.nullable=混合類型不能為可 null，'null' 已是混合類型的一部分
quick.fix.delete=刪除 ''{0}''
type.null.and.false.cannot.be.used.as.as.standalone.type='null' 和 'false' 不可用作獨立類型
is.duplicated.by.0=類型被 ''{0}'' 重複
intention.name.remove.duplicated.type=移除重複類型
popup.title.select.reference.to.remove=選擇要移除的類型
intention.family.name.append=追加 ''{0}''
intention.family.name.change.to.mixed=將類型更改為 'mixed'
inspection.php.redundant.type.in.union.type=類型宣告冗餘，可以簡化
inspection.php.redundant.type.in.union.type.template=類型宣告可以簡化為 ''{0}''
inspection.php.redundant.type.in.union.type.fix.name=簡化冗餘類型

inspection.message.always.true.because=條件始終為 ''{0, choice, 0#false|1#true}''，因為此時 ''{1}'' 已經為 ''{2, choice, 0#false|1#true}''
inspection.nullsafe.deref.unnecessary.because=Nullsafe 運算符{0,choice,0#將始終產生 ''null''|1#不必要}，因為此時 ''{1}'' 已經為 ''{2,choice,0#false|1#true}''
inspection.nullsafe.deref.unnecessary.because.evaluated=Nullsafe 運算符 ''{0,choice,0#將始終產生 ''null''|1#不必要}''，因為此時已評估 ''{1}''
inspection.message.always.true.because.evaluated=條件始終為 ''{0,choice,0#false|1#true}''，因為此時已評估 ''{1}''
hint.evaluation.makes.subsequent.condition.always.true=評估使後續條件始終為 'true'
hint.evaluation.fully.contains=評估結果完全覆蓋 ''{0}'' 的可能結果
hint.evaluation.makes.array.always.empty=評估使得陣列始終為空
intention.family.name.navigate.to.cause=導航到原因
intention.family.name.replace.ternary.expression.with.true.branch=將三元表達式取代為 ''{0}'' 分支
intention.family.name.replace.elseif.with.else=將 'elseif' 取代為 'else'
extract.condition=提取條件
delete.if=刪除 'if'
delete.elseif=刪除 'elseif'
action.show.in.log.text=在日誌中顯示
action.add.file.s.to.list.text=向列表中添加檔案
quality.tool.action.remove.file.s.from.list.text=從列表中移除檔案
quality.tool.action.clean.list.text=清除列表
quality.tool.border.title.ignored.files=已忽略的檔案
quality.tool.ignored.files={0} 忽略的檔案
intention.family.name.remove.redundant.arguments=移除冗餘的 {0, choice, 0#實參|1#實參}
inspection.message.redundant.argument={0, choice, 0#實參|1#實參}{0,choice,0#符合|1#符合}{0, choice, 0#參數的|1#參數的}預設{0, choice, 0#值|1#值}
plural.types.are.not.allowed.in.real.types=僅在 doc 類型中允許複數類型
intention.name.remove.brackets=刪除中括號
intention.name.replace.brackets.with.types=取代為 'array'
inspection.message.only.variables.can.be.passed.by.reference=僅可通過引用傳遞變數
expression.0=表達式 {0}
expression=表達式
notification.content.language.level.was.changed.to.based.on.project.usage=語言級別已根據專案中使用的功能設定為 {0}
action.revert.back.to.text=還原為 {0}
expected.class.reference=應為: 類引用
expected.expression=應為: 表達式
parser.unexpected=意外: {0}
parser.expected=應為: {0}
namespace.cannot.start.with.namespace.due.to.conflict.with.ns.relative.names=由於與 ns 相關名稱衝突，命名空間不能以 \\"namespace\\" 開頭
inspection.php.language.level.description='fn' 是 PHP 7.4 中的保留關鍵字
incorrect.null.safe.operator=錯誤的 nullsafe 運算符
replace.with.quest=取代為 '?'
required.parameters.missing=缺少所需參數 ''{0}''
parameter.ref.type.is.not.compatible.with.declaration=參數 '#ref' 類型與宣告不相容
add.remote.interpreter=添加遠端解釋器
the.remote.hosts.access.plugin.is.missing.please.enable.the.plugin.in.0.plugins=缺少 Remote Hosts Access 套件。請在“{0} | 套件”中啟用此套件。
extract.side.effect=提取副作用
delete.unused.element=刪除未使用的元素
suppress.all.for.file=對檔案全部禁止
callers=調用方
callees=被調用方
call.tree=調用樹
execution.statistics=執行統計
suppress.for.method=對方法禁止
suppress.for.function=對函數禁止
delete.redundant.switch.branch=刪除冗餘 'switch' 分支
suppress.for.phpdoc.comment=對 PhpDoc 註釋禁止
dynamically.declared.field=動態宣告的欄位
convert.closure.to.arrow.function=將閉包轉換為箭頭函數
suppress.for.file=對檔案禁止
choose.a.valid.0.launcher=選擇有效的 {0} 啟動器
0.location={0} 位置
0.path={0} 路徑:
configure=配置
file.0.does.not.exists=檔案 {0} 不存在
expressions=表達式
target=目標
creates.a.composer.json.file=創建 composer.json 檔案
composer.json.file=composer.json 檔案
implement.method=實作方法
split.elseif=拆分 'elseif'
add.setter=添加 setter
php=PHP
filetype.php.description=PHP
remove.redundant.initializer=移除冗餘的初始值設定項
delete.assignment=刪除賦值
in.0=\\\\ ({0} 內)
merge.nested.conditions=合併嵌套的條件
replace.quotes=取代引號
variable.dereferenced=已取消引用變數
0.1={0}，{1}
declaration.in.parent.class.is.incompatible.with.interface=父類中的宣告與接口不相容
copy.switch.branch=複製 'switch' 分支
default=預設:
replace.if.with.switch=將 'if' 取代為 'switch'
choose.an.alias.to.use=選擇要使用的別名
update.signature.to.match.phpdoc.comment=更新簽名以符合 PHPDoc 註釋
no.members.to.pull.up.found=未找到要向上拉取的成員
inject.language.using.phpdoc=使用 PHPDoc 注入語言
negate.boolean.expression=布爾表達式求反
no.members.to.push.down.found=未找到要向下推送的成員
replace.if.clause.with.ternary.expression=將 if 子句取代為三元表達式
0.pushing.members.down.will.result.in.them.being.deleted={0}\\\\n\\\\
向下推送成員將導致它們被刪除
remove.pass.by.ref.sign=移除 '\\\\\\\\&'
make.non.nullable=設為不可 null
reference=引用
function=函數
foreach=foreach
while=while
0=\\\\ ({0})
for=for
filetype.composer.log.description=Composer 日誌
clear.log=清除日誌
align.composer.log.console=對齊 Composer 日誌控制台
all.0=所有({0})
choose.executable.class.to.run.0=選擇用於執行 {0} 的可執行類
show.settings=顯示設定
enable=啟用
composite.test.patterns=復合測試模式
add.test.class.method=添加測試類/方法…
empty.pattern=空模式
ignore.imports.and.formatting=忽略匯入和格式設定
sort.the.elements.by.visibility.public.protected.private=按可見性對元素排序: public、protected、private
sort.by.visibility=按可見性排序
copy=複製
add=添加
replace.ternary.expression.with.if.clause=將三元表達式取代為 if 子句
information=資訊
always.show.pass.by.reference=始終顯示引用傳遞
show.name.for.all.arguments=顯示所有實參的名稱
composer.packages.versions=Composer 軟體套件版本
constructor.field=構造函數欄位
inspection.php.illegal.array.key.type.description={0} {1}
edit.template=編輯模板
remove.rule=移除規則
add.rule=添加規則
choose.super.class.or.interface=選擇超類或接口
choose.super.method=選擇 super 方法
extends.implements.overrides=擴展/實作/覆寫
remove.unnecessary.semicolon=移除不必要的分號
choose.properties=選擇屬性
composer=composer
composer.executable='composer' 可執行檔案
0.12={0}:{1}
label=標籤
namespace=命名空間
alias=別名
constant=常數
field1=欄位
class.constant=類常數
function2=函數
method=方法
class1=類
interface=接口
parameter=參數
variable=變數
cancel=取消
do.not.override=不覆寫
override=覆寫
method.name=方法名稱
proceed=繼續
add.custom.format.function=添加自訂格式函數…
02={0}::
add.class=添加類…
all.exceptions.considered.checked=所有異常均被視為已檢查
html.note.core.extensions.are.part.of.the.php.core.and.cannot.be.left.out.of.a.php.binary.with.compilation.options.html=<html>注: 核心擴展是 PHP 核心的一部分，不能放在包含編譯選項的 PHP 二進制檔案外部。</html>
choose.elements.to.generate.phpdoc.for=選擇要為其生成 PHPDoc 的元素
no.elements.to.generate.phpdoc.for=沒有任何可為其生成 PHPDoc 的元素
invalid.class.name=無效類名
target.class=目標類:
03=({0})
constant.0=常數 {0}
usage.in.return.type=返回類型中的用法
usage.in.import.statement=import 語句中的用法
overriding.implementing.methods=覆寫/實作方法
usage.in.type.hinting=類型提示中的用法
usage.in.implements.clause=implements 子句中的用法
usage.in.extends.clause=etends 子句中的用法
method.call=方法調用
function.call=函數調用
04={0}:
field.ref.not.found=找不到欄位 '#ref'
method.ref.not.found=找不到方法 '#ref'
0.extends.1={0} 擴展 {1}
0.1.choice.0.extends.1.implements.2={0}{1, choice, 0# 擴展 |1# 執行 }{2}
remove.link.between.0.and.1=移除 {0} 與 {1} 之間的鏈接
import.from.deployment.configuration=從部署配置匯入
import=匯入
php.control.flow.viewer.0=PHP 控制流查看器: {0}
php.control.flow.viewer=PHP 控制流查看器
close=關閉(&C)
build.control.flow=構建控制流(&B)
change.member.access=更改成員存取
php.make.class.non.final.quick.fix.family.name=將類設為非 final
squash.repetitive.underscores=壓縮重複下划線
replace.with.01=取代為 {0}
filetype.profiler.snapshot.description=分析器快照
proxy.configuration=代理配置
surround.with.0=使用 ''{0}'' 環繞
rename.constructor=重命名構造函數
rename=重命名
replace.with.alias=取代為別名
strict.type.declaration.is.available.in.php.7.only=從 PHP 7.0 起才允許使用嚴格類型宣告
recursive.call=遞歸調用
smarty=Smarty
add.property=添加 @property
all.scripts=<All scripts>
summary=摘要
can.t.use.nullsafe.operator.in.write.context=在寫入上下文中不能使用 nullsafe 運算符
intention.family.name.collapse.whitespaces=摺疊空格
inspection.message.qualified.name.can.t.contain.whitespaces=限定名稱不能包含空格
php.language.level.widget=PHP 語言級別
tooltip.configured.php.language.level.widget=已配置的 PHP 語言級別
tooltip.configured.php.language.level.widget.composer=通過 Composer 配置的 PHP 語言級別
change.php.language.level=更改 PHP 語言級別
function.fqn=函數 FQN
choose.class=選擇類
older=較舊…
intention.family.name.replace.with=取代為 ''{0}''
inspection.message.redundant.static.in.final.class=final 類中有冗餘的 'static'
link.label.inspection={0} 檢查
intention.name.add.as.function.s.return.type=將 ''{0}'' 作為函數返回類型添加
add.return.type=添加返回類型
php.class=類
php.interface=接口
php.trait=特徵
clearing.cache=清除快取
diagnosing=診斷
simulating.update=模擬更新
generating.autoloader=生成自動載入器
listing.licenses=列出許可證
checking.for.changes.in.code.of.dependencies=檢查依賴項程式碼中的變更
validating=驗證
add.custom.format.function1=添加自訂格式函數
edit.custom.format.function=編輯自定義格式函數
no.item=沒有項
no.interpreter=<無解釋器>
open.in.editor=在編輯器中打開
how.to.fix=修正方法
path.to.php=<php 路徑>
constructor.already.exists=構造函數已存在
fluent.setters=Fluent setter
no.private.fields.to.generate.getters.for=沒有要為之生成 getter 的 private 欄位
no.private.fields.to.generate.both.getters.and.setters.for=沒有要為之同時生成 getter 和 setter 的 private 欄位
no.private.fields.to.generate.setters.for=沒有要為之生成 setter 的 private 欄位
choose.methods.to.implement=選擇要實作的方法
make.0.1=將 ''{0}'' 設為{1}
arrays.are.not.supported.as.operands.for.0=不支持將陣列用作 ''{0}'' 的操作數
types.not.supported.as.operands.for.0.1.2=''{1} {0} {2}'' 中不受支援的操作數類型將導致 PHP 8 TypeError
trait.method.0.will.not.be.applied.because.it.collides.with.1=由於與 ''{1}'' 衝突，因此不會套用特徵方法 ''{0}''
method.0.can.t.be.overridden.with.same.trait.1=無法使用相同的特徵 ''{1}'' 覆寫方法 ''{0}''
intention.name.make.non.final=將{0}設為非 final
replace.with.absolute.reference=取代為絕對引用
debug.output=輸出
no.candidate.methods.to.implement=沒有要實作的候選方法
choose.methods.to.implement1=選擇要實作的方法
choose.methods.to.override=選擇要覆寫的方法
no.candidate.methods.to.override=沒有要覆寫的候選方法
cannot.call.abstract.method.0.1=無法調用 abstract 方法 ''{0}::{1}''
intention.name.flip=翻轉 {0} 和 {1}
method.ref.is.deprecated=方法 '#ref' 已棄用
parameter.is.deprecated=參數 ''{0}'' 已棄用
function.ref.is.deprecated=函數 '#ref' 已棄用
class.ref.is.deprecated=類 '#ref' 已棄用
constant.ref.is.deprecated=常數 '#ref' 已棄用
field.ref.is.deprecated=欄位 '#ref' 已棄用
constant.ref.is.deprecated1=常數 '#ref' 已棄用
inspection.message.duplicate.case.expression=重複 case 表達式
inspection.message.duplicate.case.expression.ref=重複 case 表達式: #ref
replace.qualifier.with.an.import=將限定符取代為匯入
inspection.message.method.ref.marked.as.internal=方法 '#ref' 已標記為 @internal
inspection.message.function.ref.marked.as.internal=函數 '#ref' 已標記為 @internal
inspection.message.class.ref.marked.as.internal=類 '#ref' 已標記為 @internal
inspection.message.constant.ref.marked.as.internal=常數 '#ref' 已標記為 @internal
inspection.message.field.ref.marked.as.internal=欄位 '#ref' 已標記為 @internal
remove.from.the.parameter.0=從參數 ''{0}'' 中移除 ''\\\\\\\\&''
remove.from.function.0.declaration=從函數 ''{0}'' 宣告中移除 ''\\\\\\\\&''
remove.numeric.literals.separators=移除數字文字分隔符
intention.name.remove=移除 {0}
intention.name.convert.array.syntax.to.short=將陣列轉換為短語法
inspection.message.call.chain.too.long.to.analyse.break.it.into.fragments.up.to.calls=調用鏈過長，無法進行分析。請將其拆分為最多包含 {0} 個調用的片段
inspection.message.undefined.goto.label.ref=未定義的 goto 標籤 '#ref'
inspection.message.unused.private.property.ref=未使用的 private 屬性 '#ref'
intention.name.add.method.stubs=添加方法存根
inspection.message.from.php.this.allowed={0}。從 PHP {1} 起才允許這樣。
intention.name.make.abstract=將{0}設為 abstract
inspection.message.expression.without.parentheses=表達式沒有括號
add.clarifying.parentheses=添加澄清括號
replace.all.occurrences.with.php=將所有符合項取代為 '<?php'
inspection.message.parentheses.are.unnecessary=圓括號不必要
remove.unnecessary.parentheses=移除不必要的圓括號
inspection.message.goto.labels.inside.loops.or.switch.statements.are.not.allowed=不允許在迴圈或 switch 語句中使用 'goto' 標籤
dialog.title.configure.code.patterns=配置程式碼模式…
intention.family.name.generate.phpdoc.comment=生成 PHPDoc 註釋
intention.family.name.copy.phpdoc.from.parent=從父項複製 PHPDoc
inspection.message.constant.reassignment=常數重新賦值
merge.with.0.branch=與 ''{0}'' 分支合併
inspection.message.use.statement.with.non.compound.name.ref.has.no.effect=包含非復合名稱 '#ref' 的 'use' 語句沒有任何作用
insert.default.branch=插入 'default' 分支
inspection.message.tostring.method.must.return.string='__toString' 方法必須返回字串
inspection.message.psr.compound.namespace.with.depth.more.than.two.levels=PSR-12: 復合命名空間的深度超過兩級
psr.12.extract.namespace=PSR-12: 提取命名空間
inspection.message.psr.short.form.type.keywords.should.be.used=PSR-12: 應當使用類型關鍵字的縮寫
psr.12.convert.to.short.form=PSR-12: 轉換為縮寫
inspection.message.psr.missing.visibility.definition=PSR-12: 缺少可見性定義
psr.12.add.public.visibility=PSR-12: 添加 'public' 可見性
inspection.message.psr.order.modifiers.incorrect=PSR-12: 修飾符的順序不正確
psr.12.fix.modifiers.order=PSR-12: 修復修飾符順序
inspection.message.psr.missing.parameter.list=PSR-12: 缺少參數列表
psr.12.add.missing.parameter.list=PSR-12: 添加缺少的參數列表
inspection.message.psr.usage.else.if.construct=PSR-12: 使用 'else if' 結構
inspection.message.psr.traits.must.be.included.one.per.line=PSR-12: 必須以每行一個的形式添加特徵
psr.12.split.to.several.use.statements=PSR-12: 拆分為多個 'use' 語句
inspection.message.psr.usage.var=PSR-12: 'var' 的用法
psr.12.replace.var.with.public=PSR-12: 將 'var' 取代為 'public'
change.method.modifiers.to.0=將方法修飾符更改為 ''{0}''
intention.family.name.remove=移除 {0}
create.new.class.quickfix=創建新類
add.class1=添加類
intention.name.suppress.for.statement=對語句禁止
intention.name.change.cast.to=將 {0} 轉換更改為 {1}
intention.name.cast.to=將 {0} 轉換為 {1}
add.fluent.setter=添加 fluent setter
intention.family.name.add.getter.setter=添加 getter 和 setter
intention.family.name.add.getter=添加 getter
intention.family.name.add.number.separators=添加數字分隔符
convert.the.arrow.function.to.a.traditional.closure=將箭頭函數轉換為傳統閉包
intention.name.extract.if=提取 if ({0})
intention.family.name.initialize.properties=初始化屬性
merge.into.elseif=合併到 'elseif' 中
intention.family.name.replace.switch.with.if=將 'switch' 取代為 'if'
make.01=設為 ''{0}''
group.use.statements.by.selected.prefix=按所選前綴將 'use' 語句分組
intention.family.name.convert.heredoc.nowdoc.to.string.literal=將 HEREDOC/NOWDOC 轉換為字串文字
intention.family.name.convert.heredoc.to.string.literal=將 HEREDOC 轉換為字串文字
intention.family.name.convert.nowdoc.to.string.literal=將 NOWDOC 轉換為字串文字
convert.concatenation.to.sprintf.call=將串聯轉換為 'sprintf()' 調用
convert.string.interpolation.to.concatenation=將字串插值轉換為串聯
convert.string.interpolation.to.sprintf.call=將字串插值轉換為 'sprintf()' 調用
intention.name.convert.sprintf.call.to.concatenation=將 'sprintf()' 調用轉換為串聯
copy.concatenated.string.to.clipboard=將串聯的字串複製到剪貼簿
extract.selected.string.part.as.concatenation.operand=將所選字串部分作為串聯操作數提取
extract.selected.string.part.as.format.function.argument=將所選字串部分作為格式函數實參提取
surround.with.if.0.1=使用 ''if({0}({1}))'{'...'}''' 環繞
command.name.new.file=新建檔案
dialog.title.inline.variable=內聯變數
property.declaration=屬性宣告
class.constructor=類構造函數
label.global.namespace=<全域命名空間>
cannot.use.positional.argument.after.named.argument=無法在命名實參後面使用位置實參
named.parameter.overwrites.previous.argument=命名參數覆寫以前的實參
unknown.named.parameter=未知命名參數 ''{0}''
docker.compose.border.title.lifecycle=生命周期
action.configuration.text=配置…
inspection.message.constructor.cannot.be.static=構造函數不能為 static
inspection.message.destructor.cannot.be.static=析構函數不能為 static
inspection.message.clone.method.cannot.be.static='Clone' 方法不能為 static
inspection.message.cannot.make.non.abstract.method.abstract=無法將非 abstract 方法設為 abstract
inspection.message.cannot.override.final.method=無法覆寫 final 方法
inspection.message.cannot.make.method.visibility.lower.than.super.s=無法將方法的可見性設為低於父級的可見性
parsing.error.not.allowed=不允許使用 ''{0}''
parsing.error.unexpected.token=意外的標記: {0}
parsing.error.expression.not.assignable=表達式不可賦值
live.template.name.comment=註釋
php.remote.debug.name=PHP 遠端調試
php.web.application.name=PHP Web 套用程序
live.template.name.statement=語句
live.template.name.string.literal=字串文字
live.template.name.expression=表達式
cli.interpreters.name=CLI 解釋器
code.style.option.group.use=將 'use' 分組
code.style.option.attributes=特性
code.style.option.parameter.attributes=參數特性
code.style.option.in.namespace=在命名空間中
code.style.option.php.opening.tag=PHP 起始標記
code.style.option.new.line.after.php.tag=在 '<?php' 標記後換行
code.style.option.align.inline.comments=對齊內聯註釋
code.style.option.function.return.type=函數返回類型
code.style.option.return.type.on.new.line=返回類型位於新行中
code.style.option.align.key.value.pairs=對齊鍵值對
code.style.option.match.expression='match' 表達式
code.style.option.match.expression.align.match.arm.bodies=對齊 'match' arm 主體
code.style.option.place.on.new.line=將 ';' 置於新行中
code.style.option.class.field.constant.groups=類屬性/常數組
code.style.option.align.properties.in.columns=對齊列中屬性
code.style.option.align.constants=對齊常數
code.style.option.align.consecutive.assignments=對齊連續賦值
code.style.option.keep.and.on.one.line=將 ')' 和 '{' 保持在同一行
code.style.option.for.foreach.statements=for()/foreach() 語句
code.style.option.place.for.constructor=放置構造函數的 '()'
code.style.option.in.anonymous.class.declaration=在匿名類宣告中
code.style.option.function.constructor.call.arguments=函數/構造函數調用實參
code.style.option.function.declaration.parameters=函數宣告參數
code.style.option.in.closure.declaration=在閉包宣告中
code.style.option.in.function.declaration=在函數宣告中
code.style.option.place.on.new.line2=在最後一個元素後換行
code.style.option.new.line.after=在第一個元素後換行
code.style.option.after='{' 之後:
code.style.option.before.return.statement=在 'return' 語句前:
code.style.option.after.function=函數之後:
code.style.option.after.opening.tag=起始標記之後:
code.style.option.between.group.use.statements=在 'Use' 語句組之間:
code.style.option.around.class.constants=環繞類常數:
code.style.option.after.class.body=類主體之後:
code.style.option.before.class.body=類主體之前:
code.style.option.after.use.statements=在 'Use' 語句後:
code.style.option.before.use.statements=在 'Use' 語句前:
code.style.option.after.namespace=命名空間之後:
code.style.option.before.namespace=命名空間之前:
code.style.option.around.property=環繞屬性:
code.style.option.multiplicative.operators=乘法運算符(*, /, %, **)
code.style.option.arrow.function.parentheses=箭頭函數括號
code.style.option.anonymous.function.parentheses=匿名函數括號
code.style.option.shift.operators=移位運算符(<<,>>)
code.style.option.and=<?= 和 ?>
code.style.option.brackets.around.variable.expression=使用中括號將變數/表達式括起來
code.style.option.between.and='?' 與 ':' 之間
code.style.option.unary.additive.operators=一元加法運算符(+,-,++,--)
code.style.option.after.unary.not=一元非(!)之後
code.style.option.before.unary.not=一元非(!)之前
code.style.option.array.initializer.parentheses=陣列初始值設定項圓括號
code.style.option.function.left.brace=函數左大括號
code.style.option.function.declaration.parentheses=函數宣告括號
code.style.option.function.call.parentheses=函數調用括號
code.style.option.after.colon.in.return.type=返回類型中的冒號之後
code.style.option.space.around.pipe.in.union.types=聯合類型的 | 周圍
code.style.option.before.colon.in.return.type=返回類型中的冒號之前
code.style.option.before.colon.in.named.argument=命名實參中的冒號之前
code.style.option.after.colon.in.named.argument=命名實參中的冒號之後
code.style.option.assignment.in.declare.statement=在 declare 語句中賦值
code.style.option.null.coalescing.operator=null 合併運算符(??)
code.style.option.object.access.operator=物件存取運算符(->)
code.style.option.concatenation=串聯(.)
code.style.option.relational.operators=關係運算符(<, >, <=, >=, <=>)
link.label.languages.frameworks.php=PHP
inspection.message.cannot.make.static.method.non.static=無法將 static 方法 {0} 設為非 static
inspection.message.cannot.make.non.static.method.static=無法將非 static 方法 {0} 設為 static
dialog.title.select.properties.to.initialize=選擇要初始化的屬性
split.selected.group.use.statement=拆分所選 'use' 語句組
intention.family.name.convert.string.literal.to.heredoc.nowdoc=將字串文字轉換為 HEREDOC/NOWDOC
intention.name.convert.string.literal.to.heredoc=將字串文字轉換為 HEREDOC
intention.name.convert.string.literal.to.nowdoc=將字串文字轉換為 NOWDOC
intention.name.convert.concatenation.to.string.interpolation=將串聯轉換為字串插值
intention.name.convert.concatenation.to.scalar.value=將串聯轉換為標量值
intention.name.convert.sprintf.call.to.string.interpolation=將 'sprintf()' 調用轉換為字串插值
intention.name.convert.sprintf.call.to.scalar.value=將 'sprintf()' 調用轉換為標量值
parsing.error,at.expected=應為 '@'
parsing.error.method.label.expected=應為方法標籤
live.template.class.member=類成員
live.template.interface.member=接口成員
live.template.trait.member=特徵成員
dialog.error.title.php.extract.class=PHP 提取類
quality.tools.label.by.default.project.interpreter=預設為專案解釋器
file.0.does.not.exist=檔案 {0} 不存在
languages.frameworks.php.php.runtime=PHP / PHP 執行時
do.not.ask.again=不再詢問
enable.support=啟用支援
validating1=正在驗證…
cache.creating=正在創建 psalm 快取…
can.not.parse.phpunit.version.output.0=無法解析 PHPUnit 版本輸出: {0}
zend.debugger.settings.broadcasting.is.already.launched=Zend Debugger 設定廣播已啟動
directories=目錄
can.not.run.command.composer.execution.plugin.was.unloaded=無法執行命令: Composer 執行套件已移除
can.not.find.specified.interpreter=找不到指定的解釋器
no.response.from.0.after.1.ms={1} ms 後 {0} 未響應
cannot.register.handler=無法註冊處理程序
handler.with.the.same.session.id.is.already.registered=已註冊使用相同會話 ID 的處理程序
unknown.debugger.type=未知調試器類型
functions.to.be.extracted=要提取的函數
failed.to.parse.php.ini.output.0=無法解析 php --ini 輸出: {0}
can.not.find.0.helper.script=找不到 ''{0}'' 幫助程序腳本
can.not.execute.tests=無法執行測試
failed.to.run.interpreter=無法執行解釋器
failed.to.find.interpreter=無法尋找解釋器
set=設定
proxy.init=代理初始化
register.ide=註冊 IDE
0.for.1.run.configuration={1} 執行配置的 {0}
project.is.already.disposed=專案已處置
can.not.execute.transfer.task.project.is.already.disposed=無法執行傳輸任務: 專案已處置
proxy.stop=代理停止
cancel.ide.registration=取消 IDE 註冊
getting.installed.standards=正在獲取已安裝的標準…
php.remote.interpreter.plugin.is.not.installed=PHP Remote Interpreter 套件未安裝
execution.result.is.null=執行結果為 null
can.not.delete.temporary.file.because.it.was.not.created=無法刪除臨時檔案，因為未創建該檔案
0.inspection={0} 檢查
failed.to.find.valid.interpreter.path=無法尋找有效的解釋器路徑
with.data.set.0=使用資料集 {1} 的 {0}
add.phpunit.test.pattern=添加 PHPUnit 測試模式
unused.code.rules=未使用的程式碼規則
naming.rules=命名規則
design.rules=設計規則
controversial.rules=有爭議的規則
code.size.rules=程式碼大小規則
remote.interpreter.can.t.be.executed.please.enable.the.php.remote.interpreter.plugin=無法執行遠端解釋器。啟用 PHP Remote Interpreter 套件。
create.target.class.quick.fix=創建目標類快速修復
create.missing.target.method.fix=創建缺少的目標方法修復
php.extract.class=PHP 提取類
local=本地
project.files=專案檔案
include.path=include 路徑
inspection.message.parameter.name.changed.from.to=參數名稱由 ''{0}'' 更改為 ''{1}''
intention.family.name.rename.parameter.to.match.super=重命名參數以符合父級
intention.name.rename.to=重命名為 ''{0}''
inspection.message.name.parameter.may.be.different.depending.on.instance.class=在 ''{0}.{1}'' 中可能未解析命名實參
tooltip.update=更新 {0}
inspection.message.constant.ref.not.found=未找到常數 '#ref'
hint.text.can.not.find.target.class.for.modification=找不到要修改的目標類。
hint.text.target.class.not.writable=目標類 {0} 不可寫。
hint.text.target.class.does.not.belong.to.project.can.not.be.modified=目標類 {0} 不屬於該專案\\\\n\\\\
並且無法修改。
inspection.message.cannot.make.non.abstract.method.abstract.1=無法將非 abstract 方法 {0} 設為 abstract
inspection.message.cannot.override.final.method.1=無法覆寫 final 方法 {0}
inspection.message.return.type.declaration.must.be.compatible.with=返回類型宣告必須與 {0} 相容: {1}
inspection.message.cannot.make.method=無法將 {0} 方法設為 {1} {2}
inspection.message.declaration.should.be.compatible.with=宣告應該與 {0} 相容
inspection.message.declaration.should.be.compatible.with.super=宣告應與父級相容
command.name.make.method.static=將方法設為 static
show.constants=顯示常數
show.properties=顯示屬性
show.includes=顯示 include
show.private.members=顯示 private 成員
show.protected.members=顯示 protected 成員
undefined.interpreter=未定義的解釋器
column.name.annotation.name=註解名稱
inspection.message.exception.never.thrown.in.corresponding.try.block=相應的 ''try'' 塊中從未拋出異常 ''{0}''
dialog.title.edit.phpunit.test.pattern=編輯 PHPUnit 測試模式
notification.title.incorrect.profiler.snapshot.format=分析器快照格式不正確
notification.title.cannot.read.snapshot=無法讀取快照
label.lt.no.server=<no server>
executable.0.was.not.found.in.path.please.make.sure.it.s.there.possible.solutions=在 %PATH% 中找不到可執行檔案 ''{0}''。請確保已指定有效路徑。可能的解決方案:
if.you.ve.changed.the.path.recently.restart.the.ide=如果最近更改了 %PATH%，請重啟 IDE。
provide.the.full.path.to.executable=提供可執行檔案的完整路徑。
select.composer.phar.and.provide.the.full.path.to.it.or.select.download.composer.stable.phar.from.getcomposer.org=選擇 'composer.phar' 並提供其完整路徑，或者選擇“從 getcomposer.org 下載 composer-stable.phar”。
executable.0.was.not.found.in.path.please.make.sure.it.s.there.possible.solutions1=在 $PATH 中找不到可執行檔案 ''{0}''。請確保已指定有效路徑。可能的解決方案:
if.you.ve.changed.the.path.recently.restart.the.ide1=如果最近更改了 $PATH，請重啟 IDE。
select.composer.phar.and.provide.the.full.path.to.it.or.select.download.composer.stable.phar.from.getcomposer.org1=選擇 'composer.phar' 並提供其完整路徑，或者選擇“從 getcomposer.org 下載 composer-stable.phar”。
label.authentication.data.not.specified=未指定身份驗證資料
configured.is.incorrect=配置的 {0} 不正確
validation.script.was.created.but.it.cannot.be.executed.check.possible.reasons=驗證腳本已創建，但無法執行。可能的原因:
validated.web.server.is.not.running=驗證的 Web 伺服器未執行。
target.directory.for.validation.script.is.not.public=驗證腳本的目標目錄不是 public。
url.to.validation.script='驗證腳本的 URL'
follow.this.links.to.install.and.configure.0.or.1=點擊這些鏈接以安裝並配置 {0} 或 {1}。
if.you.have.already.configured.debug.extension.in.php.ini.file.check.possible.reasons.why.it.was.not.loaded=如果已在 php.ini 檔案中配置調試擴展，請檢查未載入該擴展的可能原因:
you.did.not.reload.web.server.after.changes.in.php.ini.file=在 php.ini 檔案中進行更改後，未重新載入 Web 伺服器。
you.are.configuring.debug.extension.in.the.wrong.php.ini.see.the.loaded.php.ini.files.below=您正在錯誤的 php.ini 中配置調試擴展(請參見下方已載入的 php.ini 檔案)。
there.are.errors.on.attempt.to.load.debug.extension.e.g.version.incompatibility=嘗試載入調試擴展時出錯，例如版本不相容。
intention.name.change.signature=更改 {0}({1}) 的簽名
dialog.title.enter.tag.name=輸入標記名稱
method1=方法
open.inspection.settings=打開 {0} 檢查設定
popup.content.enabled.disabled.extensions=已啟用{0}和已禁用{1}擴展
popup.content.configuration.remains.unchanged=當前配置與解釋器同步
unhandled.0=未處理的{0}
unhandled.exceptions=未處理的異常
label.docker.container=Docker 容器:
dialog.message.docker.account.not.specified=未指定 Docker 帳戶
dialog.message.docker.account.not.found=找不到 Docker 帳戶
dialog.message.could.not.find.network.interface=找不到 {0} 網絡接口
dialog.message.no.interface.addresses.for.network.interface=沒有 {0} 網絡接口的接口地址
validation.script.will.be.created.in.0.directory=驗證腳本將在 {0} 目錄中創建。
files.in.the.directory.should.be.accessible.by.0.request=目錄中的檔案應當可通過 {0} 請求進行存取。
caused.by.0=原因是:“{0}”
validation.script.will.be.created.in.0.directory.and.deployed.to.the.1.server=驗證腳本將在 {0} 目錄中創建並部署到 {1} 伺服器。
files.in.the.remote.directory.should.be.accessible.by.0.request=遠端目錄中的檔案應當可通過 {0} 請求進行存取。
follow.this.0.for.more.information.about.path.mappings=有關路徑映射的詳細資訊，請參閱{0}。
validation.script.will.be.created.locally.and.the.result.will.be.fetched.by.http.request=驗證腳本將在本地創建，其結果將通過 http 請求提取。
validation.script.will.be.created.locally.and.deployed.to.the.remote.server=驗證腳本將在本地創建並部署到遠端伺服器。
the.result.of.validation.will.be.fetched.by.http.request=驗證結果將通過 http 請求提取。
follow.this.0.for.more.information.about.deployment=有關部署的詳細資訊，請參閱此{0}。
link=鏈接
no.type=NO_TYPE
in=位於
action.configure.php.runtime.text=配置 PHP 執行時…
action.configure.project.directories.text=配置專案目錄
inspection.message.interpolated.string.dereferencing.available.in.php.only=從 PHP 8.0 起才允許插值字串解引用
inspection.message.magic.constant.dereferencing.available.in.php.only=從 PHP 8.0 起才允許魔術常數解引用
intention.family.name.add.name.identifiers.to.all.arguments.starting.from.current=從當前位置開始將名稱關鍵字添加到所有實參
intention.name.add.name.identifier=添加名稱關鍵字 ''{0}''
inspection.message.argument.without.name.identifier=無名稱關鍵字的實參
tooltip.wsl2.mappings=WSL2 映射
name=名稱
file=檔案
tooltip.from=來自{0}:
tooltip.from.volumes=來自{0}卷:
intention.family.name.sort.arguments=對實參排序
open.tool.settings=打開 {0} 設定
init.cache=初始化快取
or.disable.inspection=或
inspection.message.type.can.be.reduced.to=類型範圍可以限縮為 ''{0}''
an.alias.was.defined.for.method.0.which.exists.in.1=已為 {1} 中的方法 {0}() 定義別名
intention.family.name.append.absolute.trait=追加 ''{0}::''
intention.family.name.remove.argument.name=移除實參名稱
intention.name.remove.argument.names.from.all.arguments.up.to.current=從截止到當前位置的所有實參中移除實參名稱
frameworl.composer.show.quick.actions=顯示具有快速操作的 composer.json 頂部面板
framework.composer.notify.about.missing.vendor=缺少 'vendor' 目錄時通知
cannot.make.interface.method.non.static=無法將接口方法設為非 static
cannot.make.interface.method.static=無法將接口方法設為 static
access.must.be.public=存取必須為 public
inspection.message.method.reference.resolves.to.method.with.containing.class=''Use'' 規則解析為包含類 ''{0}'' 中的方法
intention.name.move.trait.use.rule.to.use.list=將特徵 ''use'' 規則移動到 ''{0}'' ''use'' 列表
intention.family.name.move.trait.use.rule.to.resolved.class.use.list=將特徵 'use' 規則移動到解析的類 'use' 列表
required.trait.0.wasn.t.added.to.1=所需特徵 ''{0}'' 未添加到 ''{1}''
intention.family.name.add.trait.to.use.list=將特徵添加到 use 列表
intention.name.add.trait.to.use.list=將特徵 ''{0}'' 添加到 use 列表
intention.family.name.add.break.as.last.statement=將 'break' 作為最後一條語句添加
inspection.message.class.does.not.have.attribute=類 ''{0}'' 未使用 ''Attribute'' 註解
intention.family.name.add.attribute.attribute=使用 'Attribute' 註解
constant.expression.contains.invalid.operations=常數表達式包含無效運算
attribute.must.be.first.child.of.parent.element=特性必須是父元素的第一個子項
intention.family.name.move.attribute.to.start.element=將特性移動到元素開頭
quickfix.remove.match.arm=移除 'match' arm
quickfix.remove.duplicate.condition=移除重複條件
quickfix.remove.unused.condition=移除未使用的條件
inspection.duplicate.match.condition.message=重複條件
inspection.message.attribute.can.t.be.applied.to.because.it.doest.contains=特性不能應用於 {0}，因為它不包含 ''{1}'' 標誌
inspection.message.attribute.is.not.repeatable=特性不可重複，因為它不包含 'Attribute::IS_REPEATABLE' 標誌
class2=類
class.constant1=類常數
property=屬性
parameter1=參數
inspection.message.comment.will.be.parsed.as.attribute.starting.with.php=從 PHP 8.0 起註釋被解析為特性
intention.family.name.insert.space.after=在 '#' 後面插入一個空格
inspection.message.condition.is.never.matched=條件從未符合
inspection.php.arithmetic.type.check=帶有不支持操作數的算術運算
introduce.variable.fix=引入變數
hint.text.use.statement.choice.s.removed={0} ''use'' 語句{1, choice, 0#|1#}已移除
hint.text.use.statements.checked.nothing.was.removed=已檢查 {0} ''use'' 語句，未移除任何內容
no.name=無名稱
debugger.method=方法
inspection.message.named.argument.usage=命名實參用法
percentage.lines={0}% 行
column.name.parameter=參數
column.name.file.directory=檔案/目錄
unknown=未知
intention.family.name.replace.with.get.class.call=取代為 'get_class()' 調用
intention.family.name.replace.with.class.name.literal=取代為 '::class'
inspection.message.get.class.call.can.be.replaced.with.class.name.literal='get_class()' 調用可以取代為 '::class'
intention.family.name.remove.parenthesis=移除圓括號
inspection.message.redundant.parenthesis=冗餘圓括號
intention.family.name.simplify.expression=簡化表達式
intention.family.name.replace.match.with.ternary=取代為三元表達式
attribute.can.be.added.to.overridden.method=可以將特性添加到覆寫方法
attribute.can.be.added.to.overridden.parameter=可以將特性添加到覆寫參數
intention.family.name.add.attribute.to.overridden.method=將特性添加到覆寫方法
intention.family.name.add.attribute.to.overridden.method.of.abstract.method=將特性添加到抽象方法的覆寫方法
intention.family.name.add.attribute.to.overridden.parameter=將特性添加到覆寫參數
inspection.message.match.can.be.replaced.with.ternary='match' 表達式可以取代為三元表達式
intention.family.name.replace.with.traditional.property.declaration=取代為傳統屬性宣告
cannot.declare.promoted.property.outside.a.constructor=無法在構造函數外部宣告提升的屬性
only.visibility.modifiers.can.be.applied.to.promoted.property=只能將可見性修飾符套用到提升的屬性
intention.family.name.replace.with.public=取代為 'public'
cannot.declare.variadic.promoted.property=無法宣告可變提升屬性
cannot.declare.promoted.property.in.an.abstract.constructor=無法在 abstract 構造函數中宣告提升的屬性
inspection.message.promoted.field.usage=提升的屬性用法
inspection.message.redundant.assignment=冗餘的提升屬性賦值
remove.assignment=移除賦值
inspection.message.switch.can.be.replaced.with.match='switch' 語句無法轉換為 'match' 表達式
intention.family.name.replace.switch.with.match.expression=將 'switch' 取代為 'match' 表達式
intention.family.name.split.into.multiple.catch.statements=拆分為多個 'catch' 語句
exception.class=異常類
variable1=變數
identifier=關鍵字
field.name=欄位名稱
object.property=物件屬性
class.reference=類引用
array.index=陣列索引
line.separator=行分隔符
initializer=初始值設定項
label1=標籤
expression1=表達式
type=類型
static.value=static 值
property.or.function=屬性或函數
default.value=預設值
extends=擴展
interface.name=接口名稱
extends.or.implements=擴展或實作
class.name=類名
modifier=修飾符
return.type=返回類型
inspection.message.duplicates.catch.statement=重複 ''{0}'' 語句
intention.name.merge.with=與 ''{0}'' 合併
intention.family.name.merge.with.duplicated.catch.statement=與重複的 'catch' 語句合併
intention.name.merge.with.match.arm=與 ''{0}'' arm 合併
intention.family.name.merge.with.duplicated.match.arm=與重複的 'match' arm 合併
intention.family.name.add.default.match.arm=添加 'default' 'match' arm
intention.family.name.add.attribute=添加 ''#[{0}]''
inspection.message.exitpoint.attribute.can.be.added=可以添加 #[NoReturn] 特性
intention.family.name.convert.to.promoted.field=轉換為提升的屬性
intention.family.name.convert.to.promoted.field.remove.doc.comment=轉換為提升的屬性並移除屬性 PHPDoc 註釋
inspection.message.field.assignment.can.be.converted.to.promoted.field=可以提升屬性
cannot.use.unpacking.in.attribute.argument.list=無法在特性實參列表中使用解包
spread.operator.on.named.arguments.is.forbidden=禁止對命名實參使用展開運算符
inspection.message.should.be.one=值應為以下選項之一: {0}
0.by.remote.interpreter=通過遠端解釋器{0}
0.local={0}本地
inspection.message.double.quotes.are.unnecessary=雙引號不必要
inspection.php.unnecessary.double.quotes.display.name=不必要的雙引號
inspection.php.unnecessary.leading.backslash.in.use.statement='use' 語句中有不必要的前導 '\\\\'
replace.unnecessary.double.quotes=取代不必要的雙引號
quality.tool.can.not.create.temporary.file=PhpStorm 無法創建臨時檔案
dialog.message.cannot.create.file.because.project.already.disposed=由於專案已處置，無法創建檔案
dead.code.commented.out=註釋掉
dead.code.deleted=已刪除
intention.family.name.add.arrayshape.attribute=添加 '#[ArrayShape]' 特性
inspection.message.arrayshape.can.be.added=可以添加 '#[ArrayShape]'
inspection.option.label.php8.severity=PHP 8 嚴重性:
inspection.message.pure.can.be.added=可以添加 ''{0}''
intention.name.add.to.parameter=將 ''\\\\\\\\&'' 添加到參數 ''{0}''
intention.family.name.add.to.parameter=將 '\\\\\\\\&' 添加到參數
inspection.message.array.write.access.unused=未使用陣列寫入存取
intention.family.name.remove.pure=移除 '#[Pure]'
inspection.message.function.may.produce.side.effects=函數可能會產生副作用
inspection.message.method.may.produce.side.effects=方法可能會產生副作用
inspection.message.immutable.property.write.scope.does.not.allow.write.access.here=無效的不可變屬性寫入: 作用域 ''{0}'' 不允許在此處進行寫入存取
php.console=PHP 控制台
inspection.message.illegal.array.offset.access=嘗試存取類型為 ''{0}'' 的值的陣列偏移
attributes.are.inapplicable.for.constants=特性不適用於常數
intention.family.name.replace.with.define.call=取代為 'define()' 調用
inspection.message.leading.slash.in.constant.fqn.will.not.be.trimmed.by.php=PHP 不會修剪常數 FQN 中的前導斜杠
intention.family.name.remove.leading=移除前導 '\\\\'
intention.family.name.replace.with.const.syntax=取代為 'const' 語法
inspection.message.can.be.replaced.with.const.syntax=可以取代為 'const' 語法
intention.family.name.force.fqcn.for.references.in.phpdoc=對 PHPDoc 中的引用強制 FQCN
constants.may.only.evaluate.to.scalar.values.arrays.or.resources=常數只能計算為標量值、陣列或資源
intention.family.name.merge.with.following.attribute.list=將特性列表與以下內容合併
intention.family.name.extract.attribute.into.separate.list=將特性提取到單獨的列表
intention.family.name.flip.attributes.lists=翻轉特性列表
inspection.message.too.many.messages.per.line=每行的訊息過多
inspection.message.too.many.messages.per.file.only.first.errors.warnings.are.shown=每個檔案中的訊息過多。僅顯示前 {0} 條。
can.not.correctly.run.the.tool.with.parameters=無法使用參數正確執行該工具:
possible.tool.process.hangup.after.0.sec={0} 秒後可能工具過程掛起。
inspection.message.write.access.to.variable.that.still.references.array.value=對仍引用 'foreach' 中先前所用陣列值的變數的寫入權限
if.with.common.parts=具有通用部分的 'if'
switch.with.common.parts=包含通用部分的 'switch'
intention.family.name.insert.unset.before=在前面插入 ''unset(\${0});''
intention.family.name.collapse.if.statement=摺疊 ''{0}'' 語句
intention.family.name.extract.common.parts.with.removing.branch=提取通用部分，並移除分支
intention.family.name.extract.common.parts=提取通用部分
inspection.message.if.statement.with.common.parts=包含通用部分的 ''{0}'' 語句
intention.name.replace.with=將 ''{0}'' 取代為 ''{1}''
inspection.message.property.only.written.but.never.read=屬性僅寫入，但從未讀取
inspection.message.property.only.read.but.never.written=屬性只讀取，但從未寫入
intention.family.name.delete.field=刪除屬性
intention.family.name.replace.with.class.constant=取代為類常數
invalid.condition.to.body.separator.should.be.used=條件與主體之間的分隔符無效: 應改用 '=>'
intention.family.name.invert.if.statement=反轉 'if' 語句
intention.family.name.unwrap.else=解開 'else'
inspection.message.unnecessary.else=不必要的 'else'
inspection.message.array.always.empty.at.this.point=陣列在此點始終為空
intention.family.name.can.be.merged.with.sequential=''if'' 可以與後續 ''{0}'' 合併
intention.family.name.merge.with.sequential=與後續 ''{0}'' 合併
inspection.message.behavior.unparenthesized.expressions.containing.both.will.change.in.php=同時包含 ''.'' 和 ''{0}'' 的無括號表達式可能會產生意外結果
intention.name.wrap.left.operand.in.parentheses=在圓括號中包裝左操作數
intention.name.wrap.right.operand.in.parentheses=在圓括號中包裝右操作數
parameter.type.is.not.convertible.from.null=參數類型不可從 'null' 轉換
inspection.message.value.parameter.always=參數值始終為 ''{0}''
intention.family.inline.value.for.parameter=內聯參數值
intention.name.inline.value=內聯值 ''{0}''
inspection.message.can.be.replaced.with.version=表達式可以取代為 '??' 版本
inspection.message.if.can.be.replaced.with.version='if' 可以取代為 '??' 版本
intention.family.name.replace.with.version=取代為 '??' 版本
intention.family.name.replace.with.ternary.expression=取代為三元表達式
popup.title.multiple.write.scopes.found=找到多個寫入範圍
closest.scope=最近範圍中的變數
all.values=所有變數
checkbox.rename.only.nearest.scope=僅重命名最近範圍中的變數
intention.family.name.make.method.void=將方法設為 'void'
inspection.message.return.value.method.never.used=方法的返回值從未使用
inspection.message.unnecessary.leading.slash=不必要的前導 '\\\\'
inspection.message.cast.redundant=類型轉換冗餘
inspection.message.unnecessary.curly.braces=不必要的大括號
intention.family.name.unwrap.curly.braces=解開大括號
command.name.disable.synchronisation.with.composer=禁用與 composer.json 同步
navigate.to.composer.json=導航到 composer.json
notification.content.language.level.synchronisation.with.composer.was.disabled=已禁用與 composer.json 的語言級同步
inspection.message.can.be.replaced.with.direct.parameter.access='func_get_arg' 可以取代為直接參數存取
intention.family.name.replace.with.parameter.access=取代為參數存取
intention.family.name.unwrap.function.call=解開函數調用
inspection.message.with.single.string.argument=帶單個字串實參的 ''{0}''
inspection.message.for.loop.can.be.replaced.with.str.repeat='for' 迴圈可以取代為 'str_repeat'
intention.family.name.replace.with.str.repeat.call=取代為 'str_repeat()' 調用
inspection.message.for.loop.can.be.replaced.with.implode='foreach' 迴圈可以取代為 'implode()'
intention.family.name.replace.with.implode.call=取代為 'implode()' 調用
intention.family.name.unwrap.cast=解開轉換
inspection.message.unnecessary.cast.to.string=不必要地轉換為 ''{0}''
intention.family.name.merge.with.assignment=與賦值合併
inspection.message.concatenation.can.be.merged.with.assignment.empty.string.literal=串聯可以與空字串文字賦值合併
inspection.message.operands.have.incompatible.types=操作數具有不相容的類型
short.arrow.function.cannot.return.void=箭頭函數不能有 'void' 返回類型
delete.void.return.type=刪除 'void' 返回類型
array.callback.must.have.exactly.two.elements=陣列回調必須正好有兩個元素
intention.family.name.split.into.separate.case.statements=拆分為獨立的 'case' 語句
invalid.syntax.for.multiple.case.expressions=多個 'case' 表達式的語法無效
cannot.mix.keyed.and.unkeyed.array.entries.in.assignments=在賦值中不能混合鍵控和非鍵控陣列條目
cannot.use.empty.array.entries.in.keyed.array.assignment=在鍵控陣列賦值中不能使用空陣列條目
cannot.use.empty.list=無法使用空列表
unsupported.declare.0=不支持的宣告 ''{0}''
inspection.message.continue.targeting.switch.equivalent.to.break=針對 'switch' 的 'continue' 相當於 'break'
inspection.message.redundant.expression=冗餘表達式
strict.types.declaration.must.have.0.or.1.as.its.value='strict_types' 宣告的值必須為 0 或 1
private.methods.cannot.be.final=private 方法不能是 final，因為它們從不會被其他類覆寫
cannot.use.yield.from.inside.a.by.reference.generator=不能在引用傳遞生成器中使用 'yield from'
intention.family.name.replace.with.check=取代為 '!==' 檢查
dialog.title.select.methods.to.propagate.safe.delete=選擇要傳播安全刪除的方法
dialog.title.select.parameters.to.propagate.safe.delete=選擇要傳播安全刪除的參數
referenced.calls=引用的調用
cannot.mix.and.list=不能混合 [] 與 list()
intention.family.name.replace.with.array=取代為數組
intention.family.name.replace.with.list=取代為 'list'
inspection.message.can.be.replaced.with=可以取代為 ''{0}''
intention.family.name.remove.unused.postfix.operation=移除未使用的後綴運算
inspection.message.results.postfix.expression.unused=未使用後綴表達式的結果
intention.family.name.add.doc.tag.with.throws.tags=使用 @throws 標記添加 PHPDoc 註釋
replace.variable.assignment.with.named.argument=將變數賦值取代為命名實參
action.run.composer.install.text=執行 'composer install'
notification.content.vendor.directory.not.found=未找到 'vendor' 目錄
intention.family.name.move.from.to.composer.json.section=將 ''{0}'' 從 ''{1}'' 移至 ''{2}'' composer.json 部分
intention.family.name.flip=翻轉 '?:'
inspection.message.can.be.removed=可以移除 ''{0}''
intention.family.name.remove.unused.property=移除未使用的屬性
intention.family.name.simplify.ternary.expression=簡化 '?:'
inspection.message.should.probably.not.be.passed.as.parameter=''{0}'' 可能不應作為參數 ''{1}'' 傳遞
inspection.message.should.probably.not.be.assigned=''{0}'' 可能不應分配給 ''{1}''
extract.method.selector.title=要提取的程式碼
intention.family.name.replace.with.operator=取代為 '?->' 運算符
inspection.message.can.be.replaced.with.operator=可以取代為 '?->' 運算符
add.throw.before.exception=在表達式前面添加 'throw'
intention.family.name.replace.with.dirname.call=取代為 'dirname()' 調用
inspection.php.redundant.method.override=冗餘方法覆寫
inspection.php.loop.can.be.replaced.with.implode=迴圈可以取代為 'implode()'
inspection.message.redundant.method.override=方法覆寫冗餘
delete.redundant.method.override=移除方法
intention.family.name.replace.if.with.version=將 'if' 取代為 '??' 版本
anonymous.class=匿名類
anonymous.0=匿名{0}
lambda=Lambda
checkbox.anonymous.classes=匿名類
checkbox.lambdas=Lambda
inspection.message.trait.usage=不允許特徵用法
inspection.message.will.be.covered.by=非必要條件，因為它由 ''{0}'' 檢查
inspection.message.can.be.replaced.with.fail=可以取代為 ''{0}''
intention.name.replace.coalesce.expression.with.operand=將合併表達式取代為操作數
intention.name.replace.coalesce.expression.with=將合併表達式取代為 ''{0}''
label.align.named.arguments=對齊命名實參
delete.catch.statement=刪除 'catch' 語句
inspection.message.exception.immediately.rethrown=立即重新拋出異常
inspection.message.dangerous.array.initialization=危險的陣列初始化
replace.with.array=取代為直接賦值 '$array = array($value)'
intention.family.name.replace.with.comparison=取代為比較
quickfix.undefined.function.add.function=添加函數
PhpLanguageLevel.8.1.0.presentable.name=8.1
PhpLanguageLevel.8.1.0.short.description=枚舉、'never' 返回類型、交叉類型、'readonly' 屬性
PhpLanguageFeature.enum.classes=從 PHP 8.1 起才允許使用枚舉
annotation.new.expression.enum=無法實例化枚舉 ''{0}''
enum.may.not.include.0=枚舉不得包含 ''{0}''
enum.may.not.include.extend=枚舉不得擴展其他類
enums.may.not.include.properties=枚舉不得包含屬性
enums.may.not.be.cloned=不得克隆枚舉
intention.family.name.make.containing.class.enum=將包含類設為枚舉
enum.properties.are.immutable=枚舉屬性不可變
enum.backing.type.must.be.int.or.string=枚舉支援類型必須為 'int' 或 'string'
enum.case.type.0.does.not.match.enum.backing.type.1=枚舉 case 類型 ''{0}'' 與枚舉支援類型 ''{1}'' 不符合
all.cases.of.backed.enum.must.have.a.value=備用枚舉的所有 case 必須包含值
case.of.non.backed.enum.must.not.have.a.value=非備用枚舉的 case 不得包含值
intention.family.name.delete.initializer=刪除初始值設定項
intention.family.name.add.to.containing.enum=將 '' : {0}'' 添加到包含枚舉
intention.family.name.remove.backed.type.from.containing.enum=從包含枚舉中移除備用類型
enum.case.should.be.located.only.inside.enum.classes=枚舉 case 只應位於枚舉類內部
enum.case.value.must.be.constant=枚舉 case 值必須為常數
enum.backing.type.must.be.int.or.string.0.given=在給出 ''{0}'' 的情況下，枚舉支援類型必須為 ''int'' 或 ''string''
code.style.option.before.colon.in.enum.backed.type=在備用枚舉中類型宣告旁邊的冒號前面
code.style.option.after.colon.in.enum.backed.type=在備用枚舉中類型宣告旁邊的冒號後面
enum.case=枚舉 case
enums.may.not.implement.the.serializable.interface=枚舉可能不會實作 'Serializable' 接口
cannot.redeclare.methods.from.enum.implicit.interfaces=無法從枚舉隱式接口重新宣告方法
cannot.implement.interface.0=無法實作接口 ''{0}''
cannot.implement.interface.0.directly=無法直接實作接口 ''{0}''
non.enum.class.cannot.implement.interface=非枚舉類無法實作接口 ''{0}''
non.backed.enum.cannot.implement.interface.backedenum=非備用枚舉無法實作接口 'BackedEnum'
intention.family.name.count.comments.as.content=將註釋計為內容
inspection.php.class.constant.accessed.via.child.class=通過子類引用的類常數
inspection.message.constant.from.base.class.referenced.via.child.class=通過子類引用的基類 ''{0}'' 中的常數
intention.family.name.replace.with.class.reference.with.base.class=取代為對基類的類引用
intention.replace.with.method.call=取代為對現有方法的調用
inspection.php.uncovered.enum.cases=某些 enum case 未被覆蓋
inspection.message.uncovered.enum.cases='match' 表達式具有未被覆蓋的 enum case
intention.family.name.add.remaining.enum.cases=添加剩餘 enum case
add.enum.declaration.quick.fix.text=添加枚舉 case
intention.family.name.split.into.two.separate.match.arms=將條件提取到單獨的 'match' arm
multiple.enum.identifiers.should.be.stated.in.different.cases=多個枚舉關鍵字應在不同的 case 中宣告
replace.with.array.short.syntax=取代為直接賦值 '$array = [$value]'
intention.family.name.split.into.multiple.enum.cases=拆分為多個枚舉 case
inspection.message.uncovered.enum.cases.switch='switch' 語句有未被覆蓋的枚舉 case
inspection.php.unused.switch.case.inspection.display.name=未使用的 'switch' 分支
inspection.message.branch.is.unused=從不執行 'switch' 分支
inspection.php.enum.case.with.value.not.found=枚舉中找不到包含指定值的 case
inspection.message.not.valid.backing.value.for.enum={0} 不是枚舉的有效支援值
intention.name.add.enum.case.with.value=添加具有 ''{0}'' 值的枚舉 case
inspection.php.empty.index.operator.not.supported.for.strings.display.name=字串不支持的空索引運算符
inspection.php.empty.index.operator.not.supported.for.strings=字串不支持 '[]' 運算符
intention.family.name.replace.with.concatenation=取代為串聯
intention.family.name.remove.empty.index.operator=移除 '[]' 運算符
refactoring.move.class.action.name = 移動類…
refactoring.move.namespace.action.name=移動命名空間…
refactoring.move.constant.action.name=移動常數…
refactoring.move.function.action.name=移動函數…
refactoring.inline.function.cannot.inline.magic.method=無法內聯魔術方法
refactoring.inline.function.cannot.inline.constructor=無法內聯構造函數
inspection.missing.doc.comment.options.panel.ignore.private.members=忽略 private 成員
code.style.option.place.braces.for.constructor.as.is=保留原樣
code.style.option.place.braces.for.constructor.always=始終
code.style.option.place.braces.for.constructor.never=從不
settings.smart.keys.auto.insert.semicolon=在函數調用內部鍵入時自動插入分號 
inspection.php.foreach.over.single.element=對只有一個元素的陣列文字執行 Foreach
intention.family.name.unwrap.foreach=解開 'foreach'
inspection.message.foreach.over.array.literal.with.single.element=對只有一個元素的陣列文字執行 ‘foreach’
inspection.php.condition.can.be.replaced.with.min.max.call=條件可以取代為 'min()'/'max()' 調用
inspection.message.can.be.replaced.with.min.max.call=可以取代為 ''{0}'' 調用
intention.family.name.replace.with.min.max.call=取代為 'min()'/'max()' 調用
intention.name.replace.with.min.max.call=取代為 ''{0}'' 調用
quickfix.navigate.to.duplicate.case.value=導航到重複的 case 值
duplicate.value.in.enum.for.cases.0.and.1=case ''{0}'' 和 ''{1}'' 的枚舉中的重複值
inspection.php.idempotent.operation=二進制表達式中的冪等運算
inspection.message.expression.not.changed.after.applying=套用 ''{0}'' 後，表達式不會改變
inspection.php.array.push.with.single.element=只有一個元素的 'array_push()'
inspection.message.array.push.with.single.element=只有一個元素的 'array_push'
unwrap.switch=解開 switch…
inspection.switch.with.single.case=只有一個 'case' 的 'switch'
inspection.message.switch.has.only.default.case=switch 只有 'default' case
inspection.message.switch.has.only.single.case=switch 只有一個 case
intention.family.name.replace.with.if=取代為 'if'
PhpLanguageFeature.return.never=自 PHP 8.1 起才允許使用返回類型 'never'
classes.named.never.is.forbidden.in.php.8.1=PHP 8.1 中禁止名為 'never' 的類
inspection.php.never.typed.function.returning.value='never' 類型的函數返回一個值
never.can.only.be.used.as.return.type='never' 只能用作返回類型
inspection.message.never.returning.function.must.not.return='never' 返回函數不得返回
delete.case=刪除 'case'
inspection.php.internal.array.index.reset.is.unnecessary=無需陣列內部指針重置
inspection.php.enforce.doc.comment.inspection.display.name=強制執行 PHPDoc 註釋
remove.unnecessary.reset=移除不必要的 'reset'
refactoring.inline.function.cannot.inline.overridden.method=無法內聯被覆寫的方法
intention.family.name.replace.with.array.assignment=取代為數組賦值
inspection.php.array.search.can.be.replaced.with.in.array='array_search()' 可取代為 'in_array()' 調用
intention.family.name.replace.with.in.array.call=取代為 'in_array()' 調用
inspection.message.can.be.replaced.with.in.array.call=可以取代為 ''{0}'' 調用
inspection.php.preg.match.without.regular.expression='preg_match' 可取代為 'str_contains'
inspection.message.can.be.replaced.with.str.function=可以取代為 ''{0}''
intention.family.name.replace.with.str.function.call=取代為 ''{0}'' 調用
inspection.php.group.regexp=正則表達式
PhpLanguageFeature.final.class.constants=自 PHP 8.1 起只允許使用 'final' 類常數
intention.family.name.replace.in.array.with.disjunction=將 'in_array()' 取代為 '||'
intention.message.replace.in.array.with.disjunction=將 ''in_array()'' 取代為 ''{0}''
intersection.types.and.the.nullable.type.notation.cannot.be.mixed=交叉類型和可 null 類型表示法不能混用
cannot.mix.amp.and.pipe.in.type.declaration=類型宣告中不能混用 '\\\\\\\\&' 和 '|'
PhpLanguageFeature.intersection.types=從 PHP 8.1 起才允許交叉類型
intention.family.name.evaluate.cast=取代為 ''{0}''
intention.name.evaluate.cast=評估轉換
inspection.message.cast.evaluable=轉換可取代為 ''{0}''
inspection.php.cast.is.evaluable=對標量值進行類型轉換
cannot.use.readonly.as.identifier=無法將 'readonly' 用作關鍵字。自 PHP 8.1 起作為預留關鍵字
PhpLanguageFeature.readonly.properties=從 PHP 8.1 起才允許使用 'readonly' 屬性
PhpLanguageFeature.new.in.init=從 PHP 8.1 起才允許在初始值設定項中使用 'new'
globals.can.only.be.modified.using.the.globals.name.value.syntax='$GLOBALS' 只能使用 '$GLOBALS[$name] = $value' 語法進行修改
inspection.php.match.can.be.replaced.with.switch.statement='match' 可取代為 'switch' 語句
inspection.message.match.can.be.replaced.with.switch='match' 表達式可轉換為 'switch' 語句。
intention.family.name.replace.match.with.switch.statement=將 'match' 取代為 'switch' 語句
intention.family.name.replace.match.with.switch.statement.changing.semantics=將 'match' 取代為 'switch' 語句(可能會改變比較語意)
PhpLanguageFeature.explicit.octal.literal=自 PHP 8.1 起只允許顯式八進制文字
inspection.php.acessing.static.trait.members=正在存取 static 特徵成員
inspection.message.calling.static.trait.member=不推薦直接調用 static 特徵成員。它只能在使用特徵的類上訪問。
intention.family.name.replace.with.self.access=取代為 'self::' 存取
inspection.message.returning.by.reference.from.void.function.deprecated=不推薦從 void 函數通過引用返回
intention.family.name.collapse.statement.into.parameter.default.value=將語句摺疊到參數的預設值中
inspection.message.statement.can.be.collapsed.into.parameter.default.value=語句可以摺疊到參數的預設值中
label.successors=後繼
label.predecessors=前驅
inspection.php.covered.element.in.class=類中的元素已覆蓋
inspection.message.element.already.covered.by=''{0}'' 已被 ''{1}'' 覆蓋
intention.family.name.delete.covered.element=刪除已覆蓋的元素
inspection.php.ranges.in.class.can.re.merged=類中的範圍可以合併
inspection.message.can.be.merged.with=可以與 ''{0}'' 合併
intention.family.name.merge.with.adjustment.range=與調整後的範圍合併
intention.name.prepend.default.case=預置 'default'
popup.title.select.target.code.block=選擇目標程式碼塊
popup.select.target.code.block.closure=箭頭函數體(轉換為閉包)
popup.select.target.code.block.containing.block=包含塊
refactoring.inline.function.cannot.find.function.declaration=找不到函數宣告
private.constant.cannot.be.final='private' 常數不能為 'final'，因為它對其他類不可見
cannot.override.final.constant=無法從 ''{1}'' 覆蓋 final 常數 ''{0}''
intention.family.name.replace.with.implicit.octal.notation=取代為隱式八進制表示法
inspection.message.match.can.be.replaced.with.switch.changing.semantics='match' 表達式可以轉換為 'switch' 語句。請注意，'switch' 語句依賴於鬆散比較，這可能會改變表達式語意。
php.intention.category=PHP
inspection.php.deprecated.stdlib.call=已棄用的標準庫調用
inspection.message.argument.with.type.deprecated.for.this.call=此調用不推薦使用類型為 ''{0}'' 的實參
inspection.message.call.without.arguments.deprecated=不帶實參的 ''{0}'' 調用已棄用
inspection.php.array.index.immediately.rewritten=陣列索引會被立即覆寫
intention.family.name.navigate.to.rewrite.expression=導航到覆寫表達式
inspection.message.array.index.immediately.rewritten.before.accessing=陣列索引在存取之前會被立即覆寫
inspection.php.implicit.octal.literal.can.be.replaced.with.explicit.one=隱式八進制文字可以取代為顯式文字
inspection.message.replace.implicit.octal.literal.with.explicit.one=隱式八進制文字可以取代為顯式文字
inspection.family.name.replace.implicit.octal.literal.with.explicit.one=將隱式八進制文字取代為顯式八進制文字
inspection.php.object.fields.are.only.written=局部物件僅用於寫入屬性
inspection.message.local.object.used.only.for.writing.properties=局部物件僅用於寫入屬性
inspection.php.redundant.array.call.in.foreach.iterated.value=對 'foreach' 中迭代的值的冗餘 'array_values' 調用
intention.family.name.replace.with.argument=取代為實參
inspection.message.array.values.call.redundant='array_values' 調用冗餘
readonly.property.must.have.type=唯讀屬性必須指定類型
inspection.php.unit.assert.always.execute.to.same.result='assertTrue()' 的實參類型不相容
inspection.message.assert.always.will.be.false=實參類型不相容，因為 'assertTrue()' 執行與 'true' 的嚴格比較
expected.property=屬性
inspection.array.to.string.conversion=陣列到字串的轉換
inspection.message.array.to.string.conversion=陣列到字串的轉換
inspection.php.invalid.string.offset.usage=字串偏移用法無效
inspection.message.cannot.use.string.offset.as.object=無法將字串偏移用作物件
inspection.message.cannot.use.assign.op.operators.with.string.offsets=無法將組合運算符賦值與字串偏移一起使用
inspection.message.cannot.unset.string.offsets=無法取消設定字串偏移
inspection.message.cannot.increment.decrement.string.offsets=無法遞增/遞減字串偏移
inspection.message.cannot.create.references.to.from.string.offsets=無法創建到/從字串偏移的引用
inspection.message.cannot.use.string.offset.as.array=無法將字串偏移用作陣列
intention.inline.method.family.name=內聯方法
inspection.message.cannot.assign.empty.string.to.string.offset=無法將空字串分配給字串偏移
inspection.message.only.first.byte.will.be.assigned.to.string.offset=只有第一個字節將被分配給字串偏移
static.property.cannot.be.readonly='static' 屬性不能為 'readonly'
inspection.message.second.write.to.readonly.property=無法修改 'readonly' 屬性
inspection.php.second.write.to.readonly.property=第二次寫入 'readonly' 屬性
inspection.php.unnecessary.spread.operator.for.function.call.argument=函數調用實參的展開運算符不必要
inspection.message.spread.operator.can.be.unwrapped=展開運算符可以解開
inspection.message.spread.operator.over.literal.unnecessary.for.arguments.resolved.to.variadic.parameter=對於解析為可變參數的實參，文字上的展開運算符不必要
intention.family.name.unwrap.spread.operator=解開展開運算符
inspection.message.write.access.to.readonly.property.outside.declaration.scope=無法寫入宣告範圍之外的 'readonly' 屬性
inspection.php.write.access.to.readonly.property.outside.declaration.scope=對宣告範圍之外的 'readonly' 屬性的寫入權限
build.control.flow.with.exit.points=使用出口點構建控制流(&E)
inspection.message.comment.can.be.replaced.with.named.argument=註釋可以取代為命名實參
intention.family.name.replace.with.named.argument=取代為命名實參
inspection.message.can.be.replaced.with.named.argument=可以取代為命名實參
PhpLanguageFeature.first.class.callable.syntax=僅在 PHP 8.1 之後的版本中才允許一級可調用語法
intention.family.name.replace.with.closure.fromCallable=取代為 'Closure::fromCallable(...)'
cannot.create.closure.for.new.expression=無法為 'new' 表達式創建 'Closure'
replace.with.arrow.function=取代為箭頭函數
replace.with.anonymous.function=取代為匿名函數
label.interpreter=解釋器: {0}
cannot.combine.nullsafe.operator.with.closure.creation=無法將 nullsafe 運算符與 'Closure' 創建組合
replace.with.coalesce.operator=取代為合併運算符
intention.family.name.initialize.property.in.constructor=初始化構造函數中的屬性
inspection.php.field.immediately.rewritten=屬性會被立即覆寫
inspection.message.field.immediately.rewritten.before.accessing=屬性在存取之前會被立即覆寫
inspection.redundant.intersection.type=冗餘的交叉點類型
inspection.redundant.intersection.type.fix=交叉點類型可以簡化為 ''{0}''
inspection.redundant.intersection.type.fix.name=簡化交叉點類型
anonymous.function=匿名函數
expected.expression.after.spread.operator=預期: 展開運算符後的表達式
action.com.jetbrains.php.internal.PhpCreateYoutrackIssueFromFileAction.text=在 WI (PhpStorm) 專案中根據檔案內容創建 YouTrack 問題
action.com.jetbrains.php.internal.PhpCreateYoutrackIssueFromSelectionAction.text=在 WI (PhpStorm) 專案中根據所選內容創建 YouTrack 問題
inspection.php.nested.min.max.call=嵌套的 'min/max' 調用
inspection.message.nested.call.can.be.unwrapped=嵌套的 ''{0}'' 調用可以解開
intention.family.name.unwrap.call=解開調用
type.0.cannot.be.part.of.an.intersection.type=類型 ''{0}'' 不能是交叉點類型的一部分
inspection.closure.can.be.converted.to.first.class.callable='Closure::fromCallable()' 可以轉換為一級可調用語法
inspection.php.closure.can.be.converted.to.first.class.callable.inspection.display.name='Closure::fromCallable()' 可以轉換為一級可調用語法
replace.with.first.class.callable.family.name=取代為一級可調用語法
inspection.php.duplicate.character.in.str.function.call=函數調用中的重複字符
inspection.message.duplicate.character=重複字符
quickfix.remove.condition.from.default.arm=從 'default' arm 中移除非 'default' 條件
annotator.only.default.condition.allowed='default' arm 中僅允許單個 'default' 條件
inspection.php.autovivification.on.false.values='false' 到陣列的自動轉換已棄用
inspection.message.write.access.to.readonly.property.outside.declaration.scope.ret.by.ref='readonly' 屬性通過引用返回，可能會泄漏到宣告範圍之外
inspection.message.array.key.unused=陣列密鑰未使用
refactoring.inline.variable.unary.operation=無法內聯到遞減或遞增操作
inspection.message.variable.already.equal.to.assigned.value=變數已等於賦值
inspection.php.modulo.operation.with.one=以 '1' 為操作數的取模運算
intention.family.name.replace.with.zero=取代為 ''{0}''
inspection.message.expression.always.choice=表達式始終為 ''{0}''
intention.family.name.replace.with.compile.time.result=取代為編譯時結果
inspection.php.deprecated.serializable.interface.usage.inspection.display.name='Serializable' 接口用法已棄用
class.implements.the.serializable.interface.which.is.deprecated=不推薦在不使用 '__serialize()'/'__unserialize()' 方法的情況下實作 'Serializable' 接口
add.serialize.magic.methods=添加 {0} 方法
add.serialize.magic.method=添加 {0} 方法
refactoring.move.classes.dnd.name=移動類
refactoring.move.classes.dnd.title=將所選的{0,choice,0#類|1#命名空間|2#類和命名空間}移動到命名空間:
group.advanced.settings.php=PHP
advanced.setting.php.max.chain.resolve.depth=解析成員引用的最大深度
function.has.parameter.with.incompatible.default.value.type=函數有一個其預設值與其宣告的類型不相容的參數
inspection.php.unit.deprecated.call.in.phpunit.10=方法在 PHPUnit 10 中已棄用
intention.family.name.replace.with.suggested.call.in.phpunit=取代為 PHPUnit 10 中建議的調用
inspection.message.function.deprecated.will.be.removed.in.phpunit=方法已棄用並已在 PHPUnit 10 中移除
code.style.option.force.empty.functions.braces.in.one.line=將空函數/方法的大括號放在一行
inspection.php.autovivification.on.false.values.possible=可能會導致將 'false' 轉換為數組，這一轉換已棄用
php.change.signature.conflict.with.local.var=參數 ''{0}'' 與函數 ''{1}'' 內的局部變數衝突
php.change.signature.conflict.with.local.var.method=參數 ''{0}'' 與來自 ''{2}'' 的方法 ''{1}'' 內的局部變數衝突
refactoring.move.classes.dnd.files.with.the.same.name.error=單個目標中不允許有多個同名檔案。
dialog.message.execution.quality.tools.in.untrusted.project.prohibited=禁止在不受信任的專案中執行品質工具
untrusted.composer.dialog.text=正在安裝或更新依賴項，或者執行 Composer 命令可能會執行潛在的惡意程式碼。\\\\n\\\\
\\\\n\\\\
如果不信任此源，請保持在安全模式下。
inspection.undefined.field.notify.dynamic.read=通知對動態屬性的讀取權限
inspection.php.too.long.member.reference.chain=成員引用鏈過長，無法分析
php.test.framework.untrusted.reload=在安全模式下禁止刷新測試框架的版本
inspection.message.instanceof.checks.in.catch.can.be.replaced.with.specific.catches='catch' 塊中的 'instanceof' 檢查可以取代為特定的 catch
inspection.php.instanceof.checks.in.catch.can.be.replaced.with.specific.catches='catch' 塊中的 'instanceof' 檢查可以取代為特定的 catch
intention.family.name.replace.instanceof.checks.in.catch.with.specific.catches=將 'catch' 塊中的 'instanceof' 檢查取代為特定的 catch
no.in.line.parameter.name.hints.will.be.shown.for.methods.matching.any.of.these.patterns=對於符合其中任一模式的方法，都不會顯示任何嵌入參數名稱提示。
patterns.are.matched.on.fully.qualified.name.parameter.count.and.parameter.names=模式會通過完全限定名稱、參數計數和參數名稱進行符合。
you.can.always.add.a.precise.exclusion.via.alt.enter.and.then.edit.it.to.broaden.as.needed=您始終可以通過 Alt-Enter 組合鍵添加精確排除，然後根據需要對其進行編輯以擴大範圍。
code.global.code.matches.function.with.two.parameters={0} 符合帶有兩個參數的函數。
code.info.code.matches.all.single.parameter.methods.where.the.parameter.name.ends.with.em.info.em={0} 符合參數名以 {1} 結尾的所有單參數方法。
code.key.value.code.matches.all.methods.with.parameters.em.key.em.and.em.value.em={0} 符合所有具有參數 {1} 和 {2} 的方法。
code.fully.qualified.classname.methodname.key.value.code.example.precise.match={0} 是一個精確排除的範例。
key=密鑰
value=值
info=資訊
inspection.php.if.can.be.replaced.with.match.expression='if' 可以取代為 'match' 表達式
intention.family.name.replace.if.with.match.expression=將 'if' 取代為 'match' 表達式
inspection.message.can.be.replaced.with.match.expression='if' 語句可以取代為 'match' 表達式
inspection.php.duplicate.operand.in.comparison=比較中的重複操作數
intention.family.name.remove.duplicate.operand=移除重複操作數
inspection.message.expression.have.duplicate.operand=表達式有重複的操作數 {0}
refactoring.inline.function.cannot.inline.first.class.callable.declaration=無法內聯第一類可調用宣告
php.replace.try.from.with.null.quick.fix.family.name=用 'null' 取代 'tryFrom()' 調用
replace.all.occurrences.without.side.effects=取代所有符合項，無副作用
inspection.php.class.constant.can.be.final=類常數可為 'final'
inspection.message.can.be.final=可為 'final'
intention.family.name.make.final=設為 'final'
inspection.php.array.append.using.count=使用 'count()' 作為索引將值追加到陣列
inspection.message.count.used.as.array.index.to.append.element='count' 用作陣列索引以追加元素
inspection.php.pointless.boolean.expression='if' 條件內的無意義布爾表達式
intention.name.simplify.to=簡化為 ''{0}''
inspection.message.pointless.boolean.expression=可以簡化布爾表達式
inspection.php.rand.arguments.in.revers.order=順序錯誤的 'rand' 函數實參
inspection.message.max.must.be.greater.than.or.equal.to.argument.min='max' 實參必須大於或等於 'min'
quickfix.change.field.type.to.match.super.0=將類型更改為 ''{0}'' 以匹配父項
quickfix.change.field.type.to.match.super.remove=移除類型宣告以符合父項
inspection.message.readonly.property.non.readonly=無法將 'readonly' 屬性重新宣告為非 'readonly'
inspection.message.non.readonly.property.readonly=無法將非 'readonly' 屬性重新宣告為 'readonly'
intention.family.name.remove.readonly.modifier=移除 'readonly' 修飾符
intention.family.name.add.readonly.modifier=添加 'readonly' 修飾符
inspection.php.unit.invalid.mocking.target=無效的模擬目標
inspection.message.methods.cannot.be.mocked=''{0}'' 方法無法模擬
final=final
enum=枚舉
inspection.message.classes.cannot.be.doubled=''{0}'' 類無法重複
inspection.message.cannot.stub.or.mock.using.method.list.that.contains.duplicates=不能使用包含重複項的方法列表進行存根或模擬
intention.family.name.navigate.to.duplicate.method.name=導航到重複的方法
inspection.php.property.can.be.readonly=屬性可為 'readonly'
inspection.message.property.can.be.readonly=屬性可為 'readonly'
text.plain=文本/純
enum.value.cannot.referer.to.enum.cases=枚舉值不能引用枚舉 case
inspection.php.internal.array.index.reset.is.unnecessary.navigate.to.function=導航到重置陣列內部指針的函數
inspection.php.pow.call.can.be.replace.with.pow.operator='pow()' 調用可取代為 '**' 運算符
replace.with.pow.operator=取代為 '**' 運算符
group.methods.by.type=按類型對方法分組
inspection.php.private.method.may.be.inaccessible.in.late.static.binding.call=Private method may be inaccessible during late static binding call
inspection.message.existing.overriding.private.method.may.be.inaccessible=Existing overriding private method may be inaccessible
inspection.message.existing.overriding.private.method.may.be.inaccessible.method=Overriding private method ''{0}'' may be inaccessible
intention.family.name.navigate.to.possibly.inaccessible.methods=Navigate to possibly inaccessible methods
overriding.private.methods=Overriding private methods
refactoring.inplace.extract.method.name=Inplace Extract Function/Method
PhpExtractMethodDialog.generate.php.doc.inplace=生成 PHPDoc
extract.method.link.label.more.options=更多選項"
`;

exports[`src messages/SvnBundle.properties 1`] = `
"subversion.executable.notification.title=無法使用 Subversion 命令行客戶端
subversion.executable.notification.description=Subversion 可執行檔案的路徑可能是錯誤的。
subversion.executable.too.old=Subversion 命令行客戶端版本過舊({0})。

subversion.roots.detection.errors.found.description=檢測 svn 工作副本時發現錯誤。
subversion.roots.detection.errors.found.action.text=修復

#Actions&Plugin info
action.Subversion.BrowseSVNRepository.text=瀏覽 Subversion 版本庫(_W)…
action.Subversion.BrowseSVNRepository.description=瀏覽 Subversion 版本庫
group.SubversionFilePopupGroup.text=Subversion(_S)
group.IgnoreChoicesGroup.text=忽略
group.RevertIgnoreChoicesGroup.text=從忽略列表中移除
action.Subversion.UndoIgnore.text=所選文件名
action.Subversion.UndoIgnore.description=從資料夾忽略列表中移除文件名/遮罩
action.Subversion.Ignore.ExactMatch.text=所選文件名
action.Subversion.Ignore.ExactMatch.description=將所有所選檔案的名稱添加到資料夾忽略列表
action.Subversion.Ignore.MatchExtension.description=將 {0} 遮罩添加到資料夾忽略列表
action.Subversion.SetProperty.text=設定屬性(_T)…
action.Subversion.SetProperty.description=在檔案或目錄中設定版本化屬性
action.Subversion.ShowProperties.text=編輯屬性(_P)
action.name.show.properties=顯示屬性
action.Subversion.PropertiesView.AddProperty.text=添加屬性
action.Subversion.PropertiesView.AddProperty.description=添加新屬性
action.Subversion.PropertiesView.EditProperty.text=編輯屬性
action.Subversion.PropertiesView.EditProperty.description=編輯選定屬性值
action.Subversion.PropertiesView.EditKeywords.text=編輯關鍵字
action.Subversion.PropertiesView.EditKeywords.description=管理 svn:keywords 屬性
action.Subversion.PropertiesView.DeleteProperty.text=刪除屬性
action.Subversion.PropertiesView.DeleteProperty.description=刪除選定屬性
action.Subversion.PropertiesView.FollowSelection.text=跟隨選擇
action.Subversion.PropertiesView.FollowSelection.description=跟隨選擇
action.Subversion.PropertiesView.Refresh.text=刷新
action.Subversion.PropertiesView.Refresh.description=重新載入屬性
action.Subversion.PropertiesView.Close.text=關閉
action.Subversion.PropertiesView.Close.description=關閉此工具視窗
toolwindow.stripe.SVN_Properties=SVN 屬性
column.name.property.name=名稱
column.name.property.value=值
error.can.not.set.property=無法設定屬性: {0}
dialog.title.svn.keywords=SVN 關鍵字
label.select.keywords.to.set=選擇要設定的關鍵字:
action.Subversion.Resolve.text=解決文本衝突(_S)…
action.Subversion.Resolve.description=解決檔案中的文本衝突
action.Subversion.MarkResolved.text=標記為已解決(_M)…
action.Subversion.MarkResolved.description=將文本和屬性衝突標記為已解決
action.Subversion.Clenaup.text=清理(_E)
action.Subversion.Clenaup.description=解鎖鎖定的目錄，並執行其餘所有未完成的操作
action.Subversion.Copy.text=分支或標記(_B)…
action.Subversion.Copy.description=將選定的檔案或目錄複製到新的版本庫位置
action.Subversion.Lock.text=鎖定(_L)…
action.Subversion.Lock.description=鎖定檔案
action.Subversion.Unlock.text=解鎖(_O)
action.Subversion.Unlock.description=解鎖檔案
action.name.refresh=刷新
action.Subversion.ImportToSVNRepository.text=匯入 Subversion(_M)…
action.Subversion.Share.text=共享目錄(_S)…
action.Subversion.ConfigureBranches.text=配置分支…
action.Subversion.CompareWithBranch.text=與分支比較…
action.Subversion.Relocate.text=重定位…
action.Subversion.Relocate.description=將工作副本重定位到其他 URL
action.Subversion.CleanupProject.text=清理專案
action.Subversion.CleanupProject.description=對專案中的所有工作副本目錄執行清理
action.Svn.Show.Working.Copies.text=顯示工作副本
action.Svn.Show.Working.Copies.description=顯示工作副本資訊：工作副本格式和 URL
action.Svn.RefreshWorkingCopies.text=刷新
action.Svn.RefreshWorkingCopies.description=刷新工作副本資訊
action.EditCommitMessage.text=編輯修訂註釋
action.EditCommitMessage.description=編輯修訂註釋。覆寫上一條訊息。
action.Subversion.ShareWholeProject.text=共享專案(Subversion)…

#New Remote Folder dialog
dialog.title.new.remote.folder=新建遠端資料夾
label.remote.folder.url=遠端資料夾 URL:
label.remote.folder.name=遠端資料夾名稱:
label.commit.message=提交訊息:
label.recent.messages=最近的訊息:
value.new.folder.name=NewFolder
button.copy=複製
action.new.remote.folder.text=新建遠端資料夾…

#Copy dialog
dialog.title.branch=創建分支或標記
label.copy.from=複製自
label.copy.to=複製到
label.copy.from.revision=修訂(&V):
label.branch.base.url=基 URL:
label.branch.name=名稱:
value.new.branch.name=new_branch
tooltip.use.project.location=使用專案位置
radio.copy.working.copy=工作副本(&W)
radio.copy.repository.location=版本庫位置(&R):
radio.copy.to.branch.or.tag=分支或標籤
radio.copy.to.any.location=任何位置
label.copy.comment=&註釋
label.copy.select.location.dialog.copy.as=複製為(&A):
notification.content.branches.load.error=分支載入錯誤: {0}
progress.title.checking.target.folder=正在檢查目標資料夾
dialog.message.repository.path.does.not.exist=版本庫路徑 ''{0}'' 不存在。要創建它嗎?
dialog.title.select.working.copy.location=選擇工作副本位置
label.select.location.to.copy.from=選擇要從中複製的位置:
dialog.message.branch.name.is.empty=分支名稱為空
dialog.message.invalid.branch.name=分支名稱無效
dialog.message.invalid.branch.url=分支 url 無效
dialog.message.no.branch.base.location.selected=未選擇分支基位置
dialog.message.invalid.revision=修訂無效
dialog.message.invalid.repository.location=版本庫位置無效
checkbox.switch.to.newly.created.branch.or.tag=將 {0} 切換到新建的分支或標記
error.can.not.find.url.for.file=找不到檔案的 url: {0}
error.can.not.find.working.copy.for.file=找不到檔案的工作副本: {0}
progress.title.svn.branches.preloader=Subversion 分支預載入程序

#Relocate dialog
dialog.title.relocate.working.copy=重新定位工作副本
label.from.url=源 URL:
label.to.url=目標 URL:
dialog.message.error.relocating.working.copy=重定位工作副本時出錯: {0}
progress.title.relocating.working.copy=正在重定位工作副本

#Lock dialog
dialog.title.lock.files=鎖定檔案
dialog.title.lock.file=鎖定檔案
label.lock.comment=鎖定註釋(&L):
label.locl.steal.existing=竊取現有鎖(&S):

label.ssh.key.file=密鑰檔案(&F):
label.ssh.passphrase=密碼短語(&R):

label.ssl.certificate.path=證書路徑:
label.ssl.certificate.password=證書密碼短語:
checkbox.ssl.keep.for.current.session=儲存憑證(&S)

progress.text.create.remote.folder=創建遠端資料夾
dialog.title.error=錯誤

#Repository Browser
progress.text.deleting=正在刪除 {0}
progress.title.browser.delete=刪除
progress.text.browser.creating=正在創建 {0}
progress.text.browser.moving=正在移動 {0}
progress.text.browser.copying=正在拷貝{0}
progress.text.browser.remote.destination=到 {0}
progress.title.browser.move=移動
progress.title.browser.copy=複製
dialog.message.could.not.parse.url=無法解析 url
dialog.title.changes.in.url={0} 中的變更
action.Subversion.RepositoryBrowser.Checkout.text=簽出(_C)…
dialog.title.svn.repository.browser=SVN 版本庫瀏覽器
action.Subversion.RepositoryBrowser.CompareWith.text=比較物件…
dialog.message.confirm.move.folder=您即將移動名稱為 ''{0}'' 的資料夾。是否確定?
action.Subversion.RepositoryBrowser.CopyUrl.text=複製 URL…
action.Subversion.RepositoryBrowser.Export.text=匯出(_E)…
dialog.title.import.directory=匯入目錄
label.select.directory.to.import.into.repository=選擇要匯入版本庫的目錄
dialog.title.destination.directory=目標目錄
label.select.checkout.destination.directory=選擇簽出目標目錄
label.select.export.destination.directory=選擇匯出目標目錄
progress.title.loading.child.entries=正在載入子條目
dialog.title.svn.import.options=SVN 匯入選項
dialog.title.svn.export.options=SVN 匯出選項
dialog.title.export.directory=匯出目錄
label.select.directory.to.export.from.subversion=選擇要從 Subversion 匯出的目錄
dialog.title.svn.delete=SVN 刪除
label.source.url=源 URL:
label.target.location=目標位置:
label.target.name=目標名稱:
label.target.url=目標 URL:
label.export=匯出:
checkbox.replace.existing.files=取代現有檔案
label.destination=目標:
checkbox.include.externals.locations=包括外部項位置
label.override.native.eols.with=覆寫 'native' EOL 的選項:
combobox.crlf.none=無
checkbox.include.ignored.resources=包含忽略的資源
label.import.from=匯入自:
label.import.to=匯入到:
label.repositories=版本庫:
label.point.to.repository.location=指向版本庫位置
dialog.title.select.share.target=選擇共享目標
button.share=共享
label.define.share.target=定義共享目標
radio.share.target.at.selected.repository.location=在所選版本庫位置
radio.share.target.in.new.folder=在所選版本庫位置的新 \\"{0}\\" 資料夾中
checkbox.create.tags.branches=創建 /tags 和 /branches
separator.commit.comment.prefix=提交註釋前綴
toolwindow.stripe.SVN_Repositories=SVN 版本庫

#authentication
label.auth.authentication.realm=身份驗證領域: ''{0}''
label.auth.user.name=用戶名(&U):
label.auth.password=密碼(&P):
checkbox.auth.keep.for.current.session=儲存憑證(&S)
dialog.title.authentication.required=需要身份驗證
notification.content.unknown.certificate.type.from.url=Subversion: {0} 中的證書類型未知
notification.content.authentication.failed=身份驗證失敗: {0}
popup.content.already.checking=正在檢查…
progress.title.svn.roots.authorization.checker=SVN VCS 根授權檢查器
progress.title.looking.for.file.working.copy.root=正在尋找 ''{0}'' 工作副本根
progress.text.clearing.stored.credentials=正在清除 {0} 中存儲的憑證
notification.title.not.logged.into.subversion=未登錄到 Subversion
notification.content.not.logged.into.subversion=未登錄到 Subversion ''{0}'' ({1})
notification.action.click.to.fix=點擊以修正。
progress.title.clear.authentication.cache=清除身份驗證快取(&C)
label.specify.ssl.protocol.manually=請嘗試手動指定 SSL 協議 - SSLv3 或 TLSv1
popup.content.failed.to.authenticate.to.proxy.change.credentials=代理驗證失敗。您可以在 HTTP 代理設定中更改代理憑證。
popup.content.failed.to.authenticate.to.proxy=代理驗證失敗。
error.server.ssl.certificate.rejected=伺服器 SSL 證書被拒

#history
progress.text2.collecting.history=正在收集 ''{0}'' 的修訂歷史記錄
checkbox.changes.filter.filter.by.author=作者(&U):
progress.text2.processing.revision=正在處理修訂 ''{0}''
progress.text.changes.collecting.changes=正在收集有關變更的資訊
progress.text2.changes.establishing.connection=正在建立與 ''{0}'' 的連接
progress.text2.revision.processed=已處理修訂 ''{0}''
action.Subversion.ShowMergeSourceDetails.text=顯示合併原始碼詳細資訊
action.Subversion.ShowIntegratePanel.text=顯示集成面板
progress.title.loading.working.copies.data=Subversion: 正在載入工作副本資料…
progress.title.edit.revision.comment=編輯修訂註釋
tab.title.edit.revision.comment=編輯修訂註釋
progress.title.getting.latest.repository.revision=正在獲取最新的版本庫修訂
notification.content.revision.commit.message.changed.to=修訂 #{0} 註釋更改為:\\\\n\\\\
''{1}''
column.name.merge.sources=合併原始碼
status.text.merge.sources=合併原始碼
label.no.subversion.1.5.working.copies=此專案中沒有 1.5 版本庫的 Subversion 1.5 工作副本
label.merge.from.url=從:
label.merge.to.branch=到:
label.mixed.revision.working.copy=混合修訂工作副本
label.select.target.working.copy=選擇目標工作副本的路徑

#Configuration
configurable.name.svn.general=Subversion
configurable.name.svn.presentation=表示
configurable.name.svn.network=網絡
configurable.name.svn.ssh=SSH
dialog.title.select.configuration.directory=選擇配置目錄
action.title.select.configuration.directory=更改配置目錄
dialog.description.select.configuration.directory=選擇 Subversion 配置目錄或創建新目錄
button.text.clear.authentication.cache=清除身份驗證快取(&C)
label.text.delete.stored.credentials=刪除為 'http'、'svn' 和 'svn+ssh' 協議存儲的所有憑證
button.text.edit.proxies=編輯網絡選項(&O)…
dialog.title.edit.http.proxies.settings = 編輯與網絡層相關的 Subversion 選項
dialog.edit.http.proxies.settings.error.same.group.names.text=檢測到同名的組: ''{0}''
dialog.edit.http.proxies.settings.error.ambiguous.group.patterns.text=找到與多個組符合的版本庫 URL: {0}
dialog.edit.http.proxies.settings.error.ambiguous.group.patterns.to.text=URL {0} 符合 {1}
dialog.edit.http.proxies.settings.tab.edit.user.file.title=使用者檔案
dialog.edit.http.proxies.settings.tab.edit.system.file.title=系統檔案
dialog.edit.http.proxies.settings.port.must.be.number.error=連接埠必須為數字(組 ''{0}'')
dialog.edit.http.proxies.settings.timeout.must.be.number.error=HTTP 超時必須為數字(組 ''{0}'')
dialog.edit.http.proxies.settings.dialog.select.ssl.client.certificate.path.title=選擇證書路徑
dialog.edit.http.proxies.settings.panel.proxy.title=HTTP 代理設定
dialog.edit.http.proxies.settings.panel.ssl.title=SSL 設定
dialog.edit.http.proxies.settings.panel.repositories.title=版本庫
dialog.edit.http.proxies.settings.patterns.text=URL 模式(&R):
dialog.edit.http.proxies.settings.exceptions.text=異常(&X):
dialog.edit.http.proxies.settings.server.text=伺服器(&S):
dialog.edit.http.proxies.settings.user.text=使用者(&U):
dialog.edit.http.proxies.settings.port.text=連接埠(&O):
dialog.edit.http.proxies.settings.password.text=密碼(&W)：
dialog.edit.http.proxies.settings.connection.timeout.text=連接超時(&I):
dialog.edit.http.proxies.settings.seconds.text=秒
dialog.edit.http.proxies.settings.paths.to.authority.certificates.text=CA 證書檔案的逗號分隔路徑(&P):
dialog.edit.http.proxies.settings.ssl.client.certificate.file.text=SSL 客戶端證書檔案(&C):
dialog.edit.http.proxies.settings.client.certificate.passphrase.text=SSL 客戶端證書密碼短語(&H):
dialog.edit.http.proxies.settings.trust.default.cas.text=信任預設 CA(&A)
dialog.edit.http.proxies.settings.test.connection.button.text=測試連接(&T)
dialog.edit.http.proxies.settings.test.connection.settings.will.be.stored.title=警告
dialog.edit.http.proxies.settings.test.connection.settings.will.be.stored.text=設定將被儲存
dialog.edit.http.proxies.settings.test.connection.error.title=連接測試失敗
dialog.edit.http.proxies.settings.test.connection.success.title=連接測試成功
dialog.edit.http.proxies.settings.test.connection.success.text=連接測試成功
progress.title.test.connection=測試連接
progress.message.connecting.to.url=正在連接到 {0}
confirmation.text.delete.stored.authentication.information=您將刪除所有存儲的 Subversion 身份驗證資訊。\\\\n\\\\
確定要刪除嗎?
confirmation.title.clear.authentication.cache=清除身份驗證快取
dialog.title.select.path.to.subversion.executable=Subversion
label.select.path.to.subversion.executable=選擇 Subversion 可執行檔案(1.7+)的路徑
label.path.to.svn.executable=Subversion 可執行檔案的路徑:
command.line.interactive.mode.title=啟用交互模式
command.line.interactive.mode.description=<html>模擬直接從終端執行 Subversion 命令時的行為(交互模式)。<br>這是處理 svn+ssh 版本庫的密碼/密碼短語提示以及信任 https 版本庫的無效伺服器證書所必需的。</html>
non.english.locale.detected.warning=使用了非英語區域設定。

ssh.settings.executable.label=SSH 可執行檔案:
dialog.title.ssh.settings.browse.executable=SSH 可執行檔案
ssh.settings.user.name.label=用戶名:
ssh.settings.port.label=連接埠:
ssh.settings.password.choice.title=密碼
ssh.settings.private.key.choice.title=私鑰
ssh.settings.private.key.path.label=路徑:
dialog.title.ssh.settings.browse.private.key=私鑰
ssh.settings.subversion.config.choice.title=Subversion 配置
ssh.settings.tunnel.label=SSH 隧道:
ssh.settings.update.tunnel.title=更新

label.working.copy.format.unknown=未知
error.format.is.not.supported=不支持 {0} 格式。支援的格式: {1}。

label.configure.upgrade.label=工作副本升級策略:
radio.configure.upgrade.auto.16format=自動升級(使用 Subversion 1.6)(&6)
radio.configure.upgrade.auto.17format=自動升級(使用 Subversion 1.7)(&7)
radio.configure.upgrade.auto.18format=自動升級(使用 Subversion 1.8)(&8)

label.configure.create.label={0} 將要創建新的 Subversion 工作副本，\\\\n\\\\
請選擇所需的工作副本格式:
radio.configure.create.auto.16format=1.6 格式(&6)
radio.configure.create.auto.17format=1.7 格式(&7)
radio.configure.create.auto.18format=1.8 格式(&8)

label.configure.change.label=將工作副本 ''{0}'' 格式更改為:
radio.configure.change.auto.16format=1.6 格式(&6)
radio.configure.change.auto.17format=1.7 格式(&7)
radio.configure.change.auto.18format=1.8 格式(&8)

dialog.upgrade.wcopy.format.title=Subversion 工作副本格式
label.working.copy.root.outside.text=工作副本根位於“專案設定”中指定的目錄外部。\\\\n\\\\
整個工作副本將被轉換。

progress.text.loading.contents=正在載入 ''{0}'' 的內容
progress.text2.revision.information=修訂{0}
progress.title.loading.file.content=正在載入遠端檔案內容
progress.title.loading.file.properties=正在載入遠端檔案屬性
exception.text.file.miss.svn=檔案 ''{0}'' 為唯讀，但缺少 svn:needs-lock 屬性
confirmation.text.edit.file=您要編輯的檔案在編輯前需要鎖定

#File statuses
file.status.external=外部 (svn)
file.status.obstructed=受阻 (svn)
file.status.replaced=取代 (svn)
status.group.name.replaced=已取代

#Adding
confirmation.text.add.file=您是否計劃將以下檔案添加到 Subversion?\\\\n\\\\
{0}
confirmation.text.add.dir=您是否計劃將以下目錄添加到 Subversion?\\\\n\\\\
{0}
confirmation.title.add.file=計劃添加
confirmation.title.add.multiple.files=選擇要添加到 Subversion 的檔案

#Ignore
action.name.ignore.files=添加忽略檔案遮罩
action.name.undo.ignore.files=從忽略列表移除文件名(或遮罩)

# Delete
confirmation.text.delete.file=您是否計劃將以下檔案從 Subversion 刪除?\\\\n\\\\
{0}
confirmation.text.delete.dir=您是否計劃將以下目錄從 Subversion 刪除?\\\\n\\\\
{0}\\\\n\\\\
注意: 提交變更後，該目錄將從磁碟中刪除。
confirmation.text.delete.dir.17=您是否計劃將以下目錄從 Subversion 刪除?\\\\n\\\\
{0}
confirmation.title.delete.file=計劃刪除
confirmation.title.delete.multiple.files=選擇要從 Subversion 刪除的檔案

#Lock/Unlock
progress.text.locking.files=正在鎖定版本庫中的檔案…
progress.text2.processing.file=正在處理檔案 {0}
progress.title.lock.files=鎖定檔案
exception.text.locking.file.failed=無法鎖定檔案: {0}
message.text.files.lock.failed={0,choice, 0#無法鎖定檔案。|1#無法鎖定檔案。}
message.text.files.locked={0,choice, 0#鎖定檔案失敗。|1#已鎖定 1 個檔案|2#已鎖定 {0,number} 個檔案}
progress.text.unlocking.files=正在解鎖版本庫中的檔案…
progress.title.unlock.files=解鎖檔案
exception.text.failed.to.unlock.file=無法解鎖檔案: {0}
message.title.unlock.failures=解鎖失敗
message.text.files.unlocked={0,choice, 0#解鎖檔案失敗。|1#已解鎖 1 個檔案|2#已解鎖 {0,number} 個檔案}

exception.text.cleanupaction.batchperform.not.implemented=CleanupAction.batchPerform 未實作
progress.text2.adding=正在添加 ''{0}''
progress.text2.deleting=正在刪除 ''{0}''
progress.text2.sending=正在發送 ''{0}''
progress.text2.replacing=正在取代 ''{0}''
progress.text2.transmitting.delta=正在傳輸 ''{0}'' 的增量
progress.title.copy=Subversion 副本
progress.text.copy.to=複製到 ''{0}''
message.text.no.conflicts.found=未找到衝突
message.title.no.conflicts.found=無衝突
label.select.files.and.directories.to.mark.resolved=選擇要標記為已解決的檔案和目錄:
dialog.title.mark.resolved=標記已解決
action.name.mark.resolved=標記已解決
action.name.resolve.conflict=解決衝突
action.name.revert=還原(&R)
error.revert.failed=還原失敗
action.name.set.property=設定屬性
exception.text.cannot.annotate.directory=註解操作僅對檔案有意義
progress.text.computing.annotation=正在計算 ''{0}'' 的註解
action.text.annotate=註解
label.revision=修訂
label.merge.source.revision=合併原始碼修訂
tooltip.revision.number.message=修訂 {0}: {1}
error.can.not.find.relative.path.for.path.at.revision=找不到 {0}@{1} 的相對路徑
error.can.not.get.current.revision.for.path=無法獲取檔案 {0} 的當前修訂
error.can.not.get.last.changed.revision.for.path.please.file.an.issue=無法獲取檔案上次進行的修訂: {0}\\\\n\\\\
請為此檔案執行 svn info 並提交問題。
checkbox.checkin.keep.files.locked=保持檔案鎖定(&K)
checkbox.checkin.auto.update.after.commit=提交後自動更新
progress.title.commit=提交
status.text.committed.revision=提交的修訂 {0}。
checkin.operation.name=提交(_I)
checkin.different.formats.involved={0,choice,0#版本庫|1#版本庫} {1} 的選定變更\\\\n\\\\
屬於不同格式的 Subversion 工作副本。\\\\n\\\\
提交將分為多個提交。\\\\n\\\\
\\\\n\\\\
您可以在“變更 | Subversion 工作副本資訊”中將所有工作副本轉換為相同格式。\\\\n\\\\
是否要繼續提交?
dialog.title.commit.will.split=Subversion: 提交將進行拆分
error.wrong.committed.revision.number=提交的修訂號錯誤: {0}
error.missing.committed.revision.number=缺少提交的修訂號: {0}
progress.text2.fetching.external.location=正在獲取 ''{0}'' 的外部位置
progress.text2.checked.out=已簽出 {1} 個檔案，正在簽出 {0}
progress.text2.exported=已匯出 {1} 個檔案，正在匯出 {0}
progress.text2.checked.out.revision=已簽出修訂 {0}。
progress.text2.exported.revision=已匯出修訂 {0}。
status.text.checked.out.revision=已簽出修訂 {0}。
message.text.cannot.load.supported.formats=無法載入支援的格式: {0}
message.text.cannot.checkout=無法從 svn 簽出: {0}
message.text.cannot.export=無法從 svn 匯出: {0}
dialog.title.check.out=從 Subversion 簽出
progress.title.check.out=從 Subversion 簽出
message.title.export=從 Subversion 匯出
progress.text.checking.out=正在將檔案簽出到 ''{0}''
progress.text.export=正在將檔案匯出到 ''{0}''
button.text.select.all=全選(&A)
button.text.deselect.all=取消全選(&D)
dialog.title.select.repository.location=選擇版本庫位置
dialog.message.can.not.detect.repository.root.for.url=無法檢測 URL 的版本庫根: {0}
progress.title.detecting.repository.root=正在檢測版本庫根
button.text.ssl.accept=接受(_A)
button.text.ssl.reject=拒絕(_R)
button.text.ssh.accept=是 (_Y)
button.text.ssh.reject=否 (_N)
dialog.title.ssl.examine.server.crertificate=檢查伺服器證書
dialog.title.ssh.examine.server.fingerprints=驗證伺服器密鑰指紋
label.ssl.server.provided.certificate=伺服器提供了以下證書:
label.ssh.server.provided.fingerprints=無法建立主機 {0} 的驗證。
label.ssh.server.provided.fingerprints2={0} 密鑰指紋為
label.ssh.server.provided.fingerprints3=確定要繼續連接嗎?
checkbox.svn.ssh.cache.fingerprint=將密鑰添加到 Subversion 快取(&A)
dialog.title.set.property=設定屬性
label.set.property.property.name=屬性名稱(&N):
radio.set.property.set.property.value=設定屬性值(&S):
radio.set.property.delete.property=刪除屬性(&D)
checkbox.set.property.update.properties.recursively=遞歸更新屬性(&R)

#update
update.switch.configurable.name=更新/切換
label.update.url=URL:
checkbox.update.switch.configurable.to.specific.revision=更新/切換到特定版本(&R):
checkbox.force.update=強制更新(&F)
checkbox.ignore.externals=忽略外部項(&E)
checkbox.update.switch.configurable.try.merge.without.changes=嘗試合併，但不做任何變更(&T)
progress.text.merging.dry.run.changes=正在將(dry run)變更合併到 ''{0}''
progress.text.merging.changes=正在將變更合併到 ''{0}''
progress.text.updating=正在更新 ''{0}''
exception.text.root.was.not.properly.updated=svn: {0} 未正確更新; 可能是因為它已經與父級一起從版本庫中移除。
message.text.update.no.directories.found=找不到要更新的版本管理目錄
messate.text.update.error=SVN: 更新錯誤
label.external.copy=外部副本
label.switched.copy=已切換副本

progress.text2.added=已添加 {0}
progress.text2.deleted=已刪除 {0}
progress.text2.conflicted={0} 存在衝突
progress.text2.treeconflicted=已衝突 {0}(樹衝突)
progres.text2.merged=已合併 {0}
progres.text2.updated=已更新 {0}
progress.text2.restored.file=已恢復 {0}
progres.text2.updated.to.revision=已更新至修訂 {0}。
status.text.updated.to.revision=已更新至修訂 {0}。
progress.text2.skipped.file=已跳過 {0}
progress.text.updating.external.location=正在更新 ''{0}'' 的外部位置
server.ssl.accept.temporary.action.name=接受臨時(_T)
integrate.display.name=整合
error.invalid.svn.revision=無效的 svn 修訂: {0}
error.invalid.url=無效 url: {0}
integrate.configuration.revision1.label=修訂(&V)
integrate.configuration.source2.label=源 2:
integrate.configuration.revision2.label=修訂(&R)
integrate.configuration.source1.label=源 1:
integrate.configuration.description.label=將源之間的差異集成到工作副本中(比較源 2 和源 1)
source.url.could.not.be.empty.error.message=源 URL 不能為空
no.differences.between.sources.error.message=源和相同源之間沒有區別
label.update.switch.to.revision=更新/切換到修訂:
configure.revision.specified.radio=指定的
configure.revision.head.radio=HEAD
update.configuration.specific.url=更新/切換到特定 URL(&U):
progress.text.import=匯入 {0}
message.text.cannot.import=無法匯入 svn: {0}
message.title.import=匯入 Subversion
revision.title=修訂
error.revision.from.must.be.a.valid.number=“起始修訂”必須為有效數字
error.revision.to.must.be.a.valid.number=“結束修訂”須為有效數字
checkout.dialog.title=從 Subversion 簽出
checkout.dialog.button=檢出
checkout.directory.chooser.title=簽出目錄
checkout.directory.chooser.prompt=選擇要從 Subversion 簽出的目錄
checkout.options.dialog.title=SVN 簽出選項
checkout.options.checkout.label=檢出:
configure.branches.title=配置 Subversion 分支
configure.branches.error.wrong.url=主幹位置必須在版本庫根 ''{0}'' 下
configure.branches.trunk.location=主幹位置:
configure.branches.branch.locations=分支位置:
refresh.branches.item=刷新分支…
copy.column.title=複製
copy.column.tooltip=從 {0} 複製
progress.title.loading.branches=正在載入分支
compare.with.branch.progress.loading.content=載入內容中...
compare.with.branch.diff.title=與分支比較
compare.with.branch.error.title=與分支比較
compare.with.branch.popup.title=與分支比較
compare.with.branch.location.error=在分支 ''{1}'' 下找不到檔案 ''{0}'' 的版本庫位置\\\\n\\\\
請檢查您的分支配置。
action.name.switch=切換
import.dialog.title=匯入 Subversion
import.dialog.button=匯入
repository.browser.add.location.action.text=添加版本庫位置
repository.browser.add.location.action.description=添加版本庫位置
repository.browser.no.locations.added.info=未添加版本庫位置。
repository.browser.add.location.prompt=版本庫 URL:
repository.browser.add.location.title=新建版本庫位置
repository.browser.details.action=顯示/隱藏詳細資訊
repository.browser.refresh.action=刷新選定樹節點
repository.browser.add.location.menu.item=版本庫位置(_R)…
repository.browser.edit.location.menu.item= 編輯位置 URL(_U)…
repository.browser.discard.location.action=丟棄位置(_L)
repository.browser.discard.location.prompt=要丟棄位置 ''{0}'' 嗎?
repository.browser.discard.location.title=丟棄位置
repository.browser.new.folder.action=遠端資料夾(_F)…
action.repository.browser.history.text=顯示歷史記錄
action.repository.browser.history.description=顯示歷史記錄
repository.browser.import.action=匯入(_I)…
diff.options.title=與分支或標記比較
diff.options.label.compare=比較:
diff.options.label.with=與:
diff.options.label.compare.type=比較類型
diff.options.checkbox.reverse.diff=反轉差異
diff.options.radio.graphical.compare=圖形比較
diff.options.radio.unified.diff=統合差異
diff.options.no.url.error=請選擇一個 URL 進行比較
diff.options.same.url.error=請選擇其他 URL 進行比較
diff.options.no.patch.file.error=請指定儲存補丁檔案的路徑
dialog.title.save.unified.diff=補丁檔案
label.select.file.to.save.unified.diff=選擇用於存儲統合差異的檔案
diff.cant.get.properties.changes=無法顯示 SVN 屬性
repository.browser.browse.changes.action=瀏覽變更(_B)…
repository.browser.browse.changes.description=查看選定節點中的變更歷史記錄
repository.browser.compare.title=比較 ''{0}'' 和 ''{1}''
error.could.not.compare.local.file.and.remote.url.with.executable.for.svn.version=無法將本地檔案和遠端 Url 與 svn {0} 的可執行檔案相比較
cleanup.action.name=清理
changes.browser.revision.term=修訂
dialog.title.computing.difference=正在計算差異
progress.searching.for.files.with.conflicts=正在搜尋有衝突的檔案
add.files.errors.title=添加檔案時出錯
move.files.errors.title=移動檔案時出錯
error.target.of.move.operation.is.already.under.version.control=移動操作的目標已受到版本控制。
error.move.have.not.been.performed=尚未執行 Subversion 移動。
delete.files.errors.title=刪除檔案時出錯
progress.title.adding.files.to.subversion=正在向 Subversion 添加檔案
progress.title.deleting.files.from.subversion=正在從 Subversion 中刪除檔案
progress.title.moving.files.in.subversion=正在移動 Subversion 中的檔案
copy.dialog.title=分支或標籤
move.dialog.title=移動或重命名
select.location.invalid.url.message=無效的 Subversion 版本庫 URL: ''{0}''
share.directory.action=共享目錄…
share.directory.commit.message={2}\\\\n\\\\
{1} 創建的目錄 ''{0}''
share.directory.title=共享目錄
dialog.message.share.to.not.empty.directory=遠端資料夾 \\"{0}\\" 非空。\\\\n\\\\
要繼續共享嗎?
share.directory.info.message=要完成共享操作，請提交 ''{0}''。
share.directory.create.dir.progress.text=正在創建遠端資料夾 {0}
share.directory.checkout.back.progress.text=正在簽出 {0}
share.or.import.add.progress.text=正在排定 {0} 的添加時間表
progress.title.share.directory=共享目錄
progress.title.check.remote.folder.contents=檢查遠端資料夾內容
tab.title.failed.to.share.project=無法共享專案
action.share.whole.project.text=共享專案(Subversion)…
action.Subversion.integrate.changes.select.working.copy.text=集成到工作副本：
dialog.title.integrate.to.branch=集成到分支
action.Subversion.integrate.changes.message.not.under.control.text=所選目標不在 Subversio 的控制下。仍要繼續？
action.Subversion.integrate.changes.message.another.wc.text=所選目標位於另一個版本庫的工作副本內。仍要繼續？
action.Subversion.integrate.changes.branch.info.source.label.text=源分支 URL：{0}
action.Subversion.integrate.changes.branch.info.target.label.text=目標分支 URL：{0}
action.Subversion.integrate.changes.actionname=集成到分支…
action.Subversion.integrate.changes.description=將選定的變更列表/變更集集成到選定的分支
action.Subversion.integrate.changes.messages.title=集成到分支
dialog.message.integrate.changes.error.no.available.files=沒有可用於集成的檔案
popup.title.select.branch.to.integrate.to=選擇要集成到的分支…
dialog.message.integrate.changes.error.same.source.and.target=無法啟動集成: 目標分支和源分支相同。
dialog.message.integrate.changes.error.target.not.dir=無法啟動集成: 目標目錄不存在或不是目錄。
dialog.message.integrate.changes.error.not.versioned=無法啟動集成: 目標目錄不在 Subversion 控制下或不屬於所選分支。
action.Subversion.integrate.changes.dialog.add.wc.text=添加
action.Subversion.integrate.changes.dialog.remove.wc.text=移除
action.Subversion.integrate.changes.message.files.up.to.date.text=所有檔案均為最新
action.Subversion.integrate.changes.collecting.changes.to.commit.task.title=正在收集要提交的變更
action.Subversion.integrate.changes.error.unable.to.collect.changes.text=收集要提交的更改時出錯：{0}
error.cannot.load.revisions=無法載入修訂列表
action.Subversion.integrate.changes.progress.integrating.text=正在合併更改
update.switch.to.branch.text=使用分支:
popup.title.select.branch=選擇分支
progress.live.provider.loading.revisions.text=正在從伺服器載入修訂
progress.live.provider.loading.revisions.details.text=正在從伺服器載入修訂…
dialog.show.svn.map.title=Subversion 工作副本資訊
label.working.copy.url=URL:
label.working.copy.format=格式:
link.change.format=已改變
label.working.copy.depth=深度:
link.fix.depth=修正
label.working.copy.root=工作副本根
label.nested.copy.type.external=外部
label.nested.copy.type.switched=已切換
label.nested.copy.type.inner=嵌套
dialog.title.convert.working.copy.format=轉換工作副本格式
progress.title.convert.working.copy.format=轉換工作副本格式
progress.text.converting.working.copy.format=將 {0} 格式的工作副本從 {1} 轉換為 {2}
progress.details.upgraded.path=已升級路徑 {0}
dialog.message.invalid.working.copy.root=無效的工作副本根: {0}
dialog.title.can.not.invoke.action=無法調用 {0}
dialog.title.set.working.copy.infinity.depth=設定工作副本無限深度
dialog.message.set.working.copy.infinity.depth=您將以 ''infinity'' 深度簽出到 ''{0}''。\\\\n\\\\
您的工作副本也將隨之更新為 HEAD 修訂。
action.name.configure.branches=配置分支
action.name.merge.from=合併自
action.name.merge.from.ellipsis=合併自…
notification.content.can.not.access.working.copy.database=存取 svn 工作副本資料庫時發生了若干錯誤。
notification.content.single.root.unsupported.format=根 ''{0}'' 可能是不受支援的 Subversion 格式
notification.content.multiple.roots.unsupported.format=某些根的格式可能是不受支援的 Subversion 格式

committed.changes.action.enable.merge.highlighting=高亮顯示集成項
committed.changes.action.enable.merge.highlighting.description.text=選項僅適用於 SVN 版本庫和 1.5 版本的工作副本
committed.changes.action.merge.highlighting.refresh.text=刷新
committed.changes.action.merge.highlighting.refresh.description=刷新合併的修訂資訊
dialog.Subversion.select.working.copy.title=配置工作副本路徑
dialog.Subversion.select.working.copy.wcopy.list.title=已知工作副本
action.Subversion.cleanup.progress.title=Subversion 清理
progress.text.performing.path.cleanup=正在執行 ''{0}'' 清理…
progress.title.cleanup.project=清理專案
action.Subversion.cleanup.error.message=對 ''{0}'' 執行清理時出錯: {1}
action.Subversion.integrate.difference.option.use.ancestry.text=使用以前的版本(&U)
use.idea.proxy.as.default=將 {0} 常規代理設定用作 Subversion 的預設設定
use.idea.proxy.as.default.label.text=僅 HTTP 代理可用作預設值
navigate.to.idea.proxy.settings=導航到常規代理設定
dialog.message.switch.target.not.copy.current=切換目標 URL 不是當前副本。\\\\n\\\\
要繼續嗎?
dialog.title.switch.target.problem=切換目標問題
tab.repository.merge.panel.filter.plus=篩選出集成項
tab.repository.merge.panel.filter.minus=篩選出未集成項
tab.repository.merge.panel.filter.others=篩選出其他
browse.changes.settings.stop.on.copy=複製時停止(&S)
action.mark.list.as.merged.text=標記為已合併
action.mark.list.as.merged.description=將所選修訂版標記為已合併，但實際沒有合併
action.mark.list.as.not.merged.text=標記為未合併
action.mark.list.as.not.merged.description=將所選修訂版標記為未合併，但不會更改 svn:mergeinfo 之外的任何內容
label.depth.text=深度(&D):
label.depth.description=取代舊的“遞歸”選項。“遞歸”為 false 等效於“直接子級”，“遞歸”為 true 等效於“無限”
label.working.copy=工作副本
label.depth.empty=空
label.depth.files=檔案
label.depth.immediates=直接
label.depth.infinity=無限
label.depth.exclude=排除
label.depth.unknown=未知
undo.integrate.to.branch=撤消集成到分支…
undo.integrate.to.branch.description=從分支中移除修訂中所做的變更
undo.integrate.to.branch.dialog.title=撤消集成到分支
merge.source.details.title=合併 {0} [{1}] 的原始碼詳細資訊
repository.browser.edit.location.dialog.title= 編輯位置 URL
action.Subversion.TogglePropertiesDiff.text=顯示屬性
action.Subversion.TogglePropertiesDiff.description=顯示 SVN 屬性的差異
action.IntegrateChangeSetAction.text=集成到分支
show.properties.diff.progress.text.revision.information=修訂{0}
show.properties.diff.progress.text2.property.information=屬性 {0}
checkbox.ignore.whitespace.when.merge.text=&忽略空格
label.file.has.conflicts=檔案有 {0} 個衝突，無法提交
label.file.has.conflicts.before.or.after=檔案有 {0} 個衝突，無法提交\\\\n\\\\
{1}
label.file.has.conflicts.before.and.after=檔案有 {0} 個衝突，無法提交\\\\n\\\\
之前: {1}\\\\n\\\\
之後: {2}
label.locally.deleted.file.has.conflicts=檔案有 {0} 個衝突
file.conflict.tree=樹
file.conflict.text=文本
file.conflict.property=屬性
action.Subversion.MarkTreeResolved.text=將樹衝突標記為已解決…
dialog.message.mark.tree.conflict.resolved.confirmation=是否要將樹衝突標記為已解決？
dialog.title.mark.tree.conflict.resolved=將樹衝突標記為已解決
progress.title.mark.tree.conflict.resolved=將樹衝突標記為已解決
svn.integrate.changelist.warning.unresolved.conflicts.text=集成中斷。存在未解決的衝突或跳過的項。
error.integration.was.canceled=集成已取消
svn.option.ignore.whitespace.in.annotate=忽略註解中的空格差異
annotation.show.merge.sources.default.text=在歷史記錄和註解中顯示合併原始碼
svn.cannot.save.credentials.store-auth-creds=無法存儲憑證: “store-auth-creds = no”禁止
annotation.original.revision=原始修訂
confirmation.resolve.tree.conflict.merge.moved=將 {0} 中的變更應用到本地移動的 {1}?
confirmation.resolve.tree.conflict.merge.renamed=將 {0} 中的變更套用到本地重命名的 {1}?
svn.create.external.below.action=創建外部…
svn.create.external.below.description=選擇 URL，添加 svn:external 屬性，然後可以選擇簽出
button.select=選擇
dialog.title.select.target.for.external=選擇用於外部的目標
dialog.message.target.file.already.exists=目標檔案已經存在
progress.title.creating.external=正在創建外部
tab.title.create.external=創建外部
error.selected.destination.conflicts.with.existing=所選目標與現有目標相衝突: {0}
label.local.target=本地目標:
checkbox.checkout=簽出
svn.edit.commit.message.title=編輯修訂 #{0} 註釋
svn.edit.commit.message.attention=注意! 以前的訊息將丟失!
svn.edit.commit.message.prompt=新修訂註釋:

#Merge
quick.merge.variants.merge.all=全部合併
quick.merge.variants.merge.all.explanation=所有未合併的修訂將被合併。\\\\n\\\\
Subversion 將使用本地副本中記錄的 svn:mergeinfo 屬性尋找未合併的修訂。
quick.merge.variants.quick.select=快速手動選擇
quick.merge.variants.quick.select.explanation=顯示來自目標分支、已合並和未合併分支的所有修訂。\\\\n\\\\
用於手動選擇。快速獲取結果。
quick.merge.variants.pre.select=通過預篩選選擇
quick.merge.variants.pre.select.explanation=尋找涉及的一個分支複製自另一個分支的位置。\\\\n\\\\
僅載入尚未合併的修訂以供選擇。執行可能需要很長時間。
progress.title.merging.all.from.branch=正在合併 {0} 中的全部內容
progress.title.merging.all.from.branch.reintegrate=正在合併 {0} 中的全部內容(重新集成)
progress.title.shelving.local.changes.before.merge=正在擱置合併前的本地變更
progress.title.checking.repository.capabilities=正在檢查版本庫容量
progress.title.loading.recent.branch.revisions=正在載入最近的 {0} 修訂
progress.title.looking.for.branch.origin=正在尋找分支來源
progress.title.filtering.branch.revisions=正在篩選 {0} 修訂
progress.title.calculating.copy.revision=正在計算副本修訂
progress.text.collecting.merge.information=正在收集合併資訊
progress.text.collecting.not.merged.revisions=正在收集未合併的修訂
progress.details.merging.changelist.range=正在合併變更列表 {0}
error.could.not.parse.merge.info=無法解析 {0}
action.Subversion.SelectAllRevisions.text=全選
action.Subversion.SelectAllRevisions.description=全選
action.Subversion.UnselectAllRevisions.text=取消全選
action.Subversion.UnselectAllRevisions.description=取消全選
button.merge.selected=合併所選內容
button.merge.all=全部合併
dialog.title.select.merge.variant=選擇合併變體
dialog.message.merge.with.switched.paths.in.working.copy=工作副本中有一些切換的路徑。要繼續嗎?
dialog.message.merge.confirm.reintegrate=您將重新集成變更。<br><br>此舉將導致分支 ''{0}'' <b>不能再用於進一步的處理</b>。<br>此分支既無法正確吸收新的主幹({1})變更，<br>也無法正確地重新集成到主幹。<br> <br>確定嗎?
dialog.message.merge.intersects.with.local.changes.prompt=存在與合併變更衝突的本地變更。\\\\n\\\\
是否繼續?
dialog.message.merge.potentially.intersects.with.local.changes.prompt=存在與合併變更有可能相交的本地變更。\\\\n\\\\
要繼續嗎?
tab.title.merge.local.changes.intersection={0}，本地變更相交
label.merge.local.changes.intersection=以下檔案具有與合併變更相交的本地變更:
notification.content.merge.start.was.not.found=找不到合併起始點
notification.content.can.not.merge.from.self=無法自我合併
notification.content.everything.is.up.to.date=所有內容都已處於最新狀態
operation.merge=合併
button.load.quantity=載入 +{0}
label.already.merged=已合併
dialog.title.merge.from.branch=合併自 {0}
label.merge.all.from.branch=合併 {0} 中的全部內容
label.merge.all.from.branch.reintegrate=合併 {0} 中的全部內容(重新集成)
label.merge.all.from.branch.at.revision=合併 {1} 的 {0} 中的全部內容
label.merge.all.from.branch.at.revision.reintegrate=合併 {1} 的 {0} 中的全部內容(重新集成)
label.skipped.changelists=已跳過變更列表：{0}
label.changelists.merging.faced.problems=變更列表:\\\\n\\\\
{0}\\\\n\\\\
合併面臨的問題
label.merged.from.branch=已合併自 {0}
merge.chunk.changelist.description={0} [來自於修訂 {1}]

#Conflicts
progress.title.getting.base.and.theirs.revisions.content=獲取基本內容及其修訂內容
progress.title.creating.patch.for.theirs.changes=正在為其變更創建補丁
progress.title.accepting.working.state=正在接受工作狀態
progress.title.adding.file.to.subversion=正在將 {0} 添加到 Subversion
progress.title.applying.binary.changes=正在套用二進制變更
progress.title.resolve.tree.conflict=解決樹衝突
dialog.title.resolve.tree.conflict=解決樹衝突
dialog.message.keep.newly.created.files.in.their.original.place=在其初始位置保留新建檔案?
dialog.message.accept.theirs.for.path=接受他們對 {0} 的變更?
dialog.message.accept.yours.for.path=針對 {0} 接受您的變更?
progress.title.accepting.theirs.for.path=為之接受他們的變更: {0}
progress.title.accepting.yours.for.path=為之接受您的變更: {0}
dialog.message.select.binary.files.to.patch=選擇要打補丁的二進制檔案
dialog.message.merge.from.theirs.delete.binary.file=(根據其變更)刪除二進制檔案 {0}?
dialog.message.merge.from.theirs.create.binary.file=(根據其變更)創建二進制檔案 {0}?
dialog.message.merge.from.theirs.modify.binary.file=(根據其變更)對二進制檔案 {0} 套用變更?
button.keep=保留
button.move=移動
button.resolve.conflict.merge=合併
button.resolve.conflict.accept.yours=接受您的變更
button.resolve.conflict.accept.theirs=接受他們的變更
label.path.revisions.info={0}(當前: {1}，已提交: {2})
label.conflict.left.side=左: {0}
label.conflict.right.side=右: {0}
label.conflict.directory.added=(目錄)已添加
label.conflict.file.added=(檔案)已添加
label.conflict.directory.unversioned=(目錄)未進行版本管理
label.conflict.file.unversioned=(檔案)未進行版本管理
label.before.accepting.theirs.for.path=在針對 {0} 接受他們的變更前
label.after.accepting.theirs.for.path=在針對 {0} 接受他們的變更後
message.theirs.changes.merged.for.file=已針對 {0} 合併他們的變更
message.theirs.accepted.for.file=已針對 {0} 接受了他們的變更
message.yours.accepted.for.file=已針對 {0} 接受了您的變更
value.patch.file.name=TheirsChanges.patch
error.can.not.load.theirs.content.for.file=無法為檔案 {0} 載入他們的內容
tree.conflict.description=本地 {0}，{2} 時傳入 {1}
conflict.reason.edited=編輯
conflict.reason.obstructed=障礙
conflict.reason.deleted=刪除
conflict.reason.missing=缺少
conflict.reason.unversioned=未進行版本管理
conflict.reason.added=添加
conflict.reason.replaced=取代
conflict.reason.moved.away=移開
conflict.reason.moved.here=已移到此處
conflict.action.edit=編輯
conflict.action.add=添加
conflict.action.delete=刪除
conflict.action.replace=取代
conflict.operation.update=更新
conflict.operation.switch=切換
conflict.operation.merge=合併
conflict.operation.none=無

dialog.create.branch.or.tag.from.working.copy.warning=<html>使用此變體創建<b>具有本地變更</b>的分支。<br/>通常，不僅是目標目錄，還將有幾個項“帶歷史記錄添加”。<br/><br/>具有與根不同的修訂的各個檔案將被分別複製。<br/>因此，建議先更新工作副本，然後再創建分支。</html>

exportable.SvnDiffSettings.presentable.name=SVN 差異
configurable.SvnConfigureProxiesComponent.display.name=HTTP 代理配置
value.new.server.group.name=未命名
settings.use.custom.directory=使用自訂配置目錄(&U):
settings.check.mergeinfo=在準備合併時檢查目標子樹中的 svn:mergeinfo
settings.maximum.revisions.number=要在註解中回溯的最大修訂數：
settings.HTTP.timeout=HTTP 超時：
settings.seconds=秒
settings.SSH.connection.timeout=SSH 連接超時：
settings.SSH.read.timeout=SSH 讀取超時：
settings.edit.servers.subversion.runtime.configuration.file=編輯 'servers' Subversion 執行時配置檔案
settings.ssl.protocols=SSL 協議:
settings.ssl.protocols.all=所有
settings.ssl.protocols.sslv3=SSLv3
settings.ssl.protocols.all.tlsv1=TLSv1
action.DumbAware.SvnConfigureProxiesComponent.text.add=添加
action.DumbAware.SvnConfigureProxiesComponent.description.add=添加
action.DumbAware.SvnConfigureProxiesComponent.text.copy=複製
action.DumbAware.SvnConfigureProxiesComponent.description.copy=複製
action.DumbAware.RepositoryBrowserDialog.text.branch.or.tag=分支或標記…
action.DumbAware.RepositoryBrowserDialog.text.move.or.rename=移動或重命名(_M)…

svn.properties.viewer=SVN 屬性查看器
svn.tree.conflict.viewer=SVN 樹衝突查看器
svn.phantom.changes.viewer=SVN 模擬變更查看器
label.svn.phantom.change=技術記錄
text.svn.phantom.change=已記錄此變更，因為其目標檔案被刪除，\\\\n\\\\
並且某些父目錄已複製(或移動)到新位置。
dialog.title.svn.properties.diff=SVN 屬性差異
progress.title.loading.change.details=正在載入變更詳細資訊
progress.title.loading.tree.conflict.details=正在載入樹衝突詳細資訊
label.svn.properties.changed=SVN 屬性已更改
separator.property.changes=屬性變更

error.no.branch.point.found.for.target=找不到 {0} 的分支點
error.target.not.found.in.paths=在 {1} 中找不到 {0}
error.file.is.not.under.version.control=檔案 {0} 未進行版本管理
error.file.is.not.under.subversion=檔案 {0} 未受到 Subversion 控制
error.can.not.find.file=找不到檔案: {0}
error.can.not.find.repository.root.for.url=找不到 URL 的版本庫根: {0}
error.can.not.find.repository.root.for.url.in.revision=在修訂 {1} 中找不到 URL: {0} 的版本庫根
error.could.not.get.info.for.path=無法獲取 {0} 的資訊
error.could.not.get.head.info.for.url=無法獲取 {0} 的標頭資訊
error.could.not.get.revision.for.url=無法獲取 {0} 的修訂
error.properties.loading.for.revision.canceled=已取消為修訂 {0} 載入屬性。
error.can.not.access.file.base.revision.contents.administrative.area.is.locked=無法存取檔案的基本修訂內容: 管理區域已鎖定
error.url.is.not.absolute={0} 非絕對
error.url.is.not.hierarchical={0} 非層次結構
error.url.could.not.contain.query={0} 不能包含查詢
error.url.could.not.contain.fragment={0} 不能包含片段
error.can.not.delete.file=無法刪除檔案: {0}
error.can.not.create.directory=無法創建目錄: {0}
error.could.not.determine.revision.number.for.file.and.revision=無法確定檔案 {0} 和修訂 {1} 的修訂號
error.could.not.find.start.quote=找不到起始引號
error.could.not.find.separating.space=找不到分隔空間
error.latest.existent.revision.found.for.url=已找到 {0} 的最新現有修訂
error.could.not.get.relative.path.for.parent.and.child=無法獲取 {0} 和 {1} 的相對路徑
error.could.not.parse.svn.version=無法解析 svn 版本: {0}
error.could.not.get.svn.version=退出程式碼: {0}，錯誤: {1}
error.parse.file.status.unknown.state.on.line=第 {0} 行的狀態未知
error.svn.exited.with.error.code=SVN 進程已退出，錯誤程式碼為: {0}
error.authentication.canceled.for.repository=已對版本庫取消身份驗證: {0}
error.svn.status.with.no.output=狀態請求沒有為命令返回任何內容: {0}
error.svn.status.not.in.working.copy=請求的狀態不在工作副本中: {0}
toolwindow.working.copies.info.title=Subversion 工作副本資訊
svn.short.name.with.mnemonic=SVN(_S)"
`;

exports[`src messages/VcsBundle.properties 1`] = `
"none.vcs.presentation=<無>
vcs.command.name.add=添加
vcs.command.name.remove=移除
vcs.command.name.checkin=提交(_I)
vcs.command.name.edit=編輯
vcs.command.name.checkout=簽出
vcs.command.name.status=狀態
vcs.command.name.update=更新
vcs.settings.path=設定 | 版本控制
vcs.settings.path.mac=偏好設定 | 版本控制
history.empty=歷史記錄為空
history.loading.revisions=正在載入受影響的修訂
exception.text.unknown.error=未知錯誤
exception.text.internal.error.method.should.not.be.called=不應調用
vcs.revision.name.current=當前
error.no.changes.to.commit=選擇要提交的檔案
error.no.commit.message=指定提交訊息
error.no.changes.no.commit.message=選擇要提交的檔案並指定提交訊息
label.commit.checks.not.available.during.indexing=編制索引期間無法提交檢查
label.commit.checks.failed=檢查失敗: {0}
confirmation.text.check.in.with.empty.comment=在註釋為空的情況下提交?
confirmation.title.check.in.with.empty.comment=註釋為空
action.commit.anyway.text=仍然{0}
amend.action.name=修正{0}
action.amend.commit.anyway.text=仍然修正
commit.message.placeholder=提交訊息
label.commit.comment=提交訊息(&M)
border.standard.checkin.options.group=在{0}之前
border.standard.after.checkin.options.group=在{0}之後
checkbox.checkin.options.optimize.imports=優化 import(&O)
checkbox.checkin.options.reformat.code=格式化程式碼(&R)
checkbox.checkin.options.rearrange.code=重新整理程式碼(&N)
progress.title.commit.checks=提交檢查
progress.text.inspecting.code=正在檢查程式碼…
progress.text.applying.fixes=正在套用修正…
progress.text.reformatting.code=正在重新格式化程式碼…
progress.text.rearranging.code=正在重新排列程式碼…
progress.text.optimizing.imports=正在優化 import…
progress.text.analyzing.code=正在分析程式碼…
progress.text.checking.for.todo=正在檢查 TODO…
progress.text.searching.for.modified.files=正在搜尋修改的檔案
button.text.overwrite.modified.file=覆蓋已修改的檔案(&O)
button.text.overwrite.modified.files=覆蓋已修改的檔案(&O)
message.text.file.locally.modified=檔案 {0} 已在本地被修改。
message.text.several.files.locally.modified=某些檔案已在本地被修改。
update.group.name.updated.from.server=從伺服器更新
update.group.name.updated=已更新
update.group.name.created=已創建
update.group.name.deleted=已刪除
update.group.name.restored=已恢復
update.group.name.modified=已修改
update.group.name.skipped=已跳過
update.group.name.merged.with.property.conflicts=已合併，但存在屬性衝突
update.group.name.merged.with.tree.conflicts=已合併，但存在樹衝突
update.group.name.merged.with.conflicts=已合併，但存在衝突
update.group.name.merged=已合併
update.group.name.not.in.repository=不在版本庫中
update.group.name.locally.added=本地已添加
update.group.name.locally.removed=本地已移除
update.group.name.switched=已切換
status.group.name.changed.on.server=在伺服器上已更改
status.group.name.changed=已更改
status.group.name.created=已創建
status.group.name.deleted=已刪除
status.group.name.modified=已修改
status.group.name.skipped=已跳過
status.group.name.will.be.restored=將被恢復
status.group.name.will.be.merged.with.property.conflicts=將在存在屬性衝突的情況下合併
status.group.name.will.be.merged.with.tree.conflicts=將在存在樹衝突的情況下合併
status.group.name.will.be.merged.with.conflicts=將在存在衝突的情況下被合併
status.group.name.will.be.merged=將被合併
status.group.name.not.in.repository=不在版本庫中
status.group.name.locally.added=本地已添加
status.group.name.locally.removed=本地已移除
status.group.name.switched=已切換
border.changes.filter.change.number.filter=更改
border.changes.filter.date.filter=日期
checkbox.show.changes.after.num=從(&F)
checkbox.show.changes.before.num=到(&T):
checkbox.show.changes.before.date=之前(&B)
checkbox.show.changes.after.date=之後(&A)
exception.text.internal.errror.could.not.implement.method=無法實作
message.text.could.not.load.virtual.file.content=無法載入檔案 {0} 的內容: {1}
message.title.could.not.load.content=無法載入內容
message.text.commit.progress=正在提交…
message.text.commit.failed.with.error=提交失敗，有{0,choice,1#錯誤|2#錯誤}
message.text.commit.finished.with.warning=提交完成，有{0,choice,1#警告|2#警告}
message.text.background.tasks=正在等待背景 VCS 任務完成…
diff.title.local=本地
diff.title.local.with.number=本地({0})
message.title.annotate=註解
action.name.checkin.directory={0}{1,choice,1#目錄|2#目錄}
action.name.checkin.file={0}{1,choice,1#檔案|2#檔案}
action.for.file.with.dialog.text={0}{1, choice, 1#檔案|2#檔案}…
column.name.revision.list.author=作者
column.name.revisions.list.filter=日期
column.name.revisions.list.branch=分支
column.name.revision.list.revision=修訂
lookup.title.vcs.file.revisions=檔案修訂
border.selected.revision.commit.message=提交訊息
loading.file.history.progress=正在載入檔案歷史記錄
loading.text2.file.history.progress=正在載入檔案歷史記錄
loading.file.history.status=正在載入 {0} 的歷史記錄…
loading.file.history.up.to.revision.status=正在載入 {0} 截至 {1} 的歷史記錄…
message.title.could.not.load.file.history=載入檔案歷史記錄時發生問題
group.name.version.control=VCS(&V)
message.text.cannot.open.editor=無法打開檔案 {0} 的文本編輯器
message.title.cannot.open.editor=無法打開編輯器

#configuration
column.info.configure.vcses.directory=目錄
column.name.configure.vcses.vcs=VCS
checkbox.show.clear.read.only.status.dialog=如果嘗試編輯檔案，則提示解鎖設為唯讀的檔案
radio.after.deletion.do.not.remove=不移除
radio.after.deletion.show.options=詢問
radio.after.deletion.remove.silently=靜默移除
radio.after.creation.do.not.add=不添加
radio.after.creation.add.silently=靜默添加
radio.after.creation.show.options=詢問
checkbox.force.non.empty.messages=強制非空提交註釋(&E)
checkbox.clear.initial.commit.message=清除初始提交訊息(&I)
version.control.main.configurable.name=版本控制
action.name.show.difference=顯示差異
settings.filter.update.project.info.by.scope=按範圍篩選更新專案資訊
settings.partial.changelists.enable.checkbox=允許將一個檔案中的變更放入不同的變更列表(&P)
settings.show.conflict.resolve.dialog.checkbox=試圖編輯非活動變更列表中的檔案時顯示對話框(&D)
settings.highlight.files.with.conflicts.checkbox=高亮顯示存在變更列表衝突的檔案(&H)
settings.highlight.files.from.non.active.changelist.checkbox=高亮顯示非活動變更列表中的檔案(&I)
settings.files.with.ignored.conflicts.list.title=包含忽略衝突的檔案:
settings.inactive.changelist.group.title=非活動變更列表
settings.changelist.conflicts.group.title=衝突
#file view
action.name.show.files.as.tree=作為樹顯示
label.selected.revision.commit.message=提交訊息
column.name.revision.version=版本
column.name.revision.date=日期

#history
action.name.compare=比較
action.description.compare=比較版本
message.text.cannot.show.differences=無法顯示差異: {0}
message.title.show.differences=顯示差異
action.name.refresh=刷新
action.description.refresh=刷新檔案歷史記錄
action.name.get.file.content.from.repository=獲取
action.description.get.file.content.from.repository=從版本庫獲取版本
acton.name.get.revision=獲取修訂
action.name.create.patch=創建補丁…
action.description.create.patch.for.selected.revisions=為所選修訂創建補丁
message.title.get.version=獲取版本
message.text.cannot.load.revision=無法載入修訂: {0}
message.text.cannot.save.content=無法儲存內容: {0}
message.title.get.revision.content=獲取修訂內容
action.name.for.file.get.version={0}: 獲取版本 {1}
column.name.revision.list.date=日期
checkbox.show.changed.revisions.only=僅變更
progress.text.loading.patch.base.revision=正在載入補丁基礎修訂
diff.content.title.revision.number=修訂 {0}
command.name.open.error.message.view=打開訊息檢視
message.text.cannot.edit.file=無法編輯檔案: {0}
message.title.edit.files=編輯檔案
vcs.console.toolwindow.display.name=控制台
handle.ro.file.status.type.using.vcs=使用 {0}
message.text.file.is.up.to.date=檔案處於最新狀態
message.text.all.files.are.up.to.date=所有檔案都處於最新狀態
progress.text.synchronizing.files=正在同步檔案…
progress.text.updating.done=更新完成
progress.text.updating.canceled=更新已取消
message.title.vcs.update.errors={0}錯誤
update.tree.node.size.statistics={0,choice, 0#無條目|1#1 個條目|2#{0, number} 個條目}
toolwindow.title.update.project=更新專案({0})
action.name.group.by.packages=按軟體套件分組
message.text.cannot.save.settings=無法執行操作: {0}
action.name.check.status=檢查狀態(_K)
action.name.check.scope.status=檢查{0}狀態(_K)
action.display.name.check.scope.status=檢查{0}狀態
action.name.update=更新(_U)
action.display.name.update=更新
action.name.update.scope=更新{0}(_U)
action.display.name.update.scope=更新{0}
action.name.integrate=合併 (_G)
action.name.integrate.scope=合併 {0}(_G)
action.display.name.integrate.scope=集成{0}
update.files.scope.name=檔案
update.directory.scope.name=目錄
update.file.scope.name=檔案
update.directories.scope.name=目錄
update.project.scope.name=專案
dialog.title.changes.browser=變更瀏覽器
code.smells.error.messages.tab.name=程式碼分析
code.smells.error.indexing=現在無法進行程式碼分析
code.smells.error.indexing.message={0} 在背景更新索引時，無法執行程式碼分析。\\\\n\\\\
您可以在不執行檢查的情況下提交更改，也可以等到索引建立後再提交。
searching.for.code.smells.freezing.process=在簽入程式碼分析之前
checking.code.smells.progress.title=正在執行程式碼分析
before.commit.files.contain.code.smells.edit.them.confirm.text={0} 個檔案有問題。\\\\n\\\\
{1,choice, 0#無錯誤|1#1 個錯誤|2#{1} 個錯誤}，{2,choice, 0#無警告|1#1 個警告|2#{2} 個警告} \\\\n\\\\
要查看它們嗎?
before.commit.file.contains.code.smells.edit.them.confirm.text=檔案 {0} 有問題。\\\\n\\\\
{1,choice, 0#無錯誤|1#1 個錯誤|2#{1} 個錯誤}和{2,choice, 0#無警告|1#1 個警告|2#{2} 個警告}。\\\\n\\\\
要查看它們嗎?
code.smells.review.button=審查(&R)
todo.in.new.review.button=審查(&R)
before.checkin.standard.options.check.smells=分析程式碼(&A)
before.checkin.options.check.smells.profile=使用 ''{0}'' 配置檔案分析程式碼(&A)
before.checkin.options.check.smells.choose.profile=選擇配置檔案
before.checkin.waiting.for.smart.mode=正在等待智能模式…
before.checkin.new.todo.check=檢查 TODO ({0})
before.checkin.cleanup.code=清理(&L)
# Changes view
changes.nodetitle.unversioned.files=未進行版本管理的檔案
changes.nodetitle.locally.deleted.files=本地已刪除的檔案
changes.nodetitle.modified.without.editing=已修改，但未簽出的檔案
changes.nodetitle.ignored.files=已忽略的檔案
changes.nodetitle.locked.folders=鎖定的工作副本資料夾
changes.nodetitle.locked.folders.tooltip=某些資料夾已被鎖定；不允許對它們進行 VCS 操作。應執行清理。
changes.nodetitle.logicallt.locked.folders=明確鎖定的檔案
changes.nodetitle.switched.files=已切換的檔案
changes.nodetitle.switched.roots=根開關
changes.nodetitle.filter.pending=未篩選
changes.nodetitle.filtered.out=已篩選
changes.nodetitle.updating=正在更新…
changes.nodetitle.have.outdated.files=某些檔案在伺服器上已被更改
changes.nodetitle.empty.changelist.name=<空名稱>
change.nodetitle.change.is.outdated=檔案在伺服器上已被更改
changes.nodetitle.changecount={0,choice, 0#無檔案|1#1 個檔案|2#{0} 個檔案}
changes.nodetitle.directory.changecount={0,choice, 0#無目錄|1#1 個目錄|2#{0} 個目錄}
changes.nodetitle.directory.file.changecount={0,choice, 0#無目錄|1#1 個目錄|2#{0} 個目錄}，{1,choice, 0#無檔案|1#1 個檔案|2#{1} 個檔案}
changes.nodetitle.merge.conflicts=合併衝突
changes.nodetitle.merge.conflicts.resolve.link.label=解決
changes.default.changelist.name=變更
changes.action.show.ignored.text=顯示忽略的檔案
changes.action.show.ignored.description=顯示忽略的檔案
changes.dialog.newchangelist.title=新建變更列表
changes.dialog.editchangelist.title=編輯變更列表
changes.removechangelist.warning.text=確定要移除變更列表 ''{0}'' 嗎?\\\\n\\\\
所有變更都將移至活動變更列表。
changes.removechangelist.multiple.warning.text=確定要刪除{0}個變更列表？\\\\n\\\\
所有的變更將會移動到活動的變更列表中。
changes.removechangelist.warning.title=刪除變更列表
changes.removechangelist.all.lists.warning.text=確定要移除{0}個變更列表嗎?\\\\n\\\\
所有變更都將移動到新的預設變更列表。
scope.name.changelist.all.changed.files=所有更改的檔案
commit.dialog.no.changes.detected.text=未檢測到變更
commit.dialog.no.changes.detected.title=沒有要提交的內容
commit.dialog.title=提交變更
commit.dialog.default.commit.operation.name=Comm&it
commit.dialog.include.action.name=包含到提交裡(&I)
commit.dialog.failed.commit.template=提交失敗: {0}
commit.dialog.completed.successfully=已成功完成
commit.dialog.refresh.files=正在同步檔案…
commit.dialog.rejected.commit.template=拒絕提交: {0}
commit.dialog.changelist.label=變更列表(&T):
commit.dialog.partial.commit.warning.title=不支持部分提交
commit.dialog.partial.commit.warning.body=不支持 ''{0}'' 的部分提交。\\\\n\\\\
所選檔案中的所有變更都將提交。
commit.dialog.configurable=提交
change.list.manager.wait.lists.synchronization.modal={1, choice, 0#正在等待 |1#{0}: }本地變更刷新
change.list.manager.wait.lists.synchronization.background={1, choice, 0#正在等待 |1#{0}: }本地變更刷新
commit.wait.util.synched.text=正在執行 VCS 刷新…
edit.changelist.name=名稱(&N):
edit.changelist.description=註釋(&C):
changes.commit.partial.offer.to.move.text=提交時，您從活動變更列表中排除了某些檔案。\\\\n\\\\
要將剩餘變更移至其他變更列表嗎?
changes.commit.partial.offer.to.move.title=部分提交活動變更列表
checkbox.changelist.move.offer=建議將未提交的變更移至其他變更列表(&T)
checkbox.show.dirty.recursively=在專案樹中高亮顯示包含已修改檔案的目錄

commit.legend.modified=已修改
commit.legend.new=已添加
commit.legend.deleted=已刪除

commit.editor.diff.preview.title=提交: {0}
commit.editor.diff.preview.empty.title=提交

save.committing.files.confirmation.title=在提交期間儲存檔案
save.committing.files.confirmation.text=當前正在將以下{0,choice,1#檔案|2#檔案}提交到 VCS。立即儲存可能會導致提交的資料不一致。\\\\n\\\\
{1}\\\\n\\\\
立即儲存{0,choice,1#檔案|2#檔案}?
save.committing.files.confirmation.ok=立即儲存
save.committing.files.confirmation.cancel=延遲儲存

amend.commit.different.committer.warning=修正後提交的提交者與預設設定不同
amend.commit.load.details.task.title=正在載入提交詳細資訊
amend.commit.load.message.task.title=正在載入提交訊息
amend.commit.load.message.error.title=提交訊息未載入
amend.commit.load.message.error.text=無法載入待修正提交的提交訊息。
checkbox.amend=修正(_M)
label.by.author=作者

non.modal.commit.promoter.text=新的非強制回應提交介面可用。從工具視窗提交並在編輯器中查看差異。
non.modal.commit.promoter.use.non.modal.action.text=切換到工具視窗
non.modal.commit.promoter.dont.show.again.action.text=不再顯示
switch.to.commit.dialog.hint.text=要切換回“提交”對話框，請使用齒輪圖標下的選單

error.executing.commit=執行 ''{0}'' 時出錯: {1}
changes.action.rollback.title={0}變更
changes.action.rollback.custom.title={0}變更
changes.action.rollback.nothing=沒要有{0}的內容
changes.dialog.editchangelist.error.already.exists=名為 ''{0}'' 的變更列表已存在
error.adding.files.prompt=添加檔案時發生以下問題:
error.adding.files.title=無法添加檔案
column.name.revision.list.committer=使用者
column.name.revision.list.number=數字
column.name.revision.list.description=描述
browse.changes.nothing.found=未找到與條件符合的任何變更
browse.changes.nothing.found.title=未找到任何變更
browse.changes.progress.title=正在搜尋變更
browse.changes.error.title=無法顯示變更
browse.changes.error.message=存取 VCS 時發生問題: {0}
button.search.again=再次搜尋
browse.changes.filter.title=指定搜尋條件
changes.checkbox.delete.locally.added.files=刪除添加的檔案的本地副本(&D)
changes.action.rollback.text=回滾
patch.apply.file.name.field=補丁文件名(&P):
create.patch.commit.action.title=創建補丁
create.patch.commit.action.progress=正在創建補丁…
create.patch.error.title=創建補丁時出錯: {0}
create.patch.settings.dialog.title=補丁檔案設定
button.apply.patch=套用補丁
patch.apply.dialog.title=套用補丁
patch.apply.notification.title=套用補丁
filetype.patch.description=補丁
filetype.patch.display.name=補丁
patch.apply.conflict.for.title={0}的補丁衝突
patch.apply.conflict.title=補丁衝突
patch.apply.conflict.local.version=本地版本
patch.apply.conflict.merged.version=合併結果
patch.apply.conflict.patched.version=補丁版本
patch.apply.conflict.patched.somehow.version=結果
patch.apply.conflict.patch=補丁
patch.apply.select.title=選擇補丁檔案
patch.apply.before.patch.label.text=補丁前
patch.apply.after.patch.label.text=補丁後
patch.apply.aborted.title=套用補丁中止
patch.apply.aborted.message=“套用補丁”操作期間更改的所有檔案已被回滾
patch.apply.rollback.failed.title=回滾失敗
patch.apply.rollback.failed.message=嘗試使用“本地歷史記錄”對話框手動執行還原。
patch.apply.rollback.progress.title=回滾套用的變更…
patch.apply.rollback.progress=回滾套用的變更…
patch.apply.outside.content.root.message=在內容根外部找到補丁檔案: {0}
patch.apply.overwrite.existing.title=覆蓋現有檔案
patch.apply.overwrite.existing.files.prompt=以下檔案應通過補丁創建，但它們已經存在。\\\\n\\\\
要覆蓋它們嗎?
patch.apply.overwrite.existing.file.prompt=以下檔案應通過補丁創建，但它已經存在。\\\\n\\\\
要覆蓋嗎?\\\\n\\\\
{0}
patch.apply.file.type.directory.error=無法從補丁套用 {0} 檔案的內容，因為它是目錄。
patch.apply.file.type.undefined.error=無法從補丁套用 {0} 檔案的內容，因為它的類型未定義。
patch.apply.file.type.binary.error=無法從補丁套用 {0} 檔案，因為它是二進制檔案。
patch.apply.incorrectly.processed.warning=VCS 可能未正確處理以下{0, choice, 1#檔案|2#檔案}。\\\\n\\\\
請手動檢查{0, choice, 1#它|2#它們}: {1}
patch.apply.rollback.prompt=無法套用下面的{0, choice, 0#|1#檔案|2#檔案}。<br>是否要回滾套用的所有內容?
patch.apply.rollback.will.not.affect.binaries.info=回滾不會影響二進制檔案
patch.apply.partly.failed.title=補丁部分套用失敗
patch.apply.rollback.action=回滾
patch.apply.new.files.warning=套用補丁創建新檔案報錯
patch.apply.cannot.apply.now=現在無法套用補丁
patch.apply.abort.action=中止…
patch.apply.abort.and.rollback.prompt=中止並回滾套用補丁還是跳過此檔案?
patch.apply.abort.title=中止補丁
patch.apply.abort.and.rollback.action=中止並回滾(_A)
patch.apply.skip.action=跳過(_S)
patch.apply.continue.resolve.action=繼續解析
patch.apply.can.t.find.patch.file.warning=無法找到補丁檔案 {0}
patch.apply.not.patch.type.file.error=所選檔案 {0} 不是補丁類型檔案
patch.apply.can.not.apply.additional.info.error=無法套用附加補丁資訊: {0}
patch.apply.missing.base.file.label=缺少基
patch.apply.change.directory.paths.group=更改目錄路徑
patch.apply.cannot.read.patch=無法讀取補丁 {0}: {1}
patch.apply.map.base.directory.action=映射基目錄…
patch.apply.select.base.for.a.path.message=為路徑選擇基
path.apply.select.base.directory.for.a.path.popup=為路徑選擇基目錄
patch.apply.new.base.detected.node.description=檢測到新基
patch.apply.select.missing.base.link=選擇缺少的基
patch.apply.modified.status=已修改
patch.apply.deleted.status=已刪除
patch.apply.added.status=已添加
patch.apply.stripped.description=\\\\ 去除的{0}
patch.apply.old.new.base.info=更改前: {0} (基目錄: {1})<br/>更改後: {2} (基目錄: {3})
patch.apply.select.base.title=選擇{0, choice, 0#目錄|1#檔案}基
patch.apply.analyze.from.clipboard.on.the.fly.checkbox=實時分析和套用剪貼簿中的補丁
patch.apply.wrong.base.and.can.t.be.applied.warning={0} 的補丁的基錯誤，無法正確套用
patch.apply.already.exists.overwrite.prompt=檔案 {0} ({1}) 已存在。\\\\n\\\\
要覆蓋它嗎?
patch.apply.bad.diff.to.title=將補丁應用於 {0} 的結果
patch.apply.bad.diff.title=補丁套用的結果
patch.apply.already.applied.status=已套用
patch.apply.automatically.applied.status=已自動套用
patch.apply.not.applied.status=未套用
patch.apply.somehow.diff.name=以某種方式套用補丁
patch.apply.changes.in.patch.resolve=在補丁解析中{0}
patch.apply.display.local.content.was.modified.error=無法顯示補丁套用者 - 本地內容已修改
patch.content.viewer.name=補丁內容查看器
patch.apply.marker.renderer=標記: {0}
patch.apply.syntax.line=\\\\ (行: {0})
patch.apply.hunk.warning=無法檢測到下列項的區塊修改行: -{0},{1} +{2},{3}
patch.binary.decoder.content.error=解碼的二進制內容{0,choice,0#少於|1#多於}預期
patch.binary.decoder.line.error=無法編碼二進制檔案補丁: 行大小錯誤
patch.binary.decoder.char.error=無法解碼二進制檔案補丁: 字符大小符號錯誤
patch.binary.decoder.decompress.error=無法解碼二進制檔案補丁: 無法解壓縮資料
patch.simple.apply.base.line.error=意外的基行: 應為 - {0}，實際為 - {1}
patch.simple.apply.base.line.total.error=意外的基行: 總行數為 - {0}，實際為 - {1}
patch.simple.apply.hunk.base.start.error=意外的區塊基開始: 應為 - {0}，實際為 - {1}
patch.simple.apply.hunk.patched.start.error=意外的區塊補丁開始: 應為 - {0}，實際為 - {1}
patch.simple.apply.hunk.base.end.error=意外的區塊基結束: 總行數為 - {0}，區塊結束為 - {1}
patch.simple.apply.hunk.base.body.error=意外的區塊基主體: 應為 - {0}，實際為 - {1}
patch.simple.apply.hunk.patched.body.error=意外的區塊補丁主體: 應為 - {0}，實際為 - {1}
patch.simple.apply.hunk.content.error=意外的區塊內容: 應為 - {0}，實際為 - {1}
patch.copied.to.clipboard=補丁已複製到剪貼簿
patch.creation.failed=補丁創建失敗
patch.creation.save.patch.file.title=儲存補丁檔案
patch.creation.can.not.write.patch.error=無法將補丁寫入指定檔案: {0}
patch.creation.save.to.title=將補丁儲存到
patch.creation.save.to.file.button=將補丁儲存到檔案
patch.creation.base.path.field=基路徑(&B):
patch.creation.wrong.base.path.for.changes.error=基路徑不包含所有所選變更(使用 {0})
patch.creation.base.dir.does.not.exist.error=基目錄不存在
patch.creation.empty.base.path.error=基路徑不能為空!
patch.creation.name.too.long.error=檔案路徑不應過長。
patch.import.to.shelf.progress.title=將補丁匯入到 Shelf
patch.import.to.shelf.tab=將補丁匯入到 Shelf
patch.import.no.patches.found.warning=未找到補丁
patch.import.additional.info.error=無法匯入附加補丁資訊: {0}
action.import.to.shelf=匯入到 Shelf
shelve.changes.action=托管更改(_S)
shelve.changes.progress.title=正在擱置更改
shelve.changes.progress.text=正在擱置變更…
shelve.deletion.title=Shelf 刪除
shelve.file.is.locked.for.editing.message=在擱置期間檔案已鎖定，無法編輯
shelve.remove.successfully.applied.files.checkbox=從 Shelf 移除成功套用的檔案
shelve.clean.unshelved.changelists.title=清理取消擱置的變更列表
shelve.clean.changelists.older.than.one.button=超過 1
shelve.clean.changelists.all.button=所有
shelve.clean.timeperiod.week=周
shelve.clean.timeperiod.month=月
shelve.clean.timeperiod.year=年
shelve.delete.already.unshelved.label=刪除已擱置的變更列表:
shelve.base.content.not.found.or.not.applicable.error=基內容未找到或不適用。顯示與本地版本的差異
shelve.shelved.version=擱置的版本
shelve.import.one.patch.file.prompt=找到一個補丁檔案({0})。\\\\n\\\\
繼續匯入?
shelve.import.patches.prompt=找到 {0} 個補丁檔案。\\\\n\\\\
繼續匯入?
shelve.hide.already.unshelved.action=隱藏已取消擱置變更
shelve.show.already.unshelved.action=顯示已取消擱置變更
shelve.delete.files.successful.message={0,choice, 1#1 個檔案|2#{0} 個檔案}
shelve.delete.changelists.message={0,choice, 1#1 個變更列表|2#{0} 個變更列表} {1}
shelve.delete.successful.message=已成功刪除 {0}{1,choice, 0#|1# 和 }{2}
shelve.undo.deletion=撤消 Shelf 刪除
shelve.recently.deleted.node=最近刪除項
shelve.changelist.not.found=未找到擱置的變更列表 {0}
shelve.default.path.rendering=<專案根>
shelve.copying.shelves.to.progress=正在將擱置複製到新目錄…
shelve.moving.failed.prompt=Shelf 移動失敗。<br/>要使用新的 Shelf 目錄路徑還是將其還原為上一個路徑?
shelve.error.title=Shelf 錯誤
shelve.use.new.directory.button=使用新路徑(&U)
shelve.revert.moving.button=還原(&R)
shelve.import.to.progress=正在處理 
shelve.delete.files.from.changelist.error=無法從 {0} 刪除檔案
shelve.failed.title=擱置失敗
shelve.failed.message={0,choice,1#變更列表|2#變更列表} [{1}] 的變更擱置失敗
shelve.successful.message=已成功擱置變更
unshelve.loading.patch.error=無法載入補丁: {0}
unshelve.changes.action=取消托管更改
patch.apply.already.applied=指定補丁的所有變更均已包含在程式碼中
patch.apply.partially.applied=指定補丁的某些變更已被跳過，因為它們已包含在程式碼中
patch.apply.success.applied.text=已成功套用補丁
patch.apply.command=套用補丁
patch.apply.progress.title=正在套用補丁…
shelve.changes.restore.error=無法完全還原{0, choice, 1#擱置的變更列表|2# {0} 個擱置的變更列表}，因為某些檔案已被永久刪除
create.patch.success.confirmation=已成功創建補丁 {0}
shelve.changes.only.directories=所選變更僅影響目錄，不影響檔案，因此無法擱置它們
shelve.editor.diff.preview.title=擱置: {0}
stash.changes.message=在{0}之前未提交的更改
stash.changes.message.with.date=在進行{0}之前於 {1} 取消提交了變更
edit.errors=編輯錯誤
rollback.modified.without.editing.confirm.single=要將變更{0}到{1}嗎?
rollback.modified.without.editing.confirm.multiple=要將變更{0}到 {1} 個所選檔案嗎?
error.updating.changes=更新變更時出錯: {0}
no.ignored.files=沒有忽略的檔案
ignored.file.tab.title=已忽略的檔案
ignored.file.general.settings.title=常規設定
ignored.file.manage.policy.label=忽略檔案管理策略
ignored.file.manage.always.ask.option=始終詢問
ignored.file.manage.all.projects.option=為所有專案管理
ignored.file.manage.this.project.option=僅為此專案管理
ignored.file.not.manage.this.project.option=不只為此專案管理
ignored.file.not.manage.option=關閉套用範圍
ignored.file.excluded.settings.title=排除目錄管理策略
ignored.file.excluded.to.ignored.label=將排除目錄添加到忽略檔案
ignored.file.ignored.to.excluded.label=將忽略目錄標記為已排除
ignored.file.manage.view=查看
ignored.file.manage.with.files.message={0} 可以自動將經常被忽略的檔案添加到 {1}。
ignored.file.manage.message={0} 可以自動將經常被忽略的檔案添加到 {1}。
ignored.file.manage.this.project=在此專案中
ignored.file.manage.all.project=在所有專案中
ignored.file.manage.notmanage=不添加
ignored.file.manage.view.dialog.title=將檔案添加到忽略
ignored.file.manage.view.dialog.ignore.action=忽略(&I)
ignoring.files.progress.title=正在忽略檔案…
browse.changes.content.title={0}下的變更
browse.changes.no.filter.prompt=尚未指定任何篩選條件。確定要查看專案的整個歷史記錄嗎?
browse.changes.title=瀏覽變更
browse.changes.show.all.button=顯示所有變更
browse.changes.show.recent.button=顯示最近的變更
new.changelist.make.active.checkbox=設為活動(&A)
new.changelist.new.label=新建
move.to.another.changelist.nothing.selected.notification=沒有選擇任何可以移動的專案
composite.change.provider.include.vcs.checkbox=包含{0}中的變更
shelf.tab=擱置
directory.mapping.remove.title=編輯 VCS 目錄映射
directory.mapping.add.title=添加 VCS 目錄映射
settings.vcs.mapping.browser.select.directory.title=選擇目錄
settings.vcs.mapping.browser.select.directory.description=選擇要映射到 VCS 的目錄
settings.vcs.mapping.status.looking.for.vcs.administrative.area=正在尋找 VCS 管理區域
settings.vcs.mapping.invalid.vcs.options.error=無效的 VCS 選項: {0}
settings.vcs.mapping.project.description=所有模組的內容根，以及專案基目錄的所有直接後代
settings.vcs.mapping.project.description.with.idea.directory=所有模組的內容根、專案基目錄的所有直接後代以及 {0} 目錄內容
unshelve.changelist.chooser.title=取消擱置變更列表的變更
revert.changes.changelist.chooser.title=選擇目標變更列表
retrieving.annotations=正在載入註解
multiple.file.merge.title=衝突
multiple.file.merge.accept.yours=接受您的變更(&Y)
multiple.file.merge.accept.theirs=接受他們的(&T)
multiple.file.merge.merge=合併(&M)…
multiple.file.merge.column.name=名稱
multiple.file.merge.request.title=合併 {0} 的修訂
multiple.file.merge.loading.progress.title=正在載入合併修訂…
multiple.file.merge.group.by.directory.checkbox=按目錄對檔案分組
unknown.vcs.presentation=<未知 VCS> ({0})
show.diff.progress.title=正在載入內容
# suppress inspection \\"UnusedProperty\\": used by 3-party plugins
show.diff.progress.title.detailed=正在載入 {0} 的內容
new.changelist.duplicate.name.error=具有該名稱的變更列表已存在
new.changelist.empty.name.error=無法使用空名稱創建新的變更列表
# suppress inspection \\"UnusedProperty\\": used by 3-party plugins
browse.changes.action=瀏覽變更
# suppress inspection \\"UnusedProperty\\": used by 3-party plugins
browse.changes.scope=影響 {0} 的變更
rollback.modified.without.checkout.error.tab={0}未簽出時進行了修改
annotate.action.name=註解
annotate.action.description=註解檔案
operation.name.annotate=註解
changes.remove.active.prompt=選擇應將變更移至其中的變更列表:
changes.remove.active.empty.prompt=選擇要設為活動的變更列表:
changes.remove.active.title=刪除活動變更列表
create.patch.loading.content.progress=正在載入內容修訂
create.patch.reverse.checkbox=反轉補丁(&R)
create.patch.file.path=到檔案(&P):
create.patch.to.clipboard=到剪貼簿(&C)
create.patch.encoding=編碼(&E):
committed.changes.refresh.progress=正在刷新 VCS 歷史記錄
cache.settings.dialog.title=VCS 歷史記錄快取設定
changes.browser.details.marker=更多…
changelist.details.title=變更列表詳細資訊
date.group.title=日期
date.group.today=今天
date.group.last.week=過去一周
user.group.title=使用者
filter.structure.name=結構
filter.none.name=無
issue.link.issue.column=問題
issue.link.link.column=鏈接
issue.link.add.title=添加問題導航鏈接
issue.link.edit.title=編輯問題導航鏈接
issue.link.delete.prompt=刪除所選導航鏈接?
issue.link.delete.title=刪除問題導航鏈接
issue.link.no.patterns=未配置模式
issue.action.add.jira.issue.navigation.pattern.title=添加 JIRA 問題導航模式
issue.action.enter.jira.installation.url.label=輸入 JIRA 安裝 URL:
issue.action.add.youtrack.issue.navigation.pattern.title=添加 YouTrack 問題導航模式
issue.action.enter.youtrack.installation.url.label=輸入 YouTrack 安裝 URL:
add.issue.dialog.invalid.regular.expression=無效的正則表達式: {0}
add.issue.dialog.issue.link.label=問題鏈接:
add.issue.dialog.issue.id.label=問題 ID:
add.issue.dialog.issue.example.border.title=範例
add.issue.dialog.issue.link.replacement.expression=問題鏈接 (取代表達式):
add.issue.dialog.issue.id.regular.expression=問題 ID (正則表達式):
add.issue.dialog.issue.no.match=<無符合>
committed.changes.empty.comment=<無註釋>
committed.changes.filter.all=所有
committed.changes.filter.none=<無>
committed.changes.partial.list=[部分]
update.info.loading.changelists=正在載入變更列表…
update.info.group.by.changelist=按變更列表分組
update.info.click.status.text.prefix=點擊
update.info.to.initialize.status.text.suffix=以初始化版本庫變更快取
update.info.refresh.link.status.text=刷新
outdated.version.show.diff.action=顯示差異
outdated.version.update.project.action=更新專案
# 0 - author, 1 - pretty date, 2 - commit message, 3 - deletion/modification
outdated.version.text=過時的版本。{0} 在 {1} {3,choice,0#修改|1#刪除}了以下訊息: {2}
current.version.text={4}<br/><br/>當前版本為 {3}。<br/>修改者為 {0}<br/>{1}<br/>{2}
committed.changes.filter.title=篩選依據
committed.changes.group.title=分組依據
committed.changes.regex.title=正則表達式(&G)
changelist.details.committed.format=由 {0} {1} 提交
incoming.changes.indicator.tooltip={0} 個可用的傳入變更列表
# suppress inspection \\"UnusedProperty\\": used by 3-party plugins
committed.changes.incorrect.regex.message=篩選器中使用的正則表達式無效
committed.changes.empty.message=版本庫沒有提交的變更
committed.changes.not.loaded.message=按“刷新”按鈕以載入版本庫變更
incoming.changes.not.loaded.message=按“刷新”按鈕以載入傳入的變更
incoming.changes.empty.message=沒有傳入的變更

show.history.action.name.template=顯示 {0} 的歷史記錄(_F)
show.history.dialog.title.template={0} 的歷史記錄
action.name.show.history.for.selection=選區
action.name.show.history.for.class=類
action.name.show.history.for.field=欄位
action.name.show.history.for.method=方法
action.name.show.history.for.function=函數
action.name.show.history.for.code.block=程式碼塊
action.name.show.history.for.statement=語句
open.repository.version.text=打開版本庫版本
open.repository.version.description=在編輯器中打開檔案的所選修訂
edit.source.action.text=編輯源
local.history.update.from.vcs=從 VCS 更新
create.changelist.on.failed.commit=在提交失敗時創建變更列表:
commit.failed.confirm.prompt=要將提交失敗的檔案移至單獨的變更列表嗎?
commit.failed.confirm.title=提交失敗
unshelve.changes.dialog.title=取消擱置變更
unshelve.changes.progress.title=正在取消擱置變更…
shelved.version.name=擱置的版本
patched.version.name=補丁版本
local.version.title=本地版本
change.file.renamed.from.text=- 已從 {0} 重命名
change.file.moved.from.text=- 已從 {0} 移動
change.file.copied.from.text=- 已從 {0} 複製
change.file.replaced.text=- 已取代
change.file.renamed.to.text=- 已重命名為 {0}
change.file.moved.to.text=- 已移至 {0}
cannot.create.directory.for.patch=無法創建檔案: {0}. {1}
cannot.find.file.to.patch=找不到要套用補丁的檔案: {0}
cannot.apply.file.already.exists=無法將補丁套用到檔案 {0}: 它已存在。
change.lists.manager.add.unversioned=添加未進行版本管理的檔案
vcs.shelf.action.restore.text=恢復
vcs.shelf.action.restore.description=恢復最近刪除的{0, choice, 1#變更列表|2#變更列表}
vcs.shelf.move.text=將擱置變更移動到新位置
vcs.shelf.store.base.content=擱置分布式版本控制系統下檔案的基本修訂版本
vcs.shelving.changes=正在擱置變更…
vcs.unshelving.changes=正在取消擱置變更…
vcs.unshelving.conflict.left=您未提交的變更
vcs.unshelving.conflict.right=遠端變更
action.enable.version.control.integration.text=啟用版本控制集成(_E)…
dialog.enable.version.control.integration.title=啟用版本控制集成
dialog.enable.version.control.integration.select.vcs.label.text=選擇要與 {0} 關聯的版本控制系統:
dialog.enable.version.control.integration.hint.text=可在以下位置配置版本控制設定 
confirmation.title.add.file.to=將檔案添加到 {0}?
confirmation.title.add.files.to=將檔案添加到 {0}?
confirmation.title.add.ignored.single.file=確認添加忽略的檔案
confirmation.title.add.ignored.single.directory=確認添加忽略的目錄
confirmation.message.add.ignored.single.file=添加忽略的檔案?
confirmation.message.add.ignored.single.directory=添加忽略的目錄?
confirmation.title.add.ignored.files.or.dirs=確認添加忽略檔案和目錄
waiting.changelists.update.for.show.commit.dialog.message=提交
rolling.back.file=正在回滾{0}
annotation.original.revision.text=修訂: {0}
annotation.switch.to.original.text=隱藏合併原始碼
annotation.switch.to.merged.text=顯示合併原始碼
switch.to.changelist=切換到變更列表(''{0}'')(&T)
move.to.changelist=將變更移至活動變更列表(''{0}'')(&M)
vcs.config.track.changed.on.server=檢查與伺服器衝突的時間間隔
vcs.quicklist.popup.title=VCS 操作
action.Vcs.Toolbar.QuickListPopupAction.text=VCS 操作
options.check.changed.on.server.title=“在伺服器上已更改”衝突
line.annotation.aspect.author=作者
line.annotation.aspect.date=日期
line.annotation.aspect.revision=修訂
annotation.commit.number=提交編號
annotation.wrong.line.number.notification.text=<html>由 {0} 註解的行數與檔案中的行數不相等。請檢查檔案編碼和行分隔符。</html>
lst.inactive.ranges.damaged.notification=部分變更已移動到活動變更列表
todo.handler.only.skipped=<html><body>TODO 檢查已經跳過 {0,choice, 0#|1#單個檔案|2#{0}多個檔案}.<br/>沒有新的,編輯,或位於片段的 TODO 項改變發現。</body></html>
todo.handler.only.added=<html><body>發現{0,choice, 0#|1#一|2#{0}}個已被添加或編輯的 TODO {0,choice, 0#|1#專案|2#專案}。<br/>您是否想查看{0,choice,1#它|2#它們}?<br/>{1,choice, 0#|1#1個檔案被跳過。|2#{1} 個檔案被跳過。}</body></html>
todo.handler.only.in.changed=<html><body>{0,choice, 1#一|2#{0}}個 TODO {0,choice, 1#項|2#項} 在已改變的片段中找到。<br/>您是否需要查閱{0,choice,1#它|2#它們}?<br/>{1,choice, 0#|1#一個檔案被跳過|2#{1} 個檔案被跳過。}</body></html>
todo.handler.only.both=<html><body>{0, choice, 1#一|2#{0}}個添加/編輯到 TODO {0,choice, 1#專案|2#專案},<br/>並且 {1, choice, 1#一個專案|2#{1}專案} 未在變更的片段中找到。<br/>您是否項查閱它們?<br/>{2,choice, 0#|1#一個檔案被跳過。|2#{2}個檔案被跳過。}</body></html>
label.todo.items.found={0} 個 TODO

paths.affected.in.revision={0} 中的變更

executable.select.label={0} 可執行檔案路徑(&P):
executable.select.title=選擇可執行檔案
executable.test=測試
executable.project.override=僅為當前專案設定此路徑
executable.project.override.reset.title=專案可執行檔案
executable.project.override.reset.message=為此專案配置的可執行檔案路徑既可以設為所有專案的全域路徑，也可以還原為當前全域可執行檔案
executable.project.override.reset.globalize=設為全域
executable.project.override.reset.revert=還原

project.configuration.files.add.notification.message=專案配置檔案可以添加到 {0}
project.configuration.files.add.notification.action.view=查看檔案
project.configuration.files.add.notification.action.add=始終添加
project.configuration.files.add.notification.action.mute=不再詢問
project.configuration.files.view.dialog.title=將檔案添加到 {0}

external.files.add.notification.message=外部添加的檔案可以添加到 {0}
external.files.add.notification.action.view=查看檔案
external.files.add.notification.action.add=始終添加
external.files.add.notification.action.mute=不再詢問
external.files.add.view.dialog.title=將檔案添加到 {0}

ignore.to.exclude.notification.message=部分忽略的目錄未從索引和搜尋中排除
ignore.to.exclude.notification.notice=<html><b>注</b>: 建議在排除之前重新檢查目錄內容。一些目錄可能包含不應排除的項。</html>
ignore.to.exclude.notification.action.view=查看目錄
ignore.to.exclude.notification.action.mute=不再詢問
ignore.to.exclude.notification.action.details=了解更多
ignore.to.exclude.view.dialog.title=排除目錄
ignore.to.exclude.view.dialog.exclude.action=排除(&E)
ignore.to.exclude.no.directories.found=未找到要排除的目錄

# suppress inspection \\"UnusedProperty\\": dynamic property key
ignoreTokenType./=<斜杠>
# suppress inspection \\"UnusedProperty\\": dynamic property key
ignoreTokenType.BRACKET_LEFT=<左括號>
# suppress inspection \\"UnusedProperty\\": dynamic property key
ignoreTokenType.BRACKET_RIGHT=<右括號>
# suppress inspection \\"UnusedProperty\\": dynamic property key
ignoreTokenType.COMMENT=<註釋>
# suppress inspection \\"UnusedProperty\\": dynamic property key
ignoreTokenType.CRLF=<空行>
# suppress inspection \\"UnusedProperty\\": dynamic property key
ignoreTokenType.HEADER=<標題>
# suppress inspection \\"UnusedProperty\\": dynamic property key
ignoreTokenType.SECTION=<部分>
# suppress inspection \\"UnusedProperty\\": dynamic property key
ignoreTokenType.VALUE=<值>
# suppress inspection \\"UnusedProperty\\": dynamic property key
# suppress inspection \\"WrongPropertyKeyValueDelimiter\\"
ignoreTokenType.syntax:=<語法>

ignore.codeInspection.group=版本控制
ignore.codeInspection.duplicateEntry=忽略檔案重複項
ignore.codeInspection.duplicateEntry.message=<code>#ref</code> 模式不止定義一次 #loc
ignore.quick.fix.remove.entry=移除模式

vcs.add.to.ignore.file.action.group.text=添加到 {0}
vcs.add.to.ignore.file.action.group.description=將所選檔案添加到 {0}
vcs.add.to.ignore.file.create.ignore.file.confirmation.title=創建 {0}
vcs.add.to.ignore.file.create.ignore.file.confirmation.message=在 {1} 中創建 {0} 檔案?

#Annotate actions
annotate.action.view.group.text=檢視

prefer.commit.timestamp.action.text=顯示提交時間戳
prefer.commit.timestamp.action.description=顯示提交變更的時間，而不是創建時間。
configurable.ChangelistConflictConfigurable.display.name=變更列表
configurable.VcsDirectoryConfigurationPanel.display.name=目錄映射
configurable.VcsGeneralConfigurationConfigurable.display.name=確認
configurable.IssueNavigationConfigurationPanel.display.name=問題導航
configurable.VcsContentAnnotationConfigurable.display.name=顯示最近更改
vcs.operations.popup=VCS 操作彈出視窗
vcs.local.changes.toolbar=VCS 本地變更工具欄
vcs.log.changes.browser.toolbar=VCS 日誌更改瀏覽器工具欄
settings.checkbox.limit.history.to=將歷史記錄限制為
settings.checkbox.rows=行
settings.limit.history.to.n.rows.label=將歷史記錄限制為 {0} 行
settings.checkbox.show.changed.in.last=高亮顯示以下時間內更改的檔案:
settings.checkbox.measure.days=天
settings.show.changed.in.last.n.days.label=顯示過去 {0} 天的變更
settings.check.every.minutes=分鐘的更改項
settings.show.unversioned.files=顯示未進行版本管理的檔案
settings.commit.message.inspections=提交訊息檢查
inspection.SubjectBodySeparationInspection.display.name=主題與正文之間的空白行
inspection.BodyLimitInspection.display.name=限制正文行
inspection.CommitMessageSpellCheckingInspection.display.name=拼寫
inspection.SubjectLimitInspection.display.name=限制主題行
settings.commit.without.dialog=使用非強制回應提交介面
settings.confirmation.option.text.ask=詢問
settings.confirmation.option.text.no=否
settings.confirmation.option.text.yes=是
settings.commit.without.dialog.applies.to.git.mercurial=套用到 Git 和 Mercurial 下的專案
settings.filter.configure.link=配置
radio.restore.workspace.on.branch.switching=切換分支時恢復工作區(&B)
settings.when.files.are.deleted=當檔案被刪除時:
settings.border.when.files.are.created=當檔案被創建時:
settings.file.status.color.modified.in.not.active.changelist=已在非活動變更列表中修改
settings.file.status.color.added.in.not.active.changelist=已在非活動變更列表中添加
settings.file.status.color.changelist.conflict=變更列表衝突
settings.issue.navigation.patterns={0} 將在簽入註釋中搜尋指定的模式，並將它們鏈接到問題跟踪器中的問題:
settings.shelf.content.larger=大於 {0}K 的檔案的基內容不會被存儲
settings.change.shelves.location=更改擱置位置…
change.shelves.location.dialog.title=更改擱置位置
change.shelves.location.dialog.action.button=更改位置
change.shelves.location.dialog.group.title=將擱置存儲於:
change.shelves.location.dialog.location.browser.title=選擇要將擱置存儲在其中的目錄
change.shelves.location.dialog.default.label=預設目錄:
change.shelves.location.dialog.custom.label=自訂目錄:
settings.current.location=當前位置為
settings.default.location=預設位置為 
settings.auto.detected=自動檢測:
checkbox.include.issues.not.assigned.to.me=包括未分配給我的問題
checkbox.select.current.file.only=僅選擇當前檔案
action.Anonymous.text.restore.all.leading.directories=恢復所有前導目錄
action.Anonymous.text.remove.all.leading.directories=移除所有前導目錄
action.SearchFieldAction.text.find=尋找: 
action.DumbAware.ApplyPatchDifferentiatedDialog.text.refresh=刷新
action.DumbAware.ApplyPatchDifferentiatedDialog.description.refresh=刷新
action.NotificationAction.VcsRootProblemNotifier.text.enable.integration=啟用集成
action.NotificationAction.VcsRootProblemNotifier.text.ignore=忽略
action.NotificationAction.VcsRootProblemNotifier.text.configure=配置…
action.NotificationAction.AllVcses.text.install=安裝
action.NotificationAction.AllVcses.text.read.more=閱讀更多
action.NotificationAction.AllVcses.text.open.plugin.page=打開“套件”頁面
action.NotificationAction.InactiveRangesDamagedNotification.text.view.changes=查看變更…
action.AnActionButton.text.add.jira.pattern=添加 JIRA 模式
action.AnActionButton.text.add.youtrack.pattern=添加 YouTrack 模式
action.ToggleAction.text.show.unversioned.files=顯示未進行版本管理的檔案
action.ToggleAction.text.preview.diff=預覽差異
action.ToggleAction.text.show.details=顯示詳細資訊
action.ToggleAction.description.show.details=顯示詳細資訊面板
action.ToggleAction.text.scope.filter=範圍篩選器
action.DumbAwareAction.text.compare.with.local.content=與本地內容比較
action.NotificationAction.VFSListener.text.view.files=查看檔案…

action.ImportIntoShelfAction.text=匯入補丁…
action.ImportIntoShelfAction.description=將補丁檔案複製到擱置
action.presentation.ApplySelectedChangesAction.text=接受
action.presentation.IgnoreSelectedChangesAction.text=忽略
action.presentation.DiffShelvedChangesWithLocalActionProvider.description=將擱置版本與當前版本進行比較
action.presentation.ShowUpdatedDiffActionProvider.description=更新前顯示與版本的差異
button.clear=清除
import.patches.into.shelf=將補丁匯入到擱置…
import.patches=匯入補丁
looking.for.patch.files=正在尋找補丁檔案…

title.load.revision.contents=載入修訂內容
message.read.only.status.title={0}: 無法看到唯讀狀態
message.read.only.status.content=您以 <b>root</b> 身份登錄，因此: <br><br>- {0} 無法看到檔案的唯讀狀態。<br>- 所有檔案都被視為可寫入。<br>- 修改時無法自動簽出檔案。
action.clone.dialog.stub.click.to.continue=點擊“{0}”繼續
vcs.generic.name=VCS
vcs.generic.name.with.mnemonic=VCS(_S)
vcs.common.labels.directory=目錄:
vcs.common.labels.vcs=VCS:
vcs.common.labels.version.control=版本控制:
vcs.common.labels.url=URL:
settings.commit.message.right.margin.label=右邊距:
settings.commit.message.show.right.margin.label=顯示右邊距
settings.commit.message.show.right.margin.n.columns.label=顯示 {0} 列中的右邊距
settings.commit.message.body.add.blank.line.fix=添加空白行
get.from.version.control=從版本控制獲取
clone.dialog.repository.url.item=版本庫 URL
clone.dialog.clone.button=克隆
clone.dialog.unable.create.destination.error=無法創建目標目錄
clone.dialog.clone.failed.error=克隆失敗
committed.changes.tab=版本庫
incoming.changes.tab=傳入
local.changes.tab=本地變更
error.cant.perform.operation.now=現在無法{0}
local.changes.freeze.message={0}完成之前，本地變更不可用

file.history.checking.last.revision.process=正在檢查最新修訂
file.history.diff.revisions.process=正在比較修訂…
file.history.exceeded.limit.message=檔案歷史記錄: 僅為 {1} 載入了 {0} 個修訂\\\\n\\\\
要更改歷史記錄限制，請轉到 {2}
file.history.details.empty.status=提交訊息
file.history.details.hash.author.on.date.at.time={0} {1}，{2} {3}
file.history.details.committer.info=由 {0} 提交
file.history.details.committer.tooltip.info=通過 {0}
file.history.diff.handler.paths.diff.title={0} 與 {2} 中的 {1} 之間的差異
file.history.diff.handler.paths.diff.with.local.title={0} 與 {1} 中的本地版本之間的差異
file.history.diff.handler.affected.changes.title={1} 中的初始提交 {0}
file.history.diff.handler.collecting.affected.process=正在收集受影響的變更…
file.history.diff.handler.comparing.process=正在比較修訂…
file.history.diff.handler.process.error=任務期間出錯: {0}

selection.history.loading.revision.status=正在載入修訂 {0}…
selection.history.commit.message.label=提交訊息:
selection.history.local.revision.text=本地變更
selection.history.can.not.load.message=無法載入修訂內容

vcs.update.tab.name=更新資訊
file.history.tab.name=歷史記錄

vcs.commit.files.committed={0,choice,1#{0} 個檔案|2#{0} 個檔案}已提交
vcs.commit.files.committed.and.files.failed.to.commit={0,choice,1#{0} 個檔案|2#{0} 個檔案}已提交，{1,choice,1#{1} 個檔案|2#{1} 個檔案}提交失敗
vcs.commit.canceled=提交已取消

checking.vcs.status.progress=正在檢查 VCS 狀態…

notification.showDetailsInConsole = 在控制台中顯示詳細資訊

unregistered.roots.label=未註冊的根:
copy.revision.number.action=複製修訂號

annotations.color.mode.author=作者
annotations.color.mode.order=順序
annotations.color.mode.hide=隱藏
annotations.color.mode.group.colors=顏色
annotations.short.name.type.initials=初始
annotations.short.name.type.first.name=名
annotations.short.name.type.last.name=姓
annotations.short.name.type.full.name=全名
annotations.short.name.type.group.names=姓名

commit.description.tooltip.commit=提交 {0}
commit.description.tooltip.author=作者: {0}
commit.description.tooltip.date=日期: {0}
commit.description.tooltip.path=路徑: {0}

settings.version.control.option.group=版本控制
settings.commit.message.option.group=提交訊息
settings.commit.option.group=提交
settings.changelists.option.group=變更列表
settings.confirmation.option.group=確認
dialog.title.files.created=檔案已創建
label.select.files.to.be.added.to.version.control=選擇要添加到版本控制中的檔案
dialog.title.cannot.convert.module=無法轉換模組
dialog.title.select.destination.folder=選擇目標資料夾
dialog.message.enter.directory.name=為創建的專案輸入目錄名稱。留空可直接簽出到“{0}”。
dialog.title.project.directory.name=專案目錄名稱
progress.title.hey=嗨
progress.title.version.control.processing.changed.files=版本控制: 正在處理更改的檔案
dialog.message.can.t.create.text.editor.for=無法為 {0} 創建文本編輯器
link.label.display.anyway=仍然顯示
link.label.hide=隱藏
action.ShowAffectedFilesAction.show.affected.files.text=顯示受影響的檔案
progress.title.loading.current.revision=正在載入當前修訂…
dialog.title.remove.empty.changelist=移除空變更列表
button.remove=移除
checkbox.remember.my.choice=記住我的選擇(&R)
action.ChangesViewToolWindowPanel.text=檢視選項
notification.title.couldn.t.save.uncommitted.changes=無法儲存未提交的變更。
dialog.title.ignored.files=已忽略的檔案
dialog.title.unversioned.files=未進行版本管理的檔案
button.skip=跳過
progress.text.performing={0}: 正在執行 {1}…
action.message.use.selected.changes.description={0}所選變更
progress.text.performing.rollback={0}: 正在執行回滾…
progress.title.adding.files.to.vcs=正在將檔案添加到 VCS…
notification.content.didn.t.update.repository.changes=由於發生錯誤，未使用新消息更新版本庫變更: {0}
progress.title.discovering.location=正在發現 {0} 的位置
dialog.title.resolve.changelist.conflict=解決變更列表衝突
link.label.move.changes=移動變更
link.label.switch.changelist=切換變更列表
dialog.message.no.changes.for.this.file=此檔案沒有變更
dialog.title.message=訊息
link.label.ignore=忽略
tooltip.show.options.dialog=顯示選項對話框
dialog.message.conflict.seems.to.be.resolved=衝突似乎已解決
dialog.title.no.conflict.found=未找到衝突
dialog.title.move.changes.to.active.changelist=將變更移至活動變更列表
checkbox.include=包含(&I)
status.text.unversioned.files.available=未進行版本管理的檔案可用。
plugins.configurable.show=status.text.Show

action.filter.filter.by.text=篩選依據
action.filter.moved.files.text=隱藏移動時未更改的檔案
action.filter.non.important.files.text=隱藏包含不重要更改的檔案

group.mainmenu.vcs.current.file.text=當前檔案

multiple.file.merge.dialog.progress.title.resolving.conflicts=正在解決衝突…
multiple.file.merge.dialog.message.error.saving.merged.data=儲存合併資料時出錯: {0}
multiple.file.merge.dialog.command.name.accept.yours=接受您的變更
multiple.file.merge.dialog.command.name.accept.theirs=接受他們的變更
multiple.file.merge.dialog.progress.title.loading.revisions=正在載入修訂…
multiple.file.merge.dialog.error.loading.revisions.to.merge=載入待合併修訂時出錯: {0}
multiple.file.merge.dialog.message.file.too.big.to.be.loaded=檔案過大，無法載入
multiple.file.merge.dialog.title.can.t.show.merge.dialog=無法顯示“合併”對話框

text.commit.message.truncated.by.ide.name={0}\\\\n\\\\
\\\\n\\\\
…提交訊息過長，被 {1} 截斷…
label.project.vcs.root.mapping=<專案>
label.relative.project.path.presentation=<專案>/{0}
file.content.too.big.to.load.increase.property.suggestion=無法顯示 ''{0}'' 的內容。\\\\n\\\\
該檔案大小大於 {1}。\\\\n\\\\
\\\\n\\\\
您可以通過在 ''idea.properties'' 檔案中增大{2}屬性來覆寫此限制。
error.date.before.must.be.a.valid.date=之前的日期必須是有效日期
error.date.after.must.be.a.valid.date=之後的日期必須是有效日期
error.change.from.must.be.a.valid.number=起始日期必須是有效數字
error.change.to.must.be.a.valid.number=變更物件必須是有效數字

action.annotate.revision.text=註解修訂
action.annotate.selected.revision.in.new.tab.description=在新頁籤中註解所選修訂
action.annotate.previous.revision.text=註解前一個修訂
action.annotate.successor.selected.revision.in.new.tab.description=在新頁籤中註解所選修訂的後繼者
notification.title.cant.load.annotations=無法載入註解
hide.this.notification=隱藏此通知
vcs.error.failed.to.load.file.content.from.vcs=無法載入內容
diff.producer.error.cant.get.revision.content=無法獲取修訂內容
show.diff.from.annotation.action.error.can.not.load.data.to.show.diff=無法載入資料以顯示差異
vcs.preview.panel.added.ignored.line=已添加忽略的行
vcs.preview.panel.modified.ignored.line=已修改忽略的行
vcs.preview.panel.deleted.ignored.line.below=已刪除以下忽略的行
vcs.preview.panel.line.with.modified.whitespaces.and.deletion.after=帶有修改的空格和後續刪除的行
vcs.preview.panel.added.line=已添加行
vcs.preview.panel.line.with.modified.whitespaces=帶有修改的空格的行
vcs.preview.panel.modified.line=已修改的行
vcs.preview.panel.deleted.line.below=以下已刪除的行
annotation.background=註解背景
changes.error.shelving.changes.failed=擱置變更失敗: {0}
changes.error.can.t.get.revision.content=無法獲取修訂內容
changes.error.failed.to.create.content.for.current.revision=無法為當前修訂創建內容
changes.error.failed.to.fetch.current.revision=無法獲取當前修訂
changes.finishing.changed.on.server.update=正在完成“在伺服器上被更改”更新
changes.tried.to.save.uncommitted.changes.in.shelve.before.s.but.failed.with.an.error=嘗試在{0}之前擱置未提交的變更，但因為錯誤而失敗。<br/>{1}
changes.refresh.changelists.after.update=更新後刷新變更列表
changes.deleting.added.files.locally=正在本地刪除已添加檔案…
changes.progress.text.vcs.name.performing.operation.name={0}: 正在執行 {1}…
changes.project.exclude.paths=專案排除路徑
changes.error.default.project.not.supported=不支持預設專案
changes.removing.configuration.0.from.ignore=正在從忽略物件中移除配置 {0}…
changes.checking.configuration.0.for.ignore=正在為忽略物件檢查配置 {0}…
changes.cant.load.changes=無法載入變更
changes.switched.to.branch.name=已切換到 {0}
changes.do.cleanup=進行清理…
changes.locked.by=被 {0} 鎖定
changes.browse=瀏覽
changes.diff.separator=差異
changes.warning.not.all.local.changes.may.be.shown.due.to.an.error=警告: 由於錯誤，可能不會顯示所有本地變更: {0}
changes.new.changelist=新的變更列表
changes.action.include.in.operation.name=包含在 {0} 中(&I)
changes.error.content.for.0.was.removed=''{0}'' 的內容已被移除
changes.error.can.t.show.diff.for=無法顯示 ''{0}'' 的差異
changes.can.not.find.patch.for.path.in.patch.file=無法在補丁檔案中找到 {0} 的補丁。
changes.error.cannot.find.base.for.path=找不到 ''{0}'' 的基
changes.error.can.t.show.diff.for.binary.file=無法顯示二進制檔案 ''{0}'' 的差異
changes.impossible.until.indices.are.up.to.date=在索引更新前不可行
changes.empty.changelists.no.longer.active={0,choice,1#空變更列表 ''''{1}'''' 已|2#空變更列表 '<br/>'{1} 已}不再活動。<br/>要將{0, choice,1#其|2#其}移除嗎?
changes.text.default.ignored.files=預設忽略的檔案
changes.tab.title.vcs.errors=VCS 錯誤
changes.progress.title.choice.revert.apply.changes={0, choice, 0#還原|1#套用}變更
changes.dialog.message.failed.to.revert.apply.changes=無法{0, choice, 0#還原|1#套用}變更: 
changes.revert.apply.change.list.name={0, choice, 0#還原: |1#套用: }{1}
change.dialog.title.change.list.name={0} [{1}]
change.dialog.title.in.change.list.name={1} 中的 {0}
changes.none=<無>
changes.button.newer=較新的 >
changes.button.older=< 較舊的
changes.directory.does.not.belong.to.the.active.changelist={0, choice, 1#這一目錄|2#這些目錄}不屬於活動變更列表:
changes.file.does.not.belong.to.the.active.changelist={0, choice, 1#這一檔案|2#這些檔案}不屬於活動變更列表:
changes.configure=配置(&C)…
changes.hide.this.notification=隱藏此通知
changes.set.active.changelist.to.change.list.name=將活動變更列表設定為 ''{0}''
changes.move.changes.to.active.change.list.name=將變更移動到活動變更列表({0})
changes.file.from.non.active.changelist.is.modified=非活動變更列表中的檔案已修改
changes.another.change.list=另一個
changes.default.change.list=預設
changes.include.lines.into.commit=將行包含在提交中
changes.exclude.lines.from.commit=將行從提交中排除
changes.move.to.changelist=移動到 ''{0}'' 變更列表
changes.notification.content.repository.location.not.found.for=找不到 {0} 的版本庫位置
changes.days.of.history.to.cache.initially=最初要快取的歷史記錄的天數:
changes.changelists.to.cache.initially=最初要快取的變更列表:
changes.minutes=分鐘
changes.refresh.changes.every=刷新變更，每
changes.please.enter.a.valid.regex=請輸入有效正則表達式
changes.no.incoming.changelists.available=無可用傳入變更列表
changes.error.refreshing.vcs.history=刷新 VCS 歷史記錄時出錯
changes.committed.changes=已提交變更
changes.error.refreshing.view=刷新檢視時出錯: {0}
changes.title.loading.changes=正在載入變更
changes.no.tracking.branch=無跟踪分支
changes.no.tracking.branch.suffix=\\\\ (無跟踪分支)
changes.ignore.file=忽略檔案

impl.notification.content.vcs.plugin.not.found.for.mapping.to=沒有為 ''{0}'' 的映射找到 VCS 套件
impl.progress.title.installing.plugin=正在安裝套件…
impl.notification.title.failed.to.install.plugin=安裝套件失敗
impl.notification.content.could.not.find.plugin=找不到套件 {0}
impl.notification.content.plugin.was.unbundled.needs.to.be.installed.manually={0} 套件已解除捆綁，需要手動安裝
impl.vcs.initialization=VCS 初始化
impl.show.all.affected.files.for.path.at.revision.failed=為 {0} 顯示 {1} 失敗時所有受影響的檔案
merge.loading.merge.details=正在載入合併詳細資訊…

commit.message=提交訊息
commit.message.intention.family.name.reformat.commit.message=重新格式化提交訊息
commit.message.inspection.message.body.lines.should.not.exceed.characters=正文行不能超過 {0} 個字符
commit.message.intention.family.name.wrap.line=換行
commit.message.missing.blank.line.between.subject.and.body=主題與正文之間缺少空行
commit.message.inspection.message.subject.should.not.exceed.characters=主題不能超過 {0} 個字符
commit.amend.commit=修正提交
commit.tooltip.merge.this.commit.with.the.previous.one=將此提交與前一個提交合併
ranges.to.commit.of.ranges.size.changes={1} 個中的 {0} 個發生變更
commit.changes=提交變更
commit.progress.title=提交
tab.title.commit=提交
tab.title.commit.to.branch=提交至 {0}
history.file.not.found=找不到檔案 {0}
compare.with.dialog.get.from.vcs.action.title=從 VCS 獲取
history.dialog.title.difference.between.versions.in={2} 中的 {0} 和 {1} 版本的差異
history.failed.to.load.content.for.revision.0=無法為修訂 {0} 載入內容
history.tab.title.can.not.load.changelist.contents=無法載入變更列表內容
update.label.before.update=更新前
update.notification.title.project.partially.updated=專案已部分更新
update.notification.title.count.files.updated={0,choice,1#1 個檔案|2#{0} 個檔案}已更新
update.notification.content.files.updated={0,choice,1#1 個檔案|2#{0} 個檔案}已更新
update.file.name.wasn.t.modified={0} 未修改
update.filtered.files.count.in.filter.name={0} ({1} 內)
update.label.after.update=更新後
update.notification.content.view=查看
update.checkbox.don.t.show.again=不再顯示
update.can.t.load.content=無法載入內容
update.error.label=錯誤: 
roots.notification.content.added.vcs.name.roots=已添加 {0} 個{1,choice,1#根|2#根}: {2}
roots.notification.content.directory.registered.as.root.but.no.repositories.were.found.there=目錄 {0} 被註冊為 {1} 根，但在那裡沒有發現 {1} 版本庫。
roots.notification.title.invalid.vcs.root.choice.mapping.mappings=無效 VCS 根{0, choice, 1#映射|2#映射}
roots.notification.title.vcs.root.configuration.problems=VCS 根配置問題
roots.notification.title.vcs.name.integration.enabled={0} 集成已啟用
notification.title.vcs.name.repository.repositories.found=已找到 {0} 個{1, choice, 1#版本庫|2#版本庫}
roots.the.following.directories.are.registered.as.vcs.roots.but.they.are.not=以下目錄被錯誤註冊為 VCS 根:
configurable.issue.link.remove=移除
configurable.issue.link.edit=編輯
configurable.shelf.storage.destination.shelf.directory.should.have.write.access=目標擱置目錄必須具備寫入權限
configurable.shelf.storage.destination.shelf.directory.should.have.read.access=目標擱置目錄必須具備讀取權限
configurable.shelf.storage.cant.find.or.create.new.shelf.directory=無法找到或創建新的擱置目錄
configurable.vcs.manage.scopes=管理範圍
ex.new.changelist=新建變更列表…
ex.move.lines.to.another.changelist.0=將行移動到另一個變更列表({0})
ex.changelists=變更列表
checkin.cancel=取消(&N)
checkin.commit=提交(&C)
checkin.code.analysis.failed=程式碼分析失敗
checkin.code.analysis.failed.with.exception.name.message=程式碼分析失敗，出現異常: {0}: {1}
checkin.wait=等待(&W)
checkin.can.not.load.current.revision=無法載入當前修訂
checkin.can.not.load.previous.revision=無法載入前一個修訂
checkin.invalid.file.s=無效檔案
checkin.dialog.title.not.possible.right.now=現在無法檢查 TODO
checkin.dialog.message.cant.be.performed={0} 在背景更新索引時，無法執行 TODO 檢查。\\\\n\\\\
您可以在不執行檢查的情況下提交更改，也可以等到索引建立後再提交。
checkin.dialog.title.looking.for.new.edited.todo.items=正在尋找新的和編輯的 TODO 條目…
checkin.dialog.title.todo=TODO
checkin.filter.filter.name=篩選器: {0}
checkin.title.for.commit.0=以供提交 ({0})
checkin.unresolved.merge.unresolved.conflicts=未解決的衝突
checkin.unresolved.merge.are.you.sure.you.want.to.commit.changes.with.unresolved.conflicts=確定要提交有未解決衝突的變更嗎?
patch.unknown.line.prefix=未知行前綴
patch.unknown.after.hunk.start.syntax=未知的 after 區塊開始語法
patch.missing.after.hunk=缺少 after 區塊
patch.unknown.before.hunk.start.syntax=未知的 before 區塊開始語法
patch.unknown.hunk.start.syntax=未知的區塊開始語法
patch.second.file.name.expected=應為第二個文件名
patch.empty.0.data.section=空 ''{0}'' 資料分區
patch.empty.additional.info.header=空的附加資訊頭
patch.contains.additional.information.without.patch.itself=包含附加資訊但不含補丁本身
patch.can.t.detect.file.names.from.git.format.header.line=無法從 git 格式頭行檢測文件名
patch.unexpected.end.of.binary.patch=二進制補丁意外結束
patch.failed.to.fetch.old.content.for.file.name.in.revision=無法在修訂 {1} 中獲取檔案 {0} 的舊內容
vcs.tab.title.vcs.name.operations.errors={0} 個操作錯誤
vfs.revision.author.unknown=未知
change.list.scope.provider.local.changes=本地變更
changes.change.list.conflict.dialog.radio.button.ignore=忽略(&I)
changes.change.list.conflict.dialog.radio.button.shelve.changes=擱置變更(&S)
todo.tab.title.all.changes=本地變更
todo.tab.title.changelist.suffix=變更列表
get.from.vcs.extension.list.accessible.name=版本庫位置
vcs.dnd.image.text.n.files={0}{0, choice, 1#檔案|2#檔案}
checking.recent.changes=正在檢查最近的變更…
show.diff.in.editor.tab.got.it.tooltip=要在編輯器頁籤中再次顯示差異，請使用此選單。
intention.name.rollback.changes.in.current.line=回滾當前行中的變更
advanced.settings.vcs=版本控制
advanced.setting.vcs.annotations.preload=在編輯器中打開檔案時載入 VCS 中的檔案註解
advanced.setting.vcs.annotations.preload.description=這樣就可以更快速地按需顯示。

before.checkin.cleanup.code.profile=使用 ''{0}'' 配置檔案清理(&L)
label.at.date.leading=在 {0}
label.at.date.middle=在 {0}
button.tooltip.remove.commit.author.date=移除
settings.changelists.create.automatically.checkbox=自動創建變更列表(&A)
changes.default.changelist.name.old=預設變更列表
advanced.setting.vcs.commit.tool.window=啟用“提交”工具視窗
advanced.setting.vcs.commit.tool.window.description=在單獨的“提交”工具視窗中顯示“本地變更”和“擱置”頁籤
advanced.setting.vcs.non.modal.commit.toggle.ui=切換提交控件
advanced.setting.vcs.non.modal.commit.toggle.ui.description=執行提交後隱藏提交面板和復選框，並允許在“本地變更”中切換提交 UI
advanced.setting.vcs.push.all.with.commits=選擇包含要推送的新提交的所有版本庫
advanced.setting.vcs.push.all.with.commits.description=預設預先選擇包含要推送的提交的所有版本庫
advanced.setting.vcs.process.ignored=高亮顯示忽略的檔案
advanced.setting.vcs.process.ignored.description=請求 VCS 中被忽略檔案的列表，並在 IDE 中顯示這些檔案的狀態
tooltip.rerun.commit.checks=重新執行提交檢查
change.list.scope.provider.only.changes=所有檔案中僅未提交到 VCS 的變更
change.list.scope.provider.only.changes.in.file=檔案 {0} 中僅未提交到 VCS 的變更
settings.general.show.options.before.command.label=進行以下操作之前顯示選項:
show.patch.in.explorer.after.creation.label=創建補丁時:
show.patch.in.explorer.after.creation.combobox.text.ask=詢問
show.patch.in.explorer.after.creation.combobox.text.show.in.file.manager=在 {0} 中顯示
show.patch.in.explorer.after.creation.combobox.text.no=不執行任何操作
settings.checkbox.show.changed.in.last.comment=修改的檔案將在外部堆疊跟踪和調試時高亮顯示。
remove.changelist.combobox.show.options=顯示選項
remove.changelist.combobox.remove.silently=靜默移除
remove.changelist.combobox.do.not.remove=不執行任何操作
radio.restore.workspace.on.branch.switching.comment=工作區是一組打開的檔案、當前執行配置以及與分支關聯的斷點。
settings.general.confirmation.group.title=確認
settings.general.changes.group.title=變更
checkbox.including.files.created.outside.ide=應用於在 {0} 外部創建的檔案
settings.label.when.empty.changelist.becomes.inactive=當空變更列表變為非活動狀態時:
description.text.option.applicable.to.vcses=適用於 {0}
sequence.concatenation.a.and.b={0} 和 {1}
sequence.concatenation.separator=、
sequence.concatenation.tail=和 {0}
sequence.concatenation.tail.n.others=和其他 {0} 個
changes.combined.diff=組合變更差異
label.code.author.inlay.hints=程式碼作者
label.new.code=新 *
label.multi.author.modified.code={0} +{1} *
label.multi.author.not.modified.code={0} +{1}
label.single.author.modified.code={0} *
searching.for.code.smells.processing.file.progress.text=正在處理 {0}
title.code.author.inlay.hints=程式碼作者
version.control.main.configurable.description=<html><body>配置與專案中使用的版本控制相關的設定
incoming.changes.indicator.name=傳入變更
RepositoryBrowser.toolwindow.name=版本庫
ChangesBrowserToolWindow.toolwindow.name=變更
changes.editor.diff.preview.title=變更: {0}
changes.editor.diff.preview.empty.title=變更
jb.protocol.no.provider=找不到 VCS 提供程序: ''{0}''
settings.auto.detected.progress=正在檢測…
annotations.short.name.type.email=電子郵件
action.Vcs.Toolbar.ShowMoreActions.text=版本控制
Vcs.Toolbar.ShowMoreActions.description=VCS 操作
notification.group.external.executable=VCS 外部可執行檔案驗證失敗"
`;

exports[`src messages/VcsLogBundle.properties 1`] = `
"# actions
vcs.log.action.align.labels=將引用對齊到左側
vcs.log.action.description.align.labels=在提交訊息左側顯示引用
vcs.log.action.description.show.all.branches=在僅顯示當前分支和顯示所有分支之間切換
vcs.log.action.description.show.all.changes.from.parent=分別顯示對每個合併提交所做的更改
vcs.log.action.description.show.compact.references.view=僅在表中顯示提交的第一個引用
vcs.log.action.description.show.details=顯示詳細資訊面板
vcs.log.action.description.show.diff.preview=顯示差異預覽面板
vcs.log.action.description.show.long.edges=即使提交在當前檢視中不可見，也顯示長分支邊緣。
vcs.log.action.description.show.only.affected.changes=僅顯示影響“路徑”選單中所選檔案的變更
vcs.log.action.description.show.tag.names=在表中顯示標籤名稱
vcs.log.action.description.open.new.tab.with.log=打開包含 {0} 日誌的新頁籤
vcs.log.action.show.all.branches=顯示所有分支
vcs.log.action.show.diff.preview=顯示差異預覽
action.Vcs.Log.MoveDiffPreviewToBottom.text=底部
action.Vcs.Log.MoveDiffPreviewToBottom.description=在底部找到差異預覽
action.Vcs.Log.MoveDiffPreviewToRight.text=右側
action.Vcs.Log.MoveDiffPreviewToRight.description=在右側找到差異預覽
vcs.log.action.show.all.changes.from.parent=顯示對父項的變更
vcs.log.action.show.compact.references.view=緊湊型引用檢視
vcs.log.action.show.details=顯示詳細資訊
vcs.log.action.show.long.edges=顯示長邊
vcs.log.action.show.only.affected.changes=僅顯示受影響的變更
vcs.log.action.show.root.names=顯示根名稱
vcs.log.action.show.tag.names=顯示標籤名稱
vcs.log.action.open.new.tab.with.log=打開新的 {0} 日誌頁籤
action.process.expanding.linear.branches=正在展開線性分支…
action.process.expanding.merges=正在展開合併…
action.description.expand.merges=展開合併
action.title.expand.merges=展開合併
action.description.expand.linear.branches=展開線性分支
action.title.expand.linear.branches=展開線性分支
action.process.collapsing.linear.branches=正在摺疊線性分支…
action.process.collapsing.merges=正在摺疊合併…
action.description.collapse.merges=摺疊合併
action.title.collapse.merges=摺疊合併
action.description.collapse.linear.branches=摺疊線性分支
action.title.collapse.linear.branches=摺疊線性分支
action.title.match.case=區分大小寫
action.title.match.case.only.supported=區分大小寫(僅限 {0})
action.go.to.navigate.to=導航到 {0}
action.go.to.select.child.to.navigate=選擇要導航的子項
action.go.to.select.parent.to.navigate=選擇要導航的父項
action.go.to.select.hash.subject.author.date.time={0} {1}，作者 {2}，{3} {4}
action.name.refresh.log=刷新
action.description.refresh.log=檢查新提交，必要時刷新日誌
action.description.was.paused=為 {0} 編制索引已暫停。恢復。
action.title.resume.indexing=恢復 {0} 日誌索引編制
action.description.is.scheduled=為 {0} 編制索引已計劃。暫停。
action.title.pause.indexing=暫停 {0} 日誌索引編制
action.description.select.columns.to.see=選擇要在表中查看的列
action.title.select.columns.to.see=顯示列
action.FocusTextFilterAction.text=聚焦文本篩選器
action.FocusTextFilterAction.description=聚焦文本篩選器或將焦點移回提交列表
action.IntelliSortChooserPopupAction.text=IntelliSort
action.IntelliSortChooserPopupAction.description=更改 IntelliSort 類型
action.ShowCommitTooltipAction.text=顯示提交工具提示
action.ShowCommitTooltipAction.description=在日誌中為當前所選提交顯示工具提示
action.presentation.CompareRevisionsFromFileHistoryActionProvider.text.compare=比較
action.presentation.CompareRevisionsFromFileHistoryActionProvider.text.show.diff=顯示差異
action.presentation.CompareRevisionsFromFileHistoryActionProvider.description.compare=比較所選版本
action.presentation.CompareRevisionsFromFileHistoryActionProvider.description.show.diff=顯示與之前版本的差異
vcs.log.action.intellisort.title=IntelliSort: {0}
vcs.log.action.intellisort.text=IntelliSort
vcs.log.action.intellisort.description=開啟/關閉 IntelliSort
vcs.log.action.turn.intellisort.on=開啟 IntelliSort: {0}。
vcs.log.action.turn.intellisort.off=關閉 IntelliSort: {0}。
action.Vcs.Log.GoToRef.text=轉到哈希/分支/標記
action.Vcs.Log.GoToRef.description=指定分支或標記的哈希或名稱，以導航到其指向的提交
action.Vcs.Log.GoToParent.text=轉到父提交
action.Vcs.Log.GoToParent.description=導航到提交圖中的父行
action.Vcs.Log.GoToChild.text=轉到子提交
action.Vcs.Log.GoToChild.description=導航到提交圖中的子行
action.Vcs.Show.Log.text=顯示 VCS 日誌
action.Vcs.Show.Log.text.template=顯示 {0} 日誌
action.Vcs.Log.ShowTooltip.text=顯示提交工具提示
action.Vcs.Log.ShowTooltip.description=在日誌中為當前選定提交顯示工具提示
action.Vcs.Log.EnableFilterByRegexAction.text=正則表達式
action.Vcs.Log.MatchCaseAction.text=區分大小寫
action.Vcs.Log.OpenRepositoryVersion.text=按修訂顯示檔案
action.Vcs.Log.OpenRepositoryVersion.description=在編輯器中打開檔案的所選修訂
action.Vcs.Log.GetVersion.text=獲取
action.Vcs.Log.GetVersion.description=從版本庫獲取版本
action.Vcs.Log.AnnotateRevisionAction.text=註解
action.Vcs.Log.AnnotateRevisionAction.description=註解所選修訂
action.Vcs.Log.ShowAllAffected.text=顯示所有受影響的檔案
action.Vcs.Log.ShowAllAffected.description=顯示選中修訂中所做的所有變更
action.Vcs.Log.CompareRevisions.text=比較版本
action.Vcs.Log.CompareRevisions.description=比較選定版本
action.Vcs.Log.ResumeIndexing.text=恢復索引編制
action.Vcs.Log.ResumeIndexing.description=索引編制已暫停，因為它花費的時間比預期長。恢復。
group.Vcs.Log.PresentationSettings.text=演示設定
group.Vcs.Log.PresentationSettings.description=配置日誌的演示
group.Vcs.Log.TextFilterSettings.text=文本篩選器設定
group.Vcs.Log.TextFilterSettings.description=選擇文本篩選器選項
group.Vcs.Log.LayoutConfiguration.text=配置布局
group.Vcs.Log.LayoutConfiguration.description=配置視窗布局
group.Vcs.FileHistory.PresentationSettings.text=演示設定
group.Vcs.FileHistory.PresentationSettings.description=配置檔案歷史記錄的演示
group.Log.KeymapGroup.text=日誌
group.Vcs.Log.Diff.Preview.Location.text=差異預覽位置

dialog.title.paths.affected.by.commit=受提交 {0} 影響的路徑

# tooltips
vcs.log.click.to.collapse.paths.column.tooltip=點擊以摺疊
vcs.log.click.to.expand.paths.column.tooltip=點擊以展開
vcs.log.graph.arrow.tooltip.jump.to.subject.author.date.time=跳轉到 {0} (作者 {1}，{2} {3})
vcs.log.graph.arrow.tooltip.jump.to.hash=跳轉到提交 {0}
vcs.log.graph.arrow.tooltip.jump.to.hash.in.root=跳轉到 {1} 中的提交 {0}
vcs.log.references.more.tooltip=…詳細資訊窗格中的其他 {0} 項

# log in editor
filetype.vcs.log.description=Vcs 日誌

# replacement for specific vcs name
vcs=Vcs

# empty text
vcs.log.is.loading=正在載入 VCS 日誌…
vcs.log.loading.status=正在載入提交…
vcs.log.error.loading.status=載入提交時出錯
vcs.log.no.commits.status=未提交變更。
vcs.log.commit.status.action=提交本地變更
vcs.log.error.filtering.status=篩選提交時出錯
vcs.log.no.commits.matching.status=沒有與篩選器符合的提交
vcs.log.reset.filters.status.action=重置篩選器
vcs.log.refresh.status.action=刷新
vcs.log.default.status=變更日誌
vcs.log.duplicated.tab.id.error=VCS 日誌頁籤不能打開兩次

# file history
file.history.error.status=計算檔案歷史記錄時出錯
file.history.empty.status=檔案歷史記錄
file.history.action.could.not.load.selected.commits.message=無法載入所選提交: {0}
file.history.diff.preview.editor.tab.name=歷史記錄: {0}

# jump to commit
vcs.log.go.to.hash.popup.label=輸入哈希或分支/標記名稱:
vcs.log.commit.or.reference.not.found=未找到提交或引用 ''{0}''
vcs.log.commit.not.found=未找到提交 {0}
vcs.log.commit.does.not.match=提交 {0} 與篩選器不符合
vcs.log.commit.does.not.match.view.and.reset.link=查看並重置篩選器
vcs.log.commit.does.not.match.view.in.tab.link=在新頁籤中查看
file.history.commit.not.found.in.branch=當前分支中 {1} 的歷史記錄中不存在提交 {0}
file.history.commit.not.found={1} 的歷史記錄中不存在提交 {0}
file.history.commit.not.found.view.and.show.all.branches.link=查看並顯示所有分支
file.history.commit.not.found.view.in.log.link=在日誌中查看

# indexing progress
vcs.log.status.bar.indexing.cancel.tooltip=取消索引編制。可以從 {0} 日誌工具欄手動重新啟動索引編制。
vcs.log.status.bar.indexing.cancel.cancelling=正在取消
vcs.log.status.bar.indexing={0} 日誌正在編制索引…

# processes
vcs.log.creating.process=正在載入提交…
vcs.log.initial.loading.process=正在載入歷史記錄…
vcs.log.refreshing.process=正在刷新歷史記錄…
vcs.log.closing.process=正在關閉 VCS 日誌
vcs.log.loading.selected.details.process=正在載入所選詳細資訊
vcs.log.applying.filters.process=正在套用篩選器…

# tab name
vcs.log.tab.name=日誌
vcs.log.diff.preview.editor.empty.tab.name=版本庫差異
vcs.log.diff.preview.editor.tab.name=版本庫差異: {0}
vcs.log.editor.name=Vcs 日誌編輯器

# filters
vcs.log.filter.all=所有
vcs.log.filter.recent=最近
vcs.log.filter.structure.presentation.with.prefix=用於 {0}
vcs.log.filter.root.presentation.with.prefix=在 {0} 中
vcs.log.filter.branch.presentation.with.prefix=在 {0} 上
vcs.log.filter.date.presentation.with.prefix.made=生成於 {0}
vcs.log.filter.date.presentation.with.prefix.made.after={0} 後生成
vcs.log.filter.date.presentation.with.prefix.made.before={0} 前生成
vcs.log.filter.date.display.name.after=在 {0} 後
vcs.log.filter.date.display.name.before=在 {0} 前
vcs.log.filter.user.presentation.with.prefix=被 {0} 使用
vcs.log.filter.text.presentation.with.prefix=包含 {0}
vcs.log.filter.text.hash.tooltip=文本或哈希篩選器
vcs.log.filter.popup.no.roots=沒有根
vcs.log.filter.popup.no.folders=無路徑
vcs.log.filter.popup.no.items=沒有項
vcs.log.filter.popup.paths=路徑
vcs.log.Accessibility.filter.label={0}: {1}
vcs.log.date.filter.label=日期
vcs.log.branch.filter.label=分支
vcs.log.branch.filter.favorites=收藏夾
vcs.log.user.filter.label=使用者
vcs.log.user.filter.me=我
vcs.log.date.filter.since=自 {0}
vcs.log.date.filter.until=直到 {0}
vcs.log.date.filter.action.last.day=過去 24 小時
vcs.log.date.filter.action.last.week=過去 7 天
vcs.log.date.filter.select.period.dialog.title=選擇期間
vcs.log.filter.action.select=選擇…
vcs.log.select.folder.dialog.title=選擇要篩選的路徑
vcs.log.filters.structure.label=已選擇: {0}
vcs.log.filters.structure.max.selected.error.message=您已添加 {0} 個元素。不允許更多元素。
vcs.log.filter.roots=根
vcs.log.filter.tooltip.click.to.see.only={0}+點擊以僅查看“{1}”
vcs.log.filter.tooltip.no.roots.selected=未選擇根
vcs.log.filter.tooltip.roots=根:
vcs.log.filter.tooltip.folders=路徑:
vcs.log.filter.popup.advertisement.text=選擇一個或多個用 {0} 分隔的值
vcs.log.filter.popup.advertisement.text.new.lines=新行
vcs.log.filter.popup.advertisement.text.or.suffix=或{0}
vcs.log.filter.popup.advertisement.with.key.text=選擇一個或多個用 {0} 分隔的值，並使用 {1} 完成
vcs.log.filter.select.folders=在樹中選擇…
vcs.log.filter.edit.folders=選擇…
vcs.log.text.filter.action.text=按文本或哈希篩選
vcs.log.branch.filter.action.text=按分支篩選
vcs.log.user.filter.action.text=按使用者篩選
vcs.log.date.filter.action.text=按日期篩選
vcs.log.path.filter.action.text=按路徑篩選

# commit details
vcs.log.details.in.branches.loading=在分支中: 正在載入…
vcs.log.details.in.branches.empty=不在任何分支中
vcs.log.details.in.branches.hide=隱藏
vcs.log.details.in.branches.show.all=全部顯示
vcs.log.details.in.branches=在 {0,choice,1#{0} 個分支|2#{0} 個分支}中:
vcs.log.details.committer.info.user.date.time=由 {0} 於 {1} {2} 提交
vcs.log.details.committer.info.date.time=在 {0} {1} 提交
vcs.log.details.author.on.date.at.time=作者 {0}，{1} {2}
vcs.log.details.committer.info.user=由 {0} 提交
vcs.log.details.showing.selected.commits=(正在顯示 {0}/{1} 個所選提交)
vcs.log.details.references.more.label=…其他 {0} 個
loading.commit.changes=正在載入提交變更
vcs.log.commit.details.status=提交詳細資訊

# changes browser
vcs.log.changes.select.commits.to.view.changes.status=選擇提交以查看變更
vcs.log.changes.no.merge.conflicts.status=沒有合併的衝突。
vcs.log.changes.show.changes.to.parents.status.action=顯示對父項的變更
vcs.log.changes.no.changes.that.affect.selected.paths.status=沒有影響所選路徑的變更。
vcs.log.changes.show.all.paths.status.action=顯示所有路徑的變更
vcs.log.changes.no.changes.that.affect.selected.filters.status=沒有與所選篩選器符合的變更。
vcs.log.changes.show.all.changes.status.action=顯示所有變更
vcs.log.changes.details.no.commits.selected.status=未選擇提交
vcs.log.changes.too.many.status={0,choice,1#此提交|2#所選提交之一}具有 {1} 個變更
vcs.log.changes.too.many.show.anyway.status.action=仍然顯示
vcs.log.changes.no.merge.conflicts.node=沒有合併的衝突
vcs.log.changes.changes.to.parent.node=對 {0} 的變更

# highlighters
vcs.log.action.highlight.current.branch=當前分支
vcs.log.action.highlight.indexed.commits=已編制索引的提交
vcs.log.action.highlight.merge.commits=合併提交
vcs.log.action.highlight.my.commits=我的提交

# messages
vcs.log.recreated.due.to.corruption=由於資料損壞，{0} 日誌已重新創建 {1} 次。\\\\n如果經常發生這種情況，請刪除 {2} 目錄並重新啟動 {3}。
vcs.log.fatal.error.message=無法清除 {0} 下的快取。\\\\n請手動刪除快取目錄，然後重新啟動 {1}。
vcs.log.is.not.available=VCS 日誌不可用

# caches invalidator
vcs.log.clear.caches.checkbox.description=清除 VCS 日誌快取和索引

# columns
vcs.log.column.subject=主題
vcs.log.column.author=作者
vcs.log.column.date=日期
vcs.log.column.hash=哈希

# graph
graph.sort.linear=線性
graph.sort.linear.description=合併時，在主分支提交的頂部顯示傳入提交，就好像對它們進行變基
graph.sort.standard=標準
graph.sort.standard.description=合併時，首先顯示傳入提交(合併提交正下方)
graph.sort.off=關閉
graph.sort.off.description=按日期以拓撲方式對提交進行排序
"
`;

// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`dev inspectionDescriptions/LeakableMapKey.html 1`] = `
"<html>
<body>
報告在延伸模組程式碼中將 <code>Language</code> 或 <code>FileType</code> 用作映射鍵。
<p>
  此類別用法可能導致無法正確解除安裝延伸模組。
</p>
<p>
  請考慮使用 <code>String</code> 作為鍵。
</p>
<p>
  有關更多資訊，請參閱 SDK 文檔中的<a href="https://plugins.jetbrains.com/docs/intellij/dynamic-plugins.html">動態延伸模組</a>。
</p>
</body>
</html>"
`;

exports[`dev messages/ActionsBundle.properties 1`] = `
"EmojiAndSymbols.text=表情 \\\\& 符號
MainToolbarQuickActions.General.separator=選項
MainToolbarQuickActions.run.separator=執行
Vcs.VcsClone.Project.text=來自版本控制的專案…
Vcs.VcsClone.Tabbed.Welcome.text=從 VCS 獲取
Vcs.VcsClone.Welcome.text=從版本控制中獲取
action.$Copy.description=複製到剪貼簿
action.$Copy.text=複製(_C)
action.$Cut.description=剪下到剪貼簿
action.$Cut.text=剪下(_T)
action.$Delete.description=刪除所選條目
action.$Delete.text=刪除(_D)
action.$Paste.description=從剪貼簿貼上
action.$Paste.text=貼上(_P)
action.$Redo.text=重做
action.$SearchWeb.description=使用 Google 搜尋選區
action.$SearchWeb.text=使用 Google 搜尋(_S)
action.$SelectAll.description=全選
action.$SelectAll.text=全選(_A)
action.$Undo.text=撤消
action.About.description=顯示有關 IDE 的資訊
action.About.description.specialized=顯示有關 {0} 的資訊
action.About.text=關於(_A)
action.ActionUpdatesBenchmarkAction.text=動作更新基準
action.Actions.ActionsPlugin.GenerateToString.description=生成 toString() 方法
action.Actions.ActionsPlugin.GenerateToString.text=to_String()
action.ActivateDebugToolWindow.text=偵錯
action.ActivateFindToolWindow.text=尋找
action.ActivateHierarchyToolWindow.text=層次結構
action.ActivateMeetNewUIToolWindow.text=認識新 UI
action.ActivateNavBar.description=啟用導覽列
action.ActivateNavBar.text=啟用導覽列(_B)
action.ActivateRunToolWindow.text=執行
action.AddAnotherBookmark.text=將書籤新增到另一個列表
action.AddBreakpoint.text=新增中斷點
action.AddConditionalBreakpoint.text=新增條件中斷點…
action.AddFrameworkSupport.text=新增框架支援…
action.AddGroupToTestSchemeAction.description=允許來自組的所有資料。使用它在本地測試新的收集器。
action.AddGroupToTestSchemeAction.text=將組新增到事件測試方案
action.AddInlayInternalAction.text=新增嵌入…
action.AddToScopeAction.text=新增到作用域
action.AnalyzeHeapDumpSnapshot.text=分析堆傾印
action.AnalyzePluginStartupPerformance.text=分析延伸模組啟動性能
action.AnimatorTestAction.text=測試 Animator
action.Annotate.description=顯示每行的最新修改日期和作者(也稱為“追溯”)
action.Annotate.synonym1=追溯
action.Annotate.text=註解(_N)
action.Annotate.with.Blame.text=使用 Git 追溯註解(_N)
action.AnnotateStackTraceAction.show.files.modification.info.text=顯示檔案修改資訊
action.AnonymousToInner.description=將匿名類別轉換為內部類別
action.AnonymousToInner.text=將匿名轉換成內部(_Y)…
action.ApplyFixedWindowSize.text=套用特定大小
action.AssociateWithFileType.description=將所選檔案關聯到某種檔案類型
action.AssociateWithFileType.text=與檔案類型關聯…
action.AttachDirectory.text=將目錄附加到專案…
action.AttachProject.text=附加專案…
action.AutoIndentLines.description=根據程式碼樣式設定縮排當前行或所選塊
action.AutoIndentLines.text=自動縮排行(_A)
action.AutoShowProcessWindow.description=啟動任何程序時顯示背景任務視窗
action.AutoShowProcessWindow.text=自動顯示
action.Back.description=撤消上次導覽動作
action.Back.text=後退(_B)
action.BookmarkOpenTabs.text=書籤開啟頁籤…
action.BookmarksView.AskBeforeDeletingLists.text=刪除多個書籤前詢問
action.BookmarksView.AutoscrollFromSource.text=始終選擇開啟的元素
action.BookmarksView.AutoscrollToSource.text=一鍵導覽
action.BookmarksView.ChooseType.text=更改助記鍵…
action.BookmarksView.Create.text=建立書籤列表…
action.BookmarksView.DefaultGroup.text=將列表標記為預設
action.BookmarksView.Delete.text=刪除
action.BookmarksView.DeleteType.text=移除助記鍵
action.BookmarksView.GroupLineBookmarks.text=按檔案將行書簽分組
action.BookmarksView.MoveDown.text=下移
action.BookmarksView.MoveUp.text=上移
action.BookmarksView.OpenInPreviewTab.text=覆寫助記鍵之前詢問
action.BookmarksView.Rename.text=編輯
action.BookmarksView.RewriteBookmarkType.text=啟用預覽頁籤
action.BookmarksView.ShowPreview.text=開啟編輯器預覽
action.BookmarksView.SortGroupBookmarks.text=按類型和名稱對書籤進行排序
action.BraceOrQuoteOut.text=跳到當前括號/引號
action.BrowseWeb.text=瀏覽 Web…
action.BuildArtifact.description=選擇並建置專案中組態的工件
action.BuildArtifact.text=建置工件…
action.CallHierarchy.BaseOnThisMethod.text=基於此方法
action.CallHierarchy.description=瀏覽所選方法的呼叫層次結構
action.CallHierarchy.text=呼叫層次結構(_Y)
action.CallSaul.description=執行快取診斷並嘗試恢復其狀態
action.CallSaul.on.file.text=修復{0, choice, 0#檔案|2#檔案}上的 IDE
action.CallSaul.text=修復 IDE
action.ChangeCodeStyleScheme.description=更改當前程式碼樣式方案
action.ChangeCodeStyleScheme.text=程式碼樣式方案
action.ChangeColorScheme.description=更改當前編輯器配色方案
action.ChangeColorScheme.text=編輯器配色方案
action.ChangeFileEncodingAction.description=更改檔案編碼
action.ChangeFileEncodingAction.text=檔案編碼
action.ChangeIdeScale.text=縮放
action.ChangeInspectionProfile.description=更改當前編輯器檢查組態檔案
action.ChangeInspectionProfile.text=錯誤醒目提示顯示
action.ChangeKeymap.description=更改當前按鍵映射
action.ChangeKeymap.text=按鍵映射
action.ChangeLaf.description=更改當前主題
action.ChangeLaf.text=主題
action.ChangeSignature.description=更改所選方法或類別的簽名，並更正所有參照
action.ChangeSignature.text=更改簽名(_G)…
action.ChangeSortingAction.text=按名稱排序
action.ChangeSplitOrientation.description=更改拆分器方向
action.ChangeSplitOrientation.text=更改拆分器方向(_R)
action.ChangeTemplateDataLanguage.text=更改模板資料語言
action.ChangeToThisFileTypeAction.description=將檔案類型覆寫為 ''{0}''
action.ChangeToolWindowLayout.text=布局
action.ChangeTypeSignature.description=更改方法、欄位、參數、變數或類別類型實參的返回值類型的類型，並更正所有參照
action.ChangeTypeSignature.text=類型遷移(_Y)…
action.ChangeView.description=更改檢視模式
action.ChangeView.text=檢視模式
action.ChangesView.AddUnversioned.description=排定將所選檔案新增到 VCS 的時間表
action.ChangesView.AddUnversioned.text=新增到 VCS
action.ChangesView.ApplyPatch.description=將補丁套用到專案的源
action.ChangesView.ApplyPatch.text=套用補丁…
action.ChangesView.ApplyPatchFromClipboard.description=將補丁套用到專案的源
action.ChangesView.ApplyPatchFromClipboard.text=從剪貼簿套用補丁…
action.ChangesView.Browse.description=檢視已提交更改的歷史記錄
action.ChangesView.Browse.text=瀏覽更改…
action.ChangesView.CreatePatch.description=從所選更改建立更新檔
action.ChangesView.CreatePatch.text=從本地更改建立更新檔…
action.ChangesView.CreatePatchFromChanges.description=從所選更改建立更新檔
action.ChangesView.CreatePatchFromChanges.text=建立更新檔…
action.ChangesView.CreatePatchToClipboard.description=從更改建立更新檔並將其複製到剪貼簿
action.ChangesView.CreatePatchToClipboard.text=作為補丁複製到剪貼簿
action.ChangesView.Edit.description=簽出所選檔案進行編輯
action.ChangesView.Edit.text=簽出
action.ChangesView.GroupBy.Directory.text=目錄
action.ChangesView.GroupBy.Module.text=模組
action.ChangesView.GroupBy.Repository.text=儲存庫
action.ChangesView.Move.Files.text=將檔案移至另一個更改列表…
action.ChangesView.Move.description=將所選更改移至另一個更改列表
action.ChangesView.Move.text=移至另一個更改列表…
action.ChangesView.NewChangeList.description=建立新的更改列表
action.ChangesView.NewChangeList.text=新增更改列表…
action.ChangesView.Refresh.MainMenu.text=重新整理 VCS 更改
action.ChangesView.Refresh.description=重新整理 VCS 更改
action.ChangesView.Refresh.text=重新整理
action.ChangesView.RemoveChangeList.description=移除更改列表並將所有更改移至其他更改列表
action.ChangesView.RemoveChangeList.description.template=移除{0,choice,0#更改列表|2#更改列表}和移動所有的改變到{1}
action.ChangesView.RemoveChangeList.text=刪除更改列表
action.ChangesView.RemoveChangeList.text.template=刪除{0,choice,0#更改列表|2#更改列表}
action.ChangesView.RemoveDeleted.description=排定將所選檔案從 VCS 移除的時間表
action.ChangesView.RemoveDeleted.text=從 VCS 移除
action.ChangesView.Rename.description=編輯所選更改列表的名稱和描述
action.ChangesView.Rename.text=編輯更改列表…
action.ChangesView.Revert.text=復原(_R)…
action.ChangesView.RevertFiles.text=復原檔案(_R)…
action.ChangesView.SaveToShelve.description=將所選更改複製到擱置的更改列表
action.ChangesView.SaveToShelve.text=儲存到擱置
action.ChangesView.SetDefault.description=設定預設情況下放置新更改的更改列表
action.ChangesView.SetDefault.text=設定活動更改列表
action.ChangesView.Shelve.description=將更改儲存到外部更新檔檔案，並將其從程式碼中移除
action.ChangesView.Shelve.text=擱置更改…
action.ChangesView.ShelveSilently.description=擱置對適當的已擱置更改列表的更改
action.ChangesView.ShelveSilently.text=無提示擱置
action.ChangesView.ShowCommitOptions.text=顯示提交選項
action.ChangesView.SingleClickPreview.text=預覽差異
action.ChangesView.ToggleCommitUi.text=切換提交 UI…
action.ChangesView.UnshelveSilently.description=取消擱置對相應更改列表的更改
action.ChangesView.UnshelveSilently.text=無提示取消擱置
action.CheckForUpdate.WelcomeScreen.text=檢查更新
action.CheckForUpdate.description=檢查可用的 IDE 和延伸模組更新
action.CheckForUpdate.description.plugins=檢查可用的延伸模組更新(IDE 更新在外部管理)
action.CheckForUpdate.text=檢查更新(_C)…
action.CheckIgnoredAndNotExcludedDirectories.description=檢查是否存在可以排除在索引和搜尋之外的已忽略目錄
action.CheckIgnoredAndNotExcludedDirectories.progress=正在檢查已忽略但未排除的目錄…
action.CheckIgnoredAndNotExcludedDirectories.text=檢查已忽略但未排除的目錄
action.CheckStatusForFiles.text=檢查狀態(_K)
action.CheckSuggestedPlugins.text=檢查建議的延伸模組
action.CheckVfsSanity.progress=檢查 VFS 執行狀況(檢視日誌中的結果)
action.CheckVfsSanity.text=執行 VFS 執行狀況檢查
action.CheckinFiles.description=提交選中的檔案或目錄
action.CheckinFiles.text=提交檔案(_I)
action.CheckinProject.text=提交(_I)…
action.ChooseDebugConfiguration.description=選擇並偵錯組態
action.ChooseDebugConfiguration.text=偵錯…
action.ChooseRunConfiguration.description=選擇並執行組態
action.ChooseRunConfiguration.text=執行…
action.ChooseRuntime.text=選擇 IDE 的啟動 Java Runtime…
action.ClassNameCompletion.description=與雙擊基本補全快捷鍵相同(可用於補全非匯入類別名)
action.ClassNameCompletion.text=第二基本補全
action.CleanupEventsTestSchemeAction.description=移除測試方案中註冊的所有組
action.CleanupEventsTestSchemeAction.text=清理事件測試方案
action.ClickLink.text=點擊連結
action.CloseActiveTab.description=關閉活動工具視窗頁籤
action.CloseActiveTab.text=關閉活動頁籤(_O)
action.CloseAllEditors.description=在活動頁籤組中關閉所有編輯視窗
action.CloseAllEditors.text=關閉所有頁籤(_A)
action.CloseAllEditorsButActive.description=除活動編輯視窗外關閉所有其他視窗
action.CloseAllEditorsButActive.text=關閉其他頁籤(_O)
action.CloseAllNotifications.text=關閉所有
action.CloseAllProjects.description=關閉所有專案
action.CloseAllProjects.text=關閉所有專案
action.CloseAllReadonly.description=關閉具有唯讀檔案的所有編輯器
action.CloseAllReadonly.text=關閉所有唯讀頁籤
action.CloseAllToTheLeft.description=關閉左邊的所有編輯器
action.CloseAllToTheLeft.text=關閉左側頁籤
action.CloseAllToTheRight.description=關閉右邊的所有編輯器
action.CloseAllToTheRight.text=關閉右側頁籤
action.CloseAllUnmodifiedEditors.description=關閉所有未修改的編輯視窗
action.CloseAllUnmodifiedEditors.text=關閉未修改頁籤(_U)
action.CloseAllUnpinnedEditors.description=關閉所有未固定的編輯視窗
action.CloseAllUnpinnedEditors.text=關閉所有未固定
action.CloseContent.EditorTabPopup.text=關閉(_C)
action.CloseContent.description=關閉當前焦點的內容
action.CloseContent.text=關閉頁籤(_C)
action.CloseEditor.EditorPopup.text=關閉 (_C)
action.CloseEditor.EditorTabPopup.text=關閉(_C)
action.CloseEditor.description=關閉活動編輯器
action.CloseEditor.text=關閉活動編輯器(_C)
action.CloseFirstNotification.text=關閉第一個
action.CloseGotItTooltip.text=關閉“知道了”工具提示
action.CloseOtherProjects.description=關閉其他專案
action.CloseOtherProjects.text=關閉其他專案
action.CloseProject.description=關閉當前專案
action.CloseProject.text=關閉專案(_J)
action.CodeCleanup.description=執行清理檢查並套用快速修復
action.CodeCleanup.text=程式碼清理(_C)…
action.CodeCompletion.description=補全程式碼
action.CodeCompletion.text=基本(_B)
action.CodeInspection.OnEditor.description=使用編輯器設定檢查程式碼(_E)
action.CodeInspection.OnEditor.text=使用編輯器設定檢查程式碼(_E)
action.CollapseAll.text=全部摺疊
action.CollapseAllRegions.description=摺疊所有折疊區域(選區中)
action.CollapseAllRegions.text=全部摺疊(_A)
action.CollapseBlock.description=折疊當前程式碼塊
action.CollapseBlock.text=折疊程式碼塊(_B)
action.CollapseDocComments.description=摺疊所有文檔註釋
action.CollapseDocComments.text=摺疊文檔註釋(_O)
action.CollapseExpandableComponent.text=摺疊元件
action.CollapseRegion.description=摺疊文字游標處的折疊區域
action.CollapseRegion.text=摺疊(_C)
action.CollapseRegionRecursively.description=遞迴摺疊文字游標處的塊
action.CollapseRegionRecursively.text=遞迴折疊(_A)
action.CollapseSelection.description=折疊所選塊
action.CollapseSelection.text=折疊選區/移除區域(_S)
action.CollapseTreeNode.text=摺疊樹節點
action.CollapsiblePanel-toggle.text=展開/摺疊可折疊面板
action.CollectFUStatisticsAction.text=從收集器收集統計資訊…
action.CollectTroubleshootingInformation.text=收集故障排除資訊
action.CollectZippedLogs.description=將日誌和設定壓縮到檔案中
action.CollectZippedLogs.text=收集日誌和診斷資料
action.ColorBlindnessTest.text=測試色盲
action.ColoredHeaderAction.text=Show Project Gradient
action.CommentByBlockComment.description=使用塊註釋註釋/取消程式碼
action.CommentByBlockComment.text=使用塊註釋進行註釋(_B)
action.CommentByLineComment.description=使用行註釋註釋/取消註釋當前行或所選塊
action.CommentByLineComment.text=使用行註釋進行註釋(_L)
action.CommitView.ShowOnDoubleClick.EditorPreview.ToolwindowPopup.text=差異
action.CommitView.ShowOnDoubleClick.EditorPreview.text=雙擊時顯示差異
action.CommitView.ShowOnDoubleClick.Source.ToolwindowPopup.text=源
action.CommitView.ShowOnDoubleClick.Source.text=雙擊時顯示源
action.CommitView.SwitchToCommitDialog.text=切換到“提交”對話框
action.CommittedChanges.Clear.description=清除快取的修訂版本
action.CommittedChanges.Clear.text=清除
action.CommittedChanges.Details.description=檢視所選更改列表的完整資訊
action.CommittedChanges.Details.text=顯示詳細資訊
action.CommittedChanges.Filter.description=更改篩選條件
action.CommittedChanges.Filter.text=篩選
action.CommittedChanges.Refresh.description=重新整理已提交更改的列表
action.CommittedChanges.Refresh.text=重新整理
action.CommittedChanges.Revert.description=將所選更改的反向動作應用於工作副本
action.CommittedChanges.Revert.text=還原更改
action.Compare.LastVersion.text=與最新的儲存庫版本進行比較(_V)
action.Compare.SameVersion.text=與同一個儲存庫版本進行比較(_Y)
action.Compare.Selected.text=與修訂比較(_C)…
action.Compare.Specified.text=與指定修訂比較(_P)…
action.CompareClipboardWithSelection.description=將當前選區與剪貼簿進行比較
action.CompareClipboardWithSelection.text=與剪貼簿比較(_B)
action.CompareDirs.text=比較目錄
action.CompareFileWithEditor.description=將所選檔案與編輯器中的檔案進行比較
action.CompareFileWithEditor.text=與編輯器比較檔案(_M)
action.CompareKeymaps.text=比較按鍵映射…
action.CompareTwoFiles.description=比較兩個所選檔案或目錄
action.CompareTwoFiles.text=比較檔案(_F)
action.Compile.description=強制重新編譯所選模組、檔案或軟體套件
action.Compile.text=重新建置(_E)
action.CompileDirty.description=編譯專案中的所有修改和相依檔案
action.CompileDirty.text=建置專案(_P)
action.CompileFile.text=重新編譯(_E)
action.CompileProject.description=重新編譯專案中的所有檔案
action.CompileProject.text=重新建置專案(_R)
action.CompletionQualityStats.text=補全品質統計資訊
action.ComponentPanelTestAction.text=顯示標準面板
action.ComponentsTestAction.text=顯示元件測試
action.ComputeVirtualFileNameStatAction.text=計算 VF 名稱統計資訊
action.ConfigureDefaultSize.text=組態預設大小…
action.ConfigureEditorTabs.description=組態編輯器頁籤的外觀，行為和順序
action.ConfigureEditorTabs.text=組態編輯器頁籤…
action.ConfigureEventsSchemeFileAction.description=載入自訂目錄中的事件方案
action.ConfigureEventsSchemeFileAction.text=組態事件方案檔案
action.ConfigureScopesAction.text=組態…
action.ConfigureSoftWraps.text=組態自動換行
action.ConfigureTemplatesAction.text=組態實時模板…
action.Console.Execute.Multiline.description=在多行主控台中執行當前語句
action.Console.Execute.Multiline.text=在多行主控台中執行當前語句
action.Console.Execute.description=在單行主控台中執行當前語句
action.Console.Execute.text=在單行主控台中執行當前語句
action.Console.History.Browse.description=瀏覽查詢歷史記錄
action.Console.History.Browse.text=瀏覽查詢歷史記錄
action.Console.History.Next.description=主控台歷史記錄中的下一個條目
action.Console.History.Next.text=主控台歷史記錄中的下一個條目
action.Console.History.Previous.description=主控台歷史記錄中的上一個條目
action.Console.History.Previous.text=主控台歷史記錄中的上一個條目
action.Console.Open.description=為所選實體開啟主控台
action.Console.Open.text=開啟主控台
action.Console.SplitLine.text=拆分行
action.ConsoleView.FoldLinesLikeThis.text=像這樣折疊行
action.ContextHelp.description=顯示上下文幫助
action.ContextHelp.text=上下文幫助(_X)
action.ConvertIndentsToSpaces.description=轉換檔案或所選塊中的縮排，以使用空格代替制表符
action.ConvertIndentsToSpaces.text=轉換為空格
action.ConvertIndentsToTabs.description=轉換檔案或所選塊中的縮排，以使用制表符代替空格
action.ConvertIndentsToTabs.text=轉換為制表符
action.ConvertToInstanceMethod.description=將 static 方法轉換為執行個體方法並更正所有參照
action.ConvertToInstanceMethod.text=轉換為執行個體方法(_O)…
action.CopyAbsolutePath.text=絕對路徑
action.CopyAsPlainText.description=將選區複製到剪貼簿作為純文本
action.CopyAsPlainText.text=複製為純文本
action.CopyAsRichText.description=將選區複製到剪貼簿作為富文本(以 RTF 和 HTML 格式)
action.CopyAsRichText.text=複製為富文本
action.CopyContentRootPath.text=來自內容根的路徑
action.CopyElement.description=建立所選類別、檔案或目錄的副本
action.CopyElement.text=複製(_O)…
action.CopyFileName.text=檔名
action.CopyPathWithLineNumber.text=帶行號的路徑
action.CopyPaths.description=將與所選檔案或目錄對應的路徑複製到剪貼簿
action.CopyPaths.text=複製路徑(_O)
action.CopyReference.description=複製對所選類別、方法、函式或所選檔案的相對路徑的參照
action.CopyReference.text=複製參照(_Y)
action.CopySettingsPath.description=複製選定可組態選項的相對路徑
action.CopySourceRootPath.text=來自來來源根的路徑
action.CopyTBXReference.text=工具箱 URL
action.CopyUiLabel.text=複製 UI 標籤
action.CopyUrl.description=將文字游標下的 URL 複製到剪貼簿
action.CopyUrl.text=複製 URL
action.CreateDesktopEntry.description=建立桌面條目以與系統應用程式選單整合
action.CreateDesktopEntry.text=建立桌面條目…
action.CreateLauncherScript.description=使 IDE 可從命令行存取
action.CreateLauncherScript.text=建立命令行啟動器…
action.CreateLibraryFromFile.text=新增為庫…
action.CustomLayoutActionsGroup.Rename.description=重新命名當前布局({0})
action.CustomLayoutActionsGroup.Rename.text=重新命名(_R)
action.CustomizeUIAction.text=自訂選單與工具列…
action.DebugBuildProcess.description=如果啟用，建置過程將在啟動時等待偵錯連線
action.DebugBuildProcess.text=偵錯建置過程
action.DebugListen.text=拋出偵錯異常
action.Debugger.AddInlineWatch.text=新增內聯監視
action.Debugger.AddSteppingFilter.text=新增步進篩選器…
action.Debugger.AddToWatch.text=新增到監視
action.Debugger.AdjustArrayRange.text=調整範圍…
action.Debugger.AsyncStacks.text=異步堆疊追蹤
action.Debugger.AutoRenderer.text=自動
action.Debugger.CallTracer.text=追蹤呼叫
action.Debugger.CopyStack.text=複製堆疊
action.Debugger.CreateRenderer.XDebuggerTreePopup.text=建立呈現器
action.Debugger.CreateRenderer.text=建立…
action.Debugger.CustomizeContextView.text=自訂資料檢視…
action.Debugger.CustomizeThreadsView.text=自訂執行緒檢視…
action.Debugger.EditArrayFilter.text=編輯…
action.Debugger.EditCustomField.text=編輯…
action.Debugger.EditFrameSource.text=EditFrameSource
action.Debugger.EvaluateInConsole.text=在主控台中求值
action.Debugger.FilterArray.text=篩選…
action.Debugger.FocusOnBreakpoint.description=到達中斷點時預設切換到此檢視
action.Debugger.FocusOnBreakpoint.text=在中斷點時獲取焦點
action.Debugger.FocusOnFinish.description=預設情況下，在偵錯會話結束時聚焦此檢視
action.Debugger.FocusOnFinish.text=完成後聚焦
action.Debugger.ForceEarlyReturn.description=強制方法在到達 return 語句之前返回
action.Debugger.ForceEarlyReturn.text=強制返回
action.Debugger.FreezeThread.text=掛起
action.Debugger.InterruptThread.text=中斷
action.Debugger.MarkObject.description=標記/取消標記物件，以便可以在偵錯器檢視中直觀區分
action.Debugger.MarkObject.text=標記物件…
action.Debugger.MarkObject.unmark.text=取消標記物件
action.Debugger.MuteRenderers.text=忽略呈現器
action.Debugger.NewCustomField.text=新增類別級別監視…
action.Debugger.PopFrame.description=將執行點移回方法呼叫，從堆疊中丟棄當前的方法幀
action.Debugger.PopFrame.text=重設幀(_F)
action.Debugger.ReloadFile.text=編譯並重新載入檔案
action.Debugger.RemoveAllBreakpoints.text=移除所有中斷點
action.Debugger.RemoveAllBreakpointsInFile.text=移除當前檔案中的所有中斷點
action.Debugger.RemoveArrayFilter.text=移除篩選器
action.Debugger.RemoveCustomField.text=移除監視
action.Debugger.RestoreBreakpoint.description=還原上次刪除的中斷點
action.Debugger.RestoreBreakpoint.text=還原中斷點
action.Debugger.ResumeThread.text=恢復
action.Debugger.ShowCollectionHistory.text=顯示集合歷史記錄
action.Debugger.ShowLibraryFrames.text=顯示/隱藏庫框架
action.Debugger.ShowReferring.text=顯示參照物件…
action.Debugger.ShowRelatedStack.text=顯示相關堆疊…
action.Debugger.ShowTypes.text=顯示類型
action.Debugger.StepOutOfBlock.text=單步跳出程式碼塊
action.Debugger.SwitchToTheNextContext.text=切換到下一個停止的中斷點
action.Debugger.ThrowException.description=拋出一個異常
action.Debugger.ThrowException.text=拋出異常
action.Debugger.Tree.EvaluateInConsole.text=在主控台中求值
action.Debugger.ViewEditText.text=檢視/編輯文本
action.Debugger.ViewText.description=在單獨的窗格中檢視所選節點的文本值
action.Debugger.ViewText.text=檢視文本
action.Debugger.XDebuggerTextPopup.ShowAsObject.text=顯示為物件
action.DecrementWindowHeight.text=減小高度
action.DecrementWindowWidth.text=減小寬度
action.DelegateMethods.description=為欄位/getter 生成委託方法
action.DelegateMethods.text=委託方法...(_D)
action.DeleteMnemonicFromBookmark.text=移除助記鍵
action.DeleteOldAppDirs.description=尋找以前 IDE 版本中的設定、快取和日誌目錄
action.DeleteOldAppDirs.text=刪除殘留的 IDE 目錄…
action.DeleteRecentFiles.description=從最近的檔案中刪除所選檔案或關閉所選工具視窗
action.DeleteRecentFiles.text=從最近的檔案中刪除
action.DetachDirectory.text=從專案中分離目錄…
action.Diff.AppendLeftSide.text=追加左側
action.Diff.AppendRightSide.text=追加右側
action.Diff.ApplyLeftSide.text=接受左側
action.Diff.ApplyNonConflicts.Left.text=從左側套用不衝突的更改
action.Diff.ApplyNonConflicts.Right.text=從右側套用不衝突的更改
action.Diff.ApplyNonConflicts.text=套用所有不衝突的更改
action.Diff.ApplyRightSide.text=接受右側
action.Diff.ComparePartial.Base.Left.text=左和中
action.Diff.ComparePartial.Base.Right.text=中和右
action.Diff.ComparePartial.Generic={0,choice,0#左|1#中|2#右} 和 {1,choice,0#左|1#中|2#右}
action.Diff.ComparePartial.Left.Right.text=左和右
action.Diff.CompareWithBase.Left.text=基礎和左
action.Diff.CompareWithBase.Result.text=基礎和中
action.Diff.CompareWithBase.Right.text=基礎和右
action.Diff.FocusOppositePane.description=在差異檢視中選擇相對窗格
action.Diff.FocusOppositePane.text=選擇相對差異窗格
action.Diff.FocusOppositePaneAndScroll.description=在差異檢視的相對窗格中選擇相同的位置
action.Diff.FocusOppositePaneAndScroll.text=在相對差異窗格中選擇位置
action.Diff.IgnoreLeftSide.text=忽略左側
action.Diff.IgnoreRightSide.text=忽略右側
action.Diff.MagicResolveConflicts.text=解決簡單的衝突
action.Diff.NextChange.text=比較下一個檔案
action.Diff.NextConflict.description=移至下一個未解決的衝突
action.Diff.NextConflict.text=下一個衝突
action.Diff.OpenDiffInEditor.text=作為編輯器頁籤開啟選定的差異請求
action.Diff.PrevChange.text=比較上一個檔案
action.Diff.PreviousConflict.description=移至上一個未解決的衝突
action.Diff.PreviousConflict.text=上一個衝突
action.Diff.ResolveConflict.text=自動解決
action.Diff.ShowDiff.description=比較檔案或修訂。
action.Diff.ShowDiff.text=顯示差異
action.Diff.ShowDiffPreview.description=選區更改時取代差異內容
action.Diff.ShowInExternalTool.text=在外部工具中顯示差異
action.Diff.ShowSettingsPopup.text=顯示差異設定彈出視窗…
action.Diff.ShowStandaloneDiff.description=在新頁籤或視窗中開啟每個選區的差異
action.Diff.ShowStandaloneDiff.tab.description=在新頁籤中開啟每個選區的差異
action.Diff.ShowStandaloneDiff.tab.text=在新頁籤中顯示差異
action.Diff.ShowStandaloneDiff.text=在新頁籤或視窗中顯示差異
action.Diff.ShowStandaloneDiff.window.description=在新視窗中開啟每個選區的差異
action.Diff.ShowStandaloneDiff.window.text=在新視窗中顯示差異
action.DirDiffMenu.CancelComparingNewFilesWithEachOther.text=取消相互比較新檔案
action.DirDiffMenu.CompareNewFilesWithEachOtherAction.text=相互比較新檔案
action.DirDiffMenu.EnableEqual.text=顯示相同的檔案
action.DirDiffMenu.EnableLeft.text=在左側顯示新檔案
action.DirDiffMenu.EnableNotEqual.text=顯示差異
action.DirDiffMenu.EnableRight.text=在右側顯示新檔案
action.DirDiffMenu.MirrorToLeft.text=設定鏡像到左側
action.DirDiffMenu.MirrorToRight.text=設定鏡像到右側
action.DirDiffMenu.SetCopyToLeft.text=設定複製到左側
action.DirDiffMenu.SetCopyToRight.text=設定複製到右側
action.DirDiffMenu.SetDefault.text=設定預設值
action.DirDiffMenu.SetDelete.text=設定刪除
action.DirDiffMenu.SetNoOperation.text=設定不執行任何動作
action.DirDiffMenu.SynchronizeDiff.All.text=全部同步
action.DirDiffMenu.SynchronizeDiff.text=同步選定項
action.DirDiffMenu.WarnOnDeletion.text=刪除時發出警告
action.DisableNewUi.description=切換為經典 UI
action.DisableNewUi.text=切換為經典 UI…
action.DockPinnedMode.description=使工具視窗停靠並固定
action.DockPinnedMode.text=停靠固定(_P)
action.DockToolWindow.text=Dock
action.DockUnpinnedMode.description=使工具視窗停靠但焦點丟失時自動隱藏
action.DockUnpinnedMode.text=停靠不固定(_U)
action.Document2XSD.text=從 XSD 架構生成 XML 文檔…
action.Documentation.Back.text=後退
action.Documentation.EditSource.text=跳轉到源(_J)
action.Documentation.Forward.text=前進
action.Documentation.KeepTab.description=關閉當前頁籤中的所有更新，使下一個動作呼叫開啟新的頁籤
action.Documentation.KeepTab.text=保留此文檔
action.Documentation.ToggleAutoShow.description=切換是否使用補全彈出視窗自動顯示文檔
action.Documentation.ToggleAutoShow.text=在補全期間自動顯示
action.Documentation.ToggleAutoUpdate.description=選區更改時自動重新整理文檔
action.Documentation.ToggleAutoUpdate.text=從源自動更新
action.Documentation.ToggleShowInPopup.description=切換是否應在工具視窗之前顯示“文檔”彈出視窗
action.Documentation.ToggleShowInPopup.text=首先顯示“文檔”彈出視窗
action.Documentation.ViewExternal.text=檢視外部文檔
action.DomCollectionControl.Add.text=新增
action.DomCollectionControl.Edit.text=編輯
action.DomCollectionControl.Remove.text=移除
action.DumbMode.text=沉默模式
action.DumpConfigurationTypesAction.text=傾印組態
action.DumpExtensions.text=傾印副檔名
action.DumpFeaturesAndTips.description=將有關功能和提示檔案的資訊複製到剪貼簿
action.DumpFeaturesAndTips.text=傾印功能和提示資訊(_D)
action.DumpFocusableComponentHierarchyAction.text=傾印可聚焦元件層次結構
action.DumpFormattingModelAction.text=傾印格式化模型
action.DumpIElementTypesAction.text=傾印 IElementType 註冊表
action.DumpInspectionDescriptions.text=傾印檢查描述
action.DumpInspectionDescriptionsAction.text=傾印檢查描述
action.DumpIntentionsAction.text=傾印意圖
action.DumpIntentionsDescriptions.text=傾印意圖描述
action.DumpInvalidTipsOfTheDay.text=傾印無效的每日小技巧
action.DumpLibraryUsageStatistics.text=傾印庫用法的統計資訊
action.DumpLoadedInspectionsAction.text=傾印已初始化的檢查
action.DumpLookupElementWeights.text=將尋找元素權重傾印到日誌
action.DumpScreenConfiguration.text=傾印螢幕組態
action.DumpThreads.text=獲取執行緒傾印
action.DumpVfsInfoForExcludedFilesAction.text=傾印排除根下檔案的 VFS 內容
action.DumpWatchedRoots.text=顯示監視的 VFS 根
action.DupLocate.description=尋找專案中的重複程式碼
action.DupLocate.text=定位重複項(_L)…
action.EditBookmark.text=重新命名書籤…
action.EditBreakpoint.text=編輯中斷點
action.EditCustomProperties.description=開啟帶有自訂屬性檔案的編輯器頁籤
action.EditCustomProperties.text=編輯自定義屬性…
action.EditCustomVmOptions.description=開啟帶有自訂虛擬機選項檔案的編輯器頁籤
action.EditCustomVmOptions.text=編輯自定義虛擬機選項…
action.EditMacros.description=組態現有巨集
action.EditMacros.text=編輯巨集(_E)
action.EditSource.description=開啟所選條目的編輯器並使之獲得焦點
action.EditSource.text=跳轉到源(_J)
action.EditSourceInNewWindow.EditorTabPopup.text=將頁籤移至新視窗
action.EditSourceInNewWindow.description=在新視窗開啟所選條目的編輯器並使之獲得焦點
action.EditSourceInNewWindow.text=在新視窗中開啟源
action.EditSourceNotInEditor.text=編輯源(不在編輯器中)
action.EditTestSchemeAction.description=允許來自組的所有資料。使用它在本地測試新的收集器。
action.EditTestSchemeAction.text=編輯事件測試方案
action.EditorAddCaretPerSelectedLine.text=在所選行的末尾新增文字游標
action.EditorAddOrRemoveCaret.description=在當前檔案中設定多個游標，以同時編輯多行程式碼。
action.EditorAddOrRemoveCaret.text=新增或移除文字游標
action.EditorAddRectangularSelectionOnMouseDrag.text=拖動滑鼠時新增矩形選區
action.EditorBackSpace.text=退格
action.EditorBackwardParagraph.text=將文字游標後移一段
action.EditorBackwardParagraphWithSelection.text=在保持選區的情況下將文字游標後移一段
action.EditorBreadcrumbsHideBoth.description=隱藏路徑導覽列
action.EditorBreadcrumbsHideBoth.text=不顯示
action.EditorBreadcrumbsShowAbove.description=在文本編輯器上方顯示路徑導覽列
action.EditorBreadcrumbsShowAbove.text=頂部
action.EditorBreadcrumbsShowBelow.description=在文本編輯器下方顯示路徑導覽列
action.EditorBreadcrumbsShowBelow.text=底部
action.EditorChooseLookupItem.text=選擇查詢條目
action.EditorChooseLookupItemCompleteStatement.text=選擇查詢條目並呼叫語句補全
action.EditorChooseLookupItemDot.text=選擇查詢條目並插入點
action.EditorChooseLookupItemReplace.text=選擇查詢條目取代
action.EditorCloneCaretAbove.description=在上面的行中插入一個輔助游標，以同時編輯多行程式碼。
action.EditorCloneCaretAbove.text=在上方克隆文字游標
action.EditorCloneCaretBelow.description=在下面的行中插入一個輔助游標，以同時編輯多行程式碼。
action.EditorCloneCaretBelow.text=在下方克隆文字游標
action.EditorCodeBlockEnd.text=將文字游標移至程式碼塊結束
action.EditorCodeBlockEndWithSelection.text=在保持選區的情況下將文字游標移至程式碼塊結束
action.EditorCodeBlockStart.text=將文字游標移至程式碼塊開始
action.EditorCodeBlockStartWithSelection.text=在保持選區的情況下將文字游標移至程式碼塊開始
action.EditorCompleteStatement.text=補全當前語句
action.EditorConsoleScrollToTheEnd.text=滾動到結尾
action.EditorContextInfo.description=不可見時，顯示當前方法或類別宣告
action.EditorContextInfo.text=上下文資訊(_C)
action.EditorCopy.text=複製
action.EditorCreateRectangularSelection.text=建立矩形選區
action.EditorCreateRectangularSelectionOnMouseDrag.text=拖動滑鼠建立矩形選區
action.EditorCut.text=剪下
action.EditorCutLineBackward.text=反向剪下行
action.EditorCutLineEnd.text=剪下到行尾
action.EditorDecreaseFontSize.text=減小字體大小
action.EditorDelete.text=刪除
action.EditorDeleteLine.text=刪除行
action.EditorDeleteToLineEnd.text=刪除到行尾
action.EditorDeleteToLineStart.text=刪除到行首
action.EditorDeleteToWordEnd.text=刪除到詞尾
action.EditorDeleteToWordEndInDifferentHumpsMode.text=在不同的 "CamelHumps" 模式下刪除到詞尾
action.EditorDeleteToWordStart.text=刪除到詞首
action.EditorDeleteToWordStartInDifferentHumpsMode.text=在不同的 "CamelHumps" 模式下刪除到詞首
action.EditorDown.text=下
action.EditorDownWithSelection.text=在保持選區的情況下向下
action.EditorDuplicate.text=重複行或選區
action.EditorDuplicateLines.text=重複整行
action.EditorEnter.text=Enter
action.EditorEscape.text=Esc
action.EditorFocusGutter.text=焦點裝訂區域(無障礙功能)
action.EditorForwardParagraph.text=將文字游標前移一段
action.EditorForwardParagraphWithSelection.text=在保持選區的情況下將文字游標前移一段
action.EditorGutterToggleGlobalIndentLines.text=顯示縮排參考線
action.EditorGutterToggleGlobalLineNumbers.text=顯示行號
action.EditorGutterToggleLocalSoftWraps.gutterText=自動換行當前編輯器
action.EditorHungryBackSpace.description=與退格鍵的作用相同，但也會移除文字游標前的所有空白符號(如有)
action.EditorHungryBackSpace.text=飢餓退格
action.EditorIncreaseFontSize.text=增大字體大小
action.EditorIndentLineOrSelection.text=縮排行或選區
action.EditorIndentSelection.text=縮排選區
action.EditorJoinLines.text=合併行
action.EditorKillRegion.text=終止所選區域
action.EditorKillRingSave.text=儲存至終止環
action.EditorKillToWordEnd.text=終止至詞尾
action.EditorKillToWordStart.text=終止至詞首
action.EditorLeft.text=左
action.EditorLeftWithSelection.text=在保持選區的情況下向左
action.EditorLineEnd.text=將文字游標移至行尾
action.EditorLineEndWithSelection.text=在保持選區的情況下將文字游標移至行尾
action.EditorLineStart.text=將文字游標移至行首
action.EditorLineStartWithSelection.text=在保持選區的情況下將文字游標移至行首
action.EditorLookupDown.text=向下尋找
action.EditorLookupSelectionDown.text=選擇下一個補全選項
action.EditorLookupSelectionUp.text=選擇上一個補全選項
action.EditorLookupUp.text=向上尋找
action.EditorMatchBrace.text=將文字游標移至符合的大括號
action.EditorMoveDownAndScroll.text=向下移動並滾動
action.EditorMoveDownAndScrollWithSelection.text=在保持選區的情況下向下移動並滾動
action.EditorMoveToPageBottom.text=將文字游標移至頁面底部
action.EditorMoveToPageBottomWithSelection.text=在保持選區的情況下將文字游標移至頁面底部
action.EditorMoveToPageTop.text=將文字游標移至頁面頂部
action.EditorMoveToPageTopWithSelection.text=在保持選區的情況下將文字游標移至頁面頂部
action.EditorMoveUpAndScroll.text=向上移動並滾動
action.EditorMoveUpAndScrollWithSelection.text=在保持選區的情況下向上移動並滾動
action.EditorNextWord.text=將文字游標移至下一個單詞
action.EditorNextWordInDifferentHumpsMode.text=在不同的 "CamelHumps" 模式下將文字游標移至下一個單詞
action.EditorNextWordInDifferentHumpsModeWithSelection.text=在不同的 "CamelHumps" 模式下保持選區的情況下將文字游標移至下一個單詞
action.EditorNextWordWithSelection.text=在保持選區的情況下將文字游標移至下一個單詞
action.EditorPageDown.text=向下翻頁
action.EditorPageDownWithSelection.text=在保持選區的情況下向下翻頁
action.EditorPageUp.text=向上翻頁
action.EditorPageUpWithSelection.text=在保持選區的情況下向上翻頁
action.EditorPaste.text=貼上
action.EditorPasteFromX11.text=從 X 剪貼簿貼上
action.EditorPasteSimple.description=貼上，不進行格式化、自動匯入、文字轉義等。
action.EditorPasteSimple.text=貼上為純文本(_L)
action.EditorPreviousWord.text=將文字游標移至上一個單詞
action.EditorPreviousWordInDifferentHumpsMode.text=在不同的 "CamelHumps" 模式下將文字游標移至上一個單詞
action.EditorPreviousWordInDifferentHumpsModeWithSelection.text=在不同的 "CamelHumps" 模式下保持選區的情況下將文字游標移至上一個單詞
action.EditorPreviousWordWithSelection.text=在保持選區的情況下將文字游標移至上一個單詞
action.EditorRenderingBenchmarkAction.text=編輯器渲染基準
action.EditorResetFontSize.text=重設字體大小
action.EditorReverseLines.text=反轉行
action.EditorRight.text=右
action.EditorRightWithSelection.text=在保持選區的情況下向右
action.EditorScrollBottom.text=滾動到底部
action.EditorScrollDown.text=向下滾動
action.EditorScrollDownAndMove.text=向下滾動並根據需要移動
action.EditorScrollLeft.text=向左滾動
action.EditorScrollRight.text=向右滾動
action.EditorScrollToCenter.text=滾動到中心
action.EditorScrollTop.text=滾動到頂部
action.EditorScrollUp.text=向上滾動
action.EditorScrollUpAndMove.text=向上滾動並根據需要移動
action.EditorSelectLine.text=擴展行選區
action.EditorSelectSingleLineAtCaret.text=選擇文字游標處的一行
action.EditorSelectWord.text=擴展選區
action.EditorSetContentBasedBidiTextDirection.description=方向由初始字元決定
action.EditorSetContentBasedBidiTextDirection.text=基於內容
action.EditorSetLtrBidiTextDirection.text=左到右
action.EditorSetRtlBidiTextDirection.text=右到左
action.EditorShowGutterIconTooltip.text=顯示裝訂區域圖示工具提示(無障礙功能)
action.EditorSortLines.text=排序行
action.EditorSplitLine.text=拆分行
action.EditorStartNewLine.text=開始新行
action.EditorStartNewLineBefore.text=在當前行之前開始新行
action.EditorSwapSelectionBoundaries.text=交換選區邊界
action.EditorTab.text=頁籤
action.EditorTextEnd.text=將文字游標移至文本結束
action.EditorTextEndWithSelection.text=在保持選區的情況下將文字游標移至文本結束
action.EditorTextStart.text=將文字游標移至文本開始
action.EditorTextStartWithSelection.text=在保持選區的情況下將文字游標移至文本開始
action.EditorToggleCase.text=切換大小寫
action.EditorToggleColumnMode.description=在當前編輯器中切換列選擇模式
action.EditorToggleColumnMode.text=列選擇模式(_M)
action.EditorToggleInsertState.text=切換插入/覆蓋
action.EditorToggleShowBreadcrumbs.description=在當前編輯器中切換顯示路徑導覽列
action.EditorToggleShowBreadcrumbs.text=顯示路徑導覽
action.EditorToggleShowGutterIcons.description=在當前編輯器中切換顯示裝訂區域圖示
action.EditorToggleShowGutterIcons.text=顯示裝訂區域圖示 (_O)
action.EditorToggleShowIndentLines.description=在當前編輯器中切換顯示縮排參考線
action.EditorToggleShowIndentLines.text=顯示縮排參考線(_O)
action.EditorToggleShowLineNumbers.description=在當前編輯器中切換顯示行號
action.EditorToggleShowLineNumbers.text=顯示行號(_I)
action.EditorToggleShowWhitespaces.description=在當前編輯器中切換顯示空格
action.EditorToggleShowWhitespaces.text=顯示空格(_O)
action.EditorToggleStickySelection.text=切換粘性選區
action.EditorToggleUseSoftWraps.description=在當前編輯器中切換使用自動換行
action.EditorToggleUseSoftWraps.text=自動換行
action.EditorToggleUseSoftWrapsInPreview.description=在預覽編輯器中切換使用自動換行
action.EditorToggleUseSoftWrapsInPreview.text=自動換行預覽編輯器
action.EditorToggleVisualFormattingLayer.description=使用視覺嵌入和折疊，根據您的程式碼樣式採用空格
action.EditorToggleVisualFormattingLayer.text=切換視覺格式化層
action.EditorTranspose.text=轉置
action.EditorUnSelectWord.text=收縮選區
action.EditorUnindentSelection.text=取消縮排行或選區
action.EditorUp.text=上
action.EditorUpWithSelection.text=在保持選區的情況下向上
action.EmacsStyleIndent.text=Emacs 頁籤
action.EmmetNextEditPoint.description=轉到下一個 Emmet 編輯點
action.EmmetNextEditPoint.text=下一個 Emmet 編輯點
action.EmmetPreview.description=顯示 Emmet 縮寫的預覽
action.EmmetPreview.text=Emmet 預覽
action.EmmetPreviousEditPoint.description=轉到上一個 Emmet 編輯點
action.EmmetPreviousEditPoint.text=上一個 Emmet 編輯點
action.EmmetUpdateTag.description=使用 Emmet 縮寫更新現有 HTML 標記
action.EmmetUpdateTag.text=使用 Emmet 更新標記
action.EmojiAndSymbols.description=使用 macOS 系統調色板輸入特殊字元
action.EnableMetalRendering.text=Metal 呈現管道
action.EnableNewUi.description=啟用新 UI
action.EnableNewUi.text=啟用新 UI…
action.EncapsulateFields.description=使用存取器方法取代所選類別中欄位的直接存取
action.EncapsulateFields.text=封裝欄位(_E)…
action.EscapeEntities.description=使用實體轉義 XML/HTML 特殊字元
action.EscapeEntities.text=編碼 XML/HTML 特殊字元
action.EvaluateExpression.description=對任意表達式求值
action.EvaluateExpression.text=對表達式求值(_X)…
action.ExcludeFromProjectAction.text=從專案中排除
action.ExecutionTargets.text=目標
action.Exit.description=退出 IDE
action.Exit.text=退出(_X)
action.ExpandAll.text=全部展開
action.ExpandAllRegions.description=展開所有折疊區域(選區中)
action.ExpandAllRegions.text=全部展開(_E)
action.ExpandAllToLevel1.text=_1
action.ExpandAllToLevel2.text=_2
action.ExpandAllToLevel3.text=_3
action.ExpandAllToLevel4.text=_4
action.ExpandAllToLevel5.text=_5
action.ExpandCollapseToggleAction.description=展開或摺疊當前程式碼塊
action.ExpandCollapseToggleAction.text=切換折疊
action.ExpandDocComments.description=展開所有文檔註釋
action.ExpandDocComments.text=展開文檔註釋(_D)
action.ExpandExpandableComponent.text=展開元件
action.ExpandLiveTemplateByTab.text=按 Tab 展開實時模板
action.ExpandLiveTemplateCustom.description=使用在編輯器中鍵入的前綴呼叫綁定到 '自訂快捷鍵' 的實時模板
action.ExpandLiveTemplateCustom.text=展開實時模板/Emmet 縮寫
action.ExpandRegion.description=展開文字游標處的折疊區域
action.ExpandRegion.text=展開(_X)
action.ExpandRegionRecursively.description=遞迴展開文字游標處的塊
action.ExpandRegionRecursively.text=遞迴展開(_R)
action.ExpandToLevel1.text=_1
action.ExpandToLevel2.text=_2
action.ExpandToLevel3.text=_3
action.ExpandToLevel4.text=_4
action.ExpandToLevel5.text=_5
action.ExpandTreeNode.text=展開樹節點
action.ExportSettings.description=匯出全域設定
action.ExportSettings.text=匯出設定(_E)…
action.ExportTestResults.description=將測試結果匯出到檔案
action.ExportTestResults.text=匯出測試結果…
action.ExportThreads.description=將所有執行緒資訊儲存到文本檔案或剪貼簿
action.ExportThreads.text=匯出執行緒(_H)…
action.ExportToEclipse.description=為每個模組建立 Eclipse 專案
action.ExportToEclipse.text=匯出到 Eclipse…
action.ExportToHTML.MainMenu.text=將檔案或選區匯出到 HTML(_H)…
action.ExportToHTML.description=以 HTML 格式儲存檔案內容，包括語法顏色
action.ExportToHTML.text=將檔案或選區匯出到 HTML(_H)…
action.ExportToTextFile.text=匯出到文本檔案
action.ExpressionStatistics.text=收集 Java 表達式統計資訊
action.ExpressionTypeInfo.description=顯示所選表達式的類型
action.ExpressionTypeInfo.text=類型資訊(_E)
action.ExternalJavaDoc.description=開啟包含所選條目文檔的瀏覽器
action.ExternalJavaDoc.text=外部文檔(_X)
action.ExternalSystem.AfterCompile.description=在建置後執行選定任務
action.ExternalSystem.AfterCompile.text=建置後執行
action.ExternalSystem.AfterRebuild.description=在完全重新建置後執行選定任務
action.ExternalSystem.AfterRebuild.text=重新建置後執行
action.ExternalSystem.AfterSync.description=在專案匯入後執行選定任務
action.ExternalSystem.AfterSync.text=同步後執行
action.ExternalSystem.AssignRunConfigurationShortcut.description=將快捷鍵分配給選定執行組態
action.ExternalSystem.AssignRunConfigurationShortcut.text=分配快捷鍵…
action.ExternalSystem.AssignShortcut.description=將快捷鍵分配給選定任務
action.ExternalSystem.AssignShortcut.text=分配快捷鍵…
action.ExternalSystem.BeforeCompile.description=在建置前執行選定任務
action.ExternalSystem.BeforeCompile.text=建置前執行
action.ExternalSystem.BeforeRebuild.description=在完全重新建置前執行選定任務
action.ExternalSystem.BeforeRebuild.text=重新建置前執行
action.ExternalSystem.BeforeRun.description=在啟動執行/偵錯組態之前執行選定任務
action.ExternalSystem.BeforeRun.text=在執行/偵錯之前執行…
action.ExternalSystem.BeforeSync.description=在專案匯入前執行選定任務
action.ExternalSystem.BeforeSync.text=同步前執行
action.ExternalSystem.CollapseAll.text=全部摺疊
action.ExternalSystem.EditRunConfiguration.text=編輯執行組態…
action.ExternalSystem.ExpandAll.text=全部展開
action.ExternalSystem.GroupModules.text=組模組
action.ExternalSystem.GroupTasks.text=組任務
action.ExternalSystem.RemoveRunConfiguration.text=移除執行組態
action.ExternalSystem.RunTask.description=執行選定任務
action.ExternalSystem.RunTask.text=執行任務(_R)
action.ExternalSystem.SelectProjectDataToImport.text=選擇要匯入的專案資料
action.ExternalSystem.ShowCommonSettings.description=為當前專案編輯建置工具設定
action.ExternalSystem.ShowCommonSettings.text=自動重新載入設定…
action.ExternalSystem.ShowIgnored.text=顯示忽略項
action.ExternalSystem.ShowInheritedTasks.text=顯示從子專案繼承的任務
action.ExtractClass.description=提取委託
action.ExtractClass.text=提取委託(_D)…
action.ExtractInclude.description=將所選程式碼段轉換為包含的檔案
action.ExtractInclude.text=Include 檔案(_I)…
action.ExtractInterface.description=從所選類別提取接口
action.ExtractInterface.text=提取接口(_I)…
action.ExtractMethod.description=將所選程式碼段轉換為一個方法
action.ExtractMethod.text=提取方法(_M)…
action.ExtractModule.description=從所選類別提取模組
action.ExtractModule.text=提取模組(_M)…
action.ExtractModuleFromPackage.description=將軟體套件提取到單獨的模組
action.ExtractModuleFromPackage.text=提取模組…
action.ExtractSuperclass.description=從所選類別提取超類別
action.ExtractSuperclass.text=提取超類別(_U)…
action.FileChooser.Delete.description=刪除
action.FileChooser.Delete.text=刪除…
action.FileChooser.GoBackward.description=轉到之前存取過的目錄。
action.FileChooser.GoBackward.text=上一個目錄
action.FileChooser.GoForward.description=轉到之前存取過的目錄。
action.FileChooser.GoForward.text=下一個目錄
action.FileChooser.GoToParent.description=轉到父目錄
action.FileChooser.GoToParent.text=父目錄
action.FileChooser.GoToRoot.description=轉到根目錄或根目錄列表
action.FileChooser.GoToRoot.text=根目錄
action.FileChooser.GoToWslHome.description=轉到 WSL VM 中的主目錄
action.FileChooser.GoToWslHome.text=WSL 中的主目錄
action.FileChooser.GotoDesktop.description=轉到桌面目錄
action.FileChooser.GotoDesktop.text=桌面目錄
action.FileChooser.GotoHome.description=轉到主目錄
action.FileChooser.GotoHome.text=主目錄
action.FileChooser.GotoModule.description=轉到模組目錄
action.FileChooser.GotoModule.text=模組目錄
action.FileChooser.GotoProject.description=轉到專案目錄
action.FileChooser.GotoProject.text=專案目錄
action.FileChooser.LightEditGotoOpenedFile.text=選擇開啟的檔案
action.FileChooser.NewFile.description=建立新檔案
action.FileChooser.NewFile.text=新增檔案…
action.FileChooser.NewFolder.description=建立新目錄
action.FileChooser.NewFolder.text=新增目錄…
action.FileChooser.Refresh.description=重新整理檔案系統樹
action.FileChooser.Refresh.text=重新整理
action.FileChooser.ShowHidden.description=顯示隱藏的檔案和目錄
action.FileChooser.ShowHidden.text=顯示隱藏的檔案和目錄
action.FileChooser.ToggleDetection.description=允許 IDE 檢視內部以檢測專案目錄
action.FileChooser.ToggleDetection.text=檢測專案目錄
action.FileChooser.TogglePathBar.description=切換路徑輸入欄位的可見性
action.FileChooser.TogglePathBar.text=顯示/隱藏路徑輸入欄位
action.FileChooser.TogglePathShowing.text=顯示/隱藏路徑文本
action.FileStructurePopup.description=顯示帶有當前檔案結構的彈出視窗，以便快速導覽
action.FileStructurePopup.text=檔案結構(_I)
action.FillParagraph.description=重新格式化字串文字或註釋以適應最大寬度(通常為80)
action.FillParagraph.text=填充段落
action.Find.description=在活動編輯器中尋找字串
action.Find.text=尋找(_F)…
action.FindInPath.description=在多個檔案中尋找字串
action.FindInPath.synonym1=在路徑中尋找
action.FindInPath.text=在檔案中尋找…
action.FindNext.MainMenu.text=尋找下一個符合項(_N)
action.FindNext.description=重複上一次尋找/取代動作，或移至所選文本的下一個符合項
action.FindNext.text=尋找下一個/移至下一個符合項(_N)
action.FindPrevWordAtCaret.description=尋找文字游標處單詞的上一個符合項
action.FindPrevWordAtCaret.text=文字游標處單詞的上一個符合項
action.FindPrevious.MainMenu.text=尋找上一個符合項(_V)
action.FindPrevious.description=反向重複上一次尋找/取代動作，或移至所選文本的上一個符合項
action.FindPrevious.text=尋找上一個/移至上一個符合項(_V)
action.FindSelectionInPath.text=在檔案中尋找
action.FindUsages.description=尋找文字游標處符號的用法
action.FindUsages.text=尋找用法(_U)
action.FindUsagesInFile.description=在活動編輯器中尋找文字游標處符號的用法
action.FindUsagesInFile.text=在檔案中尋找用法(_I)
action.FindUsedTestData.text=尋找未使用的測試資料
action.FindWordAtCaret.description=尋找文字游標處單詞的下一個符合項
action.FindWordAtCaret.text=尋找文字游標處的字
action.FixDocComment.description=生成或修正當前上下文的文檔註釋
action.FixDocComment.text=修正文檔註釋
action.FixLineSeparators.text=修復行分隔符
action.FixWSLFirewall.text=修正 WSL 防火牆設定
action.FloatMode.description=將工具視窗移至單獨的對話框
action.FloatMode.text=浮動(_F)
action.Floating.CodeToolbar.Customize.text=自訂工具列…
action.Floating.CodeToolbar.Disable.text=不顯示工具列
action.Floating.CodeToolbar.SurroundWithIf.text=if
action.Floating.CodeToolbar.SurroundWithTryCatch.text=try / catch
action.Floating.CodeToolbar.SurroundWithTryCatchFinally.text=try / catch / finally
action.FocusDebugger.text=啟動焦點偵錯器
action.FocusEditor.text=聚焦編輯器
action.FocusTracer.text=啟動焦點追蹤
action.ForceIndexRebuild.text=重建索引
action.ForceIndexRescanning.text=同步索引
action.ForceRefresh.text=強制重新整理
action.ForceRunToCursor.description=執行到文字游標所在的行，忽略任何中斷點
action.ForceRunToCursor.text=強制執行到游標(_S)
action.ForceStepInto.description=步入，忽略庫、建構函式等步進篩選器。
action.ForceStepInto.text=強制步入(_N)
action.ForceStepOver.description=步過，在步進前停用所有中斷點。
action.ForceStepOver.text=強制步過(_V)
action.Forward.description=恢復上次撤消的導覽動作
action.Forward.text=前進(_W)
action.FullyExpandTreeNode.text=完全展開樹節點
action.GatewayCollectLogsAction.text=收集所有日誌
action.GemRequirements.ShowSettings.text=Ruby SDK 和 Gem
action.Generate.description=生成建構函式、getter 或 setter 方法等
action.Generate.text=生成…
action.GenerateAfterClassMethod.text=AfterClass 方法
action.GenerateBeforeClassMethod.text=BeforeClass 方法
action.GenerateConstructor.description=生成建構函式
action.GenerateConstructor.text=建構函式
action.GenerateCoverageReport.text=生成覆蓋率報告(_G)
action.GenerateCreateUI.description=生成 createUI(...)
action.GenerateCreateUI.text=createUI(...)
action.GenerateDTD.text=從 XML 檔案生成 DTD(_X)
action.GenerateDataMethod.text=參數方法
action.GenerateEquals.description=生成 equals() 和 hashCode()
action.GenerateEquals.text=equals() 和 hashCode()
action.GenerateEventsScheme.description=從正在執行的 IDE 執行個體中收集統計資訊收集器的方案
action.GenerateEventsScheme.text=顯示 FUS 收集器方案
action.GenerateGetter.description=生成 getter
action.GenerateGetter.text=Getter
action.GenerateGetterAndSetter.description=生成 getter 和 setter
action.GenerateGetterAndSetter.text=Getter 和 Setter
action.GenerateJavadoc.description=執行 JavaDoc 工具
action.GenerateJavadoc.text=生成 JavaDoc(_D)…
action.GenerateModuleDescriptors.description=為專案中的所有模組 module-info 檔案 (適用於 Java 9 及更高版本)
action.GenerateModuleDescriptors.text=生成 module-info 檔案描述子
action.GenerateSetUpMethod.text=SetUp 方法
action.GenerateSetter.description=生成 setter
action.GenerateSetter.text=Setter
action.GenerateSuperMethodCall.description=生成 super 方法呼叫
action.GenerateSuperMethodCall.text=super 方法呼叫
action.GenerateTearDownMethod.text=TearDown 方法
action.GenerateTestDataPathFiles.text=@TestDataPath 檔案
action.GenerateTestDataPathMethods.text=@TestDataPath 方法
action.GenerateTestMethod.text=測試方法
action.GenerateVisitorByHierarchy.text=生成層次結構訪問者…
action.GenerateXmlTag.description=根據架構資訊生成新的 XML 標記
action.GenerateXmlTag.text=XML 標記…
action.GoToLastTab.description=啟用最後一個頁籤
action.GoToLastTab.text=選擇最後一個頁籤
action.GoToLinkTarget.description=在專案檢視中開啟此符號連結的目標
action.GoToLinkTarget.text=轉到連結目標
action.GoToTab.description=啟用頁籤 #{0}
action.GoToTab.text=選擇頁籤 #{0}
action.GotoAction.description=通過名稱快速導覽到動作
action.GotoAction.text=尋找動作(_F)…
action.GotoChangedFile.description=按名稱快速導覽到更改的檔案
action.GotoChangedFile.text=轉到更改的檔案…
action.GotoClass.description=通過名稱快速導覽到類別
action.GotoClass.text=轉到類別…
action.GotoCustomRegion.text=自訂折疊…
action.GotoDeclaration.MainMenu.text=宣告或用例(_D)
action.GotoDeclaration.description=導覽到文字游標處符號的宣告或顯示其用法
action.GotoDeclaration.text=前往宣告或用法
action.GotoDeclarationOnly.MainMenu.text=宣告
action.GotoDeclarationOnly.description=導覽到文字游標處符號的宣告
action.GotoDeclarationOnly.text=轉到宣告
action.GotoFile.MainMenu.text=檔案(_F)…
action.GotoFile.description=通過名稱快速導覽到檔案
action.GotoFile.text=轉到檔案…
action.GotoImplementation.MainMenu.text=實作(_M)
action.GotoImplementation.description=導覽到所選類別或方法的實作
action.GotoImplementation.text=轉到實作(_M)
action.GotoLine.MainMenu.text=行:列(_L)…
action.GotoLine.description=通過編號在編輯器中導覽到某一行(和/或列)
action.GotoLine.text=轉到行:列…
action.GotoNextBookmark.text=下一行書籤
action.GotoNextBookmarkInEditor.text=編輯器中的下一行書籤
action.GotoNextElementUnderCaretUsage.description=導覽到下一個醒目提示的元素用法
action.GotoNextElementUnderCaretUsage.text=下一個醒目提示用例
action.GotoNextError.description=在活動編輯器中導覽到下一個醒目提示的錯誤
action.GotoNextError.text=下一個醒目提示顯示錯誤(_N)
action.GotoPrevElementUnderCaretUsage.description=導覽到上一個醒目提示的元素用法
action.GotoPrevElementUnderCaretUsage.text=轉到上一個醒目提示的元素用法
action.GotoPreviousBookmark.text=上一行書籤
action.GotoPreviousBookmarkInEditor.text=編輯器中的上一行書籤
action.GotoPreviousError.description=在活動編輯器中導覽到上一個醒目提示的錯誤
action.GotoPreviousError.text=上一個醒目提示顯示錯誤(_P)
action.GotoRelated.description=導覽到一個相關或連結的符號
action.GotoRelated.text=相關符號(_R)…
action.GotoSuperMethod.MainMenu.text=super 方法(_U)
action.GotoSuperMethod.description=導覽到當前方法覆寫或實作的方法的宣告
action.GotoSuperMethod.text=轉到 Super 方法
action.GotoSymbol.MainMenu.text=符號(_S)…
action.GotoSymbol.description=通過名稱快速導覽到任意符號
action.GotoSymbol.text=轉到符號…
action.GotoTest.MainMenu.text=測試(_E)
action.GotoTest.description=導覽到所選類別的測試
action.GotoTest.text=轉到測試
action.GotoTest.text.subject=轉到測試主題
action.GotoTestSubject.MainMenu.text=測試物件(_E)
action.GotoTestSubject.description=導覽到所選測試的物件
action.GotoTestSubject.text=轉到測試主題(_E)
action.GotoTypeDeclaration.MainMenu.text=類型宣告(_T)
action.GotoTypeDeclaration.description=導覽到文字游標處符號類型的宣告
action.GotoTypeDeclaration.text=轉到類型宣告
action.Graph.ActualSize.text=實際尺寸
action.Graph.AlignNodes.Bottom.text=底部
action.Graph.AlignNodes.Center.text=中心
action.Graph.AlignNodes.Left.text=左側
action.Graph.AlignNodes.Middle.text=居中排列
action.Graph.AlignNodes.Right.text=右側
action.Graph.AlignNodes.Top.text=頂部
action.Graph.ApplyCurrentLayout.text=套用當前布局
action.Graph.CopyDiagramSelectionToClipboard.text=將選區複製到剪貼簿
action.Graph.CopyEntireDiagramToClipboard.text=將圖表複製到剪貼簿
action.Graph.Current.Node.Dependencies.Filter.text=顯示所選節點與相依關係
action.Graph.Delete.text=刪除選區
action.Graph.DistributeNodes.Horizontally.text=水平排列
action.Graph.DistributeNodes.Vertically.text=垂直排列
action.Graph.EdgeRealizer.ArcEdgeRealizer.text=弧形
action.Graph.EdgeRealizer.BezierEdgeRealizer.text=貝塞爾曲線
action.Graph.EdgeRealizer.QuadCurveEdgeRealizer.text=二次曲線
action.Graph.EdgeRealizer.SmoothedPolylineEdgeRealizer.text=平滑多段線
action.Graph.EdgeRealizer.SplineEdgeRealizer.text=樣條
action.Graph.EdgeRealizer.StraightPolylineEdgeRealizer.text=直多段線
action.Graph.ExportToFile.description=匯出到 PNG、JPG、GIF、SVG 或 SVGZ 檔案
action.Graph.ExportToFile.text=匯出到圖片…
action.Graph.FitContent.text=調整內容
action.Graph.Layout.ARTreeLayouter.text=緊湊
action.Graph.Layout.BalloonEdgeBundledLayouter.text=邊緣捆綁(氣球)
action.Graph.Layout.BalloonLayouter.text=氣球
action.Graph.Layout.ChannelLayouter.text=通道
action.Graph.Layout.CircularEdgeBundledLayouter.text=邊緣捆綁(圓形)
action.Graph.Layout.CircularLayouter.text=迴圈
action.Graph.Layout.CompactOrthogonalLayouter.text=緊湊
action.Graph.Layout.CustomLayouter.text=圖特定
action.Graph.Layout.FamilyLayouter.text=系列
action.Graph.Layout.Fit.Content.text=在布局後調整內容
action.Graph.Layout.GenericLayouter.text=泛型
action.Graph.Layout.HVTreeLayouter.text=寬
action.Graph.Layout.HierarchicGroupLayouter.text=層次結構組
action.Graph.Layout.HierarchicLayouter.text=分層
action.Graph.Layout.OrganicEdgeBundledLayouter.text=邊緣捆綁(有機)
action.Graph.Layout.OrganicLayouter.text=有機
action.Graph.Layout.OrthogonalGroupLayouter.text=正交群
action.Graph.Layout.RadialEdgeBundledLayouter.text=邊緣捆綁(徑向)
action.Graph.Layout.RadialLayouter.text=徑向
action.Graph.Layout.RandomLayouter.text=隨機
action.Graph.Layout.SeriesParallelLayouter.text=串並聯
action.Graph.Layout.SingleCycleLayouter.text=單迴圈
action.Graph.LayoutOrientation.BottomToTop.text=🠉 從下到上
action.Graph.LayoutOrientation.LeftToRight.text=🠊 從左到右
action.Graph.LayoutOrientation.RightToLeft.text=🠈 從右到左
action.Graph.LayoutOrientation.TopToBottom.text=🠋 從上到下
action.Graph.MergeEdges.BySources.text=按源
action.Graph.MergeEdges.ByTargets.text=按目標
action.Graph.NeighborhoodViewPopup.CompactMode.text=緊湊地顯示節點
action.Graph.NeighborhoodViewPopup.SameAsModelLayouter.text=與 Main 相同
action.Graph.RouteEdges.text=自動路由邊緣
action.Graph.Show.Bridges.text=顯示連結橋
action.Graph.Show.Edge.Labels.text=顯示邊緣標籤
action.Graph.ShowHideGrid.text=顯示網格
action.Graph.ShowStructureViewForSelectedNode.text=顯示所選節點的結構檢視
action.Graph.SnapToGrid.text=對齊到網格
action.Graph.ZoomIn.text=放大
action.Graph.ZoomOut.text=縮小
action.Graph.print.reset=重設
action.GrayFilterConfig.text=灰色篩選器(&G)
action.Help.JetBrainsTV.description=檢視介紹 JetBrains 產品功能的簡短現場示範。
action.Help.JetBrainsTV.templateText=YouTube 上的 {0}
action.Help.JetBrainsTV.text=展示與螢幕錄製
action.Help.KeymapReference.description=開啟帶有預設按鍵映射參考卡的 PDF 檔案。
action.Help.KeymapReference.text=鍵盤快捷鍵 PDF(_K)
action.HelpTopics.description=顯示幫助內容
action.HelpTopics.text=幫助(_H)
action.HideActiveWindow.description=隱藏活動工具視窗
action.HideActiveWindow.text=隱藏活動工具視窗(_D)
action.HideAllWindows.description=隱藏所有工具視窗
action.HideAllWindows.text=隱藏所有工具視窗(_T)
action.HideSideWindows.description=隱藏本側所有視窗
action.HideSideWindows.text=隱藏本側工具視窗
action.HidpiInfo.text=顯示 HiDPI 資訊(&H)
action.HighlightUsagesInFile.description=在活動編輯器中醒目提示文字游標處符號的用法
action.HighlightUsagesInFile.not.ready=此用法搜尋需要索引，在索引建置之前無法執行
action.HighlightUsagesInFile.text=醒目提示檔案中的用法(_H)
action.HippieBackwardCompletion.description=迴圈擴展詞(向後)
action.HippieBackwardCompletion.text=迴圈擴展詞(向後)(_E)
action.HippieCompletion.description=迴圈擴展詞
action.HippieCompletion.text=迴圈擴展詞(_E)
action.Hotswap.description=將所有更改的類別重新載入到被偵錯的應用程式中 (熱插拔)
action.Hotswap.text=重新載入已更改的類別(_A)
action.IconScaleTestAction.text=顯示圖示比例測試對話框
action.IconsLoadTime.text=日誌圖示載入時間
action.IdeScriptingConsole.description=開啟 IDE 腳本主控台
action.IdeScriptingConsole.text=IDE 腳本主控台
action.ImageDuplicates.text=尋找圖片重複項
action.ImplementMethods.description=在當前類別中實作基接口/類別方法
action.ImplementMethods.text=實作方法(_I)…
action.ImportModule.description=從包含現有源的目錄或者現有專案模型匯入模組
action.ImportModule.text=來自現有源的模組…
action.ImportModuleFromImlFile.description=將 iml 檔案作為一個模組匯入到專案
action.ImportModuleFromImlFile.text=匯入模組
action.ImportProject.description=為包含現有源的目錄建立專案結構或者轉換現有專案模型
action.ImportProject.text=來自現有源的專案…
action.ImportSettings.description=匯入全域設定
action.ImportSettings.text=匯入設定…
action.ImportTestsFromFile.text=從檔案匯入測試
action.IncludeToProjectAction.text=包含到專案中
action.IncomingChanges.Refresh.description=重新整理傳入更改的列表
action.IncomingChanges.Refresh.text=重新整理
action.IncrementWindowHeight.text=增大高度
action.IncrementWindowWidth.text=增大寬度
action.IncrementalSearch.description=啟動增量搜尋(輸入時搜尋字串)，IntelliJ IDEA 6.0 實作。
action.IncrementalSearch.text=增量搜尋(_L)
action.InferNullity.description=推斷為 null 性
action.InferNullity.text=推斷為 null 性(_N)…
action.InheritanceToDelegation.description=將繼承取代為委託
action.InheritanceToDelegation.text=將繼承取代為委託(_I)…
action.Inline.description=內聯所選方法或變數
action.Inline.text=內聯(_N)…
action.InsertInlineCompletionAction.description=Insert current inline completion proposal
action.InsertInlineCompletionAction.text=Insert inline proposal
action.InsertLiveTemplate.description=顯示以指定前綴開頭的實時模板的彈出視窗列表
action.InsertLiveTemplate.text=插入實時模板(_T)…
action.InsertRubyInjection.description=在 Erb 檔案中插入 '<%= %>'
action.InsertRubyInjection.text=插入 '<%= %>'
action.InsertRubyInjectionWithoutOutput.description=在 Erb 檔案中插入 '<% %>'
action.InsertRubyInjectionWithoutOutput.text=插入 '<% %>'
action.InspectCode.description=檢查程式碼
action.InspectCode.text=檢查程式碼(_I)…
action.InspectionFilterAction.filter.by.language.text=按語言篩選
action.InspectionFilterAction.filter.inspections.text=篩選器檢查
action.IntegrateFiles.description=整合所選檔案或目錄
action.IntegrateFiles.text=整合
action.IntroduceConstant.description=將所選表達式取代為常數
action.IntroduceConstant.text=引入常數(_C)…
action.IntroduceField.description=將所選表達式的結果放入欄位中
action.IntroduceField.text=引入欄位(_F)…
action.IntroduceFunctionalParameter.description=通過呼叫新的函式方法參數來取代所選的語句
action.IntroduceFunctionalParameter.text=引入功能參數(_L)…
action.IntroduceFunctionalVariable.description=通過呼叫新的函式變數來取代所選的語句
action.IntroduceFunctionalVariable.text=引入函式變數…
action.IntroduceParameter.description=將所選表達式轉換為方法參數
action.IntroduceParameter.text=引入參數(_P)…
action.IntroduceParameterObject.description=使用物件取代方法參數列表
action.IntroduceParameterObject.text=引入參數物件(_J)…
action.IntroduceVariable.description=將所選表達式的結果放入變數中
action.IntroduceVariable.text=引入變數(_V)…
action.InvalidateCaches.description=在下次啟動時強制重新建置所有快取和索引
action.InvalidateCaches.text=清除快取…
action.InvertBoolean.description=使方法返回值或變數包含相反的值並更正參照
action.InvertBoolean.text=反轉布林值(_B)…
action.JBCefOsrMeasureFps.text=測量 OSR JCEF FPS
action.JBTabsDemo.text=JBTabs 示範
action.JShell.Console.description=啟動 JShell 主控台
action.JShell.Console.text=JShell 主控台…
action.JTabbedPaneDemo.text=JTabbedPane 示範
action.JsonCopyPointer.description=複製 JSON 指針
action.JsonCopyPointer.text=複製 JSON 指針
action.JumpToColorsAndFonts.description=跳轉到文字游標下的螢光筆的顏色選項
action.JumpToColorsAndFonts.text=跳轉到顏色和字體
action.JumpToLastChange.description=在最近的更改點中移動
action.JumpToLastChange.text=最後編輯位置(_O)
action.JumpToLastWindow.description=啟用上一個聚焦的工具視窗
action.JumpToLastWindow.text=跳轉到上一個工具視窗(_J)
action.JumpToNextChange.description=在最近的更改點中移動
action.JumpToNextChange.text=下一個編輯位置
action.KeepTabOpen.description=將預覽頁籤轉換為一般編輯器頁籤
action.KeepTabOpen.text=保持頁籤開啟
action.KeymapToCsv.text=將按鍵映射匯出到 CSV…
action.LabelSizeDemoAction.text=測試標籤大小
action.LaggingMode.text=滯後模式
action.LibrarySettings.navigate=開啟庫設定
action.LibraryUsageStatistics.text=顯示匯入的庫用法資訊
action.LightEditExitAction.text=退出(&X)
action.LightEditNewFileAction.text=新增(&N)
action.LightEditOpenFileInProjectAction.text=在專案中開啟檔案…
action.List-scrollDown.description=將周圍的可滾動區域向下滾動一頁，然後選擇相應的行。
action.List-scrollDown.text=向下滾動頁面並選擇行
action.List-scrollDownExtendSelection.description=將周圍的可滾動區域向下滾動一頁，然後將相應的行新增到選區。
action.List-scrollDownExtendSelection.text=向下滾動頁面並擴展選區
action.List-scrollUp.description=將周圍的可滾動區域向上滾動一頁，然後選擇相應的行。
action.List-scrollUp.text=向上滾動頁面並選擇行
action.List-scrollUpExtendSelection.description=將周圍的可滾動區域向上滾動一頁，然後將相應的行新增到選區。
action.List-scrollUpExtendSelection.text=向上滾動頁面並擴展選區
action.List-selectFirstRow.description=選擇第一行。
action.List-selectFirstRow.text=選擇第一行
action.List-selectFirstRowExtendSelection.description=滾動到第一行並將相應的行新增到選區。
action.List-selectFirstRowExtendSelection.text=將選區擴展到第一行
action.List-selectLastRow.description=選擇最後一行。
action.List-selectLastRow.text=選擇最後一行
action.List-selectLastRowExtendSelection.description=滾動到最後一行並將相應的行新增到選區。
action.List-selectLastRowExtendSelection.text=將選區擴展到最後一行
action.List-selectNextColumn.description=選擇下一列。
action.List-selectNextColumn.text=選擇下一列
action.List-selectNextColumnExtendSelection.description=將下一列新增到選區。
action.List-selectNextColumnExtendSelection.text=將選區擴展到下一列
action.List-selectNextRow.description=選擇下一行。
action.List-selectNextRow.text=選擇下一行
action.List-selectNextRowExtendSelection.description=將下一行新增到選區。
action.List-selectNextRowExtendSelection.text=將選區擴展到下一行
action.List-selectPreviousColumn.description=選擇上一列。
action.List-selectPreviousColumn.text=選擇上一列
action.List-selectPreviousColumnExtendSelection.description=將上一列新增到選區。
action.List-selectPreviousColumnExtendSelection.text=將選區擴展到上一列
action.List-selectPreviousRow.description=選擇上一行。
action.List-selectPreviousRow.text=選擇上一行
action.List-selectPreviousRowExtendSelection.description=將上一行新增到選區。
action.List-selectPreviousRowExtendSelection.text=將選區擴展到上一行
action.ListPersistentStateComponents.text=列出持久狀態元件
action.LoadAllContent.text=載入所有檔案內容
action.LoadAllVFSContent.text=載入所有 VFS 存儲的檔案內容
action.LoadDefaultYamlProfile.text=從 YAML 載入檢查組態檔案
action.LoadUnloadModules.text=載入/移除模組…
action.LocalChangesView.ShowOnDoubleClick.EditorPreview.ToolwindowPopup.text=差異
action.LocalChangesView.ShowOnDoubleClick.EditorPreview.text=雙擊時顯示差異
action.LocalChangesView.ShowOnDoubleClick.Source.ToolwindowPopup.text=源
action.LocalChangesView.ShowOnDoubleClick.Source.text=雙擊時顯示源
action.LocalHistory.PutLabel.text=放置標籤(_L)…
action.LocalHistory.ShowHistory.GoToAction.text=顯示本地歷史記錄…
action.LocalHistory.ShowHistory.Vcs.Toolbar.Widget.text=本地歷史記錄…
action.LocalHistory.ShowHistory.text=顯示歷史記錄(_H)…
action.LocalHistory.ShowSelectionHistory.GoToAction.text=顯示選區的本地歷史記錄…
action.LocalHistory.ShowSelectionHistory.text=顯示選區的歷史記錄…
action.LogDebugConfigure.description=啟用或停用額外的日誌類別。允許通過請求向支援團隊提供更多資訊。
action.LogDebugConfigure.text=偵錯日誌設定(_E)…
action.LogFocusRequests.text=日誌焦點請求
action.LogTraceScenarios.text=選擇追蹤方案
action.MacMessagesTest.text=測試 Mac 訊息
action.MainMenuAsSeparateToolbarAction.text=主選單作為單獨的工具列
action.MainMenuButton.ShowMenu.text=顯示折疊的主選單
action.MaintenanceAction.text=維護
action.MakeModule.description=編譯模組中的所有修改和相依檔案
action.MakeModule.text=建置模組(_M)
action.MakeStatic.description=將方法或內部類別轉換為 static 並更正所有參照
action.MakeStatic.text=設為 static(_T)…
action.ManageProjectTemplates.text=管理專案模板…
action.ManageRecentProjects.text=管理專案…
action.MarkAsContentRoot.description=取消所選目錄的排除，使其檔案可以被 IDE 的動作處理
action.MarkAsContentRoot.text=不排除
action.MarkExcludeRoot.text=已排除
action.MarkFileDirty.text=在 VCS 中將檔案標記為髒
action.MarkVfsCorrupted.text=將 VFS 標記為已損壞
action.MaximizeActiveDialog.text=最大化/還原活動對話框
action.MeetNewUIAction.text=認識新 UI
action.MemberPushDown.description=將類別成員向下推送到直接繼承子類別
action.MemberPushDown.text=向下推送成員(_S)…
action.MembersPullUp.description=將類別成員拉取至超類別或實作的接口
action.MembersPullUp.text=向上拉取成員(_L)…
action.Memory.CalculateRetainedSize.text=計算保留大小…
action.MemoryView.EnableTrackingWithClosedWindow.text=啟用具有隱藏記憶體檢視的追蹤
action.MemoryView.JumpToTypeSource.text=跳轉到類型源
action.MemoryView.ShowAllocationStackTrace.text=跳轉到分配位置
action.MemoryView.ShowInstances.text=顯示執行個體
action.MemoryView.ShowInstancesFromDebuggerTree.text=顯示執行個體
action.MemoryView.ShowNewInstances.text=顯示新執行個體
action.MemoryView.ShowOnlyTracked.text=僅顯示追蹤類別
action.MemoryView.ShowOnlyWithDiff.text=僅顯示非零差異
action.MemoryView.ShowOnlyWithInstances.text=僅顯示執行個體
action.MemoryView.SwitchUpdateMode.description=在偵錯器暫停時載入類別 (可能會增加偵錯器步進的開銷)
action.MemoryView.SwitchUpdateMode.text=在偵錯器停止時更新已載入的類別
action.MemoryView.TrackingAction.NewInstancesTracking.text=追蹤新執行個體
action.Merge3Files.text=合併
action.MergeAllWindowsAction.text=合併所有專案視窗
action.MethodDown.description=在活動編輯器中導覽到下一個方法
action.MethodDown.text=下一個方法(_E)
action.MethodDuplicates.description=尋找所選作用域內可以轉換為所選方法/常數的呼叫的程式碼
action.MethodDuplicates.field.text=尋找欄位重複項並取代為參照…
action.MethodDuplicates.method.text=尋找方法重複項並取代為呼叫…
action.MethodDuplicates.text=尋找並取代程式碼重複項(_C)…
action.MethodHierarchy.BaseOnThisMethod.text=基於此方法
action.MethodHierarchy.ImplementMethodAction.description=實作方法(從方法層次結構)
action.MethodHierarchy.ImplementMethodAction.text=實作方法
action.MethodHierarchy.OverrideMethodAction.description=覆寫方法(從方法層次結構)
action.MethodHierarchy.OverrideMethodAction.text=覆寫方法
action.MethodHierarchy.description=瀏覽所選方法的方法層次結構
action.MethodHierarchy.text=方法層次結構(_M)
action.MethodOverloadSwitchDown.text=下一個方法多載
action.MethodOverloadSwitchUp.text=上一個方法多載
action.MethodUp.description=在活動編輯器中導覽到上一個方法
action.MethodUp.text=上一個方法(_I)
action.MinimizeCurrentWindow.description=最小化當前視窗
action.MinimizeCurrentWindow.text=最小化
action.ModuleSettings.description=為所選模組開啟設定對話框
action.ModuleSettings.navigate=開啟模組設定
action.ModuleSettings.text=模組設定(_S)
action.Move.description=將選中類別、方法、包或 static 成員移至另一個軟體套件或類別，並更正所有參照
action.Move.text=移動(_M)…
action.MoveEditorToOppositeTabGroup.description=將編輯器移至相反的頁籤組
action.MoveEditorToOppositeTabGroup.text=移至相反的組(_M)
action.MoveElementLeft.description=將當前元素移至包含元素列表的上一個位置
action.MoveElementLeft.text=向左移動元素
action.MoveElementRight.description=將當前元素移至包含元素列表的下一個位置
action.MoveElementRight.text=向右移動元素
action.MoveLineDown.description=將所選行向下移動一行
action.MoveLineDown.text=下移行(_W)
action.MoveLineUp.description=將所選行向上移動一行
action.MoveLineUp.text=上移行(_U)
action.MoveStatementDown.description=將所選語句向下移動一行
action.MoveStatementDown.text=向下移動語句(_W)
action.MoveStatementUp.description=將所選語句向上移動一行
action.MoveStatementUp.text=向上移動語句(_U)
action.MoveTabDown.description=將編輯器區域拆分為 2 個頁籤組，然後將當前頁籤移至底部組並關閉頂部編輯器
action.MoveTabDown.text=拆分並下移
action.MoveTabRight.description=將編輯器區域拆分為 2 個頁籤組，然後將當前頁籤移至右側組並關閉左側編輯器
action.MoveTabRight.text=拆分並右移
action.NavBar-cancel.text=關閉浮動導覽列
action.NavBar-navigate.text=從選定項導覽
action.NavBar-return.text=對選定項執行動作
action.NavBar-selectDown.text=開啟相應的彈出選單
action.NavBar-selectEnd.text=選擇最後一項
action.NavBar-selectHome.text=選擇第一項
action.NavBar-selectLeft.text=選擇上一項
action.NavBar-selectRight.text=選擇下一項
action.NavBar-selectUp.text=開啟相應的彈出選單
action.NavBarLocationBottom.description=在狀態列中顯示導覽列
action.NavBarLocationBottom.text=在狀態列中
action.NavBarLocationHide.description=隱藏導覽列
action.NavBarLocationHide.text=不顯示
action.NavBarLocationTop.description=在頂部顯示導覽列
action.NavBarLocationTop.text=頂部
action.NewClass.text=Java 類別
action.NewDatabaseProject.text=專案…
action.NewDir.text=目錄/軟體套件
action.NewDirectoryProject.cannot.create.dir=無法建立目錄 ''{0}''。
action.NewDirectoryProject.description=建立一個新項目
action.NewDirectoryProject.not.empty.dialog.create.new=從現有的源建立
action.NewDirectoryProject.not.empty.dialog.open.existing=開啟專案
action.NewDirectoryProject.not.empty.dialog.text=目錄 ''{0}'' 不為空。是否要從現有的源建立專案?
action.NewDirectoryProject.not.empty.dialog.title=目錄不為空
action.NewDirectoryProject.text=新增專案…
action.NewDirectoryProject.title=建立專案
action.NewDummyProject.text=新增虛擬專案
action.NewElement.description=建立新的類別、接口、檔案或目錄
action.NewElement.text=新增(_N)…
action.NewElementSamePlace.description=在此目錄中建立新的類別、接口、檔案或目錄
action.NewElementSamePlace.text=在當前目錄新增(_N)…
action.NewFile.text=檔案
action.NewMigration.text=建立新遷移…
action.NewModule.description=從頭建立新模組並將其新增到專案
action.NewModule.text=模組(_M)…
action.NewModuleInGroup.text=模組
action.NewProject.ProjectWidgetPopup.text=新增專案…
action.NewProject.description=從頭建立一個新項目
action.NewProject.text=專案(_P)…
action.NewRubyMineDirectoryProject.ProjectWidgetPopup.text=新增專案…
action.NewRubyMineDirectoryProject.text=專案…
action.NewScratchBuffer.description=建立新的臨時緩衝區或重用現有的臨時緩衝區
action.NewScratchBuffer.text=新增臨時緩衝區
action.NewScratchFile.description=與所選語言建立新的臨時檔案
action.NewScratchFile.text=臨時檔案
action.NewScratchFile.text.with.new=新增臨時檔案
action.NewUiRunWidget.text=執行小工具
action.NextDiff.description=移至下一個差異
action.NextDiff.text=下一個差異
action.NextEditorTab.text=在多編輯器檔案中選擇下一個頁籤
action.NextOccurence.description=導覽到下一個符合項
action.NextOccurence.text=下一個符合項(_X)
action.NextParameter.text=下一個參數
action.NextProjectWindow.description=切換到下一個專案視窗
action.NextProjectWindow.text=下一個專案視窗
action.NextSplitter.description=轉到下一個拆分視窗
action.NextSplitter.text=轉到下一個拆分器(_G)
action.NextTab.description=啟用下一個頁籤
action.NextTab.text=選擇下一個頁籤(_X)
action.NextTemplateParameter.text=下一個實時模板參數
action.NextTemplateVariable.text=下一個模板變數或完成就地重構
action.NextWindow.text=啟用下一個視窗
action.NotificationTestAction.text=新增測試通知
action.OnlineDocAction.description=顯示線上文檔
action.OnlineDocAction.text=入門指南(_G)
action.OpenBlankEditorInBlankDiffWindow.text=切換到空白編輯器
action.OpenBookmarkGroup.text=開啟所有已新增書籤的檔案
action.OpenEditorInOppositeTabGroup.description=在相反的頁籤組中開啟此編輯器的副本
action.OpenEditorInOppositeTabGroup.text=在相反的組中開啟(_O)
action.OpenElementInNewWindow.text=在新編輯器視窗中開啟
action.OpenFile.description=在編輯器中開啟專案或檔案
action.OpenFile.text=開啟(_O)…
action.OpenFileEditorInBlankDiffWindow.text=切換到檔案…
action.OpenInBrowser.description=在預設瀏覽器中開啟所選檔案
action.OpenInBrowser.text=在預設瀏覽器中開啟(_B)
action.OpenInRightSplit.description=將編輯器區域拆分為 2 個頁籤組，然後將當前檔案開啟到右側組
action.OpenInRightSplit.text=在右側拆分部分開啟
action.OpenLog.text=在編輯器中開啟日誌
action.OpenModuleSettings.text=模組設定
action.OpenMouseWheelSmoothScrollSettings.text=平滑滾動選項
action.OpenStatisticsEventLogAction.description=開啟包含統計事件日誌的工具視窗
action.OpenStatisticsEventLogAction.text=開啟統計事件日誌
action.OptimizeImports.description=移除未使用的 import 並重新排列/重新組織 import
action.OptimizeImports.text=最佳化 import(_Z)
action.OverrideFileTypeAction.description=將當前檔案視為不同檔案類型的檔案
action.OverrideFileTypeAction.text=覆寫檔案類型
action.OverrideFileTypeAction.verbose.description=將檔案 ''{0}''{1,choice,0#|1# ( 和其他 {1} 個檔案)}視為具有不同檔案類型的檔案
action.OverrideMethods.description=在當前類別中覆寫基類別方法
action.OverrideMethods.text=覆寫方法(_O)…
action.ParameterInfo.description=顯示文字游標處方法的參數
action.ParameterInfo.text=參數資訊(_P)
action.PasteMultiple.description=從最近的剪貼簿貼上
action.PasteMultiple.text=從歷史記錄貼上(_E)…
action.Pause.description=掛起程序執行並啟用偵錯
action.Pause.text=暫停程序(_P)
action.PerformGC.text=執行垃圾回收
action.Performance.ActivityMonitor.description=用於檢查哪些延伸模組和子系統消耗大多數資源的工具
action.Performance.ActivityMonitor.text=活動監視器…
action.Performance.DumpThreads.text=傾印執行緒
action.Performance.MemTester.text=執行記憶體測試程序…
action.PinActiveEditorTab.description=固定活動編輯器頁籤
action.PinActiveEditorTab.text=固定活動頁籤(_I)
action.PinActiveTab.description=固定活動編輯器或工具視窗頁籤
action.PinActiveTab.text=固定活動頁籤(_I)
action.PinActiveTabToggle.description=固定活動編輯器或工具視窗頁籤
action.PinActiveTabToggle.text=固定活動頁籤
action.PinToolwindowTab.description=固定活動工具視窗頁籤
action.PinToolwindowTab.text=固定活動工具視窗頁籤(_I)
action.PlaySavedMacrosAction.description=播放儲存的巨集
action.PlaySavedMacrosAction.text=播放儲存的巨集…
action.PlaybackLastMacro.description=播放上次使用的巨集
action.PlaybackLastMacro.text=回放上一個巨集(_Y)
action.PluginManagerFiltersConfigureResetTrustDebugAction.text=Org 延伸模組篩選器: 重設
action.PluginManagerFiltersConfigureTrustOnlyJetBrainsDebugAction.text=Org 延伸模組篩選器: 僅信任 JetBrains
action.PopupHector.description=顯示面板來為當前檔案組態醒目提示模式
action.PopupHector.text=組態當前檔案分析…
action.PopupMenu-cancel.description=關閉右鍵選單。
action.PopupMenu-cancel.text=關閉右鍵選單
action.PopupMenu-return.description=開啟子選單或從選定的選單項中呼叫動作。
action.PopupMenu-return.text=呼叫選定動作
action.PopupMenu-selectChild.description=開啟子選單並在其中選擇相應的項。
action.PopupMenu-selectChild.text=選擇子選單項
action.PopupMenu-selectNext.description=選擇下一個選單項。
action.PopupMenu-selectNext.text=選擇下一個選單項
action.PopupMenu-selectParent.description=關閉子選單並在父選單中選擇相應的項。
action.PopupMenu-selectParent.text=選擇父選單項
action.PopupMenu-selectPrevious.description=選擇上一個選單項。
action.PopupMenu-selectPrevious.text=選擇上一個選單項
action.PositionTrackerTestAction.text=測試位置追蹤器
action.PrevParameter.text=上一個參數
action.PrevSplitter.description=轉到上一個拆分視窗
action.PrevSplitter.text=轉到上一個拆分器
action.PrevTemplateParameter.text=上一個實時模板參數
action.PreviousDiff.description=移至上一個差異
action.PreviousDiff.text=上一個差異
action.PreviousEditorTab.text=在多編輯器檔案中選擇上一個頁籤
action.PreviousOccurence.description=導覽到上一個符合項
action.PreviousOccurence.text=上一個符合項(_O)
action.PreviousProjectWindow.description=切換到上一個專案視窗
action.PreviousProjectWindow.text=上一個專案視窗
action.PreviousTab.description=啟用上一個頁籤
action.PreviousTab.text=選擇上一個頁籤(_L)
action.PreviousTemplateVariable.text=上一個模板變數
action.PreviousWindow.text=啟用上一個視窗
action.Print.description=列印檔案
action.Print.text=列印(_P)…
action.ProblemsView.AutoscrollToSource.description=為所選檔案開啟編輯器，並在更改選擇後導覽到選定問題
action.ProblemsView.AutoscrollToSource.text=一鍵開啟檔案
action.ProblemsView.CopyProblemDescription.description=將問題描述複製到剪貼簿
action.ProblemsView.CopyProblemDescription.text=複製問題描述
action.ProblemsView.GroupByToolId.description=允許按檢查對問題分組
action.ProblemsView.GroupByToolId.text=按檢查分組
action.ProblemsView.OpenInPreviewTab.text=啟用預覽頁籤
action.ProblemsView.QuickFixes.description=顯示所選問題的可用快速修復
action.ProblemsView.QuickFixes.text=顯示快速修復
action.ProblemsView.ShowPreview.description=Click a selected problem to open a preview for it
action.ProblemsView.ShowPreview.text=開啟編輯器預覽
action.ProblemsView.SortByName.description=允許按名稱對問題進行排序
action.ProblemsView.SortByName.text=名稱
action.ProblemsView.SortBySeverity.description=允許按嚴重性對問題進行排序
action.ProblemsView.SortBySeverity.text=嚴重性
action.ProblemsView.SortFoldersFirst.description=單獨對檔案和目錄排序
action.ProblemsView.SortFoldersFirst.text=目錄總在最前面
action.ProductivityGuide.description=顯示工作效率功能使用統計
action.ProductivityGuide.text=我的工作效率(_P)
action.Profiler.ExcludeCallAction.text=排除呼叫
action.Profiler.ExcludeSubTreeAction.text=排除子樹
action.Profiler.FocusOnCallAction.text=聚焦於呼叫
action.Profiler.FocusOnSubtreeAction.description=在新頁籤中開啟選定的子樹
action.Profiler.FocusOnSubtreeAction.text=聚焦於子樹
action.Profiler.OpenBackTracesAction.description=在新頁籤中開啟選定的方法回溯樹
action.Profiler.OpenBackTracesAction.text=方法回溯
action.Profiler.OpenMergedCalleesAction.description=在新頁籤中開啟選定的方法合併被呼叫方樹
action.Profiler.OpenMergedCalleesAction.text=方法合併被呼叫方
action.ProgressIconShowcaseAction.text=進度圖示展示
action.ProjectFromVersionControl.ProjectWidgetPopup.text=從版本控制中獲取…
action.ProjectFromVersionControl.text=來自版本控制的專案…
action.ProjectView.AbbreviatePackageNames.description=以簡短形式顯示限定軟體套件名稱
action.ProjectView.AbbreviatePackageNames.text=縮寫限定軟體套件名稱
action.ProjectView.AutoscrollFromSource.description=選擇編輯器頁籤時，在專案檢視中選擇相應的檔案
action.ProjectView.AutoscrollFromSource.text=始終選擇開啟的檔案
action.ProjectView.AutoscrollToSource.description=選擇檔案後，將其開啟進行編輯
action.ProjectView.AutoscrollToSource.text=一鍵開啟檔案
action.ProjectView.CompactDirectories.description=如果第一個目錄僅包含第二個目錄，則將兩個類似的目錄合併到單個節點中
action.ProjectView.CompactDirectories.text=壓縮目錄
action.ProjectView.FileNesting.description=組態檔案嵌套
action.ProjectView.FileNesting.text=檔案嵌套…
action.ProjectView.FlattenModules.description=以簡單列表顯示模組
action.ProjectView.FlattenModules.text=平展模組
action.ProjectView.FlattenPackages.description=以簡單列表顯示包
action.ProjectView.FlattenPackages.text=平展軟體套件
action.ProjectView.FoldersAlwaysOnTop.description=單獨對檔案和目錄排序
action.ProjectView.FoldersAlwaysOnTop.text=目錄總在最前
action.ProjectView.HideEmptyMiddlePackages.description=隱藏空的中間軟體套件
action.ProjectView.HideEmptyMiddlePackages.text=隱藏空的中間軟體套件
action.ProjectView.ManualOrder.description=手動對檔案排序
action.ProjectView.ManualOrder.text=手動排序
action.ProjectView.OpenDirectoriesWithSingleClick.text=一鍵開啟目錄
action.ProjectView.OpenInPreviewTab.text=啟用預覽頁籤
action.ProjectView.ShowExcludedFiles.description=顯示排除的檔案
action.ProjectView.ShowExcludedFiles.text=顯示排除的檔案
action.ProjectView.ShowLibraryContents.description=顯示庫內容
action.ProjectView.ShowLibraryContents.text=顯示庫內容
action.ProjectView.ShowMembers.description=顯示類別成員
action.ProjectView.ShowMembers.text=顯示成員
action.ProjectView.ShowModules.description=顯示相應根的模組名稱
action.ProjectView.ShowModules.text=顯示模組
action.ProjectView.ShowScratchesAndConsoles.description=顯示臨時檔案和主控台
action.ProjectView.ShowScratchesAndConsoles.text=顯示臨時檔案和主控台
action.ProjectView.ShowVisibilityIcons.description=在元素名稱之前顯示其可見性的圖示
action.ProjectView.ShowVisibilityIcons.text=顯示可見性圖示
action.ProjectView.SortByName.description=Sort files by their name
action.ProjectView.SortByName.text=按名稱排序
action.ProjectView.SortByTimeAscending.description=按最後修改時間對檔案進行排序，從舊到新
action.ProjectView.SortByTimeAscending.text=按修改時間排序(從舊到新)
action.ProjectView.SortByTimeDescending.description=按最後修改時間對檔案進行排序，從新到舊
action.ProjectView.SortByTimeDescending.text=按修改時間排序(從新到舊)
action.ProjectView.SortByType.description=單獨對不同類型的檔案排序
action.ProjectView.SortByType.text=按類型排序
action.ProjectViewEditSource.text=編輯源
action.PruneEmptyDirectories.text=刪除空目錄
action.QuickActionPopup.text=顯示快速動作彈出視窗
action.QuickChangeScheme.description=更改當前的程式碼樣式方案、顏色與字體方案、按鍵映射或外觀
action.QuickChangeScheme.text=快速切換方案(_Q)…
action.QuickDocCopy.text=複製快速文檔
action.QuickEvaluateExpression.description=對所選表達式求值
action.QuickEvaluateExpression.text=對表達式快速求值(_Q)
action.QuickImplementations.description=顯示包含符號(及其實作)內容的彈出視窗
action.QuickImplementations.text=快速定義(_K)
action.QuickJavaDoc.description=顯示包含文字游標處符號的文檔的彈出視窗
action.QuickJavaDoc.text=快速文檔(_D)
action.QuickPreview.text=快速預覽
action.QuickTypeDefinition.description=顯示包含文字游標處符號的類型定義的彈出視窗
action.QuickTypeDefinition.text=快速類型定義
action.RearrangeCode.description=重新排列程式碼
action.RearrangeCode.text=重新排列程式碼
action.RecentChangedFiles.description=顯示最近更改檔案的列表
action.RecentChangedFiles.text=最近更改的檔案
action.RecentChanges.text=最近的更改(_E)
action.RecentFiles.description=顯示最近檢視檔案的列表
action.RecentFiles.text=最近的檔案(_N)
action.RecentLocations.description=顯示最近檢視/更改的位置列表
action.RecentLocations.text=最近的位置
action.RecordStateCollectors.description=將所有狀態收集器和記錄結果呼叫到事件日誌
action.RecordStateCollectors.text=將狀態收集器記錄到事件日誌
action.RedesignedRunConfigurationSelector.text=選擇執行/偵錯組態
action.Refactorings.QuickListPopupAction.description=包含重構動作列表的上下文感知彈出視窗
action.Refactorings.QuickListPopupAction.text=重構此…
action.ReformatCode.description=重新格式化程式碼
action.ReformatCode.synonym1=格式程式碼
action.ReformatCode.text=重新格式化程式碼(_R)
action.Refresh.text=重新整理(_E)
action.Register.description=輸入註冊資料
action.Register.text=註冊(_R)…
action.ReloadProjectAction.text=重新載入專案
action.RemoveFromScopeAction.text=從作用域中移除
action.RemoveStripeButton.description=從側邊列移除工具視窗按鈕
action.RemoveStripeButton.text=從側邊列中移除
action.RenameAction.text=重新命名…
action.RenameElement.description=重新命名所選符號並更正所有參照
action.RenameElement.text=重新命名(_R)…
action.RenameFile.description=重新命名所選檔案
action.RenameFile.text=重新命名檔案…
action.ReopenClosedTabAction.text=重新開啟關閉的頁籤
action.Replace.description=使用另一個字串取代活動編輯器中的字串
action.Replace.text=取代(_R)…
action.ReplaceInPath.description=在多個檔案中使用另一個字串取代一個字串
action.ReplaceInPath.synonym1=在路徑中取代(_A)
action.ReplaceInPath.text=在檔案中取代(_A)…
action.ReplaceMethodWithMethodObject.description=將方法轉換為自己的物件，以便所有參數都成為該物件上的欄位
action.ReplaceMethodWithMethodObject.text=將方法取代為方法物件(_J)…
action.ReportProblem.description=在 JetBrains 問題追蹤器中提交錯誤報告
action.ReportProblem.text=提交錯誤報告…
action.ReportSettingsToFUS.text=將更改的設定記錄到事件日誌
action.Rerun.text=重新執行
action.RerunFailedTests.description=僅執行上次執行後失敗/崩潰的測試；按 Shift 鍵選擇“執行/偵錯”模式
action.RerunFailedTests.text=重新執行失敗的測試
action.RerunTests.text=重新執行測試
action.ResetFilterAction.text=重設篩選器
action.ResetGotItTooltips.text=重設“知道了”工具提示
action.ResetIdeScaleAction.text=重設 IDE 比例
action.ResetWindowsDefenderNotification.text=重設 Microsoft Defender 通知
action.ResizeToolWindowDown.description=將活動工具視窗延伸至底部
action.ResizeToolWindowDown.text=延伸至底部
action.ResizeToolWindowLeft.description=將活動工具視窗延伸至左側
action.ResizeToolWindowLeft.text=延伸至左側
action.ResizeToolWindowMaximize.text=最大化工具視窗
action.ResizeToolWindowMaximize.text.alternative=還原工具視窗大小
action.ResizeToolWindowRight.description=將活動工具視窗延伸至右側
action.ResizeToolWindowRight.text=延伸至右側
action.ResizeToolWindowUp.description=將活動工具視窗延伸至頂部
action.ResizeToolWindowUp.text=延伸至頂部
action.RestartIde.text=重啟 IDE…
action.RestoreDefaultExtensionScripts.description=重設此目錄的捆綁擴展
action.RestoreDefaultExtensionScripts.text=重設預設擴展
action.RestoreDefaultLayout.description=還原當前所選布局
action.RestoreDefaultLayout.text=還原當前布局(_C)
action.RestoreDefaultSettings.description=將所有設定重設為其預設值
action.RestoreDefaultSettings.text=還原為預設設定…
action.RestoreFontPreviewTextAction.text=還原預覽文本
action.RestoreNamedLayout.description=還原布局“{0}”
action.RestoreShelvedChange.text=還原
action.Resume.description=恢復程序執行
action.Resume.text=恢復程序(_G)
action.RetypeFile.text=重新輸入當前檔案
action.RevealIn.description=在平台的檔案管理器中醒目提示檔案
action.RevealIn.name.mac=在“訪達”中顯示
action.RevealIn.name.other=在 {0} 中顯示
action.ReverteOverrideFileTypeAction.description=撤消“覆寫檔案類型”動作並還原舊檔案類型
action.ReverteOverrideFileTypeAction.text=還原檔案類型覆寫
action.ReverteOverrideFileTypeAction.verbose.description=撤消“覆寫檔案類型”動作並為檔案 ''{0}''{1,choice,0#|1# (和其他 {1} 個檔案)}還原舊的檔案類型
action.RubyMineDemos.description=檢視介紹 RubyMine 功能的簡短現場示範
action.RubyMineDemos.text=示範和教程
action.RubyMineDeveloperCommunity.description=RubyMine 開發者社群論壇
action.RubyMineDeveloperCommunity.text=開發者社群
action.RubyMineProjectFromVersionControlAction.ProjectWidgetPopup.text=從版本控制中獲取…
action.RubyMineProjectFromVersionControlAction.text=來自版本控制的專案…
action.RulerGuide.text=標尺參考線
action.RunAnything.description=允許執行任何指令
action.RunAnything.text=執行任何內容
action.RunConfiguration.description=選擇執行/偵錯組態
action.RunConfiguration.text=選擇執行/偵錯組態
action.RunConfigurationTemplatesForNewProjects.MainMenu.text=執行組態模板…
action.RunDashboard.AddType.text=執行組態類型
action.RunDashboard.ClearContent.text=清除內容
action.RunDashboard.CopyConfiguration.text=複製組態
action.RunDashboard.Debug.text=偵錯
action.RunDashboard.EditConfiguration.text=編輯所選組態
action.RunDashboard.GroupByStatus.text=狀態
action.RunDashboard.GroupByType.text=類型
action.RunDashboard.GroupConfigurations.text=分組組態
action.RunDashboard.HideConfiguration.text=隱藏組態
action.RunDashboard.OpenRunningConfigInNewTab.text=在新頁籤中開啟執行組態
action.RunDashboard.RemoveType.text=從服務中移除組態類型
action.RunDashboard.RestoreConfiguration.text=還原組態
action.RunDashboard.RestoreHiddenConfigurations.text=還原隱藏的組態
action.RunDashboard.Run.text=執行
action.RunDashboard.Stop.text=停止
action.RunDashboard.UngroupConfigurations.text=對組態取消分組
action.RunToCursor.description=跳轉到文字游標所在的行
action.RunToCursor.text=執行到游標處(_C)
action.RunToolbarEditConfigurationAction.text=編輯組態…
action.RunToolbarHotSwapAction.text=熱交換
action.RunToolbarMainMultipleStopAction.text=停止
action.RunToolbarMainRunConfigurationsAction.text=新增組態…
action.RunToolbarMainSlotActive.text=有效程序
action.RunToolbarMainSlotInfoAction.text=有效程序
action.RunToolbarMoveToTopAction.text=將組態移至頂部
action.RunToolbarPauseAction.text=暫停
action.RunToolbarProcessStartedAction.text=有效程序
action.RunToolbarRemoveSlotAction.terminating=正在終止
action.RunToolbarRemoveSlotAction.text=移除
action.RunToolbarRerunAction.text=重新執行
action.RunToolbarResumeAction.text=恢復
action.RunToolbarRollbackToPrevious.text=復原到上一個工具列
action.RunToolbarRunConfigurationsAction.text=新增組態…
action.RunToolbarShowHidePopupAction.click.to.open.combo.text=點擊以選擇執行組態
action.RunToolbarShowHidePopupAction.click.to.open.toolwindow.text=點擊以開啟“程序”工具視窗
action.RunToolbarShowHidePopupAction.click.to.show.popup.text=點擊以顯示或隱藏停靠的組態
action.RunToolbarShowHidePopupAction.show.popup.text=顯示或隱藏停靠的組態
action.RunToolbarShowHidePopupAction.text=同時啟動多個組態
action.RunToolbarShowToolWindowTab.text=顯示“程序”工具視窗
action.RunToolbarStopAction.text=停止
action.RunToolbarWidgetAction.text=執行/偵錯小工具
action.Runner.CloseAllUnpinnedViews.description=關閉所有未固定的頁籤
action.Runner.CloseAllUnpinnedViews.text=關閉所有未固定的
action.Runner.CloseAllViews.description=關閉所有檢視
action.Runner.CloseAllViews.text=關閉所有
action.Runner.CloseOtherViews.description=關閉其他檢視
action.Runner.CloseOtherViews.text=關閉其他
action.Runner.CloseView.description=關閉檢視
action.Runner.CloseView.text=關閉
action.Runner.FocusOnStartup.description=當 UI 顯示時預設切換到該檢視
action.Runner.FocusOnStartup.text=在啟動時獲取焦點
action.Runner.RestoreLayout.description=將偵錯器會話的可視元素還原為預設狀態
action.Runner.RestoreLayout.text=還原為預設布局
action.Runner.ToggleTabLabels.text=顯示頁籤標籤
action.SafeDelete.description=刪除所選類別、方法或欄位，並檢查使用
action.SafeDelete.text=安全刪除(_D)…
action.SaveAll.description=儲存所有檔案和設定
action.SaveAll.text=全部儲存(_S)
action.SaveAs.text=另存為…
action.SaveAsNewFormat.text=另存為基於目錄的格式…
action.SaveAsTemplate.description=將所選文本儲存為實時模板
action.SaveAsTemplate.text=儲存為實時模板(_I)…
action.SaveDocument.description=只儲存在當前編輯器中開啟的檔案
action.SaveDocument.text=儲存文檔
action.SaveFileAsTemplate.description=將當前檔案另存為模板
action.SaveFileAsTemplate.text=將檔案另存為模板(_L)…
action.SaveProjectAsTemplate.text=將專案另存為模板…
action.ScanSourceCommentsAction.text=傾印專案中的所有註釋
action.ScopeView.EditScopes.description=編輯作用域…
action.ScopeView.EditScopes.text=編輯作用域(_I)…
action.Scratch.ChangeLanguage.description=更改臨時檔案語言
action.Scratch.ChangeLanguage.text=更改檔案語言
action.Scratch.ExportToScratch.description=作為文本匯出到新的臨時檔案
action.Scratch.ExportToScratch.text=匯出到臨時檔案
action.Scratch.ShowFilesPopup.description=在彈出視窗中顯示臨時檔案
action.Scratch.ShowFilesPopup.text=顯示臨時檔案
action.ScrollPane-scrollDown.description=將周圍的可滾動區域向下滾動一頁。
action.ScrollPane-scrollDown.text=向下滾動頁面
action.ScrollPane-scrollEnd.description=將周圍的可滾動區域滾動到底部。
action.ScrollPane-scrollEnd.text=滾動至頁尾
action.ScrollPane-scrollHome.description=將周圍的可滾動區域滾動到頂部。
action.ScrollPane-scrollHome.text=滾動至頁首
action.ScrollPane-scrollLeft.description=將周圍的可滾動區域向左滾動一頁。
action.ScrollPane-scrollLeft.text=向左滾動頁面
action.ScrollPane-scrollRight.description=將周圍的可滾動區域向右滾動一頁。
action.ScrollPane-scrollRight.text=向右滾動頁面
action.ScrollPane-scrollUp.description=將周圍的可滾動區域向上滾動一頁。
action.ScrollPane-scrollUp.text=向上滾動頁面
action.ScrollPane-unitScrollDown.description=將周圍的可滾動區域向下滾動一個單位。
action.ScrollPane-unitScrollDown.text=向下滾動
action.ScrollPane-unitScrollLeft.description=將周圍的可滾動區域向左滾動一個單位。
action.ScrollPane-unitScrollLeft.text=向左滾動
action.ScrollPane-unitScrollRight.description=將周圍的可滾動區域向右滾動一個單位。
action.ScrollPane-unitScrollRight.text=向右滾動
action.ScrollPane-unitScrollUp.description=將周圍的可滾動區域向上滾動一個單位。
action.ScrollPane-unitScrollUp.text=向上滾動
action.ScrollTreeToCenter.text=滾動到中心
action.SearchEverywhere.CompleteCommand.description=在 Search Everywhere 對話框中自動補全指令
action.SearchEverywhere.CompleteCommand.text=補全指令
action.SearchEverywhere.NavigateToNextGroup.description=在 Search Everywhere 對話框中導覽到下一個組
action.SearchEverywhere.NavigateToNextGroup.text=下一個組元素
action.SearchEverywhere.NavigateToPrevGroup.description=在 Search Everywhere 對話框中導覽到上一個組
action.SearchEverywhere.NavigateToPrevGroup.text=上一個組元素
action.SearchEverywhere.NextTab.description=在 Search Everywhere 對話框中切換到下一個頁籤
action.SearchEverywhere.NextTab.text=下一個頁籤
action.SearchEverywhere.PrevTab.description=在 Search Everywhere 對話框中切換到上一個頁籤
action.SearchEverywhere.PrevTab.text=上一個頁籤
action.SearchEverywhere.SelectItem.description=在 Search Everywhere 對話框中選擇項
action.SearchEverywhere.SelectItem.text=選擇項
action.SearchEverywhere.description=搜尋類別、檔案、工具視窗、動作和偏好設定
action.SearchEverywhere.text=隨處搜尋
action.SearchEverywhereNewToolbarAction.text=隨處搜尋
action.SearchEverywhereToolbar.searching.text=正在搜尋…
action.SearchEverywhereToolbar.text=隨處搜尋 
action.SearchEverywhereToolbarHotKey.hotkey=Shift+Shift
action.SearchEverywhereToolbarHotKey.text=隨處搜尋 {0}
action.SegmentedButton-left.text=選擇上一個分段按鈕
action.SegmentedButton-right.text=選擇下一個分段按鈕
action.SegmentedVcsControlAction.text=VCS 小工具
action.SelectAllOccurrences.description=通過將當前單詞的所有符合項新增到選區來設定多個游標。
action.SelectAllOccurrences.text=選擇所有符合項
action.SelectAndDumpInvalidTipsOfTheDay.text=選擇並傾印無效的每日小技巧
action.SelectAndShowTip.text=選擇並顯示提示(_S)
action.SelectIn.description=在任意檢視下選擇當前的類別或方法
action.SelectIn.text=選擇(_L)…
action.SelectInProjectView.description=在專案檢視中選擇上下文檔案
action.SelectInProjectView.text=在專案檢視中選擇檔案
action.SelectNextOccurrence.description=通過將當前單詞的下一個符合項新增到選區來設定多個游標。
action.SelectNextOccurrence.text=將下一個符合項新增到選擇
action.SelectOpenedFileInProjectView.description=在專案檢視中選擇已開啟的檔案
action.SelectOpenedFileInProjectView.text=選擇開啟的檔案
action.SelectVirtualTemplateElement.text=顯示用於就地重構的選項彈出視窗
action.SendEOF.text=發送 EOF
action.SendEventLogStatistics.description=將事件日誌檔案發送到 QA 伺服器
action.SendEventLogStatistics.text=發送功能使用事件日誌
action.SendFeedback.detailed.description=提交意見反應給 {0}
action.SendFeedback.text=提交意見反應(_F)…
action.ServiceView.ConfigureServices.text=Configure Services Tool Window
action.ServiceView.GroupByContributor.text=服務類型
action.ServiceView.GroupByServiceGroups.text=服務組
action.ServiceView.JumpToServices.text=跳轉到服務
action.ServiceView.OpenEachInNewTab.text=在新頁籤中開啟每個項
action.ServiceView.OpenInNewTab.text=在新頁籤中開啟
action.ServiceView.OpenInToolWindow.text=在單獨的工具視窗中開啟
action.ServiceView.ShowServices.text=顯示服務樹
action.ServiceView.SplitByType.text=在新頁籤中開啟每個類型
action.SetCaretVisualAttributesInternalAction.text=設定文字游標視覺特性…
action.SetShortcutAction.text=新增快捷鍵…
action.SeverityEditorDialogAction.text=顯示嚴重性編輯器
action.ShelveChanges.UnshelveWithDialog.description=更正套用更新檔的路徑並取消擱置
action.ShelveChanges.UnshelveWithDialog.text=取消擱置…
action.ShelvedChanges.Rename.description=重新命名擱置的更改列表
action.ShelvedChanges.Rename.text=重新命名…
action.ShelvedChanges.Restore.text=還原已套用的擱置更改
action.ShelvedChanges.ShowHideDeleted.description=顯示/隱藏已取消擱置更改
action.ShelvedChanges.ShowHideDeleted.text=顯示/隱藏已套用的擱置更改
action.Show.Current.Revision.text=顯示當前修訂
action.ShowAboutPopupInDebugModeAction.text=在偵錯模式下顯示“關於”彈出視窗
action.ShowBackwardPackageDeps.MainMenu.text=向後相依關係(_B)…
action.ShowBackwardPackageDeps.description=瀏覽使用的程式碼所選分析條目
action.ShowBackwardPackageDeps.text=分析向後相依關係(_B)…
action.ShowBlankDiffWindow.description=並排開啟兩個編輯器並比較他們的內容
action.ShowBlankDiffWindow.synonym1=開啟空的差異視窗
action.ShowBlankDiffWindow.synonym2=開啟新的差異視窗
action.ShowBlankDiffWindow.text=開啟空白差異視窗
action.ShowBookmarks.text=顯示書籤…
action.ShowChangedStateStatisticsAction.description=呼叫所有狀態收集器，並僅顯示自上一個記錄以來已更改的事件
action.ShowChangedStateStatisticsAction.text=僅顯示已更改的狀態事件
action.ShowColorPicker.text=顯示取色器
action.ShowContent.description=顯示一個包含工具視窗頁籤列表的彈出視窗
action.ShowContent.text=顯示頁籤列表
action.ShowContent.views.text=顯示檢視列表
action.ShowControlFlowAction.text=顯示控制流
action.ShowDependenciesOnTarget.MainMenu.text=指定目標上的相依項
action.ShowDependenciesOnTarget.text=分析指定目標上的相依項
action.ShowDetailedInformationAction.text=顯示間接相依項
action.ShowDiscoveredTests.text=顯示受影響的測試
action.ShowEditorHighlighterTokens.text=顯示編輯器螢光筆令牌
action.ShowErrorDescription.description=顯示文字游標處錯誤或警告的說明
action.ShowErrorDescription.text=錯誤描述(_R)
action.ShowExecutionPoint.description=顯示當前程序執行點
action.ShowExecutionPoint.text=顯示執行點(_X)
action.ShowExperiments.text=實驗性功能…
action.ShowFilePath.description=顯示帶有當前檔案路徑的彈出視窗，以便在外部檔案管理器中開啟
action.ShowFilePath.popup=路徑彈出視窗(_P)
action.ShowFilePath.text=檔案路徑(_P)
action.ShowFontsUsedByEditor.description=允許找出編輯器中實際使用的回退字體
action.ShowFontsUsedByEditor.text=顯示編輯器使用的字體
action.ShowGotItDemo.text=顯示 GotIt 示範
action.ShowGutterIconsSettings.description=顯示對話框以組態裝訂區域圖示
action.ShowGutterIconsSettings.text=組態裝訂區域圖示…
action.ShowIntentionActions.text=顯示上下文動作
action.ShowLog.Explorer.text=在資源管理器中顯示日誌(_L)
action.ShowLog.Finder.text=在“訪達”中顯示日誌(_L)
action.ShowLog.description=開啟帶日誌檔案的目錄
action.ShowLog.text=在檔案管理器中顯示日誌(_L)
action.ShowMainMenu.text=顯示主選單
action.ShowMembersInNavigationBar.description=在導覽列中顯示/隱藏宣告
action.ShowMembersInNavigationBar.text=顯示成員
action.ShowModulesDependencies.MainMenu.text=模組相依項(_M)…
action.ShowModulesDependencies.description=顯示專案中模組之間的相依關係
action.ShowModulesDependencies.text=分析模組相依關係(_M)…
action.ShowNavBar.ShortText=導覽列
action.ShowNavBar.text=跳轉到導覽列(_J)
action.ShowNonRetinaImages.text=顯示非視網膜圖片
action.ShowNotificationIconsDialogAction.text=測試通知圖示
action.ShowPackageCycles.MainMenu.text=迴圈相依關係(_C)…
action.ShowPackageCycles.description=瀏覽迴圈中使用的程式碼所選分析條目
action.ShowPackageCycles.text=分析迴圈相依關係(_C)…
action.ShowPackageDeps.MainMenu.text=相依項(_D)…
action.ShowPackageDeps.description=瀏覽所選分析項所相依的程式碼
action.ShowPackageDeps.text=分析相依關係(_D)…
action.ShowParameterHintsSettings.description=開啟參數名稱提示設定
action.ShowParameterHintsSettings.text=提示設定…
action.ShowPopupMenu.text=顯示右鍵選單
action.ShowProcessWindow.description=顯示/隱藏背景任務視窗
action.ShowProcessWindow.double.click=點擊以顯示/隱藏背景任務視窗
action.ShowProcessWindow.text=顯示
action.ShowProgressTestDialogAction.text=測試進度指示器
action.ShowProjectStructureSettings.description=組態專案結構
action.ShowProjectStructureSettings.text=專案結構…
action.ShowRecentTests.text=最近的測試
action.ShowReformatFileDialog.text=重新格式化檔案…
action.ShowRegistry.text=註冊表…
action.ShowSearchEverywhereItemInfo.text=顯示“隨處搜尋”條目資訊
action.ShowSearchHistory.text=顯示搜尋歷史記錄
action.ShowSettingsAndFindUsages.description=為“尋找用法”動作選擇作用域和編輯選項
action.ShowSettingsAndFindUsages.text=尋找用法設定…
action.ShowSiblings.description=顯示包含符號同級內容的彈出視窗
action.ShowSiblings.text=顯示同級
action.ShowSouthPanelTestDialogAction.text=測試 DialogWrapper 南側面板
action.ShowSplash.text=顯示初始頁面
action.ShowTips.description=學習如何提高編碼效率。
action.ShowTips.text=每日小技巧(_T)
action.ShowToolbar.text=顯示工具列
action.ShowTypeBookmarks.text=轉到助記鍵…
action.ShowUpdateDialogAction.text=顯示“更新”對話框
action.ShowUsageFeatures.text=顯示用法功能
action.ShowUsages.description=顯示文字游標處符號的用法
action.ShowUsages.text=顯示用法(_S)
action.SilentCodeCleanup.description=執行清理檢查並使用當前檢查組態檔案套用快速修復
action.SilentCodeCleanup.text=靜默程式碼清理
action.SilentHeapDumpSnapshot.text=建立並計劃堆傾印分析 (非使用者呼叫)
action.SkipWindowDeactivationEvents.description=Turn on to simplify debugging. When a breakpoint in the debug IDE is hit, the main IDE steals focus, and \`WINDOW_DEACTIVATED\` events in the debug IDE trigger the cancellation of popups or file analysis, making \`ProgressManager.checkCanceled()\` throw right away without giving a chance to debug.
action.SkipWindowDeactivationEvents.text=Skip Window Deactivation Events
action.SliceBackward.MainMenu.text=流入此處的資料(_T)…
action.SliceBackward.description=搜尋可以分配給所選表達式的值
action.SliceBackward.text=分析流入此處的資料(_T)…
action.SliceForward.MainMenu.text=流出此處的資料(_F)…
action.SliceForward.description=搜尋從此位置轉義的值
action.SliceForward.text=分析流出此處的資料(_F)…
action.SmartSelect.text=擴展選區
action.SmartStepInto.description=步入特定方法
action.SmartStepInto.text=智能步入(_P)
action.SmartTypeCompletion.description=基於預期類型補全程式碼
action.SmartTypeCompletion.synonym=SmartType
action.SmartTypeCompletion.text=類型符合
action.SmartUnSelect.text=收縮選區
action.SplitChooser.Duplicate.text=複製
action.SplitChooser.Exit.text=退出選擇器
action.SplitChooser.NextWindow.text=下一個拆分
action.SplitChooser.PreviousWindow.text=上一個拆分
action.SplitChooser.Split.text=拆分
action.SplitChooser.SplitCenter.text=無拆分
action.SplitChooser.SplitDown.text=使用向下拆分或向下切換
action.SplitChooser.SplitLeft.text=使用左拆分或左切換
action.SplitChooser.SplitRight.text=使用右拆分或右切換
action.SplitChooser.SplitTop.text=使用頂部拆分或向上切換
action.SplitChooser.description=允許在編輯器中互動選擇拆分位置，並在該處開啟/移動所選檔案
action.SplitChooser.text=通過選擇器以拆分方式開啟…
action.SplitHorizontally.description=將編輯器區域拆分為 2 個頁籤組，然後將當前檔案移至底部組
action.SplitHorizontally.synonym=水平拆分
action.SplitHorizontally.text=向下拆分
action.SplitVertically.description=將編輯器區域拆分為 2 個頁籤組，然後將當前檔案移至右側組
action.SplitVertically.synonym=垂直拆分
action.SplitVertically.text=向右拆分
action.Start.Use.Vcs.Vcs.Toolbar.Widget.text=其他服務…
action.Start.Use.Vcs.text=啟用版本控制整合(_E)…
action.StartStopMacroRecording.description=啟動/停止新巨集錄製
action.StartStopMacroRecording.text=啟動/停止巨集錄製(_R)
action.StaticIconFields.text=列出 static 圖示欄位初始設定式
action.StatusTextModeAction.text=狀態文本
action.StepInto.description=單步執行至已執行的下一行
action.StepInto.text=步入(_I)
action.StepOut.description=單步執行至從此方法返回後執行的第一行
action.StepOut.text=步出(_T)
action.StepOver.description=單步執行至此檔案中的下一行
action.StepOver.text=步過(_O)
action.Stop.description=停止程序
action.Stop.text=停止
action.StopBackgroundProcesses.description=停止背景程序
action.StopBackgroundProcesses.text=停止背景程序…
action.StopWithDropDown.text=通過選項停止
action.StoreDefaultLayout.description=存儲當前所選布局
action.StoreDefaultLayout.synonym=存儲當前布局
action.StoreDefaultLayout.text=存儲當前布局(_Y)
action.StoreNamedLayout.description=將當前布局存儲為“{0}”
action.StoreNewLayout.MainMenu.text=新增(_N)…
action.StoreNewLayout.description=以新名稱存儲當前布局
action.StoreNewLayout.text=將當前布局存儲為…
action.StretchSplitToBottom.description=將拆分的編輯器延伸至底部
action.StretchSplitToBottom.text=將編輯器延伸至底部
action.StretchSplitToLeft.description=將拆分的編輯器延伸至左側
action.StretchSplitToLeft.text=將編輯器延伸至左側
action.StretchSplitToRight.description=將拆分的編輯器延伸至右側
action.StretchSplitToRight.text=將編輯器延伸至右側
action.StretchSplitToTop.description=將拆分的編輯器延伸至頂部
action.StretchSplitToTop.text=將編輯器延伸至頂部
action.StructuralSearchPlugin.StructuralReplaceAction.description=結構取代
action.StructuralSearchPlugin.StructuralReplaceAction.text=結構化取代(_C)…
action.StructuralSearchPlugin.StructuralSearchAction.description=結構搜尋
action.StructuralSearchPlugin.StructuralSearchAction.text=結構搜尋(_T)…
action.SurroundWith.description=使用 if/while/try-catch 或其他結構包圍所選程式碼段
action.SurroundWith.text=包圍方式(_S)…
action.SurroundWithEmmet.description=使用 Emmet 縮寫包圍所選程式碼
action.SurroundWithEmmet.text=使用 Emmet 包圍
action.SurroundWithLiveTemplate.description=使用一個模板包圍選區
action.SurroundWithLiveTemplate.text=使用實時模板包圍(_P)…
action.SwapSidesInDiffWindow.text=交換兩側
action.SwapThreeWayColorModeInDiffWindow.text=更改三向檢視器模式
action.SwitchCoverage.text=顯示程式碼覆蓋率資料(_V)
action.SwitchFileBasedIndexStorageAction.text=切換基於檔案的索引存儲
action.SwitchIdeScaleAction.text=縮放 IDE
action.Switcher.text=切換器
action.SwitcherBackward.text=選擇上一行
action.SwitcherForward.text=選擇下一行
action.SwitcherIterateItems.text=迭代最近的檔案
action.SwitcherNextProblem.text=選擇下一個問題檔案
action.SwitcherPreviousProblem.text=選擇上一個問題檔案
action.SwitcherRecentEditedChangedToggleCheckBox.text=切換僅更改的檔案
action.Synchronize.description=檢測所有外部更改的檔案，並從磁碟重新載入
action.Synchronize.text=從磁碟全部重新載入
action.SynchronizeCurrentFile.text=從磁碟重新載入
action.TabList.description=使用包含在單行頁籤布局中不適合螢幕的頁籤列表的下拉列表
action.TabList.text=顯示隱藏的頁籤
action.Tabbed.WelcomeScreen.OpenProject.text=開啟
action.Table-scrollDownChangeSelection.description=將周圍的可滾動區域向下滾動一頁，然後選擇相應的行。
action.Table-scrollDownChangeSelection.text=向下滾動頁面並選擇行
action.Table-scrollDownExtendSelection.description=將周圍的可滾動區域向下滾動一頁，然後將相應的行新增到選區。
action.Table-scrollDownExtendSelection.text=向下滾動頁面並擴展選區
action.Table-scrollUpChangeSelection.description=將周圍的可滾動區域向上滾動一頁，然後選擇相應的行。
action.Table-scrollUpChangeSelection.text=向上滾動頁面並選擇行
action.Table-scrollUpExtendSelection.description=將周圍的可滾動區域向上滾動一頁，然後將相應的行新增到選區。
action.Table-scrollUpExtendSelection.text=向上滾動頁面並擴展選區
action.Table-selectFirstRow.description=選擇第一行。
action.Table-selectFirstRow.text=選擇第一行
action.Table-selectFirstRowExtendSelection.description=滾動到第一行並將相應的行新增到選區。
action.Table-selectFirstRowExtendSelection.text=將選區擴展到第一行
action.Table-selectLastRow.description=選擇最後一行。
action.Table-selectLastRow.text=選擇最後一行
action.Table-selectLastRowExtendSelection.description=滾動到最後一行並將相應的行新增到選區。
action.Table-selectLastRowExtendSelection.text=將選區擴展到最後一行
action.Table-selectNextColumn.description=選擇下一列。
action.Table-selectNextColumn.text=選擇下一列
action.Table-selectNextColumnExtendSelection.description=將下一列新增到選區。
action.Table-selectNextColumnExtendSelection.text=將選區擴展到下一列
action.Table-selectNextRow.description=選擇下一行。
action.Table-selectNextRow.text=選擇下一行
action.Table-selectNextRowExtendSelection.description=將下一行新增到選區。
action.Table-selectNextRowExtendSelection.text=將選區擴展到下一行
action.Table-selectPreviousColumn.description=選擇上一列。
action.Table-selectPreviousColumn.text=選擇上一列
action.Table-selectPreviousColumnExtendSelection.description=將上一列新增到選區。
action.Table-selectPreviousColumnExtendSelection.text=將選區擴展到上一列
action.Table-selectPreviousRow.description=選擇上一行。
action.Table-selectPreviousRow.text=選擇上一行
action.Table-selectPreviousRowExtendSelection.description=將上一行新增到選區。
action.Table-selectPreviousRowExtendSelection.text=將選區擴展到上一行
action.Table-startEditing.text=編輯表單元
action.TechnicalSupport.description=聯繫 JetBrains 網站上的技術支援
action.TechnicalSupport.text=聯繫支援(_S)…
action.TemplateProjectStructure.MainMenu.text=結構…
action.TestCoroutineProgress.text=測試協同程序進度
action.TestDndAction.text=測試 Dnd
action.TestGestureAction.text=測試手勢動作
action.TestIconMappings.text=測試圖示映射
action.TestMessageBoxAction.text=顯示測試對話框
action.TestParseEventsSchemeAction.text=測試解析事件方案…
action.TestProgressWindow.text=測試進度視窗
action.TestSearchContributors.text=SE 貢獻者測試
action.TestTextFieldAction.text=測試文本欄位
action.TestTooltipsAction.text=測試工具提示
action.TextComponent.ClearAction.description=清除文本元件中的文本
action.TextComponent.ClearAction.text=清除文本
action.TextEditorWithPreview.SplitHorizontally.text=水平布局
action.TextEditorWithPreview.SplitVertically.text=垂直布局
action.TextGrayFilterConfig.text=文本灰色篩選器(&T)
action.TextSearchAction.description=在“隨處搜尋”中顯示文本符合項
action.TextSearchAction.text=文本…
action.ToggleBookmark.text=切換書籤(_B)
action.ToggleBookmarkWithMnemonic.text=切換書籤助記鍵…
action.ToggleBreakpointEnabled.description=啟用/停用當前行的中斷點
action.ToggleBreakpointEnabled.text=切換中斷點啟用狀態(_B)
action.ToggleCompactMode.text=緊湊模式
action.ToggleCompletionHintsAction.text=補全時顯示參數名稱提示
action.ToggleContentUiTypeMode.description=切換內容的標籤式/組合式顯示
action.ToggleContentUiTypeMode.text=頁籤分組
action.ToggleDistractionFreeMode.description=切換免打擾模式
action.ToggleDistractionFreeMode.enter=進入免打擾模式
action.ToggleDistractionFreeMode.exit=退出免打擾模式
action.ToggleDistractionFreeMode.text=切換免打擾模式
action.ToggleDockMode.description=停靠/取消停靠活動工具視窗
action.ToggleDockMode.text=停靠模式(_E)
action.ToggleEssentialHighlighting.description=基本醒目提示模式只保留一組有限的程式碼醒目提示工具。包括檢查在內的所有醒目提示工具都將在執行檔案儲存動作時執行
action.ToggleEssentialHighlighting.text=基本醒目提示顯示
action.ToggleFieldBreakpoint.MainMenu.text=欄位觀察點
action.ToggleFieldBreakpoint.description=為文字游標處的欄位切換欄位觀察點
action.ToggleFieldBreakpoint.text=切換欄位觀察點(_F)
action.ToggleFindInSelection.text=僅在選區內搜尋
action.ToggleFloatingMode.description=浮動/取消浮動活動工具視窗
action.ToggleFloatingMode.text=浮動模式(_M)
action.ToggleFocusMode.text=僅醒目提示當前宣告
action.ToggleFullScreen.description=切換全螢幕模式
action.ToggleFullScreen.text=切換全螢幕模式
action.ToggleFullScreen.text.enter=進入全螢幕
action.ToggleFullScreen.text.exit=退出全螢幕
action.ToggleInlineHintsAction.description=切換參數名稱提示
action.ToggleInlineHintsAction.text=切換參數名稱提示
action.ToggleLineBreakpoint.MainMenu.text=行中斷點(_L)
action.ToggleLineBreakpoint.description=切換文字游標處的行中斷點
action.ToggleLineBreakpoint.text=切換行中斷點(_L)
action.ToggleMethodBreakpoint.MainMenu.text=方法中斷點(_M)
action.ToggleMethodBreakpoint.description=為文字游標處的方法切換方法中斷點
action.ToggleMethodBreakpoint.text=切換方法中斷點(_M)
action.TogglePinnedMode.description=固定/取消固定活動工具視窗
action.TogglePinnedMode.text=固定模式(_P)
action.TogglePopupHints.text=切換當前檔案的彈出視窗提示
action.TogglePowerSave.description=省電模式將停用背景程式碼分析和其他背景動作
action.TogglePowerSave.text=省電模式
action.TogglePresentationMode.description=切換示範模式
action.TogglePresentationMode.enter=進入示範模式
action.TogglePresentationMode.exit=退出示範模式
action.TogglePresentationMode.text=切換示範模式
action.TogglePresentationMode.text.enter=進入示範模式
action.TogglePresentationMode.text.exit=退出示範模式
action.ToggleReadOnlyAttribute.description=切換當前檔案的唯讀特性
action.ToggleReadOnlyAttribute.dirs=使{3,choice,1#目錄|2#目錄}{0,choice,0#唯讀|1#可寫}
action.ToggleReadOnlyAttribute.files=將{2,choice,1#檔案|2#檔案}設為{0,choice,0#唯讀|1#可寫}
action.ToggleReadOnlyAttribute.mixed=使檔案/目錄{0,choice,0#唯讀|1#可寫}
action.ToggleReadOnlyAttribute.synonym=將檔案設為可寫
action.ToggleReadOnlyAttribute.synonym2=將檔案設為唯讀
action.ToggleReadOnlyAttribute.text=切換唯讀特性
action.ToggleRenderedDocPresentation.description=在檢視原始碼和文檔註釋的渲染表示之間切換
action.ToggleRenderedDocPresentation.text=切換呈現檢視
action.ToggleRenderedDocPresentationForAll.description=切換到所有文檔註釋的呈現檢視
action.ToggleRenderedDocPresentationForAll.text=呈現所有文檔註釋
action.ToggleSideMode.description=開啟/關閉工具視窗拆分模式
action.ToggleSideMode.text=拆分模式
action.ToggleTemporaryLineBreakpoint.MainMenu.text=臨時行中斷點
action.ToggleTemporaryLineBreakpoint.description=切換文字游標處的臨時行中斷點
action.ToggleTemporaryLineBreakpoint.text=切換臨時行中斷點
action.ToggleThreeSideInBlankDiffWindow.text=切換三向檢視器
action.ToggleThreeSideInBlankDiffWindow.text.disable=切換到兩向檢視器
action.ToggleThreeSideInBlankDiffWindow.text.enable=切換到三向檢視器
action.ToggleUiInspectorHierarchyTrace.text=切換 UI 檢查器層次結構追蹤
action.ToggleUiInspectorHierarchyTrace.text.disable=停用 UI 檢查器層次結構追蹤
action.ToggleUiInspectorHierarchyTrace.text.enable=啟用 UI 檢查器層次結構追蹤
action.ToggleUnusedState.description=Signal the IDE is either not used or used.
action.ToggleUnusedState.text=Signal IDE Not Used
action.ToggleWindowedMode.description=視窗化/取消視窗化活動工具視窗
action.ToggleWindowedMode.text=視窗化模式(_W)
action.ToggleZenMode.description=同時切換免打擾和全螢幕模式
action.ToggleZenMode.enter=進入 Zen 模式
action.ToggleZenMode.exit=退出 Zen 模式
action.ToggleZenMode.text=切換 Zen 模式
action.ToolwindowSwitcher.text=工具視窗切換器
action.TopStripeEnableAction.text=使用單個工具視窗列
action.TopStripePinButton.text=固定
action.TopStripeUnPinButton.text=取消固定
action.TransferSettingsDemoAction.text=測試傳輸設定
action.Tree-scrollDownChangeSelection.description=將周圍的可滾動區域向下滾動一頁，然後選擇相應的節點。
action.Tree-scrollDownChangeSelection.text=向下滾動頁面並選擇節點
action.Tree-scrollDownExtendSelection.description=將周圍的可滾動區域向下滾動一頁，然後將相應的節點新增到選區。
action.Tree-scrollDownExtendSelection.text=向下滾動頁面並擴展選區
action.Tree-scrollUpChangeSelection.description=將周圍的可滾動區域向上滾動一頁，然後選擇相應的節點。
action.Tree-scrollUpChangeSelection.text=向上滾動頁面並選擇節點
action.Tree-scrollUpExtendSelection.description=將周圍的可滾動區域向上滾動一頁，然後將相應的節點新增到選區。
action.Tree-scrollUpExtendSelection.text=向上滾動頁面並擴展選區
action.Tree-selectChild.description=展開摺疊的節點或選擇子節點。
action.Tree-selectChild.text=選擇子節點
action.Tree-selectChildExtendSelection.description=展開摺疊的節點或將子節點新增到選區。
action.Tree-selectChildExtendSelection.text=將選區擴展到子節點
action.Tree-selectFirst.description=選擇第一個節點。
action.Tree-selectFirst.text=選擇第一個節點
action.Tree-selectFirstExtendSelection.description=滾動到第一個節點並將相應的節點新增到選區。
action.Tree-selectFirstExtendSelection.text=將選區擴展到第一個節點
action.Tree-selectLast.description=選擇最後一個節點。
action.Tree-selectLast.text=選擇最後一個節點
action.Tree-selectLastExtendSelection.description=滾動到最後一個節點並將相應的節點新增到選區。
action.Tree-selectLastExtendSelection.text=將選區擴展到最後一個節點
action.Tree-selectNext.description=選擇下一個節點。
action.Tree-selectNext.text=選擇下一個節點
action.Tree-selectNextExtendSelection.description=將下一個節點新增到選區。
action.Tree-selectNextExtendSelection.text=將選區擴展到下一個節點
action.Tree-selectNextSibling.description=選擇下一個同級節點。
action.Tree-selectNextSibling.text=選擇下一個同級節點
action.Tree-selectParent.description=摺疊展開的節點或選擇父節點。
action.Tree-selectParent.text=選擇父節點
action.Tree-selectParentExtendSelection.description=滾動到父節點並將相應的節點新增到選區。
action.Tree-selectParentExtendSelection.text=將選區擴展到父節點
action.Tree-selectParentNoCollapse.description=選擇父節點(不摺疊展開的節點)。
action.Tree-selectParentNoCollapse.text=選擇父節點
action.Tree-selectPrevious.description=選擇上一個節點。
action.Tree-selectPrevious.text=選擇上一個節點
action.Tree-selectPreviousExtendSelection.description=將上一個節點新增到選區。
action.Tree-selectPreviousExtendSelection.text=將選區擴展到上一個節點
action.Tree-selectPreviousSibling.description=選擇上一個同級節點。
action.Tree-selectPreviousSibling.text=選擇上一個同級節點
action.Tree-startEditing.text=編輯樹節點
action.TreeExpandAll.text=展開樹
action.TriggerLowMemoryNotification.text=觸發低記憶體通知
action.TrustProject.text=信任
action.TurnOnOffCachedValueProfilerAction.text=開啟快取值分析器
action.TurnRefsToSuper.description=將類別的用法更改為其超類別或接口的用法
action.TurnRefsToSuper.text=盡可能使用接口(_W)…
action.TypeHierarchy.Class.text=類別層次結構
action.TypeHierarchy.Subtypes.text=子類型層次結構
action.TypeHierarchy.Supertypes.text=父類型層次結構
action.TypeHierarchy.description=瀏覽所選類別的層次結構
action.TypeHierarchy.text=類型層次結構(_H)
action.TypeHierarchyBase.BaseOnThisType.text=基於此類型
action.TypingLatencyReport.text=輸入延遲報告
action.UIDefaults.text=LaF 預設設定
action.UiDebugger.text=UI 偵錯器…
action.UiDslShowcaseAction.text=UI DSL 展示
action.UiDslTestAction.text=顯示 UI DSL 測試
action.UiInspector.text=UI 檢查器(&I)
action.UndockMode.description=使工具視窗滑動並在焦點丟失時自動隱藏
action.UndockMode.text=取消停靠(_D)
action.UnmarkRoot.text=取消標記
action.Unscramble.EditorPopup.text=堆疊追蹤或執行緒傾印(_S)…
action.Unscramble.description=開啟包含可導覽堆疊追蹤或執行緒傾印的主控台
action.Unscramble.text=分析堆疊追蹤或執行緒傾印(_S)…
action.UnselectPreviousOccurrence.description=從選區中移除單詞的當前符合項。
action.UnselectPreviousOccurrence.text=取消選擇符合項
action.Unsplit.description=取消拆分視窗
action.Unsplit.text=取消拆分(_S)
action.UnsplitAll.description=移除所有拆分器
action.UnsplitAll.text=取消全部拆分(_N)
action.UntrustProject.text=不信任
action.Unwrap.description=安全地解包或移除所選作用域
action.Unwrap.text=解包/移除(_W)…
action.UpdateFiles.text=更新(_U)
action.UpdateRunningApplication.text=更新正在執行的應用程式
action.UsageView.Exclude.description=將此用法從處理中排除
action.UsageView.Exclude.text=排除
action.UsageView.Include.description=將此用法包含到處理中
action.UsageView.Include.text=包含
action.UsageView.Remove.description=將此用法從處理中移除
action.UsageView.Remove.text=移除
action.UsageView.Rerun.description=重新執行搜尋
action.UsageView.Rerun.text=重新執行
action.UsageView.ShowRecentFindUsages.description=選擇並重新執行最近的尋找用法
action.UsageView.ShowRecentFindUsages.text=最近的尋找用法(_E)
action.UsedIconsListing.text=列出使用的圖示
action.UserInvokedFullAnalysis.text=建立並立即分析堆傾印
action.ValidateLocalHistory.text=驗證本地歷史記錄存儲
action.ValidateXml.description=驗證當前的 XML 檔案
action.ValidateXml.text=驗證(_V)
action.ValidationTest.text=驗證對話框測試
action.Vcs.ApplySelectedChanges.text=優選所選更改
action.Vcs.CopyCommitSubjectAction.description=將所選提交的主題複製到剪貼簿
action.Vcs.CopyCommitSubjectAction.text=複製提交主題
action.Vcs.CopyRevisionNumberAction.description=將選定提交的修訂號複製到剪貼簿
action.Vcs.CopyRevisionNumberAction.text=複製修訂號
action.Vcs.Diff.ExcludeChangedLinesFromCommit.template.text={0,choice,0#|1#Split Chunk and |2#Split Chunks and }Exclude {1,choice,0#Current Line|2#Selected Lines} from Commit
action.Vcs.Diff.ExcludeChangedLinesFromCommit.text=Split Chunks and Exclude Selected Lines from Commit
action.Vcs.Diff.IncludeChangedLinesIntoCommit.template.text={0,choice,0#|1#Split Chunk and |2#Split Chunks and }Include {1,choice,0#Current Line|2#Selected Lines} into Commit
action.Vcs.Diff.IncludeChangedLinesIntoCommit.text=Split Chunks and Include Selected Lines into Commit
action.Vcs.Diff.ShowCombinedDiff.description=在一處顯示全部所選更改的差異
action.Vcs.Diff.ShowCombinedDiff.text=顯示組合差異
action.Vcs.Diff.ShowDiffInEditorTab.text=在編輯器頁籤中顯示差異
action.Vcs.Diff.ShowDiffInNewWindow.text=在單獨的視窗中顯示差異
action.Vcs.Diff.ToggleDiffAligningMode.description=啟用雙面差異的更改對齊
action.Vcs.Diff.ToggleDiffAligningMode.popup@DiffToolbar.text=對齊更改醒目提示
action.Vcs.Diff.ToggleDiffAligningMode.text=在並排差異中對齊更改
action.Vcs.EditSource.text=編輯源
action.Vcs.GetVersion.description=從儲存庫獲取版本
action.Vcs.GetVersion.text=獲取
action.Vcs.IntegrateProject.description=整合專案
action.Vcs.IntegrateProject.text=整合專案(_G)
action.Vcs.MoveChangedLinesToChangelist.description=將所選行中的更改移至另一個更改列表…
action.Vcs.MoveChangedLinesToChangelist.text=將行移到另一個更改列表…
action.Vcs.Operations.Popup.Annotate.text=註解行動作
action.Vcs.Push.Force.text=強制推送(_F)
action.Vcs.Push.text=推送…
action.Vcs.QuickListPopupAction.description=包含常用 VCS 動作列表的上下文感知彈出視窗
action.Vcs.QuickListPopupAction.text=VCS 動作彈出視窗…
action.Vcs.RevertSelectedChanges.text=還原所選更改
action.Vcs.RollbackChangedLines.description=復原所選行中的更改
action.Vcs.RollbackChangedLines.text=復原行
action.Vcs.RunCommitChecks.text=執行提交檢查
action.Vcs.Show.Local.Changes.text=顯示本地更改
action.Vcs.Show.Shelf.text=顯示 Shelf
action.Vcs.ShowConsoleTab.text=在 VCS 主控台頁籤中顯示
action.Vcs.ShowDiffChangedLines.description=顯示所選行的差異
action.Vcs.ShowDiffChangedLines.text=顯示行的差異
action.Vcs.ShowDiffWithLocal.Before.description=將之前的所選修訂中的版本與當前版本進行比較
action.Vcs.ShowDiffWithLocal.Before.text=將之前版本與本地版本進行比較
action.Vcs.ShowDiffWithLocal.description=將所選修訂中的版本與當前版本進行比較
action.Vcs.ShowDiffWithLocal.text=與本地比較
action.Vcs.ShowHistoryForBlock.description=顯示編輯器選擇的歷史記錄
action.Vcs.ShowHistoryForBlock.text=顯示選區的歷史記錄(_F)…
action.Vcs.ShowHistoryForRevision.description=顯示檔案的歷史記錄，直到所選修訂版本
action.Vcs.ShowHistoryForRevision.text=迄今為止的歷史記錄
action.Vcs.ShowMessageHistory.description=顯示提交訊息歷史記錄
action.Vcs.ShowMessageHistory.text=提交訊息歷史記錄
action.Vcs.ShowTabbedFileHistory.description=顯示檔案的歷史記錄
action.Vcs.ShowTabbedFileHistory.text=顯示歷史記錄(_H)
action.Vcs.ToggleAmendCommitMode.description=修改當前分支的最新提交
action.Vcs.ToggleAmendCommitMode.text=修正提交
action.Vcs.Toolbar.ShowMoreActions.description=VCS 動作
action.Vcs.Toolbar.ShowMoreActions.text=版本控制
action.Vcs.UpdateProject.text=更新專案(_U)
action.Vcs.VcsClone.text=從版本控制中獲取…
action.Vcs.VcsClone.text.synonym1=簽出
action.Vcs.VcsClone.text.synonym2=克隆
action.VcsHistory.ShowAllAffected.description=顯示選中修訂中所做的所有更改
action.VcsHistory.ShowAllAffected.text=顯示所有受影響的檔案
action.VcsShowCurrentChangeMarker.description=顯示當前所選更改的彈出視窗
action.VcsShowCurrentChangeMarker.text=文字游標下的更改(_H)
action.VcsShowNextChangeMarker.description=轉到下一個更改
action.VcsShowNextChangeMarker.text=下一個更改(_H)
action.VcsShowPrevChangeMarker.description=轉到上一個更改
action.VcsShowPrevChangeMarker.text=上一個更改(_A)
action.VcsToolbarLabelAction.text=VCS 標籤
action.ViewBreakpoints.description=檢視和管理所有中斷點和觀察點
action.ViewBreakpoints.text=檢視中斷點(_K)…
action.ViewImportPopups.description=在當前檔案中切換顯示匯入彈出視窗
action.ViewImportPopups.text=顯示匯入彈出視窗
action.ViewInplaceComments.description=在樹檢視中顯示/隱藏額外資訊
action.ViewInplaceComments.text=樹檢視中的詳細資訊
action.ViewMainMenu.description=顯示/隱藏主選單
action.ViewMainMenu.text=主選單
action.ViewMembersInNavigationBar.NavBar.text=在導覽列中顯示成員
action.ViewMembersInNavigationBar.description=在導覽列中顯示/隱藏宣告
action.ViewMembersInNavigationBar.text=導覽列中的成員
action.ViewNavigationBar.NavBar.text=顯示導覽列
action.ViewNavigationBar.description=顯示/隱藏導覽列
action.ViewNavigationBar.text=導覽列(_V)
action.ViewNewToolbarAction.text=工具列
action.ViewObsoleteNavBarAction.text=導覽列
action.ViewObsoleteToolbarAction.text=工具列經典
action.ViewOfflineInspection.description=載入離線檢查結果
action.ViewOfflineInspection.text=檢視離線檢查結果(_O)…
action.ViewSource.description=開啟所選條目的編輯器
action.ViewSource.text=顯示源(_W)
action.ViewStatusBar.description=顯示/隱藏狀態列
action.ViewStatusBar.text=狀態列(_S)
action.ViewToolBar.description=顯示/隱藏主工具列
action.ViewToolBar.text=工具列(_T)
action.ViewToolButtons.description=顯示/隱藏工具視窗按鈕
action.ViewToolButtons.text=工具視窗
action.VirtualFileInfo.text=虛擬檔案資訊
action.WebBrowser.text=顯示 Web 瀏覽器(&W)
action.WelcomeScreen.ChangeProjectIcon.text=Set Custom Project Icon...
action.WelcomeScreen.Configure.Export.text=匯出設定
action.WelcomeScreen.Configure.Import.text=匯入設定…
action.WelcomeScreen.Configure.RestoreDefault.text=還原為預設設定…
action.WelcomeScreen.CopyProjectPath.text=複製路徑
action.WelcomeScreen.CreateDirectoryProject.description=建立一個新項目。
action.WelcomeScreen.CreateDirectoryProject.text=新增專案
action.WelcomeScreen.CreateNewProject.description=啟動“新項目”嚮導，它將引導您建立一個新項目。
action.WelcomeScreen.CreateNewProject.text=新增專案
action.WelcomeScreen.DevelopPlugins.description=開始開發延伸模組。
action.WelcomeScreen.DevelopPlugins.text=延伸模組開發
action.WelcomeScreen.EditGroup.text=編輯…
action.WelcomeScreen.ManageLicense.text=管理授權…
action.WelcomeScreen.NewGroup.text=新增專案組
action.WelcomeScreen.OpenDirectoryProject.description=開始在指定的檔案或目錄中編輯程式碼。
action.WelcomeScreen.OpenDirectoryProject.text=開啟
action.WelcomeScreen.OpenProject.description=開啟檔案或專案。您也可以通過拖放到歡迎頁面來開啟專案或編輯檔案。
action.WelcomeScreen.OpenProject.text=開啟或匯入
action.WelcomeScreen.OpenSelected.text=開啟選定項
action.WelcomeScreen.Plugins.Extensions.text=擴展
action.WelcomeScreen.Plugins.description=管理已安裝的延伸模組，以及從儲存庫下載新延伸模組
action.WelcomeScreen.Plugins.text=延伸模組
action.WelcomeScreen.RemoveSelected.text=從最近的專案中移除…
action.WhatsNewAction.description=了解此版本 IDE 中的新功能
action.WhatsNewAction.text=最新變化(_N)
action.WindowMode.description=將工具視窗移至單獨的框架
action.WindowMode.text=視窗(_W)
action.WriteActionUnderProgress.text=正在測試寫入動作
action.XDebugger.CompareValueWithClipboard.description=將所選節點的值與剪貼簿文本進行比較
action.XDebugger.CompareValueWithClipboard.text=與剪貼簿比較值
action.XDebugger.CopyName.description=將所選節點的名稱複製到剪貼簿
action.XDebugger.CopyName.text=複製名稱
action.XDebugger.CopyValue.description=將所選節點的值複製到剪貼簿
action.XDebugger.CopyValue.text=複製值
action.XDebugger.CopyWatch.text=複製監視
action.XDebugger.EditWatch.text=編輯…
action.XDebugger.Inline.description=在編輯器中顯示可用的偵錯器會話值
action.XDebugger.Inline.text=在編輯器中顯示變量值
action.XDebugger.Inspect.text=檢查…
action.XDebugger.JumpToSource.description=開啟所選條目的源
action.XDebugger.JumpToSource.text=跳轉到源
action.XDebugger.JumpToTypeSource.description=開啟所選值類型的源
action.XDebugger.JumpToTypeSource.text=跳轉到類型源
action.XDebugger.MoveWatchDown.text=下移監視
action.XDebugger.MoveWatchUp.text=上移監視
action.XDebugger.MuteBreakpoints.text=忽略中斷點
action.XDebugger.NewWatch.text=新增監視…
action.XDebugger.PinToTop.text=固定至頂部
action.XDebugger.PreviewTab.text=在預覽頁籤中開啟檔案
action.XDebugger.RemoveAllWatches.text=移除所有監視
action.XDebugger.RemoveWatch.text=移除監視
action.XDebugger.SetValue.description=修改所選節點的值
action.XDebugger.SetValue.text=設定值…
action.XDebugger.Show.Breakpoints.Over.Line.Numbers.text=在行號上顯示中斷點
action.XDebugger.SwitchWatchesInVariables.text=在“變數”頁籤中顯示監視
action.XDebugger.ToggleEvaluateExpressionField.text=顯示“對表達式求值”欄位
action.XDebugger.ToggleSortValues.description=在偵錯器檢視中按字母順序排列值
action.XDebugger.ToggleSortValues.text=按字母順序對變數進行排序
action.XDebugger.UnmuteOnStop.text=在會話完成時取消忽略中斷點
action.XSD2Document.text=從 XML 檔案生成 XSD 架構…
action.XcodeBuildSwiftDocumentationAction.description=為所有目標建置文檔
action.XcodeBuildSwiftDocumentationAction.text=建置文檔
action.XcodePreviewSwiftDocumentationAction.description=為所有目標建置並預覽文檔
action.XcodePreviewSwiftDocumentationAction.text=預覽文檔
action.ZoomCurrentWindow.description=縮放當前視窗
action.ZoomCurrentWindow.text=縮放
action.ZoomInIdeAction.text=放大 IDE
action.ZoomOutIdeAction.text=縮小 IDE
action.addQuickAction.BackForward.text=後退/前進
action.addQuickAction.Build.text=建置
action.addQuickAction.Coverage.text=使用覆蓋率執行
action.addQuickAction.OpenFile.text=開啟檔案
action.addQuickAction.Profile.text=分析器
action.addQuickAction.SaveAll.text=全部儲存
action.addQuickAction.Synchronize.text=同步
action.addQuickAction.UndoRedo.text=撤銷/重做
action.compare.archives.text=比較歸檔
action.compare.files.text=比較檔案
action.compare.text=比較
action.compare.with.text=比較物件…
action.editRunConfigurations.description=開啟“編輯執行/偵錯組態”對話框
action.editRunConfigurations.text=編輯組態(_R)…
action.fontEditorPreview.ToggleBoldFont.text=切換加粗的字體
action.main.toolbar.Filename.text=檔名小工具(隱藏編輯器頁籤時)
action.main.toolbar.Project.text=專案小工具
action.openAssertEqualsDiff.text=檢視 assertEquals 差異
action.performancePlugin.ShowMemoryDialogAction.description=顯示更改記憶體對話框
action.performancePlugin.ShowMemoryDialogAction.text=更改記憶體設定
action.redo.description=重做{0}
action.redo.description.empty=最後的撤消動作
action.redo.text=重做{0}(_R)
action.synonym.LocalHistory.ShowSelectionHistory.class.text=顯示類別的本地歷史記錄…
action.synonym.LocalHistory.ShowSelectionHistory.method.text=顯示方法的本地歷史記錄…
action.synonym.Vcs.ShowHistoryForBlock.class.text=顯示類別的歷史記錄…
action.synonym.Vcs.ShowHistoryForBlock.method.text=顯示方法的歷史記錄…
action.undo.description=撤消{0}
action.undo.description.empty=最後動作
action.undo.text=撤消{0}(_U)
apply.toolbar.customization=套用
group.$LRU.GoToAction.text=開啟最近的專案
group.$LRU.description=最近開啟專案的列表
group.$LRU.text=最近的專案(_R)
group.ActiveToolwindowGroup.text=活動工具視窗
group.AnalyzeActionsPopup.text=分析程式碼
group.AnalyzeJavaMenu.description=分析 Java 選單
group.AnalyzeJavaMenu.text=分析 Java 選單
group.AnalyzeMenu.text=分析(_Z)
group.ArrangementRulesGroup.text=排列規則
group.BackgroundTasks.text=背景任務
group.Bookmarks.Goto.text=按數字/助記鍵轉到
group.Bookmarks.Toggle.text=按數字/助記鍵切換
group.Bookmarks.text=書籤
group.BreakpointActionsGroup.text=切換中斷點
group.BuildArtifactsGroup.text=建置工件
group.BuildMenu.text=建置(_B)
group.CacheRecovery.text=快取恢復
group.ChangeLineSeparators.text=行分隔符
group.ChangeProjectColorActionGroup.text=Change Project Color
group.ChangesView.Changelists.text=更改列表
group.ChangesView.GroupBy.text=分組依據
group.CleanupEventLog.description=移除所有未發送事件日誌檔案
group.CleanupEventLog.text=清理事件日誌
group.CloseEditorsGroup.text=編輯器關閉動作
group.CodeCompletionGroup.text=程式碼補全(_C)
group.CodeEditorBaseGroup.text=程式碼編輯器檢視動作
group.CodeEditorViewGroup.text=程式碼檢視動作
group.CodeFormatGroup.text=程式碼格式設定動作
group.CodeMenu.text=程式碼(_C)
group.CommentGroup.text=註釋動作
group.CommitView.ShowOnDoubleClick.text=雙擊時顯示
group.ConvertIndentsGroup.text=轉換縮排
group.Copy.Paste.Special.description=複製/貼上特殊編輯器動作
group.Copy.Paste.Special.text=複製/貼上特殊
group.CopyReferencePopupGroup.text=複製路徑/參照…
group.CoverageMenu.text=程式碼覆蓋率動作
group.CreateRunConfiguration.description=根據當前上下文建立執行組態
group.CreateRunConfiguration.text=建立執行組態
group.CustomLayoutActionsGroup.text=工具視窗布局
group.CustomLayoutsGroup.text=工具視窗布局
group.CutCopyPasteGroup.text=剪下/複製/貼上動作
group.DebugMainMenu.text=偵錯器動作
group.Debugger.ViewAsGroup.text=檢視方式
group.DebuggingActionsGroup.text=偵錯動作
group.DeleteNamedLayoutGroup.text=刪除布局(_D)
group.Diff.Binary.Settings.text=設定
group.Diff.KeymapGroup.text=差異與合併
group.Documentation.Navigation.text=快速文檔導覽
group.EditBookmarksGroup.text=書籤(_K)
group.EditCreateDeleteGroup.text=編輯器建立/刪除動作
group.EditMenu.text=編輯(_E)
group.EditSelectGroup.text=編輯器選擇動作
group.EditSelectWordGroup.text=選擇單詞動作
group.EditSmartGroup.text=編輯程式碼動作
group.EditorActions.text=編輯器動作
group.EditorBidiTextDirection.description=混合 LTR/RTL 文本的主要方向
group.EditorBidiTextDirection.text=雙向文本基礎方向
group.EditorBreadcrumbsSettings.description=切換路徑導覽列設定
group.EditorBreadcrumbsSettings.text=路徑導覽
group.EditorGutterPopupMenu.Appearance.text=外觀
group.EditorGutterPopupMenu.text=編輯器裝訂區域彈出選單
group.EditorLangPopupMenu.text=編輯器彈出視窗選單動作(2)
group.EditorPopupMenu.GoTo.description=轉到編輯器彈出視窗選單組
group.EditorPopupMenu.GoTo.text=轉到
group.EditorPopupMenu.Run.text=編譯/執行動作
group.EditorPopupMenu.description=編輯器彈出視窗選單
group.EditorPopupMenu.text=編輯器彈出視窗選單
group.EditorPopupMenu1.text=編輯器彈出視窗選單動作(1)
group.EditorPopupMenuDebug.text=偵錯動作
group.EditorTabPopupMenu.text=編輯器頁籤彈出視窗選單
group.EditorTabPopupMenuEx.text=編輯器頁籤彈出視窗選單動作(1)
group.EditorTabsEntryPoint.text=最近的檔案、頁籤動作等
group.EditorTabsGroup.text=編輯器頁籤(_T)
group.EditorToggleActions.text=活動編輯器
group.Emmet.text=Emmet
group.ExpandAllToLevel.text=全部展開到級別(_L)
group.ExpandToLevel.text=展開到級別(_E)
group.ExportImportGroup.text=管理 IDE 設定
group.ExternalSystem.ShowSettingsGroup.text=建置工具設定
group.ExternalToolsGroup.text=外部工具
group.FeatureUsage.Internal.text=功能用法統計資訊
group.FileChooserSettings.text=檔案選擇器設定
group.FileChooserToolbar.text=檔案選擇器工具列
group.FileExportGroup.text=匯出
group.FileHistory.KeymapGroup.text=檔案歷史記錄
group.FileMainSettingsGroup.text=設定動作
group.FileMenu.text=檔案(_F)
group.FileOpenGroup.text=檔案開啟動作
group.FileOtherSettingsGroup.text=新增專案設定
group.FilePropertiesGroup.text=檔案屬性
group.FileSettingsGroup.text=設定動作
group.FindMenuGroup.text=尋找(_F)
group.FindUsagesMenuGroup.text=尋找用法
group.Floating.CodeToolbar.Extract.text=提取
group.Floating.CodeToolbar.Surround.text=環繞
group.Floating.CodeToolbar.text=浮動程式碼工具列
group.FoldingGroup.text=折疊
group.GenerateGroup.text=生成(_G)
group.GoToChangeMarkerGroup.text=更改導覽動作
group.GoToCodeGroup.text=通過參照轉到
group.GoToErrorGroup.text=轉到錯誤/書籤動作
group.GoToMenu.text=導覽(_N)
group.GoToTargetEx.text=通過名稱轉到
group.Graph.AlignNodesGroup.text=對齊
group.Graph.AppearanceGroup.text=外觀
group.Graph.BehaviourGroup.text=行為
group.Graph.CommonLayoutGroup.text=布局
group.Graph.DistributeNodesGroup.text=分散排列
group.Graph.EdgeRealizerGroup.text=邊緣形狀
group.Graph.ExportGroup.text=匯出圖
group.Graph.LayoutOrientationGroup.text=方向
group.Graph.MergeEdgesGroup.text=合併邊緣
group.Graph.NeighborhoodViewPopup.AppearanceGroup.text=外觀
group.Graph.NeighborhoodViewPopup.LayoutGroup.text=布局
group.Graph.NetsLayoutGroup.text=網狀
group.Graph.OrthogonalLayoutGroup.text=正交
group.Graph.RadialLayoutGroup.text=徑向
group.Graph.TreeLayoutGroup.text=樹
group.Graphs.KeymapGroup.text=圖表
group.HelpDiagnosticTools.text=診斷工具
group.HelpMenu.text=幫助(_H)
group.HierarchyGroup.text=層次結構動作
group.ImportTests.text=匯入測試結果
group.InspectCodeGroup.text=檢查程式碼動作
group.Internal.Dump.text=傾印
group.Internal.Editor.text=編輯器(&E)
group.Internal.Errors.text=異常
group.Internal.HeapAnalysis.text=堆分析
group.Internal.Java.text=Java
group.Internal.PMM.text=PMM 實用工具
group.Internal.Performance.text=性能
group.Internal.Trust.text=原始碼安全性
group.Internal.UI.Demos.text=示範
group.Internal.UI.text=UI(&U)
group.Internal.VFS.text=VFS
group.Internal.text=內部動作(&I)
group.Internal1.text=IDEA 內部動作
group.IntroduceActionsGroup.text=提取/引入(_X)
group.LeftToolbarSideGroup.text=左側
group.ListActions.text=列表動作
group.LocalChangesView.ShowOnDoubleClick.text=雙擊時顯示
group.LocalHistory.text=本地歷史記錄(_H)
group.Macros.description=檢視、更改、錄製、執行巨集
group.Macros.text=巨集(_S)
group.MacrosGroup.text=巨集動作
group.MainMenu.text=主選單
group.MainToolBar.text=主工具列
group.MainToolbarCenter.text=中心
group.MainToolbarGeneralActionsGroup.text=一般動作
group.MainToolbarLeft.text=左側
group.MainToolbarQuickActions.text=新增到主工具列
group.MainToolbarRight.text=右側
group.MarkFileAs.text=將檔案標記為
group.MarkRootGroup.text=將目錄標記為
group.MigrationMenu.text=遷移軟體套件和類別
group.MoreActionGroup.text=更多
group.MoveModuleToGroup.description=移動模組(_M)
group.MoveModuleToGroup.text=將模組移至組
group.NavBarActions.text=導覽列動作
group.NavbarLocationGroup.description=選擇導覽列的位置
group.NavbarLocationGroup.text=導覽列
group.NavbarPopupMenu.text=導覽列
group.NavigateInFileGroup.text=在檔案中導覽
group.NewElement.text=新增(_N)
group.NewElementInMenuGroup.text=新增(_N)
group.NewElementMenu.text=新增(_N)
group.NewFromTemplate.text=從模板
group.NewGroup.text=新增(_N)
group.NewGroup1.text=新組(1)
group.NewWebDevelopment.text=Web 開發模板
group.NewXml.text=XML
group.NewXmlDescriptor.text=XML 組態檔案
group.Notifications.text=通知
group.OpenEventLogFileAction.description=在 IDE 中開啟活動事件日誌檔案
group.OpenEventLogFileAction.text=在編輯器中開啟事件日誌
group.OpenEventsSchemeFileAction.description=在 IDE 中開啟事件方案檔案
group.OpenEventsTestSchemeFileAction.description=在 IDE 中開啟事件測試方案檔案
group.OpenInBrowserEditorContextBarGroupAction.description=開啟位置…
group.OpenInBrowserGroup.EditorTabPopup.text=瀏覽器
group.OpenProjectGroup.text=開啟專案動作
group.OpenProjectWindows.text=開啟專案視窗
group.OpenRecentEditorInBlankDiffWindow.text=切換到最近
group.OtherMenu.description=未正確註冊的動作
group.OtherMenu.text=其他
group.OverrideFileTypeAction.bundledPlugin=捆綁
group.OverrideFileTypeAction.fromNamedPlugin=自 ''{0}'' 延伸模組
group.OverrideFileTypeAction.title=選擇檔案類型
group.PairFileActions.text=檔案對的動作
group.PasteGroup.text=貼上
group.Patch.MainMenu.text=補丁檔案
group.PopupMenuActions.text=彈出選單動作
group.PrintExportGroup.text=列印/匯出動作
group.ProblemsView.Options.description=允許對問題進行分類和篩選
group.ProblemsView.Options.text=檢視選項
group.ProblemsView.Show.text=顯示
group.ProblemsView.SortBy.text=排序依據
group.ProjectView.ToolWindow.Appearance.Actions.text=樹外觀
group.ProjectView.ToolWindow.SecondaryActions.text=專案檢視選項
group.ProjectViewAnalysisGroup.text=分析動作
group.ProjectViewCompileGroup.text=編譯/偵錯動作
group.ProjectViewPopupMenu.text=專案檢視彈出視窗選單
group.ProjectViewPopupMenuModifyGroup.text=專案檢視彈出視窗選單修改組
group.ProjectViewPopupMenuRefactoringGroup.text=專案檢視彈出視窗重構組
group.ProjectViewPopupMenuRunGroup.text=專案檢視彈出視窗選單執行組
group.ProjectViewPopupMenuSettingsGroup.text=專案檢視彈出視窗選單設定組
group.RefactoringMenu.text=重構(_R)
group.RefactoringMenu1.text=重構動作(1)
group.RefactoringMenu2.text=重構動作(2)
group.RegistrationActions.text=註冊動作
group.ResizeToolWindowGroup.text=調整大小
group.RestoreNamedLayoutGroup.text=還原布局(_L)
group.RevealGroup.text=開啟於
group.RightToolbarSideGroup.text=右側
group.RunContextGroupMore.text=更多執行/偵錯
group.RunContextPopupGroup.text=執行組態
group.RunDashboard.Filter.text=組態狀態
group.RunDashboard.GroupBy.text=組態
group.RunMenu.text=執行(_U)
group.Runner.Layout.description=布局組態
group.Runner.Layout.text=布局
group.RunnerActions.text=執行/偵錯
group.RunnerActionsTouchbar.text=Touch Bar 執行/偵錯動作
group.ScrollPaneActions.text=滾動
group.SearchEverywhereActions.text=隨處搜尋
group.ServiceView.AddService.text=新增服務
group.ServiceView.Filter.text=篩選器
group.ServiceView.GroupBy.text=分組依據
group.ServiceView.OpenInNewTabGroup.text=在新頁籤中開啟
group.Shelve.KeymapGroup.text=擱置
group.ShelvedChangesToolbar.ViewOptions.text=檢視選項
group.ShowAnnotateOperationsPopupGroup.text=註解行
group.ShowFilterPopup.text=顯示篩選器彈出視窗
group.ShowRecentFindUsagesGroup.description=選擇並重新執行最近的尋找用法
group.ShowRecentFindUsagesGroup.text=最近的尋找用法
group.StandardMacroActions.text=標準巨集動作
group.StoreLayoutGroup.text=存儲布局(_S)
group.SwitcherAndRecentFiles.text=切換器(RecentFiles)動作
group.TW.ViewModeGroup.text=檢視模式
group.TWViewModes.text=工具視窗檢視模式
group.TWViewModesLegacy.text=工具視窗傳統檢視模式(已棄用)
group.TableActions.text=表動作
group.TabsActions.text=頁籤
group.TextEditorWithPreview.SplitGroup.text=拆分布局
group.TipsAndFeatures.text=提示和功能
group.TodoMainGroup.text=TODO
group.TodoViewGroupByGroup.text=分組依據
group.ToggleBreakpointAction.text=中斷點動作
group.ToolWindowsGroup.text=工具視窗(_T)
group.ToolbarFindGroup.text=工具列尋找動作
group.ToolbarMakeGroup.text=工具列 Make 動作
group.ToolbarRunGroup.text=工具列執行動作
group.ToolsBasicGroup.description=基本工具組
group.ToolsBasicGroup.text=基本工具組
group.ToolsMenu.text=工具(_T)
group.ToolsXmlGroup.text=XML 動作
group.TopAnomalies.text=熱門異常
group.TopStripeActionGroup.text=單個工具視窗列
group.TouchBar.text=觸控列
group.TouchBarDebug.ForceStepButtons.text=偵錯器強制步動作
group.TouchBarDebug.StepButtons.text=偵錯器步動作
group.TouchBarDebug.text=偵錯器
group.TouchBarDebug_alt.text=使用 Alt 鍵的偵錯器
group.TouchBarDefault.text=預設
group.TouchBarDefaultOptionalGroup.text=可選動作
group.TouchBarDefault_alt.text=預設使用 Alt 鍵
group.TouchBarDefault_cmd.alt.text=預設使用 Alt+Cmd 鍵
group.TouchBarDefault_cmd.text=預設使用 Cmd 鍵
group.TouchBarDefault_ctrl.text=預設使用 Ctrl 鍵
group.TouchBarDefault_shift.text=預設使用 Shift 鍵
group.TreeActions.text=樹動作
group.UpdateEventsSchemeAction.description=必要時更新伺服器中的主要事件方案。也重新載入該檔案中的事件測試方案。
group.UpdateEventsSchemeAction.text=更新事件方案
group.Vcs.Browse.text=瀏覽 VCS 儲存庫
group.Vcs.Import.text=匯入到版本控制
group.Vcs.KeymapGroup.text=版本控制系統
group.VcsFileGroupPopup.text=版本控制組
group.VcsGlobalGroup.text=VCS 組
group.VcsGroup.text=版本控制
group.VcsGroups.text=Git(_G)
group.VcsToolbarActions.text=VCS 動作
group.VersionControlsGroup.text=VCS/LVCS 動作
group.ViewAppearanceGroup.text=外觀(_A)
group.ViewMenu.text=檢視(_V)
group.ViewRecentActions.text=檢視最近的動作組
group.ViewStatusBarWidgetsGroup.description=顯示/隱藏狀態列小工具
group.ViewStatusBarWidgetsGroup.text=狀態列小工具(_W)
group.WeighingNewGroup.text=新增(_N)
group.WelcomeScreen.KeymapGroup.text=歡迎頁面
group.WelcomeScreen.MoveToGroup.text=移至組
group.WelcomeScreen.Options.text=選項選單
group.WindowMenu.text=視窗(_W)
group.XDebugger.settings.text=偵錯設定
group.XmlGenerateToolsGroup.text=XML 生成動作
group.compare.contents.text=比較內容
group.popup@ExpandableBookmarkContextMenu.text=書籤
group.reopen.mac.text=開啟最近(_R)
group.reopen.win.text=重新開啟專案(_R)
save.file.as.template=將檔案另存為模板
separator.Local.History.text=本地歷史記錄
separator.show=顯示
show.log.in.action.text=在{0}中顯示日誌
show.log.notification.text=檢視日誌"
`;

exports[`dev messages/DiffBundle.properties 1`] = `
"action.Anonymous.text.apply.non.conflicting.changes=套用不衝突的更改:
action.Combined.Diff.NextChange.text=下一個檔案
action.Combined.Diff.PrevChange.text=上一個檔案
action.merge.apply.non.conflicts.all.text=所有
action.merge.apply.non.conflicts.left.text=左側
action.merge.apply.non.conflicts.right.text=右側
action.presentation.RefreshDirDiffAction.text=重新整理
action.presentation.diff.accept.text=接受
action.presentation.diff.append.text=追加
action.presentation.diff.append.to.the.side.text=追加到 {0, choice, 0#左側|1#右側}
action.presentation.diff.include.into.commit.area.marker.text=現在，差異檢視中將忽略此塊中的某些更改。<br>通過選中該複選框，您將包括此列指示要提交的所有行。
action.presentation.diff.include.into.commit.text=包含到提交中
action.presentation.diff.revert.text=還原
action.presentation.go.to.change.text=轉到更改
action.presentation.merge.ignore.text=忽略
action.presentation.merge.resolve.automatically.text=自動解決
action.presentation.merge.resolve.text=解決
action.presentation.merge.resolve.using.side.text=使用{0, choice, 0#左側|1#右側} 解決
action.use.external.tool.text=使用以下內容顯示差異: {0}
advanced.setting.show.diff.as.editor.tab=作為編輯器頁籤開啟差異
advanced.setting.show.diff.as.editor.tab.description=如果啟用，請使用編輯器頁籤代替框架視窗來顯示差異
advanced.settings.vcs=版本控制
apply.changes.and.mark.resolved=套用更改並標記為已解決
apply.partially.resolved.merge.dialog.title=套用更改
apply.patch.all.changes.processed.message.text=所有區塊均已被處理。<br><a href="">儲存更改並完成解決</a>
apply.patch.partially.resolved.changes.confirmation.message={0, choice, 1#1 個區塊|2#{0, number} 個區塊}未處理。\\n要儲存更改並完成解決嗎?
apply.somehow.status.message.all.applied=已解決所有區塊
apply.somehow.status.message.already.applied={0, number} 個{0, choice, 1#區塊|2#區塊}已套用
apply.somehow.status.message.cant.apply=無法套用 {0, number} 個{0, choice, 1#區塊|2#區塊}
apply.somehow.status.message.cant.apply.some=無法套用 {0, number} 個區塊，共 {1, number} 個
binary.diff.contents.are.different.message.text=檔案內容不同
binary.diff.contents.are.identical.message.text=檔案內容相同
binary.file.viewer=二進制檔案檢視器
blank.diff.recent.content.summary.text.date={0} ({1})
blank.diff.recent.content.summary.text.length.date={0} ({1} 字元，{2})
button.abort.resolve=中止解決
button.associate.file.type=關聯
button.cancel.merge=取消合併
button.continue.merge=繼續合併
button.dirdiff.filter=過濾(&F):
button.discard.changes.and.do=捨棄更改並{0}
button.hide.notification=隱藏
button.merge.resolve.accept.left=接受左側
button.merge.resolve.accept.right=接受右側
button.merge.resolve.apply=套用
button.merge.resolve.cancel=取消
button.reload.diff.request=重新載入
can.t.copy.file=無法複製檔案
can.t.finish.merge.resolve=無法解決合併衝突
can.t.load.some.changes=無法載入某些更改
can.t.show.diff.in.external.tool=無法在外部工具中顯示差異
can.t.show.diff.in.external.tool.too.many.files=選擇的檔案過多，無法使用外部工具開啟，{0} 未開啟。
can.t.show.merge.in.external.tool=無法在外部工具中顯示合併
cancel.visual.merge.dialog.title=取消檔案合併
cannot.create.file.error=無法建立檔案: {0}
cannot.find.file.error=找不到檔案: {0}
changing.highlighting.requires.the.file.merge.restart=更改醒目提示需要重啟檔案合併。是否捨棄未儲存的更改並重啟合併?
collapse.unchanged.fragments=摺疊未更改的片段
column.dirdiff.date=日期
column.dirdiff.name=名稱
column.dirdiff.size=大小
combined.side.by.side.viewer=拆分
combined.unified.viewer=統合
compare.0.with.1=比較 ''{0}'' 和 ''{1}''
compare.by=比較依據:
compare.selected.new.files=將左側和右側的所選新檔案相互比較。
configurable.DiffSettingsConfigurable.display.name=差異與合併
configurable.ExternalDiffSettingsConfigurable.display.name=外部差異工具
configurable.diff.collapse.unchanged.ranges.disable=停用
confirm.delete=確認刪除
continue.merge=繼續合併
copy.content.to.side=將內容複製到{0, choice, 0#左側|1#右側}
data.has.been.changed.externally.reloading.data=資料已在外部更改。正在重新載入資料…
delete.0.items=刪除 {0} 項?
dialog.title.diff.for.range=範圍的差異
diff.actions=差異動作
diff.all.differences.ignored.text=已忽略差異
diff.application.usage.parameters.and.description=用法: {0} 差異 <left file> <right file> [<base file>]
diff.cant.calculate.diff=無法計算差異
diff.clipboard.vs.editor.dialog.title=剪貼簿與編輯器
diff.clipboard.vs.value.dialog.title=剪貼簿與所選值
diff.content.clipboard.content.title=來自剪貼簿
diff.content.editor.content.title=編輯器
diff.content.selected.value=所選值
diff.content.selection.from.file.content.title={0}中的選區
diff.content.title.current.range=當前
diff.content.title.up.to.date=基本修訂
diff.contents.are.identical.message.text=內容相同
diff.contents.have.differences.only.in.charset.and.line.separators.message.text=內容僅在行分隔符和編碼中有差異
diff.contents.have.differences.only.in.charset.message.text=內容僅在編碼中有差異
diff.contents.have.differences.only.in.line.separators.message.text=內容僅在行分隔符中有差異
diff.count.differences.status.text={0, choice, 0#沒有|1#1個|2#{0, number}個}差異
diff.element.qualified.name.vs.element.qualified.name.dialog.title={0} 與 {1}
diff.file.editor.name=差異
diff.files.count.files.in.text=({0} 中)
diff.files.count.hyperlink.text={0} 個檔案
diff.files.dialog.title=差異
diff.files.generic.request.title=更改
diff.highlighting.disabled.text=差異醒目提示處於關閉狀態
diff.inactive.count.differences.status.text=({0} 停用)
diff.progress.spinner.tooltip.text=正在計算差異
diff.tool=差異工具
diff.type.changed.name=已更改
diff.type.conflict.name=衝突
diff.type.deleted.name=已刪除
diff.type.inserted.name=已插入
diff.unchanged.lines.folding.marker.renderer=標記: 已摺疊的未更改的行
diff.utf.charset.name.bom.suffix={0} BOM
diff.version.title.after=之後
diff.version.title.before=之前
dirdiff.mode.binary.content=二進制內容
dirdiff.mode.size=大小
dirdiff.mode.size.and.timestamp=大小和時間戳
dirdiff.mode.text=文本
directory.diff=目錄差異
directory.diff.actions=目錄差異動作
directory.viewer=目錄檢視器
disable.editing=停用編輯
discard.changes.and.restart.merge=捨棄更改並重啟合併
do.not.ask.me.again=不再詢問我
editing.viewer.hint.enable.editing.text=此檢視為唯讀。<a href="">啟用編輯</a>
editor.settings=設定
error.can.not.calculate.diff.file.too.big=無法計算差異。檔案太大且更改太多。
error.can.not.calculate.diff.operation.canceled=無法計算差異。動作已取消。
error.cannot.show.diff=無法顯示差異
error.cannot.show.merge=無法顯示合併
error.cant.resolve.conflicts.in.a.read.only.file=無法解決唯讀檔案中的衝突
error.cant.show.diff.cant.load.revision.content=無法獲取此修訂中的內容
error.cant.show.diff.cant.show.for.directory=無法顯示目錄的差異
error.cant.show.diff.content.not.found=無法顯示差異: 找不到內容
error.cant.show.diff.file.not.found=無法顯示差異: 找不到檔案
error.cant.show.diff.for.unknown.file=無法顯示未知檔案類型的差異
error.cant.show.diff.message=錯誤: 無法顯示差異
error.cant.show.dirdiff.preview.cant.load.content=無法獲取內容
error.cant.show.file=無法顯示檔案
error.cant.show.merge.file.not.found=無法顯示合併衝突: 找不到檔案
error.cant.show.merge.operation.not.supported=無法顯示合併衝突: 此動作不受支援
error.cant.show.merge.project.not.found=無法顯示合併衝突: 未知專案類型
error.conflict.is.not.valid.and.no.longer.can.be.resolved=衝突無效，無法再解決。
error.content.decoded.with.wrong.charset=內容解碼出錯(使用 ''{0}'' 字符集)
error.file.is.too.large.only.preview.is.loaded=檔案太大。僅載入預覽。
error.files.too.large.to.compare.text=檔案太大，無法比較
error.message.cannot.show.diff=無法顯示差異
error.message.cannot.show.merge=無法顯示合併
error.operation.canceled=動作已被取消
error.viewer=錯誤檢視器
filetype.diff.description=差異
hide.this.notification=隱藏此通知
highlight.words=醒目提示顯示單詞
highlighting.level=醒目提示級別
label.cant.show.diff.with.description=無法顯示差異: {0}
label.cant.show.merge.with.description=無法顯示合併: {0}
label.default.diff.editor.tab.name=差異
label.diff.settings.path=設定 | 工具 | 差異和合併
label.diff.settings.path.macos=偏好設定 | 工具 | 差異和合併
label.dirdiff.loading.file=正在載入… {0}
label.merge.unsaved.changes.discard.and.do.anyway=結果檔案中有未儲存的更改。捨棄更改並繼續{0}嗎?
launching.external.tool=正在啟動外部工具…
mark.as.resolved=標記為已解決
merge.all.changes.processed.message.text=所有更改均已被處理。<br><a href="">儲存更改並完成合併</a>
merge.application.usage.parameters.and.description=用法: {0} 合併 <left file> <right file> [<base file>] <output file>
merge.color.options.background.color.label=重要
merge.color.options.dialog.title=合併顏色選項
merge.color.options.ignored.color.label=已忽略
merge.conflict.is.outdated=合併衝突已過時。在衝突解決開始之前還原檔案內容?
merge.continue.button=繼續(&C)
merge.dialog.accept.change.command=接受更改
merge.dialog.all.conflicts.resolved.message.text=已解決所有衝突
merge.dialog.apply.non.conflicted.changes.command=套用不衝突的更改
merge.dialog.apply.partially.resolved.changes.confirmation.message={0, choice, 0#'{1, choice, 1#有|2#有}'|1#有|2#有} {0, choice, 0#|1#1 個更改|2#{0, number} 個更改}{0, choice, 0#|1#'{1, choice, 0#|1#和 }'}{1, choice, 0#|1#1 個衝突|2#{1, number} 個衝突}未處理。\\n仍要儲存更改並將衝突標記為解決嗎?
merge.dialog.exit.without.applying.changes.confirmation.message=確定要退出登入且不套用更改嗎?
merge.dialog.ignore.change.command=忽略更改
merge.dialog.resolve.conflict.command=解決衝突
merge.differences.status.text={0, choice, 0#沒有更改|1#1 個更改|2#{0, number} 個更改}。{1, choice, 0#沒有衝突|1#1 個衝突|2#{1, number} 個衝突}。
merge.files.dialog.title=合併
merge.in.external.tool=在外部工具中合併
merge.save.and.finish.button=儲存並完成(&F)
merge.tool=合併工具
merge.version.title.base=基礎版本
merge.version.title.current=當前版本:
merge.version.title.merged=合併版本
merge.version.title.merged.result=結果
merge.version.title.our=您的版本
merge.version.title.their=來自伺服器的更改
merge.version.title.their.with.revision=來自伺服器的更改 (修訂版 {0})
merge.window.title.file=合併 {0}
message.do.in.merge.command=合併時 {0}
message.init.merge.content.command=初始化合併內容
message.replace.change.command=取代更改
message.resolve.simple.conflicts.command=解決簡單的衝突更改
message.use.selected.changes.command={0}所選更改
notification.action.text.blank.diff.recent=最近
notification.action.text.blank.diff.select.file=選擇檔案…
notification.status.content.added=內容已新增
notification.status.content.removed=內容已移除
notification.you.can.disable.this.feature.in.0=您可以在 {0} 中停用此功能
option.highlighting.level.inspections=檢查
option.highlighting.level.none=無
option.highlighting.level.syntax=語法
option.highlighting.policy.group.name=醒目提示顯示模式
option.highlighting.policy.lines=醒目提示行
option.highlighting.policy.none=不醒目提示顯示
option.highlighting.policy.split=醒目提示拆分的更改
option.highlighting.policy.symbols=醒目提示顯示字元
option.highlighting.policy.words=醒目提示顯示單詞
option.ignore.policy.formatting=忽略格式化
option.ignore.policy.group.name=忽略更改
option.ignore.policy.none=不忽略
option.ignore.policy.trim=修整空白
option.ignore.policy.whitespaces=忽略空格
option.ignore.policy.whitespaces.empty.lines=忽略空格和空行
option.inherit.ignored.color=繼承忽略的顏色
option.three.side.color.policy.left.to.right=左到右
option.three.side.color.policy.merge.conflict=合併衝突
option.three.side.color.policy.merge.resolved=解決的合併衝突
press.again.to.go.to.the.next.file=再按一次轉到下一個檔案
press.again.to.go.to.the.previous.file=再按一次轉到上一個檔案
press.mark.as.resolve=在外部工具中解決完衝突時，按“標記為已解決”
progress.title.loading.requests=正在載入請求
refresh.failed.message=重新整理失敗: {0}
rollback.change.command.name=復原更改
select.external.program.dialog.title=選擇外部程序
select.file.to.compare=選擇要比較的檔案
settings.automatically.apply.non.conflicting.changes=自動套用不衝突的更改
settings.context.lines=上下文行:
settings.diff.name=差異
settings.external.diff.base.file.content=基檔案內容
settings.external.diff.comboBox.value.unknown.filetype.text={0} (未知)
settings.external.diff.enable.external.tools=啟用外部工具
settings.external.diff.left.file.content=左側檔案內容
settings.external.diff.merge.conflict.resolve.successful=合併衝突解決成功。\\n已解決的內容為:\\n{0}
settings.external.diff.merge.conflict.resolve.was.canceled=合併衝突解決已取消。
settings.external.diff.original.output.file.content=原始輸出檔案內容
settings.external.diff.panel.table.title=組態與檔案類型關聯的外部差異/合併工具:
settings.external.diff.panel.tree.title=組態外部工具:
settings.external.diff.right.file.content=右側檔案內容
settings.external.diff.table.difftool.column=差異工具
settings.external.diff.table.filetype.column=檔案類型
settings.external.diff.table.mergetool.column=合併工具
settings.external.diff.table.remove.dialog.message=確定要刪除此條目嗎?
settings.external.diff.table.remove.dialog.title=移除外部差異工具
settings.external.diff.test.complete=測試完成
settings.external.diff.test.diff=測試差異
settings.external.diff.test.merge=測試合併
settings.external.diff.test.three.side.diff=測試三向差異
settings.external.diff.trust.process.exit.code=信任程序退出程式碼
settings.external.tool.tree.add.dialog.field.argument.pattern=實參模式
settings.external.tool.tree.add.dialog.field.group=工具組
settings.external.tool.tree.add.dialog.field.program.path=程序路徑
settings.external.tool.tree.add.dialog.field.tool.name=工具名稱
settings.external.tool.tree.add.dialog.title=新增外部工具
settings.external.tool.tree.edit.dialog.title=編輯外部工具
settings.external.tool.tree.remove.warning.message=此工具用於組態。首先移除表中的組態
settings.external.tool.tree.remove.warning.title=無法刪除所選工具
settings.external.tool.tree.validation.already.exist=名稱為“{1}”的 {0} 已存在
settings.external.tool.tree.validation.empty=外部工具名稱不得為空
settings.external.tools.parameters.description=不同的工具有不同的參數。按正確的順序指定所有必要的參數非常重要:
settings.external.tools.parameters.diff=<b>%1</b> - 左(本地更改)<br><b>%2</b> - 右(伺服器內容)<br><b>%3</b> - 基礎(沒有本地更改的當前版本)
settings.external.tools.parameters.merge=<b>%1</b> - 左(本地更改)<br><b>%2</b> - 右(伺服器內容)<br><b>%3</b> - 基礎(沒有本地更改的當前版本)<br><b>%4</b> - 輸出(合併結果)
settings.external.tools.test.process.exit.text=程序已終止: exitCode ''{0}''
settings.go.to.the.next.file.after.reaching.last.change=到達上次更改後轉到下一個檔案
settings.highlight.modified.lines.in.gutter=在裝訂區域中醒目提示修改的行
settings.merge.text=合併
side.by.side.viewer=並排檢視器
synchronize.document.and.its.fragment=同步文檔及其片段
synchronize.document.and.its.fragment.range.error=選區無效
synchronize.editors.settings=同步編輯器設定
synchronize.scrolling=同步滾動
tooltip.merge.ctrl.click.to.resolve.conflict=Ctrl+點擊來解決衝突
unified.viewer=統合檢視器
update.highlighting.settings=更新醒目提示設定
use.space.button.or.mouse.click=使用空格按鈕或滑鼠點擊來更改選定元素的動作。按回車鍵執行。
use.space.button.to.change.operation=使用空格按鈕更改動作
vcs.marker.changed.line=VCS 標記: 更改的行
waiting.for.external.tool=正在等待外部工具…"
`;

exports[`dev messages/GitBundle.properties 1`] = `
"MainToolbarQuickActions.vcs.separator=VCS
abort=中止
abort.operation.cherry.pick.name=優選
abort.operation.dialog.msg=中止 {0}{1}?
abort.operation.dialog.title=中止 {0}
abort.operation.failed={0} 中止失敗
abort.operation.indicator.text=git {0} --abort{1}
abort.operation.merge.name=合併
abort.operation.progress.title=正在中止 {0} 程序
abort.operation.revert.name=還原
abort.operation.succeeded={0} 中止成功
action.CopyPathFromRepositoryRootProvider.text=版本庫根路徑
action.Git.Add.text=新增
action.Git.Branches.text=分支(_B)…
action.Git.BrowseRepoAtRevision.text=在修訂版中顯示版本庫
action.Git.Checkout.Branch.description=簽出所選分支
action.Git.Checkout.Branch.text=簽出所選…
action.Git.CheckoutRevision.text=簽出修訂
action.Git.CherryPick.Abort.text=中止優選
action.Git.Clone.text=克隆…
action.Git.Commit.Stage.text=提交…
action.Git.Compare.Selected.description=相互比較選定分支
action.Git.Compare.Selected.description.disabled=從同一版本庫中選擇分支
action.Git.Compare.Selected.title=比較分支
action.Git.Compare.With.Current.title=與當前分支進行比較
action.Git.CompareWithBranch.text=與分支比較…
action.Git.CompareWithTag.text=與標記比較…
action.Git.Configure.Remotes.text=管理遠端…
action.Git.CreateNewBranch.description=從所選提交開始建立新分支
action.Git.CreateNewBranch.text=新增分支…
action.Git.CreateNewTag.description=建立指向此提交的新標籤
action.Git.CreateNewTag.text=新增標記…
action.Git.Delete.Branch.title=刪除{0,choice,1#分支|2#分支}
action.Git.Drop.Commits.text=刪除提交
action.Git.Fetch.description.fetch.in.progress=正在獲取…
action.Git.Fetch.text=獲取
action.Git.Fetch.title=獲取所有遠端
action.Git.Fixup.To.Commit.description=建立 fixup 提交
action.Git.Fixup.To.Commit.text=Fixup…
action.Git.Init.Stage.error=向 Git 新增檔案失敗
action.Git.Init.Vcs.Toolbar.Widget.text=建立 Git 版本庫…
action.Git.Init.error=Git init 失敗
action.Git.Init.text=建立 Git 版本庫…
action.Git.Interactive.Rebase.description=顯示互動重定基底的對話框，可以在該對話中對提交執行壓縮、fixup、重新排序、移除和改寫
action.Git.Interactive.Rebase.text=從這裡進行互動重定基底…
action.Git.Loading.Branches.progress=正在載入分支…
action.Git.Log.Branches.Change.Branch.Filter.On.Selection.description=選擇分支後，按此分支篩選日誌
action.Git.Log.Branches.Change.Branch.Filter.On.Selection.text=更新分支篩選器
action.Git.Log.Branches.Change.Branch.Filter.description=使用所選分支更新日誌中的分支篩選器
action.Git.Log.Branches.Change.Branch.Filter.text=更新日誌中的分支篩選器
action.Git.Log.Branches.Navigate.Log.To.Branch.On.Selection.description=選擇分支後，在日誌中導覽到該分支 HEAD
action.Git.Log.Branches.Navigate.Log.To.Branch.On.Selection.text=在日誌中導覽到分支 Head
action.Git.Log.Branches.Navigate.Log.To.Selected.Branch.text=在日誌中導覽到所選分支 Head
action.Git.Log.DeepCompare.description=醒目提示尚未優選到當前分支的提交
action.Git.Log.DeepCompare.text=無優選提交
action.Git.Log.Edit.Remote.text=編輯遠端
action.Git.Log.Hide.Branches.text=隱藏 Git 分支
action.Git.Log.Remove.Remote.text=移除{0,choice,1#遠端|2#遠端}
action.Git.Log.Show.Branches.text=分支
action.Git.Log.text=顯示 Git 版本庫日誌…
action.Git.Merge.Abort.text=中止合併
action.Git.Merge.text=合併…
action.Git.New.Branch.description=僅選擇一個分支以繼續建立新分支
action.Git.New.Branch.dialog.title=從 {0} 建立分支
action.Git.Pull.text=拉取…
action.Git.PushUpToCommit.description=推送所有之前的提交，包括所選提交
action.Git.PushUpToCommit.text=推送此前所有提交…
action.Git.Rebase.Abort.text=中止重定基底
action.Git.Rebase.Continue.text=繼續重定基底
action.Git.Rebase.Skip.progress.title=重定基底期間跳過提交…
action.Git.Rebase.Skip.text=跳過提交
action.Git.Rebase.operation.name=重定基底
action.Git.Rebase.text=重定基底…
action.Git.Rename.Local.Branch.description=重新命名本地分支
action.Git.Rename.Local.Branch.text=重新命名…
action.Git.Reset.In.Log.text=將當前分支重設到此處…
action.Git.Reset.text=重設 HEAD…
action.Git.ResolveConflicts.text=解決衝突…
action.Git.Revert.Abort.text=中止還原
action.Git.Revert.In.Log.description=生成新提交，這會還原在原始提交中所做的更改
action.Git.Revert.In.Log.template.text=還原{0,choice,1#提交|2#提交}
action.Git.Revert.In.Log.text=還原提交
action.Git.Reword.Commit.description=通過 git rebase 或 amend 的改寫選項更改提交訊息
action.Git.Reword.Commit.text=編輯提交訊息…
action.Git.Show.My.Branches.description.calculating.branches.progress=正在計算我的分支
action.Git.Show.My.Branches.description.is.my.branch=如果分支的所有獨佔提交都是由“我”(即當前 Git 作者)執行的，則此分支為“我的”。
action.Git.Show.My.Branches.description.not.all.roots.indexed=並沒有為所有版本庫編制索引。
action.Git.Show.My.Branches.description.not.graph.ready=該日志尚未就緒，請稍候。
action.Git.Show.My.Branches.description.not.support.indexing=某些版本庫不支持索引。
action.Git.Show.My.Branches.title=顯示我的分支
action.Git.Show.Stage.text=顯示暫存區域
action.Git.Show.Stash.description=顯示“Git 隱藏”工具視窗頁籤
action.Git.Show.Stash.text=顯示 Git 隱藏
action.Git.ShowBranches.pretty.description=顯示分支
action.Git.ShowBranches.text=顯示分支
action.Git.Squash.Commits.text=壓縮提交…
action.Git.Squash.Into.Commit.description=建立壓縮提交
action.Git.Squash.Into.Commit.text=壓縮到…
action.Git.Stage.Add.All.description=將所有未暫存的更改和未追蹤的檔案新增到索引
action.Git.Stage.Add.All.text=全部暫存
action.Git.Stage.Add.Tracked.description=將追蹤檔案中所有未暫存的更改新增到索引
action.Git.Stage.Add.Tracked.text=暫存全部已追蹤項
action.Git.Stage.Compare.Local.Staged.text=與暫存版本比較
action.Git.Stage.Compare.Staged.Head.text=與 HEAD 版本比較
action.Git.Stage.Compare.Staged.Local.text=與本地版本比較
action.Git.Stage.Compare.Three.Versions.text=比較 HEAD 版本、暫存版本和本地版本
action.Git.Stage.Show.Local.description=在編輯器中顯示當前檔案的本地內容
action.Git.Stage.Show.Local.text=顯示本地版本
action.Git.Stage.Show.Staged.description=在編輯器中顯示當前檔案的暫存內容
action.Git.Stage.Show.Staged.text=顯示暫存版本
action.Git.Stage.ThreeSideDiff.description=顯示包含 HEAD、暫存和本地版本的差異視窗，從中可以互動地將更改新增到暫存區域
action.Git.Stage.ThreeSideDiff.text=比較 HEAD 版本、暫存版本和本地版本
action.Git.Stash.Apply.description=套用所選隱藏
action.Git.Stash.Apply.text=套用
action.Git.Stash.Drop.description=丟棄所選隱藏
action.Git.Stash.Drop.text=刪除
action.Git.Stash.Pop.description=彈出所選隱藏
action.Git.Stash.Pop.text=彈出
action.Git.Stash.Refresh.description=重新整理隱藏列表
action.Git.Stash.Refresh.text=重新整理隱藏
action.Git.Stash.Silently.text=無提示隱藏
action.Git.Stash.UnstashAs.description=彈出或套用選定的隱藏作為新分支(帶或不帶索引)
action.Git.Stash.UnstashAs.text=取消隱藏…
action.Git.Stash.text=隱藏更改…
action.Git.Tag.text=新增標記…
action.Git.Toggle.Favorite.title=標記/取消標記為收藏項
action.Git.Toolbar.ShowMoreActions.description=VCS 動作
action.Git.Toolbar.ShowMoreActions.text=版本控制
action.Git.Uncommit.description=撤消最後一次提交並將其更改放入所選更改列表
action.Git.Uncommit.text=撤消提交…
action.Git.Unstash.text=取消隱藏更改…
action.Git.Update.Selected.description=從追蹤的遠端獲取並使用 {1} 或像 \`git fetch branch:branch\` 一樣的快進(如果可能)更新所選{0,choice,1#分支|2#分支}
action.Git.Update.Selected.description.already.running=更新已在執行
action.Git.Update.Selected.description.select.non.current=僅選擇非當前分支
action.Git.Update.Selected.description.tracking.not.configured=沒有為所選{0,choice,1#分支|2#分支}組態追蹤分支
action.Git.Update.Selected.text=更新所選
action.New.Branch.disabled.fresh.description=無法在空版本庫中建立新分支。首先進行初始提交
action.New.Branch.disabled.several.commits.description=選擇單個提交以建立新分支
action.NotificationAction.GitDeleteBranchOperation.text.delete.tracked.branch=刪除追蹤的分支
action.NotificationAction.GitDeleteBranchOperation.text.restore=還原
action.NotificationAction.GitDeleteBranchOperation.text.view.commits=檢視提交
action.NotificationAction.GitDeleteTagOperation.text.restore=還原
action.NotificationAction.GitMergeAction.text.view.commits=檢視提交
action.NotificationAction.GitRewordOperation.text.undo=撤消
action.NotificationAction.GitUpdateSession.text.view.commits=檢視提交
action.NotificationAction.GithubNotifications.text.configure=組態…
action.NotificationAction.text.resolve=解決…
action.addQuickAction.Git.Commit.text=提交…
action.addQuickAction.Git.Diff.text=顯示差異...
action.addQuickAction.Git.History.text=顯示歷史記錄...
action.addQuickAction.Git.Push.text=推送…
action.addQuickAction.Git.Rollback.text=復原...
action.addQuickAction.Git.Update.text=更新專案...
action.description.cant.revert.merge.commit=不允許還原合併提交
action.fetch.text=獲取
action.git4idea.commands.TestGitHttpLoginDialogAction.text=測試 Git 登入對話框
action.label.add.unstaged.range=暫存
action.label.add.unstaged.range.tooltip=向索引中新增新的更改
action.label.reset.staged.range=取消暫存
action.label.reset.staged.range.tooltip=移除索引中的更改
action.main.toolbar.git.Branches.text=VCS 小工具
action.not.possible.in.fresh.repo.checkout=簽出
action.not.possible.in.fresh.repo.generic=動作
action.not.possible.in.fresh.repo.push=正在推送提交
action.not.possible.in.fresh.repo.rename.branch=正在重新命名分支
action.not.possible.in.fresh.repo.show.diff=正在比較修訂
action.selected.directory.text=選定{0,choice,1#目錄|2#目錄}
action.selected.file.text=選定{0,choice,1#檔案|2#檔案}
activity.name.rebase=重定基底
activity.name.unstash=取消隱藏
activity.name.update=VCS 更新
add.adding=正在新增檔案…
advanced.setting.git.branch.cleanup.symbol=分支名稱清理符號
advanced.setting.git.branch.cleanup.symbol.description=將在 git 分支名稱中代替停用符號的符號
advanced.setting.git.clone.recurse.submodules=遞迴克隆專案中的子模組
advanced.setting.git.clone.recurse.submodules.description=啟用後，從 Git 呼叫 'git clone --recurse-submodules' 簽出，即克隆主版本庫與所有子模組 (如有)
advanced.setting.git.read.content.with=從 Git 讀取時套用內容轉換
advanced.setting.git.read.content.with.description=從 Git 讀取檔案內容時為 'git cat-file' 指令使用 '--filters' 或 '--textconv' 標誌
advanced.setting.git.update.incoming.outgoing.info=檢查傳入和傳出提交
advanced.setting.git.update.incoming.outgoing.info.description=在“分支”彈出視窗中更新具有傳入/傳出提交的分支資訊
advanced.setting.git.use.push.force.with.lease=使用安全強制推送
advanced.setting.git.use.push.force.with.lease.description=從 IDE 呼叫強制推送時使用 '--force-with-lease'，而非僅使用 '--force'
advanced.setting.git.use.schannel.on.windows=使用 Windows 憑證存儲
advanced.setting.git.use.schannel.on.windows.description=強制 Git 使用 Windows 憑證存儲來驗證 SSL 連線。適用於 Git 2.14 及更高版本。
advanced.settings.git=版本控制. Git
annotate.cannot.annotate.dir=無法註解目錄
annotate.line.mismatch.exception=正在為第 {0} 行新增資訊，但應當為第 {1} 行新增資訊
annotate.output.lack.data=第 {0} 行的輸出缺少必要的資料
annotations.options.detect.movements.across.files=檢測跨檔案的移動
annotations.options.detect.movements.within.file=檢測檔案內的移動
annotations.options.group=選項
annotations.options.ignore.whitespaces=忽略空格
apply.changes.applied.for.commits={0} {1,choice,1#項提交|2#{1,number} 項提交} 來自於 {2}
apply.changes.everything.applied={0} 中的所有更改已被{1}
apply.changes.nothing.to.do=沒要有{0}的內容
apply.changes.operation.canceled={0} 已取消
apply.changes.operation.failed={0} 失敗
apply.changes.operation.performed.with.conflicts={0}已執行，但存在衝突
apply.changes.operation.successful={0}成功
apply.changes.operation.successful.for.commits=但是，對以下{1, choice,1#提交|2#提交}成功進行了{0}:
apply.changes.resolving.conflicts.progress.title=正在解決衝突…
apply.changes.skipped={0} {1,choice,1#被|2#被}跳過，因為所有更改已被{2}。
apply.changes.unresolved.conflicts.notification.abort.action.text=中止{0}
apply.changes.unresolved.conflicts.notification.resolve.action.text=解決…
apply.changes.unresolved.conflicts.text=工作樹中有未解決的衝突。
apply.changes.would.be.overwritten=您的本地更改將被 {0} 覆蓋。\\n提交您的更改，或隱藏更改以繼續。
apply.conflict.dialog.description.label.text=在由 {2} 執行的提交 {1} 的{0}過程中發生衝突{3}
blob.not.found=找不到 Blob: {0} - {1}
branch.checking.out.branch.from.process=正在從 {1} 簽出 {0}…
branch.checking.out.new.branch.process=正在簽出新分支 {0}…
branch.checking.out.process=正在簽出 {0}…
branch.creating.branch.process=正在建立分支 {0}…
branch.deleting.branch.process=正在刪除 {0}…
branch.deleting.remote.branch=正在刪除 {0}…
branch.deleting.tag.on.remote.process=正在刪除遠端分支上的標記 {0}…
branch.deleting.tag.process=正在刪除標記 {0}…
branch.direction.panel.base.repo.label=base 版本庫:
branch.direction.panel.branch.label=分支:
branch.direction.panel.head.repo.label=head 版本庫:
branch.direction.panel.save.button=儲存
branch.direction.panel.select.link=選擇…
branch.direction.panel.warning.not.synced=本地分支未與遠端分支同步。\\n''{0}'' 分支將與 ''{1}'' 同步。
branch.direction.panel.warning.push=''{0}'' 沒有遠端分支。\\n將在 ''{1}'' 上建立新的遠端分支。
branch.merging.process=正在合併 {0}…
branch.not.fully.merged.dialog.all.commits.from.branch.were.merged=已合併來自分支 {0} 的所有提交
branch.not.fully.merged.dialog.repository.label=版本庫:
branch.not.fully.merged.dialog.restore.button=還原(&R)
branch.not.fully.merged.dialog.the.branch.was.not.fully.merged.to=分支 {0} 未完全合併到 {1}。<br/>以下是未合併提交的列表。
branch.not.fully.merged.dialog.title=分支未完全合併
branch.operation.could.not.0.operation.name.1.reference=無法{0} {1}
branch.operation.in={0} ({1} 中)
branch.rebasing.onto.process=正在重定基底到 ''{0}''…
branch.rebasing.process=正在重定基底 {0}…
branch.renaming.branch.process=正在將 {0} 重命名為 {1}…
branch.ui.handler.can.not.operation.name.because.of.unmerged.files=由於存在未合併的檔案而無法{0}
branch.ui.handler.delete.all=全部刪除
branch.ui.handler.delete.remote.branches=刪除遠端 {0,choice,1#分支|2#分支}
branch.ui.handler.delete.remote.branches.question=刪除遠端 {0,choice,1#分支|2#分支} {1}?
branch.ui.handler.delete.tracking.local.branch.as.well=同時刪除追蹤本地分支 {0}
branch.ui.handler.delete.tracking.local.branches=刪除追蹤本地分支:
branch.ui.handler.do.not.rollback=不復原
branch.ui.handler.merge.error.notification.title=仍然存在未解決的檔案。
branch.ui.handler.merge.notification.description=以下檔案存在未解決的衝突。您需要先解決它們，然後再{0}。
branch.ui.handler.rollback=復原
branch.ui.handler.unmerged.files.error.notification=您必須先<a href=''{0}''>解決</a>所有合併衝突，然後才能{1}。<br/>解決衝突之後，您可能還需要將檔案提交到當前分支。
branch.ui.handler.you.have.to.resolve.all.conflicts.before.operation.name=您必須先解決所有合併衝突，然後才能{0}。<br/>{1}
branch.worker.could.not.create.tag=無法{1,choice,0#|1#|2#在 {2} 中}建立標記 {0}
branches.action.delete=刪除
branches.action.pull.into.branch.using.merge=使用合並拉入 {0}
branches.action.pull.into.branch.using.merge.description=使用合並拉入 {0}
branches.action.pull.into.branch.using.merge.selected=使用合併拉入當前分支
branches.action.pull.into.branch.using.rebase=使用重定基底拉入 {0}
branches.action.pull.into.branch.using.rebase.description=使用重定基底拉入 {0}
branches.action.pull.into.branch.using.rebase.selected=使用重定基底拉入當前分支
branches.branch.0=分支 ''{0}''
branches.branches=分支
branches.checking.existing.commits.process=正在檢查現有提交…
branches.checkout=簽出
branches.checkout.and.rebase.error.current.with.same.name=無法覆蓋當前分支 {0}
branches.checkout.and.rebase.failed=簽出和重定基底失敗
branches.checkout.and.rebase.onto.branch=簽出並重定基底到 {0}
branches.checkout.and.rebase.onto.current=簽出並重定基底到當前分支
branches.checkout.and.rebase.onto.current.process=正在簽出 {0} 並重定基底到當前分支
branches.checkout.and.rebase.onto.in.one.step=簽出 {0}，並在一個步驟中將其重定基底到 {1} (類似於 \`git rebase HEAD {2}\`)
branches.checkout.local=簽出本地分支
branches.checkout.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。將 ''{0}'' 變基到 ''{1}''，還是簽出 ''{0}''?
branches.checkout.s=簽出 {0}
branches.checkout.tag.or.revision=簽出標記或修訂…
branches.checkout.with.reset.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。將 ''{0}'' 變基到 ''{1}''，還是刪除本地提交?
branches.compare.the.current.working.tree.with=將當前工作樹與 {0} 中的樹進行比較
branches.compare.with.branch=與{0}比較
branches.compare.with.current=與當前分支進行比較
branches.create.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。是否要在其他版本庫中建立分支?
branches.create.new.branch.dialog.title=建立新分支
branches.create.with.reset.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。是否要刪除本地提交?
branches.current.branch=當前分支
branches.current.branch.name=當前
branches.drop.local.commits=刪除本地提交
branches.enter.reference.branch.tag.name.or.commit.hash=輸入參照(分支、標記)名稱或提交雜湊:
branches.local.branches=本地分支
branches.local.branches.in.repo={0} 中的本地分支
branches.merge.into=將 {0} 合併到 {1} 中
branches.merge.into.current=合併到當前分支
branches.new.branch.from.branch=從 {0} 新增分支…
branches.new.branch.from.branch.current=從當前位置新增分支…
branches.new.branch.from.branch.description=從 {0} 建立新分支
branches.rebase.current.onto.selected=將當前分支重定基底到所選分支
branches.rebase.is.not.possible.in.the.detached.head.state=在游離的 HEAD 狀態下無法重定基底
branches.rebase.onto=將 {0} 變基到 {1}
branches.remote.branches=遠端分支
branches.remote.branches.in.repo={0} 中的遠端分支
branches.rename.branch=重新命名分支 {0}
branches.selected.branch.name=已選擇
branches.selected.branches.updated.title=已更新{0,choice,1#分支|2#分支}:\\n\\n{1}
branches.show.commits.in=在{0}中顯示{1}中缺少的提交
branches.show.diff.with.working.tree=顯示與工作樹的差異
branches.tag.0=標記 ''{0}''
branches.tags=標記
branches.there.are.incoming.and.outgoing.commits=存在傳入和傳出提交
branches.there.are.incoming.commits=存在傳入提交
branches.there.are.outgoing.commits=存在傳出提交
branches.tracking.branch.doesn.t.configured.for.s=沒有為 {0} 組態追蹤分支
branches.update=更新
branches.update.failed=更新失敗
branches.update.info.process=更新分支資訊…
branches.update.is.already.running=更新已在執行
branches.updating.process=正在更新分支…
button.changes.excluded.from.commit.commit.anyway=仍然提交
button.crlf.fix.dialog.commit.as.is=按原樣提交
button.crlf.fix.dialog.fix.and.commit=修復並提交
button.don.t.rollback=不復原
button.rollback=復原
button.set.name.and.commit=設定並提交
changes.retrieving=檢索修訂 {0} 的更改
changes.view.merge.action.text=合併
checkbox.dont.warn.again=不再警告(&W)
checkbox.run.git.hooks=執行 Git 掛鈎(&H)
checkbox.set.config.property.globally=全域設定屬性(&G)
checkout.0=簽出 {0}
checkout.and.rebase=重定基底到遠端
checkout.new.branch.operation.branch.was.created=已建立分支 {0}
checkout.new.branch.operation.checked.out.0.and.deleted.1.on.2.3=已在{2,choice,1#根|2#根}{3}上簽出 {0} 並刪除 {1}
checkout.new.branch.operation.could.not.create.new.branch=無法建立新分支 {0}
checkout.new.branch.operation.error.during.rollback=復原期間出錯
checkout.new.branch.operation.errors.during.checkout=簽出期間出錯:
checkout.new.branch.operation.errors.during.deleting=刪除 {0} 期間出錯:
checkout.new.branch.operation.however.checkout.has.succeeded.for.the.following=不過，{0,choice,1#版本庫|2#版本庫} 的簽出已成功:
checkout.new.branch.operation.rollback.successful=復原成功
checkout.new.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以復原(簽回上一個分支並刪除 {0})以使分支不出現分叉。
checkout.operation.checked.out=已簽出 {0}
checkout.operation.checked.out.new.branch.from=已從 {1} 中簽出新分支 {0}
checkout.operation.could.not.checkout.error=無法簽出 {0}
checkout.operation.could.not.checkout.error.title=無法簽出 {0}
checkout.operation.error.during.rollback=復原期間出錯
checkout.operation.errors.during.checkout=簽出期間出錯:
checkout.operation.errors.during.deleting=刪除 {0} 期間出錯:
checkout.operation.force.checkout=強制簽出(&F)
checkout.operation.however.checkout.has.succeeded.for.the.following=不過，以下{0,choice,1#版本庫|2#版本庫}的簽出已成功:
checkout.operation.in={1,choice,0#|1#{2}中的}{0}
checkout.operation.name=簽出
checkout.operation.previous.branch=上一個分支
checkout.operation.revision.not.found=在{0,choice,0#|1#{1}中}未找到修訂
checkout.operation.rollback=復原
checkout.operation.you.may.rollback.not.to.let.branches.diverge=您可以復原(簽回 {0})以使分支不出現分叉。
cherry.pick.applied=套用
cherry.pick.name=優選
clone.dialog.checking.git.version=正在檢查 Git 版本…
column.name.commit.signature=GPG 簽名
combobox.item.file.invalid=(無效)
commit.action.commit.and.rebase.text=提交並重定基底…
commit.action.name=提交 (&I)
commit.author=作者(&A):
commit.author.diffs=<html>作者與預設不同</html>
commit.author.with.committer={0}，通過 {1}
commit.check.warning.title.commit.during.rebase=正在版本庫中進行重定基底: {0}。在重定基底期間提交可能會導致提交丟失。
commit.check.warning.title.commit.during.rebase.details=有關 Git 重定基底的更多資訊
commit.check.warning.title.commit.with.detached.head=版本庫處於游離的 HEAD 狀態: {0}
commit.check.warning.title.commit.with.detached.head.details=有關游離的 HEAD 的更多資訊
commit.check.warning.user.name.email.not.set=未設定 Git user.name 和 user.email
commit.options.create.extra.commit.with.file.movements=使用檔案移動建立額外提交
commit.options.sign.off.commit.checkbox=Sign-off 提交(&G)
commit.options.sign.off.commit.message.line=在提交訊息結尾添加以下行:<br/>Signed-off by: {0}
commit.signature.bad=錯誤的 GPG 簽名
commit.signature.fingerprint=簽名指紋:
commit.signature.none=無 GPG 簽名
commit.signature.signed.by=通過密鑰簽名:
commit.signature.unverified=未驗證的 GPG 簽名
commit.signature.unverified.reason.cannot.verify=無法驗證(例如，缺少密鑰)
commit.signature.unverified.reason.expired=過期的簽名
commit.signature.unverified.reason.expired.key=使用過期的密鑰建立
commit.signature.unverified.reason.revoked.key=使用撤消的密鑰建立
commit.signature.unverified.reason.unknown=未知有效性
commit.signature.unverified.with.reason=未驗證的 GPG 簽名: {0}
commit.signature.verified=已驗證的 GPG 簽名
common.current.branch=當前分支:
common.current.branch.tooltip=當前已簽出的分支。
common.git.root=Git 根(&R):
common.git.root.tooltip=選擇 Git VCS 根
common.local.branches=公共本地分支
common.no.active.branch=<無活動分支>
common.refreshing=正在重新整理檔案
common.remote.branches=公共遠端分支
common.suffix.in.one.repository=在 {0} 中
common.suffix.in.several.repositories=在 {0} 個版本庫中
computing.annotation=正在計算 {0} 的註解
conflict.resolver.unmerged.files.check.error.notification.description.text=由於錯誤，無法檢查工作樹中是否有未合併的檔案。{0}
conflicts.accept.progress=正在解析 {0,choice,1#個衝突|2#個衝突}
conflicts.accept.theirs.action.text=接受他們的更改
conflicts.accept.yours.action.text=接受您的更改
conflicts.loading.status=正在載入合併衝突…
conflicts.merge.window.error.message=找不到 {0} 的檔案
conflicts.merge.window.error.title=無法解決衝突
conflicts.resolve.action.text=解決
conflicts.type.added.by.them=由他們新增
conflicts.type.added.by.you=由您新增
conflicts.type.both.added=均已新增
conflicts.type.both.deleted=均已刪除
conflicts.type.both.modified=均已修改
conflicts.type.deleted.by.them=由他們刪除
conflicts.type.deleted.by.you=由您刪除
create.branch.operation.branch.created=已建立分支 {0}
create.branch.operation.could.not.create.new.branch=無法建立新分支 {0}
create.branch.operation.deleted.branch=已刪除 {0}
create.branch.operation.error.during.rollback=復原期間出錯
create.branch.operation.however.the.branch.was.created.in.the.following.repositories=不過，已在以下 {0,choice,1#版本庫|2#版本庫} 中建立分支:
create.branch.operation.name=建立分支
create.branch.operation.rollback.successful=復原成功
create.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以復原(刪除 {0})以使分支不出現分叉。
delete.branch.operation.branch.was.not.deleted.error=分支 {0} 未刪除
delete.branch.operation.collecting.unmerged.commits.process=正在收集未合併的提交…
delete.branch.operation.could.not.restore.branch.error=無法還原 {0}
delete.branch.operation.deleted.branch=已刪除分支 {0}
delete.branch.operation.deleted.branch.bold=<b>已刪除的分支:</b> {0}
delete.branch.operation.error.during.rollback.of.branch.deletion=分支刪除復原期間出錯
delete.branch.operation.however.branch.deletion.has.succeeded.for.the.following=不過，以下{0,choice,1#版本庫|2#版本庫}的分支刪除已成功:
delete.branch.operation.name=分支刪除
delete.branch.operation.restoring.branch.process=正在還原分支 {0}…
delete.branch.operation.unmerged.commits.were.discarded=未合併的提交已被捨棄
delete.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以復原(在這些根中重新建立 {0})以使分支不出現分叉。
delete.remote.branch.operation.also.deleted.local.branches=同時刪除了本地 {0,choice,1#分支|2#分支}: {1}
delete.remote.branch.operation.couldn.t.find.remote.by.name=無法按名稱尋找遠端: {0}
delete.remote.branch.operation.deleted.remote.branch=已刪除遠端分支 {0}
delete.remote.branch.operation.deleting.process=正在刪除 {0}
delete.remote.branch.operation.failed.to.delete.remote.branch=無法刪除遠端分支 {0}
delete.remote.tag.operation.deleted.tag.on.remotes=<b>已刪除{0,choice,1#遠端|2#遠端}上的標記:</b> {1}
delete.remote.tag.operation.failed.to.delete.tag.on.remotes=無法刪除 {1,choice,1#遠端|2#遠端} 上的標記 {0}
delete.remote.tag.operation.tag.does.not.exist.on.remotes=<b>標記在{0,choice,1#遠端|2#遠端}上不存在:</b> {1}
delete.tag.operation.could.not.find.tag=找不到標記 {0}
delete.tag.operation.could.not.find.tag.in=在 {0} 中找不到標記
delete.tag.operation.could.not.restore.tag=無法還原 {0}
delete.tag.operation.delete.on.remote=在{0,choice,1#遠端|2#遠端}上刪除
delete.tag.operation.deleted.tag=<b>已刪除的標記:</b> {0}
delete.tag.operation.error.during.rollback.of.tag.deletion=標記刪除復原期間出錯
delete.tag.operation.however.tag.deletion.has.succeeded.for.the.following=不過，以下{0,choice,1#版本庫|2#版本庫}的標記刪除已成功:
delete.tag.operation.restored.tag=已還原標記 {0}
delete.tag.operation.restoring.tag.process=正在還原標記 {0}…
delete.tag.operation.rollback.successful=復原成功
delete.tag.operation.tag.was.not.deleted=未刪除標記 {0}
delete.tag.operation.you.may.rollback.not.to.let.tags.diverge=您可以復原(在這些根中重新建立 {0})以使標記不出現分叉。
dialog.message.rebasing.merge.commits=您即將重定基底存在衝突的合併提交。\\n\\n如果您不想再次解決衝突，請選擇“合併”; 如果要將歷史記錄線性化，仍可進行重定基底。
dialog.message.untracked.files.will.be.overwritten.by.operation=這些未追蹤的檔案將被{0}覆蓋
dialog.title.could.not.operation=無法{0}
dialog.title.local.changes.prevent.from.operation=本地更改阻止{0}
dialog.title.rebasing.merge.commits=正在重定基底合併提交
dialog.title.untracked.files.preventing.operation=阻止{0}的未追蹤檔案
diff.find.error=正在尋找差異的修訂: {0}
editor.promo.close.link=不再顯示
editor.promo.commit.text=使用提交接口直接從 {0} 提交。
editor.promo.commit.try.link=嘗試
editor.promo.help.link=了解詳情
error.cannot.delete.file=無法刪除檔案: {0}
error.cant.set.user.name.email=無法設定 user.name 和 user.email
error.commit.cant.collect.partial.changes=無法收集要提交的部分更改
error.commit.cant.commit.multiple.changelists=無法一次提交多個更改列表中的更改
error.commit.cant.commit.with.unmerged.paths=由於您有未合併的檔案，因此無法提交。
error.commit.cant.create.message.file=建立提交訊息檔案失敗
error.dialog.title=錯誤
error.git.parse.not.a.revision.number=字串 ''{0}'' 不表示修訂號
error.git.parse.unknown.file.status=未知檔案狀態: {0}
error.git.repository.not.found=該版本庫不再存在: {0}
error.git.version.check.failed=執行 ''git --version'' 時出錯。退出程式碼: {0}，錯誤: {1}
error.list.title={0} 錯誤:
error.no.changed.files.no.commit.message=修改要提交的檔案並指定提交訊息
error.no.changed.files.to.commit=修改要提交的檔案
error.no.selected.roots.to.commit=選擇要提交的根
error.no.staged.changes.no.commit.message=暫存要提交的檔案並指定提交訊息
error.no.staged.changes.to.commit=暫存要提交的檔案
error.occurred.during=''{0}'' 時出錯
error.unresolved.conflicts=解決衝突以提交
errors.message=Git 動作以多個錯誤結束: {0}
errors.message.item=\\n{0}
exception.message.could.not.stash.root.error=無法隱藏 {0}: {1}
executable.error.git.not.installed=未安裝 Git
executable.mac.error.invalid.path.to.command.line.tools=Command Line Tools 的路徑無效
executable.mac.fix.path.action=修正路徑
exportable.Git.Application.Settings.presentable.name=Git
fetch.action.name=獲取
fetch.pruned.obsolete.remote.references=刪除過時的遠端 {0,choice,1#參照|2#參照}: {1}
fetching=正在獲取…
find.git.error.title=執行 Git 時出錯
find.git.success.title=Git 執行成功
find.git.unsupported.message=<html><tt>{0}</tt><br>此版本不受支援，某些延伸模組功能可能無法工作。<br>支援的最低版本是 <em>{1}</em>。</html>
git.add.to.exclude.file.action.description=將條目新增到 .git/info/exclude
git.add.to.exclude.file.action.text=.git/info/exclude
git.branches.popup.tree.accessible.name=分支樹
git.branches.popup.tree.no.branches=找不到分支 ''{0}''
git.commit.message.empty.title=提交訊息為空
git.commit.nothing.to.commit.error.message=沒有要提交的內容
git.compare.branches.empty.status={0} 包含來自 {1} 的所有提交
git.compare.branches.explanation.message=存在於 {0} 中但不存在於 {1} 中的提交
git.compare.branches.tab.name=比較
git.compare.branches.tab.suffix={0} 和 {1}
git.compare.with.tag.file.not.found.in.tag=標記 ''{2}'' 中不存在{0,choice,1#檔案|2#目錄} {1}
git.compare.with.tag.loading.error.title=無法載入標記
git.compare.with.tag.modal.progress.loading.tags=正在載入標記…
git.compare.with.tag.popup.title=選擇要比較的標記
git.content.transform.filters=篩選器
git.content.transform.none=無
git.content.transform.textconv=TextConv
git.error.cant.process.output=無法處理 Git 輸出: {0}
git.error.exit=Git 程序退出，程式碼為 {0}
git.executable.detect.progress.title=正在檢測 Git 可執行檔案
git.executable.error.bash.not.found=找不到 bash 可執行檔案
git.executable.error.file.not.found=沒有此類別檔案: {0}
git.executable.notification.cant.run.in.safe.mode=無法在安全模式下執行 Git 指令
git.executable.notification.description=Git 可執行檔案的路徑可能無效。
git.executable.notification.title=無法啟動 Git
git.executable.unknown.error.message=無法啟動 Git 程序: {0}
git.executable.validation.cant.identify.executable.message=無法識別 git 可執行檔案 {0} 的版本
git.executable.validation.cant.run.in.safe.mode=無法在安全模式下執行 Git 指令
git.executable.validation.error.no.response.in.n.attempts.message=無法識別 Git 可執行檔案的版本: {0,choice,0#|2# {0} 次嘗試後}無響應
git.executable.validation.error.start.title=無法執行 Git
git.executable.validation.error.version.message=至少需要 {0}
git.executable.validation.error.version.title=Git 版本 {0} 不受支援
git.executable.validation.error.wsl1.unsupported.message=不支持 WSL 版本 1，請參閱 <a href='https://youtrack.jetbrains.com/issue/IDEA-242469'>IDEA-242469</a>
git.executable.validation.error.xcode.message=執行“sudo xcodebuild -license”並重試(需要管理員權限)
git.executable.validation.error.xcode.title=接受 XCode/iOS 授權以執行 Git
git.executable.version.is=Git 版本為 {0}
git.executable.version.progress.title=正在識別 Git 版本
git.fetch.progress=正在獲取…
git.history.diff.handler.choose.parent.popup=選擇要比較的父項
git.history.diff.handler.git.show.error=執行 git show {0}:{1} 時出錯
git.history.diff.handler.load.changes.process=正在載入更改…
git.history.diff.handler.no.changes.in.file.info=此合併提交中的檔案 {0} 無更改
git.integration.could.not.git.init=無法 git init {0}
git.integration.created.git.repository.in=已在 {0} 中建立 Git 版本庫
git.light.cant.find.current.revision.exception.message=找不到 {0} 的當前修訂
git.light.status.bar.display.name=Git
git.light.status.bar.text=Git: {0}
git.light.status.bar.tooltip=當前 Git 分支: {0}
git.log.action.checkout.group=簽出
git.log.action.checkout.revision.full.text=簽出修訂 ''{0}''
git.log.action.checkout.revision.short.text=修訂 ''{0}''
git.log.branches.search.field.accessible.description=按 {0} 轉到 VCS 日誌表篩選器
git.log.branches.search.field.accessible.name=Git 分支搜尋
git.log.branches.tree.accessible.name=Git 分支
git.log.cherry.picked.highlighter.cancelled.message=已取消對 ''{0}'' 中未選取提交的醒目提示，因為分支篩選器已被更改。
git.log.cherry.picked.highlighter.error.message=無法與分支 {0} 進行比較
git.log.cherry.picked.highlighter.process=正在比較分支…
git.log.cherry.picked.highlighter.select.branch.popup=選擇源分支
git.log.diff.handler.changes.between.revisions.in.paths.title={2} 中 {0} 與 {1} 之間的更改
git.log.diff.handler.changes.between.revisions.title={0} 與 {1} 之間的更改
git.log.diff.handler.local.version.content.title=本地
git.log.diff.handler.local.version.name=本地版本
git.log.external.loading.process=正在載入 Git 日誌…
git.log.external.tab.description={0} 的日誌
git.log.external.window.title=Git 日誌
git.log.refGroup.local=本地
git.log.show.commit.in.log.process=正在搜尋修訂 {0}
git.new.tag.dialog.tag.name.label=輸入新標記的名稱
git.new.tag.dialog.title=在 {0}上建立新標記
git.open.exclude.file.action.description=在編輯器中開啟 .git/info/exclude
git.open.exclude.file.action.text=開啟 .git/info/exclude
git.rename.branch.could.not.rename.from.to=無法將 {0} 重命名為 {1}
git.rename.branch.has.succeeded.for.the.following.repositories=不過，以下{0,choice,1#版本庫|2#版本庫}的重新命名已成功:
git.rename.branch.renamed.back.to=已重新命名回 {0}
git.rename.branch.rollback.failed=復原失敗
git.rename.branch.rollback.successful=復原成功
git.rename.branch.was.renamed.to=分支 {0} 已被重命名為 {1}
git.rename.branch.you.may.rename.branch.back=您可以復原(將分支重新命名回 {0})以使分支不出現分叉。
git.reset.button=重設
git.reset.dialog.description=<nobr>這會將當前分支 HEAD 重設為所選提交，<nobr/><br><nobr>並根據所選模式更新工作樹和索引:<nobr/>
git.reset.dialog.description.commit.details.by.author={0}，作者 {1}
git.reset.dialog.description.source.in.repository={0} ({1} 內)
git.reset.dialog.title=Git 重設
git.reset.failed.notification.title=重設失敗
git.reset.hard.button=硬重設(&H)
git.reset.mode.hard=硬
git.reset.mode.hard.description=<nobr>檔案將還原為所選提交的狀態。<nobr/><br><nobr>警告: 任何本地更改都將丟失。<nobr/>
git.reset.mode.keep=保留
git.reset.mode.keep.description=<nobr>檔案將還原為所選提交的狀態，<nobr/><br><nobr>但本地更改將保持不變。<nobr/>
git.reset.mode.mixed=混合
git.reset.mode.mixed.description=檔案不會更改，差異也不進行暫存。
git.reset.mode.soft=軟
git.reset.mode.soft.description=檔案不會更改，差異將暫存以進行提交。
git.reset.operation=重設
git.reset.partially.failed.notification.msg={0} 重設成功\\n但 {1} 重設失敗:\\n{2}
git.reset.partially.failed.notification.title=重設部分失敗
git.reset.process=Git 重設
git.reset.successful.notification.message=重設成功
git.rollback=復原(&R)
git.running=執行: {0}
git.status.bar.widget.name=Git 分支
git.status.bar.widget.text.cherry.pick=正在 {0} 中優選
git.status.bar.widget.text.merge=正在合併 {0}
git.status.bar.widget.text.rebase=正在重定基底 {0}
git.status.bar.widget.text.revert=正在 {0} 中還原
git.status.bar.widget.text.unknown=<未知>
git.status.bar.widget.tooltip.detached=Git: 游離的 HEAD 不指向任何分支
git.status.copied=已複製
git.status.index=在暫存區域中{0}
git.status.not.changed=未更改
git.status.renamed=已重新命名
git.status.type.changed=已更改類型
git.status.unmerged=已取消合併
git.status.unmerged.both=兩者{0}
git.status.unmerged.index=我們{0}
git.status.unmerged.work.tree=由他人{0}
git.status.untracked=已取消追蹤
git.status.work.tree=在工作目錄中{0}
git.tag.could.not.create.tag=無法建立標記
git.tag.created.tag.successfully=已成功建立標記 {0}。
git.toolbar.widget.no.repo=版本控制
git.toolbar.widget.no.repo.tooltip=為專案組態版本控制
git.undo.action.cant.undo.commit.failure=無法撤消提交
git.undo.action.could.not.load.changes.of.commit=無法載入 {0} 的更改
git.undo.action.description=所選提交不是當前分支中的最後一次提交
git.undo.action.failed.notification.title=撤消提交失敗
git.undo.action.operation=撤消提交
git.undo.action.process=Git 撤消提交
git.undo.action.refreshing.changes.process=正在重新整理更改…
git.undo.action.select.target.changelist.title=選擇目標更改列表
git.undo.action.successful.notification.message=撤消提交成功
git.undo.action.undoing.last.commit.process=正在撤消最後一次提交…
git.unstash.clear.confirmation.message=移除所有隱藏? 此動作無法撤消。
git.unstash.clear.confirmation.title=移除所有隱藏?
git.unstash.drop.confirmation.message=<html>是否要移除 {0}?<br/>“{1}”</html>
git.unstash.drop.confirmation.title=移除隱藏 {0}?
git.update.commits.matching.filters={0,choice,1#{0} 個提交|2#{0} 個提交}與篩選器匹配
git.update.files.updated.in.commits=已更新 {1,choice,1#{1} 個提交|2#{1} 個提交}中的 {0,choice,1#{0} 個檔案|2#{0} 個檔案}
git.update.no.commits.matching.filters=沒有與篩選器符合的提交
git.update.operation=更新
git.update.project.partially.updated.title=專案已部分更新
git.update.repo.was.skipped=已跳過 {0} ({1})
git.update.skipped.repositories=已跳過 {0} 個版本庫:
git4idea.vcs.name=Git
git4idea.vcs.name.with.mnemonic=&Git
gpg.error.see.documentation.link.text=參閱 GPG 設定指南
gpg.jb.manual.link=Set_up_GPG_commit_signing
group.Git.CheckoutGroup.description=簽出所選修訂或所選提交中的分支
group.Git.CheckoutGroup.text=簽出
group.Git.ContextMenu.text=&Git
group.Git.HEAD.Branch.Filter.title=HEAD(當前分支)
group.Git.Local.Branch.title=本地
group.Git.Log.Branches.Grouping.Settings.text=分組依據
group.Git.Log.Branches.Settings.Separator.text=點擊時
group.Git.Log.Branches.Settings.text=分支窗格設定
group.Git.MainMenu.LocalChanges.text=未提交的更改(_U)
group.Git.MainMenu.MergeActions.text=合併(_M)
group.Git.MainMenu.RebaseActions.text=重定基底(_R)
group.Git.Menu.text=&Git
group.Git.Recent.Branch.in.repo.title={0} 中最近的分支
group.Git.Recent.Branch.title=最近
group.Git.Remote.Branch.title=遠端
group.Git.Stage.Index.File.Menu.text=Git
group.Git.Stage.Ui.Settings.text=檢視選項
group.MainToolbarVCSGroup.text=VCS 組
group.Vcs.ToolbarWidget.ShareProject.text=在以下平台上共享專案:
group.git4idea.actions.ShareLogIndexData.text=共享 Git 日誌索引資料
history.indexing.disabled.notification.dismiss.link=不再顯示
history.indexing.disabled.notification.resume.link=恢復 Git 日誌索引
history.indexing.disabled.notification.text=由於索引不可用，顯示的是舊式檔案歷史記錄
in.branches.all.repositories=在所有版本庫中
init.destination.directory.description=選擇將在其中建立新 Git 版本庫的目錄。
init.destination.directory.title=建立 Git 版本庫
init.warning.already.under.git=所選目錄 <tt>{0}</tt> 已在 Git 下。\\n確定要建立新的 VCS 根嗎?
init.warning.title=Git Init
initializing.title=正在初始化版本庫…
install.download.and.install.action=下載並安裝
install.downloading.progress=正在下載…
install.general.error=無法安裝 Git
install.installing.progress=正在安裝…
install.mac.error.couldnt.start.command.line.tools=無法啟動 Command Line Tools 安裝
install.mac.requesting.command.line.tools=正在請求 XCode Command Line Developer Tools
install.success.message=已安裝 Git
label.changes.excluded.from.commit.are.you.sure.want.to.continue=確定要從合併提交中排除這些更改過的檔案嗎?
label.credential.store.key.http.password=Git HTTP
label.diff.content.title.submodule.suffix={0} (子模組)
label.name.email.not.defined.in.n.roots={0,choice,1#根|2#根}中未定義 Git 的 user.name 和 user.email 屬性
label.user.email=電子郵件(&E):
label.user.name=名稱(&N):
link.label.commit.with.detached.head.read.more=閱讀有關游離的 HEAD 的更多資訊
link.label.commit.with.unfinished.rebase.read.more=閱讀有關 Git 重定基底的更多資訊
link.label.editor.notification.merge.conflicts.resolve.in.progress=正在解決合併衝突
link.label.local.changes.would.be.overwritten.by.merge.view.them=檢視這些更改
link.label.merge.conflicts.resolve.in.progress.cancel.resolve=取消解決
link.label.merge.conflicts.resolve.in.progress.focus.window=使視窗獲得焦點
local.changes.freeze.message.git.operation.prefix=Git {0}
local.changes.save.policy.shelve=擱置
local.changes.save.policy.stash=隱藏
log.parser.exception.message.could.not.parse.output=無法解析 Git 日誌輸出“{0}”
log.parser.exception.message.error.command.line={0}\\n命令行: [{1}]
log.parser.exception.message.error.parsing.line=解析第“{0}”行時出錯
login.dialog.button.login=登入
login.dialog.error.password.cant.be.empty=密碼不能為空
login.dialog.error.username.cant.be.empty=用戶名不能為空
login.dialog.label.login.to.url=登入 {0}
login.dialog.login.with.selected.provider=使用 {0} 登入…
login.dialog.password.label=密碼:
login.dialog.prompt.enter.credentials=輸入憑證:
login.dialog.select.login.way.credentials=輸入憑證
login.dialog.select.login.way.use.helper=使用憑證幫助程序
login.dialog.username.label=用戶名:
mention.in=\\ ({0} 中)
merge.action.after.update.label=更新後
merge.action.before.update.label=更新前
merge.action.name=合併
merge.action.operation.failed=Git {0} 失敗
merge.branch.already.merged=分支 ''{0}'' 已被合併
merge.branch.field.placeholder=指定分支
merge.branch.into.current.title=合併到 {0}
merge.branch.loading.branches.progress=正在載入未合併的分支…
merge.branch.popup.empty.text=無分支
merge.branch.title=合併更改
merge.commit.message.label=提交訊息:
merge.dialog.customizer.collecting.details.progress=正在收集提交詳細資訊…
merge.dialog.customizer.filter.by.conflicted.file.checkbox=按衝突檔案篩選
merge.dialog.customizer.show.details.link.label=顯示詳細資訊
merge.dialog.description.cherry.pick.label.text=在優選{2,choice,0#|1#由 {3}{4} 執行的}{0,choice,1#提交 {1}|2#多個提交}期間出現衝突
merge.dialog.description.merge.label.text=將{0,choice,1#分支 {1} |2#分叉的分支}合併到{2,choice,1#分支 {3}|2#分叉的分支}
merge.dialog.description.rebase.with.hash.label.text=正在{0,choice,0#|1#將分支 {1} }變基到 {2}
merge.dialog.description.rebase.with.onto.branch.label.text=正在{0,choice,0#|1#將分支 {1} }重定基底到分支 {2}{3,choice,0#|1#，修訂 {4}}
merge.dialog.description.rebase.without.onto.info.label.text=正在{0,choice,0#|1#將分支 {1} }重定基底到分叉的分支
merge.dialog.diff.left.title.cherry.pick.label.text=本地更改
merge.dialog.diff.left.title.default.branch.label.text=您的版本，分支 {0}
merge.dialog.diff.left.title.rebase.label.text=正在從 {1} 重定基底 {0}
merge.dialog.diff.right.title.cherry.pick.label.text=來自優選 {0} 的更改
merge.dialog.diff.right.title.default.with.hash.label.text=來自 {0} 的更改
merge.dialog.diff.right.title.default.with.onto.branch.label.text=來自分支 {0}{1,choice,0#|1#，修訂 {2}} 的更改
merge.dialog.diff.right.title.default.without.onto.info.label.text=來自分叉分支的更改
merge.dialog.diff.right.title.rebase.with.branch.label.text=已重定基底的提交和來自 {0} 的提交
merge.dialog.diff.right.title.rebase.without.branch.label.text=已重定基底的提交
merge.dialog.diff.title.changes.from.branch.label.text=來自 {0} 的更改
merge.error.unable.to.read.merge.head=無法讀取檔案 {0}: {1}
merge.no.branch.selected.error=應選擇該合併分支。
merge.no.matching.branch.error=沒有符合分支。
merge.operation.already.up.to.date=已處於最新狀態
merge.operation.branch.merged.with.conflicts={0} 已合併，但存在衝突
merge.operation.could.not.merge.branch=無法合併 {0}
merge.operation.delete.branch=刪除 {0}
merge.operation.error.during.rollback=復原期間出錯
merge.operation.however.merge.has.succeeded.for.the.following.repositories=不過，以下{0,choice,1#版本庫|2#版本庫}的合併已成功:
merge.operation.merged.to=已將 {0} 合併到 {1}
merge.operation.name=合併
merge.operation.you.may.rollback.not.to.let.branches.diverge=您可以復原(重設為合併之前的提交)以使分支不出現分叉。
merge.option.ff.only=僅在可以快進時合併
merge.option.msg=指定合併提交的訊息
merge.option.no.commit=不提交合併結果
merge.option.no.ff=即使可以快進也建立合併提交
merge.option.no.verify=繞過預合併和提交訊息掛鈎
merge.option.squash=為所有合併更改建立一個提交
merge.options.modify=修改選項
merge.options.modify.popup.title=新增合併選項
merge.progress.indicator.loading.unmerged.files.title=正在載入未合併的檔案…
merge.tool.column.status.deleted=已刪除
merge.tool.column.status.modified=已修改
merge.tool.column.theirs.status=他人的更改
merge.tool.column.theirs.with.branch.status=他人的更改({0})
merge.tool.column.yours.status=您的更改
merge.tool.column.yours.with.branch.status=您的更改({0})
merge.unresolved.conflicts.remaining.notification.body=有掛起的未解決的衝突。
merge.unresolved.conflicts.remaining.notification.title=正在掛起未解決的衝突
merge.update.project.conflict.merge.description.label=檢測到合併衝突。請先解決這些衝突，然後再繼續更新。
merge.update.project.generic.error.title=無法完成更新
merging.title=將更改合併到 {0}
message.unresolved.conflicts.prevent.commit=由於有未解決的衝突，無法提交更改。
new.branch.dialog.branch.name=新分支名稱:
new.branch.dialog.checkout.branch.checkbox=簽出分支(&C)
new.branch.dialog.error.branch.already.exists=分支名稱 {0} 已存在
new.branch.dialog.error.branch.clashes.with.directory=分支名稱 {0} 與同名的本地分支目錄衝突
new.branch.dialog.error.branch.clashes.with.remote=分支名稱 {0} 與同名的遠端分支衝突
new.branch.dialog.error.branch.name.empty=指定新分支的名稱
new.branch.dialog.error.branch.name.head=HEAD 是保留關鍵字
new.branch.dialog.error.branch.name.invalid=分支名稱 {0} 無效
new.branch.dialog.operation.checkout.description=簽出現有分支，並在其他版本庫中建立新分支
new.branch.dialog.operation.checkout.name=簽出
new.branch.dialog.operation.create.description=在其他版本庫中建立新分支
new.branch.dialog.operation.create.name=建立
new.branch.dialog.operation.rename.name=重新命名
new.branch.dialog.overwrite.existing.branch.checkbox=覆蓋現有分支(&R)
new.branch.dialog.overwrite.existing.branch.warning=更改名稱或覆蓋現有分支
new.branch.dialog.set.tracking.branch.checkbox=設定追蹤分支(&T)
no.revisions.available=無修訂
notification.content.branch.in.repo.has.no.tracked.branch={0} {1} 沒有追蹤的分支
notification.content.couldn.t.authorize=授權錯誤
notification.content.couldnt.collect.updated.files.info={0} 更新成功，但由於發生了一個錯誤，無法收集更新的更改
notification.content.detached.state.in.root.checkout.branch=您處於“游離的 HEAD”狀態，這表明您不在任何分支 {0} 上<br/>簽出分支以更新專案。
notification.content.fetch.cancelled.by.user=獲取已被使用者取消
notification.content.fetch.failed.couldn.t.authorize=獲取失敗: 授權錯誤
notification.content.fetched.successfully=已成功獲取
notification.content.untracked.files.prevent.operation.move.or.commit=在 {0} 前移動或提交<br/>{1}
notification.content.updating.root.failed.with.error=更新 {0} 失敗，出現錯誤: {1}
notification.ignore.file.generation.error.text.files.progress.title=無法生成 .gitignore 檔案
notification.title.can.t.update.no.current.branch=無法更新: 無當前分支
notification.title.couldn.t.reset.merge=無法中止合併動作
notification.title.couldnt.collect.updated.files.info=無法收集已更新檔案的資訊
notification.title.error.merging=合併錯誤
notification.title.error.updating.root=更新 {0} 期間出錯
notification.title.fetch.details=獲取詳細資訊
notification.title.fetch.failed=獲取失敗
notification.title.fetch.failure=獲取失敗
notification.title.fetch.success=獲取成功
notification.title.git.operation.failed=Git {0} 失敗
notification.title.unstash.failed=取消隱藏失敗
notification.title.unstash.failed.index.conflict=由於索引衝突，取消隱藏失敗
notification.title.untracked.files.prevent.operation=未追蹤的檔案會阻止{0}
notification.title.update.failed=更新失敗
open.in.browser.error=無法在瀏覽器中開啟
open.in.browser.getting.revision=正在獲取最新的檔案修訂
open.in.browser.getting.revision.error=無法檢索檔案的最新修訂
operation.action.message=多個 Git 根有未完成的 {0} 程序，請選擇要對其執行動作的根。
operation.name.loading.revision=載入修訂
operation.name.validating.revision.0=驗證修訂 {0}
paths.affected.title=提交 {0} 中受影響的路徑
post.commit.check.load.changes.error=無法為 {1} 載入根 {0} 中的更改
preserving.process.local.changes.not.restored.error.title=未還原本地更改
progress.checking.line.separator.issues=正在檢查行分隔符問題…
progress.checking.user.name.email=正在檢查 Git 用戶名…
progress.details.refreshing.files.for.root=正在重新整理根 {0} 的檔案
progress.finishing.conflict.resolve=正在解決衝突
progress.setting.config.value=正在更新 Git 組態…
progress.setting.user.name.email=正在設定 Git 用戶名…
progress.text.merging.repository=正在合併 {0}…
progress.title.creating.git.repository=正在建立 Git 版本庫…
progress.title.enabling.git=正在啟用 Git…
progress.title.moving.files=正在移動檔案…
progress.title.reverting.n.commits=正在還原{0,choice,1#提交|2#提交}
progress.title.update=更新
progress.title.validating.revision=正在驗證修訂…
progress.update.destination.remote=遠端
pull.action.name=拉取
pull.branch.field.placeholder=指定分支
pull.branch.no.matching.remotes=無遠端
pull.branch.not.selected.error=應選擇要從中拉取的分支。
pull.branch.nothing.to.pull=無分支
pull.button=拉取
pull.dialog.fetch.shortcuts.hint=按 {0} 更新分支
pull.dialog.title=拉取
pull.dialog.with.branch.title=拉取到 {0}
pull.fetch.failed.notification.text=選擇一個本地版本庫和一個遠端版本庫
pull.fetch.failed.notification.title=無法載入遠端分支
pull.option.ff.only=僅在可以快進時合併
pull.option.no.commit=合併，但不提交結果
pull.option.no.ff=即使可以快進也建立合併提交
pull.option.rebase=在當前分支的頂部重定基底傳入更改
pull.option.squash.commit=為所有拉取更改建立一個提交
pull.options.modify.popup.title=新增拉取選項
pull.remote.not.selected=選擇要從中拉取的遠端版本庫
pull.repository.not.selected.error=選擇一個版本庫
pulling.title=從 {0} 中拉取更改
push.dialog.preview.commits.before.push=對於向不受保護分支的提交和推送，應在推送之前預覽提交
push.dialog.push.tags=推送標記(&T)
push.dialog.push.tags.combo.all=所有
push.dialog.push.tags.combo.current.branch=當前分支
push.dialog.target.panel.add.remote=新增遠端
push.dialog.target.panel.adding.remote=正在新增遠端…
push.dialog.target.panel.can.t.push=無法推送
push.dialog.target.panel.couldnt.add.remote=無法新增遠端: {0}
push.dialog.target.panel.define.remote=定義遠端
push.dialog.target.panel.empty.repository=空版本庫
push.dialog.target.panel.new=新增
push.failed.error.message=推送失敗: {0}
push.local.history.system.label.after=推送後
push.local.history.system.label.before=推送前
push.notification.description.force.pushed=強制推送 {0} 到 {1}
push.notification.description.new.branch=已推送 {0} 到新分支 {1}
push.notification.description.new.branch.with.many.tags=推送 {0} 到新分支 {1}，並將 {2} 標籤到 {3}
push.notification.description.new.branch.with.single.tag=推送 {0} 到新分支 {1}，並將 {2} 標籤到 {3}
push.notification.description.push.with.lease.rejected=使用 Force-with-lease 推送 {0} 到 {1} 被拒
push.notification.description.pushed=已將 {0} 個{0,choice,1#提交|2#提交} 推送到 {1}
push.notification.description.pushed.many.tags=已推送 {0} 標籤到 {1}
push.notification.description.pushed.single.tag=已推送標籤 {0} 到 {1}
push.notification.description.pushed.with.many.tags=已將 {0} 個{0,choice,1#提交|2#提交} 推送到 {1}，將 {2} 標籤推送到 {3}
push.notification.description.pushed.with.single.tag=已將 {0} 個{0,choice,1#提交|2#提交} 推送到 {1}，將標籤 {2} 推送到 {3}
push.notification.description.rejected=推送到 {0} 被拒
push.notification.description.rejected.and.cancelled=推送被拒，更新被取消
push.notification.description.rejected.and.conflicts=由於更新期間發生衝突，推送被取消。<br/>檢查是否已正確解決衝突，然後再次呼叫推送。
push.notification.description.rejected.and.failed=因發生錯誤，推送被拒，更新失敗
push.notification.description.rejected.and.incomplete=由於更新過程中並未解決所有衝突，推送被取消。<br/>請解決衝突並再次呼叫推送
push.notification.description.rejected.by.remote=推送 {0} 到 {1} 被遠端拒絕
push.notification.description.up.to.date=所有內容都已處於最新狀態
push.notification.force.push.anyway.action=仍然強制推送
push.notification.force.push.progress.title.pushing=正在推送…
push.notification.force.with.lease.help=何為 Force-with-Lease?
push.notification.force.with.lease.help.description.first=Force-with-lease 推送阻止覆寫尚未獲取到本地版本庫的遠端更改
push.notification.force.with.lease.help.description.second=獲取最新更改，以確認能否安全捨棄更改並重複執行推送動作
push.notification.partially.failed.title=推送部分失敗
push.notification.partially.rejected.title=推送部分被拒
push.notification.push.failed.title=推送失敗
push.notification.rejected.title=推送被拒
push.notification.single.repo.success.description=推送動作期間收到 {0} 個{0, choice,1#提交|2#提交}
push.notification.successful.title=推送成功
push.notification.update.action=更新
push.notification.view.files.action=檢視在推送期間更新的檔案
push.notification.view.filtered.commits.actions=檢視與篩選器符合的 {0} 個{0,choice,1#提交|2#提交}
push.notification.view.received.commits.action=檢視收到的{0,choice,1#提交|2#提交}
push.rejected.dialog.title=推送被拒
push.rejected.many.repos=當前分支的推送被拒:
push.rejected.many.repos.item={1} 中的 {0}
push.rejected.many.repos.single.branch=當前分支“{0}”的推送被拒。
push.rejected.merge=合併(&M)
push.rejected.merge.needed=推送前需要合併遠端更改。
push.rejected.merge.needed.with.problem=在推送前，必須先合併遠端更改。<br/><br/>在這種情況下，強烈建議進行<b>合併</b>，因為存在未推送的合併提交。\\n<br/>進行重定基底可能導致問題。
push.rejected.only.one.git.repo=當前分支“{0}”的推送被拒。
push.rejected.rebase=重定基底(&R)
push.rejected.rebase.anyway=仍然重定基底
push.rejected.remember.checkbox=請記住更新方法，並在日後進行無提示更新(&S)。稍後可以在“{0} | 版本控制”中進行更改。<br/>
push.rejected.specific.repo=版本庫“{1}”中的當前分支“{0}”推送被拒。
push.up.to.commit.allowed.progress.title=正在檢查是否允許推送到選定的提交…
push.up.to.commit.getting.reference.progress.title=正在獲取對 HEAD 的提交參照…
push.upto.here.failed.dialog.title=無法啟動推送
push.upto.here.not.supported.notification.message=“推送此前所有提交”僅支援包含在本地分支中的提交
push.upto.here.not.supported.notification.title=無法啟動推送
rebase.abort.and.rollback.dialog.message=僅中止 {0} 中的重定基底還是同時復原 {1} 中的重定基底?
rebase.abort.and.rollback.dialog.no.button.text=僅中止
rebase.abort.and.rollback.dialog.yes.button.text=中止並復原
rebase.abort.dialog.message=中止{0} 中的重定基底?
rebase.abort.dialog.ok.button.text=中止
rebase.abort.dialog.title=中止重定基底
rebase.abort.notification.failed.title=中止重定基底失敗
rebase.abort.notification.successful.message=中止重定基底成功
rebase.abort.notification.warning.rollback.failed.message={0}中的復原失敗:{1}{2}
rebase.abort.notification.warning.rollback.failed.title=重定基底復原失敗
rebase.abort.notification.warning.rollback.failed.with.repo.message=成功中止 {0} 中的重定基底，但 {1}:{2}{3} 中的復原失敗
rebase.abort.progress.indicator.command.in.repo.title={0} ({1} 內)
rebase.abort.rollback.successful.rebase.dialog.message=是否要復原 {0} 中成功的重定基底?
rebase.abort.rollback.successful.rebase.dialog.ok.button.text=復原
rebase.confirmation.dialog.published.commits.button.cancel.text=取消
rebase.confirmation.dialog.published.commits.button.rebase.text=仍然重定基底
rebase.confirmation.dialog.published.commits.message.first=您正在嘗試重定基底一些已推送到受保護分支的提交。
rebase.confirmation.dialog.published.commits.message.second=對這些提交進行重定基底將使提交重複，這是不推薦的，而且很可能是不需要的。
rebase.confirmation.dialog.published.commits.title=重定基底已發佈的提交
rebase.conflict.diff.dialog.left.title=正在從 {1} 重定基底 {0}
rebase.conflict.diff.dialog.right.simple.title=已重定基底的提交
rebase.conflict.diff.dialog.right.with.branch.title=已重定基底的提交和來自 {0} 的提交
rebase.couldnt.resolve.file=無法解決 {0}
rebase.dialog.branch.field=源分支
rebase.dialog.error.base.not.selected=選擇新基
rebase.dialog.error.branch.invalid=分支 ''{0}'' 不存在
rebase.dialog.error.branch.not.selected=選擇要切換到的分支
rebase.dialog.error.branch.or.tag.not.exist=沒有這樣的分支或標記
rebase.dialog.error.rebase.in.progress=此 Git 根目錄已經在進行互動重定基底
rebase.dialog.error.upstream.not.selected=選擇上游
rebase.dialog.help=顯示 Git 重定基底幫助
rebase.dialog.new.base=新基礎(分支或雜湊)
rebase.dialog.old.base=原基礎(分支或雜湊)
rebase.dialog.progress.loading.tags=正在載入標記…
rebase.dialog.root.invalid.label.text=(無效)
rebase.dialog.start.rebase=重定基底
rebase.dialog.target=分支或雜湊
rebase.dialog.title=重定基底
rebase.entry.action.name.drop=刪除
rebase.entry.action.name.edit=編輯
rebase.entry.action.name.fixup=Fixup
rebase.entry.action.name.pick=選取
rebase.entry.action.name.reword=改寫
rebase.entry.action.name.squash=壓縮
rebase.entry.action.name.unknown=未知
rebase.git.operation.name=重定基底
rebase.help.link=git-scm.com 上的 git 重定基底
rebase.help.popup.ad.text=按空格開啟外部連結
rebase.help.rebase.branch=將基於一個分支的分支重定基底到另一個分支:
rebase.interactive.dialog.discard.modifications.cancel=取消重定基底
rebase.interactive.dialog.discard.modifications.continue=繼續重定基底
rebase.interactive.dialog.discard.modifications.discard=捨棄
rebase.interactive.dialog.discard.modifications.message=捨棄更改並取消重定基底?
rebase.interactive.dialog.git.commands=Git 指令
rebase.interactive.dialog.git.commands.column.action=動作
rebase.interactive.dialog.git.commands.column.hash=雜湊
rebase.interactive.dialog.git.commands.column.subject=主題
rebase.interactive.dialog.reset.link.text=重設
rebase.interactive.dialog.reword.hint.text=按 {0} 套用更改
rebase.interactive.dialog.start.rebase=啟動重定基底
rebase.interactive.dialog.stop.to.edit.text=停止以編輯
rebase.interactive.dialog.title=正在重定基底提交
rebase.interactive.dialog.view.git.commands.text=檢視 Git 指令
rebase.interactive.edit.commit.message.dialog.title=Git 提交訊息
rebase.interactive.edit.commit.message.ok.action.title=繼續重定基底
rebase.interactive.noop.dialog.text=由於當前分支直接位於基礎分支的正下方或它們指向同一個提交，因此沒有要重定基底的提交('noop' 情況)。\\n是否要繼續? (這會將當前分支重設為基礎分支)
rebase.interactive.noop.dialog.title=Git 重定基底
rebase.interactive.unstructured.editor.dialog.root.label=Git 根: {0}
rebase.log.action.loading.commit.message.failed.message=無法載入{0,choice,1#提交|2#提交}的更改
rebase.log.action.operation.rebase.name=重定基底
rebase.log.action.operation.reword.name=改寫
rebase.log.action.progress.indicator.loading.commit.message.title=正在載入{0,choice,1#提交|2#提交}詳細資訊…
rebase.log.commit.editing.action.commit.not.in.head.error.text=該提交不在當前分支中
rebase.log.commit.editing.action.commit.pushed.to.protected.branch.error.text=該提交已被推送到受保護分支 ''{0}''
rebase.log.commit.editing.action.disabled.parents.description=所選提交已{0}父項
rebase.log.commit.editing.action.progress.containing.branches.title=正在搜尋包含所選提交的分支…
rebase.log.commit.editing.action.prohibit.state=不能{0}
rebase.log.commit.editing.action.prohibit.state.grafting=優選期間不能{0}
rebase.log.commit.editing.action.prohibit.state.merging=合併期間不能{0}
rebase.log.commit.editing.action.prohibit.state.rebasing=重定基底期間不能{0}
rebase.log.commit.editing.action.prohibit.state.reverting=還原期間不能{0}
rebase.log.create.fixup.commit.action.failure.title=無法建立 Fixup 提交
rebase.log.create.squash.commit.action.failure.title=無法建立壓縮提交
rebase.log.drop.action.custom.text=刪除{0,choice,1#提交|2#提交}
rebase.log.drop.action.failure.title=無法刪除提交
rebase.log.drop.progress.indicator.title=正在刪除{0, choice, 1#提交|2#提交}…
rebase.log.drop.success.notification.title=已刪除{0, choice, 1#提交|2#提交}
rebase.log.drop.undo.failed.title=撤消刪除失敗
rebase.log.drop.undo.impossible.title=無法撤消刪除
rebase.log.drop.undo.progress.title=正在撤消刪除…
rebase.log.interactive.action.failure.title=無法啟動重定基底
rebase.log.multiple.commit.editing.action.cant.find.head=在包含選定{0,choice,1#提交|2#提交}的版本庫中找不到 HEAD 分支
rebase.log.multiple.commit.editing.action.disabled.external.repository.description=所選{0, choice, 1#提交|2#提交}{0, choice,1#|2#}來自外部版本庫
rebase.log.multiple.commit.editing.action.disabled.multiple.repository.description=所選{0, choice, 1#提交|2#提交}{0, choice,1#|2#}來自不同的版本庫
rebase.log.multiple.commit.editing.action.progress.indicator.action.possibility.check=正在檢查是否允許編輯所選提交…
rebase.log.multiple.commit.editing.action.specific.commit.not.in.head=提交 {0} 不在當前分支中
rebase.log.multiple.commit.editing.action.specific.commit.root.or.merge=提交 {0} 有 {1} 個父項
rebase.log.reword.action.failure.title=無法編輯提交訊息
rebase.log.reword.action.notification.successful.title=已更改提交訊息
rebase.log.reword.action.notification.undo.failed.title=撤消提交訊息編輯失敗
rebase.log.reword.action.notification.undo.not.allowed.repository.changed.message=版本庫已被更改
rebase.log.reword.action.notification.undo.not.allowed.title=無法撤消提交訊息編輯
rebase.log.reword.action.progress.indicator.title=正在改寫…
rebase.log.reword.action.progress.indicator.undo.title=正在撤消改寫…
rebase.log.reword.dialog.description.label=編輯由 {1} 執行的提交 {0} 的訊息
rebase.log.reword.dialog.failed.pushed.to.protected.message=無法編輯所選{0,choice,1#提交|2#提交}: 提交 {1} 已被推送到受保護的分支 ''{2}''
rebase.log.reword.dialog.failed.repository.changed.message=無法編輯所選{0,choice,1#提交|2#提交}: 版本庫狀態已更改
rebase.log.reword.dialog.title=編輯提交訊息
rebase.log.squash.action.failure.title=無法壓縮提交
rebase.log.squash.new.message.dialog.label=編輯已壓縮提交的訊息
rebase.log.squash.new.message.dialog.title=已壓縮提交訊息
rebase.log.squash.progress.indicator.title=正在壓縮…
rebase.log.squash.success.notification.title=提交已壓縮
rebase.log.squash.undo.failed.title=撤消壓縮失敗
rebase.log.squash.undo.impossible.title=無法撤消壓縮
rebase.log.squash.undo.progress.title=正在撤消壓縮…
rebase.log.undo.impossible.pushed.to.protected.branch.notification.text=來自當前分支的提交已被推送到受保護的分支 {0}
rebase.notification.action.abort.text=中止
rebase.notification.action.continue.text=繼續
rebase.notification.action.retry.text=重試
rebase.notification.action.view.shelf.text=檢視擱置…
rebase.notification.action.view.stash.text=檢視隱藏…
rebase.notification.all.conflicts.resolved.continue.rebase.action.text=繼續重定基底(&T)
rebase.notification.all.conflicts.resolved.text=所有衝突都已解決。是否要繼續重定基底?
rebase.notification.all.conflicts.resolved.title=解決衝突
rebase.notification.conflict.title=由於衝突，重定基底停止
rebase.notification.editing.title=重定基底已停止，可以進行編輯
rebase.notification.failed.continue.title=繼續重定基底失敗
rebase.notification.failed.rebase.title=重定基底失敗
rebase.notification.failed.shelf.text=無法擱置本地未提交的更改:
rebase.notification.failed.stash.text=無法隱藏本地未提交的更改:
rebase.notification.no.rebase.in.progress.abort.title=無法中止重定基底
rebase.notification.no.rebase.in.progress.continue.title=無法繼續重定基底
rebase.notification.no.rebase.in.progress.message=沒有正在進行的重定基底
rebase.notification.not.allowed.detached.message.first=您在 {0} 中處於游離的 HEAD 狀態。
rebase.notification.not.allowed.detached.message.second=無法重定基底。
rebase.notification.not.allowed.empty.repository.message=版本庫 {0} 為空。
rebase.notification.not.allowed.grafting.message.first={0} 中有一個未完成的優選程序。
rebase.notification.not.allowed.grafting.message.second=在開始重定基底前，應先完成這項動作。
rebase.notification.not.allowed.merging.message.first={0} 中有一個未完成的合併程序。
rebase.notification.not.allowed.merging.message.second=在開始重定基底前，應先完成合併。
rebase.notification.not.allowed.message=無法在 {0} 中進行重定基底。
rebase.notification.not.allowed.rebasing.message.first={0} 中有一個未完成的重定基底程序。
rebase.notification.not.allowed.rebasing.message.second=在開始另一個重定基底前，應先完成這項動作。
rebase.notification.not.allowed.reverting.message.first={0} 中有一個未完成的還原程序。
rebase.notification.not.allowed.reverting.message.second=在開始重定基底前，應先完成這項動作。
rebase.notification.not.allowed.title=不允許重定基底
rebase.notification.not.started.title=重定基底未啟動
rebase.notification.saved.local.changes.part.shelf.text=重定基底前已擱置本地更改。
rebase.notification.saved.local.changes.part.stash.text=重定基底前已隱藏本地更改。
rebase.notification.successful.rebased.checkout.message=已簽出{0,choice,0#|1# {1} }並將其重定基底{2,choice,0#|1#到 {3}}
rebase.notification.successful.rebased.message=已{0,choice,0#|1#將 {1} }重定基底{2,choice,0#|1#到 {3}}
rebase.notification.successful.title=重定基底成功
rebase.operation.name=重定基底
rebase.option.interactive=在重定基底之前編輯提交
rebase.option.keep.empty=重定基底期間不移除空提交
rebase.option.onto=為重定基底的提交指定新基
rebase.option.rebase.merges=重新建立提交拓撲
rebase.option.root=重定基底分支中的所有提交
rebase.option.switch.to.branch=選擇另一個要重定基底的分支
rebase.options.modify.dialog.title=新增重定基底選項
rebase.progress.indicator.aborting.title=正在中止重定基底程序…
rebase.progress.indicator.conflicts.collecting.title=正在收集要解決的衝突…
rebase.progress.indicator.continue.title=正在繼續重定基底程序…
rebase.progress.indicator.preparing.title=正在準備重定基底…
rebase.progress.indicator.retry.title=正在重試重定基底程序…
rebase.progress.indicator.title=正在重定基底…
rebase.simple.editor.dialog.title=Git 編輯器
rebase.update.project.abort.task.title=正在中止重定基底…
rebase.update.project.conflict.error.notification.description=然後，您可以<b>繼續重定基底</b>。<br/>您也可以<b>中止重定基底</b>以還原原始分支並停止重定基底。
rebase.update.project.conflict.error.notification.title=無法繼續重定基底
rebase.update.project.conflict.merge.description.label=檢測到合併衝突。請先解決這些衝突，然後再繼續重定基底。
rebase.update.project.notification.abort.cancel.message=已取消中止重定基底
rebase.update.project.notification.abort.error.message=中止重定基底時出錯
rebase.update.project.notification.abort.success.message=已中止重定基底
rebase.update.project.notification.failed.message=無法繼續重定基底。{0}
rebase.update.project.notification.failed.title=重定基底錯誤
rebase.using.log.couldnt.start.error=由於 IDE 生成的 'git-rebase-todo' 檔案無效，因此無法執行重定基底。是否要使用 Git 原生檔案生成來重試重定基底?
rebasing.merge.commits.button.cancel=取消
rebasing.merge.commits.button.merge=合併
rebasing.merge.commits.button.rebase=重定基底
reference.validating.progress.indicator.title=正在驗證修訂…
remote.dialog.add.remote=新增遠端
remotes.changing.remote.error.message=無法將遠端 {0} 更改為 {1} ''{2}''
remotes.changing.remote.error.title=更改遠端
remotes.changing.remote.progress=正在更改遠端…
remotes.define.duplicate.remote.name.validation.message=遠端名稱 ''{0}'' 已被使用
remotes.define.empty.remote.name.validation.message=遠端名稱不能為空
remotes.define.empty.remote.url.validation.message=遠端 URL 不能為空
remotes.define.invalid.remote.name.validation.message=遠端名稱包含非法字元
remotes.define.remote=定義遠端
remotes.define.remote.name=名稱:
remotes.define.remote.url=URL:
remotes.dialog.adding.remote=正在新增遠端…
remotes.dialog.cannot.add.remote.error.message=無法新增遠端 {0} ''{1}''
remotes.dialog.remove.remote.message=移除{0,choice,1#遠端|2#遠端}{1}?
remotes.dialog.remove.remote.title=移除{0,choice,1#遠端|2#遠端}
remotes.dialog.removing.remote.error.message=無法移除{0, choice, 1#遠端|2#遠端} {1}
remotes.dialog.removing.remote.error.title=移除{0,choice,1#遠端|2#遠端}
remotes.dialog.removing.remote.progress=正在移除{0,choice,1#遠端|2#遠端}…
remotes.dialog.title=Git 遠端
remotes.operation.error.message=在 {1} 中{0}:\\n{2}
remotes.operation.not.executed.message=動作未執行
remotes.remote.column.name=名稱
remotes.remote.column.url=URL
remove.removing=正在移除檔案…
rename.branch.operation.name=重新命名
repositories=版本庫
repository.action.missing.roots.misconfigured=組態的 Git 根都不在 Git 下。組態的目錄中必須包含“.git”目錄。
repository.action.missing.roots.title=沒有 Git 根
repository.action.missing.roots.unconfigured.message=沒有為專案組態 Git 根。
repository.not.found.error=找不到 {0} 的已組態 git 版本庫
reset.action.name=重設 Head…
reset.commit.invalid=指定的提交表達式未通過驗證。
reset.commit.label=為提交(&C):
reset.commit.tooltip=由於重設動作而將成為當前 HEAD 的提交。
reset.title=重設 Head
reset.type=重設類型(&T):
reset.type.tooltip=<html>重設類型(另請參閱 <code>git reset</code> man 頁面):<ul><li><b>Mixed</b> 將重設索引，但不會重設工作樹</li><li><b>Soft</b> 將保留索引和工作樹，只是移動 HEAD 指針</li><li><b>Hard</b> 將重設索引和工作樹。<em>工作樹中的更改會丟失</em></li></ul></html>
reset.validate=驗證(&V)
resetting.title=正在重設 HEAD…
restore.conflict.dialog.description.label.text=在 {0} 之前儲存的未提交更改與 {1} 中的檔案衝突
restore.conflict.diff.dialog.left.shelf.title=擱置中的未提交更改
restore.conflict.diff.dialog.left.stash.title=隱藏中的未提交更改
restore.conflict.diff.dialog.right.title=來自 {0} 的更改
restore.notification.failed.shelf.message=在更新之前，未提交的更改已儲存到<a href='saver'>擱置</a>。<br/>更新未完成，您的工作樹中有未解決的合併<br/>請解決衝突，完成更新並手動還原更改。
restore.notification.failed.stash.message=在更新之前，未提交的更改已儲存到<a href='saver'>隱藏</a>。<br/>更新未完成，您的工作樹中有未解決的合併<br/>請解決衝突，完成更新並手動還原更改。
restore.notification.failed.title=未還原本地更改
revert.operation.applied=還原
revert.operation.name=還原
revision.load.contents=載入修訂內容
revision.number.cannot.parse.output=無法解析輸出: [{0}]
save.load.conflict.dialog.diff.left.title=您未提交的更改
save.load.conflict.dialog.diff.right.title=遠端更改
save.notification.failed.shelf.text=試圖在 {0} 之前在擱置中儲存未提交的更改，但失敗並出現錯誤。<br/>{1}
save.notification.failed.stash.text=試圖在{0}之前在隱藏中儲存未提交的更改，但失敗並出現錯誤。<br/>{1}
save.notification.failed.title=無法儲存未提交的更改
search.everywhere.group.full.name=Git 參照
search.everywhere.group.name=Git
search.everywhere.items.commit.by.hash=提交(按雜湊)
search.everywhere.items.commit.by.message=提交(按訊息)
search.everywhere.items.local.branch=本地分支
search.everywhere.items.remote.branch=遠端分支
search.everywhere.items.tag=標記
separator.show=顯示
settings.add.suffix=在挑選推送到受保護分支的提交時，新增 'cherry-picked from <hash>' 後綴
settings.auto.update.on.push.rejected=如果當前分支的推送被拒，則自動更新
settings.clean.working.tree=使用以下方法清理工作樹:
settings.commit.group.title=提交
settings.configure.sign.gpg.do.not.sign.table.text=不簽署
settings.configure.sign.gpg.error.no.available.keys.found.text=找不到適用的私鑰
settings.configure.sign.gpg.error.table.text=錯誤: {0}
settings.configure.sign.gpg.for.repo.dialog.title=組態 GPG 密鑰 {0}
settings.configure.sign.gpg.for.repos.dialog.title=組態 GPG 密鑰
settings.configure.sign.gpg.gpg.kep.table.column.name=GPG 密鑰
settings.configure.sign.gpg.loading.table.text=正在載入…
settings.configure.sign.gpg.root.table.column.name=根
settings.configure.sign.gpg.synced.with.gitconfig.text=與 gitconfig 同步
settings.configure.sign.gpg.with.key.checkbox.text=使用 GPG 密鑰簽署提交:
settings.credential.helper=使用憑證幫助程序
settings.crlf=如果即將提交 CRLF 行分隔符，則發出警告
settings.detached.head=在游離的 HEAD 中或重定基底期間提交時發出警告
settings.enable.staging.area=啟用暫存區域
settings.enable.staging.area.comment=這將停用更改列表支援。僅適用於非強制回應提交介面。
settings.explicitly.check=顯式檢查遠端分支上的傳入提交:
settings.explicitly.check.condition.comment=需要在進階設定中啟用 ''{0}'' 選項
settings.filter.update.info=按路徑過濾“更新專案”資訊:
settings.git.incoming.change.strategy.text.always=始終
settings.git.incoming.change.strategy.text.auto=自動
settings.git.incoming.change.strategy.text.never=從不
settings.git.option.group=Git
settings.git.update.method.branch.default=分支預設
settings.git.update.method.merge=合併
settings.git.update.method.merge.description=將傳入更改合併到當前分支
settings.git.update.method.rebase=重定基底
settings.git.update.method.rebase.description=在傳入更改上重定基底當前分支
settings.label.sign.gpg.commits.enabled.different.keys.text=提交使用不同的 GPG 密鑰簽署
settings.label.sign.gpg.commits.enabled.n.roots.of.m.text=提交使用 {1} 的 {0} 個{0,choice,1#根|2#根}中的 GPG 密鑰簽署
settings.label.sign.gpg.commits.enabled.text=提交使用 GPG 密鑰簽署: {0}
settings.label.sign.gpg.commits.no.roots.text=專案中沒有 Git 根
settings.label.sign.gpg.commits.not.configured.text=未組態使用 GPG 密鑰簽署提交
settings.protected.branched=受保護分支:
settings.push.dialog=顯示提交和推送的推送對話框
settings.push.dialog.for.protected.branches=僅在提交到受保護分支時顯示推送對話框
settings.push.group.title=推送
settings.sign.gpg.configure.link.text=組態 GPG 密鑰…
settings.synchronize.branch.protection.rules=從 GitHub 載入分支保護規則
settings.synchronize.branch.protection.rules.description=將 GitHub 規則新增到本地規則中，並在每次獲取時進行同步
settings.update.group.title=更新
settings.update.method=更新方法:
show.diff.between.dialog.could.not.load.diff.with.branch.error=無法載入與 {0} 的差異: {1}
show.diff.between.dialog.no.differences.empty.text=無差異
show.diff.between.dialog.title={0}與當前工作樹之間的更改
smart.operation.dialog.don.t.operation.name=不{0}
smart.operation.dialog.git.operation.name.problem=Git {0} 問題
smart.operation.dialog.north.panel.label.shelf.text=<html>您對以下檔案的本地更改將被{0}覆蓋。<br/>{1}可以擱置這些更改，{0}，並在之後取消擱置。</html>
smart.operation.dialog.north.panel.label.stash.text=<html>您對以下檔案的本地更改將被{0}覆蓋。<br/>{1} 可以隱藏這些更改，{0}，並在之後取消隱藏。</html>
smart.operation.dialog.ok.action.shelf.description=擱置本地更改，{0}，取消擱置
smart.operation.dialog.ok.action.stash.description=隱藏本地更改，{0}，取消隱藏
smart.operation.dialog.operation.name.and.overwrite.local.changes={0}並覆蓋本地更改
smart.operation.dialog.smart.operation.name=智能{0}
stage.add.action.text=暫存
stage.add.error.title=無法暫存檔案
stage.add.no.content.action.text=無內容的暫存
stage.add.process=正在暫存檔案…
stage.add.range.command.name=暫存更改
stage.commit.all.amend.all.text=全部修正
stage.commit.all.amend.anyway.text=仍然全部修正
stage.commit.all.text=全部提交(&I)
stage.commit.failed=無法提交 {0}
stage.commit.process=正在提交暫存更改…
stage.commit.successful=已提交 {0}: {1}
stage.content.local=本地
stage.content.staged=已暫存
stage.diff.local.content.exception.message=無法獲取本地檔案: ''{0}''
stage.diff.staged.content.exception.message=無法獲取暫存內容: ''{0}''
stage.loading.status=正在載入更改…
stage.reset.action.text=取消暫存
stage.reset.error.title=無法取消暫存檔案
stage.reset.process=正在取消暫存檔案…
stage.revert.action.text=復原
stage.revert.error.title=無法復原檔案
stage.revert.process=正在復原檔案…
stage.revert.staged.range.command.name=復原暫存的更改
stage.revert.unstaged.range.command.name=復原未暫存的更改
stage.tree.node.ignored=已忽略
stage.tree.node.staged=已暫存
stage.tree.node.unmerged=已取消合併
stage.tree.node.unstaged=未暫存
stage.tree.node.untracked=已取消追蹤
stage.vfs.editor.notification.link=開啟本地版本
stage.vfs.editor.notification.text=這是暫存版本的 ''{0}''
stage.vfs.editor.tab.tooltip=''{0}'' 的暫存版本
stage.vfs.presentable.file.name=已暫存: {0}
stage.vfs.read.process=正在從 Git 索引讀取 {0}
stage.vfs.shutdown.process=正在關閉 Git 索引 VFS
stage.vfs.write.process=正在將 {0} 寫入 Git 索引
stash.action.name=隱藏
stash.button=建立隱藏
stash.editor.diff.preview.empty.title=隱藏
stash.editor.diff.preview.id.change.title={0}: {1}
stash.empty.text.help.link=隱藏和擱置入門
stash.error=無法隱藏 {0}
stash.error.can.not.stash.changes.now=現在無法隱藏更改
stash.keep.index=保留索引(&I)
stash.keep.index.tooltip=如果選中此複選框，已建立索引的更改將保留在索引中。
stash.load.changes.error=無法在解析為 {1} 的隱藏中載入根 {0} 中的更改
stash.message=訊息(&M):
stash.message.tooltip=在此處輸入隱藏訊息。
stash.progress.indicator.title=正在隱藏來自 ''{0}'' 的更改…
stash.root.node.title=隱藏
stash.tab.name=隱藏和擱置
stash.title=隱藏
stash.unstash.changes.current.branch.label=當前分支:
stash.unstash.changes.in.root.dialog.title=取消隱藏 {0} 中的更改
stash.unstash.conflict.dialog.description.label.text=更新前隱藏的未提交更改與更新後的檔案衝突。
stash.unstash.progress.indicator.title=正在消除對 ''{0}'' 的更改…
stash.unstash.unresolved.conflict.warning.notification.message=您的未提交更改已儲存到<a href='saver'>隱藏</a>。<br/>取消隱藏未完成，您的工作樹中有未解決的合併<br/>請<a href='resolve'>解決</a>衝突並刪除隱藏。
stash.unstash.unresolved.conflict.warning.notification.title=本地更改已還原，但存在衝突
stashing.progress.title=正在隱藏更改…
stashing.title=正在隱藏更改…
status.exception.message.format.message.xstatus.ystatus.line.output={0} xStatus=[{1}]，yStatus=[{2}]，行=[{3}]\\n輸出:\\n{4}
status.exception.message.line.is.too.short=此行過短
status.exception.message.missing.path=缺少初始路徑
status.exception.message.unexpected=意外的狀態符號
status.exception.message.unexpected.status=意外的狀態符號: ''{0}''
status.exception.message.unexpected.xstatus.ystatus=意外的狀態符號: ''{0}{1}''
tab.title.conflicts=衝突
tab.title.repo.root.name.at.revision={1} 的 {0}
tag.action.name=標記
tag.button=建立標籤
tag.commit.label=提交(&C)
tag.commit.tooltip=輸入要標記的提交或物件的名稱，或留空以使用 HEAD。
tag.error.creating.message.file.message=無法建立訊息檔案: {0}
tag.error.invalid.commit=該提交或物件名稱無效。
tag.error.tag.exists=存在同名的標記。
tag.force=強制(&F)
tag.force.tooltip=強制建立標記，即使已存在另一個具有此名稱的標記。
tag.getting.existing.tags=正在獲取現有標記…
tag.message.label=訊息(&M):
tag.message.tooltip=如果訊息不為空，則建立帶註解的標記。
tag.name.label=標記名稱(&N):
tag.name.tooltip=在此處輸入新的標記名稱。
tag.progress.title=正在新增標記…
tag.title=標記
tag.validate=驗證(&V)
tag.validate.tooltip=點擊此按鈕驗證要標記的提交
text.crlf.fix.dialog.description.proposed.fix=如果選擇<b>修正並提交</b>，將執行 {0}。<br/>如果選擇<b>按原樣提交</b>，則不會更改組態值。
text.crlf.fix.dialog.description.warning=您即將把 CRLF 行分隔符提交到 Git 版本庫。<br/>建議將 {0} Git 特性設定為 {1}，以免發生行分隔符問題。
text.crlf.fix.notification.description.warning=您即將向 Git 版本庫提交 CRLF 行分隔符
title.changes.excluded.from.commit=已從合併提交中排除更改
title.crlf.fix.dialog=行分隔符警告
title.sudo.command.install.git=安裝 Git
title.unresolved.conflicts.pre.commit.check=未解決的衝突
title.user.name.email.not.specified=未定義 Git 用戶名
tooltip.run.git.hooks=如果未選中，將使用 '--no-verify' 參數跳過 Git hook
tracked.branch.fix.dialog.branch.placeholder=指定分支
tracked.branch.fix.dialog.not.on.branch.message=將跳過以下版本庫:
tracked.branch.fix.dialog.not.on.branch.title=游離的 HEAD 中的 Git 版本庫
tracked.branch.fix.dialog.ok.button.text=更新
tracked.branch.fix.dialog.set.as.tracked=設為追蹤分支
tracked.branch.fix.dialog.title=更新
unexpected.tree.entries.error=意外的樹條目: {0}
unexpected.tree.object.error=意外的樹物件: {0}
unstash.action.name=取消隱藏
unstash.branch.label=作為新分支(&B):
unstash.branch.tooltip=如果輸入非空名稱，該隱藏將作為新分支簽出。
unstash.button.apply=套用隱藏
unstash.button.branch=分支
unstash.button.pop=消除隱藏
unstash.clear=清除(&C)
unstash.clear.tooltip=刪除版本庫中的所有隱藏。
unstash.clearing.stashes=正在清除隱藏…
unstash.conflict.dialog.description.label.text=取消隱藏 {0} 時發生衝突
unstash.conflict.diff.dialog.left.title=本地更改
unstash.conflict.diff.dialog.right.title=來自隱藏的更改
unstash.dialog.remove.stash.progress.indicator.title=正在移除隱藏 {0}…
unstash.dialog.show.stashes.error.dialog.title=無法顯示隱藏列表
unstash.dialog.stash.list.load.progress.indicator.title=正在載入隱藏列表…
unstash.dialog.unresolved.conflict.warning.notification.message=取消隱藏未完成，您的工作樹中存在未解決的合併<br/>請<a href='resolve'>解決</a>衝突。
unstash.dialog.unresolved.conflict.warning.notification.title=取消隱藏期間未解決衝突
unstash.drop=刪除(&D)
unstash.drop.tooltip=刪除所選隱藏
unstash.error.can.not.unstash.changes.now=現在無法取消隱藏更改
unstash.operation.name=取消隱藏
unstash.pop.stash=消除隱藏(&P)
unstash.pop.stash.tooltip=如果選中，則該隱藏在套用後會被刪除。
unstash.reinstate.index=復原索引(&I)
unstash.reinstate.index.tooltip=嘗試復原索引以及工作樹更改。
unstash.stashes=隱藏(&S):
unstash.title=取消隱藏更改
unstash.unstashed.with.conflicts.error.title=已取消隱藏，但存在衝突
unstash.unstashing=正在取消隱藏…
unstash.view=檢視(&V)
unstash.view.dialog.title=受 {0} 影響的路徑
unstash.view.tooltip=檢視所選隱藏
update.checks.not.supported.git.2.9.required=不支持更新檢查。需要 Git 2.9 及以上版本
update.notification.choose.upstream.branch=選擇上游分支
update.notification.update.error=無法更新
update.options.display.name=Git 更新設定
update.process.error.additional.description.unfinished.rebase=然後，您可以<b>繼續重定基底</b>。<br/>您也可以<b>中止重定基底</b>以還原原始分支並停止重定基底。
update.process.error.description.unfinished.rebase=您有未完成的重定基底程序。必須先解決這些衝突，然後才能更新。
update.process.error.message.unfinished.merge=您有未完成的合併。必須先解決這些衝突，然後才能更新。
update.process.error.message.unmerged.files=檢測到未合併的檔案。必須先解決這些衝突，然後才能更新。
update.process.error.notification.title=無法設定上游分支
update.process.generic.error.title=無法更新
update.process.nothing.to.update=沒有要更新的內容
update.process.progress.title=正在更新…
update.skip.root.reason.detached.head=游離的 HEAD
update.skip.root.reason.no.tracked.branch=無追蹤分支
util.remote.renderer.none=無
validation.error.email.no.at=電子郵件地址必須包含 '@' 符號
validation.warning.set.name.email.for.git=您必須為 Git 指定用戶名和電子郵件
vcs.history.action.gitlog=在 Git 日誌中顯示
vcs.log.archiving.log.index.data=正在歸檔 Git 日誌索引資料…
vcs.log.create.archive.with.log.index.data=傾印 Git 日誌索引資料
vcs.log.status.bar.extracting.log.index.data=正在獲取 Git 日誌索引資料…
vcs.log.status.bar.replacing.log.index.data=正在取代 Git 日誌索引資料…
vcs.log.use.log.index.data=使用共享 Git 日誌索引資料
vfs.listener.add.single.prompt=是否要安排將以下檔案新增到 Git?\\n{0}\\n\\n如果您選擇“取消”，以後仍可以手動新增。
vfs.listener.add.single.title=將檔案新增到 Git
vfs.listener.add.title=將檔案新增到 Git
vfs.listener.checking.ignored=正在檢查忽略的檔案…
vfs.listener.delete.single.prompt=是否要從 Git 中刪除以下檔案?\\n{0}\\n\\n如果您選擇“取消”，以後仍可以手動刪除。
vfs.listener.delete.single.title=從 Git 中刪除檔案
vfs.listener.delete.title=從 Git 中刪除檔案
warning.message.commit.with.detached.head=以下路徑中的 Git 版本庫處於<b>游離的 HEAD</b> 狀態: <br/>{0}<br/>您可以進行檢查，嘗試做出更改並提交，但務必簽出分支，以免丟失您的工作。<br/>否則，可能會丟失所做的更改。
warning.message.commit.with.unfinished.rebase=以下路徑中的 Git 版本庫有一個<b>未完成的重定基底</b>程序: <br/> {0}<br/>您可能想<b>繼續重定基底</b>而不是提交。<br/>在重定基底期間提交可能會導致提交丟失。
warning.title.commit.with.detached.head=在游離的 HEAD 中提交
warning.title.commit.with.unfinished.rebase=未完成重定基底程序
warning.your.local.changes.would.be.overwritten.by.merge=您的本地更改將被合併覆蓋。\\n提交、存儲或還原您的更改以繼續。"
`;

exports[`dev messages/GithubBundle.properties 1`] = `
"account.choose.as.default=設定為當前專案的預設帳戶
account.choose.button=選擇
account.choose.for=選擇 GitHub 帳戶: {0}
account.choose.link=選擇帳戶
account.choose.not.selected=未選擇帳戶
account.choose.title=選擇 GitHub 帳戶
account.scopes.insufficient=安全作用域不足
account.token.missing=缺少存取令牌
account.token.missing.for=缺少 {0} 的存取令牌
accounts.add.button=新增帳戶
accounts.add.dropdown.link=新增帳戶
accounts.default.missing=缺少預設的 GitHub 帳戶
accounts.label.no.accounts=無帳戶
accounts.relogin=重新登入
action.Github.Accounts.AddGHAccount.text=通過 GitHub 登入…
action.Github.Accounts.AddGHAccountWithToken.text=通過令牌登入…
action.Github.Accounts.AddGHEAccount.text=登入 GitHub Enterprise…
action.Github.PullRequest.Copy.Link.text=複製拉取請求 URL
action.Github.PullRequest.Open.Link.text=在瀏覽器中開啟拉取請求
action.Github.Share.Vcs.Toolbar.Widget.text=GitHub…
action.comment.text=評論
button.login.mnemonic=登入(&L)
button.use.token=使用令牌…
cannot.configure.remote=無法組態 ''{0}'' 遠端:\\n{1}
cannot.create.gist=無法建立 Gist
cannot.display.item=無法顯示條目 - {0}
cannot.find.git.repo=找不到 Git 版本庫
cannot.get.last.revision=無法獲取最新修訂。
cannot.load.changes=無法載入更改
cannot.load.commits=無法載入提交
cannot.load.data=無法載入資料
cannot.load.data.from.github=無法從 GitHub 載入資料
cannot.load.details=無法載入詳細資訊
cannot.load.repo.info=無法載入版本庫資訊
cannot.open.in.browser=無法在瀏覽器中開啟
clone.button=克隆
clone.dialog.clone.failed=克隆失敗
clone.dialog.directory.field=目錄:
clone.dialog.text=克隆 ''{0}''
clone.error.load.repositories=無法載入版本庫
clone.error.unable.to.create.dest.dir=無法建立目標目錄
clone.error.unable.to.find.dest=找不到目標
create.gist.action.description=建立 GitHub gist
create.gist.action.title=建立 Gist…
create.gist.dialog.copy.url=複製 URL
create.gist.dialog.create.for.field=為以下帳戶建立:
create.gist.dialog.description.field=描述:
create.gist.dialog.filename.field=檔名:
create.gist.dialog.open.browser=在瀏覽器中開啟
create.gist.dialog.secret=私密
create.gist.dialog.title=建立 Gist
create.gist.error.binary.file=無法上傳二進制檔案: {0}
create.gist.error.content.read=無法讀取檔案 {0} 的內容
create.gist.error.empty=無法建立空 gist
create.gist.process=正在建立 gist…
create.gist.success=已成功建立 Gist
create.gist.url=您的 gist url
credentials.button.generate=生成…
credentials.incorrect=憑證不正確。\\n{0}
credentials.invalid.auth.data=身份驗證資料無效。\\n{0}
credentials.invalid.server.path=伺服器路徑無效
credentials.server.cannot.be.empty=伺服器不能為空
credentials.server.field=伺服器:
credentials.server.path.invalid=伺服器 URL 無效
credentials.token.field=令牌:
dialog.message.account.cannot.be.empty=帳戶不能為空
dialog.message.login.to.continue=登入到 GitHub 以繼續
dialog.title.add.github.account=新增 GitHub 帳戶
gql.error.in.field={1} 的“{2}”欄位中存在 {0} 錯誤
group.GitHub.Copy.Link.CopyReferencePopup.text=GitHub 版本庫 URL
group.GitHub.Copy.Link.text=將連結複製到 GitHub 版本庫
group.GitHub.MainMenu.text=GitHub
group.Github.Open.In.Browser.EditorTabPopup.text=GitHub
group.Github.PullRequest.Combined.Diff.Thread.View.Options.text=顯示審查討論
group.Github.PullRequest.Details.Commit.Tree.ViewOptions.text=檢視選項
group.Github.PullRequest.Diff.Thread.View.Options.text=顯示審查討論
issue.state.closed=已關閉
issue.state.open=開放
label.login.option.separator=或
label.login.progress=正在登入…
link.label.use.token=使用令牌…
login.account.already.added=已新增帳戶 ''{0}''
login.insufficient.scopes=必須為存取令牌授予以下作用域: {0}
login.to.github=登入 GitHub
login.to.github.enterprise=登入 GitHub Enterprise
login.to.github.enterprise.action=登入 GitHub Enterprise…
login.token.cannot.be.empty=令牌不能為空
login.via.github.action=通過 GitHub 登入…
login.with.token.action=通過令牌登入…
open.in.browser.link=在瀏覽器中開啟
open.on.github.action=在 GitHub 上開啟
open.on.github.action.description=在瀏覽器中開啟相應連結
progress.text.loading.protected.branches=正在載入 GitHub 分支保護規則
pull.request.adding.reviewers=正在新增審查者
pull.request.adjustment.failed=無法調整列表
pull.request.assignees=被指派者
pull.request.assignees.popup={0, choice, 1#被指派者|2#被指派者}
pull.request.back.to.list=返回列表
pull.request.branch.action.group.name=動作(&A)
pull.request.branch.checkout.remote.cannot.find=找不到遠端
pull.request.branch.checkout.resolve.author.failed=無法解析拉取請求作者
pull.request.branch.checkout.resolve.remote.failed=無法解析拉取請求遠端
pull.request.branch.checkout.task.indicator=正在簽出分支
pull.request.branch.checkout.task.title=從拉取請求簽出分支
pull.request.branch.out.of.sync=拉取請求分支與基礎分支不同步
pull.request.branch.update.action=更新本地分支…
pull.request.branch.update.action.description=更新拉取請求本地分支
pull.request.change.remote.or.account=更改版本庫或帳戶…
pull.request.checks={0, choice, 1#檢查|2#檢查}
pull.request.checks.failing={0} 個失敗
pull.request.checks.pending={0} 個掛起
pull.request.checks.successful={0} 個成功
pull.request.close.action=關閉拉取請求
pull.request.comment.hint={0} 以評論
pull.request.comment.save=儲存更改
pull.request.comment.save.hint={0}以儲存更改
pull.request.commit.does.not.contain.changes=提交不包含任何更改
pull.request.commits=提交
pull.request.conflicts.checking=正在檢查自動合併的能力…
pull.request.conflicts.merge.tooltip=拉取請求無法合併
pull.request.conflicts.must.be.resolved=分支具有必須解決的衝突
pull.request.conflicts.none=分支與基礎分支沒有衝突
pull.request.create.action=建立拉取請求
pull.request.create.already.exists=拉取請求已存在
pull.request.create.already.exists.view=檢視
pull.request.create.description=描述
pull.request.create.discard.approve=刪除草稿
pull.request.create.discard.message=是否要刪除新拉取請求的草稿?
pull.request.create.discard.title=刪除拉取請求草稿
pull.request.create.draft.action=建立草稿拉取請求
pull.request.create.error=無法建立新的拉取請求:
pull.request.create.input.remote.branch.comment=必須推送更改才能建立拉取請求，並且本地分支 ''{0}'' 不會追蹤 ''{1}'' 處的遠端分支
pull.request.create.input.remote.branch.name=遠端分支名稱:
pull.request.create.input.remote.branch.title=拉取請求分支
pull.request.create.loading.template=正在載入模板…
pull.request.create.no.changes=''{0}'' 和 ''{1}'' 之間沒有更改
pull.request.create.process.title=正在建立拉取請求…
pull.request.create.select.branches=已選擇拉取請求的 base 和 head 來檢視更改
pull.request.create.show.form.action=建立拉取請求…
pull.request.create.title=標題
pull.request.details.adjusting.assignees=正在調整被指派者…
pull.request.details.adjusting.labels=正在調整標籤…
pull.request.details.adjusting.reviewers=正在調整審查者…
pull.request.diff.editor.add.multiline.comment=新增一條多行評論
pull.request.diff.editor.add.multiline.review.comment=添加多行審查評論
pull.request.diff.editor.add.review.comment=新增審查評論
pull.request.diff.editor.add.single.comment=新增一條評論
pull.request.diff.editor.review.comment=評論
pull.request.diff.editor.review.start=開始審查
pull.request.diff.editor.review.with.comment=以評論開始審查
pull.request.diff.editor.start.review.with.multiline.comment=以多行評論開始審查
pull.request.diff.editor.title=拉取請求 #{0,number,#} 的差異
pull.request.diff.view.options=檢視選項
pull.request.discard.pending.comments=捨棄待定評論
pull.request.discard.pending.comments.dialog.msg=確定要刪除所有待定評論嗎?
pull.request.discard.pending.comments.dialog.title=捨棄待定審查
pull.request.does.not.contain.changes=拉取請求不包含任何更改
pull.request.does.not.contain.commits=拉取請求不包含任何提交
pull.request.editor.timeline=拉取請求時間線
pull.request.existing.process.title=正在檢查是否已存在拉取請求…
pull.request.files=檔案
pull.request.info=資訊
pull.request.labels=標籤
pull.request.labels.popup={0, choice, 1#標籤|2#標籤}
pull.request.list.cannot.load=無法載入拉取請求
pull.request.list.error.authorization=使用者授權失敗
pull.request.list.filter.assignee=被指派者
pull.request.list.filter.author=作者
pull.request.list.filter.label=標籤
pull.request.list.filter.quick.assigned=已分配給您
pull.request.list.filter.quick.open=開啟
pull.request.list.filter.quick.review.requests=審查請求
pull.request.list.filter.quick.yours=您的拉取請求
pull.request.list.filter.review=審查
pull.request.list.filter.review.approved.full=批准的審查
pull.request.list.filter.review.approved.short=批准的審查
pull.request.list.filter.review.awaiting.full=正在等待您的審查
pull.request.list.filter.review.awaiting.short=正在等待審查
pull.request.list.filter.review.change.requested.full=請求的更改
pull.request.list.filter.review.change.requested.short=請求的更改
pull.request.list.filter.review.no.full=無審查
pull.request.list.filter.review.no.short=無審查
pull.request.list.filter.review.not.full=未由您審查
pull.request.list.filter.review.not.short=未審查
pull.request.list.filter.review.required.full=需要審查
pull.request.list.filter.review.required.short=需要審查
pull.request.list.filter.review.reviewed.full=由您審查
pull.request.list.filter.review.reviewed.short=已審查
pull.request.list.filter.state=狀態
pull.request.list.filter.state.closed=已關閉
pull.request.list.filter.state.merged=已合併
pull.request.list.filter.state.open=開放
pull.request.list.filters.clear=清除篩選器
pull.request.list.filters.reset.to.default=重設為{0}
pull.request.list.no.matches=沒有與篩選器符合的拉取請求。
pull.request.list.nothing.loaded={0} 中沒有拉取請求
pull.request.list.outdated=該列表已過時。
pull.request.list.refresh=重新整理
pull.request.loading.account.info=正在載入帳戶資訊
pull.request.loading.ghost=正在載入已刪除的使用者存根
pull.request.loading.repo.info=正在載入版本庫資訊
pull.request.loading.status=正在載入拉取請求狀態
pull.request.loading.user.teams.info=正在載入使用者團隊資訊
pull.request.mark.ready.for.review=標記為可供審查
pull.request.merge.commit.action=合併拉取請求…
pull.request.merge.disabled=此專案已停用合併
pull.request.merge.message.dialog.title=合併拉取請求
pull.request.merge.pull.request=合併拉取請求 #{0,number,#}
pull.request.merge.rebase.action=重定基底並合併
pull.request.merge.squash.action=壓縮並合併…
pull.request.new.diff.editor.title=新拉取請求的差異
pull.request.new.line.hint={0}以新增新行
pull.request.no.labels=無標籤
pull.request.no.reviewers=無審查者
pull.request.open.action=檢視拉取請求
pull.request.open.action.description=檢視拉取請求資訊和時間線
pull.request.post.action=發佈拉取請求
pull.request.refresh.changes.action=重新整理拉取請求更改
pull.request.refresh.comments.action=重新整理拉取請求評論
pull.request.refresh.details.action=重新整理拉取請求
pull.request.refresh.list.action=重新整理列表
pull.request.refresh.state.action=重新整理拉取請求狀態
pull.request.removing.reviewers=正在移除審查者
pull.request.reopen.action=重新開啟拉取請求
pull.request.repo.access.required=必須具有版本庫存取權限才能管理拉取請求
pull.request.repo.write.access.required=必須具有版本庫寫存取權限才能合併拉取請求
pull.request.review.actions.more.name=拉取請求動作
pull.request.review.actions.submit={0, choice, 0#提交審查…|1#提交審查({0})…}
pull.request.review.comment.empty.text=審查評論
pull.request.review.commented={0} 在 {1} 新增了評論
pull.request.review.not.supported.non.linear=非線性提交歷史記錄不支持按提交審查
pull.request.review.refresh.data.task=重新整理審查資料
pull.request.review.refresh.data.task.description=重新整理 GitHub 拉取請求審查資訊
pull.request.review.submit=提交…
pull.request.review.submit.action.description=提交拉取請求審查
pull.request.review.submit.approve.button=批准
pull.request.review.submit.comment.button=評論
pull.request.review.submit.comment.description=提交不需要明確批准的一般意見反應
pull.request.review.submit.error=提交審查時發生錯誤
pull.request.review.submit.request.changes=請求更改
pull.request.review.thread.outdated=過時
pull.request.review.thread.reply.hint={0} 以回復
pull.request.reviewers=審查者
pull.request.reviewers.popup={0, choice, 1#審查者|2#審查者}
pull.request.select.action=選擇開放的拉取請求
pull.request.select.commit.to.view.changes=選擇要檢視更改的提交
pull.request.state.cannot.load=無法載入狀態
pull.request.state.closed.long=拉取請求已關閉
pull.request.state.merged.long=拉取請求已合併
pull.request.timeline.approved.changes=批准了這些更改
pull.request.timeline.branch.deleted=刪除了 {0} 分支
pull.request.timeline.branch.force.pushed=強制推送了 {0} 分支
pull.request.timeline.branch.head.restored=還原了 head 分支
pull.request.timeline.cannot.load=無法載入時間線條目
pull.request.timeline.changed.base.branch=更改了基礎分支
pull.request.timeline.closed=關閉了此請求
pull.request.timeline.comment.suggested.changes=建議的更改
pull.request.timeline.comment.suggested.changes.action.commit.name=提交…
pull.request.timeline.comment.suggested.changes.button=區域套用
pull.request.timeline.comment.suggested.changes.progress.bar.apply=套用建議的更改
pull.request.timeline.comment.suggested.changes.progress.bar.commit=提交建議的更改
pull.request.timeline.comment.suggested.changes.tooltip.different.branch=無法在其他分支中套用來自拉取請求的建議更改
pull.request.timeline.comment.suggested.changes.tooltip.outdated=無法套用過時的建議
pull.request.timeline.comment.suggested.changes.tooltip.resolved=此建議已解決
pull.request.timeline.commented=新增了評論
pull.request.timeline.commit.added=已將提交新增到此拉取請求
pull.request.timeline.commits.added=已將 {0} 個提交新增到此拉取請求
pull.request.timeline.connected=連結了可能由此物件關閉的問題
pull.request.timeline.created=已建立
pull.request.timeline.disconnected=移除了一個指向問題的連結
pull.request.timeline.event.assigned=指派 {0}
pull.request.timeline.event.assigned.and.unassigned=指派 {0} 並取消指派 {1}
pull.request.timeline.event.labels.added=新增標籤 {0}
pull.request.timeline.event.labels.added.and.removed=新增標籤 {0} 並移除 {1}
pull.request.timeline.event.labels.removed=移除標籤 {0}
pull.request.timeline.event.removed.review.request=從 {0} 中移除審查請求
pull.request.timeline.event.requested.review=從 {0} 請求審查
pull.request.timeline.event.requested.review.and.removed.review.request=從 {0} 請求審查並從 {1} 中移除審查請求
pull.request.timeline.event.unassigned=取消指派 {0}
pull.request.timeline.marked.as.draft=將此拉取請求標記為草稿
pull.request.timeline.marked.as.ready=將此拉取請求標記為可供審查
pull.request.timeline.mentioned=提及了此拉取請求
pull.request.timeline.merged=合併了此請求
pull.request.timeline.merged.commit=已將提交 {0} 合併到 {1}
pull.request.timeline.no.description=未提供描述
pull.request.timeline.refresh.action=重新整理時間線
pull.request.timeline.refresh.action.description=檢查新時間線事件
pull.request.timeline.renamed=將此拉取請求從 ''{0}'' 重命名為 ''{1}''
pull.request.timeline.reopened=重新開啟了此請求
pull.request.timeline.requested.changes=請求了更改
pull.request.timeline.review.thread.collapse=隱藏執行緒
pull.request.timeline.review.thread.expand=顯示執行緒
pull.request.timeline.reviewed=審查了更改
pull.request.timeline.stale.review.dismissed=忽略了 <b>{0}</b> 過時的審查
pull.request.timeline.started.review=開始了審查
pull.request.unassigned=未分配
pull.request.unresolved.comments={0,choice,0#沒有未解決的註釋|1#{0} 個未解決的註釋|2#{0} 個未解決的註釋}
pull.request.view.conversations.action.description=檢視拉取請求時間線
pull.request.view.list=檢視拉取請求
rebase.action=同步複刻
rebase.action.description=相對於來源重定基底 GitHub 複刻版本庫
rebase.error=無法執行 GitHub 重定基底
rebase.error.failed.to.match.gh.repo=無法符合本地版本庫和 GitHub 版本庫
rebase.error.multi.repo.not.supported=不支持多版本庫專案
rebase.error.no.default.branch=無法確定上游分支 - 沒有為版本庫設定預設分支
rebase.error.no.suitable.account.found=找不到合適的 GitHub 帳戶
rebase.error.remote.origin.not.found=找不到 Git 遠端 'origin'
rebase.error.repo.not.found=找不到版本庫 {0}
rebase.error.upstream.not.found=未新增遠端 {0}
rebase.process=正在重定基底 GitHub 複刻…
rebase.process.adding.github.parent.as.remote.host=正在將 GitHub 父項新增為遠端主機…
rebase.process.configuring.upstream.remote=正在組態上游遠端…
rebase.process.fetching.upstream=正在獲取上游…
rebase.process.operation.title=正在重定基底
rebase.process.rebasing.branch.onto=正在將當前分支重定基底到 ''{0}''…
rebase.process.rebasing.onto=正在重定基底到 ''{0}''…
rebase.process.success=已成功重定基底 GitHub 複刻
request.response.0=請求響應: {0}。
retry.action=重試
retry.link=重試
server.unreachable=伺服器無法到達
settings.clone.ssh=使用 ssh 克隆 Git 版本庫
settings.timeout=連線超時:
settings.timeout.seconds=秒
share.action=在 GitHub 上共享專案
share.action.description=在 GitHub 上輕鬆共享專案
share.action.remote.is.on.github=遠端已經在 GitHub 上:
share.action.remotes.are.on.github=GitHub 上已經有以下遠端:
share.anyway.button=仍然共享
share.button=共享
share.dialog.account.info.load.error.prefix=無法載入 {0} 的資訊:
share.dialog.account.info.load.process.canceled=已取消程序
share.dialog.description=描述:
share.dialog.private=私有
share.dialog.remote=遠端:
share.dialog.repo.name=版本庫名稱:
share.dialog.share.by=共享者:
share.error.cannot.finish=無法完成 GitHub 共享過程
share.error.created.project=已在 GitHub 上成功建立專案
share.error.failed.to.create.repo=無法建立 GitHub 版本庫
share.error.init.commit.failed=，但初始提交失敗:<br/>
share.error.private.repos.not.supported=您的帳戶不支持私有版本庫
share.error.project.is.on.github=專案已在 GitHub 上
share.error.push.failed=，但初始推送失敗:<br/>{0}
share.error.push.no.current.branch=，但初始推送失敗: 沒有當前分支
share.error.remote.with.selected.name.exists=已存在具有所選名稱的遠端
share.error.repo.with.selected.name.exists=已存在具有所選名稱的版本庫
share.on.github=在 GitHub 上共享專案
share.process=正在 GitHub 上共享專案…
share.process.adding.files=正在將檔案新增到 git…
share.process.adding.gh.as.remote.host=正在將 GitHub 新增為遠端主機…
share.process.creating.git.repository=正在建立空 git 版本庫…
share.process.creating.repository=正在建立 GitHub 版本庫…
share.process.empty.project.created=已在 GitHub 上成功建立空版本庫
share.process.loading.account.info=正在載入 {0} 的帳戶資訊
share.process.performing.commit=正在執行提交…
share.process.pushing.to.github.master=正在推送到 GitHub master…
share.process.retrieving.username=正在檢索用戶名…
share.process.successfully.shared=已在 GitHub 上成功共享專案
share.validation.invalid.repo.name=版本庫名稱無效。名稱應由字母、數字、短划線、點和下劃線組成
share.validation.no.remote.name=未選擇遠端名稱
share.validation.no.repo.name=未選擇版本庫名稱
tab.title.pull.requests.new=在 {0} 新增拉取請求
task.comment.author=作者:
task.comment.date=日期:
task.repo.host.field=主機:
task.repo.name.field.empty.hint=版本庫名稱
task.repo.owner.field.empty.hint=版本庫所有者
task.repo.repository.field=版本庫:
task.repo.token.create.button=建立 API 令牌
task.repo.token.field=API 令牌:
task.repo.token.field.empty.hint=OAuth2 令牌
toolwindow.stripe.Pull_Requests=拉取請求
unknown.loading.error=未知載入錯誤
untracked.files.dialog.title=為初始提交新增檔案"
`;

exports[`dev messages/IdeBundle.properties 1`] = `
"FileChooser.detailsViewActionLabelText=詳細資訊
FileChooser.listViewActionLabelText=列表
FileChooser.newFolderActionLabelText=新增目錄
FileChooser.refreshActionLabelText=重新整理
FileChooser.viewMenuLabelText=檢視
ShowUsagesTableCellRenderer.accessible.CURRENT_ASTERISK_COL=當前用法
ShowUsagesTableCellRenderer.accessible.FILE_GROUP_COL=檔案 {0}
ShowUsagesTableCellRenderer.accessible.LINE_NUMBER_COL=行 {0}
ShowUsagesTableCellRenderer.accessible.OTHER_ASTERISK_COL=另一種用法
ShowUsagesTableCellRenderer.accessible.USAGE_TEXT_COL=用法文本 {0}
about.box.build.date=，{0} 建置
about.box.build.date.time=，{0} {1} 建置
about.box.build.number=構建版本 #{0}
about.box.jre=運行時版本: {0} {1}
about.box.open.source.software=開源軟體
about.box.powered.by=技術支援:
about.box.powered.by.open.source=<hyperlink>開源軟體</hyperlink>
about.box.vm=VM: {0}，{1}
about.popup.about.app=關於 {0}
about.popup.system.info=系統資訊\\n{0}\\n{1}
accessible.name.annotation=註解: {0}
accessible.name.empty=空
accessible.name.icon=圖示: {0}
accessible.name.line=行 {0}
action.ActionTracer.Anonymous.description.clear.log=清除日誌
action.ActionTracer.Anonymous.text.Clear=清除
action.AnAction.description.activate.frame.and.run=啟用框架並執行
action.AnAction.description.clear=清除
action.AnAction.description.new.script=新增腳本
action.AnAction.description.reload.list=重新載入列表
action.AnAction.description.run.on.frame.activation=在框架啟用時執行
action.AnAction.description.save=儲存
action.AnAction.description.search.history=搜尋歷史記錄
action.AnAction.description.set.script.file=設定腳本檔案
action.AnAction.description.stop=停止
action.AnAction.text.activate.frame.and.run=啟用框架並執行
action.AnAction.text.clear=清除
action.AnAction.text.new.script=新增腳本
action.AnAction.text.reload.list=重新載入列表
action.AnAction.text.run.on.frame.activation=在框架啟用時執行
action.AnAction.text.save=儲存
action.AnAction.text.search.history=搜尋歷史記錄
action.AnAction.text.set.script.file=設定腳本檔案
action.AnAction.text.stop=停止
action.AnActionButton.text.change.goto.check.box=更改“轉到”複選框
action.AnActionButton.text.install=安裝
action.AnActionButton.text.reload.list.of.packages=重新載入軟體套件列表
action.AnActionButton.text.uninstall=解除安裝
action.AnActionButton.text.upgrade=升級
action.Anonymous.text.add.abbreviation=新增縮寫
action.Anonymous.text.add.keyboard.shortcut=新增鍵盤快捷鍵
action.Anonymous.text.add.mouse.shortcut=新增滑鼠快捷方式
action.Anonymous.text.all=所有
action.Anonymous.text.back=後退
action.Anonymous.text.change.context=更改上下文…
action.Anonymous.text.configure=組態
action.Anonymous.text.delete.hook=刪除掛鈎
action.Anonymous.text.do.not.show.again=不再顯示
action.Anonymous.text.done=完成
action.Anonymous.text.edit.scopes.order=編輯作用域順序…
action.Anonymous.text.highlight=醒目提示顯示
action.Anonymous.text.live.template=實時模板
action.Anonymous.text.live.templates=實時模板
action.Anonymous.text.new.group=新增組…
action.Anonymous.text.new.tag=新增標記
action.Anonymous.text.remove.leading.directory=移除前導目錄
action.Anonymous.text.rename=重新命名
action.Anonymous.text.reset.shortcuts=重設快捷鍵
action.Anonymous.text.restore.leading.directory=還原前導目錄
action.Anonymous.text.template.group=模板組…
action.Anonymous.text.toggle=切換
action.ChangeProjectColorAction.Amber.title=Amber
action.ChangeProjectColorAction.Cobalt.title=Cobalt
action.ChangeProjectColorAction.Current.title={0} (Current)
action.ChangeProjectColorAction.Grass.title=Grass
action.ChangeProjectColorAction.Ocean.title=Ocean
action.ChangeProjectColorAction.Olive.title=Olive
action.ChangeProjectColorAction.Plum.title=Plum
action.ChangeProjectColorAction.Rust.title=Rust
action.ChangeProjectColorAction.Sky.title=Sky
action.ChangeProjectColorAction.Violet.title=紫色
action.ChooseCustomProjectColorAction.title=Custom Color...
action.CollapseAllAction.text.collapse.all=全部摺疊
action.ComboContentLayout.close.other.views.text=關閉其他檢視
action.ComboContentLayout.close.view.text=關閉檢視
action.ComboContentLayout.select.next.view.text=選擇下一個檢視
action.ComboContentLayout.select.previous.view.text=選擇上一個檢視
action.DataSharingOptionsAction.description=資料共享選項
action.DataSharingOptionsAction.text=資料共享選項…
action.DescriptionAwareSchemeActions.add.description.text=新增描述…
action.DescriptionAwareSchemeActions.edit.description.text=編輯描述…
action.DumbAware.BuildView.text.stop=BuildView
action.DumbAware.CopyrightProfilesPanel.description.stop=停止
action.DumbAware.TerminalView.text.new.session=新增會話
action.Events=事件
action.ExpandAllAction.text.expand.all=全部展開
action.FinderRecursivePanel.text.edit=編輯
action.FinderRecursivePanel.text.next=下一個
action.FinderRecursivePanel.text.previous=上一個
action.GetHelp=獲取幫助
action.InstallFromDiskAction.not.allowed.description=您的組織不允許從磁碟安裝延伸模組
action.InstallFromDiskAction.progress.text=正在安裝延伸模組
action.InstallFromDiskAction.text=從磁碟安裝延伸模組…
action.MarkAllNotificationsAsReadAction.description=將所有未讀通知標記為已讀
action.MarkAllNotificationsAsReadAction.text=將所有通知標記為已讀
action.NamedItemsListEditor.AddAction.description.add=新增
action.NamedItemsListEditor.AddAction.text.add=新增
action.NamedItemsListEditor.CopyAction.description.copy=複製
action.NamedItemsListEditor.CopyAction.text.copy=複製
action.OpenUrlHyperlinkInfo.Anonymous.description.copy.url.to.clipboard=將 URL 複製到剪貼簿
action.OpenUrlHyperlinkInfo.Anonymous.text.copy.url=複製 URL
action.QuickChangeCodeStyleSchemeAction.Anonymous.text.project=<專案>
action.ReopenProject.reopen.project.text=重新開啟專案
action.SwitchToJBR.text=切換到捆綁執行時
action.ToggleAction.description.pin.window=固定視窗
action.ToggleAction.description.toggle.auto.test=程式碼更改時切換測試的自動重新執行
action.ToggleAction.show.filter.description.show.filters.popup=顯示篩選器彈出視窗
action.ToggleAction.show.filter.text.filter=篩選
action.ToggleAction.text.filter=篩選
action.ToggleAction.text.filter.files.by.type=按類型篩選檔案
action.ToggleAction.text.pin.window=固定視窗
action.ToggleAction.text.toggle.auto.test=自動重新執行
action.ToggleAction.text.toggle.view=切換檢視
action.UpdateIde.button.postpone=推遲
action.UpdateIde.progress.text.new.installation.prepared.ide.will.restart=新安裝已準備，IDE 將在 {0, choice, 1#1 秒|2#{0} 秒}後重啟
action.UpdateIde.task.success.content=新安裝準備就緒
action.UpdateIde.task.success.restart=重新啟動
action.UpdateIde.task.success.title=IDE 更新
action.abbreviate.qualified.package.names=縮寫限定軟體套件名稱
action.activate.tool.window=啟用{0}視窗
action.add.all.open.tabs.to.new.favorites.list=將所有開啟的頁籤新增到新收藏夾列表
action.add.repository=新增儲存庫
action.add.to.new.favorites.list=新增到新收藏夾列表(_N)
action.add.to.new.favorites.list.description=新增到新收藏夾列表
action.append=追加
action.base.on.this.0=基於此{0}
action.base.on.this.class=基於此類別
action.base.on.this.method=基於此方法
action.browse.call.hierarchy=瀏覽呼叫層次結構
action.browse.method.hierarchy=瀏覽方法層次結構
action.browse.type.hierarchy=瀏覽類型層次結構
action.callee.methods.hierarchy=被呼叫方方法層次結構
action.caller.methods.hierarchy=呼叫方方法層次結構
action.choose.actions.to.add=新增動作
action.clear.encoding.description=清除預設編碼。
action.clear.encoding.description.file=清除檔案 ''{0}'' 編碼。
action.close=關閉(_C)
action.close.all.editors.above=關閉上方頁籤
action.close.all.editors.below=關閉下方頁籤
action.close.all.editors.in.tab.group=關閉組內所有頁籤(_A)
action.close.all.readonly.editors=關閉所有唯讀項
action.close.all.readonly.editors.in.tab.group=關閉組中的所有唯讀項
action.close.all.unmodified.editors=關閉未修改頁籤(_U)
action.close.all.unmodified.editors.in.tab.group=關閉組內未修改頁籤(_U)
action.close.all.unpinned.editors=關閉所有未固定頁籤
action.close.all.unpinned.editors.in.tab.group=關閉組中的未固定頁籤
action.close.projects.in.current.window=關閉當前視窗中的專案(_J)
action.collapse=摺疊
action.collapse.all=全部摺疊
action.compact.empty.middle.packages=壓縮空的中間軟體套件
action.copy.link.text=複製 {0} 連結
action.copy.path=複製絕對路徑(_O)
action.copy.paths=複製絕對路徑(_O)
action.copy.template=複製模板
action.create.child.template=建立子模板檔案
action.create.new.class.name.field=名稱
action.create.new.directory.or.package=建立新目錄或軟體套件
action.create.new.file.description=建立新檔案
action.create.template=建立模板
action.customizations.customize.action=自訂工具列…
action.delete=刪除(_D)
action.delete.ellipsis=刪除(_D)…
action.description.clear.the.contents.of.the.event.log=清除事件日誌的內容
action.description.create.new.module.group=建立新模組組
action.description.create.new.package=建立新的軟體套件
action.description.edit.notification.settings=編輯通知設定
action.description.pin.tool.window.to.0.side.ui.designer.editor=將工具視窗固定到{0}側 UI 設計器編輯器
action.description.show.files=顯示/隱藏檔案
action.description.show.included.only=僅顯示包含到當前所選作用域的檔案
action.description.show.modules=顯示/隱藏模組
action.description.todo.show.all=顯示全部 TODO 項
action.description.unpin.tool.window.from.designer.editor=從設計器編輯器取消固定工具視窗
action.description.view.class.hierarchy=選擇類別層次結構
action.description.view.subtypes.hierarchy=切換到子類型層次結構
action.description.view.supertypes.hierarchy=切換到父類型層次結構
action.descriptor.action=動作: {0}
action.descriptor.keystroke=按鍵:“{0}”
action.descriptor.typing=輸入:“{0}”
action.directory=目錄
action.dont.show.again.text=不再顯示
action.download.and.install.plugin=下載並安裝
action.edit.file.templates=編輯檔案模板…
action.edit.repository.url=編輯儲存庫 URL
action.empty.group.text=空組
action.empty.unnamed.group.text=空未命名組
action.enable.disable.global.menu.integration.description=啟用/停用全域選單整合(所有框架)
action.exclude.all.text=全部排除
action.expand=展開
action.expand.all=全部展開
action.explorer.text=檔案總管
action.file.manager.text=檔案管理器
action.filter.todo.items=篩選 TODO 條目
action.finder.text=訪達
action.flatten.packages=平展軟體套件
action.flatten.view=平展檢視
action.fn.keys.text=Fn 鍵
action.from.file.template=從檔案模板…
action.group.by.modules=模組
action.group.by.packages=軟體套件
action.group.macos.shortcuts.text=macOS 快捷鍵
action.group.name.unnamed.group=<未命名組>
action.help=幫助
action.hide.all.windows=隱藏所有視窗(_W)
action.hide.empty.middle.packages=隱藏空的中間軟體套件
action.hide.non.implementations=隱藏方法未合法實作的類別 
action.include.all.text=全部包含
action.invoke.macro.text=呼叫巨集
action.jcef.followInstructions=遵循指令
action.jcef.restart=重啟
action.label.hide.notification=隱藏通知
action.manual.order=手動排序
action.maximize.editor=最大化編輯器
action.maximize.text=最大化
action.move.module.new.top.level.group=新增頂層組…
action.move.module.outside.any.group=在任意組外
action.move.module.to.new.sub.group=到新子組…
action.move.module.to.this.group=到此組
action.new.package=新增軟體套件…
action.next.message=下一條訊息
action.next.problem=下一個問題
action.next.tip=下一步(&N)
action.next.todo=下一個 TODO
action.normalize.splits=標準化拆分
action.open.editor.settings.text=開啟設定
action.open.tip=開啟(&O)…
action.open.web.preview.text=內建預覽
action.overwrite=覆蓋
action.package=軟體套件
action.pin.tab=固定頁籤(_I)
action.presentation.AbstractSchemesPanel.description=顯示方案動作
action.presentation.AbstractSchemesPanel.text=顯示方案動作
action.presentation.EditorTabbedContainer.text=關閉。按 Alt 並點擊以關閉其他。
action.presentation.EncodingPanel.text=檔案編碼
action.presentation.ExtractIncludeAction.text=Include 檔案…
action.presentation.FindAllAction.text=搜尋全部
action.presentation.LightEditTabs.text=關閉。按 Alt 並點擊以關閉其他。
action.presentation.OpenSelectedProjectsAction.text.open.all.projects.in.group=開啟組中的所有專案
action.presentation.OpenSelectedProjectsAction.text.open.selected=開啟選定專案
action.presentation.RegistryUi.text=還原為預設值
action.presentation.RegistryUi.text.edit=編輯
action.presentation.RemoveSelectedProjectsFromGroupsAction.text=從組中移除
action.presentation.ShowUiDebuggerAction.text=UI 偵錯器
action.presentation.WeighingActionGroup.text=其他
action.previous.message=上一條訊息
action.previous.problem=上一個問題
action.previous.tip=返回(&B)
action.previous.todo=上一個 TODO
action.refresh=重新整理
action.remove=移除
action.remove.from.current.favorites=從當前收藏夾移除
action.remove.repository.from.list=從列表中移除儲存庫
action.remove.template=移除模板
action.reset.font.size=重設為 {0}pt
action.reset.font.size.all.editors=在所有編輯器中重設為 {0}pt
action.reset.font.size.info=字體大小: {0}pt
action.reset.to.default=還原為原始模板
action.restore.windows=還原視窗(_W)
action.select.none=無選擇(&N)
action.send.to.new.favorites.list=發送至新收藏夾列表
action.separator=分隔符({0})
action.separator.file.templates=檔案模板
action.show.classes=顯示類別
action.show.compact.empty.middle.packages=顯示/壓縮中間軟體套件
action.show.files=顯示檔案
action.show.hide.empty.middle.packages=顯示/隱藏空的中間軟體套件
action.show.included.only=僅顯示包含的檔案
action.show.infos=顯示資訊訊息
action.show.members=顯示成員
action.show.modules=顯示模組
action.show.warnings=顯示警告
action.start.macro.recording=開始巨集錄製(_M)
action.stop=停止
action.stop.macro.recording=停止錄製巨集 (_M)
action.switch.project.text=切換專案
action.sync.completed.successfully=檔案同步已成功完成。
action.text.change.encoding=將編碼更改為 ''{0}''
action.text.change.system.shortcuts=更改系統快捷鍵
action.text.clear.all=全部清除
action.text.copy=複製(&C)
action.text.copy.link.address=複製連結地址
action.text.disable.input.methods=停用輸入方法
action.text.editor.mode.none=無
action.text.hide.chessboard=隱藏棋盤
action.text.hide.file.name=隱藏檔名
action.text.hide.file.size=隱藏檔案大小
action.text.hide.grid=隱藏網格
action.text.hide.tags.panel=隱藏標記面板
action.text.install.keymap=安裝 {0} 按鍵映射
action.text.merge.tabs.to.group=將頁籤合併到 ''{0}'' 組
action.text.modify.shortcut=修改快捷鍵
action.text.modify.shortcuts=修改快捷鍵
action.text.more=更多
action.text.open.link.in.browser=在瀏覽器中開啟連結
action.text.reload.file=重新載入檔案
action.text.remove.0=移除 {0}
action.text.remove.abbreviation.0=移除縮寫 ''{0}''
action.text.remove.all.shortcuts=移除所有快捷鍵
action.text.search.for.keymap=搜尋 {0} 按鍵映射延伸模組
action.text.select.next.tab=選擇下一個頁籤
action.text.select.previous.tab=選擇上一個頁籤
action.text.settings=設定
action.text.show.chessboard=顯示棋盤
action.text.show.file.name=顯示檔名
action.text.show.file.size=顯示檔案大小
action.text.show.grid=顯示網格
action.text.show.tags.panel=顯示標記面板
action.text.split.group=拆分 ''{0}'' 組
action.title.group.by.directory=按目錄分組
action.todo.edit.filters=編輯篩選器
action.todo.edit.filters.description=編輯篩選器
action.todo.show.all=全部顯示
action.toggle.global.menu.integration.text=切換全域選單整合
action.unpin.tab=取消固定頁籤(_I)
action.unpin.tab.tooltip=取消固定頁籤
action.view.class.hierarchy=類別層次結構
action.view.subtypes.hierarchy=子類型層次結構
action.view.supertypes.hierarchy=父類型層次結構
actions.on.save.label.activated.on.any.save=任何儲存
actions.on.save.label.activated.on.any.save.and.external.change=<html>任何儲存和<br/>外部更改</html>
actions.on.save.label.activated.on.explicit.save=顯式儲存
actions.on.save.label.activated.on.explicit.save.with.0.shortcut=顯式儲存({0})
actions.on.save.link.all.actions.on.save=儲存時的所有動作…
actions.on.save.link.configure=組態…
actions.on.save.link.configure.autosave.options=組態自動儲存選項…
actions.on.save.option.activated.on.any.save.and.external.change=任何儲存和外部更改
actions.on.save.option.activated.on.any.save.including.autosave=任何儲存(包括自動儲存)
actions.on.save.page.title=儲存時的動作
actions.on.save.table.column.name.action=動作
actions.on.save.table.column.name.activated.on=啟用條件
activation.auth.message=命令行啟動器已過時。請重新整理(通過“工具 | 建立命令行啟動器”)。
activation.file.is.waiting.dismiss=消除
activation.file.is.waiting.do.not.show=不再顯示
activation.file.is.waiting.notification=指令行將一直等待，直到檔案 ''{0}'' 關閉。
activation.file.is.waiting.release=釋放
activation.file.is.waiting.title=指令行將一直等待，直到此檔案關閉
activation.not.initialized=IDE 尚未初始化
activation.project.is.waiting.notification=指令行將一直等待，直到專案 ''{0}'' 關閉。
activation.shutting.down=IDE 正在關閉
add.BOM=新增 BOM
add.byte.order.mark.to=向 {0} 新增位元組順序標記
add.local.scope.action.text=本地
add.module.popup.title=新增模組
add.scope.dialog.title=新增新作用域
add.scope.name.label=名稱
add.scope.popup.title=新增作用域
add.shared.scope.action.text=共享
add.source.header.popup.title=新增源和標題
alphabetical.mode.is.on.notification=已關閉按字母順序排列的制表符順序
analyze.plugin.title=每個延伸模組的啟動時間成本
appearance.ui.option.group=UI
appearance.view.option.group=檢視
appearance.window.option.group=視窗
application.cannot.start.in.a.headless.mode=應用程式不能以無頭模式啟動{0, choice, 0#|1#，對於指令: {1}|2#，對於啟動器: {2}} {3, choice, 0#|1# (命令行: {4})}
assign.custom.shortcuts.or.change.the.macos.system.settings=分配自定義快捷鍵或更改 macOS 系統設定。
attachable.project.pane.name=檔案
available.packages.dialog.title=可用軟體套件
background.image.button=背景圖像…
big.popup.filter.button.all=所有
big.popup.filter.button.invert=反轉
big.popup.filter.button.none=無
binary.file.too.large=二進制檔案 {0} 太大({1})
border.title.command.output=指令輸出
border.title.description=描述
border.title.problem.files=問題檔案
browse.custom.icon.hint=要設定自訂圖示，請指定 SVG 或 PNG 檔案的路徑。
browser.default.not.supported=抱歉，IDE 不知道如何在此系統上啟動預設瀏覽器。
browser.error=瀏覽器錯誤
browser.notification.timeout.group=在瀏覽器中開啟頁面超時
browser.notification.timeout.text=無法在瀏覽器中開啟 <a href="{0}">{1}</a>，因為 URL 未響應。
browser.notification.timeout.title=URL 未響應
browser.preview.file.title={0} 的預覽
browser.select.in.default.name=Web 瀏覽器
browser.shortcut=按住 Shift 以開啟本地檔案 URL
browser.shortcut.or.shift={0}，按住 Shift 以開啟本地檔案 URL
browser.url.popup=選擇 URL
browsers.chrome=Chrome
browsers.explorer=Internet Explorer
browsers.firefox=Firefox
browsers.safari=Safari
browsers.settings=Web 瀏覽器和預覽
buildToolWindow.tree.accessibleName=建置結果
bundled.jre.m1.arch.message=為 Apple Silicon 下載 {0} 以獲得更好的性能和穩定性。
bundled.jre.m1.arch.message.download=下載…
bundled.jre.version.message=請考慮切換到更適合 IDE 的捆綁 Java Runtime(您當前的 Java Runtime 為 {0}，來自 {1}，位置為 ''{2}'')。
button.add.action=新增動作(&A)…
button.add.separator=新增分隔符 (&S)
button.back=後退
button.cancel=取消(&C)
button.cancel.without.mnemonic=取消
button.choose=選擇
button.clear.and.close=清除並關閉
button.continue.editing=繼續編輯
button.convert=轉換
button.convert.anyway=仍然轉換
button.copy=複製(&C)
button.copy.and.close=複製並關閉
button.create=建立(&C)
button.delete=刪除
button.disable=停用
button.disable.selected.plugins=停用所選延伸模組
button.do.not.send=不發送
button.done=完成
button.edit.action.icon=編輯圖示(&I)…
button.enable.all=全部啟用
button.enable.updated.plugins=啟用更新的{0,Choice,1#Plugin|2#Plugins}
button.exclude=排除
button.exclude.recursively=遞迴排除
button.existing.frame=此視窗(&T)
button.facet.quickfix.text=修正(&F)
button.finish=完成(&F)
button.fix=修正…
button.fix.it=修復
button.help=幫助(&H)
button.http.proxy.settings=HTTP 代理設定(&H)…
button.i.want.to.edit.all.files.in.choice.this.directory={0, choice, 1#此目錄|2#這些目錄}中的所有檔案
button.i.want.to.edit.any.non.project.file.in.current.session=任何非專案檔案
button.i.want.to.edit.choice.this.directory.anyway={0, choice, 1#此目錄|2#這些目錄}
button.i.want.to.edit.choice.this.file.anyway={0, choice, 1#此文件|2#這些檔案}
button.include=包含
button.include.recursively=遞迴包含
button.invalidate.and.exit=清除並退出(&E)
button.invalidate.and.restart=清除並重啟(&R)
button.later=稍後{0,choice,0#重啟|1#關閉}
button.move.down=下移 (&D)
button.move.up=上移(&U)
button.new.frame=新視窗 (&W)
button.next=下一個
button.now=立即{0,choice,0#重啟|1#關閉}
button.ok=確定 (&O)
button.previous=上一個
button.recover.vfs.from.logs.and.exit=恢復快取並退出(&E)
button.recover.vfs.from.logs.and.restart=恢復快取並重啟(&R)
button.reject=拒絕
button.reload=重新載入
button.reload.anyway=仍然重新載入
button.remove=移除(&R)
button.remove.from.list=從列表中移除(\\\\&R)
button.rename=重新命名
button.repaint.icons=重新繪製圖示(&R)
button.restore.all=還原所有預設設定(&L)
button.restore.defaults=還原為預設值
button.restore.last.state=還原上次狀態
button.restore.selected.groups=還原選定組
button.restore.selection=還原{0}
button.save=儲存
button.save.anyway=仍然儲存
button.set.0=設定 {0}
button.skip=跳過
button.wizard.next=下一步 (&N)
button.wizard.previous=上一步 (&P)
button.yes=是(_Y)
cannot.delete.jre.config=無法刪除 JRE 組態檔案 ''{0}'': {1}
cannot.redo.message=無法重做
cannot.redo.title=無法重做
cannot.undo.error.contains.nonundoable.changes.message=以下檔案具有無法撤消的更改:
cannot.undo.error.other.affected.files.changed.message=受此動作影響的以下檔案已更改:
cannot.undo.error.other.users.overwrote.changes.message=您對以下檔案的更改已被其他使用者覆蓋:
cannot.undo.message=無法撤消
cannot.undo.title=無法撤消
change.encoding.command.name=更改 ''{0}'' 的編碼
change.memory.code.cache=程式碼快取大小
change.memory.direct.buffers=直接緩衝區限制
change.memory.max.heap=最大堆大小
change.memory.metaspace=元空間大小
change.memory.min.heap=初始堆大小
channel.status.beta=Beta 版本或公開預覽
channel.status.eap=搶先體驗計劃
channel.status.milestone=里程碑 EAP 建置
channel.status.stable=穩定版本
checkbox.acessibility.contrast.scrollbars=使用對比度捲軸
checkbox.also.in.reader.mode=也適用於<a>閱讀器模式</a>
checkbox.case.sensitive=區分大小寫
checkbox.colors.only=僅顏色
checkbox.compact.mode=緊湊模式
checkbox.compact.mode.description=UI 元素佔用更少的螢幕空間
checkbox.compact.tree.indents=在樹中使用較小的縮排
checkbox.confirm.application.exit=退出 IDE 之前確認
checkbox.copy.javadoc=複製 JavaDoc(&J)
checkbox.create.the.entry.for.all.users.requires.superuser.privileges=為所有用戶建立條目(需具備超級使用者權限)(&A)
checkbox.customfiletype.ignore.case=忽略情況 (&I)
checkbox.customfiletype.support.paired.braces=支援配對大括號 (&R)
checkbox.customfiletype.support.paired.brackets=支援配對中括號 (&C)
checkbox.customfiletype.support.paired.parens=支援配對小括號 (&P)
checkbox.customfiletype.support.string.escapes=支援字串轉義 (&E)
checkbox.disabled.included=包括停用的動作(&D)
checkbox.enable.live.templates=啟用實時模板 (&L)
checkbox.enable.new.ui=啟用新 UI
checkbox.errortree.export.details=詳細資訊
checkbox.full.paths.in.window.header=始終在視窗標題中顯示完整路徑
checkbox.inject.reveal.library.on.launch=啟動時注入 Reveal 庫
checkbox.insert.at.override=插入 @Override(&O)
checkbox.left.toolwindow.layout=左側並排布局
checkbox.main.menu.separate.toolbar=在單獨的工具列中顯示主選單
checkbox.merge.main.menu.with.window.not.supported.comment=This option is not supported for the current Window Manager
checkbox.merge.main.menu.with.window.title=合併主選單和視窗標題
checkbox.narrow.down.on.typing=在輸入時縮小(&N)
checkbox.narrow.down.the.list.on.typing=在輸入時縮小列表(&N)
checkbox.override.default.laf.fonts=使用自訂字體:
checkbox.password.safe.remember=記住(&R)
checkbox.reformat.according.to.style=按照樣式重新格式化(&R)
checkbox.remember.size.for.each.tool.window=記住每個工具視窗的大小
checkbox.remote.sdk.run.as.root.via.sudo=通過 sudo 作為 root 執行
checkbox.right.toolwindow.layout=右側並排布局
checkbox.safe.delete.with.usage.search=安全刪除(帶有用法搜尋)(&F)
checkbox.safe.write=儲存前備份檔案
checkbox.save.files.automatically=如果 IDE 空閒則儲存檔案
checkbox.save.files.on.frame.deactivation=切換到其他應用程式或內建終端時儲存檔案
checkbox.show.editor.preview.popup=懸停在捲軸上時顯示程式碼透鏡
checkbox.show.icons.in.menu.items=在選單項顯示圖示
checkbox.show.rendered.doc.comments=渲染文檔註釋
checkbox.show.tips.on.startup=啟動時不顯示小技巧
checkbox.show.tool.window.bars=顯示工具視窗列
checkbox.show.tool.window.numbers=顯示工具視窗編號
checkbox.show.tree.indent.guides=顯示樹縮排參考線
checkbox.smooth.scrolling=平滑滾動
checkbox.smooth.scrolling.animated=動畫平滑滾動(&N)
checkbox.smooth.scrolling.description=使用滑鼠滾輪/觸摸板時，整個介面將平滑滾動，而不是逐行滾動
checkbox.smooth.scrolling.enable.high.precision.timer=啟用 Windows 高精度計時器
checkbox.smooth.scrolling.enable.high.precision.timer.comments=為刷新率較高的顯示器啟用更平滑的動畫。
checkbox.smooth.scrolling.enable.high.precision.timer.help=通常，預設的 Windows 計時器周期為 15.625 毫秒。因此，預設動畫每秒播放近 60 幀。此選項會在播放動畫時動態地將周期設定為較低的值。
checkbox.support.screen.readers=支援螢幕閱讀器
checkbox.synchronize.files.on.frame.activation=切換到 IDE 視窗或開啟編輯器頁籤時同步外部更改
checkbox.text.this.project.only=僅此專案
checkbox.todo.use.default.colors=使用配色方案 TODO 預設顏色
checkbox.transparent.native.to.ascii.conversion=自動轉換成 Ascii 但顯示原生的內容
checkbox.upload.reveal.library.on.the.device.if.necessary=如有必要，上傳裝置上的 Reveal 庫
checkbox.use.custom.user.data.directory.for.chrome=使用自訂用戶數據目錄(&U):
checkbox.use.solution.colors.in.main.toolbar=在主工具列中使用專案顏色
checkbox.use.solution.colours.in.toolbar=Show Project Gradient
checkbox.use.transparent.mode.for.floating.windows=為浮動視窗使用透明模式
checkbox.widescreen.tool.window.layout=寬屏工具視窗布局
checkbox.widescreen.tool.window.layout.description=通過限制水平工具視窗的寬度，使垂直工具視窗的高度最大化
chooser.description.jar.and.zip.archives.are.accepted=接受 JAR 和 ZIP 歸檔
chooser.description.specifies.user.data.directory=指定儲存使用者資料(您的“組態檔案”)的目錄
chooser.title.plugin.file=選擇延伸模組檔案
chooser.title.select.profiles.ini.file=選擇 "profiles.ini" 檔案
chooser.title.select.user.data.directory=選擇使用者資料目錄
clear.all.notifications=清除所有通知
code.cache.warn.message={0} MB 的程式碼快取大小不足。請將 ''-XX:ReservedCodeCacheSize'' 增加到 {1} MB 或以上，以避免性能問題。
collect.logs.notification.error=無法使用日誌建立 .zip 檔案: {0}
collect.logs.notification.sent.success=日誌已發送至 {0}。您的 ID 為: {1}
collect.logs.notification.success=已建立日誌檔案: {0}
collect.logs.progress.title=正在收集日誌
collect.logs.sensitive.text=包含的日誌和設定中可能含有敏感資料。
collect.logs.sensitive.title=敏感資料
collect.upload.logs.progress.title=正在收集和上傳日誌
color.name.blue=藍色
color.name.brown=棕色
color.name.gray=灰色
color.name.green=綠色
color.name.orange=橙色
color.name.rose=玫瑰色
color.name.violet=紫色
color.name.yellow=黃色
colorfulInstances.gotIt.text=您可以在右鍵選單或設定中停用此功能
colorfulInstances.gotIt.title=通過工具列顏色區分解決方案
colorpanel.label.alpha=A
colorpanel.label.alpha.percent=A%
colorpanel.label.blue=B
colorpanel.label.brightness=B%
colorpanel.label.green=G
colorpanel.label.hue=H°
colorpanel.label.red=R
colorpanel.label.saturation=S%
colorpicker.brightness.slider.title=亮度
colorpicker.brightness.slider.tooltip=亮度
colorpicker.colorvaluepanel.hexlabel=十六進制
colorpicker.format.hsb=HSB
colorpicker.format.rgb=RGB
colorpicker.label.blue=B:
colorpicker.label.brightness=B:
colorpicker.label.green=G:
colorpicker.label.hue=H:
colorpicker.label.red=R:
colorpicker.label.saturation=S:
colorpicker.opacity.slider.title=不透明度
colorpicker.opacity.slider.tooltip=不透明度
colorpicker.recent.color.tooltip=R: {0} G: {1} B: {2} A: {3}
column.enabled=已啟用
column.name.cost.details=成本詳細資訊
column.name.plugin=延伸模組
column.name.startup.time.ms=啟動時間(毫秒)
column.plugins.name=名稱
column.todo.filter.patterns=模式
column.todo.filters.name=名稱
column.todo.patterns.case.sensitive=區分大小寫
column.todo.patterns.icon=圖示
column.todo.patterns.pattern=模式
combobox.ide.scale.comment.format=通過 {0} 或 {1} 進行更改。通過 {2} 設定為 100%
combobox.ide.scale.percent=縮放:
combobox.look.and.feel=主題:
command.close.all.editors=關閉所有編輯器
command.close.all.unmodified.editors=關閉所有未修改的編輯器
command.create.directory=建立目錄
command.create.file=建立檔案
command.create.file.from.template=從模板建立檔案
command.create.new.package=建立新軟體套件
command.create.package=建立軟體套件
command.deleting.files=正在刪除檔案
command.finish=完成
command.fixing.line.separators=修正行分隔符
command.go.to.line=轉到行
command.name.apply.color=套用顏色
command.name.choice.attach.detach={0, choice, 0#附加|1#分離} {1}
command.name.choice.exclude.include={0, choice, 0#排除|1#包含}{1}
command.pasting.reference=貼上參照
command.renaming.module=正在重新命名模組 {0}
command.select.all=全選
command.unselect.all=取消全選
comment.text.pause=暫停
comment.text.paused=已暫停
comment.text.resume=恢復
configurable.AppEngineCloudConfigurable.display.name=Google App Engine 帳號
configurable.AppEngineFacetEditor.display.name=Google App Engine
configurable.ChromeSettingsConfigurable.display.name=Chrome 設定
configurable.CodeStyle.display.name=程式碼樣式
configurable.Console.display.name=主控台
configurable.DatabaseSettingsConfigurable.CsvFormats.display.name=CSV 格式
configurable.DatabaseSettingsConfigurable.DataViews.display.name=資料編輯器和檢視器
configurable.DatabaseSettingsConfigurable.Other.display.name=其他
configurable.DatabaseSettingsConfigurable.OutputResults.display.name=輸出和結果
configurable.DatabaseSettingsConfigurable.QueryExecution.display.name=查詢執行
configurable.DatabaseSettingsConfigurable.Templating.display.name=使用者參數
configurable.DockerExtraHostConfigurable.display.name=額外主機
configurable.DuplicatesConfigurable.display.name=重複項
configurable.EmbeddedSettingsConfigurable.display.name=嵌入式開發
configurable.ExceptionAnalyzerConfigurable.display.name=異常分析器
configurable.ExternalDependenciesConfigurable.display.name=必需延伸模組
configurable.GutterIconsConfigurable.display.name=裝訂區域圖示
configurable.JavaFxSettingsConfigurable.display.name=JavaFX
configurable.PluginHostsConfigurable.display.name=自訂延伸模組儲存庫
configurable.Postfix.Completion.display.name=後綴補全
configurable.Runtime.Targets.Configurable.display.name=執行目標
configurable.SettingsPage.display.name=捆綁的 Web 幫助
configurable.TerminalOptionsConfigurable.display.name=終端
configurable.TextMateConfigurableProvider.display.name=TextMate 捆綁包
configurable.TimeTrackingConfigurable.display.name=時間追蹤
configurable.VagrantConfigurable.display.name=Vagrant
configurable.console.font.name=主控台字體
configurable.console.font.use.editor.font=使用編輯器字體
configurable.file.colors=檔案顏色
configurable.font.name=字體
configurable.new.ui.name=新 UI
configurable.notifications.name=通知
configurable.quick.lists.name=快速列表
configurable.trusted.hosts.display.name=受信任的位置
consent.configurable=資料共享
conversion.dialog.text.1=專案 ''{0}'' 的格式已過時，將被轉換。您可能無法使用早期版本的 {1} 開啟此專案。
conversion.dialog.text.2=<b> </b><a href="details">詳細資訊…</a><br/><br/>舊版本的專案檔案將被儲存到: ''{0}''
convert.project.dialog.button.text=轉換
copy.reference=複製參照(&Y)
copy.references=複製參照(&Y)
copy.relative.path=複製相對路徑(&Y)
copy.relative.paths=複製相對路徑(&Y)
copy.system.information.to.clipboard=將系統資訊複製到剪貼簿
create.new.UT8.file.option.always=包含 BOM
create.new.UT8.file.option.never=不含 BOM
create.new.UT8.file.option.only.under.windows=在 Windows 下使用 BOM，否則不使用 BOM
custom.action.actual=實際: {0}
custom.action.stored=已存儲: {0}
custom.option.testmode=讀取自訂動作 {0}
date.format.24.hours=使用 24 小時時間
date.format.date.format=日期格式:
date.format.date.patterns=日期模式
date.format.error.contains.time.pattern=日期格式不應包含時間模式(小時、分鐘、秒)
date.format.error.invalid.pattern=無效模式: {0}
date.format.override.system.date.and.time.format=覆寫系統日期和時間格式
date.format.pretty=使用美化的格式
date.format.relative=將數字日期取代為<i>今天</i>、<i>昨天</i>和 <i>10 分鐘前</i>
date.time.format.configurable=日期格式
default=預設
default.icons.add.text=新增
default.icons.edit.text=編輯
default.icons.export.text=匯出
default.icons.filter.text=篩選
default.icons.find.text=尋找
default.icons.gear.plain.text=純齒輪
default.icons.import.text=匯入
default.icons.list.files.text=列出檔案
default.icons.none.text=<無>
default.icons.remove.text=移除
default.icons.unknown.text=預設圖示
description.copy.text.to.clipboard=將文本複製到剪貼簿
detach.directory.action.text.detach.0=從專案中分離{0,choice,1#目錄|2#目錄}…
detach.directory.dialog.button.detach=分離
detach.directory.dialog.message.detach.0=分離 {0}?\\n不會從磁碟上移除檔案。
detach.directory.dialog.title.detach=從專案中分離目錄
detach.library=分離庫
detach.library.from.module=從模組 ''{1}'' 分離庫 ''{0}''?\\n不會損害磁碟上的檔案。
dialog.action.restart.cancel=取消
dialog.action.restart.yes=重啟
dialog.button.ok.jcef.signIn=登入
dialog.choose.recovery.point=選擇恢復點:
dialog.content.jcef.proxyServer=<html>瀏覽器元件正在為代理<br>請求身份驗證: {0}
dialog.content.label.jcef.login=登入名: 
dialog.content.label.jcef.password=密碼: 
dialog.layout.already.exists=已存在使用此名稱的布局
dialog.layout.name.too.long=允許的最大長度為 {0} 個字元
dialog.message.attach.project.not.found=在 {0} 中找不到專案
dialog.message.caches.will.be.invalidated=移除所有專案的快取和索引。重新開啟專案時將建置新快取。
dialog.message.can.not.open.file=無法開啟檔案 {0}
dialog.message.cannot.perform.operation.too.complex.sorry=無法執行動作。抱歉，太複雜了。
dialog.message.cannot.save.the.file.0=無法儲存檔案 {0}
dialog.message.command.could.not.complete={0} 不能成功補全。請檢視指令的輸出，了解如何解決這個問題。
dialog.message.command.not.finished.yet={0} 尚未完成。
dialog.message.communication.error=通信錯誤
dialog.message.component.could.not.be.reloaded=無法重新載入該元件。重新載入專案?
dialog.message.conversions.will.be.performed=<html>將執行以下轉換:<br>{0}</html>
dialog.message.could.not.erase.files.or.folders.0.1=無法擦除檔案或目錄:\\n{0}{1}
dialog.message.disable.dependent.plugin=<html>將停用相依的 ''{0}'' 延伸模組</html>
dialog.message.disable.dependent.plugins=<html>以下相依延伸模組將被停用: <br>{0}</html>
dialog.message.enable.required.plugin=<html>將啟用所需的 ''{0}'' 延伸模組</html>
dialog.message.enable.required.plugins=<html>將啟用所需的以下延伸模組: <br>{0}</html>
dialog.message.enable.vagrant.support.plugin=啟用 Vagrant 支援延伸模組
dialog.message.enter.new.value.for.0=輸入 {0} 的新值
dialog.message.enter.new.value.for.0.in.form.brightness.contrast.alpha=在“亮度、對比度、Alpha”表單中\\n輸入 {0} 的新值
dialog.message.enter.new.value.for.0.in.form.top.left.bottom.right=在“上、下、左、右”表單中\\n輸入 {0} 的新值
dialog.message.enter.new.value.for.0.in.form.width.height=以“寬度,高度”形式\\n輸入 {0} 的新值
dialog.message.error.setting.value=設定值時出錯: {0}
dialog.message.execution.finished=執行已完成
dialog.message.execution.finished.because=執行被終止，原因是: {0}
dialog.message.fail.to.load.plugin.descriptor.from.file=無法從檔案 {0} 載入延伸模組檔案描述子
dialog.message.file.already.exists=檔案已存在
dialog.message.file.with.name.already.exists=名稱為 ''{0}'' 的檔案已存在
dialog.message.folder.with.name.already.exists=名稱為 ''{0}'' 的目錄已存在
dialog.message.following.plugin.depend.on=以下{0,choice,1#延伸模組|2#延伸模組}{0,choice,1#相依|2#相依}於{1}。要繼續移除嗎?<br>{2}
dialog.message.host.name.empty=主機名為空
dialog.message.incompatible.encoding=您選擇的編碼(''{0}'')可能會更改 ''{1}'' 的內容。<br>是否要<br>1. 以新的編碼 ''{0}'' 從磁碟<b>重新載入</b>檔案，並覆蓋編輯器內容或<br>2. <b>轉換</b>文本並以新編碼覆蓋檔案?
dialog.message.internal.error=內部錯誤
dialog.message.invalid.host.value=主機值無效
dialog.message.invalid.path=無效路徑 ''{0}''
dialog.message.login.empty=登入名為空
dialog.message.must.be.restarted.for.changes.to.take.effect=重啟 {0} 以使更改生效
dialog.message.no.message=沒有訊息
dialog.message.no.project.found.to.open.file.in=找不到可以在以下位置開啟檔案的專案:
dialog.message.only.one.instance.can.be.run.at.time=一次只能執行一個 {0} 執行個體。
dialog.message.open.cancelled=開啟已被取消
dialog.message.password.empty=密碼為空
dialog.message.please.enter.credentials.for=請輸入憑證: {0}
dialog.message.plugin.core.part=延伸模組 ''{0}'' 是 {1} 的核心部分。要將其更新為較新的版本，您應當更新 IDE。
dialog.message.plugin.depends.on.unknown.plugin=延伸模組 {0} 依賴於未知{1,choice,1#延伸模組|2#延伸模組} {2}
dialog.message.plugin.is.not.allowed=您的組織不允許安裝延伸模組 ''{0}''
dialog.message.plugin.was.already.installed=延伸模組 ''{0}'' 已安裝
dialog.message.press.for.field.hints=按 {0} 獲取欄位提示
dialog.message.problem.with.connection=連線出現問題: {0}
dialog.message.project.group.name=專案組名
dialog.message.recover.vfs.from.operations.log=從動作日誌中恢復快取。從下面選擇所需的恢復點。需要重新啟動才能套用更改。
dialog.message.remove.0.from.recent.projects.list=從最近的專案列表中移除 ''{0}''?
dialog.message.restart.ide=是否要重啟 IDE?
dialog.message.restarted.to.apply.changes=是否重新啟動 {0} 以套用更改?
dialog.message.specified.path.cannot.be.found=找不到指定的路徑
dialog.message.the.following.items=可選:
dialog.message.there.already.same.interpreter=已經有相同的解釋器:\\n{0}
dialog.message.trying.to.create.folder.with.ignored.name=正在嘗試建立具有忽略名稱的目錄；結果將不可見
dialog.message.unable.to.apply.changes=<body style="padding: 5px;">無法套用更改: 將無法載入{0,choice,1#延伸模組|2#延伸模組} {1}。</body>
dialog.message.unable.to.create.idea.directory=無法建立 ''.idea'' 目錄(%s): {0}
dialog.message.unknown.error=未知錯誤
dialog.message.wait.must.be.supplied.with.file.or.project.to.wait.for='--wait' 必須提供要等待的檔案或專案
dialog.new.window.layout.prompt=輸入新布局名稱
dialog.new.window.layout.title=新增布局
dialog.rename.window.layout.prompt=布局名稱:
dialog.rename.window.layout.title=重新命名布局
dialog.text.error.getting.value=獲取值時出錯: {0}
dialog.title.abbreviation=縮寫
dialog.title.activity.monitor=活動監視器
dialog.title.add.actions.to.quick.list=將動作新增到快速列表
dialog.title.add.new.value=新增新值
dialog.title.attach.project.error=無法附加專案
dialog.title.auto.detected.proxy=自動檢測的代理
dialog.title.background.image=背景圖像
dialog.title.can.t.create.0.sdk=無法建立 {0} SDK
dialog.title.cannot.execute.command=無法執行指令
dialog.title.cannot.open.file=無法開啟檔案
dialog.title.change.group.name=更改組名
dialog.title.change.project.icon=Set Custom Project Icon
dialog.title.check.proxy.settings=檢查代理設定
dialog.title.choose.color=選擇顏色
dialog.title.choose.encoding.for.the.0=選擇 ''{0}'' 的編碼
dialog.title.choose.plugins.to.install.or.enable=選擇要安裝或啟用的延伸模組
dialog.title.clear.read.only.file.status=清除唯讀狀態
dialog.title.collect.troubleshooting.information=收集故障排除資訊
dialog.title.color.picker=取色器
dialog.title.configuration.changed=組態已更改
dialog.title.convert.module=轉換模組
dialog.title.convert.project=轉換專案
dialog.title.create.new.project.group=建立新項目組
dialog.title.custom.debug.log.configuration=自訂偵錯日誌組態
dialog.title.customize.0=自訂 {0}
dialog.title.data.sharing=資料共享
dialog.title.delete.0=刪除 {0}
dialog.title.dependent.plugins.found=找到相依的延伸模組
dialog.title.dimension.editor=尺寸編輯器
dialog.title.disable.dependent.plugins=停用相依延伸模組
dialog.title.edit.laf.defaults=編輯 LaF 預設值
dialog.title.enable.required.plugins=啟用必需延伸模組
dialog.title.error.saving.project=儲存專案時出錯!
dialog.title.error.writing.file=寫入檔案時錯誤
dialog.title.experimental.features=實驗性功能
dialog.title.export.to.file=匯出到檔案
dialog.title.failed.to.perform.operation=執行動作失敗
dialog.title.file.0.can.t.be.reloaded=無法以 ''{1}'' 編碼重新載入檔案 ''{0}''。{2}
dialog.title.file.0.most.likely.isn.t.stored=檔案 ''{0}'' 可能未以 ''{1}'' 編碼存儲。{2}
dialog.title.font.size.editor=字號編輯器
dialog.title.go.to.line.column=轉到行:列
dialog.title.gray.filter.editor=灰色篩選器編輯器
dialog.title.http.proxy.exceptions=代理異常
dialog.title.import=匯入
dialog.title.insets.editor=插入編輯器
dialog.title.install.plugin=安裝延伸模組
dialog.title.installing.plugin=正在安裝延伸模組 {0}
dialog.title.invalid.input=輸入無效
dialog.title.invalidate.caches=清除快取
dialog.title.jcef.proxyAuthentication=代理身份驗證
dialog.title.migrating.plugins=正在遷移延伸模組
dialog.title.new.tag.name=新增標記名稱
dialog.title.non.project.files.protection=非專案檔案保護
dialog.title.number.editor=數字編輯器
dialog.title.plugin.updates=延伸模組更新
dialog.title.proxy.authentication=代理身份驗證: {0}
dialog.title.proxy.setup=代理設定
dialog.title.recover.vfs.from.logs=從動作日誌恢復快取
dialog.title.remove.recent.project=移除最近的專案
dialog.title.reopen.project=重新開啟專案
dialog.title.required.plugin=必需延伸模組
dialog.title.restart.ide=重啟?
dialog.title.restart.required=需要重啟
dialog.title.save.as=另存為
dialog.title.save.project.to.directory.based.format=將專案儲存為基於目錄的格式
dialog.title.select.0=選擇 {0}
dialog.title.third.party.software={0} {1} 使用的第三方軟體
dialog.title.unable.to.save=無法儲存
dialog.title.untrusted.server.s.certificate=不可信伺服器的憑證
dialog.title.updating.plugin=正在更新延伸模組 {0}
dialog.title.vagrant.support.disabled=已停用 Vagrant 支援
diff.dialog.title=''{0}'' 與 ''{1}'' 之間的差異
directory.message.cant.create.folder=無法建立名為 ''{0}'' 的目錄
directory.project.location.description=為專案選擇基目錄
directory.project.location.label=位置(&L):
directory.project.location.title=選擇基目錄
display.balloon.notifications=顯示氣球通知
display.name.firefox.settings=Firefox 設定
dnd.with.alt.pressed.only=僅按下 Alt 時拖放
do.not.ask.me.again=不再詢問
double.ctrl.or.shift.shortcut=雙擊 {0}
dumb.balloon.0.is.not.available.while.indexing=編制索引期間 {0} 不可用
dumb.balloon.none.of.the.following.actions.are.available.during.indexing.0=編制索引期間以下動作均不可用: {0}
dumb.balloon.this.action.is.not.available.during.indexing=編制索引期間此動作不可用
dumb.mode.results.might.be.incomplete=編制索引時，結果可能不完整
dumb.mode.spoiler.wrapper.reload.text=重新載入結果
dumb.service.indexing.paused.due.to=由於{0}，索引編制暫停
dump.focusable.component.hierarchy.close.button=關閉並複製到剪貼簿
editbox.customfiletype.block.comment.end=塊註釋結束:
editbox.customfiletype.block.comment.start=塊註釋開始:
editbox.customfiletype.description=描述:
editbox.customfiletype.hex.prefix=十六進制前綴:
editbox.customfiletype.line.comment=行註釋:
editbox.customfiletype.name=名稱:
editbox.customfiletype.number.postfixes=數字後綴:
editbox.default.encoding.for.properties.files=屬性檔案的預設編碼:
editbox.export.to.file=匯出到檔案:
editbox.plugin.description=描述
editor.banner.close.tooltip=關閉
editor.tabs.always.keep.sorting=始終保持啟用排序
editor.tabs.enable.sorting=啟用排序
empty.project.generator.description=不帶模組的專案。用它來建立自由樣式的模組結構。將開啟“專案結構”對話框，幫助您建置專案結構。
empty.project.generator.name=多模組專案
empty.text.drop.files.to.open=將檔案拖放到此處以開啟
empty.text.go.to.file=轉到檔案
empty.text.navigation.bar=導覽列
empty.text.no.entries=無條目
empty.text.no.features.available=無可用功能
empty.text.no.project.open.yet=尚無專案開放
empty.text.nothing.found=找不到任何內容
empty.text.nothing.selected=未選擇任何內容
empty.text.project.view=專案檢視
empty.text.recent.files=最近的檔案
empty.text.search.everywhere=隨處搜尋
empty.text.this.view.is.not.available.until.indices.are.built=在建置索引前，此檢視不可用
encoding.do.not.convert.message=請勿轉換到 ''{0}''。
encoding.name.properties.default=<屬性預設值: {0}>
encoding.name.system.default=<系統預設: {0}>
encoding.not.available=不適用
encoding.unsupported.characters.message=編碼 ''{0}'' 不支持文本中的某些字元。
encodings.dialog.caption=<html>要更改 {0} 為檔案、目錄或整個專案使用的編碼，請根據需要新增其路徑，然後從編碼列表中選擇編碼。內建檔案編碼(例如JSP、HTML 或 XML)會覆寫您在此處指定的編碼。如果未指定，檔案和目錄將從父目錄或“專案編碼”繼承編碼設定。</html>
error.0.browser.path.not.specified={0}瀏覽器路徑未指定。
error.cannot.convert.project=無法轉換專案: {0}
error.cannot.create.temp.dir=無法建立臨時目錄 ''{0}''
error.cannot.load.project=無法載入專案: {0}
error.cannot.set.look.and.feel=<html><body>無法設定{0}主題:<br>{1}</body></html>
error.connection.failed=連線失敗
error.descriptor.load.failed=無法從{0}載入延伸模組檔案描述子。所選檔案可能不是 IntelliJ 延伸模組。
error.dir.contains.no.project=''{0}'' 不包含專案
error.directory.with.name.already.exists=名稱為 ''{0}'' 的目錄已存在
error.download.plugin.via.blockmap=無法通過塊映射下載延伸模組。正在從 {0} 下載整個歸檔
error.downloaded.descriptor.load.failed=無法從下載的歸檔載入延伸模組檔案描述子。歸檔可能不是 IntelliJ 延伸模組。
error.empty.name=名稱不得為空
error.failed.to.create.directory=無法建立目錄“{0}”
error.favorites.list.already.exists=收藏夾列表 ''{0}'' 已存在
error.file.does.not.exist=檔案 {0} 不存在。
error.file.not.found.message=檔案 ''{0}'' 不存在
error.file.with.name.already.exists=名稱為 ''{0}'' 的檔案已存在
error.files.of.this.type.cannot.be.opened=無法在{0}中開啟此類型的檔案
error.filter.name.should.be.specified=應指定篩選器名稱
error.filter.should.contain.at.least.one.pattern=篩選器應至少包含一個模式
error.filter.with.the.same.name.already.exists=具有相同名稱的篩選器已存在
error.group.already.exists=組 ''{0}'' 已存在。
error.incompatible.update=下載的版本與當前 IDE 不相容: {0}
error.invalid.directory=無效目錄: ''{0}''
error.invalid.directory.name=''{0}'' 不是有效的目錄名稱
error.invalid.file.name=''{0}'' 是無效的檔名
error.invalid.java.package.name=無效的軟體套件名稱；無法在內部建立 Java 類別
error.invalid.java.package.name.format=無效的軟體套件名稱格式設定；無法在內部建立 Java 類別
error.invalid.template.file.name.or.extension=無效的模板檔名或副檔名
error.loading.package.list=載入軟體套件列表時出錯: {0}
error.malformed.url=URL 格式錯誤: {0}
error.message.cannot.make.files.writable=無法解鎖以下檔案:\\n{0}
error.message.cannot.modify.file.0=無法修改檔案 ''{0}''
error.message.exception.was.thrown=拋出了異常
error.message.unable.to.create.file=無法建立檔案 ''{0}''
error.module.already.exists=名為 ''{0}'' 的模組已存在
error.name.already.exists=名稱已被使用。請更改為唯一名稱。
error.name.cannot.be.empty=名稱不能為空
error.name.should.be.specified=必須指定名稱
error.no.plugins.found=未找到延伸模組。檢查日誌檔案中有無錯誤。
error.occurred.please.check.your.internet.connection=出錯了。請檢查您的互聯網連線。
error.older.update=下載的版本({0})比當前安裝的版本({1})舊。
error.package.with.name.already.exists=名稱為 ''{0}'' 的軟體套件已存在
error.parsing.file.template=解析檔案模板時出錯: {0}
error.pattern.should.be.specified=應指定模式
error.pending.update=延伸模組“{0}”的另一個更新正在等待安裝。請重啟，然後重試。
error.please.enter.a.file.name=指定檔名
error.please.specify.path.to.web.browser=在“{0} | Web 瀏覽器”中指定 Web 瀏覽器路徑
error.please.specify.template.name=指定模板名稱
error.plugin.required.for.project.disabled=''{1}'' 專案所需延伸模組 ''{0}'' 已停用。
error.plugin.required.for.project.not.installed=''{1}'' 專案所需延伸模組 ''{0}'' 未安裝。
error.plugin.was.not.installed=延伸模組“{0}”未安裝: {1}
error.project.file.does.not.exist=無法載入 {0}。該檔案不存在。
error.project.requires.newer.ide=專案 ''{0}'' 需要 IDE 的 {1}''{2}'' 或更新的建置，但當前建置為 ''{3}''。
error.project.requires.newer.plugin=專案 ''{0}'' 需要延伸模組 ''{1}'' 版本 ''{2}'' 或更高版本，但已安裝的是 ''{3}''。
error.project.requires.older.ide=專案 ''{0}'' 需要 IDE 的 {1}''{2}'' 或更老的建置，但當前建置為 ''{3}''。
error.project.requires.older.plugin=專案 ''{0}'' 需要延伸模組 ''{1}'' 版本 ''{2}'' 或更低版本，但已安裝的是 ''{3}''。
error.same.pattern.already.exists=一些模式已存在
error.saving.statistics=儲存系統資訊時出錯: {0}
error.text.file.already.exists=檔案 {0} 已存在。\\n希望覆蓋還是追加?
error.tips.not.found=找不到每日小技巧。確保已正確安裝 {0}。
error.tree.view.cell.error=錯誤: {0}
error.tree.view.fix.description=修復: {0}
error.tree.view.fixing=正在修正…
error.unable.to.parse.template.message=無法解析模板“{0}”，\\n錯誤訊息: {1}
error.unable.to.read.tip.of.the.day=<html><body>無法讀取每日小技巧({0})。確認已正確安裝 {1}。</body></html>
error.updating.package.list=更新軟體套件列表時出錯: {0}
error.user.home.directory.not.found=未找到使用者主目錄
error.writing.to.file=寫入檔案時出錯: {0}
errortree.error=錯誤:
errortree.information=資訊:
errortree.noMessages=沒有訊息
errortree.note=注意:
errortree.prefix.line=行({0})
errortree.warning=警告:
essential-highlighting.mode.disable.action.title=停用基本醒目提示顯示模式
essential-highlighting.mode.on.notification.content=基本醒目提示模式只保留一組有限的程式碼醒目提示工具。包括檢查在內的所有醒目提示工具都將在執行檔案儲存動作時執行。
essential-highlighting.mode.on.notification.title=基本醒目提示模式已開啟
external.link.confirmation.message.0=確定要在瀏覽器或關聯的應用程式中開啟此連結嗎?<br><br>{0}
external.link.confirmation.title=開啟連結
external.link.confirmation.trust.label=信任專案並開啟
external.link.confirmation.yes.label=開啟
failed.to.install.package.dialog.title=無法安裝 ''{0}''
failed.to.install.packages.dialog.title=無法安裝軟體套件
failed.to.take.thread.dump=無法獲取執行緒傾印。
failed.to.unload.modified.plugins=無法移除修改的延伸模組: {0}
favorites.list.unnamed=未命名的{0}
file.changed.externally.message=檔案在磁碟上已被更改。
file.changed.externally.reload=重新載入
file.chooser.completion.ad.text=使用 {0} 保留路徑尾部
file.chooser.completion.no.suggestions=無建議
file.chooser.completion.path.variables.text=路徑變數
file.chooser.hide.path=隱藏路徑
file.chooser.show.path=顯示路徑
file.encoding.option.create.utf8.files=建立 UTF-8 檔案:
file.encoding.option.encoding.column=編碼
file.encoding.option.global.encoding=全域編碼
file.encoding.option.path.column=路徑
file.encoding.option.project.encoding=專案編碼
file.encoding.option.warning.always={0} 會將 <a href="https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8">UTF-8 BOM</a> 新增到使用 UTF-8 編碼建立的每個檔案中
file.encoding.option.warning.never={0} 不會將 <a href="https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8">UTF-8 BOM</a> 新增到每個以 UTF-8 編碼建立的檔案中
file.encoding.option.warning.windows.only={0} 只會在每個建立的 UTF-8 檔案在 Windows 下執行時向其新增 <a href="https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8">UTF-8 BOM</a>
file.encodings.configurable=檔案編碼
file.encodings.not.configured=未組態編碼
file.nesting.dialog.title=檔案嵌套
file.nesting.feature.enabled.checkbox=以嵌套形式顯示具有相同名稱的檔案(&S)
file.nesting.reset.to.default.button=重設為預設(&R)
file.nesting.table.title=嵌套規則:
file.read.error=無法讀取檔案 {0}。
file.read.error.details=無法讀取檔案 {0}: {1}
file.write.error=檔案{0}無法寫入。
file.write.error.details=無法寫入檔案 {0}: {1}
filetype.gui.designer.form.description=GUI 設計器表單
filetype.gui.designer.form.display.name=GUI 設計器表單
filetype.scalable.vector.graphics.description=可縮放矢量圖形
filetype.scalable.vector.graphics.display.name=可縮放矢量圖形
filetype.search.everywhere.directory.description=檔案系統目錄
filetype.web.preview.description=用於嵌入式瀏覽器中的檔案預覽
filetype.web.preview.display.name=Web 預覽
find.ide.update.title=尋找 IDE 更新
fixed.problem.prefix=已修復:
focus.debugger.label.newvalue=新值=
focus.debugger.label.oldvalue=舊值=
font.info.renderer.non.latin=非拉丁語
font.reset.link=重設為預設
gdpr.checkbox.when.using.eap.versions=使用 EAP 版本時{0}
gdpr.continue.button=繼續
gdpr.exit.button=退出
gdpr.hint.text.apply.to.all.installed.products=資料共享偏好設定適用於所有已安裝的 {0} 產品。
gdpr.hint.text.you.can.always.change.this.behavior=您隨時可以在“{0} | 外觀與行為 | 系統設定 | 資料共享”中更改此行為。
gdpr.label.there.are.no.data.sharing.options.available=沒有可用的資料共享選項
gdpr.usage.statistics.disabled.externally.warning=Toolbox Enterprise 延伸模組已暫時停用發送使用統計資訊。
general.module.type.description=一個允許使用單獨的檔案並編譯 Java 和 Kotlin 類別的基本專案。
github.project.generator.version=版本(&V):
github.project.generator.versions.not.loaded.error=尚未載入版本。
go.to.class.action.description=按名稱快速導覽到{0}
go.to.class.dumb.mode.message=在建置索引前，轉到 {0} 動作不可用，改用轉到檔案
go.to.class.kind.text=類別
go.to.class.kind.text.pluralized=類別
go.to.class.title.prefix=轉到{0}
got.it.button.name=知道了
goto.custom.region.command=轉到自訂折疊
goto.custom.region.menu.item=自訂折疊…
goto.custom.region.message.dumb.mode=在建置索引前，自訂折疊導覽不可用。
goto.custom.region.message.unavailable=當前檔案中沒有自訂的折疊
goto.inspection.action.choose.inherit.settings.from=檢查選項
goto.inspection.action.dialog.title=執行 ''{0}''
goto.inspection.action.fix.all=全部修正
goto.inspection.action.text=通過名稱執行檢查(&R)…
group.antialiasing.mode=抗鋸齒
group.customfiletype.syntax.highlighting=語法醒目提示
group.customizations.add.action.group=新增動作…
group.customizations.restore.action.group=還原動作…
group.presentation.mode=示範模式
group.settings.process.tab.close=關閉具有執行程序的工具視窗時:
group.todo.filter.patterns=模式
group.transparency=透明度
group.ui.options=UI 選項
group.vendor=供應商
group.view.options=檢視選項
group.window.options=工具視窗
handle.ro.file.status.failed=<html>無法更改以下檔案的唯讀狀態:<br>{0}</html>
handle.ro.file.status.type.using.file.system=使用檔案系統
hashes.doesnt.match=還原的歸檔的雜湊與原始歸檔的雜湊不符合
hierarchy.call.next.occurence.name=轉到下一個呼叫
hierarchy.call.prev.occurence.name=轉到上一個呼叫
hierarchy.legend.method.defined.in.superclass=方法未在類別中定義，但在其超類別中定義
hierarchy.legend.method.is.defined.in.class=方法已在類別中定義
hierarchy.legend.method.should.be.defined=必須定義方法，因為類別不為 abstract
hierarchy.method.next.occurence.name=轉到下一個方法
hierarchy.method.prev.occurence.name=轉到上一個方法
hierarchy.type.next.occurence.name=轉到下一個類型
hierarchy.type.prev.occurence.name=轉到上一個類型
highlighting.pass.injected.presentable.name=注入的片段
hint.scheme.editing=按 Enter 儲存，按 Esc 取消
hint.text.all.lines.already.have.requested.indentation=所有行都已請求縮排
hint.text.changed.indentation.in=已更改{0,choice,1#行|2#行}中的縮排
http.editor.name=HTTP
http.multirange.response.doesnt.contain.boundary=HTTP 多範圍響應邊界線 {0} 不包含邊界 {1}
http.multirange.response.doesnt.include.line.separator=HTTP 多範圍響應不包含行分隔符
http.multirange.response.includes.incorrect.header=HTTP 多範圍響應包含不正確的頭 - {0}，應為 {1}
http.proxy.configurable=HTTP 代理
http.velocity={0}<hr> <font face="verdana" size="-1"><a href=''http://velocity.apache.org/engine/devel/user-guide.html#Velocity_Template_Language_VTL:_An_Introduction''>\\nApache Velocity</a> 模板語言已使用</font>
icon.debugger.db_array.tooltip=陣列
icon.debugger.db_obsolete.tooltip=過時的框架
icon.debugger.db_primitive.tooltip=基元類型的值
icon.debugger.db_watch.tooltip=監視
icon.debugger.frame.tooltip=框架
icon.debugger.selfreference.tooltip='this' 的參照
icon.debugger.threadAtBreakpoint.tooltip=中斷點處的執行緒
icon.debugger.threadCurrent.tooltip=當前執行緒
icon.debugger.threadFrozen.tooltip=凍結執行緒
icon.debugger.threadGroup.tooltip=執行緒組
icon.debugger.threadGroupCurrent.tooltip=當前線程組
icon.debugger.threadRunning.tooltip=正在執行的執行緒
icon.debugger.threadSuspended.tooltip=暫停的執行緒
icon.debugger.value.tooltip=值
icon.debugger.watchLastReturnValue.tooltip=最後一個方法呼叫的返回值
icon.fileTypes.archive.tooltip=歸檔檔案
icon.fileTypes.custom.tooltip=自訂類型的檔案
icon.fileTypes.diagram.tooltip=圖表檔案
icon.fileTypes.java.tooltip=Java 檔案
icon.fileTypes.javaClass.tooltip=Java 編譯的位元組碼檔案
icon.fileTypes.javaOutsideSource.tooltip=來來源根之外的 Java 檔案
icon.fileTypes.json.tooltip=JSON 檔案
icon.fileTypes.jsonSchema.tooltip=JSON 架構檔案
icon.fileTypes.manifest.tooltip=清單檔案
icon.fileTypes.properties.tooltip=屬性檔案
icon.fileTypes.unknown.tooltip=未知類型的檔案
icon.fileTypes.xml.tooltip=XML 檔案
icon.fileTypes.yaml.tooltip=YAML 檔案
icon.modules.excludeRoot.tooltip=排除的目錄
icon.modules.excludedGeneratedRoot.tooltip=排除的生成來源根
icon.modules.generatedFolder.tooltip=生成的目錄
icon.modules.generatedSourceRoot.tooltip=生成的來源根
icon.modules.generatedTestRoot.tooltip=生成的測試來源根
icon.modules.output.tooltip=輸出根
icon.modules.resourcesRoot.tooltip=資源根
icon.modules.sourceRoot.tooltip=來來源根
icon.modules.testResourcesRoot.tooltip=測試資源根
icon.modules.testRoot.tooltip=測試來來源根
icon.modules.unloadedModule.tooltip=已移除的模組
icon.nodes.Module.tooltip=模組
icon.nodes.abstractClass.tooltip=抽象類別
icon.nodes.abstractException.tooltip=abstract 異常
icon.nodes.abstractMethod.tooltip=abstract 方法
icon.nodes.annotationtype.tooltip=註解類型
icon.nodes.anonymousClass.tooltip=匿名類別
icon.nodes.c_plocal.tooltip=package-local
icon.nodes.c_private.tooltip=private
icon.nodes.c_protected.tooltip=protected
icon.nodes.c_public.tooltip=public
icon.nodes.class.tooltip=類別
icon.nodes.classInitializer.tooltip=類別初始設定式
icon.nodes.enum.tooltip=枚舉
icon.nodes.exceptionClass.tooltip=異常類別
icon.nodes.excludedFromCompile.tooltip=已從編譯中排除
icon.nodes.field.tooltip=欄位
icon.nodes.finalMark.tooltip=final
icon.nodes.folder.tooltip=目錄
icon.nodes.ideaModule.tooltip=IntelliJ 模組檔案
icon.nodes.interface.tooltip=接口
icon.nodes.junitTestMark.tooltip=單元測試
icon.nodes.locked.tooltip=唯讀
icon.nodes.method.tooltip=方法
icon.nodes.moduleGroup.tooltip=模組組
icon.nodes.nodePlaceholder.tooltip=
icon.nodes.package.tooltip=軟體套件
icon.nodes.parameter.tooltip=參數
icon.nodes.ppJdk.tooltip=JDK
icon.nodes.ppLib.tooltip=外部庫
icon.nodes.runnableMark.tooltip=可執行
icon.nodes.staticMark.tooltip=static
icon.runConfigurations.testError.tooltip=意外異常
icon.runConfigurations.testFailed.tooltip=斷言失敗
icon.runConfigurations.testIgnored.tooltip=測試已忽略
icon.runConfigurations.testNotRan.tooltip=測試未開始
icon.runConfigurations.testPassed.tooltip=測試通過
icon.runConfigurations.testSkipped.tooltip=測試已跳過
icon.runConfigurations.testTerminated.tooltip=測試已終止
icon.validation.message.format=圖示格式不正確
icon.validation.message.not.found=該圖示不存在
ide.notnow.action=以後再說
ide.postpone.action=推遲
ide.protocol.cannot.title=無法開啟 URI
ide.protocol.exception=內部錯誤: {0}: {1}
ide.protocol.internal.bad.query=不正確的查詢字串: ''{0}''
ide.protocol.progress.title=正在開啟 URI
ide.protocol.unsupported=不支持的協議: ''{0}''
ide.restart.action=重啟
ide.restart.required.comment=需要重新啟動
ide.restart.required.message={0}{1}以套用延伸模組中的更改?
ide.restart.required.notification={0, choice, 0#關閉|1#重啟}以啟用延伸模組更新
ide.scale.reset.link=重設為預設
ide.shutdown.action=關閉
idea.intellij.look.and.feel=IntelliJ Light 舊版
implicit.log.directory.path=似乎您正在使用 ''idea.system.path'' 屬性指定快取目錄的位置。在 2020.1 中，應用程式目錄的預設位置已更改。為確保兼容性，IDE 選擇了日誌的舊位置({0})，但為了避免將來出現任何歧義(並去除此警告)，另請設定 ''idea.log.path'' 屬性。
implicit.plugin.directory.path=似乎您正在使用 ''idea.config.path'' 屬性指定設定目錄的位置。在 2020.1 中，應用程式目錄的預設位置已更改。為確保兼容性，IDE 選擇了延伸模組的舊位置({0})，但為了避免將來出現任何歧義(並去除此警告)，另請設定 ''idea.plugins.path'' 屬性。
incompatible.encoding.dialog.title=不相容的編碼: {0}
information.hint.accessible.context.name=提示
inline.actions.more.actions.text=更多動作
inspection.message.inspection.info=檢查資訊
install.package.failure=安裝軟體套件 ''{0}'' 時發生錯誤。<a href="xxx">詳細資訊…</a>
intention.family.editor.notification=編輯器通知
intention.family.editor.notification.option=編輯器通知選項
intention.family.editor.notification.settings=編輯器通知設定
internal.decorator.accessible.postfix=工具視窗
interpreter.default.name=遠端 {0} 解釋器
invalid.node.text=無效
invalidate.all.caches.recovery.action.name=清除快取並重啟
invalidate.workspace.model.recovery.action.presentable.name=重新開啟專案
javascript.debugger.settings.choose.file.subtitle=選擇要偵錯其中的 JavaScript 的網頁
javascript.debugger.settings.choose.file.title=選擇
jb.protocol.navigate.missing.parameters=URL 中既沒有指定 'project' 參數，也沒有指定 'origin' 參數
jb.protocol.navigate.no.project=找不到或無法開啟指定的專案
jb.protocol.navigate.target=''navigate'' 指令僅支援 ''reference'' 目標(找到 ''{0}'')
jb.protocol.parameter.missing=缺少參數: ''{0}''
jb.protocol.settings.no.configurable=找不到設定頁面: ''{0}''
jb.protocol.unknown.command=未知指令: ''{0}''
jb.protocol.unknown.target=未知目標: ''{0}''
jcef.local.cache.invalidate.action.description=刪除嵌入式瀏覽器引擎快取和 Cookie。此動作可能會影響使用嵌入式瀏覽器呈現基於 HTML 的內容和網頁的元件。
jcef.local.cache.invalidate.checkbox.description=刪除嵌入式瀏覽器引擎快取和 Cookie
jcef.local.cache.invalidate.failed.message=清除快取動作請求了嵌入式瀏覽器引擎快取清理。由於 I/O 錯誤，動作失敗: {0}
jcef.local.cache.invalidate.failed.title=無法清理瀏覽器引擎快取
jetbrains.certificate.invalid=JetBrains 憑證無效。請聯繫 JetBrains 支援人員。
jetbrains.certificate.not.found=找不到 JetBrains 憑證。
jetbrains.certificate.vendor=供應商: {0}
keymap.action.configure.keymap=組態按鍵映射…
keymap.action.install.keymap=安裝按鍵映射…
label.appearance.caret.blinking=外觀: 文字游標閃爍
label.appearance.show.inner.whitespaces=外觀: 顯示內部空格
label.appearance.show.leading.whitespaces=外觀: 顯示前導空格
label.appearance.show.right.margin=外觀: 顯示右邊距
label.appearance.show.trailing.whitespaces=外觀: 顯示尾隨空格
label.appearance.show.vertical.indent.guides=外觀: 顯示垂直縮排參考線
label.autosave.comment=無法完全停用自動儲存。<a>工作原理</a>
label.category.n.a=不適用
label.category.unknown=未知
label.certificate.expired=已過期
label.certificate.not.yet.valid=尚未生效
label.certificate.root=<根>
label.certificate.will.be.saved=接受的憑證將被儲存在信任庫 {0} 中，預設密碼為 {1}
label.change.list.for.unlocked.files=\\   更改列表(&L):
label.choose.color.scheme.importer=選擇 {0}
label.choose.target.file=選擇目標檔案
label.choosebyname.no.matches.found=未找到符合
label.choosebyname.searching=正在搜尋…
label.chrome.command.line.options=命令行選項(&C):
label.continue.editing=繼續編輯
label.description=描述:
label.dont.show=不再顯示
label.downloading.cancelled=下載已取消
label.downloading.file.started=下載已開始
label.empty.file.name=<空檔名>
label.empty.text.attach.directories.with.right.click=通過右鍵點擊附加目錄
label.enable.debug.level=啟用日誌類別的 DEBUG 級別(每行一個)。<br>向類別追加 ''{0}'' 後綴以啟用 TRACE 級別，或者追加 ''{1}'' 後綴以啟用所有級別。<br><br>
label.enter.group.name=輸入組名:
label.enter.new.abbreviation=輸入新縮寫:
label.enter.new.font.size.for.0=輸入 {0} 的新字號
label.extension=擴展(&E):
label.file.name=檔名:
label.font.name=字體:
label.font.size=大小:
label.generate.file.name=檔名(&F):
label.i.want.to.edit.choice=IDE 重啟前允許編輯:
label.icon.path=圖示(&I):
label.inactive.timeout.sec=秒
label.install.a.limited.functionality.for.free=使用免費版本或
label.invalid.color=<無效>
label.line.column=[行] [:列]:
label.macro.recording.started=巨集錄製已開始…
label.maximum.version=最高版本:
label.milliseconds=毫秒
label.minimum.version=最低版本:
label.more.files=和其他{0, choice, 1#1 個檔案|2#{0} 個檔案}
label.name=名稱(&N):
label.new.version.will.be.available.after.restart=新版本將在重啟後可用
label.next.plugin.version.is=通過此更新，延伸模組將變為
label.no.actions.found=未找到動作
label.no.enabled.actions.found=未找到已啟用的動作
label.no.files.found=未找到檔案
label.no.matches.found=未找到符合
label.offset=偏移:
label.option.appearance=外觀: {0}
label.password.safe.password=密碼(&P)
label.password.safe.user=使用者(&U)
label.plugin=延伸模組:
label.plugin.0.downloads={0} 次下載
label.plugin.change.notes=更改說明
label.plugin.downloads=下載
label.plugin.freemium=免費增值
label.plugin.last.updated=上次更新
label.plugin.paid=付費
label.plugin.status=狀態
label.plugin.updated.0=已更新 {0}
label.plugin.vendor.email=電子郵件:
label.plugin.vendor.name=名稱:
label.project.files.location=專案位置(&L):
label.project.icon.for.darcula.theme=深色主題:
label.project.icon.for.default.theme=淺色主題:
label.project.name=專案名稱(&A):
label.remote.sdk.helpers.path=幫助程序路徑:
label.remote.sdk.name=名稱(&N):
label.remote.sdk.python.interpreter.path=Python 解釋器路徑:
label.scope=作用域(&S):
label.scope.contains.files=作用域包含 {0} 個檔案，共 {1} 個
label.scope.editor.caret.position=位置: {0}
label.scope.pattern=模式(&P):
label.select.configuration.element=選擇樹中的組態元素以編輯其設定
label.show.block.cursor=顯示塊游標
label.show.line.numbers=顯示行號
label.show.status.bar.widget=顯示 {0}
label.show.whitespaces=顯示空格
label.smooth.scrolling.bezier.panel.updates=每秒繪製請求數: {0}
label.smooth.scrolling.duration=持續時間
label.ssl.certificate.details=憑證詳細資訊
label.start.search.in.background=在背景開始搜尋
label.text.antialiasing.scope.editor=編輯器:
label.text.antialiasing.scope.ide=IDE:
label.text.character.count={0} 個字元
label.text.code.completion.saved=自 {1} 以來，程式碼補全至少為您節省了 {0}的輸入時間(每個工作日約 {2})
label.text.html.center.drop.here.to.attach.br.as.a.root.directory.center.html=<html><center>拖放至此處<br/>以作為根目錄附加</center></html>
label.text.image=圖片:
label.text.opacity=不透明度:
label.text.path.to.profiles.ini="profiles.ini" 的路徑:
label.text.plugin.eap.license.not.required=EAP 版本不需要授權
label.text.plugin.no.license=無授權。
label.text.profile=使用者組態(&P):
label.text.put.stacktrace.here=在此放置一個堆疊追蹤:
label.text.quick.fixes.saved=自 {1} 以來，快速修復使您避免了 {0} 個可能的錯誤(每個工作日約 {2} 個)
label.todo.filter.name=名稱:
label.todo.filters=篩選器:
label.todo.icon=圖示:
label.todo.multiline=將以下行中的縮排文本視為同一 TODO 的一部分
label.todo.pattern=模式:
label.todo.patterns=模式:
label.transparency.delay.ms=延遲(毫秒):
label.transparency.ratio=比例:
label.ui.filter=篩選:
label.ui.name=名稱:
label.ui.value=值:
label.use.the.trial.for.up.to.30.days.or=使用 30 天試用版或
label.valid.from=生效起始日期:
label.valid.until=有效期至
label.version=版本: {0}
label.version.0.1.build.2={0} {1} 構建版本 {2}
label.version.any=<any>
label.welcome.to.0=歡迎來到 {0}
label.you.can.create.a.desktop.entry=<html>您可以建立桌面條目，以便從系統選單輕鬆啟動 $APP_NAME$ <br>並更好地進行桌面整合。<html>
laf.action.install.theme=安裝主題…
large.file.editor.name=大檔案編輯器
large.file.preview.notification=檔案太大({0})。正在顯示第一個 {1} 的唯讀預覽。
link.cancel=取消
link.change.icon=更改…
link.change.project.icon=選擇 SVG 檔案…
link.change.project.icon.description=SVG 檔案將儲存到 .idea 目錄。<br/>要共享專案圖示，請將其新增到儲存庫。
link.check=檢查
link.enable.required.plugin=啟用 {0}
link.enable.required.plugins=啟用必需延伸模組
link.get.more.themes=獲取更多主題
link.hide.processes=隱藏程序({0})
link.install.required.plugins=安裝必需延伸模組
link.just.restart=重啟
link.label.wizard.step.plugin.customize=自訂…
link.more=更多…
link.reset.icon=重設
link.reset.project.icon=重設
link.show.all.processes=全部顯示({0})
link.smooth.scrolling.play.curve.animation=<a>播放此曲線的動畫</a>
link.smooth.scrolling.stop.curve.animation=<a>停止此曲線的動畫</a>
list.item.temporary.file.0=<temporary file>{0}
listbox.customfiletype.keywords=關鍵字
loading.in.progress=<html><body style='text-align: center;padding-top:20px;'>正在載入…</body></html>
log.in.link.text=登入…
login.dialog.authorization.token.field=IDE 授權令牌
login.dialog.back.link=← 返回
login.dialog.check.token=檢查令牌
login.dialog.eap.info.link=關於 EAP
login.dialog.empty.username=已登入
login.dialog.jb.login=登入 JetBrains Account
login.dialog.link.copied=連結已複製
login.dialog.log.out=退出登入…
login.dialog.manage.account=管理帳戶
login.dialog.manual.login=使用瀏覽器登入 JetBrains Account
login.dialog.new.user.label=新用戶?
login.dialog.register.link=建立帳戶
login.dialog.separator.text=或使用以下方式登入:
login.dialog.session.expired=授權會話已過期。請再次啟動
login.dialog.simple.login=登入 JetBrains Account
login.dialog.start.using=開始
login.dialog.title={0}
login.dialog.trouble.default.message=無法完成授權過程。
login.dialog.trouble.no.link={0}<br>有關可能的解決方案，請參閱<a href="{1}">幫助文章</a>。<br>如需幫助，請<a href="{2}">聯繫技術支援團隊</a>。
login.dialog.trouble.unknown=<a href="{0}">複製連結</a>並在瀏覽器中開啟，以獲取 IDE 授權令牌。
login.dialog.trouble.with.redirect=登入到您的帳戶並複製 IDE 授權令牌。<br/>如果瀏覽器未開啟，則 <a href="{0}">複製連結</a>並手動開啟。
login.dialog.troubles.link=有問題嗎?
login.dialog.waiting.for.login=正在等待在瀏覽器中登入…
login.dialog.waiting.for.login.short=正在等待登入…
login.dialog.welcome.to.eap=歡迎來到 {0} EAP
login.dialog.wrong.token=授權令牌錯誤
login.dialog.you.are.logged=您已登入
low.disk.space.message=系統目錄分區(''{0}'')上的剩餘空間少於 50 MiB
low.disk.space.title=磁碟空間不足
low.memory.notification.action=組態
low.memory.notification.analyze.action=分析記憶體使用情況
low.memory.notification.error=IDE 可用記憶體不足。請考慮增大“{0}”設定的值。
low.memory.notification.title=記憶體不足
low.memory.notification.warning=IDE 記憶體不足，這可能會影響性能。請考慮增加堆大小。
mac.window.tabs.close.other.tabs=關閉其他頁籤
mac.window.tabs.close.tab=關閉頁籤
mac.window.tabs.close.title=點擊以關閉此頁籤。按住 Option 鍵點擊以關閉除此之外的所有頁籤
mac.window.tabs.move.tab=將頁籤移至新視窗
mac.window.tabs.show.all.tabs=顯示所有頁籤
macos.shortcut.conflict.few={0} 快捷鍵與 macOS 系統快捷鍵衝突。
macos.shortcut.conflict.many={0} 和 {1} 快捷鍵與 macOS 系統快捷鍵衝突。
main.startup.error=啟動錯誤
main.toolbar.menu.button=主選單
manage.repositories.dialog.title=管理儲存庫
meetnewui.toolwindow.button.finishSetup=完成安裝
meetnewui.toolwindow.button.startTour=開始快速導覽
meetnewui.toolwindow.clean=簡潔
meetnewui.toolwindow.compact=緊湊
meetnewui.toolwindow.density=密度:
meetnewui.toolwindow.description=在“設定 > 外觀與行為 > <a>新 UI</a>”中組態或停用新 UI。
meetnewui.toolwindow.system=系統
meetnewui.toolwindow.theme=主題:
meetnewui.toolwindow.title=認識新 UI
memory.snapshot.captured.action.text=在 {1} 中開啟 ''{0}''
memory.snapshot.captured.text=套件解除安裝失敗時捕獲記憶體快照
message.action.remove.system.assigned.shortcut=動作快捷鍵 {0} 已被分配給系統動作 ''{1}''。是否要移除此快捷鍵?
message.cannot.delete.0.1=無法刪除 ''{0}''，{1}
message.check.the.internet.connection.and=檢查互聯網連線並
message.connection.successful=連線成功
message.do.you.want.to.delete.0.1=是否要刪除“{0}”{1}?
message.link.refresh=重新整理
message.macro.exists=巨集 ''{0}'' 已存在。是否要覆蓋它?
message.module=模組 ''{0}''
message.module.file.has.an.older.format.do.you.want.to.convert.it=模組檔案為舊格式。是否要轉換?
message.modules=模組
message.move.modules.to.group=將 {0} 移至組 {1}
message.no.targets.available=在此上下文中沒有可用目標
message.occurrence.N.of.M=匹配項 {0}/{1}
message.path.to.fqn.has.been.copied=''{0}'' 已複製。
message.please.select.element.for.javadoc=選擇您想檢視其文檔的元素
message.project.will.be.saved.and.reopened.in.new.directory.based.format=專案將會儲存並以基於目錄的新格式重新開啟。確定要繼續嗎?
message.reference.to.fqn.has.been.copied=對 ''{0}'' 的參照已複製。
message.text.enter.url.to.check.connection=警告: 您的設定將被儲存。\\n輸入任意 URL 以檢查連線:
message.text.files.do.not.exist=<html><body>以下檔案不存在:<br>{0}相應的模組將不會轉換。是否要繼續?</body></html>
message.text.proxy.both.use.proxy.and.autodetect.proxy.set=代理: 同時設定了 'use proxy' 和 'autodetect proxy' 設定。應當只選擇其中一個選項。請重新組態。
message.text.proxy.passwords.were.cleared=已清除代理密碼。
message.text.unlock.read.only.files=<html><body>以下檔案為唯讀檔案。{0}將解鎖它們。<br>{1}</body></html>
message.the.path.0.does.not.exist.maybe.on.remote=路徑 {0} 不存在。\\n如果它位於可移動驅動器或網絡驅動器上，請確保該驅動器已連線。
message.there.are.no.available.schemes.to.import=沒有可供匯入的方案
message.this.action.isn.t.supported.on.the.current.platform=當前平台不支持此動作
message.this.functionality.is.not.available.during.indexing=編制索引期間此功能不可用
message.your.module.was.successfully.converted.br.old.version.was.saved.to.0=<html><body>您的模組已成功轉換。<br> 舊版本已儲存到 ''{0}''</body></html>
mixed.bag.installation=您的 {0} 安裝似乎已損壞，因為存在多個版本標記。當較新版本的歸檔被提取到包含現有安裝的目錄中時，通常就會發生這種情況。為避免出現崩潰，請從頭開始將 IDE 重新安裝到一個空目錄。
more.shortcuts.link.text.with.count=其他 {0}
name.invalid=無效
name.variable=在對話框中輸入的檔名
navigate.command.search.reference.progress.title=正在搜尋參照 ''{0}''
navigation.bar=導覽列
navigation.bar.item.sample=範例
new.dir.project.create=建立
new.dir.project.error.empty=專案路徑為空
new.dir.project.error.invalid=專案目錄路徑無效
new.plugin.manager.incompatible.deps.action=啟用所需{0, choice, 1#延伸模組|2#延伸模組}
new.plugin.manager.incompatible.deps.tooltip=未載入。所需{0, choice, 1#延伸模組|2#延伸模組} {1} {0, choice, 1#|2#}已停用。
new.ui.blog.post.link=網誌
new.ui.description=乾淨和現代的外觀，新 UI 通過最大限度減少螢幕上的混亂來幫助專注於工作.
new.ui.explore.new.ui=探索新 UI
new.ui.settings.group.name=設定
new.ui.submit.feedback=提交意見反應…
new.ui.title=新 UI
new.ui.watch.new.ui.overview=檢視新 UI 概述
no.charset.set.reason.charset.auto.detected.by.bom=字符集被 BOM 自動檢出
no.charset.set.reason.charset.auto.detected.from.content=字符集從內容中自動檢出
no.charset.set.reason.charset.hard.coded.in.file=字符集在檔案中硬編碼
no.charset.set.reason.disabled.for.binary.file=對二進制檔案停用
no.charset.set.reason.disabled.for.directory=對目錄停用
no.charset.set.reason.disabled.for.file.type=為 {0} 停用
no.disk.space.message=系統目錄分區(''{0}'')上的剩餘空間少於 1 MiB
no.disk.space.title=磁碟空間不足
no.information.available=無可用資訊
no.tip.of.the.day=<html><body>此功能目前尚無每日小技巧。</body></html>
node.call.hierarchy.N.usages=({0} 個用法)
node.default.package=<預設軟體套件>
node.hierarchy.invalid=[無效]
node.memberchooser.all.classes=所有類別
node.project.view.bad.link=無效的符號連結
node.projectview.external.libraries=外部庫
node.projectview.libraries=庫
node.projectview.library={0} 庫
node.structureview.invalid=<無效>
node.todo.group={0} {0,choice,0#項|1#項|2#項}
node.todo.items={0} {0, choice, 0#項|1#項|2#項}
node.todo.more.items=…更多…
node.todo.summary=在 {1} 個{1,choice,0#檔案|1#檔案|2#檔案}中找到 {0} 個 TODO {0,choice,0#條目|1#條目|2#條目}
notification.accessible.announce.prefix=通知
notification.action.unknown.macros.error.fix=修復
notification.cache.diagnostic.helper.text=已執行恢復步驟 {0}: ''{1}''
notification.cache.diagnostic.helper.title=IDE 修復
notification.cache.diagnostic.stop.text=現在一切正常
notification.cache.recover.from.log.no.recovery.points=沒有可用的恢復點
notification.cache.recover.from.log.not.available=快取恢復不可用
notification.configurable.display.name.notifications=通知
notification.content.cannot.find.keymap=找不到鍵映射“{0}”
notification.content.cannot.find.parent.keymap=找不到“{1}”的父鍵映射“{0}”
notification.content.color.scheme=User color scheme ''{0}'' points to incorrect or non-existent base scheme {1} and will not be shown
notification.content.failed.to.save.settings=<p>無法儲存設定。{0}
notification.content.input.method.disabler=IDE 執行時啟用了可能導致凍結的輸入方法。如果您並不使用這些輸入方法，不妨停用它們。
notification.content.internal\\ error=內部錯誤
notification.content.jcef.applySettings=要將新設定應用於 JCEF 瀏覽器，需要重啟 IDE
notification.content.jcef.gpucrash.action.disable=停用 GPU 並重啟
notification.content.jcef.gpucrash.action.restart=重啟
notification.content.jcef.gpucrash.message=GPU 程序重啟次數過多，似乎不穩定。請嘗試重啟 IDE 或完全停用 GPU 加速。
notification.content.jcef.gpucrash.title=GPU 程序(JCEF)重啟次數過多
notification.content.jcef.measureFPS=按任意鍵或切換焦點即可停止
notification.content.jcef.missingLibs=缺少原生庫: {0}
notification.content.jit.compiler.disabled=JVM JIT 編譯器已被停用。重啟 IDE 以重新啟用 JIT。<br><br>如果再次看到此訊息，請嘗試使用 <code>-XX:ReservedCodeCacheSize</code> 選項增加 CodeCache 的大小。<br><br>有關 JVM 選項的更多資訊，請參閱<a href="help">此幫助主題</a>。
notification.content.keymap.successfully.activated=按鍵映射 {0} 成功啟用
notification.content.keymap.successfully.installed=鍵映射 {0} 成功安裝
notification.content.mandatory.bom.br={0,choice,1#此檔案具有|2#這些檔案具有}強制性 BOM:<br/>{1}
notification.content.more.shortcut.conflict={0} 和其他 {1} 個快捷鍵與 macOS 快捷鍵衝突。請修改這些快捷鍵或更改 macOS 系統設定。
notification.content.please.restart.0=請重啟 {0}</p>{1}
notification.content.plugin.failed.to.save.settings=延伸模組 <i>{0}</i> 無法儲存設定。{1}
notification.content.shortcut.conflicts.with.macos.shortcut.modify={0} 快捷鍵與 macOS 快捷鍵 {1} 衝突。請修改此快捷鍵或更改 macOS 系統設定。
notification.content.solarized.color.scheme.deprecation.enable=您正在使用即將刪除的 {0} 捆綁配色方案。請考慮改為啟用 {1} 主題
notification.content.solarized.color.scheme.deprecation.install=您正在使用即將刪除的 {0} 捆綁配色方案。請考慮切換到 {1} 延伸模組
notification.content.unable.to.save.project.files=無法儲存專案檔案。請確保專案檔案可寫入，並且您具備修改權限。<a href="">再次嘗試儲存專案</a>。
notification.content.unknown.macros.error.description=路徑變數用於取代專案檔案中的絕對路徑，並允許專案檔案在版本控制系統中共享。<br>當前專案設定的某些檔案包含未知的路徑變數，{0} 無法還原這些路徑。
notification.content.unknown.macros.error.many.macroses.undefined={0} 未定義。
notification.content.unknown.macros.error.one.macros.undefined={0} 未定義。
notification.content.updated.plugin.to.version=已將 {0} 延伸模組更新到版本 {1}
notification.content.updated.plugins=已更新 {0} 個延伸模組
notification.group.built.in.server=內建 HTTP 伺服器無法啟動
notification.group.cache.recovery=已執行快取恢復步驟
notification.group.essential-highlighting.mode=基本醒目提示模式已啟用
notification.group.failed.to.remove.bom=無法移除 BOM
notification.group.ide.and.plugin.updates=IDE 和延伸模組更新可用
notification.group.ide.errors=IDE 錯誤
notification.group.ide.update.results=IDE 更新已安裝
notification.group.language.plugin=推薦的語言延伸模組可用
notification.group.leftover.directories=找到了殘留的 IDE 目錄
notification.group.load.error=無法載入設定
notification.group.low.memory=檢測到記憶體不足
notification.group.missing.keymap=缺少快捷鍵
notification.group.password.safe=密碼存儲不可用
notification.group.plugin.error=延伸模組載入失敗
notification.group.plugin.updates=延伸模組已安裝或更新
notification.group.plugins.suggestion=有可用的延伸模組建議
notification.group.power.save.mode=已啟用省電模式
notification.group.project.settings=無法儲存專案
notification.group.required.plugins=未載入所需的延伸模組
notification.group.settings.error=無法儲存設定
notification.group.system.clipboard=系統剪貼簿不可用
notification.group.system.health=檢測到系統執行狀況問題
notification.group.system.messages=系統訊息
notification.group.too.many.carets=已達到編輯器文字游標的最大數量
notification.manager.content.height.linebreak=<br>\\n
notification.manager.content.height.word=內容
notification.manager.merge.n.more=其他 {0} 個
notification.manager.merge.n.more.from=來自 {1} 的其他 {0} 個
notification.settings.action.text=設定…
notification.title.activated.from.command.line=已從命令行啟用
notification.title.desktop.entry.created=已建立桌面條目
notification.title.desktop.entry.creation.failed=桌面條目建立失敗
notification.title.enable.action.solarized.color.scheme.deprecation=啟用 {0} 主題
notification.title.incompatible.color.scheme=不相容的配色方案
notification.title.input.method.disabler=輸入方法停用程序
notification.title.install.action.solarized.color.scheme.deprecation=安裝 Marketplace 中的 Solarized Themes 延伸模組
notification.title.jcef.measureFPS=OSR JCEF FPS Meter
notification.title.jcef.proxyChanged=代理設定已更改
notification.title.jcef.startFailure=JCEF 瀏覽器元件無法啟動
notification.title.jit.compiler.disabled=重啟 IDE 避免減速
notification.title.launcher.script.creation.failed=啟動器腳本建立失敗
notification.title.required.plugins.not.loaded=尚未載入必需延伸模組
notification.title.shortcuts.conflicts=快捷鍵衝突
notification.title.solarized.color.scheme.deprecation=配色方案棄用
notification.title.unable.to.save.plugin.settings=無法儲存延伸模組設定
notification.title.unable.to.save.settings=無法儲存設定
notification.title.unknown.macros.error=載入錯誤: 未定義的路徑變數
notification.title.was.unable.to.remove.bom.in=無法移除 {0} {0,choice,1#檔案|2#檔案}中的 BOM
notifications.collapse.balloon.title=其他 {0} 個{1}
notifications.collapse.balloon.title.suggestion={0,choice,1#建議|1<建議}
notifications.collapse.balloon.title.timeline={0,choice,1#通知|1<通知}
notifications.configurable.announcing.comment=如果先前的輸出具有較低的優先級，則通知將中斷該輸出
notifications.configurable.announcing.title=用螢幕閱讀器宣布:
notifications.configurable.announcing.value.high=具有高優先級
notifications.configurable.announcing.value.interrupting=正在中斷當前輸出
notifications.configurable.announcing.value.medium=具有中等優先級
notifications.configurable.announcing.value.not.interrupting=當前輸出完成後
notifications.configurable.announcing.value.off=關閉
notifications.configurable.column.group=組
notifications.configurable.column.log=日誌
notifications.configurable.column.popup=彈出視窗類型:
notifications.configurable.column.read.aloud=大聲朗讀
notifications.configurable.column.toolwindow=在工具視窗中顯示
notifications.configurable.display.balloon.notifications=顯示氣球通知
notifications.configurable.do.not.ask.project.title=此專案
notifications.configurable.do.not.ask.title=不再詢問通知:
notifications.configurable.enable.system.notifications=啟用系統通知
notifications.configurable.no.notifications.configured=未組態通知
notifications.configurable.play.sound=播放聲音
notifications.toolwindow.dont.show.again=不再顯示
notifications.toolwindow.dont.show.again.for.this.project=不再為此專案顯示
notifications.toolwindow.empty.text.first.line=建議、事件，
notifications.toolwindow.empty.text.second.line=以及錯誤將出現在這裡
notifications.toolwindow.remind.tomorrow=明天提醒我
notifications.toolwindow.suggestions=建議
notifications.toolwindow.timeline=時間線
notifications.toolwindow.timeline.clear.all=全部清除
old.dirs.action.progress=正在尋找殘留的 IDE 存儲目錄…
old.dirs.column.name=目錄
old.dirs.column.size=大小
old.dirs.column.updated=上次使用
old.dirs.delete.error=無法刪除目錄
old.dirs.delete.progress=正在刪除目錄…
old.dirs.dialog.delete.button=刪除 {0} 個{0,choice,0#目錄|1#目錄|2#目錄}
old.dirs.dialog.text=<html>安裝在您電腦上的其他 IDE 版本使用下面列出的目錄來存儲特定於版本的<br>設定、快取和延伸模組。刪除它們可以釋放空間，並且不影響<i>此版本</i>的穩定性。<br><b>警告</b>: 不要刪除仍在使用的版本的目錄!<br><br>選擇要刪除的目錄:</html>
old.dirs.dialog.title=刪除殘留的 IDE 存儲目錄
old.dirs.not.found.notification.text=沒有找到殘留的 IDE 存儲目錄。
old.dirs.notification.action=檢視並刪除…
old.dirs.notification.text=找到殘留的 IDE 存儲目錄。
only.at.line.start=僅在行首(\\\\&O)
onoff.button.off=關閉
onoff.button.on=開啟
open.in.0=在 {0} 中開啟
open.in.browser=在瀏覽器中開啟(_B)
open.selected.file.in.browser=在瀏覽器中開啟所選檔案
open.url.in.0=在 {0} 中開啟 URL
open.url.in.browser.tooltip=在瀏覽器中開啟
option.hide.tool.window.bars=隱藏工具視窗列
option.is.overridden.by.jvm.property=此選項已由 JVM 屬性覆寫:“{0}”
option.show.tips.on.startup=啟動時顯示每日小技巧
overridden.by.jvm.property=已被 JVM 屬性 ''{0}'' 覆寫
package.0.installed.successfully=已成功安裝軟體套件 ''{0}''
package.installed.successfully=已成功安裝軟體套件
package.successfully.uninstalled=已成功解除安裝軟體套件 ''{0}''
package.successfully.upgraded=已成功升級軟體套件 {0}
packages.settings.latest.version=最新版本
packages.settings.loading=正在載入軟體套件列表
packages.settings.package=軟體套件
packages.settings.version=版本
packages.successfully.uninstalled=已成功解除安裝軟體套件
packages.title=軟體套件
path.macro.ignored.variables=忽略的變數:
path.macro.use.semicolon=使用 ; 分隔忽略的變數
please.edit.repository.url=請編輯儲存庫 URL
please.input.repository.url=請輸入儲存庫 URL
plugin.description.vim.editor=Vim 編輯器仿真
plugin.descriptor.aws.toolkit=建立、測試和偵錯使用 AWS 無伺服器應用程式模型建置的無伺服器應用程式
plugin.group.cloud.support=雲支援
plugin.group.editor=編輯器
plugin.group.tools.integration=工具整合
plugin.info.not.available=不適用
plugin.info.unknown=未知
plugin.installed.ide.restart.required.message=延伸模組“{0}”已安裝。{1} {2} 以在延伸模組中套用更改?
plugin.invalid.signature.result=''{0}'' 延伸模組的數位簽章驗證失敗並顯示以下訊息: ''{1}''。
plugin.manager.action.label.sort.by=排序依據: {0}
plugin.manager.action.label.sort.by.1=排序依據
plugin.manager.custom.certificates=管理延伸模組憑證
plugin.manager.dependencies.detected.message=''{0}'' 延伸模組需要安裝 {1}。
plugin.manager.dependencies.detected.title=安裝必需延伸模組
plugin.manager.incompatible.tooltip=延伸模組與當前 {0} 安裝不相容
plugin.manager.installed.tooltip=延伸模組將在重啟後啟用
plugin.manager.main.suggest.to.enable.message.part1=更新的延伸模組 ''{0}'' 已停用。
plugin.manager.main.suggest.to.enable.message.part2=更新的延伸模組 {0} 已停用。
plugin.manager.main.suggest.to.enable.message.part3=更新的依賴於停用內容的{0,choice,1#延伸模組|2#延伸模組}
plugin.manager.main.suggest.to.enable.message.part4=延伸模組 ''{0}''。
plugin.manager.main.suggest.to.enable.message.part5=延伸模組 {0}。
plugin.manager.main.suggest.to.enable.message.part6=被停用的延伸模組和相依停用的延伸模組在重啟後不會被啟用。
plugin.manager.main.suggest.to.enable.message.part7=停用的延伸模組在重啟後不會被啟用。
plugin.manager.main.suggest.to.enable.message.part8=是否想要啟用更新的{0,choice, 1#延伸模組|2#延伸模組}
plugin.manager.main.suggest.to.enable.message.part9=是否想要啟用延伸模組{0,choice,1#相依項|2#相依項}
plugin.manager.new.version.tooltip=從版本 {0} 更新安裝的延伸模組
plugin.manager.obsolete.plugins.detected.title=停用衝突的延伸模組
plugin.manager.optional.dependencies.detected.message=建議安裝包含延伸模組 ''{0}'' 的 {1}。
plugin.manager.optional.dependencies.detected.title=安裝建議的延伸模組
plugin.manager.options.command=輸入 / 以檢視選項
plugin.manager.replace.plugin.0.by.plugin.1=<html>''{1}'' 延伸模組旨在替代安裝的 ''{0}'' 延伸模組。<br>停用“{0}”延伸模組以避免衝突?</html>
plugin.manager.repositories=管理延伸模組儲存庫…
plugin.manager.tab.installed=已安裝
plugin.manager.tab.marketplace=Marketplace
plugin.manager.tooltip=從磁碟管理儲存庫、組態代理或安裝延伸模組
plugin.manager.uninstalled.tooltip=延伸模組已被移除；重啟後將套用更改
plugin.manager.update.all=全部更新
plugin.manager.update.available.tooltip=有更新版本的延伸模組可用
plugin.manager.updated.tooltip=延伸模組已升級到最新版本；重啟後將套用更改
plugin.message.plugin.only.supported.in=此延伸模組僅在 {0} 中可用。
plugin.settings.link.title=延伸模組設定…
plugin.signature.checker.no=取消安裝
plugin.signature.checker.revoked.cert=<html><body>''{0}'' 延伸模組已撤消 JetBrains 憑證</body></html>
plugin.signature.checker.title=延伸模組安全警告
plugin.signature.checker.yes=忽略並繼續
plugin.signature.not.signed=<html><body>''{0}'' 延伸模組未進行數位簽章，無法驗證其可靠性。安裝或更新未簽名的延伸模組可能會將您的系統置於風險之中。<br/><br/>延伸模組詳細資訊: ID: {1}，版本: {2} {3}</body></html>
plugin.status.bundled=已捆綁
plugin.status.installed=已安裝
plugin.status.not.allowed=已阻止
plugin.status.not.allowed.but.enabled=停用!
plugin.status.not.allowed.tooltip=您的組織未批准此延伸模組
plugin.status.not.allowed.tooltip.but.enabled=請停用此延伸模組，因為它未經您的組織批准
plugin.status.not.specified=(未指定)
plugin.update.dialog.total.label=總計: {0}
plugin.updater.downloading=正在下載延伸模組
plugin.updater.error.cant.find.plugin.version=在儲存庫響應中找不到延伸模組版本
plugin.updater.error.check.failed=延伸模組更新檢查失敗
plugin.updater.error.custom.repository=檢查自訂延伸模組儲存庫 {0} 失敗
plugin.updater.error.unexpected.repository.response=意外延伸模組儲存庫響應
plugin.updater.install=安裝
plugin.updater.not.installed=未安裝延伸模組更新
plugin.updater.not.installed.misc=未安裝延伸模組更新: {0}
plugin.updater.not.installed.see.log.action=請參閱日誌了解更多資訊
plugin.updater.notification.message={1} 延伸模組有可用的新版本 {0}
plugin.version.bundled=已捆綁
plugins.advertiser.action.configure.plugins=組態延伸模組…
plugins.advertiser.action.enable.plugin=啟用延伸模組
plugins.advertiser.action.enable.plugins=啟用延伸模組…
plugins.advertiser.action.ignore.extension=忽略擴展
plugins.advertiser.action.ignore.ultimate=關閉
plugins.advertiser.action.ignore.unknown.feature=不建議使用此延伸模組
plugins.advertiser.action.ignore.unknown.features=不建議使用這些延伸模組
plugins.advertiser.action.install.plugin.name=安裝 {0} 延伸模組
plugins.advertiser.action.install.plugins=安裝延伸模組
plugins.advertiser.action.try.ultimate=試用 {0}
plugins.advertiser.check.progress=正在檢查專案的建議延伸模組
plugins.advertiser.enabled.on.demand={0,choice,1#延伸模組|2#延伸模組} {1} {0,choice,1#已|2#已}啟用。
plugins.advertiser.extensions.supported.in.ides=<hyperlink>其他 JetBrains IDE</hyperlink> 中支援 {0} 檔案
plugins.advertiser.extensions.supported.in.ultimate={1} 支援 {0} 檔案
plugins.advertiser.feature.dependency=相依項
plugins.advertiser.framework.supported.in.ultimate={1} 支援 {0} 個組態檔案
plugins.advertiser.learn.more=了解詳情
plugins.advertiser.missing.feature=支援 {1} ''{2}'' 的{0,choice,1#延伸模組|2#延伸模組} {4} {0,choice,1#當前|2#當前}{3,choice,0#已停用|1#尚未安裝}。
plugins.advertiser.missing.feature.dependency=推薦的{0,choice,1#延伸模組|2#延伸模組} {1} 可用。
plugins.advertiser.missing.features=支援功能({1})的{0,choice,1#延伸模組|2#延伸模組} {3} {0,choice,1#當前|2#當前}{2,choice,0#已停用|1#尚未安裝}。
plugins.advertiser.missing.features.dependency=推薦的{0,choice,1#延伸模組|2#延伸模組} {1} 可用。
plugins.advertiser.no.suggested.plugins=找不到建議的延伸模組
plugins.advertiser.plugins.found=已找到支援 {0} 檔案的延伸模組。
plugins.advertiser.plugins.suggestions.text=已找到所選相依項的延伸模組。
plugins.advertiser.plugins.suggestions.title=延伸模組建議
plugins.advertiser.task.searching.for.plugins=在儲存庫中搜尋延伸模組
plugins.advertiser.ultimate.features.detected=檢測到 IntelliJ IDEA Ultimate {0} 涵蓋的功能
plugins.advertiser.unbundled.plugin.ai.assistant=The AI Assistant plugin is now available on the Marketplace. Install the plugin to continue using it
plugins.advertiser.unbundled.plugin.dismiss=不再顯示
plugins.advertiser.unbundled.plugin.install=Install from Marketplace
plugins.auto.disabled.notification.content={0} 和 {1} 延伸模組已停用。
plugins.auto.disabled.notification.title=相依延伸模組已停用
plugins.auto.enabled.notification.content={0} 和 {1} 延伸模組已啟用。
plugins.auto.enabled.notification.title=必需延伸模組已啟用
plugins.auto.switch.action.name=撤消
plugins.changed.notification.content=延伸模組列表已更改。請重啟 {0} 以啟用更改。
plugins.changed.notification.title=需要重啟
plugins.configurable.InstalledSearchOption.Bundled=已捆綁
plugins.configurable.InstalledSearchOption.Disabled=停用
plugins.configurable.InstalledSearchOption.Downloaded=已下載
plugins.configurable.InstalledSearchOption.Enabled=啟用
plugins.configurable.InstalledSearchOption.Invalid=無效
plugins.configurable.InstalledSearchOption.NeedUpdate=可用的更新
plugins.configurable.SortBySearchOption.Downloads=下載
plugins.configurable.SortBySearchOption.Name=名稱
plugins.configurable.SortBySearchOption.Rating=評分
plugins.configurable.SortBySearchOption.Relevance=相關性
plugins.configurable.SortBySearchOption.Updated=已更新
plugins.configurable.activate.trial.for.full.access=訂閱進階功能
plugins.configurable.additional.info.tab.name=其他資訊
plugins.configurable.bugtracker.url=問題追蹤器
plugins.configurable.bundled.updates=捆綁的延伸模組更新
plugins.configurable.buy.the.plugin=購買延伸模組
plugins.configurable.buy.the.plugin.from.0=購買價低至 {0}
plugins.configurable.check.internet=檢查互聯網連線。
plugins.configurable.disable=停用
plugins.configurable.disable.all=全部停用
plugins.configurable.disable.all.downloaded=停用所有下載的延伸模組
plugins.configurable.disabled=已停用
plugins.configurable.documentation.url=文檔
plugins.configurable.downloaded=已下載
plugins.configurable.downloads.0=下載量: {0}
plugins.configurable.enable=啟用
plugins.configurable.enable.all=全部啟用
plugins.configurable.enable.all.downloaded=啟用所有下載的延伸模組
plugins.configurable.enabled=已啟用
plugins.configurable.featured=精選
plugins.configurable.forum.url=論壇頁面
plugins.configurable.install=安裝
plugins.configurable.installed=已安裝
plugins.configurable.installing=正在安裝
plugins.configurable.license.expired=授權已過期。
plugins.configurable.license.expires.in.0.days=授權將於 {0} 天後到期。
plugins.configurable.license.is.active=授權有效。
plugins.configurable.license.is.active.until.0=授權有效期至 {0}。
plugins.configurable.license.url=授權
plugins.configurable.marketplace.plugins.not.loaded=未載入 Marketplace 延伸模組。
plugins.configurable.new.and.updated=新增和更新
plugins.configurable.not.allowed=您的組織未批准此延伸模組
plugins.configurable.notes.empty.text=很遺憾，{0} 未留下任何更新說明。
plugins.configurable.notes.empty.text.default.vendor=供應商
plugins.configurable.nothing.found=找不到任何內容。
plugins.configurable.one.plugin.details=選擇一個延伸模組以預覽延伸模組詳細資訊。
plugins.configurable.other.bundled=其他工具
plugins.configurable.overview.tab.name=概覽
plugins.configurable.plugin.details=選擇延伸模組以預覽詳細資訊
plugins.configurable.plugin.homepage.link=延伸模組首頁
plugins.configurable.plugin.installing.failed=延伸模組“{0}”下載或安裝失敗
plugins.configurable.plugin.installing.success=延伸模組 {0} 已成功安裝
plugins.configurable.plugin.unavailable.for.platform=延伸模組對 {0} 不可用
plugins.configurable.rate.0=評分: {0}
plugins.configurable.release.date.0=發佈日期: {0}
plugins.configurable.repository.0=儲存庫: {0}
plugins.configurable.required.plugins.0=相依項:\\n{0}
plugins.configurable.restart.ide.button=重啟 IDE
plugins.configurable.reviews.tab.name=評價
plugins.configurable.search.in.marketplace=在 Marketplace 中搜尋
plugins.configurable.search.options=搜尋選項
plugins.configurable.search.result.not.loaded=未載入搜尋結果。
plugins.configurable.several.plugins=已選擇多個延伸模組。
plugins.configurable.show=顯示
plugins.configurable.show.all=全部顯示
plugins.configurable.size.0=大小: {0}
plugins.configurable.sort.by=排序依據
plugins.configurable.source.code=原始碼
plugins.configurable.suggested=推薦
plugins.configurable.suggested.features.dependency=建議使用此延伸模組，因為您的專案使用了 {0} 庫
plugins.configurable.suggested.features.executable=建議使用此延伸模組，因為您已經安裝了 {0}
plugins.configurable.title.with.count={0} (已啟用 {1}/{2})
plugins.configurable.top.downloads=熱門下載
plugins.configurable.top.rated=最受好評
plugins.configurable.trial.expires.in.0.days=試用將於 {0} 天後到期。
plugins.configurable.unavailable.for.platform=不可用
plugins.configurable.uninstall=解除安裝
plugins.configurable.uninstalled=已解除安裝
plugins.configurable.update.button=更新
plugins.configurable.version.0=版本: {0}
plugins.configurable.whats.new.tab.name=最新變化
plugins.new.review.action=撰寫評價
plugins.progress.loading.plugin.title=正在載入延伸模組 {0}
plugins.progress.loading.plugins.for.current.project.title=正在載入 ''{0}'' 的延伸模組
plugins.progress.unloading.plugin.title=正在移除延伸模組 {0}
plugins.progress.unloading.plugins.for.current.project.title=正在上傳 ''{0}'' 的延伸模組
plugins.reloaded.successfully={0} 成功重新載入
plugins.review.action.copy.link.text=複製連結
plugins.review.panel.empty.text=目前尚無評價。
plugins.review.panel.next.page.button=展開
popup.content.action.not.available.while.updating.indices=在 {1} 更新索引期間 {0} 不可用
popup.content.actions.not.available.while.updating.indices=在 {1} 更新索引期間 {0} 不可用
popup.title.add.group.options=新增{0}選項
popup.title.add.run.options=新增執行選項
popup.title.add.tags=新增標記
popup.title.edit.shortcuts=編輯快捷鍵
popup.title.import.scheme=匯入方案
popup.title.in.editor.mode=在編輯器模式下
popup.title.maintenance=維護
popup.title.notification.display.type=通知顯示類型
popup.title.open.project=開啟專案
popup.title.play.saved.macros=播放儲存的巨集
popup.title.switch=切換
power.save.mode.disable.action.title=停用省電模式
power.save.mode.on.notification.content=程式碼洞察和背景任務已停用。
power.save.mode.on.notification.title=省電模式已開啟
preferred.theme.autodetect.selector=與作業系統同步
preferred.theme.dark.header=深色
preferred.theme.description=為自動檢測模式選擇首選主題
preferred.theme.light.header=淺色
preferred.theme.text=首選主題
presentation.mode.fon.size=字體大小:
presentation.mode.ide.scale=縮放:
presentation.mode.ide.scale.out.of.range.number.message.format=指定一個介於 {0}% 到 {1}% 之間的值
presentation.mode.ide.scale.wrong.number.message=指定正整數
press.0.to.assign.a.shortcut=按 {0} 分配快捷鍵
press.copy.key.to.copy.system.information.to.clipboard=按 Copy 鍵將系統資訊複製到剪貼簿
progress.cache.recover.from.logs.files.processed=已處理 {0}/{1} 個檔案
progress.cache.recover.from.logs.stage=暫存 {0}/{1}
progress.cache.recover.from.logs.title=快取恢復
progress.closing.project=正在關閉專案…
progress.connecting.to.plugin.manager=正在連線到 {0}
progress.creating.directory=正在建立目錄 {0}{1}{2}
progress.creating.file=正在建立檔案 {0}{1}{2}
progress.creating.package=正在建立軟體套件 {0}。{1}
progress.deleting=正在刪除
progress.deleting.class=正在刪除類別 {0}
progress.download.plugins=下載延伸模組
progress.downloading.available.plugins=正在下載可用延伸模組列表
progress.downloading.list.of.plugins=正在從 {0} 下載延伸模組列表
progress.downloading.plugin=正在下載延伸模組 ''{0}''
progress.downloading.plugins.meta=正在下載延伸模組 {0} 的資料
progress.file.system.changes=檔案系統更改
progress.performing.indexing.tasks=正在執行編制索引任務
progress.searching=正在搜尋…
progress.text.clickToViewProgressWindow=點擊以檢視所有正在執行的背景任務
progress.text.collecting.classes=正在收集類別列表…
progress.text.downloading=正在下載…
progress.text.generate.classes.archive=正在生成類別歸檔…
progress.text.loading=正在載入…
progress.text.migrating.plugins=正在遷移延伸模組…
progress.text.reloading.file=正在重新載入檔案…
progress.text.reloading.files=正在重新載入檔案…
progress.text.reopening.files=正在重新開啟檔案…
progress.text.stopping=正在停止 - {0}
progress.title.cds.optimize.startup=正在最佳化啟動性能…
progress.title.check.connection=檢查連線
progress.title.checking.plugin.dependencies=正在檢查延伸模組相依項
progress.title.checking.plugins.repository=正在檢查延伸模組儲存庫…
progress.title.constructing.tooltip=正在建置工具提示
progress.title.creating.git.repository=建立 Git 儲存庫
progress.title.deleting.files=正在刪除檔案…
progress.title.installing.plugin=正在安裝延伸模組“{0}”…
progress.title.loading.plugin.details=正在載入延伸模組詳細資訊
progress.title.preparing.navigation=正在準備導覽…
progress.title.reload.files=重新載入檔案
progress.window.empty.text=無背景任務
progress.window.title=背景任務
project.scheme=專案
project.structure.tree.accessible.name=專案結構樹
prompt.browse.icon.for.selected.action=以 SVG 或 PNG 格式瀏覽圖示
prompt.create.non.existing.package=軟體套件 {0} 不存在。\\n是否要建立?
prompt.delete.and=和
prompt.delete.directory={0,choice,1#目錄|2#目錄}
prompt.delete.directory.paren=({0} {0,choice,1#目錄|2#目錄})
prompt.delete.elements=刪除{0}?
prompt.delete.file={0,choice,1#檔案|2#檔案}
prompt.delete.it.anyway=仍要刪除?
prompt.delete.property={0,choice,1#屬性|2#屬性}
prompt.delete.symlink={0,choice,1#符號連結|2#符號連結}
prompt.directory.contains.read.only.files=目錄 {0} 包含唯讀檔案。仍要刪除?
prompt.enter.a.new.package.name=輸入一個新的軟體套件名稱:
prompt.enter.macro.name=輸入巨集名稱。如果為臨時巨集，請留空。
prompt.enter.new.directory.name=輸入新目錄名稱:
prompt.enter.new.file.name=指定新的檔名:
prompt.enter.new.library.name=輸入新庫名稱
prompt.enter.new.module.name=輸入新模組名稱
prompt.enter.new.name=輸入新名稱
prompt.enter.new.package.name=輸入新的軟體套件名稱:
prompt.filechooser.enter.file.name=輸入檔名:
prompt.goto.inspection.enter.name=輸入檢查名稱:
prompt.gotoaction.enter.action=輸入動作或選項名稱:
prompt.gotoclass.enter.class.name=輸入 {0} 名稱:
prompt.gotofile.enter.file.name=輸入檔名:
prompt.gotosymbol.enter.symbol.name=輸入符號名稱:
prompt.input.favorites.list.new.name=將收藏夾列表 ''{0}'' 重命名為:
prompt.input.new.favorites.list.name=輸入新收藏夾列表的名稱
prompt.open.project.or.attach=<html><body>可以在新視窗中開啟專案，取代當前視窗中的專案，或者將專案附加到已經開啟的專案。<br>您想如何開啟專案?</body></html>
prompt.open.project.or.attach.button.attach=附加(&A)…
prompt.open.project.or.attach.button.new.window=新視窗 (&W)
prompt.open.project.or.attach.button.this.window=此視窗(&T)
prompt.open.project.or.attach.title=開啟專案
prompt.proxy.authentication=代理身份驗證
prompt.reset.to.original.template=重設為原始模板?
prompt.server.authentication=伺服器身份驗證
prompt.specify.module.group.name=指定{0}將顯示在其下方的組名稱。\\n\\n
prompt.specify.name.of.module.subgroup=指定{1}將顯示在其下方的{0}子組的名稱\\n\\n
prompt.uninstall.plugin=確定要解除安裝套件 ''{0}'' 嗎?
prompt.uninstall.several.plugins=確定要解除安裝這 {0} 個套件嗎？
quick.lists.description=<html>快速列表允許您定義常用的動作組 (例如，重構或 VCS 動作)，並將鍵盤快捷鍵分配給此類別組。</html>
quick.lists.not.empty.name=快速列表應具有非空名稱
quick.lists.presentable.name=快速列表
quickfix.text.insert.0=插入 {0}
radio.button.open.matching.files.in.associated.application=在關聯的應用程式中開啟符合檔案
radio.button.unlock.all=全部解鎖
radio.button.unlock.dir=目錄解鎖
radio.button.unlock.one=解鎖一個
radio.button.using.file.system=使用檔案系統(&F)
radio.button.using.version.control.integration=使用版本控制整合(&V)
radio.process.close.ask=詢問
radio.process.close.disconnect=斷開連線
radio.process.close.terminate=終止程序
recent.files.accessible.file.list=檔案
recent.files.accessible.open.recently.edited.locations=開啟最近編輯的位置
recent.files.accessible.open.recently.viewed.locations=開啟最近的位置
recent.files.accessible.show.tool.window=啟用工具視窗: {0}
recent.files.accessible.tool.window.list=工具視窗
recent.files.checkbox.label=僅顯示已編輯的內容
recent.files.file.list.empty.text=無最近檔案
recent.files.speed.search.empty.text=按 'Enter' 在專案中搜尋
recent.files.tool.window.list.empty.text=無工具視窗
recent.locations.changed.locations=最近編輯的位置
recent.locations.popup.empty.file.text=空行
recent.locations.popup.empty.text=未找到最近的位置
recent.locations.popup.title=最近的位置
recent.locations.title.text=僅顯示已編輯的內容
recent.project.unavailable=(不可用)
recover.caches.from.log.recovery.action.name=從動作日誌恢復快取
recovery.progress.title=正在嘗試{0}…
redo.command=重做{0}
redo.dialog.title=重做
registry.change.warning=更改這些值可能導致 {0} 的異常行為。除非要求，否則請不要更改這些值。
registry.close.action.text=關閉
registry.key.requires.ide.restart.note=需要重啟 IDE
registry.restore.defaults.action.text=還原為預設設定
reload.or.convert.dialog.title={0}: 重新載入或轉換為 {1}
remove.BOM=移除 BOM
remove.byte.order.mark.from=從 {0} 中移除位元組順序標記
removing.BOM=正在移除 BOM
rename.0=重新命名 {0}
reportProblemAction.progress.title.submitting=正在提交…
repository.url.title=儲存庫 URL
required.plugin.at.least.versions=，版本至少為 ''{0}''
required.plugin.at.most.versions=，版本最高為 ''{0}''
required.plugin.between.versions=，''{0}'' 和 ''{1}'' 之間的版本
required.plugin.exact.version=，版本 ''{0}''
reset.action.text=重設
run.anything.accessible.name=執行任何內容
run.anything.action.tooltip.text=執行指令: 開啟專案，啟動執行組態，執行 Gradle 或 Maven 任務，執行終端指令等。
run.anything.actions.undefined=未定義
run.anything.ad.command.delete={0} 刪除最近的指令
run.anything.ad.run.action.with.default.settings=按 {0} 使用預設設定執行
run.anything.ad.run.in.context=按 {0} 在當前檔案上下文中執行
run.anything.ad.run.with.debug={0} 偵錯
run.anything.console.error.title=無法執行指令
run.anything.console.process.finished=\\n程序已結束，退出程式碼為 {0}。
run.anything.context.browse.directory=瀏覽目錄…
run.anything.context.project=專案
run.anything.context.project.undefined=未定義
run.anything.context.separator.directories=目錄
run.anything.context.separator.modules=模組
run.anything.context.title.working.directory=執行上下文
run.anything.context.tooltip=選擇將在其中執行當前指令的上下文
run.anything.custom.activity.notification.group.id=已執行 Run Anything 指令
run.anything.custom.activity.rollback.action=復原
run.anything.general.group.title=一般
run.anything.help.list.empty.secondary.text=選擇指令
run.anything.hint.initial.text=按 {0} 或 {1} 瀏覽建議列表
run.anything.indexing.mode.not.supported=在索引更新期間，“執行任何內容”不可用
run.anything.main.list.empty.primary.text=執行指令或組態
run.anything.main.list.empty.secondary.text=輸入“?”以檢視所有指令
run.anything.notification.warning.content=指令 ''{0}'' 無法執行。
run.anything.notification.warning.title=指令執行失敗
run.anything.recent.group.title=最近
run.anything.recent.project.command.placeholder=開啟 <專案名稱>
run.anything.recent.project.completion.group.title=最近的專案
run.anything.recent.project.help.group.title=最近的專案
run.anything.run.anything.title=執行任何內容
run.anything.run.configurations.group.title=執行組態
run.anything.run.debug.title=偵錯:
run.anything.run.in.context.debug.title=使用偵錯在上下文中執行:
run.anything.run.in.context.title=在上下文中執行:
run.layout.do.not.show.view.option.message=不顯示
scheme.ide=IDE
scheme.project=專案
scope.banner.text=作用域 ''{0}''
scope.chooser.select.scope.text=在此處選擇作用域以檢視或編輯其詳細資訊
scope.class.hierarchy=類別層次結構
scope.current.file=當前檔案
scope.editor.legend.partly.included.label=部分包含
scope.editor.legend.recursively.included.label=遞迴包含
scope.files.in.previous.search.result=之前搜尋結果中的檔案
scope.open.files=開啟檔案
scope.previous.search.results=之前的搜尋結果
scope.recent.files=最近檢視的檔案
scope.recent.modified.files=最近更改的檔案
scope.selected.directories=選定{0,choice,1#目錄|2#目錄}
scope.selected.files=選定{0,choice,1#檔案|2#檔案}
scope.selected.files.and.directories=選定{0,choice,1#檔案|2#檔案}和{1,choice,1#目錄|2#目錄}
scope.selection=選區
scope.unable.to.save.scope.message=是否要儲存為共享作用域?
scope.unable.to.save.scope.title=無法使用區域作用域
scope.view.empty.link=顯示所有專案檔案
scope.view.empty.text=當前作用域中沒有檔案。
scope.view.title=作用域
scopes.display.name=作用域
scopes.no.scoped=未新增作用域。
scopes.save.dialog.title.local=儲存為區域作用域
scopes.save.dialog.title.shared=儲存為共享作用域
scratches.and.consoles=臨時檔案和主控台
search.everywhere.action.tooltip.description.text=搜尋: <ul style=''list-style-type:none;margin:0;padding:0;''><li>- {0}</li><li>- 檔案</li><li>- 工具視窗</li><li>- 動作</li><li>- 設定</li></ul>
search.everywhere.action.tooltip.text=搜尋所有位置<br/>按 <b>{0}</b> 存取 <ul style=''list-style-type:none;margin:0;padding:0;''><li>- {1}</li><li>- 檔案</li><li>- 工具視窗</li><li>- 動作</li><li>- 設定</li></ul>
search.everywhere.command.plugins=延伸模組: {0}
search.everywhere.directory.file.type.name=目錄
search.everywhere.filter.classes.description=轉到類別
search.everywhere.filter.files.description=轉到檔案
search.everywhere.filter.symbols.description=轉到符號
search.everywhere.group.name.actions=動作
search.everywhere.group.name.files=檔案
search.everywhere.group.name.recent.files=最近的檔案
search.everywhere.group.name.symbols=符號
search.everywhere.group.name.top.hit=點擊最多
search.everywhere.points.more=…更多
search.for.usages.and.delete.elements=搜尋用法並刪除{0}?
searcheverywhere.accessible.name=隨處搜尋
searcheverywhere.allelements.tab.name=所有
searcheverywhere.autocompletion.tab.name=自動補全
searcheverywhere.commands.tab.name=指令
searcheverywhere.found.matches.title=''{0}'' 在 [{1}] 中的匹配項
searcheverywhere.found.targets.title=未排序的結果
searcheverywhere.history.shortcuts.hint=按 {0} 或 {1} 瀏覽搜尋歷史記錄
searcheverywhere.ide.search.tab.name=IDE
searcheverywhere.indexing.incomplete.results=在 {1} 更新索引期間，''{0}'' 中的搜尋結果可能不完整
searcheverywhere.indexing.mode.not.supported=在 {1} 更新索引期間，無法在 ''{0}'' 中搜尋
searcheverywhere.nothing.found.for.all.anywhere=找不到任何內容
searcheverywhere.nothing.found.for.contributor.anywhere=未找到使用此類別名的 {0}
searcheverywhere.open.in.new.window.shortcuts.hint=按 {0} 在新視窗中開啟檔案
searcheverywhere.open.in.split.shortcuts.hint=按 {0} 在右拆分中開啟檔案
searcheverywhere.project.search.tab.name=專案
searcheverywhere.reset.filters=重設篩選器
searcheverywhere.run.configs.tab.name=執行組態
searcheverywhere.runconfigurations.command.debug.description=在“偵錯”模式下開始執行組態
searcheverywhere.runconfigurations.command.run.description=在“執行”模式下開始執行組態
searcheverywhere.test.dialog.elements.limit=元素限制
searcheverywhere.test.dialog.grouping.interval=分組間隔
searcheverywhere.test.dialog.search.button=搜尋
searcheverywhere.test.dialog.search.field=搜尋文本
searcheverywhere.test.dialog.title=搜尋貢獻者測試
searcheverywhere.textfield.hint=輸入 {0} 以檢視指令
searcheverywhere.to.perform.fulltext.search=以執行全文搜尋
searcheverywhere.try.to.find.in.files=在檔案中尋找
searcheverywhere.try.to.reset.scope=將作用域設定為
searcheverywhere.use.main=使用
searcheverywhere.use.optional=或使用
section.title.fingerprints=指紋
section.title.issued.by=發佈者
section.title.issued.to=發佈物件
section.title.validity.period=有效期
select.in.commander=Commander
select.in.favorites=收藏夾
select.in.file.structure=檔案結構
select.in.packages=軟體套件
select.in.project=專案
select.in.scope=作用域
separator.scheme.stored.in=存儲於 {0}
setting.value.reload.mode.preview=在內置預覽中重新載入頁面:
setting.value.reload.mode.server=在瀏覽器中重新載入頁面:
settings.browsers.column.family=系列
settings.browsers.column.name=名稱
settings.browsers.column.path=路徑
settings.browsers.custom.path=自訂路徑
settings.browsers.default.browser=預設瀏覽器:
settings.browsers.first.listed=首先列出
settings.browsers.no.web.browsers.configured=未組態 Web 瀏覽器
settings.browsers.reload.behavior=重新載入行為
settings.browsers.show.browser.popup.html=對於 HTML 檔案
settings.browsers.show.browser.popup.in.the.editor=在編輯器中顯示瀏覽器彈出視窗
settings.browsers.show.browser.popup.xml=對於 XML 檔案
settings.browsers.system.default=系統預設值
settings.certificate.accept.non.trusted.certificates.automatically=自動接受非可信憑證(&A)
settings.certificate.accepted.certificates=接受的憑證:
settings.certificate.cannot.add.certificate=無法新增憑證
settings.certificate.cannot.add.certificate.for=無法為 {0} 新增憑證
settings.certificate.cannot.remove.certificate=無法移除憑證
settings.certificate.cannot.remove.certificate.for=無法移除 {0} 的憑證
settings.certificate.certificate.already.exists=憑證已存在
settings.certificate.choose.certificate=選擇憑證
settings.certificate.malformed.x509.server.certificate=X509 伺服器憑證的格式錯誤
settings.certificate.no.certificate.selected=未選擇任何憑證
settings.certificate.no.certificates=無憑證
settings.certificate.not.imported=未匯入
settings.entry.point.newUi.tooltip=新 UI 可用
settings.entry.point.tooltip=IDE 和專案設定
settings.entry.point.update.ide.action=下載 {0} {1}
settings.entry.point.update.plugin.action=更新 {0} 延伸模組…
settings.entry.point.update.plugins.action=更新 {0} 延伸模組…
settings.entry.point.widget.name=IDE 和專案設定
settings.entry.point.with.updates.tooltip=有可用更新。IDE 和專案設定
settings.file.color.column.color=顏色
settings.file.color.column.scope=作用域
settings.file.color.column.shared=通過 VCS 共享
settings.file.color.column.shared.help=<html>共享組態存儲在 <code>.idea</code> 目錄中，<br>其他團隊成員可以通過 VCS 使用。
settings.file.color.custom.name=自訂
settings.file.colors.add.colors.link=新增顏色
settings.file.colors.description=<html>檔案可以屬於多個作用域。如果一個作用域有兩種顏色，則使用列表中第一個作用域的顏色。
settings.file.colors.dialog.choose.color=選擇作用域顏色
settings.file.colors.dialog.warning.append=您是否希望再次新增?
settings.file.colors.dialog.warning.local=已為 {0} 定義區域顏色
settings.file.colors.dialog.warning.replace=<html>是否要將<span style="background-color:#{0};">舊顏色</span>更新為<span style="background-color:#{1};">新顏色</span>?
settings.file.colors.dialog.warning.shared=已為 {0} 定義共享顏色
settings.file.colors.dialog.warning.update=更新
settings.file.colors.enable.file.colors=啟用檔案顏色(&F)
settings.file.colors.manage.scopes=管理作用域(&M)…
settings.file.colors.no.colors.specified=未新增顏色
settings.file.colors.scope.unknown=不存在的作用域
settings.file.colors.use.in.editor.tabs=在編輯器頁籤中使用(&T)
settings.file.colors.use.in.project.view=在專案檢視中使用(&P)
settings.general.directory.preselected=“開啟…” 和 “新增 | 專案…” 對話框中會預先選擇此目錄。
settings.general.synchronization=自動儲存
settings.menus.group.touch.bar=Touch Bar
settings.password.internal.error.no.available.credential.store.implementation=內部錯誤，沒有可用的憑證存儲實作。
settings.password.package.libsecret.1.0.is.not.installed=未安裝軟體套件 libsecret-1-0 (要安裝，請使用以下指令: sudo apt-get install libsecret-1-0 gnome-keyring)。
settings.password.unknown.provider.type=未知提供程序類型: {0}
settings.required.plugins.title=指定專案所需的延伸模組列表。如果缺少必需延伸模組或需要更新，{0} 將通知您。
settings.trusted.certificates=驗證延伸模組時受信任的憑證:
share.scope.checkbox.title=通過 VCS 共享
share.scope.context.help=<html>共享組態存儲在 <code>.idea</code> 目錄中，<br>其他團隊成員可以通過 VCS 使用。
shell.env.loading.failed={0} 未能從 ''{1}'' 載入環境。與依賴於環境變數的工具整合可能無法正常進行。
shell.env.loading.learn.more=了解詳情
shortcut.balloon.add.shortcut=新增快捷鍵
shortcut.in.group.text=在 {0} 中
show.hidden.tabs=顯示隱藏的頁籤
show.in.find.window.button.description=在“尋找工具”視窗中開啟搜尋結果
show.in.find.window.button.name=在“尋找工具”視窗中開啟
show.in.find.window.button.name.newui=在尋找視窗中開啟結果
show.in.find.window.button.pin.description=在單獨的工具視窗中顯示所有用法
show.main.toolbar=顯示主工具列
show.members.in.navigation.bar=在導覽列中顯示成員
show.navigation.bar=顯示導覽列
show.options.menu=選項
show.status.bar=顯示狀態列
small.labels.in.editor.tabs=編輯器頁籤中的小標籤
speed.search.got.it.link=知道了
speed.search.got.it.text=只需開始輸入以篩選元素
split.with.chooser.duplicate.tab=，{0}以複製
split.with.chooser.move.tab=按 {0} 開啟“{1}”
split.with.chooser.switch.tab=使用 {0} 轉到下一個拆分器
start.browser.border.label.open.browser=開啟瀏覽器
start.browser.checkbox.start.browser=在啟動後
start.browser.panel.url.label=URL(&U):
start.browser.with.js.debugger=使用 JavaScript 偵錯器(&J)
status.bar.message.at.line=行 {0}: {1}
status.bar.text.file.encoding=檔案編碼: {0}
status.bar.text.macro.recorded=已記錄: {0}
status.bar.text.script.execution.finished=腳本執行已完成
structure.view.tree.accessible.name=結構檢視樹
support.screen.readers.tab={0} 和 {1} 將在對話框中導覽 UI 控件，並且不能用於切換編輯器頁籤或其他 IDE 動作
sys.health.acknowledge.action=不再顯示
sys.health.details=詳細資訊
tab.chooser.project=專案
tab.chooser.search.by.name=按名稱搜尋
tab.filetemplates.code=程式碼
tab.filetemplates.includes=Include
tab.filetemplates.j2ee=其他
tab.filetemplates.templates=檔案
tab.title.editor.and.preview=編輯器和預覽
tab.title.editor.only=編輯器
tab.title.html.preview=HTML 預覽
tab.title.preview.only=預覽
tab.title.stacktrace=<堆疊追蹤>
tab.title.text=文本
tabs.layout.compressible.name=可壓縮單排
tabs.layout.scrollable.single.row.name=可滾動單排
tabs.layout.table.name=表布局
task.browser.label=瀏覽器:
task.browser.launch=啟動 Web 瀏覽器
task.browser.url=URL:
temp.dir.env.invalid=環境變數 ''{0}'' 指向不存在的目錄(''{1}'')。有些東西可能工作不正常。
template.copy.N.of.T=複製 {0} 個 {1}
template.file.name=用於生成檔名和路徑的模板
template.file.name.optional=用於生成檔名和路徑的模板(可選)
template.unnamed=未命名
terminal.action.ClearBuffer.text=清除緩衝區
terminal.action.Find.text=尋找
terminal.action.LineDown.text=向下移動一行
terminal.action.LineUp.text=向上滾動一行
terminal.action.MoveLeft.text=左移
terminal.action.MoveRight.text=右移
terminal.action.OpenAsUrl.text=作為 URL 開啟
terminal.action.PageDown.text=向下翻頁
terminal.action.PageUp.text=向上翻頁
terminal.action.SelectNextTab.text=選擇下一個頁籤
terminal.action.SelectPreviousTab.text=選擇上一個頁籤
terminal.action.ShowTabs.text=顯示頁籤
terminal.cursor.shape.block.name=塊
terminal.cursor.shape.underline.name=下劃線
terminal.cursor.shape.vertical.name=垂直線
text.password.hidden=<已隱藏>
text.server.s.certificate.trusted=伺服器的憑證不可信
text.server.s.certificate.trusted.details=伺服器的憑證不可信:<br/>{0}
text.todo.no.filters=未組態篩選器
text.todo.no.patterns=未組態模式
text.use.solution.colors.in.main.toolbar=一目了然地區分具有不同工具列顏色的專案。僅適用於新 UI。
this.directory.does.not.belong.to.the.project={0, choice, 1#這一目錄|2#這些目錄}不屬於專案:
this.file.does.not.belong.to.the.project={0, choice, 1#這一檔案|2#這些檔案}不屬於專案:
thread.dump.is.taken=執行緒傾印已被<a href="{0}">佔用</a>。
tip.of.the.day.feedback.dislike=不喜歡
tip.of.the.day.feedback.like=喜歡
tip.of.the.day.feedback.question=您覺得這個小技巧是否有用?
tip.of.the.day.progress.title=顯示每日小技巧
tips.of.the.day.shortcut.default.keymap=(預設按鍵映射)
tips.of.the.day.shortcut.must.define=未定義，通過“設定/按鍵映射”設定
title.accessibility=無障礙功能
title.add.new.favorites.list=新增新收藏夾列表
title.add.todo.filter=新增篩選器
title.add.todo.pattern=新增模式
title.appearance=外觀
title.browse.icon=瀏覽圖示
title.browser.not.found=未找到瀏覽器
title.cannot.convert.project=無法轉換專案
title.cannot.create.class=無法建立類別
title.cannot.create.file=無法建立檔案
title.cannot.load.project=無法載入專案
title.cannot.open.file=無法開啟檔案
title.cannot.open.project=無法開啟專案
title.cannot.save.current.template=無法儲存當前模板
title.choose.action.icon=選擇動作圖示
title.choose.destination.directory=選擇目標目錄
title.common=通用
title.customizations=選單與工具列
title.delete=刪除
title.edit.file.template=編輯檔案模板
title.edit.macros=編輯巨集
title.edit.todo.filter=編輯篩選器
title.edit.todo.pattern=編輯模式
title.enter.macro.name=輸入巨集名稱
title.error.reading.file=讀取檔案時出錯
title.error.writing.file=寫入檔案時錯誤
title.export.preview=匯出預覽
title.file.already.exists=檔案已存在
title.file.templates=檔案和程式碼模板
title.general=系統設定
title.hierarchy.callees.of={0} 的被呼叫方
title.hierarchy.callers.of={0} 的呼叫方
title.hierarchy.class=類別{0}
title.hierarchy.method=方法 {0}
title.hierarchy.subtypes={0}的子類型
title.hierarchy.supertypes={0}的父類型
title.load.file.from.share=正在從網絡載入檔案
title.load.project.from.share=正在從網絡載入專案
title.macro.name.already.used=巨集名稱已被使用
title.module.file.does.not.exist=模組檔案不存在: {0}
title.module.group=模組組
title.module.sub.group=模組子組
title.new.directory=新增目錄
title.new.file=新增檔案
title.new.from.template=新增 {0}
title.new.package=新增軟體套件
title.no.element.selected=未選擇任何元素
title.open.file.or.project=開啟檔案或專案
title.open.project=開啟專案
title.package.not.found=找不到軟體套件
title.plugin.error=延伸模組錯誤
title.plugin.installation=延伸模組安裝
title.plugin.uninstall=解除安裝套件
title.plugins=延伸模組
title.popup.new.element=新增
title.popup.new.element.same.place=在此目錄中新增
title.popup.recent.files=最近的檔案
title.popup.select.target=選擇位置:
title.project=專案
title.rename.favorites.list=重新命名
title.rename.library=重新命名庫
title.rename.macro=重新命名巨集
title.rename.module=重新命名模組
title.reset.template=重設模板
title.restart.needed=需要重啟
title.search.results=搜尋結果
title.select.path.to.browser=選擇瀏覽器的路徑
title.select.project.file.directory=選擇{0}檔案目錄
title.select.template=選擇模板
title.smooth.scrolling.options=平滑滾動選項
title.tip.of.the.day=每日小技巧
title.todo=TODO
title.todo.current.file=當前檔案
title.unable.to.add.favorites.list=無法新增收藏夾列表
title.use.rest.api=使用 REST API
title.velocity.error=Velocity 錯誤
title.warning=警告
to.create.new.file.tooltip=要建立新檔案，請按 <b>{0}</b>。或者右擊任何目錄並選擇<b>新增 | \\\\&lt;file type\\\\&gt;</b>
todo.panel.preview.source.action.text=預覽源
toggle.editor.and.tools=編輯器和工具
toggle.empty.frame=空框架
too.large.download.size=通過塊映射下載歸檔需要太多塊，因此將下載整個歸檔
toolbox.updates.download.ready.action.description=Toolbox App 已安裝 {2} {1} ({0})。是否重啟到新版本?
toolbox.updates.download.ready.action.text=切換到 {2} {1} ({0})…
toolbox.updates.download.update.action.description=Toolbox App 將下載 {2} {1} ({0}) 並通知您更新切換就緒的時間
toolbox.updates.download.update.action.text=下載 {2} {1} ({0})
tooltip.autosave.mode=自動儲存模式
tooltip.close.notification=關閉。按 Alt 並點擊以關閉所有通知
tooltip.close.tab=關閉頁籤
tooltip.eap.plugin.version=EAP 版本不保證延伸模組的穩定性\\n和可用性。
tooltip.event.log.show.balloon=顯示氣球
tooltip.flip.horizontally=水平翻轉
tooltip.flip.vertically=垂直翻轉
tooltip.from.deployment.configuration=來自部署組態:
tooltip.hide=隱藏
tooltip.inherited.editor.color.scheme=編輯器 | 配色方案 | {0}<br>{1}
tooltip.license.not.required.for.eap.version=EAP 版本不需要授權
tooltip.line.separator=行分隔符: {0}
tooltip.macro.is.being.recorded.now=正在錄製巨集
tooltip.module.group=模組組
tooltip.paid.plugin=安裝後啟用延伸模組授權或使用 30 天試用。
tooltip.recent.search=最近搜尋
tooltip.search.history=搜尋歷史記錄
tooltip.search.history.hotkey=搜尋歷史記錄 {0}
tooltip.shared.folders.from.vagrantfile=來自 Vagrantfile 的共享目錄:
tooltip.text.add.shortcut.with.special.keys=使用 {0} 鍵設定快捷鍵
tooltip.text.password.will.be.stored.between.application.sessions=密碼將存儲在應用程式會話之間
tooltip.text.update.is.in.progress.click.to.cancel=正在更新。點擊以取消
tooltip.turn.notification.off=關閉或更改行為
tooltip.ui.designer.form=UI 設計器表單
toolwindow.header.accessible.name=工具視窗標題
toolwindow.palette=調色板
toolwindow.stripe.Bookmarks=書籤
toolwindow.stripe.Commit=提交
toolwindow.stripe.Event_Log=事件日誌
toolwindow.stripe.Favorites=收藏夾
toolwindow.stripe.Notifications=通知
toolwindow.stripe.Problems=自動建置
toolwindow.stripe.ProblemsView=問題
toolwindow.stripe.Problems_View=問題
toolwindow.stripe.Profiler=分析器
toolwindow.stripe.Project=專案
toolwindow.stripe.Statistics_Event_Log=統計事件日誌
toolwindow.stripe.Structure=結構
toolwindow.stripe.TODO=TODO
toolwindow.stripe.Version_Control=版本控制
toolwindow.stripe.documentation.v2=文檔
transfer.settings.notificationGroup=傳輸設定訊息
transfersettings.button.retry.import=重試匯入
transfersettings.label.build.solution=建置解決方案
transfersettings.label.debug=偵錯
transfersettings.label.failed.to.import.settings.from=無法從 {0} {1} 匯入設定
transfersettings.label.find.usages=尋找用法
transfersettings.label.go.to.declaration=轉到宣告
transfersettings.label.please.try.again=請重試
transfersettings.label.run=執行
transfersettings.label.search.everywhere=隨處搜尋
transfersettings.plugin.built.in=內建
transfersettings.plugin.plugin=延伸模組
transfersettings.product.visual.studio=Visual Studio
transfersettings.product.visual.studio.for.mac=Visual Studio for Mac
transfersettings.product.vscode=VSCode
transfersettings.projects.and.n.more=和其他 {0} 個
transfersettings.task.progress.details.complete=完成
transfersettings.task.progress.details.finishing.up=正在完成…
transfersettings.task.progress.details.starting.up=正在啟動…
transfersettings.task.progress.title.importing.settings=正在匯入設定
transfersettings.vs.failureReason=如果 Visual Studio 處於開啟狀態或其檔案被另一個程序存取，則會發生這種情況。{0}
transfersettings.vs.noSettings=如果未正確移除 Visual Studio、其設定損壞或從未啟動，則會發生這種情況。
transfersettings.vs.quit.advise=退出 Visual Studio 和所有使用 Visual Studio 工具的程序。之後等待大約 30 秒。
treenode.loading=正在載入…
trial.expired=試用已過期。
trusted.folders.settings.label=位於這些本地目錄下的專案將被視為受信任的專案
trusted.hosts.settings.new.trusted.folder.dialog.title=新增受信任的位置
trusted.hosts.settings.new.trusted.folder.file.chooser.title=選擇受信任的位置
ui.customization.select.auto.popup.by.chars.text=通過按空格、點或其他上下文相關鍵插入選定建議
undo.command=撤消{0}
undo.command.local.name=本地
undo.conflicting.change.confirmation=受此動作影響的其他檔案已更改。
undo.dialog.title=撤消
uninstall.packages.failed=無法解除安裝軟體套件。<a href="xxx">詳細資訊…</a>
uninstall.packages.failed.dialog.title=解除安裝軟體套件失敗
unknown.error=未知錯誤
unscramble.dialog.title=分析堆疊追蹤
unsupported.windows=This version of Windows is no longer supported. Some features may not work correctly. Please use Windows 10 1809 or newer.
untrusted.project.dialog.distrust.button=繼續使用安全模式
untrusted.project.dialog.trust.button=信任專案
untrusted.project.link.dialog.cancel.button=不連結
untrusted.project.link.dialog.title=是否信任並連結 {0} 專案 ''{1}''?
untrusted.project.notification.description=安全模式，功能受限。信任該專案以存取完整的 IDE 功能。
untrusted.project.notification.read.more.link=閱讀更多資訊
untrusted.project.notification.trust.link=信任專案…
untrusted.project.open.dialog.cancel.button=不開啟
untrusted.project.open.dialog.distrust.button=在安全模式下預覽
untrusted.project.open.dialog.text={0} 提供的功能可能會從此目錄執行潛在的惡意程式碼。\\n\\n如果不信任此源，請在安全模式下預覽專案，以便僅瀏覽其程式碼。
untrusted.project.open.dialog.title=信任並開啟專案 ''{0}''?
untrusted.project.warning.trust.location.checkbox=信任 {0} 中的專案
update.apply.manually.message=抱歉，IDE 無法在您的系統上執行自動更新。\\n請退出 IDE 並通過啟動此腳本手動套用更新檔:\\n{0}。
update.channel.enforced=更新通道已切換為 ''{0}''
update.downloading.patch.error=無法準備更新:<br>{0}
update.downloading.patch.open=開啟下載頁面
update.downloading.patch.progress=正在下載更新檔檔案
update.downloading.plugins.progress=正在下載延伸模組更新
update.installed.notification.title=已安裝延伸模組更新
update.no.update.hosts=沒有組態延伸模組儲存庫
update.preparing=正在準備 IDE 更新
update.preparing.patch.progress=正在準備更新檔檔案
update.ready.message=IDE 已準備好更新
update.ready.restart=重新啟動
update.snap.blog.post.action=網誌
update.snap.message=IDE 已通過 Snap 更新。
update.whats.new={0} 最新變化
updates.all.plugins.action={0,choice,1#更新|2#全部更新}
updates.apply.manually.button=手動更新(&D)
updates.channel.bundled.key=新版本有一個到期日期，不需要授權密鑰。
updates.checking.platform=正在檢查 IDE 更新
updates.checking.plugins=正在檢查延伸模組更新
updates.checking.progress=正在檢查更新
updates.configure.label=<b><a href="updates">組態</a></b>自動更新。
updates.configure.updates.label=組態更新…
updates.dialog.title={0} 和延伸模組更新
updates.download.and.restart.button=更新並重啟(&D)
updates.download.button=下載(&L)
updates.error.connection.failed=連線失敗({0})。請檢查您的網絡連線並重試。
updates.error.connection.title=連線錯誤
updates.external.error.message=無法檢查 {0} 的更新: {1}
updates.external.progress=正在提取外部元件的可用更新
updates.external.ready.message={0,choice,1#元件|2#元件}: {1}
updates.fallback.build=您有新版本的永久回退授權。
updates.from.to=將 {0} 更新到 {1} ({2})。
updates.from.to.size=正在將 {0} 更新到 {1} ({2})。補丁大小為 {3} MB。
updates.ignore.update.button=忽略這個更新(&I)
updates.ignore.updates.button=忽略{0,choice,1#此更新|2#這些更新}(&I)
updates.ignore.updates.link=忽略{0,choice,1#此更新|2#這些更新}
updates.incompatible.plugins.found=新版本中的: {0,choice,1#'' ''|2#'<br/>'} {1} 與 {0,choice,1#延伸模組|2#延伸模組} 不相容
updates.interim.build=您可以使用新版本，直到您的訂閱於 {0} 到期。
updates.last.check.never=從不
updates.new.build.notification.title={0}{1}可用
updates.new.version.available=<b>有新版本的 {0} <a href="{1}">可用</a>!</b>
updates.no.updates.message=您已安裝最新版本的 {0} 和延伸模組。
updates.no.updates.notification=沒有可用的 IDE 或延伸模組更新
updates.no.updates.snap.message=<html>所有延伸模組都處於最新狀態。<br> {0} 更新由 Snap 管理。<br>執行 ''snap refresh'' 指令以檢查更新。</html>
updates.no.updates.toolbox.message=<html>所有延伸模組都是最新的。<br> {0} 更新由 Toolbox App 管理。<br>啟動它以檢查是否有可用更新。</html>
updates.no.updates.unknown.message=<html>所有延伸模組都是最新的。<br> {0} 更新由 {1} 管理。</html>
updates.notification.title={0} 和延伸模組更新
updates.notification.update.action=更新…
updates.paid.upgrade=您可以評估新版本 {0} 天，或者線上購買。
updates.plugin.ready.title=有可用的 {0} 延伸模組更新
updates.plugin.ready.tooltip={0} 個{1,choice,1#延伸模組|2#延伸模組}{1,choice,1#更新|2#更新}可用
updates.plugins.dialog.action=詳細資訊…
updates.plugins.error.message1=無法從預設儲存庫載入延伸模組: {0}
updates.plugins.error.message2=無法從 ''{0}'' 載入延伸模組: {1}
updates.plugins.ready.title=有可用的延伸模組更新
updates.plugins.settings.checkbox=檢查延伸模組更新
updates.remind.later.button=稍後提醒我(&R)
updates.settings.channel.locked=EAP 版本只能通過 EAP 通道更新
updates.settings.check.now.button=檢查更新(&C)…
updates.settings.checkbox=檢查 IDE 更新
updates.settings.checkbox.for=為之檢查 IDE 更新:
updates.settings.current.version=當前版本:
updates.settings.external=IDE 更新由 {0} 在外部管理
updates.settings.ignored=管理忽略的更新…
updates.settings.ignored.title=忽略的更新
updates.settings.last.check=上次檢查: {0}
updates.settings.recommend.toolbox=我們推薦 <a href=''{0}''>{1}</a>
updates.settings.recommend.toolbox.multiline.description=自動獲取更新，一鍵開啟您的專案，<br>了解其他 JetBrains 產品等
updates.settings.show.editor=IDE 更新後在編輯器中顯示新功能
updates.settings.title=更新
updates.write.protected={0} 沒有 {1} 的寫入權限。請通過特權使用者執行以更新。
upgrade.package.failed.title=升級軟體套件失敗。
upgrade.packages.failed=無法升級軟體套件。<a href="xxx">詳細資訊…</a>
upgrade.packages.failed.dialog.title=升級軟體套件失敗
uses.shortcut.of=繼承自
vagrant.vm.1.choice.0.0.1.at.2.3=Vagrant 虛擬機{1, choice, 0#“{0}”|1#}，處於 {2} ({3})
vm.options.edit.action.cap=編輯自定義虛擬機選項
vm.options.env.vars=檢測到使用了 Java 選項環境變數。此類別變數將覆寫 IDE 組態檔案(*.vmoptions)，並可能導致性能和穩定性問題。請考慮刪除以下變數: {0}。
warning.create.directory.with.dot=注意: 名稱中的 "." 會被視為一般字元。如果要建立嵌套目錄，請改用 "/"
warning.create.directory.with.ignored.name=正在嘗試建立包含忽略名稱(''{0}'')的目錄；結果將不可見
warning.create.package.with.ignored.name=正在嘗試建立包含忽略名稱(''{0}'')的軟體套件；結果將不可見
warning.delete.all.files.and.subdirectories=\\n“{0}”中的所有檔案和子目錄將被刪除。\\n您可能無法完全撤消此動作!
warning.delete.all.files.and.subdirectories.in.the.selected.directory=\\n所選目錄中的所有檔案和子目錄將被刪除。\\n您可能無法完全撤消此動作!
warning.load.file.from.share=您正在開啟來自網絡共享的檔案。是否要繼續?\\n{0}
warning.load.project.from.share=您正在開啟來自網絡共享的專案。您是否信任此位置?\\n{0}
warning.use.rest.api.0.and.trust.host.1=''{0}'' API 已請求。您信任 ''{1}'' 嗎?
warning.use.rest.api.0.and.trust.host.unknown=已請求 ''{0}'' API。您是否信任未知主機?
warning.use.rest.api.block.unknown.hosts=是否要阻止來自未知主機的請求?
web.preview.file.editor.name={0} 的預覽 
web.preview.reload.mode.disabled=已停用
web.preview.reload.mode.on.change=更改時
web.preview.reload.mode.on.save=儲存時
welcome.expUi.promo.button=啟用新 UI
welcome.expUi.promo.description={0} 採用了新的現代設計 — 降低了視覺複雜性，減少了干擾，並具有相同的功能
welcome.expUi.promo.header=認識新 UI
welcome.screen.action.docs.how.tos.action.text=文檔和指南
welcome.screen.all.settings.link=所有設定…
welcome.screen.check.for.updates.comment=更新。
welcome.screen.color.theme.header=顏色方案
welcome.screen.configure.action.text=組態
welcome.screen.copy.about.action.text=複製有關資訊
welcome.screen.customize.title=自訂
welcome.screen.drop.files.to.open.text=將檔案拖放到此處以開啟
welcome.screen.empty.projects.create.comment=從頭建立新項目。
welcome.screen.empty.projects.open.comment=從磁碟或版本控制中開啟現有專案。
welcome.screen.ide.font.size.label=IDE 字體:
welcome.screen.learnIde.help.and.resources.text=幫助和資源
welcome.screen.learnIde.interactive.courses.text=互動課程
welcome.screen.learnIde.title=學習
welcome.screen.logo.version.label=版本 {0}
welcome.screen.more.actions.link.text=更多動作
welcome.screen.plugins.title=延伸模組
welcome.screen.projects.title=專案
welcome.screen.quick.start.action.text=快速開始
welcome.screen.search.projects.empty.text=搜尋專案
whats.new.action.custom.description=了解此版本的 {0} 中的新功能
whats.new.action.custom.text={0} 最新變化(_N)
whats.new.notification.action=檢視最新變化
whats.new.notification.text={0} {1} 登場!
whats.new.timeout.action=您可以<a href="{0}" class="link" target="_blank">在瀏覽器中開啟此頁面</a>或稍後重試。
whats.new.timeout.message=無法載入該頁面的內容。請檢查您的互聯網連線。
whats.new.timeout.title=無法載入頁面
window.title.switcher=切換器
windows.native.common.dialog.open=開啟
windows.native.common.dialog.select.folder=選擇目錄
wrong.http.range.response=HTTP 範圍響應的行過長 {0}
wrong.number.of.arguments.usage.ide.executable.exit=實參數量錯誤。用法: <ide executable> exit [--restart]
wrong.number.of.arguments.usage.ide.executable.save=實參數量錯誤。用法: <ide 可執行檔案> 儲存
wsl.cant.parse.ip.no.output=無法解析 {0}，因為輸出未包含足夠的資料。請參閱 idea.log 了解特定錯誤。
wsl.cant.parse.ip.process.failed=由於程序失敗，無法解析 {0}。請參閱 idea.log 了解特定錯誤。
wsl.enter.root.password.dialog.title=輸入根密碼
wsl.error.host.ip.not.obtained.message=無法獲取 WSL 分發的主機 IP: {0}
wsl.executing.process=正在執行 WSL 程序
wsl.linux.distribution.label=Linux 分發版(&D):
wsl.no.distribution.found.error=WSL: 應設定 Linux 分發版
wsl.no.installed.distributions=沒有安裝分發版
wsl.no.rsync=請在您的 {0} WSL 上安裝 rsync
wsl.no_path=找不到此分發版特定於 Windows 的部分，無法瀏覽
wsl.not.installed.dialog.message=在 %PATH% 中找不到 wsl.exe，請安裝 WSL
wsl.not.installed.distribution=未安裝 {0}
wsl.opening_wsl=正在開啟 WSL…
wsl.rsync.unable.to.copy.files.dialog.message=無法將檔案複製到 {0}
wsl.rsync.unable.to.create.target.dir.message=無法建立目標目錄 {0}
wsl.sudo.password.for.root.label={0} 根的 Sudo 密碼:
wsl.target.introspection.step.command.finished.with.exit.code=程序已結束，退出程式碼為 {0}
wsl.target.introspection.step.completed.successfully=內省成功完成!
wsl.target.introspection.step.completed.with.errors=內省完成但有錯誤。
wsl.target.introspection.step.description=WSL 分發版內省
wsl.target.language.step.description=用於 {1} 的 {0} 執行時組態
wsl.target.tool.step.description=WSL 組態
wsl.win.ip=主機 (Windows) IP
wsl.wsl.ip=WSL (Linux) IP
x.and.y={0} 和 {1}"
`;

exports[`dev messages/InspectionGadgetsBundle.properties 1`] = `
"0.will.no.longer.be.overridable.by.1={0} 將不再可被 {1} 覆寫
absolute.alignment.in.user.interface.display.name=AWT/Swing 程式碼中的絕對對齊
absolute.alignment.in.user.interface.fix.family.name=取代為常數
absolute.alignment.in.user.interface.problem.descriptor=使用了絕對對齊常數 <code>{0}.#ref</code> #loc
abstract.class.extends.concrete.class.display.name=抽象類別擴展具體類別
abstract.class.extends.concrete.class.problem.descriptor=類別 <code>#ref</code> 被宣告為 'abstract'，並擴展一個具體類別 #loc
abstract.class.naming.convention.element.description=抽象類別
abstract.class.never.implemented.display.name=沒有具體子類別的抽象類別
abstract.class.never.implemented.problem.descriptor=抽象類別 <code>#ref</code> 沒有具體子類別 #loc
abstract.class.with.only.one.direct.inheritor.display.name=只有一個直接繼承者的抽象類別
abstract.class.with.only.one.direct.inheritor.problem.descriptor=只有一個直接繼承者的抽象類別 <code>#ref</code> #loc
abstract.class.without.abstract.methods.display.name=沒有 'abstract' 方法的抽象類別
abstract.class.without.abstract.methods.ignore.utility.class.option=忽略實用程序類別
abstract.class.without.abstract.methods.problem.descriptor=類別 <code>#ref</code> 被宣告為 'abstract'，並且沒有 'abstract' 方法 #loc
abstract.method.call.in.constructor.display.name=物件建構期間呼叫的 abstract 方法
abstract.method.call.in.constructor.problem.descriptor=物件建構期間呼叫 'abstract' 方法 <code>#ref()</code> #loc
abstract.method.overrides.abstract.method.display.name=abstract 方法覆寫 abstract 方法
abstract.method.overrides.abstract.method.ignore.different.javadoc.option=忽略 Javadoc 與其 super 方法不同的方法
abstract.method.overrides.abstract.method.problem.descriptor=abstract 方法 <code>#ref()</code> 覆寫 abstract 方法 #loc
abstract.method.overrides.abstract.method.remove.quickfix=移除冗餘 abstract 方法宣告
abstract.method.overrides.concrete.method.display.name=abstract 方法覆寫具體方法
abstract.method.overrides.concrete.method.problem.descriptor=abstract 方法 <code>#ref()</code> 覆寫具體方法 #loc
abstract.method.with.missing.implementations.display.name=缺少實作的 abstract 方法
abstract.method.with.missing.implementations.problem.descriptor=abstract 方法 <code>#ref()</code> 未在每個子類別中實作 #loc
access.to.non.thread.safe.static.field.from.instance.class.chooser.title=選擇非執行緒安全類別
access.to.non.thread.safe.static.field.from.instance.display.name=非執行緒安全的 'static' 欄位存取
access.to.non.thread.safe.static.field.from.instance.field.problem.descriptor=存取類型為 ''{0}'' 的非執行緒安全 static 欄位 <code>#ref</code> #loc
access.to.non.thread.safe.static.field.from.instance.option.title=非執行緒安全類別:
access.to.static.field.locked.on.instance.display.name=存取執行個體資料上鎖定的 'static' 欄位
access.to.static.field.locked.on.instance.fix.name=忽略類型 ''{0}'' 的 static 欄位
access.to.static.field.locked.on.instance.problem.descriptor=存取執行個體資料上鎖定的 static 欄位 <code>#ref</code> #loc
accessing.non.public.field.of.another.object.display.name=存取另一個物件的非 public 欄位
accessing.non.public.field.of.another.object.problem.descriptor=直接存取另一個物件的非 public 欄位 <code>#ref</code> #loc
add.0.to.ignore.if.annotated.by.list.quickfix=將 ''{0}'' 新增到“由以下物件註解時忽略”列表中
add.catch.section.fix.family.name=新增 'catch' 子句
add.read.write.object.methods.fix.family.name=新增始終拋出異常的 'readObject()' 和 'writeObject()' 方法
add.read.write.object.methods.fix.text=新增始終拋出異常的 'writeObject()' 方法
add.read.write.object.methods.fix.text2=新增始終拋出異常的 'readObject()' 方法
add.serialversionuidfield.quickfix=新增 'serialVersionUID' 欄位
add.this.qualifier.quickfix=新增 'this' 限定符
add.throws.clause.fix.family.name=修復 'throws' 子句
all.levels.option=所有日誌級別
allow.resource.to.be.opened.inside.a.try.block=允許在 'try' 塊內開啟資源
allow.suppressions.fix.family.name=允許禁止
allow.suppressions.fix.text=允許這些禁止
allow.suppressions.preview.text=檢查 ID 將被新增到設定中的允許禁止列表中
ambiguous.field.access.display.name=對繼承欄位的存取類似於對周圍程式碼中元素的存取
ambiguous.field.access.hides.field.problem.descriptor=存取超類別 ''{0}'' 中的 <code>#ref</code> 欄位類似於存取周圍類別中的欄位 #loc
ambiguous.field.access.hides.local.variable.problem.descriptor=存取超類別 ''{0}'' 中的 <code>#ref</code> 欄位類似於存取區域變數 #loc
ambiguous.field.access.hides.parameter.problem.descriptor=存取超類別 ''{0}'' 中的 <code>#ref</code> 欄位類似於存取參數 #loc
ambiguous.field.access.navigate.quickfix=導覽到明顯存取過的{0, choice, 1#區域變數|2#參數|3#欄位}
ambiguous.field.access.quickfix=將 'super' 限定符新增到欄位存取
ambiguous.method.call.display.name=對繼承方法的呼叫類似於對本地方法的呼叫
ambiguous.method.call.problem.descriptor=對來自超類別 ''{0}'' 的方法 <code>#ref()</code> 的呼叫類似於對來自類別 ''{1}'' 的方法的呼叫 #loc
ambiguous.method.call.quickfix=向方法呼叫中新增 'super' 限定符
annotation.class.display.name=註解接口
annotation.class.problem.descriptor=註解接口 <code>#ref</code> #loc
annotation.display.name=註解
annotation.naming.convention.element.description=註解接口
annotation.problem.descriptor=註解 <code>#ref</code> #loc
anonymous.class.field.hides.containing.method.variable.problem.descriptor=匿名類別欄位 <code>#ref</code> 隱藏包含方法中的變數 #loc
anonymous.class.parameter.hides.containing.method.variable.problem.descriptor=匿名類別參數 <code>#ref</code> 隱藏包含方法中的變數 #loc
anonymous.class.variable.hides.containing.method.variable.display.name=匿名類別變數隱藏包含方法中的變數
anonymous.class.variable.hides.containing.method.variable.problem.descriptor=匿名類別區域變數 <code>#ref</code> 隱藏包含方法中的變數 #loc
anonymous.extends.concrete.collection.problem.descriptor=匿名類別顯式擴展 ''{0}'' #loc
anonymous.extends.thread.problem.descriptor=匿名類別直接擴展 'java.lang.Thread' #loc
anonymous.extends.throwable.problem.descriptor=匿名類別直接擴展 'java.lang.Throwable' #loc
anonymous.inner.class.display.name=匿名內部類別可被取代為內部類別
anonymous.inner.class.problem.descriptor=匿名內部類別 <code>#ref</code> #loc
anonymous.inner.class.with.too.many.methods.display.name=具有太多方法的匿名內部類別
anonymous.inner.class.with.too.many.methods.problem.descriptor=具有太多方法的匿名內部類別 (方法計數 = {0}) #loc
anonymous.inner.may.be.named.static.inner.class.display.name=匿名類別可能是命名為 'static' 的內部類別
anonymous.inner.may.be.named.static.inner.class.problem.descriptor=匿名類別 <code>#ref</code> 可能是命名為 'static' 的內部類別 #loc
anonymous.inner.may.be.named.static.inner.class.quickfix=轉換為命名 'static' 內部類別
any.method.may.close.resource.argument=任何方法都可能關閉作為實參傳遞的資源
array.allocation.zero.length.display.name=零長度陣列分配
array.allocation.zero.length.problem.descriptor=零長度陣列的分配 #loc
array.can.be.replaced.with.enum.values = 可以將陣列取代為枚舉值
array.can.be.replaced.with.enum.values.family.quickfix = 將陣列取代為 EnumType.values()
array.can.be.replaced.with.enum.values.quickfix = 將陣列取代為 {0}.values()
array.comparison.display.name=使用 '==' 而不是 'Arrays.equals()' 進行陣列比較
array.comparison.problem.descriptor=使用 <code>#ref</code> 而不是 'Arrays.equals()' 來比較陣列物件 #loc
array.creation.without.new.keyword.family.quickfix=新增 'new' 表達式
array.creation.without.new.keyword.name=建立不帶 'new' 表達式的陣列
array.creation.without.new.keyword.quickfix=新增 ''new {0}''
array.equals.problem.descriptor=或許應當使用 ''{0}'' 完成陣列比較''
array.hash.code.display.name=在陣列上呼叫了 'hashCode()'
array.hash.code.fix.family.name=取代為 'Arrays.hashCode()' 呼叫
array.hash.code.problem.descriptor=陣列上呼叫的 <code>#ref()</code> 可能應當是 'Arrays.hashCode()' #loc
array.hashcode.problem.descriptor=或許應當使用 ''{0}'' 完成陣列雜湊程式碼計算
array.length.in.loop.condition.display.name=迴圈條件下的 Array.length
array.length.in.loop.condition.problem.descriptor=檢查迴圈條件下的陣列 <code>#ref</code> #loc
array.objects.equals.display.name=對陣列使用淺層方法或 'Objects' 方法
arrays.as.list.with.one.argument.problem.descriptor=僅使用一個實參呼叫 <code>#ref()</code> #loc
arrays.as.list.with.zero.arguments.problem.descriptor=呼叫 <code>#ref()</code> 以建立空列表 #loc
arrays.as.list.with.zero.or.one.argument.display.name='Arrays.asList()' 呼叫的實參過少
assert.can.be.if.quickfix=將 'assert' 取代為 'if' 語句
assert.keyword.is.considered.an.assertion='assert' 關鍵字被視為斷言
assert.message.not.string.display.name='assert' 訊息不是字串
assert.message.not.string.only.warn.boolean.option=僅當 'assert' 訊息為 'boolean' 或 'java.lang.Boolean' 時發出警告
assert.message.of.type.boolean.problem.descriptor=類型為 ''{0}'' 的 ''assert'' 訊息 #loc
assert.statement.display.name='assert' 語句
assert.with.side.effects.call.mutates.expression=呼叫 ''{0}()'' 會改變 ''{1}''
assert.with.side.effects.call.mutates.field=呼叫 ''{0}()'' 會改變欄位 ''{1}''
assert.with.side.effects.display.name=具有副作用的 'assert' 語句
assert.with.side.effects.problem.descriptor=<code>#ref</code> 具有副作用: {0} #loc
assert.without.message.problem.descriptor=沒有訊息的 <code>#ref()</code> #loc
assert.without.message.quick.fix.family.name=新增錯誤訊息
assertion.can.be.if.name=斷言可被取代為 'if' 語句
asserts.without.messages.display.name=斷言上缺少訊息
assignment.of.field.with.mutable.type.problem.descriptor=指派給參數 <code>#ref</code> 中的 {0} 欄位 ''{1}'' #loc
assignment.or.return.of.field.with.mutable.type.display.name=具有可變類型的欄位的指派或返回
assignment.replaceable.with.operator.assignment.display.name=指派可被取代為運算符指派
assignment.replaceable.with.operator.assignment.ignore.conditional.operators.option=忽略條件運算符
assignment.replaceable.with.operator.assignment.ignore.obscure.operators.option=忽略模糊的 ^ 和 % 運算符
assignment.replaceable.with.operator.assignment.problem.descriptor=<code>#ref</code> 可以簡化為 ''{0}'' #loc
assignment.to.catch.block.parameter.display.name=指派給 'catch' 塊參數
assignment.to.catch.block.parameter.problem.descriptor=指派給 'catch' 塊參數 <code>#ref</code> #loc
assignment.to.for.loop.parameter.check.foreach.option=檢查增強型 'for' 迴圈參數
assignment.to.for.loop.parameter.display.name=指派給 'for' 迴圈參數
assignment.to.for.loop.parameter.problem.descriptor=指派給 for 迴圈參數 <code>#ref</code> #loc
assignment.to.lambda.parameter.display.name=指派給 lambda 參數
assignment.to.lambda.parameter.problem.descriptor=指派給 lambda 參數 <code>#ref</code> #loc
assignment.to.method.parameter.display.name=指派給方法參數
assignment.to.method.parameter.ignore.transformation.option=<html>如果指派是原始參數的轉換，則忽略</html>
assignment.to.method.parameter.problem.descriptor=指派給方法參數 <code>#ref</code> #loc
assignment.to.null.display.name='null' 指派
assignment.to.null.option=忽略對欄位的指派
assignment.to.null.problem.descriptor='null' 已指派給變數 <code>#ref</code> #loc
assignment.to.static.field.from.instance.method.display.name=從實例上下文指派給 static 欄位
assignment.to.static.field.from.instance.method.problem.descriptor=從實例上下文指派給 static 欄位 <code>#ref</code> #loc
assignment.to.superclass.field.display.name=建構函式將值賦給在超類別中定義的欄位
assignment.to.superclass.field.problem.descriptor=指派給在超類別 ''{1}'' 中定義的欄位 ''{0}'' #loc
assignment.used.as.condition.display.name=用作條件的指派
assignment.used.as.condition.problem.descriptor=指派 <code>#ref</code> 作為條件使用 #loc
atomic.field.updater.issues.display.name='AtomicFieldUpdater' 宣告不一致
atomic.field.updater.not.static.final.display.name='AtomicFieldUpdater' 欄位未被宣告為 'static final'
atomic.field.updater.not.static.final.problem.descriptor={0} 欄位 <code>#ref</code> 未被宣告為 ''static final'' #loc
auto.boxing.display.name=自動裝箱
auto.boxing.ignore.added.to.collection.option=忽略新增到集合的表達式
auto.boxing.make.boxing.explicit.quickfix=使裝箱顯式
auto.boxing.problem.descriptor=自動裝箱 <code>#ref</code> #loc
auto.closeable.resource.display.name=在沒有 'try-with-resources' 的情況下使用 AutoCloseable
auto.closeable.resource.problem.descriptor=在沒有 ''try-with-resources'' 語句的情況下使用 ''{0}'' #loc
auto.closeable.resource.quickfix=忽略此方法返回的 'AutoCloseable'
auto.closeable.resource.returned.option=忽略從所有方法呼叫返回的 AutoCloseable 執行個體
auto.unboxing.display.name=自動拆箱
auto.unboxing.make.unboxing.explicit.quickfix=使拆箱顯式
auto.unboxing.problem.descriptor=自動拆箱 <code>#ref</code> #loc
await.not.in.loop.display.name=未在迴圈中呼叫的 'await()'
await.not.in.loop.problem.descriptor=<code>#ref()</code> 呼叫不在迴圈中 #loc
await.without.corresponding.signal.display.name=沒有相應 'signal()' 的 'await()'
await.without.corresponding.signal.problem.descriptor=在沒有相應 <code>signal()</code> 或 <code>signalAll()</code> 的情況下呼叫 <code>#ref()</code> #loc
bad.exception.caught.display.name=已捕獲禁止的 'Exception'
bad.exception.caught.problem.descriptor=已捕獲禁止異常 <code>#ref</code> #loc
bad.exception.declared.display.name=已宣告禁止異常
bad.exception.declared.problem.descriptor=已宣告禁止異常 <code>#ref</code> #loc
bad.exception.thrown.display.name=已拋出禁止異常
bad.exception.thrown.problem.descriptor=已拋出禁止異常 ''{0}'' #loc
bad.oddness.display.name=可疑的奇數檢查
bad.oddness.problem.descriptor=對負值進行奇數檢查將會失敗 #loc
big.decimal.equals.display.name=在 'BigDecimal' 上調用了 'equals()'
big.decimal.equals.problem.descriptor=BigDecimal 值之間的 <code>#ref()</code> 可能應當是 'compareTo()' #loc
big.decimal.method.without.rounding.called.display.name='BigDecimal' 方法呼叫沒有舍入模式實參
big.decimal.method.without.rounding.called.problem.descriptor=在沒有舍入模式實參的情況下呼叫了 'BigDecimal.#ref()'
bigdecimal.legacy.method.display.name=呼叫了 'BigDecimal' 遺留方法
bigdecimal.legacy.method.problem.descriptor=對 'BigDecimal.#ref()' 的呼叫可以使用 'RoundingMode' 枚舉常數
bigdecimal.legacy.method.quickfix=使用 'RoundingMode' 枚舉常數
boolean.constructor.display.name=布爾建構函式呼叫
boolean.constructor.problem.descriptor=布爾建構函式呼叫 #loc
boolean.constructor.simplify.quickfix=簡化
boolean.expression.can.be.simplified.problem.descriptor=<code>#ref</code> 可以簡化為 ''{0}'' #loc
boolean.expression.does.not.modify.problem.descriptor=<code>#ref</code> 未修改 ''{0}'' 的值 #loc
boolean.expression.may.be.conditional.display.name=布爾表達式可被取代為條件表達式
boolean.expression.remove.compound.assignment.quickfix=移除無意義的複合指派
boolean.field.always.inverted.problem.descriptor=布爾欄位 <code>#ref</code> 始終反轉 #loc
boolean.method.name.must.start.with.question.display.name=布爾方法名稱必須以疑問詞開頭
boolean.method.name.must.start.with.question.problem.descriptor=布爾方法名稱 <code>#ref</code> 未以疑問詞開頭 #loc
boolean.method.name.must.start.with.question.table.label=布爾方法名稱前綴:
boolean.parameter.constructor.problem.descriptor='public' 建構函式 <code>#ref()</code> 具有 'boolean' 參數 #loc
boolean.parameter.display.name='public' 方法具有 'boolean' 參數
boolean.parameter.only.report.multiple.option=僅報告具有多個布爾參數的方法
boolean.parameter.problem.descriptor='public' 方法 <code>#ref()</code> 具有 'boolean' 參數 #loc
boolean.parameters.constructor.problem.descriptor='public' 建構函式 <code>#ref()</code> 具有 'boolean' 參數 #loc
boolean.parameters.problem.descriptor='public' 方法 <code>#ref()</code> 具有 'boolean' 參數 #loc
boolean.variable.always.inverted.display.name=布爾變數始終反轉
boolean.variable.always.inverted.problem.descriptor=布爾變數 <code>#ref</code> 始終反轉 #loc
bounded.wildcard.contravariant.descriptor=可以泛化為 <code>? super #ref</code> #loc
bounded.wildcard.covariant.descriptor=可以泛化為 <code>? extends #ref</code> #loc
bounded.wildcard.display.name=可以使用有界萬用字元
bounded.wildcard.report.instance.option=報告執行個體方法
bounded.wildcard.report.invariant.option=報告固定類別
bounded.wildcard.report.private.option=報告 private 方法
boxing.boxed.value.display.name=裝箱已裝箱的值
boxing.boxed.value.problem.descriptor=裝箱已裝箱的 <code>#ref</code> #loc
boxing.boxed.value.quickfix=移除不必要的裝箱
break.statement.display.name='break' 語句
break.statement.with.label.display.name=帶標籤的 'break' 語句
break.statement.with.label.problem.descriptor=帶標籤的 <code>#ref</code> 語句 #loc
busy.wait.display.name=忙等待
busy.wait.problem.descriptor=在迴圈中呼叫 <code>Thread.#ref()</code>，可能處於忙等待 #loc
c.style.array.declaration.display.name=C 樣式陣列宣告
c.style.array.declaration.replace.quickfix=取代為 Java 樣式陣列宣告
cached.number.constructor.call.display.name=數字建構函式呼叫具有基元實參
cached.number.constructor.call.ignore.string.arguments.option=忽略具有字串實參的新數字表達式
cached.number.constructor.call.problem.descriptor=數字建構函式呼叫具有基元實參 #loc
cached.number.constructor.call.report.only.deprecated=僅在建構函式為 @Deprecated 時報告
call.to.date.tostring.display.name=呼叫 'Date.toString()'
call.to.date.tostring.problem.descriptor=國際化上下文中使用的 <code>Date.#ref()</code> #loc
call.to.native.method.while.locked.display.name=鎖定時呼叫 'native' 方法
call.to.native.method.while.locked.problem.descriptor=在同步上下文中呼叫本地方法 <code>#ref()</code> #loc
call.to.numeric.tostring.display.name=呼叫 'Number.toString()'
call.to.numeric.tostring.problem.descriptor=國際化上下文中呼叫的 <code>Number.#ref()</code> #loc
call.to.private.setter.in.class.option=僅在 setter 為 'private' 時報告
call.to.private.simple.getter.in.class.option=僅在 getter 為 'private' 時報告
call.to.simple.getter.in.class.display.name=從類別內呼叫簡單 getter
call.to.simple.getter.in.class.ignore.option=忽略其他物件上的 getter 呼叫
call.to.simple.getter.in.class.inline.quickfix=內聯呼叫 getter
call.to.simple.getter.in.class.problem.descriptor=從類別內呼叫簡單 getter <code>#ref()</code> #loc
call.to.simple.setter.in.class.display.name=從類別內呼叫簡單 setter
call.to.simple.setter.in.class.ignore.option=忽略其他物件上的 setter 呼叫
call.to.simple.setter.in.class.inline.quickfix=內聯呼叫 setter
call.to.simple.setter.in.class.problem.descriptor=從類別內呼叫簡單 setter <code>#ref()</code> #loc
call.to.string.concat.can.be.replaced.by.operator.display.name=對 'String.concat()' 的呼叫可被取代為 '+'
call.to.string.concat.can.be.replaced.by.operator.problem.descriptor=對 <code>#ref()</code> 的呼叫可被取代為 '+' 表達式 #loc
call.to.string.concat.can.be.replaced.by.operator.quickfix=用 '+' 取代 'concat()'
call.to.suspicious.string.method.display.name=呼叫可疑的 'String' 方法
call.to.suspicious.string.method.problem.descriptor=國際化上下文中呼叫的 <code>String.#ref()</code> #loc
cast.conflicts.with.instanceof.display.name=轉換與 'instanceof' 衝突
cast.conflicts.with.instanceof.problem.descriptor=轉換為 ''{0}'' 類型將與前面的 ''instanceof {1}'' 檢查衝突
cast.conflicts.with.instanceof.quickfix1=在轉換中將 ''{0}'' 取代為 ''{1}''
cast.conflicts.with.instanceof.quickfix2=在 instanceof 中將 ''{0}'' 取代為 ''{1}''
cast.that.loses.precision.display.name=損失精度的數字轉換
cast.that.loses.precision.negative.problem.descriptor=''{0}'' 到 <code>#ref</code> 的轉換可能導致負實參的精度損失 #loc
cast.that.loses.precision.option=忽略從 int 到 char 的轉換
cast.that.loses.precision.problem.descriptor=''{0}'' 到 <code>#ref</code> 的轉換可能導致精度損失 #loc
cast.to.concrete.class.problem.descriptor=轉換為具體類別 <code>{0}</code> #loc
casting.to.incompatible.interface.display.name=轉換為不相容的接口
casting.to.incompatible.interface.problem.descriptor=轉換為不相容的接口 <code>#ref</code> #loc
caught.exception.immediately.rethrown.display.name=捕獲的異常被立即重新拋出
caught.exception.immediately.rethrown.problem.descriptor=捕獲的異常 <code>#ref</code> 被立即重新拋出 #loc
chain.of.class.equality.checks.problem.descriptor=類別相等檢查鏈指示抽象失敗 #loc
chain.of.instanceof.checks.display.name='instanceof' 檢查鏈
chain.of.instanceof.checks.problem.descriptor='instanceof' 檢查鏈指示抽象失敗 #loc
chained.equality.comparisons.display.name=鏈式相等比較
chained.equality.comparisons.problem.descriptor=鏈式相等比較 <code>#ref</code> #loc
chained.method.call.display.name=鏈式方法呼叫
chained.method.call.ignore.option=忽略欄位初始設定式中的鏈式方法呼叫
chained.method.call.ignore.self.types.option=忽略對返回類型與其封閉類別相同的方法的呼叫
chained.method.call.problem.descriptor=鏈式方法呼叫 <code>#ref()</code> #loc
change.modifier.fix.family.name=更改修飾符
change.modifier.package.private.quickfix=設為 package-private
change.modifier.quickfix=設為 ''{0}''
channel.opened.not.closed.display.name=開啟了 'Channel'，但未安全關閉
char.used.in.arithmetic.content.cast.fix.family.name=插入轉換
char.used.in.arithmetic.context.cast.quickfix=插入到 {0} 的轉換
char.used.in.arithmetic.context.display.name=在算術上下文中使用 'char' 表達式
char.used.in.arithmetic.context.problem.descriptor=算術上下文中使用了 'char' #loc
char.used.in.arithmetic.context.quickfix=轉換為字串文字
character.comparison.display.name=字元比較
character.comparison.problem.descriptor=國際化上下文中的字元比較 <code>#ref</code> #loc
checkbox.ignore.null.on.wrong.side=忽略錯誤側的 'null'
checked.exception.class.display.name=已檢查的異常類別
checked.exception.class.problem.descriptor=已檢查的異常類別 <code>#ref</code> #loc
choose.autocloseable.type.to.ignore.title=選擇要忽略的 AutoCloseable 資源類型
choose.class=選擇類別
choose.class.hierarchy.to.ignore.title=選擇要忽略的類別層次結構
choose.class.type.to.ignore=選擇要忽略的類別
choose.exception.class=選擇異常類別
choose.exception.label=被禁止的異常:
choose.io.resource.type.to.ignore=選擇要忽略的 I/O 資源類型
choose.logger.class=選擇記錄器類別
class.escapes.defined.scope.display.module.option=Report non-exported classes exposed in module API (Java 9+)
class.escapes.defined.scope.display.name=Class is exposed outside of its visibility scope
class.escapes.defined.scope.display.package.option=Report private classes exposed in package-local API
class.escapes.defined.scope.display.public.option=Report non-accessible classes exposed in public API
class.escapes.defined.scope.java9.modules.descriptor=類別 <code>#ref</code> 未從模組 ''{0}'' 匯出
class.escapes.defined.scope.problem.descriptor=Class <code>#ref</code> is exposed outside its defined visibility scope #loc
class.extends.utility.class.display.name=類別擴展實用程序類別
class.extends.utility.class.ignore.utility.class.option=如果覆寫類別為實用程序類別，則忽略
class.extends.utility.class.problem.descriptor=類別 <code>#ref</code> 擴展實用程序類別 ''{0}'' #loc
class.independent.of.module.display.name=獨立於其模組的類別
class.independent.of.module.problem.descriptor=類別 <code>#ref</code> 在其模組中沒有相依或相依項 #loc
class.initializer.display.name=非 'static' 初始設定式
class.initializer.may.be.static.display.name=類別初始設定式可能為 'static'
class.initializer.may.be.static.problem.descriptor=類別初始設定式可能為 'static' #loc
class.initializer.move.code.to.constructor.quickfix=將初始設定式程式碼移至建構函式
class.initializer.option=僅在類別具有一個或多個建構函式時警告
class.initializer.problem.descriptor=非 'static' 初始設定式 #loc
class.loader.instantiation.display.name='ClassLoader' 實例化
class.loader.instantiation.problem.descriptor=實例化 <code>#ref</code> 可能造成安全問題 #loc
class.may.be.interface.convert.quickfix=將類別轉換為接口
class.may.be.interface.display.name='abstract' 類別可以是 'interface'
class.may.be.interface.java8.option=使用 Java 8 時報告包含非 abstract 方法的類別
class.may.be.interface.problem.descriptor=抽象類別 <code>#ref</code> 可能是接口 #loc
class.name=類別名
class.name.differs.from.file.name.display.name=類別名與檔名不同
class.name.differs.from.file.name.problem.descriptor=類別名 <code>#ref</code> 與檔名不同 #loc
class.name.prefixed.with.package.name.display.name=使用軟體套件名稱作為前綴的類別名
class.name.prefixed.with.package.name.problem.descriptor=類別名 <code>#ref</code> 以其軟體套件名稱開始 #loc
class.name.same.as.ancestor.name.display.name=類別名與上級名稱相同
class.name.same.as.ancestor.name.problem.descriptor=類別名 <code>#ref</code> 與其超類別的名稱之一相同 #loc
class.naming.convention.display.name=類別命名約定
class.naming.convention.element.description=類別
class.new.instance.display.name=對 'Class.newInstance()' 的呼叫不安全
class.new.instance.problem.descriptor=對 <code>#ref()</code> 的呼叫可能會拋出未宣告的已檢查的異常 #loc
class.only.used.in.one.module.display.name=僅在其他模組中使用的類別
class.only.used.in.one.module.problem.descriptor=類別 <code>#ref</code> 在其模組 ''{0}'' 中只有相依和/或相依性 #loc
class.only.used.in.one.package.display.name=僅在其他軟體套件中使用的類別
class.only.used.in.one.package.problem.descriptor=類別 <code>#ref</code> 在其軟體套件 ''{0}'' 中只有相依和/或相依項 #loc
class.references.subclass.display.name=類別參照其子類別之一
class.references.subclass.problem.descriptor=類別 ''{0}'' 參照子類別 <code>#ref</code> #loc
class.references.subclass.problem.descriptor.anonymous=匿名類別參照子類別 <code>#ref</code> #loc
class.too.deep.display.name=類別在繼承樹中太深
class.too.deep.inheritance.depth.limit.option=繼承深度限制:
class.too.deep.problem.descriptor=<code>#ref</code> 在繼承樹中太深 (繼承深度 = {0}) #loc
class.unconnected.to.package.display.name=獨立於其軟體套件的類別
class.unconnected.to.package.problem.descriptor=類別 <code>#ref</code> 在其軟體套件中沒有相依或相依項
class.with.only.private.constructors.display.name=僅包含 'private' 建構函式的類別應被宣告為 'final'
class.with.only.private.constructors.problem.descriptor=僅包含 'private' 建構函式的類別 <code>#ref</code> 應被宣告為 'final'
class.with.too.many.dependencies.display.name=相依過多的類別
class.with.too.many.dependencies.max.option=最大相依項數
class.with.too.many.dependencies.problem.descriptor=類別 ''{0}'' 的相依過多 ({1} > {2})
class.with.too.many.dependents.display.name=相依項過多的類別
class.with.too.many.dependents.max.option=最大相依項數
class.with.too.many.dependents.problem.descriptor=類別 ''{0}'' 的相依項過多 ({1} > {2})
class.with.too.many.transitive.dependencies.display.name=可傳遞相依項過多的類別
class.with.too.many.transitive.dependencies.max.option=最大可傳遞相依項數
class.with.too.many.transitive.dependencies.problem.descriptor=類別 ''{0}'' 的可傳遞相依項過多({1} > {2})
class.with.too.many.transitive.dependents.display.name=傳遞相依項過多的類別
class.with.too.many.transitive.dependents.max.option=最大傳遞相依項數
class.with.too.many.transitive.dependents.problem.descriptor=類別 ''{0}'' 的可傳遞相依項過多({1} > {2})
class.without.constructor.create.quickfix=生成空建構函式
class.without.constructor.display.name=不帶建構函式的類別
class.without.constructor.problem.descriptor=類別 <code>#ref</code> 沒有建構函式 #loc
class.without.logger.annotations.tab=註解
class.without.logger.loggers.tab=記錄器
class.without.no.arg.constructor.display.name=沒有無實參建構函式的類別
class.without.no.arg.constructor.ignore.option=如果類別具有預設建構函式，則忽略
class.without.no.arg.constructor.problem.descriptor=類別 <code>#ref</code> 缺少無實參建構函式 #loc
clone.doesnt.declare.clonenotsupportedexception.declare.quickfix=將 'CloneNotSupportedException' 新增到 throws 子句
clone.doesnt.declare.clonenotsupportedexception.display.name='clone()' 未宣告 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.problem.descriptor=<code>#ref()</code> #loc 未宣告 'CloneNotSupportedException'
clone.instantiates.new.array.problem.descriptor=''clone()'' 建立新的 {0} 陣列 #loc
clone.instantiates.objects.with.constructor.display.name='clone()' 用建構函式實例化物件
clone.instantiates.objects.with.constructor.problem.descriptor='clone()' 建立新的 <code>#ref</code> 執行個體 #loc
clone.method.in.non.cloneable.anonymous.class.problem.descriptor=<code>#ref()</code> 在派生自 ''{0}'' 的不可克隆匿名類別中定義 #loc
clone.method.in.non.cloneable.class.display.name=不可克隆類別中的 'clone()' 方法
clone.method.in.non.cloneable.class.problem.descriptor=<code>#ref()</code> 在不可克隆類別 ''{0}'' 中定義 #loc
clone.method.in.non.cloneable.interface.problem.descriptor=<code>#ref()</code> 在不可克隆接口 ''{0}'' 中定義 #loc
clone.returns.class.type.display.name='clone()' 應當具有等於其所包含類別的返回值類型
clone.returns.class.type.family.quickfix=將返回值類型更改為類別類型
clone.returns.class.type.problem.descriptor=''clone()'' 應當具有返回值類型 ''{0}'' #loc
clone.returns.class.type.quickfix=將返回值類型更改為 ''{0}''
cloneable.class.in.secure.context.display.name=安全上下文中的可克隆類別
cloneable.class.in.secure.context.problem.descriptor=類別 <code>#ref</code> 可能被克隆，影響安全性 #loc
cloneable.class.in.secure.context.quickfix=生成始終拋出異常的 'clone()' 方法
cloneable.class.without.clone.display.name=沒有 'clone()' 方法的可克隆類別
cloneable.class.without.clone.ignore.option=忽略由於繼承而可克隆的類別
cloneable.class.without.clone.ignore.when.clone.called.option=如果呼叫超類別的 clone() 方法需要 Cloneable，則忽略
cloneable.class.without.clone.problem.descriptor=<code>#ref</code> 為 'Cloneable'，但未定義 'clone()' 方法 #loc
cloneable.class.without.clone.quickfix=生成 'clone()' 方法
cloneable.class.without.clone.todo.message=TODO: 複製此處的可變狀態，這樣此克隆就不能更改初始克隆的內部項
collection.added.to.self.display.name=集合已新增到自身
collection.added.to.self.problem.descriptor=在以自身作為實參的集合 <code>#ref</code> 上調用了 ''{0}()'' #loc
collection.declared.by.class.display.name=按類別 (而不是接口) 宣告的集合
collection.declared.by.class.ignore.locals.option=忽略區域變數
collection.declared.by.class.ignore.private.members.option=忽略 'private' 欄位和方法
collection.declared.by.class.problem.descriptor=<code>#ref</code> 的宣告可能應當被削弱為 ''{0}'' #loc
collections.field.access.replaceable.by.method.call.display.name=對空集合欄位的參照可被取代為方法呼叫
collections.field.access.replaceable.by.method.call.fix.family.name=將 Collections.EMPTY_* 取代為呼叫
collections.field.access.replaceable.by.method.call.problem.descriptor=<code>#ref</code> 可被取代為 ''Collections.{0}'' #loc
collections.must.have.initial.capacity.display.name=沒有初始容量的集合
collections.must.have.initial.capacity.problem.descriptor=沒有初始容量的 <code>new #ref()</code> #loc
commented.out.code.delete.quickfix=刪除註釋
commented.out.code.uncomment.quickfix=撤消程式碼註釋
comments.as.content.option=註釋計為內容
comparable.implemented.but.equals.not.overridden.display.name=已實作 'Comparable'，但 'equals()' 未被覆寫
comparable.implemented.but.equals.not.overridden.fix.add.note.name=新增 'ordering inconsistent with equals' JavaDoc 記錄
comparable.implemented.but.equals.not.overridden.fix.generate.equals.name=生成 'equals()' 方法
comparable.implemented.but.equals.not.overridden.problem.descriptor=類別 <code>#ref</code> 實作 'java.lang.Comparable'，但未覆寫 'equals()' #loc
comparator.not.serializable.display.name='Comparator' 類別未被宣告為 'Serializable'
comparator.not.serializable.problem.descriptor=比較器類別 <code>#ref</code> 未被宣告為可序列化 #loc
comparison.of.short.and.char.display.name=比較 'short' 和 'char' 值
comparison.of.short.and.char.problem.descriptor=short 和 char 值的相等比較 <code>#ref</code> #loc
comparison.to.nan.display.name=與 'Double.NaN' 或 'Float.NaN' 比較
comparison.to.nan.problem.descriptor1=與 <code>#ref</code> 的比較始終為 false #loc
comparison.to.nan.problem.descriptor2=與 <code>#ref</code> 的比較始終為 true #loc
concrete.class.method.parameter.problem.descriptor=具體類別 <code>#ref</code> 的參數 ''{0}'' #loc
concrete.class.use.display.name=具體類別的使用
condition.signal.display.name=呼叫 'signal()' 而不是 'signalAll()'
condition.signal.problem.descriptor=<code>#ref</code> 可能應當取代為 'signalAll()' #loc
conditional.can.be.pushed.inside.expression.display.name=可以將條件推送到分支表達式內部
conditional.can.be.pushed.inside.expression.option=在條件將僅作為方法呼叫的實參時忽略
conditional.can.be.pushed.inside.expression.problem.descriptor=條件表達式可以推送到分支內 #loc
conditional.can.be.pushed.inside.expression.quickfix=在分支內推送條件表達式
conditional.expression.display.name=條件表達式
conditional.expression.expression.context.option=忽略無法使用 if 語句的位置
conditional.expression.option=對簡單指派和返回值忽略
conditional.expression.problem.descriptor=條件表達式 <code>#ref</code> #loc
conditional.expression.quickfix=取代為 'if' 語句
conditional.expression.with.identical.branches.collapse.quickfix=摺疊條件表達式
conditional.expression.with.identical.branches.display.name=具有相同分支的條件表達式
conditional.expression.with.identical.branches.problem.descriptor=具有相同分支的條件表達式 <code>#ref</code> #loc
confusing.else.option=當 'if' 語句之後沒有其他語句時報告
confusing.floating.point.literal.change.quickfix=更改為規範形式
confusing.floating.point.literal.display.name=引起混淆的浮點文字
confusing.floating.point.literal.option=在科學記數法中忽略浮點文字
confusing.floating.point.literal.problem.descriptor=引起混淆的浮點文字 <code>#ref</code> #loc
confusing.main.method.display.name=引起混淆的 'main()' 方法
confusing.main.method.problem.descriptor=方法 <code>#ref</code> 沒有簽名 'public static void main(String[])' #loc
confusing.octal.escape.sequence.display.name=引起混淆的八進制轉義序列
confusing.octal.escape.sequence.problem.descriptor=八進制轉義序列 <code>#ref</code> 後面緊跟數字 #loc
connection.opened.not.safely.closed.display.name=集合已開啟，但未安全關閉
consider.static.final.fields.constant.option=考慮 'static final' 欄位常數
constant.assert.condition.display.name='assert' 語句中的常數條件
constant.assert.condition.problem.descriptor=斷言條件 <code>#ref</code> 是常數 #loc
constant.conditional.expression.display.name=常數條件表達式
constant.conditional.expression.problem.descriptor=<code>#ref</code> 可以簡化為 ''{0}'' #loc
constant.conditional.expression.simplify.quickfix=簡化
constant.conditional.expression.simplify.quickfix.sideEffect=提取副作用並簡化
constant.declared.in.abstract.class.display.name=在 'abstract' 類別中宣告的常數
constant.declared.in.abstract.class.problem.descriptor=常數 <code>#ref</code> 在抽象類別中宣告 #loc
constant.declared.in.interface.display.name=在接口中宣告的常數
constant.declared.in.interface.problem.descriptor=常數 <code>#ref</code> 在接口中宣告 #loc
constant.for.zero.length.array.display.name=不必要的零長度陣列用法
constant.for.zero.length.array.problem.descriptor=零長度陣列可更改為常數 #loc
constant.for.zero.length.array.quickfix.family=取代為常數
constant.junit.assert.argument.display.name=常數斷言實參
constant.junit.assert.argument.problem.descriptor=實參 <code>#ref</code> 是常數 #loc
constant.math.call.display.name=對 'Math' 的常數呼叫
constant.math.call.problem.descriptor=對 <code>#ref()</code> 的常數呼叫可以簡化 #loc
constant.naming.convention.element.description=常數
constant.on.lhs.of.comparison.options.item.left=左
constant.on.lhs.of.comparison.options.item.right=右
constant.on.lhs.of.comparison.problem.descriptor=常數 <code>#ref</code> 位於比較的左側 #loc
constant.on.rhs.of.comparison.problem.descriptor=常數 <code>#ref</code> 位於比較的右側 #loc
constant.on.side.of.comparison.display.name=常數位於比較的錯誤一側
constant.value.variable.use.display.name=使用已知值為常數的變數
constant.value.variable.use.problem.descriptor=<code>#ref</code> 的值已知為常數 #loc
constant.with.mutable.field.naming.convention.element.description=具有可變類型的常數
constructor.visibility.option=忽略具有以下可見性的建構函式:
continue.or.break.from.finally.block.display.name='continue' 或 'break' 位於 'finally' 塊內
continue.or.break.from.finally.block.problem.descriptor=<code>#ref</code> 位於 'finally' 塊內 #loc
continue.statement.display.name='continue' 語句
continue.statement.with.label.display.name=帶標籤的 'continue' 語句
continue.statement.with.label.problem.descriptor=帶標籤的 <code>#ref</code> 語句 #loc
control.flow.statement.without.braces.add.quickfix=將大括號新增到語句
control.flow.statement.without.braces.display.name=不帶大括號的控制流語句
control.flow.statement.without.braces.message=將大括號新增到 ''{0}'' 語句
control.flow.statement.without.braces.problem.descriptor=不帶大括號的 <code>{0}</code> #loc
convert.double.unary.quickfix=取代為 ''{0}{1}''
convert.empty.anonymous.to.new.fix.family.name=移除 '{}'
convert.octal.literal.to.decimal.literal.quickfix=將八進制文字轉換為十進制文字
convert.octal.literals.to.decimal.literals.quickfix=將八進制文字轉換為十進制文字
convert.to.variable.arity.method.quickfix=轉換為 vararg 方法
copy.constructor.misses.field.display.name=複製缺少欄位的建構函式
copy.constructor.misses.field.problem.descriptor.1=複製未複製欄位 ''{0}'' 的建構函式
copy.constructor.misses.field.problem.descriptor.2=複製未複製欄位 ''{0}'' 和 ''{1}'' 的建構函式
copy.constructor.misses.field.problem.descriptor.3=複製未複製欄位 ''{0}''、''{1}'' 和 ''{2}'' 的建構函式
copy.constructor.misses.field.problem.descriptor.many=複製未複製 {0} 個欄位的建構函式
covariant.equals.display.name=協變 'equals()'
covariant.equals.problem.descriptor=<code>#ref()</code> 應當以 'Object' 作為其實參 #loc
create.default.branch.fix.family.name=插入 'default' 分支
create.missing.enum.switch.branches.fix.family.name=建立缺少的枚舉 switch 分支
create.missing.record.deconstructions.switch.branches.fix.family.name=建立缺失記錄解構 switch 分支
create.missing.sealed.class.switch.branches.fix.family.name=建立缺少的密封類別 switch 分支
create.missing.switch.branch=建立缺少的 switch 分支 ''{0}''
create.missing.switch.branches=建立缺少的分支: {0}
create.null.branch.fix.family.name=插入 'null' 分支
create.package.info.java.family.name=建立 'package-info.java'
cstyle.array.method.declaration.problem.descriptor=方法 <code>{0}()</code> 具有 C 樣式陣列返回類型宣告 #loc
cstyle.array.variable.declaration.problem.descriptor={0, choice, 1#欄位|2#參數|3#記錄元件|4#區域變數} <code>{1}</code> 具有 C 樣式陣列類型宣告 #loc
custom.classloader.display.name=宣告了自訂的 'ClassLoader'
custom.classloader.problem.descriptor=自訂 ClassLoader 類別 <code>#ref</code> #loc
custom.security.manager.display.name=自訂 'SecurityManager'
custom.security.manager.problem.descriptor=自訂 SecurityManager 類別 <code>#ref</code> #loc
cyclic.class.dependency.1.problem.descriptor=類別 ''{0}'' 迴圈依賴於類別 ''{1}''
cyclic.class.dependency.2.problem.descriptor=類別 ''{0}'' 迴圈依賴於類別 ''{1}'' 和 ''{2}''
cyclic.class.dependency.display.name=迴圈類別相依
cyclic.class.dependency.ignore.in.same.file=忽略位於同一檔案中的類別之間的迴圈
cyclic.class.dependency.problem.descriptor=類別 ''{0}'' 迴圈依賴於其他 {1} 個類別
cyclic.package.dependency.1.problem.descriptor=軟體套件 ''{0}'' 迴圈依賴於軟體套件 ''{1}''
cyclic.package.dependency.2.problem.descriptor=軟體套件 ''{0}'' 迴圈依賴於軟體套件 ''{1}'' 和 ''{2}''
cyclic.package.dependency.display.name=迴圈軟體套件相依關係
cyclic.package.dependency.problem.descriptor=軟體套件 ''{0}'' 迴圈依賴於其他 {1} 個軟體套件
cyclomatic.complexity.display.name=過度複雜的方法
cyclomatic.complexity.limit.option=迴圈復雜度限制:
cyclomatic.complexity.problem.descriptor=過度複雜的方法 <code>#ref()</code> (迴圈復雜度 = {0}) #loc
dangling.javadoc.convert.quickfix=取代為塊註釋
dangling.javadoc.delete.quickfix=移除懸空的註釋
dangling.javadoc.display.name=懸空的 Javadoc 註釋
dangling.javadoc.ignore.copyright.option=忽略 JavaDoc 格式的檔案頭註釋
dangling.javadoc.problem.descriptor=懸空的 Javadoc 註釋 #loc
debug.level.and.lower.option=偵錯級別和更低
declare.collection.as.interface.fix.family.name=削弱類型
declare.collection.as.interface.quickfix=削弱為 ''{0}''
default.not.last.case.in.switch.display.name='default' 不是 'switch' 中的最後一個 case
default.not.last.case.in.switch.problem.descriptor=''default'' 分支不是 ''switch'' {0} 中的最後一個 case #loc
default.tostring.call.display.name=呼叫預設 'toString()'
default.tostring.call.problem.descriptor=呼叫 <code>#ref</code> 上的預設 'toString()' #loc
delete.catch.section.fix.family.name=刪除 catch 語句
delete.catch.section.quickfix=刪除 'catch' 部分
delete.import.quickfix=刪除不必要的匯入
delete.unnecessary.statement.fix.family.name=移除冗餘語句
deserializable.class.in.secure.context.problem.descriptor=類別 <code>#ref</code> 可能被反序列化，影響安全性 #loc
design.for.extension.display.name=為擴展設計
design.for.extension.problem.descriptor=方法 <code>#ref()</code> 可能被覆寫，其功能會被忽略 #loc
diamond.can.be.replaced.with.explicit.type.arguments.name=diamond 可被取代為顯式類型實參
diamond.can.be.replaced.with.explicit.type.arguments.quickfix=將 '<>' 取代為顯式類型實參
disjoint.package.display.name=具有不相交相依關係圖的軟體套件
disjoint.package.problem.descriptor=軟體套件 {0} 可以分解為 {1} 個獨立軟體套件
divide.by.zero.display.name=除以零
divide.by.zero.problem.descriptor=除以零 #loc
dollar.sign.in.name.display.name=在關鍵字中使用 '$'
dollar.sign.in.name.problem.descriptor=關鍵字 <code>#ref</code> 包含 '$' #loc
double.brace.initialization.display.name=雙大括號初始化
double.brace.initialization.quickfix=取代為正則初始化
double.checked.locking.display.name=雙重檢查鎖定
double.checked.locking.fix.family.name=將欄位設為 volatile
double.checked.locking.problem.descriptor=雙重檢查鎖定 #loc
double.checked.locking.quickfix=將 ''{0}'' 設為 volatile
double.literal.may.be.float.literal.display.name=轉換為 'float' 可以是 'float' 文字
double.negation.display.name=雙重否定
double.negation.problem.descriptor=<code>#ref</code> 中的雙重否定 #loc
double.negation.quickfix=移除雙重否定
drivermanager.call.display.name=使用 'DriverManager' 獲取 JDBC 連線
drivermanager.call.problem.descriptor=呼叫 <code>DriverManager.#ref()</code> #loc
dumpstack.call.display.name=呼叫 'Thread.dumpStack()'
dumpstack.call.problem.descriptor=對 <code>Thread.#ref()</code> 的呼叫可能應當取代為更可靠的日誌 #loc
duplicate.condition.display.name=條件重複
duplicate.condition.ignore.method.calls.option=忽略有副作用的條件
duplicate.condition.problem.descriptor=重複條件 <code>#ref</code> #loc
dynamic.regex.replaceable.by.compiled.pattern.display.name=動態正則表達式可被取代為已編譯的 'Pattern'
dynamic.regex.replaceable.by.compiled.pattern.problem.descriptor=<code>#ref()</code> 可被取代為已編譯的 'java.util.regex.Pattern' 結構 #loc
dynamic.regex.replaceable.by.compiled.pattern.quickfix=取代為對已編譯 'Pattern' 常數的方法的呼叫
empty.anonymous.class.problem.descriptor=匿名類別為空 #loc
empty.class.display.name=冗餘空類別
empty.class.file.without.class.problem.descriptor=Java 檔案未宣告任何類別 #loc
empty.class.ignore.parameterization.option=如果類別是父類型的參數化，則將其忽略
empty.class.initializer.delete.quickfix=刪除空類別初始設定式
empty.class.initializer.display.name=空類別初始設定式
empty.class.initializer.problem.descriptor=空類別初始設定式 #loc
empty.class.problem.descriptor=類別 <code>#ref</code> 為空 #loc
empty.enum.problem.descriptor=枚舉 <code>#ref</code> 為空 #loc
empty.finally.block.display.name=空 'finally' 塊
empty.finally.block.problem.descriptor=空 <code>#ref</code> 塊 #loc
empty.synchronized.statement.display.name=空 'synchronized' 語句
empty.synchronized.statement.problem.descriptor=空 <code>#ref</code> 語句 #loc
empty.try.block.display.name=空 'try' 塊
empty.try.block.problem.descriptor=空 <code>#ref</code> 塊 #loc
encapsulate.variable.fix.family.name=封裝欄位
encapsulate.variable.quickfix=封裝欄位 ''{0}''
enum.singleton.problem.descriptor=枚舉 <code>#ref</code> 為單例 #loc
enum.switch.statement.which.misses.cases.display.name=缺少 case 的枚舉 'switch' 語句
enum.switch.statement.which.misses.cases.option=忽略具有預設分支的 switch 語句
enum.switch.statement.which.misses.cases.problem.descriptor=枚舉類型 ''{0}'' 上的 <code>#ref</code> 語句缺少 case: {1} #loc
enum.switch.statement.which.misses.cases.problem.descriptor.single=枚舉類型 ''{0}'' 上的 <code>#ref</code> 語句缺少 case ''{1}'' #loc
enumerated.class.display.name=枚舉類別
enumerated.class.naming.convention.element.description=枚舉類別
enumerated.class.problem.descriptor=枚舉類別 <code>#ref</code> #loc
enumerated.constant.naming.convention.element.description=枚舉常數
enumeration.can.be.iteration.display.name=枚舉可以是迭代
enumeration.can.be.iteration.problem.descriptor=<code>#ref()</code> 可被取代為 ''{0}'' 結構 #loc
enumeration.can.be.iteration.quickfix=取代為 'Iterator' 結構
equality.to.safe.equals.quickfix=用 null 安全 'equals()' 取代 '=='
equals.between.inconvertible.types.display.name='equals()' 位於不可轉換類型的物件之間
equals.between.inconvertible.types.mutual.subclass.option=如果未找到相互子類別，則發出警告
equals.between.inconvertible.types.no.mutual.subclass.problem.descriptor=未找到屬於 ''{0}'' 和 ''{1}'' 這兩個子類型的類別 #loc
equals.between.inconvertible.types.problem.descriptor=<code>#ref</code> 位於 ''{0}'' 和 ''{1}'' 不可轉換類型的物件之間 #loc
equals.called.on.array.display.name=在陣列上呼叫了 'equals()'
equals.called.on.array.problem.descriptor=陣列之間的 <code>#ref()</code> 可能應當是 'Arrays.equals()' #loc
equals.called.on.enum.constant.display.name=對枚舉值呼叫了 'equals()'
equals.called.on.enum.constant.problem.descriptor=對枚舉值呼叫了 <code>#ref()</code> #loc
equals.called.on.suspicious.object.display.name=在不對其進行覆寫的類別上呼叫了 'equals()'
equals.called.on.suspicious.object.fix.family.name=取代為代表值的比較
equals.called.on.suspicious.object.fix.name=取代為 ''{0}()'' 呼叫結果的比較
equals.called.on.suspicious.object.problem.descriptor=''{0}'' 物件上存在可疑的 ''equals()'' 呼叫
equals.doesnt.check.class.parameter.display.name=不檢查參數的類別的 'equals()' 方法
equals.doesnt.check.class.parameter.problem.descriptor=<code>#ref()</code> 應當檢查其參數的類別 #loc
equals.replaceable.by.objects.call.display.name='equals()' 表達式可被取代為 'Objects.equals()' 表達式
equals.replaceable.by.objects.call.problem.descriptor=<code>#ref</code> 可被取代為 'Objects.equals()' 表達式 #loc
equals.replaceable.by.objects.check.not.null.option=醒目提示與 'a != null \\\\&\\\\& a.equals(b)' 類似的表達式
equals.with.itself.display.name=在自身上呼叫了 'equals()'
equals.with.itself.option=僅對 final 庫類別類型或基元的測試斷言發出警告
equals.with.itself.problem.descriptor=在自身上呼叫了 <code>#ref()</code>
error.rethrown.display.name='Error' 未重新拋出
error.rethrown.problem.descriptor=錯誤 <code>#ref</code> 未重新拋出 #loc
exception.from.catch.which.doesnt.wrap.display.name='throw' 位於忽略已捕獲異常的 'catch' 塊內
exception.from.catch.which.doesnt.wrap.problem.descriptor='catch' 塊內的 <code>#ref</code> 忽略捕獲的異常 #loc
exception.from.catch.which.doesntwrap.ignore.cant.wrap.option=如果拋出的異常無法包裝異常，則忽略
exception.from.catch.which.doesntwrap.ignore.option=如果使用異常方法呼叫的結果，則忽略
exception.name.doesnt.end.with.exception.display.name=異常類別名不以 'Exception' 結尾
exception.name.doesnt.end.with.exception.problem.descriptor=異常類別名 <code>#ref</code> 未以 'Exception' 結尾 #loc
exception.package.display.name=異常軟體套件
exception.package.problem.descriptor=軟體套件 ''{0}'' 僅包含異常類別
expected.exception.never.thrown.display.name=從未在測試方法正文中拋出預期異常
expected.exception.never.thrown.problem.descriptor=從未在 ''{0}()'' 的正文中拋出預期 <code>#ref</code> #loc
explicit.array.to.string.problem.descriptor=呼叫陣列上的 '#ref()' #loc
expression.can.be.replaced.no.quotes.problem.descriptor={0} 可被取代為 {1}
expression.can.be.replaced.problem.descriptor=<code>#ref</code> 可被取代為 ''{0}'' #loc
expression.may.be.factorized.display.name=表達式可以因式分解
extend.exception.fix.family.name=使類別擴展 'Exception'
extended.for.statement.display.name=增強的 'for' 語句
extended.for.statement.problem.descriptor=擴展 <code>#ref</code> 語句 #loc
extended.for.statement.replace.quickfix=取代為舊式 'for' 語句
extends.annotation.display.name=類別擴展註解接口
extends.annotation.interface.problem.descriptor=接口 ''{0}'' 擴展註解接口 <code>#ref</code> #loc
extends.annotation.problem.descriptor=類別 ''{0}'' 實作註解接口 <code>#ref</code> #loc
extends.concrete.collection.display.name=類別顯式擴展 'Collection' 類別
extends.concrete.collection.problem.descriptor=類別 <code>#ref</code> 顯式擴展 ''{0}'' #loc
extends.object.display.name=類別顯式擴展 'Object'
extends.object.problem.descriptor=類別 <code>#ref</code> 顯式擴展 'java.lang.Object' #loc
extends.object.remove.quickfix=移除冗餘的 'extends Object'
extends.thread.display.name=類別直接擴展 'Thread'
extends.thread.problem.descriptor=類別 <code>#ref</code> 直接擴展 'java.lang.Thread' #loc
extends.throwable.display.name=類別直接擴展 'Throwable'
extends.throwable.problem.descriptor=類別 <code>#ref</code> 直接擴展 'java.lang.Throwable' #loc
externalizable.with.serialization.methods.display.name=具有 'readObject()' 或 'writeObject()' 的可外部化類別
externalizable.with.serialization.methods.problem.descriptor.both=可外部化{0, choice, 1#類別|2#接口|3#派生的匿名類別|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'readObject()' 和 'writeObject()' #loc
externalizable.with.serialization.methods.problem.descriptor.read=可外部化{0, choice, 1#類別|2#接口|3#派生的匿名類別|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'readObject()' #loc
externalizable.with.serialization.methods.problem.descriptor.write=可外部化{0, choice, 1#類別|2#接口|3#派生的匿名類別|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'writeObject()' #loc
externalizable.without.public.no.arg.constructor.display.name=沒有 'public' 無實參建構函式的 'Externalizable' 類別
externalizable.without.public.no.arg.constructor.problem.descriptor=可外部化類別 <code>#ref</code> 沒有 'public' 無實參建構函式 #loc
extract.method.quickfix=提取方法
extract.parameter.as.local.variable.quickfix=提取參數作為區域變數
fallthru.in.switch.statement.display.name='switch' 語句中的直落
fallthru.in.switch.statement.problem.descriptor='switch' 語句存在直落 #loc
fallthru.in.switch.statement.quickfix=新增 ''{0}''
feature.envy.display.name=特性依戀
feature.envy.problem.descriptor=類別 ''{0}'' 在方法 <code>#ref()</code> 中被重複存取 #loc
field.accessed.synchronized.and.unsynchronized.display.name=同時在 'synchronized' 和未同步上下文中存取欄位
field.accessed.synchronized.and.unsynchronized.option=簡單的 getter 和 setter 也被視為欄位存取
field.accessed.synchronized.and.unsynchronized.problem.descriptor=同時在同步和未同步上下文中存取欄位 <code>#ref</code> #loc
field.count.inspection.include.constant.fields.in.count.checkbox=在計數中包含常數欄位
field.count.inspection.include.enum.constants.in.count=在計數中包含枚舉常數
field.count.inspection.static.final.fields.count.as.constant.checkbox=將 'static final' 欄位計為常數
field.has.setter.but.no.getter.display.name=欄位具有 setter 但沒有 getter
field.has.setter.but.no.getter.problem.descriptor=欄位 <code>#ref</code> 有 setter 但沒有 getter #loc
field.has.static.modifier.problem.descriptor=欄位 ''{0}'' 具有 ''static'' 修飾符
field.incorrect.type.problem.descriptor=欄位 ''{0}'' 沒有類型 ''{1}''
field.may.be.final.display.name=欄位可能為 'final'
field.may.be.final.problem.descriptor=欄位 <code>#ref</code> 可能為 'final' #loc
field.may.be.static.display.name=欄位可以為 'static'
field.may.be.static.problem.descriptor=欄位 <code>#ref</code> 可能為 'static' #loc
field.missing.volatile.modifier.problem.descriptor=欄位 ''{0}'' 沒有 ''volatile'' 修飾符
field.name.hides.in.superclass.display.name=子類別欄位隱藏超類別欄位
field.name.hides.in.superclass.ignore.option=忽略不可存取欄位
field.name.hides.in.superclass.ignore.static.field.option=忽略隱藏 static 欄位的 static 欄位
field.name.hides.in.superclass.problem.descriptor=欄位 <code>#ref</code> 隱藏超類別中的欄位 #loc
field.naming.convention.display.name=欄位命名約定
field.not.found.in.class.problem.descriptor=類別 ''{1}'' 中未找到命名為 ''{0}'' 的欄位
final.class.display.name=類別禁止繼承
final.class.problem.descriptor=類別 ''{0}'' 宣告了 <code>#ref</code> #loc
final.method.display.name=不能覆寫方法
final.method.in.final.class.display.name='final' 類別位於 'final' 方法中
final.method.in.final.class.problem.descriptor=方法在 'final' 類別中被宣告為 <code>#ref</code> #loc
final.method.problem.descriptor=方法被宣告為 <code>#ref</code> #loc
final.private.method.display.name='private' 方法被宣告為 'final'
final.private.method.problem.descriptor='private' 方法被宣告為 <code>#ref</code> #loc
final.static.method.display.name='static' 方法被宣告為 'final'
final.static.method.problem.descriptor='static' 方法被宣告為 <code>#ref</code> #loc
finalize.called.explicitly.display.name='finalize()' 被顯式呼叫
finalize.called.explicitly.problem.descriptor=<code>#ref()</code> 被顯式呼叫 #loc
finalize.declaration.display.name='finalize()' 不應被覆寫
finalize.declaration.problem.descriptor='finalize()' 不應被覆寫 #loc
finalize.not.declared.protected.display.name='finalize()' 應為 protected，不應為 public
finalize.not.declared.protected.problem.descriptor='finalize()' 應具有 protected 存取權限，不應具有 public 存取權限 #loc
finally.block.cannot.complete.normally.display.name=不能正常完成的 'finally' 塊
finally.block.cannot.complete.normally.problem.descriptor=<code>#ref</code> 塊無法正常完成 #loc
fix.add.argument.family.name=新增實參
fix.add.argument.name=新增 ''{0}'' 實參
fix.data.provider.create.method.fix.name=建立資料提供程序方法 '@Parameters public static Iterable<Object> parameters()'
fix.data.provider.multiple.methods.problem=類別 <code>#ref</code> 中存在多個 @Parameters 資料提供程序方法
fix.data.provider.signature.family.name=修正資料提供程序方法簽名
fix.data.provider.signature.fix.name=將方法簽名更改為 ''{0}''
fix.data.provider.signature.incorrect.problem=資料提供程序方法 <code>#ref()</code> 的簽名不正確
fix.data.provider.signature.missing.method.problem=參數化測試類別 <code>#ref</code> 缺少用 '@Parameters' 註解的資料提供程序方法
fix.eliminate.folded.if.present.description=可以消除折疊的 'ifPresent()' 呼叫
fix.eliminate.folded.if.present.name=移除折疊的 'ifPresent()' 呼叫
fix.replace.map.with.flat.map.description='map()' 可被取代為 'flatMap()'
flip.comparison.quickfix=翻轉比較
floating.point.equality.display.name=浮點相等比較
floating.point.equality.problem.descriptor=<code>#ref</code>: 比較浮點值以實作完全相等 #loc
for.can.be.foreach.display.name='for' 迴圈可被取代為增強的 for 迴圈
for.can.be.foreach.fix.no.indexed=不報告索引的 'java.util.List' 迴圈
for.can.be.foreach.option=報告索引的 'java.util.List' 迴圈
for.can.be.foreach.option2=不報告無類型集合上的迭代
for.can.be.foreach.problem.descriptor=<code>#ref</code> 迴圈可被取代為增強的 'for' #loc
for.loop.replaceable.by.while.display.name='for' 迴圈可被取代為 'while' 迴圈
for.loop.replaceable.by.while.ignore.option=忽略無條件迴圈的 'infinite'
for.loop.replaceable.by.while.problem.descriptor=<code>#ref</code> 迴圈語句可被取代為 'while' 迴圈 #loc
for.loop.with.missing.component.collection.loop.option=忽略集合迭代
for.loop.with.missing.component.display.name=缺少元件的 'for' 迴圈
for.loop.with.missing.component.problem.descriptor1=<code>#ref</code> 語句缺少初始設定式 #loc
for.loop.with.missing.component.problem.descriptor2=<code>#ref</code> 語句缺少條件 #loc
for.loop.with.missing.component.problem.descriptor3=<code>#ref</code> 語句缺少更新 #loc
for.loop.with.missing.component.problem.descriptor4=<code>#ref</code> 語句缺少初始設定式和條件 #loc
for.loop.with.missing.component.problem.descriptor5=<code>#ref</code> 語句缺少初始設定式和條件 #loc
for.loop.with.missing.component.problem.descriptor6=<code>#ref</code> 語句缺少條件和更新 #loc
for.loop.with.missing.component.problem.descriptor7=<code>#ref</code> 語句缺少初始設定式、條件和更新 #loc
foreach.replace.quickfix=取代為增強 'for'
format.string.error.duplicate.flag=''{1}'' 中存在重複的標誌 ''{0}''
format.string.error.flags.not.allowed=''{1}'' 中不允許使用{2, choice, 1#標誌|1<標誌} ''{0}''
format.string.error.illegal.flag.combination=''{2}'' 中的標誌組合 ''{0}'' 和 ''{1}'' 非法
format.string.error.illegal.position.specifier=''{1}'' 存在非法的位置說明符 ''{0}''
format.string.error.invalid.precision=''{0}'' 中指定的精度無效
format.string.error.left.justify.no.width=使用了左對齊標誌 ''-''，但 ''{0}'' 中未指定寬度
format.string.error.precision.not.allowed=''{1}'' 中不允許該精度 (''{0}'')
format.string.error.previous.element.not.found=使用了以前的標誌 '<'，但沒有找到 ''{0}'' 以前的格式說明符
format.string.error.unexpected.flag=''{1}'' 中出現意外字元 ''{0}''
format.string.error.unknown.conversion=''{0}'' 中存在未知的轉換
format.string.error.unnecessary.position.specifier=''{1}'' 存在不必要的實參位置說明符 ''{0}''
format.string.error.width.not.allowed=''{1}'' 中不允許該寬度 (''{0}'')
format.string.error.zero.padding.no.width=使用了零填充標誌 ''0''，但 ''{0}'' 中未指定寬度
gc.call.display.name=呼叫 'System.gc()' 或 'Runtime.gc()'
gc.call.problem.descriptor=<code>#ref</code> 不應在生產程式碼中呼叫 #loc
generate.to.string.quick.fix.family.name=生成
generate.to.string.quick.fix.text=生成 toString()
groups.of.modules.loaded.together.description=每行指定一個以逗號分隔的模組名稱列表，已知這些模組名稱由同一個類別載入器載入。\\n不應報告對此類別模組之間的 package-private 成員的存取。
groups.of.modules.loaded.together.label=一起載入的模組組:
hardcoded.file.separator.display.name=硬編碼檔案分隔符
hardcoded.file.separator.ignore.methods.option=忽略以下方法的實參:
hardcoded.file.separator.include.option=在已識別的 MIME 媒體類型中包括 'example/*'
hardcoded.file.separator.problem.descriptor=硬編碼檔案分隔符 <code>#ref</code> #loc
hardcoded.line.separator.display.name=硬編碼行分隔符
hardcoded.line.separator.problem.descriptor=硬編碼行分隔符 <code>#ref</code> #loc
hibernate.resource.opened.not.closed.display.name=Hibernate 資源已開啟，但未安全關閉
html.tag.can.be.javadoc.tag.display.name='<code>...</code>' 可被取代為 '{@code ...}'
html.tag.can.be.javadoc.tag.problem.descriptor=<code>#ref...\\\\&lt;/code\\\\&gt;</code> 可被取代為 '{@code ...}' #loc
i.o.resource.opened.not.closed.display.name=I/O 資源已開啟，但未安全關閉
if.can.be.assertion.name=語句可被取代為 'assert' 或 'Objects.requireNonNull'
if.can.be.assertion.replace.with.assertion.quickfix=將語句取代為 'assert' 語句
if.can.be.assertion.replace.with.objects.requirenonnull.quickfix=將語句取代為 'Objects.requireNonNull()'
if.can.be.switch.display.name='if' 可被取代為 'switch'
if.can.be.switch.enum.option=對枚舉啟用 switch 建議
if.can.be.switch.int.option=對數字啟用 switch 建議
if.can.be.switch.minimum.branch.option='if' 條件分支的最小數量:
if.can.be.switch.null.safe.option=僅對 null-safe 表達式啟用建議
if.can.be.switch.problem.descriptor=<code>#ref</code> 語句可被取代為 'switch' 語句 #loc
if.may.be.conditional.problem.descriptor=<code>#ref</code> 可被取代為條件表達式 #loc
if.may.be.conditional.quickfix=取代為條件表達式
if.may.be.factorized.problem.descriptor=<code>#ref</code> 可以因式分解 #loc
if.may.be.factorized.quickfix=取代為因式分解表達式
if.statement.with.identical.branches.display.name='if' 語句的分支相同
if.statement.with.too.many.branches.display.name='if' 語句的分支過多
if.statement.with.too.many.branches.max.option=最大分支數:
if.statement.with.too.many.branches.problem.descriptor=<code>#ref</code> 的分支過多 ({0}) #loc
ignore.accesses.from.equals.method=忽略來自 'equals()' 方法的存取
ignore.accesses.from.the.same.class=忽略來自同一類的存取
ignore.anonymous.inner.classes=忽略匿名內部類別
ignore.boolean.methods.in.an.interface.option=忽略 @&interface 中的布爾方法
ignore.branches.of.switch.statements=忽略 'switch' 語句的分支
ignore.calls.to.property.getters=忽略對屬性 getter 的呼叫
ignore.calls.to.static.methods=忽略對 static 方法的呼叫
ignore.class.fix.family.name=對這些類型忽略
ignore.classes.annotated.by=由以下物件註解時忽略類別:
ignore.classes.in.hierarchy.column.name=忽略以下物件的子類別:
ignore.cloneable.option=忽略 'java.lang.Cloneable'
ignore.constructor.method.references=忽略產生 AutoCloseable 的建構函式方法參照
ignore.enhanced.for.loop.statements=忽略增強型 for 迴圈
ignore.equals.hashcode.and.tostring=忽略 'equals()'、'hashCode()' 和 'toString()' 方法
ignore.exceptions.declared.on.library.override.option=忽略在覆寫庫方法的方法上宣告的異常(&L)
ignore.for.equals.methods.option=對 'equals()' 方法忽略(&E)
ignore.getters.returning.resource=忽略返回源的 getter
ignore.guard.clauses.option=忽略臨界子句(&G)
ignore.if.annotated.by=由以下物件註解時忽略:
ignore.in.module.statements.option=在 Java 9 模組語句中忽略
ignore.instanceof.on.library.classes=忽略庫類別上的 instanceof
ignore.methods.in.anonymous.classes=忽略匿名類別中的方法
ignore.methods.overriding.super.method=忽略覆寫/實作 super 方法的方法(O&)
ignore.methods.with.boolean.return.type.option=忽略具有 'java.lang.Boolean' 返回值類型的方法(&B)
ignore.overflowing.byte.casts.option=忽略從 int 128-255 到位元組的轉換
ignore.parentheses.around.single.no.formal.type.lambda.parameter=忽略單個非正式類型 lambda 參數周圍的括號
ignore.private.methods.option=忽略 private 方法中的指派和返回值
ignore.serializable.option=忽略 'java.io.Serializable'
ignore.single.field.static.imports.option=忽略單欄位靜態匯入(&F)
ignore.single.method.static.imports.option=忽略單方法靜態匯入(&M)
ignore.trivial.finalizers.option=對普通 'finalize()' 實作忽略
ignored.autocloseable.types.label=已忽略的 AutoCloseable 資源類型:
ignored.class.hierarchies.border.title=忽略以下物件的子類別:
ignored.class.label=已忽略類別(包括子類別):
ignored.class.names=忽略類別(包括子類別)
ignored.io.resource.types=已忽略的 I/O 資源類型
ignored.io.resource.types.label=已忽略的 I/O 資源類型:
implicit.array.to.string.display.name=呼叫陣列上的 'toString()'
implicit.array.to.string.fix.family.name=將 Array.toString() 設為隱式
implicit.array.to.string.method.call.problem.descriptor=隱式呼叫呼叫 <code>#ref</code> 返回的陣列上的 'toString()' #loc
implicit.array.to.string.problem.descriptor=隱式呼叫陣列 <code>#ref</code> 上的 'toString()' #loc
implicit.array.to.string.quickfix=使用 ''{0}'' 表達式包裝
implicit.call.to.super.display.name=隱式呼叫 'super()'
implicit.call.to.super.ignore.option=對 'java.lang.Object' 的直接子類別忽略
implicit.call.to.super.make.explicit.quickfix=使對 'super()' 的呼叫顯式
implicit.call.to.super.problem.descriptor=隱式呼叫 'super()' #loc
implicit.default.charset.usage.constructor.problem.descriptor=<code>new #ref()</code> 呼叫使用平台的預設字符集
implicit.default.charset.usage.display.name=隱式平台預設字符集
implicit.default.charset.usage.fix.family.name=指定 UTF-8 字符集
implicit.default.charset.usage.problem.descriptor=對 <code>#ref()</code> 的呼叫使用平台的預設字符集
implicit.numeric.conversion.assignment.problem.descriptor=將結果值從 ''{0}'' 隱式數字轉換為 ''{1}'' #loc
implicit.numeric.conversion.display.name=隱式數字轉換
implicit.numeric.conversion.ignore.char.conversion.option=忽略 'char' 之間的轉換
implicit.numeric.conversion.ignore.constant.conversion.option=忽略從常數和文字的轉換
implicit.numeric.conversion.ignore.widening.conversion.option=忽略擴大轉換
implicit.numeric.conversion.make.explicit.quickfix=使轉換顯式
implicit.numeric.conversion.problem.descriptor=將 <code>#ref</code> 從 ''{0}'' 隱式數字轉換為 ''{1}'' #loc
import.display.name='*' 匯入
import.from.same.package.display.name=相同軟體套件中的不必要 import
import.from.same.package.problem.descriptor=相同軟體套件 <code>#ref</code> 中有不必要的 import #loc
import.problem.descriptor=軟體套件匯入 <code>#ref</code> #loc
include.java.system.classes.option=包括與 Java 系統類別的耦合
include.library.classes.option=包括與庫類別的耦合
incompatible.mask.operation.display.name=不相容的位元遮罩運算
incompatible.mask.operation.problem.descriptor.always.false=<code>#ref</code> 始終為 false #loc
incompatible.mask.operation.problem.descriptor.always.true=<code>#ref</code> 始終為 true #loc
incorrect.date.format.fix.family.name=修復不正確的日期格式
increment.decrement.display.name=使用 '++' 或 '--' 的結果
increment.decrement.used.as.expression.fix.family.name=提取到分離語句中
increment.decrement.used.as.expression.quickfix=提取 ''{0}'' 以分離語句
inequality.to.safe.not.equals.quickfix=用 null 安全 '!equals()' 取代 '!='
infinite.loop.statement.display.name=無限迴圈語句
infinite.loop.statement.problem.descriptor=<code>#ref</code> 語句不能在未拋出異常的情況下完成 #loc
infinite.recursion.display.name=無限遞迴
infinite.recursion.problem.descriptor=方法 <code>#ref()</code> 無限遞迴，只能以拋出異常結束 #loc
info.level.and.lower.option=資訊級別和更低
inline.call.quickfix=內聯呼叫
inline.variable.quickfix=內聯變數
inner.class.field.hides.outer.display.name=內部類別欄位隱藏外部類別欄位
inner.class.field.hides.outer.ignore.option=忽略從內部類別不可見的外部欄位
inner.class.field.hides.outer.problem.descriptor=內部類別欄位 <code>#ref</code> 隱藏外部類別欄位 #loc
inner.class.may.be.static.display.name=內部類別可能為 'static'
inner.class.may.be.static.problem.descriptor=內部類別 <code>#ref</code> 可能為 'static' #loc
inner.class.on.interface.display.name=接口的內部類別
inner.class.on.interface.ignore.option=忽略接口的內部接口
inner.class.on.interface.problem.descriptor=接口 ''{0}'' 具有內部類別 <code>#ref</code> #loc
inner.class.referenced.via.subclass.display.name=通過子類別參照的內部類別
inner.class.referenced.via.subclass.problem.descriptor=內部類別 <code>#ref</code> 在類別 ''{0}'' 中宣告，但通過子類別 ''{1}'' 參照 #loc
inner.class.referenced.via.subclass.quickfix=使內部類別存取合理化
inner.class.too.deeply.nested.display.name=內部類別嵌套太深
inner.class.too.deeply.nested.nesting.limit.option=嵌套限制:
inner.class.too.deeply.nested.problem.descriptor=<code>#ref</code> 嵌套太深 (嵌套級別 = {0}) #loc
inspection.autocloseable.resource.ignored.methods.title=忽略從這些方法返回的 AutoCloseable 執行個體:
inspection.byte.array.output.stream.to.string.message=ByteArrayOutputStream 轉換低效
inspection.case.mismatch.display.name='String' 動作中不符合的大小寫
inspection.case.mismatch.message.arg.is.lower=方法 ''{0}()'' 始終返回 {1}: 實參包含小寫符號，而限定符僅為大寫
inspection.case.mismatch.message.arg.is.upper=方法 ''{0}()'' 始終返回 {1}: 實參包含大寫符號，而限定符僅為小寫
inspection.case.mismatch.message.label.is.lower=無法存取 switch 分支: 標籤包含小寫符號，而選擇器僅支援大寫
inspection.case.mismatch.message.label.is.upper=無法存取 switch 分支: 標籤包含大寫符號，而選擇器僅支援小寫
inspection.cast.can.be.replaced.with.variable.display.name=轉換可被取代為變數
inspection.cast.can.be.replaced.with.variable.family.name=用變數取代轉換
inspection.cast.can.be.replaced.with.variable.message=可以使用變數 ''{0}'' 替代 ''{1}''
inspection.catch.ignores.exception.display.name=catch 塊可能會忽略異常
inspection.catch.ignores.exception.empty.message=空 <code>#ref</code> 塊 #loc
inspection.catch.ignores.exception.option.comments=當 'catch' 塊包含註釋時不發出警告
inspection.catch.ignores.exception.option.ignored.used=當名稱為 'ignore(d)' 的異常實際上未被忽略時不發出警告
inspection.catch.ignores.exception.option.nonempty=當 'catch' 塊不為空時不發出警告
inspection.catch.ignores.exception.unused.message=未使用的 'catch' 參數 <code>#ref</code> #loc
inspection.catch.ignores.exception.used.message=已使用命名為 <code>#ref</code> 的 'catch' 參數 #loc
inspection.catch.ignores.exception.vm.ignored.message=<code>#ref</code> 塊中可能會忽略 ''{0}'' 之類的意外虛擬機異常 #loc
inspection.collection.must.have.initial.capacity.initializers.option=不報告欄位初始設定式
inspection.commented.out.code.disable.short.fragments=不報告此類別短片段
inspection.commented.out.code.display.name=註釋掉的程式碼
inspection.commented.out.code.min.lines.options=最少程式碼行數
inspection.commented.out.code.problem.descriptor=註釋掉的程式碼 ({0} {0, choice, 1#行|1<行})
inspection.common.if.parts.description.complete.duplicate=可以摺疊 ''if'' 語句{0}
inspection.common.if.parts.description.complete.duplicate.side.effect=可以通過提取副作用摺疊 'if' 語句
inspection.common.if.parts.description.variables.only=可以從 ''if'' 中提取變數{0}
inspection.common.if.parts.description.whole.branch=可以提取通用部分，同時移除分支{0}
inspection.common.if.parts.description.with.variables.extract=可以從 ''if'' 中提取包含變數的通用部分{0}
inspection.common.if.parts.description.without.variables.extract=可以從 ''if'' 中提取通用部分{0}
inspection.common.if.parts.message.complete.duplicate=摺疊 ''if'' 語句{0}
inspection.common.if.parts.message.complete.duplicate.side.effect=摺疊 'if' 語句並提取副作用
inspection.common.if.parts.message.variables.only=從 ''if'' 中提取變數{0}
inspection.common.if.parts.message.whole.branch=提取通用部分，同時移除分支{0}
inspection.common.if.parts.message.with.variables.extract=從 ''if'' 中提取包含變數的通用部分{0}
inspection.common.if.parts.message.without.variables.extract=從 ''if'' 中提取通用部分{0}
inspection.common.subexpression.in.switch.display.name=可以從 'switch' 中提取通用子表達式
inspection.common.subexpression.in.switch.fix.family.name=向下推送 'switch' 表達式
inspection.comparator.combinators.description=可被取代為 'Comparator' 鏈
inspection.comparator.combinators.description2=可被取代為 ''{0}''
inspection.comparator.combinators.fix.chain=取代為 'Comparator' 鏈
inspection.condition.covered.by.further.condition.descr=條件 ''{0}'' 由後面的{1, choice, 1#條件 ''''{2}''''|2#條件}覆蓋
inspection.constant.expression.display.name=可以對常數表達式求值
inspection.constant.expression.fix.family.name=計算常量值
inspection.constant.expression.fix.name=計算 ''{0}'' 的常量值
inspection.constant.expression.fix.name.short=取代為常量值
inspection.constant.expression.fix.name.with.value=將 ''{0}'' 取代為常量值 ''{1}''
inspection.constant.expression.message=常數表達式的求值結果可以為 ''{0}''
inspection.constant.expression.skip.non.literal=Don't report when the expression contains references to defined constants
inspection.deconstruction.can.be.used.display.name=可以使用記錄模式
inspection.deconstruction.can.be.used.fix.family.name=取代為記錄模式
inspection.deconstruction.can.be.used.message=可被取代為記錄模式
inspection.empty.catch.block.generate.body=從模板生成 'catch' 正文
inspection.empty.class.ignore.subclasses.option=忽略 {0} 的子類別
inspection.enhanced.for.with.record.pattern.can.be.used.components.option=要解構的記錄元件的最大數量:
inspection.enhanced.for.with.record.pattern.can.be.used.display.name=可以使用帶有記錄模式的增強 'for'
inspection.enhanced.for.with.record.pattern.can.be.used.fix.family.name=取代為記錄模式
inspection.enhanced.for.with.record.pattern.can.be.used.level.option=嵌套深度限制:
inspection.enhanced.for.with.record.pattern.can.be.used.maximum.depth.disabled=不建議帶有 {0} 種和更多嵌套模式的模式
inspection.enhanced.for.with.record.pattern.can.be.used.maximum.number.disabled=不建議帶有 {0} 個或更多元件的記錄
inspection.enhanced.for.with.record.pattern.can.be.used.message=可被取代為帶有記錄模式的增強 'for'
inspection.enhanced.for.with.record.pattern.can.be.used.not.used.option=未使用的記錄元件的最大數量:
inspection.excessive.range.check.fix.family.name=簡化過度範圍檢查
inspection.excessive.range.check.message=可被取代為 ''{0}''
inspection.explicit.chrono.field.display.name=可以簡化對帶有顯式 'ChronoField' 或 'ChronoUnit' 實參的 'java.time' 方法的呼叫
inspection.explicit.chrono.field.family.name=簡化帶有顯式 'ChronoField' 或 'ChronoUnit' 實參的呼叫
inspection.explicit.chrono.field.problem.descriptor=可以簡化對帶有顯式 'ChronoField' 或 'ChronoUnit' 實參呼叫的呼叫
inspection.if.statement.missing.break.in.loop.description=滿足條件後，可以終止迴圈
inspection.if.statement.missing.break.in.loop.name=在 'if' 條件下提前退出迴圈
inspection.if.statement.missing.break.in.loop.quickfix=新增 'break'
inspection.incorrect.date.format.display.name=不正確的 'DateTimeFormat' 模式
inspection.incorrect.date.format.message.literal=左單引號({0})後未跟隨右單引號
inspection.incorrect.date.format.message.padding=沒有連續模式字母的填充修飾符 ''{0}''
inspection.incorrect.date.format.message.reserved.character=使用保留字元 ''{0}''
inspection.incorrect.date.format.message.unpaired=在沒有事先開啟 ''{0}'' 的情況下關閉 <code>#ref</code>
inspection.incorrect.date.format.message.unsupported=非法模式字母 ''{0}''
inspection.incorrect.date.format.too.few.letters=連續模式字母 ''{0}'' 過少；最小: {1}；指定: {2}
inspection.incorrect.date.format.too.many.letters=連續模式字母 ''{0}'' 過多；最大: {1}；指定: {2}
inspection.incorrect.date.format.wrong.number.of.letters=連續模式字母 ''{0}'' 的數量錯誤；允許: {1}；指定: {2}
inspection.incorrect.message.format.choice.limit.incorrect=選擇模式中的下限 ''{0}'' 不正確
inspection.incorrect.message.format.choice.limit.not.found=選擇模式中的下''{0}''為空
inspection.incorrect.message.format.display.name='MessageFormat' 模式不正確
inspection.incorrect.message.format.incorrect.index=索引 ''{0}'' 不正確
inspection.incorrect.message.format.incorrect.order.choice=選擇模式中的下限未按升序排列
inspection.incorrect.message.format.incorrect.quotes.number=引號的數量可能不正確，將列印超過 1 個引號
inspection.incorrect.message.format.not.found.argument=No argument for index ''{0}''
inspection.incorrect.message.format.not.found.arguments=索引沒有實參: {0}
inspection.incorrect.message.format.not.used.argument=模式中未使用索引為 ''{0}'' 的實參
inspection.incorrect.message.format.pattern=訊息格式模式 ''{1}'' 中的 {0}
inspection.incorrect.message.format.quotes.around.parameter=佔位符 ''{0}'' 不會被取代，因為它包含在引號中
inspection.incorrect.message.format.unclosed.brace=未閉合的大括號
inspection.incorrect.message.format.unknown.format.type=未知格式類型 ''{0}''
inspection.incorrect.message.format.unmatched.brace=不符合的大括號
inspection.incorrect.message.format.unpaired.quote=訊息模式中不成對的引號
inspection.list.remove.in.loop.display.name=在迴圈中呼叫了 'List.remove()'
inspection.list.remove.in.loop.message=可被取代為 'List.subList().clear()'
inspection.lossy.conversion.compound.assignment.display.name=Implicit cast from ''{0}'' to ''{1}'' in compound assignment can be lossy
inspection.lossy.conversion.compound.assignment.name=Possibly lossy implicit cast in compound assignment
inspection.meta.annotation.without.runtime.description={0} 應具有 @Retention(RetentionPolicy.RUNTIME)
inspection.method.call.in.loop.ignore.known.methods.option=忽略有副作用的已知方法
inspection.new.object.equality.display.name=使用 '==' 比較新物件
inspection.new.object.equality.message=使用 ''{0}'' 比較新物件
inspection.non.strict.comparison.equality.display.name=非嚴格不等式 '>=' 或 '<=' 可被取代為 '=='
inspection.non.strict.comparison.equality.message=可被取代為等式
inspection.note.may.change.semantics=可能更改語意
inspection.only.one.element.used.array=僅使用了一個陣列元素
inspection.only.one.element.used.display.name=僅使用了一個元素
inspection.only.one.element.used.fix.family=取代為已存取的元素
inspection.only.one.element.used.list=僅使用了一個列表元素
inspection.only.one.element.used.string=僅使用了一個字串字元
inspection.option.ignore.as.initial.capacity=忽略 StringBuilders 和 Collections 的初始容量
inspection.option.ignore.assert=對斷言語句描述實參忽略
inspection.option.ignore.constant.initializers=對常數欄位的初始設定式忽略
inspection.option.ignore.exceptions=對 Throwable 子類別的建構函式實參忽略
inspection.option.ignore.in.annotations=在註解中忽略
inspection.option.ignore.in.hashcode=忽略 'hashCode()' 方法中的常數
inspection.option.ignore.in.tostring=在 toString() 方法內部忽略
inspection.option.ignore.nonnls=通過 @NonNls 進行註解時忽略
inspection.option.ignore.system.err=對 'System.err.print' 實參忽略
inspection.option.ignore.system.out=對 'System.out.print' 實參忽略
inspection.parameterized.parameters.static.collection.display.name=沒有資料提供程序方法的參數化測試類別
inspection.pattern.variable.can.be.used.display.name=可以使用模式變數
inspection.pattern.variable.can.be.used.existing.fix.family.name=取代為現有模式變數
inspection.pattern.variable.can.be.used.existing.fix.name=將 ''{0}'' 取代為現有模式變數 ''{1}''
inspection.pattern.variable.can.be.used.existing.message=可以使用現有模式變數 ''{0}'' 代替 ''{1}''
inspection.pattern.variable.can.be.used.fix.family.name=取代為模式變數
inspection.pattern.variable.can.be.used.fix.name=將 ''{0}'' 取代為模式變數
inspection.pattern.variable.can.be.used.message=變數 ''{0}'' 可被取代為模式變數
inspection.redundant.arguments.message=不必要的實參
inspection.redundant.class.call.display.name=冗餘的 'isInstance()' 或 'cast()' 呼叫
inspection.redundant.collection.operation.display.name=冗餘的 'Collection' 動作
inspection.redundant.collection.operation.fix.family.name=簡化集合動作
inspection.redundant.collection.operation.problem.arraycopy=為複製陣列而建立的集合不必要
inspection.redundant.collection.removal.by.index.fix=使用按物件移除
inspection.redundant.collection.removal.by.index.problem=按索引移除可被取代為按物件移除
inspection.redundant.collection.unnecessary.contains.fix=移除 ''{0}()'' 檢查
inspection.redundant.collection.unnecessary.contains.problem=不必要的 ''{0}()'' 檢查
inspection.redundant.compare.call.display.name=冗餘的 'compare()' 方法呼叫
inspection.redundant.compare.call.fix.name=內聯 'compare()' 呼叫
inspection.redundant.empty.string.argument.message=不必要的空字串實參
inspection.redundant.explicit.variable.type.description=可以省略區域變數的顯式類型
inspection.redundant.length.check.display.name=冗餘的陣列長度檢查
inspection.redundant.string.call.message=<code>#ref()</code> 的呼叫冗餘 #loc
inspection.redundant.string.constructor.message=<code>new #ref()</code> 冗餘 #loc
inspection.redundant.string.fix.family.name=移除冗餘呼叫
inspection.redundant.string.intern.on.constant.message=編譯時常量上 <code>#ref()</code> 的呼叫不必要 #loc
inspection.redundant.string.length.argument.message=不必要的字串長度實參
inspection.redundant.string.new.array.message=<code>#ref</code> 冗餘 #loc
inspection.redundant.string.operation.display.name=冗餘的 'String' 動作
inspection.redundant.string.option.do.not.report.string.constructors=不報告 String 建構函式呼叫
inspection.redundant.string.remove.argument.fix.name=移除實參
inspection.redundant.string.remove.fix.name=移除冗餘的 ''{0}()'' 呼叫
inspection.redundant.string.replace.with.arg.fix.name=取代為實參
inspection.redundant.string.replace.with.empty.fix.name=取代為空字串
inspection.redundant.zero.argument.message=不必要的零實參
inspection.refused.bequest.super.annotated.option=僅在通過以下方式註解 super 方法時報告:
inspection.replace.on.literal.display.name=取代動作不起任何作用
inspection.simplifiable.compare.java.time.display.name=帶有 'java.time' 'compareTo()' 呼叫的表達式可以簡化
inspection.simplifiable.compare.java.time.family.name=使用 'java.time' 'compareTo()' 呼叫簡化表達式
inspection.simplifiable.compare.java.time.problem.descriptor=帶有 'java.time' <code>#ref()</code> 呼叫的表達式可以簡化
inspection.simplifiable.if.statement.display.name='if' 語句可被取代為條件或布爾表達式
inspection.simplifiable.if.statement.fix.family.name=將 'if else' 取代為條件運算符
inspection.simplifiable.if.statement.fix.name=將 ''if else'' 取代為 ''{0}''
inspection.simplifiable.if.statement.message=If 語句可被取代為 ''{0}''
inspection.simplifiable.if.statement.option.dont.warn.on.ternary=不建議使用 '?:' 運算符
inspection.suppression.annotation.display.name=檢查禁止註解
inspection.suppression.annotation.problem.descriptor=檢查禁止註解 <code>#ref</code> #loc
inspection.suspicious.date.format.display.name=可疑的日期格式模式
inspection.suspicious.date.format.message.lower=使用了小寫 ''{0}'' ({1}) 模式: 預期可能為 ''{2}'' ({3})
inspection.suspicious.date.format.message.upper=使用了大寫 ''{0}'' ({1}) 模式: 預期可能為 ''{2}'' ({3})
inspection.suspicious.package.private.access.description={0} 是 {1}，但在不同的模組 ''{2}'' 中宣告
inspection.suspicious.package.private.access.problem={0} 重寫了來自在不同模組 ''{2}'' 中宣告的 {1} 的 package-private 方法
inspection.test.method.without.assertion.list.name=斷言方法:
inspection.test.method.without.assertions.exceptions.option=忽略宣告異常的測試方法
inspection.trivial.functional.expression.usage.description=可以簡化方法呼叫
inspection.type.may.be.weakened.add.stop.class.family=新增停止類別
inspection.type.may.be.weakened.add.stop.class.selection.popup=選擇停止類別
inspection.type.may.be.weakened.add.stop.class.selection.table=停止類別
inspection.type.may.be.weakened.add.stop.class.selection.table.label=停止類別:
inspection.type.may.be.weakened.add.stopper=作為停止類別添加以減弱
inspection.type.may.be.weakened.add.stopper.preview=停止類別將被新增到此檢查的停止類別列表中。
inspection.type.may.be.weakened.add.stopper.single=新增 {0} 作為停止類別以削弱
inspection.type.may.be.weakened.collection.method.option=對方法呼叫實參使用參數化集合類型(&P)
inspection.type.may.be.weakened.display.name=類型可能被削弱
inspection.type.may.be.weakened.do.not.weaken.inferred.variable.type=不建議削弱宣告為 'var' 的變數
inspection.type.may.be.weakened.do.not.weaken.return.type=不削弱返回值類型
inspection.type.may.be.weakened.do.not.weaken.to.object.option=不削弱為 'java.lang.Object'(&W)
inspection.type.may.be.weakened.field.problem.descriptor=欄位 <code>#ref</code> 的類型可能被削弱為 {0} #loc
inspection.type.may.be.weakened.ignore.option=在指派中使用右手類型作為最弱的類型(&R)
inspection.type.may.be.weakened.method.problem.descriptor=方法 <code>#ref()</code> 的返回值類型可能被削弱為 {0} #loc
inspection.type.may.be.weakened.only.weaken.to.an.interface=僅削弱為接口
inspection.type.may.be.weakened.parameter.problem.descriptor=參數 <code>#ref</code> 的類型可能被削弱為 {0} #loc
inspection.type.may.be.weakened.problem.descriptor=變數 <code>#ref</code> 的類型可能被削弱為 {0} #loc
inspection.type.may.be.weakened.quickfix=將類型削弱為 ''{0}''
inspection.type.may.be.weakened.weaken.type.family=削弱類型
inspection.unnecessary.string.escape.report.char.literals.option=報告字元文字
inspection.use.of.private.field.inner.classes.option=忽略來自內部類別的存取
inspection.use.of.slash.s.display.name='\\\\s' 轉義序列的非終止使用
inspection.use.of.slash.s.fix.family=將 '\\\\s' 序列取代為空格
inspection.use.of.slash.s.message=不推薦在行中間使用 '\\\\s' 轉義序列
inspection.x.call.can.be.replaced.with.y=<code>#ref()</code> 呼叫可被取代為 ''{0}()''
instance.Variable.may.not.be.initialized.problem.descriptor.junit=執行個體欄位 <code>#ref</code> 在物件建構或 'setUp()' 呼叫期間可能無法初始化 #loc
instance.method.naming.convention.element.description=執行個體方法
instance.variable.may.not.be.initialized.display.name=執行個體欄位可能無法初始化
instance.variable.may.not.be.initialized.problem.descriptor=執行個體欄位 <code>#ref</code> 在物件建構期間可能無法初始化 #loc
instance.variable.naming.convention.element.description=執行個體欄位
instance.variable.of.concrete.class.problem.descriptor=具體類別 <code>#ref</code> 的執行個體欄位 ''{0}'' #loc
instance.variable.used.before.initialized.display.name=執行個體欄位在初始化前使用
instance.variable.used.before.initialized.problem.descriptor=初始化前使用的執行個體欄位 <code>#ref</code> #loc
instanceof.catch.parameter.display.name='catch' 參數上的 'instanceof'
instanceof.catch.parameter.problem.descriptor='catch' 參數 <code>#ref</code> 上的 'instanceof' #loc
instanceof.check.for.this.display.name='this' 的 'instanceof' 檢查
instanceof.check.for.this.equality.problem.descriptor='this' 的類別比較 #loc
instanceof.check.for.this.problem.descriptor=<code>#ref</code> 的 'instanceof' 檢查 #loc
instanceof.concrete.class.equality.problem.descriptor=與具體類別 <code>#ref</code> 的類別比較 #loc
instanceof.concrete.class.pattern.problem.descriptor=針對具體類別 <code>#ref</code> 的模式測試 #loc
instanceof.concrete.class.problem.descriptor='instanceof' 具體類別 <code>#ref</code> #loc
instanceof.with.incompatible.interface.display.name=具有不相容接口的 'instanceof'
instanceof.with.incompatible.interface.problem.descriptor=具有不相容接口 <code>#ref</code> 的 'instanceof' #loc
instantiating.datetimeformatter.without.locale.problem.descriptor=在未在國際化上下文中指定區域設定的情況下呼叫 <code>DateTimeFormatter.#ref()</code> #loc
instantiating.object.to.get.class.object.display.name=實例化物件以獲取 'Class' 物件
instantiating.object.to.get.class.object.problem.descriptor=實例化物件以獲取類別物件 #loc
instantiating.object.to.get.class.object.replace.quickfix=取代為直接類別物件存取
instantiating.simpledateformat.without.locale.display.name=無區域設定的 'SimpleDateFormat'
instantiating.simpledateformat.without.locale.problem.descriptor=在未在國際化上下文中指定區域設定的情況下實例化 <code>#ref</code> #loc
instantiation.utility.class.display.name=實用程序類別的實例化
instantiation.utility.class.problem.descriptor=實用程序類別 <code>#ref</code> 的實例化 #loc
int.literal.may.be.long.literal.display.name=轉換為 'long' 可以是 'long' 文字
int.literal.may.be.long.literal.problem.descriptor=<code>#ref</code> 可被取代為 ''{0}'' #loc
integer.division.in.floating.point.context.display.name=浮點上下文中的整數除法
integer.division.in.floating.point.context.fix.family.name=將分子轉換為浮點類型
integer.division.in.floating.point.context.fix.name=將分子轉換為 ''{0}''
integer.division.in.floating.point.context.problem.descriptor=<code>#ref</code>: 浮點上下文中的整數除法 #loc
integer.multiplication.implicit.cast.to.long.display.name=整數乘法或移位隱式轉換為 'long'
integer.multiplication.implicit.cast.to.long.option=<html>忽略靜態證明不可能溢出的表達式</html>
integer.multiplication.implicit.cast.to.long.problem.descriptor=#ref: 整數乘法隱式轉換為 long #loc
integer.multiplication.implicit.cast.to.long.quickfix=轉換為 long
integer.shift.implicit.cast.to.long.problem.descriptor=#ref: 整數移位隱式轉換為 long #loc
interface.clashes.with.object.class.display.name=接口方法與 'Object' 中的方法衝突
interface.clashes.with.object.class.problem.descriptor=<code>#ref()</code> 與 'java.lang.Object' 中的方法衝突
interface.may.be.annotated.functional.display.name=接口可以註解為 '@FunctionalInterface'
interface.may.be.annotated.functional.problem.descriptor=接口 <code>#ref</code> 可以使用 @FunctionalInterface 註解
interface.naming.convention.element.description=接口
interface.never.implemented.display.name=沒有具體子類別的接口
interface.never.implemented.option=忽略僅宣告常數的接口
interface.never.implemented.problem.descriptor=接口 <code>#ref</code> 沒有具體子類別 #loc
interface.one.inheritor.display.name=只有一個直接繼承者的接口
interface.one.inheritor.problem.descriptor=只有一個直接繼承者的接口 <code>#ref</code> #loc
introduce.holder.class.quickfix=引入 holder 類別
introduce.variable.may.change.semantics.quickfix=引入變數 (可能更改語意)
introduce.variable.quickfix=引入變數
invert.method.quickfix=反轉方法
invert.quickfix=反轉 ''{0}''
invert.quickfix.family.name=反轉布爾
iterator.hasnext.which.calls.next.display.name=呼叫 'next()' 的 'Iterator.hasNext()'
iterator.hasnext.which.calls.next.problem.descriptor=<code>Iterator.{0}()</code> 包含 ''#ref()'' 呼叫 #loc
iterator.next.does.not.throw.nosuchelementexception.display.name=無法拋出 'NoSuchElementException' 的 'Iterator.next()'
iterator.next.does.not.throw.nosuchelementexception.problem.descriptor=無法拋出 'NoSuchElementException' 的 <code>Iterator.#ref()</code> '#loc
java.lang.import.display.name='java.lang' 軟體套件中有不必要的 import
java.lang.import.problem.descriptor='java.lang' 軟體套件中有不必要的 import #loc
jdbc.execute.with.non.constant.string.display.name='Statement.execute()' 呼叫具有非常數字串
jdbc.execute.with.non.constant.string.problem.descriptor=<code>Statement.#ref()</code> 呼叫具有非常數實參 #loc
jdbc.prepare.statement.with.non.constant.string.display.name='Connection.prepare*()' 呼叫具有非常數字串
jdbc.prepare.statement.with.non.constant.string.problem.descriptor=<code>Connection.#ref()</code> 呼叫具有非常數實參 #loc
jdbc.resource.opened.not.closed.display.name=JDBC 資源已開啟，但未安全關閉
jndi.resource.opened.not.closed.display.name=JNDI 資源已開啟，但未安全關閉
junit.abstract.test.class.naming.convention.element.description=Abstract 測試類別
junit.test.class.naming.convention.element.description=測試類別
junit.test.suite.naming.convention.element.description=測試套件
junit3.method.naming.convention.element.description=JUnit 3 測試方法
junit3.style.test.method.in.junit4.class.display.name=JUnit 4 類別中的舊樣式 JUnit 測試方法
junit3.style.test.method.in.junit4.class.problem.descriptor=JUnit 4 類別中的舊樣式 JUnit 測試方法 <code>#ref()</code> #loc
junit4.method.naming.convention.element.description=JUnit 4+ 測試方法
key.set.iteration.may.use.entry.set.display.name=可以最佳化對 'keySet()' 的迭代
key.set.iteration.may.use.entry.set.problem.descriptor=<code>#ref</code> 上的迭代可被取代為 ''{0}'' 迭代 #loc
key.set.iteration.may.use.entry.set.quickfix=最佳化 Map 迭代
labeled.statement.display.name=標記語句
labeled.statement.problem.descriptor=標記語句 <code>#ref:</code> #loc
lambda.body.can.be.code.block.name=lambda 體可以是程式碼塊
lambda.body.can.be.code.block.quickfix=將 lambda 體擴展為 {...}
lambda.can.be.replaced.with.anonymous.name=lambda 可被取代為匿名類別
lambda.can.be.replaced.with.anonymous.quickfix=將 lambda 取代為匿名類別
lambda.parameter.hides.member.variable.display.name=lambda 參數隱藏欄位
lambda.parameter.hides.member.variable.ignore.invisible.option=忽略從 lambda 實際不可見的欄位
lambda.parameter.hides.member.variable.problem.descriptor=lambda 參數 <code>#ref</code> 隱藏類別 ''{0}'' 中的欄位 #loc
lambda.parameter.naming.convention.display.name=lambda 參數命名約定
lambda.parameter.naming.convention.element.description=lambda 參數
lambda.parameter.type.can.be.specified.descriptor=Lambda 參數類型可以擴展為{0}
lambda.parameter.type.can.be.specified.family.quickfix=指定 lambda 參數類型
lambda.parameter.type.can.be.specified.name=可以指定 lambda 參數類型
lambda.parameter.type.can.be.specified.quickfix=將參數類型擴展為{0}
lambda.unfriendly.constructor.overload.problem.descriptor=建構函式 <code>#ref()</code> 的多載對 lambda 不友好
lambda.unfriendly.method.overload.display.name=方法多載對 lambda 不友好
lambda.unfriendly.method.overload.problem.descriptor=方法 <code>#ref()</code> 的多載對 lambda 不友好
large.array.allocation.no.outofmemoryerror.display.name=沒有 OutOfMemoryError 檢查的大型陣列分配
large.array.allocation.no.outofmemoryerror.maximum.number.of.elements.option=最大元素數:
large.array.allocation.no.outofmemoryerror.problem.descriptor=未檢查記憶體不足情況的大型陣列分配 #loc
large.initializer.primitive.type.array.display.name=原始類型陣列的過大初始設定式
large.initializer.primitive.type.array.maximum.number.of.elements.option=最大元素數:
large.initializer.primitive.type.array.problem.descriptor=具有太多元素 ({0}) 的原始陣列初始設定式 #loc
law.of.demeter.display.name=迪米特法則
law.of.demeter.field.problem.descriptor=對 <code>#ref()</code> 的存取違反迪米特法則 #loc
law.of.demeter.ignore.library.calls.option=忽略對庫方法的呼叫和對庫欄位的存取
law.of.demeter.problem.descriptor=對 <code>#ref()</code> 的呼叫違反迪米特法則 #loc
length.one.string.in.indexof.display.name= 'String.indexOf()' 呼叫中的單字元字串實參
length.one.strings.in.concatenation.display.name=單字元字串串聯
length.one.strings.in.concatenation.replace.quickfix=取代為字元
limited.scope.inner.class.display.name=區域類別
limited.scope.inner.class.problem.descriptor=區域類別 <code>#ref</code> #loc
list.indexof.replaceable.by.contains.display.name='List.indexOf()' 表達式可被取代為 'contains()'
listener.may.use.adapter.display.name=類別可以擴展適配器而不是實作偵聽器
listener.may.use.adapter.emtpy.methods.option=僅在找到空實作方法時發出警告(&O)
listener.may.use.adapter.fix.family.name=取代為適配器
listener.may.use.adapter.problem.descriptor=類別 ''{0}'' 可以擴展 ''{1}'' 而不是實作 <code>#ref</code> #loc
literal.as.arg.to.string.equals.display.name=字串文字可以為 'equals()' 限定符
literal.as.arg.to.string.equals.flip.quickfix=翻轉 ''{0}()''
literal.as.arg.to.string.equals.problem.descriptor=文字 #ref 是 ''{0}()'' 的實參，而不是其限定符 #loc
load.library.with.non.constant.string.display.name='System.loadLibrary()' 呼叫具有非常數字串
load.library.with.non.constant.string.problem.descriptor=<code>{0}.#ref()</code> 呼叫具有非常數實參 #loc
local.variable.hides.member.variable.display.name=區域變數隱藏欄位
local.variable.hides.member.variable.ignore.option=忽略隱藏非 static 欄位的 static 上下文中的區域變數
local.variable.hides.member.variable.problem.descriptor=區域變數 <code>#ref</code> 隱藏類別 ''{0}'' 中的欄位 #loc
local.variable.naming.convention.display.name=區域變數命名約定
local.variable.naming.convention.element.description=區域變數
local.variable.naming.convention.ignore.catch.option=忽略 'catch' 塊參數
local.variable.naming.convention.ignore.option=忽略 for 迴圈參數
local.variable.of.concrete.class.problem.descriptor=具體類別 <code>#ref</code> 的區域變數 ''{0}'' #loc
log.condition.text=日誌條件文本
log.method.name=記錄方法名稱
log.statement.guarded.by.log.condition.display.name=日誌呼叫不受日誌條件保護
log.statement.guarded.by.log.condition.flag.all.unguarded.option=標記所有不受保護的日誌呼叫
log.statement.guarded.by.log.condition.problem.descriptor=<code>#ref()</code> 日誌呼叫不受日誌條件保護 #loc
log.statement.guarded.by.log.condition.quickfix=使用日誌條件包圍
logger.class.name=記錄器類別名:
logger.factory.class.name=記錄器工廠類別名
logger.factory.method.name=記錄器工廠方法名稱
logger.initialized.with.foreign.class.display.name=使用外類別初始化記錄器
logger.initialized.with.foreign.class.fix.family.name=取代外類別
logger.initialized.with.foreign.class.ignore.non.public.classes.option=忽略非 public 類別中的記錄器
logger.initialized.with.foreign.class.ignore.super.class.option=忽略使用超類別初始化的記錄器
logger.initialized.with.foreign.class.problem.descriptor=使用外類別 <code>#ref</code> 初始化記錄器 #loc
logger.name.option=記錄器類別名(&C):
long.literals.ending.with.lowercase.l.display.name='long' 文字以 'l' 而不是 'L' 結尾
long.literals.ending.with.lowercase.l.problem.descriptor='long' 文字 <code>#ref</code> 以小寫 'l' 結尾 #loc
loop.condition.not.updated.inside.loop.display.name=迴圈變數未在迴圈內更新
loop.condition.not.updated.inside.loop.problem.descriptor=條件 '#ref' 未在迴圈內更新#loc
loop.statements.that.dont.loop.display.name=不迴圈的迴圈語句
loop.statements.that.dont.loop.problem.descriptor=<code>#ref</code> 語句未迴圈 #loc
loop.variable.not.updated.inside.loop.option.nonlocal=忽略可能的非本地更改
loop.variable.not.updated.inside.loop.problem.descriptor=變數 '#ref' 未在迴圈內更新#loc
loop.with.implicit.termination.condition.display.name=具有隱式終止條件的迴圈
loop.with.implicit.termination.condition.dowhile.problem.descriptor=具有隱式終止條件的 <code>#ref-while</code> 迴圈 #loc
loop.with.implicit.termination.condition.problem.descriptor=具有隱式終止條件的 <code>#ref</code> 迴圈 #loc
loop.with.implicit.termination.condition.quickfix=使條件顯式
magic.character.display.name=魔幻字元
magic.character.problem.descriptor=國際化上下文中使用的魔幻字元 <code>#ref</code> #loc
magic.number.display.name=幻數
magic.number.problem.descriptor=幻數 <code>#ref</code> #loc
make.class.final.fix.family.name=將類別設為 final
make.class.final.fix.name=將類別 ''{0}'' 設為 ''final''
make.constructor.public=將建構函式設為 'public'
make.field.final.fix.family.name=設為 final
make.field.final.quickfix=將 ''{0}'' 設為 ''final''
make.field.static.final.fix.family.name=設為 static final
make.initialization.explicit.quickfix=使初始化顯式
make.method.ctr.quickfix=使方法成為建構函式
make.method.final.fix.family.name=將方法設為 'final'
make.method.final.fix.name=將方法 ''{0}()'' 設為 ''final''
make.package.private.fix.family.name=設為 package-private
make.static.final.quickfix=將 ''{0}'' 設為 static final
make.static.quickfix=設為 'static'
malformed.format.string.display.name=字串的格式錯誤
malformed.format.string.problem.descriptor.arguments.do.not.match.type=實參類型 ''{0}'' 與格式說明符 ''{1}'' 的類型不符合 #loc
malformed.format.string.problem.descriptor.at.least.too.few.arguments=格式字串的實參過少(實際: {0}，至少應為: {1}) #loc
malformed.format.string.problem.descriptor.illegal=非法格式字串指定符: {0} #loc
malformed.format.string.problem.descriptor.malformed=格式字串 <code>#ref</code> 的格式錯誤 #loc
malformed.format.string.problem.descriptor.too.few.arguments=格式字串的實參太少(實際: {0}，應為: {1}) #loc
malformed.format.string.problem.descriptor.too.many.arguments=格式字串的實參太多(實際: {0}，應為: {1}) #loc
manual.array.copy.display.name=手動陣列複製
manual.array.copy.problem.descriptor=手動陣列複製 #loc
manual.array.to.collection.copy.display.name=手動陣列到集合複製
manual.array.to.collection.copy.problem.descriptor=手動陣列到集合複製 #loc
map.replaceable.by.enum.map.display.name='Map' 可被取代為 'EnumMap'
map.replaceable.by.enum.map.problem.descriptor=<code>#ref</code> 可被取代為 'EnumMap' #loc
mark.modules.as.loaded.together.fix.family.name=將模組標記為一起載入
mark.modules.as.loaded.together.fix.text=將 ''{0}'' 和 ''{1}'' 模組標記為一起載入
marker.interface.display.name=標記接口
marker.interface.problem.descriptor=標記接口 <code>#ref</code> #loc
masked.assertion.display.name=斷言通過 'catch' 禁止
masked.assertion.problem.description=''{0}'' 不能失敗，因為它被包圍 ''catch'' 禁止
math.random.cast.to.int.display.name='Math.random()' 轉換為 'int'
math.random.cast.to.int.problem.descriptor=<code>#ref</code> 轉換為 ''{0}'' 時始終向下舍入為 ''0'' #loc
math.random.cast.to.int.quickfix=新增括號以在轉換前執行乘法
math.rounding.with.int.argument.display.name=使用 'int' 實參呼叫數學舍入
math.rounding.with.int.argument.family.name=簡化舍入呼叫
math.rounding.with.int.argument.problem.descriptor=帶有 'int' 類型實參的 <code>#ref()</code> #loc
math.rounding.with.int.argument.quickfix=簡化 ''{0}()'' 呼叫
meta.annotation.without.runtime.retention=不含 '@Retention(RUNTIME)' 註解的測試註解
method.call.in.loop.condition.display.name=迴圈條件下的方法呼叫
method.call.in.loop.condition.problem.descriptor=迴圈條件下呼叫方法 <code>#ref()</code> #loc
method.can.be.variable.arity.method.display.name=方法可以有 varargs 參數
method.can.be.variable.arity.method.ignore.all.primitive.arrays.option=忽略所有原始陣列類型
method.can.be.variable.arity.method.ignore.byte.short.option=忽略具類型為 byte[] 或 short[] 的參數
method.can.be.variable.arity.method.ignore.multidimensional.arrays.option=忽略多維陣列參數
method.can.be.variable.arity.method.ignore.multiple.arrays.option=忽略具有多個陣列參數的方法
method.can.be.variable.arity.method.problem.descriptor=<code>#ref()</code> 可以轉換為 vararg 方法 #loc
method.complexity.limit.option=方法復雜度限制:
method.count.ignore.getters.setters.option=忽略簡單的 getter 和 setter 方法(&I)
method.count.limit.option=方法計數限制:
method.coupling.display.name=過度耦合的方法
method.coupling.limit.option=方法耦合限制:
method.coupling.problem.descriptor=<code>#ref</code> 過度耦合 (# 參照的類別 = {0}) #loc
method.may.be.static.display.name=方法可以為 'static'
method.may.be.static.empty.option=忽略空方法
method.may.be.static.ignore.default.methods.option=忽略 'default' 方法
method.may.be.static.only.option=僅檢查 'private' 或 'final' 方法
method.may.be.static.problem.descriptor=方法 <code>#ref()</code> 可能為 'static' #loc
method.may.be.static.replaces.qualifiers.with.class.references.option=快速修復可將執行個體限定符取代為類別參照
method.may.be.synchronized.display.name=只有一個 'synchronized' 塊的方法可被取代為 'synchronized' 方法
method.may.be.synchronized.problem.descriptor=帶 synchronized 塊的方法 <code>#ref()</code> 可以是 synchronized 方法 #loc
method.may.be.synchronized.quickfix=將方法設為 synchronized 並移除 synchronized 塊
method.name.regex=方法名稱正則表達式
method.name.same.as.class.name.display.name=方法名稱與類別名相同
method.name.same.as.class.name.problem.descriptor=方法名稱 <code>#ref</code> 與其類別名相同 #loc
method.name.same.as.parent.name.display.name=方法名稱與父類別名相同
method.name.same.as.parent.name.problem.descriptor=方法名稱 <code>#ref</code> 與其父類別名相同 #loc
method.names.differ.only.by.case.display.name=方法名稱僅大小寫不同
method.names.differ.only.by.case.problem.descriptor=方法名稱 <code>#ref</code> 和方法名稱 ''{0}'' 僅大小寫不同 #loc
method.only.used.from.inner.class.display.name=僅在內部類中使用 private 方法
method.only.used.from.inner.class.ignore.option=忽略從匿名類別或區域類別呼叫的方法(&A)
method.only.used.from.inner.class.problem.descriptor=方法 <code>#ref()</code>#loc 只能從{0, choice, 1#內部|2#區域|3#}{1, choice, 1#類別|2#接口|3#派生的匿名類別|4#註解類型|5#枚舉|6#記錄} ''{2}'' 使用 #loc
method.overloads.display.name=可能是超類別方法意外多載
method.overloads.problem.descriptor=當可能打算覆寫時，方法 <code>#ref()</code> 多載超類別的相容方法 #loc
method.overloads.report.incompatible.option=即使參數類型不相容，也會報告
method.overrides.inaccessible.method.display.name=方法覆寫了超類別不可存取的方法
method.overrides.package.local.method.problem.descriptor=方法 <code>#ref()</code> 覆寫了位於另一個軟體套件中的超類別的 package-private 方法 #loc
method.overrides.private.display.name.problem.descriptor=方法 <code>#ref()</code> 重寫了超類別的 'private' 方法 #loc
method.overrides.static.display.name=方法嘗試覆寫超類別的 'static' 方法
method.overrides.static.problem.descriptor=方法 <code>#ref()</code> 嘗試覆寫超類別的 static 方法 #loc
method.ref.can.be.replaced.with.lambda.name=方法參照可被取代為 lambda
method.ref.can.be.replaced.with.lambda.quickfix=將方法參照取代為 lambda
method.return.always.constant.display.name=方法返回類別特定的常數
method.return.always.constant.problem.descriptor=方法 <code>#ref()</code> 及其所有派生方法始終返回常數
method.return.concrete.class.problem.descriptor=方法返回一個具體類別 <code>#ref</code> #loc
method.with.multiple.loops.display.name=具有多個迴圈的方法
method.with.multiple.loops.problem.descriptor=<code>#ref</code> 包含 {0} 個迴圈 #loc
mismatched.read.write.array.display.name=陣列的讀取和寫入不符合
mismatched.read.write.array.problem.descriptor.read.not.write=陣列 <code>#ref</code> 的內容已讀取，但從未被寫入 #loc
mismatched.read.write.array.problem.descriptor.write.not.read=陣列 <code>#ref</code> 的內容已寫入，但從未被讀取 #loc
mismatched.string.builder.queried.problem.descriptor=<code>{0} #ref</code> 的內容已查詢，但從未更新 #loc
mismatched.string.builder.query.update.display.name='StringBuilder' 的查詢和更新不符合
mismatched.string.builder.updated.problem.descriptor=<code>{0} #ref</code> 的內容已更新，但從未被查詢 #loc
mismatched.update.collection.display.name=不符合的集合查詢和更新
mismatched.update.collection.problem.description.queried.not.updated=集合 <code>#ref</code> 的內容已被查詢，但從未更新 #loc
mismatched.update.collection.problem.descriptor.updated.not.queried=集合 <code>#ref</code> 的內容已更新，但從未被查詢 #loc
misordered.assert.equals.arguments.display.name=順序錯誤的 'assertEquals()' 實參
misordered.assert.equals.arguments.flip.quickfix=翻轉比較實參
misordered.assert.equals.arguments.problem.descriptor=<code>#ref()</code> 的實參順序錯誤 #loc
missing.add.deprecated.javadoc.tag.quickfix=新增 '@deprecated' Javadoc 標記說明
missing.deprecated.annotation.add.quickfix=新增 '@Deprecated' 註解
missing.deprecated.annotation.display.name=缺少 '@Deprecated' 註解
missing.deprecated.annotation.problem.descriptor=缺少 '@Deprecated' 註解 #loc
missing.deprecated.tag.option=警告缺少 @deprecated Javadoc 標記說明
missing.deprecated.tag.problem.descriptor=缺少 '@deprecated' Javadoc 標記說明 #loc
missing.override.annotation.display.name=缺少 '@Override' 註解
missing.override.annotation.in.overriding.problem.descriptor=覆寫方法未使用 '@Override' 註解
missing.override.annotation.problem.descriptor=缺少關於 <code>#ref()</code> 的 '@Override' 註解 #loc
missing.override.warn.on.super.option=當方法的覆寫方法並非全部具有 '@Override' 註解時，醒目提示該方法
missing.package.html.problem.descriptor=軟體套件 ''{0}'' 缺少 <code>package.html</code> 檔案
missing.package.info.display.name=缺少 'package-info.java'
missing.package.info.problem.descriptor=軟體套件 ''{0}'' 缺少 <code>package-info.java</code> 檔案
missing.serial.annotation.display.name=可以使用 '@Serial' 註解
missing.serial.annotation.on.field.problem.descriptor=<code>#ref</code> 可以使用 '@Serial' 進行註解
missing.serial.annotation.on.method.problem.descriptor=<code>#ref()</code> 可以使用 '@Serial' 進行註解
missorted.modifiers.display.name=錯位修飾符
missorted.modifiers.problem.descriptor=錯位修飾符 <code>{0}</code> #loc
missorted.modifiers.require.option=檢查註解順序
missorted.modifiers.sort.quickfix=對修飾符排序
missorted.modifiers.typeuse.before.type.option=目標 TYPE_USE 註解始終位於類型前
misspelled.equals.display.name='equal()' 代替 'equals()'
misspelled.equals.problem.descriptor=<code>#ref()</code> 方法可能應當是 'equals()' #loc
module.with.too.few.classes.display.name=類別過少的模組
module.with.too.few.classes.min.option=最小類別數:
module.with.too.few.classes.problem.descriptor=模組 ''{0}'' 包含過少的類別 ({1} < {2})
module.with.too.many.classes.display.name=類別過多的模組
module.with.too.many.classes.max.option=最大類別數:
module.with.too.many.classes.problem.descriptor=模組 ''{0}'' 包含過多的類別 ({1} > {2})
move.anonymous.to.inner.quickfix=轉換為命名內部類別
move.class.quickfix=移動類別
move.exception.to.javadoc.fix.family.name=移至 Javadoc '@throws'
multi.catch.can.be.split.name=多 catch 可拆分為單獨的 catch 塊
multi.catch.can.be.split.quickfix=將多 catch 拆分為單獨的 'catch' 塊
multiple.declaration.array.only.option=僅在單個宣告中對不同的陣列次元發出警告
multiple.declaration.display.name=一個宣告中的多個變數
multiple.declaration.ignore.for.option=忽略 'for' 迴圈宣告
multiple.declaration.problem.descriptor=一個宣告中的多個變數 #loc
multiple.exceptions.declared.on.test.method.display.name=在測試方法上宣告的多個異常
multiple.exceptions.declared.on.test.method.problem.descriptor=<code>#ref</code> 可被取代為 'throws Exception' #loc
multiple.loggers.display.name=具有多個記錄器的類別
multiple.loggers.problem.descriptor=類別 <code>#ref</code> 宣告多個記錄器 #loc
multiple.return.points.per.method.display.name=具有多個返回點的方法
multiple.return.points.per.method.problem.descriptor=<code>#ref</code> 具有 {0} 個返回點 #loc
multiple.top.level.classes.in.file.display.name=單個檔案中的多個頂級類別
multiple.top.level.classes.in.file.problem.descriptor=檔案中的多個頂級類別
multiple.typed.declaration.problem.descriptor=在一個宣告中具有不同陣列次元的變數 #loc
multiply.or.divide.by.power.of.two.display.name=乘以或除以 2 的冪
multiply.or.divide.by.power.of.two.divide.option=還通過 2 的冪檢查除法
multiply.or.divide.by.power.of.two.replace.quickfix=取代為移位
naked.notify.display.name=沒有相應狀態更改的 'notify()' 或 'notifyAll()'
naked.notify.problem.descriptor=在沒有相應狀態更改的情況下呼叫 <code>#ref()</code> #loc
naming.convention.problem.descriptor.long={0} 名稱 <code>#ref</code> 過長({1} > {2}) #loc
naming.convention.problem.descriptor.regex.mismatch={0} 名稱 <code>#ref</code> 不符合正則表達式 ''{1}'' #loc
naming.convention.problem.descriptor.short={0} 名稱 <code>#ref</code> 過短({1} < {2}) #loc
native.method.display.name=本地方法
native.method.naming.convention.element.description='native' 方法
native.method.problem.descriptor=宣告為 <code>#ref</code> 的方法不可移植 #loc
negated.conditional.display.name=具有否定條件的條件表達式
negated.conditional.expression.display.name=否定條件表達式
negated.conditional.expression.problem.descriptor=否定條件表達式 #loc
negated.conditional.expression.quickfix=移除否定
negated.conditional.invert.quickfix=反轉條件
negated.conditional.problem.descriptor=具有否定條件的條件表達式 #loc
negated.equality.expression.display.name=否定相等表達式
negated.equality.expression.problem.descriptor=否定 ''{0}'' #loc
negated.equality.expression.quickfix=移除否定
negated.if.else.display.name=具有否定條件的 'if' 語句
negated.if.else.ignore.negated.null.option=忽略 '!= null' 比較
negated.if.else.ignore.negated.zero.option=忽略 '!= 0' 比較
negated.if.else.invert.quickfix=反轉 'if' 條件
negated.if.else.problem.descriptor=帶嵌套條件的 <code>#ref</code> 語句 #loc
negative.int.constant.in.long.context.display.name=長整數型上下文中的負整數型十六進制常數
negative.int.constant.in.long.context.fix.add.suffix=新增 'L' 後綴(更改語意)
negative.int.constant.in.long.context.fix.convert=轉換為長整數型常數(保留語意)
negatively.named.boolean.variable.display.name=否定命名的布爾變數
negatively.named.boolean.variable.problem.descriptor=布爾變數 <code>#ref</code> 已否定命名 #loc
nested.assignment.display.name=嵌套指派
nested.assignment.problem.descriptor=使用的指派表達式的結果 #loc
nested.conditional.expression.display.name=嵌套條件表達式
nested.conditional.expression.problem.descriptor=嵌套條件表達式 <code>#ref</code> #loc
nested.method.call.display.name=嵌套方法呼叫
nested.method.call.ignore.option=忽略欄位初始設定式中的嵌套方法呼叫
nested.method.call.problem.descriptor=嵌套方法呼叫 <code>#ref()</code> #loc
nested.switch.statement.display.name=嵌套 'switch' 語句
nested.switch.statement.problem.descriptor=嵌套 <code>#ref</code> {0} #loc
nested.synchronized.statement.display.name=嵌套 'synchronized' 語句
nested.synchronized.statement.problem.descriptor=嵌套 <code>#ref</code> 語句 #loc
nested.try.statement.display.name=嵌套 'try' 語句
nested.try.statement.problem.descriptor=嵌套 <code>#ref</code> 語句 #loc
nesting.depth.display.name=過度嵌套的方法
nesting.depth.limit.option=嵌套深度限制:
nesting.depth.problem.descriptor=<code>#ref</code> 過度嵌套 (最大嵌套深度 = {0}) #loc
new.exception.without.arguments.display.name=未使用實參呼叫異常建構函式
new.exception.without.arguments.problem.descriptor=<code>new #ref()</code> 沒有實參 #loc
new.method.naming.convention.display.name=方法命名約定
new.string.buffer.replaceable.by.string.problem.descriptor=<code>#ref</code> 可被取代為 'String' #loc
new.string.buffer.with.char.argument.display.name=StringBuilder 建構函式呼叫具有 'char' 實參
new.string.buffer.with.char.argument.problem.descriptor=<code>new #ref()</code> 具有 'char' 類型的實參 #loc
new.string.buffer.with.char.argument.quickfix=將字元實參取代為字串文字
no.logger.display.name=不帶記錄器的類別
no.logger.problem.descriptor=類別 <code>#ref</code> 未宣告記錄器 #loc
non.atomic.operation.on.volatile.field.display.name='volatile' 欄位上的非原子動作
non.atomic.operation.on.volatile.field.problem.descriptor=volatile 欄位 <code>#ref</code> 上的非原子動作 #loc
non.boolean.method.name.must.not.start.with.question.display.name=非布爾方法名稱不能以疑問詞開頭
non.boolean.method.name.must.not.start.with.question.problem.descriptor=非布爾方法名稱 <code>#ref</code> 以疑問詞開頭 #loc
non.comment.source.statements.display.name=過長的方法
non.comment.source.statements.limit.option=非註釋源語句限制:
non.comment.source.statements.problem.descriptor=<code>#ref</code> 過長 (# 非註釋源語句 = {0}) #loc
non.constant.logger.display.name=非常數記錄器
non.constant.logger.problem.descriptor=非常數記錄器欄位 <code>#ref</code> #loc
non.exception.name.ends.with.exception.display.name=非異常類別名以 'Exception' 結尾
non.exception.name.ends.with.exception.problem.descriptor=非異常類別名 <code>#ref</code> 以 'Exception' 結尾 #loc
non.exception.name.ends.with.exception.quickfix=使 ''{0}'' 擴展 ''java.lang.Exception''
non.final.clone.display.name=非 final 'clone()' 位於安全上下文中
non.final.clone.problem.descriptor=非 final <code>#ref()</code> 方法，影響安全性 #loc
non.final.field.compareto.display.name='compareTo()' 中參照了非 final 欄位
non.final.field.compareto.problem.descriptor=在 'compareTo()' 中存取了非 final 欄位 <code>#ref</code> #loc
non.final.field.in.enum.display.name='enum' 中的非 final 欄位
non.final.field.in.enum.problem.descriptor=枚舉 ''{0}'' 中存在非 final 欄位 <code>#ref</code> #loc
non.final.field.in.enum.quickfix.option=忽略無法成為 'final' 的欄位
non.final.field.in.equals.display.name='equals()' 中參照了非 final 欄位
non.final.field.in.equals.problem.descriptor=在 'equals()' 中存取了非 final 欄位 <code>#ref</code> #loc
non.final.field.in.hashcode.display.name='hashCode()' 中參照了非 final 欄位
non.final.field.in.hashcode.problem.descriptor=在 'hashCode()' 中存取了非 final 欄位 <code>#ref</code> #loc
non.final.field.of.exception.display.name='Exception' 類別的非 final 欄位
non.final.field.of.exception.problem.descriptor=異常類別的非 final 欄位 <code>#ref</code> #loc
non.final.static.variable.initialization.display.name=在類別初始化期間使用非 final static 欄位
non.final.static.variable.initialization.problem.descriptor=在類別初始化期間使用非 final static 欄位 <code>#ref</code> #loc
non.final.utility.class.display.name=實用程序類別不為 'final'
non.final.utility.class.problem.descriptor=實用程序類別 <code>#ref</code> 不為 'final' #loc
non.protected.constructor.in.abstract.class.display.name=抽象類別中的 public 建構函式
non.protected.constructor.in.abstract.class.ignore.option=對非 public 類別忽略
non.protected.constructor.in.abstract.class.problem.descriptor=抽象類別的建構函式 <code>#ref()</code> 不應宣告為 'public' #loc
non.public.clone.display.name='clone()' 方法不是 'public'
non.public.clone.problem.descriptor=<code>#ref()</code> 方法不是 'public' #loc
non.reproducible.math.call.display.name=對 'Math' 的不可重現呼叫
non.reproducible.math.call.problem.descriptor=<code>Math.#ref()</code> 可能產生不可重現的結果 #loc
non.reproducible.math.call.replace.quickfix=取代為 'StrictMath' 呼叫
non.serializable.@interface.with.serialversionuid.problem.descriptor=定義 'serialVersionUID' 欄位的不可序列化 @interface <code>#ref</code> #loc
non.serializable.anonymous.with.serialversionuid.problem.descriptor=派生自 <code>#ref</code> 的不可序列化匿名類別定義 'serialVersionUID' 欄位 #loc
non.serializable.class.with.readwriteobject.display.name=具有 'readObject()' 或 'writeObject()' 的不可序列化類別
non.serializable.class.with.readwriteobject.problem.descriptor.both=不可序列化{0, choice, 1#類別|2#接口|3#派生的匿名類別|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'readObject()' 和 'writeObject()' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.read=不可序列化{0, choice, 1#類別|2#接口|3#派生的匿名類別|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'readObject()' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.write=不可序列化{0, choice, 1#類別|2#接口|3#派生的匿名類別|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'writeObject()' #loc
non.serializable.class.with.serialversionuid.problem.descriptor=定義 'serialVersionUID' 欄位的不可序列化類別 <code>#ref</code> #loc
non.serializable.field.in.serializable.class.display.name='Serializable' 類別中有不可序列化的欄位
non.serializable.field.in.serializable.class.problem.descriptor=可序列化類別中不可序列化的欄位 '#ref' #loc
non.serializable.interface.with.serialversionuid.problem.descriptor=定義 'serialVersionUID' 欄位的不可序列化接口 <code>#ref</code> #loc
non.serializable.object.bound.to.http.session.display.name=不可序列化的物件被綁定到了 'HttpSession'
non.serializable.object.bound.to.http.session.problem.descriptor=傳遞給 HttpSession 的不可序列化物件 #loc
non.serializable.object.passed.to.object.stream.display.name=不可序列化的物件被傳遞給了 'ObjectOutputStream'
non.serializable.object.passed.to.object.stream.problem.descriptor=傳遞給 ObjectOutputStream 的不可序列化物件 #loc
non.serializable.with.serialversionuid.display.name=具有 'serialVersionUID' 的不可序列化類別
non.short.circuit.boolean.expression.display.name=非短路布爾表達式
non.short.circuit.boolean.expression.problem.descriptor=非短路布爾表達式 <code>#ref</code> #loc
non.short.circuit.boolean.expression.replace.quickfix=取代為短路表達式
non.synchronized.method.overrides.synchronized.method.display.name=未同步方法覆寫 'synchronized' 方法
non.synchronized.method.overrides.synchronized.method.problem.descriptor=未同步方法 <code>#ref()</code> 覆寫 synchronized 方法 #loc
non.thread.safe.lazy.initialization.display.name=不安全的 'static' 欄位延遲初始化
non.thread.safe.lazy.initialization.problem.descriptor='static' 欄位 <code>#ref</code> 的延遲初始化不是執行緒安全 #loc
none=無
noop.method.in.abstract.class.display.name='abstract' 類別中的無運算方法
noop.method.in.abstract.class.problem.descriptor=無動作方法 <code>#ref()</code> 應當設為 abstract #loc
normalize.declaration.quickfix=拆分為單獨的宣告
not.object.equals.can.be.equality.problem.descriptor=<code>!#ref()</code> 可被取代為 '!='
notify.called.on.condition.display.name=在 'java.util.concurrent.locks.Condition' 物件上呼叫了 'notify()' 或 'notifyAll()'
notify.called.on.condition.problem.descriptor=在條件物件上呼叫 <code>#ref()</code> #loc
notify.without.corresponding.wait.display.name=沒有相應 'wait()' 的 'notify()'
notify.without.corresponding.wait.problem.descriptor=在沒有相應 <code>wait()</code> 的情況下呼叫 <code>#ref()</code> #loc
null.argument.to.var.arg.method.display.name=引起混淆的 vararg 方法實參
null.argument.to.var.arg.method.problem.descriptor=引起混淆的實參 <code>#ref</code>，不清楚是否需要 vararg 或非 vararg 呼叫 #loc
null.thrown.display.name=已拋出 'null'
null.thrown.problem.descriptor=已拋出 <code>#ref</code> #loc
number.comparison.display.name=使用 '==' 而不是 'equals()' 進行數字比較
number.comparison.problem.descriptor=使用 <code>#ref</code> 而不是 'equals()' 來比較數字物件 #loc
object.allocation.in.loop.display.name=迴圈中的物件分配
object.allocation.in.loop.new.descriptor=迴圈中的物件分配 <code>new #ref()</code> #loc
object.allocation.in.loop.problem.array.initializer.descriptor=迴圈中的陣列分配 #loc
object.allocation.in.loop.problem.call.descriptor=物件分配通過迴圈中的 <code>#ref()</code> 呼叫完成 #loc
object.allocation.in.loop.problem.lambda.descriptor=物件分配通過捕獲迴圈中的 lambda 完成 #loc
object.allocation.in.loop.problem.methodref.descriptor=物件分配通過迴圈中的執行個體綁定方法參照 <code>#ref()</code> 完成 #loc
object.allocation.in.loop.problem.string.concat=物件分配通過迴圈中的字串串聯完成 #loc
object.comparison.display.name=使用 '==' 而不是 'equals()' 進行物件比較
object.comparison.enumerated.ignore.option=忽略枚舉變數之間的 '=='
object.comparison.klass.ignore.option=忽略沒有 'equals()' 實作的 final 類別類型之間的 '=='
object.comparison.problem.description=使用 <code>#ref</code> 而不是 'equals()' 來比較物件值 #loc
object.equality.ignore.between.objects.of.a.type.with.only.private.constructors.option=忽略只有 'private' 建構函式的類型物件之間的 '=='
object.equals.can.be.equality.display.name='equals()' 呼叫可被取代為 '=='
object.equals.can.be.equality.problem.descriptor=<code>#ref()</code> 可被取代為 '=='
object.instantiation.inside.equals.or.hashcode.display.name='equals()' 或 'hashCode()' 內部的物件實例化
object.instantiation.inside.equals.or.hashcode.problem.descriptor=''{0}()'' 內部的物件實例化 #loc
object.instantiation.inside.equals.or.hashcode.problem.descriptor2=''{0}()'' ({1}) 內部的物件實例化 #loc
object.notify.display.name=呼叫 'notify()' 而不是 'notifyAll()'
object.notify.problem.descriptor=<code>#ref</code> 可能應當取代為 'notifyAll()' #loc
objects.hash.fix.family.name=使用 'Arrays.hashCode()' 包裝
objects.hash.problem.descriptor=傳遞給 'Objects.hash()' 的陣列應包裝在 'Arrays.hashcode()' 中
octal.and.decimal.integers.in.same.array.display.name=同一陣列中的八進制和十進制整數
octal.and.decimal.integers.in.same.array.problem.descriptor=同一陣列初始設定式中的八進制和十進制整數 #loc
octal.literal.display.name=八進制整數
octal.literal.problem.descriptor=八進制整數 <code>#ref</code> #loc
only.report.public.methods.option=僅報告 'public' 方法
only.report.qualified.static.usages.option=僅報告來自 static 上下文的限定靜態存取
only.report.static.methods=僅報告 'static' 方法(&O)
only.warn.on.protected.clone.methods=僅對 'protected' 克隆方法發出警告
only.warn.on.public.clone.methods=僅對 'public' 克隆方法發出警告
optional.contains.array.problem.descriptor='Optional' 包含陣列 <code>#ref</code>
optional.contains.collection.display.name='Optional' 包含陣列或集合
optional.contains.collection.problem.descriptor='Optional' 包含集合 <code>#ref</code>
optional.used.as.field.or.parameter.type.display.name=用作欄位或參數類型的 'Optional'
optional.used.as.field.type.problem.descriptor=<code>#ref</code> 用作欄位 ''{0}'' 的類型
optional.used.as.parameter.type.problem.descriptor=<code>#ref</code> 用作參數 ''{0}'' 的類型
options.label.ignored.classes=已忽略的類別:
options.title.ignored.classes=已忽略的類別
overloaded.methods.with.same.number.parameters.display.name=具有相同參數數量的多載方法
overloaded.methods.with.same.number.parameters.option=<html>忽略參數類型絕對不相容的多載方法</html>
overloaded.methods.with.same.number.parameters.problem.descriptor=具有相同數量參數的多個方法命名 <code>#ref</code> #loc
overloaded.vararg.constructor.problem.descriptor=多載 vararg 建構函式 <code>#ref()</code> #loc
overloaded.vararg.method.display.name=多載 vararg 方法
overloaded.vararg.method.problem.descriptor=多載 vararg 方法 <code>#ref()</code> #loc
overloaded.vararg.method.problem.option=忽略參數類型絕對不相容的多載方法
overly.broad.throws.clause.display.name=過寬的 'throws' 子句
overly.broad.throws.clause.ignore.thrown.option=忽略隱藏其他異常但自身被拋出的異常(&H)
overly.broad.throws.clause.problem.descriptor1=<code>throws #ref</code> 過寬，遮罩異常 ''{0}'' #loc
overly.broad.throws.clause.problem.descriptor2=<code>throws #ref</code> 過寬，遮罩異常 ''{0}'' 和 ''{1}'' #loc
overly.broad.throws.clause.quickfix1=新增特定異常
overly.broad.throws.clause.quickfix2=取代為特定異常
overly.broad.throws.clause.threshold.option=要報告的最大隱藏異常數:
overly.complex.anonymous.inner.class.display.name=過度複雜的匿名類別
overly.complex.anonymous.inner.class.problem.descriptor=過度複雜的匿名類別 (迴圈復雜度 = {0}) #loc
overly.complex.arithmetic.expression.display.name=過於複雜的算術表達式
overly.complex.arithmetic.expression.max.number.option=最大項數:
overly.complex.arithmetic.expression.problem.descriptor=過於複雜的算術表達式 #loc
overly.complex.boolean.expression.display.name=過度複雜的布爾表達式
overly.complex.boolean.expression.ignore.option=忽略純合取和析取
overly.complex.boolean.expression.max.terms.option=最大項數:
overly.complex.boolean.expression.problem.descriptor=過度複雜的布爾表達式 ({0} 項) #loc
overly.complex.class.display.name=過度複雜的類別
overly.complex.class.problem.descriptor=過度複雜的類別<code>#ref</code> (迴圈復雜度 = {0}) #loc
overly.coupled.class.class.coupling.limit.option=類別耦合限制:
overly.coupled.class.display.name=過度耦合的類別
overly.coupled.class.problem.descriptor=<code>#ref</code> 過度耦合 (相依 = {0}) #loc
overly.long.lambda.display.name=過長的 lambda 表達式
overly.long.lambda.problem.descriptor=lambda 表達式過長 (# 非註釋源語句 = {0}) #loc
overly.strong.type.cast.display.name=過強的類型轉換
overly.strong.type.cast.ignore.in.matching.instanceof.option=忽略具有符合 instanceof 表達式的轉換
overly.strong.type.cast.problem.descriptor=到 <code>#ref</code> 的轉換可以被削弱為 ''{0}'' #loc
overly.strong.type.cast.weaken.quickfix=削弱過強的轉換
overridable.method.call.in.constructor.display.name=物件建構期間呼叫的可覆寫方法
overridable.method.call.in.constructor.problem.descriptor=物件建構期間呼叫可覆寫方法 <code>#ref()</code> #loc
overridden.method.call.in.constructor.display.name=覆寫的方法在物件建構期間呼叫
overridden.method.call.in.constructor.problem.descriptor=物件建構期間呼叫已覆寫方法 <code>#ref()</code> #loc
package.dot.html.may.be.package.info.convert.quickfix=轉換為 'package-info.java'
package.dot.html.may.be.package.info.delete.quickfix=刪除 'package.html'
package.dot.html.may.be.package.info.display.name='package.html' 可以轉換為 'package-info.java'
package.dot.html.may.be.package.info.exists.problem.descriptor=<code>package.html</code> 被忽略，因為 <code>package-info.java</code> 存在
package.dot.html.may.be.package.info.problem.descriptor=<code>package.html</code> 可以轉換為 <code>package-info.java</code>
package.in.multiple.modules.display.name=具有多個模組中的類別的軟體套件
package.in.multiple.modules.problem.descriptor.many=軟體套件 ''{0}'' 具有模組 ''{1}''、''{2}'' 以及其他 {3} 個模組中的類別
package.in.multiple.modules.problem.descriptor2=軟體套件 ''{0}'' 具有模組 ''{1}'' 和 ''{2}'' 中的類別
package.in.multiple.modules.problem.descriptor3=軟體套件 ''{0}'' 具有模組 ''{1}''、''{2}'' 和 ''{3}'' 中的類別
package.info.java.without.package.display.name=不帶 'package' 語句的 'package-info.java'
package.info.without.package.family.quickfix=新增 package 語句
package.info.without.package.problem.descriptor='package-info.java' 沒有 'package' 語句
package.info.without.package.quickfix=新增 ''package {0};''
package.local.field.not.accessible=package-private 欄位 ''{0}'' 無法從此處存取
package.local.private=package-private 與 private
package.naming.convention.display.name=軟體套件命名約定
package.naming.convention.problem.descriptor.long=軟體套件名稱 <code>{0}</code> 過長
package.naming.convention.problem.descriptor.regex.mismatch=軟體套件名稱 <code>{0}</code> 與正則表達式 ''{1}'' 不符合
package.naming.convention.problem.descriptor.short=軟體套件名稱 <code>{0}</code> 過短
package.visible.field.display.name=軟體套件可見欄位
package.visible.field.problem.descriptor=軟體套件可見欄位 <code>#ref</code> #loc
package.visible.inner.class.display.name=軟體套件可見的嵌套類別
package.visible.inner.class.ignore.enum.option=忽略軟體套件可見的內部枚舉
package.visible.inner.class.ignore.interface.option=忽略軟體套件可見的內部接口
package.visible.inner.class.problem.descriptor=軟體套件可見的嵌套類別 <code>#ref</code> #loc
package.with.too.few.classes.display.name=軟體套件具有過少類別
package.with.too.few.classes.min.option=最小類別數:
package.with.too.few.classes.problem.descriptor=軟體套件 ''{0}'' 包含過少的類別 ({1} < {2})
package.with.too.many.classes.display.name=類別過多的軟體套件
package.with.too.many.classes.max.option=最大類別數:
package.with.too.many.classes.problem.descriptor=軟體套件 ''{0}'' 包含過多的類別 ({1} > {2})
parameter.hides.member.variable.display.name=參數隱藏欄位
parameter.hides.member.variable.ignore.abstract.methods.option=對 abstract 方法忽略
parameter.hides.member.variable.ignore.constructors.option=對建構函式忽略
parameter.hides.member.variable.ignore.setters.option=對屬性 setter 忽略
parameter.hides.member.variable.ignore.static.parameters.option=對隱藏執行個體欄位的 static 方法參數忽略
parameter.hides.member.variable.ignore.superclass.option=忽略從子類別不可見的超類別欄位
parameter.hides.member.variable.problem.descriptor=參數 <code>#ref</code> 隱藏類別 ''{0}'' 中的欄位 #loc
parameter.limit.option=參數限制:
parameter.name.differs.from.overridden.parameter.display.name=參數名稱與覆寫或多載方法中的參數不同
parameter.name.differs.from.overridden.parameter.ignore.character.option=如果覆寫的參數僅包含一個字元，則忽略
parameter.name.differs.from.overridden.parameter.ignore.library.option=如果覆寫的參數來自庫，則忽略
parameter.name.differs.from.overridden.parameter.problem.descriptor=參數名 <code>#ref</code> 不同於{1, choice, 1#super 方法|2#多載方法|3#super 建構函式|4#多載建構函式}中的參數 ''{0}'' #loc
parameter.naming.convention.display.name=方法參數命名約定
parameter.naming.convention.element.description=參數
parameter.type.prevents.overriding.display.name=參數類型阻止覆寫
parameter.type.prevents.overriding.family.quickfix=更改參數類型
parameter.type.prevents.overriding.problem.descriptor=參數類型 <code>#ref</code> 位於 ''{0}''，而 super 方法參數類型位於 ''{1}''，可防止覆寫 #loc
parameter.type.prevents.overriding.quickfix=將參數類型更改為 ''{0}''
parameters.per.constructor.display.name=參數過多的建構函式
parameters.per.constructor.problem.descriptor=<code>#ref()</code> 的參數過多(參數數量 = {0}) #loc
parameters.per.method.display.name=參數過多的方法
parameters.per.method.problem.descriptor=<code>#ref()</code> 的參數過多(參數數量 = {0}) #loc
pattern.variable.hides.field.display.name=模式變數隱藏欄位
pattern.variable.hides.field.problem.descriptor=模式變數 <code>#ref</code> 隱藏類別 ''{0}'' 中的欄位 #loc
pointless.arithmetic.expression.display.name=無意義的算術表達式
pointless.bitwise.expression.display.name=無意義的按位表達式
pointless.bitwise.expression.simplify.quickfix=簡化
pointless.boolean.expression.display.name=無意義的布爾表達式
pointless.boolean.expression.ignore.option=在確定無意義表達式時忽略命名常數
pointless.indexof.comparison.always.false.problem.descriptor=<code>#ref</code> 始終為 false #loc
pointless.indexof.comparison.always.true.problem.descriptor=<code>#ref</code> 始終為 true #loc
pointless.indexof.comparison.display.name=無意義的 'indexOf()' 比較
pointless.nullcheck.display.name=方法呼叫前出現不必要的 'null' 檢查
pointless.nullcheck.problem.descriptor.call=''{0}()'' 呼叫之前的 ''null'' 檢查不必要
possible.throw.from.finally.block.problem.descriptor=<code>{0}</code> 可能在 ''finally'' 塊內拋出 #loc
prefer.empty.array.options.mode.always=始終
prefer.empty.array.options.mode.always.never=從不(首選預設大小的陣列)
prefer.empty.array.options.mode.by.level=根據語言級別
prefer.empty.array.options.title=首選空陣列:
prefix.operation.quickfix.family.name=取代為前綴運算符
press.escape.to.remove.highlighting.message=按 Esc 移除醒目提示
primitive.array.argument.to.var.arg.method.display.name=引起混淆的 vararg 方法基元陣列實參
primitive.array.argument.to.var.arg.method.problem.descriptor=引起混淆的 vararg 方法基元陣列實參 #loc
primitive.fields.ignore.option=忽略原始欄位
printstacktrace.call.display.name=呼叫 'printStackTrace()'
printstacktrace.call.problem.descriptor=對 <code>#ref()</code> 的呼叫可能應當取代為更可靠的日誌 #loc
private=private
private.field.not.accessible.problem.descriptor=''private'' 欄位 ''{0}'' 無法從此處存取
private.member.access.between.outer.and.inner.classes.display.name=合成存取器呼叫
private.member.access.between.outer.and.inner.classes.make.constructor.package.local.quickfix=將 ''{0}'' 建構函式設為 package-private
private.member.access.between.outer.and.inner.classes.make.local.quickfix=將 ''{0}'' 設為 package-private
private.member.access.between.outer.and.inner.classes.problem.descriptor=存取類別 ''{0}'' 的 ''private'' 成員需要合成存取器 #loc
problematic.varargs.method.display.name=非 vararg 方法覆寫 vararg 方法
problematic.varargs.method.override.problem.descriptor=非 vararg 方法 <code>#ref()</code> 覆寫 vararg 方法 #loc
progress.text.analyzing.package.0=正在分析軟體套件 {0}
properties.object.as.hashtable.display.name=將 'Properties' 物件用作 'Hashtable'
properties.object.as.hashtable.problem.descriptor=在屬性物件上呼叫 <code>Hashtable.#ref()</code> #loc
property.value.set.to.itself.display.name=屬性值設定為自身
protected.field.display.name=protected 欄位
protected.field.not.accessible.problem.descriptor=''protected'' 欄位 ''{0}'' 無法從此處存取
protected.field.problem.descriptor=protected 欄位 <code>#ref</code> #loc
protected.inner.class.display.name=protected 嵌套類別
protected.inner.class.ignore.enum.option=忽略 'protected' 內部枚舉
protected.inner.class.ignore.interface.option=忽略 'protected' 內部接口
protected.inner.class.problem.descriptor=protected 嵌套類別 <code>#ref</code> #loc
protected.member.in.final.class.display.name='protected' 成員位於 'final' 類別中
protected.member.in.final.class.problem.descriptor=類別成員在 'final' 類別中被宣告為 <code>#ref</code> #loc
protected.package.local.private=protected、package-private 和 private
public.constructor.display.name='public' 建構函式可被取代為工廠方法
public.constructor.in.non.public.class.display.name='public' 建構函式位於非 public 類別中
public.constructor.in.non.public.class.problem.descriptor=建構函式在非 public 類別 ''{0}'' 中被宣告為 <code>#ref</code> #loc
public.constructor.in.non.public.class.quickfix=將建構函式設為 private
public.constructor.problem.descriptor=public 建構函式 <code>#ref()</code> #loc
public.constructor.quickfix=將建構函式取代為工廠方法
public.default.constructor.problem.descriptor=類別 <code>#ref</code> 具有 'public' 預設建構函式
public.field.accessed.in.synchronized.context.display.name=在 'synchronized' 上下文中存取d了非 private 欄位
public.field.accessed.in.synchronized.context.problem.descriptor=在同步上下文中存取非 private 欄位 <code>#ref</code> #loc
public.field.display.name='public' 欄位
public.field.ignore.enum.type.fields.option=忽略枚舉類型的 'public final' 欄位
public.field.problem.descriptor='public' 欄位 <code>#ref</code> #loc
public.inner.class.display.name='public' 嵌套類別
public.inner.class.ignore.enum.option=忽略 'public' 內部枚舉
public.inner.class.ignore.interface.option=忽略 'public' 內部接口
public.inner.class.problem.descriptor='public' 嵌套類別 <code>#ref</code> #loc
public.method.not.in.interface.display.name='public' 方法在接口中未公開
public.method.not.in.interface.option=<html>如果包含類別未實作非庫接口，則忽略</html>
public.method.not.in.interface.problem.descriptor='public' 方法 <code>#ref()</code> 未通過接口公開 #loc
public.method.without.logging.display.name='public' 方法沒有日誌記錄
public.method.without.logging.problem.descriptor='public' 方法 <code>#ref()</code> 沒有日誌呼叫 #loc
public.static.array.field.display.name='public static' 陣列欄位
public.static.array.field.problem.descriptor='public static' 陣列欄位 <code>#ref</code>，影響安全性 #loc
public.static.collection.field.display.name='public static' 集合欄位
public.static.collection.field.problem.descriptor='public static' 集合欄位 <code>#ref</code>，影響安全性 #loc
qualify.call.fix.family.name=限定呼叫
query.column.name=查詢名稱開頭
query.label=查詢名稱開頭:
questionable.name.display.name=可疑名稱
questionable.name.list.label=報告的名稱:
questionable.name.problem.descriptor=可疑名稱 <code>#ref</code> #loc
random.double.for.random.integer.display.name=使用 'Random.nextDouble()' 獲取隨機整數
random.double.for.random.integer.problem.descriptor=使用 <code>Random.#ref</code> 建立隨機整數 #loc
raw.use.of.parameterized.type.display.name=參數化類別的原始使用
readobject.initialization.display.name=執行個體欄位可能無法被 'readObject()' 初始化
readobject.initialization.problem.descriptor=執行個體欄位 <code>#ref</code> 在 'readObject()' 呼叫期間可能無法初始化 #loc
readresolve.writereplace.protected.display.name='readResolve()' 或 'writeReplace()' 未被宣告為 'protected'
readresolve.writereplace.protected.problem.descriptor=<code>#ref()</code> 未被宣告為 'protected' #loc
readwriteobject.private.display.name='readObject()' 或 'writeObject()' 未被宣告為 'private'
readwriteobject.private.problem.descriptor=<code>#ref</code> 未被宣告為 'private' #loc
recordstore.opened.not.safely.closed.display.name=開啟了 'RecordStore'，但未安全關閉
redundant.as.list.for.iteration.fix.name=解包
redundant.as.list.for.iteration.problem=不必要的 'Arrays.asList()' 呼叫
redundant.call.problem.descriptor=冗餘呼叫 <code>#ref()</code> #loc
redundant.else.display.name=冗餘的 'else'
redundant.else.problem.descriptor=<code>#ref</code> 分支可以解包，因為 'if' 分支永遠不會正常完成 #loc
redundant.else.unwrap.quickfix=移除冗餘的 'else'
redundant.escape.in.regex.replacement.display.name=正則表達式取代字串中的冗餘轉義
redundant.escape.in.regex.replacement.problem.descriptor=''{0}'' 的冗餘轉義
redundant.escape.in.regex.replacement.quickfix=移除冗餘轉義
redundant.explicit.var.type.display.name=可以省略區域變數類型
redundant.field.initialization.display.name=冗餘欄位初始化
redundant.field.initialization.problem.descriptor=<code>#ref</code> 的欄位初始化是冗餘的 #loc
redundant.field.initialization.remove.quickfix=移除初始設定式
redundant.implements.display.name=冗餘接口宣告
redundant.implements.problem.descriptor=冗餘接口宣告 <code>#ref</code> #loc
redundant.implements.remove.quickfix=移除冗餘接口宣告
redundant.local.variable.annotation.option=忽略具有註解的變數
redundant.local.variable.display.name=冗餘區域變數
redundant.local.variable.ignore.option=忽略立即返回或拋出的變數
redundant.method.override.delegate.quickfix=將方法取代為到 super 的委託
redundant.method.override.delegates.to.super.problem.descriptor=方法 <code>#ref()</code> 僅委託給 super 方法 #loc
redundant.method.override.display.name=方法與其 super 方法相同
redundant.method.override.option.check.library.methods=檢查覆寫庫方法的方法
redundant.method.override.option.ignore.delegates=忽略到 super 方法的委託
redundant.method.override.problem.descriptor=方法 <code>#ref()</code> 與其 super 方法相同 #loc
redundant.method.override.quickfix=移除冗餘方法
redundant.string.format.call.display.name=冗餘呼叫 'String.format()'
redundant.string.format.call.quickfix=移除對 'String.format()' 的冗餘呼叫
redundant.string.formatted.call.quickfix=移除對 'String.formatted()' 的冗餘呼叫
referencing.subclass.0.from.superclass.1.initializer.might.lead.to.class.loading.deadlock=從超類別 {1} 初始設定式參照子類別 {0} 可能會導致類別載入死鎖
reflection.for.unavailable.annotation.display.name=對僅源註解的反射存取
reflection.for.unavailable.annotation.problem.descriptor=註解 '#ref' 不保留用於反射存取 #loc
refused.bequest.display.name=方法不呼叫 super 方法
refused.bequest.fix.family.name=將呼叫插入 super 方法
refused.bequest.ignore.default.super.methods.option=忽略 'default' super 方法
refused.bequest.ignore.empty.super.methods.option=忽略空 super 方法
refused.bequest.problem.descriptor=方法 <code>#ref()</code> 未呼叫 'super.#ref()' #loc
remove.annotation.parameter.0.fix.name=移除註解參數 ''{0}''
remove.call.fix.family.name=移除呼叫
remove.cloneable.quickfix=從 'implements' 子句中移除 'Cloneable'
remove.finally.block.quickfix=移除 'finally' 塊
remove.leading.zero.to.make.decimal.quickfix=移除前導零以變為十進制
remove.leading.zeroes.to.make.decimals.quickfix=移除前導零以變為十進制
remove.loop.fix.family.name=移除迴圈
remove.modifier.fix.family.name=移除修飾符
remove.modifier.quickfix=移除 ''{0}'' 修飾符
remove.redundant.polyadic.operand.fix.family.name=移除不必要的條件
remove.redundant.polyadic.operand.fix.name=移除不必要的 ''{0}'' 條件
remove.redundant.string.fix.text=使用 ''{0}()'' 並移除冗餘的 ''{1}()'' 呼叫
remove.redundant.substring.fix.family.name=移除冗餘的 'substring()' 呼叫
remove.suppress.comment.fix.family.name=移除 //{0}
remove.try.finally.block.quickfix=移除 'try-finally' 塊
rename.catch.parameter.to.ignored=將 ''catch'' 參數重命名為 ''{0}''
rename.quickfix=重新命名
renameto.quickfix=重命名為 ''{0}''
replace.all.dot.display.name=可疑的正則表達式實參
replace.all.dot.problem.descriptor=''{0}()'' 呼叫中存在可疑的正則表達式 #ref #loc
replace.all.dot.quickfix=轉義正則表達式元字元
replace.all.file.separator.problem.descriptor=File.separator 用作正則表達式；無法在 Windows 上工作
replace.anonymous.with.lambda.body.fix.family.name=將呼叫取代為方法體
replace.cast.fix.family.name=取代轉換類型
replace.casted.literal.with.just.literal.fix.family.name=取代為 {0} 文字
replace.field.reference.fix.family.name=取代欄位參照
replace.field.reference.fix.text=將欄位參照取代為 ''{0}''
replace.inheritance.with.delegation.quickfix=將繼承取代為委託
replace.instanceof.fix.family.name=取代 instanceOf 類型
replace.method.call.fix.family.name=取代方法呼叫
replace.method.call.fix.text=將方法呼叫取代為 ''{0}''
replace.method.ref.with.qualifier.fix.family.name=取代為限定符
replace.method.ref.with.qualifier.problem.lambda=lambda 可被取代為呼叫限定符
replace.method.ref.with.qualifier.problem.method=方法參照可被取代為限定符
replace.with.cast.fix.family.name=取代為轉換
replace.with.catch.clause.for.runtime.exception.quickfix=針對 'RuntimeException' 取代為 'catch' 子句
replace.with.comparator.fix.family.name=使用 'Comparator' static 方法簡化比較器
replace.with.lambda.body.fix.family.name=將 lambda 上的方法呼叫取代為 lambda 體
replace.with.method.ref.fix.family.name=將 lambda 取代為方法參照
replace.with.method.ref.fix.name.may.change.semantics=將 lambda 取代為方法參照(可能更改語意)
replace.with.method.reference.fix.family.name=將方法參照上的方法呼叫取代為相應的方法呼叫
replace.with.var.fix.family.name=將顯式類型取代為 'var'
resource.opened.not.closed.problem.descriptor=''{0}'' 應在 ''try'' 塊之前開啟，並在相應的 ''finally'' 塊中關閉 #loc
result.of.method.call.ignored.class.column.title=類別名
result.of.method.call.ignored.display.name=方法呼叫的結果已忽略
result.of.method.call.ignored.method.column.title=方法名稱正則表達式
result.of.method.call.ignored.non.library.option=報告所有忽略的非庫呼叫
result.of.method.call.ignored.problem.descriptor=<code>{0}.#ref()</code> 的結果已忽略 #loc
result.of.object.allocation.fix.name=忽略類型 ''{0}'' 的物件的分配
result.of.object.allocation.ignored.display.name=物件分配的結果已忽略
result.of.object.allocation.ignored.options.chooserTitle=選擇可以忽略物件分配的類別
result.of.object.allocation.ignored.problem.descriptor=<code>new #ref()</code> 的結果已忽略 #loc
return.from.finally.block.display.name='return' 位於 'finally' 塊內
return.from.finally.block.problem.descriptor='return' 位於 'finally' 塊內 #loc
return.of.anonymous.class.problem.descriptor=返回匿名類別的執行個體 #loc
return.of.collection.field.fix.family.name=使返回集合 'unmodifiable'
return.of.field.with.mutable.type.problem.descriptor=返回 {0} 欄位 <code>{1}</code> #loc
return.of.inner.class.display.name=返回匿名、區域或內部類別的執行個體
return.of.inner.class.ignore.non.public.option=忽略非 public 方法的返回值
return.of.inner.class.problem.descriptor=返回非 static 內部類別 <code>{0}</code> 的執行個體 #loc
return.of.local.class.problem.descriptor=返回區域類別 <code>{0}</code> 的執行個體 #loc
return.of.null.arrays.option=報告返回陣列的方法
return.of.null.collections.option=報告返回集合物件的方法
return.of.null.display.name=返回 'null'
return.of.null.ignore.private.option=忽略 'private' 方法、匿名類別和 lambda
return.of.null.objects.option=報告返回物件的方法
return.of.null.problem.descriptor=返回 <code>#ref</code> #loc
return.point.limit.option=返回點限制(&R):
return.this.display.name=返回 'this'
return.this.problem.descriptor=返回 <code>#ref</code> #loc
reuse.of.local.variable.display.name=區域變數的重用
reuse.of.local.variable.problem.descriptor=區域變數 <code>#ref</code> 的重用 #loc
reuse.of.local.variable.split.quickfix=拆分區域變數
runtime.exec.call.display.name=呼叫 'Runtime.exec()'
runtime.exec.call.problem.descriptor=對 <code>Runtime.#ref()</code> 的呼叫不可移植 #loc
runtime.exec.with.non.constant.string.display.name='Runtime.exec()' 呼叫具有非常數字串
runtime.exec.with.non.constant.string.problem.descriptor=<code>Runtime.#ref()</code> 呼叫具有非常數實參 #loc
safe.lock.display.name=已獲取但未安全解鎖的鎖
safe.lock.problem.descriptor=''{0}'' 應在 ''try'' 塊之前鎖定，並在相應的 ''finally'' 塊中解鎖 #loc
serial.annotation.used.on.wrong.member.display.name=對錯誤的成員使用了 '@Serial' 註解
serial.annotation.used.on.wrong.member.problem.descriptor=註解的成員不是序列化機制的一部分
serializable.anonymous.class.stores.non.serializable.problem.descriptor=可序列化匿名類別隱式存儲類型為 ''{0}'' 的不可序列化物件
serializable.class.in.secure.context.display.name=安全上下文中的可序列化類別
serializable.class.in.secure.context.problem.descriptor=類別 <code>#ref</code> 可能被序列化，影響安全性 #loc
serializable.deserializable.class.in.secure.context.problem.descriptor=類別 <code>#ref</code> 可能被序列化和反序列化，影響安全性 #loc
serializable.has.serialization.methods.display.name=不帶 'readObject()' 和 'writeObject()' 的可序列化類別
serializable.has.serialization.methods.ignore.option=忽略未定義執行個體欄位的類別
serializable.has.serialization.methods.problem.descriptor=可序列化類別 <code>#ref</code> 未定義 'readObject()' 或 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor1=可序列化類別 <code>#ref</code> 未定義 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor2=可序列化類別 <code>#ref</code> 未定義 'readObject()' #loc
serializable.inner.class.has.serial.version.uid.field.display.name=沒有 'serialVersionUID' 的可序列化非 static 內部類別
serializable.inner.class.has.serial.version.uid.field.problem.descriptor=內部類別 <code>#ref</code> 未定義 'serialVersionUID' 欄位 #loc
serializable.inner.class.with.non.serializable.outer.class.display.name=可序列化非 'static' 內部類別具有不可序列化外部類
serializable.inner.class.with.non.serializable.outer.class.problem.descriptor=內部類別 <code>#ref</code> 可序列化，而其外部類別不可序列化 #loc
serializable.lambda.stores.non.serializable.problem.descriptor=可序列化 lambda 隱式存儲類型為 ''{0}'' 的不可序列化物件
serializable.local.class.stores.non.serializable.problem.descriptor=可序列化區域類別 ''{1}'' 隱式存儲類型為 ''{0}'' 的不可序列化物件
serializable.record.contains.ignored.field.problem.descriptor=在記錄序列化期間將忽略 <code>#ref</code>
serializable.record.contains.ignored.members.display.name='record' 包含被忽略的成員
serializable.record.contains.ignored.method.problem.descriptor=在記錄序列化期間將忽略 <code>#ref()</code>
serializable.stores.non.serializable.display.name='Serializable' 物件隱式存儲非 'Serializable' 物件
serializable.with.unconstructable.ancestor.display.name=具有不可建構上級的可序列化類別
serializable.with.unconstructable.ancestor.problem.descriptor=<code>#ref</code> 具有不帶無實參建構函式的不可序列化上級 ''{0}'' #loc
serialpersistentfields.with.wrong.signature.display.name='serialPersistentFields' 欄位未被宣告為 'private static final ObjectStreamField[]'
serialpersistentfields.with.wrong.signature.problem.descriptor=可序列化類別的 <code>#ref</code> 欄位未被宣告為 'private static final ObjectStreamField[]' #loc
serialversionuid.private.static.final.long.display.name='serialVersionUID' 欄位未被宣告為 'private static final long'
serialversionuid.private.static.final.long.problem.descriptor=可序列化類別的 <code>#ref</code> 欄位未被宣告為 'private static final long' #loc
serialversionuid.private.static.final.long.quickfix=將 serialVersionUID 設為 'private static final'
set.annotation.parameter.0.1.fix.name=將註解參數 {0} 設定為“{1}”
set.replaceable.by.enum.set.display.name='Set' 可被取代為 'EnumSet'
set.replaceable.by.enum.set.problem.descriptor=<code>#ref</code> 可被取代為 'EnumSet' #loc
shared.thread.local.random.display.name='ThreadLocalRandom' 執行個體可能是共享的
shared.thread.local.random.problem.descriptor='ThreadLocalRandom' 執行個體可能線上程之間共享
shift.operation.by.inappropriate.constant.display.name=按不當常數進行移位運算
shift.operation.by.inappropriate.constant.problem.descriptor.negative=對 <code>#ref</code> 進行移位運算時使用的常量值 {0} 為負 #loc
shift.operation.by.inappropriate.constant.problem.descriptor.out.of.bounds=按超出範圍的值 {0} 進行移位運算 <code>#ref</code> #loc
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=對 <code>#ref</code> 進行移位運算時使用的常量值 {0} 過大 #loc
shift.out.of.range.fix.family.name=修復移位值
side.effects.method.ref.to.lambda.fix.family.name={0} (副作用)
signal.without.corresponding.await.display.name=沒有相應 'await()' 的 'signal()'
signal.without.corresponding.await.problem.descriptor=在沒有相應 <code>await()</code> 的情況下呼叫 <code>#ref()</code> #loc
simplifiable.annotation.braces.problem.descriptor=註解中 <code>{0}</code> 周圍不必要的圓括號 #loc
simplifiable.annotation.display.name=可簡化註解
simplifiable.annotation.problem.descriptor=註解中有不必要的 <code>#ref</code> #loc
simplifiable.annotation.quickfix=簡化註解
simplifiable.annotation.whitespace.problem.descriptor=註解中有不必要的空格 #loc
simplifiable.boolean.expression.display.name=可簡化的布爾表達式
simplifiable.conditional.expression.display.name=可簡化的條件表達式
simplifiable.conditional.expression.problem.descriptor=<code>{1}</code> 可以簡化為 ''{0}'' #loc
simplifiable.equals.expression.display.name='equals()' 呼叫之前的 'null' 檢查不必要
simplifiable.equals.expression.option.non.constant=報告具有非常數非 null 實參的等於
simplifiable.equals.expression.problem.descriptor=''{0}()'' 呼叫之前的 ''null'' 檢查不必要 #loc
simplifiable.equals.expression.quickfix=翻轉 ''.{0}()'' 並移除不必要的 ''null'' 檢查
simplifiable.junit.assertion.display.name=可簡化斷言
simplifiable.junit.assertion.problem.descriptor=<code>#ref()</code> 可以簡化為 ''{0}'' #loc
simplify.junit.assertion.simplify.quickfix=簡化斷言
single.character.startswith.display.name=單個字元 'startsWith()' 或 'endsWith()'
single.character.startswith.problem.descriptor=單個字元 <code>#ref()</code> 可被取代為 'charAt()' 表達式 #loc
single.character.startswith.quickfix=取代為 'charAt()' 表達式
single.class.import.display.name=單個類別匯入
single.class.import.problem.descriptor=單個類別匯入 <code>#ref</code> #loc
single.element.annotation.family.quickfix=將註解擴展為標準形式
single.element.annotation.name=非規范化註解
single.element.annotation.quickfix=新增 'value='
single.statement.in.block.descriptor=''{0}'' 包含單條語句
single.statement.in.block.family.quickfix=從語句中移除大括號
single.statement.in.block.name=程式碼塊包含單條語句
single.statement.in.block.quickfix=從 ''{0}'' 語句中移除大括號
singleton.display.name=單例
singleton.problem.descriptor=類別 <code>#ref</code> 為單例 #loc
size.replaceable.by.isempty.display.name='size() == 0' 可被取代為 'isEmpty()'
size.replaceable.by.isempty.fix.ignore.calls=忽略類型 ''{1}'' 上的 ''.{0}()'' 呼叫
size.replaceable.by.isempty.negation.ignore.option=忽略將取代為 '!isEmpty()' 的表達式
sleep.while.holding.lock.display.name=同步時呼叫 'Thread.sleep()'
sleep.while.holding.lock.problem.descriptor=同步時呼叫 <code>Thread.#ref()</code> #loc
smth.unnecessary.remove.quickfix=移除不必要的 ''{0}''
socket.opened.not.closed.display.name=套接字已開啟，但未安全關閉
standard.variable.names.display.name=標準變數名稱
standard.variable.names.ignore.override.option=對與 super 方法參數相同的參數名稱忽略
standard.variable.names.problem.descriptor=變數命名 <code>#ref</code> 沒有類型 ''{0}'' #loc
standard.variable.names.problem.descriptor2=變數命名 <code>#ref</code> 沒有類型 ''{0}'' 或 ''{1}'' #loc
statement.problem.descriptor=<code>#ref</code> 語句 #loc
statement.with.empty.body.display.name=帶空體的語句
statement.with.empty.body.include.option=包含空程式碼塊語句正文
statement.with.empty.body.problem.descriptor=<code>#ref</code> 語句具有空體 #loc
static.collection.display.name=靜態集合
static.collection.ignore.option=忽略弱靜態集合或映射
static.collection.problem.descriptor=靜態集合 <code>#ref</code> #loc
static.field.via.subclass.display.name=static 欄位通過子類別參照
static.field.via.subclass.problem.descriptor=static 欄位 <code>#ref</code> 在類別 ''{0}'' 中宣告，但通過子類別 ''{1}'' 參照 #loc
static.field.via.subclass.rationalize.quickfix=使 static 欄位存取合理化
static.import.display.name=靜態匯入
static.import.fix.ignore.class=允許類別 ''{0}'' 的靜態匯入
static.import.options.border.title=靜態可匯入類別:
static.import.options.chooserTitle=選擇靜態可匯入類別
static.import.problem.descriptor=靜態匯入 <code>#ref</code>  #loc
static.import.replace.quickfix=取代為非靜態匯入
static.inheritance.display.name=靜態繼承
static.inheritance.fix.family.name=將繼承取代為限定參照
static.inheritance.problem.descriptor=接口 <code>#ref</code> 僅針對其 static 常數實作 #loc
static.inheritance.replace.quickfix=將繼承取代為 {0} 中的限定參照
static.initializer.references.subclass.display.name=static 初始設定式參照子類別
static.method.naming.convention.element.description='static' 方法
static.method.only.used.in.one.anonymous.class.problem.descriptor=static {0, choice, 1#方法|2#欄位} <code>#ref{0, choice, 1#()|2#}</code> 僅在派生自 ''{1}'' 的匿名類別中使用 #loc
static.method.only.used.in.one.class.display.name=static 成員僅在其他一個類別中使用
static.method.only.used.in.one.class.ignore.anonymous.option=僅在匿名類別中使用時忽略
static.method.only.used.in.one.class.ignore.on.conflicts=當方法無法在不產生衝突的情況下移動時忽略
static.method.only.used.in.one.class.ignore.test.option=僅在測試類別中使用時忽略
static.method.only.used.in.one.class.ignore.utility.classes=忽略位於實用程序類別中的成員
static.method.only.used.in.one.class.problem.descriptor=static {0, choice, 1#方法|2#欄位} <code>#ref{0, choice, 1#()|2#}</code> 僅在 ''{1}'' 類別中使用 #loc
static.method.only.used.in.one.class.quickfix=將 {0} 移至使用類別
static.method.only.used.in.one.class.quickfix.preview=將 static 成員移至使用它的類別。
static.method.via.subclass.display.name=static 方法通過子類別參照
static.method.via.subclass.problem.descriptor=static 方法 <code>#ref()</code> 在類別 ''{0}'' 中宣告，但通過子類別 ''{1}'' 參照 #loc
static.method.via.subclass.rationalize.quickfix=使 static 方法呼叫合理化
static.non.final.field.display.name='static' 非 'final' 欄位
static.non.final.field.option=僅報告 'public' 欄位
static.non.final.field.problem.descriptor='static' 非 'final' 欄位 <code>#ref</code> #loc
static.variable.may.not.be.initialized.display.name=static 欄位可能無法初始化
static.variable.may.not.be.initialized.problem.descriptor=static 欄位 <code>#ref</code> 在類別初始化期間可能無法初始化 #loc
static.variable.naming.convention.element.description='static' 欄位
static.variable.of.concrete.class.problem.descriptor=具體類別 <code>#ref</code> 的 static 欄位 ''{0}'' #loc
static.variable.used.before.initialization.display.name=static 欄位在初始化前使用
static.variable.used.before.initialization.problem.descriptor=static 欄位 <code>#ref</code> 在初始化前使用 #loc
string.buffer.must.have.initial.capacity.display.name=沒有初始容量的 'StringBuilder'
string.buffer.must.have.initial.capacity.problem.descriptor=沒有初始容量的 <code>new #ref()</code> #loc
string.buffer.replaceable.by.string.builder.display.name='StringBuffer' 可能是 'StringBuilder'
string.buffer.replaceable.by.string.builder.problem.descriptor=<code>StringBuffer #ref</code> 可能被宣告為 'StringBuilder' #loc
string.buffer.replaceable.by.string.display.name='StringBuilder' 可被取代為 'String'
string.buffer.replaceable.by.string.problem.descriptor=<code>{0} #ref</code> 可被取代為 ''String'' #loc
string.buffer.to.string.in.concatenation.display.name=連線中的 'StringBuilder.toString()'
string.buffer.to.string.in.concatenation.problem.descriptor=在串聯中呼叫 <code>{0}.#ref()</code> #loc
string.comparison.display.name=使用 '==' 而不是 'equals()' 進行字串比較
string.comparison.problem.descriptor=使用 <code>#ref</code> 而不是 'equals()' 來比較字串值 #loc
string.concatenation.argument.to.log.call.display.name=非常數字串串聯作為日誌呼叫的實參
string.concatenation.argument.to.log.call.problem.descriptor=非常數字串串聯作為 <code>#ref()</code> 日誌呼叫的實參 #loc
string.concatenation.argument.to.log.call.quickfix=將串聯取代為參數化的日誌訊息
string.concatenation.display.name=字串串聯
string.concatenation.in.format.call.display.name=字串串聯作為 'format()' 呼叫的實參
string.concatenation.in.format.call.fix.family.name=將串聯取代為實參
string.concatenation.in.format.call.problem.descriptor=''{0}()'' 呼叫包含字串串聯實參
string.concatenation.in.format.call.quickfix=將串聯取代為單獨的實參
string.concatenation.in.loops.display.name=字串串聯在迴圈中
string.concatenation.in.loops.problem.descriptor=迴圈中的字串串聯 <code>#ref</code> #loc
string.concatenation.in.message.format.call.display.name=字串串聯作為 'MessageFormat.format()' 呼叫的實參
string.concatenation.in.message.format.call.problem.descriptor=字串串聯作為 'MessageFormat.format()' 呼叫的實參 #loc
string.concatenation.inside.string.buffer.append.display.name=字串串聯作為 'StringBuilder.append()' 呼叫的實參
string.concatenation.inside.string.buffer.append.problem.descriptor=字串串聯作為 <code>{0}.#ref()</code> 呼叫的實參 #loc
string.concatenation.inside.string.buffer.append.replace.quickfix=取代為鏈式 'append()' 呼叫
string.concatenation.introduce.fix=引入 StringBuilder
string.concatenation.introduce.fix.name=引入新的 {1} 以更新變數 ''{0}''
string.concatenation.introduce.fix.name.null.safe=引入新的 {1} 以更新變數 ''{0}'' (null 安全)
string.concatenation.missing.whitespace.display.name=字串串聯中可能缺少空格
string.concatenation.missing.whitespace.option=忽略具有變量字串的串聯
string.concatenation.missing.whitespace.problem.descriptor=字串串聯中可能缺少空格 #loc
string.concatenation.problem.descriptor=國際化上下文中的字串串聯 <code>#ref</code> #loc
string.concatenation.replace.fix=取代為 StringBuilder
string.concatenation.replace.fix.name=將變數 ''{0}'' 從字串轉換為 {1}
string.concatenation.replace.fix.name.null.safe=將變數 ''{0}'' 從字串轉換為 {1} (null 安全)
string.equals.char.sequence.display.name=使用 'CharSequence' 實參呼叫了 'String.equals()'
string.equals.char.sequence.problem.descriptor=使用 ''{0}'' 實參呼叫了 <code>String.equals()</code> #loc
string.equals.empty.string.display.name='String.equals()' 可被取代為 'String.isEmpty()'
string.equals.empty.string.fix.family.name=簡化空字串檢查
string.equals.empty.string.is.empty.problem.descriptor=<code>#ref("")</code> 可被取代為 'isEmpty()' #loc
string.equals.empty.string.option.do.not.add.null.check=當有必要進行 null 檢查時，不必報告
string.equals.empty.string.problem.descriptor=<code>#ref("")</code> 可被取代為 'length()==0' #loc
string.format.choose.class=選擇格式化程序類別
string.format.class.label=附加格式化程序類別:
string.format.class.method.label=附加格式化程序方法:
string.indexof.replaceable.by.contains.display.name='String.indexOf()' 表達式可被取代為 'contains()'
string.replace.quickfix=移除空字串動作數
string.replaceable.by.string.buffer.display.name=非常數 'String' 可被取代為 'StringBuilder'
string.replaceable.by.string.buffer.in.loop.option=僅在迴圈中追加時發出警告
string.replaceable.by.string.buffer.problem.descriptor=非常數字串 <code>#ref</code> 可能應被宣告為 'StringBuilder' #loc
string.touppercase.tolowercase.without.locale.display.name=呼叫無區域設定的 'String.toUpperCase()' 或 'toLowerCase()'
string.touppercase.tolowercase.without.locale.problem.descriptor=在未使用國際化字串指定區域設定的情況下呼叫 <code>String.#ref()</code> #loc
stringbuffer.field.display.name='StringBuilder' 欄位
stringbuffer.field.problem.descriptor=''{0}'' 欄位 <code>#ref</code> #loc
subtraction.in.compareto.display.name='compareTo()' 中的減法
subtraction.in.compareto.problem.descriptor='compareTo()' 中的減法 <code>#ref</code> 可能導致溢出或精度損失 #loc
super.class.logger.option=在超類別有可存取的記錄器時忽略
suppress.for.tests.scope.quickfix=對 'Tests' 作用域禁止
suspicious.array.cast.display.name=可疑的陣列轉換
suspicious.array.cast.problem.descriptor=可疑轉換為 <code>#ref</code> #loc
suspicious.comparator.compare.descriptor.min.value=Returning Integer.MIN_VALUE from a comparison function is discouraged
suspicious.comparator.compare.descriptor.non.negative=Comparator never returns negative values
suspicious.comparator.compare.descriptor.non.positive=Comparator never returns positive values
suspicious.comparator.compare.descriptor.non.reflexive=對於相等的元素，比較器不返回 0
suspicious.comparator.compare.descriptor.parameter.not.used=未使用 ''{0}()'' 參數 <code>#ref</code> #loc
suspicious.comparator.compare.display.name=可疑的 'Comparator.compare()' 實作
suspicious.getter.problem.descriptor=getter <code>#ref()</code> 返回欄位 ''{0}'' #loc
suspicious.getter.setter.display.name=可疑的 getter/setter
suspicious.indent.after.control.statement.display.name=沒有大括號的控制語句後存在可疑縮排
suspicious.indent.after.control.statement.problem.descriptor=''{0}'' 語句後存在可疑縮排 #loc
suspicious.integer.div.assignment.display.name=可疑的整數除法指派
suspicious.integer.div.assignment.problem.descriptor=除法結果被截斷為整數
suspicious.integer.div.assignment.quickfix=轉換為 double
suspicious.literal.underscore.display.name=數字文字中的可疑下劃線
suspicious.literal.underscore.problem.descriptor=帶下劃線的數字文字中的組沒有長度 3 #loc
suspicious.package.private.access.display.name=可疑的 package-private 存取權限
suspicious.setter.problem.descriptor=setter <code>#ref()</code> 對欄位 ''{0}'' 指派 #loc
suspicious.system.arraycopy.display.name=可疑的 'System.arraycopy()' 呼叫
suspicious.system.arraycopy.problem.descriptor.length.bigger.dest=長度始終大於 ''dest.length - destPos'' {0}
suspicious.system.arraycopy.problem.descriptor.length.bigger.src=長度始終大於 ''src.length - srcPos'' {0}
suspicious.system.arraycopy.problem.descriptor.ranges.intersect=複製到具有相交範圍的同一陣列
suspicious.system.arraycopy.problem.descriptor4=<code>#ref</code> 不是陣列類型 #loc
suspicious.system.arraycopy.problem.descriptor5=<code>#ref</code> 不是陣列類型 #loc
suspicious.system.arraycopy.problem.descriptor6=源參數類型 ''{0}'' 不可分配給類型為 ''{1}'' 的目標參數 <code>#ref</code> #loc
suspicious.to.array.call.display.name=可疑的 'Collection.toArray()' 呼叫
suspicious.to.array.call.fix.family.name=取代為正確陣列
suspicious.to.array.call.problem.descriptor=應為類型 ''{0}[]'' 的陣列，找到的是 ''{1}[]'' #loc
swap.equals.fix.family.name=翻轉方法呼叫
switch.expression.with.single.default.message='switch' 表達式只有 'default' case
switch.expression.with.too.few.branches.problem.descriptor=''switch'' 表達式的 case 標籤太少 ({0})，並且可能應當取代為 ''if'' 語句或條件運算符 #loc
switch.statement.density.display.name='switch' 語句的分支密度過低
switch.statement.density.min.option=分支的最小密度: %
switch.statement.density.problem.descriptor=<code>#ref</code> 的分支密度過低 ({0}%) #loc
switch.statement.display.name='switch' 語句
switch.statement.with.confusing.declaration.display.name=在不同 'switch' 分支中使用並宣告的區域變數
switch.statement.with.confusing.declaration.problem.descriptor=區域變數 <code>#ref</code> 在一個 'switch' 分支中宣告，並在另一個分支中使用 #loc
switch.statement.with.single.default.message='switch' 語句只有 'default' case
switch.statement.with.too.few.branches.display.name=最小 'switch' 分支
switch.statement.with.too.few.branches.ignore.pattern.option=不報告模式 switch 語句
switch.statement.with.too.few.branches.min.option=最小分支數:
switch.statement.with.too.few.branches.problem.descriptor=''switch'' 語句的 case 標籤太少({0})，並且可能應當取代為 ''if'' 語句 #loc
switch.statement.with.too.many.branches.display.name=最大 'switch' 分支
switch.statement.without.default.ignore.option=忽略詳盡的 switch 語句
switch.statements.without.default.display.name=不帶 'default' 分支的 'switch' 語句
switch.statements.without.default.problem.descriptor=沒有 'default' 分支的 <code>#ref</code> 語句 #loc
synchronization.on.get.class.display.name=在 'getClass()' 上同步
synchronization.on.get.class.problem.descriptor=在 <code>#ref()</code> 上同步 #loc
synchronization.on.local.variable.or.method.parameter.display.name=在區域變數或方法參數上同步
synchronization.on.local.variable.problem.descriptor=在區域變數 <code>#ref</code> 上同步 #loc
synchronization.on.method.parameter.problem.descriptor=在方法參數 <code>#ref</code> 上同步 #loc
synchronization.on.static.field.display.name=在 'static' 欄位上同步
synchronization.on.static.field.problem.descriptor=在 'static' 欄位 <code>#ref</code> 上同步 #loc
synchronize.on.class.problem.descriptor=對類別的鎖定動作可能會產生不可預見的副作用 #loc
synchronize.on.lock.display.name=在 'Lock' 物件上同步
synchronize.on.lock.problem.descriptor=在 ''{0}'' 物件上同步不太可能是故意的 #loc
synchronize.on.non.final.field.display.name=在非 final 欄位上同步
synchronize.on.non.final.field.problem.descriptor=在非 final 欄位 <code>#ref</code> 上同步 #loc
synchronize.on.this.display.name=在 'this' 上同步
synchronize.on.this.problem.descriptor=對 'this' 的鎖定動作可能會產生不可預見的副作用 #loc
synchronized.method.display.name='synchronized' 方法
synchronized.method.ignore.synchronized.super.option=忽略覆寫 synchronized 方法的方法
synchronized.method.include.option=包含本地方法
synchronized.method.move.quickfix=將同步移至方法中
synchronized.method.problem.descriptor=方法 ''{0}()'' 被宣告為 <code>#ref</code> #loc
synchronized.on.direct.literal.object.problem.descriptor=在 {0} 文字 <code>#ref</code> 上同步 #loc
synchronized.on.literal.object.name=在使用文字初始化的物件上同步
synchronized.on.literal.object.problem.descriptor=在使用文字初始化的 {0} <code>#ref</code> 上同步 #loc
synchronized.on.literal.object.warn.on.all.option=警告所有可能的文字
synchronized.on.possibly.literal.object.problem.descriptor=在 {0} <code>#ref</code> 上同步 #loc
system.exit.call.display.name=呼叫 'System.exit()' 或相關方法
system.exit.call.ignore.option=在 main 方法中忽略
system.exit.call.problem.descriptor=對 <code>{0}.#ref()</code> 的呼叫不可移植 #loc
system.getenv.call.display.name=呼叫 'System.getenv()'
system.getenv.call.problem.descriptor=對 <code>System.#ref()</code> 的呼叫不可移植 #loc
system.properties.display.name=系統屬性的存取
system.properties.problem.descriptor=對 <code>Integer.#ref()</code> 的呼叫可能造成安全問題 #loc
system.properties.problem.descriptor1=對 <code>Boolean.#ref()</code> 的呼叫可能造成安全問題 #loc
system.run.finalizers.on.exit.display.name=呼叫 'System.runFinalizersOnExit()'
system.run.finalizers.on.exit.problem.descriptor=呼叫 <code>System.#ref()</code> #loc
system.set.problem.descriptor=對 <code>System.#ref()</code> 的呼叫可能造成安全問題 #loc
system.set.security.manager.display.name=呼叫 'System.setSecurityManager()'
system.set.security.manager.problem.descriptor=對 <code>System.#ref()</code> 的呼叫可能造成安全問題 #loc
tail.recursion.display.name=尾遞迴
tail.recursion.problem.descriptor=尾部遞迴呼叫 <code>#ref()</code> #loc
tail.recursion.replace.quickfix=用迭代替換尾部遞迴
test.case.with.no.test.methods.display.name=沒有測試的測試類別
test.case.with.no.test.methods.option=忽略具有帶測試方法的超類別的測試用例
test.case.with.no.test.methods.problem.descriptor=測試類別 <code>#ref</code> 沒有測試 #loc
text.label.in.switch.statement.display.name='switch' 語句中的文本標籤
text.label.in.switch.statement.problem.descriptor='switch' {0, choice, 1#語句|2#表達式}中存在文本標籤 <code>#ref:</code> #loc
the.whole.project=整個專案
this.class=此類別
this.reference.escaped.in.construction.display.name=物件建構中轉義的 'this' 參照
this.reference.escaped.in.construction.problem.descriptor=物件建構期間轉義 <code>#ref</code> #loc
thread.death.rethrown.display.name='ThreadDeath' 未重新拋出
thread.death.rethrown.problem.descriptor=ThreadDeath <code>#ref</code> 未重新拋出 #loc
thread.local.not.static.final.display.name='ThreadLocal' 欄位未被宣告為 'static final'
thread.local.not.static.final.problem.descriptor=ThreadLocal <code>#ref</code> 未被宣告為 'static final' #loc
thread.local.set.with.null.display.name = 以 null 作為實參的 'ThreadLocal.set()'
thread.local.set.with.null.problem.descriptor = 使用 null 作為實參的 'ThreadLocal.set()' 可能會導致記憶體泄漏
thread.local.set.with.null.quickfix = 取代為 'ThreadLocal.remove()' 呼叫
thread.priority.display.name=呼叫 'Thread.setPriority()'
thread.priority.problem.descriptor=呼叫 <code>Thread.#ref()</code> #loc
thread.run.problem.descriptor=對 <code>#ref()</code> 的呼叫可能應當取代為 'start()' #loc
thread.start.in.construction.display.name=物件建構期間呼叫 'Thread.start()'
thread.start.in.construction.problem.descriptor=物件建構期間呼叫 <code>#ref()</code> #loc
thread.stop.suspend.resume.display.name=呼叫 'Thread.stop()'、'suspend()' 或 'resume()'
thread.stop.suspend.resume.problem.descriptor=呼叫 <code>Thread.#ref()</code> #loc
thread.with.default.run.method.display.name=使用預設的 'run()' 方法實例化 'Thread'
thread.with.default.run.method.problem.descriptor=使用預設的 'run()' 方法實例化 <code>#ref</code> #loc
thread.yield.display.name=呼叫 'Thread.yield()'
thread.yield.problem.descriptor=呼叫 <code>Thread.#ref()</code> #loc
three.negations.per.method.display.name=具有三個以上否定的方法
three.negations.per.method.ignore.assert.option=忽略 'assert' 語句中的否定
three.negations.per.method.ignore.option=忽略 'equals()' 方法中的否定
three.negations.per.method.problem.descriptor=<code>#ref</code> 包含 {0} 個否定 #loc
throw,from.finally.block.everywhere.option=警告隨處都可能拋出宣告的異常
throw.caught.locally.display.name=通過包含 'try' 語句捕獲 'throw'
throw.caught.locally.ignore.option=忽略重新拋出的異常
throw.caught.locally.problem.descriptor=通過包含 'try' 語句捕獲 <code>#ref</code> #loc
throw.from.finally.block.display.name='throw' 位於 'finally' 塊內
throw.from.finally.block.problem.descriptor=<code>#ref</code> 位於 'finally' 塊內 #loc
throwable.instance.never.thrown.checked.exception.problem.descriptor=已檢查的異常執行個體 <code>#ref</code> 未拋出 #loc
throwable.instance.never.thrown.error.problem.descriptor=錯誤執行個體 <code>#ref</code> 未拋出 #loc
throwable.instance.never.thrown.problem.descriptor=Throwable 執行個體 <code>#ref</code> 未拋出 #loc
throwable.instance.never.thrown.runtime.exception.problem.descriptor=執行時異常執行個體 <code>new #ref()</code> 未拋出 #loc
throwable.not.thrown.display.name='Throwable' 未拋出
throwable.printed.to.system.out.display.name='Throwable' 列印到 'System.out'
throwable.printed.to.system.out.problem.descriptor=''Throwable'' 實參 <code>#ref</code> 到 ''System.{0}.{1}()'' 呼叫
throwable.result.of.method.call.ignored.problem.descriptor=<code>#ref()</code> 的結果未拋出 #loc
throwable.supplier.only.throw.exception.name=Throwable 供應商從不返回值
throwable.supplier.only.throw.exception.problem.descriptor=Throwable 供應商不返回任何異常
throwable.supplier.only.throw.exception.quickfix=將 lambda 中的 'throw' 取代為 'return'
thrown.exceptions.per.method.display.name=方法宣告的異常過多
thrown.exceptions.per.method.limit.option=異常拋出限制:
thrown.exceptions.per.method.problem.descriptor=<code>#ref</code> 宣告的異常過多 (異常數量 = {0}) #loc
throws.runtime.exception.display.name=在 'throws' 子句中宣告的未檢查的異常
throws.runtime.exception.fix.family.name=從 'throws' 子句中移除
throws.runtime.exception.move.quickfix=將 ''{0}'' 移至 Javadoc ''@throws'' 標記中
throws.runtime.exception.problem.descriptor=在 'throws' 子句中宣告的未檢查的異常 <code>#ref</code> #loc
throws.runtime.exception.quickfix=從 ''throws'' 子句中移除 ''{0}''
time.tostring.call.display.name=呼叫 'Time.toString()'
time.tostring.call.problem.descriptor=國際化上下文中的 <code>Time.#ref()</code> #loc
to.array.call.style.display.name='Collection.toArray()' 呼叫樣式
to.array.call.style.problem.descriptor.presized=<code>#ref()</code> 呼叫具有預設大小的陣列實參 ''{0}'' #loc
to.array.call.style.problem.descriptor.zero=<code>#ref()</code> 呼叫具有空陣列實參 ''{0}'' #loc
to.array.call.style.quickfix.family.name=修復傳遞到 'toArray()' 呼叫的陣列的大小
to.array.call.style.quickfix.make.presized=將實參取代為預設大小的陣列
to.array.call.style.quickfix.make.zero=將實參取代為空陣列
too.broad.catch.display.name=過寬的 'catch' 塊
too.broad.catch.option=僅對 RuntimeException、異常、錯誤或 Throwable 發出警告(&O)
too.broad.catch.problem.descriptor=<code>#ref</code> 的 ''catch'' 過寬，遮罩異常 ''{0}'' #loc
too.broad.catch.problem.descriptor1=<code>#ref</code> 的 ''catch'' 過寬，遮罩異常 ''{0}'' 和 ''{1}'' #loc
too.broad.catch.quickfix=向 ''{0}'' 新增 ''catch'' 子句
too.broad.scope.allow.option=<html>報告使用新表達式作為初始設定式的變數<br>(可能不安全)</html>
too.broad.scope.display.name=變數作用域過寬
too.broad.scope.inspection.fix.family.name=限縮作用域
too.broad.scope.narrow.quickfix=將 ''{0}'' 的宣告移近用法
too.broad.scope.only.blocks.option=僅報告可移入內部塊的變數
too.broad.scope.problem.descriptor=變數 <code>#ref</code> 的作用域過寬 #loc
too.many.constructors.count.limit.option=建構函式計數限制:
too.many.constructors.display.name=建構函式過多的類別
too.many.constructors.ignore.deprecated.option=忽略棄用的建構函式
too.many.constructors.problem.descriptor=<code>#ref</code> 的建構函式過多 (建構函式計數 = {0}) #loc
too.many.fields.count.limit.option=欄位計數限制:
too.many.fields.display.name=欄位過多的類別
too.many.fields.problem.descriptor=<code>#ref</code> 的欄位過多 (欄位計數 = {0}) #loc
too.many.methods.display.name=方法過多的類別
too.many.methods.problem.descriptor=<code>#ref</code> 的方法過多 (方法計數 = {0}) #loc
trace.level.option=追蹤級別
transient.field.in.non.serializable.class.display.name=不可序列化類別中存在 transient 欄位
transient.field.in.non.serializable.class.problem.descriptor=欄位 ''{0}'' 已在不可序列化類別中標記為 <code>#ref</code> #loc
transient.field.not.initialized.display.name=transient 欄位在反序列化時未初始化
transient.field.not.initialized.problem.descriptor=transient 欄位 <code>#ref</code> 在反序列化時未初始化 #loc
trivial.if.display.name=冗餘的 'if' 語句
trivial.if.fix.family.name=簡化 'if else'
trivial.if.option.ignore.assert.statements=忽略帶有簡單 'assert' 的 'if' 語句
trivial.if.option.ignore.chained=忽略鏈式 'if' 語句
trivial.if.problem.descriptor=<code>#ref</code> 語句可以簡化 #loc
trivial.string.concatenation.display.name=與空字串串聯
trivial.string.concatenation.problem.descriptor=串聯中使用的空字串
try.finally.can.be.try.with.resources.display.name='try finally' 可被取代為 'try' with resources
try.finally.can.be.try.with.resources.problem.descriptor=<code>#ref</code> 可以使用自動資源管理 #loc
try.finally.can.be.try.with.resources.quickfix=取代為 'try-with-resources'
try.statement.with.multiple.resources.name=可以拆分具有多個資源的 'try' 語句
try.statement.with.multiple.resources.quickfix=拆分具有多個資源的 'try' 語句
try.with.identical.catches.checkbox.different.comments=不報告帶有不同註釋的 catch 塊
try.with.identical.catches.display.name='try' 語句中的相同 'catch' 分支
try.with.identical.catches.problem.descriptor=''catch'' 分支與 ''{0}'' 分支相同 #loc
try.with.identical.catches.quickfix=摺疊 'catch' 塊
type.parameter.extends.enum.type.parameter.problem.descriptor=類型參數 <code>#ref</code> 隱式擴展 final 枚舉 ''{0}'' #loc
type.parameter.extends.enum.wildcard.problem.descriptor=萬用字元類型實參 <code>#ref</code> 隱式擴展了 final 枚舉 ''{0}'' #loc
type.parameter.extends.final.class.display.name=類型參數擴展 'final' 類別
type.parameter.extends.final.class.quickfix=將類型參數取代為實際類別
type.parameter.extends.final.class.type.parameter.problem.descriptor=類型參數 <code>#ref</code> 擴展 ''final'' 類別{0} #loc
type.parameter.extends.final.class.wildcard.problem.descriptor=萬用字元類型實參 <code>#ref</code> 擴展了 ''final'' 類別 ''{0}'' #loc
type.parameter.extends.object.display.name=類型參數顯式擴展 'Object'
type.parameter.extends.object.ignore.annotated=註解 java.lang.Object 時忽略
type.parameter.extends.object.problem.descriptor1=類型參數 <code>#ref</code> 顯式擴展 'java.lang.Object' #loc
type.parameter.extends.object.problem.descriptor2=萬用字元類型實參 <code>#ref</code> 顯式擴展 'java.lang.Object' #loc
type.parameter.hides.type.parameter.problem.descriptor=類型參數 <code>#ref</code> 隱藏類型參數 ''{0}'' #loc
type.parameter.hides.visible.type.display.name=類型參數隱藏可見類型
type.parameter.hides.visible.type.problem.descriptor=類型參數 <code>#ref</code> 隱藏可見類型 ''{0}'' #loc
type.parameter.naming.convention.element.description=類型參數
unary.plus.display.name=一元正號
unary.plus.problem.descriptor=一元 <code>#ref</code> 運算符 #loc
unary.plus.quickfix=移除一元 '+'
unchecked.exception.class.display.name=未檢查的 'Exception' 類別
unchecked.exception.class.problem.descriptor=未檢查的異常類別 <code>#ref</code> #loc
unclear.binary.expression.display.name=具有不同優先級的多個運算符
unclear.binary.expression.problem.descriptor=表達式可以使用澄清括號 #loc
unclear.binary.expression.quickfix=新增澄清括號
unconditional.wait.display.name=無條件的 'wait()' 呼叫
unconditional.wait.problem.descriptor=無條件呼叫 <code>#ref()</code> #loc
unnecessarily.qualified.inner.class.access.display.name=不必要的限定內部類別存取
unnecessarily.qualified.inner.class.access.option=忽略需要匯入的參照
unnecessarily.qualified.inner.class.access.problem.descriptor=使用 <code>#ref</code> 限定 ''{0}'' 不必要 #loc
unnecessarily.qualified.inner.class.access.quickfix=移除限定符
unnecessarily.qualified.static.usage.display.name=不必要的限定靜態存取
unnecessarily.qualified.static.usage.ignore.field.option=忽略不必要的限定欄位存取
unnecessarily.qualified.static.usage.ignore.method.option=忽略不必要的限定方法呼叫
unnecessarily.qualified.static.usage.problem.descriptor=不必要的限定 static 方法呼叫 <code>{0}()</code> #loc
unnecessarily.qualified.static.usage.problem.descriptor1=不必要的限定靜態存取 <code>{0}</code> #loc
unnecessarily.qualified.statically.imported.element.display.name=不必要的限定靜態匯入元素
unnecessarily.qualified.statically.imported.element.problem.descriptor=靜態匯入元素 ''{0}'' 使用 <code>#ref</code> 不必要限定 #loc
unnecessarily.qualified.statically.imported.element.quickfix=移除不必要的限定符
unnecessary.block.statement.problem.descriptor=此語句周圍的大括號不必要 #loc
unnecessary.boxing.display.name=不必要的裝箱
unnecessary.boxing.inside.value.of.problem.descriptor=冗餘裝箱，可以改用 <code>{0}.{1}()</code> 呼叫 #loc
unnecessary.boxing.problem.descriptor=不必要的裝箱 #loc
unnecessary.boxing.remove.quickfix=移除裝箱
unnecessary.boxing.superfluous.option=僅報告真正多餘的裝箱表達式
unnecessary.break.display.name=不必要的 'break' 語句
unnecessary.break.problem.descriptor=<code>#ref</code> 語句不必要 #loc
unnecessary.code.block.display.name=不必要的程式碼塊
unnecessary.code.block.unwrap.quickfix=解包塊
unnecessary.constant.array.creation.expression.display.name=常數陣列建立中的冗餘 'new' 表達式
unnecessary.constant.array.creation.expression.family.quickfix=從新陣列表達式中移除類型規範
unnecessary.constant.array.creation.expression.problem.descriptor=可從新陣列表達式中移除 <code>#ref</code> #loc
unnecessary.constructor.annotation.option=忽略有註解的建構函式
unnecessary.constructor.display.name=冗餘無實參建構函式
unnecessary.constructor.problem.descriptor=無實參建構函式 <code>#ref()</code> 是冗餘的 #loc
unnecessary.constructor.remove.quickfix=移除冗餘建構函式
unnecessary.continue.display.name=不必要的 'continue' 語句
unnecessary.continue.problem.descriptor=<code>#ref</code> 不必要，因為是迴圈中的最後一條語句 #loc
unnecessary.conversion.to.string.display.name=到 'String' 的不必要轉換
unnecessary.default.display.name=枚舉 'switch' 語句的 'default' 不必要
unnecessary.default.expressions.option=僅報告 switch 表達式
unnecessary.default.problem.descriptor=<code>#ref</code> 分支不必要 #loc
unnecessary.default.quickfix=移除 'default' 分支
unnecessary.enum.constructor.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於枚舉建構函式是冗餘的 #loc
unnecessary.explicit.numeric.cast.display.name=不必要的顯式數字轉換
unnecessary.explicit.numeric.cast.problem.descriptor=''{0}'' 不必要轉換為 <code>#ref</code> #loc
unnecessary.explicit.numeric.cast.quickfix=移除轉換
unnecessary.final.on.local.variable.or.parameter.display.name=區域變數或參數上存在不必要的 'final'
unnecessary.final.on.local.variable.problem.descriptor=變數 ''{0}'' 上存在不必要的 <code>#ref</code> #loc
unnecessary.final.on.parameter.only.interface.option=僅對 abstract 或接口方法發出警告
unnecessary.final.on.parameter.problem.descriptor=參數 ''{0}'' 上存在不必要的 <code>#ref</code> #loc
unnecessary.final.report.local.variables.option=報告區域變數
unnecessary.final.report.parameters.option=報告參數
unnecessary.final.report.pattern.variables.option=報告模式變數
unnecessary.fully.qualified.name.display.name=不必要的完全限定名稱
unnecessary.fully.qualified.name.fix.family.name=取代完全限定名稱
unnecessary.fully.qualified.name.problem.descriptor1=限定符 <code>#ref</code> 不必要，可被取代為匯入 #loc
unnecessary.fully.qualified.name.problem.descriptor2=限定符 <code>#ref</code> 不必要，可以移除 #loc
unnecessary.fully.qualified.name.remove.quickfix=移除不必要的限定
unnecessary.fully.qualified.name.replace.quickfix=將限定名稱取代為匯入
unnecessary.fully.qualified.name.status.bar.escape.highlighting.message={0} 個完全限定{0, choice, 1#名稱|2#名稱}取代為匯入 (按 Esc 移除醒目提示)
unnecessary.inherit.doc.class.invalid.problem.descriptor=<code>#ref</code> 在類別上無效 #loc
unnecessary.inherit.doc.constructor.invalid.problem.descriptor=<code>#ref</code> 在建構函式上無效 #loc
unnecessary.inherit.doc.constructor.no.super.problem.descriptor=找不到繼承 Javadoc 的 super 方法 #loc
unnecessary.inherit.doc.display.name=不必要的 '{@inheritDoc}' Javadoc 註釋
unnecessary.inherit.doc.field.invalid.problem.descriptor=<code>#ref</code> 在欄位上無效 #loc
unnecessary.inherit.doc.module.invalid.problem.descriptor=<code>#ref</code> 在模組宣告上無效 #loc
unnecessary.inherit.doc.problem.descriptor=僅包含 <code>#ref</code> 的 Javadoc 註釋不必要 #loc
unnecessary.inherit.doc.quickfix=移除不必要的 {@inheritDoc}
unnecessary.initcause.display.name=對 'Throwable.initCause()' 的呼叫不必要
unnecessary.initcause.problem.descriptor=不必要的 <code>Throwable.#ref()</code> 呼叫
unnecessary.initcause.quickfix=移除 'Throwable.initCause()' 呼叫
unnecessary.inner.enum.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於內部枚舉是冗餘的 #loc
unnecessary.inner.interface.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於內部接口是冗餘的 #loc
unnecessary.inner.record.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於內部記錄是冗餘的
unnecessary.interface.field.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於接口欄位是冗餘的 #loc
unnecessary.interface.inner.class.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於接口的內部類別是冗餘的 #loc
unnecessary.interface.member.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於接口成員是冗餘的 #loc
unnecessary.interface.method.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於接口方法是冗餘的 #loc
unnecessary.interface.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於接口是冗餘的 #loc
unnecessary.java.doc.link.fix.family.name=移除冗餘標記
unnecessary.javadoc.link.display.name=不必要的 Javadoc 連結
unnecessary.javadoc.link.option=忽略 super 方法的內聯連結
unnecessary.javadoc.link.quickfix=移除不必要的 ''{0}''
unnecessary.javadoc.link.super.method.problem.descriptor=指向 super 方法的 <code>#ref</code> 不必要 #loc
unnecessary.javadoc.link.this.class.problem.descriptor=指向包含類別的 <code>#ref</code> 不必要 #loc
unnecessary.javadoc.link.this.method.problem.descriptor=指向此方法的 <code>#ref</code> 不必要 #loc
unnecessary.label.on.break.statement.display.name='break' 語句上的標籤不必要
unnecessary.label.on.break.statement.problem.descriptor=Break 語句上存在不必要的標籤 <code>#ref</code> #loc
unnecessary.label.on.continue.statement.display.name='continue' 語句上的不必要標籤
unnecessary.label.on.continue.statement.problem.descriptor=Continue 語句上存在不必要的標籤 <code>#ref</code> #loc
unnecessary.label.remove.quickfix=移除標籤
unnecessary.local.variable.problem.descriptor=區域變數 <code>#ref</code> 是冗餘的 #loc
unnecessary.modifier.display.name=不必要的修飾符
unnecessary.parentheses.conditional.option=忽略條件表達式條件周圍的圓括號
unnecessary.parentheses.display.name=不必要的圓括號
unnecessary.parentheses.option=忽略澄清圓括號
unnecessary.parentheses.problem.descriptor=<code>#ref</code> 周圍的圓括號不必要 #loc
unnecessary.parentheses.remove.quickfix=移除不必要的圓括號
unnecessary.qualifier.for.super.problem.descriptor='super' 上的限定符 <code>#ref</code> 在此上下文中不必要 #loc
unnecessary.qualifier.for.this.display.name='this' 或 'super' 的限定符不必要
unnecessary.qualifier.for.this.problem.descriptor='this' 上的限定符 <code>#ref</code> 在此上下文中不必要 #loc
unnecessary.qualifier.for.this.remove.quickfix=移除不必要的限定符
unnecessary.record.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於記錄是冗餘的
unnecessary.return.constructor.problem.descriptor=<code>#ref</code> 不必要，因為是建構函式中的最後一條語句 #loc
unnecessary.return.display.name=不必要的 'return' 語句
unnecessary.return.option=在具有 'else' 分支的 'if' 語句的 then 分支中忽略
unnecessary.return.problem.descriptor=<code>#ref</code> 不必要，因為是 'void' 方法中的最後一條語句 #loc
unnecessary.semicolon.display.name=不必要的分號
unnecessary.semicolon.ignore.after.enum.constants.option=忽略枚舉常數後的不必要分號
unnecessary.semicolon.problem.descriptor=不必要的分號 <code>#ref</code> #loc
unnecessary.semicolon.remove.quickfix=移除不必要的分號
unnecessary.strictfp.modifier.problem.descriptor=修飾符 <code>#ref</code> 在 Java 17 和更高版本上是冗餘的
unnecessary.string.escape.display.name=不必要的轉義字元
unnecessary.string.escape.problem.descriptor=<code>#ref</code> 進行了不必要的轉義
unnecessary.string.escape.quickfix=將不必要的轉義字元取代為未轉義字元
unnecessary.super.constructor.display.name=對 'super()' 的呼叫不必要
unnecessary.super.constructor.problem.descriptor=<code>#ref</code> 不必要 #loc
unnecessary.super.constructor.remove.quickfix=移除不必要的 'super()'
unnecessary.super.qualifier.display.name=不必要的 'super' 限定符
unnecessary.super.qualifier.problem.descriptor=限定符 <code>#ref</code> 在此上下文中不必要 #loc
unnecessary.super.qualifier.quickfix=移除不必要的 'super' 限定符
unnecessary.temporary.object.fix.family.name=取代串聯
unnecessary.temporary.on.conversion.from.string.display.name=從 'String' 轉換時有不必要的臨時物件
unnecessary.temporary.on.conversion.to.string.display.name=轉換為 'String' 時有不必要的臨時物件
unnecessary.this.display.name=不必要的 'this' 限定符
unnecessary.this.ignore.assignments.option=忽略欄位指派
unnecessary.this.problem.descriptor=<code>#ref</code> 在此上下文中不必要 #loc
unnecessary.this.remove.quickfix=移除不必要的 'this' 限定符
unnecessary.tostring.call.display.name=對 'toString()' 的呼叫不必要
unnecessary.tostring.call.problem.descriptor=不必要的 <code>#ref()</code> 呼叫 #loc
unnecessary.transient.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於 'static' 欄位是冗餘的
unnecessary.unary.minus.display.name=不必要的一元負號
unnecessary.unary.minus.problem.descriptor=不必要的一元 <code>#ref</code> 運算符 #loc
unnecessary.unary.minus.quickfix=移除一元負號並反轉父運算符號
unnecessary.unary.minus.remove.quickfix=移除雙一元減號
unnecessary.unboxing.display.name=不必要的拆箱
unnecessary.unboxing.problem.descriptor=不必要的拆箱 #loc
unnecessary.unboxing.remove.quickfix=移除拆箱
unnecessary.unboxing.superfluous.option=僅報告真正多餘的拆箱表達式
unnecessary.unicode.escape.display.name=不必要的 Unicode 轉義序列
unnecessary.unicode.escape.fix.family.name=取代為字元
unnecessary.unicode.escape.fix.text=取代為換行字元
unnecessary.unicode.escape.problem.descriptor=Unicode 轉義序列 <code>#ref</code> 可被取代為 ''{0}'' #loc
unnecessary.unicode.escape.problem.newline.descriptor=Unicode 轉義序列 <code>#ref</code> 可被取代為換行字元 #loc
unnecessary.unicode.escape.problem.tab.descriptor=Unicode 轉義序列 <code>#ref</code> 可被取代為制表符 #loc
unpredictable.big.decimal.constructor.call.display.name=不可預知的 'BigDecimal' 建構函式呼叫
unpredictable.big.decimal.constructor.call.ignore.complex.literals.option=忽略具有多個文字的建構函式呼叫 (例如 0.1 + 0.2)
unpredictable.big.decimal.constructor.call.ignore.references.option=忽略具有變量或方法呼叫實參的建構函式呼叫
unpredictable.big.decimal.constructor.call.problem.descriptor=不可預知的 <code>new #ref()</code> 呼叫 #loc
unqualified,static.usage.only.report.static.usages.option=僅報告來自非 static 上下文的靜態存取
unqualified.field.access.display.name=未使用 'this' 限定的執行個體欄位存取
unqualified.field.access.problem.descriptor=未使用 'this' 限定的執行個體欄位存取 <code>#ref</code> #loc
unqualified.inner.class.access.display.name=非限定內部類別存取
unqualified.inner.class.access.option=忽略對本地內部類別的參照
unqualified.inner.class.access.problem.descriptor=<code>#ref</code> 未使用外部類別限定 #loc
unqualified.inner.class.access.quickfix=使用外部類別限定
unqualified.method.access.display.name=未使用 'this' 限定的執行個體方法呼叫
unqualified.method.access.problem.descriptor=未使用 'this' 限定執行個體方法呼叫 <code>#ref()</code> #loc
unqualified.static.access.fix.family.name=限定靜態存取
unqualified.static.usage.display.name=非限定靜態存取
unqualified.static.usage.ignore.field.option=忽略非限定欄位存取
unqualified.static.usage.ignore.method.option=忽略非限定方法呼叫
unqualified.static.usage.problem.descriptor=非限定 static 方法呼叫 <code>#ref()</code> #loc
unqualified.static.usage.problem.descriptor1=非限定 static 欄位存取 <code>#ref</code> #loc
unqualified.static.usage.qualify.field.quickfix=限定 static 欄位存取
unqualified.static.usage.qualify.method.quickfix=限定 static 方法呼叫
unresolved.class.reference.repair.display.name=未解析的類別參照
unresolved.class.reference.repair.problem.descriptor=無法解析 ''{0}'' 參照
unrunnable.main.method.problem.descriptor=無法執行方法 <code>#ref()</code>，因為包含類別沒有完全限定名稱
unsecure.random.number.generation.display.name=不安全的隨機數生成
unsecure.random.number.generation.problem.descriptor1=出於安全目的，請使用 'java.security.SecureRandom' 而不是 <code>java.lang.Math.#ref()</code> #loc
unsecure.random.number.generation.problem.descriptor2=出於安全目的，請使用 'java.security.SecureRandom' 而不是 <code>java.util.#ref</code> #loc
unsecure.random.number.generation.problem.descriptor3=出於安全目的，請使用 'java.security.SecureRandom' 而不是 <code>#ref</code> #loc
unused.import.problem.descriptor=未使用的 import <code>#ref</code> #loc
unused.label.display.name=未使用的標籤
unused.label.problem.descriptor=未使用的標籤 <code>#ref</code> #loc
unused.label.remove.quickfix=移除未使用的標籤
update.column.name=更新名稱開頭
update.label=更新名稱開頭:
upper.case.field.name.not.constant.display.name=具有大寫名稱的非常數欄位
upper.case.field.name.not.constant.problem.descriptor=帶常數樣式名稱的非常數欄位 <code>#ref</code> #loc
usage.of.obsolete.assert.display.name=使用廢棄的 'junit.framework.Assert' 方法
use.0index.in.jdbc.prepared.statement.problem.descriptor=在 JDBC PreparedStatement 中使用索引 '0' #loc
use.0index.in.jdbc.resultset.display.name=在 JDBC ResultSet 中使用索引 0
use.0index.in.jdbc.resultset.problem.descriptor=在 JDBC ResultSet 中使用索引 '0' #loc
use.contentequals=使用 'contentEquals()' 與 'AbstractStringBuilder' 進行比較
use.equalsignorecase.for.case.insensitive.comparison=為不區分大小寫的比較使用 'equalsIgnoreCase()'
use.isblank.to.check.if.string.is.whitespace.or.empty=使用 'isBlank()' 檢查字串是否為空或者僅包含空格
use.obsolete.collection.type.display.name=使用廢棄的集合類型
use.obsolete.collection.type.ignore.library.arguments.option=在需要的位置忽略廢棄的集合類型
use.obsolete.collection.type.problem.descriptor=使用了廢棄的集合類型 <code>#ref</code> #loc
use.of.awt.peer.class.display.name=使用 AWT 對等類別
use.of.awt.peer.class.problem.descriptor=AWT 對等類別 <code>#ref</code> 的使用不可移植 #loc
use.of.clone.call.method.problem.descriptor=實作 <code>#ref()</code>
use.of.clone.call.problem.descriptor=呼叫 <code>#ref()</code>
use.of.clone.display.name=使用 'clone()' 或 'Cloneable'
use.of.clone.reference.problem.descriptor=使用 <code>#ref</code>
use.of.concrete.class.option.ignore.abstract=忽略抽象類別類型
use.of.concrete.class.option.ignore.records=忽略 Java 記錄
use.of.concrete.class.option.report.cast=報告轉換表達式中使用的類型
use.of.concrete.class.option.report.instance.fields=報告執行個體欄位類型
use.of.concrete.class.option.report.instanceof=報告 instanceof、patterns 或 getClass() 比較中使用的類型
use.of.concrete.class.option.report.local.variable=報告區域變數類型
use.of.concrete.class.option.report.method.returns=報告方法返回值類型
use.of.concrete.class.option.report.parameter=報告方法參數類型
use.of.concrete.class.option.report.static.fields=報告 static 欄位類型
use.of.concrete.jdbc.driver.class.display.name=使用具體的 JDBC 驅動程序類別
use.of.concrete.jdbc.driver.class.problem.descriptor=具體 JDBC 驅動程序類別 <code>#ref</code> 的使用不可移植 #loc
use.of.obsolete.assert.problem.descriptor=對來自 ''{0}'' 的 <code>#ref()</code> 的呼叫應被取代為對來自 ''org.junit.Assert'' 的方法的呼叫 #loc
use.of.obsolete.assert.quickfix=取代為 'org.junit.Assert' 方法呼叫
use.of.obsolete.date.time.api.display.name=使用廢棄的日期時間 API
use.of.obsolete.date.time.api.problem.descriptor=使用了廢棄的日期時間類型 <code>#ref</code> #loc
use.of.properties.as.hashtable.fix.family.name=修復屬性存取
use.processbuilder.class.display.name=使用 'java.lang.ProcessBuilder' 類別
use.processbuilder.class.problem.descriptor=<code>#ref</code> 的使用不可移植 #loc
use.stringtokenizer.display.name=使用 'StringTokenizer'
use.stringtokenizer.problem.descriptor=國際化上下文中的 <code>#ref</code> #loc
use.sun.classes.display.name=使用 'sun.*' 類別
use.sun.classes.problem.descriptor=Sun 提供的類別 <code>#ref</code> 的使用不可移植 #loc
use.system.out.err.display.name=使用 'System.out' 或 'System.err'
use.system.out.err.problem.descriptor=<code>#ref</code> 的使用可能應當取代為更可靠的日誌 #loc
utility.class.can.be.enum.display.name=實用程序類別可以是 'enum'
utility.class.code.can.be.enum.problem.descriptor=實用程序類別 <code>#ref</code> 可以是 'enum' #loc
utility.class.code.can.be.enum.quickfix=轉換為 'enum'
utility.class.display.name=實用程序類別
utility.class.problem.descriptor=類別 <code>#ref</code> 只有 'static' 成員，指示程序建構 #loc
utility.class.with.public.constructor.display.name=實用程序類別具有 'public' 建構函式
utility.class.with.public.constructor.fix.family.name=將建構函式設為非 public
utility.class.with.public.constructor.make.private.quickfix=將{0, choice, 1#建構函式|2#建構函式}設為 'private'
utility.class.with.public.constructor.make.protected.quickfix=將{0, choice, 1#建構函式|2#建構函式}設為 'protected'
utility.class.with.public.constructor.problem.descriptor=類別 <code>#ref</code> 只有 'static' 成員和 'public' 建構函式 #loc
utility.class.without.private.constructor.cant.generate.constructor.message=實用程序類別具有實例化，將不會建立 private 建構函式
utility.class.without.private.constructor.cant.generate.constructor.title=無法生成建構函式
utility.class.without.private.constructor.create.quickfix=生成空 'private' 建構函式
utility.class.without.private.constructor.display.name=實用程序類別沒有 'private' 建構函式
utility.class.without.private.constructor.make.quickfix=將建構函式設為 'private'
utility.class.without.private.constructor.option=忽略僅具有主方法的類別
utility.class.without.private.constructor.problem.descriptor=類別 <code>#ref</code> 只有 'static' 成員，缺少 'private' 建構函式 #loc
value.of.post.decrement.problem.descriptor=使用後減量表達式 <code>#ref</code> 的值 #loc
value.of.post.increment.problem.descriptor=使用後增量表達式 <code>#ref</code> 的值 #loc
value.of.pre.decrement.problem.descriptor=使用前減量表達式 <code>#ref</code> 的值 #loc
value.of.pre.increment.problem.descriptor=使用前增量表達式 <code>#ref</code> 的值 #loc
variable.argument.method.display.name=vararg 方法
variable.argument.method.problem.descriptor=vararg 方法 <code>#ref()</code> #loc
variable.argument.method.quickfix=將 vararg 參數轉換為數組
variable.not.used.inside.conditional.problem.descriptor=條件內未使用檢查為 'null' 的 <code>#ref</code> #loc
variable.not.used.inside.if.display.name='if' 內未使用檢查為 'null' 的參照
variable.not.used.inside.if.problem.descriptor='if' 內未使用檢查為 'null' 的 <code>#ref</code> #loc
variable.type.can.be.explicit.display.name=變數類型可以是顯式的
volatile.array.field.display.name=volatile 陣列欄位
volatile.field.problem.descriptor=類型 ''{0}'' 的 volatile 欄位 <code>#ref</code> #loc
wait.called.on.condition.display.name=在 'java.util.concurrent.locks.Condition' 物件上呼叫了 'wait()'
wait.called.on.condition.problem.descriptor=在條件物件上呼叫 <code>#ref()</code> #loc
wait.not.in.loop.display.name=未在迴圈中呼叫的 'wait()'
wait.not.in.loop.problem.descriptor=<code>#ref()</code> 呼叫不在迴圈中 #loc
wait.notify.not.in.synchronized.context.display.name='wait()' 或 'notify()' 不在同步的上下文中
wait.notify.while.not.synchronized.on.problem.descriptor=''{0}'' 未同步時呼叫 <code>#ref</code> #loc
wait.or.await.without.timeout.display.name=無超時的 'wait()' 或 'await()'
wait.or.await.without.timeout.problem.descriptor=無超時的 <code>#ref</code> #loc
wait.while.holding.two.locks.display.name=保持兩個鎖時 'wait()'
wait.while.holding.two.locks.problem.descriptor=在保持兩個鎖的情況下呼叫 <code>#ref()</code> #loc
wait.without.corresponding.notify.display.name=沒有相應 'notify()' 的 'wait()'
wait.without.corresponding.notify.problem.descriptor=在沒有相應 <code>notify()</code> 或 <code>notifyAll()</code> 的情況下呼叫 <code>#ref()</code> #loc
warn.level.and.lower.option=警告級別和更低
warn.on.label=警告物件:
weaken.visibility.quickfix=削弱可見性
while.can.be.foreach.display.name='while' 迴圈可被取代為增強的 'for' 迴圈
while.can.be.foreach.problem.descriptor=<code>#ref</code> 迴圈可被取代為增強的 'for' #loc
while.loop.spins.on.field.display.name='while' 迴圈在欄位上自旋
while.loop.spins.on.field.fix.family.name=修復自旋迴圈
while.loop.spins.on.field.fix.spinwait=新增 Thread.onSpinWait()
while.loop.spins.on.field.fix.volatile=將 ''{0}'' 設為 volatile
while.loop.spins.on.field.fix.volatile.spinwait=將 ''{0}'' 設為 volatile 並新增 Thread.onSpinWait()
while.loop.spins.on.field.ignore.non.empty.loops.option=僅當迴圈為空時才發出警告
while.loop.spins.on.field.problem.descriptor=<code>#ref</code> 迴圈在欄位上自旋 #loc
wrap.with.arrays.hash.code.quickfix=使用 ''{0}'' 包裝
write.only.object.display.name=只寫入物件
write.only.object.option.ignore.impure.constructors=忽略不純的建構函式"
`;

exports[`dev messages/JavaScriptBundle.properties 1`] = `
"0.is.not.a.legal.name=''{0}'' 不是合法的類別名
0.is.not.accessible.from.1=無法從 {1} 存取 {0}
0.is.not.allowed.in.interface=接口中不允許使用 {0} 
0.with.1.visibility.in.the.target.class.is.not.accessible.from.2=目標類別中可見性為 {1} 的 {0} 無法從 {2} 存取
0.with.1.visibility.is.not.accessible.from.2=可見性為 {1} 的 {0} 將無法從 {2} 存取
action.Anonymous.text.configure=組態
action.EslintImportCodeStyle.description=套用 ESLint 程式碼樣式
action.ExplainNodeModulesLibrariesAction.text=解釋 node__modules 庫
action.FindDuplicatedIndexedFilesInNodeModulesAction.text=在 node__modules 中尋找重複的索引檔案
action.Generate.Constructor.JavaScript.text=建構函式
action.Generate.GetAccessor.JavaScript.text=Getter
action.Generate.GetSetAccessor.JavaScript.text=Getter 和 Setter
action.Generate.Missing.Members.ES6.text=實作方法…
action.Generate.Missing.Members.TypeScript.text=實作成員…
action.Generate.SetAccessor.JavaScript.text=Setter
action.InstallNodeLocalDependencies$Root.text=為 {1} 執行 ''{0}''
action.InstallNodeLocalDependencies.text=安裝 Node.js 相依項
action.JS.TypeScript.Include.Generated.Declarations.description=在專案中包含 .d.ts 子檔案
action.JS.TypeScript.Include.Generated.Declarations.text=包括 '.d.ts' 子檔案
action.JasmineGenerateAfterEachMethodAction.text=Jasmine afterEach
action.JasmineGenerateBeforeEachMethodAction.text=Jasmine beforeEach
action.JasmineGenerateNewSpecAction.text=Jasmine Spec
action.JasmineGenerateNewSuiteAction.text=Jasmine Suite
action.JavaScriptGenerateDictionaries.text=生成 JavaScript 拼寫檢查器字典
action.PackageJsonNewFile.description=建立 {0} 檔案
action.PackageJsonNewFile.text={0}
action.QUnitGenerateNewTestAction.text=QUnit Test
action.QUnitGenerateSetupAction.text=QUnit Setup
action.QUnitGenerateTearDownAction.text=QUnit TearDown
action.ReactClassToFunctionComponentAction.description=轉換為函式元件
action.ReactExtractComponentAction.description=提取元件
action.ReactFunctionToClassComponentAction.description=轉換為類別元件
action.ToggleNodeCoreCodingAssistanceAction.toggle.coding.assistance.for.node.js.text=切換 Node.js 的編碼輔助
action.TypeScriptExtractTypeAlias.description=提取類型別名
action.already.set.for.containing.folder.or.project.description=已針對包含的目錄或專案進行設定。
action.creates.new.file.description=建立新的 {0} 檔案
action.don.t.ask.again.text=不再詢問
action.don.t.use.library.description=不使用庫
action.js.tagged.literal.injection.text=JS 標記文字注入
action.jump.to.text=跳轉到…
action.name.add.explicit.value=新增枚舉顯式值
action.name.disable.category=停用 {0}
action.show.error.details.text=顯示錯誤詳細資訊
action.show.structure.text=顯示結構
action.structureview.show.object.inherited=從物件繼承
action.use.library.description=使用庫
action.view.install.text=檢視並安裝…
actionscript.space.after.dots.in.rest.parameter=在 rest 參數中的 '...' 後面
actionscript.validation.message.get.method.access.type.is.different.from.setter=Flash 編譯器錯誤 174646: Get 存取器方法存取類型不同於 set 存取器存取類型，應為 ''{0}''
actionscript.validation.message.set.method.access.type.is.different.from.getter=Flash 編譯器錯誤 174646: Set 存取器方法存取類型不同於 get 存取器存取類型，應為 ''{0}''
add.import.binding.to.import=將匯入綁定新增到匯入
add.import.specifier.to.import=將匯入說明符新增到匯入
add.variable.to.require=新增 require 呼叫的變數
anonymous.to.named.intention.function.name=函式名稱:
automatically.replace.with.template.string.on.typing=在輸入 '\${' 時自動將字串文字取代為模板字串
border.title.inspection.description.title=描述:
border.title.inspection.export.results.capitalized.location=位置
bower.correct.path=請更正 {0} 的路徑
bower.dialog.message.specify.package=指定正確的 bower 軟體套件: 未找到“{0}”檔案
bower.json=bower.json (&O):
bower.no_description_available.text=無可用描述
bower.package=Bower 軟體套件(&B):
bower.package.name=Bower 軟體套件
bower.packages.view.dependencies=相依項:
bower.required.version.notification.content=要檢視 bower 軟體套件，您需要 bower@1.0.0 或更高版本
build.event.title.failed.to.list.tasks=無法列出 {0} 任務
buildTools.EditRunSettingsAction.text=編輯 ''{0}'' 設定(&E)…
buildTools.JsbtAddBuildfileAction.text=新增 {0}
buildTools.JsbtReloadTasksAction.npm.text=重新載入腳本
buildTools.JsbtReloadTasksAction.text=重新載入任務
buildTools.JsbtRemoveBuildfileAction.text=移除 {0}
buildTools.JsbtRunTaskAction.text=執行 Gulp/Grunt/npm 任務
buildTools.JsbtShowTasksAction.npm.text=顯示 npm 腳本
buildTools.JsbtShowTasksAction.text=顯示 {0} 任務
buildTools.ShowSettingsAction.npm.text=編輯 npm 組態(&E)…
buildTools.ShowSettingsAction.text={0}設定…
buildTools.add.with=使用 {1} 新增 {0}
buildTools.choose_buildfile.text=選擇 {0}
buildTools.edit.run.configuration=編輯執行組態
buildTools.failed.to.list.tasks=無法列出任務
buildTools.failed.to.list.tasks.details.reference=詳細資訊
buildTools.no.files.added=未新增檔案
buildTools.no.such.file=沒有此類別檔案
buildTools.no.tasks.found=未找到任務
buildTools.searchEverywhere.npm.text=執行 ''{0}'' npm 腳本
buildTools.searchEverywhere.text=執行 ''{0}'' 任務
buildTools.tooltip.click.to.show.error.details=點擊以顯示錯誤詳細資訊
buildTools.tree.sortBy.definitionOrder.text=定義順序
buildTools.tree.sortBy.name.text=名稱
buildTools.tree.sortBy.text=排序方式
bundler.configuration.automatic=自動
bundler.configuration.automatic.hint={0} 將使用當前檔案所在目錄或其任意父目錄中的 {1} 組態檔案內的模組解析規則。
bundler.configuration.automatic.how.it.works=運作方式
bundler.configuration.detect.description=檢測適合模組解析的 {0} 組態檔案:
bundler.configuration.disabled=已停用
bundler.configuration.field=組態檔案:
bundler.configuration.field.required.error=手動模式下需要組態檔案路徑
bundler.configuration.manual=手動
button.abort=中止
button.continue=繼續
button.install.update=安裝/更新
can.t.find.flow.executable=找不到 Flow 可執行檔案
cannot.modify.library.code=無法修改庫或 SDK 程式碼
cannot.parse.service.initialization.answer.0=無法解析服務初始化回復 {0}\\n
cannot.refactor.anonymous.function=現有非呼叫用法阻止呼叫站點分析。
change.method.signature.and.update.delegating.call.fix.family.name=更改方法簽名並更新委託呼叫
change.method.signature.and.update.delegating.call.fix.text=更改 {0} 簽名以符合 {1} 呼叫和更新呼叫
change.method.signature.and.update.delegating.call.noname.fix.text=更改簽名以符合 {0} 呼叫和更新呼叫
change.method.signature.delegating.default.text=委託
change.method.signature.fix.family.name=更改方法簽名
change.method.signature.fix.text=更改 {0} 簽名
change.signature.call.expression.contains.spreads=函式呼叫包含傳播實參。用法將保持不變。
change.signature.column.name=名稱
change.signature.column.name.call.value=呼叫中的值
change.signature.column.name.default.parameter=預設參數
change.signature.column.name.initializer=初始設定式
change.signature.column.name.modifier=修飾符
change.signature.column.name.optional.flag=可選
change.signature.column.type=類型
change.signature.conflict.eliminating.parameter.property.breaks.usages=將參數-屬性轉換為簡單的參數將中斷 {0} 的欄位用法
change.signature.conflict.incompatible.implementation=實作 {0} 的參數個數與重構 {1} 的參數個數不同。重構期間將忽略 {2}。
change.signature.conflict.incompatible.override=覆寫 {0} 的參數個數與重構 {1} 的參數個數不同。重構期間將忽略 {2}。
change.signature.conflict.readonly.parameter.property.write.usage=將 {0} 變為唯讀將中斷非讀取用法
change.signature.dialog.title=更改 {0} 的簽名
change.signature.method.references.arguments=函式參照實參，更改簽名後代碼可能會中斷
change.signature.parameter.table.empty.message=使用  '+' 按鈕新增新參數
change.signature.tagged.template.issue=無法更新標記的模板呼叫。用法將保持不變。
change.signature.usage.view.declarations.header=要重構的方法
change.signature.value.column.title=值
changeSignature.vararg.not.last=Rest 參數應當為方法簽名中的最後一個參數
checkbox.collapse.array.literals=陣列文字
checkbox.collapse.object.literals=物件文字
checkbox.collapse.one.line.function.literals=JavaScript 和 TypeScript 中的單行函式
checkbox.collapse.xml.literals=XML 文字
checkbox.enable=啟用
checkbox.move.simple.expressions.to.field.initializer=將簡單表達式移至欄位初始設定式
choose.base.component.title=選擇超類別
choose.class.to.import.title=要匯入的類別
choose.declaration.element=<html><body>選擇 TypeScript 宣告</body></html>
choose.destination.scope=選擇目標作用域
choose.field.type=選擇欄位類型
choose.implementing.class=<html><body>選擇 <b>{0}</b> 的實作(找到 {1})</body></html>
choose.implementing.method=<html><body>選擇 <b>{0}</b> 的實作(找到 {1} 個)</body></html>
choose.overriding.function=<html><body>選擇 <b>{0}</b> 的覆寫函式(找到 {1} 個)</body></html>
choose.overriding.method=<html><body>選擇 <b>{0}</b> 的覆寫方法(找到 {1} 個)</body></html>
choose.subclass=<html><body>選擇 <b>{0}</b> 的子類別(找到 {1})</body></html>
choose.super.class.title=選擇超類別
choose.super.classifier=<html><body>選擇 <b>{0}</b> 的超類別或接口(找到 {1})</body></html>
choose.super.field=<html><body>選擇 <b>{0}</b> 的 Super 欄位(找到 {1})</body></html>
choose.super.function=<html><body>選擇 <b>{0}</b> 的 Super 函式(找到 {1})</body></html>
choose.super.interface.title=選擇 Super 接口
choose.super.method=<html><body>選擇 <b>{0}</b> 的 Super 方法(找到 {1})</body></html>
class.0.cannot.be.created=無法建立目標類別 {0}，因為存在同名的限定元素
class.already.contains.field.warning=類別 ''{0}'' 已包含欄位 ''{1}''。\\n是否繼續?
class.already.contains.method.warning=類別 ''{0}''''已經 {1, choice, 1# 包含|2#繼承] 方法 ''{2}()''。\\n是否繼續?
class.chooser.not.available.in.dumb.mode=正在進行索引更新，選擇器不可用。
class.does.not.have.inheritors.in.current.project={0} 在當前專案中沒有繼承者
class.names={0,choice,1#類別|2#類別} {1}
class.template.title=類別
class.with.supers.template.title=包含 Super 的類別
code.vision.implementations.hint={0, choice, 1#1 個實作|2#{0,number} 個實作}
code.vision.inheritors.hint={0, choice, 1#1 個繼承者|2#{0,number} 個繼承者}
code.vision.overrides.hint={0, choice, 1#1 個覆寫|2#{0,number} 個覆寫}
code.vision.performance.watcher.notification.configure=組態…
code.vision.performance.watcher.notification.disable.code.vision=停用提示
code.vision.performance.watcher.notification.message=停用 Code Vision 提示可以通過減少 CPU 負載來提高性能。
code.vision.performance.watcher.notification.title=Code Vision 提示評估緩慢
codestyle.ui.field.prefix=欄位前綴 (&F):
codestyle.ui.file.name.style=檔案命名約定 (&N):
codestyle.ui.generated.jsdoc.use.types.checkbox=在 JSDoc 中包括類型 (&T)
codestyle.ui.property.prefix=屬性前綴 (&P):
collection.queried.but.not.update=查詢了集合 <code>#ref</code> 的內容，但從未寫入
collection.updated.but.not.queried=更新了集合 <code>#ref</code> 的內容，但從未被查詢
command.name.add.explicit.value=新增顯式值 ''{0}''
command.name.create.javascript.file=建立 JavaScript 檔案 {0}
command.name.create.typescript.file=建立 TypeScript 檔案 {0}
command.name.extract.named.type=提取已命名類型
command.name.import=匯入 {0}
complete.import.binding=完整的匯入綁定
complete.import.name=完整的匯入名稱
configurable.JSCodeCompletionConfigurable.display.name=JavaScript
configurable.JSSmartKeysConfigurable.display.name=JavaScript
configurable.JSTemplateLangConfigurable.display.name=模板
configurable.MyConfigurable.display.name=JSX
configure.code.completion.settings=組態程式碼補全設定
configure.node.interpreter.path=組態 Node.js 路徑…
copying.files=正在複製檔案
create.button.text=建立(&C)
create.class.interfaces.label=接口(&I):
create.class.name.label=名稱(&N):
create.class.ok.button.text=建立
create.class.package.label=軟體套件:
create.class.superclass.label=超類別(&S):
create.class.template.label=模板(&T):
create.constructor.dialog.title=建立建構函式
create.field.dialog.title=建立欄位
create.file.name=建立檔案 ''{0}''
create.file.name.with=使用 {1} 建立檔案 ''{0}''
create.file.name.with.and=使用 {1} 和 {2} 建立檔案 ''{0}''
create.js.file.description=從指定的模板建立 JavaScript 檔案
create.method.dialog.title=建立方法
create.mobile.view=建立檢視 ''{0}''
create.react.app.description=<a href="https://github.com/facebookincubator/create-react-app">建立 React 套用</a>是官方支援的一種建立單頁 React 套用程序的新方法。它提供了沒有組態的現代建置設定。
create.react.app.name=React
create.react.app.scripts.version=腳本版本 (&V)
create.react.app.typescript.checkbox=建立 TypeScript 專案(&T)
create.ts.file.description=建立新的 TypeScript 檔案
custom.template.variables=自訂模板變數(&C):
custom.variables.step.title.label.text=模板 ''{0}'' 中的自訂變數 (&C):
declare.event.0=宣告事件 ''{0}''
declare.static=宣告 static(&S)
diagram.element.not.found={0} (未找到)
dialog.kind.0.file={0} 檔案
dialog.message.cannot.compile.typescript.config.file.incorrect=無法編譯 TypeScript。組態檔案不正確。
dialog.message.cannot.create.argument.stubs.invoked.method.function=無法建立實參存根: 呼叫的方法不是函式
dialog.message.cannot.determine.package.json.directory=無法確定 package.json 目錄
dialog.message.cannot.find.file=找不到檔案 {0}
dialog.message.cannot.find.module.for.import=無法建置用於匯入的模組路徑
dialog.message.cannot.find.module.types=找不到模組 @types/{0}
dialog.message.cannot.find.npx.bundled.with=找不到使用 {0} 捆綁的 npx
dialog.message.cannot.infer.type.new.parameter=無法推斷新參數的類型
dialog.message.cannot.locate.wrapper.config.file=找不到包裝器組態檔案
dialog.message.cannot.proceed.when.having.non.read.usages.in.embedded.expressions=嵌入式表達式中有非讀取用法時，無法繼續
dialog.message.cannot.propagate.variable=無法傳播變數: {0}
dialog.message.cannot.propagate.when.having.usages.declarations.in.different.files=用法和宣告位於不同檔案中時，無法傳播
dialog.message.cannot.transform.object.array.destructuring.patterns.for.same.element=無法為相同的元素轉換物件和陣列解構模式
dialog.message.command.cancelled=指令 ''{0}'' 已取消
dialog.message.command.finished.with.exit.code=指令 ''{0}'' 已完成，退出程式碼為 {1}。Stdout:\\n{2}\\n\\nstderr:\\n{3}
dialog.message.command.supported.by={1} 不支持指令 ''{0}''
dialog.message.command.timed.out=指令 ''{0}'' 超時
dialog.message.component.name=元件名稱:
dialog.message.expression.indexed.by.non.numeric.value=表達式使用非數字值編制索引
dialog.message.failed.to.download.0.1=無法下載 {0}。{1}
dialog.message.incomplete.destructuring.pattern.encountered.in.code=在程式碼中遇到不完整的解構模式
dialog.message.incorrect.path.to.typescript.package=typescript 軟體套件的路徑不正確
dialog.message.invalid.npm.package=無效的 {0} 軟體套件: 無此類別檔案或目錄
dialog.message.invalid.npx.command=無效的 npx 指令
dialog.message.invalid.package.file.specified.but.directory.with.package.json.expected={0} 軟體套件無效: 指定了一個檔案，但應為包含 package.json 的目錄
dialog.message.invalid.package.no.such.directory=無效的 {0} 軟體套件: 無此類別目錄
dialog.message.no.npm.script=無 ''{0}'' npm 腳本
dialog.message.no.path.to.package.json.found=未找到 package.json 的路徑。
dialog.message.no.results.for.after={1} 之後沒有 {0} 的結果
dialog.message.no.such=沒有這樣的 {0}
dialog.message.node.interpreter.unspecified.error.text=請指定 Node.js 解釋器
dialog.message.package.yarn.installed.package.format.yarn.relative.path.to.package.json.package.name={0}軟體套件: Yarn 安裝的軟體套件格式為 ''yarn:[package.json 的相對路徑]:[軟體套件名稱]''。
dialog.message.please.select.distribution=請選擇分發版
dialog.message.please.specify.npm.scripts.to.run=請指定要執行的 npm 腳本
dialog.message.please.specify.package.json=請指定 package.json
dialog.message.please.specify.package.json.correctly=請正確指定 package.json
dialog.message.please.specify.stylelint.package.correctly=正確指定 Stylelint 軟體套件: 找不到 Stylelint 二進制檔案
dialog.message.please.specify.wsl.path.to.node.js.interpreter=請指定 WSL 中安裝的 Node.js 解釋器的路徑
dialog.message.some.usages.cannot.be.updated.properly=有些用法無法正常更新。\\n匯入和匯出中的用法、字串用法或動態參照無法取代為解構。
dialog.message.some.usages.cannot.be.updated.properly.wrong.access=有些用法無法正常更新。\\n無法取代不按名稱存取屬性的用法或者不按索引存取元素的用法。
dialog.message.transforming.multiple.nested.patterns.not.supported=陣列解構不支持轉換多個嵌套模式
dialog.message.unspecified=未指定的 {0}
dialog.message.unspecified.package=未指定 {0} 軟體套件
dialog.message.unspecified.package.name=未指定軟體套件名稱。
dialog.message.unspecified.suite.name=未指定的套件名稱
dialog.message.unspecified.test.name=未指定的測試名稱
dialog.message.unsupported.destructuring.container=不支持的解構容器: {0}
dialog.message.usages.search.was.interrupted=用法搜尋被中斷
dialog.message.variables.from.destructuring.pattern.have.no.usages=來自於解構模式的變數沒有用法
dialog.message.write.usages.cannot.be.updated.with.destructuring=寫入用法無法通過重構進行更新
dialog.title.add.classes=新增類別
dialog.title.cannot.convert=無法轉換
dialog.title.cannot.introduce.new.interface=無法引入新接口
dialog.title.cannot.propagate=無法傳播
dialog.title.configure.coding.assistance.for.node.js.api=組態 Node.js API 編碼輔助
dialog.title.download.error=下載錯誤
dialog.title.edit.run.debug.configuration=編輯執行/偵錯組態: ''{0}''
dialog.title.error.details=錯誤詳細資訊
dialog.title.grunt.settings=Grunt 設定
dialog.title.gulp.settings=Gulp 設定
dialog.title.main.file=主檔案
dialog.title.missing.dependencies=缺少相依項
dialog.title.move.members=移動成員
dialog.title.new.javascript.file=新增 JavaScript 檔案
dialog.title.new.typescript.file=新增 TypeScript 檔案
dialog.title.output.directory=輸出目錄
dialog.title.select.navigation.target=選擇導覽目標
dialog.title.select.parameters.to.convert.to.parameter.properties=選擇要轉換為參數-屬性的參數
dialog.title.select.targets.to.convert.to.class=選擇要轉換為類別的目標
dialog.title.wsl.node.interpreter={0} WSL Node 解釋器
dialog.title.wsl.node.interpreter.edit=編輯
dialog.title.wsl.node.interpreter.edit.add=新增
directory.already.contains.file=目錄 ''{0}'' 已包含檔案 ''{1}''
duplicate.parameter.name=重複的參數名稱: {0}
ecmascript.6.or.higher=ECMAScript 6 或更高版本
editor.notification.label.enable.babel.file.watcher.question=是否啟用 File Watcher 以使用 Babel 將 ECMAScript 6 轉換為 ECMAScript 5?
element.name.anonymous=<匿名>
element.name.default=<預設>
enable.notifications.about.installing.dependencies.from.package.json=啟用有關從 package.json 安裝相依項的通知
entity.in.parent.description={0} ({1} 內)
env.variable.empty={0} 為空
env.variable.undefined={0} 未定義
error.not.available.in.javascript.code={0} 在 JavaScript 程式碼中不可用
error.wrong.caret.position.method.name=文字游標應置於要重構的方法的名稱處。
es6.auto.import.options.completion.add.imports=自動新增 JavaScript import
es6.auto.import.options.title=TypeScript / JavaScript
es6.change.to.default.fix=對 ''{0}'' 使用預設匯入
es6.change.to.named.import.fix=對 ''{0}'' 使用命名匯入
es6.changeSignature.call.value.not.allowed=參數 ''{0}'' 不允許使用呼叫中的值。因為沒有為前面的參數指定它。
es6.changeSignature.no.call.value=新參數 ''{0}'' 已新增。\\n指定要用於此方法的所有現有呼叫的預設值或值。
es6.code.style.path.mapping.always=始終
es6.code.style.path.mapping.different.paths=僅在指定路徑以外的檔案中
es6.code.style.path.mapping.never=從不
es6.default.export.not.declared=未在匯入的模組中宣告預設匯出
es6.extract.super.destination.label=目標檔案 (&D):
es6.extract.super.different.name.expected=應為不同名稱
es6.extract.super.members.in.interface=新接口中的成員
es6.extract.super.members.in.superclass=新超類別中的成員
es6.extract.super.overload.declaration.without.implementation.conflict=類別中不允許沒有實作的多載宣告 {0}
es6.generate.index.action=生成 index.js/index.ts
es6.generate.index.action.description=生成 index.js/index.ts
es6.import.options.blacklist.title=不從指定路徑或路徑模式匯入:
es6.import.options.exts.help=此選項用於組態 import 語句中的副檔名。<br><br>選擇“自動”時，IDE 會向 vue 檔案、來自在 package.json 中具有 "type": "module" 的專案的檔案，以及擴展名為 .mjs 或 .cjs 的檔案的名稱新增副檔名。<br><br>選擇“始終”時，IDE 會始終向檔名新增副檔名。<br><br>選擇“從不”時，IDE 會始終使用不帶副檔名的檔名。
es6.import.options.not.import.help=此選項會組態 IDE 在自動匯入符號期間跳過的確切路徑。相反，IDE 將尋找替代路徑來匯入符號。路徑應符合 glob 模式規則。
es6.import.options.paths=使用路徑別名:
es6.import.options.paths.help=此選項用於組態 import 語句中使用的路徑樣式。<br><br>選擇“始終”時，IDE 會始終使用來自 webpack、vite 或 jsconfig.json 組態的別名。<br><br>選擇“僅在指定路徑之外的檔案中”時，IDE 會針對為之定義了別名的檔案之間的匯入使用相對路徑。在所有其他檔案中，使用路徑映射。<br><br>選擇“從不”時，則從不使用別名。
es6.insert.await.fix=插入 await
es6.missing.await.report.for.promises=報告 return 語句中的 promise
es6.missing.await.report.for.promises.hint=在異步函式呼叫前插入 'await' 有助於 V8 提供異步堆疊追蹤
es6.move.module.members.cannot.detect.js.language=目標檔案不是 JS 檔案
es6.move.module.members.destination.contains.default.export=目標模組包含預設匯出
es6.move.module.members.destination.does.not.support.jsx={0} 包含 JSX 標籤，但目標語言不支持這些標籤
es6.move.module.members.destination.not.es6=目標檔案 {0} 不是 ES6 模組
es6.move.module.members.has.local.usage.message=檔案 {1} 中使用未匯出的 {0}
es6.move.module.members.incompatible.language=目標模組具有不相容的語言
es6.move.module.members.non.es6.module.usage=在非 ES6 模組的檔案 {1} 中使用 {0}
es6.move.module.members.refactoring.create.file=建立檔案
es6.move.module.members.refactoring.create.file.message=檔案 {0} 不存在。\\n是否要建立?
es6.move.module.members.refactoring.dialog.error.incorrect.module=目標模組不正確
es6.move.module.members.refactoring.dialog.error.invalid.file.name=目標檔名在此作業系統中無效
es6.move.module.members.refactoring.dialog.error.modules.same=源模組和目標模組應不同
es6.move.module.members.refactoring.dialog.error.no.script.tag=目標檔案不包含腳本標籤
es6.move.module.members.refactoring.dialog.error.no.selected.items=沒有要移動的選定成員
es6.move.module.members.refactoring.dialog.field.from=從:
es6.move.module.members.refactoring.dialog.field.to=到:
es6.move.module.members.refactoring.dialog.move.member.to=成員移動至
es6.move.module.members.refactoring.file.does.not.exist=檔案 {0} 不存在
es6.move.module.members.refactoring.name=移動模組成員
es6.move.module.members.references.local.message=選擇的 {0} 參照非匯出 {1}
es6.move.module.members.references.unresolved.import.message=選擇的 {0} 參照未解析匯入 {1}
es6.move.module.members.syntax.errors=移動 {0} 將引入語法錯誤，因為目標語言不同於源語言
es6.move.module.members.table.title=要移動的成員
es6.prefer.short.import.name=可以縮短匯入
es6.redundant.await.report.for.promises=報告 promise
es6.redundant.await.report.for.promises.hint=總是報告 'return await' 為冗餘，但這會破壞 V8 的異步堆疊追蹤功能
es6.replace.import.action.name=取代為 {0}
es6.replace.import.family.name=取代為較短的路徑
es6.validate.import.error=無法解析符號 ''{0}''
es6.validation.message.const.variable.without.initializer=不允許使用無初始設定式的 'const' 變數
escape.jsdoc.copy.pasted.text=在複製和貼上時轉義 JSDoc 前導星號
escape.pasted.text=在貼上字串文字時轉義文本
eslint.action.fix.problems.description=通過呼叫 'eslint --fix' 修正 ESLint 問題
eslint.additional.rules.directory.field.name=其他規則目錄
eslint.code.style.apply.message=套用 ESLint 的程式碼樣式?
eslint.code.style.apply.text=是
eslint.code.style.dismiss.text=否
eslint.configurable.additionalRulesDir.browseDialogTitle=選擇 ESLint 其他規則目錄
eslint.configurable.additionalRulesDir.label=其他規則目錄 (&R):
eslint.configurable.config.autoSearch.description.bodyInnerHtml=ESLint 將在要 lint 的檔案的目錄中以及連續的父目錄中尋找 .eslintrc.* 和 package.json 檔案，直至尋找到檔案系統的根目錄。<div style="padding-top:8px">要使用 package.json，請將您的組態新增到 <code>eslintConfig</code> 屬性下。</div>
eslint.configurable.config.select.config.text=選擇 ESLint 組態檔案(*.eslintrc.*)
eslint.configurable.eslintPackage.label=ESLint 軟體套件(&E):
eslint.configurable.extraOptions.label=額外 eslint 選項 (&O):
eslint.configurable.label.working.directories=工作目錄(&W):
eslint.configurable.working.dir.field.empty.text=由最近的 .eslintrc 或 .eslintignore 檢出
eslint.configurable.working.directories.comment=<html>路徑或 <a href='https://github.com/isaacs/node-glob#glob-primer'>glob 模式</a>，以分號分隔。為自動檢測留空。</html>
eslint.configuration.file.field.name=ESLint 組態檔案
eslint.error.package.directory.expected=應為軟體套件目錄
eslint.files.pattern.comment=<html>使用 <a href=''https://github.com/isaacs/node-glob#glob-primer''>glob 模式</a>，例如，<code>{**/*,*}.{js,ts}</code></html>
eslint.fix.problems.family.name={0}: 修復當前錯誤
eslint.fix.problems.text.current={0}: 修復當前錯誤
eslint.fix.problems.text.with.error.code={0}: 修復 ''{1}''
eslint.inspections.error.can.not.parse.message=無法解析訊息，應為 JSON 物件，但實際為: {0}
eslint.inspections.error.messages.not.array=訊息不是陣列: {0}
eslint.inspections.error.unexpected.language.service.response=意外的語言服務響應: {0}
eslint.inspections.error.unknown.message.severity=未知的訊息嚴重性: {0}\\n主體:\\n{1}
eslint.run.for.files.label=為檔案執行(&F):
eslint.run.on.save=儲存時執行 eslint --fix(&U)
eslint.run.on.save.auto.configuration.comment=自動 ESLint 組態
eslint.run.on.save.checkbox.on.actions.on.save.page=執行 eslint --fix
eslint.run.on.save.disabled.comment=已停用 ESLint 整合
eslint.run.on.save.link.enable.eslint=啟用 ESLint…
eslint.run.on.save.manual.configuration.comment=手動 ESLint 組態
eslint.version.0.is.not.supported.please.upgrade.eslint=ESLint 版本 {0} 不受支援。請升級 ESLint。
extract.0.turn.refs=提取 {0} 並盡量使用 (&T)
extract.constant.type=類型(&T):
extract.function.declare.functional.expression=宣告函式表達式(&F)
extract.function.function=函式
extract.function.name=名稱(&N):
extract.function.parameters=參數
extract.function.return.type=返回值類型(&T):
extract.function.signature.preview=簽名預覽
extract.interface.command.name=提取接口
extract.method.declare.static=宣告 static(&S)
extract.subclass.command.name=從 {1} 提取子類別 {0}
extract.type.alias.command.name=提取類型別名
failed.to.download=無法下載
field.initializer.is.not.specified=未指定欄位初始設定式
file.name.masks.to.skip.from.analysis=要在分析中排除的檔名遮罩:
filetype.actionscript.description=ActionScript
filetype.ecmascript6.description=ECMAScript 6
filetype.flow.description=Flow JS
filetype.flow.display.name=Flow JS
filetype.javascript.description=JavaScript
filetype.js.testing.snapshot.description=JavaScript 測試快照(Jest)
filetype.js.testing.snapshot.display.name=JavaScript 測試快照
filetype.jshint.config.description=JSHint 組態
filetype.jshint.config.display.name=JSHint 組態
filetype.jsx.description=React JSX
filetype.jsx.display.name=React JSX
filetype.typescript.config.description=TypeScript 組態
filetype.typescript.config.display.name=TypeScript 組態
filetype.typescript.description=TypeScript
filetype.typescript.jsx.description=TypeScript JSX
filetype.yarn.lock.description=Yarn lock
filetype.yarn.lock.display.name=Yarn Lock
find.usages.of.base.class={1} 的方法 {0}\\n覆寫 {2} 的方法。\\n要{3}基方法嗎?
find.usages.of.base.interface={1} 的方法 {0}\\n實作 {2} 的方法。\\n要{3}基方法嗎?
flow.js.get.type=Flow JS:Get 類型
flow.js.show.settings=組態 Flow…
flow.js.widget.display.name=Flow JS
flow.js.widget.name=Flow
flow.show.error.details=顯示錯誤詳情
function.names={1}{0,choice,1#函式|2#函式} 
function.returns=函式返回值類型
function.returns.description=函式返回值類型
generate.constructor.overloads.and.fields.chooser.title=選擇要使用的多載和要初始化的欄位
generate.delegate.method.conflict.message=無法通過不同的屬性為同名成員生成委託
generate.delegate.method.conflict.message.title=無法生成委託
generate.filter.button.description=在列表中顯示 {0} 
generate.filter.button.tooltip=顯示 {0}
generate.filter.fields=欄位和屬性
generate.filter.indexers=索引器
generate.filter.methods=方法
generate.to.string.chooser.title=選擇要在 toString 函式中使用的欄位
generating.0=正在生成 {0}
generation.bindable.event=可綁定事件(&B):
generation.event.constant=事件常數(&E):
group.Editor.JSLibrariesMenu.description=選擇要與當前檔案一起使用的 JavaScript 庫
group.Editor.JSLibrariesMenu.text=使用 JavaScript 庫
grunt.before.run.task=執行 Grunt 任務
grunt.before.run.task.descr=執行 Grunt {0, choice, 0#任務|1#任務 |2#任務 }{1} [{2}]
grunt.gruntfile.not.found=未找到 Gruntfile
grunt.rc.arguments.label=實參(&R):
grunt.rc.environmentVariables.label=環境(&E):
grunt.rc.gruntCliPackage.label=軟體套件 grunt-cli (&P):
grunt.rc.gruntfile.browseDialogTitle=選擇 Gruntfile
grunt.rc.gruntfile.label=Gruntfile (&F):
grunt.rc.nodeInterpreter.label=Node 解釋器(&I):
grunt.rc.nodeOptions.label=Node 選項(&O):
grunt.rc.tasks.label=任務(&T):
grunt.task.title=Grunt 任務
grunt.unspecified.gruntfile=未指定 Gruntfile
gulp.before.run.task=執行 gulp 任務
gulp.before.run.task.descr=執行 gulp {0, choice, 0#任務|1#任務 |2#任務 }{1} [{2}]
gulp.gulpfile.not.found=未找到 Gulpfile
gulp.gulpfile.unspecified=未指定 Gulpfile
gulp.rc.arguments.label=實參(&R):
gulp.rc.environmentVariables.label=環境(&E):
gulp.rc.gulpPackage.label=Gulp 軟體套件(&G):
gulp.rc.gulpfile.browseDialogTitle=選擇 gulpfile.js
gulp.rc.gulpfile.label=Gulpfile (&F):
gulp.rc.nodeInterpreter.label=Node 解釋器(&I):
gulp.rc.nodeOptions.label=Node 選項(&O):
gulp.rc.tasks.label=任務(&T):
gulp.task.title=Gulp 任務
header.declarations.to.be.refactored=要重構的宣告
icon.icons.nodes.readonlyMark.tooltip=唯讀
ignore.unused.option.all=全部
ignore.unused.option.before.used=使用前
ignore.unused.option.none=無
implement.members.abstract=實作 abstract 成員
import.options.find.more.configuration.options=在<a>程式碼樣式</a>中尋找更多組態選項
initialize.fields.intention.visibility=可見性:
inlay.hints.usages.text={0,choice, 0#無用法|1#1 個用法|2#{0,number} 個用法}
inlay.parameters.angular.show.names.for.all.args=Angular HTML 模板中的文字和命名物件參數。
inlay.parameters.angular.show.names.for.pipes=<a href='https://angular.io/guide/pipes'>Angular HTML 模板中的管道。</a>
inlay.parameters.js.only.show.names.for.all.args=文字和非文字實參、呼叫表達式、物件和陣列初始設定式。
inlay.parameters.js.only.show.names.for.pipes=<a href='https://github.com/tc39/proposal-pipeline-operator'>管道運算符中的參數。</a>
inlay.parameters.js.only.show.names.for.tagged=<a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates'>標記模板中的實參。<a><br>此設定僅對非文字實參生效，並且僅在啟用“非文字實參”選項時可用。
inlay.parameters.js.param.hints.show.names.for.all.args=方法呼叫中的文字和命名物件參數。
inlay.parameters.js.param.hints.show.names.for.tagged=標記模板中的實參。
inlay.parameters.vuejs.show.names.for.all.args=文字和命名物件。
inlay.parameters.vuejs.show.names.for.filters=<a href='https://v2.vuejs.org/v2/guide/filters.html'>篩選器(Vue 2)。</a>
inline.cannot.inline.has.supers=無法內聯擴展其他類型的 {0} 
inline.cannot.inline.references.this.type=無法內聯參照 'this' 類型的接口
inline.type.used.in.reference.list=無法在''{0}'' 列表中內聯用法
insert.class.fix.name=新增類別名限定符
insert.new.keyword.fix.name=插入新關鍵字
insert.this.keyword.fix.name=新增 this 限定符
inspection.NodeCoreCodingAssistanceInspection.no.coding.assistance.message=Node.js 的編碼輔助已被停用
inspection.message.installed.version.doesn.t.match.version.range=安裝的版本 {0} 與版本範圍 {1} 不符合
inspection.message.package.installed=未安裝 {0} 軟體套件
inspection.message.package.version.specified=未指定軟體套件版本
inspection.message.reference.includes.files.outside.project=參照包括專案範圍之外的檔案
inspection.message.sm.test.runner.magnitude.assertion.failed.title=斷言失敗
inspection.update.package_json.dependency.action.text=將 ''{0}'' 更新到最新版本 {1}
inspection.update.package_json.dependency.message=有可用的 ''{0}'' 新版本: {1}
intellilang.tagged.literal.expression.border.title=模板標籤
intellilang.tagged.literal.injection.name.label=模式:
intention.category.ecmascript6=JavaScript/ECMAScript 6
intention.category.javascript=JavaScript
intention.category.react=React
intention.category.typescript=TypeScript
intention.family.name.add.required.property=新增所需的屬性
intention.family.name.generate.prop.types=為元件生成 propTypes
intention.family.name.introduce.parameter.properties.for.unused.parameters=轉換為參數屬性
intention.family.name.run.npm.install=執行 'npm install'
intention.family.name.select.in.test.tree=在測試樹中選擇
intention.family.name.suppress.with.ts.ignore=使用 @ts-ignore 禁止
intention.family.name.surround.with.tag=使用標記包圍
intention.name.add.file.to.tsconfig=將檔案 ''{0}'' 新增到 tsconfig.json
intention.name.create.library.with.files.outside.project=使用專案外部的檔案建立庫
intention.name.import.augmentation=匯入擴大 {0}
intention.name.loading.service.fixes=正在載入服務修正…
intention.name.navigate.to=導覽到 {0}
intention.name.run.npm=執行 ''{0}''
intention.name.surround.with.tag=使用 <{0}> 包圍
interface.cannot.be.extracted.from.enum=無法從枚舉中提取接口
interface.cannot.be.extracted.from.type.alias=無法從類型別名中提取接口
interface.function.declaration.should.have.no.body=接口函式宣告不應有本體
interface.should.have.no.variable.declarations=接口不應有變量宣告
interface.template.title=接口
introduce.constant.target.class=目標類別(&A):
introduce.field.class.constructor=類別建構函式(&C)
introduce.field.current.method=當前方法(&M)
introduce.field.declaration=欄位宣告(&D)
introduce.field.initialize.in=初始化位置
introduce.field.type=類型(&T):
introduce.parameter.optional=可選參數(&O)
introduce.parameter.type=類型(&T):
introduce.variable.const=const(&C)
introduce.variable.declaration=變數宣告
introduce.variable.let=let(&L)
introduce.variable.make.constant=設為常數(&C)
introduce.variable.var=var(&V)
introduce.variable.var.of.type=類型的變數(&T):
invalid.field.type.expression=無效欄位類型: ''{0}''
invalid.identifier.value.0=無效關鍵字: ''{0}''
invalid.parameter.type.expression=參數類型 ''{0}'' 無效
invalid.return.type.expression=返回值類型 ''{0}'' 無效
item.already.exists={0} {1} 已存在
javascript.abstract.class.can.not.be.instantiated.message=無法實例化抽象類別
javascript.ambient.declaration.const.should.be.primitive=環境上下文中的 'const' 初始設定式必須是基元文字或文字枚舉參照
javascript.ambient.declaration.should.have.no.body=環境宣告不應有本體
javascript.ambient.declaration.should.have.no.initializer=環境宣告不應有初始設定式
javascript.argument.type.mismatch=實參類型 {1} 不可分配給參數類型 {0}
javascript.argument.types.mismatch=實參類型與參數不符合
javascript.assign.parameter.to.field.intention.name=分配參數 ''{0}'' 給欄位
javascript.assigned.expression.type.mismatch=分配的表達式類型 {1} 不可分配給類型 {0}
javascript.assume.uppercase.functions.to.be.constructors=假設只有大寫的函式是建構函式
javascript.auto.import.options.add.imports.on.the.fly=動態明確 import
javascript.auto.import.options.add.on.code.completion=程式碼補全時
javascript.auto.import.options.show.popup=包含自動匯入工具提示
javascript.badcharacter=錯誤字元
javascript.blockcomment=塊註釋
javascript.braces=大括號
javascript.brackets=中括號
javascript.cannot.return.expression.from.function.with.void.result.type=無法從結果類型為 void 的函式返回值
javascript.cannot.return.expression.from.function.with.void.result.type.fix=移除返回值
javascript.change.jsdoc.type.family.name=更改 JSDoc 中元素的類型
javascript.change.language.level.family=更改 JavaScript 語言版本
javascript.change.language.level.message=更改 JavaScript 語言版本為 {0}
javascript.change.signature.invalid.function.name.0=無效函式名稱: ''{0}''
javascript.change.signature.invalid.parameter.declaration=無效參數: ''{0}''
javascript.changeSignature.call.value.not.allowed=參數 ''{0}'' 不允許使用預設值。因為沒有為前面的參數指定它。
javascript.changeSignature.no.call.value=新的必選參數 ''{0}'' 已新增。\\n指定要用於此方法的所有現有呼叫的預設值。
javascript.check.global.definitions=檢查全域作用域內的指派
javascript.class=類別
javascript.comma=逗號
javascript.completion.several.definitions=(多個定義)
javascript.constructor.call.without.new.message=不帶 <code>new</code> 的建構函式呼叫
javascript.constructor.with.lower.case.name.used.message=建構函式名稱通常以大寫字母開頭。拼寫錯誤?
javascript.create.class.intention.name=建立類別 ''{0}''
javascript.create.constant.field.intention.name=建立常數欄位 ''{0}''
javascript.create.constant.holding.arrow.function.intention.name=建立含有常數 ''{0}'' 的箭頭函式
javascript.create.constant.intention.name=建立常數 ''{0}''
javascript.create.constructor.intention.name=在 ''{0}'' 類別中建立建構函式
javascript.create.event.handler.intention.name=建立事件處理程序 ''{0}''
javascript.create.field.holding.arrow.function.intention.name=建立含有欄位 ''{0}'' 的箭頭函式
javascript.create.field.intention.name=建立欄位 ''{0}''
javascript.create.function.intention.family=建立 JavaScript 函式或方法
javascript.create.function.intention.name=建立函式 ''{0}''
javascript.create.function.property.intention.name=建立函式屬性 ''{0}''
javascript.create.get.property.intention.name=建立 ''get'' 屬性 ''{0}''
javascript.create.interface.intention.name=建立接口 ''{0}''
javascript.create.method.intention.name=建立方法 ''{0}''
javascript.create.property.holding.arrow.function.intention.name=建立含有屬性 ''{0}'' 的箭頭函式
javascript.create.property.intention.name=建立屬性 ''{0}''
javascript.create.set.property.intention.name=建立 ''set'' 屬性 ''{0}''
javascript.create.variable.holding.arrow.function.intention.name=建立含有變數 ''{0}'' 的箭頭函式
javascript.create.variable.intention.family=建立 JavaScript 變數或屬性
javascript.create.variable.intention.name=建立變數 ''{0}''
javascript.declare.variable.in.previous.var.statement.intention.family=將 var 宣告插入之前的 var 語句
javascript.declare.variable.in.previous.var.statement.intention.name=將 ''{0}'' 的 var 宣告插入之前的 var 語句
javascript.declare.variable.intention.family.name=插入 var 宣告
javascript.declare.variable.intention.name=為 ''{1}'' 插入 {0} 宣告
javascript.deprecated.symbol.replace.fix=將棄用的程式碼取代為 {0}
javascript.deprecated.symbol.replace.fix.family=將棄用的程式碼取代為建議的取代
javascript.deprecated.symbol.used.name.message=使用了棄用的符號，請查閱文檔，以獲取更好的替代性 #loc
javascript.deprecated.symbol.used.name.message2=自版本 {0} 符號被標記為棄用以來，使用 {1} 作為取代用 #loc
javascript.destructuring.initializer=初始設定式 {0}
javascript.destructuring.variable.only=僅解構變數
javascript.doccomment=文檔註釋
javascript.doctag=文檔標籤
javascript.doctagvalue=文檔標記值
javascript.dot=點
javascript.element.default.instead.named=使用了預設匯入而不是命名匯入
javascript.element.is.not.accessible.message=元素不可存取 #loc
javascript.element.need.to.be.exported=未匯出元素
javascript.element.need.to.be.imported=未匯入元素
javascript.element.need.to.be.included.to.config=tsconfig.json 中不包含相應檔案
javascript.equality.comparison.with.coercion.display.name=相等運算符可能導致類型強制
javascript.equality.comparison.with.coercion.error.string=比較 #ref 可能導致意外類型強制 #loc
javascript.equality.comparison.with.coercion.family.name=取代但不進行類型強制
javascript.equality.comparison.with.coercion.fix=取代為 ''{0}''
javascript.equality.comparison.with.coercion.option.always=所有
javascript.equality.comparison.with.coercion.option.always.except.null=與 null 或 typeof 比較時除外
javascript.equality.comparison.with.coercion.option.only.suspicious=僅可疑表達式
javascript.equality.comparison.with.coercion.options.label=醒目提示顯示 '==' 和 '!=' 的用法:
javascript.expected.class.or.descendant=應為類別 {0} 或後代
javascript.export.only.member=元素僅匯出
javascript.exported.class=匯出的類別
javascript.exported.function=匯出的函式
javascript.exported.variable=匯出的變數
javascript.expression.type.implicitly.coerced.to.unrelated.type=表達式類型 {1} 隱式強制為不相關類型 {0}
javascript.extract.method.title=提取函式
javascript.falsy.typeof.guard=''typeof'' 檢查始終為 false: {0}'' 始終具有類型 ''{1}''
javascript.file=JavaScript 檔案
javascript.find.usages.destructuring.target.dialog=速記解構變數使用 {0} 初始化。\\n您想尋找哪些用法?
javascript.fix.add.enum.values=新增枚舉值
javascript.fix.add.override.modifier=新增覆寫修飾符
javascript.fix.add.string.enum.values=新增字串枚舉值
javascript.fix.change.parameter.type=參數 ''{0}'' 類型更改為 ''{1}''
javascript.fix.change.type=''{0}'' 類型更改為 ''{1}''
javascript.fix.create.class.component.jsx.family=建立類別元件
javascript.fix.create.class.component.jsx.name=建立類別元件 ''{0}''
javascript.fix.create.constructor.invoke.super=建立符合 super 的建構函式
javascript.fix.create.extends=使 ''{0}'' 擴展 ''{1}''
javascript.fix.create.function.component.jsx.family=建立函式元件
javascript.fix.create.function.component.jsx.name=建立函式元件 ''{0}''
javascript.fix.create.implements=使 ''{0}'' 實作 ''{1}''
javascript.fix.create.inheritor.family=從 super 類型繼承
javascript.fix.create.invoke.super=插入超類別建構函式呼叫
javascript.fix.create.parameter=建立參數 ''{0}''
javascript.fix.generate.argument.stubs=生成實參存根
javascript.fix.implement=實作 {0}
javascript.fix.implement.chooser.all=所有類別
javascript.fix.implement.chooser.title=從中實作成員
javascript.fix.implement.family=在派生類別中實作
javascript.fix.implement.members=實作成員
javascript.fix.implement.methods=實作方法
javascript.fix.initialize.parameter=初始化參數
javascript.fix.message.change.parameters.to.expected=將這些參數更改為預期參數
javascript.fix.message.change.return.type.to.expected=將返回值類型更改為預期類型
javascript.fix.optimize.imports=最佳化 import
javascript.fix.property.spelling.family=修復屬性名稱中可能的拼寫錯誤
javascript.fix.property.spelling.text=將拼寫調整為 ''{0}''
javascript.fix.remove.abstract.keyword=移除 'abstract' 修飾符
javascript.fix.remove.access.modifier=移除存取修飾符
javascript.fix.remove.circular.dependency=移除迴圈相依關係
javascript.fix.remove.comma=移除逗號
javascript.fix.remove.constructor=移除建構函式
javascript.fix.remove.default=移除預設子句
javascript.fix.remove.dynamic.modifier=移除動態修飾符
javascript.fix.remove.externally.visible.symbol=移除外部可見符號
javascript.fix.remove.final.modifier=移除 final 修飾符
javascript.fix.remove.initializer=移除初始設定式
javascript.fix.remove.modifier=移除修飾符
javascript.fix.remove.namespace.reference=移除命名空間參照
javascript.fix.remove.override.modifier=移除覆寫修飾符
javascript.fix.remove.parameter=移除參數
javascript.fix.remove.parameters=移除參數
javascript.fix.remove.setter.parameter.initializer=移除參數預設值
javascript.fix.remove.static.modifier=移除 static 修飾符
javascript.fix.remove.type.reference=移除類型參照
javascript.fix.remove.virtual.modifier=移除虛擬修飾符
javascript.fix.remove.visibility.modifier=移除可見性修飾符
javascript.fix.set.element.visibility=將 {0} 設為 {1}
javascript.fix.set.method.return.type=使 ''{0}'' 返回 ''{1}''
javascript.fix.visibility.family=修復可見性問題
javascript.formatting.options.panel.comments=註釋
javascript.formatting.options.panel.naming.conventions=命名約定
javascript.function.arrow=箭頭函式
javascript.global.decorator=裝飾器
javascript.global.function=全域函式
javascript.global.variable=全域變數
javascript.ignore.unused.catch.parameters=忽略未使用的 catch 參數
javascript.ignore.unused.function.parameters=忽略未使用的參數:
javascript.illegal.variable.type.void=非法變數類型: 'void'
javascript.implement.all.interfaces=實作所有成員
javascript.implement.members.abstract=實作 abstract 成員
javascript.implement.required.interfaces=實作所需的所有成員
javascript.import.options.use.resource.root=使用相對於專案、資源或來源根目錄的路徑
javascript.incorrect.array.type.in.for-in=陣列鍵類型應為字串
javascript.incorrect.variable.type.mismatch=變數類型 {1} 不可分配給類型 {0}
javascript.indexed.property.instead.of.computed.name=索引屬性存取中括號位於單獨的行中。是否應為計算的名稱?
javascript.initializer.type.mismatch=初始設定式類型 {1} 不可分配給變數類型 {0}
javascript.inline.element.is.not.used={0} 從未使用
javascript.insert.cast.fix=插入轉換
javascript.insert.generic.wrapper.fix.family.name=使用泛型類型包裝
javascript.insert.primitive.wrapper.fix.family.name=使用基元類型包裝
javascript.insert.symbol.fix=插入{0}
javascript.insert.wrapper.fix.text=使用 ''{0}'' 包裝
javascript.instance.member.function=執行個體成員函式
javascript.instance.member.is.not.accessible.message=執行個體成員不可存取 #loc
javascript.instance.member.variable=執行個體成員變數
javascript.intention.add.default.export.family.name=新增預設匯出
javascript.intention.add.export.family.name=新增匯出
javascript.intention.add.export.fix.text=將 {0} 匯出在檔案 {1} 中
javascript.intention.add.template.argument=插入模板字串實參
javascript.intention.call.chain.to.pipe=將嵌套呼叫取代為管道表達式
javascript.intention.code.optimizations.text=正在最佳化生成的程式碼
javascript.intention.create.getter=為 ''{0}'' 建立 getter
javascript.intention.create.getter.desc=建立 getter
javascript.intention.create.getter.setter=為 ''{0}'' 建立 getter 和 setter
javascript.intention.create.getter.setter.desc=建立 getter 和 setter
javascript.intention.create.setter=為 ''{0}'' 建立 setter
javascript.intention.create.setter.desc=建立 setter
javascript.intention.expand.nullish.coalescing=展開 null 合併
javascript.intention.expand.opt.chain=展開可選連結
javascript.intention.expand.opt.chain.and.nullish.coalescing=展開可選連結和 null 合併
javascript.intention.expand.opt.chain.and.or.coalescing=展開可選連結並使用 ?: 運算符
javascript.intention.expand.opt.chain.family=將可選連結或 null 合併擴展到顯式檢查
javascript.intention.expand.or.coalescing=使用 ?: 運算符
javascript.intention.explicit.fields=宣告顯式類別欄位
javascript.intention.explicit.fields.dialog.title=選擇要顯式宣告的欄位
javascript.intention.explicit.fields.single=宣告顯式類別欄位
javascript.intention.init.fields=從參數初始化新字段
javascript.intention.init.fields.dialog.title=選擇參數以初始化欄位
javascript.intention.opt.chain.chain.and.coalesce=使用可選連結和 null 合併
javascript.intention.opt.chain.chain.only=使用可選連結
javascript.intention.opt.chain.coalesce.only=使用 null 合併
javascript.intention.opt.chain.conditional.only=使用 '||'
javascript.intention.opt.chain.family=使用可選連結或 null 合併
javascript.intention.pipe.to.call.chain=將管道表達式取代為嵌套呼叫
javascript.intention.promise.to.async.name=轉換為異步功能
javascript.intention.remove.export.family.name=移除匯出
javascript.intention.remove.export.inaccessible.conflict.text={0} 在 {1} 中進行了使用
javascript.interface=接口
javascript.interface.can.not.be.instantiated.message=無法實例化接口
javascript.introduce.breaks.operator.precedence=無法呼叫重構。\\n通過引入將更改表達式中的運算符優先級。
javascript.introduce.constant.error.expression.has.void.type=無法引入常數。\\n選定的表達式類型無效。
javascript.introduce.constant.error.no.expression.selected=無法引入常數。\\n選定內容不構成表達式。
javascript.introduce.constant.error.not.constant.expression.selected=無法引入常數。\\n選定內容不是常數表達式。
javascript.introduce.constant.in.es5=無法呼叫重構。\\n無法在 ECMAScript 3 或 ECMAScript 5 程式碼中引入常數。
javascript.introduce.constant.title=引入常數
javascript.introduce.element.already.exists=作用域中已存在同名的 {0}。
javascript.introduce.field.before.super.call=無法引入欄位。\\n在"super"呼叫前無法存取"this"。
javascript.introduce.field.constructor=建構函式
javascript.introduce.field.current.method=當前方法
javascript.introduce.field.error.expression.has.void.type=無法引入變數。\\n選定的表達式類型無效。
javascript.introduce.field.error.no.enclosing.class=無法引入欄位。\\n沒有封閉類別。
javascript.introduce.field.error.no.expression.selected=無法引入欄位。\\n選定內容不構成表達式。
javascript.introduce.field.field.declaration=欄位宣告
javascript.introduce.field.initialize.in.scope=初始化位置(&I):
javascript.introduce.field.keyboard.hint=按 {0} 用於鍵盤快捷鍵
javascript.introduce.field.make.readonly=設為唯讀(&R)
javascript.introduce.field.title=引入欄位
javascript.introduce.field.visibility=可見性(&V):
javascript.introduce.in.embedded.expression=無法呼叫重構。\\n無法在嵌入式表達式中引入
javascript.introduce.incorrect.context=無法引入變數。\\n選定內容包含對"this"的參照
javascript.introduce.parameter.error.expression.has.void.type=無法引入參數。\\n選定的表達式類型無效。
javascript.introduce.parameter.error.no.containing.function=無法引入參數。\\n找不到要使用的包含函式。
javascript.introduce.parameter.error.no.expression.selected=無法引入參數。\\n選定內容不構成表達式。
javascript.introduce.parameter.error.not.async.context=無法為包含 'await' 的表達式引入參數。\\n並非所有用法都包含在異步函式中
javascript.introduce.parameter.error.target.not.async=無法為包含 'await' 的表達式引入參數。\\n目標函式不是異步函式
javascript.introduce.parameter.error.yield=無法為包含 'yield 的表達式引入參數。
javascript.introduce.parameter.generate.jsdoc=生成 JSDoc
javascript.introduce.parameter.introduced.variable.value=值(&V):
javascript.introduce.parameter.optional.parameter=可選參數
javascript.introduce.parameter.title=提取參數
javascript.introduce.throw.expressions.unsupported=無法呼叫重構。\\n“提取”重構中當前不支持 throw 表達式。
javascript.introduce.variable.arrow.await.referenced=無法引入。\\n選定內容包含 await 表達式
javascript.introduce.variable.arrow.function.parameter.referenced=無法引入。\\n選定內容包含對箭頭函式參數的參照
javascript.introduce.variable.error.expression.has.void.type=無法引入變數。\\n選定的表達式類型無效。
javascript.introduce.variable.error.no.expression.selected=無法引入變數。\\n選定內容不構成表達式。
javascript.introduce.variable.invalid.name=請輸入有效名稱。
javascript.introduce.variable.make.constant=設為常數
javascript.introduce.variable.name.prompt=名稱(&N):
javascript.introduce.variable.replace.all.occurrences=取代所有符合項(找到 {0} 個匹配項)(&A)
javascript.introduce.variable.title=提取變數
javascript.introduce.variable.title.local=引入區域變數
javascript.introduce.variable.xml.embedded=無法在嵌入式表達式中引入變數
javascript.invalid.delete.target.message=刪除運算符目標無效，應為欄位參照
javascript.invalid.extended.unicode.escape=擴展的 Unicode 轉義僅允許介於 0x0 和 0x10FFFF 之間的值
javascript.invalid.invoker.target=無效呼叫目標
javascript.invalid.number.of.parameters=實參數量無效，應為 {0} 個
javascript.invalid.string.escape=無效字串轉義
javascript.jsdoc.private.member.is.not.accessible.message=private 成員不可存取 #loc
javascript.jsdoc.protected.member.is.not.accessible.message=protected 成員不可存取 #loc
javascript.keyword=關鍵字
javascript.kind.unknown=未知元素
javascript.known.props.only=物件文字只能指定已知屬性，但以下為額外屬性: {0}
javascript.label=標籤
javascript.label.visibility.package_local=internal(&I)
javascript.label.visibility.private=private(&V)
javascript.label.visibility.protected=protected(&O)
javascript.label.visibility.public=公共 (&B)
javascript.language.service.cannot.get.results=無法從語言服務獲得結果
javascript.language.service.cannot.start=無法啟動語言服務程序
javascript.language.service.default.empty.text=無錯誤
javascript.language.service.default.project.errors=顯示專案錯誤
javascript.language.service.start.timeout=啟動語言服務程序超時
javascript.language.service.tracking.disabled=錯誤追蹤已停用
javascript.language.service.tracking.is.not.started=服務未啟動
javascript.language.simple.name=JavaScript
javascript.language.term.attribute=特性
javascript.language.term.attribute.value=特性值
javascript.language.term.class=類別
javascript.language.term.const=常數
javascript.language.term.const.field=常數欄位
javascript.language.term.constructor=建構函式
javascript.language.term.decorator=裝飾器
javascript.language.term.default.export=預設匯出
javascript.language.term.definition=定義
javascript.language.term.destructuring.property=解構屬性
javascript.language.term.entity.name=實體名稱
javascript.language.term.enum=枚舉
javascript.language.term.export.specifier=匯出說明符
javascript.language.term.exported.default.binding=已匯出預設綁定
javascript.language.term.external.module.reference=外部模組參照
javascript.language.term.field=欄位
javascript.language.term.file=檔案
javascript.language.term.function=函式
javascript.language.term.global=全域
javascript.language.term.import.specifier=匯入說明符
javascript.language.term.import.statement=import 語句
javascript.language.term.imported.default.binding=已匯入預設綁定
javascript.language.term.inner.class=內部類別
javascript.language.term.inner.function=內部函式
javascript.language.term.inner.interface=內部接口
javascript.language.term.interface=接口
javascript.language.term.jsdoc.tag=JSDoc 標記
javascript.language.term.label=標籤
javascript.language.term.local.const=區域常數
javascript.language.term.local.variable=區域變數
javascript.language.term.method=方法
javascript.language.term.module=模組
javascript.language.term.namespace=命名空間
javascript.language.term.namespace.export=命名空間匯出
javascript.language.term.namespace.import=命名空間匯入
javascript.language.term.package=軟體套件
javascript.language.term.parameter=參數
javascript.language.term.property=屬性
javascript.language.term.readonly.field=唯讀欄位
javascript.language.term.tag=標記
javascript.language.term.type.alias=類型別名
javascript.language.term.type.parameter=類型參數
javascript.language.term.variable=變數
javascript.language.term.xml.tag=xml 標籤
javascript.library.built.in=內建
javascript.linecomment=行註釋
javascript.linter.action.edit.config=編輯 {0}
javascript.linter.action.edit.property=編輯 {1} 中的 {0}
javascript.linter.action.edit.settings.text={0}設定…
javascript.linter.action.fix.problems.file.text={0}: 修復當前檔案
javascript.linter.action.fix.problems.name=修復 {0} 問題
javascript.linter.action.fix.problems.name.finish=已結束修復 {0} 問題
javascript.linter.action.fix.problems.name.start=已開始修復 {0} 問題
javascript.linter.action.fix.prompt=使用 {0} 重新格式化選定的檔案?
javascript.linter.configurable.config.autoSearch.title=自動搜尋 (&S)
javascript.linter.configuration.file.title=組態檔案
javascript.linter.error.can.not.find.document=找不到 {0} 的文檔
javascript.linter.error.can.not.find.psi.file=找不到 {0} 的 PSI 檔案
javascript.linter.error.empty.path=路徑為空
javascript.linter.error.failed.to.lint=Lint {0} 失敗
javascript.linter.error.invalid.path.to.package=指定 ''{0}'' 軟體套件的正確路徑
javascript.linter.error.no.path.to.package=指定 ''{0}'' 軟體套件的路徑
javascript.linter.error.no.such.file=沒有此類別檔案
javascript.linter.error.notification.problem.with.reformatting=重新設定 {0} 的格式時出現問題:<br/>{1}
javascript.linter.error.package.not.installed=安裝 ''{0}'' 軟體套件
javascript.linter.error.specify.correct.path.to=指定 {0} 的正確路徑
javascript.linter.import.error.bin.file.not.found=無法 ''{1}'' 軟體套件下找到 ''{0}''
javascript.linter.import.error.entry.point.not.found=無法在 ''{0}'' 軟體套件中找到入口點
javascript.linter.import.error.generic=套用組態檔案中的程式碼樣式規則時出錯，可能是組態檔案無效。
javascript.linter.import.error.package.not.found=找不到 ''{0}'' 軟體套件
javascript.linter.import.error.timeout.processing.configuration.file=處理組態檔案時超時
javascript.linter.import.nothing.to.import={0}: 已套用所有已知規則
javascript.linter.import.notification={0}: 專案程式碼樣式和編輯器設定基於 ''{1}'' 更新。
javascript.linter.import.notification.edit=編輯 ''{0}''
javascript.linter.import.notification.reset=重設
javascript.linter.import.notification.restored=預設程式碼樣式和編輯器設定已還原
javascript.linter.import.notification.rules.applied=套用了以下 {0}: {1}。
javascript.linter.import.translate.config.description=套用 ESLint 程式碼樣式規則
javascript.linter.import.translate.config.file.error=無法套用程式碼樣式規則
javascript.linter.import.translate.config.progress.title=套用 {0} 程式碼樣式規則
javascript.linter.import.translate.config.title=套用 ESLint 程式碼樣式規則
javascript.linter.intention.family.name.show.details={0}: 顯示詳細資訊
javascript.linter.intention.name.details=詳細資訊
javascript.linter.progress.reformatting.with=正在使用 {0} 重新格式化…
javascript.linter.radio.button.configuration.file=組態檔案(&C):
javascript.linter.suppress.all.rules.for.file.description=禁止當前檔案的所有 {0} 規則
javascript.linter.suppress.all.rules.for.line.description=禁止當前行的所有 {0} 規則
javascript.linter.suppress.rule.for.file.description=禁止當前檔案的 ''{0}''
javascript.linter.suppress.rule.for.line.description=禁止當前行的 ''{0}''
javascript.linter.suppress.rules.for.file.family.name=對當前檔案禁止
javascript.linter.suppress.rules.for.line.family.name=對當前行禁止
javascript.linter.use.severity.from.config.label=使用組態檔案中的規則嚴重性
javascript.local.function=區域函式
javascript.local.variable=區域變數
javascript.member.from.unopened.namespace.message=未開啟命名空間的成員 #loc
javascript.metadata=元資料
javascript.missed.argument.for.parameter=參數 {0} 缺少實參
javascript.missing.read.property=未解析的讀取屬性 #loc
javascript.missing.write.property=未解析的寫入屬性 #loc
javascript.module.dependencies.empty.got.it.text=<div align='left'>當前檔案或目錄沒有任何相依關係。<br/>請嘗試使用其他檔案或目錄。</div>
javascript.module.dependencies.got.it.text=<div align='left'>此圖顯示所選檔案或目錄具有的模組相依關係。<br/>要檢視多個檔案或目錄的相依關係，請在<i>專案檢視</i><br/>中將其選定，然後從所選專案右鍵選單中選擇<i>圖 – 顯示圖</i>。</div>
javascript.module.dependencies.got.it.title=模組相依關係圖
javascript.module.name=模組名稱
javascript.mutable.variable.accessible.from.closure=可從閉包存取可變變數
javascript.no.call.signatures=分配的類型不包含呼叫簽名
javascript.not.a.constructor.call.message=不是建構函式呼叫
javascript.number=數字
javascript.object.is.null={0} 為 null
javascript.object.is.null.or.undefined={0} 為 null 或 undefined
javascript.object.is.possibly.null={0} 可能為 null
javascript.object.is.possibly.null.or.undefined={0} 可能為 null 或 undefined
javascript.object.is.possibly.undefined={0} 可能為 undefined
javascript.object.is.undefined={0} 未定義
javascript.object.null.or.undefined.desc=物件為 'null' 或 'undefined'
javascript.octal.literals.are.not.allowed.es5.message=前綴為 '0' 的八進制文字已過時，不建議使用
javascript.octal.literals.are.not.allowed.es6.message=不允許使用前綴為 '0' 的八進制文字。改用 '0o' 前綴
javascript.octal.literals.are.not.allowed.in.strict.mode=在嚴格模式下不允許八進制文字
javascript.octal.literals.warn.always=關於 ES5-程式碼中過時八進制文字的警告
javascript.octal.sequences.are.not.allowed.message=不允許八進制轉義序列
javascript.operation=運算
javascript.parameter=參數
javascript.parens=括號
javascript.parser.message.are.not.supported.by.dialect=當前 JavaScript 版本不支持 {0}
javascript.parser.message.expected.as=應為 'as'
javascript.parser.message.expected.at=應為 @
javascript.parser.message.expected.case.or.default=應為 'case' 或 'default'
javascript.parser.message.expected.checks=應為 'checks'
javascript.parser.message.expected.class=應為 'class'
javascript.parser.message.expected.colon=應為 :
javascript.parser.message.expected.colon.or.comma=應為 : 或 ,
javascript.parser.message.expected.comma=應為 ,
javascript.parser.message.expected.comma.or.rbrace=應為 , 或 }
javascript.parser.message.expected.comma.or.rparen=應為 , 或 )
javascript.parser.message.expected.declaration=應為宣告
javascript.parser.message.expected.declare=應為 'declare'
javascript.parser.message.expected.dot=應為 .
javascript.parser.message.expected.eqgt=應為 =>
javascript.parser.message.expected.equal=應為 =
javascript.parser.message.expected.exports=應為 'exports'
javascript.parser.message.expected.expression=應為表達式
javascript.parser.message.expected.forloop.in.or.semicolon=應為 'in' 或 ;
javascript.parser.message.expected.forloop.left.hand.side.expression.or.variable.declaration='in' 前面應為左側表達式或變數宣告
javascript.parser.message.expected.forloop.using.not.allowed.in.for-in='for-in' 迴圈中不允許使用 'using'
javascript.parser.message.expected.formal.parameter.name=應為參數名稱
javascript.parser.message.expected.from=應為 'from'
javascript.parser.message.expected.function.name=應為函式名稱
javascript.parser.message.expected.gt=應為 >
javascript.parser.message.expected.heredoc.closing.identifier=應為 heredoc 結束關鍵字
javascript.parser.message.expected.identifier=應為關鍵字
javascript.parser.message.expected.identifier.lbrace.or.lbracket=應為關鍵字、{ 或 [
javascript.parser.message.expected.identifier.or.value=應為關鍵字或值
javascript.parser.message.expected.identifier.string.literal.or.lbrace=應為關鍵字、字串文字或 {
javascript.parser.message.expected.identifier.string.literal.or.numeric.literal=應為關鍵字、字串文字或數字文字
javascript.parser.message.expected.identifier.string.literal.or.rbrace=應為關鍵字、字串文字或 }
javascript.parser.message.expected.import.specifier=應為匯入說明符
javascript.parser.message.expected.import.value=應為匯入綁定或說明符
javascript.parser.message.expected.in=應為 'in'
javascript.parser.message.expected.instanceof=應為 'instanceof'
javascript.parser.message.expected.lbrace=應為 {
javascript.parser.message.expected.lbrace.or.semicolon=應為 { 或 ;
javascript.parser.message.expected.lbracket=應為 [
javascript.parser.message.expected.lparen=應為 (
javascript.parser.message.expected.meta=僅接受 'meta' 作為要匯入的元屬性
javascript.parser.message.expected.mult.or.lbrace=應為 * 或 {
javascript.parser.message.expected.name=應為名稱
javascript.parser.message.expected.name.or.lbrace=應為軟體套件名稱或 {
javascript.parser.message.expected.namespace=應為 'namespace'
javascript.parser.message.expected.newline.or.semicolon=需要換行符或分號
javascript.parser.message.expected.parameter.name=應為參數名稱
javascript.parser.message.expected.property.name=應為屬性名稱
javascript.parser.message.expected.question=應為 ?
javascript.parser.message.expected.rbrace=應為 }
javascript.parser.message.expected.rbracket=應為 ]
javascript.parser.message.expected.readonly=應為 'readonly'
javascript.parser.message.expected.rparen=應為 )
javascript.parser.message.expected.semicolon=應為 ;
javascript.parser.message.expected.statement=應為語句
javascript.parser.message.expected.string.literal=應為字串文字
javascript.parser.message.expected.target=僅接受 'target' 作為要新增的元屬性
javascript.parser.message.expected.tuple.comma.or.rbracket=應為 , 或 ]
javascript.parser.message.expected.type=應為類型
javascript.parser.message.expected.type.keyword=應為 'type'
javascript.parser.message.expected.type.member=應為類型成員
javascript.parser.message.expected.type.name=應為類型名稱
javascript.parser.message.expected.typename=應為類型名稱
javascript.parser.message.expected.typename.or.*=* 應為 * 或類型名稱
javascript.parser.message.expected.value=應為值
javascript.parser.message.expected.variable.name=應為變數名稱
javascript.parser.message.expected.while.keyword=應為 'while'
javascript.parser.message.expected.xml=應為 XML 上下文關鍵字
javascript.parser.message.expected.xml.element=應為 XML 元素
javascript.parser.message.missing.attribute.name=缺少特性名稱
javascript.parser.message.missing.back.quote=缺少 \`
javascript.parser.message.missing.or_rbrace=缺少 |}
javascript.parser.message.missing.rbrace=缺少 }
javascript.parser.message.missing.rbracket=缺少 ]
javascript.parser.message.missing.rparen=缺少 )
javascript.parser.message.missing.tag.name=缺少標記名稱
javascript.parser.message.unclosed.comment=未閉合註釋
javascript.parser.message.unclosed.string.literal=未閉合的字串文字
javascript.parser.message.unexpected.end.of.file=意外的檔案結尾
javascript.parser.message.unexpected.token=意外的標記 {0}
javascript.parser.property.expected=應為屬性
javascript.potentially.invalid.target.of.indexed.property.access=索引的屬性存取的目標可能無效
javascript.potentially.invalid.usage.of.class.this=通過嵌套函式的 'this.' 對類別欄位的參照存取可能無效
javascript.potentially.invalid.usage.of.this=This 的用法可能無效
javascript.private.constructor.is.not.accessible.message=private 建構函式不可存取 #loc
javascript.private.member.is.not.accessible.message=private 成員不可存取 #loc
javascript.property.is.read.only.message=唯讀屬性 #loc
javascript.property.is.write.only.message=只寫屬性 #loc
javascript.protected.constructor.is.not.accessible.message=protected 建構函式不可存取 #loc
javascript.protected.member.is.not.accessible.message=protected 成員不可存取 #loc
javascript.qualified.class.name.expected=應為限定的類別名
javascript.qualified.name.is.not.imported.message=未匯入限定名稱 #loc
javascript.redundant.typeof.guard=''typeof'' 檢查冗餘: ''{0}'' 始終具有類型 ''{1}''
javascript.refactoring.asdoc.for.abstracts=abstract 的 ASDoc
javascript.refactoring.cannot.find.usages.of.definition.to.inline=找不到要內聯的定義的用法
javascript.refactoring.cannot.inline.ambient.function=無法內聯沒有實作的宣告
javascript.refactoring.cannot.inline.complex.expression.evaluation=無法內聯複雜表達式求值
javascript.refactoring.cannot.inline.constructor=無法內聯建構函式
javascript.refactoring.cannot.inline.destructuring.rest.variable=無法內聯解構 rest 變數
javascript.refactoring.cannot.inline.destructuring.variable.with.default=無法內聯使用預設值的解構變數
javascript.refactoring.cannot.inline.function.defined.in.library=無法內聯外部庫中定義的函式
javascript.refactoring.cannot.inline.function.referencing.arguments=無法內聯參照實參的函式
javascript.refactoring.cannot.inline.function.referencing.rest.parameter=無法內聯函式參照的 rest 參數
javascript.refactoring.cannot.inline.function.with.multiple.returns=無法內聯有多個退出點的函式
javascript.refactoring.cannot.inline.interface.method=無法內聯接口方法
javascript.refactoring.cannot.inline.jsx.usage=無法內聯 JSX 標籤用法
javascript.refactoring.cannot.inline.not.initialized.variable=無法內聯未初始化的變數
javascript.refactoring.cannot.inline.overrided.or.overridden.method=無法內聯參與層次結構的方法
javascript.refactoring.cannot.inline.recursive.function=無法內聯遞迴函式
javascript.refactoring.extract.function.already.exists.in.this.scope=此作用域中已存在 {0}
javascript.refactoring.extract.function.bad.selection=所選塊應代表一組語句或表達式
javascript.refactoring.extract.function.function.used.before.declaring=選定內容包含在宣告之前使用的函式
javascript.refactoring.extract.function.multiple.exit.points=所選程式碼段有多個退出點
javascript.refactoring.extract.function.no.loop.for.break=程式碼段內沒有用於 break 語句的相應迴圈
javascript.refactoring.extract.function.no.loop.for.continue=程式碼段內沒有用於 continue 語句的相應迴圈
javascript.refactoring.extract.function.no.switch.for.break=程式碼段內沒有用於 break 語句的相應 'switch'
javascript.refactoring.extract.function.title=提取函式
javascript.refactoring.extract.function.yield.and.return=所選片段同時包含 yield 表達式和 return 語句
javascript.refactoring.function.to.es6.class.command=將函式 {0} 轉換為類別
javascript.refactoring.function.to.es6.class.defineProperty.warning.text=警告: 將使用“Object.defineProperty”、“Object.defineProperties”或“Object.create”建立的屬性轉換為 ES6 語法可能會影響其可枚舉性和可組態性
javascript.refactoring.inline.all.message=內聯所有參照並移除 {0} ({1}) (&A)
javascript.refactoring.inline.dialog.title=內聯{0}
javascript.refactoring.inline.function.title=內聯函式
javascript.refactoring.inline.this.only=僅內聯此參照並保留 {0}(&K)
javascript.refactoring.inline.variable.title=內聯變數
javascript.refactoring.searching.usages=尋找用法
javascript.refactoring.variable.used.as.lvalue=要內聯的變數在指派的左側使用
javascript.refactoring.variable.value.is.changed.when.accessed.from.closure=從閉包存取時變量值被更改
javascript.regexp=正則表達式
javascript.rename.choose.target.message=您要重新命名哪一個?
javascript.rename.containing.file.message=是否還要將該檔案重命名為 {0}?\\n{1} 的用法和 import 語句中的檔案路徑將進行相應更新。
javascript.rename.destructuring.target.dialog.title=速記解構變數使用 {0} 初始化
javascript.rename.element.with.related.elements.title=重新命名 {0}
javascript.rename.reference.intention.name=重新命名參照
javascript.rename.related.declaration.message=是否還要重新命名 {0}?\\nimport 語句中的 {0} 用法將進行相應更新。
javascript.rename.shorthand.property.description=屬性
javascript.rename.shorthand.target.dialog.title=速記屬性使用 {0} 初始化
javascript.rename.symbol.intention.name=重新命名符號
javascript.report.unused.definitions=報告未使用的定義
javascript.report.unused.properties=報告未使用的屬性
javascript.returned.expression.type.mismatch=返回的表達式類型 {1} 不可分配給類型 {0}
javascript.semicolon=分號
javascript.service.node.error=Node 解釋器路徑不正確。請檢查解釋器設定
javascript.starting.service=啟動 {0} 服務
javascript.static.member.function=static 成員函式
javascript.static.member.is.not.accessible.message=static 成員不可存取 #loc
javascript.static.member.variable=static 成員變數
javascript.strictly.check.global.vars=將未宣告的全域符號報告為錯誤
javascript.strictly.check.object.properties=將未宣告的屬性報告為錯誤
javascript.string=字串
javascript.surround.with.cast=Type(expr)
javascript.surround.with.do.while=do / while
javascript.surround.with.for=for
javascript.surround.with.function=函式
javascript.surround.with.function.expression=函式表達式
javascript.surround.with.if=if
javascript.surround.with.if.cond=if (cond)
javascript.surround.with.if.else=if / else
javascript.surround.with.if.else.cond=if (cond) / else
javascript.surround.with.not.parenthesis=!(expr)
javascript.surround.with.object.literal=物件文字
javascript.surround.with.parenthesis=(expr)
javascript.surround.with.try.catch=try / catch
javascript.surround.with.try.catch.finally=try / catch / finally
javascript.surround.with.try.finally=try / finally
javascript.surround.with.while=while
javascript.surround.with.with=with
javascript.suspicious.type.guard.desc=類型防護檢查不健全
javascript.suspicious.typeof.guard=''typeof'' 檢查無效: ''{0}'' 不能具有類型 ''{1}''
javascript.template.context.type=JavaSc&ript 和 TypeScript
javascript.term.does.not.evaluate.to.function=方法表達式不是函式類型
javascript.term.does.not.evaluate.to.function.line.break=表達式不可呼叫。如果這不應是呼叫，請檢查是否缺少分號
javascript.term.does.not.evaluate.to.function.nullable=方法表達式可以為 null 或 undefined
javascript.term.does.not.evaluate.to.function2=屬性不能作為函式呼叫
javascript.term.does.not.evaluate.to.function2.fix=移除實參列表
javascript.term.nullable.indexer.qualifier=索引的表達式可以為 null 或 undefined
javascript.type.is.not.assignable.to.type=類型 {1} 不可分配給類型 {0}
javascript.undeclared.variable.name.message=隱式宣告變數 {0} #loc
javascript.unfiltered.for.in.loop=可能迭代意外(自訂/繼承)成員，可能缺少 hasOwnProperty 檢查
javascript.unknown.metadata.attribute=未知元資料特性
javascript.unknown.metadata.tag=未知元資料標籤
javascript.unresolved.circle.definition=匯入的圓定義
javascript.unresolved.file.or.dir=無法解析 {0} <code>''{1}''</code>
javascript.unresolved.function.name.message=未解析的函式或方法 <code>{0}()</code> #loc
javascript.unresolved.symbol.message=未解析的符號
javascript.unresolved.type.name.message=未解析的類型 {0} #loc
javascript.unresolved.variable.name.message=未解析的變數 {0} #loc
javascript.unresolved.variable.null.or.undefined.qualifier.message=''{0}'' 的限定符可能為 null 或 undefined #loc
javascript.unresolved.variable.null.qualifier.message=''{0}'' 的限定符可能為 null #loc
javascript.unresolved.variable.or.type.name.message=未解析的變數或類型 {0} #loc
javascript.unresolved.variable.or.type.name.message2=未解析的變數或類型 {0}
javascript.unresolved.variable.undefined.qualifier.message=''{0}'' 的限定符可能未定義 #loc
javascript.unused.import.remove=移除未使用的 'import'
javascript.unused.import.remove.specifier=移除未使用的元素
javascript.valid.string.escape=有效字串轉義
javascript.validate.imports.name=未解析的已匯入名稱
javascript.validation.destructuring.without.initializer=解構宣告必須有初始設定式
javascript.validation.fqn.to.replace.with.import=限定名稱可被取代為 import 語句
javascript.validation.generators.yield.not.assignable.to.return=類型 ''{1}'' 不可分配給類型 ''{0}''
javascript.validation.generators.yield.not.in.generator=只允許在產生器正文中使用 'yield' 表達式。
javascript.validation.generators.yield.not.iterable=表達式類型沒有定義 [Symbol.iterator] 或 [Symbol.asyncIterator]
javascript.validation.initialized.var.in.for.loop=''{0}'' 迴圈中不允許變數初始設定式
javascript.validation.message.abstract.get.accessor.not.implemented=未實作類別 {1} 的 abstract get 存取器 {0}
javascript.validation.message.abstract.method.not.implemented=未實作類別 {1} 中的 abstract 方法 {0}
javascript.validation.message.abstract.set.accessor.not.implemented=未實作類別 {1} 的 abstract set 存取器 {0}
javascript.validation.message.accessor.could.not.be.nested.under.other.function=存取器方法不能嵌套在其他函式中
javascript.validation.message.arguments.is.readonly='arguments' 唯讀
javascript.validation.message.arguments.with.rest.parameter=使用 rest 參數時，'arguments' 物件不可用
javascript.validation.message.assignment.to.const=嘗試分配給常數或唯讀變數
javascript.validation.message.assignment.to.const.fix.remove.readonly=移除唯讀修飾符
javascript.validation.message.assignment.to.const.fix.replace=取代為 let
javascript.validation.message.attribute.was.specified.multiple.times=多次指定修飾符 {0}
javascript.validation.message.base.constructor.in.not.derived=僅允許在派生建構函式中呼叫基類別建構函式
javascript.validation.message.baseMethod.before.super.call=超類別建構函式呼叫前不允許有 'super'
javascript.validation.message.break.without.target=無法確定 'break' 的目標
javascript.validation.message.can.not.override.final.method=無法從{0}覆寫 final 方法
javascript.validation.message.circular.dependency=迴圈相依關係
javascript.validation.message.class.method.incompatible=''{1}'' 類別中的方法 ''{0}'' 不可分配給基類別 ''{2}'' 中的同一方法
javascript.validation.message.class.method.not.implemented=未實作類別 {1} 的方法 {0}
javascript.validation.message.class.name.expected.here=此處應為類別名
javascript.validation.message.class.property.incompatible=''{1}'' 類別中的屬性 ''{0}'' 不可分配給基類別 ''{2}'' 中的同一屬性
javascript.validation.message.class.property.not.implemented=未實作類別 {1} 的屬性 {0}
javascript.validation.message.class.setter.cannot.have.return.type='set' 存取器不能有返回值類型
javascript.validation.message.comma.is.not.allowed.after.last.parameter=最後一個參數後不允許有逗號
javascript.validation.message.comma.is.not.allowed.after.rest.element=rest 元素後不允許有逗號
javascript.validation.message.conflicting.definition.was.found.with.the.same.name=在命名空間 {1} 中發現衝突性的繼承宣告 {0}
javascript.validation.message.const.variable.without.initializer='const' 變數不包含初始設定式。以後無法賦予有意義的值。
javascript.validation.message.constructor.cannot.be.static=建構函式不能為 static
javascript.validation.message.constructor.cannot.have.custom.visibility=建構函式應為 public 或未指定可見性
javascript.validation.message.constructor.field.not.allowed=類別可能沒有名為 'constructor' 的非 static 欄位
javascript.validation.message.continue.outside.loop='continue' 在迴圈語句外部
javascript.validation.message.continue.without.target=無法確定 'continue' 的目標
javascript.validation.message.duplicate.catch.block=重複 catch 塊 #loc
javascript.validation.message.duplicate.catch.block.fix=移除重複的 catch 塊
javascript.validation.message.duplicate.declaration=重複宣告
javascript.validation.message.duplicate.declaration.fix.remove=移除類型
javascript.validation.message.duplicate.declaration.fix.text=導覽到上一個宣告 ''{0}''
javascript.validation.message.duplicate.declaration.fix.text.no.name=導覽到上一個宣告
javascript.validation.message.duplicate.default.export.declaration=一個模組不能有多個預設匯出
javascript.validation.message.duplicate.default.export.in.module=預設匯出只能在 ECMAScript-style 模組中使用
javascript.validation.message.duplicate.export.declaration=匯出宣告與已匯出的宣告 ''{0}'' 相衝突
javascript.validation.message.duplicate.label=重複標籤
javascript.validation.message.dynamic.can.be.applied.to.class=動態特性只能應用於類別宣告
javascript.validation.message.es5.function.declarations.allowed.on.top.level.or.function=禁止在程序或函式的頂層使用函式語句
javascript.validation.message.eval.cannot.be.assigned=不能在嚴格模式下分配 'eval'
javascript.validation.message.extend.final.class=無法擴展 final 類別 ''{0}''
javascript.validation.message.extend.multiple.classes=類別不能擴展多個類別
javascript.validation.message.final.modifier.allowed.only.for.methods=final 修飾符只能應用於類別和類別方法
javascript.validation.message.flowjs.path=Flow 路徑不正確
javascript.validation.message.for.await.no.async.context='for await' 只能在 'async' 函式中使用
javascript.validation.message.for.await.top.level=使用了頂層 'for await'
javascript.validation.message.function.method.invalid.overridden.parameter.type=不相容覆寫，應有類型 ''{0}''
javascript.validation.message.function.override.for.interface=對 {0} 中的方法進行了不相容的覆寫
javascript.validation.message.function.override.for.object.method=從 Object 繼承的方法無需覆寫
javascript.validation.message.function.override.incompatible.access.modifier=不相容覆寫，應有 ''{0}'' 存取修飾符
javascript.validation.message.function.override.incompatible.signature=不相容覆寫，應有簽名 ''{0}''
javascript.validation.message.function.override.incompatible.signature.generic=不相容覆寫
javascript.validation.message.function.override.incompatible.signature2=不相容覆寫，應有返回值類型 ''{0}''
javascript.validation.message.function.override.incompatible.signature3=不相容覆寫，應有種類 ''{0}''
javascript.validation.message.function.override.without.override.modifier=方法重寫了沒有 override 關鍵字的超類別 {0} 中的方法
javascript.validation.message.function.override.without.parent.method=方法不覆寫超類別的方法
javascript.validation.message.get.method.should.be.valid.type=getter 定義的返回值類型不應為 {0}
javascript.validation.message.get.method.should.have.no.parameter=getter 定義不得有形參
javascript.validation.message.get.method.type.is.different.from.setter=Get 存取器方法的類型與 set 存取器類型不相容，應為 ''{0}''
javascript.validation.message.identifier.not.allowed.in.strict.mode=在嚴格模式下不能將 ''{0}'' 用作關鍵字
javascript.validation.message.implements.for.interface.not.allowed=接口不允許有實作列表
javascript.validation.message.implements.is.not.allowed=標準 ECMAScript 中不允許有實作子句
javascript.validation.message.incompatible.override=對 {0} 中的成員進行了不相容的覆寫
javascript.validation.message.index.no.type=索引簽名參數必須具有類型註解
javascript.validation.message.index.wrong.type=索引簽名參數類型必須可以分配給 'string | number | symbol'
javascript.validation.message.interface.call.signature.not.implemented=未實作接口 {0} 的呼叫簽名
javascript.validation.message.interface.cannot.be.final.modifiers=接口不能為最終
javascript.validation.message.interface.get.accessor.not.implemented=未實作接口 {1} 的屬性 get 存取器 {0}
javascript.validation.message.interface.index.signature.not.implemented=未實作接口 {0} 的索引簽名
javascript.validation.message.interface.members.cannot.be.final.modifiers=接口成員不能為最終
javascript.validation.message.interface.members.cannot.have.access.modifiers=接口成員不能具有存取修飾符
javascript.validation.message.interface.members.cannot.have.namespace.attributes=接口成員不能具有命名空間特性
javascript.validation.message.interface.method.invalid.access.modifier=不相容實作，應有 'public' 存取修飾符
javascript.validation.message.interface.method.invalid.signature=不相容實作，應有簽名 ''{0}''
javascript.validation.message.interface.method.invalid.signature2=不相容實作，應有返回值類型 ''{0}''
javascript.validation.message.interface.method.invalid.signature3=不相容實作，應有 get / set ''{0}''
javascript.validation.message.interface.method.not.implemented=未實作來自接口 {1} 的方法 {0}
javascript.validation.message.interface.name.expected.here=此處應為接口名稱
javascript.validation.message.interface.property.not.implemented=未實作接口 {1} 的屬性 {0}
javascript.validation.message.interface.set.accessor.not.implemented=未實作接口 {1} 的屬性 set 存取器 {0}
javascript.validation.message.jsdoc.types.are.used=JSDoc 類型只能在文檔註釋內部使用
javascript.validation.message.missed.super.constructor.call=缺少超類別建構函式呼叫
javascript.validation.message.missing.catch.or.finally=缺少 catch 或 finally 子句
javascript.validation.message.must.be.lvalue={0} 中的左側無效
javascript.validation.message.nested.classes.are.not.allowed=不允許嵌套類別
javascript.validation.message.one.visibility.modifier.allowed=只允許一個可見性修飾符(public、protected、internal、private)
javascript.validation.message.only.one.default.is.allowed=\\ switch 中只允許一個預設子句
javascript.validation.message.override.can.be.applied.to.method=覆寫只能應用於函式宣告
javascript.validation.message.parameter.is.not.allowed.after.rest.parameter=rest 參數後不允許有任何參數
javascript.validation.message.parameter.non.optional.after.optional=必選參數不能位於可選參數後
javascript.validation.message.parameter.rest.optional=rest 參數不能是可選參數
javascript.validation.message.parameter.should.be.initialized=應初始化參數
javascript.validation.message.redeclaration.of.block.scope=不能重複宣告塊作用域變數
javascript.validation.message.redeclaration.of.block.scope.in.scope.of.var=塊作用域變數不能與同一塊作用域中的"var"變數或參數使用相同的名稱
javascript.validation.message.redeclaration.of.var.in.scope.of.block.scope="var" 變數不能與其可見性作用域內的塊作用域變數使用相同的名稱
javascript.validation.message.redefining.is.not.allowed=不允許重新定義 {0}
javascript.validation.message.redundant.type=顯式類型實參 {0} 可被取代為 {1}
javascript.validation.message.redundant.type.remove=可以移除顯式類型實參 {0}
javascript.validation.message.referencing.arguments.caller.callee.is.not.allowed=不允許從實參中參照 'caller' 和 'callee'
javascript.validation.message.referencing.function.arguments.property.is.not.allowed=不允許參照 'arguments' 函式屬性
javascript.validation.message.remove.unneeded.comma.fix=移除不需要的逗號
javascript.validation.message.rest.parameter.should.not.be.initialized=不應初始化 Rest 參數
javascript.validation.message.return.outside.function.definition='return' 在函式定義外部
javascript.validation.message.return.statement.required=非無效返回值類型必需具備 return 語句
javascript.validation.message.return.value.of.type.is.required=必需具備類型 {0} 的返回值
javascript.validation.message.set.method.should.be.void.or.without.type=setter 定義的返回值類型必須為未指定或無效
javascript.validation.message.set.method.should.have.one.parameter=setter 定義必須正好有一個參數
javascript.validation.message.set.method.type.is.different.from.getter=set 存取器方法的類型與 get 存取器類型不相容，應為 ''{0}''
javascript.validation.message.setter.parameter.cannot.have.initializer=Setter 定義不能具有可選參數
javascript.validation.message.static.method.cannot.be.final=靜態方法不能為最終
javascript.validation.message.static.modifier.is.allowed.only.for.class.members=僅允許類別成員使用 static 修飾符
javascript.validation.message.super.constructor.call.should.be.in.constructor=超類別建構函式呼叫應位於建構函式本體中
javascript.validation.message.super.referenced.from.static.context=在 static 上下文中參照了 'super'
javascript.validation.message.super.referenced.without.class.instance.context=在沒有類別執行個體上下文的情況下參照了'super'
javascript.validation.message.this.before.super.call=超類別建構函式呼叫前不允許有 'this'
javascript.validation.message.this.referenced.from.static.context=在 static 上下文中參照了 'this'
javascript.validation.message.unexpected.type.for.rest.parameter=Rest 參數不應有類型
javascript.validation.message.unknown.metadata.annotation.used=使用了未知的元資料特性
javascript.validation.message.unneeded.comma=不需要的逗號
javascript.validation.message.unresolved.component=未解析的元件 {0}
javascript.validation.message.use.namespace.reference.or.access.modifier=使用命名空間或存取修飾符
javascript.validation.multiple.var.in.for.loop=''{0}'' 迴圈中只允許一個變數
javascript.validation.new.target.not.in.function=僅允許函式宣告、函式表達式或建構函式的本體中有元屬性 'new.target'
javascript.validation.unused.import=未使用的 import
javascript.vector.literal.element.type.mismatch=矢量文字元素類型 {1} 不可分配給類型 {0}
javascript.visibility.internal=internal
javascript.visibility.private=private
javascript.visibility.protected=protected
javascript.visibility.public=public
javascript.with.statement.is.not.allowed.in.strict.mode.message=嚴格模式下不允許使用 With 語句
jest.cannot.find.bin.file.for.package.dialog.message=找不到 ''{0}'' 軟體套件的 bin 檔案
jest.coverage.cannot.find.lcov.info.notification.content=無法顯示 Jest 覆蓋率: 找不到 {0}。
jest.coverage.directory.not.found.notification.content=無法從 Jest 組態中讀取 coverageDirectory 選項
jest.coverage.notification.title=Jest 覆蓋率
jest.go.to.snapshot.text=轉到 ''{0}'' 快照
jest.package.placeholder.text=軟體套件目錄的路徑，可選擇 jest、react-scripts 或 react-scripts 替代項
jest.rc.configurationFile.label=組態檔案(&C):
jest.rc.configurationFile.title=選擇 Jest 組態檔案
jest.rc.jestOptions.emptyText=CLI 選項，例如 --watch 或 --env=jsdom
jest.rc.jestOptions.label=Jest 選項:
jest.rc.jestPackageField.label=Jest 軟體套件(&J):
jest.snapshot.label=Jest 快照
jest.snapshot.update.all.tests.text=<link>點擊以更新所有失敗的快照</link>
jest.snapshot.update.rc.name=更新 {0} 的快照
jest.snapshot.update.single.test.text=<link>點擊以更新 ''{0}'' 的快照</link>
jest.snapshot.update.test.file.text=<link>點擊以更新 {0} 中失敗的快照</link>
jquery.documentation.not.found=找不到 jQuery 文檔
js.accessibility.check.inspection.name=已參照無法存取的 @private 和 @protected 成員
js.add.braces.to.arrow.function=向箭頭函式中新增大括號
js.add.members.to.type=將成員 {0} 新增到 ''{1}''
js.add.members.to.type.desc=將成員新增到類別或接口
js.add.then.fix=新增 '.then()'
js.align.multiline.extends.list=多行時對齊
js.align.properties.none=不對齊
js.align.properties.on.colon=冒號上
js.align.properties.on.value=值上
js.annotator.assignment.pattern.rhs=指派模式必須位於指派的左側
js.annotator.inspection.name=未遵循 ECMAScript 規範
js.annotator.newline.before.arrow=箭頭前不允許換行符
js.annotator.replace.with.fat.arrow=取代為粗箭頭
js.annotator.rest.element.must.be.last=rest 元素必須位於最後
js.annotator.thin.arrow.used=使用了細箭頭
js.annotator.unary.operator.within.exponential=一元運算符 ''{0}'' 不允許直接位於指數表達式之前。建議新增括號以解決歧義問題。
js.annotator.yield.cannot.be.used.inside.generator='yield' 不能用作產生器內部的關鍵字
js.anonymous.to.named.function=匿名函式轉換為命名函式
js.arrangement.group.arrow.fields.with.methods=使用包含方法的箭頭函式初始化的組欄位
js.array.new.line.after.left.bracket=在 '[' 後換行
js.array.new.line.before.right.bracket=將 ']' 置於新行中
js.arrow.function.braces.can.be.removed.fix.family.name=移除箭頭函式體周圍的大括號
js.arrow.function.braces.can.be.removed.key=箭頭函式體周圍的大括號冗餘
js.arrow.function.braces.can.be.removed.problem.description=可以移除箭頭函式體周圍的大括號
js.assigning.to.primitive.type.property=賦給基元的值將丟失
js.assignment.issues.group.name=指派問題
js.assignment.used.as.condition.fix=將 ''='' 取代為 ''{0}''
js.assignment.used.as.condition.name=用作條件的指派
js.assignment.used.as.condition.text=<code>#ref</code> 作為條件使用
js.await-using.in.synchronous.function='await using' 指令只能在 'async' 函式中使用
js.await.in.synchronous.function='await' 運算符只能在 'async' 函式中使用
js.await.promise.double.await.inspection=冗餘 'await await'
js.await.promise.reject.inspection=冗餘 'await Promise.reject()'
js.await.promise.resolve.fix=取代為 ''{0}''
js.await.promise.resolve.inspection=冗餘 'await Promise.resolve()'
js.await.promise.return.await.inspection=冗餘 'return await'
js.await.promise.trivial.await.inspection=非 promise 類型的冗餘 'await'
js.bitwise.operator.usage.name=按位運算符用法
js.bitwise.operator.usage.popup=使用了按位運算符
js.bitwise.operator.usage.quickfix=取代為 {0}
js.blank.lines.around.function=Around 函式:
js.blank.lines.around.method=方法周圍:
js.breadcrumbs.callback.for=\\ {0}() 回調
js.chained.call.dot.on.next.line='.' 在新行
js.check.function.signature.guess.optionality=將非類型化參數視為必選
js.check.function.signature.guess.optionality.hint=如果停用，則所有未鍵入的參數均視為可選參數
js.checkbox.make.readonly=設為唯讀(&R)
js.class.context.type=類別/接口
js.class.member.expression.context.type=類別成員表達式
js.class.member.initialization.inspection.name=在 static 初始設定式中使用可能未分配的屬性
js.class.member.initialization.inspection.text=欄位 ''{1}'' 在 ''{0}'' 之後宣告，並且可能尚未分配
js.class.member.initialization.inspection.text.id=欄位 ''{0}'' 參照本身
js.class.member.statement.context.type=類別成員語句
js.closure.compiler.syntax.cyclic.inheritance=涉及 {0} 的迴圈繼承
js.closure.compiler.syntax.empty.type=空類型不可用
js.closure.compiler.syntax.implements.not.interface={0} 未用 @interface 進行註解
js.closure.compiler.syntax.inspection.name=JSDoc 標記不正確的用法
js.closure.compiler.syntax.invalid.type=類型語法無效
js.code.style.align.caption=對齊
js.code.style.align.from.clause.caption=對齊 'from' 子句
js.code.style.align.var.statements=當多行時
js.code.style.align.var.statements.and.assignments=分組時
js.code.style.array.group.name=陣列
js.code.style.do.not.align.var.statement=不對齊
js.code.style.file.name.camel.style=駝峰命名法 (appComponent)
js.code.style.file.name.lisp.style=中線命名法 (app-component)
js.code.style.file.name.mixed.style=帶後綴的中線命名法 (my-app.component)
js.code.style.file.name.pascal.style=帕斯卡命名法 (AppComponent)
js.code.style.file.name.relaxed.style=重用當前檔案的 case
js.code.style.file.name.snake.style=蛇形命名法 (app_component)
js.code.style.issues.group.name=程式碼樣式問題
js.code.style.object.literals.category.name=物件
js.code.style.punctuation.tab.title=標點
js.code.style.tab.name=JavaScript
js.commandline.configure.language.version=為專案組態 JavaScript 語言版本
js.commandline.configure.nodejs=組態 NodeJS 解釋器並為 package.json 檔案安裝軟體套件
js.comment.matches.signature.inspection.name=不符合的 JSDoc 和函式簽名
js.comment.matches.signature.inspection.problem1=JSDoc 中未描述參數 {0}
js.comment.matches.signature.inspection.problem2=JSDoc 中描述的參數 {0} 未出現在函式簽名中
js.comment.matches.signature.inspection.quickfix=更新 JSDoc 註釋
js.comparison.with.nan.inspection.name=與 NaN 比較
js.comparison.with.nan.inspection.problem=與 NaN 的相等比較的求值結果始終為 false
js.comparison.with.nan.inspection.problem2=與 NaN 的不等比較的求值結果始終為 true
js.comparison.with.nan.inspection.quickfix=取代為 {0}isNaN(...)
js.consecutive.commas.in.array.literal.inspection.insert.undefined=插入 'undefined'
js.consecutive.commas.in.array.literal.inspection.message=陣列文字中的連續逗號
js.consecutive.commas.in.array.literal.inspection.name=陣列文字中的連續逗號
js.constructor.cant.have.return.type=建構函式不能有返回值類型
js.constructor.returns.primitive.inspection.name=建構函式返回基元值
js.constructor.returns.primitive.inspection.problem=使用 'new' 調用時從建構函式返回的基元值將丟失
js.constructor.returns.primitive.inspection.quickfix=返回值類型顯式設定為 {0}
js.convert.for.each.to.for.of.intention.family=將 'forEach' 取代為 'for..of' 迴圈
js.convert.for.each.to.indexed.intention.family=將 'forEach' 取代為索引的 'for' 迴圈
js.convert.for.in.to.for.of.family.name=將 'for..in' 轉換為 'for..of'
js.convert.for.in.to.for.of.inspection.text=使用了 'for..in' 而不是 'for..of'
js.convert.for.in.to.for.of.text=將 'for..in' 轉換為 'for..of'
js.convert.for.of.to.indexed.intention.family=將 'for..of' 取代為索引的 'for' 迴圈
js.convert.indexed.for.to.for.of.family.name=將帶索引的 'for' 轉換為 'for..of'
js.convert.indexed.for.to.for.of.inspection.text=已使用索引的 'for' 而不是 'for..of'
js.convert.indexed.for.to.for.of.text=將帶索引的 'for' 轉換為 'for..of'
js.convert.indexed.for.to.foreach.intention.family=將索引的 'for' 轉換為 'forEach' 呼叫
js.convert.let.to.const.inspection.text=已使用 'let' 而不是 'const'
js.convert.map.to.for.of.intention.family=將 'map' 陣列呼叫取代為 'for..of' 迴圈
js.convert.module.exports.into.es6.export.family.name=轉換為 export
js.convert.module.exports.into.es6.export.inspection.text=使用了 'module.exports' 而不是 'export'
js.convert.module.exports.into.es6.export.text=轉換為 export
js.convert.parameters.to.object.intention.name=將參數轉換為物件
js.convert.parameters.to.object.non.call.usage.will.not.be.updated=不更新非呼叫用法
js.convert.parameters.to.object.usage.will.not.be.updated.for.contextual.type=方法會覆寫另一個方法。不會更新基方法
js.convert.parameters.to.object.usage.will.not.be.updated.for.spread=不會更新使用非終端傳播實參進行的呼叫
js.convert.parameters.to.object.with.interface.intention.name=將參數轉換為物件並引入接口
js.convert.require.into.es6.import.family.name=將 require() 轉換為 import
js.convert.require.into.es6.import.inspection.text=使用了 'require()' 而不是 'import'
js.convert.require.into.es6.import.inspection.withConditional.option=使用“全部修復”動作在內部作用域內轉換 require()
js.convert.require.into.es6.import.inspection.withConditional.option.description=在內部作用域內轉換 require() (例如 'if' 語句或內部函式)
js.convert.require.into.es6.import.text=將 require() 轉換為 import
js.convert.to.anonymous.function=轉換為匿名函式
js.convert.to.anonymous.function.family.name=箭頭函式轉換為匿名函式
js.convert.to.arrow.function=轉換為箭頭函式
js.convert.to.es6.class=轉換為類別
js.convert.to.es6.class.family.name=將函式及其成員宣告轉換為類別
js.convert.to.foreach.intention.name=將 'for-in' 轉換為 'forEach' 呼叫
js.convert.to.named.function=轉換為命名函式
js.convert.to.named.function.to.class.method=轉換為類別方法
js.convert.var.to.const.text=轉換為 const
js.convert.var.to.let.or.const=轉換為 let/const
js.convert.var.to.let.or.const.family.name=將 var 轉換為 let/const
js.convert.var.to.let.or.const.inspection.conservative.option=使用“全部修復”動作保守地轉換 var
js.convert.var.to.let.or.const.inspection.conservative.option.description=在第一次使用變數之前，宣告可能會移至函式器頂部。\\n要在使用“全部修復”動作時停用此行為，請選中“保守轉換 var”選項。
js.convert.var.to.let.or.const.inspection.text=已使用 'var' 而不是 'let' 或 'const'
js.convert.var.to.let.text=轉換為 let
js.copy.qualified.to.clipboard=將限定名稱複製到剪貼簿
js.create.derived.type.abstract.class=實作抽象類別
js.create.derived.type.class=建立派生類別
js.create.derived.type.family=建立派生類別/實作接口
js.create.derived.type.interface=實作接口
js.create.switch.cases=建立缺少的 'switch' 分支
js.create.switch.cases.fix=建立缺少的分支: {0}
js.declaration.is.not.at.scope.start=var 語句不在作用域開始
js.declarations.at.scope.start.inspection='var' 未在函式開頭宣告
js.deprecated.symbols.inspection.name=已使用棄用的符號
js.destructuring.merge.inspection=正在解構具有相同鍵的屬性
js.destructuring.merge.inspection.fix=合併解構屬性
js.destructuring.merge.inspection.text=可以合併具有多個相同鍵的解構屬性
js.dialect.settings.caption=
js.dialect.settings.dialog.title=JavaScript 語言版本
js.dialect.settings.empty.text=使用 + 按鈕新增目錄，並選擇 JavaScript 版本
js.dialect.settings.override.question=覆寫子目錄和檔案的語言版本?
js.dialect.settings.override.title=覆寫語言版本設定
js.dialect.settings.tableTitle=語言
js.dialects.customized.label=根據目錄自定義
js.documentation.fires=觸發:
js.documentation.more.overload=其他 {0} 個多載
js.documentation.more.overloads=其他 {0} 個多載
js.dot.property.access.context.type=點號屬性存取
js.duplicate.declaration.inspection.name=重複宣告
js.edit.object.literal=編輯物件文字屬性的值
js.expand.shorthand.property.quick.fix=展開速記屬性
js.expression.context.type=表達式
js.extends.keyword.wrap=擴展關鍵字
js.extends.list.wrap=Extends 列表
js.extjs.unresolved.ext.xtype.inspection.name=未解析的 Ext JS xtype
js.file.references.inspection.ignore.complex.cases=忽略複雜 case
js.file.references.inspection.name=未解析的檔案參照
js.file.watcher.6to5.description=使用 Babel 將 ECMAScript 6 程式碼轉換成 ECMAScript 5
js.fix.change.member.access.to.sharp=使用 '#' 設為 private
js.flow.all.servers.action.restart=重啟所有 Flow 伺服器
js.flow.enable.flow.service.error=\\ 不正確的 Flow 路徑
js.flow.enable.flow.service.error.empty=Flow 可執行檔案的路徑為空
js.flow.enable.flow.service.error.message={0}。停用所有 Flow 服務或為可執行檔案提供有效路徑。
js.flow.enable.flow.service.error.on.checking=檢查 Flow 路徑時出錯: {0}
js.flow.enable.other.services=導覽、程式碼補全和類型提示
js.flow.enable.type.checking=類型檢查
js.flow.has.unsaved.files=由於修改了某些檔案，因此沒有執行醒目提示
js.flow.process.log=Flow 流程日誌
js.flow.services.label=為之使用 Flow 伺服器:
js.flow.settings.auto.save=自動儲存所有修改的檔案
js.flow.settings.auto.save.warning=只有儲存其他所有修改過的檔案時，Flow 才會檢查當前檔案。
js.flow.settings.auto.save.warning.lsp=這樣 Flow 將始終顯示最新的錯誤狀態。
js.flow.settings.executable.dialog.title=選擇 Flow 軟體套件或可執行檔案
js.flow.settings.executable.label=Flow 軟體套件或可執行檔案 (&F):
js.flowjs.annotation.inspection.name=Flow 類型檢查器
js.flowjs.config.inspection.message=無關聯的 .flowconfig
js.flowjs.config.inspection.name=缺少 .flowconfig
js.flowjs.config.inspection.to.current.path.name=向當前目錄中新增 .flowconfig
js.flowjs.config.inspection.to.module.path.name=向模組內容根中新增 .flowconfig
js.flowjs.config.inspection.to.project.path.name=向專案根目錄中新增 .flowconfig
js.flowjs.coverage.inspection.error.text=Flow 不涵蓋此元素
js.flowjs.coverage.inspection.name=Flow 不涵蓋程式碼
js.flowjs.flag.comment.placement.inspection.error=Flow 標誌註釋不在檔案起始處
js.flowjs.flag.comment.placement.inspection.fix=將 Flow 標誌註釋移至檔案起始處
js.flowjs.flag.comment.placement.inspection.name=位置錯誤的 @flow 標記
js.flowjs.flag.without.language.version=無 Flow 語言版本的 Flow 標誌
js.flowjs.group.name=Flow 類型檢查器
js.format.cstyle.comments=對齊多行
js.frameworks.sencha.xtype.not.found=找不到 xtype ''{0}'' 的 Ext JS 類別
js.function.brace.style=在函式宣告中
js.function.call.parentheses=函式呼叫括號
js.function.call.wrap=函式呼叫實參
js.function.declaration.parentheses=函式宣告括號
js.function.expression.brace.style=在函式表達式中
js.function.metrics.group.name=函式指標
js.function.parameters.wrap=函式宣告參數
js.generated.explicit.return.expression.types=函式表達式返回
js.generated.explicit.return.types=函式宣告返回
js.generated.explicit.types=此項的首選顯式類型:
js.generated.explicit.var.types=變數和欄位
js.generated.types=類型
js.generated.types.settings.link=顯式類型的程式碼樣式設定
js.generated.use.as.cast=首選 'as' 類型轉換
js.generated.use.public.modifier=使用 'public' 修飾符
js.import.options.merge.import=合併同一模組中成員的匯入
js.import.options.sort.members=對匯入的成員排序
js.import.options.sort.module.name=按模組對匯入排序
js.import.options.use.explicit.js.extension=使用檔案副檔名:
js.import.options.use.explicit.js.extension.auto=自動
js.import.options.use.explicit.js.extension.no=從不
js.import.options.use.explicit.js.extension.yes=始終
js.import.options.use.explicit.js.extension.yes.ts=始終為 ".js"
js.import.options.use.node.resolution=在 index.js 可用時使用目錄匯入(Node 樣式模組解析)
js.imports.dependencies.group.name=Import 和相依項
js.incompatible.types.comparison.inspection.name=類型不相容的表達式的比較
js.incompatible.types.comparison.message=條件始終為 {0, choice, 0#false|1#true}，因為類型 ''{1}'' 和 ''{2}'' 沒有重疊
js.indexer.to.property.intention=取代為屬性存取
js.infer.parameter.types.intention=從用法中推斷參數類型
js.infer.parameter.types.intention.failure.readonly.text=無法從用法中推斷類型: 為唯讀檔案
js.infer.parameter.types.intention.failure.text=無法從用法中推斷類型
js.infer.parameter.types.intention.failure.title=無法推斷類型
js.infer.parameter.types.intention.jsdoc=從用法中推斷 JSDoc 參數類型
js.infer.parameter.types.intention.progress.text=正在推斷類型
js.inject.dont.format.intention.text=停用注入內容的格式設定
js.inject.with.comment.intention.family.name=使用註釋對注射做出註解
js.inspection.amd.modules.dependencies.family.name=缺少 AMD 模組相依關係
js.inspection.async.group.name=Async 程式碼和 promise
js.inspection.bitwise.group.name=按位運算問題
js.inspection.convert.to.es6.group.name=ES2015 遷移協助
js.inspection.es6.modules.dependencies.family.name=缺少 import 語句
js.inspection.function.expression.is.used.instead.of.arrow=使用了函式表達式而不是箭頭函式
js.inspection.group.name=一般
js.inspection.group.path=JavaScript 和 TypeScript
js.inspection.missing.amd.dependency=缺少 AMD 模組相依關係
js.inspection.missing.import=缺少 import 語句
js.inspection.missing.module.dependency=缺少模組相依關係
js.inspection.package.json.dependencies=package.json 中的相依關係不符合
js.inspection.package.json.update.dependency.to.latest.version=將 package.json 相依項更新為最新版本
js.inspection.promise.ignored.display.name=返回 promise 的方法呼叫結果被忽略
js.inspection.promise.ignored.problem.descriptor=從 {0} 返回的 Promise 被忽略
js.inspection.promise.value.expected.problem.descriptor=應為值，但使用了從 {0} 返回的 Promise
js.inspection.switch.group.name=switch 語句問題
js.iterate=使用 'for..of' 進行迭代
js.iterate.async=使用 'for await..of' 進行迭代
js.join.declaration.assignment.inspection.fix=聯接變數宣告和指派
js.join.declaration.assignment.inspection.name=變數宣告可與變數的第一個指派合併
js.join.vars.intention=加入後續變數宣告
js.jquery.efficiency.inspection.allow.attribute.and.pseudo.selectors=允許特性和偽選擇器
js.jquery.efficiency.inspection.attribute.used.message=jQuery 特性選擇器可能低效
js.jquery.efficiency.inspection.duplicated.selector=重複的 jQuery 選擇器
js.jquery.efficiency.inspection.name=可以最佳化 JQuery 選擇器
js.jquery.efficiency.inspection.pseudoselector.used.message=jQuery 偽選擇器可能低效
js.language.feature.annotations=註解
js.language.feature.arbitrary.precision.integers=任意精度整數
js.language.feature.array.comprehensions=陣列推導式
js.language.feature.arrow.functions=箭頭函式
js.language.feature.async.await=async/await
js.language.feature.binary.0b.and.new.octal.0o.literals=二進制(0b)和新的八進制(0o)文字
js.language.feature.bind.expressions=綁定表達式
js.language.feature.class.member.visibility.modifiers=類別成員可見性修飾符
js.language.feature.classes=類別
js.language.feature.computed.property.names=計算的屬性名稱
js.language.feature.const.definitions=Const 定義
js.language.feature.decorator.declarations=裝飾器宣告
js.language.feature.default.parameter.values=預設參數值
js.language.feature.destructuring.assignments=解構指派
js.language.feature.destructuring.parameters=解構參數
js.language.feature.ecmascript.syntax.for.private.members=私有成員的 ECMAScript #- 語法
js.language.feature.enums=枚舉
js.language.feature.es6.export.declarations=ES6 匯出宣告
js.language.feature.es6.import.declarations=ES6 匯入宣告
js.language.feature.expression.closures=表達式結束
js.language.feature.for.each.statements=針對每條語句
js.language.feature.for.of.loops=for..of 迴圈
js.language.feature.generator.expressions=產生器表達式
js.language.feature.generators=生成器
js.language.feature.generics=泛型
js.language.feature.getters.and.setters=getter 和 setter
js.language.feature.interfaces=接口
js.language.feature.let.definitions=Let 定義
js.language.feature.let.statements=Let 語句
js.language.feature.method.definition.shorthands=方法定義速記形式
js.language.feature.nullish.coalescing=Null 合併運算符
js.language.feature.optional.catch.bindings=可選 catch 綁定
js.language.feature.optional.chaining.operator=可選連結運算符
js.language.feature.pipe.expressions=管道表達式
js.language.feature.reference.namespace=參照命名空間
js.language.feature.rest.parameters=rest 參數
js.language.feature.shorthand.property.names=速記屬性名稱
js.language.feature.string.templates=字串模板
js.language.feature.throw.expressions=拋出表達式
js.language.feature.top.level.yield.expressions=頂層 yield 表達式
js.language.feature.trailing.commas.in.function.parameter.lists.and.calls=函式參數列表和呼叫中的尾隨逗號
js.language.feature.types=類型
js.language.feature.unicode.escapes.with.braces=使用大括號的 Unicode 轉義
js.language.feature.xml.tags=XML 標記
js.language.version.combo.es5=ECMAScript 5.1
js.language.version.combo.es6=ECMAScript 6+
js.language.version.combo.es6.description=ECMAScript 2015+、一些提案和 JSX
js.language.version.combo.flow=Flow
js.language.version.combo.flow.description=ECMAScript 6 中的 Flow 和 JSX
js.language.version.combo.js185=JavaScript 1.8.5
js.language.version.combo.js185.description=已棄用特定於 Firefox 的 ECMAScript 實作。請考慮切換。
js.language.version.combo.nashorn=Nashorn JS
js.language.version.combo.nashorn.description=Java 中的 JavaScript 實作
js.language.version.label=JavaScript 語言版本
js.last.comma.in.array.literal.inspection.name=陣列文字中的最後一個逗號多餘
js.last.comma.in.object.literal.inspection.name=物件文字中的最後一個逗號多餘
js.library.attach.debug=附加偵錯版本(&D)…
js.library.attach.release=附加發佈版本(&R)…
js.library.configurable.name=庫
js.library.documentation=文檔
js.library.download.fix=下載庫
js.library.download.stubs.label=TypeScript 社群存根
js.library.downloading.library=正在下載庫
js.library.successfully.downloaded=已成功下載 {0}
js.library.unresolved.url.inspection.name=HTTP 連結缺少本地存儲的庫
js.linter.guesser.linter.disabled={0} 已停用。
js.linter.guesser.linter.enabled.because.of.config.file=已啟用 {0}: 組態檔案位於專案中。
js.linter.guesser.linter.enabled.because.of.dependency=已啟用 {0}: ''{1}'' 列出在 package.json 中。
js.linter.guesser.linter.enabled.because.of.package.json.section=已啟用 {0}: ''{1}'' 位於 package.json 中。
js.linters.detect.automatically.caption=從最近的 package.json 檢測軟體套件和組態檔案
js.linters.inspection.group.name=程式碼品質工具
js.make.single.var.statement=設為單變數語句
js.method.can.be.static=方法可以為 'static'
js.method.can.be.static.option=僅檢查 'private' 方法
js.mismatched.update.collection.inspection.name=不符合的集合查詢和更新
js.mismatched.update.collection.update.method.names=更新方法名稱:
js.missing.await.symbol.inspection.for.generator.name=異步產生器應使用 for-await 迴圈進行迭代
js.missing.await.symbol.inspection.for.returns=始終對異步函式呼叫使用 'await' 以避免錯誤，並幫助進行 V8 異步堆疊追蹤
js.missing.await.symbol.inspection.name=異步函式呼叫缺少 await
js.missing.switch.branches.ignore.with.default=忽略具有預設分支的 switch 語句
js.missing.switch.branches.inspection.desc=''switch'' 語句缺少 case: {0}
js.missing.switch.branches.inspection.name='switch' 語句缺少分支
js.module.uml.presentable.name=JavaScript 模組相依項
js.move.to.scope.start=將 var 語句移至作用域開始
js.move.type.to.file.family=移至名稱符合的檔案
js.move.type.to.file.text=將 {0} 移至檔案 {1}
js.named.to.anonymous.family.name=轉換為函式表達式
js.named.to.arrow.text=轉換為含有 {0} 的箭頭函式
js.named.to.function.expression.text=轉換為包含變數的函式表達式
js.named.to.function.hoisting.conflict.text=函式在宣告之前使用。轉換為變數後，將中斷使用
js.nested.template.literal.fix=內聯嵌套文字
js.nested.template.literal.inspection=模板文字中的冗餘嵌套
js.param.hints.blacklist.pattern.explanation=要停用方法或函式提示，請使用下面的其中一種模式: <p style="margin-left: 5px"><code><b>(*info)</b></code> - 所有參數名稱以 <em>info</em> 結尾的單參數方法<br><code><b>(key, value)</b></code> - 所有包含參數<em>鍵</em>和<em>值</em>的方法<br><code><b>*.put(key, value)</b></code>- 所有包含<em>鍵</em>和<em>值</em>參數的 <em>put</em> 方法<br><code><b>Console.log(*, *)</b></code> - 正好包含兩個參數的 <em>Console</em> 類型的 <em>log</em> 方法</p><br><p>必須為所有參數(包括可選參數)提供名稱或佔位符。<br>限定方法名稱必須包含類別或接口名稱或佔位符。<br>在編輯程式碼時，請使用“不為當前方法顯示提示”{0} 動作來新增模式。</p>
js.param.hints.show.names.for.all.args=非文字實參
js.param.hints.show.names.for.pipes=管道運算符
js.param.hints.show.names.for.tagged=標記的模板實參
js.possibly.async.function.inspection=非異步函式中的 'await'
js.possibly.async.function.quick.fix=令函式 {0} 為異步函式
js.possibly.async.function.quick.fix.family.name=將函式設為異步
js.potentially.invalid.constructor.usages.inspection.name=可能無效的建構函式用法
js.potentially.invalid.target.of.indexed.property.access.inspection.name=索引的屬性存取的目標可能不正確
js.potentially.invalid.usage.of.class.this.inspection.name=從閉包對類別中 'this' 的參照可能無效
js.potentially.invalid.usage.of.this.inspection.name=從閉包對 'this' 的參照可能無效
js.primitive.type.improper.instantiation.inspection={0} 實例化可以簡化
js.primitive.type.wrapper.usage.inspection=使用了基元類型物件包裝器
js.probable.bugs.group.name=可能的錯誤
js.property.can.be.replaced.with.shorthand=屬性可被取代為速記形式
js.property.can.be.replaced.with.shorthand.method=屬性可被取代為速記方法
js.property.to.indexer.intention=取代為索引器存取
js.pull.up.will.be.made.abstract=非 abstract {0}將被設為 abstract
js.quote.unquote.intention.plural={0} 屬性名稱
js.quote.unquote.intention.quote=參照
js.quote.unquote.intention.quote.family=使用引號包裝屬性名稱
js.quote.unquote.intention.singular={0} 屬性名稱
js.quote.unquote.intention.unquote=取消參照
js.quote.unquote.intention.unquote.family=移除屬性名稱中的引號
js.react.group.name=React
js.redundant.await.inspection=冗餘 'await' 表達式
js.redundant.switch.problems.inspection.default='switch' 語句僅包含一個 'default' 子句
js.redundant.switch.problems.inspection.default.unwrap=解包 'switch' 語句
js.redundant.switch.problems.inspection.empty='switch' 語句為空
js.redundant.switch.problems.inspection.empty.remove=移除空的 'switch' 語句
js.redundant.switch.problems.inspection.name='switch' 語句冗餘，可以取代
js.redundant.switch.problems.inspection.side.effects=並提取副作用
js.redundant.switch.problems.inspection.single='switch' 語句僅包含一個非預設子句
js.redundant.switch.problems.inspection.single.replace=將 'switch' 取代為 'if'
js.referencing.mutable.variable.from.closure.inspection.name=從閉包中參照可變變數
js.regex.flag.d=符合索引 - 用於子字串符合的索引
js.regex.flag.g=全域符合 - 返回所有符合項
js.regex.flag.i=忽略大小寫 - 不區分大小寫的符合
js.regex.flag.m=多行 - ^ 和 $ 的每行符合
js.regex.flag.s=dotAll - . 符合換行符
js.regex.flag.u=unicode - 完整 unicode 支援
js.regex.flag.y=粘性 - 在確切的位置搜尋
js.remove.digit.separators=移除數字分隔符
js.remove.redundant.initializer.fix=移除冗餘的初始設定式
js.remove.unused.assignment=移除未使用的指派
js.rename.base.member=重新命名基{0}
js.rename.current.member=重新命名當前 {0}
js.rename.file.to.match.type.name=將檔案重命名為 {0} 以匹配 {1} 名稱
js.rename.file.to.match.type.name.family=重新命名檔案以符合類型名稱
js.rename.member.title={0} {1} {3} 的 {2}
js.rename.member.title.implements=實作
js.rename.member.title.overrides=覆寫
js.replace.string.concatenation.with.es6.template.fix.text=取代為模板字串
js.replace.string.concatenation.with.es6.template.inspection.name=已使用字串串聯而不是模板文字
js.replace.string.with.es6.template=取代為模板字串
js.replace.with.literal=取代為 {0} 文字
js.replace.with.shorthand.method.quick.fix=取代為速記方法
js.replace.with.shorthand.property.quick.fix=取代為速記屬性
js.replace.with.type.cast.to.primitive=取代為 {0} 的類型轉換
js.separate.bytes=分隔位元組
js.separate.digits=分隔數字
js.separate.nibbles=分隔半位元組
js.separate.thousands=分隔千分位
js.separate.thousands.in.integer.part=分隔整數中的千分位
js.separate.words=分隔 16 位單詞
js.show.dynamic.usages=顯示動態用法
js.show.type.info.action.error=找不到表達式
js.space.before.function.left.brace=函式左大括號
js.spaces.in.flow.category=在 Flow 中
js.split.declarations=拆分宣告
js.split.into.multiple.declarations=拆分為多個宣告
js.statement.context.type=語句
js.strict.mode.inspection.error={0} 不處於嚴格模式下
js.strict.mode.inspection.fix=新增“use strict”雜註
js.strict.mode.inspection.name=使用了非嚴格模式
js.strict.mode.inspection.redundant.pragma="use strict"雜註冗餘
js.strict.mode.remove.pragma=移除“use strict”雜註
js.string.template.line.separators.multispan=轉換為多行字串模板
js.string.template.line.separators.multispan.family.name=轉換為多行字串模板
js.string.template.line.separators.visible=轉換為可見行分隔符
js.string.template.line.separators.visible.family.name=轉換模板字串以使用可見行分隔符
js.suspicious.bind.with.arrow.function=箭頭函式 'bind' 用法可疑
js.suspicious.eq.plus.fix.name=取代為 '+='
js.suspicious.eq.plus.inspection.desc=可疑的 '=+' 指派: '+=' 可能拼寫錯誤
js.suspicious.eq.plus.inspection.name=可疑的 '=+' 指派
js.suspicious.name.assignment=''{0}'' 可能不應分配給 ''{1}''
js.suspicious.name.combination.inspection.name=可疑的變數/參數名稱組合
js.suspicious.name.parameter=''{0}'' 可能不應作為參數 ''{1}'' 傳遞
js.suspicious.name.return=''{0}'' 可能不應從方法 ''{1}'' 返回
js.switch.no.default='switch' 語句沒有 'default' 分支
js.switch.no.default.add=建立缺少的預設分支
js.switch.to.jsx.inspection.dismiss=關閉
js.testing.autoWatch.action.name=留意變化
js.testing.highlight.line=在測試程式碼中醒目提示失敗的行
js.testing.inspection.group.name=單元測試
js.tool.window.limit=顯示前 {0} 個錯誤。
js.tool.window.limit.all=檢視所有 {0} 個錯誤
js.top.level.await.expression.inspection=頂層 'await' 表達式
js.top.level.await.expression.inspection.description=使用了頂層 'await' 表達式
js.top.level.statement.context.type=頂級語句
js.trailing.comma.keep=保持
js.trailing.comma.remove=移除
js.trailing.comma.whenMultiline=多行時新增
js.undeclared.variable.inspection.name=隱式宣告的全域 JavaScript 變數
js.undefined.property.assignment.inspection.message=類型 {1} 中未定義屬性 {0}
js.undefined.property.assignment.inspection.name=未定義的屬性指派
js.unfiltered.for.in.loop.inspection.name=未過濾 for..in 迴圈
js.unfiltered.for.in.loop.skip.primitives=使用陣列或物件初始設定式跳過參照迭代
js.unfiltered.for.in.loop.skip.primitives.tooltip=在未修改 Object.prototype 和 Array.prototype 時啟用它
js.unnecessary.semicolon.fix.name=移除不必要的分號
js.unnecessary.semicolon.inspection.name=不必要的分號
js.unnecessary.semicolon.problem=不必要的分號 #loc
js.unreachable.switch.branches.ignore.with.dynamic=不在動態類型的上下文中顯示此警告
js.unreachable.switch.branches.inspection.desc=不可到達的 'case' 分支
js.unreachable.switch.branches.inspection.name=不可到達 'switch' 語句的 'case' 分支
js.unreachable.switch.branches.remove=移除不可到達的 'case' 分支
js.unresolved.variable.inspection.name=未解析的參照
js.unused.assignment.inspection.name=未使用的指派
js.unused.es6.import.inspection.name=未使用的 import
js.unused.global.symbol.inspection.name=未使用的全域符號
js.unused.local.symbol.inspection.name=未使用的區域符號
js.unused.symbol=未使用的 {0} #ref
js.unused.symbol.full=未使用的 {0}
js.unused.symbol.remove=移除未使用的 {0}
js.unused.symbols.group.name=未使用的符號
js.unwanted.symbols.group.name=可能不合需要的程式碼結構
js.url.import.usage.inspection.download.module.0.quick.fix.failed=下載模組 ''{0}'' 失敗
js.url.import.usage.inspection.download.module.0.quick.fix.progress=正在下載模組 ''{0}''
js.url.import.usage.inspection.download.module.0.quick.fix.success=模組 ''{0}'' 已成功下載
js.url.import.usage.inspection.download.module.0.quick.fix.warning=模組 ''{0}'' 已下載，但有錯誤
js.url.import.usage.inspection.download.module.0.quick.fix.warning.urls=失敗的 URL:
js.url.import.usage.inspection.download.module.quick.fix.name=下載模組
js.url.import.usage.inspection.name=使用了 URL 匯入
js.usage.type.call=函式呼叫中的用法
js.validate.jsdoc.inspection.name=JSDoc 中的語法錯誤和未解析的參照
js.validate.signature.inspection.name=簽名不符合
js.validate.types.inspection.name=類型不符合
js.validity.issues.group.name=有效性問題
js.value.assigned.is.never.used=從未使用過所賦之值 #loc
js.value.assigned.to.is.never.used=賦給 ''{0}'' 的值從未使用 #loc
js.variable.initializer.is.redundant=變數初始設定式冗餘 #loc
js.variable.might.not.been.initialized=變數可能尚未初始化 #loc
js.variable.problems.ignore.desc=對可變變數忽略
js.variable.problems.inspection.desc=變數 ''{0}'' 在子句 ''{1}'' 中宣告， 但在子句 ''{2}'' 中使用
js.variable.problems.inspection.desc.ref.error=存取時參照錯誤
js.variable.problems.inspection.name=宣告了變數並在不同的 'case' 子句中使用
js.void.function.result.used.description=使用了 void 函式返回值
js.void.function.result.used.name=使用了 void 函式返回值
js.wrap.settings.import=ES6 匯入/匯出
js.wrap.settings.object.types=物件類型
js.wrap.settings.union.and.intersection.types=聯合和相交類型
js.wrap.settings.var.group.name=變數宣告
jsdoc.tag=JSDoc 標記
jsdoc.tag.description=JSDoc 標記描述
jsdoc.tag.namepath=JSDoc 標記的 namepath
jsdoc.text=JSDoc 文本
jsdoc.type=JSDoc 類型
jshint.clear.field.to.disable=清除要停用的欄位
jshint.config.default.description=<div style="padding-bottom:10px"><div><b>.jshintrc</b></div><div style="padding-left:10px; padding-top:4px;">對 JavaScript 檔案進行 Linting 檢查時，IDE 會從檔案所在的目錄開始尋找 .jshintrc，然後上行到檔案系統根目錄。</div></div><div><div><b>package.json</b></div><div style="padding-left:10px; padding-top:4px;">將您的組態新增到專案的 package.json 檔案中的 <code>jshintConfig</code> 屬性下。</div></div>
jshint.config.error.cannot.locate.ext.config=JSHint: 無法定位擴展組態
jshint.config.error.cannot.parse.ext.config=JSHint: 無法解析擴展組態
jshint.config.error.failed.to.read.property=無法從 package.json 讀取 ''{0}'' 屬性
jshint.config.extends.cyclically=JSHint 組態迴圈擴展
jshint.config.failed.to.read=無法讀取 JSHint 組態
jshint.config.option.custom.browser.title=選擇 JSHint 組態檔案 (*.jshintrc)
jshint.config.option.custom.name=自訂組態檔案
jshint.config.option.default.name=預設
jshint.exception.balloon.action.configure.proxy.or.retry=<a href=''{0}''>組態 HTTP 代理</a>或<a href=''{1}''>重試</a>
jshint.exception.balloon.action.retry=<a href=''{0}''>重試</a>
jshint.illegal.integer=非法整數
jshint.inspection.message.config.not.found=未找到 JSHint 組態
jshint.inspection.message.duplicate.options=重複 JSHint 選項: {0}，{1}。
jshint.inspection.message.expected.value=預期值: {0}
jshint.inspection.message.expected.values.x.or.y=預期值: {0} 或 {1}
jshint.inspection.message.malformed.config=JSHint 組態格式錯誤
jshint.inspection.message.not.loaded=未載入 JSHint {0}
jshint.inspection.message.object.or.array.expected=應為物件或陣列
jshint.inspection.message.prefix=JSHint:
jshint.inspection.message.unexpected.jshint.option.name=意外的 JSHint 選項名稱
jshint.inspection.message.unexpected.value=意外值
jshint.label.bundled.suffix=(捆綁)
jshint.label.no.version=無版本
jshint.latedef.false.text=不警告
jshint.latedef.nofunc.text=<html><body>禁止變數在未定義的情況下使用，<br>但允許函式宣告。</body></html>
jshint.latedef.true.text=禁止變數在未定義的情況下使用
jshint.option.asi.description.short=禁止缺少分號的警告
jshint.option.bitwise.description.short=有關使用逐位運算符的警告
jshint.option.boss.description.short=禁止有關 <code>if/for/…</code> 內部指派的警告
jshint.option.browser.description.short=瀏覽器
jshint.option.camelcase.description.short=有關變數命名的警告
jshint.option.curly.description.short=塊省略 <code>{}</code> 時發出警告
jshint.option.debug.description.short=禁止有關偵錯模式的警告
jshint.option.devel.description.short=開發
jshint.option.edit.dialog.title=設定 ''{0}'' 選項
jshint.option.elision.description.short=禁止有關 ES3 陣列省略元素的警告
jshint.option.enforceall.description.short=程式碼未遵守最嚴格的組態時發出警告
jshint.option.eqeqeq.description.short=有關不安全比較的警告
jshint.option.eqnull.description.short=禁止有關 <code>== null</code> 的警告
jshint.option.es3.description.short=有關與 ES3 規範不相容的警告
jshint.option.es5.description.short=有關與 ES5 規範不相容的警告
jshint.option.esnext.description.short=EcmaScript.next
jshint.option.esversion.description.short=在與指定的 ECMAScript 版本不相容時發出警告
jshint.option.evil.description.short=禁止有關 <code>eval</code> 的警告
jshint.option.expr.description.short=禁止有關將表達式用作語句的警告
jshint.option.forin.description.short=有關不安全 <code>for..in</code> 的警告
jshint.option.freeze.description.short=有關覆蓋原生物件原型的警告
jshint.option.funcscope.description.short=禁止有關在已宣告塊外部使用變數的警告
jshint.option.futurehostile.description.short=有關使用在以後的 JavaScript 版本中定義的關鍵字的警告
jshint.option.gcl.description.short=將 JSHint 設為與 Google Closure Compiler 相容
jshint.option.globalstrict.description.short=禁止有關使用全域嚴格模式的警告
jshint.option.immed.description.short=有關未使用括號包裝函式而直接呼叫函式的警告
jshint.option.indent.description.short=縮排
jshint.option.iterator.description.short=禁止有關 <code>__iterator__</code> 屬性的警告
jshint.option.lastsemic.description.short=禁止有關缺少分號的警告，但僅當單行塊中的最後一條語句省略分號時才顯示該警告
jshint.option.latedef.description.short=當變數在未定義的情況下使用時發出警告
jshint.option.laxbreak.description.short=禁止有關不安全換行的警告
jshint.option.laxcomma.description.short=禁止有關編碼樣式以逗號開頭的警告
jshint.option.loopfunc.description.short=禁止有關函式在迴圈內部的警告
jshint.option.maxcomplexity.description.short=程式碼中的最大迴圈復雜度
jshint.option.maxdepth.description.short=塊的最大深度
jshint.option.maxerr.description.short=最大錯誤數
jshint.option.maxlen.description.short=行的最大長度
jshint.option.maxparams.description.short=函式中的最大參數數量
jshint.option.maxstatements.description.short=函式中的最大語句數量
jshint.option.module.description.short=ECMAScript 6 模組
jshint.option.moz.description.short=檢查程式碼是否使用 Mozilla JavaScript 擴展
jshint.option.multistr.description.short=禁止有關多行字串的警告
jshint.option.newcap.description.short=有關使用非大寫形式的建構函式的警告
jshint.option.noarg.description.short=有關 <code>arguments.caller</code> 和 <code>.callee</code> 的警告
jshint.option.nocomma.description.short=有關使用逗號運算符的警告
jshint.option.noempty.description.short=有關空塊的警告
jshint.option.nomen.description.short=不允許使用 _ in 變數
jshint.option.nonbsp.description.short=有關“不間斷空格”字元的警告
jshint.option.nonew.description.short=有關副作用 <code>new</code> 用法的警告
jshint.option.nonstandard.description.short=轉義和未轉義
jshint.option.notypeof.description.short=禁止有關無效 <code>typeof</code> 運算符值的警告
jshint.option.noyield.description.short=禁止在產生器函式中無 yield 語句時有關產生器函式的警告
jshint.option.onevar.description.short=每個函式一個變數語句
jshint.option.passfail.description.short=出現第一個錯誤時停止
jshint.option.plusplus.description.short=有關使用一元遞增和遞減運算符的警告
jshint.option.predef.description.short=預定義(以 , 分隔)
jshint.option.predef.details=指定全域變數及其可分配狀態:\\n<pre>DISQUS:true、jQuery:false</pre>\\n<p/>此時，JSHint 允許您覆寫 DISQUS，但禁止覆寫 jQuery。
jshint.option.proto.description.short=禁止有關 <code>__proto__</code> 屬性的警告
jshint.option.quotmark.description.short=引號
jshint.option.scripturl.description.short=禁止有關使用以腳本為目標的 URL 的警告
jshint.option.shadow.description.short=禁止有關變數隱藏的警告
jshint.option.singlegroups.description.short=如果未嚴格要求使用分組運算符，禁止使用該運算符
jshint.option.smarttabs.description.short=在空格僅用於對齊時，禁止有關將制表符和空格混合使用的警告
jshint.option.strict.description.short=程式碼未採用嚴格模式時發出警告
jshint.option.sub.description.short=如果可以使用點符號表示 <code>[]</code> 符號，則禁止有關使用後者的警告
jshint.option.supernew.description.short=禁止有關“怪異”建構的警告
jshint.option.trailing.description.short=有關尾隨空格的警告
jshint.option.typed.description.short=輸入的陣列
jshint.option.undef.description.short=未定義變數時發出警告
jshint.option.unused.description.short=存在未使用的變數時發出警告
jshint.option.validthis.description.short=禁止有關可能違反嚴格要求的警告
jshint.option.varstmt.description.short=有關使用 VariableStatements 的警告
jshint.option.white.description.short=不允許使用雜亂的空格
jshint.option.withstmt.description.short=禁止有關使用 with 語句的警告
jshint.option.worker.description.short=Web 工作執行緒
jshint.option.wsh.description.short=Windows Script Host
jshint.options.tree.tooltip.set.a.new.value=設定新值
jshint.progress.title=JSHint {0}
jshint.progress.title.downloading=正在下載 {0}
jshint.progress.title.updating.jshint=正在將 JSHint 更新到 {0}
jshint.quotmark.double.text=僅允許雙引號
jshint.quotmark.false.text=允許兩種引號
jshint.quotmark.single.text=僅允許單引號
jshint.quotmark.true.text=僅允許單引號或雙引號
jshint.suppress.text.suppress.for.line=禁止行
jshint.tree.link.set=設定
jshint.unused.false.text=不檢查任何內容
jshint.unused.strict.text=檢查所有變量和參數
jshint.unused.true.text=<html><body>檢查所有變量和參數，但允許<br>使用的參數後存在未使用參數</body></html>
jshint.unused.vars.text=檢查變數，而不是函式參數
jshint.use.config.files=使用組態檔案
jshint.version.label=版本(&V):
jsx.code.style.attribute.default.value=為 JSX 特性新增:
jsx.code.style.attribute.default.value.braces=大括號
jsx.code.style.attribute.default.value.none=無
jsx.code.style.attribute.default.value.quotes=引號
jsx.code.style.attribute.default.value.typebased=基於類型
jsx.convert.html.attributes.to.jsx=將 HTML 貼上到 JSX 檔案時轉換特性
jsx.dom.nesting.inspection.message=''{0}'' 不能作為 ''{1}'' 的子級出現
jsx.dom.nesting.inspection.message.text=文本節點不能顯示為 ''{0}'' 的子級
jsx.dom.nesting.inspection.message.tr=''{0}'' 不能作為 ''{1}'' 的子級出現。在您的程式碼中新增 <tbody>、<thead> 或 <tfoot> 以符合瀏覽器生成的 DOM 樹。
jsx.dom.nesting.inspection.name=無效的 DOM 元素嵌套
jsx.html.context.type=JSX HTML
jsx.missing.namespace.inspection.name=缺少 JSX 命名空間
jsx.missing.namespace.inspection.text=在未匯入 {0} 的情況下使用 JSX
jsx.syntax.used.description=已使用 JSX 語法
jsx.syntax.used.name=已使用 JSX 語法
jsx.unresolved.component.name=未解析的 JSX 元件
label.choose.main.file=選擇主檔案
label.choose.output.directory=選擇輸出目錄
label.compiles.js.files=編譯 .js 檔案
label.compress.js.files=壓縮 .js 檔案
label.exclude.methods.classes=排除類別方法:
label.import.popup=自動匯入工具提示
label.method.should.be.defined=方法應已定義
label.minimum.language.level=最低語言級別:
label.name=名稱: 
label.name.injection=名稱(&N):
label.namespace=命名空間:
label.path=路徑(&P):
label.type=類型: 
label.wsl.node.interpreter=WSL Node.js 解釋器(&N):
linemarker.implemented=已實作
linemarker.implementing=實作
linemarker.implements.invalid=<無效>
linemarker.implements.several=實作多種接口方法
linemarker.implements.text=實作 {1} 中的 {0}
linemarker.javascript.sources=JavaScript 源
linemarker.javascript.typescript=JavaScript/TypeScript 行標記
linemarker.overridden=覆寫
linemarker.overrides.text=覆寫 {1} 中的 {0}
linemarker.overriding=覆寫
linemarker.typescript.declaration=TypeScript 宣告
list.item.class.field=類別欄位
list.item.declarations.function.members.to.be.converted.to.class.members=要轉換為類別成員的函式成員的宣告
list.item.declarations.that.were.not.converted=未轉換的宣告
list.item.function.converted.to.class=轉換為類別的函式
list.item.function.to.be.converted.to.class=要轉換為類別的函式
list.item.global.or.module.constant=全域或模組常數
list.item.google.javascript.style.guide=Google JavaScript 樣式指南
list.item.javascript.file=JavaScript 檔案
list.item.javascript.standard.style=JavaScript 標準樣式
list.item.local.constant=區域常數
list.item.typescript.file=TypeScript 檔案
list.item.typescript.jsx.file=TypeScript JSX 檔案
livetemplate.description.arf=使用箭頭函式包圍
livetemplate.description.console.assert=console.assert()
livetemplate.description.console.error=console.error()
livetemplate.description.console.info=console.info()
livetemplate.description.console.log=console.log()
livetemplate.description.console.trace=console.trace()
livetemplate.description.console.warn=console.warn()
livetemplate.description.defi=插入 define() 表達式
livetemplate.description.exportall=匯出語句 - 從 'a' 匯出 *
livetemplate.description.exportfrom=匯出語句 - 從 ''a'' 匯出 {b} 
livetemplate.description.exportitems=匯出語句 - export {b}
livetemplate.description.flow=插入 @flow 註解
livetemplate.description.fori=建立迭代迴圈
livetemplate.description.importdefault=import 語句 - 從 'a' 匯入 b
livetemplate.description.importfrom=import 語句 - 從 ''a'' 匯入 {b}
livetemplate.description.importns=import 語句 - 從 'a' 匯入 * as b
livetemplate.description.itar=遍歷陣列元素
livetemplate.description.iter=迭代 (for..of)
livetemplate.description.itera=迭代 (for await..of)
livetemplate.description.itin=迭代(for..in)
livetemplate.description.moduleexports=匯出語句 - module.exports = a
livetemplate.description.ref=插入參照路徑註釋
livetemplate.description.ritar=以相反順序遍歷陣列的元素
livetemplate.description.us=插入 'use strict' 語句
lsp.executable.error=找不到 {0} 的可執行檔案。
lsp.interpreter.error=未組態本地或 WSL Node.js 解釋器。
macro.js.component.type.of=jsComponentTypeOf(Array)
macro.js.suggest.default.variable.kind=jsSuggestDefaultVariableKind(Boolean)
make.method.static=設為 'static'
make.private=設為 private
members.to.implement.chooser.title=選擇要實作的成員
members.to.override.chooser.title=選擇要覆寫的成員
merged.process.output.text={0}{2, choice, 0#\\n\\n標準錯誤:\\n{1}|1#}{4, choice, 0#\\n\\n標準輸出:\\n{3}|1#}\\n\\n{5}
method.return.types.in.call.chains=呼叫鏈中的函式返回值類型
modules.selected=選定
move.members.dialog.title=移動成員
move.members.refactoring.name=移動成員
multiple.inheritance=多重繼承
new.actionscript.class.dialog.title=新增 ActionScript 類別
new.actionscript.interface.dialog.title=新增 ActionScript 接口
new.constructor.action.description=建立建構函式
new.constructor.action.text=建構函式
new.field.action.description=在類別中建立新字段
new.field.action.text=欄位
new.method.action.description=在類別中建立新方法
new.method.action.text=方法
no.candidates=無候選項
no.executable.found.in.path=在 {0, choice, 0#%PATH%|1#$PATH} 中未找到可執行檔案
no.members.to.implement=找不到要實作的成員
no.members.to.override=找不到要覆寫的成員
no.methods.to.implement=找不到要實作的方法
no.methods.to.override=找不到要覆寫的方法
no.variables.for.getter=找不到沒有 getter 的欄位
no.variables.for.getter.setter=找不到沒有 getter 和 setter 的欄位
no.variables.for.setter=找不到沒有 setter 的欄位
node.core.core_modules_fetch_timed_out.dialog.message=無法提取核心模組: 已超時
node.core.enable_coding_assistance_intention.name=啟用 Node.js 的編碼輔助
node.core.failed_to_fetch_node_core_modules.dialog.message=無法提取 Node 核心模組
node.core.make.sure.javascript.debugger.plugin.enabled.dialog.message=確保已啟用 'JavaScript Debugger' 延伸模組
node.core.navigate_action_text.text=組態 Node.js…
node.core.not_ready_for_core_modules_configuration.dialog.message=未準備好進行核心模組組態
node.debug.cannot_connect_to_vm.error.message=無法連線到虛擬機 {0}
node.debug.cannot_get_localhost_IPv4.error.message=無法獲取 127.0.0.1 IPv4
node.execution.failed.to.prepare.target.environment.error=無法準備環境: {0}
node.execution.starting.process.progress.title=正在啟動 ''{0}''…
node.interpreter.command_timed_out.dialog.message=''{0}'' 指令執行超時(>{1} 毫秒)
node.interpreter.download=下載 Node.js
node.interpreter.field.add.item.text=新增…
node.interpreter.field.unexpected_value.text=意外值 {0}
node.interpreter.invalid_interpreter.error.message=無效 ''{0}''
node.interpreter.label=Node 解釋器(&I):
node.interpreter.no_local_interpreter.error.message=沒有本地 Node.js 解釋器
node.interpreter.node_from_path.reference.name=node
node.interpreter.not.found=找不到 {0}
node.interpreter.project_node.reference.name=專案
node.interpreter.reference_not_found.text=未找到
node.interpreter.specified_interpreter_correctly.dialog.message=正確指定 Node.js 解釋器
node.interpreter.unavailable.target=不可用的目標: {0}
node.interpreter.unresolved_reference.error.message=未解析的解釋器 ''{0}''
node.interpreter.unspecified.error.text=指定 Node.js 解釋器
node.interpreter.unspecified_interpreter.dialog.message=指定 Node.js 解釋器
node.interpreter.unspecified_local_interpreter.dialog.message=指定本地 Node.js 解釋器
node.js.add.interpreter.action=新增{0}…
node.js.configure.interpreter=組態{0}
node.js.downloading=正在下載 Node.js {0}
node.js.inspection.group.name=Node.js
node.js.interpreters=Node.js 解釋器
node.js.invalid.node=該專案使用了無效的 Node.js 路徑。<br>它已更新為使用 {0} 中的 Node.js。
node.js.missing.require=缺少 require() 語句
node.js.quickfix.install.node.module.devDependencies.family.name=安裝模組作為開發相依關係
node.js.quickfix.install.node.module.error.no.interpreter.text=無法安裝 Node.js 模組: 請指定預設 Node.js 解釋器。
node.js.quickfix.install.node.module.error.no.interpreter.title=安裝 Node.js 模組
node.js.quickfix.install.node.module.error.prefix.text=無法安裝 Node.js 模組: {0}
node.js.quickfix.install.node.module.family.name=安裝模組
node.js.quickfix.install.node.module.text=安裝 ''{0}''
node.js.quickfix.install.node.module.update.modules.family.name=執行 'npm install'
node.js.quickfix.install.node.module.with.dev.dependencies.text=安裝 ''{0}'' 作為開發相依關係
node.js.quickfix.run.command=執行 ''{0}''
node.js.remote.interpreters.plugin.missing=缺少 Node.js 遠端解釋器延伸模組。請啟用 {0} 中的延伸模組
node.js.select.file=選擇 {0} 檔案
node.js.set.project.interpreter.action=設定為專案解釋器
node.js.unresolved.api=未解析的 Node.js API
node.no.interpreter=無解釋器
node.npm.cannot_find_package_by_reference.dialog.message=找不到軟體套件管理器 ''{0}''
node.npm.cannot_find_project_package_manager.dialog.message=找不到專案 Node.js 軟體套件管理器
node.npm.cannot_resolve_package_manager.dialog.message=無法解析 ''{0}'' 軟體套件管理器
node.npm.correct_path_to_npm_or_yarn_package.dialog.message=指定 npm 或 yarn 軟體套件的正確路徑: 無此類別目錄“{0}”
node.npm.invalid_package_manager.binary_file_not_found.dialog.message=指定有效的軟體套件管理器: 在 ''{0}'' 目錄內部找不到二進制檔案
node.npm.package_manager_link.text=軟體套件管理器
node.npm.project_package_manager_disallowed_here.dialog.message=無法在此處參照專案 npm 軟體套件
node.npm.specify_npm_or_yarn_package.dialog.message=指定 npm 或 yarn 軟體套件
node.npm.unspecified_package_manager.dialog.message=未指定軟體套件管理器
node.package.binary.file.hint=指向 {0} 的二進制檔案的路徑
node.package.cannot.find.bin.file.dialog.message=找不到 ''{0}'' 軟體套件的 bin 檔案
node.package.dropDownList.select=選擇…
node.package.empty.error.message=專案名稱為空
node.package.empty.hint={0} 軟體套件目錄路徑
node.package.empty.hint.pkg1.or.pkg2={0} 或 {1}
node.package.field.not_found.text=未找到
node.package.manager.label=軟體套件管理器 (&M):
node.package.name.URL-friendly.characters.error.message=專案目錄名稱應僅包含適用於 URL 的字元
node.package.name.capital.letters.error.message=專案目錄名稱不應包含大寫字母
node.package.name.core.module.error.message=''{0}'' 不能用作專案名稱，因為它是 Node.js 核心模組的名稱
node.package.name.forbidden.error.message=''{0}'' 不能用作專案名稱
node.package.name.leading.or.trailing.spaces.error.message=專案目錄名稱不應包含前導空格或尾隨空格
node.package.name.period.error.message=專案目錄名稱不應以句點開頭
node.package.name.special.characters.error.message=專案目錄名稱不應包含特殊字元("~'!()*")
node.package.name.too.long.error.message=專案目錄名稱不應超過 214 個字元
node.package.name.underscore.error.message=專案目錄名稱不應以下劃線開頭
node.package.none=無軟體套件
node.package.selector.multiple.packages.binary.file.title=選擇 {0} 的軟體套件目錄或二進制檔案
node.package.selector.multiple.packages.description=選擇 {0}
node.package.selector.multiple.packages.title=選擇軟體套件目錄
node.package.selector.single.package.title=選擇 {0} 軟體套件目錄
node.package_documentation.installed_version.text=已安裝版本: {0}
node.package_documentation.latest_version.text=最新版本: {0}
node.packages.cannot_find_working_directory.text=無法確定 {0} 的工作目錄: {1}
node.wsl.network.connection.failure=無法建立從 WSL 到 Windows 主機的網絡連線(可能被防火牆阻止)。\\n要了解詳細資訊，請參閱: https://jb.gg/wsl-firewall
node.wsl.unavailable.dialog.message=WSL 不可用
non.ascii.identifiers.inspection.name=包含非 ASCII 符號的關鍵字
non.ascii.identifiers.mixed.set=<html>名稱同時包含 ASCII 和非 ASCII 符號: {0}</html>
non.ascii.identifiers.non.ascii.found=<html>名稱包含非 ASCII 符號: {0}</html>
non.ascii.identifiers.only.ascii=僅允許 ASCII 名稱
non.parenthesized.single.parameter=未使用括號括起來的單個參數
non.parenthesized.single.parameter.description=未使用括號括起來的單個參數
not.installed.package=未安裝軟體套件
notification.content.html.href.settings.show.inspection.settings.or.href.undo.undo.html=<html><a href='settings'>顯示檢查設定</a>或<a href='undo'>撤消</a></html>
notification.content.notifications.are.enabled.for.all.package.json.files=為所有 package.json 檔案啟用通知
notification.content.notifications.are.enabled.for.current.package.json=為當前 package.json 啟用通知
notification.content.show.details=顯示詳細資訊
notification.group.code.vision.performance.watcher=JavaScript: Code Vision 性能觀察程序
notification.group.grunt.console=Grunt 'watch' 任務狀態已更改
notification.group.jest=Jest 測試執行失敗
notification.group.linters=JavaScript linter
notification.group.narrowed.types=JavaScript: 已停用限縮的類型的著色
notification.group.nodejs.assistance=Node.js 編碼輔助失敗
notification.group.nodejs.interpreter=Node.js 解釋器路徑已更新
notification.group.package.json=來自 package.json 的相依項可用
notification.group.package.json.disabled=來自 package.json 的相依項: 通知已停用
notification.group.project.generator=JavaScript 專案生成失敗
notification.group.vitest=Vitest 測試執行失敗
notification.title.cannot.download.types.node=無法下載 @types/node
notification.title.cannot.enable.node.js.coding.assistance=無法啟用 Node.js 編碼輔助
notification.title.cannot.generate=無法生成 {0}
notification.title.coloring.types.narrowed.by.type.guard.was.disabled=按類型防護限縮類型著色被停用
notify.urls.more=… 和其他 {0,number} 個
npm.before.run.task=執行 npm 腳本
npm.before.run.task.descr=執行 npm {0, choice, 0#腳本|1#腳本|2#腳本}{1} [{2}]
npm.dialog.message.cannot.resolve.package.manager=無法解析 ''{0}'' 軟體套件管理器
npm.downloading_package=正在下載 {0}…
npm.failed_to_install_package.title.message=無法安裝 {0}
npm.modules.inspection.content.of.require.module.not.installed.warning=未安裝模組
npm.modules.inspection.content.of.require.not.in.dependencies.warning=package.json 相依關係中未列出模組
npm.modules.install.global.types.dialog.title=安裝 TypeScript 定義
npm.modules.install.global.types.directory.error=無法建立所需的目錄
npm.modules.install.global.types.fix.name=安裝 TypeScript 定義以提供更好的類型資訊
npm.no.scripts.found=未找到腳本
npm.rc.command.label=指令:(&C)
npm.rc.environmentVariables.label=環境:
npm.rc.nodeInterpreter.label=Node 解釋器(&I):
npm.rc.nodeOptions.label=Node 選項:
npm.rc.packageJson.browseDialogTitle=選擇 package.json 檔案
npm.rc.packageJson.label=package.json(&P):
npm.rc.scripts.label=腳本 (&T):
npm.rc.scriptsArguments.label=實參(&R):
npm.task.title=NPM 腳本
numeric.enum.values=數值枚舉值
package.description=軟體套件 {0}
package.json.install.types.fix.family.name=為軟體套件安裝 @types
package.version.range.hint={0, choice, 0#允許|1#允許次要更新:|2#允許更新檔更新} {1} ≤ 版本 \\\\&lt; {2}
package.version.range.info={0, choice, 0#未安裝|1#已安裝: ?|2#已安裝: {1}}，最新: {2, choice, 0#正在載入…|1#未找到|2#{3}}
package_json.install_dependencies.notification.content=來自 {0}
package_json.install_dependencies.notification.title=安裝相依項
package_json.install_dependencies_multiple.notification.content=來自 {0} 和其他 {1} 個
package_json.notifications_are_disabled.notification.content=已停用從 {0} 安裝相依項的通知。<p>使用“{1}”動作重新啟用通知。
package_json.update_dependencies.notification.title=更新相依項
parameter.type.is.not.specified=參數 ''{0}'' 的類型未指定。\\n是否繼續?
parameters.in.parentheses=圓括號中的參數
parameters.in.parentheses.description=圓括號中的參數
please.specify.package.manager=指定<a href="">軟體套件管理器</a>。
popup.advertisement.latest.available.versions.for.all.distribution.tags=所有發行版標籤的最新可用版本
popup.advertisement.start.typing.package.name=開始輸入軟體套件名稱，以從 npm 官方公共註冊表中獲取更具體的結果
popup.content.cannot.edit.selected.node.js.interpreter=無法編輯選定的 Node.js 解釋器
popup.title.choose.class=選擇類別
popup.title.select.destructuring.assignment.target=選擇解構指派目標
popup.title.target.function=目標函式
postfix.template.condition.array.name=陣列
postfix.template.condition.non.void.name=非 Void
postfix.template.provider.name=JavaScript 和 TypeScript
process.terminated=程序已終止
progress.subtitle.install=正在通過 {1} 安裝 {0}…
progress.text.initializing.opened.files=正在初始化開啟的檔案
progress.text.modifying=正在修改 {0}
progress.text.processing=正在處理 {0}{1}
progress.title.compiling.typescript.files=正在編譯 TypeScript 檔案
progress.title.configuring.node.js.coding.assistance=正在組態 Node.js 編碼輔助…
progress.title.detect.overridden.methods=檢查覆寫方法
progress.title.downloading.documentation=正在下載文檔
progress.title.downloading.library=正在下載庫
progress.title.downloading.typings=正在下載 typings
progress.title.executing.performance.task.on.files=正在檔案上執行性能任務
progress.title.install=安裝 {0}
progress.title.install.npm.module=安裝 npm 模組 ''{0}''
project.generation=生成專案
protractor.rc.configurationFile.label=組態檔案(&C):
protractor.rc.configurationFile.title=選擇 Protractor 組態檔案
protractor.rc.protractorOptions.emptyText=CLI 選項，例如 --browser 或 --rootElement
protractor.rc.protractorOptions.label=Protractor 選項 (&O):
protractor.rc.protractorPackage.label=Protractor 軟體套件(&P):
radio.set.options.manually=手動設定選項
radio.use.tsconfig.json=使用 tsconfig.json
rc.environmentVariables.label=環境變數(&E):
rc.nodeOptions.label=Node 選項 (&O):
rc.testConfig.presentable.name={0} 中的所有測試
rc.testDirectory.presentable.name={0} 中的測試
rc.testOrSuiteScope.emptyTest=空測試名稱
rc.testOrSuiteScope.suite.label=套件名稱:
rc.testOrSuiteScope.suite.title=編輯套件名稱
rc.testOrSuiteScope.test.label=測試名稱:
rc.testOrSuiteScope.test.title=編輯測試名稱
rc.testRunScope.all=所有測試(&L)
rc.testRunScope.directory=目錄(&D)
rc.testRunScope.suite=套件
rc.testRunScope.test=測試(&T)
rc.testRunScope.testDirectory.browseTitle=選擇測試目錄
rc.testRunScope.testDirectory.label=測試目錄:
rc.testRunScope.testFile=測試檔案(&F)
rc.testRunScope.testFile.browseTitle=選擇測試檔案
rc.testRunScope.testFile.label=測試檔案:
rc.workingDirectory.browseDialogTitle=選擇工作目錄
rc.workingDirectory.label=工作目錄(&W):
react.class.component.type.class=類別
react.class.component.type.function=函式
react.class.to.function.caret.at.class=文字游標應置於要轉換的類別處
react.function.to.class.caret.at.function=文字游標應置於要轉換的函式處
recursive.call=遞迴呼叫
refactoring.create.react.component.title=建立元件
refactoring.destructuring.vars.for.refactor.this=物件或陣列解構…
refactoring.destructuring.vars.intention.const.to.var.warning=在轉換期間，醒目提示顯示的 const 變數將轉換為 let 變數。\\n是否要繼續?
refactoring.destructuring.vars.intention.const.to.var.warning.title=變數關鍵字更改
refactoring.destructuring.vars.intention.deconstruct=生成解構模式
refactoring.destructuring.vars.intention.depropagate=將解構取代為屬性和索引存取
refactoring.destructuring.vars.intention.guard.conflict=通過類型防護將表達式類型限縮為 ''{0}''，該類型防護在重構後將不起作用
refactoring.destructuring.vars.intention.name=引入物件或陣列解構
refactoring.destructuring.vars.intention.name.array=引入陣列解構
refactoring.destructuring.vars.intention.name.object=引入物件解構
refactoring.destructuring.vars.intention.propagate=傳播到解構宣告
refactoring.destructuring.vars.intention.replace.array=取代為數組解構
refactoring.destructuring.vars.intention.replace.object=取代為物件解構
refactoring.destructuring.vars.intention.replace.promise=取代為 'await Promise.all'
refactoring.destructuring.vars.intention.replace.shorthand=取代為解構和速記屬性
refactoring.extract.react.component.component.for.refactor.this=提取元件…
refactoring.extract.react.component.no.expression=所選內容不構成 JSX 表達式
refactoring.extract.react.component.no.scope=找不到用於放置所建立元件的作用域
refactoring.extract.react.component.title=提取元件
refactoring.react.class.to.function.conflict.used.with.ref={0} 與 ''ref'' 特性結合使用。無法為無狀態函式元件提供 ref
refactoring.react.class.to.function.intention.title=轉換為函式元件
refactoring.react.class.to.function.refactoring.title=轉換為函式元件
refactoring.react.could.not.find.in.template=無法重構。找不到名稱為 {0} 的元素。可能的程式碼模板 {1} 無效嗎?
refactoring.react.function.to.class.intention.title=轉換為類別元件
refactoring.react.function.to.class.refactoring.title=轉換為類別元件
refactoring.react.function.to.class.used.in.call.conflict=呼叫表達式中使用了 {0}
refactoring.react.function.to.class.used.in.new.conflict=\\ ''new'' 表達式中使用了 {0}
reg.exp.tagged.template=''{1}'' 標記模板中的 {0}
remove.type.prefix=移除類型前綴
remove.unnecessary.parentheses.fix.text=移除不必要的圓括號
rename.accessors.dialog.text=是否將屬性存取器也重命名為 ''{0}''?
rename.accessors.dialog.title=重新命名欄位
rename.destructuring.property.description=解構屬性參照多個成員。應重新命名相關屬性，否則可能導致程式碼不一致。
rename.destructuring.property.title=重新命名解構屬性
rename.prompt.do.you.want.to.rename.base.method=是否要重新命名基方法?
rename.react.hook.variable.description=將相關狀態變數重命名為:
rename.react.hook.variable.title=重新命名狀態變數
rename.type.members.destructuring.description=檢測到解構屬性中的用法。應重新命名相關屬性，否則可能導致程式碼不一致。
rename.type.members.title=重新命名類型成員
rename.type.members.union.intersection.mapped.description=檢測到聯合、相交或映射類型用法。應重新命名相關屬性，否則可能導致程式碼不一致。
replace.implements.keyword.fix.name=將 'implements' 更改為 'extends'
required.parameters.are.not.permitted.after.optional.parameters=必選參數不能位於可選參數後
return.type.is.not.resolved=返回值類型 ''{0}'' 未解析。\\n是否繼續?
separator.deprecated.settings=棄用的設定
service.configurable.default={0} (預設)
settings.code.style.Trailing.comma=尾隨逗號(&T):
settings.code.style.always=始終
settings.code.style.dont.use=不使用
settings.code.style.double=雙
settings.code.style.in.new.code=在 IDE 生成的程式碼中
settings.code.style.indent.all.chained.calls.in.a.group=縮排組中的所有鏈式呼叫
settings.code.style.indent.chained.methods=縮排鏈式方法
settings.code.style.option.use=使用
settings.code.style.quotes=引號(&Q)
settings.code.style.semicolon.to.terminate.statements=分號(&S)
settings.code.style.single=單
settings.code.style.use=使用
settings.javascript.bower.configurable.name=Bower
settings.javascript.field.names.completion=為類別欄位建議名稱 (&F)
settings.javascript.lang.templates.configurable.name=模板
settings.javascript.linters.autodetect.configure.automatically=自動 {0} 組態 (&A)
settings.javascript.linters.autodetect.configure.automatically.help.text={0} 將使用 node_modules 目錄中的 {1} 軟體套件，還會使用與當前檔案或其任何父目錄位於同一目錄中的 {2} 組態檔案。
settings.javascript.linters.autodetect.configure.manually=手動 {0} 組態 (&M)
settings.javascript.linters.autodetect.disabled=停用 {0}(&D)
settings.javascript.linters.configurable.name=程式碼品質工具
settings.javascript.linters.eslint.configurable.name=ESLint
settings.javascript.linters.jshint.configurable.name=JSHint
settings.javascript.only.type.based.completion=僅基於類型補全 (&C)
settings.javascript.only.type.based.completion.tooltip=根據類型資訊顯示較少的補全建議。可能會顯著提高性能。
settings.javascript.opt.chain.completion=為可 null 類型建議包含可選連結的條目(&O)
settings.javascript.overrides.completion=在覆寫補全中展開方法體
settings.javascript.root.configurable.name=JavaScript
settings.javascript.var.names.completion=建議變數和參數名稱(&V)
settings.javascript.var.names.completion.desc=補全名稱
settings.javascript.var.names.completion.names.only=無類型
settings.javascript.var.names.completion.types=為建議的參數名稱新增類型註解(&T)
settings.javascript.var.names.completion.types.everywhere=隨處都是類型
settings.javascript.var.names.completion.types.except.fields=隨處都是類型，欄位除外
settings.javascript.var.names.completion.types.for.params=具有函式參數的類型
settings.javascript.var.names.completion.types.for.params.fields=具有參數和欄位的類型
settings.nodejs.coding.assistance.label=Node.js 編碼協助 (&A):
settings.nodejs.coding.assistance.manage.scopes.label=管理作用域…
settings.nodejs.name=Node.js
settings.typescript.root.configurable.name=TypeScript
space.after.dots.in.rest.spread=在 rest/spread 中的 '...' 後面
space.after.generator.mult=在產生器中的 '*' 後面 
space.after.name.value.separator=在屬性名稱-值分隔符 ':' 後面
space.after.type.colon=在類型參照冒號 ':' 後面
space.before.class.interface.module.lbrace=類別/接口/模組左大括號
space.before.class.lbrace=類別的左大括號
space.before.function.left.parenth=在函式表達式中
space.before.generator.mult=在產生器中的 '*' 前面 
space.before.name.value.separator=在屬性名稱-值分隔符 ':' 前面
space.before.type.colon=在類型參照冒號 ':' 前面
spaces.after.unary.not=在 'not' (!) 和 '!!' 後面
spaces.arrow.function=箭頭函式(=>)
spaces.async.arrow.function=在異步箭頭函式中
spaces.before.unary.not=在 'not' (!) 和 '!!' 前面
spaces.within.array.initializer=陣列中括號
spaces.within.import.braces=ES6 匯入/匯出大括號
spaces.within.indexer.brackets=索引存取中括號
spaces.within.interpolation.expressions=插值表達式
spaces.within.object.literal.braces=物件文字大括號
spaces.within.object.type.braces=物件文字類型大括號
spaces.within.type.assertion=類型斷言
spaces.within.unary.additive=一元加法運算符 (+,-,++,--)
spaces.within.union.and.intersection=聯合和相交類型
standardjs.action.fix.problems.description=修正標準程式碼樣式問題
standardjs.codestyle.updated={0}: 專案程式碼樣式設定已更新
standardjs.codestyle.updated.config.section={0}: 專案程式碼樣式設定已根據 package.json 中的 ''standard'' 部分更新
standardjs.codestyle.updated.dependency={0}: 專案程式碼樣式設定已根據 package.json 中的 ''standard'' 相依項更新
standardjs.edit.settings.caption=ESlint/標準程式碼樣式
standardjs.editor.notification.action=是
standardjs.editor.notification.can.be.enabled.text=為此專案使用 JavaScript 標準程式碼樣式?
standardjs.editor.notification.do.not.show.text=否
standardjs.error.unsupported.package=不支持的軟體套件版本。請將 ''Standard'' 軟體套件升級到最低版本 {0}。
standardjs.name=標準程式碼樣式
start.template.string.interpolation.on.typing=鍵入 '$' 時啟動模板字串內插
status.text.add.interpreter.with=使用 {0} 新增解釋器
status.text.javascript.language.service.default.project.errors=顯示專案錯誤
status.text.no.errors.in.current.file=當前檔案中沒有錯誤。
status.text.no.interpreters.added=未新增解釋器
status.text.project.structure.isn.t.available=專案結構不可用
status.text.refresh.required=需要重新整理
status.text.running.which.node=正在執行 \`which node\`…
status.text.service.doesn.t.contain.open.projects=服務不包含開放專案
structural.search.anonymous.functions=匿名函式
structural.search.classes=類別
structural.search.comparison.to.self=與自身比較
structural.search.console.log.calls=呼叫 console.log()
structural.search.constants=常數
structural.search.empty.functions=空函式
structural.search.function.calls=函式呼叫
structural.search.functions=函式
structural.search.functions.with.boolean.parameters=使用布爾參數的函式
structural.search.var.statements=Var 語句
structural.search.variables=變數
structural.search.while.loops=While 迴圈
structural.search.with.statements=With 語句
stylelint.action.background.title=正在執行 stylelint --fix…
stylelint.action.fix.problems.description=通過呼叫 'stylelint --fix' 修正 Stylelint 問題
stylelint.action.modal.title=Stylelint 修正
successfully.downloaded=已成功下載
superclass.cannot.be.extracted.from.enum=無法從枚舉中提取超類別
superclass.cannot.be.extracted.from.mxml.component=無法從 MXML 元件中提取超類別。
superclass.cannot.be.extracted.from.type.alias=無法從類型別名中提取超類別
superclass.label.text=超類別(&S):
tab.title.compile.errors=編譯錯誤
tab.title.convert.to.class=轉換為類別
tab.title.errors=錯誤
tab.title.project.errors=專案錯誤
tab.title.refactoring.preview=重構預覽
tab.title.refactoring.result=重構結果
template.add.imports=新增明確的匯入
terminal.add_node_modules_bin_to_path.label=將 ''node_modules/.bin'' 從專案根目錄新增到 {0}
testing.select.in.test.tree.name=在測試樹中選擇 ''{0}''
testing.snapshot.update.all.tests.text=<link>點擊以更新所有失敗的快照</link>
testing.snapshot.update.single.test.text=<link>點擊以更新 ''{0}'' 的快照</link>
testing.snapshot.update.test.file.text=<link>點擊以更新 {0} 中所有失敗的快照</link>
text.cannot.download=無法下載 {0}。{1}
text.html.front.end.template.a.href.http.html5boilerplate.com=<html>前端模板<a href='http://html5boilerplate.com'>http://html5boilerplate.com</a></html>
text.html.sleek.intuitive.and.powerful.front.end.framework=<html>整潔、直觀、強大的前端框架，更快、更輕鬆地進行 Web 開發 <a href='http://getbootstrap.com'>http://getbootstrap.com</a></html>
titled.separator.predefined=預定義
top.level.package=頂層軟體套件
ts.add.import.all.family.name=新增所有 import
ts.add.import.hint.all.part=或全部使用 {0} 匯入
ts.add.import.hint.multiple.text=使用  {1} 為 {0} 新增匯入
ts.add.import.hint.text=使用 {1} 新增 {0}
ts.add.import.statement.dialog.title=新增 import 語句
ts.change.import.action.command=更改匯入
ts.change.import.action.dialog.title=匯入自…
ts.change.import.action.family.name=更改 ES6 匯入路徑
ts.change.import.action.many.title=更改匯入…
ts.change.import.action.one.title=更改為 {0}
ts.convert.alias.to.enum.action.family.name=將類型別名轉換為枚舉
ts.convert.alias.to.enum.action.title=將別名轉換為枚舉
ts.convert.alias.to.interface.action.family.name=將類型別名轉換為接口
ts.convert.alias.to.interface.action.title=將別名轉換為接口
ts.convert.field.to.parameter.property=將欄位轉換為參數屬性
ts.convert.parameter.property.to.field=將參數屬性轉換為欄位
ts.generate.reference.path.name=生成參照路徑註釋
ts.switch.to.jsx.inspection.name=更改檔案擴展名為 .tsx
ts.unresolved.variable.inspection.name=未解析的 TypeScript 參照
tsx.missing.name.quick.fix.name="新增 {0} import 語句
type.annotations=類型註解
type.is.not.resolved=類型 ''{0}'' 未解析。\\n是否繼續?
typescipt.import.options.paths.help=此選項用於組態 import 語句中使用的路徑樣式。<br><br>選擇“始終”時，IDE 會始終使用來自 tsconfig.json 組態的別名。<br><br>選擇“僅在指定路徑之外的檔案中”時，IDE 會針對為之定義了別名的檔案之間的匯入使用相對路徑。在所有其他檔案中使用路徑映射。<br><br>選擇“從不”時，則從不使用別名。
typescript.abstract.class.constructor.can.be.made.protected=抽象類別建構函式可以設為 protected
typescript.auto.import.options.add.imports=自動新增 TypeScript import
typescript.before.task.check.errors=檢查錯誤
typescript.before.task.config.dialog.title=選擇 tsconfig.json
typescript.before.task.config.path=組態檔案:
typescript.before.task.title=TypeScript 編譯設定
typescript.code.style.tab.name=TypeScript
typescript.compiler.action.compile.all=全部編譯
typescript.compiler.action.compile.all.compile.config=組態 {0} 的編譯檔案
typescript.compiler.action.compile.all.description=編譯所有專案檔案
typescript.compiler.action.compile.current=編譯當前檔案
typescript.compiler.action.compile.description=編譯當前專案
typescript.compiler.action.compile.simple=編譯 TypeScript
typescript.compiler.action.compile.toolbar=編譯
typescript.compiler.action.no.compile.message=檔案未編譯，因為沒有從主檔案參照
typescript.compiler.before.run=編譯 TypeScript
typescript.compiler.configurable.name=TypeScript
typescript.compiler.configurable.options.command.line=選項:
typescript.compiler.configurable.options.command.line.localeNotSupportedForBundled=捆綁的 TypeScript 不支持區域設定
typescript.compiler.configurable.options.compile.main=僅編譯主檔案:
typescript.compiler.configurable.options.compile.main.error=主檔案的路徑不正確
typescript.compiler.configurable.options.enable.no.config=也針對沒有 tsconfig.json 的專案
typescript.compiler.configurable.options.generate.source.map=生成源映射
typescript.compiler.configurable.options.output.path=使用輸出路徑:
typescript.compiler.configurable.options.scope=編譯作用域:
typescript.compiler.configurable.options.track.file.system=在更改時重新編譯
typescript.compiler.configurable.options.version=TypeScript:
typescript.compiler.configurable.options.version.bundled=已捆綁
typescript.compiler.notification.editor.configure=組態 TypeScript…
typescript.compiler.starting=TypeScript 正在啟動…
typescript.compiler.structure.tab.title=結構
typescript.config.inspection=不一致的 Tsconfig.json 屬性
typescript.config.inspection.checkjs.info=屬性 checkJs 需要 allowJs 屬性
typescript.config.inspection.config.options.fix=向 tsconfig.json 中新增 ''{0}''
typescript.config.inspection.fix.pattern=新增 ''{0}'' 屬性
typescript.config.inspection.libs=缺少全域類別庫
typescript.config.inspection.libs.fix=在 tsconfig.json 中啟用庫 ''{0}''
typescript.config.inspection.missing.option=缺少 tsconfig.json 選項 
typescript.duplicate.typescript.union.inspection.name=聯合或相交類型元件重複
typescript.enum.member.name=枚舉成員
typescript.enum.name=枚舉
typescript.explicit.member.type.inspection.name=顯式類型
typescript.export.assignment.cannot.be.used.in.internal.modules=匯出不能在內部模組中使用的指派
typescript.extract.type.alias.name=類型別名…
typescript.field.can.be.made.readonly=可以為唯讀欄位
typescript.file=TypeScript 檔案
typescript.fix.change.member.access=設為 ''{0}''
typescript.generics.should.not.be=類型 ''{0}'' 非泛型
typescript.import.options.exts.help=此選項用於組態 import 語句中的副檔名。<br><br>選擇“自動”時，IDE 會始終向 vue 檔案、來自在 tsconfig.json 中具有 "module": "node16" 或 "module": "nodenext" 和在 package.json 中具有 "type": "module" 的專案的檔案，以及擴展名為 .mts 的檔案的名稱新增副檔名。<br><br>選擇“始終”時，IDE 會始終向 TypeScript 檔名新增 .js 副檔名。<br><br>選擇“從不”時，IDE 會始終使用不帶副檔名的檔名。
typescript.import.options.paths=使用 tsconfig.json 的路徑映射:
typescript.import.options.use.config=使用相對於 tsconfig.json 的路徑
typescript.include.js.sources.action=包括 JavaScript 檔案
typescript.include.js.sources.dialog.message=是否在此專案中包含 ''{0}'' 中的 JavaScript 檔案?
typescript.include.js.sources.dialog.title=包括軟體套件 {0}
typescript.include.js.sources.element=搜尋 JavaScript 宣告
typescript.insert.cast.fix=插入類型斷言
typescript.insert.type.guard.fix.family=插入類型防護
typescript.insert.type.guard.nc=將限定符取代為 ''{0}''
typescript.insert.type.guard.nc.self=取代為 ''{0}''
typescript.insert.type.guard.postfix=使用 ''{0}'' 進行可選查詢
typescript.insert.type.guard.prefix=前綴為 ''{0}''
typescript.insert.type.guard.surround=封閉在 ''{0}''中
typescript.inspection.group.name=TypeScript
typescript.intention.convert.import.require=將 import require 轉換為 import from
typescript.intention.convert.import.require.text=轉換為 {0}
typescript.language.service.clean=正在重設快取…
typescript.language.service.compile.file=正在編譯檔案… {0}
typescript.language.service.compile.file.errors=正在計算錯誤… {0}
typescript.language.service.compile.project=正在編譯專案… {0}
typescript.language.service.compile.project.errors=正在計算專案錯誤… {0}
typescript.language.service.compile.project.open.file=正在開啟檔案… {0}
typescript.language.service.name=TypeScript 服務
typescript.language.simple.name=TypeScript
typescript.make.constructor.protected=將建構函式設為 protected
typescript.make.field.readonly=將欄位設為唯讀
typescript.missing.augmentation.import=缺少擴大匯入
typescript.module.name=模組名稱
typescript.narrowed.to=範圍限縮至 ''{0}''
typescript.primitive.types.name=基元類型
typescript.private.field.modifiers.mix=使用不公開名稱的欄位不能具有 'public'、'private' 或 'protected' 存取修飾符
typescript.redundant.declaration=類型宣告與推斷的類型相符合，因此可以移除
typescript.redundant.instanceof.guard=''instanceof'' 檢查冗餘: ''{0}'' 具有類型 ''{1}'' 或 ''{1}'' 的子類型
typescript.redundant.instanceof.inheritor.guard=''instanceof'' 檢查冗餘: ''{0}'' 具有類型 ''{1}'' 或 ''{1}'' 的繼承者
typescript.redundant.typescript.type.argument.inspection.name=冗餘類型實參
typescript.reference.to.umd.global=已參照的 UMD 全域變數
typescript.remove.type.declaration=移除類型宣告
typescript.rename.dynamic.references=搜尋動態參照 (&D)
typescript.rename.javascript.references=在 JavaScript 檔案中搜尋(&J)
typescript.service.action.restart=重啟{0}
typescript.service.no.config=檔案未包括在任何 tsconfig.json 中
typescript.service.no.main.reference=檔案未處理，因為沒有從主檔案參照
typescript.smart.cast=範圍限縮的類型
typescript.smart.cast.hyperlink=設定字體和背景
typescript.specify.all.param.types.explicitly=顯式指定所有參數類型
typescript.specify.all.param.types.explicitly.from.hint=向所有參數中新增顯式類型註解
typescript.specify.type.explicitly=顯式指定類型
typescript.specify.type.explicitly.from.hint=新增顯式類型註解
typescript.suspicious.constructor.parameter.assignment=建構函式中的參數指派可疑。您是否忘記了新增 'this.'?
typescript.suspicious.constructor.parameter.assignment.desc=已分配建構函式欄位參數
typescript.suspicious.instanceof.guard=''instanceof'' 檢查無效: ''{0}'' 的類型與 ''{1}'' 無關
typescript.type.alias.name=類型別名
typescript.type.guard.name=變數類型限縮為類型防護
typescript.type.guard.name.disable=停用範圍限縮的類型的著色
typescript.type.parameter=類型參數
typescript.type.predicate.destructuring=類型謂詞不能參照綁定模式中的元素。
typescript.type.predicate.incompatible.types=類型謂詞不可分配給 {0}
typescript.type.predicate.not.match.name=找不到參數 {0}
typescript.type.predicate.not.return=僅函式和方法的返回值類型位置允許類型謂詞
typescript.type.predicate.rest=類型謂詞不能參照 rest 參數
typescript.type.this.predicate.not.return=僅類別或接口成員、get 存取器或函式和方法的返回值類型位置允許基於 'this' 類型的謂詞。
typescript.types.intersection=相交
typescript.types.key=鍵參照
typescript.types.mapped=映射
typescript.types.merged=已合併
typescript.types.merged.accessor=合併存取器
typescript.types.merged.parts=參照的屬性:
typescript.types.module.not.installed.warning=無法解析模組 ''{0}'' 的定義
typescript.types.type.member={0} 類型屬性
typescript.types.union=聯合
typescript.use.service.configurable.options.enable=TypeScript 語言服務
typescript.validate.generic.types.fix.add=新增泛型實參
typescript.validate.generic.types.fix.delete=移除泛型實參
typescript.validate.generic.types.inspection.error.argument.number=泛型類型 ''{0}'' 需要 ''{1}'' 類型實參
typescript.validate.generic.types.inspection.error.argument.number.between=泛型類型 ''{0}'' 需要介於 {1} 和 {2} 之間的類型實參
typescript.validate.generic.types.inspection.error.not.empty.argument=類型實參列表不能為空
typescript.validate.generic.types.inspection.error.not.empty.parameter=類型參數列表不能為空
typescript.validate.generic.types.inspection.name=不正確的泛型實參
typescript.validate.optional.parameter.inspection.error=參數不能有問號和初始設定式
typescript.validate.optional.parameter.inspection.fix.question=移除問號
typescript.validate.template.literal.types=模板類型 {1} 不可分配給約束類型 {0}
typescript.validate.types.any.inspection.name='any' 類型的類型不符合
typescript.validation.async.incorrect.type.annotation=異步函式不能有 ''{0}'' 類型註解
typescript.validation.cannot.find.best.common.type=無法從用法推斷類型實參
typescript.validation.class.extend.constructor.return.not.class=基類別建構函式返回值類型 ''{0}'' 不是類別或接口類型。
typescript.validation.class.extend.cycled.definition=迴圈類別定義
typescript.validation.class.extend.many.constructors=基類別建構函式必須具有相同的返回值類型
typescript.validation.class.extend.no.type.arguments.type=沒有任何基類別建構函式具有指定數量的類型實參
typescript.validation.class.extend.not.constructor.type=類型 ''{0}'' 不是建構函式類型
typescript.validation.dissatisfies.type.annotation=類型 ''{0}'' 不滿足預期類型 ''{1}''
typescript.validation.expressionWithTypeArguments.compatibleSignatureNotFound=找不到相容的簽名
typescript.validation.generators.ambient=環境上下文中不允許使用產生器
typescript.validation.generators.async.no.yield=產生器隱式具有類型 'AsyncIterableIterator<any>'，因為它不產生任何值。請考慮提供返回值類型。
typescript.validation.generators.incorrect.type.annotation=發生器不能有 ''{0}'' 類型註解
typescript.validation.generators.incorrect.type.annotation.iterable=類型 ''{0}'' 不可分配給類型 ''{1}''。
typescript.validation.generators.no.yield=產生器隱式具有類型 'IterableIterator<any>'，因為它不產生任何值。請考慮提供返回值類型。
typescript.validation.generators.overload=多載簽名無法被宣告為產生器
typescript.validation.incorrect.rhs.in.private.brand=右側必須是一個物件，實際為: ''{0}''
typescript.validation.message.abstract.cannot.be.used=''{0}'' 修飾符不能與 ''abstract''修飾符一起使用
typescript.validation.message.abstract.cannot.have.body=方法不能具有實作，因為它被標記為 'abstract'
typescript.validation.message.abstract.class.be.created=無法建立抽象類別 ''{0}'' 的執行個體
typescript.validation.message.abstract.class.should.be=abstract 方法只能出現在抽象類別中
typescript.validation.message.abstract.member.access.super=無法通過 super 表達式存取 abstract 方法 ''{0}''。
typescript.validation.message.abstract.overload=多載簽名必須全部為 abstract 或非 abstract。
typescript.validation.message.constructor.cannot.be.abstract=建構函式不能為 'abstract'
typescript.validation.message.duplicate.modifier=已看到修飾符 {0}
typescript.validation.message.duplicate.modifier2=已看到可存取性修飾符
typescript.validation.message.function.implementation.missing=缺少函式實作或此宣告之後未緊隨函式實作
typescript.validation.message.getter.and.setter.must.have.same.access.type=Getter 和 setter 必須具有相同的存取類型
typescript.validation.message.invalid.modifier.cannot.be.here=修飾符 {0} 不能出現在此處
typescript.validation.message.invalid.module.member.modifier=''{0}'' 不是模組成員的有效修飾符
typescript.validation.message.misordered.in.modifier='in' 修飾符必須在 'out' 修飾符之前。
typescript.validation.message.unexpected.type.for.rest.parameter=Rest 參數必須為數組類型或具有陣列約束的泛型
typescript.validation.message.unexpected.type.for.rest.parameter.fix=取代為數組類型
typescript.validation.message.unique.symbol.mutable.non.static.field.declaration=類型為 'unique symbol' 類型的類別的屬性必須同時為 'static' 和 'readonly'
typescript.validation.message.unique.symbol.mutable.non.static.field.declaration.fix.add.static.readonly=新增 static 和 readonly 修飾符
typescript.validation.message.unique.symbol.mutable.property.signature=如果接口或類型文字的類型是 'unique symbol' 類型，則其屬性必須為 'readonly'
typescript.validation.message.unique.symbol.mutable.variable=類型為 'unique symbol' 類型的變數必須為 'const'
typescript.validation.message.unique.symbol.wrong.usage=此處不允許使用 'unique symbol' 類型
typescript.validation.module.reference.with.extension=外部模組參照不能以擴展結束
unnecessary.parentheses.display.name=不必要的圓括號
unnecessary.parentheses.problem.descriptor=<code>#ref</code> 周圍的圓括號不必要 #loc
unwrap.with.kind=解包 ''{0}…''
variables.and.fields=變數和欄位
variables.and.fields.description=變數和欄位
varible.name.column.title=名稱
varible.value.column.title=值
visibility.level.details=詳細資訊
visibility.level.overview=概覽
vitest.coverage.cannot.copy.lcov.info.notification.content=無法顯示 Vitest 覆蓋率: 無法複製檔案。
vitest.coverage.cannot.find.lcov.info.notification.content=無法顯示 Vitest 覆蓋率: 找不到 {0}。
vitest.coverage.directory.not.found.notification.content=無法從 Vitest 組態中讀取 coverageDirectory 選項
vitest.coverage.notification.title=Vitest 覆蓋率
vitest.coverage.presentable.text=Vitest 覆蓋率
vitest.rc.configurationFile.label=組態檔案(&C):
vitest.rc.configurationFile.title=選擇 Vitest 組態檔案
vitest.rc.vitestOptions.emptyText=CLI 選項，例如 --watch 或 --ui
vitest.rc.vitestOptions.label=Vitest 選項:
vitest.rc.vitestPackageField.label=Vitest 軟體套件(&V):
vitest.snapshot.update.rc.name=更新 {0} 的快照
web.bundler.analyzing.configs.progress=正在分析 Web 捆綁程序的組態檔案
web.bundler.cannot.analyze=無法分析 {0}: 編碼輔助將忽略此檔案中的模組解析規則。
web.bundler.error.details=錯誤詳細資訊: {0}
web.bundler.failed.to.load=無法載入 {0}
web.bundler.possible.reasons=可能的原因: 此檔案不是有效的組態檔案，或者 IDE 目前不支持其格式。
web.template.file-type.description={0} 模板
yarn.package_requires_yarn.dialog.message=軟體套件“{0}”要求 Yarn {1}。
yarn.pnp.library_name=來自 {0} 的相依項
yarn.pnp.requires.yarn.package_manager.dialog.message=Yarn PnP 需要 Yarn <a href="">軟體套件管理器</a>
{0}.visibility.will.break.methods.hierarchy=可見性為 {1} 的{0}無法參與層次結構"
`;

exports[`dev messages/PhpBundle.properties 1`] = `
"0=\\ ({0})
0.1={0}，{1}
0.1.choice.0.extends.1.implements.2={0}{1, choice, 0# 擴展 |1# 執行 }{2}
0.12={0}:{1}
0.and.1.define.the.same.property.2=''{0}'' 和 ''{1}'' 定義相同的屬性 ''{2}''
0.by.remote.interpreter=通過遠端解釋器{0}
0.completion.shortcut=使用{1}進行{0}補全
0.extends.1={0} 擴展 {1}
0.for.1.run.configuration={1} 執行組態的 {0}
0.inspection={0} 檢查
0.local={0}本地
0.location={0} 位置
0.path={0} 路徑:
0.pushing.members.down.will.result.in.them.being.deleted={0}\\n向下推送成員將導致它們被刪除
0.should.not.extend.itself={0} 不應自行擴展
0.with.same.name.already.defined.in.this.class=此類別中已經定義了具有相同名稱的{0}
02={0}::
03=({0})
04={0}:
12.hour.format.of.an.hour.with.leading.zeros=帶前導零的 12 小時格式小時(01 到 12)
12.hour.format.of.an.hour.without.leading.zeros=不帶前導零的 12 小時格式小時(1 到 12)
24.hour.format.of.an.hour.with.leading.zeros=帶前導零的 24 小時格式小時(00 到 23)
24.hour.format.of.an.hour.without.leading.zeros=不帶前導零的 24 小時格式小時(0 到 23)
>>>>>>>=e3e71918c4cd1 (WI-68349 新檢查=關於使用永不返回函式結果的警告)
DBGPProxyConfigurable.display.name=DBGp 代理
DBGPProxyConfigurable.host=主機:
DBGPProxyConfigurable.ide.key=IDE 鍵:
DBGPProxyConfigurable.port=連接埠:
PhpBuiltInWebServerRunConfigurationEditor.configuration.description=PHP 內建 Web 伺服器組態
PhpBuiltInWebServerRunConfigurationEditor.configuration.display.name=PHP 內建 Web 伺服器
PhpBuiltInWebServerRunConfigurationEditor.document.root=文檔根:
PhpBuiltInWebServerRunConfigurationEditor.host=主機:
PhpBuiltInWebServerRunConfigurationEditor.port=連接埠:
PhpBuiltInWebServerRunConfigurationEditor.title=伺服器組態
PhpBuiltInWebServerRunConfigurationEditor.use.router.script=使用 router 腳本:
PhpCommandLineConfigurationEditor.command.line=命令行
PhpCommandLineConfigurationEditor.field.custom.working.directory=自訂工作目錄:
PhpCommandLineConfigurationEditor.field.environment.variables=環境變數:
PhpCommandLineConfigurationEditor.field.interpreter.options=解釋器選項:
PhpCommandLineConfigurationEditor.interpreter.options.editor.dialog.caption=解釋器選項
PhpDebugBreakAtFirstLineToggleAction.text=在 PHP 腳本中的第一行中斷
PhpDebugConfigurable.advanced.settings=進階設定
PhpDebugConfigurable.break.at.first.line=在 PHP 腳本中的第一行中斷
PhpDebugConfigurable.detect.path.mappings.from.deployment=檢測部署組態的路徑映射
PhpDebugConfigurable.evaluation=評估
PhpDebugConfigurable.external.connections=外部連線
PhpDebugConfigurable.ignore.external.connections.through.unregistered.server.configurations.label=通過未註冊的伺服器組態忽略外部連線
PhpDebugConfigurable.import.use.statements=從求值上下文匯入命名空間和 'use' 語句
PhpDebugConfigurable.notify.resolved.breakpoint=通知是否將中斷點解析為另一行(Xdebug 2.8+)
PhpDebugConfigurable.notify.session.stopped.without.pause=在偵錯會話完成而不暫停時通知
PhpDebugConfigurable.pass.required.configuration.options=通過命令行傳遞所需組態選項(仍需要手動啟用偵錯擴展)
PhpDebugConfigurable.remote.debug.listen.for.connections=3. 啟動“PHP 遠端偵錯”執行組態。
PhpDebugConfigurable.safe.evaluation.mode=值提示和監視框架下的安全求值模式
PhpDebugConfigurable.show.array.children.in.repl=在偵錯主控台中顯示陣列和物件子級
PhpDebugConfigurable.web.page.listen.for.connections=2. 啟動“PHP 網頁”執行組態。
PhpDebugConfigurable.web.page.pre.config.title=偵錯預組態
PhpDebugConfigurable.xdebug=Xdebug
PhpDebugConfigurable.xdebug.debug.port=Xdebug 偵錯連接埠
PhpDebugConfigurable.xdebug.force.break.no.path.mapping=未指定路徑映射時，在第一行強制中斷
PhpDebugConfigurable.xdebug.force.break.when.outside.project=當腳本在專案外部時，在第一行強制中斷
PhpDebugConfigurable.xdebug.resolve.breakpoints=如果中斷點在當前行不可用，則解析中斷點(Xdebug 2.8+)
PhpDebugConfigurable.zend.debug.port=Zend Debugger 偵錯連接埠
PhpDebugConfigurable.zend.debugger=Zend 偵錯器
PhpDebugConfigurable.zend.settings.broadcasting.port=Zend Debugger 設定廣播連接埠
PhpDebugConfigurable.zend.settings.ide.hosts=Zend Debugger IDE 主機
PhpDebugConfigurable.zend.settings.ide.hosts.detect=正在檢測…
PhpDebugConfigurable.zend.settings.ide.hosts.detect.progress=正在檢測 Zend Debugger 的 IP…
PhpDebugConfigurable.zero.configuration=預組態
PhpDebugConfigurable.zero.configuration.install.debugger.php.instruction=1. 安裝
PhpDebugConfigurable.zero.configuration.install.php.instruction=或
PhpDebugConfigurable.zero.configuration.install.php.validate=Web 伺服器上的偵錯器組態。
PhpDebugConfigurable.zero.configuration.install.php.validate.action=驗證
PhpDebugConfigurable.zero.configuration.install.toolbar.instruction=瀏覽器工具列或小書籤。
PhpDebugConfigurable.zero.configuration.install.toolbar.instruction.label=2. 安裝
PhpDebugConfigurable.zero.configuration.install.xdebug.php.instruction=Xdebug
PhpDebugConfigurable.zero.configuration.install.zend.debugger.php.action=Zend 偵錯器
PhpDebugConfigurable.zero.configuration.install.zend.debugger.php.instruction=在 Web 伺服器上。
PhpDebugConfigurable.zero.configuration.listen.for.connections=3. 啟用 PHP 偵錯連線偵聽:
PhpDebugConfigurable.zero.configuration.listen.for.connections.action=開始偵聽
PhpDebugConfigurable.zero.configuration.start.session=4. 使用工具列或小書籤在瀏覽器中啟動偵錯會話。
PhpDebugConfigurable.zero.configuration.stop.listen.for.connections.action=停止偵聽
PhpDebugConfigurable.zero.configuration.tutorial=有關更多資訊，請參見
PhpDebugConfigurable.zero.configuration.tutorial.action=“零組態偵錯”教程
PhpDebugHideEmptySuperGlobalsToggleAction.text=顯示空的超全域變數
PhpDebugSkippedPathsConfigurable.column.title=跳過的路徑
PhpDebugSkippedPathsConfigurable.display.name=跳過的路徑
PhpDebugSkippedPathsConfigurable.notify.about.skipped.files=通知跳過的檔案
PhpExtractMethodDialog.declare.static=宣告 static(&S)
PhpExtractMethodDialog.duplicates.count=檢查並取代重複項(找到 {0} 個)
PhpExtractMethodDialog.duplicates.pending=正在搜尋重複項…
PhpExtractMethodDialog.extract.function=提取函式
PhpExtractMethodDialog.extract.method=提取方法
PhpExtractMethodDialog.function=函式:
PhpExtractMethodDialog.generate.php.doc=生成 PhpDoc(&G)
PhpExtractMethodDialog.generate.php.doc.inplace=生成 PHPDoc
PhpExtractMethodDialog.method=方法:
PhpExtractMethodDialog.name=名稱(&A):
PhpExtractMethodDialog.output.variables=輸出變數
PhpExtractMethodDialog.parameters=參數
PhpExtractMethodDialog.private=private(&V)
PhpExtractMethodDialog.protected=protected(&T)
PhpExtractMethodDialog.public=public(&B)
PhpExtractMethodDialog.replace.tail.break.continue.with.return=將尾“break/continue”語句取代為“return”語句(&T)
PhpExtractMethodDialog.return.output.through=通過以下方式返回輸出變數:
PhpExtractMethodDialog.return.output.through.ref.parameters=通過參照傳遞的參數(&P)
PhpExtractMethodDialog.return.output.through.return=return 語句(&E)
PhpExtractMethodDialog.signature.preview=簽名預覽
PhpExtractMethodDialog.transformation.options=轉換選項
PhpExtractMethodDialog.visibility=可見性:
PhpFrameworksCommonConfigurable.display.name=框架
PhpHttpRequestRunConfiguration.configuration.description=HTTP 請求組態
PhpHttpRequestRunConfiguration.configuration.display.name=PHP HTTP 請求
PhpHttpRequestRunConfiguration.error.fetch.result=響應正文不可用
PhpHttpRequestRunConfiguration.error.host.is.not.specified=伺服器 ''{0}'' 的主機未指定或無效
PhpHttpRequestRunConfiguration.error.server.configuration=無法執行 HTTP 請求: ''{0}''。請在“PHP|伺服器”下檢查伺服器組態。
PhpHttpRequestRunConfiguration.error.server.is.not.specified=找不到名稱為 ''{0}'' 的遠端伺服器
PhpHttpRequestRunConfiguration.error.url.is.not.specified=URL 未指定或無效: ''{0}''。
PhpIncomingConnectionDialog.file.path.on.server=伺服器上的檔案路徑:
PhpIncomingConnectionDialog.request.uri=請求 URI:
PhpIncomingConnectionDialog.server.name=伺服器名稱:
PhpIncomingConnectionDialog.server.port=伺服器連接埠:
PhpIncomingLocalConnectionDialog.file.path=檔案路徑:
PhpInterpreter.configuration.duplicate.interpreter.name=找到了具有非唯一名稱 ''{0}'' 的 PHP 解釋器。
PhpInterpreter.configuration.in.project.settings.message=無法將 PHP 解釋器指定為預設 SDK。您可以在“設定| PHP”中為當前專案組態
PhpInterpreter.configuration.in.project.settings.title=PHP 解釋器組態
PhpInterpreter.configuration.interpreter.is.invalid=啟用“PHP Remote Interpreters”延伸模組以編輯解釋器。
PhpInterpreter.configuration.selection.list.title=選擇 CLI 解釋器
PhpInterpreter.php.debugger.label=偵錯器:
PhpInterpreter.php.dependent.configuration.exists=所選 PHP 解釋器有{0}組態。確定要刪除此解釋器嗎?
PhpInterpreter.php.dependent.configuration.exists.title=PHP 解釋器相依組態
PhpInterpreter.php.general.title=一般
PhpInterpreter.php.home.path.label=PHP 可執行檔案:
PhpInterpreter.php.interpreter.name.conflict=發現專案級和應用程式級解釋程序名稱存在衝突。為解決該問題，以下專案級解釋器被重新命名:
PhpInterpreter.php.interpreter.name.conflict.title=解釋器名稱衝突
PhpInterpreter.php.sdk.type=PHP 解釋器
PhpInterpreterConfigurable.can.not.updated.phpinfo=無法更新 phpinfo
PhpInterpreterConfigurable.configuration.default.project.tooltip=無法僅為預設專案儲存解釋器。
PhpInterpreterConfigurable.configuration.file.can.not.find=無法通過路徑找到檔案: ''{0}''
PhpInterpreterConfigurable.configuration.file.can.not.find.title=找不到組態檔案
PhpInterpreterConfigurable.configuration.file.evaluate.dir=正在評估組態檔案目錄…
PhpInterpreterConfigurable.configuration.file.fix=在 {0} 目錄中建立 php.ini 檔案，<br><br>組態檔案模板可在 php 根目錄中找到:<br>“php.ini-development”- 預設設定<br>“php.ini-production”- 推薦設定。<br>
PhpInterpreterConfigurable.configuration.file.fix.failed.to.detect=使用“{0} --ini”指令確定組態檔案目錄。<br>
PhpInterpreterConfigurable.configuration.file.fix.link=<br>點擊此<a href="http://php.net/manual/en/configuration.file.php">連結</a>獲取更多資訊。
PhpInterpreterConfigurable.configuration.file.fix.title=組態 php.ini 檔案不存在
PhpInterpreterConfigurable.configuration.file.hhvm.fix=在 <b>/etc/hhvm</b> 目錄中建立 php.ini 檔案，<br><br>點擊此<a href="http://docs.hhvm.com/manual/en/configuration.file.php">>連結</a>獲取更多資訊。
PhpInterpreterConfigurable.configuration.file.path=組態檔案: {0}
PhpInterpreterConfigurable.configuration.file.path.not.found=組態 php.ini 檔案不存在
PhpInterpreterConfigurable.configuration.options.description=這些選項將使用 '-d' 命令行選項傳遞
PhpInterpreterConfigurable.configuration.options.dialog.caption=組態選項
PhpInterpreterConfigurable.configuration.options.label=組態選項:
PhpInterpreterConfigurable.configuration.options.table.empty.text=為 php.ini 中允許的任何組態指令設定自訂值
PhpInterpreterConfigurable.configuration.options.table.name=組態指令
PhpInterpreterConfigurable.configuration.options.table.value=值
PhpInterpreterConfigurable.configuration.options.with.empty.name.are.not.allowed=不允許名稱為空的組態選項
PhpInterpreterConfigurable.configuration.project.level=僅對此專案可見
PhpInterpreterConfigurable.configuration.project.tooltip=檢查是否不想在專案之間共享解釋器
PhpInterpreterConfigurable.configuration.title=其他
PhpInterpreterConfigurable.debugger.extension.description=將僅為從 CLI 執行組態啟動的偵錯會話載入偵錯器擴展
PhpInterpreterConfigurable.debugger.extension.label=偵錯器擴展:
PhpInterpreterConfigurable.debugger.extension.title=選擇偵錯器擴展路徑
PhpInterpreterConfigurable.generate.xdebug.extension=生成安裝腳本
PhpInterpreterConfigurable.install.xdebug.extension=下載並安裝 Xdebug 擴展
PhpInterpreterConfigurable.not.installed=未安裝
PhpInterpreterConfigurable.php.ini.title=選擇組態檔案或目錄
PhpInterpreterConfigurable.php.version=PHP 版本: {0}
PhpInterpreterConfigurable.reload.phpinfo=重新載入 phpinfo
PhpInterpreterConfigurable.show.phpinfo=顯示 phpinfo
PhpInterpreterConfigurable.update.helpers.title=正在更新幫助程序目錄…
PhpInterpreterConfigurable.updated.phpinfo=已成功更新 phpinfo
PhpLanguageFeature.abstract.function.override=從 PHP 7.2 起才允許抽象函式覆寫
PhpLanguageFeature.abstract.private.trait.methods=從 PHP 8.0 起才允許使用 abstract private 特徵方法
PhpLanguageFeature.anonymous.classes=從 PHP 7.0 起才允許使用匿名類別
PhpLanguageFeature.argument.unpacking=從 PHP 5.6 起才允許使用實參解包
PhpLanguageFeature.array.dereferencing.not.supported=從 PHP 5.4 起才允許對調用進行陣列解參照
PhpLanguageFeature.arrow.function=從 PHP 7.4 起才允許箭頭函式語法
PhpLanguageFeature.attributes=從 PHP 8.0 起才允許使用特性
PhpLanguageFeature.binary.literal.not.supported=從 PHP 5.4 起才允許使用二進制文字
PhpLanguageFeature.built.in.web.server=內建 Web 伺服器僅自 PHP 5.4 起可用
PhpLanguageFeature.call.time.pass.by.reference.not.supported=調用時通過參照傳遞在 PHP 5.4 中已被移除
PhpLanguageFeature.catch.multiple=從 PHP 7.1 起才允許捕獲多條語句
PhpLanguageFeature.class.constant.visibility=從 PHP 7.1 起才允許類別常數可見性
PhpLanguageFeature.class.member.access.on.instantiation.not.supported=從 PHP 5.4 起才允許對實例化進行類別成員存取
PhpLanguageFeature.class.name.const.not.supported=從 PHP 5.5 起才允許使用類別名常數
PhpLanguageFeature.class.name.literal.on.object=從 PHP 8.0 起才允許在物件上使用 '::class'
PhpLanguageFeature.coalesce.assign=從 PHP 7.4 起才允許使用 '??='
PhpLanguageFeature.coalesce.operator=從 PHP 7.0 起才允許使用合併運算符
PhpLanguageFeature.constant.scalar.expressions=從 PHP 5.6 起才允許使用常數標量表達式
PhpLanguageFeature.constants.in.traits=從 PHP 8.2 起才允許在特徵中使用常數
PhpLanguageFeature.empty.any.expression.not.supported=從 PHP 5.5 起才允許在 'empty' 中使用任意表達式
PhpLanguageFeature.enum.classes=從 PHP 8.1 起才允許使用枚舉
PhpLanguageFeature.exception.throw.from.toString=從 PHP 7.4 起才允許從 ''__toString'' 拋出異常，''{0}.__toString'' 可能會拋出異常
PhpLanguageFeature.explicit.octal.literal=自 PHP 8.1 起只允許顯式八進制文字
PhpLanguageFeature.exponentiation=從 PHP 5.6 起才允許使用求冪
PhpLanguageFeature.final.class.constants=自 PHP 8.1 起只允許使用 'final' 類別常數
PhpLanguageFeature.finally.not.supported=從 PHP 5.5 起才允許使用 'Finally' 子句
PhpLanguageFeature.first.class.callable.syntax=從 PHP 8.1 起才允許一級可調用語法
PhpLanguageFeature.flexible.heredocs=靈活的 heredoc/nowdoc 語法
PhpLanguageFeature.foreach.list.not.supported=從 PHP 5.5 起才允許在 foreach 中使用列表
PhpLanguageFeature.generators.not.supported=從 PHP 5.5 起才允許使用產生器
PhpLanguageFeature.grouped.use=從 PHP 7.0 起才允許分組 use 宣告
PhpLanguageFeature.immediate.dereferencing.not.supported=從 PHP 5.5 起才允許直接解參照
PhpLanguageFeature.intersection.and.union.in.same.type=從 PHP 8.2 起才允許使用混合交叉類型與聯合類型
PhpLanguageFeature.intersection.types=從 PHP 8.1 起才允許交叉類型
PhpLanguageFeature.iterable.type.hint=從 PHP 7.1 起才允許迭代類型提示
PhpLanguageFeature.keyword.names=在 PHP 7.0 中關鍵字可用作名稱
PhpLanguageFeature.list.assign=從 PHP 7.1 起才允許列表解包中的 []
PhpLanguageFeature.list.keys=從 PHP 7.1 起才允許列表解包中的密鑰
PhpLanguageFeature.literal.in.instanceof=從 PHP 7.3 起才允許將文字作為第一個動作數
PhpLanguageFeature.literal.in.static.call.not.supported=從 PHP 5.4 起才允許在 static 呼叫中使用文字
PhpLanguageFeature.match.expression=從 PHP 8.0 起才允許符合表達式
PhpLanguageFeature.mixed.type.hint=從 PHP 8.0 起才允許 'mixed' 類型提示
PhpLanguageFeature.named.arguments=從 PHP 8.0 起才允許使用命名實參
PhpLanguageFeature.namespaced.name.as.single.token=從 PHP 8.0 起才允許關鍵字作為命名空間的一部分
PhpLanguageFeature.negative.numeric.indices=從 PHP 7.1 起才允許負數值索引
PhpLanguageFeature.new.in.init=從 PHP 8.1 起才允許在初始設定式中使用 'new'
PhpLanguageFeature.non.capturing.catches=從 PHP 8.0 起才允許捕捉異常而又不將異常捕獲到變數中
PhpLanguageFeature.nullables=從 PHP 7.1 起才允許可為 null
PhpLanguageFeature.nullsafe.dereferencing=從 PHP 8.0 起才允許 Nullsafe 運算符
PhpLanguageFeature.numeric.literals.separators=從 PHP 7.4 起才允許使用數值文字分隔符
PhpLanguageFeature.object.type.hint=從 PHP 7.2 起才允許物件類型提示
PhpLanguageFeature.parent.in.closure.not.supported=從 PHP 5.4 起才允許在閉包中使用 parent
PhpLanguageFeature.property.promotion=從 PHP 8.0 起才允許建構函式屬性提升
PhpLanguageFeature.readonly.classes=從 PHP 8.2 起才允許使用 'readonly' 類別
PhpLanguageFeature.readonly.properties=從 PHP 8.1 起才允許使用 'readonly' 屬性
PhpLanguageFeature.references.in.list=從 PHP 7.3 起才允許在 [] 和 list() 指派中使用參照
PhpLanguageFeature.return.never=自 PHP 8.1 起才允許使用返回值類型 'never'
PhpLanguageFeature.return.types=從 PHP 7.0 起才允許使用返回值類型宣告
PhpLanguageFeature.return.void=從 PHP 7.1 起才允許使用返回值類型 'void'
PhpLanguageFeature.scalar.type.hints=從 PHP 7.0 起才允許使用標量類型提示
PhpLanguageFeature.self.in.closure.not.supported=從 PHP 5.4 起才允許在閉包中使用 self
PhpLanguageFeature.short.array.syntax.not.supported=從 PHP 5.4 起才允許使用短陣列語法
PhpLanguageFeature.spaceship.operator=從 PHP 7.0 起才允許使用宇宙飛船運算符
PhpLanguageFeature.spread.operator.in.array=從 PHP 7.4 起才允許在陣列中使用展開運算符
PhpLanguageFeature.standalone.null.false=從 PHP 8.2 起才允許將 'null' 和 'false' 用作獨立類型
PhpLanguageFeature.static.in.closure.not.supported=從 PHP 5.4 起才允許在閉包中使用 static
PhpLanguageFeature.static.type.hint=從 PHP 8.0 起才允許 'static' 返回值類型宣告
PhpLanguageFeature.this.in.closure.not.supported=從 PHP 5.4 起才允許在閉包中使用 $this
PhpLanguageFeature.throw.expression=從 PHP 8.0 起才允許使用 throw 表達式
PhpLanguageFeature.trailing.comma.in.closure.use.list=只有 PHP 8.0 支援在閉包 use 列表中使用尾隨逗號
PhpLanguageFeature.trailing.comma.in.function.calls=從 PHP 7.3 起才允許在函式呼叫中使用尾隨逗號
PhpLanguageFeature.trailing.comma.in.group.uses=從 PHP 7.2 起才允許在組使用列表中使用尾隨逗號
PhpLanguageFeature.trailing.comma.in.parameter.list=從 PHP 8.0 起才允許在參數列表中使用尾隨逗號
PhpLanguageFeature.traits.not.supported=從 PHP 5.4 起才允許使用特徵
PhpLanguageFeature.true.type=從 PHP 8.2 起才允許使用名為 'true' 的類型提示
PhpLanguageFeature.typed.properties=從 PHP 7.4 起才允許使用類型化屬性
PhpLanguageFeature.uniform.variable.syntax=從 PHP 7.0 起才允許統一變數語法
PhpLanguageFeature.union.types=從 PHP 8.0 起才允許聯合類型
PhpLanguageFeature.use.function.and.const=從 PHP 5.6 起才允許 use function 和 use const
PhpLanguageFeature.var.break.argument.not.supported=PHP 5.4 不再支援具有非常數動作數的 'break' 運算符
PhpLanguageFeature.var.break.zero.argument.not.supported=自 PHP 5.4 起，'break' 運算符僅接受正數
PhpLanguageFeature.var.continue.not.supported=PHP 5.4 不再支援具有非常數動作數的 'continue' 運算符
PhpLanguageFeature.var.continue.zero.not.supported=自 PHP 5.4 起，'continue' 運算符僅接受正數
PhpLanguageFeature.variadic.functions=從 PHP 5.6 起才允許使用可變函式
PhpLanguageLevel.5.3.0.presentable.name=5.3
PhpLanguageLevel.5.3.0.short.description=命名空間，閉包
PhpLanguageLevel.5.4.0.presentable.name=5.4
PhpLanguageLevel.5.4.0.short.description=特徵，短陣列語法
PhpLanguageLevel.5.5.0.presentable.name=5.5
PhpLanguageLevel.5.5.0.short.description=finally，生成器
PhpLanguageLevel.5.6.0.presentable.name=5.6
PhpLanguageLevel.5.6.0.short.description=可變函式，實參解包
PhpLanguageLevel.7.0.0.presentable.name=7.0
PhpLanguageLevel.7.0.0.short.description=返回值類型，標量類型提示
PhpLanguageLevel.7.1.0.presentable.name=7.1
PhpLanguageLevel.7.1.0.short.description=常數可見性，可為 null，多個異常
PhpLanguageLevel.7.2.0.presentable.name=7.2
PhpLanguageLevel.7.2.0.short.description=物件類型提示，abstract 函式覆寫
PhpLanguageLevel.7.3.0.presentable.name=7.3
PhpLanguageLevel.7.3.0.short.description=列表指派中的參照，靈活的 heredoc
PhpLanguageLevel.7.4.0.presentable.name=7.4
PhpLanguageLevel.7.4.0.short.description=類型屬性，短閉包，null 合併運算符
PhpLanguageLevel.8.0.0.presentable.name=8.0
PhpLanguageLevel.8.0.0.short.description=聯合類型，命名實參，特性，match 表達式
PhpLanguageLevel.8.1.0.presentable.name=8.1
PhpLanguageLevel.8.1.0.short.description=枚舉、'never' 返回值類型、交叉類型、'readonly' 屬性
PhpLanguageLevel.8.2.0.presentable.name=8.2
PhpLanguageLevel.8.2.0.short.description='readonly' 類別，'true' 類型，獨立的 'null' 和 'false'
PhpPathMappingsConfigurable.use.path.mappings.label=使用路徑映射(選擇伺服器是遠端伺服器還是使用符號連結)
PhpProjectConfigurable.0.interpreter.include.path=''{0}'' 解釋器 include 路徑
PhpProjectConfigurable.advanced.settings=進階設定(&V)
PhpProjectConfigurable.all=所有
PhpProjectConfigurable.analysis=分析
PhpProjectConfigurable.analysis.custom.format.functions=自訂格式函式
PhpProjectConfigurable.default.stubs.path=預設存根路徑(&D):
PhpProjectConfigurable.docker.default.project.error.tooltip=開啟或建立專案以組態 Docker 容器
PhpProjectConfigurable.exception.analysis=異常分析
PhpProjectConfigurable.exception.analysis.depth=呼叫樹分析路徑:
PhpProjectConfigurable.exception.analysis.unchecked.exceptions=未檢查的異常:
PhpProjectConfigurable.include.analysis=Include 分析
PhpProjectConfigurable.include.path=Include 路徑
PhpProjectConfigurable.interpreter=CLI 解釋器:
PhpProjectConfigurable.language.level=PHP 語言級別(&P):
PhpProjectConfigurable.php.runtime=PHP 執行時
PhpProjectConfigurable.provide.include.path=提供 include 路徑
PhpProjectConfigurable.select.default.stubs.path.description=選擇預設存根路徑
PhpProjectConfigurable.select.default.stubs.path.title=選擇預設存根路徑
PhpProjectConfigurable.select.document.root.path.description=選擇 $_SERVER['DOCUMENT_ROOT'] 路徑
PhpProjectConfigurable.select.document.root.path.title=選擇 $_SERVER['DOCUMENT_ROOT'] 路徑
PhpProjectConfigurable.specify.other=指定其他…
PhpRemoteDebugRunConfigurationEditor.auto.config=通過 IDE 鍵篩選偵錯連線
PhpRemoteDebugRunConfigurationEditor.configuration.description=PHP 偵錯組態
PhpRemoteDebugRunConfigurationEditor.configuration.display.name=PHP 遠端偵錯
PhpRemoteDebugRunConfigurationEditor.filter.connections.help=適用於複雜伺服器設定，例如同一主機連接埠上有多個應用程式。<p/>保持未選中狀態以自動檢測組態，或使用<i>“偵聽偵錯連線”</i>動作。
PhpRemoteDebugRunConfigurationEditor.filter.connections.help.link=閱讀更多資訊
PhpRemoteDebugRunConfigurationEditor.filter.connections.help.title=進階選項
PhpRemoteDebugRunConfigurationEditor.server.label=伺服器(&E):
PhpRemoteDebugRunConfigurationEditor.session.id.cannot.be.empty=IDE 鍵(會話 ID)不能為空
PhpRemoteDebugRunConfigurationEditor.session.id.label=IDE 鍵(會話 ID)(&K):
PhpRemoteDebugRunConfigurationEditor.stop.zero.configuration=PhpStorm 已停止偵聽傳入偵錯連線。
PhpRemoteDebugRunConfigurationEditor.stop.zero.configuration.title=已停止偵聽傳入 PHP 偵錯連線
PhpRemoteDebugRunConfigurationEditor.zero.configuration.is.already.used=“偵聽傳入偵錯連線”已啟用，不會發生任何變化。<br/>檢視<a href="zero_config">零組態偵錯</a>獲取更多資訊。<br/><br/>要停止偵聽偵錯連線，請使用<a href="stop">執行|停止偵聽 PHP 偵錯連線</a>。
PhpRemoteDebugRunConfigurationEditor.zero.configuration.used=沒有為 <i>''{0}''</i> 執行組態指定<i>伺服器</i>，因此 PhpStorm 將偵聽所有傳入偵錯連線。<br/>檢視<a href="zero_config">零組態偵錯</a>獲取更多資訊。<br/><br/>要停止偵聽偵錯連線，請使用<a href="stop">執行|停止偵聽 PHP 偵錯連線</a>。
PhpRemoteDebugRunConfigurationEditor.zero.configuration.used.title=已開始偵聽傳入 PHP 偵錯連線
PhpScripRunConfigurationEditor.arguments=實參:
PhpScripRunConfigurationEditor.arguments.caption=實參
PhpScripRunConfigurationEditor.configuration.description=PHP 腳本組態
PhpScripRunConfigurationEditor.configuration.display.name=PHP 腳本
PhpScripRunConfigurationEditor.file=檔案:
PhpServerConfigurable.debugger.label=偵錯器(&D)
PhpServerConfigurable.host=主機
PhpServerConfigurable.host.label=主機(&H):
PhpServerConfigurable.port=連接埠
PhpServerConfigurable.port.label=連接埠(&P)
PhpServerConfigurable.shared=共享(&S)
PhpStepFilters.log.frame=框架已被跳過。函式名稱: {0}。遠端檔案 URL: {1}
PhpStepFiltersConfigurable.add.method=新增方法
PhpStepFiltersConfigurable.display.name=步進篩選器
PhpStepFiltersConfigurable.skip.constructors=跳過建構函式
PhpStepFiltersConfigurable.skip.magic.methods=跳過魔術方法
PhpStepFiltersConfigurable.skipped.files=跳過的檔案
PhpStepFiltersConfigurable.skipped.methods=跳過的方法
PhpStepFiltersConfigurable.specify.method.name=指定方法名稱
PhpStepFiltersConfigurable.title.files=檔案
PhpStepFiltersConfigurable.title.methods=方法
PhpUnitConfigurableForm.can.not.find.custom.loader=在 ''{0}'' 下找不到自動載入器腳本
PhpUnitConfigurableForm.can.not.find.paratest=在 ''{0}'' 下找不到 ParaTest
PhpUnitConfigurableForm.can.not.find.phpunit.phar=在 ''{0}'' 下找不到 phpunit.phar
PhpUnitConfigurableForm.custom.loader.is.directory=自動載入器不應為目錄，對於預設 Composer 組態，將路徑設定為“vendor/autoload.php”
PhpUnitConfigurableForm.custom.loader.is.empty=自動載入器檔案的路徑為空
PhpUnitConfigurableForm.default.paratest.binary=預設 ParaTest 二進制檔案:
PhpUnitConfigurableForm.download.phpunit.phar.link.text=從 {0} 下載 phpunit.phar
PhpUnitConfigurableForm.paratest.path=預設 ParaTest 二進制檔案
PhpUnitConfigurableForm.path.to.phpunit.phar=phpunit.phar 路徑
PhpUnitConfigurableForm.path.to.script=腳本路徑:
PhpUnitConfigurableForm.phpunit.library=PHPUnit 庫
PhpUnitConfigurableForm.phpunit.paratest.is.empty=ParaTest 的路徑為空
PhpUnitConfigurableForm.phpunit.phar.is.empty=phpunit.phar 路徑為空
PhpUnitConfigurableForm.specified.wrong.paratest.binary=指定了錯誤的 ParaTest 二進制檔案，請改用 'paratest_for_phpstorm'
PhpUnitConfigurableForm.test.runner=測試執行程序
PhpUnitConfigurableForm.unsupported.paratest.version=<html>安裝的 ParaTest 版本不支持與 PHPStorm 整合。<br>請將 ParaTest 更新到 6.5.0 或更高版本。</html>
PhpUnitConfigurableForm.use.bootstrap.file=預設啟動檔案:
PhpUnitConfigurableForm.use.bootstrap.file.validation.warning=為 ''{0}'' 提供啟動檔案的路徑，或停用“預設啟動檔案”選項
PhpUnitConfigurableForm.use.configuration.file=預設組態檔案:
PhpUnitConfigurableForm.use.configuration.file.validation.warning=為 ''{0}'' 提供組態檔案的路徑，或停用“預設組態檔案”選項
PhpUnitConfigurableForm.use.custom.loader=使用 Composer 自動載入器
PhpUnitConfigurableForm.use.paratest=使用 ParaTest:
PhpUnitConfiguration.interpreter.conflict=發現應用程式級 PHPUnit 組態衝突。為解決該問題，建立了以下組態的專案級副本:
PhpUnitConfiguration.interpreter.conflict.title=PHPUnit 組態衝突
PhpUnitTestRunnerConfigurationEditor.dialog.caption.test.runner.options=測試執行程序選項
PhpUnitTestRunnerConfigurationEditor.field.class=類別:
PhpUnitTestRunnerConfigurationEditor.field.directory=目錄:
PhpUnitTestRunnerConfigurationEditor.field.file=檔案:
PhpUnitTestRunnerConfigurationEditor.field.method=方法:
PhpUnitTestRunnerConfigurationEditor.field.test.runner.coverage.engine=首選覆蓋率引擎:
PhpUnitTestRunnerConfigurationEditor.field.test.runner.options=測試執行程序選項(&O):
PhpUnitTestRunnerConfigurationEditor.scope=測試作用域:
PhpUnitTestRunnerConfigurationEditor.scope.class=類別
PhpUnitTestRunnerConfigurationEditor.scope.directory=目錄
PhpUnitTestRunnerConfigurationEditor.scope.method=方法
PhpUnitTestRunnerConfigurationEditor.scope.xml=在組態檔案中定義
PhpUnitTestRunnerConfigurationEditor.test.runner=測試執行程序
PhpUnitTestRunnerConfigurationEditor.use.alt.bootstrap.file=使用替代啟動檔案(&U):
PhpUnitTestRunnerConfigurationEditor.use.alt.configuration.file=使用替代組態檔案(&U):
PhpUserDefinedConstantsGroup.name=常數
PhpWebAppRunConfigurationEditor.browser=瀏覽器(&B):
PhpWebAppRunConfigurationEditor.configuration.description=PHP 網頁組態
PhpWebAppRunConfigurationEditor.configuration.display.name=PHP 網頁
PhpWebAppRunConfigurationEditor.malformed.start.url=起始 URL 的格式錯誤 - {0}
PhpWebAppRunConfigurationEditor.startUrl=起始 URL(&U):
RunConfigurationEditor.configuration=組態
RunConfigurationEditor.error.server.is.not.exist=名稱為 ''{0}'' 的伺服器不存在
RunConfigurationEditor.error.server.is.not.selected=未選擇伺服器
RunConfigurationEditor.server=伺服器(&S):
XdebugAddMethodToSkipListToggleAction.text=將方法新增到跳過列表
XdebugCloudConfigurable.base.host=Cloud 主機:
XdebugCloudConfigurable.cloud.id=Cloud ID:
XdebugCloudConfigurable.connect.via.xdebug.cloud=連線到 Xdebug Cloud
XdebugCloudConfigurable.custom.server=連線到預置 Xdebug Cloud
XdebugCloudConfigurable.display.name=Xdebug Cloud
XdebugCloudConfigurable.port=Cloud 連接埠:
XdebugShowUserDefinedConstantsToggleAction.description=將其停用會停止獲取使用者定義的常數資訊並提高偵錯器性能
XdebugShowUserDefinedConstantsToggleAction.text=顯示使用者定義的常數
a.class.constant.must.not.be.called.class.it.is.reserved.for.class.name.fetching=類別常數不得被稱為 'class'；後者被保留用於類別名提取
a.full.numeric.representation.of.a.year.at.least.4.digits.with.for.years.bce=年份的完整數字表示，至少 4 位數，使用 - 表示公元前的年份(2022 年)
a.full.textual.representation.of.a.month.such.as.january.or.march=月份的完整文本表示，英語(January 到 December)
a.full.textual.representation.of.the.day.of.the.week=星期几的完整文本表示(Sunday 到 Saturday)
a.short.textual.representation.of.a.month.three.letters=月份的短文本表示，三個英語字母(Jan 到 Dec)
a.textual.representation.of.a.day.three.letters=星期几的文本表示，三個英語字母(Mon 到 Sun)
a.trait.cannot.extend.a.class=特徵無法擴展類別
a.trait.cannot.implement.an.interface=特徵無法實作接口
a.two.digit.representation.of.a.year=年份的兩位數表示(22)
absolute.reference.is.not.allowed=不允許絕對參照
abstract.modifier.is.not.allowed.here=此處不允許使用 'Abstract' 修飾符
access.level.to.0.1.must.be.2.as.in.class.3.or.weaker=''{0}::\${1}'' 的存取級別必須為 {2} (與類別 {3} 中一樣)或更低
access.level.to.0.1.must.be.2.as.in.class.3.or.weaker2=''{0}::{1}'' 的存取級別必須為 {2} (與類別 {3} 中一樣)或更低
access.must.be.public=存取必須為 public
access.type.for.interface.member.must.be.omitted=接口成員的存取類型必須省略
action.ChangePHPInterpreter.description=更改專案 PHP 解釋器
action.ChangePHPInterpreter.text=更改 PHP 解釋器
action.ComposerAddDependencyAction.description=管理 Composer 相依項
action.ComposerAddDependencyAction.text=管理相依項…
action.ComposerClearCacheAction.description=刪除 Composer 快取目錄中的所有內容
action.ComposerClearCacheAction.text=清除快取
action.ComposerDiagnoseAction.description=檢查常見的 Composer 問題
action.ComposerDiagnoseAction.text=診斷
action.ComposerDryRunUpdate.description=模擬更新，但不實際更新
action.ComposerDryRunUpdate.text=模擬更新
action.ComposerDumpAutoloadAction.description=重新生成自動載入類別的列表
action.ComposerDumpAutoloadAction.text=傾印自動載入器…
action.ComposerInstallAction.description=考慮到 composer.lock，安裝 composer.json 中的軟體套件
action.ComposerInstallAction.text=安裝
action.ComposerLicensesAction.description=列出安裝的每個軟體套件的名稱、版本和授權
action.ComposerLicensesAction.text=列出授權
action.ComposerSelfUpdateAction.description=將 Composer 本身更新到最新版本
action.ComposerSelfUpdateAction.text=自我更新
action.ComposerShowLogAction.description=顯示包含此 composer.json 的 Composer 動作日誌
action.ComposerShowLogAction.text=顯示日誌
action.ComposerStatusAction.description=檢查任何相依項中有無本地更改
action.ComposerStatusAction.text=檢查相依項中的更改
action.ComposerUpdateAction.description=從 Composer.json 安裝最新適當版本的軟體套件
action.ComposerUpdateAction.text=更新
action.ComposerValidateAction.description=檢查 composer.json 是否有效
action.ComposerValidateAction.text=驗證…
action.DisableXdebugDfaAssist.description=永久關閉數據流輔助偵錯
action.DisableXdebugDfaAssist.text=永久關閉數據流助手
action.MessDetectorAddToIgnored.description=新增到 PHP Mess Detector 忽略列表
action.MessDetectorAddToIgnored.text=新增到 PHPMD 忽略列表
action.PhpCSAddToIgnored.description=新增到 PHP_CodeSniffer 忽略列表
action.PhpCSAddToIgnored.text=新增到 PHPCS 忽略列表
action.PhpCSFixerAddToIgnored.description=新增到 PHP CS Fixer 忽略列表
action.PhpCSFixerAddToIgnored.text=新增到 PHP CS Fixer 忽略列表
action.PhpDebuggerCopyType.text=複製類型
action.PhpDetectPsroRoots.description=將檢測原始碼命名空間根
action.PhpDetectPsroRoots.text=檢測 PSR-0 命名空間根
action.PhpExtractClassAction.description=將元素提取到單獨的類別
action.PhpExtractClassAction.text=提取類別…
action.PhpGenerateConstructor.description=建立建構函式。
action.PhpGenerateConstructor.text=建構函式…
action.PhpGenerateGetters.description=為 private 類別欄位建立 getter。
action.PhpGenerateGetters.text=getter…
action.PhpGenerateGettersAndSetters.description=為 private 類別欄位建立 getter 和 setter。
action.PhpGenerateGettersAndSetters.text=getter 和 setter…
action.PhpGeneratePhpDocBlocks.description=為函式、類別和欄位新增 PHPDoc 塊。
action.PhpGeneratePhpDocBlocks.text=PHPDoc 塊…
action.PhpGenerateSetters.description=為 private 類別欄位建立 setter。
action.PhpGenerateSetters.text=setter…
action.PhpListenDebugAction.description=偵聽偵錯連線
action.PhpListenDebugAction.text=偵聽偵錯連線
action.PhpMakeStaticAction.description=將類別方法設為 static
action.PhpMakeStaticAction.text=設為 static
action.PhpNewTest.description=建立新的 PHP 測試
action.PhpNewTest.text=PHP 測試
action.PhpStanAddToIgnored.description=新增到 PHPStan 忽略列表
action.PhpStanAddToIgnored.text=新增到 PHPStan 忽略列表
action.PhpStormMigrationGuide.text=PhpStorm 遷移指南
action.PhpUnitGenerateSetUpMethod.description=建立 PHPUnit setUp 方法
action.PhpUnitGenerateSetUpMethod.text=SetUp 方法
action.PhpUnitGenerateTearDownMethod.description=建立 PHPUnit tearDown 方法
action.PhpUnitGenerateTearDownMethod.text=TearDown 方法
action.PhpUnitGenerateTestMethod.description=建立 PHPUnit 測試方法
action.PhpUnitGenerateTestMethod.text=測試方法
action.ProfilerJumpToSource.description=跳轉到源
action.ProfilerJumpToSource.text=跳轉到源
action.ProjectFromVersionControl.ProjectWidgetPopup.text=從版本控制中獲取…
action.ProjectFromVersionControl.text=從版本控制新增專案…
action.XDebugger.CopyPath.text=複製路徑
action.XdebugAnalyzeProfilerSnapshotAction.text=分析 Xdebug 分析器快照…
action.XdebugDetachFromSessionAction.text=從會話中分離
action.add.file.s.to.list.text=向列表中新增檔案
action.com.jetbrains.php.composer.ComposerInitSupportAction.description=初始化 Composer
action.com.jetbrains.php.composer.ComposerInitSupportAction.text=初始化 Composer…
action.com.jetbrains.php.internal.PhpCreateYoutrackIssueFromFileAction.text=在 WI (PhpStorm) 專案中根據檔案內容建立 YouTrack 問題
action.com.jetbrains.php.internal.PhpCreateYoutrackIssueFromSelectionAction.text=在 WI (PhpStorm) 專案中根據所選內容建立 YouTrack 問題
action.com.jetbrains.php.internal.PhpShowFQNInternalAction.text=顯示 PHP FQN
action.com.jetbrains.php.internal.PhpViewControlFlowAction.text=當前檔案的 PHP 控制流
action.configuration.text=組態…
action.configure.php.runtime.text=組態 PHP 執行時…
action.configure.project.directories.text=組態專案目錄
action.copy.3v4l.link.text=將 3v4l 連結複製到剪貼簿
action.copy.port.to.clipboard.text=將連接埠值複製到剪貼簿
action.copy.to.clipboard.text=複製到剪貼簿
action.detect.composer.json.not.found=在路徑 {0} 下找不到 composer.json
action.detect.composer.json.not.found.title=找不到 composer.json
action.detect.composer.json.open=在編輯器中開啟
action.detect.settings.sync.turned.on=PHP 語言級別已與 composer.json 同步
action.detect.settings.sync.turned.on.title=已與 composer.json 同步
action.detect.user.settings.state.overwritten=如果開啟同步，IDE 設定(PHP 語言級別，PSR-0/PSR-4 根)可能會被覆蓋
action.detect.user.settings.state.overwritten.short=設定可能會被覆蓋: PSR-0/PSR-4 根和 PHP 語言級別。
action.detect.user.settings.state.supported=支援 PSR-0/PSR-4 根和 PHP 語言級別的同步
action.enable.plugin.text=啟用 ''{0}'' 延伸模組
action.open.3v4l.link.in.browser.text=在瀏覽器中開啟 3v4l 連結
action.quality.tools.provider=品質工具
action.quality.tools.provider.description=檔案被排除在外部品質工具分析和格式化程序外
action.retry.text=重試
action.revert.back.to.text=還原為 {0}
action.run.composer.install.text=執行 'composer install'
action.run.on.3v4l.org.text=在 3v4l.org 上執行
action.show.in.log.text=在日誌中顯示
action.submits.code.to.3v4l.org.show.result.in.preview.editor.description=將程式碼提交到 3v4l.org，並在預覽編輯器中顯示結果
action.synonym.listening=偵聽
action.synonym.start.listening=開始偵聽 PHP Xdebug 連線
action.synonym.stop.listening=停止偵聽 PHP Xdebug 連線
actions.detect.common.setting.from.composer.disable=不同步
actions.detect.common.setting.from.composer.enable=啟用同步
actions.detect.common.setting.from.composer.show.settings=顯示設定
actions.detect.common.setting.from.composer.suggest.title=將設定與 Composer 同步?
actions.detect.common.settings.composer.sync.state.title=與 composer.json 的同步{0}
actions.detect.common.settings.updated.from.composer.title={0} 設定已更新
actions.detect.language.level.loaded.from.composer.idea.title=語言級別
actions.detect.language.level.loaded.from.composer.title=PHP 語言級別
actions.detect.namespace.roots.finished=已完成 PSR-0 命名空間根檢測。
actions.detect.namespace.roots.from.composer.idea.title=來來源根
actions.detect.namespace.roots.from.composer.title=PSR-0/PSR-4 根
actions.detect.namespace.roots.idea.view.configuration=您可以在 '專案結構 | 模組' 中修改設定。
actions.detect.namespace.roots.manual.configuration=手動組態
actions.detect.namespace.roots.no.new.roots.detected=未檢測到新的 PSR-0 命名空間根。
actions.detect.namespace.roots.notification.id=PHP PSR-0 命名空間根檢測已完成
actions.detect.namespace.roots.notification.title=檢測 PSR-0 命名空間根
actions.detect.namespace.roots.progress.title=正在檢測 PSR-0 命名空間根…
actions.detect.namespace.roots.view.configuration=檢視組態
actions.generate.php.doc.is.not.available=PHPDoc 生成在索引更新期間不可用
actions.mark.directory.as.psr.0.root=<i>{0}</i>
actions.mark.directory.as.psr.0.root.mark.psr=標記為 {0} 根
actions.mark.directory.as.psr.0.root.title=是否要將目錄標記為 {0} 根?
actions.mark.directory.as.psr.0.root.with.prefix=<i>{0}</i>為前綴“{1}”?
actions.new.php.base.arrows.extension.tooltip=在編輯器中按向上或向下箭頭可更改檔案副檔名
actions.new.php.base.arrows.template.tooltip=在編輯器中按向上或向下箭頭可更改模板
actions.new.php.base.dialog.label.extension=檔案副檔名:
actions.new.php.base.dialog.label.file.name=檔名:
actions.new.php.class.action.description=建立新的 PHP 類別
actions.new.php.class.action.name=PHP 類別
actions.new.php.class.dialog.border.title.class=類別
actions.new.php.class.dialog.label.class.name=名稱:
actions.new.php.class.dialog.label.directory=目錄:
actions.new.php.class.dialog.label.namespace=命名空間:
actions.new.php.class.dialog.label.superclasses.container=父類別
actions.new.php.class.dialog.label.superclasses.super.fqn=擴展:
actions.new.php.class.dialog.label.superinterfaces.add.interface=新增接口…
actions.new.php.class.dialog.label.superinterfaces.to.extend.empty=選擇要擴展的接口
actions.new.php.class.dialog.label.superinterfaces.to.implement=實作:
actions.new.php.class.dialog.label.superinterfaces.to.implement.empty=選擇要實作的接口
actions.new.php.class.dialog.label.template=模板:
actions.new.php.class.dialog.title=建立新的 PHP 類別
actions.new.php.file.action.description=建立新的 PHP 檔案
actions.new.php.file.action.name=PHP 檔案
actions.new.php.file.dialog.title=建立新的 PHP 檔案
actions.new.phpunit.class.action.description=建立新的 PHPUnit 測試
actions.new.phpunit.class.action.name=PHPUnit 測試
actions.new.test.class.action.description=建立新的 PHP 測試
actions.new.test.class.action.name=新增 PHP 測試
actions.new.test.class.dialog.arrows.libraries.hint=在編輯器中按向上或向下箭頭可更改測試庫
actions.new.test.class.dialog.border.title.class.to.test=要測試的類別(可選)
actions.new.test.class.dialog.border.title.target.class.file.path=檔案路徑:
actions.new.test.class.dialog.border.title.test.class=測試類別
actions.new.test.class.dialog.label.directory=目錄:
actions.new.test.class.dialog.label.fqn=完全限定名稱:
actions.new.test.class.dialog.label.name=名稱:
actions.new.test.class.dialog.label.namespace=命名空間:
actions.new.test.class.dialog.select.methods.show.inherited.methods=顯示繼承的方法(&I)
actions.new.test.class.dialog.title=建立新的 PHP 測試
actions.new.test.class.dialog.title.named=為 {0} 建立新的 PHP 測試
add=新增
add.catch.clause.quick.fix=新增 'catch' 從句
add.clarifying.parentheses=新增澄清括號
add.class=新增類別…
add.class1=新增類別
add.constant.0.to.class.1.and.opens.containing.file.in.editor=將常數 ''{0}'' 新增到類別 ''{1}'' 並在編輯器中開啟包含的檔案
add.constant.declaration.quick.fix.text=新增常數
add.custom.format.function=新增自訂格式函式…
add.custom.format.function1=新增自訂格式函式
add.enum.declaration.quick.fix.text=新增枚舉 case
add.fluent.setter=新增 fluent setter
add.global.variable.quick.fix.family.name=新增全域變數
add.global.variable.quick.fix.text=新增 ''global \${0}''
add.phpunit.test.pattern=新增 PHPUnit 測試模式
add.port.in.ide.settings=將連接埠 {0} 新增到設定
add.property=新增 @property
add.remote.interpreter=新增遠端解釋器
add.return.type=新增返回值類型
add.rule=新增規則
add.serialize.magic.method=新增{0}方法
add.serialize.magic.methods=新增{0}方法
add.setter=新增 setter
add.slash.to.the.start=在開頭新增 '/'
add.test.class.method=新增測試類別/方法…
add.throw.before.exception=在表達式前面新增 'throw'
add.to.composer.json.quick.fix=向 composer.json 中新增 ''{0}''
add.to.excluded.files.action=將 \`{0}\` 新增到忽略的檔案
advanced.setting.php.code.vision.hierarchy.limit=Code Vision: 要處理的最大繼承實體數
advanced.setting.php.code.vision.usages.limit=Code Vision: 要搜尋的最大用法數
advanced.setting.php.max.chain.resolve.depth=解析成員參照的最大深度
advanced.setting.php.sql.completion.recursive.jumps.limit=補全: 尋找 SQL 查詢時要解析的最大元素數量
alias=別名
align.composer.log.console=對齊 Composer 日誌主控台
all.0=所有({0})
all.cases.of.backed.enum.must.have.a.value=備用枚舉的所有 case 必須包含值
all.exceptions.considered.checked=所有異常均被視為已檢查
all.scripts=<All scripts>
all.values=所有變數
all.versions=所有版本
always.show.pass.by.reference=始終顯示參照傳遞
an.alias.was.defined.for.method.0.which.exists.in.1=已為 {1} 中的方法 {0}() 定義別名
an.expanded.full.numeric.representation.if.requried.or.a.full.numeral.representation.like.y=擴展的完整數字表示(如果需要)，或完整數字表示(2022)
an.expanded.full.numeric.representation.of.a.year.at.least.4.digits.with.or=年份的擴展完整數字表示，至少 4 位數，帶 - 或 + (+2022)
an.object.s.clone.method.cannot.be.called.directly=無法直接呼叫物件的 '__clone()' 方法
analyzing.php.sdk=正在檢查 PHP 安裝…
and=和
annotation.expression.is.not.allowed.as.class.constant.value=表達式不允許為類別常量值
annotation.new.expression.abstract=無法實例化抽象類別 ''{0}''
annotation.new.expression.enum=無法實例化枚舉 ''{0}''
annotation.new.expression.interface=無法實例化接口 ''{0}''
annotation.new.expression.trait=無法實例化特徵 ''{0}''
annotation.variable.variable=可變變數
annotator.cannot.break.continue=無法中斷/繼續{0}級別
annotator.duplicate.default.match.condition=match 表達式只能包含一個 'default' 分支
annotator.duplicate.use.statement=無法使用 ''{0}''，因為該名稱已被使用
annotator.fix.remove=移除 ''{0}''
annotator.invalid.class.name=''{0}'' 是無效的類別名
annotator.jump.out.of.finally=不允許跳出 finally 塊
annotator.only.default.condition.allowed='default' arm 中僅允許單個 'default' 條件
annotator.reserved.class.name=無法使用 ''{0}'' 作為類別名，因為該名稱已被保留
annotator.special.class.name=無法將 {0} 用作 {1}，因為 ''{1}'' 是一個特殊的類別名
annotator.unhandled.match.argument=未處理的 'match' 實參
anonymous.0=匿名{0}
anonymous.class=匿名類別
anonymous.function=匿名函式
anonymous.function.expected=應為匿名函式
another.definition.with.same.name.exists.in.this.file=此檔案中存在另一個具有相同名稱的定義
argument.passed.must.be.of.the.type.0.1.given=傳遞的實參必須為 {0} 類型，給定的為 {1}
array.callback.must.have.exactly.two.elements=陣列回調必須正好有兩個元素
array.can.t.be.used.for.array.destructuring.assignment='array()' 不能用於陣列解構指派
array.declaration.style=陣列/列表宣告樣式
array.index=陣列索引
array.only.updated.but.never.queried=陣列僅被更新，但從未被查詢
arrays.are.not.supported.as.operands.for.0=不支持將陣列用作 ''{0}'' 的動作數
attribute.can.be.added.to.overridden.method=可以將特性新增到覆寫方法
attribute.can.be.added.to.overridden.parameter=可以將特性新增到覆寫參數
attribute.must.be.first.child.of.parent.element=特性必須是父元素的第一個子項
attributes.are.inapplicable.for.constants=特性不適用於常數
auto.import.from.global.space=處理來自全域空間的符號
auto.import.from.global.space.class=類別:
auto.import.from.global.space.constant=常數:
auto.import.from.global.space.function=函式:
auto.import.from.global.space.prefer.fallback=回退優先
auto.import.from.global.space.prefer.fqn=FQN 優先
auto.import.from.global.space.prefer.import=匯入優先
auto.import.in.file.scope=在檔案作用域內啟用自動匯入
auto.import.in.namespace.scope=在命名空間作用域內啟用自動匯入
background.task.detect.namespace.roots.progress.title=正在檢測命名空間根…
bit.shift.by.negative.number=按負數進行移位
border.title.additional.dependencies=其他相依項
border.title.constant.syntax=常數語法
border.title.include.analysis=Include 分析
border.title.initialize.in=初始化位置
border.title.introduce.field=引入屬性
border.title.introduce.variable=引入變數
border.title.options=選項
border.title.php=PHP
border.title.require.dependencies='require' 相依項
border.title.require.dev.dependencies='require-dev' 相依項
border.title.visibility=可見性
build.control.flow=建置控制流(&B)
build.control.flow.with.exit.points=使用出口點建置控制流(&E)
button.sync.extensions.with.interpreter=將擴展與解釋器同步
cache.creating=正在建立 psalm 快取…
call.to.0.1.construct.from.invalid.context=從無效上下文呼叫 ''{0} {1}::__construct()''
call.to.method.clone.from.invalid.context=從無效上下文呼叫方法 '__clone'
call.tree=呼叫樹
callees=被呼叫方
callers=呼叫方
can.not.correctly.run.the.tool.with.parameters=無法使用參數正確執行該工具:
can.not.delete.temporary.file.because.it.was.not.created=無法刪除臨時檔案，因為未建立該檔案
can.not.execute.tests=無法執行測試
can.not.execute.transfer.task.project.is.already.disposed=無法執行傳輸任務: 專案已被處置
can.not.find.0.helper.script=找不到 ''{0}'' 幫助程序腳本
can.not.find.specified.interpreter=找不到指定的解釋器
can.not.parse.phpunit.version.output.0=無法解析 PHPUnit 版本輸出: {0}
can.not.run.command.composer.execution.plugin.was.unloaded=無法執行指令: Composer 執行延伸模組已移除
can.only.be.used.as.standalone.type={0} 僅可用作獨立類型
can.t.use.nullsafe.operator.in.write.context=在寫入上下文中不能使用 nullsafe 運算符
cancel=取消
cancel.ide.registration=取消 IDE 註冊
cannot.apply.0.to.interface=無法將 {0} 應用於接口
cannot.apply.0.to.readonly.class=無法將 {0} 應用於 ''readonly'' 類別
cannot.apply.0.to.trait=無法將 {0} 應用於特徵
cannot.call.abstract.method.0.1=無法呼叫 abstract 方法 ''{0}::{1}''
cannot.combine.nullsafe.operator.with.closure.creation=無法將 nullsafe 運算符與 'Closure' 建立組合
cannot.create.closure.for.new.expression=無法為 'new' 表達式建立 'Closure'
cannot.declare.dynamic.properties.in.readonly.class=不能在 'readonly' 類別中宣告動態屬性
cannot.declare.promoted.property.in.an.abstract.constructor=無法在 abstract 建構函式中宣告提升的屬性
cannot.declare.promoted.property.outside.a.constructor=無法在建構函式外部宣告提升的屬性
cannot.declare.self.referencing.constant=無法宣告自參照常數
cannot.declare.static.properties.in.readonly.class=不能在 'readonly' 類別中宣告 'static' 屬性
cannot.declare.variadic.promoted.property=無法宣告可變提升屬性
cannot.implement.interface.0=無法實作接口 ''{0}''
cannot.implement.interface.0.directly=無法直接實作接口 ''{0}''
cannot.inherit.previously.inherited.or.override.constant.0.from.interface.1=無法從接口 ''{1}'' 繼承先前繼承的常數 ''{0}'' 或將其覆寫
cannot.make.interface.method.non.static=無法將接口方法設為非 static
cannot.make.interface.method.static=無法將接口方法設為 static
cannot.mix.amp.and.pipe.in.type.declaration=類型宣告中不能混用 '\\\\&' 和 '|'
cannot.mix.and.list=不能混合 [] 與 list()
cannot.mix.keyed.and.unkeyed.array.entries.in.assignments=在指派中不能混合鍵控和非鍵控陣列條目
cannot.override.final.constant=無法從 ''{1}'' 覆寫 final 常數 ''{0}''
cannot.redeclare.constant.0=無法重新宣告常數 ''{0}''
cannot.redeclare.methods.from.enum.implicit.interfaces=無法從枚舉隱式接口重新宣告方法
cannot.redeclare.non.static.0.1.as.static.2.3=無法將非 static ''{0}::\${1}'' 重新宣告為 static ''{2}::\${3}''
cannot.redeclare.static.0.1.as.non.static.2.3=無法將 static ''{0}::\${1}'' 重新宣告為非 static ''{2}::\${3}''
cannot.register.handler=無法註冊處理程序
cannot.use.0.as.lexical.variable=無法將 ''\${0}'' 用作詞法變數
cannot.use.class.on.primitive.type=只允許在物件上使用 '::class'
cannot.use.empty.array.elements.in.arrays=無法在陣列中使用空陣列元素
cannot.use.empty.array.entries.in.keyed.array.assignment=在鍵控陣列指派中不能使用空陣列條目
cannot.use.empty.list=無法使用空列表
cannot.use.for.reading=無法使用 '[]' 進行讀取
cannot.use.match.as.identifier=無法將 'match' 用作關鍵字，自 PHP 8.0 起作為預留關鍵字
cannot.use.positional.argument.after.argument.unpacking=無法在實參解包後使用位置實參
cannot.use.positional.argument.after.argument.unpacking.named.argument.81=實參解包後的位置實參從 PHP 8.1 起才可用
cannot.use.positional.argument.after.named.argument=無法在命名實參後面使用位置實參
cannot.use.readonly.as.identifier=無法將 'readonly' 用作關鍵字。自 PHP 8.1 起作為預留關鍵字
cannot.use.static.as.function.return.type.declaration=不允許 'static' 作為類別作用域外部的返回值類型宣告
cannot.use.this.as.parameter=不能將 $this 用作參數
cannot.use.traits.inside.of.interfaces=無法在接口內部使用特徵
cannot.use.unpacking.in.attribute.argument.list=無法在特性實參列表中使用解包
cannot.use.yield.from.inside.a.by.reference.generator=不能在參照傳遞產生器中使用 'yield from'
cant.save.interpreter=無法儲存 ''{0}'': {1}
cant.use.temporary.expression.in.write.context=在寫上下文中不能使用臨時表達式
case.of.non.backed.enum.must.not.have.a.value=非備用枚舉的 case 不得包含值
caused.by.0=原因是:“{0}”
change.member.access=更改成員存取
change.method.modifiers.to.0=將方法修飾符更改為 ''{0}''
change.php.language.level=更改 PHP 語言級別
change.signature.arg.type.incompatible=應為 ''{0}'' 類型的參數，提供的是 ''{1}''
change.signature.arg.type.miss.argument=應為 ''{0}'' 類型的參數
change.signature.column.name.parameter=參數:
change.signature.column.type.parameter=類型:
change.signature.error.wrong.caret.position=文字游標應置於要重構的函式的名稱處。
change.signature.find.usages.of.base.class=類別 {1} 的方法 {0}\\n重寫了類別 {2} 的方法。\\n要{3}基方法嗎?
change.signature.find.usages.of.base.interface=類別 {1} 的方法 {0}\\n實作了接口 {2} 的方法。\\n要{3}基方法嗎?
change.signature.initialize.new.parameters=建立並初始化類別屬性(&I)
change.signature.parameter.may.have.side.effect=用作參數“{1}”的表達式“{0}”可能會有副作用
change.signature.tooltip.default.value=要在此方法的所有現有呼叫中使用的值
change.signature.tooltip.parameter=$name = 'init' 或 &...$array = 'init'
change.signature.usage.view.declarations.header=要重構的函式
change.signature.visibility.not.accessible=可見性為 {1} 的{0}將無法從{2}存取
checkbox.add.a.comma.after.last.argument.in.function.call=在函式呼叫中的最後一個實參後新增逗號
checkbox.add.a.comma.after.last.element.in.multiline.array=在多行陣列中的最後一個元素之後新增逗號
checkbox.add.a.comma.after.last.match.arm=在最後一個 match arm 後新增一個逗號
checkbox.add.a.comma.after.last.parameter=在參數列表中的最後一個參數後新增逗號
checkbox.add.a.comma.after.last.var.in.closure.use.list=在閉包 use 列表中的最後一個變數後新增逗號
checkbox.add.packages.as.libraries=作為庫新增軟體套件(&A)
checkbox.add.phpdoc=新增 PHPDoc(&D):
checkbox.align.parameter.property.names=對齊參數/屬性名稱
checkbox.align.tag.comments=對齊標記註釋
checkbox.always.enable.php.code.background.highlighting=始終啟用 PHP 程式碼背景醒目提示顯示
checkbox.anonymous.classes=匿名類別
checkbox.blank.line.before.the.first.tag=在第一個標記前使用空行
checkbox.blank.lines.around.parameters=在參數周圍使用空行
checkbox.check.clone.method=檢查 '__clone' 方法
checkbox.check.destruct.method=檢查 '__destruct' 方法
checkbox.check.sleep.method=檢查 '__sleep' 方法
checkbox.check.wakeup.method=檢查 '__wakeup' 方法
checkbox.force.short.declaration.style=強制短宣告樣式
checkbox.ignore.empty.functions=忽略空函式
checkbox.ignore.test.methods=忽略測試方法
checkbox.keep.blank.lines=保留空行
checkbox.lambdas=Lambda
checkbox.move.to.another.class=移至另一個類別(&M)
checkbox.rename.only.nearest.scope=僅重新命名最近作用域中的變數
checkbox.show.class.namespace.separators=顯示 PHP 類別和命名空間分隔符
checkbox.sort.phpdoc.tags=對 PHPDoc 標記排序
checkbox.static=static
checkbox.use.as.a.default.template=用作預設模板
checkbox.use.composer=新增 'composer.json'
checkbox.use.fully.qualified.class.names=使用完全限定類別名
checkbox.wrap.long.lines=長行換行
checking.for.changes.in.code.of.dependencies=正在檢查相依項程式碼中的更改
choose.a.valid.0.launcher=選擇有效的 {0} 啟動器
choose.an.alias.to.use=選擇要使用的別名
choose.class=選擇類別
choose.elements.to.generate.phpdoc.for=選擇要為其生成 PHPDoc 的元素
choose.executable.class.to.run.0=選擇用於執行 {0} 的可執行類別
choose.methods.to.implement=選擇要實作的方法
choose.methods.to.implement1=選擇要實作的方法
choose.methods.to.override=選擇要覆寫的方法
choose.php.home=選擇 PHP 可執行檔案
choose.properties=選擇屬性
choose.super.class.or.interface=選擇超類別或接口
choose.super.method=選擇 super 方法
choose.test.method.to.run.dataset.0=選擇測試方法以執行資料集 {0}
class=類別
class.cannot.extend.from.trait=類別無法從特徵擴展
class.cannot.implement.previously.implemented.interface=類別無法實作先前實作的接口
class.constant=類別常數
class.constant1=類別常數
class.constructor=類別建構函式
class.declarations.may.not.be.nested=類別宣告不能被嵌套
class.implements.solely.traversable=類別 ''{0}'' 必須將接口 Traversable 作為 Iterator 或 IteratorAggregate 的一部分來實作
class.implements.the.serializable.interface.which.is.deprecated=在不使用 '__serialize()'/'__unserialize()' 方法的情況下實作 'Serializable' 接口已棄用
class.name=類別名
class.ref.is.deprecated=類別 '#ref' 已棄用
class.reference=類別參照
class.should.not.implement.itself=類別不應自行實作
class1=類別
class2=類別
classes.can.not.have.backed.type=類別不能有備用類型
classes.named.never.is.forbidden.in.php.8.1=PHP 8.1 中禁止名為 'never' 的類別
classes.named.object.are.forbidden.in.php.7.2=PHP 7.2 中禁止名為 'object' 的類別
classes.named.void.and.iterable.are.forbidden.in.php.7.1=PHP 7.1 中禁止名為 'void' 和 'iterable' 的類別
classes.without.member=層次結構中不帶 ''{0}'' 的類別
cleaning.up=正在清理…
clear.log=清除日誌
clearing.cache=正在清除快取
cli.interpreters.name=CLI 解釋器
close=關閉(&C)
closest.scope=最近作用域中的變數
code.fully.qualified.classname.methodname.key.value.code.example.precise.match={0} 是一個精確排除的範例。
code.global.code.matches.function.with.two.parameters={0} 符合帶有兩個參數的函式。
code.info.code.matches.all.single.parameter.methods.where.the.parameter.name.ends.with.em.info.em={0} 符合參數名以 {1} 結尾的所有單參數方法。
code.key.value.code.matches.all.methods.with.parameters.em.key.em.and.em.value.em={0} 符合所有具有參數 {1} 和 {2} 的方法。
code.size.rules=程式碼大小規則
code.style.option.after='{' 之後:
code.style.option.after.class.body=類別主體之後:
code.style.option.after.colon.in.enum.backed.type=在備用枚舉中類型宣告旁邊的冒號後面
code.style.option.after.colon.in.named.argument=命名實參中的冒號之後
code.style.option.after.colon.in.return.type=返回值類型中的冒號之後
code.style.option.after.function=函式之後:
code.style.option.after.namespace=命名空間之後:
code.style.option.after.opening.tag=起始標記之後:
code.style.option.after.unary.not=一元非(!)之後
code.style.option.after.use.statements=在 'Use' 語句後:
code.style.option.align.consecutive.assignments=對齊連續指派
code.style.option.align.constants=對齊常數
code.style.option.align.enum.cases=對齊枚舉 case
code.style.option.align.inline.comments=對齊內聯註釋
code.style.option.align.key.value.pairs=對齊鍵值對
code.style.option.align.properties.in.columns=對齊列中屬性
code.style.option.and=<?= 和 ?>
code.style.option.anonymous.function.parentheses=匿名函式括號
code.style.option.around.class.constants=類別常數周圍:
code.style.option.around.enum.cases=枚舉 case 周圍:
code.style.option.around.property=屬性周圍:
code.style.option.array.initializer.parentheses=陣列初始設定式圓括號
code.style.option.arrow.function.parentheses=箭頭函式括號
code.style.option.assignment.in.declare.statement=在 declare 語句中指派
code.style.option.attributes=特性
code.style.option.before.class.body=類別主體之前:
code.style.option.before.colon.in.enum.backed.type=在備用枚舉中類型宣告旁邊的冒號前面
code.style.option.before.colon.in.named.argument=命名實參中的冒號之前
code.style.option.before.colon.in.return.type=返回值類型中的冒號之前
code.style.option.before.namespace=命名空間之前:
code.style.option.before.return.statement=在 'return' 語句前:
code.style.option.before.unary.not=一元非(!)之前
code.style.option.before.use.statements=在 'Use' 語句前:
code.style.option.between.and='?' 與 ':' 之間
code.style.option.between.group.use.statements=在 'Use' 語句組之間:
code.style.option.brackets.around.variable.expression=使用中括號將變數/表達式括起來
code.style.option.class.field.constant.groups=類別屬性/常數組
code.style.option.concatenation=串聯(.)
code.style.option.for.foreach.statements=for()/foreach() 語句
code.style.option.force.empty.functions.braces.in.one.line=將空函式/方法的大括號放在一行
code.style.option.function.call.parentheses=函式呼叫括號
code.style.option.function.constructor.call.arguments=函式/建構函式呼叫實參
code.style.option.function.declaration.parameters=函式宣告參數
code.style.option.function.declaration.parentheses=函式宣告括號
code.style.option.function.left.brace=函式左大括號
code.style.option.function.return.type=函式返回值類型
code.style.option.group.use=將 'use' 分組
code.style.option.in.anonymous.class.declaration=在匿名類別宣告中
code.style.option.in.closure.declaration=在閉包宣告中
code.style.option.in.function.declaration=在函式宣告中
code.style.option.in.namespace=在命名空間中
code.style.option.keep.and.on.one.line=將 ')' 和 '{' 保持在同一行
code.style.option.match.expression='match' 表達式
code.style.option.match.expression.align.match.arm.bodies=對齊 'match' arm 主體
code.style.option.multiline.arrays.lambdas=將多行陣列/匿名函式視為多行實參
code.style.option.multiplicative.operators=乘法運算符(*, /, %, **)
code.style.option.new.line.after=在第一個元素後換行
code.style.option.new.line.after.php.tag=在 '<?php' 標記後換行
code.style.option.null.coalescing.operator=null 合併運算符(??)
code.style.option.object.access.operator=物件存取運算符(->)
code.style.option.parameter.attributes=參數特性
code.style.option.php.opening.tag=PHP 起始標記
code.style.option.place.braces.for.constructor.always=始終
code.style.option.place.braces.for.constructor.as.is=保留原樣
code.style.option.place.braces.for.constructor.never=從不
code.style.option.place.for.constructor=放置建構函式的 '()'
code.style.option.place.on.new.line=將 ';' 置於新行中
code.style.option.place.on.new.line2=在最後一個元素後換行
code.style.option.relational.operators=關係運算符(<、>、<=、>=、<=>)
code.style.option.return.type.on.new.line=返回值類型位於新行中
code.style.option.shift.operators=移位運算符(<<,>>)
code.style.option.space.around.pipe.in.union.types=聯合類型的 | 周圍
code.style.option.unary.additive.operators=一元加法運算符(+,-,++,--)
code.vision.implementations.hint={0, choice, 1#1 個實作|2#{0,number}'{1,choice, |1#+}' 實作}
code.vision.inheritors.hint={0, choice, 1#1 個繼承者|2#{0,number}'{1,choice, |1#+}' 繼承者}
code.vision.overrides.hint={0, choice, 1#1 個覆寫|2#{0,number}'{1,choice, |1#+}' 覆寫}
code.vision.used.in.hint=由 {0}{1, choice, |1#+} 使用
color.settings.alias.primitive.type.hint=關鍵字//基元類型提示
color.settings.alias.reference=關鍵字//別名參照
color.settings.attributes=特性
color.settings.bad_character=未知字元
color.settings.braces=大括號和運算符//大括號
color.settings.brackets=大括號和運算符//中括號
color.settings.class=類別和屬性//類別
color.settings.comma=大括號和運算符//逗號
color.settings.comment=註釋
color.settings.concatenation=字串//串聯
color.settings.constant=關鍵字//常數
color.settings.doc.identifier=PHPDoc//關鍵字
color.settings.doc.method.identifier=PHPDoc//方法宣告
color.settings.doc.parameter=PHPDoc//參數
color.settings.doc.property.identifier=PHPDoc//屬性
color.settings.doc.var=PHPDoc//變數
color.settings.doccomment=PHPDoc//文本
color.settings.docmarkup=PHPDoc//標記
color.settings.doctag=PHPDoc//標記
color.settings.escape_sequence=字串//轉義序列
color.settings.exec_command=Shell 指令
color.settings.function=函式和方法//宣告
color.settings.function.call=函式和方法//函式呼叫
color.settings.goto.label=關鍵字//轉到標籤
color.settings.heredoc_content=Heredoc//Heredoc 內容
color.settings.heredoc_id=Heredoc//Heredoc ID
color.settings.identifier=關鍵字//預設
color.settings.instance.field=類別和屬性//執行個體屬性
color.settings.instance.method=函式和方法//執行個體方法呼叫
color.settings.instance.private.field=類別和屬性//private 執行個體屬性
color.settings.instance.private.method=函式和方法//private 執行個體方法呼叫
color.settings.instance.protected.field=類別和屬性//protected 執行個體屬性
color.settings.instance.protected.method=函式和方法//protected 執行個體方法呼叫
color.settings.interface=類別和屬性//接口
color.settings.keyword=關鍵字
color.settings.magic.member=關鍵字//魔術成員存取
color.settings.name=PHP
color.settings.named.arguments=命名實參
color.settings.number=數字
color.settings.operation=大括號和運算符//運算符
color.settings.parameter=函式和方法//參數
color.settings.parentheses=大括號和運算符//圓括號
color.settings.php.scripting=PHP 程式碼//背景
color.settings.php.tags=PHP 程式碼//標記
color.settings.predefined.symbols=關鍵字//預定義符號
color.settings.semicolon=大括號和運算符//分號
color.settings.static.field=類別和屬性//static 屬性
color.settings.static.method=函式和方法//static 方法呼叫
color.settings.string=字串//字元
color.settings.this.var=關鍵字//'$this' 變數
color.settings.var=關鍵字//變數
color.settings.var_var=關鍵字//可變變數
column.name.annotation.name=註解名稱
column.name.file.directory=檔案/目錄
column.name.parameter=參數
command.name.disable.synchronisation.with.composer=停用與 composer.json 同步
command.name.make.method.static=將方法設為 static
command.name.new.file=新增檔案
completion.press.again.to.see.all.classes=再次按 {0} 以檢視所有類別
completion.press.again.to.see.global.variants=再次按 {0} 以檢視全域變體
completion.press.again.to.see.more.variants=再次按 {0} 以檢視更多變體
composer=composer
composer.autoloader.generation.settings.name=自動載入器生成設定
composer.border.title.execution=執行
composer.border.title.package=軟體套件
composer.change.setting.action.name=更改設定
composer.checkbox.allow.unbound.version.constraints=允許未綁定的版本約束
composer.checkbox.autoload.classes.from.the.classmap.only=僅從類別映射自動載入類別
composer.checkbox.check.if.composer.lock.is.up.to.date=檢查 composer.lock 是否為最新
composer.checkbox.check.if.the.package.is.packagist.ready=檢查軟體套件是否為 Packagist 就緒
composer.checkbox.disable.autoload.dev.dependencies=停用 autoload-dev 相依項
composer.checkbox.download.composer.phar.from.getcomposer.org=從 getcomposer.org 下載 composer-stable.phar
composer.checkbox.optimize.autoloader.convert.psr.0.4.rules.to.a.classmap=最佳化自動載入器(將 PSR-0/4 規則轉換為類別映射)
composer.checkbox.skip.scripts.execution=跳過腳本執行
composer.checkbox.synchronize.ide.settings.with.composer.json=將 IDE 設定與 composer.json 同步(&S)
composer.checkbox.use.apcu.to.cache.found.not.found.classes=使用 APCu 快取找到/未找到的類別
composer.checkbox.validate.package.dependencies=驗證軟體套件相依項
composer.checking.for.changes.in.code.of.dependencies.task.title=檢查相依項程式碼中的更改
composer.clearing.cache.action.name=清除快取
composer.diagnose.task.title=診斷
composer.executable='composer' 可執行檔案
composer.generate.list.popup.title=生成
composer.generating.autoloader.task.title=生成自動載入器
composer.json.custom.invalid.json=json 無效
composer.json.custom.packages.done=自訂儲存庫已載入
composer.json.custom.packages.empty=找不到軟體套件。請檢查您的儲存庫
composer.json.exec.not.configured=自訂儲存庫無法載入。未組態 Composer 可執行檔案路徑
composer.json.file=composer.json 檔案
composer.json.open.tool.settings.intention=開啟工具設定
composer.json.packages.loading.error=軟體套件未重新載入
composer.json.packages.refresh=軟體套件正在重新整理
composer.json.packagist.packages.done=僅載入了 packagist 儲存庫
composer.json.path.not.configured=自訂儲存庫無法載入。未組態 composer.json 路徑
composer.label.can.be.time.consuming=可能較為耗時
composer.label.executable='composer' 可執行檔案
composer.label.filter.packages=篩選軟體套件(&F):
composer.label.label=標籤
composer.label.package=軟體套件:
composer.label.path.to.composer.json=composer.json 路徑(&C):
composer.label.phar=composer.phar
composer.label.the.settings.php.language.level.directories.may.be.updated=設定(Php 語言級別，目錄)可能已更新
composer.label.version.to.install=要安裝的版本:
composer.listing.licenses.task.title=列出授權
composer.packages.versions=Composer 軟體套件版本
composer.remove.action.name=移除(&R)
composer.require.package.task.title=需要 Composer 軟體套件
composer.revert.action.name=還原
composer.simulating.update.task.title=模擬更新
composer.update.composer.packages.task.title=更新 Composer 軟體套件
composer.update.composer.task.title=更新 Composer
composer.validate.dialog.action.button.title=驗證
composer.validating.task.title=驗證
composer.validation.settings.name=驗證設定
composer.version.update.hint=已安裝軟體套件的當前版本和可用更新。
composite.test.patterns=複合測試模式
config.file.doesnt.exist=組態檔案不存在
configurable.PhpDebugConfigurable.display.name=偵錯
configurable.PhpProjectConfigurable.display.name=PHP
configurable.PhpServerConfigurable.display.name=伺服器
configurable.PhpServersConfigurable.display.name=伺服器
configurable.PhpSmartKeysConfigurable.display.name=PHP
configurable.PhpTemplatesCommonConfigurable.display.name=模板
configurable.PhpTestFrameworksConfigurable.display.name=測試框架
configurable.QualityToolCommonConfigurable.display.name=品質工具
configure=組態
configure.php.include.paths=組態 PHP Include 路徑(&O)…
configure.suppressed.annotations=組態禁止的註解
configured.is.incorrect=組態的 {0} 不正確
conflict.class.constant.with.same.name.already.exists=此類別中已經定義了具有相同名稱的常數
conflict.class.with.same.name.already.exists=已經定義了具有相同名稱的類別
conflict.constant.with.same.name.already.exists=已經定義了具有相同名稱的常數
conflict.field.with.same.name.already.exists=此類別中已經定義了具有相同名稱的屬性
conflict.function.with.same.name.already.exists=已經定義了具有相同名稱的函式
conflict.method.with.same.name.already.exists=此類別中已經定義了具有相同名稱的方法
conflict.parameter.with.same.name.already.exists=已經定義了具有相同名稱的參數
conflict.tag.name.contains.close.tag=文本包含“{0}”
conflict.template.parameter.with.same.name.already.exists=已存在同名的模板參數
conflict.use.with.same.name.already.exists=已經定義名稱相同的 'Use' 語句
conflict.variable.with.same.name.already.exists=已經定義了具有相同名稱的變數
connection.failed.message=連線失敗。請檢查您的網絡連線並重試。
connection.port.is.busy=連接埠 {0} 繁忙
constant=常數
constant.0=常數 {0}
constant.expression.contains.invalid.operations=常數表達式包含無效運算
constant.ref.is.deprecated=常數 '#ref' 已棄用
constant.ref.is.deprecated1=常數 '#ref' 已棄用
constant.ref.not.found.in=在 {0} 中未找到常數 ''#ref''
constant.with.same.name.already.exists.in.0={0} 中已經存在名稱相同的常數
constants.defined.using.the.const.keyword.must.be.declared.at.the.top.level.scope=使用 'const' 關鍵字定義的常數必須在頂層作用域宣告
constants.may.only.evaluate.to.scalar.values.arrays.or.resources=常數的求值結果只能為標量值、陣列或資源
constructor.already.exists=建構函式已存在
constructor.field=建構函式欄位
constructors=建構函式
controversial.rules=有爭議的規則
convert.closure.to.arrow.function=將閉包轉換為箭頭函式
convert.concatenation.to.sprintf.call=將串聯轉換為 'sprintf()' 呼叫
convert.string.interpolation.to.concatenation=將字串內插轉換為串聯
convert.string.interpolation.to.sprintf.call=將字串內插轉換為 'sprintf()' 呼叫
convert.the.arrow.function.to.a.traditional.closure=將箭頭函式轉換為傳統閉包
copy=複製
copy.concatenated.string.to.clipboard=將串聯的字串複製到剪貼簿
copy.handler.is.dumb.during.indexing=在索引編制進行時複製類別將只是簡單地複製包含的檔案。您將必須手動更改命名空間和匯入。是否仍要繼續?
copy.switch.branch=複製 'switch' 分支
copy.to.namespace=目標命名空間:
coverage.is.not.supported.for.selected.run.profile=程式碼覆蓋率與所選執行組態檔案不相容
create.missing.target.method.fix=建立缺少的目標方法修復
create.new.class.quickfix=建立新類別
create.new.field.dialog.title=建立新字段
create.target.class.quick.fix=建立目標類別快速修復
creates.a.composer.json.file=建立 composer.json 檔案
creates.new.class.0.in.a.separate.file=在單獨的檔案中建立名為 ''{0}'' 的新類別
creates.new.class.method.0.in.a.separate.file=在單獨的檔案中使用方法 ''{1}'' 建立名為 ''{0}'' 的新類別
ction.run.on.3v4l.org.promotion.tooltip=您現在可以在 3v4l.org 上執行不同 PHP 版本的臨時檔案
custom.format.functions.dialog.class.placeholder=留空以新增純函式
custom.format.functions.dialog.format.index.title=格式字串模板的索引
custom.format.functions.dialog.validation.class.not.found=找不到類別 {0}
custom.format.functions.dialog.validation.format.index=索引必須為非負數
custom.format.functions.dialog.validation.function.not.found=找不到函式 {0}
custom.format.functions.dialog.validation.method.not.found=在 {1} 中找不到方法 {0}
day.of.the.month.2.digits.with.leading.zeros=月中幾號，2 位數，帶前導零(01到 31)
day.of.the.month.without.leading.zeros=月中幾號，不帶前導零(1 到 31)
dbgp.invalid.packet=無效封包
dbgp.proxy=Xdebug 代理
dbgp.proxy.cannot.connect.to.host=無法連線到主機 ''{0}''
dbgp.proxy.cannot.connect.to.xdebug.proxy=無法連線到 ''{0}:{1}'' 上的 Xdebug 代理
dbgp.proxy.host=代理主機
dbgp.proxy.ide.key=IDE 鍵
dbgp.proxy.ide.register.error=無法使用 IDE 鍵 ''{0}'' 註冊 IDE
dbgp.proxy.ide.register.success=IDE 已成功使用 IDE 鍵 ''{0}'' 註冊
dbgp.proxy.ide.unregister.success=IDE 已成功註銷
dbgp.proxy.port=代理連接埠
dbgp.proxy.sending.request.to.xdebug.proxy=正在將請求發送到 Xdebug 代理…
dead.code.commented.out=註釋掉
dead.code.deleted=已刪除
debug.accept.connection=接受
debug.action.copy.as.title=將變數複製為 ''{0}''
debug.action.copy.as.was.fail.can.not.get.full.name=無法將變數複製為 ''{0}''，無法對完整的變數名求值
debug.action.copy.value.as.text=將值複製為…
debug.breakpoint.move.disabled=中斷點移動到解析的位置已被停用，從下一個偵錯會話開始將不會移動中斷點。您可以稍後在 <a href="open">PHP|偵錯</a>下將其啟用。
debug.breakpoint.resolved.disabled=中斷點解析已被停用，從下一個偵錯會話開始將不會解析中斷點。 您可以稍後在 <a href="open">PHP|偵錯</a>下將其啟用。
debug.breakpoint.resolved.notify.disabled=中斷點解析通知已被停用。您可以在 <a href="open">PHP|偵錯|進階設定</a>下將其啟用。
debug.breakpoint.was.moved=<br/>中斷點也已移至此行。
debug.breakpoint.was.resolved=此處的偵錯會話已暫停，因為 ''{0}'' 處的中斷點已被解析到此行。<br/>您可以<a href="disable">停用</a>中斷點解析或<a href="more">了解詳情</a>。<a href="dontshow">不再顯示</a>
debug.cannot.find.port=找不到可用連接埠
debug.cannot.map.local.file=檔案路徑未映射到伺服器上的任何檔案路徑。編輯路徑映射以解決此問題。
debug.cannot.start=無法啟動 ''{0}''
debug.cannot.start.listening.for.connections.from.0=無法開始偵聽來自 ''{0}'' 的連線
debug.check.firewall=請檢查您的防火牆設定
debug.checkbox.can.accept.external.connections=可以接受外部連線
debug.checkbox.ignore.z.ray.system.requests=忽略 Z-Ray 系統請求
debug.composite.value.presentation=[{0}]
debug.configure.servers=組態伺服器
debug.debug.port=偵錯連接埠:
debug.edit.ignored.paths.list=<a href="#a">編輯</a>跳過的路徑。
debug.edit.path.mappings=點擊以設定路徑映射
debug.error=錯誤
debug.error.cannot.evaluate.expression=無法對表達式求值
debug.error.cannot.evaluate.expression0=無法對表達式 ''{0}'' 求值
debug.error.cannot.evaluate.variables=無法對變數求值
debug.error.cannot.modify.value=無法修改值
debug.error.cannot.parse.server.name=要修復，請在遠端伺服器上建立環境變數 <i><b>PHP_IDE_CONFIG</b></i>。<br/><br/><i>Windows:</i> 設定 PHP_IDE_CONFIG="serverName=SomeName"<br/> <i>Linux / Mac OS X:</i> 匯出 PHP_IDE_CONFIG="serverName=SomeName"。
debug.error.cannot.parse.server.name.for.external.connection=無法為外部 {0} 連線解析伺服器名稱。
debug.error.cannot.parse.ssh.connection=無法從 $_SERVER[''SSH_CONNECTION''] 解析連接埠: ''{0}''
debug.error.server.name.is.empty=<i><b>$_SERVER["SERVER_NAME"]</i></b> 為空，這可能是 Web 伺服器組態錯誤所致。<br/><br/><i>Nginx:</i> 將 fastcgi 參數新增至 nginx 組態，<a href="http://wiki.nginx.org/PHPFcgiExample">更多</a><br/><i>Apache:</i> 為當前 VirtualHost 組態 ServerName，<a href="https://httpd.apache.org/docs/2.4/vhosts/name-based.html">更多</a>
debug.error.title.cannot.accept.external.0.connection=無法接受外部 {0} 連線
debug.error.unknown.debugger.id=未檢測到偵錯器擴展
debug.error.wrong.debugger.id=不支持 {0}
debug.expression.evaluation.fail=由於返回值未知，無法對表達式求值
debug.file.is.ignored=檔案 ''{0}'' 被跳過。
debug.function.was.added.to.skip.list=''{0}'' 已新增到跳過列表。
debug.ignore.connection=忽略
debug.incoming.connection.title.0=來自 {0} 的傳入連線
debug.label.file.path.in.project=專案中的檔案路徑:
debug.label.file.path.on.server=伺服器上的檔案路徑:
debug.label.max.simultaneous.connections=最大同時連線數:
debug.label.select.a.project.or.a.file.to.debug=選擇一個專案或檔案進行偵錯
debug.label.select.a.project.to.debug=選擇一個專案進行偵錯
debug.log.cant.register.breakpoint.no.remote=無法註冊中斷點。沒有本地路徑 ''{0}'' 的路徑映射
debug.log.cant.register.breakpoint.no.template.mapping=無法註冊中斷點。沒有到 PHP 行 ''{0}'' 的映射
debug.log.connection.was.terminated=偵錯連線在 ''{0}'':''{1}'' 上意外終止
debug.log.exception.break=異常中斷: {0} ({1})
debug.log.invalid.xdebug.message=由於 Xdebug 訊息無效，無法在中斷點處停止。\\n要解決此問題，請切換到穩定版本的 Xdebug 或使用 'xdebug.remote_log' 選項收集日誌並建立錯誤報告。 
debug.log.path.mapping.remote.extracted=遠端: ''{0}'' <-> 提取: ''{1}''
debug.log.path.mapping.remote.local=遠端: ''{0}'' <-> 本地: ''{1}''
debug.log.stack.frame=框架: {0}:{1}，{2}
debug.log.stop=停止於 (''{0}'':{1})
debug.mapping.resolve.dialog.stop.debugger=停止偵錯器
debug.not.installed=<未安裝>
debug.output=輸出
debug.path.on.server=伺服器上的絕對路徑
debug.php.breakpoint.failed.to.register=無法註冊中斷點，請嘗試將其停用並重新啟用。
debug.php.exception.breakpoint.dialog.title=新增異常中斷點
debug.php.exception.breakpoint.exception.name=異常名稱:
debug.php.exception.breakpoint.not.supported=載入的偵錯擴展不支持異常中斷點
debug.php.exception.breakpoint.title=PHP 異常中斷點
debug.php.exception.breakpoint.zend.not.supported=Zend Debugger 不支持異常中斷點
debug.php.external.connection.finished.break.at.first.line=<b><i>'在第一行中斷'</i></b> 選項已啟用
debug.php.external.connection.finished.break.at.first.line.title=PHP 偵錯組態
debug.php.external.connection.finished.warning=這可能是由於路徑映射組態錯誤或本地和遠端專案未同步。<br/><br/>要找出問題，請在 <b><i><a href="servers">PHP|伺服器</a></i></b>下檢查 ''{0}'' 伺服器的路徑映射組態，或啟用 <b><i><a href="break">''在 PHP 腳本中的第一行中斷''</a></i></b> 選項(位於<i>執行</i>選單下)。<br/><a href="ignore">不再顯示</a>
debug.php.external.connection.finished.warning.title=偵錯會話已完成且未暫停
debug.php.line.breakpoint.title=PHP 行中斷點
debug.php.method.breakpoint.dialog.title=新增方法中斷點
debug.php.method.breakpoint.title=PHP 方法中斷點
debug.php.method.breakpoint.zend.not.supported=Zend Debugger 不支持方法中斷點
debug.port.is.updated=設定中指定的連接埠 {0} 正在使用中。連接埠 {1} 可用，可由 Xdebug 使用。請使用 {2} 更新 php.ini
debug.port.is.updated.descr=設定中指定的連接埠 {0} 正在使用中。連接埠 {1} 可用，可由 Xdebug 使用。
debug.ports.is.updated=設定中指定的所有連接埠都在使用中。連接埠 {0} 可用，可由 Xdebug 使用。請使用 {1} 更新 php.ini
debug.process.cannot.find.file=在本地找不到檔案 ''{0}''。\\n要修復，請通過環境變數 PHP_IDE_CONFIG 設定伺服器名稱，然後重啟偵錯會話。
debug.process.cannot.find.file.in.project=在專案中找不到路徑為 ''{0}'' 的檔案
debug.process.cannot.find.file.link=更多資訊
debug.process.cannot.find.local.file=在伺服器 {0} 上找不到檔案的本地副本\\n本地路徑為 {1}
debug.process.cannot.find.path.mapping=遠端檔案路徑 ''{0}'' 未映射到專案中的任何檔案路徑
debug.process.cannot.find.remote.copy.local.file=專案 ''{0}'' 中的檔案路徑未映射到伺服器上的任何檔案路徑
debug.process.cannot.find.server.name=找不到源位置。名稱為 ''{0}'' 的伺服器不存在。
debug.process.cant.compute.source.position=無法計算源位置。腳本 ''{0}'' 未與任何文本檔案類型關聯。
debug.process.console.error.format={0}: {1}，{2} 中的第 {3} 行\\n
debug.process.script.outside.project=腳本 ''{0}'' 在專案外部。
debug.process.smart.step.into.function.evaluation.error=無法對目標函式求值。將執行“單步跳入”。
debug.process.smart.step.into.function.was.not.executed=尚未呼叫所選函式。
debug.process.smart.step.into.popup=步入函式
debug.process.status.connected=已連線
debug.process.status.disconnected=已斷開連線
debug.process.status.wait=正在等待與{0} ''{1}'' 的傳入連線
debug.resolve.mapping.problem=解決路徑映射問題
debug.rest.client.error.cannot.evaluate.server.name=無法評估 '$_SERVER['SERVER_NAME']'。請確保為您的 Web 伺服器組態了正確的伺服器名稱。<br>點擊此<a href="help">連結</a>獲取更多資訊。
debug.rest.client.error.cannot.evaluate.server.name.title=無法通過伺服器名稱找到對應的“PHP|伺服器”
debug.server.can.not.detect.path.mappings.from.deployment=無法評估路徑映射: 未選擇目標部署伺服器
debug.server.detect.path.mappings.from.deployment=正在檢測現有路徑映射…
debug.server.detect.path.mappings.from.deployment.progress=正在為 ''{0}'' 專案分析路徑映射
debug.server.import.configuration.deployment=部署(&D):
debug.server.import.configuration.dialog.title=從部署組態匯入
debug.server.import.configuration.local=本地(&L)
debug.server.import.configuration.local.file.path=本地檔案路徑:
debug.server.import.configuration.mounted=已掛載(&M)
debug.server.import.configuration.path.to.remote.root=部署根的絕對路徑(&R):
debug.server.import.configuration.path.to.remote.root.mounted=本地: ''{0}'' -> 遠端: ''{1}''
debug.server.import.configuration.path.to.remote.root.mounted.label=已掛載目錄的遠端路徑(&R):
debug.server.import.configuration.path.to.remote.root.mounted.tooltip=遠端檔案的絕對路徑:<br>"已掛載目錄的遠端路徑" . "伺服器上的相對部署路徑" (來自部署路徑映射)
debug.server.import.configuration.path.to.remote.root.sftp=絕對遠端根: ''{0}''
debug.server.import.configuration.path.to.remote.root.sftp.tooltip=遠端檔案的絕對路徑:<br>"遠端根的絕對路徑" . "根路徑" (來自部署設定) . "伺服器上的相對部署路徑" (來自部署路徑映射)
debug.server.import.configuration.preview.border.title=預覽
debug.server.import.configuration.project=專案(&P):
debug.server.import.from.deployment.deployment.configurations.message=找到具有相關路徑映射的部署組態。
debug.server.import.from.deployment.deployment.root.label=部署根(&R):
debug.server.import.from.deployment.no.deployment.configurations.message=找不到合適的部署組態
debug.server.import.from.deployment.no.deployment.configurations.tooltip=組態部署根(如果不為空)
debug.server.import.from.deployment.radio=從部署匯入映射(&I)
debug.server.manually.select.file.message=選擇一個專案或檔案進行偵錯
debug.server.manually.select.file.or.project=手動選擇本地檔案或專案(&M)
debug.server.select.file.mapping=組態本地檔案路徑
debug.settings.auto.detect.ide.host=自動檢測 IDE IP:
debug.settings.broadcasting.port=設定廣播連接埠:
debug.start.listen.debug.connections=開始偵聽 PHP 偵錯連線
debug.stop.listen.debug.connections=停止偵聽 PHP 偵錯連線
debug.type.float=浮點
debug.type.int=int
debug.type.resource=資源
debug.xdebug=Xdebug
debug.xdebug.error.unsupported.protocol.version=不支持的 Xdebug 協議版本
debug.zend.cannot.accept.incoming.connection=無法接受來自 Zend Debugger 的傳入連線
debug.zend.debugger=Zend 偵錯器
debug.zend.debugger.settings.broadcasting=Zend Debugger 設定廣播
debug.zend.error.title.cannot.accept.external.xdebug.connection=無法接受外部 Xdebug 連線
debug.zend.required.protocol.version.0.or.higher=所需協議版本為 ''{0}'' 或更高版本
debugger.method=方法
declaration.in.parent.class.is.incompatible.with.interface=父類別中的宣告與接口不相容
declaration.must.be.compatible.with.0=宣告必須與 {0} 相容
declaration.must.be.compatible.with.super=宣告必須與父級相容
default=預設:
default.value=預設值
delete.assignment=刪除指派
delete.case=刪除 'case'
delete.catch.statement=刪除 'catch' 語句
delete.elseif=刪除 'elseif'
delete.if=刪除 'if'
delete.redundant.method.override=移除方法
delete.redundant.switch.branch=刪除冗餘 'switch' 分支
delete.unused.element=刪除未使用的元素
delete.void.return.type=刪除 'void' 返回值類型
deprecated.form.of.callables=已棄用的可調用對象形式
design.rules=設計規則
diagnosing=正在診斷
dialog.error.title.php.extract.class=PHP 提取類別
dialog.message.cannot.create.file.because.project.already.disposed=由於專案已被處置，無法建立檔案
dialog.message.could.not.find.network.interface=找不到 {0} 網絡接口
dialog.message.do.you.want.to.upload.content.scratch.file.to.3v4l.org.make.it.public=是否要將臨時檔案的內容上傳到 3v4l.org 並將其公開?
dialog.message.docker.account.not.found=找不到 Docker 帳戶
dialog.message.docker.account.not.specified=未指定 Docker 帳戶
dialog.message.execution.quality.tools.in.untrusted.project.prohibited=禁止在不受信任的專案中執行品質工具
dialog.message.no.interface.addresses.for.network.interface=沒有 {0} 網絡接口的接口地址
dialog.message.port.cannot.be.negative.number=端口號不能為負
dialog.message.query.string.cannot.start.with=查詢字串不能以 '?' 開頭
dialog.message.server.host.cannot.be.empty=伺服器主機不能為空
dialog.message.unable.to.create.configurations.with.same.executable.path=無法使用相同的可執行檔案路徑建立組態:  {0}
dialog.title.configure.code.patterns=組態程式碼模式…
dialog.title.edit.phpunit.test.pattern=編輯 PHPUnit 測試模式
dialog.title.enter.tag.name=輸入標記名稱
dialog.title.inline.variable=內聯變數
dialog.title.select.methods.to.propagate.safe.delete=選擇要傳播安全刪除的方法
dialog.title.select.parameters.to.propagate.safe.delete=選擇要傳播安全刪除的參數
dialog.title.select.properties.to.initialize=選擇要初始化的屬性
difference.to.greenwich.time.gmt.with.colon.between.hours.and.minutes=與格林威治時間(GMT)的差值，小時和分鐘之間有冒號(+02:00)
difference.to.greenwich.time.gmt.without.colon.between.hours.and.minutes=與格林威治時間(GMT)的差值，小時和分鐘之間沒有冒號(+0200)
directories=目錄
display.name.directory.0=目錄 ''{0}''
do.not.ask.again=不再詢問
do.not.override=不覆寫
docker.compose.border.title.lifecycle=生命周期
docker.compose.coverage.file.failed.to.copy=無法從 Docker 容器複製覆蓋率結果
docker.compose.coverage.file.failed.to.extract=無法提取覆蓋率結果
docker.compose.coverage.file.is.not.found=找不到覆蓋率檔案
docker.compose.failed.to.start.container=啟動 docker-compose 服務失敗，請在命令行中啟動並重試
docker.compose.radio.button.always.start.a.new.container.docker.compose.run=始終啟動一個新容器('Docker-compose run')
docker.compose.radio.button.connect.to.existing.container.docker.compose.exec=連線到現有容器('Docker-compose exec')
docker.host.name.error=主機名與 <i>host.docker.internal</i> 不同
docker.host.name.error.descr=<i>host.docker.internal</i> 解析為主機使用的內部 IP 地址
download.validation.script=下載 Xdebug 驗證腳本
duplicate.value.in.enum.for.cases.0.and.1=case ''{0}'' 和 ''{1}'' 的枚舉中的重複值
duplicate.variable.0=重複的變數 ''{0}''
dynamically.declared.field=動態宣告的欄位
edit.custom.format.function=編輯自定義格式函式
edit.template=編輯模板
empty.extends.list=空 extends 列表
empty.implements.list=空實作列表
empty.pattern=空模式
empty.type=空類型
enable=啟用
enable.navigate.links.for.class.and.member.references=為類別和成員參照啟用“… 導覽”連結
enable.return.function.value.debugging.xdebug.3.2=啟用返回函式值偵錯 (Xdebug 3.2+)
enable.support=啟用支援
enable.the.following.extension=在 PHP 執行時選項中啟用以下擴展存根:
enable.tostring.object.view=啟用 '__toString' 物件檢視
enables.inspection.0=啟用檢查 ''{0}''
english.ordinal.suffix.for.the.day.of.the.month.2.characters=月中幾號的英語序數後綴，2 個字元(st、nd、rd、th)
enter.annotation=輸入註解
entry.points=入口點
entry.points.tab=入口點
enum=枚舉
enum.backing.type.must.be.int.or.string=枚舉支援類型必須為 'int' 或 'string'
enum.backing.type.must.be.int.or.string.0.given=在給出 ''{0}'' 的情況下，枚舉支援類型必須為 ''int'' 或 ''string''
enum.case=枚舉 case
enum.case.should.be.located.only.inside.enum.classes=枚舉 case 只應位於枚舉類別內部
enum.case.type.0.does.not.match.enum.backing.type.1=枚舉 case 類型 ''{0}'' 與枚舉支援類型 ''{1}'' 不符合
enum.case.value.must.be.constant=枚舉 case 值必須為常數
enum.may.not.include.0=枚舉不得包含 ''{0}''
enum.may.not.include.extend=枚舉不得擴展其他類別
enum.properties.are.immutable=枚舉屬性不可變
enum.value.cannot.referer.to.enum.cases=枚舉值不能參照枚舉 case
enums.may.not.be.cloned=不得克隆枚舉
enums.may.not.implement.the.serializable.interface=枚舉可能不會實作 'Serializable' 接口
enums.may.not.include.properties=枚舉不得包含屬性
error.cannot.connect.to.0=無法連線到 ''{0}''
error.cannot.connect.to.0.1=無法連線到 ''{0}'': {1}
error.cant.create.edge=無法建立關係連結
error.during.access.to.3v4l.org=存取 3v4l.org 時出錯
error.file.unable.create.selected.directory=無法在所選目錄中建立檔案 {0}
error.template.unable.create.from.internal.template=無法從內部模板 {0} 建立檔案
error.template.unable.parse.internal.template=無法解析內部模板 {0}
exception.analysis.settings.path=PHP/分析
exception.class=異常類別
exclude.0.from.1.analysis.a=從{1}分析中排除{0}。
executable.0.was.not.found.in.path.please.make.sure.it.s.there.possible.solutions=在 %PATH% 中找不到可執行檔案 ''{0}''。請確保已指定有效路徑。可能的解決方案:
executable.0.was.not.found.in.path.please.make.sure.it.s.there.possible.solutions1=在 $PATH 中找不到可執行檔案 ''{0}''。請確保已指定有效路徑。可能的解決方案:
execution.result.is.null=執行結果為 null
execution.statistics=執行統計
expected.class.reference=應為: 類別參照
expected.expression=應為: 表達式
expected.expression.after.spread.operator=應為: 展開運算符後的表達式
expected.property=屬性
explore.migration.guides=探索遷移指南
expression=表達式
expression.0=表達式 {0}
expression.is.not.allowed.as.constant.value=表達式不允許作為常量值
expression.is.not.allowed.as.field.default.value=表達式不允許為欄位預設值
expression.is.not.allowed.as.parameter.default.value=表達式不允許為參數預設值
expression.is.not.allowed.as.static.initializer=表達式不允許為 static 初始設定式
expression.is.not.assignable=表達式不可指派
expression1=表達式
expressions=表達式
extends=擴展
extends.implements.overrides=擴展/實作/覆寫
extends.or.implements=擴展或實作
external.formatter.couldnt.run.tool={0} 無法啟動。請檢查您的組態。
external.formatter.phpcbf=PHP Code Beautifier and Fixer
external.formatter.phpcsfixer=PHP CS Fixer
extract.condition=提取條件
extract.method.link.label.more.options=更多選項
extract.method.parameter.name.column.title=參數
extract.method.selector.title=要提取的程式碼
extract.selected.string.part.as.concatenation.operand=將所選字串部分作為串聯動作數提取
extract.selected.string.part.as.format.function.argument=將所選字串部分作為格式函式實參提取
extract.side.effect=提取副作用
failed.to.find.interpreter=無法尋找解釋器
failed.to.find.valid.interpreter.path=無法尋找有效的解釋器路徑
failed.to.parse.php.ini.output.0=無法解析 php --ini 輸出: {0}
failed.to.run.interpreter=無法執行解釋器
field=欄位
field.name=欄位名稱
field.ref.is.deprecated=欄位 '#ref' 已棄用
field.ref.not.found=找不到欄位 '#ref'
field1=欄位
fields.cannot.be.declared.abstract=屬性不能宣告為 abstract
fields.cannot.be.declared.final=屬性不能宣告為 final
fields.default.visibility.panel=屬性預設可見性
fields.default.visibility.private=private
fields.default.visibility.protected=protected
fields.default.visibility.public=public
file=檔案
file.0.does.not.exist=檔案 {0} 不存在
file.0.does.not.exists=檔案 {0} 不存在
files.in.the.directory.should.be.accessible.by.0.request=目錄中的檔案應當可通過 {0} 請求進行存取。
files.in.the.remote.directory.should.be.accessible.by.0.request=遠端目錄中的檔案應當可通過 {0} 請求進行存取。
filetype.composer.log.description=Composer 日誌
filetype.doctrine.query.description=Doctrine 查詢語言
filetype.phar.description=Php Phar
filetype.phar.display.name=Php Phar
filetype.php.description=PHP
filetype.profiler.snapshot.description=分析器快照
final=final
final.class.cant.be.inherited=類別 {0} 為 final
final.modifier.is.not.allowed.here=此處不允許使用 'final' 修飾符
find.cause=尋找原因
find.classes.without.member=尋找沒有成員的類別
find.exception.cause.table.title=異常原因
find.field.accessors.text=是否要搜尋 ''{0}'' 的存取器?
find.field.accessors.title=搜尋存取器
find.options.include.child.methods.checkbox=包括覆寫/實作方法(&V)
find.usages.button.base.method=基方法
find.usages.button.current.method=當前方法
find.usages.prompt.dialog.implements=類別 ''{1}'' 的方法 ''{0}()'' 在 ''{2}'' 中實作了{3,choice,0#方法|1#方法}\\n是否要尋找基{3,choice,0#方法|1#方法}的用法?
find.usages.prompt.dialog.overrides=類別 ''{1}'' 的方法 ''{0}()'' 在 ''{2}'' 中重寫了{3,choice,0#方法|1#方法}\\n是否要尋找基{3,choice,0#方法|1#方法}的用法?
fix.not.available=修復不可用
fix.package.text=將命名空間 ''{0}'' 取代為 ''{1}''
fix.package.text.family=修復命名空間 
flip.key.value.intention.family.name=翻轉鍵和值
flip.key.value.intention.message.all.in.array=翻轉陣列中的所有鍵和值
flip.key.value.intention.message.single=翻轉鍵和值
fluent.setters=Fluent setter
folding.checkbox.collapse.classes=類別主體
folding.checkbox.collapse.function.body=函式體
folding.checkbox.collapse.heredocs.and.nowdocs=HEREDOC\\\\NOWDOC
folding.checkbox.collapse.imports=Import
folding.checkbox.collapse.method.body=方法體
folding.checkbox.collapse.php.tags=標記
follow.this.0.for.more.information.about.deployment=有關部署的詳細資訊，請參閱此{0}。
follow.this.0.for.more.information.about.path.mappings=有關路徑映射的詳細資訊，請參閱{0}。
follow.this.links.to.install.and.configure.0.or.1=點擊這些連結以安裝並組態 {0} 或 {1}。
for=for
foreach=foreach
found.roots.configured=檢測到並組態了 PSR-0 根
framework.composer=Composer
framework.composer.0.1.version.2={0} {1}，版本 {2}
framework.composer.add.composer.dependency.title=管理 Composer 相依項
framework.composer.add.dependency.available.packages.label=可用軟體套件
framework.composer.add.dependency.close.button=關閉(&C)
framework.composer.add.dependency.hide.tooltip=隱藏
framework.composer.add.dependency.install.button=安裝
framework.composer.add.dependency.no.new.version.found.for.0=找不到 {0} 的新版本。
framework.composer.add.dependency.no.package.selected=未選擇軟體套件
framework.composer.add.dependency.no.such.package=packagist 上無此類別軟體套件
framework.composer.add.dependency.no.version.selected=未選擇版本
framework.composer.add.dependency.running=正在執行
framework.composer.add.dependency.settings.cl.dialog.title=參數
framework.composer.add.dependency.settings.cl.label=命令行參數(&P):
framework.composer.add.dependency.settings.interpreter.label=PHP 解釋器:
framework.composer.add.dependency.settings.title=設定(&S)
framework.composer.add.dependency.show.output=顯示輸出
framework.composer.add.dependency.successfully.installed.0.version.1=已成功安裝 {0}，版本 {1}。
framework.composer.add.dependency.successfully.removed.0=已成功移除 {0}。
framework.composer.add.dependency.successfully.updated.0=已成功更新 {0}。
framework.composer.add.dependency.task.title=新增相依項
framework.composer.add.dependency.update.button=更新
framework.composer.available.version=可用版本:
framework.composer.checking.for.update=正在檢查更新…
framework.composer.configurable.title=Composer
framework.composer.create.project.from=自以下建立專案
framework.composer.create.project.progress.title=建立專案
framework.composer.default.composer.interpreter.name=Composer 的解釋器
framework.composer.default.interpreter.for.this.project.is.remote=此專案的預設解釋器是遠端解釋器，無法使用。
framework.composer.default.interpreter.is.not.configured=尚未為此專案組態預設解釋器。
framework.composer.default.project.interpreter=預設專案解釋器
framework.composer.empty.package.name.in.0={0} 中的軟體套件名稱為空
framework.composer.empty.path.to.0={0} 的路徑為空
framework.composer.expected.name.0.versions.0.description.got.1=應為 <name> {0} <versions> {0} <description>，獲得的是 {1}
framework.composer.failed.check.for.update=無法執行 'update --dry-run' 指令。
framework.composer.failed.to.0=無法{0}。
framework.composer.failed.to.0.1.script.was.cancelled=無法{0} {1}。腳本已被取消。
framework.composer.failed.to.download.composer.phar=無法下載 composer-stable.phar
framework.composer.failed.to.load.package.names=無法載入軟體套件名稱。
framework.composer.failed.to.parse.package.description=無法解析軟體套件描述。
framework.composer.failed.to.parse.package.names=無法解析軟體套件名稱。
framework.composer.file.0.is.not.found=找不到檔案 ''{0}''。
framework.composer.file.0.set.as.composer.config.change.setting.a.href.here.a=檔案 ''{0}'' 設定為 Composer 組態。
framework.composer.init.dialog.title.composer.settings=Composer 設定
framework.composer.initialize.popup=找到了 Composer 組態檔案 {0}。專案設定與其同步。
framework.composer.initialize.popup.multi.composer=找到 {0} 個 composer 組態檔案。專案設定已與其同步。
framework.composer.install.action.name=安裝
framework.composer.install.task.title=正在安裝軟體套件
framework.composer.interpreters.combo.default.interpreter=< 預設解釋器 >
framework.composer.interpreters.combo.default.interpreter.no.php.path=預設解釋器未提供 PHP 路徑
framework.composer.interpreters.combo.default.project.interpreter=< 預設專案解釋器 >
framework.composer.interpreters.combo.no.default.interpreter=預設設定中沒有預設解釋器
framework.composer.interpreters.combo.no.default.interpreter.in.project=此專案中沒有預設解釋器
framework.composer.label.installed.version=已安裝的版本:
framework.composer.label.version.to.install=要安裝的版本(&V):
framework.composer.load.update.availability=檢查可用軟體套件更新
framework.composer.loading.package.description=正在載入軟體套件描述
framework.composer.loading.packages=正在載入 Composer 軟體套件
framework.composer.loading.update.availability=正在檢查 Composer 軟體套件更新
framework.composer.name.composer=Composer
framework.composer.no.description.available=無可用描述。
framework.composer.no.package.versions.in.0={0} 中沒有軟體套件版本
framework.composer.notification.title.init.composer=初始化 Composer
framework.composer.notify.about.missing.vendor=缺少 'vendor' 目錄時通知
framework.composer.package.default.version=<預設>
framework.composer.package.version.available.0={0}的更新
framework.composer.packages.were.added.0.excluded.folders.popup=Composer 軟體套件已被新增到排除的目錄中。
framework.composer.packages.were.added.0.php.include.paths.popup=Composer 軟體套件已被新增到 PHP include 路徑中。
framework.composer.packages.were.changed.0.excluded.folders.popup=Composer 軟體套件已更改，因此更新了排除的目錄。
framework.composer.packages.were.changed.0.php.include.paths.popup=Composer 軟體套件已更改，因此更新了 PHP include 路徑。
framework.composer.packages.were.changed.0.test.config.popup={0} 組態已根據 composer.json 更新
framework.composer.packages.were.changed.0.test.config.title=Composer 軟體套件已被更改
framework.composer.packages.were.moved.to.0.php.include.paths.popup=Composer 軟體套件已從 Composer 外部庫移至 PHP include 路徑。
framework.composer.packages.were.removed.0.excluded.folders.popup=Composer 軟體套件已從排除的目錄中移除。
framework.composer.packages.were.removed.0.php.include.paths.popup=Composer 軟體套件已從 PHP include 路徑中移除。
framework.composer.path.dialog.path.to.composer=Composer 路徑
framework.composer.path.dialog.path.to.composer.json=composer.json 路徑
framework.composer.path.dialog.specify.composer.executable=指定 Composer 可執行檔案:
framework.composer.path.dialog.specify.composer.json=指定 composer.json:
framework.composer.path.dialog.specify.composer.phar=指定 Composer phar:
framework.composer.path.form.empty.path.to.composer.executable=Composer 可執行檔案路徑為空
framework.composer.path.form.empty.path.to.composer.json=composer.json 路徑為空
framework.composer.path.form.empty.path.to.composer.phar=composer.phar 路徑為空
framework.composer.path.form.execution.validation.wrapper=<html>執行未設定。<br/>{0}</html>
framework.composer.path.to.php.executable.titled=PHP 可執行檔案的路徑
framework.composer.path.validation.0.is.a.directory={0} 是目錄
framework.composer.project.generation.error.title=無法建立 Composer 專案
framework.composer.project.generator.description=通過 Composer 指令建立專案。
framework.composer.project.generator.failed.to.copy.temp.directory.0.content.to.project.root=無法將臨時目錄 ''{0}'' 內容複製到專案根目錄
framework.composer.project.generator.name=Composer 軟體套件專案
framework.composer.project.generator.notification.content.failed.to.find=找不到 {0}
framework.composer.project.generator.notification.content.failed.to.find.composer.json=無法在專案根目錄中找到 composer.json
framework.composer.remove.action.name=移除
framework.composer.removing.package.task.title=移除軟體套件
framework.composer.require.action.name=需要
framework.composer.require.task.title=正在安裝軟體套件 {0}
framework.composer.run.path.to.composer.json=composer.json 路徑:
framework.composer.run.script=腳本:
framework.composer.run.script.missing=未指定 Composer 腳本
framework.composer.script.run.configuration.description=Composer 腳本執行組態
framework.composer.script.run.configuration.name=Composer 腳本
framework.composer.selected.file.is.not.composer.json=所選檔案不是 composer.json
framework.composer.self.update.action.name=自我更新
framework.composer.self.update.task.title=更新 Composer
framework.composer.specify.php.executable.0=指定 PHP 可執行檔案 {0}
framework.composer.update.action.name=更新
framework.composer.update.task.title=正在更新軟體套件
framework.composer.updating.package.task.title=更新軟體套件
framework.composer.vendors.library.name=Composer 供應商
frameworks.composer.could.not.get.package.info=無法獲取軟體套件資訊。
frameworks.composer.could.not.get.packages.info.0=無法獲取軟體套件資訊。{0}
frameworks.settings.none.installed=沒有可用的框架設定提供程序。<br/>考慮安裝 Drupal Support、Joomla! Support 或 WordPress Support 延伸模組。
frameworl.composer.show.quick.actions=顯示具有快速動作的 composer.json 頂部面板
function=函式
function.call=函式呼叫
function.call.is.not.allowed.here=此處不允許使用函式呼叫
function.fqn=函式 FQN
function.has.parameter.with.incompatible.default.value.type=函式有一個預設值與其宣告的類型不相容的參數
function.name.must.be.callable.a.string.closure.or.class.implementing.invoke.currently.0=函式名稱必須可呼叫 - 字串、閉包或實作 ''__invoke'' 的類別，當前為 ''{0}''
function.ref.is.deprecated=函式 '#ref' 已棄用
function2=函式
functions.to.be.extracted=要提取的函式
generating.autoloader=正在生成自動載入器
getters.setters.configure=組態…
getters.setters.getters.first=getter 優先
getters.setters.naming.style=命名樣式:
getters.setters.order=Getter/Setter 順序:
getters.setters.setters.first=setter 優先
getters.setters.style=Getter/Setter 樣式
getting.installed.standards=正在獲取已安裝的標準…
global.code.should.be.enclosed.in.global.namespace.declaration=全域程式碼應包含在全域命名空間宣告中
global.namespace.should.use.braced.syntax=全域命名空間應使用帶大括號的語法
global.this.is.deprecated=不能將 $this 用作全域變數，它已在 PHP 7.1 中棄用
global.variable.from.globals.array.assignment=來自 $GLOBALS 陣列指派的全域變數
globals.can.only.be.modified.using.the.globals.name.value.syntax='$GLOBALS' 只能使用 '$GLOBALS[$name] = $value' 語法進行修改
group.ComposerGroup.text=Composer
group.ComposerToolsGroup.text=Composer
group.DBGPProxyGroup.text=DBGp 代理
group.PHPQualityToolsAddToIgnoredList.text=新增到忽略列表…
group.PhpNewTestGroup.text=PHP 測試
group.advanced.settings.php=PHP
group.methods.by.type=按類型對方法分組
group.use.statements.by.selected.prefix=按所選前綴將 'use' 語句分組
guality.tool.configuration.show.ignored.files=顯示忽略的檔案
gutter.overriden.select.implementation.title=選擇 {0} 的實作
gutter.overriden.select.subclass.title=選擇 {0} 的子類別
gutter.overriding.select.title=選擇要導覽的父方法
gutter.pin.overriden.select.implementation.title={0} 的實作
gutter.pin.overriden.select.subclass.title={0} 的實作
gutter.pin.overriding.select.title={0} 的父項
guzzle.http.request.gutter.name=Guzzle HTTP 請求
guzzle.invalid.http.request.file=檔案 ''{0}'' 是無效的 HTTP 請求檔案
guzzle.name=Guzzle
guzzle.open.http.request=在 HTTP 請求編輯器中開啟
guzzle.unable.to.add.new.request.to.file=無法向 ''{0}'' 檔案新增新請求
guzzle.unable.to.extract.request.parameters=無法提取請求參數
halt.compiler.can.only.be.used.from.the.outermost.scope=僅可從最外側作用域使用 '__halt_compiler()'
handler.with.the.same.session.id.is.already.registered=已註冊使用相同會話 ID 的處理程序
hint.evaluation.fully.contains=求值結果完全覆蓋 ''{0}'' 的可能結果
hint.evaluation.makes.array.always.empty=求值使得陣列始終為空
hint.evaluation.makes.subsequent.condition.always.true=求值使後續條件始終為 '{0,choice,0#false|1#true}'
hint.text.can.not.find.target.class.for.modification=找不到要修改的目標類別。
hint.text.element.doesn.t.have.fqn=元素沒有 FQN
hint.text.installed.version=已安裝的版本
hint.text.target.class.does.not.belong.to.project.can.not.be.modified=目標類別 {0} 不屬於該專案\\n並且無法修改。
hint.text.target.class.not.writable=目標類別 {0} 不可寫。
hint.text.use.statement.choice.s.removed={0} ''use'' 語句{1, choice, 0#|1#}已移除
hint.text.use.statements.checked.nothing.was.removed=已檢查 {0} ''use'' 語句，未移除任何內容
host.name.eg.localhost.example.com=主機名。例如，localhost.example.com
how.to.fix=修正方法
html.note.core.extensions.are.part.of.the.php.core.and.cannot.be.left.out.of.a.php.binary.with.compilation.options.html=<html>註: 核心擴展是 PHP 核心的一部分，不能放在包含編譯選項的 PHP 二進制檔案外部。</html>
http.client.request.init.debug.connection.title=正在初始化偵錯連線
identifier=關鍵字
if.with.common.parts=具有通用部分的 'if'
if.you.have.already.configured.debug.extension.in.php.ini.file.check.possible.reasons.why.it.was.not.loaded=如果已在 php.ini 檔案中組態偵錯擴展，請檢查未載入該擴展的可能原因:
if.you.ve.changed.the.path.recently.restart.the.ide=如果最近更改了 %PATH%，請重啟 IDE。
if.you.ve.changed.the.path.recently.restart.the.ide1=如果最近更改了 $PATH，請重啟 IDE。
ignore.imports.and.formatting=忽略匯入和格式設定
implement.method=實作方法
import=匯入
import.from.deployment.configuration=從部署組態匯入
import.references.on.paste.dialog.message=<html>貼上的程式碼段使用 {0}，後者在目標作用域中不能通過匯入存取。<br/>選擇您想要匯入到作用域中的{0}。</html>
import.references.on.paste.dialog.title=選擇要匯入的{0}
in=位於
in.0=\\ ({0} 中)
include.eol.slow=包括 eol (慢)
include.path=Include 路徑
include.path.column.info=路徑
incorrect.null.safe.operator=錯誤的 nullsafe 運算符
info=資訊
information=資訊
init.cache=初始化快取
initialize.var.quick.fix.family.name=使用值初始化
initializer=初始設定式
inject.language.using.phpdoc=使用 PHPDoc 注入語言
inlay.hints.usages.text={0,choice, 0#無用法|1#1 個用法|2#{0,number} 個用法}
insert.default.branch=插入 'default' 分支
inspection.array.access.can.be.replaced.with.foreach.value=陣列存取可被取代為 'foreach' 值
inspection.array.modification.will.not.have.any.effect=按值修改從函式返回的陣列不會有任何影響
inspection.array.to.string.conversion=陣列到字串的轉換
inspection.arrayfill.can.be.converted.to.loop='array_fill()' 呼叫可以轉換為迴圈
inspection.arrayfilter.can.be.converted.to.loop='array_filter()' 呼叫可以轉換為迴圈
inspection.arraymap.can.be.converted.to.loop='array_map()' 呼叫可以轉換為迴圈
inspection.assignment.in.condition=條件中的指派
inspection.assignment.in.condition.move.assignment.out.of.condition.fix.name=從條件中移出指派
inspection.assignment.replaceable.with=<code>#ref</code> 可被取代為 ''{0}'' #loc
inspection.closure.can.be.converted.to.arrow.function=閉包可以轉換為箭頭函式
inspection.closure.can.be.converted.to.first.class.callable='Closure::fromCallable()' 可以轉換為一級可調用語法
inspection.code.patterns.panel.description.label=如果 fqn 名稱符合，則將程式碼標記為入口點
inspection.code.patterns.panel.description.text=將方法留空以表示建構函式 \\n任何 * 都將與 fqn 名稱中的一個或多個字元符合
inspection.code.patterns.panel.errors.class=模式必須是有效的 php fqn，僅接受 '*' 作為佔位符
inspection.code.patterns.panel.errors.member=方法模式 {0} 必須是有效的 php 關鍵字，僅接受 ''*'' 作為佔位符
inspection.codeSmell.class.call.is.not.casesensitive=類別用法中的大小寫與宣告中的大小寫不符合
inspection.codeSmell.function.call.is.not.casesensitive=函式/方法呼叫中的大小寫與宣告中的大小寫不符合
inspection.codeSmell.namespace.reference.is.not.casesensitive=命名空間參照中的大小寫與宣告中的大小寫不符合
inspection.codeSmell.overriding.method.visibility.description=方法可見性不應被覆寫
inspection.composer.file.reference.problem=路徑 ''{0}'' 未找到
inspection.composer.json.file.references.inspection.display.name=未解析的檔案參照
inspection.constructor.style=舊式建構函式
inspection.curly.braces.access.syntax.usage=大括號存取語法自 PHP 7.4 已棄用
inspection.dead.code.problem.class.abstract.several.implementations={0} 具有{1, choice, 1#直接或間接實作|2# {1,number} 個直接或間接實作}，但<ul><li>其從未實例化或</li><li>不存在可從入口點到達的實例化。</li></ul>
inspection.dead.code.problem.class.nousages.synopsis=類別從未使用。
inspection.dead.code.problem.empty.constant.synopsis=常數從未使用。
inspection.dead.code.problem.empty.function.synopsis=函式從未使用。
inspection.dead.code.problem.multiple.constant.synopsis=常數有 {0, choice, 1#1 個用法|2#{0,number} 個用法}，但無法從入口點到達。
inspection.dead.code.problem.recursive.suspicious.function.synopsis=所有函式用法均屬於不存在可從入口點到達的成員的呼叫鏈。
inspection.dead.code.problem.single.constant.synopsis=常數有一個用法，但無法到達。
inspection.dead.code.problem.suspicious.function.synopsis=函式無法從入口點到達。
inspection.dead.code.problem.trait.additional.reachable=特徵具有可到達用法。
inspection.dead.code.problem.trait.additional.unreachable=特徵沒有可到達用法。
inspection.dead.code.problem.trait.synopsis=特徵從未使用。
inspection.deprecated.cast={0} 轉換自 PHP {1} 已棄用
inspection.deprecated.implode.usage=帶實參(陣列，字串)呼叫的 {0} 自 PHP 7.4 已棄用
inspection.disabled.quality.tool.inspection={0} 檢查已停用
inspection.disabled.quality.tool.inspection.fix=啟用檢查
inspection.disabled.quality.tool.inspection.open.fix=開啟檢查設定
inspection.division.by.zero=除以零
inspection.doc.field.type.mismatch=屬性類型不符合
inspection.doc.missing.return.tag.problem=函式/方法 PHPDoc 註釋中缺少 @return 標記
inspection.doc.throws.option.skip.on.empty.phpdoc=忽略沒有 @param/@return 的 PHPDoc
inspection.doc.throws.problem=PHPDoc 註釋不包含所有必需的 @throws 標記
inspection.duplicate.array.keys.display.name=重複的陣列鍵
inspection.duplicate.array.keys.problem=重複的陣列鍵
inspection.duplicate.array.keys.problem.0=值為 ''{0}'' 的重複陣列鍵
inspection.duplicate.match.arm.body=''match'' arm 是 ''{0}'' arm 的重複項
inspection.duplicate.match.condition.message=重複條件
inspection.duplicate.phpdoc.type.fix=從標記中移除重複類型
inspection.duplicate.phpdoc.type.problem=重複的類型 ''{0}''
inspection.duplicate.switch.case.body=''switch'' 中的分支是 ''{0}'' 分支的重複項
inspection.dynamic.method.called.as.static.problem=非 static 方法 '#ref' 不應被靜態呼叫
inspection.dynamic.method.called.as.static.problem.magic=非 static 方法 '#ref' 不應被靜態呼叫，但類別具有 '__magic' 方法。
inspection.export.results.back.traces=反向追蹤
inspection.export.results.const=常數
inspection.expression.have.same.operands=表達式有相同動作數
inspection.expression.result.unused.problem=表達式結果未在任何位置使用
inspection.ext.is.specified.in.require.dev.but.used.outside.tests=''{0}'' 在 ''require-dev'' 部分中指定，但在測試外部使用
inspection.ext.is.specified.in.suggest=''{0}'' 在 ''suggest'' 中指定，可能不可用
inspection.family.name.replace.implicit.octal.literal.with.explicit.one=將隱式八進制文字取代為顯式八進制文字
inspection.field.assignment.type.mismatch=類型不相容: 應為 ''{0}'' 類型的屬性，提供的是 ''{1}''
inspection.field.assignment.type.mismatch.multi.resolve=指派的類型 ''{0}'' 與屬性的宣告類型不相容
inspection.field.can.be.promoted=可以提升屬性
inspection.foreach.array.is.used.as.value.problem=變數 ''{0}'' 已被用作 ''array expression''
inspection.format.function.parameters.mismatch.conversion.specification=轉換規範未映射到任何參數
inspection.format.function.parameters.mismatch.parameter=參數未映射到任何轉換規範
inspection.fully.qualified.name.usage=限定符可被取代為匯入
inspection.fully.qualified.name.usage.name.option.ignore.global.namespace=忽略全域命名空間
inspection.fully.qualified.name.usage.option.enable.file.scope=在檔案作用域內啟用
inspection.group=PHP
inspection.group.code.smell=程式碼異味
inspection.group.code.style=程式碼樣式
inspection.group.control.flow=控制流
inspection.group.general=一般
inspection.group.naming.convention=命名約定
inspection.group.php.doc=PHPDoc
inspection.group.probably.bug=可能的錯誤
inspection.group.type.compatibility=類型相容性
inspection.group.undefined=未定義
inspection.group.unused=未使用
inspection.group.unused.quickfix.label=未使用的元素
inspection.group.unused.quickfix.message=未使用的元素: ''{0}''
inspection.hierarchyChecks=類別層次結構檢查
inspection.hierarchyChecks.descr=類別必須被宣告為 abstract 或實作 {0}
inspection.hierarchyChecks.field.type.redeclaration.match.super.type=類型必須為 ''{0}''(如基類別 ''{1}'' 中)
inspection.hierarchyChecks.field.type.redeclaration.must.not.be.defined=類型不得定義(如基類別 ''{0}'' 中)
inspection.hierarchyChecks.should.implement=類別必須實作 {0}
inspection.ignored.class.alias.declaration=忽略了類別名聲明
inspection.illegal.array.key.type.problem=非法陣列鍵類型
inspection.illegal.psr.class.path.class.is.not.matched.to.psr0={0}名稱與包含檔名不符合
inspection.illegal.psr.class.path.namespace.name.is.not.matched.to.psr0=命名空間名稱與 PSR-0/PSR-4 專案結構不符合
inspection.illegal.string.offset.problem=非法字串偏移 {0}
inspection.incompatible.return.type=返回值應為 ''{0}''，返回的是 ''{1}''
inspection.incompatible.return.type.batch=返回值類型與宣告不相容
inspection.incompatible.return.type.strict.type.checking=嚴格類型檢查
inspection.inconsistent.return.points.option.treat.return=在 'void' 函式/方法中以相同方式對待 'return null' 和 'return'
inspection.inconsistent.return.points.problem1=缺少 'return' 語句
inspection.inconsistent.return.points.problem1.yield=缺少 'yield' 語句
inspection.inconsistent.return.points.problem2=缺少返回實參
inspection.invalid.function.result.used.problem=使用了 ''{0}'' {1} ''{2}'' 結果
inspection.invalid.function.result.used.problem.function=函式
inspection.invalid.function.result.used.problem.method=方法
inspection.json.all.not.installed.packages=未安裝軟體套件
inspection.json.duplicated.packages.0=require 和 require-dev 中存在重複的 ''{0}'' 條目
inspection.json.duplicated.packages.fix=從 require-dev 中移除重複項
inspection.json.not.installed.package.update.fix=更新軟體套件
inspection.json.not.installed.packages=未安裝軟體套件
inspection.json.not.installed.packages.install.fix=安裝軟體套件
inspection.json.not.installed.packages.update.fix=更新所有軟體套件
inspection.language.level.quick.fix.switch.language.level.in.composer.0=切換到 composer.json 中的 PHP {0} 語言級別
inspection.language.level.quick.fix.switch.language.level.in.composer.manually.0=手動切換到 composer.json 中的 PHP {0} 語言級別
inspection.language.level.quick.fix.switch.language.level.name.0=切換到 PHP {0} 語言級別
inspection.loop.can.be.converted.to.arrayfill=迴圈可以轉換為 'array_fill()' 呼叫
inspection.loop.can.be.converted.to.arrayfilter=迴圈可以轉換為 'array_filter()' 呼叫
inspection.loop.can.be.converted.to.arraymap=迴圈可以轉換為 'array_map()' 呼叫
inspection.magic.method.visibility.cannot.be.static=魔術方法 ''{0}'' 不能為 static
inspection.magic.method.visibility.must.be.public=魔術方法 ''{0}'' 必須為 public
inspection.magic.method.visibility.must.be.static=魔術方法 ''{0}'' 必須為 static
inspection.mess.detector.validation.inspection.display.name=PHP Mess Detector 驗證
inspection.message.0.extends.class.with.final.tag=''{0}'' 會擴展帶有 @final 標記的類別
inspection.message.0.overrides.method.with.final.tag=''{0}'' 會覆寫帶有 @final 標記的方法
inspection.message.absolute.method.reference.should.be.specified.for.insteadof.trait.use.rule=應為 'insteadof' 特徵 use 規則指定絕對方法參照
inspection.message.always.true=條件始終為 '{0,choice,0#false|1#true}'
inspection.message.always.true.because=條件始終為 ''{0, choice, 0#false|1#true}''，因為此時 ''{1}'' 已經為 ''{2, choice, 0#false|1#true}''
inspection.message.always.true.because.evaluated=條件始終為 ''{0,choice,0#false|1#true}''，因為此時對 ''{1}'' 求值
inspection.message.argument.with.type.deprecated.for.this.call=類型為 ''{0}'' 的實參對此呼叫已棄用
inspection.message.argument.without.name.identifier=無名稱關鍵字的實參
inspection.message.array.always.empty.at.this.point=陣列在此點始終為空
inspection.message.array.index.immediately.rewritten.before.accessing=陣列索引在存取之前會被立即覆蓋
inspection.message.array.key.unused=陣列密鑰未使用
inspection.message.array.push.with.single.element=只有一個元素的 'array_push'
inspection.message.array.to.string.conversion=陣列到字串的轉換
inspection.message.array.traversable.can.be.replaced.with.iterable=類型提示 'array|Traversable' 可被取代為 'iterable'
inspection.message.array.values.call.redundant='array_values' 呼叫冗餘
inspection.message.array.write.access.unused=未使用陣列寫入存取
inspection.message.arrayshape.can.be.added=ArrayShape 可以新增
inspection.message.assert.always.will.be.false=實參類型不相容，因為 'assertTrue()' 執行與 'true' 的嚴格比較
inspection.message.assertion.always.true=斷言始終為 '{0,choice,0#false|1#true}'
inspection.message.assertion.always.true.because=斷言始終為 ''{0, choice, 0#false|1#true}''，因為此時 ''{1}'' 已經為 ''{2, choice, 0#false|1#true}''
inspection.message.assertion.always.true.because.evaluated=斷言始終為 ''{0,choice,0#false|1#true}''，因為此時已評估 ''{1}''
inspection.message.attribute.can.t.be.applied.to.because.it.doest.contains=特性不能應用於 {0}，因為它不包含 ''{1}'' 標誌
inspection.message.attribute.is.not.repeatable=特性不可重複，因為它不包含 'Attribute::IS_REPEATABLE' 標誌
inspection.message.behavior.unparenthesized.expressions.containing.both.will.change.in.php=同時包含 ''.'' 和 ''{0}'' 的無括號表達式可能會產生意外結果
inspection.message.branch.is.unused=從不執行 'switch' 分支
inspection.message.call.chain.too.long.to.analyse.break.it.into.fragments.up.to.calls=呼叫鏈過長，無法進行分析。請將其拆分為最多包含 {0} 個呼叫的片段
inspection.message.call.without.arguments.deprecated=不帶實參的 ''{0}'' 呼叫已棄用
inspection.message.calling.static.trait.member=直接呼叫 static 特徵成員已棄用。只應在使用特徵的類別上訪問。
inspection.message.can.be.final=可以為 'final'
inspection.message.can.be.merged.with=可以與 ''{0}'' 合併
inspection.message.can.be.removed=可以移除 ''{0}''
inspection.message.can.be.replaced.with=可被取代為 ''{0}''
inspection.message.can.be.replaced.with.assert.false=可被取代為 'assertFalse'
inspection.message.can.be.replaced.with.assert.true=可被取代為 'assertTrue'
inspection.message.can.be.replaced.with.const.syntax=可被取代為 'const' 語法
inspection.message.can.be.replaced.with.direct.parameter.access='func_get_arg' 可被取代為直接參數存取
inspection.message.can.be.replaced.with.fail=可被取代為 ''{0}''
inspection.message.can.be.replaced.with.in.array.call=可被取代為 ''{0}'' 呼叫
inspection.message.can.be.replaced.with.match.expression='if' 語句可被取代為 'match' 表達式
inspection.message.can.be.replaced.with.min.max.call=可被取代為 ''{0}'' 呼叫
inspection.message.can.be.replaced.with.named.argument=可被取代為命名實參
inspection.message.can.be.replaced.with.operator=可被取代為 '?->' 運算符
inspection.message.can.be.replaced.with.str.function=可被取代為 ''{0}''
inspection.message.can.be.replaced.with.version=表達式可被取代為 '??' 版本
inspection.message.cannot.assign.empty.string.to.string.offset=無法將空字串分配給字串偏移
inspection.message.cannot.create.references.to.from.string.offsets=無法建立到/從字串偏移的參照
inspection.message.cannot.increment.decrement.string.offsets=無法遞增/遞減字串偏移
inspection.message.cannot.make.method=無法將 {0} 方法設為 {1} {2}
inspection.message.cannot.make.method.visibility.lower.than.super.s=無法將方法的可見性設為低於父級的可見性
inspection.message.cannot.make.non.abstract.method.abstract=無法將非 abstract 方法設為 abstract
inspection.message.cannot.make.non.abstract.method.abstract.1=無法將非 abstract 方法 {0} 設為 abstract
inspection.message.cannot.make.non.static.method.static=無法將非 static 方法 {0} 設為 static
inspection.message.cannot.make.static.method.non.static=無法將 static 方法 {0} 設為非 static
inspection.message.cannot.override.final.method=無法覆寫 final 方法
inspection.message.cannot.override.final.method.1=無法覆寫 final 方法 {0}
inspection.message.cannot.stub.or.mock.using.method.list.that.contains.duplicates=不能使用包含重複項的方法列表進行存根或模擬
inspection.message.cannot.unset.string.offsets=無法取消設定字串偏移
inspection.message.cannot.use.assign.op.operators.with.string.offsets=無法將組合運算符指派與字串偏移一起使用
inspection.message.cannot.use.string.offset.as.array=無法將字串偏移用作陣列
inspection.message.cannot.use.string.offset.as.object=無法將字串偏移用作物件
inspection.message.cast.evaluable=轉換可被取代為 ''{0}''
inspection.message.cast.redundant=類型轉換冗餘
inspection.message.class.can.be.readonly=類別不能為 'readonly'
inspection.message.class.does.not.have.attribute=類別 ''{0}'' 未使用 ''Attribute'' 註解
inspection.message.class.may.inherit.from.final.class=類別可能無法繼承 final 類別
inspection.message.class.ref.marked.as.internal=類別 '#ref' 已標記為 @internal
inspection.message.classes.cannot.be.doubled=''{0}'' 類別無法重複
inspection.message.clone.method.cannot.be.static='Clone' 方法不能為 static
inspection.message.code.fragment.too.complex.to.parse.this.piece.code.will.be.treated.as.plain.text=程式碼段過於複雜，無法解析，因此將作為純文本處理
inspection.message.comment.can.be.replaced.with.named.argument=註釋可被取代為命名實參
inspection.message.comment.will.be.parsed.as.attribute.starting.with.php=從 PHP 8.0 起註釋被解析為特性
inspection.message.concatenation.can.be.merged.with.assignment.empty.string.literal=串聯可以與空字串文字指派合併
inspection.message.condition.is.never.matched=條件從未符合
inspection.message.constant.from.base.class.referenced.via.child.class=通過子類別參照的基類別 ''{0}'' 中的常數
inspection.message.constant.reassignment=常數重新指派
inspection.message.constant.ref.marked.as.internal=常數 '#ref' 已標記為 @internal
inspection.message.constant.ref.not.found=未找到常數 '#ref'
inspection.message.constructor.cannot.be.static=建構函式不能為 static
inspection.message.continue.targeting.switch.equivalent.to.break=針對 'switch' 的 'continue' 相當於 'break'
inspection.message.control.flow.too.big.to.analyze=控制流太大，無法分析
inspection.message.count.used.as.array.index.to.append.element='count' 用作陣列索引以追加元素
inspection.message.dangerous.array.initialization=危險的陣列初始化
inspection.message.data.provider.method.should.be=資料提供程序方法應為 {0}
inspection.message.data.provider.method.should.not.require.arguments=資料提供程序方法不應需要實參
inspection.message.declaration.should.be.compatible.with=宣告應該與 {0} 相容
inspection.message.declaration.should.be.compatible.with.super=宣告應與父級相容
inspection.message.defining.custom.assert.function.deprecated=定義自定義 'assert()' 函式已棄用
inspection.message.defining.custom.assert.function.forbidden=禁止定義自定義 'assert()' 函式
inspection.message.deprecated.autoload.declaration='__autoload()' 宣告已棄用
inspection.message.destructor.cannot.be.static=解構函式不能為 static
inspection.message.doc.tag.without.variable.name.doesn.t.provide.type.information.for.any.expression=沒有變量名稱的 Doc 標記不提供任何表達式的類型資訊
inspection.message.double.quotes.are.unnecessary=雙引號不必要
inspection.message.duplicate.case.expression=重複 case 表達式
inspection.message.duplicate.case.expression.ref=重複 case 表達式: #ref
inspection.message.duplicate.character=重複字元
inspection.message.duplicates.catch.statement=重複 ''{0}'' 語句
inspection.message.element.already.covered.by=''{0}'' 已被 ''{1}'' 覆蓋
inspection.message.enum.field.reference.in.constant.expression.allowed.only.from.php=從 PHP 8.2 起才允許在常數表達式中參照枚舉欄位
inspection.message.exception.immediately.rethrown=立即重新拋出異常
inspection.message.exception.never.thrown.in.corresponding.try.block=相應的 ''try'' 塊中從未拋出異常 ''{0}''
inspection.message.existing.overriding.private.method.may.be.inaccessible=現有的覆寫 private 方法可能無法存取
inspection.message.existing.overriding.private.method.may.be.inaccessible.method=覆寫 private 方法 ''{0}'' 可能無法存取
inspection.message.exitpoint.attribute.can.be.added=可以新增 #[NoReturn] 特性
inspection.message.expression.always.choice=表達式始終為 ''{0}''
inspection.message.expression.have.duplicate.operand=表達式有重複的動作數 {0}
inspection.message.expression.not.changed.after.applying=套用 ''{0}'' 後，表達式不會改變
inspection.message.expression.without.parentheses=表達式沒有括號
inspection.message.extends.class.with.final.tag=擴展帶有 @final 標記的類別
inspection.message.field.assignment.can.be.converted.to.promoted.field=可以提升屬性
inspection.message.field.immediately.rewritten.before.accessing=屬性在存取之前會被立即覆蓋
inspection.message.field.ref.marked.as.internal=欄位 '#ref' 已標記為 @internal
inspection.message.for.loop.can.be.replaced.with.implode='foreach' 迴圈可被取代為 'implode()'
inspection.message.for.loop.can.be.replaced.with.str.repeat='for' 迴圈可被取代為 'str_repeat'
inspection.message.foreach.over.array.literal.with.single.element=對只有一個元素的陣列文字執行 'foreach'
inspection.message.from.php.this.allowed={0}。從 PHP {1} 起才允許這樣。
inspection.message.function.deprecated.will.be.removed.in.phpunit=方法已棄用並已在 PHPUnit 10 中移除
inspection.message.function.may.produce.side.effects=函式可能會產生副作用
inspection.message.function.ref.marked.as.internal=函式 '#ref' 已標記為 @internal
inspection.message.generators.may.only.declare.return.type.generator.iterator.or.traversable.or.iterable.permitted=產生器只能宣告 ''Generator''、''Iterator''、''Traversable'' 或 ''iterable'' 的返回值類型，不允許 {0}
inspection.message.get.class.call.can.be.replaced.with.class.name.literal='get_class()' 呼叫可被取代為 '::class'
inspection.message.goto.labels.inside.loops.or.switch.statements.are.not.allowed=不允許在迴圈或 switch 語句中使用 'goto' 標籤
inspection.message.if.can.be.replaced.with.version='if' 可被取代為 '??' 版本
inspection.message.if.statement.with.common.parts=包含通用部分的 ''{0}'' 語句
inspection.message.illegal.array.offset.access=嘗試存取類型為 ''{0}'' 的值的陣列偏移
inspection.message.immutable.property.write.scope.does.not.allow.write.access.here=無效的不可變屬性寫入: 作用域 ''{0}'' 不允許在此處進行寫入存取
inspection.message.instanceof.checks.in.catch.can.be.replaced.with.specific.catches='catch' 塊中的 'instanceof' 檢查可被取代為特定的 catch
inspection.message.interpolated.string.dereferencing.available.in.php.only=從 PHP 8.0 起才允許插值字串解參照
inspection.message.key.element.cannot.be.reference=鍵元素不能為參照
inspection.message.leading.slash.in.constant.fqn.will.not.be.trimmed.by.php=PHP 不會修剪常數 FQN 中的前導斜杠
inspection.message.local.object.used.only.for.writing.properties=區域物件僅用於寫入屬性
inspection.message.loop.can.be.replaced.with.0=迴圈可被取代為 ''{0}()''
inspection.message.magic.constant.dereferencing.available.in.php.only=從 PHP 8.0 起才允許魔術常數解參照
inspection.message.match.can.be.replaced.with.switch='match' 表達式可轉換為 'switch' 語句。
inspection.message.match.can.be.replaced.with.switch.changing.semantics='match' 表達式可以轉換為 'switch' 語句。請注意，'switch' 語句依賴於鬆散比較，這可能會改變表達式語意。
inspection.message.match.can.be.replaced.with.ternary='match' 表達式可被取代為三元表達式
inspection.message.max.must.be.greater.than.or.equal.to.argument.min='max' 實參必須大於或等於 'min'
inspection.message.method.may.produce.side.effects=方法可能會產生副作用
inspection.message.method.ref.marked.as.internal=方法 '#ref' 已標記為 @internal
inspection.message.method.reference.resolves.to.method.with.containing.class=''Use'' 規則解析為包含類別 ''{0}'' 中的方法
inspection.message.methods.cannot.be.mocked=''{0}'' 方法無法模擬
inspection.message.multiple.isset.calls.can.be.combined.into.one=可將多個 'isset' 呼叫合併為一個
inspection.message.name.parameter.may.be.different.depending.on.instance.class=在 ''{0}.{1}'' 中可能未解析命名實參
inspection.message.named.argument.usage=命名實參用法
inspection.message.nested.call.can.be.unwrapped=嵌套的 ''{0}'' 呼叫可以解包
inspection.message.never.returning.function.must.not.return='never' 返回函式不得返回
inspection.message.non.readonly.class.cannot.extend.readonly.class=非 ''readonly'' 類別不能擴展 ''readonly'' 類別 ''{0}''
inspection.message.non.readonly.property.readonly=無法將非 'readonly' 屬性重新宣告為 'readonly'
inspection.message.not.valid.backing.value.for.enum={0} 不是枚舉的有效支援值
inspection.message.only.first.byte.will.be.assigned.to.string.offset=只有第一個位元組將被分配給字串偏移
inspection.message.only.variables.can.be.passed.by.reference=僅可通過參照傳遞變數
inspection.message.operands.have.incompatible.types=動作數具有不相容的類型
inspection.message.overrides.method.with.final.tag=覆寫帶有 @final 標記的方法
inspection.message.parameter.name.changed.from.to=參數名稱由 ''{0}'' 更改為 ''{1}''
inspection.message.parentheses.are.unnecessary=圓括號不必要
inspection.message.pointless.boolean.expression=可以簡化布爾表達式
inspection.message.primitive.types.can.t.be.used.as.instanceof.argument=僅物件或字串應用作 ''instanceof'' 實參，當前: ''{0}''
inspection.message.prohibited.autoload.declaration=禁止使用 '__autoload()' 宣告
inspection.message.promoted.field.usage=提升的屬性用法
inspection.message.property.can.be.readonly=屬性可以為 'readonly'
inspection.message.property.only.read.but.never.written=屬性只讀取，但從未寫入
inspection.message.property.only.written.but.never.read=屬性僅寫入，但從未讀取
inspection.message.psr.compound.namespace.with.depth.more.than.two.levels=PSR-12: 複合命名空間的深度超過兩級
inspection.message.psr.missing.parameter.list=PSR-12: 缺少參數列表
inspection.message.psr.missing.visibility.definition=PSR-12: 缺少可見性定義
inspection.message.psr.order.modifiers.incorrect=PSR-12: 修飾符的順序不正確
inspection.message.psr.short.form.type.keywords.should.be.used=PSR-12: 應當使用類型關鍵字的縮寫
inspection.message.psr.traits.must.be.included.one.per.line=PSR-12: 必須以每行一個的形式新增特徵
inspection.message.psr.usage.else.if.construct=PSR-12: 使用 'else if' 結構
inspection.message.psr.usage.var=PSR-12: 'var' 的用法
inspection.message.pure.can.be.added=可以新增 ''{0}''
inspection.message.qualified.name.can.t.contain.whitespaces=限定名稱不能包含空格
inspection.message.readonly.class.cannot.extend.non.readonly.class=''readonly'' 類別不能擴展非 ''readonly'' 類別 ''{0}''
inspection.message.readonly.modifier.redundant='readonly' 修飾符冗餘
inspection.message.readonly.property.non.readonly=無法將 'readonly' 屬性重新宣告為非 'readonly'
inspection.message.redundant.argument={0, choice, 0#實參|1#實參}{0,choice,0#符合|1#符合}{0, choice, 0#參數的|1#參數的}預設{0, choice, 0#值|1#值}
inspection.message.redundant.assignment=冗餘的提升屬性指派
inspection.message.redundant.expression=冗餘表達式
inspection.message.redundant.method.override=方法覆寫冗餘
inspection.message.redundant.parenthesis=冗餘圓括號
inspection.message.redundant.static.in.final.class=final 類別中有冗餘的 'static'
inspection.message.remove.final.tag=移除 '@final' 標記
inspection.message.remove.final.tag.from.0=從 ''{0}'' PHPDoc 註釋中移除 ''@final'' 標記
inspection.message.replace.implicit.octal.literal.with.explicit.one=隱式八進制文字可被取代為顯式八進制文字
inspection.message.results.postfix.expression.unused=未使用後綴表達式的結果
inspection.message.return.type.declaration.must.be.compatible.with=返回值類型宣告必須與 {0} 相容: {1}
inspection.message.return.value.method.never.used=方法的返回值從未使用
inspection.message.returning.by.reference.from.void.function.deprecated=從 void 函式通過參照返回已棄用
inspection.message.second.write.to.readonly.property=無法修改 'readonly' 屬性
inspection.message.should.be.one=值應為以下選項之一: {0}
inspection.message.should.probably.not.be.assigned=''{0}'' 可能不應分配給 ''{1}''
inspection.message.should.probably.not.be.passed.as.parameter=''{0}'' 可能不應作為參數 ''{1}'' 傳遞
inspection.message.spread.operator.can.be.unwrapped=展開運算符可以解包
inspection.message.spread.operator.over.literal.unnecessary.for.arguments.resolved.to.variadic.parameter=對於解析為可變參數的實參，文字上的展開運算符不必要
inspection.message.statement.can.be.collapsed.into.parameter.default.value=語句可以摺疊到參數的預設值中
inspection.message.switch.can.be.replaced.with.match='switch' 語句無法轉換為 'match' 表達式
inspection.message.switch.has.only.default.case=switch 只有 'default' case
inspection.message.switch.has.only.single.case=switch 只有一個 case
inspection.message.too.many.messages.per.file.only.first.errors.warnings.are.shown=每個檔案中的訊息過多。僅顯示前 {0} 條。
inspection.message.too.many.messages.per.line=每行的訊息過多
inspection.message.tostring.method.must.return.string='__toString' 方法必須返回字串
inspection.message.trait.usage=不允許特徵用法
inspection.message.type.can.be.reduced.to=類型範圍可以限縮為 ''{0}''
inspection.message.type.mismatch.should.be.conditional.expression=類型不符合: 應為條件表達式
inspection.message.uncovered.enum.cases='match' 表達式具有未被覆蓋的 enum case
inspection.message.uncovered.enum.cases.switch='switch' 語句有未被覆蓋的枚舉 case
inspection.message.undefined.goto.label.ref=未定義的 goto 標籤 '#ref'
inspection.message.unnecessary.cast.to.string=不必要地轉換為 ''{0}''
inspection.message.unnecessary.curly.braces=不必要的大括號
inspection.message.unnecessary.else=不必要的 'else'
inspection.message.unnecessary.leading.slash=不必要的前導 ''
inspection.message.unused.private.property.ref=未使用的 private 屬性 '#ref'
inspection.message.use.statement.with.non.compound.name.ref.has.no.effect=包含非複合名稱 '#ref' 的 'use' 語句沒有任何作用
inspection.message.using.in.strings.deprecated.use.instead=在字串中使用 {0} 已棄用，請改用 {1}
inspection.message.using.variable.variables.in.strings.deprecated.use.instead=在字串中使用 {0} (可變變數)已棄用，請改用 {1}
inspection.message.value.parameter.always=參數值始終為 ''{0}''
inspection.message.value.ranges.mismatch.expected.actual=值範圍不符合。應為: {0}，實際為: {1}
inspection.message.var.export.with.return.argument.equals.false.always.returns.null=帶等於 ''false'' 的 ''return'' 實參的 ''{0}'' 始終返回 ''{1}''
inspection.message.var.export.without.return.argument.always.returns.null=不帶 ''return'' 實參的 ''{0}'' 始終返回 ''{1}''
inspection.message.variable.already.equal.to.assigned.value=變數已等於指派
inspection.message.will.be.covered.by=非必要條件，因為它由 ''{0}'' 檢查
inspection.message.with.single.string.argument=帶單個字串實參的 ''{0}''
inspection.message.write.access.to.readonly.property.outside.declaration.scope=無法寫入宣告作用域之外的 'readonly' 屬性
inspection.message.write.access.to.readonly.property.outside.declaration.scope.ret.by.ref='readonly' 屬性通過參照返回，可能會泄漏到宣告作用域之外
inspection.message.write.access.to.variable.that.still.references.array.value=對仍參照 'foreach' 中先前所用陣列值的變數的寫入權限
inspection.method.may.be.static=方法可以為 'static'
inspection.method.parameters.count.mismatch=為方法呼叫提供了 {0} 個參數，但方法簽名使用了 {1} 個參數
inspection.method.parameters.count.mismatch.option.ignore.func.get.arg=忽略帶有 func_get_arg/func_get_args 呼叫的函式/方法
inspection.method.parameters.count.mismatch.option.ignore.underscore=忽略最後一個參數為 $_ 的函式/方法
inspection.method.to.string.is.not.implemented=沒有為類別 ''{0}'' 實作方法 ''__toString''
inspection.method.to.string.is.not.implemented.strict.mode=檢查每種表達式類型是否存在 __toString
inspection.missing.break.statement.problem=缺少 'break' 語句
inspection.missing.doc.comment.options.panel.class=類別(&C)
inspection.missing.doc.comment.options.panel.class.constant=類別常數(&A)
inspection.missing.doc.comment.options.panel.constant=常數(&O)
inspection.missing.doc.comment.options.panel.field=屬性(&P)
inspection.missing.doc.comment.options.panel.function=函式(&F)
inspection.missing.doc.comment.options.panel.ignore.private.members=忽略 private 成員
inspection.missing.doc.comment.options.panel.method=方法(&M)
inspection.missing.doc.comment.problem=缺少 PHPDoc 註釋
inspection.missing.doc.comment.problem.batch={0} 缺少 PHPDoc 註釋
inspection.missing.ext.composer.json=composer.json 中缺少 ''{0}''
inspection.missing.ext.require.bundled=需要 PHP 捆綁的擴展
inspection.missing.field.type=缺少屬性的類型宣告
inspection.missing.parent.call.message=缺少父方法呼叫
inspection.missing.parent.constructor.call.message=缺少父建構函式呼叫
inspection.missing.strict.types.declaration=缺少嚴格類型宣告
inspection.missing.strict.types.declaration.add.declaration=新增嚴格類型宣告
inspection.missing_param=缺少所需參數 ''{0}''
inspection.mockery.protected.method.cannot.be.mocked=在不呼叫 'Mock.shouldAllowMockingProtectedMethods' 的情況下，無法對 'protected' 方法進行模擬
inspection.multiple.classes.declarations.in.one.file=在此檔案中宣告了另一個類別
inspection.naming.convention.element.description.class=類別
inspection.naming.convention.element.description.constant=常數
inspection.naming.convention.element.description.function=函式
inspection.naming.convention.element.description.method=方法
inspection.naming.convention.element.description.property=屬性
inspection.naming.convention.element.description.variable=變數
inspection.naming.convention.element.descriptor.regexp={0} 名稱 <code>#ref</code> 不符合正則表達式 ''{1}'' #loc
inspection.naming.convention.problem.descriptor.long={0} 名稱 <code>#ref</code> 過長({1} > {2}) #loc
inspection.naming.convention.problem.descriptor.short={0} 名稱 <code>#ref</code> 過短({1} < {2}) #loc
inspection.nested.ternary.expression=嵌套三元表達式自 PHP 7.4 已棄用
inspection.nested.vs.outer.foreach.variables.conflict.problem1=變數 ''{0}'' 作為鍵用於內部和外部 ''foreach'' 迴圈
inspection.nested.vs.outer.foreach.variables.conflict.problem2=變數 ''{0}'' 作為值用於內部和外部 ''foreach'' 迴圈
inspection.never.function.result.used.problem.type=從未
inspection.non.strict.object.equality=非嚴格物件相等比較
inspection.nullsafe.deref.unnecessary.because=Nullsafe 運算符{0,choice,0#將始終產生 ''null''|1#不必要}，因為此時 ''{1}'' 已經為 ''{2,choice,0#false|1#true}''
inspection.nullsafe.deref.unnecessary.because.evaluated=Nullsafe 運算符 ''{0,choice,0#將始終產生 ''null''|1#不必要}''，因為此時對 ''{1}'' 求值
inspection.option.label.php.severity=PHP {0} 嚴重性:
inspection.option.label.php73.severity=PHP 7.3 嚴重性:
inspection.option.label.php8.severity=PHP 8 嚴重性:
inspection.optional.before.required=可選參數在需要前提供
inspection.php.CS.fixer.validation.inspection.display.name=PHP CS Fixer 驗證
inspection.php.CS.validation.inspection.display.name=PHP_CodeSniffer 驗證
inspection.php.abstract.static.method.description=PHP 嚴格標準: static 方法 '#ref' 不應為 abstract
inspection.php.abstract.static.method.inspection.display.name=static 函式不應為 abstract
inspection.php.accessed.array.is.always.empty=陣列在存取點始終為空
inspection.php.acessing.static.trait.members=正在存取 static 特徵成員
inspection.php.add.line.break.after.trailing.comma=在尾隨逗號後新增換行符
inspection.php.argument.without.name.identifier=無名稱關鍵字的實參
inspection.php.arithmetic.type.check=帶有不支持動作數的算術運算
inspection.php.array.access.on.illegal.type.display.name=非法類型的陣列偏移存取
inspection.php.array.append.using.count=使用 'count()' 作為索引將值追加到陣列
inspection.php.array.fill.can.be.converted.to.loop.inspection.display.name='array_fill' 可以轉換為迴圈
inspection.php.array.filter.can.be.converted.to.loop.inspection.display.name='array_filter()' 呼叫可以轉換為迴圈
inspection.php.array.index.immediately.rewritten=陣列索引會被立即覆寫
inspection.php.array.key.does.not.match.array.shape=陣列鍵與陣列形狀不符合 
inspection.php.array.map.can.be.converted.to.loop.inspection.display.name='array_map()' 呼叫可以轉換為迴圈
inspection.php.array.push.with.single.element=只有一個元素的 'array_push()'
inspection.php.array.search.can.be.replaced.with.in.array='array_search()' 可被取代為 'in_array()' 呼叫
inspection.php.array.traversable.can.be.replaced.with.iterable=類型提示 'array|Traversable' 可被取代為 'iterable'
inspection.php.array.used.only.for.write.inspection.display.name=陣列僅用於寫存取
inspection.php.array.write.access.is.not.used=未使用陣列寫入存取
inspection.php.assert.declaration.is.deprecated=已棄用的 'assert()' 函式宣告
inspection.php.assignment.in.condition.inspection.display.name=條件中的指派
inspection.php.assignment.replaceable.with.operator.assignment.inspection.display.name=指派可被取代為運算符指派
inspection.php.assignment.replaceable.with.prefix.expression.inspection.display.name=指派可被取代為增量或減量
inspection.php.attribute.array.shape.can.be.added=可以新增 '#[ArrayShape]' 特性
inspection.php.attribute.can.be.overridden=可以將特性新增到覆寫成員
inspection.php.attribute.is.not.repeatable=不可重複的特性
inspection.php.attribute.no.return.can.be.added=可以新增 NoReturn 特性
inspection.php.autoload.declaration.is.deprecated=已棄用的 '__autoload()' 函式宣告
inspection.php.autovivification.on.false.values='false' 到陣列的自動轉換已棄用
inspection.php.autovivification.on.false.values.possible=可能會導致將 'false' 轉換為數組，這一轉換已棄用
inspection.php.boolean.expression.can.be.simplified=可以簡化布爾表達式
inspection.php.cast.is.evaluable=對標量值進行類型轉換
inspection.php.cast.is.unnecessary=類型轉換不必要
inspection.php.class.cant.be.used.as.attribute=類別不能用作特性
inspection.php.class.constant.accessed.via.child.class=通過子類別參照的類別常數
inspection.php.class.constant.can.be.final=類別常數可以為 'final'
inspection.php.class.implements.solely.traversable.inspection.display.name=類別無法直接實作 Traversable
inspection.php.class.naming.convention.inspection.display.name=類別名未遵循編碼約定
inspection.php.class.static.member.accessed.via.instance.inspection.display.name=通過執行個體存取的類別 static 成員
inspection.php.closure.can.be.converted.to.first.class.callable.inspection.display.name='Closure::fromCallable()' 可以轉換為一級可調用語法
inspection.php.closure.can.be.converted.to.short.arrow.function.inspection.display.name=閉包可以轉換為箭頭函式
inspection.php.comment.will.be.parsed.as.attribute=在 PHP 8.0 中註釋被解析為特性
inspection.php.composer.duplicated.requirement.inspection.display.name=composer.json 中存在重複的軟體套件條目
inspection.php.composer.extension.stubs.inspection.display.name=composer.json 中缺少擴展
inspection.php.compound.namespace.depth.inspection.display.name=複合命名空間深度大於 2
inspection.php.concatenation.with.arithmetic.usage=具有算術用法的串聯
inspection.php.concatenation.with.empty.string.can.be.merged=空字串的串聯可以與指派合併
inspection.php.condition.always.evaluates.to.constant=條件的求值結果始終為 'true/false'
inspection.php.condition.can.be.replaced.with.min.max.call=條件可被取代為 'min()'/'max()' 呼叫
inspection.php.condition.checked.by.next.condition=邏輯表達式內部的條件由後續條件檢查
inspection.php.constant.naming.convention.inspection.display.name=常數名稱未遵循編碼約定
inspection.php.constant.reassignment.inspection.display.name=常數重新指派
inspection.php.constructor.style.inspection.display.name=舊式建構函式
inspection.php.continue.targeting.switch='continue' 針對 'switch' 語句
inspection.php.covered.element.in.class=類別中的元素已被覆蓋
inspection.php.curly.brace.access.syntax.usage.inspection.display.name=使用了大括號存取語法
inspection.php.define.constant.can.be.replaced.with.const.syntax=define 常數名稱可被取代為 'const' 語法
inspection.php.define.constant.name.with.leading.slash=使用前導斜杠定義的常數名稱
inspection.php.delete.redundant.isset.calls=刪除冗餘的 'isset' 呼叫
inspection.php.deprecated.cast.inspection.display.name=棄用的轉換
inspection.php.deprecated.dollar.brace.string.interpolation=已棄用的 '\${' 字串內插
inspection.php.deprecated.implode.usage.inspection.display.name=棄用的 'implode/join' 用法
inspection.php.deprecated.modifier=自 PHP {1} 起修飾符 ''{0}'' 已棄用
inspection.php.deprecated.partially.supported.callables.display.name=已棄用的部分支援可呼叫物件
inspection.php.deprecated.serializable.interface.usage.inspection.display.name=已棄用的 'Serializable' 接口用法
inspection.php.deprecated.stdlib.call=已棄用的標準庫呼叫
inspection.php.deprecation.inspection.display.name=已棄用
inspection.php.disabled.extension.stubs.description=已停用的 ''{0}'' 擴展存根
inspection.php.disabled.extension.stubs.inspection.display.name=已停用的擴展存根
inspection.php.disabled.quality.tool.composer.inspection.display.name=品質工具檢查已停用
inspection.php.division.by.zero.inspection.display.name=除以零
inspection.php.doc.duplicate.type.inspection.display.name=類型已存在於 PHPDoc 標記中
inspection.php.doc.field.type.mismatch.inspection.display.name=類型與屬性的宣告類型不符合
inspection.php.doc.is.not.complete.inspection.display.name=PHPDoc 註釋簽名不完整
inspection.php.doc.missing.throws.inspection.display.name=缺少 @throws 標記
inspection.php.doc.redundant.throws.inspection.display.name=冗餘 @throws 標記
inspection.php.doc.signature.description=重複的實參 PHPDoc
inspection.php.doc.signature.description2=返回值類型與宣告的不符合
inspection.php.doc.signature.description3=不存在實參的 PHPDoc
inspection.php.doc.signature.description5=實參類型與宣告的不符合
inspection.php.doc.signature.inspection.display.name=PHPDoc 註釋符合函式/方法簽名
inspection.php.duplicate.case.inspection.display.name=switch 語句中存在重複的 case
inspection.php.duplicate.character.in.str.function.call=函式呼叫中的重複字元
inspection.php.duplicate.match.arm.body.inspection.display.name='match' 表達式中的重複 arm
inspection.php.duplicate.match.condition.inspection.display.name=重複條件
inspection.php.duplicate.operand.in.comparison=比較中的重複動作數
inspection.php.duplicate.switch.case.body.inspection.display.name=switch 語句中存在重複分支
inspection.php.duplicate.switch.catch.body.inspection.display.name='catch' 語句中的重複分支
inspection.php.dynamic.as.static.method.call.inspection.display.name=動態方法被呼叫為 static
inspection.php.dynamic.field.declaration=動態屬性宣告
inspection.php.element.is.not.available.in.current.php.version.inspection.display.name=元素在組態的 PHP 版本中不可用
inspection.php.empty.index.operator.not.supported.for.strings=字串不支持 '[]' 運算符
inspection.php.empty.index.operator.not.supported.for.strings.display.name=字串不支持的空索引運算符
inspection.php.enforce.doc.comment.inspection.display.name=強制執行 PHPDoc 註釋
inspection.php.enum.case.with.value.not.found=枚舉中找不到包含指定值的 case
inspection.php.exception.is.immediately.rethrown=立即重新拋出異常
inspection.php.expected.values.should.be.used=應使用預期值
inspection.php.expression.always.constant.inspection.display.name=到達時，變數始終為 true/false
inspection.php.expression.always.null.description='#ref' 始終為 'null'
inspection.php.expression.always.null.inspection.display.name=表達式始終為 'null'
inspection.php.expression.result.unused.inspection.display.name=未使用表達式結果
inspection.php.expression.with.same.operands.inspection.display.name=邏輯表達式有相同動作數
inspection.php.expression.without.clarifying.parentheses.inspection.display.name=表達式不帶澄清括號
inspection.php.field.assignment.type.mismatch.inspection.display.name=屬性指派中的類型不符合
inspection.php.field.immediately.rewritten=屬性會被立即覆寫
inspection.php.foreach.array.is.used.as.value.inspection.display.name=Foreach 陣列用作值
inspection.php.foreach.nested.outer.key.value.variables.conflict.inspection.display.name=嵌套與外部 'foreach' 變數衝突
inspection.php.foreach.over.single.element=對只有一個元素的陣列文字執行 Foreach
inspection.php.foreach.variable.overwrite.already.defined.variable='foreach' 變數覆寫已定義的變數
inspection.php.format.function.call.with.single.argument=使用單個實參格式化函式呼叫
inspection.php.format.function.parameters.mismatch.inspection.display.name=格式函式參數不符合
inspection.php.fully.qualified.name.usage.inspection.display.name=使用了完全限定名稱
inspection.php.func.get.arg.can.be.replaced.with.parameter.access='func_get_arg()' 呼叫可被取代為參數存取
inspection.php.function.naming.convention.inspection.display.name=函式名稱未遵循編碼約定
inspection.php.get.class.can.be.replaced.with.class.name.literal.inspection.display.name='get_class()' 呼叫可被取代為 '::class'
inspection.php.goto.into.loop.inspection.display.name=Goto 轉入迴圈語句
inspection.php.group.attributes=特性
inspection.php.group.code.smell=程式碼異味
inspection.php.group.code.style=程式碼樣式
inspection.php.group.composer=Composer
inspection.php.group.control.flow=控制流
inspection.php.group.error.handling=錯誤處理
inspection.php.group.general=一般
inspection.php.group.naming.conventions=命名約定
inspection.php.group.phpdoc=PHPDoc
inspection.php.group.phpunit=PHPUnit
inspection.php.group.probable.bugs=可能的錯誤
inspection.php.group.psr.12=PSR-12
inspection.php.group.quality.tools=品質工具
inspection.php.group.regexp=正則表達式
inspection.php.group.replacable.assignments=可取代指派
inspection.php.group.strict.standards=PHP 嚴格標準
inspection.php.group.type.compatibility=類型相容性
inspection.php.group.undefined=未定義的符號
inspection.php.group.unused=未使用的符號
inspection.php.highlight.only.closures.with.multiple.statements.option=僅醒目提示包含多條語句的閉包
inspection.php.idempotent.operation=二元表達式中的冪等運算
inspection.php.if.can.be.merged.with.sequential.condition='if' 可以與後續條件合併
inspection.php.if.can.be.replaced.with.match.expression='if' 可被取代為 'match' 表達式
inspection.php.ignored.class.alias.declaration.display.name=忽略的類別名聲明
inspection.php.illegal.array.key.type.description={0} {1}
inspection.php.illegal.array.key.type.inspection.display.name=非法陣列鍵類型
inspection.php.illegal.psr.class.path.inspection.display.name=類別路徑與專案結構不符合
inspection.php.illegal.string.offset.inspection.display.name=非法字串偏移
inspection.php.immutable.property.is.written.in.invalid.scope=在無效的作用域中寫入不可變屬性
inspection.php.implicit.octal.literal.can.be.replaced.with.explicit.one=隱式八進制文字可被取代為顯式八進制文字
inspection.php.in.array.can.be.replaced.with.comparison='in_array' 可被取代為比較
inspection.php.inapplicable.attribute.target.declaration=不適用的特性目標宣告
inspection.php.inappropriate.inherit.doc.usage.class.description=@inheritDoc 用於沒有帶 doc 註釋的父類別的類別
inspection.php.inappropriate.inherit.doc.usage.description=@inheritDoc 用於沒有父級成員但含有 doc 註釋的成員
inspection.php.inappropriate.inherit.doc.usage.description2=@inheritDoc 應僅用於類別成員
inspection.php.inappropriate.inherit.doc.usage.inspection.display.name=使用了不當的 @inheritDoc
inspection.php.include.description=無法解析表達式 ''{0}'' 的目標
inspection.php.include.description2=未找到路徑 ''{0}''
inspection.php.include.inspection.display.name=未解析的 include
inspection.php.incompatible.return.type.inspection.display.name=返回值類型不相容
inspection.php.inconsistent.return.points.inspection.display.name=不一致的返回點
inspection.php.incorrect.magic.method.signature.inspection.display.name=魔術方法簽名不正確
inspection.php.instanceof.checks.in.catch.can.be.replaced.with.specific.catches='catch' 塊中的 'instanceof' 檢查可被取代為特定的 catch
inspection.php.instanceof.is.always.true='instanceof' 的結果始終為 'true'
inspection.php.int.ranges.mismatch=數字範圍不符合
inspection.php.internal.array.index.reset.is.unnecessary=無需陣列內部指針重設
inspection.php.internal.array.index.reset.is.unnecessary.navigate.to.function=導覽到重設陣列內部指針的函式
inspection.php.internal.entity.used.inspection.display.name=使用了內部實體
inspection.php.invalid.delimiter.key=無效分隔符
inspection.php.invalid.instanceof.argument.type='instanceof' 的實參只應是物件或字串
inspection.php.invalid.magic.method.modifiers.inspection.display.name=魔術方法修飾符無效
inspection.php.invalid.string.offset.usage=字串偏移用法無效
inspection.php.isset.can.be.replaced.with.coalesce='isset' 可被取代為合併
inspection.php.isset.can.check.nested.access.directly='isset' 可以直接檢查嵌套存取
inspection.php.isset.can.check.nested.array.access.subproperties.directly='isset' 可以直接檢查嵌套陣列存取和子屬性
inspection.php.language.level.description='fn' 是 PHP 7.4 中的保留關鍵字
inspection.php.language.level.inspection.display.name=語言級別
inspection.php.laravel.pint.inspection.display.name=Laravel Pint 驗證
inspection.php.long.type.form.inspection.display.name=類型關鍵字的縮寫
inspection.php.loop.can.be.converted.to.array.fill.inspection.display.name=迴圈可以轉換為 'array_fill()' 呼叫
inspection.php.loop.can.be.converted.to.array.filter.inspection.display.name=迴圈可以轉換為 'array_filter()' 呼叫
inspection.php.loop.can.be.converted.to.array.map.inspection.display.name=迴圈可以轉換為 'array_map()' 呼叫
inspection.php.loop.can.be.replaced.with.implode=迴圈可被取代為 'implode()'
inspection.php.loop.can.be.replaced.with.in.array=迴圈可被取代為 'in_array()' 或 'array_key_exists()' 呼叫
inspection.php.loop.can.be.replaced.with.str.repeat=迴圈可被取代為 'str_repeat'
inspection.php.loop.never.iterates=''{0}'' 語句不迴圈
inspection.php.loop.never.iterates.name=迴圈未迭代
inspection.php.match.can.be.replaced.with.switch.statement='match' 可被取代為 'switch' 語句
inspection.php.match.expression.can.be.replaced.with.ternary='match' 表達式可被取代為三元表達式
inspection.php.method.may.be.static.inspection.display.name=方法可以為 'static'
inspection.php.method.naming.convention.inspection.display.name=方法名稱未遵循編碼約定
inspection.php.method.or.class.call.is.not.case.sensitive.inspection.display.name=方法呼叫或類別用法中的大小寫不符合
inspection.php.method.parameters.count.mismatch.inspection.display.name=參數數量與宣告不符合
inspection.php.method.return.value.is.never.used=方法的返回值從未使用
inspection.php.missing.break.statement.inspection.display.name=缺少 'break' 語句
inspection.php.missing.doc.comment.inspection.display.name=缺少 PHPDoc 註釋
inspection.php.missing.field.type.inspection.display.name=缺少屬性的類型宣告
inspection.php.missing.param.type.description=缺少參數的類型宣告
inspection.php.missing.parameter.type.inspection.display.name=缺少參數的類型宣告
inspection.php.missing.parent.call.common.inspection.display.name=方法缺少父呼叫
inspection.php.missing.parent.call.magic.inspection.display.name=魔術方法缺少父呼叫
inspection.php.missing.parent.constructor.inspection.display.name=建構函式缺少父呼叫
inspection.php.missing.return.type.description=缺少函式的返回值類型宣告
inspection.php.missing.return.type.inspection.display.name=缺少返回值類型宣告
inspection.php.missing.strict.types.declaration.inspection.display.name=缺少嚴格類型宣告
inspection.php.missing.visibility.inspection.display.name=缺少可見性
inspection.php.mixed.return.type.can.be.reduced=可以限縮 'mixed' 返回值類型的範圍
inspection.php.mockery.invalid.mocking.target=無效的 Mockery 模擬目標
inspection.php.modifier.order.inspection.display.name=修飾符順序
inspection.php.modulo.operation.with.one=以 '1' 為動作數的取模運算
inspection.php.move.variable.inside.closure=在閉包內移動變數指派
inspection.php.multiple.class.declarations.inspection.display.name=多個類別宣告
inspection.php.multiple.classes.declarations.in.one.file.display.name=一個檔案中有多個類別宣告
inspection.php.multiple.isset.calls.can.be.replaced.with.one=可將多個 'isset' 呼叫取代為一個
inspection.php.name.variable.is.used.only.inside.closure=變數僅在閉包內使用
inspection.php.named.argument.may.be.unresolved=命名實參可能未解析
inspection.php.named.argument.usage=有名稱關鍵字的實參
inspection.php.named.arguments.with.changed.order=命名實參順序與參數順序不符合
inspection.php.navigate.to.variable.assignment=導覽到變數指派
inspection.php.nested.dirname.call.can.be.replaced.with.levels.usage=嵌套的 'dirname()' 呼叫可被取代為 'levels' 參數用法
inspection.php.nested.min.max.call=嵌套的 'min/max' 呼叫
inspection.php.nested.ternary.expression.usage.inspection.display.name=使用了嵌套的三元運算符
inspection.php.never.typed.function.returning.value='never' 類型的函式返回一個值
inspection.php.new.class.missing.parameter.list.inspection.display.name=缺少參數列表
inspection.php.non.canonical.elements.order.description=變數及其類型以非規範順序列出
inspection.php.non.canonical.elements.order.inspection.display.name=元素的非規範順序
inspection.php.non.compound.use.inspection.display.name=不必要的語句使用
inspection.php.non.strict.object.equality.inspection.display.name=非嚴格物件相等
inspection.php.not.installed.packages.inspection.display.name=未安裝的 Composer 軟體套件
inspection.php.null.is.not.compatible.with.parameter='null' 與參數的宣告類型不相容
inspection.php.null.safe.operator.can.be.used=可以使用 Nullsafe 運算符 '?->'
inspection.php.object.fields.are.only.written=區域物件僅用於寫入屬性
inspection.php.object.shape.can.be.added=ObjectShape 可以新增
inspection.php.open.echo.tag.inspection.display.name=開啟 'echo' 標記用法
inspection.php.optional.before.required.parameters.inspection.display.name=可選參數在必選參數之前
inspection.php.overriding.method.extending.class.marked.as.final=被標記為 '@final' 的覆寫方法/擴展類別
inspection.php.overriding.method.visibility.inspection.display.name=方法可見性不應被覆寫
inspection.php.parameter.always.have.same.value=參數值始終相同
inspection.php.parameter.by.ref.is.not.used.as.reference.inspection.display.name=不必要的通過參照傳遞
inspection.php.parameter.name.chaged.during.inhertiance=在繼承期間更改了參數名稱
inspection.php.params.inspection.display.name=參數類型
inspection.php.pass.by.ref.description=僅變數可通過參照返回
inspection.php.pass.by.ref.inspection.display.name=通過參照傳遞參數
inspection.php.plural.mixed.can.be.replaced.with.array='mixed' 類型可被取代為 'array'
inspection.php.pointless.boolean.expression='if' 條件內的無意義布爾表達式
inspection.php.possible.polymorphic.invocation.inspection.display.name=可能的多態呼叫
inspection.php.pow.call.can.be.replace.with.pow.operator='pow()' 呼叫可被取代為 '**' 運算符
inspection.php.preg.match.can.be.replaced.with.comparison='preg_match()' 可被取代為比較
inspection.php.preg.match.redundant.closure=冗餘閉包 '.*'
inspection.php.preg.match.without.regular.expression='preg_match' 可被取代為 'str_contains'
inspection.php.preg.replace.with.empty.replacement.name='preg_replace()' 可被取代為 '(l|r)trim' 呼叫
inspection.php.preg.split.can.be.replaced.with.explode='preg_split' 可被取代為 'explode'
inspection.php.private.field.can.be.local.variable.description=屬性可被取代為區域變數
inspection.php.private.field.can.be.local.variable.inspection.display.name=private 屬性可為區域
inspection.php.private.method.may.be.inaccessible.in.late.static.binding.call=在延遲 static 綁定呼叫期間可能無法存取 private 方法
inspection.php.promoted.field.usage=提升的屬性用法
inspection.php.property.can.be.readonly=屬性可以為 'readonly'
inspection.php.property.naming.convention.inspection.display.name=屬性名稱未遵循編碼約定
inspection.php.property.only.written=屬性用法具有相同的存取權限
inspection.php.pure.contract.attribute.can.be.added=可以新增 '#[Pure]' 特性
inspection.php.pure.function.may.produce.side.effect=純函式可能會產生副作用
inspection.php.rand.arguments.in.revers.order=順序錯誤的 'rand' 函式實參
inspection.php.ranges.in.class.can.re.merged=類別中的範圍可以合併
inspection.php.redeclaration.stdlib.function=標準庫函數的重複宣告
inspection.php.redeclaration.stdlib.function.description=不能重複宣告標準庫函數 ''{0}''
inspection.php.redundant.array.call.in.foreach.iterated.value=對 'foreach' 中迭代的值的冗餘 'array_values' 呼叫
inspection.php.redundant.assignment.to.promoted.field=冗餘的提升屬性指派
inspection.php.redundant.attribute.parenthesis=特性中的冗餘圓括號
inspection.php.redundant.catch.clause.inspection.display.name=冗餘 catch 子句
inspection.php.redundant.closing.tag.inspection.display.name=冗餘結束標記
inspection.php.redundant.continue.break.argument=冗餘的 'continue/break' 實參
inspection.php.redundant.doc.comment.inspection.display.name=冗餘 PHPDoc 註釋
inspection.php.redundant.match.expression='match' 表達式只有 default arm，應當進行簡化
inspection.php.redundant.method.override=冗餘方法覆寫
inspection.php.redundant.modifier=冗餘的 ''{0}'' 修飾符
inspection.php.redundant.modifier.key=冗餘修飾符
inspection.php.redundant.optional.argument=冗餘的可選實參
inspection.php.redundant.type.in.union.type=類型宣告冗餘，可以簡化
inspection.php.redundant.type.in.union.type.fix.name=簡化冗餘類型
inspection.php.redundant.type.in.union.type.template=類型宣告可以簡化為 ''{0}''
inspection.php.redundant.variable.doc.type.description=@var 標記指定了已從原始碼推斷出的類型
inspection.php.redundant.variable.doc.type.inspection.display.name=冗餘 @var 標記
inspection.php.regexp.delimiter.is.alphanumeric.or.backslash=分隔符是字母數字或反斜杠
inspection.php.regexp.delimiter.is.used.in.reg.exp=在正則表達式中使用了分隔符
inspection.php.regexp.n.modifier.can.be.replaced.with.non.capturing.groups='n' 修飾符可被取代為非捕獲組
inspection.php.regexp.replace.n.modifier.with.non.capturing.groups=將 'n' 修飾符取代為非捕獲組
inspection.php.regexp.replace.with.valid.delimiter=取代為有效分隔符
inspection.php.remove.modifier=移除修飾符 ''{0}''
inspection.php.remove.useless.trailing.comma=移除無用的尾隨逗號
inspection.php.return.doc.type.mismatch=PHPDoc 中的返回值類型與實際返回值類型不符合
inspection.php.return.doc.type.mismatch.inspection.display.name=PHPDoc 註釋中的返回值類型與實際返回值類型不符合
inspection.php.second.write.to.readonly.property=第二次寫入 'readonly' 屬性
inspection.php.separate.else.if.inspection.display.name=Else if
inspection.php.short.echo.open.tag.description=短 echo 起始標記用法
inspection.php.short.open.echo.tag.inspection.display.name=短起始 'echo' 標記用法
inspection.php.short.open.tag.description=使用了短起始標記
inspection.php.short.open.tag.inspection.display.name=使用了短起始標記
inspection.php.signature.mismatch.during.inheritance.inspection.display.name=覆寫方法的宣告應與父類別相容
inspection.php.silly.assignment.inspection.display.name=冗餘指派
inspection.php.single.statement.with.braces.inspection.display.name=單語句主體帶大括號
inspection.php.statement.has.empty.body.description=語句具有空體
inspection.php.statement.has.empty.body.inspection.display.name=語句具有空體
inspection.php.statement.without.braces.inspection.display.name=控制語句主體無大括號
inspection.php.static.as.dynamic.method.call.inspection.display.name=static 方法被呼叫為動態
inspection.php.str.functions.inspection.display.name='str*()' 呼叫可被取代為 PHP 8 'str_*()' 呼叫
inspection.php.strict.comparison.of.operands.with.different.types=嚴格比較類型不相容的動作數
inspection.php.strict.type.checking.inspection.display.name=嚴格類型檢查規則違反
inspection.php.super.class.incompatible.with.interface.inspection.display.name=父類別的方法宣告與實作的接口不相容
inspection.php.suspicious.name.combination.inspection.name=可疑名稱組合
inspection.php.switch.can.be.replaced.with.match.expression='switch' 可被取代為 'match' 表達式
inspection.php.switch.case.without.default.branch.inspection.display.name=switch 語句沒有 default 分支
inspection.php.ternary.expression.can.be.replaced.with.condition.inspection.display.name=三元表達式可被取代為條件
inspection.php.ternary.expression.can.be.replaced.with.short.version=三元表達式可被取代為短版本
inspection.php.throwable.not.thrown.inspection.display.name=未拋出 Throwable
inspection.php.to.string.implementation.inspection.display.name=方法 '__toString' 實作
inspection.php.to.string.may.produce.exception='__toString' 可能會拋出異常
inspection.php.to.string.return.inspection.display.name=方法 '__toString' 返回值類型
inspection.php.too.long.member.reference.chain=成員參照鏈過長，無法分析
inspection.php.too.many.parameters.inspection.display.name=函式宣告中的參數過多
inspection.php.traditional.syntax.array.literal.inspection.display.name=檢測到傳統語法陣列文字
inspection.php.trait.method.use.is.located.inside.different.target.class=特徵 use 規則已解析為使用不同包含類別的方法 
inspection.php.trait.usage=不允許特徵用法
inspection.php.traits.use.list.inspection.display.name=每行一個特徵 use
inspection.php.type.tag.without.variable.name=不帶變數名稱的類型標記
inspection.php.typed.property.might.be.uninitialized.inspection.display.name=類型化屬性可能未初始化
inspection.php.typed.property.might.be.uninitialized.inspection.problem=類型化屬性 ''{0}'' 可能未初始化
inspection.php.uncovered.enum.cases=某些 enum case 未被覆蓋
inspection.php.undefined.callback.inspection.display.name=未定義的回調
inspection.php.undefined.class.constant.inspection.display.name=未定義的類別常數
inspection.php.undefined.class.description=類別 '#ref' 存在多個定義
inspection.php.undefined.class.description2=未定義的類別 '#ref'
inspection.php.undefined.class.description5=存在類別 '#ref' 的其他宣告
inspection.php.undefined.class.inspection.display.name=未定義的類別
inspection.php.undefined.class.other.declaration.exists={0} 處存在類別 ''#ref'' 的其他宣告
inspection.php.undefined.class.other.declaration.exists.and={0} 和另 {1} 處存在類別 ''#ref'' 的其他宣告
inspection.php.undefined.constant.inspection.display.name=未定義的常數
inspection.php.undefined.field.inspection.display.name=未定義的屬性
inspection.php.undefined.function.inspection.display.name=未定義的函式
inspection.php.undefined.goto.label.inspection.display.name=未定義的 goto 標籤
inspection.php.undefined.method.inspection.display.name=未定義的方法
inspection.php.undefined.namespace.description=未定義的命名空間 '#ref'
inspection.php.undefined.namespace.inspection.display.name=未定義的命名空間
inspection.php.undefined.variable.inspection.display.name=未定義的變數
inspection.php.unhandled.exception.inspection.display.name=未處理的異常
inspection.php.unit.assert.always.execute.to.same.result=實參類型不相容的 'assertTrue()'
inspection.php.unit.assert.array.has.key.inspection.display.name=可以改用方法 'assertArrayHasKey/assertArrayNotHasKey'
inspection.php.unit.assert.can.be.replaced.with.assert.true.false=斷言可被取代為 'assertTrue/assertFalse'
inspection.php.unit.assert.can.be.replaced.with.fail=斷言可被取代為 'fail'
inspection.php.unit.assert.contains.inspection.display.name=棄用的 'assertContains/assertNotContains' 用法
inspection.php.unit.assert.count.inspection.display.name=使用了 'assertCount/assertSameSize' 方法而非 assertEquals
inspection.php.unit.assert.empty.inspection.display.name=斷言可被取代為 'assertEmpty/assertNotEmpty'
inspection.php.unit.assert.equals.inspection.display.name=棄用的 'assertEquals/assertNotEquals' 用法
inspection.php.unit.assert.file.equals.inspection.display.name=棄用的 'assertFileEquals/assertStringEqualsFile' 用法
inspection.php.unit.covers.by.access.modifier.is.deprecated.inspection.display.name=棄用的通過修飾符註解進行的 @covers/@uses
inspection.php.unit.covers.function.without.scope.resolution.operator.inspection.display.name=提供的覆蓋函式參照沒有 '::'
inspection.php.unit.deprecated.call.in.phpunit.10=方法在 PHPUnit 10 中已棄用
inspection.php.unit.deprecated.data.provider.signature.inspection.display.name=自 PHPUnit 10 以來，已棄用資料提供程序
inspection.php.unit.deprecated.expect.exception.inspection.display.name=使用了棄用的 expectException
inspection.php.unit.expected.exception.doc.tag.is.deprecated.inspection.display.name=棄用的通過文檔標記進行的異常處理
inspection.php.unit.failed.line=測試中失敗的行
inspection.php.unit.invalid.mocking.target=無效的 PHPUnit 模擬目標
inspection.php.unit.misordered.assert.equals.arguments.inspection.display.name=順序錯誤的 PHPUnit 等式斷言方法實參
inspection.php.unit.missing.target.for.test.inspection.display.name=PHPUnit 測試缺少目標元素
inspection.php.unit.undefined.data.provider.inspection.display.name=未定義的 PHPUnit 資料提供程序
inspection.php.unknown.modifier=未知修飾符 ''{0}''
inspection.php.unnecessary.continue='continue' 不必要，因為是迴圈中的最後一條語句
inspection.php.unnecessary.curly.variable.syntax=變數的不必要大括號語法
inspection.php.unnecessary.double.quotes.display.name=不必要的雙引號
inspection.php.unnecessary.else.inspection.display.name=不必要的 'else' 分支
inspection.php.unnecessary.fully.qualified.name.inspection.display.name=不必要的完全限定名稱
inspection.php.unnecessary.leading.backslash.in.use.statement='use' 語句中有不必要的前導 ''
inspection.php.unnecessary.local.variable.inspection.display.name=不必要的區域變數
inspection.php.unnecessary.parentheses.inspection.display.name=不必要的圓括號
inspection.php.unnecessary.return.function='return' 不必要，因為是函式中的最後一條語句
inspection.php.unnecessary.return.inspection.display.name=不必要的 'return/continue' 語句
inspection.php.unnecessary.return.method='return' 不必要，因為是方法中的最後一條語句
inspection.php.unnecessary.semicolon.description=不必要的 ;
inspection.php.unnecessary.semicolon.inspection.display.name=不必要的分號
inspection.php.unnecessary.spread.operator.for.function.call.argument=函式呼叫實參的不必要展開運算符
inspection.php.unpacked.argument.type.mismatch.inspection.display.name=無效類型的解包實參
inspection.php.unpacking.arrays.with.string.keys.inspection=對於 PHP 8.1 之前的版本，禁止使用字串鍵解包陣列
inspection.php.unsupported.modifier=自 PHP {1} 起不支持修飾符 ''{0}''
inspection.php.unsupported.modifier.key=不支持的修飾符
inspection.php.unused.alias.description=匯入 '#ref' 不必要
inspection.php.unused.alias.description2=匯入 '#ref' 從未使用
inspection.php.unused.alias.inspection.display.name=未使用的 import
inspection.php.unused.display.name=未使用的宣告
inspection.php.unused.field.default.value.description=屬性初始設定式冗餘
inspection.php.unused.field.default.value.inspection.display.name=冗餘屬性初始設定式
inspection.php.unused.local.variable.inspection.display.name=未使用的區域變數
inspection.php.unused.match.arm.condition.inspection.display.name=未使用的 'match' 條件
inspection.php.unused.parameter.inspection.display.name=未使用的參數
inspection.php.unused.private.field.inspection.display.name=未使用的 private 屬性
inspection.php.unused.private.method.inspection.display.name=未使用的 private 方法
inspection.php.unused.switch.case.inspection.display.name=未使用的 'switch' 分支
inspection.php.usage.of.silence.operator.inspection.display.name=使用了靜默運算符
inspection.php.useless.trailing.comma.inspection.desc=無用的尾隨逗號
inspection.php.useless.trailing.comma.inspection.display.name=無用的尾隨逗號
inspection.php.var.export.used.without.return.argument=使用 'var_export' 或 'print_r' 調用時不帶 'return' 實參
inspection.php.var.usage.inspection.display.name=使用了 var
inspection.php.variable.naming.convention.inspection.display.name=變數名稱未遵循編碼約定
inspection.php.variable.variable.inspection.display.name=使用了可變變數
inspection.php.void.function.result.used.inspection.display.name=使用了 void 函式結果
inspection.php.write.access.to.readonly.property.outside.declaration.scope=對宣告作用域之外的 'readonly' 屬性的寫入權限
inspection.php.write.access.to.referenced.array.value.without.unset=對無 'unset' 的參照陣列值的寫入權限
inspection.php.wrong.catch.clauses.order.inspection.display.name=catch 子句順序錯誤
inspection.php.wrong.foreach.argument.type.inspection.display.name=為 'foreach()' 提供的無效實參
inspection.php.wrong.string.concatenation.inspection.display.name=字串串聯錯誤
inspection.phpunit.asserts.array.has.key.can.be.used.instead=可以改用方法 ''{0}''
inspection.phpunit.asserts.assert.with.count.function=可以使用方法 {0} 代替 {1}
inspection.phpunit.asserts.assertEquals.misordered.arguments=順序錯誤的 ''{0}()'' 實參
inspection.phpunit.asserts.assertEquals.parameters.empty=帶有此類別參數的呼叫已棄用
inspection.phpunit.asserts.assertEquals.parameters.many=可選的 {0} 個參數已棄用
inspection.phpunit.asserts.assertEquals.parameters.single=可選的 {0} 個參數已棄用
inspection.phpunit.covers.function.without.scope.resolution.operator=提供的覆蓋{0}參照沒有 ''::''
inspection.phpunit.expectException=對將 expectException() 用於 {0} 的支援已棄用，將在 PHPUnit 10 中移除。請改用 {1}()。
inspection.phpunit.missing.target.element.ref=未找到 '#ref' 的測試目標元素
inspection.probably.undefined.property=屬性 '#ref' 已動態宣告，可能未定義
inspection.property.declared.dynamically=動態宣告的屬性
inspection.property.declared.dynamically.deprecated=動態宣告的屬性，從 PHP 8.2 開始已棄用。
inspection.redundant.closing.tag.fix.remove=移除結束標記
inspection.redundant.closing.tag.problem=冗餘結束標記
inspection.redundant.intersection.type=冗餘的交叉類型
inspection.redundant.intersection.type.fix=交叉類型可以簡化為 ''{0}''
inspection.redundant.intersection.type.fix.name=簡化交叉類型
inspection.redundant.phpdoc=冗餘 PHPDoc 註釋
inspection.redundant.phpdoc.tag=冗餘的 PHPDoc 標記
inspection.severity.with.magic=當 __magic 存在時顯示
inspection.silly.assignment.problem=指派左右兩側相等
inspection.single.statement.with.braces=單語句主體帶大括號
inspection.single.statement.with.braces.fix.name=從 ''{0}'' 語句中移除大括號
inspection.statement.has.empty.body.comments.count.as.content=註釋計為內容
inspection.statement.has.empty.body.ignore.empty.for=忽略無主體的 'for' 迴圈
inspection.statement.has.empty.body.ignore.empty.while=忽略無主體的 'while' 迴圈
inspection.statement.without.braces=控制語句主體無大括號
inspection.statement.without.braces.fix.name=將大括號新增到 ''{0}'' 語句
inspection.static.member.accessed.via.instance.reference=通過執行個體參照存取 static 成員 ''{0}''
inspection.static.method.called.as.dynamic.problem=static 方法 '#ref' 不應被動態呼叫
inspection.static.method.called.as.dynamic.problem.magic=static 方法 '#ref' 不應被動態呼叫，但類別具有 '__magic' 方法。
inspection.str.functions.strpos.call.can.be.converted.to.strcontains='strpos()' 呼叫可以轉換為 'str_contains()'
inspection.str.functions.strpos.call.can.be.converted.to.strstartswith='strpos()' 呼叫可以轉換為 'str_starts_with()'
inspection.str.functions.substr.call.can.be.converted.to.strendswith='substr()' 呼叫可以轉換為 'str_ends_with()'
inspection.str.functions.substr.call.can.be.converted.to.strstartswith='substr()' 呼叫可以轉換為 'str_starts_with()'
inspection.strict.type.checking.field.assignment=屬性必須為 ''{0}'' 類型，提供的是 ''{1}''
inspection.strict.type.checking.field.assignment.multi.resolve=指派的類型 ''{0}'' 與屬性的宣告類型不相容
inspection.strict.type.checking.option=為所有檔案啟用
inspection.strict.type.checking.parameter=應為 ''{0}'' 類型的參數，提供的是 ''{1}''
inspection.strict.type.checking.parameter.batch=參數 '#ref' 類型與宣告不相容
inspection.strict.type.checking.return=返回值必須為 ''{0}'' 類型，返回的是 ''{1}''
inspection.strict.type.checking.return.batch=返回值類型與宣告不相容
inspection.super.incompatible.with.interface.declaration.must.be.compatible=''{0}'' 的宣告必須與 ''{1}'' 相容
inspection.switch.with.single.case=只有一個 'case' 的 'switch'
inspection.switch.without.default.case='Switch' 沒有預設分支
inspection.too.many.parameters=參數數量超出指定限值
inspection.too.many.parameters.ignore.constructors=忽略建構函式
inspection.too.many.parameters.max.number.of.parameters=最大參數數量
inspection.traditional.syntax.array.literal.detected=使用了傳統語法陣列文字
inspection.undefined.callback.class=未定義的類別 ''{0}''
inspection.undefined.callback.dont.report.ambiguity.checkbox=不明確時不報告
inspection.undefined.callback.dont.report.exist.checkbox=忽略來自 '*_exists' 和 'is_callable' 函式的回調
inspection.undefined.callback.field=在類別 ''{1}'' 中未找到屬性 ''{0}''
inspection.undefined.callback.function=未定義的函式 ''{0}''
inspection.undefined.callback.method=在類別 ''{1}'' 中未找到方法 ''{0}''
inspection.undefined.class.ignore.phpdoc=忽略 PHPDoc
inspection.undefined.constant.problem1=未定義的常數 '#ref'
inspection.undefined.constant.problem2=常數 '#ref' 可能未定義
inspection.undefined.field.notify.access.magic.method=通過魔術方法存取屬性的通知
inspection.undefined.field.notify.dynamic.declaration=動態屬性宣告的通知
inspection.undefined.field.notify.dynamic.read=通知對動態屬性的讀取權限
inspection.undefined.field.problem1=通過魔術方法存取的屬性
inspection.undefined.function.problem1=未定義的函式 '#ref'
inspection.undefined.function.problem2=函式 '#ref' 可能未定義
inspection.undefined.member.downgrade=如果類別中存在 __magic 方法則降級嚴重性(&D)
inspection.undefined.member.warnOnMixed=出現混合、物件、stdClass、未定義類型、null 的存取成員時通知
inspection.undefined.phpunit.provider=未定義的 PHPUnit 資料提供程序 ''{0}''
inspection.undefined.variable.option.description.enable.in.file.scope=在全域空間中啟用檢查
inspection.undefined.variable.option.description.ignore.include=在當前檔案外搜尋變數定義
inspection.undefined.variable.option.description.report.can.be.undefined=報告變數可能未定義
inspection.undefined.variable.problem1=未定義的變數 '#ref'
inspection.undefined.variable.problem2=變數 '#ref' 可能未定義
inspection.unnecessary.bool.cast=冗餘轉換為布林值
inspection.unnecessary.fully.qualified.name.option.enable.file.scope=在檔案作用域中啟用
inspection.unnecessary.fully.qualified.name.option.ignore.global.namespace=忽略全域命名空間
inspection.unnecessary.qualifier.already.imported.message=限定符不必要，可以移除
inspection.unnecessary.static.reference=final 類別中有冗餘的 'static'
inspection.unnecessary.string.cast=冗餘轉換為字串
inspection.unpacked.argument.type.mismatch=僅可解包陣列和 Traversable，獲得的是{0}
inspection.unreachable.statement=不可到達的語句
inspection.unreachable.statement.problem=不可到達的語句
inspection.unused.declaration.option.show.unused_from_entries=顯示所有宣告
inspection.unused.declaration.option.show_strictly_unused=僅顯示未使用項
inspection.unused.declaration.option.test.entry_points=假定測試宣告為入口點
inspection.unused.declaration.option.test.suppressGettersAndSetters=禁止 getter/setter
inspection.unused.description.code.suppressed.annotations=已禁止的註解
inspection.unused.local.variable.option.description.file.scope=在全域空間中啟用檢查
inspection.unused.local.variable.option.description.foreach=在 'list()' 中或存在 'foreach' 鍵時忽略 foreach 值
inspection.unused.local.variable.option.description.include=忽略 'include' 之前的變數
inspection.unused.local.variable.option.description.list=忽略 'list()' 中的變數
inspection.unused.local.variable.option.description.null=忽略 'null' 的指派
inspection.unused.local.variable.option.indirect.access=忽略通過 'get_defined_vars()' 存取的變數
inspection.unused.local.variable.problem=未使用的區域變數 ''{0}''。{1}
inspection.unused.local.variable.problem.batch=區域變數 '#ref' 未在任何位置使用
inspection.unused.local.variable.problem.case1=變數的值未在任何位置使用。
inspection.unused.local.variable.problem.case2=變數的值被立即覆蓋。
inspection.unused.local.variable.problem.case3=變數中存儲的參照未在任何位置使用。
inspection.unused.local.variable.problem.case4=變數中存儲的參照被立即覆蓋。
inspection.unused.local.variable.problem.fix.side.effects.found.dialog.message=分配給 ''{0}'' 的表達式可能含有副作用。\\n您可以:\\n- 完全<b>移除</b>變數指派\\n- 將分配的表達式<b>轉換</b>成單獨的語句
inspection.unused.local.variable.problem.fix.side.effects.found.dialog.title=發現副作用
inspection.unused.parameter.option.description.empty.abstract=忽略抽象類別方法的參數
inspection.unused.parameter.option.description.empty.anonymous=忽略匿名函式的參數
inspection.unused.parameter.option.description.empty.body=忽略帶有空體的方法/函式的參數
inspection.unused.parameter.option.description.empty.override=忽略覆寫方法的參數
inspection.unused.parameter.option.description.parameter.count=不報告通過 'func_num_args()' 存取的參數
inspection.unused.parameter.problem=未使用的參數 ''{0}''。{1}
inspection.unused.parameter.problem.case1=參數值未在任何位置使用。
inspection.unused.parameter.problem.case2=參數值被立即覆蓋。
inspection.unused.parameter.problem.case3=參數中存儲的參照未在任何位置使用。
inspection.unused.parameter.problem.case4=參數中存儲的參照被立即覆蓋。
inspection.unused.private.method.option.ignore.clone=忽略方法 '__clone' 用法
inspection.unused.private.method.option.ignore.constructor=忽略方法 '__construct' 用法
inspection.unused.private.method.problem.batch=未使用的 private 方法 '#ref'
inspection.unused.symbol.check.anonymous_classes=匿名
inspection.unused.symbol.check.classes=類別
inspection.unused.symbol.check.constants=常數
inspection.unused.symbol.check.fields=屬性
inspection.unused.symbol.check.functions=函式
inspection.unused.symbol.check.magic_method=魔術方法
inspection.unused.symbol.check.methods=方法
inspection.unused.symbol.export.abstract=abstract
inspection.unused.symbol.export.call=呼叫
inspection.unused.symbol.export.calls=呼叫
inspection.unused.symbol.export.closure=結束
inspection.unused.symbol.export.entry=入口點
inspection.unused.symbol.export.label=標籤
inspection.unused.symbol.export.reachable_element=可到達
inspection.unused.symbol.export.test_method=測試
inspection.unusedd.description.code.patterns.button.label=程式碼模式
inspection.usage.of.silence.operator.problem=使用了沉默運算符
inspection.variable.variable=使用了可變變數
inspection.void.function.result.used.problem.type=void
inspection.void.never.function.result.used.problem.type=void/never
inspection.wrong.exception.order.fix.move.display.name=將 ''catch'' 子句移至 ''{0}'' 前
inspection.wrong.exception.order.fix.move.family.name=移動 'catch' 子句
inspection.wrong.exception.order.problem.batch=已捕獲異常 '#ref'
inspection.wrong.exception.order.problem.same=已捕獲異常 ''{0}''
inspection.wrong.exception.order.problem.super=已捕獲異常類別 ''{1}'' 的超類別 ''{0}''
inspection.wrong.exception.type.problem.catch=無法捕獲非派生自 'Exception' 或 'Throwable' 基類別的物件
inspection.wrong.exception.type.problem.throw=已拋出物件必須為 'Exception' 或 'Throwable' 的執行個體
inspection.wrong.foreach.argument.type.problem=提供給 ''foreach'' 的實參無效。預期類型: ''array'' 或 ''object''，提供的是 ''{0}''。
inspection.wrong.foreach.argument.type.problem.batch=提供給 'foreach' 的無效實參
inspection.wrong.string.concatenation.operator.option.ignore.magic=忽略通過魔術方法存取的屬性
inspection.wrong.string.concatenation.operator.problem=字串串聯運算符錯誤
inspection.wrong.string.concatenation.operator.problem.batch=字串串聯運算符錯誤
inspection.wrong_param_type=應為 ''{1}'' 類型的參數，提供的是 ''{0}''
install.composer.packages.task.title=安裝 Composer 軟體套件
instanceof.is.always.true={0} 已位於 {1} 的層次結構中
intention.add.constructor.parameters=新增建構函式參數
intention.add.constructor.parameters.fields.chooser.dialog.title=選擇要在建構函式中初始化的屬性
intention.can.not.find.statement.to.surround=找不到要包圍的目標語句。
intention.convert.to.short.syntax=將陣列轉換為短語法
intention.convert.to.short.syntax.list=將列表轉換為短語法
intention.convert.to.traditional.syntax=將陣列轉換為傳統語法
intention.convert.to.traditional.syntax.list=將列表轉換為傳統語法
intention.declare.missing.field=宣告屬性
intention.declare.missing.property=新增 @property
intention.family.inline.value.for.parameter=內聯參數值
intention.family.name.add=新增 ''\${0}''
intention.family.name.add.arrayshape.attribute=新增 '#[ArrayShape]' 特性
intention.family.name.add.arrayshape.to.doc=將 ArrayShape 新增到 PHPDoc
intention.family.name.add.attribute=新增 ''#[{0}]''
intention.family.name.add.attribute.attribute=使用 'Attribute' 註解
intention.family.name.add.attribute.to=將 ''#[{0}]'' 新增到 ''{1}''
intention.family.name.add.attribute.to.overridden.method=將特性新增到覆寫方法
intention.family.name.add.attribute.to.overridden.method.of.abstract.method=將特性新增到抽象方法的覆寫方法
intention.family.name.add.attribute.to.overridden.parameter=將特性新增到覆寫參數
intention.family.name.add.break.as.last.statement=將 'break' 作為最後一條語句新增
intention.family.name.add.default.match.arm=新增 'default' 'match' arm
intention.family.name.add.doc.tag.with.throws.tags=使用 @throws 標記新增 PHPDoc 註釋
intention.family.name.add.getter=新增 getter
intention.family.name.add.getter.setter=新增 getter 和 setter
intention.family.name.add.missing.parameters=新增缺少的參數
intention.family.name.add.name.identifiers.to.all.arguments.starting.from.current=從當前位置開始將名稱關鍵字新增到所有實參
intention.family.name.add.number.separators=新增數字分隔符
intention.family.name.add.readonly.modifier=新增 'readonly' 修飾符
intention.family.name.add.remaining.enum.cases=新增剩餘 enum case
intention.family.name.add.should.allow.mocking.protected.methods.call=新增 'shouldAllowMockingProtectedMethods' 呼叫
intention.family.name.add.to.containing.enum=將 '' : {0}'' 新增到包含枚舉
intention.family.name.add.to.parameter=將 '\\\\&' 新增到參數
intention.family.name.add.trait.to.use.list=將特徵新增到 use 列表
intention.family.name.add.true.argument.to.var.export.call=將 'true' 實參新增到 'var_export' 呼叫
intention.family.name.add.variable.name=新增變數名稱
intention.family.name.append=追加 ''{0}''
intention.family.name.append.absolute.trait=追加 ''{0}::''
intention.family.name.can.be.merged.with.sequential=''if'' 可以與後續 ''{0}'' 合併
intention.family.name.change.to.mixed=將類型更改為 'mixed'
intention.family.name.collapse.if.statement=摺疊 ''{0}'' 語句
intention.family.name.collapse.statement.into.parameter.default.value=將語句摺疊到參數的預設值中
intention.family.name.collapse.whitespaces=摺疊空格
intention.family.name.combine.multiple.isset.calls.into.one=將多個 'isset' 呼叫合併為一個
intention.family.name.convert.heredoc.nowdoc.to.string.literal=將 HEREDOC/NOWDOC 轉換為字串文字
intention.family.name.convert.heredoc.to.string.literal=將 HEREDOC 轉換為字串文字
intention.family.name.convert.nowdoc.to.string.literal=將 NOWDOC 轉換為字串文字
intention.family.name.convert.string.literal.to.heredoc.nowdoc=將字串文字轉換為 HEREDOC/NOWDOC
intention.family.name.convert.to.promoted.field=轉換為提升的屬性
intention.family.name.convert.to.promoted.field.remove.doc.comment=轉換為提升的屬性並移除屬性 PHPDoc 註釋
intention.family.name.copy.phpdoc.from.parent=從父項複製 PHPDoc
intention.family.name.count.comments.as.content=將註釋計為內容
intention.family.name.delete.covered.element=刪除已覆蓋的元素
intention.family.name.delete.field=刪除屬性
intention.family.name.delete.initializer=刪除初始設定式
intention.family.name.delete.readonly=刪除 'readonly'
intention.family.name.evaluate.cast=取代為 ''{0}''
intention.family.name.extract.attribute.into.separate.list=將特性提取到單獨的列表
intention.family.name.extract.common.parts=提取通用部分
intention.family.name.extract.common.parts.with.removing.branch=提取通用部分，並移除分支
intention.family.name.flip=翻轉 '?:'
intention.family.name.flip.attributes.lists=翻轉特性列表
intention.family.name.force.fqcn.for.references.in.phpdoc=對 PHPDoc 中的參照強制 FQCN
intention.family.name.generate.phpdoc.comment=生成 PHPDoc 註釋
intention.family.name.group.intersection.types=對交叉類型分組
intention.family.name.initialize.properties=初始化屬性
intention.family.name.initialize.property.in.constructor=初始化建構函式中的屬性
intention.family.name.insert.space.after=在 '#' 後面插入一個空格
intention.family.name.insert.unset.before=在前面插入 ''unset(\${0});''
intention.family.name.invert.if.statement=反轉 'if' 語句
intention.family.name.make.class.readonly=將類別設定為 'readonly'
intention.family.name.make.containing.class.enum=將包含類別設為枚舉
intention.family.name.make.data.provider.method.public.static=將資料提供程序方法設定為 'public' 和 'static'
intention.family.name.make.final=設為 'final'
intention.family.name.make.function.return.by.reference=使函式按參照返回
intention.family.name.make.method.void=將方法設為 'void'
intention.family.name.merge.with.adjustment.range=與調整後的範圍合併
intention.family.name.merge.with.assignment=與指派合併
intention.family.name.merge.with.duplicated.catch.statement=與重複的 'catch' 語句合併
intention.family.name.merge.with.duplicated.match.arm=與重複的 'match' arm 合併
intention.family.name.merge.with.following.attribute.list=將特性列表與以下內容合併
intention.family.name.merge.with.sequential=與後續 ''{0}'' 合併
intention.family.name.move.attribute.to.start.element=將特性移至元素開頭
intention.family.name.move.from.to.composer.json.section=將 ''{0}'' 從 ''{1}'' 移至 ''{2}'' composer.json 部分
intention.family.name.move.trait.use.rule.to.resolved.class.use.list=將特徵 'use' 規則移至解析的類別 'use' 列表
intention.family.name.navigate.to.cause=導覽到原因
intention.family.name.navigate.to.duplicate.method.name=導覽到重複的方法
intention.family.name.navigate.to.possibly.inaccessible.methods=導覽到可能無法存取的方法
intention.family.name.navigate.to.rewrite.expression=導覽到覆寫表達式
intention.family.name.remove=移除 {0}
intention.family.name.remove.argument.name=移除實參名稱
intention.family.name.remove.attribute=移除 ''#[{0}]''
intention.family.name.remove.backed.type.from.containing.enum=從包含枚舉中移除備用類型
intention.family.name.remove.duplicate.operand=移除重複動作數
intention.family.name.remove.empty.index.operator=移除 '[]' 運算符
intention.family.name.remove.leading=移除前導 ''
intention.family.name.remove.parenthesis=移除圓括號
intention.family.name.remove.readonly.modifier=移除 'readonly' 修飾符
intention.family.name.remove.redundant.arguments=移除冗餘{0, choice, 0#實參|1#實參}
intention.family.name.remove.unused.postfix.operation=移除未使用的後綴運算
intention.family.name.remove.unused.property=移除未使用的屬性
intention.family.name.rename.parameter.to.match.super=重新命名參數以符合父級
intention.family.name.replace.array.traversable.with.iterable=將 'array|Traversable '取代為'iterable'
intention.family.name.replace.elseif.with.else=將 'elseif' 取代為 'else'
intention.family.name.replace.if.with.match.expression=將 'if' 取代為 'match' 表達式
intention.family.name.replace.if.with.version=將 'if' 取代為 '??' 版本
intention.family.name.replace.in.array.with.disjunction=將 'in_array()' 取代為 '||'
intention.family.name.replace.instanceof.checks.in.catch.with.specific.catches=將 'catch' 塊中的 'instanceof' 檢查取代為特定的 catch
intention.family.name.replace.match.with.switch.statement=將 'match' 取代為 'switch' 語句
intention.family.name.replace.match.with.switch.statement.changing.semantics=將 'match' 取代為 'switch' 語句(可能會改變比較語意)
intention.family.name.replace.match.with.ternary=取代為三元表達式
intention.family.name.replace.readonly.with.public=將 'readonly' 取代為 'public'
intention.family.name.replace.switch.with.if=將 'switch' 取代為 'if'
intention.family.name.replace.switch.with.match.expression=將 'switch' 取代為 'match' 表達式
intention.family.name.replace.ternary.expression.with.true.branch=將三元表達式取代為 ''{0}'' 分支
intention.family.name.replace.true.argument.with.false=將 'true' 實參取代為 'false'
intention.family.name.replace.with=取代為 ''{0}''
intention.family.name.replace.with.argument=取代為實參
intention.family.name.replace.with.array=取代為數組
intention.family.name.replace.with.array.assignment=取代為數組指派
intention.family.name.replace.with.array.merge.expression=取代為 'array_merge' 表達式
intention.family.name.replace.with.check=取代為 '!==' 檢查
intention.family.name.replace.with.class.constant=取代為類別常數
intention.family.name.replace.with.class.name.literal=取代為 '::class'
intention.family.name.replace.with.class.reference.with.base.class=取代為對基類別的類別參照
intention.family.name.replace.with.closure.fromCallable=取代為 'Closure::fromCallable(...)'
intention.family.name.replace.with.comparison=取代為比較
intention.family.name.replace.with.compile.time.result=取代為編譯時結果
intention.family.name.replace.with.concatenation=取代為串聯
intention.family.name.replace.with.const.syntax=取代為 'const' 語法
intention.family.name.replace.with.define.call=取代為 'define()' 呼叫
intention.family.name.replace.with.dirname.call=取代為 'dirname()' 呼叫
intention.family.name.replace.with.dnf=取代為 DNF 類型宣告
intention.family.name.replace.with.get.class.call=取代為 'get_class()' 呼叫
intention.family.name.replace.with.if=取代為 'if'
intention.family.name.replace.with.implicit.octal.notation=取代為隱式八進制表示法
intention.family.name.replace.with.implode.call=取代為 'implode()' 呼叫
intention.family.name.replace.with.in.array.call=取代為 'in_array()' 呼叫
intention.family.name.replace.with.interpolation=取代為 '{$' 插值
intention.family.name.replace.with.list=取代為 'list'
intention.family.name.replace.with.min.max.call=取代為 'min()'/'max()' 呼叫
intention.family.name.replace.with.named.argument=取代為命名實參
intention.family.name.replace.with.operator=取代為 '?->' 運算符
intention.family.name.replace.with.parameter.access=取代為參數存取
intention.family.name.replace.with.public=取代為 'public'
intention.family.name.replace.with.self.access=取代為 'self::' 存取
intention.family.name.replace.with.spl.autoload.register.call=取代為 'spl_autoload_register()' 呼叫
intention.family.name.replace.with.str.function.call=取代為 ''{0}'' 呼叫
intention.family.name.replace.with.str.repeat.call=取代為 'str_repeat()' 呼叫
intention.family.name.replace.with.suggested.call.in.phpunit=取代為 PHPUnit 10 中建議的呼叫
intention.family.name.replace.with.ternary.expression=取代為三元表達式
intention.family.name.replace.with.traditional.property.declaration=取代為傳統屬性宣告
intention.family.name.replace.with.union.type=取代為聯合類型
intention.family.name.replace.with.version=取代為 '??' 版本
intention.family.name.replace.with.zero=取代為 ''{0}''
intention.family.name.show.example.date.time.output=顯示範例日期時間輸出
intention.family.name.simplify.expression=簡化表達式
intention.family.name.simplify.ternary.expression=簡化 '?:'
intention.family.name.sort.arguments=對實參排序
intention.family.name.split.into.multiple.catch.statements=拆分為多個 'catch' 語句
intention.family.name.split.into.multiple.enum.cases=拆分為多個枚舉 case
intention.family.name.split.into.separate.case.statements=拆分為獨立的 'case' 語句
intention.family.name.split.into.two.separate.match.arms=將條件提取到單獨的 'match' arm
intention.family.name.unwrap.call=解包呼叫
intention.family.name.unwrap.cast=解包轉換
intention.family.name.unwrap.curly.braces=解包大括號
intention.family.name.unwrap.else=解包 'else'
intention.family.name.unwrap.foreach=解包 'foreach'
intention.family.name.unwrap.function.call=解包函式呼叫
intention.family.name.unwrap.intersection.type=解包交叉類型
intention.family.name.unwrap.spread.operator=解包展開運算符
intention.family.name.unwrap.type=解包類型
intention.flip.binary.expression.family.name=翻轉二元表達式
intention.flip.binary.expression.text1=翻轉 ''{0}''
intention.flip.binary.expression.text2=翻轉 ''{0}'' (可能更改語意)
intention.flip.binary.expression.text3=翻轉 ''{0}'' (更改語意)
intention.generate.phpdoc=生成 PHPDoc
intention.implement.interface=實作接口
intention.import.class=作為別名匯入類別
intention.import.class.alias.already.exists=已匯入具有相同別名的類別
intention.import.class.alias.name=別名:
intention.inline.alias=內聯別名
intention.inline.method.family.name=內聯方法
intention.join.comma.separated.values=將逗號分隔的值合併為一行
intention.line.split=在兩個字串和串聯中拆分字串
intention.merge.condition.with.outer=與外部條件合併
intention.message.replace.in.array.with.disjunction=將 ''in_array()'' 取代為 ''{0}''
intention.name.add.as.function.s.return.type=將 ''{0}'' 作為函式返回值類型新增
intention.name.add.enum.case.with.value=新增具有 ''{0}'' 值的枚舉 case
intention.name.add.method.stubs=新增方法存根
intention.name.add.name.identifier=新增名稱關鍵字 ''{0}''
intention.name.add.to.parameter=將 ''\\\\&'' 新增到參數 ''{0}''
intention.name.add.trait.to.use.list=將特徵 ''{0}'' 新增到 use 列表
intention.name.cast.to=將{0}轉換為{1}
intention.name.change.cast.to=將 {0} 轉換更改為 {1}
intention.name.change.method.to=將方法 ''{0}'' 更改為 {1}
intention.name.change.signature=更改 {0}({1}) 的簽名
intention.name.convert.array.syntax.to.short=將陣列轉換為短語法
intention.name.convert.concatenation.to.scalar.value=將串聯轉換為標量值
intention.name.convert.concatenation.to.string.interpolation=將串聯轉換為字串內插
intention.name.convert.sprintf.call.to.concatenation=將 'sprintf()' 呼叫轉換為串聯
intention.name.convert.sprintf.call.to.scalar.value=將 'sprintf()' 呼叫轉換為標量值
intention.name.convert.sprintf.call.to.string.interpolation=將 'sprintf()' 呼叫轉換為字串內插
intention.name.convert.string.literal.to.heredoc=將字串文字轉換為 HEREDOC
intention.name.convert.string.literal.to.nowdoc=將字串文字轉換為 NOWDOC
intention.name.evaluate.cast=對轉換求值
intention.name.extract.if=提取 if ({0})
intention.name.flip=翻轉 {0} 和 {1}
intention.name.inline.value=內聯值 ''{0}''
intention.name.make.abstract=將{0}設為 abstract
intention.name.make.non.final=將 ''{0}'' 設為非 final
intention.name.merge.with=與 ''{0}'' 合併
intention.name.merge.with.match.arm=與 ''{0}'' arm 合併
intention.name.move.trait.use.rule.to.use.list=將特徵 ''use'' 規則移至 ''{0}'' ''use'' 列表
intention.name.prepend.default.case=預置 'default'
intention.name.remove=移除 {0}
intention.name.remove.argument.names.from.all.arguments.up.to.current=從截止到當前位置的所有實參中移除實參名稱
intention.name.remove.brackets=刪除中括號
intention.name.remove.duplicated.type=移除重複類型
intention.name.rename.to=重命名為 ''{0}''
intention.name.replace.brackets.with.types=取代為 'array'
intention.name.replace.coalesce.expression.with=將合併表達式取代為 ''{0}''
intention.name.replace.coalesce.expression.with.operand=將合併表達式取代為動作數
intention.name.replace.null.as.part.union.type.with.nullable.notation=將 '|null' 作為聯合類型的一部分取代為 '?'
intention.name.replace.nullable.notation.with.null.as.part.union.type=用 '|null' 取代 '?' 作為聯合類型的一部分
intention.name.replace.with=將 ''{0}'' 取代為 ''{1}''
intention.name.replace.with.min.max.call=取代為 ''{0}'' 呼叫
intention.name.suppress.for.statement=對語句禁止
intention.name.wrap.left.operand.in.parentheses=使用圓括號包裝左動作數
intention.name.wrap.right.operand.in.parentheses=使用圓括號包裝右動作數
intention.namespace.bracing=將命名空間轉換為帶大括號
intention.php.add.object.shape.attribute=新增 '#[ObjectShape]' 特性
intention.php.doc.add.object.shape=將 ObjectShape 新增到 PHPDoc
intention.php.replace.class.with.enum=將類別取代為枚舉
intention.php.replace.class.with.enum.error.message=由於建構函式呼叫，無法將類別取代為枚舉
intention.php.replace.class.with.enum.title=將類別取代為枚舉
intention.replace.class.with.alias=取代為別名
intention.replace.if.with.ternaryExpression=簡化 'if'
intention.replace.quotes=無法取代引號 - 轉義符號無效且\\\\r 不受支援
intention.replace.ternary.expression.with.if=將 '?:' 取代為 if
intention.replace.with.method.call=取代為對現有方法的呼叫
intention.split.comma.separated.values=將逗號分隔的值拆分為多行
intention.statement.to.surround.failed.message=無法使用 ''{0}'' 包圍語句。
intention.swap.call.arguments.family.name=交換呼叫實參
intention.swap.call.arguments.text1=交換 ''{0}'' 和 ''{1}''
intention.variable.add.phpdoc.comment.family.name=新增 PHPDoc 註釋
interface=接口
interface.cannot.extend.previously.extended.interface=接口無法擴展先前擴展的接口
interface.method.can.t.have.body=接口方法不能有主體
interface.name=接口名稱
interfaces.may.not.include.member.variables=接口可能不包括成員變數
interpreter=解釋器
intersection.types.and.the.nullable.type.notation.cannot.be.mixed=交叉類型和可 null 類型表示法不能混用
introduce.named.constant.for.value.0=為值 ''{0}'' 引入命名常數
introduce.variable.fix=引入變數
invalid.class.name=無效類別名
invalid.condition.to.body.separator.should.be.used=條件與主體之間的分隔符無效: 應改用 '=>'
invalid.octal.literal.won.t.be.reported.by.php.but.will.work.incorrectly=無效的八進制文字: 不會由 PHP 報告，但無法正常工作
invalid.syntax.for.multiple.case.expressions=多個 'case' 表達式的語法無效
is.duplicated.by.0=類型被 ''{0}'' 重複
iso.8601.date=ISO 8601 日期({0})
iso.8601.numeric.representation.of.the.day.of.the.week=ISO 8601 星期几的數字表示(1 到 7)
iso.8601.week.number.of.year.weeks.starting.on.monday=ISO 8601 一年中的第幾周，周從星期一開始(42)
iso.8601.week.numbering.year=ISO 8601 周編號年份(2022)
isset.only.works.with.variables.and.arrays=isset 僅適用於變數和陣列
it.s.not.possible.to.unpack.array.argument.by.reference=無法通過參照對陣列實參解包
it.s.not.possible.to.unpack.array.key=無法解包陣列鍵
it.s.not.possible.to.unpack.array.value.with.associated.key=無法使用關聯鍵解包陣列值
jump.into.a.finally.block.is.disallowed=不允許跳入 'finally' 塊
key=鍵
label=標籤
label.align.named.arguments=對齊命名實參
label.authentication.data.not.specified=未指定身份驗證資料
label.can.be.configured.as.external.formatter=可組態為 {0}
label.class.fqn=類別 FQN
label.configured.as.external.formatter=已組態為 {0}
label.constant.syntax=常數語法(&C)
label.docker.container=Docker 容器:
label.failed=已失敗
label.global.namespace=<全域命名空間>
label.highlight.target.parameter.attributes.applied.to.promoted.property=僅允許具有提升屬性的 'TARGET_PARAMETER|TARGET_PROPERTY' 特性
label.initialize.in=初始化位置(&I)
label.insert.imports.on.paste=貼上時插入 import:
label.interpreter=解釋器: {0}
label.lt.no.server=<no server>
label.method.name=方法名稱
label.name=名稱:
label.new.name=新名稱:
label.predecessors=前驅
label.server.document.root=$_SERVER['DOCUMENT_ROOT']
label.successors=後繼
label.system.php=系統 PHP
label.visibility=可見性(&V)
label.visibility2=可見性:
label.with.same.name.already.defined.in.current.scope=當前作用域中已定義具有相同名稱的標籤
label1=標籤
lambda=Lambda
languages.frameworks.php.php.runtime=PHP / PHP 執行時
line.separator=行分隔符
link=連結
link.label.go.to.documentation=轉到文檔
link.label.inspection={0} 檢查
link.label.languages.frameworks.php=PHP
list.is.not.allowed.as.class.reference=不允許將列表作為類別參照
list.item.update.phpdoc.comment=更新 PHPDoc 註釋
list.of.causes.0=// 可能拋出異常的位置列表:\\n{0}
listing.licenses=正在列出授權
live.template.class.member=類別成員
live.template.interface.member=接口成員
live.template.name.comment=註釋
live.template.name.expression=表達式
live.template.name.statement=語句
live.template.name.string.literal=字串文字
live.template.trait.member=特徵成員
local=本地
lowercase.ante.meridiem.and.post.meridiem.am.pm=小寫上午和下午(am/pm)
machine.type.eg.i386=機器類型。例如，i386
make.0.1=將 ''{0}'' 設為{1}
make.01=設為 ''{0}''
make.call.dynamic.quick.fix.family.name=使呼叫為動態
make.non.nullable=設為不可為 null
member.has.0.access=成員具備 {0} 可見性
member.has.0.access.but.class.has.magic.method.1=成員具備 {0} 可見性，但可以通過 ''{1}'' 魔術方法存取
members.to.report=要報告的成員
merge.into.elseif=合併到 'elseif' 中
merge.nested.conditions=合併嵌套的條件
merge.with.0.branch=與 ''{0}'' 分支合併
meta.declaration.exists=''{1}'' 存在元宣告 ''{0}''
meta.declaration.line.marker.name=存在元宣告
meta.multiple.declaration.exists=''{0}'' 存在多個元宣告
method=方法
method.0.can.t.be.overridden.with.same.trait.1=無法使用相同的特徵 ''{1}'' 覆寫方法 ''{0}''
method.0.clone.cannot.accept.any.arguments=方法 ''{0}::__clone()'' 不能接受任何實參
method.call=方法呼叫
method.is.undefined=方法 '#ref' {0,choice,0#未定義|1#可能未定義}
method.is.undefined.in.class=方法 ''#ref'' 在 {0} 中{1,choice,0#未找到|1#可能未定義}
method.name=方法名稱
method.ref.is.deprecated=方法 '#ref' 已棄用
method.ref.not.found=找不到方法 '#ref'
method.should.either.have.body.or.be.abstract=方法應具有主體或為 abstract
method.should.not.be.finished.with=方法不應以 ';' 結束
method.template.parameter.shadows.class.template.parameter=方法模板參數 ''{0}'' 會隱藏類別模板參數
method.with.same.name.already.defined.in.this.class=此類別中已經定義了具有相同名稱的方法
method1=方法
microseconds=微秒(654321)
milliseconds=毫秒(654)
minutes.with.leading.zeros=帶前導零的分鐘(00 到 59)
modifier=修飾符
more.actions=更多動作…
move.class.to.separate.file.text.family=將類別移至單獨的檔案
move.from.another.ide.or.code.editor=從另一個 IDE 或程式碼編輯器遷移
multiple.enum.identifiers.should.be.stated.in.different.cases=多個枚舉關鍵字應在不同的 case 中宣告
multiple.modifiers.are.not.allowed=不允許多個修飾符
multiple.namespaces.in.a.file.should.use.same.preferably.braced.syntax=檔案中的多個命名空間應使用相同的(最好帶大括號)語法
multiple.subsequent.underscores.in.a.numeric.literal.are.not.allowed=不允許在數字文字中使用多個後續下劃線
mute.until.restart=重啟前靜音
name=名稱
named.parameter.overwrites.previous.argument=命名參數覆寫以前的實參
namespace=命名空間
namespace.cannot.start.with.namespace.due.to.conflict.with.ns.relative.names=由於與 ns 相關名稱衝突，命名空間不能以 "namespace" 開頭
namespace.declarations.cannot.be.nested=命名空間宣告不能被嵌套
naming.rules=命名規則
navigate=… 導覽
navigate.to.composer.json=導覽到 composer.json
navigate.to.meta.declaration=導覽到 ''{0}''
navigation.goto.super.method.is.not.available=索引更新期間無法在此處導覽
negate.boolean.expression=布爾表達式求反
nested.type.groups.are.not.allowed=不允許嵌套類型組
never.can.only.be.used.as.return.type='never' 只能用作返回值類型
no.candidate.methods.to.implement=沒有要實作的候選方法
no.candidate.methods.to.override=沒有要覆寫的候選方法
no.content.allowed.before.namespace.declaration=命名空間宣告之前不允許任何內容
no.elements.to.generate.phpdoc.for=沒有任何可為其生成 PHPDoc 的元素
no.expression.found=找不到表達式
no.external.formatter=無外部格式化程序
no.in.line.parameter.name.hints.will.be.shown.for.methods.matching.any.of.these.patterns=對於符合其中任一模式的方法，都不會顯示任何嵌入參數名稱提示。
no.interpreter=<無解釋器>
no.item=沒有項
no.members.to.pull.up.found=未找到要向上拉取的成員
no.members.to.push.down.found=未找到要向下推送的成員
no.name=無名稱
no.private.fields.to.generate.both.getters.and.setters.for=沒有要為之同時生成 getter 和 setter 的 private 欄位
no.private.fields.to.generate.getters.for=沒有要為之生成 getter 的 private 欄位
no.private.fields.to.generate.setters.for=沒有要為之生成 setter 的 private 欄位
no.response.from.0.after.1.ms={1} 毫秒後 {0} 未響應
no.type=NO_TYPE
node.is.interface=接口只能繼承一個接口
non.backed.enum.cannot.implement.interface.backedenum=非備用枚舉無法實作接口 'BackedEnum'
non.enum.class.cannot.implement.interface=非枚舉類別無法實作接口 ''{0}''
notication.group.php.debugger=PHP 偵錯器
notification.content.composer.executable.was.automatically.set.to.global.composer=Composer 可執行檔案已被自動設定為全域 'composer'
notification.content.configure.manually=手動組態
notification.content.disable.breakpoint.move.to.resolved.position=停用中斷點移動到已解析的位置
notification.content.disable.paratest=停用 ParaTest
notification.content.formatter.couldn.t.apply.result.external.tool=格式化程序無法套用外部工具的結果
notification.content.language.level.synchronisation.with.composer.was.disabled=已停用與 composer.json 的語言級同步
notification.content.language.level.was.changed.to.based.on.project.usage=語言級別已根據專案中使用的功能設定為 {0}
notification.content.link.copied.to.clipboard=連結 {0} 已複製到剪貼簿
notification.content.process.exited.with.non.zero.code=程序以非零程式碼退出
notification.content.tests.have.been.run.without.paratest=測試在沒有 ParaTest 的情況下執行
notification.content.timeout.while.fetching.data.from=從 {0} 提取資料時超時
notification.content.usage.found.in.project=在專案中找到了 {0} 用法
notification.content.vendor.directory.not.found=未找到 'vendor' 目錄
notification.content.xdebug.extension.not.installed=未安裝 Xdebug 擴展
notification.group.composer.install=建議使用 Composer 'install' 指令
notification.group.composer.language.level=已停用 Composer 語言級別同步
notification.group.dbgp.proxy=PHP 偵錯器代理
notification.group.debug.listener=PHP 偵錯偵聽器
notification.group.default.stubs=PHP 預設存根路徑不正確
notification.group.php=PHP
notification.group.php.3v4l=PHP 3v4l 整合
notification.group.php.cgi=PHP-CGI 伺服器
notification.group.php.code.style=建議進行 PHP 程式碼樣式檢查
notification.group.php.interpreters=PHP 解釋器問題
notification.group.php.plugin.suggestion=PHP 延伸模組建議
notification.group.php.profiler=PHP 分析器問題
notification.group.phpunit=PHPUnit
notification.group.quality.tools=PHP 外部品質工具
notification.paratest.mute=忽略
notification.title.cannot.read.snapshot=無法讀取快照
notification.title.incorrect.profiler.snapshot.format=分析器快照格式不正確
notification.title.paratest.doesn.t.support.filter.option=ParaTest 不支持 --filter 選項
null.cannot.be.marked.as.nullable='null' 不能被標記為可以為 null
number.of.days.in.the.given.month=給定月份中的天數(28 到 31)
numeric.representation.of.a.month.with.leading.zeros=月份的數字表示，帶前導零(01 到 12)
numeric.representation.of.a.month.without.leading.zeros=月份的數字表示，不帶前導零(1 到 12)
numeric.representation.of.the.day.of.the.week=星期几的數字表示(0 到 6)
object.property=物件屬性
older=較舊…
only.intersection.type.can.be.used.for.grouping=只能使用交叉類型進行分組
only.intersection.type.can.be.used.for.grouping1=只能使用交叉類型進行分組
only.simple.expressions.are.allowed=只允許簡單表達式
only.the.last.parameter.can.be.variadic=只有最後一個參數可以是可變形參
only.visibility.modifiers.can.be.applied.to.promoted.property=只能將可見性修飾符套用到提升的屬性
open.in.editor=在編輯器中開啟
open.inspection.settings=開啟 {0} 檢查設定
open.tool.settings=開啟 {0} 設定
opens.composer.json.to.change.php.property=開啟 'composer.json' 以更改 'php' 屬性
opens.inspection.0.setting=開啟檢查 ''{0}'' 設定
operating.system.name.eg.freebsd=作業系統名稱。例如，FreeBSD
or.disable.inspection=或
output.phpinfo=輸出 phpinfo():
output.phpinfo.title=輸出 phpinfo() 
override=覆寫
overriding.implementing.methods=覆寫/實作方法
overriding.private.methods=覆寫 private 方法
parameter=參數
parameter.is.deprecated=參數 ''{0}'' 已棄用
parameter.ref.type.is.not.compatible.with.declaration=參數 '#ref' 類型與宣告不相容
parameter.type.is.not.convertible.from.null=參數類型不可從 'null' 轉換
parameter1=參數
paratest=ParaTest
paratest.is.not.supported.for.selected.run.profile=ParaTest 與所選執行組態檔案不相容
paratest.runner.description=使用 ParaTest 執行所選組態
parser.expected=應為: {0}
parser.unexpected=意外: {0}
parsing.error,at.expected=應為 '@'
parsing.error.expression.not.assignable=表達式不可指派
parsing.error.method.label.expected=應為方法標籤
parsing.error.not.allowed=不允許使用 ''{0}''
parsing.error.statement.expected=應為語句
parsing.error.unexpected.token=意外的標記: {0}
pass.by.ref.is.not.effectively.used.inside.body=參照沒有必要，因為實參既不通過參照指派，也不通過參照進一步傳遞
path.0.is.invalid=路徑 ''{0}'' 無效
path.to.php=<php 路徑>
patterns.are.matched.on.fully.qualified.name.parameter.count.and.parameter.names=模式會通過完全限定名稱、參數計數和參數名稱進行符合。
percentage.lines={0}% 行
phar.exclude.from.project.action.title=從專案中排除 phar
phar.exclude.or.include.into.project.action.title=在專案中包含或排除 phar
phar.failed.to.parse=無法解析
phar.include.into.project.action.title=將 phar 包含到專案中
php=PHP
php.5.6.is.not.supported=不支持下載 PHP 5.6 版本的 Xdebug 擴展
php.add.exception=將 ''{0}'' 新增到現有 @throws 標記
php.add.field.declaration.quick.fix.text=新增屬性
php.add.method.declaration.quick.fix.text=新增方法
php.add.tag.base.quick.fix.family.name=新增 {0} 標記
php.annotator.exchange.extends.implements.keyword=將 ''{0} {2}'' 更改為 ''{1} {2}''
php.annotator.expecting.class=應為類別參照
php.annotator.expecting.interface=應為接口參照
php.annotator.heredoc.indent.validation.mixed.space.and.tab.characters=結束關鍵字縮排中混用了空格和制表符字元
php.annotator.heredoc.indent.validation.wrong.content.indent=縮排錯誤:應與結束標記縮排相同
php.annotator.return.type.make.nullable.fix=使返回值類型可為 null
php.annotator.return.type.non.nullable.null.returned=無法返回 'null': 返回值類型不可為 null
php.annotator.strict.types.block.mode='strict_types' 宣告不能使用塊模式
php.annotator.strict.types.first.statement='strict_types' 宣告必須是腳本中的第一條語句
php.annotator.typed.parameter.type.mismatch.fix.change=將參數類型更改為 ''{0}''
php.annotator.typed.parameter.type.mismatch.fix.family=更改參數類型以符合預設值的類型
php.annotator.typed.parameter.type.mismatch.fix.nullable=使參數類型可為 null
php.annotator.typed.property.callable.is.illegal=屬性不能有 'callable' 類型
php.annotator.typed.property.illegal.value=''{0}'' 類型的屬性可能沒有預設值
php.annotator.typed.property.type.mismatch=預設值只能是 ''{0}'' 類型
php.annotator.typed.property.type.mismatch.fix.change=將屬性類型更改為 ''{0}''
php.annotator.typed.property.type.mismatch.fix.family=更改屬性類型以符合預設值的類型
php.annotator.typed.property.type.mismatch.fix.nullable=使屬性類型可為 null
php.annotator.void.function.must.not.return.value=void 函式不得返回值
php.append.doc.static.fix.family.name=在函式參照前追加 '::'
php.cgi.not.found=請確保<a href="">組態的 PHP 解釋器</a>作為 CGI 程序建置(指定了 --enable-fastcgi)
php.cgi.not.found.title=找不到 {0}
php.change.cast.operation.quick.fix.family.name=將轉換更改為{0}
php.change.function.signature.from.usage.quick.fix.family.name=從用法改變函式簽名
php.change.function.signature.manually.quick.fix.family.name=手動更改簽名
php.change.method.modifiers.quick.fix.family.name=更改修飾符
php.change.method.modifiers.quick.fix.text=移除修飾符
php.change.signature.conflict.with.local.var=參數 ''{0}'' 與函式 ''{1}'' 內的區域變數衝突
php.change.signature.conflict.with.local.var.method=參數 ''{0}'' 與來自 ''{2}'' 的方法 ''{1}'' 內的區域變數衝突
php.check.validity.reg.exp=在專用對話框中檢查正則表達式的有效性
php.class=類別
php.code.style.convert.keyword.to.lowercase=將關鍵字轉換為小寫
php.code.style.convert.lower.case=小寫
php.code.style.convert.upper.case=大寫
php.code.style.sort.alphabetically=按字母順序
php.code.style.sort.by.length=按長度
php.code.style.sort.use.stmt=對 'use' 語句排序:
php.configure.extensions.quick.fix.family.name=組態擴展存根
php.console=PHP 主控台
php.control.flow.viewer=PHP 控制流檢視器
php.control.flow.viewer.0=PHP 控制流檢視器: {0}
php.conversion.code.style.title=程式碼轉換
php.create.data.provider.quick.fix.family.name=建立資料提供程序
php.dead.code.entries=PHP 死碼條目
php.debug.action.include.return.value.breakpoint.step.description=啟用額外的“從函式返回”偵錯步驟
php.debug.action.watches.method.return.value.enable=啟用函式返回值偵錯
php.debug.action.watches.method.return.value.unavailable.reason=從 Xdebug 3.2 起才支援返回值偵錯
php.debug.state.widget=停止/啟動偵錯偵聽
php.debug.validate.got.it=偵錯驗證
php.debug.validate.got.it.descr=您可以使用偵錯驗證對話框驗證設定
php.delete.catch.clause.quick.fix=刪除 'catch' 子句
php.delete.exception.quick.fix=刪除異常
php.element.is.available.starting.with.php.version=''{0}'' 從 PHP 版本 {1} 開始可用
php.element.was.removed.in.php.version=''{0}'' 已在 PHP {1} 版本中被移除
php.embedded.stubs.incorrect.path.warning.message=組態的預設存根路徑 ''{0}'' 不存在，改為使用嵌入式存根。
php.embedded.stubs.incorrect.path.warning.title=預設存根路徑不正確
php.embedded.stubs.notification.provider.clone=在 GitHub 上克隆
php.embedded.stubs.notification.provider.do.not.show.again=不再顯示
php.embedded.stubs.notification.provider.notification=您正在檢視不可變的嵌入式存根。為了能夠編輯這些存根，您需要克隆一個存根專案，然後通過“PHP / PHP 執行時 / 進階設定”提供預設存根路徑。
php.embedded.stubs.notification.provider.provide=提供預設存根路徑
php.empty.project.generator.description=為 PHP 建立空專案
php.empty.project.generator.name=PHP 空專案
php.enable.extension.quick.fix.family.name=啟用擴展存根
php.enable.extension.quick.fix.text=啟用 ''{0}'' 擴展存根
php.enum=枚舉
php.exception.is.never.thrown=函式中從未拋出異常 ''{0}''
php.executable.macro.description=專案設定中組態的 Php 可執行檔案
php.external.formatter=PHP 外部格式化程序
php.external.formatter.title=外部格式化程序
php.extract.class=PHP 提取類別
php.find.clause.throws=可能拋出: {0}
php.flip.arguments.quick.fix.family.name=翻轉第一和第二個實參
php.flip.variable.and.type.quick.fix.family.name=翻轉變數和類型
php.framework.enable.plugin=啟用延伸模組
php.framework.install.plugin=安裝延伸模組
php.framework.laravel.plugin=Laravel Idea
php.framework.settings.page=設定
php.framework.symfony.plugin=Symfony
php.generation.code.style.title=程式碼生成
php.info.parse.exception=無法解析 php 資訊: {0} 是空的
php.information.dialog.title=PHP 資訊
php.inline.variable.quick.fix.family.name=內聯變數
php.intention.category=PHP
php.interface=接口
php.interpreter.base.configuration.fix.interpreter={0}。要修復，請<a href=''{1}''>更改</a>專案解釋器或<a href=''{2}''>檢查</a>設定。
php.interpreter.base.configuration.interpreter.is.invalid=無法執行 {0}，因為{1}組態的解釋器無效。
php.interpreter.base.configuration.is.not.provided.or.empty={1} 的 {0} 路徑未組態。您可以在“PHP|{0}”下進行修復
php.interpreter.base.configuration.working.directory=無法檢測工作目錄，請在執行組態中進行組態。
php.interpreter.custom.ini.label=組態檔案:
php.interpreter.info.failed.to.parse.validation.script=無法解析驗證腳本輸出
php.interpreter.is.remote.message=請<a href="">選擇本地 PHP 解釋器</a>以使用內建 Web 伺服器
php.interpreter.is.remote.title=已組態遠端 PHP 解釋器
php.interpreter.label.label=標籤
php.interpreter.not.configured=請<a href="">組態 PHP 解釋器</a>以使用內建 Web 伺服器
php.interpreter.not.configured.title=未組態 PHP 解釋器
php.language.level.widget=PHP 語言級別
php.make.class.abstract.quick.fix.family.name=將類別設為 abstract
php.make.class.non.final.quick.fix.family.name=將類別設為非 final
php.make.method.non.abstract.quick.fix.family.name=將方法設為非 abstract
php.make.method.non.final.quick.fix.family.name=將方法設為非 final
php.make.method.non.static.quick.fix.family.name=將方法設為非 static
php.method.name.empty=未指定測試方法
php.method.not.found=在類別 ''{1}'' 中未找到方法 ''{0}''
php.non.strict.object.equality.quick.fix.text=取代為身份比較
php.not.test.method=類別 ''{1}'' 中的方法 ''{0}'' 不是測試方法
php.path.was.updated={0} 自訂
php.path.was.updated.text=專案預設解釋器已被新增到 {0}
php.prefdefined.codestyle.psr12.chosen.message=您可以啟用其他 PSR-12 檢查，這些檢查當前已停用。
php.prefdefined.codestyle.psr12.chosen.title=PSR-12 程式碼樣式
php.prefdefined.codestyle.psr12.enabled.message=PSR-12 檢查已啟用。
php.project.configurable.composer.configs.tab.name=Composer 檔案
php.project.configurable.composer.duplicate.configurations=已經存在具有相同 composer.json 的組態
php.project.configurable.composer.main=主
php.quick.documentation.namespace.classes=命名空間類別:
php.remote.debug.name=PHP 遠端偵錯
php.remote.interpreter.plugin.is.not.installed=PHP Remote Interpreter 延伸模組未安裝
php.remove.all.unused.parameters.quick.fix.text=移除所有未使用的參數
php.remove.doc.tag.quick.fix.family.name=移除 {0}
php.remove.exception.from.throws=從 @throws 標記中移除 ''{0}''
php.remove.parameters.quick.fix.text=移除未使用的參數
php.remove.pass.by.ref.from.parameter.quick.fix.family.name=從參數中移除 '&'
php.remove.ref.from.assignment.quick.fix.family.name=將 '=\\\\&' 取代為 '='
php.remove.ref.from.function.declaration.quick.fix.family.name=從函式宣告中移除 '&'
php.remove.statement.fix.family.name=移除
php.remove.throws.tag=從 @throws 標記移除
php.remove.unused.local.variable.without.successor.quick.fix.family.name=移除變數 ''{0}''
php.rename.wrong.reference.quick.fix.family.name=重新命名參照
php.replace.argument.with.cast.quick.fix.family.name=將實參轉換為{0}
php.replace.try.from.with.null.quick.fix.family.name=將 'tryFrom()' 呼叫取代為 'null'
php.replace.with=取代為 ''{0}''
php.replace.with.float.cast.quick.fix.family.name=取代為 '(float)' 轉換
php.replace.with.interface.quick.fix.family.name=取代為 {0}
php.replace.with.local.variable.quick.fix.family.name=將屬性取代為區域變數
php.replace.with.null.quick.fix.family.name=取代為 'null'
php.run.check.reg.exp=執行檢查 RegExp 意圖 {0}
php.run.http.border.title.configuration=組態
php.run.label.https=HTTPS:
php.run.label.interpreter=解釋器:
php.run.label.query.string=查詢字串:
php.run.label.request.body=請求正文:
php.run.label.request.method=請求方法:
php.run.label.send.request.body.as=將請求正文發送為:
php.run.label.server=伺服器:
php.run.label.url=URL:
php.run.radio.button.key.value=鍵值
php.run.radio.button.text=文本
php.smart.indent.codestyle.indent.in.php=縮排 PHP 標記中的程式碼
php.surround.with.if=if
php.surround.with.try.catch.quick.fix=使用 'try-catch' 包圍
php.tag.is.deprecated={0} 已棄用，將在 PHPUnit 9 中移除
php.test.framework.by.sdk.dialog.label=解釋器(&I):
php.test.framework.by.sdk.new.settings.dialog.title=通過遠端解釋器{0}
php.test.framework.by.sdk.settings.already.exist=所選解釋器的 {0} 設定已存在
php.test.framework.by.sdk.settings.remote.path.title=選擇伺服器上的路徑
php.test.framework.by.sdk.settings.select.server=選擇遠端解釋器以組態遠端{0}
php.test.framework.configuration.can.not.update=無法更新 {0} 版本
php.test.framework.configuration.ui.library={0} 庫
php.test.framework.configuration.ui.not.installed=未安裝
php.test.framework.configuration.ui.path.to.exe={0} 可執行檔案路徑:
php.test.framework.configuration.ui.select.interpreter=請選擇 PHP 解釋器以載入 {0} 版本
php.test.framework.configuration.ui.select.local.interpreter=請選擇本地 PHP 解釋器以載入 {0} 版本
php.test.framework.configuration.ui.test.runner=測試執行程序
php.test.framework.configuration.ui.use.configuration.file=預設組態檔案:
php.test.framework.configuration.ui.version={0} 版本: {1}
php.test.framework.configuration.updated.version=已成功更新 {0} 版本
php.test.framework.default.interpreter.is.not.local=無法檢測到 {0} 版本。預設 PHP 解釋器不是本地解釋器
php.test.framework.download.hyperlink={0} 版本: <a href={1}>{1}</a>
php.test.framework.field.test.runner.options=測試執行程序選項(&O):
php.test.framework.interpreter.conflict=發現應用程式級 {0} 組態衝突。為解決該問題，建立了以下組態的專案級副本:
php.test.framework.interpreter.conflict.title={0} 組態衝突
php.test.framework.no.configuration.types.are.available=沒有可用的其他組態類型
php.test.framework.project.level=(當前專案)
php.test.framework.run.configuration.ui.alternative.configuration.file=使用替代組態檔案(&U):
php.test.framework.run.configuration.ui.alternative.custom.file=使用替代 {0}(&U)
php.test.framework.run.configuration.ui.configuration.radio.button=在組態檔案中定義(&C)
php.test.framework.run.configuration.ui.custom.file.radio.button=在 {0} 中定義
php.test.framework.run.configuration.ui.directory.radio.button=目錄 (&D)
php.test.framework.run.configuration.ui.directory.text.field=目錄:
php.test.framework.run.configuration.ui.file.radio.button=檔案(&F)
php.test.framework.run.configuration.ui.file.text.field=檔案:
php.test.framework.run.configuration.ui.scenario.radio.button=方法(&M)
php.test.framework.run.configuration.ui.scenario.text.field=方法:
php.test.framework.run.configuration.ui.scope=測試作用域:
php.test.framework.run.configuration.ui.type.combo.box=類型:
php.test.framework.run.configuration.ui.type.radio.button=類型(&T)
php.test.framework.run.confuguration.ui.dialog.caption.test.runner.options=測試執行程序選項
php.test.framework.select.type.of.settings.popup.title=選擇組態類型
php.test.framework.settings.is.not.provided.or.empty={1} 的 {0} 路徑未組態。按“修復”以編輯您的 {0} 組態。
php.test.framework.undefined.interpreter=未定義
php.test.framework.untrusted.reload=在安全模式下禁止重新整理測試框架的版本
php.test.framework.validation.run.configuration.file.working.directory=檔案應該是工作目錄的子項: ''{0}''
php.test.framework.validation.run.configuration.method=在 ''{1}'' 中找不到 ''{0}''
php.test.framework.validation.run.configuration.no.type=如果未選擇類型則無法執行測試。
php.test.framework.validation.run.configuration.unsupported.type=無法通過 ''{0}'' 指令執行測試。
php.test.framework.validation.run.configuration.working.directory=目錄應該是工作目錄的子目錄: ''{0}''
php.test.framework.version.configuration.ui.can.not.parse.version=無法解析版本指令輸出。\\n{0}
php.test.framework.version.detector.empty.output=''{0}'' 指令輸出為空。
php.test.framework.version.getting.version.title=正在獲取 {0} 版本…
php.test.framework.version.path.to.exe.is.invalid={0} 可執行檔案的路徑為空或無效。
php.test.frameworks.form.application=\\ (應用程式)
php.testframework.local.interpreter=本地解釋器
php.testframework.local.interpreter.version=本地 PHP {0}
php.testframework.remote.interpreter=遠端 {0}
php.title.docker.compose.settings=Docker Compose 設定
php.trait=特徵
php.turn.off.path.modification=關閉 {0} 自訂
php.uml.provider.presentable.name=PHP 類別圖
php.unit.checkbox.use.alternative.patterns.base.path=使用替代模式基路徑:
php.unit.create.target.class.quick.fix.family.name=建立缺少的目標類別
php.unit.create.target.method.quick.fix.family.name=建立缺少的目標方法
php.unit.label.test.file.template=測試檔案模板(&T):
php.unit.local.run.description=PHPUnit
php.unit.local.run.display.name=PHPUnit
php.unit.optional=可選
php.unit.radio.button.composite=複合
php.unit.test.runner.options=測試執行程序選項
php.web.application.name=PHP Web 應用程式
php.web.server.validation.action.text=Web 伺服器偵錯驗證
php.web.server.validation.additional.configuration.files=<b>已解析的其他 .ini 檔案:</b> {0}
php.web.server.validation.chose.path.to.script=選擇驗證腳本的路徑
php.web.server.validation.chose.path.to.script.description=選擇本地目錄以建立驗證腳本
php.web.server.validation.client.host.is.reachable=<b>偵錯用戶端主機</b>: 可以存取
php.web.server.validation.client.host.is.unreachable=<b>偵錯用戶端主機</b>: 無法存取
php.web.server.validation.client.host.is.unreachable.descr=請確保已正確組態 <i>xdebug.remote_host</i> (適用於 Xdebug 2)、<i>xdebug.client_host</i> (適用於 Xdebug 3)或 zend_debugger。值可以是執行 PhpStorm 的機器的主機名(例如，localhost)或 IP 地址，並且必須可以從伺服器 ping 通。使用 Xdebug 時，<i>xdebug.remote_connect_back</i> (適用於 Xdebug 2)或 <i>xdebug.discover_client_host</i> (適用於 Xdebug 3)可用於故障排除。
php.web.server.validation.client.phpstorm.is.reachable=<b>PhpStorm:</b> 準備接收 Xdebug 連線
php.web.server.validation.client.phpstorm.is.unreachable=<b>PhpStorm:</b> 無法接收 Xdebug 連線
php.web.server.validation.client.phpstorm.is.unreachable.descr=偵聽傳入偵錯連線可能被停用，或者可能在設定中為傳入連線指定了錯誤的連接埠
php.web.server.validation.configuration.files=<b>已載入的 php.ini:</b> {0}
php.web.server.validation.configure.local=請組態驗證腳本的本地和 Web 路徑
php.web.server.validation.configure.phpinfo=請貼上 <i>phpinfo()</i> 的完整輸出
php.web.server.validation.configure.phpinfo.desc=複製並貼上 HTML 版本、HTML 源或 <i>php -i</i> 輸出
php.web.server.validation.configure.remote=請組態驗證腳本的路徑並選擇部署伺服器
php.web.server.validation.configure.validation.script=請下載驗證腳本歸檔並指定腳本目錄的 Web 路徑
php.web.server.validation.deployment.server=部署伺服器(&D):
php.web.server.validation.deployment.server.tooltip=所選伺服器會用於將驗證腳本部署到遠端伺服器
php.web.server.validation.dialog.validate.button=驗證(&V)
php.web.server.validation.docker=<b>在 Docker 容器中</b>: {0}
php.web.server.validation.failed.to.deploy.validation.script=無法將驗證腳本部署到伺服器
php.web.server.validation.failed.to.execute.script=指定的 URL 不可到達，原因是: ''{0}''
php.web.server.validation.failed.to.fetch.script.result=無法提取驗證腳本的結果
php.web.server.validation.failed.to.find.deployment.settings=找不到伺服器的部署設定
php.web.server.validation.failed.to.find.web.path=請組態驗證腳本的 Web 路徑
php.web.server.validation.failed.to.map.deployment.folder=請為驗證目錄組態遠端路徑映射
php.web.server.validation.failed.to.map.deployment.folder.to.web=請為驗證目錄組態 Web 路徑映射
php.web.server.validation.failed.to.unzip=無法從 {0} 提取資料
php.web.server.validation.invalid.path.to.script=驗證目錄的路徑無效
php.web.server.validation.loaded.debugger.extension=<b>偵錯器擴展:</b> {0}
php.web.server.validation.local.path.to.script=建立驗證腳本的路徑(&P):
php.web.server.validation.local.path.to.script.tooltip=所選路徑應可通過 Web 伺服器存取
php.web.server.validation.local.web.server.radio=本地 Web 伺服器或共享目錄(&L)
php.web.server.validation.multi.debugger.extension=Xdebug 和 Zend Debugger 擴展均已載入
php.web.server.validation.multi.debugger.extension.description=只有一個偵錯器擴展可在 php.ini 中載入。
php.web.server.validation.no.configuration.files=找不到 php.ini 檔案
php.web.server.validation.no.debugger.extension=未載入偵錯擴展
php.web.server.validation.os=<b>用戶端主機作業系統</b>: {0}
php.web.server.validation.os.server=<b>伺服器主機作業系統</b>: {0}
php.web.server.validation.process.title=驗證 Web 伺服器
php.web.server.validation.reference.to.documentation=請參閱<a href="{0}">{0}</a>獲取更多資訊。
php.web.server.validation.remote.web.server.radio=遠端 Web 伺服器(&R)
php.web.server.validation.script.local.result.path.mapping.check=請檢查是否為 <b>''{0}''</b> 目錄正確組態了驗證腳本的 Web 路徑
php.web.server.validation.script.result.is.empty=驗證腳本的結果為空
php.web.server.validation.script.result.path.mapping.check=請檢查是否在部署設定中為 <b>''{0}''</b> 目錄正確組態了遠端和 Web 路徑映射
php.web.server.validation.script.result.wrong.format=驗證腳本的結果具有意外格式
php.web.server.validation.server.name=<b>伺服器名稱:</b> {0}
php.web.server.validation.server.name.is.empty=伺服器名稱為空
php.web.server.validation.server.name.is.empty.description=伺服器名稱對於 PhpStorm 中的標識是必要的。<br>請在 Web 伺服器組態檔案中進行組態。
php.web.server.validation.synonym=驗證偵錯
php.web.server.validation.synonym2=驗證 Xdebug
php.web.server.validation.title=驗證 Web 伺服器上的偵錯器組態
php.web.server.validation.uploading.validation.script=正在將驗證腳本上傳至 {0}
php.web.server.validation.url.to.validation.script=驗證腳本的 URL(&U):
php.web.server.validation.url.to.validation.script.tooltip=所選 Web 路徑將用於執行驗證腳本
php.web.server.validation.xdebug.debugger.host=<b>遠端主機:</b> {0}
php.web.server.validation.xdebug.debugger.host.description=正在執行偵錯器<b>用戶端</b>的主機。
php.web.server.validation.xdebug.debugger.host.remote.addr=<br/><br/>在 php.ini 檔案中，將 <b>''{0}''</b> 設為 <i>''{1}''</i> 或自 Web 伺服器可見的本地機器 IP 地址。
php.web.server.validation.xdebug.debugger.localhost=儘管伺服器主機可能不在本地，但遠端主機仍組態為 ''{0}''
php.web.server.validation.xdebug.mode.is.not.supported=不支持遠端模式 ''{0}''
php.web.server.validation.xdebug.option.is.enabled=<b>{0}:</b> 選項已啟用
php.web.server.validation.xdebug.option.is.ignored.description=<b>{0}:</b> 選項將被忽略。
php.web.server.validation.xdebug.option.is.not.enabled.description=<b>{0}:</b> 選項未啟用
php.web.server.validation.xdebug.port=<b>遠端連接埠:</b> {0}
php.web.server.validation.xdebug.port.require.sudo=<b>遠端連接埠:</b> {0}，需要根權限才能使用
php.web.server.validation.xdebug.port.require.sudo.description=要在 Linux 和 Mac 上使用小於 1024 的連接埠，必須具有根權限。
php.web.server.validation.xdebug.protocol.is.not.supported=不支持偵錯協議 ''{0}''
php.web.server.validation.xdebug.remote.autostart.description=偵錯會話將嘗試為每個請求啟動。
php.web.server.validation.xdebug.remote.is.not.enable=遠端偵錯未啟用
php.web.server.validation.xdebug.remote.is.not.enable.description=將 <b>''{0}''</b> 行新增到 php.ini 檔案。
php.web.server.validation.xdebug.remote.log=<b>{0}:</b> {1}
php.web.server.validation.xdebug.remote.mode.jit=<b>遠端模式:</b> 'jit'
php.web.server.validation.xdebug.remote.mode.jit.description=偵錯會話將僅在出現錯誤後初始化。
php.web.server.validation.xdebug.remote.mode.req=<b>遠端模式:</b> 'req'
php.web.server.validation.xdebug.remote.mode.req.description=偵錯會話將在腳本啟動時初始化。
php.web.server.validation.xdebug.wrong.port=Xdebug 連接埠(''{0}'')與“PHP->偵錯 IDE”設定(''{1}'')不同
php.web.server.validation.xdebug.wrong.port.description=來自 php.ini (<b>{0}</b>)的 Xdebug 連接埠應與在 IDE 內(在 <b>PHP->偵錯</b>下)組態的連接埠相同。
php.web.server.validation.xdebug.wrong.port.format=<b>Xdebug 連接埠無效:</b> ''{0}''
php.web.server.validation.xdebug.zend.extension.load=Xdebug 必須通過 'zend_extension' 而不是 'extension' 載入
php.web.server.validation.xdebug.zend.extension.load.description=在 php.ini 檔案中使用 <b>'zend_extension=path_to_xdebug.so'</b> 行以載入 Xdebug 擴展。
php.web.server.validation.xdebug3.cloud.php.ini.xdebug.disabled.message=<b>Php.ini 雲偵錯:</b> 已停用。
php.web.server.validation.xdebug3.cloud.xdebug.correct.cloud.id.message=<b>IDE 中的雲 ID:</b> 與伺服器上的雲 ID 相同
php.web.server.validation.xdebug3.cloud.xdebug.disabled.message=<b>通過 Xdebug Cloud 連線:</b> 已停用。請在 IDE 設定中進行啟用: <b>PHP->偵錯->XDebug Cloud</b>
php.web.server.validation.xdebug3.cloud.xdebug.doesnt.accept.connections.message=Xdebug 現在不接受外部連線
php.web.server.validation.xdebug3.cloud.xdebug.wrong.cloud.id.description=<b>IDE 中的雲 ID:</b> {0}<br><b>伺服器上的雲 ID:</b> {1}
php.web.server.validation.xdebug3.cloud.xdebug.wrong.cloud.id.message=<b>IDE 中的雲 ID:</b> 與伺服器上的雲 ID 不同
php.web.server.validation.xdebug3.discover.client=根據 <b>$_SERVER['HTTP_X_FORWARDED_FOR']</b> 和 <b>$_SERVER['REMOTE_ADDR']</b> 中的值，Xdebug 將嘗試自動連線到用戶端。若失敗，則回到 <b>'xdebug.client_host'</b>。
php.web.server.validation.xdebug3.discover.client.message=<b>發現用戶端主機:</b> xdebug 將嘗試自動提取用戶端主機。
php.web.server.validation.xdebug3.discover.client.no=<b>發現用戶端主機</b>: 關閉
php.web.server.validation.xdebug3.discover.client.with.discover.header=根據 <b>$_SERVER[''{0}'']</b> 中的值，Xdebug 將嘗試自動連線到用戶端。若失敗，則以空的 <b>''xdebug.client_discovery_header''</b> 回到 <b>''xdebug.discover_client_host''</b>。
php.web.server.validation.xdebug3.option.in.invalid.mode=''{0}'' 選項設定為 ''{1}''，這對於 xdebug3 是無效模式。
php.web.server.validation.xdebug3.option.is.enabled.message=<b>{0}</b>: 選項被設定為 ''{1}''。
php.web.server.validation.xdebug3.remote.mode.emulation.description=偵錯會話將在腳本啟動時初始化，與 xdebug2 的 <b>remote_mode=''{0}''</b> 相同。
php.web.server.validation.xdebug3.remote.mode.emulation.message=<b>遠端模式:</b> xdebug2 的 ''{0}'' 已模擬。 
php.web.server.validation.xdebug3.start.upon.error.description=偵錯會話將嘗試根據相應組態在錯誤時自動啟動。
php.web.server.validation.xdebug3.start.with.request.description=偵錯會話將嘗試根據相應組態自動啟動。
php.web.server.validation.zend.debugger.deny.host=<b>拒絕主機:</b> {0}
php.web.server.validation.zend.debugger.deny.host.description=無法使用拒絕主機從用戶端進行偵錯。
php.web.server.validation.zend.debugger.host=<b>遠端主機:</b> {0}
php.web.server.validation.zend.debugger.localhost=儘管伺服器不在本地，但偵錯會話僅適用於本地主機。
php.web.server.validation.zend.debugger.localhost.description=將正在執行偵錯器<b>用戶端</b>的主機新增至 <b>'zend_debugger.allow_hosts'</b> 選項。
php.web.server.validation.zend.expose.remotely=<b>屬性 ''expose_remotely''</b> 設為 ''{0}''
php.web.server.validation.zend.expose.remotely.allowed.hosts.description=偵錯器會話將嘗試從 <b>'zend_debugger.allow_hosts'</b> 選項為主機啟動。
php.web.server.validation.zend.expose.remotely.always.description=偵錯器會話將嘗試為每個用戶端啟動。
php.web.server.validation.zend.expose.remotely.never.description=偵錯器會話將不會進行初始化，<b>'zend_debugger.allow_hosts'</b> 選項將被忽略。<br>將選項 <b>'zend_debugger.expose_remotely'</b> 設定為 'allowed_hosts' 或 'always' 以啟用 Web 伺服器偵錯。
php.web/server.validation.validation.script=偵錯驗證腳本
php.xdebug.enable.dfa.assist=預測分析程序數據流的未來條件值
php.xdebug.enable.dfa.assist.gray.mode=將預計無法存取的程式碼塊變灰
php.xdebug.move.to.resolve.breakpoint=如果中斷點與源不同，則將中斷點移動到已解析的位置
phpdoc.code.style.convert.else.if.combine=elseif
phpdoc.code.style.convert.else.if.separate=else if
phpdoc.code.style.convert.else.if.to=將 else if/elseif 轉換為:
phpdoc.code.style.convert.null.to=將 Null 常數轉換為:
phpdoc.code.style.convert.true.false.to=將 True/False 常數轉換為:
phpdoc.code.style.force.null.position=將 'null' 置於以下類型中:
phpdoc.code.style.generated.doc.blocks=生成的 PHPDoc 標記
phpdoc.code.style.in.beginning.position=在開頭
phpdoc.code.style.in.end.position=在結尾
phpdoc.code.style.param.spaces.between.name.and.description=在名稱與描述之間:
phpdoc.code.style.param.spaces.between.tag.and.type=在標記與類型之間:
phpdoc.code.style.param.spaces.between.type.and.name=在類型與名稱之間:
phpdoc.code.style.param.spaces.panel=PHPDoc '@param' 空間
phpdoc.code.style.sort.doc.blocks=PHPDoc 標記順序
phpdoc.code.style.throws.analysis.depth.performance.note.message=不建議深入分析多個級別，因為這可能會影響 IDE 性能。要繼續嗎?
phpdoc.code.style.throws.analysis.depth.performance.note.title=性能註釋
phpdoc.code.style.title=PHPDoc
phpunit.10.won.t.support.classname.annotations=PHPUnit 10 將不支持 ClassName::<*> 註解
phpunit.can.not.rerun.failed.tests.title=無法執行失敗的 PHPUnit 測試。
phpunit.config.directory.label=目錄:
phpunit.config.empty.pattern=空模式
phpunit.config.label=測試根
phpunit.getting.phpunit.version=正在更新 PhpUnit 版本…
phpunit.label.data.set=資料集:
phpunit.not.tests.was.executed.message=要修復，為 <i>{0}</i> <a href="config">組態</a>自動載入檔案或 PHPUnit phar 路徑。
phpunit.not.tests.was.executed.title=未組態 PHPUnit
platform.reqs.are.missing=缺少平台要求。
please.enter.your.password.to.make.install.xdebug.extension=輸入您的密碼以安裝 Xdebug 擴展:
plural.types.are.not.allowed.in.real.types=僅在 doc 類型中允許複數類型
popup.content.configuration.remains.unchanged=當前組態與解釋器同步
popup.content.enabled.disabled.extensions=已啟用{0}和已停用{1}擴展
popup.select.target.code.block.closure=箭頭函式體(轉換為閉包)
popup.select.target.code.block.containing.block=包含塊
popup.title.multiple.write.scopes.found=找到多個寫入作用域
popup.title.select.reference.to.remove=選擇要移除的類型
popup.title.select.target.code.block=選擇目標程式碼塊
possible.tool.process.hangup.after.0.sec={0} 秒後可能工具過程掛起。
postfix.template.provider.display.name=PHP
potentially.polymorphic.call.multiple.subclasses=潛在的多態呼叫。該程式碼可能無法動作，具體取決於作為實參傳遞的實際類別執行個體。
potentially.polymorphic.call.single.subclass=潛在的多態呼叫。{0} 的層次結構中沒有成員
primitive.hints.name.are.forbidden.in.php.7=PHP 7 中禁止名為 'int'、'string'、'float'、'bool'、'true'、'false' 和 'null' 的類別
private.constant.cannot.be.final='private' 常數不能為 'final'，因為它對其他類別不可見
private.methods.cannot.be.final=private 方法不能是 final，因為它們從不會被其他類別覆寫
proceed=繼續
profiler.button.refresh=重新整理
profiler.column.invocation.callable=可調用
profiler.column.invocation.count.title=呼叫
profiler.column.memory.title=記憶體(B)
profiler.column.own.memory.title=自身記憶體(B)
profiler.column.own.time.title=自用時間
profiler.column.script=腳本
profiler.column.time.title=時間
profiler.label.time=時間:
profiler.measurement.unit.microsecond=微秒
profiler.measurement.unit.microsecond.short=µs
profiler.measurement.unit.millisecond=毫秒
profiler.measurement.unit.millisecond.short=毫秒
profiler.measurement.unit.second=秒
profiler.measurement.unit.second.short=秒
profiler.view.call.tree.title=呼叫樹
profiler.view.callees.title=被呼叫方
profiler.view.callers.title=呼叫方
profiler.view.execution.statistics.title=執行統計
profiler.xdebug.file.chooser.title=選擇 Xdebug 分析器快照
profiler.xdebug.task.parsing=正在解析 ''{0}''
profiler.xdebug.task.title=分析 Xdebug 分析器快照
progress.text.fetching.result.from=正在從 {0} 提取結果
progress.text.submitting.code.to.3v4l.org=正在將程式碼提交到 3v4l.org
progress.title.executing.3v4l.org=正在 3v4l.org 上執行程式碼
project.files=專案檔案
project.is.already.disposed=專案已被處置
promoted.property=提升屬性
property=屬性
property.declaration=屬性宣告
property.is.undefined=屬性 '#ref' {0,choice,0#未定義|1#可能未定義}
property.is.undefined.in.class=屬性 ''#ref'' 在 {0} 中{1,choice,0#未找到|1#可能未定義}
property.or.function=屬性或函式
property.read=@property-read
property.write=@property-write
provide.the.full.path.to.executable=提供可執行檔案的完整路徑。
proxy.configuration=代理組態
proxy.init=代理初始化
proxy.stop=代理停止
psr.12.add.missing.parameter.list=PSR-12: 新增缺少的參數列表
psr.12.add.public.visibility=PSR-12: 新增 'public' 可見性
psr.12.convert.to.short.form=PSR-12: 轉換為縮寫
psr.12.extract.namespace=PSR-12: 提取命名空間
psr.12.fix.modifiers.order=PSR-12: 修復修飾符順序
psr.12.replace.var.with.public=PSR-12: 將 'var' 取代為 'public'
psr.12.split.to.several.use.statements=PSR-12: 拆分為多個 'use' 語句
psr.roots.revert=還原
public.and.static='public' 和 'static'
quality.inspection.button.tooltip=該按鈕顯示相應的檢查是否開啟
quality.tool.action.clean.list.text=清除列表
quality.tool.action.remove.file.s.from.list.text=從列表中移除檔案
quality.tool.border.title.ignored.files=已忽略的檔案
quality.tool.button.validate=驗證
quality.tool.can.not.create.temporary.file=PhpStorm 無法建立臨時檔案
quality.tool.can.not.determine.version=無法確定工具版本，得到 ''{0}''
quality.tool.can.not.retrieve.standards=無法檢索可用規則集，請檢查 PHP CS Fixer 工具組態。
quality.tool.checkbox.installed.standard.paths=已安裝的標準路徑:
quality.tool.checkbox.show.sniff.name=顯示 sniff 名稱
quality.tool.checkbox.show.warning.as=將警告顯示為:
quality.tool.coding.stardards.has.been.updated=已安裝的編碼標準列表已更新。
quality.tool.configuration.can.not.find.configuration.by.id=按 ID 找不到 {0} 組態: ''{1}''
quality.tool.configuration.default.interpreter.is.not.found=預設選擇 {0} 組態解釋器，但未指定解釋器
quality.tool.configuration.for.interpreter.is.not.found=找不到解釋器的 {0} 組態: ''{1}''
quality.tool.configuration.interpreter.is.undefined={0} 組態的解釋器未指定或無效
quality.tool.configuration.tool.path.is.empty=所選組態的 {0} 路徑為空
quality.tool.cs.fixer.allow.risky.rules=允許為內建規則集設定有風險的規則
quality.tool.cs.fixer.custom.rules.warning=選擇 'Custom' 類型以選擇您的組態。
quality.tool.cs.fixer.reformat.action=PHP CS Fixer: 修復整個檔案
quality.tool.cs.fixer.ruleset=規則集:
quality.tool.empty.path.phpcs={0} 的路徑為空
quality.tool.file.not.found=找不到檔案。
quality.tool.ignored.files={0} 忽略的檔案
quality.tool.label.check.files.with.extensions=檢查帶副檔名的檔案:
quality.tool.label.coding.standard=編碼標準:
quality.tool.label.configuration=組態:
quality.tool.label.custom.rulesets=自訂規則集:
quality.tool.label.label=標籤
quality.tool.label.tool.path=工具路徑:
quality.tool.label.tool.process.timeout=工具處理超時，[1...60] 秒:
quality.tool.label.validation.label=驗證標籤
quality.tool.laravel.pint=Laravel Pint
quality.tool.laravel.pint.json.path=pint.json 路徑:
quality.tool.laravel.pint.quick.fix.text=Laravel Pint: 修復整個檔案
quality.tool.laravel.pint.reformat.only.uncommitted.files=僅重新格式化未提交的檔案
quality.tool.laravel.pint.ruleset=規則集:
quality.tool.laravel.pint.should.be.json.file=選擇 .json 檔案
quality.tool.path.must.not.be.empty=路徑不得為空。
quality.tool.php.cs.fixer.required.phpcs.version=支援的 PHP CS Fixer 版本為 2.8.0 或更高，找到的是 {0}
quality.tool.php.dir.does.not.contain=該目錄不包含{0}
quality.tool.php_cs.custom.rules.validation.not.php_cs=PHP CS Fixer 不支持所選規則集
quality.tool.php_cs.dir.does.not.contain.custom=此目錄不包含任何受支援的檔案: {0}
quality.tool.phpcbf.location=PHPCBF 位置
quality.tool.phpcbf.location.descr=選擇有效的 phpcbf 啟動器
quality.tool.phpcbf.name=PHP Code Beautifier and Fixer
quality.tool.phpcbf.path=phpcbf 路徑:
quality.tool.phpcbf.reformat.action=PHP Code Beautifier and Fixer: 修復整個檔案
quality.tool.phpcbf.settings=PHP Code Beautifier and Fixer 設定
quality.tool.phpcs.can.not.retrieve.standards=無法檢索可用標準，請檢查 PHP_CodeSniffer 工具組態。
quality.tool.phpcs.custom.rules.validation.not.xml=所選規則集不是 XML
quality.tool.phpcs.custom.rules.warning=選擇 'Custom' 編碼標準類型以選擇自訂規則集。
quality.tool.phpcs.installed.paths=已安裝的標準路徑
quality.tool.phpcs.label.path.to.ruleset=規則集路徑:
quality.tool.phpcs.required.phpcs.version=所需的 PHP_CodeSniffer 版本為 1.5.0 或更高，找到的是 {0}
quality.tool.selected.file.is.not.phpcbf=所選檔案不是 phpcbf 可執行檔案
quality.tool.stardards.has.been.updated=已安裝的規則集列表已更新。
quality.tools.0.added.to.ignored.files.list={0}已新增到忽略的檔案列表。
quality.tools.custom.coding.standard=自訂編碼標準
quality.tools.label.by.default.project.interpreter=預設為專案解釋器
quality.tools.provider.tooltip=此檔案被排除在外部品質工具分析和格式設定外。您可以從忽略的檔案列表中移除該檔案。
quick.fix.delete=刪除 ''{0}''
quick.fix.error=快速修復錯誤
quickfix.access.static.via.class.reference=取代為 ''{0}''
quickfix.add.to.use=新增到閉包 'use' 建構
quickfix.can.not.find.class.reference.name=無法按名稱尋找類別
quickfix.can.not.find.dynamic.method.reference=找不到動態方法參照
quickfix.can.not.find.static.method.reference=找不到 static 方法參照
quickfix.cannot.find.class.reference=找不到要解析的類別參照
quickfix.cannot.find.target.class=無法從參照 ''{0}'' 解析類別
quickfix.case.sensitive.name=更改 {0} 的大小寫以符合其宣告
quickfix.change.field.type.add.inferred.type.error.non.project=無法修改非專案檔案 ''{0}''
quickfix.change.field.type.add.inferred.type.error.read.only=無法修改唯讀檔案 ''{0}''
quickfix.change.field.type.add.inferred.type.family.name=作為屬性的類型新增推斷的類型
quickfix.change.field.type.add.inferred.type.name=作為屬性的類型新增 ''{0}''
quickfix.change.field.type.to.match.super=更改類型以符合父項
quickfix.change.field.type.to.match.super.0=將類型更改為 ''{0}'' 以匹配父項
quickfix.change.field.type.to.match.super.remove=移除類型宣告以符合父項
quickfix.change.type=更改為 ''{0}''
quickfix.change.type.declaration.family=更改類型
quickfix.convert.arrayfill.to.loop=將 'array_fill()' 呼叫轉換為迴圈
quickfix.convert.arrayfilter.to.loop=將 'array_filter()' 呼叫轉換為迴圈
quickfix.convert.arraymap.to.loop=將 'array_map()' 呼叫轉換為迴圈
quickfix.convert.loop.to.arrayfilll=將迴圈轉換為 'array_fill()' 呼叫
quickfix.convert.loop.to.arrayfilter=將迴圈轉換為 'array_filter()' 呼叫
quickfix.convert.loop.to.arraymap=將迴圈轉換為 'array_map()' 呼叫
quickfix.convert.to.new.style.constructor=將建構函式轉換為新樣式
quickfix.create.class=建立類別
quickfix.create.field.from.callback.invalid.element=無法從回調提取屬性名稱
quickfix.create.field.from.callback.name=從回調建立屬性
quickfix.create.field.from.callback.unresolved.class.ref=無法從回調建立屬性。無法解析目標類別參照。
quickfix.create.function.from.callback.family.name=從回調建立函式
quickfix.create.function.from.callback.name=新增函式
quickfix.create.method.from.callback.name=從回調建立方法
quickfix.create.parameter=建立參數
quickfix.delete.return.argument=刪除返回實參
quickfix.disable.inspection.for.global.namespace=為全域命名空間停用檢查
quickfix.failed.to.create.class=無法建立類別 ''{0}''
quickfix.import.base.no.candidates=找不到要匯入的候選項
quickfix.import.class.name=匯入類別
quickfix.import.class.popup.title=要匯入的類別
quickfix.import.constant.name=匯入常數
quickfix.import.constant.popup.title=要匯入的常數
quickfix.import.function.name=匯入函式
quickfix.import.function.popup.title=要匯入的函式
quickfix.is.not.available.in.dump.mode=在索引更新期間，''{0}'' 快速修復不可用
quickfix.make.call.static.name=將呼叫設為 static
quickfix.make.method.static=設為 'static'
quickfix.move.class.to.corresponding.directory=移至目錄 ''{0}''
quickfix.move.class.to.corresponding.directory.error.file.exists=檔案 {0} 已存在
quickfix.move.class.to.corresponding.directory.error.unable.create.directories=無法建立缺少的目錄: ''{0}''
quickfix.move.class.to.corresponding.directory.error.unable.move.file=無法將檔案移至目錄 ''{0}''
quickfix.multiple.target.class.resolve=類別 ''{0}'' 有多個宣告
quickfix.navigate.to.duplicate.array.key=導覽到重複鍵
quickfix.navigate.to.duplicate.case.value=導覽到重複的 case 值
quickfix.navigate.to.duplicate.condition=導覽到重複條件
quickfix.non.strict.object.equality=非嚴格物件相等比較
quickfix.overriding.method.visibility=移除可見性覆寫
quickfix.php.missing.param.type.batch.description=作為屬性類型新增推斷的類型
quickfix.php.missing.param.type.description=作為參數類型新增 ''{0}''
quickfix.phpdoc.update.field.type=將屬性類型更改為 ''{0}'' 以匹配 PHPDoc 註釋
quickfix.phpdoc.update.type=更新 PHPDoc 類型
quickfix.phpunit.assert.equals.flip.compared.arguments=翻轉比較實參
quickfix.phpunit.create.target.class.error.filename.exists=存在檔案 {0}
quickfix.phpunit.drop.redundant.optional.parameters=刪除冗餘的可選參數
quickfix.phpunit.replace.current.method.with.alternative=取代為 ''{0}''
quickfix.remove.condition.from.default.arm=從 'default' arm 中移除非 'default' 條件
quickfix.remove.default.arm=移除重複的 'default' match arm
quickfix.remove.duplicate.condition=移除重複條件
quickfix.remove.match.arm=移除 'match' arm
quickfix.remove.phpdoc=移除冗餘 PHPDoc 註釋
quickfix.remove.phpdoc.param.tag=移除 @param 標記
quickfix.remove.phpdoc.return.tag=移除 @return 標記
quickfix.remove.phpdoc.signature.tags=移除不必要的 @param 和 @return 標記
quickfix.remove.redundant.phpdoc.tags=移除所有冗餘的 PHPDoc 標記
quickfix.remove.type=移除類型 ''{0}''
quickfix.remove.unnecessary.qualifier=移除不必要的限定符
quickfix.remove.unnecessary.qualifier.on.class.name=簡化 FQN
quickfix.remove.unused.condition=移除未使用的條件
quickfix.replace.assignment.operator.with.prefix.expression.family.name=將指派運算符取代為前綴表達式
quickfix.replace.assignment.with.operator.assignment.family.name=將指派取代為運算符指派
quickfix.replace.assignment.with.operator.assignment.name=將 ''='' 取代為 ''{0}=''
quickfix.replace.assignment.with.prefix.expression.family.name=將指派取代為前綴表達式
quickfix.replace.curly.braces.with.brackets=將大括號取代為中括號
quickfix.replace.nested.ternary.expression=將三元表達式取代為 {0} 關聯版本
quickfix.replace.one.operator.with.another=將 ''{0}'' 取代為 ''{1}''
quickfix.set.inheritance.between.classes=使{0} {1} {2}
quickfix.strict.type.checking.change.parameter.type.family=更改參數類型
quickfix.strict.type.checking.change.parameter.type.name=將{0, choice, 1#第 1 個|2#第 2 個|3#第 3 個|4#第 {0,number} 個}參數的類型從 ''{1}'' 更改為 ''{2}''
quickfix.strict.type.checking.change.return.type.family=更改返回值類型
quickfix.strict.type.checking.change.return.type.name=將返回值類型從 ''{0}'' 更改為 ''{1}''
quickfix.strict.type.checking.extend.return.type.family=擴展返回值類型
quickfix.strict.type.checking.extend.return.type.name=將返回值類型從 ''{0}'' 擴展為 ''{1}''
quickfix.undefined.function.add.function=新增函式
radio.button.by.concatenation=通過串聯(&C)
radio.button.by.embeding=通過嵌入(&E)
radio.button.class.constructor=類別建構函式(&S)
radio.button.const=const(&C)
radio.button.copy.from.base.class=從基類別複製(&P)
radio.button.current.method=當前方法(&T)
radio.button.default=預設(&F)
radio.button.default.empty.template=預設/空模板(&E)
radio.button.define=定義(&D)
radio.button.field.declaration=屬性宣告(&D)
radio.button.private=private(&I)
radio.button.protected=protected(&O)
radio.button.public=public(&U)
radio.button.setup=設定(&U)
radio.button.with.inheritdoc.tag=帶有 @inheritDoc 標記(&I)
radio.for.all.properties=適用於所有方法
radio.only.for.properties.without.declared.type=適用於沒有宣告類型的方法
reading.and.writing.creates.files.if.not.exists.fails.otherwise=讀/寫。如果檔案不存在則建立檔案，如果找到檔案則失敗。
reading.and.writing.start.at.the.beginning.of.the.file=讀/寫。從檔案開頭開始。
reading.and.writing.start.at.the.beginning.of.the.file.and.truncate.the.file.to.zero.length.creates.files.if.not.exists=讀/寫。從檔案開頭開始，將其截斷為零長度。如果檔案不存在則建立檔案。
reading.and.writing.start.at.the.the.end.of.the.file.creates.files.if.not.exists=讀/寫。從檔案末尾開始。如果檔案不存在則建立檔案。
reading.and.writing.starts.at.the.beginning.of.the.file.creates.files.if.not.exists=讀/寫。從檔案開頭開始。如果檔案不存在則建立檔案。
reading.only.start.at.the.beginning.of.the.file=唯讀。從檔案開頭開始。
readonly.property.cannot.have.default.value='readonly' 屬性不能具有預設值
readonly.property.must.have.type='readonly' 屬性必須指定類型
recursive.call=遞迴呼叫
redefinition.of.parameters.is.not.allowed=不允許參數重新定義
refactoring.common.fail.to.extract.expression=無法從所選程式碼段中提取表達式
refactoring.common.not.extractable.expression=不支持此類別表達式
refactoring.common.not.supported.context=當前上下文不支持{0}
refactoring.common.not.supported.expression.in.scope=當前作用域不支持此類別表達式的{0}
refactoring.common.ui.target.directory.edit=按 F2 編輯目標目錄
refactoring.common.ui.target.directory.label=目標目錄(&D):
refactoring.common.ui.target.namespace.label=命名空間(&N):
refactoring.common.validation.class.psi=無法執行重構: 目標類別“{0}”無效
refactoring.common.validation.namespace.name=“{0}”不是有效的命名空間名稱
refactoring.common.validation.target.directory.is.not.valid=目錄“{0}”的路徑無效
refactoring.common.validation.target.directory.not.inside.project=目錄“{0}”不在專案內部
refactoring.copy.class.name=複製類別
refactoring.extract.base.dialog.replace.all.occurrences=取代所有符合項(找到 {0} 個匹配項)(&A)
refactoring.extract.base.handler.no.expression.selected=選擇不構成正確的表達式
refactoring.extract.base.handler.not.supported.expression=此類別表達式不支持{0}
refactoring.extract.base.handler.not.supported.scope=當前作用域不支持{0}
refactoring.extract.base.validator.not.valid.identifier=“{0}”不是有效的 PHP 關鍵字。
refactoring.extract.base.validator.reserved.keyword=“{0}”是保留的 PHP 關鍵字。
refactoring.extract.class.conflicts.extract.class.refactoring.is.not.supported.for.dynamically.declared.properties.usages=動態宣告屬性用法不支持“提取類別”重構
refactoring.extract.class.conflicts.method.0.depends.on.1.constant.2=方法“{0}”依賴於 {1} 常數“{2}”
refactoring.extract.class.conflicts.method.0.depends.on.1.method.2=方法“{0}”依賴於 {1} 方法“{2}”
refactoring.extract.class.conflicts.method.0.depends.on.property.1.which.needs.getters.in.2=方法“{0}”依賴於屬性 "\${1}"，需要“{2}”中的 getter
refactoring.extract.class.conflicts.method.0.depends.on.property.1.which.needs.setters.in.2=方法“{0}”依賴於屬性 "\${1}"，需要“{2}”中的 setter
refactoring.extract.class.conflicts.unable.to.add.delegate.property.initialization.to.constructor=無法將委託的屬性初始化新增到類別建構函式
refactoring.extract.class.conflicts.unable.to.add.delegate.property.initialization.to.constructor.trait.constructor.will.be.overridden=無法將委託的屬性初始化新增到類別建構函式: 特徵建構函式將被覆寫
refactoring.extract.class.conflicts.using.write.access.for.non.public.properties.in.array.destructuring.expressions.is.not.supported.in.extract.class.refactoring=“提取類別”重構不支持將寫入權限用於陣列解構表達式中的非 public 屬性
refactoring.extract.class.conflicts.using.write.access.for.non.public.properties.in.multiple.assignment.expressions.in.extract.class.refactoring=“提取類別”重構不支持將寫入權限用於多個指派表達式中的非 public 屬性
refactoring.extract.class.dialog.class=類別名:
refactoring.extract.class.dialog.generate.accessors=生成存取器(&G)
refactoring.extract.class.dialog.members.to.be.extracted=要提取的成員
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.abstract.methods=抽象方法不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.anonymous.classes=匿名類別不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.anonymous.functions=匿名函式不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.doc.methods=通過 PHPDoc 定義的魔術方法不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.doc.properties=通過 PHPDoc 定義的魔術屬性不支持 Extract Class 重構
refactoring.extract.class.error.failed.to.create.file=無法建立檔案
refactoring.extract.class.error.the.selected.function.should.belong.to.project.sources=所選函式必須屬於專案源
refactoring.extract.class.extract.to.class=提取到類別
refactoring.extract.class.extracting.from.class=正在從類別提取:
refactoring.extract.class.extracting.from.file=正在從檔案提取:
refactoring.extract.constant.conflict.already.exists=作用域中已經存在名稱為“{0}”的常數。
refactoring.extract.constant.conflict.cannot.override.interface.constant=無法覆寫接口“{1}”的常數“{0}”
refactoring.extract.constant.conflict.exists.in.subclass=“{0}::{1}”將被此常數覆寫
refactoring.extract.constant.conflict.exists.in.subclass.with.weaker.access=“{0}”的存取級別必須為“{1}”(如在類別“{2}”中)或更弱
refactoring.extract.constant.name=提取常數
refactoring.extract.constant.unable.to.add.constant.declaration="無法新增常數宣告"
refactoring.extract.field.conflict.already.exists=該類中已經存在名稱為“{0}”的屬性。
refactoring.extract.field.name=提取屬性
refactoring.extract.field.validator.reserved.field.name=“{0}”是保留的屬性名稱
refactoring.extract.field.visibility=可見性
refactoring.extract.field.visibility.private=private(&I)
refactoring.extract.field.visibility.protected=protected(&O)
refactoring.extract.field.visibility.public=public(&U)
refactoring.extract.interface.fail.to.create.file=無法建立檔案 ''{0}''。
refactoring.extract.interface.field=接口名稱(&I):
refactoring.extract.interface.invalid.caret.location=文字游標應置於要重構的類別名處。
refactoring.extract.interface.invalide.extract.from.trait=無法從特徵提取接口。
refactoring.extract.interface.members.title=要構成接口的成員(&B)
refactoring.extract.interface.name=提取接口
refactoring.extract.interface.no.methods=沒有要提取到接口的方法。
refactoring.extract.interface.phpdoc.copy=複製(&C)
refactoring.extract.interface.phpdoc.do.nothing=保留原樣(&A)
refactoring.extract.interface.phpdoc.move=移動(&M)
refactoring.extract.interface.phpdoc.title=PhpDoc
refactoring.extract.interface.title=從類別 ''{0}'' 提取接口
refactoring.extract.interface.validation.members.modifier=對於每個提取的方法，修飾符將更改為 public。
refactoring.extract.method.error.a.set.of.statements.should.be.from.the.same.code.block=一組語句應來自同一程式碼塊。
refactoring.extract.method.error.inconsistent.return.points.in.selected.code.fragment=所選程式碼段中的返回點不一致。
refactoring.extract.method.error.selected.block.should.represent.a.set.of.statement.or.an.expression=所選塊應代表一組語句或表達式。
refactoring.extract.method.error.there.are.break.continue.operators.which.can.interrupt.execution=存在會中斷執行的 break/continue 運算符。
refactoring.extract.method.from.duplicate.code=從重複的程式碼中提取方法
refactoring.extract.method.name=提取函式/方法
refactoring.extract.method.tooltip=輸入 $name = 'init'
refactoring.extract.parameter.name=提取參數
refactoring.extract.replace.class.reference=盡可能將類別參照取代為接口(&F)
refactoring.extract.variable.conflict.already.exists=作用域中已經存在名稱為“{0}”的變數。
refactoring.extract.variable.name=提取變數
refactoring.inline.cannot.find.variable.to.inline=找不到要內聯的變數
refactoring.inline.constant.all.references.and.keep=全部內聯並保留常數
refactoring.inline.constant.all.references.and.remove=全部內聯並移除常數
refactoring.inline.constant.cannot.extract.value=無法提取常數的值
refactoring.inline.constant.command=內聯常數
refactoring.inline.constant.is.never.used=常數 {0} 從未使用
refactoring.inline.constant.multiple.declarations=還有其他具有相同名稱的常數宣告。
refactoring.inline.constant.name=內聯常數
refactoring.inline.constant.this.reference.only=僅內聯此參照並保留常數
refactoring.inline.function.all.invocations.and.remove.the.method=全部內聯並移除{0}(&A)
refactoring.inline.function.all.invocations.keep.the.method=全部內聯並保留{0}(&E)
refactoring.inline.function.cannot.find.function.declaration=找不到函式宣告
refactoring.inline.function.cannot.inline.constructor=無法內聯建構函式
refactoring.inline.function.cannot.inline.first.class.callable.declaration=無法內聯一級可調用宣告
refactoring.inline.function.cannot.inline.function.with.global.usage=無法內聯{0}和 <code>global</code> 用法
refactoring.inline.function.cannot.inline.library.function=無法內聯庫函數
refactoring.inline.function.cannot.inline.magic.method=無法內聯魔術方法
refactoring.inline.function.cannot.inline.overridden.method=無法內聯被覆寫的方法
refactoring.inline.function.cannot.parse.function.body=無法解析函式體
refactoring.inline.function.command=正在內聯{0}
refactoring.inline.function.inline.function.refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow=當 return 語句中斷執行流程時，不支持內聯函式重構
refactoring.inline.function.not.accessible.from.caller.site=無法從呼叫者站點存取成員參照 <code>{0}</code>
refactoring.inline.function.only.static.method.is.supported=僅支援 static 方法
refactoring.inline.function.parent.reference.unresolved=<code>parent</code> 類別參照在 {0} 中未解析
refactoring.inline.function.reference.is.recursive=不支持遞迴呼叫
refactoring.inline.function.this.invocation.only.and.keep.the.method=僅內聯此呼叫並保留{0}(&K)
refactoring.inline.function.title=內聯{0}重構
refactoring.inline.function.yield.found.in.function.body=在函式體中找到 <code>yield</code> 用法
refactoring.inline.variable.cannot.extract.value=無法提取變數 ''\${0}'' 的值
refactoring.inline.variable.no.occurrences=沒有符合項可以被安全地內聯
refactoring.inline.variable.unary.operation=無法內聯到遞減或遞增運算
refactoring.inplace.extract.method.name=就地提取函式/方法
refactoring.make.method.static=將方法設為 static
refactoring.make.method.static.add.parameters.for.fields=新增屬性參數(&P):
refactoring.make.method.static.doc.method.is.not.supported=不支持文檔方法
refactoring.make.method.static.dynamic.method.call.found=執行個體物件應作為參數傳遞，找到動態方法呼叫: {0}
refactoring.make.method.static.magic.method=魔術方法不能設為 static
refactoring.make.method.static.method.calls.found.in.static.context=在 static 上下文中找到方法呼叫
refactoring.make.method.static.method.converts.method.to.static=將方法轉換為 static
refactoring.make.method.static.method.is.overridden=方法 {0} 被覆寫
refactoring.make.method.static.object.is.needed=方法 {0} 使用未作為參數傳遞的屬性 {1}
refactoring.make.method.static.private.field.is.not.accessible=private 屬性 {0} 無法從類別外部存取
refactoring.make.method.static.protected.field.is.not.accessible=protected 屬性 {0} 無法從類別及其繼承者外部存取
refactoring.make.method.static.references.to.be.changed=待更改參照 {0}
refactoring.make.method.static.this.found=執行個體物件應作為參數傳遞，找到 $this
refactoring.make.method.static.writeAccess=檢測到 {0} 寫入存取，執行個體物件應作為參數傳遞。
refactoring.make.static.then.move.method.message=方法 ''{0}'' 將被設為 ''public static''
refactoring.make.static.then.move.method.select=將方法 ''{0}'' 移至類別
refactoring.move.class.action.name=移動類別…
refactoring.move.class.cannot.move.anonymous.class=無法移動匿名類別
refactoring.move.class.in.non.code.message=註釋和字串中的類別參照
refactoring.move.class.name=移動類別
refactoring.move.class.new.file=將類別提取到單獨的檔案(&E)
refactoring.move.class.title=將類別 {0} 移至命名空間(&C):
refactoring.move.classes.dnd.files.with.the.same.name.error=單個目標中不允許有多個同名檔案。
refactoring.move.classes.dnd.name=移動類別
refactoring.move.classes.dnd.title=將所選{0,choice,0#類別|1#命名空間|2#類別和命名空間}移至命名空間:
refactoring.move.constant.action.name=移動常數…
refactoring.move.constant.class.already.contains.constant=類別 {0} 已包含常數 {1}
refactoring.move.constant.class.already.contains.method=類別 {0} 已包含方法 {1}
refactoring.move.constant.label.text.field=將常數 {0} 移至類別(&C)
refactoring.move.constant.title=移動常數
refactoring.move.constant.unable.to.resolve=無法解析 {0}
refactoring.move.function.action.name=移動函式…
refactoring.move.function.interface.cant.contain.method=接口中不允許帶有主體的方法
refactoring.move.function.label.text.field=將函式 {0} 移至類別(&C)
refactoring.move.function.title=移動函式
refactoring.move.instance.method=移動執行個體方法
refactoring.move.instance.method.action.name=移動執行個體方法…
refactoring.move.instance.method.preview.header=要移至另一個類別的方法
refactoring.move.instance.method.this.parameter.label=將取代類別 {0} 的 $this 參照的參數名稱
refactoring.move.instance.method.usage.will.not.be.accessible=用法 {0} 將無法存取。應提高方法可見性
refactoring.move.member.action.name=移動成員…
refactoring.move.member.method.is.overridden.in.a.sublclass={0} 在子類別 {1} 中被覆寫
refactoring.move.member.title=移動 static 成員
refactoring.move.members.0.will.be.hidden.in.1=成員 {0} 將在 {1} 中被隱藏
refactoring.move.members.cannot.find.target.class=找不到類別 {0}
refactoring.move.members.class.0.does.not.exist=類別 {0} 不存在。\\n是否要建立?
refactoring.move.members.enum.0.already.contains.case.with.name.0=枚舉 {0} 已經包含名稱為 ''{1}'' 的 case
refactoring.move.members.enum.0.already.contains.case.with.value.1=枚舉 {0} 已經包含值為 ''{1}'' 的 case
refactoring.move.members.is.not.a.valid.class.name=“{0}”不是有效的類別名
refactoring.move.members.is.not.accessible={0} 在 {1} 中無法存取
refactoring.move.members.late.static.binding.detected=檢測到延遲 static 綁定: {0}
refactoring.move.members.late.static.binding.detected.in.doc=在文檔中檢測到延遲 static 綁定
refactoring.move.members.member.will.change.visibility.to.public=成員 {0} 會將可見性更改為 public
refactoring.move.members.method.implements.abstract.method={0} 在 {1} 中實作 abstract 方法
refactoring.move.members.method.implements.method.in={0} 在 {1} 中實作方法
refactoring.move.members.move.as.enum.cases=作為枚舉 case 移動
refactoring.move.members.no.members.are.selected=未選擇成員
refactoring.move.members.only.constants.can.be.moved.to.interface=只有常數可以移至接口
refactoring.move.members.preview.header=要移至另一個類別的成員
refactoring.move.members.properties.can.not.be.moved.to.enum=屬性不能移動到枚舉
refactoring.move.members.self.from.anonymous.class=無法處理對匿名類別的自參照
refactoring.move.members.there.are.several.classes.with.specified.name=存在多個具有指定名稱 {0} 的類別
refactoring.move.members.to.be.moved=要移至另一個類別的成員(&B)
refactoring.move.members.unable.to.resolve.usage.callback.found=無法解析用法: 發現回調: {0}
refactoring.move.members.unable.to.resolve.usage.late.static.binding.detected=無法解析用法: 檢測到延遲 static 綁定: {0}
refactoring.move.method.cannot.move.constructor=無法移動建構函式
refactoring.move.method.cannot.move.magic.method=無法移動魔術方法
refactoring.move.method.label.text.field=將成員移至類別(&C)
refactoring.move.multiple.constant.label.text.field=將 {0} 個常數移至類別(&C)
refactoring.move.multiple.functions.label.text.field=將 {0} 個函式移至類別(&C)
refactoring.move.namespace.action.name=移動命名空間…
refactoring.move.namespace.header.message=移動命名空間
refactoring.move.namespace.in.non.code.message=註釋和字串中的命名空間參照
refactoring.move.namespace.message=要移動的命名空間
refactoring.move.namespace.name=移動命名空間
refactoring.move.namespace.new.namespace=新命名空間名稱(&N):
refactoring.move.namespace.title=移動命名空間 {0}
refactoring.move.related.namespace.collect.title=收集子命名空間
refactoring.move.related.namespace.description=將具有相關命名空間的檔案移至新目錄:
refactoring.move.related.namespace.directory.column=新增目錄
refactoring.move.related.namespace.name.column=新命名空間名稱
refactoring.move.related.namespace.title=移動具有相關命名空間的檔案
refactoring.parameter.reserved.name=參數名稱“{0}”已保留
refactoring.parameter.validation=參數 {0} 無效
refactoring.parameter.validation.default.value=預設值表達式 ''{0}'' 無效
refactoring.parameter.validation.duplicate.parameter=重複的參數名稱: {0}
refactoring.parameter.validation.initializer=初始設定式 ''{0}'' 無效
refactoring.parameter.validation.initializer.last=必選參數不能位於可選參數後
refactoring.parameter.validation.initializer.type=具有類別類型提示的參數的預設值只能為 NULL
refactoring.parameter.validation.name.collision.with.use.list=參數名稱 ''{0}'' 無效。''{0}'' 已匯入 use 列表
refactoring.parameter.validation.no.default.value=應該為參數 ''{0}'' 提供初始設定式或預設值
refactoring.parameter.validation.pass.by.reference=僅變數可通過參照傳遞
refactoring.parameter.validation.type=參數類型 ''{0}'' 無效
refactoring.parameter.validation.variadic.can.have.default.value=可變參數不能具有預設值
refactoring.parameter.validation.variadic.last=只有最後一個參數可以是可變形參
refactoring.php.cannot.create.class=無法在預覽中建立新類別
refactoring.php.create.class=建立新類別
refactoring.php.extract.enum=提取枚舉
refactoring.pull.up.abstract.method=類別 {0} 將被標記為 abstract
refactoring.pull.up.class.does.not.have.base.classes.interfaces.in.project.files={0}在專案檔案中沒有基類別/接口
refactoring.pull.up.conflict.duplicate.constant={0} 將與 {1} 中的常數衝突。
refactoring.pull.up.implement.method=在實作接口的類別中建立方法存根(&S)
refactoring.pull.up.is.1.and.will.not.be.accessible.in.the.target.class={0} 為 private，在目標類別中將無法存取。
refactoring.pull.up.may.not.be.accessible.in.the.target.class={0} 在目標類別中可能無法存取。
refactoring.pull.up.private.access={0} 存取權限將更改為 {1}
refactoring.pull.up.static.reference.is.not.accessible.in.the.target.class=非 static 方法 {0} 不應在外部類中靜態呼叫
refactoring.pull.up.validation.field.into.interface=無法將屬性拉入接口
refactoring.pull.up.validation.static.method.into.interface={0} 為 static，不能為 abstract。
refactoring.pull.up.will.not.be.accessible.in.the.target.class={0} 在目標類別中將無法存取。
refactoring.push.down.method.implemented.in.interface={0} 必須被宣告為 abstract 或實作 {1}
refactoring.push.down.validation.magic.method=移動魔術方法會產生副作用
refactoring.rename.automatic.renamer.accessors.name=重新命名存取器(&C)
refactoring.rename.automatic.renamer.class.dialog.description=將具有以下名稱的類別重命名為:
refactoring.rename.automatic.renamer.class.dialog.title=重新命名類別
refactoring.rename.automatic.renamer.class.entity.name=類別
refactoring.rename.automatic.renamer.class.name=重新命名類別(&C)
refactoring.rename.automatic.renamer.field.accessors.dialog.description=將具有以下名稱的屬性存取器重命名為:
refactoring.rename.automatic.renamer.field.accessors.dialog.title=重新命名存取器
refactoring.rename.automatic.renamer.field.accessors.entity.name=存取器
refactoring.rename.entity.name.inheritor=繼承者/檔案
refactoring.rename.inheritors.and.related.files.with.the.following.names.to=將具有以下名稱的繼承者和相關檔案重命名為:
refactoring.rename.search.in.global.scope=在全域作用域中搜尋
refactoring.returnType.validation.type=返回值類型 ''{0}'' 無效
refactoring.validation.class.error.property.with.name.0.is.already.exists=已存在名稱為“{0}”的屬性
reference=參照
referenced.calls=參照的呼叫
reformats.file.with.0=使用 ''{0}'' 重新格式化檔案
register.ide=註冊 IDE
relationship.already.exists={0} 與 {1} 之間的關係已存在
release.name.eg.5.1.2.release=發佈名稱。例如，5.1.2-RELEASE
remote.connection.settings.default.remote.interpreter=預設遠端解釋器
remote.connection.settings.interpreter.is.not.remote=當前專案解釋器非遠端解釋器
remote.interpreter.browse.action.is.not.supported.for.docker=基於 Docker 的遠端解釋器不支持瀏覽動作
remote.interpreter.can.t.be.executed.please.enable.the.php.remote.interpreter.plugin=無法執行遠端解釋器。啟用 PHP Remote Interpreter 延伸模組。
remote.interpreter.path.mappings.validation.message=請檢查映射是否在 {0} 下正確組態。
remote.interpreter.path.mappings.validation.php.section=<b><i><a href="php_mappings">設定|PHP</a></i></b>
remote.interpreter.path.mappings.validation.title=沒有為所選解釋器組態路徑映射。
remove=移除
remove.assignment=移除指派
remove.else=移除 else…
remove.from.function.0.declaration=從函式 ''{0}'' 宣告中移除 ''\\\\&''
remove.from.ignored.list=移除
remove.from.the.parameter.0=從參數 ''{0}'' 中移除 ''\\\\&''
remove.link.between.0.and.1=移除 {0} 與 {1} 之間的連結
remove.numeric.literals.separators=移除數字文字分隔符
remove.pass.by.ref=移除 '\\\\&'
remove.pass.by.ref.sign=移除 '\\\\&'
remove.redundant.initializer=移除冗餘的初始設定式
remove.redundant.suppression.quick.fix.family.name=移除 ''{0}'' 禁止
remove.relationship.link=移除關係連結
remove.rule=移除規則
remove.unnecessary.parentheses=移除不必要的圓括號
remove.unnecessary.reset=移除不必要的 'reset'
remove.unnecessary.semicolon=移除不必要的分號
remove.variable=移除變數
rename=重新命名
rename.constructor=重新命名建構函式
rename.filename.quick.fix=將檔案 ''{0}'' 重命名為 ''{1}''
rename.parameter.dialog.description=將層次結構中的參數重命名為:
rename.parameters.dialog.title=重新命名參數
rename.psi.element.quick.fix=將{0} ''{1}'' 重命名為 ''{2}''
replace.all.occurrences.with.php=將所有符合項取代為 '<?php'
replace.all.occurrences.with.php.echo=將所有符合項取代為 '<?php echo'
replace.all.occurrences.with.short.php.echo=將所有符合項取代為 '<?='
replace.all.occurrences.without.side.effects=取代所有無副作用的符合項
replace.deprecated.from.of.callable=取代已棄用的可呼叫物件形式
replace.extends.implements=取代 'extends'/'implements'
replace.if.clause.with.ternary.expression=將 if 子句取代為三元表達式
replace.if.with.switch=將 'if' 取代為 'switch'
replace.plus.asgn.to.concat.asgn.quick.fix.family.name=將 '+=' 取代為 '.='
replace.plus.to.concat.quick.fix.family.name=將 '+' 取代為 '.'
replace.qualifier.with.an.import=將限定符取代為匯入
replace.quotes=取代引號
replace.ternary.expression.with.if.clause=將三元表達式取代為 if 子句
replace.unnecessary.double.quotes=取代不必要的雙引號
replace.variable.assignment.with.named.argument=將變數指派取代為命名實參
replace.with.0=取代為 {0}
replace.with.01=取代為 {0}
replace.with.absolute.reference=取代為絕對參照
replace.with.alias=取代為別名
replace.with.alias.from.target.scope=取代為目標作用域中的別名
replace.with.anonymous.function=取代為匿名函式
replace.with.array=取代為直接指派 '$array = array($value)'
replace.with.array.short.syntax=取代為直接指派 '$array = [$value]'
replace.with.arrow.function=取代為箭頭函式
replace.with.coalesce.operator=取代為合併運算符
replace.with.first.class.callable.family.name=取代為一級可調用語法
replace.with.pow.operator=取代為 '**' 運算符
replace.with.quest=取代為 '?'
require='必需'
required.parameters.missing=缺少所需參數 ''{0}''
required.trait.0.wasn.t.added.to.1=所需特徵 ''{0}'' 未新增到 ''{1}''
rerun.with.ignore.platform.reqs=使用 --ignore-platform-reqs 重新執行
return.type=返回值類型
return.type.declaration.is.not.allowed=不允許返回值類型宣告
return.type.declaration.must.be.compatible.with.super=返回值類型宣告必須與父級相容
returned.by.iterator.aggregate.should.be.traversable=\\\\IteratorAggregate::getIterator() 返回的物件必須為 Traversable 或實作接口 Iterator
rfc.2822.rfc.5322.formatted.date=RFC 2822/RFC 5322 格式的日期({0})
robo=Robo
robo.task.method=Robo 任務方法
run.install.update.with.platform.reqs=使用 --ignore-platform-reqs 執行安裝/更新(&R)
run.with.paratest=使用 ParaTest 執行
run.with.paratest.mnemonic=使用 ParaTest 執行 %s
searching.for.usages=正在搜尋用法…
seconds.since.the.unix.epoch.january.1.1970.00.00.00.gmt=自 Unix 時間戳 1970 年 1 月 1 日 00:00:00 GMT 以來的秒數({0})
seconds.with.leading.zeros=帶前導零的秒(00 到 59)
select.composer.phar.and.provide.the.full.path.to.it.or.select.download.composer.stable.phar.from.getcomposer.org=選擇 'composer.phar' 並提供其完整路徑，或者選擇“從 getcomposer.org 下載 composer-stable.phar”。
select.composer.phar.and.provide.the.full.path.to.it.or.select.download.composer.stable.phar.from.getcomposer.org1=選擇 'composer.phar' 並提供其完整路徑，或者選擇“從 getcomposer.org 下載 composer-stable.phar”。
server=伺服器
set=設定
set.close.on.exec.flag.on.the.opened.file.descriptor.only.available.in.php.compiled.on.posix.1.2008.conform.systems=在檔案檔案描述子上設定 close-on-exec 標誌。僅適用於符合 POSIX.1-2008 標準的系統。
set.the.following.option=設定以下選項:
settings.smart.keys.auto.insert.closing.html.tag.in.php.doc=在 PHPDoc 塊中自動插入 HTML 結束標記
settings.smart.keys.auto.insert.semicolon=在函式呼叫內部鍵入時自動插入分號 
settings.smart.keys.auto.insert.tag.after.typing=輸入 '<?' 後自動插入 '<?php' 標記
settings.smart.keys.enable.smart.function.parameters.completion=啟用智能函式參數補全
settings.smart.keys.escape.symbols.on.paste.in.string.literals=在字串文字中貼上時轉義符號
settings.smart.keys.find.usages.of.base.method.prompt=搜尋方法用法時顯示其他選項
settings.smart.keys.remove.php.open.close.tags.while.pasting.in.php.context=在 PHP 上下文中貼上時移除 PHP 開始/結束標記
settings.smart.keys.replace.unnecessary.double.quotes.on.paste=貼上時取代不必要的雙引號
settings.smart.keys.select.variable.name.without.dollar.sign.on.double.click=在雙擊時選擇不帶 '$' 符號的變數名
settings.smart.keys.title=PHP
short.arrow.function.cannot.return.void=箭頭函式不能有 'void' 返回值類型
show.0.settings.window=顯示 ''{0}'' 設定視窗
show.composer.settings.action.name=顯示 Composer 設定
show.constants=顯示常數
show.implementations.for.0={0} 的實作
show.includes=顯示 Include
show.log=顯示日誌
show.log.of.composer.related.actions=顯示 Composer 相關動作的日誌
show.name.for.all.arguments=顯示所有實參的名稱
show.private.members=顯示 private 成員
show.properties=顯示屬性
show.protected.members=顯示 protected 成員
show.settings=顯示設定
show.super.types.for.0=顯示 {0} 的父類型
show.validation.dialog=顯示“驗證偵錯器”對話框
shows.0.dialog=顯示 ''{0}'' 對話框
shows.dialog.with.methods.from.implemented.interface.selected.methods.will.be.inserted.into.the.class.after.dialog.confirmation=顯示包含已實作接口中方法的對話框。對話框確認後，所選方法將被插入到類別中。
shows.list.of.child.classes.with.inaccessible.methods=顯示具有不可存取方法的子類別列表
shows.list.of.child.classes.without.without.resolved.member=顯示沒有已解析成員的子類別列表
simulating.update=正在模擬更新
skip.constant.params=跳過使用常數參數的呼叫
smarty=Smarty
smarty.configurable.title=Smarty
sort.by.visibility=按可見性排序
sort.the.elements.by.visibility.public.protected.private=按可見性對元素排序: public、protected、private
split.elseif=拆分 'elseif'
split.selected.group.use.statement=拆分所選 'use' 語句組
spread.operator.on.named.arguments.is.forbidden=禁止對命名實參使用展開運算符
spread.operators.in.arrays.are.not.supported.for.multiassignments.variables=多指派變數不支持在陣列中使用展開運算符
squash.repetitive.underscores=壓縮重複下劃線
static.is.not.allowed.in.compile.time.constants=編譯時常量中不允許使用 'static::'
static.is.not.allowed.in.parameter.type.declaration=參數類型宣告中不允許 'static'
static.modifier.is.not.allowed.here=此處不允許使用 'Static' 修飾符
static.property.cannot.be.readonly='static' 屬性不能為 'readonly'
static.property.cannot.be.unset=static 屬性不能取消設定
static.value=static 值
status.text.no.dependencies=無相依項
strict.type.declaration.is.available.in.php.7.only=從 PHP 7.0 起才允許使用嚴格類型宣告
strict.types.declaration.must.have.0.or.1.as.its.value='strict_types' 宣告的值必須為 0 或 1
summary=摘要
suppress.all.for.file=對檔案全部禁止
suppress.for.field=對欄位禁止
suppress.for.file=對檔案禁止
suppress.for.function=對函式禁止
suppress.for.method=對方法禁止
suppress.for.phpdoc.comment=對 PhpDoc 註釋禁止
suppress.if.annotated.by.tag=如果用 ''{0}'' 註解，則禁止
suppress.unused.preview=對使用 ''{0}'' 註解的實體禁止“未使用的宣告”檢查
suppressed.annotation.title=已禁止的註解
surround.with.0=使用 ''{0}'' 包圍
surround.with.if.0.1=使用 ''if({0}({1}))'{'...'}''' 包圍
swatch.internet.time=Swatch 互聯網時間(000 到 999)
switch.statements.may.only.contain.one.default.clause.in.php.7=在 PHP 7 中，switch 語句只能包含一個 'default' 子句
switch.with.common.parts=包含通用部分的 'switch'
switching.from.another.vs.code.sublime.text.or.another.ide.check.out.our.migration.guides.to.get.started.faster=從 VS Code、Sublime Text 或其他 IDE 切換而來? 請檢視我們的遷移指南以更快地開始使用。
target=目標
target.class=目標類別:
target.directory.for.validation.script.is.not.public=驗證腳本的目標目錄不是 public。
target.trait.should.be.specified=應指定目標特徵
template.debug.cache.dir.is.incorrect=模板偵錯: 在設定中指定的快取目錄路徑無效
template.debug.cache.dir.is.not.specified=模板偵錯: 未在設定中指定快取目錄路徑
template.debug.cache.path=快取路徑:
template.debug.path.to.output.folder=快取目錄路徑
template.debug.path.to.output.folder.descr=指定快取目錄路徑
template.debug.php.file.not.found=模板偵錯: 未找到 {0} 的相應 PHP 檔案
template.parameter=模板參數
template.smart.completion.function.parameters.description=智能函式參數補全
terminal.add.interpreter.to.path=將預設專案 PHP 解釋器新增到 {0}
ternary.condition.can.be.replaced.with.condition.expression=表達式可以安全地取代為 ''{0}''
test.not.tests.was.executed.title=未組態 {0}。按 ''修正'' 安裝 composer 軟體套件。
text.plain=文本/純
the.button.shows.whether.inspection.is.on.or.off=該按鈕顯示檢查是開啟還是關閉
the.day.of.the.year.starting.from.0=一年中的第幾天(0 至 365)
the.original.class.0.does.not.belong.to.the.project.and.cannot.be.modified=原始類別 {0} 不屬於該專案\\n並且無法修改。
the.remote.hosts.access.plugin.is.missing.please.enable.the.plugin.in.0.plugins=缺少 ''FTP/SFTP/WebDAV Connectivity'' 和 ''Terminal'' 延伸模組中的一個或兩個。請在“{0} | 延伸模組”中啟用延伸模組。
the.result.of.validation.will.be.fetched.by.http.request=驗證結果將通過 http 請求提取。
the.same.as.p.but.returns.z.instead.of.00.00.available.as.of.php.8.0=與 P 相同，但返回 Z 而不是 +00:00，從 PHP 8.0 起可用(+02:00)
the.use.keyword.must.be.declared.in.the.outermost.scope.of.a.file.the.global.scope.or.inside.namespace.declarations=必須在檔案的最外側作用域(全域作用域)或命名空間宣告內部宣告 'use' 關鍵字
the.yield.expression.can.only.be.used.inside.a.function='yield' 表達式只能在函式中使用
there.are.errors.on.attempt.to.load.debug.extension.e.g.version.incompatibility=嘗試載入偵錯擴展時出錯，例如版本不相容。
this.is.the.default.contains.all.modes.in.the.sequence.s.n.r.v.m=這是預設值。包含序列 "s n r v m" 中的所有模式
this.reassignment.is.not.allowed=不能重新分配 $this
this.will.remove.relationship.link.between.classes=這將移除類別之間的關係連結並修改類別 {0}。繼續?
timezone.abbreviation.if.known.otherwise.the.gmt.offset=時區縮寫(如果已知)，否則為 GMT 偏移量(EST、MDT、+05)
timezone.identifier=時區關鍵字(UTC、GMT、大西洋/亞速爾群島)
timezone.offset.in.seconds=以秒為單位的時區偏移量(-43200 到 50400)
tooltip.configured.php.language.level.widget=已組態的 PHP 語言級別
tooltip.configured.php.language.level.widget.composer=通過 Composer 組態的 PHP 語言級別
tooltip.defaults.to.project.folder=預設為專案目錄
tooltip.from=來自{0}:
tooltip.from.volumes=來自{0}卷:
tooltip.update=更新 {0}
tooltip.wsl2.mappings=WSL2 映射
trailing.comma.is.not.allowed=不允許尾隨逗號
trait.already.contains.method=特徵 {0} 已包含方法 {1}
trait.expected.class.found=應為特徵，發現類別
trait.method.0.will.not.be.applied.because.it.collides.with.1=由於與 ''{1}'' 衝突，因此不會套用特徵方法 ''{0}''
trait.use.rule.type.name=特徵 use 規則方法
transform=轉換
turn.off.external.formatter=關閉外部格式化程序
turn.off.inspection.tool=關閉 {0} 檢查
type=類型
type.0.cannot.be.part.of.an.intersection.type=類型 ''{0}'' 不能是交叉類型的一部分
type.0.is.redundant.as.it.is.more.restrictive.than.type.1=類型 ''{0}'' 冗餘，因為它比類型 ''{1}'' 更加嚴格
type.contains.both.true.and.false.bool.should.be.used.instead=類型同時包含 true 和 false，應改用布爾
type.primitive.false.null.hints.names.are.forbidden=從 PHP 8.0 起才允許使用名為 'false' 和 'null' 的類型提示
type.primitive.true.hints.names.are.forbidden=從 PHP 8.2 起才允許使用名為 'true' 的類型提示
types.not.supported.as.operands.for.0.1.2=''{1} {0} {2}'' 中不受支援的動作數類型將導致 PHP 8 TypeError
uml.0.already.exists.in.class.1=類別 {1} 中已經存在 ''{0}''
uml.wrong.name=錯誤的名稱
undefined.interpreter=未定義的解釋器
unhandled.0=未處理的{0}
unhandled.exceptions=未處理的異常
union.types.and.the.nullable.type.notation.cannot.be.mixed=聯合類型和可為 null 類型表示法不能混合
union.types.mixed.cannot.be.nullable=混合類型不能為可 null，'null' 已是混合類型的一部分
unknown=未知
unknown.debugger.type=未知偵錯器類型
unknown.named.parameter=未知命名參數 ''{0}''
unnamed.variable=(未命名)
unnecessary.local.variable=不必要的區域變數
unsupported.declare.0=不支持的宣告 ''{0}''
untrusted.composer.dialog.text=正在安裝或更新相依項，或者執行 Composer 指令可能會執行潛在的惡意程式碼。\\n\\n如果不信任此源，請繼續使用安全模式。
unused.code.rules=未使用的程式碼規則
unwrap.dowhile=解包 do-while…
unwrap.else=解包 else…
unwrap.elseif=解包 elseif…
unwrap.for=解包 for…
unwrap.foreach=解包 foreach…
unwrap.if=解包 if…
unwrap.method=解包 ''{0}''
unwrap.switch=解包 switch…
unwrap.try=解包 try…
unwrap.while=解包 while…
update.php.doc.type.comment=取代為 ''{0}''
update.php.doc.type.family.name=更新 PHPDoc 類型
update.signature.to.match.phpdoc.comment=更新簽名以符合 PHPDoc 註釋
uppercase.ante.meridiem.and.post.meridiem.am.pm=大寫上午和下午(AM/PM)
url.to.validation.script='驗證腳本的 URL'
usage.in.extends.clause=etends 子句中的用法
usage.in.implements.clause=implements 子句中的用法
usage.in.import.statement=import 語句中的用法
usage.in.return.type=返回值類型中的用法
usage.in.type.hinting=類型提示中的用法
usage.of.intersection.types.grouping.is.allowed.only.as.part.of.union.type=交叉類型分組僅允許作為聯合類型的一部分使用
usages.show.this.self.references=顯示 $this/自參照
use.0.in.callables.is.deprecated=在可呼叫物件中使用 ''{0}'' 已棄用
using.this.when.not.in.object.context=不在物件上下文中時使用 '$this'
validated.web.server.is.not.running=驗證的 Web 伺服器未執行。
validating=正在驗證
validating1=正在驗證…
validation.0.extension.is.installed.check.configuration.options=已安裝 ''{0}'' 擴展。檢查組態選項。
validation.0.extension.is.not.installed=未安裝 ''{0}'' 擴展
validation.0.is.not.a.directory=''{0}'' 不是目錄
validation.0.not.found.at.1=在 ''{1}'' 中找不到 ''{0}''
validation.cannot.parse.value.of.0=無法解析 ''{0}'' 的值
validation.class.already.exists={0}中已經存在具有相同名稱的類別
validation.class.cannot.be.overridden=類別“{0}”不能被覆寫
validation.class.not.valid.name=“{0}”不是有效的類別名
validation.connection.was.not.established=未建立連線。
validation.connection.was.not.established.0=無法使用 ''{0}'' 啟動偵錯器會話
validation.connection.was.not.established.no.debug=未安裝偵錯擴展
validation.connection.was.not.established.update.info=更新解釋器資訊
validation.connection.was.not.established.validate.installation=驗證安裝
validation.debug.extension.is.updated=偵錯擴展設定已更新。請重新執行當前組態以使用新值。
validation.file.already.exists=檔案“{0}”已存在
validation.file.already.exists.in.dir=名稱為“{0}”的檔案已存在於“{1}”中
validation.file.not.valid.name=“{0}”不是有效的檔名
validation.function.already.exists=當前命名空間中已定義具有相同名稱的函式
validation.interface.cannot.be.overridden=無法實作接口“{0}”
validation.invalid.alias=“{0}”不是有效的別名
validation.invalid.identifier=“{0}”不是有效的關鍵字
validation.invalid.identifier.with.no.identifier=插入的關鍵字無效
validation.namespace.already.exists={1}中已定義名稱為 ''{0}'' 的命名空間
validation.namespace.not.valid.name=“{0}”不是有效的命名空間名稱
validation.no.debug.extension.is.installed=未安裝偵錯擴展。
validation.press.fix.to.edit.project.configuration=按“修復”編輯您的專案組態。
validation.script.was.created.but.it.cannot.be.executed.check.possible.reasons=驗證腳本已建立，但無法執行。可能的原因:
validation.script.will.be.created.in.0.directory=驗證腳本將在 {0} 目錄中建立。
validation.script.will.be.created.in.0.directory.and.deployed.to.the.1.server=驗證腳本將在 {0} 目錄中建立並部署到 {1} 伺服器。
validation.script.will.be.created.locally.and.deployed.to.the.remote.server=驗證腳本將在本地建立並部署到遠端伺服器。
validation.script.will.be.created.locally.and.the.result.will.be.fetched.by.http.request=驗證腳本將在本地建立，其結果將通過 http 請求提取。
validation.ssh.remote.code.coverage.support={0} 擴展不支持通過 ssh 進行程式碼覆蓋
validation.ssh.remote.debug.support=''{0}'' 擴展不支持通過 ssh 進行遠端偵錯。
validation.test.no.test.patterns=未新增任何模式
validation.value.is.invalid={0} 無效
validation.value.is.not.specified.or.invalid={0} 未指定或無效。
validation.value.is.not.specified.or.invalid.press.fix.project.configuration={0} 未指定或無效。按“修復”編輯您的專案組態。
validation.value.is.not.specified.press.fix.project.configuration={1} 組態中未指定 {0}。按“修復”以編輯 {1} 組態。
validation.value.path.to.value.is.invalid=無法通過 {1} 中提供的路徑找到 {0}
validation.value.path.to.value.is.invalid.press.fix.project.configuration=無法通過 {1} 中提供的路徑找到 {0}。按“修復”以編輯 {2} 組態。
validation.value.path.to.value.should.be.specified={0} 的路徑應在 {1} 中指定
validation.vendor.doesnt.exit=供應商目錄不存在
value=值
variable=變數
variable.always.have.value.0=到達時變數始終為 '{0,choice,0#false|1#true}'
variable.dereferenced=已取消參照變數
variable.naming.style.camel.case=駝峰式命名法
variable.naming.style.mixed=混合
variable.naming.style.panel=變數命名樣式
variable.naming.style.snake.case=snake_case
variable1=變數
variadic.parameter.cannot.have.a.default.value=可變參數不能具有預設值
version.information.varies.a.lot.between.operating.systems=版本資訊。不同作業系統之間差異很大
void.can.only.be.used.as.return.type=Void 只能用作返回值類型
void.type.cannot.be.nullable=void 類型不能是可為 null
waiting.for.3v4l.org.response=正在等待 3v4l.org 響應…
whether.it.s.a.leap.year.1.or.0=是否為閏年(1 或 0)
whether.or.not.the.date.is.in.daylight.saving.time.1.or.0=日期是否為夏令時(1 或 0)
while=while
with.data.set.0=使用資料集 {1} 的 {0}
working.directory.invalid=找不到工作目錄 ''{0}''
writing.only.creates.files.if.not.exists.fails.otherwise=只寫。如果檔案不存在則建立檔案，如果找到檔案則失敗。
writing.only.start.at.the.beginning.of.the.file.and.truncate.the.file.to.zero.length.creates.files.if.not.exists=只寫。從檔案開頭開始，將其截斷為零長度。如果檔案不存在則建立檔案。
writing.only.start.at.the.the.end.of.the.file.creates.files.if.not.exists=只寫。從檔案末尾開始。如果檔案不存在則建立檔案。
writing.only.starts.at.the.beginning.of.the.file.creates.files.if.not.exists=只寫。從檔案開頭開始。如果檔案不存在則建立檔案。
xdebug.cloud.cannot.connect=無法連線到 Xdebug Cloud
xdebug.cloud.cannot.connect.unknown.host=Xdebug Cloud 無法存取: {0}
xdebug.cloud.cannot.open.new.debug.connection=打不開新的偵錯連線
xdebug.cloud.cannot.register.cloud.id=無法在 Xdebug Cloud 上註冊 Cloud ID
xdebug.cloud.cannot.register.cloud.id.unexpected.response=由於意外響應，無法註冊 Cloud ID
xdebug.cloud.validation.cloud.id.not.defined=Cloud ID 未定義
xdebug.cloud.validation.host.not.defined=未定義本地部署 Xdebug Cloud 主機
xdebug.cloud.validation.port.invalid=本地部署 Xdebug Cloud 連接埠無效
xdebug.compile.task=編譯 Xdebug 擴展
xdebug.initializing.connection.debugger=偵錯器
xdebug.initializing.connection.failed.with.timeout=無法連線到 {0}: 超時
xdebug.initializing.connection.xdebug.cloud=Xdebug Cloud
xdebug.initializing.debugger.connection=正在連線到 {0}…
xdebug.validation.download.script.label=下載腳本指令:
xdebug.validation.ip.not.found=在自動檢測到的 IDE IP 中找不到 {0}
xdebug.validation.ip.not.found.descr=自動檢測的 IDE IP: {0}
you.are.configuring.debug.extension.in.the.wrong.php.ini.see.the.loaded.php.ini.files.below=您正在錯誤的 php.ini 中組態偵錯擴展(請參見下方已載入的 php.ini 檔案)。
you.can.always.add.a.precise.exclusion.via.alt.enter.and.then.edit.it.to.broaden.as.needed=您始終可以通過 Alt-Enter 組合鍵新增精確排除，然後根據需要對其進行編輯以擴大範圍。
you.did.not.reload.web.server.after.changes.in.php.ini.file=在 php.ini 檔案中進行更改後，未重新載入 Web 伺服器。
zend.debugger.settings.broadcasting.is.already.launched=Zend Debugger 設定廣播已啟動"
`;

exports[`dev messages/SvnBundle.properties 1`] = `
"action.DumbAware.RepositoryBrowserDialog.text.branch.or.tag=分支或標記…
action.DumbAware.RepositoryBrowserDialog.text.move.or.rename=移動或重新命名(_M)…
action.DumbAware.SvnConfigureProxiesComponent.description.add=新增
action.DumbAware.SvnConfigureProxiesComponent.description.copy=複製
action.DumbAware.SvnConfigureProxiesComponent.text.add=新增
action.DumbAware.SvnConfigureProxiesComponent.text.copy=複製
action.EditCommitMessage.description=編輯修訂註釋。覆寫上一條訊息。
action.EditCommitMessage.text=編輯修訂註釋
action.IntegrateChangeSetAction.text=整合到分支
action.Subversion.BrowseSVNRepository.description=瀏覽 Subversion 版本庫
action.Subversion.BrowseSVNRepository.text=瀏覽 Subversion 版本庫(_W)…
action.Subversion.CleanupProject.description=對專案中的所有工作副本目錄執行清理
action.Subversion.CleanupProject.text=清理專案
action.Subversion.Clenaup.description=解鎖鎖定的目錄，並執行其餘所有未完成的動作
action.Subversion.Clenaup.text=清理(_E)
action.Subversion.CompareWithBranch.text=與分支比較…
action.Subversion.ConfigureBranches.text=組態分支…
action.Subversion.Copy.description=將選定的檔案或目錄複製到新的版本庫位置
action.Subversion.Copy.text=分支或標記(_B)…
action.Subversion.Ignore.ExactMatch.description=將所有所選檔案的名稱新增到目錄忽略列表
action.Subversion.Ignore.ExactMatch.text=所選檔名
action.Subversion.Ignore.MatchExtension.description=將 {0} 遮罩新增到目錄忽略列表
action.Subversion.ImportToSVNRepository.text=匯入 Subversion(_M)…
action.Subversion.Lock.description=鎖定檔案
action.Subversion.Lock.text=鎖定(_L)…
action.Subversion.MarkResolved.description=將文本和屬性衝突標記為已解決
action.Subversion.MarkResolved.text=標記為已解決(_M)…
action.Subversion.MarkTreeResolved.text=將樹衝突標記為已解決…
action.Subversion.PropertiesView.AddProperty.description=新增新屬性
action.Subversion.PropertiesView.AddProperty.text=新增屬性
action.Subversion.PropertiesView.Close.description=關閉此工具視窗
action.Subversion.PropertiesView.Close.text=關閉
action.Subversion.PropertiesView.DeleteProperty.description=刪除選定屬性
action.Subversion.PropertiesView.DeleteProperty.text=刪除屬性
action.Subversion.PropertiesView.EditKeywords.description=管理 svn:keywords 屬性
action.Subversion.PropertiesView.EditKeywords.text=編輯關鍵字
action.Subversion.PropertiesView.EditProperty.description=編輯選定屬性值
action.Subversion.PropertiesView.EditProperty.text=編輯屬性
action.Subversion.PropertiesView.FollowSelection.description=跟隨選擇
action.Subversion.PropertiesView.FollowSelection.text=跟隨選擇
action.Subversion.PropertiesView.Refresh.description=重新載入屬性
action.Subversion.PropertiesView.Refresh.text=重新整理
action.Subversion.Relocate.description=將工作副本重定位到其他 URL
action.Subversion.Relocate.text=重定位…
action.Subversion.RepositoryBrowser.Checkout.text=簽出(_C)…
action.Subversion.RepositoryBrowser.CompareWith.text=比較物件…
action.Subversion.RepositoryBrowser.CopyUrl.text=複製 URL…
action.Subversion.RepositoryBrowser.Export.text=匯出(_E)…
action.Subversion.Resolve.description=解決檔案中的文本衝突
action.Subversion.Resolve.text=解決文本衝突(_S)…
action.Subversion.SelectAllRevisions.description=全選
action.Subversion.SelectAllRevisions.text=全選
action.Subversion.SetProperty.description=在檔案或目錄中設定版本化屬性
action.Subversion.SetProperty.text=設定屬性(_T)…
action.Subversion.Share.text=共享目錄(_S)…
action.Subversion.ShareWholeProject.text=共享專案(Subversion)…
action.Subversion.ShowIntegratePanel.text=顯示整合面板
action.Subversion.ShowMergeSourceDetails.text=顯示合併原始碼詳細資訊
action.Subversion.ShowProperties.text=編輯屬性(_P)
action.Subversion.TogglePropertiesDiff.description=顯示 SVN 屬性的差異
action.Subversion.TogglePropertiesDiff.text=顯示屬性
action.Subversion.UndoIgnore.description=從目錄忽略列表中移除檔名/遮罩
action.Subversion.UndoIgnore.text=所選檔名
action.Subversion.Unlock.description=解鎖檔案
action.Subversion.Unlock.text=解鎖(_O)
action.Subversion.UnselectAllRevisions.description=取消全選
action.Subversion.UnselectAllRevisions.text=取消全選
action.Subversion.cleanup.error.message=對 ''{0}'' 執行清理時出錯: {1}
action.Subversion.cleanup.progress.title=Subversion 清理
action.Subversion.integrate.changes.actionname=整合到分支…
action.Subversion.integrate.changes.branch.info.source.label.text=源分支 URL: {0}
action.Subversion.integrate.changes.branch.info.target.label.text=目標分支 URL: {0}
action.Subversion.integrate.changes.collecting.changes.to.commit.task.title=正在收集要提交的更改
action.Subversion.integrate.changes.description=將選定的更改列表/更改集整合到選定的分支
action.Subversion.integrate.changes.dialog.add.wc.text=新增
action.Subversion.integrate.changes.dialog.remove.wc.text=移除
action.Subversion.integrate.changes.error.unable.to.collect.changes.text=收集要提交的更改時出錯: {0}
action.Subversion.integrate.changes.message.another.wc.text=所選目標位於另一個版本庫的工作副本內。仍要繼續?
action.Subversion.integrate.changes.message.files.up.to.date.text=所有檔案均為最新
action.Subversion.integrate.changes.message.not.under.control.text=所選目標不在 Subversio 的控制下。仍要繼續?
action.Subversion.integrate.changes.messages.title=整合到分支
action.Subversion.integrate.changes.progress.integrating.text=正在合併更改
action.Subversion.integrate.changes.select.working.copy.text=整合到工作副本:
action.Subversion.integrate.difference.option.use.ancestry.text=使用以前的版本(&U)
action.Svn.RefreshWorkingCopies.description=重新整理工作副本資訊
action.Svn.RefreshWorkingCopies.text=重新整理
action.Svn.Show.Working.Copies.description=顯示工作副本資訊: 工作副本格式和 URL
action.Svn.Show.Working.Copies.text=顯示工作副本
action.mark.list.as.merged.description=將所選修訂版標記為已合併，但實際沒有合併
action.mark.list.as.merged.text=標記為已合併
action.mark.list.as.not.merged.description=將所選修訂版標記為未合併，但不會更改 svn:mergeinfo 之外的任何內容
action.mark.list.as.not.merged.text=標記為未合併
action.name.configure.branches=組態分支
action.name.ignore.files=新增忽略檔案遮罩
action.name.mark.resolved=標記已解決
action.name.merge.from=合併自
action.name.merge.from.ellipsis=合併自…
action.name.refresh=重新整理
action.name.resolve.conflict=解決衝突
action.name.revert=還原(&R)
action.name.set.property=設定屬性
action.name.show.properties=顯示屬性
action.name.switch=切換
action.name.undo.ignore.files=從忽略列表移除檔名(或遮罩)
action.new.remote.folder.text=新增遠端目錄…
action.repository.browser.history.description=顯示歷史記錄
action.repository.browser.history.text=顯示歷史記錄
action.share.whole.project.text=共享專案(Subversion)…
action.text.annotate=註解
action.title.select.configuration.directory=更改組態目錄
add.files.errors.title=新增檔案時出錯
annotation.original.revision=原始修訂
annotation.show.merge.sources.default.text=在歷史記錄和註解中顯示合併原始碼
browse.changes.settings.stop.on.copy=複製時停止(&S)
button.copy=複製
button.keep=保留
button.load.quantity=載入 +{0}
button.merge.all=全部合併
button.merge.selected=合併所選內容
button.move=移動
button.resolve.conflict.accept.theirs=接受他們的更改
button.resolve.conflict.accept.yours=接受您的更改
button.resolve.conflict.merge=合併
button.select=選擇
button.share=共享
button.text.clear.authentication.cache=清除身份驗證快取(&C)
button.text.deselect.all=取消全選(&D)
button.text.edit.proxies=編輯網絡選項(&O)…
button.text.select.all=全選(&A)
button.text.ssh.accept=是 (_Y)
button.text.ssh.reject=否 (_N)
button.text.ssl.accept=接受(_A)
button.text.ssl.reject=拒絕(_R)
changes.browser.revision.term=修訂
checkbox.auth.keep.for.current.session=儲存憑證(&S)
checkbox.changes.filter.filter.by.author=作者(&U):
checkbox.checkin.auto.update.after.commit=提交後自動更新
checkbox.checkin.keep.files.locked=保持檔案鎖定(&K)
checkbox.checkout=簽出
checkbox.create.tags.branches=建立 /tags 和 /branches
checkbox.force.update=強制更新(&F)
checkbox.ignore.externals=忽略外部項(&E)
checkbox.ignore.whitespace.when.merge.text=&忽略空格
checkbox.include.externals.locations=包括外部項位置
checkbox.include.ignored.resources=包含忽略的資源
checkbox.replace.existing.files=取代現有檔案
checkbox.set.property.update.properties.recursively=遞迴更新屬性(&R)
checkbox.ssl.keep.for.current.session=儲存憑證(&S)
checkbox.svn.ssh.cache.fingerprint=將密鑰新增到 Subversion 快取(&A)
checkbox.switch.to.newly.created.branch.or.tag=將 {0} 切換到新增的分支或標記
checkbox.update.switch.configurable.to.specific.revision=更新/切換到特定版本(&R):
checkbox.update.switch.configurable.try.merge.without.changes=嘗試合併，但不做任何更改(&T)
checkin.different.formats.involved={0,choice,0#版本庫|1#版本庫} {1} 的選定更改\\n\\
屬於不同格式的 Subversion 工作副本。\\n\\
提交將分為多個提交。\\n\\
\\n\\
您可以在“更改 | Subversion 工作副本資訊”中將所有工作副本轉換為相同格式。\\n\\
是否要繼續提交?
checkin.operation.name=提交(_I)
checkout.dialog.button=檢出
checkout.dialog.title=從 Subversion 簽出
checkout.directory.chooser.prompt=選擇要從 Subversion 簽出的目錄
checkout.directory.chooser.title=簽出目錄
checkout.options.checkout.label=檢出:
checkout.options.dialog.title=SVN 簽出選項
checkout.repository=正在簽出版本庫…
checkout.repository.canceled=簽出已取消
checkout.repository.failed=簽出失敗
checkout.repository.tooltip=該專案將在完成簽出後開啟
checkout.stop.message.description=確定要停止簽出 {0} 版本庫嗎?
checkout.stop.message.title=停止簽出
cleanup.action.name=清理
column.name.merge.sources=合併原始碼
column.name.property.name=名稱
column.name.property.value=值
combobox.crlf.none=無
command.line.interactive.mode.description=<html>模擬直接從終端執行 Subversion 指令時的行為(互動模式)。<br>這是處理 svn+ssh 版本庫的密碼/密碼短語提示以及信任 https 版本庫的無效伺服器憑證所必需的。</html>
command.line.interactive.mode.title=啟用互動模式
committed.changes.action.enable.merge.highlighting=醒目提示已整合的更改列表
committed.changes.action.enable.merge.highlighting.description.text=選項僅適用於 SVN 版本庫和 1.5 版本的工作副本
committed.changes.action.merge.highlighting.refresh.description=重新整理合併的修訂資訊
committed.changes.action.merge.highlighting.refresh.text=重新整理
compare.with.branch.diff.title=與分支比較
compare.with.branch.error.title=與分支比較
compare.with.branch.location.error=在分支 ''{1}'' 下找不到檔案 ''{0}'' 的版本庫位置\\n\\
請檢查您的分支組態。
compare.with.branch.popup.title=與分支比較
compare.with.branch.progress.loading.content=載入內容中…
configurable.SvnConfigureProxiesComponent.display.name=HTTP 代理組態
configurable.name.svn.general=Subversion
configurable.name.svn.network=網絡
configurable.name.svn.presentation=表示
configurable.name.svn.ssh=SSH
configure.branches.branch.locations=分支位置:
configure.branches.error.wrong.url=主幹位置必須在版本庫根 ''{0}'' 下
configure.branches.title=組態 Subversion 分支
configure.branches.trunk.location=主幹位置:
configure.revision.head.radio=HEAD
configure.revision.specified.radio=指定的
confirmation.resolve.tree.conflict.merge.moved=將 {0} 中的更改應用到本地移動的 {1}?
confirmation.resolve.tree.conflict.merge.renamed=將 {0} 中的更改套用到本地重新命名的 {1}?
confirmation.text.add.dir=是否要安排將以下目錄新增到 Subversion?\\n\\
{0}
confirmation.text.add.file=是否要安排將以下檔案新增到 Subversion?\\n\\
{0}
confirmation.text.delete.dir=是否要安排將以下目錄從 Subversion 刪除?\\n\\
{0}\\n\\
注意: 提交更改後，該目錄將從磁碟中刪除。
confirmation.text.delete.dir.17=是否要安排將以下目錄從 Subversion 刪除?\\n\\
{0}
confirmation.text.delete.file=是否要安排將以下檔案從 Subversion 刪除?\\n\\
{0}
confirmation.text.delete.stored.authentication.information=您將刪除所有存儲的 Subversion 身份驗證資訊。\\n\\
確定要刪除嗎?
confirmation.text.edit.file=您要編輯的檔案在編輯前需要鎖定
confirmation.title.add.file=新增的時間表
confirmation.title.add.multiple.files=選擇要新增到 Subversion 的檔案
confirmation.title.clear.authentication.cache=清除身份驗證快取
confirmation.title.delete.file=計劃刪除
confirmation.title.delete.multiple.files=選擇要從 Subversion 刪除的檔案
conflict.action.add=新增
conflict.action.delete=刪除
conflict.action.edit=編輯
conflict.action.replace=取代
conflict.operation.merge=合併
conflict.operation.none=無
conflict.operation.switch=切換
conflict.operation.update=更新
conflict.reason.added=新增
conflict.reason.deleted=刪除
conflict.reason.edited=編輯
conflict.reason.missing=缺少
conflict.reason.moved.away=移開
conflict.reason.moved.here=已移到此處
conflict.reason.obstructed=障礙
conflict.reason.replaced=取代
conflict.reason.unversioned=未進行版本管理
copy.column.title=複製
copy.column.tooltip=從 {0} 複製
copy.dialog.title=分支或標籤
delete.files.errors.title=刪除檔案時出錯
dialog.Subversion.select.working.copy.title=組態工作副本路徑
dialog.Subversion.select.working.copy.wcopy.list.title=已知工作副本
dialog.create.branch.or.tag.from.working.copy.warning=<html>使用此變體建立<b>具有本地更改</b>的分支。<br/>通常，不僅是目標目錄，還將有幾個項“帶歷史記錄新增”。<br/><br/>具有與根不同的修訂的各個檔案將被分別複製。<br/>因此，建議先更新工作副本，然後再建立分支。</html>
dialog.description.select.configuration.directory=選擇 Subversion 組態目錄或建立新目錄
dialog.edit.http.proxies.settings.client.certificate.passphrase.text=SSL 用戶端憑證密碼短語(&H):
dialog.edit.http.proxies.settings.connection.timeout.text=連線超時(&I):
dialog.edit.http.proxies.settings.dialog.select.ssl.client.certificate.path.title=選擇憑證路徑
dialog.edit.http.proxies.settings.error.ambiguous.group.patterns.text=找到與多個組符合的版本庫 URL: {0}
dialog.edit.http.proxies.settings.error.ambiguous.group.patterns.to.text=URL {0} 符合 {1}
dialog.edit.http.proxies.settings.error.same.group.names.text=檢測到同名的組: ''{0}''
dialog.edit.http.proxies.settings.exceptions.text=異常(&X):
dialog.edit.http.proxies.settings.panel.proxy.title=HTTP 代理設定
dialog.edit.http.proxies.settings.panel.repositories.title=版本庫
dialog.edit.http.proxies.settings.panel.ssl.title=SSL 設定
dialog.edit.http.proxies.settings.password.text=密碼(&W):
dialog.edit.http.proxies.settings.paths.to.authority.certificates.text=CA 憑證檔案的逗號分隔路徑(&P):
dialog.edit.http.proxies.settings.patterns.text=URL 模式(&R):
dialog.edit.http.proxies.settings.port.must.be.number.error=連接埠必須為數字(組 ''{0}'')
dialog.edit.http.proxies.settings.port.text=連接埠(&O):
dialog.edit.http.proxies.settings.seconds.text=秒
dialog.edit.http.proxies.settings.server.text=伺服器(&S):
dialog.edit.http.proxies.settings.ssl.client.certificate.file.text=SSL 用戶端憑證檔案(&C):
dialog.edit.http.proxies.settings.tab.edit.system.file.title=系統檔案
dialog.edit.http.proxies.settings.tab.edit.user.file.title=使用者檔案
dialog.edit.http.proxies.settings.test.connection.button.text=測試連線(&T)
dialog.edit.http.proxies.settings.test.connection.error.title=連線測試失敗
dialog.edit.http.proxies.settings.test.connection.settings.will.be.stored.text=設定將被儲存
dialog.edit.http.proxies.settings.test.connection.settings.will.be.stored.title=警告
dialog.edit.http.proxies.settings.test.connection.success.text=連線測試成功
dialog.edit.http.proxies.settings.test.connection.success.title=連線測試成功
dialog.edit.http.proxies.settings.timeout.must.be.number.error=HTTP 超時必須為數字(組 ''{0}'')
dialog.edit.http.proxies.settings.trust.default.cas.text=信任預設 CA(&A)
dialog.edit.http.proxies.settings.user.text=使用者(&U):
dialog.message.accept.theirs.for.path=接受他們對 {0} 的更改?
dialog.message.accept.yours.for.path=接受您對 {0} 的更改?
dialog.message.branch.name.is.empty=分支名稱為空
dialog.message.can.not.detect.repository.root.for.url=無法檢測 URL 的版本庫根: {0}
dialog.message.confirm.move.folder=您即將移動名稱為 ''{0}'' 的目錄。是否確定?
dialog.message.could.not.parse.url=無法解析 url
dialog.message.error.relocating.working.copy=重定位工作副本時出錯: {0}
dialog.message.integrate.changes.error.no.available.files=沒有可用於整合的檔案
dialog.message.integrate.changes.error.not.versioned=無法啟動整合: 目標目錄不在 Subversion 控制下或不屬於所選分支。
dialog.message.integrate.changes.error.same.source.and.target=無法啟動整合: 目標分支和源分支相同。
dialog.message.integrate.changes.error.target.not.dir=無法啟動整合: 目標目錄不存在或不是目錄。
dialog.message.invalid.branch.name=分支名稱無效
dialog.message.invalid.branch.url=分支 url 無效
dialog.message.invalid.repository.location=版本庫位置無效
dialog.message.invalid.revision=修訂無效
dialog.message.invalid.working.copy.root=無效的工作副本根: {0}
dialog.message.keep.newly.created.files.in.their.original.place=在其初始位置保留新增檔案?
dialog.message.mark.tree.conflict.resolved.confirmation=是否要將樹衝突標記為已解決?
dialog.message.merge.confirm.reintegrate=您將重新整合更改。<br><br>此舉將導致分支 ''{0}'' <b>不能再用於進一步的處理</b>。<br>此分支既無法正確吸收新的主幹({1})更改，<br>也無法正確地重新整合到主幹。<br> <br>確定嗎?
dialog.message.merge.from.theirs.create.binary.file=(根據其更改)建立二進制檔案 {0}?
dialog.message.merge.from.theirs.delete.binary.file=(根據其更改)刪除二進制檔案 {0}?
dialog.message.merge.from.theirs.modify.binary.file=(根據其更改)對二進制檔案 {0} 套用更改?
dialog.message.merge.intersects.with.local.changes.prompt=存在與合併更改衝突的本地更改。\\n\\
是否要繼續?
dialog.message.merge.potentially.intersects.with.local.changes.prompt=存在與合併更改有可能相交的本地更改。\\n\\
是否要繼續?
dialog.message.merge.with.switched.paths.in.working.copy=工作副本中有一些切換的路徑。是否要繼續?
dialog.message.no.branch.base.location.selected=未選擇分支基位置
dialog.message.repository.path.does.not.exist=版本庫路徑 ''{0}'' 不存在。要建立它嗎?
dialog.message.select.binary.files.to.patch=選擇要打補丁的二進制檔案
dialog.message.set.working.copy.infinity.depth=您將以 ''infinity'' 深度簽出到 ''{0}''。\\n\\
您的工作副本也將隨之更新為 HEAD 修訂。
dialog.message.share.to.not.empty.directory=遠端目錄“{0}”非空。\\n\\
是否要繼續共享?
dialog.message.switch.target.not.copy.current=切換目標 URL 不是當前副本。\\n\\
是否要繼續?
dialog.message.target.file.already.exists=目標檔案已經存在
dialog.show.svn.map.title=Subversion 工作副本資訊
dialog.title.authentication.required=需要身份驗證
dialog.title.branch=建立分支或標記
dialog.title.can.not.invoke.action=無法呼叫 {0}
dialog.title.changes.in.url={0} 中的更改
dialog.title.check.out=從 Subversion 簽出
dialog.title.commit.will.split=Subversion: 提交將進行拆分
dialog.title.computing.difference=正在計算差異
dialog.title.convert.working.copy.format=轉換工作副本格式
dialog.title.destination.directory=目標目錄
dialog.title.edit.http.proxies.settings = 編輯與網絡層相關的 Subversion 選項
dialog.title.error=錯誤
dialog.title.export.directory=匯出目錄
dialog.title.import.directory=匯入目錄
dialog.title.integrate.to.branch=整合到分支
dialog.title.lock.file=鎖定檔案
dialog.title.lock.files=鎖定檔案
dialog.title.mark.resolved=標記已解決
dialog.title.mark.tree.conflict.resolved=將樹衝突標記為已解決
dialog.title.merge.from.branch=合併自 {0}
dialog.title.new.remote.folder=新增遠端目錄
dialog.title.relocate.working.copy=重新定位工作副本
dialog.title.resolve.tree.conflict=解決樹衝突
dialog.title.save.unified.diff=補丁檔案
dialog.title.select.configuration.directory=選擇組態目錄
dialog.title.select.merge.variant=選擇合併變體
dialog.title.select.path.to.subversion.executable=Subversion
dialog.title.select.repository.location=選擇版本庫位置
dialog.title.select.share.target=選擇共享目標
dialog.title.select.target.for.external=選擇用於外部的目標
dialog.title.select.working.copy.location=選擇工作副本位置
dialog.title.set.property=設定屬性
dialog.title.set.working.copy.infinity.depth=設定工作副本無限深度
dialog.title.ssh.examine.server.fingerprints=驗證伺服器密鑰指紋
dialog.title.ssh.settings.browse.executable=SSH 可執行檔案
dialog.title.ssh.settings.browse.private.key=私鑰
dialog.title.ssl.examine.server.crertificate=檢查伺服器憑證
dialog.title.svn.delete=SVN 刪除
dialog.title.svn.export.options=SVN 匯出選項
dialog.title.svn.import.options=SVN 匯入選項
dialog.title.svn.keywords=SVN 關鍵字
dialog.title.svn.properties.diff=SVN 屬性差異
dialog.title.svn.repository.browser=SVN 版本庫瀏覽器
dialog.title.switch.target.problem=切換目標問題
dialog.upgrade.wcopy.format.title=Subversion 工作副本格式
diff.cant.get.properties.changes=無法顯示 SVN 屬性
diff.options.checkbox.reverse.diff=反轉差異
diff.options.label.compare=比較:
diff.options.label.compare.type=比較類型
diff.options.label.with=與:
diff.options.no.patch.file.error=請指定儲存補丁檔案的路徑
diff.options.no.url.error=請選擇一個 URL 進行比較
diff.options.radio.graphical.compare=圖形比較
diff.options.radio.unified.diff=統合差異
diff.options.same.url.error=請選擇其他 URL 進行比較
diff.options.title=與分支或標記比較
error.authentication.canceled.for.repository=已對版本庫取消身份驗證: {0}
error.can.not.access.file.base.revision.contents.administrative.area.is.locked=無法存取檔案的基礎修訂內容: 管理區域已被鎖定
error.can.not.create.directory=無法建立目錄: {0}
error.can.not.delete.file=無法刪除檔案: {0}
error.can.not.find.file=找不到檔案: {0}
error.can.not.find.relative.path.for.path.at.revision=找不到 {0}@{1} 的相對路徑
error.can.not.find.repository.root.for.url=找不到 URL 的版本庫根: {0}
error.can.not.find.repository.root.for.url.in.revision=在修訂 {1} 中找不到 URL: {0} 的版本庫根
error.can.not.find.url.for.file=找不到檔案的 url: {0}
error.can.not.find.working.copy.for.file=找不到檔案的工作副本: {0}
error.can.not.get.current.revision.for.path=無法獲取檔案 {0} 的當前修訂
error.can.not.get.last.changed.revision.for.path.please.file.an.issue=無法獲取檔案上次進行的修訂: {0}\\n\\
請為此檔案執行 svn info 並提交問題。
error.can.not.load.theirs.content.for.file=無法為檔案 {0} 載入他們的內容
error.can.not.set.property=無法設定屬性: {0}
error.cannot.load.revisions=無法載入修訂列表
error.could.not.compare.local.file.and.remote.url.with.executable.for.svn.version=無法將本地檔案和遠端 Url 與 svn {0} 的可執行檔案相比較
error.could.not.determine.revision.number.for.file.and.revision=無法確定檔案 {0} 和修訂 {1} 的修訂號
error.could.not.find.separating.space=找不到分隔空間
error.could.not.find.start.quote=找不到起始引號
error.could.not.get.head.info.for.url=無法獲取 {0} 的標頭資訊
error.could.not.get.info.for.path=無法獲取 {0} 的資訊
error.could.not.get.relative.path.for.parent.and.child=無法獲取 {0} 和 {1} 的相對路徑
error.could.not.get.revision.for.url=無法獲取 {0} 的修訂
error.could.not.get.svn.version=退出程式碼: {0}，錯誤: {1}
error.could.not.parse.merge.info=無法解析 {0}
error.could.not.parse.svn.version=無法解析 svn 版本: {0}
error.file.is.not.under.subversion=檔案 {0} 未受到 Subversion 控制
error.file.is.not.under.version.control=檔案 {0} 未進行版本管理
error.format.is.not.supported=不支持 {0} 格式。支援的格式: {1}。
error.integration.was.canceled=整合已被取消
error.invalid.svn.revision=無效的 svn 修訂: {0}
error.invalid.url=無效 url: {0}
error.latest.existing.revision.found.for.url=已找到 {0} 的最新現有修訂
error.missing.committed.revision.number=缺少提交的修訂號: {0}
error.move.have.not.been.performed=尚未執行 Subversion 移動。
error.no.branch.point.found.for.target=找不到 {0} 的分支點
error.parse.file.status.unknown.state.on.line=第 {0} 行的狀態未知
error.properties.loading.for.revision.canceled=已取消為修訂 {0} 載入屬性。
error.revert.failed=還原失敗
error.revision.from.must.be.a.valid.number=“起始修訂”必須為有效數字
error.revision.to.must.be.a.valid.number=“結束修訂”須為有效數字
error.selected.destination.conflicts.with.existing=所選目標與現有目標相衝突: {0}
error.server.ssl.certificate.rejected=伺服器 SSL 憑證被拒
error.svn.exited.with.error.code=SVN 程序已退出，錯誤程式碼為: {0}
error.svn.status.not.in.working.copy=請求的狀態不在工作副本中: {0}
error.svn.status.with.no.output=狀態請求沒有為指令返回任何內容: {0}
error.target.not.found.in.paths=在 {1} 中找不到 {0}
error.target.of.move.operation.is.already.under.version.control=移動動作的目標已受到版本控制。
error.url.could.not.contain.fragment={0} 不能包含片段
error.url.could.not.contain.query={0} 不能包含查詢
error.url.is.not.absolute={0} 非絕對
error.url.is.not.hierarchical={0} 非層次結構
error.wrong.committed.revision.number=提交的修訂號錯誤: {0}
exception.text.cannot.annotate.directory=註解動作僅對檔案有意義
exception.text.cleanupaction.batchperform.not.implemented=CleanupAction.batchPerform 未實作
exception.text.failed.to.unlock.file=無法解鎖檔案: {0}
exception.text.file.miss.svn=檔案 ''{0}'' 為唯讀，但缺少 svn:needs-lock 屬性
exception.text.locking.file.failed=無法鎖定檔案: {0}
exception.text.root.was.not.properly.updated=svn: {0} 未正確更新; 可能是因為它已經與父級一起從版本庫中移除。
exportable.SvnDiffSettings.presentable.name=SVN 差異
file.conflict.property=屬性
file.conflict.text=文本
file.conflict.tree=樹
file.status.external=外部 (svn)
file.status.obstructed=受阻 (svn)
file.status.replaced=取代 (svn)
group.IgnoreChoicesGroup.text=忽略
group.RevertIgnoreChoicesGroup.text=從忽略列表中移除
group.SubversionFilePopupGroup.text=Subversion(_S)
import.dialog.button=匯入
import.dialog.title=匯入 Subversion
integrate.configuration.description.label=將源之間的差異整合到工作副本中(比較源 2 和源 1)
integrate.configuration.revision1.label=修訂(&V)
integrate.configuration.revision2.label=修訂(&R)
integrate.configuration.source1.label=源 1:
integrate.configuration.source2.label=源 2:
integrate.display.name=整合
label.after.accepting.theirs.for.path=在接受他們對 {0} 的更改後
label.already.merged=已合併
label.auth.authentication.realm=身份驗證領域: ''{0}''
label.auth.password=密碼(&P):
label.auth.user.name=用戶名(&U):
label.before.accepting.theirs.for.path=在接受他們對 {0} 的更改前
label.branch.base.url=基 URL:
label.branch.name=名稱:
label.changelists.merging.faced.problems=更改列表:\\n\\
{0}\\n\\
合併面臨的問題
label.commit.message=提交訊息:
label.configure.change.label=將工作副本 ''{0}'' 格式更改為:
label.configure.create.label={0} 將要建立新的 Subversion 工作副本，\\n\\
請選擇所需的工作副本格式:
label.configure.upgrade.label=工作副本升級策略:
label.conflict.directory.added=(目錄)已新增
label.conflict.directory.unversioned=(目錄)未進行版本管理
label.conflict.file.added=(檔案)已新增
label.conflict.file.unversioned=(檔案)未進行版本管理
label.conflict.left.side=左: {0}
label.conflict.right.side=右: {0}
label.copy.comment=&註釋
label.copy.from=複製自
label.copy.from.revision=修訂(&V):
label.copy.select.location.dialog.copy.as=複製為(&A):
label.copy.to=複製到
label.define.share.target=定義共享目標
label.depth.description=取代舊的“遞迴”選項。“遞迴”為 false 等效於“直接子級”，“遞迴”為 true 等效於“無限”
label.depth.empty=空
label.depth.exclude=排除
label.depth.files=檔案
label.depth.immediates=直接
label.depth.infinity=無限
label.depth.text=深度(&D):
label.depth.unknown=未知
label.destination=目標:
label.export=匯出:
label.external.copy=外部副本
label.file.has.conflicts=檔案有 {0} 個衝突，無法提交
label.file.has.conflicts.before.and.after=檔案有 {0} 個衝突，無法提交\\n\\
之前: {1}\\n\\
之後: {2}
label.file.has.conflicts.before.or.after=檔案有 {0} 個衝突，無法提交\\n\\
{1}
label.from.url=源 URL:
label.import.from=匯入自:
label.import.to=匯入到:
label.local.target=本地目標:
label.locally.deleted.file.has.conflicts=檔案有 {0} 個衝突
label.lock.comment=鎖定註釋(&L):
label.locl.steal.existing=竊取現有鎖(&S):
label.merge.all.from.branch=合併 {0} 中的全部內容
label.merge.all.from.branch.at.revision=合併 {1} 的 {0} 中的全部內容
label.merge.all.from.branch.at.revision.reintegrate=合併 {1} 的 {0} 中的全部內容(重新整合)
label.merge.all.from.branch.reintegrate=合併 {0} 中的全部內容(重新整合)
label.merge.from.url=從:
label.merge.local.changes.intersection=以下檔案具有與合併更改相交的本地更改:
label.merge.source.revision=合併原始碼修訂
label.merge.to.branch=到:
label.merged.from.branch=已合併自 {0}
label.mixed.revision.working.copy=混合修訂工作副本
label.nested.copy.type.external=外部
label.nested.copy.type.inner=嵌套
label.nested.copy.type.switched=已切換
label.no.subversion.1.5.working.copies=此專案中沒有 1.5 版本庫的 Subversion 1.5 工作副本
label.override.native.eols.with=覆寫 'native' EOL 的選項:
label.path.revisions.info={0}(當前: {1}，已提交: {2})
label.path.to.svn.executable=Subversion 可執行檔案的路徑:
label.point.to.repository.location=指向版本庫位置
label.recent.messages=最近的訊息:
label.remote.folder.name=遠端目錄名稱:
label.remote.folder.url=遠端目錄 URL:
label.repositories=版本庫:
label.revision=修訂
label.select.checkout.destination.directory=選擇簽出目標目錄
label.select.directory.to.export.from.subversion=選擇要從 Subversion 匯出的目錄
label.select.directory.to.import.into.repository=選擇要匯入版本庫的目錄
label.select.export.destination.directory=選擇匯出目標目錄
label.select.file.to.save.unified.diff=選擇用於存儲統合差異的檔案
label.select.files.and.directories.to.mark.resolved=選擇要標記為已解決的檔案和目錄:
label.select.keywords.to.set=選擇要設定的關鍵字:
label.select.location.to.copy.from=選擇要從中複製的位置:
label.select.path.to.subversion.executable=選擇 Subversion 可執行檔案(1.7+)的路徑
label.select.target.working.copy=選擇目標工作副本的路徑
label.set.property.property.name=屬性名稱(&N):
label.skipped.changelists=已跳過的更改列表: {0}
label.source.url=源 URL:
label.specify.ssl.protocol.manually=請嘗試手動指定 SSL 協議 - SSLv3 或 TLSv1
label.ssh.key.file=密鑰檔案(&F):
label.ssh.passphrase=密碼短語(&R):
label.ssh.server.provided.fingerprints=無法建立主機 {0} 的驗證。
label.ssh.server.provided.fingerprints2={0} 密鑰指紋為
label.ssh.server.provided.fingerprints3=確定要繼續連線嗎?
label.ssl.certificate.password=憑證密碼短語:
label.ssl.certificate.path=憑證路徑:
label.ssl.server.provided.certificate=伺服器提供了以下憑證:
label.svn.phantom.change=技術記錄
label.svn.properties.changed=SVN 屬性已更改
label.switched.copy=已切換副本
label.target.location=目標位置:
label.target.name=目標名稱:
label.target.url=目標 URL:
label.text.delete.stored.credentials=刪除 'http'、'svn' 和 'svn+ssh' 協議的所有已存儲憑證
label.to.url=目標 URL:
label.update.switch.to.revision=更新/切換到修訂:
label.update.url=URL:
label.working.copy=工作副本
label.working.copy.depth=深度:
label.working.copy.format=格式:
label.working.copy.format.unknown=未知
label.working.copy.root=工作副本根
label.working.copy.root.outside.text=工作副本根位於“專案設定”中指定的目錄外部。\\n\\
整個工作副本將被轉換。
label.working.copy.url=URL:
link.change.format=更改
link.fix.depth=修正
merge.chunk.changelist.description={0} [來自於修訂 {1}]
merge.source.details.title=合併 {0} [{1}] 的原始碼詳細資訊
message.text.cannot.checkout=無法從 svn 簽出: {0}
message.text.cannot.export=無法從 svn 匯出: {0}
message.text.cannot.import=無法匯入 svn: {0}
message.text.cannot.load.supported.formats=無法載入支援的格式: {0}
message.text.files.lock.failed={0,choice, 0#無法鎖定檔案。|1#無法鎖定檔案。}
message.text.files.locked={0,choice, 0#無法鎖定檔案。|1#已鎖定 1 個檔案|2#已鎖定 {0,number} 個檔案}
message.text.files.unlocked={0,choice, 0#無法解鎖檔案。|1#已解鎖 1 個檔案|2#已解鎖 {0,number} 個檔案}
message.text.no.conflicts.found=未找到衝突
message.text.update.no.directories.found=找不到要更新的版本管理目錄
message.theirs.accepted.for.file=已接受他們對 {0} 的更改
message.theirs.changes.merged.for.file=已針對 {0} 合併他們的更改
message.title.export=從 Subversion 匯出
message.title.import=匯入 Subversion
message.title.no.conflicts.found=無衝突
message.title.unlock.failures=解鎖失敗
message.yours.accepted.for.file=已接受您對 {0} 的更改
messate.text.update.error=SVN: 更新錯誤
move.dialog.title=移動或重新命名
move.files.errors.title=移動檔案時出錯
navigate.to.idea.proxy.settings=導覽到一般代理設定
no.differences.between.sources.error.message=源和相同源之間沒有區別
non.english.locale.detected.warning=使用了非英語區域設定。
notification.action.click.to.fix=點擊以修正。
notification.content.authentication.failed=身份驗證失敗: {0}
notification.content.branches.load.error=分支載入錯誤: {0}
notification.content.can.not.access.working.copy.database=存取 svn 工作副本資料庫時發生了若干錯誤。
notification.content.can.not.merge.from.self=無法自我合併
notification.content.everything.is.up.to.date=所有內容都已處於最新狀態
notification.content.merge.start.was.not.found=找不到合併起始點
notification.content.multiple.roots.unsupported.format=某些根的格式可能是不受支援的 Subversion 格式
notification.content.not.logged.into.subversion=未登錄到 Subversion ''{0}'' ({1})
notification.content.revision.commit.message.changed.to=修訂 #{0} 註釋更改為:\\n\\
''{1}''
notification.content.single.root.unsupported.format=根 ''{0}'' 可能是不受支援的 Subversion 格式
notification.content.unknown.certificate.type.from.url=Subversion: {0} 中的憑證類型未知
notification.group.svn.roots=Subversion 根檢測失敗
notification.title.not.logged.into.subversion=未登錄到 Subversion
operation.merge=合併
popup.content.already.checking=正在檢查…
popup.content.failed.to.authenticate.to.proxy=代理驗證失敗。
popup.content.failed.to.authenticate.to.proxy.change.credentials=代理驗證失敗。您可以在 HTTP 代理設定中更改代理憑證。
popup.title.select.branch=選擇分支
popup.title.select.branch.to.integrate.to=選擇要整合到的分支…
progres.text2.merged=已合併 {0}
progres.text2.updated=已更新 {0}
progres.text2.updated.to.revision=已更新至修訂 {0}。
progress.details.merging.changelist.range=正在合併更改列表 {0}
progress.details.upgraded.path=已升級路徑 {0}
progress.live.provider.loading.revisions.details.text=正在從伺服器載入修訂…
progress.live.provider.loading.revisions.text=正在從伺服器載入修訂
progress.message.connecting.to.url=正在連線到 {0}
progress.searching.for.files.with.conflicts=正在搜尋有衝突的檔案
progress.text.browser.copying=正在拷貝{0}
progress.text.browser.creating=正在建立 {0}
progress.text.browser.moving=正在移動 {0}
progress.text.browser.remote.destination=到 {0}
progress.text.changes.collecting.changes=正在收集有關更改的資訊
progress.text.checking.out=正在將檔案簽出到 ''{0}''
progress.text.clearing.stored.credentials=正在清除 {0} 中存儲的憑證
progress.text.collecting.merge.information=正在收集合併資訊
progress.text.collecting.not.merged.revisions=正在收集未合併的修訂
progress.text.computing.annotation=正在計算 ''{0}'' 的註解
progress.text.converting.working.copy.format=將 {0} 格式的工作副本從 {1} 轉換為 {2}
progress.text.copy.to=複製到 ''{0}''
progress.text.create.remote.folder=建立遠端目錄
progress.text.deleting=正在刪除 {0}
progress.text.export=正在將檔案匯出到 ''{0}''
progress.text.import=匯入 {0}
progress.text.loading.contents=正在載入 ''{0}'' 的內容
progress.text.locking.files=正在鎖定版本庫中的檔案…
progress.text.merging.changes=正在將更改合併到 ''{0}''
progress.text.merging.dry.run.changes=正在將(dry run)更改合併到 ''{0}''
progress.text.performing.path.cleanup=正在執行 ''{0}'' 清理…
progress.text.unlocking.files=正在解鎖版本庫中的檔案…
progress.text.updating=正在更新 ''{0}''
progress.text.updating.external.location=正在更新 ''{0}'' 的外部位置
progress.text2.added=已新增 {0}
progress.text2.adding=正在新增 ''{0}''
progress.text2.changes.establishing.connection=正在建立與 ''{0}'' 的連線
progress.text2.checked.out=已簽出 {1} 個檔案，正在簽出 {0}
progress.text2.checked.out.revision=已簽出修訂 {0}。
progress.text2.collecting.history=正在收集 ''{0}'' 的修訂歷史記錄
progress.text2.conflicted={0} 存在衝突
progress.text2.deleted=已刪除 {0}
progress.text2.deleting=正在刪除 ''{0}''
progress.text2.exported=已匯出 {1} 個檔案，正在匯出 {0}
progress.text2.exported.revision=已匯出修訂 {0}。
progress.text2.fetching.external.location=正在獲取 ''{0}'' 的外部位置
progress.text2.processing.file=正在處理檔案 {0}
progress.text2.processing.revision=正在處理修訂 ''{0}''
progress.text2.replacing=正在取代 ''{0}''
progress.text2.restored.file=已還原 {0}
progress.text2.revision.information=修訂{0}
progress.text2.revision.processed=已處理修訂 ''{0}''
progress.text2.sending=正在發送 ''{0}''
progress.text2.skipped.file=已跳過 {0}
progress.text2.transmitting.delta=正在傳輸 ''{0}'' 的增量
progress.text2.treeconflicted=已衝突 {0}(樹衝突)
progress.title.accepting.theirs.for.path=正在接受他們對 {0} 的更改
progress.title.accepting.working.state=正在接受工作狀態
progress.title.accepting.yours.for.path=為之接受您的更改: {0}
progress.title.adding.file.to.subversion=正在將 {0} 新增到 Subversion
progress.title.adding.files.to.subversion=正在向 Subversion 新增檔案
progress.title.applying.binary.changes=正在套用二進制更改
progress.title.browser.copy=複製
progress.title.browser.delete=刪除
progress.title.browser.move=移動
progress.title.calculating.copy.revision=正在計算副本修訂
progress.title.check.out=從 Subversion 簽出
progress.title.check.out.cancel=停止從 Subversion 簽出
progress.title.check.remote.folder.contents=檢查遠端目錄內容
progress.title.checking.repository.capabilities=正在檢查版本庫容量
progress.title.checking.target.folder=正在檢查目標目錄
progress.title.cleanup.project=清理專案
progress.title.clear.authentication.cache=清除身份驗證快取(&C)
progress.title.commit=提交
progress.title.convert.working.copy.format=轉換工作副本格式
progress.title.copy=Subversion 副本
progress.title.creating.external=正在建立外部
progress.title.creating.patch.for.theirs.changes=正在為其更改建立更新檔
progress.title.deleting.files.from.subversion=正在從 Subversion 中刪除檔案
progress.title.detecting.repository.root=正在檢測版本庫根
progress.title.edit.revision.comment=編輯修訂註釋
progress.title.filtering.branch.revisions=正在篩選 {0} 修訂
progress.title.getting.base.and.theirs.revisions.content=獲取基本內容及其修訂內容
progress.title.getting.latest.repository.revision=正在獲取最新的版本庫修訂
progress.title.loading.branches=正在載入分支
progress.title.loading.change.details=正在載入更改詳細資訊
progress.title.loading.child.entries=正在載入子條目
progress.title.loading.file.content=正在載入遠端檔案內容
progress.title.loading.file.properties=正在載入遠端檔案屬性
progress.title.loading.recent.branch.revisions=正在載入最近的 {0} 修訂
progress.title.loading.tree.conflict.details=正在載入樹衝突詳細資訊
progress.title.loading.working.copies.data=Subversion: 正在載入工作副本資料…
progress.title.lock.files=鎖定檔案
progress.title.looking.for.branch.origin=正在尋找分支來源
progress.title.looking.for.file.working.copy.root=正在尋找 ''{0}'' 工作副本根
progress.title.mark.tree.conflict.resolved=將樹衝突標記為已解決
progress.title.merging.all.from.branch=正在合併 {0} 中的全部內容
progress.title.merging.all.from.branch.reintegrate=正在合併 {0} 中的全部內容(重新整合)
progress.title.moving.files.in.subversion=正在移動 Subversion 中的檔案
progress.title.relocating.working.copy=正在重定位工作副本
progress.title.resolve.tree.conflict=解決樹衝突
progress.title.share.directory=共享目錄
progress.title.shelving.local.changes.before.merge=正在擱置合併前的本地更改
progress.title.svn.branches.preloader=Subversion 分支預載入程序
progress.title.svn.roots.authorization.checker=SVN VCS 根授權檢查器
progress.title.test.connection=測試連線
progress.title.unlock.files=解鎖檔案
quick.merge.variants.merge.all=全部合併
quick.merge.variants.merge.all.explanation=所有未合併的修訂將被合併。\\n\\
Subversion 將使用本地副本中記錄的 svn:mergeinfo 屬性尋找未合併的修訂。
quick.merge.variants.pre.select=通過預篩選選擇
quick.merge.variants.pre.select.explanation=尋找涉及的一個分支複製自另一個分支的位置。\\n\\
僅載入尚未合併的修訂以供選擇。執行可能需要很長時間。
quick.merge.variants.quick.select=快速手動選擇
quick.merge.variants.quick.select.explanation=顯示來自目標分支、已合並和未合併分支的所有修訂。\\n\\
用於手動選擇。快速獲取結果。
radio.configure.change.auto.16format=1.6 格式(&6)
radio.configure.change.auto.17format=1.7 格式(&7)
radio.configure.change.auto.18format=1.8 格式(&8)
radio.configure.create.auto.16format=1.6 格式(&6)
radio.configure.create.auto.17format=1.7 格式(&7)
radio.configure.create.auto.18format=1.8 格式(&8)
radio.configure.upgrade.auto.16format=自動升級(使用 Subversion 1.6)(&6)
radio.configure.upgrade.auto.17format=自動升級(使用 Subversion 1.7)(&7)
radio.configure.upgrade.auto.18format=自動升級(使用 Subversion 1.8)(&8)
radio.copy.repository.location=版本庫位置(&R):
radio.copy.to.any.location=任何位置
radio.copy.to.branch.or.tag=分支或標籤
radio.copy.working.copy=工作副本(&W)
radio.set.property.delete.property=刪除屬性(&D)
radio.set.property.set.property.value=設定屬性值(&S):
radio.share.target.at.selected.repository.location=在所選版本庫位置
radio.share.target.in.new.folder=在所選版本庫位置的新“{0}”目錄中
refresh.branches.item=重新整理分支…
repository.browser.add.location.action.description=新增版本庫位置
repository.browser.add.location.action.text=新增版本庫位置
repository.browser.add.location.menu.item=版本庫位置(_R)…
repository.browser.add.location.prompt=版本庫 URL:
repository.browser.add.location.title=新增版本庫位置
repository.browser.browse.changes.action=瀏覽更改(_B)…
repository.browser.browse.changes.description=檢視選定節點中的更改歷史記錄
repository.browser.compare.title=比較 ''{0}'' 和 ''{1}''
repository.browser.details.action=顯示/隱藏詳細資訊
repository.browser.discard.location.action=捨棄位置(_L)
repository.browser.discard.location.prompt=要捨棄位置 ''{0}'' 嗎?
repository.browser.discard.location.title=捨棄位置
repository.browser.edit.location.dialog.title= 編輯位置 URL
repository.browser.edit.location.menu.item= 編輯位置 URL(_U)…
repository.browser.import.action=匯入(_I)…
repository.browser.new.folder.action=遠端目錄(_F)…
repository.browser.no.locations.added.info=未新增版本庫位置。
repository.browser.refresh.action=重新整理選定樹節點
revision.title=修訂
select.location.invalid.url.message=無效的 Subversion 版本庫 URL: ''{0}''
separator.commit.comment.prefix=提交註釋前綴
separator.property.changes=屬性更改
server.ssl.accept.temporary.action.name=接受臨時(_T)
settings.HTTP.timeout=HTTP 超時:
settings.SSH.connection.timeout=SSH 連線超時:
settings.SSH.read.timeout=SSH 讀取超時:
settings.check.mergeinfo=準備合併時檢查目標子樹中的 svn:mergeinfo
settings.edit.servers.subversion.runtime.configuration.file=編輯 'servers' Subversion 執行時組態檔案
settings.maximum.revisions.number=註解中可回顧的最大修訂數:
settings.seconds=秒
settings.ssl.protocols=SSL 協議:
settings.ssl.protocols.all=所有
settings.ssl.protocols.all.tlsv1=TLSv1
settings.ssl.protocols.sslv3=SSLv3
settings.use.custom.directory=使用自訂組態目錄(&U):
share.directory.action=共享目錄…
share.directory.checkout.back.progress.text=正在簽出 {0}
share.directory.commit.message={2}\\n\\
{1} 建立的目錄 ''{0}''
share.directory.create.dir.progress.text=正在建立遠端目錄 {0}
share.directory.info.message=要完成共享動作，請提交 ''{0}''。
share.directory.title=共享目錄
share.or.import.add.progress.text=正在排定 {0} 的新增時間表
show.properties.diff.progress.text.revision.information=修訂{0}
show.properties.diff.progress.text2.property.information=屬性 {0}
source.url.could.not.be.empty.error.message=源 URL 不能為空
ssh.settings.executable.label=SSH 可執行檔案:
ssh.settings.password.choice.title=密碼
ssh.settings.port.label=連接埠:
ssh.settings.private.key.choice.title=私鑰
ssh.settings.private.key.path.label=路徑:
ssh.settings.subversion.config.choice.title=Subversion 組態
ssh.settings.tunnel.label=SSH 隧道:
ssh.settings.update.tunnel.title=更新
ssh.settings.user.name.label=用戶名:
status.group.name.replaced=已取代
status.text.checked.out.revision=已簽出修訂 {0}。
status.text.committed.revision=提交的修訂 {0}。
status.text.merge.sources=合併原始碼
status.text.updated.to.revision=已更新至修訂 {0}。
subversion.executable.notification.cant.run.in.safe.mode=無法在安全模式下執行 Svn 指令
subversion.executable.notification.description=Subversion 可執行檔案的路徑可能是錯誤的。
subversion.executable.notification.title=無法使用 Subversion 命令行用戶端
subversion.executable.too.old=Subversion 命令行用戶端版本過舊({0})。
subversion.roots.detection.errors.found.action.text=修復
subversion.roots.detection.errors.found.description=檢測 Subversion 工作副本時發現錯誤。
svn.cannot.save.credentials.store-auth-creds=無法存儲憑證: “store-auth-creds = no”禁止
svn.create.external.below.action=建立外部…
svn.create.external.below.description=選擇 URL，新增 svn:external 屬性，然後可以選擇簽出
svn.edit.commit.message.attention=注意! 以前的訊息將丟失!
svn.edit.commit.message.prompt=新修訂註釋:
svn.edit.commit.message.title=編輯修訂 #{0} 註釋
svn.integrate.changelist.warning.unresolved.conflicts.text=整合中斷。存在未解決的衝突或跳過的項。
svn.name.with.mnemonic=Subversion(_S)
svn.option.ignore.whitespace.in.annotate=忽略註解中的空格差異
svn.phantom.changes.viewer=SVN 模擬更改檢視器
svn.properties.viewer=SVN 屬性檢視器
svn.short.name.with.mnemonic=SVN(_S)
svn.tree.conflict.viewer=SVN 樹衝突檢視器
tab.repository.merge.panel.filter.minus=篩選出未整合項
tab.repository.merge.panel.filter.others=篩選出其他
tab.repository.merge.panel.filter.plus=篩選出整合項
tab.title.create.external=建立外部
tab.title.edit.revision.comment=編輯修訂註釋
tab.title.failed.to.share.project=無法共享專案
tab.title.merge.local.changes.intersection={0}，本地更改相交
text.svn.phantom.change=已記錄此更改，因為其目標檔案被刪除，\\n\\
並且某些父目錄已複製(或移動)到新位置。
tooltip.revision.number.message=修訂 {0}: {1}
tooltip.use.project.location=使用專案位置
toolwindow.stripe.SVN_Properties=SVN 屬性
toolwindow.stripe.SVN_Repositories=SVN 版本庫
toolwindow.working.copies.info.title=Subversion 工作副本資訊
tree.conflict.description=本地 {0}，{2} 時傳入 {1}
undo.integrate.to.branch=撤消整合到分支…
undo.integrate.to.branch.description=從分支中移除修訂中所做的更改
undo.integrate.to.branch.dialog.title=撤消整合到分支
update.configuration.specific.url=更新/切換到特定 URL(&U):
update.switch.configurable.name=更新/切換
update.switch.to.branch.text=使用分支:
use.idea.proxy.as.default=將 {0} 一般代理設定用作 Subversion 的預設設定
use.idea.proxy.as.default.label.text=只有 HTTP 代理可以用作預設設定
value.new.branch.name=new_branch
value.new.folder.name=NewFolder
value.new.server.group.name=未命名
value.patch.file.name=TheirsChanges.patch"
`;

exports[`dev messages/VcsBundle.properties 1`] = `
"ChangesBrowserToolWindow.toolwindow.name=更改
RepositoryBrowser.toolwindow.name=版本庫
action.AnActionButton.text.add.jira.pattern=新增 JIRA 模式
action.AnActionButton.text.add.youtrack.pattern=新增 YouTrack 模式
action.Anonymous.text.remove.all.leading.directories=移除所有前導目錄
action.Anonymous.text.restore.all.leading.directories=還原所有前導目錄
action.ChangesViewToolWindowPanel.text=檢視選項
action.DumbAware.ApplyPatchDifferentiatedDialog.description.refresh=重新整理
action.DumbAware.ApplyPatchDifferentiatedDialog.text.refresh=重新整理
action.DumbAwareAction.text.compare.with.local.content=與本地內容比較
action.ImportIntoShelfAction.description=將補丁檔案複製到擱置
action.ImportIntoShelfAction.text=匯入更新檔…
action.NotificationAction.AllVcses.text.install=安裝
action.NotificationAction.AllVcses.text.open.plugin.page=開啟“延伸模組”頁面
action.NotificationAction.AllVcses.text.read.more=閱讀更多
action.NotificationAction.InactiveRangesDamagedNotification.text.view.changes=檢視更改…
action.NotificationAction.VFSListener.text.view.files=檢視檔案…
action.NotificationAction.VcsRootProblemNotifier.text.configure=組態…
action.NotificationAction.VcsRootProblemNotifier.text.enable.integration=啟用整合
action.NotificationAction.VcsRootProblemNotifier.text.ignore=忽略
action.SearchFieldAction.text.find=尋找: 
action.ShowAffectedFilesAction.show.affected.files.text=顯示受影響的檔案
action.ToggleAction.description.show.details=顯示詳細資訊面板
action.ToggleAction.text.preview.diff=預覽差異
action.ToggleAction.text.scope.filter=作用域篩選器
action.ToggleAction.text.show.details=顯示詳細資訊
action.Vcs.Toolbar.QuickListPopupAction.text=VCS 動作
action.amend.commit.anyway.text=仍然修正
action.annotate.previous.revision.text=註解之前的修訂
action.annotate.revision.text=註解修訂
action.annotate.selected.revision.in.new.tab.description=在新頁籤中註解所選修訂
action.annotate.show.diff.preview.on.hover.text=懸停時顯示差異
action.annotate.successor.selected.revision.in.new.tab.description=在新頁籤中註解所選修訂的後繼者
action.clone.dialog.stub.click.to.continue=點擊“{0}”繼續
action.commit.anyway.text=仍然{0}
action.description.compare=比較版本
action.description.create.patch.for.selected.revisions=為所選修訂建立更新檔
action.description.refresh=重新整理檔案歷史記錄
action.description.refresh.compare.with.local.panel=重新整理更改
action.display.name.check.scope.status=檢查{0}狀態
action.display.name.integrate.scope=整合{0}
action.display.name.update=更新
action.display.name.update.scope=更新{0}
action.enable.version.control.integration.text=啟用版本控制整合(_E)…
action.filter.filter.by.text=篩選依據
action.filter.moved.files.text=已移動且無更改
action.filter.non.important.files.text=包含不重要的更改
action.filter.separator.text=隱藏檔案
action.for.file.with.dialog.text={0}{1, choice, 1#檔案|2#檔案}…
action.import.to.shelf=匯入到 Shelf
action.message.use.selected.changes.description={0}所選更改
action.name.check.scope.status=檢查{0}狀態(_K)
action.name.check.status=檢查狀態(_K)
action.name.checkin.directory={0}{1,choice,1#目錄|2#目錄}
action.name.checkin.file={0}{1,choice,1#檔案|2#檔案}
action.name.compare=比較
action.name.create.patch=建立更新檔…
action.name.for.file.get.version={0}: 獲取版本 {1}
action.name.get.file.content.from.repository=從修訂中獲取
action.name.group.by.packages=按軟體套件分組
action.name.integrate=合併 (_G)
action.name.integrate.scope=合併 {0}(_G)
action.name.refresh=重新整理
action.name.refresh.compare.with.local.panel=重新整理
action.name.show.difference=顯示差異
action.name.show.files.as.tree=作為樹顯示
action.name.show.history.for.class=類別
action.name.show.history.for.code.block=程式碼塊
action.name.show.history.for.field=欄位
action.name.show.history.for.function=函式
action.name.show.history.for.method=方法
action.name.show.history.for.selection=選區
action.name.show.history.for.statement=語句
action.name.update=更新(_U)
action.name.update.scope=更新{0}(_U)
action.presentation.ApplySelectedChangesAction.text=接受
action.presentation.DiffShelvedChangesWithLocalActionProvider.description=將擱置版本與當前版本進行比較
action.presentation.IgnoreSelectedChangesAction.text=忽略
action.presentation.ShowUpdatedDiffActionProvider.description=更新前顯示與版本的差異
action.vcs.log.show.separator=顯示
acton.name.get.revision=獲取修訂
add.issue.dialog.invalid.regular.expression=無效的正則表達式: {0}
add.issue.dialog.issue.example.border.title=範例
add.issue.dialog.issue.id.label=問題 ID:
add.issue.dialog.issue.id.regular.expression=問題 ID (正則表達式):
add.issue.dialog.issue.link.label=問題連結:
add.issue.dialog.issue.link.replacement.expression=問題連結 (取代表達式):
add.issue.dialog.issue.no.match=<無符合>
advanced.setting.vcs.annotations.preload=在編輯器中開啟檔案時載入 VCS 中的檔案註解
advanced.setting.vcs.annotations.preload.description=這樣就可以更快速地按需顯示。
advanced.setting.vcs.commit.tool.window=啟用“提交”工具視窗
advanced.setting.vcs.commit.tool.window.description=在單獨的“提交”工具視窗中顯示“本地更改”和“擱置”頁籤
advanced.setting.vcs.non.modal.commit.toggle.ui=切換提交控件
advanced.setting.vcs.non.modal.commit.toggle.ui.description=執行提交後隱藏提交面板和複選框，並允許在“本地更改”中切換提交 UI
advanced.setting.vcs.process.ignored=醒目提示忽略的檔案
advanced.setting.vcs.process.ignored.description=請求 VCS 中被忽略檔案的列表，並在 IDE 中顯示這些檔案的狀態
advanced.setting.vcs.push.all.with.commits=選擇包含要推送的新提交的所有版本庫
advanced.setting.vcs.push.all.with.commits.description=預設預先選擇包含要推送的提交的所有版本庫
advanced.settings.vcs=版本控制
amend.action.name=修正{0}
amend.commit.different.committer.warning=修正後提交的提交者與預設設定不同
amend.commit.load.details.task.title=正在載入提交詳細資訊
amend.commit.load.message.error.text=無法載入待修正提交的提交訊息。
amend.commit.load.message.error.title=提交訊息未載入
amend.commit.load.message.task.title=正在載入提交訊息
annotate.action.description=註解檔案
annotate.action.name=註解
annotate.action.view.group.text=檢視
annotation.background=註解背景
annotation.commit.number=提交編號
annotation.original.revision.text=修訂: {0}
annotation.switch.to.merged.text=顯示合併原始碼
annotation.switch.to.original.text=隱藏合併原始碼
annotation.wrong.line.number.notification.text=<html>由 {0} 註解的行數與檔案中的行數不相等。請檢查檔案編碼和行分隔符。</html>
annotations.color.mode.author=作者
annotations.color.mode.group.colors=顏色
annotations.color.mode.hide=隱藏
annotations.color.mode.order=順序
annotations.short.name.type.email=電子郵件
annotations.short.name.type.first.name=名字
annotations.short.name.type.full.name=全名
annotations.short.name.type.group.names=姓名
annotations.short.name.type.initials=初始
annotations.short.name.type.last.name=姓氏
before.checkin.cleanup.code=清理(&L)
before.checkin.cleanup.code.profile=使用 ''{0}'' 組態檔案清理(&L)
before.checkin.error.unknown=無法檢查提交
before.checkin.error.unknown.details=無法檢查提交: {0}
before.checkin.error.unresolved.merge.conflicts=檔案有未解決的衝突
before.checkin.new.todo.check=檢查 TODO ({0})
before.checkin.new.todo.check.no.filter=檢查 TODO
before.checkin.options.check.smells.choose.profile=選擇組態檔案
before.checkin.options.check.smells.profile=使用 ''{0}'' 組態檔案分析程式碼(&A)
before.checkin.post.commit.error.dumb.mode=現在無法進行程式碼分析
before.checkin.standard.options.check.smells=分析程式碼(&A)
before.checkin.waiting.for.smart.mode=正在等待智能模式…
before.commit.file.contains.code.smells.edit.them.confirm.text=檔案 {0} 有問題。\\n\\
{1,choice, 0#無錯誤|1#1 個錯誤|2#{1} 個錯誤}和{2,choice, 0#無警告|1#1 個警告|2#{2} 個警告}。\\n\\
要檢視它們嗎?
before.commit.files.contain.code.smells.edit.them.confirm.text={0} 個檔案有問題。\\n\\
{1,choice, 0#無錯誤|1#1 個錯誤|2#{1} 個錯誤}，{2,choice, 0#無警告|1#1 個警告|2#{2} 個警告} \\n\\
要檢視它們嗎?
border.changes.filter.change.number.filter=更改
border.changes.filter.date.filter=日期
border.selected.revision.commit.message=提交訊息
border.standard.after.checkin.options.group=在{0}之後
border.standard.checkin.options.group=在{0}之前
border.standard.checkin.options.group.with.post.commit={0} 檢查
browse.changes.action=瀏覽更改
browse.changes.content.title={0}下的更改
browse.changes.error.message=存取 VCS 時發生問題: {0}
browse.changes.error.title=無法顯示更改
browse.changes.filter.title=指定搜尋條件
browse.changes.no.filter.prompt=尚未指定任何篩選條件。確定要檢視專案的整個歷史記錄嗎?
browse.changes.nothing.found=未找到與條件符合的任何更改
browse.changes.nothing.found.title=未找到任何更改
browse.changes.progress.title=正在搜尋更改
browse.changes.scope=影響 {0} 的更改
browse.changes.show.all.button=顯示所有更改
browse.changes.show.recent.button=顯示最近的更改
browse.changes.title=瀏覽更改
button.apply.patch=套用補丁
button.clear=清除
button.remove=移除
button.search.again=再次搜尋
button.skip=跳過
button.text.overwrite.modified.file=覆蓋已修改的檔案(&O)
button.text.overwrite.modified.files=覆蓋已修改的檔案(&O)
button.tooltip.remove.commit.author.date=移除
cache.settings.dialog.title=VCS 歷史記錄快取設定
cannot.apply.file.already.exists=無法將補丁套用到檔案 {0}: 它已存在。
cannot.create.directory.for.patch=不能建立檔案: {0}。{1}
cannot.find.file.to.patch=找不到要套用更新檔的檔案: {0}
change.dialog.title.change.list.name={0} [{1}]
change.dialog.title.in.change.list.name={1} 中的 {0}
change.file.copied.from.text=- 已從 {0} 複製
change.file.moved.from.text=- 已從 {0} 移動
change.file.moved.to.text=- 已移至 {0}
change.file.renamed.from.text=- 已從 {0} 重新命名
change.file.renamed.to.text=- 已重命名為 {0}
change.file.replaced.text=- 已取代
change.list.manager.wait.lists.synchronization.background={1, choice, 0#正在等待 |1#{0}: }本地更改重新整理
change.list.manager.wait.lists.synchronization.modal={1, choice, 0#正在等待 |1#{0}: }本地更改重新整理
change.list.scope.provider.local.changes=本地更改
change.list.scope.provider.only.changes=所有檔案中僅未提交到 VCS 的更改
change.list.scope.provider.only.changes.in.file=檔案 {0} 中僅未提交到 VCS 的更改
change.lists.manager.add.unversioned=新增未進行版本管理的檔案
change.nodetitle.change.is.outdated=檔案在伺服器上已被更改
change.shelves.location.dialog.action.button=更改位置
change.shelves.location.dialog.custom.label=自訂目錄(&U):
change.shelves.location.dialog.default.label=預設目錄:
change.shelves.location.dialog.group.title=將擱置存儲於:
change.shelves.location.dialog.location.browser.title=選擇要將擱置存儲在其中的目錄
change.shelves.location.dialog.title=更改擱置位置
changelist.details.committed.format=由 {0} {1} 提交
changelist.details.title=更改列表詳細資訊
changes.ExcludeChangedLinesFromCommit.chunks.action.text=從提交中排除所選塊
changes.IncludeChangedLinesIntoCommit.chunks.action.text=將所選塊包含到提交中
changes.action.include.in.operation.name=包含在 {0} 中(&I)
changes.action.rollback.custom.title={0}更改
changes.action.rollback.text=復原
changes.action.rollback.title={0}更改
changes.action.show.ignored.description=顯示忽略的檔案
changes.action.show.ignored.text=已忽略的檔案
changes.another.change.list=另一個
changes.browse=瀏覽
changes.browser.details.marker=更多…
changes.button.newer=較新的 >
changes.button.older=< 較舊的
changes.can.not.find.patch.for.path.in.patch.file=在更新檔檔案中找不到 {0} 的補丁。
changes.cant.load.changes=無法載入更改
changes.change.list.conflict.dialog.radio.button.ignore=忽略(&I)
changes.change.list.conflict.dialog.radio.button.shelve.changes=擱置更改(&S)
changes.changelists.to.cache.initially=最初要快取的更改列表:
changes.checkbox.delete.locally.added.files=刪除新增的檔案的本地副本(&D)
changes.checking.configuration.0.for.ignore=正在為忽略物件檢查組態 {0}…
changes.combined.diff=組合更改差異
changes.committed.changes=已提交更改
changes.configure=組態(&C)…
changes.days.of.history.to.cache.initially=最初要快取的歷史記錄的天數:
changes.default.change.list=預設
changes.default.changelist.name=更改
changes.default.changelist.name.old=預設更改列表
changes.deleting.added.files.locally=正在本地刪除已新增檔案…
changes.dialog.editchangelist.error.already.exists=名為 ''{0}'' 的更改列表已存在
changes.dialog.editchangelist.title=編輯更改列表
changes.dialog.message.failed.to.revert.apply.changes=無法{0, choice, 0#還原|1#套用}更改: 
changes.dialog.newchangelist.title=新增更改列表
changes.diff.separator=差異
changes.directory.does.not.belong.to.the.active.changelist={0, choice, 1#這一目錄|2#這些目錄}不屬於活動更改列表:
changes.do.cleanup=進行清理…
changes.editor.diff.preview.empty.title=更改
changes.editor.diff.preview.title=更改: {0}
changes.empty.changelists.no.longer.active={0,choice,1#空更改列表 ''''{1}'''' 已|2#空更改列表 '<br/>'{1} 已}不再活動。<br/>是否要將{0, choice,1#其|2#其}移除?
changes.error.can.t.get.revision.content=無法獲取修訂內容
changes.error.can.t.show.diff.for=無法顯示 ''{0}'' 的差異
changes.error.can.t.show.diff.for.binary.file=無法顯示二進制檔案 ''{0}'' 的差異
changes.error.cannot.find.base.for.path=找不到 ''{0}'' 的基
changes.error.content.for.0.was.removed=''{0}'' 的內容已被移除
changes.error.default.project.not.supported=不支持預設專案
changes.error.failed.to.create.content.for.current.revision=無法為當前修訂建立內容
changes.error.failed.to.fetch.current.revision=無法獲取當前修訂
changes.error.refreshing.vcs.history=重新整理 VCS 歷史記錄時出錯
changes.error.refreshing.view=重新整理檢視時出錯: {0}
changes.error.shelving.changes.failed=擱置更改失敗: {0}
changes.file.does.not.belong.to.the.active.changelist={0, choice, 1#這一檔案|2#這些檔案}不屬於活動更改列表:
changes.file.from.non.active.changelist.is.modified=停用更改列表中的檔案已修改
changes.finishing.changed.on.server.update=正在完成“在伺服器上被更改”更新
changes.hide.this.notification=隱藏此通知
changes.ignore.file=忽略檔案
changes.impossible.until.indices.are.up.to.date=在索引更新前不可行
changes.locked.by=被 {0} 鎖定
changes.minutes=分鐘
changes.move.changes.to.active.change.list.name=將更改移至活動更改列表({0})
changes.move.to.changelist=移至 ''{0}'' 更改列表
changes.new.changelist=新增更改列表
changes.no.incoming.changelists.available=無可用傳入更改列表
changes.no.tracking.branch=無追蹤分支
changes.no.tracking.branch.suffix=\\ (無追蹤分支)
changes.nodetitle.changecount={0,choice, 0#無檔案|1#1 個檔案|2#{0} 個檔案}
changes.nodetitle.directory.changecount={0,choice, 0#無目錄|1#1 個目錄|2#{0} 個目錄}
changes.nodetitle.directory.file.changecount={0,choice, 0#無目錄|1#1 個目錄|2#{0} 個目錄}，{1,choice, 0#無檔案|1#1 個檔案|2#{1} 個檔案}
changes.nodetitle.empty.changelist.name=<空名稱>
changes.nodetitle.filter.pending=未篩選
changes.nodetitle.filtered.out=已篩選
changes.nodetitle.have.outdated.files=某些檔案在伺服器上已被更改
changes.nodetitle.ignored.files=已忽略的檔案
changes.nodetitle.locally.deleted.files=本地已刪除的檔案
changes.nodetitle.locked.folders=鎖定的工作副本目錄
changes.nodetitle.locked.folders.tooltip=某些目錄已被鎖定；不允許對它們進行 VCS 動作。應執行清理。
changes.nodetitle.logicallt.locked.folders=明確鎖定的檔案
changes.nodetitle.merge.conflicts=合併衝突
changes.nodetitle.merge.conflicts.resolve.link.label=解決
changes.nodetitle.modified.without.editing=已修改，但未簽出的檔案
changes.nodetitle.switched.files=已切換的檔案
changes.nodetitle.switched.roots=根開關
changes.nodetitle.unversioned.files=未進行版本管理的檔案
changes.nodetitle.updating=正在更新…
changes.none=<無>
changes.notification.content.repository.location.not.found.for=找不到 {0} 的版本庫位置
changes.please.enter.a.valid.regex=請輸入有效正則表達式
changes.progress.text.vcs.name.performing.operation.name={0}: 正在執行 {1}…
changes.progress.title.choice.revert.apply.changes={0, choice, 0#還原|1#套用}更改
changes.project.exclude.paths=專案排除路徑
changes.refresh.changelists.after.update=更新後重新整理更改列表
changes.refresh.changes.every=更改重新整理間隔
changes.remove.active.empty.prompt=選擇要設為活動的更改列表:
changes.remove.active.prompt=選擇應將更改移至其中的更改列表:
changes.remove.active.title=刪除活動更改列表
changes.removechangelist.all.lists.warning.text=確定要移除{0}個更改列表嗎?\\n\\
所有更改都將移至新的預設更改列表。
changes.removechangelist.multiple.warning.text=確定要刪除{0}個更改列表?\\n\\
所有的更改將會移至活動的更改列表中。
changes.removechangelist.warning.text=確定要移除更改列表 ''{0}'' 嗎?\\n\\
所有更改都將移至活動更改列表。
changes.removechangelist.warning.title=刪除更改列表
changes.removing.configuration.0.from.ignore=正在從忽略物件中移除組態 {0}…
changes.revert.apply.change.list.name={0, choice, 0#還原: |1#套用: }{1}
changes.set.active.changelist.to.change.list.name=將活動更改列表設定為 ''{0}''
changes.switched.to.branch.name=已切換到 {0}
changes.tab.title.vcs.errors=VCS 錯誤
changes.text.default.ignored.files=預設忽略的檔案
changes.title.loading.changes=正在載入更改
changes.tried.to.save.uncommitted.changes.in.shelve.before.s.but.failed.with.an.error=嘗試在{0}之前擱置未提交的更改，但因為錯誤而失敗。<br/>{1}
changes.warning.not.all.local.changes.may.be.shown.due.to.an.error=警告: 由於錯誤，可能不會顯示所有本地更改: {0}
checkbox.amend=修正(_M)
checkbox.checkin.options.optimize.imports=最佳化 import(&O)
checkbox.checkin.options.rearrange.code=重新整理程式碼(&N)
checkbox.checkin.options.reformat.code=格式化程式碼(&R)
checkbox.clear.initial.commit.message=清除初始提交訊息(&I)
checkbox.include=包含(&I)
checkbox.include.issues.not.assigned.to.me=包括未分配給我的問題
checkbox.including.files.created.outside.ide=應用於在 {0} 外部建立的檔案
checkbox.remember.my.choice=記住我的選擇(&R)
checkbox.select.current.file.only=僅選擇當前檔案(&C)
checkbox.show.changed.revisions.only=僅更改
checkbox.show.changes.after.date=之後(&A)
checkbox.show.changes.after.num=從(&F)
checkbox.show.changes.before.date=之前(&B)
checkbox.show.changes.before.num=到(&T):
checkbox.show.clear.read.only.status.dialog=如果嘗試編輯唯讀檔案，則提示將其解鎖
checkbox.show.dirty.recursively=在專案樹中醒目提示包含已修改檔案的目錄
checkin.can.not.load.current.revision=無法載入當前修訂
checkin.can.not.load.previous.revision=無法載入之前的修訂
checkin.commit.checks.failed=提交檢查失敗
checkin.commit.checks.failed.cancel.button=取消(&N)
checkin.dialog.title.todo=TODO
checkin.filter.filter.name=篩選器: {0}
checkin.invalid.file.s=無效檔案
checkin.title.for.commit.0=以供提交 ({0})
checkin.unresolved.merge.are.you.sure.you.want.to.commit.changes.with.unresolved.conflicts=確定要提交有未解決衝突的更改嗎?
checkin.unresolved.merge.unresolved.conflicts=未解決的衝突
checkin.wait=等待(&W)
checking.code.smells.progress.title=正在執行程式碼分析
checking.recent.changes=正在檢查最近的更改…
checking.vcs.status.progress=正在檢查 VCS 狀態…
clone.dialog.clone.button=克隆
clone.dialog.clone.failed.error=克隆失敗
clone.dialog.repository.url.item=版本庫 URL
clone.dialog.unable.create.destination.error=無法建立目標目錄
code.smells.error.messages.tab.name=程式碼分析
code.smells.review.button=檢查程式碼分析(&R)
column.info.configure.vcses.directory=目錄
column.name.configure.vcses.vcs=VCS
column.name.revision.date=日期
column.name.revision.list.author=作者
column.name.revision.list.committer=使用者
column.name.revision.list.date=日期
column.name.revision.list.description=描述
column.name.revision.list.number=數字
column.name.revision.list.revision=修訂
column.name.revision.version=版本
column.name.revisions.list.branch=分支
column.name.revisions.list.filter=日期
command.name.open.error.message.view=開啟訊息檢視
commit.amend.commit=修正提交
commit.changes=提交更改
commit.checks.error.indexing=現在無法進行程式碼分析
commit.checks.error.indexing.message=當 {0} 在背景更新索引時，無法執行提交檢查。\\n\\
您可以在不執行檢查的情況下提交更改，也可以等到索引建立後再提交。
commit.checks.failed.notification.commit.anyway.action=仍然{0}
commit.checks.failed.notification.show.details.action=顯示詳細資訊
commit.checks.failed.notification.title={0} 檢查失敗
commit.checks.on.commit.progress.text=正在提交…
commit.checks.on.commit.progress.text.with.context=正在提交: {0}
commit.checks.only.progress.text=正在執行提交檢查…
commit.checks.only.progress.text.with.context=正在執行提交檢查: {0}
commit.description.tooltip.author=作者: {0}
commit.description.tooltip.commit=提交 {0}
commit.description.tooltip.date=日期: {0}
commit.description.tooltip.path=路徑: {0}
commit.dialog.changelist.label=更改列表(&T):
commit.dialog.configurable=提交
commit.dialog.default.commit.operation.name=Comm&it
commit.dialog.include.action.name=包含到提交裡(&I)
commit.dialog.no.changes.detected.text=未檢測到更改
commit.dialog.no.changes.detected.title=沒有要提交的內容
commit.dialog.partial.commit.warning.body=不支持 ''{0}'' 的部分提交。\\n\\
所選檔案中的所有更改都將提交。
commit.dialog.partial.commit.warning.title=不支持部分提交
commit.dialog.refresh.files=正在同步檔案…
commit.dialog.title=提交更改
commit.editor.diff.preview.empty.title=提交
commit.editor.diff.preview.title=提交: {0}
commit.legend.deleted=已刪除
commit.legend.modified=已修改
commit.legend.new=已新增
commit.message=提交訊息
commit.message.inspection.message.body.lines.should.not.exceed.characters=正文行不能超過 {0} 個字元
commit.message.inspection.message.subject.should.not.exceed.characters=主題不能超過 {0} 個字元
commit.message.intention.family.name.reformat.commit.message=重新格式化提交訊息
commit.message.intention.family.name.wrap.line=換行
commit.message.missing.blank.line.between.subject.and.body=主題與正文之間缺少空行
commit.message.placeholder=提交訊息
commit.progress.title=提交
commit.tooltip.merge.this.commit.with.the.previous.one=將此提交與前一個提交合併
commit.wait.util.synched.text=正在執行 VCS 重新整理…
committed.changes.empty.comment=<無註釋>
committed.changes.empty.message=版本庫沒有提交的更改
committed.changes.filter.all=所有
committed.changes.filter.none=<無>
committed.changes.filter.title=篩選依據
committed.changes.group.title=分組依據
committed.changes.incorrect.regex.message=篩選器中使用的正則表達式無效
committed.changes.not.loaded.message=按“重新整理”按鈕以載入版本庫更改
committed.changes.partial.list=[部分]
committed.changes.refresh.progress=正在重新整理 VCS 歷史記錄
committed.changes.regex.title=正則表達式(&G)
committed.changes.tab=版本庫
compare.with.dialog.get.from.vcs.action.title=從 VCS 獲取
composite.change.provider.include.vcs.checkbox=包含{0}中的更改
configurable.ChangelistConflictConfigurable.display.name=更改列表
configurable.IssueNavigationConfigurationPanel.display.name=問題導覽
configurable.VcsContentAnnotationConfigurable.display.name=顯示最近更改
configurable.VcsDirectoryConfigurationPanel.display.name=目錄映射
configurable.VcsGeneralConfigurationConfigurable.display.name=確認
configurable.issue.link.edit=編輯
configurable.issue.link.remove=移除
configurable.shelf.storage.cant.find.or.create.new.shelf.directory=找不到或建立新的擱置目錄
configurable.shelf.storage.destination.shelf.directory.should.have.read.access=目標擱置目錄必須具備讀取權限
configurable.shelf.storage.destination.shelf.directory.should.have.write.access=目標擱置目錄必須具備寫入權限
configurable.vcs.manage.scopes=管理作用域
confirmation.message.add.ignored.single.directory=新增忽略的目錄?
confirmation.message.add.ignored.single.file=新增忽略的檔案?
confirmation.title.add.file.to=將檔案新增到 {0}?
confirmation.title.add.files.to=將檔案新增到 {0}?
confirmation.title.add.ignored.files.or.dirs=確認新增忽略檔案和目錄
confirmation.title.add.ignored.single.directory=確認新增忽略的目錄
confirmation.title.add.ignored.single.file=確認新增忽略的檔案
copy.revision.number.action=複製修訂號
create.patch.commit.action.progress=正在建立更新檔…
create.patch.commit.action.title=建立更新檔
create.patch.encoding=編碼(&E):
create.patch.error.title=建立補丁時出錯: {0}
create.patch.file.path=到檔案(&P):
create.patch.loading.content.progress=正在載入內容修訂
create.patch.reverse.checkbox=反轉更新檔(&R)
create.patch.settings.dialog.title=更新檔檔案設定
create.patch.success.confirmation=已成功建立更新檔 {0}
create.patch.to.clipboard=到剪貼簿(&C)
current.version.text={4}<br/><br/>當前版本為 {3}。<br/>修改者為 {0}<br/>{1}<br/>{2}
date.group.last.week=過去一周
date.group.title=日期
date.group.today=今天
description.text.option.applicable.to.vcses=適用於 {0}
dialog.enable.version.control.integration.hint.text=可在以下位置組態版本控制設定 
dialog.enable.version.control.integration.select.vcs.label.text=選擇要與{0}關聯的版本控制系統:
dialog.enable.version.control.integration.title=啟用版本控制整合
dialog.message.can.t.create.text.editor.for=無法為 {0} 建立文本編輯器
dialog.message.conflict.seems.to.be.resolved=衝突似乎已解決
dialog.message.enter.directory.name=為建立的專案輸入目錄名稱。留空可直接簽出到“{0}”。
dialog.message.no.changes.for.this.file=此檔案沒有更改
dialog.title.cannot.convert.module=無法轉換模組
dialog.title.changes.browser=更改瀏覽器
dialog.title.files.created=檔案已建立
dialog.title.ignored.files=已忽略的檔案
dialog.title.message=訊息
dialog.title.move.changes.to.active.changelist=將更改移至活動更改列表
dialog.title.no.conflict.found=未找到衝突
dialog.title.project.directory.name=專案目錄名稱
dialog.title.remove.empty.changelist=移除空更改列表
dialog.title.resolve.changelist.conflict=解決更改列表衝突
dialog.title.select.destination.folder=選擇目標目錄
dialog.title.unversioned.files=未進行版本管理的檔案
diff.content.title.revision.number=修訂 {0}
diff.producer.error.cant.get.revision.content=無法獲取修訂內容
diff.title.local=本地
diff.title.local.with.number=本地({0})
directory.mapping.add.title=新增 VCS 目錄映射
directory.mapping.remove.title=編輯 VCS 目錄映射
edit.changelist.description=註釋(&C):
edit.changelist.name=名稱(&N):
edit.errors=編輯錯誤
edit.source.action.text=編輯源
error.adding.files.notification.title=無法新增檔案
error.adding.files.prompt=新增檔案時發生以下問題:
error.adding.files.title=無法新增檔案
error.cant.perform.operation.now=現在無法{0}
error.change.from.must.be.a.valid.number=起始日期必須是有效數字
error.change.to.must.be.a.valid.number=更改物件必須是有效數字
error.date.after.must.be.a.valid.date=之後的日期必須是有效日期
error.date.before.must.be.a.valid.date=之前的日期必須是有效日期
error.executing.commit=執行 ''{0}'' 時出錯: {1}
error.no.changes.no.commit.message=選擇要提交的檔案並指定提交訊息
error.no.changes.to.commit=選擇要提交的檔案
error.no.commit.message=指定提交訊息
error.text.check.in.with.empty.comment=請指定註釋
error.title.check.in.with.empty.comment=註釋為空
error.updating.changes=更新更改時出錯: {0}
ex.changelists=更改列表
ex.move.lines.to.another.changelist.0=將行移至另一個更改列表({0})
ex.new.changelist=新增更改列表…
exception.text.internal.error.method.should.not.be.called=不應呼叫
exception.text.internal.errror.could.not.implement.method=無法實作
exception.text.unknown.error=未知錯誤
executable.project.override=僅為當前專案設定此路徑
executable.project.override.reset.globalize=設為全域
executable.project.override.reset.message=為此專案組態的可執行檔案路徑既可以設為所有專案的全域路徑，也可以還原為當前全域可執行檔案
executable.project.override.reset.revert=還原
executable.project.override.reset.title=專案可執行檔案
executable.select.label={0} 可執行檔案路徑(&P):
executable.select.title=選擇可執行檔案
executable.test=測試
external.files.add.notification.action.add=始終新增
external.files.add.notification.action.mute=不再詢問
external.files.add.notification.action.view=檢視檔案
external.files.add.notification.message=外部新增的檔案可以新增到 {0}
external.files.add.view.dialog.title=將檔案新增到 {0}
file.content.too.big.to.load.increase.property.suggestion=無法顯示 ''{0}'' 的內容。\\n\\
該檔案大小大於 {1}。\\n\\
\\n\\
您可以通過在 ''idea.properties'' 檔案中增大{2}屬性來覆寫此限制。
file.history.checking.last.revision.process=正在檢查最新修訂
file.history.details.committer.info=由 {0} 提交
file.history.details.committer.tooltip.info=通過 {0}
file.history.details.empty.status=提交訊息
file.history.details.hash.author.on.date.at.time={0} {1}，{2} {3}
file.history.diff.handler.affected.changes.title={1} 中的初始提交 {0}
file.history.diff.handler.collecting.affected.process=正在收集受影響的更改…
file.history.diff.handler.comparing.process=正在比較修訂…
file.history.diff.handler.paths.diff.title={0} 與 {2} 中的 {1} 之間的差異
file.history.diff.handler.paths.diff.with.local.title={0} 與 {1} 中的本地版本之間的差異
file.history.diff.handler.process.error=任務期間出錯: {0}
file.history.diff.revisions.process=正在比較修訂…
file.history.exceeded.limit.message=檔案歷史記錄: 僅為 {1} 載入了 {0} 個修訂\\n\\
要更改歷史記錄限制，請轉到 {2}
file.history.tab.name=歷史記錄
filetype.patch.description=補丁
filetype.patch.display.name=補丁
filter.none.name=無
filter.structure.name=結構
get.from.vcs.extension.list.accessible.name=版本庫位置
get.from.version.control=從版本控制獲取
group.mainmenu.vcs.current.file.text=當前檔案
group.name.version.control=VCS(&V)
handle.ro.file.status.type.using.vcs=使用 {0}
hide.this.notification=隱藏此通知
history.dialog.title.difference.between.versions.in={2} 中的 {0} 和 {1} 版本的差異
history.empty=歷史記錄為空
history.failed.to.load.content.for.revision.0=無法為修訂 {0} 載入內容
history.file.not.found=找不到檔案 {0}
history.loading.revisions=正在載入受影響的修訂
history.tab.title.can.not.load.changelist.contents=無法載入更改列表內容
ignore.codeInspection.duplicateEntry=忽略檔案重複項
ignore.codeInspection.duplicateEntry.message=<code>#ref</code> 模式不止定義一次 #loc
ignore.codeInspection.group=版本控制
ignore.quick.fix.remove.entry=移除模式
ignore.to.exclude.no.directories.found=未找到要排除的目錄
ignore.to.exclude.notification.action.details=了解更多
ignore.to.exclude.notification.action.mute=不再顯示
ignore.to.exclude.notification.action.view=檢視目錄
ignore.to.exclude.notification.message=部分忽略的目錄未從索引和搜尋中排除
ignore.to.exclude.notification.notice=<html><b>註</b>: 建議在排除之前重新檢查目錄內容。一些目錄可能包含不應排除的項。</html>
ignore.to.exclude.view.dialog.exclude.action=排除(&E)
ignore.to.exclude.view.dialog.title=排除目錄
ignoreTokenType./=<斜杠>
ignoreTokenType.BRACKET_LEFT=<左括號>
ignoreTokenType.BRACKET_RIGHT=<右括號>
ignoreTokenType.COMMENT=<註釋>
ignoreTokenType.CRLF=<空行>
ignoreTokenType.HEADER=<標頭>
ignoreTokenType.SECTION=<部分>
ignoreTokenType.VALUE=<值>
ignoreTokenType.syntax:=<語法>
ignored.file.excluded.settings.title=排除目錄管理策略
ignored.file.excluded.to.ignored.label=將排除目錄新增到忽略檔案
ignored.file.general.settings.title=一般設定
ignored.file.ignored.to.excluded.label=將忽略目錄標記為已排除
ignored.file.manage.all.project=在所有專案中
ignored.file.manage.all.projects.option=為所有專案管理
ignored.file.manage.always.ask.option=始終詢問
ignored.file.manage.message={0} 可以自動將經常被忽略的檔案新增到 {1}。
ignored.file.manage.notmanage=不新增
ignored.file.manage.policy.label=忽略檔案管理策略:
ignored.file.manage.this.project=在此專案中
ignored.file.manage.this.project.option=僅為此專案管理
ignored.file.manage.view=檢視
ignored.file.manage.view.dialog.ignore.action=忽略(&I)
ignored.file.manage.view.dialog.title=將檔案新增到忽略
ignored.file.manage.with.files.message={0} 可以自動將經常被忽略的檔案新增到 {1}。
ignored.file.not.manage.option=關閉套用範圍
ignored.file.not.manage.this.project.option=不只為此專案管理
ignored.file.tab.title=已忽略的檔案
ignoring.files.progress.title=正在忽略檔案…
impl.notification.content.could.not.find.plugin=找不到延伸模組 {0}
impl.notification.content.plugin.was.unbundled.needs.to.be.installed.manually={0} 延伸模組已解除捆綁，需要手動安裝
impl.notification.content.vcs.plugin.not.found.for.mapping.to=沒有為 ''{0}'' 的映射找到 VCS 延伸模組
impl.notification.title.failed.to.install.plugin=安裝延伸模組失敗
impl.progress.title.installing.plugin=正在安裝延伸模組…
impl.show.all.affected.files.for.path.at.revision.failed=為 {0} 顯示 {1} 失敗時所有受影響的檔案
impl.vcs.initialization=VCS 初始化
import.patches=匯入更新檔
import.patches.into.shelf=將補丁匯入到擱置…
incoming.changes.empty.message=沒有傳入的更改
incoming.changes.indicator.name=傳入更改
incoming.changes.indicator.tooltip={0} 個可用的傳入更改列表
incoming.changes.not.loaded.message=按“重新整理”按鈕以載入傳入的更改
incoming.changes.tab=傳入
inlay.vcs.code.author.description=根據 VCS 中的記錄獲得的程式碼作者。<br><br>作者是最後編輯類別、方法或函式的人。如果有來自不同作者的多個提交，擁有最多行的那個會被視為作者。
inspection.BodyLimitInspection.display.name=限制正文行
inspection.CommitMessageSpellCheckingInspection.display.name=拼寫
inspection.SubjectBodySeparationInspection.display.name=主題與正文之間的空白行
inspection.SubjectLimitInspection.display.name=限制主題行
issue.action.add.jira.issue.navigation.pattern.title=新增 JIRA 問題導覽模式
issue.action.add.youtrack.issue.navigation.pattern.title=新增 YouTrack 問題導覽模式
issue.action.enter.jira.installation.url.label=輸入 JIRA 安裝 URL:
issue.action.enter.youtrack.installation.url.label=輸入 YouTrack 安裝 URL:
issue.link.add.title=新增問題導覽連結
issue.link.delete.prompt=刪除所選導覽連結?
issue.link.delete.title=刪除問題導覽連結
issue.link.edit.title=編輯問題導覽連結
issue.link.issue.column=問題
issue.link.link.column=連結
issue.link.no.patterns=未組態模式
jb.protocol.no.provider=找不到 VCS 提供程序: ''{0}''
label.at.date.leading=在 {0}
label.at.date.middle=在 {0}
label.by.author=作者
label.code.author.inlay.hints=程式碼作者
label.commit.checks.failed.unknown.reason=檢查失敗
label.commit.checks.not.available.during.indexing=編制索引期間無法提交檢查
label.commit.comment=提交訊息(&M)
label.multi.author.modified.code={0} +{1} *
label.multi.author.not.modified.code={0} +{1}
label.new.code=新 *
label.project.vcs.root.mapping=<專案>
label.relative.project.path.presentation=<專案>/{0}
label.select.files.to.be.added.to.version.control=選擇要新增到版本控制中的檔案
label.selected.revision.commit.message=提交訊息
label.single.author.modified.code={0} *
label.todo.items.found={0} 個 TODO
line.annotation.aspect.author=作者
line.annotation.aspect.date=日期
line.annotation.aspect.revision=修訂
link.label.display.anyway=仍然顯示
link.label.hide=隱藏
link.label.ignore=忽略
link.label.move.changes=移動更改
link.label.switch.changelist=切換更改列表
loading.file.history.progress=正在載入檔案歷史記錄
loading.file.history.status=正在載入 {0} 的歷史記錄…
loading.file.history.up.to.revision.status=正在載入 {0} 截至 {1} 的歷史記錄…
loading.text2.file.history.progress=正在載入檔案歷史記錄
local.changes.freeze.message={0}完成之前，本地更改不可用
local.changes.tab=本地更改
local.history.update.from.vcs=從 VCS 更新
local.version.title=本地版本
looking.for.patch.files=正在尋找更新檔檔案…
lookup.title.vcs.file.revisions=檔案修訂
lst.inactive.ranges.damaged.notification=部分更改已移至活動更改列表
merge.loading.merge.details=正在載入合併詳細資訊…
message.read.only.status.content=您以 <b>root</b> 身份登入，因此: <br><br>- {0} 無法看到唯讀狀態的檔案。<br>- 所有檔案都被視為可寫入。<br>- 修改時無法自動簽出檔案。
message.read.only.status.title={0}: 無法看到唯讀狀態
message.text.all.files.are.up.to.date=所有檔案都處於最新狀態
message.text.background.tasks=正在等待背景 VCS 任務完成…
message.text.cannot.edit.file=無法編輯檔案: {0}
message.text.cannot.load.revision=無法載入修訂: {0}
message.text.cannot.open.editor=無法開啟檔案 {0} 的文本編輯器
message.text.cannot.save.content=無法儲存內容: {0}
message.text.cannot.save.settings=無法執行動作: {0}
message.text.cannot.show.differences=無法顯示差異: {0}
message.text.commit.failed.with.error=提交失敗，有{0,choice,1#錯誤|2#錯誤}
message.text.commit.finished.with.warning=提交完成，有{0,choice,1#警告|2#警告}
message.text.commit.progress=正在提交…
message.text.could.not.load.virtual.file.content=無法載入檔案 {0} 的內容: {1}
message.text.file.is.up.to.date=檔案處於最新狀態
message.text.file.locally.modified=檔案 {0} 已在本地被修改。
message.text.several.files.locally.modified=某些檔案已在本地被修改。
message.title.annotate=註解
message.title.cannot.open.editor=無法開啟編輯器
message.title.could.not.load.content=無法載入內容
message.title.could.not.load.file.history=載入檔案歷史記錄時發生問題
message.title.edit.files=編輯檔案
message.title.get.revision.content=獲取修訂內容
message.title.get.version=獲取版本
message.title.show.differences=顯示差異
message.title.vcs.update.errors={0}錯誤
move.to.another.changelist.nothing.selected.notification=沒有選擇任何可以移動的專案
move.to.changelist=將更改移至活動更改列表(''{0}'')(&M)
multiple.file.merge.accept.theirs=接受他們的(&T)
multiple.file.merge.accept.yours=接受您的更改(&Y)
multiple.file.merge.column.name=名稱
multiple.file.merge.dialog.command.name.accept.theirs=接受他們的更改
multiple.file.merge.dialog.command.name.accept.yours=接受您的更改
multiple.file.merge.dialog.error.loading.revisions.to.merge=載入待合併修訂時出錯: {0}
multiple.file.merge.dialog.message.error.saving.merged.data=儲存合併資料時出錯: {0}
multiple.file.merge.dialog.message.file.too.big.to.be.loaded=檔案過大，無法載入
multiple.file.merge.dialog.progress.title.loading.revisions=正在載入修訂…
multiple.file.merge.dialog.progress.title.resolving.conflicts=正在解決衝突…
multiple.file.merge.dialog.title.can.t.show.merge.dialog=無法顯示“合併”對話框
multiple.file.merge.group.by.directory.checkbox=按目錄對檔案分組
multiple.file.merge.loading.progress.title=正在載入合併修訂…
multiple.file.merge.merge=合併(&M)…
multiple.file.merge.request.title=合併 {0} 的修訂
multiple.file.merge.title=衝突
new.changelist.duplicate.name.error=具有該名稱的更改列表已存在
new.changelist.empty.name.error=無法使用空名稱建立新的更改列表
new.changelist.make.active.checkbox=設為活動(&A)
new.changelist.new.label=新增
no.ignored.files=沒有忽略的檔案
non.modal.commit.promoter.dont.show.again.action.text=不再顯示
non.modal.commit.promoter.text=新的非強制回應提交介面可用。從工具視窗提交並在編輯器中檢視差異。
non.modal.commit.promoter.use.non.modal.action.text=切換到工具視窗
none.vcs.presentation=<無>
notification.content.didn.t.update.repository.changes=由於發生錯誤，未使用新消息更新版本庫更改: {0}
notification.group.external.executable=VCS 外部可執行檔案驗證失敗
notification.group.vcs.common.messages=VCS 普通訊息
notification.group.vcs.important.messages=VCS 重要訊息
notification.group.vcs.messages=VCS 訊息
notification.group.vcs.notifications=VCS 通知
notification.group.vcs.silent.notifications=VCS 靜默通知
notification.showDetailsInConsole=在主控台中顯示詳細資訊
notification.title.cant.load.annotations=無法載入註解
notification.title.couldn.t.save.uncommitted.changes=無法儲存未提交的更改。
notification.title.vcs.name.repository.repositories.found=已找到 {0} 個{1, choice, 1#版本庫|2#版本庫}
open.repository.version.description=在編輯器中開啟檔案的所選修訂
open.repository.version.text=開啟版本庫版本
operation.name.annotate=註釋
outdated.version.show.diff.action=顯示差異
outdated.version.text=過時的版本。{0} 在 {1} {3,choice,0#修改|1#刪除}了以下訊息: {2}
outdated.version.update.project.action=更新專案
patch.apply.abort.action=中止…
patch.apply.abort.and.rollback.action=中止並復原(_A)
patch.apply.abort.and.rollback.prompt=中止並復原套用更新檔還是跳過此檔案?
patch.apply.abort.title=中止更新檔
patch.apply.aborted.message=“套用補丁”動作期間更改的所有檔案已被復原
patch.apply.aborted.title=套用更新檔中止
patch.apply.added.status=已新增
patch.apply.after.patch.label.text=補丁後
patch.apply.already.applied=指定更新檔的所有更改均已包含在程式碼中
patch.apply.already.applied.status=已套用
patch.apply.already.exists.overwrite.prompt=檔案 {0} ({1})已存在。\\n\\
是否要覆蓋它?
patch.apply.analyze.from.clipboard.on.the.fly.checkbox=動態分析和套用剪貼簿中的更新檔
patch.apply.automatically.applied.status=已自動套用
patch.apply.bad.diff.title=更新檔套用的結果
patch.apply.bad.diff.to.title=將補丁應用於 {0} 的結果
patch.apply.before.patch.label.text=補丁前
patch.apply.can.not.apply.additional.info.error=無法套用附加更新檔資訊: {0}
patch.apply.can.t.find.patch.file.warning=找不到補丁檔案 {0}
patch.apply.cannot.apply.now=現在無法套用更新檔
patch.apply.cannot.read.patch=無法讀取更新檔 {0}: {1}
patch.apply.change.directory.paths.group=更改目錄路徑
patch.apply.changes.in.patch.resolve=在補丁解析中{0}
patch.apply.command=套用補丁
patch.apply.conflict.for.title={0}的補丁衝突
patch.apply.conflict.local.version=本地版本
patch.apply.conflict.merged.version=合併結果
patch.apply.conflict.patch=補丁
patch.apply.conflict.patched.somehow.version=結果
patch.apply.conflict.patched.version=更新檔版本
patch.apply.conflict.title=補丁衝突
patch.apply.continue.resolve.action=繼續解析
patch.apply.deleted.status=已刪除
patch.apply.dialog.title=套用補丁
patch.apply.display.local.content.was.modified.error=無法顯示更新檔套用者 - 本地內容已修改
patch.apply.error.conflict=套用更新檔衝突
patch.apply.error.document.not.found=找不到文檔 {0}
patch.apply.error.file.not.found=找不到檔案 {0}
patch.apply.file.name.field=補丁檔名(&P):
patch.apply.file.type.binary.error=無法從補丁套用 {0} 檔案，因為它是二進制檔案。
patch.apply.file.type.directory.error=無法從補丁套用 {0} 檔案的內容，因為它是目錄。
patch.apply.file.type.undefined.error=無法從補丁套用 {0} 檔案的內容，因為它的類型未定義。
patch.apply.hunk.warning=無法檢測到下列項的區塊修改行: -{0},{1} +{2},{3}
patch.apply.incorrectly.processed.warning=VCS 可能未正確處理以下{0, choice, 1#檔案|2#檔案}。\\n\\
請手動檢查{0, choice, 1#它|2#它們}: {1}
patch.apply.map.base.directory.action=映射基目錄…
patch.apply.marker.renderer=標記: {0}
patch.apply.missing.base.file.label=缺少基
patch.apply.modified.status=已修改
patch.apply.new.base.detected.node.description=檢測到新基
patch.apply.new.files.warning=套用更新檔建立新檔案報錯
patch.apply.not.applied.status=未套用
patch.apply.not.patch.type.file.error=所選檔案 {0} 不是補丁類型檔案
patch.apply.notification.title=套用補丁
patch.apply.old.new.base.info=更改前: {0} (基目錄: {1})<br/>更改後: {2} (基目錄: {3})
patch.apply.outside.content.root.message=在內容根外部找到補丁檔案: {0}
patch.apply.overwrite.existing.file.prompt=以下檔案應通過更新檔建立，但它已經存在。\\n\\
是否要覆蓋它?\\n\\
{0}
patch.apply.overwrite.existing.files.prompt=以下檔案應通過更新檔建立，但它們已經存在。\\n\\
是否要覆蓋它們?
patch.apply.overwrite.existing.title=覆蓋現有檔案
patch.apply.partially.applied=指定更新檔的某些更改已被跳過，因為它們已包含在程式碼中
patch.apply.partly.failed.title=更新檔部分套用失敗
patch.apply.progress.title=正在套用更新檔…
patch.apply.rollback.action=復原
patch.apply.rollback.failed.message=嘗試使用“本地歷史記錄”對話框手動執行還原。
patch.apply.rollback.failed.title=復原失敗
patch.apply.rollback.progress=復原套用的更改…
patch.apply.rollback.progress.title=復原套用的更改…
patch.apply.rollback.prompt=無法{0, choice, 0#套用補丁。|1#將補丁套用到檔案:|2#將補丁套用到檔案:}
patch.apply.rollback.prompt.bottom=更新檔中的其他更改已成功套用，是否要復原它們?
patch.apply.rollback.will.not.affect.binaries.info=復原不會影響二進制檔案
patch.apply.select.base.for.a.path.message=為路徑選擇基
patch.apply.select.base.title=選擇{0, choice, 0#目錄|1#檔案}基
patch.apply.select.missing.base.link=選擇缺少的基
patch.apply.select.title=選擇更新檔檔案
patch.apply.skip.action=跳過(_S)
patch.apply.somehow.diff.name=以某種方式套用更新檔
patch.apply.stripped.description=\\ 去除的{0}
patch.apply.success.applied.text=已成功套用補丁
patch.apply.syntax.line=\\ (行: {0})
patch.apply.wrong.base.and.can.t.be.applied.warning={0} 的補丁的基錯誤，無法正確套用
patch.binary.decoder.char.error=無法解碼二進制檔案更新檔: 字元大小符號錯誤
patch.binary.decoder.content.error=解碼的二進制內容{0,choice,0#少於|1#多於}預期
patch.binary.decoder.decompress.error=無法解碼二進制檔案更新檔: 無法解壓資料
patch.binary.decoder.line.error=無法編碼二進制檔案更新檔: 行大小錯誤
patch.can.t.detect.file.names.from.git.format.header.line=無法從 git 格式頭行檢測檔名
patch.contains.additional.information.without.patch.itself=包含附加資訊但不含更新檔本身
patch.content.viewer.name=補丁內容檢視器
patch.copied.to.clipboard=更新檔已複製到剪貼簿
patch.creation.base.dir.does.not.exist.error=基目錄不存在
patch.creation.base.path.field=基路徑(&B):
patch.creation.can.not.write.patch.error=無法將更新檔寫入指定檔案: {0}
patch.creation.empty.base.path.error=基路徑不能為空!
patch.creation.failed=更新檔建立失敗
patch.creation.name.too.long.error=檔案路徑不應過長。
patch.creation.save.patch.file.title=儲存更新檔檔案
patch.creation.save.to.file.button=將補丁儲存到檔案
patch.creation.save.to.title=將補丁儲存到
patch.creation.wrong.base.path.for.changes.error=基路徑不包含所有所選更改(使用 {0})
patch.empty.0.data.section=空 ''{0}'' 資料分區
patch.empty.additional.info.header=空的附加資訊頭
patch.failed.to.fetch.old.content.for.file.name.in.revision=無法在修訂 {1} 中獲取檔案 {0} 的舊內容
patch.import.additional.info.error=無法匯入附加更新檔資訊: {0}
patch.import.no.patches.found.warning=未找到更新檔
patch.import.to.shelf.progress.title=將補丁匯入到 Shelf
patch.import.to.shelf.tab=將補丁匯入到 Shelf
patch.missing.after.hunk=缺少 after 區塊
patch.second.file.name.expected=應為第二個檔名
patch.simple.apply.base.line.error=意外的基行: 應為 - {0}，實際為 - {1}
patch.simple.apply.base.line.total.error=意外的基行: 總行數為 - {0}，實際為 - {1}
patch.simple.apply.hunk.base.body.error=意外的區塊基主體: 應為 - {0}，實際為 - {1}
patch.simple.apply.hunk.base.end.error=意外的區塊基結束: 總行數為 - {0}，區塊結束為 - {1}
patch.simple.apply.hunk.base.start.error=意外的區塊基開始: 應為 - {0}，實際為 - {1}
patch.simple.apply.hunk.content.error=意外的區塊內容: 應為 - {0}，實際為 - {1}
patch.simple.apply.hunk.patched.body.error=意外的區塊補丁主體: 應為 - {0}，實際為 - {1}
patch.simple.apply.hunk.patched.start.error=意外的區塊更新檔開始: 應為 - {0}，實際為 - {1}
patch.unexpected.end.of.binary.patch=二進制補丁意外結束
patch.unknown.after.hunk.start.syntax=未知的 after 區塊開始語法
patch.unknown.before.hunk.start.syntax=未知的 before 區塊開始語法
patch.unknown.hunk.start.syntax=未知的區塊開始語法
patch.unknown.line.prefix=未知行前綴
patched.version.name=更新檔版本
path.apply.select.base.directory.for.a.path.popup=為路徑選擇基目錄
paths.affected.in.revision={0} 中的更改
post.commit.checks.failed.notification.ignore.action=忽略
post.commit.checks.failed.notification.title=提交包含問題
post.commit.checks.failed.push.dialog.notification.text=提交包含問題: {0}
post.commit.checks.not.finished.push.dialog.notification.text=提交檢查仍在進行中
post.commit.checks.progress.text=正在檢查提交中的檔案
prefer.commit.timestamp.action.description=顯示提交更改的時間，而不是建立時間。
prefer.commit.timestamp.action.text=提交時間戳
prefer.commit.timestamp.action.text.show=顯示提交時間戳
progress.text.analyzing.code=正在分析程式碼…
progress.text.applying.fixes=正在套用修正…
progress.text.checking.for.todo=正在檢查 TODO…
progress.text.inspecting.code=正在檢查程式碼…
progress.text.loading.patch.base.revision=正在載入更新檔基礎修訂
progress.text.optimizing.imports=正在最佳化 import…
progress.text.performing={0}: 正在執行 {1}…
progress.text.performing.rollback={0}: 正在執行復原…
progress.text.rearranging.code=正在重新排列程式碼…
progress.text.reformatting.code=正在重新格式化程式碼…
progress.text.searching.for.modified.files=正在搜尋修改的檔案
progress.text.synchronizing.files=正在同步檔案…
progress.text.updating.canceled=更新已取消
progress.text.updating.done=更新完成
progress.title.adding.files.to.vcs=正在將檔案新增到 VCS…
progress.title.commit.checks=提交檢查
progress.title.discovering.location=正在發現 {0} 的位置
progress.title.hey=嗨
progress.title.loading.current.revision=正在載入當前修訂…
progress.title.version.control.processing.changed.files=版本控制: 正在處理更改的檔案
project.configuration.files.add.notification.action.add=始終新增
project.configuration.files.add.notification.action.mute=不再詢問
project.configuration.files.add.notification.action.view=檢視檔案
project.configuration.files.add.notification.message=可以將 IDE 專案設定新增到 {0}
project.configuration.files.view.dialog.title=將檔案新增到 {0}
radio.after.creation.add.silently=無提示新增
radio.after.creation.do.not.add=不新增
radio.after.creation.show.options=詢問
radio.after.deletion.do.not.remove=不移除
radio.after.deletion.remove.silently=無提示移除
radio.after.deletion.show.options=詢問
radio.restore.workspace.on.branch.switching=切換分支時還原工作區(&B)
radio.restore.workspace.on.branch.switching.comment=工作區是一組開啟的檔案、當前執行組態以及與分支關聯的中斷點。
ranges.to.commit.of.ranges.size.changes={1} 個中的 {0} 個發生更改
remove.changelist.combobox.do.not.remove=不執行任何動作
remove.changelist.combobox.remove.silently=無提示移除
remove.changelist.combobox.show.options=顯示選項
retrieving.annotations=正在載入註解
revert.changes.changelist.chooser.title=選擇目標更改列表
rollback.modified.without.checkout.error.tab={0}未簽出時進行了修改
rollback.modified.without.editing.confirm.multiple=要將更改{0}到 {1} 個所選檔案嗎?
rollback.modified.without.editing.confirm.single=要將更改{0}到{1}嗎?
rolling.back.file=正在復原{0}
roots.notification.content.added.vcs.name.roots=已新增 {0} 個{1,choice,1#根|2#根}: {2}
roots.notification.content.directory.registered.as.root.but.no.repositories.were.found.there=目錄 {0} 被註冊為 {1} 根，但在那裡沒有發現 {1} 版本庫。
roots.notification.title.invalid.vcs.root.choice.mapping.mappings=無效 VCS 根{0, choice, 1#映射|2#映射}
roots.notification.title.vcs.name.integration.enabled={0} 整合已啟用
roots.notification.title.vcs.root.configuration.problems=VCS 根組態問題
roots.the.following.directories.are.registered.as.vcs.roots.but.they.are.not=以下目錄被錯誤註冊為 VCS 根:
save.committing.files.confirmation.cancel=延遲儲存
save.committing.files.confirmation.ok=立即儲存
save.committing.files.confirmation.text=當前正在將以下{0,choice,1#檔案|2#檔案}提交到 VCS。立即儲存可能會導致提交的資料不一致。\\n\\
{1}\\n\\
立即儲存{0,choice,1#檔案|2#檔案}?
save.committing.files.confirmation.title=在提交期間儲存檔案
saved.patch.apply.action=套用
saved.patch.apply.pop.help.tooltip=<html>套用\\\\&mdash;套用並將隱藏保留在<br/>列表中。<br/>彈出\\\\&mdash;套用並從列表中<br/>移除隱藏。</html>
saved.patch.changes.empty=選擇隱藏或擱置以檢視檔案
saved.patch.changes.loading=正在載入…
saved.patch.created.on.date.at.time.tooltip={0} 在 {2} 建立於 {1}
saved.patch.editor.diff.preview.empty.title=隱藏和擱置
saved.patch.empty.text=未新增任何隱藏或擱置。
saved.patch.pop.action=彈出
scope.name.changelist.all.changed.files=所有更改的檔案
searching.for.code.smells.freezing.process=簽入前代碼分析
searching.for.code.smells.processing.file.progress.text=正在處理 {0}
selection.history.can.not.load.message=無法載入修訂內容
selection.history.commit.message.label=提交訊息:
selection.history.loading.revision.status=正在載入修訂 {0}…
selection.history.local.revision.text=本地更改
sequence.concatenation.a.and.b={0} 和 {1}
sequence.concatenation.separator=, 
sequence.concatenation.tail=和 {0}
sequence.concatenation.tail.n.others=和其他 {0} 個
settings.auto.detected=自動檢測:
settings.auto.detected.progress=正在檢測…
settings.border.when.files.are.created=當檔案被建立時:
settings.change.shelves.location=更改擱置位置…
settings.changelist.conflicts.group.title=衝突
settings.changelists.create.automatically.checkbox=自動建立更改列表(&A)
settings.changelists.option.group=更改列表
settings.check.every.minutes=分鐘
settings.checkbox.limit.history.to=將歷史記錄限制為
settings.checkbox.measure.days=天
settings.checkbox.rows=行
settings.checkbox.show.changed.in.last=醒目提示以下時間內更改的檔案:
settings.checkbox.show.changed.in.last.comment=修改的檔案將在外部堆疊追蹤和偵錯時醒目提示。
settings.commit.message.body.add.blank.line.fix=新增空白行
settings.commit.message.inspections=提交訊息檢查
settings.commit.message.option.group=提交訊息
settings.commit.message.right.margin.label=右邊距:
settings.commit.message.show.right.margin.label=顯示右邊距
settings.commit.message.show.right.margin.n.columns.label=顯示 {0} 列中的右邊距
settings.commit.option.group=提交
settings.commit.without.dialog=使用非強制回應提交介面
settings.commit.without.dialog.applies.to.git.mercurial=套用到 Git 和 Mercurial 下的專案
settings.confirmation.option.group=確認
settings.confirmation.option.text.ask=詢問
settings.confirmation.option.text.no=否
settings.confirmation.option.text.yes=是
settings.current.location=當前位置為
settings.default.location=預設位置為 
settings.file.status.color.added.in.not.active.changelist=已在停用更改列表中新增
settings.file.status.color.changelist.conflict=更改列表衝突
settings.file.status.color.modified.in.not.active.changelist=已在停用更改列表中修改
settings.files.with.ignored.conflicts.list.title=包含忽略衝突的檔案:
settings.filter.configure.link=組態
settings.filter.update.project.info.by.scope=按作用域篩選更新專案資訊
settings.general.changes.group.title=更改
settings.general.confirmation.group.title=確認
settings.general.show.options.before.command.label=進行以下動作之前顯示選項:
settings.highlight.files.from.non.active.changelist.checkbox=醒目提示停用更改列表中的檔案(&I)
settings.highlight.files.with.conflicts.checkbox=醒目提示存在更改列表衝突的檔案(&H)
settings.inactive.changelist.group.title=停用更改列表
settings.issue.navigation.patterns={0} 將在簽入註釋中搜尋指定的模式，並將它們連結到問題追蹤器中的問題:
settings.label.when.empty.changelist.becomes.inactive=當空更改列表變為停用狀態時:
settings.limit.history.to.n.rows.label=將歷史記錄限制為 {0} 行
settings.partial.changelists.enable.checkbox=允許將一個檔案中的更改放入不同的更改列表(&P)
settings.shelf.content.larger=大於 {0}K 的檔案的基內容不會被存儲
settings.show.changed.in.last.n.days.label=顯示過去 {0} 天的更改
settings.show.conflict.resolve.dialog.checkbox=試圖編輯停用更改列表中的檔案時顯示對話框(&D)
settings.vcs.mapping.browser.select.directory.description=選擇要映射到 VCS 的目錄
settings.vcs.mapping.browser.select.directory.title=選擇目錄
settings.vcs.mapping.invalid.vcs.options.error=無效的 VCS 選項: {0}
settings.vcs.mapping.project.description=所有模組的內容根，以及專案基目錄的所有直接後代
settings.vcs.mapping.project.description.with.idea.directory=所有模組的內容根、專案基目錄的所有直接後代以及 {0} 目錄內容
settings.vcs.mapping.status.looking.for.vcs.administrative.area=正在尋找 VCS 管理區域
settings.version.control.option.group=版本控制
settings.when.files.are.deleted=當檔案被刪除時:
shelf.apply.action.description=套用所選擱置
shelf.drop.action=刪除
shelf.drop.action.description=刪除所選擱置
shelf.pop.action.description=彈出所選擱置
shelf.root.node.title=擱置
shelf.tab=擱置
shelf.tooltip.title=擱置
shelf.unshelve.changes.action.description=取消擱置所選更改
shelf.unshelve.changes.action.text=取消擱置
shelf.unshelve.changes.remove.action.description=取消擱置所選更改並將其從擱置中移除
shelf.unshelve.changes.remove.action.text=取消擱置並移除
shelve.base.content.not.found.or.not.applicable.error=基內容未找到或不適用。顯示與本地版本的差異
shelve.changelist.not.found=未找到擱置的更改列表 {0}
shelve.changes.action=托管更改(_S)
shelve.changes.only.directories=所選更改僅影響目錄，不影響檔案，因此無法擱置它們
shelve.changes.progress.text=正在擱置更改…
shelve.changes.progress.title=正在擱置更改
shelve.changes.restore.error=無法完全還原{0, choice, 1#擱置的更改列表|2#{0}擱置的更改列表}，因為某些檔案已被永久刪除
shelve.copying.shelves.to.progress=正在將擱置複製到新目錄…
shelve.default.path.rendering=<專案根目錄>
shelve.delete.already.unshelved.label=刪除已擱置的更改列表:
shelve.delete.changelists.message={0,choice, 1#1 個更改列表|2#{0} 個更改列表} {1}
shelve.delete.files.from.changelist.error=無法從 {0} 刪除檔案
shelve.delete.files.successful.message={0,choice, 1#1 個檔案|2#{0} 個檔案}
shelve.delete.successful.message=已成功刪除 {0}{1,choice, 0#|1# 和 }{2}
shelve.deletion.title=Shelf 刪除
shelve.editor.diff.preview.title=擱置: {0}
shelve.error.title=Shelf 錯誤
shelve.failed.message={0,choice,1#更改列表|2#更改列表} [{1}] 的更改擱置失敗
shelve.failed.title=擱置失敗
shelve.file.is.locked.for.editing.message=在擱置期間檔案已鎖定，無法編輯
shelve.import.one.patch.file.prompt=找到一個更新檔檔案({0})。\\n\\
繼續匯入?
shelve.import.patches.prompt=找到 {0} 個補丁檔案。\\n\\
繼續匯入?
shelve.import.to.progress=正在處理 
shelve.moving.failed.prompt=Shelf 移動失敗。<br/>要使用新的 Shelf 目錄路徑還是將其還原為上一個路徑?
shelve.recently.deleted.node=最近刪除項
shelve.remove.successfully.applied.files.checkbox=從 Shelf 移除成功套用的檔案
shelve.revert.moving.button=還原(&R)
shelve.shelved.version=擱置的版本
shelve.show.already.unshelved.action=已取消擱置
shelve.successful.message=已成功擱置更改
shelve.undo.deletion=撤消 Shelf 刪除
shelve.use.new.directory.button=使用新路徑(&U)
shelved.version.name=擱置的版本
show.diff.from.annotation.action.error.can.not.load.data.to.show.diff=無法載入資料以顯示差異
show.diff.in.editor.tab.got.it.tooltip=要在編輯器頁籤中再次顯示差異，請使用此選單。
show.diff.progress.title=正在載入內容
show.diff.progress.title.detailed=正在載入 {0} 的內容
show.history.action.name.template=顯示 {0} 的歷史記錄(_F)…
show.history.dialog.title.template={0} 的歷史記錄
show.patch.in.explorer.after.creation.combobox.text.ask=詢問
show.patch.in.explorer.after.creation.combobox.text.no=不執行任何動作
show.patch.in.explorer.after.creation.combobox.text.show.in.file.manager=在 {0} 中顯示
show.patch.in.explorer.after.creation.label=建立補丁時:
stash.changes.message=在{0}之前未提交的更改
stash.changes.message.with.date=在進行{0}之前於 {1} 取消提交了更改
status.group.name.changed=已更改
status.group.name.changed.on.server=在伺服器上已更改
status.group.name.created=已建立
status.group.name.deleted=已刪除
status.group.name.locally.added=本地已新增
status.group.name.locally.removed=本地已移除
status.group.name.modified=已修改
status.group.name.not.in.repository=不在版本庫中
status.group.name.skipped=已跳過
status.group.name.switched=已切換
status.group.name.will.be.merged=將被合併
status.group.name.will.be.merged.with.conflicts=將在存在衝突的情況下被合併
status.group.name.will.be.merged.with.property.conflicts=將在存在屬性衝突的情況下合併
status.group.name.will.be.merged.with.tree.conflicts=將在存在樹衝突的情況下合併
status.group.name.will.be.restored=將被還原
status.text.commit.toolwindow.create.repository=建立 Git 版本庫…
status.text.commit.toolwindow.create.repository.prefix=要提交更改，
status.text.commit.toolwindow.local.history=本地歷史記錄…
status.text.commit.toolwindow.local.history.prefix=有關最近的更改，請參閱
status.text.vcs.toolwindow=要追蹤程式碼更改:
status.text.vcs.toolwindow.create.repository=建立 Git 版本庫…
status.text.vcs.toolwindow.help=版本控制整合
status.text.vcs.toolwindow.local.history=使用本地歷史記錄…
switch.to.changelist=切換到更改列表(''{0}'')(&T)
switch.to.commit.dialog.hint.text=要切換回“提交”對話框，請使用齒輪圖示下的選單
switch.to.commit.dialog.hint.text.new.ui=要切換回“提交”對話框，請使用“選項”圖示下的選單
tab.title.commit=提交
tab.title.commit.to.branch=提交至 {0}
text.commit.message.truncated.by.ide.name={0}\\n\\
\\n\\
…提交訊息過長，被 {1} 截斷…
title.code.author.inlay.hints=程式碼作者
title.load.revision.contents=載入修訂內容
todo.handler.only.added=<html><body>發現{0,choice, 0#|1#一|2#{0}}個已被新增或編輯的 TODO {0,choice, 0#|1#專案|2#專案}。<br/>您是否想檢視{0,choice,1#它|2#它們}?<br/>{1,choice, 0#|1#1個檔案被跳過。|2#{1} 個檔案被跳過。}</body></html>
todo.handler.only.both=<html><body>{0, choice, 1#1|2#{0}} 個新增/編輯的 TODO {0,choice, 1#條目|2#條目}，<br/>並在更改的片段中找到 {1, choice, 1#1個條目|2#{1} 個條目}。<br/>要檢查它們嗎?<br/>{2,choice, 0#|1#1 個檔案被跳過。|2#{2} 個檔案被跳過。}</body></html>
todo.handler.only.in.changed=<html><body>{0,choice, 1#一|2#{0}}個 TODO {0,choice, 1#項|2#項} 在已改變的片段中找到。<br/>您是否需要查閱{0,choice,1#它|2#它們}?<br/>{1,choice, 0#|1#一個檔案被跳過|2#{1} 個檔案被跳過。}</body></html>
todo.handler.only.skipped=<html><body>TODO 檢查已經跳過 {0,choice, 0#|1#1 個檔案|2#{0}多個檔案}。<br/>沒有發現新的或已編輯的 TODO 條目，也沒有位於更改的文本片段中的條目。</body></html>
todo.in.new.review.button=審查 TODO(&R)
todo.tab.title.all.changes=本地更改
todo.tab.title.changelist.suffix=更改列表
tooltip.rerun.commit.checks=重新執行提交檢查
tooltip.show.options.dialog=顯示選項對話框
toolwindow.title.update.project=更新專案({0})
unknown.vcs.presentation=<未知 VCS> ({0})
unregistered.roots.label=未註冊的根:
unshelve.changelist.chooser.title=取消擱置更改列表的更改
unshelve.changes.action=取消托管更改
unshelve.changes.dialog.title=取消擱置更改
unshelve.changes.progress.title=正在取消擱置更改…
unshelve.loading.patch.error=無法載入更新檔: {0}
update.can.t.load.content=無法載入內容
update.checkbox.don.t.show.again=不再顯示
update.directories.scope.name=目錄
update.directory.scope.name=目錄
update.error.label=錯誤: 
update.file.name.wasn.t.modified={0} 未修改
update.file.scope.name=檔案
update.files.scope.name=檔案
update.filtered.files.count.in.filter.name={0} ({1} 內)
update.group.name.created=已建立
update.group.name.deleted=已刪除
update.group.name.locally.added=本地已新增
update.group.name.locally.removed=本地已移除
update.group.name.merged=已合併
update.group.name.merged.with.conflicts=已合併，但存在衝突
update.group.name.merged.with.property.conflicts=已合併，但存在屬性衝突
update.group.name.merged.with.tree.conflicts=已合併，但存在樹衝突
update.group.name.modified=已修改
update.group.name.not.in.repository=不在版本庫中
update.group.name.restored=已還原
update.group.name.skipped=已跳過
update.group.name.switched=已切換
update.group.name.updated=已更新
update.group.name.updated.from.server=從伺服器更新
update.info.click.status.text.prefix=點擊
update.info.group.by.changelist=按更改列表分組
update.info.loading.changelists=正在載入更改列表…
update.info.refresh.link.status.text=重新整理
update.info.to.initialize.status.text.suffix=以初始化版本庫更改快取
update.label.after.update=更新後
update.label.before.update=更新前
update.notification.content.files.updated={0,choice,1#1 個檔案|2#{0} 個檔案}已更新
update.notification.content.view=檢視
update.notification.title.count.files.updated={0,choice,1#1 個檔案|2#{0} 個檔案}已更新
update.notification.title.project.partially.updated=專案已部分更新
update.project.scope.name=專案
update.tree.node.size.statistics={0,choice, 0#無條目|1#1 個條目|2#{0, number} 個條目}
user.group.title=使用者
vcs.add.to.ignore.file.action.group.description=將所選檔案新增到 {0}
vcs.add.to.ignore.file.action.group.text=新增到 {0}
vcs.add.to.ignore.file.create.ignore.file.confirmation.message=在 {1} 中建立 {0} 檔案?
vcs.add.to.ignore.file.create.ignore.file.confirmation.title=建立 {0}
vcs.command.name.add=新增
vcs.command.name.checkin=提交(_I)
vcs.command.name.checkout=簽出
vcs.command.name.edit=編輯
vcs.command.name.remove=移除
vcs.command.name.status=狀態
vcs.command.name.update=更新
vcs.commit.canceled=提交已取消
vcs.commit.files.committed={0,choice,1#{0} 個檔案|2#{0} 個檔案}已提交
vcs.commit.files.committed.and.files.failed.to.commit={0,choice,1#{0} 個檔案|2#{0} 個檔案}已提交，{1,choice,1#{1} 個檔案|2#{1} 個檔案}提交失敗
vcs.common.labels.directory=目錄:
vcs.common.labels.url=URL:
vcs.common.labels.vcs=VCS:
vcs.common.labels.version.control=版本控制:
vcs.config.track.changed.on.server=檢查與伺服器衝突的時間間隔
vcs.console.toolwindow.display.name=主控台
vcs.dnd.image.text.n.files={0} 個{0, choice, 1#檔案|2#檔案}
vcs.error.failed.to.load.file.content.from.vcs=無法載入內容
vcs.generic.name=VCS
vcs.generic.name.with.mnemonic=VCS(_S)
vcs.local.changes.toolbar=VCS 本地更改工具列
vcs.operations.popup=VCS 動作彈出視窗
vcs.preview.panel.added.ignored.line=已新增忽略的行
vcs.preview.panel.added.line=已新增行
vcs.preview.panel.deleted.ignored.line.below=已刪除以下忽略的行
vcs.preview.panel.deleted.line.below=以下已刪除的行
vcs.preview.panel.last.commit.modified.line=上次提交中修改的行
vcs.preview.panel.line.with.modified.whitespaces=帶有修改的空格的行
vcs.preview.panel.line.with.modified.whitespaces.and.deletion.after=帶有修改的空格和後續刪除的行
vcs.preview.panel.modified.ignored.line=已修改忽略的行
vcs.preview.panel.modified.line=已修改的行
vcs.quicklist.popup.title=VCS 動作
vcs.revision.name.current=當前
vcs.settings.path=設定 | 版本控制
vcs.settings.path.mac=偏好設定 | 版本控制
vcs.shelf.action.restore.description=還原最近刪除的{0, choice, 1#更改列表|2#更改列表}
vcs.shelf.action.restore.text=還原
vcs.shelf.move.text=將擱置移至新位置(&M)
vcs.shelf.store.base.content=擱置分布式版本控制系統下檔案的基本修訂版本
vcs.shelving.changes=正在擱置更改…
vcs.tab.title.vcs.name.operations.errors={0} 個動作錯誤
vcs.unshelving.changes=正在取消擱置更改…
vcs.unshelving.conflict.left=您未提交的更改
vcs.unshelving.conflict.right=遠端更改
vcs.update.tab.name=更新資訊
version.control.main.configurable.description=<html><body>組態與專案中使用的版本控制相關的設定
version.control.main.configurable.name=版本控制
vfs.revision.author.unknown=未知
waiting.changelists.update.for.show.commit.dialog.message=提交"
`;

exports[`dev messages/VcsLogBundle.properties 1`] = `
"action.FocusTextFilterAction.description=聚焦文本篩選器或將焦點移回提交列表
action.FocusTextFilterAction.text=聚焦文本篩選器
action.IntelliSortChooserPopupAction.description=更改 IntelliSort 類型
action.IntelliSortChooserPopupAction.text=IntelliSort
action.ShowCommitTooltipAction.description=在日誌中為當前所選提交顯示工具提示
action.ShowCommitTooltipAction.text=顯示提交工具提示
action.Vcs.Log.AnnotateRevisionAction.description=註解所選修訂
action.Vcs.Log.AnnotateRevisionAction.text=註解
action.Vcs.Log.CompareRevisions.description=比較選定版本
action.Vcs.Log.CompareRevisions.text=比較版本
action.Vcs.Log.EnableFilterByRegexAction.text=正則表達式
action.Vcs.Log.GoToChild.description=導覽到提交圖中的子行
action.Vcs.Log.GoToChild.text=轉到子提交
action.Vcs.Log.GoToParent.description=導覽到提交圖中的父行
action.Vcs.Log.GoToParent.text=轉到父提交
action.Vcs.Log.GoToRef.description=指定分支或標記的雜湊或名稱，以導覽到其指向的提交
action.Vcs.Log.GoToRef.text=轉到雜湊/分支/標記
action.Vcs.Log.MatchCaseAction.text=區分大小寫
action.Vcs.Log.MoveDiffPreviewToBottom.description=在底部找到差異預覽
action.Vcs.Log.MoveDiffPreviewToBottom.text=底部
action.Vcs.Log.MoveDiffPreviewToRight.description=在右側找到差異預覽
action.Vcs.Log.MoveDiffPreviewToRight.text=右側
action.Vcs.Log.OpenRepositoryVersion.description=在編輯器中開啟檔案的所選修訂
action.Vcs.Log.OpenRepositoryVersion.text=按修訂顯示檔案
action.Vcs.Log.ResumeIndexing.description=索引編制已暫停，因為它花費的時間比預期長。恢復。
action.Vcs.Log.ResumeIndexing.text=恢復索引編制
action.Vcs.Log.ShowAllAffected.description=顯示選中修訂中所做的所有更改
action.Vcs.Log.ShowAllAffected.text=顯示所有受影響的檔案
action.Vcs.Log.ShowTooltip.description=在日誌中為當前選定提交顯示工具提示
action.Vcs.Log.ShowTooltip.text=顯示提交工具提示
action.Vcs.Show.Log.text=顯示 VCS 日誌
action.Vcs.Show.Log.text.template=顯示 {0} 日誌
action.description.collapse.linear.branches=摺疊線性分支
action.description.collapse.merges=摺疊合併
action.description.expand.linear.branches=展開線性分支
action.description.expand.merges=展開合併
action.description.is.scheduled=為 {0} 編制索引已計劃。暫停。
action.description.refresh.log=檢查新提交，必要時重新整理日誌
action.description.select.columns.to.see=選擇要在表中檢視的列
action.description.was.paused=為 {0} 編制索引已暫停。恢復。
action.go.to.navigate.to=導覽到 {0}
action.go.to.select.child.to.navigate=選擇要導覽的子項
action.go.to.select.hash.subject.author.date.time={0} {1}，作者 {2}，{3} {4}
action.go.to.select.parent.to.navigate=選擇要導覽的父項
action.name.refresh.log=重新整理
action.presentation.CompareRevisionsFromFileHistoryActionProvider.description.compare=比較所選版本
action.presentation.CompareRevisionsFromFileHistoryActionProvider.description.show.diff=顯示與之前版本的差異
action.presentation.CompareRevisionsFromFileHistoryActionProvider.text.compare=比較
action.presentation.CompareRevisionsFromFileHistoryActionProvider.text.show.diff=顯示差異
action.process.collapsing.linear.branches=正在摺疊線性分支…
action.process.collapsing.merges=正在摺疊合併…
action.process.expanding.linear.branches=正在展開線性分支…
action.process.expanding.merges=正在展開合併…
action.title.collapse.linear.branches=摺疊線性分支
action.title.collapse.merges=摺疊合併
action.title.expand.linear.branches=展開線性分支
action.title.expand.merges=展開合併
action.title.match.case=區分大小寫
action.title.match.case.only.supported=區分大小寫(僅限 {0})
action.title.pause.indexing=暫停 {0} 日誌索引編制
action.title.resume.indexing=恢復 {0} 日誌索引編制
action.title.select.columns.to.see=列
action.vcs.log.branches.separator=分支
action.vcs.log.show.separator=顯示
dialog.title.paths.affected.by.commit=受提交 {0} 影響的路徑
file.history.action.could.not.load.selected.commits.message=無法載入所選提交: {0}
file.history.commit.not.found={1} 的歷史記錄中不存在 {0}
file.history.commit.not.found.in.branch=當前分支中 {1} 的歷史記錄中不存在 {0}
file.history.commit.not.found.view.and.show.all.branches.link=檢視並顯示所有分支
file.history.commit.not.found.view.in.log.link=在日誌中檢視
file.history.diff.preview.editor.tab.name=歷史記錄: {0}
file.history.empty.status=檔案歷史記錄
file.history.error.status=計算檔案歷史記錄時出錯
file.history.toolbar=檔案歷史工具列
filetype.vcs.log.description=Vcs 日誌
graph.sort.linear=線性
graph.sort.linear.description=合併時，在主分支提交的頂部顯示傳入提交，就好像對它們進行重定基底
graph.sort.off=關閉
graph.sort.off.description=按日期以拓撲方式對提交進行排序
graph.sort.standard=標準
graph.sort.standard.description=合併時，首先顯示傳入提交(合併提交正下方)
group.Log.KeymapGroup.text=日誌
group.Vcs.FileHistory.PresentationSettings.description=組態檔案歷史記錄的表示
group.Vcs.FileHistory.PresentationSettings.text=檢視選項
group.Vcs.Log.ChangesBrowser.PresentationSettings.text=檢視選項
group.Vcs.Log.Diff.Preview.Location.text=差異預覽位置
group.Vcs.Log.Internal.text=Vcs 日誌
group.Vcs.Log.LayoutConfiguration.description=組態視窗布局
group.Vcs.Log.LayoutConfiguration.separator.text=布局
group.Vcs.Log.LayoutConfiguration.text=組態布局
group.Vcs.Log.PresentationSettings.description=組態日誌的表示
group.Vcs.Log.PresentationSettings.text=檢視選項
group.Vcs.Log.TextFilterSettings.description=選擇文本篩選器選項
group.Vcs.Log.TextFilterSettings.text=文本篩選器設定
loading.commit.changes=正在載入提交更改
vcs=Vcs
vcs.log.action.align.labels=左側的參照
vcs.log.action.description.align.labels=在提交訊息左側顯示參照
vcs.log.action.description.open.new.tab.with.log=開啟包含 {0} 日誌的新頁籤
vcs.log.action.description.show.all.branches=在僅顯示當前分支和顯示所有分支之間切換
vcs.log.action.description.show.all.changes.from.parent=分別顯示對每個合併提交所做的更改
vcs.log.action.description.show.compact.references.view=僅在表中顯示提交的第一個參照
vcs.log.action.description.show.details=顯示詳細資訊面板
vcs.log.action.description.show.diff.preview=顯示差異預覽面板
vcs.log.action.description.show.long.edges=即使提交在當前檢視中不可見，也顯示長分支邊緣。
vcs.log.action.description.show.only.affected.changes=僅顯示影響“路徑”選單中所選檔案的更改
vcs.log.action.description.show.tag.names=在表中顯示標籤名稱
vcs.log.action.highlight.current.branch=當前分支
vcs.log.action.highlight.indexed.commits=已編制索引的提交
vcs.log.action.highlight.merge.commits=合併提交
vcs.log.action.highlight.my.commits=我的提交
vcs.log.action.intellisort.description=開啟/關閉 IntelliSort
vcs.log.action.intellisort.text=IntelliSort
vcs.log.action.intellisort.title=IntelliSort: {0}
vcs.log.action.open.new.tab.with.log=開啟新的 {0} 日誌頁籤
vcs.log.action.show.all.branches=顯示所有分支
vcs.log.action.show.all.changes.from.parent=顯示對父項的更改
vcs.log.action.show.compact.references.view=緊湊型參照檢視
vcs.log.action.show.details=顯示詳細資訊
vcs.log.action.show.diff.preview=顯示差異預覽
vcs.log.action.show.long.edges=長邊
vcs.log.action.show.only.affected.changes=僅顯示受影響的更改
vcs.log.action.show.root.names=根名稱
vcs.log.action.show.tag.names=標籤名稱
vcs.log.action.turn.intellisort.off=關閉 IntelliSort: {0}。
vcs.log.action.turn.intellisort.on=開啟 IntelliSort: {0}。
vcs.log.applying.filters.process=正在套用篩選器…
vcs.log.branch.filter.action.text=按分支篩選
vcs.log.branch.filter.favorites=收藏夾
vcs.log.branch.filter.label=分支
vcs.log.changes.accessible.name=提交更改瀏覽器
vcs.log.changes.browser.toolbar=VCS 日誌更改瀏覽器工具列
vcs.log.changes.changes.to.parent.node=對 {0} 的更改
vcs.log.changes.details.no.commits.selected.status=未選擇提交
vcs.log.changes.no.changes.that.affect.selected.paths.status=沒有影響所選路徑的更改。
vcs.log.changes.no.merge.conflicts.node=沒有合併的衝突
vcs.log.changes.no.merge.conflicts.status=沒有合併的衝突。
vcs.log.changes.select.commits.to.view.changes.status=選擇要檢視更改的提交
vcs.log.changes.show.all.paths.status.action=顯示所有路徑的更改
vcs.log.changes.show.changes.to.parents.status.action=顯示對父項的更改
vcs.log.changes.too.many.show.anyway.status.action=仍然顯示
vcs.log.changes.too.many.status={0,choice,1#此提交|2#所選提交之一}具有 {1} 個更改
vcs.log.clear.caches.checkbox.description=清除 VCS 日誌快取和索引
vcs.log.click.to.collapse.paths.column.tooltip=點擊以摺疊
vcs.log.click.to.expand.paths.column.tooltip=點擊以展開
vcs.log.column.author=作者
vcs.log.column.date=日期
vcs.log.column.hash=雜湊
vcs.log.column.subject=主題
vcs.log.commit.details.status=提交詳細資訊
vcs.log.commit.does.not.match={0} 與篩選器不符合
vcs.log.commit.does.not.match.view.and.reset.link=檢視並重設篩選器
vcs.log.commit.does.not.match.view.in.tab.link=在新頁籤中檢視
vcs.log.commit.not.found=找不到 {0}
vcs.log.commit.or.reference.prefix=提交或參照 ''{0}''
vcs.log.commit.prefix=提交 ''{0}''
vcs.log.commit.status.action=提交本地更改
vcs.log.creating.process=正在載入提交…
vcs.log.date.filter.action.last.day=過去 24 小時
vcs.log.date.filter.action.last.week=過去 7 天
vcs.log.date.filter.action.text=按日期篩選
vcs.log.date.filter.label=日期
vcs.log.date.filter.select.period.dialog.title=選擇期間
vcs.log.date.filter.since=自 {0}
vcs.log.date.filter.until=到 {0}
vcs.log.default.status=更改日誌
vcs.log.details.author.on.date.at.time=作者 {0}，{1} {2}
vcs.log.details.committer.info.date.time=在 {0} {1} 提交
vcs.log.details.committer.info.user=由 {0} 提交
vcs.log.details.committer.info.user.date.time=由 {0} 於 {1} {2} 提交
vcs.log.details.in.branches=在 {0,choice,1#{0} 個分支|2#{0} 個分支}中:
vcs.log.details.in.branches.empty=不在任何分支中
vcs.log.details.in.branches.hide=隱藏
vcs.log.details.in.branches.loading=在分支中: 正在載入…
vcs.log.details.in.branches.show.all=全部顯示
vcs.log.details.references.more.label=…其他 {0} 個
vcs.log.details.showing.selected.commits=(正在顯示 {0}/{1} 個所選提交)
vcs.log.diff.preview.editor.empty.tab.name=版本庫差異
vcs.log.diff.preview.editor.tab.name=版本庫差異: {0}
vcs.log.duplicated.tab.id.error=“VCS 日誌”頁籤不能開啟兩次
vcs.log.editor.name=Vcs 日誌編輯器
vcs.log.error.filtering.status=篩選提交時出錯
vcs.log.error.loading.changes.status=載入更改時出錯
vcs.log.error.loading.commits.status=載入提交時出錯
vcs.log.error.loading.details.status=載入提交詳細資訊時出錯
vcs.log.failed.loading.details=無法在 {1} 中載入提交 {0} 的詳細資訊
vcs.log.fatal.error.message=無法清除 {0} 下的快取。\\n請手動刪除快取目錄，然後重啟 {1}。
vcs.log.filter.accessible.name={0}: {1}
vcs.log.filter.action.select=選擇…
vcs.log.filter.all=所有
vcs.log.filter.branch.presentation.with.prefix=在 {0} 上
vcs.log.filter.date.display.name.after=自 {0}
vcs.log.filter.date.display.name.before=到 {0}
vcs.log.filter.date.display.name.between={0} 和 {1} 之間
vcs.log.filter.date.presentation.with.prefix.made.after=生成自 {0}
vcs.log.filter.date.presentation.with.prefix.made.before=生成到 {0}
vcs.log.filter.date.presentation.with.prefix.made.between=在 {0} 與 {1} 之間進行
vcs.log.filter.edit.folders=選擇…
vcs.log.filter.popup.advertisement.text=選擇一個或多個用 {0} 分隔的值
vcs.log.filter.popup.advertisement.text.new.lines=新行
vcs.log.filter.popup.advertisement.text.or.suffix=或{0}
vcs.log.filter.popup.advertisement.with.key.text=選擇一個或多個用 {0} 分隔的值，並使用 {1} 完成
vcs.log.filter.popup.no.folders=無路徑
vcs.log.filter.popup.no.items=沒有項
vcs.log.filter.popup.no.roots=沒有根
vcs.log.filter.popup.paths=路徑
vcs.log.filter.recent=最近
vcs.log.filter.root.presentation.with.prefix=在 {0} 中
vcs.log.filter.roots=根
vcs.log.filter.select.folders=在樹中選擇…
vcs.log.filter.structure.presentation.with.prefix=用於 {0}
vcs.log.filter.text.hash.tooltip=文本或雜湊篩選器
vcs.log.filter.text.presentation.with.prefix=包含 {0}
vcs.log.filter.tooltip.click.to.see.only={0}+點擊以僅檢視“{1}”
vcs.log.filter.tooltip.folders=路徑:
vcs.log.filter.tooltip.no.roots.selected=未選擇根
vcs.log.filter.tooltip.roots=根:
vcs.log.filter.user.presentation.with.prefix=被 {0} 使用
vcs.log.filters.structure.label=已選擇: {0}
vcs.log.filters.structure.max.selected.error.message=您已新增 {0} 個元素。不允許更多元素。
vcs.log.go.to.hash.popup.label=輸入雜湊或分支/標記名稱:
vcs.log.graph.arrow.tooltip.jump.to.hash=跳轉到提交 {0}
vcs.log.graph.arrow.tooltip.jump.to.hash.in.root=跳轉到 {1} 中的提交 {0}
vcs.log.graph.arrow.tooltip.jump.to.subject.author.date.time=跳轉到 {0} (作者 {1}，{2} {3})
vcs.log.index.diagnostic.action.title=檢查舊提交的 VCS 日誌索引資料
vcs.log.index.diagnostic.error.attribute.name.author=作者
vcs.log.index.diagnostic.error.attribute.name.author.time=作者日期
vcs.log.index.diagnostic.error.attribute.name.committer=提交者
vcs.log.index.diagnostic.error.attribute.name.committer.time=提交日期
vcs.log.index.diagnostic.error.attribute.name.message=訊息
vcs.log.index.diagnostic.error.attribute.name.parents=父項
vcs.log.index.diagnostic.error.filter=按 {0} 篩選不會返回 {1}
vcs.log.index.diagnostic.error.for.commit=提交 {0} 的差異\\n{1}
vcs.log.index.diagnostic.error.message=應為 {0}: {1}，實際為 {0}: {2}
vcs.log.index.diagnostic.progress.title=正在執行 VCS 日誌索引診斷
vcs.log.index.diagnostic.report.title=VCS 日誌索引診斷報告 {0}
vcs.log.index.diagnostic.selected.action.title=檢查所選提交的 VCS 日誌索引資料
vcs.log.index.diagnostic.selected.non.indexed.warning.message=所選提交未編制索引
vcs.log.index.diagnostic.success.message={0} 個已檢查{0,choice,1#提交|2#提交}的 VCS 日誌索引資料正確
vcs.log.initial.loading.process=正在載入歷史記錄…
vcs.log.invalidate.caches.progress=正在使 {0} 日誌快取和索引無效
vcs.log.invalidate.caches.text=使 {0} 日誌快取和索引無效
vcs.log.is.loading=正在載入 VCS 日誌…
vcs.log.is.not.available=VCS 日誌不可用
vcs.log.loading.selected.details.process=正在載入所選詳細資訊
vcs.log.loading.status=正在載入提交…
vcs.log.no.commits.matching.status=沒有與篩選器符合的提交
vcs.log.no.commits.status=未提交更改。
vcs.log.path.filter.action.text=按路徑篩選
vcs.log.references.more.tooltip=…詳細資訊窗格中的其他 {0} 項
vcs.log.refresh.status.action=重新整理
vcs.log.refreshing.process=正在重新整理歷史記錄…
vcs.log.reset.filters.status.action=重設篩選器
vcs.log.right.corner.toolbar=VCS 日誌工具列
vcs.log.select.folder.dialog.title=選擇要篩選的路徑
vcs.log.show.commit.in.log.process=正在搜尋修訂 {0}
vcs.log.status.bar.indexing={0} 日誌正在編制索引…
vcs.log.status.bar.indexing.cancel.cancelling=正在取消
vcs.log.status.bar.indexing.cancel.tooltip=取消索引編制。可以從 {0} 日誌工具列手動重啟索引編制。
vcs.log.string.is.not.a.hash=''{0}'' 看起來不像提交雜湊
vcs.log.tab.name=日誌
vcs.log.table.accessible.name={0} 日誌
vcs.log.text.filter.accessible.name={0} 日誌文本或雜湊篩選器
vcs.log.text.filter.action.text=按文本或雜湊篩選
vcs.log.user.filter.action.text=按使用者篩選
vcs.log.user.filter.label=使用者
vcs.log.user.filter.me=我"
`;

exports[`src inspectionDescriptions/LeakableMapKey.html 1`] = `
"<html>
<body>
報告在延伸模組程式碼中將 <code>Language</code> 或 <code>FileType</code> 用作映射鍵。
<p>
  此類別用法可能導致無法正確解除安裝延伸模組。
</p>
<p>
  請考慮使用 <code>String</code> 作為鍵。
</p>
<p>
  有關更多資訊，請參閱 SDK 文檔中的<a href="https://plugins.jetbrains.com/docs/intellij/dynamic-plugins.html">動態延伸模組</a>。
</p>
</body>
</html>"
`;

exports[`src messages/ActionsBundle.properties 1`] = `
"EmojiAndSymbols.text=表情 \\\\& 符號
MainToolbarQuickActions.General.separator=選項
MainToolbarQuickActions.run.separator=執行
Vcs.VcsClone.Project.text=來自版本控制的專案…
Vcs.VcsClone.Tabbed.Welcome.text=從 VCS 獲取
Vcs.VcsClone.Welcome.text=從版本控制中獲取
action.$Copy.description=複製到剪貼簿
action.$Copy.text=複製(_C)
action.$Cut.description=剪下到剪貼簿
action.$Cut.text=剪下(_T)
action.$Delete.description=刪除所選條目
action.$Delete.text=刪除(_D)
action.$Paste.description=從剪貼簿貼上
action.$Paste.text=貼上(_P)
action.$Redo.text=重做
action.$SearchWeb.description=使用 Google 搜尋選區
action.$SearchWeb.text=使用 Google 搜尋(_S)
action.$SelectAll.description=全選
action.$SelectAll.text=全選(_A)
action.$Undo.text=撤消
action.About.description=顯示有關 IDE 的資訊
action.About.description.specialized=顯示有關 {0} 的資訊
action.About.text=關於(_A)
action.ActionUpdatesBenchmarkAction.text=動作更新基準
action.Actions.ActionsPlugin.GenerateToString.description=生成 toString() 方法
action.Actions.ActionsPlugin.GenerateToString.text=to_String()
action.ActivateDebugToolWindow.text=偵錯
action.ActivateFindToolWindow.text=尋找
action.ActivateHierarchyToolWindow.text=層次結構
action.ActivateMeetNewUIToolWindow.text=認識新 UI
action.ActivateNavBar.description=啟用導覽列
action.ActivateNavBar.text=啟用導覽列(_B)
action.ActivateRunToolWindow.text=執行
action.AddAnotherBookmark.text=將書籤新增到另一個列表
action.AddBreakpoint.text=新增中斷點
action.AddConditionalBreakpoint.text=新增條件中斷點…
action.AddFrameworkSupport.text=新增框架支援…
action.AddGroupToTestSchemeAction.description=允許來自組的所有資料。使用它在本地測試新的收集器。
action.AddGroupToTestSchemeAction.text=將組新增到事件測試方案
action.AddInlayInternalAction.text=新增嵌入…
action.AddToScopeAction.text=新增到作用域
action.AnalyzeHeapDumpSnapshot.text=分析堆傾印
action.AnalyzePluginStartupPerformance.text=分析延伸模組啟動性能
action.AnimatorTestAction.text=測試 Animator
action.Annotate.description=顯示每行的最新修改日期和作者(也稱為“追溯”)
action.Annotate.synonym1=追溯
action.Annotate.text=註解(_N)
action.Annotate.with.Blame.text=使用 Git 追溯註解(_N)
action.AnnotateStackTraceAction.show.files.modification.info.text=顯示檔案修改資訊
action.AnonymousToInner.description=將匿名類別轉換為內部類別
action.AnonymousToInner.text=將匿名轉換成內部(_Y)…
action.ApplyFixedWindowSize.text=套用特定大小
action.AssociateWithFileType.description=將所選檔案關聯到某種檔案類型
action.AssociateWithFileType.text=與檔案類型關聯…
action.AttachDirectory.text=將目錄附加到專案…
action.AttachProject.text=附加專案…
action.AutoIndentLines.description=根據程式碼樣式設定縮排當前行或所選塊
action.AutoIndentLines.text=自動縮排行(_A)
action.AutoShowProcessWindow.description=啟動任何程序時顯示背景任務視窗
action.AutoShowProcessWindow.text=自動顯示
action.Back.description=撤消上次導覽動作
action.Back.text=後退(_B)
action.BookmarkOpenTabs.text=書籤開啟頁籤…
action.BookmarksView.AskBeforeDeletingLists.text=刪除多個書籤前詢問
action.BookmarksView.AutoscrollFromSource.text=始終選擇開啟的元素
action.BookmarksView.AutoscrollToSource.text=一鍵導覽
action.BookmarksView.ChooseType.text=更改助記鍵…
action.BookmarksView.Create.text=建立書籤列表…
action.BookmarksView.DefaultGroup.text=將列表標記為預設
action.BookmarksView.Delete.text=刪除
action.BookmarksView.DeleteType.text=移除助記鍵
action.BookmarksView.GroupLineBookmarks.text=按檔案將行書簽分組
action.BookmarksView.MoveDown.text=下移
action.BookmarksView.MoveUp.text=上移
action.BookmarksView.OpenInPreviewTab.text=覆寫助記鍵之前詢問
action.BookmarksView.Rename.text=編輯
action.BookmarksView.RewriteBookmarkType.text=啟用預覽頁籤
action.BookmarksView.ShowPreview.text=開啟編輯器預覽
action.BookmarksView.SortGroupBookmarks.text=按類型和名稱對書籤進行排序
action.BraceOrQuoteOut.text=跳到當前括號/引號
action.BrowseWeb.text=瀏覽 Web…
action.BuildArtifact.description=選擇並建置專案中組態的工件
action.BuildArtifact.text=建置工件…
action.CallHierarchy.BaseOnThisMethod.text=基於此方法
action.CallHierarchy.description=瀏覽所選方法的呼叫層次結構
action.CallHierarchy.text=呼叫層次結構(_Y)
action.CallSaul.description=執行快取診斷並嘗試恢復其狀態
action.CallSaul.on.file.text=修復{0, choice, 0#檔案|2#檔案}上的 IDE
action.CallSaul.text=修復 IDE
action.ChangeCodeStyleScheme.description=更改當前程式碼樣式方案
action.ChangeCodeStyleScheme.text=程式碼樣式方案
action.ChangeColorScheme.description=更改當前編輯器配色方案
action.ChangeColorScheme.text=編輯器配色方案
action.ChangeFileEncodingAction.description=更改檔案編碼
action.ChangeFileEncodingAction.text=檔案編碼
action.ChangeIdeScale.text=縮放
action.ChangeInspectionProfile.description=更改當前編輯器檢查組態檔案
action.ChangeInspectionProfile.text=錯誤醒目提示顯示
action.ChangeKeymap.description=更改當前按鍵映射
action.ChangeKeymap.text=按鍵映射
action.ChangeLaf.description=更改當前主題
action.ChangeLaf.text=主題
action.ChangeSignature.description=更改所選方法或類別的簽名，並更正所有參照
action.ChangeSignature.text=更改簽名(_G)…
action.ChangeSortingAction.text=按名稱排序
action.ChangeSplitOrientation.description=更改拆分器方向
action.ChangeSplitOrientation.text=更改拆分器方向(_R)
action.ChangeTemplateDataLanguage.text=更改模板資料語言
action.ChangeToThisFileTypeAction.description=將檔案類型覆寫為 ''{0}''
action.ChangeToolWindowLayout.text=布局
action.ChangeTypeSignature.description=更改方法、欄位、參數、變數或類別類型實參的返回值類型的類型，並更正所有參照
action.ChangeTypeSignature.text=類型遷移(_Y)…
action.ChangeView.description=更改檢視模式
action.ChangeView.text=檢視模式
action.ChangesView.AddUnversioned.description=排定將所選檔案新增到 VCS 的時間表
action.ChangesView.AddUnversioned.text=新增到 VCS
action.ChangesView.ApplyPatch.description=將補丁套用到專案的源
action.ChangesView.ApplyPatch.text=套用補丁…
action.ChangesView.ApplyPatchFromClipboard.description=將補丁套用到專案的源
action.ChangesView.ApplyPatchFromClipboard.text=從剪貼簿套用補丁…
action.ChangesView.Browse.description=檢視已提交更改的歷史記錄
action.ChangesView.Browse.text=瀏覽更改…
action.ChangesView.CreatePatch.description=從所選更改建立補丁
action.ChangesView.CreatePatch.text=從本地更改建立補丁…
action.ChangesView.CreatePatchFromChanges.description=從所選更改建立補丁
action.ChangesView.CreatePatchFromChanges.text=建立補丁…
action.ChangesView.CreatePatchToClipboard.description=從更改建立補丁並將其複製到剪貼簿
action.ChangesView.CreatePatchToClipboard.text=作為補丁複製到剪貼簿
action.ChangesView.Edit.description=簽出所選檔案進行編輯
action.ChangesView.Edit.text=簽出
action.ChangesView.GroupBy.Directory.text=目錄
action.ChangesView.GroupBy.Module.text=模組
action.ChangesView.GroupBy.Repository.text=儲存庫
action.ChangesView.Move.Files.text=將檔案移至另一個更改列表…
action.ChangesView.Move.description=將所選更改移至另一個更改列表
action.ChangesView.Move.text=移至另一個更改列表…
action.ChangesView.NewChangeList.description=建立新的更改列表
action.ChangesView.NewChangeList.text=新增更改列表…
action.ChangesView.Refresh.MainMenu.text=重新整理 VCS 更改
action.ChangesView.Refresh.description=重新整理 VCS 更改
action.ChangesView.Refresh.text=重新整理
action.ChangesView.RemoveChangeList.description=移除更改列表並將所有更改移至其他更改列表
action.ChangesView.RemoveChangeList.description.template=移除{0,choice,0#更改列表|2#更改列表}和移動所有的改變到{1}
action.ChangesView.RemoveChangeList.text=刪除更改列表
action.ChangesView.RemoveChangeList.text.template=刪除{0,choice,0#更改列表|2#更改列表}
action.ChangesView.RemoveDeleted.description=排定將所選檔案從 VCS 移除的時間表
action.ChangesView.RemoveDeleted.text=從 VCS 移除
action.ChangesView.Rename.description=編輯所選更改列表的名稱和描述
action.ChangesView.Rename.text=編輯更改列表…
action.ChangesView.Revert.text=回滾(_R)…
action.ChangesView.RevertFiles.text=回滾檔案(_R)…
action.ChangesView.SaveToShelve.description=將所選更改複製到擱置的更改列表
action.ChangesView.SaveToShelve.text=儲存到擱置
action.ChangesView.SetDefault.description=設定預設情況下放置新更改的更改列表
action.ChangesView.SetDefault.text=設定活動更改列表
action.ChangesView.Shelve.description=將更改儲存到外部補丁檔案，並將其從程式碼中移除
action.ChangesView.Shelve.text=擱置更改…
action.ChangesView.ShelveSilently.description=擱置對適當的已擱置更改列表的更改
action.ChangesView.ShelveSilently.text=無提示擱置
action.ChangesView.ShowCommitOptions.text=顯示提交選項
action.ChangesView.SingleClickPreview.text=預覽差異
action.ChangesView.ToggleCommitUi.text=切換提交 UI…
action.ChangesView.UnshelveSilently.description=取消擱置對相應更改列表的更改
action.ChangesView.UnshelveSilently.text=無提示取消擱置
action.CheckForUpdate.WelcomeScreen.text=檢查更新
action.CheckForUpdate.description=檢查可用的 IDE 和延伸模組更新
action.CheckForUpdate.description.plugins=檢查可用的延伸模組更新(IDE 更新在外部管理)
action.CheckForUpdate.text=檢查更新(_C)…
action.CheckIgnoredAndNotExcludedDirectories.description=檢查是否存在可以排除在索引和搜尋之外的已忽略目錄
action.CheckIgnoredAndNotExcludedDirectories.progress=正在檢查已忽略但未排除的目錄…
action.CheckIgnoredAndNotExcludedDirectories.text=檢查已忽略但未排除的目錄
action.CheckStatusForFiles.text=檢查狀態(_K)
action.CheckSuggestedPlugins.text=檢查建議的延伸模組
action.CheckVfsSanity.progress=檢查 VFS 執行狀況(檢視日誌中的結果)
action.CheckVfsSanity.text=執行 VFS 執行狀況檢查
action.CheckinFiles.description=提交選中的檔案或目錄
action.CheckinFiles.text=提交檔案(_I)
action.CheckinProject.text=提交(_I)…
action.ChooseDebugConfiguration.description=選擇並偵錯組態
action.ChooseDebugConfiguration.text=偵錯…
action.ChooseRunConfiguration.description=選擇並執行組態
action.ChooseRunConfiguration.text=執行…
action.ChooseRuntime.text=選擇 IDE 的啟動 Java Runtime…
action.ClassNameCompletion.description=與雙擊基本補全快捷鍵相同(可用於補全非匯入類別名)
action.ClassNameCompletion.text=第二基本補全
action.CleanupEventsTestSchemeAction.description=移除測試方案中註冊的所有組
action.CleanupEventsTestSchemeAction.text=清理事件測試方案
action.ClickLink.text=點擊鏈接
action.CloseActiveTab.description=關閉活動工具視窗頁籤
action.CloseActiveTab.text=關閉活動頁籤(_O)
action.CloseAllEditors.description=在活動頁籤組中關閉所有編輯視窗
action.CloseAllEditors.text=關閉所有頁籤(_A)
action.CloseAllEditorsButActive.description=除活動編輯視窗外關閉所有其他視窗
action.CloseAllEditorsButActive.text=關閉其他頁籤(_O)
action.CloseAllNotifications.text=關閉所有
action.CloseAllProjects.description=關閉所有專案
action.CloseAllProjects.text=關閉所有專案
action.CloseAllReadonly.description=關閉具有唯讀檔案的所有編輯器
action.CloseAllReadonly.text=關閉所有唯讀頁籤
action.CloseAllToTheLeft.description=關閉左邊的所有編輯器
action.CloseAllToTheLeft.text=關閉左側頁籤
action.CloseAllToTheRight.description=關閉右邊的所有編輯器
action.CloseAllToTheRight.text=關閉右側頁籤
action.CloseAllUnmodifiedEditors.description=關閉所有未修改的編輯視窗
action.CloseAllUnmodifiedEditors.text=關閉未修改頁籤(_U)
action.CloseAllUnpinnedEditors.description=關閉所有未固定的編輯視窗
action.CloseAllUnpinnedEditors.text=關閉所有未固定
action.CloseContent.EditorTabPopup.text=關閉(_C)
action.CloseContent.description=關閉當前焦點的內容
action.CloseContent.text=關閉頁籤(_C)
action.CloseEditor.EditorPopup.text=關閉 (_C)
action.CloseEditor.EditorTabPopup.text=關閉(_C)
action.CloseEditor.description=關閉活動編輯器
action.CloseEditor.text=關閉活動編輯器(_C)
action.CloseFirstNotification.text=關閉第一個
action.CloseGotItTooltip.text=關閉“知道了”工具提示
action.CloseOtherProjects.description=關閉其他專案
action.CloseOtherProjects.text=關閉其他專案
action.CloseProject.description=關閉當前專案
action.CloseProject.text=關閉專案(_J)
action.CodeCleanup.description=執行清理檢查並套用快速修復
action.CodeCleanup.text=程式碼清理(_C)…
action.CodeCompletion.description=補全程式碼
action.CodeCompletion.text=基本(_B)
action.CodeInspection.OnEditor.description=使用編輯器設定檢查程式碼(_E)
action.CodeInspection.OnEditor.text=使用編輯器設定檢查程式碼(_E)
action.CollapseAll.text=全部摺疊
action.CollapseAllRegions.description=摺疊所有折疊區域(選區中)
action.CollapseAllRegions.text=全部摺疊(_A)
action.CollapseBlock.description=折疊當前程式碼塊
action.CollapseBlock.text=折疊程式碼塊(_B)
action.CollapseDocComments.description=摺疊所有文檔註釋
action.CollapseDocComments.text=摺疊文檔註釋(_O)
action.CollapseExpandableComponent.text=摺疊組件
action.CollapseRegion.description=摺疊文字游標處的折疊區域
action.CollapseRegion.text=摺疊(_C)
action.CollapseRegionRecursively.description=遞迴摺疊文字游標處的塊
action.CollapseRegionRecursively.text=遞迴折疊(_A)
action.CollapseSelection.description=折疊所選塊
action.CollapseSelection.text=折疊選區/移除區域(_S)
action.CollapseTreeNode.text=摺疊樹節點
action.CollapsiblePanel-toggle.text=展開/摺疊可折疊面板
action.CollectFUStatisticsAction.text=從收集器收集統計資訊…
action.CollectTroubleshootingInformation.text=收集故障排除資訊
action.CollectZippedLogs.description=將日誌和設定壓縮到檔案中
action.CollectZippedLogs.text=收集日誌和診斷資料
action.ColorBlindnessTest.text=測試色盲
action.ColoredHeaderAction.text=Show Project Gradient
action.CommentByBlockComment.description=使用塊註釋註釋/取消程式碼
action.CommentByBlockComment.text=使用塊註釋進行註釋(_B)
action.CommentByLineComment.description=使用行註釋註釋/取消註釋當前行或所選塊
action.CommentByLineComment.text=使用行註釋進行註釋(_L)
action.CommitView.ShowOnDoubleClick.EditorPreview.ToolwindowPopup.text=差異
action.CommitView.ShowOnDoubleClick.EditorPreview.text=雙擊時顯示差異
action.CommitView.ShowOnDoubleClick.Source.ToolwindowPopup.text=源
action.CommitView.ShowOnDoubleClick.Source.text=雙擊時顯示源
action.CommitView.SwitchToCommitDialog.text=切換到“提交”對話框
action.CommittedChanges.Clear.description=清除快取的修訂版本
action.CommittedChanges.Clear.text=清除
action.CommittedChanges.Details.description=檢視所選更改列表的完整資訊
action.CommittedChanges.Details.text=顯示詳細資訊
action.CommittedChanges.Filter.description=更改篩選條件
action.CommittedChanges.Filter.text=篩選
action.CommittedChanges.Refresh.description=重新整理已提交更改的列表
action.CommittedChanges.Refresh.text=重新整理
action.CommittedChanges.Revert.description=將所選更改的反向動作應用於工作副本
action.CommittedChanges.Revert.text=還原更改
action.Compare.LastVersion.text=與最新的儲存庫版本進行比較(_V)
action.Compare.SameVersion.text=與同一個儲存庫版本進行比較(_Y)
action.Compare.Selected.text=與修訂比較(_C)…
action.Compare.Specified.text=與指定修訂比較(_P)…
action.CompareClipboardWithSelection.description=將當前選區與剪貼簿進行比較
action.CompareClipboardWithSelection.text=與剪貼簿比較(_B)
action.CompareDirs.text=比較目錄
action.CompareFileWithEditor.description=將所選檔案與編輯器中的檔案進行比較
action.CompareFileWithEditor.text=與編輯器比較檔案(_M)
action.CompareKeymaps.text=比較按鍵映射…
action.CompareTwoFiles.description=比較兩個所選檔案或目錄
action.CompareTwoFiles.text=比較檔案(_F)
action.Compile.description=強制重新編譯所選模組、檔案或軟體套件
action.Compile.text=重新建置(_E)
action.CompileDirty.description=編譯專案中的所有修改和相依檔案
action.CompileDirty.text=建置專案(_P)
action.CompileFile.text=重新編譯(_E)
action.CompileProject.description=重新編譯專案中的所有檔案
action.CompileProject.text=重新建置專案(_R)
action.CompletionQualityStats.text=補全品質統計資訊
action.ComponentPanelTestAction.text=顯示標準面板
action.ComponentsTestAction.text=顯示組件測試
action.ComputeVirtualFileNameStatAction.text=計算 VF 名稱統計資訊
action.ConfigureDefaultSize.text=組態預設大小…
action.ConfigureEditorTabs.description=組態編輯器頁籤的外觀，行為和順序
action.ConfigureEditorTabs.text=組態編輯器頁籤…
action.ConfigureEventsSchemeFileAction.description=載入自訂目錄中的事件方案
action.ConfigureEventsSchemeFileAction.text=組態事件方案檔案
action.ConfigureScopesAction.text=組態…
action.ConfigureSoftWraps.text=組態自動換行
action.ConfigureTemplatesAction.text=組態實時模板…
action.Console.Execute.Multiline.description=在多行主控台中執行當前語句
action.Console.Execute.Multiline.text=在多行主控台中執行當前語句
action.Console.Execute.description=在單行主控台中執行當前語句
action.Console.Execute.text=在單行主控台中執行當前語句
action.Console.History.Browse.description=瀏覽查詢歷史記錄
action.Console.History.Browse.text=瀏覽查詢歷史記錄
action.Console.History.Next.description=主控台歷史記錄中的下一個條目
action.Console.History.Next.text=主控台歷史記錄中的下一個條目
action.Console.History.Previous.description=主控台歷史記錄中的上一個條目
action.Console.History.Previous.text=主控台歷史記錄中的上一個條目
action.Console.Open.description=為所選實體開啟主控台
action.Console.Open.text=開啟主控台
action.Console.SplitLine.text=拆分行
action.ConsoleView.FoldLinesLikeThis.text=像這樣折疊行
action.ContextHelp.description=顯示上下文幫助
action.ContextHelp.text=上下文幫助(_X)
action.ConvertIndentsToSpaces.description=轉換檔案或所選塊中的縮排，以使用空格代替制表符
action.ConvertIndentsToSpaces.text=轉換為空格
action.ConvertIndentsToTabs.description=轉換檔案或所選塊中的縮排，以使用制表符代替空格
action.ConvertIndentsToTabs.text=轉換為制表符
action.ConvertToInstanceMethod.description=將 static 方法轉換為實例方法並更正所有參照
action.ConvertToInstanceMethod.text=轉換為實例方法(_O)…
action.CopyAbsolutePath.text=絕對路徑
action.CopyAsPlainText.description=將選區複製到剪貼簿作為純文本
action.CopyAsPlainText.text=複製為純文本
action.CopyAsRichText.description=將選區複製到剪貼簿作為富文本(以 RTF 和 HTML 格式)
action.CopyAsRichText.text=複製為富文本
action.CopyContentRootPath.text=來自內容根的路徑
action.CopyElement.description=建立所選類別、檔案或目錄的副本
action.CopyElement.text=複製(_O)…
action.CopyFileName.text=檔名
action.CopyPathWithLineNumber.text=帶行號的路徑
action.CopyPaths.description=將與所選檔案或目錄對應的路徑複製到剪貼簿
action.CopyPaths.text=複製路徑(_O)
action.CopyReference.description=複製對所選類別、方法、函式或所選檔案的相對路徑的參照
action.CopyReference.text=複製參照(_Y)
action.CopySettingsPath.description=複製選定可組態選項的相對路徑
action.CopySourceRootPath.text=來自來源根的路徑
action.CopyTBXReference.text=工具箱 URL
action.CopyUiLabel.text=複製 UI 標籤
action.CopyUrl.description=將文字游標下的 URL 複製到剪貼簿
action.CopyUrl.text=複製 URL
action.CreateDesktopEntry.description=建立桌面條目以與系統應用程式選單整合
action.CreateDesktopEntry.text=建立桌面條目…
action.CreateLauncherScript.description=使 IDE 可從命令行存取
action.CreateLauncherScript.text=建立命令行啟動器…
action.CreateLibraryFromFile.text=新增為庫…
action.CustomLayoutActionsGroup.Rename.description=重新命名當前布局({0})
action.CustomLayoutActionsGroup.Rename.text=重新命名(_R)
action.CustomizeUIAction.text=自訂選單與工具列…
action.DebugBuildProcess.description=如果啟用，建置過程將在啟動時等待偵錯連線
action.DebugBuildProcess.text=偵錯建置過程
action.DebugListen.text=拋出偵錯異常
action.Debugger.AddInlineWatch.text=新增內聯監視
action.Debugger.AddSteppingFilter.text=新增步進篩選器…
action.Debugger.AddToWatch.text=新增到監視
action.Debugger.AdjustArrayRange.text=調整範圍…
action.Debugger.AsyncStacks.text=異步堆疊追蹤
action.Debugger.AutoRenderer.text=自動
action.Debugger.CallTracer.text=追蹤呼叫
action.Debugger.CopyStack.text=複製堆疊
action.Debugger.CreateRenderer.XDebuggerTreePopup.text=建立呈現器
action.Debugger.CreateRenderer.text=建立…
action.Debugger.CustomizeContextView.text=自訂資料檢視…
action.Debugger.CustomizeThreadsView.text=自訂執行緒檢視…
action.Debugger.EditArrayFilter.text=編輯…
action.Debugger.EditCustomField.text=編輯…
action.Debugger.EditFrameSource.text=EditFrameSource
action.Debugger.EvaluateInConsole.text=在主控台中求值
action.Debugger.FilterArray.text=篩選…
action.Debugger.FocusOnBreakpoint.description=到達中斷點時預設切換到此檢視
action.Debugger.FocusOnBreakpoint.text=在中斷點時獲取焦點
action.Debugger.FocusOnFinish.description=預設情況下，在偵錯會話結束時聚焦此檢視
action.Debugger.FocusOnFinish.text=完成後聚焦
action.Debugger.ForceEarlyReturn.description=強制方法在到達 return 語句之前返回
action.Debugger.ForceEarlyReturn.text=強制返回
action.Debugger.FreezeThread.text=掛起
action.Debugger.InterruptThread.text=中斷
action.Debugger.MarkObject.description=標記/取消標記物件，以便可以在偵錯器檢視中直觀區分
action.Debugger.MarkObject.text=標記物件…
action.Debugger.MarkObject.unmark.text=取消標記物件
action.Debugger.MuteRenderers.text=忽略呈現器
action.Debugger.NewCustomField.text=新增類別級別監視…
action.Debugger.PopFrame.description=將執行點移回方法呼叫，從堆疊中丟棄當前的方法幀
action.Debugger.PopFrame.text=重設幀(_F)
action.Debugger.ReloadFile.text=編譯並重新載入檔案
action.Debugger.RemoveAllBreakpoints.text=移除所有中斷點
action.Debugger.RemoveAllBreakpointsInFile.text=移除當前檔案中的所有中斷點
action.Debugger.RemoveArrayFilter.text=移除篩選器
action.Debugger.RemoveCustomField.text=移除監視
action.Debugger.RestoreBreakpoint.description=還原上次刪除的中斷點
action.Debugger.RestoreBreakpoint.text=還原中斷點
action.Debugger.ResumeThread.text=恢復
action.Debugger.ShowCollectionHistory.text=顯示集合歷史記錄
action.Debugger.ShowLibraryFrames.text=顯示/隱藏庫框架
action.Debugger.ShowReferring.text=顯示參照物件…
action.Debugger.ShowRelatedStack.text=顯示相關堆疊…
action.Debugger.ShowTypes.text=顯示類型
action.Debugger.StepOutOfBlock.text=單步跳出程式碼塊
action.Debugger.SwitchToTheNextContext.text=切換到下一個停止的中斷點
action.Debugger.ThrowException.description=拋出一個異常
action.Debugger.ThrowException.text=拋出異常
action.Debugger.Tree.EvaluateInConsole.text=在主控台中求值
action.Debugger.ViewEditText.text=檢視/編輯文本
action.Debugger.ViewText.description=在單獨的窗格中檢視所選節點的文本值
action.Debugger.ViewText.text=檢視文本
action.Debugger.XDebuggerTextPopup.ShowAsObject.text=顯示為物件
action.DecrementWindowHeight.text=減小高度
action.DecrementWindowWidth.text=減小寬度
action.DelegateMethods.description=為欄位/getter 生成委託方法
action.DelegateMethods.text=委託方法...(_D)
action.DeleteMnemonicFromBookmark.text=移除助記鍵
action.DeleteOldAppDirs.description=尋找以前 IDE 版本中的設定、快取和日誌目錄
action.DeleteOldAppDirs.text=刪除殘留的 IDE 目錄…
action.DeleteRecentFiles.description=從最近的檔案中刪除所選檔案或關閉所選工具視窗
action.DeleteRecentFiles.text=從最近的檔案中刪除
action.DetachDirectory.text=從專案中分離目錄…
action.Diff.AppendLeftSide.text=追加左側
action.Diff.AppendRightSide.text=追加右側
action.Diff.ApplyLeftSide.text=接受左側
action.Diff.ApplyNonConflicts.Left.text=從左側套用不衝突的更改
action.Diff.ApplyNonConflicts.Right.text=從右側套用不衝突的更改
action.Diff.ApplyNonConflicts.text=套用所有不衝突的更改
action.Diff.ApplyRightSide.text=接受右側
action.Diff.ComparePartial.Base.Left.text=左和中
action.Diff.ComparePartial.Base.Right.text=中和右
action.Diff.ComparePartial.Generic={0,choice,0#左|1#中|2#右} 和 {1,choice,0#左|1#中|2#右}
action.Diff.ComparePartial.Left.Right.text=左和右
action.Diff.CompareWithBase.Left.text=基礎和左
action.Diff.CompareWithBase.Result.text=基礎和中
action.Diff.CompareWithBase.Right.text=基礎和右
action.Diff.FocusOppositePane.description=在差異檢視中選擇相對窗格
action.Diff.FocusOppositePane.text=選擇相對差異窗格
action.Diff.FocusOppositePaneAndScroll.description=在差異檢視的相對窗格中選擇相同的位置
action.Diff.FocusOppositePaneAndScroll.text=在相對差異窗格中選擇位置
action.Diff.IgnoreLeftSide.text=忽略左側
action.Diff.IgnoreRightSide.text=忽略右側
action.Diff.MagicResolveConflicts.text=解決簡單的衝突
action.Diff.NextChange.text=比較下一個檔案
action.Diff.NextConflict.description=移至下一個未解決的衝突
action.Diff.NextConflict.text=下一個衝突
action.Diff.OpenDiffInEditor.text=作為編輯器頁籤開啟選定的差異請求
action.Diff.PrevChange.text=比較上一個檔案
action.Diff.PreviousConflict.description=移至上一個未解決的衝突
action.Diff.PreviousConflict.text=上一個衝突
action.Diff.ResolveConflict.text=自動解決
action.Diff.ShowDiff.description=比較檔案或修訂。
action.Diff.ShowDiff.text=顯示差異
action.Diff.ShowDiffPreview.description=選區更改時取代差異內容
action.Diff.ShowInExternalTool.text=在外部工具中顯示差異
action.Diff.ShowSettingsPopup.text=顯示差異設定彈出視窗…
action.Diff.ShowStandaloneDiff.description=在新頁籤或視窗中開啟每個選區的差異
action.Diff.ShowStandaloneDiff.tab.description=在新頁籤中開啟每個選區的差異
action.Diff.ShowStandaloneDiff.tab.text=在新頁籤中顯示差異
action.Diff.ShowStandaloneDiff.text=在新頁籤或視窗中顯示差異
action.Diff.ShowStandaloneDiff.window.description=在新視窗中開啟每個選區的差異
action.Diff.ShowStandaloneDiff.window.text=在新視窗中顯示差異
action.DirDiffMenu.CancelComparingNewFilesWithEachOther.text=取消相互比較新檔案
action.DirDiffMenu.CompareNewFilesWithEachOtherAction.text=相互比較新檔案
action.DirDiffMenu.EnableEqual.text=顯示相同的檔案
action.DirDiffMenu.EnableLeft.text=在左側顯示新檔案
action.DirDiffMenu.EnableNotEqual.text=顯示差異
action.DirDiffMenu.EnableRight.text=在右側顯示新檔案
action.DirDiffMenu.MirrorToLeft.text=設定鏡像到左側
action.DirDiffMenu.MirrorToRight.text=設定鏡像到右側
action.DirDiffMenu.SetCopyToLeft.text=設定複製到左側
action.DirDiffMenu.SetCopyToRight.text=設定複製到右側
action.DirDiffMenu.SetDefault.text=設定預設值
action.DirDiffMenu.SetDelete.text=設定刪除
action.DirDiffMenu.SetNoOperation.text=設定不執行任何動作
action.DirDiffMenu.SynchronizeDiff.All.text=全部同步
action.DirDiffMenu.SynchronizeDiff.text=同步選定項
action.DirDiffMenu.WarnOnDeletion.text=刪除時發出警告
action.DisableNewUi.description=切換為經典 UI
action.DisableNewUi.text=切換為經典 UI…
action.DockPinnedMode.description=使工具視窗停靠並固定
action.DockPinnedMode.text=停靠固定(_P)
action.DockToolWindow.text=Dock
action.DockUnpinnedMode.description=使工具視窗停靠但焦點丟失時自動隱藏
action.DockUnpinnedMode.text=停靠不固定(_U)
action.Document2XSD.text=從 XSD 架構生成 XML 文檔…
action.Documentation.Back.text=後退
action.Documentation.EditSource.text=跳轉到源(_J)
action.Documentation.Forward.text=前進
action.Documentation.KeepTab.description=關閉當前頁籤中的所有更新，使下一個動作呼叫開啟新的頁籤
action.Documentation.KeepTab.text=保留此文檔
action.Documentation.ToggleAutoShow.description=切換是否使用補全彈出視窗自動顯示文檔
action.Documentation.ToggleAutoShow.text=在補全期間自動顯示
action.Documentation.ToggleAutoUpdate.description=選區更改時自動重新整理文檔
action.Documentation.ToggleAutoUpdate.text=從源自動更新
action.Documentation.ToggleShowInPopup.description=切換是否應在工具視窗之前顯示“文檔”彈出視窗
action.Documentation.ToggleShowInPopup.text=首先顯示“文檔”彈出視窗
action.Documentation.ViewExternal.text=檢視外部文檔
action.DomCollectionControl.Add.text=新增
action.DomCollectionControl.Edit.text=編輯
action.DomCollectionControl.Remove.text=移除
action.DumbMode.text=沉默模式
action.DumpConfigurationTypesAction.text=傾印組態
action.DumpExtensions.text=傾印副檔名
action.DumpFeaturesAndTips.description=將有關功能和提示檔案的資訊複製到剪貼簿
action.DumpFeaturesAndTips.text=傾印功能和提示資訊(_D)
action.DumpFocusableComponentHierarchyAction.text=傾印可聚焦組件層次結構
action.DumpFormattingModelAction.text=傾印格式化模型
action.DumpIElementTypesAction.text=傾印 IElementType 註冊表
action.DumpInspectionDescriptions.text=傾印檢查描述
action.DumpInspectionDescriptionsAction.text=傾印檢查描述
action.DumpIntentionsAction.text=傾印意圖
action.DumpIntentionsDescriptions.text=傾印意圖描述
action.DumpInvalidTipsOfTheDay.text=傾印無效的每日小技巧
action.DumpLibraryUsageStatistics.text=傾印庫用法的統計資訊
action.DumpLoadedInspectionsAction.text=傾印已初始化的檢查
action.DumpLookupElementWeights.text=將尋找元素權重傾印到日誌
action.DumpScreenConfiguration.text=傾印螢幕組態
action.DumpThreads.text=獲取執行緒傾印
action.DumpVfsInfoForExcludedFilesAction.text=傾印排除根下檔案的 VFS 內容
action.DumpWatchedRoots.text=顯示監視的 VFS 根
action.DupLocate.description=尋找專案中的重複程式碼
action.DupLocate.text=定位重複項(_L)…
action.EditBookmark.text=重新命名書籤…
action.EditBreakpoint.text=編輯中斷點
action.EditCustomProperties.description=開啟帶有自訂屬性檔案的編輯器頁籤
action.EditCustomProperties.text=編輯自定義屬性…
action.EditCustomVmOptions.description=開啟帶有自訂虛擬機選項檔案的編輯器頁籤
action.EditCustomVmOptions.text=編輯自定義虛擬機選項…
action.EditMacros.description=組態現有巨集
action.EditMacros.text=編輯巨集(_E)
action.EditSource.description=開啟所選條目的編輯器並使之獲得焦點
action.EditSource.text=跳轉到源(_J)
action.EditSourceInNewWindow.EditorTabPopup.text=將頁籤移至新視窗
action.EditSourceInNewWindow.description=在新視窗開啟所選條目的編輯器並使之獲得焦點
action.EditSourceInNewWindow.text=在新視窗中開啟源
action.EditSourceNotInEditor.text=編輯源(不在編輯器中)
action.EditTestSchemeAction.description=允許來自組的所有資料。使用它在本地測試新的收集器。
action.EditTestSchemeAction.text=編輯事件測試方案
action.EditorAddCaretPerSelectedLine.text=在所選行的末尾新增文字游標
action.EditorAddOrRemoveCaret.description=在當前檔案中設定多個游標，以同時編輯多行程式碼。
action.EditorAddOrRemoveCaret.text=新增或移除文字游標
action.EditorAddRectangularSelectionOnMouseDrag.text=拖動滑鼠時新增矩形選區
action.EditorBackSpace.text=退格
action.EditorBackwardParagraph.text = 將文字游標後移一段
action.EditorBackwardParagraphWithSelection.text = 在保持選區的情況下將文字游標後移一段
action.EditorBreadcrumbsHideBoth.description=隱藏路徑導覽列
action.EditorBreadcrumbsHideBoth.text=不顯示
action.EditorBreadcrumbsShowAbove.description=在文本編輯器上方顯示路徑導覽列
action.EditorBreadcrumbsShowAbove.text=頂部
action.EditorBreadcrumbsShowBelow.description=在文本編輯器下方顯示路徑導覽列
action.EditorBreadcrumbsShowBelow.text=底部
action.EditorChooseLookupItem.text=選擇查詢條目
action.EditorChooseLookupItemCompleteStatement.text=選擇查詢條目並呼叫語句補全
action.EditorChooseLookupItemDot.text=選擇查詢條目並插入點
action.EditorChooseLookupItemReplace.text=選擇查詢條目取代
action.EditorCloneCaretAbove.description=在上面的行中插入一個輔助游標，以同時編輯多行程式碼。
action.EditorCloneCaretAbove.text=在上方克隆文字游標
action.EditorCloneCaretBelow.description=在下面的行中插入一個輔助游標，以同時編輯多行程式碼。
action.EditorCloneCaretBelow.text=在下方克隆文字游標
action.EditorCodeBlockEnd.text=將文字游標移至程式碼塊結束
action.EditorCodeBlockEndWithSelection.text=在保持選區的情況下將文字游標移至程式碼塊結束
action.EditorCodeBlockStart.text=將文字游標移至程式碼塊開始
action.EditorCodeBlockStartWithSelection.text=在保持選區的情況下將文字游標移至程式碼塊開始
action.EditorCompleteStatement.text=補全當前語句
action.EditorConsoleScrollToTheEnd.text=滾動到結尾
action.EditorContextInfo.description=不可見時，顯示當前方法或類別宣告
action.EditorContextInfo.text=上下文資訊(_C)
action.EditorCopy.text=複製
action.EditorCreateRectangularSelection.text=建立矩形選區
action.EditorCreateRectangularSelectionOnMouseDrag.text=拖動滑鼠建立矩形選區
action.EditorCut.text=剪下
action.EditorCutLineBackward.text=反向剪下行
action.EditorCutLineEnd.text=剪下到行尾
action.EditorDecreaseFontSize.text=減小字體大小
action.EditorDelete.text=刪除
action.EditorDeleteLine.text=刪除行
action.EditorDeleteToLineEnd.text=刪除到行尾
action.EditorDeleteToLineStart.text=刪除到行首
action.EditorDeleteToWordEnd.text=刪除到詞尾
action.EditorDeleteToWordEndInDifferentHumpsMode.text=在不同的 "CamelHumps" 模式下刪除到詞尾
action.EditorDeleteToWordStart.text=刪除到詞首
action.EditorDeleteToWordStartInDifferentHumpsMode.text=在不同的 "CamelHumps" 模式下刪除到詞首
action.EditorDown.text=下
action.EditorDownWithSelection.text=在保持選區的情況下向下
action.EditorDuplicate.text=重複行或選區
action.EditorDuplicateLines.text=重複整行
action.EditorEnter.text=Enter
action.EditorEscape.text=Esc
action.EditorFocusGutter.text=焦點裝訂區域(無障礙功能)
action.EditorForwardParagraph.text = 將文字游標前移一段
action.EditorForwardParagraphWithSelection.text = 在保持選區的情況下將文字游標前移一段
action.EditorGutterToggleGlobalIndentLines.text=顯示縮排參考線
action.EditorGutterToggleGlobalLineNumbers.text=顯示行號
action.EditorGutterToggleLocalSoftWraps.gutterText=自動換行當前編輯器
action.EditorHungryBackSpace.description=與退格鍵的作用相同，但也會移除文字游標前的所有空白符號(如有)
action.EditorHungryBackSpace.text=飢餓退格
action.EditorIncreaseFontSize.text=增大字體大小
action.EditorIndentLineOrSelection.text=縮排行或選區
action.EditorIndentSelection.text=縮排選區
action.EditorJoinLines.text=合併行
action.EditorKillRegion.text=終止所選區域
action.EditorKillRingSave.text=儲存至終止環
action.EditorKillToWordEnd.text=終止至詞尾
action.EditorKillToWordStart.text=終止至詞首
action.EditorLeft.text=左
action.EditorLeftWithSelection.text=在保持選區的情況下向左
action.EditorLineEnd.text=將文字游標移至行尾
action.EditorLineEndWithSelection.text=在保持選區的情況下將文字游標移至行尾
action.EditorLineStart.text=將文字游標移至行首
action.EditorLineStartWithSelection.text=在保持選區的情況下將文字游標移至行首
action.EditorLookupDown.text=向下尋找
action.EditorLookupSelectionDown.text=選擇下一個補全選項
action.EditorLookupSelectionUp.text=選擇上一個補全選項
action.EditorLookupUp.text=向上尋找
action.EditorMatchBrace.text=將文字游標移至符合的大括號
action.EditorMoveDownAndScroll.text=向下移動並滾動
action.EditorMoveDownAndScrollWithSelection.text=在保持選區的情況下向下移動並滾動
action.EditorMoveToPageBottom.text=將文字游標移至頁面底部
action.EditorMoveToPageBottomWithSelection.text=在保持選區的情況下將文字游標移至頁面底部
action.EditorMoveToPageTop.text=將文字游標移至頁面頂部
action.EditorMoveToPageTopWithSelection.text=在保持選區的情況下將文字游標移至頁面頂部
action.EditorMoveUpAndScroll.text=向上移動並滾動
action.EditorMoveUpAndScrollWithSelection.text=在保持選區的情況下向上移動並滾動
action.EditorNextWord.text=將文字游標移至下一個單詞
action.EditorNextWordInDifferentHumpsMode.text=在不同的 "CamelHumps" 模式下將文字游標移至下一個單詞
action.EditorNextWordInDifferentHumpsModeWithSelection.text=在不同的 "CamelHumps" 模式下保持選區的情況下將文字游標移至下一個單詞
action.EditorNextWordWithSelection.text=在保持選區的情況下將文字游標移至下一個單詞
action.EditorPageDown.text=向下翻頁
action.EditorPageDownWithSelection.text=在保持選區的情況下向下翻頁
action.EditorPageUp.text=向上翻頁
action.EditorPageUpWithSelection.text=在保持選區的情況下向上翻頁
action.EditorPaste.text=貼上
action.EditorPasteFromX11.text=從 X 剪貼簿貼上
action.EditorPasteSimple.description=貼上，不進行格式化、自動匯入、文字轉義等。
action.EditorPasteSimple.text=貼上為純文本(_L)
action.EditorPreviousWord.text=將文字游標移至上一個單詞
action.EditorPreviousWordInDifferentHumpsMode.text=在不同的 "CamelHumps" 模式下將文字游標移至上一個單詞
action.EditorPreviousWordInDifferentHumpsModeWithSelection.text=在不同的 "CamelHumps" 模式下保持選區的情況下將文字游標移至上一個單詞
action.EditorPreviousWordWithSelection.text=在保持選區的情況下將文字游標移至上一個單詞
action.EditorRenderingBenchmarkAction.text=編輯器渲染基準
action.EditorResetFontSize.text=重設字體大小
action.EditorReverseLines.text=反轉行
action.EditorRight.text=右
action.EditorRightWithSelection.text=在保持選區的情況下向右
action.EditorScrollBottom.text=滾動到底部
action.EditorScrollDown.text=向下滾動
action.EditorScrollDownAndMove.text=向下滾動並根據需要移動
action.EditorScrollLeft.text=向左滾動
action.EditorScrollRight.text=向右滾動
action.EditorScrollToCenter.text=滾動到中心
action.EditorScrollTop.text=滾動到頂部
action.EditorScrollUp.text=向上滾動
action.EditorScrollUpAndMove.text=向上滾動並根據需要移動
action.EditorSelectLine.text=擴展行選區
action.EditorSelectSingleLineAtCaret.text=選擇文字游標處的一行
action.EditorSelectWord.text=擴展選區
action.EditorSetContentBasedBidiTextDirection.description=方向由初始字元決定
action.EditorSetContentBasedBidiTextDirection.text=基於內容
action.EditorSetLtrBidiTextDirection.text=左到右
action.EditorSetRtlBidiTextDirection.text=右到左
action.EditorShowGutterIconTooltip.text=顯示裝訂區域圖標工具提示(無障礙功能)
action.EditorSortLines.text=排序行
action.EditorSplitLine.text=拆分行
action.EditorStartNewLine.text=開始新行
action.EditorStartNewLineBefore.text=在當前行之前開始新行
action.EditorSwapSelectionBoundaries.text=交換選區邊界
action.EditorTab.text=頁籤
action.EditorTextEnd.text=將文字游標移至文本結束
action.EditorTextEndWithSelection.text=在保持選區的情況下將文字游標移至文本結束
action.EditorTextStart.text=將文字游標移至文本開始
action.EditorTextStartWithSelection.text=在保持選區的情況下將文字游標移至文本開始
action.EditorToggleCase.text=切換大小寫
action.EditorToggleColumnMode.description=在當前編輯器中切換列選擇模式
action.EditorToggleColumnMode.text=列選擇模式(_M)
action.EditorToggleInsertState.text=切換插入/覆蓋
action.EditorToggleShowBreadcrumbs.description=在當前編輯器中切換顯示路徑導覽列
action.EditorToggleShowBreadcrumbs.text=顯示路徑導覽
action.EditorToggleShowGutterIcons.description=在當前編輯器中切換顯示裝訂區域圖標
action.EditorToggleShowGutterIcons.text=顯示裝訂區域圖標 (_O)
action.EditorToggleShowIndentLines.description=在當前編輯器中切換顯示縮排參考線
action.EditorToggleShowIndentLines.text=顯示縮排參考線(_O)
action.EditorToggleShowLineNumbers.description=在當前編輯器中切換顯示行號
action.EditorToggleShowLineNumbers.text=顯示行號(_I)
action.EditorToggleShowWhitespaces.description=在當前編輯器中切換顯示空格
action.EditorToggleShowWhitespaces.text=顯示空格(_O)
action.EditorToggleStickySelection.text=切換粘性選區
action.EditorToggleUseSoftWraps.description=在當前編輯器中切換使用自動換行
action.EditorToggleUseSoftWraps.text=自動換行
action.EditorToggleUseSoftWrapsInPreview.description=在預覽編輯器中切換使用自動換行
action.EditorToggleUseSoftWrapsInPreview.text=自動換行預覽編輯器
action.EditorToggleVisualFormattingLayer.description=使用視覺嵌入和折疊，根據您的程式碼樣式採用空格
action.EditorToggleVisualFormattingLayer.text=切換視覺格式化層
action.EditorTranspose.text=轉置
action.EditorUnSelectWord.text=收縮選區
action.EditorUnindentSelection.text=取消縮排行或選區
action.EditorUp.text=上
action.EditorUpWithSelection.text=在保持選區的情況下向上
action.EmacsStyleIndent.text=Emacs 頁籤
action.EmmetNextEditPoint.description=轉到下一個 Emmet 編輯點
action.EmmetNextEditPoint.text=下一個 Emmet 編輯點
action.EmmetPreview.description=顯示 Emmet 縮寫的預覽
action.EmmetPreview.text=Emmet 預覽
action.EmmetPreviousEditPoint.description=轉到上一個 Emmet 編輯點
action.EmmetPreviousEditPoint.text=上一個 Emmet 編輯點
action.EmmetUpdateTag.description=使用 Emmet 縮寫更新現有 HTML 標記
action.EmmetUpdateTag.text=使用 Emmet 更新標記
action.EmojiAndSymbols.description=使用 macOS 系統調色板輸入特殊字元
action.EnableMetalRendering.text=Metal 呈現管道
action.EnableNewUi.description=啟用新 UI
action.EnableNewUi.text=啟用新 UI…
action.EncapsulateFields.description=使用存取器方法取代所選類別中欄位的直接存取
action.EncapsulateFields.text=封裝欄位(_E)…
action.EscapeEntities.description=使用實體轉義 XML/HTML 特殊字元
action.EscapeEntities.text=編碼 XML/HTML 特殊字元
action.EvaluateExpression.description=對任意表達式求值
action.EvaluateExpression.text=對表達式求值(_X)…
action.ExcludeFromProjectAction.text=從專案中排除
action.ExecutionTargets.text=目標
action.Exit.description=退出 IDE
action.Exit.text=退出(_X)
action.ExpandAll.text=全部展開
action.ExpandAllRegions.description=展開所有折疊區域(選區中)
action.ExpandAllRegions.text=全部展開(_E)
action.ExpandAllToLevel1.text=_1
action.ExpandAllToLevel2.text=_2
action.ExpandAllToLevel3.text=_3
action.ExpandAllToLevel4.text=_4
action.ExpandAllToLevel5.text=_5
action.ExpandCollapseToggleAction.description=展開或摺疊當前程式碼塊
action.ExpandCollapseToggleAction.text=切換折疊
action.ExpandDocComments.description=展開所有文檔註釋
action.ExpandDocComments.text=展開文檔註釋(_D)
action.ExpandExpandableComponent.text=展開組件
action.ExpandLiveTemplateByTab.text=按 Tab 展開實時模板
action.ExpandLiveTemplateCustom.description=使用在編輯器中鍵入的前綴呼叫綁定到 '自訂快捷鍵' 的實時模板
action.ExpandLiveTemplateCustom.text=展開實時模板/Emmet 縮寫
action.ExpandRegion.description=展開文字游標處的折疊區域
action.ExpandRegion.text=展開(_X)
action.ExpandRegionRecursively.description=遞迴展開文字游標處的塊
action.ExpandRegionRecursively.text=遞迴展開(_R)
action.ExpandToLevel1.text=_1
action.ExpandToLevel2.text=_2
action.ExpandToLevel3.text=_3
action.ExpandToLevel4.text=_4
action.ExpandToLevel5.text=_5
action.ExpandTreeNode.text=展開樹節點
action.ExportSettings.description=匯出全域設定
action.ExportSettings.text=匯出設定(_E)…
action.ExportTestResults.description=將測試結果匯出到檔案
action.ExportTestResults.text=匯出測試結果…
action.ExportThreads.description=將所有執行緒資訊儲存到文本檔案或剪貼簿
action.ExportThreads.text=匯出執行緒(_H)…
action.ExportToEclipse.description=為每個模組建立 Eclipse 專案
action.ExportToEclipse.text=匯出到 Eclipse…
action.ExportToHTML.MainMenu.text=將檔案或選區匯出到 HTML(_H)…
action.ExportToHTML.description=以 HTML 格式儲存檔案內容，包括語法顏色
action.ExportToHTML.text=將檔案或選區匯出到 HTML(_H)…
action.ExportToTextFile.text=匯出到文本檔案
action.ExpressionStatistics.text=收集 Java 表達式統計資訊
action.ExpressionTypeInfo.description=顯示所選表達式的類型
action.ExpressionTypeInfo.text=類型資訊(_E)
action.ExternalJavaDoc.description=開啟包含所選條目文檔的瀏覽器
action.ExternalJavaDoc.text=外部文檔(_X)
action.ExternalSystem.AfterCompile.description=在建置後執行選定任務
action.ExternalSystem.AfterCompile.text=建置後執行
action.ExternalSystem.AfterRebuild.description=在完全重新建置後執行選定任務
action.ExternalSystem.AfterRebuild.text=重新建置後執行
action.ExternalSystem.AfterSync.description=在專案匯入後執行選定任務
action.ExternalSystem.AfterSync.text=同步後執行
action.ExternalSystem.AssignRunConfigurationShortcut.description=將快捷鍵分配給選定執行組態
action.ExternalSystem.AssignRunConfigurationShortcut.text=分配快捷鍵…
action.ExternalSystem.AssignShortcut.description=將快捷鍵分配給選定任務
action.ExternalSystem.AssignShortcut.text=分配快捷鍵…
action.ExternalSystem.BeforeCompile.description=在建置前執行選定任務
action.ExternalSystem.BeforeCompile.text=建置前執行
action.ExternalSystem.BeforeRebuild.description=在完全重新建置前執行選定任務
action.ExternalSystem.BeforeRebuild.text=重新建置前執行
action.ExternalSystem.BeforeRun.description=在啟動執行/偵錯組態之前執行選定任務
action.ExternalSystem.BeforeRun.text=在執行/偵錯之前執行…
action.ExternalSystem.BeforeSync.description=在專案匯入前執行選定任務
action.ExternalSystem.BeforeSync.text=同步前執行
action.ExternalSystem.CollapseAll.text=全部摺疊
action.ExternalSystem.EditRunConfiguration.text=編輯執行組態…
action.ExternalSystem.ExpandAll.text=全部展開
action.ExternalSystem.GroupModules.text=組模組
action.ExternalSystem.GroupTasks.text=組任務
action.ExternalSystem.RemoveRunConfiguration.text=移除執行組態
action.ExternalSystem.RunTask.description=執行選定任務
action.ExternalSystem.RunTask.text=執行任務(_R)
action.ExternalSystem.SelectProjectDataToImport.text=選擇要匯入的專案資料
action.ExternalSystem.ShowCommonSettings.description=為當前專案編輯建置工具設定
action.ExternalSystem.ShowCommonSettings.text=自動重新載入設定…
action.ExternalSystem.ShowIgnored.text=顯示忽略項
action.ExternalSystem.ShowInheritedTasks.text=顯示從子專案繼承的任務
action.ExtractClass.description=提取委託
action.ExtractClass.text=提取委託(_D)…
action.ExtractInclude.description=將所選程式碼段轉換為包含的檔案
action.ExtractInclude.text=Include 檔案(_I)…
action.ExtractInterface.description=從所選類別提取接口
action.ExtractInterface.text=提取接口(_I)…
action.ExtractMethod.description=將所選程式碼段轉換為一個方法
action.ExtractMethod.text=提取方法(_M)…
action.ExtractModule.description=從所選類別提取模組
action.ExtractModule.text=提取模組(_M)…
action.ExtractModuleFromPackage.description=將軟體套件提取到單獨的模組
action.ExtractModuleFromPackage.text=提取模組…
action.ExtractSuperclass.description=從所選類別提取超類別
action.ExtractSuperclass.text=提取超類別(_U)…
action.FileChooser.Delete.description=刪除
action.FileChooser.Delete.text=刪除…
action.FileChooser.GoBackward.description=轉到之前存取過的目錄。
action.FileChooser.GoBackward.text=上一個目錄
action.FileChooser.GoForward.description=轉到之前存取過的目錄。
action.FileChooser.GoForward.text=下一個目錄
action.FileChooser.GoToParent.description=轉到父目錄
action.FileChooser.GoToParent.text=父目錄
action.FileChooser.GoToRoot.description=轉到根目錄或根目錄列表
action.FileChooser.GoToRoot.text=根目錄
action.FileChooser.GoToWslHome.description=轉到 WSL VM 中的主目錄
action.FileChooser.GoToWslHome.text=WSL 中的主目錄
action.FileChooser.GotoDesktop.description=轉到桌面目錄
action.FileChooser.GotoDesktop.text=桌面目錄
action.FileChooser.GotoHome.description=轉到主目錄
action.FileChooser.GotoHome.text=主目錄
action.FileChooser.GotoModule.description=轉到模組目錄
action.FileChooser.GotoModule.text=模組目錄
action.FileChooser.GotoProject.description=轉到專案目錄
action.FileChooser.GotoProject.text=專案目錄
action.FileChooser.LightEditGotoOpenedFile.text=選擇開啟的檔案
action.FileChooser.NewFile.description=建立新檔案
action.FileChooser.NewFile.text=新增檔案…
action.FileChooser.NewFolder.description=建立新目錄
action.FileChooser.NewFolder.text=新增目錄…
action.FileChooser.Refresh.description=重新整理檔案系統樹
action.FileChooser.Refresh.text=重新整理
action.FileChooser.ShowHidden.description=顯示隱藏的檔案和目錄
action.FileChooser.ShowHidden.text=顯示隱藏的檔案和目錄
action.FileChooser.ToggleDetection.description=允許 IDE 檢視內部以檢測專案目錄
action.FileChooser.ToggleDetection.text=檢測專案目錄
action.FileChooser.TogglePathBar.description=切換路徑輸入欄位的可見性
action.FileChooser.TogglePathBar.text=顯示/隱藏路徑輸入欄位
action.FileChooser.TogglePathShowing.text=顯示/隱藏路徑文本
action.FileStructurePopup.description=顯示帶有當前檔案結構的彈出視窗，以便快速導覽
action.FileStructurePopup.text=檔案結構(_I)
action.FillParagraph.description=重新格式化字串文字或註釋以適應最大寬度(通常為80)
action.FillParagraph.text=填充段落
action.Find.description=在活動編輯器中尋找字串
action.Find.text=尋找(_F)…
action.FindInPath.description=在多個檔案中尋找字串
action.FindInPath.synonym1=在路徑中尋找
action.FindInPath.text=在檔案中尋找…
action.FindNext.MainMenu.text=尋找下一個符合項(_N)
action.FindNext.description=重複上一次尋找/取代動作，或移至所選文本的下一個符合項
action.FindNext.text=尋找下一個/移至下一個符合項(_N)
action.FindPrevWordAtCaret.description=尋找文字游標處單詞的上一個符合項
action.FindPrevWordAtCaret.text=文字游標處單詞的上一個符合項
action.FindPrevious.MainMenu.text=尋找上一個符合項(_V)
action.FindPrevious.description=反向重複上一次尋找/取代動作，或移至所選文本的上一個符合項
action.FindPrevious.text=尋找上一個/移至上一個符合項(_V)
action.FindSelectionInPath.text=在檔案中尋找
action.FindUsages.description=尋找文字游標處符號的用法
action.FindUsages.text=尋找用法(_U)
action.FindUsagesInFile.description=在活動編輯器中尋找文字游標處符號的用法
action.FindUsagesInFile.text=在檔案中尋找用法(_I)
action.FindUsedTestData.text=尋找未使用的測試資料
action.FindWordAtCaret.description=尋找文字游標處單詞的下一個符合項
action.FindWordAtCaret.text=尋找文字游標處的字
action.FixDocComment.description=生成或修正當前上下文的文檔註釋
action.FixDocComment.text=修正文檔註釋
action.FixLineSeparators.text=修復行分隔符
action.FixWSLFirewall.text=修正 WSL 防火牆設定
action.FloatMode.description=將工具視窗移至單獨的對話框
action.FloatMode.text=浮動(_F)
action.Floating.CodeToolbar.Customize.text=自訂工具列…
action.Floating.CodeToolbar.Disable.text=不顯示工具列
action.Floating.CodeToolbar.SurroundWithIf.text=if
action.Floating.CodeToolbar.SurroundWithTryCatch.text=try / catch
action.Floating.CodeToolbar.SurroundWithTryCatchFinally.text=try / catch / finally
action.FocusDebugger.text=啟動焦點偵錯器
action.FocusEditor.text=聚焦編輯器
action.FocusTracer.text=啟動焦點追蹤
action.ForceIndexRebuild.text=重建索引
action.ForceIndexRescanning.text=同步索引
action.ForceRefresh.text=強制重新整理
action.ForceRunToCursor.description=執行到文字游標所在的行，忽略任何中斷點
action.ForceRunToCursor.text=強制執行到游標(_S)
action.ForceStepInto.description=步入，忽略庫、建構函式等步進篩選器。
action.ForceStepInto.text=強制步入(_N)
action.ForceStepOver.description=步過，在步進前停用所有中斷點。
action.ForceStepOver.text=強制步過(_V)
action.Forward.description=恢復上次撤消的導覽動作
action.Forward.text=前進(_W)
action.FullyExpandTreeNode.text=完全展開樹節點
action.GatewayCollectLogsAction.text = 收集所有日誌
action.GemRequirements.ShowSettings.text=Ruby SDK 和 Gem
action.Generate.description=生成建構函式、getter 或 setter 方法等
action.Generate.text=生成…
action.GenerateAfterClassMethod.text=AfterClass 方法
action.GenerateBeforeClassMethod.text=BeforeClass 方法
action.GenerateConstructor.description=生成建構函式
action.GenerateConstructor.text=建構函式
action.GenerateCoverageReport.text=生成覆蓋率報告(_G)
action.GenerateCreateUI.description=生成 createUI(...)
action.GenerateCreateUI.text=createUI(...)
action.GenerateDTD.text=從 XML 檔案生成 DTD(_X)
action.GenerateDataMethod.text=參數方法
action.GenerateEquals.description=生成 equals() 和 hashCode()
action.GenerateEquals.text=equals() 和 hashCode()
action.GenerateEventsScheme.description=從正在執行的 IDE 實例中收集統計資訊收集器的方案
action.GenerateEventsScheme.text=顯示 FUS 收集器方案
action.GenerateGetter.description=生成 getter
action.GenerateGetter.text=Getter
action.GenerateGetterAndSetter.description=生成 getter 和 setter
action.GenerateGetterAndSetter.text=Getter 和 Setter
action.GenerateJavadoc.description=執行 JavaDoc 工具
action.GenerateJavadoc.text=生成 JavaDoc(_D)…
action.GenerateModuleDescriptors.description=為專案中的所有模組 module-info 檔案 (適用於 Java 9 及更高版本)
action.GenerateModuleDescriptors.text=生成 module-info 檔案描述子
action.GenerateSetUpMethod.text=SetUp 方法
action.GenerateSetter.description=生成 setter
action.GenerateSetter.text=Setter
action.GenerateSuperMethodCall.description=生成 super 方法呼叫
action.GenerateSuperMethodCall.text=super 方法呼叫
action.GenerateTearDownMethod.text=TearDown 方法
action.GenerateTestDataPathFiles.text=@TestDataPath 檔案
action.GenerateTestDataPathMethods.text=@TestDataPath 方法
action.GenerateTestMethod.text=測試方法
action.GenerateVisitorByHierarchy.text=生成層次結構訪問者…
action.GenerateXmlTag.description=根據架構資訊生成新的 XML 標記
action.GenerateXmlTag.text=XML 標記…
action.GoToLastTab.description=啟用最後一個頁籤
action.GoToLastTab.text=選擇最後一個頁籤
action.GoToLinkTarget.description=在專案檢視中開啟此符號鏈接的目標
action.GoToLinkTarget.text=轉到鏈接目標
action.GoToTab.description=啟用頁籤 #{0}
action.GoToTab.text=選擇頁籤 #{0}
action.GotoAction.description=通過名稱快速導覽到動作
action.GotoAction.text=尋找動作(_F)…
action.GotoChangedFile.description=按名稱快速導覽到更改的檔案
action.GotoChangedFile.text=轉到更改的檔案…
action.GotoClass.description=通過名稱快速導覽到類別
action.GotoClass.text=轉到類別…
action.GotoCustomRegion.text=自訂折疊…
action.GotoDeclaration.MainMenu.text=宣告或用例(_D)
action.GotoDeclaration.description=導覽到文字游標處符號的宣告或顯示其用法
action.GotoDeclaration.text=前往宣告或用法
action.GotoDeclarationOnly.MainMenu.text=宣告
action.GotoDeclarationOnly.description=導覽到文字游標處符號的宣告
action.GotoDeclarationOnly.text=轉到宣告
action.GotoFile.MainMenu.text=檔案(_F)…
action.GotoFile.description=通過名稱快速導覽到檔案
action.GotoFile.text=轉到檔案…
action.GotoImplementation.MainMenu.text=實作(_M)
action.GotoImplementation.description=導覽到所選類別或方法的實作
action.GotoImplementation.text=轉到實作(_M)
action.GotoLine.MainMenu.text=行:列(_L)…
action.GotoLine.description=通過編號在編輯器中導覽到某一行(和/或列)
action.GotoLine.text=轉到行:列…
action.GotoNextBookmark.text=下一行書籤
action.GotoNextBookmarkInEditor.text=編輯器中的下一行書籤
action.GotoNextElementUnderCaretUsage.description=導覽到下一個醒目提示的元素用法
action.GotoNextElementUnderCaretUsage.text=下一個醒目提示用例
action.GotoNextError.description=在活動編輯器中導覽到下一個醒目提示的錯誤
action.GotoNextError.text=下一個醒目提示顯示錯誤(_N)
action.GotoPrevElementUnderCaretUsage.description=導覽到上一個醒目提示的元素用法
action.GotoPrevElementUnderCaretUsage.text=轉到上一個醒目提示的元素用法
action.GotoPreviousBookmark.text=上一行書籤
action.GotoPreviousBookmarkInEditor.text=編輯器中的上一行書籤
action.GotoPreviousError.description=在活動編輯器中導覽到上一個醒目提示的錯誤
action.GotoPreviousError.text=上一個醒目提示顯示錯誤(_P)
action.GotoRelated.description=導覽到一個相關或鏈接的符號
action.GotoRelated.text=相關符號(_R)…
action.GotoSuperMethod.MainMenu.text=super 方法(_U)
action.GotoSuperMethod.description=導覽到當前方法覆寫或實作的方法的宣告
action.GotoSuperMethod.text=轉到 Super 方法
action.GotoSymbol.MainMenu.text=符號(_S)…
action.GotoSymbol.description=通過名稱快速導覽到任意符號
action.GotoSymbol.text=轉到符號…
action.GotoTest.MainMenu.text=測試(_E)
action.GotoTest.description=導覽到所選類別的測試
action.GotoTest.text=轉到測試
action.GotoTest.text.subject=轉到測試主題
action.GotoTestSubject.MainMenu.text=測試物件(_E)
action.GotoTestSubject.description=導覽到所選測試的物件
action.GotoTestSubject.text=轉到測試主題(_E)
action.GotoTypeDeclaration.MainMenu.text=類型宣告(_T)
action.GotoTypeDeclaration.description=導覽到文字游標處符號類型的宣告
action.GotoTypeDeclaration.text=轉到類型宣告
action.Graph.ActualSize.text=實際尺寸
action.Graph.AlignNodes.Bottom.text=底部
action.Graph.AlignNodes.Center.text=中心
action.Graph.AlignNodes.Left.text=左側
action.Graph.AlignNodes.Middle.text=居中排列
action.Graph.AlignNodes.Right.text=右側
action.Graph.AlignNodes.Top.text=頂部
action.Graph.ApplyCurrentLayout.text=套用當前布局
action.Graph.CopyDiagramSelectionToClipboard.text=將選區複製到剪貼簿
action.Graph.CopyEntireDiagramToClipboard.text=將圖表複製到剪貼簿
action.Graph.Current.Node.Dependencies.Filter.text=顯示所選節點與相依關係
action.Graph.Delete.text=刪除選區
action.Graph.DistributeNodes.Horizontally.text=水平排列
action.Graph.DistributeNodes.Vertically.text=垂直排列
action.Graph.EdgeRealizer.ArcEdgeRealizer.text=弧形
action.Graph.EdgeRealizer.BezierEdgeRealizer.text=貝塞爾曲線
action.Graph.EdgeRealizer.QuadCurveEdgeRealizer.text=二次曲線
action.Graph.EdgeRealizer.SmoothedPolylineEdgeRealizer.text=平滑多段線
action.Graph.EdgeRealizer.SplineEdgeRealizer.text=樣條
action.Graph.EdgeRealizer.StraightPolylineEdgeRealizer.text=直多段線
action.Graph.ExportToFile.description=匯出到 PNG、JPG、GIF、SVG 或 SVGZ 檔案
action.Graph.ExportToFile.text=匯出到圖片…
action.Graph.FitContent.text=調整內容
action.Graph.Layout.ARTreeLayouter.text=緊湊
action.Graph.Layout.BalloonEdgeBundledLayouter.text=邊緣捆綁(氣球)
action.Graph.Layout.BalloonLayouter.text=氣球
action.Graph.Layout.ChannelLayouter.text=通道
action.Graph.Layout.CircularEdgeBundledLayouter.text=邊緣捆綁(圓形)
action.Graph.Layout.CircularLayouter.text=迴圈
action.Graph.Layout.CompactOrthogonalLayouter.text=緊湊
action.Graph.Layout.CustomLayouter.text=圖特定
action.Graph.Layout.FamilyLayouter.text=系列
action.Graph.Layout.Fit.Content.text=在布局後調整內容
action.Graph.Layout.GenericLayouter.text=泛型
action.Graph.Layout.HVTreeLayouter.text=寬
action.Graph.Layout.HierarchicGroupLayouter.text=層次結構組
action.Graph.Layout.HierarchicLayouter.text=分層
action.Graph.Layout.OrganicEdgeBundledLayouter.text=邊緣捆綁(有機)
action.Graph.Layout.OrganicLayouter.text=有機
action.Graph.Layout.OrthogonalGroupLayouter.text=正交群
action.Graph.Layout.RadialEdgeBundledLayouter.text=邊緣捆綁(徑向)
action.Graph.Layout.RadialLayouter.text=徑向
action.Graph.Layout.RandomLayouter.text=隨機
action.Graph.Layout.SeriesParallelLayouter.text=串並聯
action.Graph.Layout.SingleCycleLayouter.text=單迴圈
action.Graph.LayoutOrientation.BottomToTop.text=🠉 從下到上
action.Graph.LayoutOrientation.LeftToRight.text=🠊 從左到右
action.Graph.LayoutOrientation.RightToLeft.text=🠈 從右到左
action.Graph.LayoutOrientation.TopToBottom.text=🠋 從上到下
action.Graph.MergeEdges.BySources.text=按源
action.Graph.MergeEdges.ByTargets.text=按目標
action.Graph.NeighborhoodViewPopup.CompactMode.text=緊湊地顯示節點
action.Graph.NeighborhoodViewPopup.SameAsModelLayouter.text=與 Main 相同
action.Graph.RouteEdges.text=自動路由邊緣
action.Graph.Show.Bridges.text=顯示鏈接橋
action.Graph.Show.Edge.Labels.text=顯示邊緣標籤
action.Graph.ShowHideGrid.text=顯示網格
action.Graph.ShowStructureViewForSelectedNode.text=顯示所選節點的結構檢視
action.Graph.SnapToGrid.text=對齊到網格
action.Graph.ZoomIn.text=放大
action.Graph.ZoomOut.text=縮小
action.Graph.print.reset=重設
action.GrayFilterConfig.text=灰色篩選器(&G)
action.Help.JetBrainsTV.description=檢視介紹 JetBrains 產品功能的簡短現場示範。
action.Help.JetBrainsTV.templateText=YouTube 上的 {0}
action.Help.JetBrainsTV.text=YouTube 上的產品
action.Help.KeymapReference.description=開啟帶有預設按鍵映射參考卡的 PDF 檔案。
action.Help.KeymapReference.text=鍵盤快捷鍵 PDF(_K)
action.HelpTopics.description=顯示幫助內容
action.HelpTopics.text=幫助(_H)
action.HideActiveWindow.description=隱藏活動工具視窗
action.HideActiveWindow.text=隱藏活動工具視窗(_D)
action.HideAllWindows.description=隱藏所有工具視窗
action.HideAllWindows.text=隱藏所有工具視窗(_T)
action.HideSideWindows.description=隱藏本側所有視窗
action.HideSideWindows.text=隱藏本側工具視窗
action.HidpiInfo.text=顯示 HiDPI 資訊(&H)
action.HighlightUsagesInFile.description=在活動編輯器中醒目提示文字游標處符號的用法
action.HighlightUsagesInFile.not.ready=此用法搜尋需要索引，在索引建置之前無法執行
action.HighlightUsagesInFile.text=醒目提示檔案中的用法(_H)
action.HippieBackwardCompletion.description=迴圈擴展詞(向後)
action.HippieBackwardCompletion.text=迴圈擴展詞(向後)(_E)
action.HippieCompletion.description=迴圈擴展詞
action.HippieCompletion.text=迴圈擴展詞(_E)
action.Hotswap.description=將所有更改的類別重新載入到被偵錯的應用程式中 (熱插拔)
action.Hotswap.text=重新載入已更改的類別(_A)
action.IconScaleTestAction.text=顯示圖標比例測試對話框
action.IconsLoadTime.text=日誌圖標載入時間
action.IdeScriptingConsole.description=開啟 IDE 腳本主控台
action.IdeScriptingConsole.text=IDE 腳本主控台
action.ImageDuplicates.text=尋找圖片重複項
action.ImplementMethods.description=在當前類別中實作基接口/類別方法
action.ImplementMethods.text=實作方法(_I)…
action.ImportModule.description=從包含現有源的目錄或者現有專案模型匯入模組
action.ImportModule.text=來自現有源的模組…
action.ImportModuleFromImlFile.description=將 iml 檔案作為一個模組匯入到專案
action.ImportModuleFromImlFile.text=匯入模組
action.ImportProject.description=為包含現有源的目錄建立專案結構或者轉換現有專案模型
action.ImportProject.text=來自現有源的專案…
action.ImportSettings.description=匯入全域設定
action.ImportSettings.text=匯入設定…
action.ImportTestsFromFile.text=從檔案匯入測試
action.IncludeToProjectAction.text=包含到專案中
action.IncomingChanges.Refresh.description=重新整理傳入更改的列表
action.IncomingChanges.Refresh.text=重新整理
action.IncrementWindowHeight.text=增大高度
action.IncrementWindowWidth.text=增大寬度
action.IncrementalSearch.description=啟動增量搜尋(輸入時搜尋字串)，IntelliJ IDEA 6.0 實作。
action.IncrementalSearch.text=增量搜尋(_L)
action.InferNullity.description=推斷為 null 性
action.InferNullity.text=推斷為 null 性(_N)…
action.InheritanceToDelegation.description=將繼承取代為委託
action.InheritanceToDelegation.text=將繼承取代為委託(_I)…
action.Inline.description=內聯所選方法或變數
action.Inline.text=內聯(_N)…
action.InsertInlineCompletionAction.description=Insert current inline completion proposal
action.InsertInlineCompletionAction.text=Insert inline proposal
action.InsertLiveTemplate.description=顯示以指定前綴開頭的實時模板的彈出視窗列表
action.InsertLiveTemplate.text=插入實時模板(_T)…
action.InsertRubyInjection.description=在 Erb 檔案中插入 '<%= %>'
action.InsertRubyInjection.text=插入 '<%= %>'
action.InsertRubyInjectionWithoutOutput.description=在 Erb 檔案中插入 '<% %>'
action.InsertRubyInjectionWithoutOutput.text=插入 '<% %>'
action.InspectCode.description=檢查程式碼
action.InspectCode.text=檢查程式碼(_I)…
action.InspectionFilterAction.filter.by.language.text=按語言篩選
action.InspectionFilterAction.filter.inspections.text=篩選器檢查
action.IntegrateFiles.description=整合所選檔案或目錄
action.IntegrateFiles.text=整合
action.IntroduceConstant.description=將所選表達式取代為常數
action.IntroduceConstant.text=引入常數(_C)…
action.IntroduceField.description=將所選表達式的結果放入欄位中
action.IntroduceField.text=引入欄位(_F)…
action.IntroduceFunctionalParameter.description=通過呼叫新的函式方法參數來取代所選的語句
action.IntroduceFunctionalParameter.text=引入功能參數(_L)…
action.IntroduceFunctionalVariable.description=通過呼叫新的函式變數來取代所選的語句
action.IntroduceFunctionalVariable.text=引入函式變數…
action.IntroduceParameter.description=將所選表達式轉換為方法參數
action.IntroduceParameter.text=引入參數(_P)…
action.IntroduceParameterObject.description=使用物件取代方法參數列表
action.IntroduceParameterObject.text=引入參數物件(_J)…
action.IntroduceVariable.description=將所選表達式的結果放入變數中
action.IntroduceVariable.text=引入變數(_V)…
action.InvalidateCaches.description=在下次啟動時強制重新建置所有快取和索引
action.InvalidateCaches.text=清除快取…
action.InvertBoolean.description=使方法返回值或變數包含相反的值並更正參照
action.InvertBoolean.text=反轉布林值(_B)…
action.JBCefOsrMeasureFps.text=測量 OSR JCEF FPS
action.JBTabsDemo.text=JBTabs 示範
action.JShell.Console.description=啟動 JShell 主控台
action.JShell.Console.text=JShell 主控台…
action.JTabbedPaneDemo.text=JTabbedPane 示範
action.JsonCopyPointer.description=複製 JSON 指針
action.JsonCopyPointer.text=複製 JSON 指針
action.JumpToColorsAndFonts.description=跳轉到文字游標下的螢光筆的顏色選項
action.JumpToColorsAndFonts.text=跳轉到顏色和字體
action.JumpToLastChange.description=在最近的更改點中移動
action.JumpToLastChange.text=最後編輯位置(_O)
action.JumpToLastWindow.description=啟用上一個聚焦的工具視窗
action.JumpToLastWindow.text=跳轉到上一個工具視窗(_J)
action.JumpToNextChange.description=在最近的更改點中移動
action.JumpToNextChange.text=下一個編輯位置
action.KeepTabOpen.description=將預覽頁籤轉換為一般編輯器頁籤
action.KeepTabOpen.text=保持頁籤開啟
action.KeymapToCsv.text=將按鍵映射匯出到 CSV…
action.LabelSizeDemoAction.text=測試標籤大小
action.LaggingMode.text=滯後模式
action.LibrarySettings.navigate=開啟庫設定
action.LibraryUsageStatistics.text=顯示匯入的庫用法資訊
action.LightEditExitAction.text=退出(&X)
action.LightEditNewFileAction.text=新增(&N)
action.LightEditOpenFileInProjectAction.text=在專案中開啟檔案…
action.List-scrollDown.description=將周圍的可滾動區域向下滾動一頁，然後選擇相應的行。
action.List-scrollDown.text=向下滾動頁面並選擇行
action.List-scrollDownExtendSelection.description=將周圍的可滾動區域向下滾動一頁，然後將相應的行新增到選區。
action.List-scrollDownExtendSelection.text=向下滾動頁面並擴展選區
action.List-scrollUp.description=將周圍的可滾動區域向上滾動一頁，然後選擇相應的行。
action.List-scrollUp.text=向上滾動頁面並選擇行
action.List-scrollUpExtendSelection.description=將周圍的可滾動區域向上滾動一頁，然後將相應的行新增到選區。
action.List-scrollUpExtendSelection.text=向上滾動頁面並擴展選區
action.List-selectFirstRow.description=選擇第一行。
action.List-selectFirstRow.text=選擇第一行
action.List-selectFirstRowExtendSelection.description=滾動到第一行並將相應的行新增到選區。
action.List-selectFirstRowExtendSelection.text=將選區擴展到第一行
action.List-selectLastRow.description=選擇最後一行。
action.List-selectLastRow.text=選擇最後一行
action.List-selectLastRowExtendSelection.description=滾動到最後一行並將相應的行新增到選區。
action.List-selectLastRowExtendSelection.text=將選區擴展到最後一行
action.List-selectNextColumn.description=選擇下一列。
action.List-selectNextColumn.text=選擇下一列
action.List-selectNextColumnExtendSelection.description=將下一列新增到選區。
action.List-selectNextColumnExtendSelection.text=將選區擴展到下一列
action.List-selectNextRow.description=選擇下一行。
action.List-selectNextRow.text=選擇下一行
action.List-selectNextRowExtendSelection.description=將下一行新增到選區。
action.List-selectNextRowExtendSelection.text=將選區擴展到下一行
action.List-selectPreviousColumn.description=選擇上一列。
action.List-selectPreviousColumn.text=選擇上一列
action.List-selectPreviousColumnExtendSelection.description=將上一列新增到選區。
action.List-selectPreviousColumnExtendSelection.text=將選區擴展到上一列
action.List-selectPreviousRow.description=選擇上一行。
action.List-selectPreviousRow.text=選擇上一行
action.List-selectPreviousRowExtendSelection.description=將上一行新增到選區。
action.List-selectPreviousRowExtendSelection.text=將選區擴展到上一行
action.ListPersistentStateComponents.text=列出持久狀態組件
action.LoadAllContent.text=載入所有檔案內容
action.LoadAllVFSContent.text=載入所有 VFS 存儲的檔案內容
action.LoadDefaultYamlProfile.text=從 YAML 載入檢查組態檔案
action.LoadUnloadModules.text=載入/移除模組…
action.LocalChangesView.ShowOnDoubleClick.EditorPreview.ToolwindowPopup.text=差異
action.LocalChangesView.ShowOnDoubleClick.EditorPreview.text=雙擊時顯示差異
action.LocalChangesView.ShowOnDoubleClick.Source.ToolwindowPopup.text=源
action.LocalChangesView.ShowOnDoubleClick.Source.text=雙擊時顯示源
action.LocalHistory.PutLabel.text=放置標籤(_L)…
action.LocalHistory.ShowHistory.GoToAction.text=顯示本地歷史記錄…
action.LocalHistory.ShowHistory.Vcs.Toolbar.Widget.text=本地歷史記錄…
action.LocalHistory.ShowHistory.text=顯示歷史記錄(_H)…
action.LocalHistory.ShowSelectionHistory.GoToAction.text=顯示選區的本地歷史記錄…
action.LocalHistory.ShowSelectionHistory.text=顯示選區的歷史記錄…
action.LogDebugConfigure.description=啟用或停用額外的日誌類別。允許通過請求向支援團隊提供更多資訊。
action.LogDebugConfigure.text=偵錯日誌設定(_E)…
action.LogFocusRequests.text=日誌焦點請求
action.LogTraceScenarios.text=選擇追蹤方案
action.MacMessagesTest.text=測試 Mac 訊息
action.MainMenuAsSeparateToolbarAction.text=主選單作為單獨的工具列
action.MainMenuButton.ShowMenu.text=顯示折疊的主選單
action.MaintenanceAction.text=維護
action.MakeModule.description=編譯模組中的所有修改和相依檔案
action.MakeModule.text=建置模組(_M)
action.MakeStatic.description=將方法或內部類別轉換為 static 並更正所有參照
action.MakeStatic.text=設為 static(_T)…
action.ManageProjectTemplates.text=管理專案模板…
action.ManageRecentProjects.text=管理專案…
action.MarkAsContentRoot.description=取消所選目錄的排除，使其檔案可以被 IDE 的動作處理
action.MarkAsContentRoot.text=不排除
action.MarkExcludeRoot.text=已排除
action.MarkFileDirty.text=在 VCS 中將檔案標記為髒
action.MarkVfsCorrupted.text=將 VFS 標記為已損壞
action.MaximizeActiveDialog.text=最大化/還原活動對話框
action.MeetNewUIAction.text=認識新 UI
action.MemberPushDown.description=將類別成員向下推送到直接繼承子類別
action.MemberPushDown.text=向下推送成員(_S)…
action.MembersPullUp.description=將類別成員拉取至超類別或實作的接口
action.MembersPullUp.text=向上拉取成員(_L)…
action.Memory.CalculateRetainedSize.text=計算保留大小…
action.MemoryView.EnableTrackingWithClosedWindow.text=啟用具有隱藏記憶體檢視的追蹤
action.MemoryView.JumpToTypeSource.text=跳轉到類型源
action.MemoryView.ShowAllocationStackTrace.text=跳轉到分配位置
action.MemoryView.ShowInstances.text=顯示實例
action.MemoryView.ShowInstancesFromDebuggerTree.text=顯示實例
action.MemoryView.ShowNewInstances.text=顯示新實例
action.MemoryView.ShowOnlyTracked.text=僅顯示追蹤類別
action.MemoryView.ShowOnlyWithDiff.text=僅顯示非零差異
action.MemoryView.ShowOnlyWithInstances.text=僅顯示實例
action.MemoryView.SwitchUpdateMode.description=在偵錯器暫停時載入類別 (可能會增加偵錯器步進的開銷)
action.MemoryView.SwitchUpdateMode.text=在偵錯器停止時更新已載入的類別
action.MemoryView.TrackingAction.NewInstancesTracking.text=追蹤新實例
action.Merge3Files.text=合併
action.MergeAllWindowsAction.text=合併所有專案視窗
action.MethodDown.description=在活動編輯器中導覽到下一個方法
action.MethodDown.text=下一個方法(_E)
action.MethodDuplicates.description=尋找所選作用域內可以轉換為所選方法/常數的呼叫的程式碼
action.MethodDuplicates.field.text=尋找欄位重複項並取代為參照…
action.MethodDuplicates.method.text=尋找方法重複項並取代為呼叫…
action.MethodDuplicates.text=尋找並取代程式碼重複項(_C)…
action.MethodHierarchy.BaseOnThisMethod.text=基於此方法
action.MethodHierarchy.ImplementMethodAction.description=實作方法(從方法層次結構)
action.MethodHierarchy.ImplementMethodAction.text=實作方法
action.MethodHierarchy.OverrideMethodAction.description=覆寫方法(從方法層次結構)
action.MethodHierarchy.OverrideMethodAction.text=覆寫方法
action.MethodHierarchy.description=瀏覽所選方法的方法層次結構
action.MethodHierarchy.text=方法層次結構(_M)
action.MethodOverloadSwitchDown.text=下一個方法多載
action.MethodOverloadSwitchUp.text=上一個方法多載
action.MethodUp.description=在活動編輯器中導覽到上一個方法
action.MethodUp.text=上一個方法(_I)
action.MinimizeCurrentWindow.description=最小化當前視窗
action.MinimizeCurrentWindow.text=最小化
action.ModuleSettings.description=為所選模組開啟設定對話框
action.ModuleSettings.navigate=開啟模組設定
action.ModuleSettings.text=模組設定(_S)
action.Move.description=將選中類別、方法、包或 static 成員移至另一個軟體套件或類別，並更正所有參照
action.Move.text=移動(_M)…
action.MoveEditorToOppositeTabGroup.description=將編輯器移至相反的頁籤組
action.MoveEditorToOppositeTabGroup.text=移至相反的組(_M)
action.MoveElementLeft.description=將當前元素移至包含元素列表的上一個位置
action.MoveElementLeft.text=向左移動元素
action.MoveElementRight.description=將當前元素移至包含元素列表的下一個位置
action.MoveElementRight.text=向右移動元素
action.MoveLineDown.description=將所選行向下移動一行
action.MoveLineDown.text=下移行(_W)
action.MoveLineUp.description=將所選行向上移動一行
action.MoveLineUp.text=上移行(_U)
action.MoveStatementDown.description=將所選語句向下移動一行
action.MoveStatementDown.text=向下移動語句(_W)
action.MoveStatementUp.description=將所選語句向上移動一行
action.MoveStatementUp.text=向上移動語句(_U)
action.MoveTabDown.description=將編輯器區域拆分為 2 個頁籤組，然後將當前頁籤移至底部組並關閉頂部編輯器
action.MoveTabDown.text=拆分並下移
action.MoveTabRight.description=將編輯器區域拆分為 2 個頁籤組，然後將當前頁籤移至右側組並關閉左側編輯器
action.MoveTabRight.text=拆分並右移
action.NavBar-cancel.text=關閉浮動導覽列
action.NavBar-navigate.text=從選定項導覽
action.NavBar-return.text=對選定項執行動作
action.NavBar-selectDown.text=開啟相應的彈出選單
action.NavBar-selectEnd.text=選擇最後一項
action.NavBar-selectHome.text=選擇第一項
action.NavBar-selectLeft.text=選擇上一項
action.NavBar-selectRight.text=選擇下一項
action.NavBar-selectUp.text=開啟相應的彈出選單
action.NavBarLocationBottom.description=在狀態列中顯示導覽列
action.NavBarLocationBottom.text=在狀態列中
action.NavBarLocationHide.description=隱藏導覽列
action.NavBarLocationHide.text=不顯示
action.NavBarLocationTop.description=在頂部顯示導覽列
action.NavBarLocationTop.text=頂部
action.NewClass.text=Java 類別
action.NewDatabaseProject.text=專案…
action.NewDir.text=目錄/軟體套件
action.NewDirectoryProject.cannot.create.dir=無法建立目錄 ''{0}''。
action.NewDirectoryProject.description=建立一個新項目
action.NewDirectoryProject.not.empty.dialog.create.new=從現有的源建立
action.NewDirectoryProject.not.empty.dialog.open.existing=開啟專案
action.NewDirectoryProject.not.empty.dialog.text=目錄 ''{0}'' 不為空。是否要從現有的源建立專案?
action.NewDirectoryProject.not.empty.dialog.title=目錄不為空
action.NewDirectoryProject.text=新增專案…
action.NewDirectoryProject.title=建立專案
action.NewDummyProject.text=新增虛擬專案
action.NewElement.description=建立新的類別、接口、檔案或目錄
action.NewElement.text=新增(_N)…
action.NewElementSamePlace.description=在此目錄中建立新的類別、接口、檔案或目錄
action.NewElementSamePlace.text=在當前目錄新增(_N)…
action.NewFile.text=檔案
action.NewMigration.text=建立新遷移…
action.NewModule.description=從頭建立新模組並將其新增到專案
action.NewModule.text=模組(_M)…
action.NewModuleInGroup.text=模組
action.NewProject.ProjectWidgetPopup.text=新增專案…
action.NewProject.description=從頭建立一個新項目
action.NewProject.text=專案(_P)…
action.NewRubyMineDirectoryProject.ProjectWidgetPopup.text=新增專案…
action.NewRubyMineDirectoryProject.text=專案…
action.NewScratchBuffer.description=建立新的臨時緩衝區或重用現有的臨時緩衝區
action.NewScratchBuffer.text=新增臨時緩衝區
action.NewScratchFile.description=與所選語言建立新的臨時檔案
action.NewScratchFile.text=臨時檔案
action.NewScratchFile.text.with.new=新增臨時檔案
action.NewUiRunWidget.text=執行小工具
action.NextDiff.description=移至下一個差異
action.NextDiff.text=下一個差異
action.NextEditorTab.text=在多編輯器檔案中選擇下一個頁籤
action.NextOccurence.description=導覽到下一個符合項
action.NextOccurence.text=下一個符合項(_X)
action.NextParameter.text=下一個參數
action.NextProjectWindow.description=切換到下一個專案視窗
action.NextProjectWindow.text=下一個專案視窗
action.NextSplitter.description=轉到下一個拆分視窗
action.NextSplitter.text=轉到下一個拆分器(_G)
action.NextTab.description=啟用下一個頁籤
action.NextTab.text=選擇下一個頁籤(_X)
action.NextTemplateParameter.text=下一個實時模板參數
action.NextTemplateVariable.text=下一個模板變數或完成就地重構
action.NextWindow.text=啟用下一個視窗
action.NotificationTestAction.text=新增測試通知
action.OnlineDocAction.description=顯示在線文檔
action.OnlineDocAction.text=入門指南(_G)
action.OpenBlankEditorInBlankDiffWindow.text=切換到空白編輯器
action.OpenBookmarkGroup.text=開啟所有已新增書籤的檔案
action.OpenEditorInOppositeTabGroup.description=在相反的頁籤組中開啟此編輯器的副本
action.OpenEditorInOppositeTabGroup.text=在相反的組中開啟(_O)
action.OpenElementInNewWindow.text=在新編輯器視窗中開啟
action.OpenFile.description=在編輯器中開啟專案或檔案
action.OpenFile.text=開啟(_O)…
action.OpenFileEditorInBlankDiffWindow.text=切換到檔案…
action.OpenInBrowser.description=在預設瀏覽器中開啟所選檔案
action.OpenInBrowser.text=在預設瀏覽器中開啟(_B)
action.OpenInRightSplit.description=將編輯器區域拆分為 2 個頁籤組，然後將當前檔案開啟到右側組
action.OpenInRightSplit.text=在右側拆分部分開啟
action.OpenLog.text=在編輯器中開啟日誌
action.OpenModuleSettings.text=模組設定
action.OpenMouseWheelSmoothScrollSettings.text=平滑滾動選項
action.OpenStatisticsEventLogAction.description=開啟包含統計事件日誌的工具視窗
action.OpenStatisticsEventLogAction.text=開啟統計事件日誌
action.OptimizeImports.description=移除未使用的 import 並重新排列/重新組織 import
action.OptimizeImports.text=最佳化 import(_Z)
action.OverrideFileTypeAction.description=將當前檔案視為不同檔案類型的檔案
action.OverrideFileTypeAction.text=覆寫檔案類型
action.OverrideFileTypeAction.verbose.description=將檔案 ''{0}''{1,choice,0#|1# ( 和其他 {1} 個檔案)}視為具有不同檔案類型的檔案
action.OverrideMethods.description=在當前類別中覆寫基類別方法
action.OverrideMethods.text=覆寫方法(_O)…
action.ParameterInfo.description=顯示文字游標處方法的參數
action.ParameterInfo.text=參數資訊(_P)
action.PasteMultiple.description=從最近的剪貼簿貼上
action.PasteMultiple.text=從歷史記錄貼上(_E)…
action.Pause.description=掛起程序執行並啟用偵錯
action.Pause.text=暫停程序(_P)
action.PerformGC.text=執行垃圾回收
action.Performance.ActivityMonitor.description=用於檢查哪些延伸模組和子系統消耗大多數資源的工具
action.Performance.ActivityMonitor.text=活動監視器…
action.Performance.DumpThreads.text=傾印執行緒
action.Performance.MemTester.text=執行記憶體測試程序…
action.PinActiveEditorTab.description=固定活動編輯器頁籤
action.PinActiveEditorTab.text=固定活動頁籤(_I)
action.PinActiveTab.description=固定活動編輯器或工具視窗頁籤
action.PinActiveTab.text=固定活動頁籤(_I)
action.PinActiveTabToggle.description=固定活動編輯器或工具視窗頁籤
action.PinActiveTabToggle.text=固定活動頁籤
action.PinToolwindowTab.description=固定活動工具視窗頁籤
action.PinToolwindowTab.text=固定活動工具視窗頁籤(_I)
action.PlaySavedMacrosAction.description=播放儲存的巨集
action.PlaySavedMacrosAction.text=播放儲存的巨集…
action.PlaybackLastMacro.description=播放上次使用的巨集
action.PlaybackLastMacro.text=回放上一個巨集(_Y)
action.PluginManagerFiltersConfigureResetTrustDebugAction.text=Org 延伸模組篩選器: 重設
action.PluginManagerFiltersConfigureTrustOnlyJetBrainsDebugAction.text=Org 延伸模組篩選器: 僅信任 JetBrains
action.PopupHector.description=顯示面板來為當前檔案組態醒目提示模式
action.PopupHector.text=組態當前檔案分析…
action.PopupMenu-cancel.description=關閉右鍵選單。
action.PopupMenu-cancel.text=關閉右鍵選單
action.PopupMenu-return.description=開啟子選單或從選定的選單項中呼叫動作。
action.PopupMenu-return.text=呼叫選定動作
action.PopupMenu-selectChild.description=開啟子選單並在其中選擇相應的項。
action.PopupMenu-selectChild.text=選擇子選單項
action.PopupMenu-selectNext.description=選擇下一個選單項。
action.PopupMenu-selectNext.text=選擇下一個選單項
action.PopupMenu-selectParent.description=關閉子選單並在父選單中選擇相應的項。
action.PopupMenu-selectParent.text=選擇父選單項
action.PopupMenu-selectPrevious.description=選擇上一個選單項。
action.PopupMenu-selectPrevious.text=選擇上一個選單項
action.PositionTrackerTestAction.text=測試位置追蹤器
action.PrevParameter.text=上一個參數
action.PrevSplitter.description=轉到上一個拆分視窗
action.PrevSplitter.text=轉到上一個拆分器
action.PrevTemplateParameter.text=上一個實時模板參數
action.PreviousDiff.description=移至上一個差異
action.PreviousDiff.text=上一個差異
action.PreviousEditorTab.text=在多編輯器檔案中選擇上一個頁籤
action.PreviousOccurence.description=導覽到上一個符合項
action.PreviousOccurence.text=上一個符合項(_O)
action.PreviousProjectWindow.description=切換到上一個專案視窗
action.PreviousProjectWindow.text=上一個專案視窗
action.PreviousTab.description=啟用上一個頁籤
action.PreviousTab.text=選擇上一個頁籤(_L)
action.PreviousTemplateVariable.text=上一個模板變數
action.PreviousWindow.text=啟用上一個視窗
action.Print.description=列印檔案
action.Print.text=列印(_P)…
action.ProblemsView.AutoscrollToSource.description=為所選檔案開啟編輯器，並在更改選擇後導覽到選定問題
action.ProblemsView.AutoscrollToSource.text=一鍵開啟檔案
action.ProblemsView.CopyProblemDescription.description=將問題描述複製到剪貼簿
action.ProblemsView.CopyProblemDescription.text=複製問題描述
action.ProblemsView.GroupByToolId.description=允許按檢查對問題分組
action.ProblemsView.GroupByToolId.text=按檢查分組
action.ProblemsView.OpenInPreviewTab.text=啟用預覽頁籤
action.ProblemsView.QuickFixes.description=顯示所選問題的可用快速修復
action.ProblemsView.QuickFixes.text=顯示快速修復
action.ProblemsView.ShowPreview.description=Click a selected problem to open a preview for it
action.ProblemsView.ShowPreview.text=開啟編輯器預覽
action.ProblemsView.SortByName.description=允許按名稱對問題進行排序
action.ProblemsView.SortByName.text=名稱
action.ProblemsView.SortBySeverity.description=允許按嚴重性對問題進行排序
action.ProblemsView.SortBySeverity.text=嚴重性
action.ProblemsView.SortFoldersFirst.description=單獨對檔案和目錄排序
action.ProblemsView.SortFoldersFirst.text=目錄總在最前面
action.ProductivityGuide.description=顯示工作效率功能使用統計
action.ProductivityGuide.text=我的工作效率(_P)
action.Profiler.ExcludeCallAction.text=排除呼叫
action.Profiler.ExcludeSubTreeAction.text=排除子樹
action.Profiler.FocusOnCallAction.text=聚焦於呼叫
action.Profiler.FocusOnSubtreeAction.description=在新頁籤中開啟選定的子樹
action.Profiler.FocusOnSubtreeAction.text=聚焦於子樹
action.Profiler.OpenBackTracesAction.description=在新頁籤中開啟選定的方法回溯樹
action.Profiler.OpenBackTracesAction.text=方法回溯
action.Profiler.OpenMergedCalleesAction.description=在新頁籤中開啟選定的方法合並被呼叫方樹
action.Profiler.OpenMergedCalleesAction.text=方法合並被呼叫方
action.ProgressIconShowcaseAction.text=進度圖標展示
action.ProjectFromVersionControl.ProjectWidgetPopup.text=從版本控制中獲取…
action.ProjectFromVersionControl.text=來自版本控制的專案…
action.ProjectView.AbbreviatePackageNames.description=以簡短形式顯示限定軟體套件名稱
action.ProjectView.AbbreviatePackageNames.text=縮寫限定軟體套件名稱
action.ProjectView.AutoscrollFromSource.description=選擇編輯器頁籤時，在專案檢視中選擇相應的檔案
action.ProjectView.AutoscrollFromSource.text=始終選擇開啟的檔案
action.ProjectView.AutoscrollToSource.description=選擇檔案後，將其開啟進行編輯
action.ProjectView.AutoscrollToSource.text=一鍵開啟檔案
action.ProjectView.CompactDirectories.description=如果第一個目錄僅包含第二個目錄，則將兩個類似的目錄合併到單個節點中
action.ProjectView.CompactDirectories.text=壓縮目錄
action.ProjectView.FileNesting.description=組態檔案嵌套
action.ProjectView.FileNesting.text=檔案嵌套…
action.ProjectView.FlattenModules.description=以簡單列表顯示模組
action.ProjectView.FlattenModules.text=平展模組
action.ProjectView.FlattenPackages.description=以簡單列表顯示包
action.ProjectView.FlattenPackages.text=平展軟體套件
action.ProjectView.FoldersAlwaysOnTop.description=單獨對檔案和目錄排序
action.ProjectView.FoldersAlwaysOnTop.text=目錄總在最前
action.ProjectView.HideEmptyMiddlePackages.description=隱藏空的中間軟體套件
action.ProjectView.HideEmptyMiddlePackages.text=隱藏空的中間軟體套件
action.ProjectView.ManualOrder.description=手動對檔案排序
action.ProjectView.ManualOrder.text=手動排序
action.ProjectView.OpenDirectoriesWithSingleClick.text=一鍵開啟目錄
action.ProjectView.OpenInPreviewTab.text=啟用預覽頁籤
action.ProjectView.ShowExcludedFiles.description=顯示排除的檔案
action.ProjectView.ShowExcludedFiles.text=顯示排除的檔案
action.ProjectView.ShowLibraryContents.description=顯示庫內容
action.ProjectView.ShowLibraryContents.text=顯示庫內容
action.ProjectView.ShowMembers.description=顯示類別成員
action.ProjectView.ShowMembers.text=顯示成員
action.ProjectView.ShowModules.description=顯示相應根的模組名稱
action.ProjectView.ShowModules.text=顯示模組
action.ProjectView.ShowScratchesAndConsoles.description=顯示臨時檔案和主控台
action.ProjectView.ShowScratchesAndConsoles.text=顯示臨時檔案和主控台
action.ProjectView.ShowVisibilityIcons.description=在元素名稱之前顯示其可見性的圖標
action.ProjectView.ShowVisibilityIcons.text=顯示可見性圖標
action.ProjectView.SortByName.description=Sort files by their name
action.ProjectView.SortByName.text=按名稱排序
action.ProjectView.SortByTimeAscending.description=按最後修改時間對檔案進行排序，從舊到新
action.ProjectView.SortByTimeAscending.text=按修改時間排序(從舊到新)
action.ProjectView.SortByTimeDescending.description=按最後修改時間對檔案進行排序，從新到舊
action.ProjectView.SortByTimeDescending.text=按修改時間排序(從新到舊)
action.ProjectView.SortByType.description=單獨對不同類型的檔案排序
action.ProjectView.SortByType.text=按類型排序
action.ProjectViewEditSource.text=編輯源
action.PruneEmptyDirectories.text=刪除空目錄
action.QuickActionPopup.text=顯示快速動作彈出視窗
action.QuickChangeScheme.description=更改當前的程式碼樣式方案、顏色與字體方案、按鍵映射或外觀
action.QuickChangeScheme.text=快速切換方案(_Q)…
action.QuickDocCopy.text=複製快速文檔
action.QuickEvaluateExpression.description=對所選表達式求值
action.QuickEvaluateExpression.text=對表達式快速求值(_Q)
action.QuickImplementations.description=顯示包含符號(及其實作)內容的彈出視窗
action.QuickImplementations.text=快速定義(_K)
action.QuickJavaDoc.description=顯示包含文字游標處符號的文檔的彈出視窗
action.QuickJavaDoc.text=快速文檔(_D)
action.QuickPreview.text=快速預覽
action.QuickTypeDefinition.description=顯示包含文字游標處符號的類型定義的彈出視窗
action.QuickTypeDefinition.text=快速類型定義
action.RearrangeCode.description=重新排列程式碼
action.RearrangeCode.text=重新排列程式碼
action.RecentChangedFiles.description=顯示最近更改檔案的列表
action.RecentChangedFiles.text=最近更改的檔案
action.RecentChanges.text=最近的更改(_E)
action.RecentFiles.description=顯示最近檢視檔案的列表
action.RecentFiles.text=最近的檔案(_N)
action.RecentLocations.description=顯示最近檢視/更改的位置列表
action.RecentLocations.text=最近的位置
action.RecordStateCollectors.description=將所有狀態收集器和記錄結果呼叫到事件日誌
action.RecordStateCollectors.text=將狀態收集器記錄到事件日誌
action.RedesignedRunConfigurationSelector.text=選擇執行/偵錯組態
action.Refactorings.QuickListPopupAction.description=包含重構動作列表的上下文感知彈出視窗
action.Refactorings.QuickListPopupAction.text=重構此…
action.ReformatCode.description=重新格式化程式碼
action.ReformatCode.synonym1=格式程式碼
action.ReformatCode.text=重新格式化程式碼(_R)
action.Refresh.text=重新整理(_E)
action.Register.description=輸入註冊資料
action.Register.text=註冊(_R)…
action.ReloadProjectAction.text=重新載入專案
action.RemoveFromScopeAction.text=從作用域中移除
action.RemoveStripeButton.description=從側邊列移除工具視窗按鈕
action.RemoveStripeButton.text=從側邊列中移除
action.RenameAction.text=重新命名…
action.RenameElement.description=重新命名所選符號並更正所有參照
action.RenameElement.text=重新命名(_R)…
action.RenameFile.description=重新命名所選檔案
action.RenameFile.text=重新命名檔案…
action.ReopenClosedTabAction.text=重新開啟關閉的頁籤
action.Replace.description=使用另一個字串取代活動編輯器中的字串
action.Replace.text=取代(_R)…
action.ReplaceInPath.description=在多個檔案中使用另一個字串取代一個字串
action.ReplaceInPath.synonym1=在路徑中取代(_A)
action.ReplaceInPath.text=在檔案中取代(_A)…
action.ReplaceMethodWithMethodObject.description=將方法轉換為自己的物件，以便所有參數都成為該物件上的欄位
action.ReplaceMethodWithMethodObject.text=將方法取代為方法物件(_J)…
action.ReportProblem.description=在 JetBrains 問題追蹤器中提交錯誤報告
action.ReportProblem.text=提交錯誤報告…
action.ReportSettingsToFUS.text=將更改的設定記錄到事件日誌
action.Rerun.text=重新執行
action.RerunFailedTests.description=僅執行上次執行後失敗/崩潰的測試；按 Shift 鍵選擇“執行/偵錯”模式
action.RerunFailedTests.text=重新執行失敗的測試
action.RerunTests.text=重新執行測試
action.ResetFilterAction.text=重設篩選器
action.ResetGotItTooltips.text=重設“知道了”工具提示
action.ResetIdeScaleAction.text=重設 IDE 比例
action.ResetWindowsDefenderNotification.text=重設 Microsoft Defender 通知
action.ResizeToolWindowDown.description=將活動工具視窗延伸至底部
action.ResizeToolWindowDown.text=延伸至底部
action.ResizeToolWindowLeft.description=將活動工具視窗延伸至左側
action.ResizeToolWindowLeft.text=延伸至左側
action.ResizeToolWindowMaximize.text=最大化工具視窗
action.ResizeToolWindowMaximize.text.alternative=還原工具視窗大小
action.ResizeToolWindowRight.description=將活動工具視窗延伸至右側
action.ResizeToolWindowRight.text=延伸至右側
action.ResizeToolWindowUp.description=將活動工具視窗延伸至頂部
action.ResizeToolWindowUp.text=延伸至頂部
action.RestartIde.text=重啟 IDE…
action.RestoreDefaultExtensionScripts.description=重設此目錄的捆綁擴展
action.RestoreDefaultExtensionScripts.text=重設預設擴展
action.RestoreDefaultLayout.description=還原當前所選布局
action.RestoreDefaultLayout.text=還原當前布局(_C)
action.RestoreDefaultSettings.description=將所有設定重設為其預設值
action.RestoreDefaultSettings.text=還原為預設設定…
action.RestoreFontPreviewTextAction.text=還原預覽文本
action.RestoreNamedLayout.description=還原布局“{0}”
action.RestoreShelvedChange.text=還原
action.Resume.description=恢復程序執行
action.Resume.text=恢復程序(_G)
action.RetypeFile.text=重新輸入當前檔案
action.RevealIn.description=在平台的檔案管理器中醒目提示檔案
action.RevealIn.name.mac=在“訪達”中顯示
action.RevealIn.name.other=在 {0} 中顯示
action.ReverteOverrideFileTypeAction.description=撤消“覆寫檔案類型”動作並還原舊檔案類型
action.ReverteOverrideFileTypeAction.text=還原檔案類型覆寫
action.ReverteOverrideFileTypeAction.verbose.description=撤消“覆寫檔案類型”動作並為檔案 ''{0}''{1,choice,0#|1# (和其他 {1} 個檔案)}還原舊的檔案類型
action.RubyMineDemos.description=檢視介紹 RubyMine 功能的簡短現場示範
action.RubyMineDemos.text=示範和教程
action.RubyMineDeveloperCommunity.description=RubyMine 開發者社區論壇
action.RubyMineDeveloperCommunity.text=開發者社區
action.RubyMineProjectFromVersionControlAction.ProjectWidgetPopup.text=從版本控制中獲取…
action.RubyMineProjectFromVersionControlAction.text=來自版本控制的專案…
action.RulerGuide.text=標尺參考線
action.RunAnything.description=允許執行任何指令
action.RunAnything.text=執行任何內容
action.RunConfiguration.description=選擇執行/偵錯組態
action.RunConfiguration.text=選擇執行/偵錯組態
action.RunConfigurationTemplatesForNewProjects.MainMenu.text=執行組態模板…
action.RunDashboard.AddType.text=執行組態類型
action.RunDashboard.ClearContent.text=清除內容
action.RunDashboard.CopyConfiguration.text=複製組態
action.RunDashboard.Debug.text=偵錯
action.RunDashboard.EditConfiguration.text=編輯所選組態
action.RunDashboard.GroupByStatus.text=狀態
action.RunDashboard.GroupByType.text=類型
action.RunDashboard.GroupConfigurations.text=分組組態
action.RunDashboard.HideConfiguration.text=隱藏組態
action.RunDashboard.OpenRunningConfigInNewTab.text=在新頁籤中開啟執行組態
action.RunDashboard.RemoveType.text=從服務中移除組態類型
action.RunDashboard.RestoreConfiguration.text=還原組態
action.RunDashboard.RestoreHiddenConfigurations.text=還原隱藏的組態
action.RunDashboard.Run.text=執行
action.RunDashboard.Stop.text=停止
action.RunDashboard.UngroupConfigurations.text=對組態取消分組
action.RunToCursor.description=跳轉到文字游標所在的行
action.RunToCursor.text=執行到游標處(_C)
action.RunToolbarEditConfigurationAction.text=編輯組態…
action.RunToolbarHotSwapAction.text=熱交換
action.RunToolbarMainMultipleStopAction.text=停止
action.RunToolbarMainRunConfigurationsAction.text=新增組態…
action.RunToolbarMainSlotActive.text=有效程序
action.RunToolbarMainSlotInfoAction.text=有效程序
action.RunToolbarMoveToTopAction.text=將組態移至頂部
action.RunToolbarPauseAction.text=暫停
action.RunToolbarProcessStartedAction.text=有效程序
action.RunToolbarRemoveSlotAction.terminating=正在終止
action.RunToolbarRemoveSlotAction.text=移除
action.RunToolbarRerunAction.text=重新執行
action.RunToolbarResumeAction.text=恢復
action.RunToolbarRollbackToPrevious.text=回滾到上一個工具列
action.RunToolbarRunConfigurationsAction.text=新增組態…
action.RunToolbarShowHidePopupAction.click.to.open.combo.text=點擊以選擇執行組態
action.RunToolbarShowHidePopupAction.click.to.open.toolwindow.text=點擊以開啟“程序”工具視窗
action.RunToolbarShowHidePopupAction.click.to.show.popup.text=點擊以顯示或隱藏停靠的組態
action.RunToolbarShowHidePopupAction.show.popup.text=顯示或隱藏停靠的組態
action.RunToolbarShowHidePopupAction.text=同時啟動多個組態
action.RunToolbarShowToolWindowTab.text=顯示“程序”工具視窗
action.RunToolbarStopAction.text=停止
action.RunToolbarWidgetAction.text=執行/偵錯小工具
action.Runner.CloseAllUnpinnedViews.description=關閉所有未固定的頁籤
action.Runner.CloseAllUnpinnedViews.text=關閉所有未固定的
action.Runner.CloseAllViews.description=關閉所有檢視
action.Runner.CloseAllViews.text=關閉所有
action.Runner.CloseOtherViews.description=關閉其他檢視
action.Runner.CloseOtherViews.text=關閉其他
action.Runner.CloseView.description=關閉檢視
action.Runner.CloseView.text=關閉
action.Runner.FocusOnStartup.description=當 UI 顯示時預設切換到該檢視
action.Runner.FocusOnStartup.text=在啟動時獲取焦點
action.Runner.RestoreLayout.description=將偵錯器會話的可視元素還原為預設狀態
action.Runner.RestoreLayout.text=還原為預設布局
action.Runner.ToggleTabLabels.text=顯示頁籤標籤
action.SafeDelete.description=刪除所選類別、方法或欄位，並檢查使用
action.SafeDelete.text=安全刪除(_D)…
action.SaveAll.description=儲存所有檔案和設定
action.SaveAll.text=全部儲存(_S)
action.SaveAs.text=另存為…
action.SaveAsNewFormat.text=另存為基於目錄的格式…
action.SaveAsTemplate.description=將所選文本儲存為實時模板
action.SaveAsTemplate.text=儲存為實時模板(_I)…
action.SaveDocument.description=只儲存在當前編輯器中開啟的檔案
action.SaveDocument.text=儲存文檔
action.SaveFileAsTemplate.description=將當前檔案另存為模板
action.SaveFileAsTemplate.text=將檔案另存為模板(_L)…
action.SaveProjectAsTemplate.text=將專案另存為模板…
action.ScanSourceCommentsAction.text=傾印專案中的所有註釋
action.ScopeView.EditScopes.description=編輯作用域…
action.ScopeView.EditScopes.text=編輯作用域(_I)…
action.Scratch.ChangeLanguage.description=更改臨時檔案語言
action.Scratch.ChangeLanguage.text=更改檔案語言
action.Scratch.ExportToScratch.description=作為文本匯出到新的臨時檔案
action.Scratch.ExportToScratch.text=匯出到臨時檔案
action.Scratch.ShowFilesPopup.description=在彈出視窗中顯示臨時檔案
action.Scratch.ShowFilesPopup.text=顯示臨時檔案
action.ScrollPane-scrollDown.description=將周圍的可滾動區域向下滾動一頁。
action.ScrollPane-scrollDown.text=向下滾動頁面
action.ScrollPane-scrollEnd.description=將周圍的可滾動區域滾動到底部。
action.ScrollPane-scrollEnd.text=滾動至頁尾
action.ScrollPane-scrollHome.description=將周圍的可滾動區域滾動到頂部。
action.ScrollPane-scrollHome.text=滾動至頁首
action.ScrollPane-scrollLeft.description=將周圍的可滾動區域向左滾動一頁。
action.ScrollPane-scrollLeft.text=向左滾動頁面
action.ScrollPane-scrollRight.description=將周圍的可滾動區域向右滾動一頁。
action.ScrollPane-scrollRight.text=向右滾動頁面
action.ScrollPane-scrollUp.description=將周圍的可滾動區域向上滾動一頁。
action.ScrollPane-scrollUp.text=向上滾動頁面
action.ScrollPane-unitScrollDown.description=將周圍的可滾動區域向下滾動一個單位。
action.ScrollPane-unitScrollDown.text=向下滾動
action.ScrollPane-unitScrollLeft.description=將周圍的可滾動區域向左滾動一個單位。
action.ScrollPane-unitScrollLeft.text=向左滾動
action.ScrollPane-unitScrollRight.description=將周圍的可滾動區域向右滾動一個單位。
action.ScrollPane-unitScrollRight.text=向右滾動
action.ScrollPane-unitScrollUp.description=將周圍的可滾動區域向上滾動一個單位。
action.ScrollPane-unitScrollUp.text=向上滾動
action.ScrollTreeToCenter.text=滾動到中心
action.SearchEverywhere.CompleteCommand.description=在 Search Everywhere 對話框中自動補全指令
action.SearchEverywhere.CompleteCommand.text=補全指令
action.SearchEverywhere.NavigateToNextGroup.description=在 Search Everywhere 對話框中導覽到下一個組
action.SearchEverywhere.NavigateToNextGroup.text=下一個組元素
action.SearchEverywhere.NavigateToPrevGroup.description=在 Search Everywhere 對話框中導覽到上一個組
action.SearchEverywhere.NavigateToPrevGroup.text=上一個組元素
action.SearchEverywhere.NextTab.description=在 Search Everywhere 對話框中切換到下一個頁籤
action.SearchEverywhere.NextTab.text=下一個頁籤
action.SearchEverywhere.PrevTab.description=在 Search Everywhere 對話框中切換到上一個頁籤
action.SearchEverywhere.PrevTab.text=上一個頁籤
action.SearchEverywhere.SelectItem.description=在 Search Everywhere 對話框中選擇項
action.SearchEverywhere.SelectItem.text=選擇項
action.SearchEverywhere.description=搜尋類別、檔案、工具視窗、動作和偏好設定
action.SearchEverywhere.text=隨處搜尋
action.SearchEverywhereNewToolbarAction.text=隨處搜尋
action.SearchEverywhereToolbar.searching.text=正在搜尋…
action.SearchEverywhereToolbar.text=隨處搜尋 
action.SearchEverywhereToolbarHotKey.hotkey=Shift+Shift
action.SearchEverywhereToolbarHotKey.text=隨處搜尋 {0}
action.SegmentedButton-left.text=選擇上一個分段按鈕
action.SegmentedButton-right.text=選擇下一個分段按鈕
action.SegmentedVcsControlAction.text=VCS 小工具
action.SelectAllOccurrences.description=通過將當前單詞的所有符合項新增到選區來設定多個游標。
action.SelectAllOccurrences.text=選擇所有符合項
action.SelectAndDumpInvalidTipsOfTheDay.text=選擇並傾印無效的每日小技巧
action.SelectAndShowTip.text=選擇並顯示提示(_S)
action.SelectIn.description=在任意檢視下選擇當前的類別或方法
action.SelectIn.text=選擇(_L)…
action.SelectInProjectView.description=在專案檢視中選擇上下文檔案
action.SelectInProjectView.text=在專案檢視中選擇檔案
action.SelectNextOccurrence.description=通過將當前單詞的下一個符合項新增到選區來設定多個游標。
action.SelectNextOccurrence.text=將下一個符合項新增到選擇
action.SelectOpenedFileInProjectView.description=在專案檢視中選擇已開啟的檔案
action.SelectOpenedFileInProjectView.text=選擇開啟的檔案
action.SelectVirtualTemplateElement.text=顯示用於就地重構的選項彈出視窗
action.SendEOF.text=發送 EOF
action.SendEventLogStatistics.description=將事件日誌檔案發送到 QA 伺服器
action.SendEventLogStatistics.text=發送功能使用事件日誌
action.SendFeedback.detailed.description=提交反饋給 {0}
action.SendFeedback.text=提交反饋(_F)…
action.ServiceView.ConfigureServices.text=Configure Services Tool Window
action.ServiceView.GroupByContributor.text=服務類型
action.ServiceView.GroupByServiceGroups.text=服務組
action.ServiceView.JumpToServices.text=跳轉到服務
action.ServiceView.OpenEachInNewTab.text=在新頁籤中開啟每個項
action.ServiceView.OpenInNewTab.text=在新頁籤中開啟
action.ServiceView.OpenInToolWindow.text=在單獨的工具視窗中開啟
action.ServiceView.ShowServices.text=顯示服務樹
action.ServiceView.SplitByType.text=在新頁籤中開啟每個類型
action.SetCaretVisualAttributesInternalAction.text=設定文字游標視覺特性…
action.SetShortcutAction.text=新增快捷鍵…
action.SeverityEditorDialogAction.text=顯示嚴重性編輯器
action.ShelveChanges.UnshelveWithDialog.description=更正套用補丁的路徑並取消擱置
action.ShelveChanges.UnshelveWithDialog.text=取消擱置…
action.ShelvedChanges.Rename.description=重新命名擱置的更改列表
action.ShelvedChanges.Rename.text=重新命名…
action.ShelvedChanges.Restore.text=還原已套用的擱置更改
action.ShelvedChanges.ShowHideDeleted.description=顯示/隱藏已取消擱置更改
action.ShelvedChanges.ShowHideDeleted.text=顯示/隱藏已套用的擱置更改
action.Show.Current.Revision.text=顯示當前修訂
action.ShowAboutPopupInDebugModeAction.text=在偵錯模式下顯示“關於”彈出視窗
action.ShowBackwardPackageDeps.MainMenu.text=向後相依關係(_B)…
action.ShowBackwardPackageDeps.description=瀏覽使用的程式碼所選分析條目
action.ShowBackwardPackageDeps.text=分析向後相依關係(_B)…
action.ShowBlankDiffWindow.description=並排開啟兩個編輯器並比較他們的內容
action.ShowBlankDiffWindow.synonym1=開啟空的差異視窗
action.ShowBlankDiffWindow.synonym2=開啟新的差異視窗
action.ShowBlankDiffWindow.text=開啟空白差異視窗
action.ShowBookmarks.text=顯示書籤…
action.ShowChangedStateStatisticsAction.description=呼叫所有狀態收集器，並僅顯示自上一個記錄以來已更改的事件
action.ShowChangedStateStatisticsAction.text=僅顯示已更改的狀態事件
action.ShowColorPicker.text=顯示取色器
action.ShowContent.description=顯示一個包含工具視窗頁籤列表的彈出視窗
action.ShowContent.text=顯示頁籤列表
action.ShowContent.views.text=顯示檢視列表
action.ShowControlFlowAction.text=顯示控制流
action.ShowDependenciesOnTarget.MainMenu.text=指定目標上的相依項
action.ShowDependenciesOnTarget.text=分析指定目標上的相依項
action.ShowDetailedInformationAction.text=顯示間接相依項
action.ShowDiscoveredTests.text=顯示受影響的測試
action.ShowEditorHighlighterTokens.text=顯示編輯器螢光筆令牌
action.ShowErrorDescription.description=顯示文字游標處錯誤或警告的說明
action.ShowErrorDescription.text=錯誤描述(_R)
action.ShowExecutionPoint.description=顯示當前程序執行點
action.ShowExecutionPoint.text=顯示執行點(_X)
action.ShowExperiments.text=實驗性功能…
action.ShowFilePath.description=顯示帶有當前檔案路徑的彈出視窗，以便在外部檔案管理器中開啟
action.ShowFilePath.popup=路徑彈出視窗(_P)
action.ShowFilePath.text=檔案路徑(_P)
action.ShowFontsUsedByEditor.description=允許找出編輯器中實際使用的回退字體
action.ShowFontsUsedByEditor.text=顯示編輯器使用的字體
action.ShowGotItDemo.text=顯示 GotIt 示範
action.ShowGutterIconsSettings.description=顯示對話框以組態裝訂區域圖標
action.ShowGutterIconsSettings.text=組態裝訂區域圖標…
action.ShowIntentionActions.text=顯示上下文動作
action.ShowLog.Explorer.text=在資源管理器中顯示日誌(_L)
action.ShowLog.Finder.text=在“訪達”中顯示日誌(_L)
action.ShowLog.description=開啟帶日誌檔案的目錄
action.ShowLog.text=在檔案管理器中顯示日誌(_L)
action.ShowMainMenu.text=顯示主選單
action.ShowMembersInNavigationBar.description=在導覽列中顯示/隱藏宣告
action.ShowMembersInNavigationBar.text=顯示成員
action.ShowModulesDependencies.MainMenu.text=模組相依項(_M)…
action.ShowModulesDependencies.description=顯示專案中模組之間的相依關係
action.ShowModulesDependencies.text=分析模組相依關係(_M)…
action.ShowNavBar.ShortText=導覽列
action.ShowNavBar.text=跳轉到導覽列(_J)
action.ShowNonRetinaImages.text=顯示非視網膜圖片
action.ShowNotificationIconsDialogAction.text=測試通知圖標
action.ShowPackageCycles.MainMenu.text=迴圈相依關係(_C)…
action.ShowPackageCycles.description=瀏覽迴圈中使用的程式碼所選分析條目
action.ShowPackageCycles.text=分析迴圈相依關係(_C)…
action.ShowPackageDeps.MainMenu.text=相依項(_D)…
action.ShowPackageDeps.description=瀏覽所選分析項所相依的程式碼
action.ShowPackageDeps.text=分析相依關係(_D)…
action.ShowParameterHintsSettings.description=開啟參數名稱提示設定
action.ShowParameterHintsSettings.text=提示設定…
action.ShowPopupMenu.text=顯示右鍵選單
action.ShowProcessWindow.description=顯示/隱藏背景任務視窗
action.ShowProcessWindow.double.click=點擊以顯示/隱藏背景任務視窗
action.ShowProcessWindow.text=顯示
action.ShowProgressTestDialogAction.text=測試進度指示器
action.ShowProjectStructureSettings.description=組態專案結構
action.ShowProjectStructureSettings.text=專案結構…
action.ShowRecentTests.text=最近的測試
action.ShowReformatFileDialog.text=重新格式化檔案…
action.ShowRegistry.text=註冊表…
action.ShowSearchEverywhereItemInfo.text=顯示“隨處搜尋”條目資訊
action.ShowSearchHistory.text=顯示搜尋歷史記錄
action.ShowSettingsAndFindUsages.description=為“尋找用法”動作選擇作用域和編輯選項
action.ShowSettingsAndFindUsages.text=尋找用法設定…
action.ShowSiblings.description=顯示包含符號同級內容的彈出視窗
action.ShowSiblings.text=顯示同級
action.ShowSouthPanelTestDialogAction.text=測試 DialogWrapper 南側面板
action.ShowSplash.text=顯示初始頁面
action.ShowTips.description=學習如何提高編碼效率。
action.ShowTips.text=每日小技巧(_T)
action.ShowToolbar.text=顯示工具列
action.ShowTypeBookmarks.text=轉到助記鍵…
action.ShowUpdateDialogAction.text=顯示“更新”對話框
action.ShowUsageFeatures.text=顯示用法功能
action.ShowUsages.description=顯示文字游標處符號的用法
action.ShowUsages.text=顯示用法(_S)
action.SilentCodeCleanup.description=執行清理檢查並使用當前檢查組態檔案套用快速修復
action.SilentCodeCleanup.text=靜默程式碼清理
action.SilentHeapDumpSnapshot.text=建立並計劃堆傾印分析 (非使用者呼叫)
action.SkipWindowDeactivationEvents.description=Turn on to simplify debugging. When a breakpoint in the debug IDE is hit, the main IDE steals focus, and \`WINDOW_DEACTIVATED\` events in the debug IDE trigger the cancellation of popups or file analysis, making \`ProgressManager.checkCanceled()\` throw right away without giving a chance to debug.
action.SkipWindowDeactivationEvents.text=Skip Window Deactivation Events
action.SliceBackward.MainMenu.text=流入此處的資料(_T)…
action.SliceBackward.description=搜尋可以分配給所選表達式的值
action.SliceBackward.text=分析流入此處的資料(_T)…
action.SliceForward.MainMenu.text=流出此處的資料(_F)…
action.SliceForward.description=搜尋從此位置轉義的值
action.SliceForward.text=分析流出此處的資料(_F)…
action.SmartSelect.text=擴展選區
action.SmartStepInto.description=步入特定方法
action.SmartStepInto.text=智能步入(_P)
action.SmartTypeCompletion.description=基於預期類型補全程式碼
action.SmartTypeCompletion.synonym=SmartType
action.SmartTypeCompletion.text=類型符合
action.SmartUnSelect.text=收縮選區
action.SplitChooser.Duplicate.text=複製
action.SplitChooser.Exit.text=退出選擇器
action.SplitChooser.NextWindow.text=下一個拆分
action.SplitChooser.PreviousWindow.text=上一個拆分
action.SplitChooser.Split.text=拆分
action.SplitChooser.SplitCenter.text=無拆分
action.SplitChooser.SplitDown.text=使用向下拆分或向下切換
action.SplitChooser.SplitLeft.text=使用左拆分或左切換
action.SplitChooser.SplitRight.text=使用右拆分或右切換
action.SplitChooser.SplitTop.text=使用頂部拆分或向上切換
action.SplitChooser.description=允許在編輯器中互動選擇拆分位置，並在該處開啟/移動所選檔案
action.SplitChooser.text=通過選擇器以拆分方式開啟…
action.SplitHorizontally.description=將編輯器區域拆分為 2 個頁籤組，然後將當前檔案移至底部組
action.SplitHorizontally.synonym=水平拆分
action.SplitHorizontally.text=向下拆分
action.SplitVertically.description=將編輯器區域拆分為 2 個頁籤組，然後將當前檔案移至右側組
action.SplitVertically.synonym=垂直拆分
action.SplitVertically.text=向右拆分
action.Start.Use.Vcs.Vcs.Toolbar.Widget.text=其他服務…
action.Start.Use.Vcs.text=啟用版本控制整合(_E)…
action.StartStopMacroRecording.description=啟動/停止新巨集錄製
action.StartStopMacroRecording.text=啟動/停止巨集錄製(_R)
action.StaticIconFields.text=列出 static 圖標欄位初始設定式
action.StatusTextModeAction.text=狀態文本
action.StepInto.description=單步執行至已執行的下一行
action.StepInto.text=步入(_I)
action.StepOut.description=單步執行至從此方法返回後執行的第一行
action.StepOut.text=步出(_T)
action.StepOver.description=單步執行至此檔案中的下一行
action.StepOver.text=步過(_O)
action.Stop.description=停止程序
action.Stop.text=停止
action.StopBackgroundProcesses.description=停止背景程序
action.StopBackgroundProcesses.text=停止背景程序…
action.StopWithDropDown.text=通過選項停止
action.StoreDefaultLayout.description=存儲當前所選布局
action.StoreDefaultLayout.synonym=存儲當前布局
action.StoreDefaultLayout.text=存儲當前布局(_Y)
action.StoreNamedLayout.description=將當前布局存儲為“{0}”
action.StoreNewLayout.MainMenu.text=新增(_N)…
action.StoreNewLayout.description=以新名稱存儲當前布局
action.StoreNewLayout.text=將當前布局存儲為…
action.StretchSplitToBottom.description=將拆分的編輯器延伸至底部
action.StretchSplitToBottom.text=將編輯器延伸至底部
action.StretchSplitToLeft.description=將拆分的編輯器延伸至左側
action.StretchSplitToLeft.text=將編輯器延伸至左側
action.StretchSplitToRight.description=將拆分的編輯器延伸至右側
action.StretchSplitToRight.text=將編輯器延伸至右側
action.StretchSplitToTop.description=將拆分的編輯器延伸至頂部
action.StretchSplitToTop.text=將編輯器延伸至頂部
action.StructuralSearchPlugin.StructuralReplaceAction.description=結構取代
action.StructuralSearchPlugin.StructuralReplaceAction.text=結構化取代(_C)…
action.StructuralSearchPlugin.StructuralSearchAction.description=結構搜尋
action.StructuralSearchPlugin.StructuralSearchAction.text=結構搜尋(_T)…
action.SurroundWith.description=使用 if/while/try-catch 或其他結構包圍所選程式碼段
action.SurroundWith.text=包圍方式(_S)…
action.SurroundWithEmmet.description=使用 Emmet 縮寫包圍所選程式碼
action.SurroundWithEmmet.text=使用 Emmet 包圍
action.SurroundWithLiveTemplate.description=使用一個模板包圍選區
action.SurroundWithLiveTemplate.text=使用實時模板包圍(_P)…
action.SwapSidesInDiffWindow.text=交換兩側
action.SwapThreeWayColorModeInDiffWindow.text=更改三向檢視器模式
action.SwitchCoverage.text=顯示程式碼覆蓋率資料(_V)
action.SwitchFileBasedIndexStorageAction.text=切換基於檔案的索引存儲
action.SwitchIdeScaleAction.text=縮放 IDE
action.Switcher.text=切換器
action.SwitcherBackward.text=選擇上一行
action.SwitcherForward.text=選擇下一行
action.SwitcherIterateItems.text=迭代最近的檔案
action.SwitcherNextProblem.text=選擇下一個問題檔案
action.SwitcherPreviousProblem.text=選擇上一個問題檔案
action.SwitcherRecentEditedChangedToggleCheckBox.text=切換僅更改的檔案
action.Synchronize.description=檢測所有外部更改的檔案，並從磁碟重新載入
action.Synchronize.text=從磁碟全部重新載入
action.SynchronizeCurrentFile.text=從磁碟重新載入
action.TabList.description=使用包含在單行頁籤布局中不適合螢幕的頁籤列表的下拉列表
action.TabList.text=顯示隱藏的頁籤
action.Tabbed.WelcomeScreen.OpenProject.text=開啟
action.Table-scrollDownChangeSelection.description=將周圍的可滾動區域向下滾動一頁，然後選擇相應的行。
action.Table-scrollDownChangeSelection.text=向下滾動頁面並選擇行
action.Table-scrollDownExtendSelection.description=將周圍的可滾動區域向下滾動一頁，然後將相應的行新增到選區。
action.Table-scrollDownExtendSelection.text=向下滾動頁面並擴展選區
action.Table-scrollUpChangeSelection.description=將周圍的可滾動區域向上滾動一頁，然後選擇相應的行。
action.Table-scrollUpChangeSelection.text=向上滾動頁面並選擇行
action.Table-scrollUpExtendSelection.description=將周圍的可滾動區域向上滾動一頁，然後將相應的行新增到選區。
action.Table-scrollUpExtendSelection.text=向上滾動頁面並擴展選區
action.Table-selectFirstRow.description=選擇第一行。
action.Table-selectFirstRow.text=選擇第一行
action.Table-selectFirstRowExtendSelection.description=滾動到第一行並將相應的行新增到選區。
action.Table-selectFirstRowExtendSelection.text=將選區擴展到第一行
action.Table-selectLastRow.description=選擇最後一行。
action.Table-selectLastRow.text=選擇最後一行
action.Table-selectLastRowExtendSelection.description=滾動到最後一行並將相應的行新增到選區。
action.Table-selectLastRowExtendSelection.text=將選區擴展到最後一行
action.Table-selectNextColumn.description=選擇下一列。
action.Table-selectNextColumn.text=選擇下一列
action.Table-selectNextColumnExtendSelection.description=將下一列新增到選區。
action.Table-selectNextColumnExtendSelection.text=將選區擴展到下一列
action.Table-selectNextRow.description=選擇下一行。
action.Table-selectNextRow.text=選擇下一行
action.Table-selectNextRowExtendSelection.description=將下一行新增到選區。
action.Table-selectNextRowExtendSelection.text=將選區擴展到下一行
action.Table-selectPreviousColumn.description=選擇上一列。
action.Table-selectPreviousColumn.text=選擇上一列
action.Table-selectPreviousColumnExtendSelection.description=將上一列新增到選區。
action.Table-selectPreviousColumnExtendSelection.text=將選區擴展到上一列
action.Table-selectPreviousRow.description=選擇上一行。
action.Table-selectPreviousRow.text=選擇上一行
action.Table-selectPreviousRowExtendSelection.description=將上一行新增到選區。
action.Table-selectPreviousRowExtendSelection.text=將選區擴展到上一行
action.Table-startEditing.text=編輯表單元
action.TechnicalSupport.description=聯繫 JetBrains 網站上的技術支援
action.TechnicalSupport.text=聯繫支援(_S)…
action.TemplateProjectStructure.MainMenu.text=結構…
action.TestCoroutineProgress.text=測試協同程序進度
action.TestDndAction.text=測試 Dnd
action.TestGestureAction.text=測試手勢動作
action.TestIconMappings.text=測試圖標映射
action.TestMessageBoxAction.text=顯示測試對話框
action.TestParseEventsSchemeAction.text=測試解析事件方案…
action.TestProgressWindow.text=測試進度視窗
action.TestSearchContributors.text= SE 貢獻者測試
action.TestTextFieldAction.text=測試文本欄位
action.TestTooltipsAction.text=測試工具提示
action.TextComponent.ClearAction.description=清除文本組件中的文本
action.TextComponent.ClearAction.text=清除文本
action.TextEditorWithPreview.SplitHorizontally.text=水平布局
action.TextEditorWithPreview.SplitVertically.text=垂直布局
action.TextGrayFilterConfig.text=文本灰色篩選器(&T)
action.TextSearchAction.description=在“隨處搜尋”中顯示文本符合項
action.TextSearchAction.text=文本…
action.ToggleBookmark.text=切換書籤(_B)
action.ToggleBookmarkWithMnemonic.text=切換書籤助記鍵…
action.ToggleBreakpointEnabled.description=啟用/停用當前行的中斷點
action.ToggleBreakpointEnabled.text=切換中斷點啟用狀態(_B)
action.ToggleCompactMode.text=緊湊模式
action.ToggleCompletionHintsAction.text=補全時顯示參數名稱提示
action.ToggleContentUiTypeMode.description=切換內容的標籤式/組合式顯示
action.ToggleContentUiTypeMode.text=頁籤分組
action.ToggleDistractionFreeMode.description=切換免打擾模式
action.ToggleDistractionFreeMode.enter=進入免打擾模式
action.ToggleDistractionFreeMode.exit=退出免打擾模式
action.ToggleDistractionFreeMode.text=切換免打擾模式
action.ToggleDockMode.description=停靠/取消停靠活動工具視窗
action.ToggleDockMode.text=停靠模式(_E)
action.ToggleEssentialHighlighting.description=基本醒目提示模式只保留一組有限的程式碼醒目提示工具。包括檢查在內的所有醒目提示工具都將在執行檔案儲存動作時執行
action.ToggleEssentialHighlighting.text=基本醒目提示顯示
action.ToggleFieldBreakpoint.MainMenu.text= 欄位觀察點
action.ToggleFieldBreakpoint.description=為文字游標處的欄位切換欄位觀察點
action.ToggleFieldBreakpoint.text=切換欄位觀察點(_F)
action.ToggleFindInSelection.text=僅在選區內搜尋
action.ToggleFloatingMode.description=浮動/取消浮動活動工具視窗
action.ToggleFloatingMode.text=浮動模式(_M)
action.ToggleFocusMode.text=僅醒目提示當前宣告
action.ToggleFullScreen.description=切換全螢幕模式
action.ToggleFullScreen.text=切換全螢幕模式
action.ToggleFullScreen.text.enter=進入全螢幕
action.ToggleFullScreen.text.exit=退出全螢幕
action.ToggleInlineHintsAction.description=切換參數名稱提示
action.ToggleInlineHintsAction.text=切換參數名稱提示
action.ToggleLineBreakpoint.MainMenu.text=行中斷點(_L)
action.ToggleLineBreakpoint.description=切換文字游標處的行中斷點
action.ToggleLineBreakpoint.text=切換行中斷點(_L)
action.ToggleMethodBreakpoint.MainMenu.text=方法中斷點(_M)
action.ToggleMethodBreakpoint.description=為文字游標處的方法切換方法中斷點
action.ToggleMethodBreakpoint.text=切換方法中斷點(_M)
action.TogglePinnedMode.description=固定/取消固定活動工具視窗
action.TogglePinnedMode.text=固定模式(_P)
action.TogglePopupHints.text=切換當前檔案的彈出視窗提示
action.TogglePowerSave.description=省電模式將停用背景程式碼分析和其他背景動作
action.TogglePowerSave.text=省電模式
action.TogglePresentationMode.description=切換示範模式
action.TogglePresentationMode.enter=進入示範模式
action.TogglePresentationMode.exit=退出示範模式
action.TogglePresentationMode.text=切換示範模式
action.TogglePresentationMode.text.enter=進入示範模式
action.TogglePresentationMode.text.exit=退出示範模式
action.ToggleReadOnlyAttribute.description=切換當前檔案的唯讀特性
action.ToggleReadOnlyAttribute.dirs=使{3,choice,1#目錄|2#目錄}{0,choice,0#唯讀|1#可寫}
action.ToggleReadOnlyAttribute.files=將{2,choice,1#檔案|2#檔案}設為{0,choice,0#唯讀|1#可寫}
action.ToggleReadOnlyAttribute.mixed=使檔案/目錄{0,choice,0#唯讀|1#可寫}
action.ToggleReadOnlyAttribute.synonym=將檔案設為可寫
action.ToggleReadOnlyAttribute.synonym2=將檔案設為唯讀
action.ToggleReadOnlyAttribute.text=切換唯讀特性
action.ToggleRenderedDocPresentation.description=在檢視原始碼和文檔註釋的渲染表示之間切換
action.ToggleRenderedDocPresentation.text=切換呈現檢視
action.ToggleRenderedDocPresentationForAll.description=切換到所有文檔註釋的呈現檢視
action.ToggleRenderedDocPresentationForAll.text=呈現所有文檔註釋
action.ToggleSideMode.description=開啟/關閉工具視窗拆分模式
action.ToggleSideMode.text=拆分模式
action.ToggleTemporaryLineBreakpoint.MainMenu.text=臨時行中斷點
action.ToggleTemporaryLineBreakpoint.description=切換文字游標處的臨時行中斷點
action.ToggleTemporaryLineBreakpoint.text=切換臨時行中斷點
action.ToggleThreeSideInBlankDiffWindow.text=切換三向檢視器
action.ToggleThreeSideInBlankDiffWindow.text.disable=切換到兩向檢視器
action.ToggleThreeSideInBlankDiffWindow.text.enable=切換到三向檢視器
action.ToggleUiInspectorHierarchyTrace.text=切換 UI 檢查器層次結構追蹤
action.ToggleUiInspectorHierarchyTrace.text.disable=停用 UI 檢查器層次結構追蹤
action.ToggleUiInspectorHierarchyTrace.text.enable=啟用 UI 檢查器層次結構追蹤
action.ToggleUnusedState.description=Signal the IDE is either not used or used.
action.ToggleUnusedState.text=Signal IDE Not Used
action.ToggleWindowedMode.description=視窗化/取消視窗化活動工具視窗
action.ToggleWindowedMode.text=視窗化模式(_W)
action.ToggleZenMode.description=同時切換免打擾和全螢幕模式
action.ToggleZenMode.enter=進入 Zen 模式
action.ToggleZenMode.exit=退出 Zen 模式
action.ToggleZenMode.text=切換 Zen 模式
action.ToolwindowSwitcher.text=工具視窗切換器
action.TopStripeEnableAction.text=使用單個工具視窗列
action.TopStripePinButton.text=固定
action.TopStripeUnPinButton.text=取消固定
action.TransferSettingsDemoAction.text=測試傳輸設定
action.Tree-scrollDownChangeSelection.description=將周圍的可滾動區域向下滾動一頁，然後選擇相應的節點。
action.Tree-scrollDownChangeSelection.text=向下滾動頁面並選擇節點
action.Tree-scrollDownExtendSelection.description=將周圍的可滾動區域向下滾動一頁，然後將相應的節點新增到選區。
action.Tree-scrollDownExtendSelection.text=向下滾動頁面並擴展選區
action.Tree-scrollUpChangeSelection.description=將周圍的可滾動區域向上滾動一頁，然後選擇相應的節點。
action.Tree-scrollUpChangeSelection.text=向上滾動頁面並選擇節點
action.Tree-scrollUpExtendSelection.description=將周圍的可滾動區域向上滾動一頁，然後將相應的節點新增到選區。
action.Tree-scrollUpExtendSelection.text=向上滾動頁面並擴展選區
action.Tree-selectChild.description=展開摺疊的節點或選擇子節點。
action.Tree-selectChild.text=選擇子節點
action.Tree-selectChildExtendSelection.description=展開摺疊的節點或將子節點新增到選區。
action.Tree-selectChildExtendSelection.text=將選區擴展到子節點
action.Tree-selectFirst.description=選擇第一個節點。
action.Tree-selectFirst.text=選擇第一個節點
action.Tree-selectFirstExtendSelection.description=滾動到第一個節點並將相應的節點新增到選區。
action.Tree-selectFirstExtendSelection.text=將選區擴展到第一個節點
action.Tree-selectLast.description=選擇最後一個節點。
action.Tree-selectLast.text=選擇最後一個節點
action.Tree-selectLastExtendSelection.description=滾動到最後一個節點並將相應的節點新增到選區。
action.Tree-selectLastExtendSelection.text=將選區擴展到最後一個節點
action.Tree-selectNext.description=選擇下一個節點。
action.Tree-selectNext.text=選擇下一個節點
action.Tree-selectNextExtendSelection.description=將下一個節點新增到選區。
action.Tree-selectNextExtendSelection.text=將選區擴展到下一個節點
action.Tree-selectNextSibling.description=選擇下一個同級節點。
action.Tree-selectNextSibling.text=選擇下一個同級節點
action.Tree-selectParent.description=摺疊展開的節點或選擇父節點。
action.Tree-selectParent.text=選擇父節點
action.Tree-selectParentExtendSelection.description=滾動到父節點並將相應的節點新增到選區。
action.Tree-selectParentExtendSelection.text=將選區擴展到父節點
action.Tree-selectParentNoCollapse.description=選擇父節點(不摺疊展開的節點)。
action.Tree-selectParentNoCollapse.text=選擇父節點
action.Tree-selectPrevious.description=選擇上一個節點。
action.Tree-selectPrevious.text=選擇上一個節點
action.Tree-selectPreviousExtendSelection.description=將上一個節點新增到選區。
action.Tree-selectPreviousExtendSelection.text=將選區擴展到上一個節點
action.Tree-selectPreviousSibling.description=選擇上一個同級節點。
action.Tree-selectPreviousSibling.text=選擇上一個同級節點
action.Tree-startEditing.text=編輯樹節點
action.TreeExpandAll.text=展開樹
action.TriggerLowMemoryNotification.text=觸發低記憶體通知
action.TrustProject.text=信任
action.TurnOnOffCachedValueProfilerAction.text=開啟快取值分析器
action.TurnRefsToSuper.description=將類別的用法更改為其超類別或接口的用法
action.TurnRefsToSuper.text=盡可能使用接口(_W)…
action.TypeHierarchy.Class.text=類別層次結構
action.TypeHierarchy.Subtypes.text=子類型層次結構
action.TypeHierarchy.Supertypes.text=父類型層次結構
action.TypeHierarchy.description=瀏覽所選類別的層次結構
action.TypeHierarchy.text=類型層次結構(_H)
action.TypeHierarchyBase.BaseOnThisType.text=基於此類型
action.TypingLatencyReport.text=輸入延遲報告
action.UIDefaults.text=LaF 預設設定
action.UiDebugger.text=UI 偵錯器…
action.UiDslShowcaseAction.text=UI DSL 展示
action.UiDslTestAction.text=顯示 UI DSL 測試
action.UiInspector.text=UI 檢查器(&I)
action.UndockMode.description=使工具視窗滑動並在焦點丟失時自動隱藏
action.UndockMode.text=取消停靠(_D)
action.UnmarkRoot.text=取消標記
action.Unscramble.EditorPopup.text=堆疊追蹤或執行緒傾印(_S)…
action.Unscramble.description=開啟包含可導覽堆疊追蹤或執行緒傾印的主控台
action.Unscramble.text=分析堆疊追蹤或執行緒傾印(_S)…
action.UnselectPreviousOccurrence.description=從選區中移除單詞的當前符合項。
action.UnselectPreviousOccurrence.text=取消選擇符合項
action.Unsplit.description=取消拆分視窗
action.Unsplit.text=取消拆分(_S)
action.UnsplitAll.description=移除所有拆分器
action.UnsplitAll.text=取消全部拆分(_N)
action.UntrustProject.text=不信任
action.Unwrap.description=安全地解包或移除所選作用域
action.Unwrap.text=解包/移除(_W)…
action.UpdateFiles.text=更新(_U)
action.UpdateRunningApplication.text=更新正在執行的應用程式
action.UsageView.Exclude.description=將此用法從處理中排除
action.UsageView.Exclude.text=排除
action.UsageView.Include.description=將此用法包含到處理中
action.UsageView.Include.text=包含
action.UsageView.Remove.description=將此用法從處理中移除
action.UsageView.Remove.text=移除
action.UsageView.Rerun.description=重新執行搜尋
action.UsageView.Rerun.text=重新執行
action.UsageView.ShowRecentFindUsages.description=選擇並重新執行最近的尋找用法
action.UsageView.ShowRecentFindUsages.text=最近的尋找用法(_E)
action.UsedIconsListing.text=列出使用的圖標
action.UserInvokedFullAnalysis.text=建立並立即分析堆傾印
action.ValidateLocalHistory.text=驗證本地歷史記錄存儲
action.ValidateXml.description=驗證當前的 XML 檔案
action.ValidateXml.text=驗證(_V)
action.ValidationTest.text=驗證對話框測試
action.Vcs.ApplySelectedChanges.text=優選所選更改
action.Vcs.CopyCommitSubjectAction.description=將所選提交的主題複製到剪貼簿
action.Vcs.CopyCommitSubjectAction.text=複製提交主題
action.Vcs.CopyRevisionNumberAction.description=將選定提交的修訂號複製到剪貼簿
action.Vcs.CopyRevisionNumberAction.text=複製修訂號
action.Vcs.Diff.ExcludeChangedLinesFromCommit.template.text={0,choice,0#|1#Split Chunk and |2#Split Chunks and }Exclude {1,choice,0#Current Line|2#Selected Lines} from Commit
action.Vcs.Diff.ExcludeChangedLinesFromCommit.text=Split Chunks and Exclude Selected Lines from Commit
action.Vcs.Diff.IncludeChangedLinesIntoCommit.template.text={0,choice,0#|1#Split Chunk and |2#Split Chunks and }Include {1,choice,0#Current Line|2#Selected Lines} into Commit
action.Vcs.Diff.IncludeChangedLinesIntoCommit.text=Split Chunks and Include Selected Lines into Commit
action.Vcs.Diff.ShowCombinedDiff.description=在一處顯示全部所選更改的差異
action.Vcs.Diff.ShowCombinedDiff.text=顯示組合差異
action.Vcs.Diff.ShowDiffInEditorTab.text=在編輯器頁籤中顯示差異
action.Vcs.Diff.ShowDiffInNewWindow.text=在單獨的視窗中顯示差異
action.Vcs.Diff.ToggleDiffAligningMode.description=啟用雙面差異的更改對齊
action.Vcs.Diff.ToggleDiffAligningMode.popup@DiffToolbar.text=對齊更改醒目提示
action.Vcs.Diff.ToggleDiffAligningMode.text=在並排差異中對齊更改
action.Vcs.EditSource.text=編輯源
action.Vcs.GetVersion.description=從儲存庫獲取版本
action.Vcs.GetVersion.text=獲取
action.Vcs.IntegrateProject.description=整合專案
action.Vcs.IntegrateProject.text=整合專案(_G)
action.Vcs.MoveChangedLinesToChangelist.description=將所選行中的更改移至另一個更改列表…
action.Vcs.MoveChangedLinesToChangelist.text=將行移到另一個更改列表…
action.Vcs.Operations.Popup.Annotate.text=註解行動作
action.Vcs.Push.Force.text=強制推送(_F)
action.Vcs.Push.text=推送…
action.Vcs.QuickListPopupAction.description=包含常用 VCS 動作列表的上下文感知彈出視窗
action.Vcs.QuickListPopupAction.text=VCS 動作彈出視窗…
action.Vcs.RevertSelectedChanges.text=還原所選更改
action.Vcs.RollbackChangedLines.description=回滾所選行中的更改
action.Vcs.RollbackChangedLines.text=回滾行
action.Vcs.RunCommitChecks.text=執行提交檢查
action.Vcs.Show.Local.Changes.text=顯示本地更改
action.Vcs.Show.Shelf.text=顯示 Shelf
action.Vcs.ShowConsoleTab.text=在 VCS 主控台頁籤中顯示
action.Vcs.ShowDiffChangedLines.description=顯示所選行的差異
action.Vcs.ShowDiffChangedLines.text=顯示行的差異
action.Vcs.ShowDiffWithLocal.Before.description=將之前的所選修訂中的版本與當前版本進行比較
action.Vcs.ShowDiffWithLocal.Before.text=將之前版本與本地版本進行比較
action.Vcs.ShowDiffWithLocal.description=將所選修訂中的版本與當前版本進行比較
action.Vcs.ShowDiffWithLocal.text=與本地比較
action.Vcs.ShowHistoryForBlock.description=顯示編輯器選擇的歷史記錄
action.Vcs.ShowHistoryForBlock.text=顯示選區的歷史記錄(_F)…
action.Vcs.ShowHistoryForRevision.description=顯示檔案的歷史記錄，直到所選修訂版本
action.Vcs.ShowHistoryForRevision.text=迄今為止的歷史記錄
action.Vcs.ShowMessageHistory.description=顯示提交訊息歷史記錄
action.Vcs.ShowMessageHistory.text=提交訊息歷史記錄
action.Vcs.ShowTabbedFileHistory.description=顯示檔案的歷史記錄
action.Vcs.ShowTabbedFileHistory.text=顯示歷史記錄(_H)
action.Vcs.ToggleAmendCommitMode.description=修改當前分支的最新提交
action.Vcs.ToggleAmendCommitMode.text=修正提交
action.Vcs.Toolbar.ShowMoreActions.description=VCS 動作
action.Vcs.Toolbar.ShowMoreActions.text=版本控制
action.Vcs.UpdateProject.text=更新專案(_U)
action.Vcs.VcsClone.text=從版本控制中獲取…
action.Vcs.VcsClone.text.synonym1=簽出
action.Vcs.VcsClone.text.synonym2=克隆
action.VcsHistory.ShowAllAffected.description=顯示選中修訂中所做的所有更改
action.VcsHistory.ShowAllAffected.text=顯示所有受影響的檔案
action.VcsShowCurrentChangeMarker.description=顯示當前所選更改的彈出視窗
action.VcsShowCurrentChangeMarker.text=文字游標下的更改(_H)
action.VcsShowNextChangeMarker.description=轉到下一個更改
action.VcsShowNextChangeMarker.text=下一個更改(_H)
action.VcsShowPrevChangeMarker.description=轉到上一個更改
action.VcsShowPrevChangeMarker.text=上一個更改(_A)
action.VcsToolbarLabelAction.text=VCS 標籤
action.ViewBreakpoints.description=檢視和管理所有中斷點和觀察點
action.ViewBreakpoints.text=檢視中斷點(_K)…
action.ViewImportPopups.description=在當前檔案中切換顯示匯入彈出視窗
action.ViewImportPopups.text=顯示匯入彈出視窗
action.ViewInplaceComments.description=在樹檢視中顯示/隱藏額外資訊
action.ViewInplaceComments.text=樹檢視中的詳細資訊
action.ViewMainMenu.description=顯示/隱藏主選單
action.ViewMainMenu.text=主選單
action.ViewMembersInNavigationBar.NavBar.text=在導覽列中顯示成員
action.ViewMembersInNavigationBar.description=在導覽列中顯示/隱藏宣告
action.ViewMembersInNavigationBar.text=導覽列中的成員
action.ViewNavigationBar.NavBar.text=顯示導覽列
action.ViewNavigationBar.description=顯示/隱藏導覽列
action.ViewNavigationBar.text=導覽列(_V)
action.ViewNewToolbarAction.text=工具列
action.ViewObsoleteNavBarAction.text=導覽列
action.ViewObsoleteToolbarAction.text=工具列經典
action.ViewOfflineInspection.description=載入離線檢查結果
action.ViewOfflineInspection.text=檢視離線檢查結果(_O)…
action.ViewSource.description=開啟所選條目的編輯器
action.ViewSource.text=顯示源(_W)
action.ViewStatusBar.description=顯示/隱藏狀態列
action.ViewStatusBar.text=狀態列(_S)
action.ViewToolBar.description=顯示/隱藏主工具列
action.ViewToolBar.text=工具列(_T)
action.ViewToolButtons.description=顯示/隱藏工具視窗按鈕
action.ViewToolButtons.text=工具視窗
action.VirtualFileInfo.text=虛擬檔案資訊
action.WebBrowser.text=顯示 Web 瀏覽器(&W)
action.WelcomeScreen.ChangeProjectIcon.text=Set Custom Project Icon...
action.WelcomeScreen.Configure.Export.text=匯出設定
action.WelcomeScreen.Configure.Import.text=匯入設定…
action.WelcomeScreen.Configure.RestoreDefault.text=還原為預設設定…
action.WelcomeScreen.CopyProjectPath.text=複製路徑
action.WelcomeScreen.CreateDirectoryProject.description=建立一個新項目。
action.WelcomeScreen.CreateDirectoryProject.text=新增專案
action.WelcomeScreen.CreateNewProject.description=啟動“新項目”嚮導，它將引導您建立一個新項目。
action.WelcomeScreen.CreateNewProject.text=新增專案
action.WelcomeScreen.DevelopPlugins.description=開始開發延伸模組。
action.WelcomeScreen.DevelopPlugins.text=延伸模組開發
action.WelcomeScreen.EditGroup.text=編輯…
action.WelcomeScreen.ManageLicense.text=管理授權…
action.WelcomeScreen.NewGroup.text=新增專案組
action.WelcomeScreen.OpenDirectoryProject.description=開始在指定的檔案或目錄中編輯程式碼。
action.WelcomeScreen.OpenDirectoryProject.text=開啟
action.WelcomeScreen.OpenProject.description=開啟檔案或專案。您也可以通過拖放到歡迎頁面來開啟專案或編輯檔案。
action.WelcomeScreen.OpenProject.text=開啟或匯入
action.WelcomeScreen.OpenSelected.text=開啟選定項
action.WelcomeScreen.Plugins.Extensions.text=擴展
action.WelcomeScreen.Plugins.description=管理已安裝的延伸模組，以及從儲存庫下載新延伸模組
action.WelcomeScreen.Plugins.text=延伸模組
action.WelcomeScreen.RemoveSelected.text=從最近的專案中移除…
action.WhatsNewAction.description=了解此版本 IDE 中的新功能
action.WhatsNewAction.text=最新變化(_N)
action.WindowMode.description=將工具視窗移至單獨的框架
action.WindowMode.text=視窗(_W)
action.WriteActionUnderProgress.text=正在測試寫入動作
action.XDebugger.CompareValueWithClipboard.description=將所選節點的值與剪貼簿文本進行比較
action.XDebugger.CompareValueWithClipboard.text=與剪貼簿比較值
action.XDebugger.CopyName.description=將所選節點的名稱複製到剪貼簿
action.XDebugger.CopyName.text=複製名稱
action.XDebugger.CopyValue.description=將所選節點的值複製到剪貼簿
action.XDebugger.CopyValue.text=複製值
action.XDebugger.CopyWatch.text=複製監視
action.XDebugger.EditWatch.text=編輯…
action.XDebugger.Inline.description=在編輯器中顯示可用的偵錯器會話值
action.XDebugger.Inline.text=在編輯器中顯示變量值
action.XDebugger.Inspect.text=檢查…
action.XDebugger.JumpToSource.description=開啟所選條目的源
action.XDebugger.JumpToSource.text=跳轉到源
action.XDebugger.JumpToTypeSource.description=開啟所選值類型的源
action.XDebugger.JumpToTypeSource.text=跳轉到類型源
action.XDebugger.MoveWatchDown.text=下移監視
action.XDebugger.MoveWatchUp.text=上移監視
action.XDebugger.MuteBreakpoints.text=忽略中斷點
action.XDebugger.NewWatch.text=新增監視…
action.XDebugger.PinToTop.text=固定至頂部
action.XDebugger.PreviewTab.text=在預覽頁籤中開啟檔案
action.XDebugger.RemoveAllWatches.text=移除所有監視
action.XDebugger.RemoveWatch.text=移除監視
action.XDebugger.SetValue.description=修改所選節點的值
action.XDebugger.SetValue.text=設定值…
action.XDebugger.Show.Breakpoints.Over.Line.Numbers.text=在行號上顯示中斷點
action.XDebugger.SwitchWatchesInVariables.text=在“變數”頁籤中顯示監視
action.XDebugger.ToggleEvaluateExpressionField.text=顯示“對表達式求值”欄位
action.XDebugger.ToggleSortValues.description=在偵錯器檢視中按字母順序排列值
action.XDebugger.ToggleSortValues.text=按字母順序對變數進行排序
action.XDebugger.UnmuteOnStop.text=在會話完成時取消忽略中斷點
action.XSD2Document.text=從 XML 檔案生成 XSD 架構…
action.XcodeBuildSwiftDocumentationAction.description=為所有目標建置文檔
action.XcodeBuildSwiftDocumentationAction.text=建置文檔
action.XcodePreviewSwiftDocumentationAction.description=為所有目標建置並預覽文檔
action.XcodePreviewSwiftDocumentationAction.text=預覽文檔
action.ZoomCurrentWindow.description=縮放當前視窗
action.ZoomCurrentWindow.text=縮放
action.ZoomInIdeAction.text=放大 IDE
action.ZoomOutIdeAction.text=縮小 IDE
action.addQuickAction.BackForward.text=後退/前進
action.addQuickAction.Build.text=建置
action.addQuickAction.Coverage.text=使用覆蓋率執行
action.addQuickAction.OpenFile.text=開啟檔案
action.addQuickAction.Profile.text=分析器
action.addQuickAction.SaveAll.text=全部儲存
action.addQuickAction.Synchronize.text=同步
action.addQuickAction.UndoRedo.text=撤銷/重做
action.compare.archives.text=比較歸檔
action.compare.files.text=比較檔案
action.compare.text=比較
action.compare.with.text=比較物件…
action.editRunConfigurations.description=開啟“編輯執行/偵錯組態”對話框
action.editRunConfigurations.text=編輯組態(_R)…
action.fontEditorPreview.ToggleBoldFont.text=切換加粗的字體
action.main.toolbar.Filename.text=檔名小工具(隱藏編輯器頁籤時)
action.main.toolbar.Project.text=專案小工具
action.openAssertEqualsDiff.text=檢視 assertEquals 差異
action.performancePlugin.ShowMemoryDialogAction.description=顯示更改記憶體對話框
action.performancePlugin.ShowMemoryDialogAction.text=更改記憶體設定
action.redo.description=重做{0}
action.redo.description.empty=最後的撤消動作
action.redo.text=重做{0}(_R)
action.synonym.LocalHistory.ShowSelectionHistory.class.text=顯示類別的本地歷史記錄…
action.synonym.LocalHistory.ShowSelectionHistory.method.text=顯示方法的本地歷史記錄…
action.synonym.Vcs.ShowHistoryForBlock.class.text=顯示類別的歷史記錄…
action.synonym.Vcs.ShowHistoryForBlock.method.text=顯示方法的歷史記錄…
action.undo.description=撤消{0}
action.undo.description.empty=最後動作
action.undo.text=撤消{0}(_U)
apply.toolbar.customization=套用
group.$LRU.GoToAction.text=開啟最近的專案
group.$LRU.description=最近開啟專案的列表
group.$LRU.text=最近的專案(_R)
group.ActiveToolwindowGroup.text=活動工具視窗
group.AnalyzeActionsPopup.text=分析程式碼
group.AnalyzeJavaMenu.description=分析 Java 選單
group.AnalyzeJavaMenu.text=分析 Java 選單
group.AnalyzeMenu.text=分析(_Z)
group.ArrangementRulesGroup.text=排列規則
group.BackgroundTasks.text=背景任務
group.Bookmarks.Goto.text=按數字/助記鍵轉到
group.Bookmarks.Toggle.text=按數字/助記鍵切換
group.Bookmarks.text=書籤
group.BreakpointActionsGroup.text=切換中斷點
group.BuildArtifactsGroup.text=建置工件
group.BuildMenu.text=建置(_B)
group.CacheRecovery.text=快取恢復
group.ChangeLineSeparators.text=行分隔符
group.ChangeProjectColorActionGroup.text=Change Project Color
group.ChangesView.Changelists.text=更改列表
group.ChangesView.GroupBy.text=分組依據
group.CleanupEventLog.description=移除所有未發送事件日誌檔案
group.CleanupEventLog.text=清理事件日誌
group.CloseEditorsGroup.text=編輯器關閉動作
group.CodeCompletionGroup.text=程式碼補全(_C)
group.CodeEditorBaseGroup.text=程式碼編輯器檢視動作
group.CodeEditorViewGroup.text=程式碼檢視動作
group.CodeFormatGroup.text=程式碼格式設定動作
group.CodeMenu.text=程式碼(_C)
group.CommentGroup.text=註釋動作
group.CommitView.ShowOnDoubleClick.text=雙擊時顯示
group.ConvertIndentsGroup.text=轉換縮排
group.Copy.Paste.Special.description=複製/貼上特殊編輯器動作
group.Copy.Paste.Special.text=複製/貼上特殊
group.CopyReferencePopupGroup.text=複製路徑/參照…
group.CoverageMenu.text=程式碼覆蓋率動作
group.CreateRunConfiguration.description=根據當前上下文建立執行組態
group.CreateRunConfiguration.text=建立執行組態
group.CustomLayoutActionsGroup.text=工具視窗布局
group.CustomLayoutsGroup.text=工具視窗布局
group.CutCopyPasteGroup.text=剪下/複製/貼上動作
group.DebugMainMenu.text=偵錯器動作
group.Debugger.ViewAsGroup.text=檢視方式
group.DebuggingActionsGroup.text=偵錯動作
group.DeleteNamedLayoutGroup.text=刪除布局(_D)
group.Diff.Binary.Settings.text=設定
group.Diff.KeymapGroup.text=差異與合併
group.Documentation.Navigation.text=快速文檔導覽
group.EditBookmarksGroup.text=書籤(_K)
group.EditCreateDeleteGroup.text=編輯器建立/刪除動作
group.EditMenu.text=編輯(_E)
group.EditSelectGroup.text=編輯器選擇動作
group.EditSelectWordGroup.text=選擇單詞動作
group.EditSmartGroup.text=編輯程式碼動作
group.EditorActions.text=編輯器動作
group.EditorBidiTextDirection.description=混合 LTR/RTL 文本的主要方向
group.EditorBidiTextDirection.text=雙向文本基礎方向
group.EditorBreadcrumbsSettings.description=切換路徑導覽列設定
group.EditorBreadcrumbsSettings.text=路徑導覽
group.EditorGutterPopupMenu.Appearance.text=外觀
group.EditorGutterPopupMenu.text=編輯器裝訂區域彈出選單
group.EditorLangPopupMenu.text=編輯器彈出視窗選單動作(2)
group.EditorPopupMenu.GoTo.description=轉到編輯器彈出視窗選單組
group.EditorPopupMenu.GoTo.text=轉到
group.EditorPopupMenu.Run.text=編譯/執行動作
group.EditorPopupMenu.description=編輯器彈出視窗選單
group.EditorPopupMenu.text=編輯器彈出視窗選單
group.EditorPopupMenu1.text=編輯器彈出視窗選單動作(1)
group.EditorPopupMenuDebug.text=偵錯動作
group.EditorTabPopupMenu.text=編輯器頁籤彈出視窗選單
group.EditorTabPopupMenuEx.text=編輯器頁籤彈出視窗選單動作(1)
group.EditorTabsEntryPoint.text=最近的檔案、頁籤動作等
group.EditorTabsGroup.text=編輯器頁籤(_T)
group.EditorToggleActions.text=活動編輯器
group.Emmet.text=Emmet
group.ExpandAllToLevel.text=全部展開到級別(_L)
group.ExpandToLevel.text=展開到級別(_E)
group.ExportImportGroup.text=管理 IDE 設定
group.ExternalSystem.ShowSettingsGroup.text=建置工具設定
group.ExternalToolsGroup.text=外部工具
group.FeatureUsage.Internal.text=功能用法統計資訊
group.FileChooserSettings.text=檔案選擇器設定
group.FileChooserToolbar.text=檔案選擇器工具列
group.FileExportGroup.text=匯出
group.FileHistory.KeymapGroup.text=檔案歷史記錄
group.FileMainSettingsGroup.text=設定動作
group.FileMenu.text=檔案(_F)
group.FileOpenGroup.text=檔案開啟動作
group.FileOtherSettingsGroup.text=新增專案設定
group.FilePropertiesGroup.text=檔案屬性
group.FileSettingsGroup.text=設定動作
group.FindMenuGroup.text=尋找(_F)
group.FindUsagesMenuGroup.text=尋找用法
group.Floating.CodeToolbar.Extract.text=提取
group.Floating.CodeToolbar.Surround.text=環繞
group.Floating.CodeToolbar.text=浮動程式碼工具列
group.FoldingGroup.text=折疊
group.GenerateGroup.text=生成(_G)
group.GoToChangeMarkerGroup.text=更改導覽動作
group.GoToCodeGroup.text=通過參照轉到
group.GoToErrorGroup.text=轉到錯誤/書籤動作
group.GoToMenu.text=導覽(_N)
group.GoToTargetEx.text=通過名稱轉到
group.Graph.AlignNodesGroup.text=對齊
group.Graph.AppearanceGroup.text=外觀
group.Graph.BehaviourGroup.text=行為
group.Graph.CommonLayoutGroup.text=布局
group.Graph.DistributeNodesGroup.text=分散排列
group.Graph.EdgeRealizerGroup.text=邊緣形狀
group.Graph.ExportGroup.text=匯出圖
group.Graph.LayoutOrientationGroup.text=方向
group.Graph.MergeEdgesGroup.text=合併邊緣
group.Graph.NeighborhoodViewPopup.AppearanceGroup.text=外觀
group.Graph.NeighborhoodViewPopup.LayoutGroup.text=布局
group.Graph.NetsLayoutGroup.text=網狀
group.Graph.OrthogonalLayoutGroup.text=正交
group.Graph.RadialLayoutGroup.text=徑向
group.Graph.TreeLayoutGroup.text=樹
group.Graphs.KeymapGroup.text=圖表
group.HelpDiagnosticTools.text=診斷工具
group.HelpMenu.text=幫助(_H)
group.HierarchyGroup.text=層次結構動作
group.ImportTests.text=匯入測試結果
group.InspectCodeGroup.text=檢查程式碼動作
group.Internal.Dump.text=傾印
group.Internal.Editor.text=編輯器(&E)
group.Internal.Errors.text=異常
group.Internal.HeapAnalysis.text=堆分析
group.Internal.Java.text=Java
group.Internal.PMM.text=PMM 實用工具
group.Internal.Performance.text=性能
group.Internal.Trust.text=原始碼安全性
group.Internal.UI.Demos.text=示範
group.Internal.UI.text=UI(&U)
group.Internal.VFS.text=VFS
group.Internal.text=內部動作(&I)
group.Internal1.text=IDEA 內部動作
group.IntroduceActionsGroup.text=提取/引入(_X)
group.LeftToolbarSideGroup.text=左側
group.ListActions.text=列表動作
group.LocalChangesView.ShowOnDoubleClick.text=雙擊時顯示
group.LocalHistory.text=本地歷史記錄(_H)
group.Macros.description=檢視、更改、錄製、執行巨集
group.Macros.text=巨集(_S)
group.MacrosGroup.text=巨集動作
group.MainMenu.text=主選單
group.MainToolBar.text=主工具列
group.MainToolbarCenter.text=中心
group.MainToolbarGeneralActionsGroup.text=一般動作
group.MainToolbarLeft.text=左側
group.MainToolbarQuickActions.text=新增到主工具列
group.MainToolbarRight.text=右側
group.MarkFileAs.text=將檔案標記為
group.MarkRootGroup.text=將目錄標記為
group.MigrationMenu.text=遷移軟體套件和類別
group.MoreActionGroup.text=更多
group.MoveModuleToGroup.description=移動模組(_M)
group.MoveModuleToGroup.text=將模組移至組
group.NavBarActions.text=導覽列動作
group.NavbarLocationGroup.description=選擇導覽列的位置
group.NavbarLocationGroup.text=導覽列
group.NavbarPopupMenu.text=導覽列
group.NavigateInFileGroup.text=在檔案中導覽
group.NewElement.text=新增(_N)
group.NewElementInMenuGroup.text=新增(_N)
group.NewElementMenu.text=新增(_N)
group.NewFromTemplate.text=從模板
group.NewGroup.text=新增(_N)
group.NewGroup1.text=新組(1)
group.NewWebDevelopment.text=Web 開發模板
group.NewXml.text=XML
group.NewXmlDescriptor.text=XML 組態檔案
group.Notifications.text=通知
group.OpenEventLogFileAction.description=在 IDE 中開啟活動事件日誌檔案
group.OpenEventLogFileAction.text=在編輯器中開啟事件日誌
group.OpenEventsSchemeFileAction.description=在 IDE 中開啟事件方案檔案
group.OpenEventsTestSchemeFileAction.description=在 IDE 中開啟事件測試方案檔案
group.OpenInBrowserEditorContextBarGroupAction.description=開啟位置…
group.OpenInBrowserGroup.EditorTabPopup.text=瀏覽器
group.OpenProjectGroup.text=開啟專案動作
group.OpenProjectWindows.text=開啟專案視窗
group.OpenRecentEditorInBlankDiffWindow.text=切換到最近
group.OtherMenu.description=未正確註冊的動作
group.OtherMenu.text=其他
group.OverrideFileTypeAction.bundledPlugin=捆綁
group.OverrideFileTypeAction.fromNamedPlugin=自 ''{0}'' 延伸模組
group.OverrideFileTypeAction.title=選擇檔案類型
group.PairFileActions.text=檔案對的動作
group.PasteGroup.text=貼上
group.Patch.MainMenu.text=補丁檔案
group.PopupMenuActions.text=彈出選單動作
group.PrintExportGroup.text=列印/匯出動作
group.ProblemsView.Options.description=允許對問題進行分類和篩選
group.ProblemsView.Options.text=檢視選項
group.ProblemsView.Show.text=顯示
group.ProblemsView.SortBy.text=排序依據
group.ProjectView.ToolWindow.Appearance.Actions.text=樹外觀
group.ProjectView.ToolWindow.SecondaryActions.text=專案檢視選項
group.ProjectViewAnalysisGroup.text=分析動作
group.ProjectViewCompileGroup.text=編譯/偵錯動作
group.ProjectViewPopupMenu.text=專案檢視彈出視窗選單
group.ProjectViewPopupMenuModifyGroup.text=專案檢視彈出視窗選單修改組
group.ProjectViewPopupMenuRefactoringGroup.text = 專案檢視彈出視窗重構組
group.ProjectViewPopupMenuRunGroup.text=專案檢視彈出視窗選單執行組
group.ProjectViewPopupMenuSettingsGroup.text=專案檢視彈出視窗選單設定組
group.RefactoringMenu.text=重構(_R)
group.RefactoringMenu1.text=重構動作(1)
group.RefactoringMenu2.text=重構動作(2)
group.RegistrationActions.text=註冊動作
group.ResizeToolWindowGroup.text=調整大小
group.RestoreNamedLayoutGroup.text=還原布局(_L)
group.RevealGroup.text=開啟於
group.RightToolbarSideGroup.text=右側
group.RunContextGroupMore.text=更多執行/偵錯
group.RunContextPopupGroup.text=執行組態
group.RunDashboard.Filter.text=組態狀態
group.RunDashboard.GroupBy.text=組態
group.RunMenu.text=執行(_U)
group.Runner.Layout.description=布局組態
group.Runner.Layout.text=布局
group.RunnerActions.text=執行/偵錯
group.RunnerActionsTouchbar.text=Touch Bar 執行/偵錯動作
group.ScrollPaneActions.text=滾動
group.SearchEverywhereActions.text=隨處搜尋
group.ServiceView.AddService.text=新增服務
group.ServiceView.Filter.text=篩選器
group.ServiceView.GroupBy.text=分組依據
group.ServiceView.OpenInNewTabGroup.text=在新頁籤中開啟
group.Shelve.KeymapGroup.text=擱置
group.ShelvedChangesToolbar.ViewOptions.text=檢視選項
group.ShowAnnotateOperationsPopupGroup.text=註解行
group.ShowFilterPopup.text=顯示篩選器彈出視窗
group.ShowRecentFindUsagesGroup.description=選擇並重新執行最近的尋找用法
group.ShowRecentFindUsagesGroup.text=最近的尋找用法
group.StandardMacroActions.text=標準巨集動作
group.StoreLayoutGroup.text=存儲布局(_S)
group.SwitcherAndRecentFiles.text=切換器(RecentFiles)動作
group.TW.ViewModeGroup.text=檢視模式
group.TWViewModes.text=工具視窗檢視模式
group.TWViewModesLegacy.text=工具視窗傳統檢視模式(已棄用)
group.TableActions.text=表動作
group.TabsActions.text=頁籤
group.TextEditorWithPreview.SplitGroup.text=拆分布局
group.TipsAndFeatures.text=提示和功能
group.TodoMainGroup.text=TODO
group.TodoViewGroupByGroup.text=分組依據
group.ToggleBreakpointAction.text=中斷點動作
group.ToolWindowsGroup.text=工具視窗(_T)
group.ToolbarFindGroup.text=工具列尋找動作
group.ToolbarMakeGroup.text=工具列 Make 動作
group.ToolbarRunGroup.text=工具列執行動作
group.ToolsBasicGroup.description=基本工具組
group.ToolsBasicGroup.text=基本工具組
group.ToolsMenu.text=工具(_T)
group.ToolsXmlGroup.text=XML 動作
group.TopAnomalies.text=熱門異常
group.TopStripeActionGroup.text=單個工具視窗列
group.TouchBar.text=觸控列
group.TouchBarDebug.ForceStepButtons.text=偵錯器強制步動作
group.TouchBarDebug.StepButtons.text=偵錯器步動作
group.TouchBarDebug.text=偵錯器
group.TouchBarDebug_alt.text=使用 Alt 鍵的偵錯器
group.TouchBarDefault.text=預設
group.TouchBarDefaultOptionalGroup.text=可選動作
group.TouchBarDefault_alt.text=預設使用 Alt 鍵
group.TouchBarDefault_cmd.alt.text=預設使用 Alt+Cmd 鍵
group.TouchBarDefault_cmd.text=預設使用 Cmd 鍵
group.TouchBarDefault_ctrl.text=預設使用 Ctrl 鍵
group.TouchBarDefault_shift.text=預設使用 Shift 鍵
group.TreeActions.text=樹動作
group.UpdateEventsSchemeAction.description=必要時更新伺服器中的主要事件方案。也重新載入該檔案中的事件測試方案。
group.UpdateEventsSchemeAction.text=更新事件方案
group.Vcs.Browse.text=瀏覽 VCS 儲存庫
group.Vcs.Import.text=匯入到版本控制
group.Vcs.KeymapGroup.text=版本控制系統
group.VcsFileGroupPopup.text=版本控制組
group.VcsGlobalGroup.text=VCS 組
group.VcsGroup.text=版本控制
group.VcsGroups.text=Git(_G)
group.VcsToolbarActions.text=VCS 動作
group.VersionControlsGroup.text=VCS/LVCS 動作
group.ViewAppearanceGroup.text=外觀(_A)
group.ViewMenu.text=檢視(_V)
group.ViewRecentActions.text=檢視最近的動作組
group.ViewStatusBarWidgetsGroup.description=顯示/隱藏狀態列小工具
group.ViewStatusBarWidgetsGroup.text=狀態列小工具(_W)
group.WeighingNewGroup.text=新增(_N)
group.WelcomeScreen.KeymapGroup.text=歡迎頁面
group.WelcomeScreen.MoveToGroup.text=移至組
group.WelcomeScreen.Options.text=選項選單
group.WindowMenu.text=視窗(_W)
group.XDebugger.settings.text=偵錯設定
group.XmlGenerateToolsGroup.text=XML 生成動作
group.compare.contents.text=比較內容
group.popup@ExpandableBookmarkContextMenu.text=書籤
group.reopen.mac.text=開啟最近(_R)
group.reopen.win.text=重新開啟專案(_R)
save.file.as.template=將檔案另存為模板
separator.Local.History.text=本地歷史記錄
separator.show=顯示
show.log.in.action.text=在{0}中顯示日誌
show.log.notification.text=檢視日誌"
`;

exports[`src messages/DiffBundle.properties 1`] = `
"action.Anonymous.text.apply.non.conflicting.changes=套用不衝突的更改:
action.Combined.Diff.NextChange.text=下一個檔案
action.Combined.Diff.PrevChange.text=上一個檔案
action.merge.apply.non.conflicts.all.text=所有
action.merge.apply.non.conflicts.left.text=左側
action.merge.apply.non.conflicts.right.text=右側
action.presentation.RefreshDirDiffAction.text=重新整理
action.presentation.diff.accept.text=接受
action.presentation.diff.append.text=追加
action.presentation.diff.append.to.the.side.text=追加到 {0, choice, 0#左側|1#右側}
action.presentation.diff.include.into.commit.area.marker.text=現在，差異檢視中將忽略此塊中的某些更改。<br>通過選中該複選框，您將包括此列指示要提交的所有行。
action.presentation.diff.include.into.commit.text=包含到提交中
action.presentation.diff.revert.text=還原
action.presentation.go.to.change.text=轉到更改
action.presentation.merge.ignore.text=忽略
action.presentation.merge.resolve.automatically.text=自動解決
action.presentation.merge.resolve.text=解決
action.presentation.merge.resolve.using.side.text=使用{0, choice, 0#左側|1#右側} 解決
action.use.external.tool.text=使用以下內容顯示差異: {0}
advanced.setting.show.diff.as.editor.tab=作為編輯器頁籤開啟差異
advanced.setting.show.diff.as.editor.tab.description=如果啟用，請使用編輯器頁籤代替框架視窗來顯示差異
advanced.settings.vcs=版本控制
apply.changes.and.mark.resolved=套用更改並標記為已解決
apply.partially.resolved.merge.dialog.title=套用更改
apply.patch.all.changes.processed.message.text=所有區塊均已被處理。<br><a href="">儲存更改並完成解決</a>
apply.patch.partially.resolved.changes.confirmation.message={0, choice, 1#1 個區塊|2#{0, number} 個區塊}未處理。\\n要儲存更改並完成解決嗎?
apply.somehow.status.message.all.applied=已解決所有區塊
apply.somehow.status.message.already.applied={0, number} 個{0, choice, 1#區塊|2#區塊}已套用
apply.somehow.status.message.cant.apply=無法套用 {0, number} 個{0, choice, 1#區塊|2#區塊}
apply.somehow.status.message.cant.apply.some=無法套用 {0, number} 個區塊，共 {1, number} 個
binary.diff.contents.are.different.message.text=檔案內容不同
binary.diff.contents.are.identical.message.text=檔案內容相同
binary.file.viewer=二進制檔案檢視器
blank.diff.recent.content.summary.text.date={0} ({1})
blank.diff.recent.content.summary.text.length.date={0} ({1} 字元，{2})
button.abort.resolve=中止解決
button.associate.file.type=關聯
button.cancel.merge=取消合併
button.continue.merge=繼續合併
button.dirdiff.filter=過濾(&F):
button.discard.changes.and.do=捨棄更改並{0}
button.hide.notification=隱藏
button.merge.resolve.accept.left=接受左側
button.merge.resolve.accept.right=接受右側
button.merge.resolve.apply=套用
button.merge.resolve.cancel=取消
button.reload.diff.request=重新載入
can.t.copy.file=無法複製檔案
can.t.finish.merge.resolve=無法解決合併衝突
can.t.load.some.changes=無法載入某些更改
can.t.show.diff.in.external.tool=無法在外部工具中顯示差異
can.t.show.diff.in.external.tool.too.many.files=選擇的檔案過多，無法使用外部工具開啟，{0} 未開啟。
can.t.show.merge.in.external.tool=無法在外部工具中顯示合併
cancel.visual.merge.dialog.title=取消檔案合併
cannot.create.file.error=無法建立檔案: {0}
cannot.find.file.error=找不到檔案: {0}
changing.highlighting.requires.the.file.merge.restart=更改醒目提示需要重啟檔案合併。是否捨棄未儲存的更改並重啟合併?
collapse.unchanged.fragments=摺疊未更改的片段
column.dirdiff.date=日期
column.dirdiff.name=名稱
column.dirdiff.size=大小
combined.side.by.side.viewer=拆分
combined.unified.viewer=統合
compare.0.with.1=比較 ''{0}'' 和 ''{1}''
compare.by=比較依據:
compare.selected.new.files=將左側和右側的所選新檔案相互比較。
configurable.DiffSettingsConfigurable.display.name=差異與合併
configurable.ExternalDiffSettingsConfigurable.display.name=外部差異工具
configurable.diff.collapse.unchanged.ranges.disable=停用
confirm.delete=確認刪除
continue.merge=繼續合併
copy.content.to.side=將內容複製到{0, choice, 0#左側|1#右側}
data.has.been.changed.externally.reloading.data=資料已在外部更改。正在重新載入資料…
delete.0.items=刪除 {0} 項?
dialog.title.diff.for.range=範圍的差異
diff.actions=差異動作
diff.all.differences.ignored.text=已忽略差異
diff.application.usage.parameters.and.description=用法: {0} 差異 <left file> <right file> [<base file>]
diff.cant.calculate.diff=無法計算差異
diff.clipboard.vs.editor.dialog.title=剪貼簿與編輯器
diff.clipboard.vs.value.dialog.title=剪貼簿與所選值
diff.content.clipboard.content.title=來自剪貼簿
diff.content.editor.content.title=編輯器
diff.content.selected.value=所選值
diff.content.selection.from.file.content.title={0}中的選區
diff.content.title.current.range=當前
diff.content.title.up.to.date=基本修訂
diff.contents.are.identical.message.text=內容相同
diff.contents.have.differences.only.in.charset.and.line.separators.message.text=內容僅在行分隔符和編碼中有差異
diff.contents.have.differences.only.in.charset.message.text=內容僅在編碼中有差異
diff.contents.have.differences.only.in.line.separators.message.text=內容僅在行分隔符中有差異
diff.count.differences.status.text={0, choice, 0#沒有|1#1個|2#{0, number}個}差異
diff.element.qualified.name.vs.element.qualified.name.dialog.title={0} 與 {1}
diff.file.editor.name=差異
diff.files.count.files.in.text=({0} 中)
diff.files.count.hyperlink.text={0} 個檔案
diff.files.dialog.title=差異
diff.files.generic.request.title=更改
diff.highlighting.disabled.text=差異醒目提示處於關閉狀態
diff.inactive.count.differences.status.text=({0} 停用)
diff.progress.spinner.tooltip.text=正在計算差異
diff.tool=差異工具
diff.type.changed.name=已更改
diff.type.conflict.name=衝突
diff.type.deleted.name=已刪除
diff.type.inserted.name=已插入
diff.unchanged.lines.folding.marker.renderer=標記: 已摺疊的未更改的行
diff.utf.charset.name.bom.suffix={0} BOM
diff.version.title.after=之後
diff.version.title.before=之前
dirdiff.mode.binary.content=二進制內容
dirdiff.mode.size=大小
dirdiff.mode.size.and.timestamp=大小和時間戳
dirdiff.mode.text=文本
directory.diff=目錄差異
directory.diff.actions=目錄差異動作
directory.viewer=目錄檢視器
disable.editing=停用編輯
discard.changes.and.restart.merge=捨棄更改並重啟合併
do.not.ask.me.again=不再詢問我
editing.viewer.hint.enable.editing.text=此檢視為唯讀。<a href="">啟用編輯</a>
editor.settings=設定
error.can.not.calculate.diff.file.too.big=無法計算差異。檔案太大且更改太多。
error.can.not.calculate.diff.operation.canceled=無法計算差異。動作已取消。
error.cannot.show.diff=無法顯示差異
error.cannot.show.merge=無法顯示合併
error.cant.resolve.conflicts.in.a.read.only.file=無法解決唯讀檔案中的衝突
error.cant.show.diff.cant.load.revision.content=無法獲取此修訂中的內容
error.cant.show.diff.cant.show.for.directory=無法顯示目錄的差異
error.cant.show.diff.content.not.found=無法顯示差異: 找不到內容
error.cant.show.diff.file.not.found=無法顯示差異: 找不到檔案
error.cant.show.diff.for.unknown.file=無法顯示未知檔案類型的差異
error.cant.show.diff.message=錯誤: 無法顯示差異
error.cant.show.dirdiff.preview.cant.load.content=無法獲取內容
error.cant.show.file=無法顯示檔案
error.cant.show.merge.file.not.found=無法顯示合併衝突: 找不到檔案
error.cant.show.merge.operation.not.supported=無法顯示合併衝突: 此動作不受支援
error.cant.show.merge.project.not.found=無法顯示合併衝突: 未知專案類型
error.conflict.is.not.valid.and.no.longer.can.be.resolved=衝突無效，無法再解決。
error.content.decoded.with.wrong.charset=內容解碼出錯(使用 ''{0}'' 字符集)
error.file.is.too.large.only.preview.is.loaded=檔案太大。僅載入預覽。
error.files.too.large.to.compare.text=檔案太大，無法比較
error.message.cannot.show.diff=無法顯示差異
error.message.cannot.show.merge=無法顯示合併
error.operation.canceled=動作已被取消
error.viewer=錯誤檢視器
filetype.diff.description=差異
hide.this.notification=隱藏此通知
highlight.words=醒目提示顯示單詞
highlighting.level=醒目提示級別
label.cant.show.diff.with.description=無法顯示差異: {0}
label.cant.show.merge.with.description=無法顯示合併: {0}
label.default.diff.editor.tab.name=差異
label.diff.settings.path=設定 | 工具 | 差異和合併
label.diff.settings.path.macos=偏好設定 | 工具 | 差異和合併
label.dirdiff.loading.file=正在載入… {0}
label.merge.unsaved.changes.discard.and.do.anyway=結果檔案中有未儲存的更改。捨棄更改並繼續{0}嗎?
launching.external.tool=正在啟動外部工具…
mark.as.resolved=標記為已解決
merge.all.changes.processed.message.text=所有更改均已被處理。<br><a href="">儲存更改並完成合併</a>
merge.application.usage.parameters.and.description=用法: {0} 合併 <left file> <right file> [<base file>] <output file>
merge.color.options.background.color.label=重要
merge.color.options.dialog.title=合併顏色選項
merge.color.options.ignored.color.label=已忽略
merge.conflict.is.outdated=合併衝突已過時。在衝突解決開始之前還原檔案內容?
merge.continue.button=繼續(&C)
merge.dialog.accept.change.command=接受更改
merge.dialog.all.conflicts.resolved.message.text=已解決所有衝突
merge.dialog.apply.non.conflicted.changes.command=套用不衝突的更改
merge.dialog.apply.partially.resolved.changes.confirmation.message={0, choice, 0#'{1, choice, 1#有|2#有}'|1#有|2#有} {0, choice, 0#|1#1 個更改|2#{0, number} 個更改}{0, choice, 0#|1#'{1, choice, 0#|1#和 }'}{1, choice, 0#|1#1 個衝突|2#{1, number} 個衝突}未處理。\\n仍要儲存更改並將衝突標記為解決嗎?
merge.dialog.exit.without.applying.changes.confirmation.message=確定要退出登入且不套用更改嗎?
merge.dialog.ignore.change.command=忽略更改
merge.dialog.resolve.conflict.command=解決衝突
merge.differences.status.text={0, choice, 0#沒有更改|1#1 個更改|2#{0, number} 個更改}。{1, choice, 0#沒有衝突|1#1 個衝突|2#{1, number} 個衝突}。
merge.files.dialog.title=合併
merge.in.external.tool=在外部工具中合併
merge.save.and.finish.button=儲存並完成(&F)
merge.tool=合併工具
merge.version.title.base=基礎版本
merge.version.title.current=當前版本:
merge.version.title.merged=合併版本
merge.version.title.merged.result=結果
merge.version.title.our=您的版本
merge.version.title.their=來自伺服器的更改
merge.version.title.their.with.revision=來自伺服器的更改 (修訂版 {0})
merge.window.title.file=合併 {0}
message.do.in.merge.command=合併時 {0}
message.init.merge.content.command=初始化合併內容
message.replace.change.command=取代更改
message.resolve.simple.conflicts.command=解決簡單的衝突更改
message.use.selected.changes.command={0}所選更改
notification.action.text.blank.diff.recent=最近
notification.action.text.blank.diff.select.file=選擇檔案…
notification.status.content.added=內容已新增
notification.status.content.removed=內容已移除
notification.you.can.disable.this.feature.in.0=您可以在 {0} 中停用此功能
option.highlighting.level.inspections=檢查
option.highlighting.level.none=無
option.highlighting.level.syntax=語法
option.highlighting.policy.group.name=醒目提示顯示模式
option.highlighting.policy.lines=醒目提示行
option.highlighting.policy.none=不醒目提示顯示
option.highlighting.policy.split=醒目提示拆分的更改
option.highlighting.policy.symbols=醒目提示顯示字元
option.highlighting.policy.words=醒目提示顯示單詞
option.ignore.policy.formatting=忽略格式化
option.ignore.policy.group.name=忽略更改
option.ignore.policy.none=不忽略
option.ignore.policy.trim=修整空白
option.ignore.policy.whitespaces=忽略空格
option.ignore.policy.whitespaces.empty.lines=忽略空格和空行
option.inherit.ignored.color=繼承忽略的顏色
option.three.side.color.policy.left.to.right=左到右
option.three.side.color.policy.merge.conflict=合併衝突
option.three.side.color.policy.merge.resolved=解決的合併衝突
press.again.to.go.to.the.next.file=再按一次轉到下一個檔案
press.again.to.go.to.the.previous.file=再按一次轉到上一個檔案
press.mark.as.resolve=在外部工具中解決完衝突時，按“標記為已解決”
progress.title.loading.requests=正在載入請求
refresh.failed.message=重新整理失敗: {0}
rollback.change.command.name=回滾更改
select.external.program.dialog.title=選擇外部程序
select.file.to.compare=選擇要比較的檔案
settings.automatically.apply.non.conflicting.changes=自動套用不衝突的更改
settings.context.lines=上下文行:
settings.diff.name=差異
settings.external.diff.base.file.content=基檔案內容
settings.external.diff.comboBox.value.unknown.filetype.text={0} (未知)
settings.external.diff.enable.external.tools=啟用外部工具
settings.external.diff.left.file.content=左側檔案內容
settings.external.diff.merge.conflict.resolve.successful=合併衝突解決成功。\\n已解決的內容為:\\n{0}
settings.external.diff.merge.conflict.resolve.was.canceled=合併衝突解決已取消。
settings.external.diff.original.output.file.content=原始輸出檔案內容
settings.external.diff.panel.table.title=組態與檔案類型關聯的外部差異/合併工具:
settings.external.diff.panel.tree.title=組態外部工具:
settings.external.diff.right.file.content=右側檔案內容
settings.external.diff.table.difftool.column=差異工具
settings.external.diff.table.filetype.column=檔案類型
settings.external.diff.table.mergetool.column=合併工具
settings.external.diff.table.remove.dialog.message=確定要刪除此條目嗎?
settings.external.diff.table.remove.dialog.title=移除外部差異工具
settings.external.diff.test.complete=測試完成
settings.external.diff.test.diff=測試差異
settings.external.diff.test.merge=測試合併
settings.external.diff.test.three.side.diff=測試三向差異
settings.external.diff.trust.process.exit.code=信任程序退出程式碼
settings.external.tool.tree.add.dialog.field.argument.pattern=實參模式
settings.external.tool.tree.add.dialog.field.group=工具組
settings.external.tool.tree.add.dialog.field.program.path=程序路徑
settings.external.tool.tree.add.dialog.field.tool.name=工具名稱
settings.external.tool.tree.add.dialog.title=新增外部工具
settings.external.tool.tree.edit.dialog.title=編輯外部工具
settings.external.tool.tree.remove.warning.message=此工具用於組態。首先移除表中的組態
settings.external.tool.tree.remove.warning.title=無法刪除所選工具
settings.external.tool.tree.validation.already.exist=名稱為“{1}”的 {0} 已存在
settings.external.tool.tree.validation.empty=外部工具名稱不得為空
settings.external.tools.parameters.description=不同的工具有不同的參數。按正確的順序指定所有必要的參數非常重要:
settings.external.tools.parameters.diff=<b>%1</b> - 左(本地更改)<br><b>%2</b> - 右(伺服器內容)<br><b>%3</b> - 基礎(沒有本地更改的當前版本)
settings.external.tools.parameters.merge=<b>%1</b> - 左(本地更改)<br><b>%2</b> - 右(伺服器內容)<br><b>%3</b> - 基礎(沒有本地更改的當前版本)<br><b>%4</b> - 輸出(合併結果)
settings.external.tools.test.process.exit.text=程序已終止: exitCode ''{0}''
settings.go.to.the.next.file.after.reaching.last.change=到達上次更改後轉到下一個檔案
settings.highlight.modified.lines.in.gutter=在裝訂區域中醒目提示修改的行
settings.merge.text=合併
side.by.side.viewer=並排檢視器
synchronize.document.and.its.fragment=同步文檔及其片段
synchronize.document.and.its.fragment.range.error=選區無效
synchronize.editors.settings=同步編輯器設定
synchronize.scrolling=同步滾動
tooltip.merge.ctrl.click.to.resolve.conflict=Ctrl+點擊來解決衝突
unified.viewer=統合檢視器
update.highlighting.settings=更新醒目提示設定
use.space.button.or.mouse.click=使用空格按鈕或滑鼠點擊來更改選定元素的動作。按回車鍵執行。
use.space.button.to.change.operation=使用空格按鈕更改動作
vcs.marker.changed.line=VCS 標記: 更改的行
waiting.for.external.tool=正在等待外部工具…"
`;

exports[`src messages/GitBundle.properties 1`] = `
"MainToolbarQuickActions.vcs.separator=VCS
abort=中止
abort.operation.cherry.pick.name=優選
abort.operation.dialog.msg=中止 {0}{1}?
abort.operation.dialog.title=中止 {0}
abort.operation.failed={0} 中止失敗
abort.operation.indicator.text=git {0} --abort{1}
abort.operation.merge.name=合併
abort.operation.progress.title=正在中止 {0} 程序
abort.operation.revert.name=還原
abort.operation.succeeded={0} 中止成功
action.CopyPathFromRepositoryRootProvider.text=版本庫根路徑
action.Git.Add.text=新增
action.Git.Branches.text=分支(_B)…
action.Git.BrowseRepoAtRevision.text=在修訂版中顯示版本庫
action.Git.Checkout.Branch.description=簽出所選分支
action.Git.Checkout.Branch.text=簽出所選…
action.Git.CheckoutRevision.text=簽出修訂
action.Git.CherryPick.Abort.text=中止優選
action.Git.Clone.text=克隆…
action.Git.Commit.Stage.text=提交…
action.Git.Compare.Selected.description=相互比較選定分支
action.Git.Compare.Selected.description.disabled=從同一版本庫中選擇分支
action.Git.Compare.Selected.title=比較分支
action.Git.Compare.With.Current.title=與當前分支進行比較
action.Git.CompareWithBranch.text=與分支比較…
action.Git.CompareWithTag.text=與標記比較…
action.Git.Configure.Remotes.text=管理遠端…
action.Git.CreateNewBranch.description=從所選提交開始建立新分支
action.Git.CreateNewBranch.text=新增分支…
action.Git.CreateNewTag.description=建立指向此提交的新標籤
action.Git.CreateNewTag.text=新增標記…
action.Git.Delete.Branch.title=刪除{0,choice,1#分支|2#分支}
action.Git.Drop.Commits.text=刪除提交
action.Git.Fetch.description.fetch.in.progress=正在獲取…
action.Git.Fetch.text=獲取
action.Git.Fetch.title=獲取所有遠端
action.Git.Fixup.To.Commit.description=建立 fixup 提交
action.Git.Fixup.To.Commit.text=Fixup…
action.Git.Init.Stage.error=向 Git 新增檔案失敗
action.Git.Init.Vcs.Toolbar.Widget.text=建立 Git 版本庫…
action.Git.Init.error=Git init 失敗
action.Git.Init.text=建立 Git 版本庫…
action.Git.Interactive.Rebase.description=顯示互動重定基底的對話框，可以在該對話中對提交執行壓縮、fixup、重新排序、移除和改寫
action.Git.Interactive.Rebase.text=從這裡進行互動重定基底…
action.Git.Loading.Branches.progress=正在載入分支…
action.Git.Log.Branches.Change.Branch.Filter.On.Selection.description=選擇分支後，按此分支篩選日誌
action.Git.Log.Branches.Change.Branch.Filter.On.Selection.text=更新分支篩選器
action.Git.Log.Branches.Change.Branch.Filter.description=使用所選分支更新日誌中的分支篩選器
action.Git.Log.Branches.Change.Branch.Filter.text=更新日誌中的分支篩選器
action.Git.Log.Branches.Navigate.Log.To.Branch.On.Selection.description=選擇分支後，在日誌中導覽到該分支 HEAD
action.Git.Log.Branches.Navigate.Log.To.Branch.On.Selection.text=在日誌中導覽到分支 Head
action.Git.Log.Branches.Navigate.Log.To.Selected.Branch.text=在日誌中導覽到所選分支 Head
action.Git.Log.DeepCompare.description=醒目提示尚未優選到當前分支的提交
action.Git.Log.DeepCompare.text=無優選提交
action.Git.Log.Edit.Remote.text=編輯遠端
action.Git.Log.Hide.Branches.text=隱藏 Git 分支
action.Git.Log.Remove.Remote.text=移除{0,choice,1#遠端|2#遠端}
action.Git.Log.Show.Branches.text=分支
action.Git.Log.text=顯示 Git 版本庫日誌…
action.Git.Merge.Abort.text=中止合併
action.Git.Merge.text=合併…
action.Git.New.Branch.description=僅選擇一個分支以繼續建立新分支
action.Git.New.Branch.dialog.title=從 {0} 建立分支
action.Git.Pull.text=拉取…
action.Git.PushUpToCommit.description=推送所有之前的提交，包括所選提交
action.Git.PushUpToCommit.text=推送此前所有提交…
action.Git.Rebase.Abort.text=中止重定基底
action.Git.Rebase.Continue.text=繼續重定基底
action.Git.Rebase.Skip.progress.title=重定基底期間跳過提交…
action.Git.Rebase.Skip.text=跳過提交
action.Git.Rebase.operation.name=重定基底
action.Git.Rebase.text=重定基底…
action.Git.Rename.Local.Branch.description=重新命名本地分支
action.Git.Rename.Local.Branch.text=重新命名…
action.Git.Reset.In.Log.text=將當前分支重設到此處…
action.Git.Reset.text=重設 HEAD…
action.Git.ResolveConflicts.text=解決衝突…
action.Git.Revert.Abort.text=中止還原
action.Git.Revert.In.Log.description=生成新提交，這會還原在原始提交中所做的更改
action.Git.Revert.In.Log.template.text=還原{0,choice,1#提交|2#提交}
action.Git.Revert.In.Log.text=還原提交
action.Git.Reword.Commit.description=通過 git rebase 或 amend 的改寫選項更改提交訊息
action.Git.Reword.Commit.text=編輯提交訊息…
action.Git.Show.My.Branches.description.calculating.branches.progress=正在計算我的分支
action.Git.Show.My.Branches.description.is.my.branch=如果分支的所有獨佔提交都是由“我”(即當前 Git 作者)執行的，則此分支為“我的”。
action.Git.Show.My.Branches.description.not.all.roots.indexed=並沒有為所有版本庫編制索引。
action.Git.Show.My.Branches.description.not.graph.ready=該日志尚未就緒，請稍候。
action.Git.Show.My.Branches.description.not.support.indexing=某些版本庫不支持索引。
action.Git.Show.My.Branches.title=顯示我的分支
action.Git.Show.Stage.text=顯示暫存區域
action.Git.Show.Stash.description=顯示“Git 隱藏”工具視窗頁籤
action.Git.Show.Stash.text=顯示 Git 隱藏
action.Git.ShowBranches.pretty.description=顯示分支
action.Git.ShowBranches.text=顯示分支
action.Git.Squash.Commits.text=壓縮提交…
action.Git.Squash.Into.Commit.description=建立壓縮提交
action.Git.Squash.Into.Commit.text=壓縮到…
action.Git.Stage.Add.All.description=將所有未暫存的更改和未追蹤的檔案新增到索引
action.Git.Stage.Add.All.text=全部暫存
action.Git.Stage.Add.Tracked.description=將追蹤檔案中所有未暫存的更改新增到索引
action.Git.Stage.Add.Tracked.text=暫存全部已追蹤項
action.Git.Stage.Compare.Local.Staged.text=與暫存版本比較
action.Git.Stage.Compare.Staged.Head.text=與 HEAD 版本比較
action.Git.Stage.Compare.Staged.Local.text=與本地版本比較
action.Git.Stage.Compare.Three.Versions.text=比較 HEAD 版本、暫存版本和本地版本
action.Git.Stage.Show.Local.description=在編輯器中顯示當前檔案的本地內容
action.Git.Stage.Show.Local.text=顯示本地版本
action.Git.Stage.Show.Staged.description=在編輯器中顯示當前檔案的暫存內容
action.Git.Stage.Show.Staged.text=顯示暫存版本
action.Git.Stage.ThreeSideDiff.description=顯示包含 HEAD、暫存和本地版本的差異視窗，從中可以互動地將更改新增到暫存區域
action.Git.Stage.ThreeSideDiff.text=比較 HEAD 版本、暫存版本和本地版本
action.Git.Stash.Apply.description=套用所選隱藏
action.Git.Stash.Apply.text=套用
action.Git.Stash.Drop.description=丟棄所選隱藏
action.Git.Stash.Drop.text=刪除
action.Git.Stash.Pop.description=彈出所選隱藏
action.Git.Stash.Pop.text=彈出
action.Git.Stash.Refresh.description=重新整理隱藏列表
action.Git.Stash.Refresh.text=重新整理隱藏
action.Git.Stash.Silently.text=無提示隱藏
action.Git.Stash.UnstashAs.description=彈出或套用選定的隱藏作為新分支(帶或不帶索引)
action.Git.Stash.UnstashAs.text=取消隱藏…
action.Git.Stash.text=隱藏更改…
action.Git.Tag.text=新增標記…
action.Git.Toggle.Favorite.title=標記/取消標記為收藏項
action.Git.Toolbar.ShowMoreActions.description=VCS 動作
action.Git.Toolbar.ShowMoreActions.text=版本控制
action.Git.Uncommit.description=撤消最後一次提交並將其更改放入所選更改列表
action.Git.Uncommit.text=撤消提交…
action.Git.Unstash.text=取消隱藏更改…
action.Git.Update.Selected.description=從追蹤的遠端獲取並使用 {1} 或像 \`git fetch branch:branch\` 一樣的快進(如果可能)更新所選{0,choice,1#分支|2#分支}
action.Git.Update.Selected.description.already.running=更新已在執行
action.Git.Update.Selected.description.select.non.current=僅選擇非當前分支
action.Git.Update.Selected.description.tracking.not.configured=沒有為所選{0,choice,1#分支|2#分支}組態追蹤分支
action.Git.Update.Selected.text=更新所選
action.New.Branch.disabled.fresh.description=無法在空版本庫中建立新分支。首先進行初始提交
action.New.Branch.disabled.several.commits.description=選擇單個提交以建立新分支
action.NotificationAction.GitDeleteBranchOperation.text.delete.tracked.branch=刪除追蹤的分支
action.NotificationAction.GitDeleteBranchOperation.text.restore=還原
action.NotificationAction.GitDeleteBranchOperation.text.view.commits=檢視提交
action.NotificationAction.GitDeleteTagOperation.text.restore=還原
action.NotificationAction.GitMergeAction.text.view.commits=檢視提交
action.NotificationAction.GitRewordOperation.text.undo=撤消
action.NotificationAction.GitUpdateSession.text.view.commits=檢視提交
action.NotificationAction.GithubNotifications.text.configure=組態…
action.NotificationAction.text.resolve=解決…
action.addQuickAction.Git.Commit.text=提交…
action.addQuickAction.Git.Diff.text=顯示差異...
action.addQuickAction.Git.History.text=顯示歷史記錄...
action.addQuickAction.Git.Push.text=推送…
action.addQuickAction.Git.Rollback.text=回滾...
action.addQuickAction.Git.Update.text=更新專案...
action.description.cant.revert.merge.commit=不允許還原合併提交
action.fetch.text=獲取
action.git4idea.commands.TestGitHttpLoginDialogAction.text=測試 Git 登入對話框
action.label.add.unstaged.range=暫存
action.label.add.unstaged.range.tooltip=向索引中新增新的更改
action.label.reset.staged.range=取消暫存
action.label.reset.staged.range.tooltip=移除索引中的更改
action.main.toolbar.git.Branches.text=VCS 小工具
action.not.possible.in.fresh.repo.checkout=簽出
action.not.possible.in.fresh.repo.generic=動作
action.not.possible.in.fresh.repo.push=正在推送提交
action.not.possible.in.fresh.repo.rename.branch=正在重新命名分支
action.not.possible.in.fresh.repo.show.diff=正在比較修訂
action.selected.directory.text=選定{0,choice,1#目錄|2#目錄}
action.selected.file.text=選定{0,choice,1#檔案|2#檔案}
activity.name.rebase=重定基底
activity.name.unstash=取消隱藏
activity.name.update=VCS 更新
add.adding=正在新增檔案…
advanced.setting.git.branch.cleanup.symbol=分支名稱清理符號
advanced.setting.git.branch.cleanup.symbol.description=將在 git 分支名稱中代替停用符號的符號
advanced.setting.git.clone.recurse.submodules=遞迴克隆專案中的子模組
advanced.setting.git.clone.recurse.submodules.description=啟用後，從 Git 呼叫 'git clone --recurse-submodules' 簽出，即克隆主版本庫與所有子模組 (如有)
advanced.setting.git.read.content.with=從 Git 讀取時套用內容轉換
advanced.setting.git.read.content.with.description=從 Git 讀取檔案內容時為 'git cat-file' 指令使用 '--filters' 或 '--textconv' 標誌
advanced.setting.git.update.incoming.outgoing.info=檢查傳入和傳出提交
advanced.setting.git.update.incoming.outgoing.info.description=在“分支”彈出視窗中更新具有傳入/傳出提交的分支資訊
advanced.setting.git.use.push.force.with.lease=使用安全強制推送
advanced.setting.git.use.push.force.with.lease.description=從 IDE 呼叫強制推送時使用 '--force-with-lease'，而非僅使用 '--force'
advanced.setting.git.use.schannel.on.windows=使用 Windows 憑證存儲
advanced.setting.git.use.schannel.on.windows.description=強制 Git 使用 Windows 憑證存儲來驗證 SSL 連線。適用於 Git 2.14 及更高版本。
advanced.settings.git=版本控制. Git
annotate.cannot.annotate.dir=無法註解目錄
annotate.line.mismatch.exception=正在為第 {0} 行新增資訊，但應當為第 {1} 行新增資訊
annotate.output.lack.data=第 {0} 行的輸出缺少必要的資料
annotations.options.detect.movements.across.files=檢測跨檔案的移動
annotations.options.detect.movements.within.file=檢測檔案內的移動
annotations.options.group=選項
annotations.options.ignore.whitespaces=忽略空格
apply.changes.applied.for.commits={0} {1,choice,1#項提交|2#{1,number} 項提交} 來自於 {2}
apply.changes.everything.applied={0} 中的所有更改已被{1}
apply.changes.nothing.to.do=沒要有{0}的內容
apply.changes.operation.canceled={0} 已取消
apply.changes.operation.failed={0} 失敗
apply.changes.operation.performed.with.conflicts={0}已執行，但存在衝突
apply.changes.operation.successful={0}成功
apply.changes.operation.successful.for.commits=但是，對以下{1, choice,1#提交|2#提交}成功進行了{0}:
apply.changes.resolving.conflicts.progress.title=正在解決衝突…
apply.changes.skipped={0} {1,choice,1#被|2#被}跳過，因為所有更改已被{2}。
apply.changes.unresolved.conflicts.notification.abort.action.text=中止{0}
apply.changes.unresolved.conflicts.notification.resolve.action.text=解決…
apply.changes.unresolved.conflicts.text=工作樹中有未解決的衝突。
apply.changes.would.be.overwritten=您的本地更改將被 {0} 覆蓋。\\n\\
提交您的更改，或隱藏更改以繼續。
apply.conflict.dialog.description.label.text=在由 {2} 執行的提交 {1} 的{0}過程中發生衝突{3}
blob.not.found=找不到 Blob: {0} - {1}
branch.checking.out.branch.from.process=正在從 {1} 簽出 {0}…
branch.checking.out.new.branch.process=正在簽出新分支 {0}…
branch.checking.out.process=正在簽出 {0}…
branch.creating.branch.process=正在建立分支 {0}…
branch.deleting.branch.process=正在刪除 {0}…
branch.deleting.remote.branch=正在刪除 {0}…
branch.deleting.tag.on.remote.process=正在刪除遠端分支上的標記 {0}…
branch.deleting.tag.process=正在刪除標記 {0}…
branch.direction.panel.base.repo.label=base 版本庫:
branch.direction.panel.branch.label=分支:
branch.direction.panel.head.repo.label=head 版本庫:
branch.direction.panel.save.button=儲存
branch.direction.panel.select.link=選擇…
branch.direction.panel.warning.not.synced=本地分支未與遠端分支同步。\\n\\
''{0}'' 分支將與 ''{1}'' 同步。
branch.direction.panel.warning.push=''{0}'' 沒有遠端分支。\\n\\
將在 ''{1}'' 上建立新的遠端分支。
branch.merging.process=正在合併 {0}…
branch.not.fully.merged.dialog.all.commits.from.branch.were.merged=已合併來自分支 {0} 的所有提交
branch.not.fully.merged.dialog.repository.label=版本庫:
branch.not.fully.merged.dialog.restore.button=還原(&R)
branch.not.fully.merged.dialog.the.branch.was.not.fully.merged.to=分支 {0} 未完全合併到 {1}。<br/>以下是未合併提交的列表。
branch.not.fully.merged.dialog.title=分支未完全合併
branch.operation.could.not.0.operation.name.1.reference=無法{0} {1}
branch.operation.in={0} ({1} 中)
branch.rebasing.onto.process=正在重定基底到 ''{0}''…
branch.rebasing.process=正在重定基底 {0}…
branch.renaming.branch.process=正在將 {0} 重命名為 {1}…
branch.ui.handler.can.not.operation.name.because.of.unmerged.files=由於存在未合併的檔案而無法{0}
branch.ui.handler.delete.all=全部刪除
branch.ui.handler.delete.remote.branches=刪除遠端 {0,choice,1#分支|2#分支}
branch.ui.handler.delete.remote.branches.question=刪除遠端 {0,choice,1#分支|2#分支} {1}?
branch.ui.handler.delete.tracking.local.branch.as.well=同時刪除追蹤本地分支 {0}
branch.ui.handler.delete.tracking.local.branches=刪除追蹤本地分支:
branch.ui.handler.do.not.rollback=不回滾
branch.ui.handler.merge.error.notification.title=仍然存在未解決的檔案。
branch.ui.handler.merge.notification.description=以下檔案存在未解決的衝突。您需要先解決它們，然後再{0}。
branch.ui.handler.rollback=回滾
branch.ui.handler.unmerged.files.error.notification=您必須先<a href=''{0}''>解決</a>所有合併衝突，然後才能{1}。<br/>解決衝突之後，您可能還需要將檔案提交到當前分支。
branch.ui.handler.you.have.to.resolve.all.conflicts.before.operation.name=您必須先解決所有合併衝突，然後才能{0}。<br/>{1}
branch.worker.could.not.create.tag=無法{1,choice,0#|1#|2#在 {2} 中}建立標記 {0}
branches.action.delete=刪除
branches.action.pull.into.branch.using.merge=使用合並拉入 {0}
branches.action.pull.into.branch.using.merge.description=使用合並拉入 {0}
branches.action.pull.into.branch.using.merge.selected=使用合併拉入當前分支
branches.action.pull.into.branch.using.rebase=使用重定基底拉入 {0}
branches.action.pull.into.branch.using.rebase.description=使用重定基底拉入 {0}
branches.action.pull.into.branch.using.rebase.selected=使用重定基底拉入當前分支
branches.branch.0=分支 ''{0}''
branches.branches=分支
branches.checking.existing.commits.process=正在檢查現有提交…
branches.checkout=簽出
branches.checkout.and.rebase.error.current.with.same.name=無法覆蓋當前分支 {0}
branches.checkout.and.rebase.failed=簽出和重定基底失敗
branches.checkout.and.rebase.onto.branch=簽出並重定基底到 {0}
branches.checkout.and.rebase.onto.current=簽出並重定基底到當前分支
branches.checkout.and.rebase.onto.current.process=正在簽出 {0} 並重定基底到當前分支
branches.checkout.and.rebase.onto.in.one.step=簽出 {0}，並在一個步驟中將其重定基底到 {1} (類似於 \`git rebase HEAD {2}\`)
branches.checkout.local=簽出本地分支
branches.checkout.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。將 ''{0}'' 變基到 ''{1}''，還是簽出 ''{0}''?
branches.checkout.s=簽出 {0}
branches.checkout.tag.or.revision=簽出標記或修訂…
branches.checkout.with.reset.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。將 ''{0}'' 變基到 ''{1}''，還是刪除本地提交?
branches.compare.the.current.working.tree.with=將當前工作樹與 {0} 中的樹進行比較
branches.compare.with.branch=與{0}比較
branches.compare.with.current=與當前分支進行比較
branches.create.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。是否要在其他版本庫中建立分支?
branches.create.new.branch.dialog.title=建立新分支
branches.create.with.reset.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。是否要刪除本地提交?
branches.current.branch=當前分支
branches.current.branch.name=當前
branches.drop.local.commits=刪除本地提交
branches.enter.reference.branch.tag.name.or.commit.hash=輸入參照(分支、標記)名稱或提交雜湊:
branches.local.branches=本地分支
branches.local.branches.in.repo={0} 中的本地分支
branches.merge.into=將 {0} 合併到 {1} 中
branches.merge.into.current=合併到當前分支
branches.new.branch.from.branch=從 {0} 新增分支…
branches.new.branch.from.branch.current=從當前位置新增分支…
branches.new.branch.from.branch.description=從 {0} 建立新分支
branches.rebase.current.onto.selected=將當前分支重定基底到所選分支
branches.rebase.is.not.possible.in.the.detached.head.state=在游離的 HEAD 狀態下無法重定基底
branches.rebase.onto=將 {0} 變基到 {1}
branches.remote.branches=遠端分支
branches.remote.branches.in.repo={0} 中的遠端分支
branches.rename.branch=重新命名分支 {0}
branches.selected.branch.name=已選擇
branches.selected.branches.updated.title=已更新{0,choice,1#分支|2#分支}:\\n\\
\\n\\
{1}
branches.show.commits.in=在{0}中顯示{1}中缺少的提交
branches.show.diff.with.working.tree=顯示與工作樹的差異
branches.tag.0=標記 ''{0}''
branches.tags=標記
branches.there.are.incoming.and.outgoing.commits=存在傳入和傳出提交
branches.there.are.incoming.commits=存在傳入提交
branches.there.are.outgoing.commits=存在傳出提交
branches.tracking.branch.doesn.t.configured.for.s=沒有為 {0} 組態追蹤分支
branches.update=更新
branches.update.failed=更新失敗
branches.update.info.process=更新分支資訊…
branches.update.is.already.running=更新已在執行
branches.updating.process=正在更新分支…
button.changes.excluded.from.commit.commit.anyway=仍然提交
button.crlf.fix.dialog.commit.as.is=按原樣提交
button.crlf.fix.dialog.fix.and.commit=修復並提交
button.don.t.rollback=不回滾
button.rollback=回滾
button.set.name.and.commit=設定並提交
changes.retrieving=檢索修訂 {0} 的更改
changes.view.merge.action.text=合併
checkbox.dont.warn.again=不再警告(&W)
checkbox.run.git.hooks=執行 Git 掛鈎(&H)
checkbox.set.config.property.globally=全域設定屬性(&G)
checkout.0=簽出 {0}
checkout.and.rebase=重定基底到遠端
checkout.new.branch.operation.branch.was.created=已建立分支 {0}
checkout.new.branch.operation.checked.out.0.and.deleted.1.on.2.3=已在{2,choice,1#根|2#根}{3}上簽出 {0} 並刪除 {1}
checkout.new.branch.operation.could.not.create.new.branch=無法建立新分支 {0}
checkout.new.branch.operation.error.during.rollback=回滾期間出錯
checkout.new.branch.operation.errors.during.checkout=簽出期間出錯:
checkout.new.branch.operation.errors.during.deleting=刪除 {0} 期間出錯:
checkout.new.branch.operation.however.checkout.has.succeeded.for.the.following=不過，{0,choice,1#版本庫|2#版本庫} 的簽出已成功:
checkout.new.branch.operation.rollback.successful=回滾成功
checkout.new.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滾(簽回上一個分支並刪除 {0})以使分支不出現分叉。
checkout.operation.checked.out=已簽出 {0}
checkout.operation.checked.out.new.branch.from=已從 {1} 中簽出新分支 {0}
checkout.operation.could.not.checkout.error=無法簽出 {0}
checkout.operation.could.not.checkout.error.title=無法簽出 {0}
checkout.operation.error.during.rollback=回滾期間出錯
checkout.operation.errors.during.checkout=簽出期間出錯:
checkout.operation.errors.during.deleting=刪除 {0} 期間出錯:
checkout.operation.force.checkout=強制簽出(&F)
checkout.operation.however.checkout.has.succeeded.for.the.following=不過，以下{0,choice,1#版本庫|2#版本庫}的簽出已成功:
checkout.operation.in={1,choice,0#|1#{2}中的}{0}
checkout.operation.name=簽出
checkout.operation.previous.branch=上一個分支
checkout.operation.revision.not.found=在{0,choice,0#|1#{1}中}未找到修訂
checkout.operation.rollback=回滾
checkout.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滾(簽回 {0})以使分支不出現分叉。
cherry.pick.applied=套用
cherry.pick.name=優選
clone.dialog.checking.git.version=正在檢查 Git 版本…
column.name.commit.signature=GPG 簽名
combobox.item.file.invalid=(無效)
commit.action.commit.and.rebase.text=提交並重定基底…
commit.action.name=提交 (&I)
commit.author=作者(&A):
commit.author.diffs=<html>作者與預設不同</html>
commit.author.with.committer={0}，通過 {1}
commit.check.warning.title.commit.during.rebase=正在版本庫中進行重定基底: {0}。在重定基底期間提交可能會導致提交丟失。
commit.check.warning.title.commit.during.rebase.details=有關 Git 重定基底的更多資訊
commit.check.warning.title.commit.with.detached.head=版本庫處於游離的 HEAD 狀態: {0}
commit.check.warning.title.commit.with.detached.head.details=有關游離的 HEAD 的更多資訊
commit.check.warning.user.name.email.not.set=未設定 Git user.name 和 user.email
commit.options.create.extra.commit.with.file.movements=使用檔案移動建立額外提交
commit.options.sign.off.commit.checkbox=Sign-off 提交(&G)
commit.options.sign.off.commit.message.line=在提交訊息結尾添加以下行:<br/>Signed-off by: {0}
commit.signature.bad=錯誤的 GPG 簽名
commit.signature.fingerprint=簽名指紋:
commit.signature.none=無 GPG 簽名
commit.signature.signed.by=通過密鑰簽名:
commit.signature.unverified=未驗證的 GPG 簽名
commit.signature.unverified.reason.cannot.verify=無法驗證(例如，缺少密鑰)
commit.signature.unverified.reason.expired=過期的簽名
commit.signature.unverified.reason.expired.key=使用過期的密鑰建立
commit.signature.unverified.reason.revoked.key=使用撤消的密鑰建立
commit.signature.unverified.reason.unknown=未知有效性
commit.signature.unverified.with.reason=未驗證的 GPG 簽名: {0}
commit.signature.verified=已驗證的 GPG 簽名
common.current.branch=當前分支:
common.current.branch.tooltip=當前已簽出的分支。
common.git.root=Git 根(&R):
common.git.root.tooltip=選擇 Git VCS 根
common.local.branches=公共本地分支
common.no.active.branch=<無活動分支>
common.refreshing=正在重新整理檔案
common.remote.branches=公共遠端分支
common.suffix.in.one.repository=在 {0} 中
common.suffix.in.several.repositories=在 {0} 個版本庫中
computing.annotation=正在計算 {0} 的註解
conflict.resolver.unmerged.files.check.error.notification.description.text=由於錯誤，無法檢查工作樹中是否有未合併的檔案。{0}
conflicts.accept.progress=正在解析 {0,choice,1#個衝突|2#個衝突}
conflicts.accept.theirs.action.text=接受他們的更改
conflicts.accept.yours.action.text=接受您的更改
conflicts.loading.status=正在載入合併衝突…
conflicts.merge.window.error.message=找不到 {0} 的檔案
conflicts.merge.window.error.title=無法解決衝突
conflicts.resolve.action.text=解決
conflicts.type.added.by.them=由他們新增
conflicts.type.added.by.you=由您新增
conflicts.type.both.added=均已新增
conflicts.type.both.deleted=均已刪除
conflicts.type.both.modified=均已修改
conflicts.type.deleted.by.them=由他們刪除
conflicts.type.deleted.by.you=由您刪除
create.branch.operation.branch.created=已建立分支 {0}
create.branch.operation.could.not.create.new.branch=無法建立新分支 {0}
create.branch.operation.deleted.branch=已刪除 {0}
create.branch.operation.error.during.rollback=回滾期間出錯
create.branch.operation.however.the.branch.was.created.in.the.following.repositories=不過，已在以下 {0,choice,1#版本庫|2#版本庫} 中建立分支:
create.branch.operation.name=建立分支
create.branch.operation.rollback.successful=回滾成功
create.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滾(刪除 {0})以使分支不出現分叉。
delete.branch.operation.branch.was.not.deleted.error=分支 {0} 未刪除
delete.branch.operation.collecting.unmerged.commits.process=正在收集未合併的提交…
delete.branch.operation.could.not.restore.branch.error=無法還原 {0}
delete.branch.operation.deleted.branch=已刪除分支 {0}
delete.branch.operation.deleted.branch.bold=<b>已刪除的分支:</b> {0}
delete.branch.operation.error.during.rollback.of.branch.deletion=分支刪除回滾期間出錯
delete.branch.operation.however.branch.deletion.has.succeeded.for.the.following=不過，以下{0,choice,1#版本庫|2#版本庫}的分支刪除已成功:
delete.branch.operation.name=分支刪除
delete.branch.operation.restoring.branch.process=正在還原分支 {0}…
delete.branch.operation.unmerged.commits.were.discarded=未合併的提交已被捨棄
delete.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滾(在這些根中重新建立 {0})以使分支不出現分叉。
delete.remote.branch.operation.also.deleted.local.branches=同時刪除了本地 {0,choice,1#分支|2#分支}: {1}
delete.remote.branch.operation.couldn.t.find.remote.by.name=無法按名稱尋找遠端: {0}
delete.remote.branch.operation.deleted.remote.branch=已刪除遠端分支 {0}
delete.remote.branch.operation.deleting.process=正在刪除 {0}
delete.remote.branch.operation.failed.to.delete.remote.branch=無法刪除遠端分支 {0}
delete.remote.tag.operation.deleted.tag.on.remotes=<b>已刪除{0,choice,1#遠端|2#遠端}上的標記:</b> {1}
delete.remote.tag.operation.failed.to.delete.tag.on.remotes=無法刪除 {1,choice,1#遠端|2#遠端} 上的標記 {0}
delete.remote.tag.operation.tag.does.not.exist.on.remotes=<b>標記在{0,choice,1#遠端|2#遠端}上不存在:</b> {1}
delete.tag.operation.could.not.find.tag=找不到標記 {0}
delete.tag.operation.could.not.find.tag.in=在 {0} 中找不到標記
delete.tag.operation.could.not.restore.tag=無法還原 {0}
delete.tag.operation.delete.on.remote=在{0,choice,1#遠端|2#遠端}上刪除
delete.tag.operation.deleted.tag=<b>已刪除的標記:</b> {0}
delete.tag.operation.error.during.rollback.of.tag.deletion=標記刪除回滾期間出錯
delete.tag.operation.however.tag.deletion.has.succeeded.for.the.following=不過，以下{0,choice,1#版本庫|2#版本庫}的標記刪除已成功:
delete.tag.operation.restored.tag=已還原標記 {0}
delete.tag.operation.restoring.tag.process=正在還原標記 {0}…
delete.tag.operation.rollback.successful=回滾成功
delete.tag.operation.tag.was.not.deleted=未刪除標記 {0}
delete.tag.operation.you.may.rollback.not.to.let.tags.diverge=您可以回滾(在這些根中重新建立 {0})以使標記不出現分叉。
dialog.message.rebasing.merge.commits=您即將重定基底存在衝突的合併提交。\\n\\
\\n\\
如果您不想再次解決衝突，請選擇“合併”; 如果要將歷史記錄線性化，仍可進行重定基底。
dialog.message.untracked.files.will.be.overwritten.by.operation=這些未追蹤的檔案將被{0}覆蓋
dialog.title.could.not.operation=無法{0}
dialog.title.local.changes.prevent.from.operation=本地更改阻止{0}
dialog.title.rebasing.merge.commits=正在重定基底合併提交
dialog.title.untracked.files.preventing.operation=阻止{0}的未追蹤檔案
diff.find.error=正在尋找差異的修訂: {0}
editor.promo.close.link=不再顯示
editor.promo.commit.text=使用提交接口直接從 {0} 提交。
editor.promo.commit.try.link=嘗試
editor.promo.help.link=了解詳情
error.cannot.delete.file=無法刪除檔案: {0}
error.cant.set.user.name.email=無法設定 user.name 和 user.email
error.commit.cant.collect.partial.changes=無法收集要提交的部分更改
error.commit.cant.commit.multiple.changelists=無法一次提交多個更改列表中的更改
error.commit.cant.commit.with.unmerged.paths=由於您有未合併的檔案，因此無法提交。
error.commit.cant.create.message.file=建立提交訊息檔案失敗
error.dialog.title=錯誤
error.git.parse.not.a.revision.number=字串 ''{0}'' 不表示修訂號
error.git.parse.unknown.file.status=未知檔案狀態: {0}
error.git.repository.not.found=該版本庫不再存在: {0}
error.git.version.check.failed=執行 ''git --version'' 時出錯。退出程式碼: {0}，錯誤: {1}
error.list.title={0} 錯誤:
error.no.changed.files.no.commit.message=修改要提交的檔案並指定提交訊息
error.no.changed.files.to.commit=修改要提交的檔案
error.no.selected.roots.to.commit=選擇要提交的根
error.no.staged.changes.no.commit.message=暫存要提交的檔案並指定提交訊息
error.no.staged.changes.to.commit=暫存要提交的檔案
error.occurred.during=''{0}'' 時出錯
error.unresolved.conflicts=解決衝突以提交
errors.message=Git 動作以多個錯誤結束: {0}
errors.message.item=\\n\\
   {0}
exception.message.could.not.stash.root.error=無法隱藏 {0}: {1}
executable.error.git.not.installed=未安裝 Git
executable.mac.error.invalid.path.to.command.line.tools=Command Line Tools 的路徑無效
executable.mac.fix.path.action=修正路徑
exportable.Git.Application.Settings.presentable.name=Git
fetch.action.name=獲取
fetch.pruned.obsolete.remote.references=刪除過時的遠端 {0,choice,1#參照|2#參照}: {1}
fetching=正在獲取…
find.git.error.title=執行 Git 時出錯
find.git.success.title=Git 執行成功
find.git.unsupported.message=<html><tt>{0}</tt><br>此版本不受支援，某些延伸模組功能可能無法工作。<br>支援的最低版本是 <em>{1}</em>。</html>
git.add.to.exclude.file.action.description=將條目新增到 .git/info/exclude
git.add.to.exclude.file.action.text=.git/info/exclude
git.branches.popup.tree.accessible.name=分支樹
git.branches.popup.tree.no.branches=找不到分支 ''{0}''
git.commit.message.empty.title=提交訊息為空
git.commit.nothing.to.commit.error.message=沒有要提交的內容
git.compare.branches.empty.status={0} 包含來自 {1} 的所有提交
git.compare.branches.explanation.message=存在於 {0} 中但不存在於 {1} 中的提交
git.compare.branches.tab.name=比較
git.compare.branches.tab.suffix={0} 和 {1}
git.compare.with.tag.file.not.found.in.tag=標記 ''{2}'' 中不存在{0,choice,1#檔案|2#目錄} {1}
git.compare.with.tag.loading.error.title=無法載入標記
git.compare.with.tag.modal.progress.loading.tags=正在載入標記…
git.compare.with.tag.popup.title=選擇要比較的標記
git.content.transform.filters=篩選器
git.content.transform.none=無
git.content.transform.textconv=TextConv
git.error.cant.process.output=無法處理 Git 輸出: {0}
git.error.exit=Git 程序退出，程式碼為 {0}
git.executable.detect.progress.title=正在檢測 Git 可執行檔案
git.executable.error.bash.not.found=找不到 bash 可執行檔案
git.executable.error.file.not.found=沒有此類別檔案: {0}
git.executable.notification.cant.run.in.safe.mode=無法在安全模式下執行 Git 指令
git.executable.notification.description=Git 可執行檔案的路徑可能無效。
git.executable.notification.title=無法啟動 Git
git.executable.unknown.error.message=無法啟動 Git 程序: {0}
git.executable.validation.cant.identify.executable.message=無法識別 git 可執行檔案 {0} 的版本
git.executable.validation.cant.run.in.safe.mode=無法在安全模式下執行 Git 指令
git.executable.validation.error.no.response.in.n.attempts.message=無法識別 Git 可執行檔案的版本: {0,choice,0#|2# {0} 次嘗試後}無響應
git.executable.validation.error.start.title=無法執行 Git
git.executable.validation.error.version.message=至少需要 {0}
git.executable.validation.error.version.title=Git 版本 {0} 不受支援
git.executable.validation.error.wsl1.unsupported.message=不支持 WSL 版本 1，請參閱 <a href='https://youtrack.jetbrains.com/issue/IDEA-242469'>IDEA-242469</a>
git.executable.validation.error.xcode.message=執行“sudo xcodebuild -license”並重試(需要管理員權限)
git.executable.validation.error.xcode.title=接受 XCode/iOS 授權以執行 Git
git.executable.version.is=Git 版本為 {0}
git.executable.version.progress.title=正在識別 Git 版本
git.fetch.progress=正在獲取…
git.history.diff.handler.choose.parent.popup=選擇要比較的父項
git.history.diff.handler.git.show.error=執行 git show {0}:{1} 時出錯
git.history.diff.handler.load.changes.process=正在載入更改…
git.history.diff.handler.no.changes.in.file.info=此合併提交中的檔案 {0} 無更改
git.integration.could.not.git.init=無法 git init {0}
git.integration.created.git.repository.in=已在 {0} 中建立 Git 版本庫
git.light.cant.find.current.revision.exception.message=找不到 {0} 的當前修訂
git.light.status.bar.display.name=Git
git.light.status.bar.text=Git: {0}
git.light.status.bar.tooltip=當前 Git 分支: {0}
git.log.action.checkout.group=簽出
git.log.action.checkout.revision.full.text=簽出修訂 ''{0}''
git.log.action.checkout.revision.short.text=修訂 ''{0}''
git.log.branches.search.field.accessible.description=按 {0} 轉到 VCS 日誌表篩選器
git.log.branches.search.field.accessible.name=Git 分支搜尋
git.log.branches.tree.accessible.name=Git 分支
git.log.cherry.picked.highlighter.cancelled.message=已取消對 ''{0}'' 中未選取提交的醒目提示，因為分支篩選器已被更改。
git.log.cherry.picked.highlighter.error.message=無法與分支 {0} 進行比較
git.log.cherry.picked.highlighter.process=正在比較分支…
git.log.cherry.picked.highlighter.select.branch.popup=選擇源分支
git.log.diff.handler.changes.between.revisions.in.paths.title={2} 中 {0} 與 {1} 之間的更改
git.log.diff.handler.changes.between.revisions.title={0} 與 {1} 之間的更改
git.log.diff.handler.local.version.content.title=本地
git.log.diff.handler.local.version.name=本地版本
git.log.external.loading.process=正在載入 Git 日誌…
git.log.external.tab.description={0} 的日誌
git.log.external.window.title=Git 日誌
git.log.refGroup.local=本地
git.log.show.commit.in.log.process=正在搜尋修訂 {0}
git.new.tag.dialog.tag.name.label=輸入新標記的名稱
git.new.tag.dialog.title=在 {0}上建立新標記
git.open.exclude.file.action.description=在編輯器中開啟 .git/info/exclude
git.open.exclude.file.action.text=開啟 .git/info/exclude
git.rename.branch.could.not.rename.from.to=無法將 {0} 重命名為 {1}
git.rename.branch.has.succeeded.for.the.following.repositories=不過，以下{0,choice,1#版本庫|2#版本庫}的重新命名已成功:
git.rename.branch.renamed.back.to=已重新命名回 {0}
git.rename.branch.rollback.failed=回滾失敗
git.rename.branch.rollback.successful=回滾成功
git.rename.branch.was.renamed.to=分支 {0} 已被重命名為 {1}
git.rename.branch.you.may.rename.branch.back=您可以回滾(將分支重新命名回 {0})以使分支不出現分叉。
git.reset.button=重設
git.reset.dialog.description=<nobr>這會將當前分支 HEAD 重設為所選提交，<nobr/><br><nobr>並根據所選模式更新工作樹和索引:<nobr/>
git.reset.dialog.description.commit.details.by.author={0}，作者 {1}
git.reset.dialog.description.source.in.repository={0} ({1} 內)
git.reset.dialog.title=Git 重設
git.reset.failed.notification.title=重設失敗
git.reset.hard.button=硬重設(&H)
git.reset.mode.hard=硬
git.reset.mode.hard.description=<nobr>檔案將還原為所選提交的狀態。<nobr/><br><nobr>警告: 任何本地更改都將丟失。<nobr/>
git.reset.mode.keep=保留
git.reset.mode.keep.description=<nobr>檔案將還原為所選提交的狀態，<nobr/><br><nobr>但本地更改將保持不變。<nobr/>
git.reset.mode.mixed=混合
git.reset.mode.mixed.description=檔案不會更改，差異也不進行暫存。
git.reset.mode.soft=軟
git.reset.mode.soft.description=檔案不會更改，差異將暫存以進行提交。
git.reset.operation=重設
git.reset.partially.failed.notification.msg={0} 重設成功\\n\\
但 {1} 重設失敗:\\n\\
{2}
git.reset.partially.failed.notification.title=重設部分失敗
git.reset.process=Git 重設
git.reset.successful.notification.message=重設成功
git.rollback=回滾(&R)
git.running=執行: {0}
git.status.bar.widget.name=Git 分支
git.status.bar.widget.text.cherry.pick=正在 {0} 中優選
git.status.bar.widget.text.merge=正在合併 {0}
git.status.bar.widget.text.rebase=正在重定基底 {0}
git.status.bar.widget.text.revert=正在 {0} 中還原
git.status.bar.widget.text.unknown=<未知>
git.status.bar.widget.tooltip.detached=Git: 游離的 HEAD 不指向任何分支
git.status.copied=已複製
git.status.index=在暫存區域中{0}
git.status.not.changed=未更改
git.status.renamed=已重新命名
git.status.type.changed=已更改類型
git.status.unmerged=已取消合併
git.status.unmerged.both=兩者{0}
git.status.unmerged.index=我們{0}
git.status.unmerged.work.tree=由他人{0}
git.status.untracked=已取消追蹤
git.status.work.tree=在工作目錄中{0}
git.tag.could.not.create.tag=無法建立標記
git.tag.created.tag.successfully=已成功建立標記 {0}。
git.toolbar.widget.no.repo=版本控制
git.toolbar.widget.no.repo.tooltip=為專案組態版本控制
git.undo.action.cant.undo.commit.failure=無法撤消提交
git.undo.action.could.not.load.changes.of.commit=無法載入 {0} 的更改
git.undo.action.description=所選提交不是當前分支中的最後一次提交
git.undo.action.failed.notification.title=撤消提交失敗
git.undo.action.operation=撤消提交
git.undo.action.process=Git 撤消提交
git.undo.action.refreshing.changes.process=正在重新整理更改…
git.undo.action.select.target.changelist.title=選擇目標更改列表
git.undo.action.successful.notification.message=撤消提交成功
git.undo.action.undoing.last.commit.process=正在撤消最後一次提交…
git.unstash.clear.confirmation.message=移除所有隱藏? 此動作無法撤消。
git.unstash.clear.confirmation.title=移除所有隱藏?
git.unstash.drop.confirmation.message=<html>是否要移除 {0}?<br/>“{1}”</html>
git.unstash.drop.confirmation.title=移除隱藏 {0}?
git.update.commits.matching.filters={0,choice,1#{0} 個提交|2#{0} 個提交}與篩選器匹配
git.update.files.updated.in.commits=已更新 {1,choice,1#{1} 個提交|2#{1} 個提交}中的 {0,choice,1#{0} 個檔案|2#{0} 個檔案}
git.update.no.commits.matching.filters=沒有與篩選器符合的提交
git.update.operation=更新
git.update.project.partially.updated.title=專案已部分更新
git.update.repo.was.skipped=已跳過 {0} ({1})
git.update.skipped.repositories=已跳過 {0} 個版本庫:
git4idea.vcs.name=Git
git4idea.vcs.name.with.mnemonic=Git(_G)
gpg.error.see.documentation.link.text=參閱 GPG 設定指南
gpg.jb.manual.link=Set_up_GPG_commit_signing
group.Git.CheckoutGroup.description=簽出所選修訂或所選提交中的分支
group.Git.CheckoutGroup.text=簽出
group.Git.ContextMenu.text=Git(_G)
group.Git.HEAD.Branch.Filter.title=HEAD(當前分支)
group.Git.Local.Branch.title=本地
group.Git.Log.Branches.Grouping.Settings.text=分組依據
group.Git.Log.Branches.Settings.Separator.text=點擊時
group.Git.Log.Branches.Settings.text=分支窗格設定
group.Git.MainMenu.LocalChanges.text=未提交的更改(_U)
group.Git.MainMenu.MergeActions.text=合併(_M)
group.Git.MainMenu.RebaseActions.text=重定基底(_R)
group.Git.Menu.text=Git(_G)
group.Git.Recent.Branch.in.repo.title={0} 中最近的分支
group.Git.Recent.Branch.title=最近
group.Git.Remote.Branch.title=遠端
group.Git.Stage.Index.File.Menu.text=Git
group.Git.Stage.Ui.Settings.text=檢視選項
group.MainToolbarVCSGroup.text=VCS 組
group.Vcs.ToolbarWidget.ShareProject.text=在以下平台上共享專案:
group.git4idea.actions.ShareLogIndexData.text=共享 Git 日誌索引資料
history.indexing.disabled.notification.dismiss.link=不再顯示
history.indexing.disabled.notification.resume.link=恢復 Git 日誌索引
history.indexing.disabled.notification.text=由於索引不可用，顯示的是舊式檔案歷史記錄
in.branches.all.repositories=在所有版本庫中
init.destination.directory.description=選擇將在其中建立新 Git 版本庫的目錄。
init.destination.directory.title=建立 Git 版本庫
init.warning.already.under.git=所選目錄 <tt>{0}</tt> 已在 Git 下。\\n\\
確定要建立新的 VCS 根嗎?
init.warning.title=Git Init
initializing.title=正在初始化版本庫…
install.download.and.install.action=下載並安裝
install.downloading.progress=正在下載…
install.general.error=無法安裝 Git
install.installing.progress=正在安裝…
install.mac.error.couldnt.start.command.line.tools=無法啟動 Command Line Tools 安裝
install.mac.requesting.command.line.tools=正在請求 XCode Command Line Developer Tools
install.success.message=已安裝 Git
label.changes.excluded.from.commit.are.you.sure.want.to.continue=確定要從合併提交中排除這些更改過的檔案嗎?
label.credential.store.key.http.password=Git HTTP
label.diff.content.title.submodule.suffix={0} (子模組)
label.name.email.not.defined.in.n.roots={0,choice,1#根|2#根}中未定義 Git 的 user.name 和 user.email 屬性
label.user.email=電子郵件(&E):
label.user.name=名稱(&N):
link.label.commit.with.detached.head.read.more=閱讀有關游離的 HEAD 的更多資訊
link.label.commit.with.unfinished.rebase.read.more=閱讀有關 Git 重定基底的更多資訊
link.label.editor.notification.merge.conflicts.resolve.in.progress=正在解決合併衝突
link.label.local.changes.would.be.overwritten.by.merge.view.them=檢視這些更改
link.label.merge.conflicts.resolve.in.progress.cancel.resolve=取消解決
link.label.merge.conflicts.resolve.in.progress.focus.window=使視窗獲得焦點
local.changes.freeze.message.git.operation.prefix=Git {0}
local.changes.save.policy.shelve=擱置
local.changes.save.policy.stash=隱藏
log.parser.exception.message.could.not.parse.output=無法解析 Git 日誌輸出“{0}”
log.parser.exception.message.error.command.line={0}\\n\\
命令行: [{1}]
log.parser.exception.message.error.parsing.line=解析第“{0}”行時出錯
login.dialog.button.login=登入
login.dialog.error.password.cant.be.empty=密碼不能為空
login.dialog.error.username.cant.be.empty=用戶名不能為空
login.dialog.label.login.to.url=登入 {0}
login.dialog.login.with.selected.provider=使用 {0} 登入…
login.dialog.password.label=密碼:
login.dialog.prompt.enter.credentials=輸入憑證:
login.dialog.select.login.way.credentials=輸入憑證
login.dialog.select.login.way.use.helper=使用憑證幫助程序
login.dialog.username.label=用戶名:
mention.in=\\ ({0} 中)
merge.action.after.update.label=更新後
merge.action.before.update.label=更新前
merge.action.name=合併
merge.action.operation.failed=Git {0} 失敗
merge.branch.already.merged=分支 ''{0}'' 已被合併
merge.branch.field.placeholder=指定分支
merge.branch.into.current.title=合併到 {0}
merge.branch.loading.branches.progress=正在載入未合併的分支…
merge.branch.popup.empty.text=無分支
merge.branch.title=合併更改
merge.commit.message.label=提交訊息:
merge.dialog.customizer.collecting.details.progress=正在收集提交詳細資訊…
merge.dialog.customizer.filter.by.conflicted.file.checkbox=按衝突檔案篩選
merge.dialog.customizer.show.details.link.label=顯示詳細資訊
merge.dialog.description.cherry.pick.label.text=在優選{2,choice,0#|1#由 {3}{4} 執行的}{0,choice,1#提交 {1}|2#多個提交}期間出現衝突
merge.dialog.description.merge.label.text=將{0,choice,1#分支 {1} |2#分叉的分支}合併到{2,choice,1#分支 {3}|2#分叉的分支}
merge.dialog.description.rebase.with.hash.label.text=正在{0,choice,0#|1#將分支 {1} }變基到 {2}
merge.dialog.description.rebase.with.onto.branch.label.text=正在{0,choice,0#|1#將分支 {1} }重定基底到分支 {2}{3,choice,0#|1#，修訂 {4}}
merge.dialog.description.rebase.without.onto.info.label.text=正在{0,choice,0#|1#將分支 {1} }重定基底到分叉的分支
merge.dialog.diff.left.title.cherry.pick.label.text=本地更改
merge.dialog.diff.left.title.default.branch.label.text=您的版本，分支 {0}
merge.dialog.diff.left.title.rebase.label.text=正在從 {1} 重定基底 {0}
merge.dialog.diff.right.title.cherry.pick.label.text=來自優選 {0} 的更改
merge.dialog.diff.right.title.default.with.hash.label.text=來自 {0} 的更改
merge.dialog.diff.right.title.default.with.onto.branch.label.text=來自分支 {0}{1,choice,0#|1#，修訂 {2}} 的更改
merge.dialog.diff.right.title.default.without.onto.info.label.text=來自分叉分支的更改
merge.dialog.diff.right.title.rebase.with.branch.label.text=已重定基底的提交和來自 {0} 的提交
merge.dialog.diff.right.title.rebase.without.branch.label.text=已重定基底的提交
merge.dialog.diff.title.changes.from.branch.label.text=來自 {0} 的更改
merge.error.unable.to.read.merge.head=無法讀取檔案 {0}: {1}
merge.no.branch.selected.error=應選擇該合併分支。
merge.no.matching.branch.error=沒有符合分支。
merge.operation.already.up.to.date=已處於最新狀態
merge.operation.branch.merged.with.conflicts={0} 已合併，但存在衝突
merge.operation.could.not.merge.branch=無法合併 {0}
merge.operation.delete.branch=刪除 {0}
merge.operation.error.during.rollback=回滾期間出錯
merge.operation.however.merge.has.succeeded.for.the.following.repositories=不過，以下{0,choice,1#版本庫|2#版本庫}的合併已成功:
merge.operation.merged.to=已將 {0} 合併到 {1}
merge.operation.name=合併
merge.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滾(重設為合併之前的提交)以使分支不出現分叉。
merge.option.ff.only=僅在可以快進時合併
merge.option.msg=指定合併提交的訊息
merge.option.no.commit=不提交合併結果
merge.option.no.ff=即使可以快進也建立合併提交
merge.option.no.verify=繞過預合併和提交訊息掛鈎
merge.option.squash=為所有合併更改建立一個提交
merge.options.modify=修改選項
merge.options.modify.popup.title=新增合併選項
merge.progress.indicator.loading.unmerged.files.title=正在載入未合併的檔案…
merge.tool.column.status.deleted=已刪除
merge.tool.column.status.modified=已修改
merge.tool.column.theirs.status=他人的更改
merge.tool.column.theirs.with.branch.status=他人的更改({0})
merge.tool.column.yours.status=您的更改
merge.tool.column.yours.with.branch.status=您的更改({0})
merge.unresolved.conflicts.remaining.notification.body=有掛起的未解決的衝突。
merge.unresolved.conflicts.remaining.notification.title=正在掛起未解決的衝突
merge.update.project.conflict.merge.description.label=檢測到合併衝突。請先解決這些衝突，然後再繼續更新。
merge.update.project.generic.error.title=無法完成更新
merging.title=將更改合併到 {0}
message.unresolved.conflicts.prevent.commit=由於有未解決的衝突，無法提交更改。
new.branch.dialog.branch.name=新分支名稱:
new.branch.dialog.checkout.branch.checkbox=簽出分支(&C)
new.branch.dialog.error.branch.already.exists=分支名稱 {0} 已存在
new.branch.dialog.error.branch.clashes.with.directory=分支名稱 {0} 與同名的本地分支目錄衝突
new.branch.dialog.error.branch.clashes.with.remote=分支名稱 {0} 與同名的遠端分支衝突
new.branch.dialog.error.branch.name.empty=指定新分支的名稱
new.branch.dialog.error.branch.name.head=HEAD 是保留關鍵字
new.branch.dialog.error.branch.name.invalid=分支名稱 {0} 無效
new.branch.dialog.operation.checkout.description=簽出現有分支，並在其他版本庫中建立新分支
new.branch.dialog.operation.checkout.name=簽出
new.branch.dialog.operation.create.description=在其他版本庫中建立新分支
new.branch.dialog.operation.create.name=建立
new.branch.dialog.operation.rename.name=重新命名
new.branch.dialog.overwrite.existing.branch.checkbox=覆蓋現有分支(&R)
new.branch.dialog.overwrite.existing.branch.warning=更改名稱或覆蓋現有分支
new.branch.dialog.set.tracking.branch.checkbox=設定追蹤分支(&T)
no.revisions.available=無修訂
notification.content.branch.in.repo.has.no.tracked.branch={0} {1} 沒有追蹤的分支
notification.content.couldn.t.authorize=授權錯誤
notification.content.couldnt.collect.updated.files.info={0} 更新成功，但由於發生了一個錯誤，無法收集更新的更改
notification.content.detached.state.in.root.checkout.branch=您處於“游離的 HEAD”狀態，這表明您不在任何分支 {0} 上<br/>簽出分支以更新專案。
notification.content.fetch.cancelled.by.user=獲取已被使用者取消
notification.content.fetch.failed.couldn.t.authorize=獲取失敗: 授權錯誤
notification.content.fetched.successfully=已成功獲取
notification.content.untracked.files.prevent.operation.move.or.commit=在 {0} 前移動或提交<br/>{1}
notification.content.updating.root.failed.with.error=更新 {0} 失敗，出現錯誤: {1}
notification.ignore.file.generation.error.text.files.progress.title=無法生成 .gitignore 檔案
notification.title.can.t.update.no.current.branch=無法更新: 無當前分支
notification.title.couldn.t.reset.merge=無法中止合併動作
notification.title.couldnt.collect.updated.files.info=無法收集已更新檔案的資訊
notification.title.error.merging=合併錯誤
notification.title.error.updating.root=更新 {0} 期間出錯
notification.title.fetch.details=獲取詳細資訊
notification.title.fetch.failed=獲取失敗
notification.title.fetch.failure=獲取失敗
notification.title.fetch.success=獲取成功
notification.title.git.operation.failed=Git {0} 失敗
notification.title.unstash.failed=取消隱藏失敗
notification.title.unstash.failed.index.conflict=由於索引衝突，取消隱藏失敗
notification.title.untracked.files.prevent.operation=未追蹤的檔案會阻止{0}
notification.title.update.failed=更新失敗
open.in.browser.error=無法在瀏覽器中開啟
open.in.browser.getting.revision=正在獲取最新的檔案修訂
open.in.browser.getting.revision.error=無法檢索檔案的最新修訂
operation.action.message=多個 Git 根有未完成的 {0} 程序，請選擇要對其執行動作的根。
operation.name.loading.revision=載入修訂
operation.name.validating.revision.0=驗證修訂 {0}
paths.affected.title=提交 {0} 中受影響的路徑
post.commit.check.load.changes.error=無法為 {1} 載入根 {0} 中的更改
preserving.process.local.changes.not.restored.error.title=未還原本地更改
progress.checking.line.separator.issues=正在檢查行分隔符問題…
progress.checking.user.name.email=正在檢查 Git 用戶名…
progress.details.refreshing.files.for.root=正在重新整理根 {0} 的檔案
progress.finishing.conflict.resolve=正在解決衝突
progress.setting.config.value=正在更新 Git 組態…
progress.setting.user.name.email=正在設定 Git 用戶名…
progress.text.merging.repository=正在合併 {0}…
progress.title.creating.git.repository=正在建立 Git 版本庫…
progress.title.enabling.git=正在啟用 Git…
progress.title.moving.files=正在移動檔案…
progress.title.reverting.n.commits=正在還原{0,choice,1#提交|2#提交}
progress.title.update=更新
progress.title.validating.revision=正在驗證修訂…
progress.update.destination.remote=遠端
pull.action.name=拉取
pull.branch.field.placeholder=指定分支
pull.branch.no.matching.remotes=無遠端
pull.branch.not.selected.error=應選擇要從中拉取的分支。
pull.branch.nothing.to.pull=無分支
pull.button=拉取
pull.dialog.fetch.shortcuts.hint=按 {0} 更新分支
pull.dialog.title=拉取
pull.dialog.with.branch.title=拉取到 {0}
pull.fetch.failed.notification.text=選擇一個本地版本庫和一個遠端版本庫
pull.fetch.failed.notification.title=無法載入遠端分支
pull.option.ff.only=僅在可以快進時合併
pull.option.no.commit=合併，但不提交結果
pull.option.no.ff=即使可以快進也建立合併提交
pull.option.rebase=在當前分支的頂部重定基底傳入更改
pull.option.squash.commit=為所有拉取更改建立一個提交
pull.options.modify.popup.title=新增拉取選項
pull.remote.not.selected=選擇要從中拉取的遠端版本庫
pull.repository.not.selected.error=選擇一個版本庫
pulling.title=從 {0} 中拉取更改
push.dialog.preview.commits.before.push=對於向不受保護分支的提交和推送，應在推送之前預覽提交
push.dialog.push.tags=推送標記(&T)
push.dialog.push.tags.combo.all=所有
push.dialog.push.tags.combo.current.branch=當前分支
push.dialog.target.panel.add.remote=新增遠端
push.dialog.target.panel.adding.remote=正在新增遠端…
push.dialog.target.panel.can.t.push=無法推送
push.dialog.target.panel.couldnt.add.remote=無法新增遠端: {0}
push.dialog.target.panel.define.remote=定義遠端
push.dialog.target.panel.empty.repository=空版本庫
push.dialog.target.panel.new=新增
push.failed.error.message=推送失敗: {0}
push.local.history.system.label.after=推送後
push.local.history.system.label.before=推送前
push.notification.description.force.pushed=強制推送 {0} 到 {1}
push.notification.description.new.branch=已推送 {0} 到新分支 {1}
push.notification.description.new.branch.with.many.tags=推送 {0} 到新分支 {1}，並將 {2} 標籤到 {3}
push.notification.description.new.branch.with.single.tag=推送 {0} 到新分支 {1}，並將 {2} 標籤到 {3}
push.notification.description.push.with.lease.rejected=使用 Force-with-lease 推送 {0} 到 {1} 被拒
push.notification.description.pushed=已將 {0} 個{0,choice,1#提交|2#提交} 推送到 {1}
push.notification.description.pushed.many.tags=已推送 {0} 標籤到 {1}
push.notification.description.pushed.single.tag=已推送標籤 {0} 到 {1}
push.notification.description.pushed.with.many.tags=已將 {0} 個{0,choice,1#提交|2#提交} 推送到 {1}，將 {2} 標籤推送到 {3}
push.notification.description.pushed.with.single.tag=已將 {0} 個{0,choice,1#提交|2#提交} 推送到 {1}，將標籤 {2} 推送到 {3}
push.notification.description.rejected=推送到 {0} 被拒
push.notification.description.rejected.and.cancelled=推送被拒，更新被取消
push.notification.description.rejected.and.conflicts=由於更新期間發生衝突，推送被取消。<br/>檢查是否已正確解決衝突，然後再次呼叫推送。
push.notification.description.rejected.and.failed=因發生錯誤，推送被拒，更新失敗
push.notification.description.rejected.and.incomplete=由於更新過程中並未解決所有衝突，推送被取消。<br/>請解決衝突並再次呼叫推送
push.notification.description.rejected.by.remote=推送 {0} 到 {1} 被遠端拒絕
push.notification.description.up.to.date=所有內容都已處於最新狀態
push.notification.force.push.anyway.action=仍然強制推送
push.notification.force.push.progress.title.pushing=正在推送…
push.notification.force.with.lease.help=何為 Force-with-Lease?
push.notification.force.with.lease.help.description.first=Force-with-lease 推送阻止覆寫尚未獲取到本地版本庫的遠端更改
push.notification.force.with.lease.help.description.second=獲取最新更改，以確認能否安全捨棄更改並重複執行推送動作
push.notification.partially.failed.title=推送部分失敗
push.notification.partially.rejected.title=推送部分被拒
push.notification.push.failed.title=推送失敗
push.notification.rejected.title=推送被拒
push.notification.single.repo.success.description=推送動作期間收到 {0} 個{0, choice,1#提交|2#提交}
push.notification.successful.title=推送成功
push.notification.update.action=更新
push.notification.view.files.action=檢視在推送期間更新的檔案
push.notification.view.filtered.commits.actions=檢視與篩選器符合的 {0} 個{0,choice,1#提交|2#提交}
push.notification.view.received.commits.action=檢視收到的{0,choice,1#提交|2#提交}
push.rejected.dialog.title=推送被拒
push.rejected.many.repos=當前分支的推送被拒:
push.rejected.many.repos.item={1} 中的 {0}
push.rejected.many.repos.single.branch=當前分支“{0}”的推送被拒。
push.rejected.merge=合併(&M)
push.rejected.merge.needed=推送前需要合並遠端更改。
push.rejected.merge.needed.with.problem=在推送前，必須先合併遠端更改。<br/><br/>在這種情況下，強烈建議進行<b>合併</b>，因為存在未推送的合併提交。\\n\\
<br/>進行重定基底可能導致問題。
push.rejected.only.one.git.repo=當前分支“{0}”的推送被拒。
push.rejected.rebase=重定基底(&R)
push.rejected.rebase.anyway=仍然重定基底
push.rejected.remember.checkbox=請記住更新方法，並在日後進行無提示更新(&S)。稍後可以在“{0} | 版本控制”中進行更改。<br/>
push.rejected.specific.repo=版本庫“{1}”中的當前分支“{0}”推送被拒。
push.up.to.commit.allowed.progress.title=正在檢查是否允許推送到選定的提交…
push.up.to.commit.getting.reference.progress.title=正在獲取對 HEAD 的提交參照…
push.upto.here.failed.dialog.title=無法啟動推送
push.upto.here.not.supported.notification.message=“推送此前所有提交”僅支援包含在本地分支中的提交
push.upto.here.not.supported.notification.title=無法啟動推送
rebase.abort.and.rollback.dialog.message=僅中止 {0} 中的重定基底還是同時回滾 {1} 中的重定基底?
rebase.abort.and.rollback.dialog.no.button.text=僅中止
rebase.abort.and.rollback.dialog.yes.button.text=中止並回滾
rebase.abort.dialog.message=中止{0} 中的重定基底?
rebase.abort.dialog.ok.button.text=中止
rebase.abort.dialog.title=中止重定基底
rebase.abort.notification.failed.title=中止重定基底失敗
rebase.abort.notification.successful.message=中止重定基底成功
rebase.abort.notification.warning.rollback.failed.message={0}中的回滾失敗:{1}{2}
rebase.abort.notification.warning.rollback.failed.title=重定基底回滾失敗
rebase.abort.notification.warning.rollback.failed.with.repo.message=成功中止 {0} 中的重定基底，但 {1}:{2}{3} 中的回滾失敗
rebase.abort.progress.indicator.command.in.repo.title={0} ({1} 內)
rebase.abort.rollback.successful.rebase.dialog.message=是否要回滾 {0} 中成功的重定基底?
rebase.abort.rollback.successful.rebase.dialog.ok.button.text=回滾
rebase.confirmation.dialog.published.commits.button.cancel.text=取消
rebase.confirmation.dialog.published.commits.button.rebase.text=仍然重定基底
rebase.confirmation.dialog.published.commits.message.first=您正在嘗試重定基底一些已推送到受保護分支的提交。
rebase.confirmation.dialog.published.commits.message.second=對這些提交進行重定基底將使提交重複，這是不推薦的，而且很可能是不需要的。
rebase.confirmation.dialog.published.commits.title=重定基底已發佈的提交
rebase.conflict.diff.dialog.left.title=正在從 {1} 重定基底 {0}
rebase.conflict.diff.dialog.right.simple.title=已重定基底的提交
rebase.conflict.diff.dialog.right.with.branch.title=已重定基底的提交和來自 {0} 的提交
rebase.couldnt.resolve.file=無法解決 {0}
rebase.dialog.branch.field=源分支
rebase.dialog.error.base.not.selected=選擇新基
rebase.dialog.error.branch.invalid=分支 ''{0}'' 不存在
rebase.dialog.error.branch.not.selected=選擇要切換到的分支
rebase.dialog.error.branch.or.tag.not.exist=沒有這樣的分支或標記
rebase.dialog.error.rebase.in.progress=此 Git 根目錄已經在進行互動重定基底
rebase.dialog.error.upstream.not.selected=選擇上游
rebase.dialog.help=顯示 Git 重定基底幫助
rebase.dialog.new.base=新基礎(分支或雜湊)
rebase.dialog.old.base=原基礎(分支或雜湊)
rebase.dialog.progress.loading.tags=正在載入標記…
rebase.dialog.root.invalid.label.text=(無效)
rebase.dialog.start.rebase=重定基底
rebase.dialog.target=分支或雜湊
rebase.dialog.title=重定基底
rebase.entry.action.name.drop=刪除
rebase.entry.action.name.edit=編輯
rebase.entry.action.name.fixup=Fixup
rebase.entry.action.name.pick=選取
rebase.entry.action.name.reword=改寫
rebase.entry.action.name.squash=壓縮
rebase.entry.action.name.unknown=未知
rebase.git.operation.name=重定基底
rebase.help.link=git-scm.com 上的 git 重定基底
rebase.help.popup.ad.text=按空格開啟外部鏈接
rebase.help.rebase.branch=將基於一個分支的分支重定基底到另一個分支:
rebase.interactive.dialog.discard.modifications.cancel=取消重定基底
rebase.interactive.dialog.discard.modifications.continue=繼續重定基底
rebase.interactive.dialog.discard.modifications.discard=捨棄
rebase.interactive.dialog.discard.modifications.message=捨棄更改並取消重定基底?
rebase.interactive.dialog.git.commands=Git 指令
rebase.interactive.dialog.git.commands.column.action=動作
rebase.interactive.dialog.git.commands.column.hash=雜湊
rebase.interactive.dialog.git.commands.column.subject=主題
rebase.interactive.dialog.reset.link.text=重設
rebase.interactive.dialog.reword.hint.text=按 {0} 套用更改
rebase.interactive.dialog.start.rebase=啟動重定基底
rebase.interactive.dialog.stop.to.edit.text=停止以編輯
rebase.interactive.dialog.title=正在重定基底提交
rebase.interactive.dialog.view.git.commands.text=檢視 Git 指令
rebase.interactive.edit.commit.message.dialog.title=Git 提交訊息
rebase.interactive.edit.commit.message.ok.action.title=繼續重定基底
rebase.interactive.noop.dialog.text=由於當前分支直接位於基礎分支的正下方或它們指向同一個提交，因此沒有要重定基底的提交('noop' 情況)。\\n\\
 是否要繼續? (這會將當前分支重設為基礎分支)
rebase.interactive.noop.dialog.title=Git 重定基底
rebase.interactive.unstructured.editor.dialog.root.label=Git 根: {0}
rebase.log.action.loading.commit.message.failed.message=無法載入{0,choice,1#提交|2#提交}的更改
rebase.log.action.operation.rebase.name=重定基底
rebase.log.action.operation.reword.name=改寫
rebase.log.action.progress.indicator.loading.commit.message.title=正在載入{0,choice,1#提交|2#提交}詳細資訊…
rebase.log.commit.editing.action.commit.not.in.head.error.text=該提交不在當前分支中
rebase.log.commit.editing.action.commit.pushed.to.protected.branch.error.text=該提交已被推送到受保護分支 ''{0}''
rebase.log.commit.editing.action.disabled.parents.description=所選提交已{0}父項
rebase.log.commit.editing.action.progress.containing.branches.title=正在搜尋包含所選提交的分支…
rebase.log.commit.editing.action.prohibit.state=不能{0}
rebase.log.commit.editing.action.prohibit.state.grafting=優選期間不能{0}
rebase.log.commit.editing.action.prohibit.state.merging=合併期間不能{0}
rebase.log.commit.editing.action.prohibit.state.rebasing=重定基底期間不能{0}
rebase.log.commit.editing.action.prohibit.state.reverting=還原期間不能{0}
rebase.log.create.fixup.commit.action.failure.title=無法建立 Fixup 提交
rebase.log.create.squash.commit.action.failure.title=無法建立壓縮提交
rebase.log.drop.action.custom.text=刪除{0,choice,1#提交|2#提交}
rebase.log.drop.action.failure.title=無法刪除提交
rebase.log.drop.progress.indicator.title=正在刪除{0, choice, 1#提交|2#提交}…
rebase.log.drop.success.notification.title=已刪除{0, choice, 1#提交|2#提交}
rebase.log.drop.undo.failed.title=撤消刪除失敗
rebase.log.drop.undo.impossible.title=無法撤消刪除
rebase.log.drop.undo.progress.title=正在撤消刪除…
rebase.log.interactive.action.failure.title=無法啟動重定基底
rebase.log.multiple.commit.editing.action.cant.find.head=在包含選定{0,choice,1#提交|2#提交}的版本庫中找不到 HEAD 分支
rebase.log.multiple.commit.editing.action.disabled.external.repository.description=所選{0, choice, 1#提交|2#提交}{0, choice,1#|2#}來自外部版本庫
rebase.log.multiple.commit.editing.action.disabled.multiple.repository.description=所選{0, choice, 1#提交|2#提交}{0, choice,1#|2#}來自不同的版本庫
rebase.log.multiple.commit.editing.action.progress.indicator.action.possibility.check=正在檢查是否允許編輯所選提交…
rebase.log.multiple.commit.editing.action.specific.commit.not.in.head=提交 {0} 不在當前分支中
rebase.log.multiple.commit.editing.action.specific.commit.root.or.merge=提交 {0} 有 {1} 個父項
rebase.log.reword.action.failure.title=無法編輯提交訊息
rebase.log.reword.action.notification.successful.title=已更改提交訊息
rebase.log.reword.action.notification.undo.failed.title=撤消提交訊息編輯失敗
rebase.log.reword.action.notification.undo.not.allowed.repository.changed.message=版本庫已被更改
rebase.log.reword.action.notification.undo.not.allowed.title=無法撤消提交訊息編輯
rebase.log.reword.action.progress.indicator.title=正在改寫…
rebase.log.reword.action.progress.indicator.undo.title=正在撤消改寫…
rebase.log.reword.dialog.description.label=編輯由 {1} 執行的提交 {0} 的訊息
rebase.log.reword.dialog.failed.pushed.to.protected.message=無法編輯所選{0,choice,1#提交|2#提交}: 提交 {1} 已被推送到受保護的分支 ''{2}''
rebase.log.reword.dialog.failed.repository.changed.message=無法編輯所選{0,choice,1#提交|2#提交}: 版本庫狀態已更改
rebase.log.reword.dialog.title=編輯提交訊息
rebase.log.squash.action.failure.title=無法壓縮提交
rebase.log.squash.new.message.dialog.label=編輯已壓縮提交的訊息
rebase.log.squash.new.message.dialog.title=已壓縮提交訊息
rebase.log.squash.progress.indicator.title=正在壓縮…
rebase.log.squash.success.notification.title=提交已壓縮
rebase.log.squash.undo.failed.title=撤消壓縮失敗
rebase.log.squash.undo.impossible.title=無法撤消壓縮
rebase.log.squash.undo.progress.title=正在撤消壓縮…
rebase.log.undo.impossible.pushed.to.protected.branch.notification.text=來自當前分支的提交已被推送到受保護的分支 {0}
rebase.notification.action.abort.text=中止
rebase.notification.action.continue.text=繼續
rebase.notification.action.retry.text=重試
rebase.notification.action.view.shelf.text=檢視擱置…
rebase.notification.action.view.stash.text=檢視隱藏…
rebase.notification.all.conflicts.resolved.continue.rebase.action.text=繼續重定基底(&T)
rebase.notification.all.conflicts.resolved.text=所有衝突都已解決。是否要繼續重定基底?
rebase.notification.all.conflicts.resolved.title=解決衝突
rebase.notification.conflict.title=由於衝突，重定基底停止
rebase.notification.editing.title=重定基底已停止，可以進行編輯
rebase.notification.failed.continue.title=繼續重定基底失敗
rebase.notification.failed.rebase.title=重定基底失敗
rebase.notification.failed.shelf.text=無法擱置本地未提交的更改:
rebase.notification.failed.stash.text=無法隱藏本地未提交的更改:
rebase.notification.no.rebase.in.progress.abort.title=無法中止重定基底
rebase.notification.no.rebase.in.progress.continue.title=無法繼續重定基底
rebase.notification.no.rebase.in.progress.message=沒有正在進行的重定基底
rebase.notification.not.allowed.detached.message.first=您在 {0} 中處於游離的 HEAD 狀態。
rebase.notification.not.allowed.detached.message.second=無法重定基底。
rebase.notification.not.allowed.empty.repository.message=版本庫 {0} 為空。
rebase.notification.not.allowed.grafting.message.first={0} 中有一個未完成的優選程序。
rebase.notification.not.allowed.grafting.message.second=在開始重定基底前，應先完成這項動作。
rebase.notification.not.allowed.merging.message.first={0} 中有一個未完成的合併程序。
rebase.notification.not.allowed.merging.message.second=在開始重定基底前，應先完成合併。
rebase.notification.not.allowed.message=無法在 {0} 中進行重定基底。
rebase.notification.not.allowed.rebasing.message.first={0} 中有一個未完成的重定基底程序。
rebase.notification.not.allowed.rebasing.message.second=在開始另一個重定基底前，應先完成這項動作。
rebase.notification.not.allowed.reverting.message.first={0} 中有一個未完成的還原程序。
rebase.notification.not.allowed.reverting.message.second=在開始重定基底前，應先完成這項動作。
rebase.notification.not.allowed.title=不允許重定基底
rebase.notification.not.started.title=重定基底未啟動
rebase.notification.saved.local.changes.part.shelf.text=重定基底前已擱置本地更改。
rebase.notification.saved.local.changes.part.stash.text=重定基底前已隱藏本地更改。
rebase.notification.successful.rebased.checkout.message=已簽出{0,choice,0#|1# {1} }並將其重定基底{2,choice,0#|1#到 {3}}
rebase.notification.successful.rebased.message=已{0,choice,0#|1#將 {1} }重定基底{2,choice,0#|1#到 {3}}
rebase.notification.successful.title=重定基底成功
rebase.operation.name=重定基底
rebase.option.interactive=在重定基底之前編輯提交
rebase.option.keep.empty=重定基底期間不移除空提交
rebase.option.onto=為重定基底的提交指定新基
rebase.option.rebase.merges=重新建立提交拓撲
rebase.option.root=重定基底分支中的所有提交
rebase.option.switch.to.branch=選擇另一個要重定基底的分支
rebase.options.modify.dialog.title=新增重定基底選項
rebase.progress.indicator.aborting.title=正在中止重定基底程序…
rebase.progress.indicator.conflicts.collecting.title=正在收集要解決的衝突…
rebase.progress.indicator.continue.title=正在繼續重定基底程序…
rebase.progress.indicator.preparing.title=正在準備重定基底…
rebase.progress.indicator.retry.title=正在重試重定基底程序…
rebase.progress.indicator.title=正在重定基底…
rebase.simple.editor.dialog.title=Git 編輯器
rebase.update.project.abort.task.title=正在中止重定基底…
rebase.update.project.conflict.error.notification.description=然後，您可以<b>繼續重定基底</b>。<br/>您也可以<b>中止重定基底</b>以還原原始分支並停止重定基底。
rebase.update.project.conflict.error.notification.title=無法繼續重定基底
rebase.update.project.conflict.merge.description.label=檢測到合併衝突。請先解決這些衝突，然後再繼續重定基底。
rebase.update.project.notification.abort.cancel.message=已取消中止重定基底
rebase.update.project.notification.abort.error.message=中止重定基底時出錯
rebase.update.project.notification.abort.success.message=已中止重定基底
rebase.update.project.notification.failed.message=無法繼續重定基底。{0}
rebase.update.project.notification.failed.title=重定基底錯誤
rebase.using.log.couldnt.start.error=由於 IDE 生成的 'git-rebase-todo' 檔案無效，因此無法執行重定基底。是否要使用 Git 原生檔案生成來重試重定基底?
rebasing.merge.commits.button.cancel=取消
rebasing.merge.commits.button.merge=合併
rebasing.merge.commits.button.rebase=重定基底
reference.validating.progress.indicator.title=正在驗證修訂…
remote.dialog.add.remote=新增遠端
remotes.changing.remote.error.message=無法將遠端 {0} 更改為 {1} ''{2}''
remotes.changing.remote.error.title=更改遠端
remotes.changing.remote.progress=正在更改遠端…
remotes.define.duplicate.remote.name.validation.message=遠端名稱 ''{0}'' 已被使用
remotes.define.empty.remote.name.validation.message=遠端名稱不能為空
remotes.define.empty.remote.url.validation.message=遠端 URL 不能為空
remotes.define.invalid.remote.name.validation.message=遠端名稱包含非法字元
remotes.define.remote=定義遠端
remotes.define.remote.name=名稱:
remotes.define.remote.url=URL:
remotes.dialog.adding.remote=正在新增遠端…
remotes.dialog.cannot.add.remote.error.message=無法新增遠端 {0} ''{1}''
remotes.dialog.remove.remote.message=移除{0,choice,1#遠端|2#遠端}{1}?
remotes.dialog.remove.remote.title=移除{0,choice,1#遠端|2#遠端}
remotes.dialog.removing.remote.error.message=無法移除{0, choice, 1#遠端|2#遠端} {1}
remotes.dialog.removing.remote.error.title=移除{0,choice,1#遠端|2#遠端}
remotes.dialog.removing.remote.progress=正在移除{0,choice,1#遠端|2#遠端}…
remotes.dialog.title=Git 遠端
remotes.operation.error.message=在 {1} 中{0}:\\n\\
{2}
remotes.operation.not.executed.message=動作未執行
remotes.remote.column.name=名稱
remotes.remote.column.url=URL
remove.removing=正在移除檔案…
rename.branch.operation.name=重新命名
repositories=版本庫
repository.action.missing.roots.misconfigured=組態的 Git 根都不在 Git 下。組態的目錄中必須包含“.git”目錄。
repository.action.missing.roots.title=沒有 Git 根
repository.action.missing.roots.unconfigured.message=沒有為專案組態 Git 根。
repository.not.found.error=找不到 {0} 的已組態 git 版本庫
reset.action.name=重設 Head…
reset.commit.invalid=指定的提交表達式未通過驗證。
reset.commit.label=為提交(&C):
reset.commit.tooltip=由於重設動作而將成為當前 HEAD 的提交。
reset.title=重設 Head
reset.type=重設類型(&T):
reset.type.tooltip=<html>重設類型(另請參閱 <code>git reset</code> man 頁面):<ul><li><b>Mixed</b> 將重設索引，但不會重設工作樹</li><li><b>Soft</b> 將保留索引和工作樹，只是移動 HEAD 指針</li><li><b>Hard</b> 將重設索引和工作樹。<em>工作樹中的更改會丟失</em></li></ul></html>
reset.validate=驗證(&V)
resetting.title=正在重設 HEAD…
restore.conflict.dialog.description.label.text=在 {0} 之前儲存的未提交更改與 {1} 中的檔案衝突
restore.conflict.diff.dialog.left.shelf.title=擱置中的未提交更改
restore.conflict.diff.dialog.left.stash.title=隱藏中的未提交更改
restore.conflict.diff.dialog.right.title=來自 {0} 的更改
restore.notification.failed.shelf.message=在更新之前，未提交的更改已儲存到<a href='saver'>擱置</a>。<br/>更新未完成，您的工作樹中有未解決的合併<br/>請解決衝突，完成更新並手動還原更改。
restore.notification.failed.stash.message=在更新之前，未提交的更改已儲存到<a href='saver'>隱藏</a>。<br/>更新未完成，您的工作樹中有未解決的合併<br/>請解決衝突，完成更新並手動還原更改。
restore.notification.failed.title=未還原本地更改
revert.operation.applied=還原
revert.operation.name=還原
revision.load.contents=載入修訂內容
revision.number.cannot.parse.output=無法解析輸出: [{0}]
save.load.conflict.dialog.diff.left.title=您未提交的更改
save.load.conflict.dialog.diff.right.title=遠端更改
save.notification.failed.shelf.text=試圖在 {0} 之前在擱置中儲存未提交的更改，但失敗並出現錯誤。<br/>{1}
save.notification.failed.stash.text=試圖在{0}之前在隱藏中儲存未提交的更改，但失敗並出現錯誤。<br/>{1}
save.notification.failed.title=無法儲存未提交的更改
search.everywhere.group.full.name=Git 參照
search.everywhere.group.name=Git
search.everywhere.items.commit.by.hash=提交(按雜湊)
search.everywhere.items.commit.by.message=提交(按訊息)
search.everywhere.items.local.branch=本地分支
search.everywhere.items.remote.branch=遠端分支
search.everywhere.items.tag=標記
separator.show=顯示
settings.add.suffix=在挑選推送到受保護分支的提交時，新增 'cherry-picked from <hash>' 後綴
settings.auto.update.on.push.rejected=如果當前分支的推送被拒，則自動更新
settings.clean.working.tree=使用以下方法清理工作樹:
settings.commit.group.title=提交
settings.configure.sign.gpg.do.not.sign.table.text=不簽署
settings.configure.sign.gpg.error.no.available.keys.found.text=找不到適用的私鑰
settings.configure.sign.gpg.error.table.text=錯誤: {0}
settings.configure.sign.gpg.for.repo.dialog.title=組態 GPG 密鑰 {0}
settings.configure.sign.gpg.for.repos.dialog.title=組態 GPG 密鑰
settings.configure.sign.gpg.gpg.kep.table.column.name=GPG 密鑰
settings.configure.sign.gpg.loading.table.text=正在載入…
settings.configure.sign.gpg.root.table.column.name=根
settings.configure.sign.gpg.synced.with.gitconfig.text=與 gitconfig 同步
settings.configure.sign.gpg.with.key.checkbox.text=使用 GPG 密鑰簽署提交:
settings.credential.helper=使用憑證幫助程序
settings.crlf=如果即將提交 CRLF 行分隔符，則發出警告
settings.detached.head=在游離的 HEAD 中或重定基底期間提交時發出警告
settings.enable.staging.area=啟用暫存區域
settings.enable.staging.area.comment=這將停用更改列表支援。僅適用於非強制回應提交介面。
settings.explicitly.check=顯式檢查遠端分支上的傳入提交:
settings.explicitly.check.condition.comment=需要在進階設定中啟用 ''{0}'' 選項
settings.filter.update.info=按路徑過濾“更新專案”資訊:
settings.git.incoming.change.strategy.text.always=始終
settings.git.incoming.change.strategy.text.auto=自動
settings.git.incoming.change.strategy.text.never=從不
settings.git.option.group=Git
settings.git.update.method.branch.default=分支預設
settings.git.update.method.merge=合併
settings.git.update.method.merge.description=將傳入更改合併到當前分支
settings.git.update.method.rebase=重定基底
settings.git.update.method.rebase.description=在傳入更改上重定基底當前分支
settings.label.sign.gpg.commits.enabled.different.keys.text=提交使用不同的 GPG 密鑰簽署
settings.label.sign.gpg.commits.enabled.n.roots.of.m.text=提交使用 {1} 的 {0} 個{0,choice,1#根|2#根}中的 GPG 密鑰簽署
settings.label.sign.gpg.commits.enabled.text=提交使用 GPG 密鑰簽署: {0}
settings.label.sign.gpg.commits.no.roots.text=專案中沒有 Git 根
settings.label.sign.gpg.commits.not.configured.text=未組態使用 GPG 密鑰簽署提交
settings.protected.branched=受保護分支:
settings.push.dialog=顯示提交和推送的推送對話框
settings.push.dialog.for.protected.branches=僅在提交到受保護分支時顯示推送對話框
settings.push.group.title=推送
settings.sign.gpg.configure.link.text=組態 GPG 密鑰…
settings.synchronize.branch.protection.rules=從 GitHub 載入分支保護規則
settings.synchronize.branch.protection.rules.description=將 GitHub 規則新增到本地規則中，並在每次獲取時進行同步
settings.update.group.title=更新
settings.update.method=更新方法:
show.diff.between.dialog.could.not.load.diff.with.branch.error=無法載入與 {0} 的差異: {1}
show.diff.between.dialog.no.differences.empty.text=無差異
show.diff.between.dialog.title={0}與當前工作樹之間的更改
smart.operation.dialog.don.t.operation.name=不{0}
smart.operation.dialog.git.operation.name.problem=Git {0} 問題
smart.operation.dialog.north.panel.label.shelf.text=<html>您對以下檔案的本地更改將被{0}覆蓋。<br/>{1}可以擱置這些更改，{0}，並在之後取消擱置。</html>
smart.operation.dialog.north.panel.label.stash.text=<html>您對以下檔案的本地更改將被{0}覆蓋。<br/>{1} 可以隱藏這些更改，{0}，並在之後取消隱藏。</html>
smart.operation.dialog.ok.action.shelf.description=擱置本地更改，{0}，取消擱置
smart.operation.dialog.ok.action.stash.description=隱藏本地更改，{0}，取消隱藏
smart.operation.dialog.operation.name.and.overwrite.local.changes={0}並覆蓋本地更改
smart.operation.dialog.smart.operation.name=智能{0}
stage.add.action.text=暫存
stage.add.error.title=無法暫存檔案
stage.add.no.content.action.text=無內容的暫存
stage.add.process=正在暫存檔案…
stage.add.range.command.name=暫存更改
stage.commit.all.amend.all.text=全部修正
stage.commit.all.amend.anyway.text=仍然全部修正
stage.commit.all.text=全部提交(&I)
stage.commit.failed=無法提交 {0}
stage.commit.process=正在提交暫存更改…
stage.commit.successful=已提交 {0}: {1}
stage.content.local=本地
stage.content.staged=已暫存
stage.diff.local.content.exception.message=無法獲取本地檔案: ''{0}''
stage.diff.staged.content.exception.message=無法獲取暫存內容: ''{0}''
stage.loading.status=正在載入更改…
stage.reset.action.text=取消暫存
stage.reset.error.title=無法取消暫存檔案
stage.reset.process=正在取消暫存檔案…
stage.revert.action.text=回滾
stage.revert.error.title=無法回滾檔案
stage.revert.process=正在回滾檔案…
stage.revert.staged.range.command.name=回滾暫存的更改
stage.revert.unstaged.range.command.name=回滾未暫存的更改
stage.tree.node.ignored=已忽略
stage.tree.node.staged=已暫存
stage.tree.node.unmerged=已取消合併
stage.tree.node.unstaged=未暫存
stage.tree.node.untracked=已取消追蹤
stage.vfs.editor.notification.link=開啟本地版本
stage.vfs.editor.notification.text=這是暫存版本的 ''{0}''
stage.vfs.editor.tab.tooltip=''{0}'' 的暫存版本
stage.vfs.presentable.file.name=已暫存: {0}
stage.vfs.read.process=正在從 Git 索引讀取 {0}
stage.vfs.shutdown.process=正在關閉 Git 索引 VFS
stage.vfs.write.process=正在將 {0} 寫入 Git 索引
stash.action.name=隱藏
stash.button=建立隱藏
stash.editor.diff.preview.empty.title=隱藏
stash.editor.diff.preview.id.change.title={0}: {1}
stash.empty.text.help.link=隱藏和擱置入門
stash.error=無法隱藏 {0}
stash.error.can.not.stash.changes.now=現在無法隱藏更改
stash.keep.index=保留索引(&I)
stash.keep.index.tooltip=如果選中此複選框，已建立索引的更改將保留在索引中。
stash.load.changes.error=無法在解析為 {1} 的隱藏中載入根 {0} 中的更改
stash.message=訊息(&M):
stash.message.tooltip=在此處輸入隱藏訊息。
stash.progress.indicator.title=正在隱藏來自 ''{0}'' 的更改…
stash.root.node.title=隱藏
stash.tab.name=隱藏和擱置
stash.title=隱藏
stash.unstash.changes.current.branch.label=當前分支:
stash.unstash.changes.in.root.dialog.title=取消隱藏 {0} 中的更改
stash.unstash.conflict.dialog.description.label.text=更新前隱藏的未提交更改與更新後的檔案衝突。
stash.unstash.progress.indicator.title=正在消除對 ''{0}'' 的更改…
stash.unstash.unresolved.conflict.warning.notification.message=您的未提交更改已儲存到<a href='saver'>隱藏</a>。<br/>取消隱藏未完成，您的工作樹中有未解決的合併<br/>請<a href='resolve'>解決</a>衝突並刪除隱藏。
stash.unstash.unresolved.conflict.warning.notification.title=本地更改已還原，但存在衝突
stashing.progress.title=正在隱藏更改…
stashing.title=正在隱藏更改…
status.exception.message.format.message.xstatus.ystatus.line.output={0} xStatus=[{1}]，yStatus=[{2}]，行=[{3}]\\n\\
輸出:\\n\\
{4}
status.exception.message.line.is.too.short=此行過短
status.exception.message.missing.path=缺少初始路徑
status.exception.message.unexpected=意外的狀態符號
status.exception.message.unexpected.status=意外的狀態符號: ''{0}''
status.exception.message.unexpected.xstatus.ystatus=意外的狀態符號: ''{0}{1}''
tab.title.conflicts=衝突
tab.title.repo.root.name.at.revision={1} 的 {0}
tag.action.name=標記
tag.button=建立標籤
tag.commit.label=提交(&C)
tag.commit.tooltip=輸入要標記的提交或物件的名稱，或留空以使用 HEAD。
tag.error.creating.message.file.message=無法建立訊息檔案: {0}
tag.error.invalid.commit=該提交或物件名稱無效。
tag.error.tag.exists=存在同名的標記。
tag.force=強制(&F)
tag.force.tooltip=強制建立標記，即使已存在另一個具有此名稱的標記。
tag.getting.existing.tags=正在獲取現有標記…
tag.message.label=訊息(&M):
tag.message.tooltip=如果訊息不為空，則建立帶註解的標記。
tag.name.label=標記名稱(&N):
tag.name.tooltip=在此處輸入新的標記名稱。
tag.progress.title=正在新增標記…
tag.title=標記
tag.validate=驗證(&V)
tag.validate.tooltip=點擊此按鈕驗證要標記的提交
text.crlf.fix.dialog.description.proposed.fix=如果選擇<b>修正並提交</b>，將執行 {0}。<br/>如果選擇<b>按原樣提交</b>，則不會更改組態值。
text.crlf.fix.dialog.description.warning=您即將把 CRLF 行分隔符提交到 Git 版本庫。<br/>建議將 {0} Git 特性設定為 {1}，以免發生行分隔符問題。
text.crlf.fix.notification.description.warning=您即將向 Git 版本庫提交 CRLF 行分隔符
title.changes.excluded.from.commit=已從合併提交中排除更改
title.crlf.fix.dialog=行分隔符警告
title.sudo.command.install.git=安裝 Git
title.unresolved.conflicts.pre.commit.check=未解決的衝突
title.user.name.email.not.specified=未定義 Git 用戶名
tooltip.run.git.hooks=如果未選中，將使用 '--no-verify' 參數跳過 Git hook
tracked.branch.fix.dialog.branch.placeholder=指定分支
tracked.branch.fix.dialog.not.on.branch.message=將跳過以下版本庫:
tracked.branch.fix.dialog.not.on.branch.title=游離的 HEAD 中的 Git 版本庫
tracked.branch.fix.dialog.ok.button.text=更新
tracked.branch.fix.dialog.set.as.tracked=設為追蹤分支
tracked.branch.fix.dialog.title=更新
unexpected.tree.entries.error=意外的樹條目: {0}
unexpected.tree.object.error=意外的樹物件: {0}
unstash.action.name=取消隱藏
unstash.branch.label=作為新分支(&B):
unstash.branch.tooltip=如果輸入非空名稱，該隱藏將作為新分支簽出。
unstash.button.apply=套用隱藏
unstash.button.branch=分支
unstash.button.pop=消除隱藏
unstash.clear=清除(&C)
unstash.clear.tooltip=刪除版本庫中的所有隱藏。
unstash.clearing.stashes=正在清除隱藏…
unstash.conflict.dialog.description.label.text=取消隱藏 {0} 時發生衝突
unstash.conflict.diff.dialog.left.title=本地更改
unstash.conflict.diff.dialog.right.title=來自隱藏的更改
unstash.dialog.remove.stash.progress.indicator.title=正在移除隱藏 {0}…
unstash.dialog.show.stashes.error.dialog.title=無法顯示隱藏列表
unstash.dialog.stash.list.load.progress.indicator.title=正在載入隱藏列表…
unstash.dialog.unresolved.conflict.warning.notification.message=取消隱藏未完成，您的工作樹中存在未解決的合併<br/>請<a href='resolve'>解決</a>衝突。
unstash.dialog.unresolved.conflict.warning.notification.title=取消隱藏期間未解決衝突
unstash.drop=刪除(&D)
unstash.drop.tooltip=刪除所選隱藏
unstash.error.can.not.unstash.changes.now=現在無法取消隱藏更改
unstash.operation.name=取消隱藏
unstash.pop.stash=消除隱藏(&P)
unstash.pop.stash.tooltip=如果選中，則該隱藏在套用後會被刪除。
unstash.reinstate.index=復原索引(&I)
unstash.reinstate.index.tooltip=嘗試復原索引以及工作樹更改。
unstash.stashes=隱藏(&S):
unstash.title=取消隱藏更改
unstash.unstashed.with.conflicts.error.title=已取消隱藏，但存在衝突
unstash.unstashing=正在取消隱藏…
unstash.view=檢視(&V)
unstash.view.dialog.title=受 {0} 影響的路徑
unstash.view.tooltip=檢視所選隱藏
update.checks.not.supported.git.2.9.required=不支持更新檢查。需要 Git 2.9 及以上版本
update.notification.choose.upstream.branch=選擇上游分支
update.notification.update.error=無法更新
update.options.display.name=Git 更新設定
update.process.error.additional.description.unfinished.rebase=然後，您可以<b>繼續重定基底</b>。<br/>您也可以<b>中止重定基底</b>以還原原始分支並停止重定基底。
update.process.error.description.unfinished.rebase=您有未完成的重定基底程序。必須先解決這些衝突，然後才能更新。
update.process.error.message.unfinished.merge=您有未完成的合併。必須先解決這些衝突，然後才能更新。
update.process.error.message.unmerged.files=檢測到未合併的檔案。必須先解決這些衝突，然後才能更新。
update.process.error.notification.title=無法設定上游分支
update.process.generic.error.title=無法更新
update.process.nothing.to.update=沒有要更新的內容
update.process.progress.title=正在更新…
update.skip.root.reason.detached.head=游離的 HEAD
update.skip.root.reason.no.tracked.branch=無追蹤分支
util.remote.renderer.none=無
validation.error.email.no.at=電子郵件地址必須包含 '@' 符號
validation.warning.set.name.email.for.git=您必須為 Git 指定用戶名和電子郵件
vcs.history.action.gitlog=在 Git 日誌中顯示
vcs.log.archiving.log.index.data=正在歸檔 Git 日誌索引資料…
vcs.log.create.archive.with.log.index.data=傾印 Git 日誌索引資料
vcs.log.status.bar.extracting.log.index.data=正在獲取 Git 日誌索引資料…
vcs.log.status.bar.replacing.log.index.data=正在取代 Git 日誌索引資料…
vcs.log.use.log.index.data=使用共享 Git 日誌索引資料
vfs.listener.add.single.prompt=是否要安排將以下檔案新增到 Git?\\n\\
{0}\\n\\
\\n\\
如果您選擇“取消”，以後仍可以手動新增。
vfs.listener.add.single.title=將檔案新增到 Git
vfs.listener.add.title=將檔案新增到 Git
vfs.listener.checking.ignored=正在檢查忽略的檔案…
vfs.listener.delete.single.prompt=是否要從 Git 中刪除以下檔案?\\n\\
{0}\\n\\
\\n\\
如果您選擇“取消”，以後仍可以手動刪除。
vfs.listener.delete.single.title=從 Git 中刪除檔案
vfs.listener.delete.title=從 Git 中刪除檔案
warning.message.commit.with.detached.head=以下路徑中的 Git 版本庫處於<b>游離的 HEAD</b> 狀態: <br/>{0}<br/>您可以進行檢查，嘗試做出更改並提交，但務必簽出分支，以免丟失您的工作。<br/>否則，可能會丟失所做的更改。
warning.message.commit.with.unfinished.rebase=以下路徑中的 Git 版本庫有一個<b>未完成的重定基底</b>程序: <br/> {0}<br/>您可能想<b>繼續重定基底</b>而不是提交。<br/>在重定基底期間提交可能會導致提交丟失。
warning.title.commit.with.detached.head=在游離的 HEAD 中提交
warning.title.commit.with.unfinished.rebase=未完成重定基底程序
warning.your.local.changes.would.be.overwritten.by.merge=您的本地更改將被合併覆蓋。\\n\\
提交、存儲或還原您的更改以繼續。"
`;

exports[`src messages/GithubBundle.properties 1`] = `
"account.choose.as.default=設定為當前專案的預設帳戶
account.choose.button=選擇
account.choose.for=選擇 GitHub 帳戶: {0}
account.choose.link=選擇帳戶
account.choose.not.selected=未選擇帳戶
account.choose.title=選擇 GitHub 帳戶
account.scopes.insufficient=安全作用域不足
account.token.missing=缺少存取令牌
account.token.missing.for=缺少 {0} 的存取令牌
accounts.add.button=新增帳戶
accounts.add.dropdown.link=新增帳戶
accounts.default.missing=缺少預設的 GitHub 帳戶
accounts.label.no.accounts=無帳戶
accounts.relogin=重新登入
action.Github.Accounts.AddGHAccount.text=通過 GitHub 登入…
action.Github.Accounts.AddGHAccountWithToken.text=通過令牌登入…
action.Github.Accounts.AddGHEAccount.text=登入 GitHub Enterprise…
action.Github.PullRequest.Copy.Link.text=複製拉取請求 URL
action.Github.PullRequest.Open.Link.text=在瀏覽器中開啟拉取請求
action.Github.Share.Vcs.Toolbar.Widget.text=GitHub…
action.comment.text=評論
button.login.mnemonic=登入(&L)
button.use.token=使用令牌…
cannot.configure.remote=無法組態 ''{0}'' 遠端:\\n{1}
cannot.create.gist=無法建立 Gist
cannot.display.item=無法顯示條目 - {0}
cannot.find.git.repo=找不到 Git 版本庫
cannot.get.last.revision=無法獲取最新修訂。
cannot.load.changes=無法載入更改
cannot.load.commits=無法載入提交
cannot.load.data=無法載入資料
cannot.load.data.from.github=無法從 GitHub 載入資料
cannot.load.details=無法載入詳細資訊
cannot.load.repo.info=無法載入版本庫資訊
cannot.open.in.browser=無法在瀏覽器中開啟
clone.button=克隆
clone.dialog.clone.failed=克隆失敗
clone.dialog.directory.field=目錄:
clone.dialog.text=克隆 ''{0}''
clone.error.load.repositories=無法載入版本庫
clone.error.unable.to.create.dest.dir=無法建立目標目錄
clone.error.unable.to.find.dest=找不到目標
create.gist.action.description=建立 GitHub gist
create.gist.action.title=建立 Gist…
create.gist.dialog.copy.url=複製 URL
create.gist.dialog.create.for.field=為以下帳戶建立:
create.gist.dialog.description.field=描述:
create.gist.dialog.filename.field=檔名:
create.gist.dialog.open.browser=在瀏覽器中開啟
create.gist.dialog.secret=私密
create.gist.dialog.title=建立 Gist
create.gist.error.binary.file=無法上傳二進制檔案: {0}
create.gist.error.content.read=無法讀取檔案 {0} 的內容
create.gist.error.empty=無法建立空 gist
create.gist.process=正在建立 gist…
create.gist.success=已成功建立 Gist
create.gist.url=您的 gist url
credentials.button.generate=生成…
credentials.incorrect=憑證不正確。\\n{0}
credentials.invalid.auth.data=身份驗證資料無效。\\n{0}
credentials.invalid.server.path=伺服器路徑無效
credentials.server.cannot.be.empty=伺服器不能為空
credentials.server.field=伺服器:
credentials.server.path.invalid=伺服器 URL 無效
credentials.token.field=令牌:
dialog.message.account.cannot.be.empty=帳戶不能為空
dialog.message.login.to.continue=登入到 GitHub 以繼續
dialog.title.add.github.account=新增 GitHub 帳戶
gql.error.in.field={1} 的“{2}”欄位中存在 {0} 錯誤
group.GitHub.Copy.Link.CopyReferencePopup.text=GitHub 版本庫 URL
group.GitHub.Copy.Link.text=將鏈接複製到 GitHub 版本庫
group.GitHub.MainMenu.text=GitHub
group.Github.Open.In.Browser.EditorTabPopup.text=GitHub
group.Github.PullRequest.Combined.Diff.Thread.View.Options.text=顯示審查討論
group.Github.PullRequest.Details.Commit.Tree.ViewOptions.text=檢視選項
group.Github.PullRequest.Diff.Thread.View.Options.text=顯示審查討論
issue.state.closed=已關閉
issue.state.open=開放
label.login.option.separator=或
label.login.progress=正在登入…
link.label.use.token=使用令牌…
login.account.already.added=已新增帳戶 ''{0}''
login.insufficient.scopes=必須為存取令牌授予以下作用域: {0}
login.to.github=登入 GitHub
login.to.github.enterprise=登入 GitHub Enterprise
login.to.github.enterprise.action=登入 GitHub Enterprise…
login.token.cannot.be.empty=令牌不能為空
login.via.github.action=通過 GitHub 登入…
login.with.token.action=通過令牌登入…
open.in.browser.link=在瀏覽器中開啟
open.on.github.action=在 GitHub 上開啟
open.on.github.action.description=在瀏覽器中開啟相應鏈接
progress.text.loading.protected.branches=正在載入 GitHub 分支保護規則
pull.request.adding.reviewers=正在新增審查者
pull.request.adjustment.failed=無法調整列表
pull.request.assignees=被指派者
pull.request.assignees.popup={0, choice, 1#被指派者|2#被指派者}
pull.request.back.to.list=返回列表
pull.request.branch.action.group.name=動作(&A)
pull.request.branch.checkout.remote.cannot.find=找不到遠端
pull.request.branch.checkout.resolve.author.failed=無法解析拉取請求作者
pull.request.branch.checkout.resolve.remote.failed=無法解析拉取請求遠端
pull.request.branch.checkout.task.indicator=正在簽出分支
pull.request.branch.checkout.task.title=從拉取請求簽出分支
pull.request.branch.out.of.sync=拉取請求分支與基礎分支不同步
pull.request.branch.update.action=更新本地分支…
pull.request.branch.update.action.description=更新拉取請求本地分支
pull.request.change.remote.or.account=更改版本庫或帳戶…
pull.request.checks={0, choice, 1#檢查|2#檢查}
pull.request.checks.failing={0} 個失敗
pull.request.checks.pending={0} 個掛起
pull.request.checks.successful={0} 個成功
pull.request.close.action=關閉拉取請求
pull.request.comment.hint={0} 以評論
pull.request.comment.save=儲存更改
pull.request.comment.save.hint={0}以儲存更改
pull.request.commit.does.not.contain.changes=提交不包含任何更改
pull.request.commits=提交
pull.request.conflicts.checking=正在檢查自動合併的能力…
pull.request.conflicts.merge.tooltip=拉取請求無法合併
pull.request.conflicts.must.be.resolved=分支具有必須解決的衝突
pull.request.conflicts.none=分支與基礎分支沒有衝突
pull.request.create.action=建立拉取請求
pull.request.create.already.exists=拉取請求已存在
pull.request.create.already.exists.view=檢視
pull.request.create.description=描述
pull.request.create.discard.approve=刪除草稿
pull.request.create.discard.message=是否要刪除新拉取請求的草稿?
pull.request.create.discard.title=刪除拉取請求草稿
pull.request.create.draft.action=建立草稿拉取請求
pull.request.create.error=無法建立新的拉取請求:
pull.request.create.input.remote.branch.comment=必須推送更改才能建立拉取請求，並且本地分支 ''{0}'' 不會追蹤 ''{1}'' 處的遠端分支
pull.request.create.input.remote.branch.name=遠端分支名稱:
pull.request.create.input.remote.branch.title=拉取請求分支
pull.request.create.loading.template=正在載入模板…
pull.request.create.no.changes=''{0}'' 和 ''{1}'' 之間沒有更改
pull.request.create.process.title=正在建立拉取請求…
pull.request.create.select.branches=已選擇拉取請求的 base 和 head 來檢視更改
pull.request.create.show.form.action=建立拉取請求…
pull.request.create.title=標題
pull.request.details.adjusting.assignees=正在調整被指派者…
pull.request.details.adjusting.labels=正在調整標籤…
pull.request.details.adjusting.reviewers=正在調整審查者…
pull.request.diff.editor.add.multiline.comment=新增一條多行評論
pull.request.diff.editor.add.multiline.review.comment=添加多行審查評論
pull.request.diff.editor.add.review.comment=新增審查評論
pull.request.diff.editor.add.single.comment=新增一條評論
pull.request.diff.editor.review.comment=評論
pull.request.diff.editor.review.start=開始審查
pull.request.diff.editor.review.with.comment=以評論開始審查
pull.request.diff.editor.start.review.with.multiline.comment=以多行評論開始審查
pull.request.diff.editor.title=拉取請求 #{0,number,#} 的差異
pull.request.diff.view.options=檢視選項
pull.request.discard.pending.comments=捨棄待定評論
pull.request.discard.pending.comments.dialog.msg=確定要刪除所有待定評論嗎?
pull.request.discard.pending.comments.dialog.title=捨棄待定審查
pull.request.does.not.contain.changes=拉取請求不包含任何更改
pull.request.does.not.contain.commits=拉取請求不包含任何提交
pull.request.editor.timeline=拉取請求時間線
pull.request.existing.process.title=正在檢查是否已存在拉取請求…
pull.request.files=檔案
pull.request.info=資訊
pull.request.labels=標籤
pull.request.labels.popup={0, choice, 1#標籤|2#標籤}
pull.request.list.cannot.load=無法載入拉取請求
pull.request.list.error.authorization=使用者授權失敗
pull.request.list.filter.assignee=被指派者
pull.request.list.filter.author=作者
pull.request.list.filter.label=標籤
pull.request.list.filter.quick.assigned=已分配給您
pull.request.list.filter.quick.open=開啟
pull.request.list.filter.quick.review.requests=審查請求
pull.request.list.filter.quick.yours=您的拉取請求
pull.request.list.filter.review=審查
pull.request.list.filter.review.approved.full=批准的審查
pull.request.list.filter.review.approved.short=批准的審查
pull.request.list.filter.review.awaiting.full=正在等待您的審查
pull.request.list.filter.review.awaiting.short=正在等待審查
pull.request.list.filter.review.change.requested.full=請求的更改
pull.request.list.filter.review.change.requested.short=請求的更改
pull.request.list.filter.review.no.full=無審查
pull.request.list.filter.review.no.short=無審查
pull.request.list.filter.review.not.full=未由您審查
pull.request.list.filter.review.not.short=未審查
pull.request.list.filter.review.required.full=需要審查
pull.request.list.filter.review.required.short=需要審查
pull.request.list.filter.review.reviewed.full=由您審查
pull.request.list.filter.review.reviewed.short=已審查
pull.request.list.filter.state=狀態
pull.request.list.filter.state.closed=已關閉
pull.request.list.filter.state.merged=已合併
pull.request.list.filter.state.open=開放
pull.request.list.filters.clear=清除篩選器
pull.request.list.filters.reset.to.default=重設為{0}
pull.request.list.no.matches=沒有與篩選器符合的拉取請求。
pull.request.list.nothing.loaded={0} 中沒有拉取請求
pull.request.list.outdated=該列表已過時。
pull.request.list.refresh=重新整理
pull.request.loading.account.info=正在載入帳戶資訊
pull.request.loading.ghost=正在載入已刪除的使用者存根
pull.request.loading.repo.info=正在載入版本庫資訊
pull.request.loading.status=正在載入拉取請求狀態
pull.request.loading.user.teams.info=正在載入使用者團隊資訊
pull.request.mark.ready.for.review=標記為可供審查
pull.request.merge.commit.action=合併拉取請求…
pull.request.merge.disabled=此專案已停用合併
pull.request.merge.message.dialog.title=合併拉取請求
pull.request.merge.pull.request=合併拉取請求 #{0,number,#}
pull.request.merge.rebase.action=重定基底並合併
pull.request.merge.squash.action=壓縮並合併…
pull.request.new.diff.editor.title=新拉取請求的差異
pull.request.new.line.hint={0}以新增新行
pull.request.no.labels=無標籤
pull.request.no.reviewers=無審查者
pull.request.open.action=檢視拉取請求
pull.request.open.action.description=檢視拉取請求資訊和時間線
pull.request.post.action=發佈拉取請求
pull.request.refresh.changes.action=重新整理拉取請求更改
pull.request.refresh.comments.action=重新整理拉取請求評論
pull.request.refresh.details.action=重新整理拉取請求
pull.request.refresh.list.action=重新整理列表
pull.request.refresh.state.action=重新整理拉取請求狀態
pull.request.removing.reviewers=正在移除審查者
pull.request.reopen.action=重新開啟拉取請求
pull.request.repo.access.required=必須具有版本庫存取權限才能管理拉取請求
pull.request.repo.write.access.required=必須具有版本庫寫存取權限才能合併拉取請求
pull.request.review.actions.more.name=拉取請求動作
pull.request.review.actions.submit={0, choice, 0#提交審查…|1#提交審查({0})…}
pull.request.review.comment.empty.text=審查評論
pull.request.review.commented={0} 在 {1} 新增了評論
pull.request.review.not.supported.non.linear=非線性提交歷史記錄不支持按提交審查
pull.request.review.refresh.data.task=重新整理審查資料
pull.request.review.refresh.data.task.description=重新整理 GitHub 拉取請求審查資訊
pull.request.review.submit=提交…
pull.request.review.submit.action.description=提交拉取請求審查
pull.request.review.submit.approve.button=批准
pull.request.review.submit.comment.button=評論
pull.request.review.submit.comment.description=提交不需要明確批准的一般反饋
pull.request.review.submit.error=提交審查時發生錯誤
pull.request.review.submit.request.changes=請求更改
pull.request.review.thread.outdated=過時
pull.request.review.thread.reply.hint={0} 以回復
pull.request.reviewers=審查者
pull.request.reviewers.popup={0, choice, 1#審查者|2#審查者}
pull.request.select.action=選擇開放的拉取請求
pull.request.select.commit.to.view.changes=選擇要檢視更改的提交
pull.request.state.cannot.load=無法載入狀態
pull.request.state.closed.long=拉取請求已關閉
pull.request.state.merged.long=拉取請求已合併
pull.request.timeline.approved.changes=批准了這些更改
pull.request.timeline.branch.deleted=刪除了 {0} 分支
pull.request.timeline.branch.force.pushed=強制推送了 {0} 分支
pull.request.timeline.branch.head.restored=還原了 head 分支
pull.request.timeline.cannot.load=無法載入時間線條目
pull.request.timeline.changed.base.branch=更改了基礎分支
pull.request.timeline.closed=關閉了此請求
pull.request.timeline.comment.suggested.changes=建議的更改
pull.request.timeline.comment.suggested.changes.action.commit.name=提交…
pull.request.timeline.comment.suggested.changes.button=區域套用
pull.request.timeline.comment.suggested.changes.progress.bar.apply=套用建議的更改
pull.request.timeline.comment.suggested.changes.progress.bar.commit=提交建議的更改
pull.request.timeline.comment.suggested.changes.tooltip.different.branch=無法在其他分支中套用來自拉取請求的建議更改
pull.request.timeline.comment.suggested.changes.tooltip.outdated=無法套用過時的建議
pull.request.timeline.comment.suggested.changes.tooltip.resolved=此建議已解決
pull.request.timeline.commented=新增了評論
pull.request.timeline.commit.added=已將提交新增到此拉取請求
pull.request.timeline.commits.added=已將 {0} 個提交新增到此拉取請求
pull.request.timeline.connected=鏈接了可能由此物件關閉的問題
pull.request.timeline.created=已建立
pull.request.timeline.disconnected=移除了一個指向問題的鏈接
pull.request.timeline.event.assigned=指派 {0}
pull.request.timeline.event.assigned.and.unassigned=指派 {0} 並取消指派 {1}
pull.request.timeline.event.labels.added=新增標籤 {0}
pull.request.timeline.event.labels.added.and.removed=新增標籤 {0} 並移除 {1}
pull.request.timeline.event.labels.removed=移除標籤 {0}
pull.request.timeline.event.removed.review.request=從 {0} 中移除審查請求
pull.request.timeline.event.requested.review=從 {0} 請求審查
pull.request.timeline.event.requested.review.and.removed.review.request=從 {0} 請求審查並從 {1} 中移除審查請求
pull.request.timeline.event.unassigned=取消指派 {0}
pull.request.timeline.marked.as.draft=將此拉取請求標記為草稿
pull.request.timeline.marked.as.ready=將此拉取請求標記為可供審查
pull.request.timeline.mentioned=提及了此拉取請求
pull.request.timeline.merged=合併了此請求
pull.request.timeline.merged.commit=已將提交 {0} 合併到 {1}
pull.request.timeline.no.description=未提供描述
pull.request.timeline.refresh.action=重新整理時間線
pull.request.timeline.refresh.action.description=檢查新時間線事件
pull.request.timeline.renamed=將此拉取請求從 ''{0}'' 重命名為 ''{1}''
pull.request.timeline.reopened=重新開啟了此請求
pull.request.timeline.requested.changes=請求了更改
pull.request.timeline.review.thread.collapse=隱藏執行緒
pull.request.timeline.review.thread.expand=顯示執行緒
pull.request.timeline.reviewed=審查了更改
pull.request.timeline.stale.review.dismissed=忽略了 <b>{0}</b> 過時的審查
pull.request.timeline.started.review=開始了審查
pull.request.unassigned=未分配
pull.request.unresolved.comments={0,choice,0#沒有未解決的註釋|1#{0} 個未解決的註釋|2#{0} 個未解決的註釋}
pull.request.view.conversations.action.description=檢視拉取請求時間線
pull.request.view.list=檢視拉取請求
rebase.action=同步複刻
rebase.action.description=相對於來源重定基底 GitHub 複刻版本庫
rebase.error=無法執行 GitHub 重定基底
rebase.error.failed.to.match.gh.repo=無法符合本地版本庫和 GitHub 版本庫
rebase.error.multi.repo.not.supported=不支持多版本庫專案
rebase.error.no.default.branch=無法確定上游分支 - 沒有為版本庫設定預設分支
rebase.error.no.suitable.account.found=找不到合適的 GitHub 帳戶
rebase.error.remote.origin.not.found=找不到 Git 遠端 'origin'
rebase.error.repo.not.found=找不到版本庫 {0}
rebase.error.upstream.not.found=未新增遠端 {0}
rebase.process=正在重定基底 GitHub 複刻…
rebase.process.adding.github.parent.as.remote.host=正在將 GitHub 父項新增為遠端主機…
rebase.process.configuring.upstream.remote=正在組態上游遠端…
rebase.process.fetching.upstream=正在獲取上游…
rebase.process.operation.title=正在重定基底
rebase.process.rebasing.branch.onto=正在將當前分支重定基底到 ''{0}''…
rebase.process.rebasing.onto=正在重定基底到 ''{0}''…
rebase.process.success=已成功重定基底 GitHub 複刻
request.response.0=請求響應: {0}。
retry.action=重試
retry.link=重試
server.unreachable=伺服器無法到達
settings.clone.ssh=使用 ssh 克隆 Git 版本庫
settings.timeout=連線超時:
settings.timeout.seconds=秒
share.action=在 GitHub 上共享專案
share.action.description=在 GitHub 上輕鬆共享專案
share.action.remote.is.on.github=遠端已經在 GitHub 上:
share.action.remotes.are.on.github=GitHub 上已經有以下遠端:
share.anyway.button=仍然共享
share.button=共享
share.dialog.account.info.load.error.prefix=無法載入 {0} 的資訊:
share.dialog.account.info.load.process.canceled=已取消程序
share.dialog.description=描述:
share.dialog.private=私有
share.dialog.remote=遠端:
share.dialog.repo.name=版本庫名稱:
share.dialog.share.by=共享者:
share.error.cannot.finish=無法完成 GitHub 共享過程
share.error.created.project=已在 GitHub 上成功建立專案
share.error.failed.to.create.repo=無法建立 GitHub 版本庫
share.error.init.commit.failed=，但初始提交失敗:<br/>
share.error.private.repos.not.supported=您的帳戶不支持私有版本庫
share.error.project.is.on.github=專案已在 GitHub 上
share.error.push.failed=，但初始推送失敗:<br/>{0}
share.error.push.no.current.branch=，但初始推送失敗: 沒有當前分支
share.error.remote.with.selected.name.exists=已存在具有所選名稱的遠端
share.error.repo.with.selected.name.exists=已存在具有所選名稱的版本庫
share.on.github=在 GitHub 上共享專案
share.process=正在 GitHub 上共享專案…
share.process.adding.files=正在將檔案新增到 git…
share.process.adding.gh.as.remote.host=正在將 GitHub 新增為遠端主機…
share.process.creating.git.repository=正在建立空 git 版本庫…
share.process.creating.repository=正在建立 GitHub 版本庫…
share.process.empty.project.created=已在 GitHub 上成功建立空版本庫
share.process.loading.account.info=正在載入 {0} 的帳戶資訊
share.process.performing.commit=正在執行提交…
share.process.pushing.to.github.master=正在推送到 GitHub master…
share.process.retrieving.username=正在檢索用戶名…
share.process.successfully.shared=已在 GitHub 上成功共享專案
share.validation.invalid.repo.name=版本庫名稱無效。名稱應由字母、數字、短划線、點和下劃線組成
share.validation.no.remote.name=未選擇遠端名稱
share.validation.no.repo.name=未選擇版本庫名稱
tab.title.pull.requests.new=在 {0} 新增拉取請求
task.comment.author=作者:
task.comment.date=日期:
task.repo.host.field=主機:
task.repo.name.field.empty.hint=版本庫名稱
task.repo.owner.field.empty.hint=版本庫所有者
task.repo.repository.field=版本庫:
task.repo.token.create.button=建立 API 令牌
task.repo.token.field=API 令牌:
task.repo.token.field.empty.hint=OAuth2 令牌
toolwindow.stripe.Pull_Requests=拉取請求
unknown.loading.error=未知載入錯誤
untracked.files.dialog.title=為初始提交新增檔案"
`;

exports[`src messages/IdeBundle.properties 1`] = `
"FileChooser.detailsViewActionLabelText=詳細資訊
FileChooser.listViewActionLabelText=列表
FileChooser.newFolderActionLabelText=新增目錄
FileChooser.refreshActionLabelText=重新整理
FileChooser.viewMenuLabelText=檢視
ShowUsagesTableCellRenderer.accessible.CURRENT_ASTERISK_COL=當前用法
ShowUsagesTableCellRenderer.accessible.FILE_GROUP_COL=檔案 {0}
ShowUsagesTableCellRenderer.accessible.LINE_NUMBER_COL=行 {0}
ShowUsagesTableCellRenderer.accessible.OTHER_ASTERISK_COL=另一種用法
ShowUsagesTableCellRenderer.accessible.USAGE_TEXT_COL=用法文本 {0}
about.box.build.date=，{0} 建置
about.box.build.date.time=，{0} {1} 建置
about.box.build.number=構建版本 #{0}
about.box.jre=運行時版本: {0} {1}
about.box.open.source.software=開源軟體
about.box.powered.by=技術支援:
about.box.powered.by.open.source=<hyperlink>開源軟體</hyperlink>
about.box.vm=VM: {0}，{1}
about.popup.about.app=關於 {0}
about.popup.system.info=系統資訊\\n\\
{0}\\n\\
{1}
accessible.name.annotation=註解: {0}
accessible.name.empty=空
accessible.name.icon=圖標: {0}
accessible.name.line=行 {0}
action.ActionTracer.Anonymous.description.clear.log=清除日誌
action.ActionTracer.Anonymous.text.Clear=清除
action.AnAction.description.activate.frame.and.run=啟用框架並執行
action.AnAction.description.clear=清除
action.AnAction.description.new.script=新增腳本
action.AnAction.description.reload.list=重新載入列表
action.AnAction.description.run.on.frame.activation=在框架啟用時執行
action.AnAction.description.save=儲存
action.AnAction.description.search.history=搜尋歷史記錄
action.AnAction.description.set.script.file=設定腳本檔案
action.AnAction.description.stop=停止
action.AnAction.text.activate.frame.and.run=啟用框架並執行
action.AnAction.text.clear=清除
action.AnAction.text.new.script=新增腳本
action.AnAction.text.reload.list=重新載入列表
action.AnAction.text.run.on.frame.activation=在框架啟用時執行
action.AnAction.text.save=儲存
action.AnAction.text.search.history=搜尋歷史記錄
action.AnAction.text.set.script.file=設定腳本檔案
action.AnAction.text.stop=停止
action.AnActionButton.text.change.goto.check.box=更改“轉到”複選框
action.AnActionButton.text.install=安裝
action.AnActionButton.text.reload.list.of.packages=重新載入軟體套件列表
action.AnActionButton.text.uninstall=移除
action.AnActionButton.text.upgrade=升級
action.Anonymous.text.add.abbreviation=新增縮寫
action.Anonymous.text.add.keyboard.shortcut=新增鍵盤快捷鍵
action.Anonymous.text.add.mouse.shortcut=新增滑鼠快捷方式
action.Anonymous.text.all=所有
action.Anonymous.text.back=後退
action.Anonymous.text.change.context=更改上下文…
action.Anonymous.text.configure=組態
action.Anonymous.text.delete.hook=刪除掛鈎
action.Anonymous.text.do.not.show.again=不再顯示
action.Anonymous.text.done=完成
action.Anonymous.text.edit.scopes.order=編輯作用域順序…
action.Anonymous.text.highlight=醒目提示顯示
action.Anonymous.text.live.template=實時模板
action.Anonymous.text.live.templates=實時模板
action.Anonymous.text.new.group=新增組…
action.Anonymous.text.new.tag=新增標記
action.Anonymous.text.remove.leading.directory=移除前導目錄
action.Anonymous.text.rename=重新命名
action.Anonymous.text.reset.shortcuts=重設快捷鍵
action.Anonymous.text.restore.leading.directory=還原前導目錄
action.Anonymous.text.template.group=模板組…
action.Anonymous.text.toggle=切換
action.ChangeProjectColorAction.Amber.title=Amber
action.ChangeProjectColorAction.Cobalt.title=Cobalt
action.ChangeProjectColorAction.Current.title={0} (Current)
action.ChangeProjectColorAction.Grass.title=Grass
action.ChangeProjectColorAction.Ocean.title=Ocean
action.ChangeProjectColorAction.Olive.title=Olive
action.ChangeProjectColorAction.Plum.title=Plum
action.ChangeProjectColorAction.Rust.title=Rust
action.ChangeProjectColorAction.Sky.title=Sky
action.ChangeProjectColorAction.Violet.title=紫色
action.ChooseCustomProjectColorAction.title=Custom Color...
action.CollapseAllAction.text.collapse.all=全部摺疊
action.ComboContentLayout.close.other.views.text=關閉其他檢視
action.ComboContentLayout.close.view.text=關閉檢視
action.ComboContentLayout.select.next.view.text=選擇下一個檢視
action.ComboContentLayout.select.previous.view.text=選擇上一個檢視
action.DataSharingOptionsAction.description=資料共享選項
action.DataSharingOptionsAction.text=資料共享選項…
action.DescriptionAwareSchemeActions.add.description.text=新增描述…
action.DescriptionAwareSchemeActions.edit.description.text=編輯描述…
action.DumbAware.BuildView.text.stop=BuildView
action.DumbAware.CopyrightProfilesPanel.description.stop=停止
action.DumbAware.TerminalView.text.new.session=新增會話
action.Events=事件
action.ExpandAllAction.text.expand.all=全部展開
action.FinderRecursivePanel.text.edit=編輯
action.FinderRecursivePanel.text.next=下一個
action.FinderRecursivePanel.text.previous=上一個
action.GetHelp=獲取幫助
action.InstallFromDiskAction.not.allowed.description=您的組織不允許從磁碟安裝延伸模組
action.InstallFromDiskAction.progress.text=正在安裝延伸模組
action.InstallFromDiskAction.text=從磁碟安裝延伸模組…
action.MarkAllNotificationsAsReadAction.description=將所有未讀通知標記為已讀
action.MarkAllNotificationsAsReadAction.text=將所有通知標記為已讀
action.NamedItemsListEditor.AddAction.description.add=新增
action.NamedItemsListEditor.AddAction.text.add=新增
action.NamedItemsListEditor.CopyAction.description.copy=複製
action.NamedItemsListEditor.CopyAction.text.copy=複製
action.OpenUrlHyperlinkInfo.Anonymous.description.copy.url.to.clipboard=將 URL 複製到剪貼簿
action.OpenUrlHyperlinkInfo.Anonymous.text.copy.url=複製 URL
action.QuickChangeCodeStyleSchemeAction.Anonymous.text.project=<專案>
action.ReopenProject.reopen.project.text=重新開啟專案
action.SwitchToJBR.text=切換到捆綁執行時
action.ToggleAction.description.pin.window=固定視窗
action.ToggleAction.description.toggle.auto.test=程式碼更改時切換測試的自動重新執行
action.ToggleAction.show.filter.description.show.filters.popup=顯示篩選器彈出視窗
action.ToggleAction.show.filter.text.filter=篩選
action.ToggleAction.text.filter=篩選
action.ToggleAction.text.filter.files.by.type=按類型篩選檔案
action.ToggleAction.text.pin.window=固定視窗
action.ToggleAction.text.toggle.auto.test=自動重新執行
action.ToggleAction.text.toggle.view=切換檢視
action.UpdateIde.button.postpone=推遲
action.UpdateIde.progress.text.new.installation.prepared.ide.will.restart=新安裝已準備，IDE 將在 {0, choice, 1#1 秒|2#{0} 秒}後重啟
action.UpdateIde.task.success.content=新安裝準備就緒
action.UpdateIde.task.success.restart=重新啟動
action.UpdateIde.task.success.title=IDE 更新
action.abbreviate.qualified.package.names=縮寫限定軟體套件名稱
action.activate.tool.window=啟用{0}視窗
action.add.all.open.tabs.to.new.favorites.list=將所有開啟的頁籤新增到新收藏夾列表
action.add.repository=新增儲存庫
action.add.to.new.favorites.list=新增到新收藏夾列表(_N)
action.add.to.new.favorites.list.description=新增到新收藏夾列表
action.append=追加
action.base.on.this.0=基於此{0}
action.base.on.this.class=基於此類別
action.base.on.this.method=基於此方法
action.browse.call.hierarchy=瀏覽呼叫層次結構
action.browse.method.hierarchy=瀏覽方法層次結構
action.browse.type.hierarchy=瀏覽類型層次結構
action.callee.methods.hierarchy=被呼叫方方法層次結構
action.caller.methods.hierarchy=呼叫方方法層次結構
action.choose.actions.to.add=新增動作
action.clear.encoding.description=清除預設編碼。
action.clear.encoding.description.file=清除檔案 ''{0}'' 編碼。
action.close=關閉(_C)
action.close.all.editors.above=關閉上方頁籤
action.close.all.editors.below=關閉下方頁籤
action.close.all.editors.in.tab.group=關閉組內所有頁籤(_A)
action.close.all.readonly.editors=關閉所有唯讀項
action.close.all.readonly.editors.in.tab.group=關閉組中的所有唯讀項
action.close.all.unmodified.editors=關閉未修改頁籤(_U)
action.close.all.unmodified.editors.in.tab.group=關閉組內未修改頁籤(_U)
action.close.all.unpinned.editors=關閉所有未固定頁籤
action.close.all.unpinned.editors.in.tab.group=關閉組中的未固定頁籤
action.close.projects.in.current.window=關閉當前視窗中的專案(_J)
action.collapse=摺疊
action.collapse.all=全部摺疊
action.compact.empty.middle.packages=壓縮空的中間軟體套件
action.copy.link.text=複製 {0} 鏈接
action.copy.path=複製絕對路徑(_O)
action.copy.paths=複製絕對路徑(_O)
action.copy.template=複製模板
action.create.child.template=建立子模板檔案
action.create.new.class.name.field=名稱
action.create.new.directory.or.package=建立新目錄或軟體套件
action.create.new.file.description=建立新檔案
action.create.template=建立模板
action.customizations.customize.action=自訂工具列…
action.delete=刪除(_D)
action.delete.ellipsis=刪除(_D)…
action.description.clear.the.contents.of.the.event.log=清除事件日誌的內容
action.description.create.new.module.group=建立新模組組
action.description.create.new.package=建立新的軟體套件
action.description.edit.notification.settings=編輯通知設定
action.description.pin.tool.window.to.0.side.ui.designer.editor=將工具視窗固定到{0}側 UI 設計器編輯器
action.description.show.files=顯示/隱藏檔案
action.description.show.included.only=僅顯示包含到當前所選作用域的檔案
action.description.show.modules=顯示/隱藏模組
action.description.todo.show.all=顯示全部 TODO 項
action.description.unpin.tool.window.from.designer.editor=從設計器編輯器取消固定工具視窗
action.description.view.class.hierarchy=選擇類別層次結構
action.description.view.subtypes.hierarchy=切換到子類型層次結構
action.description.view.supertypes.hierarchy=切換到父類型層次結構
action.descriptor.action=動作: {0}
action.descriptor.keystroke=按鍵:“{0}”
action.descriptor.typing=輸入:“{0}”
action.directory=目錄
action.dont.show.again.text=不再顯示
action.download.and.install.plugin=下載並安裝
action.edit.file.templates=編輯檔案模板…
action.edit.repository.url=編輯儲存庫 URL
action.empty.group.text=空組
action.empty.unnamed.group.text=空未命名組
action.enable.disable.global.menu.integration.description=啟用/停用全域選單整合(所有框架)
action.exclude.all.text=全部排除
action.expand=展開
action.expand.all=全部展開
action.explorer.text=資源管理器
action.file.manager.text=檔案管理器
action.filter.todo.items=篩選 TODO 條目
action.finder.text=訪達
action.flatten.packages=平展軟體套件
action.flatten.view=平展檢視
action.fn.keys.text=Fn 鍵
action.from.file.template=從檔案模板…
action.group.by.modules=模組
action.group.by.packages=軟體套件
action.group.macos.shortcuts.text=macOS 快捷鍵
action.group.name.unnamed.group=<未命名組>
action.help=幫助
action.hide.all.windows=隱藏所有視窗(_W)
action.hide.empty.middle.packages=隱藏空的中間軟體套件
action.hide.non.implementations=隱藏方法未合法實作的類別 
action.include.all.text=全部包含
action.invoke.macro.text=呼叫巨集
action.jcef.followInstructions=遵循指令
action.jcef.restart=重啟
action.label.hide.notification=隱藏通知
action.manual.order=手動排序
action.maximize.editor=最大化編輯器
action.maximize.text=最大化
action.move.module.new.top.level.group=新增頂層組…
action.move.module.outside.any.group=在任意組外
action.move.module.to.new.sub.group=到新子組…
action.move.module.to.this.group=到此組
action.new.package=新增軟體套件…
action.next.message=下一條訊息
action.next.problem=下一個問題
action.next.tip=下一步(&N)
action.next.todo=下一個 TODO
action.normalize.splits=標準化拆分
action.open.editor.settings.text=開啟設定
action.open.tip=開啟(&O)…
action.open.web.preview.text=內建預覽
action.overwrite=覆蓋
action.package=軟體套件
action.pin.tab=固定頁籤(_I)
action.presentation.AbstractSchemesPanel.description=顯示方案動作
action.presentation.AbstractSchemesPanel.text=顯示方案動作
action.presentation.EditorTabbedContainer.text=關閉。按 Alt 並點擊以關閉其他。
action.presentation.EncodingPanel.text=檔案編碼
action.presentation.ExtractIncludeAction.text=Include 檔案…
action.presentation.FindAllAction.text=搜尋全部
action.presentation.LightEditTabs.text=關閉。按 Alt 並點擊以關閉其他。
action.presentation.OpenSelectedProjectsAction.text.open.all.projects.in.group=開啟組中的所有專案
action.presentation.OpenSelectedProjectsAction.text.open.selected=開啟選定專案
action.presentation.RegistryUi.text=還原為預設值
action.presentation.RegistryUi.text.edit=編輯
action.presentation.RemoveSelectedProjectsFromGroupsAction.text=從組中移除
action.presentation.ShowUiDebuggerAction.text=UI 偵錯器
action.presentation.WeighingActionGroup.text=其他
action.previous.message=上一條訊息
action.previous.problem=上一個問題
action.previous.tip=返回(&B)
action.previous.todo=上一個 TODO
action.refresh=重新整理
action.remove=移除
action.remove.from.current.favorites=從當前收藏夾移除
action.remove.repository.from.list=從列表中移除儲存庫
action.remove.template=移除模板
action.reset.font.size=重設為 {0}pt
action.reset.font.size.all.editors=在所有編輯器中重設為 {0}pt
action.reset.font.size.info=字體大小: {0}pt
action.reset.to.default=還原為原始模板
action.restore.windows=還原視窗(_W)
action.select.none=無選擇(&N)
action.send.to.new.favorites.list=發送至新收藏夾列表
action.separator=分隔符({0})
action.separator.file.templates=檔案模板
action.show.classes=顯示類別
action.show.compact.empty.middle.packages=顯示/壓縮中間軟體套件
action.show.files=顯示檔案
action.show.hide.empty.middle.packages=顯示/隱藏空的中間軟體套件
action.show.included.only=僅顯示包含的檔案
action.show.infos=顯示資訊訊息
action.show.members=顯示成員
action.show.modules=顯示模組
action.show.warnings=顯示警告
action.start.macro.recording=開始巨集錄製(_M)
action.stop=停止
action.stop.macro.recording=停止錄製巨集 (_M)
action.switch.project.text=切換專案
action.sync.completed.successfully=檔案同步已成功完成。
action.text.change.encoding=將編碼更改為 ''{0}''
action.text.change.system.shortcuts=更改系統快捷鍵
action.text.clear.all=全部清除
action.text.copy=複製(&C)
action.text.copy.link.address=複製鏈接地址
action.text.disable.input.methods=停用輸入方法
action.text.editor.mode.none=無
action.text.hide.chessboard=隱藏棋盤
action.text.hide.file.name=隱藏檔名
action.text.hide.file.size=隱藏檔案大小
action.text.hide.grid=隱藏網格
action.text.hide.tags.panel=隱藏標記面板
action.text.install.keymap=安裝 {0} 按鍵映射
action.text.merge.tabs.to.group=將頁籤合併到 ''{0}'' 組
action.text.modify.shortcut=修改快捷鍵
action.text.modify.shortcuts=修改快捷鍵
action.text.more=更多
action.text.open.link.in.browser=在瀏覽器中開啟鏈接
action.text.reload.file=重新載入檔案
action.text.remove.0=移除 {0}
action.text.remove.abbreviation.0=移除縮寫 ''{0}''
action.text.remove.all.shortcuts=移除所有快捷鍵
action.text.search.for.keymap=搜尋 {0} 按鍵映射延伸模組
action.text.select.next.tab=選擇下一個頁籤
action.text.select.previous.tab=選擇上一個頁籤
action.text.settings=設定
action.text.show.chessboard=顯示棋盤
action.text.show.file.name=顯示檔名
action.text.show.file.size=顯示檔案大小
action.text.show.grid=顯示網格
action.text.show.tags.panel=顯示標記面板
action.text.split.group=拆分 ''{0}'' 組
action.title.group.by.directory=按目錄分組
action.todo.edit.filters=編輯篩選器
action.todo.edit.filters.description=編輯篩選器
action.todo.show.all=全部顯示
action.toggle.global.menu.integration.text=切換全域選單整合
action.unpin.tab=取消固定頁籤(_I)
action.unpin.tab.tooltip=取消固定頁籤
action.view.class.hierarchy=類別層次結構
action.view.subtypes.hierarchy=子類型層次結構
action.view.supertypes.hierarchy=父類型層次結構
actions.on.save.label.activated.on.any.save=任何儲存
actions.on.save.label.activated.on.any.save.and.external.change=<html>任何儲存和<br/>外部更改</html>
actions.on.save.label.activated.on.explicit.save=顯式儲存
actions.on.save.label.activated.on.explicit.save.with.0.shortcut=顯式儲存({0})
actions.on.save.link.all.actions.on.save=儲存時的所有動作…
actions.on.save.link.configure=組態…
actions.on.save.link.configure.autosave.options=組態自動儲存選項…
actions.on.save.option.activated.on.any.save.and.external.change=任何儲存和外部更改
actions.on.save.option.activated.on.any.save.including.autosave=任何儲存(包括自動儲存)
actions.on.save.page.title=儲存時的動作
actions.on.save.table.column.name.action=動作
actions.on.save.table.column.name.activated.on=啟用條件
activation.auth.message=命令行啟動器已過時。請重新整理(通過“工具 | 建立命令行啟動器”)。
activation.file.is.waiting.dismiss=消除
activation.file.is.waiting.do.not.show=不再顯示
activation.file.is.waiting.notification=指令行將一直等待，直到檔案 ''{0}'' 關閉。
activation.file.is.waiting.release=釋放
activation.file.is.waiting.title=指令行將一直等待，直到此檔案關閉
activation.not.initialized=IDE 尚未初始化
activation.project.is.waiting.notification=指令行將一直等待，直到專案 ''{0}'' 關閉。
activation.shutting.down=IDE 正在關閉
add.BOM=新增 BOM
add.byte.order.mark.to=向 {0} 新增位元組順序標記
add.local.scope.action.text=本地
add.module.popup.title=新增模組
add.scope.dialog.title=新增新作用域
add.scope.name.label=名稱
add.scope.popup.title=新增作用域
add.shared.scope.action.text=共享
add.source.header.popup.title=新增源和標題
alphabetical.mode.is.on.notification=已關閉按字母順序排列的制表符順序
analyze.plugin.title=每個延伸模組的啟動時間成本
appearance.ui.option.group=UI
appearance.view.option.group=檢視
appearance.window.option.group=視窗
application.cannot.start.in.a.headless.mode=應用程式不能以無頭模式啟動{0, choice, 0#|1#，對於指令: {1}|2#，對於啟動器: {2}} {3, choice, 0#|1# (命令行: {4})}
assign.custom.shortcuts.or.change.the.macos.system.settings=分配自定義快捷鍵或更改 macOS 系統設定。
attachable.project.pane.name=檔案
available.packages.dialog.title=可用軟體套件
background.image.button=背景圖像…
big.popup.filter.button.all=所有
big.popup.filter.button.invert=反轉
big.popup.filter.button.none=無
binary.file.too.large=二進制檔案 {0} 太大({1})
border.title.command.output=指令輸出
border.title.description=描述
border.title.problem.files=問題檔案
browse.custom.icon.hint=要設定自訂圖標，請指定 SVG 或 PNG 檔案的路徑。
browser.default.not.supported=抱歉，IDE 不知道如何在此系統上啟動預設瀏覽器。
browser.error=瀏覽器錯誤
browser.notification.timeout.group=在瀏覽器中開啟頁面超時
browser.notification.timeout.text=無法在瀏覽器中開啟 <a href="{0}">{1}</a>，因為 URL 未響應。
browser.notification.timeout.title=URL 未響應
browser.preview.file.title={0} 的預覽
browser.select.in.default.name=Web 瀏覽器
browser.shortcut=按住 Shift 以開啟本地檔案 URL
browser.shortcut.or.shift={0}，按住 Shift 以開啟本地檔案 URL
browser.url.popup=選擇 URL
browsers.chrome=Chrome
browsers.explorer=Internet Explorer
browsers.firefox=Firefox
browsers.safari=Safari
browsers.settings=Web 瀏覽器和預覽
buildToolWindow.tree.accessibleName=建置結果
bundled.jre.m1.arch.message=為 Apple Silicon 下載 {0} 以獲得更好的性能和穩定性。
bundled.jre.m1.arch.message.download=下載…
bundled.jre.version.message=請考慮切換到更適合 IDE 的捆綁 Java Runtime(您當前的 Java Runtime 為 {0}，來自 {1}，位置為 ''{2}'')。
button.add.action=新增動作(&A)…
button.add.separator=新增分隔符 (&S)
button.back=後退
button.cancel=取消(&C)
button.cancel.without.mnemonic=取消
button.choose=選擇
button.clear.and.close=清除並關閉
button.continue.editing=繼續編輯
button.convert=轉換
button.convert.anyway=仍然轉換
button.copy=複製(&C)
button.copy.and.close=複製並關閉
button.create=建立(&C)
button.delete=刪除
button.disable=停用
button.disable.selected.plugins=停用所選延伸模組
button.do.not.send=不發送
button.done=完成
button.edit.action.icon=編輯圖標(&I)…
button.enable.all=全部啟用
button.enable.updated.plugins=啟用更新的{0,Choice,1#Plugin|2#Plugins}
button.exclude=排除
button.exclude.recursively=遞迴排除
button.existing.frame=此視窗(&T)
button.facet.quickfix.text=修正(&F)
button.finish=完成(&F)
button.fix=修正…
button.fix.it=修復
button.help=幫助(&H)
button.http.proxy.settings=HTTP 代理設定(&H)…
button.i.want.to.edit.all.files.in.choice.this.directory={0, choice, 1#此目錄|2#這些目錄}中的所有檔案
button.i.want.to.edit.any.non.project.file.in.current.session=任何非專案檔案
button.i.want.to.edit.choice.this.directory.anyway={0, choice, 1#此目錄|2#這些目錄}
button.i.want.to.edit.choice.this.file.anyway={0, choice, 1#此文件|2#這些檔案}
button.include=包含
button.include.recursively=遞迴包含
button.invalidate.and.exit=清除並退出(&E)
button.invalidate.and.restart=清除並重啟(&R)
button.later=稍後{0,choice,0#重啟|1#關閉}
button.move.down=下移 (&D)
button.move.up=上移(&U)
button.new.frame=新視窗 (&W)
button.next=下一個
button.now=立即{0,choice,0#重啟|1#關閉}
button.ok=確定 (&O)
button.previous=上一個
button.recover.vfs.from.logs.and.exit=恢復快取並退出(&E)
button.recover.vfs.from.logs.and.restart=恢復快取並重啟(&R)
button.reject=拒絕
button.reload=重新載入
button.reload.anyway=仍然重新載入
button.remove=移除(&R)
button.remove.from.list=從列表中移除(\\\\&R)
button.rename=重新命名
button.repaint.icons=重新繪製圖標(&R)
button.restore.all=還原所有預設設定(&L)
button.restore.defaults=還原為預設值
button.restore.last.state=還原上次狀態
button.restore.selected.groups=還原選定組
button.restore.selection=還原{0}
button.save=儲存
button.save.anyway=仍然儲存
button.set.0=設定 {0}
button.skip=跳過
button.wizard.next=下一步 (&N)
button.wizard.previous=上一步 (&P)
button.yes=是(_Y)
cannot.delete.jre.config=無法刪除 JRE 組態檔案 ''{0}'': {1}
cannot.redo.message=無法重做
cannot.redo.title=無法重做
cannot.undo.error.contains.nonundoable.changes.message=以下檔案具有無法撤消的更改:
cannot.undo.error.other.affected.files.changed.message=受此動作影響的以下檔案已更改:
cannot.undo.error.other.users.overwrote.changes.message=您對以下檔案的更改已被其他使用者覆蓋:
cannot.undo.message=無法撤消
cannot.undo.title=無法撤消
change.encoding.command.name=更改 ''{0}'' 的編碼
change.memory.code.cache=程式碼快取大小
change.memory.direct.buffers=直接緩衝區限制
change.memory.max.heap=最大堆大小
change.memory.metaspace=元空間大小
change.memory.min.heap=初始堆大小
channel.status.beta=Beta 版本或公開預覽
channel.status.eap=搶先體驗計劃
channel.status.milestone=里程碑 EAP 建置
channel.status.stable=穩定版本
checkbox.acessibility.contrast.scrollbars=使用對比度捲軸
checkbox.also.in.reader.mode=也適用於<a>閱讀器模式</a>
checkbox.case.sensitive=區分大小寫
checkbox.colors.only=僅顏色
checkbox.compact.mode=緊湊模式
checkbox.compact.mode.description=UI 元素佔用更少的螢幕空間
checkbox.compact.tree.indents=在樹中使用較小的縮排
checkbox.confirm.application.exit=退出 IDE 之前確認
checkbox.copy.javadoc=複製 JavaDoc(&J)
checkbox.create.the.entry.for.all.users.requires.superuser.privileges=為所有用戶建立條目(需具備超級使用者權限)(&A)
checkbox.customfiletype.ignore.case=忽略情況 (&I)
checkbox.customfiletype.support.paired.braces=支援配對大括號 (&R)
checkbox.customfiletype.support.paired.brackets=支援配對中括號 (&C)
checkbox.customfiletype.support.paired.parens=支援配對小括號 (&P)
checkbox.customfiletype.support.string.escapes=支援字串轉義 (&E)
checkbox.disabled.included=包括停用的動作(&D)
checkbox.enable.live.templates=啟用實時模板 (&L)
checkbox.enable.new.ui=啟用新 UI
checkbox.errortree.export.details=詳細資訊
checkbox.full.paths.in.window.header=始終在視窗標題中顯示完整路徑
checkbox.inject.reveal.library.on.launch=啟動時注入 Reveal 庫
checkbox.insert.at.override=插入 @Override(&O)
checkbox.left.toolwindow.layout=左側並排布局
checkbox.main.menu.separate.toolbar=在單獨的工具列中顯示主選單
checkbox.merge.main.menu.with.window.not.supported.comment=This option is not supported for the current Window Manager
checkbox.merge.main.menu.with.window.title=合併主選單和視窗標題
checkbox.narrow.down.on.typing=在輸入時縮小(&N)
checkbox.narrow.down.the.list.on.typing=在輸入時縮小列表(&N)
checkbox.override.default.laf.fonts=使用自訂字體:
checkbox.password.safe.remember=記住(&R)
checkbox.reformat.according.to.style=按照樣式重新格式化(&R)
checkbox.remember.size.for.each.tool.window=記住每個工具視窗的大小
checkbox.remote.sdk.run.as.root.via.sudo=通過 sudo 作為 root 執行
checkbox.right.toolwindow.layout=右側並排布局
checkbox.safe.delete.with.usage.search=安全刪除(帶有用法搜尋)(&F)
checkbox.safe.write=儲存前備份檔案
checkbox.save.files.automatically=如果 IDE 空閒則儲存檔案
checkbox.save.files.on.frame.deactivation=切換到其他應用程式或內建終端時儲存檔案
checkbox.show.editor.preview.popup=懸停在捲軸上時顯示程式碼透鏡
checkbox.show.icons.in.menu.items=在選單項顯示圖標
checkbox.show.rendered.doc.comments=渲染文檔註釋
checkbox.show.tips.on.startup=啟動時不顯示小技巧
checkbox.show.tool.window.bars=顯示工具視窗列
checkbox.show.tool.window.numbers=顯示工具視窗編號
checkbox.show.tree.indent.guides=顯示樹縮排參考線
checkbox.smooth.scrolling=平滑滾動
checkbox.smooth.scrolling.animated=動畫平滑滾動(&N)
checkbox.smooth.scrolling.description=使用滑鼠滾輪/觸摸板時，整個介面將平滑滾動，而不是逐行滾動
checkbox.smooth.scrolling.enable.high.precision.timer=啟用 Windows 高精度計時器
checkbox.smooth.scrolling.enable.high.precision.timer.comments=為刷新率較高的顯示器啟用更平滑的動畫。
checkbox.smooth.scrolling.enable.high.precision.timer.help=通常，預設的 Windows 計時器周期為 15.625 毫秒。因此，預設動畫每秒播放近 60 幀。此選項會在播放動畫時動態地將周期設定為較低的值。
checkbox.support.screen.readers=支援螢幕閱讀器
checkbox.synchronize.files.on.frame.activation=切換到 IDE 視窗或開啟編輯器頁籤時同步外部更改
checkbox.text.this.project.only=僅此專案
checkbox.todo.use.default.colors=使用配色方案 TODO 預設顏色
checkbox.transparent.native.to.ascii.conversion=自動轉換成 Ascii 但顯示原生的內容
checkbox.upload.reveal.library.on.the.device.if.necessary=如有必要，上傳裝置上的 Reveal 庫
checkbox.use.custom.user.data.directory.for.chrome=使用自訂用戶數據目錄(&U):
checkbox.use.solution.colors.in.main.toolbar=在主工具列中使用專案顏色
checkbox.use.solution.colours.in.toolbar=Show Project Gradient
checkbox.use.transparent.mode.for.floating.windows=為浮動視窗使用透明模式
checkbox.widescreen.tool.window.layout=寬屏工具視窗布局
checkbox.widescreen.tool.window.layout.description=通過限制水平工具視窗的寬度，使垂直工具視窗的高度最大化
chooser.description.jar.and.zip.archives.are.accepted=接受 JAR 和 ZIP 歸檔
chooser.description.specifies.user.data.directory=指定儲存使用者資料(您的“組態檔案”)的目錄
chooser.title.plugin.file=選擇延伸模組檔案
chooser.title.select.profiles.ini.file=選擇 "profiles.ini" 檔案
chooser.title.select.user.data.directory=選擇使用者資料目錄
clear.all.notifications=清除所有通知
code.cache.warn.message={0} MB 的程式碼快取大小不足。請將 ''-XX:ReservedCodeCacheSize'' 增加到 {1} MB 或以上，以避免性能問題。
collect.logs.notification.error=無法使用日誌建立 .zip 檔案: {0}
collect.logs.notification.sent.success=日誌已發送至 {0}。您的 ID 為: {1}
collect.logs.notification.success=已建立日誌檔案: {0}
collect.logs.progress.title=正在收集日誌
collect.logs.sensitive.text=包含的日誌和設定中可能含有敏感資料。
collect.logs.sensitive.title=敏感資料
collect.upload.logs.progress.title=正在收集和上傳日誌
color.name.blue=藍色
color.name.brown=棕色
color.name.gray=灰色
color.name.green=綠色
color.name.orange=橙色
color.name.rose=玫瑰色
color.name.violet=紫色
color.name.yellow=黃色
colorfulInstances.gotIt.text=您可以在右鍵選單或設定中停用此功能
colorfulInstances.gotIt.title=通過工具列顏色區分解決方案
colorpanel.label.alpha=A
colorpanel.label.alpha.percent=A%
colorpanel.label.blue=B
colorpanel.label.brightness=B%
colorpanel.label.green=G
colorpanel.label.hue=H°
colorpanel.label.red=R
colorpanel.label.saturation=S%
colorpicker.brightness.slider.title=亮度
colorpicker.brightness.slider.tooltip=亮度
colorpicker.colorvaluepanel.hexlabel=十六進制
colorpicker.format.hsb=HSB
colorpicker.format.rgb=RGB
colorpicker.label.blue=B:
colorpicker.label.brightness=B:
colorpicker.label.green=G:
colorpicker.label.hue=H:
colorpicker.label.red=R:
colorpicker.label.saturation=S:
colorpicker.opacity.slider.title=不透明度
colorpicker.opacity.slider.tooltip=不透明度
colorpicker.recent.color.tooltip=R: {0} G: {1} B: {2} A: {3}
column.enabled=已啟用
column.name.cost.details=成本詳細資訊
column.name.plugin=延伸模組
column.name.startup.time.ms=啟動時間(毫秒)
column.plugins.name=名稱
column.todo.filter.patterns=模式
column.todo.filters.name=名稱
column.todo.patterns.case.sensitive=區分大小寫
column.todo.patterns.icon=圖標
column.todo.patterns.pattern=模式
combobox.ide.scale.comment.format=通過 {0} 或 {1} 進行更改。通過 {2} 設定為 100%
combobox.ide.scale.percent=縮放:
combobox.look.and.feel=主題:
command.close.all.editors=關閉所有編輯器
command.close.all.unmodified.editors=關閉所有未修改的編輯器
command.create.directory=建立目錄
command.create.file=建立檔案
command.create.file.from.template=從模板建立檔案
command.create.new.package=建立新軟體套件
command.create.package=建立軟體套件
command.deleting.files=正在刪除檔案
command.finish=完成
command.fixing.line.separators=修正行分隔符
command.go.to.line=轉到行
command.name.apply.color=套用顏色
command.name.choice.attach.detach={0, choice, 0#附加|1#分離} {1}
command.name.choice.exclude.include={0, choice, 0#排除|1#包含}{1}
command.pasting.reference=貼上參照
command.renaming.module=正在重新命名模組 {0}
command.select.all=全選
command.unselect.all=取消全選
comment.text.pause=暫停
comment.text.paused=已暫停
comment.text.resume=恢復
configurable.AppEngineCloudConfigurable.display.name=Google App Engine 帳號
configurable.AppEngineFacetEditor.display.name=Google App Engine
configurable.ChromeSettingsConfigurable.display.name=Chrome 設定
configurable.CodeStyle.display.name=程式碼樣式
configurable.Console.display.name=主控台
configurable.DatabaseSettingsConfigurable.CsvFormats.display.name=CSV 格式
configurable.DatabaseSettingsConfigurable.DataViews.display.name=資料編輯器和檢視器
configurable.DatabaseSettingsConfigurable.Other.display.name=其他
configurable.DatabaseSettingsConfigurable.OutputResults.display.name=輸出和結果
configurable.DatabaseSettingsConfigurable.QueryExecution.display.name=查詢執行
configurable.DatabaseSettingsConfigurable.Templating.display.name=使用者參數
configurable.DockerExtraHostConfigurable.display.name=額外主機
configurable.DuplicatesConfigurable.display.name=重複項
configurable.EmbeddedSettingsConfigurable.display.name=嵌入式開發
configurable.ExceptionAnalyzerConfigurable.display.name=異常分析器
configurable.ExternalDependenciesConfigurable.display.name=必需延伸模組
configurable.GutterIconsConfigurable.display.name=裝訂區域圖標
configurable.JavaFxSettingsConfigurable.display.name=JavaFX
configurable.PluginHostsConfigurable.display.name=自訂延伸模組儲存庫
configurable.Postfix.Completion.display.name=後綴補全
configurable.Runtime.Targets.Configurable.display.name=執行目標
configurable.SettingsPage.display.name=捆綁的 Web 幫助
configurable.TerminalOptionsConfigurable.display.name=終端
configurable.TextMateConfigurableProvider.display.name=TextMate 捆綁包
configurable.TimeTrackingConfigurable.display.name=時間追蹤
configurable.VagrantConfigurable.display.name=Vagrant
configurable.console.font.name=主控台字體
configurable.console.font.use.editor.font=使用編輯器字體
configurable.file.colors=檔案顏色
configurable.font.name=字體
configurable.new.ui.name=新 UI
configurable.notifications.name=通知
configurable.quick.lists.name=快速列表
configurable.trusted.hosts.display.name=受信任的位置
consent.configurable=資料共享
conversion.dialog.text.1=專案 ''{0}'' 的格式已過時，將被轉換。您可能無法使用早期版本的 {1} 開啟此專案。
conversion.dialog.text.2=<b> </b><a href="details">詳細資訊…</a><br/><br/>舊版本的專案檔案將被儲存到: ''{0}''
convert.project.dialog.button.text=轉換
copy.reference=複製參照(&Y)
copy.references=複製參照(&Y)
copy.relative.path=複製相對路徑(&Y)
copy.relative.paths=複製相對路徑(&Y)
copy.system.information.to.clipboard=將系統資訊複製到剪貼簿
create.new.UT8.file.option.always=包含 BOM
create.new.UT8.file.option.never=不含 BOM
create.new.UT8.file.option.only.under.windows=在 Windows 下使用 BOM，否則不使用 BOM
custom.action.actual=實際: {0}
custom.action.stored=已存儲: {0}
custom.option.testmode=讀取自訂動作 {0}
date.format.24.hours=使用 24 小時時間
date.format.date.format=日期格式:
date.format.date.patterns=日期模式
date.format.error.contains.time.pattern=日期格式不應包含時間模式(小時、分鐘、秒)
date.format.error.invalid.pattern=無效模式: {0}
date.format.override.system.date.and.time.format=覆寫系統日期和時間格式
date.format.pretty=使用美化的格式
date.format.relative=將數字日期取代為<i>今天</i>、<i>昨天</i>和 <i>10 分鐘前</i>
date.time.format.configurable=日期格式
default=預設
default.icons.add.text=新增
default.icons.edit.text=編輯
default.icons.export.text=匯出
default.icons.filter.text=篩選
default.icons.find.text=尋找
default.icons.gear.plain.text=純齒輪
default.icons.import.text=匯入
default.icons.list.files.text=列出檔案
default.icons.none.text=<無>
default.icons.remove.text=移除
default.icons.unknown.text=預設圖標
description.copy.text.to.clipboard=將文本複製到剪貼簿
detach.directory.action.text.detach.0=從專案中分離{0,choice,1#目錄|2#目錄}…
detach.directory.dialog.button.detach=分離
detach.directory.dialog.message.detach.0=分離 {0}?\\n\\
不會從磁碟上移除檔案。
detach.directory.dialog.title.detach=從專案中分離目錄
detach.library=分離庫
detach.library.from.module=從模組 ''{1}'' 分離庫 ''{0}''?\\n\\
不會損害磁碟上的檔案。
dialog.action.restart.cancel=取消
dialog.action.restart.yes=重啟
dialog.button.ok.jcef.signIn=登入
dialog.choose.recovery.point=選擇恢復點:
dialog.content.jcef.proxyServer=<html>瀏覽器組件正在為代理<br>請求身份驗證: {0}
dialog.content.label.jcef.login=登入名: 
dialog.content.label.jcef.password=密碼: 
dialog.layout.already.exists=已存在使用此名稱的布局
dialog.layout.name.too.long=允許的最大長度為 {0} 個字元
dialog.message.attach.project.not.found=在 {0} 中找不到專案
dialog.message.caches.will.be.invalidated=移除所有專案的快取和索引。重新開啟專案時將建置新快取。
dialog.message.can.not.open.file=無法開啟檔案 {0}
dialog.message.cannot.perform.operation.too.complex.sorry=無法執行動作。抱歉，太複雜了。
dialog.message.cannot.save.the.file.0=無法儲存檔案 {0}
dialog.message.command.could.not.complete={0} 不能成功補全。請檢視指令的輸出，了解如何解決這個問題。
dialog.message.command.not.finished.yet={0} 尚未完成。
dialog.message.communication.error=通信錯誤
dialog.message.component.could.not.be.reloaded=無法重新載入該組件。重新載入專案?
dialog.message.conversions.will.be.performed=<html>將執行以下轉換:<br>{0}</html>
dialog.message.could.not.erase.files.or.folders.0.1=無法擦除檔案或目錄:\\n\\
{0}{1}
dialog.message.disable.dependent.plugin=<html>將停用相依的 ''{0}'' 延伸模組</html>
dialog.message.disable.dependent.plugins=<html>以下相依延伸模組將被停用: <br>{0}</html>
dialog.message.enable.required.plugin=<html>將啟用所需的 ''{0}'' 延伸模組</html>
dialog.message.enable.required.plugins=<html>將啟用所需的以下延伸模組: <br>{0}</html>
dialog.message.enable.vagrant.support.plugin=啟用 Vagrant 支援延伸模組
dialog.message.enter.new.value.for.0=輸入 {0} 的新值
dialog.message.enter.new.value.for.0.in.form.brightness.contrast.alpha=在“亮度、對比度、Alpha”表單中\\n\\
輸入 {0} 的新值
dialog.message.enter.new.value.for.0.in.form.top.left.bottom.right=在“上、下、左、右”表單中\\n\\
輸入 {0} 的新值
dialog.message.enter.new.value.for.0.in.form.width.height=以“寬度,高度”形式\\n\\
輸入 {0} 的新值
dialog.message.error.setting.value=設定值時出錯: {0}
dialog.message.execution.finished=執行已完成
dialog.message.execution.finished.because=執行被終止，原因是: {0}
dialog.message.fail.to.load.plugin.descriptor.from.file=無法從檔案 {0} 載入延伸模組檔案描述子
dialog.message.file.already.exists=檔案已存在
dialog.message.file.with.name.already.exists=名稱為 ''{0}'' 的檔案已存在
dialog.message.folder.with.name.already.exists=名稱為 ''{0}'' 的目錄已存在
dialog.message.following.plugin.depend.on=以下{0,choice,1#延伸模組|2#延伸模組}{0,choice,1#相依|2#相依}於{1}。要繼續移除嗎?<br>{2}
dialog.message.host.name.empty=主機名為空
dialog.message.incompatible.encoding=您選擇的編碼(''{0}'')可能會更改 ''{1}'' 的內容。<br>是否要<br>1. 以新的編碼 ''{0}'' 從磁碟<b>重新載入</b>檔案，並覆蓋編輯器內容或<br>2. <b>轉換</b>文本並以新編碼覆蓋檔案?
dialog.message.internal.error=內部錯誤
dialog.message.invalid.host.value=主機值無效
dialog.message.invalid.path=無效路徑 ''{0}''
dialog.message.login.empty=登入名為空
dialog.message.must.be.restarted.for.changes.to.take.effect=重啟 {0} 以使更改生效
dialog.message.no.message=沒有訊息
dialog.message.no.project.found.to.open.file.in=找不到可以在以下位置開啟檔案的專案:
dialog.message.only.one.instance.can.be.run.at.time=一次只能執行一個 {0} 實例。
dialog.message.open.cancelled=開啟已被取消
dialog.message.password.empty=密碼為空
dialog.message.please.enter.credentials.for=請輸入憑證: {0}
dialog.message.plugin.core.part=延伸模組 ''{0}'' 是 {1} 的核心部分。要將其更新為較新的版本，您應當更新 IDE。
dialog.message.plugin.depends.on.unknown.plugin=延伸模組 {0} 依賴於未知{1,choice,1#延伸模組|2#延伸模組} {2}
dialog.message.plugin.is.not.allowed=您的組織不允許安裝延伸模組 ''{0}''
dialog.message.plugin.was.already.installed=延伸模組 ''{0}'' 已安裝
dialog.message.press.for.field.hints=按 {0} 獲取欄位提示
dialog.message.problem.with.connection=連線出現問題: {0}
dialog.message.project.group.name=專案組名
dialog.message.recover.vfs.from.operations.log=從動作日誌中恢復快取。從下面選擇所需的恢復點。需要重新啟動才能套用更改。
dialog.message.remove.0.from.recent.projects.list=從最近的專案列表中移除 ''{0}''?
dialog.message.restart.ide=是否要重啟 IDE?
dialog.message.restarted.to.apply.changes=是否重新啟動 {0} 以套用更改?
dialog.message.specified.path.cannot.be.found=找不到指定的路徑
dialog.message.the.following.items=可選:
dialog.message.there.already.same.interpreter=已經有相同的解釋器:\\n\\
{0}
dialog.message.trying.to.create.folder.with.ignored.name=正在嘗試建立具有忽略名稱的目錄；結果將不可見
dialog.message.unable.to.apply.changes=<body style="padding: 5px;">無法套用更改: 將無法載入{0,choice,1#延伸模組|2#延伸模組} {1}。</body>
dialog.message.unable.to.create.idea.directory=無法建立 ''.idea'' 目錄(%s): {0}
dialog.message.unknown.error=未知錯誤
dialog.message.wait.must.be.supplied.with.file.or.project.to.wait.for='--wait' 必須提供要等待的檔案或專案
dialog.new.window.layout.prompt=輸入新布局名稱
dialog.new.window.layout.title=新增布局
dialog.rename.window.layout.prompt=布局名稱:
dialog.rename.window.layout.title=重新命名布局
dialog.text.error.getting.value=獲取值時出錯: {0}
dialog.title.abbreviation=縮寫
dialog.title.activity.monitor=活動監視器
dialog.title.add.actions.to.quick.list=將動作新增到快速列表
dialog.title.add.new.value=新增新值
dialog.title.attach.project.error=無法附加專案
dialog.title.auto.detected.proxy=自動檢測的代理
dialog.title.background.image=背景圖像
dialog.title.can.t.create.0.sdk=無法建立 {0} SDK
dialog.title.cannot.execute.command=無法執行指令
dialog.title.cannot.open.file=無法開啟檔案
dialog.title.change.group.name=更改組名
dialog.title.change.project.icon=Set Custom Project Icon
dialog.title.check.proxy.settings=檢查代理設定
dialog.title.choose.color=選擇顏色
dialog.title.choose.encoding.for.the.0=選擇 ''{0}'' 的編碼
dialog.title.choose.plugins.to.install.or.enable=選擇要安裝或啟用的延伸模組
dialog.title.clear.read.only.file.status=清除唯讀狀態
dialog.title.collect.troubleshooting.information=收集故障排除資訊
dialog.title.color.picker=取色器
dialog.title.configuration.changed=組態已更改
dialog.title.convert.module=轉換模組
dialog.title.convert.project=轉換專案
dialog.title.create.new.project.group=建立新項目組
dialog.title.custom.debug.log.configuration=自訂偵錯日誌組態
dialog.title.customize.0=自訂 {0}
dialog.title.data.sharing=資料共享
dialog.title.delete.0=刪除 {0}
dialog.title.dependent.plugins.found=找到相依的延伸模組
dialog.title.dimension.editor=尺寸編輯器
dialog.title.disable.dependent.plugins=停用相依延伸模組
dialog.title.edit.laf.defaults=編輯 LaF 預設值
dialog.title.enable.required.plugins=啟用必需延伸模組
dialog.title.error.saving.project=儲存專案時出錯!
dialog.title.error.writing.file=寫入檔案時錯誤
dialog.title.experimental.features=實驗性功能
dialog.title.export.to.file=匯出到檔案
dialog.title.failed.to.perform.operation=執行動作失敗
dialog.title.file.0.can.t.be.reloaded=無法以 ''{1}'' 編碼重新載入檔案 ''{0}''。{2}
dialog.title.file.0.most.likely.isn.t.stored=檔案 ''{0}'' 可能未以 ''{1}'' 編碼存儲。{2}
dialog.title.font.size.editor=字號編輯器
dialog.title.go.to.line.column=轉到行:列
dialog.title.gray.filter.editor=灰色篩選器編輯器
dialog.title.http.proxy.exceptions=代理異常
dialog.title.import=匯入
dialog.title.insets.editor=插入編輯器
dialog.title.install.plugin=安裝延伸模組
dialog.title.installing.plugin=正在安裝延伸模組 {0}
dialog.title.invalid.input=輸入無效
dialog.title.invalidate.caches=清除快取
dialog.title.jcef.proxyAuthentication=代理身份驗證
dialog.title.migrating.plugins=正在遷移延伸模組
dialog.title.new.tag.name=新增標記名稱
dialog.title.non.project.files.protection=非專案檔案保護
dialog.title.number.editor=數字編輯器
dialog.title.plugin.updates=延伸模組更新
dialog.title.proxy.authentication=代理身份驗證: {0}
dialog.title.proxy.setup=代理設定
dialog.title.recover.vfs.from.logs=從動作日誌恢復快取
dialog.title.remove.recent.project=移除最近的專案
dialog.title.reopen.project=重新開啟專案
dialog.title.required.plugin=必需延伸模組
dialog.title.restart.ide=重啟?
dialog.title.restart.required=需要重啟
dialog.title.save.as=另存為
dialog.title.save.project.to.directory.based.format=將專案儲存為基於目錄的格式
dialog.title.select.0=選擇 {0}
dialog.title.third.party.software={0} {1} 使用的第三方軟體
dialog.title.unable.to.save=無法儲存
dialog.title.untrusted.server.s.certificate=不可信伺服器的憑證
dialog.title.updating.plugin=正在更新延伸模組 {0}
dialog.title.vagrant.support.disabled=已停用 Vagrant 支援
diff.dialog.title=''{0}'' 與 ''{1}'' 之間的差異
directory.message.cant.create.folder=無法建立名為 ''{0}'' 的目錄
directory.project.location.description=為專案選擇基目錄
directory.project.location.label=位置(&L):
directory.project.location.title=選擇基目錄
display.balloon.notifications=顯示氣球通知
display.name.firefox.settings=Firefox 設定
dnd.with.alt.pressed.only=僅按下 Alt 時拖放
do.not.ask.me.again=不再詢問
double.ctrl.or.shift.shortcut=雙擊 {0}
dumb.balloon.0.is.not.available.while.indexing=編制索引期間 {0} 不可用
dumb.balloon.none.of.the.following.actions.are.available.during.indexing.0=編制索引期間以下動作均不可用: {0}
dumb.balloon.this.action.is.not.available.during.indexing=編制索引期間此動作不可用
dumb.mode.results.might.be.incomplete=編制索引時，結果可能不完整
dumb.mode.spoiler.wrapper.reload.text=重新載入結果
dumb.service.indexing.paused.due.to=由於{0}，索引編制暫停
dump.focusable.component.hierarchy.close.button=關閉並複製到剪貼簿
editbox.customfiletype.block.comment.end=塊註釋結束:
editbox.customfiletype.block.comment.start=塊註釋開始:
editbox.customfiletype.description=描述:
editbox.customfiletype.hex.prefix=十六進制前綴:
editbox.customfiletype.line.comment=行註釋:
editbox.customfiletype.name=名稱:
editbox.customfiletype.number.postfixes=數字後綴:
editbox.default.encoding.for.properties.files=屬性檔案的預設編碼:
editbox.export.to.file=匯出到檔案:
editbox.plugin.description=描述
editor.banner.close.tooltip=關閉
editor.tabs.always.keep.sorting=始終保持啟用排序
editor.tabs.enable.sorting=啟用排序
empty.project.generator.description=不帶模組的專案。用它來建立自由樣式的模組結構。將開啟“專案結構”對話框，幫助您建置專案結構。
empty.project.generator.name=多模組專案
empty.text.drop.files.to.open=將檔案拖放到此處以開啟
empty.text.go.to.file=轉到檔案
empty.text.navigation.bar=導覽列
empty.text.no.entries=無條目
empty.text.no.features.available=無可用功能
empty.text.no.project.open.yet=  尚無專案開放
empty.text.nothing.found=找不到任何內容
empty.text.nothing.selected=未選擇任何內容
empty.text.project.view=專案檢視
empty.text.recent.files=最近的檔案
empty.text.search.everywhere=隨處搜尋
empty.text.this.view.is.not.available.until.indices.are.built=在建置索引前，此檢視不可用
encoding.do.not.convert.message=請勿轉換到 ''{0}''。
encoding.name.properties.default=<屬性預設值: {0}>
encoding.name.system.default=<系統預設: {0}>
encoding.not.available=不適用
encoding.unsupported.characters.message=編碼 ''{0}'' 不支持文本中的某些字元。
encodings.dialog.caption=<html>要更改 {0} 為檔案、目錄或整個專案使用的編碼，請根據需要新增其路徑，然後從編碼列表中選擇編碼。內建檔案編碼(例如JSP、HTML 或 XML)會覆寫您在此處指定的編碼。如果未指定，檔案和目錄將從父目錄或“專案編碼”繼承編碼設定。</html>
error.0.browser.path.not.specified={0}瀏覽器路徑未指定。
error.cannot.convert.project=無法轉換專案: {0}
error.cannot.create.temp.dir=無法建立臨時目錄 ''{0}''
error.cannot.load.project=無法載入專案: {0}
error.cannot.set.look.and.feel=<html><body>無法設定{0}主題:<br>{1}</body></html>
error.connection.failed=連線失敗
error.descriptor.load.failed=無法從{0}載入延伸模組檔案描述子。所選檔案可能不是 IntelliJ 延伸模組。
error.dir.contains.no.project=''{0}'' 不包含專案
error.directory.with.name.already.exists=名稱為 ''{0}'' 的目錄已存在
error.download.plugin.via.blockmap=無法通過塊映射下載延伸模組。正在從 {0} 下載整個歸檔
error.downloaded.descriptor.load.failed=無法從下載的歸檔載入延伸模組檔案描述子。歸檔可能不是 IntelliJ 延伸模組。
error.empty.name=名稱不得為空
error.failed.to.create.directory=無法建立目錄“{0}”
error.favorites.list.already.exists=收藏夾列表 ''{0}'' 已存在
error.file.does.not.exist=檔案 {0} 不存在。
error.file.not.found.message=檔案 ''{0}'' 不存在
error.file.with.name.already.exists=名稱為 ''{0}'' 的檔案已存在
error.files.of.this.type.cannot.be.opened=無法在{0}中開啟此類型的檔案
error.filter.name.should.be.specified=應指定篩選器名稱
error.filter.should.contain.at.least.one.pattern=篩選器應至少包含一個模式
error.filter.with.the.same.name.already.exists=具有相同名稱的篩選器已存在
error.group.already.exists=組 ''{0}'' 已存在。
error.incompatible.update=下載的版本與當前 IDE 不相容: {0}
error.invalid.directory=無效目錄: ''{0}''
error.invalid.directory.name=''{0}'' 不是有效的目錄名稱
error.invalid.file.name=''{0}'' 是無效的檔名
error.invalid.java.package.name=無效的軟體套件名稱；無法在內部建立 Java 類別
error.invalid.java.package.name.format=無效的軟體套件名稱格式設定；無法在內部建立 Java 類別
error.invalid.template.file.name.or.extension=無效的模板檔名或副檔名
error.loading.package.list=載入軟體套件列表時出錯: {0}
error.malformed.url=URL 格式錯誤: {0}
error.message.cannot.make.files.writable=無法解鎖以下檔案:\\n\\
{0}
error.message.cannot.modify.file.0=無法修改檔案 ''{0}''
error.message.exception.was.thrown=拋出了異常
error.message.unable.to.create.file=無法建立檔案 ''{0}''
error.module.already.exists=名為 ''{0}'' 的模組已存在
error.name.already.exists=名稱已被使用。請更改為唯一名稱。
error.name.cannot.be.empty=名稱不能為空
error.name.should.be.specified=必須指定名稱
error.no.plugins.found=未找到延伸模組。檢查日誌檔案中有無錯誤。
error.occurred.please.check.your.internet.connection=出錯了。請檢查您的互聯網連線。
error.older.update=下載的版本({0})比當前安裝的版本({1})舊。
error.package.with.name.already.exists=名稱為 ''{0}'' 的軟體套件已存在
error.parsing.file.template=解析檔案模板時出錯: {0}
error.pattern.should.be.specified=應指定模式
error.pending.update=延伸模組“{0}”的另一個更新正在等待安裝。請重啟，然後重試。
error.please.enter.a.file.name=指定檔名
error.please.specify.path.to.web.browser=在“{0} | Web 瀏覽器”中指定 Web 瀏覽器路徑
error.please.specify.template.name=指定模板名稱
error.plugin.required.for.project.disabled=''{1}'' 專案所需延伸模組 ''{0}'' 已停用。
error.plugin.required.for.project.not.installed=''{1}'' 專案所需延伸模組 ''{0}'' 未安裝。
error.plugin.was.not.installed=延伸模組“{0}”未安裝: {1}
error.project.file.does.not.exist=無法載入 {0}。該檔案不存在。
error.project.requires.newer.ide=專案 ''{0}'' 需要 IDE 的 {1}''{2}'' 或更新的建置，但當前建置為 ''{3}''。
error.project.requires.newer.plugin=專案 ''{0}'' 需要延伸模組 ''{1}'' 版本 ''{2}'' 或更高版本，但已安裝的是 ''{3}''。
error.project.requires.older.ide=專案 ''{0}'' 需要 IDE 的 {1}''{2}'' 或更老的建置，但當前建置為 ''{3}''。
error.project.requires.older.plugin=專案 ''{0}'' 需要延伸模組 ''{1}'' 版本 ''{2}'' 或更低版本，但已安裝的是 ''{3}''。
error.same.pattern.already.exists=一些模式已存在
error.saving.statistics=儲存系統資訊時出錯: {0}
error.text.file.already.exists=檔案 {0} 已存在。\\n\\
希望覆蓋還是追加?
error.tips.not.found=找不到每日小技巧。確保已正確安裝 {0}。
error.tree.view.cell.error=錯誤: {0}
error.tree.view.fix.description=修復: {0}
error.tree.view.fixing=正在修正…
error.unable.to.parse.template.message=無法解析模板“{0}”，\\n\\
錯誤訊息: {1}
error.unable.to.read.tip.of.the.day=<html><body>無法讀取每日小技巧({0})。確認已正確安裝 {1}。</body></html>
error.updating.package.list=更新軟體套件列表時出錯: {0}
error.user.home.directory.not.found=未找到使用者主目錄
error.writing.to.file=寫入檔案時出錯: {0}
errortree.error=錯誤:
errortree.information=資訊:
errortree.noMessages=沒有訊息
errortree.note=注意:
errortree.prefix.line=行({0})
errortree.warning=警告:
essential-highlighting.mode.disable.action.title=停用基本醒目提示顯示模式
essential-highlighting.mode.on.notification.content=基本醒目提示模式只保留一組有限的程式碼醒目提示工具。包括檢查在內的所有醒目提示工具都將在執行檔案儲存動作時執行。
essential-highlighting.mode.on.notification.title=基本醒目提示模式已開啟
external.link.confirmation.message.0=確定要在瀏覽器或關聯的應用程式中開啟此鏈接嗎?<br><br>{0}
external.link.confirmation.title=開啟鏈接
external.link.confirmation.trust.label=信任專案並開啟
external.link.confirmation.yes.label=開啟
failed.to.install.package.dialog.title=無法安裝 ''{0}''
failed.to.install.packages.dialog.title=無法安裝軟體套件
failed.to.take.thread.dump=無法獲取執行緒傾印。
failed.to.unload.modified.plugins=無法移除修改的延伸模組: {0}
favorites.list.unnamed=未命名的{0}
file.changed.externally.message=檔案在磁碟上已被更改。
file.changed.externally.reload=重新載入
file.chooser.completion.ad.text=使用 {0} 保留路徑尾部
file.chooser.completion.no.suggestions=無建議
file.chooser.completion.path.variables.text=路徑變數
file.chooser.hide.path=隱藏路徑
file.chooser.show.path=顯示路徑
file.encoding.option.create.utf8.files=建立 UTF-8 檔案:
file.encoding.option.encoding.column=編碼
file.encoding.option.global.encoding=全域編碼
file.encoding.option.path.column=路徑
file.encoding.option.project.encoding=專案編碼
file.encoding.option.warning.always={0} 會將 <a href="https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8">UTF-8 BOM</a> 新增到使用 UTF-8 編碼建立的每個檔案中
file.encoding.option.warning.never={0} 不會將 <a href="https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8">UTF-8 BOM</a> 新增到每個以 UTF-8 編碼建立的檔案中
file.encoding.option.warning.windows.only={0} 只會在每個建立的 UTF-8 檔案在 Windows 下執行時向其新增 <a href="https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8">UTF-8 BOM</a>
file.encodings.configurable=檔案編碼
file.encodings.not.configured=未組態編碼
file.nesting.dialog.title=檔案嵌套
file.nesting.feature.enabled.checkbox=以嵌套形式顯示具有相同名稱的檔案(&S)
file.nesting.reset.to.default.button=重設為預設(&R)
file.nesting.table.title=嵌套規則:
file.read.error=無法讀取檔案 {0}。
file.read.error.details=無法讀取檔案 {0}: {1}
file.write.error=檔案{0}無法寫入。
file.write.error.details=無法寫入檔案 {0}: {1}
filetype.gui.designer.form.description=GUI 設計器表單
filetype.gui.designer.form.display.name=GUI 設計器表單
filetype.scalable.vector.graphics.description=可縮放矢量圖形
filetype.scalable.vector.graphics.display.name=可縮放矢量圖形
filetype.search.everywhere.directory.description=檔案系統目錄
filetype.web.preview.description=用於嵌入式瀏覽器中的檔案預覽
filetype.web.preview.display.name=Web 預覽
find.ide.update.title=尋找 IDE 更新
fixed.problem.prefix=已修復:
focus.debugger.label.newvalue=新值=
focus.debugger.label.oldvalue=舊值=
font.info.renderer.non.latin=非拉丁語
font.reset.link=重設為預設
gdpr.checkbox.when.using.eap.versions=使用 EAP 版本時{0}
gdpr.continue.button=繼續
gdpr.exit.button=退出
gdpr.hint.text.apply.to.all.installed.products=資料共享偏好設定適用於所有已安裝的 {0} 產品。
gdpr.hint.text.you.can.always.change.this.behavior=您隨時可以在“{0} | 外觀與行為 | 系統設定 | 資料共享”中更改此行為。
gdpr.label.there.are.no.data.sharing.options.available=沒有可用的資料共享選項
gdpr.usage.statistics.disabled.externally.warning=Toolbox Enterprise 延伸模組已暫時停用發送使用統計資訊。
general.module.type.description=一個允許使用單獨的檔案並編譯 Java 和 Kotlin 類別的基本專案。
github.project.generator.version=版本(&V):
github.project.generator.versions.not.loaded.error=尚未載入版本。
go.to.class.action.description=按名稱快速導覽到{0}
go.to.class.dumb.mode.message=在建置索引前，轉到 {0} 動作不可用，改用轉到檔案
go.to.class.kind.text=類別
go.to.class.kind.text.pluralized=類別
go.to.class.title.prefix=轉到{0}
got.it.button.name=知道了
goto.custom.region.command=轉到自訂折疊
goto.custom.region.menu.item=自訂折疊…
goto.custom.region.message.dumb.mode=在建置索引前，自訂折疊導覽不可用。
goto.custom.region.message.unavailable=當前檔案中沒有自訂的折疊
goto.inspection.action.choose.inherit.settings.from=檢查選項
goto.inspection.action.dialog.title=執行 ''{0}''
goto.inspection.action.fix.all=全部修正
goto.inspection.action.text=通過名稱執行檢查(&R)…
group.antialiasing.mode=抗鋸齒
group.customfiletype.syntax.highlighting=語法醒目提示
group.customizations.add.action.group=新增動作…
group.customizations.restore.action.group=還原動作…
group.presentation.mode=示範模式
group.settings.process.tab.close=關閉具有執行程序的工具視窗時:
group.todo.filter.patterns=模式
group.transparency=透明度
group.ui.options=UI 選項
group.vendor=供應商
group.view.options=檢視選項
group.window.options=工具視窗
handle.ro.file.status.failed=<html>無法更改以下檔案的唯讀狀態:<br>{0}</html>
handle.ro.file.status.type.using.file.system=使用檔案系統
hashes.doesnt.match=還原的歸檔的雜湊與原始歸檔的雜湊不符合
hierarchy.call.next.occurence.name=轉到下一個呼叫
hierarchy.call.prev.occurence.name=轉到上一個呼叫
hierarchy.legend.method.defined.in.superclass=方法未在類別中定義，但在其超類別中定義
hierarchy.legend.method.is.defined.in.class=方法已在類別中定義
hierarchy.legend.method.should.be.defined=必須定義方法，因為類別不為 abstract
hierarchy.method.next.occurence.name=轉到下一個方法
hierarchy.method.prev.occurence.name=轉到上一個方法
hierarchy.type.next.occurence.name=轉到下一個類型
hierarchy.type.prev.occurence.name=轉到上一個類型
highlighting.pass.injected.presentable.name=注入的片段
hint.scheme.editing=按 Enter 儲存，按 Esc 取消
hint.text.all.lines.already.have.requested.indentation=所有行都已請求縮排
hint.text.changed.indentation.in=已更改{0,choice,1#行|2#行}中的縮排
http.editor.name=HTTP
http.multirange.response.doesnt.contain.boundary=HTTP 多範圍響應邊界線 {0} 不包含邊界 {1}
http.multirange.response.doesnt.include.line.separator=HTTP 多範圍響應不包含行分隔符
http.multirange.response.includes.incorrect.header=HTTP 多範圍響應包含不正確的頭 - {0}，應為 {1}
http.proxy.configurable=HTTP 代理
http.velocity={0}<hr> <font face="verdana" size="-1"><a href=''http://velocity.apache.org/engine/devel/user-guide.html#Velocity_Template_Language_VTL:_An_Introduction''>\\n\\
Apache Velocity</a> 模板語言已使用</font>
icon.debugger.db_array.tooltip=陣列
icon.debugger.db_obsolete.tooltip=過時的框架
icon.debugger.db_primitive.tooltip=基元類型的值
icon.debugger.db_watch.tooltip=監視
icon.debugger.frame.tooltip=框架
icon.debugger.selfreference.tooltip='this' 的參照
icon.debugger.threadAtBreakpoint.tooltip=中斷點處的執行緒
icon.debugger.threadCurrent.tooltip=當前執行緒
icon.debugger.threadFrozen.tooltip=凍結執行緒
icon.debugger.threadGroup.tooltip=執行緒組
icon.debugger.threadGroupCurrent.tooltip=當前線程組
icon.debugger.threadRunning.tooltip=正在執行的執行緒
icon.debugger.threadSuspended.tooltip=暫停的執行緒
icon.debugger.value.tooltip=值
icon.debugger.watchLastReturnValue.tooltip=最後一個方法呼叫的返回值
icon.fileTypes.archive.tooltip=歸檔檔案
icon.fileTypes.custom.tooltip=自訂類型的檔案
icon.fileTypes.diagram.tooltip=圖表檔案
icon.fileTypes.java.tooltip=Java 檔案
icon.fileTypes.javaClass.tooltip=Java 編譯的位元組碼檔案
icon.fileTypes.javaOutsideSource.tooltip=來源根之外的 Java 檔案
icon.fileTypes.json.tooltip=JSON 檔案
icon.fileTypes.jsonSchema.tooltip=JSON 架構檔案
icon.fileTypes.manifest.tooltip=清單檔案
icon.fileTypes.properties.tooltip=屬性檔案
icon.fileTypes.unknown.tooltip=未知類型的檔案
icon.fileTypes.xml.tooltip=XML 檔案
icon.fileTypes.yaml.tooltip=YAML 檔案
icon.modules.excludeRoot.tooltip=排除的目錄
icon.modules.excludedGeneratedRoot.tooltip=排除的生成來源根
icon.modules.generatedFolder.tooltip=生成的目錄
icon.modules.generatedSourceRoot.tooltip=生成的來源根
icon.modules.generatedTestRoot.tooltip=生成的測試來源根
icon.modules.output.tooltip=輸出根
icon.modules.resourcesRoot.tooltip=資源根
icon.modules.sourceRoot.tooltip=來源根
icon.modules.testResourcesRoot.tooltip=測試資源根
icon.modules.testRoot.tooltip=測試來源根
icon.modules.unloadedModule.tooltip=已移除的模組
icon.nodes.Module.tooltip=模組
icon.nodes.abstractClass.tooltip=抽象類別
icon.nodes.abstractException.tooltip=abstract 異常
icon.nodes.abstractMethod.tooltip=abstract 方法
icon.nodes.annotationtype.tooltip=註解類型
icon.nodes.anonymousClass.tooltip=匿名類別
icon.nodes.c_plocal.tooltip=package-local
icon.nodes.c_private.tooltip=private
icon.nodes.c_protected.tooltip=protected
icon.nodes.c_public.tooltip=public
icon.nodes.class.tooltip=類別
icon.nodes.classInitializer.tooltip=類別初始設定式
icon.nodes.enum.tooltip=枚舉
icon.nodes.exceptionClass.tooltip=異常類別
icon.nodes.excludedFromCompile.tooltip=已從編譯中排除
icon.nodes.field.tooltip=欄位
icon.nodes.finalMark.tooltip=final
icon.nodes.folder.tooltip=目錄
icon.nodes.ideaModule.tooltip=IntelliJ 模組檔案
icon.nodes.interface.tooltip=接口
icon.nodes.junitTestMark.tooltip=單元測試
icon.nodes.locked.tooltip=唯讀
icon.nodes.method.tooltip=方法
icon.nodes.moduleGroup.tooltip=模組組
icon.nodes.nodePlaceholder.tooltip=
icon.nodes.package.tooltip=軟體套件
icon.nodes.parameter.tooltip=參數
icon.nodes.ppJdk.tooltip=JDK
icon.nodes.ppLib.tooltip=外部庫
icon.nodes.runnableMark.tooltip=可執行
icon.nodes.staticMark.tooltip=static
icon.runConfigurations.testError.tooltip=意外異常
icon.runConfigurations.testFailed.tooltip=斷言失敗
icon.runConfigurations.testIgnored.tooltip=測試已忽略
icon.runConfigurations.testNotRan.tooltip=測試未開始
icon.runConfigurations.testPassed.tooltip=測試通過
icon.runConfigurations.testSkipped.tooltip=測試已跳過
icon.runConfigurations.testTerminated.tooltip=測試已終止
icon.validation.message.format=圖標格式不正確
icon.validation.message.not.found=該圖標不存在
ide.notnow.action=以後再說
ide.postpone.action=推遲
ide.protocol.cannot.title=無法開啟 URI
ide.protocol.exception=內部錯誤: {0}: {1}
ide.protocol.internal.bad.query=不正確的查詢字串: ''{0}''
ide.protocol.progress.title=正在開啟 URI
ide.protocol.unsupported=不支持的協議: ''{0}''
ide.restart.action=重啟
ide.restart.required.comment=需要重新啟動
ide.restart.required.message={0}{1}以套用延伸模組中的更改?
ide.restart.required.notification={0, choice, 0#關閉|1#重啟}以啟用延伸模組更新
ide.scale.reset.link=重設為預設
ide.shutdown.action=關閉
idea.intellij.look.and.feel=IntelliJ Light 舊版
implicit.log.directory.path=似乎您正在使用 ''idea.system.path'' 屬性指定快取目錄的位置。在 2020.1 中，應用程式目錄的預設位置已更改。為確保兼容性，IDE 選擇了日誌的舊位置({0})，但為了避免將來出現任何歧義(並去除此警告)，另請設定 ''idea.log.path'' 屬性。
implicit.plugin.directory.path=似乎您正在使用 ''idea.config.path'' 屬性指定設定目錄的位置。在 2020.1 中，應用程式目錄的預設位置已更改。為確保兼容性，IDE 選擇了延伸模組的舊位置({0})，但為了避免將來出現任何歧義(並去除此警告)，另請設定 ''idea.plugins.path'' 屬性。
incompatible.encoding.dialog.title=不相容的編碼: {0}
information.hint.accessible.context.name=提示
inline.actions.more.actions.text=更多動作
inspection.message.inspection.info=檢查資訊
install.package.failure=安裝軟體套件 ''{0}'' 時發生錯誤。<a href="xxx">詳細資訊…</a>
intention.family.editor.notification=編輯器通知
intention.family.editor.notification.option=編輯器通知選項
intention.family.editor.notification.settings=編輯器通知設定
internal.decorator.accessible.postfix=工具視窗
interpreter.default.name=遠端 {0} 解釋器
invalid.node.text=無效
invalidate.all.caches.recovery.action.name=清除快取並重啟
invalidate.workspace.model.recovery.action.presentable.name=重新開啟專案
javascript.debugger.settings.choose.file.subtitle=選擇要偵錯其中的 JavaScript 的網頁
javascript.debugger.settings.choose.file.title=選擇
jb.protocol.navigate.missing.parameters=URL 中既沒有指定 'project' 參數，也沒有指定 'origin' 參數
jb.protocol.navigate.no.project=找不到或無法開啟指定的專案
jb.protocol.navigate.target=''navigate'' 指令僅支援 ''reference'' 目標(找到 ''{0}'')
jb.protocol.parameter.missing=缺少參數: ''{0}''
jb.protocol.settings.no.configurable=找不到設定頁面: ''{0}''
jb.protocol.unknown.command=未知指令: ''{0}''
jb.protocol.unknown.target=未知目標: ''{0}''
jcef.local.cache.invalidate.action.description=刪除嵌入式瀏覽器引擎快取和 Cookie。此動作可能會影響使用嵌入式瀏覽器呈現基於 HTML 的內容和網頁的組件。
jcef.local.cache.invalidate.checkbox.description=刪除嵌入式瀏覽器引擎快取和 Cookie
jcef.local.cache.invalidate.failed.message=清除快取動作請求了嵌入式瀏覽器引擎快取清理。由於 I/O 錯誤，動作失敗: {0}
jcef.local.cache.invalidate.failed.title=無法清理瀏覽器引擎快取
jetbrains.certificate.invalid=JetBrains 憑證無效。請聯繫 JetBrains 支援人員。
jetbrains.certificate.not.found=找不到 JetBrains 憑證。
jetbrains.certificate.vendor=供應商: {0}
keymap.action.configure.keymap=組態按鍵映射…
keymap.action.install.keymap=安裝按鍵映射…
label.appearance.caret.blinking=外觀: 文字游標閃爍
label.appearance.show.inner.whitespaces=外觀: 顯示內部空格
label.appearance.show.leading.whitespaces=外觀: 顯示前導空格
label.appearance.show.right.margin=外觀: 顯示右邊距
label.appearance.show.trailing.whitespaces=外觀: 顯示尾隨空格
label.appearance.show.vertical.indent.guides=外觀: 顯示垂直縮排參考線
label.autosave.comment=無法完全停用自動儲存。<a>工作原理</a>
label.category.n.a=不適用
label.category.unknown=未知
label.certificate.expired=已過期
label.certificate.not.yet.valid=尚未生效
label.certificate.root=<根>
label.certificate.will.be.saved=接受的憑證將被儲存在信任庫 {0} 中，預設密碼為 {1}
label.change.list.for.unlocked.files=\\   更改列表(&L):
label.choose.color.scheme.importer=選擇 {0}
label.choose.target.file=選擇目標檔案
label.choosebyname.no.matches.found=未找到符合
label.choosebyname.searching=正在搜尋…
label.chrome.command.line.options=命令行選項(&C):
label.continue.editing=繼續編輯
label.description=描述:
label.dont.show=不再顯示
label.downloading.cancelled=下載已取消
label.downloading.file.started=下載已開始
label.empty.file.name=<空檔名>
label.empty.text.attach.directories.with.right.click=通過右鍵點擊附加目錄
label.enable.debug.level=啟用日誌類別的 DEBUG 級別(每行一個)。<br>向類別追加 ''{0}'' 後綴以啟用 TRACE 級別，或者追加 ''{1}'' 後綴以啟用所有級別。<br><br>
label.enter.group.name=輸入組名:
label.enter.new.abbreviation=輸入新縮寫:
label.enter.new.font.size.for.0=輸入 {0} 的新字號
label.extension=擴展(&E):
label.file.name=檔名:
label.font.name=字體:
label.font.size=大小:
label.generate.file.name=檔名(&F):
label.i.want.to.edit.choice=IDE 重啟前允許編輯:
label.icon.path=圖標(&I):
label.inactive.timeout.sec= 秒
label.install.a.limited.functionality.for.free=使用免費版本或
label.invalid.color=<無效>
label.line.column=[行] [:列]:
label.macro.recording.started=巨集錄製已開始…
label.maximum.version=最高版本:
label.milliseconds=毫秒
label.minimum.version=最低版本:
label.more.files=和其他{0, choice, 1#1 個檔案|2#{0} 個檔案}
label.name=名稱(&N):
label.new.version.will.be.available.after.restart=新版本將在重啟後可用
label.next.plugin.version.is=通過此更新，延伸模組將變為
label.no.actions.found=未找到動作
label.no.enabled.actions.found=未找到已啟用的動作
label.no.files.found=未找到檔案
label.no.matches.found=未找到符合
label.offset=偏移:
label.option.appearance=外觀: {0}
label.password.safe.password=密碼(&P)
label.password.safe.user=使用者(&U)
label.plugin=延伸模組:
label.plugin.0.downloads={0} 次下載
label.plugin.change.notes=更改說明
label.plugin.downloads=下載
label.plugin.freemium=免費增值
label.plugin.last.updated=上次更新
label.plugin.paid=付費
label.plugin.status=狀態
label.plugin.updated.0=已更新 {0}
label.plugin.vendor.email=電子郵件:
label.plugin.vendor.name=名稱:
label.project.files.location=專案位置(&L):
label.project.icon.for.darcula.theme=深色主題:
label.project.icon.for.default.theme=淺色主題:
label.project.name=專案名稱(&A):
label.remote.sdk.helpers.path=幫助程序路徑:
label.remote.sdk.name=名稱(&N):
label.remote.sdk.python.interpreter.path=Python 解釋器路徑:
label.scope=作用域(&S):
label.scope.contains.files=作用域包含 {0} 個檔案，共 {1} 個
label.scope.editor.caret.position=位置: {0}
label.scope.pattern=模式(&P):
label.select.configuration.element=選擇樹中的組態元素以編輯其設定
label.show.block.cursor=顯示塊游標
label.show.line.numbers=顯示行號
label.show.status.bar.widget=顯示 {0}
label.show.whitespaces=顯示空格
label.smooth.scrolling.bezier.panel.updates=每秒繪製請求數: {0}
label.smooth.scrolling.duration=持續時間
label.ssl.certificate.details=憑證詳細資訊
label.start.search.in.background=在背景開始搜尋
label.text.antialiasing.scope.editor=編輯器:
label.text.antialiasing.scope.ide=IDE:
label.text.character.count={0} 個字元
label.text.code.completion.saved=自 {1} 以來，程式碼補全至少為您節省了 {0}的輸入時間(每個工作日約 {2})
label.text.html.center.drop.here.to.attach.br.as.a.root.directory.center.html=<html><center>拖放至此處<br/>以作為根目錄附加</center></html>
label.text.image=圖片:
label.text.opacity=不透明度:
label.text.path.to.profiles.ini="profiles.ini" 的路徑:
label.text.plugin.eap.license.not.required=EAP 版本不需要授權
label.text.plugin.no.license=無授權。
label.text.profile=使用者組態(&P):
label.text.put.stacktrace.here=在此放置一個堆疊追蹤:
label.text.quick.fixes.saved=自 {1} 以來，快速修復使您避免了 {0} 個可能的錯誤(每個工作日約 {2} 個)
label.todo.filter.name=名稱:
label.todo.filters=篩選器:
label.todo.icon=圖標:
label.todo.multiline=將以下行中的縮排文本視為同一 TODO 的一部分
label.todo.pattern=模式:
label.todo.patterns=模式:
label.transparency.delay.ms=延遲(毫秒):
label.transparency.ratio=比例:
label.ui.filter=篩選:
label.ui.name=名稱:
label.ui.value=值:
label.use.the.trial.for.up.to.30.days.or=使用 30 天試用版或
label.valid.from=生效起始日期:
label.valid.until=有效期至
label.version=版本: {0}
label.version.0.1.build.2={0} {1} 構建版本 {2}
label.version.any=<any>
label.welcome.to.0=歡迎存取 {0}
label.you.can.create.a.desktop.entry=<html>您可以建立桌面條目，以便從系統選單輕鬆啟動 $APP_NAME$ <br>並更好地進行桌面整合。<html>
laf.action.install.theme=安裝主題…
large.file.editor.name=大檔案編輯器
large.file.preview.notification=檔案太大({0})。正在顯示第一個 {1} 的唯讀預覽。
link.cancel=取消
link.change.icon=更改…
link.change.project.icon=選擇 SVG 檔案…
link.change.project.icon.description=SVG 檔案將儲存到 .idea 目錄。<br/>要共享專案圖標，請將其新增到儲存庫。
link.check=檢查
link.enable.required.plugin=啟用 {0}
link.enable.required.plugins=啟用必需延伸模組
link.get.more.themes=獲取更多主題
link.hide.processes=隱藏程序({0})
link.install.required.plugins=安裝必需延伸模組
link.just.restart=重啟
link.label.wizard.step.plugin.customize=自訂…
link.more=更多…
link.reset.icon=重設
link.reset.project.icon=重設
link.show.all.processes=全部顯示({0})
link.smooth.scrolling.play.curve.animation=<a>播放此曲線的動畫</a>
link.smooth.scrolling.stop.curve.animation=<a>停止此曲線的動畫</a>
list.item.temporary.file.0=<temporary file>{0}
listbox.customfiletype.keywords=關鍵字
loading.in.progress=<html><body style='text-align: center;padding-top:20px;'>正在載入…</body></html>
log.in.link.text=登入…
login.dialog.authorization.token.field=IDE 授權令牌
login.dialog.back.link=← 返回
login.dialog.check.token=檢查令牌
login.dialog.eap.info.link=關於 EAP
login.dialog.empty.username=已登入
login.dialog.jb.login=登入 JetBrains Account
login.dialog.link.copied=鏈接已複製
login.dialog.log.out=退出登入…
login.dialog.manage.account=管理帳戶
login.dialog.manual.login=使用瀏覽器登入 JetBrains Account
login.dialog.new.user.label=新用戶?
login.dialog.register.link=建立帳戶
login.dialog.separator.text=或使用以下方式登入:
login.dialog.session.expired=授權會話已過期。請再次啟動
login.dialog.simple.login=登入 JetBrains Account
login.dialog.start.using=開始
login.dialog.title={0}
login.dialog.trouble.default.message=無法完成授權過程。
login.dialog.trouble.no.link={0}<br>有關可能的解決方案，請參閱<a href="{1}">幫助文章</a>。<br>如需幫助，請<a href="{2}">聯繫技術支援團隊</a>。
login.dialog.trouble.unknown=<a href="{0}">複製鏈接</a>並在瀏覽器中開啟，以獲取 IDE 授權令牌。
login.dialog.trouble.with.redirect=登入到您的帳戶並複製 IDE 授權令牌。<br/>如果瀏覽器未開啟，則 <a href="{0}">複製鏈接</a>並手動開啟。
login.dialog.troubles.link=有問題嗎?
login.dialog.waiting.for.login=正在等待在瀏覽器中登入…
login.dialog.waiting.for.login.short=正在等待登入…
login.dialog.welcome.to.eap=歡迎存取 {0} EAP
login.dialog.wrong.token=授權令牌錯誤
login.dialog.you.are.logged=您已登入
low.disk.space.message=系統目錄分區(''{0}'')上的剩餘空間少於 50 MiB
low.disk.space.title=磁碟空間不足
low.memory.notification.action=組態
low.memory.notification.analyze.action=分析記憶體使用情況
low.memory.notification.error=IDE 可用記憶體不足。請考慮增大“{0}”設定的值。
low.memory.notification.title=記憶體不足
low.memory.notification.warning=IDE 記憶體不足，這可能會影響性能。請考慮增加堆大小。
mac.window.tabs.close.other.tabs=關閉其他頁籤
mac.window.tabs.close.tab=關閉頁籤
mac.window.tabs.close.title=點擊以關閉此頁籤。按住 Option 鍵點擊以關閉除此之外的所有頁籤
mac.window.tabs.move.tab=將頁籤移至新視窗
mac.window.tabs.show.all.tabs=顯示所有頁籤
macos.shortcut.conflict.few={0} 快捷鍵與 macOS 系統快捷鍵衝突。
macos.shortcut.conflict.many={0} 和 {1} 快捷鍵與 macOS 系統快捷鍵衝突。
main.startup.error=啟動錯誤
main.toolbar.menu.button=主選單
manage.repositories.dialog.title=管理儲存庫
meetnewui.toolwindow.button.finishSetup=完成安裝
meetnewui.toolwindow.button.startTour=開始快速導覽
meetnewui.toolwindow.clean=簡潔
meetnewui.toolwindow.compact=緊湊
meetnewui.toolwindow.density=密度:
meetnewui.toolwindow.description=在“設定 > 外觀與行為 > <a>新 UI</a>”中組態或停用新 UI。
meetnewui.toolwindow.system=系統
meetnewui.toolwindow.theme=主題:
meetnewui.toolwindow.title=認識新 UI
memory.snapshot.captured.action.text=在 {1} 中開啟 ''{0}''
memory.snapshot.captured.text=在 {0} 的延伸模組移除失敗時捕獲記憶體快照
message.action.remove.system.assigned.shortcut=動作快捷鍵 {0} 已被分配給系統動作 ''{1}''。是否要移除此快捷鍵?
message.cannot.delete.0.1=無法刪除 ''{0}''，{1}
message.check.the.internet.connection.and=檢查互聯網連線並
message.connection.successful=連線成功
message.do.you.want.to.delete.0.1=是否要刪除“{0}”{1}?
message.link.refresh=重新整理
message.macro.exists=巨集 ''{0}'' 已存在。是否要覆蓋它?
message.module=模組 ''{0}''
message.module.file.has.an.older.format.do.you.want.to.convert.it=模組檔案為舊格式。是否要轉換?
message.modules=模組
message.move.modules.to.group=將 {0} 移至組 {1}
message.no.targets.available=在此上下文中沒有可用目標
message.occurrence.N.of.M=匹配項 {0}/{1}
message.path.to.fqn.has.been.copied=''{0}'' 已複製。
message.please.select.element.for.javadoc=選擇您想檢視其文檔的元素
message.project.will.be.saved.and.reopened.in.new.directory.based.format=專案將會儲存並以基於目錄的新格式重新開啟。確定要繼續嗎?
message.reference.to.fqn.has.been.copied=對 ''{0}'' 的參照已複製。
message.text.enter.url.to.check.connection=警告: 您的設定將被儲存。\\n\\
輸入任意 URL 以檢查連線:
message.text.files.do.not.exist=<html><body>以下檔案不存在:<br>{0}相應的模組將不會轉換。是否要繼續?</body></html>
message.text.proxy.both.use.proxy.and.autodetect.proxy.set=代理: 同時設定了 'use proxy' 和 'autodetect proxy' 設定。應當只選擇其中一個選項。請重新組態。
message.text.proxy.passwords.were.cleared=已清除代理密碼。
message.text.unlock.read.only.files=<html><body>以下檔案為唯讀檔案。{0}將解鎖它們。<br>{1}</body></html>
message.the.path.0.does.not.exist.maybe.on.remote=路徑 {0} 不存在。\\n\\
如果它位於可移動驅動器或網絡驅動器上，請確保該驅動器已連線。
message.there.are.no.available.schemes.to.import=沒有可供匯入的方案
message.this.action.isn.t.supported.on.the.current.platform=當前平台不支持此動作
message.this.functionality.is.not.available.during.indexing=編制索引期間此功能不可用
message.your.module.was.successfully.converted.br.old.version.was.saved.to.0=<html><body>您的模組已成功轉換。<br> 舊版本已儲存到 ''{0}''</body></html>
mixed.bag.installation=您的 {0} 安裝似乎已損壞，因為存在多個版本標記。當較新版本的歸檔被提取到包含現有安裝的目錄中時，通常就會發生這種情況。為避免出現崩潰，請從頭開始將 IDE 重新安裝到一個空目錄。
more.shortcuts.link.text.with.count=其他 {0}
name.invalid=無效
name.variable=在對話框中輸入的檔名
navigate.command.search.reference.progress.title=正在搜尋參照 ''{0}''
navigation.bar=導覽列
navigation.bar.item.sample=範例
new.dir.project.create=建立
new.dir.project.error.empty=專案路徑為空
new.dir.project.error.invalid=專案目錄路徑無效
new.plugin.manager.incompatible.deps.action=啟用所需{0, choice, 1#延伸模組|2#延伸模組}
new.plugin.manager.incompatible.deps.tooltip=未載入。所需{0, choice, 1#延伸模組|2#延伸模組} {1} {0, choice, 1#|2#}已停用。
new.ui.blog.post.link=網誌
new.ui.description=乾淨和現代的外觀，新 UI 通過最大限度減少螢幕上的混亂來幫助專注於工作.
new.ui.explore.new.ui=探索新 UI
new.ui.settings.group.name=設定
new.ui.submit.feedback=提交反饋…
new.ui.title=新 UI
new.ui.watch.new.ui.overview=檢視新 UI 概述
no.charset.set.reason.charset.auto.detected.by.bom=字符集被 BOM 自動檢出
no.charset.set.reason.charset.auto.detected.from.content=字符集從內容中自動檢出
no.charset.set.reason.charset.hard.coded.in.file=字符集在檔案中硬編碼
no.charset.set.reason.disabled.for.binary.file=對二進制檔案停用
no.charset.set.reason.disabled.for.directory=對目錄停用
no.charset.set.reason.disabled.for.file.type=為 {0} 停用
no.disk.space.message=系統目錄分區(''{0}'')上的剩餘空間少於 1 MiB
no.disk.space.title=磁碟空間不足
no.information.available=無可用資訊
no.tip.of.the.day=<html><body>此功能目前尚無每日小技巧。</body></html>
node.call.hierarchy.N.usages=  ({0} 個用法)
node.default.package=<預設軟體套件>
node.hierarchy.invalid=[無效]
node.memberchooser.all.classes=所有類別
node.project.view.bad.link=無效的符號鏈接
node.projectview.external.libraries=外部庫
node.projectview.libraries=庫
node.projectview.library={0} 庫
node.structureview.invalid=<無效>
node.todo.group={0} {0,choice,0#項|1#項|2#項}
node.todo.items={0} {0, choice, 0#項|1#項|2#項}
node.todo.more.items=…更多…
node.todo.summary=在 {1} 個{1,choice,0#檔案|1#檔案|2#檔案}中找到 {0} 個 TODO {0,choice,0#條目|1#條目|2#條目}
notification.accessible.announce.prefix=通知
notification.action.unknown.macros.error.fix=修復
notification.cache.diagnostic.helper.text=已執行恢復步驟 {0}: ''{1}''
notification.cache.diagnostic.helper.title=IDE 修復
notification.cache.diagnostic.stop.text=現在一切正常
notification.cache.recover.from.log.no.recovery.points=沒有可用的恢復點
notification.cache.recover.from.log.not.available=快取恢復不可用
notification.configurable.display.name.notifications=通知
notification.content.cannot.find.keymap=找不到鍵映射“{0}”
notification.content.cannot.find.parent.keymap=找不到“{1}”的父鍵映射“{0}”
notification.content.color.scheme=User color scheme ''{0}'' points to incorrect or non-existent base scheme {1} and will not be shown
notification.content.failed.to.save.settings=<p>無法儲存設定。{0}
notification.content.input.method.disabler=IDE 執行時啟用了可能導致凍結的輸入方法。如果您並不使用這些輸入方法，不妨停用它們。
notification.content.internal\\ error=內部錯誤
notification.content.jcef.applySettings=要將新設定應用於 JCEF 瀏覽器，需要重啟 IDE
notification.content.jcef.gpucrash.action.disable=停用 GPU 並重啟
notification.content.jcef.gpucrash.action.restart=重啟
notification.content.jcef.gpucrash.message=GPU 程序重啟次數過多，似乎不穩定。請嘗試重啟 IDE 或完全停用 GPU 加速。
notification.content.jcef.gpucrash.title=GPU 程序(JCEF)重啟次數過多
notification.content.jcef.measureFPS=按任意鍵或切換焦點即可停止
notification.content.jcef.missingLibs=缺少原生庫: {0}
notification.content.jit.compiler.disabled=JVM JIT 編譯器已被停用。重啟 IDE 以重新啟用 JIT。<br><br>如果再次看到此訊息，請嘗試使用 <code>-XX:ReservedCodeCacheSize</code> 選項增加 CodeCache 的大小。<br><br>有關 JVM 選項的更多資訊，請參閱<a href="help">此幫助主題</a>。
notification.content.keymap.successfully.activated=按鍵映射 {0} 成功啟用
notification.content.keymap.successfully.installed=鍵映射 {0} 成功安裝
notification.content.mandatory.bom.br={0,choice,1#此檔案具有|2#這些檔案具有}強制性 BOM:<br/>{1}
notification.content.more.shortcut.conflict={0} 和其他 {1} 個快捷鍵與 macOS 快捷鍵衝突。請修改這些快捷鍵或更改 macOS 系統設定。
notification.content.please.restart.0=請重啟 {0}</p>{1}
notification.content.plugin.failed.to.save.settings=延伸模組 <i>{0}</i> 無法儲存設定。{1}
notification.content.shortcut.conflicts.with.macos.shortcut.modify={0} 快捷鍵與 macOS 快捷鍵 {1} 衝突。請修改此快捷鍵或更改 macOS 系統設定。
notification.content.solarized.color.scheme.deprecation.enable=您正在使用即將刪除的 {0} 捆綁配色方案。請考慮改為啟用 {1} 主題
notification.content.solarized.color.scheme.deprecation.install=您正在使用即將刪除的 {0} 捆綁配色方案。請考慮切換到 {1} 延伸模組
notification.content.unable.to.save.project.files=無法儲存專案檔案。請確保專案檔案可寫入，並且您具備修改權限。<a href="">再次嘗試儲存專案</a>。
notification.content.unknown.macros.error.description=路徑變數用於取代專案檔案中的絕對路徑，並允許專案檔案在版本控制系統中共享。<br>當前專案設定的某些檔案包含未知的路徑變數，{0} 無法還原這些路徑。
notification.content.unknown.macros.error.many.macroses.undefined={0} 未定義。
notification.content.unknown.macros.error.one.macros.undefined={0} 未定義。
notification.content.updated.plugin.to.version=已將 {0} 延伸模組更新到版本 {1}
notification.content.updated.plugins=已更新 {0} 個延伸模組
notification.group.built.in.server=內建 HTTP 伺服器無法啟動
notification.group.cache.recovery=已執行快取恢復步驟
notification.group.essential-highlighting.mode=基本醒目提示模式已啟用
notification.group.failed.to.remove.bom=無法移除 BOM
notification.group.ide.and.plugin.updates=IDE 和延伸模組更新可用
notification.group.ide.errors=IDE 錯誤
notification.group.ide.update.results=IDE 更新已安裝
notification.group.language.plugin=推薦的語言延伸模組可用
notification.group.leftover.directories=找到了殘留的 IDE 目錄
notification.group.load.error=無法載入設定
notification.group.low.memory=檢測到記憶體不足
notification.group.missing.keymap=缺少快捷鍵
notification.group.password.safe=密碼存儲不可用
notification.group.plugin.error=延伸模組載入失敗
notification.group.plugin.updates=延伸模組已安裝或更新
notification.group.plugins.suggestion=有可用的延伸模組建議
notification.group.power.save.mode=已啟用省電模式
notification.group.project.settings=無法儲存專案
notification.group.required.plugins=未載入所需的延伸模組
notification.group.settings.error=無法儲存設定
notification.group.system.clipboard=系統剪貼簿不可用
notification.group.system.health=檢測到系統執行狀況問題
notification.group.system.messages=系統訊息
notification.group.too.many.carets=已達到編輯器文字游標的最大數量
notification.manager.content.height.linebreak=<br>\\n\\

notification.manager.content.height.word=內容
notification.manager.merge.n.more=其他 {0} 個
notification.manager.merge.n.more.from=來自 {1} 的其他 {0} 個
notification.settings.action.text=設定…
notification.title.activated.from.command.line=已從命令行啟用
notification.title.desktop.entry.created=已建立桌面條目
notification.title.desktop.entry.creation.failed=桌面條目建立失敗
notification.title.enable.action.solarized.color.scheme.deprecation=啟用 {0} 主題
notification.title.incompatible.color.scheme=不相容的配色方案
notification.title.input.method.disabler=輸入方法停用程序
notification.title.install.action.solarized.color.scheme.deprecation=安裝 Marketplace 中的 Solarized Themes 延伸模組
notification.title.jcef.measureFPS=OSR JCEF FPS Meter
notification.title.jcef.proxyChanged=代理設定已更改
notification.title.jcef.startFailure=JCEF 瀏覽器組件無法啟動
notification.title.jit.compiler.disabled=重啟 IDE 避免減速
notification.title.launcher.script.creation.failed=啟動器腳本建立失敗
notification.title.required.plugins.not.loaded=尚未載入必需延伸模組
notification.title.shortcuts.conflicts=快捷鍵衝突
notification.title.solarized.color.scheme.deprecation=配色方案棄用
notification.title.unable.to.save.plugin.settings=無法儲存延伸模組設定
notification.title.unable.to.save.settings=無法儲存設定
notification.title.unknown.macros.error=載入錯誤: 未定義的路徑變數
notification.title.was.unable.to.remove.bom.in=無法移除 {0} {0,choice,1#檔案|2#檔案}中的 BOM
notifications.collapse.balloon.title=其他 {0} 個{1}
notifications.collapse.balloon.title.suggestion={0,choice,1#建議|1<建議}
notifications.collapse.balloon.title.timeline={0,choice,1#通知|1<通知}
notifications.configurable.announcing.comment=如果先前的輸出具有較低的優先級，則通知將中斷該輸出
notifications.configurable.announcing.title=用螢幕閱讀器宣布:
notifications.configurable.announcing.value.high=具有高優先級
notifications.configurable.announcing.value.interrupting=正在中斷當前輸出
notifications.configurable.announcing.value.medium=具有中等優先級
notifications.configurable.announcing.value.not.interrupting=當前輸出完成後
notifications.configurable.announcing.value.off=關閉
notifications.configurable.column.group=組
notifications.configurable.column.log=日誌
notifications.configurable.column.popup=彈出視窗類型:
notifications.configurable.column.read.aloud=大聲朗讀
notifications.configurable.column.toolwindow=在工具視窗中顯示
notifications.configurable.display.balloon.notifications=顯示氣球通知
notifications.configurable.do.not.ask.project.title=此專案
notifications.configurable.do.not.ask.title=不再詢問通知:
notifications.configurable.enable.system.notifications=啟用系統通知
notifications.configurable.no.notifications.configured=未組態通知
notifications.configurable.play.sound=播放聲音
notifications.toolwindow.dont.show.again=不再顯示
notifications.toolwindow.dont.show.again.for.this.project=不再為此專案顯示
notifications.toolwindow.empty.text.first.line=建議、事件，
notifications.toolwindow.empty.text.second.line=以及錯誤將出現在這裡
notifications.toolwindow.remind.tomorrow=明天提醒我
notifications.toolwindow.suggestions=建議
notifications.toolwindow.timeline=時間線
notifications.toolwindow.timeline.clear.all=全部清除
old.dirs.action.progress=正在尋找殘留的 IDE 存儲目錄…
old.dirs.column.name=目錄
old.dirs.column.size=大小
old.dirs.column.updated=上次使用
old.dirs.delete.error=無法刪除目錄
old.dirs.delete.progress=正在刪除目錄…
old.dirs.dialog.delete.button=刪除 {0} 個{0,choice,0#目錄|1#目錄|2#目錄}
old.dirs.dialog.text=<html>安裝在您計算機上的其他 IDE 版本使用下面列出的目錄來存儲特定於版本的<br>設定、快取和延伸模組。刪除它們可以釋放空間，並且不影響<i>此版本</i>的穩定性。<br><b>警告</b>: 不要刪除仍在使用的版本的目錄!<br><br>選擇要刪除的目錄:</html>
old.dirs.dialog.title=刪除殘留的 IDE 存儲目錄
old.dirs.not.found.notification.text=沒有找到殘留的 IDE 存儲目錄。
old.dirs.notification.action=檢視並刪除…
old.dirs.notification.text=找到殘留的 IDE 存儲目錄。
only.at.line.start=僅在行首(\\\\&O)
onoff.button.off=關閉
onoff.button.on=開啟
open.in.0=在 {0} 中開啟
open.in.browser=在瀏覽器中開啟(_B)
open.selected.file.in.browser=在瀏覽器中開啟所選檔案
open.url.in.0=在 {0} 中開啟 URL
open.url.in.browser.tooltip=在瀏覽器中開啟
option.hide.tool.window.bars=隱藏工具視窗列
option.is.overridden.by.jvm.property=此選項已由 JVM 屬性覆寫:“{0}”
option.show.tips.on.startup=啟動時顯示每日小技巧
overridden.by.jvm.property=已被 JVM 屬性 ''{0}'' 覆寫
package.0.installed.successfully=已成功安裝軟體套件 ''{0}''
package.installed.successfully=已成功安裝軟體套件
package.successfully.uninstalled=已成功移除軟體套件 ''{0}''
package.successfully.upgraded=已成功升級軟體套件 {0}
packages.settings.latest.version=最新版本
packages.settings.loading=正在載入軟體套件列表
packages.settings.package=軟體套件
packages.settings.version=版本
packages.successfully.uninstalled=已成功移除軟體套件
packages.title=軟體套件
path.macro.ignored.variables=忽略的變數:
path.macro.use.semicolon=使用 ; 分隔忽略的變數
please.edit.repository.url=請編輯儲存庫 URL
please.input.repository.url=請輸入儲存庫 URL
plugin.description.vim.editor=Vim 編輯器仿真
plugin.descriptor.aws.toolkit=建立、測試和偵錯使用 AWS 無伺服器應用程式模型建置的無伺服器應用程式
plugin.group.cloud.support=雲支援
plugin.group.editor=編輯器
plugin.group.tools.integration=工具整合
plugin.info.not.available=不適用
plugin.info.unknown=未知
plugin.installed.ide.restart.required.message=延伸模組“{0}”已安裝。{1} {2} 以在延伸模組中套用更改?
plugin.invalid.signature.result=''{0}'' 延伸模組的數位簽章驗證失敗並顯示以下訊息: ''{1}''。
plugin.manager.action.label.sort.by=排序依據: {0}
plugin.manager.action.label.sort.by.1=排序依據
plugin.manager.custom.certificates=管理延伸模組憑證
plugin.manager.dependencies.detected.message=''{0}'' 延伸模組需要安裝 {1}。
plugin.manager.dependencies.detected.title=安裝必需延伸模組
plugin.manager.incompatible.tooltip=延伸模組與當前 {0} 安裝不相容
plugin.manager.installed.tooltip=延伸模組將在重啟後啟用
plugin.manager.main.suggest.to.enable.message.part1=更新的延伸模組 ''{0}'' 已停用。
plugin.manager.main.suggest.to.enable.message.part2=更新的延伸模組 {0} 已停用。
plugin.manager.main.suggest.to.enable.message.part3=更新的依賴於停用內容的{0,choice,1#延伸模組|2#延伸模組}
plugin.manager.main.suggest.to.enable.message.part4=延伸模組 ''{0}''。
plugin.manager.main.suggest.to.enable.message.part5=延伸模組 {0}。
plugin.manager.main.suggest.to.enable.message.part6=被停用的延伸模組和相依停用的延伸模組在重啟後不會被啟用。
plugin.manager.main.suggest.to.enable.message.part7=停用的延伸模組在重啟後不會被啟用。
plugin.manager.main.suggest.to.enable.message.part8=是否想要啟用更新的{0,choice, 1#延伸模組|2#延伸模組}
plugin.manager.main.suggest.to.enable.message.part9=是否想要啟用延伸模組{0,choice,1#相依項|2#相依項}
plugin.manager.new.version.tooltip=從版本 {0} 更新安裝的延伸模組
plugin.manager.obsolete.plugins.detected.title=停用衝突的延伸模組
plugin.manager.optional.dependencies.detected.message=建議安裝包含延伸模組 ''{0}'' 的 {1}。
plugin.manager.optional.dependencies.detected.title=安裝建議的延伸模組
plugin.manager.options.command=輸入 / 以檢視選項
plugin.manager.replace.plugin.0.by.plugin.1=<html>''{1}'' 延伸模組旨在替代安裝的 ''{0}'' 延伸模組。<br>停用“{0}”延伸模組以避免衝突?</html>
plugin.manager.repositories=管理延伸模組儲存庫…
plugin.manager.tab.installed=已安裝
plugin.manager.tab.marketplace=Marketplace
plugin.manager.tooltip=從磁碟管理儲存庫、組態代理或安裝延伸模組
plugin.manager.uninstalled.tooltip=延伸模組已被移除；重啟後將套用更改
plugin.manager.update.all=全部更新
plugin.manager.update.available.tooltip=有更新版本的延伸模組可用
plugin.manager.updated.tooltip=延伸模組已升級到最新版本；重啟後將套用更改
plugin.message.plugin.only.supported.in=此延伸模組僅在 {0} 中可用。
plugin.settings.link.title=延伸模組設定…
plugin.signature.checker.no=取消安裝
plugin.signature.checker.revoked.cert=<html><body>''{0}'' 延伸模組已撤消 JetBrains 憑證</body></html>
plugin.signature.checker.title=延伸模組安全警告
plugin.signature.checker.yes=忽略並繼續
plugin.signature.not.signed=<html><body>''{0}'' 延伸模組未進行數位簽章，無法驗證其可靠性。安裝或更新未簽名的延伸模組可能會將您的系統置於風險之中。<br/><br/>延伸模組詳細資訊: ID: {1}，版本: {2} {3}</body></html>
plugin.status.bundled=已捆綁
plugin.status.installed=已安裝
plugin.status.not.allowed=已阻止
plugin.status.not.allowed.but.enabled=停用!
plugin.status.not.allowed.tooltip=您的組織未批准此延伸模組
plugin.status.not.allowed.tooltip.but.enabled=請停用此延伸模組，因為它未經您的組織批准
plugin.status.not.specified=(未指定)
plugin.update.dialog.total.label=總計: {0}
plugin.updater.downloading=正在下載延伸模組
plugin.updater.error.cant.find.plugin.version=在儲存庫響應中找不到延伸模組版本
plugin.updater.error.check.failed=延伸模組更新檢查失敗
plugin.updater.error.custom.repository=檢查自訂延伸模組儲存庫 {0} 失敗
plugin.updater.error.unexpected.repository.response=意外延伸模組儲存庫響應
plugin.updater.install=安裝
plugin.updater.not.installed=未安裝延伸模組更新
plugin.updater.not.installed.misc=未安裝延伸模組更新: {0}
plugin.updater.not.installed.see.log.action=請參閱日誌了解更多資訊
plugin.updater.notification.message={1} 延伸模組有可用的新版本 {0}
plugin.version.bundled=已捆綁
plugins.advertiser.action.configure.plugins=組態延伸模組…
plugins.advertiser.action.enable.plugin=啟用延伸模組
plugins.advertiser.action.enable.plugins=啟用延伸模組…
plugins.advertiser.action.ignore.extension=忽略擴展
plugins.advertiser.action.ignore.ultimate=關閉
plugins.advertiser.action.ignore.unknown.feature=不建議使用此延伸模組
plugins.advertiser.action.ignore.unknown.features=不建議使用這些延伸模組
plugins.advertiser.action.install.plugin.name=安裝 {0} 延伸模組
plugins.advertiser.action.install.plugins=安裝延伸模組
plugins.advertiser.action.try.ultimate=試用 {0}
plugins.advertiser.check.progress=正在檢查專案的建議延伸模組
plugins.advertiser.enabled.on.demand={0,choice,1#延伸模組|2#延伸模組} {1} {0,choice,1#已|2#已}啟用。
plugins.advertiser.extensions.supported.in.ides=<hyperlink>其他 JetBrains IDE</hyperlink> 中支援 {0} 檔案
plugins.advertiser.extensions.supported.in.ultimate={1} 支援 {0} 檔案
plugins.advertiser.feature.dependency=相依項
plugins.advertiser.framework.supported.in.ultimate={1} 支援 {0} 個組態檔案
plugins.advertiser.learn.more=了解詳情
plugins.advertiser.missing.feature=支援 {1} ''{2}'' 的{0,choice,1#延伸模組|2#延伸模組} {4} {0,choice,1#當前|2#當前}{3,choice,0#已停用|1#尚未安裝}。
plugins.advertiser.missing.feature.dependency=推薦的{0,choice,1#延伸模組|2#延伸模組} {1} 可用。
plugins.advertiser.missing.features=支援功能({1})的{0,choice,1#延伸模組|2#延伸模組} {3} {0,choice,1#當前|2#當前}{2,choice,0#已停用|1#尚未安裝}。
plugins.advertiser.missing.features.dependency=推薦的{0,choice,1#延伸模組|2#延伸模組} {1} 可用。
plugins.advertiser.no.suggested.plugins=找不到建議的延伸模組
plugins.advertiser.plugins.found=已找到支援 {0} 檔案的延伸模組。
plugins.advertiser.plugins.suggestions.text=已找到所選相依項的延伸模組。
plugins.advertiser.plugins.suggestions.title=延伸模組建議
plugins.advertiser.task.searching.for.plugins=在儲存庫中搜尋延伸模組
plugins.advertiser.ultimate.features.detected=檢測到 IntelliJ IDEA Ultimate {0} 涵蓋的功能
plugins.advertiser.unbundled.plugin.ai.assistant=The AI Assistant plugin is now available on the Marketplace. Install the plugin to continue using it
plugins.advertiser.unbundled.plugin.dismiss=不再顯示
plugins.advertiser.unbundled.plugin.install=Install from Marketplace
plugins.auto.disabled.notification.content={0} 和 {1} 延伸模組已停用。
plugins.auto.disabled.notification.title=相依延伸模組已停用
plugins.auto.enabled.notification.content={0} 和 {1} 延伸模組已啟用。
plugins.auto.enabled.notification.title=必需延伸模組已啟用
plugins.auto.switch.action.name=撤消
plugins.changed.notification.content=延伸模組列表已更改。請重啟 {0} 以啟用更改。
plugins.changed.notification.title=需要重啟
plugins.configurable.InstalledSearchOption.Bundled=已捆綁
plugins.configurable.InstalledSearchOption.Disabled=停用
plugins.configurable.InstalledSearchOption.Downloaded=已下載
plugins.configurable.InstalledSearchOption.Enabled=啟用
plugins.configurable.InstalledSearchOption.Invalid=無效
plugins.configurable.InstalledSearchOption.NeedUpdate=可用的更新
plugins.configurable.SortBySearchOption.Downloads=下載
plugins.configurable.SortBySearchOption.Name=名稱
plugins.configurable.SortBySearchOption.Rating=評分
plugins.configurable.SortBySearchOption.Relevance=相關性
plugins.configurable.SortBySearchOption.Updated=已更新
plugins.configurable.activate.trial.for.full.access=訂閱進階功能
plugins.configurable.additional.info.tab.name=其他資訊
plugins.configurable.bugtracker.url=問題追蹤器
plugins.configurable.bundled.updates=捆綁的延伸模組更新
plugins.configurable.buy.the.plugin=購買延伸模組
plugins.configurable.buy.the.plugin.from.0=購買價低至 {0}
plugins.configurable.check.internet=檢查互聯網連線。
plugins.configurable.disable=停用
plugins.configurable.disable.all=全部停用
plugins.configurable.disable.all.downloaded=停用所有下載的延伸模組
plugins.configurable.disabled=已停用
plugins.configurable.documentation.url=文檔
plugins.configurable.downloaded=已下載
plugins.configurable.downloads.0=下載量: {0}
plugins.configurable.enable=啟用
plugins.configurable.enable.all=全部啟用
plugins.configurable.enable.all.downloaded=啟用所有下載的延伸模組
plugins.configurable.enabled=已啟用
plugins.configurable.featured=精選
plugins.configurable.forum.url=論壇頁面
plugins.configurable.install=安裝
plugins.configurable.installed=已安裝
plugins.configurable.installing=正在安裝
plugins.configurable.license.expired=授權已過期。
plugins.configurable.license.expires.in.0.days=授權將於 {0} 天後到期。
plugins.configurable.license.is.active=授權有效。
plugins.configurable.license.is.active.until.0=授權有效期至 {0}。
plugins.configurable.license.url=授權
plugins.configurable.marketplace.plugins.not.loaded=未載入 Marketplace 延伸模組。
plugins.configurable.new.and.updated=新增和更新
plugins.configurable.not.allowed=您的組織未批准此延伸模組
plugins.configurable.notes.empty.text=很遺憾，{0} 未留下任何更新說明。
plugins.configurable.notes.empty.text.default.vendor=供應商
plugins.configurable.nothing.found=找不到任何內容。
plugins.configurable.one.plugin.details=選擇一個延伸模組以預覽延伸模組詳細資訊。
plugins.configurable.other.bundled=其他工具
plugins.configurable.overview.tab.name=概覽
plugins.configurable.plugin.details=選擇延伸模組以預覽詳細資訊
plugins.configurable.plugin.homepage.link=延伸模組主頁
plugins.configurable.plugin.installing.failed=延伸模組“{0}”下載或安裝失敗
plugins.configurable.plugin.installing.success=延伸模組 {0} 已成功安裝
plugins.configurable.plugin.unavailable.for.platform=延伸模組對 {0} 不可用
plugins.configurable.rate.0=評分: {0}
plugins.configurable.release.date.0=發佈日期: {0}
plugins.configurable.repository.0=儲存庫: {0}
plugins.configurable.required.plugins.0=相依項:\\n\\
{0}
plugins.configurable.restart.ide.button=重啟 IDE
plugins.configurable.reviews.tab.name=評價
plugins.configurable.search.in.marketplace=在 Marketplace 中搜尋
plugins.configurable.search.options=搜尋選項
plugins.configurable.search.result.not.loaded=未載入搜尋結果。
plugins.configurable.several.plugins=已選擇多個延伸模組。
plugins.configurable.show=顯示
plugins.configurable.show.all=全部顯示
plugins.configurable.size.0=大小: {0}
plugins.configurable.sort.by=排序依據
plugins.configurable.source.code=原始碼
plugins.configurable.suggested=推薦
plugins.configurable.suggested.features.dependency=建議使用此延伸模組，因為您的專案使用了 {0} 庫
plugins.configurable.suggested.features.executable=建議使用此延伸模組，因為您已經安裝了 {0}
plugins.configurable.title.with.count={0} (已啟用 {1}/{2})
plugins.configurable.top.downloads=熱門下載
plugins.configurable.top.rated=最受好評
plugins.configurable.trial.expires.in.0.days=試用將於 {0} 天後到期。
plugins.configurable.unavailable.for.platform=不可用
plugins.configurable.uninstall=移除
plugins.configurable.uninstalled=已移除
plugins.configurable.update.button=更新
plugins.configurable.version.0=版本: {0}
plugins.configurable.whats.new.tab.name=最新變化
plugins.new.review.action=撰寫評價
plugins.progress.loading.plugin.title=正在載入延伸模組 {0}
plugins.progress.loading.plugins.for.current.project.title=正在載入 ''{0}'' 的延伸模組
plugins.progress.unloading.plugin.title=正在移除延伸模組 {0}
plugins.progress.unloading.plugins.for.current.project.title=正在上傳 ''{0}'' 的延伸模組
plugins.reloaded.successfully={0} 成功重新載入
plugins.review.action.copy.link.text=複製鏈接
plugins.review.panel.empty.text=目前尚無評價。
plugins.review.panel.next.page.button=展開
popup.content.action.not.available.while.updating.indices=在 {1} 更新索引期間 {0} 不可用
popup.content.actions.not.available.while.updating.indices=在 {1} 更新索引期間 {0} 不可用
popup.title.add.group.options=新增{0}選項
popup.title.add.run.options=新增執行選項
popup.title.add.tags=新增標記
popup.title.edit.shortcuts=編輯快捷鍵
popup.title.import.scheme=匯入方案
popup.title.in.editor.mode=在編輯器模式下
popup.title.maintenance=維護
popup.title.notification.display.type=通知顯示類型
popup.title.open.project=開啟專案
popup.title.play.saved.macros=播放儲存的巨集
popup.title.switch=切換
power.save.mode.disable.action.title=停用省電模式
power.save.mode.on.notification.content=程式碼洞察和背景任務已停用。
power.save.mode.on.notification.title=省電模式已開啟
preferred.theme.autodetect.selector=與作業系統同步
preferred.theme.dark.header=深色
preferred.theme.description=為自動檢測模式選擇首選主題
preferred.theme.light.header=淺色
preferred.theme.text=首選主題
presentation.mode.fon.size=字體大小:
presentation.mode.ide.scale=縮放:
presentation.mode.ide.scale.out.of.range.number.message.format=指定一個介於 {0}% 到 {1}% 之間的值
presentation.mode.ide.scale.wrong.number.message=指定正整數
press.0.to.assign.a.shortcut=按 {0} 分配快捷鍵
press.copy.key.to.copy.system.information.to.clipboard=按 Copy 鍵將系統資訊複製到剪貼簿
progress.cache.recover.from.logs.files.processed=已處理 {0}/{1} 個檔案
progress.cache.recover.from.logs.stage=暫存 {0}/{1}
progress.cache.recover.from.logs.title=快取恢復
progress.closing.project=正在關閉專案…
progress.connecting.to.plugin.manager=正在連線到 {0}
progress.creating.directory=正在建立目錄 {0}{1}{2}
progress.creating.file=正在建立檔案 {0}{1}{2}
progress.creating.package=正在建立軟體套件 {0}。{1}
progress.deleting=正在刪除
progress.deleting.class=正在刪除類別 {0}
progress.download.plugins=下載延伸模組
progress.downloading.available.plugins=正在下載可用延伸模組列表
progress.downloading.list.of.plugins=正在從 {0} 下載延伸模組列表
progress.downloading.plugin=正在下載延伸模組 ''{0}''
progress.downloading.plugins.meta=正在下載延伸模組 {0} 的資料
progress.file.system.changes=檔案系統更改
progress.performing.indexing.tasks=正在執行編制索引任務
progress.searching= 正在搜尋…
progress.text.clickToViewProgressWindow=點擊以檢視所有正在執行的背景任務
progress.text.collecting.classes=正在收集類別列表…
progress.text.downloading=正在下載…
progress.text.generate.classes.archive=正在生成類別歸檔…
progress.text.loading=正在載入…
progress.text.migrating.plugins=正在遷移延伸模組…
progress.text.reloading.file=正在重新載入檔案…
progress.text.reloading.files=正在重新載入檔案…
progress.text.reopening.files=正在重新開啟檔案…
progress.text.stopping=正在停止 - {0}
progress.title.cds.optimize.startup=正在最佳化啟動性能…
progress.title.check.connection=檢查連線
progress.title.checking.plugin.dependencies=正在檢查延伸模組相依項
progress.title.checking.plugins.repository=正在檢查延伸模組儲存庫…
progress.title.constructing.tooltip=正在建置工具提示
progress.title.creating.git.repository=建立 Git 儲存庫
progress.title.deleting.files=正在刪除檔案…
progress.title.installing.plugin=正在安裝延伸模組“{0}”…
progress.title.loading.plugin.details=正在載入延伸模組詳細資訊
progress.title.preparing.navigation=正在準備導覽…
progress.title.reload.files=重新載入檔案
progress.window.empty.text=無背景任務
progress.window.title=背景任務
project.scheme=專案
project.structure.tree.accessible.name=專案結構樹
prompt.browse.icon.for.selected.action=以 SVG 或 PNG 格式瀏覽圖標
prompt.create.non.existing.package=軟體套件 {0} 不存在。\\n\\
是否要建立?
prompt.delete.and=和
prompt.delete.directory={0,choice,1#目錄|2#目錄}
prompt.delete.directory.paren=({0} {0,choice,1#目錄|2#目錄})
prompt.delete.elements=刪除{0}?
prompt.delete.file={0,choice,1#檔案|2#檔案}
prompt.delete.it.anyway= 仍要刪除?
prompt.delete.property={0,choice,1#屬性|2#屬性}
prompt.delete.symlink={0,choice,1#符號鏈接|2#符號鏈接}
prompt.directory.contains.read.only.files=目錄 {0} 包含唯讀檔案。仍要刪除?
prompt.enter.a.new.package.name=輸入一個新的軟體套件名稱:
prompt.enter.macro.name=輸入巨集名稱。如果為臨時巨集，請留空。
prompt.enter.new.directory.name=輸入新目錄名稱:
prompt.enter.new.file.name=指定新的檔名:
prompt.enter.new.library.name=輸入新庫名稱
prompt.enter.new.module.name=輸入新模組名稱
prompt.enter.new.name=輸入新名稱
prompt.enter.new.package.name=輸入新的軟體套件名稱:
prompt.filechooser.enter.file.name=輸入檔名:
prompt.goto.inspection.enter.name=輸入檢查名稱:
prompt.gotoaction.enter.action=輸入動作或選項名稱:
prompt.gotoclass.enter.class.name=輸入 {0} 名稱:
prompt.gotofile.enter.file.name=輸入檔名:
prompt.gotosymbol.enter.symbol.name=輸入符號名稱:
prompt.input.favorites.list.new.name=將收藏夾列表 ''{0}'' 重命名為:
prompt.input.new.favorites.list.name=輸入新收藏夾列表的名稱
prompt.open.project.or.attach=<html><body>可以在新視窗中開啟專案，取代當前視窗中的專案，或者將專案附加到已經開啟的專案。<br>您想如何開啟專案?</body></html>
prompt.open.project.or.attach.button.attach=附加(&A)…
prompt.open.project.or.attach.button.new.window=新視窗 (&W)
prompt.open.project.or.attach.button.this.window=此視窗(&T)
prompt.open.project.or.attach.title=開啟專案
prompt.proxy.authentication=代理身份驗證
prompt.reset.to.original.template=重設為原始模板?
prompt.server.authentication=伺服器身份驗證
prompt.specify.module.group.name=指定{0}將顯示在其下方的組名稱。\\n\\
\\n\\

prompt.specify.name.of.module.subgroup=指定{1}將顯示在其下方的{0}子組的名稱\\n\\
\\n\\

prompt.uninstall.plugin=確定要移除延伸模組 ''{0}'' 嗎?
prompt.uninstall.several.plugins=確定要移除這 {0} 個延伸模組嗎?
quick.lists.description=<html>快速列表允許您定義常用的動作組 (例如，重構或 VCS 動作)，並將鍵盤快捷鍵分配給此類別組。</html>
quick.lists.not.empty.name=快速列表應具有非空名稱
quick.lists.presentable.name=快速列表
quickfix.text.insert.0=插入 {0}
radio.button.open.matching.files.in.associated.application=在關聯的應用程式中開啟符合檔案
radio.button.unlock.all=全部解鎖
radio.button.unlock.dir=目錄解鎖
radio.button.unlock.one=解鎖一個
radio.button.using.file.system=使用檔案系統(&F)
radio.button.using.version.control.integration=使用版本控制整合(&V)
radio.process.close.ask=詢問
radio.process.close.disconnect=斷開連線
radio.process.close.terminate=終止程序
recent.files.accessible.file.list=檔案
recent.files.accessible.open.recently.edited.locations=開啟最近編輯的位置
recent.files.accessible.open.recently.viewed.locations=開啟最近的位置
recent.files.accessible.show.tool.window=啟用工具視窗: {0}
recent.files.accessible.tool.window.list=工具視窗
recent.files.checkbox.label=僅顯示已編輯的內容
recent.files.file.list.empty.text=無最近檔案
recent.files.speed.search.empty.text=按 'Enter' 在專案中搜尋
recent.files.tool.window.list.empty.text=無工具視窗
recent.locations.changed.locations=最近編輯的位置
recent.locations.popup.empty.file.text=空行
recent.locations.popup.empty.text=未找到最近的位置
recent.locations.popup.title=最近的位置
recent.locations.title.text=僅顯示已編輯的內容
recent.project.unavailable=(不可用)
recover.caches.from.log.recovery.action.name=從動作日誌恢復快取
recovery.progress.title=正在嘗試{0}…
redo.command=重做{0}
redo.dialog.title=重做
registry.change.warning=更改這些值可能導致 {0} 的異常行為。除非要求，否則請不要更改這些值。
registry.close.action.text=關閉
registry.key.requires.ide.restart.note=需要重啟 IDE
registry.restore.defaults.action.text=還原為預設設定
reload.or.convert.dialog.title={0}: 重新載入或轉換為 {1}
remove.BOM=移除 BOM
remove.byte.order.mark.from=從 {0} 中移除位元組順序標記
removing.BOM=正在移除 BOM
rename.0=重新命名 {0}
reportProblemAction.progress.title.submitting=正在提交…
repository.url.title=儲存庫 URL
required.plugin.at.least.versions=，版本至少為 ''{0}''
required.plugin.at.most.versions=，版本最高為 ''{0}''
required.plugin.between.versions=，''{0}'' 和 ''{1}'' 之間的版本
required.plugin.exact.version=，版本 ''{0}''
reset.action.text=重設
run.anything.accessible.name=執行任何內容
run.anything.action.tooltip.text=執行指令: 開啟專案，啟動執行組態，執行 Gradle 或 Maven 任務，執行終端指令等。
run.anything.actions.undefined=未定義
run.anything.ad.command.delete={0} 刪除最近的指令
run.anything.ad.run.action.with.default.settings=按 {0} 使用預設設定執行
run.anything.ad.run.in.context=按 {0} 在當前檔案上下文中執行
run.anything.ad.run.with.debug={0} 偵錯
run.anything.console.error.title=無法執行指令
run.anything.console.process.finished=\\n\\
程序已結束，退出程式碼為 {0}。
run.anything.context.browse.directory=瀏覽目錄…
run.anything.context.project=專案
run.anything.context.project.undefined=未定義
run.anything.context.separator.directories=目錄
run.anything.context.separator.modules=模組
run.anything.context.title.working.directory=執行上下文
run.anything.context.tooltip=選擇將在其中執行當前指令的上下文
run.anything.custom.activity.notification.group.id=已執行 Run Anything 指令
run.anything.custom.activity.rollback.action=回滾
run.anything.general.group.title=一般
run.anything.help.list.empty.secondary.text=選擇指令
run.anything.hint.initial.text=按 {0} 或 {1} 瀏覽建議列表
run.anything.indexing.mode.not.supported=在索引更新期間，“執行任何內容”不可用
run.anything.main.list.empty.primary.text=執行指令或組態
run.anything.main.list.empty.secondary.text=輸入“?”以檢視所有指令
run.anything.notification.warning.content=指令 ''{0}'' 無法執行。
run.anything.notification.warning.title=指令執行失敗
run.anything.recent.group.title=最近
run.anything.recent.project.command.placeholder=開啟 <專案名稱>
run.anything.recent.project.completion.group.title=最近的專案
run.anything.recent.project.help.group.title=最近的專案
run.anything.run.anything.title=執行任何內容
run.anything.run.configurations.group.title=執行組態
run.anything.run.debug.title=偵錯:
run.anything.run.in.context.debug.title=使用偵錯在上下文中執行:
run.anything.run.in.context.title=在上下文中執行:
run.layout.do.not.show.view.option.message=不顯示
scheme.ide=IDE
scheme.project=專案
scope.banner.text=作用域 ''{0}''
scope.chooser.select.scope.text=在此處選擇作用域以檢視或編輯其詳細資訊
scope.class.hierarchy=類別層次結構
scope.current.file=當前檔案
scope.editor.legend.partly.included.label=部分包含
scope.editor.legend.recursively.included.label=遞迴包含
scope.files.in.previous.search.result=之前搜尋結果中的檔案
scope.open.files=開啟檔案
scope.previous.search.results=之前的搜尋結果
scope.recent.files=最近檢視的檔案
scope.recent.modified.files=最近更改的檔案
scope.selected.directories=選定{0,choice,1#目錄|2#目錄}
scope.selected.files=選定{0,choice,1#檔案|2#檔案}
scope.selected.files.and.directories=選定{0,choice,1#檔案|2#檔案}和{1,choice,1#目錄|2#目錄}
scope.selection=選區
scope.unable.to.save.scope.message=是否要儲存為共享作用域?
scope.unable.to.save.scope.title=無法使用區域作用域
scope.view.empty.link=顯示所有專案檔案
scope.view.empty.text=當前作用域中沒有檔案。
scope.view.title=作用域
scopes.display.name=作用域
scopes.no.scoped=未新增作用域。
scopes.save.dialog.title.local=儲存為區域作用域
scopes.save.dialog.title.shared=儲存為共享作用域
scratches.and.consoles=臨時檔案和主控台
search.everywhere.action.tooltip.description.text=搜尋: <ul style=''list-style-type:none;margin:0;padding:0;''><li>- {0}</li><li>- 檔案</li><li>- 工具視窗</li><li>- 動作</li><li>- 設定</li></ul>
search.everywhere.action.tooltip.text=搜尋所有位置<br/>按 <b>{0}</b> 存取 <ul style=''list-style-type:none;margin:0;padding:0;''><li>- {1}</li><li>- 檔案</li><li>- 工具視窗</li><li>- 動作</li><li>- 設定</li></ul>
search.everywhere.command.plugins=延伸模組: {0}
search.everywhere.directory.file.type.name=目錄
search.everywhere.filter.classes.description=轉到類別
search.everywhere.filter.files.description=轉到檔案
search.everywhere.filter.symbols.description=轉到符號
search.everywhere.group.name.actions=動作
search.everywhere.group.name.files=檔案
search.everywhere.group.name.recent.files=最近的檔案
search.everywhere.group.name.symbols=符號
search.everywhere.group.name.top.hit=點擊最多
search.everywhere.points.more=…更多
search.for.usages.and.delete.elements=搜尋用法並刪除{0}?
searcheverywhere.accessible.name=隨處搜尋
searcheverywhere.allelements.tab.name=所有
searcheverywhere.autocompletion.tab.name=自動補全
searcheverywhere.commands.tab.name=指令
searcheverywhere.found.matches.title=''{0}'' 在 [{1}] 中的匹配項
searcheverywhere.found.targets.title=未排序的結果
searcheverywhere.history.shortcuts.hint=按 {0} 或 {1} 瀏覽搜尋歷史記錄
searcheverywhere.ide.search.tab.name=IDE
searcheverywhere.indexing.incomplete.results=在 {1} 更新索引期間，''{0}'' 中的搜尋結果可能不完整
searcheverywhere.indexing.mode.not.supported=在 {1} 更新索引期間，無法在 ''{0}'' 中搜尋
searcheverywhere.nothing.found.for.all.anywhere=找不到任何內容
searcheverywhere.nothing.found.for.contributor.anywhere=未找到使用此類別名的 {0}
searcheverywhere.open.in.new.window.shortcuts.hint=按 {0} 在新視窗中開啟檔案
searcheverywhere.open.in.split.shortcuts.hint=按 {0} 在右拆分中開啟檔案
searcheverywhere.project.search.tab.name=專案
searcheverywhere.reset.filters=重設篩選器
searcheverywhere.run.configs.tab.name=執行組態
searcheverywhere.runconfigurations.command.debug.description=在“偵錯”模式下開始執行組態
searcheverywhere.runconfigurations.command.run.description=在“執行”模式下開始執行組態
searcheverywhere.test.dialog.elements.limit=元素限制
searcheverywhere.test.dialog.grouping.interval=分組間隔
searcheverywhere.test.dialog.search.button=搜尋
searcheverywhere.test.dialog.search.field=搜尋文本
searcheverywhere.test.dialog.title=搜尋貢獻者測試
searcheverywhere.textfield.hint=輸入 {0} 以檢視指令
searcheverywhere.to.perform.fulltext.search=以執行全文搜尋
searcheverywhere.try.to.find.in.files=在檔案中尋找
searcheverywhere.try.to.reset.scope=將作用域設定為
searcheverywhere.use.main=使用
searcheverywhere.use.optional=或使用
section.title.fingerprints=指紋
section.title.issued.by=發佈者
section.title.issued.to=發佈物件
section.title.validity.period=有效期
select.in.commander=Commander
select.in.favorites=收藏夾
select.in.file.structure=檔案結構
select.in.packages=軟體套件
select.in.project=專案
select.in.scope=作用域
separator.scheme.stored.in=存儲於 {0}
setting.value.reload.mode.preview=在內置預覽中重新載入頁面:
setting.value.reload.mode.server=在瀏覽器中重新載入頁面:
settings.browsers.column.family=系列
settings.browsers.column.name=名稱
settings.browsers.column.path=路徑
settings.browsers.custom.path=自訂路徑
settings.browsers.default.browser=預設瀏覽器:
settings.browsers.first.listed=首先列出
settings.browsers.no.web.browsers.configured=未組態 Web 瀏覽器
settings.browsers.reload.behavior=重新載入行為
settings.browsers.show.browser.popup.html=對於 HTML 檔案
settings.browsers.show.browser.popup.in.the.editor=在編輯器中顯示瀏覽器彈出視窗
settings.browsers.show.browser.popup.xml=對於 XML 檔案
settings.browsers.system.default=系統預設值
settings.certificate.accept.non.trusted.certificates.automatically=自動接受非可信憑證(&A)
settings.certificate.accepted.certificates=接受的憑證:
settings.certificate.cannot.add.certificate=無法新增憑證
settings.certificate.cannot.add.certificate.for=無法為 {0} 新增憑證
settings.certificate.cannot.remove.certificate=無法移除憑證
settings.certificate.cannot.remove.certificate.for=無法移除 {0} 的憑證
settings.certificate.certificate.already.exists=憑證已存在
settings.certificate.choose.certificate=選擇憑證
settings.certificate.malformed.x509.server.certificate=X509 伺服器憑證的格式錯誤
settings.certificate.no.certificate.selected=未選擇任何憑證
settings.certificate.no.certificates=無憑證
settings.certificate.not.imported=未匯入
settings.entry.point.newUi.tooltip=新 UI 可用
settings.entry.point.tooltip=IDE 和專案設定
settings.entry.point.update.ide.action=下載 {0} {1}
settings.entry.point.update.plugin.action=更新 {0} 延伸模組…
settings.entry.point.update.plugins.action=更新 {0} 延伸模組…
settings.entry.point.widget.name=IDE 和專案設定
settings.entry.point.with.updates.tooltip=有可用更新。IDE 和專案設定
settings.file.color.column.color=顏色
settings.file.color.column.scope=作用域
settings.file.color.column.shared=通過 VCS 共享
settings.file.color.column.shared.help=<html>共享組態存儲在 <code>.idea</code> 目錄中，<br>其他團隊成員可以通過 VCS 使用。
settings.file.color.custom.name=自訂
settings.file.colors.add.colors.link=新增顏色
settings.file.colors.description=<html>檔案可以屬於多個作用域。如果一個作用域有兩種顏色，則使用列表中第一個作用域的顏色。
settings.file.colors.dialog.choose.color=選擇作用域顏色
settings.file.colors.dialog.warning.append=您是否希望再次新增?
settings.file.colors.dialog.warning.local=已為 {0} 定義區域顏色
settings.file.colors.dialog.warning.replace=<html>是否要將<span style="background-color:#{0};">舊顏色</span>更新為<span style="background-color:#{1};">新顏色</span>?
settings.file.colors.dialog.warning.shared=已為 {0} 定義共享顏色
settings.file.colors.dialog.warning.update=更新
settings.file.colors.enable.file.colors=啟用檔案顏色(&F)
settings.file.colors.manage.scopes=管理作用域(&M)…
settings.file.colors.no.colors.specified=未新增顏色
settings.file.colors.scope.unknown=不存在的作用域
settings.file.colors.use.in.editor.tabs=在編輯器頁籤中使用(&T)
settings.file.colors.use.in.project.view=在專案檢視中使用(&P)
settings.general.directory.preselected=“開啟…” 和 “新增 | 專案…” 對話框中會預先選擇此目錄。
settings.general.synchronization=自動儲存
settings.menus.group.touch.bar=Touch Bar
settings.password.internal.error.no.available.credential.store.implementation=內部錯誤，沒有可用的憑證存儲實作。
settings.password.package.libsecret.1.0.is.not.installed=未安裝軟體套件 libsecret-1-0 (要安裝，請使用以下指令: sudo apt-get install libsecret-1-0 gnome-keyring)。
settings.password.unknown.provider.type=未知提供程序類型: {0}
settings.required.plugins.title=指定專案所需的延伸模組列表。如果缺少必需延伸模組或需要更新，{0} 將通知您。
settings.trusted.certificates=驗證延伸模組時受信任的憑證:
share.scope.checkbox.title=通過 VCS 共享
share.scope.context.help=<html>共享組態存儲在 <code>.idea</code> 目錄中，<br>其他團隊成員可以通過 VCS 使用。
shell.env.loading.failed={0} 未能從 ''{1}'' 載入環境。與依賴於環境變數的工具整合可能無法正常進行。
shell.env.loading.learn.more=了解詳情
shortcut.balloon.add.shortcut=新增快捷鍵
shortcut.in.group.text=在 {0} 中
show.hidden.tabs=顯示隱藏的頁籤
show.in.find.window.button.description=在“尋找工具”視窗中開啟搜尋結果
show.in.find.window.button.name=在“尋找工具”視窗中開啟
show.in.find.window.button.name.newui=在尋找視窗中開啟結果
show.in.find.window.button.pin.description=在單獨的工具視窗中顯示所有用法
show.main.toolbar=顯示主工具列
show.members.in.navigation.bar=在導覽列中顯示成員
show.navigation.bar=顯示導覽列
show.options.menu=選項
show.status.bar=顯示狀態列
small.labels.in.editor.tabs=編輯器頁籤中的小標籤
speed.search.got.it.link=知道了
speed.search.got.it.text=只需開始輸入以篩選元素
split.with.chooser.duplicate.tab=，{0}以複製
split.with.chooser.move.tab=按 {0} 開啟“{1}”
split.with.chooser.switch.tab=使用 {0} 轉到下一個拆分器
start.browser.border.label.open.browser=開啟瀏覽器
start.browser.checkbox.start.browser=在啟動後
start.browser.panel.url.label=URL(&U):
start.browser.with.js.debugger=使用 JavaScript 偵錯器(&J)
status.bar.message.at.line=行 {0}: {1}
status.bar.text.file.encoding=檔案編碼: {0}
status.bar.text.macro.recorded=已記錄: {0}
status.bar.text.script.execution.finished=腳本執行已完成
structure.view.tree.accessible.name=結構檢視樹
support.screen.readers.tab={0} 和 {1} 將在對話框中導覽 UI 控件，並且不能用於切換編輯器頁籤或其他 IDE 動作
sys.health.acknowledge.action=不再顯示
sys.health.details=詳細資訊
tab.chooser.project=專案
tab.chooser.search.by.name=按名稱搜尋
tab.filetemplates.code=程式碼
tab.filetemplates.includes=Include
tab.filetemplates.j2ee=其他
tab.filetemplates.templates=檔案
tab.title.editor.and.preview=編輯器和預覽
tab.title.editor.only=編輯器
tab.title.html.preview=HTML 預覽
tab.title.preview.only=預覽
tab.title.stacktrace=<堆疊追蹤>
tab.title.text=文本
tabs.layout.compressible.name=可壓縮單排
tabs.layout.scrollable.single.row.name=可滾動單排
tabs.layout.table.name=表布局
task.browser.label=瀏覽器:
task.browser.launch=啟動 Web 瀏覽器
task.browser.url=URL:
temp.dir.env.invalid=環境變數 ''{0}'' 指向不存在的目錄(''{1}'')。有些東西可能工作不正常。
template.copy.N.of.T=複製 {0} 個 {1}
template.file.name=用於生成檔名和路徑的模板
template.file.name.optional=用於生成檔名和路徑的模板(可選)
template.unnamed=未命名
terminal.action.ClearBuffer.text=清除緩衝區
terminal.action.Find.text=尋找
terminal.action.LineDown.text=向下移動一行
terminal.action.LineUp.text=向上滾動一行
terminal.action.MoveLeft.text=左移
terminal.action.MoveRight.text=右移
terminal.action.OpenAsUrl.text=作為 URL 開啟
terminal.action.PageDown.text=向下翻頁
terminal.action.PageUp.text=向上翻頁
terminal.action.SelectNextTab.text=選擇下一個頁籤
terminal.action.SelectPreviousTab.text=選擇上一個頁籤
terminal.action.ShowTabs.text=顯示頁籤
terminal.cursor.shape.block.name=塊
terminal.cursor.shape.underline.name=下劃線
terminal.cursor.shape.vertical.name=垂直線
text.password.hidden=<已隱藏>
text.server.s.certificate.trusted=伺服器的憑證不可信
text.server.s.certificate.trusted.details=伺服器的憑證不可信:<br/>{0}
text.todo.no.filters=未組態篩選器
text.todo.no.patterns=未組態模式
text.use.solution.colors.in.main.toolbar=一目了然地區分具有不同工具列顏色的專案。僅適用於新 UI。
this.directory.does.not.belong.to.the.project={0, choice, 1#這一目錄|2#這些目錄}不屬於專案:
this.file.does.not.belong.to.the.project={0, choice, 1#這一檔案|2#這些檔案}不屬於專案:
thread.dump.is.taken=執行緒傾印已被<a href="{0}">佔用</a>。
tip.of.the.day.feedback.dislike=不喜歡
tip.of.the.day.feedback.like=喜歡
tip.of.the.day.feedback.question=您覺得這個小技巧是否有用?
tip.of.the.day.progress.title=顯示每日小技巧
tips.of.the.day.shortcut.default.keymap=(預設按鍵映射)
tips.of.the.day.shortcut.must.define=未定義，通過“設定/按鍵映射”設定
title.accessibility=無障礙功能
title.add.new.favorites.list=新增新收藏夾列表
title.add.todo.filter=新增篩選器
title.add.todo.pattern=新增模式
title.appearance=外觀
title.browse.icon=瀏覽圖標
title.browser.not.found=未找到瀏覽器
title.cannot.convert.project=無法轉換專案
title.cannot.create.class=無法建立類別
title.cannot.create.file=無法建立檔案
title.cannot.load.project=無法載入專案
title.cannot.open.file=無法開啟檔案
title.cannot.open.project=無法開啟專案
title.cannot.save.current.template=無法儲存當前模板
title.choose.action.icon=選擇動作圖標
title.choose.destination.directory=選擇目標目錄
title.common=通用
title.customizations=選單與工具列
title.delete=刪除
title.edit.file.template=編輯檔案模板
title.edit.macros=編輯巨集
title.edit.todo.filter=編輯篩選器
title.edit.todo.pattern=編輯模式
title.enter.macro.name=輸入巨集名稱
title.error.reading.file=讀取檔案時出錯
title.error.writing.file=寫入檔案時錯誤
title.export.preview=匯出預覽
title.file.already.exists=檔案已存在
title.file.templates=檔案和程式碼模板
title.general=系統設定
title.hierarchy.callees.of={0} 的被呼叫方
title.hierarchy.callers.of={0} 的呼叫方
title.hierarchy.class=類別{0}
title.hierarchy.method=方法 {0}
title.hierarchy.subtypes={0}的子類型
title.hierarchy.supertypes={0}的父類型
title.load.file.from.share=正在從網絡載入檔案
title.load.project.from.share=正在從網絡載入專案
title.macro.name.already.used=巨集名稱已被使用
title.module.file.does.not.exist=模組檔案不存在: {0}
title.module.group=模組組
title.module.sub.group=模組子組
title.new.directory=新增目錄
title.new.file=新增檔案
title.new.from.template=新增 {0}
title.new.package=新增軟體套件
title.no.element.selected=未選擇任何元素
title.open.file.or.project=開啟檔案或專案
title.open.project=開啟專案
title.package.not.found=找不到軟體套件
title.plugin.error=延伸模組錯誤
title.plugin.installation=延伸模組安裝
title.plugin.uninstall=移除延伸模組
title.plugins=延伸模組
title.popup.new.element=新增
title.popup.new.element.same.place=在此目錄中新增
title.popup.recent.files=最近的檔案
title.popup.select.target=選擇位置:
title.project=專案
title.rename.favorites.list=重新命名
title.rename.library=重新命名庫
title.rename.macro=重新命名巨集
title.rename.module=重新命名模組
title.reset.template=重設模板
title.restart.needed=需要重啟
title.search.results=搜尋結果
title.select.path.to.browser=選擇瀏覽器的路徑
title.select.project.file.directory=選擇{0}檔案目錄
title.select.template=選擇模板
title.smooth.scrolling.options=平滑滾動選項
title.tip.of.the.day=每日小技巧
title.todo=TODO
title.todo.current.file=當前檔案
title.unable.to.add.favorites.list=無法新增收藏夾列表
title.use.rest.api=使用 REST API
title.velocity.error=Velocity 錯誤
title.warning=警告
to.create.new.file.tooltip=要建立新檔案，請按 <b>{0}</b>。或者右擊任何目錄並選擇<b>新增 | \\\\&lt;file type\\\\&gt;</b>
todo.panel.preview.source.action.text=預覽源
toggle.editor.and.tools=編輯器和工具
toggle.empty.frame=空框架
too.large.download.size=通過塊映射下載歸檔需要太多塊，因此將下載整個歸檔
toolbox.updates.download.ready.action.description=Toolbox App 已安裝 {2} {1} ({0})。是否重啟到新版本?
toolbox.updates.download.ready.action.text=切換到 {2} {1} ({0})…
toolbox.updates.download.update.action.description=Toolbox App 將下載 {2} {1} ({0}) 並通知您更新切換就緒的時間
toolbox.updates.download.update.action.text=下載 {2} {1} ({0})
tooltip.autosave.mode=自動儲存模式
tooltip.close.notification=關閉。按 Alt 並點擊以關閉所有通知
tooltip.close.tab=關閉頁籤
tooltip.eap.plugin.version=EAP 版本不保證延伸模組的穩定性\\n\\
和可用性。
tooltip.event.log.show.balloon=顯示氣球
tooltip.flip.horizontally=水平翻轉
tooltip.flip.vertically=垂直翻轉
tooltip.from.deployment.configuration=來自部署組態:
tooltip.hide=隱藏
tooltip.inherited.editor.color.scheme=編輯器 | 配色方案 | {0}<br>{1}
tooltip.license.not.required.for.eap.version=EAP 版本不需要授權
tooltip.line.separator=行分隔符: {0}
tooltip.macro.is.being.recorded.now=正在錄製巨集
tooltip.module.group=模組組
tooltip.paid.plugin=安裝後啟用延伸模組授權或使用 30 天試用。
tooltip.recent.search=最近搜尋
tooltip.search.history=搜尋歷史記錄
tooltip.search.history.hotkey=搜尋歷史記錄 {0}
tooltip.shared.folders.from.vagrantfile=來自 Vagrantfile 的共享目錄:
tooltip.text.add.shortcut.with.special.keys=使用 {0} 鍵設定快捷鍵
tooltip.text.password.will.be.stored.between.application.sessions=密碼將存儲在應用程式會話之間
tooltip.text.update.is.in.progress.click.to.cancel=正在更新。點擊以取消
tooltip.turn.notification.off=關閉或更改行為
tooltip.ui.designer.form=UI 設計器表單
toolwindow.header.accessible.name=工具視窗標題
toolwindow.palette=調色板
toolwindow.stripe.Bookmarks=書籤
toolwindow.stripe.Commit=提交
toolwindow.stripe.Event_Log=事件日誌
toolwindow.stripe.Favorites=收藏夾
toolwindow.stripe.Notifications=通知
toolwindow.stripe.Problems=自動建置
toolwindow.stripe.ProblemsView=問題
toolwindow.stripe.Problems_View=問題
toolwindow.stripe.Profiler=分析器
toolwindow.stripe.Project=專案
toolwindow.stripe.Statistics_Event_Log=統計事件日誌
toolwindow.stripe.Structure=結構
toolwindow.stripe.TODO=TODO
toolwindow.stripe.Version_Control=版本控制
toolwindow.stripe.documentation.v2=文檔
transfer.settings.notificationGroup=傳輸設定訊息
transfersettings.button.retry.import=重試匯入
transfersettings.label.build.solution=建置解決方案
transfersettings.label.debug=偵錯
transfersettings.label.failed.to.import.settings.from=無法從 {0} {1} 匯入設定
transfersettings.label.find.usages=尋找用法
transfersettings.label.go.to.declaration=轉到宣告
transfersettings.label.please.try.again=請重試
transfersettings.label.run=執行
transfersettings.label.search.everywhere=隨處搜尋
transfersettings.plugin.built.in=內建
transfersettings.plugin.plugin=延伸模組
transfersettings.product.visual.studio=Visual Studio
transfersettings.product.visual.studio.for.mac=Visual Studio for Mac
transfersettings.product.vscode=VSCode
transfersettings.projects.and.n.more=和其他 {0} 個
transfersettings.task.progress.details.complete=完成
transfersettings.task.progress.details.finishing.up=正在完成…
transfersettings.task.progress.details.starting.up=正在啟動…
transfersettings.task.progress.title.importing.settings=正在匯入設定
transfersettings.vs.failureReason=如果 Visual Studio 處於開啟狀態或其檔案被另一個程序存取，則會發生這種情況。{0}
transfersettings.vs.noSettings=如果未正確移除 Visual Studio、其設定損壞或從未啟動，則會發生這種情況。
transfersettings.vs.quit.advise=退出 Visual Studio 和所有使用 Visual Studio 工具的程序。之後等待大約 30 秒。
treenode.loading= 正在載入…
trial.expired=試用已過期。
trusted.folders.settings.label=位於這些本地目錄下的專案將被視為受信任的專案
trusted.hosts.settings.new.trusted.folder.dialog.title=新增受信任的位置
trusted.hosts.settings.new.trusted.folder.file.chooser.title=選擇受信任的位置
ui.customization.select.auto.popup.by.chars.text=通過按空格、點或其他上下文相關鍵插入選定建議
undo.command=撤消{0}
undo.command.local.name=本地
undo.conflicting.change.confirmation=受此動作影響的其他檔案已更改。
undo.dialog.title=撤消
uninstall.packages.failed=無法移除軟體套件。<a href="xxx">詳細資訊…</a>
uninstall.packages.failed.dialog.title=移除軟體套件失敗
unknown.error=未知錯誤
unscramble.dialog.title=分析堆疊追蹤
unsupported.windows=This version of Windows is no longer supported. Some features may not work correctly. Please use Windows 10 1809 or newer.
untrusted.project.dialog.distrust.button=繼續使用安全模式
untrusted.project.dialog.trust.button=信任專案
untrusted.project.link.dialog.cancel.button=不鏈接
untrusted.project.link.dialog.title=是否信任並鏈接 {0} 專案 ''{1}''?
untrusted.project.notification.description=安全模式，功能受限。信任該專案以存取完整的 IDE 功能。
untrusted.project.notification.read.more.link=閱讀更多資訊
untrusted.project.notification.trust.link=信任專案…
untrusted.project.open.dialog.cancel.button=不開啟
untrusted.project.open.dialog.distrust.button=在安全模式下預覽
untrusted.project.open.dialog.text={0} 提供的功能可能會從此目錄執行潛在的惡意程式碼。\\n\\
\\n\\
如果不信任此源，請在安全模式下預覽專案，以便僅瀏覽其程式碼。
untrusted.project.open.dialog.title=信任並開啟專案 ''{0}''?
untrusted.project.warning.trust.location.checkbox=信任 {0} 中的專案
update.apply.manually.message=抱歉，IDE 無法在您的系統上執行自動更新。\\n\\
 請退出 IDE 並通過啟動此腳本手動套用補丁:\\n\\
{0}。
update.channel.enforced=更新通道已切換為 ''{0}''
update.downloading.patch.error=無法準備更新:<br>{0}
update.downloading.patch.open=開啟下載頁面
update.downloading.patch.progress=正在下載補丁檔案
update.downloading.plugins.progress=正在下載延伸模組更新
update.installed.notification.title=已安裝延伸模組更新
update.no.update.hosts=沒有組態延伸模組儲存庫
update.preparing=正在準備 IDE 更新
update.preparing.patch.progress=正在準備補丁檔案
update.ready.message=IDE 已準備好更新
update.ready.restart=重新啟動
update.snap.blog.post.action=網誌
update.snap.message=IDE 已通過 Snap 更新。
update.whats.new={0} 最新變化
updates.all.plugins.action={0,choice,1#更新|2#全部更新}
updates.apply.manually.button=手動更新(&D)
updates.channel.bundled.key=新版本有一個到期日期，不需要授權密鑰。
updates.checking.platform=正在檢查 IDE 更新
updates.checking.plugins=正在檢查延伸模組更新
updates.checking.progress=正在檢查更新
updates.configure.label=<b><a href="updates">組態</a></b>自動更新。
updates.configure.updates.label=組態更新…
updates.dialog.title={0} 和延伸模組更新
updates.download.and.restart.button=更新並重啟(&D)
updates.download.button=下載(&L)
updates.error.connection.failed=連線失敗({0})。請檢查您的網絡連線並重試。
updates.error.connection.title=連線錯誤
updates.external.error.message=無法檢查 {0} 的更新: {1}
updates.external.progress=正在提取外部組件的可用更新
updates.external.ready.message={0,choice,1#組件|2#組件}: {1}
updates.fallback.build=您有新版本的永久回退授權。
updates.from.to=將 {0} 更新到 {1} ({2})。
updates.from.to.size=正在將 {0} 更新到 {1} ({2})。補丁大小為 {3} MB。
updates.ignore.update.button=忽略這個更新(&I)
updates.ignore.updates.button=忽略{0,choice,1#此更新|2#這些更新}(&I)
updates.ignore.updates.link=忽略{0,choice,1#此更新|2#這些更新}
updates.incompatible.plugins.found=新版本中的: {0,choice,1#'' ''|2#'<br/>'} {1} 與 {0,choice,1#延伸模組|2#延伸模組} 不相容
updates.interim.build=您可以使用新版本，直到您的訂閱於 {0} 到期。
updates.last.check.never=從不
updates.new.build.notification.title={0}{1}可用
updates.new.version.available=<b>有新版本的 {0} <a href="{1}">可用</a>!</b>
updates.no.updates.message=您已安裝最新版本的 {0} 和延伸模組。
updates.no.updates.notification=沒有可用的 IDE 或延伸模組更新
updates.no.updates.snap.message=<html>所有延伸模組都處於最新狀態。<br> {0} 更新由 Snap 管理。<br>執行 ''snap refresh'' 指令以檢查更新。</html>
updates.no.updates.toolbox.message=<html>所有延伸模組都是最新的。<br> {0} 更新由 Toolbox App 管理。<br>啟動它以檢查是否有可用更新。</html>
updates.no.updates.unknown.message=<html>所有延伸模組都是最新的。<br> {0} 更新由 {1} 管理。</html>
updates.notification.title={0} 和延伸模組更新
updates.notification.update.action=更新…
updates.paid.upgrade=您可以評估新版本 {0} 天，或者在線購買。
updates.plugin.ready.title=有可用的 {0} 延伸模組更新
updates.plugin.ready.tooltip={0} 個{1,choice,1#延伸模組|2#延伸模組}{1,choice,1#更新|2#更新}可用
updates.plugins.dialog.action=詳細資訊…
updates.plugins.error.message1=無法從預設儲存庫載入延伸模組: {0}
updates.plugins.error.message2=無法從 ''{0}'' 載入延伸模組: {1}
updates.plugins.ready.title=有可用的延伸模組更新
updates.plugins.settings.checkbox=檢查延伸模組更新
updates.remind.later.button=稍後提醒我(&R)
updates.settings.channel.locked=EAP 版本只能通過 EAP 通道更新
updates.settings.check.now.button=檢查更新(&C)…
updates.settings.checkbox=檢查 IDE 更新
updates.settings.checkbox.for=為之檢查 IDE 更新:
updates.settings.current.version=當前版本:
updates.settings.external=IDE 更新由 {0} 在外部管理
updates.settings.ignored=管理忽略的更新…
updates.settings.ignored.title=忽略的更新
updates.settings.last.check=上次檢查: {0}
updates.settings.recommend.toolbox=我們推薦 <a href=''{0}''>{1}</a>
updates.settings.recommend.toolbox.multiline.description=自動獲取更新，一鍵開啟您的專案，<br>了解其他 JetBrains 產品等
updates.settings.show.editor=IDE 更新後在編輯器中顯示新功能
updates.settings.title=更新
updates.write.protected={0} 沒有 {1} 的寫入權限。請通過特權使用者執行以更新。
upgrade.package.failed.title=升級軟體套件失敗。
upgrade.packages.failed=無法升級軟體套件。<a href="xxx">詳細資訊…</a>
upgrade.packages.failed.dialog.title=升級軟體套件失敗
uses.shortcut.of=繼承自
vagrant.vm.1.choice.0.0.1.at.2.3=Vagrant 虛擬機{1, choice, 0#“{0}”|1#}，處於 {2} ({3})
vm.options.edit.action.cap=編輯自定義虛擬機選項
vm.options.env.vars=檢測到使用了 Java 選項環境變數。此類別變數將覆寫 IDE 組態檔案(*.vmoptions)，並可能導致性能和穩定性問題。請考慮刪除以下變數: {0}。
warning.create.directory.with.dot=注意: 名稱中的 "." 會被視為一般字元。如果要建立嵌套目錄，請改用 "/"
warning.create.directory.with.ignored.name=正在嘗試建立包含忽略名稱(''{0}'')的目錄；結果將不可見
warning.create.package.with.ignored.name=正在嘗試建立包含忽略名稱(''{0}'')的軟體套件；結果將不可見
warning.delete.all.files.and.subdirectories=\\n\\
“{0}”中的所有檔案和子目錄將被刪除。\\n\\
您可能無法完全撤消此動作!
warning.delete.all.files.and.subdirectories.in.the.selected.directory=\\n\\
所選目錄中的所有檔案和子目錄將被刪除。\\n\\
您可能無法完全撤消此動作!
warning.load.file.from.share=您正在開啟來自網絡共享的檔案。是否要繼續?\\n\\
{0}
warning.load.project.from.share=您正在開啟來自網絡共享的專案。您是否信任此位置?\\n\\
{0}
warning.use.rest.api.0.and.trust.host.1=''{0}'' API 已請求。您信任 ''{1}'' 嗎?
warning.use.rest.api.0.and.trust.host.unknown=已請求 ''{0}'' API。您是否信任未知主機?
warning.use.rest.api.block.unknown.hosts=是否要阻止來自未知主機的請求?
web.preview.file.editor.name={0} 的預覽 
web.preview.reload.mode.disabled=已停用
web.preview.reload.mode.on.change=更改時
web.preview.reload.mode.on.save=儲存時
welcome.expUi.promo.button=啟用新 UI
welcome.expUi.promo.description={0} 採用了新的現代設計 — 降低了視覺複雜性，減少了干擾，並具有相同的功能
welcome.expUi.promo.header=認識新 UI
welcome.screen.action.docs.how.tos.action.text=文檔和指南
welcome.screen.all.settings.link=所有設定…
welcome.screen.check.for.updates.comment=更新。
welcome.screen.color.theme.header=顏色方案
welcome.screen.configure.action.text=組態
welcome.screen.copy.about.action.text=複製有關資訊
welcome.screen.customize.title=自訂
welcome.screen.drop.files.to.open.text=將檔案拖放到此處以開啟
welcome.screen.empty.projects.create.comment= 從頭建立新項目。
welcome.screen.empty.projects.open.comment=從磁碟或版本控制中開啟現有專案。
welcome.screen.ide.font.size.label=IDE 字體:
welcome.screen.learnIde.help.and.resources.text=幫助和資源
welcome.screen.learnIde.interactive.courses.text=互動課程
welcome.screen.learnIde.title=學習
welcome.screen.logo.version.label=版本 {0}
welcome.screen.more.actions.link.text=更多動作
welcome.screen.plugins.title=延伸模組
welcome.screen.projects.title=專案
welcome.screen.quick.start.action.text=快速開始
welcome.screen.search.projects.empty.text=搜尋專案
whats.new.action.custom.description=了解此版本的 {0} 中的新功能
whats.new.action.custom.text={0} 最新變化(_N)
whats.new.notification.action=檢視最新變化
whats.new.notification.text={0} {1} 登場!
whats.new.timeout.action=您可以<a href="{0}" class="link" target="_blank">在瀏覽器中開啟此頁面</a>或稍後重試。
whats.new.timeout.message=無法載入該頁面的內容。請檢查您的互聯網連線。
whats.new.timeout.title=無法載入頁面
window.title.switcher=切換器
windows.native.common.dialog.open=開啟
windows.native.common.dialog.select.folder=選擇目錄
wrong.http.range.response=HTTP 範圍響應的行過長 {0}
wrong.number.of.arguments.usage.ide.executable.exit=實參數量錯誤。用法: <ide executable> exit [--restart]
wrong.number.of.arguments.usage.ide.executable.save=實參數量錯誤。用法: <ide 可執行檔案> 儲存
wsl.cant.parse.ip.no.output=無法解析 {0}，因為輸出未包含足夠的資料。請參閱 idea.log 了解特定錯誤。
wsl.cant.parse.ip.process.failed=由於程序失敗，無法解析 {0}。請參閱 idea.log 了解特定錯誤。
wsl.enter.root.password.dialog.title=輸入根密碼
wsl.error.host.ip.not.obtained.message=無法獲取 WSL 分發的主機 IP: {0}
wsl.executing.process=正在執行 WSL 程序
wsl.linux.distribution.label=Linux 分發版(&D):
wsl.no.distribution.found.error=WSL: 應設定 Linux 分發版
wsl.no.installed.distributions=沒有安裝分發版
wsl.no.rsync=請在您的 {0} WSL 上安裝 rsync
wsl.no_path=找不到此分發版特定於 Windows 的部分，無法瀏覽
wsl.not.installed.dialog.message=在 %PATH% 中找不到 wsl.exe，請安裝 WSL
wsl.not.installed.distribution=未安裝 {0}
wsl.opening_wsl=正在開啟 WSL…
wsl.rsync.unable.to.copy.files.dialog.message=無法將檔案複製到 {0}
wsl.rsync.unable.to.create.target.dir.message=無法建立目標目錄 {0}
wsl.sudo.password.for.root.label={0} 根的 Sudo 密碼:
wsl.target.introspection.step.command.finished.with.exit.code=程序已結束，退出程式碼為 {0}
wsl.target.introspection.step.completed.successfully=內省成功完成!
wsl.target.introspection.step.completed.with.errors=內省完成但有錯誤。
wsl.target.introspection.step.description=WSL 分發版內省
wsl.target.language.step.description=用於 {1} 的 {0} 執行時組態
wsl.target.tool.step.description=WSL 組態
wsl.win.ip=主機 (Windows) IP
wsl.wsl.ip=WSL (Linux) IP
x.and.y={0} 和 {1}"
`;

exports[`src messages/InspectionGadgetsBundle.properties 1`] = `
"0.will.no.longer.be.overridable.by.1={0} 將不再可被 {1} 覆寫
absolute.alignment.in.user.interface.display.name=AWT/Swing 程式碼中的絕對對齊
absolute.alignment.in.user.interface.fix.family.name=取代為常數
absolute.alignment.in.user.interface.problem.descriptor=使用了絕對對齊常數 <code>{0}.#ref</code> #loc
abstract.class.extends.concrete.class.display.name=抽象類別擴展具體類別
abstract.class.extends.concrete.class.problem.descriptor=類別 <code>#ref</code> 被宣告為 'abstract'，並擴展一個具體類別 #loc
abstract.class.naming.convention.element.description=抽象類別
abstract.class.never.implemented.display.name=沒有具體子類別的抽象類別
abstract.class.never.implemented.problem.descriptor=抽象類別 <code>#ref</code> 沒有具體子類別 #loc
abstract.class.with.only.one.direct.inheritor.display.name=只有一個直接繼承者的抽象類別
abstract.class.with.only.one.direct.inheritor.problem.descriptor=只有一個直接繼承者的抽象類別 <code>#ref</code> #loc
abstract.class.without.abstract.methods.display.name=沒有 'abstract' 方法的抽象類別
abstract.class.without.abstract.methods.ignore.utility.class.option=忽略實用程序類別
abstract.class.without.abstract.methods.problem.descriptor=類別 <code>#ref</code> 被宣告為 'abstract'，並且沒有 'abstract' 方法 #loc
abstract.method.call.in.constructor.display.name=物件建構期間呼叫的 abstract 方法
abstract.method.call.in.constructor.problem.descriptor=物件建構期間呼叫 'abstract' 方法 <code>#ref()</code> #loc
abstract.method.overrides.abstract.method.display.name=abstract 方法覆寫 abstract 方法
abstract.method.overrides.abstract.method.ignore.different.javadoc.option=忽略 Javadoc 與其 super 方法不同的方法
abstract.method.overrides.abstract.method.problem.descriptor=abstract 方法 <code>#ref()</code> 覆寫 abstract 方法 #loc
abstract.method.overrides.abstract.method.remove.quickfix=移除冗餘 abstract 方法宣告
abstract.method.overrides.concrete.method.display.name=abstract 方法覆寫具體方法
abstract.method.overrides.concrete.method.problem.descriptor=abstract 方法 <code>#ref()</code> 覆寫具體方法 #loc
abstract.method.with.missing.implementations.display.name=缺少實作的 abstract 方法
abstract.method.with.missing.implementations.problem.descriptor=abstract 方法 <code>#ref()</code> 未在每個子類別中實作 #loc
access.to.non.thread.safe.static.field.from.instance.class.chooser.title=選擇非執行緒安全類別
access.to.non.thread.safe.static.field.from.instance.display.name=非執行緒安全的 'static' 欄位存取
access.to.non.thread.safe.static.field.from.instance.field.problem.descriptor=存取類型為 ''{0}'' 的非執行緒安全 static 欄位 <code>#ref</code> #loc
access.to.non.thread.safe.static.field.from.instance.option.title=非執行緒安全類別:
access.to.static.field.locked.on.instance.display.name=存取實例資料上鎖定的 'static' 欄位
access.to.static.field.locked.on.instance.fix.name=忽略類型 ''{0}'' 的 static 欄位
access.to.static.field.locked.on.instance.problem.descriptor=存取實例資料上鎖定的 static 欄位 <code>#ref</code> #loc
accessing.non.public.field.of.another.object.display.name=存取另一個物件的非 public 欄位
accessing.non.public.field.of.another.object.problem.descriptor=直接存取另一個物件的非 public 欄位 <code>#ref</code> #loc
add.0.to.ignore.if.annotated.by.list.quickfix=將 ''{0}'' 新增到“由以下物件註解時忽略”列表中
add.catch.section.fix.family.name=新增 'catch' 子句
add.read.write.object.methods.fix.family.name=新增始終拋出異常的 'readObject()' 和 'writeObject()' 方法
add.read.write.object.methods.fix.text=新增始終拋出異常的 'writeObject()' 方法
add.read.write.object.methods.fix.text2=新增始終拋出異常的 'readObject()' 方法
add.serialversionuidfield.quickfix=新增 'serialVersionUID' 欄位
add.this.qualifier.quickfix=新增 'this' 限定符
add.throws.clause.fix.family.name=修復 'throws' 子句
all.levels.option=所有日誌級別
allow.resource.to.be.opened.inside.a.try.block=允許在 'try' 塊內開啟資源
allow.suppressions.fix.family.name=允許禁止
allow.suppressions.fix.text=允許這些禁止
allow.suppressions.preview.text=檢查 ID 將被新增到設定中的允許禁止列表中
ambiguous.field.access.display.name=對繼承欄位的存取類似於對周圍程式碼中元素的存取
ambiguous.field.access.hides.field.problem.descriptor=存取超類別 ''{0}'' 中的 <code>#ref</code> 欄位類似於存取周圍類別中的欄位 #loc
ambiguous.field.access.hides.local.variable.problem.descriptor=存取超類別 ''{0}'' 中的 <code>#ref</code> 欄位類似於存取區域變數 #loc
ambiguous.field.access.hides.parameter.problem.descriptor=存取超類別 ''{0}'' 中的 <code>#ref</code> 欄位類似於存取參數 #loc
ambiguous.field.access.navigate.quickfix=導覽到明顯存取過的{0, choice, 1#區域變數|2#參數|3#欄位}
ambiguous.field.access.quickfix=將 'super' 限定符新增到欄位存取
ambiguous.method.call.display.name=對繼承方法的呼叫類似於對本地方法的呼叫
ambiguous.method.call.problem.descriptor=對來自超類別 ''{0}'' 的方法 <code>#ref()</code> 的呼叫類似於對來自類別 ''{1}'' 的方法的呼叫 #loc
ambiguous.method.call.quickfix=向方法呼叫中新增 'super' 限定符
annotation.class.display.name=註解接口
annotation.class.problem.descriptor=註解接口 <code>#ref</code> #loc
annotation.display.name=註解
annotation.naming.convention.element.description=註解接口
annotation.problem.descriptor=註解 <code>#ref</code> #loc
anonymous.class.field.hides.containing.method.variable.problem.descriptor=匿名類別欄位 <code>#ref</code> 隱藏包含方法中的變數 #loc
anonymous.class.parameter.hides.containing.method.variable.problem.descriptor=匿名類別參數 <code>#ref</code> 隱藏包含方法中的變數 #loc
anonymous.class.variable.hides.containing.method.variable.display.name=匿名類別變數隱藏包含方法中的變數
anonymous.class.variable.hides.containing.method.variable.problem.descriptor=匿名類別區域變數 <code>#ref</code> 隱藏包含方法中的變數 #loc
anonymous.extends.concrete.collection.problem.descriptor=匿名類別顯式擴展 ''{0}'' #loc
anonymous.extends.thread.problem.descriptor=匿名類別直接擴展 'java.lang.Thread' #loc
anonymous.extends.throwable.problem.descriptor=匿名類別直接擴展 'java.lang.Throwable' #loc
anonymous.inner.class.display.name=匿名內部類別可被取代為內部類別
anonymous.inner.class.problem.descriptor=匿名內部類別 <code>#ref</code> #loc
anonymous.inner.class.with.too.many.methods.display.name=具有太多方法的匿名內部類別
anonymous.inner.class.with.too.many.methods.problem.descriptor=具有太多方法的匿名內部類別 (方法計數 = {0}) #loc
anonymous.inner.may.be.named.static.inner.class.display.name=匿名類別可能是命名為 'static' 的內部類別
anonymous.inner.may.be.named.static.inner.class.problem.descriptor=匿名類別 <code>#ref</code> 可能是命名為 'static' 的內部類別 #loc
anonymous.inner.may.be.named.static.inner.class.quickfix=轉換為命名 'static' 內部類別
any.method.may.close.resource.argument=任何方法都可能關閉作為實參傳遞的資源
array.allocation.zero.length.display.name=零長度陣列分配
array.allocation.zero.length.problem.descriptor=零長度陣列的分配 #loc
array.can.be.replaced.with.enum.values = 可以將陣列取代為枚舉值
array.can.be.replaced.with.enum.values.family.quickfix = 將陣列取代為 EnumType.values()
array.can.be.replaced.with.enum.values.quickfix = 將陣列取代為 {0}.values()
array.comparison.display.name=使用 '==' 而不是 'Arrays.equals()' 進行陣列比較
array.comparison.problem.descriptor=使用 <code>#ref</code> 而不是 'Arrays.equals()' 來比較陣列物件 #loc
array.creation.without.new.keyword.family.quickfix=新增 'new' 表達式
array.creation.without.new.keyword.name=建立不帶 'new' 表達式的陣列
array.creation.without.new.keyword.quickfix=新增 ''new {0}''
array.equals.problem.descriptor=或許應當使用 ''{0}'' 完成陣列比較''
array.hash.code.display.name=在陣列上呼叫了 'hashCode()'
array.hash.code.fix.family.name=取代為 'Arrays.hashCode()' 呼叫
array.hash.code.problem.descriptor=陣列上呼叫的 <code>#ref()</code> 可能應當是 'Arrays.hashCode()' #loc
array.hashcode.problem.descriptor=或許應當使用 ''{0}'' 完成陣列雜湊程式碼計算
array.length.in.loop.condition.display.name=迴圈條件下的 Array.length
array.length.in.loop.condition.problem.descriptor=檢查迴圈條件下的陣列 <code>#ref</code> #loc
array.objects.equals.display.name=對陣列使用淺層方法或 'Objects' 方法
arrays.as.list.with.one.argument.problem.descriptor=僅使用一個實參呼叫 <code>#ref()</code> #loc
arrays.as.list.with.zero.arguments.problem.descriptor=呼叫 <code>#ref()</code> 以建立空列表 #loc
arrays.as.list.with.zero.or.one.argument.display.name='Arrays.asList()' 呼叫的實參過少
assert.can.be.if.quickfix=將 'assert' 取代為 'if' 語句
assert.keyword.is.considered.an.assertion='assert' 關鍵字被視為斷言
assert.message.not.string.display.name='assert' 訊息不是字串
assert.message.not.string.only.warn.boolean.option=僅當 'assert' 訊息為 'boolean' 或 'java.lang.Boolean' 時發出警告
assert.message.of.type.boolean.problem.descriptor=類型為 ''{0}'' 的 ''assert'' 訊息 #loc
assert.statement.display.name='assert' 語句
assert.with.side.effects.call.mutates.expression=呼叫 ''{0}()'' 會改變 ''{1}''
assert.with.side.effects.call.mutates.field=呼叫 ''{0}()'' 會改變欄位 ''{1}''
assert.with.side.effects.display.name=具有副作用的 'assert' 語句
assert.with.side.effects.problem.descriptor=<code>#ref</code> 具有副作用: {0} #loc
assert.without.message.problem.descriptor=沒有訊息的 <code>#ref()</code> #loc
assert.without.message.quick.fix.family.name=新增錯誤訊息
assertion.can.be.if.name=斷言可被取代為 'if' 語句
asserts.without.messages.display.name=斷言上缺少訊息
assignment.of.field.with.mutable.type.problem.descriptor=賦值給參數 <code>#ref</code> 中的 {0} 欄位 ''{1}'' #loc
assignment.or.return.of.field.with.mutable.type.display.name=具有可變類型的欄位的賦值或返回
assignment.replaceable.with.operator.assignment.display.name=賦值可被取代為運算符賦值
assignment.replaceable.with.operator.assignment.ignore.conditional.operators.option=忽略條件運算符
assignment.replaceable.with.operator.assignment.ignore.obscure.operators.option=忽略模糊的 ^ 和 % 運算符
assignment.replaceable.with.operator.assignment.problem.descriptor=<code>#ref</code> 可以簡化為 ''{0}'' #loc
assignment.to.catch.block.parameter.display.name=賦值給 'catch' 塊參數
assignment.to.catch.block.parameter.problem.descriptor=賦值給 'catch' 塊參數 <code>#ref</code> #loc
assignment.to.for.loop.parameter.check.foreach.option=檢查增強型 'for' 迴圈參數
assignment.to.for.loop.parameter.display.name=賦值給 'for' 迴圈參數
assignment.to.for.loop.parameter.problem.descriptor=賦值給 for 迴圈參數 <code>#ref</code> #loc
assignment.to.lambda.parameter.display.name=賦值給 lambda 參數
assignment.to.lambda.parameter.problem.descriptor=賦值給 lambda 參數 <code>#ref</code> #loc
assignment.to.method.parameter.display.name=賦值給方法參數
assignment.to.method.parameter.ignore.transformation.option=<html>如果賦值是原始參數的轉換，則忽略</html>
assignment.to.method.parameter.problem.descriptor=賦值給方法參數 <code>#ref</code> #loc
assignment.to.null.display.name='null' 賦值
assignment.to.null.option=忽略對欄位的賦值
assignment.to.null.problem.descriptor='null' 已賦值給變數 <code>#ref</code> #loc
assignment.to.static.field.from.instance.method.display.name=從實例上下文賦值給 static 欄位
assignment.to.static.field.from.instance.method.problem.descriptor=從實例上下文賦值給 static 欄位 <code>#ref</code> #loc
assignment.to.superclass.field.display.name=建構函式將值賦給在超類別中定義的欄位
assignment.to.superclass.field.problem.descriptor=賦值給在超類別 ''{1}'' 中定義的欄位 ''{0}'' #loc
assignment.used.as.condition.display.name=用作條件的賦值
assignment.used.as.condition.problem.descriptor=賦值 <code>#ref</code> 作為條件使用 #loc
atomic.field.updater.issues.display.name='AtomicFieldUpdater' 宣告不一致
atomic.field.updater.not.static.final.display.name='AtomicFieldUpdater' 欄位未被宣告為 'static final'
atomic.field.updater.not.static.final.problem.descriptor={0} 欄位 <code>#ref</code> 未被宣告為 ''static final'' #loc
auto.boxing.display.name=自動裝箱
auto.boxing.ignore.added.to.collection.option=忽略新增到集合的表達式
auto.boxing.make.boxing.explicit.quickfix=使裝箱顯式
auto.boxing.problem.descriptor=自動裝箱 <code>#ref</code> #loc
auto.closeable.resource.display.name=在沒有 'try-with-resources' 的情況下使用 AutoCloseable
auto.closeable.resource.problem.descriptor=在沒有 ''try-with-resources'' 語句的情況下使用 ''{0}'' #loc
auto.closeable.resource.quickfix=忽略此方法返回的 'AutoCloseable'
auto.closeable.resource.returned.option=忽略從所有方法呼叫返回的 AutoCloseable 實例
auto.unboxing.display.name=自動拆箱
auto.unboxing.make.unboxing.explicit.quickfix=使拆箱顯式
auto.unboxing.problem.descriptor=自動拆箱 <code>#ref</code> #loc
await.not.in.loop.display.name=未在迴圈中呼叫的 'await()'
await.not.in.loop.problem.descriptor=<code>#ref()</code> 呼叫不在迴圈中 #loc
await.without.corresponding.signal.display.name=沒有相應 'signal()' 的 'await()'
await.without.corresponding.signal.problem.descriptor=在沒有相應 <code>signal()</code> 或 <code>signalAll()</code> 的情況下呼叫 <code>#ref()</code> #loc
bad.exception.caught.display.name=已捕獲禁止的 'Exception'
bad.exception.caught.problem.descriptor=已捕獲禁止異常 <code>#ref</code> #loc
bad.exception.declared.display.name=已宣告禁止異常
bad.exception.declared.problem.descriptor=已宣告禁止異常 <code>#ref</code> #loc
bad.exception.thrown.display.name=已拋出禁止異常
bad.exception.thrown.problem.descriptor=已拋出禁止異常 ''{0}'' #loc
bad.oddness.display.name=可疑的奇數檢查
bad.oddness.problem.descriptor=對負值進行奇數檢查將會失敗 #loc
big.decimal.equals.display.name=在 'BigDecimal' 上調用了 'equals()'
big.decimal.equals.problem.descriptor=BigDecimal 值之間的 <code>#ref()</code> 可能應當是 'compareTo()' #loc
big.decimal.method.without.rounding.called.display.name='BigDecimal' 方法呼叫沒有舍入模式實參
big.decimal.method.without.rounding.called.problem.descriptor=在沒有舍入模式實參的情況下呼叫了 'BigDecimal.#ref()'
bigdecimal.legacy.method.display.name=呼叫了 'BigDecimal' 遺留方法
bigdecimal.legacy.method.problem.descriptor=對 'BigDecimal.#ref()' 的呼叫可以使用 'RoundingMode' 枚舉常數
bigdecimal.legacy.method.quickfix=使用 'RoundingMode' 枚舉常數
boolean.constructor.display.name=布爾建構函式呼叫
boolean.constructor.problem.descriptor=布爾建構函式呼叫 #loc
boolean.constructor.simplify.quickfix=簡化
boolean.expression.can.be.simplified.problem.descriptor=<code>#ref</code> 可以簡化為 ''{0}'' #loc
boolean.expression.does.not.modify.problem.descriptor=<code>#ref</code> 未修改 ''{0}'' 的值 #loc
boolean.expression.may.be.conditional.display.name=布爾表達式可被取代為條件表達式
boolean.expression.remove.compound.assignment.quickfix=移除無意義的複合賦值
boolean.field.always.inverted.problem.descriptor=布爾欄位 <code>#ref</code> 始終反轉 #loc
boolean.method.name.must.start.with.question.display.name=布爾方法名稱必須以疑問詞開頭
boolean.method.name.must.start.with.question.problem.descriptor=布爾方法名稱 <code>#ref</code> 未以疑問詞開頭 #loc
boolean.method.name.must.start.with.question.table.label=布爾方法名稱前綴:
boolean.parameter.constructor.problem.descriptor='public' 建構函式 <code>#ref()</code> 具有 'boolean' 參數 #loc
boolean.parameter.display.name='public' 方法具有 'boolean' 參數
boolean.parameter.only.report.multiple.option=僅報告具有多個布爾參數的方法
boolean.parameter.problem.descriptor='public' 方法 <code>#ref()</code> 具有 'boolean' 參數 #loc
boolean.parameters.constructor.problem.descriptor='public' 建構函式 <code>#ref()</code> 具有 'boolean' 參數 #loc
boolean.parameters.problem.descriptor='public' 方法 <code>#ref()</code> 具有 'boolean' 參數 #loc
boolean.variable.always.inverted.display.name=布爾變數始終反轉
boolean.variable.always.inverted.problem.descriptor=布爾變數 <code>#ref</code> 始終反轉 #loc
bounded.wildcard.contravariant.descriptor=可以泛化為 <code>? super #ref</code> #loc
bounded.wildcard.covariant.descriptor=可以泛化為 <code>? extends #ref</code> #loc
bounded.wildcard.display.name=可以使用有界萬用字元
bounded.wildcard.report.instance.option=報告實例方法
bounded.wildcard.report.invariant.option=報告固定類別
bounded.wildcard.report.private.option=報告 private 方法
boxing.boxed.value.display.name=裝箱已裝箱的值
boxing.boxed.value.problem.descriptor=裝箱已裝箱的 <code>#ref</code> #loc
boxing.boxed.value.quickfix=移除不必要的裝箱
break.statement.display.name='break' 語句
break.statement.with.label.display.name=帶標籤的 'break' 語句
break.statement.with.label.problem.descriptor=帶標籤的 <code>#ref</code> 語句 #loc
busy.wait.display.name=忙等待
busy.wait.problem.descriptor=在迴圈中呼叫 <code>Thread.#ref()</code>，可能處於忙等待 #loc
c.style.array.declaration.display.name=C 樣式陣列宣告
c.style.array.declaration.replace.quickfix=取代為 Java 樣式陣列宣告
cached.number.constructor.call.display.name=數字建構函式呼叫具有基元實參
cached.number.constructor.call.ignore.string.arguments.option=忽略具有字串實參的新數字表達式
cached.number.constructor.call.problem.descriptor=數字建構函式呼叫具有基元實參 #loc
cached.number.constructor.call.report.only.deprecated=僅在建構函式為 @Deprecated 時報告
call.to.date.tostring.display.name=呼叫 'Date.toString()'
call.to.date.tostring.problem.descriptor=國際化上下文中使用的 <code>Date.#ref()</code> #loc
call.to.native.method.while.locked.display.name=鎖定時呼叫 'native' 方法
call.to.native.method.while.locked.problem.descriptor=在同步上下文中呼叫本地方法 <code>#ref()</code> #loc
call.to.numeric.tostring.display.name=呼叫 'Number.toString()'
call.to.numeric.tostring.problem.descriptor=國際化上下文中呼叫的 <code>Number.#ref()</code> #loc
call.to.private.setter.in.class.option=僅在 setter 為 'private' 時報告
call.to.private.simple.getter.in.class.option=僅在 getter 為 'private' 時報告
call.to.simple.getter.in.class.display.name=從類別內呼叫簡單 getter
call.to.simple.getter.in.class.ignore.option=忽略其他物件上的 getter 呼叫
call.to.simple.getter.in.class.inline.quickfix=內聯呼叫 getter
call.to.simple.getter.in.class.problem.descriptor=從類別內呼叫簡單 getter <code>#ref()</code> #loc
call.to.simple.setter.in.class.display.name=從類別內呼叫簡單 setter
call.to.simple.setter.in.class.ignore.option=忽略其他物件上的 setter 呼叫
call.to.simple.setter.in.class.inline.quickfix=內聯呼叫 setter
call.to.simple.setter.in.class.problem.descriptor=從類別內呼叫簡單 setter <code>#ref()</code> #loc
call.to.string.concat.can.be.replaced.by.operator.display.name=對 'String.concat()' 的呼叫可被取代為 '+'
call.to.string.concat.can.be.replaced.by.operator.problem.descriptor=對 <code>#ref()</code> 的呼叫可被取代為 '+' 表達式 #loc
call.to.string.concat.can.be.replaced.by.operator.quickfix=用 '+' 取代 'concat()'
call.to.suspicious.string.method.display.name=呼叫可疑的 'String' 方法
call.to.suspicious.string.method.problem.descriptor=國際化上下文中呼叫的 <code>String.#ref()</code> #loc
cast.conflicts.with.instanceof.display.name=轉換與 'instanceof' 衝突
cast.conflicts.with.instanceof.problem.descriptor=轉換為 ''{0}'' 類型將與前面的 ''instanceof {1}'' 檢查衝突
cast.conflicts.with.instanceof.quickfix1=在轉換中將 ''{0}'' 取代為 ''{1}''
cast.conflicts.with.instanceof.quickfix2=在 instanceof 中將 ''{0}'' 取代為 ''{1}''
cast.that.loses.precision.display.name=損失精度的數字轉換
cast.that.loses.precision.negative.problem.descriptor=''{0}'' 到 <code>#ref</code> 的轉換可能導致負實參的精度損失 #loc
cast.that.loses.precision.option=忽略從 int 到 char 的轉換
cast.that.loses.precision.problem.descriptor=''{0}'' 到 <code>#ref</code> 的轉換可能導致精度損失 #loc
cast.to.concrete.class.problem.descriptor=轉換為具體類別 <code>{0}</code> #loc
casting.to.incompatible.interface.display.name=轉換為不相容的接口
casting.to.incompatible.interface.problem.descriptor=轉換為不相容的接口 <code>#ref</code> #loc
caught.exception.immediately.rethrown.display.name=捕獲的異常被立即重新拋出
caught.exception.immediately.rethrown.problem.descriptor=捕獲的異常 <code>#ref</code> 被立即重新拋出 #loc
chain.of.class.equality.checks.problem.descriptor=類別相等檢查鏈指示抽象失敗 #loc
chain.of.instanceof.checks.display.name='instanceof' 檢查鏈
chain.of.instanceof.checks.problem.descriptor='instanceof' 檢查鏈指示抽象失敗 #loc
chained.equality.comparisons.display.name=鏈式相等比較
chained.equality.comparisons.problem.descriptor=鏈式相等比較 <code>#ref</code> #loc
chained.method.call.display.name=鏈式方法呼叫
chained.method.call.ignore.option=忽略欄位初始設定式中的鏈式方法呼叫
chained.method.call.ignore.self.types.option=忽略對返回類型與其封閉類別相同的方法的呼叫
chained.method.call.problem.descriptor=鏈式方法呼叫 <code>#ref()</code> #loc
change.modifier.fix.family.name=更改修飾符
change.modifier.package.private.quickfix=設為 package-private
change.modifier.quickfix=設為 ''{0}''
channel.opened.not.closed.display.name=開啟了 'Channel'，但未安全關閉
char.used.in.arithmetic.content.cast.fix.family.name=插入轉換
char.used.in.arithmetic.context.cast.quickfix=插入到 {0} 的轉換
char.used.in.arithmetic.context.display.name=在算術上下文中使用 'char' 表達式
char.used.in.arithmetic.context.problem.descriptor=算術上下文中使用了 'char' #loc
char.used.in.arithmetic.context.quickfix=轉換為字串文字
character.comparison.display.name=字元比較
character.comparison.problem.descriptor=國際化上下文中的字元比較 <code>#ref</code> #loc
checkbox.ignore.null.on.wrong.side=忽略錯誤側的 'null'
checked.exception.class.display.name=已檢查的異常類別
checked.exception.class.problem.descriptor=已檢查的異常類別 <code>#ref</code> #loc
choose.autocloseable.type.to.ignore.title=選擇要忽略的 AutoCloseable 資源類型
choose.class=選擇類別
choose.class.hierarchy.to.ignore.title=選擇要忽略的類別層次結構
choose.class.type.to.ignore=選擇要忽略的類別
choose.exception.class=選擇異常類別
choose.exception.label=被禁止的異常:
choose.io.resource.type.to.ignore=選擇要忽略的 I/O 資源類型
choose.logger.class=選擇記錄器類別
class.escapes.defined.scope.display.module.option=Report non-exported classes exposed in module API (Java 9+)
class.escapes.defined.scope.display.name=Class is exposed outside of its visibility scope
class.escapes.defined.scope.display.package.option=Report private classes exposed in package-local API
class.escapes.defined.scope.display.public.option=Report non-accessible classes exposed in public API
class.escapes.defined.scope.java9.modules.descriptor=類別 <code>#ref</code> 未從模組 ''{0}'' 匯出
class.escapes.defined.scope.problem.descriptor=Class <code>#ref</code> is exposed outside its defined visibility scope #loc
class.extends.utility.class.display.name=類別擴展實用程序類別
class.extends.utility.class.ignore.utility.class.option=如果覆寫類別為實用程序類別，則忽略
class.extends.utility.class.problem.descriptor=類別 <code>#ref</code> 擴展實用程序類別 ''{0}'' #loc
class.independent.of.module.display.name=獨立於其模組的類別
class.independent.of.module.problem.descriptor=類別 <code>#ref</code> 在其模組中沒有相依或相依項 #loc
class.initializer.display.name=非 'static' 初始設定式
class.initializer.may.be.static.display.name=類別初始設定式可能為 'static'
class.initializer.may.be.static.problem.descriptor=類別初始設定式可能為 'static' #loc
class.initializer.move.code.to.constructor.quickfix=將初始設定式程式碼移至建構函式
class.initializer.option=僅在類別具有一個或多個建構函式時警告
class.initializer.problem.descriptor=非 'static' 初始設定式 #loc
class.loader.instantiation.display.name='ClassLoader' 實例化
class.loader.instantiation.problem.descriptor=實例化 <code>#ref</code> 可能造成安全問題 #loc
class.may.be.interface.convert.quickfix=將類別轉換為接口
class.may.be.interface.display.name='abstract' 類別可以是 'interface'
class.may.be.interface.java8.option=使用 Java 8 時報告包含非 abstract 方法的類別
class.may.be.interface.problem.descriptor=抽象類別 <code>#ref</code> 可能是接口 #loc
class.name=類別名
class.name.differs.from.file.name.display.name=類別名與檔名不同
class.name.differs.from.file.name.problem.descriptor=類別名 <code>#ref</code> 與檔名不同 #loc
class.name.prefixed.with.package.name.display.name=使用軟體套件名稱作為前綴的類別名
class.name.prefixed.with.package.name.problem.descriptor=類別名 <code>#ref</code> 以其軟體套件名稱開始 #loc
class.name.same.as.ancestor.name.display.name=類別名與上級名稱相同
class.name.same.as.ancestor.name.problem.descriptor=類別名 <code>#ref</code> 與其超類別的名稱之一相同 #loc
class.naming.convention.display.name=類別命名約定
class.naming.convention.element.description=類別
class.new.instance.display.name=對 'Class.newInstance()' 的呼叫不安全
class.new.instance.problem.descriptor=對 <code>#ref()</code> 的呼叫可能會拋出未宣告的已檢查的異常 #loc
class.only.used.in.one.module.display.name=僅在其他模組中使用的類別
class.only.used.in.one.module.problem.descriptor=類別 <code>#ref</code> 在其模組 ''{0}'' 中只有相依和/或相依性 #loc
class.only.used.in.one.package.display.name=僅在其他軟體套件中使用的類別
class.only.used.in.one.package.problem.descriptor=類別 <code>#ref</code> 在其軟體套件 ''{0}'' 中只有相依和/或相依項 #loc
class.references.subclass.display.name=類別參照其子類別之一
class.references.subclass.problem.descriptor=類別 ''{0}'' 參照子類別 <code>#ref</code> #loc
class.references.subclass.problem.descriptor.anonymous=匿名類別參照子類別 <code>#ref</code> #loc
class.too.deep.display.name=類別在繼承樹中太深
class.too.deep.inheritance.depth.limit.option=繼承深度限制:
class.too.deep.problem.descriptor=<code>#ref</code> 在繼承樹中太深 (繼承深度 = {0}) #loc
class.unconnected.to.package.display.name=獨立於其軟體套件的類別
class.unconnected.to.package.problem.descriptor=類別 <code>#ref</code> 在其軟體套件中沒有相依或相依項
class.with.only.private.constructors.display.name=僅包含 'private' 建構函式的類別應被宣告為 'final'
class.with.only.private.constructors.problem.descriptor=僅包含 'private' 建構函式的類別 <code>#ref</code> 應被宣告為 'final'
class.with.too.many.dependencies.display.name=相依過多的類別
class.with.too.many.dependencies.max.option=最大相依項數
class.with.too.many.dependencies.problem.descriptor=類別 ''{0}'' 的相依過多 ({1} > {2})
class.with.too.many.dependents.display.name=相依項過多的類別
class.with.too.many.dependents.max.option=最大相依項數
class.with.too.many.dependents.problem.descriptor=類別 ''{0}'' 的相依項過多 ({1} > {2})
class.with.too.many.transitive.dependencies.display.name=可傳遞相依項過多的類別
class.with.too.many.transitive.dependencies.max.option=最大可傳遞相依項數
class.with.too.many.transitive.dependencies.problem.descriptor=類別 ''{0}'' 的可傳遞相依項過多({1} > {2})
class.with.too.many.transitive.dependents.display.name=傳遞相依項過多的類別
class.with.too.many.transitive.dependents.max.option=最大傳遞相依項數
class.with.too.many.transitive.dependents.problem.descriptor=類別 ''{0}'' 的可傳遞相依項過多({1} > {2})
class.without.constructor.create.quickfix=生成空建構函式
class.without.constructor.display.name=不帶建構函式的類別
class.without.constructor.problem.descriptor=類別 <code>#ref</code> 沒有建構函式 #loc
class.without.logger.annotations.tab=註解
class.without.logger.loggers.tab=記錄器
class.without.no.arg.constructor.display.name=沒有無實參建構函式的類別
class.without.no.arg.constructor.ignore.option=如果類別具有預設建構函式，則忽略
class.without.no.arg.constructor.problem.descriptor=類別 <code>#ref</code> 缺少無實參建構函式 #loc
clone.doesnt.declare.clonenotsupportedexception.declare.quickfix=將 'CloneNotSupportedException' 新增到 throws 子句
clone.doesnt.declare.clonenotsupportedexception.display.name='clone()' 未宣告 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.problem.descriptor=<code>#ref()</code> #loc 未宣告 'CloneNotSupportedException'
clone.instantiates.new.array.problem.descriptor=''clone()'' 建立新的 {0} 陣列 #loc
clone.instantiates.objects.with.constructor.display.name='clone()' 用建構函式實例化物件
clone.instantiates.objects.with.constructor.problem.descriptor='clone()' 建立新的 <code>#ref</code> 實例 #loc
clone.method.in.non.cloneable.anonymous.class.problem.descriptor=<code>#ref()</code> 在派生自 ''{0}'' 的不可克隆匿名類別中定義 #loc
clone.method.in.non.cloneable.class.display.name=不可克隆類別中的 'clone()' 方法
clone.method.in.non.cloneable.class.problem.descriptor=<code>#ref()</code> 在不可克隆類別 ''{0}'' 中定義 #loc
clone.method.in.non.cloneable.interface.problem.descriptor=<code>#ref()</code> 在不可克隆接口 ''{0}'' 中定義 #loc
clone.returns.class.type.display.name='clone()' 應當具有等於其所包含類別的返回值類型
clone.returns.class.type.family.quickfix=將返回值類型更改為類別類型
clone.returns.class.type.problem.descriptor=''clone()'' 應當具有返回值類型 ''{0}'' #loc
clone.returns.class.type.quickfix=將返回值類型更改為 ''{0}''
cloneable.class.in.secure.context.display.name=安全上下文中的可克隆類別
cloneable.class.in.secure.context.problem.descriptor=類別 <code>#ref</code> 可能被克隆，影響安全性 #loc
cloneable.class.in.secure.context.quickfix=生成始終拋出異常的 'clone()' 方法
cloneable.class.without.clone.display.name=沒有 'clone()' 方法的可克隆類別
cloneable.class.without.clone.ignore.option=忽略由於繼承而可克隆的類別
cloneable.class.without.clone.ignore.when.clone.called.option=如果呼叫超類別的 clone() 方法需要 Cloneable，則忽略
cloneable.class.without.clone.problem.descriptor=<code>#ref</code> 為 'Cloneable'，但未定義 'clone()' 方法 #loc
cloneable.class.without.clone.quickfix=生成 'clone()' 方法
cloneable.class.without.clone.todo.message=TODO: 複製此處的可變狀態，這樣此克隆就不能更改初始克隆的內部項
collection.added.to.self.display.name=集合已新增到自身
collection.added.to.self.problem.descriptor=在以自身作為實參的集合 <code>#ref</code> 上調用了 ''{0}()'' #loc
collection.declared.by.class.display.name=按類別 (而不是接口) 宣告的集合
collection.declared.by.class.ignore.locals.option=忽略區域變數
collection.declared.by.class.ignore.private.members.option=忽略 'private' 欄位和方法
collection.declared.by.class.problem.descriptor=<code>#ref</code> 的宣告可能應當被削弱為 ''{0}'' #loc
collections.field.access.replaceable.by.method.call.display.name=對空集合欄位的參照可被取代為方法呼叫
collections.field.access.replaceable.by.method.call.fix.family.name=將 Collections.EMPTY_* 取代為呼叫
collections.field.access.replaceable.by.method.call.problem.descriptor=<code>#ref</code> 可被取代為 ''Collections.{0}'' #loc
collections.must.have.initial.capacity.display.name=沒有初始容量的集合
collections.must.have.initial.capacity.problem.descriptor=沒有初始容量的 <code>new #ref()</code> #loc
commented.out.code.delete.quickfix=刪除註釋
commented.out.code.uncomment.quickfix=撤消程式碼註釋
comments.as.content.option=註釋計為內容
comparable.implemented.but.equals.not.overridden.display.name=已實作 'Comparable'，但 'equals()' 未被覆寫
comparable.implemented.but.equals.not.overridden.fix.add.note.name=新增 'ordering inconsistent with equals' JavaDoc 記錄
comparable.implemented.but.equals.not.overridden.fix.generate.equals.name=生成 'equals()' 方法
comparable.implemented.but.equals.not.overridden.problem.descriptor=類別 <code>#ref</code> 實作 'java.lang.Comparable'，但未覆寫 'equals()' #loc
comparator.not.serializable.display.name='Comparator' 類別未被宣告為 'Serializable'
comparator.not.serializable.problem.descriptor=比較器類別 <code>#ref</code> 未被宣告為可序列化 #loc
comparison.of.short.and.char.display.name=比較 'short' 和 'char' 值
comparison.of.short.and.char.problem.descriptor=short 和 char 值的相等比較 <code>#ref</code> #loc
comparison.to.nan.display.name=與 'Double.NaN' 或 'Float.NaN' 比較
comparison.to.nan.problem.descriptor1=與 <code>#ref</code> 的比較始終為 false #loc
comparison.to.nan.problem.descriptor2=與 <code>#ref</code> 的比較始終為 true #loc
concrete.class.method.parameter.problem.descriptor=具體類別 <code>#ref</code> 的參數 ''{0}'' #loc
concrete.class.use.display.name=具體類別的使用
condition.signal.display.name=呼叫 'signal()' 而不是 'signalAll()'
condition.signal.problem.descriptor=<code>#ref</code> 可能應當取代為 'signalAll()' #loc
conditional.can.be.pushed.inside.expression.display.name=可以將條件推送到分支表達式內部
conditional.can.be.pushed.inside.expression.option=在條件將僅作為方法呼叫的實參時忽略
conditional.can.be.pushed.inside.expression.problem.descriptor=條件表達式可以推送到分支內 #loc
conditional.can.be.pushed.inside.expression.quickfix=在分支內推送條件表達式
conditional.expression.display.name=條件表達式
conditional.expression.expression.context.option=忽略無法使用 if 語句的位置
conditional.expression.option=對簡單賦值和返回值忽略
conditional.expression.problem.descriptor=條件表達式 <code>#ref</code> #loc
conditional.expression.quickfix=取代為 'if' 語句
conditional.expression.with.identical.branches.collapse.quickfix=摺疊條件表達式
conditional.expression.with.identical.branches.display.name=具有相同分支的條件表達式
conditional.expression.with.identical.branches.problem.descriptor=具有相同分支的條件表達式 <code>#ref</code> #loc
confusing.else.option=當 'if' 語句之後沒有其他語句時報告
confusing.floating.point.literal.change.quickfix=更改為規範形式
confusing.floating.point.literal.display.name=引起混淆的浮點文字
confusing.floating.point.literal.option=在科學記數法中忽略浮點文字
confusing.floating.point.literal.problem.descriptor=引起混淆的浮點文字 <code>#ref</code> #loc
confusing.main.method.display.name=引起混淆的 'main()' 方法
confusing.main.method.problem.descriptor=方法 <code>#ref</code> 沒有簽名 'public static void main(String[])' #loc
confusing.octal.escape.sequence.display.name=引起混淆的八進制轉義序列
confusing.octal.escape.sequence.problem.descriptor=八進制轉義序列 <code>#ref</code> 後面緊跟數字 #loc
connection.opened.not.safely.closed.display.name=集合已開啟，但未安全關閉
consider.static.final.fields.constant.option=考慮 'static final' 欄位常數
constant.assert.condition.display.name='assert' 語句中的常數條件
constant.assert.condition.problem.descriptor=斷言條件 <code>#ref</code> 是常數 #loc
constant.conditional.expression.display.name=常數條件表達式
constant.conditional.expression.problem.descriptor=<code>#ref</code> 可以簡化為 ''{0}'' #loc
constant.conditional.expression.simplify.quickfix=簡化
constant.conditional.expression.simplify.quickfix.sideEffect=提取副作用並簡化
constant.declared.in.abstract.class.display.name=在 'abstract' 類別中宣告的常數
constant.declared.in.abstract.class.problem.descriptor=常數 <code>#ref</code> 在抽象類別中宣告 #loc
constant.declared.in.interface.display.name=在接口中宣告的常數
constant.declared.in.interface.problem.descriptor=常數 <code>#ref</code> 在接口中宣告 #loc
constant.for.zero.length.array.display.name=不必要的零長度陣列用法
constant.for.zero.length.array.problem.descriptor=零長度陣列可更改為常數 #loc
constant.for.zero.length.array.quickfix.family=取代為常數
constant.junit.assert.argument.display.name=常數斷言實參
constant.junit.assert.argument.problem.descriptor=實參 <code>#ref</code> 是常數 #loc
constant.math.call.display.name=對 'Math' 的常數呼叫
constant.math.call.problem.descriptor=對 <code>#ref()</code> 的常數呼叫可以簡化 #loc
constant.naming.convention.element.description=常數
constant.on.lhs.of.comparison.options.item.left=左
constant.on.lhs.of.comparison.options.item.right=右
constant.on.lhs.of.comparison.problem.descriptor=常數 <code>#ref</code> 位於比較的左側 #loc
constant.on.rhs.of.comparison.problem.descriptor=常數 <code>#ref</code> 位於比較的右側 #loc
constant.on.side.of.comparison.display.name=常數位於比較的錯誤一側
constant.value.variable.use.display.name=使用已知值為常數的變數
constant.value.variable.use.problem.descriptor=<code>#ref</code> 的值已知為常數 #loc
constant.with.mutable.field.naming.convention.element.description=具有可變類型的常數
constructor.visibility.option=忽略具有以下可見性的建構函式:
continue.or.break.from.finally.block.display.name='continue' 或 'break' 位於 'finally' 塊內
continue.or.break.from.finally.block.problem.descriptor=<code>#ref</code> 位於 'finally' 塊內 #loc
continue.statement.display.name='continue' 語句
continue.statement.with.label.display.name=帶標籤的 'continue' 語句
continue.statement.with.label.problem.descriptor=帶標籤的 <code>#ref</code> 語句 #loc
control.flow.statement.without.braces.add.quickfix=將大括號新增到語句
control.flow.statement.without.braces.display.name=不帶大括號的控制流語句
control.flow.statement.without.braces.message=將大括號新增到 ''{0}'' 語句
control.flow.statement.without.braces.problem.descriptor=不帶大括號的 <code>{0}</code> #loc
convert.double.unary.quickfix=取代為 ''{0}{1}''
convert.empty.anonymous.to.new.fix.family.name=移除 '{}'
convert.octal.literal.to.decimal.literal.quickfix=將八進制文字轉換為十進制文字
convert.octal.literals.to.decimal.literals.quickfix=將八進制文字轉換為十進制文字
convert.to.variable.arity.method.quickfix=轉換為 vararg 方法
copy.constructor.misses.field.display.name=複製缺少欄位的建構函式
copy.constructor.misses.field.problem.descriptor.1=複製未複製欄位 ''{0}'' 的建構函式
copy.constructor.misses.field.problem.descriptor.2=複製未複製欄位 ''{0}'' 和 ''{1}'' 的建構函式
copy.constructor.misses.field.problem.descriptor.3=複製未複製欄位 ''{0}''、''{1}'' 和 ''{2}'' 的建構函式
copy.constructor.misses.field.problem.descriptor.many=複製未複製 {0} 個欄位的建構函式
covariant.equals.display.name=協變 'equals()'
covariant.equals.problem.descriptor=<code>#ref()</code> 應當以 'Object' 作為其實參 #loc
create.default.branch.fix.family.name=插入 'default' 分支
create.missing.enum.switch.branches.fix.family.name=建立缺少的枚舉 switch 分支
create.missing.record.deconstructions.switch.branches.fix.family.name=建立缺失記錄解構 switch 分支
create.missing.sealed.class.switch.branches.fix.family.name=建立缺少的密封類別 switch 分支
create.missing.switch.branch=建立缺少的 switch 分支 ''{0}''
create.missing.switch.branches=建立缺少的分支: {0}
create.null.branch.fix.family.name=插入 'null' 分支
create.package.info.java.family.name=建立 'package-info.java'
cstyle.array.method.declaration.problem.descriptor=方法 <code>{0}()</code> 具有 C 樣式陣列返回類型宣告 #loc
cstyle.array.variable.declaration.problem.descriptor={0, choice, 1#欄位|2#參數|3#記錄組件|4#區域變數} <code>{1}</code> 具有 C 樣式陣列類型宣告 #loc
custom.classloader.display.name=宣告了自訂的 'ClassLoader'
custom.classloader.problem.descriptor=自訂 ClassLoader 類別 <code>#ref</code> #loc
custom.security.manager.display.name=自訂 'SecurityManager'
custom.security.manager.problem.descriptor=自訂 SecurityManager 類別 <code>#ref</code> #loc
cyclic.class.dependency.1.problem.descriptor=類別 ''{0}'' 迴圈依賴於類別 ''{1}''
cyclic.class.dependency.2.problem.descriptor=類別 ''{0}'' 迴圈依賴於類別 ''{1}'' 和 ''{2}''
cyclic.class.dependency.display.name=迴圈類別相依
cyclic.class.dependency.ignore.in.same.file=忽略位於同一檔案中的類別之間的迴圈
cyclic.class.dependency.problem.descriptor=類別 ''{0}'' 迴圈依賴於其他 {1} 個類別
cyclic.package.dependency.1.problem.descriptor=軟體套件 ''{0}'' 迴圈依賴於軟體套件 ''{1}''
cyclic.package.dependency.2.problem.descriptor=軟體套件 ''{0}'' 迴圈依賴於軟體套件 ''{1}'' 和 ''{2}''
cyclic.package.dependency.display.name=迴圈軟體套件相依關係
cyclic.package.dependency.problem.descriptor=軟體套件 ''{0}'' 迴圈依賴於其他 {1} 個軟體套件
cyclomatic.complexity.display.name=過度複雜的方法
cyclomatic.complexity.limit.option=迴圈復雜度限制:
cyclomatic.complexity.problem.descriptor=過度複雜的方法 <code>#ref()</code> (迴圈復雜度 = {0}) #loc
dangling.javadoc.convert.quickfix=取代為塊註釋
dangling.javadoc.delete.quickfix=移除懸空的註釋
dangling.javadoc.display.name=懸空的 Javadoc 註釋
dangling.javadoc.ignore.copyright.option=忽略 JavaDoc 格式的檔案頭註釋
dangling.javadoc.problem.descriptor=懸空的 Javadoc 註釋 #loc
debug.level.and.lower.option=偵錯級別和更低
declare.collection.as.interface.fix.family.name=削弱類型
declare.collection.as.interface.quickfix=削弱為 ''{0}''
default.not.last.case.in.switch.display.name='default' 不是 'switch' 中的最後一個 case
default.not.last.case.in.switch.problem.descriptor=''default'' 分支不是 ''switch'' {0} 中的最後一個 case #loc
default.tostring.call.display.name=呼叫預設 'toString()'
default.tostring.call.problem.descriptor=呼叫 <code>#ref</code> 上的預設 'toString()' #loc
delete.catch.section.fix.family.name=刪除 catch 語句
delete.catch.section.quickfix=刪除 'catch' 部分
delete.import.quickfix=刪除不必要的匯入
delete.unnecessary.statement.fix.family.name=移除冗餘語句
deserializable.class.in.secure.context.problem.descriptor=類別 <code>#ref</code> 可能被反序列化，影響安全性 #loc
design.for.extension.display.name=為擴展設計
design.for.extension.problem.descriptor=方法 <code>#ref()</code> 可能被覆寫，其功能會被忽略 #loc
diamond.can.be.replaced.with.explicit.type.arguments.name=diamond 可被取代為顯式類型實參
diamond.can.be.replaced.with.explicit.type.arguments.quickfix=將 '<>' 取代為顯式類型實參
disjoint.package.display.name=具有不相交相依關係圖的軟體套件
disjoint.package.problem.descriptor=軟體套件 {0} 可以分解為 {1} 個獨立軟體套件
divide.by.zero.display.name=除以零
divide.by.zero.problem.descriptor=除以零 #loc
dollar.sign.in.name.display.name=在關鍵字中使用 '$'
dollar.sign.in.name.problem.descriptor=關鍵字 <code>#ref</code> 包含 '$' #loc
double.brace.initialization.display.name=雙大括號初始化
double.brace.initialization.quickfix=取代為正則初始化
double.checked.locking.display.name=雙重檢查鎖定
double.checked.locking.fix.family.name=將欄位設為 volatile
double.checked.locking.problem.descriptor=雙重檢查鎖定 #loc
double.checked.locking.quickfix=將 ''{0}'' 設為 volatile
double.literal.may.be.float.literal.display.name=轉換為 'float' 可以是 'float' 文字
double.negation.display.name=雙重否定
double.negation.problem.descriptor=<code>#ref</code> 中的雙重否定 #loc
double.negation.quickfix=移除雙重否定
drivermanager.call.display.name=使用 'DriverManager' 獲取 JDBC 連線
drivermanager.call.problem.descriptor=呼叫 <code>DriverManager.#ref()</code> #loc
dumpstack.call.display.name=呼叫 'Thread.dumpStack()'
dumpstack.call.problem.descriptor=對 <code>Thread.#ref()</code> 的呼叫可能應當取代為更可靠的日誌 #loc
duplicate.condition.display.name=條件重複
duplicate.condition.ignore.method.calls.option=忽略有副作用的條件
duplicate.condition.problem.descriptor=重複條件 <code>#ref</code> #loc
dynamic.regex.replaceable.by.compiled.pattern.display.name=動態正則表達式可被取代為已編譯的 'Pattern'
dynamic.regex.replaceable.by.compiled.pattern.problem.descriptor=<code>#ref()</code> 可被取代為已編譯的 'java.util.regex.Pattern' 結構 #loc
dynamic.regex.replaceable.by.compiled.pattern.quickfix=取代為對已編譯 'Pattern' 常數的方法的呼叫
empty.anonymous.class.problem.descriptor=匿名類別為空 #loc
empty.class.display.name=冗餘空類別
empty.class.file.without.class.problem.descriptor=Java 檔案未宣告任何類別 #loc
empty.class.ignore.parameterization.option=如果類別是父類型的參數化，則將其忽略
empty.class.initializer.delete.quickfix=刪除空類別初始設定式
empty.class.initializer.display.name=空類別初始設定式
empty.class.initializer.problem.descriptor=空類別初始設定式 #loc
empty.class.problem.descriptor=類別 <code>#ref</code> 為空 #loc
empty.enum.problem.descriptor=枚舉 <code>#ref</code> 為空 #loc
empty.finally.block.display.name=空 'finally' 塊
empty.finally.block.problem.descriptor=空 <code>#ref</code> 塊 #loc
empty.synchronized.statement.display.name=空 'synchronized' 語句
empty.synchronized.statement.problem.descriptor=空 <code>#ref</code> 語句 #loc
empty.try.block.display.name=空 'try' 塊
empty.try.block.problem.descriptor=空 <code>#ref</code> 塊 #loc
encapsulate.variable.fix.family.name=封裝欄位
encapsulate.variable.quickfix=封裝欄位 ''{0}''
enum.singleton.problem.descriptor=枚舉 <code>#ref</code> 為單例 #loc
enum.switch.statement.which.misses.cases.display.name=缺少 case 的枚舉 'switch' 語句
enum.switch.statement.which.misses.cases.option=忽略具有預設分支的 switch 語句
enum.switch.statement.which.misses.cases.problem.descriptor=枚舉類型 ''{0}'' 上的 <code>#ref</code> 語句缺少 case: {1} #loc
enum.switch.statement.which.misses.cases.problem.descriptor.single=枚舉類型 ''{0}'' 上的 <code>#ref</code> 語句缺少 case ''{1}'' #loc
enumerated.class.display.name=枚舉類別
enumerated.class.naming.convention.element.description=枚舉類別
enumerated.class.problem.descriptor=枚舉類別 <code>#ref</code> #loc
enumerated.constant.naming.convention.element.description=枚舉常數
enumeration.can.be.iteration.display.name=枚舉可以是迭代
enumeration.can.be.iteration.problem.descriptor=<code>#ref()</code> 可被取代為 ''{0}'' 結構 #loc
enumeration.can.be.iteration.quickfix=取代為 'Iterator' 結構
equality.to.safe.equals.quickfix=用 null 安全 'equals()' 取代 '=='
equals.between.inconvertible.types.display.name='equals()' 位於不可轉換類型的物件之間
equals.between.inconvertible.types.mutual.subclass.option=如果未找到相互子類別，則發出警告
equals.between.inconvertible.types.no.mutual.subclass.problem.descriptor=未找到屬於 ''{0}'' 和 ''{1}'' 這兩個子類型的類別 #loc
equals.between.inconvertible.types.problem.descriptor=<code>#ref</code> 位於 ''{0}'' 和 ''{1}'' 不可轉換類型的物件之間 #loc
equals.called.on.array.display.name=在陣列上呼叫了 'equals()'
equals.called.on.array.problem.descriptor=陣列之間的 <code>#ref()</code> 可能應當是 'Arrays.equals()' #loc
equals.called.on.enum.constant.display.name=對枚舉值呼叫了 'equals()'
equals.called.on.enum.constant.problem.descriptor=對枚舉值呼叫了 <code>#ref()</code> #loc
equals.called.on.suspicious.object.display.name=在不對其進行覆寫的類別上呼叫了 'equals()'
equals.called.on.suspicious.object.fix.family.name=取代為代表值的比較
equals.called.on.suspicious.object.fix.name=取代為 ''{0}()'' 呼叫結果的比較
equals.called.on.suspicious.object.problem.descriptor=''{0}'' 物件上存在可疑的 ''equals()'' 呼叫
equals.doesnt.check.class.parameter.display.name=不檢查參數的類別的 'equals()' 方法
equals.doesnt.check.class.parameter.problem.descriptor=<code>#ref()</code> 應當檢查其參數的類別 #loc
equals.replaceable.by.objects.call.display.name='equals()' 表達式可被取代為 'Objects.equals()' 表達式
equals.replaceable.by.objects.call.problem.descriptor=<code>#ref</code> 可被取代為 'Objects.equals()' 表達式 #loc
equals.replaceable.by.objects.check.not.null.option=醒目提示與 'a != null \\\\&\\\\& a.equals(b)' 類似的表達式
equals.with.itself.display.name=在自身上呼叫了 'equals()'
equals.with.itself.option=僅對 final 庫類別類型或基元的測試斷言發出警告
equals.with.itself.problem.descriptor=在自身上呼叫了 <code>#ref()</code>
error.rethrown.display.name='Error' 未重新拋出
error.rethrown.problem.descriptor=錯誤 <code>#ref</code> 未重新拋出 #loc
exception.from.catch.which.doesnt.wrap.display.name='throw' 位於忽略已捕獲異常的 'catch' 塊內
exception.from.catch.which.doesnt.wrap.problem.descriptor='catch' 塊內的 <code>#ref</code> 忽略捕獲的異常 #loc
exception.from.catch.which.doesntwrap.ignore.cant.wrap.option=如果拋出的異常無法包裝異常，則忽略
exception.from.catch.which.doesntwrap.ignore.option=如果使用異常方法呼叫的結果，則忽略
exception.name.doesnt.end.with.exception.display.name=異常類別名不以 'Exception' 結尾
exception.name.doesnt.end.with.exception.problem.descriptor=異常類別名 <code>#ref</code> 未以 'Exception' 結尾 #loc
exception.package.display.name=異常軟體套件
exception.package.problem.descriptor=軟體套件 ''{0}'' 僅包含異常類別
expected.exception.never.thrown.display.name=從未在測試方法正文中拋出預期異常
expected.exception.never.thrown.problem.descriptor=從未在 ''{0}()'' 的正文中拋出預期 <code>#ref</code> #loc
explicit.array.to.string.problem.descriptor=呼叫陣列上的 '#ref()' #loc
expression.can.be.replaced.no.quotes.problem.descriptor={0} 可被取代為 {1}
expression.can.be.replaced.problem.descriptor=<code>#ref</code> 可被取代為 ''{0}'' #loc
expression.may.be.factorized.display.name=表達式可以因式分解
extend.exception.fix.family.name=使類別擴展 'Exception'
extended.for.statement.display.name=增強的 'for' 語句
extended.for.statement.problem.descriptor=擴展 <code>#ref</code> 語句 #loc
extended.for.statement.replace.quickfix=取代為舊式 'for' 語句
extends.annotation.display.name=類別擴展註解接口
extends.annotation.interface.problem.descriptor=接口 ''{0}'' 擴展註解接口 <code>#ref</code> #loc
extends.annotation.problem.descriptor=類別 ''{0}'' 實作註解接口 <code>#ref</code> #loc
extends.concrete.collection.display.name=類別顯式擴展 'Collection' 類別
extends.concrete.collection.problem.descriptor=類別 <code>#ref</code> 顯式擴展 ''{0}'' #loc
extends.object.display.name=類別顯式擴展 'Object'
extends.object.problem.descriptor=類別 <code>#ref</code> 顯式擴展 'java.lang.Object' #loc
extends.object.remove.quickfix=移除冗餘的 'extends Object'
extends.thread.display.name=類別直接擴展 'Thread'
extends.thread.problem.descriptor=類別 <code>#ref</code> 直接擴展 'java.lang.Thread' #loc
extends.throwable.display.name=類別直接擴展 'Throwable'
extends.throwable.problem.descriptor=類別 <code>#ref</code> 直接擴展 'java.lang.Throwable' #loc
externalizable.with.serialization.methods.display.name=具有 'readObject()' 或 'writeObject()' 的可外部化類別
externalizable.with.serialization.methods.problem.descriptor.both=可外部化{0, choice, 1#類別|2#接口|3#派生的匿名類別|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'readObject()' 和 'writeObject()' #loc
externalizable.with.serialization.methods.problem.descriptor.read=可外部化{0, choice, 1#類別|2#接口|3#派生的匿名類別|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'readObject()' #loc
externalizable.with.serialization.methods.problem.descriptor.write=可外部化{0, choice, 1#類別|2#接口|3#派生的匿名類別|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'writeObject()' #loc
externalizable.without.public.no.arg.constructor.display.name=沒有 'public' 無實參建構函式的 'Externalizable' 類別
externalizable.without.public.no.arg.constructor.problem.descriptor=可外部化類別 <code>#ref</code> 沒有 'public' 無實參建構函式 #loc
extract.method.quickfix=提取方法
extract.parameter.as.local.variable.quickfix=提取參數作為區域變數
fallthru.in.switch.statement.display.name='switch' 語句中的直落
fallthru.in.switch.statement.problem.descriptor='switch' 語句存在直落 #loc
fallthru.in.switch.statement.quickfix=新增 ''{0}''
feature.envy.display.name=特性依戀
feature.envy.problem.descriptor=類別 ''{0}'' 在方法 <code>#ref()</code> 中被重複存取 #loc
field.accessed.synchronized.and.unsynchronized.display.name=同時在 'synchronized' 和未同步上下文中存取欄位
field.accessed.synchronized.and.unsynchronized.option=簡單的 getter 和 setter 也被視為欄位存取
field.accessed.synchronized.and.unsynchronized.problem.descriptor=同時在同步和未同步上下文中存取欄位 <code>#ref</code> #loc
field.count.inspection.include.constant.fields.in.count.checkbox=在計數中包含常數欄位
field.count.inspection.include.enum.constants.in.count=在計數中包含枚舉常數
field.count.inspection.static.final.fields.count.as.constant.checkbox=將 'static final' 欄位計為常數
field.has.setter.but.no.getter.display.name=欄位具有 setter 但沒有 getter
field.has.setter.but.no.getter.problem.descriptor=欄位 <code>#ref</code> 有 setter 但沒有 getter #loc
field.has.static.modifier.problem.descriptor=欄位 ''{0}'' 具有 ''static'' 修飾符
field.incorrect.type.problem.descriptor=欄位 ''{0}'' 沒有類型 ''{1}''
field.may.be.final.display.name=欄位可能為 'final'
field.may.be.final.problem.descriptor=欄位 <code>#ref</code> 可能為 'final' #loc
field.may.be.static.display.name=欄位可以為 'static'
field.may.be.static.problem.descriptor=欄位 <code>#ref</code> 可能為 'static' #loc
field.missing.volatile.modifier.problem.descriptor=欄位 ''{0}'' 沒有 ''volatile'' 修飾符
field.name.hides.in.superclass.display.name=子類別欄位隱藏超類別欄位
field.name.hides.in.superclass.ignore.option=忽略不可存取欄位
field.name.hides.in.superclass.ignore.static.field.option=忽略隱藏 static 欄位的 static 欄位
field.name.hides.in.superclass.problem.descriptor=欄位 <code>#ref</code> 隱藏超類別中的欄位 #loc
field.naming.convention.display.name=欄位命名約定
field.not.found.in.class.problem.descriptor=類別 ''{1}'' 中未找到命名為 ''{0}'' 的欄位
final.class.display.name=類別禁止繼承
final.class.problem.descriptor=類別 ''{0}'' 宣告了 <code>#ref</code> #loc
final.method.display.name=不能覆寫方法
final.method.in.final.class.display.name='final' 類別位於 'final' 方法中
final.method.in.final.class.problem.descriptor=方法在 'final' 類別中被宣告為 <code>#ref</code> #loc
final.method.problem.descriptor=方法被宣告為 <code>#ref</code> #loc
final.private.method.display.name='private' 方法被宣告為 'final'
final.private.method.problem.descriptor='private' 方法被宣告為 <code>#ref</code> #loc
final.static.method.display.name='static' 方法被宣告為 'final'
final.static.method.problem.descriptor='static' 方法被宣告為 <code>#ref</code> #loc
finalize.called.explicitly.display.name='finalize()' 被顯式呼叫
finalize.called.explicitly.problem.descriptor=<code>#ref()</code> 被顯式呼叫 #loc
finalize.declaration.display.name='finalize()' 不應被覆寫
finalize.declaration.problem.descriptor='finalize()' 不應被覆寫 #loc
finalize.not.declared.protected.display.name='finalize()' 應為 protected，不應為 public
finalize.not.declared.protected.problem.descriptor='finalize()' 應具有 protected 存取權限，不應具有 public 存取權限 #loc
finally.block.cannot.complete.normally.display.name=不能正常完成的 'finally' 塊
finally.block.cannot.complete.normally.problem.descriptor=<code>#ref</code> 塊無法正常完成 #loc
fix.add.argument.family.name=新增實參
fix.add.argument.name=新增 ''{0}'' 實參
fix.data.provider.create.method.fix.name=建立資料提供程序方法 '@Parameters public static Iterable<Object> parameters()'
fix.data.provider.multiple.methods.problem=類別 <code>#ref</code> 中存在多個 @Parameters 資料提供程序方法
fix.data.provider.signature.family.name=修正資料提供程序方法簽名
fix.data.provider.signature.fix.name=將方法簽名更改為 ''{0}''
fix.data.provider.signature.incorrect.problem=資料提供程序方法 <code>#ref()</code> 的簽名不正確
fix.data.provider.signature.missing.method.problem=參數化測試類別 <code>#ref</code> 缺少用 '@Parameters' 註解的資料提供程序方法
fix.eliminate.folded.if.present.description=可以消除折疊的 'ifPresent()' 呼叫
fix.eliminate.folded.if.present.name=移除折疊的 'ifPresent()' 呼叫
fix.replace.map.with.flat.map.description='map()' 可被取代為 'flatMap()'
flip.comparison.quickfix=翻轉比較
floating.point.equality.display.name=浮點相等比較
floating.point.equality.problem.descriptor=<code>#ref</code>: 比較浮點值以實作完全相等 #loc
for.can.be.foreach.display.name='for' 迴圈可被取代為增強的 for 迴圈
for.can.be.foreach.fix.no.indexed=不報告索引的 'java.util.List' 迴圈
for.can.be.foreach.option=報告索引的 'java.util.List' 迴圈
for.can.be.foreach.option2=不報告無類型集合上的迭代
for.can.be.foreach.problem.descriptor=<code>#ref</code> 迴圈可被取代為增強的 'for' #loc
for.loop.replaceable.by.while.display.name='for' 迴圈可被取代為 'while' 迴圈
for.loop.replaceable.by.while.ignore.option=忽略無條件迴圈的 'infinite'
for.loop.replaceable.by.while.problem.descriptor=<code>#ref</code> 迴圈語句可被取代為 'while' 迴圈 #loc
for.loop.with.missing.component.collection.loop.option=忽略集合迭代
for.loop.with.missing.component.display.name=缺少組件的 'for' 迴圈
for.loop.with.missing.component.problem.descriptor1=<code>#ref</code> 語句缺少初始設定式 #loc
for.loop.with.missing.component.problem.descriptor2=<code>#ref</code> 語句缺少條件 #loc
for.loop.with.missing.component.problem.descriptor3=<code>#ref</code> 語句缺少更新 #loc
for.loop.with.missing.component.problem.descriptor4=<code>#ref</code> 語句缺少初始設定式和條件 #loc
for.loop.with.missing.component.problem.descriptor5=<code>#ref</code> 語句缺少初始設定式和條件 #loc
for.loop.with.missing.component.problem.descriptor6=<code>#ref</code> 語句缺少條件和更新 #loc
for.loop.with.missing.component.problem.descriptor7=<code>#ref</code> 語句缺少初始設定式、條件和更新 #loc
foreach.replace.quickfix=取代為增強 'for'
format.string.error.duplicate.flag=''{1}'' 中存在重複的標誌 ''{0}''
format.string.error.flags.not.allowed=''{1}'' 中不允許使用{2, choice, 1#標誌|1<標誌} ''{0}''
format.string.error.illegal.flag.combination=''{2}'' 中的標誌組合 ''{0}'' 和 ''{1}'' 非法
format.string.error.illegal.position.specifier=''{1}'' 存在非法的位置說明符 ''{0}''
format.string.error.invalid.precision=''{0}'' 中指定的精度無效
format.string.error.left.justify.no.width=使用了左對齊標誌 ''-''，但 ''{0}'' 中未指定寬度
format.string.error.precision.not.allowed=''{1}'' 中不允許該精度 (''{0}'')
format.string.error.previous.element.not.found=使用了以前的標誌 '<'，但沒有找到 ''{0}'' 以前的格式說明符
format.string.error.unexpected.flag=''{1}'' 中出現意外字元 ''{0}''
format.string.error.unknown.conversion=''{0}'' 中存在未知的轉換
format.string.error.unnecessary.position.specifier=''{1}'' 存在不必要的實參位置說明符 ''{0}''
format.string.error.width.not.allowed=''{1}'' 中不允許該寬度 (''{0}'')
format.string.error.zero.padding.no.width=使用了零填充標誌 ''0''，但 ''{0}'' 中未指定寬度
gc.call.display.name=呼叫 'System.gc()' 或 'Runtime.gc()'
gc.call.problem.descriptor=<code>#ref</code> 不應在生產程式碼中呼叫 #loc
generate.to.string.quick.fix.family.name=生成
generate.to.string.quick.fix.text=生成 toString()
groups.of.modules.loaded.together.description=每行指定一個以逗號分隔的模組名稱列表，已知這些模組名稱由同一個類別載入器載入。\\n不應報告對此類別模組之間的 package-private 成員的存取。
groups.of.modules.loaded.together.label=一起載入的模組組:
hardcoded.file.separator.display.name=硬編碼檔案分隔符
hardcoded.file.separator.ignore.methods.option=忽略以下方法的實參:
hardcoded.file.separator.include.option=在已識別的 MIME 媒體類型中包括 'example/*'
hardcoded.file.separator.problem.descriptor=硬編碼檔案分隔符 <code>#ref</code> #loc
hardcoded.line.separator.display.name=硬編碼行分隔符
hardcoded.line.separator.problem.descriptor=硬編碼行分隔符 <code>#ref</code> #loc
hibernate.resource.opened.not.closed.display.name=Hibernate 資源已開啟，但未安全關閉
html.tag.can.be.javadoc.tag.display.name='<code>...</code>' 可被取代為 '{@code ...}'
html.tag.can.be.javadoc.tag.problem.descriptor=<code>#ref...\\\\&lt;/code\\\\&gt;</code> 可被取代為 '{@code ...}' #loc
i.o.resource.opened.not.closed.display.name=I/O 資源已開啟，但未安全關閉
if.can.be.assertion.name=語句可被取代為 'assert' 或 'Objects.requireNonNull'
if.can.be.assertion.replace.with.assertion.quickfix=將語句取代為 'assert' 語句
if.can.be.assertion.replace.with.objects.requirenonnull.quickfix=將語句取代為 'Objects.requireNonNull()'
if.can.be.switch.display.name='if' 可被取代為 'switch'
if.can.be.switch.enum.option=對枚舉啟用 switch 建議
if.can.be.switch.int.option=對數字啟用 switch 建議
if.can.be.switch.minimum.branch.option='if' 條件分支的最小數量:
if.can.be.switch.null.safe.option=僅對 null-safe 表達式啟用建議
if.can.be.switch.problem.descriptor=<code>#ref</code> 語句可被取代為 'switch' 語句 #loc
if.may.be.conditional.problem.descriptor=<code>#ref</code> 可被取代為條件表達式 #loc
if.may.be.conditional.quickfix=取代為條件表達式
if.may.be.factorized.problem.descriptor=<code>#ref</code> 可以因式分解 #loc
if.may.be.factorized.quickfix=取代為因式分解表達式
if.statement.with.identical.branches.display.name='if' 語句的分支相同
if.statement.with.too.many.branches.display.name='if' 語句的分支過多
if.statement.with.too.many.branches.max.option=最大分支數:
if.statement.with.too.many.branches.problem.descriptor=<code>#ref</code> 的分支過多 ({0}) #loc
ignore.accesses.from.equals.method=忽略來自 'equals()' 方法的存取
ignore.accesses.from.the.same.class=忽略來自同一類的存取
ignore.anonymous.inner.classes=忽略匿名內部類別
ignore.boolean.methods.in.an.interface.option=忽略 @&interface 中的布爾方法
ignore.branches.of.switch.statements=忽略 'switch' 語句的分支
ignore.calls.to.property.getters=忽略對屬性 getter 的呼叫
ignore.calls.to.static.methods=忽略對 static 方法的呼叫
ignore.class.fix.family.name=對這些類型忽略
ignore.classes.annotated.by=由以下物件註解時忽略類別:
ignore.classes.in.hierarchy.column.name=忽略以下物件的子類別:
ignore.cloneable.option=忽略 'java.lang.Cloneable'
ignore.constructor.method.references=忽略產生 AutoCloseable 的建構函式方法參照
ignore.enhanced.for.loop.statements=忽略增強型 for 迴圈
ignore.equals.hashcode.and.tostring=忽略 'equals()'、'hashCode()' 和 'toString()' 方法
ignore.exceptions.declared.on.library.override.option=忽略在覆寫庫方法的方法上宣告的異常(&L)
ignore.for.equals.methods.option=對 'equals()' 方法忽略(&E)
ignore.getters.returning.resource=忽略返回源的 getter
ignore.guard.clauses.option=忽略臨界子句(&G)
ignore.if.annotated.by=由以下物件註解時忽略:
ignore.in.module.statements.option=在 Java 9 模組語句中忽略
ignore.instanceof.on.library.classes=忽略庫類別上的 instanceof
ignore.methods.in.anonymous.classes=忽略匿名類別中的方法
ignore.methods.overriding.super.method=忽略覆寫/實作 super 方法的方法(O&)
ignore.methods.with.boolean.return.type.option=忽略具有 'java.lang.Boolean' 返回值類型的方法(&B)
ignore.overflowing.byte.casts.option=忽略從 int 128-255 到位元組的轉換
ignore.parentheses.around.single.no.formal.type.lambda.parameter=忽略單個非正式類型 lambda 參數周圍的括號
ignore.private.methods.option=忽略 private 方法中的賦值和返回值
ignore.serializable.option=忽略 'java.io.Serializable'
ignore.single.field.static.imports.option=忽略單欄位靜態匯入(&F)
ignore.single.method.static.imports.option=忽略單方法靜態匯入(&M)
ignore.trivial.finalizers.option=對普通 'finalize()' 實作忽略
ignored.autocloseable.types.label=已忽略的 AutoCloseable 資源類型:
ignored.class.hierarchies.border.title=忽略以下物件的子類別:
ignored.class.label=已忽略類別(包括子類別):
ignored.class.names=忽略類別(包括子類別)
ignored.io.resource.types=已忽略的 I/O 資源類型
ignored.io.resource.types.label=已忽略的 I/O 資源類型:
implicit.array.to.string.display.name=呼叫陣列上的 'toString()'
implicit.array.to.string.fix.family.name=將 Array.toString() 設為隱式
implicit.array.to.string.method.call.problem.descriptor=隱式呼叫呼叫 <code>#ref</code> 返回的陣列上的 'toString()' #loc
implicit.array.to.string.problem.descriptor=隱式呼叫陣列 <code>#ref</code> 上的 'toString()' #loc
implicit.array.to.string.quickfix=使用 ''{0}'' 表達式包裝
implicit.call.to.super.display.name=隱式呼叫 'super()'
implicit.call.to.super.ignore.option=對 'java.lang.Object' 的直接子類別忽略
implicit.call.to.super.make.explicit.quickfix=使對 'super()' 的呼叫顯式
implicit.call.to.super.problem.descriptor=隱式呼叫 'super()' #loc
implicit.default.charset.usage.constructor.problem.descriptor=<code>new #ref()</code> 呼叫使用平台的預設字符集
implicit.default.charset.usage.display.name=隱式平台預設字符集
implicit.default.charset.usage.fix.family.name=指定 UTF-8 字符集
implicit.default.charset.usage.problem.descriptor=對 <code>#ref()</code> 的呼叫使用平台的預設字符集
implicit.numeric.conversion.assignment.problem.descriptor=將結果值從 ''{0}'' 隱式數字轉換為 ''{1}'' #loc
implicit.numeric.conversion.display.name=隱式數字轉換
implicit.numeric.conversion.ignore.char.conversion.option=忽略 'char' 之間的轉換
implicit.numeric.conversion.ignore.constant.conversion.option=忽略從常數和文字的轉換
implicit.numeric.conversion.ignore.widening.conversion.option=忽略擴大轉換
implicit.numeric.conversion.make.explicit.quickfix=使轉換顯式
implicit.numeric.conversion.problem.descriptor=將 <code>#ref</code> 從 ''{0}'' 隱式數字轉換為 ''{1}'' #loc
import.display.name='*' 匯入
import.from.same.package.display.name=相同軟體套件中的不必要 import
import.from.same.package.problem.descriptor=相同軟體套件 <code>#ref</code> 中有不必要的 import #loc
import.problem.descriptor=軟體套件匯入 <code>#ref</code> #loc
include.java.system.classes.option=包括與 Java 系統類別的耦合
include.library.classes.option=包括與庫類別的耦合
incompatible.mask.operation.display.name=不相容的位元遮罩運算
incompatible.mask.operation.problem.descriptor.always.false=<code>#ref</code> 始終為 false #loc
incompatible.mask.operation.problem.descriptor.always.true=<code>#ref</code> 始終為 true #loc
incorrect.date.format.fix.family.name=修復不正確的日期格式
increment.decrement.display.name=使用 '++' 或 '--' 的結果
increment.decrement.used.as.expression.fix.family.name=提取到分離語句中
increment.decrement.used.as.expression.quickfix=提取 ''{0}'' 以分離語句
inequality.to.safe.not.equals.quickfix=用 null 安全 '!equals()' 取代 '!='
infinite.loop.statement.display.name=無限迴圈語句
infinite.loop.statement.problem.descriptor=<code>#ref</code> 語句不能在未拋出異常的情況下完成 #loc
infinite.recursion.display.name=無限遞迴
infinite.recursion.problem.descriptor=方法 <code>#ref()</code> 無限遞迴，只能以拋出異常結束 #loc
info.level.and.lower.option=資訊級別和更低
inline.call.quickfix=內聯呼叫
inline.variable.quickfix=內聯變數
inner.class.field.hides.outer.display.name=內部類別欄位隱藏外部類別欄位
inner.class.field.hides.outer.ignore.option=忽略從內部類別不可見的外部欄位
inner.class.field.hides.outer.problem.descriptor=內部類別欄位 <code>#ref</code> 隱藏外部類別欄位 #loc
inner.class.may.be.static.display.name=內部類別可能為 'static'
inner.class.may.be.static.problem.descriptor=內部類別 <code>#ref</code> 可能為 'static' #loc
inner.class.on.interface.display.name=接口的內部類別
inner.class.on.interface.ignore.option=忽略接口的內部接口
inner.class.on.interface.problem.descriptor=接口 ''{0}'' 具有內部類別 <code>#ref</code> #loc
inner.class.referenced.via.subclass.display.name=通過子類別參照的內部類別
inner.class.referenced.via.subclass.problem.descriptor=內部類別 <code>#ref</code> 在類別 ''{0}'' 中宣告，但通過子類別 ''{1}'' 參照 #loc
inner.class.referenced.via.subclass.quickfix=使內部類別存取合理化
inner.class.too.deeply.nested.display.name=內部類別嵌套太深
inner.class.too.deeply.nested.nesting.limit.option=嵌套限制:
inner.class.too.deeply.nested.problem.descriptor=<code>#ref</code> 嵌套太深 (嵌套級別 = {0}) #loc
inspection.autocloseable.resource.ignored.methods.title=忽略從這些方法返回的 AutoCloseable 實例:
inspection.byte.array.output.stream.to.string.message=ByteArrayOutputStream 轉換低效
inspection.case.mismatch.display.name='String' 動作中不符合的大小寫
inspection.case.mismatch.message.arg.is.lower=方法 ''{0}()'' 始終返回 {1}: 實參包含小寫符號，而限定符僅為大寫
inspection.case.mismatch.message.arg.is.upper=方法 ''{0}()'' 始終返回 {1}: 實參包含大寫符號，而限定符僅為小寫
inspection.case.mismatch.message.label.is.lower=無法存取 switch 分支: 標籤包含小寫符號，而選擇器僅支援大寫
inspection.case.mismatch.message.label.is.upper=無法存取 switch 分支: 標籤包含大寫符號，而選擇器僅支援小寫
inspection.cast.can.be.replaced.with.variable.display.name=轉換可被取代為變數
inspection.cast.can.be.replaced.with.variable.family.name=用變數取代轉換
inspection.cast.can.be.replaced.with.variable.message=可以使用變數 ''{0}'' 替代 ''{1}''
inspection.catch.ignores.exception.display.name=catch 塊可能會忽略異常
inspection.catch.ignores.exception.empty.message=空 <code>#ref</code> 塊 #loc
inspection.catch.ignores.exception.option.comments=當 'catch' 塊包含註釋時不發出警告
inspection.catch.ignores.exception.option.ignored.used=當名稱為 'ignore(d)' 的異常實際上未被忽略時不發出警告
inspection.catch.ignores.exception.option.nonempty=當 'catch' 塊不為空時不發出警告
inspection.catch.ignores.exception.unused.message=未使用的 'catch' 參數 <code>#ref</code> #loc
inspection.catch.ignores.exception.used.message=已使用命名為 <code>#ref</code> 的 'catch' 參數 #loc
inspection.catch.ignores.exception.vm.ignored.message=<code>#ref</code> 塊中可能會忽略 ''{0}'' 之類的意外虛擬機異常 #loc
inspection.collection.must.have.initial.capacity.initializers.option=不報告欄位初始設定式
inspection.commented.out.code.disable.short.fragments=不報告此類別短片段
inspection.commented.out.code.display.name=註釋掉的程式碼
inspection.commented.out.code.min.lines.options=最少程式碼行數
inspection.commented.out.code.problem.descriptor=註釋掉的程式碼 ({0} {0, choice, 1#行|1<行})
inspection.common.if.parts.description.complete.duplicate=可以摺疊 ''if'' 語句{0}
inspection.common.if.parts.description.complete.duplicate.side.effect=可以通過提取副作用摺疊 'if' 語句
inspection.common.if.parts.description.variables.only=可以從 ''if'' 中提取變數{0}
inspection.common.if.parts.description.whole.branch=可以提取通用部分，同時移除分支{0}
inspection.common.if.parts.description.with.variables.extract=可以從 ''if'' 中提取包含變數的通用部分{0}
inspection.common.if.parts.description.without.variables.extract=可以從 ''if'' 中提取通用部分{0}
inspection.common.if.parts.message.complete.duplicate=摺疊 ''if'' 語句{0}
inspection.common.if.parts.message.complete.duplicate.side.effect=摺疊 'if' 語句並提取副作用
inspection.common.if.parts.message.variables.only=從 ''if'' 中提取變數{0}
inspection.common.if.parts.message.whole.branch=提取通用部分，同時移除分支{0}
inspection.common.if.parts.message.with.variables.extract=從 ''if'' 中提取包含變數的通用部分{0}
inspection.common.if.parts.message.without.variables.extract=從 ''if'' 中提取通用部分{0}
inspection.common.subexpression.in.switch.display.name=可以從 'switch' 中提取通用子表達式
inspection.common.subexpression.in.switch.fix.family.name=向下推送 'switch' 表達式
inspection.comparator.combinators.description=可被取代為 'Comparator' 鏈
inspection.comparator.combinators.description2=可被取代為 ''{0}''
inspection.comparator.combinators.fix.chain=取代為 'Comparator' 鏈
inspection.condition.covered.by.further.condition.descr=條件 ''{0}'' 由後面的{1, choice, 1#條件 ''''{2}''''|2#條件}覆蓋
inspection.constant.expression.display.name=可以對常數表達式求值
inspection.constant.expression.fix.family.name=計算常量值
inspection.constant.expression.fix.name=計算 ''{0}'' 的常量值
inspection.constant.expression.fix.name.short=取代為常量值
inspection.constant.expression.fix.name.with.value=將 ''{0}'' 取代為常量值 ''{1}''
inspection.constant.expression.message=常數表達式的求值結果可以為 ''{0}''
inspection.constant.expression.skip.non.literal=Don't report when the expression contains references to defined constants
inspection.deconstruction.can.be.used.display.name=可以使用記錄模式
inspection.deconstruction.can.be.used.fix.family.name=取代為記錄模式
inspection.deconstruction.can.be.used.message=可被取代為記錄模式
inspection.empty.catch.block.generate.body=從模板生成 'catch' 正文
inspection.empty.class.ignore.subclasses.option=忽略 {0} 的子類別
inspection.enhanced.for.with.record.pattern.can.be.used.components.option=要解構的記錄組件的最大數量:
inspection.enhanced.for.with.record.pattern.can.be.used.display.name=可以使用帶有記錄模式的增強 'for'
inspection.enhanced.for.with.record.pattern.can.be.used.fix.family.name=取代為記錄模式
inspection.enhanced.for.with.record.pattern.can.be.used.level.option=嵌套深度限制:
inspection.enhanced.for.with.record.pattern.can.be.used.maximum.depth.disabled=不建議帶有 {0} 種和更多嵌套模式的模式
inspection.enhanced.for.with.record.pattern.can.be.used.maximum.number.disabled=不建議帶有 {0} 個或更多組件的記錄
inspection.enhanced.for.with.record.pattern.can.be.used.message=可被取代為帶有記錄模式的增強 'for'
inspection.enhanced.for.with.record.pattern.can.be.used.not.used.option=未使用的記錄組件的最大數量:
inspection.excessive.range.check.fix.family.name=簡化過度範圍檢查
inspection.excessive.range.check.message=可被取代為 ''{0}''
inspection.explicit.chrono.field.display.name=可以簡化對帶有顯式 'ChronoField' 或 'ChronoUnit' 實參的 'java.time' 方法的呼叫
inspection.explicit.chrono.field.family.name=簡化帶有顯式 'ChronoField' 或 'ChronoUnit' 實參的呼叫
inspection.explicit.chrono.field.problem.descriptor=可以簡化對帶有顯式 'ChronoField' 或 'ChronoUnit' 實參呼叫的呼叫
inspection.if.statement.missing.break.in.loop.description=滿足條件後，可以終止迴圈
inspection.if.statement.missing.break.in.loop.name=在 'if' 條件下提前退出迴圈
inspection.if.statement.missing.break.in.loop.quickfix=新增 'break'
inspection.incorrect.date.format.display.name=不正確的 'DateTimeFormat' 模式
inspection.incorrect.date.format.message.literal=左單引號({0})後未跟隨右單引號
inspection.incorrect.date.format.message.padding=沒有連續模式字母的填充修飾符 ''{0}''
inspection.incorrect.date.format.message.reserved.character=使用保留字元 ''{0}''
inspection.incorrect.date.format.message.unpaired=在沒有事先開啟 ''{0}'' 的情況下關閉 <code>#ref</code>
inspection.incorrect.date.format.message.unsupported=非法模式字母 ''{0}''
inspection.incorrect.date.format.too.few.letters=連續模式字母 ''{0}'' 過少；最小: {1}；指定: {2}
inspection.incorrect.date.format.too.many.letters=連續模式字母 ''{0}'' 過多；最大: {1}；指定: {2}
inspection.incorrect.date.format.wrong.number.of.letters=連續模式字母 ''{0}'' 的數量錯誤；允許: {1}；指定: {2}
inspection.incorrect.message.format.choice.limit.incorrect=選擇模式中的下限 ''{0}'' 不正確
inspection.incorrect.message.format.choice.limit.not.found=選擇模式中的下''{0}''為空
inspection.incorrect.message.format.display.name='MessageFormat' 模式不正確
inspection.incorrect.message.format.incorrect.index=索引 ''{0}'' 不正確
inspection.incorrect.message.format.incorrect.order.choice=選擇模式中的下限未按升序排列
inspection.incorrect.message.format.incorrect.quotes.number=引號的數量可能不正確，將列印超過 1 個引號
inspection.incorrect.message.format.not.found.argument=No argument for index ''{0}''
inspection.incorrect.message.format.not.found.arguments=索引沒有實參: {0}
inspection.incorrect.message.format.not.used.argument=模式中未使用索引為 ''{0}'' 的實參
inspection.incorrect.message.format.pattern=訊息格式模式 ''{1}'' 中的 {0}
inspection.incorrect.message.format.quotes.around.parameter=佔位符 ''{0}'' 不會被取代，因為它包含在引號中
inspection.incorrect.message.format.unclosed.brace=未閉合的大括號
inspection.incorrect.message.format.unknown.format.type=未知格式類型 ''{0}''
inspection.incorrect.message.format.unmatched.brace=不符合的大括號
inspection.incorrect.message.format.unpaired.quote=訊息模式中不成對的引號
inspection.list.remove.in.loop.display.name=在迴圈中呼叫了 'List.remove()'
inspection.list.remove.in.loop.message=可被取代為 'List.subList().clear()'
inspection.lossy.conversion.compound.assignment.display.name=Implicit cast from ''{0}'' to ''{1}'' in compound assignment can be lossy
inspection.lossy.conversion.compound.assignment.name=Possibly lossy implicit cast in compound assignment
inspection.meta.annotation.without.runtime.description={0} 應具有 @Retention(RetentionPolicy.RUNTIME)
inspection.method.call.in.loop.ignore.known.methods.option=忽略有副作用的已知方法
inspection.new.object.equality.display.name=使用 '==' 比較新物件
inspection.new.object.equality.message=使用 ''{0}'' 比較新物件
inspection.non.strict.comparison.equality.display.name=非嚴格不等式 '>=' 或 '<=' 可被取代為 '=='
inspection.non.strict.comparison.equality.message=可被取代為等式
inspection.note.may.change.semantics=可能更改語意
inspection.only.one.element.used.array=僅使用了一個陣列元素
inspection.only.one.element.used.display.name=僅使用了一個元素
inspection.only.one.element.used.fix.family=取代為已存取的元素
inspection.only.one.element.used.list=僅使用了一個列表元素
inspection.only.one.element.used.string=僅使用了一個字串字元
inspection.option.ignore.as.initial.capacity=忽略 StringBuilders 和 Collections 的初始容量
inspection.option.ignore.assert=對斷言語句描述實參忽略
inspection.option.ignore.constant.initializers=對常數欄位的初始設定式忽略
inspection.option.ignore.exceptions=對 Throwable 子類別的建構函式實參忽略
inspection.option.ignore.in.annotations=在註解中忽略
inspection.option.ignore.in.hashcode=忽略 'hashCode()' 方法中的常數
inspection.option.ignore.in.tostring=在 toString() 方法內部忽略
inspection.option.ignore.nonnls=通過 @NonNls 進行註解時忽略
inspection.option.ignore.system.err=對 'System.err.print' 實參忽略
inspection.option.ignore.system.out=對 'System.out.print' 實參忽略
inspection.parameterized.parameters.static.collection.display.name=沒有資料提供程序方法的參數化測試類別
inspection.pattern.variable.can.be.used.display.name=可以使用模式變數
inspection.pattern.variable.can.be.used.existing.fix.family.name=取代為現有模式變數
inspection.pattern.variable.can.be.used.existing.fix.name=將 ''{0}'' 取代為現有模式變數 ''{1}''
inspection.pattern.variable.can.be.used.existing.message=可以使用現有模式變數 ''{0}'' 代替 ''{1}''
inspection.pattern.variable.can.be.used.fix.family.name=取代為模式變數
inspection.pattern.variable.can.be.used.fix.name=將 ''{0}'' 取代為模式變數
inspection.pattern.variable.can.be.used.message=變數 ''{0}'' 可被取代為模式變數
inspection.redundant.arguments.message=不必要的實參
inspection.redundant.class.call.display.name=冗餘的 'isInstance()' 或 'cast()' 呼叫
inspection.redundant.collection.operation.display.name=冗餘的 'Collection' 動作
inspection.redundant.collection.operation.fix.family.name=簡化集合動作
inspection.redundant.collection.operation.problem.arraycopy=為複製陣列而建立的集合不必要
inspection.redundant.collection.removal.by.index.fix=使用按物件移除
inspection.redundant.collection.removal.by.index.problem=按索引移除可被取代為按物件移除
inspection.redundant.collection.unnecessary.contains.fix=移除 ''{0}()'' 檢查
inspection.redundant.collection.unnecessary.contains.problem=不必要的 ''{0}()'' 檢查
inspection.redundant.compare.call.display.name=冗餘的 'compare()' 方法呼叫
inspection.redundant.compare.call.fix.name=內聯 'compare()' 呼叫
inspection.redundant.empty.string.argument.message=不必要的空字串實參
inspection.redundant.explicit.variable.type.description=可以省略區域變數的顯式類型
inspection.redundant.length.check.display.name=冗餘的陣列長度檢查
inspection.redundant.string.call.message=<code>#ref()</code> 的呼叫冗餘 #loc
inspection.redundant.string.constructor.message=<code>new #ref()</code> 冗餘 #loc
inspection.redundant.string.fix.family.name=移除冗餘呼叫
inspection.redundant.string.intern.on.constant.message=編譯時常量上 <code>#ref()</code> 的呼叫不必要 #loc
inspection.redundant.string.length.argument.message=不必要的字串長度實參
inspection.redundant.string.new.array.message=<code>#ref</code> 冗餘 #loc
inspection.redundant.string.operation.display.name=冗餘的 'String' 動作
inspection.redundant.string.option.do.not.report.string.constructors=不報告 String 建構函式呼叫
inspection.redundant.string.remove.argument.fix.name=移除實參
inspection.redundant.string.remove.fix.name=移除冗餘的 ''{0}()'' 呼叫
inspection.redundant.string.replace.with.arg.fix.name=取代為實參
inspection.redundant.string.replace.with.empty.fix.name=取代為空字串
inspection.redundant.zero.argument.message=不必要的零實參
inspection.refused.bequest.super.annotated.option=僅在通過以下方式註解 super 方法時報告:
inspection.replace.on.literal.display.name=取代動作不起任何作用
inspection.simplifiable.compare.java.time.display.name=帶有 'java.time' 'compareTo()' 呼叫的表達式可以簡化
inspection.simplifiable.compare.java.time.family.name=使用 'java.time' 'compareTo()' 呼叫簡化表達式
inspection.simplifiable.compare.java.time.problem.descriptor=帶有 'java.time' <code>#ref()</code> 呼叫的表達式可以簡化
inspection.simplifiable.if.statement.display.name='if' 語句可被取代為條件或布爾表達式
inspection.simplifiable.if.statement.fix.family.name=將 'if else' 取代為條件運算符
inspection.simplifiable.if.statement.fix.name=將 ''if else'' 取代為 ''{0}''
inspection.simplifiable.if.statement.message=If 語句可被取代為 ''{0}''
inspection.simplifiable.if.statement.option.dont.warn.on.ternary=不建議使用 '?:' 運算符
inspection.suppression.annotation.display.name=檢查禁止註解
inspection.suppression.annotation.problem.descriptor=檢查禁止註解 <code>#ref</code> #loc
inspection.suspicious.date.format.display.name=可疑的日期格式模式
inspection.suspicious.date.format.message.lower=使用了小寫 ''{0}'' ({1}) 模式: 預期可能為 ''{2}'' ({3})
inspection.suspicious.date.format.message.upper=使用了大寫 ''{0}'' ({1}) 模式: 預期可能為 ''{2}'' ({3})
inspection.suspicious.package.private.access.description={0} 是 {1}，但在不同的模組 ''{2}'' 中宣告
inspection.suspicious.package.private.access.problem={0} 重寫了來自在不同模組 ''{2}'' 中宣告的 {1} 的 package-private 方法
inspection.test.method.without.assertion.list.name=斷言方法:
inspection.test.method.without.assertions.exceptions.option=忽略宣告異常的測試方法
inspection.trivial.functional.expression.usage.description=可以簡化方法呼叫
inspection.type.may.be.weakened.add.stop.class.family=新增停止類別
inspection.type.may.be.weakened.add.stop.class.selection.popup=選擇停止類別
inspection.type.may.be.weakened.add.stop.class.selection.table=停止類別
inspection.type.may.be.weakened.add.stop.class.selection.table.label=停止類別:
inspection.type.may.be.weakened.add.stopper=作為停止類別添加以減弱
inspection.type.may.be.weakened.add.stopper.preview=停止類別將被新增到此檢查的停止類別列表中。
inspection.type.may.be.weakened.add.stopper.single=新增 {0} 作為停止類別以削弱
inspection.type.may.be.weakened.collection.method.option=對方法呼叫實參使用參數化集合類型(&P)
inspection.type.may.be.weakened.display.name=類型可能被削弱
inspection.type.may.be.weakened.do.not.weaken.inferred.variable.type=不建議削弱宣告為 'var' 的變數
inspection.type.may.be.weakened.do.not.weaken.return.type=不削弱返回值類型
inspection.type.may.be.weakened.do.not.weaken.to.object.option=不削弱為 'java.lang.Object'(&W)
inspection.type.may.be.weakened.field.problem.descriptor=欄位 <code>#ref</code> 的類型可能被削弱為 {0} #loc
inspection.type.may.be.weakened.ignore.option=在賦值中使用右手類型作為最弱的類型(&R)
inspection.type.may.be.weakened.method.problem.descriptor=方法 <code>#ref()</code> 的返回值類型可能被削弱為 {0} #loc
inspection.type.may.be.weakened.only.weaken.to.an.interface=僅削弱為接口
inspection.type.may.be.weakened.parameter.problem.descriptor=參數 <code>#ref</code> 的類型可能被削弱為 {0} #loc
inspection.type.may.be.weakened.problem.descriptor=變數 <code>#ref</code> 的類型可能被削弱為 {0} #loc
inspection.type.may.be.weakened.quickfix=將類型削弱為 ''{0}''
inspection.type.may.be.weakened.weaken.type.family=削弱類型
inspection.unnecessary.string.escape.report.char.literals.option=報告字元文字
inspection.use.of.private.field.inner.classes.option=忽略來自內部類別的存取
inspection.use.of.slash.s.display.name='\\\\s' 轉義序列的非終止使用
inspection.use.of.slash.s.fix.family=將 '\\\\s' 序列取代為空格
inspection.use.of.slash.s.message=不推薦在行中間使用 '\\\\s' 轉義序列
inspection.x.call.can.be.replaced.with.y=<code>#ref()</code> 呼叫可被取代為 ''{0}()''
instance.Variable.may.not.be.initialized.problem.descriptor.junit=實例欄位 <code>#ref</code> 在物件建構或 'setUp()' 呼叫期間可能無法初始化 #loc
instance.method.naming.convention.element.description=實例方法
instance.variable.may.not.be.initialized.display.name=實例欄位可能無法初始化
instance.variable.may.not.be.initialized.problem.descriptor=實例欄位 <code>#ref</code> 在物件建構期間可能無法初始化 #loc
instance.variable.naming.convention.element.description=實例欄位
instance.variable.of.concrete.class.problem.descriptor=具體類別 <code>#ref</code> 的實例欄位 ''{0}'' #loc
instance.variable.used.before.initialized.display.name=實例欄位在初始化前使用
instance.variable.used.before.initialized.problem.descriptor=初始化前使用的實例欄位 <code>#ref</code> #loc
instanceof.catch.parameter.display.name='catch' 參數上的 'instanceof'
instanceof.catch.parameter.problem.descriptor='catch' 參數 <code>#ref</code> 上的 'instanceof' #loc
instanceof.check.for.this.display.name='this' 的 'instanceof' 檢查
instanceof.check.for.this.equality.problem.descriptor='this' 的類別比較 #loc
instanceof.check.for.this.problem.descriptor=<code>#ref</code> 的 'instanceof' 檢查 #loc
instanceof.concrete.class.equality.problem.descriptor=與具體類別 <code>#ref</code> 的類別比較 #loc
instanceof.concrete.class.pattern.problem.descriptor=針對具體類別 <code>#ref</code> 的模式測試 #loc
instanceof.concrete.class.problem.descriptor='instanceof' 具體類別 <code>#ref</code> #loc
instanceof.with.incompatible.interface.display.name=具有不相容接口的 'instanceof'
instanceof.with.incompatible.interface.problem.descriptor=具有不相容接口 <code>#ref</code> 的 'instanceof' #loc
instantiating.datetimeformatter.without.locale.problem.descriptor=在未在國際化上下文中指定區域設定的情況下呼叫 <code>DateTimeFormatter.#ref()</code> #loc
instantiating.object.to.get.class.object.display.name=實例化物件以獲取 'Class' 物件
instantiating.object.to.get.class.object.problem.descriptor=實例化物件以獲取類別物件 #loc
instantiating.object.to.get.class.object.replace.quickfix=取代為直接類別物件存取
instantiating.simpledateformat.without.locale.display.name=無區域設定的 'SimpleDateFormat'
instantiating.simpledateformat.without.locale.problem.descriptor=在未在國際化上下文中指定區域設定的情況下實例化 <code>#ref</code> #loc
instantiation.utility.class.display.name=實用程序類別的實例化
instantiation.utility.class.problem.descriptor=實用程序類別 <code>#ref</code> 的實例化 #loc
int.literal.may.be.long.literal.display.name=轉換為 'long' 可以是 'long' 文字
int.literal.may.be.long.literal.problem.descriptor=<code>#ref</code> 可被取代為 ''{0}'' #loc
integer.division.in.floating.point.context.display.name=浮點上下文中的整數除法
integer.division.in.floating.point.context.fix.family.name=將分子轉換為浮點類型
integer.division.in.floating.point.context.fix.name=將分子轉換為 ''{0}''
integer.division.in.floating.point.context.problem.descriptor=<code>#ref</code>: 浮點上下文中的整數除法 #loc
integer.multiplication.implicit.cast.to.long.display.name=整數乘法或移位隱式轉換為 'long'
integer.multiplication.implicit.cast.to.long.option=<html>忽略靜態證明不可能溢出的表達式</html>
integer.multiplication.implicit.cast.to.long.problem.descriptor=#ref: 整數乘法隱式轉換為 long #loc
integer.multiplication.implicit.cast.to.long.quickfix=轉換為 long
integer.shift.implicit.cast.to.long.problem.descriptor=#ref: 整數移位隱式轉換為 long #loc
interface.clashes.with.object.class.display.name=接口方法與 'Object' 中的方法衝突
interface.clashes.with.object.class.problem.descriptor=<code>#ref()</code> 與 'java.lang.Object' 中的方法衝突
interface.may.be.annotated.functional.display.name=接口可以註解為 '@FunctionalInterface'
interface.may.be.annotated.functional.problem.descriptor=接口 <code>#ref</code> 可以使用 @FunctionalInterface 註解
interface.naming.convention.element.description=接口
interface.never.implemented.display.name=沒有具體子類別的接口
interface.never.implemented.option=忽略僅宣告常數的接口
interface.never.implemented.problem.descriptor=接口 <code>#ref</code> 沒有具體子類別 #loc
interface.one.inheritor.display.name=只有一個直接繼承者的接口
interface.one.inheritor.problem.descriptor=只有一個直接繼承者的接口 <code>#ref</code> #loc
introduce.holder.class.quickfix=引入 holder 類別
introduce.variable.may.change.semantics.quickfix=引入變數 (可能更改語意)
introduce.variable.quickfix=引入變數
invert.method.quickfix=反轉方法
invert.quickfix=反轉 ''{0}''
invert.quickfix.family.name=反轉布爾
iterator.hasnext.which.calls.next.display.name=呼叫 'next()' 的 'Iterator.hasNext()'
iterator.hasnext.which.calls.next.problem.descriptor=<code>Iterator.{0}()</code> 包含 ''#ref()'' 呼叫 #loc
iterator.next.does.not.throw.nosuchelementexception.display.name=無法拋出 'NoSuchElementException' 的 'Iterator.next()'
iterator.next.does.not.throw.nosuchelementexception.problem.descriptor=無法拋出 'NoSuchElementException' 的 <code>Iterator.#ref()</code> '#loc
java.lang.import.display.name='java.lang' 軟體套件中有不必要的 import
java.lang.import.problem.descriptor='java.lang' 軟體套件中有不必要的 import #loc
jdbc.execute.with.non.constant.string.display.name='Statement.execute()' 呼叫具有非常數字串
jdbc.execute.with.non.constant.string.problem.descriptor=<code>Statement.#ref()</code> 呼叫具有非常數實參 #loc
jdbc.prepare.statement.with.non.constant.string.display.name='Connection.prepare*()' 呼叫具有非常數字串
jdbc.prepare.statement.with.non.constant.string.problem.descriptor=<code>Connection.#ref()</code> 呼叫具有非常數實參 #loc
jdbc.resource.opened.not.closed.display.name=JDBC 資源已開啟，但未安全關閉
jndi.resource.opened.not.closed.display.name=JNDI 資源已開啟，但未安全關閉
junit.abstract.test.class.naming.convention.element.description=Abstract 測試類別
junit.test.class.naming.convention.element.description=測試類別
junit.test.suite.naming.convention.element.description=測試套件
junit3.method.naming.convention.element.description=JUnit 3 測試方法
junit3.style.test.method.in.junit4.class.display.name=JUnit 4 類別中的舊樣式 JUnit 測試方法
junit3.style.test.method.in.junit4.class.problem.descriptor=JUnit 4 類別中的舊樣式 JUnit 測試方法 <code>#ref()</code> #loc
junit4.method.naming.convention.element.description=JUnit 4+ 測試方法
key.set.iteration.may.use.entry.set.display.name=可以最佳化對 'keySet()' 的迭代
key.set.iteration.may.use.entry.set.problem.descriptor=<code>#ref</code> 上的迭代可被取代為 ''{0}'' 迭代 #loc
key.set.iteration.may.use.entry.set.quickfix=最佳化 Map 迭代
labeled.statement.display.name=標記語句
labeled.statement.problem.descriptor=標記語句 <code>#ref:</code> #loc
lambda.body.can.be.code.block.name=lambda 體可以是程式碼塊
lambda.body.can.be.code.block.quickfix=將 lambda 體擴展為 {...}
lambda.can.be.replaced.with.anonymous.name=lambda 可被取代為匿名類別
lambda.can.be.replaced.with.anonymous.quickfix=將 lambda 取代為匿名類別
lambda.parameter.hides.member.variable.display.name=lambda 參數隱藏欄位
lambda.parameter.hides.member.variable.ignore.invisible.option=忽略從 lambda 實際不可見的欄位
lambda.parameter.hides.member.variable.problem.descriptor=lambda 參數 <code>#ref</code> 隱藏類別 ''{0}'' 中的欄位 #loc
lambda.parameter.naming.convention.display.name=lambda 參數命名約定
lambda.parameter.naming.convention.element.description=lambda 參數
lambda.parameter.type.can.be.specified.descriptor=Lambda 參數類型可以擴展為{0}
lambda.parameter.type.can.be.specified.family.quickfix=指定 lambda 參數類型
lambda.parameter.type.can.be.specified.name=可以指定 lambda 參數類型
lambda.parameter.type.can.be.specified.quickfix=將參數類型擴展為{0}
lambda.unfriendly.constructor.overload.problem.descriptor=建構函式 <code>#ref()</code> 的多載對 lambda 不友好
lambda.unfriendly.method.overload.display.name=方法多載對 lambda 不友好
lambda.unfriendly.method.overload.problem.descriptor=方法 <code>#ref()</code> 的多載對 lambda 不友好
large.array.allocation.no.outofmemoryerror.display.name=沒有 OutOfMemoryError 檢查的大型陣列分配
large.array.allocation.no.outofmemoryerror.maximum.number.of.elements.option=最大元素數:
large.array.allocation.no.outofmemoryerror.problem.descriptor=未檢查記憶體不足情況的大型陣列分配 #loc
large.initializer.primitive.type.array.display.name=原始類型陣列的過大初始設定式
large.initializer.primitive.type.array.maximum.number.of.elements.option=最大元素數:
large.initializer.primitive.type.array.problem.descriptor=具有太多元素 ({0}) 的原始陣列初始設定式 #loc
law.of.demeter.display.name=迪米特法則
law.of.demeter.field.problem.descriptor=對 <code>#ref()</code> 的存取違反迪米特法則 #loc
law.of.demeter.ignore.library.calls.option=忽略對庫方法的呼叫和對庫欄位的存取
law.of.demeter.problem.descriptor=對 <code>#ref()</code> 的呼叫違反迪米特法則 #loc
length.one.string.in.indexof.display.name= 'String.indexOf()' 呼叫中的單字元字串實參
length.one.strings.in.concatenation.display.name=單字元字串串聯
length.one.strings.in.concatenation.replace.quickfix=取代為字元
limited.scope.inner.class.display.name=區域類別
limited.scope.inner.class.problem.descriptor=區域類別 <code>#ref</code> #loc
list.indexof.replaceable.by.contains.display.name='List.indexOf()' 表達式可被取代為 'contains()'
listener.may.use.adapter.display.name=類別可以擴展適配器而不是實作偵聽器
listener.may.use.adapter.emtpy.methods.option=僅在找到空實作方法時發出警告(&O)
listener.may.use.adapter.fix.family.name=取代為適配器
listener.may.use.adapter.problem.descriptor=類別 ''{0}'' 可以擴展 ''{1}'' 而不是實作 <code>#ref</code> #loc
literal.as.arg.to.string.equals.display.name=字串文字可以為 'equals()' 限定符
literal.as.arg.to.string.equals.flip.quickfix=翻轉 ''{0}()''
literal.as.arg.to.string.equals.problem.descriptor=文字 #ref 是 ''{0}()'' 的實參，而不是其限定符 #loc
load.library.with.non.constant.string.display.name='System.loadLibrary()' 呼叫具有非常數字串
load.library.with.non.constant.string.problem.descriptor=<code>{0}.#ref()</code> 呼叫具有非常數實參 #loc
local.variable.hides.member.variable.display.name=區域變數隱藏欄位
local.variable.hides.member.variable.ignore.option=忽略隱藏非 static 欄位的 static 上下文中的區域變數
local.variable.hides.member.variable.problem.descriptor=區域變數 <code>#ref</code> 隱藏類別 ''{0}'' 中的欄位 #loc
local.variable.naming.convention.display.name=區域變數命名約定
local.variable.naming.convention.element.description=區域變數
local.variable.naming.convention.ignore.catch.option=忽略 'catch' 塊參數
local.variable.naming.convention.ignore.option=忽略 for 迴圈參數
local.variable.of.concrete.class.problem.descriptor=具體類別 <code>#ref</code> 的區域變數 ''{0}'' #loc
log.condition.text=日誌條件文本
log.method.name=記錄方法名稱
log.statement.guarded.by.log.condition.display.name=日誌呼叫不受日誌條件保護
log.statement.guarded.by.log.condition.flag.all.unguarded.option=標記所有不受保護的日誌呼叫
log.statement.guarded.by.log.condition.problem.descriptor=<code>#ref()</code> 日誌呼叫不受日誌條件保護 #loc
log.statement.guarded.by.log.condition.quickfix=使用日誌條件包圍
logger.class.name=記錄器類別名:
logger.factory.class.name=記錄器工廠類別名
logger.factory.method.name=記錄器工廠方法名稱
logger.initialized.with.foreign.class.display.name=使用外類別初始化記錄器
logger.initialized.with.foreign.class.fix.family.name=取代外類別
logger.initialized.with.foreign.class.ignore.non.public.classes.option=忽略非 public 類別中的記錄器
logger.initialized.with.foreign.class.ignore.super.class.option=忽略使用超類別初始化的記錄器
logger.initialized.with.foreign.class.problem.descriptor=使用外類別 <code>#ref</code> 初始化記錄器 #loc
logger.name.option=記錄器類別名(&C):
long.literals.ending.with.lowercase.l.display.name='long' 文字以 'l' 而不是 'L' 結尾
long.literals.ending.with.lowercase.l.problem.descriptor='long' 文字 <code>#ref</code> 以小寫 'l' 結尾 #loc
loop.condition.not.updated.inside.loop.display.name=迴圈變數未在迴圈內更新
loop.condition.not.updated.inside.loop.problem.descriptor=條件 '#ref' 未在迴圈內更新#loc
loop.statements.that.dont.loop.display.name=不迴圈的迴圈語句
loop.statements.that.dont.loop.problem.descriptor=<code>#ref</code> 語句未迴圈 #loc
loop.variable.not.updated.inside.loop.option.nonlocal=忽略可能的非本地更改
loop.variable.not.updated.inside.loop.problem.descriptor=變數 '#ref' 未在迴圈內更新#loc
loop.with.implicit.termination.condition.display.name=具有隱式終止條件的迴圈
loop.with.implicit.termination.condition.dowhile.problem.descriptor=具有隱式終止條件的 <code>#ref-while</code> 迴圈 #loc
loop.with.implicit.termination.condition.problem.descriptor=具有隱式終止條件的 <code>#ref</code> 迴圈 #loc
loop.with.implicit.termination.condition.quickfix=使條件顯式
magic.character.display.name=魔幻字元
magic.character.problem.descriptor=國際化上下文中使用的魔幻字元 <code>#ref</code> #loc
magic.number.display.name=幻數
magic.number.problem.descriptor=幻數 <code>#ref</code> #loc
make.class.final.fix.family.name=將類別設為 final
make.class.final.fix.name=將類別 ''{0}'' 設為 ''final''
make.constructor.public=將建構函式設為 'public'
make.field.final.fix.family.name=設為 final
make.field.final.quickfix=將 ''{0}'' 設為 ''final''
make.field.static.final.fix.family.name=設為 static final
make.initialization.explicit.quickfix=使初始化顯式
make.method.ctr.quickfix=使方法成為建構函式
make.method.final.fix.family.name=將方法設為 'final'
make.method.final.fix.name=將方法 ''{0}()'' 設為 ''final''
make.package.private.fix.family.name=設為 package-private
make.static.final.quickfix=將 ''{0}'' 設為 static final
make.static.quickfix=設為 'static'
malformed.format.string.display.name=字串的格式錯誤
malformed.format.string.problem.descriptor.arguments.do.not.match.type=實參類型 ''{0}'' 與格式說明符 ''{1}'' 的類型不符合 #loc
malformed.format.string.problem.descriptor.at.least.too.few.arguments=格式字串的實參過少(實際: {0}，至少應為: {1}) #loc
malformed.format.string.problem.descriptor.illegal=非法格式字串指定符: {0} #loc
malformed.format.string.problem.descriptor.malformed=格式字串 <code>#ref</code> 的格式錯誤 #loc
malformed.format.string.problem.descriptor.too.few.arguments=格式字串的實參太少(實際: {0}，應為: {1}) #loc
malformed.format.string.problem.descriptor.too.many.arguments=格式字串的實參太多(實際: {0}，應為: {1}) #loc
manual.array.copy.display.name=手動陣列複製
manual.array.copy.problem.descriptor=手動陣列複製 #loc
manual.array.to.collection.copy.display.name=手動陣列到集合複製
manual.array.to.collection.copy.problem.descriptor=手動陣列到集合複製 #loc
map.replaceable.by.enum.map.display.name='Map' 可被取代為 'EnumMap'
map.replaceable.by.enum.map.problem.descriptor=<code>#ref</code> 可被取代為 'EnumMap' #loc
mark.modules.as.loaded.together.fix.family.name=將模組標記為一起載入
mark.modules.as.loaded.together.fix.text=將 ''{0}'' 和 ''{1}'' 模組標記為一起載入
marker.interface.display.name=標記接口
marker.interface.problem.descriptor=標記接口 <code>#ref</code> #loc
masked.assertion.display.name=斷言通過 'catch' 禁止
masked.assertion.problem.description=''{0}'' 不能失敗，因為它被包圍 ''catch'' 禁止
math.random.cast.to.int.display.name='Math.random()' 轉換為 'int'
math.random.cast.to.int.problem.descriptor=<code>#ref</code> 轉換為 ''{0}'' 時始終向下舍入為 ''0'' #loc
math.random.cast.to.int.quickfix=新增括號以在轉換前執行乘法
math.rounding.with.int.argument.display.name=使用 'int' 實參呼叫數學舍入
math.rounding.with.int.argument.family.name=簡化舍入呼叫
math.rounding.with.int.argument.problem.descriptor=帶有 'int' 類型實參的 <code>#ref()</code> #loc
math.rounding.with.int.argument.quickfix=簡化 ''{0}()'' 呼叫
meta.annotation.without.runtime.retention=不含 '@Retention(RUNTIME)' 註解的測試註解
method.call.in.loop.condition.display.name=迴圈條件下的方法呼叫
method.call.in.loop.condition.problem.descriptor=迴圈條件下呼叫方法 <code>#ref()</code> #loc
method.can.be.variable.arity.method.display.name=方法可以有 varargs 參數
method.can.be.variable.arity.method.ignore.all.primitive.arrays.option=忽略所有原始陣列類型
method.can.be.variable.arity.method.ignore.byte.short.option=忽略具類型為 byte[] 或 short[] 的參數
method.can.be.variable.arity.method.ignore.multidimensional.arrays.option=忽略多維陣列參數
method.can.be.variable.arity.method.ignore.multiple.arrays.option=忽略具有多個陣列參數的方法
method.can.be.variable.arity.method.problem.descriptor=<code>#ref()</code> 可以轉換為 vararg 方法 #loc
method.complexity.limit.option=方法復雜度限制:
method.count.ignore.getters.setters.option=忽略簡單的 getter 和 setter 方法(&I)
method.count.limit.option=方法計數限制:
method.coupling.display.name=過度耦合的方法
method.coupling.limit.option=方法耦合限制:
method.coupling.problem.descriptor=<code>#ref</code> 過度耦合 (# 參照的類別 = {0}) #loc
method.may.be.static.display.name=方法可以為 'static'
method.may.be.static.empty.option=忽略空方法
method.may.be.static.ignore.default.methods.option=忽略 'default' 方法
method.may.be.static.only.option=僅檢查 'private' 或 'final' 方法
method.may.be.static.problem.descriptor=方法 <code>#ref()</code> 可能為 'static' #loc
method.may.be.static.replaces.qualifiers.with.class.references.option=快速修復可將實例限定符取代為類別參照
method.may.be.synchronized.display.name=只有一個 'synchronized' 塊的方法可被取代為 'synchronized' 方法
method.may.be.synchronized.problem.descriptor=帶 synchronized 塊的方法 <code>#ref()</code> 可以是 synchronized 方法 #loc
method.may.be.synchronized.quickfix=將方法設為 synchronized 並移除 synchronized 塊
method.name.regex=方法名稱正則表達式
method.name.same.as.class.name.display.name=方法名稱與類別名相同
method.name.same.as.class.name.problem.descriptor=方法名稱 <code>#ref</code> 與其類別名相同 #loc
method.name.same.as.parent.name.display.name=方法名稱與父類別名相同
method.name.same.as.parent.name.problem.descriptor=方法名稱 <code>#ref</code> 與其父類別名相同 #loc
method.names.differ.only.by.case.display.name=方法名稱僅大小寫不同
method.names.differ.only.by.case.problem.descriptor=方法名稱 <code>#ref</code> 和方法名稱 ''{0}'' 僅大小寫不同 #loc
method.only.used.from.inner.class.display.name=僅在內部類中使用 private 方法
method.only.used.from.inner.class.ignore.option=忽略從匿名類別或區域類別呼叫的方法(&A)
method.only.used.from.inner.class.problem.descriptor=方法 <code>#ref()</code>#loc 只能從{0, choice, 1#內部|2#區域|3#}{1, choice, 1#類別|2#接口|3#派生的匿名類別|4#註解類型|5#枚舉|6#記錄} ''{2}'' 使用 #loc
method.overloads.display.name=可能是超類別方法意外多載
method.overloads.problem.descriptor=當可能打算覆寫時，方法 <code>#ref()</code> 多載超類別的相容方法 #loc
method.overloads.report.incompatible.option=即使參數類型不相容，也會報告
method.overrides.inaccessible.method.display.name=方法覆寫了超類別不可存取的方法
method.overrides.package.local.method.problem.descriptor=方法 <code>#ref()</code> 覆寫了位於另一個軟體套件中的超類別的 package-private 方法 #loc
method.overrides.private.display.name.problem.descriptor=方法 <code>#ref()</code> 重寫了超類別的 'private' 方法 #loc
method.overrides.static.display.name=方法嘗試覆寫超類別的 'static' 方法
method.overrides.static.problem.descriptor=方法 <code>#ref()</code> 嘗試覆寫超類別的 static 方法 #loc
method.ref.can.be.replaced.with.lambda.name=方法參照可被取代為 lambda
method.ref.can.be.replaced.with.lambda.quickfix=將方法參照取代為 lambda
method.return.always.constant.display.name=方法返回類別特定的常數
method.return.always.constant.problem.descriptor=方法 <code>#ref()</code> 及其所有派生方法始終返回常數
method.return.concrete.class.problem.descriptor=方法返回一個具體類別 <code>#ref</code> #loc
method.with.multiple.loops.display.name=具有多個迴圈的方法
method.with.multiple.loops.problem.descriptor=<code>#ref</code> 包含 {0} 個迴圈 #loc
mismatched.read.write.array.display.name=陣列的讀取和寫入不符合
mismatched.read.write.array.problem.descriptor.read.not.write=陣列 <code>#ref</code> 的內容已讀取，但從未被寫入 #loc
mismatched.read.write.array.problem.descriptor.write.not.read=陣列 <code>#ref</code> 的內容已寫入，但從未被讀取 #loc
mismatched.string.builder.queried.problem.descriptor=<code>{0} #ref</code> 的內容已查詢，但從未更新 #loc
mismatched.string.builder.query.update.display.name='StringBuilder' 的查詢和更新不符合
mismatched.string.builder.updated.problem.descriptor=<code>{0} #ref</code> 的內容已更新，但從未被查詢 #loc
mismatched.update.collection.display.name=不符合的集合查詢和更新
mismatched.update.collection.problem.description.queried.not.updated=集合 <code>#ref</code> 的內容已被查詢，但從未更新 #loc
mismatched.update.collection.problem.descriptor.updated.not.queried=集合 <code>#ref</code> 的內容已更新，但從未被查詢 #loc
misordered.assert.equals.arguments.display.name=順序錯誤的 'assertEquals()' 實參
misordered.assert.equals.arguments.flip.quickfix=翻轉比較實參
misordered.assert.equals.arguments.problem.descriptor=<code>#ref()</code> 的實參順序錯誤 #loc
missing.add.deprecated.javadoc.tag.quickfix=新增 '@deprecated' Javadoc 標記說明
missing.deprecated.annotation.add.quickfix=新增 '@Deprecated' 註解
missing.deprecated.annotation.display.name=缺少 '@Deprecated' 註解
missing.deprecated.annotation.problem.descriptor=缺少 '@Deprecated' 註解 #loc
missing.deprecated.tag.option=警告缺少 @deprecated Javadoc 標記說明
missing.deprecated.tag.problem.descriptor=缺少 '@deprecated' Javadoc 標記說明 #loc
missing.override.annotation.display.name=缺少 '@Override' 註解
missing.override.annotation.in.overriding.problem.descriptor=覆寫方法未使用 '@Override' 註解
missing.override.annotation.problem.descriptor=缺少關於 <code>#ref()</code> 的 '@Override' 註解 #loc
missing.override.warn.on.super.option=當方法的覆寫方法並非全部具有 '@Override' 註解時，醒目提示該方法
missing.package.html.problem.descriptor=軟體套件 ''{0}'' 缺少 <code>package.html</code> 檔案
missing.package.info.display.name=缺少 'package-info.java'
missing.package.info.problem.descriptor=軟體套件 ''{0}'' 缺少 <code>package-info.java</code> 檔案
missing.serial.annotation.display.name=可以使用 '@Serial' 註解
missing.serial.annotation.on.field.problem.descriptor=<code>#ref</code> 可以使用 '@Serial' 進行註解
missing.serial.annotation.on.method.problem.descriptor=<code>#ref()</code> 可以使用 '@Serial' 進行註解
missorted.modifiers.display.name=錯位修飾符
missorted.modifiers.problem.descriptor=錯位修飾符 <code>{0}</code> #loc
missorted.modifiers.require.option=檢查註解順序
missorted.modifiers.sort.quickfix=對修飾符排序
missorted.modifiers.typeuse.before.type.option=目標 TYPE_USE 註解始終位於類型前
misspelled.equals.display.name='equal()' 代替 'equals()'
misspelled.equals.problem.descriptor=<code>#ref()</code> 方法可能應當是 'equals()' #loc
module.with.too.few.classes.display.name=類別過少的模組
module.with.too.few.classes.min.option=最小類別數:
module.with.too.few.classes.problem.descriptor=模組 ''{0}'' 包含過少的類別 ({1} < {2})
module.with.too.many.classes.display.name=類別過多的模組
module.with.too.many.classes.max.option=最大類別數:
module.with.too.many.classes.problem.descriptor=模組 ''{0}'' 包含過多的類別 ({1} > {2})
move.anonymous.to.inner.quickfix=轉換為命名內部類別
move.class.quickfix=移動類別
move.exception.to.javadoc.fix.family.name=移至 Javadoc '@throws'
multi.catch.can.be.split.name=多 catch 可拆分為單獨的 catch 塊
multi.catch.can.be.split.quickfix=將多 catch 拆分為單獨的 'catch' 塊
multiple.declaration.array.only.option=僅在單個宣告中對不同的陣列維度發出警告
multiple.declaration.display.name=一個宣告中的多個變數
multiple.declaration.ignore.for.option=忽略 'for' 迴圈宣告
multiple.declaration.problem.descriptor=一個宣告中的多個變數 #loc
multiple.exceptions.declared.on.test.method.display.name=在測試方法上宣告的多個異常
multiple.exceptions.declared.on.test.method.problem.descriptor=<code>#ref</code> 可被取代為 'throws Exception' #loc
multiple.loggers.display.name=具有多個記錄器的類別
multiple.loggers.problem.descriptor=類別 <code>#ref</code> 宣告多個記錄器 #loc
multiple.return.points.per.method.display.name=具有多個返回點的方法
multiple.return.points.per.method.problem.descriptor=<code>#ref</code> 具有 {0} 個返回點 #loc
multiple.top.level.classes.in.file.display.name=單個檔案中的多個頂級類別
multiple.top.level.classes.in.file.problem.descriptor=檔案中的多個頂級類別
multiple.typed.declaration.problem.descriptor=在一個宣告中具有不同陣列維度的變數 #loc
multiply.or.divide.by.power.of.two.display.name=乘以或除以 2 的冪
multiply.or.divide.by.power.of.two.divide.option=還通過 2 的冪檢查除法
multiply.or.divide.by.power.of.two.replace.quickfix=取代為移位
naked.notify.display.name=沒有相應狀態更改的 'notify()' 或 'notifyAll()'
naked.notify.problem.descriptor=在沒有相應狀態更改的情況下呼叫 <code>#ref()</code> #loc
naming.convention.problem.descriptor.long={0} 名稱 <code>#ref</code> 過長({1} > {2}) #loc
naming.convention.problem.descriptor.regex.mismatch={0} 名稱 <code>#ref</code> 不符合正則表達式 ''{1}'' #loc
naming.convention.problem.descriptor.short={0} 名稱 <code>#ref</code> 過短({1} < {2}) #loc
native.method.display.name=本地方法
native.method.naming.convention.element.description='native' 方法
native.method.problem.descriptor=宣告為 <code>#ref</code> 的方法不可移植 #loc
negated.conditional.display.name=具有否定條件的條件表達式
negated.conditional.expression.display.name=否定條件表達式
negated.conditional.expression.problem.descriptor=否定條件表達式 #loc
negated.conditional.expression.quickfix=移除否定
negated.conditional.invert.quickfix=反轉條件
negated.conditional.problem.descriptor=具有否定條件的條件表達式 #loc
negated.equality.expression.display.name=否定相等表達式
negated.equality.expression.problem.descriptor=否定 ''{0}'' #loc
negated.equality.expression.quickfix=移除否定
negated.if.else.display.name=具有否定條件的 'if' 語句
negated.if.else.ignore.negated.null.option=忽略 '!= null' 比較
negated.if.else.ignore.negated.zero.option=忽略 '!= 0' 比較
negated.if.else.invert.quickfix=反轉 'if' 條件
negated.if.else.problem.descriptor=帶嵌套條件的 <code>#ref</code> 語句 #loc
negative.int.constant.in.long.context.display.name=長整數型上下文中的負整數型十六進制常數
negative.int.constant.in.long.context.fix.add.suffix=新增 'L' 後綴(更改語意)
negative.int.constant.in.long.context.fix.convert=轉換為長整數型常數(保留語意)
negatively.named.boolean.variable.display.name=否定命名的布爾變數
negatively.named.boolean.variable.problem.descriptor=布爾變數 <code>#ref</code> 已否定命名 #loc
nested.assignment.display.name=嵌套賦值
nested.assignment.problem.descriptor=使用的賦值表達式的結果 #loc
nested.conditional.expression.display.name=嵌套條件表達式
nested.conditional.expression.problem.descriptor=嵌套條件表達式 <code>#ref</code> #loc
nested.method.call.display.name=嵌套方法呼叫
nested.method.call.ignore.option=忽略欄位初始設定式中的嵌套方法呼叫
nested.method.call.problem.descriptor=嵌套方法呼叫 <code>#ref()</code> #loc
nested.switch.statement.display.name=嵌套 'switch' 語句
nested.switch.statement.problem.descriptor=嵌套 <code>#ref</code> {0} #loc
nested.synchronized.statement.display.name=嵌套 'synchronized' 語句
nested.synchronized.statement.problem.descriptor=嵌套 <code>#ref</code> 語句 #loc
nested.try.statement.display.name=嵌套 'try' 語句
nested.try.statement.problem.descriptor=嵌套 <code>#ref</code> 語句 #loc
nesting.depth.display.name=過度嵌套的方法
nesting.depth.limit.option=嵌套深度限制:
nesting.depth.problem.descriptor=<code>#ref</code> 過度嵌套 (最大嵌套深度 = {0}) #loc
new.exception.without.arguments.display.name=未使用實參呼叫異常建構函式
new.exception.without.arguments.problem.descriptor=<code>new #ref()</code> 沒有實參 #loc
new.method.naming.convention.display.name=方法命名約定
new.string.buffer.replaceable.by.string.problem.descriptor=<code>#ref</code> 可被取代為 'String' #loc
new.string.buffer.with.char.argument.display.name=StringBuilder 建構函式呼叫具有 'char' 實參
new.string.buffer.with.char.argument.problem.descriptor=<code>new #ref()</code> 具有 'char' 類型的實參 #loc
new.string.buffer.with.char.argument.quickfix=將字元實參取代為字串文字
no.logger.display.name=不帶記錄器的類別
no.logger.problem.descriptor=類別 <code>#ref</code> 未宣告記錄器 #loc
non.atomic.operation.on.volatile.field.display.name='volatile' 欄位上的非原子動作
non.atomic.operation.on.volatile.field.problem.descriptor=volatile 欄位 <code>#ref</code> 上的非原子動作 #loc
non.boolean.method.name.must.not.start.with.question.display.name=非布爾方法名稱不能以疑問詞開頭
non.boolean.method.name.must.not.start.with.question.problem.descriptor=非布爾方法名稱 <code>#ref</code> 以疑問詞開頭 #loc
non.comment.source.statements.display.name=過長的方法
non.comment.source.statements.limit.option=非註釋源語句限制:
non.comment.source.statements.problem.descriptor=<code>#ref</code> 過長 (# 非註釋源語句 = {0}) #loc
non.constant.logger.display.name=非常數記錄器
non.constant.logger.problem.descriptor=非常數記錄器欄位 <code>#ref</code> #loc
non.exception.name.ends.with.exception.display.name=非異常類別名以 'Exception' 結尾
non.exception.name.ends.with.exception.problem.descriptor=非異常類別名 <code>#ref</code> 以 'Exception' 結尾 #loc
non.exception.name.ends.with.exception.quickfix=使 ''{0}'' 擴展 ''java.lang.Exception''
non.final.clone.display.name=非 final 'clone()' 位於安全上下文中
non.final.clone.problem.descriptor=非 final <code>#ref()</code> 方法，影響安全性 #loc
non.final.field.compareto.display.name='compareTo()' 中參照了非 final 欄位
non.final.field.compareto.problem.descriptor=在 'compareTo()' 中存取了非 final 欄位 <code>#ref</code> #loc
non.final.field.in.enum.display.name='enum' 中的非 final 欄位
non.final.field.in.enum.problem.descriptor=枚舉 ''{0}'' 中存在非 final 欄位 <code>#ref</code> #loc
non.final.field.in.enum.quickfix.option=忽略無法成為 'final' 的欄位
non.final.field.in.equals.display.name='equals()' 中參照了非 final 欄位
non.final.field.in.equals.problem.descriptor=在 'equals()' 中存取了非 final 欄位 <code>#ref</code> #loc
non.final.field.in.hashcode.display.name='hashCode()' 中參照了非 final 欄位
non.final.field.in.hashcode.problem.descriptor=在 'hashCode()' 中存取了非 final 欄位 <code>#ref</code> #loc
non.final.field.of.exception.display.name='Exception' 類別的非 final 欄位
non.final.field.of.exception.problem.descriptor=異常類別的非 final 欄位 <code>#ref</code> #loc
non.final.static.variable.initialization.display.name=在類別初始化期間使用非 final static 欄位
non.final.static.variable.initialization.problem.descriptor=在類別初始化期間使用非 final static 欄位 <code>#ref</code> #loc
non.final.utility.class.display.name=實用程序類別不為 'final'
non.final.utility.class.problem.descriptor=實用程序類別 <code>#ref</code> 不為 'final' #loc
non.protected.constructor.in.abstract.class.display.name=抽象類別中的 public 建構函式
non.protected.constructor.in.abstract.class.ignore.option=對非 public 類別忽略
non.protected.constructor.in.abstract.class.problem.descriptor=抽象類別的建構函式 <code>#ref()</code> 不應宣告為 'public' #loc
non.public.clone.display.name='clone()' 方法不是 'public'
non.public.clone.problem.descriptor=<code>#ref()</code> 方法不是 'public' #loc
non.reproducible.math.call.display.name=對 'Math' 的不可重現呼叫
non.reproducible.math.call.problem.descriptor=<code>Math.#ref()</code> 可能產生不可重現的結果 #loc
non.reproducible.math.call.replace.quickfix=取代為 'StrictMath' 呼叫
non.serializable.@interface.with.serialversionuid.problem.descriptor=定義 'serialVersionUID' 欄位的不可序列化 @interface <code>#ref</code> #loc
non.serializable.anonymous.with.serialversionuid.problem.descriptor=派生自 <code>#ref</code> 的不可序列化匿名類別定義 'serialVersionUID' 欄位 #loc
non.serializable.class.with.readwriteobject.display.name=具有 'readObject()' 或 'writeObject()' 的不可序列化類別
non.serializable.class.with.readwriteobject.problem.descriptor.both=不可序列化{0, choice, 1#類別|2#接口|3#派生的匿名類別|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'readObject()' 和 'writeObject()' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.read=不可序列化{0, choice, 1#類別|2#接口|3#派生的匿名類別|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'readObject()' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.write=不可序列化{0, choice, 1#類別|2#接口|3#派生的匿名類別|4#註解類型|5#枚舉|6#記錄} <code>#ref</code> 定義 'writeObject()' #loc
non.serializable.class.with.serialversionuid.problem.descriptor=定義 'serialVersionUID' 欄位的不可序列化類別 <code>#ref</code> #loc
non.serializable.field.in.serializable.class.display.name='Serializable' 類別中有不可序列化的欄位
non.serializable.field.in.serializable.class.problem.descriptor=可序列化類別中不可序列化的欄位 '#ref' #loc
non.serializable.interface.with.serialversionuid.problem.descriptor=定義 'serialVersionUID' 欄位的不可序列化接口 <code>#ref</code> #loc
non.serializable.object.bound.to.http.session.display.name=不可序列化的物件被綁定到了 'HttpSession'
non.serializable.object.bound.to.http.session.problem.descriptor=傳遞給 HttpSession 的不可序列化物件 #loc
non.serializable.object.passed.to.object.stream.display.name=不可序列化的物件被傳遞給了 'ObjectOutputStream'
non.serializable.object.passed.to.object.stream.problem.descriptor=傳遞給 ObjectOutputStream 的不可序列化物件 #loc
non.serializable.with.serialversionuid.display.name=具有 'serialVersionUID' 的不可序列化類別
non.short.circuit.boolean.expression.display.name=非短路布爾表達式
non.short.circuit.boolean.expression.problem.descriptor=非短路布爾表達式 <code>#ref</code> #loc
non.short.circuit.boolean.expression.replace.quickfix=取代為短路表達式
non.synchronized.method.overrides.synchronized.method.display.name=未同步方法覆寫 'synchronized' 方法
non.synchronized.method.overrides.synchronized.method.problem.descriptor=未同步方法 <code>#ref()</code> 覆寫 synchronized 方法 #loc
non.thread.safe.lazy.initialization.display.name=不安全的 'static' 欄位延遲初始化
non.thread.safe.lazy.initialization.problem.descriptor='static' 欄位 <code>#ref</code> 的延遲初始化不是執行緒安全 #loc
none=無
noop.method.in.abstract.class.display.name='abstract' 類別中的無運算方法
noop.method.in.abstract.class.problem.descriptor=無動作方法 <code>#ref()</code> 應當設為 abstract #loc
normalize.declaration.quickfix=拆分為單獨的宣告
not.object.equals.can.be.equality.problem.descriptor=<code>!#ref()</code> 可被取代為 '!='
notify.called.on.condition.display.name=在 'java.util.concurrent.locks.Condition' 物件上呼叫了 'notify()' 或 'notifyAll()'
notify.called.on.condition.problem.descriptor=在條件物件上呼叫 <code>#ref()</code> #loc
notify.without.corresponding.wait.display.name=沒有相應 'wait()' 的 'notify()'
notify.without.corresponding.wait.problem.descriptor=在沒有相應 <code>wait()</code> 的情況下呼叫 <code>#ref()</code> #loc
null.argument.to.var.arg.method.display.name=引起混淆的 vararg 方法實參
null.argument.to.var.arg.method.problem.descriptor=引起混淆的實參 <code>#ref</code>，不清楚是否需要 vararg 或非 vararg 呼叫 #loc
null.thrown.display.name=已拋出 'null'
null.thrown.problem.descriptor=已拋出 <code>#ref</code> #loc
number.comparison.display.name=使用 '==' 而不是 'equals()' 進行數字比較
number.comparison.problem.descriptor=使用 <code>#ref</code> 而不是 'equals()' 來比較數字物件 #loc
object.allocation.in.loop.display.name=迴圈中的物件分配
object.allocation.in.loop.new.descriptor=迴圈中的物件分配 <code>new #ref()</code> #loc
object.allocation.in.loop.problem.array.initializer.descriptor=迴圈中的陣列分配 #loc
object.allocation.in.loop.problem.call.descriptor=物件分配通過迴圈中的 <code>#ref()</code> 呼叫完成 #loc
object.allocation.in.loop.problem.lambda.descriptor=物件分配通過捕獲迴圈中的 lambda 完成 #loc
object.allocation.in.loop.problem.methodref.descriptor=物件分配通過迴圈中的實例綁定方法參照 <code>#ref()</code> 完成 #loc
object.allocation.in.loop.problem.string.concat=物件分配通過迴圈中的字串串聯完成 #loc
object.comparison.display.name=使用 '==' 而不是 'equals()' 進行物件比較
object.comparison.enumerated.ignore.option=忽略枚舉變數之間的 '=='
object.comparison.klass.ignore.option=忽略沒有 'equals()' 實作的 final 類別類型之間的 '=='
object.comparison.problem.description=使用 <code>#ref</code> 而不是 'equals()' 來比較物件值 #loc
object.equality.ignore.between.objects.of.a.type.with.only.private.constructors.option=忽略只有 'private' 建構函式的類型物件之間的 '=='
object.equals.can.be.equality.display.name='equals()' 呼叫可被取代為 '=='
object.equals.can.be.equality.problem.descriptor=<code>#ref()</code> 可被取代為 '=='
object.instantiation.inside.equals.or.hashcode.display.name='equals()' 或 'hashCode()' 內部的物件實例化
object.instantiation.inside.equals.or.hashcode.problem.descriptor=''{0}()'' 內部的物件實例化 #loc
object.instantiation.inside.equals.or.hashcode.problem.descriptor2=''{0}()'' ({1}) 內部的物件實例化 #loc
object.notify.display.name=呼叫 'notify()' 而不是 'notifyAll()'
object.notify.problem.descriptor=<code>#ref</code> 可能應當取代為 'notifyAll()' #loc
objects.hash.fix.family.name=使用 'Arrays.hashCode()' 包裝
objects.hash.problem.descriptor=傳遞給 'Objects.hash()' 的陣列應包裝在 'Arrays.hashcode()' 中
octal.and.decimal.integers.in.same.array.display.name=同一陣列中的八進制和十進制整數
octal.and.decimal.integers.in.same.array.problem.descriptor=同一陣列初始設定式中的八進制和十進制整數 #loc
octal.literal.display.name=八進制整數
octal.literal.problem.descriptor=八進制整數 <code>#ref</code> #loc
only.report.public.methods.option=僅報告 'public' 方法
only.report.qualified.static.usages.option=僅報告來自 static 上下文的限定靜態存取
only.report.static.methods=僅報告 'static' 方法(&O)
only.warn.on.protected.clone.methods=僅對 'protected' 克隆方法發出警告
only.warn.on.public.clone.methods=僅對 'public' 克隆方法發出警告
optional.contains.array.problem.descriptor='Optional' 包含陣列 <code>#ref</code>
optional.contains.collection.display.name='Optional' 包含陣列或集合
optional.contains.collection.problem.descriptor='Optional' 包含集合 <code>#ref</code>
optional.used.as.field.or.parameter.type.display.name=用作欄位或參數類型的 'Optional'
optional.used.as.field.type.problem.descriptor=<code>#ref</code> 用作欄位 ''{0}'' 的類型
optional.used.as.parameter.type.problem.descriptor=<code>#ref</code> 用作參數 ''{0}'' 的類型
options.label.ignored.classes=已忽略的類別:
options.title.ignored.classes=已忽略的類別
overloaded.methods.with.same.number.parameters.display.name=具有相同參數數量的多載方法
overloaded.methods.with.same.number.parameters.option=<html>忽略參數類型絕對不相容的多載方法</html>
overloaded.methods.with.same.number.parameters.problem.descriptor=具有相同數量參數的多個方法命名 <code>#ref</code> #loc
overloaded.vararg.constructor.problem.descriptor=多載 vararg 建構函式 <code>#ref()</code> #loc
overloaded.vararg.method.display.name=多載 vararg 方法
overloaded.vararg.method.problem.descriptor=多載 vararg 方法 <code>#ref()</code> #loc
overloaded.vararg.method.problem.option=忽略參數類型絕對不相容的多載方法
overly.broad.throws.clause.display.name=過寬的 'throws' 子句
overly.broad.throws.clause.ignore.thrown.option=忽略隱藏其他異常但自身被拋出的異常(&H)
overly.broad.throws.clause.problem.descriptor1=<code>throws #ref</code> 過寬，遮罩異常 ''{0}'' #loc
overly.broad.throws.clause.problem.descriptor2=<code>throws #ref</code> 過寬，遮罩異常 ''{0}'' 和 ''{1}'' #loc
overly.broad.throws.clause.quickfix1=新增特定異常
overly.broad.throws.clause.quickfix2=取代為特定異常
overly.broad.throws.clause.threshold.option=要報告的最大隱藏異常數:
overly.complex.anonymous.inner.class.display.name=過度複雜的匿名類別
overly.complex.anonymous.inner.class.problem.descriptor=過度複雜的匿名類別 (迴圈復雜度 = {0}) #loc
overly.complex.arithmetic.expression.display.name=過於複雜的算術表達式
overly.complex.arithmetic.expression.max.number.option=最大項數:
overly.complex.arithmetic.expression.problem.descriptor=過於複雜的算術表達式 #loc
overly.complex.boolean.expression.display.name=過度複雜的布爾表達式
overly.complex.boolean.expression.ignore.option=忽略純合取和析取
overly.complex.boolean.expression.max.terms.option=最大項數:
overly.complex.boolean.expression.problem.descriptor=過度複雜的布爾表達式 ({0} 項) #loc
overly.complex.class.display.name=過度複雜的類別
overly.complex.class.problem.descriptor=過度複雜的類別<code>#ref</code> (迴圈復雜度 = {0}) #loc
overly.coupled.class.class.coupling.limit.option=類別耦合限制:
overly.coupled.class.display.name=過度耦合的類別
overly.coupled.class.problem.descriptor=<code>#ref</code> 過度耦合 (相依 = {0}) #loc
overly.long.lambda.display.name=過長的 lambda 表達式
overly.long.lambda.problem.descriptor=lambda 表達式過長 (# 非註釋源語句 = {0}) #loc
overly.strong.type.cast.display.name=過強的類型轉換
overly.strong.type.cast.ignore.in.matching.instanceof.option=忽略具有符合 instanceof 表達式的轉換
overly.strong.type.cast.problem.descriptor=到 <code>#ref</code> 的轉換可以被削弱為 ''{0}'' #loc
overly.strong.type.cast.weaken.quickfix=削弱過強的轉換
overridable.method.call.in.constructor.display.name=物件建構期間呼叫的可覆寫方法
overridable.method.call.in.constructor.problem.descriptor=物件建構期間呼叫可覆寫方法 <code>#ref()</code> #loc
overridden.method.call.in.constructor.display.name=覆寫的方法在物件建構期間呼叫
overridden.method.call.in.constructor.problem.descriptor=物件建構期間呼叫已覆寫方法 <code>#ref()</code> #loc
package.dot.html.may.be.package.info.convert.quickfix=轉換為 'package-info.java'
package.dot.html.may.be.package.info.delete.quickfix=刪除 'package.html'
package.dot.html.may.be.package.info.display.name='package.html' 可以轉換為 'package-info.java'
package.dot.html.may.be.package.info.exists.problem.descriptor=<code>package.html</code> 被忽略，因為 <code>package-info.java</code> 存在
package.dot.html.may.be.package.info.problem.descriptor=<code>package.html</code> 可以轉換為 <code>package-info.java</code>
package.in.multiple.modules.display.name=具有多個模組中的類別的軟體套件
package.in.multiple.modules.problem.descriptor.many=軟體套件 ''{0}'' 具有模組 ''{1}''、''{2}'' 以及其他 {3} 個模組中的類別
package.in.multiple.modules.problem.descriptor2=軟體套件 ''{0}'' 具有模組 ''{1}'' 和 ''{2}'' 中的類別
package.in.multiple.modules.problem.descriptor3=軟體套件 ''{0}'' 具有模組 ''{1}''、''{2}'' 和 ''{3}'' 中的類別
package.info.java.without.package.display.name=不帶 'package' 語句的 'package-info.java'
package.info.without.package.family.quickfix=新增 package 語句
package.info.without.package.problem.descriptor='package-info.java' 沒有 'package' 語句
package.info.without.package.quickfix=新增 ''package {0};''
package.local.field.not.accessible=package-private 欄位 ''{0}'' 無法從此處存取
package.local.private=package-private 與 private
package.naming.convention.display.name=軟體套件命名約定
package.naming.convention.problem.descriptor.long=軟體套件名稱 <code>{0}</code> 過長
package.naming.convention.problem.descriptor.regex.mismatch=軟體套件名稱 <code>{0}</code> 與正則表達式 ''{1}'' 不符合
package.naming.convention.problem.descriptor.short=軟體套件名稱 <code>{0}</code> 過短
package.visible.field.display.name=軟體套件可見欄位
package.visible.field.problem.descriptor=軟體套件可見欄位 <code>#ref</code> #loc
package.visible.inner.class.display.name=軟體套件可見的嵌套類別
package.visible.inner.class.ignore.enum.option=忽略軟體套件可見的內部枚舉
package.visible.inner.class.ignore.interface.option=忽略軟體套件可見的內部接口
package.visible.inner.class.problem.descriptor=軟體套件可見的嵌套類別 <code>#ref</code> #loc
package.with.too.few.classes.display.name=軟體套件具有過少類別
package.with.too.few.classes.min.option=最小類別數:
package.with.too.few.classes.problem.descriptor=軟體套件 ''{0}'' 包含過少的類別 ({1} < {2})
package.with.too.many.classes.display.name=類別過多的軟體套件
package.with.too.many.classes.max.option=最大類別數:
package.with.too.many.classes.problem.descriptor=軟體套件 ''{0}'' 包含過多的類別 ({1} > {2})
parameter.hides.member.variable.display.name=參數隱藏欄位
parameter.hides.member.variable.ignore.abstract.methods.option=對 abstract 方法忽略
parameter.hides.member.variable.ignore.constructors.option=對建構函式忽略
parameter.hides.member.variable.ignore.setters.option=對屬性 setter 忽略
parameter.hides.member.variable.ignore.static.parameters.option=對隱藏實例欄位的 static 方法參數忽略
parameter.hides.member.variable.ignore.superclass.option=忽略從子類別不可見的超類別欄位
parameter.hides.member.variable.problem.descriptor=參數 <code>#ref</code> 隱藏類別 ''{0}'' 中的欄位 #loc
parameter.limit.option=參數限制:
parameter.name.differs.from.overridden.parameter.display.name=參數名稱與覆寫或多載方法中的參數不同
parameter.name.differs.from.overridden.parameter.ignore.character.option=如果覆寫的參數僅包含一個字元，則忽略
parameter.name.differs.from.overridden.parameter.ignore.library.option=如果覆寫的參數來自庫，則忽略
parameter.name.differs.from.overridden.parameter.problem.descriptor=參數名 <code>#ref</code> 不同於{1, choice, 1#super 方法|2#多載方法|3#super 建構函式|4#多載建構函式}中的參數 ''{0}'' #loc
parameter.naming.convention.display.name=方法參數命名約定
parameter.naming.convention.element.description=參數
parameter.type.prevents.overriding.display.name=參數類型阻止覆寫
parameter.type.prevents.overriding.family.quickfix=更改參數類型
parameter.type.prevents.overriding.problem.descriptor=參數類型 <code>#ref</code> 位於 ''{0}''，而 super 方法參數類型位於 ''{1}''，可防止覆寫 #loc
parameter.type.prevents.overriding.quickfix=將參數類型更改為 ''{0}''
parameters.per.constructor.display.name=參數過多的建構函式
parameters.per.constructor.problem.descriptor=<code>#ref()</code> 的參數過多(參數數量 = {0}) #loc
parameters.per.method.display.name=參數過多的方法
parameters.per.method.problem.descriptor=<code>#ref()</code> 的參數過多(參數數量 = {0}) #loc
pattern.variable.hides.field.display.name=模式變數隱藏欄位
pattern.variable.hides.field.problem.descriptor=模式變數 <code>#ref</code> 隱藏類別 ''{0}'' 中的欄位 #loc
pointless.arithmetic.expression.display.name=無意義的算術表達式
pointless.bitwise.expression.display.name=無意義的按位表達式
pointless.bitwise.expression.simplify.quickfix=簡化
pointless.boolean.expression.display.name=無意義的布爾表達式
pointless.boolean.expression.ignore.option=在確定無意義表達式時忽略命名常數
pointless.indexof.comparison.always.false.problem.descriptor=<code>#ref</code> 始終為 false #loc
pointless.indexof.comparison.always.true.problem.descriptor=<code>#ref</code> 始終為 true #loc
pointless.indexof.comparison.display.name=無意義的 'indexOf()' 比較
pointless.nullcheck.display.name=方法呼叫前出現不必要的 'null' 檢查
pointless.nullcheck.problem.descriptor.call=''{0}()'' 呼叫之前的 ''null'' 檢查不必要
possible.throw.from.finally.block.problem.descriptor=<code>{0}</code> 可能在 ''finally'' 塊內拋出 #loc
prefer.empty.array.options.mode.always=始終
prefer.empty.array.options.mode.always.never=從不(首選預設大小的陣列)
prefer.empty.array.options.mode.by.level=根據語言級別
prefer.empty.array.options.title=首選空陣列:
prefix.operation.quickfix.family.name=取代為前綴運算符
press.escape.to.remove.highlighting.message=按 Esc 移除醒目提示
primitive.array.argument.to.var.arg.method.display.name=引起混淆的 vararg 方法基元陣列實參
primitive.array.argument.to.var.arg.method.problem.descriptor=引起混淆的 vararg 方法基元陣列實參 #loc
primitive.fields.ignore.option=忽略原始欄位
printstacktrace.call.display.name=呼叫 'printStackTrace()'
printstacktrace.call.problem.descriptor=對 <code>#ref()</code> 的呼叫可能應當取代為更可靠的日誌 #loc
private=private
private.field.not.accessible.problem.descriptor=''private'' 欄位 ''{0}'' 無法從此處存取
private.member.access.between.outer.and.inner.classes.display.name=合成存取器呼叫
private.member.access.between.outer.and.inner.classes.make.constructor.package.local.quickfix=將 ''{0}'' 建構函式設為 package-private
private.member.access.between.outer.and.inner.classes.make.local.quickfix=將 ''{0}'' 設為 package-private
private.member.access.between.outer.and.inner.classes.problem.descriptor=存取類別 ''{0}'' 的 ''private'' 成員需要合成存取器 #loc
problematic.varargs.method.display.name=非 vararg 方法覆寫 vararg 方法
problematic.varargs.method.override.problem.descriptor=非 vararg 方法 <code>#ref()</code> 覆寫 vararg 方法 #loc
progress.text.analyzing.package.0=正在分析軟體套件 {0}
properties.object.as.hashtable.display.name=將 'Properties' 物件用作 'Hashtable'
properties.object.as.hashtable.problem.descriptor=在屬性物件上呼叫 <code>Hashtable.#ref()</code> #loc
property.value.set.to.itself.display.name=屬性值設定為自身
protected.field.display.name=protected 欄位
protected.field.not.accessible.problem.descriptor=''protected'' 欄位 ''{0}'' 無法從此處存取
protected.field.problem.descriptor=protected 欄位 <code>#ref</code> #loc
protected.inner.class.display.name=protected 嵌套類別
protected.inner.class.ignore.enum.option=忽略 'protected' 內部枚舉
protected.inner.class.ignore.interface.option=忽略 'protected' 內部接口
protected.inner.class.problem.descriptor=protected 嵌套類別 <code>#ref</code> #loc
protected.member.in.final.class.display.name='protected' 成員位於 'final' 類別中
protected.member.in.final.class.problem.descriptor=類別成員在 'final' 類別中被宣告為 <code>#ref</code> #loc
protected.package.local.private=protected、package-private 和 private
public.constructor.display.name='public' 建構函式可被取代為工廠方法
public.constructor.in.non.public.class.display.name='public' 建構函式位於非 public 類別中
public.constructor.in.non.public.class.problem.descriptor=建構函式在非 public 類別 ''{0}'' 中被宣告為 <code>#ref</code> #loc
public.constructor.in.non.public.class.quickfix=將建構函式設為 private
public.constructor.problem.descriptor=public 建構函式 <code>#ref()</code> #loc
public.constructor.quickfix=將建構函式取代為工廠方法
public.default.constructor.problem.descriptor=類別 <code>#ref</code> 具有 'public' 預設建構函式
public.field.accessed.in.synchronized.context.display.name=在 'synchronized' 上下文中存取d了非 private 欄位
public.field.accessed.in.synchronized.context.problem.descriptor=在同步上下文中存取非 private 欄位 <code>#ref</code> #loc
public.field.display.name='public' 欄位
public.field.ignore.enum.type.fields.option=忽略枚舉類型的 'public final' 欄位
public.field.problem.descriptor='public' 欄位 <code>#ref</code> #loc
public.inner.class.display.name='public' 嵌套類別
public.inner.class.ignore.enum.option=忽略 'public' 內部枚舉
public.inner.class.ignore.interface.option=忽略 'public' 內部接口
public.inner.class.problem.descriptor='public' 嵌套類別 <code>#ref</code> #loc
public.method.not.in.interface.display.name='public' 方法在接口中未公開
public.method.not.in.interface.option=<html>如果包含類別未實作非庫接口，則忽略</html>
public.method.not.in.interface.problem.descriptor='public' 方法 <code>#ref()</code> 未通過接口公開 #loc
public.method.without.logging.display.name='public' 方法沒有日誌記錄
public.method.without.logging.problem.descriptor='public' 方法 <code>#ref()</code> 沒有日誌呼叫 #loc
public.static.array.field.display.name='public static' 陣列欄位
public.static.array.field.problem.descriptor='public static' 陣列欄位 <code>#ref</code>，影響安全性 #loc
public.static.collection.field.display.name='public static' 集合欄位
public.static.collection.field.problem.descriptor='public static' 集合欄位 <code>#ref</code>，影響安全性 #loc
qualify.call.fix.family.name=限定呼叫
query.column.name=查詢名稱開頭
query.label=查詢名稱開頭:
questionable.name.display.name=可疑名稱
questionable.name.list.label=報告的名稱:
questionable.name.problem.descriptor=可疑名稱 <code>#ref</code> #loc
random.double.for.random.integer.display.name=使用 'Random.nextDouble()' 獲取隨機整數
random.double.for.random.integer.problem.descriptor=使用 <code>Random.#ref</code> 建立隨機整數 #loc
raw.use.of.parameterized.type.display.name=參數化類別的原始使用
readobject.initialization.display.name=實例欄位可能無法被 'readObject()' 初始化
readobject.initialization.problem.descriptor=實例欄位 <code>#ref</code> 在 'readObject()' 呼叫期間可能無法初始化 #loc
readresolve.writereplace.protected.display.name='readResolve()' 或 'writeReplace()' 未被宣告為 'protected'
readresolve.writereplace.protected.problem.descriptor=<code>#ref()</code> 未被宣告為 'protected' #loc
readwriteobject.private.display.name='readObject()' 或 'writeObject()' 未被宣告為 'private'
readwriteobject.private.problem.descriptor=<code>#ref</code> 未被宣告為 'private' #loc
recordstore.opened.not.safely.closed.display.name=開啟了 'RecordStore'，但未安全關閉
redundant.as.list.for.iteration.fix.name=解包
redundant.as.list.for.iteration.problem=不必要的 'Arrays.asList()' 呼叫
redundant.call.problem.descriptor=冗餘呼叫 <code>#ref()</code> #loc
redundant.else.display.name=冗餘的 'else'
redundant.else.problem.descriptor=<code>#ref</code> 分支可以解包，因為 'if' 分支永遠不會正常完成 #loc
redundant.else.unwrap.quickfix=移除冗餘的 'else'
redundant.escape.in.regex.replacement.display.name=正則表達式取代字串中的冗餘轉義
redundant.escape.in.regex.replacement.problem.descriptor=''{0}'' 的冗餘轉義
redundant.escape.in.regex.replacement.quickfix=移除冗餘轉義
redundant.explicit.var.type.display.name=可以省略區域變數類型
redundant.field.initialization.display.name=冗餘欄位初始化
redundant.field.initialization.problem.descriptor=<code>#ref</code> 的欄位初始化是冗餘的 #loc
redundant.field.initialization.remove.quickfix=移除初始設定式
redundant.implements.display.name=冗餘接口宣告
redundant.implements.problem.descriptor=冗餘接口宣告 <code>#ref</code> #loc
redundant.implements.remove.quickfix=移除冗餘接口宣告
redundant.local.variable.annotation.option=忽略具有註解的變數
redundant.local.variable.display.name=冗餘區域變數
redundant.local.variable.ignore.option=忽略立即返回或拋出的變數
redundant.method.override.delegate.quickfix=將方法取代為到 super 的委託
redundant.method.override.delegates.to.super.problem.descriptor=方法 <code>#ref()</code> 僅委託給 super 方法 #loc
redundant.method.override.display.name=方法與其 super 方法相同
redundant.method.override.option.check.library.methods=檢查覆寫庫方法的方法
redundant.method.override.option.ignore.delegates=忽略到 super 方法的委託
redundant.method.override.problem.descriptor=方法 <code>#ref()</code> 與其 super 方法相同 #loc
redundant.method.override.quickfix=移除冗餘方法
redundant.string.format.call.display.name=冗餘呼叫 'String.format()'
redundant.string.format.call.quickfix=移除對 'String.format()' 的冗餘呼叫
redundant.string.formatted.call.quickfix=移除對 'String.formatted()' 的冗餘呼叫
referencing.subclass.0.from.superclass.1.initializer.might.lead.to.class.loading.deadlock=從超類別 {1} 初始設定式參照子類別 {0} 可能會導致類別載入死鎖
reflection.for.unavailable.annotation.display.name=對僅源註解的反射存取
reflection.for.unavailable.annotation.problem.descriptor=註解 '#ref' 不保留用於反射存取 #loc
refused.bequest.display.name=方法不呼叫 super 方法
refused.bequest.fix.family.name=將呼叫插入 super 方法
refused.bequest.ignore.default.super.methods.option=忽略 'default' super 方法
refused.bequest.ignore.empty.super.methods.option=忽略空 super 方法
refused.bequest.problem.descriptor=方法 <code>#ref()</code> 未呼叫 'super.#ref()' #loc
remove.annotation.parameter.0.fix.name=移除註解參數 ''{0}''
remove.call.fix.family.name=移除呼叫
remove.cloneable.quickfix=從 'implements' 子句中移除 'Cloneable'
remove.finally.block.quickfix=移除 'finally' 塊
remove.leading.zero.to.make.decimal.quickfix=移除前導零以變為十進制
remove.leading.zeroes.to.make.decimals.quickfix=移除前導零以變為十進制
remove.loop.fix.family.name=移除迴圈
remove.modifier.fix.family.name=移除修飾符
remove.modifier.quickfix=移除 ''{0}'' 修飾符
remove.redundant.polyadic.operand.fix.family.name=移除不必要的條件
remove.redundant.polyadic.operand.fix.name=移除不必要的 ''{0}'' 條件
remove.redundant.string.fix.text=使用 ''{0}()'' 並移除冗餘的 ''{1}()'' 呼叫
remove.redundant.substring.fix.family.name=移除冗餘的 'substring()' 呼叫
remove.suppress.comment.fix.family.name=移除 //{0}
remove.try.finally.block.quickfix=移除 'try-finally' 塊
rename.catch.parameter.to.ignored=將 ''catch'' 參數重命名為 ''{0}''
rename.quickfix=重新命名
renameto.quickfix=重命名為 ''{0}''
replace.all.dot.display.name=可疑的正則表達式實參
replace.all.dot.problem.descriptor=''{0}()'' 呼叫中存在可疑的正則表達式 #ref #loc
replace.all.dot.quickfix=轉義正則表達式元字元
replace.all.file.separator.problem.descriptor=File.separator 用作正則表達式；無法在 Windows 上工作
replace.anonymous.with.lambda.body.fix.family.name=將呼叫取代為方法體
replace.cast.fix.family.name=取代轉換類型
replace.casted.literal.with.just.literal.fix.family.name=取代為 {0} 文字
replace.field.reference.fix.family.name=取代欄位參照
replace.field.reference.fix.text=將欄位參照取代為 ''{0}''
replace.inheritance.with.delegation.quickfix=將繼承取代為委託
replace.instanceof.fix.family.name=取代 instanceOf 類型
replace.method.call.fix.family.name=取代方法呼叫
replace.method.call.fix.text=將方法呼叫取代為 ''{0}''
replace.method.ref.with.qualifier.fix.family.name=取代為限定符
replace.method.ref.with.qualifier.problem.lambda=lambda 可被取代為呼叫限定符
replace.method.ref.with.qualifier.problem.method=方法參照可被取代為限定符
replace.with.cast.fix.family.name=取代為轉換
replace.with.catch.clause.for.runtime.exception.quickfix=針對 'RuntimeException' 取代為 'catch' 子句
replace.with.comparator.fix.family.name=使用 'Comparator' static 方法簡化比較器
replace.with.lambda.body.fix.family.name=將 lambda 上的方法呼叫取代為 lambda 體
replace.with.method.ref.fix.family.name=將 lambda 取代為方法參照
replace.with.method.ref.fix.name.may.change.semantics=將 lambda 取代為方法參照(可能更改語意)
replace.with.method.reference.fix.family.name=將方法參照上的方法呼叫取代為相應的方法呼叫
replace.with.var.fix.family.name=將顯式類型取代為 'var'
resource.opened.not.closed.problem.descriptor=''{0}'' 應在 ''try'' 塊之前開啟，並在相應的 ''finally'' 塊中關閉 #loc
result.of.method.call.ignored.class.column.title=類別名
result.of.method.call.ignored.display.name=方法呼叫的結果已忽略
result.of.method.call.ignored.method.column.title=方法名稱正則表達式
result.of.method.call.ignored.non.library.option=報告所有忽略的非庫呼叫
result.of.method.call.ignored.problem.descriptor=<code>{0}.#ref()</code> 的結果已忽略 #loc
result.of.object.allocation.fix.name=忽略類型 ''{0}'' 的物件的分配
result.of.object.allocation.ignored.display.name=物件分配的結果已忽略
result.of.object.allocation.ignored.options.chooserTitle=選擇可以忽略物件分配的類別
result.of.object.allocation.ignored.problem.descriptor=<code>new #ref()</code> 的結果已忽略 #loc
return.from.finally.block.display.name='return' 位於 'finally' 塊內
return.from.finally.block.problem.descriptor='return' 位於 'finally' 塊內 #loc
return.of.anonymous.class.problem.descriptor=返回匿名類別的實例 #loc
return.of.collection.field.fix.family.name=使返回集合 'unmodifiable'
return.of.field.with.mutable.type.problem.descriptor=返回 {0} 欄位 <code>{1}</code> #loc
return.of.inner.class.display.name=返回匿名、區域或內部類別的實例
return.of.inner.class.ignore.non.public.option=忽略非 public 方法的返回值
return.of.inner.class.problem.descriptor=返回非 static 內部類別 <code>{0}</code> 的實例 #loc
return.of.local.class.problem.descriptor=返回區域類別 <code>{0}</code> 的實例 #loc
return.of.null.arrays.option=報告返回陣列的方法
return.of.null.collections.option=報告返回集合物件的方法
return.of.null.display.name=返回 'null'
return.of.null.ignore.private.option=忽略 'private' 方法、匿名類別和 lambda
return.of.null.objects.option=報告返回物件的方法
return.of.null.problem.descriptor=返回 <code>#ref</code> #loc
return.point.limit.option=返回點限制(&R):
return.this.display.name=返回 'this'
return.this.problem.descriptor=返回 <code>#ref</code> #loc
reuse.of.local.variable.display.name=區域變數的重用
reuse.of.local.variable.problem.descriptor=區域變數 <code>#ref</code> 的重用 #loc
reuse.of.local.variable.split.quickfix=拆分區域變數
runtime.exec.call.display.name=呼叫 'Runtime.exec()'
runtime.exec.call.problem.descriptor=對 <code>Runtime.#ref()</code> 的呼叫不可移植 #loc
runtime.exec.with.non.constant.string.display.name='Runtime.exec()' 呼叫具有非常數字串
runtime.exec.with.non.constant.string.problem.descriptor=<code>Runtime.#ref()</code> 呼叫具有非常數實參 #loc
safe.lock.display.name=已獲取但未安全解鎖的鎖
safe.lock.problem.descriptor=''{0}'' 應在 ''try'' 塊之前鎖定，並在相應的 ''finally'' 塊中解鎖 #loc
serial.annotation.used.on.wrong.member.display.name=對錯誤的成員使用了 '@Serial' 註解
serial.annotation.used.on.wrong.member.problem.descriptor=註解的成員不是序列化機制的一部分
serializable.anonymous.class.stores.non.serializable.problem.descriptor=可序列化匿名類別隱式存儲類型為 ''{0}'' 的不可序列化物件
serializable.class.in.secure.context.display.name=安全上下文中的可序列化類別
serializable.class.in.secure.context.problem.descriptor=類別 <code>#ref</code> 可能被序列化，影響安全性 #loc
serializable.deserializable.class.in.secure.context.problem.descriptor=類別 <code>#ref</code> 可能被序列化和反序列化，影響安全性 #loc
serializable.has.serialization.methods.display.name=不帶 'readObject()' 和 'writeObject()' 的可序列化類別
serializable.has.serialization.methods.ignore.option=忽略未定義實例欄位的類別
serializable.has.serialization.methods.problem.descriptor=可序列化類別 <code>#ref</code> 未定義 'readObject()' 或 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor1=可序列化類別 <code>#ref</code> 未定義 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor2=可序列化類別 <code>#ref</code> 未定義 'readObject()' #loc
serializable.inner.class.has.serial.version.uid.field.display.name=沒有 'serialVersionUID' 的可序列化非 static 內部類別
serializable.inner.class.has.serial.version.uid.field.problem.descriptor=內部類別 <code>#ref</code> 未定義 'serialVersionUID' 欄位 #loc
serializable.inner.class.with.non.serializable.outer.class.display.name=可序列化非 'static' 內部類別具有不可序列化外部類
serializable.inner.class.with.non.serializable.outer.class.problem.descriptor=內部類別 <code>#ref</code> 可序列化，而其外部類別不可序列化 #loc
serializable.lambda.stores.non.serializable.problem.descriptor=可序列化 lambda 隱式存儲類型為 ''{0}'' 的不可序列化物件
serializable.local.class.stores.non.serializable.problem.descriptor=可序列化區域類別 ''{1}'' 隱式存儲類型為 ''{0}'' 的不可序列化物件
serializable.record.contains.ignored.field.problem.descriptor=在記錄序列化期間將忽略 <code>#ref</code>
serializable.record.contains.ignored.members.display.name='record' 包含被忽略的成員
serializable.record.contains.ignored.method.problem.descriptor=在記錄序列化期間將忽略 <code>#ref()</code>
serializable.stores.non.serializable.display.name='Serializable' 物件隱式存儲非 'Serializable' 物件
serializable.with.unconstructable.ancestor.display.name=具有不可建構上級的可序列化類別
serializable.with.unconstructable.ancestor.problem.descriptor=<code>#ref</code> 具有不帶無實參建構函式的不可序列化上級 ''{0}'' #loc
serialpersistentfields.with.wrong.signature.display.name='serialPersistentFields' 欄位未被宣告為 'private static final ObjectStreamField[]'
serialpersistentfields.with.wrong.signature.problem.descriptor=可序列化類別的 <code>#ref</code> 欄位未被宣告為 'private static final ObjectStreamField[]' #loc
serialversionuid.private.static.final.long.display.name='serialVersionUID' 欄位未被宣告為 'private static final long'
serialversionuid.private.static.final.long.problem.descriptor=可序列化類別的 <code>#ref</code> 欄位未被宣告為 'private static final long' #loc
serialversionuid.private.static.final.long.quickfix=將 serialVersionUID 設為 'private static final'
set.annotation.parameter.0.1.fix.name=將註解參數 {0} 設定為“{1}”
set.replaceable.by.enum.set.display.name='Set' 可被取代為 'EnumSet'
set.replaceable.by.enum.set.problem.descriptor=<code>#ref</code> 可被取代為 'EnumSet' #loc
shared.thread.local.random.display.name='ThreadLocalRandom' 實例可能是共享的
shared.thread.local.random.problem.descriptor='ThreadLocalRandom' 實例可能在線程之間共享
shift.operation.by.inappropriate.constant.display.name=按不當常數進行移位運算
shift.operation.by.inappropriate.constant.problem.descriptor.negative=對 <code>#ref</code> 進行移位運算時使用的常量值 {0} 為負 #loc
shift.operation.by.inappropriate.constant.problem.descriptor.out.of.bounds=按超出範圍的值 {0} 進行移位運算 <code>#ref</code> #loc
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=對 <code>#ref</code> 進行移位運算時使用的常量值 {0} 過大 #loc
shift.out.of.range.fix.family.name=修復移位值
side.effects.method.ref.to.lambda.fix.family.name={0} (副作用)
signal.without.corresponding.await.display.name=沒有相應 'await()' 的 'signal()'
signal.without.corresponding.await.problem.descriptor=在沒有相應 <code>await()</code> 的情況下呼叫 <code>#ref()</code> #loc
simplifiable.annotation.braces.problem.descriptor=註解中 <code>{0}</code> 周圍不必要的圓括號 #loc
simplifiable.annotation.display.name=可簡化註解
simplifiable.annotation.problem.descriptor=註解中有不必要的 <code>#ref</code> #loc
simplifiable.annotation.quickfix=簡化註解
simplifiable.annotation.whitespace.problem.descriptor=註解中有不必要的空格 #loc
simplifiable.boolean.expression.display.name=可簡化的布爾表達式
simplifiable.conditional.expression.display.name=可簡化的條件表達式
simplifiable.conditional.expression.problem.descriptor=<code>{1}</code> 可以簡化為 ''{0}'' #loc
simplifiable.equals.expression.display.name='equals()' 呼叫之前的 'null' 檢查不必要
simplifiable.equals.expression.option.non.constant=報告具有非常數非 null 實參的等於
simplifiable.equals.expression.problem.descriptor=''{0}()'' 呼叫之前的 ''null'' 檢查不必要 #loc
simplifiable.equals.expression.quickfix=翻轉 ''.{0}()'' 並移除不必要的 ''null'' 檢查
simplifiable.junit.assertion.display.name=可簡化斷言
simplifiable.junit.assertion.problem.descriptor=<code>#ref()</code> 可以簡化為 ''{0}'' #loc
simplify.junit.assertion.simplify.quickfix=簡化斷言
single.character.startswith.display.name=單個字元 'startsWith()' 或 'endsWith()'
single.character.startswith.problem.descriptor=單個字元 <code>#ref()</code> 可被取代為 'charAt()' 表達式 #loc
single.character.startswith.quickfix=取代為 'charAt()' 表達式
single.class.import.display.name=單個類別匯入
single.class.import.problem.descriptor=單個類別匯入 <code>#ref</code> #loc
single.element.annotation.family.quickfix=將註解擴展為標準形式
single.element.annotation.name=非規范化註解
single.element.annotation.quickfix=新增 'value='
single.statement.in.block.descriptor=''{0}'' 包含單條語句
single.statement.in.block.family.quickfix=從語句中移除大括號
single.statement.in.block.name=程式碼塊包含單條語句
single.statement.in.block.quickfix=從 ''{0}'' 語句中移除大括號
singleton.display.name=單例
singleton.problem.descriptor=類別 <code>#ref</code> 為單例 #loc
size.replaceable.by.isempty.display.name='size() == 0' 可被取代為 'isEmpty()'
size.replaceable.by.isempty.fix.ignore.calls=忽略類型 ''{1}'' 上的 ''.{0}()'' 呼叫
size.replaceable.by.isempty.negation.ignore.option=忽略將取代為 '!isEmpty()' 的表達式
sleep.while.holding.lock.display.name=同步時呼叫 'Thread.sleep()'
sleep.while.holding.lock.problem.descriptor=同步時呼叫 <code>Thread.#ref()</code> #loc
smth.unnecessary.remove.quickfix=移除不必要的 ''{0}''
socket.opened.not.closed.display.name=套接字已開啟，但未安全關閉
standard.variable.names.display.name=標準變數名稱
standard.variable.names.ignore.override.option=對與 super 方法參數相同的參數名稱忽略
standard.variable.names.problem.descriptor=變數命名 <code>#ref</code> 沒有類型 ''{0}'' #loc
standard.variable.names.problem.descriptor2=變數命名 <code>#ref</code> 沒有類型 ''{0}'' 或 ''{1}'' #loc
statement.problem.descriptor=<code>#ref</code> 語句 #loc
statement.with.empty.body.display.name=帶空體的語句
statement.with.empty.body.include.option=包含空程式碼塊語句正文
statement.with.empty.body.problem.descriptor=<code>#ref</code> 語句具有空體 #loc
static.collection.display.name=靜態集合
static.collection.ignore.option=忽略弱靜態集合或映射
static.collection.problem.descriptor=靜態集合 <code>#ref</code> #loc
static.field.via.subclass.display.name=static 欄位通過子類別參照
static.field.via.subclass.problem.descriptor=static 欄位 <code>#ref</code> 在類別 ''{0}'' 中宣告，但通過子類別 ''{1}'' 參照 #loc
static.field.via.subclass.rationalize.quickfix=使 static 欄位存取合理化
static.import.display.name=靜態匯入
static.import.fix.ignore.class=允許類別 ''{0}'' 的靜態匯入
static.import.options.border.title=靜態可匯入類別:
static.import.options.chooserTitle=選擇靜態可匯入類別
static.import.problem.descriptor=靜態匯入 <code>#ref</code>  #loc
static.import.replace.quickfix=取代為非靜態匯入
static.inheritance.display.name=靜態繼承
static.inheritance.fix.family.name=將繼承取代為限定參照
static.inheritance.problem.descriptor=接口 <code>#ref</code> 僅針對其 static 常數實作 #loc
static.inheritance.replace.quickfix=將繼承取代為 {0} 中的限定參照
static.initializer.references.subclass.display.name=static 初始設定式參照子類別
static.method.naming.convention.element.description='static' 方法
static.method.only.used.in.one.anonymous.class.problem.descriptor=static {0, choice, 1#方法|2#欄位} <code>#ref{0, choice, 1#()|2#}</code> 僅在派生自 ''{1}'' 的匿名類別中使用 #loc
static.method.only.used.in.one.class.display.name=static 成員僅在其他一個類別中使用
static.method.only.used.in.one.class.ignore.anonymous.option=僅在匿名類別中使用時忽略
static.method.only.used.in.one.class.ignore.on.conflicts=當方法無法在不產生衝突的情況下移動時忽略
static.method.only.used.in.one.class.ignore.test.option=僅在測試類別中使用時忽略
static.method.only.used.in.one.class.ignore.utility.classes=忽略位於實用程序類別中的成員
static.method.only.used.in.one.class.problem.descriptor=static {0, choice, 1#方法|2#欄位} <code>#ref{0, choice, 1#()|2#}</code> 僅在 ''{1}'' 類別中使用 #loc
static.method.only.used.in.one.class.quickfix=將 {0} 移至使用類別
static.method.only.used.in.one.class.quickfix.preview=將 static 成員移至使用它的類別。
static.method.via.subclass.display.name=static 方法通過子類別參照
static.method.via.subclass.problem.descriptor=static 方法 <code>#ref()</code> 在類別 ''{0}'' 中宣告，但通過子類別 ''{1}'' 參照 #loc
static.method.via.subclass.rationalize.quickfix=使 static 方法呼叫合理化
static.non.final.field.display.name='static' 非 'final' 欄位
static.non.final.field.option=僅報告 'public' 欄位
static.non.final.field.problem.descriptor='static' 非 'final' 欄位 <code>#ref</code> #loc
static.variable.may.not.be.initialized.display.name=static 欄位可能無法初始化
static.variable.may.not.be.initialized.problem.descriptor=static 欄位 <code>#ref</code> 在類別初始化期間可能無法初始化 #loc
static.variable.naming.convention.element.description='static' 欄位
static.variable.of.concrete.class.problem.descriptor=具體類別 <code>#ref</code> 的 static 欄位 ''{0}'' #loc
static.variable.used.before.initialization.display.name=static 欄位在初始化前使用
static.variable.used.before.initialization.problem.descriptor=static 欄位 <code>#ref</code> 在初始化前使用 #loc
string.buffer.must.have.initial.capacity.display.name=沒有初始容量的 'StringBuilder'
string.buffer.must.have.initial.capacity.problem.descriptor=沒有初始容量的 <code>new #ref()</code> #loc
string.buffer.replaceable.by.string.builder.display.name='StringBuffer' 可能是 'StringBuilder'
string.buffer.replaceable.by.string.builder.problem.descriptor=<code>StringBuffer #ref</code> 可能被宣告為 'StringBuilder' #loc
string.buffer.replaceable.by.string.display.name='StringBuilder' 可被取代為 'String'
string.buffer.replaceable.by.string.problem.descriptor=<code>{0} #ref</code> 可被取代為 ''String'' #loc
string.buffer.to.string.in.concatenation.display.name=連線中的 'StringBuilder.toString()'
string.buffer.to.string.in.concatenation.problem.descriptor=在串聯中呼叫 <code>{0}.#ref()</code> #loc
string.comparison.display.name=使用 '==' 而不是 'equals()' 進行字串比較
string.comparison.problem.descriptor=使用 <code>#ref</code> 而不是 'equals()' 來比較字串值 #loc
string.concatenation.argument.to.log.call.display.name=非常數字串串聯作為日誌呼叫的實參
string.concatenation.argument.to.log.call.problem.descriptor=非常數字串串聯作為 <code>#ref()</code> 日誌呼叫的實參 #loc
string.concatenation.argument.to.log.call.quickfix=將串聯取代為參數化的日誌訊息
string.concatenation.display.name=字串串聯
string.concatenation.in.format.call.display.name=字串串聯作為 'format()' 呼叫的實參
string.concatenation.in.format.call.fix.family.name=將串聯取代為實參
string.concatenation.in.format.call.problem.descriptor=''{0}()'' 呼叫包含字串串聯實參
string.concatenation.in.format.call.quickfix=將串聯取代為單獨的實參
string.concatenation.in.loops.display.name=字串串聯在迴圈中
string.concatenation.in.loops.problem.descriptor=迴圈中的字串串聯 <code>#ref</code> #loc
string.concatenation.in.message.format.call.display.name=字串串聯作為 'MessageFormat.format()' 呼叫的實參
string.concatenation.in.message.format.call.problem.descriptor=字串串聯作為 'MessageFormat.format()' 呼叫的實參 #loc
string.concatenation.inside.string.buffer.append.display.name=字串串聯作為 'StringBuilder.append()' 呼叫的實參
string.concatenation.inside.string.buffer.append.problem.descriptor=字串串聯作為 <code>{0}.#ref()</code> 呼叫的實參 #loc
string.concatenation.inside.string.buffer.append.replace.quickfix=取代為鏈式 'append()' 呼叫
string.concatenation.introduce.fix=引入 StringBuilder
string.concatenation.introduce.fix.name=引入新的 {1} 以更新變數 ''{0}''
string.concatenation.introduce.fix.name.null.safe=引入新的 {1} 以更新變數 ''{0}'' (null 安全)
string.concatenation.missing.whitespace.display.name=字串串聯中可能缺少空格
string.concatenation.missing.whitespace.option=忽略具有變量字串的串聯
string.concatenation.missing.whitespace.problem.descriptor=字串串聯中可能缺少空格 #loc
string.concatenation.problem.descriptor=國際化上下文中的字串串聯 <code>#ref</code> #loc
string.concatenation.replace.fix=取代為 StringBuilder
string.concatenation.replace.fix.name=將變數 ''{0}'' 從字串轉換為 {1}
string.concatenation.replace.fix.name.null.safe=將變數 ''{0}'' 從字串轉換為 {1} (null 安全)
string.equals.char.sequence.display.name=使用 'CharSequence' 實參呼叫了 'String.equals()'
string.equals.char.sequence.problem.descriptor=使用 ''{0}'' 實參呼叫了 <code>String.equals()</code> #loc
string.equals.empty.string.display.name='String.equals()' 可被取代為 'String.isEmpty()'
string.equals.empty.string.fix.family.name=簡化空字串檢查
string.equals.empty.string.is.empty.problem.descriptor=<code>#ref("")</code> 可被取代為 'isEmpty()' #loc
string.equals.empty.string.option.do.not.add.null.check=當有必要進行 null 檢查時，不必報告
string.equals.empty.string.problem.descriptor=<code>#ref("")</code> 可被取代為 'length()==0' #loc
string.format.choose.class=選擇格式化程序類別
string.format.class.label=附加格式化程序類別:
string.format.class.method.label=附加格式化程序方法:
string.indexof.replaceable.by.contains.display.name='String.indexOf()' 表達式可被取代為 'contains()'
string.replace.quickfix=移除空字串動作數
string.replaceable.by.string.buffer.display.name=非常數 'String' 可被取代為 'StringBuilder'
string.replaceable.by.string.buffer.in.loop.option=僅在迴圈中追加時發出警告
string.replaceable.by.string.buffer.problem.descriptor=非常數字串 <code>#ref</code> 可能應被宣告為 'StringBuilder' #loc
string.touppercase.tolowercase.without.locale.display.name=呼叫無區域設定的 'String.toUpperCase()' 或 'toLowerCase()'
string.touppercase.tolowercase.without.locale.problem.descriptor=在未使用國際化字串指定區域設定的情況下呼叫 <code>String.#ref()</code> #loc
stringbuffer.field.display.name='StringBuilder' 欄位
stringbuffer.field.problem.descriptor=''{0}'' 欄位 <code>#ref</code> #loc
subtraction.in.compareto.display.name='compareTo()' 中的減法
subtraction.in.compareto.problem.descriptor='compareTo()' 中的減法 <code>#ref</code> 可能導致溢出或精度損失 #loc
super.class.logger.option=在超類別有可存取的記錄器時忽略
suppress.for.tests.scope.quickfix=對 'Tests' 作用域禁止
suspicious.array.cast.display.name=可疑的陣列轉換
suspicious.array.cast.problem.descriptor=可疑轉換為 <code>#ref</code> #loc
suspicious.comparator.compare.descriptor.min.value=Returning Integer.MIN_VALUE from a comparison function is discouraged
suspicious.comparator.compare.descriptor.non.negative=Comparator never returns negative values
suspicious.comparator.compare.descriptor.non.positive=Comparator never returns positive values
suspicious.comparator.compare.descriptor.non.reflexive=對於相等的元素，比較器不返回 0
suspicious.comparator.compare.descriptor.parameter.not.used=未使用 ''{0}()'' 參數 <code>#ref</code> #loc
suspicious.comparator.compare.display.name=可疑的 'Comparator.compare()' 實作
suspicious.getter.problem.descriptor=getter <code>#ref()</code> 返回欄位 ''{0}'' #loc
suspicious.getter.setter.display.name=可疑的 getter/setter
suspicious.indent.after.control.statement.display.name=沒有大括號的控制語句後存在可疑縮排
suspicious.indent.after.control.statement.problem.descriptor=''{0}'' 語句後存在可疑縮排 #loc
suspicious.integer.div.assignment.display.name=可疑的整數除法賦值
suspicious.integer.div.assignment.problem.descriptor=除法結果被截斷為整數
suspicious.integer.div.assignment.quickfix=轉換為 double
suspicious.literal.underscore.display.name=數字文字中的可疑下劃線
suspicious.literal.underscore.problem.descriptor=帶下劃線的數字文字中的組沒有長度 3 #loc
suspicious.package.private.access.display.name=可疑的 package-private 存取權限
suspicious.setter.problem.descriptor=setter <code>#ref()</code> 對欄位 ''{0}'' 賦值 #loc
suspicious.system.arraycopy.display.name=可疑的 'System.arraycopy()' 呼叫
suspicious.system.arraycopy.problem.descriptor.length.bigger.dest=長度始終大於 ''dest.length - destPos'' {0}
suspicious.system.arraycopy.problem.descriptor.length.bigger.src=長度始終大於 ''src.length - srcPos'' {0}
suspicious.system.arraycopy.problem.descriptor.ranges.intersect=複製到具有相交範圍的同一陣列
suspicious.system.arraycopy.problem.descriptor4=<code>#ref</code> 不是陣列類型 #loc
suspicious.system.arraycopy.problem.descriptor5=<code>#ref</code> 不是陣列類型 #loc
suspicious.system.arraycopy.problem.descriptor6=源參數類型 ''{0}'' 不可分配給類型為 ''{1}'' 的目標參數 <code>#ref</code> #loc
suspicious.to.array.call.display.name=可疑的 'Collection.toArray()' 呼叫
suspicious.to.array.call.fix.family.name=取代為正確陣列
suspicious.to.array.call.problem.descriptor=應為類型 ''{0}[]'' 的陣列，找到的是 ''{1}[]'' #loc
swap.equals.fix.family.name=翻轉方法呼叫
switch.expression.with.single.default.message='switch' 表達式只有 'default' case
switch.expression.with.too.few.branches.problem.descriptor=''switch'' 表達式的 case 標籤太少 ({0})，並且可能應當取代為 ''if'' 語句或條件運算符 #loc
switch.statement.density.display.name='switch' 語句的分支密度過低
switch.statement.density.min.option=分支的最小密度: %
switch.statement.density.problem.descriptor=<code>#ref</code> 的分支密度過低 ({0}%) #loc
switch.statement.display.name='switch' 語句
switch.statement.with.confusing.declaration.display.name=在不同 'switch' 分支中使用並宣告的區域變數
switch.statement.with.confusing.declaration.problem.descriptor=區域變數 <code>#ref</code> 在一個 'switch' 分支中宣告，並在另一個分支中使用 #loc
switch.statement.with.single.default.message='switch' 語句只有 'default' case
switch.statement.with.too.few.branches.display.name=最小 'switch' 分支
switch.statement.with.too.few.branches.ignore.pattern.option=不報告模式 switch 語句
switch.statement.with.too.few.branches.min.option=最小分支數:
switch.statement.with.too.few.branches.problem.descriptor=''switch'' 語句的 case 標籤太少({0})，並且可能應當取代為 ''if'' 語句 #loc
switch.statement.with.too.many.branches.display.name=最大 'switch' 分支
switch.statement.without.default.ignore.option=忽略詳盡的 switch 語句
switch.statements.without.default.display.name=不帶 'default' 分支的 'switch' 語句
switch.statements.without.default.problem.descriptor=沒有 'default' 分支的 <code>#ref</code> 語句 #loc
synchronization.on.get.class.display.name=在 'getClass()' 上同步
synchronization.on.get.class.problem.descriptor=在 <code>#ref()</code> 上同步 #loc
synchronization.on.local.variable.or.method.parameter.display.name=在區域變數或方法參數上同步
synchronization.on.local.variable.problem.descriptor=在區域變數 <code>#ref</code> 上同步 #loc
synchronization.on.method.parameter.problem.descriptor=在方法參數 <code>#ref</code> 上同步 #loc
synchronization.on.static.field.display.name=在 'static' 欄位上同步
synchronization.on.static.field.problem.descriptor=在 'static' 欄位 <code>#ref</code> 上同步 #loc
synchronize.on.class.problem.descriptor=對類別的鎖定動作可能會產生不可預見的副作用 #loc
synchronize.on.lock.display.name=在 'Lock' 物件上同步
synchronize.on.lock.problem.descriptor=在 ''{0}'' 物件上同步不太可能是故意的 #loc
synchronize.on.non.final.field.display.name=在非 final 欄位上同步
synchronize.on.non.final.field.problem.descriptor=在非 final 欄位 <code>#ref</code> 上同步 #loc
synchronize.on.this.display.name=在 'this' 上同步
synchronize.on.this.problem.descriptor=對 'this' 的鎖定動作可能會產生不可預見的副作用 #loc
synchronized.method.display.name='synchronized' 方法
synchronized.method.ignore.synchronized.super.option=忽略覆寫 synchronized 方法的方法
synchronized.method.include.option=包含本地方法
synchronized.method.move.quickfix=將同步移至方法中
synchronized.method.problem.descriptor=方法 ''{0}()'' 被宣告為 <code>#ref</code> #loc
synchronized.on.direct.literal.object.problem.descriptor=在 {0} 文字 <code>#ref</code> 上同步 #loc
synchronized.on.literal.object.name=在使用文字初始化的物件上同步
synchronized.on.literal.object.problem.descriptor=在使用文字初始化的 {0} <code>#ref</code> 上同步 #loc
synchronized.on.literal.object.warn.on.all.option=警告所有可能的文字
synchronized.on.possibly.literal.object.problem.descriptor=在 {0} <code>#ref</code> 上同步 #loc
system.exit.call.display.name=呼叫 'System.exit()' 或相關方法
system.exit.call.ignore.option=在 main 方法中忽略
system.exit.call.problem.descriptor=對 <code>{0}.#ref()</code> 的呼叫不可移植 #loc
system.getenv.call.display.name=呼叫 'System.getenv()'
system.getenv.call.problem.descriptor=對 <code>System.#ref()</code> 的呼叫不可移植 #loc
system.properties.display.name=系統屬性的存取
system.properties.problem.descriptor=對 <code>Integer.#ref()</code> 的呼叫可能造成安全問題 #loc
system.properties.problem.descriptor1=對 <code>Boolean.#ref()</code> 的呼叫可能造成安全問題 #loc
system.run.finalizers.on.exit.display.name=呼叫 'System.runFinalizersOnExit()'
system.run.finalizers.on.exit.problem.descriptor=呼叫 <code>System.#ref()</code> #loc
system.set.problem.descriptor=對 <code>System.#ref()</code> 的呼叫可能造成安全問題 #loc
system.set.security.manager.display.name=呼叫 'System.setSecurityManager()'
system.set.security.manager.problem.descriptor=對 <code>System.#ref()</code> 的呼叫可能造成安全問題 #loc
tail.recursion.display.name=尾遞迴
tail.recursion.problem.descriptor=尾部遞迴呼叫 <code>#ref()</code> #loc
tail.recursion.replace.quickfix=用迭代替換尾部遞迴
test.case.with.no.test.methods.display.name=沒有測試的測試類別
test.case.with.no.test.methods.option=忽略具有帶測試方法的超類別的測試用例
test.case.with.no.test.methods.problem.descriptor=測試類別 <code>#ref</code> 沒有測試 #loc
text.label.in.switch.statement.display.name='switch' 語句中的文本標籤
text.label.in.switch.statement.problem.descriptor='switch' {0, choice, 1#語句|2#表達式}中存在文本標籤 <code>#ref:</code> #loc
the.whole.project=整個專案
this.class=此類別
this.reference.escaped.in.construction.display.name=物件建構中轉義的 'this' 參照
this.reference.escaped.in.construction.problem.descriptor=物件建構期間轉義 <code>#ref</code> #loc
thread.death.rethrown.display.name='ThreadDeath' 未重新拋出
thread.death.rethrown.problem.descriptor=ThreadDeath <code>#ref</code> 未重新拋出 #loc
thread.local.not.static.final.display.name='ThreadLocal' 欄位未被宣告為 'static final'
thread.local.not.static.final.problem.descriptor=ThreadLocal <code>#ref</code> 未被宣告為 'static final' #loc
thread.local.set.with.null.display.name = 以 null 作為實參的 'ThreadLocal.set()'
thread.local.set.with.null.problem.descriptor = 使用 null 作為實參的 'ThreadLocal.set()' 可能會導致記憶體泄漏
thread.local.set.with.null.quickfix = 取代為 'ThreadLocal.remove()' 呼叫
thread.priority.display.name=呼叫 'Thread.setPriority()'
thread.priority.problem.descriptor=呼叫 <code>Thread.#ref()</code> #loc
thread.run.problem.descriptor=對 <code>#ref()</code> 的呼叫可能應當取代為 'start()' #loc
thread.start.in.construction.display.name=物件建構期間呼叫 'Thread.start()'
thread.start.in.construction.problem.descriptor=物件建構期間呼叫 <code>#ref()</code> #loc
thread.stop.suspend.resume.display.name=呼叫 'Thread.stop()'、'suspend()' 或 'resume()'
thread.stop.suspend.resume.problem.descriptor=呼叫 <code>Thread.#ref()</code> #loc
thread.with.default.run.method.display.name=使用預設的 'run()' 方法實例化 'Thread'
thread.with.default.run.method.problem.descriptor=使用預設的 'run()' 方法實例化 <code>#ref</code> #loc
thread.yield.display.name=呼叫 'Thread.yield()'
thread.yield.problem.descriptor=呼叫 <code>Thread.#ref()</code> #loc
three.negations.per.method.display.name=具有三個以上否定的方法
three.negations.per.method.ignore.assert.option=忽略 'assert' 語句中的否定
three.negations.per.method.ignore.option=忽略 'equals()' 方法中的否定
three.negations.per.method.problem.descriptor=<code>#ref</code> 包含 {0} 個否定 #loc
throw,from.finally.block.everywhere.option=警告隨處都可能拋出宣告的異常
throw.caught.locally.display.name=通過包含 'try' 語句捕獲 'throw'
throw.caught.locally.ignore.option=忽略重新拋出的異常
throw.caught.locally.problem.descriptor=通過包含 'try' 語句捕獲 <code>#ref</code> #loc
throw.from.finally.block.display.name='throw' 位於 'finally' 塊內
throw.from.finally.block.problem.descriptor=<code>#ref</code> 位於 'finally' 塊內 #loc
throwable.instance.never.thrown.checked.exception.problem.descriptor=已檢查的異常實例 <code>#ref</code> 未拋出 #loc
throwable.instance.never.thrown.error.problem.descriptor=錯誤實例 <code>#ref</code> 未拋出 #loc
throwable.instance.never.thrown.problem.descriptor=Throwable 實例 <code>#ref</code> 未拋出 #loc
throwable.instance.never.thrown.runtime.exception.problem.descriptor=執行時異常實例 <code>new #ref()</code> 未拋出 #loc
throwable.not.thrown.display.name='Throwable' 未拋出
throwable.printed.to.system.out.display.name='Throwable' 列印到 'System.out'
throwable.printed.to.system.out.problem.descriptor=''Throwable'' 實參 <code>#ref</code> 到 ''System.{0}.{1}()'' 呼叫
throwable.result.of.method.call.ignored.problem.descriptor=<code>#ref()</code> 的結果未拋出 #loc
throwable.supplier.only.throw.exception.name=Throwable 供應商從不返回值
throwable.supplier.only.throw.exception.problem.descriptor=Throwable 供應商不返回任何異常
throwable.supplier.only.throw.exception.quickfix=將 lambda 中的 'throw' 取代為 'return'
thrown.exceptions.per.method.display.name=方法宣告的異常過多
thrown.exceptions.per.method.limit.option=異常拋出限制:
thrown.exceptions.per.method.problem.descriptor=<code>#ref</code> 宣告的異常過多 (異常數量 = {0}) #loc
throws.runtime.exception.display.name=在 'throws' 子句中宣告的未檢查的異常
throws.runtime.exception.fix.family.name=從 'throws' 子句中移除
throws.runtime.exception.move.quickfix=將 ''{0}'' 移至 Javadoc ''@throws'' 標記中
throws.runtime.exception.problem.descriptor=在 'throws' 子句中宣告的未檢查的異常 <code>#ref</code> #loc
throws.runtime.exception.quickfix=從 ''throws'' 子句中移除 ''{0}''
time.tostring.call.display.name=呼叫 'Time.toString()'
time.tostring.call.problem.descriptor=國際化上下文中的 <code>Time.#ref()</code> #loc
to.array.call.style.display.name='Collection.toArray()' 呼叫樣式
to.array.call.style.problem.descriptor.presized=<code>#ref()</code> 呼叫具有預設大小的陣列實參 ''{0}'' #loc
to.array.call.style.problem.descriptor.zero=<code>#ref()</code> 呼叫具有空陣列實參 ''{0}'' #loc
to.array.call.style.quickfix.family.name=修復傳遞到 'toArray()' 呼叫的陣列的大小
to.array.call.style.quickfix.make.presized=將實參取代為預設大小的陣列
to.array.call.style.quickfix.make.zero=將實參取代為空陣列
too.broad.catch.display.name=過寬的 'catch' 塊
too.broad.catch.option=僅對 RuntimeException、異常、錯誤或 Throwable 發出警告(&O)
too.broad.catch.problem.descriptor=<code>#ref</code> 的 ''catch'' 過寬，遮罩異常 ''{0}'' #loc
too.broad.catch.problem.descriptor1=<code>#ref</code> 的 ''catch'' 過寬，遮罩異常 ''{0}'' 和 ''{1}'' #loc
too.broad.catch.quickfix=向 ''{0}'' 新增 ''catch'' 子句
too.broad.scope.allow.option=<html>報告使用新表達式作為初始設定式的變數<br>(可能不安全)</html>
too.broad.scope.display.name=變數作用域過寬
too.broad.scope.inspection.fix.family.name=限縮作用域
too.broad.scope.narrow.quickfix=將 ''{0}'' 的宣告移近用法
too.broad.scope.only.blocks.option=僅報告可移入內部塊的變數
too.broad.scope.problem.descriptor=變數 <code>#ref</code> 的作用域過寬 #loc
too.many.constructors.count.limit.option=建構函式計數限制:
too.many.constructors.display.name=建構函式過多的類別
too.many.constructors.ignore.deprecated.option=忽略棄用的建構函式
too.many.constructors.problem.descriptor=<code>#ref</code> 的建構函式過多 (建構函式計數 = {0}) #loc
too.many.fields.count.limit.option=欄位計數限制:
too.many.fields.display.name=欄位過多的類別
too.many.fields.problem.descriptor=<code>#ref</code> 的欄位過多 (欄位計數 = {0}) #loc
too.many.methods.display.name=方法過多的類別
too.many.methods.problem.descriptor=<code>#ref</code> 的方法過多 (方法計數 = {0}) #loc
trace.level.option=追蹤級別
transient.field.in.non.serializable.class.display.name=不可序列化類別中存在 transient 欄位
transient.field.in.non.serializable.class.problem.descriptor=欄位 ''{0}'' 已在不可序列化類別中標記為 <code>#ref</code> #loc
transient.field.not.initialized.display.name=transient 欄位在反序列化時未初始化
transient.field.not.initialized.problem.descriptor=transient 欄位 <code>#ref</code> 在反序列化時未初始化 #loc
trivial.if.display.name=冗餘的 'if' 語句
trivial.if.fix.family.name=簡化 'if else'
trivial.if.option.ignore.assert.statements=忽略帶有簡單 'assert' 的 'if' 語句
trivial.if.option.ignore.chained=忽略鏈式 'if' 語句
trivial.if.problem.descriptor=<code>#ref</code> 語句可以簡化 #loc
trivial.string.concatenation.display.name=與空字串串聯
trivial.string.concatenation.problem.descriptor=串聯中使用的空字串
try.finally.can.be.try.with.resources.display.name='try finally' 可被取代為 'try' with resources
try.finally.can.be.try.with.resources.problem.descriptor=<code>#ref</code> 可以使用自動資源管理 #loc
try.finally.can.be.try.with.resources.quickfix=取代為 'try-with-resources'
try.statement.with.multiple.resources.name=可以拆分具有多個資源的 'try' 語句
try.statement.with.multiple.resources.quickfix=拆分具有多個資源的 'try' 語句
try.with.identical.catches.checkbox.different.comments=不報告帶有不同註釋的 catch 塊
try.with.identical.catches.display.name='try' 語句中的相同 'catch' 分支
try.with.identical.catches.problem.descriptor=''catch'' 分支與 ''{0}'' 分支相同 #loc
try.with.identical.catches.quickfix=摺疊 'catch' 塊
type.parameter.extends.enum.type.parameter.problem.descriptor=類型參數 <code>#ref</code> 隱式擴展 final 枚舉 ''{0}'' #loc
type.parameter.extends.enum.wildcard.problem.descriptor=萬用字元類型實參 <code>#ref</code> 隱式擴展了 final 枚舉 ''{0}'' #loc
type.parameter.extends.final.class.display.name=類型參數擴展 'final' 類別
type.parameter.extends.final.class.quickfix=將類型參數取代為實際類別
type.parameter.extends.final.class.type.parameter.problem.descriptor=類型參數 <code>#ref</code> 擴展 ''final'' 類別{0} #loc
type.parameter.extends.final.class.wildcard.problem.descriptor=萬用字元類型實參 <code>#ref</code> 擴展了 ''final'' 類別 ''{0}'' #loc
type.parameter.extends.object.display.name=類型參數顯式擴展 'Object'
type.parameter.extends.object.ignore.annotated=註解 java.lang.Object 時忽略
type.parameter.extends.object.problem.descriptor1=類型參數 <code>#ref</code> 顯式擴展 'java.lang.Object' #loc
type.parameter.extends.object.problem.descriptor2=萬用字元類型實參 <code>#ref</code> 顯式擴展 'java.lang.Object' #loc
type.parameter.hides.type.parameter.problem.descriptor=類型參數 <code>#ref</code> 隱藏類型參數 ''{0}'' #loc
type.parameter.hides.visible.type.display.name=類型參數隱藏可見類型
type.parameter.hides.visible.type.problem.descriptor=類型參數 <code>#ref</code> 隱藏可見類型 ''{0}'' #loc
type.parameter.naming.convention.element.description=類型參數
unary.plus.display.name=一元正號
unary.plus.problem.descriptor=一元 <code>#ref</code> 運算符 #loc
unary.plus.quickfix=移除一元 '+'
unchecked.exception.class.display.name=未檢查的 'Exception' 類別
unchecked.exception.class.problem.descriptor=未檢查的異常類別 <code>#ref</code> #loc
unclear.binary.expression.display.name=具有不同優先級的多個運算符
unclear.binary.expression.problem.descriptor=表達式可以使用澄清括號 #loc
unclear.binary.expression.quickfix=新增澄清括號
unconditional.wait.display.name=無條件的 'wait()' 呼叫
unconditional.wait.problem.descriptor=無條件呼叫 <code>#ref()</code> #loc
unnecessarily.qualified.inner.class.access.display.name=不必要的限定內部類別存取
unnecessarily.qualified.inner.class.access.option=忽略需要匯入的參照
unnecessarily.qualified.inner.class.access.problem.descriptor=使用 <code>#ref</code> 限定 ''{0}'' 不必要 #loc
unnecessarily.qualified.inner.class.access.quickfix=移除限定符
unnecessarily.qualified.static.usage.display.name=不必要的限定靜態存取
unnecessarily.qualified.static.usage.ignore.field.option=忽略不必要的限定欄位存取
unnecessarily.qualified.static.usage.ignore.method.option=忽略不必要的限定方法呼叫
unnecessarily.qualified.static.usage.problem.descriptor=不必要的限定 static 方法呼叫 <code>{0}()</code> #loc
unnecessarily.qualified.static.usage.problem.descriptor1=不必要的限定靜態存取 <code>{0}</code> #loc
unnecessarily.qualified.statically.imported.element.display.name=不必要的限定靜態匯入元素
unnecessarily.qualified.statically.imported.element.problem.descriptor=靜態匯入元素 ''{0}'' 使用 <code>#ref</code> 不必要限定 #loc
unnecessarily.qualified.statically.imported.element.quickfix=移除不必要的限定符
unnecessary.block.statement.problem.descriptor=此語句周圍的大括號不必要 #loc
unnecessary.boxing.display.name=不必要的裝箱
unnecessary.boxing.inside.value.of.problem.descriptor=冗餘裝箱，可以改用 <code>{0}.{1}()</code> 呼叫 #loc
unnecessary.boxing.problem.descriptor=不必要的裝箱 #loc
unnecessary.boxing.remove.quickfix=移除裝箱
unnecessary.boxing.superfluous.option=僅報告真正多餘的裝箱表達式
unnecessary.break.display.name=不必要的 'break' 語句
unnecessary.break.problem.descriptor=<code>#ref</code> 語句不必要 #loc
unnecessary.code.block.display.name=不必要的程式碼塊
unnecessary.code.block.unwrap.quickfix=解包塊
unnecessary.constant.array.creation.expression.display.name=常數陣列建立中的冗餘 'new' 表達式
unnecessary.constant.array.creation.expression.family.quickfix=從新陣列表達式中移除類型規範
unnecessary.constant.array.creation.expression.problem.descriptor=可從新陣列表達式中移除 <code>#ref</code> #loc
unnecessary.constructor.annotation.option=忽略有註解的建構函式
unnecessary.constructor.display.name=冗餘無實參建構函式
unnecessary.constructor.problem.descriptor=無實參建構函式 <code>#ref()</code> 是冗餘的 #loc
unnecessary.constructor.remove.quickfix=移除冗餘建構函式
unnecessary.continue.display.name=不必要的 'continue' 語句
unnecessary.continue.problem.descriptor=<code>#ref</code> 不必要，因為是迴圈中的最後一條語句 #loc
unnecessary.conversion.to.string.display.name=到 'String' 的不必要轉換
unnecessary.default.display.name=枚舉 'switch' 語句的 'default' 不必要
unnecessary.default.expressions.option=僅報告 switch 表達式
unnecessary.default.problem.descriptor=<code>#ref</code> 分支不必要 #loc
unnecessary.default.quickfix=移除 'default' 分支
unnecessary.enum.constructor.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於枚舉建構函式是冗餘的 #loc
unnecessary.explicit.numeric.cast.display.name=不必要的顯式數字轉換
unnecessary.explicit.numeric.cast.problem.descriptor=''{0}'' 不必要轉換為 <code>#ref</code> #loc
unnecessary.explicit.numeric.cast.quickfix=移除轉換
unnecessary.final.on.local.variable.or.parameter.display.name=區域變數或參數上存在不必要的 'final'
unnecessary.final.on.local.variable.problem.descriptor=變數 ''{0}'' 上存在不必要的 <code>#ref</code> #loc
unnecessary.final.on.parameter.only.interface.option=僅對 abstract 或接口方法發出警告
unnecessary.final.on.parameter.problem.descriptor=參數 ''{0}'' 上存在不必要的 <code>#ref</code> #loc
unnecessary.final.report.local.variables.option=報告區域變數
unnecessary.final.report.parameters.option=報告參數
unnecessary.final.report.pattern.variables.option=報告模式變數
unnecessary.fully.qualified.name.display.name=不必要的完全限定名稱
unnecessary.fully.qualified.name.fix.family.name=取代完全限定名稱
unnecessary.fully.qualified.name.problem.descriptor1=限定符 <code>#ref</code> 不必要，可被取代為匯入 #loc
unnecessary.fully.qualified.name.problem.descriptor2=限定符 <code>#ref</code> 不必要，可以移除 #loc
unnecessary.fully.qualified.name.remove.quickfix=移除不必要的限定
unnecessary.fully.qualified.name.replace.quickfix=將限定名稱取代為匯入
unnecessary.fully.qualified.name.status.bar.escape.highlighting.message={0} 個完全限定{0, choice, 1#名稱|2#名稱}取代為匯入 (按 Esc 移除醒目提示)
unnecessary.inherit.doc.class.invalid.problem.descriptor=<code>#ref</code> 在類別上無效 #loc
unnecessary.inherit.doc.constructor.invalid.problem.descriptor=<code>#ref</code> 在建構函式上無效 #loc
unnecessary.inherit.doc.constructor.no.super.problem.descriptor=找不到繼承 Javadoc 的 super 方法 #loc
unnecessary.inherit.doc.display.name=不必要的 '{@inheritDoc}' Javadoc 註釋
unnecessary.inherit.doc.field.invalid.problem.descriptor=<code>#ref</code> 在欄位上無效 #loc
unnecessary.inherit.doc.module.invalid.problem.descriptor=<code>#ref</code> 在模組宣告上無效 #loc
unnecessary.inherit.doc.problem.descriptor=僅包含 <code>#ref</code> 的 Javadoc 註釋不必要 #loc
unnecessary.inherit.doc.quickfix=移除不必要的 {@inheritDoc}
unnecessary.initcause.display.name=對 'Throwable.initCause()' 的呼叫不必要
unnecessary.initcause.problem.descriptor=不必要的 <code>Throwable.#ref()</code> 呼叫
unnecessary.initcause.quickfix=移除 'Throwable.initCause()' 呼叫
unnecessary.inner.enum.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於內部枚舉是冗餘的 #loc
unnecessary.inner.interface.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於內部接口是冗餘的 #loc
unnecessary.inner.record.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於內部記錄是冗餘的
unnecessary.interface.field.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於接口欄位是冗餘的 #loc
unnecessary.interface.inner.class.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於接口的內部類別是冗餘的 #loc
unnecessary.interface.member.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於接口成員是冗餘的 #loc
unnecessary.interface.method.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於接口方法是冗餘的 #loc
unnecessary.interface.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於接口是冗餘的 #loc
unnecessary.java.doc.link.fix.family.name=移除冗餘標記
unnecessary.javadoc.link.display.name=不必要的 Javadoc 鏈接
unnecessary.javadoc.link.option=忽略 super 方法的內聯鏈接
unnecessary.javadoc.link.quickfix=移除不必要的 ''{0}''
unnecessary.javadoc.link.super.method.problem.descriptor=指向 super 方法的 <code>#ref</code> 不必要 #loc
unnecessary.javadoc.link.this.class.problem.descriptor=指向包含類別的 <code>#ref</code> 不必要 #loc
unnecessary.javadoc.link.this.method.problem.descriptor=指向此方法的 <code>#ref</code> 不必要 #loc
unnecessary.label.on.break.statement.display.name='break' 語句上的標籤不必要
unnecessary.label.on.break.statement.problem.descriptor=Break 語句上存在不必要的標籤 <code>#ref</code> #loc
unnecessary.label.on.continue.statement.display.name='continue' 語句上的不必要標籤
unnecessary.label.on.continue.statement.problem.descriptor=Continue 語句上存在不必要的標籤 <code>#ref</code> #loc
unnecessary.label.remove.quickfix=移除標籤
unnecessary.local.variable.problem.descriptor=區域變數 <code>#ref</code> 是冗餘的 #loc
unnecessary.modifier.display.name=不必要的修飾符
unnecessary.parentheses.conditional.option=忽略條件表達式條件周圍的圓括號
unnecessary.parentheses.display.name=不必要的圓括號
unnecessary.parentheses.option=忽略澄清圓括號
unnecessary.parentheses.problem.descriptor=<code>#ref</code> 周圍的圓括號不必要 #loc
unnecessary.parentheses.remove.quickfix=移除不必要的圓括號
unnecessary.qualifier.for.super.problem.descriptor='super' 上的限定符 <code>#ref</code> 在此上下文中不必要 #loc
unnecessary.qualifier.for.this.display.name='this' 或 'super' 的限定符不必要
unnecessary.qualifier.for.this.problem.descriptor='this' 上的限定符 <code>#ref</code> 在此上下文中不必要 #loc
unnecessary.qualifier.for.this.remove.quickfix=移除不必要的限定符
unnecessary.record.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於記錄是冗餘的
unnecessary.return.constructor.problem.descriptor=<code>#ref</code> 不必要，因為是建構函式中的最後一條語句 #loc
unnecessary.return.display.name=不必要的 'return' 語句
unnecessary.return.option=在具有 'else' 分支的 'if' 語句的 then 分支中忽略
unnecessary.return.problem.descriptor=<code>#ref</code> 不必要，因為是 'void' 方法中的最後一條語句 #loc
unnecessary.semicolon.display.name=不必要的分號
unnecessary.semicolon.ignore.after.enum.constants.option=忽略枚舉常數後的不必要分號
unnecessary.semicolon.problem.descriptor=不必要的分號 <code>#ref</code> #loc
unnecessary.semicolon.remove.quickfix=移除不必要的分號
unnecessary.strictfp.modifier.problem.descriptor=修飾符 <code>#ref</code> 在 Java 17 和更高版本上是冗餘的
unnecessary.string.escape.display.name=不必要的轉義字元
unnecessary.string.escape.problem.descriptor=<code>#ref</code> 進行了不必要的轉義
unnecessary.string.escape.quickfix=將不必要的轉義字元取代為未轉義字元
unnecessary.super.constructor.display.name=對 'super()' 的呼叫不必要
unnecessary.super.constructor.problem.descriptor=<code>#ref</code> 不必要 #loc
unnecessary.super.constructor.remove.quickfix=移除不必要的 'super()'
unnecessary.super.qualifier.display.name=不必要的 'super' 限定符
unnecessary.super.qualifier.problem.descriptor=限定符 <code>#ref</code> 在此上下文中不必要 #loc
unnecessary.super.qualifier.quickfix=移除不必要的 'super' 限定符
unnecessary.temporary.object.fix.family.name=取代串聯
unnecessary.temporary.on.conversion.from.string.display.name=從 'String' 轉換時有不必要的臨時物件
unnecessary.temporary.on.conversion.to.string.display.name=轉換為 'String' 時有不必要的臨時物件
unnecessary.this.display.name=不必要的 'this' 限定符
unnecessary.this.ignore.assignments.option=忽略欄位賦值
unnecessary.this.problem.descriptor=<code>#ref</code> 在此上下文中不必要 #loc
unnecessary.this.remove.quickfix=移除不必要的 'this' 限定符
unnecessary.tostring.call.display.name=對 'toString()' 的呼叫不必要
unnecessary.tostring.call.problem.descriptor=不必要的 <code>#ref()</code> 呼叫 #loc
unnecessary.transient.modifier.problem.descriptor=修飾符 <code>#ref</code> 對於 'static' 欄位是冗餘的
unnecessary.unary.minus.display.name=不必要的一元負號
unnecessary.unary.minus.problem.descriptor=不必要的一元 <code>#ref</code> 運算符 #loc
unnecessary.unary.minus.quickfix=移除一元負號並反轉父運算符號
unnecessary.unary.minus.remove.quickfix=移除雙一元減號
unnecessary.unboxing.display.name=不必要的拆箱
unnecessary.unboxing.problem.descriptor=不必要的拆箱 #loc
unnecessary.unboxing.remove.quickfix=移除拆箱
unnecessary.unboxing.superfluous.option=僅報告真正多餘的拆箱表達式
unnecessary.unicode.escape.display.name=不必要的 Unicode 轉義序列
unnecessary.unicode.escape.fix.family.name=取代為字元
unnecessary.unicode.escape.fix.text=取代為換行字元
unnecessary.unicode.escape.problem.descriptor=Unicode 轉義序列 <code>#ref</code> 可被取代為 ''{0}'' #loc
unnecessary.unicode.escape.problem.newline.descriptor=Unicode 轉義序列 <code>#ref</code> 可被取代為換行字元 #loc
unnecessary.unicode.escape.problem.tab.descriptor=Unicode 轉義序列 <code>#ref</code> 可被取代為制表符 #loc
unpredictable.big.decimal.constructor.call.display.name=不可預知的 'BigDecimal' 建構函式呼叫
unpredictable.big.decimal.constructor.call.ignore.complex.literals.option=忽略具有多個文字的建構函式呼叫 (例如 0.1 + 0.2)
unpredictable.big.decimal.constructor.call.ignore.references.option=忽略具有變量或方法呼叫實參的建構函式呼叫
unpredictable.big.decimal.constructor.call.problem.descriptor=不可預知的 <code>new #ref()</code> 呼叫 #loc
unqualified,static.usage.only.report.static.usages.option=僅報告來自非 static 上下文的靜態存取
unqualified.field.access.display.name=未使用 'this' 限定的實例欄位存取
unqualified.field.access.problem.descriptor=未使用 'this' 限定的實例欄位存取 <code>#ref</code> #loc
unqualified.inner.class.access.display.name=非限定內部類別存取
unqualified.inner.class.access.option=忽略對本地內部類別的參照
unqualified.inner.class.access.problem.descriptor=<code>#ref</code> 未使用外部類別限定 #loc
unqualified.inner.class.access.quickfix=使用外部類別限定
unqualified.method.access.display.name=未使用 'this' 限定的實例方法呼叫
unqualified.method.access.problem.descriptor=未使用 'this' 限定實例方法呼叫 <code>#ref()</code> #loc
unqualified.static.access.fix.family.name=限定靜態存取
unqualified.static.usage.display.name=非限定靜態存取
unqualified.static.usage.ignore.field.option=忽略非限定欄位存取
unqualified.static.usage.ignore.method.option=忽略非限定方法呼叫
unqualified.static.usage.problem.descriptor=非限定 static 方法呼叫 <code>#ref()</code> #loc
unqualified.static.usage.problem.descriptor1=非限定 static 欄位存取 <code>#ref</code> #loc
unqualified.static.usage.qualify.field.quickfix=限定 static 欄位存取
unqualified.static.usage.qualify.method.quickfix=限定 static 方法呼叫
unresolved.class.reference.repair.display.name=未解析的類別參照
unresolved.class.reference.repair.problem.descriptor=無法解析 ''{0}'' 參照
unrunnable.main.method.problem.descriptor=無法執行方法 <code>#ref()</code>，因為包含類別沒有完全限定名稱
unsecure.random.number.generation.display.name=不安全的隨機數生成
unsecure.random.number.generation.problem.descriptor1=出於安全目的，請使用 'java.security.SecureRandom' 而不是 <code>java.lang.Math.#ref()</code> #loc
unsecure.random.number.generation.problem.descriptor2=出於安全目的，請使用 'java.security.SecureRandom' 而不是 <code>java.util.#ref</code> #loc
unsecure.random.number.generation.problem.descriptor3=出於安全目的，請使用 'java.security.SecureRandom' 而不是 <code>#ref</code> #loc
unused.import.problem.descriptor=未使用的 import <code>#ref</code> #loc
unused.label.display.name=未使用的標籤
unused.label.problem.descriptor=未使用的標籤 <code>#ref</code> #loc
unused.label.remove.quickfix=移除未使用的標籤
update.column.name=更新名稱開頭
update.label=更新名稱開頭:
upper.case.field.name.not.constant.display.name=具有大寫名稱的非常數欄位
upper.case.field.name.not.constant.problem.descriptor=帶常數樣式名稱的非常數欄位 <code>#ref</code> #loc
usage.of.obsolete.assert.display.name=使用廢棄的 'junit.framework.Assert' 方法
use.0index.in.jdbc.prepared.statement.problem.descriptor=在 JDBC PreparedStatement 中使用索引 '0' #loc
use.0index.in.jdbc.resultset.display.name=在 JDBC ResultSet 中使用索引 0
use.0index.in.jdbc.resultset.problem.descriptor=在 JDBC ResultSet 中使用索引 '0' #loc
use.contentequals=使用 'contentEquals()' 與 'AbstractStringBuilder' 進行比較
use.equalsignorecase.for.case.insensitive.comparison=為不區分大小寫的比較使用 'equalsIgnoreCase()'
use.isblank.to.check.if.string.is.whitespace.or.empty=使用 'isBlank()' 檢查字串是否為空或者僅包含空格
use.obsolete.collection.type.display.name=使用廢棄的集合類型
use.obsolete.collection.type.ignore.library.arguments.option=在需要的位置忽略廢棄的集合類型
use.obsolete.collection.type.problem.descriptor=使用了廢棄的集合類型 <code>#ref</code> #loc
use.of.awt.peer.class.display.name=使用 AWT 對等類別
use.of.awt.peer.class.problem.descriptor=AWT 對等類別 <code>#ref</code> 的使用不可移植 #loc
use.of.clone.call.method.problem.descriptor=實作 <code>#ref()</code>
use.of.clone.call.problem.descriptor=呼叫 <code>#ref()</code>
use.of.clone.display.name=使用 'clone()' 或 'Cloneable'
use.of.clone.reference.problem.descriptor=使用 <code>#ref</code>
use.of.concrete.class.option.ignore.abstract=忽略抽象類別類型
use.of.concrete.class.option.ignore.records=忽略 Java 記錄
use.of.concrete.class.option.report.cast=報告轉換表達式中使用的類型
use.of.concrete.class.option.report.instance.fields=報告實例欄位類型
use.of.concrete.class.option.report.instanceof=報告 instanceof、patterns 或 getClass() 比較中使用的類型
use.of.concrete.class.option.report.local.variable=報告區域變數類型
use.of.concrete.class.option.report.method.returns=報告方法返回值類型
use.of.concrete.class.option.report.parameter=報告方法參數類型
use.of.concrete.class.option.report.static.fields=報告 static 欄位類型
use.of.concrete.jdbc.driver.class.display.name=使用具體的 JDBC 驅動程序類別
use.of.concrete.jdbc.driver.class.problem.descriptor=具體 JDBC 驅動程序類別 <code>#ref</code> 的使用不可移植 #loc
use.of.obsolete.assert.problem.descriptor=對來自 ''{0}'' 的 <code>#ref()</code> 的呼叫應被取代為對來自 ''org.junit.Assert'' 的方法的呼叫 #loc
use.of.obsolete.assert.quickfix=取代為 'org.junit.Assert' 方法呼叫
use.of.obsolete.date.time.api.display.name=使用廢棄的日期時間 API
use.of.obsolete.date.time.api.problem.descriptor=使用了廢棄的日期時間類型 <code>#ref</code> #loc
use.of.properties.as.hashtable.fix.family.name=修復屬性存取
use.processbuilder.class.display.name=使用 'java.lang.ProcessBuilder' 類別
use.processbuilder.class.problem.descriptor=<code>#ref</code> 的使用不可移植 #loc
use.stringtokenizer.display.name=使用 'StringTokenizer'
use.stringtokenizer.problem.descriptor=國際化上下文中的 <code>#ref</code> #loc
use.sun.classes.display.name=使用 'sun.*' 類別
use.sun.classes.problem.descriptor=Sun 提供的類別 <code>#ref</code> 的使用不可移植 #loc
use.system.out.err.display.name=使用 'System.out' 或 'System.err'
use.system.out.err.problem.descriptor=<code>#ref</code> 的使用可能應當取代為更可靠的日誌 #loc
utility.class.can.be.enum.display.name=實用程序類別可以是 'enum'
utility.class.code.can.be.enum.problem.descriptor=實用程序類別 <code>#ref</code> 可以是 'enum' #loc
utility.class.code.can.be.enum.quickfix=轉換為 'enum'
utility.class.display.name=實用程序類別
utility.class.problem.descriptor=類別 <code>#ref</code> 只有 'static' 成員，指示程序建構 #loc
utility.class.with.public.constructor.display.name=實用程序類別具有 'public' 建構函式
utility.class.with.public.constructor.fix.family.name=將建構函式設為非 public
utility.class.with.public.constructor.make.private.quickfix=將{0, choice, 1#建構函式|2#建構函式}設為 'private'
utility.class.with.public.constructor.make.protected.quickfix=將{0, choice, 1#建構函式|2#建構函式}設為 'protected'
utility.class.with.public.constructor.problem.descriptor=類別 <code>#ref</code> 只有 'static' 成員和 'public' 建構函式 #loc
utility.class.without.private.constructor.cant.generate.constructor.message=實用程序類別具有實例化，將不會建立 private 建構函式
utility.class.without.private.constructor.cant.generate.constructor.title=無法生成建構函式
utility.class.without.private.constructor.create.quickfix=生成空 'private' 建構函式
utility.class.without.private.constructor.display.name=實用程序類別沒有 'private' 建構函式
utility.class.without.private.constructor.make.quickfix=將建構函式設為 'private'
utility.class.without.private.constructor.option=忽略僅具有主方法的類別
utility.class.without.private.constructor.problem.descriptor=類別 <code>#ref</code> 只有 'static' 成員，缺少 'private' 建構函式 #loc
value.of.post.decrement.problem.descriptor=使用後減量表達式 <code>#ref</code> 的值 #loc
value.of.post.increment.problem.descriptor=使用後增量表達式 <code>#ref</code> 的值 #loc
value.of.pre.decrement.problem.descriptor=使用前減量表達式 <code>#ref</code> 的值 #loc
value.of.pre.increment.problem.descriptor=使用前增量表達式 <code>#ref</code> 的值 #loc
variable.argument.method.display.name=vararg 方法
variable.argument.method.problem.descriptor=vararg 方法 <code>#ref()</code> #loc
variable.argument.method.quickfix=將 vararg 參數轉換為數組
variable.not.used.inside.conditional.problem.descriptor=條件內未使用檢查為 'null' 的 <code>#ref</code> #loc
variable.not.used.inside.if.display.name='if' 內未使用檢查為 'null' 的參照
variable.not.used.inside.if.problem.descriptor='if' 內未使用檢查為 'null' 的 <code>#ref</code> #loc
variable.type.can.be.explicit.display.name=變數類型可以是顯式的
volatile.array.field.display.name=volatile 陣列欄位
volatile.field.problem.descriptor=類型 ''{0}'' 的 volatile 欄位 <code>#ref</code> #loc
wait.called.on.condition.display.name=在 'java.util.concurrent.locks.Condition' 物件上呼叫了 'wait()'
wait.called.on.condition.problem.descriptor=在條件物件上呼叫 <code>#ref()</code> #loc
wait.not.in.loop.display.name=未在迴圈中呼叫的 'wait()'
wait.not.in.loop.problem.descriptor=<code>#ref()</code> 呼叫不在迴圈中 #loc
wait.notify.not.in.synchronized.context.display.name='wait()' 或 'notify()' 不在同步的上下文中
wait.notify.while.not.synchronized.on.problem.descriptor=''{0}'' 未同步時呼叫 <code>#ref</code> #loc
wait.or.await.without.timeout.display.name=無超時的 'wait()' 或 'await()'
wait.or.await.without.timeout.problem.descriptor=無超時的 <code>#ref</code> #loc
wait.while.holding.two.locks.display.name=保持兩個鎖時 'wait()'
wait.while.holding.two.locks.problem.descriptor=在保持兩個鎖的情況下呼叫 <code>#ref()</code> #loc
wait.without.corresponding.notify.display.name=沒有相應 'notify()' 的 'wait()'
wait.without.corresponding.notify.problem.descriptor=在沒有相應 <code>notify()</code> 或 <code>notifyAll()</code> 的情況下呼叫 <code>#ref()</code> #loc
warn.level.and.lower.option=警告級別和更低
warn.on.label=警告物件:
weaken.visibility.quickfix=削弱可見性
while.can.be.foreach.display.name='while' 迴圈可被取代為增強的 'for' 迴圈
while.can.be.foreach.problem.descriptor=<code>#ref</code> 迴圈可被取代為增強的 'for' #loc
while.loop.spins.on.field.display.name='while' 迴圈在欄位上自旋
while.loop.spins.on.field.fix.family.name=修復自旋迴圈
while.loop.spins.on.field.fix.spinwait=新增 Thread.onSpinWait()
while.loop.spins.on.field.fix.volatile=將 ''{0}'' 設為 volatile
while.loop.spins.on.field.fix.volatile.spinwait=將 ''{0}'' 設為 volatile 並新增 Thread.onSpinWait()
while.loop.spins.on.field.ignore.non.empty.loops.option=僅當迴圈為空時才發出警告
while.loop.spins.on.field.problem.descriptor=<code>#ref</code> 迴圈在欄位上自旋 #loc
wrap.with.arrays.hash.code.quickfix=使用 ''{0}'' 包裝
write.only.object.display.name=只寫入物件
write.only.object.option.ignore.impure.constructors=忽略不純的建構函式"
`;

exports[`src messages/JavaScriptBundle.properties 1`] = `
"0.is.not.a.legal.name=''{0}'' 不是合法的類別名
0.is.not.accessible.from.1=無法從 {1} 存取 {0}
0.is.not.allowed.in.interface=接口中不允許使用 {0} 
0.with.1.visibility.in.the.target.class.is.not.accessible.from.2=目標類別中可見性為 {1} 的 {0} 無法從 {2} 存取
0.with.1.visibility.is.not.accessible.from.2=可見性為 {1} 的 {0} 將無法從 {2} 存取
action.Anonymous.text.configure=組態
action.EslintImportCodeStyle.description=套用 ESLint 程式碼樣式
action.ExplainNodeModulesLibrariesAction.text=解釋 node__modules 庫
action.FindDuplicatedIndexedFilesInNodeModulesAction.text=在 node__modules 中尋找重複的索引檔案
action.Generate.Constructor.JavaScript.text=建構函式
action.Generate.GetAccessor.JavaScript.text=Getter
action.Generate.GetSetAccessor.JavaScript.text=Getter 和 Setter
action.Generate.Missing.Members.ES6.text=實作方法…
action.Generate.Missing.Members.TypeScript.text=實作成員…
action.Generate.SetAccessor.JavaScript.text=Setter
action.InstallNodeLocalDependencies$Root.text=為 {1} 執行 ''{0}''
action.InstallNodeLocalDependencies.text=安裝 Node.js 相依項
action.JS.TypeScript.Include.Generated.Declarations.description=在專案中包含 .d.ts 子檔案
action.JS.TypeScript.Include.Generated.Declarations.text=包括 '.d.ts' 子檔案
action.JasmineGenerateAfterEachMethodAction.text=Jasmine afterEach
action.JasmineGenerateBeforeEachMethodAction.text=Jasmine beforeEach
action.JasmineGenerateNewSpecAction.text=Jasmine Spec
action.JasmineGenerateNewSuiteAction.text=Jasmine Suite
action.JavaScriptGenerateDictionaries.text=生成 JavaScript 拼寫檢查器字典
action.PackageJsonNewFile.description=建立 {0} 檔案
action.PackageJsonNewFile.text={0}
action.QUnitGenerateNewTestAction.text=QUnit Test
action.QUnitGenerateSetupAction.text=QUnit Setup
action.QUnitGenerateTearDownAction.text=QUnit TearDown
action.ReactClassToFunctionComponentAction.description=轉換為函式組件
action.ReactExtractComponentAction.description=提取組件
action.ReactFunctionToClassComponentAction.description=轉換為類別組件
action.ToggleNodeCoreCodingAssistanceAction.toggle.coding.assistance.for.node.js.text=切換 Node.js 的編碼輔助
action.TypeScriptExtractTypeAlias.description=提取類型別名
action.already.set.for.containing.folder.or.project.description=已針對包含的目錄或專案進行設定。
action.creates.new.file.description=建立新的 {0} 檔案
action.don.t.ask.again.text=不再詢問
action.don.t.use.library.description=不使用庫
action.js.tagged.literal.injection.text=JS 標記文字注入
action.jump.to.text=跳轉到…
action.name.add.explicit.value=新增枚舉顯式值
action.name.disable.category=停用 {0}
action.show.error.details.text=顯示錯誤詳細資訊
action.show.structure.text=顯示結構
action.structureview.show.object.inherited=從物件繼承
action.use.library.description=使用庫
action.view.install.text=檢視並安裝…
actionscript.space.after.dots.in.rest.parameter=在 rest 參數中的 '...' 後面
actionscript.validation.message.get.method.access.type.is.different.from.setter=Flash 編譯器錯誤 174646: Get 存取器方法存取類型不同於 set 存取器存取類型，應為 ''{0}''
actionscript.validation.message.set.method.access.type.is.different.from.getter=Flash 編譯器錯誤 174646: Set 存取器方法存取類型不同於 get 存取器存取類型，應為 ''{0}''
add.import.binding.to.import=將匯入綁定新增到匯入
add.import.specifier.to.import=將匯入說明符新增到匯入
add.variable.to.require=新增 require 呼叫的變數
anonymous.to.named.intention.function.name=函式名稱:
automatically.replace.with.template.string.on.typing=在輸入 '\${' 時自動將字串文字取代為模板字串
border.title.inspection.description.title=描述:
border.title.inspection.export.results.capitalized.location=位置
bower.correct.path=請更正 {0} 的路徑
bower.dialog.message.specify.package=指定正確的 bower 軟體套件: 未找到“{0}”檔案
bower.json=bower.json (&O):
bower.no_description_available.text=無可用描述
bower.package=Bower 軟體套件(&B):
bower.package.name=Bower 軟體套件
bower.packages.view.dependencies=相依項:
bower.required.version.notification.content=要檢視 bower 軟體套件，您需要 bower@1.0.0 或更高版本
build.event.title.failed.to.list.tasks=無法列出 {0} 任務
buildTools.EditRunSettingsAction.text=編輯 ''{0}'' 設定(&E)…
buildTools.JsbtAddBuildfileAction.text=新增 {0}
buildTools.JsbtReloadTasksAction.npm.text=重新載入腳本
buildTools.JsbtReloadTasksAction.text=重新載入任務
buildTools.JsbtRemoveBuildfileAction.text=移除 {0}
buildTools.JsbtRunTaskAction.text=執行 Gulp/Grunt/npm 任務
buildTools.JsbtShowTasksAction.npm.text=顯示 npm 腳本
buildTools.JsbtShowTasksAction.text=顯示 {0} 任務
buildTools.ShowSettingsAction.npm.text=編輯 npm 組態(&E)…
buildTools.ShowSettingsAction.text={0}設定…
buildTools.add.with=使用 {1} 新增 {0}
buildTools.choose_buildfile.text=選擇 {0}
buildTools.edit.run.configuration=編輯執行組態
buildTools.failed.to.list.tasks=無法列出任務
buildTools.failed.to.list.tasks.details.reference=詳細資訊
buildTools.no.files.added=未新增檔案
buildTools.no.such.file=沒有此類別檔案
buildTools.no.tasks.found=未找到任務
buildTools.searchEverywhere.npm.text=執行 ''{0}'' npm 腳本
buildTools.searchEverywhere.text=執行 ''{0}'' 任務
buildTools.tooltip.click.to.show.error.details=點擊以顯示錯誤詳細資訊
buildTools.tree.sortBy.definitionOrder.text=定義順序
buildTools.tree.sortBy.name.text=名稱
buildTools.tree.sortBy.text=排序方式
bundler.configuration.automatic=自動
bundler.configuration.automatic.hint={0} 將使用當前檔案所在目錄或其任意父目錄中的 {1} 組態檔案內的模組解析規則。
bundler.configuration.automatic.how.it.works=運作方式
bundler.configuration.detect.description=檢測適合模組解析的 {0} 組態檔案:
bundler.configuration.disabled=已停用
bundler.configuration.field=組態檔案:
bundler.configuration.field.required.error=手動模式下需要組態檔案路徑
bundler.configuration.manual=手動
button.abort=中止
button.continue=繼續
button.install.update=安裝/更新
can.t.find.flow.executable=找不到 Flow 可執行檔案
cannot.modify.library.code=無法修改庫或 SDK 程式碼
cannot.parse.service.initialization.answer.0=無法解析服務初始化回復 {0}\\n\\

cannot.refactor.anonymous.function=現有非呼叫用法阻止呼叫站點分析。
change.method.signature.and.update.delegating.call.fix.family.name=更改方法簽名並更新委託呼叫
change.method.signature.and.update.delegating.call.fix.text=更改 {0} 簽名以符合 {1} 呼叫和更新呼叫
change.method.signature.and.update.delegating.call.noname.fix.text=更改簽名以符合 {0} 呼叫和更新呼叫
change.method.signature.delegating.default.text=委託
change.method.signature.fix.family.name=更改方法簽名
change.method.signature.fix.text=更改 {0} 簽名
change.signature.call.expression.contains.spreads=函式呼叫包含傳播實參。用法將保持不變。
change.signature.column.name=名稱
change.signature.column.name.call.value=呼叫中的值
change.signature.column.name.default.parameter=預設參數
change.signature.column.name.initializer=初始設定式
change.signature.column.name.modifier=修飾符
change.signature.column.name.optional.flag=可選
change.signature.column.type=類型
change.signature.conflict.eliminating.parameter.property.breaks.usages=將參數-屬性轉換為簡單的參數將中斷 {0} 的欄位用法
change.signature.conflict.incompatible.implementation=實作 {0} 的參數個數與重構 {1} 的參數個數不同。重構期間將忽略 {2}。
change.signature.conflict.incompatible.override=覆寫 {0} 的參數個數與重構 {1} 的參數個數不同。重構期間將忽略 {2}。
change.signature.conflict.readonly.parameter.property.write.usage=將 {0} 變為唯讀將中斷非讀取用法
change.signature.dialog.title=更改 {0} 的簽名
change.signature.method.references.arguments=函式參照實參，更改簽名後代碼可能會中斷
change.signature.parameter.table.empty.message=使用  '+' 按鈕新增新參數
change.signature.tagged.template.issue=無法更新標記的模板呼叫。用法將保持不變。
change.signature.usage.view.declarations.header=要重構的方法
change.signature.value.column.title=值
changeSignature.vararg.not.last=Rest 參數應當為方法簽名中的最後一個參數
checkbox.collapse.array.literals=陣列文字
checkbox.collapse.object.literals=物件文字
checkbox.collapse.one.line.function.literals=JavaScript 和 TypeScript 中的單行函式
checkbox.collapse.xml.literals=XML 文字
checkbox.enable=啟用
checkbox.move.simple.expressions.to.field.initializer=將簡單表達式移至欄位初始設定式
choose.base.component.title=選擇超類別
choose.class.to.import.title=要匯入的類別
choose.declaration.element=<html><body>選擇 TypeScript 宣告</body></html>
choose.destination.scope=選擇目標作用域
choose.field.type=選擇欄位類型
choose.implementing.class=<html><body>選擇 <b>{0}</b> 的實作(找到 {1})</body></html>
choose.implementing.method=<html><body>選擇 <b>{0}</b> 的實作(找到 {1} 個)</body></html>
choose.overriding.function=<html><body>選擇 <b>{0}</b> 的覆寫函式(找到 {1} 個)</body></html>
choose.overriding.method=<html><body>選擇 <b>{0}</b> 的覆寫方法(找到 {1} 個)</body></html>
choose.subclass=<html><body>選擇 <b>{0}</b> 的子類別(找到 {1})</body></html>
choose.super.class.title=選擇超類別
choose.super.classifier=<html><body>選擇 <b>{0}</b> 的超類別或接口(找到 {1})</body></html>
choose.super.field=<html><body>選擇 <b>{0}</b> 的 Super 欄位(找到 {1})</body></html>
choose.super.function=<html><body>選擇 <b>{0}</b> 的 Super 函式(找到 {1})</body></html>
choose.super.interface.title=選擇 Super 接口
choose.super.method=<html><body>選擇 <b>{0}</b> 的 Super 方法(找到 {1})</body></html>
class.0.cannot.be.created=無法建立目標類別 {0}，因為存在同名的限定元素
class.already.contains.field.warning=類別 ''{0}'' 已包含欄位 ''{1}''。\\n\\
是否繼續?
class.already.contains.method.warning=類別 ''{0}''''已經 {1, choice, 1# 包含|2#繼承] 方法 ''{2}()''。\\n\\
是否繼續?
class.chooser.not.available.in.dumb.mode=正在進行索引更新，選擇器不可用。
class.does.not.have.inheritors.in.current.project={0} 在當前專案中沒有繼承者
class.names={0,choice,1#類別|2#類別} {1}
class.template.title=類別
class.with.supers.template.title=包含 Super 的類別
code.vision.implementations.hint={0, choice, 1#1 個實作|2#{0,number} 個實作}
code.vision.inheritors.hint={0, choice, 1#1 個繼承者|2#{0,number} 個繼承者}
code.vision.overrides.hint={0, choice, 1#1 個覆寫|2#{0,number} 個覆寫}
code.vision.performance.watcher.notification.configure=組態…
code.vision.performance.watcher.notification.disable.code.vision=停用提示
code.vision.performance.watcher.notification.message=停用 Code Vision 提示可以通過減少 CPU 負載來提高性能。
code.vision.performance.watcher.notification.title=Code Vision 提示評估緩慢
codestyle.ui.field.prefix=欄位前綴 (&F):
codestyle.ui.file.name.style=檔案命名約定 (&N):
codestyle.ui.generated.jsdoc.use.types.checkbox=在 JSDoc 中包括類型 (&T)
codestyle.ui.property.prefix=屬性前綴 (&P):
collection.queried.but.not.update=查詢了集合 <code>#ref</code> 的內容，但從未寫入
collection.updated.but.not.queried=更新了集合 <code>#ref</code> 的內容，但從未被查詢
command.name.add.explicit.value=新增顯式值 ''{0}''
command.name.create.javascript.file=建立 JavaScript 檔案 {0}
command.name.create.typescript.file=建立 TypeScript 檔案 {0}
command.name.extract.named.type=提取已命名類型
command.name.import=匯入 {0}
complete.import.binding=完整的匯入綁定
complete.import.name=完整的匯入名稱
configurable.JSCodeCompletionConfigurable.display.name=JavaScript
configurable.JSSmartKeysConfigurable.display.name=JavaScript
configurable.JSTemplateLangConfigurable.display.name=模板
configurable.MyConfigurable.display.name=JSX
configure.code.completion.settings=組態程式碼補全設定
configure.node.interpreter.path=組態 Node.js 路徑…
copying.files=正在複製檔案
create.button.text=建立(&C)
create.class.interfaces.label=接口(&I):
create.class.name.label=名稱(&N):
create.class.ok.button.text=建立
create.class.package.label=軟體套件:
create.class.superclass.label=超類別(&S):
create.class.template.label=模板(&T):
create.constructor.dialog.title=建立建構函式
create.field.dialog.title=建立欄位
create.file.name=建立檔案 ''{0}''
create.file.name.with=使用 {1} 建立檔案 ''{0}''
create.file.name.with.and=使用 {1} 和 {2} 建立檔案 ''{0}''
create.js.file.description=從指定的模板建立 JavaScript 檔案
create.method.dialog.title=建立方法
create.mobile.view=建立檢視 ''{0}''
create.react.app.description=<a href="https://github.com/facebookincubator/create-react-app">建立 React 套用</a>是官方支援的一種建立單頁 React 套用程序的新方法。它提供了沒有組態的現代建置設定。
create.react.app.name=React
create.react.app.scripts.version=腳本版本 (&V)
create.react.app.typescript.checkbox=建立 TypeScript 專案(&T)
create.ts.file.description=建立新的 TypeScript 檔案
custom.template.variables=自訂模板變數(&C):
custom.variables.step.title.label.text=模板 ''{0}'' 中的自訂變數 (&C):
declare.event.0=宣告事件 ''{0}''
declare.static=宣告 static(&S)
diagram.element.not.found={0} (未找到)
dialog.kind.0.file={0} 檔案
dialog.message.cannot.compile.typescript.config.file.incorrect=無法編譯 TypeScript。組態檔案不正確。
dialog.message.cannot.create.argument.stubs.invoked.method.function=無法建立實參存根: 呼叫的方法不是函式
dialog.message.cannot.determine.package.json.directory=無法確定 package.json 目錄
dialog.message.cannot.find.file=找不到檔案 {0}
dialog.message.cannot.find.module.for.import=無法建置用於匯入的模組路徑
dialog.message.cannot.find.module.types=找不到模組 @types/{0}
dialog.message.cannot.find.npx.bundled.with=找不到使用 {0} 捆綁的 npx
dialog.message.cannot.infer.type.new.parameter=無法推斷新參數的類型
dialog.message.cannot.locate.wrapper.config.file=找不到包裝器組態檔案
dialog.message.cannot.proceed.when.having.non.read.usages.in.embedded.expressions=嵌入式表達式中有非讀取用法時，無法繼續
dialog.message.cannot.propagate.variable=無法傳播變數: {0}
dialog.message.cannot.propagate.when.having.usages.declarations.in.different.files=用法和宣告位於不同檔案中時，無法傳播
dialog.message.cannot.transform.object.array.destructuring.patterns.for.same.element=無法為相同的元素轉換物件和陣列解構模式
dialog.message.command.cancelled=指令 ''{0}'' 已取消
dialog.message.command.finished.with.exit.code=指令 ''{0}'' 已完成，退出程式碼為 {1}。Stdout:\\n\\
{2}\\n\\
\\n\\
stderr:\\n\\
{3}
dialog.message.command.supported.by={1} 不支持指令 ''{0}''
dialog.message.command.timed.out=指令 ''{0}'' 超時
dialog.message.component.name=組件名稱:
dialog.message.expression.indexed.by.non.numeric.value=表達式使用非數字值編制索引
dialog.message.failed.to.download.0.1=無法下載 {0}。{1}
dialog.message.incomplete.destructuring.pattern.encountered.in.code=在程式碼中遇到不完整的解構模式
dialog.message.incorrect.path.to.typescript.package=typescript 軟體套件的路徑不正確
dialog.message.invalid.npm.package=無效的 {0} 軟體套件: 無此類別檔案或目錄
dialog.message.invalid.npx.command=無效的 npx 指令
dialog.message.invalid.package.file.specified.but.directory.with.package.json.expected={0} 軟體套件無效: 指定了一個檔案，但應為包含 package.json 的目錄
dialog.message.invalid.package.no.such.directory=無效的 {0} 軟體套件: 無此類別目錄
dialog.message.no.npm.script=無 ''{0}'' npm 腳本
dialog.message.no.path.to.package.json.found=未找到 package.json 的路徑。
dialog.message.no.results.for.after={1} 之後沒有 {0} 的結果
dialog.message.no.such=沒有這樣的 {0}
dialog.message.node.interpreter.unspecified.error.text=請指定 Node.js 解釋器
dialog.message.package.yarn.installed.package.format.yarn.relative.path.to.package.json.package.name={0}軟體套件: Yarn 安裝的軟體套件格式為 ''yarn:[package.json 的相對路徑]:[軟體套件名稱]''。
dialog.message.please.select.distribution=請選擇分發版
dialog.message.please.specify.npm.scripts.to.run=請指定要執行的 npm 腳本
dialog.message.please.specify.package.json=請指定 package.json
dialog.message.please.specify.package.json.correctly=請正確指定 package.json
dialog.message.please.specify.stylelint.package.correctly=正確指定 Stylelint 軟體套件: 找不到 Stylelint 二進制檔案
dialog.message.please.specify.wsl.path.to.node.js.interpreter=請指定 WSL 中安裝的 Node.js 解釋器的路徑
dialog.message.some.usages.cannot.be.updated.properly=有些用法無法正常更新。\\n\\
匯入和匯出中的用法、字串用法或動態參照無法取代為解構。
dialog.message.some.usages.cannot.be.updated.properly.wrong.access=有些用法無法正常更新。\\n\\
無法取代不按名稱存取屬性的用法或者不按索引存取元素的用法。
dialog.message.transforming.multiple.nested.patterns.not.supported=陣列解構不支持轉換多個嵌套模式
dialog.message.unspecified=未指定的 {0}
dialog.message.unspecified.package=未指定 {0} 軟體套件
dialog.message.unspecified.package.name=未指定軟體套件名稱。
dialog.message.unspecified.suite.name=未指定的套件名稱
dialog.message.unspecified.test.name=未指定的測試名稱
dialog.message.unsupported.destructuring.container=不支持的解構容器: {0}
dialog.message.usages.search.was.interrupted=用法搜尋被中斷
dialog.message.variables.from.destructuring.pattern.have.no.usages=來自於解構模式的變數沒有用法
dialog.message.write.usages.cannot.be.updated.with.destructuring=寫入用法無法通過重構進行更新
dialog.title.add.classes=新增類別
dialog.title.cannot.convert=無法轉換
dialog.title.cannot.introduce.new.interface=無法引入新接口
dialog.title.cannot.propagate=無法傳播
dialog.title.configure.coding.assistance.for.node.js.api=組態 Node.js API 編碼輔助
dialog.title.download.error=下載錯誤
dialog.title.edit.run.debug.configuration=編輯執行/偵錯組態: ''{0}''
dialog.title.error.details=錯誤詳細資訊
dialog.title.grunt.settings=Grunt 設定
dialog.title.gulp.settings=Gulp 設定
dialog.title.main.file=主檔案
dialog.title.missing.dependencies=缺少相依項
dialog.title.move.members=移動成員
dialog.title.new.javascript.file=新增 JavaScript 檔案
dialog.title.new.typescript.file=新增 TypeScript 檔案
dialog.title.output.directory=輸出目錄
dialog.title.select.navigation.target=選擇導覽目標
dialog.title.select.parameters.to.convert.to.parameter.properties=選擇要轉換為參數-屬性的參數
dialog.title.select.targets.to.convert.to.class=選擇要轉換為類別的目標
dialog.title.wsl.node.interpreter={0} WSL Node 解釋器
dialog.title.wsl.node.interpreter.edit=編輯
dialog.title.wsl.node.interpreter.edit.add=新增
directory.already.contains.file=目錄 ''{0}'' 已包含檔案 ''{1}''
duplicate.parameter.name=重複的參數名稱: {0}
ecmascript.6.or.higher=ECMAScript 6 或更高版本
editor.notification.label.enable.babel.file.watcher.question=是否啟用 File Watcher 以使用 Babel 將 ECMAScript 6 轉換為 ECMAScript 5?
element.name.anonymous=<匿名>
element.name.default=<預設>
enable.notifications.about.installing.dependencies.from.package.json=啟用有關從 package.json 安裝相依項的通知
entity.in.parent.description={0} ({1} 內)
env.variable.empty={0} 為空
env.variable.undefined={0} 未定義
error.not.available.in.javascript.code={0} 在 JavaScript 程式碼中不可用
error.wrong.caret.position.method.name=文字游標應置於要重構的方法的名稱處。
es6.auto.import.options.completion.add.imports=自動新增 JavaScript import
es6.auto.import.options.title=TypeScript / JavaScript
es6.change.to.default.fix=對 ''{0}'' 使用預設匯入
es6.change.to.named.import.fix=對 ''{0}'' 使用命名匯入
es6.changeSignature.call.value.not.allowed=參數 ''{0}'' 不允許使用呼叫中的值。因為沒有為前面的參數指定它。
es6.changeSignature.no.call.value=新參數 ''{0}'' 已新增。\\n\\
指定要用於此方法的所有現有呼叫的預設值或值。
es6.code.style.path.mapping.always=始終
es6.code.style.path.mapping.different.paths=僅在指定路徑以外的檔案中
es6.code.style.path.mapping.never=從不
es6.default.export.not.declared=未在匯入的模組中宣告預設匯出
es6.extract.super.destination.label=目標檔案 (&D):
es6.extract.super.different.name.expected=應為不同名稱
es6.extract.super.members.in.interface=新接口中的成員
es6.extract.super.members.in.superclass=新超類別中的成員
es6.extract.super.overload.declaration.without.implementation.conflict=類別中不允許沒有實作的多載宣告 {0}
es6.generate.index.action=生成 index.js/index.ts
es6.generate.index.action.description=生成 index.js/index.ts
es6.import.options.blacklist.title=不從指定路徑或路徑模式匯入:
es6.import.options.exts.help=此選項用於組態 import 語句中的副檔名。<br><br>選擇“自動”時，IDE 會向 vue 檔案、來自在 package.json 中具有 "type": "module" 的專案的檔案，以及擴展名為 .mjs 或 .cjs 的檔案的名稱新增副檔名。<br><br>選擇“始終”時，IDE 會始終向檔名新增副檔名。<br><br>選擇“從不”時，IDE 會始終使用不帶副檔名的檔名。
es6.import.options.not.import.help=此選項會組態 IDE 在自動匯入符號期間跳過的確切路徑。相反，IDE 將尋找替代路徑來匯入符號。路徑應符合 glob 模式規則。
es6.import.options.paths=使用路徑別名:
es6.import.options.paths.help=此選項用於組態 import 語句中使用的路徑樣式。<br><br>選擇“始終”時，IDE 會始終使用來自 webpack、vite 或 jsconfig.json 組態的別名。<br><br>選擇“僅在指定路徑之外的檔案中”時，IDE 會針對為之定義了別名的檔案之間的匯入使用相對路徑。在所有其他檔案中，使用路徑映射。<br><br>選擇“從不”時，則從不使用別名。
es6.insert.await.fix=插入 await
es6.missing.await.report.for.promises=報告 return 語句中的 promise
es6.missing.await.report.for.promises.hint=在異步函式呼叫前插入 'await' 有助於 V8 提供異步堆疊追蹤
es6.move.module.members.cannot.detect.js.language=目標檔案不是 JS 檔案
es6.move.module.members.destination.contains.default.export=目標模組包含預設匯出
es6.move.module.members.destination.does.not.support.jsx={0} 包含 JSX 標籤，但目標語言不支持這些標籤
es6.move.module.members.destination.not.es6=目標檔案 {0} 不是 ES6 模組
es6.move.module.members.has.local.usage.message=檔案 {1} 中使用未匯出的 {0}
es6.move.module.members.incompatible.language=目標模組具有不相容的語言
es6.move.module.members.non.es6.module.usage=在非 ES6 模組的檔案 {1} 中使用 {0}
es6.move.module.members.refactoring.create.file=建立檔案
es6.move.module.members.refactoring.create.file.message=檔案 {0} 不存在。\\n\\
是否要建立?
es6.move.module.members.refactoring.dialog.error.incorrect.module=目標模組不正確
es6.move.module.members.refactoring.dialog.error.invalid.file.name=目標檔名在此作業系統中無效
es6.move.module.members.refactoring.dialog.error.modules.same=源模組和目標模組應不同
es6.move.module.members.refactoring.dialog.error.no.script.tag=目標檔案不包含腳本標籤
es6.move.module.members.refactoring.dialog.error.no.selected.items=沒有要移動的選定成員
es6.move.module.members.refactoring.dialog.field.from=從:
es6.move.module.members.refactoring.dialog.field.to=到:
es6.move.module.members.refactoring.dialog.move.member.to=成員移動至
es6.move.module.members.refactoring.file.does.not.exist=檔案 {0} 不存在
es6.move.module.members.refactoring.name=移動模組成員
es6.move.module.members.references.local.message=選擇的 {0} 參照非匯出 {1}
es6.move.module.members.references.unresolved.import.message=選擇的 {0} 參照未解析匯入 {1}
es6.move.module.members.syntax.errors=移動 {0} 將引入語法錯誤，因為目標語言不同於源語言
es6.move.module.members.table.title=要移動的成員
es6.prefer.short.import.name=可以縮短匯入
es6.redundant.await.report.for.promises=報告 promise
es6.redundant.await.report.for.promises.hint=總是報告 'return await' 為冗餘，但這會破壞 V8 的異步堆疊追蹤功能
es6.replace.import.action.name=取代為 {0}
es6.replace.import.family.name=取代為較短的路徑
es6.validate.import.error=無法解析符號 ''{0}''
es6.validation.message.const.variable.without.initializer=不允許使用無初始設定式的 'const' 變數
escape.jsdoc.copy.pasted.text=在複製和貼上時轉義 JSDoc 前導星號
escape.pasted.text=在貼上字串文字時轉義文本
eslint.action.fix.problems.description=通過呼叫 'eslint --fix' 修正 ESLint 問題
eslint.additional.rules.directory.field.name=其他規則目錄
eslint.code.style.apply.message=套用 ESLint 的程式碼樣式?
eslint.code.style.apply.text=是
eslint.code.style.dismiss.text=否
eslint.configurable.additionalRulesDir.browseDialogTitle=選擇 ESLint 其他規則目錄
eslint.configurable.additionalRulesDir.label=其他規則目錄 (&R):
eslint.configurable.config.autoSearch.description.bodyInnerHtml=ESLint 將在要 lint 的檔案的目錄中以及連續的父目錄中尋找 .eslintrc.* 和 package.json 檔案，直至尋找到檔案系統的根目錄。<div style="padding-top:8px">要使用 package.json，請將您的組態新增到 <code>eslintConfig</code> 屬性下。</div>
eslint.configurable.config.select.config.text=選擇 ESLint 組態檔案(*.eslintrc.*)
eslint.configurable.eslintPackage.label=ESLint 軟體套件(&E):
eslint.configurable.extraOptions.label=額外 eslint 選項 (&O):
eslint.configurable.label.working.directories=工作目錄(&W):
eslint.configurable.working.dir.field.empty.text=由最近的 .eslintrc 或 .eslintignore 檢出
eslint.configurable.working.directories.comment=<html>路徑或 <a href='https://github.com/isaacs/node-glob#glob-primer'>glob 模式</a>，以分號分隔。為自動檢測留空。</html>
eslint.configuration.file.field.name=ESLint 組態檔案
eslint.error.package.directory.expected=應為軟體套件目錄
eslint.files.pattern.comment=<html>使用 <a href=''https://github.com/isaacs/node-glob#glob-primer''>glob 模式</a>，例如，<code>{**/*,*}.{js,ts}</code></html>
eslint.fix.problems.family.name={0}: 修復當前錯誤
eslint.fix.problems.text.current={0}: 修復當前錯誤
eslint.fix.problems.text.with.error.code={0}: 修復 ''{1}''
eslint.inspections.error.can.not.parse.message=無法解析訊息，應為 JSON 物件，但實際為: {0}
eslint.inspections.error.messages.not.array=訊息不是陣列: {0}
eslint.inspections.error.unexpected.language.service.response=意外的語言服務響應: {0}
eslint.inspections.error.unknown.message.severity=未知的訊息嚴重性: {0}\\n\\
主體:\\n\\
{1}
eslint.run.for.files.label=為檔案執行(&F):
eslint.run.on.save=儲存時執行 eslint --fix(&U)
eslint.run.on.save.auto.configuration.comment=自動 ESLint 組態
eslint.run.on.save.checkbox.on.actions.on.save.page=執行 eslint --fix
eslint.run.on.save.disabled.comment=已停用 ESLint 整合
eslint.run.on.save.link.enable.eslint=啟用 ESLint…
eslint.run.on.save.manual.configuration.comment=手動 ESLint 組態
eslint.version.0.is.not.supported.please.upgrade.eslint=ESLint 版本 {0} 不受支援。請升級 ESLint。
extract.0.turn.refs=提取 {0} 並盡量使用 (&T)
extract.constant.type=類型(&T):
extract.function.declare.functional.expression=宣告函式表達式(&F)
extract.function.function=函式
extract.function.name=名稱(&N):
extract.function.parameters=參數
extract.function.return.type=返回值類型(&T):
extract.function.signature.preview=簽名預覽
extract.interface.command.name=提取接口
extract.method.declare.static=宣告 static(&S)
extract.subclass.command.name=從 {1} 提取子類別 {0}
extract.type.alias.command.name=提取類型別名
failed.to.download=無法下載
field.initializer.is.not.specified=未指定欄位初始設定式
file.name.masks.to.skip.from.analysis=要在分析中排除的檔名遮罩:
filetype.actionscript.description=ActionScript
filetype.ecmascript6.description=ECMAScript 6
filetype.flow.description=Flow JS
filetype.flow.display.name=Flow JS
filetype.javascript.description=JavaScript
filetype.js.testing.snapshot.description=JavaScript 測試快照(Jest)
filetype.js.testing.snapshot.display.name=JavaScript 測試快照
filetype.jshint.config.description=JSHint 組態
filetype.jshint.config.display.name=JSHint 組態
filetype.jsx.description=React JSX
filetype.jsx.display.name=React JSX
filetype.typescript.config.description=TypeScript 組態
filetype.typescript.config.display.name=TypeScript 組態
filetype.typescript.description=TypeScript
filetype.typescript.jsx.description=TypeScript JSX
filetype.yarn.lock.description=Yarn lock
filetype.yarn.lock.display.name=Yarn Lock
find.usages.of.base.class={1} 的方法 {0}\\n\\
覆寫 {2} 的方法。\\n\\
要{3}基方法嗎?
find.usages.of.base.interface={1} 的方法 {0}\\n\\
實作 {2} 的方法。\\n\\
要{3}基方法嗎?
flow.js.get.type=Flow JS:Get 類型
flow.js.show.settings=組態 Flow…
flow.js.widget.display.name=Flow JS
flow.js.widget.name=Flow
flow.show.error.details=顯示錯誤詳情
function.names={1}{0,choice,1#函式|2#函式} 
function.returns=函式返回值類型
function.returns.description=函式返回值類型
generate.constructor.overloads.and.fields.chooser.title=選擇要使用的多載和要初始化的欄位
generate.delegate.method.conflict.message=無法通過不同的屬性為同名成員生成委託
generate.delegate.method.conflict.message.title=無法生成委託
generate.filter.button.description=在列表中顯示 {0} 
generate.filter.button.tooltip=顯示 {0}
generate.filter.fields=欄位和屬性
generate.filter.indexers=索引器
generate.filter.methods=方法
generate.to.string.chooser.title=選擇要在 toString 函式中使用的欄位
generating.0=正在生成 {0}
generation.bindable.event=可綁定事件(&B):
generation.event.constant=事件常數(&E):
group.Editor.JSLibrariesMenu.description=選擇要與當前檔案一起使用的 JavaScript 庫
group.Editor.JSLibrariesMenu.text=使用 JavaScript 庫
grunt.before.run.task=執行 Grunt 任務
grunt.before.run.task.descr=執行 Grunt {0, choice, 0#任務|1#任務 |2#任務 }{1} [{2}]
grunt.gruntfile.not.found=未找到 Gruntfile
grunt.rc.arguments.label=實參(&R):
grunt.rc.environmentVariables.label=環境(&E):
grunt.rc.gruntCliPackage.label=軟體套件 grunt-cli (&P):
grunt.rc.gruntfile.browseDialogTitle=選擇 Gruntfile
grunt.rc.gruntfile.label=Gruntfile (&F):
grunt.rc.nodeInterpreter.label=Node 解釋器(&I):
grunt.rc.nodeOptions.label=Node 選項(&O):
grunt.rc.tasks.label=任務(&T):
grunt.task.title=Grunt 任務
grunt.unspecified.gruntfile=未指定 Gruntfile
gulp.before.run.task=執行 gulp 任務
gulp.before.run.task.descr=執行 gulp {0, choice, 0#任務|1#任務 |2#任務 }{1} [{2}]
gulp.gulpfile.not.found=未找到 Gulpfile
gulp.gulpfile.unspecified=未指定 Gulpfile
gulp.rc.arguments.label=實參(&R):
gulp.rc.environmentVariables.label=環境(&E):
gulp.rc.gulpPackage.label=Gulp 軟體套件(&G):
gulp.rc.gulpfile.browseDialogTitle=選擇 gulpfile.js
gulp.rc.gulpfile.label=Gulpfile (&F):
gulp.rc.nodeInterpreter.label=Node 解釋器(&I):
gulp.rc.nodeOptions.label=Node 選項(&O):
gulp.rc.tasks.label=任務(&T):
gulp.task.title=Gulp 任務
header.declarations.to.be.refactored=要重構的宣告
icon.icons.nodes.readonlyMark.tooltip=唯讀
ignore.unused.option.all=全部
ignore.unused.option.before.used=使用前
ignore.unused.option.none=無
implement.members.abstract=實作 abstract 成員
import.options.find.more.configuration.options=在<a>程式碼樣式</a>中尋找更多組態選項
initialize.fields.intention.visibility=可見性:
inlay.hints.usages.text={0,choice, 0#無用法|1#1 個用法|2#{0,number}'{1,choice, |1#+}' 用法}
inlay.parameters.angular.show.names.for.all.args=Angular HTML 模板中的文字和命名物件參數。
inlay.parameters.angular.show.names.for.pipes=<a href='https://angular.io/guide/pipes'>Angular HTML 模板中的管道。</a>
inlay.parameters.js.only.show.names.for.all.args=文字和非文字實參、呼叫表達式、物件和陣列初始設定式。
inlay.parameters.js.only.show.names.for.pipes=<a href='https://github.com/tc39/proposal-pipeline-operator'>管道運算符中的參數。</a>
inlay.parameters.js.only.show.names.for.tagged=<a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates'>標記模板中的實參。<a><br>此設定僅對非文字實參生效，並且僅在啟用“非文字實參”選項時可用。
inlay.parameters.js.param.hints.show.names.for.all.args=方法呼叫中的文字和命名物件參數。
inlay.parameters.js.param.hints.show.names.for.tagged=標記模板中的實參。
inlay.parameters.vuejs.show.names.for.all.args=文字和命名物件。
inlay.parameters.vuejs.show.names.for.filters=<a href='https://v2.vuejs.org/v2/guide/filters.html'>篩選器(Vue 2)。</a>
inline.cannot.inline.has.supers=無法內聯擴展其他類型的 {0} 
inline.cannot.inline.references.this.type=無法內聯參照 'this' 類型的接口
inline.type.used.in.reference.list=無法在''{0}'' 列表中內聯用法
insert.class.fix.name=新增類別名限定符
insert.new.keyword.fix.name=插入新關鍵字
insert.this.keyword.fix.name=新增 this 限定符
inspection.NodeCoreCodingAssistanceInspection.no.coding.assistance.message=Node.js 的編碼輔助已被停用
inspection.message.installed.version.doesn.t.match.version.range=安裝的版本 {0} 與版本範圍 {1} 不符合
inspection.message.package.installed=未安裝 {0} 軟體套件
inspection.message.package.version.specified=未指定軟體套件版本
inspection.message.reference.includes.files.outside.project=參照包括專案範圍之外的檔案
inspection.message.sm.test.runner.magnitude.assertion.failed.title=斷言失敗
inspection.update.package_json.dependency.action.text=將 ''{0}'' 更新到最新版本 {1}
inspection.update.package_json.dependency.message=有可用的 ''{0}'' 新版本: {1}
intellilang.tagged.literal.expression.border.title=模板標籤
intellilang.tagged.literal.injection.name.label=模式:
intention.category.ecmascript6=JavaScript/ECMAScript 6
intention.category.javascript=JavaScript
intention.category.react=React
intention.category.typescript=TypeScript
intention.family.name.add.required.property=新增所需的屬性
intention.family.name.generate.prop.types=為組件生成 propTypes
intention.family.name.introduce.parameter.properties.for.unused.parameters=轉換為參數屬性
intention.family.name.run.npm.install=執行 'npm install'
intention.family.name.select.in.test.tree=在測試樹中選擇
intention.family.name.suppress.with.ts.ignore=使用 @ts-ignore 禁止
intention.family.name.surround.with.tag=使用標記包圍
intention.name.add.file.to.tsconfig=將檔案 ''{0}'' 新增到 tsconfig.json
intention.name.create.library.with.files.outside.project=使用專案外部的檔案建立庫
intention.name.import.augmentation=匯入擴大 {0}
intention.name.loading.service.fixes=正在載入服務修正…
intention.name.navigate.to=導覽到 {0}
intention.name.run.npm=執行 ''{0}''
intention.name.surround.with.tag=使用 <{0}> 包圍
interface.cannot.be.extracted.from.enum=無法從枚舉中提取接口
interface.cannot.be.extracted.from.type.alias=無法從類型別名中提取接口
interface.function.declaration.should.have.no.body=接口函式宣告不應有本體
interface.should.have.no.variable.declarations=接口不應有變量宣告
interface.template.title=接口
introduce.constant.target.class=目標類別(&A):
introduce.field.class.constructor=類別建構函式(&C)
introduce.field.current.method=當前方法(&M)
introduce.field.declaration=欄位宣告(&D)
introduce.field.initialize.in=初始化位置
introduce.field.type=類型(&T):
introduce.parameter.optional=可選參數(&O)
introduce.parameter.type=類型(&T):
introduce.variable.const=const(&C)
introduce.variable.declaration=變數宣告
introduce.variable.let=let(&L)
introduce.variable.make.constant=設為常數(&C)
introduce.variable.var=var(&V)
introduce.variable.var.of.type=類型的變數(&T):
invalid.field.type.expression=無效欄位類型: ''{0}''
invalid.identifier.value.0=無效關鍵字: ''{0}''
invalid.parameter.type.expression=參數類型 ''{0}'' 無效
invalid.return.type.expression=返回值類型 ''{0}'' 無效
item.already.exists={0} {1} 已存在
javascript.abstract.class.can.not.be.instantiated.message=無法實例化抽象類別
javascript.ambient.declaration.const.should.be.primitive=環境上下文中的 'const' 初始設定式必須是基元文字或文字枚舉參照
javascript.ambient.declaration.should.have.no.body=環境宣告不應有本體
javascript.ambient.declaration.should.have.no.initializer=環境宣告不應有初始設定式
javascript.argument.type.mismatch=實參類型 {1} 不可分配給參數類型 {0}
javascript.argument.types.mismatch=實參類型與參數不符合
javascript.assign.parameter.to.field.intention.name=分配參數 ''{0}'' 給欄位
javascript.assigned.expression.type.mismatch=分配的表達式類型 {1} 不可分配給類型 {0}
javascript.assume.uppercase.functions.to.be.constructors=假設只有大寫的函式是建構函式
javascript.auto.import.options.add.imports.on.the.fly=動態明確 import
javascript.auto.import.options.add.on.code.completion=程式碼補全時
javascript.auto.import.options.show.popup=包含自動匯入工具提示
javascript.badcharacter=錯誤字元
javascript.blockcomment=塊註釋
javascript.braces=大括號
javascript.brackets=中括號
javascript.cannot.return.expression.from.function.with.void.result.type=無法從結果類型為 void 的函式返回值
javascript.cannot.return.expression.from.function.with.void.result.type.fix=移除返回值
javascript.change.jsdoc.type.family.name=更改 JSDoc 中元素的類型
javascript.change.language.level.family=更改 JavaScript 語言版本
javascript.change.language.level.message=更改 JavaScript 語言版本為 {0}
javascript.change.signature.invalid.function.name.0=無效函式名稱: ''{0}''
javascript.change.signature.invalid.parameter.declaration=無效參數: ''{0}''
javascript.changeSignature.call.value.not.allowed=參數 ''{0}'' 不允許使用預設值。因為沒有為前面的參數指定它。
javascript.changeSignature.no.call.value=新的必選參數 ''{0}'' 已新增。\\n\\
指定要用於此方法的所有現有呼叫的預設值。
javascript.check.global.definitions=檢查全域作用域內的賦值
javascript.class=類別
javascript.comma=逗號
javascript.completion.several.definitions=(多個定義)
javascript.constructor.call.without.new.message=不帶 <code>new</code> 的建構函式呼叫
javascript.constructor.with.lower.case.name.used.message=建構函式名稱通常以大寫字母開頭。拼寫錯誤?
javascript.create.class.intention.name=建立類別 ''{0}''
javascript.create.constant.field.intention.name=建立常數欄位 ''{0}''
javascript.create.constant.holding.arrow.function.intention.name=建立含有常數 ''{0}'' 的箭頭函式
javascript.create.constant.intention.name=建立常數 ''{0}''
javascript.create.constructor.intention.name=在 ''{0}'' 類別中建立建構函式
javascript.create.event.handler.intention.name=建立事件處理程序 ''{0}''
javascript.create.field.holding.arrow.function.intention.name=建立含有欄位 ''{0}'' 的箭頭函式
javascript.create.field.intention.name=建立欄位 ''{0}''
javascript.create.function.intention.family=建立 JavaScript 函式或方法
javascript.create.function.intention.name=建立函式 ''{0}''
javascript.create.function.property.intention.name=建立函式屬性 ''{0}''
javascript.create.get.property.intention.name=建立 ''get'' 屬性 ''{0}''
javascript.create.interface.intention.name=建立接口 ''{0}''
javascript.create.method.intention.name=建立方法 ''{0}''
javascript.create.property.holding.arrow.function.intention.name=建立含有屬性 ''{0}'' 的箭頭函式
javascript.create.property.intention.name=建立屬性 ''{0}''
javascript.create.set.property.intention.name=建立 ''set'' 屬性 ''{0}''
javascript.create.variable.holding.arrow.function.intention.name=建立含有變數 ''{0}'' 的箭頭函式
javascript.create.variable.intention.family=建立 JavaScript 變數或屬性
javascript.create.variable.intention.name=建立變數 ''{0}''
javascript.declare.variable.in.previous.var.statement.intention.family=將 var 宣告插入之前的 var 語句
javascript.declare.variable.in.previous.var.statement.intention.name=將 ''{0}'' 的 var 宣告插入之前的 var 語句
javascript.declare.variable.intention.family.name=插入 var 宣告
javascript.declare.variable.intention.name=為 ''{1}'' 插入 {0} 宣告
javascript.deprecated.symbol.replace.fix=將棄用的程式碼取代為 {0}
javascript.deprecated.symbol.replace.fix.family=將棄用的程式碼取代為建議的取代
javascript.deprecated.symbol.used.name.message=使用了棄用的符號，請查閱文檔，以獲取更好的替代性 #loc
javascript.deprecated.symbol.used.name.message2=自版本 {0} 符號被標記為棄用以來，使用 {1} 作為取代用 #loc
javascript.destructuring.initializer=初始設定式 {0}
javascript.destructuring.variable.only=僅解構變數
javascript.doccomment=文檔註釋
javascript.doctag=文檔標籤
javascript.doctagvalue=文檔標記值
javascript.dot=點
javascript.element.default.instead.named=使用了預設匯入而不是命名匯入
javascript.element.is.not.accessible.message=元素不可存取 #loc
javascript.element.need.to.be.exported=未匯出元素
javascript.element.need.to.be.imported=未匯入元素
javascript.element.need.to.be.included.to.config=tsconfig.json 中不包含相應檔案
javascript.equality.comparison.with.coercion.display.name=相等運算符可能導致類型強制
javascript.equality.comparison.with.coercion.error.string=比較 #ref 可能導致意外類型強制 #loc
javascript.equality.comparison.with.coercion.family.name=取代但不進行類型強制
javascript.equality.comparison.with.coercion.fix=取代為 ''{0}''
javascript.equality.comparison.with.coercion.option.always=所有
javascript.equality.comparison.with.coercion.option.always.except.null=與 null 或 typeof 比較時除外
javascript.equality.comparison.with.coercion.option.only.suspicious=僅可疑表達式
javascript.equality.comparison.with.coercion.options.label=醒目提示顯示 '==' 和 '!=' 的用法:
javascript.expected.class.or.descendant=應為類別 {0} 或後代
javascript.export.only.member=元素僅匯出
javascript.exported.class=匯出的類別
javascript.exported.function=匯出的函式
javascript.exported.variable=匯出的變數
javascript.expression.type.implicitly.coerced.to.unrelated.type=表達式類型 {1} 隱式強制為不相關類型 {0}
javascript.extract.method.title=提取函式
javascript.falsy.typeof.guard=''typeof'' 檢查始終為 false: {0}'' 始終具有類型 ''{1}''
javascript.file=JavaScript 檔案
javascript.find.usages.destructuring.target.dialog=速記解構變數使用 {0} 初始化。\\n\\
您想尋找哪些用法?
javascript.fix.add.enum.values=新增枚舉值
javascript.fix.add.override.modifier=新增覆寫修飾符
javascript.fix.add.string.enum.values=新增字串枚舉值
javascript.fix.change.parameter.type=參數 ''{0}'' 類型更改為 ''{1}''
javascript.fix.change.type=''{0}'' 類型更改為 ''{1}''
javascript.fix.create.class.component.jsx.family=建立類別組件
javascript.fix.create.class.component.jsx.name=建立類別組件 ''{0}''
javascript.fix.create.constructor.invoke.super=建立符合 super 的建構函式
javascript.fix.create.extends=使 ''{0}'' 擴展 ''{1}''
javascript.fix.create.function.component.jsx.family=建立函式組件
javascript.fix.create.function.component.jsx.name=建立函式組件 ''{0}''
javascript.fix.create.implements=使 ''{0}'' 實作 ''{1}''
javascript.fix.create.inheritor.family=從 super 類型繼承
javascript.fix.create.invoke.super=插入超類別建構函式呼叫
javascript.fix.create.parameter=建立參數 ''{0}''
javascript.fix.generate.argument.stubs=生成實參存根
javascript.fix.implement=實作 {0}
javascript.fix.implement.chooser.all=所有類別
javascript.fix.implement.chooser.title=從中實作成員
javascript.fix.implement.family=在派生類別中實作
javascript.fix.implement.members=實作成員
javascript.fix.implement.methods=實作方法
javascript.fix.initialize.parameter=初始化參數
javascript.fix.message.change.parameters.to.expected=將這些參數更改為預期參數
javascript.fix.message.change.return.type.to.expected=將返回值類型更改為預期類型
javascript.fix.optimize.imports=最佳化 import
javascript.fix.property.spelling.family=修復屬性名稱中可能的拼寫錯誤
javascript.fix.property.spelling.text=將拼寫調整為 ''{0}''
javascript.fix.remove.abstract.keyword=移除 'abstract' 修飾符
javascript.fix.remove.access.modifier=移除存取修飾符
javascript.fix.remove.circular.dependency=移除迴圈相依關係
javascript.fix.remove.comma=移除逗號
javascript.fix.remove.constructor=移除建構函式
javascript.fix.remove.default=移除預設子句
javascript.fix.remove.dynamic.modifier=移除動態修飾符
javascript.fix.remove.externally.visible.symbol=移除外部可見符號
javascript.fix.remove.final.modifier=移除 final 修飾符
javascript.fix.remove.initializer=移除初始設定式
javascript.fix.remove.modifier=移除修飾符
javascript.fix.remove.namespace.reference=移除命名空間參照
javascript.fix.remove.override.modifier=移除覆寫修飾符
javascript.fix.remove.parameter=移除參數
javascript.fix.remove.parameters=移除參數
javascript.fix.remove.setter.parameter.initializer=移除參數預設值
javascript.fix.remove.static.modifier=移除 static 修飾符
javascript.fix.remove.type.reference=移除類型參照
javascript.fix.remove.virtual.modifier=移除虛擬修飾符
javascript.fix.remove.visibility.modifier=移除可見性修飾符
javascript.fix.set.element.visibility=將 {0} 設為 {1}
javascript.fix.set.method.return.type=使 ''{0}'' 返回 ''{1}''
javascript.fix.visibility.family=修復可見性問題
javascript.formatting.options.panel.comments=註釋
javascript.formatting.options.panel.naming.conventions=命名約定
javascript.function.arrow=箭頭函式
javascript.global.decorator=裝飾器
javascript.global.function=全域函式
javascript.global.variable=全域變數
javascript.ignore.unused.catch.parameters=忽略未使用的 catch 參數
javascript.ignore.unused.function.parameters=忽略未使用的參數:
javascript.illegal.variable.type.void=非法變數類型: 'void'
javascript.implement.all.interfaces=實作所有成員
javascript.implement.members.abstract=實作 abstract 成員
javascript.implement.required.interfaces=實作所需的所有成員
javascript.import.options.use.resource.root=使用相對於專案、資源或來源根目錄的路徑
javascript.incorrect.array.type.in.for-in=陣列鍵類型應為字串
javascript.incorrect.variable.type.mismatch=變數類型 {1} 不可分配給類型 {0}
javascript.indexed.property.instead.of.computed.name=索引屬性存取中括號位於單獨的行中。是否應為計算的名稱?
javascript.initializer.type.mismatch=初始設定式類型 {1} 不可分配給變數類型 {0}
javascript.inline.element.is.not.used={0} 從未使用
javascript.insert.cast.fix=插入轉換
javascript.insert.generic.wrapper.fix.family.name=使用泛型類型包裝
javascript.insert.primitive.wrapper.fix.family.name=使用基元類型包裝
javascript.insert.symbol.fix=插入{0}
javascript.insert.wrapper.fix.text=使用 ''{0}'' 包裝
javascript.instance.member.function=實例成員函式
javascript.instance.member.is.not.accessible.message=實例成員不可存取 #loc
javascript.instance.member.variable=實例成員變數
javascript.intention.add.default.export.family.name=新增預設匯出
javascript.intention.add.export.family.name=新增匯出
javascript.intention.add.export.fix.text=將 {0} 匯出在檔案 {1} 中
javascript.intention.add.template.argument=插入模板字串實參
javascript.intention.call.chain.to.pipe=將嵌套呼叫取代為管道表達式
javascript.intention.code.optimizations.text=正在最佳化生成的程式碼
javascript.intention.create.getter=為 ''{0}'' 建立 getter
javascript.intention.create.getter.desc=建立 getter
javascript.intention.create.getter.setter=為 ''{0}'' 建立 getter 和 setter
javascript.intention.create.getter.setter.desc=建立 getter 和 setter
javascript.intention.create.setter=為 ''{0}'' 建立 setter
javascript.intention.create.setter.desc=建立 setter
javascript.intention.expand.nullish.coalescing=展開 null 合併
javascript.intention.expand.opt.chain=展開可選鏈接
javascript.intention.expand.opt.chain.and.nullish.coalescing=展開可選鏈接和 null 合併
javascript.intention.expand.opt.chain.and.or.coalescing=展開可選鏈接並使用 ?: 運算符
javascript.intention.expand.opt.chain.family=將可選鏈接或 null 合併擴展到顯式檢查
javascript.intention.expand.or.coalescing=使用 ?: 運算符
javascript.intention.explicit.fields=宣告顯式類別欄位
javascript.intention.explicit.fields.dialog.title=選擇要顯式宣告的欄位
javascript.intention.explicit.fields.single=宣告顯式類別欄位
javascript.intention.init.fields=從參數初始化新字段
javascript.intention.init.fields.dialog.title=選擇參數以初始化欄位
javascript.intention.opt.chain.chain.and.coalesce=使用可選鏈接和 null 合併
javascript.intention.opt.chain.chain.only=使用可選鏈接
javascript.intention.opt.chain.coalesce.only=使用 null 合併
javascript.intention.opt.chain.conditional.only=使用 '||'
javascript.intention.opt.chain.family=使用可選鏈接或 null 合併
javascript.intention.pipe.to.call.chain=將管道表達式取代為嵌套呼叫
javascript.intention.promise.to.async.name=轉換為異步功能
javascript.intention.remove.export.family.name=移除匯出
javascript.intention.remove.export.inaccessible.conflict.text={0} 在 {1} 中進行了使用
javascript.interface=接口
javascript.interface.can.not.be.instantiated.message=無法實例化接口
javascript.introduce.breaks.operator.precedence=無法呼叫重構。\\n\\
通過引入將更改表達式中的運算符優先級。
javascript.introduce.constant.error.expression.has.void.type=無法引入常數。\\n\\
選定的表達式類型無效。
javascript.introduce.constant.error.no.expression.selected=無法引入常數。\\n\\
選定內容不構成表達式。
javascript.introduce.constant.error.not.constant.expression.selected=無法引入常數。\\n\\
選定內容不是常數表達式。
javascript.introduce.constant.in.es5=無法呼叫重構。\\n\\
無法在 ECMAScript 3 或 ECMAScript 5 程式碼中引入常數。
javascript.introduce.constant.title=引入常數
javascript.introduce.element.already.exists=作用域中已存在同名的 {0}。
javascript.introduce.field.before.super.call=無法引入欄位。\\n\\
在"super"呼叫前無法存取"this"。
javascript.introduce.field.constructor=建構函式
javascript.introduce.field.current.method=當前方法
javascript.introduce.field.error.expression.has.void.type=無法引入變數。\\n\\
選定的表達式類型無效。
javascript.introduce.field.error.no.enclosing.class=無法引入欄位。\\n\\
沒有封閉類別。
javascript.introduce.field.error.no.expression.selected=無法引入欄位。\\n\\
選定內容不構成表達式。
javascript.introduce.field.field.declaration=欄位宣告
javascript.introduce.field.initialize.in.scope=初始化位置(&I):
javascript.introduce.field.keyboard.hint=按 {0} 用於鍵盤快捷鍵
javascript.introduce.field.make.readonly=設為唯讀(&R)
javascript.introduce.field.title=引入欄位
javascript.introduce.field.visibility=可見性(&V):
javascript.introduce.in.embedded.expression=無法呼叫重構。\\n\\
無法在嵌入式表達式中引入
javascript.introduce.incorrect.context=無法引入變數。\\n\\
選定內容包含對"this"的參照
javascript.introduce.parameter.error.expression.has.void.type=無法引入參數。\\n\\
選定的表達式類型無效。
javascript.introduce.parameter.error.no.containing.function=無法引入參數。\\n\\
找不到要使用的包含函式。
javascript.introduce.parameter.error.no.expression.selected=無法引入參數。\\n\\
選定內容不構成表達式。
javascript.introduce.parameter.error.not.async.context=無法為包含 'await' 的表達式引入參數。\\n\\
並非所有用法都包含在異步函式中
javascript.introduce.parameter.error.target.not.async=無法為包含 'await' 的表達式引入參數。\\n\\
目標函式不是異步函式
javascript.introduce.parameter.error.yield=無法為包含 'yield 的表達式引入參數。
javascript.introduce.parameter.generate.jsdoc=生成 JSDoc
javascript.introduce.parameter.introduced.variable.value=值(&V):
javascript.introduce.parameter.optional.parameter=可選參數
javascript.introduce.parameter.title=提取參數
javascript.introduce.throw.expressions.unsupported=無法呼叫重構。\\n\\
“提取”重構中當前不支持 throw 表達式。
javascript.introduce.variable.arrow.await.referenced=無法引入。\\n\\
選定內容包含 await 表達式
javascript.introduce.variable.arrow.function.parameter.referenced=無法引入。\\n\\
選定內容包含對箭頭函式參數的參照
javascript.introduce.variable.error.expression.has.void.type=無法引入變數。\\n\\
選定的表達式類型無效。
javascript.introduce.variable.error.no.expression.selected=無法引入變數。\\n\\
選定內容不構成表達式。
javascript.introduce.variable.invalid.name=請輸入有效名稱。
javascript.introduce.variable.make.constant=設為常數
javascript.introduce.variable.name.prompt=名稱(&N):
javascript.introduce.variable.replace.all.occurrences=取代所有符合項(找到 {0} 個匹配項)(&A)
javascript.introduce.variable.title=提取變數
javascript.introduce.variable.title.local=引入區域變數
javascript.introduce.variable.xml.embedded=無法在嵌入式表達式中引入變數
javascript.invalid.delete.target.message=刪除運算符目標無效，應為欄位參照
javascript.invalid.extended.unicode.escape=擴展的 Unicode 轉義僅允許介於 0x0 和 0x10FFFF 之間的值
javascript.invalid.invoker.target=無效呼叫目標
javascript.invalid.number.of.parameters=實參數量無效，應為 {0} 個
javascript.invalid.string.escape=無效字串轉義
javascript.jsdoc.private.member.is.not.accessible.message=private 成員不可存取 #loc
javascript.jsdoc.protected.member.is.not.accessible.message=protected 成員不可存取 #loc
javascript.keyword=關鍵字
javascript.kind.unknown=未知元素
javascript.known.props.only=物件文字只能指定已知屬性，但以下為額外屬性: {0}
javascript.label=標籤
javascript.label.visibility.package_local=internal(&I)
javascript.label.visibility.private=private(&V)
javascript.label.visibility.protected=protected(&O)
javascript.label.visibility.public=公共 (&B)
javascript.language.service.cannot.get.results=無法從語言服務獲得結果
javascript.language.service.cannot.start=無法啟動語言服務程序
javascript.language.service.default.empty.text=無錯誤
javascript.language.service.default.project.errors=顯示專案錯誤
javascript.language.service.start.timeout=啟動語言服務程序超時
javascript.language.service.tracking.disabled=錯誤追蹤已停用
javascript.language.service.tracking.is.not.started=服務未啟動
javascript.language.simple.name=JavaScript
javascript.language.term.attribute=特性
javascript.language.term.attribute.value=特性值
javascript.language.term.class=類別
javascript.language.term.const=常數
javascript.language.term.const.field=常數欄位
javascript.language.term.constructor=建構函式
javascript.language.term.decorator=裝飾器
javascript.language.term.default.export=預設匯出
javascript.language.term.definition=定義
javascript.language.term.destructuring.property=解構屬性
javascript.language.term.entity.name=實體名稱
javascript.language.term.enum=枚舉
javascript.language.term.export.specifier=匯出說明符
javascript.language.term.exported.default.binding=已匯出預設綁定
javascript.language.term.external.module.reference=外部模組參照
javascript.language.term.field=欄位
javascript.language.term.file=檔案
javascript.language.term.function=函式
javascript.language.term.global=全域
javascript.language.term.import.specifier=匯入說明符
javascript.language.term.import.statement=import 語句
javascript.language.term.imported.default.binding=已匯入預設綁定
javascript.language.term.inner.class=內部類別
javascript.language.term.inner.function=內部函式
javascript.language.term.inner.interface=內部接口
javascript.language.term.interface=接口
javascript.language.term.jsdoc.tag=JSDoc 標記
javascript.language.term.label=標籤
javascript.language.term.local.const=區域常數
javascript.language.term.local.variable=區域變數
javascript.language.term.method=方法
javascript.language.term.module=模組
javascript.language.term.namespace=命名空間
javascript.language.term.namespace.export=命名空間匯出
javascript.language.term.namespace.import=命名空間匯入
javascript.language.term.package=軟體套件
javascript.language.term.parameter=參數
javascript.language.term.property=屬性
javascript.language.term.readonly.field=唯讀欄位
javascript.language.term.tag=標記
javascript.language.term.type.alias=類型別名
javascript.language.term.type.parameter=類型參數
javascript.language.term.variable=變數
javascript.language.term.xml.tag=xml 標籤
javascript.library.built.in=內建
javascript.linecomment=行註釋
javascript.linter.action.edit.config=編輯 {0}
javascript.linter.action.edit.property=編輯 {1} 中的 {0}
javascript.linter.action.edit.settings.text={0}設定…
javascript.linter.action.fix.problems.file.text={0}: 修復當前檔案
javascript.linter.action.fix.problems.name=修復 {0} 問題
javascript.linter.action.fix.problems.name.finish=已結束修復 {0} 問題
javascript.linter.action.fix.problems.name.start=已開始修復 {0} 問題
javascript.linter.action.fix.prompt=使用 {0} 重新格式化選定的檔案?
javascript.linter.configurable.config.autoSearch.title=自動搜尋 (&S)
javascript.linter.configuration.file.title=組態檔案
javascript.linter.error.can.not.find.document=找不到 {0} 的文檔
javascript.linter.error.can.not.find.psi.file=找不到 {0} 的 PSI 檔案
javascript.linter.error.empty.path=路徑為空
javascript.linter.error.failed.to.lint=Lint {0} 失敗
javascript.linter.error.invalid.path.to.package=指定 ''{0}'' 軟體套件的正確路徑
javascript.linter.error.no.path.to.package=指定 ''{0}'' 軟體套件的路徑
javascript.linter.error.no.such.file=沒有此類別檔案
javascript.linter.error.notification.problem.with.reformatting=重新設定 {0} 的格式時出現問題:<br/>{1}
javascript.linter.error.package.not.installed=安裝 ''{0}'' 軟體套件
javascript.linter.error.specify.correct.path.to=指定 {0} 的正確路徑
javascript.linter.import.error.bin.file.not.found=無法 ''{1}'' 軟體套件下找到 ''{0}''
javascript.linter.import.error.entry.point.not.found=無法在 ''{0}'' 軟體套件中找到入口點
javascript.linter.import.error.generic=套用組態檔案中的程式碼樣式規則時出錯，可能是組態檔案無效。
javascript.linter.import.error.package.not.found=找不到 ''{0}'' 軟體套件
javascript.linter.import.error.timeout.processing.configuration.file=處理組態檔案時超時
javascript.linter.import.nothing.to.import={0}: 已套用所有已知規則
javascript.linter.import.notification={0}: 專案程式碼樣式和編輯器設定基於 ''{1}'' 更新。
javascript.linter.import.notification.edit=編輯 ''{0}''
javascript.linter.import.notification.reset=重設
javascript.linter.import.notification.restored=預設程式碼樣式和編輯器設定已還原
javascript.linter.import.notification.rules.applied=套用了以下 {0}: {1}。
javascript.linter.import.translate.config.description=套用 ESLint 程式碼樣式規則
javascript.linter.import.translate.config.file.error=無法套用程式碼樣式規則
javascript.linter.import.translate.config.progress.title=套用 {0} 程式碼樣式規則
javascript.linter.import.translate.config.title=套用 ESLint 程式碼樣式規則
javascript.linter.intention.family.name.show.details={0}: 顯示詳細資訊
javascript.linter.intention.name.details=詳細資訊
javascript.linter.progress.reformatting.with=正在使用 {0} 重新格式化…
javascript.linter.radio.button.configuration.file=組態檔案(&C):
javascript.linter.suppress.all.rules.for.file.description=禁止當前檔案的所有 {0} 規則
javascript.linter.suppress.all.rules.for.line.description=禁止當前行的所有 {0} 規則
javascript.linter.suppress.rule.for.file.description=禁止當前檔案的 ''{0}''
javascript.linter.suppress.rule.for.line.description=禁止當前行的 ''{0}''
javascript.linter.suppress.rules.for.file.family.name=對當前檔案禁止
javascript.linter.suppress.rules.for.line.family.name=對當前行禁止
javascript.linter.use.severity.from.config.label=使用組態檔案中的規則嚴重性
javascript.local.function=區域函式
javascript.local.variable=區域變數
javascript.member.from.unopened.namespace.message=未開啟命名空間的成員 #loc
javascript.metadata=元資料
javascript.missed.argument.for.parameter=參數 {0} 缺少實參
javascript.missing.read.property=未解析的讀取屬性 #loc
javascript.missing.write.property=未解析的寫入屬性 #loc
javascript.module.dependencies.empty.got.it.text=<div align='left'>當前檔案或目錄沒有任何相依關係。<br/>請嘗試使用其他檔案或目錄。</div>
javascript.module.dependencies.got.it.text=<div align='left'>此圖顯示所選檔案或目錄具有的模組相依關係。<br/>要檢視多個檔案或目錄的相依關係，請在<i>專案檢視</i><br/>中將其選定，然後從所選專案右鍵選單中選擇<i>圖 – 顯示圖</i>。</div>
javascript.module.dependencies.got.it.title=模組相依關係圖
javascript.module.name=模組名稱
javascript.mutable.variable.accessible.from.closure=可從閉包存取可變變數
javascript.no.call.signatures=分配的類型不包含呼叫簽名
javascript.not.a.constructor.call.message=不是建構函式呼叫
javascript.number=數字
javascript.object.is.null={0} 為 null
javascript.object.is.null.or.undefined={0} 為 null 或 undefined
javascript.object.is.possibly.null={0} 可能為 null
javascript.object.is.possibly.null.or.undefined={0} 可能為 null 或 undefined
javascript.object.is.possibly.undefined={0} 可能為 undefined
javascript.object.is.undefined={0} 未定義
javascript.object.null.or.undefined.desc=物件為 'null' 或 'undefined'
javascript.octal.literals.are.not.allowed.es5.message=前綴為 '0' 的八進制文字已過時，不建議使用
javascript.octal.literals.are.not.allowed.es6.message=不允許使用前綴為 '0' 的八進制文字。改用 '0o' 前綴
javascript.octal.literals.are.not.allowed.in.strict.mode=在嚴格模式下不允許八進制文字
javascript.octal.literals.warn.always=關於 ES5-程式碼中過時八進制文字的警告
javascript.octal.sequences.are.not.allowed.message=不允許八進制轉義序列
javascript.operation=運算
javascript.parameter=參數
javascript.parens=括號
javascript.parser.message.are.not.supported.by.dialect=當前 JavaScript 版本不支持 {0}
javascript.parser.message.expected.as=應為 'as'
javascript.parser.message.expected.at=應為 @
javascript.parser.message.expected.case.or.default=應為 'case' 或 'default'
javascript.parser.message.expected.checks=應為 'checks'
javascript.parser.message.expected.class=應為 'class'
javascript.parser.message.expected.colon=應為 :
javascript.parser.message.expected.colon.or.comma=應為 : 或 ,
javascript.parser.message.expected.comma=應為 ,
javascript.parser.message.expected.comma.or.rbrace=應為 , 或 }
javascript.parser.message.expected.comma.or.rparen=應為 , 或 )
javascript.parser.message.expected.declaration=應為宣告
javascript.parser.message.expected.declare=應為 'declare'
javascript.parser.message.expected.dot=應為 .
javascript.parser.message.expected.eqgt=應為 =>
javascript.parser.message.expected.equal=應為 =
javascript.parser.message.expected.exports=應為 'exports'
javascript.parser.message.expected.expression=應為表達式
javascript.parser.message.expected.forloop.in.or.semicolon=應為 'in' 或 ;
javascript.parser.message.expected.forloop.left.hand.side.expression.or.variable.declaration='in' 前面應為左側表達式或變數宣告
javascript.parser.message.expected.forloop.using.not.allowed.in.for-in='for-in' 迴圈中不允許使用 'using'
javascript.parser.message.expected.formal.parameter.name=應為參數名稱
javascript.parser.message.expected.from=應為 'from'
javascript.parser.message.expected.function.name=應為函式名稱
javascript.parser.message.expected.gt=應為 >
javascript.parser.message.expected.heredoc.closing.identifier=應為 heredoc 結束關鍵字
javascript.parser.message.expected.identifier=應為關鍵字
javascript.parser.message.expected.identifier.lbrace.or.lbracket=應為關鍵字、{ 或 [
javascript.parser.message.expected.identifier.or.value=應為關鍵字或值
javascript.parser.message.expected.identifier.string.literal.or.lbrace=應為關鍵字、字串文字或 {
javascript.parser.message.expected.identifier.string.literal.or.numeric.literal=應為關鍵字、字串文字或數字文字
javascript.parser.message.expected.identifier.string.literal.or.rbrace=應為關鍵字、字串文字或 }
javascript.parser.message.expected.import.specifier=應為匯入說明符
javascript.parser.message.expected.import.value=應為匯入綁定或說明符
javascript.parser.message.expected.in=應為 'in'
javascript.parser.message.expected.instanceof=應為 'instanceof'
javascript.parser.message.expected.lbrace=應為 {
javascript.parser.message.expected.lbrace.or.semicolon=應為 { 或 ;
javascript.parser.message.expected.lbracket=應為 [
javascript.parser.message.expected.lparen=應為 (
javascript.parser.message.expected.meta=僅接受 'meta' 作為要匯入的元屬性
javascript.parser.message.expected.mult.or.lbrace=應為 * 或 {
javascript.parser.message.expected.name=應為名稱
javascript.parser.message.expected.name.or.lbrace=應為軟體套件名稱或 {
javascript.parser.message.expected.namespace=應為 'namespace'
javascript.parser.message.expected.newline.or.semicolon=需要換行符或分號
javascript.parser.message.expected.parameter.name=應為參數名稱
javascript.parser.message.expected.property.name=應為屬性名稱
javascript.parser.message.expected.question=應為 ?
javascript.parser.message.expected.rbrace=應為 }
javascript.parser.message.expected.rbracket=應為 ]
javascript.parser.message.expected.readonly=應為 'readonly'
javascript.parser.message.expected.rparen=應為 )
javascript.parser.message.expected.semicolon=應為 ;
javascript.parser.message.expected.statement=應為語句
javascript.parser.message.expected.string.literal=應為字串文字
javascript.parser.message.expected.target=僅接受 'target' 作為要新增的元屬性
javascript.parser.message.expected.tuple.comma.or.rbracket=應為 , 或 ]
javascript.parser.message.expected.type=應為類型
javascript.parser.message.expected.type.keyword=應為 'type'
javascript.parser.message.expected.type.member=應為類型成員
javascript.parser.message.expected.type.name=應為類型名稱
javascript.parser.message.expected.typename=應為類型名稱
javascript.parser.message.expected.typename.or.*=* 應為 * 或類型名稱
javascript.parser.message.expected.value=應為值
javascript.parser.message.expected.variable.name=應為變數名稱
javascript.parser.message.expected.while.keyword=應為 'while'
javascript.parser.message.expected.xml=應為 XML 上下文關鍵字
javascript.parser.message.expected.xml.element=應為 XML 元素
javascript.parser.message.missing.attribute.name=缺少特性名稱
javascript.parser.message.missing.back.quote=缺少 \`
javascript.parser.message.missing.or_rbrace=缺少 |}
javascript.parser.message.missing.rbrace=缺少 }
javascript.parser.message.missing.rbracket=缺少 ]
javascript.parser.message.missing.rparen=缺少 )
javascript.parser.message.missing.tag.name=缺少標記名稱
javascript.parser.message.unclosed.comment=未閉合註釋
javascript.parser.message.unclosed.string.literal=未閉合的字串文字
javascript.parser.message.unexpected.end.of.file=意外的檔案結尾
javascript.parser.message.unexpected.token=意外的標記 {0}
javascript.parser.property.expected=應為屬性
javascript.potentially.invalid.target.of.indexed.property.access=索引的屬性存取的目標可能無效
javascript.potentially.invalid.usage.of.class.this=通過嵌套函式的 'this.' 對類別欄位的參照存取可能無效
javascript.potentially.invalid.usage.of.this=This 的用法可能無效
javascript.private.constructor.is.not.accessible.message=private 建構函式不可存取 #loc
javascript.private.member.is.not.accessible.message=private 成員不可存取 #loc
javascript.property.is.read.only.message=唯讀屬性 #loc
javascript.property.is.write.only.message=只寫屬性 #loc
javascript.protected.constructor.is.not.accessible.message=protected 建構函式不可存取 #loc
javascript.protected.member.is.not.accessible.message=protected 成員不可存取 #loc
javascript.qualified.class.name.expected=應為限定的類別名
javascript.qualified.name.is.not.imported.message=未匯入限定名稱 #loc
javascript.redundant.typeof.guard=''typeof'' 檢查冗餘: ''{0}'' 始終具有類型 ''{1}''
javascript.refactoring.asdoc.for.abstracts=abstract 的 ASDoc
javascript.refactoring.cannot.find.usages.of.definition.to.inline=找不到要內聯的定義的用法
javascript.refactoring.cannot.inline.ambient.function=無法內聯沒有實作的宣告
javascript.refactoring.cannot.inline.complex.expression.evaluation=無法內聯複雜表達式求值
javascript.refactoring.cannot.inline.constructor=無法內聯建構函式
javascript.refactoring.cannot.inline.destructuring.rest.variable=無法內聯解構 rest 變數
javascript.refactoring.cannot.inline.destructuring.variable.with.default=無法內聯使用預設值的解構變數
javascript.refactoring.cannot.inline.function.defined.in.library=無法內聯外部庫中定義的函式
javascript.refactoring.cannot.inline.function.referencing.arguments=無法內聯參照實參的函式
javascript.refactoring.cannot.inline.function.referencing.rest.parameter=無法內聯函式參照的 rest 參數
javascript.refactoring.cannot.inline.function.with.multiple.returns=無法內聯有多個退出點的函式
javascript.refactoring.cannot.inline.interface.method=無法內聯接口方法
javascript.refactoring.cannot.inline.jsx.usage=無法內聯 JSX 標籤用法
javascript.refactoring.cannot.inline.not.initialized.variable=無法內聯未初始化的變數
javascript.refactoring.cannot.inline.overrided.or.overridden.method=無法內聯參與層次結構的方法
javascript.refactoring.cannot.inline.recursive.function=無法內聯遞迴函式
javascript.refactoring.extract.function.already.exists.in.this.scope=此作用域中已存在 {0}
javascript.refactoring.extract.function.bad.selection=所選塊應代表一組語句或表達式
javascript.refactoring.extract.function.function.used.before.declaring=選定內容包含在宣告之前使用的函式
javascript.refactoring.extract.function.multiple.exit.points=所選程式碼段有多個退出點
javascript.refactoring.extract.function.no.loop.for.break=程式碼段內沒有用於 break 語句的相應迴圈
javascript.refactoring.extract.function.no.loop.for.continue=程式碼段內沒有用於 continue 語句的相應迴圈
javascript.refactoring.extract.function.no.switch.for.break=程式碼段內沒有用於 break 語句的相應 'switch'
javascript.refactoring.extract.function.title=提取函式
javascript.refactoring.extract.function.yield.and.return=所選片段同時包含 yield 表達式和 return 語句
javascript.refactoring.function.to.es6.class.command=將函式 {0} 轉換為類別
javascript.refactoring.function.to.es6.class.defineProperty.warning.text=警告: 將使用“Object.defineProperty”、“Object.defineProperties”或“Object.create”建立的屬性轉換為 ES6 語法可能會影響其可枚舉性和可組態性
javascript.refactoring.inline.all.message=內聯所有參照並移除 {0} ({1}) (&A)
javascript.refactoring.inline.dialog.title=內聯{0}
javascript.refactoring.inline.function.title=內聯函式
javascript.refactoring.inline.this.only=僅內聯此參照並保留 {0}(&K)
javascript.refactoring.inline.variable.title=內聯變數
javascript.refactoring.searching.usages=尋找用法
javascript.refactoring.variable.used.as.lvalue=要內聯的變數在賦值的左側使用
javascript.refactoring.variable.value.is.changed.when.accessed.from.closure=從閉包存取時變量值被更改
javascript.regexp=正則表達式
javascript.rename.choose.target.message=您要重新命名哪一個?
javascript.rename.containing.file.message=是否還要將該檔案重命名為 {0}?\\n\\
{1} 的用法和 import 語句中的檔案路徑將進行相應更新。
javascript.rename.destructuring.target.dialog.title=速記解構變數使用 {0} 初始化
javascript.rename.element.with.related.elements.title=重新命名 {0}
javascript.rename.reference.intention.name=重新命名參照
javascript.rename.related.declaration.message=是否還要重新命名 {0}?\\n\\
import 語句中的 {0} 用法將進行相應更新。
javascript.rename.shorthand.property.description=屬性
javascript.rename.shorthand.target.dialog.title=速記屬性使用 {0} 初始化
javascript.rename.symbol.intention.name=重新命名符號
javascript.report.unused.definitions=報告未使用的定義
javascript.report.unused.properties=報告未使用的屬性
javascript.returned.expression.type.mismatch=返回的表達式類型 {1} 不可分配給類型 {0}
javascript.semicolon=分號
javascript.service.node.error=Node 解釋器路徑不正確。請檢查解釋器設定
javascript.starting.service=啟動 {0} 服務
javascript.static.member.function=static 成員函式
javascript.static.member.is.not.accessible.message=static 成員不可存取 #loc
javascript.static.member.variable=static 成員變數
javascript.strictly.check.global.vars=將未宣告的全域符號報告為錯誤
javascript.strictly.check.object.properties=將未宣告的屬性報告為錯誤
javascript.string=字串
javascript.surround.with.cast=Type(expr)
javascript.surround.with.do.while=do / while
javascript.surround.with.for=for
javascript.surround.with.function=函式
javascript.surround.with.function.expression=函式表達式
javascript.surround.with.if=if
javascript.surround.with.if.cond=if (cond)
javascript.surround.with.if.else=if / else
javascript.surround.with.if.else.cond=if (cond) / else
javascript.surround.with.not.parenthesis=!(expr)
javascript.surround.with.object.literal=物件文字
javascript.surround.with.parenthesis=(expr)
javascript.surround.with.try.catch=try / catch
javascript.surround.with.try.catch.finally=try / catch / finally
javascript.surround.with.try.finally=try / finally
javascript.surround.with.while=while
javascript.surround.with.with=with
javascript.suspicious.type.guard.desc=類型防護檢查不健全
javascript.suspicious.typeof.guard=''typeof'' 檢查無效: ''{0}'' 不能具有類型 ''{1}''
javascript.template.context.type=JavaSc&ript 和 TypeScript
javascript.term.does.not.evaluate.to.function=方法表達式不是函式類型
javascript.term.does.not.evaluate.to.function.line.break=表達式不可呼叫。如果這不應是呼叫，請檢查是否缺少分號
javascript.term.does.not.evaluate.to.function.nullable=方法表達式可以為 null 或 undefined
javascript.term.does.not.evaluate.to.function2=屬性不能作為函式呼叫
javascript.term.does.not.evaluate.to.function2.fix=移除實參列表
javascript.term.nullable.indexer.qualifier=索引的表達式可以為 null 或 undefined
javascript.type.is.not.assignable.to.type=類型 {1} 不可分配給類型 {0}
javascript.undeclared.variable.name.message=隱式宣告變數 {0} #loc
javascript.unfiltered.for.in.loop=可能迭代意外(自訂/繼承)成員，可能缺少 hasOwnProperty 檢查
javascript.unknown.metadata.attribute=未知元資料特性
javascript.unknown.metadata.tag=未知元資料標籤
javascript.unresolved.circle.definition=匯入的圓定義
javascript.unresolved.file.or.dir=無法解析 {0} <code>''{1}''</code>
javascript.unresolved.function.name.message=未解析的函式或方法 <code>{0}()</code> #loc
javascript.unresolved.symbol.message=未解析的符號
javascript.unresolved.type.name.message=未解析的類型 {0} #loc
javascript.unresolved.variable.name.message=未解析的變數 {0} #loc
javascript.unresolved.variable.null.or.undefined.qualifier.message=''{0}'' 的限定符可能為 null 或 undefined #loc
javascript.unresolved.variable.null.qualifier.message=''{0}'' 的限定符可能為 null #loc
javascript.unresolved.variable.or.type.name.message=未解析的變數或類型 {0} #loc
javascript.unresolved.variable.or.type.name.message2=未解析的變數或類型 {0}
javascript.unresolved.variable.undefined.qualifier.message=''{0}'' 的限定符可能未定義 #loc
javascript.unused.import.remove=移除未使用的 'import'
javascript.unused.import.remove.specifier=移除未使用的元素
javascript.valid.string.escape=有效字串轉義
javascript.validate.imports.name=未解析的已匯入名稱
javascript.validation.destructuring.without.initializer=解構宣告必須有初始設定式
javascript.validation.fqn.to.replace.with.import=限定名稱可被取代為 import 語句
javascript.validation.generators.yield.not.assignable.to.return=類型 ''{1}'' 不可分配給類型 ''{0}''
javascript.validation.generators.yield.not.in.generator=只允許在產生器正文中使用 'yield' 表達式。
javascript.validation.generators.yield.not.iterable=表達式類型沒有定義 [Symbol.iterator] 或 [Symbol.asyncIterator]
javascript.validation.initialized.var.in.for.loop=''{0}'' 迴圈中不允許變數初始設定式
javascript.validation.message.abstract.get.accessor.not.implemented=未實作類別 {1} 的 abstract get 存取器 {0}
javascript.validation.message.abstract.method.not.implemented=未實作類別 {1} 中的 abstract 方法 {0}
javascript.validation.message.abstract.set.accessor.not.implemented=未實作類別 {1} 的 abstract set 存取器 {0}
javascript.validation.message.accessor.could.not.be.nested.under.other.function=存取器方法不能嵌套在其他函式中
javascript.validation.message.arguments.is.readonly='arguments' 唯讀
javascript.validation.message.arguments.with.rest.parameter=使用 rest 參數時，'arguments' 物件不可用
javascript.validation.message.assignment.to.const=嘗試分配給常數或唯讀變數
javascript.validation.message.assignment.to.const.fix.remove.readonly=移除唯讀修飾符
javascript.validation.message.assignment.to.const.fix.replace=取代為 let
javascript.validation.message.attribute.was.specified.multiple.times=多次指定修飾符 {0}
javascript.validation.message.base.constructor.in.not.derived=僅允許在派生建構函式中呼叫基類別建構函式
javascript.validation.message.baseMethod.before.super.call=超類別建構函式呼叫前不允許有 'super'
javascript.validation.message.break.without.target=無法確定 'break' 的目標
javascript.validation.message.can.not.override.final.method=無法從{0}覆寫 final 方法
javascript.validation.message.circular.dependency=迴圈相依關係
javascript.validation.message.class.method.incompatible= ''{1}'' 類別中的方法 ''{0}'' 不可分配給基類別 ''{2}'' 中的同一方法
javascript.validation.message.class.method.not.implemented=未實作類別 {1} 的方法 {0}
javascript.validation.message.class.name.expected.here=此處應為類別名
javascript.validation.message.class.property.incompatible= ''{1}'' 類別中的屬性 ''{0}'' 不可分配給基類別 ''{2}'' 中的同一屬性
javascript.validation.message.class.property.not.implemented=未實作類別 {1} 的屬性 {0}
javascript.validation.message.class.setter.cannot.have.return.type='set' 存取器不能有返回值類型
javascript.validation.message.comma.is.not.allowed.after.last.parameter=最後一個參數後不允許有逗號
javascript.validation.message.comma.is.not.allowed.after.rest.element=rest 元素後不允許有逗號
javascript.validation.message.conflicting.definition.was.found.with.the.same.name=在命名空間 {1} 中發現衝突性的繼承宣告 {0}
javascript.validation.message.const.variable.without.initializer='const' 變數不包含初始設定式。以後無法賦予有意義的值。
javascript.validation.message.constructor.cannot.be.static=建構函式不能為 static
javascript.validation.message.constructor.cannot.have.custom.visibility=建構函式應為 public 或未指定可見性
javascript.validation.message.constructor.field.not.allowed=類別可能沒有名為 'constructor' 的非 static 欄位
javascript.validation.message.continue.outside.loop='continue' 在迴圈語句外部
javascript.validation.message.continue.without.target=無法確定 'continue' 的目標
javascript.validation.message.duplicate.catch.block=重複 catch 塊 #loc
javascript.validation.message.duplicate.catch.block.fix=移除重複的 catch 塊
javascript.validation.message.duplicate.declaration=重複宣告
javascript.validation.message.duplicate.declaration.fix.remove=移除類型
javascript.validation.message.duplicate.declaration.fix.text=導覽到上一個宣告 ''{0}''
javascript.validation.message.duplicate.declaration.fix.text.no.name=導覽到上一個宣告
javascript.validation.message.duplicate.default.export.declaration=一個模組不能有多個預設匯出
javascript.validation.message.duplicate.default.export.in.module=預設匯出只能在 ECMAScript-style 模組中使用
javascript.validation.message.duplicate.export.declaration=匯出宣告與已匯出的宣告 ''{0}'' 相衝突
javascript.validation.message.duplicate.label=重複標籤
javascript.validation.message.dynamic.can.be.applied.to.class=動態特性只能應用於類別宣告
javascript.validation.message.es5.function.declarations.allowed.on.top.level.or.function=禁止在程序或函式的頂層使用函式語句
javascript.validation.message.eval.cannot.be.assigned=不能在嚴格模式下分配 'eval'
javascript.validation.message.extend.final.class=無法擴展 final 類別 ''{0}''
javascript.validation.message.extend.multiple.classes=類別不能擴展多個類別
javascript.validation.message.final.modifier.allowed.only.for.methods=final 修飾符只能應用於類別和類別方法
javascript.validation.message.flowjs.path=Flow 路徑不正確
javascript.validation.message.for.await.no.async.context='for await' 只能在 'async' 函式中使用
javascript.validation.message.for.await.top.level=使用了頂層 'for await'
javascript.validation.message.function.method.invalid.overridden.parameter.type=不相容覆寫，應有類型 ''{0}''
javascript.validation.message.function.override.for.interface=對 {0} 中的方法進行了不相容的覆寫
javascript.validation.message.function.override.for.object.method=從 Object 繼承的方法無需覆寫
javascript.validation.message.function.override.incompatible.access.modifier=不相容覆寫，應有 ''{0}'' 存取修飾符
javascript.validation.message.function.override.incompatible.signature=不相容覆寫，應有簽名 ''{0}''
javascript.validation.message.function.override.incompatible.signature.generic=不相容覆寫
javascript.validation.message.function.override.incompatible.signature2=不相容覆寫，應有返回值類型 ''{0}''
javascript.validation.message.function.override.incompatible.signature3=不相容覆寫，應有種類 ''{0}''
javascript.validation.message.function.override.without.override.modifier=方法重寫了沒有 override 關鍵字的超類別 {0} 中的方法
javascript.validation.message.function.override.without.parent.method=方法不覆寫超類別的方法
javascript.validation.message.get.method.should.be.valid.type=getter 定義的返回值類型不應為 {0}
javascript.validation.message.get.method.should.have.no.parameter=getter 定義不得有形參
javascript.validation.message.get.method.type.is.different.from.setter=Get 存取器方法的類型與 set 存取器類型不相容，應為 ''{0}''
javascript.validation.message.identifier.not.allowed.in.strict.mode=在嚴格模式下不能將 ''{0}'' 用作關鍵字
javascript.validation.message.implements.for.interface.not.allowed=接口不允許有實作列表
javascript.validation.message.implements.is.not.allowed=標準 ECMAScript 中不允許有實作子句
javascript.validation.message.incompatible.override=對 {0} 中的成員進行了不相容的覆寫
javascript.validation.message.index.no.type=索引簽名參數必須具有類型註解
javascript.validation.message.index.wrong.type=索引簽名參數類型必須可以分配給 'string | number | symbol'
javascript.validation.message.interface.call.signature.not.implemented=未實作接口 {0} 的呼叫簽名
javascript.validation.message.interface.cannot.be.final.modifiers=接口不能為最終
javascript.validation.message.interface.get.accessor.not.implemented=未實作接口 {1} 的屬性 get 存取器 {0}
javascript.validation.message.interface.index.signature.not.implemented=未實作接口 {0} 的索引簽名
javascript.validation.message.interface.members.cannot.be.final.modifiers=接口成員不能為最終
javascript.validation.message.interface.members.cannot.have.access.modifiers=接口成員不能具有存取修飾符
javascript.validation.message.interface.members.cannot.have.namespace.attributes=接口成員不能具有命名空間特性
javascript.validation.message.interface.method.invalid.access.modifier=不相容實作，應有 'public' 存取修飾符
javascript.validation.message.interface.method.invalid.signature=不相容實作，應有簽名 ''{0}''
javascript.validation.message.interface.method.invalid.signature2=不相容實作，應有返回值類型 ''{0}''
javascript.validation.message.interface.method.invalid.signature3=不相容實作，應有 get / set ''{0}''
javascript.validation.message.interface.method.not.implemented=未實作來自接口 {1} 的方法 {0}
javascript.validation.message.interface.name.expected.here=此處應為接口名稱
javascript.validation.message.interface.property.not.implemented=未實作接口 {1} 的屬性 {0}
javascript.validation.message.interface.set.accessor.not.implemented=未實作接口 {1} 的屬性 set 存取器 {0}
javascript.validation.message.jsdoc.types.are.used=JSDoc 類型只能在文檔註釋內部使用
javascript.validation.message.missed.super.constructor.call=缺少超類別建構函式呼叫
javascript.validation.message.missing.catch.or.finally=缺少 catch 或 finally 子句
javascript.validation.message.must.be.lvalue={0} 中的左側無效
javascript.validation.message.nested.classes.are.not.allowed=不允許嵌套類別
javascript.validation.message.one.visibility.modifier.allowed=只允許一個可見性修飾符(public、protected、internal、private)
javascript.validation.message.only.one.default.is.allowed=\\ switch 中只允許一個預設子句
javascript.validation.message.override.can.be.applied.to.method=覆寫只能應用於函式宣告
javascript.validation.message.parameter.is.not.allowed.after.rest.parameter=rest 參數後不允許有任何參數
javascript.validation.message.parameter.non.optional.after.optional=必選參數不能位於可選參數後
javascript.validation.message.parameter.rest.optional=rest 參數不能是可選參數
javascript.validation.message.parameter.should.be.initialized=應初始化參數
javascript.validation.message.redeclaration.of.block.scope=不能重複宣告塊作用域變數
javascript.validation.message.redeclaration.of.block.scope.in.scope.of.var=塊作用域變數不能與同一塊作用域中的"var"變數或參數使用相同的名稱
javascript.validation.message.redeclaration.of.var.in.scope.of.block.scope="var" 變數不能與其可見性作用域內的塊作用域變數使用相同的名稱
javascript.validation.message.redefining.is.not.allowed=不允許重新定義 {0}
javascript.validation.message.redundant.type=顯式類型實參 {0} 可被取代為 {1}
javascript.validation.message.redundant.type.remove=可以移除顯式類型實參 {0}
javascript.validation.message.referencing.arguments.caller.callee.is.not.allowed=不允許從實參中參照 'caller' 和 'callee'
javascript.validation.message.referencing.function.arguments.property.is.not.allowed=不允許參照 'arguments' 函式屬性
javascript.validation.message.remove.unneeded.comma.fix=移除不需要的逗號
javascript.validation.message.rest.parameter.should.not.be.initialized=不應初始化 Rest 參數
javascript.validation.message.return.outside.function.definition='return' 在函式定義外部
javascript.validation.message.return.statement.required=非無效返回值類型必需具備 return 語句
javascript.validation.message.return.value.of.type.is.required=必需具備類型 {0} 的返回值
javascript.validation.message.set.method.should.be.void.or.without.type=setter 定義的返回值類型必須為未指定或無效
javascript.validation.message.set.method.should.have.one.parameter=setter 定義必須正好有一個參數
javascript.validation.message.set.method.type.is.different.from.getter=set 存取器方法的類型與 get 存取器類型不相容，應為 ''{0}''
javascript.validation.message.setter.parameter.cannot.have.initializer=Setter 定義不能具有可選參數
javascript.validation.message.static.method.cannot.be.final=靜態方法不能為最終
javascript.validation.message.static.modifier.is.allowed.only.for.class.members=僅允許類別成員使用 static 修飾符
javascript.validation.message.super.constructor.call.should.be.in.constructor=超類別建構函式呼叫應位於建構函式本體中
javascript.validation.message.super.referenced.from.static.context=在 static 上下文中參照了 'super'
javascript.validation.message.super.referenced.without.class.instance.context=在沒有類別實例上下文的情況下參照了'super'
javascript.validation.message.this.before.super.call=超類別建構函式呼叫前不允許有 'this'
javascript.validation.message.this.referenced.from.static.context=在 static 上下文中參照了 'this'
javascript.validation.message.unexpected.type.for.rest.parameter=Rest 參數不應有類型
javascript.validation.message.unknown.metadata.annotation.used=使用了未知的元資料特性
javascript.validation.message.unneeded.comma=不需要的逗號
javascript.validation.message.unresolved.component=未解析的組件 {0}
javascript.validation.message.use.namespace.reference.or.access.modifier=使用命名空間或存取修飾符
javascript.validation.multiple.var.in.for.loop=''{0}'' 迴圈中只允許一個變數
javascript.validation.new.target.not.in.function=僅允許函式宣告、函式表達式或建構函式的本體中有元屬性 'new.target'
javascript.validation.unused.import=未使用的 import
javascript.vector.literal.element.type.mismatch=矢量文字元素類型 {1} 不可分配給類型 {0}
javascript.visibility.internal=internal
javascript.visibility.private=private
javascript.visibility.protected=protected
javascript.visibility.public=public
javascript.with.statement.is.not.allowed.in.strict.mode.message=嚴格模式下不允許使用 With 語句
jest.cannot.find.bin.file.for.package.dialog.message=找不到 ''{0}'' 軟體套件的 bin 檔案
jest.coverage.cannot.find.lcov.info.notification.content=無法顯示 Jest 覆蓋率: 找不到 {0}。
jest.coverage.directory.not.found.notification.content=無法從 Jest 組態中讀取 coverageDirectory 選項
jest.coverage.notification.title=Jest 覆蓋率
jest.go.to.snapshot.text=轉到 ''{0}'' 快照
jest.package.placeholder.text=軟體套件目錄的路徑，可選擇 jest、react-scripts 或 react-scripts 替代項
jest.rc.configurationFile.label=組態檔案(&C):
jest.rc.configurationFile.title=選擇 Jest 組態檔案
jest.rc.jestOptions.emptyText=CLI 選項，例如 --watch 或 --env=jsdom
jest.rc.jestOptions.label=Jest 選項:
jest.rc.jestPackageField.label=Jest 軟體套件(&J):
jest.snapshot.label=Jest 快照
jest.snapshot.update.all.tests.text=<link>點擊以更新所有失敗的快照</link>
jest.snapshot.update.rc.name=更新 {0} 的快照
jest.snapshot.update.single.test.text=<link>點擊以更新 ''{0}'' 的快照</link>
jest.snapshot.update.test.file.text=<link>點擊以更新 {0} 中失敗的快照</link>
jquery.documentation.not.found=找不到 jQuery 文檔
js.accessibility.check.inspection.name=已參照無法存取的 @private 和 @protected 成員
js.add.braces.to.arrow.function=向箭頭函式中新增大括號
js.add.members.to.type=將成員 {0} 新增到 ''{1}''
js.add.members.to.type.desc=將成員新增到類別或接口
js.add.then.fix=新增 '.then()'
js.align.multiline.extends.list=多行時對齊
js.align.properties.none=不對齊
js.align.properties.on.colon=冒號上
js.align.properties.on.value=值上
js.annotator.assignment.pattern.rhs=賦值模式必須位於賦值的左側
js.annotator.inspection.name=未遵循 ECMAScript 規範
js.annotator.newline.before.arrow=箭頭前不允許換行符
js.annotator.replace.with.fat.arrow=取代為粗箭頭
js.annotator.rest.element.must.be.last=rest 元素必須位於最後
js.annotator.thin.arrow.used=使用了細箭頭
js.annotator.unary.operator.within.exponential=一元運算符 ''{0}'' 不允許直接位於指數表達式之前。建議新增括號以解決歧義問題。
js.annotator.yield.cannot.be.used.inside.generator='yield' 不能用作產生器內部的關鍵字
js.anonymous.to.named.function=匿名函式轉換為命名函式
js.arrangement.group.arrow.fields.with.methods=使用包含方法的箭頭函式初始化的組欄位
js.array.new.line.after.left.bracket=在 '[' 後換行
js.array.new.line.before.right.bracket=將 ']' 置於新行中
js.arrow.function.braces.can.be.removed.fix.family.name=移除箭頭函式體周圍的大括號
js.arrow.function.braces.can.be.removed.key=箭頭函式體周圍的大括號冗餘
js.arrow.function.braces.can.be.removed.problem.description=可以移除箭頭函式體周圍的大括號
js.assigning.to.primitive.type.property=賦給基元的值將丟失
js.assignment.issues.group.name=賦值問題
js.assignment.used.as.condition.fix=將 ''='' 取代為 ''{0}''
js.assignment.used.as.condition.name=用作條件的賦值
js.assignment.used.as.condition.text=<code>#ref</code> 作為條件使用
js.await-using.in.synchronous.function='await using' 指令只能在 'async' 函式中使用
js.await.in.synchronous.function='await' 運算符只能在 'async' 函式中使用
js.await.promise.double.await.inspection=冗餘 'await await'
js.await.promise.reject.inspection=冗餘 'await Promise.reject()'
js.await.promise.resolve.fix=取代為 ''{0}''
js.await.promise.resolve.inspection=冗餘 'await Promise.resolve()'
js.await.promise.return.await.inspection=冗餘 'return await'
js.await.promise.trivial.await.inspection=非 promise 類型的冗餘 'await'
js.bitwise.operator.usage.name=按位運算符用法
js.bitwise.operator.usage.popup=使用了按位運算符
js.bitwise.operator.usage.quickfix=取代為 {0}
js.blank.lines.around.function=Around 函式:
js.blank.lines.around.method=方法周圍:
js.breadcrumbs.callback.for=\\ {0}() 回調
js.chained.call.dot.on.next.line='.' 在新行
js.check.function.signature.guess.optionality=將非類型化參數視為必選
js.check.function.signature.guess.optionality.hint=如果停用，則所有未鍵入的參數均視為可選參數
js.checkbox.make.readonly=設為唯讀(&R)
js.class.context.type=類別/接口
js.class.member.expression.context.type=類別成員表達式
js.class.member.initialization.inspection.name=在 static 初始設定式中使用可能未分配的屬性
js.class.member.initialization.inspection.text=欄位 ''{1}'' 在 ''{0}'' 之後宣告，並且可能尚未分配
js.class.member.initialization.inspection.text.id=欄位 ''{0}'' 參照本身
js.class.member.statement.context.type=類別成員語句
js.closure.compiler.syntax.cyclic.inheritance=涉及 {0} 的迴圈繼承
js.closure.compiler.syntax.empty.type=空類型不可用
js.closure.compiler.syntax.implements.not.interface={0} 未用 @interface 進行註解
js.closure.compiler.syntax.inspection.name=JSDoc 標記不正確的用法
js.closure.compiler.syntax.invalid.type=類型語法無效
js.code.style.align.caption=對齊
js.code.style.align.from.clause.caption=對齊 'from' 子句
js.code.style.align.var.statements=當多行時
js.code.style.align.var.statements.and.assignments=分組時
js.code.style.array.group.name=陣列
js.code.style.do.not.align.var.statement=不對齊
js.code.style.file.name.camel.style=駝峰命名法 (appComponent)
js.code.style.file.name.lisp.style=中線命名法 (app-component)
js.code.style.file.name.mixed.style=帶後綴的中線命名法 (my-app.component)
js.code.style.file.name.pascal.style=帕斯卡命名法 (AppComponent)
js.code.style.file.name.relaxed.style=重用當前檔案的 case
js.code.style.file.name.snake.style=蛇形命名法 (app_component)
js.code.style.issues.group.name=程式碼樣式問題
js.code.style.object.literals.category.name=物件
js.code.style.punctuation.tab.title=標點
js.code.style.tab.name=JavaScript
js.commandline.configure.language.version=為專案組態 JavaScript 語言版本
js.commandline.configure.nodejs=組態 NodeJS 解釋器並為 package.json 檔案安裝軟體套件
js.comment.matches.signature.inspection.name=不符合的 JSDoc 和函式簽名
js.comment.matches.signature.inspection.problem1=JSDoc 中未描述參數 {0}
js.comment.matches.signature.inspection.problem2=JSDoc 中描述的參數 {0} 未出現在函式簽名中
js.comment.matches.signature.inspection.quickfix=更新 JSDoc 註釋
js.comparison.with.nan.inspection.name=與 NaN 比較
js.comparison.with.nan.inspection.problem=與 NaN 的相等比較的求值結果始終為 false
js.comparison.with.nan.inspection.problem2=與 NaN 的不等比較的求值結果始終為 true
js.comparison.with.nan.inspection.quickfix=取代為 {0}isNaN(...)
js.consecutive.commas.in.array.literal.inspection.insert.undefined=插入 'undefined'
js.consecutive.commas.in.array.literal.inspection.message=陣列文字中的連續逗號
js.consecutive.commas.in.array.literal.inspection.name=陣列文字中的連續逗號
js.constructor.cant.have.return.type=建構函式不能有返回值類型
js.constructor.returns.primitive.inspection.name=建構函式返回基元值
js.constructor.returns.primitive.inspection.problem=使用 'new' 調用時從建構函式返回的基元值將丟失
js.constructor.returns.primitive.inspection.quickfix=返回值類型顯式設定為 {0}
js.convert.for.each.to.for.of.intention.family=將 'forEach' 取代為 'for..of' 迴圈
js.convert.for.each.to.indexed.intention.family=將 'forEach' 取代為索引的 'for' 迴圈
js.convert.for.in.to.for.of.family.name=將 'for..in' 轉換為 'for..of'
js.convert.for.in.to.for.of.inspection.text=使用了 'for..in' 而不是 'for..of'
js.convert.for.in.to.for.of.text=將 'for..in' 轉換為 'for..of'
js.convert.for.of.to.indexed.intention.family=將 'for..of' 取代為索引的 'for' 迴圈
js.convert.indexed.for.to.for.of.family.name=將帶索引的 'for' 轉換為 'for..of'
js.convert.indexed.for.to.for.of.inspection.text=已使用索引的 'for' 而不是 'for..of'
js.convert.indexed.for.to.for.of.text=將帶索引的 'for' 轉換為 'for..of'
js.convert.indexed.for.to.foreach.intention.family=將索引的 'for' 轉換為 'forEach' 呼叫
js.convert.let.to.const.inspection.text=已使用 'let' 而不是 'const'
js.convert.map.to.for.of.intention.family=將 'map' 陣列呼叫取代為 'for..of' 迴圈
js.convert.module.exports.into.es6.export.family.name=轉換為 export
js.convert.module.exports.into.es6.export.inspection.text=使用了 'module.exports' 而不是 'export'
js.convert.module.exports.into.es6.export.text=轉換為 export
js.convert.parameters.to.object.intention.name=將參數轉換為物件
js.convert.parameters.to.object.non.call.usage.will.not.be.updated=不更新非呼叫用法
js.convert.parameters.to.object.usage.will.not.be.updated.for.contextual.type=方法會覆寫另一個方法。不會更新基方法
js.convert.parameters.to.object.usage.will.not.be.updated.for.spread=不會更新使用非終端傳播實參進行的呼叫
js.convert.parameters.to.object.with.interface.intention.name=將參數轉換為物件並引入接口
js.convert.require.into.es6.import.family.name=將 require() 轉換為 import
js.convert.require.into.es6.import.inspection.text=使用了 'require()' 而不是 'import'
js.convert.require.into.es6.import.inspection.withConditional.option=使用“全部修復”動作在內部作用域內轉換 require()
js.convert.require.into.es6.import.inspection.withConditional.option.description=在內部作用域內轉換 require() (例如 'if' 語句或內部函式)
js.convert.require.into.es6.import.text=將 require() 轉換為 import
js.convert.to.anonymous.function=轉換為匿名函式
js.convert.to.anonymous.function.family.name=箭頭函式轉換為匿名函式
js.convert.to.arrow.function=轉換為箭頭函式
js.convert.to.es6.class=轉換為類別
js.convert.to.es6.class.family.name=將函式及其成員宣告轉換為類別
js.convert.to.foreach.intention.name=將 'for-in' 轉換為 'forEach' 呼叫
js.convert.to.named.function=轉換為命名函式
js.convert.to.named.function.to.class.method=轉換為類別方法
js.convert.var.to.const.text=轉換為 const
js.convert.var.to.let.or.const=轉換為 let/const
js.convert.var.to.let.or.const.family.name=將 var 轉換為 let/const
js.convert.var.to.let.or.const.inspection.conservative.option=使用“全部修復”動作保守地轉換 var
js.convert.var.to.let.or.const.inspection.conservative.option.description=在第一次使用變數之前，宣告可能會移至函式器頂部。\\n\\
要在使用“全部修復”動作時停用此行為，請選中“保守轉換 var”選項。
js.convert.var.to.let.or.const.inspection.text=已使用 'var' 而不是 'let' 或 'const'
js.convert.var.to.let.text=轉換為 let
js.copy.qualified.to.clipboard=將限定名稱複製到剪貼簿
js.create.derived.type.abstract.class=實作抽象類別
js.create.derived.type.class=建立派生類別
js.create.derived.type.family=建立派生類別/實作接口
js.create.derived.type.interface=實作接口
js.create.switch.cases=建立缺少的 'switch' 分支
js.create.switch.cases.fix=建立缺少的分支: {0}
js.declaration.is.not.at.scope.start=var 語句不在作用域開始
js.declarations.at.scope.start.inspection='var' 未在函式開頭宣告
js.deprecated.symbols.inspection.name=已使用棄用的符號
js.destructuring.merge.inspection=正在解構具有相同鍵的屬性
js.destructuring.merge.inspection.fix=合併解構屬性
js.destructuring.merge.inspection.text=可以合併具有多個相同鍵的解構屬性
js.dialect.settings.caption=
js.dialect.settings.dialog.title=JavaScript 語言版本
js.dialect.settings.empty.text=使用 + 按鈕新增目錄，並選擇 JavaScript 版本
js.dialect.settings.override.question=覆寫子目錄和檔案的語言版本?
js.dialect.settings.override.title=覆寫語言版本設定
js.dialect.settings.tableTitle=語言
js.dialects.customized.label=根據目錄自定義
js.documentation.fires=觸發:
js.documentation.more.overload=其他 {0} 個多載
js.documentation.more.overloads=其他 {0} 個多載
js.dot.property.access.context.type=點號屬性存取
js.duplicate.declaration.inspection.name=重複宣告
js.edit.object.literal=編輯物件文字屬性的值
js.expand.shorthand.property.quick.fix=展開速記屬性
js.expression.context.type=表達式
js.extends.keyword.wrap=擴展關鍵字
js.extends.list.wrap=Extends 列表
js.extjs.unresolved.ext.xtype.inspection.name=未解析的 Ext JS xtype
js.file.references.inspection.ignore.complex.cases=忽略複雜 case
js.file.references.inspection.name=未解析的檔案參照
js.file.watcher.6to5.description=使用 Babel 將 ECMAScript 6 程式碼轉換成 ECMAScript 5
js.fix.change.member.access.to.sharp=使用 '#' 設為 private
js.flow.all.servers.action.restart=重啟所有 Flow 伺服器
js.flow.enable.flow.service.error=\\ 不正確的 Flow 路徑
js.flow.enable.flow.service.error.empty=Flow 可執行檔案的路徑為空
js.flow.enable.flow.service.error.message={0}。停用所有 Flow 服務或為可執行檔案提供有效路徑。
js.flow.enable.flow.service.error.on.checking=檢查 Flow 路徑時出錯: {0}
js.flow.enable.other.services=導覽、程式碼補全和類型提示
js.flow.enable.type.checking=類型檢查
js.flow.has.unsaved.files=由於修改了某些檔案，因此沒有執行醒目提示
js.flow.process.log=Flow 流程日誌
js.flow.services.label=為之使用 Flow 伺服器:
js.flow.settings.auto.save=自動儲存所有修改的檔案
js.flow.settings.auto.save.warning=只有儲存其他所有修改過的檔案時，Flow 才會檢查當前檔案。
js.flow.settings.auto.save.warning.lsp=這樣 Flow 將始終顯示最新的錯誤狀態。
js.flow.settings.executable.dialog.title=選擇 Flow 軟體套件或可執行檔案
js.flow.settings.executable.label=Flow 軟體套件或可執行檔案 (&F):
js.flowjs.annotation.inspection.name=Flow 類型檢查器
js.flowjs.config.inspection.message=無關聯的 .flowconfig
js.flowjs.config.inspection.name=缺少 .flowconfig
js.flowjs.config.inspection.to.current.path.name=向當前目錄中新增 .flowconfig
js.flowjs.config.inspection.to.module.path.name=向模組內容根中新增 .flowconfig
js.flowjs.config.inspection.to.project.path.name=向專案根目錄中新增 .flowconfig
js.flowjs.coverage.inspection.error.text=Flow 不涵蓋此元素
js.flowjs.coverage.inspection.name=Flow 不涵蓋程式碼
js.flowjs.flag.comment.placement.inspection.error=Flow 標誌註釋不在檔案起始處
js.flowjs.flag.comment.placement.inspection.fix=將 Flow 標誌註釋移至檔案起始處
js.flowjs.flag.comment.placement.inspection.name=位置錯誤的 @flow 標記
js.flowjs.flag.without.language.version=無 Flow 語言版本的 Flow 標誌
js.flowjs.group.name=Flow 類型檢查器
js.format.cstyle.comments=對齊多行
js.frameworks.sencha.xtype.not.found=找不到 xtype ''{0}'' 的 Ext JS 類別
js.function.brace.style=在函式宣告中
js.function.call.parentheses=函式呼叫括號
js.function.call.wrap=函式呼叫實參
js.function.declaration.parentheses=函式宣告括號
js.function.expression.brace.style=在函式表達式中
js.function.metrics.group.name=函式指標
js.function.parameters.wrap=函式宣告參數
js.generated.explicit.return.expression.types=函式表達式返回
js.generated.explicit.return.types=函式宣告返回
js.generated.explicit.types=此項的首選顯式類型:
js.generated.explicit.var.types=變數和欄位
js.generated.types=類型
js.generated.types.settings.link=顯式類型的程式碼樣式設定
js.generated.use.as.cast=首選 'as' 類型轉換
js.generated.use.public.modifier=使用 'public' 修飾符
js.import.options.merge.import=合併同一模組中成員的匯入
js.import.options.sort.members=對匯入的成員排序
js.import.options.sort.module.name=按模組對匯入排序
js.import.options.use.explicit.js.extension=使用檔案副檔名:
js.import.options.use.explicit.js.extension.auto=自動
js.import.options.use.explicit.js.extension.no=從不
js.import.options.use.explicit.js.extension.yes=始終
js.import.options.use.explicit.js.extension.yes.ts=始終為 ".js"
js.import.options.use.node.resolution=在 index.js 可用時使用目錄匯入(Node 樣式模組解析)
js.imports.dependencies.group.name=Import 和相依項
js.incompatible.types.comparison.inspection.name=類型不相容的表達式的比較
js.incompatible.types.comparison.message=條件始終為 {0, choice, 0#false|1#true}，因為類型 ''{1}'' 和 ''{2}'' 沒有重疊
js.indexer.to.property.intention=取代為屬性存取
js.infer.parameter.types.intention=從用法中推斷參數類型
js.infer.parameter.types.intention.failure.readonly.text=無法從用法中推斷類型: 為唯讀檔案
js.infer.parameter.types.intention.failure.text=無法從用法中推斷類型
js.infer.parameter.types.intention.failure.title=無法推斷類型
js.infer.parameter.types.intention.jsdoc=從用法中推斷 JSDoc 參數類型
js.infer.parameter.types.intention.progress.text=正在推斷類型
js.inject.dont.format.intention.text=停用注入內容的格式設定
js.inject.with.comment.intention.family.name=使用註釋對注射做出註解
js.inspection.amd.modules.dependencies.family.name=缺少 AMD 模組相依關係
js.inspection.async.group.name=Async 程式碼和 promise
js.inspection.bitwise.group.name=按位運算問題
js.inspection.convert.to.es6.group.name=ES2015 遷移協助
js.inspection.es6.modules.dependencies.family.name=缺少 import 語句
js.inspection.function.expression.is.used.instead.of.arrow=使用了函式表達式而不是箭頭函式
js.inspection.group.name=一般
js.inspection.group.path=JavaScript 和 TypeScript
js.inspection.missing.amd.dependency=缺少 AMD 模組相依關係
js.inspection.missing.import=缺少 import 語句
js.inspection.missing.module.dependency=缺少模組相依關係
js.inspection.package.json.dependencies=package.json 中的相依關係不符合
js.inspection.package.json.update.dependency.to.latest.version=將 package.json 相依項更新為最新版本
js.inspection.promise.ignored.display.name=返回 promise 的方法呼叫結果被忽略
js.inspection.promise.ignored.problem.descriptor=從 {0} 返回的 Promise 被忽略
js.inspection.promise.value.expected.problem.descriptor=應為值，但使用了從 {0} 返回的 Promise
js.inspection.switch.group.name=switch 語句問題
js.iterate=使用 'for..of' 進行迭代
js.iterate.async=使用 'for await..of' 進行迭代
js.join.declaration.assignment.inspection.fix=聯接變數宣告和賦值
js.join.declaration.assignment.inspection.name=變數宣告可與變數的第一個賦值合併
js.join.vars.intention=加入後續變數宣告
js.jquery.efficiency.inspection.allow.attribute.and.pseudo.selectors=允許特性和偽選擇器
js.jquery.efficiency.inspection.attribute.used.message=jQuery 特性選擇器可能低效
js.jquery.efficiency.inspection.duplicated.selector=重複的 jQuery 選擇器
js.jquery.efficiency.inspection.name=可以最佳化 JQuery 選擇器
js.jquery.efficiency.inspection.pseudoselector.used.message=jQuery 偽選擇器可能低效
js.language.feature.annotations=註解
js.language.feature.arbitrary.precision.integers=任意精度整數
js.language.feature.array.comprehensions=陣列推導式
js.language.feature.arrow.functions=箭頭函式
js.language.feature.async.await=async/await
js.language.feature.binary.0b.and.new.octal.0o.literals=二進制(0b)和新的八進制(0o)文字
js.language.feature.bind.expressions=綁定表達式
js.language.feature.class.member.visibility.modifiers=類別成員可見性修飾符
js.language.feature.classes=類別
js.language.feature.computed.property.names=計算的屬性名稱
js.language.feature.const.definitions=Const 定義
js.language.feature.decorator.declarations=裝飾器宣告
js.language.feature.default.parameter.values=預設參數值
js.language.feature.destructuring.assignments=解構賦值
js.language.feature.destructuring.parameters=解構參數
js.language.feature.ecmascript.syntax.for.private.members=私有成員的 ECMAScript #- 語法
js.language.feature.enums=枚舉
js.language.feature.es6.export.declarations=ES6 匯出宣告
js.language.feature.es6.import.declarations=ES6 匯入宣告
js.language.feature.expression.closures=表達式結束
js.language.feature.for.each.statements=針對每條語句
js.language.feature.for.of.loops=for..of 迴圈
js.language.feature.generator.expressions=產生器表達式
js.language.feature.generators=生成器
js.language.feature.generics=泛型
js.language.feature.getters.and.setters=getter 和 setter
js.language.feature.interfaces=接口
js.language.feature.let.definitions=Let 定義
js.language.feature.let.statements=Let 語句
js.language.feature.method.definition.shorthands=方法定義速記形式
js.language.feature.nullish.coalescing=Null 合併運算符
js.language.feature.optional.catch.bindings=可選 catch 綁定
js.language.feature.optional.chaining.operator=可選鏈接運算符
js.language.feature.pipe.expressions=管道表達式
js.language.feature.reference.namespace=參照命名空間
js.language.feature.rest.parameters=rest 參數
js.language.feature.shorthand.property.names=速記屬性名稱
js.language.feature.string.templates=字串模板
js.language.feature.throw.expressions=拋出表達式
js.language.feature.top.level.yield.expressions=頂層 yield 表達式
js.language.feature.trailing.commas.in.function.parameter.lists.and.calls=函式參數列表和呼叫中的尾隨逗號
js.language.feature.types=類型
js.language.feature.unicode.escapes.with.braces=使用大括號的 Unicode 轉義
js.language.feature.xml.tags=XML 標記
js.language.version.combo.es5=ECMAScript 5.1
js.language.version.combo.es6=ECMAScript 6+
js.language.version.combo.es6.description=ECMAScript 2015+、一些提案和 JSX
js.language.version.combo.flow=Flow
js.language.version.combo.flow.description=ECMAScript 6 中的 Flow 和 JSX
js.language.version.combo.js185=JavaScript 1.8.5
js.language.version.combo.js185.description=已棄用特定於 Firefox 的 ECMAScript 實作。請考慮切換。
js.language.version.combo.nashorn=Nashorn JS
js.language.version.combo.nashorn.description=Java 中的 JavaScript 實作
js.language.version.label=JavaScript 語言版本
js.last.comma.in.array.literal.inspection.name=陣列文字中的最後一個逗號多餘
js.last.comma.in.object.literal.inspection.name=物件文字中的最後一個逗號多餘
js.library.attach.debug=附加偵錯版本(&D)…
js.library.attach.release=附加發佈版本(&R)…
js.library.configurable.name=庫
js.library.documentation=文檔
js.library.download.fix=下載庫
js.library.download.stubs.label=TypeScript 社區存根
js.library.downloading.library=正在下載庫
js.library.successfully.downloaded=已成功下載 {0}
js.library.unresolved.url.inspection.name=HTTP 鏈接缺少本地存儲的庫
js.linter.guesser.linter.disabled={0} 已停用。
js.linter.guesser.linter.enabled.because.of.config.file=已啟用 {0}: 組態檔案位於專案中。
js.linter.guesser.linter.enabled.because.of.dependency=已啟用 {0}: ''{1}'' 列出在 package.json 中。
js.linter.guesser.linter.enabled.because.of.package.json.section=已啟用 {0}: ''{1}'' 位於 package.json 中。
js.linters.detect.automatically.caption=從最近的 package.json 檢測軟體套件和組態檔案
js.linters.inspection.group.name=程式碼品質工具
js.make.single.var.statement=設為單變數語句
js.method.can.be.static=方法可以為 'static'
js.method.can.be.static.option=僅檢查 'private' 方法
js.mismatched.update.collection.inspection.name=不符合的集合查詢和更新
js.mismatched.update.collection.update.method.names=更新方法名稱:
js.missing.await.symbol.inspection.for.generator.name=異步產生器應使用 for-await 迴圈進行迭代
js.missing.await.symbol.inspection.for.returns=始終對異步函式呼叫使用 'await' 以避免錯誤，並幫助進行 V8 異步堆疊追蹤
js.missing.await.symbol.inspection.name=異步函式呼叫缺少 await
js.missing.switch.branches.ignore.with.default=忽略具有預設分支的 switch 語句
js.missing.switch.branches.inspection.desc=''switch'' 語句缺少 case: {0}
js.missing.switch.branches.inspection.name='switch' 語句缺少分支
js.module.uml.presentable.name=JavaScript 模組相依項
js.move.to.scope.start=將 var 語句移至作用域開始
js.move.type.to.file.family=移至名稱符合的檔案
js.move.type.to.file.text=將 {0} 移至檔案 {1}
js.named.to.anonymous.family.name=轉換為函式表達式
js.named.to.arrow.text = 轉換為含有 {0} 的箭頭函式
js.named.to.function.expression.text = 轉換為包含變數的函式表達式
js.named.to.function.hoisting.conflict.text=函式在宣告之前使用。轉換為變數後，將中斷使用
js.nested.template.literal.fix=內聯嵌套文字
js.nested.template.literal.inspection=模板文字中的冗餘嵌套
js.param.hints.blacklist.pattern.explanation=要停用方法或函式提示，請使用下面的其中一種模式: <p style="margin-left: 5px"><code><b>(*info)</b></code> - 所有參數名稱以 <em>info</em> 結尾的單參數方法<br><code><b>(key, value)</b></code> - 所有包含參數<em>鍵</em>和<em>值</em>的方法<br><code><b>*.put(key, value)</b></code>- 所有包含<em>鍵</em>和<em>值</em>參數的 <em>put</em> 方法<br><code><b>Console.log(*, *)</b></code> - 正好包含兩個參數的 <em>Console</em> 類型的 <em>log</em> 方法</p><br><p>必須為所有參數(包括可選參數)提供名稱或佔位符。<br>限定方法名稱必須包含類別或接口名稱或佔位符。<br>在編輯程式碼時，請使用“不為當前方法顯示提示”{0} 動作來新增模式。</p>
js.param.hints.show.names.for.all.args=非文字實參
js.param.hints.show.names.for.pipes=管道運算符
js.param.hints.show.names.for.tagged=標記的模板實參
js.possibly.async.function.inspection=非異步函式中的 'await'
js.possibly.async.function.quick.fix=令函式 {0} 為異步函式
js.possibly.async.function.quick.fix.family.name=將函式設為異步
js.potentially.invalid.constructor.usages.inspection.name=可能無效的建構函式用法
js.potentially.invalid.target.of.indexed.property.access.inspection.name=索引的屬性存取的目標可能不正確
js.potentially.invalid.usage.of.class.this.inspection.name=從閉包對類別中 'this' 的參照可能無效
js.potentially.invalid.usage.of.this.inspection.name=從閉包對 'this' 的參照可能無效
js.primitive.type.improper.instantiation.inspection={0} 實例化可以簡化
js.primitive.type.wrapper.usage.inspection=使用了基元類型物件包裝器
js.probable.bugs.group.name=可能的錯誤
js.property.can.be.replaced.with.shorthand=屬性可被取代為速記形式
js.property.can.be.replaced.with.shorthand.method=屬性可被取代為速記方法
js.property.to.indexer.intention=取代為索引器存取
js.pull.up.will.be.made.abstract=非 abstract {0}將被設為 abstract
js.quote.unquote.intention.plural={0} 屬性名稱
js.quote.unquote.intention.quote=參照
js.quote.unquote.intention.quote.family=使用引號包裝屬性名稱
js.quote.unquote.intention.singular={0} 屬性名稱
js.quote.unquote.intention.unquote=取消參照
js.quote.unquote.intention.unquote.family=移除屬性名稱中的引號
js.react.group.name=React
js.redundant.await.inspection=冗餘 'await' 表達式
js.redundant.switch.problems.inspection.default='switch' 語句僅包含一個 'default' 子句
js.redundant.switch.problems.inspection.default.unwrap=解包 'switch' 語句
js.redundant.switch.problems.inspection.empty='switch' 語句為空
js.redundant.switch.problems.inspection.empty.remove=移除空的 'switch' 語句
js.redundant.switch.problems.inspection.name='switch' 語句冗餘，可以取代
js.redundant.switch.problems.inspection.side.effects=並提取副作用
js.redundant.switch.problems.inspection.single='switch' 語句僅包含一個非預設子句
js.redundant.switch.problems.inspection.single.replace=將 'switch' 取代為 'if'
js.referencing.mutable.variable.from.closure.inspection.name=從閉包中參照可變變數
js.regex.flag.d=符合索引 - 用於子字串符合的索引
js.regex.flag.g=全域符合 - 返回所有符合項
js.regex.flag.i=忽略大小寫 - 不區分大小寫的符合
js.regex.flag.m=多行 - ^ 和 $ 的每行符合
js.regex.flag.s=dotAll - . 符合換行符
js.regex.flag.u=unicode - 完整 unicode 支援
js.regex.flag.y=粘性 - 在確切的位置搜尋
js.remove.digit.separators=移除數字分隔符
js.remove.redundant.initializer.fix=移除冗餘的初始設定式
js.remove.unused.assignment=移除未使用的賦值
js.rename.base.member=重新命名基{0}
js.rename.current.member=重新命名當前 {0}
js.rename.file.to.match.type.name=將檔案重命名為 {0} 以匹配 {1} 名稱
js.rename.file.to.match.type.name.family=重新命名檔案以符合類型名稱
js.rename.member.title={0} {1} {3} 的 {2}
js.rename.member.title.implements=實作
js.rename.member.title.overrides=覆寫
js.replace.string.concatenation.with.es6.template.fix.text=取代為模板字串
js.replace.string.concatenation.with.es6.template.inspection.name=已使用字串串聯而不是模板文字
js.replace.string.with.es6.template=取代為模板字串
js.replace.with.literal=取代為 {0} 文字
js.replace.with.shorthand.method.quick.fix=取代為速記方法
js.replace.with.shorthand.property.quick.fix=取代為速記屬性
js.replace.with.type.cast.to.primitive=取代為 {0} 的類型轉換
js.separate.bytes=分隔位元組
js.separate.digits=分隔數字
js.separate.nibbles=分隔半位元組
js.separate.thousands=分隔千分位
js.separate.thousands.in.integer.part=分隔整數中的千分位
js.separate.words=分隔 16 位單詞
js.show.dynamic.usages=顯示動態用法
js.show.type.info.action.error=找不到表達式
js.space.before.function.left.brace=函式左大括號
js.spaces.in.flow.category=在 Flow 中
js.split.declarations=拆分宣告
js.split.into.multiple.declarations=拆分為多個宣告
js.statement.context.type=語句
js.strict.mode.inspection.error={0} 不處於嚴格模式下
js.strict.mode.inspection.fix=新增“use strict”雜註
js.strict.mode.inspection.name=使用了非嚴格模式
js.strict.mode.inspection.redundant.pragma="use strict"雜註冗餘
js.strict.mode.remove.pragma=移除“use strict”雜註
js.string.template.line.separators.multispan=轉換為多行字串模板
js.string.template.line.separators.multispan.family.name=轉換為多行字串模板
js.string.template.line.separators.visible=轉換為可見行分隔符
js.string.template.line.separators.visible.family.name=轉換模板字串以使用可見行分隔符
js.suspicious.bind.with.arrow.function=箭頭函式 'bind' 用法可疑
js.suspicious.eq.plus.fix.name=取代為 '+='
js.suspicious.eq.plus.inspection.desc=可疑的 '=+' 賦值: '+=' 可能拼寫錯誤
js.suspicious.eq.plus.inspection.name=可疑的 '=+' 賦值
js.suspicious.name.assignment=''{0}'' 可能不應分配給 ''{1}''
js.suspicious.name.combination.inspection.name=可疑的變數/參數名稱組合
js.suspicious.name.parameter=''{0}'' 可能不應作為參數 ''{1}'' 傳遞
js.suspicious.name.return=''{0}'' 可能不應從方法 ''{1}'' 返回
js.switch.no.default='switch' 語句沒有 'default' 分支
js.switch.no.default.add=建立缺少的預設分支
js.switch.to.jsx.inspection.dismiss=關閉
js.testing.autoWatch.action.name=留意變化
js.testing.highlight.line=在測試程式碼中醒目提示失敗的行
js.testing.inspection.group.name=單元測試
js.tool.window.limit=顯示前 {0} 個錯誤。
js.tool.window.limit.all=檢視所有 {0} 個錯誤
js.top.level.await.expression.inspection= 頂層 'await' 表達式
js.top.level.await.expression.inspection.description= 使用了頂層 'await' 表達式
js.top.level.statement.context.type=頂級語句
js.trailing.comma.keep=保持
js.trailing.comma.remove=移除
js.trailing.comma.whenMultiline=多行時新增
js.undeclared.variable.inspection.name=隱式宣告的全域 JavaScript 變數
js.undefined.property.assignment.inspection.message=類型 {1} 中未定義屬性 {0}
js.undefined.property.assignment.inspection.name=未定義的屬性賦值
js.unfiltered.for.in.loop.inspection.name=未過濾 for..in 迴圈
js.unfiltered.for.in.loop.skip.primitives=使用陣列或物件初始設定式跳過參照迭代
js.unfiltered.for.in.loop.skip.primitives.tooltip=在未修改 Object.prototype 和 Array.prototype 時啟用它
js.unnecessary.semicolon.fix.name=移除不必要的分號
js.unnecessary.semicolon.inspection.name=不必要的分號
js.unnecessary.semicolon.problem=不必要的分號 #loc
js.unreachable.switch.branches.ignore.with.dynamic=不在動態類型的上下文中顯示此警告
js.unreachable.switch.branches.inspection.desc=不可到達的 'case' 分支
js.unreachable.switch.branches.inspection.name=不可到達 'switch' 語句的 'case' 分支
js.unreachable.switch.branches.remove=移除不可到達的 'case' 分支
js.unresolved.variable.inspection.name=未解析的參照
js.unused.assignment.inspection.name=未使用的賦值
js.unused.es6.import.inspection.name=未使用的 import
js.unused.global.symbol.inspection.name=未使用的全域符號
js.unused.local.symbol.inspection.name=未使用的區域符號
js.unused.symbol=未使用的 {0} #ref
js.unused.symbol.full=未使用的 {0}
js.unused.symbol.remove=移除未使用的 {0}
js.unused.symbols.group.name=未使用的符號
js.unwanted.symbols.group.name=可能不合需要的程式碼結構
js.url.import.usage.inspection.download.module.0.quick.fix.failed=下載模組 ''{0}'' 失敗
js.url.import.usage.inspection.download.module.0.quick.fix.progress=正在下載模組 ''{0}''
js.url.import.usage.inspection.download.module.0.quick.fix.success=模組 ''{0}'' 已成功下載
js.url.import.usage.inspection.download.module.0.quick.fix.warning=模組 ''{0}'' 已下載，但有錯誤
js.url.import.usage.inspection.download.module.0.quick.fix.warning.urls=失敗的 URL:
js.url.import.usage.inspection.download.module.quick.fix.name=下載模組
js.url.import.usage.inspection.name=使用了 URL 匯入
js.usage.type.call=函式呼叫中的用法
js.validate.jsdoc.inspection.name=JSDoc 中的語法錯誤和未解析的參照
js.validate.signature.inspection.name=簽名不符合
js.validate.types.inspection.name=類型不符合
js.validity.issues.group.name=有效性問題
js.value.assigned.is.never.used=從未使用過所賦之值 #loc
js.value.assigned.to.is.never.used=賦給 ''{0}'' 的值從未使用 #loc
js.variable.initializer.is.redundant=變數初始設定式冗餘 #loc
js.variable.might.not.been.initialized=變數可能尚未初始化 #loc
js.variable.problems.ignore.desc=對可變變數忽略
js.variable.problems.inspection.desc=變數 ''{0}'' 在子句 ''{1}'' 中宣告， 但在子句 ''{2}'' 中使用
js.variable.problems.inspection.desc.ref.error=存取時參照錯誤
js.variable.problems.inspection.name=宣告了變數並在不同的 'case' 子句中使用
js.void.function.result.used.description=使用了 void 函式返回值
js.void.function.result.used.name=使用了 void 函式返回值
js.wrap.settings.import=ES6 匯入/匯出
js.wrap.settings.object.types=物件類型
js.wrap.settings.union.and.intersection.types=聯合和相交類型
js.wrap.settings.var.group.name=變數宣告
jsdoc.tag=JSDoc 標記
jsdoc.tag.description=JSDoc 標記描述
jsdoc.tag.namepath=JSDoc 標記的 namepath
jsdoc.text=JSDoc 文本
jsdoc.type=JSDoc 類型
jshint.clear.field.to.disable=清除要停用的欄位
jshint.config.default.description=<div style="padding-bottom:10px"><div><b>.jshintrc</b></div><div style="padding-left:10px; padding-top:4px;">對 JavaScript 檔案進行 Linting 檢查時，IDE 會從檔案所在的目錄開始尋找 .jshintrc，然後上行到檔案系統根目錄。</div></div><div><div><b>package.json</b></div><div style="padding-left:10px; padding-top:4px;">將您的組態新增到專案的 package.json 檔案中的 <code>jshintConfig</code> 屬性下。</div></div>
jshint.config.error.cannot.locate.ext.config=JSHint: 無法定位擴展組態
jshint.config.error.cannot.parse.ext.config=JSHint: 無法解析擴展組態
jshint.config.error.failed.to.read.property=無法從 package.json 讀取 ''{0}'' 屬性
jshint.config.extends.cyclically=JSHint 組態迴圈擴展
jshint.config.failed.to.read=無法讀取 JSHint 組態
jshint.config.option.custom.browser.title=選擇 JSHint 組態檔案 (*.jshintrc)
jshint.config.option.custom.name=自訂組態檔案
jshint.config.option.default.name=預設
jshint.exception.balloon.action.configure.proxy.or.retry=<a href=''{0}''>組態 HTTP 代理</a>或<a href=''{1}''>重試</a>
jshint.exception.balloon.action.retry=<a href=''{0}''>重試</a>
jshint.illegal.integer=非法整數
jshint.inspection.message.config.not.found=未找到 JSHint 組態
jshint.inspection.message.duplicate.options=重複 JSHint 選項: {0}，{1}。
jshint.inspection.message.expected.value=預期值: {0}
jshint.inspection.message.expected.values.x.or.y=預期值: {0} 或 {1}
jshint.inspection.message.malformed.config=JSHint 組態格式錯誤
jshint.inspection.message.not.loaded=未載入 JSHint {0}
jshint.inspection.message.object.or.array.expected=應為物件或陣列
jshint.inspection.message.prefix=JSHint:
jshint.inspection.message.unexpected.jshint.option.name=意外的 JSHint 選項名稱
jshint.inspection.message.unexpected.value=意外值
jshint.label.bundled.suffix=(捆綁)
jshint.label.no.version=無版本
jshint.latedef.false.text=不警告
jshint.latedef.nofunc.text=<html><body>禁止變數在未定義的情況下使用，<br>但允許函式宣告。</body></html>
jshint.latedef.true.text=禁止變數在未定義的情況下使用
jshint.option.asi.description.short=禁止缺少分號的警告
jshint.option.bitwise.description.short=有關使用逐位運算符的警告
jshint.option.boss.description.short=禁止有關 <code>if/for/…</code> 內部賦值的警告
jshint.option.browser.description.short=瀏覽器
jshint.option.camelcase.description.short=有關變數命名的警告
jshint.option.curly.description.short=塊省略 <code>{}</code> 時發出警告
jshint.option.debug.description.short=禁止有關偵錯模式的警告
jshint.option.devel.description.short=開發
jshint.option.edit.dialog.title=設定 ''{0}'' 選項
jshint.option.elision.description.short=禁止有關 ES3 陣列省略元素的警告
jshint.option.enforceall.description.short=程式碼未遵守最嚴格的組態時發出警告
jshint.option.eqeqeq.description.short=有關不安全比較的警告
jshint.option.eqnull.description.short=禁止有關 <code>== null</code> 的警告
jshint.option.es3.description.short=有關與 ES3 規範不相容的警告
jshint.option.es5.description.short=有關與 ES5 規範不相容的警告
jshint.option.esnext.description.short=EcmaScript.next
jshint.option.esversion.description.short=在與指定的 ECMAScript 版本不相容時發出警告
jshint.option.evil.description.short=禁止有關 <code>eval</code> 的警告
jshint.option.expr.description.short=禁止有關將表達式用作語句的警告
jshint.option.forin.description.short=有關不安全 <code>for..in</code> 的警告
jshint.option.freeze.description.short=有關覆蓋原生物件原型的警告
jshint.option.funcscope.description.short=禁止有關在已宣告塊外部使用變數的警告
jshint.option.futurehostile.description.short=有關使用在以後的 JavaScript 版本中定義的關鍵字的警告
jshint.option.gcl.description.short=將 JSHint 設為與 Google Closure Compiler 相容
jshint.option.globalstrict.description.short=禁止有關使用全域嚴格模式的警告
jshint.option.immed.description.short=有關未使用括號包裝函式而直接呼叫函式的警告
jshint.option.indent.description.short=縮排
jshint.option.iterator.description.short=禁止有關 <code>__iterator__</code> 屬性的警告
jshint.option.lastsemic.description.short=禁止有關缺少分號的警告，但僅當單行塊中的最後一條語句省略分號時才顯示該警告
jshint.option.latedef.description.short=當變數在未定義的情況下使用時發出警告
jshint.option.laxbreak.description.short=禁止有關不安全換行的警告
jshint.option.laxcomma.description.short=禁止有關編碼樣式以逗號開頭的警告
jshint.option.loopfunc.description.short=禁止有關函式在迴圈內部的警告
jshint.option.maxcomplexity.description.short=程式碼中的最大迴圈復雜度
jshint.option.maxdepth.description.short=塊的最大深度
jshint.option.maxerr.description.short=最大錯誤數
jshint.option.maxlen.description.short=行的最大長度
jshint.option.maxparams.description.short=函式中的最大參數數量
jshint.option.maxstatements.description.short=函式中的最大語句數量
jshint.option.module.description.short=ECMAScript 6 模組
jshint.option.moz.description.short=檢查程式碼是否使用 Mozilla JavaScript 擴展
jshint.option.multistr.description.short=禁止有關多行字串的警告
jshint.option.newcap.description.short=有關使用非大寫形式的建構函式的警告
jshint.option.noarg.description.short=有關 <code>arguments.caller</code> 和 <code>.callee</code> 的警告
jshint.option.nocomma.description.short=有關使用逗號運算符的警告
jshint.option.noempty.description.short=有關空塊的警告
jshint.option.nomen.description.short=不允許使用 _ in 變數
jshint.option.nonbsp.description.short=有關“不間斷空格”字元的警告
jshint.option.nonew.description.short=有關副作用 <code>new</code> 用法的警告
jshint.option.nonstandard.description.short=轉義和未轉義
jshint.option.notypeof.description.short=禁止有關無效 <code>typeof</code> 運算符值的警告
jshint.option.noyield.description.short=禁止在產生器函式中無 yield 語句時有關產生器函式的警告
jshint.option.onevar.description.short=每個函式一個變數語句
jshint.option.passfail.description.short=出現第一個錯誤時停止
jshint.option.plusplus.description.short=有關使用一元遞增和遞減運算符的警告
jshint.option.predef.description.short=預定義(以 , 分隔)
jshint.option.predef.details=指定全域變數及其可分配狀態:\\n\\
<pre>DISQUS:true、jQuery:false</pre>\\n\\
<p/>此時，JSHint 允許您覆寫 DISQUS，但禁止覆寫 jQuery。
jshint.option.proto.description.short=禁止有關 <code>__proto__</code> 屬性的警告
jshint.option.quotmark.description.short=引號
jshint.option.scripturl.description.short=禁止有關使用以腳本為目標的 URL 的警告
jshint.option.shadow.description.short=禁止有關變數隱藏的警告
jshint.option.singlegroups.description.short=如果未嚴格要求使用分組運算符，禁止使用該運算符
jshint.option.smarttabs.description.short=在空格僅用於對齊時，禁止有關將制表符和空格混合使用的警告
jshint.option.strict.description.short=程式碼未採用嚴格模式時發出警告
jshint.option.sub.description.short=如果可以使用點符號表示 <code>[]</code> 符號，則禁止有關使用後者的警告
jshint.option.supernew.description.short=禁止有關“怪異”建構的警告
jshint.option.trailing.description.short=有關尾隨空格的警告
jshint.option.typed.description.short=輸入的陣列
jshint.option.undef.description.short=未定義變數時發出警告
jshint.option.unused.description.short=存在未使用的變數時發出警告
jshint.option.validthis.description.short=禁止有關可能違反嚴格要求的警告
jshint.option.varstmt.description.short=有關使用 VariableStatements 的警告
jshint.option.white.description.short=不允許使用雜亂的空格
jshint.option.withstmt.description.short=禁止有關使用 with 語句的警告
jshint.option.worker.description.short=Web 工作執行緒
jshint.option.wsh.description.short=Windows Script Host
jshint.options.tree.tooltip.set.a.new.value=設定新值
jshint.progress.title=JSHint {0}
jshint.progress.title.downloading=正在下載 {0}
jshint.progress.title.updating.jshint=正在將 JSHint 更新到 {0}
jshint.quotmark.double.text=僅允許雙引號
jshint.quotmark.false.text=允許兩種引號
jshint.quotmark.single.text=僅允許單引號
jshint.quotmark.true.text=僅允許單引號或雙引號
jshint.suppress.text.suppress.for.line=禁止行
jshint.tree.link.set=設定
jshint.unused.false.text=不檢查任何內容
jshint.unused.strict.text=檢查所有變量和參數
jshint.unused.true.text=<html><body>檢查所有變量和參數，但允許<br>使用的參數後存在未使用參數</body></html>
jshint.unused.vars.text=檢查變數，而不是函式參數
jshint.use.config.files=使用組態檔案
jshint.version.label=版本(&V):
jsx.code.style.attribute.default.value=為 JSX 特性新增:
jsx.code.style.attribute.default.value.braces=大括號
jsx.code.style.attribute.default.value.none=無
jsx.code.style.attribute.default.value.quotes=引號
jsx.code.style.attribute.default.value.typebased=基於類型
jsx.convert.html.attributes.to.jsx=將 HTML 貼上到 JSX 檔案時轉換特性
jsx.dom.nesting.inspection.message=''{0}'' 不能作為 ''{1}'' 的子級出現
jsx.dom.nesting.inspection.message.text=文本節點不能顯示為 ''{0}'' 的子級
jsx.dom.nesting.inspection.message.tr=''{0}'' 不能作為 ''{1}'' 的子級出現。在您的程式碼中新增 <tbody>、<thead> 或 <tfoot> 以符合瀏覽器生成的 DOM 樹。
jsx.dom.nesting.inspection.name=無效的 DOM 元素嵌套
jsx.html.context.type=JSX HTML
jsx.missing.namespace.inspection.name=缺少 JSX 命名空間
jsx.missing.namespace.inspection.text=在未匯入 {0} 的情況下使用 JSX
jsx.syntax.used.description=已使用 JSX 語法
jsx.syntax.used.name=已使用 JSX 語法
jsx.unresolved.component.name=未解析的 JSX 組件
label.choose.main.file=選擇主檔案
label.choose.output.directory=選擇輸出目錄
label.compiles.js.files=編譯 .js 檔案
label.compress.js.files=壓縮 .js 檔案
label.exclude.methods.classes=排除類別方法:
label.import.popup=自動匯入工具提示
label.method.should.be.defined=方法應已定義
label.minimum.language.level=最低語言級別:
label.name=名稱: 
label.name.injection=名稱(&N):
label.namespace=命名空間:
label.path=路徑(&P):
label.type=類型: 
label.wsl.node.interpreter=WSL Node.js 解釋器(&N):
linemarker.implemented=已實作
linemarker.implementing=實作
linemarker.implements.invalid=<無效>
linemarker.implements.several=實作多種接口方法
linemarker.implements.text=實作 {1} 中的 {0}
linemarker.javascript.sources=JavaScript 源
linemarker.javascript.typescript=JavaScript/TypeScript 行標記
linemarker.overridden=覆寫
linemarker.overrides.text=覆寫 {1} 中的 {0}
linemarker.overriding=覆寫
linemarker.typescript.declaration=TypeScript 宣告
list.item.class.field=類別欄位
list.item.declarations.function.members.to.be.converted.to.class.members=要轉換為類別成員的函式成員的宣告
list.item.declarations.that.were.not.converted=未轉換的宣告
list.item.function.converted.to.class=轉換為類別的函式
list.item.function.to.be.converted.to.class=要轉換為類別的函式
list.item.global.or.module.constant=全域或模組常數
list.item.google.javascript.style.guide=Google JavaScript 樣式指南
list.item.javascript.file=JavaScript 檔案
list.item.javascript.standard.style=JavaScript 標準樣式
list.item.local.constant=區域常數
list.item.typescript.file=TypeScript 檔案
list.item.typescript.jsx.file=TypeScript JSX 檔案
livetemplate.description.arf=使用箭頭函式包圍
livetemplate.description.console.assert=console.assert()
livetemplate.description.console.error=console.error()
livetemplate.description.console.info=console.info()
livetemplate.description.console.log=console.log()
livetemplate.description.console.trace=console.trace()
livetemplate.description.console.warn=console.warn()
livetemplate.description.defi=插入 define() 表達式
livetemplate.description.exportall=匯出語句 - 從 'a' 匯出 *
livetemplate.description.exportfrom=匯出語句 - 從 ''a'' 匯出 {b} 
livetemplate.description.exportitems=匯出語句 - export {b}
livetemplate.description.flow=插入 @flow 註解
livetemplate.description.fori=建立迭代迴圈
livetemplate.description.importdefault=import 語句 - 從 'a' 匯入 b
livetemplate.description.importfrom=import 語句 - 從 ''a'' 匯入 {b}
livetemplate.description.importns=import 語句 - 從 'a' 匯入 * as b
livetemplate.description.itar=遍歷陣列元素
livetemplate.description.iter=迭代 (for..of)
livetemplate.description.itera=迭代 (for await..of)
livetemplate.description.itin=迭代(for..in)
livetemplate.description.moduleexports=匯出語句 - module.exports = a
livetemplate.description.ref=插入參照路徑註釋
livetemplate.description.ritar=以相反順序遍歷陣列的元素
livetemplate.description.us=插入 'use strict' 語句
lsp.executable.error=找不到 {0} 的可執行檔案。
lsp.interpreter.error=未組態本地或 WSL Node.js 解釋器。
macro.js.component.type.of=jsComponentTypeOf(Array)
macro.js.suggest.default.variable.kind=jsSuggestDefaultVariableKind(Boolean)
make.method.static=設為 'static'
make.private=設為 private
members.to.implement.chooser.title=選擇要實作的成員
members.to.override.chooser.title=選擇要覆寫的成員
merged.process.output.text={0}{2, choice, 0#\\n\\
\\n\\
標準錯誤:\\n\\
{1}|1#}{4, choice, 0#\\n\\
\\n\\
標準輸出:\\n\\
{3}|1#}\\n\\
\\n\\
{5}
method.return.types.in.call.chains=呼叫鏈中的函式返回值類型
modules.selected=選定
move.members.dialog.title=移動成員
move.members.refactoring.name=移動成員
multiple.inheritance=多重繼承
new.actionscript.class.dialog.title=新增 ActionScript 類別
new.actionscript.interface.dialog.title=新增 ActionScript 接口
new.constructor.action.description=建立建構函式
new.constructor.action.text=建構函式
new.field.action.description=在類別中建立新字段
new.field.action.text=欄位
new.method.action.description=在類別中建立新方法
new.method.action.text=方法
no.candidates=無候選項
no.executable.found.in.path=在 {0, choice, 0#%PATH%|1#$PATH} 中未找到可執行檔案
no.members.to.implement=找不到要實作的成員
no.members.to.override=找不到要覆寫的成員
no.methods.to.implement=找不到要實作的方法
no.methods.to.override=找不到要覆寫的方法
no.variables.for.getter=找不到沒有 getter 的欄位
no.variables.for.getter.setter=找不到沒有 getter 和 setter 的欄位
no.variables.for.setter=找不到沒有 setter 的欄位
node.core.core_modules_fetch_timed_out.dialog.message=無法提取核心模組: 已超時
node.core.enable_coding_assistance_intention.name=啟用 Node.js 的編碼輔助
node.core.failed_to_fetch_node_core_modules.dialog.message=無法提取 Node 核心模組
node.core.make.sure.javascript.debugger.plugin.enabled.dialog.message=確保已啟用 'JavaScript Debugger' 延伸模組
node.core.navigate_action_text.text=組態 Node.js…
node.core.not_ready_for_core_modules_configuration.dialog.message=未準備好進行核心模組組態
node.debug.cannot_connect_to_vm.error.message=無法連線到虛擬機 {0}
node.debug.cannot_get_localhost_IPv4.error.message=無法獲取 127.0.0.1 IPv4
node.execution.failed.to.prepare.target.environment.error=無法準備環境: {0}
node.execution.starting.process.progress.title=正在啟動 ''{0}''…
node.interpreter.command_timed_out.dialog.message=''{0}'' 指令執行超時(>{1} 毫秒)
node.interpreter.download=下載 Node.js
node.interpreter.field.add.item.text=新增…
node.interpreter.field.unexpected_value.text=意外值 {0}
node.interpreter.invalid_interpreter.error.message=無效 ''{0}''
node.interpreter.label=Node 解釋器(&I):
node.interpreter.no_local_interpreter.error.message=沒有本地 Node.js 解釋器
node.interpreter.node_from_path.reference.name=node
node.interpreter.not.found=找不到 {0}
node.interpreter.project_node.reference.name=專案
node.interpreter.reference_not_found.text=未找到
node.interpreter.specified_interpreter_correctly.dialog.message=正確指定 Node.js 解釋器
node.interpreter.unavailable.target=不可用的目標: {0}
node.interpreter.unresolved_reference.error.message=未解析的解釋器 ''{0}''
node.interpreter.unspecified.error.text=指定 Node.js 解釋器
node.interpreter.unspecified_interpreter.dialog.message=指定 Node.js 解釋器
node.interpreter.unspecified_local_interpreter.dialog.message=指定本地 Node.js 解釋器
node.js.add.interpreter.action=新增{0}…
node.js.configure.interpreter=組態{0}
node.js.downloading=正在下載 Node.js {0}
node.js.inspection.group.name=Node.js
node.js.interpreters=Node.js 解釋器
node.js.invalid.node=該專案使用了無效的 Node.js 路徑。<br>它已更新為使用 {0} 中的 Node.js。
node.js.missing.require=缺少 require() 語句
node.js.quickfix.install.node.module.devDependencies.family.name=安裝模組作為開發相依關係
node.js.quickfix.install.node.module.error.no.interpreter.text=無法安裝 Node.js 模組: 請指定預設 Node.js 解釋器。
node.js.quickfix.install.node.module.error.no.interpreter.title=安裝 Node.js 模組
node.js.quickfix.install.node.module.error.prefix.text=無法安裝 Node.js 模組: {0}
node.js.quickfix.install.node.module.family.name=安裝模組
node.js.quickfix.install.node.module.text=安裝 ''{0}''
node.js.quickfix.install.node.module.update.modules.family.name=執行 'npm install'
node.js.quickfix.install.node.module.with.dev.dependencies.text=安裝 ''{0}'' 作為開發相依關係
node.js.quickfix.run.command=執行 ''{0}''
node.js.remote.interpreters.plugin.missing=缺少 Node.js 遠端解釋器延伸模組。請啟用 {0} 中的延伸模組
node.js.select.file=選擇 {0} 檔案
node.js.set.project.interpreter.action=設定為專案解釋器
node.js.unresolved.api=未解析的 Node.js API
node.no.interpreter=無解釋器
node.npm.cannot_find_package_by_reference.dialog.message=找不到軟體套件管理器 ''{0}''
node.npm.cannot_find_project_package_manager.dialog.message=找不到專案 Node.js 軟體套件管理器
node.npm.cannot_resolve_package_manager.dialog.message=無法解析 ''{0}'' 軟體套件管理器
node.npm.correct_path_to_npm_or_yarn_package.dialog.message=指定 npm 或 yarn 軟體套件的正確路徑: 無此類別目錄“{0}”
node.npm.invalid_package_manager.binary_file_not_found.dialog.message=指定有效的軟體套件管理器: 在 ''{0}'' 目錄內部找不到二進制檔案
node.npm.package_manager_link.text=軟體套件管理器
node.npm.project_package_manager_disallowed_here.dialog.message=無法在此處參照專案 npm 軟體套件
node.npm.specify_npm_or_yarn_package.dialog.message=指定 npm 或 yarn 軟體套件
node.npm.unspecified_package_manager.dialog.message=未指定軟體套件管理器
node.package.binary.file.hint=指向 {0} 的二進制檔案的路徑
node.package.cannot.find.bin.file.dialog.message=找不到 ''{0}'' 軟體套件的 bin 檔案
node.package.dropDownList.select=選擇…
node.package.empty.error.message=專案名稱為空
node.package.empty.hint={0} 軟體套件目錄路徑
node.package.empty.hint.pkg1.or.pkg2={0} 或 {1}
node.package.field.not_found.text=未找到
node.package.manager.label=軟體套件管理器 (&M):
node.package.name.URL-friendly.characters.error.message=專案目錄名稱應僅包含適用於 URL 的字元
node.package.name.capital.letters.error.message=專案目錄名稱不應包含大寫字母
node.package.name.core.module.error.message=''{0}'' 不能用作專案名稱，因為它是 Node.js 核心模組的名稱
node.package.name.forbidden.error.message=''{0}'' 不能用作專案名稱
node.package.name.leading.or.trailing.spaces.error.message=專案目錄名稱不應包含前導空格或尾隨空格
node.package.name.period.error.message=專案目錄名稱不應以句點開頭
node.package.name.special.characters.error.message=專案目錄名稱不應包含特殊字元("~'!()*")
node.package.name.too.long.error.message=專案目錄名稱不應超過 214 個字元
node.package.name.underscore.error.message=專案目錄名稱不應以下劃線開頭
node.package.none=無軟體套件
node.package.selector.multiple.packages.binary.file.title=選擇 {0} 的軟體套件目錄或二進制檔案
node.package.selector.multiple.packages.description=選擇 {0}
node.package.selector.multiple.packages.title=選擇軟體套件目錄
node.package.selector.single.package.title=選擇 {0} 軟體套件目錄
node.package_documentation.installed_version.text=已安裝版本: {0}
node.package_documentation.latest_version.text=最新版本: {0}
node.packages.cannot_find_working_directory.text=無法確定 {0} 的工作目錄: {1}
node.wsl.network.connection.failure=無法建立從 WSL 到 Windows 主機的網絡連線(可能被防火牆阻止)。\\n\\
要了解詳細資訊，請參閱: https://jb.gg/wsl-firewall
node.wsl.unavailable.dialog.message=WSL 不可用
non.ascii.identifiers.inspection.name=包含非 ASCII 符號的關鍵字
non.ascii.identifiers.mixed.set=<html>名稱同時包含 ASCII 和非 ASCII 符號: {0}</html>
non.ascii.identifiers.non.ascii.found=<html>名稱包含非 ASCII 符號: {0}</html>
non.ascii.identifiers.only.ascii=僅允許 ASCII 名稱
non.parenthesized.single.parameter=未使用括號括起來的單個參數
non.parenthesized.single.parameter.description=未使用括號括起來的單個參數
not.installed.package=未安裝軟體套件
notification.content.html.href.settings.show.inspection.settings.or.href.undo.undo.html=<html><a href='settings'>顯示檢查設定</a>或<a href='undo'>撤消</a></html>
notification.content.notifications.are.enabled.for.all.package.json.files=為所有 package.json 檔案啟用通知
notification.content.notifications.are.enabled.for.current.package.json=為當前 package.json 啟用通知
notification.content.show.details=顯示詳細資訊
notification.group.code.vision.performance.watcher=JavaScript: Code Vision 性能觀察程序
notification.group.grunt.console=Grunt 'watch' 任務狀態已更改
notification.group.jest=Jest 測試執行失敗
notification.group.linters=JavaScript linter
notification.group.narrowed.types=JavaScript: 已停用限縮的類型的著色
notification.group.nodejs.assistance=Node.js 編碼輔助失敗
notification.group.nodejs.interpreter=Node.js 解釋器路徑已更新
notification.group.package.json=來自 package.json 的相依項可用
notification.group.package.json.disabled=來自 package.json 的相依項: 通知已停用
notification.group.project.generator=JavaScript 專案生成失敗
notification.group.vitest=Vitest 測試執行失敗
notification.title.cannot.download.types.node=無法下載 @types/node
notification.title.cannot.enable.node.js.coding.assistance=無法啟用 Node.js 編碼輔助
notification.title.cannot.generate=無法生成 {0}
notification.title.coloring.types.narrowed.by.type.guard.was.disabled=按類型防護限縮類型著色被停用
notify.urls.more=… 和其他 {0,number} 個
npm.before.run.task=執行 npm 腳本
npm.before.run.task.descr=執行 npm {0, choice, 0#腳本|1#腳本|2#腳本}{1} [{2}]
npm.dialog.message.cannot.resolve.package.manager=無法解析 ''{0}'' 軟體套件管理器
npm.downloading_package=正在下載 {0}…
npm.failed_to_install_package.title.message=無法安裝 {0}
npm.modules.inspection.content.of.require.module.not.installed.warning=未安裝模組
npm.modules.inspection.content.of.require.not.in.dependencies.warning=package.json 相依關係中未列出模組
npm.modules.install.global.types.dialog.title=安裝 TypeScript 定義
npm.modules.install.global.types.directory.error=無法建立所需的目錄
npm.modules.install.global.types.fix.name=安裝 TypeScript 定義以提供更好的類型資訊
npm.no.scripts.found=未找到腳本
npm.rc.command.label=指令:(&C)
npm.rc.environmentVariables.label=環境:
npm.rc.nodeInterpreter.label=Node 解釋器(&I):
npm.rc.nodeOptions.label=Node 選項:
npm.rc.packageJson.browseDialogTitle=選擇 package.json 檔案
npm.rc.packageJson.label=package.json(&P):
npm.rc.scripts.label=腳本 (&T):
npm.rc.scriptsArguments.label=實參(&R):
npm.task.title=NPM 腳本
numeric.enum.values=數值枚舉值
package.description=軟體套件 {0}
package.json.install.types.fix.family.name=為軟體套件安裝 @types
package.version.range.hint={0, choice, 0#允許|1#允許次要更新:|2#允許補丁更新} {1} ≤ 版本 \\\\&lt; {2}
package.version.range.info={0, choice, 0#未安裝|1#已安裝: ?|2#已安裝: {1}}，最新: {2, choice, 0#正在載入…|1#未找到|2#{3}}
package_json.install_dependencies.notification.content=來自 {0}
package_json.install_dependencies.notification.title=安裝相依項
package_json.install_dependencies_multiple.notification.content=來自 {0} 和其他 {1} 個
package_json.notifications_are_disabled.notification.content=已停用從 {0} 安裝相依項的通知。<p>使用“{1}”動作重新啟用通知。
package_json.update_dependencies.notification.title=更新相依項
parameter.type.is.not.specified=參數 ''{0}'' 的類型未指定。\\n\\
是否繼續?
parameters.in.parentheses=圓括號中的參數
parameters.in.parentheses.description=圓括號中的參數
please.specify.package.manager=指定<a href="">軟體套件管理器</a>。
popup.advertisement.latest.available.versions.for.all.distribution.tags=所有發行版標籤的最新可用版本
popup.advertisement.start.typing.package.name=開始輸入軟體套件名稱，以從 npm 官方公共註冊表中獲取更具體的結果
popup.content.cannot.edit.selected.node.js.interpreter=無法編輯選定的 Node.js 解釋器
popup.title.choose.class=選擇類別
popup.title.select.destructuring.assignment.target=選擇解構賦值目標
popup.title.target.function=目標函式
postfix.template.condition.array.name=陣列
postfix.template.condition.non.void.name=非 Void
postfix.template.provider.name=JavaScript 和 TypeScript
process.terminated=程序已終止
progress.subtitle.install=正在通過 {1} 安裝 {0}…
progress.text.initializing.opened.files=正在初始化開啟的檔案
progress.text.modifying=正在修改 {0}
progress.text.processing=正在處理 {0}{1}
progress.title.compiling.typescript.files=正在編譯 TypeScript 檔案
progress.title.configuring.node.js.coding.assistance=正在組態 Node.js 編碼輔助…
progress.title.detect.overridden.methods=檢查覆寫方法
progress.title.downloading.documentation=正在下載文檔
progress.title.downloading.library=正在下載庫
progress.title.downloading.typings=正在下載 typings
progress.title.executing.performance.task.on.files=正在檔案上執行性能任務
progress.title.install=安裝 {0}
progress.title.install.npm.module=安裝 npm 模組 ''{0}''
project.generation=生成專案
protractor.rc.configurationFile.label=組態檔案(&C):
protractor.rc.configurationFile.title=選擇 Protractor 組態檔案
protractor.rc.protractorOptions.emptyText=CLI 選項，例如 --browser 或 --rootElement
protractor.rc.protractorOptions.label=Protractor 選項 (&O):
protractor.rc.protractorPackage.label=Protractor 軟體套件(&P):
radio.set.options.manually=手動設定選項
radio.use.tsconfig.json=使用 tsconfig.json
rc.environmentVariables.label=環境變數(&E):
rc.nodeOptions.label=Node 選項 (&O):
rc.testConfig.presentable.name={0} 中的所有測試
rc.testDirectory.presentable.name={0} 中的測試
rc.testOrSuiteScope.emptyTest=空測試名稱
rc.testOrSuiteScope.suite.label=套件名稱:
rc.testOrSuiteScope.suite.title=編輯套件名稱
rc.testOrSuiteScope.test.label=測試名稱:
rc.testOrSuiteScope.test.title=編輯測試名稱
rc.testRunScope.all=所有測試(&L)
rc.testRunScope.directory=目錄(&D)
rc.testRunScope.suite=套件
rc.testRunScope.test=測試(&T)
rc.testRunScope.testDirectory.browseTitle=選擇測試目錄
rc.testRunScope.testDirectory.label=測試目錄:
rc.testRunScope.testFile=測試檔案(&F)
rc.testRunScope.testFile.browseTitle=選擇測試檔案
rc.testRunScope.testFile.label=測試檔案:
rc.workingDirectory.browseDialogTitle=選擇工作目錄
rc.workingDirectory.label=工作目錄(&W):
react.class.component.type.class=類別
react.class.component.type.function=函式
react.class.to.function.caret.at.class=文字游標應置於要轉換的類別處
react.function.to.class.caret.at.function=文字游標應置於要轉換的函式處
recursive.call=遞迴呼叫
refactoring.create.react.component.title=建立組件
refactoring.destructuring.vars.for.refactor.this=物件或陣列解構…
refactoring.destructuring.vars.intention.const.to.var.warning=在轉換期間，醒目提示顯示的 const 變數將轉換為 let 變數。\\n\\
是否要繼續?
refactoring.destructuring.vars.intention.const.to.var.warning.title=變數關鍵字更改
refactoring.destructuring.vars.intention.deconstruct=生成解構模式
refactoring.destructuring.vars.intention.depropagate=將解構取代為屬性和索引存取
refactoring.destructuring.vars.intention.guard.conflict=通過類型防護將表達式類型限縮為 ''{0}''，該類型防護在重構後將不起作用
refactoring.destructuring.vars.intention.name=引入物件或陣列解構
refactoring.destructuring.vars.intention.name.array=引入陣列解構
refactoring.destructuring.vars.intention.name.object=引入物件解構
refactoring.destructuring.vars.intention.propagate=傳播到解構宣告
refactoring.destructuring.vars.intention.replace.array=取代為數組解構
refactoring.destructuring.vars.intention.replace.object=取代為物件解構
refactoring.destructuring.vars.intention.replace.promise=取代為 'await Promise.all'
refactoring.destructuring.vars.intention.replace.shorthand=取代為解構和速記屬性
refactoring.extract.react.component.component.for.refactor.this=提取組件…
refactoring.extract.react.component.no.expression=所選內容不構成 JSX 表達式
refactoring.extract.react.component.no.scope=找不到用於放置所建立組件的作用域
refactoring.extract.react.component.title=提取組件
refactoring.react.class.to.function.conflict.used.with.ref={0} 與 ''ref'' 特性結合使用。無法為無狀態函式組件提供 ref
refactoring.react.class.to.function.intention.title=轉換為函式組件
refactoring.react.class.to.function.refactoring.title=轉換為函式組件
refactoring.react.could.not.find.in.template=無法重構。找不到名稱為 {0} 的元素。可能的程式碼模板 {1} 無效嗎?
refactoring.react.function.to.class.intention.title=轉換為類別組件
refactoring.react.function.to.class.refactoring.title=轉換為類別組件
refactoring.react.function.to.class.used.in.call.conflict=呼叫表達式中使用了 {0}
refactoring.react.function.to.class.used.in.new.conflict=\\ ''new'' 表達式中使用了 {0}
reg.exp.tagged.template=''{1}'' 標記模板中的 {0}
remove.type.prefix=移除類型前綴
remove.unnecessary.parentheses.fix.text=移除不必要的圓括號
rename.accessors.dialog.text=是否將屬性存取器也重命名為 ''{0}''?
rename.accessors.dialog.title=重新命名欄位
rename.destructuring.property.description=解構屬性參照多個成員。應重新命名相關屬性，否則可能導致程式碼不一致。
rename.destructuring.property.title=重新命名解構屬性
rename.prompt.do.you.want.to.rename.base.method=是否要重新命名基方法?
rename.react.hook.variable.description=將相關狀態變數重命名為:
rename.react.hook.variable.title=重新命名狀態變數
rename.type.members.destructuring.description=檢測到解構屬性中的用法。應重新命名相關屬性，否則可能導致程式碼不一致。
rename.type.members.title=重新命名類型成員
rename.type.members.union.intersection.mapped.description=檢測到聯合、相交或映射類型用法。應重新命名相關屬性，否則可能導致程式碼不一致。
replace.implements.keyword.fix.name=將 'implements' 更改為 'extends'
required.parameters.are.not.permitted.after.optional.parameters=必選參數不能位於可選參數後
return.type.is.not.resolved=返回值類型 ''{0}'' 未解析。\\n\\
是否繼續?
separator.deprecated.settings=棄用的設定
service.configurable.default={0} (預設)
settings.code.style.Trailing.comma=尾隨逗號(&T):
settings.code.style.always=始終
settings.code.style.dont.use=不使用
settings.code.style.double=雙
settings.code.style.in.new.code=在 IDE 生成的程式碼中
settings.code.style.indent.all.chained.calls.in.a.group=縮排組中的所有鏈式呼叫
settings.code.style.indent.chained.methods=縮排鏈式方法
settings.code.style.option.use=使用
settings.code.style.quotes=引號(&Q)
settings.code.style.semicolon.to.terminate.statements=分號(&S)
settings.code.style.single=單
settings.code.style.use=使用
settings.javascript.bower.configurable.name=Bower
settings.javascript.field.names.completion=為類別欄位建議名稱 (&F)
settings.javascript.lang.templates.configurable.name=模板
settings.javascript.linters.autodetect.configure.automatically=自動 {0} 組態 (&A)
settings.javascript.linters.autodetect.configure.automatically.help.text={0} 將使用 node_modules 目錄中的 {1} 軟體套件，還會使用與當前檔案或其任何父目錄位於同一目錄中的 {2} 組態檔案。
settings.javascript.linters.autodetect.configure.manually=手動 {0} 組態 (&M)
settings.javascript.linters.autodetect.disabled=停用 {0}(&D)
settings.javascript.linters.configurable.name=程式碼品質工具
settings.javascript.linters.eslint.configurable.name=ESLint
settings.javascript.linters.jshint.configurable.name=JSHint
settings.javascript.only.type.based.completion=僅基於類型補全 (&C)
settings.javascript.only.type.based.completion.tooltip=根據類型資訊顯示較少的補全建議。可能會顯著提高性能。
settings.javascript.opt.chain.completion=為可 null 類型建議包含可選鏈接的條目(&O)
settings.javascript.overrides.completion=在覆寫補全中展開方法體
settings.javascript.root.configurable.name=JavaScript
settings.javascript.var.names.completion=建議變數和參數名稱(&V)
settings.javascript.var.names.completion.desc=補全名稱
settings.javascript.var.names.completion.names.only=無類型
settings.javascript.var.names.completion.types=為建議的參數名稱新增類型註解(&T)
settings.javascript.var.names.completion.types.everywhere=隨處都是類型
settings.javascript.var.names.completion.types.except.fields=隨處都是類型，欄位除外
settings.javascript.var.names.completion.types.for.params=具有函式參數的類型
settings.javascript.var.names.completion.types.for.params.fields=具有參數和欄位的類型
settings.nodejs.coding.assistance.label=Node.js 編碼協助 (&A):
settings.nodejs.coding.assistance.manage.scopes.label=管理作用域…
settings.nodejs.name=Node.js
settings.typescript.root.configurable.name=TypeScript
space.after.dots.in.rest.spread=在 rest/spread 中的 '...' 後面
space.after.generator.mult=在產生器中的 '*' 後面 
space.after.name.value.separator=在屬性名稱-值分隔符 ':' 後面
space.after.type.colon=在類型參照冒號 ':' 後面
space.before.class.interface.module.lbrace=類別/接口/模組左大括號
space.before.class.lbrace=類別的左大括號
space.before.function.left.parenth=在函式表達式中
space.before.generator.mult=在產生器中的 '*' 前面 
space.before.name.value.separator=在屬性名稱-值分隔符 ':' 前面
space.before.type.colon=在類型參照冒號 ':' 前面
spaces.after.unary.not=在 'not' (!) 和 '!!' 後面
spaces.arrow.function=箭頭函式(=>)
spaces.async.arrow.function=在異步箭頭函式中
spaces.before.unary.not=在 'not' (!) 和 '!!' 前面
spaces.within.array.initializer=陣列中括號
spaces.within.import.braces=ES6 匯入/匯出大括號
spaces.within.indexer.brackets=索引存取中括號
spaces.within.interpolation.expressions=插值表達式
spaces.within.object.literal.braces=物件文字大括號
spaces.within.object.type.braces=物件文字類型大括號
spaces.within.type.assertion=類型斷言
spaces.within.unary.additive=一元加法運算符 (+,-,++,--)
spaces.within.union.and.intersection=聯合和相交類型
standardjs.action.fix.problems.description=修正標準程式碼樣式問題
standardjs.codestyle.updated={0}: 專案程式碼樣式設定已更新
standardjs.codestyle.updated.config.section={0}: 專案程式碼樣式設定已根據 package.json 中的 ''standard'' 部分更新
standardjs.codestyle.updated.dependency={0}: 專案程式碼樣式設定已根據 package.json 中的 ''standard'' 相依項更新
standardjs.edit.settings.caption=ESlint/標準程式碼樣式
standardjs.editor.notification.action=是
standardjs.editor.notification.can.be.enabled.text=為此專案使用 JavaScript 標準程式碼樣式?
standardjs.editor.notification.do.not.show.text=否
standardjs.error.unsupported.package=不支持的軟體套件版本。請將 ''Standard'' 軟體套件升級到最低版本 {0}。
standardjs.name=標準程式碼樣式
start.template.string.interpolation.on.typing=鍵入 '$' 時啟動模板字串內插
status.text.add.interpreter.with=使用 {0} 新增解釋器
status.text.javascript.language.service.default.project.errors=顯示專案錯誤
status.text.no.errors.in.current.file=當前檔案中沒有錯誤。
status.text.no.interpreters.added=未新增解釋器
status.text.project.structure.isn.t.available=專案結構不可用
status.text.refresh.required=需要重新整理
status.text.running.which.node=正在執行 \`which node\`…
status.text.service.doesn.t.contain.open.projects=服務不包含開放專案
structural.search.anonymous.functions=匿名函式
structural.search.classes=類別
structural.search.comparison.to.self=與自身比較
structural.search.console.log.calls=呼叫 console.log()
structural.search.constants=常數
structural.search.empty.functions=空函式
structural.search.function.calls=函式呼叫
structural.search.functions=函式
structural.search.functions.with.boolean.parameters=使用布爾參數的函式
structural.search.var.statements=Var 語句
structural.search.variables=變數
structural.search.while.loops=While 迴圈
structural.search.with.statements=With 語句
stylelint.action.background.title=正在執行 stylelint --fix…
stylelint.action.fix.problems.description=通過呼叫 'stylelint --fix' 修正 Stylelint 問題
stylelint.action.modal.title=Stylelint 修正
successfully.downloaded=已成功下載
superclass.cannot.be.extracted.from.enum=無法從枚舉中提取超類別
superclass.cannot.be.extracted.from.mxml.component=無法從 MXML 組件中提取超類別。
superclass.cannot.be.extracted.from.type.alias=無法從類型別名中提取超類別
superclass.label.text=超類別(&S):
tab.title.compile.errors=編譯錯誤
tab.title.convert.to.class=轉換為類別
tab.title.errors=錯誤
tab.title.project.errors=專案錯誤
tab.title.refactoring.preview=重構預覽
tab.title.refactoring.result=重構結果
template.add.imports=新增明確的匯入
terminal.add_node_modules_bin_to_path.label=將 ''node_modules/.bin'' 從專案根目錄新增到 {0}
testing.select.in.test.tree.name=在測試樹中選擇 ''{0}''
testing.snapshot.update.all.tests.text=<link>點擊以更新所有失敗的快照</link>
testing.snapshot.update.single.test.text=<link>點擊以更新 ''{0}'' 的快照</link>
testing.snapshot.update.test.file.text=<link>點擊以更新 {0} 中所有失敗的快照</link>
text.cannot.download=無法下載 {0}。{1}
text.html.front.end.template.a.href.http.html5boilerplate.com=<html>前端模板<a href='http://html5boilerplate.com'>http://html5boilerplate.com</a></html>
text.html.sleek.intuitive.and.powerful.front.end.framework=<html>整潔、直觀、強大的前端框架，更快、更輕鬆地進行 Web 開發 <a href='http://getbootstrap.com'>http://getbootstrap.com</a></html>
titled.separator.predefined=預定義
top.level.package=頂層軟體套件
ts.add.import.all.family.name=新增所有 import
ts.add.import.hint.all.part=或全部使用 {0} 匯入
ts.add.import.hint.multiple.text=使用  {1} 為 {0} 新增匯入
ts.add.import.hint.text=使用 {1} 新增 {0}
ts.add.import.statement.dialog.title=新增 import 語句
ts.change.import.action.command=更改匯入
ts.change.import.action.dialog.title=匯入自…
ts.change.import.action.family.name=更改 ES6 匯入路徑
ts.change.import.action.many.title=更改匯入…
ts.change.import.action.one.title=更改為 {0}
ts.convert.alias.to.enum.action.family.name=將類型別名轉換為枚舉
ts.convert.alias.to.enum.action.title=將別名轉換為枚舉
ts.convert.alias.to.interface.action.family.name=將類型別名轉換為接口
ts.convert.alias.to.interface.action.title=將別名轉換為接口
ts.convert.field.to.parameter.property=將欄位轉換為參數屬性
ts.convert.parameter.property.to.field=將參數屬性轉換為欄位
ts.generate.reference.path.name=生成參照路徑註釋
ts.switch.to.jsx.inspection.name=更改檔案擴展名為 .tsx
ts.unresolved.variable.inspection.name=未解析的 TypeScript 參照
tsx.missing.name.quick.fix.name="新增 {0} import 語句
type.annotations=類型註解
type.is.not.resolved=類型 ''{0}'' 未解析。\\n\\
是否繼續?
typescipt.import.options.paths.help=此選項用於組態 import 語句中使用的路徑樣式。<br><br>選擇“始終”時，IDE 會始終使用來自 tsconfig.json 組態的別名。<br><br>選擇“僅在指定路徑之外的檔案中”時，IDE 會針對為之定義了別名的檔案之間的匯入使用相對路徑。在所有其他檔案中使用路徑映射。<br><br>選擇“從不”時，則從不使用別名。
typescript.abstract.class.constructor.can.be.made.protected=抽象類別建構函式可以設為 protected
typescript.auto.import.options.add.imports=自動新增 TypeScript import
typescript.before.task.check.errors=檢查錯誤
typescript.before.task.config.dialog.title=選擇 tsconfig.json
typescript.before.task.config.path=組態檔案:
typescript.before.task.title=TypeScript 編譯設定
typescript.code.style.tab.name=TypeScript
typescript.compiler.action.compile.all=全部編譯
typescript.compiler.action.compile.all.compile.config=組態 {0} 的編譯檔案
typescript.compiler.action.compile.all.description=編譯所有專案檔案
typescript.compiler.action.compile.current=編譯當前檔案
typescript.compiler.action.compile.description=編譯當前專案
typescript.compiler.action.compile.simple=編譯 TypeScript
typescript.compiler.action.compile.toolbar=編譯
typescript.compiler.action.no.compile.message=檔案未編譯，因為沒有從主檔案參照
typescript.compiler.before.run=編譯 TypeScript
typescript.compiler.configurable.name=TypeScript
typescript.compiler.configurable.options.command.line=選項:
typescript.compiler.configurable.options.command.line.localeNotSupportedForBundled=捆綁的 TypeScript 不支持區域設定
typescript.compiler.configurable.options.compile.main=僅編譯主檔案:
typescript.compiler.configurable.options.compile.main.error=主檔案的路徑不正確
typescript.compiler.configurable.options.enable.no.config=也針對沒有 tsconfig.json 的專案
typescript.compiler.configurable.options.generate.source.map=生成源映射
typescript.compiler.configurable.options.output.path=使用輸出路徑:
typescript.compiler.configurable.options.scope=編譯作用域:
typescript.compiler.configurable.options.track.file.system=在更改時重新編譯
typescript.compiler.configurable.options.version=TypeScript:
typescript.compiler.configurable.options.version.bundled=已捆綁
typescript.compiler.notification.editor.configure=組態 TypeScript…
typescript.compiler.starting=TypeScript 正在啟動…
typescript.compiler.structure.tab.title=結構
typescript.config.inspection=不一致的 Tsconfig.json 屬性
typescript.config.inspection.checkjs.info=屬性 checkJs 需要 allowJs 屬性
typescript.config.inspection.config.options.fix=向 tsconfig.json 中新增 ''{0}''
typescript.config.inspection.fix.pattern=新增 ''{0}'' 屬性
typescript.config.inspection.libs=缺少全域類別庫
typescript.config.inspection.libs.fix=在 tsconfig.json 中啟用庫 ''{0}''
typescript.config.inspection.missing.option=缺少 tsconfig.json 選項 
typescript.duplicate.typescript.union.inspection.name=聯合或相交類型組件重複
typescript.enum.member.name=枚舉成員
typescript.enum.name=枚舉
typescript.explicit.member.type.inspection.name=顯式類型
typescript.export.assignment.cannot.be.used.in.internal.modules=匯出不能在內部模組中使用的賦值
typescript.extract.type.alias.name=類型別名…
typescript.field.can.be.made.readonly=可以為唯讀欄位
typescript.file=TypeScript 檔案
typescript.fix.change.member.access=設為 ''{0}''
typescript.generics.should.not.be=類型 ''{0}'' 非泛型
typescript.import.options.exts.help=此選項用於組態 import 語句中的副檔名。<br><br>選擇“自動”時，IDE 會始終向 vue 檔案、來自在 tsconfig.json 中具有 "module": "node16" 或 "module": "nodenext" 和在 package.json 中具有 "type": "module" 的專案的檔案，以及擴展名為 .mts 的檔案的名稱新增副檔名。<br><br>選擇“始終”時，IDE 會始終向 TypeScript 檔名新增 .js 副檔名。<br><br>選擇“從不”時，IDE 會始終使用不帶副檔名的檔名。
typescript.import.options.paths=使用 tsconfig.json 的路徑映射:
typescript.import.options.use.config=使用相對於 tsconfig.json 的路徑
typescript.include.js.sources.action=包括 JavaScript 檔案
typescript.include.js.sources.dialog.message=是否在此專案中包含 ''{0}'' 中的 JavaScript 檔案?
typescript.include.js.sources.dialog.title=包括軟體套件 {0}
typescript.include.js.sources.element=搜尋 JavaScript 宣告
typescript.insert.cast.fix=插入類型斷言
typescript.insert.type.guard.fix.family=插入類型防護
typescript.insert.type.guard.nc=將限定符取代為 ''{0}''
typescript.insert.type.guard.nc.self=取代為 ''{0}''
typescript.insert.type.guard.postfix=使用 ''{0}'' 進行可選查詢
typescript.insert.type.guard.prefix=前綴為 ''{0}''
typescript.insert.type.guard.surround=封閉在 ''{0}''中
typescript.inspection.group.name=TypeScript
typescript.intention.convert.import.require=將 import require 轉換為 import from
typescript.intention.convert.import.require.text=轉換為 {0}
typescript.language.service.clean=正在重設快取…
typescript.language.service.compile.file=正在編譯檔案… {0}
typescript.language.service.compile.file.errors=正在計算錯誤… {0}
typescript.language.service.compile.project=正在編譯專案… {0}
typescript.language.service.compile.project.errors=正在計算專案錯誤… {0}
typescript.language.service.compile.project.open.file=正在開啟檔案… {0}
typescript.language.service.name=TypeScript 服務
typescript.language.simple.name=TypeScript
typescript.make.constructor.protected=將建構函式設為 protected
typescript.make.field.readonly=將欄位設為唯讀
typescript.missing.augmentation.import=缺少擴大匯入
typescript.module.name=模組名稱
typescript.narrowed.to=範圍限縮至 ''{0}''
typescript.primitive.types.name=基元類型
typescript.private.field.modifiers.mix=使用不公開名稱的欄位不能具有 'public'、'private' 或 'protected' 存取修飾符
typescript.redundant.declaration=類型宣告與推斷的類型相符合，因此可以移除
typescript.redundant.instanceof.guard=''instanceof'' 檢查冗餘: ''{0}'' 具有類型 ''{1}'' 或 ''{1}'' 的子類型
typescript.redundant.instanceof.inheritor.guard=''instanceof'' 檢查冗餘: ''{0}'' 具有類型 ''{1}'' 或 ''{1}'' 的繼承者
typescript.redundant.typescript.type.argument.inspection.name=冗餘類型實參
typescript.reference.to.umd.global=已參照的 UMD 全域變數
typescript.remove.type.declaration=移除類型宣告
typescript.rename.dynamic.references=搜尋動態參照 (&D)
typescript.rename.javascript.references=在 JavaScript 檔案中搜尋(&J)
typescript.service.action.restart=重啟{0}
typescript.service.no.config=檔案未包括在任何 tsconfig.json 中
typescript.service.no.main.reference=檔案未處理，因為沒有從主檔案參照
typescript.smart.cast=範圍限縮的類型
typescript.smart.cast.hyperlink=設定字體和背景
typescript.specify.all.param.types.explicitly=顯式指定所有參數類型
typescript.specify.all.param.types.explicitly.from.hint=向所有參數中新增顯式類型註解
typescript.specify.type.explicitly=顯式指定類型
typescript.specify.type.explicitly.from.hint=新增顯式類型註解
typescript.suspicious.constructor.parameter.assignment=建構函式中的參數賦值可疑。您是否忘記了新增 'this.'?
typescript.suspicious.constructor.parameter.assignment.desc=已分配建構函式欄位參數
typescript.suspicious.instanceof.guard=''instanceof'' 檢查無效: ''{0}'' 的類型與 ''{1}'' 無關
typescript.type.alias.name=類型別名
typescript.type.guard.name=變數類型限縮為類型防護
typescript.type.guard.name.disable=停用範圍限縮的類型的著色
typescript.type.parameter=類型參數
typescript.type.predicate.destructuring=類型謂詞不能參照綁定模式中的元素。
typescript.type.predicate.incompatible.types=類型謂詞不可分配給 {0}
typescript.type.predicate.not.match.name=找不到參數 {0}
typescript.type.predicate.not.return=僅函式和方法的返回值類型位置允許類型謂詞
typescript.type.predicate.rest=類型謂詞不能參照 rest 參數
typescript.type.this.predicate.not.return=僅類別或接口成員、get 存取器或函式和方法的返回值類型位置允許基於 'this' 類型的謂詞。
typescript.types.intersection=相交
typescript.types.key=鍵參照
typescript.types.mapped=映射
typescript.types.merged=已合併
typescript.types.merged.accessor=合併存取器
typescript.types.merged.parts=參照的屬性:
typescript.types.module.not.installed.warning=無法解析模組 ''{0}'' 的定義
typescript.types.type.member={0} 類型屬性
typescript.types.union=聯合
typescript.use.service.configurable.options.enable=TypeScript 語言服務
typescript.validate.generic.types.fix.add=新增泛型實參
typescript.validate.generic.types.fix.delete=移除泛型實參
typescript.validate.generic.types.inspection.error.argument.number=泛型類型 ''{0}'' 需要 ''{1}'' 類型實參
typescript.validate.generic.types.inspection.error.argument.number.between=泛型類型 ''{0}'' 需要介於 {1} 和 {2} 之間的類型實參
typescript.validate.generic.types.inspection.error.not.empty.argument=類型實參列表不能為空
typescript.validate.generic.types.inspection.error.not.empty.parameter=類型參數列表不能為空
typescript.validate.generic.types.inspection.name=不正確的泛型實參
typescript.validate.optional.parameter.inspection.error=參數不能有問號和初始設定式
typescript.validate.optional.parameter.inspection.fix.question=移除問號
typescript.validate.template.literal.types=模板類型 {1} 不可分配給約束類型 {0}
typescript.validate.types.any.inspection.name='any' 類型的類型不符合
typescript.validation.async.incorrect.type.annotation=異步函式不能有 ''{0}'' 類型註解
typescript.validation.cannot.find.best.common.type=無法從用法推斷類型實參
typescript.validation.class.extend.constructor.return.not.class=基類別建構函式返回值類型 ''{0}'' 不是類別或接口類型。
typescript.validation.class.extend.cycled.definition=迴圈類別定義
typescript.validation.class.extend.many.constructors=基類別建構函式必須具有相同的返回值類型
typescript.validation.class.extend.no.type.arguments.type=沒有任何基類別建構函式具有指定數量的類型實參
typescript.validation.class.extend.not.constructor.type=類型 ''{0}'' 不是建構函式類型
typescript.validation.dissatisfies.type.annotation=類型 ''{0}'' 不滿足預期類型 ''{1}''
typescript.validation.expressionWithTypeArguments.compatibleSignatureNotFound=找不到相容的簽名
typescript.validation.generators.ambient=環境上下文中不允許使用產生器
typescript.validation.generators.async.no.yield=產生器隱式具有類型 'AsyncIterableIterator<any>'，因為它不產生任何值。請考慮提供返回值類型。
typescript.validation.generators.incorrect.type.annotation=發生器不能有 ''{0}'' 類型註解
typescript.validation.generators.incorrect.type.annotation.iterable=類型 ''{0}'' 不可分配給類型 ''{1}''。
typescript.validation.generators.no.yield=產生器隱式具有類型 'IterableIterator<any>'，因為它不產生任何值。請考慮提供返回值類型。
typescript.validation.generators.overload=多載簽名無法被宣告為產生器
typescript.validation.incorrect.rhs.in.private.brand=右側必須是一個物件，實際為: ''{0}''
typescript.validation.message.abstract.cannot.be.used=''{0}'' 修飾符不能與 ''abstract''修飾符一起使用
typescript.validation.message.abstract.cannot.have.body=方法不能具有實作，因為它被標記為 'abstract'
typescript.validation.message.abstract.class.be.created=無法建立抽象類別 ''{0}'' 的實例
typescript.validation.message.abstract.class.should.be=abstract 方法只能出現在抽象類別中
typescript.validation.message.abstract.member.access.super=無法通過 super 表達式存取 abstract 方法 ''{0}''。
typescript.validation.message.abstract.overload=多載簽名必須全部為 abstract 或非 abstract。
typescript.validation.message.constructor.cannot.be.abstract=建構函式不能為 'abstract'
typescript.validation.message.duplicate.modifier=已看到修飾符 {0}
typescript.validation.message.duplicate.modifier2=已看到可存取性修飾符
typescript.validation.message.function.implementation.missing=缺少函式實作或此宣告之後未緊隨函式實作
typescript.validation.message.getter.and.setter.must.have.same.access.type=Getter 和 setter 必須具有相同的存取類型
typescript.validation.message.invalid.modifier.cannot.be.here=修飾符 {0} 不能出現在此處
typescript.validation.message.invalid.module.member.modifier=''{0}'' 不是模組成員的有效修飾符
typescript.validation.message.misordered.in.modifier='in' 修飾符必須在 'out' 修飾符之前。
typescript.validation.message.unexpected.type.for.rest.parameter=Rest 參數必須為數組類型或具有陣列約束的泛型
typescript.validation.message.unexpected.type.for.rest.parameter.fix=取代為數組類型
typescript.validation.message.unique.symbol.mutable.non.static.field.declaration=類型為 'unique symbol' 類型的類別的屬性必須同時為 'static' 和 'readonly'
typescript.validation.message.unique.symbol.mutable.non.static.field.declaration.fix.add.static.readonly=新增 static 和 readonly 修飾符
typescript.validation.message.unique.symbol.mutable.property.signature=如果接口或類型文字的類型是 'unique symbol' 類型，則其屬性必須為 'readonly'
typescript.validation.message.unique.symbol.mutable.variable=類型為 'unique symbol' 類型的變數必須為 'const'
typescript.validation.message.unique.symbol.wrong.usage=此處不允許使用 'unique symbol' 類型
typescript.validation.module.reference.with.extension=外部模組參照不能以擴展結束
unnecessary.parentheses.display.name=不必要的圓括號
unnecessary.parentheses.problem.descriptor=<code>#ref</code> 周圍的圓括號不必要 #loc
unwrap.with.kind=解包 ''{0}…''
variables.and.fields=變數和欄位
variables.and.fields.description=變數和欄位
varible.name.column.title=名稱
varible.value.column.title=值
visibility.level.details=詳細資訊
visibility.level.overview=概覽
vitest.coverage.cannot.copy.lcov.info.notification.content=無法顯示 Vitest 覆蓋率: 無法複製檔案。
vitest.coverage.cannot.find.lcov.info.notification.content=無法顯示 Vitest 覆蓋率: 找不到 {0}。
vitest.coverage.directory.not.found.notification.content=無法從 Vitest 組態中讀取 coverageDirectory 選項
vitest.coverage.notification.title=Vitest 覆蓋率
vitest.coverage.presentable.text=Vitest 覆蓋率
vitest.rc.configurationFile.label=組態檔案(&C):
vitest.rc.configurationFile.title=選擇 Vitest 組態檔案
vitest.rc.vitestOptions.emptyText=CLI 選項，例如 --watch 或 --ui
vitest.rc.vitestOptions.label=Vitest 選項:
vitest.rc.vitestPackageField.label=Vitest 軟體套件(&V):
vitest.snapshot.update.rc.name=更新 {0} 的快照
web.bundler.analyzing.configs.progress=正在分析 Web 捆綁程序的組態檔案
web.bundler.cannot.analyze=無法分析 {0}: 編碼輔助將忽略此檔案中的模組解析規則。
web.bundler.error.details=錯誤詳細資訊: {0}
web.bundler.failed.to.load=無法載入 {0}
web.bundler.possible.reasons=可能的原因: 此檔案不是有效的組態檔案，或者 IDE 目前不支持其格式。
web.template.file-type.description={0} 模板
yarn.package_requires_yarn.dialog.message=軟體套件“{0}”要求 Yarn {1}。
yarn.pnp.library_name=來自 {0} 的相依項
yarn.pnp.requires.yarn.package_manager.dialog.message=Yarn PnP 需要 Yarn <a href="">軟體套件管理器</a>
{0}.visibility.will.break.methods.hierarchy=可見性為 {1} 的{0}無法參與層次結構"
`;

exports[`src messages/PhpBundle.properties 1`] = `
"0=\\ ({0})
0.1={0}，{1}
0.1.choice.0.extends.1.implements.2={0}{1, choice, 0# 擴展 |1# 執行 }{2}
0.12={0}:{1}
0.and.1.define.the.same.property.2=''{0}'' 和 ''{1}'' 定義相同的屬性 ''{2}''
0.by.remote.interpreter=通過遠端解釋器{0}
0.completion.shortcut=使用{1}進行{0}補全
0.extends.1={0} 擴展 {1}
0.for.1.run.configuration={1} 執行組態的 {0}
0.inspection={0} 檢查
0.local={0}本地
0.location={0} 位置
0.path={0} 路徑:
0.pushing.members.down.will.result.in.them.being.deleted={0}\\n\\
向下推送成員將導致它們被刪除
0.should.not.extend.itself={0} 不應自行擴展
0.with.same.name.already.defined.in.this.class=此類別中已經定義了具有相同名稱的{0}
02={0}::
03=({0})
04={0}:
12.hour.format.of.an.hour.with.leading.zeros=帶前導零的 12 小時格式小時(01 到 12)
12.hour.format.of.an.hour.without.leading.zeros=不帶前導零的 12 小時格式小時(1 到 12)
24.hour.format.of.an.hour.with.leading.zeros=帶前導零的 24 小時格式小時(00 到 23)
24.hour.format.of.an.hour.without.leading.zeros=不帶前導零的 24 小時格式小時(0 到 23)
>>>>>>> e3e71918c4cd1 (WI-68349 新檢查=關於使用永不返回函式結果的警告)
DBGPProxyConfigurable.display.name=DBGp 代理
DBGPProxyConfigurable.host=主機:
DBGPProxyConfigurable.ide.key=IDE 鍵:
DBGPProxyConfigurable.port=連接埠:
PhpBuiltInWebServerRunConfigurationEditor.configuration.description=PHP 內建 Web 伺服器組態
PhpBuiltInWebServerRunConfigurationEditor.configuration.display.name=PHP 內建 Web 伺服器
PhpBuiltInWebServerRunConfigurationEditor.document.root=文檔根:
PhpBuiltInWebServerRunConfigurationEditor.host=主機:
PhpBuiltInWebServerRunConfigurationEditor.port=連接埠:
PhpBuiltInWebServerRunConfigurationEditor.title=伺服器組態
PhpBuiltInWebServerRunConfigurationEditor.use.router.script=使用 router 腳本:
PhpCommandLineConfigurationEditor.command.line=命令行
PhpCommandLineConfigurationEditor.field.custom.working.directory=自訂工作目錄:
PhpCommandLineConfigurationEditor.field.environment.variables=環境變數:
PhpCommandLineConfigurationEditor.field.interpreter.options=解釋器選項:
PhpCommandLineConfigurationEditor.interpreter.options.editor.dialog.caption=解釋器選項
PhpDebugBreakAtFirstLineToggleAction.text=在 PHP 腳本中的第一行中斷
PhpDebugConfigurable.advanced.settings=進階設定
PhpDebugConfigurable.break.at.first.line=在 PHP 腳本中的第一行中斷
PhpDebugConfigurable.detect.path.mappings.from.deployment=檢測部署組態的路徑映射
PhpDebugConfigurable.evaluation=評估
PhpDebugConfigurable.external.connections=外部連線
PhpDebugConfigurable.ignore.external.connections.through.unregistered.server.configurations.label=通過未註冊的伺服器組態忽略外部連線
PhpDebugConfigurable.import.use.statements=從求值上下文匯入命名空間和 'use' 語句
PhpDebugConfigurable.notify.resolved.breakpoint=通知是否將中斷點解析為另一行(Xdebug 2.8+)
PhpDebugConfigurable.notify.session.stopped.without.pause=在偵錯會話完成而不暫停時通知
PhpDebugConfigurable.pass.required.configuration.options=通過命令行傳遞所需組態選項(仍需要手動啟用偵錯擴展)
PhpDebugConfigurable.remote.debug.listen.for.connections=3. 啟動“PHP 遠端偵錯”執行組態。
PhpDebugConfigurable.safe.evaluation.mode=值提示和監視框架下的安全求值模式
PhpDebugConfigurable.show.array.children.in.repl=在偵錯主控台中顯示陣列和物件子級
PhpDebugConfigurable.web.page.listen.for.connections=2. 啟動“PHP 網頁”執行組態。
PhpDebugConfigurable.web.page.pre.config.title=偵錯預組態
PhpDebugConfigurable.xdebug=Xdebug
PhpDebugConfigurable.xdebug.debug.port=Xdebug 偵錯連接埠
PhpDebugConfigurable.xdebug.force.break.no.path.mapping=未指定路徑映射時，在第一行強制中斷
PhpDebugConfigurable.xdebug.force.break.when.outside.project=當腳本在專案外部時，在第一行強制中斷
PhpDebugConfigurable.xdebug.resolve.breakpoints=如果中斷點在當前行不可用，則解析中斷點(Xdebug 2.8+)
PhpDebugConfigurable.zend.debug.port=Zend Debugger 偵錯連接埠
PhpDebugConfigurable.zend.debugger=Zend 偵錯器
PhpDebugConfigurable.zend.settings.broadcasting.port=Zend Debugger 設定廣播連接埠
PhpDebugConfigurable.zend.settings.ide.hosts=Zend Debugger IDE 主機
PhpDebugConfigurable.zend.settings.ide.hosts.detect=正在檢測…
PhpDebugConfigurable.zend.settings.ide.hosts.detect.progress=正在檢測 Zend Debugger 的 IP…
PhpDebugConfigurable.zero.configuration=預組態
PhpDebugConfigurable.zero.configuration.install.debugger.php.instruction=1. 安裝
PhpDebugConfigurable.zero.configuration.install.php.instruction=或
PhpDebugConfigurable.zero.configuration.install.php.validate=Web 伺服器上的偵錯器組態。
PhpDebugConfigurable.zero.configuration.install.php.validate.action=驗證
PhpDebugConfigurable.zero.configuration.install.toolbar.instruction=瀏覽器工具列或小書籤。
PhpDebugConfigurable.zero.configuration.install.toolbar.instruction.label=2. 安裝
PhpDebugConfigurable.zero.configuration.install.xdebug.php.instruction=Xdebug
PhpDebugConfigurable.zero.configuration.install.zend.debugger.php.action=Zend 偵錯器
PhpDebugConfigurable.zero.configuration.install.zend.debugger.php.instruction=在 Web 伺服器上。
PhpDebugConfigurable.zero.configuration.listen.for.connections=3. 啟用 PHP 偵錯連線偵聽:
PhpDebugConfigurable.zero.configuration.listen.for.connections.action=開始偵聽
PhpDebugConfigurable.zero.configuration.start.session=4. 使用工具列或小書籤在瀏覽器中啟動偵錯會話。
PhpDebugConfigurable.zero.configuration.stop.listen.for.connections.action=停止偵聽
PhpDebugConfigurable.zero.configuration.tutorial=有關更多資訊，請參見
PhpDebugConfigurable.zero.configuration.tutorial.action=“零組態偵錯”教程
PhpDebugHideEmptySuperGlobalsToggleAction.text=顯示空的超全域變數
PhpDebugSkippedPathsConfigurable.column.title=跳過的路徑
PhpDebugSkippedPathsConfigurable.display.name=跳過的路徑
PhpDebugSkippedPathsConfigurable.notify.about.skipped.files=通知跳過的檔案
PhpExtractMethodDialog.declare.static=宣告 static(&S)
PhpExtractMethodDialog.duplicates.count=檢查並取代重複項(找到 {0} 個)
PhpExtractMethodDialog.duplicates.pending=正在搜尋重複項…
PhpExtractMethodDialog.extract.function=提取函式
PhpExtractMethodDialog.extract.method=提取方法
PhpExtractMethodDialog.function=函式:
PhpExtractMethodDialog.generate.php.doc=生成 PhpDoc(&G)
PhpExtractMethodDialog.generate.php.doc.inplace=生成 PHPDoc
PhpExtractMethodDialog.method=方法:
PhpExtractMethodDialog.name=名稱(&A):
PhpExtractMethodDialog.output.variables=輸出變數
PhpExtractMethodDialog.parameters=參數
PhpExtractMethodDialog.private=private(&V)
PhpExtractMethodDialog.protected=protected(&T)
PhpExtractMethodDialog.public=public(&B)
PhpExtractMethodDialog.replace.tail.break.continue.with.return=將尾“break/continue”語句取代為“return”語句(&T)
PhpExtractMethodDialog.return.output.through=通過以下方式返回輸出變數:
PhpExtractMethodDialog.return.output.through.ref.parameters=通過參照傳遞的參數(&P)
PhpExtractMethodDialog.return.output.through.return=return 語句(&E)
PhpExtractMethodDialog.signature.preview=簽名預覽
PhpExtractMethodDialog.transformation.options=轉換選項
PhpExtractMethodDialog.visibility=可見性:
PhpFrameworksCommonConfigurable.display.name=框架
PhpHttpRequestRunConfiguration.configuration.description=HTTP 請求組態
PhpHttpRequestRunConfiguration.configuration.display.name=PHP HTTP 請求
PhpHttpRequestRunConfiguration.error.fetch.result=響應正文不可用
PhpHttpRequestRunConfiguration.error.host.is.not.specified=伺服器 ''{0}'' 的主機未指定或無效
PhpHttpRequestRunConfiguration.error.server.configuration=無法執行 HTTP 請求: ''{0}''。請在“PHP|伺服器”下檢查伺服器組態。
PhpHttpRequestRunConfiguration.error.server.is.not.specified=找不到名稱為 ''{0}'' 的遠端伺服器
PhpHttpRequestRunConfiguration.error.url.is.not.specified=URL 未指定或無效: ''{0}''。
PhpIncomingConnectionDialog.file.path.on.server=伺服器上的檔案路徑:
PhpIncomingConnectionDialog.request.uri=請求 URI:
PhpIncomingConnectionDialog.server.name=伺服器名稱:
PhpIncomingConnectionDialog.server.port=伺服器連接埠:
PhpIncomingLocalConnectionDialog.file.path=檔案路徑:
PhpInterpreter.configuration.duplicate.interpreter.name=找到了具有非唯一名稱 ''{0}'' 的 PHP 解釋器。
PhpInterpreter.configuration.in.project.settings.message=無法將 PHP 解釋器指定為預設 SDK。您可以在“設定| PHP”中為當前專案組態
PhpInterpreter.configuration.in.project.settings.title=PHP 解釋器組態
PhpInterpreter.configuration.interpreter.is.invalid=啟用“PHP Remote Interpreters”延伸模組以編輯解釋器。
PhpInterpreter.configuration.selection.list.title=選擇 CLI 解釋器
PhpInterpreter.php.debugger.label=偵錯器:
PhpInterpreter.php.dependent.configuration.exists=所選 PHP 解釋器有{0}組態。確定要刪除此解釋器嗎?
PhpInterpreter.php.dependent.configuration.exists.title=PHP 解釋器相依組態
PhpInterpreter.php.general.title=一般
PhpInterpreter.php.home.path.label=PHP 可執行檔案:
PhpInterpreter.php.interpreter.name.conflict=發現專案級和應用程式級解釋程序名稱存在衝突。為解決該問題，以下專案級解釋器被重新命名:
PhpInterpreter.php.interpreter.name.conflict.title=解釋器名稱衝突
PhpInterpreter.php.sdk.type=PHP 解釋器
PhpInterpreterConfigurable.can.not.updated.phpinfo=無法更新 phpinfo
PhpInterpreterConfigurable.configuration.default.project.tooltip=無法僅為預設專案儲存解釋器。
PhpInterpreterConfigurable.configuration.file.can.not.find=無法通過路徑找到檔案: ''{0}''
PhpInterpreterConfigurable.configuration.file.can.not.find.title=找不到組態檔案
PhpInterpreterConfigurable.configuration.file.evaluate.dir=正在評估組態檔案目錄…
PhpInterpreterConfigurable.configuration.file.fix=在 {0} 目錄中建立 php.ini 檔案，<br><br>組態檔案模板可在 php 根目錄中找到:<br>“php.ini-development”- 預設設定<br>“php.ini-production”- 推薦設定。<br>
PhpInterpreterConfigurable.configuration.file.fix.failed.to.detect=使用“{0} --ini”指令確定組態檔案目錄。<br>
PhpInterpreterConfigurable.configuration.file.fix.link=<br>點擊此<a href="http://php.net/manual/en/configuration.file.php">鏈接</a>獲取更多資訊。
PhpInterpreterConfigurable.configuration.file.fix.title=組態 php.ini 檔案不存在
PhpInterpreterConfigurable.configuration.file.hhvm.fix=在 <b>/etc/hhvm</b> 目錄中建立 php.ini 檔案，<br><br>點擊此<a href="http://docs.hhvm.com/manual/en/configuration.file.php">>鏈接</a>獲取更多資訊。
PhpInterpreterConfigurable.configuration.file.path=組態檔案: {0}
PhpInterpreterConfigurable.configuration.file.path.not.found=組態 php.ini 檔案不存在
PhpInterpreterConfigurable.configuration.options.description=這些選項將使用 '-d' 命令行選項傳遞
PhpInterpreterConfigurable.configuration.options.dialog.caption=組態選項
PhpInterpreterConfigurable.configuration.options.label=組態選項:
PhpInterpreterConfigurable.configuration.options.table.empty.text=為 php.ini 中允許的任何組態指令設定自訂值
PhpInterpreterConfigurable.configuration.options.table.name=組態指令
PhpInterpreterConfigurable.configuration.options.table.value=值
PhpInterpreterConfigurable.configuration.options.with.empty.name.are.not.allowed=不允許名稱為空的組態選項
PhpInterpreterConfigurable.configuration.project.level=僅對此專案可見
PhpInterpreterConfigurable.configuration.project.tooltip=檢查是否不想在專案之間共享解釋器
PhpInterpreterConfigurable.configuration.title=其他
PhpInterpreterConfigurable.debugger.extension.description=將僅為從 CLI 執行組態啟動的偵錯會話載入偵錯器擴展
PhpInterpreterConfigurable.debugger.extension.label=偵錯器擴展:
PhpInterpreterConfigurable.debugger.extension.title=選擇偵錯器擴展路徑
PhpInterpreterConfigurable.generate.xdebug.extension=生成安裝腳本
PhpInterpreterConfigurable.install.xdebug.extension=下載並安裝 Xdebug 擴展
PhpInterpreterConfigurable.not.installed=未安裝
PhpInterpreterConfigurable.php.ini.title=選擇組態檔案或目錄
PhpInterpreterConfigurable.php.version=PHP 版本: {0}
PhpInterpreterConfigurable.reload.phpinfo=重新載入 phpinfo
PhpInterpreterConfigurable.show.phpinfo=顯示 phpinfo
PhpInterpreterConfigurable.update.helpers.title=正在更新幫助程序目錄…
PhpInterpreterConfigurable.updated.phpinfo=已成功更新 phpinfo
PhpLanguageFeature.abstract.function.override=從 PHP 7.2 起才允許抽象函式覆寫
PhpLanguageFeature.abstract.private.trait.methods=從 PHP 8.0 起才允許使用 abstract private 特徵方法
PhpLanguageFeature.anonymous.classes=從 PHP 7.0 起才允許使用匿名類別
PhpLanguageFeature.argument.unpacking=從 PHP 5.6 起才允許使用實參解包
PhpLanguageFeature.array.dereferencing.not.supported=從 PHP 5.4 起才允許對調用進行陣列解參照
PhpLanguageFeature.arrow.function=從 PHP 7.4 起才允許箭頭函式語法
PhpLanguageFeature.attributes=從 PHP 8.0 起才允許使用特性
PhpLanguageFeature.binary.literal.not.supported=從 PHP 5.4 起才允許使用二進制文字
PhpLanguageFeature.built.in.web.server=內建 Web 伺服器僅自 PHP 5.4 起可用
PhpLanguageFeature.call.time.pass.by.reference.not.supported=調用時通過參照傳遞在 PHP 5.4 中已被移除
PhpLanguageFeature.catch.multiple=從 PHP 7.1 起才允許捕獲多條語句
PhpLanguageFeature.class.constant.visibility=從 PHP 7.1 起才允許類別常數可見性
PhpLanguageFeature.class.member.access.on.instantiation.not.supported=從 PHP 5.4 起才允許對實例化進行類別成員存取
PhpLanguageFeature.class.name.const.not.supported=從 PHP 5.5 起才允許使用類別名常數
PhpLanguageFeature.class.name.literal.on.object=從 PHP 8.0 起才允許在物件上使用 '::class'
PhpLanguageFeature.coalesce.assign=從 PHP 7.4 起才允許使用 '??='
PhpLanguageFeature.coalesce.operator=從 PHP 7.0 起才允許使用合併運算符
PhpLanguageFeature.constant.scalar.expressions=從 PHP 5.6 起才允許使用常數標量表達式
PhpLanguageFeature.constants.in.traits=從 PHP 8.2 起才允許在特徵中使用常數
PhpLanguageFeature.empty.any.expression.not.supported=從 PHP 5.5 起才允許在 'empty' 中使用任意表達式
PhpLanguageFeature.enum.classes=從 PHP 8.1 起才允許使用枚舉
PhpLanguageFeature.exception.throw.from.toString=從 PHP 7.4 起才允許從 ''__toString'' 拋出異常，''{0}.__toString'' 可能會拋出異常
PhpLanguageFeature.explicit.octal.literal=自 PHP 8.1 起只允許顯式八進制文字
PhpLanguageFeature.exponentiation=從 PHP 5.6 起才允許使用求冪
PhpLanguageFeature.final.class.constants=自 PHP 8.1 起只允許使用 'final' 類別常數
PhpLanguageFeature.finally.not.supported=從 PHP 5.5 起才允許使用 'Finally' 子句
PhpLanguageFeature.first.class.callable.syntax=從 PHP 8.1 起才允許一級可調用語法
PhpLanguageFeature.flexible.heredocs=靈活的 heredoc/nowdoc 語法
PhpLanguageFeature.foreach.list.not.supported=從 PHP 5.5 起才允許在 foreach 中使用列表
PhpLanguageFeature.generators.not.supported=從 PHP 5.5 起才允許使用產生器
PhpLanguageFeature.grouped.use=從 PHP 7.0 起才允許分組 use 宣告
PhpLanguageFeature.immediate.dereferencing.not.supported=從 PHP 5.5 起才允許直接解參照
PhpLanguageFeature.intersection.and.union.in.same.type=從 PHP 8.2 起才允許使用混合交叉類型與聯合類型
PhpLanguageFeature.intersection.types=從 PHP 8.1 起才允許交叉類型
PhpLanguageFeature.iterable.type.hint=從 PHP 7.1 起才允許迭代類型提示
PhpLanguageFeature.keyword.names=在 PHP 7.0 中關鍵字可用作名稱
PhpLanguageFeature.list.assign=從 PHP 7.1 起才允許列表解包中的 []
PhpLanguageFeature.list.keys=從 PHP 7.1 起才允許列表解包中的密鑰
PhpLanguageFeature.literal.in.instanceof=從 PHP 7.3 起才允許將文字作為第一個動作數
PhpLanguageFeature.literal.in.static.call.not.supported=從 PHP 5.4 起才允許在 static 呼叫中使用文字
PhpLanguageFeature.match.expression=從 PHP 8.0 起才允許符合表達式
PhpLanguageFeature.mixed.type.hint=從 PHP 8.0 起才允許 'mixed' 類型提示
PhpLanguageFeature.named.arguments=從 PHP 8.0 起才允許使用命名實參
PhpLanguageFeature.namespaced.name.as.single.token=從 PHP 8.0 起才允許關鍵字作為命名空間的一部分
PhpLanguageFeature.negative.numeric.indices=從 PHP 7.1 起才允許負數值索引
PhpLanguageFeature.new.in.init=從 PHP 8.1 起才允許在初始設定式中使用 'new'
PhpLanguageFeature.non.capturing.catches=從 PHP 8.0 起才允許捕捉異常而又不將異常捕獲到變數中
PhpLanguageFeature.nullables=從 PHP 7.1 起才允許可為 null
PhpLanguageFeature.nullsafe.dereferencing=從 PHP 8.0 起才允許 Nullsafe 運算符
PhpLanguageFeature.numeric.literals.separators=從 PHP 7.4 起才允許使用數值文字分隔符
PhpLanguageFeature.object.type.hint=從 PHP 7.2 起才允許物件類型提示
PhpLanguageFeature.parent.in.closure.not.supported=從 PHP 5.4 起才允許在閉包中使用 parent
PhpLanguageFeature.property.promotion=從 PHP 8.0 起才允許建構函式屬性提升
PhpLanguageFeature.readonly.classes=從 PHP 8.2 起才允許使用 'readonly' 類別
PhpLanguageFeature.readonly.properties=從 PHP 8.1 起才允許使用 'readonly' 屬性
PhpLanguageFeature.references.in.list=從 PHP 7.3 起才允許在 [] 和 list() 賦值中使用參照
PhpLanguageFeature.return.never=自 PHP 8.1 起才允許使用返回值類型 'never'
PhpLanguageFeature.return.types=從 PHP 7.0 起才允許使用返回值類型宣告
PhpLanguageFeature.return.void=從 PHP 7.1 起才允許使用返回值類型 'void'
PhpLanguageFeature.scalar.type.hints=從 PHP 7.0 起才允許使用標量類型提示
PhpLanguageFeature.self.in.closure.not.supported=從 PHP 5.4 起才允許在閉包中使用 self
PhpLanguageFeature.short.array.syntax.not.supported=從 PHP 5.4 起才允許使用短陣列語法
PhpLanguageFeature.spaceship.operator=從 PHP 7.0 起才允許使用宇宙飛船運算符
PhpLanguageFeature.spread.operator.in.array=從 PHP 7.4 起才允許在陣列中使用展開運算符
PhpLanguageFeature.standalone.null.false=從 PHP 8.2 起才允許將 'null' 和 'false' 用作獨立類型
PhpLanguageFeature.static.in.closure.not.supported=從 PHP 5.4 起才允許在閉包中使用 static
PhpLanguageFeature.static.type.hint=從 PHP 8.0 起才允許 'static' 返回值類型宣告
PhpLanguageFeature.this.in.closure.not.supported=從 PHP 5.4 起才允許在閉包中使用 $this
PhpLanguageFeature.throw.expression=從 PHP 8.0 起才允許使用 throw 表達式
PhpLanguageFeature.trailing.comma.in.closure.use.list=只有 PHP 8.0 支援在閉包 use 列表中使用尾隨逗號
PhpLanguageFeature.trailing.comma.in.function.calls=從 PHP 7.3 起才允許在函式呼叫中使用尾隨逗號
PhpLanguageFeature.trailing.comma.in.group.uses=從 PHP 7.2 起才允許在組使用列表中使用尾隨逗號
PhpLanguageFeature.trailing.comma.in.parameter.list=從 PHP 8.0 起才允許在參數列表中使用尾隨逗號
PhpLanguageFeature.traits.not.supported=從 PHP 5.4 起才允許使用特徵
PhpLanguageFeature.true.type=從 PHP 8.2 起才允許使用名為 'true' 的類型提示
PhpLanguageFeature.typed.properties=從 PHP 7.4 起才允許使用類型化屬性
PhpLanguageFeature.uniform.variable.syntax=從 PHP 7.0 起才允許統一變數語法
PhpLanguageFeature.union.types=從 PHP 8.0 起才允許聯合類型
PhpLanguageFeature.use.function.and.const=從 PHP 5.6 起才允許 use function 和 use const
PhpLanguageFeature.var.break.argument.not.supported=PHP 5.4 不再支援具有非常數動作數的 'break' 運算符
PhpLanguageFeature.var.break.zero.argument.not.supported=自 PHP 5.4 起，'break' 運算符僅接受正數
PhpLanguageFeature.var.continue.not.supported=PHP 5.4 不再支援具有非常數動作數的 'continue' 運算符
PhpLanguageFeature.var.continue.zero.not.supported=自 PHP 5.4 起，'continue' 運算符僅接受正數
PhpLanguageFeature.variadic.functions=從 PHP 5.6 起才允許使用可變函式
PhpLanguageLevel.5.3.0.presentable.name=5.3
PhpLanguageLevel.5.3.0.short.description=命名空間，閉包
PhpLanguageLevel.5.4.0.presentable.name=5.4
PhpLanguageLevel.5.4.0.short.description=特徵，短陣列語法
PhpLanguageLevel.5.5.0.presentable.name=5.5
PhpLanguageLevel.5.5.0.short.description=finally，生成器
PhpLanguageLevel.5.6.0.presentable.name=5.6
PhpLanguageLevel.5.6.0.short.description=可變函式，實參解包
PhpLanguageLevel.7.0.0.presentable.name=7.0
PhpLanguageLevel.7.0.0.short.description=返回值類型，標量類型提示
PhpLanguageLevel.7.1.0.presentable.name=7.1
PhpLanguageLevel.7.1.0.short.description=常數可見性，可為 null，多個異常
PhpLanguageLevel.7.2.0.presentable.name=7.2
PhpLanguageLevel.7.2.0.short.description=物件類型提示，abstract 函式覆寫
PhpLanguageLevel.7.3.0.presentable.name=7.3
PhpLanguageLevel.7.3.0.short.description=列表賦值中的參照，靈活的 heredoc
PhpLanguageLevel.7.4.0.presentable.name=7.4
PhpLanguageLevel.7.4.0.short.description=類型屬性，短閉包，null 合併運算符
PhpLanguageLevel.8.0.0.presentable.name=8.0
PhpLanguageLevel.8.0.0.short.description=聯合類型，命名實參，特性，match 表達式
PhpLanguageLevel.8.1.0.presentable.name=8.1
PhpLanguageLevel.8.1.0.short.description=枚舉、'never' 返回值類型、交叉類型、'readonly' 屬性
PhpLanguageLevel.8.2.0.presentable.name=8.2
PhpLanguageLevel.8.2.0.short.description='readonly' 類別，'true' 類型，獨立的 'null' 和 'false'
PhpPathMappingsConfigurable.use.path.mappings.label=使用路徑映射(選擇伺服器是遠端伺服器還是使用符號鏈接)
PhpProjectConfigurable.0.interpreter.include.path=''{0}'' 解釋器 include 路徑
PhpProjectConfigurable.advanced.settings=進階設定(&V)
PhpProjectConfigurable.all=所有
PhpProjectConfigurable.analysis=分析
PhpProjectConfigurable.analysis.custom.format.functions=自訂格式函式
PhpProjectConfigurable.default.stubs.path=預設存根路徑(&D):
PhpProjectConfigurable.docker.default.project.error.tooltip=開啟或建立專案以組態 Docker 容器
PhpProjectConfigurable.exception.analysis=異常分析
PhpProjectConfigurable.exception.analysis.depth=呼叫樹分析路徑:
PhpProjectConfigurable.exception.analysis.unchecked.exceptions=未檢查的異常:
PhpProjectConfigurable.include.analysis=Include 分析
PhpProjectConfigurable.include.path=Include 路徑
PhpProjectConfigurable.interpreter=CLI 解釋器:
PhpProjectConfigurable.language.level=PHP 語言級別(&P):
PhpProjectConfigurable.php.runtime=PHP 執行時
PhpProjectConfigurable.provide.include.path=提供 include 路徑
PhpProjectConfigurable.select.default.stubs.path.description=選擇預設存根路徑
PhpProjectConfigurable.select.default.stubs.path.title=選擇預設存根路徑
PhpProjectConfigurable.select.document.root.path.description=選擇 $_SERVER['DOCUMENT_ROOT'] 路徑
PhpProjectConfigurable.select.document.root.path.title=選擇 $_SERVER['DOCUMENT_ROOT'] 路徑
PhpProjectConfigurable.specify.other=指定其他…
PhpRemoteDebugRunConfigurationEditor.auto.config=通過 IDE 鍵篩選偵錯連線
PhpRemoteDebugRunConfigurationEditor.configuration.description=PHP 偵錯組態
PhpRemoteDebugRunConfigurationEditor.configuration.display.name=PHP 遠端偵錯
PhpRemoteDebugRunConfigurationEditor.filter.connections.help=適用於複雜伺服器設定，例如同一主機連接埠上有多個應用程式。<p/>保持未選中狀態以自動檢測組態，或使用<i>“偵聽偵錯連線”</i>動作。
PhpRemoteDebugRunConfigurationEditor.filter.connections.help.link=閱讀更多資訊
PhpRemoteDebugRunConfigurationEditor.filter.connections.help.title=進階選項
PhpRemoteDebugRunConfigurationEditor.server.label=伺服器(&E):
PhpRemoteDebugRunConfigurationEditor.session.id.cannot.be.empty=IDE 鍵(會話 ID)不能為空
PhpRemoteDebugRunConfigurationEditor.session.id.label=IDE 鍵(會話 ID)(&K):
PhpRemoteDebugRunConfigurationEditor.stop.zero.configuration=PhpStorm 已停止偵聽傳入偵錯連線。
PhpRemoteDebugRunConfigurationEditor.stop.zero.configuration.title=已停止偵聽傳入 PHP 偵錯連線
PhpRemoteDebugRunConfigurationEditor.zero.configuration.is.already.used=“偵聽傳入偵錯連線”已啟用，不會發生任何變化。<br/>檢視<a href="zero_config">零組態偵錯</a>獲取更多資訊。<br/><br/>要停止偵聽偵錯連線，請使用<a href="stop">執行|停止偵聽 PHP 偵錯連線</a>。
PhpRemoteDebugRunConfigurationEditor.zero.configuration.used=沒有為 <i>''{0}''</i> 執行組態指定<i>伺服器</i>，因此 PhpStorm 將偵聽所有傳入偵錯連線。<br/>檢視<a href="zero_config">零組態偵錯</a>獲取更多資訊。<br/><br/>要停止偵聽偵錯連線，請使用<a href="stop">執行|停止偵聽 PHP 偵錯連線</a>。
PhpRemoteDebugRunConfigurationEditor.zero.configuration.used.title=已開始偵聽傳入 PHP 偵錯連線
PhpScripRunConfigurationEditor.arguments=實參:
PhpScripRunConfigurationEditor.arguments.caption=實參
PhpScripRunConfigurationEditor.configuration.description=PHP 腳本組態
PhpScripRunConfigurationEditor.configuration.display.name=PHP 腳本
PhpScripRunConfigurationEditor.file=檔案:
PhpServerConfigurable.debugger.label=偵錯器(&D)
PhpServerConfigurable.host=主機
PhpServerConfigurable.host.label=主機(&H):
PhpServerConfigurable.port=連接埠
PhpServerConfigurable.port.label=連接埠(&P)
PhpServerConfigurable.shared=共享(&S)
PhpStepFilters.log.frame=框架已被跳過。函式名稱: {0}。遠端檔案 URL: {1}
PhpStepFiltersConfigurable.add.method=新增方法
PhpStepFiltersConfigurable.display.name=步進篩選器
PhpStepFiltersConfigurable.skip.constructors=跳過建構函式
PhpStepFiltersConfigurable.skip.magic.methods=跳過魔術方法
PhpStepFiltersConfigurable.skipped.files=跳過的檔案
PhpStepFiltersConfigurable.skipped.methods=跳過的方法
PhpStepFiltersConfigurable.specify.method.name=指定方法名稱
PhpStepFiltersConfigurable.title.files=檔案
PhpStepFiltersConfigurable.title.methods=方法
PhpUnitConfigurableForm.can.not.find.custom.loader=在 ''{0}'' 下找不到自動載入器腳本
PhpUnitConfigurableForm.can.not.find.paratest=在 ''{0}'' 下找不到 ParaTest
PhpUnitConfigurableForm.can.not.find.phpunit.phar=在 ''{0}'' 下找不到 phpunit.phar
PhpUnitConfigurableForm.custom.loader.is.directory=自動載入器不應為目錄，對於預設 Composer 組態，將路徑設定為“vendor/autoload.php”
PhpUnitConfigurableForm.custom.loader.is.empty=自動載入器檔案的路徑為空
PhpUnitConfigurableForm.default.paratest.binary=預設 ParaTest 二進制檔案:
PhpUnitConfigurableForm.download.phpunit.phar.link.text=從 {0} 下載 phpunit.phar
PhpUnitConfigurableForm.paratest.path=預設 ParaTest 二進制檔案
PhpUnitConfigurableForm.path.to.phpunit.phar=phpunit.phar 路徑
PhpUnitConfigurableForm.path.to.script=腳本路徑:
PhpUnitConfigurableForm.phpunit.library=PHPUnit 庫
PhpUnitConfigurableForm.phpunit.paratest.is.empty=ParaTest 的路徑為空
PhpUnitConfigurableForm.phpunit.phar.is.empty=phpunit.phar 路徑為空
PhpUnitConfigurableForm.specified.wrong.paratest.binary=指定了錯誤的 ParaTest 二進制檔案，請改用 'paratest_for_phpstorm'
PhpUnitConfigurableForm.test.runner=測試執行程序
PhpUnitConfigurableForm.unsupported.paratest.version=<html>安裝的 ParaTest 版本不支持與 PHPStorm 整合。<br>請將 ParaTest 更新到 6.5.0 或更高版本。</html>
PhpUnitConfigurableForm.use.bootstrap.file=預設啟動檔案:
PhpUnitConfigurableForm.use.bootstrap.file.validation.warning=為 ''{0}'' 提供啟動檔案的路徑，或停用“預設啟動檔案”選項
PhpUnitConfigurableForm.use.configuration.file=預設組態檔案:
PhpUnitConfigurableForm.use.configuration.file.validation.warning=為 ''{0}'' 提供組態檔案的路徑，或停用“預設組態檔案”選項
PhpUnitConfigurableForm.use.custom.loader=使用 Composer 自動載入器
PhpUnitConfigurableForm.use.paratest=使用 ParaTest:
PhpUnitConfiguration.interpreter.conflict=發現應用程式級 PHPUnit 組態衝突。為解決該問題，建立了以下組態的專案級副本:
PhpUnitConfiguration.interpreter.conflict.title=PHPUnit 組態衝突
PhpUnitTestRunnerConfigurationEditor.dialog.caption.test.runner.options=測試執行程序選項
PhpUnitTestRunnerConfigurationEditor.field.class=類別:
PhpUnitTestRunnerConfigurationEditor.field.directory=目錄:
PhpUnitTestRunnerConfigurationEditor.field.file=檔案:
PhpUnitTestRunnerConfigurationEditor.field.method=方法:
PhpUnitTestRunnerConfigurationEditor.field.test.runner.coverage.engine=首選覆蓋率引擎:
PhpUnitTestRunnerConfigurationEditor.field.test.runner.options=測試執行程序選項(&O):
PhpUnitTestRunnerConfigurationEditor.scope=測試作用域:
PhpUnitTestRunnerConfigurationEditor.scope.class=類別
PhpUnitTestRunnerConfigurationEditor.scope.directory=目錄
PhpUnitTestRunnerConfigurationEditor.scope.method=方法
PhpUnitTestRunnerConfigurationEditor.scope.xml=在組態檔案中定義
PhpUnitTestRunnerConfigurationEditor.test.runner=測試執行程序
PhpUnitTestRunnerConfigurationEditor.use.alt.bootstrap.file=使用替代啟動檔案(&U):
PhpUnitTestRunnerConfigurationEditor.use.alt.configuration.file=使用替代組態檔案(&U):
PhpUserDefinedConstantsGroup.name=常數
PhpWebAppRunConfigurationEditor.browser=瀏覽器(&B):
PhpWebAppRunConfigurationEditor.configuration.description=PHP 網頁組態
PhpWebAppRunConfigurationEditor.configuration.display.name=PHP 網頁
PhpWebAppRunConfigurationEditor.malformed.start.url=起始 URL 的格式錯誤 - {0}
PhpWebAppRunConfigurationEditor.startUrl=起始 URL(&U):
RunConfigurationEditor.configuration=組態
RunConfigurationEditor.error.server.is.not.exist=名稱為 ''{0}'' 的伺服器不存在
RunConfigurationEditor.error.server.is.not.selected=未選擇伺服器
RunConfigurationEditor.server=伺服器(&S):
XdebugAddMethodToSkipListToggleAction.text=將方法新增到跳過列表
XdebugCloudConfigurable.base.host=Cloud 主機:
XdebugCloudConfigurable.cloud.id=Cloud ID:
XdebugCloudConfigurable.connect.via.xdebug.cloud=連線到 Xdebug Cloud
XdebugCloudConfigurable.custom.server=連線到預置 Xdebug Cloud
XdebugCloudConfigurable.display.name=Xdebug Cloud
XdebugCloudConfigurable.port=Cloud 連接埠:
XdebugShowUserDefinedConstantsToggleAction.description=將其停用會停止獲取使用者定義的常數資訊並提高偵錯器性能
XdebugShowUserDefinedConstantsToggleAction.text=顯示使用者定義的常數
a.class.constant.must.not.be.called.class.it.is.reserved.for.class.name.fetching=類別常數不得被稱為 'class'；後者被保留用於類別名提取
a.full.numeric.representation.of.a.year.at.least.4.digits.with.for.years.bce=年份的完整數字表示，至少 4 位數，使用 - 表示公元前的年份(2022 年)
a.full.textual.representation.of.a.month.such.as.january.or.march=月份的完整文本表示，英語(January 到 December)
a.full.textual.representation.of.the.day.of.the.week=星期几的完整文本表示(Sunday 到 Saturday)
a.short.textual.representation.of.a.month.three.letters=月份的短文本表示，三個英語字母(Jan 到 Dec)
a.textual.representation.of.a.day.three.letters=星期几的文本表示，三個英語字母(Mon 到 Sun)
a.trait.cannot.extend.a.class=特徵無法擴展類別
a.trait.cannot.implement.an.interface=特徵無法實作接口
a.two.digit.representation.of.a.year=年份的兩位數表示(22)
absolute.reference.is.not.allowed=不允許絕對參照
abstract.modifier.is.not.allowed.here=此處不允許使用 'Abstract' 修飾符
access.level.to.0.1.must.be.2.as.in.class.3.or.weaker=''{0}::\${1}'' 的存取級別必須為 {2} (與類別 {3} 中一樣)或更低
access.level.to.0.1.must.be.2.as.in.class.3.or.weaker2=''{0}::{1}'' 的存取級別必須為 {2} (與類別 {3} 中一樣)或更低
access.must.be.public=存取必須為 public
access.type.for.interface.member.must.be.omitted=接口成員的存取類型必須省略
action.ChangePHPInterpreter.description=更改專案 PHP 解釋器
action.ChangePHPInterpreter.text=更改 PHP 解釋器
action.ComposerAddDependencyAction.description=管理 Composer 相依項
action.ComposerAddDependencyAction.text=管理相依項…
action.ComposerClearCacheAction.description=刪除 Composer 快取目錄中的所有內容
action.ComposerClearCacheAction.text=清除快取
action.ComposerDiagnoseAction.description=檢查常見的 Composer 問題
action.ComposerDiagnoseAction.text=診斷
action.ComposerDryRunUpdate.description=模擬更新，但不實際更新
action.ComposerDryRunUpdate.text=模擬更新
action.ComposerDumpAutoloadAction.description=重新生成自動載入類別的列表
action.ComposerDumpAutoloadAction.text=傾印自動載入器…
action.ComposerInstallAction.description=考慮到 composer.lock，安裝 composer.json 中的軟體套件
action.ComposerInstallAction.text=安裝
action.ComposerLicensesAction.description=列出安裝的每個軟體套件的名稱、版本和授權
action.ComposerLicensesAction.text=列出授權
action.ComposerSelfUpdateAction.description=將 Composer 本身更新到最新版本
action.ComposerSelfUpdateAction.text=自我更新
action.ComposerShowLogAction.description=顯示包含此 composer.json 的 Composer 動作日誌
action.ComposerShowLogAction.text=顯示日誌
action.ComposerStatusAction.description=檢查任何相依項中有無本地更改
action.ComposerStatusAction.text=檢查相依項中的更改
action.ComposerUpdateAction.description=從 Composer.json 安裝最新適當版本的軟體套件
action.ComposerUpdateAction.text=更新
action.ComposerValidateAction.description=檢查 composer.json 是否有效
action.ComposerValidateAction.text=驗證…
action.DisableXdebugDfaAssist.description=永久關閉數據流輔助偵錯
action.DisableXdebugDfaAssist.text=永久關閉數據流助手
action.MessDetectorAddToIgnored.description=新增到 PHP Mess Detector 忽略列表
action.MessDetectorAddToIgnored.text=新增到 PHPMD 忽略列表
action.PhpCSAddToIgnored.description=新增到 PHP_CodeSniffer 忽略列表
action.PhpCSAddToIgnored.text=新增到 PHPCS 忽略列表
action.PhpCSFixerAddToIgnored.description=新增到 PHP CS Fixer 忽略列表
action.PhpCSFixerAddToIgnored.text=新增到 PHP CS Fixer 忽略列表
action.PhpDebuggerCopyType.text=複製類型
action.PhpDetectPsroRoots.description=將檢測原始碼命名空間根
action.PhpDetectPsroRoots.text=檢測 PSR-0 命名空間根
action.PhpExtractClassAction.description=將元素提取到單獨的類別
action.PhpExtractClassAction.text=提取類別…
action.PhpGenerateConstructor.description=建立建構函式。
action.PhpGenerateConstructor.text=建構函式…
action.PhpGenerateGetters.description=為 private 類別欄位建立 getter。
action.PhpGenerateGetters.text=getter…
action.PhpGenerateGettersAndSetters.description=為 private 類別欄位建立 getter 和 setter。
action.PhpGenerateGettersAndSetters.text=getter 和 setter…
action.PhpGeneratePhpDocBlocks.description=為函式、類別和欄位新增 PHPDoc 塊。
action.PhpGeneratePhpDocBlocks.text=PHPDoc 塊…
action.PhpGenerateSetters.description=為 private 類別欄位建立 setter。
action.PhpGenerateSetters.text=setter…
action.PhpListenDebugAction.description=偵聽偵錯連線
action.PhpListenDebugAction.text=偵聽偵錯連線
action.PhpMakeStaticAction.description=將類別方法設為 static
action.PhpMakeStaticAction.text=設為 static
action.PhpNewTest.description=建立新的 PHP 測試
action.PhpNewTest.text=PHP 測試
action.PhpStanAddToIgnored.description=新增到 PHPStan 忽略列表
action.PhpStanAddToIgnored.text=新增到 PHPStan 忽略列表
action.PhpStormMigrationGuide.text=PhpStorm 遷移指南
action.PhpUnitGenerateSetUpMethod.description=建立 PHPUnit setUp 方法
action.PhpUnitGenerateSetUpMethod.text=SetUp 方法
action.PhpUnitGenerateTearDownMethod.description=建立 PHPUnit tearDown 方法
action.PhpUnitGenerateTearDownMethod.text=TearDown 方法
action.PhpUnitGenerateTestMethod.description=建立 PHPUnit 測試方法
action.PhpUnitGenerateTestMethod.text=測試方法
action.ProfilerJumpToSource.description=跳轉到源
action.ProfilerJumpToSource.text=跳轉到源
action.ProjectFromVersionControl.ProjectWidgetPopup.text=從版本控制中獲取…
action.ProjectFromVersionControl.text=從版本控制新增專案…
action.XDebugger.CopyPath.text=複製路徑
action.XdebugAnalyzeProfilerSnapshotAction.text=分析 Xdebug 分析器快照…
action.XdebugDetachFromSessionAction.text=從會話中分離
action.add.file.s.to.list.text=向列表中新增檔案
action.com.jetbrains.php.composer.ComposerInitSupportAction.description=初始化 Composer
action.com.jetbrains.php.composer.ComposerInitSupportAction.text=初始化 Composer…
action.com.jetbrains.php.internal.PhpCreateYoutrackIssueFromFileAction.text=在 WI (PhpStorm) 專案中根據檔案內容建立 YouTrack 問題
action.com.jetbrains.php.internal.PhpCreateYoutrackIssueFromSelectionAction.text=在 WI (PhpStorm) 專案中根據所選內容建立 YouTrack 問題
action.com.jetbrains.php.internal.PhpShowFQNInternalAction.text=顯示 PHP FQN
action.com.jetbrains.php.internal.PhpViewControlFlowAction.text=當前檔案的 PHP 控制流
action.configuration.text=組態…
action.configure.php.runtime.text=組態 PHP 執行時…
action.configure.project.directories.text=組態專案目錄
action.copy.3v4l.link.text=將 3v4l 鏈接複製到剪貼簿
action.copy.port.to.clipboard.text=將連接埠值複製到剪貼簿
action.copy.to.clipboard.text=複製到剪貼簿
action.detect.composer.json.not.found=在路徑 {0} 下找不到 composer.json
action.detect.composer.json.not.found.title=找不到 composer.json
action.detect.composer.json.open=在編輯器中開啟
action.detect.settings.sync.turned.on=PHP 語言級別已與 composer.json 同步
action.detect.settings.sync.turned.on.title=已與 composer.json 同步
action.detect.user.settings.state.overwritten=如果開啟同步，IDE 設定(PHP 語言級別，PSR-0/PSR-4 根)可能會被覆蓋
action.detect.user.settings.state.overwritten.short=設定可能會被覆蓋: PSR-0/PSR-4 根和 PHP 語言級別。
action.detect.user.settings.state.supported=支援 PSR-0/PSR-4 根和 PHP 語言級別的同步
action.enable.plugin.text=啟用 ''{0}'' 延伸模組
action.open.3v4l.link.in.browser.text=在瀏覽器中開啟 3v4l 鏈接
action.quality.tools.provider=品質工具
action.quality.tools.provider.description=檔案被排除在外部品質工具分析和格式化程序外
action.retry.text=重試
action.revert.back.to.text=還原為 {0}
action.run.composer.install.text=執行 'composer install'
action.run.on.3v4l.org.text=在 3v4l.org 上執行
action.show.in.log.text=在日誌中顯示
action.submits.code.to.3v4l.org.show.result.in.preview.editor.description=將程式碼提交到 3v4l.org，並在預覽編輯器中顯示結果
action.synonym.listening=偵聽
action.synonym.start.listening=開始偵聽 PHP Xdebug 連線
action.synonym.stop.listening=停止偵聽 PHP Xdebug 連線
actions.detect.common.setting.from.composer.disable=不同步
actions.detect.common.setting.from.composer.enable=啟用同步
actions.detect.common.setting.from.composer.show.settings=顯示設定
actions.detect.common.setting.from.composer.suggest.title=將設定與 Composer 同步?
actions.detect.common.settings.composer.sync.state.title=與 composer.json 的同步{0}
actions.detect.common.settings.updated.from.composer.title={0} 設定已更新
actions.detect.language.level.loaded.from.composer.idea.title=語言級別
actions.detect.language.level.loaded.from.composer.title=PHP 語言級別
actions.detect.namespace.roots.finished=已完成 PSR-0 命名空間根檢測。
actions.detect.namespace.roots.from.composer.idea.title=來源根
actions.detect.namespace.roots.from.composer.title=PSR-0/PSR-4 根
actions.detect.namespace.roots.idea.view.configuration=您可以在 '專案結構 | 模組' 中修改設定。
actions.detect.namespace.roots.manual.configuration=手動組態
actions.detect.namespace.roots.no.new.roots.detected=未檢測到新的 PSR-0 命名空間根。
actions.detect.namespace.roots.notification.id=PHP PSR-0 命名空間根檢測已完成
actions.detect.namespace.roots.notification.title=檢測 PSR-0 命名空間根
actions.detect.namespace.roots.progress.title=正在檢測 PSR-0 命名空間根…
actions.detect.namespace.roots.view.configuration=檢視組態
actions.generate.php.doc.is.not.available=PHPDoc 生成在索引更新期間不可用
actions.mark.directory.as.psr.0.root=<i>{0}</i>
actions.mark.directory.as.psr.0.root.mark.psr=標記為 {0} 根
actions.mark.directory.as.psr.0.root.title=是否要將目錄標記為 {0} 根?
actions.mark.directory.as.psr.0.root.with.prefix=<i>{0}</i>為前綴“{1}”?
actions.new.php.base.arrows.extension.tooltip=在編輯器中按向上或向下箭頭可更改檔案副檔名
actions.new.php.base.arrows.template.tooltip=在編輯器中按向上或向下箭頭可更改模板
actions.new.php.base.dialog.label.extension=檔案副檔名:
actions.new.php.base.dialog.label.file.name=檔名:
actions.new.php.class.action.description=建立新的 PHP 類別
actions.new.php.class.action.name=PHP 類別
actions.new.php.class.dialog.border.title.class=類別
actions.new.php.class.dialog.label.class.name=名稱:
actions.new.php.class.dialog.label.directory=目錄:
actions.new.php.class.dialog.label.namespace=命名空間:
actions.new.php.class.dialog.label.superclasses.container=父類別
actions.new.php.class.dialog.label.superclasses.super.fqn=擴展:
actions.new.php.class.dialog.label.superinterfaces.add.interface=新增接口…
actions.new.php.class.dialog.label.superinterfaces.to.extend.empty=選擇要擴展的接口
actions.new.php.class.dialog.label.superinterfaces.to.implement=實作:
actions.new.php.class.dialog.label.superinterfaces.to.implement.empty=選擇要實作的接口
actions.new.php.class.dialog.label.template=模板:
actions.new.php.class.dialog.title=建立新的 PHP 類別
actions.new.php.file.action.description=建立新的 PHP 檔案
actions.new.php.file.action.name=PHP 檔案
actions.new.php.file.dialog.title=建立新的 PHP 檔案
actions.new.phpunit.class.action.description=建立新的 PHPUnit 測試
actions.new.phpunit.class.action.name=PHPUnit 測試
actions.new.test.class.action.description=建立新的 PHP 測試
actions.new.test.class.action.name=新增 PHP 測試
actions.new.test.class.dialog.arrows.libraries.hint=在編輯器中按向上或向下箭頭可更改測試庫
actions.new.test.class.dialog.border.title.class.to.test=要測試的類別(可選)
actions.new.test.class.dialog.border.title.target.class.file.path=檔案路徑:
actions.new.test.class.dialog.border.title.test.class=測試類別
actions.new.test.class.dialog.label.directory=目錄:
actions.new.test.class.dialog.label.fqn=完全限定名稱:
actions.new.test.class.dialog.label.name=名稱:
actions.new.test.class.dialog.label.namespace=命名空間:
actions.new.test.class.dialog.select.methods.show.inherited.methods=顯示繼承的方法(&I)
actions.new.test.class.dialog.title=建立新的 PHP 測試
actions.new.test.class.dialog.title.named=為 {0} 建立新的 PHP 測試
add=新增
add.catch.clause.quick.fix=新增 'catch' 從句
add.clarifying.parentheses=新增澄清括號
add.class=新增類別…
add.class1=新增類別
add.constant.0.to.class.1.and.opens.containing.file.in.editor=將常數 ''{0}'' 新增到類別 ''{1}'' 並在編輯器中開啟包含的檔案
add.constant.declaration.quick.fix.text=新增常數
add.custom.format.function=新增自訂格式函式…
add.custom.format.function1=新增自訂格式函式
add.enum.declaration.quick.fix.text=新增枚舉 case
add.fluent.setter=新增 fluent setter
add.global.variable.quick.fix.family.name=新增全域變數
add.global.variable.quick.fix.text=新增 ''global \${0}''
add.phpunit.test.pattern=新增 PHPUnit 測試模式
add.port.in.ide.settings=將連接埠 {0} 新增到設定
add.property=新增 @property
add.remote.interpreter=新增遠端解釋器
add.return.type=新增返回值類型
add.rule=新增規則
add.serialize.magic.method=新增{0}方法
add.serialize.magic.methods=新增{0}方法
add.setter=新增 setter
add.slash.to.the.start=在開頭新增 '/'
add.test.class.method=新增測試類別/方法…
add.throw.before.exception=在表達式前面新增 'throw'
add.to.composer.json.quick.fix=向 composer.json 中新增 ''{0}''
add.to.excluded.files.action=將 \`{0}\` 新增到忽略的檔案
advanced.setting.php.code.vision.hierarchy.limit=Code Vision: 要處理的最大繼承實體數
advanced.setting.php.code.vision.usages.limit=Code Vision: 要搜尋的最大用法數
advanced.setting.php.max.chain.resolve.depth=解析成員參照的最大深度
advanced.setting.php.sql.completion.recursive.jumps.limit=補全: 尋找 SQL 查詢時要解析的最大元素數量
alias=別名
align.composer.log.console=對齊 Composer 日誌主控台
all.0=所有({0})
all.cases.of.backed.enum.must.have.a.value=備用枚舉的所有 case 必須包含值
all.exceptions.considered.checked=所有異常均被視為已檢查
all.scripts=<All scripts>
all.values=所有變數
all.versions=所有版本
always.show.pass.by.reference=始終顯示參照傳遞
an.alias.was.defined.for.method.0.which.exists.in.1=已為 {1} 中的方法 {0}() 定義別名
an.expanded.full.numeric.representation.if.requried.or.a.full.numeral.representation.like.y=擴展的完整數字表示(如果需要)，或完整數字表示(2022)
an.expanded.full.numeric.representation.of.a.year.at.least.4.digits.with.or=年份的擴展完整數字表示，至少 4 位數，帶 - 或 + (+2022)
an.object.s.clone.method.cannot.be.called.directly=無法直接呼叫物件的 '__clone()' 方法
analyzing.php.sdk=正在檢查 PHP 安裝…
and=和
annotation.expression.is.not.allowed.as.class.constant.value=表達式不允許為類別常量值
annotation.new.expression.abstract=無法實例化抽象類別 ''{0}''
annotation.new.expression.enum=無法實例化枚舉 ''{0}''
annotation.new.expression.interface=無法實例化接口 ''{0}''
annotation.new.expression.trait=無法實例化特徵 ''{0}''
annotation.variable.variable=可變變數
annotator.cannot.break.continue=無法中斷/繼續{0}級別
annotator.duplicate.default.match.condition=match 表達式只能包含一個 'default' 分支
annotator.duplicate.use.statement=無法使用 ''{0}''，因為該名稱已被使用
annotator.fix.remove=移除 ''{0}''
annotator.invalid.class.name=''{0}'' 是無效的類別名
annotator.jump.out.of.finally=不允許跳出 finally 塊
annotator.only.default.condition.allowed='default' arm 中僅允許單個 'default' 條件
annotator.reserved.class.name=無法使用 ''{0}'' 作為類別名，因為該名稱已被保留
annotator.special.class.name=無法將 {0} 用作 {1}，因為 ''{1}'' 是一個特殊的類別名
annotator.unhandled.match.argument=未處理的 'match' 實參
anonymous.0=匿名{0}
anonymous.class=匿名類別
anonymous.function=匿名函式
anonymous.function.expected=應為匿名函式
another.definition.with.same.name.exists.in.this.file=此檔案中存在另一個具有相同名稱的定義
argument.passed.must.be.of.the.type.0.1.given=傳遞的實參必須為 {0} 類型，給定的為 {1}
array.callback.must.have.exactly.two.elements=陣列回調必須正好有兩個元素
array.can.t.be.used.for.array.destructuring.assignment='array()' 不能用於陣列解構賦值
array.declaration.style=陣列/列表宣告樣式
array.index=陣列索引
array.only.updated.but.never.queried=陣列僅被更新，但從未被查詢
arrays.are.not.supported.as.operands.for.0=不支持將陣列用作 ''{0}'' 的動作數
attribute.can.be.added.to.overridden.method=可以將特性新增到覆寫方法
attribute.can.be.added.to.overridden.parameter=可以將特性新增到覆寫參數
attribute.must.be.first.child.of.parent.element=特性必須是父元素的第一個子項
attributes.are.inapplicable.for.constants=特性不適用於常數
auto.import.from.global.space=處理來自全域空間的符號
auto.import.from.global.space.class=類別:
auto.import.from.global.space.constant=常數:
auto.import.from.global.space.function=函式:
auto.import.from.global.space.prefer.fallback=回退優先
auto.import.from.global.space.prefer.fqn=FQN 優先
auto.import.from.global.space.prefer.import=匯入優先
auto.import.in.file.scope=在檔案作用域內啟用自動匯入
auto.import.in.namespace.scope=在命名空間作用域內啟用自動匯入
background.task.detect.namespace.roots.progress.title=正在檢測命名空間根…
bit.shift.by.negative.number=按負數進行移位
border.title.additional.dependencies=其他相依項
border.title.constant.syntax=常數語法
border.title.include.analysis=Include 分析
border.title.initialize.in=初始化位置
border.title.introduce.field=引入屬性
border.title.introduce.variable=引入變數
border.title.options=選項
border.title.php=PHP
border.title.require.dependencies='require' 相依項
border.title.require.dev.dependencies='require-dev' 相依項
border.title.visibility=可見性
build.control.flow=建置控制流(&B)
build.control.flow.with.exit.points=使用出口點建置控制流(&E)
button.sync.extensions.with.interpreter=將擴展與解釋器同步
cache.creating=正在建立 psalm 快取…
call.to.0.1.construct.from.invalid.context=從無效上下文呼叫 ''{0} {1}::__construct()''
call.to.method.clone.from.invalid.context=從無效上下文呼叫方法 '__clone'
call.tree=呼叫樹
callees=被呼叫方
callers=呼叫方
can.not.correctly.run.the.tool.with.parameters=無法使用參數正確執行該工具:
can.not.delete.temporary.file.because.it.was.not.created=無法刪除臨時檔案，因為未建立該檔案
can.not.execute.tests=無法執行測試
can.not.execute.transfer.task.project.is.already.disposed=無法執行傳輸任務: 專案已被處置
can.not.find.0.helper.script=找不到 ''{0}'' 幫助程序腳本
can.not.find.specified.interpreter=找不到指定的解釋器
can.not.parse.phpunit.version.output.0=無法解析 PHPUnit 版本輸出: {0}
can.not.run.command.composer.execution.plugin.was.unloaded=無法執行指令: Composer 執行延伸模組已移除
can.only.be.used.as.standalone.type={0} 僅可用作獨立類型
can.t.use.nullsafe.operator.in.write.context=在寫入上下文中不能使用 nullsafe 運算符
cancel=取消
cancel.ide.registration=取消 IDE 註冊
cannot.apply.0.to.interface=無法將 {0} 應用於接口
cannot.apply.0.to.readonly.class=無法將 {0} 應用於 ''readonly'' 類別
cannot.apply.0.to.trait=無法將 {0} 應用於特徵
cannot.call.abstract.method.0.1=無法呼叫 abstract 方法 ''{0}::{1}''
cannot.combine.nullsafe.operator.with.closure.creation=無法將 nullsafe 運算符與 'Closure' 建立組合
cannot.create.closure.for.new.expression=無法為 'new' 表達式建立 'Closure'
cannot.declare.dynamic.properties.in.readonly.class=不能在 'readonly' 類別中宣告動態屬性
cannot.declare.promoted.property.in.an.abstract.constructor=無法在 abstract 建構函式中宣告提升的屬性
cannot.declare.promoted.property.outside.a.constructor=無法在建構函式外部宣告提升的屬性
cannot.declare.self.referencing.constant=無法宣告自參照常數
cannot.declare.static.properties.in.readonly.class=不能在 'readonly' 類別中宣告 'static' 屬性
cannot.declare.variadic.promoted.property=無法宣告可變提升屬性
cannot.implement.interface.0=無法實作接口 ''{0}''
cannot.implement.interface.0.directly=無法直接實作接口 ''{0}''
cannot.inherit.previously.inherited.or.override.constant.0.from.interface.1=無法從接口 ''{1}'' 繼承先前繼承的常數 ''{0}'' 或將其覆寫
cannot.make.interface.method.non.static=無法將接口方法設為非 static
cannot.make.interface.method.static=無法將接口方法設為 static
cannot.mix.amp.and.pipe.in.type.declaration=類型宣告中不能混用 '\\\\&' 和 '|'
cannot.mix.and.list=不能混合 [] 與 list()
cannot.mix.keyed.and.unkeyed.array.entries.in.assignments=在賦值中不能混合鍵控和非鍵控陣列條目
cannot.override.final.constant=無法從 ''{1}'' 覆寫 final 常數 ''{0}''
cannot.redeclare.constant.0=無法重新宣告常數 ''{0}''
cannot.redeclare.methods.from.enum.implicit.interfaces=無法從枚舉隱式接口重新宣告方法
cannot.redeclare.non.static.0.1.as.static.2.3=無法將非 static ''{0}::\${1}'' 重新宣告為 static ''{2}::\${3}''
cannot.redeclare.static.0.1.as.non.static.2.3=無法將 static ''{0}::\${1}'' 重新宣告為非 static ''{2}::\${3}''
cannot.register.handler=無法註冊處理程序
cannot.use.0.as.lexical.variable=無法將 ''\${0}'' 用作詞法變數
cannot.use.class.on.primitive.type=只允許在物件上使用 '::class'
cannot.use.empty.array.elements.in.arrays=無法在陣列中使用空陣列元素
cannot.use.empty.array.entries.in.keyed.array.assignment=在鍵控陣列賦值中不能使用空陣列條目
cannot.use.empty.list=無法使用空列表
cannot.use.for.reading=無法使用 '[]' 進行讀取
cannot.use.match.as.identifier=無法將 'match' 用作關鍵字，自 PHP 8.0 起作為預留關鍵字
cannot.use.positional.argument.after.argument.unpacking=無法在實參解包後使用位置實參
cannot.use.positional.argument.after.argument.unpacking.named.argument.81=實參解包後的位置實參從 PHP 8.1 起才可用
cannot.use.positional.argument.after.named.argument=無法在命名實參後面使用位置實參
cannot.use.readonly.as.identifier=無法將 'readonly' 用作關鍵字。自 PHP 8.1 起作為預留關鍵字
cannot.use.static.as.function.return.type.declaration=不允許 'static' 作為類別作用域外部的返回值類型宣告
cannot.use.this.as.parameter=不能將 $this 用作參數
cannot.use.traits.inside.of.interfaces=無法在接口內部使用特徵
cannot.use.unpacking.in.attribute.argument.list=無法在特性實參列表中使用解包
cannot.use.yield.from.inside.a.by.reference.generator=不能在參照傳遞產生器中使用 'yield from'
cant.save.interpreter=無法儲存 ''{0}'': {1}
cant.use.temporary.expression.in.write.context=在寫上下文中不能使用臨時表達式
case.of.non.backed.enum.must.not.have.a.value=非備用枚舉的 case 不得包含值
caused.by.0=原因是:“{0}”
change.member.access=更改成員存取
change.method.modifiers.to.0=將方法修飾符更改為 ''{0}''
change.php.language.level=更改 PHP 語言級別
change.signature.arg.type.incompatible=應為 ''{0}'' 類型的參數，提供的是 ''{1}''
change.signature.arg.type.miss.argument=應為 ''{0}'' 類型的參數
change.signature.column.name.parameter=參數:
change.signature.column.type.parameter=類型:
change.signature.error.wrong.caret.position=文字游標應置於要重構的函式的名稱處。
change.signature.find.usages.of.base.class=類別 {1} 的方法 {0}\\n\\
重寫了類別 {2} 的方法。\\n\\
要{3}基方法嗎?
change.signature.find.usages.of.base.interface=類別 {1} 的方法 {0}\\n\\
實作了接口 {2} 的方法。\\n\\
要{3}基方法嗎?
change.signature.initialize.new.parameters=建立並初始化類別屬性(&I)
change.signature.parameter.may.have.side.effect=用作參數“{1}”的表達式“{0}”可能會有副作用
change.signature.tooltip.default.value=要在此方法的所有現有呼叫中使用的值
change.signature.tooltip.parameter=$name = 'init' 或 &...$array = 'init'
change.signature.usage.view.declarations.header=要重構的函式
change.signature.visibility.not.accessible=可見性為 {1} 的{0}將無法從{2}存取
checkbox.add.a.comma.after.last.argument.in.function.call=在函式呼叫中的最後一個實參後新增逗號
checkbox.add.a.comma.after.last.element.in.multiline.array=在多行陣列中的最後一個元素之後新增逗號
checkbox.add.a.comma.after.last.match.arm=在最後一個 match arm 後新增一個逗號
checkbox.add.a.comma.after.last.parameter=在參數列表中的最後一個參數後新增逗號
checkbox.add.a.comma.after.last.var.in.closure.use.list=在閉包 use 列表中的最後一個變數後新增逗號
checkbox.add.packages.as.libraries=作為庫新增軟體套件(&A)
checkbox.add.phpdoc=新增 PHPDoc(&D):
checkbox.align.parameter.property.names=對齊參數/屬性名稱
checkbox.align.tag.comments=對齊標記註釋
checkbox.always.enable.php.code.background.highlighting=始終啟用 PHP 程式碼背景醒目提示顯示
checkbox.anonymous.classes=匿名類別
checkbox.blank.line.before.the.first.tag=在第一個標記前使用空行
checkbox.blank.lines.around.parameters=在參數周圍使用空行
checkbox.check.clone.method=檢查 '__clone' 方法
checkbox.check.destruct.method=檢查 '__destruct' 方法
checkbox.check.sleep.method=檢查 '__sleep' 方法
checkbox.check.wakeup.method=檢查 '__wakeup' 方法
checkbox.force.short.declaration.style=強制短宣告樣式
checkbox.ignore.empty.functions=忽略空函式
checkbox.ignore.test.methods=忽略測試方法
checkbox.keep.blank.lines=保留空行
checkbox.lambdas=Lambda
checkbox.move.to.another.class=移至另一個類別(&M)
checkbox.rename.only.nearest.scope=僅重新命名最近作用域中的變數
checkbox.show.class.namespace.separators=顯示 PHP 類別和命名空間分隔符
checkbox.sort.phpdoc.tags=對 PHPDoc 標記排序
checkbox.static=static
checkbox.use.as.a.default.template=用作預設模板
checkbox.use.composer=新增 'composer.json'
checkbox.use.fully.qualified.class.names=使用完全限定類別名
checkbox.wrap.long.lines=長行換行
checking.for.changes.in.code.of.dependencies=正在檢查相依項程式碼中的更改
choose.a.valid.0.launcher=選擇有效的 {0} 啟動器
choose.an.alias.to.use=選擇要使用的別名
choose.class=選擇類別
choose.elements.to.generate.phpdoc.for=選擇要為其生成 PHPDoc 的元素
choose.executable.class.to.run.0=選擇用於執行 {0} 的可執行類別
choose.methods.to.implement=選擇要實作的方法
choose.methods.to.implement1=選擇要實作的方法
choose.methods.to.override=選擇要覆寫的方法
choose.php.home=選擇 PHP 可執行檔案
choose.properties=選擇屬性
choose.super.class.or.interface=選擇超類別或接口
choose.super.method=選擇 super 方法
choose.test.method.to.run.dataset.0=選擇測試方法以執行資料集 {0}
class=類別
class.cannot.extend.from.trait=類別無法從特徵擴展
class.cannot.implement.previously.implemented.interface=類別無法實作先前實作的接口
class.constant=類別常數
class.constant1=類別常數
class.constructor=類別建構函式
class.declarations.may.not.be.nested=類別宣告不能被嵌套
class.implements.solely.traversable=類別 ''{0}'' 必須將接口 Traversable 作為 Iterator 或 IteratorAggregate 的一部分來實作
class.implements.the.serializable.interface.which.is.deprecated=在不使用 '__serialize()'/'__unserialize()' 方法的情況下實作 'Serializable' 接口已棄用
class.name=類別名
class.ref.is.deprecated=類別 '#ref' 已棄用
class.reference=類別參照
class.should.not.implement.itself=類別不應自行實作
class1=類別
class2=類別
classes.can.not.have.backed.type=類別不能有備用類型
classes.named.never.is.forbidden.in.php.8.1=PHP 8.1 中禁止名為 'never' 的類別
classes.named.object.are.forbidden.in.php.7.2=PHP 7.2 中禁止名為 'object' 的類別
classes.named.void.and.iterable.are.forbidden.in.php.7.1=PHP 7.1 中禁止名為 'void' 和 'iterable' 的類別
classes.without.member=層次結構中不帶 ''{0}'' 的類別
cleaning.up=正在清理…
clear.log=清除日誌
clearing.cache=正在清除快取
cli.interpreters.name=CLI 解釋器
close=關閉(&C)
closest.scope=最近作用域中的變數
code.fully.qualified.classname.methodname.key.value.code.example.precise.match={0} 是一個精確排除的範例。
code.global.code.matches.function.with.two.parameters={0} 符合帶有兩個參數的函式。
code.info.code.matches.all.single.parameter.methods.where.the.parameter.name.ends.with.em.info.em={0} 符合參數名以 {1} 結尾的所有單參數方法。
code.key.value.code.matches.all.methods.with.parameters.em.key.em.and.em.value.em={0} 符合所有具有參數 {1} 和 {2} 的方法。
code.size.rules=程式碼大小規則
code.style.option.after='{' 之後:
code.style.option.after.class.body=類別主體之後:
code.style.option.after.colon.in.enum.backed.type=在備用枚舉中類型宣告旁邊的冒號後面
code.style.option.after.colon.in.named.argument=命名實參中的冒號之後
code.style.option.after.colon.in.return.type=返回值類型中的冒號之後
code.style.option.after.function=函式之後:
code.style.option.after.namespace=命名空間之後:
code.style.option.after.opening.tag=起始標記之後:
code.style.option.after.unary.not=一元非(!)之後
code.style.option.after.use.statements=在 'Use' 語句後:
code.style.option.align.consecutive.assignments=對齊連續賦值
code.style.option.align.constants=對齊常數
code.style.option.align.enum.cases=對齊枚舉 case
code.style.option.align.inline.comments=對齊內聯註釋
code.style.option.align.key.value.pairs=對齊鍵值對
code.style.option.align.properties.in.columns=對齊列中屬性
code.style.option.and=<?= 和 ?>
code.style.option.anonymous.function.parentheses=匿名函式括號
code.style.option.around.class.constants=類別常數周圍:
code.style.option.around.enum.cases=枚舉 case 周圍:
code.style.option.around.property=屬性周圍:
code.style.option.array.initializer.parentheses=陣列初始設定式圓括號
code.style.option.arrow.function.parentheses=箭頭函式括號
code.style.option.assignment.in.declare.statement=在 declare 語句中賦值
code.style.option.attributes=特性
code.style.option.before.class.body=類別主體之前:
code.style.option.before.colon.in.enum.backed.type=在備用枚舉中類型宣告旁邊的冒號前面
code.style.option.before.colon.in.named.argument=命名實參中的冒號之前
code.style.option.before.colon.in.return.type=返回值類型中的冒號之前
code.style.option.before.namespace=命名空間之前:
code.style.option.before.return.statement=在 'return' 語句前:
code.style.option.before.unary.not=一元非(!)之前
code.style.option.before.use.statements=在 'Use' 語句前:
code.style.option.between.and='?' 與 ':' 之間
code.style.option.between.group.use.statements=在 'Use' 語句組之間:
code.style.option.brackets.around.variable.expression=使用中括號將變數/表達式括起來
code.style.option.class.field.constant.groups=類別屬性/常數組
code.style.option.concatenation=串聯(.)
code.style.option.for.foreach.statements=for()/foreach() 語句
code.style.option.force.empty.functions.braces.in.one.line=將空函式/方法的大括號放在一行
code.style.option.function.call.parentheses=函式呼叫括號
code.style.option.function.constructor.call.arguments=函式/建構函式呼叫實參
code.style.option.function.declaration.parameters=函式宣告參數
code.style.option.function.declaration.parentheses=函式宣告括號
code.style.option.function.left.brace=函式左大括號
code.style.option.function.return.type=函式返回值類型
code.style.option.group.use=將 'use' 分組
code.style.option.in.anonymous.class.declaration=在匿名類別宣告中
code.style.option.in.closure.declaration=在閉包宣告中
code.style.option.in.function.declaration=在函式宣告中
code.style.option.in.namespace=在命名空間中
code.style.option.keep.and.on.one.line=將 ')' 和 '{' 保持在同一行
code.style.option.match.expression='match' 表達式
code.style.option.match.expression.align.match.arm.bodies=對齊 'match' arm 主體
code.style.option.multiline.arrays.lambdas=將多行陣列/匿名函式視為多行實參
code.style.option.multiplicative.operators=乘法運算符(*, /, %, **)
code.style.option.new.line.after=在第一個元素後換行
code.style.option.new.line.after.php.tag=在 '<?php' 標記後換行
code.style.option.null.coalescing.operator=null 合併運算符(??)
code.style.option.object.access.operator=物件存取運算符(->)
code.style.option.parameter.attributes=參數特性
code.style.option.php.opening.tag=PHP 起始標記
code.style.option.place.braces.for.constructor.always=始終
code.style.option.place.braces.for.constructor.as.is=保留原樣
code.style.option.place.braces.for.constructor.never=從不
code.style.option.place.for.constructor=放置建構函式的 '()'
code.style.option.place.on.new.line=將 ';' 置於新行中
code.style.option.place.on.new.line2=在最後一個元素後換行
code.style.option.relational.operators=關係運算符(<、>、<=、>=、<=>)
code.style.option.return.type.on.new.line=返回值類型位於新行中
code.style.option.shift.operators=移位運算符(<<,>>)
code.style.option.space.around.pipe.in.union.types=聯合類型的 | 周圍
code.style.option.unary.additive.operators=一元加法運算符(+,-,++,--)
code.vision.implementations.hint={0, choice, 1#1 個實作|2#{0,number}'{1,choice, |1#+}' 實作}
code.vision.inheritors.hint={0, choice, 1#1 個繼承者|2#{0,number}'{1,choice, |1#+}' 繼承者}
code.vision.overrides.hint={0, choice, 1#1 個覆寫|2#{0,number}'{1,choice, |1#+}' 覆寫}
code.vision.used.in.hint=由 {0}{1, choice, |1#+} 使用
color.settings.alias.primitive.type.hint=關鍵字//基元類型提示
color.settings.alias.reference=關鍵字//別名參照
color.settings.attributes=特性
color.settings.bad_character=未知字元
color.settings.braces=大括號和運算符//大括號
color.settings.brackets=大括號和運算符//中括號
color.settings.class=類別和屬性//類別
color.settings.comma=大括號和運算符//逗號
color.settings.comment=註釋
color.settings.concatenation=字串//串聯
color.settings.constant=關鍵字//常數
color.settings.doc.identifier=PHPDoc//關鍵字
color.settings.doc.method.identifier=PHPDoc//方法宣告
color.settings.doc.parameter=PHPDoc//參數
color.settings.doc.property.identifier=PHPDoc//屬性
color.settings.doc.var=PHPDoc//變數
color.settings.doccomment=PHPDoc//文本
color.settings.docmarkup=PHPDoc//標記
color.settings.doctag=PHPDoc//標記
color.settings.escape_sequence=字串//轉義序列
color.settings.exec_command=Shell 指令
color.settings.function=函式和方法//宣告
color.settings.function.call=函式和方法//函式呼叫
color.settings.goto.label=關鍵字//轉到標籤
color.settings.heredoc_content=Heredoc//Heredoc 內容
color.settings.heredoc_id=Heredoc//Heredoc ID
color.settings.identifier=關鍵字//預設
color.settings.instance.field=類別和屬性//實例屬性
color.settings.instance.method=函式和方法//實例方法呼叫
color.settings.instance.private.field=類別和屬性//private 實例屬性
color.settings.instance.private.method=函式和方法//private 實例方法呼叫
color.settings.instance.protected.field=類別和屬性//protected 實例屬性
color.settings.instance.protected.method=函式和方法//protected 實例方法呼叫
color.settings.interface=類別和屬性//接口
color.settings.keyword=關鍵字
color.settings.magic.member=關鍵字//魔術成員存取
color.settings.name=PHP
color.settings.named.arguments=命名實參
color.settings.number=數字
color.settings.operation=大括號和運算符//運算符
color.settings.parameter=函式和方法//參數
color.settings.parentheses=大括號和運算符//圓括號
color.settings.php.scripting=PHP 程式碼//背景
color.settings.php.tags=PHP 程式碼//標記
color.settings.predefined.symbols=關鍵字//預定義符號
color.settings.semicolon=大括號和運算符//分號
color.settings.static.field=類別和屬性//static 屬性
color.settings.static.method=函式和方法//static 方法呼叫
color.settings.string=字串//字元
color.settings.this.var=關鍵字//'$this' 變數
color.settings.var=關鍵字//變數
color.settings.var_var=關鍵字//可變變數
column.name.annotation.name=註解名稱
column.name.file.directory=檔案/目錄
column.name.parameter=參數
command.name.disable.synchronisation.with.composer=停用與 composer.json 同步
command.name.make.method.static=將方法設為 static
command.name.new.file=新增檔案
completion.press.again.to.see.all.classes=再次按 {0} 以檢視所有類別
completion.press.again.to.see.global.variants=再次按 {0} 以檢視全域變體
completion.press.again.to.see.more.variants=再次按 {0} 以檢視更多變體
composer=composer
composer.autoloader.generation.settings.name=自動載入器生成設定
composer.border.title.execution=執行
composer.border.title.package=軟體套件
composer.change.setting.action.name=更改設定
composer.checkbox.allow.unbound.version.constraints=允許未綁定的版本約束
composer.checkbox.autoload.classes.from.the.classmap.only=僅從類別映射自動載入類別
composer.checkbox.check.if.composer.lock.is.up.to.date=檢查 composer.lock 是否為最新
composer.checkbox.check.if.the.package.is.packagist.ready=檢查軟體套件是否為 Packagist 就緒
composer.checkbox.disable.autoload.dev.dependencies=停用 autoload-dev 相依項
composer.checkbox.download.composer.phar.from.getcomposer.org=從 getcomposer.org 下載 composer-stable.phar
composer.checkbox.optimize.autoloader.convert.psr.0.4.rules.to.a.classmap=最佳化自動載入器(將 PSR-0/4 規則轉換為類別映射)
composer.checkbox.skip.scripts.execution=跳過腳本執行
composer.checkbox.synchronize.ide.settings.with.composer.json=將 IDE 設定與 composer.json 同步(&S)
composer.checkbox.use.apcu.to.cache.found.not.found.classes=使用 APCu 快取找到/未找到的類別
composer.checkbox.validate.package.dependencies=驗證軟體套件相依項
composer.checking.for.changes.in.code.of.dependencies.task.title=檢查相依項程式碼中的更改
composer.clearing.cache.action.name=清除快取
composer.diagnose.task.title=診斷
composer.executable='composer' 可執行檔案
composer.generate.list.popup.title=生成
composer.generating.autoloader.task.title=生成自動載入器
composer.json.custom.invalid.json=json 無效
composer.json.custom.packages.done=自訂儲存庫已載入
composer.json.custom.packages.empty=找不到軟體套件。請檢查您的儲存庫
composer.json.exec.not.configured=自訂儲存庫無法載入。未組態 Composer 可執行檔案路徑
composer.json.file=composer.json 檔案
composer.json.open.tool.settings.intention=開啟工具設定
composer.json.packages.loading.error=軟體套件未重新載入
composer.json.packages.refresh=軟體套件正在重新整理
composer.json.packagist.packages.done=僅載入了 packagist 儲存庫
composer.json.path.not.configured=自訂儲存庫無法載入。未組態 composer.json 路徑
composer.label.can.be.time.consuming=可能較為耗時
composer.label.executable='composer' 可執行檔案
composer.label.filter.packages=篩選軟體套件(&F):
composer.label.label=標籤
composer.label.package=軟體套件:
composer.label.path.to.composer.json=composer.json 路徑(&C):
composer.label.phar=composer.phar
composer.label.the.settings.php.language.level.directories.may.be.updated=設定(Php 語言級別，目錄)可能已更新
composer.label.version.to.install=要安裝的版本:
composer.listing.licenses.task.title=列出授權
composer.packages.versions=Composer 軟體套件版本
composer.remove.action.name=移除(&R)
composer.require.package.task.title=需要 Composer 軟體套件
composer.revert.action.name=還原
composer.simulating.update.task.title=模擬更新
composer.update.composer.packages.task.title=更新 Composer 軟體套件
composer.update.composer.task.title=更新 Composer
composer.validate.dialog.action.button.title=驗證
composer.validating.task.title=驗證
composer.validation.settings.name=驗證設定
composer.version.update.hint=已安裝軟體套件的當前版本和可用更新。
composite.test.patterns=複合測試模式
config.file.doesnt.exist=組態檔案不存在
configurable.PhpDebugConfigurable.display.name=偵錯
configurable.PhpProjectConfigurable.display.name=PHP
configurable.PhpServerConfigurable.display.name=伺服器
configurable.PhpServersConfigurable.display.name=伺服器
configurable.PhpSmartKeysConfigurable.display.name=PHP
configurable.PhpTemplatesCommonConfigurable.display.name=模板
configurable.PhpTestFrameworksConfigurable.display.name=測試框架
configurable.QualityToolCommonConfigurable.display.name=品質工具
configure=組態
configure.php.include.paths=組態 PHP Include 路徑(&O)…
configure.suppressed.annotations=組態禁止的註解
configured.is.incorrect=組態的 {0} 不正確
conflict.class.constant.with.same.name.already.exists=此類別中已經定義了具有相同名稱的常數
conflict.class.with.same.name.already.exists=已經定義了具有相同名稱的類別
conflict.constant.with.same.name.already.exists=已經定義了具有相同名稱的常數
conflict.field.with.same.name.already.exists=此類別中已經定義了具有相同名稱的屬性
conflict.function.with.same.name.already.exists=已經定義了具有相同名稱的函式
conflict.method.with.same.name.already.exists=此類別中已經定義了具有相同名稱的方法
conflict.parameter.with.same.name.already.exists=已經定義了具有相同名稱的參數
conflict.tag.name.contains.close.tag=文本包含“{0}”
conflict.template.parameter.with.same.name.already.exists=已存在同名的模板參數
conflict.use.with.same.name.already.exists=已經定義名稱相同的 'Use' 語句
conflict.variable.with.same.name.already.exists=已經定義了具有相同名稱的變數
connection.failed.message=連線失敗。請檢查您的網絡連線並重試。
connection.port.is.busy=連接埠 {0} 繁忙
constant=常數
constant.0=常數 {0}
constant.expression.contains.invalid.operations=常數表達式包含無效運算
constant.ref.is.deprecated=常數 '#ref' 已棄用
constant.ref.is.deprecated1=常數 '#ref' 已棄用
constant.ref.not.found.in=在 {0} 中未找到常數 ''#ref''
constant.with.same.name.already.exists.in.0={0} 中已經存在名稱相同的常數
constants.defined.using.the.const.keyword.must.be.declared.at.the.top.level.scope=使用 'const' 關鍵字定義的常數必須在頂層作用域宣告
constants.may.only.evaluate.to.scalar.values.arrays.or.resources=常數的求值結果只能為標量值、陣列或資源
constructor.already.exists=建構函式已存在
constructor.field=建構函式欄位
constructors=建構函式
controversial.rules=有爭議的規則
convert.closure.to.arrow.function=將閉包轉換為箭頭函式
convert.concatenation.to.sprintf.call=將串聯轉換為 'sprintf()' 呼叫
convert.string.interpolation.to.concatenation=將字串內插轉換為串聯
convert.string.interpolation.to.sprintf.call=將字串內插轉換為 'sprintf()' 呼叫
convert.the.arrow.function.to.a.traditional.closure=將箭頭函式轉換為傳統閉包
copy=複製
copy.concatenated.string.to.clipboard=將串聯的字串複製到剪貼簿
copy.handler.is.dumb.during.indexing=在索引編制進行時複製類別將只是簡單地複製包含的檔案。您將必須手動更改命名空間和匯入。是否仍要繼續?
copy.switch.branch=複製 'switch' 分支
copy.to.namespace=目標命名空間:
coverage.is.not.supported.for.selected.run.profile=程式碼覆蓋率與所選執行組態檔案不相容
create.missing.target.method.fix=建立缺少的目標方法修復
create.new.class.quickfix=建立新類別
create.new.field.dialog.title=建立新字段
create.target.class.quick.fix=建立目標類別快速修復
creates.a.composer.json.file=建立 composer.json 檔案
creates.new.class.0.in.a.separate.file=在單獨的檔案中建立名為 ''{0}'' 的新類別
creates.new.class.method.0.in.a.separate.file=在單獨的檔案中使用方法 ''{1}'' 建立名為 ''{0}'' 的新類別
ction.run.on.3v4l.org.promotion.tooltip=您現在可以在 3v4l.org 上執行不同 PHP 版本的臨時檔案
custom.format.functions.dialog.class.placeholder=留空以新增純函式
custom.format.functions.dialog.format.index.title=格式字串模板的索引
custom.format.functions.dialog.validation.class.not.found=找不到類別 {0}
custom.format.functions.dialog.validation.format.index=索引必須為非負數
custom.format.functions.dialog.validation.function.not.found=找不到函式 {0}
custom.format.functions.dialog.validation.method.not.found=在 {1} 中找不到方法 {0}
day.of.the.month.2.digits.with.leading.zeros=月中幾號，2 位數，帶前導零(01到 31)
day.of.the.month.without.leading.zeros=月中幾號，不帶前導零(1 到 31)
dbgp.invalid.packet=無效數據包
dbgp.proxy=Xdebug 代理
dbgp.proxy.cannot.connect.to.host=無法連線到主機 ''{0}''
dbgp.proxy.cannot.connect.to.xdebug.proxy=無法連線到 ''{0}:{1}'' 上的 Xdebug 代理
dbgp.proxy.host=代理主機
dbgp.proxy.ide.key=IDE 鍵
dbgp.proxy.ide.register.error=無法使用 IDE 鍵 ''{0}'' 註冊 IDE
dbgp.proxy.ide.register.success=IDE 已成功使用 IDE 鍵 ''{0}'' 註冊
dbgp.proxy.ide.unregister.success=IDE 已成功註銷
dbgp.proxy.port=代理連接埠
dbgp.proxy.sending.request.to.xdebug.proxy=正在將請求發送到 Xdebug 代理…
dead.code.commented.out=註釋掉
dead.code.deleted=已刪除
debug.accept.connection=接受
debug.action.copy.as.title=將變數複製為 ''{0}''
debug.action.copy.as.was.fail.can.not.get.full.name=無法將變數複製為 ''{0}''，無法對完整的變數名求值
debug.action.copy.value.as.text=將值複製為…
debug.breakpoint.move.disabled=中斷點移動到解析的位置已被停用，從下一個偵錯會話開始將不會移動中斷點。您可以稍後在 <a href="open">PHP|偵錯</a>下將其啟用。
debug.breakpoint.resolved.disabled=中斷點解析已被停用，從下一個偵錯會話開始將不會解析中斷點。 您可以稍後在 <a href="open">PHP|偵錯</a>下將其啟用。
debug.breakpoint.resolved.notify.disabled=中斷點解析通知已被停用。您可以在 <a href="open">PHP|偵錯|進階設定</a>下將其啟用。
debug.breakpoint.was.moved=<br/>中斷點也已移至此行。
debug.breakpoint.was.resolved=此處的偵錯會話已暫停，因為 ''{0}'' 處的中斷點已被解析到此行。<br/>您可以<a href="disable">停用</a>中斷點解析或<a href="more">了解詳情</a>。<a href="dontshow">不再顯示</a>
debug.cannot.find.port=找不到可用連接埠
debug.cannot.map.local.file=檔案路徑未映射到伺服器上的任何檔案路徑。編輯路徑映射以解決此問題。
debug.cannot.start=無法啟動 ''{0}''
debug.cannot.start.listening.for.connections.from.0=無法開始偵聽來自 ''{0}'' 的連線
debug.check.firewall=請檢查您的防火牆設定
debug.checkbox.can.accept.external.connections=可以接受外部連線
debug.checkbox.ignore.z.ray.system.requests=忽略 Z-Ray 系統請求
debug.composite.value.presentation=[{0}]
debug.configure.servers=組態伺服器
debug.debug.port=偵錯連接埠:
debug.edit.ignored.paths.list=<a href="#a">編輯</a>跳過的路徑。
debug.edit.path.mappings=點擊以設定路徑映射
debug.error=錯誤
debug.error.cannot.evaluate.expression=無法對表達式求值
debug.error.cannot.evaluate.expression0=無法對表達式 ''{0}'' 求值
debug.error.cannot.evaluate.variables=無法對變數求值
debug.error.cannot.modify.value=無法修改值
debug.error.cannot.parse.server.name=要修復，請在遠端伺服器上建立環境變數 <i><b>PHP_IDE_CONFIG</b></i>。<br/><br/><i>Windows:</i> 設定 PHP_IDE_CONFIG="serverName=SomeName"<br/> <i>Linux / Mac OS X:</i> 匯出 PHP_IDE_CONFIG="serverName=SomeName"。
debug.error.cannot.parse.server.name.for.external.connection=無法為外部 {0} 連線解析伺服器名稱。
debug.error.cannot.parse.ssh.connection=無法從 $_SERVER[''SSH_CONNECTION''] 解析連接埠: ''{0}''
debug.error.server.name.is.empty=<i><b>$_SERVER["SERVER_NAME"]</i></b> 為空，這可能是 Web 伺服器組態錯誤所致。<br/><br/><i>Nginx:</i> 將 fastcgi 參數新增至 nginx 組態，<a href="http://wiki.nginx.org/PHPFcgiExample">更多</a><br/><i>Apache:</i> 為當前 VirtualHost 組態 ServerName，<a href="https://httpd.apache.org/docs/2.4/vhosts/name-based.html">更多</a>
debug.error.title.cannot.accept.external.0.connection=無法接受外部 {0} 連線
debug.error.unknown.debugger.id=未檢測到偵錯器擴展
debug.error.wrong.debugger.id=不支持 {0}
debug.expression.evaluation.fail=由於返回值未知，無法對表達式求值
debug.file.is.ignored=檔案 ''{0}'' 被跳過。
debug.function.was.added.to.skip.list=''{0}'' 已新增到跳過列表。
debug.ignore.connection=忽略
debug.incoming.connection.title.0=來自 {0} 的傳入連線
debug.label.file.path.in.project=專案中的檔案路徑:
debug.label.file.path.on.server=伺服器上的檔案路徑:
debug.label.max.simultaneous.connections=最大同時連線數:
debug.label.select.a.project.or.a.file.to.debug=選擇一個專案或檔案進行偵錯
debug.label.select.a.project.to.debug=選擇一個專案進行偵錯
debug.log.cant.register.breakpoint.no.remote=無法註冊中斷點。沒有本地路徑 ''{0}'' 的路徑映射
debug.log.cant.register.breakpoint.no.template.mapping=無法註冊中斷點。沒有到 PHP 行 ''{0}'' 的映射
debug.log.connection.was.terminated=偵錯連線在 ''{0}'':''{1}'' 上意外終止
debug.log.exception.break=異常中斷: {0} ({1})
debug.log.invalid.xdebug.message=由於 Xdebug 訊息無效，無法在中斷點處停止。\\n\\
要解決此問題，請切換到穩定版本的 Xdebug 或使用 'xdebug.remote_log' 選項收集日誌並建立錯誤報告。 
debug.log.path.mapping.remote.extracted=遠端: ''{0}'' <-> 提取: ''{1}''
debug.log.path.mapping.remote.local=遠端: ''{0}'' <-> 本地: ''{1}''
debug.log.stack.frame=框架: {0}:{1}，{2}
debug.log.stop=停止於 (''{0}'':{1})
debug.mapping.resolve.dialog.stop.debugger=停止偵錯器
debug.not.installed=<未安裝>
debug.output=輸出
debug.path.on.server=伺服器上的絕對路徑
debug.php.breakpoint.failed.to.register=無法註冊中斷點，請嘗試將其停用並重新啟用。
debug.php.exception.breakpoint.dialog.title=新增異常中斷點
debug.php.exception.breakpoint.exception.name=異常名稱:
debug.php.exception.breakpoint.not.supported=載入的偵錯擴展不支持異常中斷點
debug.php.exception.breakpoint.title=PHP 異常中斷點
debug.php.exception.breakpoint.zend.not.supported=Zend Debugger 不支持異常中斷點
debug.php.external.connection.finished.break.at.first.line=<b><i>'在第一行中斷'</i></b> 選項已啟用
debug.php.external.connection.finished.break.at.first.line.title=PHP 偵錯組態
debug.php.external.connection.finished.warning=這可能是由於路徑映射組態錯誤或本地和遠端專案未同步。<br/><br/>要找出問題，請在 <b><i><a href="servers">PHP|伺服器</a></i></b>下檢查 ''{0}'' 伺服器的路徑映射組態，或啟用 <b><i><a href="break">''在 PHP 腳本中的第一行中斷''</a></i></b> 選項(位於<i>執行</i>選單下)。<br/><a href="ignore">不再顯示</a>
debug.php.external.connection.finished.warning.title=偵錯會話已完成且未暫停
debug.php.line.breakpoint.title=PHP 行中斷點
debug.php.method.breakpoint.dialog.title=新增方法中斷點
debug.php.method.breakpoint.title=PHP 方法中斷點
debug.php.method.breakpoint.zend.not.supported=Zend Debugger 不支持方法中斷點
debug.port.is.updated=設定中指定的連接埠 {0} 正在使用中。連接埠 {1} 可用，可由 Xdebug 使用。請使用 {2} 更新 php.ini
debug.port.is.updated.descr=設定中指定的連接埠 {0} 正在使用中。連接埠 {1} 可用，可由 Xdebug 使用。
debug.ports.is.updated=設定中指定的所有連接埠都在使用中。連接埠 {0} 可用，可由 Xdebug 使用。請使用 {1} 更新 php.ini
debug.process.cannot.find.file=在本地找不到檔案 ''{0}''。\\n\\
要修復，請通過環境變數 PHP_IDE_CONFIG 設定伺服器名稱，然後重啟偵錯會話。
debug.process.cannot.find.file.in.project=在專案中找不到路徑為 ''{0}'' 的檔案
debug.process.cannot.find.file.link=更多資訊
debug.process.cannot.find.local.file=在伺服器 {0} 上找不到檔案的本地副本\\n\\
本地路徑為 {1}
debug.process.cannot.find.path.mapping=遠端檔案路徑 ''{0}'' 未映射到專案中的任何檔案路徑
debug.process.cannot.find.remote.copy.local.file=專案 ''{0}'' 中的檔案路徑未映射到伺服器上的任何檔案路徑
debug.process.cannot.find.server.name=找不到源位置。名稱為 ''{0}'' 的伺服器不存在。
debug.process.cant.compute.source.position=無法計算源位置。腳本 ''{0}'' 未與任何文本檔案類型關聯。
debug.process.console.error.format={0}: {1}，{2} 中的第 {3} 行\\n\\

debug.process.script.outside.project=腳本 ''{0}'' 在專案外部。
debug.process.smart.step.into.function.evaluation.error =無法對目標函式求值。將執行“單步跳入”。
debug.process.smart.step.into.function.was.not.executed=尚未呼叫所選函式。
debug.process.smart.step.into.popup=步入函式
debug.process.status.connected=已連線
debug.process.status.disconnected=已斷開連線
debug.process.status.wait=正在等待與{0} ''{1}'' 的傳入連線
debug.resolve.mapping.problem=解決路徑映射問題
debug.rest.client.error.cannot.evaluate.server.name=無法評估 '$_SERVER['SERVER_NAME']'。請確保為您的 Web 伺服器組態了正確的伺服器名稱。<br>點擊此<a href="help">鏈接</a>獲取更多資訊。
debug.rest.client.error.cannot.evaluate.server.name.title=無法通過伺服器名稱找到對應的“PHP|伺服器”
debug.server.can.not.detect.path.mappings.from.deployment=無法評估路徑映射: 未選擇目標部署伺服器
debug.server.detect.path.mappings.from.deployment=正在檢測現有路徑映射…
debug.server.detect.path.mappings.from.deployment.progress=正在為 ''{0}'' 專案分析路徑映射
debug.server.import.configuration.deployment=部署(&D):
debug.server.import.configuration.dialog.title=從部署組態匯入
debug.server.import.configuration.local=本地(&L)
debug.server.import.configuration.local.file.path=本地檔案路徑:
debug.server.import.configuration.mounted=已掛載(&M)
debug.server.import.configuration.path.to.remote.root=部署根的絕對路徑(&R):
debug.server.import.configuration.path.to.remote.root.mounted=本地: ''{0}'' -> 遠端: ''{1}''
debug.server.import.configuration.path.to.remote.root.mounted.label=已掛載目錄的遠端路徑(&R):
debug.server.import.configuration.path.to.remote.root.mounted.tooltip=遠端檔案的絕對路徑:<br>"已掛載目錄的遠端路徑" . "伺服器上的相對部署路徑" (來自部署路徑映射)
debug.server.import.configuration.path.to.remote.root.sftp=絕對遠端根: ''{0}''
debug.server.import.configuration.path.to.remote.root.sftp.tooltip=遠端檔案的絕對路徑:<br>"遠端根的絕對路徑" . "根路徑" (來自部署設定) . "伺服器上的相對部署路徑" (來自部署路徑映射)
debug.server.import.configuration.preview.border.title=預覽
debug.server.import.configuration.project=專案(&P):
debug.server.import.from.deployment.deployment.configurations.message=找到具有相關路徑映射的部署組態。
debug.server.import.from.deployment.deployment.root.label=部署根(&R):
debug.server.import.from.deployment.no.deployment.configurations.message=找不到合適的部署組態
debug.server.import.from.deployment.no.deployment.configurations.tooltip=組態部署根(如果不為空)
debug.server.import.from.deployment.radio=從部署匯入映射(&I)
debug.server.manually.select.file.message=選擇一個專案或檔案進行偵錯
debug.server.manually.select.file.or.project=手動選擇本地檔案或專案(&M)
debug.server.select.file.mapping=組態本地檔案路徑
debug.settings.auto.detect.ide.host=自動檢測 IDE IP:
debug.settings.broadcasting.port=設定廣播連接埠:
debug.start.listen.debug.connections=開始偵聽 PHP 偵錯連線
debug.stop.listen.debug.connections=停止偵聽 PHP 偵錯連線
debug.type.float=浮點
debug.type.int=int
debug.type.resource=資源
debug.xdebug=Xdebug
debug.xdebug.error.unsupported.protocol.version=不支持的 Xdebug 協議版本
debug.zend.cannot.accept.incoming.connection=無法接受來自 Zend Debugger 的傳入連線
debug.zend.debugger=Zend 偵錯器
debug.zend.debugger.settings.broadcasting=Zend Debugger 設定廣播
debug.zend.error.title.cannot.accept.external.xdebug.connection=無法接受外部 Xdebug 連線
debug.zend.required.protocol.version.0.or.higher=所需協議版本為 ''{0}'' 或更高版本
debugger.method=方法
declaration.in.parent.class.is.incompatible.with.interface=父類別中的宣告與接口不相容
declaration.must.be.compatible.with.0=宣告必須與 {0} 相容
declaration.must.be.compatible.with.super=宣告必須與父級相容
default=預設:
default.value=預設值
delete.assignment=刪除賦值
delete.case=刪除 'case'
delete.catch.statement=刪除 'catch' 語句
delete.elseif=刪除 'elseif'
delete.if=刪除 'if'
delete.redundant.method.override=移除方法
delete.redundant.switch.branch=刪除冗餘 'switch' 分支
delete.unused.element=刪除未使用的元素
delete.void.return.type=刪除 'void' 返回值類型
deprecated.form.of.callables=已棄用的可調用對象形式
design.rules=設計規則
diagnosing=正在診斷
dialog.error.title.php.extract.class=PHP 提取類別
dialog.message.cannot.create.file.because.project.already.disposed=由於專案已被處置，無法建立檔案
dialog.message.could.not.find.network.interface=找不到 {0} 網絡接口
dialog.message.do.you.want.to.upload.content.scratch.file.to.3v4l.org.make.it.public=是否要將臨時檔案的內容上傳到 3v4l.org 並將其公開?
dialog.message.docker.account.not.found=找不到 Docker 帳戶
dialog.message.docker.account.not.specified=未指定 Docker 帳戶
dialog.message.execution.quality.tools.in.untrusted.project.prohibited=禁止在不受信任的專案中執行品質工具
dialog.message.no.interface.addresses.for.network.interface=沒有 {0} 網絡接口的接口地址
dialog.message.port.cannot.be.negative.number=端口號不能為負
dialog.message.query.string.cannot.start.with=查詢字串不能以 '?' 開頭
dialog.message.server.host.cannot.be.empty=伺服器主機不能為空
dialog.message.unable.to.create.configurations.with.same.executable.path=無法使用相同的可執行檔案路徑建立組態:  {0}
dialog.title.configure.code.patterns=組態程式碼模式…
dialog.title.edit.phpunit.test.pattern=編輯 PHPUnit 測試模式
dialog.title.enter.tag.name=輸入標記名稱
dialog.title.inline.variable=內聯變數
dialog.title.select.methods.to.propagate.safe.delete=選擇要傳播安全刪除的方法
dialog.title.select.parameters.to.propagate.safe.delete=選擇要傳播安全刪除的參數
dialog.title.select.properties.to.initialize=選擇要初始化的屬性
difference.to.greenwich.time.gmt.with.colon.between.hours.and.minutes=與格林威治時間(GMT)的差值，小時和分鐘之間有冒號(+02:00)
difference.to.greenwich.time.gmt.without.colon.between.hours.and.minutes=與格林威治時間(GMT)的差值，小時和分鐘之間沒有冒號(+0200)
directories=目錄
display.name.directory.0=目錄 ''{0}''
do.not.ask.again=不再詢問
do.not.override=不覆寫
docker.compose.border.title.lifecycle=生命周期
docker.compose.coverage.file.failed.to.copy=無法從 Docker 容器複製覆蓋率結果
docker.compose.coverage.file.failed.to.extract=無法提取覆蓋率結果
docker.compose.coverage.file.is.not.found=找不到覆蓋率檔案
docker.compose.failed.to.start.container=啟動 docker-compose 服務失敗，請在命令行中啟動並重試
docker.compose.radio.button.always.start.a.new.container.docker.compose.run=始終啟動一個新容器('Docker-compose run')
docker.compose.radio.button.connect.to.existing.container.docker.compose.exec=連線到現有容器('Docker-compose exec')
docker.host.name.error=主機名與 <i>host.docker.internal</i> 不同
docker.host.name.error.descr=<i>host.docker.internal</i> 解析為主機使用的內部 IP 地址
download.validation.script=下載 Xdebug 驗證腳本
duplicate.value.in.enum.for.cases.0.and.1=case ''{0}'' 和 ''{1}'' 的枚舉中的重複值
duplicate.variable.0=重複的變數 ''{0}''
dynamically.declared.field=動態宣告的欄位
edit.custom.format.function=編輯自定義格式函式
edit.template=編輯模板
empty.extends.list=空 extends 列表
empty.implements.list=空實作列表
empty.pattern=空模式
empty.type=空類型
enable=啟用
enable.navigate.links.for.class.and.member.references=為類別和成員參照啟用“… 導覽”鏈接
enable.return.function.value.debugging.xdebug.3.2=啟用返回函式值偵錯 (Xdebug 3.2+)
enable.support=啟用支援
enable.the.following.extension=在 PHP 執行時選項中啟用以下擴展存根:
enable.tostring.object.view=啟用 '__toString' 物件檢視
enables.inspection.0=啟用檢查 ''{0}''
english.ordinal.suffix.for.the.day.of.the.month.2.characters=月中幾號的英語序數後綴，2 個字元(st、nd、rd、th)
enter.annotation=輸入註解
entry.points=入口點
entry.points.tab=入口點
enum=枚舉
enum.backing.type.must.be.int.or.string=枚舉支援類型必須為 'int' 或 'string'
enum.backing.type.must.be.int.or.string.0.given=在給出 ''{0}'' 的情況下，枚舉支援類型必須為 ''int'' 或 ''string''
enum.case=枚舉 case
enum.case.should.be.located.only.inside.enum.classes=枚舉 case 只應位於枚舉類別內部
enum.case.type.0.does.not.match.enum.backing.type.1=枚舉 case 類型 ''{0}'' 與枚舉支援類型 ''{1}'' 不符合
enum.case.value.must.be.constant=枚舉 case 值必須為常數
enum.may.not.include.0=枚舉不得包含 ''{0}''
enum.may.not.include.extend=枚舉不得擴展其他類別
enum.properties.are.immutable=枚舉屬性不可變
enum.value.cannot.referer.to.enum.cases=枚舉值不能參照枚舉 case
enums.may.not.be.cloned=不得克隆枚舉
enums.may.not.implement.the.serializable.interface=枚舉可能不會實作 'Serializable' 接口
enums.may.not.include.properties=枚舉不得包含屬性
error.cannot.connect.to.0=無法連線到 ''{0}''
error.cannot.connect.to.0.1=無法連線到 ''{0}'': {1}
error.cant.create.edge=無法建立關係鏈接
error.during.access.to.3v4l.org=存取 3v4l.org 時出錯
error.file.unable.create.selected.directory=無法在所選目錄中建立檔案 {0}
error.template.unable.create.from.internal.template=無法從內部模板 {0} 建立檔案
error.template.unable.parse.internal.template=無法解析內部模板 {0}
exception.analysis.settings.path=PHP/分析
exception.class=異常類別
exclude.0.from.1.analysis.a=從{1}分析中排除{0}。
executable.0.was.not.found.in.path.please.make.sure.it.s.there.possible.solutions=在 %PATH% 中找不到可執行檔案 ''{0}''。請確保已指定有效路徑。可能的解決方案:
executable.0.was.not.found.in.path.please.make.sure.it.s.there.possible.solutions1=在 $PATH 中找不到可執行檔案 ''{0}''。請確保已指定有效路徑。可能的解決方案:
execution.result.is.null=執行結果為 null
execution.statistics=執行統計
expected.class.reference=應為: 類別參照
expected.expression=應為: 表達式
expected.expression.after.spread.operator=應為: 展開運算符後的表達式
expected.property=屬性
explore.migration.guides=探索遷移指南
expression=表達式
expression.0=表達式 {0}
expression.is.not.allowed.as.constant.value=表達式不允許作為常量值
expression.is.not.allowed.as.field.default.value=表達式不允許為欄位預設值
expression.is.not.allowed.as.parameter.default.value=表達式不允許為參數預設值
expression.is.not.allowed.as.static.initializer=表達式不允許為 static 初始設定式
expression.is.not.assignable=表達式不可賦值
expression1=表達式
expressions=表達式
extends=擴展
extends.implements.overrides=擴展/實作/覆寫
extends.or.implements=擴展或實作
external.formatter.couldnt.run.tool={0} 無法啟動。請檢查您的組態。
external.formatter.phpcbf=PHP Code Beautifier and Fixer
external.formatter.phpcsfixer=PHP CS Fixer
extract.condition=提取條件
extract.method.link.label.more.options=更多選項
extract.method.parameter.name.column.title=參數
extract.method.selector.title=要提取的程式碼
extract.selected.string.part.as.concatenation.operand=將所選字串部分作為串聯動作數提取
extract.selected.string.part.as.format.function.argument=將所選字串部分作為格式函式實參提取
extract.side.effect=提取副作用
failed.to.find.interpreter=無法尋找解釋器
failed.to.find.valid.interpreter.path=無法尋找有效的解釋器路徑
failed.to.parse.php.ini.output.0=無法解析 php --ini 輸出: {0}
failed.to.run.interpreter=無法執行解釋器
field=欄位
field.name=欄位名稱
field.ref.is.deprecated=欄位 '#ref' 已棄用
field.ref.not.found=找不到欄位 '#ref'
field1=欄位
fields.cannot.be.declared.abstract=屬性不能宣告為 abstract
fields.cannot.be.declared.final=屬性不能宣告為 final
fields.default.visibility.panel=屬性預設可見性
fields.default.visibility.private=private
fields.default.visibility.protected=protected
fields.default.visibility.public=public
file=檔案
file.0.does.not.exist=檔案 {0} 不存在
file.0.does.not.exists=檔案 {0} 不存在
files.in.the.directory.should.be.accessible.by.0.request=目錄中的檔案應當可通過 {0} 請求進行存取。
files.in.the.remote.directory.should.be.accessible.by.0.request=遠端目錄中的檔案應當可通過 {0} 請求進行存取。
filetype.composer.log.description=Composer 日誌
filetype.doctrine.query.description=Doctrine 查詢語言
filetype.phar.description=Php Phar
filetype.phar.display.name=Php Phar
filetype.php.description=PHP
filetype.profiler.snapshot.description=分析器快照
final=final
final.class.cant.be.inherited=類別 {0} 為 final
final.modifier.is.not.allowed.here=此處不允許使用 'final' 修飾符
find.cause=尋找原因
find.classes.without.member=尋找沒有成員的類別
find.exception.cause.table.title=異常原因
find.field.accessors.text=是否要搜尋 ''{0}'' 的存取器?
find.field.accessors.title=搜尋存取器
find.options.include.child.methods.checkbox=包括覆寫/實作方法(&V)
find.usages.button.base.method=基方法
find.usages.button.current.method=當前方法
find.usages.prompt.dialog.implements=類別 ''{1}'' 的方法 ''{0}()'' 在 ''{2}'' 中實作了{3,choice,0#方法|1#方法}\\n\\
是否要尋找基{3,choice,0#方法|1#方法}的用法?
find.usages.prompt.dialog.overrides=類別 ''{1}'' 的方法 ''{0}()'' 在 ''{2}'' 中重寫了{3,choice,0#方法|1#方法}\\n\\
是否要尋找基{3,choice,0#方法|1#方法}的用法?
fix.not.available=修復不可用
fix.package.text=將命名空間 ''{0}'' 取代為 ''{1}''
fix.package.text.family=修復命名空間 
flip.key.value.intention.family.name=翻轉鍵和值
flip.key.value.intention.message.all.in.array=翻轉陣列中的所有鍵和值
flip.key.value.intention.message.single=翻轉鍵和值
fluent.setters=Fluent setter
folding.checkbox.collapse.classes=類別主體
folding.checkbox.collapse.function.body=函式體
folding.checkbox.collapse.heredocs.and.nowdocs=HEREDOC\\\\NOWDOC
folding.checkbox.collapse.imports=Import
folding.checkbox.collapse.method.body=方法體
folding.checkbox.collapse.php.tags=標記
follow.this.0.for.more.information.about.deployment=有關部署的詳細資訊，請參閱此{0}。
follow.this.0.for.more.information.about.path.mappings=有關路徑映射的詳細資訊，請參閱{0}。
follow.this.links.to.install.and.configure.0.or.1=點擊這些鏈接以安裝並組態 {0} 或 {1}。
for=for
foreach=foreach
found.roots.configured=檢測到並組態了 PSR-0 根
framework.composer=Composer
framework.composer.0.1.version.2={0} {1}，版本 {2}
framework.composer.add.composer.dependency.title=管理 Composer 相依項
framework.composer.add.dependency.available.packages.label=可用軟體套件
framework.composer.add.dependency.close.button=關閉(&C)
framework.composer.add.dependency.hide.tooltip=隱藏
framework.composer.add.dependency.install.button=安裝
framework.composer.add.dependency.no.new.version.found.for.0=找不到 {0} 的新版本。
framework.composer.add.dependency.no.package.selected=未選擇軟體套件
framework.composer.add.dependency.no.such.package=packagist 上無此類別軟體套件
framework.composer.add.dependency.no.version.selected=未選擇版本
framework.composer.add.dependency.running=正在執行
framework.composer.add.dependency.settings.cl.dialog.title=參數
framework.composer.add.dependency.settings.cl.label=命令行參數(&P):
framework.composer.add.dependency.settings.interpreter.label=PHP 解釋器:
framework.composer.add.dependency.settings.title=設定(&S)
framework.composer.add.dependency.show.output=顯示輸出
framework.composer.add.dependency.successfully.installed.0.version.1=已成功安裝 {0}，版本 {1}。
framework.composer.add.dependency.successfully.removed.0=已成功移除 {0}。
framework.composer.add.dependency.successfully.updated.0=已成功更新 {0}。
framework.composer.add.dependency.task.title=新增相依項
framework.composer.add.dependency.update.button=更新
framework.composer.available.version=可用版本:
framework.composer.checking.for.update=正在檢查更新…
framework.composer.configurable.title=Composer
framework.composer.create.project.from=自以下建立專案
framework.composer.create.project.progress.title=建立專案
framework.composer.default.composer.interpreter.name=Composer 的解釋器
framework.composer.default.interpreter.for.this.project.is.remote=此專案的預設解釋器是遠端解釋器，無法使用。
framework.composer.default.interpreter.is.not.configured=尚未為此專案組態預設解釋器。
framework.composer.default.project.interpreter=預設專案解釋器
framework.composer.empty.package.name.in.0={0} 中的軟體套件名稱為空
framework.composer.empty.path.to.0={0} 的路徑為空
framework.composer.expected.name.0.versions.0.description.got.1=應為 <name> {0} <versions> {0} <description>，獲得的是 {1}
framework.composer.failed.check.for.update=無法執行 'update --dry-run' 指令。
framework.composer.failed.to.0=無法{0}。
framework.composer.failed.to.0.1.script.was.cancelled=無法{0} {1}。腳本已被取消。
framework.composer.failed.to.download.composer.phar=無法下載 composer-stable.phar
framework.composer.failed.to.load.package.names=無法載入軟體套件名稱。
framework.composer.failed.to.parse.package.description=無法解析軟體套件描述。
framework.composer.failed.to.parse.package.names=無法解析軟體套件名稱。
framework.composer.file.0.is.not.found=找不到檔案 ''{0}''。
framework.composer.file.0.set.as.composer.config.change.setting.a.href.here.a=檔案 ''{0}'' 設定為 Composer 組態。
framework.composer.init.dialog.title.composer.settings=Composer 設定
framework.composer.initialize.popup=找到了 Composer 組態檔案 {0}。專案設定與其同步。
framework.composer.initialize.popup.multi.composer=找到 {0} 個 composer 組態檔案。專案設定已與其同步。
framework.composer.install.action.name=安裝
framework.composer.install.task.title=正在安裝軟體套件
framework.composer.interpreters.combo.default.interpreter=< 預設解釋器 >
framework.composer.interpreters.combo.default.interpreter.no.php.path=預設解釋器未提供 PHP 路徑
framework.composer.interpreters.combo.default.project.interpreter=< 預設專案解釋器 >
framework.composer.interpreters.combo.no.default.interpreter=預設設定中沒有預設解釋器
framework.composer.interpreters.combo.no.default.interpreter.in.project=此專案中沒有預設解釋器
framework.composer.label.installed.version=已安裝的版本:
framework.composer.label.version.to.install=要安裝的版本(&V):
framework.composer.load.update.availability=檢查可用軟體套件更新
framework.composer.loading.package.description=正在載入軟體套件描述
framework.composer.loading.packages=正在載入 Composer 軟體套件
framework.composer.loading.update.availability=正在檢查 Composer 軟體套件更新
framework.composer.name.composer=Composer
framework.composer.no.description.available=無可用描述。
framework.composer.no.package.versions.in.0={0} 中沒有軟體套件版本
framework.composer.notification.title.init.composer=初始化 Composer
framework.composer.notify.about.missing.vendor=缺少 'vendor' 目錄時通知
framework.composer.package.default.version=<預設>
framework.composer.package.version.available.0={0}的更新
framework.composer.packages.were.added.0.excluded.folders.popup=Composer 軟體套件已被新增到排除的目錄中。
framework.composer.packages.were.added.0.php.include.paths.popup=Composer 軟體套件已被新增到 PHP include 路徑中。
framework.composer.packages.were.changed.0.excluded.folders.popup=Composer 軟體套件已更改，因此更新了排除的目錄。
framework.composer.packages.were.changed.0.php.include.paths.popup=Composer 軟體套件已更改，因此更新了 PHP include 路徑。
framework.composer.packages.were.changed.0.test.config.popup={0} 組態已根據 composer.json 更新
framework.composer.packages.were.changed.0.test.config.title=Composer 軟體套件已被更改
framework.composer.packages.were.moved.to.0.php.include.paths.popup=Composer 軟體套件已從 Composer 外部庫移至 PHP include 路徑。
framework.composer.packages.were.removed.0.excluded.folders.popup=Composer 軟體套件已從排除的目錄中移除。
framework.composer.packages.were.removed.0.php.include.paths.popup=Composer 軟體套件已從 PHP include 路徑中移除。
framework.composer.path.dialog.path.to.composer=Composer 路徑
framework.composer.path.dialog.path.to.composer.json=composer.json 路徑
framework.composer.path.dialog.specify.composer.executable=指定 Composer 可執行檔案:
framework.composer.path.dialog.specify.composer.json=指定 composer.json:
framework.composer.path.dialog.specify.composer.phar=指定 Composer phar:
framework.composer.path.form.empty.path.to.composer.executable=Composer 可執行檔案路徑為空
framework.composer.path.form.empty.path.to.composer.json=composer.json 路徑為空
framework.composer.path.form.empty.path.to.composer.phar=composer.phar 路徑為空
framework.composer.path.form.execution.validation.wrapper=<html>執行未設定。<br/>{0}</html>
framework.composer.path.to.php.executable.titled=PHP 可執行檔案的路徑
framework.composer.path.validation.0.is.a.directory={0} 是目錄
framework.composer.project.generation.error.title=無法建立 Composer 專案
framework.composer.project.generator.description=通過 Composer 指令建立專案。
framework.composer.project.generator.failed.to.copy.temp.directory.0.content.to.project.root=無法將臨時目錄 ''{0}'' 內容複製到專案根目錄
framework.composer.project.generator.name=Composer 軟體套件專案
framework.composer.project.generator.notification.content.failed.to.find=找不到 {0}
framework.composer.project.generator.notification.content.failed.to.find.composer.json=無法在專案根目錄中找到 composer.json
framework.composer.remove.action.name=移除
framework.composer.removing.package.task.title=移除軟體套件
framework.composer.require.action.name=需要
framework.composer.require.task.title=正在安裝軟體套件 {0}
framework.composer.run.path.to.composer.json=composer.json 路徑:
framework.composer.run.script=腳本:
framework.composer.run.script.missing=未指定 Composer 腳本
framework.composer.script.run.configuration.description=Composer 腳本執行組態
framework.composer.script.run.configuration.name=Composer 腳本
framework.composer.selected.file.is.not.composer.json=所選檔案不是 composer.json
framework.composer.self.update.action.name=自我更新
framework.composer.self.update.task.title=更新 Composer
framework.composer.specify.php.executable.0=指定 PHP 可執行檔案 {0}
framework.composer.update.action.name=更新
framework.composer.update.task.title=正在更新軟體套件
framework.composer.updating.package.task.title=更新軟體套件
framework.composer.vendors.library.name=Composer 供應商
frameworks.composer.could.not.get.package.info=無法獲取軟體套件資訊。
frameworks.composer.could.not.get.packages.info.0=無法獲取軟體套件資訊。{0}
frameworks.settings.none.installed=沒有可用的框架設定提供程序。<br/>考慮安裝 Drupal Support、Joomla! Support 或 WordPress Support 延伸模組。
frameworl.composer.show.quick.actions=顯示具有快速動作的 composer.json 頂部面板
function=函式
function.call=函式呼叫
function.call.is.not.allowed.here=此處不允許使用函式呼叫
function.fqn=函式 FQN
function.has.parameter.with.incompatible.default.value.type=函式有一個預設值與其宣告的類型不相容的參數
function.name.must.be.callable.a.string.closure.or.class.implementing.invoke.currently.0=函式名稱必須可呼叫 - 字串、閉包或實作 ''__invoke'' 的類別，當前為 ''{0}''
function.ref.is.deprecated=函式 '#ref' 已棄用
function2=函式
functions.to.be.extracted=要提取的函式
generating.autoloader=正在生成自動載入器
getters.setters.configure=組態…
getters.setters.getters.first=getter 優先
getters.setters.naming.style=命名樣式:
getters.setters.order=Getter/Setter 順序:
getters.setters.setters.first=setter 優先
getters.setters.style=Getter/Setter 樣式
getting.installed.standards=正在獲取已安裝的標準…
global.code.should.be.enclosed.in.global.namespace.declaration=全域程式碼應包含在全域命名空間宣告中
global.namespace.should.use.braced.syntax=全域命名空間應使用帶大括號的語法
global.this.is.deprecated=不能將 $this 用作全域變數，它已在 PHP 7.1 中棄用
global.variable.from.globals.array.assignment=來自 $GLOBALS 陣列賦值的全域變數
globals.can.only.be.modified.using.the.globals.name.value.syntax='$GLOBALS' 只能使用 '$GLOBALS[$name] = $value' 語法進行修改
group.ComposerGroup.text=Composer
group.ComposerToolsGroup.text=Composer
group.DBGPProxyGroup.text=DBGp 代理
group.PHPQualityToolsAddToIgnoredList.text=新增到忽略列表…
group.PhpNewTestGroup.text=PHP 測試
group.advanced.settings.php=PHP
group.methods.by.type=按類型對方法分組
group.use.statements.by.selected.prefix=按所選前綴將 'use' 語句分組
guality.tool.configuration.show.ignored.files=顯示忽略的檔案
gutter.overriden.select.implementation.title=選擇 {0} 的實作
gutter.overriden.select.subclass.title=選擇 {0} 的子類別
gutter.overriding.select.title=選擇要導覽的父方法
gutter.pin.overriden.select.implementation.title={0} 的實作
gutter.pin.overriden.select.subclass.title={0} 的實作
gutter.pin.overriding.select.title={0} 的父項
guzzle.http.request.gutter.name=Guzzle HTTP 請求
guzzle.invalid.http.request.file=檔案 ''{0}'' 是無效的 HTTP 請求檔案
guzzle.name=Guzzle
guzzle.open.http.request=在 HTTP 請求編輯器中開啟
guzzle.unable.to.add.new.request.to.file=無法向 ''{0}'' 檔案新增新請求
guzzle.unable.to.extract.request.parameters=無法提取請求參數
halt.compiler.can.only.be.used.from.the.outermost.scope=僅可從最外側作用域使用 '__halt_compiler()'
handler.with.the.same.session.id.is.already.registered=已註冊使用相同會話 ID 的處理程序
hint.evaluation.fully.contains=求值結果完全覆蓋 ''{0}'' 的可能結果
hint.evaluation.makes.array.always.empty=求值使得陣列始終為空
hint.evaluation.makes.subsequent.condition.always.true=求值使後續條件始終為 '{0,choice,0#false|1#true}'
hint.text.can.not.find.target.class.for.modification=找不到要修改的目標類別。
hint.text.element.doesn.t.have.fqn=元素沒有 FQN
hint.text.installed.version=已安裝的版本
hint.text.target.class.does.not.belong.to.project.can.not.be.modified=目標類別 {0} 不屬於該專案\\n\\
並且無法修改。
hint.text.target.class.not.writable=目標類別 {0} 不可寫。
hint.text.use.statement.choice.s.removed={0} ''use'' 語句{1, choice, 0#|1#}已移除
hint.text.use.statements.checked.nothing.was.removed=已檢查 {0} ''use'' 語句，未移除任何內容
host.name.eg.localhost.example.com=主機名。例如，localhost.example.com
how.to.fix=修正方法
html.note.core.extensions.are.part.of.the.php.core.and.cannot.be.left.out.of.a.php.binary.with.compilation.options.html=<html>註: 核心擴展是 PHP 核心的一部分，不能放在包含編譯選項的 PHP 二進制檔案外部。</html>
http.client.request.init.debug.connection.title=正在初始化偵錯連線
identifier=關鍵字
if.with.common.parts=具有通用部分的 'if'
if.you.have.already.configured.debug.extension.in.php.ini.file.check.possible.reasons.why.it.was.not.loaded=如果已在 php.ini 檔案中組態偵錯擴展，請檢查未載入該擴展的可能原因:
if.you.ve.changed.the.path.recently.restart.the.ide=如果最近更改了 %PATH%，請重啟 IDE。
if.you.ve.changed.the.path.recently.restart.the.ide1=如果最近更改了 $PATH，請重啟 IDE。
ignore.imports.and.formatting=忽略匯入和格式設定
implement.method=實作方法
import=匯入
import.from.deployment.configuration=從部署組態匯入
import.references.on.paste.dialog.message=<html>貼上的程式碼段使用 {0}，後者在目標作用域中不能通過匯入存取。<br/>選擇您想要匯入到作用域中的{0}。</html>
import.references.on.paste.dialog.title=選擇要匯入的{0}
in=位於
in.0=\\ ({0} 中)
include.eol.slow=包括 eol (慢)
include.path=Include 路徑
include.path.column.info=路徑
incorrect.null.safe.operator=錯誤的 nullsafe 運算符
info=資訊
information=資訊
init.cache=初始化快取
initialize.var.quick.fix.family.name=使用值初始化
initializer=初始設定式
inject.language.using.phpdoc=使用 PHPDoc 注入語言
inlay.hints.usages.text={0,choice, 0#無用法|1#1 個用法|2#{0,number}'{1,choice, |1#+}' 用法}
insert.default.branch=插入 'default' 分支
inspection.array.access.can.be.replaced.with.foreach.value=陣列存取可被取代為 'foreach' 值
inspection.array.modification.will.not.have.any.effect=按值修改從函式返回的陣列不會有任何影響
inspection.array.to.string.conversion=陣列到字串的轉換
inspection.arrayfill.can.be.converted.to.loop='array_fill()' 呼叫可以轉換為迴圈
inspection.arrayfilter.can.be.converted.to.loop='array_filter()' 呼叫可以轉換為迴圈
inspection.arraymap.can.be.converted.to.loop='array_map()' 呼叫可以轉換為迴圈
inspection.assignment.in.condition=條件中的賦值
inspection.assignment.in.condition.move.assignment.out.of.condition.fix.name=從條件中移出賦值
inspection.assignment.replaceable.with=<code>#ref</code> 可被取代為 ''{0}'' #loc
inspection.closure.can.be.converted.to.arrow.function=閉包可以轉換為箭頭函式
inspection.closure.can.be.converted.to.first.class.callable='Closure::fromCallable()' 可以轉換為一級可調用語法
inspection.code.patterns.panel.description.label = 如果 fqn 名稱符合，則將程式碼標記為入口點
inspection.code.patterns.panel.description.text = 將方法留空以表示建構函式 \\n\\
 任何 * 都將與 fqn 名稱中的一個或多個字元符合
inspection.code.patterns.panel.errors.class = 模式必須是有效的 php fqn，僅接受 '*' 作為佔位符
inspection.code.patterns.panel.errors.member = 方法模式 {0} 必須是有效的 php 關鍵字，僅接受 ''*'' 作為佔位符
inspection.codeSmell.class.call.is.not.casesensitive=類別用法中的大小寫與宣告中的大小寫不符合
inspection.codeSmell.function.call.is.not.casesensitive=函式/方法呼叫中的大小寫與宣告中的大小寫不符合
inspection.codeSmell.namespace.reference.is.not.casesensitive=命名空間參照中的大小寫與宣告中的大小寫不符合
inspection.codeSmell.overriding.method.visibility.description=方法可見性不應被覆寫
inspection.composer.file.reference.problem=路徑 ''{0}'' 未找到
inspection.composer.json.file.references.inspection.display.name=未解析的檔案參照
inspection.constructor.style=舊式建構函式
inspection.curly.braces.access.syntax.usage=大括號存取語法自 PHP 7.4 已棄用
inspection.dead.code.problem.class.abstract.several.implementations={0} 具有{1, choice, 1#直接或間接實作|2# {1,number} 個直接或間接實作}，但<ul><li>其從未實例化或</li><li>不存在可從入口點到達的實例化。</li></ul>
inspection.dead.code.problem.class.nousages.synopsis=類別從未使用。
inspection.dead.code.problem.empty.constant.synopsis=常數從未使用。
inspection.dead.code.problem.empty.function.synopsis=函式從未使用。
inspection.dead.code.problem.multiple.constant.synopsis=常數有 {0, choice, 1#1 個用法|2#{0,number} 個用法}，但無法從入口點到達。
inspection.dead.code.problem.recursive.suspicious.function.synopsis=所有函式用法均屬於不存在可從入口點到達的成員的呼叫鏈。
inspection.dead.code.problem.single.constant.synopsis=常數有一個用法，但無法到達。
inspection.dead.code.problem.suspicious.function.synopsis=函式無法從入口點到達。
inspection.dead.code.problem.trait.additional.reachable=特徵具有可到達用法。
inspection.dead.code.problem.trait.additional.unreachable=特徵沒有可到達用法。
inspection.dead.code.problem.trait.synopsis=特徵從未使用。
inspection.deprecated.cast={0} 轉換自 PHP {1} 已棄用
inspection.deprecated.implode.usage=帶實參(陣列，字串)呼叫的 {0} 自 PHP 7.4 已棄用
inspection.disabled.quality.tool.inspection= {0} 檢查已停用
inspection.disabled.quality.tool.inspection.fix=啟用檢查
inspection.disabled.quality.tool.inspection.open.fix=開啟檢查設定
inspection.division.by.zero=除以零
inspection.doc.field.type.mismatch=屬性類型不符合
inspection.doc.missing.return.tag.problem=函式/方法 PHPDoc 註釋中缺少 @return 標記
inspection.doc.throws.option.skip.on.empty.phpdoc=忽略沒有 @param/@return 的 PHPDoc
inspection.doc.throws.problem=PHPDoc 註釋不包含所有必需的 @throws 標記
inspection.duplicate.array.keys.display.name=重複的陣列鍵
inspection.duplicate.array.keys.problem=重複的陣列鍵
inspection.duplicate.array.keys.problem.0=值為 ''{0}'' 的重複陣列鍵
inspection.duplicate.match.arm.body=''match'' arm 是 ''{0}'' arm 的重複項
inspection.duplicate.match.condition.message=重複條件
inspection.duplicate.phpdoc.type.fix=從標記中移除重複類型
inspection.duplicate.phpdoc.type.problem=重複的類型 ''{0}''
inspection.duplicate.switch.case.body=''switch'' 中的分支是 ''{0}'' 分支的重複項
inspection.dynamic.method.called.as.static.problem=非 static 方法 '#ref' 不應被靜態呼叫
inspection.dynamic.method.called.as.static.problem.magic=非 static 方法 '#ref' 不應被靜態呼叫，但類別具有 '__magic' 方法。
inspection.export.results.back.traces=反向追蹤
inspection.export.results.const=常數
inspection.expression.have.same.operands=表達式有相同動作數
inspection.expression.result.unused.problem=表達式結果未在任何位置使用
inspection.ext.is.specified.in.require.dev.but.used.outside.tests=''{0}'' 在 ''require-dev'' 部分中指定，但在測試外部使用
inspection.ext.is.specified.in.suggest=''{0}'' 在 ''suggest'' 中指定，可能不可用
inspection.family.name.replace.implicit.octal.literal.with.explicit.one=將隱式八進制文字取代為顯式八進制文字
inspection.field.assignment.type.mismatch=類型不相容: 應為 ''{0}'' 類型的屬性，提供的是 ''{1}''
inspection.field.assignment.type.mismatch.multi.resolve=賦值的類型 ''{0}'' 與屬性的宣告類型不相容
inspection.field.can.be.promoted=可以提升屬性
inspection.foreach.array.is.used.as.value.problem=變數 ''{0}'' 已被用作 ''array expression''
inspection.format.function.parameters.mismatch.conversion.specification=轉換規範未映射到任何參數
inspection.format.function.parameters.mismatch.parameter=參數未映射到任何轉換規範
inspection.fully.qualified.name.usage=限定符可被取代為匯入
inspection.fully.qualified.name.usage.name.option.ignore.global.namespace=忽略全域命名空間
inspection.fully.qualified.name.usage.option.enable.file.scope=在檔案作用域內啟用
inspection.group=PHP
inspection.group.code.smell=程式碼異味
inspection.group.code.style=程式碼樣式
inspection.group.control.flow=控制流
inspection.group.general=一般
inspection.group.naming.convention=命名約定
inspection.group.php.doc=PHPDoc
inspection.group.probably.bug=可能的錯誤
inspection.group.type.compatibility=類型相容性
inspection.group.undefined=未定義
inspection.group.unused=未使用
inspection.group.unused.quickfix.label=未使用的元素
inspection.group.unused.quickfix.message=未使用的元素: ''{0}''
inspection.hierarchyChecks=類別層次結構檢查
inspection.hierarchyChecks.descr=類別必須被宣告為 abstract 或實作 {0}
inspection.hierarchyChecks.field.type.redeclaration.match.super.type=類型必須為 ''{0}''(如基類別 ''{1}'' 中)
inspection.hierarchyChecks.field.type.redeclaration.must.not.be.defined=類型不得定義(如基類別 ''{0}'' 中)
inspection.hierarchyChecks.should.implement=類別必須實作 {0}
inspection.ignored.class.alias.declaration=忽略了類別名聲明
inspection.illegal.array.key.type.problem=非法陣列鍵類型
inspection.illegal.psr.class.path.class.is.not.matched.to.psr0={0}名稱與包含檔名不符合
inspection.illegal.psr.class.path.namespace.name.is.not.matched.to.psr0=命名空間名稱與 PSR-0/PSR-4 專案結構不符合
inspection.illegal.string.offset.problem=非法字串偏移 {0}
inspection.incompatible.return.type=返回值應為 ''{0}''，返回的是 ''{1}''
inspection.incompatible.return.type.batch=返回值類型與宣告不相容
inspection.incompatible.return.type.strict.type.checking=嚴格類型檢查
inspection.inconsistent.return.points.option.treat.return=在 'void' 函式/方法中以相同方式對待 'return null' 和 'return'
inspection.inconsistent.return.points.problem1=缺少 'return' 語句
inspection.inconsistent.return.points.problem1.yield=缺少 'yield' 語句
inspection.inconsistent.return.points.problem2=缺少返回實參
inspection.invalid.function.result.used.problem=使用了 ''{0}'' {1} ''{2}'' 結果
inspection.invalid.function.result.used.problem.function=函式
inspection.invalid.function.result.used.problem.method=方法
inspection.json.all.not.installed.packages=未安裝軟體套件
inspection.json.duplicated.packages.0=require 和 require-dev 中存在重複的 ''{0}'' 條目
inspection.json.duplicated.packages.fix=從 require-dev 中移除重複項
inspection.json.not.installed.package.update.fix=更新軟體套件
inspection.json.not.installed.packages=未安裝軟體套件
inspection.json.not.installed.packages.install.fix=安裝軟體套件
inspection.json.not.installed.packages.update.fix=更新所有軟體套件
inspection.language.level.quick.fix.switch.language.level.in.composer.0=切換到 composer.json 中的 PHP {0} 語言級別
inspection.language.level.quick.fix.switch.language.level.in.composer.manually.0=手動切換到 composer.json 中的 PHP {0} 語言級別
inspection.language.level.quick.fix.switch.language.level.name.0=切換到 PHP {0} 語言級別
inspection.loop.can.be.converted.to.arrayfill=迴圈可以轉換為 'array_fill()' 呼叫
inspection.loop.can.be.converted.to.arrayfilter=迴圈可以轉換為 'array_filter()' 呼叫
inspection.loop.can.be.converted.to.arraymap=迴圈可以轉換為 'array_map()' 呼叫
inspection.magic.method.visibility.cannot.be.static=魔術方法 ''{0}'' 不能為 static
inspection.magic.method.visibility.must.be.public=魔術方法 ''{0}'' 必須為 public
inspection.magic.method.visibility.must.be.static=魔術方法 ''{0}'' 必須為 static
inspection.mess.detector.validation.inspection.display.name=PHP Mess Detector 驗證
inspection.message.0.extends.class.with.final.tag=''{0}'' 會擴展帶有 @final 標記的類別
inspection.message.0.overrides.method.with.final.tag=''{0}'' 會覆寫帶有 @final 標記的方法
inspection.message.absolute.method.reference.should.be.specified.for.insteadof.trait.use.rule=應為 'insteadof' 特徵 use 規則指定絕對方法參照
inspection.message.always.true=條件始終為 '{0,choice,0#false|1#true}'
inspection.message.always.true.because=條件始終為 ''{0, choice, 0#false|1#true}''，因為此時 ''{1}'' 已經為 ''{2, choice, 0#false|1#true}''
inspection.message.always.true.because.evaluated=條件始終為 ''{0,choice,0#false|1#true}''，因為此時對 ''{1}'' 求值
inspection.message.argument.with.type.deprecated.for.this.call=類型為 ''{0}'' 的實參對此呼叫已棄用
inspection.message.argument.without.name.identifier=無名稱關鍵字的實參
inspection.message.array.always.empty.at.this.point=陣列在此點始終為空
inspection.message.array.index.immediately.rewritten.before.accessing=陣列索引在存取之前會被立即覆蓋
inspection.message.array.key.unused=陣列密鑰未使用
inspection.message.array.push.with.single.element=只有一個元素的 'array_push'
inspection.message.array.to.string.conversion=陣列到字串的轉換
inspection.message.array.traversable.can.be.replaced.with.iterable=類型提示 'array|Traversable' 可被取代為 'iterable'
inspection.message.array.values.call.redundant='array_values' 呼叫冗餘
inspection.message.array.write.access.unused=未使用陣列寫入存取
inspection.message.arrayshape.can.be.added=ArrayShape 可以新增
inspection.message.assert.always.will.be.false=實參類型不相容，因為 'assertTrue()' 執行與 'true' 的嚴格比較
inspection.message.assertion.always.true=斷言始終為 '{0,choice,0#false|1#true}'
inspection.message.assertion.always.true.because=斷言始終為 ''{0, choice, 0#false|1#true}''，因為此時 ''{1}'' 已經為 ''{2, choice, 0#false|1#true}''
inspection.message.assertion.always.true.because.evaluated=斷言始終為 ''{0,choice,0#false|1#true}''，因為此時已評估 ''{1}''
inspection.message.attribute.can.t.be.applied.to.because.it.doest.contains=特性不能應用於 {0}，因為它不包含 ''{1}'' 標誌
inspection.message.attribute.is.not.repeatable=特性不可重複，因為它不包含 'Attribute::IS_REPEATABLE' 標誌
inspection.message.behavior.unparenthesized.expressions.containing.both.will.change.in.php=同時包含 ''.'' 和 ''{0}'' 的無括號表達式可能會產生意外結果
inspection.message.branch.is.unused=從不執行 'switch' 分支
inspection.message.call.chain.too.long.to.analyse.break.it.into.fragments.up.to.calls=呼叫鏈過長，無法進行分析。請將其拆分為最多包含 {0} 個呼叫的片段
inspection.message.call.without.arguments.deprecated=不帶實參的 ''{0}'' 呼叫已棄用
inspection.message.calling.static.trait.member=直接呼叫 static 特徵成員已棄用。只應在使用特徵的類別上訪問。
inspection.message.can.be.final=可以為 'final'
inspection.message.can.be.merged.with=可以與 ''{0}'' 合併
inspection.message.can.be.removed=可以移除 ''{0}''
inspection.message.can.be.replaced.with=可被取代為 ''{0}''
inspection.message.can.be.replaced.with.assert.false=可被取代為 'assertFalse'
inspection.message.can.be.replaced.with.assert.true=可被取代為 'assertTrue'
inspection.message.can.be.replaced.with.const.syntax=可被取代為 'const' 語法
inspection.message.can.be.replaced.with.direct.parameter.access='func_get_arg' 可被取代為直接參數存取
inspection.message.can.be.replaced.with.fail=可被取代為 ''{0}''
inspection.message.can.be.replaced.with.in.array.call=可被取代為 ''{0}'' 呼叫
inspection.message.can.be.replaced.with.match.expression='if' 語句可被取代為 'match' 表達式
inspection.message.can.be.replaced.with.min.max.call=可被取代為 ''{0}'' 呼叫
inspection.message.can.be.replaced.with.named.argument=可被取代為命名實參
inspection.message.can.be.replaced.with.operator=可被取代為 '?->' 運算符
inspection.message.can.be.replaced.with.str.function=可被取代為 ''{0}''
inspection.message.can.be.replaced.with.version=表達式可被取代為 '??' 版本
inspection.message.cannot.assign.empty.string.to.string.offset=無法將空字串分配給字串偏移
inspection.message.cannot.create.references.to.from.string.offsets=無法建立到/從字串偏移的參照
inspection.message.cannot.increment.decrement.string.offsets=無法遞增/遞減字串偏移
inspection.message.cannot.make.method=無法將 {0} 方法設為 {1} {2}
inspection.message.cannot.make.method.visibility.lower.than.super.s=無法將方法的可見性設為低於父級的可見性
inspection.message.cannot.make.non.abstract.method.abstract=無法將非 abstract 方法設為 abstract
inspection.message.cannot.make.non.abstract.method.abstract.1=無法將非 abstract 方法 {0} 設為 abstract
inspection.message.cannot.make.non.static.method.static=無法將非 static 方法 {0} 設為 static
inspection.message.cannot.make.static.method.non.static=無法將 static 方法 {0} 設為非 static
inspection.message.cannot.override.final.method=無法覆寫 final 方法
inspection.message.cannot.override.final.method.1=無法覆寫 final 方法 {0}
inspection.message.cannot.stub.or.mock.using.method.list.that.contains.duplicates=不能使用包含重複項的方法列表進行存根或模擬
inspection.message.cannot.unset.string.offsets=無法取消設定字串偏移
inspection.message.cannot.use.assign.op.operators.with.string.offsets=無法將組合運算符賦值與字串偏移一起使用
inspection.message.cannot.use.string.offset.as.array=無法將字串偏移用作陣列
inspection.message.cannot.use.string.offset.as.object=無法將字串偏移用作物件
inspection.message.cast.evaluable=轉換可被取代為 ''{0}''
inspection.message.cast.redundant=類型轉換冗餘
inspection.message.class.can.be.readonly=類別不能為 'readonly'
inspection.message.class.does.not.have.attribute=類別 ''{0}'' 未使用 ''Attribute'' 註解
inspection.message.class.may.inherit.from.final.class=類別可能無法繼承 final 類別
inspection.message.class.ref.marked.as.internal=類別 '#ref' 已標記為 @internal
inspection.message.classes.cannot.be.doubled=''{0}'' 類別無法重複
inspection.message.clone.method.cannot.be.static='Clone' 方法不能為 static
inspection.message.code.fragment.too.complex.to.parse.this.piece.code.will.be.treated.as.plain.text=程式碼段過於複雜，無法解析，因此將作為純文本處理
inspection.message.comment.can.be.replaced.with.named.argument=註釋可被取代為命名實參
inspection.message.comment.will.be.parsed.as.attribute.starting.with.php=從 PHP 8.0 起註釋被解析為特性
inspection.message.concatenation.can.be.merged.with.assignment.empty.string.literal=串聯可以與空字串文字賦值合併
inspection.message.condition.is.never.matched=條件從未符合
inspection.message.constant.from.base.class.referenced.via.child.class=通過子類別參照的基類別 ''{0}'' 中的常數
inspection.message.constant.reassignment=常數重新賦值
inspection.message.constant.ref.marked.as.internal=常數 '#ref' 已標記為 @internal
inspection.message.constant.ref.not.found=未找到常數 '#ref'
inspection.message.constructor.cannot.be.static=建構函式不能為 static
inspection.message.continue.targeting.switch.equivalent.to.break=針對 'switch' 的 'continue' 相當於 'break'
inspection.message.control.flow.too.big.to.analyze=控制流太大，無法分析
inspection.message.count.used.as.array.index.to.append.element='count' 用作陣列索引以追加元素
inspection.message.dangerous.array.initialization=危險的陣列初始化
inspection.message.data.provider.method.should.be=資料提供程序方法應為 {0}
inspection.message.data.provider.method.should.not.require.arguments=資料提供程序方法不應需要實參
inspection.message.declaration.should.be.compatible.with=宣告應該與 {0} 相容
inspection.message.declaration.should.be.compatible.with.super=宣告應與父級相容
inspection.message.defining.custom.assert.function.deprecated=定義自定義 'assert()' 函式已棄用
inspection.message.defining.custom.assert.function.forbidden=禁止定義自定義 'assert()' 函式
inspection.message.deprecated.autoload.declaration='__autoload()' 宣告已棄用
inspection.message.destructor.cannot.be.static=解構函式不能為 static
inspection.message.doc.tag.without.variable.name.doesn.t.provide.type.information.for.any.expression=沒有變量名稱的 Doc 標記不提供任何表達式的類型資訊
inspection.message.double.quotes.are.unnecessary=雙引號不必要
inspection.message.duplicate.case.expression=重複 case 表達式
inspection.message.duplicate.case.expression.ref=重複 case 表達式: #ref
inspection.message.duplicate.character=重複字元
inspection.message.duplicates.catch.statement=重複 ''{0}'' 語句
inspection.message.element.already.covered.by=''{0}'' 已被 ''{1}'' 覆蓋
inspection.message.enum.field.reference.in.constant.expression.allowed.only.from.php=從 PHP 8.2 起才允許在常數表達式中參照枚舉欄位
inspection.message.exception.immediately.rethrown=立即重新拋出異常
inspection.message.exception.never.thrown.in.corresponding.try.block=相應的 ''try'' 塊中從未拋出異常 ''{0}''
inspection.message.existing.overriding.private.method.may.be.inaccessible=現有的覆寫 private 方法可能無法存取
inspection.message.existing.overriding.private.method.may.be.inaccessible.method=覆寫 private 方法 ''{0}'' 可能無法存取
inspection.message.exitpoint.attribute.can.be.added=可以新增 #[NoReturn] 特性
inspection.message.expression.always.choice=表達式始終為 ''{0}''
inspection.message.expression.have.duplicate.operand=表達式有重複的動作數 {0}
inspection.message.expression.not.changed.after.applying=套用 ''{0}'' 後，表達式不會改變
inspection.message.expression.without.parentheses=表達式沒有括號
inspection.message.extends.class.with.final.tag=擴展帶有 @final 標記的類別
inspection.message.field.assignment.can.be.converted.to.promoted.field=可以提升屬性
inspection.message.field.immediately.rewritten.before.accessing=屬性在存取之前會被立即覆蓋
inspection.message.field.ref.marked.as.internal=欄位 '#ref' 已標記為 @internal
inspection.message.for.loop.can.be.replaced.with.implode='foreach' 迴圈可被取代為 'implode()'
inspection.message.for.loop.can.be.replaced.with.str.repeat='for' 迴圈可被取代為 'str_repeat'
inspection.message.foreach.over.array.literal.with.single.element=對只有一個元素的陣列文字執行 'foreach'
inspection.message.from.php.this.allowed={0}。從 PHP {1} 起才允許這樣。
inspection.message.function.deprecated.will.be.removed.in.phpunit=方法已棄用並已在 PHPUnit 10 中移除
inspection.message.function.may.produce.side.effects=函式可能會產生副作用
inspection.message.function.ref.marked.as.internal=函式 '#ref' 已標記為 @internal
inspection.message.generators.may.only.declare.return.type.generator.iterator.or.traversable.or.iterable.permitted=產生器只能宣告 ''Generator''、''Iterator''、''Traversable'' 或 ''iterable'' 的返回值類型，不允許 {0}
inspection.message.get.class.call.can.be.replaced.with.class.name.literal='get_class()' 呼叫可被取代為 '::class'
inspection.message.goto.labels.inside.loops.or.switch.statements.are.not.allowed=不允許在迴圈或 switch 語句中使用 'goto' 標籤
inspection.message.if.can.be.replaced.with.version='if' 可被取代為 '??' 版本
inspection.message.if.statement.with.common.parts=包含通用部分的 ''{0}'' 語句
inspection.message.illegal.array.offset.access=嘗試存取類型為 ''{0}'' 的值的陣列偏移
inspection.message.immutable.property.write.scope.does.not.allow.write.access.here=無效的不可變屬性寫入: 作用域 ''{0}'' 不允許在此處進行寫入存取
inspection.message.instanceof.checks.in.catch.can.be.replaced.with.specific.catches='catch' 塊中的 'instanceof' 檢查可被取代為特定的 catch
inspection.message.interpolated.string.dereferencing.available.in.php.only=從 PHP 8.0 起才允許插值字串解參照
inspection.message.key.element.cannot.be.reference=鍵元素不能為參照
inspection.message.leading.slash.in.constant.fqn.will.not.be.trimmed.by.php=PHP 不會修剪常數 FQN 中的前導斜杠
inspection.message.local.object.used.only.for.writing.properties=區域物件僅用於寫入屬性
inspection.message.loop.can.be.replaced.with.0=迴圈可被取代為 ''{0}()''
inspection.message.magic.constant.dereferencing.available.in.php.only=從 PHP 8.0 起才允許魔術常數解參照
inspection.message.match.can.be.replaced.with.switch='match' 表達式可轉換為 'switch' 語句。
inspection.message.match.can.be.replaced.with.switch.changing.semantics='match' 表達式可以轉換為 'switch' 語句。請注意，'switch' 語句依賴於鬆散比較，這可能會改變表達式語意。
inspection.message.match.can.be.replaced.with.ternary='match' 表達式可被取代為三元表達式
inspection.message.max.must.be.greater.than.or.equal.to.argument.min='max' 實參必須大於或等於 'min'
inspection.message.method.may.produce.side.effects=方法可能會產生副作用
inspection.message.method.ref.marked.as.internal=方法 '#ref' 已標記為 @internal
inspection.message.method.reference.resolves.to.method.with.containing.class=''Use'' 規則解析為包含類別 ''{0}'' 中的方法
inspection.message.methods.cannot.be.mocked=''{0}'' 方法無法模擬
inspection.message.multiple.isset.calls.can.be.combined.into.one=可將多個 'isset' 呼叫合併為一個
inspection.message.name.parameter.may.be.different.depending.on.instance.class=在 ''{0}.{1}'' 中可能未解析命名實參
inspection.message.named.argument.usage=命名實參用法
inspection.message.nested.call.can.be.unwrapped=嵌套的 ''{0}'' 呼叫可以解包
inspection.message.never.returning.function.must.not.return='never' 返回函式不得返回
inspection.message.non.readonly.class.cannot.extend.readonly.class=非 ''readonly'' 類別不能擴展 ''readonly'' 類別 ''{0}''
inspection.message.non.readonly.property.readonly=無法將非 'readonly' 屬性重新宣告為 'readonly'
inspection.message.not.valid.backing.value.for.enum={0} 不是枚舉的有效支援值
inspection.message.only.first.byte.will.be.assigned.to.string.offset=只有第一個位元組將被分配給字串偏移
inspection.message.only.variables.can.be.passed.by.reference=僅可通過參照傳遞變數
inspection.message.operands.have.incompatible.types=動作數具有不相容的類型
inspection.message.overrides.method.with.final.tag=覆寫帶有 @final 標記的方法
inspection.message.parameter.name.changed.from.to=參數名稱由 ''{0}'' 更改為 ''{1}''
inspection.message.parentheses.are.unnecessary=圓括號不必要
inspection.message.pointless.boolean.expression=可以簡化布爾表達式
inspection.message.primitive.types.can.t.be.used.as.instanceof.argument=僅物件或字串應用作 ''instanceof'' 實參，當前: ''{0}''
inspection.message.prohibited.autoload.declaration=禁止使用 '__autoload()' 宣告
inspection.message.promoted.field.usage=提升的屬性用法
inspection.message.property.can.be.readonly=屬性可以為 'readonly'
inspection.message.property.only.read.but.never.written=屬性只讀取，但從未寫入
inspection.message.property.only.written.but.never.read=屬性僅寫入，但從未讀取
inspection.message.psr.compound.namespace.with.depth.more.than.two.levels=PSR-12: 複合命名空間的深度超過兩級
inspection.message.psr.missing.parameter.list=PSR-12: 缺少參數列表
inspection.message.psr.missing.visibility.definition=PSR-12: 缺少可見性定義
inspection.message.psr.order.modifiers.incorrect=PSR-12: 修飾符的順序不正確
inspection.message.psr.short.form.type.keywords.should.be.used=PSR-12: 應當使用類型關鍵字的縮寫
inspection.message.psr.traits.must.be.included.one.per.line=PSR-12: 必須以每行一個的形式新增特徵
inspection.message.psr.usage.else.if.construct=PSR-12: 使用 'else if' 結構
inspection.message.psr.usage.var=PSR-12: 'var' 的用法
inspection.message.pure.can.be.added=可以新增 ''{0}''
inspection.message.qualified.name.can.t.contain.whitespaces=限定名稱不能包含空格
inspection.message.readonly.class.cannot.extend.non.readonly.class=''readonly'' 類別不能擴展非 ''readonly'' 類別 ''{0}''
inspection.message.readonly.modifier.redundant='readonly' 修飾符冗餘
inspection.message.readonly.property.non.readonly=無法將 'readonly' 屬性重新宣告為非 'readonly'
inspection.message.redundant.argument={0, choice, 0#實參|1#實參}{0,choice,0#符合|1#符合}{0, choice, 0#參數的|1#參數的}預設{0, choice, 0#值|1#值}
inspection.message.redundant.assignment=冗餘的提升屬性賦值
inspection.message.redundant.expression=冗餘表達式
inspection.message.redundant.method.override=方法覆寫冗餘
inspection.message.redundant.parenthesis=冗餘圓括號
inspection.message.redundant.static.in.final.class=final 類別中有冗餘的 'static'
inspection.message.remove.final.tag=移除 '@final' 標記
inspection.message.remove.final.tag.from.0=從 ''{0}'' PHPDoc 註釋中移除 ''@final'' 標記
inspection.message.replace.implicit.octal.literal.with.explicit.one=隱式八進制文字可被取代為顯式八進制文字
inspection.message.results.postfix.expression.unused=未使用後綴表達式的結果
inspection.message.return.type.declaration.must.be.compatible.with=返回值類型宣告必須與 {0} 相容: {1}
inspection.message.return.value.method.never.used=方法的返回值從未使用
inspection.message.returning.by.reference.from.void.function.deprecated=從 void 函式通過參照返回已棄用
inspection.message.second.write.to.readonly.property=無法修改 'readonly' 屬性
inspection.message.should.be.one=值應為以下選項之一: {0}
inspection.message.should.probably.not.be.assigned=''{0}'' 可能不應分配給 ''{1}''
inspection.message.should.probably.not.be.passed.as.parameter=''{0}'' 可能不應作為參數 ''{1}'' 傳遞
inspection.message.spread.operator.can.be.unwrapped=展開運算符可以解包
inspection.message.spread.operator.over.literal.unnecessary.for.arguments.resolved.to.variadic.parameter=對於解析為可變參數的實參，文字上的展開運算符不必要
inspection.message.statement.can.be.collapsed.into.parameter.default.value=語句可以摺疊到參數的預設值中
inspection.message.switch.can.be.replaced.with.match='switch' 語句無法轉換為 'match' 表達式
inspection.message.switch.has.only.default.case=switch 只有 'default' case
inspection.message.switch.has.only.single.case=switch 只有一個 case
inspection.message.too.many.messages.per.file.only.first.errors.warnings.are.shown=每個檔案中的訊息過多。僅顯示前 {0} 條。
inspection.message.too.many.messages.per.line=每行的訊息過多
inspection.message.tostring.method.must.return.string='__toString' 方法必須返回字串
inspection.message.trait.usage=不允許特徵用法
inspection.message.type.can.be.reduced.to=類型範圍可以限縮為 ''{0}''
inspection.message.type.mismatch.should.be.conditional.expression=類型不符合: 應為條件表達式
inspection.message.uncovered.enum.cases='match' 表達式具有未被覆蓋的 enum case
inspection.message.uncovered.enum.cases.switch='switch' 語句有未被覆蓋的枚舉 case
inspection.message.undefined.goto.label.ref=未定義的 goto 標籤 '#ref'
inspection.message.unnecessary.cast.to.string=不必要地轉換為 ''{0}''
inspection.message.unnecessary.curly.braces=不必要的大括號
inspection.message.unnecessary.else=不必要的 'else'
inspection.message.unnecessary.leading.slash=不必要的前導 '\\'
inspection.message.unused.private.property.ref=未使用的 private 屬性 '#ref'
inspection.message.use.statement.with.non.compound.name.ref.has.no.effect=包含非複合名稱 '#ref' 的 'use' 語句沒有任何作用
inspection.message.using.in.strings.deprecated.use.instead=在字串中使用 {0} 已棄用，請改用 {1}
inspection.message.using.variable.variables.in.strings.deprecated.use.instead=在字串中使用 {0} (可變變數)已棄用，請改用 {1}
inspection.message.value.parameter.always=參數值始終為 ''{0}''
inspection.message.value.ranges.mismatch.expected.actual=值範圍不符合。應為: {0}，實際為: {1}
inspection.message.var.export.with.return.argument.equals.false.always.returns.null=帶等於 ''false'' 的 ''return'' 實參的 ''{0}'' 始終返回 ''{1}''
inspection.message.var.export.without.return.argument.always.returns.null=不帶 ''return'' 實參的 ''{0}'' 始終返回 ''{1}''
inspection.message.variable.already.equal.to.assigned.value=變數已等於賦值
inspection.message.will.be.covered.by=非必要條件，因為它由 ''{0}'' 檢查
inspection.message.with.single.string.argument=帶單個字串實參的 ''{0}''
inspection.message.write.access.to.readonly.property.outside.declaration.scope=無法寫入宣告作用域之外的 'readonly' 屬性
inspection.message.write.access.to.readonly.property.outside.declaration.scope.ret.by.ref='readonly' 屬性通過參照返回，可能會泄漏到宣告作用域之外
inspection.message.write.access.to.variable.that.still.references.array.value=對仍參照 'foreach' 中先前所用陣列值的變數的寫入權限
inspection.method.may.be.static=方法可以為 'static'
inspection.method.parameters.count.mismatch=為方法呼叫提供了 {0} 個參數，但方法簽名使用了 {1} 個參數
inspection.method.parameters.count.mismatch.option.ignore.func.get.arg=忽略帶有 func_get_arg/func_get_args 呼叫的函式/方法
inspection.method.parameters.count.mismatch.option.ignore.underscore=忽略最後一個參數為 $_ 的函式/方法
inspection.method.to.string.is.not.implemented=沒有為類別 ''{0}'' 實作方法 ''__toString''
inspection.method.to.string.is.not.implemented.strict.mode=檢查每種表達式類型是否存在 __toString
inspection.missing.break.statement.problem=缺少 'break' 語句
inspection.missing.doc.comment.options.panel.class=類別(&C)
inspection.missing.doc.comment.options.panel.class.constant=類別常數(&A)
inspection.missing.doc.comment.options.panel.constant=常數(&O)
inspection.missing.doc.comment.options.panel.field=屬性(&P)
inspection.missing.doc.comment.options.panel.function=函式(&F)
inspection.missing.doc.comment.options.panel.ignore.private.members=忽略 private 成員
inspection.missing.doc.comment.options.panel.method=方法(&M)
inspection.missing.doc.comment.problem=缺少 PHPDoc 註釋
inspection.missing.doc.comment.problem.batch={0} 缺少 PHPDoc 註釋
inspection.missing.ext.composer.json=composer.json 中缺少 ''{0}''
inspection.missing.ext.require.bundled=需要 PHP 捆綁的擴展
inspection.missing.field.type=缺少屬性的類型宣告
inspection.missing.parent.call.message=缺少父方法呼叫
inspection.missing.parent.constructor.call.message=缺少父建構函式呼叫
inspection.missing.strict.types.declaration=缺少嚴格類型宣告
inspection.missing.strict.types.declaration.add.declaration=新增嚴格類型宣告
inspection.missing_param=缺少所需參數 ''{0}''
inspection.mockery.protected.method.cannot.be.mocked=在不呼叫 'Mock.shouldAllowMockingProtectedMethods' 的情況下，無法對 'protected' 方法進行模擬
inspection.multiple.classes.declarations.in.one.file=在此檔案中宣告了另一個類別
inspection.naming.convention.element.description.class=類別
inspection.naming.convention.element.description.constant=常數
inspection.naming.convention.element.description.function=函式
inspection.naming.convention.element.description.method=方法
inspection.naming.convention.element.description.property=屬性
inspection.naming.convention.element.description.variable=變數
inspection.naming.convention.element.descriptor.regexp={0} 名稱 <code>#ref</code> 不符合正則表達式 ''{1}'' #loc
inspection.naming.convention.problem.descriptor.long={0} 名稱 <code>#ref</code> 過長({1} > {2}) #loc
inspection.naming.convention.problem.descriptor.short={0} 名稱 <code>#ref</code> 過短({1} < {2}) #loc
inspection.nested.ternary.expression=嵌套三元表達式自 PHP 7.4 已棄用
inspection.nested.vs.outer.foreach.variables.conflict.problem1=變數 ''{0}'' 作為鍵用於內部和外部 ''foreach'' 迴圈
inspection.nested.vs.outer.foreach.variables.conflict.problem2=變數 ''{0}'' 作為值用於內部和外部 ''foreach'' 迴圈
inspection.never.function.result.used.problem.type=從未
inspection.non.strict.object.equality=非嚴格物件相等比較
inspection.nullsafe.deref.unnecessary.because=Nullsafe 運算符{0,choice,0#將始終產生 ''null''|1#不必要}，因為此時 ''{1}'' 已經為 ''{2,choice,0#false|1#true}''
inspection.nullsafe.deref.unnecessary.because.evaluated=Nullsafe 運算符 ''{0,choice,0#將始終產生 ''null''|1#不必要}''，因為此時對 ''{1}'' 求值
inspection.option.label.php.severity=PHP {0} 嚴重性:
inspection.option.label.php73.severity=PHP 7.3 嚴重性:
inspection.option.label.php8.severity=PHP 8 嚴重性:
inspection.optional.before.required=可選參數在需要前提供
inspection.php.CS.fixer.validation.inspection.display.name=PHP CS Fixer 驗證
inspection.php.CS.validation.inspection.display.name=PHP_CodeSniffer 驗證
inspection.php.abstract.static.method.description=PHP 嚴格標準: static 方法 '#ref' 不應為 abstract
inspection.php.abstract.static.method.inspection.display.name=static 函式不應為 abstract
inspection.php.accessed.array.is.always.empty=陣列在存取點始終為空
inspection.php.acessing.static.trait.members=正在存取 static 特徵成員
inspection.php.add.line.break.after.trailing.comma=在尾隨逗號後新增換行符
inspection.php.argument.without.name.identifier=無名稱關鍵字的實參
inspection.php.arithmetic.type.check=帶有不支持動作數的算術運算
inspection.php.array.access.on.illegal.type.display.name=非法類型的陣列偏移存取
inspection.php.array.append.using.count=使用 'count()' 作為索引將值追加到陣列
inspection.php.array.fill.can.be.converted.to.loop.inspection.display.name='array_fill' 可以轉換為迴圈
inspection.php.array.filter.can.be.converted.to.loop.inspection.display.name='array_filter()' 呼叫可以轉換為迴圈
inspection.php.array.index.immediately.rewritten=陣列索引會被立即覆寫
inspection.php.array.key.does.not.match.array.shape=陣列鍵與陣列形狀不符合 
inspection.php.array.map.can.be.converted.to.loop.inspection.display.name='array_map()' 呼叫可以轉換為迴圈
inspection.php.array.push.with.single.element=只有一個元素的 'array_push()'
inspection.php.array.search.can.be.replaced.with.in.array='array_search()' 可被取代為 'in_array()' 呼叫
inspection.php.array.traversable.can.be.replaced.with.iterable=類型提示 'array|Traversable' 可被取代為 'iterable'
inspection.php.array.used.only.for.write.inspection.display.name=陣列僅用於寫存取
inspection.php.array.write.access.is.not.used=未使用陣列寫入存取
inspection.php.assert.declaration.is.deprecated=已棄用的 'assert()' 函式宣告
inspection.php.assignment.in.condition.inspection.display.name=條件中的賦值
inspection.php.assignment.replaceable.with.operator.assignment.inspection.display.name=賦值可被取代為運算符賦值
inspection.php.assignment.replaceable.with.prefix.expression.inspection.display.name=賦值可被取代為增量或減量
inspection.php.attribute.array.shape.can.be.added=可以新增 '#[ArrayShape]' 特性
inspection.php.attribute.can.be.overridden=可以將特性新增到覆寫成員
inspection.php.attribute.is.not.repeatable=不可重複的特性
inspection.php.attribute.no.return.can.be.added=可以新增 NoReturn 特性
inspection.php.autoload.declaration.is.deprecated=已棄用的 '__autoload()' 函式宣告
inspection.php.autovivification.on.false.values='false' 到陣列的自動轉換已棄用
inspection.php.autovivification.on.false.values.possible=可能會導致將 'false' 轉換為數組，這一轉換已棄用
inspection.php.boolean.expression.can.be.simplified=可以簡化布爾表達式
inspection.php.cast.is.evaluable=對標量值進行類型轉換
inspection.php.cast.is.unnecessary=類型轉換不必要
inspection.php.class.cant.be.used.as.attribute=類別不能用作特性
inspection.php.class.constant.accessed.via.child.class=通過子類別參照的類別常數
inspection.php.class.constant.can.be.final=類別常數可以為 'final'
inspection.php.class.implements.solely.traversable.inspection.display.name=類別無法直接實作 Traversable
inspection.php.class.naming.convention.inspection.display.name=類別名未遵循編碼約定
inspection.php.class.static.member.accessed.via.instance.inspection.display.name=通過實例存取的類別 static 成員
inspection.php.closure.can.be.converted.to.first.class.callable.inspection.display.name='Closure::fromCallable()' 可以轉換為一級可調用語法
inspection.php.closure.can.be.converted.to.short.arrow.function.inspection.display.name=閉包可以轉換為箭頭函式
inspection.php.comment.will.be.parsed.as.attribute=在 PHP 8.0 中註釋被解析為特性
inspection.php.composer.duplicated.requirement.inspection.display.name=composer.json 中存在重複的軟體套件條目
inspection.php.composer.extension.stubs.inspection.display.name=composer.json 中缺少擴展
inspection.php.compound.namespace.depth.inspection.display.name=複合命名空間深度大於 2
inspection.php.concatenation.with.arithmetic.usage=具有算術用法的串聯
inspection.php.concatenation.with.empty.string.can.be.merged=空字串的串聯可以與賦值合併
inspection.php.condition.always.evaluates.to.constant=條件的求值結果始終為 'true/false'
inspection.php.condition.can.be.replaced.with.min.max.call=條件可被取代為 'min()'/'max()' 呼叫
inspection.php.condition.checked.by.next.condition=邏輯表達式內部的條件由後續條件檢查
inspection.php.constant.naming.convention.inspection.display.name=常數名稱未遵循編碼約定
inspection.php.constant.reassignment.inspection.display.name=常數重新賦值
inspection.php.constructor.style.inspection.display.name=舊式建構函式
inspection.php.continue.targeting.switch='continue' 針對 'switch' 語句
inspection.php.covered.element.in.class=類別中的元素已被覆蓋
inspection.php.curly.brace.access.syntax.usage.inspection.display.name=使用了大括號存取語法
inspection.php.define.constant.can.be.replaced.with.const.syntax=define 常數名稱可被取代為 'const' 語法
inspection.php.define.constant.name.with.leading.slash=使用前導斜杠定義的常數名稱
inspection.php.delete.redundant.isset.calls=刪除冗餘的 'isset' 呼叫
inspection.php.deprecated.cast.inspection.display.name=棄用的轉換
inspection.php.deprecated.dollar.brace.string.interpolation=已棄用的 '\${' 字串內插
inspection.php.deprecated.implode.usage.inspection.display.name=棄用的 'implode/join' 用法
inspection.php.deprecated.modifier=自 PHP {1} 起修飾符 ''{0}'' 已棄用
inspection.php.deprecated.partially.supported.callables.display.name=已棄用的部分支援可呼叫物件
inspection.php.deprecated.serializable.interface.usage.inspection.display.name=已棄用的 'Serializable' 接口用法
inspection.php.deprecated.stdlib.call=已棄用的標準庫呼叫
inspection.php.deprecation.inspection.display.name=已棄用
inspection.php.disabled.extension.stubs.description=已停用的 ''{0}'' 擴展存根
inspection.php.disabled.extension.stubs.inspection.display.name=已停用的擴展存根
inspection.php.disabled.quality.tool.composer.inspection.display.name=品質工具檢查已停用
inspection.php.division.by.zero.inspection.display.name=除以零
inspection.php.doc.duplicate.type.inspection.display.name=類型已存在於 PHPDoc 標記中
inspection.php.doc.field.type.mismatch.inspection.display.name=類型與屬性的宣告類型不符合
inspection.php.doc.is.not.complete.inspection.display.name=PHPDoc 註釋簽名不完整
inspection.php.doc.missing.throws.inspection.display.name=缺少 @throws 標記
inspection.php.doc.redundant.throws.inspection.display.name=冗餘 @throws 標記
inspection.php.doc.signature.description=重複的實參 PHPDoc
inspection.php.doc.signature.description2=返回值類型與宣告的不符合
inspection.php.doc.signature.description3=不存在實參的 PHPDoc
inspection.php.doc.signature.description5=實參類型與宣告的不符合
inspection.php.doc.signature.inspection.display.name=PHPDoc 註釋符合函式/方法簽名
inspection.php.duplicate.case.inspection.display.name=switch 語句中存在重複的 case
inspection.php.duplicate.character.in.str.function.call=函式呼叫中的重複字元
inspection.php.duplicate.match.arm.body.inspection.display.name='match' 表達式中的重複 arm
inspection.php.duplicate.match.condition.inspection.display.name=重複條件
inspection.php.duplicate.operand.in.comparison=比較中的重複動作數
inspection.php.duplicate.switch.case.body.inspection.display.name=switch 語句中存在重複分支
inspection.php.duplicate.switch.catch.body.inspection.display.name='catch' 語句中的重複分支
inspection.php.dynamic.as.static.method.call.inspection.display.name=動態方法被呼叫為 static
inspection.php.dynamic.field.declaration=動態屬性宣告
inspection.php.element.is.not.available.in.current.php.version.inspection.display.name=元素在組態的 PHP 版本中不可用
inspection.php.empty.index.operator.not.supported.for.strings=字串不支持 '[]' 運算符
inspection.php.empty.index.operator.not.supported.for.strings.display.name=字串不支持的空索引運算符
inspection.php.enforce.doc.comment.inspection.display.name=強制執行 PHPDoc 註釋
inspection.php.enum.case.with.value.not.found=枚舉中找不到包含指定值的 case
inspection.php.exception.is.immediately.rethrown=立即重新拋出異常
inspection.php.expected.values.should.be.used=應使用預期值
inspection.php.expression.always.constant.inspection.display.name=到達時，變數始終為 true/false
inspection.php.expression.always.null.description='#ref' 始終為 'null'
inspection.php.expression.always.null.inspection.display.name=表達式始終為 'null'
inspection.php.expression.result.unused.inspection.display.name=未使用表達式結果
inspection.php.expression.with.same.operands.inspection.display.name=邏輯表達式有相同動作數
inspection.php.expression.without.clarifying.parentheses.inspection.display.name=表達式不帶澄清括號
inspection.php.field.assignment.type.mismatch.inspection.display.name=屬性賦值中的類型不符合
inspection.php.field.immediately.rewritten=屬性會被立即覆寫
inspection.php.foreach.array.is.used.as.value.inspection.display.name=Foreach 陣列用作值
inspection.php.foreach.nested.outer.key.value.variables.conflict.inspection.display.name=嵌套與外部 'foreach' 變數衝突
inspection.php.foreach.over.single.element=對只有一個元素的陣列文字執行 Foreach
inspection.php.foreach.variable.overwrite.already.defined.variable='foreach' 變數覆寫已定義的變數
inspection.php.format.function.call.with.single.argument=使用單個實參格式化函式呼叫
inspection.php.format.function.parameters.mismatch.inspection.display.name=格式函式參數不符合
inspection.php.fully.qualified.name.usage.inspection.display.name=使用了完全限定名稱
inspection.php.func.get.arg.can.be.replaced.with.parameter.access='func_get_arg()' 呼叫可被取代為參數存取
inspection.php.function.naming.convention.inspection.display.name=函式名稱未遵循編碼約定
inspection.php.get.class.can.be.replaced.with.class.name.literal.inspection.display.name='get_class()' 呼叫可被取代為 '::class'
inspection.php.goto.into.loop.inspection.display.name=Goto 轉入迴圈語句
inspection.php.group.attributes=特性
inspection.php.group.code.smell=程式碼異味
inspection.php.group.code.style=程式碼樣式
inspection.php.group.composer=Composer
inspection.php.group.control.flow=控制流
inspection.php.group.error.handling=錯誤處理
inspection.php.group.general=一般
inspection.php.group.naming.conventions=命名約定
inspection.php.group.phpdoc=PHPDoc
inspection.php.group.phpunit=PHPUnit
inspection.php.group.probable.bugs=可能的錯誤
inspection.php.group.psr.12=PSR-12
inspection.php.group.quality.tools=品質工具
inspection.php.group.regexp=正則表達式
inspection.php.group.replacable.assignments=可取代賦值
inspection.php.group.strict.standards=PHP 嚴格標準
inspection.php.group.type.compatibility=類型相容性
inspection.php.group.undefined=未定義的符號
inspection.php.group.unused=未使用的符號
inspection.php.highlight.only.closures.with.multiple.statements.option=僅醒目提示包含多條語句的閉包
inspection.php.idempotent.operation=二元表達式中的冪等運算
inspection.php.if.can.be.merged.with.sequential.condition='if' 可以與後續條件合併
inspection.php.if.can.be.replaced.with.match.expression='if' 可被取代為 'match' 表達式
inspection.php.ignored.class.alias.declaration.display.name=忽略的類別名聲明
inspection.php.illegal.array.key.type.description={0} {1}
inspection.php.illegal.array.key.type.inspection.display.name=非法陣列鍵類型
inspection.php.illegal.psr.class.path.inspection.display.name=類別路徑與專案結構不符合
inspection.php.illegal.string.offset.inspection.display.name=非法字串偏移
inspection.php.immutable.property.is.written.in.invalid.scope=在無效的作用域中寫入不可變屬性
inspection.php.implicit.octal.literal.can.be.replaced.with.explicit.one=隱式八進制文字可被取代為顯式八進制文字
inspection.php.in.array.can.be.replaced.with.comparison='in_array' 可被取代為比較
inspection.php.inapplicable.attribute.target.declaration=不適用的特性目標宣告
inspection.php.inappropriate.inherit.doc.usage.class.description=@inheritDoc 用於沒有帶 doc 註釋的父類別的類別
inspection.php.inappropriate.inherit.doc.usage.description=@inheritDoc 用於沒有父級成員但含有 doc 註釋的成員
inspection.php.inappropriate.inherit.doc.usage.description2=@inheritDoc 應僅用於類別成員
inspection.php.inappropriate.inherit.doc.usage.inspection.display.name=使用了不當的 @inheritDoc
inspection.php.include.description=無法解析表達式 ''{0}'' 的目標
inspection.php.include.description2=未找到路徑 ''{0}''
inspection.php.include.inspection.display.name=未解析的 include
inspection.php.incompatible.return.type.inspection.display.name=返回值類型不相容
inspection.php.inconsistent.return.points.inspection.display.name=不一致的返回點
inspection.php.incorrect.magic.method.signature.inspection.display.name=魔術方法簽名不正確
inspection.php.instanceof.checks.in.catch.can.be.replaced.with.specific.catches='catch' 塊中的 'instanceof' 檢查可被取代為特定的 catch
inspection.php.instanceof.is.always.true='instanceof' 的結果始終為 'true'
inspection.php.int.ranges.mismatch=數字範圍不符合
inspection.php.internal.array.index.reset.is.unnecessary=無需陣列內部指針重設
inspection.php.internal.array.index.reset.is.unnecessary.navigate.to.function=導覽到重設陣列內部指針的函式
inspection.php.internal.entity.used.inspection.display.name=使用了內部實體
inspection.php.invalid.delimiter.key=無效分隔符
inspection.php.invalid.instanceof.argument.type='instanceof' 的實參只應是物件或字串
inspection.php.invalid.magic.method.modifiers.inspection.display.name=魔術方法修飾符無效
inspection.php.invalid.string.offset.usage=字串偏移用法無效
inspection.php.isset.can.be.replaced.with.coalesce='isset' 可被取代為合併
inspection.php.isset.can.check.nested.access.directly='isset' 可以直接檢查嵌套存取
inspection.php.isset.can.check.nested.array.access.subproperties.directly='isset' 可以直接檢查嵌套陣列存取和子屬性
inspection.php.language.level.description='fn' 是 PHP 7.4 中的保留關鍵字
inspection.php.language.level.inspection.display.name=語言級別
inspection.php.laravel.pint.inspection.display.name=Laravel Pint 驗證
inspection.php.long.type.form.inspection.display.name=類型關鍵字的縮寫
inspection.php.loop.can.be.converted.to.array.fill.inspection.display.name=迴圈可以轉換為 'array_fill()' 呼叫
inspection.php.loop.can.be.converted.to.array.filter.inspection.display.name=迴圈可以轉換為 'array_filter()' 呼叫
inspection.php.loop.can.be.converted.to.array.map.inspection.display.name=迴圈可以轉換為 'array_map()' 呼叫
inspection.php.loop.can.be.replaced.with.implode=迴圈可被取代為 'implode()'
inspection.php.loop.can.be.replaced.with.in.array=迴圈可被取代為 'in_array()' 或 'array_key_exists()' 呼叫
inspection.php.loop.can.be.replaced.with.str.repeat=迴圈可被取代為 'str_repeat'
inspection.php.loop.never.iterates=''{0}'' 語句不迴圈
inspection.php.loop.never.iterates.name=迴圈未迭代
inspection.php.match.can.be.replaced.with.switch.statement='match' 可被取代為 'switch' 語句
inspection.php.match.expression.can.be.replaced.with.ternary='match' 表達式可被取代為三元表達式
inspection.php.method.may.be.static.inspection.display.name=方法可以為 'static'
inspection.php.method.naming.convention.inspection.display.name=方法名稱未遵循編碼約定
inspection.php.method.or.class.call.is.not.case.sensitive.inspection.display.name=方法呼叫或類別用法中的大小寫不符合
inspection.php.method.parameters.count.mismatch.inspection.display.name=參數數量與宣告不符合
inspection.php.method.return.value.is.never.used=方法的返回值從未使用
inspection.php.missing.break.statement.inspection.display.name=缺少 'break' 語句
inspection.php.missing.doc.comment.inspection.display.name=缺少 PHPDoc 註釋
inspection.php.missing.field.type.inspection.display.name=缺少屬性的類型宣告
inspection.php.missing.param.type.description=缺少參數的類型宣告
inspection.php.missing.parameter.type.inspection.display.name=缺少參數的類型宣告
inspection.php.missing.parent.call.common.inspection.display.name=方法缺少父呼叫
inspection.php.missing.parent.call.magic.inspection.display.name=魔術方法缺少父呼叫
inspection.php.missing.parent.constructor.inspection.display.name=建構函式缺少父呼叫
inspection.php.missing.return.type.description=缺少函式的返回值類型宣告
inspection.php.missing.return.type.inspection.display.name=缺少返回值類型宣告
inspection.php.missing.strict.types.declaration.inspection.display.name=缺少嚴格類型宣告
inspection.php.missing.visibility.inspection.display.name=缺少可見性
inspection.php.mixed.return.type.can.be.reduced=可以限縮 'mixed' 返回值類型的範圍
inspection.php.mockery.invalid.mocking.target=無效的 Mockery 模擬目標
inspection.php.modifier.order.inspection.display.name=修飾符順序
inspection.php.modulo.operation.with.one=以 '1' 為動作數的取模運算
inspection.php.move.variable.inside.closure=在閉包內移動變數賦值
inspection.php.multiple.class.declarations.inspection.display.name=多個類別宣告
inspection.php.multiple.classes.declarations.in.one.file.display.name=一個檔案中有多個類別宣告
inspection.php.multiple.isset.calls.can.be.replaced.with.one=可將多個 'isset' 呼叫取代為一個
inspection.php.name.variable.is.used.only.inside.closure=變數僅在閉包內使用
inspection.php.named.argument.may.be.unresolved=命名實參可能未解析
inspection.php.named.argument.usage=有名稱關鍵字的實參
inspection.php.named.arguments.with.changed.order=命名實參順序與參數順序不符合
inspection.php.navigate.to.variable.assignment=導覽到變數賦值
inspection.php.nested.dirname.call.can.be.replaced.with.levels.usage=嵌套的 'dirname()' 呼叫可被取代為 'levels' 參數用法
inspection.php.nested.min.max.call=嵌套的 'min/max' 呼叫
inspection.php.nested.ternary.expression.usage.inspection.display.name=使用了嵌套的三元運算符
inspection.php.never.typed.function.returning.value='never' 類型的函式返回一個值
inspection.php.new.class.missing.parameter.list.inspection.display.name=缺少參數列表
inspection.php.non.canonical.elements.order.description=變數及其類型以非規範順序列出
inspection.php.non.canonical.elements.order.inspection.display.name=元素的非規範順序
inspection.php.non.compound.use.inspection.display.name=不必要的語句使用
inspection.php.non.strict.object.equality.inspection.display.name=非嚴格物件相等
inspection.php.not.installed.packages.inspection.display.name=未安裝的 Composer 軟體套件
inspection.php.null.is.not.compatible.with.parameter='null' 與參數的宣告類型不相容
inspection.php.null.safe.operator.can.be.used=可以使用 Nullsafe 運算符 '?->'
inspection.php.object.fields.are.only.written=區域物件僅用於寫入屬性
inspection.php.object.shape.can.be.added=ObjectShape 可以新增
inspection.php.open.echo.tag.inspection.display.name=開啟 'echo' 標記用法
inspection.php.optional.before.required.parameters.inspection.display.name=可選參數在必選參數之前
inspection.php.overriding.method.extending.class.marked.as.final=被標記為 '@final' 的覆寫方法/擴展類別
inspection.php.overriding.method.visibility.inspection.display.name=方法可見性不應被覆寫
inspection.php.parameter.always.have.same.value=參數值始終相同
inspection.php.parameter.by.ref.is.not.used.as.reference.inspection.display.name=不必要的通過參照傳遞
inspection.php.parameter.name.chaged.during.inhertiance=在繼承期間更改了參數名稱
inspection.php.params.inspection.display.name=參數類型
inspection.php.pass.by.ref.description=僅變數可通過參照返回
inspection.php.pass.by.ref.inspection.display.name=通過參照傳遞參數
inspection.php.plural.mixed.can.be.replaced.with.array='mixed' 類型可被取代為 'array'
inspection.php.pointless.boolean.expression='if' 條件內的無意義布爾表達式
inspection.php.possible.polymorphic.invocation.inspection.display.name=可能的多態呼叫
inspection.php.pow.call.can.be.replace.with.pow.operator='pow()' 呼叫可被取代為 '**' 運算符
inspection.php.preg.match.can.be.replaced.with.comparison='preg_match()' 可被取代為比較
inspection.php.preg.match.redundant.closure=冗餘閉包 '.*'
inspection.php.preg.match.without.regular.expression='preg_match' 可被取代為 'str_contains'
inspection.php.preg.replace.with.empty.replacement.name='preg_replace()' 可被取代為 '(l|r)trim' 呼叫
inspection.php.preg.split.can.be.replaced.with.explode='preg_split' 可被取代為 'explode'
inspection.php.private.field.can.be.local.variable.description=屬性可被取代為區域變數
inspection.php.private.field.can.be.local.variable.inspection.display.name=private 屬性可為區域
inspection.php.private.method.may.be.inaccessible.in.late.static.binding.call=在延遲 static 綁定呼叫期間可能無法存取 private 方法
inspection.php.promoted.field.usage=提升的屬性用法
inspection.php.property.can.be.readonly=屬性可以為 'readonly'
inspection.php.property.naming.convention.inspection.display.name=屬性名稱未遵循編碼約定
inspection.php.property.only.written=屬性用法具有相同的存取權限
inspection.php.pure.contract.attribute.can.be.added=可以新增 '#[Pure]' 特性
inspection.php.pure.function.may.produce.side.effect=純函式可能會產生副作用
inspection.php.rand.arguments.in.revers.order=順序錯誤的 'rand' 函式實參
inspection.php.ranges.in.class.can.re.merged=類別中的範圍可以合併
inspection.php.redeclaration.stdlib.function=標準庫函數的重複宣告
inspection.php.redeclaration.stdlib.function.description=不能重複宣告標準庫函數 ''{0}''
inspection.php.redundant.array.call.in.foreach.iterated.value=對 'foreach' 中迭代的值的冗餘 'array_values' 呼叫
inspection.php.redundant.assignment.to.promoted.field=冗餘的提升屬性賦值
inspection.php.redundant.attribute.parenthesis=特性中的冗餘圓括號
inspection.php.redundant.catch.clause.inspection.display.name=冗餘 catch 子句
inspection.php.redundant.closing.tag.inspection.display.name=冗餘結束標記
inspection.php.redundant.continue.break.argument=冗餘的 'continue/break' 實參
inspection.php.redundant.doc.comment.inspection.display.name=冗餘 PHPDoc 註釋
inspection.php.redundant.match.expression='match' 表達式只有 default arm，應當進行簡化
inspection.php.redundant.method.override=冗餘方法覆寫
inspection.php.redundant.modifier=冗餘的 ''{0}'' 修飾符
inspection.php.redundant.modifier.key=冗餘修飾符
inspection.php.redundant.optional.argument=冗餘的可選實參
inspection.php.redundant.type.in.union.type=類型宣告冗餘，可以簡化
inspection.php.redundant.type.in.union.type.fix.name=簡化冗餘類型
inspection.php.redundant.type.in.union.type.template=類型宣告可以簡化為 ''{0}''
inspection.php.redundant.variable.doc.type.description=@var 標記指定了已從原始碼推斷出的類型
inspection.php.redundant.variable.doc.type.inspection.display.name=冗餘 @var 標記
inspection.php.regexp.delimiter.is.alphanumeric.or.backslash=分隔符是字母數字或反斜杠
inspection.php.regexp.delimiter.is.used.in.reg.exp=在正則表達式中使用了分隔符
inspection.php.regexp.n.modifier.can.be.replaced.with.non.capturing.groups='n' 修飾符可被取代為非捕獲組
inspection.php.regexp.replace.n.modifier.with.non.capturing.groups=將 'n' 修飾符取代為非捕獲組
inspection.php.regexp.replace.with.valid.delimiter=取代為有效分隔符
inspection.php.remove.modifier=移除修飾符 ''{0}''
inspection.php.remove.useless.trailing.comma=移除無用的尾隨逗號
inspection.php.return.doc.type.mismatch=PHPDoc 中的返回值類型與實際返回值類型不符合
inspection.php.return.doc.type.mismatch.inspection.display.name=PHPDoc 註釋中的返回值類型與實際返回值類型不符合
inspection.php.second.write.to.readonly.property=第二次寫入 'readonly' 屬性
inspection.php.separate.else.if.inspection.display.name=Else if
inspection.php.short.echo.open.tag.description=短 echo 起始標記用法
inspection.php.short.open.echo.tag.inspection.display.name=短起始 'echo' 標記用法
inspection.php.short.open.tag.description=使用了短起始標記
inspection.php.short.open.tag.inspection.display.name=使用了短起始標記
inspection.php.signature.mismatch.during.inheritance.inspection.display.name=覆寫方法的宣告應與父類別相容
inspection.php.silly.assignment.inspection.display.name=冗餘賦值
inspection.php.single.statement.with.braces.inspection.display.name=單語句主體帶大括號
inspection.php.statement.has.empty.body.description=語句具有空體
inspection.php.statement.has.empty.body.inspection.display.name=語句具有空體
inspection.php.statement.without.braces.inspection.display.name=控制語句主體無大括號
inspection.php.static.as.dynamic.method.call.inspection.display.name=static 方法被呼叫為動態
inspection.php.str.functions.inspection.display.name='str*()' 呼叫可被取代為 PHP 8 'str_*()' 呼叫
inspection.php.strict.comparison.of.operands.with.different.types=嚴格比較類型不相容的動作數
inspection.php.strict.type.checking.inspection.display.name=嚴格類型檢查規則違反
inspection.php.super.class.incompatible.with.interface.inspection.display.name=父類別的方法宣告與實作的接口不相容
inspection.php.suspicious.name.combination.inspection.name=可疑名稱組合
inspection.php.switch.can.be.replaced.with.match.expression='switch' 可被取代為 'match' 表達式
inspection.php.switch.case.without.default.branch.inspection.display.name=switch 語句沒有 default 分支
inspection.php.ternary.expression.can.be.replaced.with.condition.inspection.display.name=三元表達式可被取代為條件
inspection.php.ternary.expression.can.be.replaced.with.short.version=三元表達式可被取代為短版本
inspection.php.throwable.not.thrown.inspection.display.name=未拋出 Throwable
inspection.php.to.string.implementation.inspection.display.name=方法 '__toString' 實作
inspection.php.to.string.may.produce.exception='__toString' 可能會拋出異常
inspection.php.to.string.return.inspection.display.name=方法 '__toString' 返回值類型
inspection.php.too.long.member.reference.chain=成員參照鏈過長，無法分析
inspection.php.too.many.parameters.inspection.display.name=函式宣告中的參數過多
inspection.php.traditional.syntax.array.literal.inspection.display.name=檢測到傳統語法陣列文字
inspection.php.trait.method.use.is.located.inside.different.target.class=特徵 use 規則已解析為使用不同包含類別的方法 
inspection.php.trait.usage=不允許特徵用法
inspection.php.traits.use.list.inspection.display.name=每行一個特徵 use
inspection.php.type.tag.without.variable.name=不帶變數名稱的類型標記
inspection.php.typed.property.might.be.uninitialized.inspection.display.name=類型化屬性可能未初始化
inspection.php.typed.property.might.be.uninitialized.inspection.problem=類型化屬性 ''{0}'' 可能未初始化
inspection.php.uncovered.enum.cases=某些 enum case 未被覆蓋
inspection.php.undefined.callback.inspection.display.name=未定義的回調
inspection.php.undefined.class.constant.inspection.display.name=未定義的類別常數
inspection.php.undefined.class.description=類別 '#ref' 存在多個定義
inspection.php.undefined.class.description2=未定義的類別 '#ref'
inspection.php.undefined.class.description5=存在類別 '#ref' 的其他宣告
inspection.php.undefined.class.inspection.display.name=未定義的類別
inspection.php.undefined.class.other.declaration.exists={0} 處存在類別 ''#ref'' 的其他宣告
inspection.php.undefined.class.other.declaration.exists.and={0} 和另 {1} 處存在類別 ''#ref'' 的其他宣告
inspection.php.undefined.constant.inspection.display.name=未定義的常數
inspection.php.undefined.field.inspection.display.name=未定義的屬性
inspection.php.undefined.function.inspection.display.name=未定義的函式
inspection.php.undefined.goto.label.inspection.display.name=未定義的 goto 標籤
inspection.php.undefined.method.inspection.display.name=未定義的方法
inspection.php.undefined.namespace.description=未定義的命名空間 '#ref'
inspection.php.undefined.namespace.inspection.display.name=未定義的命名空間
inspection.php.undefined.variable.inspection.display.name=未定義的變數
inspection.php.unhandled.exception.inspection.display.name=未處理的異常
inspection.php.unit.assert.always.execute.to.same.result=實參類型不相容的 'assertTrue()'
inspection.php.unit.assert.array.has.key.inspection.display.name=可以改用方法 'assertArrayHasKey/assertArrayNotHasKey'
inspection.php.unit.assert.can.be.replaced.with.assert.true.false=斷言可被取代為 'assertTrue/assertFalse'
inspection.php.unit.assert.can.be.replaced.with.fail=斷言可被取代為 'fail'
inspection.php.unit.assert.contains.inspection.display.name=棄用的 'assertContains/assertNotContains' 用法
inspection.php.unit.assert.count.inspection.display.name=使用了 'assertCount/assertSameSize' 方法而非 assertEquals
inspection.php.unit.assert.empty.inspection.display.name=斷言可被取代為 'assertEmpty/assertNotEmpty'
inspection.php.unit.assert.equals.inspection.display.name=棄用的 'assertEquals/assertNotEquals' 用法
inspection.php.unit.assert.file.equals.inspection.display.name=棄用的 'assertFileEquals/assertStringEqualsFile' 用法
inspection.php.unit.covers.by.access.modifier.is.deprecated.inspection.display.name=棄用的通過修飾符註解進行的 @covers/@uses
inspection.php.unit.covers.function.without.scope.resolution.operator.inspection.display.name=提供的覆蓋函式參照沒有 '::'
inspection.php.unit.deprecated.call.in.phpunit.10=方法在 PHPUnit 10 中已棄用
inspection.php.unit.deprecated.data.provider.signature.inspection.display.name=自 PHPUnit 10 以來，已棄用資料提供程序
inspection.php.unit.deprecated.expect.exception.inspection.display.name=使用了棄用的 expectException
inspection.php.unit.expected.exception.doc.tag.is.deprecated.inspection.display.name=棄用的通過文檔標記進行的異常處理
inspection.php.unit.failed.line=測試中失敗的行
inspection.php.unit.invalid.mocking.target=無效的 PHPUnit 模擬目標
inspection.php.unit.misordered.assert.equals.arguments.inspection.display.name=順序錯誤的 PHPUnit 等式斷言方法實參
inspection.php.unit.missing.target.for.test.inspection.display.name=PHPUnit 測試缺少目標元素
inspection.php.unit.undefined.data.provider.inspection.display.name=未定義的 PHPUnit 資料提供程序
inspection.php.unknown.modifier=未知修飾符 ''{0}''
inspection.php.unnecessary.continue='continue' 不必要，因為是迴圈中的最後一條語句
inspection.php.unnecessary.curly.variable.syntax=變數的不必要大括號語法
inspection.php.unnecessary.double.quotes.display.name=不必要的雙引號
inspection.php.unnecessary.else.inspection.display.name=不必要的 'else' 分支
inspection.php.unnecessary.fully.qualified.name.inspection.display.name=不必要的完全限定名稱
inspection.php.unnecessary.leading.backslash.in.use.statement='use' 語句中有不必要的前導 '\\'
inspection.php.unnecessary.local.variable.inspection.display.name=不必要的區域變數
inspection.php.unnecessary.parentheses.inspection.display.name=不必要的圓括號
inspection.php.unnecessary.return.function='return' 不必要，因為是函式中的最後一條語句
inspection.php.unnecessary.return.inspection.display.name=不必要的 'return/continue' 語句
inspection.php.unnecessary.return.method='return' 不必要，因為是方法中的最後一條語句
inspection.php.unnecessary.semicolon.description=不必要的 ;
inspection.php.unnecessary.semicolon.inspection.display.name=不必要的分號
inspection.php.unnecessary.spread.operator.for.function.call.argument=函式呼叫實參的不必要展開運算符
inspection.php.unpacked.argument.type.mismatch.inspection.display.name=無效類型的解包實參
inspection.php.unpacking.arrays.with.string.keys.inspection=對於 PHP 8.1 之前的版本，禁止使用字串鍵解包陣列
inspection.php.unsupported.modifier=自 PHP {1} 起不支持修飾符 ''{0}''
inspection.php.unsupported.modifier.key=不支持的修飾符
inspection.php.unused.alias.description=匯入 '#ref' 不必要
inspection.php.unused.alias.description2=匯入 '#ref' 從未使用
inspection.php.unused.alias.inspection.display.name=未使用的 import
inspection.php.unused.display.name=未使用的宣告
inspection.php.unused.field.default.value.description=屬性初始設定式冗餘
inspection.php.unused.field.default.value.inspection.display.name=冗餘屬性初始設定式
inspection.php.unused.local.variable.inspection.display.name=未使用的區域變數
inspection.php.unused.match.arm.condition.inspection.display.name=未使用的 'match' 條件
inspection.php.unused.parameter.inspection.display.name=未使用的參數
inspection.php.unused.private.field.inspection.display.name=未使用的 private 屬性
inspection.php.unused.private.method.inspection.display.name=未使用的 private 方法
inspection.php.unused.switch.case.inspection.display.name=未使用的 'switch' 分支
inspection.php.usage.of.silence.operator.inspection.display.name=使用了靜默運算符
inspection.php.useless.trailing.comma.inspection.desc=無用的尾隨逗號
inspection.php.useless.trailing.comma.inspection.display.name=無用的尾隨逗號
inspection.php.var.export.used.without.return.argument=使用 'var_export' 或 'print_r' 調用時不帶 'return' 實參
inspection.php.var.usage.inspection.display.name=使用了 var
inspection.php.variable.naming.convention.inspection.display.name=變數名稱未遵循編碼約定
inspection.php.variable.variable.inspection.display.name=使用了可變變數
inspection.php.void.function.result.used.inspection.display.name=使用了 void 函式結果
inspection.php.write.access.to.readonly.property.outside.declaration.scope=對宣告作用域之外的 'readonly' 屬性的寫入權限
inspection.php.write.access.to.referenced.array.value.without.unset=對無 'unset' 的參照陣列值的寫入權限
inspection.php.wrong.catch.clauses.order.inspection.display.name=catch 子句順序錯誤
inspection.php.wrong.foreach.argument.type.inspection.display.name=為 'foreach()' 提供的無效實參
inspection.php.wrong.string.concatenation.inspection.display.name=字串串聯錯誤
inspection.phpunit.asserts.array.has.key.can.be.used.instead=可以改用方法 ''{0}''
inspection.phpunit.asserts.assert.with.count.function=可以使用方法 {0} 代替 {1}
inspection.phpunit.asserts.assertEquals.misordered.arguments=順序錯誤的 ''{0}()'' 實參
inspection.phpunit.asserts.assertEquals.parameters.empty=帶有此類別參數的呼叫已棄用
inspection.phpunit.asserts.assertEquals.parameters.many=可選的 {0} 個參數已棄用
inspection.phpunit.asserts.assertEquals.parameters.single=可選的 {0} 個參數已棄用
inspection.phpunit.covers.function.without.scope.resolution.operator=提供的覆蓋{0}參照沒有 ''::''
inspection.phpunit.expectException=對將 expectException() 用於 {0} 的支援已棄用，將在 PHPUnit 10 中移除。請改用 {1}()。
inspection.phpunit.missing.target.element.ref=未找到 '#ref' 的測試目標元素
inspection.probably.undefined.property=屬性 '#ref' 已動態宣告，可能未定義
inspection.property.declared.dynamically=動態宣告的屬性
inspection.property.declared.dynamically.deprecated=動態宣告的屬性，從 PHP 8.2 開始已棄用。
inspection.redundant.closing.tag.fix.remove=移除結束標記
inspection.redundant.closing.tag.problem=冗餘結束標記
inspection.redundant.intersection.type=冗餘的交叉類型
inspection.redundant.intersection.type.fix=交叉類型可以簡化為 ''{0}''
inspection.redundant.intersection.type.fix.name=簡化交叉類型
inspection.redundant.phpdoc=冗餘 PHPDoc 註釋
inspection.redundant.phpdoc.tag=冗餘的 PHPDoc 標記
inspection.severity.with.magic=當 __magic 存在時顯示
inspection.silly.assignment.problem=賦值左右兩側相等
inspection.single.statement.with.braces=單語句主體帶大括號
inspection.single.statement.with.braces.fix.name=從 ''{0}'' 語句中移除大括號
inspection.statement.has.empty.body.comments.count.as.content=註釋計為內容
inspection.statement.has.empty.body.ignore.empty.for=忽略無主體的 'for' 迴圈
inspection.statement.has.empty.body.ignore.empty.while=忽略無主體的 'while' 迴圈
inspection.statement.without.braces=控制語句主體無大括號
inspection.statement.without.braces.fix.name=將大括號新增到 ''{0}'' 語句
inspection.static.member.accessed.via.instance.reference=通過實例參照存取 static 成員 ''{0}''
inspection.static.method.called.as.dynamic.problem=static 方法 '#ref' 不應被動態呼叫
inspection.static.method.called.as.dynamic.problem.magic=static 方法 '#ref' 不應被動態呼叫，但類別具有 '__magic' 方法。
inspection.str.functions.strpos.call.can.be.converted.to.strcontains='strpos()' 呼叫可以轉換為 'str_contains()'
inspection.str.functions.strpos.call.can.be.converted.to.strstartswith='strpos()' 呼叫可以轉換為 'str_starts_with()'
inspection.str.functions.substr.call.can.be.converted.to.strendswith='substr()' 呼叫可以轉換為 'str_ends_with()'
inspection.str.functions.substr.call.can.be.converted.to.strstartswith='substr()' 呼叫可以轉換為 'str_starts_with()'
inspection.strict.type.checking.field.assignment=屬性必須為 ''{0}'' 類型，提供的是 ''{1}''
inspection.strict.type.checking.field.assignment.multi.resolve=賦值的類型 ''{0}'' 與屬性的宣告類型不相容
inspection.strict.type.checking.option=為所有檔案啟用
inspection.strict.type.checking.parameter=應為 ''{0}'' 類型的參數，提供的是 ''{1}''
inspection.strict.type.checking.parameter.batch=參數 '#ref' 類型與宣告不相容
inspection.strict.type.checking.return=返回值必須為 ''{0}'' 類型，返回的是 ''{1}''
inspection.strict.type.checking.return.batch=返回值類型與宣告不相容
inspection.super.incompatible.with.interface.declaration.must.be.compatible=''{0}'' 的宣告必須與 ''{1}'' 相容
inspection.switch.with.single.case=只有一個 'case' 的 'switch'
inspection.switch.without.default.case='Switch' 沒有預設分支
inspection.too.many.parameters=參數數量超出指定限值
inspection.too.many.parameters.ignore.constructors=忽略建構函式
inspection.too.many.parameters.max.number.of.parameters=最大參數數量
inspection.traditional.syntax.array.literal.detected=使用了傳統語法陣列文字
inspection.undefined.callback.class=未定義的類別 ''{0}''
inspection.undefined.callback.dont.report.ambiguity.checkbox=不明確時不報告
inspection.undefined.callback.dont.report.exist.checkbox=忽略來自 '*_exists' 和 'is_callable' 函式的回調
inspection.undefined.callback.field=在類別 ''{1}'' 中未找到屬性 ''{0}''
inspection.undefined.callback.function=未定義的函式 ''{0}''
inspection.undefined.callback.method=在類別 ''{1}'' 中未找到方法 ''{0}''
inspection.undefined.class.ignore.phpdoc=忽略 PHPDoc
inspection.undefined.constant.problem1=未定義的常數 '#ref'
inspection.undefined.constant.problem2=常數 '#ref' 可能未定義
inspection.undefined.field.notify.access.magic.method=通過魔術方法存取屬性的通知
inspection.undefined.field.notify.dynamic.declaration=動態屬性宣告的通知
inspection.undefined.field.notify.dynamic.read=通知對動態屬性的讀取權限
inspection.undefined.field.problem1=通過魔術方法存取的屬性
inspection.undefined.function.problem1=未定義的函式 '#ref'
inspection.undefined.function.problem2=函式 '#ref' 可能未定義
inspection.undefined.member.downgrade=如果類別中存在 __magic 方法則降級嚴重性(&D)
inspection.undefined.member.warnOnMixed=出現混合、物件、stdClass、未定義類型、null 的存取成員時通知
inspection.undefined.phpunit.provider=未定義的 PHPUnit 資料提供程序 ''{0}''
inspection.undefined.variable.option.description.enable.in.file.scope=在全域空間中啟用檢查
inspection.undefined.variable.option.description.ignore.include=在當前檔案外搜尋變數定義
inspection.undefined.variable.option.description.report.can.be.undefined=報告變數可能未定義
inspection.undefined.variable.problem1=未定義的變數 '#ref'
inspection.undefined.variable.problem2=變數 '#ref' 可能未定義
inspection.unnecessary.bool.cast=冗餘轉換為布林值
inspection.unnecessary.fully.qualified.name.option.enable.file.scope=在檔案作用域中啟用
inspection.unnecessary.fully.qualified.name.option.ignore.global.namespace=忽略全域命名空間
inspection.unnecessary.qualifier.already.imported.message=限定符不必要，可以移除
inspection.unnecessary.static.reference=final 類別中有冗餘的 'static'
inspection.unnecessary.string.cast=冗餘轉換為字串
inspection.unpacked.argument.type.mismatch=僅可解包陣列和 Traversable，獲得的是{0}
inspection.unreachable.statement=不可到達的語句
inspection.unreachable.statement.problem=不可到達的語句
inspection.unused.declaration.option.show.unused_from_entries=顯示所有宣告
inspection.unused.declaration.option.show_strictly_unused=僅顯示未使用項
inspection.unused.declaration.option.test.entry_points=假定測試宣告為入口點
inspection.unused.declaration.option.test.suppressGettersAndSetters=禁止 getter/setter
inspection.unused.description.code.suppressed.annotations=已禁止的註解
inspection.unused.local.variable.option.description.file.scope=在全域空間中啟用檢查
inspection.unused.local.variable.option.description.foreach=在 'list()' 中或存在 'foreach' 鍵時忽略 foreach 值
inspection.unused.local.variable.option.description.include=忽略 'include' 之前的變數
inspection.unused.local.variable.option.description.list=忽略 'list()' 中的變數
inspection.unused.local.variable.option.description.null=忽略 'null' 的賦值
inspection.unused.local.variable.option.indirect.access=忽略通過 'get_defined_vars()' 存取的變數
inspection.unused.local.variable.problem=未使用的區域變數 ''{0}''。{1}
inspection.unused.local.variable.problem.batch=區域變數 '#ref' 未在任何位置使用
inspection.unused.local.variable.problem.case1=變數的值未在任何位置使用。
inspection.unused.local.variable.problem.case2=變數的值被立即覆蓋。
inspection.unused.local.variable.problem.case3=變數中存儲的參照未在任何位置使用。
inspection.unused.local.variable.problem.case4=變數中存儲的參照被立即覆蓋。
inspection.unused.local.variable.problem.fix.side.effects.found.dialog.message=分配給 ''{0}'' 的表達式可能含有副作用。\\n\\
您可以:\\n\\
- 完全<b>移除</b>變數賦值\\n\\
- 將分配的表達式<b>轉換</b>成單獨的語句
inspection.unused.local.variable.problem.fix.side.effects.found.dialog.title=發現副作用
inspection.unused.parameter.option.description.empty.abstract=忽略抽象類別方法的參數
inspection.unused.parameter.option.description.empty.anonymous=忽略匿名函式的參數
inspection.unused.parameter.option.description.empty.body=忽略帶有空體的方法/函式的參數
inspection.unused.parameter.option.description.empty.override=忽略覆寫方法的參數
inspection.unused.parameter.option.description.parameter.count=不報告通過 'func_num_args()' 存取的參數
inspection.unused.parameter.problem=未使用的參數 ''{0}''。{1}
inspection.unused.parameter.problem.case1=參數值未在任何位置使用。
inspection.unused.parameter.problem.case2=參數值被立即覆蓋。
inspection.unused.parameter.problem.case3=參數中存儲的參照未在任何位置使用。
inspection.unused.parameter.problem.case4=參數中存儲的參照被立即覆蓋。
inspection.unused.private.method.option.ignore.clone=忽略方法 '__clone' 用法
inspection.unused.private.method.option.ignore.constructor=忽略方法 '__construct' 用法
inspection.unused.private.method.problem.batch=未使用的 private 方法 '#ref'
inspection.unused.symbol.check.anonymous_classes=匿名
inspection.unused.symbol.check.classes=類別
inspection.unused.symbol.check.constants=常數
inspection.unused.symbol.check.fields=屬性
inspection.unused.symbol.check.functions=函式
inspection.unused.symbol.check.magic_method=魔術方法
inspection.unused.symbol.check.methods=方法
inspection.unused.symbol.export.abstract=abstract
inspection.unused.symbol.export.call=呼叫
inspection.unused.symbol.export.calls=呼叫
inspection.unused.symbol.export.closure=結束
inspection.unused.symbol.export.entry=入口點
inspection.unused.symbol.export.label=標籤
inspection.unused.symbol.export.reachable_element=可到達
inspection.unused.symbol.export.test_method=測試
inspection.unusedd.description.code.patterns.button.label=程式碼模式
inspection.usage.of.silence.operator.problem=使用了沉默運算符
inspection.variable.variable=使用了可變變數
inspection.void.function.result.used.problem.type=void
inspection.void.never.function.result.used.problem.type=void/never
inspection.wrong.exception.order.fix.move.display.name=將 ''catch'' 子句移至 ''{0}'' 前
inspection.wrong.exception.order.fix.move.family.name=移動 'catch' 子句
inspection.wrong.exception.order.problem.batch=已捕獲異常 '#ref'
inspection.wrong.exception.order.problem.same=已捕獲異常 ''{0}''
inspection.wrong.exception.order.problem.super=已捕獲異常類別 ''{1}'' 的超類別 ''{0}''
inspection.wrong.exception.type.problem.catch = 無法捕獲非派生自 'Exception' 或 'Throwable' 基類別的物件
inspection.wrong.exception.type.problem.throw = 已拋出物件必須為 'Exception' 或 'Throwable' 的實例
inspection.wrong.foreach.argument.type.problem=提供給 ''foreach'' 的實參無效。預期類型: ''array'' 或 ''object''，提供的是 ''{0}''。
inspection.wrong.foreach.argument.type.problem.batch=提供給 'foreach' 的無效實參
inspection.wrong.string.concatenation.operator.option.ignore.magic=忽略通過魔術方法存取的屬性
inspection.wrong.string.concatenation.operator.problem=字串串聯運算符錯誤
inspection.wrong.string.concatenation.operator.problem.batch=字串串聯運算符錯誤
inspection.wrong_param_type=應為 ''{1}'' 類型的參數，提供的是 ''{0}''
install.composer.packages.task.title=安裝 Composer 軟體套件
instanceof.is.always.true={0} 已位於 {1} 的層次結構中
intention.add.constructor.parameters=新增建構函式參數
intention.add.constructor.parameters.fields.chooser.dialog.title=選擇要在建構函式中初始化的屬性
intention.can.not.find.statement.to.surround=找不到要包圍的目標語句。
intention.convert.to.short.syntax=將陣列轉換為短語法
intention.convert.to.short.syntax.list=將列表轉換為短語法
intention.convert.to.traditional.syntax=將陣列轉換為傳統語法
intention.convert.to.traditional.syntax.list=將列表轉換為傳統語法
intention.declare.missing.field=宣告屬性
intention.declare.missing.property=新增 @property
intention.family.inline.value.for.parameter=內聯參數值
intention.family.name.add=新增 ''\${0}''
intention.family.name.add.arrayshape.attribute=新增 '#[ArrayShape]' 特性
intention.family.name.add.arrayshape.to.doc=將 ArrayShape 新增到 PHPDoc
intention.family.name.add.attribute=新增 ''#[{0}]''
intention.family.name.add.attribute.attribute=使用 'Attribute' 註解
intention.family.name.add.attribute.to=將 ''#[{0}]'' 新增到 ''{1}''
intention.family.name.add.attribute.to.overridden.method=將特性新增到覆寫方法
intention.family.name.add.attribute.to.overridden.method.of.abstract.method=將特性新增到抽象方法的覆寫方法
intention.family.name.add.attribute.to.overridden.parameter=將特性新增到覆寫參數
intention.family.name.add.break.as.last.statement=將 'break' 作為最後一條語句新增
intention.family.name.add.default.match.arm=新增 'default' 'match' arm
intention.family.name.add.doc.tag.with.throws.tags=使用 @throws 標記新增 PHPDoc 註釋
intention.family.name.add.getter=新增 getter
intention.family.name.add.getter.setter=新增 getter 和 setter
intention.family.name.add.missing.parameters=新增缺少的參數
intention.family.name.add.name.identifiers.to.all.arguments.starting.from.current=從當前位置開始將名稱關鍵字新增到所有實參
intention.family.name.add.number.separators=新增數字分隔符
intention.family.name.add.readonly.modifier=新增 'readonly' 修飾符
intention.family.name.add.remaining.enum.cases=新增剩餘 enum case
intention.family.name.add.should.allow.mocking.protected.methods.call=新增 'shouldAllowMockingProtectedMethods' 呼叫
intention.family.name.add.to.containing.enum=將 '' : {0}'' 新增到包含枚舉
intention.family.name.add.to.parameter=將 '\\\\&' 新增到參數
intention.family.name.add.trait.to.use.list=將特徵新增到 use 列表
intention.family.name.add.true.argument.to.var.export.call=將 'true' 實參新增到 'var_export' 呼叫
intention.family.name.add.variable.name=新增變數名稱
intention.family.name.append=追加 ''{0}''
intention.family.name.append.absolute.trait=追加 ''{0}::''
intention.family.name.can.be.merged.with.sequential=''if'' 可以與後續 ''{0}'' 合併
intention.family.name.change.to.mixed=將類型更改為 'mixed'
intention.family.name.collapse.if.statement=摺疊 ''{0}'' 語句
intention.family.name.collapse.statement.into.parameter.default.value=將語句摺疊到參數的預設值中
intention.family.name.collapse.whitespaces=摺疊空格
intention.family.name.combine.multiple.isset.calls.into.one=將多個 'isset' 呼叫合併為一個
intention.family.name.convert.heredoc.nowdoc.to.string.literal=將 HEREDOC/NOWDOC 轉換為字串文字
intention.family.name.convert.heredoc.to.string.literal=將 HEREDOC 轉換為字串文字
intention.family.name.convert.nowdoc.to.string.literal=將 NOWDOC 轉換為字串文字
intention.family.name.convert.string.literal.to.heredoc.nowdoc=將字串文字轉換為 HEREDOC/NOWDOC
intention.family.name.convert.to.promoted.field=轉換為提升的屬性
intention.family.name.convert.to.promoted.field.remove.doc.comment=轉換為提升的屬性並移除屬性 PHPDoc 註釋
intention.family.name.copy.phpdoc.from.parent=從父項複製 PHPDoc
intention.family.name.count.comments.as.content=將註釋計為內容
intention.family.name.delete.covered.element=刪除已覆蓋的元素
intention.family.name.delete.field=刪除屬性
intention.family.name.delete.initializer=刪除初始設定式
intention.family.name.delete.readonly=刪除 'readonly'
intention.family.name.evaluate.cast=取代為 ''{0}''
intention.family.name.extract.attribute.into.separate.list=將特性提取到單獨的列表
intention.family.name.extract.common.parts=提取通用部分
intention.family.name.extract.common.parts.with.removing.branch=提取通用部分，並移除分支
intention.family.name.flip=翻轉 '?:'
intention.family.name.flip.attributes.lists=翻轉特性列表
intention.family.name.force.fqcn.for.references.in.phpdoc=對 PHPDoc 中的參照強制 FQCN
intention.family.name.generate.phpdoc.comment=生成 PHPDoc 註釋
intention.family.name.group.intersection.types=對交叉類型分組
intention.family.name.initialize.properties=初始化屬性
intention.family.name.initialize.property.in.constructor=初始化建構函式中的屬性
intention.family.name.insert.space.after=在 '#' 後面插入一個空格
intention.family.name.insert.unset.before=在前面插入 ''unset(\${0});''
intention.family.name.invert.if.statement=反轉 'if' 語句
intention.family.name.make.class.readonly=將類別設定為 'readonly'
intention.family.name.make.containing.class.enum=將包含類別設為枚舉
intention.family.name.make.data.provider.method.public.static=將資料提供程序方法設定為 'public' 和 'static'
intention.family.name.make.final=設為 'final'
intention.family.name.make.function.return.by.reference=使函式按參照返回
intention.family.name.make.method.void=將方法設為 'void'
intention.family.name.merge.with.adjustment.range=與調整後的範圍合併
intention.family.name.merge.with.assignment=與賦值合併
intention.family.name.merge.with.duplicated.catch.statement=與重複的 'catch' 語句合併
intention.family.name.merge.with.duplicated.match.arm=與重複的 'match' arm 合併
intention.family.name.merge.with.following.attribute.list=將特性列表與以下內容合併
intention.family.name.merge.with.sequential=與後續 ''{0}'' 合併
intention.family.name.move.attribute.to.start.element=將特性移至元素開頭
intention.family.name.move.from.to.composer.json.section=將 ''{0}'' 從 ''{1}'' 移至 ''{2}'' composer.json 部分
intention.family.name.move.trait.use.rule.to.resolved.class.use.list=將特徵 'use' 規則移至解析的類別 'use' 列表
intention.family.name.navigate.to.cause=導覽到原因
intention.family.name.navigate.to.duplicate.method.name=導覽到重複的方法
intention.family.name.navigate.to.possibly.inaccessible.methods=導覽到可能無法存取的方法
intention.family.name.navigate.to.rewrite.expression=導覽到覆寫表達式
intention.family.name.remove=移除 {0}
intention.family.name.remove.argument.name=移除實參名稱
intention.family.name.remove.attribute=移除 ''#[{0}]''
intention.family.name.remove.backed.type.from.containing.enum=從包含枚舉中移除備用類型
intention.family.name.remove.duplicate.operand=移除重複動作數
intention.family.name.remove.empty.index.operator=移除 '[]' 運算符
intention.family.name.remove.leading=移除前導 '\\'
intention.family.name.remove.parenthesis=移除圓括號
intention.family.name.remove.readonly.modifier=移除 'readonly' 修飾符
intention.family.name.remove.redundant.arguments=移除冗餘{0, choice, 0#實參|1#實參}
intention.family.name.remove.unused.postfix.operation=移除未使用的後綴運算
intention.family.name.remove.unused.property=移除未使用的屬性
intention.family.name.rename.parameter.to.match.super=重新命名參數以符合父級
intention.family.name.replace.array.traversable.with.iterable=將 'array|Traversable '取代為'iterable'
intention.family.name.replace.elseif.with.else=將 'elseif' 取代為 'else'
intention.family.name.replace.if.with.match.expression=將 'if' 取代為 'match' 表達式
intention.family.name.replace.if.with.version=將 'if' 取代為 '??' 版本
intention.family.name.replace.in.array.with.disjunction=將 'in_array()' 取代為 '||'
intention.family.name.replace.instanceof.checks.in.catch.with.specific.catches=將 'catch' 塊中的 'instanceof' 檢查取代為特定的 catch
intention.family.name.replace.match.with.switch.statement=將 'match' 取代為 'switch' 語句
intention.family.name.replace.match.with.switch.statement.changing.semantics=將 'match' 取代為 'switch' 語句(可能會改變比較語意)
intention.family.name.replace.match.with.ternary=取代為三元表達式
intention.family.name.replace.readonly.with.public=將 'readonly' 取代為 'public'
intention.family.name.replace.switch.with.if=將 'switch' 取代為 'if'
intention.family.name.replace.switch.with.match.expression=將 'switch' 取代為 'match' 表達式
intention.family.name.replace.ternary.expression.with.true.branch=將三元表達式取代為 ''{0}'' 分支
intention.family.name.replace.true.argument.with.false=將 'true' 實參取代為 'false'
intention.family.name.replace.with=取代為 ''{0}''
intention.family.name.replace.with.argument=取代為實參
intention.family.name.replace.with.array=取代為數組
intention.family.name.replace.with.array.assignment=取代為數組賦值
intention.family.name.replace.with.array.merge.expression=取代為 'array_merge' 表達式
intention.family.name.replace.with.check=取代為 '!==' 檢查
intention.family.name.replace.with.class.constant=取代為類別常數
intention.family.name.replace.with.class.name.literal=取代為 '::class'
intention.family.name.replace.with.class.reference.with.base.class=取代為對基類別的類別參照
intention.family.name.replace.with.closure.fromCallable=取代為 'Closure::fromCallable(...)'
intention.family.name.replace.with.comparison=取代為比較
intention.family.name.replace.with.compile.time.result=取代為編譯時結果
intention.family.name.replace.with.concatenation=取代為串聯
intention.family.name.replace.with.const.syntax=取代為 'const' 語法
intention.family.name.replace.with.define.call=取代為 'define()' 呼叫
intention.family.name.replace.with.dirname.call=取代為 'dirname()' 呼叫
intention.family.name.replace.with.dnf=取代為 DNF 類型宣告
intention.family.name.replace.with.get.class.call=取代為 'get_class()' 呼叫
intention.family.name.replace.with.if=取代為 'if'
intention.family.name.replace.with.implicit.octal.notation=取代為隱式八進制表示法
intention.family.name.replace.with.implode.call=取代為 'implode()' 呼叫
intention.family.name.replace.with.in.array.call=取代為 'in_array()' 呼叫
intention.family.name.replace.with.interpolation=取代為 '{$' 插值
intention.family.name.replace.with.list=取代為 'list'
intention.family.name.replace.with.min.max.call=取代為 'min()'/'max()' 呼叫
intention.family.name.replace.with.named.argument=取代為命名實參
intention.family.name.replace.with.operator=取代為 '?->' 運算符
intention.family.name.replace.with.parameter.access=取代為參數存取
intention.family.name.replace.with.public=取代為 'public'
intention.family.name.replace.with.self.access=取代為 'self::' 存取
intention.family.name.replace.with.spl.autoload.register.call=取代為 'spl_autoload_register()' 呼叫
intention.family.name.replace.with.str.function.call=取代為 ''{0}'' 呼叫
intention.family.name.replace.with.str.repeat.call=取代為 'str_repeat()' 呼叫
intention.family.name.replace.with.suggested.call.in.phpunit=取代為 PHPUnit 10 中建議的呼叫
intention.family.name.replace.with.ternary.expression=取代為三元表達式
intention.family.name.replace.with.traditional.property.declaration=取代為傳統屬性宣告
intention.family.name.replace.with.union.type=取代為聯合類型
intention.family.name.replace.with.version=取代為 '??' 版本
intention.family.name.replace.with.zero=取代為 ''{0}''
intention.family.name.show.example.date.time.output=顯示範例日期時間輸出
intention.family.name.simplify.expression=簡化表達式
intention.family.name.simplify.ternary.expression=簡化 '?:'
intention.family.name.sort.arguments=對實參排序
intention.family.name.split.into.multiple.catch.statements=拆分為多個 'catch' 語句
intention.family.name.split.into.multiple.enum.cases=拆分為多個枚舉 case
intention.family.name.split.into.separate.case.statements=拆分為獨立的 'case' 語句
intention.family.name.split.into.two.separate.match.arms=將條件提取到單獨的 'match' arm
intention.family.name.unwrap.call=解包呼叫
intention.family.name.unwrap.cast=解包轉換
intention.family.name.unwrap.curly.braces=解包大括號
intention.family.name.unwrap.else=解包 'else'
intention.family.name.unwrap.foreach=解包 'foreach'
intention.family.name.unwrap.function.call=解包函式呼叫
intention.family.name.unwrap.intersection.type=解包交叉類型
intention.family.name.unwrap.spread.operator=解包展開運算符
intention.family.name.unwrap.type=解包類型
intention.flip.binary.expression.family.name=翻轉二元表達式
intention.flip.binary.expression.text1=翻轉 ''{0}''
intention.flip.binary.expression.text2=翻轉 ''{0}'' (可能更改語意)
intention.flip.binary.expression.text3=翻轉 ''{0}'' (更改語意)
intention.generate.phpdoc=生成 PHPDoc
intention.implement.interface=實作接口
intention.import.class=作為別名匯入類別
intention.import.class.alias.already.exists=已匯入具有相同別名的類別
intention.import.class.alias.name=別名:
intention.inline.alias=內聯別名
intention.inline.method.family.name=內聯方法
intention.join.comma.separated.values=將逗號分隔的值合併為一行
intention.line.split=在兩個字串和串聯中拆分字串
intention.merge.condition.with.outer=與外部條件合併
intention.message.replace.in.array.with.disjunction=將 ''in_array()'' 取代為 ''{0}''
intention.name.add.as.function.s.return.type=將 ''{0}'' 作為函式返回值類型新增
intention.name.add.enum.case.with.value=新增具有 ''{0}'' 值的枚舉 case
intention.name.add.method.stubs=新增方法存根
intention.name.add.name.identifier=新增名稱關鍵字 ''{0}''
intention.name.add.to.parameter=將 ''\\\\&'' 新增到參數 ''{0}''
intention.name.add.trait.to.use.list=將特徵 ''{0}'' 新增到 use 列表
intention.name.cast.to=將{0}轉換為{1}
intention.name.change.cast.to=將 {0} 轉換更改為 {1}
intention.name.change.method.to=將方法 ''{0}'' 更改為 {1}
intention.name.change.signature=更改 {0}({1}) 的簽名
intention.name.convert.array.syntax.to.short=將陣列轉換為短語法
intention.name.convert.concatenation.to.scalar.value=將串聯轉換為標量值
intention.name.convert.concatenation.to.string.interpolation=將串聯轉換為字串內插
intention.name.convert.sprintf.call.to.concatenation=將 'sprintf()' 呼叫轉換為串聯
intention.name.convert.sprintf.call.to.scalar.value=將 'sprintf()' 呼叫轉換為標量值
intention.name.convert.sprintf.call.to.string.interpolation=將 'sprintf()' 呼叫轉換為字串內插
intention.name.convert.string.literal.to.heredoc=將字串文字轉換為 HEREDOC
intention.name.convert.string.literal.to.nowdoc=將字串文字轉換為 NOWDOC
intention.name.evaluate.cast=對轉換求值
intention.name.extract.if=提取 if ({0})
intention.name.flip=翻轉 {0} 和 {1}
intention.name.inline.value=內聯值 ''{0}''
intention.name.make.abstract=將{0}設為 abstract
intention.name.make.non.final=將 ''{0}'' 設為非 final
intention.name.merge.with=與 ''{0}'' 合併
intention.name.merge.with.match.arm=與 ''{0}'' arm 合併
intention.name.move.trait.use.rule.to.use.list=將特徵 ''use'' 規則移至 ''{0}'' ''use'' 列表
intention.name.prepend.default.case=預置 'default'
intention.name.remove=移除 {0}
intention.name.remove.argument.names.from.all.arguments.up.to.current=從截止到當前位置的所有實參中移除實參名稱
intention.name.remove.brackets=刪除中括號
intention.name.remove.duplicated.type=移除重複類型
intention.name.rename.to=重命名為 ''{0}''
intention.name.replace.brackets.with.types=取代為 'array'
intention.name.replace.coalesce.expression.with=將合併表達式取代為 ''{0}''
intention.name.replace.coalesce.expression.with.operand=將合併表達式取代為動作數
intention.name.replace.null.as.part.union.type.with.nullable.notation=將 '|null' 作為聯合類型的一部分取代為 '?'
intention.name.replace.nullable.notation.with.null.as.part.union.type=用 '|null' 取代 '?' 作為聯合類型的一部分
intention.name.replace.with=將 ''{0}'' 取代為 ''{1}''
intention.name.replace.with.min.max.call=取代為 ''{0}'' 呼叫
intention.name.suppress.for.statement=對語句禁止
intention.name.wrap.left.operand.in.parentheses=使用圓括號包裝左動作數
intention.name.wrap.right.operand.in.parentheses=使用圓括號包裝右動作數
intention.namespace.bracing=將命名空間轉換為帶大括號
intention.php.add.object.shape.attribute=新增 '#[ObjectShape]' 特性
intention.php.doc.add.object.shape=將 ObjectShape 新增到 PHPDoc
intention.php.replace.class.with.enum=將類別取代為枚舉
intention.php.replace.class.with.enum.error.message=由於建構函式呼叫，無法將類別取代為枚舉
intention.php.replace.class.with.enum.title=將類別取代為枚舉
intention.replace.class.with.alias=取代為別名
intention.replace.if.with.ternaryExpression=簡化 'if'
intention.replace.quotes=無法取代引號 - 轉義符號無效且\\\\r 不受支援
intention.replace.ternary.expression.with.if=將 '?:' 取代為 if
intention.replace.with.method.call=取代為對現有方法的呼叫
intention.split.comma.separated.values=將逗號分隔的值拆分為多行
intention.statement.to.surround.failed.message=無法使用 ''{0}'' 包圍語句。
intention.swap.call.arguments.family.name=交換呼叫實參
intention.swap.call.arguments.text1=交換 ''{0}'' 和 ''{1}''
intention.variable.add.phpdoc.comment.family.name=新增 PHPDoc 註釋
interface=接口
interface.cannot.extend.previously.extended.interface=接口無法擴展先前擴展的接口
interface.method.can.t.have.body=接口方法不能有主體
interface.name=接口名稱
interfaces.may.not.include.member.variables=接口可能不包括成員變數
interpreter=解釋器
intersection.types.and.the.nullable.type.notation.cannot.be.mixed=交叉類型和可 null 類型表示法不能混用
introduce.named.constant.for.value.0=為值 ''{0}'' 引入命名常數
introduce.variable.fix=引入變數
invalid.class.name=無效類別名
invalid.condition.to.body.separator.should.be.used=條件與主體之間的分隔符無效: 應改用 '=>'
invalid.octal.literal.won.t.be.reported.by.php.but.will.work.incorrectly=無效的八進制文字: 不會由 PHP 報告，但無法正常工作
invalid.syntax.for.multiple.case.expressions=多個 'case' 表達式的語法無效
is.duplicated.by.0=類型被 ''{0}'' 重複
iso.8601.date=ISO 8601 日期({0})
iso.8601.numeric.representation.of.the.day.of.the.week=ISO 8601 星期几的數字表示(1 到 7)
iso.8601.week.number.of.year.weeks.starting.on.monday=ISO 8601 一年中的第幾周，周從星期一開始(42)
iso.8601.week.numbering.year=ISO 8601 周編號年份(2022)
isset.only.works.with.variables.and.arrays=isset 僅適用於變數和陣列
it.s.not.possible.to.unpack.array.argument.by.reference=無法通過參照對陣列實參解包
it.s.not.possible.to.unpack.array.key=無法解包陣列鍵
it.s.not.possible.to.unpack.array.value.with.associated.key=無法使用關聯鍵解包陣列值
jump.into.a.finally.block.is.disallowed=不允許跳入 'finally' 塊
key=鍵
label=標籤
label.align.named.arguments=對齊命名實參
label.authentication.data.not.specified=未指定身份驗證資料
label.can.be.configured.as.external.formatter=可組態為 {0}
label.class.fqn=類別 FQN
label.configured.as.external.formatter=已組態為 {0}
label.constant.syntax=常數語法(&C)
label.docker.container=Docker 容器:
label.failed=已失敗
label.global.namespace=<全域命名空間>
label.highlight.target.parameter.attributes.applied.to.promoted.property=僅允許具有提升屬性的 'TARGET_PARAMETER|TARGET_PROPERTY' 特性
label.initialize.in=初始化位置(&I)
label.insert.imports.on.paste=貼上時插入 import:
label.interpreter=解釋器: {0}
label.lt.no.server=<no server>
label.method.name=方法名稱
label.name=名稱:
label.new.name=新名稱:
label.predecessors=前驅
label.server.document.root=$_SERVER['DOCUMENT_ROOT']
label.successors=後繼
label.system.php=系統 PHP
label.visibility=可見性(&V)
label.visibility2=可見性:
label.with.same.name.already.defined.in.current.scope=當前作用域中已定義具有相同名稱的標籤
label1=標籤
lambda=Lambda
languages.frameworks.php.php.runtime=PHP / PHP 執行時
line.separator=行分隔符
link=鏈接
link.label.go.to.documentation=轉到文檔
link.label.inspection={0} 檢查
link.label.languages.frameworks.php=PHP
list.is.not.allowed.as.class.reference=不允許將列表作為類別參照
list.item.update.phpdoc.comment=更新 PHPDoc 註釋
list.of.causes.0=// 可能拋出異常的位置列表:\\n\\
{0}
listing.licenses=正在列出授權
live.template.class.member=類別成員
live.template.interface.member=接口成員
live.template.name.comment=註釋
live.template.name.expression=表達式
live.template.name.statement=語句
live.template.name.string.literal=字串文字
live.template.trait.member=特徵成員
local=本地
lowercase.ante.meridiem.and.post.meridiem.am.pm=小寫上午和下午(am/pm)
machine.type.eg.i386=機器類型。例如，i386
make.0.1=將 ''{0}'' 設為{1}
make.01=設為 ''{0}''
make.call.dynamic.quick.fix.family.name=使呼叫為動態
make.non.nullable=設為不可為 null
member.has.0.access=成員具備 {0} 可見性
member.has.0.access.but.class.has.magic.method.1=成員具備 {0} 可見性，但可以通過 ''{1}'' 魔術方法存取
members.to.report=要報告的成員
merge.into.elseif=合併到 'elseif' 中
merge.nested.conditions=合併嵌套的條件
merge.with.0.branch=與 ''{0}'' 分支合併
meta.declaration.exists=''{1}'' 存在元宣告 ''{0}''
meta.declaration.line.marker.name=存在元宣告
meta.multiple.declaration.exists=''{0}'' 存在多個元宣告
method=方法
method.0.can.t.be.overridden.with.same.trait.1=無法使用相同的特徵 ''{1}'' 覆寫方法 ''{0}''
method.0.clone.cannot.accept.any.arguments=方法 ''{0}::__clone()'' 不能接受任何實參
method.call=方法呼叫
method.is.undefined=方法 '#ref' {0,choice,0#未定義|1#可能未定義}
method.is.undefined.in.class=方法 ''#ref'' 在 {0} 中{1,choice,0#未找到|1#可能未定義}
method.name=方法名稱
method.ref.is.deprecated=方法 '#ref' 已棄用
method.ref.not.found=找不到方法 '#ref'
method.should.either.have.body.or.be.abstract=方法應具有主體或為 abstract
method.should.not.be.finished.with=方法不應以 ';' 結束
method.template.parameter.shadows.class.template.parameter=方法模板參數 ''{0}'' 會隱藏類別模板參數
method.with.same.name.already.defined.in.this.class=此類別中已經定義了具有相同名稱的方法
method1=方法
microseconds=微秒(654321)
milliseconds=毫秒(654)
minutes.with.leading.zeros=帶前導零的分鐘(00 到 59)
modifier=修飾符
more.actions=更多動作…
move.class.to.separate.file.text.family=將類別移至單獨的檔案
move.from.another.ide.or.code.editor=從另一個 IDE 或程式碼編輯器遷移
multiple.enum.identifiers.should.be.stated.in.different.cases=多個枚舉關鍵字應在不同的 case 中宣告
multiple.modifiers.are.not.allowed=不允許多個修飾符
multiple.namespaces.in.a.file.should.use.same.preferably.braced.syntax=檔案中的多個命名空間應使用相同的(最好帶大括號)語法
multiple.subsequent.underscores.in.a.numeric.literal.are.not.allowed=不允許在數字文字中使用多個後續下劃線
mute.until.restart=重啟前靜音
name=名稱
named.parameter.overwrites.previous.argument=命名參數覆寫以前的實參
namespace=命名空間
namespace.cannot.start.with.namespace.due.to.conflict.with.ns.relative.names=由於與 ns 相關名稱衝突，命名空間不能以 "namespace" 開頭
namespace.declarations.cannot.be.nested=命名空間宣告不能被嵌套
naming.rules=命名規則
navigate=… 導覽
navigate.to.composer.json=導覽到 composer.json
navigate.to.meta.declaration=導覽到 ''{0}''
navigation.goto.super.method.is.not.available=索引更新期間無法在此處導覽
negate.boolean.expression=布爾表達式求反
nested.type.groups.are.not.allowed=不允許嵌套類型組
never.can.only.be.used.as.return.type='never' 只能用作返回值類型
no.candidate.methods.to.implement=沒有要實作的候選方法
no.candidate.methods.to.override=沒有要覆寫的候選方法
no.content.allowed.before.namespace.declaration=命名空間宣告之前不允許任何內容
no.elements.to.generate.phpdoc.for=沒有任何可為其生成 PHPDoc 的元素
no.expression.found=找不到表達式
no.external.formatter=無外部格式化程序
no.in.line.parameter.name.hints.will.be.shown.for.methods.matching.any.of.these.patterns=對於符合其中任一模式的方法，都不會顯示任何嵌入參數名稱提示。
no.interpreter=<無解釋器>
no.item=沒有項
no.members.to.pull.up.found=未找到要向上拉取的成員
no.members.to.push.down.found=未找到要向下推送的成員
no.name=無名稱
no.private.fields.to.generate.both.getters.and.setters.for=沒有要為之同時生成 getter 和 setter 的 private 欄位
no.private.fields.to.generate.getters.for=沒有要為之生成 getter 的 private 欄位
no.private.fields.to.generate.setters.for=沒有要為之生成 setter 的 private 欄位
no.response.from.0.after.1.ms={1} 毫秒後 {0} 未響應
no.type=NO_TYPE
node.is.interface=接口只能繼承一個接口
non.backed.enum.cannot.implement.interface.backedenum=非備用枚舉無法實作接口 'BackedEnum'
non.enum.class.cannot.implement.interface=非枚舉類別無法實作接口 ''{0}''
notication.group.php.debugger=PHP 偵錯器
notification.content.composer.executable.was.automatically.set.to.global.composer=Composer 可執行檔案已被自動設定為全域 'composer'
notification.content.configure.manually=手動組態
notification.content.disable.breakpoint.move.to.resolved.position=停用中斷點移動到已解析的位置
notification.content.disable.paratest=停用 ParaTest
notification.content.formatter.couldn.t.apply.result.external.tool=格式化程序無法套用外部工具的結果
notification.content.language.level.synchronisation.with.composer.was.disabled=已停用與 composer.json 的語言級同步
notification.content.language.level.was.changed.to.based.on.project.usage=語言級別已根據專案中使用的功能設定為 {0}
notification.content.link.copied.to.clipboard=鏈接 {0} 已複製到剪貼簿
notification.content.process.exited.with.non.zero.code=程序以非零程式碼退出
notification.content.tests.have.been.run.without.paratest=測試在沒有 ParaTest 的情況下執行
notification.content.timeout.while.fetching.data.from=從 {0} 提取資料時超時
notification.content.usage.found.in.project=在專案中找到了 {0} 用法
notification.content.vendor.directory.not.found=未找到 'vendor' 目錄
notification.content.xdebug.extension.not.installed=未安裝 Xdebug 擴展
notification.group.composer.install=建議使用 Composer 'install' 指令
notification.group.composer.language.level=已停用 Composer 語言級別同步
notification.group.dbgp.proxy=PHP 偵錯器代理
notification.group.debug.listener=PHP 偵錯偵聽器
notification.group.default.stubs=PHP 預設存根路徑不正確
notification.group.php=PHP
notification.group.php.3v4l=PHP 3v4l 整合
notification.group.php.cgi=PHP-CGI 伺服器
notification.group.php.code.style=建議進行 PHP 程式碼樣式檢查
notification.group.php.interpreters=PHP 解釋器問題
notification.group.php.plugin.suggestion=PHP 延伸模組建議
notification.group.php.profiler=PHP 分析器問題
notification.group.phpunit=PHPUnit
notification.group.quality.tools=PHP 外部品質工具
notification.paratest.mute=忽略
notification.title.cannot.read.snapshot=無法讀取快照
notification.title.incorrect.profiler.snapshot.format=分析器快照格式不正確
notification.title.paratest.doesn.t.support.filter.option=ParaTest 不支持 --filter 選項
null.cannot.be.marked.as.nullable='null' 不能被標記為可以為 null
number.of.days.in.the.given.month=給定月份中的天數(28 到 31)
numeric.representation.of.a.month.with.leading.zeros=月份的數字表示，帶前導零(01 到 12)
numeric.representation.of.a.month.without.leading.zeros=月份的數字表示，不帶前導零(1 到 12)
numeric.representation.of.the.day.of.the.week=星期几的數字表示(0 到 6)
object.property=物件屬性
older=較舊…
only.intersection.type.can.be.used.for.grouping=只能使用交叉類型進行分組
only.intersection.type.can.be.used.for.grouping1=只能使用交叉類型進行分組
only.simple.expressions.are.allowed=只允許簡單表達式
only.the.last.parameter.can.be.variadic=只有最後一個參數可以是可變形參
only.visibility.modifiers.can.be.applied.to.promoted.property=只能將可見性修飾符套用到提升的屬性
open.in.editor=在編輯器中開啟
open.inspection.settings=開啟 {0} 檢查設定
open.tool.settings=開啟 {0} 設定
opens.composer.json.to.change.php.property=開啟 'composer.json' 以更改 'php' 屬性
opens.inspection.0.setting=開啟檢查 ''{0}'' 設定
operating.system.name.eg.freebsd=作業系統名稱。例如，FreeBSD
or.disable.inspection=或
output.phpinfo=輸出 phpinfo():
output.phpinfo.title=輸出 phpinfo() 
override=覆寫
overriding.implementing.methods=覆寫/實作方法
overriding.private.methods=覆寫 private 方法
parameter=參數
parameter.is.deprecated=參數 ''{0}'' 已棄用
parameter.ref.type.is.not.compatible.with.declaration=參數 '#ref' 類型與宣告不相容
parameter.type.is.not.convertible.from.null=參數類型不可從 'null' 轉換
parameter1=參數
paratest=ParaTest
paratest.is.not.supported.for.selected.run.profile=ParaTest 與所選執行組態檔案不相容
paratest.runner.description=使用 ParaTest 執行所選組態
parser.expected=應為: {0}
parser.unexpected=意外: {0}
parsing.error,at.expected=應為 '@'
parsing.error.expression.not.assignable=表達式不可賦值
parsing.error.method.label.expected=應為方法標籤
parsing.error.not.allowed=不允許使用 ''{0}''
parsing.error.statement.expected=應為語句
parsing.error.unexpected.token=意外的標記: {0}
pass.by.ref.is.not.effectively.used.inside.body=參照沒有必要，因為實參既不通過參照賦值，也不通過參照進一步傳遞
path.0.is.invalid=路徑 ''{0}'' 無效
path.to.php=<php 路徑>
patterns.are.matched.on.fully.qualified.name.parameter.count.and.parameter.names=模式會通過完全限定名稱、參數計數和參數名稱進行符合。
percentage.lines={0}% 行
phar.exclude.from.project.action.title=從專案中排除 phar
phar.exclude.or.include.into.project.action.title=在專案中包含或排除 phar
phar.failed.to.parse=無法解析
phar.include.into.project.action.title=將 phar 包含到專案中
php=PHP
php.5.6.is.not.supported=不支持下載 PHP 5.6 版本的 Xdebug 擴展
php.add.exception=將 ''{0}'' 新增到現有 @throws 標記
php.add.field.declaration.quick.fix.text=新增屬性
php.add.method.declaration.quick.fix.text=新增方法
php.add.tag.base.quick.fix.family.name=新增 {0} 標記
php.annotator.exchange.extends.implements.keyword=將 ''{0} {2}'' 更改為 ''{1} {2}''
php.annotator.expecting.class=應為類別參照
php.annotator.expecting.interface=應為接口參照
php.annotator.heredoc.indent.validation.mixed.space.and.tab.characters=結束關鍵字縮排中混用了空格和制表符字元
php.annotator.heredoc.indent.validation.wrong.content.indent=縮排錯誤:應與結束標記縮排相同
php.annotator.return.type.make.nullable.fix=使返回值類型可為 null
php.annotator.return.type.non.nullable.null.returned=無法返回 'null': 返回值類型不可為 null
php.annotator.strict.types.block.mode='strict_types' 宣告不能使用塊模式
php.annotator.strict.types.first.statement='strict_types' 宣告必須是腳本中的第一條語句
php.annotator.typed.parameter.type.mismatch.fix.change=將參數類型更改為 ''{0}''
php.annotator.typed.parameter.type.mismatch.fix.family=更改參數類型以符合預設值的類型
php.annotator.typed.parameter.type.mismatch.fix.nullable=使參數類型可為 null
php.annotator.typed.property.callable.is.illegal=屬性不能有 'callable' 類型
php.annotator.typed.property.illegal.value=''{0}'' 類型的屬性可能沒有預設值
php.annotator.typed.property.type.mismatch=預設值只能是 ''{0}'' 類型
php.annotator.typed.property.type.mismatch.fix.change=將屬性類型更改為 ''{0}''
php.annotator.typed.property.type.mismatch.fix.family=更改屬性類型以符合預設值的類型
php.annotator.typed.property.type.mismatch.fix.nullable=使屬性類型可為 null
php.annotator.void.function.must.not.return.value=void 函式不得返回值
php.append.doc.static.fix.family.name=在函式參照前追加 '::'
php.cgi.not.found=請確保<a href="">組態的 PHP 解釋器</a>作為 CGI 程序建置(指定了 --enable-fastcgi)
php.cgi.not.found.title=找不到 {0}
php.change.cast.operation.quick.fix.family.name=將轉換更改為{0}
php.change.function.signature.from.usage.quick.fix.family.name=從用法改變函式簽名
php.change.function.signature.manually.quick.fix.family.name=手動更改簽名
php.change.method.modifiers.quick.fix.family.name=更改修飾符
php.change.method.modifiers.quick.fix.text=移除修飾符
php.change.signature.conflict.with.local.var=參數 ''{0}'' 與函式 ''{1}'' 內的區域變數衝突
php.change.signature.conflict.with.local.var.method=參數 ''{0}'' 與來自 ''{2}'' 的方法 ''{1}'' 內的區域變數衝突
php.check.validity.reg.exp=在專用對話框中檢查正則表達式的有效性
php.class=類別
php.code.style.convert.keyword.to.lowercase=將關鍵字轉換為小寫
php.code.style.convert.lower.case=小寫
php.code.style.convert.upper.case=大寫
php.code.style.sort.alphabetically=按字母順序
php.code.style.sort.by.length=按長度
php.code.style.sort.use.stmt=對 'use' 語句排序:
php.configure.extensions.quick.fix.family.name=組態擴展存根
php.console=PHP 主控台
php.control.flow.viewer=PHP 控制流檢視器
php.control.flow.viewer.0=PHP 控制流檢視器: {0}
php.conversion.code.style.title=程式碼轉換
php.create.data.provider.quick.fix.family.name=建立資料提供程序
php.dead.code.entries=PHP 死碼條目
php.debug.action.include.return.value.breakpoint.step.description=啟用額外的“從函式返回”偵錯步驟
php.debug.action.watches.method.return.value.enable=啟用函式返回值偵錯
php.debug.action.watches.method.return.value.unavailable.reason=從 Xdebug 3.2 起才支援返回值偵錯
php.debug.state.widget=停止/啟動偵錯偵聽
php.debug.validate.got.it=偵錯驗證
php.debug.validate.got.it.descr=您可以使用偵錯驗證對話框驗證設定
php.delete.catch.clause.quick.fix=刪除 'catch' 子句
php.delete.exception.quick.fix=刪除異常
php.element.is.available.starting.with.php.version=''{0}'' 從 PHP 版本 {1} 開始可用
php.element.was.removed.in.php.version=''{0}'' 已在 PHP {1} 版本中被移除
php.embedded.stubs.incorrect.path.warning.message=組態的預設存根路徑 ''{0}'' 不存在，改為使用嵌入式存根。
php.embedded.stubs.incorrect.path.warning.title=預設存根路徑不正確
php.embedded.stubs.notification.provider.clone=在 GitHub 上克隆
php.embedded.stubs.notification.provider.do.not.show.again=不再顯示
php.embedded.stubs.notification.provider.notification=您正在檢視不可變的嵌入式存根。為了能夠編輯這些存根，您需要克隆一個存根專案，然後通過“PHP / PHP 執行時 / 進階設定”提供預設存根路徑。
php.embedded.stubs.notification.provider.provide=提供預設存根路徑
php.empty.project.generator.description=為 PHP 建立空專案
php.empty.project.generator.name=PHP 空專案
php.enable.extension.quick.fix.family.name=啟用擴展存根
php.enable.extension.quick.fix.text=啟用 ''{0}'' 擴展存根
php.enum=枚舉
php.exception.is.never.thrown=函式中從未拋出異常 ''{0}''
php.executable.macro.description=專案設定中組態的 Php 可執行檔案
php.external.formatter=PHP 外部格式化程序
php.external.formatter.title=外部格式化程序
php.extract.class=PHP 提取類別
php.find.clause.throws=可能拋出: {0}
php.flip.arguments.quick.fix.family.name=翻轉第一和第二個實參
php.flip.variable.and.type.quick.fix.family.name=翻轉變數和類型
php.framework.enable.plugin=啟用延伸模組
php.framework.install.plugin=安裝延伸模組
php.framework.laravel.plugin=Laravel Idea
php.framework.settings.page=設定
php.framework.symfony.plugin=Symfony
php.generation.code.style.title=程式碼生成
php.info.parse.exception=無法解析 php 資訊: {0} 是空的
php.information.dialog.title=PHP 資訊
php.inline.variable.quick.fix.family.name=內聯變數
php.intention.category=PHP
php.interface=接口
php.interpreter.base.configuration.fix.interpreter={0}。要修復，請<a href=''{1}''>更改</a>專案解釋器或<a href=''{2}''>檢查</a>設定。
php.interpreter.base.configuration.interpreter.is.invalid=無法執行 {0}，因為{1}組態的解釋器無效。
php.interpreter.base.configuration.is.not.provided.or.empty={1} 的 {0} 路徑未組態。您可以在“PHP|{0}”下進行修復
php.interpreter.base.configuration.working.directory=無法檢測工作目錄，請在執行組態中進行組態。
php.interpreter.custom.ini.label=組態檔案:
php.interpreter.info.failed.to.parse.validation.script=無法解析驗證腳本輸出
php.interpreter.is.remote.message=請<a href="">選擇本地 PHP 解釋器</a>以使用內建 Web 伺服器
php.interpreter.is.remote.title=已組態遠端 PHP 解釋器
php.interpreter.label.label=標籤
php.interpreter.not.configured=請<a href="">組態 PHP 解釋器</a>以使用內建 Web 伺服器
php.interpreter.not.configured.title=未組態 PHP 解釋器
php.language.level.widget=PHP 語言級別
php.make.class.abstract.quick.fix.family.name=將類別設為 abstract
php.make.class.non.final.quick.fix.family.name=將類別設為非 final
php.make.method.non.abstract.quick.fix.family.name=將方法設為非 abstract
php.make.method.non.final.quick.fix.family.name=將方法設為非 final
php.make.method.non.static.quick.fix.family.name=將方法設為非 static
php.method.name.empty=未指定測試方法
php.method.not.found=在類別 ''{1}'' 中未找到方法 ''{0}''
php.non.strict.object.equality.quick.fix.text=取代為身份比較
php.not.test.method=類別 ''{1}'' 中的方法 ''{0}'' 不是測試方法
php.path.was.updated={0} 自訂
php.path.was.updated.text=專案預設解釋器已被新增到 {0}
php.prefdefined.codestyle.psr12.chosen.message=您可以啟用其他 PSR-12 檢查，這些檢查當前已停用。
php.prefdefined.codestyle.psr12.chosen.title=PSR-12 程式碼樣式
php.prefdefined.codestyle.psr12.enabled.message=PSR-12 檢查已啟用。
php.project.configurable.composer.configs.tab.name=Composer 檔案
php.project.configurable.composer.duplicate.configurations=已經存在具有相同 composer.json 的組態
php.project.configurable.composer.main=主
php.quick.documentation.namespace.classes=命名空間類別:
php.remote.debug.name=PHP 遠端偵錯
php.remote.interpreter.plugin.is.not.installed=PHP Remote Interpreter 延伸模組未安裝
php.remove.all.unused.parameters.quick.fix.text=移除所有未使用的參數
php.remove.doc.tag.quick.fix.family.name=移除 {0}
php.remove.exception.from.throws=從 @throws 標記中移除 ''{0}''
php.remove.parameters.quick.fix.text=移除未使用的參數
php.remove.pass.by.ref.from.parameter.quick.fix.family.name=從參數中移除 '&'
php.remove.ref.from.assignment.quick.fix.family.name=將 '=\\\\&' 取代為 '='
php.remove.ref.from.function.declaration.quick.fix.family.name=從函式宣告中移除 '&'
php.remove.statement.fix.family.name=移除
php.remove.throws.tag=從 @throws 標記移除
php.remove.unused.local.variable.without.successor.quick.fix.family.name=移除變數 ''{0}''
php.rename.wrong.reference.quick.fix.family.name=重新命名參照
php.replace.argument.with.cast.quick.fix.family.name=將實參轉換為{0}
php.replace.try.from.with.null.quick.fix.family.name=將 'tryFrom()' 呼叫取代為 'null'
php.replace.with=取代為 ''{0}''
php.replace.with.float.cast.quick.fix.family.name=取代為 '(float)' 轉換
php.replace.with.interface.quick.fix.family.name=取代為 {0}
php.replace.with.local.variable.quick.fix.family.name=將屬性取代為區域變數
php.replace.with.null.quick.fix.family.name=取代為 'null'
php.run.check.reg.exp=執行檢查 RegExp 意圖 {0}
php.run.http.border.title.configuration=組態
php.run.label.https=HTTPS:
php.run.label.interpreter=解釋器:
php.run.label.query.string=查詢字串:
php.run.label.request.body=請求正文:
php.run.label.request.method=請求方法:
php.run.label.send.request.body.as=將請求正文發送為:
php.run.label.server=伺服器:
php.run.label.url=URL:
php.run.radio.button.key.value=鍵值
php.run.radio.button.text=文本
php.smart.indent.codestyle.indent.in.php=縮排 PHP 標記中的程式碼
php.surround.with.if=if
php.surround.with.try.catch.quick.fix=使用 'try-catch' 包圍
php.tag.is.deprecated={0} 已棄用，將在 PHPUnit 9 中移除
php.test.framework.by.sdk.dialog.label=解釋器(&I):
php.test.framework.by.sdk.new.settings.dialog.title=通過遠端解釋器{0}
php.test.framework.by.sdk.settings.already.exist=所選解釋器的 {0} 設定已存在
php.test.framework.by.sdk.settings.remote.path.title=選擇伺服器上的路徑
php.test.framework.by.sdk.settings.select.server=選擇遠端解釋器以組態遠端{0}
php.test.framework.configuration.can.not.update=無法更新 {0} 版本
php.test.framework.configuration.ui.library={0} 庫
php.test.framework.configuration.ui.not.installed=未安裝
php.test.framework.configuration.ui.path.to.exe={0} 可執行檔案路徑:
php.test.framework.configuration.ui.select.interpreter=請選擇 PHP 解釋器以載入 {0} 版本
php.test.framework.configuration.ui.select.local.interpreter=請選擇本地 PHP 解釋器以載入 {0} 版本
php.test.framework.configuration.ui.test.runner=測試執行程序
php.test.framework.configuration.ui.use.configuration.file=預設組態檔案:
php.test.framework.configuration.ui.version={0} 版本: {1}
php.test.framework.configuration.updated.version=已成功更新 {0} 版本
php.test.framework.default.interpreter.is.not.local=無法檢測到 {0} 版本。預設 PHP 解釋器不是本地解釋器
php.test.framework.download.hyperlink={0} 版本: <a href={1}>{1}</a>
php.test.framework.field.test.runner.options=測試執行程序選項(&O):
php.test.framework.interpreter.conflict=發現應用程式級 {0} 組態衝突。為解決該問題，建立了以下組態的專案級副本:
php.test.framework.interpreter.conflict.title={0} 組態衝突
php.test.framework.no.configuration.types.are.available=沒有可用的其他組態類型
php.test.framework.project.level=(當前專案)
php.test.framework.run.configuration.ui.alternative.configuration.file=使用替代組態檔案(&U):
php.test.framework.run.configuration.ui.alternative.custom.file=使用替代 {0}(&U)
php.test.framework.run.configuration.ui.configuration.radio.button=在組態檔案中定義(&C)
php.test.framework.run.configuration.ui.custom.file.radio.button=在 {0} 中定義
php.test.framework.run.configuration.ui.directory.radio.button=目錄 (&D)
php.test.framework.run.configuration.ui.directory.text.field=目錄:
php.test.framework.run.configuration.ui.file.radio.button=檔案(&F)
php.test.framework.run.configuration.ui.file.text.field=檔案:
php.test.framework.run.configuration.ui.scenario.radio.button=方法(&M)
php.test.framework.run.configuration.ui.scenario.text.field=方法:
php.test.framework.run.configuration.ui.scope=測試作用域:
php.test.framework.run.configuration.ui.type.combo.box=類型:
php.test.framework.run.configuration.ui.type.radio.button=類型(&T)
php.test.framework.run.confuguration.ui.dialog.caption.test.runner.options=測試執行程序選項
php.test.framework.select.type.of.settings.popup.title=選擇組態類型
php.test.framework.settings.is.not.provided.or.empty={1} 的 {0} 路徑未組態。按“修復”以編輯您的 {0} 組態。
php.test.framework.undefined.interpreter=未定義
php.test.framework.untrusted.reload=在安全模式下禁止重新整理測試框架的版本
php.test.framework.validation.run.configuration.file.working.directory=檔案應該是工作目錄的子項: ''{0}''
php.test.framework.validation.run.configuration.method=在 ''{1}'' 中找不到 ''{0}''
php.test.framework.validation.run.configuration.no.type=如果未選擇類型則無法執行測試。
php.test.framework.validation.run.configuration.unsupported.type=無法通過 ''{0}'' 指令執行測試。
php.test.framework.validation.run.configuration.working.directory=目錄應該是工作目錄的子目錄: ''{0}''
php.test.framework.version.configuration.ui.can.not.parse.version=無法解析版本指令輸出。\\n\\
{0}
php.test.framework.version.detector.empty.output=''{0}'' 指令輸出為空。
php.test.framework.version.getting.version.title=正在獲取 {0} 版本…
php.test.framework.version.path.to.exe.is.invalid={0} 可執行檔案的路徑為空或無效。
php.test.frameworks.form.application=\\ (應用程式)
php.testframework.local.interpreter=本地解釋器
php.testframework.local.interpreter.version=本地 PHP {0}
php.testframework.remote.interpreter=遠端 {0}
php.title.docker.compose.settings=Docker Compose 設定
php.trait=特徵
php.turn.off.path.modification=關閉 {0} 自訂
php.uml.provider.presentable.name=PHP 類別圖
php.unit.checkbox.use.alternative.patterns.base.path=使用替代模式基路徑:
php.unit.create.target.class.quick.fix.family.name=建立缺少的目標類別
php.unit.create.target.method.quick.fix.family.name=建立缺少的目標方法
php.unit.label.test.file.template=測試檔案模板(&T):
php.unit.local.run.description=PHPUnit
php.unit.local.run.display.name=PHPUnit
php.unit.optional=可選
php.unit.radio.button.composite=複合
php.unit.test.runner.options=測試執行程序選項
php.web.application.name=PHP Web 應用程式
php.web.server.validation.action.text=Web 伺服器偵錯驗證
php.web.server.validation.additional.configuration.files=<b>已解析的其他 .ini 檔案:</b> {0}
php.web.server.validation.chose.path.to.script=選擇驗證腳本的路徑
php.web.server.validation.chose.path.to.script.description=選擇本地目錄以建立驗證腳本
php.web.server.validation.client.host.is.reachable=<b>偵錯客戶端主機</b>: 可以存取
php.web.server.validation.client.host.is.unreachable=<b>偵錯客戶端主機</b>: 無法存取
php.web.server.validation.client.host.is.unreachable.descr=請確保已正確組態 <i>xdebug.remote_host</i> (適用於 Xdebug 2)、<i>xdebug.client_host</i> (適用於 Xdebug 3)或 zend_debugger。值可以是執行 PhpStorm 的機器的主機名(例如，localhost)或 IP 地址，並且必須可以從伺服器 ping 通。使用 Xdebug 時，<i>xdebug.remote_connect_back</i> (適用於 Xdebug 2)或 <i>xdebug.discover_client_host</i> (適用於 Xdebug 3)可用於故障排除。
php.web.server.validation.client.phpstorm.is.reachable=<b>PhpStorm:</b> 準備接收 Xdebug 連線
php.web.server.validation.client.phpstorm.is.unreachable=<b>PhpStorm:</b> 無法接收 Xdebug 連線
php.web.server.validation.client.phpstorm.is.unreachable.descr=偵聽傳入偵錯連線可能被停用，或者可能在設定中為傳入連線指定了錯誤的連接埠
php.web.server.validation.configuration.files=<b>已載入的 php.ini:</b> {0}
php.web.server.validation.configure.local=請組態驗證腳本的本地和 Web 路徑
php.web.server.validation.configure.phpinfo=請貼上 <i>phpinfo()</i> 的完整輸出
php.web.server.validation.configure.phpinfo.desc=複製並貼上 HTML 版本、HTML 源或 <i>php -i</i> 輸出
php.web.server.validation.configure.remote=請組態驗證腳本的路徑並選擇部署伺服器
php.web.server.validation.configure.validation.script=請下載驗證腳本歸檔並指定腳本目錄的 Web 路徑
php.web.server.validation.deployment.server=部署伺服器(&D):
php.web.server.validation.deployment.server.tooltip=所選伺服器會用於將驗證腳本部署到遠端伺服器
php.web.server.validation.dialog.validate.button=驗證(&V)
php.web.server.validation.docker=<b>在 Docker 容器中</b>: {0}
php.web.server.validation.failed.to.deploy.validation.script=無法將驗證腳本部署到伺服器
php.web.server.validation.failed.to.execute.script=指定的 URL 不可到達，原因是: ''{0}''
php.web.server.validation.failed.to.fetch.script.result=無法提取驗證腳本的結果
php.web.server.validation.failed.to.find.deployment.settings=找不到伺服器的部署設定
php.web.server.validation.failed.to.find.web.path=請組態驗證腳本的 Web 路徑
php.web.server.validation.failed.to.map.deployment.folder=請為驗證目錄組態遠端路徑映射
php.web.server.validation.failed.to.map.deployment.folder.to.web=請為驗證目錄組態 Web 路徑映射
php.web.server.validation.failed.to.unzip=無法從 {0} 提取資料
php.web.server.validation.invalid.path.to.script=驗證目錄的路徑無效
php.web.server.validation.loaded.debugger.extension=<b>偵錯器擴展:</b> {0}
php.web.server.validation.local.path.to.script=建立驗證腳本的路徑(&P):
php.web.server.validation.local.path.to.script.tooltip=所選路徑應可通過 Web 伺服器存取
php.web.server.validation.local.web.server.radio=本地 Web 伺服器或共享目錄(&L)
php.web.server.validation.multi.debugger.extension=Xdebug 和 Zend Debugger 擴展均已載入
php.web.server.validation.multi.debugger.extension.description=只有一個偵錯器擴展可在 php.ini 中載入。
php.web.server.validation.no.configuration.files=找不到 php.ini 檔案
php.web.server.validation.no.debugger.extension=未載入偵錯擴展
php.web.server.validation.os=<b>客戶端主機作業系統</b>: {0}
php.web.server.validation.os.server=<b>伺服器主機作業系統</b>: {0}
php.web.server.validation.process.title=驗證 Web 伺服器
php.web.server.validation.reference.to.documentation=請參閱<a href="{0}">{0}</a>獲取更多資訊。
php.web.server.validation.remote.web.server.radio=遠端 Web 伺服器(&R)
php.web.server.validation.script.local.result.path.mapping.check=請檢查是否為 <b>''{0}''</b> 目錄正確組態了驗證腳本的 Web 路徑
php.web.server.validation.script.result.is.empty=驗證腳本的結果為空
php.web.server.validation.script.result.path.mapping.check=請檢查是否在部署設定中為 <b>''{0}''</b> 目錄正確組態了遠端和 Web 路徑映射
php.web.server.validation.script.result.wrong.format=驗證腳本的結果具有意外格式
php.web.server.validation.server.name=<b>伺服器名稱:</b> {0}
php.web.server.validation.server.name.is.empty=伺服器名稱為空
php.web.server.validation.server.name.is.empty.description=伺服器名稱對於 PhpStorm 中的標識是必要的。<br>請在 Web 伺服器組態檔案中進行組態。
php.web.server.validation.synonym=驗證偵錯
php.web.server.validation.synonym2=驗證 Xdebug
php.web.server.validation.title=驗證 Web 伺服器上的偵錯器組態
php.web.server.validation.uploading.validation.script=正在將驗證腳本上傳至 {0}
php.web.server.validation.url.to.validation.script=驗證腳本的 URL(&U):
php.web.server.validation.url.to.validation.script.tooltip=所選 Web 路徑將用於執行驗證腳本
php.web.server.validation.xdebug.debugger.host=<b>遠端主機:</b> {0}
php.web.server.validation.xdebug.debugger.host.description=正在執行偵錯器<b>客戶端</b>的主機。
php.web.server.validation.xdebug.debugger.host.remote.addr=<br/><br/>在 php.ini 檔案中，將 <b>''{0}''</b> 設為 <i>''{1}''</i> 或自 Web 伺服器可見的本地機器 IP 地址。
php.web.server.validation.xdebug.debugger.localhost=儘管伺服器主機可能不在本地，但遠端主機仍組態為 ''{0}''
php.web.server.validation.xdebug.mode.is.not.supported=不支持遠端模式 ''{0}''
php.web.server.validation.xdebug.option.is.enabled=<b>{0}:</b> 選項已啟用
php.web.server.validation.xdebug.option.is.ignored.description=<b>{0}:</b> 選項將被忽略。
php.web.server.validation.xdebug.option.is.not.enabled.description=<b>{0}:</b> 選項未啟用
php.web.server.validation.xdebug.port=<b>遠端連接埠:</b> {0}
php.web.server.validation.xdebug.port.require.sudo=<b>遠端連接埠:</b> {0}，需要根權限才能使用
php.web.server.validation.xdebug.port.require.sudo.description=要在 Linux 和 Mac 上使用小於 1024 的連接埠，必須具有根權限。
php.web.server.validation.xdebug.protocol.is.not.supported=不支持偵錯協議 ''{0}''
php.web.server.validation.xdebug.remote.autostart.description=偵錯會話將嘗試為每個請求啟動。
php.web.server.validation.xdebug.remote.is.not.enable=遠端偵錯未啟用
php.web.server.validation.xdebug.remote.is.not.enable.description=將 <b>''{0}''</b> 行新增到 php.ini 檔案。
php.web.server.validation.xdebug.remote.log=<b>{0}:</b> {1}
php.web.server.validation.xdebug.remote.mode.jit=<b>遠端模式:</b> 'jit'
php.web.server.validation.xdebug.remote.mode.jit.description=偵錯會話將僅在出現錯誤後初始化。
php.web.server.validation.xdebug.remote.mode.req=<b>遠端模式:</b> 'req'
php.web.server.validation.xdebug.remote.mode.req.description=偵錯會話將在腳本啟動時初始化。
php.web.server.validation.xdebug.wrong.port=Xdebug 連接埠(''{0}'')與“PHP->偵錯 IDE”設定(''{1}'')不同
php.web.server.validation.xdebug.wrong.port.description=來自 php.ini (<b>{0}</b>)的 Xdebug 連接埠應與在 IDE 內(在 <b>PHP->偵錯</b>下)組態的連接埠相同。
php.web.server.validation.xdebug.wrong.port.format=<b>Xdebug 連接埠無效:</b> ''{0}''
php.web.server.validation.xdebug.zend.extension.load=Xdebug 必須通過 'zend_extension' 而不是 'extension' 載入
php.web.server.validation.xdebug.zend.extension.load.description=在 php.ini 檔案中使用 <b>'zend_extension=path_to_xdebug.so'</b> 行以載入 Xdebug 擴展。
php.web.server.validation.xdebug3.cloud.php.ini.xdebug.disabled.message=<b>Php.ini 雲偵錯:</b> 已停用。
php.web.server.validation.xdebug3.cloud.xdebug.correct.cloud.id.message=<b>IDE 中的雲 ID:</b> 與伺服器上的雲 ID 相同
php.web.server.validation.xdebug3.cloud.xdebug.disabled.message=<b>通過 Xdebug Cloud 連線:</b> 已停用。請在 IDE 設定中進行啟用: <b>PHP->偵錯->XDebug Cloud</b>
php.web.server.validation.xdebug3.cloud.xdebug.doesnt.accept.connections.message=Xdebug 現在不接受外部連線
php.web.server.validation.xdebug3.cloud.xdebug.wrong.cloud.id.description=<b>IDE 中的雲 ID:</b> {0}<br><b>伺服器上的雲 ID:</b> {1}
php.web.server.validation.xdebug3.cloud.xdebug.wrong.cloud.id.message=<b>IDE 中的雲 ID:</b> 與伺服器上的雲 ID 不同
php.web.server.validation.xdebug3.discover.client=根據 <b>$_SERVER['HTTP_X_FORWARDED_FOR']</b> 和 <b>$_SERVER['REMOTE_ADDR']</b> 中的值，Xdebug 將嘗試自動連線到客戶端。若失敗，則回到 <b>'xdebug.client_host'</b>。
php.web.server.validation.xdebug3.discover.client.message=<b>發現客戶端主機:</b> xdebug 將嘗試自動提取客戶端主機。
php.web.server.validation.xdebug3.discover.client.no=<b>發現客戶端主機</b>: 關閉
php.web.server.validation.xdebug3.discover.client.with.discover.header=根據 <b>$_SERVER[''{0}'']</b> 中的值，Xdebug 將嘗試自動連線到客戶端。若失敗，則以空的 <b>''xdebug.client_discovery_header''</b> 回到 <b>''xdebug.discover_client_host''</b>。
php.web.server.validation.xdebug3.option.in.invalid.mode=''{0}'' 選項設定為 ''{1}''，這對於 xdebug3 是無效模式。
php.web.server.validation.xdebug3.option.is.enabled.message=<b>{0}</b>: 選項被設定為 ''{1}''。
php.web.server.validation.xdebug3.remote.mode.emulation.description=偵錯會話將在腳本啟動時初始化，與 xdebug2 的 <b>remote_mode=''{0}''</b> 相同。
php.web.server.validation.xdebug3.remote.mode.emulation.message=<b>遠端模式:</b> xdebug2 的 ''{0}'' 已模擬。 
php.web.server.validation.xdebug3.start.upon.error.description=偵錯會話將嘗試根據相應組態在錯誤時自動啟動。
php.web.server.validation.xdebug3.start.with.request.description=偵錯會話將嘗試根據相應組態自動啟動。
php.web.server.validation.zend.debugger.deny.host=<b>拒絕主機:</b> {0}
php.web.server.validation.zend.debugger.deny.host.description=無法使用拒絕主機從客戶端進行偵錯。
php.web.server.validation.zend.debugger.host=<b>遠端主機:</b> {0}
php.web.server.validation.zend.debugger.localhost=儘管伺服器不在本地，但偵錯會話僅適用於本地主機。
php.web.server.validation.zend.debugger.localhost.description=將正在執行偵錯器<b>客戶端</b>的主機新增至 <b>'zend_debugger.allow_hosts'</b> 選項。
php.web.server.validation.zend.expose.remotely=<b>屬性 ''expose_remotely''</b> 設為 ''{0}''
php.web.server.validation.zend.expose.remotely.allowed.hosts.description=偵錯器會話將嘗試從 <b>'zend_debugger.allow_hosts'</b> 選項為主機啟動。
php.web.server.validation.zend.expose.remotely.always.description=偵錯器會話將嘗試為每個客戶端啟動。
php.web.server.validation.zend.expose.remotely.never.description=偵錯器會話將不會進行初始化，<b>'zend_debugger.allow_hosts'</b> 選項將被忽略。<br>將選項 <b>'zend_debugger.expose_remotely'</b> 設定為 'allowed_hosts' 或 'always' 以啟用 Web 伺服器偵錯。
php.web/server.validation.validation.script=偵錯驗證腳本
php.xdebug.enable.dfa.assist=預測分析程序數據流的未來條件值
php.xdebug.enable.dfa.assist.gray.mode=將預計無法存取的程式碼塊變灰
php.xdebug.move.to.resolve.breakpoint=如果中斷點與源不同，則將中斷點移動到已解析的位置
phpdoc.code.style.convert.else.if.combine=elseif
phpdoc.code.style.convert.else.if.separate=else if
phpdoc.code.style.convert.else.if.to=將 else if/elseif 轉換為:
phpdoc.code.style.convert.null.to=將 Null 常數轉換為:
phpdoc.code.style.convert.true.false.to=將 True/False 常數轉換為:
phpdoc.code.style.force.null.position=將 'null' 置於以下類型中:
phpdoc.code.style.generated.doc.blocks=生成的 PHPDoc 標記
phpdoc.code.style.in.beginning.position=在開頭
phpdoc.code.style.in.end.position=在結尾
phpdoc.code.style.param.spaces.between.name.and.description=在名稱與描述之間:
phpdoc.code.style.param.spaces.between.tag.and.type=在標記與類型之間:
phpdoc.code.style.param.spaces.between.type.and.name=在類型與名稱之間:
phpdoc.code.style.param.spaces.panel=PHPDoc '@param' 空間
phpdoc.code.style.sort.doc.blocks=PHPDoc 標記順序
phpdoc.code.style.throws.analysis.depth.performance.note.message=不建議深入分析多個級別，因為這可能會影響 IDE 性能。要繼續嗎?
phpdoc.code.style.throws.analysis.depth.performance.note.title=性能註釋
phpdoc.code.style.title=PHPDoc
phpunit.10.won.t.support.classname.annotations=PHPUnit 10 將不支持 ClassName::<*> 註解
phpunit.can.not.rerun.failed.tests.title=無法執行失敗的 PHPUnit 測試。
phpunit.config.directory.label=目錄:
phpunit.config.empty.pattern=空模式
phpunit.config.label=測試根
phpunit.getting.phpunit.version=正在更新 PhpUnit 版本…
phpunit.label.data.set=資料集:
phpunit.not.tests.was.executed.message=要修復，為 <i>{0}</i> <a href="config">組態</a>自動載入檔案或 PHPUnit phar 路徑。
phpunit.not.tests.was.executed.title=未組態 PHPUnit
platform.reqs.are.missing=缺少平台要求。
please.enter.your.password.to.make.install.xdebug.extension=輸入您的密碼以安裝 Xdebug 擴展:
plural.types.are.not.allowed.in.real.types=僅在 doc 類型中允許複數類型
popup.content.configuration.remains.unchanged=當前組態與解釋器同步
popup.content.enabled.disabled.extensions=已啟用{0}和已停用{1}擴展
popup.select.target.code.block.closure=箭頭函式體(轉換為閉包)
popup.select.target.code.block.containing.block=包含塊
popup.title.multiple.write.scopes.found=找到多個寫入作用域
popup.title.select.reference.to.remove=選擇要移除的類型
popup.title.select.target.code.block=選擇目標程式碼塊
possible.tool.process.hangup.after.0.sec={0} 秒後可能工具過程掛起。
postfix.template.provider.display.name=PHP
potentially.polymorphic.call.multiple.subclasses=潛在的多態呼叫。該程式碼可能無法動作，具體取決於作為實參傳遞的實際類別實例。
potentially.polymorphic.call.single.subclass=潛在的多態呼叫。{0} 的層次結構中沒有成員
primitive.hints.name.are.forbidden.in.php.7=PHP 7 中禁止名為 'int'、'string'、'float'、'bool'、'true'、'false' 和 'null' 的類別
private.constant.cannot.be.final='private' 常數不能為 'final'，因為它對其他類別不可見
private.methods.cannot.be.final=private 方法不能是 final，因為它們從不會被其他類別覆寫
proceed=繼續
profiler.button.refresh=重新整理
profiler.column.invocation.callable=可調用
profiler.column.invocation.count.title=呼叫
profiler.column.memory.title=記憶體(B)
profiler.column.own.memory.title=自身記憶體(B)
profiler.column.own.time.title=自用時間
profiler.column.script=腳本
profiler.column.time.title=時間
profiler.label.time=時間:
profiler.measurement.unit.microsecond=微秒
profiler.measurement.unit.microsecond.short=µs
profiler.measurement.unit.millisecond=毫秒
profiler.measurement.unit.millisecond.short=毫秒
profiler.measurement.unit.second=秒
profiler.measurement.unit.second.short=秒
profiler.view.call.tree.title=呼叫樹
profiler.view.callees.title=被呼叫方
profiler.view.callers.title=呼叫方
profiler.view.execution.statistics.title=執行統計
profiler.xdebug.file.chooser.title=選擇 Xdebug 分析器快照
profiler.xdebug.task.parsing=正在解析 ''{0}''
profiler.xdebug.task.title=分析 Xdebug 分析器快照
progress.text.fetching.result.from=正在從 {0} 提取結果
progress.text.submitting.code.to.3v4l.org=正在將程式碼提交到 3v4l.org
progress.title.executing.3v4l.org=正在 3v4l.org 上執行程式碼
project.files=專案檔案
project.is.already.disposed=專案已被處置
promoted.property=提升屬性
property=屬性
property.declaration=屬性宣告
property.is.undefined=屬性 '#ref' {0,choice,0#未定義|1#可能未定義}
property.is.undefined.in.class=屬性 ''#ref'' 在 {0} 中{1,choice,0#未找到|1#可能未定義}
property.or.function=屬性或函式
property.read=@property-read
property.write=@property-write
provide.the.full.path.to.executable=提供可執行檔案的完整路徑。
proxy.configuration=代理組態
proxy.init=代理初始化
proxy.stop=代理停止
psr.12.add.missing.parameter.list=PSR-12: 新增缺少的參數列表
psr.12.add.public.visibility=PSR-12: 新增 'public' 可見性
psr.12.convert.to.short.form=PSR-12: 轉換為縮寫
psr.12.extract.namespace=PSR-12: 提取命名空間
psr.12.fix.modifiers.order=PSR-12: 修復修飾符順序
psr.12.replace.var.with.public=PSR-12: 將 'var' 取代為 'public'
psr.12.split.to.several.use.statements=PSR-12: 拆分為多個 'use' 語句
psr.roots.revert=還原
public.and.static='public' 和 'static'
quality.inspection.button.tooltip=該按鈕顯示相應的檢查是否開啟
quality.tool.action.clean.list.text=清除列表
quality.tool.action.remove.file.s.from.list.text=從列表中移除檔案
quality.tool.border.title.ignored.files=已忽略的檔案
quality.tool.button.validate=驗證
quality.tool.can.not.create.temporary.file=PhpStorm 無法建立臨時檔案
quality.tool.can.not.determine.version=無法確定工具版本，得到 ''{0}''
quality.tool.can.not.retrieve.standards=無法檢索可用規則集，請檢查 PHP CS Fixer 工具組態。
quality.tool.checkbox.installed.standard.paths=已安裝的標準路徑:
quality.tool.checkbox.show.sniff.name=顯示 sniff 名稱
quality.tool.checkbox.show.warning.as=將警告顯示為:
quality.tool.coding.stardards.has.been.updated=已安裝的編碼標準列表已更新。
quality.tool.configuration.can.not.find.configuration.by.id=按 ID 找不到 {0} 組態: ''{1}''
quality.tool.configuration.default.interpreter.is.not.found=預設選擇 {0} 組態解釋器，但未指定解釋器
quality.tool.configuration.for.interpreter.is.not.found=找不到解釋器的 {0} 組態: ''{1}''
quality.tool.configuration.interpreter.is.undefined={0} 組態的解釋器未指定或無效
quality.tool.configuration.tool.path.is.empty=所選組態的 {0} 路徑為空
quality.tool.cs.fixer.allow.risky.rules=允許為內建規則集設定有風險的規則
quality.tool.cs.fixer.custom.rules.warning=選擇 'Custom' 類型以選擇您的組態。
quality.tool.cs.fixer.reformat.action=PHP CS Fixer: 修復整個檔案
quality.tool.cs.fixer.ruleset=規則集:
quality.tool.empty.path.phpcs={0} 的路徑為空
quality.tool.file.not.found=找不到檔案。
quality.tool.ignored.files={0} 忽略的檔案
quality.tool.label.check.files.with.extensions=檢查帶副檔名的檔案:
quality.tool.label.coding.standard=編碼標準:
quality.tool.label.configuration=組態:
quality.tool.label.custom.rulesets=自訂規則集:
quality.tool.label.label=標籤
quality.tool.label.tool.path=工具路徑:
quality.tool.label.tool.process.timeout=工具處理超時，[1...60] 秒:
quality.tool.label.validation.label=驗證標籤
quality.tool.laravel.pint=Laravel Pint
quality.tool.laravel.pint.json.path=pint.json 路徑:
quality.tool.laravel.pint.quick.fix.text=Laravel Pint: 修復整個檔案
quality.tool.laravel.pint.reformat.only.uncommitted.files=僅重新格式化未提交的檔案
quality.tool.laravel.pint.ruleset=規則集:
quality.tool.laravel.pint.should.be.json.file=選擇 .json 檔案
quality.tool.path.must.not.be.empty=路徑不得為空。
quality.tool.php.cs.fixer.required.phpcs.version=支援的 PHP CS Fixer 版本為 2.8.0 或更高，找到的是 {0}
quality.tool.php.dir.does.not.contain=該目錄不包含{0}
quality.tool.php_cs.custom.rules.validation.not.php_cs=PHP CS Fixer 不支持所選規則集
quality.tool.php_cs.dir.does.not.contain.custom=此目錄不包含任何受支援的檔案: {0}
quality.tool.phpcbf.location=PHPCBF 位置
quality.tool.phpcbf.location.descr=選擇有效的 phpcbf 啟動器
quality.tool.phpcbf.name=PHP Code Beautifier and Fixer
quality.tool.phpcbf.path=phpcbf 路徑:
quality.tool.phpcbf.reformat.action=PHP Code Beautifier and Fixer: 修復整個檔案
quality.tool.phpcbf.settings=PHP Code Beautifier and Fixer 設定
quality.tool.phpcs.can.not.retrieve.standards=無法檢索可用標準，請檢查 PHP_CodeSniffer 工具組態。
quality.tool.phpcs.custom.rules.validation.not.xml=所選規則集不是 XML
quality.tool.phpcs.custom.rules.warning=選擇 'Custom' 編碼標準類型以選擇自訂規則集。
quality.tool.phpcs.installed.paths=已安裝的標準路徑
quality.tool.phpcs.label.path.to.ruleset=規則集路徑:
quality.tool.phpcs.required.phpcs.version=所需的 PHP_CodeSniffer 版本為 1.5.0 或更高，找到的是 {0}
quality.tool.selected.file.is.not.phpcbf=所選檔案不是 phpcbf 可執行檔案
quality.tool.stardards.has.been.updated=已安裝的規則集列表已更新。
quality.tools.0.added.to.ignored.files.list={0}已新增到忽略的檔案列表。
quality.tools.custom.coding.standard=自訂編碼標準
quality.tools.label.by.default.project.interpreter=預設為專案解釋器
quality.tools.provider.tooltip=此檔案被排除在外部品質工具分析和格式設定外。您可以從忽略的檔案列表中移除該檔案。
quick.fix.delete=刪除 ''{0}''
quick.fix.error=快速修復錯誤
quickfix.access.static.via.class.reference=取代為 ''{0}''
quickfix.add.to.use=新增到閉包 'use' 建構
quickfix.can.not.find.class.reference.name=無法按名稱尋找類別
quickfix.can.not.find.dynamic.method.reference=找不到動態方法參照
quickfix.can.not.find.static.method.reference=找不到 static 方法參照
quickfix.cannot.find.class.reference=找不到要解析的類別參照
quickfix.cannot.find.target.class=無法從參照 ''{0}'' 解析類別
quickfix.case.sensitive.name=更改 {0} 的大小寫以符合其宣告
quickfix.change.field.type.add.inferred.type.error.non.project=無法修改非專案檔案 ''{0}''
quickfix.change.field.type.add.inferred.type.error.read.only=無法修改唯讀檔案 ''{0}''
quickfix.change.field.type.add.inferred.type.family.name=作為屬性的類型新增推斷的類型
quickfix.change.field.type.add.inferred.type.name=作為屬性的類型新增 ''{0}''
quickfix.change.field.type.to.match.super=更改類型以符合父項
quickfix.change.field.type.to.match.super.0=將類型更改為 ''{0}'' 以匹配父項
quickfix.change.field.type.to.match.super.remove=移除類型宣告以符合父項
quickfix.change.type=更改為 ''{0}''
quickfix.change.type.declaration.family=更改類型
quickfix.convert.arrayfill.to.loop=將 'array_fill()' 呼叫轉換為迴圈
quickfix.convert.arrayfilter.to.loop=將 'array_filter()' 呼叫轉換為迴圈
quickfix.convert.arraymap.to.loop=將 'array_map()' 呼叫轉換為迴圈
quickfix.convert.loop.to.arrayfilll=將迴圈轉換為 'array_fill()' 呼叫
quickfix.convert.loop.to.arrayfilter=將迴圈轉換為 'array_filter()' 呼叫
quickfix.convert.loop.to.arraymap=將迴圈轉換為 'array_map()' 呼叫
quickfix.convert.to.new.style.constructor=將建構函式轉換為新樣式
quickfix.create.class=建立類別
quickfix.create.field.from.callback.invalid.element=無法從回調提取屬性名稱
quickfix.create.field.from.callback.name=從回調建立屬性
quickfix.create.field.from.callback.unresolved.class.ref=無法從回調建立屬性。無法解析目標類別參照。
quickfix.create.function.from.callback.family.name=從回調建立函式
quickfix.create.function.from.callback.name=新增函式
quickfix.create.method.from.callback.name=從回調建立方法
quickfix.create.parameter=建立參數
quickfix.delete.return.argument=刪除返回實參
quickfix.disable.inspection.for.global.namespace=為全域命名空間停用檢查
quickfix.failed.to.create.class=無法建立類別 ''{0}''
quickfix.import.base.no.candidates=找不到要匯入的候選項
quickfix.import.class.name=匯入類別
quickfix.import.class.popup.title=要匯入的類別
quickfix.import.constant.name=匯入常數
quickfix.import.constant.popup.title=要匯入的常數
quickfix.import.function.name=匯入函式
quickfix.import.function.popup.title=要匯入的函式
quickfix.is.not.available.in.dump.mode=在索引更新期間，''{0}'' 快速修復不可用
quickfix.make.call.static.name=將呼叫設為 static
quickfix.make.method.static=設為 'static'
quickfix.move.class.to.corresponding.directory=移至目錄 ''{0}''
quickfix.move.class.to.corresponding.directory.error.file.exists=檔案 {0} 已存在
quickfix.move.class.to.corresponding.directory.error.unable.create.directories=無法建立缺少的目錄: ''{0}''
quickfix.move.class.to.corresponding.directory.error.unable.move.file=無法將檔案移至目錄 ''{0}''
quickfix.multiple.target.class.resolve=類別 ''{0}'' 有多個宣告
quickfix.navigate.to.duplicate.array.key=導覽到重複鍵
quickfix.navigate.to.duplicate.case.value=導覽到重複的 case 值
quickfix.navigate.to.duplicate.condition=導覽到重複條件
quickfix.non.strict.object.equality=非嚴格物件相等比較
quickfix.overriding.method.visibility=移除可見性覆寫
quickfix.php.missing.param.type.batch.description=作為屬性類型新增推斷的類型
quickfix.php.missing.param.type.description=作為參數類型新增 ''{0}''
quickfix.phpdoc.update.field.type=將屬性類型更改為 ''{0}'' 以匹配 PHPDoc 註釋
quickfix.phpdoc.update.type=更新 PHPDoc 類型
quickfix.phpunit.assert.equals.flip.compared.arguments=翻轉比較實參
quickfix.phpunit.create.target.class.error.filename.exists=存在檔案 {0}
quickfix.phpunit.drop.redundant.optional.parameters=刪除冗餘的可選參數
quickfix.phpunit.replace.current.method.with.alternative=取代為 ''{0}''
quickfix.remove.condition.from.default.arm=從 'default' arm 中移除非 'default' 條件
quickfix.remove.default.arm=移除重複的 'default' match arm
quickfix.remove.duplicate.condition=移除重複條件
quickfix.remove.match.arm=移除 'match' arm
quickfix.remove.phpdoc=移除冗餘 PHPDoc 註釋
quickfix.remove.phpdoc.param.tag=移除 @param 標記
quickfix.remove.phpdoc.return.tag=移除 @return 標記
quickfix.remove.phpdoc.signature.tags=移除不必要的 @param 和 @return 標記
quickfix.remove.redundant.phpdoc.tags=移除所有冗餘的 PHPDoc 標記
quickfix.remove.type=移除類型 ''{0}''
quickfix.remove.unnecessary.qualifier=移除不必要的限定符
quickfix.remove.unnecessary.qualifier.on.class.name=簡化 FQN
quickfix.remove.unused.condition=移除未使用的條件
quickfix.replace.assignment.operator.with.prefix.expression.family.name=將賦值運算符取代為前綴表達式
quickfix.replace.assignment.with.operator.assignment.family.name=將賦值取代為運算符賦值
quickfix.replace.assignment.with.operator.assignment.name=將 ''='' 取代為 ''{0}=''
quickfix.replace.assignment.with.prefix.expression.family.name=將賦值取代為前綴表達式
quickfix.replace.curly.braces.with.brackets=將大括號取代為中括號
quickfix.replace.nested.ternary.expression=將三元表達式取代為 {0} 關聯版本
quickfix.replace.one.operator.with.another=將 ''{0}'' 取代為 ''{1}''
quickfix.set.inheritance.between.classes=使{0} {1} {2}
quickfix.strict.type.checking.change.parameter.type.family=更改參數類型
quickfix.strict.type.checking.change.parameter.type.name=將{0, choice, 1#第 1 個|2#第 2 個|3#第 3 個|4#第 {0,number} 個}參數的類型從 ''{1}'' 更改為 ''{2}''
quickfix.strict.type.checking.change.return.type.family=更改返回值類型
quickfix.strict.type.checking.change.return.type.name=將返回值類型從 ''{0}'' 更改為 ''{1}''
quickfix.strict.type.checking.extend.return.type.family=擴展返回值類型
quickfix.strict.type.checking.extend.return.type.name=將返回值類型從 ''{0}'' 擴展為 ''{1}''
quickfix.undefined.function.add.function=新增函式
radio.button.by.concatenation=通過串聯(&C)
radio.button.by.embeding=通過嵌入(&E)
radio.button.class.constructor=類別建構函式(&S)
radio.button.const=const(&C)
radio.button.copy.from.base.class=從基類別複製(&P)
radio.button.current.method=當前方法(&T)
radio.button.default=預設(&F)
radio.button.default.empty.template=預設/空模板(&E)
radio.button.define=定義(&D)
radio.button.field.declaration=屬性宣告(&D)
radio.button.private=private(&I)
radio.button.protected=protected(&O)
radio.button.public=public(&U)
radio.button.setup=設定(&U)
radio.button.with.inheritdoc.tag=帶有 @inheritDoc 標記(&I)
radio.for.all.properties=適用於所有方法
radio.only.for.properties.without.declared.type=適用於沒有宣告類型的方法
reading.and.writing.creates.files.if.not.exists.fails.otherwise=讀/寫。如果檔案不存在則建立檔案，如果找到檔案則失敗。
reading.and.writing.start.at.the.beginning.of.the.file=讀/寫。從檔案開頭開始。
reading.and.writing.start.at.the.beginning.of.the.file.and.truncate.the.file.to.zero.length.creates.files.if.not.exists=讀/寫。從檔案開頭開始，將其截斷為零長度。如果檔案不存在則建立檔案。
reading.and.writing.start.at.the.the.end.of.the.file.creates.files.if.not.exists=讀/寫。從檔案末尾開始。如果檔案不存在則建立檔案。
reading.and.writing.starts.at.the.beginning.of.the.file.creates.files.if.not.exists=讀/寫。從檔案開頭開始。如果檔案不存在則建立檔案。
reading.only.start.at.the.beginning.of.the.file=唯讀。從檔案開頭開始。
readonly.property.cannot.have.default.value='readonly' 屬性不能具有預設值
readonly.property.must.have.type='readonly' 屬性必須指定類型
recursive.call=遞迴呼叫
redefinition.of.parameters.is.not.allowed=不允許參數重新定義
refactoring.common.fail.to.extract.expression=無法從所選程式碼段中提取表達式
refactoring.common.not.extractable.expression=不支持此類別表達式
refactoring.common.not.supported.context=當前上下文不支持{0}
refactoring.common.not.supported.expression.in.scope=當前作用域不支持此類別表達式的{0}
refactoring.common.ui.target.directory.edit = 按 F2 編輯目標目錄
refactoring.common.ui.target.directory.label=目標目錄(&D):
refactoring.common.ui.target.namespace.label=命名空間(&N):
refactoring.common.validation.class.psi=無法執行重構: 目標類別“{0}”無效
refactoring.common.validation.namespace.name=“{0}”不是有效的命名空間名稱
refactoring.common.validation.target.directory.is.not.valid=目錄“{0}”的路徑無效
refactoring.common.validation.target.directory.not.inside.project=目錄“{0}”不在專案內部
refactoring.copy.class.name=複製類別
refactoring.extract.base.dialog.replace.all.occurrences=取代所有符合項(找到 {0} 個匹配項)(&A)
refactoring.extract.base.handler.no.expression.selected=選擇不構成正確的表達式
refactoring.extract.base.handler.not.supported.expression=此類別表達式不支持{0}
refactoring.extract.base.handler.not.supported.scope=當前作用域不支持{0}
refactoring.extract.base.validator.not.valid.identifier=“{0}”不是有效的 PHP 關鍵字。
refactoring.extract.base.validator.reserved.keyword=“{0}”是保留的 PHP 關鍵字。
refactoring.extract.class.conflicts.extract.class.refactoring.is.not.supported.for.dynamically.declared.properties.usages=動態宣告屬性用法不支持“提取類別”重構
refactoring.extract.class.conflicts.method.0.depends.on.1.constant.2=方法“{0}”依賴於 {1} 常數“{2}”
refactoring.extract.class.conflicts.method.0.depends.on.1.method.2=方法“{0}”依賴於 {1} 方法“{2}”
refactoring.extract.class.conflicts.method.0.depends.on.property.1.which.needs.getters.in.2=方法“{0}”依賴於屬性 "\${1}"，需要“{2}”中的 getter
refactoring.extract.class.conflicts.method.0.depends.on.property.1.which.needs.setters.in.2=方法“{0}”依賴於屬性 "\${1}"，需要“{2}”中的 setter
refactoring.extract.class.conflicts.unable.to.add.delegate.property.initialization.to.constructor=無法將委託的屬性初始化新增到類別建構函式
refactoring.extract.class.conflicts.unable.to.add.delegate.property.initialization.to.constructor.trait.constructor.will.be.overridden=無法將委託的屬性初始化新增到類別建構函式: 特徵建構函式將被覆寫
refactoring.extract.class.conflicts.using.write.access.for.non.public.properties.in.array.destructuring.expressions.is.not.supported.in.extract.class.refactoring=“提取類別”重構不支持將寫入權限用於陣列解構表達式中的非 public 屬性
refactoring.extract.class.conflicts.using.write.access.for.non.public.properties.in.multiple.assignment.expressions.in.extract.class.refactoring=“提取類別”重構不支持將寫入權限用於多個賦值表達式中的非 public 屬性
refactoring.extract.class.dialog.class=類別名:
refactoring.extract.class.dialog.generate.accessors=生成存取器(&G)
refactoring.extract.class.dialog.members.to.be.extracted=要提取的成員
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.abstract.methods=抽象方法不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.anonymous.classes=匿名類別不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.anonymous.functions=匿名函式不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.doc.methods=通過 PHPDoc 定義的魔術方法不支持 Extract Class 重構
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.doc.properties=通過 PHPDoc 定義的魔術屬性不支持 Extract Class 重構
refactoring.extract.class.error.failed.to.create.file=無法建立檔案
refactoring.extract.class.error.the.selected.function.should.belong.to.project.sources=所選函式必須屬於專案源
refactoring.extract.class.extract.to.class=提取到類別
refactoring.extract.class.extracting.from.class=正在從類別提取:
refactoring.extract.class.extracting.from.file=正在從檔案提取:
refactoring.extract.constant.conflict.already.exists=作用域中已經存在名稱為“{0}”的常數。
refactoring.extract.constant.conflict.cannot.override.interface.constant=無法覆寫接口“{1}”的常數“{0}”
refactoring.extract.constant.conflict.exists.in.subclass=“{0}::{1}”將被此常數覆寫
refactoring.extract.constant.conflict.exists.in.subclass.with.weaker.access=“{0}”的存取級別必須為“{1}”(如在類別“{2}”中)或更弱
refactoring.extract.constant.name=提取常數
refactoring.extract.constant.unable.to.add.constant.declaration="無法新增常數宣告"
refactoring.extract.field.conflict.already.exists=該類中已經存在名稱為“{0}”的屬性。
refactoring.extract.field.name=提取屬性
refactoring.extract.field.validator.reserved.field.name=“{0}”是保留的屬性名稱
refactoring.extract.field.visibility=可見性
refactoring.extract.field.visibility.private=private(&I)
refactoring.extract.field.visibility.protected=protected(&O)
refactoring.extract.field.visibility.public=public(&U)
refactoring.extract.interface.fail.to.create.file=無法建立檔案 ''{0}''。
refactoring.extract.interface.field=接口名稱(&I):
refactoring.extract.interface.invalid.caret.location=文字游標應置於要重構的類別名處。
refactoring.extract.interface.invalide.extract.from.trait=無法從特徵提取接口。
refactoring.extract.interface.members.title=要構成接口的成員(&B)
refactoring.extract.interface.name=提取接口
refactoring.extract.interface.no.methods=沒有要提取到接口的方法。
refactoring.extract.interface.phpdoc.copy=複製(&C)
refactoring.extract.interface.phpdoc.do.nothing=保留原樣(&A)
refactoring.extract.interface.phpdoc.move=移動(&M)
refactoring.extract.interface.phpdoc.title=PhpDoc
refactoring.extract.interface.title=從類別 ''{0}'' 提取接口
refactoring.extract.interface.validation.members.modifier=對於每個提取的方法，修飾符將更改為 public。
refactoring.extract.method.error.a.set.of.statements.should.be.from.the.same.code.block=一組語句應來自同一程式碼塊。
refactoring.extract.method.error.inconsistent.return.points.in.selected.code.fragment=所選程式碼段中的返回點不一致。
refactoring.extract.method.error.selected.block.should.represent.a.set.of.statement.or.an.expression=所選塊應代表一組語句或表達式。
refactoring.extract.method.error.there.are.break.continue.operators.which.can.interrupt.execution=存在會中斷執行的 break/continue 運算符。
refactoring.extract.method.from.duplicate.code=從重複的程式碼中提取方法
refactoring.extract.method.name=提取函式/方法
refactoring.extract.method.tooltip=輸入 $name = 'init'
refactoring.extract.parameter.name=提取參數
refactoring.extract.replace.class.reference=盡可能將類別參照取代為接口(&F)
refactoring.extract.variable.conflict.already.exists=作用域中已經存在名稱為“{0}”的變數。
refactoring.extract.variable.name=提取變數
refactoring.inline.cannot.find.variable.to.inline=找不到要內聯的變數
refactoring.inline.constant.all.references.and.keep=全部內聯並保留常數
refactoring.inline.constant.all.references.and.remove=全部內聯並移除常數
refactoring.inline.constant.cannot.extract.value=無法提取常數的值
refactoring.inline.constant.command=內聯常數
refactoring.inline.constant.is.never.used=常數 {0} 從未使用
refactoring.inline.constant.multiple.declarations=還有其他具有相同名稱的常數宣告。
refactoring.inline.constant.name=內聯常數
refactoring.inline.constant.this.reference.only=僅內聯此參照並保留常數
refactoring.inline.function.all.invocations.and.remove.the.method=全部內聯並移除{0}(&A)
refactoring.inline.function.all.invocations.keep.the.method=全部內聯並保留{0}(&E)
refactoring.inline.function.cannot.find.function.declaration=找不到函式宣告
refactoring.inline.function.cannot.inline.constructor=無法內聯建構函式
refactoring.inline.function.cannot.inline.first.class.callable.declaration=無法內聯一級可調用宣告
refactoring.inline.function.cannot.inline.function.with.global.usage=無法內聯{0}和 <code>global</code> 用法
refactoring.inline.function.cannot.inline.library.function=無法內聯庫函數
refactoring.inline.function.cannot.inline.magic.method=無法內聯魔術方法
refactoring.inline.function.cannot.inline.overridden.method=無法內聯被覆寫的方法
refactoring.inline.function.cannot.parse.function.body=無法解析函式體
refactoring.inline.function.command=正在內聯{0}
refactoring.inline.function.inline.function.refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow=當 return 語句中斷執行流程時，不支持內聯函式重構
refactoring.inline.function.not.accessible.from.caller.site=無法從呼叫者站點存取成員參照 <code>{0}</code>
refactoring.inline.function.only.static.method.is.supported=僅支援 static 方法
refactoring.inline.function.parent.reference.unresolved=<code>parent</code> 類別參照在 {0} 中未解析
refactoring.inline.function.reference.is.recursive=不支持遞迴呼叫
refactoring.inline.function.this.invocation.only.and.keep.the.method=僅內聯此呼叫並保留{0}(&K)
refactoring.inline.function.title=內聯{0}重構
refactoring.inline.function.yield.found.in.function.body=在函式體中找到 <code>yield</code> 用法
refactoring.inline.variable.cannot.extract.value=無法提取變數 ''\${0}'' 的值
refactoring.inline.variable.no.occurrences=沒有符合項可以被安全地內聯
refactoring.inline.variable.unary.operation=無法內聯到遞減或遞增運算
refactoring.inplace.extract.method.name=就地提取函式/方法
refactoring.make.method.static=將方法設為 static
refactoring.make.method.static.add.parameters.for.fields=新增屬性參數(&P):
refactoring.make.method.static.doc.method.is.not.supported=不支持文檔方法
refactoring.make.method.static.dynamic.method.call.found=實例物件應作為參數傳遞，找到動態方法呼叫: {0}
refactoring.make.method.static.magic.method=魔術方法不能設為 static
refactoring.make.method.static.method.calls.found.in.static.context=在 static 上下文中找到方法呼叫
refactoring.make.method.static.method.converts.method.to.static=將方法轉換為 static
refactoring.make.method.static.method.is.overridden=方法 {0} 被覆寫
refactoring.make.method.static.object.is.needed=方法 {0} 使用未作為參數傳遞的屬性 {1}
refactoring.make.method.static.private.field.is.not.accessible=private 屬性 {0} 無法從類別外部存取
refactoring.make.method.static.protected.field.is.not.accessible=protected 屬性 {0} 無法從類別及其繼承者外部存取
refactoring.make.method.static.references.to.be.changed=待更改參照 {0}
refactoring.make.method.static.this.found=實例物件應作為參數傳遞，找到 $this
refactoring.make.method.static.writeAccess=檢測到 {0} 寫入存取，實例物件應作為參數傳遞。
refactoring.make.static.then.move.method.message=方法 ''{0}'' 將被設為 ''public static''
refactoring.make.static.then.move.method.select=將方法 ''{0}'' 移至類別
refactoring.move.class.action.name = 移動類別…
refactoring.move.class.cannot.move.anonymous.class=無法移動匿名類別
refactoring.move.class.in.non.code.message=註釋和字串中的類別參照
refactoring.move.class.name = 移動類別
refactoring.move.class.new.file = 將類別提取到單獨的檔案(&E)
refactoring.move.class.title = 將類別 {0} 移至命名空間(&C):
refactoring.move.classes.dnd.files.with.the.same.name.error=單個目標中不允許有多個同名檔案。
refactoring.move.classes.dnd.name=移動類別
refactoring.move.classes.dnd.title=將所選{0,choice,0#類別|1#命名空間|2#類別和命名空間}移至命名空間:
refactoring.move.constant.action.name=移動常數…
refactoring.move.constant.class.already.contains.constant=類別 {0} 已包含常數 {1}
refactoring.move.constant.class.already.contains.method=類別 {0} 已包含方法 {1}
refactoring.move.constant.label.text.field=將常數 {0} 移至類別(&C)
refactoring.move.constant.title=移動常數
refactoring.move.constant.unable.to.resolve=無法解析 {0}
refactoring.move.function.action.name=移動函式…
refactoring.move.function.interface.cant.contain.method=接口中不允許帶有主體的方法
refactoring.move.function.label.text.field=將函式 {0} 移至類別(&C)
refactoring.move.function.title=移動函式
refactoring.move.instance.method=移動實例方法
refactoring.move.instance.method.action.name=移動實例方法…
refactoring.move.instance.method.preview.header=要移至另一個類別的方法
refactoring.move.instance.method.this.parameter.label=將取代類別 {0} 的 $this 參照的參數名稱
refactoring.move.instance.method.usage.will.not.be.accessible=用法 {0} 將無法存取。應提高方法可見性
refactoring.move.member.action.name=移動成員…
refactoring.move.member.method.is.overridden.in.a.sublclass={0} 在子類別 {1} 中被覆寫
refactoring.move.member.title=移動 static 成員
refactoring.move.members.0.will.be.hidden.in.1=成員 {0} 將在 {1} 中被隱藏
refactoring.move.members.cannot.find.target.class=找不到類別 {0}
refactoring.move.members.class.0.does.not.exist=類別 {0} 不存在。\\n\\
是否要建立?
refactoring.move.members.enum.0.already.contains.case.with.name.0=枚舉 {0} 已經包含名稱為 ''{1}'' 的 case
refactoring.move.members.enum.0.already.contains.case.with.value.1=枚舉 {0} 已經包含值為 ''{1}'' 的 case
refactoring.move.members.is.not.a.valid.class.name=“{0}”不是有效的類別名
refactoring.move.members.is.not.accessible={0} 在 {1} 中無法存取
refactoring.move.members.late.static.binding.detected=檢測到延遲 static 綁定: {0}
refactoring.move.members.late.static.binding.detected.in.doc=在文檔中檢測到延遲 static 綁定
refactoring.move.members.member.will.change.visibility.to.public=成員 {0} 會將可見性更改為 public
refactoring.move.members.method.implements.abstract.method={0} 在 {1} 中實作 abstract 方法
refactoring.move.members.method.implements.method.in={0} 在 {1} 中實作方法
refactoring.move.members.move.as.enum.cases=作為枚舉 case 移動
refactoring.move.members.no.members.are.selected=未選擇成員
refactoring.move.members.only.constants.can.be.moved.to.interface = 只有常數可以移至接口
refactoring.move.members.preview.header=要移至另一個類別的成員
refactoring.move.members.properties.can.not.be.moved.to.enum=屬性不能移動到枚舉
refactoring.move.members.self.from.anonymous.class=無法處理對匿名類別的自參照
refactoring.move.members.there.are.several.classes.with.specified.name=存在多個具有指定名稱 {0} 的類別
refactoring.move.members.to.be.moved=要移至另一個類別的成員(&B)
refactoring.move.members.unable.to.resolve.usage.callback.found=無法解析用法: 發現回調: {0}
refactoring.move.members.unable.to.resolve.usage.late.static.binding.detected=無法解析用法: 檢測到延遲 static 綁定: {0}
refactoring.move.method.cannot.move.constructor=無法移動建構函式
refactoring.move.method.cannot.move.magic.method=無法移動魔術方法
refactoring.move.method.label.text.field=將成員移至類別(&C)
refactoring.move.multiple.constant.label.text.field=將 {0} 個常數移至類別(&C)
refactoring.move.multiple.functions.label.text.field=將 {0} 個函式移至類別(&C)
refactoring.move.namespace.action.name=移動命名空間…
refactoring.move.namespace.header.message=移動命名空間
refactoring.move.namespace.in.non.code.message=註釋和字串中的命名空間參照
refactoring.move.namespace.message=要移動的命名空間
refactoring.move.namespace.name=移動命名空間
refactoring.move.namespace.new.namespace=新命名空間名稱(&N):
refactoring.move.namespace.title=移動命名空間 {0}
refactoring.move.related.namespace.collect.title=收集子命名空間
refactoring.move.related.namespace.description=將具有相關命名空間的檔案移至新目錄:
refactoring.move.related.namespace.directory.column=新增目錄
refactoring.move.related.namespace.name.column=新命名空間名稱
refactoring.move.related.namespace.title=移動具有相關命名空間的檔案
refactoring.parameter.reserved.name = 參數名稱“{0}”已保留
refactoring.parameter.validation = 參數 {0} 無效
refactoring.parameter.validation.default.value=預設值表達式 ''{0}'' 無效
refactoring.parameter.validation.duplicate.parameter=重複的參數名稱: {0}
refactoring.parameter.validation.initializer=初始設定式 ''{0}'' 無效
refactoring.parameter.validation.initializer.last=必選參數不能位於可選參數後
refactoring.parameter.validation.initializer.type=具有類別類型提示的參數的預設值只能為 NULL
refactoring.parameter.validation.name.collision.with.use.list=參數名稱 ''{0}'' 無效。''{0}'' 已匯入 use 列表
refactoring.parameter.validation.no.default.value=應該為參數 ''{0}'' 提供初始設定式或預設值
refactoring.parameter.validation.pass.by.reference=僅變數可通過參照傳遞
refactoring.parameter.validation.type=參數類型 ''{0}'' 無效
refactoring.parameter.validation.variadic.can.have.default.value=可變形參不能具有預設值
refactoring.parameter.validation.variadic.last=只有最後一個參數可以是可變形參
refactoring.php.cannot.create.class=無法在預覽中建立新類別
refactoring.php.create.class=建立新類別
refactoring.php.extract.enum=提取枚舉
refactoring.pull.up.abstract.method = 類別 {0} 將被標記為 abstract
refactoring.pull.up.class.does.not.have.base.classes.interfaces.in.project.files={0}在專案檔案中沒有基類別/接口
refactoring.pull.up.conflict.duplicate.constant = {0} 將與 {1} 中的常數衝突。
refactoring.pull.up.implement.method = 在實作接口的類別中建立方法存根(&S)
refactoring.pull.up.is.1.and.will.not.be.accessible.in.the.target.class={0} 為 private，在目標類別中將無法存取。
refactoring.pull.up.may.not.be.accessible.in.the.target.class={0} 在目標類別中可能無法存取。
refactoring.pull.up.private.access = {0} 存取權限將更改為 {1}
refactoring.pull.up.static.reference.is.not.accessible.in.the.target.class=非 static 方法 {0} 不應在外部類中靜態呼叫
refactoring.pull.up.validation.field.into.interface = 無法將屬性拉入接口
refactoring.pull.up.validation.static.method.into.interface = {0} 為 static，不能為 abstract。
refactoring.pull.up.will.not.be.accessible.in.the.target.class={0} 在目標類別中將無法存取。
refactoring.push.down.method.implemented.in.interface={0} 必須被宣告為 abstract 或實作 {1}
refactoring.push.down.validation.magic.method=移動魔術方法會產生副作用
refactoring.rename.automatic.renamer.accessors.name=重新命名存取器(&C)
refactoring.rename.automatic.renamer.class.dialog.description=將具有以下名稱的類別重命名為:
refactoring.rename.automatic.renamer.class.dialog.title=重新命名類別
refactoring.rename.automatic.renamer.class.entity.name=類別
refactoring.rename.automatic.renamer.class.name=重新命名類別(&C)
refactoring.rename.automatic.renamer.field.accessors.dialog.description=將具有以下名稱的屬性存取器重命名為:
refactoring.rename.automatic.renamer.field.accessors.dialog.title=重新命名存取器
refactoring.rename.automatic.renamer.field.accessors.entity.name=存取器
refactoring.rename.entity.name.inheritor=繼承者/檔案
refactoring.rename.inheritors.and.related.files.with.the.following.names.to=將具有以下名稱的繼承者和相關檔案重命名為:
refactoring.rename.search.in.global.scope=在全域作用域中搜尋
refactoring.returnType.validation.type=返回值類型 ''{0}'' 無效
refactoring.validation.class.error.property.with.name.0.is.already.exists=已存在名稱為“{0}”的屬性
reference=參照
referenced.calls=參照的呼叫
reformats.file.with.0=使用 ''{0}'' 重新格式化檔案
register.ide=註冊 IDE
relationship.already.exists={0} 與 {1} 之間的關係已存在
release.name.eg.5.1.2.release=發佈名稱。例如，5.1.2-RELEASE
remote.connection.settings.default.remote.interpreter=預設遠端解釋器
remote.connection.settings.interpreter.is.not.remote=當前專案解釋器非遠端解釋器
remote.interpreter.browse.action.is.not.supported.for.docker=基於 Docker 的遠端解釋器不支持瀏覽動作
remote.interpreter.can.t.be.executed.please.enable.the.php.remote.interpreter.plugin=無法執行遠端解釋器。啟用 PHP Remote Interpreter 延伸模組。
remote.interpreter.path.mappings.validation.message=請檢查映射是否在 {0} 下正確組態。
remote.interpreter.path.mappings.validation.php.section=<b><i><a href="php_mappings">設定|PHP</a></i></b>
remote.interpreter.path.mappings.validation.title=沒有為所選解釋器組態路徑映射。
remove=移除
remove.assignment=移除賦值
remove.else=移除 else…
remove.from.function.0.declaration=從函式 ''{0}'' 宣告中移除 ''\\\\&''
remove.from.ignored.list=移除
remove.from.the.parameter.0=從參數 ''{0}'' 中移除 ''\\\\&''
remove.link.between.0.and.1=移除 {0} 與 {1} 之間的鏈接
remove.numeric.literals.separators=移除數字文字分隔符
remove.pass.by.ref=移除 '\\\\&'
remove.pass.by.ref.sign=移除 '\\\\&'
remove.redundant.initializer=移除冗餘的初始設定式
remove.redundant.suppression.quick.fix.family.name=移除 ''{0}'' 禁止
remove.relationship.link=移除關係鏈接
remove.rule=移除規則
remove.unnecessary.parentheses=移除不必要的圓括號
remove.unnecessary.reset=移除不必要的 'reset'
remove.unnecessary.semicolon=移除不必要的分號
remove.variable=移除變數
rename=重新命名
rename.constructor=重新命名建構函式
rename.filename.quick.fix=將檔案 ''{0}'' 重命名為 ''{1}''
rename.parameter.dialog.description=將層次結構中的參數重命名為:
rename.parameters.dialog.title=重新命名參數
rename.psi.element.quick.fix=將{0} ''{1}'' 重命名為 ''{2}''
replace.all.occurrences.with.php=將所有符合項取代為 '<?php'
replace.all.occurrences.with.php.echo=將所有符合項取代為 '<?php echo'
replace.all.occurrences.with.short.php.echo=將所有符合項取代為 '<?='
replace.all.occurrences.without.side.effects=取代所有無副作用的符合項
replace.deprecated.from.of.callable=取代已棄用的可呼叫物件形式
replace.extends.implements=取代 'extends'/'implements'
replace.if.clause.with.ternary.expression=將 if 子句取代為三元表達式
replace.if.with.switch=將 'if' 取代為 'switch'
replace.plus.asgn.to.concat.asgn.quick.fix.family.name=將 '+=' 取代為 '.='
replace.plus.to.concat.quick.fix.family.name=將 '+' 取代為 '.'
replace.qualifier.with.an.import=將限定符取代為匯入
replace.quotes=取代引號
replace.ternary.expression.with.if.clause=將三元表達式取代為 if 子句
replace.unnecessary.double.quotes=取代不必要的雙引號
replace.variable.assignment.with.named.argument=將變數賦值取代為命名實參
replace.with.0=取代為 {0}
replace.with.01=取代為 {0}
replace.with.absolute.reference=取代為絕對參照
replace.with.alias=取代為別名
replace.with.alias.from.target.scope=取代為目標作用域中的別名
replace.with.anonymous.function=取代為匿名函式
replace.with.array=取代為直接賦值 '$array = array($value)'
replace.with.array.short.syntax=取代為直接賦值 '$array = [$value]'
replace.with.arrow.function=取代為箭頭函式
replace.with.coalesce.operator=取代為合併運算符
replace.with.first.class.callable.family.name=取代為一級可調用語法
replace.with.pow.operator=取代為 '**' 運算符
replace.with.quest=取代為 '?'
require='必需'
required.parameters.missing=缺少所需參數 ''{0}''
required.trait.0.wasn.t.added.to.1=所需特徵 ''{0}'' 未新增到 ''{1}''
rerun.with.ignore.platform.reqs=使用 --ignore-platform-reqs 重新執行
return.type=返回值類型
return.type.declaration.is.not.allowed=不允許返回值類型宣告
return.type.declaration.must.be.compatible.with.super=返回值類型宣告必須與父級相容
returned.by.iterator.aggregate.should.be.traversable=\\\\IteratorAggregate::getIterator() 返回的物件必須為 Traversable 或實作接口 Iterator
rfc.2822.rfc.5322.formatted.date=RFC 2822/RFC 5322 格式的日期({0})
robo=Robo
robo.task.method=Robo 任務方法
run.install.update.with.platform.reqs=使用 --ignore-platform-reqs 執行安裝/更新(&R)
run.with.paratest=使用 ParaTest 執行
run.with.paratest.mnemonic=使用 ParaTest 執行 %s
searching.for.usages=正在搜尋用法…
seconds.since.the.unix.epoch.january.1.1970.00.00.00.gmt=自 Unix 時間戳 1970 年 1 月 1 日 00:00:00 GMT 以來的秒數({0})
seconds.with.leading.zeros=帶前導零的秒(00 到 59)
select.composer.phar.and.provide.the.full.path.to.it.or.select.download.composer.stable.phar.from.getcomposer.org=選擇 'composer.phar' 並提供其完整路徑，或者選擇“從 getcomposer.org 下載 composer-stable.phar”。
select.composer.phar.and.provide.the.full.path.to.it.or.select.download.composer.stable.phar.from.getcomposer.org1=選擇 'composer.phar' 並提供其完整路徑，或者選擇“從 getcomposer.org 下載 composer-stable.phar”。
server=伺服器
set=設定
set.close.on.exec.flag.on.the.opened.file.descriptor.only.available.in.php.compiled.on.posix.1.2008.conform.systems=在檔案檔案描述子上設定 close-on-exec 標誌。僅適用於符合 POSIX.1-2008 標準的系統。
set.the.following.option=設定以下選項:
settings.smart.keys.auto.insert.closing.html.tag.in.php.doc=在 PHPDoc 塊中自動插入 HTML 結束標記
settings.smart.keys.auto.insert.semicolon=在函式呼叫內部鍵入時自動插入分號 
settings.smart.keys.auto.insert.tag.after.typing=輸入 '<?' 後自動插入 '<?php' 標記
settings.smart.keys.enable.smart.function.parameters.completion=啟用智能函式參數補全
settings.smart.keys.escape.symbols.on.paste.in.string.literals=在字串文字中貼上時轉義符號
settings.smart.keys.find.usages.of.base.method.prompt=搜尋方法用法時顯示其他選項
settings.smart.keys.remove.php.open.close.tags.while.pasting.in.php.context=在 PHP 上下文中貼上時移除 PHP 開始/結束標記
settings.smart.keys.replace.unnecessary.double.quotes.on.paste=貼上時取代不必要的雙引號
settings.smart.keys.select.variable.name.without.dollar.sign.on.double.click=在雙擊時選擇不帶 '$' 符號的變數名
settings.smart.keys.title=PHP
short.arrow.function.cannot.return.void=箭頭函式不能有 'void' 返回值類型
show.0.settings.window=顯示 ''{0}'' 設定視窗
show.composer.settings.action.name=顯示 Composer 設定
show.constants=顯示常數
show.implementations.for.0={0} 的實作
show.includes=顯示 Include
show.log=顯示日誌
show.log.of.composer.related.actions=顯示 Composer 相關動作的日誌
show.name.for.all.arguments=顯示所有實參的名稱
show.private.members=顯示 private 成員
show.properties=顯示屬性
show.protected.members=顯示 protected 成員
show.settings=顯示設定
show.super.types.for.0=顯示 {0} 的父類型
show.validation.dialog=顯示“驗證偵錯器”對話框
shows.0.dialog=顯示 ''{0}'' 對話框
shows.dialog.with.methods.from.implemented.interface.selected.methods.will.be.inserted.into.the.class.after.dialog.confirmation=顯示包含已實作接口中方法的對話框。對話框確認後，所選方法將被插入到類別中。
shows.list.of.child.classes.with.inaccessible.methods=顯示具有不可存取方法的子類別列表
shows.list.of.child.classes.without.without.resolved.member=顯示沒有已解析成員的子類別列表
simulating.update=正在模擬更新
skip.constant.params=跳過使用常數參數的呼叫
smarty=Smarty
smarty.configurable.title=Smarty
sort.by.visibility=按可見性排序
sort.the.elements.by.visibility.public.protected.private=按可見性對元素排序: public、protected、private
split.elseif=拆分 'elseif'
split.selected.group.use.statement=拆分所選 'use' 語句組
spread.operator.on.named.arguments.is.forbidden=禁止對命名實參使用展開運算符
spread.operators.in.arrays.are.not.supported.for.multiassignments.variables=多賦值變數不支持在陣列中使用展開運算符
squash.repetitive.underscores=壓縮重複下劃線
static.is.not.allowed.in.compile.time.constants=編譯時常量中不允許使用 'static::'
static.is.not.allowed.in.parameter.type.declaration=參數類型宣告中不允許 'static'
static.modifier.is.not.allowed.here=此處不允許使用 'Static' 修飾符
static.property.cannot.be.readonly='static' 屬性不能為 'readonly'
static.property.cannot.be.unset=static 屬性不能取消設定
static.value=static 值
status.text.no.dependencies=無相依項
strict.type.declaration.is.available.in.php.7.only=從 PHP 7.0 起才允許使用嚴格類型宣告
strict.types.declaration.must.have.0.or.1.as.its.value='strict_types' 宣告的值必須為 0 或 1
summary=摘要
suppress.all.for.file=對檔案全部禁止
suppress.for.field=對欄位禁止
suppress.for.file=對檔案禁止
suppress.for.function=對函式禁止
suppress.for.method=對方法禁止
suppress.for.phpdoc.comment=對 PhpDoc 註釋禁止
suppress.if.annotated.by.tag=如果用 ''{0}'' 註解，則禁止
suppress.unused.preview=對使用 ''{0}'' 註解的實體禁止“未使用的宣告”檢查
suppressed.annotation.title=已禁止的註解
surround.with.0=使用 ''{0}'' 包圍
surround.with.if.0.1=使用 ''if({0}({1}))'{'...'}''' 包圍
swatch.internet.time=Swatch 互聯網時間(000 到 999)
switch.statements.may.only.contain.one.default.clause.in.php.7=在 PHP 7 中，switch 語句只能包含一個 'default' 子句
switch.with.common.parts=包含通用部分的 'switch'
switching.from.another.vs.code.sublime.text.or.another.ide.check.out.our.migration.guides.to.get.started.faster=從 VS Code、Sublime Text 或其他 IDE 切換而來? 請檢視我們的遷移指南以更快地開始使用。
target=目標
target.class=目標類別:
target.directory.for.validation.script.is.not.public=驗證腳本的目標目錄不是 public。
target.trait.should.be.specified=應指定目標特徵
template.debug.cache.dir.is.incorrect=模板偵錯: 在設定中指定的快取目錄路徑無效
template.debug.cache.dir.is.not.specified=模板偵錯: 未在設定中指定快取目錄路徑
template.debug.cache.path=快取路徑:
template.debug.path.to.output.folder=快取目錄路徑
template.debug.path.to.output.folder.descr=指定快取目錄路徑
template.debug.php.file.not.found=模板偵錯: 未找到 {0} 的相應 PHP 檔案
template.parameter=模板參數
template.smart.completion.function.parameters.description=智能函式參數補全
terminal.add.interpreter.to.path=將預設專案 PHP 解釋器新增到 {0}
ternary.condition.can.be.replaced.with.condition.expression=表達式可以安全地取代為 ''{0}''
test.not.tests.was.executed.title=未組態 {0}。按 ''修正'' 安裝 composer 軟體套件。
text.plain=文本/純
the.button.shows.whether.inspection.is.on.or.off=該按鈕顯示檢查是開啟還是關閉
the.day.of.the.year.starting.from.0=一年中的第幾天(0 至 365)
the.original.class.0.does.not.belong.to.the.project.and.cannot.be.modified=原始類別 {0} 不屬於該專案\\n\\
並且無法修改。
the.remote.hosts.access.plugin.is.missing.please.enable.the.plugin.in.0.plugins=缺少 ''FTP/SFTP/WebDAV Connectivity'' 和 ''Terminal'' 延伸模組中的一個或兩個。請在“{0} | 延伸模組”中啟用延伸模組。
the.result.of.validation.will.be.fetched.by.http.request=驗證結果將通過 http 請求提取。
the.same.as.p.but.returns.z.instead.of.00.00.available.as.of.php.8.0=與 P 相同，但返回 Z 而不是 +00:00，從 PHP 8.0 起可用(+02:00)
the.use.keyword.must.be.declared.in.the.outermost.scope.of.a.file.the.global.scope.or.inside.namespace.declarations=必須在檔案的最外側作用域(全域作用域)或命名空間宣告內部宣告 'use' 關鍵字
the.yield.expression.can.only.be.used.inside.a.function='yield' 表達式只能在函式中使用
there.are.errors.on.attempt.to.load.debug.extension.e.g.version.incompatibility=嘗試載入偵錯擴展時出錯，例如版本不相容。
this.is.the.default.contains.all.modes.in.the.sequence.s.n.r.v.m=這是預設值。包含序列 "s n r v m" 中的所有模式
this.reassignment.is.not.allowed=不能重新分配 $this
this.will.remove.relationship.link.between.classes=這將移除類別之間的關係鏈接並修改類別 {0}。繼續?
timezone.abbreviation.if.known.otherwise.the.gmt.offset=時區縮寫(如果已知)，否則為 GMT 偏移量(EST、MDT、+05)
timezone.identifier=時區關鍵字(UTC、GMT、大西洋/亞速爾群島)
timezone.offset.in.seconds=以秒為單位的時區偏移量(-43200 到 50400)
tooltip.configured.php.language.level.widget=已組態的 PHP 語言級別
tooltip.configured.php.language.level.widget.composer=通過 Composer 組態的 PHP 語言級別
tooltip.defaults.to.project.folder=預設為專案目錄
tooltip.from=來自{0}:
tooltip.from.volumes=來自{0}卷:
tooltip.update=更新 {0}
tooltip.wsl2.mappings=WSL2 映射
trailing.comma.is.not.allowed=不允許尾隨逗號
trait.already.contains.method=特徵 {0} 已包含方法 {1}
trait.expected.class.found=應為特徵，發現類別
trait.method.0.will.not.be.applied.because.it.collides.with.1=由於與 ''{1}'' 衝突，因此不會套用特徵方法 ''{0}''
trait.use.rule.type.name=特徵 use 規則方法
transform=轉換
turn.off.external.formatter=關閉外部格式化程序
turn.off.inspection.tool=關閉 {0} 檢查
type=類型
type.0.cannot.be.part.of.an.intersection.type=類型 ''{0}'' 不能是交叉類型的一部分
type.0.is.redundant.as.it.is.more.restrictive.than.type.1=類型 ''{0}'' 冗餘，因為它比類型 ''{1}'' 更加嚴格
type.contains.both.true.and.false.bool.should.be.used.instead=類型同時包含 true 和 false，應改用布爾
type.primitive.false.null.hints.names.are.forbidden=從 PHP 8.0 起才允許使用名為 'false' 和 'null' 的類型提示
type.primitive.true.hints.names.are.forbidden=從 PHP 8.2 起才允許使用名為 'true' 的類型提示
types.not.supported.as.operands.for.0.1.2=''{1} {0} {2}'' 中不受支援的動作數類型將導致 PHP 8 TypeError
uml.0.already.exists.in.class.1=類別 {1} 中已經存在 ''{0}''
uml.wrong.name=錯誤的名稱
undefined.interpreter=未定義的解釋器
unhandled.0=未處理的{0}
unhandled.exceptions=未處理的異常
union.types.and.the.nullable.type.notation.cannot.be.mixed=聯合類型和可為 null 類型表示法不能混合
union.types.mixed.cannot.be.nullable=混合類型不能為可 null，'null' 已是混合類型的一部分
unknown=未知
unknown.debugger.type=未知偵錯器類型
unknown.named.parameter=未知命名參數 ''{0}''
unnamed.variable=(未命名)
unnecessary.local.variable=不必要的區域變數
unsupported.declare.0=不支持的宣告 ''{0}''
untrusted.composer.dialog.text=正在安裝或更新相依項，或者執行 Composer 指令可能會執行潛在的惡意程式碼。\\n\\
\\n\\
如果不信任此源，請繼續使用安全模式。
unused.code.rules=未使用的程式碼規則
unwrap.dowhile=解包 do-while…
unwrap.else=解包 else…
unwrap.elseif=解包 elseif…
unwrap.for=解包 for…
unwrap.foreach=解包 foreach…
unwrap.if=解包 if…
unwrap.method=解包 ''{0}''
unwrap.switch=解包 switch…
unwrap.try=解包 try…
unwrap.while=解包 while…
update.php.doc.type.comment=取代為 ''{0}''
update.php.doc.type.family.name=更新 PHPDoc 類型
update.signature.to.match.phpdoc.comment=更新簽名以符合 PHPDoc 註釋
uppercase.ante.meridiem.and.post.meridiem.am.pm=大寫上午和下午(AM/PM)
url.to.validation.script='驗證腳本的 URL'
usage.in.extends.clause=etends 子句中的用法
usage.in.implements.clause=implements 子句中的用法
usage.in.import.statement=import 語句中的用法
usage.in.return.type=返回值類型中的用法
usage.in.type.hinting=類型提示中的用法
usage.of.intersection.types.grouping.is.allowed.only.as.part.of.union.type=交叉類型分組僅允許作為聯合類型的一部分使用
usages.show.this.self.references=顯示 $this/自參照
use.0.in.callables.is.deprecated=在可呼叫物件中使用 ''{0}'' 已棄用
using.this.when.not.in.object.context=不在物件上下文中時使用 '$this'
validated.web.server.is.not.running=驗證的 Web 伺服器未執行。
validating=正在驗證
validating1=正在驗證…
validation.0.extension.is.installed.check.configuration.options=已安裝 ''{0}'' 擴展。檢查組態選項。
validation.0.extension.is.not.installed=未安裝 ''{0}'' 擴展
validation.0.is.not.a.directory=''{0}'' 不是目錄
validation.0.not.found.at.1=在 ''{1}'' 中找不到 ''{0}''
validation.cannot.parse.value.of.0=無法解析 ''{0}'' 的值
validation.class.already.exists = {0}中已經存在具有相同名稱的類別
validation.class.cannot.be.overridden = 類別“{0}”不能被覆寫
validation.class.not.valid.name=“{0}”不是有效的類別名
validation.connection.was.not.established=未建立連線。
validation.connection.was.not.established.0=無法使用 ''{0}'' 啟動偵錯器會話
validation.connection.was.not.established.no.debug=未安裝偵錯擴展
validation.connection.was.not.established.update.info=更新解釋器資訊
validation.connection.was.not.established.validate.installation=驗證安裝
validation.debug.extension.is.updated=偵錯擴展設定已更新。請重新執行當前組態以使用新值。
validation.file.already.exists=檔案“{0}”已存在
validation.file.already.exists.in.dir=名稱為“{0}”的檔案已存在於“{1}”中
validation.file.not.valid.name=“{0}”不是有效的檔名
validation.function.already.exists = 當前命名空間中已定義具有相同名稱的函式
validation.interface.cannot.be.overridden = 無法實作接口“{0}”
validation.invalid.alias=“{0}”不是有效的別名
validation.invalid.identifier=“{0}”不是有效的關鍵字
validation.invalid.identifier.with.no.identifier=插入的關鍵字無效
validation.namespace.already.exists = {1}中已定義名稱為 ''{0}'' 的命名空間
validation.namespace.not.valid.name=“{0}”不是有效的命名空間名稱
validation.no.debug.extension.is.installed=未安裝偵錯擴展。
validation.press.fix.to.edit.project.configuration=按“修復”編輯您的專案組態。
validation.script.was.created.but.it.cannot.be.executed.check.possible.reasons=驗證腳本已建立，但無法執行。可能的原因:
validation.script.will.be.created.in.0.directory=驗證腳本將在 {0} 目錄中建立。
validation.script.will.be.created.in.0.directory.and.deployed.to.the.1.server=驗證腳本將在 {0} 目錄中建立並部署到 {1} 伺服器。
validation.script.will.be.created.locally.and.deployed.to.the.remote.server=驗證腳本將在本地建立並部署到遠端伺服器。
validation.script.will.be.created.locally.and.the.result.will.be.fetched.by.http.request=驗證腳本將在本地建立，其結果將通過 http 請求提取。
validation.ssh.remote.code.coverage.support={0} 擴展不支持通過 ssh 進行程式碼覆蓋
validation.ssh.remote.debug.support=''{0}'' 擴展不支持通過 ssh 進行遠端偵錯。
validation.test.no.test.patterns = 未新增任何模式
validation.value.is.invalid={0} 無效
validation.value.is.not.specified.or.invalid={0} 未指定或無效。
validation.value.is.not.specified.or.invalid.press.fix.project.configuration={0} 未指定或無效。按“修復”編輯您的專案組態。
validation.value.is.not.specified.press.fix.project.configuration={1} 組態中未指定 {0}。按“修復”以編輯 {1} 組態。
validation.value.path.to.value.is.invalid=無法通過 {1} 中提供的路徑找到 {0}
validation.value.path.to.value.is.invalid.press.fix.project.configuration=無法通過 {1} 中提供的路徑找到 {0}。按“修復”以編輯 {2} 組態。
validation.value.path.to.value.should.be.specified={0} 的路徑應在 {1} 中指定
validation.vendor.doesnt.exit=供應商目錄不存在
value=值
variable=變數
variable.always.have.value.0=到達時變數始終為 '{0,choice,0#false|1#true}'
variable.dereferenced=已取消參照變數
variable.naming.style.camel.case=駝峰式命名法
variable.naming.style.mixed=混合
variable.naming.style.panel=變數命名樣式
variable.naming.style.snake.case=snake_case
variable1=變數
variadic.parameter.cannot.have.a.default.value=可變形參不能具有預設值
version.information.varies.a.lot.between.operating.systems=版本資訊。不同作業系統之間差異很大
void.can.only.be.used.as.return.type=Void 只能用作返回值類型
void.type.cannot.be.nullable=void 類型不能是可為 null
waiting.for.3v4l.org.response=正在等待 3v4l.org 響應…
whether.it.s.a.leap.year.1.or.0=是否為閏年(1 或 0)
whether.or.not.the.date.is.in.daylight.saving.time.1.or.0=日期是否為夏令時(1 或 0)
while=while
with.data.set.0=使用資料集 {1} 的 {0}
working.directory.invalid=找不到工作目錄 ''{0}''
writing.only.creates.files.if.not.exists.fails.otherwise=只寫。如果檔案不存在則建立檔案，如果找到檔案則失敗。
writing.only.start.at.the.beginning.of.the.file.and.truncate.the.file.to.zero.length.creates.files.if.not.exists=只寫。從檔案開頭開始，將其截斷為零長度。如果檔案不存在則建立檔案。
writing.only.start.at.the.the.end.of.the.file.creates.files.if.not.exists=只寫。從檔案末尾開始。如果檔案不存在則建立檔案。
writing.only.starts.at.the.beginning.of.the.file.creates.files.if.not.exists=只寫。從檔案開頭開始。如果檔案不存在則建立檔案。
xdebug.cloud.cannot.connect=無法連線到 Xdebug Cloud
xdebug.cloud.cannot.connect.unknown.host=Xdebug Cloud 無法存取: {0}
xdebug.cloud.cannot.open.new.debug.connection=打不開新的偵錯連線
xdebug.cloud.cannot.register.cloud.id=無法在 Xdebug Cloud 上註冊 Cloud ID
xdebug.cloud.cannot.register.cloud.id.unexpected.response=由於意外響應，無法註冊 Cloud ID
xdebug.cloud.validation.cloud.id.not.defined=Cloud ID 未定義
xdebug.cloud.validation.host.not.defined=未定義本地部署 Xdebug Cloud 主機
xdebug.cloud.validation.port.invalid=本地部署 Xdebug Cloud 連接埠無效
xdebug.compile.task=編譯 Xdebug 擴展
xdebug.initializing.connection.debugger=偵錯器
xdebug.initializing.connection.failed.with.timeout=無法連線到 {0}: 超時
xdebug.initializing.connection.xdebug.cloud=Xdebug Cloud
xdebug.initializing.debugger.connection=正在連線到 {0}…
xdebug.validation.download.script.label=下載腳本指令:
xdebug.validation.ip.not.found=在自動檢測到的 IDE IP 中找不到 {0}
xdebug.validation.ip.not.found.descr=自動檢測的 IDE IP: {0}
you.are.configuring.debug.extension.in.the.wrong.php.ini.see.the.loaded.php.ini.files.below=您正在錯誤的 php.ini 中組態偵錯擴展(請參見下方已載入的 php.ini 檔案)。
you.can.always.add.a.precise.exclusion.via.alt.enter.and.then.edit.it.to.broaden.as.needed=您始終可以通過 Alt-Enter 組合鍵新增精確排除，然後根據需要對其進行編輯以擴大範圍。
you.did.not.reload.web.server.after.changes.in.php.ini.file=在 php.ini 檔案中進行更改後，未重新載入 Web 伺服器。
zend.debugger.settings.broadcasting.is.already.launched=Zend Debugger 設定廣播已啟動"
`;

exports[`src messages/SvnBundle.properties 1`] = `
"action.DumbAware.RepositoryBrowserDialog.text.branch.or.tag=分支或標記…
action.DumbAware.RepositoryBrowserDialog.text.move.or.rename=移動或重新命名(_M)…
action.DumbAware.SvnConfigureProxiesComponent.description.add=新增
action.DumbAware.SvnConfigureProxiesComponent.description.copy=複製
action.DumbAware.SvnConfigureProxiesComponent.text.add=新增
action.DumbAware.SvnConfigureProxiesComponent.text.copy=複製
action.EditCommitMessage.description=編輯修訂註釋。覆寫上一條訊息。
action.EditCommitMessage.text=編輯修訂註釋
action.IntegrateChangeSetAction.text=整合到分支
action.Subversion.BrowseSVNRepository.description=瀏覽 Subversion 版本庫
action.Subversion.BrowseSVNRepository.text=瀏覽 Subversion 版本庫(_W)…
action.Subversion.CleanupProject.description=對專案中的所有工作副本目錄執行清理
action.Subversion.CleanupProject.text=清理專案
action.Subversion.Clenaup.description=解鎖鎖定的目錄，並執行其餘所有未完成的動作
action.Subversion.Clenaup.text=清理(_E)
action.Subversion.CompareWithBranch.text=與分支比較…
action.Subversion.ConfigureBranches.text=組態分支…
action.Subversion.Copy.description=將選定的檔案或目錄複製到新的版本庫位置
action.Subversion.Copy.text=分支或標記(_B)…
action.Subversion.Ignore.ExactMatch.description=將所有所選檔案的名稱新增到目錄忽略列表
action.Subversion.Ignore.ExactMatch.text=所選檔名
action.Subversion.Ignore.MatchExtension.description=將 {0} 遮罩新增到目錄忽略列表
action.Subversion.ImportToSVNRepository.text=匯入 Subversion(_M)…
action.Subversion.Lock.description=鎖定檔案
action.Subversion.Lock.text=鎖定(_L)…
action.Subversion.MarkResolved.description=將文本和屬性衝突標記為已解決
action.Subversion.MarkResolved.text=標記為已解決(_M)…
action.Subversion.MarkTreeResolved.text=將樹衝突標記為已解決…
action.Subversion.PropertiesView.AddProperty.description=新增新屬性
action.Subversion.PropertiesView.AddProperty.text=新增屬性
action.Subversion.PropertiesView.Close.description=關閉此工具視窗
action.Subversion.PropertiesView.Close.text=關閉
action.Subversion.PropertiesView.DeleteProperty.description=刪除選定屬性
action.Subversion.PropertiesView.DeleteProperty.text=刪除屬性
action.Subversion.PropertiesView.EditKeywords.description=管理 svn:keywords 屬性
action.Subversion.PropertiesView.EditKeywords.text=編輯關鍵字
action.Subversion.PropertiesView.EditProperty.description=編輯選定屬性值
action.Subversion.PropertiesView.EditProperty.text=編輯屬性
action.Subversion.PropertiesView.FollowSelection.description=跟隨選擇
action.Subversion.PropertiesView.FollowSelection.text=跟隨選擇
action.Subversion.PropertiesView.Refresh.description=重新載入屬性
action.Subversion.PropertiesView.Refresh.text=重新整理
action.Subversion.Relocate.description=將工作副本重定位到其他 URL
action.Subversion.Relocate.text=重定位…
action.Subversion.RepositoryBrowser.Checkout.text=簽出(_C)…
action.Subversion.RepositoryBrowser.CompareWith.text=比較物件…
action.Subversion.RepositoryBrowser.CopyUrl.text=複製 URL…
action.Subversion.RepositoryBrowser.Export.text=匯出(_E)…
action.Subversion.Resolve.description=解決檔案中的文本衝突
action.Subversion.Resolve.text=解決文本衝突(_S)…
action.Subversion.SelectAllRevisions.description=全選
action.Subversion.SelectAllRevisions.text=全選
action.Subversion.SetProperty.description=在檔案或目錄中設定版本化屬性
action.Subversion.SetProperty.text=設定屬性(_T)…
action.Subversion.Share.text=共享目錄(_S)…
action.Subversion.ShareWholeProject.text=共享專案(Subversion)…
action.Subversion.ShowIntegratePanel.text=顯示整合面板
action.Subversion.ShowMergeSourceDetails.text=顯示合併原始碼詳細資訊
action.Subversion.ShowProperties.text=編輯屬性(_P)
action.Subversion.TogglePropertiesDiff.description=顯示 SVN 屬性的差異
action.Subversion.TogglePropertiesDiff.text=顯示屬性
action.Subversion.UndoIgnore.description=從目錄忽略列表中移除檔名/遮罩
action.Subversion.UndoIgnore.text=所選檔名
action.Subversion.Unlock.description=解鎖檔案
action.Subversion.Unlock.text=解鎖(_O)
action.Subversion.UnselectAllRevisions.description=取消全選
action.Subversion.UnselectAllRevisions.text=取消全選
action.Subversion.cleanup.error.message=對 ''{0}'' 執行清理時出錯: {1}
action.Subversion.cleanup.progress.title=Subversion 清理
action.Subversion.integrate.changes.actionname=整合到分支…
action.Subversion.integrate.changes.branch.info.source.label.text=源分支 URL: {0}
action.Subversion.integrate.changes.branch.info.target.label.text=目標分支 URL: {0}
action.Subversion.integrate.changes.collecting.changes.to.commit.task.title=正在收集要提交的更改
action.Subversion.integrate.changes.description=將選定的更改列表/更改集整合到選定的分支
action.Subversion.integrate.changes.dialog.add.wc.text=新增
action.Subversion.integrate.changes.dialog.remove.wc.text=移除
action.Subversion.integrate.changes.error.unable.to.collect.changes.text=收集要提交的更改時出錯: {0}
action.Subversion.integrate.changes.message.another.wc.text=所選目標位於另一個版本庫的工作副本內。仍要繼續?
action.Subversion.integrate.changes.message.files.up.to.date.text=所有檔案均為最新
action.Subversion.integrate.changes.message.not.under.control.text=所選目標不在 Subversio 的控制下。仍要繼續?
action.Subversion.integrate.changes.messages.title=整合到分支
action.Subversion.integrate.changes.progress.integrating.text=正在合併更改
action.Subversion.integrate.changes.select.working.copy.text=整合到工作副本:
action.Subversion.integrate.difference.option.use.ancestry.text=使用以前的版本(&U)
action.Svn.RefreshWorkingCopies.description=重新整理工作副本資訊
action.Svn.RefreshWorkingCopies.text=重新整理
action.Svn.Show.Working.Copies.description=顯示工作副本資訊: 工作副本格式和 URL
action.Svn.Show.Working.Copies.text=顯示工作副本
action.mark.list.as.merged.description=將所選修訂版標記為已合併，但實際沒有合併
action.mark.list.as.merged.text=標記為已合併
action.mark.list.as.not.merged.description=將所選修訂版標記為未合併，但不會更改 svn:mergeinfo 之外的任何內容
action.mark.list.as.not.merged.text=標記為未合併
action.name.configure.branches=組態分支
action.name.ignore.files=新增忽略檔案遮罩
action.name.mark.resolved=標記已解決
action.name.merge.from=合併自
action.name.merge.from.ellipsis=合併自…
action.name.refresh=重新整理
action.name.resolve.conflict=解決衝突
action.name.revert=還原(&R)
action.name.set.property=設定屬性
action.name.show.properties=顯示屬性
action.name.switch=切換
action.name.undo.ignore.files=從忽略列表移除檔名(或遮罩)
action.new.remote.folder.text=新增遠端目錄…
action.repository.browser.history.description=顯示歷史記錄
action.repository.browser.history.text=顯示歷史記錄
action.share.whole.project.text=共享專案(Subversion)…
action.text.annotate=註解
action.title.select.configuration.directory=更改組態目錄
add.files.errors.title=新增檔案時出錯
annotation.original.revision=原始修訂
annotation.show.merge.sources.default.text=在歷史記錄和註解中顯示合併原始碼
browse.changes.settings.stop.on.copy=複製時停止(&S)
button.copy=複製
button.keep=保留
button.load.quantity=載入 +{0}
button.merge.all=全部合併
button.merge.selected=合併所選內容
button.move=移動
button.resolve.conflict.accept.theirs=接受他們的更改
button.resolve.conflict.accept.yours=接受您的更改
button.resolve.conflict.merge=合併
button.select=選擇
button.share=共享
button.text.clear.authentication.cache=清除身份驗證快取(&C)
button.text.deselect.all=取消全選(&D)
button.text.edit.proxies=編輯網絡選項(&O)…
button.text.select.all=全選(&A)
button.text.ssh.accept=是 (_Y)
button.text.ssh.reject=否 (_N)
button.text.ssl.accept=接受(_A)
button.text.ssl.reject=拒絕(_R)
changes.browser.revision.term=修訂
checkbox.auth.keep.for.current.session=儲存憑證(&S)
checkbox.changes.filter.filter.by.author=作者(&U):
checkbox.checkin.auto.update.after.commit=提交後自動更新
checkbox.checkin.keep.files.locked=保持檔案鎖定(&K)
checkbox.checkout=簽出
checkbox.create.tags.branches=建立 /tags 和 /branches
checkbox.force.update=強制更新(&F)
checkbox.ignore.externals=忽略外部項(&E)
checkbox.ignore.whitespace.when.merge.text=&忽略空格
checkbox.include.externals.locations=包括外部項位置
checkbox.include.ignored.resources=包含忽略的資源
checkbox.replace.existing.files=取代現有檔案
checkbox.set.property.update.properties.recursively=遞迴更新屬性(&R)
checkbox.ssl.keep.for.current.session=儲存憑證(&S)
checkbox.svn.ssh.cache.fingerprint=將密鑰新增到 Subversion 快取(&A)
checkbox.switch.to.newly.created.branch.or.tag=將 {0} 切換到新增的分支或標記
checkbox.update.switch.configurable.to.specific.revision=更新/切換到特定版本(&R):
checkbox.update.switch.configurable.try.merge.without.changes=嘗試合併，但不做任何更改(&T)
checkin.different.formats.involved={0,choice,0#版本庫|1#版本庫} {1} 的選定更改\\n\\
屬於不同格式的 Subversion 工作副本。\\n\\
提交將分為多個提交。\\n\\
\\n\\
您可以在“更改 | Subversion 工作副本資訊”中將所有工作副本轉換為相同格式。\\n\\
是否要繼續提交?
checkin.operation.name=提交(_I)
checkout.dialog.button=檢出
checkout.dialog.title=從 Subversion 簽出
checkout.directory.chooser.prompt=選擇要從 Subversion 簽出的目錄
checkout.directory.chooser.title=簽出目錄
checkout.options.checkout.label=檢出:
checkout.options.dialog.title=SVN 簽出選項
checkout.repository=正在簽出版本庫…
checkout.repository.canceled=簽出已取消
checkout.repository.failed=簽出失敗
checkout.repository.tooltip=該專案將在完成簽出後開啟
checkout.stop.message.description=確定要停止簽出 {0} 版本庫嗎?
checkout.stop.message.title=停止簽出
cleanup.action.name=清理
column.name.merge.sources=合併原始碼
column.name.property.name=名稱
column.name.property.value=值
combobox.crlf.none=無
command.line.interactive.mode.description=<html>模擬直接從終端執行 Subversion 指令時的行為(互動模式)。<br>這是處理 svn+ssh 版本庫的密碼/密碼短語提示以及信任 https 版本庫的無效伺服器憑證所必需的。</html>
command.line.interactive.mode.title=啟用互動模式
committed.changes.action.enable.merge.highlighting=醒目提示已整合的更改列表
committed.changes.action.enable.merge.highlighting.description.text=選項僅適用於 SVN 版本庫和 1.5 版本的工作副本
committed.changes.action.merge.highlighting.refresh.description=重新整理合併的修訂資訊
committed.changes.action.merge.highlighting.refresh.text=重新整理
compare.with.branch.diff.title=與分支比較
compare.with.branch.error.title=與分支比較
compare.with.branch.location.error=在分支 ''{1}'' 下找不到檔案 ''{0}'' 的版本庫位置\\n\\
請檢查您的分支組態。
compare.with.branch.popup.title=與分支比較
compare.with.branch.progress.loading.content=載入內容中…
configurable.SvnConfigureProxiesComponent.display.name=HTTP 代理組態
configurable.name.svn.general=Subversion
configurable.name.svn.network=網絡
configurable.name.svn.presentation=表示
configurable.name.svn.ssh=SSH
configure.branches.branch.locations=分支位置:
configure.branches.error.wrong.url=主幹位置必須在版本庫根 ''{0}'' 下
configure.branches.title=組態 Subversion 分支
configure.branches.trunk.location=主幹位置:
configure.revision.head.radio=HEAD
configure.revision.specified.radio=指定的
confirmation.resolve.tree.conflict.merge.moved=將 {0} 中的更改應用到本地移動的 {1}?
confirmation.resolve.tree.conflict.merge.renamed=將 {0} 中的更改套用到本地重新命名的 {1}?
confirmation.text.add.dir=是否要安排將以下目錄新增到 Subversion?\\n\\
{0}
confirmation.text.add.file=是否要安排將以下檔案新增到 Subversion?\\n\\
{0}
confirmation.text.delete.dir=是否要安排將以下目錄從 Subversion 刪除?\\n\\
{0}\\n\\
注意: 提交更改後，該目錄將從磁碟中刪除。
confirmation.text.delete.dir.17=是否要安排將以下目錄從 Subversion 刪除?\\n\\
{0}
confirmation.text.delete.file=是否要安排將以下檔案從 Subversion 刪除?\\n\\
{0}
confirmation.text.delete.stored.authentication.information=您將刪除所有存儲的 Subversion 身份驗證資訊。\\n\\
確定要刪除嗎?
confirmation.text.edit.file=您要編輯的檔案在編輯前需要鎖定
confirmation.title.add.file=新增的時間表
confirmation.title.add.multiple.files=選擇要新增到 Subversion 的檔案
confirmation.title.clear.authentication.cache=清除身份驗證快取
confirmation.title.delete.file=計劃刪除
confirmation.title.delete.multiple.files=選擇要從 Subversion 刪除的檔案
conflict.action.add=新增
conflict.action.delete=刪除
conflict.action.edit=編輯
conflict.action.replace=取代
conflict.operation.merge=合併
conflict.operation.none=無
conflict.operation.switch=切換
conflict.operation.update=更新
conflict.reason.added=新增
conflict.reason.deleted=刪除
conflict.reason.edited=編輯
conflict.reason.missing=缺少
conflict.reason.moved.away=移開
conflict.reason.moved.here=已移到此處
conflict.reason.obstructed=障礙
conflict.reason.replaced=取代
conflict.reason.unversioned=未進行版本管理
copy.column.title=複製
copy.column.tooltip=從 {0} 複製
copy.dialog.title=分支或標籤
delete.files.errors.title=刪除檔案時出錯
dialog.Subversion.select.working.copy.title=組態工作副本路徑
dialog.Subversion.select.working.copy.wcopy.list.title=已知工作副本
dialog.create.branch.or.tag.from.working.copy.warning=<html>使用此變體建立<b>具有本地更改</b>的分支。<br/>通常，不僅是目標目錄，還將有幾個項“帶歷史記錄新增”。<br/><br/>具有與根不同的修訂的各個檔案將被分別複製。<br/>因此，建議先更新工作副本，然後再建立分支。</html>
dialog.description.select.configuration.directory=選擇 Subversion 組態目錄或建立新目錄
dialog.edit.http.proxies.settings.client.certificate.passphrase.text=SSL 客戶端憑證密碼短語(&H):
dialog.edit.http.proxies.settings.connection.timeout.text=連線超時(&I):
dialog.edit.http.proxies.settings.dialog.select.ssl.client.certificate.path.title=選擇憑證路徑
dialog.edit.http.proxies.settings.error.ambiguous.group.patterns.text=找到與多個組符合的版本庫 URL: {0}
dialog.edit.http.proxies.settings.error.ambiguous.group.patterns.to.text=URL {0} 符合 {1}
dialog.edit.http.proxies.settings.error.same.group.names.text=檢測到同名的組: ''{0}''
dialog.edit.http.proxies.settings.exceptions.text=異常(&X):
dialog.edit.http.proxies.settings.panel.proxy.title=HTTP 代理設定
dialog.edit.http.proxies.settings.panel.repositories.title=版本庫
dialog.edit.http.proxies.settings.panel.ssl.title=SSL 設定
dialog.edit.http.proxies.settings.password.text=密碼(&W):
dialog.edit.http.proxies.settings.paths.to.authority.certificates.text=CA 憑證檔案的逗號分隔路徑(&P):
dialog.edit.http.proxies.settings.patterns.text=URL 模式(&R):
dialog.edit.http.proxies.settings.port.must.be.number.error=連接埠必須為數字(組 ''{0}'')
dialog.edit.http.proxies.settings.port.text=連接埠(&O):
dialog.edit.http.proxies.settings.seconds.text=秒
dialog.edit.http.proxies.settings.server.text=伺服器(&S):
dialog.edit.http.proxies.settings.ssl.client.certificate.file.text=SSL 客戶端憑證檔案(&C):
dialog.edit.http.proxies.settings.tab.edit.system.file.title=系統檔案
dialog.edit.http.proxies.settings.tab.edit.user.file.title=使用者檔案
dialog.edit.http.proxies.settings.test.connection.button.text=測試連線(&T)
dialog.edit.http.proxies.settings.test.connection.error.title=連線測試失敗
dialog.edit.http.proxies.settings.test.connection.settings.will.be.stored.text=設定將被儲存
dialog.edit.http.proxies.settings.test.connection.settings.will.be.stored.title=警告
dialog.edit.http.proxies.settings.test.connection.success.text=連線測試成功
dialog.edit.http.proxies.settings.test.connection.success.title=連線測試成功
dialog.edit.http.proxies.settings.timeout.must.be.number.error=HTTP 超時必須為數字(組 ''{0}'')
dialog.edit.http.proxies.settings.trust.default.cas.text=信任預設 CA(&A)
dialog.edit.http.proxies.settings.user.text=使用者(&U):
dialog.message.accept.theirs.for.path=接受他們對 {0} 的更改?
dialog.message.accept.yours.for.path=接受您對 {0} 的更改?
dialog.message.branch.name.is.empty=分支名稱為空
dialog.message.can.not.detect.repository.root.for.url=無法檢測 URL 的版本庫根: {0}
dialog.message.confirm.move.folder=您即將移動名稱為 ''{0}'' 的目錄。是否確定?
dialog.message.could.not.parse.url=無法解析 url
dialog.message.error.relocating.working.copy=重定位工作副本時出錯: {0}
dialog.message.integrate.changes.error.no.available.files=沒有可用於整合的檔案
dialog.message.integrate.changes.error.not.versioned=無法啟動整合: 目標目錄不在 Subversion 控制下或不屬於所選分支。
dialog.message.integrate.changes.error.same.source.and.target=無法啟動整合: 目標分支和源分支相同。
dialog.message.integrate.changes.error.target.not.dir=無法啟動整合: 目標目錄不存在或不是目錄。
dialog.message.invalid.branch.name=分支名稱無效
dialog.message.invalid.branch.url=分支 url 無效
dialog.message.invalid.repository.location=版本庫位置無效
dialog.message.invalid.revision=修訂無效
dialog.message.invalid.working.copy.root=無效的工作副本根: {0}
dialog.message.keep.newly.created.files.in.their.original.place=在其初始位置保留新增檔案?
dialog.message.mark.tree.conflict.resolved.confirmation=是否要將樹衝突標記為已解決?
dialog.message.merge.confirm.reintegrate=您將重新整合更改。<br><br>此舉將導致分支 ''{0}'' <b>不能再用於進一步的處理</b>。<br>此分支既無法正確吸收新的主幹({1})更改，<br>也無法正確地重新整合到主幹。<br> <br>確定嗎?
dialog.message.merge.from.theirs.create.binary.file=(根據其更改)建立二進制檔案 {0}?
dialog.message.merge.from.theirs.delete.binary.file=(根據其更改)刪除二進制檔案 {0}?
dialog.message.merge.from.theirs.modify.binary.file=(根據其更改)對二進制檔案 {0} 套用更改?
dialog.message.merge.intersects.with.local.changes.prompt=存在與合併更改衝突的本地更改。\\n\\
是否要繼續?
dialog.message.merge.potentially.intersects.with.local.changes.prompt=存在與合併更改有可能相交的本地更改。\\n\\
是否要繼續?
dialog.message.merge.with.switched.paths.in.working.copy=工作副本中有一些切換的路徑。是否要繼續?
dialog.message.no.branch.base.location.selected=未選擇分支基位置
dialog.message.repository.path.does.not.exist=版本庫路徑 ''{0}'' 不存在。要建立它嗎?
dialog.message.select.binary.files.to.patch=選擇要打補丁的二進制檔案
dialog.message.set.working.copy.infinity.depth=您將以 ''infinity'' 深度簽出到 ''{0}''。\\n\\
您的工作副本也將隨之更新為 HEAD 修訂。
dialog.message.share.to.not.empty.directory=遠端目錄“{0}”非空。\\n\\
是否要繼續共享?
dialog.message.switch.target.not.copy.current=切換目標 URL 不是當前副本。\\n\\
是否要繼續?
dialog.message.target.file.already.exists=目標檔案已經存在
dialog.show.svn.map.title=Subversion 工作副本資訊
dialog.title.authentication.required=需要身份驗證
dialog.title.branch=建立分支或標記
dialog.title.can.not.invoke.action=無法呼叫 {0}
dialog.title.changes.in.url={0} 中的更改
dialog.title.check.out=從 Subversion 簽出
dialog.title.commit.will.split=Subversion: 提交將進行拆分
dialog.title.computing.difference=正在計算差異
dialog.title.convert.working.copy.format=轉換工作副本格式
dialog.title.destination.directory=目標目錄
dialog.title.edit.http.proxies.settings = 編輯與網絡層相關的 Subversion 選項
dialog.title.error=錯誤
dialog.title.export.directory=匯出目錄
dialog.title.import.directory=匯入目錄
dialog.title.integrate.to.branch=整合到分支
dialog.title.lock.file=鎖定檔案
dialog.title.lock.files=鎖定檔案
dialog.title.mark.resolved=標記已解決
dialog.title.mark.tree.conflict.resolved=將樹衝突標記為已解決
dialog.title.merge.from.branch=合併自 {0}
dialog.title.new.remote.folder=新增遠端目錄
dialog.title.relocate.working.copy=重新定位工作副本
dialog.title.resolve.tree.conflict=解決樹衝突
dialog.title.save.unified.diff=補丁檔案
dialog.title.select.configuration.directory=選擇組態目錄
dialog.title.select.merge.variant=選擇合併變體
dialog.title.select.path.to.subversion.executable=Subversion
dialog.title.select.repository.location=選擇版本庫位置
dialog.title.select.share.target=選擇共享目標
dialog.title.select.target.for.external=選擇用於外部的目標
dialog.title.select.working.copy.location=選擇工作副本位置
dialog.title.set.property=設定屬性
dialog.title.set.working.copy.infinity.depth=設定工作副本無限深度
dialog.title.ssh.examine.server.fingerprints=驗證伺服器密鑰指紋
dialog.title.ssh.settings.browse.executable=SSH 可執行檔案
dialog.title.ssh.settings.browse.private.key=私鑰
dialog.title.ssl.examine.server.crertificate=檢查伺服器憑證
dialog.title.svn.delete=SVN 刪除
dialog.title.svn.export.options=SVN 匯出選項
dialog.title.svn.import.options=SVN 匯入選項
dialog.title.svn.keywords=SVN 關鍵字
dialog.title.svn.properties.diff=SVN 屬性差異
dialog.title.svn.repository.browser=SVN 版本庫瀏覽器
dialog.title.switch.target.problem=切換目標問題
dialog.upgrade.wcopy.format.title=Subversion 工作副本格式
diff.cant.get.properties.changes=無法顯示 SVN 屬性
diff.options.checkbox.reverse.diff=反轉差異
diff.options.label.compare=比較:
diff.options.label.compare.type=比較類型
diff.options.label.with=與:
diff.options.no.patch.file.error=請指定儲存補丁檔案的路徑
diff.options.no.url.error=請選擇一個 URL 進行比較
diff.options.radio.graphical.compare=圖形比較
diff.options.radio.unified.diff=統合差異
diff.options.same.url.error=請選擇其他 URL 進行比較
diff.options.title=與分支或標記比較
error.authentication.canceled.for.repository=已對版本庫取消身份驗證: {0}
error.can.not.access.file.base.revision.contents.administrative.area.is.locked=無法存取檔案的基礎修訂內容: 管理區域已被鎖定
error.can.not.create.directory=無法建立目錄: {0}
error.can.not.delete.file=無法刪除檔案: {0}
error.can.not.find.file=找不到檔案: {0}
error.can.not.find.relative.path.for.path.at.revision=找不到 {0}@{1} 的相對路徑
error.can.not.find.repository.root.for.url=找不到 URL 的版本庫根: {0}
error.can.not.find.repository.root.for.url.in.revision=在修訂 {1} 中找不到 URL: {0} 的版本庫根
error.can.not.find.url.for.file=找不到檔案的 url: {0}
error.can.not.find.working.copy.for.file=找不到檔案的工作副本: {0}
error.can.not.get.current.revision.for.path=無法獲取檔案 {0} 的當前修訂
error.can.not.get.last.changed.revision.for.path.please.file.an.issue=無法獲取檔案上次進行的修訂: {0}\\n\\
請為此檔案執行 svn info 並提交問題。
error.can.not.load.theirs.content.for.file=無法為檔案 {0} 載入他們的內容
error.can.not.set.property=無法設定屬性: {0}
error.cannot.load.revisions=無法載入修訂列表
error.could.not.compare.local.file.and.remote.url.with.executable.for.svn.version=無法將本地檔案和遠端 Url 與 svn {0} 的可執行檔案相比較
error.could.not.determine.revision.number.for.file.and.revision=無法確定檔案 {0} 和修訂 {1} 的修訂號
error.could.not.find.separating.space=找不到分隔空間
error.could.not.find.start.quote=找不到起始引號
error.could.not.get.head.info.for.url=無法獲取 {0} 的標頭資訊
error.could.not.get.info.for.path=無法獲取 {0} 的資訊
error.could.not.get.relative.path.for.parent.and.child=無法獲取 {0} 和 {1} 的相對路徑
error.could.not.get.revision.for.url=無法獲取 {0} 的修訂
error.could.not.get.svn.version=退出程式碼: {0}，錯誤: {1}
error.could.not.parse.merge.info=無法解析 {0}
error.could.not.parse.svn.version=無法解析 svn 版本: {0}
error.file.is.not.under.subversion=檔案 {0} 未受到 Subversion 控制
error.file.is.not.under.version.control=檔案 {0} 未進行版本管理
error.format.is.not.supported=不支持 {0} 格式。支援的格式: {1}。
error.integration.was.canceled=整合已被取消
error.invalid.svn.revision=無效的 svn 修訂: {0}
error.invalid.url=無效 url: {0}
error.latest.existing.revision.found.for.url=已找到 {0} 的最新現有修訂
error.missing.committed.revision.number=缺少提交的修訂號: {0}
error.move.have.not.been.performed=尚未執行 Subversion 移動。
error.no.branch.point.found.for.target=找不到 {0} 的分支點
error.parse.file.status.unknown.state.on.line=第 {0} 行的狀態未知
error.properties.loading.for.revision.canceled=已取消為修訂 {0} 載入屬性。
error.revert.failed=還原失敗
error.revision.from.must.be.a.valid.number=“起始修訂”必須為有效數字
error.revision.to.must.be.a.valid.number=“結束修訂”須為有效數字
error.selected.destination.conflicts.with.existing=所選目標與現有目標相衝突: {0}
error.server.ssl.certificate.rejected=伺服器 SSL 憑證被拒
error.svn.exited.with.error.code=SVN 程序已退出，錯誤程式碼為: {0}
error.svn.status.not.in.working.copy=請求的狀態不在工作副本中: {0}
error.svn.status.with.no.output=狀態請求沒有為指令返回任何內容: {0}
error.target.not.found.in.paths=在 {1} 中找不到 {0}
error.target.of.move.operation.is.already.under.version.control=移動動作的目標已受到版本控制。
error.url.could.not.contain.fragment={0} 不能包含片段
error.url.could.not.contain.query={0} 不能包含查詢
error.url.is.not.absolute={0} 非絕對
error.url.is.not.hierarchical={0} 非層次結構
error.wrong.committed.revision.number=提交的修訂號錯誤: {0}
exception.text.cannot.annotate.directory=註解動作僅對檔案有意義
exception.text.cleanupaction.batchperform.not.implemented=CleanupAction.batchPerform 未實作
exception.text.failed.to.unlock.file=無法解鎖檔案: {0}
exception.text.file.miss.svn=檔案 ''{0}'' 為唯讀，但缺少 svn:needs-lock 屬性
exception.text.locking.file.failed=無法鎖定檔案: {0}
exception.text.root.was.not.properly.updated=svn: {0} 未正確更新; 可能是因為它已經與父級一起從版本庫中移除。
exportable.SvnDiffSettings.presentable.name=SVN 差異
file.conflict.property=屬性
file.conflict.text=文本
file.conflict.tree=樹
file.status.external=外部 (svn)
file.status.obstructed=受阻 (svn)
file.status.replaced=取代 (svn)
group.IgnoreChoicesGroup.text=忽略
group.RevertIgnoreChoicesGroup.text=從忽略列表中移除
group.SubversionFilePopupGroup.text=Subversion(_S)
import.dialog.button=匯入
import.dialog.title=匯入 Subversion
integrate.configuration.description.label=將源之間的差異整合到工作副本中(比較源 2 和源 1)
integrate.configuration.revision1.label=修訂(&V)
integrate.configuration.revision2.label=修訂(&R)
integrate.configuration.source1.label=源 1:
integrate.configuration.source2.label=源 2:
integrate.display.name=整合
label.after.accepting.theirs.for.path=在接受他們對 {0} 的更改後
label.already.merged=已合併
label.auth.authentication.realm=身份驗證領域: ''{0}''
label.auth.password=密碼(&P):
label.auth.user.name=用戶名(&U):
label.before.accepting.theirs.for.path=在接受他們對 {0} 的更改前
label.branch.base.url=基 URL:
label.branch.name=名稱:
label.changelists.merging.faced.problems=更改列表:\\n\\
{0}\\n\\
合併面臨的問題
label.commit.message=提交訊息:
label.configure.change.label=將工作副本 ''{0}'' 格式更改為:
label.configure.create.label={0} 將要建立新的 Subversion 工作副本，\\n\\
請選擇所需的工作副本格式:
label.configure.upgrade.label=工作副本升級策略:
label.conflict.directory.added=(目錄)已新增
label.conflict.directory.unversioned=(目錄)未進行版本管理
label.conflict.file.added=(檔案)已新增
label.conflict.file.unversioned=(檔案)未進行版本管理
label.conflict.left.side=左: {0}
label.conflict.right.side=右: {0}
label.copy.comment=&註釋
label.copy.from=複製自
label.copy.from.revision=修訂(&V):
label.copy.select.location.dialog.copy.as=複製為(&A):
label.copy.to=複製到
label.define.share.target=定義共享目標
label.depth.description=取代舊的“遞迴”選項。“遞迴”為 false 等效於“直接子級”，“遞迴”為 true 等效於“無限”
label.depth.empty=空
label.depth.exclude=排除
label.depth.files=檔案
label.depth.immediates=直接
label.depth.infinity=無限
label.depth.text=深度(&D):
label.depth.unknown=未知
label.destination=目標:
label.export=匯出:
label.external.copy=外部副本
label.file.has.conflicts=檔案有 {0} 個衝突，無法提交
label.file.has.conflicts.before.and.after=檔案有 {0} 個衝突，無法提交\\n\\
之前: {1}\\n\\
之後: {2}
label.file.has.conflicts.before.or.after=檔案有 {0} 個衝突，無法提交\\n\\
{1}
label.from.url=源 URL:
label.import.from=匯入自:
label.import.to=匯入到:
label.local.target=本地目標:
label.locally.deleted.file.has.conflicts=檔案有 {0} 個衝突
label.lock.comment=鎖定註釋(&L):
label.locl.steal.existing=竊取現有鎖(&S):
label.merge.all.from.branch=合併 {0} 中的全部內容
label.merge.all.from.branch.at.revision=合併 {1} 的 {0} 中的全部內容
label.merge.all.from.branch.at.revision.reintegrate=合併 {1} 的 {0} 中的全部內容(重新整合)
label.merge.all.from.branch.reintegrate=合併 {0} 中的全部內容(重新整合)
label.merge.from.url=從:
label.merge.local.changes.intersection=以下檔案具有與合併更改相交的本地更改:
label.merge.source.revision=合併原始碼修訂
label.merge.to.branch=到:
label.merged.from.branch=已合併自 {0}
label.mixed.revision.working.copy=混合修訂工作副本
label.nested.copy.type.external=外部
label.nested.copy.type.inner=嵌套
label.nested.copy.type.switched=已切換
label.no.subversion.1.5.working.copies=此專案中沒有 1.5 版本庫的 Subversion 1.5 工作副本
label.override.native.eols.with=覆寫 'native' EOL 的選項:
label.path.revisions.info={0}(當前: {1}，已提交: {2})
label.path.to.svn.executable=Subversion 可執行檔案的路徑:
label.point.to.repository.location=指向版本庫位置
label.recent.messages=最近的訊息:
label.remote.folder.name=遠端目錄名稱:
label.remote.folder.url=遠端目錄 URL:
label.repositories=版本庫:
label.revision=修訂
label.select.checkout.destination.directory=選擇簽出目標目錄
label.select.directory.to.export.from.subversion=選擇要從 Subversion 匯出的目錄
label.select.directory.to.import.into.repository=選擇要匯入版本庫的目錄
label.select.export.destination.directory=選擇匯出目標目錄
label.select.file.to.save.unified.diff=選擇用於存儲統合差異的檔案
label.select.files.and.directories.to.mark.resolved=選擇要標記為已解決的檔案和目錄:
label.select.keywords.to.set=選擇要設定的關鍵字:
label.select.location.to.copy.from=選擇要從中複製的位置:
label.select.path.to.subversion.executable=選擇 Subversion 可執行檔案(1.7+)的路徑
label.select.target.working.copy=選擇目標工作副本的路徑
label.set.property.property.name=屬性名稱(&N):
label.skipped.changelists=已跳過的更改列表: {0}
label.source.url=源 URL:
label.specify.ssl.protocol.manually=請嘗試手動指定 SSL 協議 - SSLv3 或 TLSv1
label.ssh.key.file=密鑰檔案(&F):
label.ssh.passphrase=密碼短語(&R):
label.ssh.server.provided.fingerprints=無法建立主機 {0} 的驗證。
label.ssh.server.provided.fingerprints2={0} 密鑰指紋為
label.ssh.server.provided.fingerprints3=確定要繼續連線嗎?
label.ssl.certificate.password=憑證密碼短語:
label.ssl.certificate.path=憑證路徑:
label.ssl.server.provided.certificate=伺服器提供了以下憑證:
label.svn.phantom.change=技術記錄
label.svn.properties.changed=SVN 屬性已更改
label.switched.copy=已切換副本
label.target.location=目標位置:
label.target.name=目標名稱:
label.target.url=目標 URL:
label.text.delete.stored.credentials=刪除 'http'、'svn' 和 'svn+ssh' 協議的所有已存儲憑證
label.to.url=目標 URL:
label.update.switch.to.revision=更新/切換到修訂:
label.update.url=URL:
label.working.copy=工作副本
label.working.copy.depth=深度:
label.working.copy.format=格式:
label.working.copy.format.unknown=未知
label.working.copy.root=工作副本根
label.working.copy.root.outside.text=工作副本根位於“專案設定”中指定的目錄外部。\\n\\
整個工作副本將被轉換。
label.working.copy.url=URL:
link.change.format=更改
link.fix.depth=修正
merge.chunk.changelist.description={0} [來自於修訂 {1}]
merge.source.details.title=合併 {0} [{1}] 的原始碼詳細資訊
message.text.cannot.checkout=無法從 svn 簽出: {0}
message.text.cannot.export=無法從 svn 匯出: {0}
message.text.cannot.import=無法匯入 svn: {0}
message.text.cannot.load.supported.formats=無法載入支援的格式: {0}
message.text.files.lock.failed={0,choice, 0#無法鎖定檔案。|1#無法鎖定檔案。}
message.text.files.locked={0,choice, 0#無法鎖定檔案。|1#已鎖定 1 個檔案|2#已鎖定 {0,number} 個檔案}
message.text.files.unlocked={0,choice, 0#無法解鎖檔案。|1#已解鎖 1 個檔案|2#已解鎖 {0,number} 個檔案}
message.text.no.conflicts.found=未找到衝突
message.text.update.no.directories.found=找不到要更新的版本管理目錄
message.theirs.accepted.for.file=已接受他們對 {0} 的更改
message.theirs.changes.merged.for.file=已針對 {0} 合併他們的更改
message.title.export=從 Subversion 匯出
message.title.import=匯入 Subversion
message.title.no.conflicts.found=無衝突
message.title.unlock.failures=解鎖失敗
message.yours.accepted.for.file=已接受您對 {0} 的更改
messate.text.update.error=SVN: 更新錯誤
move.dialog.title=移動或重新命名
move.files.errors.title=移動檔案時出錯
navigate.to.idea.proxy.settings=導覽到一般代理設定
no.differences.between.sources.error.message=源和相同源之間沒有區別
non.english.locale.detected.warning=使用了非英語區域設定。
notification.action.click.to.fix=點擊以修正。
notification.content.authentication.failed=身份驗證失敗: {0}
notification.content.branches.load.error=分支載入錯誤: {0}
notification.content.can.not.access.working.copy.database=存取 svn 工作副本資料庫時發生了若干錯誤。
notification.content.can.not.merge.from.self=無法自我合併
notification.content.everything.is.up.to.date=所有內容都已處於最新狀態
notification.content.merge.start.was.not.found=找不到合併起始點
notification.content.multiple.roots.unsupported.format=某些根的格式可能是不受支援的 Subversion 格式
notification.content.not.logged.into.subversion=未登錄到 Subversion ''{0}'' ({1})
notification.content.revision.commit.message.changed.to=修訂 #{0} 註釋更改為:\\n\\
''{1}''
notification.content.single.root.unsupported.format=根 ''{0}'' 可能是不受支援的 Subversion 格式
notification.content.unknown.certificate.type.from.url=Subversion: {0} 中的憑證類型未知
notification.group.svn.roots=Subversion 根檢測失敗
notification.title.not.logged.into.subversion=未登錄到 Subversion
operation.merge=合併
popup.content.already.checking=正在檢查…
popup.content.failed.to.authenticate.to.proxy=代理驗證失敗。
popup.content.failed.to.authenticate.to.proxy.change.credentials=代理驗證失敗。您可以在 HTTP 代理設定中更改代理憑證。
popup.title.select.branch=選擇分支
popup.title.select.branch.to.integrate.to=選擇要整合到的分支…
progres.text2.merged=已合併 {0}
progres.text2.updated=已更新 {0}
progres.text2.updated.to.revision=已更新至修訂 {0}。
progress.details.merging.changelist.range=正在合併更改列表 {0}
progress.details.upgraded.path=已升級路徑 {0}
progress.live.provider.loading.revisions.details.text=正在從伺服器載入修訂…
progress.live.provider.loading.revisions.text=正在從伺服器載入修訂
progress.message.connecting.to.url=正在連線到 {0}
progress.searching.for.files.with.conflicts=正在搜尋有衝突的檔案
progress.text.browser.copying=正在拷貝{0}
progress.text.browser.creating=正在建立 {0}
progress.text.browser.moving=正在移動 {0}
progress.text.browser.remote.destination=到 {0}
progress.text.changes.collecting.changes=正在收集有關更改的資訊
progress.text.checking.out=正在將檔案簽出到 ''{0}''
progress.text.clearing.stored.credentials=正在清除 {0} 中存儲的憑證
progress.text.collecting.merge.information=正在收集合併資訊
progress.text.collecting.not.merged.revisions=正在收集未合併的修訂
progress.text.computing.annotation=正在計算 ''{0}'' 的註解
progress.text.converting.working.copy.format=將 {0} 格式的工作副本從 {1} 轉換為 {2}
progress.text.copy.to=複製到 ''{0}''
progress.text.create.remote.folder=建立遠端目錄
progress.text.deleting=正在刪除 {0}
progress.text.export=正在將檔案匯出到 ''{0}''
progress.text.import=匯入 {0}
progress.text.loading.contents=正在載入 ''{0}'' 的內容
progress.text.locking.files=正在鎖定版本庫中的檔案…
progress.text.merging.changes=正在將更改合併到 ''{0}''
progress.text.merging.dry.run.changes=正在將(dry run)更改合併到 ''{0}''
progress.text.performing.path.cleanup=正在執行 ''{0}'' 清理…
progress.text.unlocking.files=正在解鎖版本庫中的檔案…
progress.text.updating=正在更新 ''{0}''
progress.text.updating.external.location=正在更新 ''{0}'' 的外部位置
progress.text2.added=已新增 {0}
progress.text2.adding=正在新增 ''{0}''
progress.text2.changes.establishing.connection=正在建立與 ''{0}'' 的連線
progress.text2.checked.out=已簽出 {1} 個檔案，正在簽出 {0}
progress.text2.checked.out.revision=已簽出修訂 {0}。
progress.text2.collecting.history=正在收集 ''{0}'' 的修訂歷史記錄
progress.text2.conflicted={0} 存在衝突
progress.text2.deleted=已刪除 {0}
progress.text2.deleting=正在刪除 ''{0}''
progress.text2.exported=已匯出 {1} 個檔案，正在匯出 {0}
progress.text2.exported.revision=已匯出修訂 {0}。
progress.text2.fetching.external.location=正在獲取 ''{0}'' 的外部位置
progress.text2.processing.file=正在處理檔案 {0}
progress.text2.processing.revision=正在處理修訂 ''{0}''
progress.text2.replacing=正在取代 ''{0}''
progress.text2.restored.file=已還原 {0}
progress.text2.revision.information=修訂{0}
progress.text2.revision.processed=已處理修訂 ''{0}''
progress.text2.sending=正在發送 ''{0}''
progress.text2.skipped.file=已跳過 {0}
progress.text2.transmitting.delta=正在傳輸 ''{0}'' 的增量
progress.text2.treeconflicted=已衝突 {0}(樹衝突)
progress.title.accepting.theirs.for.path=正在接受他們對 {0} 的更改
progress.title.accepting.working.state=正在接受工作狀態
progress.title.accepting.yours.for.path=為之接受您的更改: {0}
progress.title.adding.file.to.subversion=正在將 {0} 新增到 Subversion
progress.title.adding.files.to.subversion=正在向 Subversion 新增檔案
progress.title.applying.binary.changes=正在套用二進制更改
progress.title.browser.copy=複製
progress.title.browser.delete=刪除
progress.title.browser.move=移動
progress.title.calculating.copy.revision=正在計算副本修訂
progress.title.check.out=從 Subversion 簽出
progress.title.check.out.cancel=停止從 Subversion 簽出
progress.title.check.remote.folder.contents=檢查遠端目錄內容
progress.title.checking.repository.capabilities=正在檢查版本庫容量
progress.title.checking.target.folder=正在檢查目標目錄
progress.title.cleanup.project=清理專案
progress.title.clear.authentication.cache=清除身份驗證快取(&C)
progress.title.commit=提交
progress.title.convert.working.copy.format=轉換工作副本格式
progress.title.copy=Subversion 副本
progress.title.creating.external=正在建立外部
progress.title.creating.patch.for.theirs.changes=正在為其更改建立補丁
progress.title.deleting.files.from.subversion=正在從 Subversion 中刪除檔案
progress.title.detecting.repository.root=正在檢測版本庫根
progress.title.edit.revision.comment=編輯修訂註釋
progress.title.filtering.branch.revisions=正在篩選 {0} 修訂
progress.title.getting.base.and.theirs.revisions.content=獲取基本內容及其修訂內容
progress.title.getting.latest.repository.revision=正在獲取最新的版本庫修訂
progress.title.loading.branches=正在載入分支
progress.title.loading.change.details=正在載入更改詳細資訊
progress.title.loading.child.entries=正在載入子條目
progress.title.loading.file.content=正在載入遠端檔案內容
progress.title.loading.file.properties=正在載入遠端檔案屬性
progress.title.loading.recent.branch.revisions=正在載入最近的 {0} 修訂
progress.title.loading.tree.conflict.details=正在載入樹衝突詳細資訊
progress.title.loading.working.copies.data=Subversion: 正在載入工作副本資料…
progress.title.lock.files=鎖定檔案
progress.title.looking.for.branch.origin=正在尋找分支來源
progress.title.looking.for.file.working.copy.root=正在尋找 ''{0}'' 工作副本根
progress.title.mark.tree.conflict.resolved=將樹衝突標記為已解決
progress.title.merging.all.from.branch=正在合併 {0} 中的全部內容
progress.title.merging.all.from.branch.reintegrate=正在合併 {0} 中的全部內容(重新整合)
progress.title.moving.files.in.subversion=正在移動 Subversion 中的檔案
progress.title.relocating.working.copy=正在重定位工作副本
progress.title.resolve.tree.conflict=解決樹衝突
progress.title.share.directory=共享目錄
progress.title.shelving.local.changes.before.merge=正在擱置合併前的本地更改
progress.title.svn.branches.preloader=Subversion 分支預載入程序
progress.title.svn.roots.authorization.checker=SVN VCS 根授權檢查器
progress.title.test.connection=測試連線
progress.title.unlock.files=解鎖檔案
quick.merge.variants.merge.all=全部合併
quick.merge.variants.merge.all.explanation=所有未合併的修訂將被合併。\\n\\
Subversion 將使用本地副本中記錄的 svn:mergeinfo 屬性尋找未合併的修訂。
quick.merge.variants.pre.select=通過預篩選選擇
quick.merge.variants.pre.select.explanation=尋找涉及的一個分支複製自另一個分支的位置。\\n\\
僅載入尚未合併的修訂以供選擇。執行可能需要很長時間。
quick.merge.variants.quick.select=快速手動選擇
quick.merge.variants.quick.select.explanation=顯示來自目標分支、已合並和未合併分支的所有修訂。\\n\\
用於手動選擇。快速獲取結果。
radio.configure.change.auto.16format=1.6 格式(&6)
radio.configure.change.auto.17format=1.7 格式(&7)
radio.configure.change.auto.18format=1.8 格式(&8)
radio.configure.create.auto.16format=1.6 格式(&6)
radio.configure.create.auto.17format=1.7 格式(&7)
radio.configure.create.auto.18format=1.8 格式(&8)
radio.configure.upgrade.auto.16format=自動升級(使用 Subversion 1.6)(&6)
radio.configure.upgrade.auto.17format=自動升級(使用 Subversion 1.7)(&7)
radio.configure.upgrade.auto.18format=自動升級(使用 Subversion 1.8)(&8)
radio.copy.repository.location=版本庫位置(&R):
radio.copy.to.any.location=任何位置
radio.copy.to.branch.or.tag=分支或標籤
radio.copy.working.copy=工作副本(&W)
radio.set.property.delete.property=刪除屬性(&D)
radio.set.property.set.property.value=設定屬性值(&S):
radio.share.target.at.selected.repository.location=在所選版本庫位置
radio.share.target.in.new.folder=在所選版本庫位置的新“{0}”目錄中
refresh.branches.item=重新整理分支…
repository.browser.add.location.action.description=新增版本庫位置
repository.browser.add.location.action.text=新增版本庫位置
repository.browser.add.location.menu.item=版本庫位置(_R)…
repository.browser.add.location.prompt=版本庫 URL:
repository.browser.add.location.title=新增版本庫位置
repository.browser.browse.changes.action=瀏覽更改(_B)…
repository.browser.browse.changes.description=檢視選定節點中的更改歷史記錄
repository.browser.compare.title=比較 ''{0}'' 和 ''{1}''
repository.browser.details.action=顯示/隱藏詳細資訊
repository.browser.discard.location.action=捨棄位置(_L)
repository.browser.discard.location.prompt=要捨棄位置 ''{0}'' 嗎?
repository.browser.discard.location.title=捨棄位置
repository.browser.edit.location.dialog.title= 編輯位置 URL
repository.browser.edit.location.menu.item= 編輯位置 URL(_U)…
repository.browser.import.action=匯入(_I)…
repository.browser.new.folder.action=遠端目錄(_F)…
repository.browser.no.locations.added.info=未新增版本庫位置。
repository.browser.refresh.action=重新整理選定樹節點
revision.title=修訂
select.location.invalid.url.message=無效的 Subversion 版本庫 URL: ''{0}''
separator.commit.comment.prefix=提交註釋前綴
separator.property.changes=屬性更改
server.ssl.accept.temporary.action.name=接受臨時(_T)
settings.HTTP.timeout=HTTP 超時:
settings.SSH.connection.timeout=SSH 連線超時:
settings.SSH.read.timeout=SSH 讀取超時:
settings.check.mergeinfo=準備合併時檢查目標子樹中的 svn:mergeinfo
settings.edit.servers.subversion.runtime.configuration.file=編輯 'servers' Subversion 執行時組態檔案
settings.maximum.revisions.number=註解中可回顧的最大修訂數:
settings.seconds=秒
settings.ssl.protocols=SSL 協議:
settings.ssl.protocols.all=所有
settings.ssl.protocols.all.tlsv1=TLSv1
settings.ssl.protocols.sslv3=SSLv3
settings.use.custom.directory=使用自訂組態目錄(&U):
share.directory.action=共享目錄…
share.directory.checkout.back.progress.text=正在簽出 {0}
share.directory.commit.message={2}\\n\\
{1} 建立的目錄 ''{0}''
share.directory.create.dir.progress.text=正在建立遠端目錄 {0}
share.directory.info.message=要完成共享動作，請提交 ''{0}''。
share.directory.title=共享目錄
share.or.import.add.progress.text=正在排定 {0} 的新增時間表
show.properties.diff.progress.text.revision.information=修訂{0}
show.properties.diff.progress.text2.property.information=屬性 {0}
source.url.could.not.be.empty.error.message=源 URL 不能為空
ssh.settings.executable.label=SSH 可執行檔案:
ssh.settings.password.choice.title=密碼
ssh.settings.port.label=連接埠:
ssh.settings.private.key.choice.title=私鑰
ssh.settings.private.key.path.label=路徑:
ssh.settings.subversion.config.choice.title=Subversion 組態
ssh.settings.tunnel.label=SSH 隧道:
ssh.settings.update.tunnel.title=更新
ssh.settings.user.name.label=用戶名:
status.group.name.replaced=已取代
status.text.checked.out.revision=已簽出修訂 {0}。
status.text.committed.revision=提交的修訂 {0}。
status.text.merge.sources=合併原始碼
status.text.updated.to.revision=已更新至修訂 {0}。
subversion.executable.notification.cant.run.in.safe.mode=無法在安全模式下執行 Svn 指令
subversion.executable.notification.description=Subversion 可執行檔案的路徑可能是錯誤的。
subversion.executable.notification.title=無法使用 Subversion 命令行客戶端
subversion.executable.too.old=Subversion 命令行客戶端版本過舊({0})。
subversion.roots.detection.errors.found.action.text=修復
subversion.roots.detection.errors.found.description=檢測 Subversion 工作副本時發現錯誤。
svn.cannot.save.credentials.store-auth-creds=無法存儲憑證: “store-auth-creds = no”禁止
svn.create.external.below.action=建立外部…
svn.create.external.below.description=選擇 URL，新增 svn:external 屬性，然後可以選擇簽出
svn.edit.commit.message.attention=注意! 以前的訊息將丟失!
svn.edit.commit.message.prompt=新修訂註釋:
svn.edit.commit.message.title=編輯修訂 #{0} 註釋
svn.integrate.changelist.warning.unresolved.conflicts.text=整合中斷。存在未解決的衝突或跳過的項。
svn.name.with.mnemonic=Subversion(_S)
svn.option.ignore.whitespace.in.annotate=忽略註解中的空格差異
svn.phantom.changes.viewer=SVN 模擬更改檢視器
svn.properties.viewer=SVN 屬性檢視器
svn.short.name.with.mnemonic=SVN(_S)
svn.tree.conflict.viewer=SVN 樹衝突檢視器
tab.repository.merge.panel.filter.minus=篩選出未整合項
tab.repository.merge.panel.filter.others=篩選出其他
tab.repository.merge.panel.filter.plus=篩選出整合項
tab.title.create.external=建立外部
tab.title.edit.revision.comment=編輯修訂註釋
tab.title.failed.to.share.project=無法共享專案
tab.title.merge.local.changes.intersection={0}，本地更改相交
text.svn.phantom.change=已記錄此更改，因為其目標檔案被刪除，\\n\\
並且某些父目錄已複製(或移動)到新位置。
tooltip.revision.number.message=修訂 {0}: {1}
tooltip.use.project.location=使用專案位置
toolwindow.stripe.SVN_Properties=SVN 屬性
toolwindow.stripe.SVN_Repositories=SVN 版本庫
toolwindow.working.copies.info.title=Subversion 工作副本資訊
tree.conflict.description=本地 {0}，{2} 時傳入 {1}
undo.integrate.to.branch=撤消整合到分支…
undo.integrate.to.branch.description=從分支中移除修訂中所做的更改
undo.integrate.to.branch.dialog.title=撤消整合到分支
update.configuration.specific.url=更新/切換到特定 URL(&U):
update.switch.configurable.name=更新/切換
update.switch.to.branch.text=使用分支:
use.idea.proxy.as.default=將 {0} 一般代理設定用作 Subversion 的預設設定
use.idea.proxy.as.default.label.text=只有 HTTP 代理可以用作預設設定
value.new.branch.name=new_branch
value.new.folder.name=NewFolder
value.new.server.group.name=未命名
value.patch.file.name=TheirsChanges.patch"
`;

exports[`src messages/VcsBundle.properties 1`] = `
"ChangesBrowserToolWindow.toolwindow.name=更改
RepositoryBrowser.toolwindow.name=版本庫
action.AnActionButton.text.add.jira.pattern=新增 JIRA 模式
action.AnActionButton.text.add.youtrack.pattern=新增 YouTrack 模式
action.Anonymous.text.remove.all.leading.directories=移除所有前導目錄
action.Anonymous.text.restore.all.leading.directories=還原所有前導目錄
action.ChangesViewToolWindowPanel.text=檢視選項
action.DumbAware.ApplyPatchDifferentiatedDialog.description.refresh=重新整理
action.DumbAware.ApplyPatchDifferentiatedDialog.text.refresh=重新整理
action.DumbAwareAction.text.compare.with.local.content=與本地內容比較
action.ImportIntoShelfAction.description=將補丁檔案複製到擱置
action.ImportIntoShelfAction.text=匯入補丁…
action.NotificationAction.AllVcses.text.install=安裝
action.NotificationAction.AllVcses.text.open.plugin.page=開啟“延伸模組”頁面
action.NotificationAction.AllVcses.text.read.more=閱讀更多
action.NotificationAction.InactiveRangesDamagedNotification.text.view.changes=檢視更改…
action.NotificationAction.VFSListener.text.view.files=檢視檔案…
action.NotificationAction.VcsRootProblemNotifier.text.configure=組態…
action.NotificationAction.VcsRootProblemNotifier.text.enable.integration=啟用整合
action.NotificationAction.VcsRootProblemNotifier.text.ignore=忽略
action.SearchFieldAction.text.find=尋找: 
action.ShowAffectedFilesAction.show.affected.files.text=顯示受影響的檔案
action.ToggleAction.description.show.details=顯示詳細資訊面板
action.ToggleAction.text.preview.diff=預覽差異
action.ToggleAction.text.scope.filter=作用域篩選器
action.ToggleAction.text.show.details=顯示詳細資訊
action.Vcs.Toolbar.QuickListPopupAction.text=VCS 動作
action.amend.commit.anyway.text=仍然修正
action.annotate.previous.revision.text=註解之前的修訂
action.annotate.revision.text=註解修訂
action.annotate.selected.revision.in.new.tab.description=在新頁籤中註解所選修訂
action.annotate.show.diff.preview.on.hover.text=懸停時顯示差異
action.annotate.successor.selected.revision.in.new.tab.description=在新頁籤中註解所選修訂的後繼者
action.clone.dialog.stub.click.to.continue=點擊“{0}”繼續
action.commit.anyway.text=仍然{0}
action.description.compare=比較版本
action.description.create.patch.for.selected.revisions=為所選修訂建立補丁
action.description.refresh=重新整理檔案歷史記錄
action.description.refresh.compare.with.local.panel=重新整理更改
action.display.name.check.scope.status=檢查{0}狀態
action.display.name.integrate.scope=整合{0}
action.display.name.update=更新
action.display.name.update.scope=更新{0}
action.enable.version.control.integration.text=啟用版本控制整合(_E)…
action.filter.filter.by.text=篩選依據
action.filter.moved.files.text=已移動且無更改
action.filter.non.important.files.text=包含不重要的更改
action.filter.separator.text=隱藏檔案
action.for.file.with.dialog.text={0}{1, choice, 1#檔案|2#檔案}…
action.import.to.shelf=匯入到 Shelf
action.message.use.selected.changes.description={0}所選更改
action.name.check.scope.status=檢查{0}狀態(_K)
action.name.check.status=檢查狀態(_K)
action.name.checkin.directory={0}{1,choice,1#目錄|2#目錄}
action.name.checkin.file={0}{1,choice,1#檔案|2#檔案}
action.name.compare=比較
action.name.create.patch=建立補丁…
action.name.for.file.get.version={0}: 獲取版本 {1}
action.name.get.file.content.from.repository=從修訂中獲取
action.name.group.by.packages=按軟體套件分組
action.name.integrate=合併 (_G)
action.name.integrate.scope=合併 {0}(_G)
action.name.refresh=重新整理
action.name.refresh.compare.with.local.panel=重新整理
action.name.show.difference=顯示差異
action.name.show.files.as.tree=作為樹顯示
action.name.show.history.for.class=類別
action.name.show.history.for.code.block=程式碼塊
action.name.show.history.for.field=欄位
action.name.show.history.for.function=函式
action.name.show.history.for.method=方法
action.name.show.history.for.selection=選區
action.name.show.history.for.statement=語句
action.name.update=更新(_U)
action.name.update.scope=更新{0}(_U)
action.presentation.ApplySelectedChangesAction.text=接受
action.presentation.DiffShelvedChangesWithLocalActionProvider.description=將擱置版本與當前版本進行比較
action.presentation.IgnoreSelectedChangesAction.text=忽略
action.presentation.ShowUpdatedDiffActionProvider.description=更新前顯示與版本的差異
action.vcs.log.show.separator=顯示
acton.name.get.revision=獲取修訂
add.issue.dialog.invalid.regular.expression=無效的正則表達式: {0}
add.issue.dialog.issue.example.border.title=範例
add.issue.dialog.issue.id.label=問題 ID:
add.issue.dialog.issue.id.regular.expression=問題 ID (正則表達式):
add.issue.dialog.issue.link.label=問題鏈接:
add.issue.dialog.issue.link.replacement.expression=問題鏈接 (取代表達式):
add.issue.dialog.issue.no.match=<無符合>
advanced.setting.vcs.annotations.preload=在編輯器中開啟檔案時載入 VCS 中的檔案註解
advanced.setting.vcs.annotations.preload.description=這樣就可以更快速地按需顯示。
advanced.setting.vcs.commit.tool.window=啟用“提交”工具視窗
advanced.setting.vcs.commit.tool.window.description=在單獨的“提交”工具視窗中顯示“本地更改”和“擱置”頁籤
advanced.setting.vcs.non.modal.commit.toggle.ui=切換提交控件
advanced.setting.vcs.non.modal.commit.toggle.ui.description=執行提交後隱藏提交面板和複選框，並允許在“本地更改”中切換提交 UI
advanced.setting.vcs.process.ignored=醒目提示忽略的檔案
advanced.setting.vcs.process.ignored.description=請求 VCS 中被忽略檔案的列表，並在 IDE 中顯示這些檔案的狀態
advanced.setting.vcs.push.all.with.commits=選擇包含要推送的新提交的所有版本庫
advanced.setting.vcs.push.all.with.commits.description=預設預先選擇包含要推送的提交的所有版本庫
advanced.settings.vcs=版本控制
amend.action.name=修正{0}
amend.commit.different.committer.warning=修正後提交的提交者與預設設定不同
amend.commit.load.details.task.title=正在載入提交詳細資訊
amend.commit.load.message.error.text=無法載入待修正提交的提交訊息。
amend.commit.load.message.error.title=提交訊息未載入
amend.commit.load.message.task.title=正在載入提交訊息
annotate.action.description=註解檔案
annotate.action.name=註解
annotate.action.view.group.text=檢視
annotation.background=註解背景
annotation.commit.number=提交編號
annotation.original.revision.text=修訂: {0}
annotation.switch.to.merged.text=顯示合併原始碼
annotation.switch.to.original.text=隱藏合併原始碼
annotation.wrong.line.number.notification.text=<html>由 {0} 註解的行數與檔案中的行數不相等。請檢查檔案編碼和行分隔符。</html>
annotations.color.mode.author=作者
annotations.color.mode.group.colors=顏色
annotations.color.mode.hide=隱藏
annotations.color.mode.order=順序
annotations.short.name.type.email=電子郵件
annotations.short.name.type.first.name=名字
annotations.short.name.type.full.name=全名
annotations.short.name.type.group.names=姓名
annotations.short.name.type.initials=初始
annotations.short.name.type.last.name=姓氏
before.checkin.cleanup.code=清理(&L)
before.checkin.cleanup.code.profile=使用 ''{0}'' 組態檔案清理(&L)
before.checkin.error.unknown=無法檢查提交
before.checkin.error.unknown.details=無法檢查提交: {0}
before.checkin.error.unresolved.merge.conflicts=檔案有未解決的衝突
before.checkin.new.todo.check=檢查 TODO ({0})
before.checkin.new.todo.check.no.filter=檢查 TODO
before.checkin.options.check.smells.choose.profile=選擇組態檔案
before.checkin.options.check.smells.profile=使用 ''{0}'' 組態檔案分析程式碼(&A)
before.checkin.post.commit.error.dumb.mode=現在無法進行程式碼分析
before.checkin.standard.options.check.smells=分析程式碼(&A)
before.checkin.waiting.for.smart.mode=正在等待智能模式…
before.commit.file.contains.code.smells.edit.them.confirm.text=檔案 {0} 有問題。\\n\\
{1,choice, 0#無錯誤|1#1 個錯誤|2#{1} 個錯誤}和{2,choice, 0#無警告|1#1 個警告|2#{2} 個警告}。\\n\\
要檢視它們嗎?
before.commit.files.contain.code.smells.edit.them.confirm.text={0} 個檔案有問題。\\n\\
{1,choice, 0#無錯誤|1#1 個錯誤|2#{1} 個錯誤}，{2,choice, 0#無警告|1#1 個警告|2#{2} 個警告} \\n\\
要檢視它們嗎?
border.changes.filter.change.number.filter=更改
border.changes.filter.date.filter=日期
border.selected.revision.commit.message=提交訊息
border.standard.after.checkin.options.group=在{0}之後
border.standard.checkin.options.group=在{0}之前
border.standard.checkin.options.group.with.post.commit={0} 檢查
browse.changes.action=瀏覽更改
browse.changes.content.title={0}下的更改
browse.changes.error.message=存取 VCS 時發生問題: {0}
browse.changes.error.title=無法顯示更改
browse.changes.filter.title=指定搜尋條件
browse.changes.no.filter.prompt=尚未指定任何篩選條件。確定要檢視專案的整個歷史記錄嗎?
browse.changes.nothing.found=未找到與條件符合的任何更改
browse.changes.nothing.found.title=未找到任何更改
browse.changes.progress.title=正在搜尋更改
browse.changes.scope=影響 {0} 的更改
browse.changes.show.all.button=顯示所有更改
browse.changes.show.recent.button=顯示最近的更改
browse.changes.title=瀏覽更改
button.apply.patch=套用補丁
button.clear=清除
button.remove=移除
button.search.again=再次搜尋
button.skip=跳過
button.text.overwrite.modified.file=覆蓋已修改的檔案(&O)
button.text.overwrite.modified.files=覆蓋已修改的檔案(&O)
button.tooltip.remove.commit.author.date=移除
cache.settings.dialog.title=VCS 歷史記錄快取設定
cannot.apply.file.already.exists=無法將補丁套用到檔案 {0}: 它已存在。
cannot.create.directory.for.patch=不能建立檔案: {0}。{1}
cannot.find.file.to.patch=找不到要套用補丁的檔案: {0}
change.dialog.title.change.list.name={0} [{1}]
change.dialog.title.in.change.list.name={1} 中的 {0}
change.file.copied.from.text=- 已從 {0} 複製
change.file.moved.from.text=- 已從 {0} 移動
change.file.moved.to.text=- 已移至 {0}
change.file.renamed.from.text=- 已從 {0} 重新命名
change.file.renamed.to.text=- 已重命名為 {0}
change.file.replaced.text=- 已取代
change.list.manager.wait.lists.synchronization.background={1, choice, 0#正在等待 |1#{0}: }本地更改重新整理
change.list.manager.wait.lists.synchronization.modal={1, choice, 0#正在等待 |1#{0}: }本地更改重新整理
change.list.scope.provider.local.changes=本地更改
change.list.scope.provider.only.changes=所有檔案中僅未提交到 VCS 的更改
change.list.scope.provider.only.changes.in.file=檔案 {0} 中僅未提交到 VCS 的更改
change.lists.manager.add.unversioned=新增未進行版本管理的檔案
change.nodetitle.change.is.outdated=檔案在伺服器上已被更改
change.shelves.location.dialog.action.button=更改位置
change.shelves.location.dialog.custom.label=自訂目錄(&U):
change.shelves.location.dialog.default.label=預設目錄:
change.shelves.location.dialog.group.title=將擱置存儲於:
change.shelves.location.dialog.location.browser.title=選擇要將擱置存儲在其中的目錄
change.shelves.location.dialog.title=更改擱置位置
changelist.details.committed.format=由 {0} {1} 提交
changelist.details.title=更改列表詳細資訊
changes.ExcludeChangedLinesFromCommit.chunks.action.text=從提交中排除所選塊
changes.IncludeChangedLinesIntoCommit.chunks.action.text=將所選塊包含到提交中
changes.action.include.in.operation.name=包含在 {0} 中(&I)
changes.action.rollback.custom.title={0}更改
changes.action.rollback.text=回滾
changes.action.rollback.title={0}更改
changes.action.show.ignored.description=顯示忽略的檔案
changes.action.show.ignored.text=已忽略的檔案
changes.another.change.list=另一個
changes.browse=瀏覽
changes.browser.details.marker=更多…
changes.button.newer=較新的 >
changes.button.older=< 較舊的
changes.can.not.find.patch.for.path.in.patch.file=在補丁檔案中找不到 {0} 的補丁。
changes.cant.load.changes=無法載入更改
changes.change.list.conflict.dialog.radio.button.ignore=忽略(&I)
changes.change.list.conflict.dialog.radio.button.shelve.changes=擱置更改(&S)
changes.changelists.to.cache.initially=最初要快取的更改列表:
changes.checkbox.delete.locally.added.files=刪除新增的檔案的本地副本(&D)
changes.checking.configuration.0.for.ignore=正在為忽略物件檢查組態 {0}…
changes.combined.diff=組合更改差異
changes.committed.changes=已提交更改
changes.configure=組態(&C)…
changes.days.of.history.to.cache.initially=最初要快取的歷史記錄的天數:
changes.default.change.list=預設
changes.default.changelist.name=更改
changes.default.changelist.name.old=預設更改列表
changes.deleting.added.files.locally=正在本地刪除已新增檔案…
changes.dialog.editchangelist.error.already.exists=名為 ''{0}'' 的更改列表已存在
changes.dialog.editchangelist.title=編輯更改列表
changes.dialog.message.failed.to.revert.apply.changes=無法{0, choice, 0#還原|1#套用}更改: 
changes.dialog.newchangelist.title=新增更改列表
changes.diff.separator=差異
changes.directory.does.not.belong.to.the.active.changelist={0, choice, 1#這一目錄|2#這些目錄}不屬於活動更改列表:
changes.do.cleanup=進行清理…
changes.editor.diff.preview.empty.title=更改
changes.editor.diff.preview.title=更改: {0}
changes.empty.changelists.no.longer.active={0,choice,1#空更改列表 ''''{1}'''' 已|2#空更改列表 '<br/>'{1} 已}不再活動。<br/>是否要將{0, choice,1#其|2#其}移除?
changes.error.can.t.get.revision.content=無法獲取修訂內容
changes.error.can.t.show.diff.for=無法顯示 ''{0}'' 的差異
changes.error.can.t.show.diff.for.binary.file=無法顯示二進制檔案 ''{0}'' 的差異
changes.error.cannot.find.base.for.path=找不到 ''{0}'' 的基
changes.error.content.for.0.was.removed=''{0}'' 的內容已被移除
changes.error.default.project.not.supported=不支持預設專案
changes.error.failed.to.create.content.for.current.revision=無法為當前修訂建立內容
changes.error.failed.to.fetch.current.revision=無法獲取當前修訂
changes.error.refreshing.vcs.history=重新整理 VCS 歷史記錄時出錯
changes.error.refreshing.view=重新整理檢視時出錯: {0}
changes.error.shelving.changes.failed=擱置更改失敗: {0}
changes.file.does.not.belong.to.the.active.changelist={0, choice, 1#這一檔案|2#這些檔案}不屬於活動更改列表:
changes.file.from.non.active.changelist.is.modified=停用更改列表中的檔案已修改
changes.finishing.changed.on.server.update=正在完成“在伺服器上被更改”更新
changes.hide.this.notification=隱藏此通知
changes.ignore.file=忽略檔案
changes.impossible.until.indices.are.up.to.date=在索引更新前不可行
changes.locked.by=被 {0} 鎖定
changes.minutes=分鐘
changes.move.changes.to.active.change.list.name=將更改移至活動更改列表({0})
changes.move.to.changelist=移至 ''{0}'' 更改列表
changes.new.changelist=新增更改列表
changes.no.incoming.changelists.available=無可用傳入更改列表
changes.no.tracking.branch=無追蹤分支
changes.no.tracking.branch.suffix=\\ (無追蹤分支)
changes.nodetitle.changecount={0,choice, 0#無檔案|1#1 個檔案|2#{0} 個檔案}
changes.nodetitle.directory.changecount={0,choice, 0#無目錄|1#1 個目錄|2#{0} 個目錄}
changes.nodetitle.directory.file.changecount={0,choice, 0#無目錄|1#1 個目錄|2#{0} 個目錄}，{1,choice, 0#無檔案|1#1 個檔案|2#{1} 個檔案}
changes.nodetitle.empty.changelist.name=<空名稱>
changes.nodetitle.filter.pending=未篩選
changes.nodetitle.filtered.out=已篩選
changes.nodetitle.have.outdated.files=某些檔案在伺服器上已被更改
changes.nodetitle.ignored.files=已忽略的檔案
changes.nodetitle.locally.deleted.files=本地已刪除的檔案
changes.nodetitle.locked.folders=鎖定的工作副本目錄
changes.nodetitle.locked.folders.tooltip=某些目錄已被鎖定；不允許對它們進行 VCS 動作。應執行清理。
changes.nodetitle.logicallt.locked.folders=明確鎖定的檔案
changes.nodetitle.merge.conflicts=合併衝突
changes.nodetitle.merge.conflicts.resolve.link.label=解決
changes.nodetitle.modified.without.editing=已修改，但未簽出的檔案
changes.nodetitle.switched.files=已切換的檔案
changes.nodetitle.switched.roots=根開關
changes.nodetitle.unversioned.files=未進行版本管理的檔案
changes.nodetitle.updating=正在更新…
changes.none=<無>
changes.notification.content.repository.location.not.found.for=找不到 {0} 的版本庫位置
changes.please.enter.a.valid.regex=請輸入有效正則表達式
changes.progress.text.vcs.name.performing.operation.name={0}: 正在執行 {1}…
changes.progress.title.choice.revert.apply.changes={0, choice, 0#還原|1#套用}更改
changes.project.exclude.paths=專案排除路徑
changes.refresh.changelists.after.update=更新後重新整理更改列表
changes.refresh.changes.every=更改重新整理間隔
changes.remove.active.empty.prompt=選擇要設為活動的更改列表:
changes.remove.active.prompt=選擇應將更改移至其中的更改列表:
changes.remove.active.title=刪除活動更改列表
changes.removechangelist.all.lists.warning.text=確定要移除{0}個更改列表嗎?\\n\\
所有更改都將移至新的預設更改列表。
changes.removechangelist.multiple.warning.text=確定要刪除{0}個更改列表?\\n\\
所有的更改將會移至活動的更改列表中。
changes.removechangelist.warning.text=確定要移除更改列表 ''{0}'' 嗎?\\n\\
所有更改都將移至活動更改列表。
changes.removechangelist.warning.title=刪除更改列表
changes.removing.configuration.0.from.ignore=正在從忽略物件中移除組態 {0}…
changes.revert.apply.change.list.name={0, choice, 0#還原: |1#套用: }{1}
changes.set.active.changelist.to.change.list.name=將活動更改列表設定為 ''{0}''
changes.switched.to.branch.name=已切換到 {0}
changes.tab.title.vcs.errors=VCS 錯誤
changes.text.default.ignored.files=預設忽略的檔案
changes.title.loading.changes=正在載入更改
changes.tried.to.save.uncommitted.changes.in.shelve.before.s.but.failed.with.an.error=嘗試在{0}之前擱置未提交的更改，但因為錯誤而失敗。<br/>{1}
changes.warning.not.all.local.changes.may.be.shown.due.to.an.error=警告: 由於錯誤，可能不會顯示所有本地更改: {0}
checkbox.amend=修正(_M)
checkbox.checkin.options.optimize.imports=最佳化 import(&O)
checkbox.checkin.options.rearrange.code=重新整理程式碼(&N)
checkbox.checkin.options.reformat.code=格式化程式碼(&R)
checkbox.clear.initial.commit.message=清除初始提交訊息(&I)
checkbox.include=包含(&I)
checkbox.include.issues.not.assigned.to.me=包括未分配給我的問題
checkbox.including.files.created.outside.ide=應用於在 {0} 外部建立的檔案
checkbox.remember.my.choice=記住我的選擇(&R)
checkbox.select.current.file.only=僅選擇當前檔案(&C)
checkbox.show.changed.revisions.only=僅更改
checkbox.show.changes.after.date=之後(&A)
checkbox.show.changes.after.num=從(&F)
checkbox.show.changes.before.date=之前(&B)
checkbox.show.changes.before.num=到(&T):
checkbox.show.clear.read.only.status.dialog=如果嘗試編輯唯讀檔案，則提示將其解鎖
checkbox.show.dirty.recursively=在專案樹中醒目提示包含已修改檔案的目錄
checkin.can.not.load.current.revision=無法載入當前修訂
checkin.can.not.load.previous.revision=無法載入之前的修訂
checkin.commit.checks.failed=提交檢查失敗
checkin.commit.checks.failed.cancel.button=取消(&N)
checkin.dialog.title.todo=TODO
checkin.filter.filter.name=篩選器: {0}
checkin.invalid.file.s=無效檔案
checkin.title.for.commit.0=以供提交 ({0})
checkin.unresolved.merge.are.you.sure.you.want.to.commit.changes.with.unresolved.conflicts=確定要提交有未解決衝突的更改嗎?
checkin.unresolved.merge.unresolved.conflicts=未解決的衝突
checkin.wait=等待(&W)
checking.code.smells.progress.title=正在執行程式碼分析
checking.recent.changes=正在檢查最近的更改…
checking.vcs.status.progress=正在檢查 VCS 狀態…
clone.dialog.clone.button=克隆
clone.dialog.clone.failed.error=克隆失敗
clone.dialog.repository.url.item=版本庫 URL
clone.dialog.unable.create.destination.error=無法建立目標目錄
code.smells.error.messages.tab.name=程式碼分析
code.smells.review.button=檢查程式碼分析(&R)
column.info.configure.vcses.directory=目錄
column.name.configure.vcses.vcs=VCS
column.name.revision.date=日期
column.name.revision.list.author=作者
column.name.revision.list.committer=使用者
column.name.revision.list.date=日期
column.name.revision.list.description=描述
column.name.revision.list.number=數字
column.name.revision.list.revision=修訂
column.name.revision.version=版本
column.name.revisions.list.branch=分支
column.name.revisions.list.filter=日期
command.name.open.error.message.view=開啟訊息檢視
commit.amend.commit=修正提交
commit.changes=提交更改
commit.checks.error.indexing=現在無法進行程式碼分析
commit.checks.error.indexing.message=當 {0} 在背景更新索引時，無法執行提交檢查。\\n\\
您可以在不執行檢查的情況下提交更改，也可以等到索引建立後再提交。
commit.checks.failed.notification.commit.anyway.action=仍然{0}
commit.checks.failed.notification.show.details.action=顯示詳細資訊
commit.checks.failed.notification.title={0} 檢查失敗
commit.checks.on.commit.progress.text=正在提交…
commit.checks.on.commit.progress.text.with.context=正在提交: {0}
commit.checks.only.progress.text=正在執行提交檢查…
commit.checks.only.progress.text.with.context=正在執行提交檢查: {0}
commit.description.tooltip.author=作者: {0}
commit.description.tooltip.commit=提交 {0}
commit.description.tooltip.date=日期: {0}
commit.description.tooltip.path=路徑: {0}
commit.dialog.changelist.label=更改列表(&T):
commit.dialog.configurable=提交
commit.dialog.default.commit.operation.name=Comm&it
commit.dialog.include.action.name=包含到提交裡(&I)
commit.dialog.no.changes.detected.text=未檢測到更改
commit.dialog.no.changes.detected.title=沒有要提交的內容
commit.dialog.partial.commit.warning.body=不支持 ''{0}'' 的部分提交。\\n\\
所選檔案中的所有更改都將提交。
commit.dialog.partial.commit.warning.title=不支持部分提交
commit.dialog.refresh.files=正在同步檔案…
commit.dialog.title=提交更改
commit.editor.diff.preview.empty.title=提交
commit.editor.diff.preview.title=提交: {0}
commit.legend.deleted=已刪除
commit.legend.modified=已修改
commit.legend.new=已新增
commit.message=提交訊息
commit.message.inspection.message.body.lines.should.not.exceed.characters=正文行不能超過 {0} 個字元
commit.message.inspection.message.subject.should.not.exceed.characters=主題不能超過 {0} 個字元
commit.message.intention.family.name.reformat.commit.message=重新格式化提交訊息
commit.message.intention.family.name.wrap.line=換行
commit.message.missing.blank.line.between.subject.and.body=主題與正文之間缺少空行
commit.message.placeholder=提交訊息
commit.progress.title=提交
commit.tooltip.merge.this.commit.with.the.previous.one=將此提交與前一個提交合併
commit.wait.util.synched.text=正在執行 VCS 重新整理…
committed.changes.empty.comment=<無註釋>
committed.changes.empty.message=版本庫沒有提交的更改
committed.changes.filter.all=所有
committed.changes.filter.none=<無>
committed.changes.filter.title=篩選依據
committed.changes.group.title=分組依據
committed.changes.incorrect.regex.message=篩選器中使用的正則表達式無效
committed.changes.not.loaded.message=按“重新整理”按鈕以載入版本庫更改
committed.changes.partial.list=[部分]
committed.changes.refresh.progress=正在重新整理 VCS 歷史記錄
committed.changes.regex.title=正則表達式(&G)
committed.changes.tab=版本庫
compare.with.dialog.get.from.vcs.action.title=從 VCS 獲取
composite.change.provider.include.vcs.checkbox=包含{0}中的更改
configurable.ChangelistConflictConfigurable.display.name=更改列表
configurable.IssueNavigationConfigurationPanel.display.name=問題導覽
configurable.VcsContentAnnotationConfigurable.display.name=顯示最近更改
configurable.VcsDirectoryConfigurationPanel.display.name=目錄映射
configurable.VcsGeneralConfigurationConfigurable.display.name=確認
configurable.issue.link.edit=編輯
configurable.issue.link.remove=移除
configurable.shelf.storage.cant.find.or.create.new.shelf.directory=找不到或建立新的擱置目錄
configurable.shelf.storage.destination.shelf.directory.should.have.read.access=目標擱置目錄必須具備讀取權限
configurable.shelf.storage.destination.shelf.directory.should.have.write.access=目標擱置目錄必須具備寫入權限
configurable.vcs.manage.scopes=管理作用域
confirmation.message.add.ignored.single.directory=新增忽略的目錄?
confirmation.message.add.ignored.single.file=新增忽略的檔案?
confirmation.title.add.file.to=將檔案新增到 {0}?
confirmation.title.add.files.to=將檔案新增到 {0}?
confirmation.title.add.ignored.files.or.dirs=確認新增忽略檔案和目錄
confirmation.title.add.ignored.single.directory=確認新增忽略的目錄
confirmation.title.add.ignored.single.file=確認新增忽略的檔案
copy.revision.number.action=複製修訂號
create.patch.commit.action.progress=正在建立補丁…
create.patch.commit.action.title=建立補丁
create.patch.encoding=編碼(&E):
create.patch.error.title=建立補丁時出錯: {0}
create.patch.file.path=到檔案(&P):
create.patch.loading.content.progress=正在載入內容修訂
create.patch.reverse.checkbox=反轉補丁(&R)
create.patch.settings.dialog.title=補丁檔案設定
create.patch.success.confirmation=已成功建立補丁 {0}
create.patch.to.clipboard=到剪貼簿(&C)
current.version.text={4}<br/><br/>當前版本為 {3}。<br/>修改者為 {0}<br/>{1}<br/>{2}
date.group.last.week=過去一周
date.group.title=日期
date.group.today=今天
description.text.option.applicable.to.vcses=適用於 {0}
dialog.enable.version.control.integration.hint.text=可在以下位置組態版本控制設定 
dialog.enable.version.control.integration.select.vcs.label.text=選擇要與{0}關聯的版本控制系統:
dialog.enable.version.control.integration.title=啟用版本控制整合
dialog.message.can.t.create.text.editor.for=無法為 {0} 建立文本編輯器
dialog.message.conflict.seems.to.be.resolved=衝突似乎已解決
dialog.message.enter.directory.name=為建立的專案輸入目錄名稱。留空可直接簽出到“{0}”。
dialog.message.no.changes.for.this.file=此檔案沒有更改
dialog.title.cannot.convert.module=無法轉換模組
dialog.title.changes.browser=更改瀏覽器
dialog.title.files.created=檔案已建立
dialog.title.ignored.files=已忽略的檔案
dialog.title.message=訊息
dialog.title.move.changes.to.active.changelist=將更改移至活動更改列表
dialog.title.no.conflict.found=未找到衝突
dialog.title.project.directory.name=專案目錄名稱
dialog.title.remove.empty.changelist=移除空更改列表
dialog.title.resolve.changelist.conflict=解決更改列表衝突
dialog.title.select.destination.folder=選擇目標目錄
dialog.title.unversioned.files=未進行版本管理的檔案
diff.content.title.revision.number=修訂 {0}
diff.producer.error.cant.get.revision.content=無法獲取修訂內容
diff.title.local=本地
diff.title.local.with.number=本地({0})
directory.mapping.add.title=新增 VCS 目錄映射
directory.mapping.remove.title=編輯 VCS 目錄映射
edit.changelist.description=註釋(&C):
edit.changelist.name=名稱(&N):
edit.errors=編輯錯誤
edit.source.action.text=編輯源
error.adding.files.notification.title=無法新增檔案
error.adding.files.prompt=新增檔案時發生以下問題:
error.adding.files.title=無法新增檔案
error.cant.perform.operation.now=現在無法{0}
error.change.from.must.be.a.valid.number=起始日期必須是有效數字
error.change.to.must.be.a.valid.number=更改物件必須是有效數字
error.date.after.must.be.a.valid.date=之後的日期必須是有效日期
error.date.before.must.be.a.valid.date=之前的日期必須是有效日期
error.executing.commit=執行 ''{0}'' 時出錯: {1}
error.no.changes.no.commit.message=選擇要提交的檔案並指定提交訊息
error.no.changes.to.commit=選擇要提交的檔案
error.no.commit.message=指定提交訊息
error.text.check.in.with.empty.comment=請指定註釋
error.title.check.in.with.empty.comment=註釋為空
error.updating.changes=更新更改時出錯: {0}
ex.changelists=更改列表
ex.move.lines.to.another.changelist.0=將行移至另一個更改列表({0})
ex.new.changelist=新增更改列表…
exception.text.internal.error.method.should.not.be.called=不應呼叫
exception.text.internal.errror.could.not.implement.method=無法實作
exception.text.unknown.error=未知錯誤
executable.project.override=僅為當前專案設定此路徑
executable.project.override.reset.globalize=設為全域
executable.project.override.reset.message=為此專案組態的可執行檔案路徑既可以設為所有專案的全域路徑，也可以還原為當前全域可執行檔案
executable.project.override.reset.revert=還原
executable.project.override.reset.title=專案可執行檔案
executable.select.label={0} 可執行檔案路徑(&P):
executable.select.title=選擇可執行檔案
executable.test=測試
external.files.add.notification.action.add=始終新增
external.files.add.notification.action.mute=不再詢問
external.files.add.notification.action.view=檢視檔案
external.files.add.notification.message=外部新增的檔案可以新增到 {0}
external.files.add.view.dialog.title=將檔案新增到 {0}
file.content.too.big.to.load.increase.property.suggestion=無法顯示 ''{0}'' 的內容。\\n\\
該檔案大小大於 {1}。\\n\\
\\n\\
您可以通過在 ''idea.properties'' 檔案中增大{2}屬性來覆寫此限制。
file.history.checking.last.revision.process=正在檢查最新修訂
file.history.details.committer.info=由 {0} 提交
file.history.details.committer.tooltip.info=通過 {0}
file.history.details.empty.status=提交訊息
file.history.details.hash.author.on.date.at.time={0} {1}，{2} {3}
file.history.diff.handler.affected.changes.title={1} 中的初始提交 {0}
file.history.diff.handler.collecting.affected.process=正在收集受影響的更改…
file.history.diff.handler.comparing.process=正在比較修訂…
file.history.diff.handler.paths.diff.title={0} 與 {2} 中的 {1} 之間的差異
file.history.diff.handler.paths.diff.with.local.title={0} 與 {1} 中的本地版本之間的差異
file.history.diff.handler.process.error=任務期間出錯: {0}
file.history.diff.revisions.process=正在比較修訂…
file.history.exceeded.limit.message=檔案歷史記錄: 僅為 {1} 載入了 {0} 個修訂\\n\\
要更改歷史記錄限制，請轉到 {2}
file.history.tab.name=歷史記錄
filetype.patch.description=補丁
filetype.patch.display.name=補丁
filter.none.name=無
filter.structure.name=結構
get.from.vcs.extension.list.accessible.name=版本庫位置
get.from.version.control=從版本控制獲取
group.mainmenu.vcs.current.file.text=當前檔案
group.name.version.control=VCS(&V)
handle.ro.file.status.type.using.vcs=使用 {0}
hide.this.notification=隱藏此通知
history.dialog.title.difference.between.versions.in={2} 中的 {0} 和 {1} 版本的差異
history.empty=歷史記錄為空
history.failed.to.load.content.for.revision.0=無法為修訂 {0} 載入內容
history.file.not.found=找不到檔案 {0}
history.loading.revisions=正在載入受影響的修訂
history.tab.title.can.not.load.changelist.contents=無法載入更改列表內容
ignore.codeInspection.duplicateEntry=忽略檔案重複項
ignore.codeInspection.duplicateEntry.message=<code>#ref</code> 模式不止定義一次 #loc
ignore.codeInspection.group=版本控制
ignore.quick.fix.remove.entry=移除模式
ignore.to.exclude.no.directories.found=未找到要排除的目錄
ignore.to.exclude.notification.action.details=了解更多
ignore.to.exclude.notification.action.mute=不再顯示
ignore.to.exclude.notification.action.view=檢視目錄
ignore.to.exclude.notification.message=部分忽略的目錄未從索引和搜尋中排除
ignore.to.exclude.notification.notice=<html><b>註</b>: 建議在排除之前重新檢查目錄內容。一些目錄可能包含不應排除的項。</html>
ignore.to.exclude.view.dialog.exclude.action=排除(&E)
ignore.to.exclude.view.dialog.title=排除目錄
ignoreTokenType./=<斜杠>
ignoreTokenType.BRACKET_LEFT=<左括號>
ignoreTokenType.BRACKET_RIGHT=<右括號>
ignoreTokenType.COMMENT=<註釋>
ignoreTokenType.CRLF=<空行>
ignoreTokenType.HEADER=<標頭>
ignoreTokenType.SECTION=<部分>
ignoreTokenType.VALUE=<值>
ignoreTokenType.syntax:=<語法>
ignored.file.excluded.settings.title=排除目錄管理策略
ignored.file.excluded.to.ignored.label=將排除目錄新增到忽略檔案
ignored.file.general.settings.title=一般設定
ignored.file.ignored.to.excluded.label=將忽略目錄標記為已排除
ignored.file.manage.all.project=在所有專案中
ignored.file.manage.all.projects.option=為所有專案管理
ignored.file.manage.always.ask.option=始終詢問
ignored.file.manage.message={0} 可以自動將經常被忽略的檔案新增到 {1}。
ignored.file.manage.notmanage=不新增
ignored.file.manage.policy.label=忽略檔案管理策略:
ignored.file.manage.this.project=在此專案中
ignored.file.manage.this.project.option=僅為此專案管理
ignored.file.manage.view=檢視
ignored.file.manage.view.dialog.ignore.action=忽略(&I)
ignored.file.manage.view.dialog.title=將檔案新增到忽略
ignored.file.manage.with.files.message={0} 可以自動將經常被忽略的檔案新增到 {1}。
ignored.file.not.manage.option=關閉套用範圍
ignored.file.not.manage.this.project.option=不只為此專案管理
ignored.file.tab.title=已忽略的檔案
ignoring.files.progress.title=正在忽略檔案…
impl.notification.content.could.not.find.plugin=找不到延伸模組 {0}
impl.notification.content.plugin.was.unbundled.needs.to.be.installed.manually={0} 延伸模組已解除捆綁，需要手動安裝
impl.notification.content.vcs.plugin.not.found.for.mapping.to=沒有為 ''{0}'' 的映射找到 VCS 延伸模組
impl.notification.title.failed.to.install.plugin=安裝延伸模組失敗
impl.progress.title.installing.plugin=正在安裝延伸模組…
impl.show.all.affected.files.for.path.at.revision.failed=為 {0} 顯示 {1} 失敗時所有受影響的檔案
impl.vcs.initialization=VCS 初始化
import.patches=匯入補丁
import.patches.into.shelf=將補丁匯入到擱置…
incoming.changes.empty.message=沒有傳入的更改
incoming.changes.indicator.name=傳入更改
incoming.changes.indicator.tooltip={0} 個可用的傳入更改列表
incoming.changes.not.loaded.message=按“重新整理”按鈕以載入傳入的更改
incoming.changes.tab=傳入
inlay.vcs.code.author.description=根據 VCS 中的記錄獲得的程式碼作者。<br><br>作者是最後編輯類別、方法或函式的人。如果有來自不同作者的多個提交，擁有最多行的那個會被視為作者。
inspection.BodyLimitInspection.display.name=限制正文行
inspection.CommitMessageSpellCheckingInspection.display.name=拼寫
inspection.SubjectBodySeparationInspection.display.name=主題與正文之間的空白行
inspection.SubjectLimitInspection.display.name=限制主題行
issue.action.add.jira.issue.navigation.pattern.title=新增 JIRA 問題導覽模式
issue.action.add.youtrack.issue.navigation.pattern.title=新增 YouTrack 問題導覽模式
issue.action.enter.jira.installation.url.label=輸入 JIRA 安裝 URL:
issue.action.enter.youtrack.installation.url.label=輸入 YouTrack 安裝 URL:
issue.link.add.title=新增問題導覽鏈接
issue.link.delete.prompt=刪除所選導覽鏈接?
issue.link.delete.title=刪除問題導覽鏈接
issue.link.edit.title=編輯問題導覽鏈接
issue.link.issue.column=問題
issue.link.link.column=鏈接
issue.link.no.patterns=未組態模式
jb.protocol.no.provider=找不到 VCS 提供程序: ''{0}''
label.at.date.leading=在 {0}
label.at.date.middle=在 {0}
label.by.author=作者
label.code.author.inlay.hints=程式碼作者
label.commit.checks.failed.unknown.reason=檢查失敗
label.commit.checks.not.available.during.indexing=編制索引期間無法提交檢查
label.commit.comment=提交訊息(&M)
label.multi.author.modified.code={0} +{1} *
label.multi.author.not.modified.code={0} +{1}
label.new.code=新 *
label.project.vcs.root.mapping=<專案>
label.relative.project.path.presentation=<專案>/{0}
label.select.files.to.be.added.to.version.control=選擇要新增到版本控制中的檔案
label.selected.revision.commit.message=提交訊息
label.single.author.modified.code={0} *
label.todo.items.found={0} 個 TODO
line.annotation.aspect.author=作者
line.annotation.aspect.date=日期
line.annotation.aspect.revision=修訂
link.label.display.anyway=仍然顯示
link.label.hide=隱藏
link.label.ignore=忽略
link.label.move.changes=移動更改
link.label.switch.changelist=切換更改列表
loading.file.history.progress=正在載入檔案歷史記錄
loading.file.history.status=正在載入 {0} 的歷史記錄…
loading.file.history.up.to.revision.status=正在載入 {0} 截至 {1} 的歷史記錄…
loading.text2.file.history.progress=正在載入檔案歷史記錄
local.changes.freeze.message={0}完成之前，本地更改不可用
local.changes.tab=本地更改
local.history.update.from.vcs=從 VCS 更新
local.version.title=本地版本
looking.for.patch.files=正在尋找補丁檔案…
lookup.title.vcs.file.revisions=檔案修訂
lst.inactive.ranges.damaged.notification=部分更改已移至活動更改列表
merge.loading.merge.details=正在載入合併詳細資訊…
message.read.only.status.content=您以 <b>root</b> 身份登入，因此: <br><br>- {0} 無法看到唯讀狀態的檔案。<br>- 所有檔案都被視為可寫入。<br>- 修改時無法自動簽出檔案。
message.read.only.status.title={0}: 無法看到唯讀狀態
message.text.all.files.are.up.to.date=所有檔案都處於最新狀態
message.text.background.tasks=正在等待背景 VCS 任務完成…
message.text.cannot.edit.file=無法編輯檔案: {0}
message.text.cannot.load.revision=無法載入修訂: {0}
message.text.cannot.open.editor=無法開啟檔案 {0} 的文本編輯器
message.text.cannot.save.content=無法儲存內容: {0}
message.text.cannot.save.settings=無法執行動作: {0}
message.text.cannot.show.differences=無法顯示差異: {0}
message.text.commit.failed.with.error=提交失敗，有{0,choice,1#錯誤|2#錯誤}
message.text.commit.finished.with.warning=提交完成，有{0,choice,1#警告|2#警告}
message.text.commit.progress=正在提交…
message.text.could.not.load.virtual.file.content=無法載入檔案 {0} 的內容: {1}
message.text.file.is.up.to.date=檔案處於最新狀態
message.text.file.locally.modified=檔案 {0} 已在本地被修改。
message.text.several.files.locally.modified=某些檔案已在本地被修改。
message.title.annotate=註解
message.title.cannot.open.editor=無法開啟編輯器
message.title.could.not.load.content=無法載入內容
message.title.could.not.load.file.history=載入檔案歷史記錄時發生問題
message.title.edit.files=編輯檔案
message.title.get.revision.content=獲取修訂內容
message.title.get.version=獲取版本
message.title.show.differences=顯示差異
message.title.vcs.update.errors={0}錯誤
move.to.another.changelist.nothing.selected.notification=沒有選擇任何可以移動的專案
move.to.changelist=將更改移至活動更改列表(''{0}'')(&M)
multiple.file.merge.accept.theirs=接受他們的(&T)
multiple.file.merge.accept.yours=接受您的更改(&Y)
multiple.file.merge.column.name=名稱
multiple.file.merge.dialog.command.name.accept.theirs=接受他們的更改
multiple.file.merge.dialog.command.name.accept.yours=接受您的更改
multiple.file.merge.dialog.error.loading.revisions.to.merge=載入待合併修訂時出錯: {0}
multiple.file.merge.dialog.message.error.saving.merged.data=儲存合併資料時出錯: {0}
multiple.file.merge.dialog.message.file.too.big.to.be.loaded=檔案過大，無法載入
multiple.file.merge.dialog.progress.title.loading.revisions=正在載入修訂…
multiple.file.merge.dialog.progress.title.resolving.conflicts=正在解決衝突…
multiple.file.merge.dialog.title.can.t.show.merge.dialog=無法顯示“合併”對話框
multiple.file.merge.group.by.directory.checkbox=按目錄對檔案分組
multiple.file.merge.loading.progress.title=正在載入合併修訂…
multiple.file.merge.merge=合併(&M)…
multiple.file.merge.request.title=合併 {0} 的修訂
multiple.file.merge.title=衝突
new.changelist.duplicate.name.error=具有該名稱的更改列表已存在
new.changelist.empty.name.error=無法使用空名稱建立新的更改列表
new.changelist.make.active.checkbox=設為活動(&A)
new.changelist.new.label=新增
no.ignored.files=沒有忽略的檔案
non.modal.commit.promoter.dont.show.again.action.text=不再顯示
non.modal.commit.promoter.text=新的非強制回應提交介面可用。從工具視窗提交並在編輯器中檢視差異。
non.modal.commit.promoter.use.non.modal.action.text=切換到工具視窗
none.vcs.presentation=<無>
notification.content.didn.t.update.repository.changes=由於發生錯誤，未使用新消息更新版本庫更改: {0}
notification.group.external.executable=VCS 外部可執行檔案驗證失敗
notification.group.vcs.common.messages=VCS 普通訊息
notification.group.vcs.important.messages=VCS 重要訊息
notification.group.vcs.messages=VCS 訊息
notification.group.vcs.notifications=VCS 通知
notification.group.vcs.silent.notifications=VCS 靜默通知
notification.showDetailsInConsole=在主控台中顯示詳細資訊
notification.title.cant.load.annotations=無法載入註解
notification.title.couldn.t.save.uncommitted.changes=無法儲存未提交的更改。
notification.title.vcs.name.repository.repositories.found=已找到 {0} 個{1, choice, 1#版本庫|2#版本庫}
open.repository.version.description=在編輯器中開啟檔案的所選修訂
open.repository.version.text=開啟版本庫版本
operation.name.annotate=註釋
outdated.version.show.diff.action=顯示差異
outdated.version.text=過時的版本。{0} 在 {1} {3,choice,0#修改|1#刪除}了以下訊息: {2}
outdated.version.update.project.action=更新專案
patch.apply.abort.action=中止…
patch.apply.abort.and.rollback.action=中止並回滾(_A)
patch.apply.abort.and.rollback.prompt=中止並回滾套用補丁還是跳過此檔案?
patch.apply.abort.title=中止補丁
patch.apply.aborted.message=“套用補丁”動作期間更改的所有檔案已被回滾
patch.apply.aborted.title=套用補丁中止
patch.apply.added.status=已新增
patch.apply.after.patch.label.text=補丁後
patch.apply.already.applied=指定補丁的所有更改均已包含在程式碼中
patch.apply.already.applied.status=已套用
patch.apply.already.exists.overwrite.prompt=檔案 {0} ({1})已存在。\\n\\
是否要覆蓋它?
patch.apply.analyze.from.clipboard.on.the.fly.checkbox=動態分析和套用剪貼簿中的補丁
patch.apply.automatically.applied.status=已自動套用
patch.apply.bad.diff.title=補丁套用的結果
patch.apply.bad.diff.to.title=將補丁應用於 {0} 的結果
patch.apply.before.patch.label.text=補丁前
patch.apply.can.not.apply.additional.info.error=無法套用附加補丁資訊: {0}
patch.apply.can.t.find.patch.file.warning=找不到補丁檔案 {0}
patch.apply.cannot.apply.now=現在無法套用補丁
patch.apply.cannot.read.patch=無法讀取補丁 {0}: {1}
patch.apply.change.directory.paths.group=更改目錄路徑
patch.apply.changes.in.patch.resolve=在補丁解析中{0}
patch.apply.command=套用補丁
patch.apply.conflict.for.title={0}的補丁衝突
patch.apply.conflict.local.version=本地版本
patch.apply.conflict.merged.version=合併結果
patch.apply.conflict.patch=補丁
patch.apply.conflict.patched.somehow.version=結果
patch.apply.conflict.patched.version=補丁版本
patch.apply.conflict.title=補丁衝突
patch.apply.continue.resolve.action=繼續解析
patch.apply.deleted.status=已刪除
patch.apply.dialog.title=套用補丁
patch.apply.display.local.content.was.modified.error=無法顯示補丁套用者 - 本地內容已修改
patch.apply.error.conflict=套用補丁衝突
patch.apply.error.document.not.found=找不到文檔 {0}
patch.apply.error.file.not.found=找不到檔案 {0}
patch.apply.file.name.field=補丁檔名(&P):
patch.apply.file.type.binary.error=無法從補丁套用 {0} 檔案，因為它是二進制檔案。
patch.apply.file.type.directory.error=無法從補丁套用 {0} 檔案的內容，因為它是目錄。
patch.apply.file.type.undefined.error=無法從補丁套用 {0} 檔案的內容，因為它的類型未定義。
patch.apply.hunk.warning=無法檢測到下列項的區塊修改行: -{0},{1} +{2},{3}
patch.apply.incorrectly.processed.warning=VCS 可能未正確處理以下{0, choice, 1#檔案|2#檔案}。\\n\\
請手動檢查{0, choice, 1#它|2#它們}: {1}
patch.apply.map.base.directory.action=映射基目錄…
patch.apply.marker.renderer=標記: {0}
patch.apply.missing.base.file.label=缺少基
patch.apply.modified.status=已修改
patch.apply.new.base.detected.node.description=檢測到新基
patch.apply.new.files.warning=套用補丁建立新檔案報錯
patch.apply.not.applied.status=未套用
patch.apply.not.patch.type.file.error=所選檔案 {0} 不是補丁類型檔案
patch.apply.notification.title=套用補丁
patch.apply.old.new.base.info=更改前: {0} (基目錄: {1})<br/>更改後: {2} (基目錄: {3})
patch.apply.outside.content.root.message=在內容根外部找到補丁檔案: {0}
patch.apply.overwrite.existing.file.prompt=以下檔案應通過補丁建立，但它已經存在。\\n\\
是否要覆蓋它?\\n\\
{0}
patch.apply.overwrite.existing.files.prompt=以下檔案應通過補丁建立，但它們已經存在。\\n\\
是否要覆蓋它們?
patch.apply.overwrite.existing.title=覆蓋現有檔案
patch.apply.partially.applied=指定補丁的某些更改已被跳過，因為它們已包含在程式碼中
patch.apply.partly.failed.title=補丁部分套用失敗
patch.apply.progress.title=正在套用補丁…
patch.apply.rollback.action=回滾
patch.apply.rollback.failed.message=嘗試使用“本地歷史記錄”對話框手動執行還原。
patch.apply.rollback.failed.title=回滾失敗
patch.apply.rollback.progress=回滾套用的更改…
patch.apply.rollback.progress.title=回滾套用的更改…
patch.apply.rollback.prompt=無法{0, choice, 0#套用補丁。|1#將補丁套用到檔案:|2#將補丁套用到檔案:}
patch.apply.rollback.prompt.bottom=補丁中的其他更改已成功套用，是否要回滾它們?
patch.apply.rollback.will.not.affect.binaries.info=回滾不會影響二進制檔案
patch.apply.select.base.for.a.path.message=為路徑選擇基
patch.apply.select.base.title=選擇{0, choice, 0#目錄|1#檔案}基
patch.apply.select.missing.base.link=選擇缺少的基
patch.apply.select.title=選擇補丁檔案
patch.apply.skip.action=跳過(_S)
patch.apply.somehow.diff.name=以某種方式套用補丁
patch.apply.stripped.description=\\ 去除的{0}
patch.apply.success.applied.text=已成功套用補丁
patch.apply.syntax.line=\\ (行: {0})
patch.apply.wrong.base.and.can.t.be.applied.warning={0} 的補丁的基錯誤，無法正確套用
patch.binary.decoder.char.error=無法解碼二進制檔案補丁: 字元大小符號錯誤
patch.binary.decoder.content.error=解碼的二進制內容{0,choice,0#少於|1#多於}預期
patch.binary.decoder.decompress.error=無法解碼二進制檔案補丁: 無法解壓資料
patch.binary.decoder.line.error=無法編碼二進制檔案補丁: 行大小錯誤
patch.can.t.detect.file.names.from.git.format.header.line=無法從 git 格式頭行檢測檔名
patch.contains.additional.information.without.patch.itself=包含附加資訊但不含補丁本身
patch.content.viewer.name=補丁內容檢視器
patch.copied.to.clipboard=補丁已複製到剪貼簿
patch.creation.base.dir.does.not.exist.error=基目錄不存在
patch.creation.base.path.field=基路徑(&B):
patch.creation.can.not.write.patch.error=無法將補丁寫入指定檔案: {0}
patch.creation.empty.base.path.error=基路徑不能為空!
patch.creation.failed=補丁建立失敗
patch.creation.name.too.long.error=檔案路徑不應過長。
patch.creation.save.patch.file.title=儲存補丁檔案
patch.creation.save.to.file.button=將補丁儲存到檔案
patch.creation.save.to.title=將補丁儲存到
patch.creation.wrong.base.path.for.changes.error=基路徑不包含所有所選更改(使用 {0})
patch.empty.0.data.section=空 ''{0}'' 資料分區
patch.empty.additional.info.header=空的附加資訊頭
patch.failed.to.fetch.old.content.for.file.name.in.revision=無法在修訂 {1} 中獲取檔案 {0} 的舊內容
patch.import.additional.info.error=無法匯入附加補丁資訊: {0}
patch.import.no.patches.found.warning=未找到補丁
patch.import.to.shelf.progress.title=將補丁匯入到 Shelf
patch.import.to.shelf.tab=將補丁匯入到 Shelf
patch.missing.after.hunk=缺少 after 區塊
patch.second.file.name.expected=應為第二個檔名
patch.simple.apply.base.line.error=意外的基行: 應為 - {0}，實際為 - {1}
patch.simple.apply.base.line.total.error=意外的基行: 總行數為 - {0}，實際為 - {1}
patch.simple.apply.hunk.base.body.error=意外的區塊基主體: 應為 - {0}，實際為 - {1}
patch.simple.apply.hunk.base.end.error=意外的區塊基結束: 總行數為 - {0}，區塊結束為 - {1}
patch.simple.apply.hunk.base.start.error=意外的區塊基開始: 應為 - {0}，實際為 - {1}
patch.simple.apply.hunk.content.error=意外的區塊內容: 應為 - {0}，實際為 - {1}
patch.simple.apply.hunk.patched.body.error=意外的區塊補丁主體: 應為 - {0}，實際為 - {1}
patch.simple.apply.hunk.patched.start.error=意外的區塊補丁開始: 應為 - {0}，實際為 - {1}
patch.unexpected.end.of.binary.patch=二進制補丁意外結束
patch.unknown.after.hunk.start.syntax=未知的 after 區塊開始語法
patch.unknown.before.hunk.start.syntax=未知的 before 區塊開始語法
patch.unknown.hunk.start.syntax=未知的區塊開始語法
patch.unknown.line.prefix=未知行前綴
patched.version.name=補丁版本
path.apply.select.base.directory.for.a.path.popup=為路徑選擇基目錄
paths.affected.in.revision={0} 中的更改
post.commit.checks.failed.notification.ignore.action=忽略
post.commit.checks.failed.notification.title=提交包含問題
post.commit.checks.failed.push.dialog.notification.text=提交包含問題: {0}
post.commit.checks.not.finished.push.dialog.notification.text=提交檢查仍在進行中
post.commit.checks.progress.text=正在檢查提交中的檔案
prefer.commit.timestamp.action.description=顯示提交更改的時間，而不是建立時間。
prefer.commit.timestamp.action.text=提交時間戳
prefer.commit.timestamp.action.text.show=顯示提交時間戳
progress.text.analyzing.code=正在分析程式碼…
progress.text.applying.fixes=正在套用修正…
progress.text.checking.for.todo=正在檢查 TODO…
progress.text.inspecting.code=正在檢查程式碼…
progress.text.loading.patch.base.revision=正在載入補丁基礎修訂
progress.text.optimizing.imports=正在最佳化 import…
progress.text.performing={0}: 正在執行 {1}…
progress.text.performing.rollback={0}: 正在執行回滾…
progress.text.rearranging.code=正在重新排列程式碼…
progress.text.reformatting.code=正在重新格式化程式碼…
progress.text.searching.for.modified.files=正在搜尋修改的檔案
progress.text.synchronizing.files=正在同步檔案…
progress.text.updating.canceled=更新已取消
progress.text.updating.done=更新完成
progress.title.adding.files.to.vcs=正在將檔案新增到 VCS…
progress.title.commit.checks=提交檢查
progress.title.discovering.location=正在發現 {0} 的位置
progress.title.hey=嗨
progress.title.loading.current.revision=正在載入當前修訂…
progress.title.version.control.processing.changed.files=版本控制: 正在處理更改的檔案
project.configuration.files.add.notification.action.add=始終新增
project.configuration.files.add.notification.action.mute=不再詢問
project.configuration.files.add.notification.action.view=檢視檔案
project.configuration.files.add.notification.message=可以將 IDE 專案設定新增到 {0}
project.configuration.files.view.dialog.title=將檔案新增到 {0}
radio.after.creation.add.silently=無提示新增
radio.after.creation.do.not.add=不新增
radio.after.creation.show.options=詢問
radio.after.deletion.do.not.remove=不移除
radio.after.deletion.remove.silently=無提示移除
radio.after.deletion.show.options=詢問
radio.restore.workspace.on.branch.switching=切換分支時還原工作區(&B)
radio.restore.workspace.on.branch.switching.comment=工作區是一組開啟的檔案、當前執行組態以及與分支關聯的中斷點。
ranges.to.commit.of.ranges.size.changes={1} 個中的 {0} 個發生更改
remove.changelist.combobox.do.not.remove=不執行任何動作
remove.changelist.combobox.remove.silently=無提示移除
remove.changelist.combobox.show.options=顯示選項
retrieving.annotations=正在載入註解
revert.changes.changelist.chooser.title=選擇目標更改列表
rollback.modified.without.checkout.error.tab={0}未簽出時進行了修改
rollback.modified.without.editing.confirm.multiple=要將更改{0}到 {1} 個所選檔案嗎?
rollback.modified.without.editing.confirm.single=要將更改{0}到{1}嗎?
rolling.back.file=正在回滾{0}
roots.notification.content.added.vcs.name.roots=已新增 {0} 個{1,choice,1#根|2#根}: {2}
roots.notification.content.directory.registered.as.root.but.no.repositories.were.found.there=目錄 {0} 被註冊為 {1} 根，但在那裡沒有發現 {1} 版本庫。
roots.notification.title.invalid.vcs.root.choice.mapping.mappings=無效 VCS 根{0, choice, 1#映射|2#映射}
roots.notification.title.vcs.name.integration.enabled={0} 整合已啟用
roots.notification.title.vcs.root.configuration.problems=VCS 根組態問題
roots.the.following.directories.are.registered.as.vcs.roots.but.they.are.not=以下目錄被錯誤註冊為 VCS 根:
save.committing.files.confirmation.cancel=延遲儲存
save.committing.files.confirmation.ok=立即儲存
save.committing.files.confirmation.text=當前正在將以下{0,choice,1#檔案|2#檔案}提交到 VCS。立即儲存可能會導致提交的資料不一致。\\n\\
{1}\\n\\
立即儲存{0,choice,1#檔案|2#檔案}?
save.committing.files.confirmation.title=在提交期間儲存檔案
saved.patch.apply.action=套用
saved.patch.apply.pop.help.tooltip=<html>套用\\\\&mdash;套用並將隱藏保留在<br/>列表中。<br/>彈出\\\\&mdash;套用並從列表中<br/>移除隱藏。</html>
saved.patch.changes.empty=選擇隱藏或擱置以檢視檔案
saved.patch.changes.loading=正在載入…
saved.patch.created.on.date.at.time.tooltip={0} 在 {2} 建立於 {1}
saved.patch.editor.diff.preview.empty.title=隱藏和擱置
saved.patch.empty.text=未新增任何隱藏或擱置。
saved.patch.pop.action=彈出
scope.name.changelist.all.changed.files=所有更改的檔案
searching.for.code.smells.freezing.process=簽入前代碼分析
searching.for.code.smells.processing.file.progress.text=正在處理 {0}
selection.history.can.not.load.message=無法載入修訂內容
selection.history.commit.message.label=提交訊息:
selection.history.loading.revision.status=正在載入修訂 {0}…
selection.history.local.revision.text=本地更改
sequence.concatenation.a.and.b={0} 和 {1}
sequence.concatenation.separator=, 
sequence.concatenation.tail=和 {0}
sequence.concatenation.tail.n.others=和其他 {0} 個
settings.auto.detected=自動檢測:
settings.auto.detected.progress=正在檢測…
settings.border.when.files.are.created=當檔案被建立時:
settings.change.shelves.location=更改擱置位置…
settings.changelist.conflicts.group.title=衝突
settings.changelists.create.automatically.checkbox=自動建立更改列表(&A)
settings.changelists.option.group=更改列表
settings.check.every.minutes=分鐘
settings.checkbox.limit.history.to=將歷史記錄限制為
settings.checkbox.measure.days=天
settings.checkbox.rows=行
settings.checkbox.show.changed.in.last=醒目提示以下時間內更改的檔案:
settings.checkbox.show.changed.in.last.comment=修改的檔案將在外部堆疊追蹤和偵錯時醒目提示。
settings.commit.message.body.add.blank.line.fix=新增空白行
settings.commit.message.inspections=提交訊息檢查
settings.commit.message.option.group=提交訊息
settings.commit.message.right.margin.label=右邊距:
settings.commit.message.show.right.margin.label=顯示右邊距
settings.commit.message.show.right.margin.n.columns.label=顯示 {0} 列中的右邊距
settings.commit.option.group=提交
settings.commit.without.dialog=使用非強制回應提交介面
settings.commit.without.dialog.applies.to.git.mercurial=套用到 Git 和 Mercurial 下的專案
settings.confirmation.option.group=確認
settings.confirmation.option.text.ask=詢問
settings.confirmation.option.text.no=否
settings.confirmation.option.text.yes=是
settings.current.location=當前位置為
settings.default.location=預設位置為 
settings.file.status.color.added.in.not.active.changelist=已在停用更改列表中新增
settings.file.status.color.changelist.conflict=更改列表衝突
settings.file.status.color.modified.in.not.active.changelist=已在停用更改列表中修改
settings.files.with.ignored.conflicts.list.title=包含忽略衝突的檔案:
settings.filter.configure.link=組態
settings.filter.update.project.info.by.scope=按作用域篩選更新專案資訊
settings.general.changes.group.title=更改
settings.general.confirmation.group.title=確認
settings.general.show.options.before.command.label=進行以下動作之前顯示選項:
settings.highlight.files.from.non.active.changelist.checkbox=醒目提示停用更改列表中的檔案(&I)
settings.highlight.files.with.conflicts.checkbox=醒目提示存在更改列表衝突的檔案(&H)
settings.inactive.changelist.group.title=停用更改列表
settings.issue.navigation.patterns={0} 將在簽入註釋中搜尋指定的模式，並將它們鏈接到問題追蹤器中的問題:
settings.label.when.empty.changelist.becomes.inactive=當空更改列表變為停用狀態時:
settings.limit.history.to.n.rows.label=將歷史記錄限制為 {0} 行
settings.partial.changelists.enable.checkbox=允許將一個檔案中的更改放入不同的更改列表(&P)
settings.shelf.content.larger=大於 {0}K 的檔案的基內容不會被存儲
settings.show.changed.in.last.n.days.label=顯示過去 {0} 天的更改
settings.show.conflict.resolve.dialog.checkbox=試圖編輯停用更改列表中的檔案時顯示對話框(&D)
settings.vcs.mapping.browser.select.directory.description=選擇要映射到 VCS 的目錄
settings.vcs.mapping.browser.select.directory.title=選擇目錄
settings.vcs.mapping.invalid.vcs.options.error=無效的 VCS 選項: {0}
settings.vcs.mapping.project.description=所有模組的內容根，以及專案基目錄的所有直接後代
settings.vcs.mapping.project.description.with.idea.directory=所有模組的內容根、專案基目錄的所有直接後代以及 {0} 目錄內容
settings.vcs.mapping.status.looking.for.vcs.administrative.area=正在尋找 VCS 管理區域
settings.version.control.option.group=版本控制
settings.when.files.are.deleted=當檔案被刪除時:
shelf.apply.action.description=套用所選擱置
shelf.drop.action=刪除
shelf.drop.action.description=刪除所選擱置
shelf.pop.action.description=彈出所選擱置
shelf.root.node.title=擱置
shelf.tab=擱置
shelf.tooltip.title=擱置
shelf.unshelve.changes.action.description=取消擱置所選更改
shelf.unshelve.changes.action.text=取消擱置
shelf.unshelve.changes.remove.action.description=取消擱置所選更改並將其從擱置中移除
shelf.unshelve.changes.remove.action.text=取消擱置並移除
shelve.base.content.not.found.or.not.applicable.error=基內容未找到或不適用。顯示與本地版本的差異
shelve.changelist.not.found=未找到擱置的更改列表 {0}
shelve.changes.action=托管更改(_S)
shelve.changes.only.directories=所選更改僅影響目錄，不影響檔案，因此無法擱置它們
shelve.changes.progress.text=正在擱置更改…
shelve.changes.progress.title=正在擱置更改
shelve.changes.restore.error=無法完全還原{0, choice, 1#擱置的更改列表|2#{0}擱置的更改列表}，因為某些檔案已被永久刪除
shelve.copying.shelves.to.progress=正在將擱置複製到新目錄…
shelve.default.path.rendering=<專案根目錄>
shelve.delete.already.unshelved.label=刪除已擱置的更改列表:
shelve.delete.changelists.message={0,choice, 1#1 個更改列表|2#{0} 個更改列表} {1}
shelve.delete.files.from.changelist.error=無法從 {0} 刪除檔案
shelve.delete.files.successful.message={0,choice, 1#1 個檔案|2#{0} 個檔案}
shelve.delete.successful.message=已成功刪除 {0}{1,choice, 0#|1# 和 }{2}
shelve.deletion.title=Shelf 刪除
shelve.editor.diff.preview.title=擱置: {0}
shelve.error.title=Shelf 錯誤
shelve.failed.message={0,choice,1#更改列表|2#更改列表} [{1}] 的更改擱置失敗
shelve.failed.title=擱置失敗
shelve.file.is.locked.for.editing.message=在擱置期間檔案已鎖定，無法編輯
shelve.import.one.patch.file.prompt=找到一個補丁檔案({0})。\\n\\
繼續匯入?
shelve.import.patches.prompt=找到 {0} 個補丁檔案。\\n\\
繼續匯入?
shelve.import.to.progress=正在處理 
shelve.moving.failed.prompt=Shelf 移動失敗。<br/>要使用新的 Shelf 目錄路徑還是將其還原為上一個路徑?
shelve.recently.deleted.node=最近刪除項
shelve.remove.successfully.applied.files.checkbox=從 Shelf 移除成功套用的檔案
shelve.revert.moving.button=還原(&R)
shelve.shelved.version=擱置的版本
shelve.show.already.unshelved.action=已取消擱置
shelve.successful.message=已成功擱置更改
shelve.undo.deletion=撤消 Shelf 刪除
shelve.use.new.directory.button=使用新路徑(&U)
shelved.version.name=擱置的版本
show.diff.from.annotation.action.error.can.not.load.data.to.show.diff=無法載入資料以顯示差異
show.diff.in.editor.tab.got.it.tooltip=要在編輯器頁籤中再次顯示差異，請使用此選單。
show.diff.progress.title=正在載入內容
show.diff.progress.title.detailed=正在載入 {0} 的內容
show.history.action.name.template=顯示 {0} 的歷史記錄(_F)…
show.history.dialog.title.template={0} 的歷史記錄
show.patch.in.explorer.after.creation.combobox.text.ask=詢問
show.patch.in.explorer.after.creation.combobox.text.no=不執行任何動作
show.patch.in.explorer.after.creation.combobox.text.show.in.file.manager=在 {0} 中顯示
show.patch.in.explorer.after.creation.label=建立補丁時:
stash.changes.message=在{0}之前未提交的更改
stash.changes.message.with.date=在進行{0}之前於 {1} 取消提交了更改
status.group.name.changed=已更改
status.group.name.changed.on.server=在伺服器上已更改
status.group.name.created=已建立
status.group.name.deleted=已刪除
status.group.name.locally.added=本地已新增
status.group.name.locally.removed=本地已移除
status.group.name.modified=已修改
status.group.name.not.in.repository=不在版本庫中
status.group.name.skipped=已跳過
status.group.name.switched=已切換
status.group.name.will.be.merged=將被合併
status.group.name.will.be.merged.with.conflicts=將在存在衝突的情況下被合併
status.group.name.will.be.merged.with.property.conflicts=將在存在屬性衝突的情況下合併
status.group.name.will.be.merged.with.tree.conflicts=將在存在樹衝突的情況下合併
status.group.name.will.be.restored=將被還原
status.text.commit.toolwindow.create.repository=建立 Git 版本庫…
status.text.commit.toolwindow.create.repository.prefix=要提交更改，
status.text.commit.toolwindow.local.history=本地歷史記錄…
status.text.commit.toolwindow.local.history.prefix=有關最近的更改，請參閱
status.text.vcs.toolwindow=要追蹤程式碼更改:
status.text.vcs.toolwindow.create.repository=建立 Git 版本庫…
status.text.vcs.toolwindow.help=版本控制整合
status.text.vcs.toolwindow.local.history=使用本地歷史記錄…
switch.to.changelist=切換到更改列表(''{0}'')(&T)
switch.to.commit.dialog.hint.text=要切換回“提交”對話框，請使用齒輪圖標下的選單
switch.to.commit.dialog.hint.text.new.ui=要切換回“提交”對話框，請使用“選項”圖標下的選單
tab.title.commit=提交
tab.title.commit.to.branch=提交至 {0}
text.commit.message.truncated.by.ide.name={0}\\n\\
\\n\\
…提交訊息過長，被 {1} 截斷…
title.code.author.inlay.hints=程式碼作者
title.load.revision.contents=載入修訂內容
todo.handler.only.added=<html><body>發現{0,choice, 0#|1#一|2#{0}}個已被新增或編輯的 TODO {0,choice, 0#|1#專案|2#專案}。<br/>您是否想檢視{0,choice,1#它|2#它們}?<br/>{1,choice, 0#|1#1個檔案被跳過。|2#{1} 個檔案被跳過。}</body></html>
todo.handler.only.both=<html><body>{0, choice, 1#1|2#{0}} 個新增/編輯的 TODO {0,choice, 1#條目|2#條目}，<br/>並在更改的片段中找到 {1, choice, 1#1個條目|2#{1} 個條目}。<br/>要檢查它們嗎?<br/>{2,choice, 0#|1#1 個檔案被跳過。|2#{2} 個檔案被跳過。}</body></html>
todo.handler.only.in.changed=<html><body>{0,choice, 1#一|2#{0}}個 TODO {0,choice, 1#項|2#項} 在已改變的片段中找到。<br/>您是否需要查閱{0,choice,1#它|2#它們}?<br/>{1,choice, 0#|1#一個檔案被跳過|2#{1} 個檔案被跳過。}</body></html>
todo.handler.only.skipped=<html><body>TODO 檢查已經跳過 {0,choice, 0#|1#1 個檔案|2#{0}多個檔案}。<br/>沒有發現新的或已編輯的 TODO 條目，也沒有位於更改的文本片段中的條目。</body></html>
todo.in.new.review.button=審查 TODO(&R)
todo.tab.title.all.changes=本地更改
todo.tab.title.changelist.suffix=更改列表
tooltip.rerun.commit.checks=重新執行提交檢查
tooltip.show.options.dialog=顯示選項對話框
toolwindow.title.update.project=更新專案({0})
unknown.vcs.presentation=<未知 VCS> ({0})
unregistered.roots.label=未註冊的根:
unshelve.changelist.chooser.title=取消擱置更改列表的更改
unshelve.changes.action=取消托管更改
unshelve.changes.dialog.title=取消擱置更改
unshelve.changes.progress.title=正在取消擱置更改…
unshelve.loading.patch.error=無法載入補丁: {0}
update.can.t.load.content=無法載入內容
update.checkbox.don.t.show.again=不再顯示
update.directories.scope.name=目錄
update.directory.scope.name=目錄
update.error.label=錯誤: 
update.file.name.wasn.t.modified={0} 未修改
update.file.scope.name=檔案
update.files.scope.name=檔案
update.filtered.files.count.in.filter.name={0} ({1} 內)
update.group.name.created=已建立
update.group.name.deleted=已刪除
update.group.name.locally.added=本地已新增
update.group.name.locally.removed=本地已移除
update.group.name.merged=已合併
update.group.name.merged.with.conflicts=已合併，但存在衝突
update.group.name.merged.with.property.conflicts=已合併，但存在屬性衝突
update.group.name.merged.with.tree.conflicts=已合併，但存在樹衝突
update.group.name.modified=已修改
update.group.name.not.in.repository=不在版本庫中
update.group.name.restored=已還原
update.group.name.skipped=已跳過
update.group.name.switched=已切換
update.group.name.updated=已更新
update.group.name.updated.from.server=從伺服器更新
update.info.click.status.text.prefix=點擊
update.info.group.by.changelist=按更改列表分組
update.info.loading.changelists=正在載入更改列表…
update.info.refresh.link.status.text=重新整理
update.info.to.initialize.status.text.suffix=以初始化版本庫更改快取
update.label.after.update=更新後
update.label.before.update=更新前
update.notification.content.files.updated={0,choice,1#1 個檔案|2#{0} 個檔案}已更新
update.notification.content.view=檢視
update.notification.title.count.files.updated={0,choice,1#1 個檔案|2#{0} 個檔案}已更新
update.notification.title.project.partially.updated=專案已部分更新
update.project.scope.name=專案
update.tree.node.size.statistics={0,choice, 0#無條目|1#1 個條目|2#{0, number} 個條目}
user.group.title=使用者
vcs.add.to.ignore.file.action.group.description=將所選檔案新增到 {0}
vcs.add.to.ignore.file.action.group.text=新增到 {0}
vcs.add.to.ignore.file.create.ignore.file.confirmation.message=在 {1} 中建立 {0} 檔案?
vcs.add.to.ignore.file.create.ignore.file.confirmation.title=建立 {0}
vcs.command.name.add=新增
vcs.command.name.checkin=提交(_I)
vcs.command.name.checkout=簽出
vcs.command.name.edit=編輯
vcs.command.name.remove=移除
vcs.command.name.status=狀態
vcs.command.name.update=更新
vcs.commit.canceled=提交已取消
vcs.commit.files.committed={0,choice,1#{0} 個檔案|2#{0} 個檔案}已提交
vcs.commit.files.committed.and.files.failed.to.commit={0,choice,1#{0} 個檔案|2#{0} 個檔案}已提交，{1,choice,1#{1} 個檔案|2#{1} 個檔案}提交失敗
vcs.common.labels.directory=目錄:
vcs.common.labels.url=URL:
vcs.common.labels.vcs=VCS:
vcs.common.labels.version.control=版本控制:
vcs.config.track.changed.on.server=檢查與伺服器衝突的時間間隔
vcs.console.toolwindow.display.name=主控台
vcs.dnd.image.text.n.files={0} 個{0, choice, 1#檔案|2#檔案}
vcs.error.failed.to.load.file.content.from.vcs=無法載入內容
vcs.generic.name=VCS
vcs.generic.name.with.mnemonic=VCS(_S)
vcs.local.changes.toolbar=VCS 本地更改工具列
vcs.operations.popup=VCS 動作彈出視窗
vcs.preview.panel.added.ignored.line=已新增忽略的行
vcs.preview.panel.added.line=已新增行
vcs.preview.panel.deleted.ignored.line.below=已刪除以下忽略的行
vcs.preview.panel.deleted.line.below=以下已刪除的行
vcs.preview.panel.last.commit.modified.line=上次提交中修改的行
vcs.preview.panel.line.with.modified.whitespaces=帶有修改的空格的行
vcs.preview.panel.line.with.modified.whitespaces.and.deletion.after=帶有修改的空格和後續刪除的行
vcs.preview.panel.modified.ignored.line=已修改忽略的行
vcs.preview.panel.modified.line=已修改的行
vcs.quicklist.popup.title=VCS 動作
vcs.revision.name.current=當前
vcs.settings.path=設定 | 版本控制
vcs.settings.path.mac=偏好設定 | 版本控制
vcs.shelf.action.restore.description=還原最近刪除的{0, choice, 1#更改列表|2#更改列表}
vcs.shelf.action.restore.text=還原
vcs.shelf.move.text=將擱置移至新位置(&M)
vcs.shelf.store.base.content=擱置分布式版本控制系統下檔案的基本修訂版本
vcs.shelving.changes=正在擱置更改…
vcs.tab.title.vcs.name.operations.errors={0} 個動作錯誤
vcs.unshelving.changes=正在取消擱置更改…
vcs.unshelving.conflict.left=您未提交的更改
vcs.unshelving.conflict.right=遠端更改
vcs.update.tab.name=更新資訊
version.control.main.configurable.description=<html><body>組態與專案中使用的版本控制相關的設定
version.control.main.configurable.name=版本控制
vfs.revision.author.unknown=未知
waiting.changelists.update.for.show.commit.dialog.message=提交"
`;

exports[`src messages/VcsLogBundle.properties 1`] = `
"action.FocusTextFilterAction.description=聚焦文本篩選器或將焦點移回提交列表
action.FocusTextFilterAction.text=聚焦文本篩選器
action.IntelliSortChooserPopupAction.description=更改 IntelliSort 類型
action.IntelliSortChooserPopupAction.text=IntelliSort
action.ShowCommitTooltipAction.description=在日誌中為當前所選提交顯示工具提示
action.ShowCommitTooltipAction.text=顯示提交工具提示
action.Vcs.Log.AnnotateRevisionAction.description=註解所選修訂
action.Vcs.Log.AnnotateRevisionAction.text=註解
action.Vcs.Log.CompareRevisions.description=比較選定版本
action.Vcs.Log.CompareRevisions.text=比較版本
action.Vcs.Log.EnableFilterByRegexAction.text=正則表達式
action.Vcs.Log.GoToChild.description=導覽到提交圖中的子行
action.Vcs.Log.GoToChild.text=轉到子提交
action.Vcs.Log.GoToParent.description=導覽到提交圖中的父行
action.Vcs.Log.GoToParent.text=轉到父提交
action.Vcs.Log.GoToRef.description=指定分支或標記的雜湊或名稱，以導覽到其指向的提交
action.Vcs.Log.GoToRef.text=轉到雜湊/分支/標記
action.Vcs.Log.MatchCaseAction.text=區分大小寫
action.Vcs.Log.MoveDiffPreviewToBottom.description=在底部找到差異預覽
action.Vcs.Log.MoveDiffPreviewToBottom.text=底部
action.Vcs.Log.MoveDiffPreviewToRight.description=在右側找到差異預覽
action.Vcs.Log.MoveDiffPreviewToRight.text=右側
action.Vcs.Log.OpenRepositoryVersion.description=在編輯器中開啟檔案的所選修訂
action.Vcs.Log.OpenRepositoryVersion.text=按修訂顯示檔案
action.Vcs.Log.ResumeIndexing.description=索引編制已暫停，因為它花費的時間比預期長。恢復。
action.Vcs.Log.ResumeIndexing.text=恢復索引編制
action.Vcs.Log.ShowAllAffected.description=顯示選中修訂中所做的所有更改
action.Vcs.Log.ShowAllAffected.text=顯示所有受影響的檔案
action.Vcs.Log.ShowTooltip.description=在日誌中為當前選定提交顯示工具提示
action.Vcs.Log.ShowTooltip.text=顯示提交工具提示
action.Vcs.Show.Log.text=顯示 VCS 日誌
action.Vcs.Show.Log.text.template=顯示 {0} 日誌
action.description.collapse.linear.branches=摺疊線性分支
action.description.collapse.merges=摺疊合併
action.description.expand.linear.branches=展開線性分支
action.description.expand.merges=展開合併
action.description.is.scheduled=為 {0} 編制索引已計劃。暫停。
action.description.refresh.log=檢查新提交，必要時重新整理日誌
action.description.select.columns.to.see=選擇要在表中檢視的列
action.description.was.paused=為 {0} 編制索引已暫停。恢復。
action.go.to.navigate.to=導覽到 {0}
action.go.to.select.child.to.navigate=選擇要導覽的子項
action.go.to.select.hash.subject.author.date.time={0} {1}，作者 {2}，{3} {4}
action.go.to.select.parent.to.navigate=選擇要導覽的父項
action.name.refresh.log=重新整理
action.presentation.CompareRevisionsFromFileHistoryActionProvider.description.compare=比較所選版本
action.presentation.CompareRevisionsFromFileHistoryActionProvider.description.show.diff=顯示與之前版本的差異
action.presentation.CompareRevisionsFromFileHistoryActionProvider.text.compare=比較
action.presentation.CompareRevisionsFromFileHistoryActionProvider.text.show.diff=顯示差異
action.process.collapsing.linear.branches=正在摺疊線性分支…
action.process.collapsing.merges=正在摺疊合併…
action.process.expanding.linear.branches=正在展開線性分支…
action.process.expanding.merges=正在展開合併…
action.title.collapse.linear.branches=摺疊線性分支
action.title.collapse.merges=摺疊合併
action.title.expand.linear.branches=展開線性分支
action.title.expand.merges=展開合併
action.title.match.case=區分大小寫
action.title.match.case.only.supported=區分大小寫(僅限 {0})
action.title.pause.indexing=暫停 {0} 日誌索引編制
action.title.resume.indexing=恢復 {0} 日誌索引編制
action.title.select.columns.to.see=列
action.vcs.log.branches.separator=分支
action.vcs.log.show.separator=顯示
dialog.title.paths.affected.by.commit=受提交 {0} 影響的路徑
file.history.action.could.not.load.selected.commits.message=無法載入所選提交: {0}
file.history.commit.not.found={1} 的歷史記錄中不存在 {0}
file.history.commit.not.found.in.branch=當前分支中 {1} 的歷史記錄中不存在 {0}
file.history.commit.not.found.view.and.show.all.branches.link=檢視並顯示所有分支
file.history.commit.not.found.view.in.log.link=在日誌中檢視
file.history.diff.preview.editor.tab.name=歷史記錄: {0}
file.history.empty.status=檔案歷史記錄
file.history.error.status=計算檔案歷史記錄時出錯
file.history.toolbar=檔案歷史工具列
filetype.vcs.log.description=Vcs 日誌
graph.sort.linear=線性
graph.sort.linear.description=合併時，在主分支提交的頂部顯示傳入提交，就好像對它們進行重定基底
graph.sort.off=關閉
graph.sort.off.description=按日期以拓撲方式對提交進行排序
graph.sort.standard=標準
graph.sort.standard.description=合併時，首先顯示傳入提交(合併提交正下方)
group.Log.KeymapGroup.text=日誌
group.Vcs.FileHistory.PresentationSettings.description=組態檔案歷史記錄的表示
group.Vcs.FileHistory.PresentationSettings.text=檢視選項
group.Vcs.Log.ChangesBrowser.PresentationSettings.text=檢視選項
group.Vcs.Log.Diff.Preview.Location.text=差異預覽位置
group.Vcs.Log.Internal.text=Vcs 日誌
group.Vcs.Log.LayoutConfiguration.description=組態視窗布局
group.Vcs.Log.LayoutConfiguration.separator.text=布局
group.Vcs.Log.LayoutConfiguration.text=組態布局
group.Vcs.Log.PresentationSettings.description=組態日誌的表示
group.Vcs.Log.PresentationSettings.text=檢視選項
group.Vcs.Log.TextFilterSettings.description=選擇文本篩選器選項
group.Vcs.Log.TextFilterSettings.text=文本篩選器設定
loading.commit.changes=正在載入提交更改
vcs=Vcs
vcs.log.action.align.labels=左側的參照
vcs.log.action.description.align.labels=在提交訊息左側顯示參照
vcs.log.action.description.open.new.tab.with.log=開啟包含 {0} 日誌的新頁籤
vcs.log.action.description.show.all.branches=在僅顯示當前分支和顯示所有分支之間切換
vcs.log.action.description.show.all.changes.from.parent=分別顯示對每個合併提交所做的更改
vcs.log.action.description.show.compact.references.view=僅在表中顯示提交的第一個參照
vcs.log.action.description.show.details=顯示詳細資訊面板
vcs.log.action.description.show.diff.preview=顯示差異預覽面板
vcs.log.action.description.show.long.edges=即使提交在當前檢視中不可見，也顯示長分支邊緣。
vcs.log.action.description.show.only.affected.changes=僅顯示影響“路徑”選單中所選檔案的更改
vcs.log.action.description.show.tag.names=在表中顯示標籤名稱
vcs.log.action.highlight.current.branch=當前分支
vcs.log.action.highlight.indexed.commits=已編制索引的提交
vcs.log.action.highlight.merge.commits=合併提交
vcs.log.action.highlight.my.commits=我的提交
vcs.log.action.intellisort.description=開啟/關閉 IntelliSort
vcs.log.action.intellisort.text=IntelliSort
vcs.log.action.intellisort.title=IntelliSort: {0}
vcs.log.action.open.new.tab.with.log=開啟新的 {0} 日誌頁籤
vcs.log.action.show.all.branches=顯示所有分支
vcs.log.action.show.all.changes.from.parent=顯示對父項的更改
vcs.log.action.show.compact.references.view=緊湊型參照檢視
vcs.log.action.show.details=顯示詳細資訊
vcs.log.action.show.diff.preview=顯示差異預覽
vcs.log.action.show.long.edges=長邊
vcs.log.action.show.only.affected.changes=僅顯示受影響的更改
vcs.log.action.show.root.names=根名稱
vcs.log.action.show.tag.names=標籤名稱
vcs.log.action.turn.intellisort.off=關閉 IntelliSort: {0}。
vcs.log.action.turn.intellisort.on=開啟 IntelliSort: {0}。
vcs.log.applying.filters.process=正在套用篩選器…
vcs.log.branch.filter.action.text=按分支篩選
vcs.log.branch.filter.favorites=收藏夾
vcs.log.branch.filter.label=分支
vcs.log.changes.accessible.name=提交更改瀏覽器
vcs.log.changes.browser.toolbar=VCS 日誌更改瀏覽器工具列
vcs.log.changes.changes.to.parent.node=對 {0} 的更改
vcs.log.changes.details.no.commits.selected.status=未選擇提交
vcs.log.changes.no.changes.that.affect.selected.paths.status=沒有影響所選路徑的更改。
vcs.log.changes.no.merge.conflicts.node=沒有合併的衝突
vcs.log.changes.no.merge.conflicts.status=沒有合併的衝突。
vcs.log.changes.select.commits.to.view.changes.status=選擇要檢視更改的提交
vcs.log.changes.show.all.paths.status.action=顯示所有路徑的更改
vcs.log.changes.show.changes.to.parents.status.action=顯示對父項的更改
vcs.log.changes.too.many.show.anyway.status.action=仍然顯示
vcs.log.changes.too.many.status={0,choice,1#此提交|2#所選提交之一}具有 {1} 個更改
vcs.log.clear.caches.checkbox.description=清除 VCS 日誌快取和索引
vcs.log.click.to.collapse.paths.column.tooltip=點擊以摺疊
vcs.log.click.to.expand.paths.column.tooltip=點擊以展開
vcs.log.column.author=作者
vcs.log.column.date=日期
vcs.log.column.hash=雜湊
vcs.log.column.subject=主題
vcs.log.commit.details.status=提交詳細資訊
vcs.log.commit.does.not.match={0} 與篩選器不符合
vcs.log.commit.does.not.match.view.and.reset.link=檢視並重設篩選器
vcs.log.commit.does.not.match.view.in.tab.link=在新頁籤中檢視
vcs.log.commit.not.found=找不到 {0}
vcs.log.commit.or.reference.prefix=提交或參照 ''{0}''
vcs.log.commit.prefix=提交 ''{0}''
vcs.log.commit.status.action=提交本地更改
vcs.log.creating.process=正在載入提交…
vcs.log.date.filter.action.last.day=過去 24 小時
vcs.log.date.filter.action.last.week=過去 7 天
vcs.log.date.filter.action.text=按日期篩選
vcs.log.date.filter.label=日期
vcs.log.date.filter.select.period.dialog.title=選擇期間
vcs.log.date.filter.since=自 {0}
vcs.log.date.filter.until=到 {0}
vcs.log.default.status=更改日誌
vcs.log.details.author.on.date.at.time=作者 {0}，{1} {2}
vcs.log.details.committer.info.date.time=在 {0} {1} 提交
vcs.log.details.committer.info.user=由 {0} 提交
vcs.log.details.committer.info.user.date.time=由 {0} 於 {1} {2} 提交
vcs.log.details.in.branches=在 {0,choice,1#{0} 個分支|2#{0} 個分支}中:
vcs.log.details.in.branches.empty=不在任何分支中
vcs.log.details.in.branches.hide=隱藏
vcs.log.details.in.branches.loading=在分支中: 正在載入…
vcs.log.details.in.branches.show.all=全部顯示
vcs.log.details.references.more.label=…其他 {0} 個
vcs.log.details.showing.selected.commits=(正在顯示 {0}/{1} 個所選提交)
vcs.log.diff.preview.editor.empty.tab.name=版本庫差異
vcs.log.diff.preview.editor.tab.name=版本庫差異: {0}
vcs.log.duplicated.tab.id.error=“VCS 日誌”頁籤不能開啟兩次
vcs.log.editor.name=Vcs 日誌編輯器
vcs.log.error.filtering.status=篩選提交時出錯
vcs.log.error.loading.changes.status=載入更改時出錯
vcs.log.error.loading.commits.status=載入提交時出錯
vcs.log.error.loading.details.status=載入提交詳細資訊時出錯
vcs.log.failed.loading.details=無法在 {1} 中載入提交 {0} 的詳細資訊
vcs.log.fatal.error.message=無法清除 {0} 下的快取。\\n請手動刪除快取目錄，然後重啟 {1}。
vcs.log.filter.accessible.name={0}: {1}
vcs.log.filter.action.select=選擇…
vcs.log.filter.all=所有
vcs.log.filter.branch.presentation.with.prefix=在 {0} 上
vcs.log.filter.date.display.name.after=自 {0}
vcs.log.filter.date.display.name.before=到 {0}
vcs.log.filter.date.display.name.between={0} 和 {1} 之間
vcs.log.filter.date.presentation.with.prefix.made.after=生成自 {0}
vcs.log.filter.date.presentation.with.prefix.made.before=生成到 {0}
vcs.log.filter.date.presentation.with.prefix.made.between=在 {0} 與 {1} 之間進行
vcs.log.filter.edit.folders=選擇…
vcs.log.filter.popup.advertisement.text=選擇一個或多個用 {0} 分隔的值
vcs.log.filter.popup.advertisement.text.new.lines=新行
vcs.log.filter.popup.advertisement.text.or.suffix=或{0}
vcs.log.filter.popup.advertisement.with.key.text=選擇一個或多個用 {0} 分隔的值，並使用 {1} 完成
vcs.log.filter.popup.no.folders=無路徑
vcs.log.filter.popup.no.items=沒有項
vcs.log.filter.popup.no.roots=沒有根
vcs.log.filter.popup.paths=路徑
vcs.log.filter.recent=最近
vcs.log.filter.root.presentation.with.prefix=在 {0} 中
vcs.log.filter.roots=根
vcs.log.filter.select.folders=在樹中選擇…
vcs.log.filter.structure.presentation.with.prefix=用於 {0}
vcs.log.filter.text.hash.tooltip=文本或雜湊篩選器
vcs.log.filter.text.presentation.with.prefix=包含 {0}
vcs.log.filter.tooltip.click.to.see.only={0}+點擊以僅檢視“{1}”
vcs.log.filter.tooltip.folders=路徑:
vcs.log.filter.tooltip.no.roots.selected=未選擇根
vcs.log.filter.tooltip.roots=根:
vcs.log.filter.user.presentation.with.prefix=被 {0} 使用
vcs.log.filters.structure.label=已選擇: {0}
vcs.log.filters.structure.max.selected.error.message=您已新增 {0} 個元素。不允許更多元素。
vcs.log.go.to.hash.popup.label=輸入雜湊或分支/標記名稱:
vcs.log.graph.arrow.tooltip.jump.to.hash=跳轉到提交 {0}
vcs.log.graph.arrow.tooltip.jump.to.hash.in.root=跳轉到 {1} 中的提交 {0}
vcs.log.graph.arrow.tooltip.jump.to.subject.author.date.time=跳轉到 {0} (作者 {1}，{2} {3})
vcs.log.index.diagnostic.action.title=檢查舊提交的 VCS 日誌索引資料
vcs.log.index.diagnostic.error.attribute.name.author=作者
vcs.log.index.diagnostic.error.attribute.name.author.time=作者日期
vcs.log.index.diagnostic.error.attribute.name.committer=提交者
vcs.log.index.diagnostic.error.attribute.name.committer.time=提交日期
vcs.log.index.diagnostic.error.attribute.name.message=訊息
vcs.log.index.diagnostic.error.attribute.name.parents=父項
vcs.log.index.diagnostic.error.filter=按 {0} 篩選不會返回 {1}
vcs.log.index.diagnostic.error.for.commit=提交 {0} 的差異\\n{1}
vcs.log.index.diagnostic.error.message=應為 {0}: {1}，實際為 {0}: {2}
vcs.log.index.diagnostic.progress.title=正在執行 VCS 日誌索引診斷
vcs.log.index.diagnostic.report.title=VCS 日誌索引診斷報告 {0}
vcs.log.index.diagnostic.selected.action.title=檢查所選提交的 VCS 日誌索引資料
vcs.log.index.diagnostic.selected.non.indexed.warning.message=所選提交未編制索引
vcs.log.index.diagnostic.success.message={0} 個已檢查{0,choice,1#提交|2#提交}的 VCS 日誌索引資料正確
vcs.log.initial.loading.process=正在載入歷史記錄…
vcs.log.invalidate.caches.progress=正在使 {0} 日誌快取和索引無效
vcs.log.invalidate.caches.text=使 {0} 日誌快取和索引無效
vcs.log.is.loading=正在載入 VCS 日誌…
vcs.log.is.not.available=VCS 日誌不可用
vcs.log.loading.selected.details.process=正在載入所選詳細資訊
vcs.log.loading.status=正在載入提交…
vcs.log.no.commits.matching.status=沒有與篩選器符合的提交
vcs.log.no.commits.status=未提交更改。
vcs.log.path.filter.action.text=按路徑篩選
vcs.log.references.more.tooltip=…詳細資訊窗格中的其他 {0} 項
vcs.log.refresh.status.action=重新整理
vcs.log.refreshing.process=正在重新整理歷史記錄…
vcs.log.reset.filters.status.action=重設篩選器
vcs.log.right.corner.toolbar=VCS 日誌工具列
vcs.log.select.folder.dialog.title=選擇要篩選的路徑
vcs.log.show.commit.in.log.process=正在搜尋修訂 {0}
vcs.log.status.bar.indexing={0} 日誌正在編制索引…
vcs.log.status.bar.indexing.cancel.cancelling=正在取消
vcs.log.status.bar.indexing.cancel.tooltip=取消索引編制。可以從 {0} 日誌工具列手動重啟索引編制。
vcs.log.string.is.not.a.hash=''{0}'' 看起來不像提交雜湊
vcs.log.tab.name=日誌
vcs.log.table.accessible.name={0} 日誌
vcs.log.text.filter.accessible.name={0} 日誌文本或雜湊篩選器
vcs.log.text.filter.action.text=按文本或雜湊篩選
vcs.log.user.filter.action.text=按使用者篩選
vcs.log.user.filter.label=使用者
vcs.log.user.filter.me=我"
`;

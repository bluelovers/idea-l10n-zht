action.AnalyzeUnloadablePlugins.progress.title=正在分析插件({0})
action.AnalyzeUnloadablePlugins.text=分析可卸载插件
action.DevKit.NewAction.text=操作
action.DevKit.NewMessageBundle.action.name.create.new.message.bundle=创建新消息捆绑包 ''{0}''
action.DevKit.NewMessageBundle.description=创建新的消息捆绑包类和相应的属性文件
action.DevKit.NewMessageBundle.error.message.do.not.put.bundle.to.impl.module=目前不建议为 .impl 模块创建单独的捆绑包，请改为使用相应 API 模块中的捆绑包
action.DevKit.NewMessageBundle.error.message.folder.already.exists={1} 下已存在 ''{0}'' 文件夹
action.DevKit.NewMessageBundle.error.message.multiple.content.roots.for.module={0} 的多个内容根
action.DevKit.NewMessageBundle.error.message.under.sources.root={0} 在源根下
action.DevKit.NewMessageBundle.error.title.cannot.create.new.message.bundle=无法创建新消息捆绑包
action.DevKit.NewMessageBundle.label.bundle.name=捆绑包名称\:
action.DevKit.NewMessageBundle.notification.content.cannot.create.resources.root.for.properties.file=无法为属性文件 {0} 创建资源根
action.DevKit.NewMessageBundle.notification.title.cannot.create.resources.root.for.properties.file=无法创建新消息捆绑包
action.DevKit.NewMessageBundle.text=消息捆绑包
action.DevKit.NewMessageBundle.title.create.new.message.bundle=创建新消息捆绑包
action.DevKit.NewMessageBundleObject.text=消息捆绑包
action.DevKit.NewRemoteDevModule.action.name.create.remdev.module=创建新的远程开发模块 ''{0}''
action.DevKit.NewRemoteDevModule.error.title.cannot.create.remdev.module=无法创建新的远程开发模块
action.DevKit.NewService.description=创建一个新的 @Service 类来管理内存中的 IDE 状态
action.DevKit.NewService.text=服务
action.DevKit.NewStartupActivity.description=创建将在项目打开时执行的新活动
action.DevKit.NewStartupActivity.text=启动活动
action.DevKit.NewState.description=创建一个新的 PersistentStateComponent 类，该类将用于存储和共享设置
action.DevKit.NewState.text=持久状态
action.DevKit.NewToolwindow.text=工具窗口
action.DumpCleanTestData.error.source.destination.must.differ=源根和目标根应不同
action.DumpCleanTestData.file.chooser.destination.description=将放置无高亮显示标记的副本的目录
action.DumpCleanTestData.file.chooser.source.description=包含高亮显示测试数据的目录
action.DumpCleanTestData.file.chooser.title=选择目录
action.DumpCleanTestData.text=转储高亮显示的无标记数据
action.GenerateExternalization.text=生成外部化
action.MakeAllJarsAction.text=准备所有要部署的插件
action.MakeJarAction.text=准备部署
action.NewAction.description=创建新操作
action.NewAction.text=操作
action.NewRemoteDevModule.text=远程开发模块…
action.ShowHelpPageById.dialog.enter.help.id=输入帮助 ID\:
action.ShowHelpPageById.dialog.title=显示帮助页面
action.ShowHelpPageById.text=按 ID 显示帮助页面
action.ShowSerializedXml.dialog.title=''{0}'' 的序列化 XML
action.ShowSerializedXml.message.cannot.find.class=找不到类 ''{0}''
action.ShowSerializedXml.message.cannot.generate.class=无法生成类 ''{0}''\: {1}
action.ShowSerializedXml.message.caret.must.be.at.class.identifier=文本光标应位于类名处
action.ShowSerializedXml.text=显示类的序列化 XML
action.ShuffleNamesAction.text=对名称进行重排/加扰/匿名/置换
action.TestData.Navigate.text=导航到测试数据
action.ToggleHighlightingMarkup.text=切换预期的高亮显示标记
action.UpdateIdeFromSources.description=从当前打开的源代码构建 IntelliJ IDEA 的安装，并用结果更新当前(或其他)安装。
action.UpdateIdeFromSources.text=从源代码更新 IDE…
action.UpdateIdeFromSourcesAction.copy.copy.new.files.text=正在复制新文件
action.UpdateIdeFromSourcesAction.copy.delete.old.files.text=正在删除旧文件
action.UpdateIdeFromSourcesAction.copy.progress.text=正在将文件复制到 IDE 发行版…
action.UpdateIdeFromSourcesAction.dialog.message.directory.not.writable=目录 {0} 不可写
action.UpdateIdeFromSourcesAction.error.config.or.system.directory.under.home=无法更新 {0} 安装，因为 ''{1}'' 属性指向它下面的目录，并且它在更新过程中将被清除。
action.UpdateIdeFromSourcesAction.error.empty.dir=构建目录 ''{0}'' 为空。
action.UpdateIdeFromSourcesAction.error.ide.cannot.restart=此 IDE 无法自行重启，因此不支持从源代码更新
action.UpdateIdeFromSourcesAction.error.no.module=在项目中找不到构建脚本模块 ''{0}''。
action.UpdateIdeFromSourcesAction.error.no.sdk=项目SDK未定义。
action.UpdateIdeFromSourcesAction.error.work.home.not.valid.ide.home={0} 不是有效的 IDE 主目录\: {1}
action.UpdateIdeFromSourcesAction.error.work.home.not.valid.ide.home.not.directory=它不是目录
action.UpdateIdeFromSourcesAction.error.work.home.not.valid.ide.home.not.exists=安装目录无效\: ''{0}'' 不存在
action.UpdateIdeFromSourcesAction.notification.action.view.debug.log=查看调试日志
action.UpdateIdeFromSourcesAction.notification.action.view.output=查看输出
action.UpdateIdeFromSourcesAction.notification.content=新安装在{0}处准备。
action.UpdateIdeFromSourcesAction.notification.title=从源代码更新
action.UpdateIdeFromSourcesAction.settings.do.not.show.description=您可以调用“从源设置更新 IDE”操作来更改设置
action.UpdateIdeFromSourcesAction.settings.enabled.plugins.only=仅构建已启用的插件
action.UpdateIdeFromSourcesAction.settings.installation.choose.ide.directory.title=选择 IDE 安装目录
action.UpdateIdeFromSourcesAction.settings.ok.button=更新
action.UpdateIdeFromSourcesAction.settings.restart.automatically=自动重启
action.UpdateIdeFromSourcesAction.settings.row.ide.installation=IDE 安装\:
action.UpdateIdeFromSourcesAction.settings.title=从源代码更新 IDE
action.UpdateIdeFromSourcesAction.task.failed.content=构建脚本完成，错误代码为 {0}
action.UpdateIdeFromSourcesAction.task.failed.title=从源代码更新失败
action.UpdateIdeFromSourcesAction.task.title=从源代码更新
action.UpdateIdeFromSourcesAction.update.progress.delete=正在删除 {0}
action.UpdateIdeFromSourcesAction.update.progress.start.script=正在运行分发构建脚本
action.UpdateIdeFromSourcesAction.update.progress.text=正在从源代码更新 IDE…
action.UpdateIdeFromSourcesSettings.text=从源代码设置更新 IDE…
action.create.message.bundle.title=新消息捆绑包
action.name.new.action=创建新操作
action.name.new.devkit.service=创建服务类
action.name.new.devkit.startup.activity=创建新的 DevKit ProjectActivity
action.name.new.state.service=创建 PersistentStateComponent 类
action.or.group.reference=操作 ID 引用
api.compose.description=用于构建精美 UI 的开源声明式框架
api.lsp.description=实现 IDE 和语言服务器之间的通信
category.platform.description=IntelliJ 平台模块提供的 API
category.platform.title=IntelliJ 平台
category.plugins.description=语言和框架
category.plugins.title=插件
code.convert.experimental.feature.id.cannot.resolve=无法解析功能 ''{0}''
code.convert.experimental.feature.no.description=无描述
code.convert.extension.point.declaration=无法解析扩展点 ''{0}''
code.convert.notification.group.cannot.resolve=无法解析通知组 id ''{0}''
code.convert.registry.key.cannot.resolve=无法解析注册表键 ''{0}''
code.convert.registry.key.no.default.value=无默认值
code.convert.registry.key.no.description=无描述
command.create.bundle.properties=创建捆绑包 .properties 文件
command.implement.externalizable=实现可外部化
command.register.startup.activity=在 plugin.xml 中注册 ProjectActivity
command.register.state.settings=在 plugin.xml 中注册设置
compose.hot.reload.failed.to.download.compose.hot.reload.agent=无法下载 'Compose Hot Reload' 代理
compose.hot.reload.hot.reload.agent.has.been.saved=重新启动您的运行配置。Compose Hot Reload 代理已保存至 ''{0}''。
compose.hot.reload.restart.your.run.configuration=Compose Hot Reload 代理正在下载至 ''{0}''。下载完成后，请重新启动运行配置。
create.description.file=创建描述文件{0}
create.description.file.family.name=创建描述文件
deployment.cleanup=清理 {0} 目录
deployment.directory.location=选择 {0} 目录位置
deployment.title=插件部署
deployment.view.delete=确定删除{0}?
deployment.view.meta-inf.label={0} 路径
deployment.view.select=选择 {0}
descriptor.documentation.yaml.schema.display.name=描述符文档
devkit.unstable.api.usage.ignore.declared.inside.this.project=忽略此项目中声明的不稳定 API
dialog.title.new.devkit.action=新建操作
dialog.title.new.devkit.service=新建服务
dialog.title.new.devkit.startup.activity=新建项目活动
dialog.title.new.devkit.state=新建持久状态组件
error.cannot.resolve.extension.point=无法解析依赖项中的扩展点 ''{0}''
error.cannot.resolve.extension.point.missing.dependency=缺少使用扩展点 ''{0}'' 的依赖关系声明
error.cannot.resolve.extension.point.missing.dependency.fix.family.name=添加缺少的 <depends>
error.cannot.resolve.plugin=无法解析依赖项中的插件 ''{0}''
error.cannot.resolve.plugin.reference.link.title=(引用\: 插件依赖项)
error.file.not.found=找不到文件 
error.file.not.found.message=文件 ''{0}'' 不存在
error.message.cannot.find.module=找不到模块 ''{0}''
error.message.cannot.find.resource.file=在模块 ''{1}'' 中找不到 ''{0}'' 文件
error.no.plugin.xml=找不到 plugin.xml 文件
error.occurred=出错
error.plugin.xml.readonly=无法处理只读 plugin.xml 文件\: {0}
error.plugin.xml.tag.invalid=<Invalid>
extension.point.documentation.field.required.can.be.empty.suffix=(必填，允许为空)
extension.point.documentation.field.required.suffix=(必填)
extension.point.documentation.implementation.section=扩展点实现
extension.point.documentation.link.platform.explorer=在 IntelliJ Platform Explorer 中显示用法
file.templates=模板
file.templates.new.plugin=新插件
group.DevkitNewActions.text=Plugin DevKit
group.Internal.DevKit.text=DevKit
group.PluginDeployActions.text=插件部署操作
gutter.name.test.data.line.marker=测试数据
gutter.related.extension.declaration=声明
gutter.related.navigation.choose.action=选择一个操作
gutter.related.navigation.choose.action.group=选择操作组
gutter.related.navigation.choose.component=选择组件
gutter.related.navigation.choose.extension=选择扩展
gutter.related.navigation.choose.extension.point=选择扩展点
gutter.related.navigation.choose.listener=选择侦听器
gutter.related.navigation.popup.description.tooltip=描述
gutter.related.navigation.popup.template.title=选择模板
gutter.related.navigation.popup.template.tooltip=在模板前面/后面
gutter.related.option.before.after.templates=在模板前面/后面
gutter.related.option.description=描述
gutter.related.option.name=描述/在模板前面|后面
implemented.at.runtime.dom=在运行时实现的 DOM 元素
info.message=信息
inlay.threading.description=IntelliJ 平台线程处理和读/写锁相关注解，例如，<code>@RequiresEdt</code>、<code>@RequiresReadLock</code>。<br><br>实验性，仅在 IDEA 项目中启用。
inlay.threading.name=IJ 平台线程处理
inspection.action.is.not.preview.friendly.display.name=字段会阻塞意图预览
inspection.action.presentation.instantiated.in.ctor.display.name=操作演示的预先创建
inspection.action.presentation.instantiated.in.ctor.message=在构造函数中实例化的操作演示
inspection.can.be.dumb.aware.message=如果不访问索引，可以设为 DumbAware
inspection.can.be.dumb.aware.name=可以为 DumbAware
inspection.can.be.dumb.aware.quickfix.add.to.ignore=忽略 ''{0}''
inspection.can.be.dumb.aware.settings.ignore.classes.dialog.title=指定要忽略的类
inspection.can.be.dumb.aware.settings.ignore.classes.title=忽略类列表\:
inspection.cancellation.check.in.loops.display.name=循环中的取消检查
inspection.cancellation.check.in.loops.message=取消检查 ''{0}'' 应为循环体中的第一条语句
inspection.content.module.namespace.invalid=命名空间必须匹配 {0}
inspection.content.module.namespace.invalid.length=命名空间长度必须介于 5 到 30 个字符之间
inspection.content.module.namespace.mismatch=所有 ''content'' 元素必须定义相同的命名空间(第一个命名空间\: ''{0}'')
inspection.content.module.namespace.missing=具有非 private 模块的 'content' 需要命名空间
inspection.content.module.namespace.missing.fix.add.family.name=添加命名空间
inspection.content.module.namespace.missing.fix.add.name=添加 ''{0}'' 命名空间
inspection.content.module.namespace.name=内容模块命名空间验证
inspection.content.module.visibility.internal=''{0}'' 模块为 internal，并在 ''{2}'' 中的命名空间 ''{1}'' 中声明，因此无法从在 ''{5}'' 中的命名空间 ''{4}'' 中声明的模块 ''{3}'' 访问
inspection.content.module.visibility.internal.current.namespace.missing=''{0}'' 模块为 internal，并在 ''{2}'' 中的命名空间 ''{1}'' 中声明，因此无法从在 ''{4}'' 中声明但没有命名空间的模块 ''{3}'' 访问
inspection.content.module.visibility.internal.declared.in.plugin=''{0}'' 模块为 internal，并在 ''{2}'' 中的命名空间 ''{1}'' 中声明，因此无法从在命名空间 ''{4}'' 中声明的插件 ''{3}'' 访问
inspection.content.module.visibility.internal.declared.in.plugin.current.namespace.missing=''{0}'' 模块为 internal，并在 ''{2}'' 中的命名空间 ''{1}'' 中声明，因此无法从已声明但没有命名空间的插件 ''{3}'' 访问
inspection.content.module.visibility.internal.declared.in.plugin.dependency.namespace.missing=''{0}'' 模块为 internal，并在 ''{1}'' 中声明但没有命名空间，因此无法从在命名空间 ''{3}'' 中声明的插件 ''{2}'' 访问
inspection.content.module.visibility.internal.dependency.namespace.missing=''{0}'' 模块为 internal，并在 ''{1}'' 中声明但没有命名空间，因此无法从在 ''{4}'' 中的命名空间 ''{3}'' 中声明的模块 ''{2}'' 访问
inspection.content.module.visibility.internal.fix.set.namespace.family.name=设置命名空间
inspection.content.module.visibility.internal.fix.set.namespace.to=将 ''{0}'' 中的命名空间设置为 ''{1}''
inspection.content.module.visibility.name=无法访问内容模块依赖项
inspection.content.module.visibility.private=''{0}'' 模块为 private，并在插件 ''{1}'' 中声明，因此无法从在插件 ''{3}'' 中声明的模块 ''{2}'' 访问
inspection.content.module.visibility.private.accessed.from.plugin=''{0}'' 模块为 private，并在插件 ''{1}'' 中声明，因此无法从插件 ''{2}'' 访问
inspection.content.module.visibility.private.fix.change.visibility.family.name=更改模块可见性
inspection.content.module.visibility.private.fix.change.visibility.to.internal.name=将模块 ''{0}'' 设为{1}
inspection.extension.class.should.be.final.and.non.public.display.name=扩展类应为 final 和非 public
inspection.extension.class.should.be.final.text=扩展类应为 final
inspection.extension.class.should.not.be.public.service=服务实现不应设为 public。如果服务要在其模块之外使用，请从中提取一个接口，并在 plugin.xml 中将其指定为 serviceInterface。
inspection.extension.class.should.not.be.public.text=扩展类应为 public
inspection.extension.registered.as.component.message=一个类不得同时注册为扩展和组件
inspection.extension.registered.as.service.message=一个类不得同时注册为扩展和服务
inspection.extension.registered.as.service.or.component.display.name=注册为服务/组件的扩展
inspection.file.equals.usage.display.name=File.equals() 用法
inspection.incorrect.parent.disposable.display.name=不正确的 parentDisposable 形参
inspection.incorrect.service.retrieving.display.name=不正确的服务检索
inspection.incorrect.service.retrieving.mismatch.for.app.level=应用程序级服务作为项目级服务进行检索
inspection.incorrect.service.retrieving.mismatch.for.project.level=项目级服务作为应用程序级服务进行检索
inspection.incorrect.service.retrieving.not.registered=''{0}'' 类未注册为服务
inspection.insert.cancellation.check.fix.message=插入取消检查
inspection.inspection.description.not.found.inspection.display.name=检查描述检查器
inspection.inspection.unspecified.actions.place.display.name=未指定的操作位置
inspection.inspection.using.gray.colors.display.name=使用新的 Color(a,a,a)
inspection.intention.description.not.found.inspection.display.name=意图描述检查器
inspection.keymap.xml.inspection.name=按键映射 XML 有效性
inspection.light.service.migration.already.annotated.message=使用 '@Service' 注解的服务类不得在 plugin.xml 中注册
inspection.light.service.migration.app.level.fix=使用 '@Service' 注解服务类并从 'plugin.xml' 文件中移除其注册
inspection.light.service.migration.display.name=服务可被转换为轻量服务
inspection.light.service.migration.family.name=转换为轻量服务
inspection.light.service.migration.message=服务可被转换为轻量服务
inspection.light.service.migration.project.level.fix=使用 '@Service(Service.Level.PROJECT)' 注解服务类，并从 'plugin.xml' 文件中移除其注册
inspection.light.service.must.be.concrete.class.message=轻量服务必须为具体类，不能为抽象类或者为接口。\nIntelliJ 平台依靠具体的实现类来创建和管理服务实例。如果没有具体的实现，平台将无法创建服务的实例，并且该服务将不能供插件使用。\n要解决这个问题，您应该为服务定义一个具体的实现类，并使用 '@Service' 对其进行注解。
inspection.light.service.must.be.final.display.name=轻量服务必须为 final
inspection.light.service.must.be.final.message=轻量服务必须为 final
inspection.message.accessible.context.not.defined.for.jpanel=没有为 JPanel 定义可访问上下文
inspection.message.field.may.prevent.intention.preview.to.work.properly=字段可能会阻止意图预览正常工作
inspection.message.method.annotated.with.returns.value.annotated.with=使用 {0} 注解的方法返回使用 {1} 注解的值
inspection.message.return.value.without.path.annotation.where.expected=在应为 {0} 的位置，返回值缺少路径注解
inspection.message.unnecessary.safe.field.annotation=不必要的 @SafeFieldForPreview注解\: 该字段类型已被视为安全
inspection.migrate.to.opt.control.display.name=迁移到 getOptionPane()
inspection.migrate.to.opt.control.fix=转换为 OptPane
inspection.migrate.to.opt.control.message=可自动转换为 OptPane
inspection.mismatched.light.service.level.and.ctor.app.level.ctor.required=应用程序级服务需要一个无实参或 'kotlinx.coroutines.CoroutineScope' 类型的单形参构造函数
inspection.mismatched.light.service.level.and.ctor.display.name=轻量服务级别与构造函数之间的不匹配
inspection.mismatched.light.service.level.and.ctor.project.level.required=具有接受 'Project' 类型的形参的构造函数的轻量服务必须指定 '@Service(Service.Level.PROJECT)'
inspection.mismatched.light.service.level.and.ctor.specify.project.level.fix=在 '@Service' 注解中指定 'Service.Level.PROJECT' 形参
inspection.missing.accessible.context.display.name=缺少可访问上下文
inspection.missing.recent.api.display.name=在旧 IDE 中无法使用 IntelliJ API
inspection.module.not.registered.as.plugin.content.fix.add=注册为 ''{0}'' 插件的内容模块
inspection.module.not.registered.as.plugin.content.message=''{0}'' 模块未在任何插件描述符中声明为内容
inspection.module.not.registered.as.plugin.content.name=模块未在任何插件中声明为内容
inspection.non.default.constructor.display.name=服务和扩展类的非默认构造函数
inspection.path.annotation.display.name=路径注解用法问题
inspection.plugin.xml.dynamic.plugin.display.name=Plugin.xml 动态插件验证
inspection.plugin.xml.extension.registration.configurable.should.define.displayName.or.key.attribute=定义与 'Configurable.getDisplayName()' 实现匹配的 'displayName' 或 'key' 特性
inspection.plugin.xml.extension.registration.display.name=Plugin.xml 扩展程序注册
inspection.plugin.xml.extension.registration.intention.redundant.description.directory=指定的描述目录与默认目录名匹配
inspection.plugin.xml.extension.registration.should.define.externalidprefix.attribute=<html>定义 externalIdPrefix 特性，请参阅<a href\='https\://plugins.jetbrains.com/docs/intellij/stub-indexes.html?from\=PluginXmlExtensionRegistrationInspection'>存根索引</a></html>
inspection.plugin.xml.extension.registration.should.define.id.attribute=定义与 'StatusBarWidgetFactory.getId()' 实现匹配的 'id' 特性
inspection.plugin.xml.extension.registration.should.define.language.attribute=扩展 ''{0}'' 应定义 ''language'' 特性
inspection.plugin.xml.extension.registration.should.define.language.tag=扩展 ''{0}'' 应定义 ''language'' 标记
inspection.plugin.xml.extension.registration.should.define.language.tag.family.name=添加语言标记
inspection.plugin.xml.plugin.logo.display.name=插件徽标检查
inspection.plugin.xml.registration.check.display.name=plugin.xml 注册检查
inspection.plugin.xml.validity.display.name=Plugin.xml 有效性
inspection.potential.deadlock.during.service.init.display.name=服务初始化中的潜在死锁
inspection.potential.deadlock.during.service.init.message.context=({0}在 {1}中调用)
inspection.potential.deadlock.during.service.init.message.context.constructor=''{0}'' 构造函数或 init 块
inspection.potential.deadlock.during.service.init.message.context.field=''{0}'' 字段初始值设定项
inspection.potential.deadlock.during.service.init.message.context.instance.initializer=实例初始化块
inspection.potential.deadlock.during.service.init.message.context.method=''{0}'' 方法
inspection.potential.deadlock.during.service.init.message.context.static.initializer=static 初始化块
inspection.potential.deadlock.during.service.init.message.invoke.and.wait=请勿在服务初始化期间运行 ''invokeAndWait'' {0}
inspection.potential.deadlock.during.service.init.message.read=请勿在服务初始化期间运行读取操作{0}
inspection.potential.deadlock.during.service.init.message.write=请勿在服务初始化期间运行写入操作{0}
inspection.presentation.annotation.display.name=@Presentation 中的图标路径无效
inspection.product.modules.xml.display.name=Product-modules.xml 有效性
inspection.psi.element.concatenation.display.name=使用 PsiElement 字符串表示生成新表达式是不正确的
inspection.quick.fix.get.family.name.violation.display.name=QuickFix 的 getFamilyName() 实现不得依赖于特定上下文
inspection.remote.dev.missing.runtime.dependency.fix.add=添加 ''{0}'' 依赖项
inspection.remote.dev.missing.runtime.dependency.message=当前模块 ''{0}'' 的名称以 ''{1}'' 结尾，但缺少对 ''{2}'' 的依赖项
inspection.remote.dev.missing.runtime.dependency.name=缺少前端或后端运行时依赖项
inspection.renamer.dialog.description=<html>是否还要重命名检查描述文件并更改短名称?<br/><b>警告\: 它可能会破坏现有的检查配置文件和禁止注释。</b></html>
inspection.renamer.dialog.title=重命名检查描述文件并更改短名称
inspection.renamer.entity.name=元素
inspection.renamer.option.name=重命名检查描述文件并更改短名称
inspection.serializable.constructor.message=非默认构造函数应使用 @PropertyMapping 进行注解
inspection.serializable.ctor.display.name=可序列化类中的非默认构造函数
inspection.simplifiable.service.retrieving.can.be.replaced.with=可被替换为 ''{0}.{1}()'' 调用
inspection.simplifiable.service.retrieving.display.name=可简化的服务检索
inspection.simplifiable.service.retrieving.replace.with=替换为 ''{0}.{1}()'' 调用
inspection.stateful.ep.display.name=有状态扩展
inspection.threading.concurrency.display.name=线程和并发问题
inspection.threading.concurrency.option.check.missing.annotations.methods=检查 public 方法的缺失注解
inspection.threading.concurrency.option.group.inside.requires.edt=@RequiresEdt 内的检查\:
inspection.threading.concurrency.option.group.inside.requires.edt.check.requires.read.lock=@RequiresReadLock
inspection.threading.concurrency.option.group.inside.requires.edt.check.requires.write.lock=@RequiresWriteLock
inspection.threading.concurrency.violation.call.inside.method=使用 ''@{0}'' 注解的方法不得从使用 ''@{1}'' 注解的方法中调用
inspection.threading.concurrency.violation.unannotated.method.contains.call=未注解的方法调用了使用 ''@{0}'' 注解的方法
inspection.threading.concurrency.violation.unannotated.method.contains.call.multiple.annotations=未注解的方法调用了使用多线程注解的方法
inspection.token.set.in.parser.definition=ParserDefinition 中的 TokenSet 引用了非平台类
inspection.token.set.in.parser.definition.display.name=在 ParserDefinition 中声明了非平台 TokenSet
inspection.u.element.as.psi.display.name=UElement 作为 PsiElement 的用法
inspection.uast.hinted.visitor.adapter.hints.missing.hint=''{0}'' 未使用，因为适配器提示中未提供 ''{1}''
inspection.uast.hinted.visitor.adapter.hints.problem.display.name='UastHintedVisitorAdapter' 提示问题
inspection.uast.hinted.visitor.adapter.hints.redundant.hint=提示中提供了 ''{0}''，但该元素未在访问者中访问
inspection.undesirable.class.usage.display.name=不需要的类用法
inspection.unknown.id.in.meta.information.name=元信息中的未知检查 ID
inspection.unsafe.return.statement.visitor.display.name=不安全的 return 语句访问者
inspection.unsafe.vfs.recursion.display.name=不安全的 VFS 递归
inspection.use.DPI.aware.borders.display.name=使用 DPI 感知边界
inspection.use.DPI.aware.insets.display.name=使用 DPI 感知嵌入
inspection.use.JB.color.display.name=使用 Darcula 感知 JBColor
inspection.use.intellij.virtual.threads.display.name=使用 'IntelliJVirtualThreads.ofVirtual'
inspection.use.intellij.virtual.threads.fix.family.name=替换为 'IntelliJVirtualThreads.ofVirtual()'
inspection.use.intellij.virtual.threads.message=使用 'IntelliJVirtualThreads.ofVirtual()' 代替 'Thread.ofVirtual()'
inspection.use.plugin.id.equals.display.name=使用 'PluginId\#equals(Object)'
inspection.use.primitive.types.equals.display.name=将 'PsiType\#equals(Object)' 与基元类型结合使用
inspection.use.virtual.file.equals.display.name=使用 'VirtualFile\#equals(Object)'
inspections.IncorrectParentDisposableInspection.do.not.use.as.disposable=请勿在插件代码中将 {0} 用作可处置对象
inspections.IncorrectParentDisposableInspection.documentation.link.title=选择可处置的父级
inspections.action.update.thread.display.name=缺少 ActionUpdateThread
inspections.action.update.thread.message=重写 'getActionUpdateThread' 并选择 'EDT' 或 'BGT'
inspections.application.service.as.static.final.field.message=不得将应用程序服务分配给 static final 字段
inspections.application.service.as.static.final.field.or.property.display.name=指定至 static final 字段或不可变属性的应用程序服务
inspections.awt.color.used=使用了 'java.awt.Color' 而不是 'JBColor'
inspections.awt.color.used.fix.use.jb.color.constant.family.name=转换为 'JBColor' 常量
inspections.awt.color.used.fix.use.jb.color.fix.family.name=转换为 'JBColor'
inspections.calling.method.should.be.rbc.annotated=调用方法应使用 @RequresBlockingContext 进行注解
inspections.calling.method.should.be.rbc.annotated.annotate.fix=使用 '@RequiresBlockingContext' 注解调用方法
inspections.calling.method.should.be.rbc.annotated.message=调用方法应使用 '@RequiresBlockingContext' 进行注解
inspections.component.not.registered.message={0} 未在 plugin.xml 中注册
inspections.component.not.registered.name=组件/操作未注册
inspections.component.not.registered.option.check.actions=检查操作
inspections.component.not.registered.option.ignore.non.public=忽略非 public 类
inspections.component.not.registered.quickfix.error=无法注册 {0}
inspections.component.not.registered.quickfix.family=注册 {0}
inspections.component.not.registered.quickfix.name=注册 {0}
inspections.component.postfix.template.not.found.description.name=后缀模板描述检查器
inspections.file.equals.method=请勿使用 File.equals/hashCode/compareTo，因为它们在 macOS 中不区分大小写。请改用 FileUtil.filesEquals/fileHashCode/compareFiles。
inspections.group.code=代码
inspections.group.description.file=描述文件
inspections.group.descriptor=插件描述符
inspections.group.name=Plugin DevKit
inspections.group.path=Plugin DevKit
inspections.incorrect.cancellation.exception.handling.display.name=取消异常处理不正确
inspections.incorrect.cancellation.exception.handling.name.logged=''{0}'' 不得记录
inspections.incorrect.cancellation.exception.handling.name.not.rethrown=''{0}'' 必须重新抛出
inspections.incorrect.cancellation.exception.inheritor.handling.name.logged=''{0}'' 继承者不得记录
inspections.incorrect.cancellation.exception.inheritor.handling.name.not.rethrown=''{0}'' 继承者必须重新抛出
inspections.incorrect.implicit.cancellation.exception.handling.name.logged=''{0}'' 不得记录。它由 ''{1}()'' 抛出。
inspections.incorrect.implicit.cancellation.exception.handling.name.not.rethrown=''{0}'' 必须重新抛出。它由 ''{1}()'' 抛出。
inspections.incorrect.implicit.cancellation.exception.inheritor.handling.name.logged=''{0}'' 继承者不得记录。它由 ''{1}()'' 抛出。
inspections.incorrect.implicit.cancellation.exception.inheritor.handling.name.not.rethrown=''{0}'' 继承者必须重新抛出。它由 ''{1}()'' 抛出。
inspections.inspection.description.optional.short.name=检查没有描述{0}
inspections.inspection.mapping.consistency.specify.bundle=应指定捆绑包
inspections.inspection.mapping.consistency.specify.displayName.or.key=应指定 displayName 或 key
inspections.inspection.mapping.consistency.specify.groupName.or.groupKey=应指定 groupName 或 groupKey
inspections.intention.description.no.before.after.template=意图在 'description.html' 旁必须有 'before.*.template' 和 'after.*.template'
inspections.intention.description.not.found=意图没有描述
inspections.jcomponent.data.provider.display.name=JComponent 必须使用 UiDataProvider
inspections.jcomponent.data.provider.use.uidataprovider.instead.of.dataprovider=使用 UiDataProvider 而不是 DataProvider
inspections.leakable.map.key.name=映射键可能会泄漏
inspections.leakable.map.key.quick.fix.name=使用 ''{0}'' 进行形参化
inspections.leakable.map.key.text=考虑使用 ''String'' 代替 ''{0}'' 作为映射键
inspections.listener.implementation.must.not.be.disposable.name=侦听器实现实现 'Disposable'
inspections.listener.implementation.must.not.implement.disposable=侦听器实现不得实现 'Disposable'
inspections.message.first.argument.fs.getpath.should.be.annotated.with.nativepath=FileSystem.getPath() 的第一个实参应使用 @NativePath 注解
inspections.message.first.argument.path.of.should.be.annotated.with.multiroutingfilesystempath=Path.of() 的第一个实参应使用 @MultiRoutingFileSystemPath 或 @Filename 注解
inspections.message.more.parameters.in.fs.getpath.should.be.annotated.with.nativepath.or.filename=FileSystem.getPath() 中的 'more' 形参元素应使用 @NativePath 或 @Filename 注解
inspections.message.more.parameters.in.path.of.should.be.annotated.with.multiroutingfilesystempath.or.filename=Path.of() 中的 'more' 形参元素应使用 @MultiRoutingFileSystemPath 或 @Filename 注解
inspections.message.multiroutingfilesystempath.expected=在应使用 @MultiRoutingFileSystemPath 的上下文中使用了字符串字面量
inspections.message.multiroutingfilesystempath.passed.to.nativepath.method.parameter=使用 @MultiRoutingFileSystemPath 注解的字符串被传递给使用 @NativePath 注解的方法形参
inspections.message.nativepath.expected=在应使用 @NativePath 的上下文中使用了字符串字面量
inspections.message.nativepath.passed.to.multiroutingfilesystempath.method.parameter=使用 @NativePath 注解的字符串被传递给使用 @MultiRoutingFileSystemPath 注解的方法形参
inspections.message.nativepath.should.not.be.used.directly.constructing.path=使用 @NativePath 注解的字符串不应直接在 Path 构造函数或工厂方法中使用
inspections.message.string.annotated.with.passed.to.method.parameter.annotated.with=使用 {0} 注解的字符串被传递给使用 {1} 注解的方法形参
inspections.message.string.without.path.annotation.used.in.method.parameter.annotated.with=在使用 {0} 注解的方法形参中使用了不带路径注解的字符串
inspections.message.string.without.path.annotation.used.in.path.resolve.method=Path.resolve() 方法中使用了不带路径注解的字符串
inspections.meta.information.json.schema.display.name=IntelliJ 检查元信息
inspections.meta.information.unknown.inspection.id=未知检查 ID ''{0}''
inspections.missing.recent.api.class.message=''{0}'' 仅从 {1} 开始方可用，但该模块的目标是 {2}。这可能导致与 {1} 之前的 IDE 出现兼容性问题。请注意，在以前的 IDE 中，此类型可能具有其他完全限定名称。
inspections.missing.recent.api.common.message=''{0}'' 仅从 {1} 开始方可用，但该模块的目标是 {2}。这可能导致与 {1} 之前的 IDE 出现兼容性问题。
inspections.missing.recent.api.default.constructor.message=''{0}'' 的默认构造函数仅从 {1} 开始方可用，但该模块的目标是 {2}。这可能导致与 {1} 之前的 IDE 出现兼容性问题。
inspections.missing.recent.api.field.message=''{0}'' 仅从 {1} 开始方可用，但该模块的目标是 {2}。这可能导致与 {1} 之前的 IDE 出现兼容性问题。请注意，在以前的 IDE 中，此字段可能具有不同的完全签名。
inspections.missing.recent.api.method.message=''{0}'' 仅从 {1} 开始方可用，但该模块的目标是 {2}。这可能导致与 {1} 之前的 IDE 出现兼容性问题。请注意，在以前的 IDE 中，此方法可能具有不同的完全签名。
inspections.missing.recent.api.overriding=''{0}'' 的覆盖方法仅从 {1} 开始方可用，但该模块的目标是 {2}。这可能导致与 {1} 之前的 IDE 出现兼容性问题。请注意，在以前的 IDE 中，此覆盖方法可能具有不同的签名。
inspections.missing.recent.api.settings.invalid.build.number=无效构建号\: {0}
inspections.missing.recent.api.settings.range=插件兼容性范围
inspections.missing.recent.api.settings.since=自
inspections.missing.recent.api.settings.until=至
inspections.missing.recent.api.since.until.range.all.builds=所有构建
inspections.non.default.warning.and.suffix.message={0} 不应具有包含形参 {1} 的构造函数
inspections.non.default.warning.suffix.module=(模块除外)
inspections.non.default.warning.suffix.project=(项目除外)
inspections.non.default.warning.suffix.project.or.module=(如果是在相应级别请求，则项目或模块除外)
inspections.non.default.warning.type.extension=扩展
inspections.non.default.warning.type.service=服务
inspections.path.annotation.usage.problems=路径注解用法问题
inspections.plugin.xml.ComponentModuleRegistrationChecker.element.registered.wrong.module=元素应在定义其类 ''{1}'' 的 ''{0}'' 模块中注册
inspections.plugin.xml.ComponentModuleRegistrationChecker.fix.move.registration.family.name=将注册移至正确的模块
inspections.plugin.xml.ComponentModuleRegistrationChecker.fix.move.registration.name=将注册移至 {0}
inspections.plugin.xml.action.class.required.with.use.shortcut.of='class' 必须使用 'use-shortcut-of' 指定
inspections.plugin.xml.action.group.id.required=应指定 'id'
inspections.plugin.xml.action.must.override.method.with.use.shortcut.of=必须使用 ''use-shortcut-of'' 重写 {0}
inspections.plugin.xml.add.ignored.class.title=指定要忽略的类
inspections.plugin.xml.add.vendor.tag=添加 <vendor>
inspections.plugin.xml.add.version.tag=添加 <version>
inspections.plugin.xml.anchor.must.have.relative-to-action='anchor' 必须使用 'relative-to-action' 进行指定
inspections.plugin.xml.attribute.not.used.anymore=特性 ''{0}'' 不再使用
inspections.plugin.xml.change.until.build.family.name=更正 'until-build' 特性
inspections.plugin.xml.change.until.build.name=将 ''until-build'' 更改为 ''{0}''
inspections.plugin.xml.component.interface.class.redundant=冗余标记 'interface-class'
inspections.plugin.xml.dependency.class.located.in.wrong.package=类 ''{0}'' 必须位于软件包 ''{1}'' 中
inspections.plugin.xml.dependency.descriptor.at.least.one.dependency=必须至少定义一个 <module> 或 <plugin> 依赖项
inspections.plugin.xml.dependency.descriptor.cannot.use.depends=除了 <dependencies> 之外，不能使用 <depends>
inspections.plugin.xml.dependency.specify.config.file=必须指定 'config-file'
inspections.plugin.xml.dependency.superfluous.optional=多余的声明
inspections.plugin.xml.deprecated=已弃用
inspections.plugin.xml.deprecated.attribute=弃用的特性 ''{0}''
inspections.plugin.xml.deprecated.ep=弃用的扩展点 ''{0}''
inspections.plugin.xml.deprecated.ep.marked.for.removal=已标记为移除扩展点 ''{0}''
inspections.plugin.xml.deprecated.ep.marked.for.removal.in.version=已标记为移除版本 ''{1}'' 中的扩展点 ''{0}''
inspections.plugin.xml.deprecated.ep.use.replacement=弃用的扩展点 ''{0}''，请改用 ''{1}''
inspections.plugin.xml.deprecated.helpset=Helpset 已不再使用，请改用 'com.intellij.openapi.help.WebHelpProvider' 
inspections.plugin.xml.deprecated.implementation.detail=不再支持实现插件\: 使用常规插件或实现产品模块
inspections.plugin.xml.deprecated.package.attribute=不推荐且已弃用 package 特性用法，内容模块应打包到 `lib/modules/` 下的单独 jar 文件中。详情请参阅特性文档。
inspections.plugin.xml.do.not.use.template.text=不使用模板文本 ''{0}''
inspections.plugin.xml.duplicated.dependency=依赖项配置文件 ''{0}'' 重复
inspections.plugin.xml.dynamic.plugin.component.usage=由于使用组件而变成非动态的插件。
inspections.plugin.xml.dynamic.plugin.component.usage.docs.link.title=迁移指南
inspections.plugin.xml.dynamic.plugin.extension.point=非动态扩展点 ''{0}''
inspections.plugin.xml.dynamic.plugin.id.required.for.group=必须为 <group> 指定 'id'
inspections.plugin.xml.dynamic.plugin.option.highlight.usages.ep=高亮显示非动态扩展点的用法
inspections.plugin.xml.dynamic.plugin.usage.of.non.dynamic.extension.point=使用非动态扩展点 ''{0}''
inspections.plugin.xml.ep.both.beanClass.and.interface='<extensionPoint>' 不得同时指定 'interface' 特性和 'beanClass' 特性
inspections.plugin.xml.ep.both.name.and.qualifiedName='<extensionPoint>' 不得同时指定 'name' 和 'qualifiedName' 特性
inspections.plugin.xml.ep.doesnt.have.with='<extensionPoint>' 没有用于指定类字段类型的 '<with>' 标记
inspections.plugin.xml.ep.missing.beanClass.and.interface='<extensionPoint>' 必须指定 'interface' 特性或 'beanClass' 特性
inspections.plugin.xml.ep.missing.name.and.qualifiedName='<extensionPoint>' 必须指定 'name' 或 'qualifiedName' 特性
inspections.plugin.xml.ep.qualifiedName.superfluous=通过 'qualifiedName' 进行了不必要的声明
inspections.plugin.xml.ep.qualifiedName.superfluous.fix=通过 'name' 声明
inspections.plugin.xml.fix.extension.point.add.with.tag=添加 <with> 标记
inspections.plugin.xml.ignore.classes.title=注册检查忽略类列表\: 
inspections.plugin.xml.inner.class.must.be.separated.with.dollar=内部类必须用 '$' 分隔
inspections.plugin.xml.invalid.build.number=<html>无效内部版本号 ''{0}'' (<a href\="https\://plugins.jetbrains.com/docs/intellij/build-number-ranges.html?from\=DevkitPluginXmlInspection">文档</a>)</html>
inspections.plugin.xml.invalid.ep.name=名称
inspections.plugin.xml.invalid.ep.name.description=无效的扩展点 {0} ''{1}''，只能包含拉丁字符、数字和点，不能以点开头/结尾，每个片段都必须以小写字母开头，最后一个片段词不得重复任何先前的片段
inspections.plugin.xml.invalid.ep.qualifiedName=限定名称
inspections.plugin.xml.invalid.order.attribute=无效 'order' 特性值
inspections.plugin.xml.jetbrains.only.api=为 JetBrains 内部使用而保留的 API 的用法
inspections.plugin.xml.listener.does.not.inherit=''{0}'' 不是继承自 ''{1}''
inspections.plugin.xml.marked.for.removal.attribute=标记为移除特性 ''{0}''
inspections.plugin.xml.module.descriptor.at.least.one.dependency=必须至少定义一个 <module> 条目
inspections.plugin.xml.must.not.contain.template.text=不得包含模板文本 ''{0}''
inspections.plugin.xml.must.use.after.before.with.relative-to-action=''{0}''|''{1}'' 与 ''relative-to-action'' 必须一起使用
inspections.plugin.xml.no.need.to.specify.itnReporter=由 JetBrains 开发的插件中的异常会通过 ITNReporter 自动报告，无需显式指定
inspections.plugin.xml.no.plugin.icon.svg.file=<html>插件应提供 ''{0}'' (<a href\="https\://plugins.jetbrains.com/docs/intellij/plugin-icon-file.html?from\=PluginXmlPluginLogoInspection">文档</a>)</html>
inspections.plugin.xml.plugin.jetbrains.no.generic.plugin.url=作为 IntelliJ IDEA 项目的一部分开发的插件不应指定泛型插件 url
inspections.plugin.xml.plugin.jetbrains.no.idea.version=作为 IntelliJ IDEA 项目的一部分开发的插件不应指定 idea-version，因为构建脚本会自动生成
inspections.plugin.xml.plugin.jetbrains.no.version=作为 IntelliJ IDEA 项目的一部分开发的插件不应指定版本
inspections.plugin.xml.plugin.jetbrains.vendor.no.email=作为 IntelliJ IDEA 项目的一部分开发的插件不应指定电子邮箱
inspections.plugin.xml.plugin.jetbrains.vendor.no.url=作为 IntelliJ IDEA 项目的一部分开发的插件不应指定  ''{0}'' 作为 url
inspections.plugin.xml.plugin.modules.description=每一行都是包含在单个插件中的模块名称的逗号分隔列表。
inspections.plugin.xml.plugin.modules.label=多模块插件的模块\: 
inspections.plugin.xml.plugin.should.have.jetbrains.vendor=作为 IntelliJ IDEA 项目的一部分开发的插件应指定 'JetBrains' 作为其供应商
inspections.plugin.xml.product.descriptor.invalid.date=日期必须为 YYYYMMDD 整数或占位符(例如__DATE__)
inspections.plugin.xml.product.descriptor.invalid.version=版本必须为整数或占位符(例如__VERSION__)
inspections.plugin.xml.reference.id.deprecated.use.ref=改用 'ref'
inspections.plugin.xml.service.interface.class.redundant=冗余特性 'serviceInterface'
inspections.plugin.xml.since.build.could.not.determine.platform.version=无法确定目标平台版本，请检查项目设置
inspections.plugin.xml.since.build.could.not.locate.main.descriptor=无法定位主 plugin.xml 文件来确定所需的 <idea-version> 'since-build'
inspections.plugin.xml.since.build.listeners.not.available=功能仅在平台版本 {0} 或更高版本中可用，但指定的 ''since-build'' 平台为 ''{1}''
inspections.plugin.xml.since.build.listeners.os.attribute=特性 ''os'' 仅在平台版本 {0} 或更高版本中可用，但指定的 ''since-build'' 平台为 ''{1}''
inspections.plugin.xml.since.build.must.be.specified=必须指定 <idea-version> 'since-build'
inspections.plugin.xml.skipForDefaultProject.deprecated='skipForDefaultProject' 已弃用； 默认情况下，项目组件不加载到默认项目中
inspections.plugin.xml.specify.defaultExtensionNs.explicitly=显式指定 defaultExtensionNs\="{0}"
inspections.plugin.xml.synonym.both.key.and.text='<synonym>' 不得同时指定 'key' 或 'text' 特性
inspections.plugin.xml.synonym.missing.key.and.text='<synonym>' 必须指定 'key' 或 'text' 特性
inspections.plugin.xml.third.party.plugins.must.not.use.itnReporter='com.intellij.diagnostic.ITNReporter' 报告 JetBrains 的内部处理错误，不应将其用于第三方插件
inspections.plugin.xml.until.build.misleading.plain.number=''{2}'' 特性中的纯数字可能会引起误解。''{0}'' 与 ''{0}.0'' 的意义相同，因此该插件不兼容内部版本号 {0}.*。最好改为指定 ''{1}''。
inspections.plugin.xml.until.build.must.be.greater.than.since.build="{0}" 必须大于 "since-build"
inspections.plugin.xml.until.build.use.asterisk.instead.of.big.number=不在 ''{1}'' 中使用 ''{0}''，改用 ''*''
inspections.plugin.xml.usage.of.experimental.api=使用通过 @{0} 标记的 API。在日后的 IDE 版本中，可能会更改或移除此类导致兼容性问题的 API。
inspections.plugin.xml.usage.of.internal.api=使用通过 @{0} 标记的 API。不应在 IntelliJ IDEA 项目之外使用此类 API。
inspections.plugin.xml.usage.of.obsolete.api=标记为 @{0} 的 API 的用法。不应在新代码中使用此类 API。
inspections.plugin.xml.use.defaultExtensionNs=改为使用 defaultExtensionNs
inspections.plugin.xml.value.exceeds.max.length=值超过最大长度 {0}
inspections.plugin.xml.value.must.be.https.or.http.link.to.website=必须是使用 https\:// 或 http\:// 方案的有效网站链接
inspections.plugin.xml.value.must.have.minimum.length=值必须达到最小长度 {0}
inspections.plugin.xml.vendor.must.be.specified=必须指定 '<vendor>'
inspections.plugin.xml.vendor.specify.jetbrains=指定 JetBrains 作为供应商
inspections.plugin.xml.version.must.be.specified=必须指定 '<version>'
inspections.postfix.description.no.before.after.template=后缀模板在 'description.html' 旁必须有 'before.*.template' 和 'after.*.template'
inspections.postfix.description.not.found=后缀模板没有描述
inspections.presentation.cannot.resolve.icon=无法解析图标 ''{0}''
inspections.psi.element.concat.add.get.text.family.name=调用文本表示检索方法
inspections.psi.element.concat.add.get.text.name=使用 ''{0}'' 调用
inspections.psi.element.concat.psi.element=PsiElement 到字符串的可疑转换
inspections.psi.element.concat.psi.type=PsiType 到字符串的可疑转换
inspections.quick.fix.family.name=QuickFix 的 getFamilyName() 实现不得依赖于特定上下文
inspections.registration.problems.abstract=插件组件类不得为 abstract
inspections.registration.problems.component.duplicate.interface=不允许多个具有相同 'interface-class' 的组件
inspections.registration.problems.component.incompatible.interface=组件类不可分配给其接口类 ''{0}''
inspections.registration.problems.incompatible.message=根据在 plugin.xml 中的注册，该类应扩展 ''{0}''
inspections.registration.problems.missing.noarg.ctor=操作类必须具有无实参的构造函数
inspections.registration.problems.name=组件类型不匹配
inspections.registration.problems.quickfix.create.constructor=插件无实参构造函数
inspections.registration.problems.quickfix.read-only=''{0}'' 为只读类
inspections.stateful.extension.point.do.not.use.in.extension=请勿在扩展中将 {0} 用作字段
inspections.stateful.extension.point.do.not.use.in.quick.fix=请勿在快速修复中将 {0} 用作字段
inspections.stateful.extension.point.leak.psi.element=潜在的内存泄漏\: 请勿保持 PsiElement，改用 SmartPsiElementPointer
inspections.stateful.extension.point.leak.psi.element.quick.fix=另请参阅 LocalQuickFixOnPsiElement。
inspections.static.initialization.in.extensions.message=扩展点实现不得使用 static 初始化
inspections.static.initialization.in.extensions.name=扩展点实现中的 static 初始化
inspections.statistics.collector.not.registered.message=统计信息收集器未在 plugin.xml 中注册
inspections.statistics.collector.not.registered.name=统计信息收集器未注册
inspections.undesirable.class.use.instead=请改用 ''{0}''
inspections.unresolved.plugin.config.reference=未解析的插件配置引用
inspections.unsafe.return.insert.family.name=跳过匿名/局部类
inspections.unsafe.return.insert.visit.class.method=插入 visitClass 方法
inspections.unsafe.return.insert.visit.lambda.expression=插入 visitLambdaExpression 方法
inspections.unsafe.return.insert.visit.lambda.expression.and.class.methods=插入 visitLambdaExpression/visitClass 方法
inspections.unsafe.return.message=具有 'visitReturnStatement' 的递归访问者最有可能应当专门处理匿名/局部类 ('visitClass') 以及 lambda 表达式('visitLambdaExpression')
inspections.unsafe.vfs.recursion=从递归方法调用的 'VirtualFile.getChildren()'
inspections.unspecified.actions.place.popup.menu=未指定的操作弹出菜单位置
inspections.unspecified.actions.place.toolbar=未指定的操作工具栏位置
inspections.usage.uelement.as.psi=不建议将 UElement 用作 PsiElement
inspections.use.dpi.aware.empty.border.can.be.simplified=可以简化空边框创建
inspections.use.dpi.aware.empty.border.convert.fix.name=转换为 'JBUI.Borders.empty(…)'
inspections.use.dpi.aware.empty.border.not.dpi.aware='EmptyBorder' 非 DPI 感知
inspections.use.dpi.aware.empty.border.simplify.fix.name=简化
inspections.use.dpi.aware.insets.can.be.simplified=Insets 创建可以简化
inspections.use.dpi.aware.insets.convert.fix.name=转换为 'JBUI.insets(...)'
inspections.use.dpi.aware.insets.not.dpi.aware='Insets' 非 DPI 感知
inspections.use.dpi.aware.insets.simplify.fix.name=简化
inspections.use.equals.description=应比较 ''{0}'' 实例是否相等，而不是是否相同
inspections.use.equals.fix.replace.equality.with.equals.family.name=将相等运算符替换为 'equals()'
inspections.use.equals.fix.replace.equality.with.equals.name=将 ''{0}'' 替换为 ''equals()''
inspections.use.equals.fix.replace.equality.with.not.equals.name=将 ''{0}'' 替换为 ''\!equals()''
inspections.use.gray.awt.color.used.name=用于灰色的 'java.awt.Color'
inspections.use.gray.fix.convert.family.name=转换为 'Gray'
inspections.use.gray.fix.convert.name=转换为 ''Gray._{0}''
inspections.wrap.application.service.in.supplier.quick.fix.message=将应用程序服务包装在 'java.util.function.Supplier' 中
intellij.api.annotations.update.task.title=更新 IntelliJ API 注解 {0}
invalid.order.attribute.part=''order'' 特性值部分无效\: ''{0}''，必须为 ''first''、''last''、''before <id>'' 或 ''after <id>''
line.marker.descriptors.including.content.module.name=包含此内容模块的描述符
line.marker.descriptors.including.content.module.popup.title=包含此内容模块的描述符
line.marker.descriptors.including.content.module.tooltip=''{0}'' 内容模块包含在 {1} 个插件 XML 描述符中
line.marker.related.property.description=相关属性
line.marker.related.property.popup.title=相关属性
line.marker.related.property.tooltip=相关属性
list.item.an.action=操作
list.item.applications.service=应用程序服务
list.item.applications.state=应用程序设置
list.item.background.activity=后台活动
list.item.immediate.activity=即时活动
list.item.project.service=项目服务
list.item.project.state=项目设置
list.item.toggle.action=切换操作
manifest.selection=选定的 {0} 将包含在得到的分发中
manifest.settings=清单设置
manifest.use.user.defined=使用用户清单\: 
message.bundle.convert.advanced.setting.id.cannot.resolve=无法解析高级设置 ID ''{0}''
message.bundle.convert.toolwindow.id.cannot.resolve=无法解析工具窗口 ID ''{0}''
module.builder.github.template.link=功能齐全的 GitHub 模板
module.builder.how.to.link=如何为基于 IntelliJ 的 IDE 构建插件
module.builder.title=IDE 插件
module.builder.type=类型\:
module.builder.type.plugin=插件
module.builder.type.theme=主题
module.description=插件模块用于开发基于 <b>IntelliJ 平台</b>的 IDE 的插件。<br>它们提供 <b>IntelliJ 平台插件 SDK </b>和<b>运行配置</b>，用于在 IDE 中运行和调试插件。
module.title=IntelliJ 平台插件
module.wizard.gradle.plugin.xml.template.display.name=基于 Gradle 的项目中的 plugin.xml
new.action.action.name=正在创建新操作\: {0}。{1}
new.action.add.to.group=添加到组
new.action.cannot.create.class=无法创建操作类
new.action.class.name=类名(&C)\:
new.action.description=描述(&D)\:
new.action.dialog.title=新操作
new.action.error=无法创建操作
new.action.group.actions=操作(&I)\:
new.action.group.anchor=定位标记\:
new.action.group.anchor.=最后一个(&L)
new.action.group.anchor.after=后面(&T)
new.action.group.anchor.before=之前 (&B)
new.action.group.anchor.first=第一个(&F)
new.action.group.groups=组(&G)\:
new.action.id=操作 ID(&A)\:
new.action.invalid.class.name=操作类名不是有效的 Java 限定名称
new.action.invalid.id=操作 ID 不得为空
new.action.invalid.name=操作名称不得为空
new.action.keyboard.clear=X
new.action.keyboard.clear.tooltip=清除快捷键
new.action.keyboard.first=第一\: 
new.action.keyboard.second=第二\: 
new.action.keyboard.shortcuts=键盘快捷键
new.action.text=名称(&N)\:
new.menu.action.text=操作
new.menu.application.component.text=应用程序组件
new.menu.module.component.text=模块组件
new.menu.project.component.text=项目组件
notification.group.devkit.deployment=插件部署已完成
notification.group.testdata=找不到测试数据文件
notification.message.duplicate.packages.file=项目中的软件包列表文件过多\:\n{0}
plugin.descriptor=IntelliJ 平台插件描述符
plugin.descriptor.chooser.cannot.find=找不到插件描述符
plugin.descriptor.chooser.popup.title=选择插件描述符
plugin.xml.convert.action.or.group.cannot.resolve=无法解析{0} ''{1}''
plugin.xml.convert.action.or.group.invalid.name=<invalid name>
plugin.xml.convert.action.or.group.type.action=操作
plugin.xml.convert.action.or.group.type.action.or.group=操作或组
plugin.xml.convert.action.or.group.type.group=组
plugin.xml.convert.enum.cannot.resolve=无法解析{1}中的 ''{0}''
plugin.xml.convert.extension.order.cannot.resolve=无法解析 '''''{'0'}''''' {0} 扩展
plugin.xml.convert.extension.property.cannot.resolve=无法解析扩展点属性 ''{0}''
plugin.xml.convert.keymap.cannot.resolve=无法解析按键映射 ''{0}''
plugin.xml.convert.language.id.any.language.display.name=<any language>
plugin.xml.convert.language.id.cannot.resolve=无法解析 ID 为 ''''{0}'''' 的语言
plugin.xml.convert.module.descriptor.name=无法解析源和库根中的模块描述符 ''{0}''
plugin.xml.convert.property.bundle.cannot.resolve=无法解析属性捆绑包
plugin.xml.scopes.display.name=插件描述符文件
plugin.xml.scopes.production.display.name=所有生产插件描述符文件
plugins.database.description=数据库工具窗口、控制台和 SQL
plugins.go.description=Go 语言
plugins.java.description=适用于 Java、Kotlin、Groovy 和 Scala 的 JVM 平台 API
plugins.javascript.description=JavaScript、TypeScript、JSX 和 TSX 文件
plugins.json.description=JSON 语言和 JSON 架构验证
plugins.kotlin.description=Kotlin 插件
plugins.markdown.description=Markdown 语言和预览 UI
plugins.php.description=PHP 语言
plugins.properties.description=属性文件
plugins.python.description=Python 语言
plugins.ruby.description=Ruby 语言
plugins.rust.description=Rust 语言
plugins.xml.description=XML 语言和 DOM API
plugins.yaml.description=YAML 语言
prepare.for.deployment=为部署准备插件模块 ''{0}''
prepare.for.deployment.all=为部署准备所有插件模块
prepare.for.deployment.task=进行插件模块 ''{0}'' 部署准备
prepare.for.deployment.task.progress=正在进行部署准备
program.parameters=程序实参(&P)
progress.title.calculate.target.properties.file=正在计算目标属性文件
register.extension.fix.name=注册扩展
register.extension.fix.popup.title=选择扩展点
register.inspection.fix.family.name=注册检查
register.inspection.fix.name=注册检查 ''{0}''
registry.properties.annotator.add.description.family.name=添加描述键
registry.properties.annotator.add.description.text=添加 ''{0}'' 的描述键
registry.properties.annotator.key.no.description.key=键 ''{0}'' 没有描述键
registry.properties.annotator.plugin.keys.use.ep=特定于插件的键应通过 'com.intellij.registryKey' 扩展点进行注册
registry.properties.annotator.show.ep.family.name=显示扩展点声明
registry.properties.annotator.show.ep.message=将此声明复制到您的插件描述符 XML 中
registry.properties.annotator.show.ep.name=显示 ''{0}'' 的扩展点声明
registry.properties.annotator.show.ep.title=扩展点声明
run.configuration.no.module.specified=未为配置指定插件模块
run.configuration.title=插件
run.configuration.type.description=插件沙盒环境
sandbox.home=沙盒主页
sandbox.home.label=沙盒主页\: 
sandbox.no.configured=未为 IntelliJ 平台插件 SDK 指定沙盒
sandbox.no.sdk=请配置 SDK
sandbox.purpose=浏览文件夹以放置目标 IDE 的配置、系统和插件
sandbox.specification=请配置沙盒
saved.message=模块 ''{1}'' 的 {0, choice, 1\#Zip|2\#JAR} 文件保存至 {2}
saved.message.common={0} 将保存在所选目录中
sdk.from.sources.scanning.roots=正在扫描根
sdk.no.idea.sdk.version.found=未能检测出 IntelliJ 平台插件 SDK 所需的 JDK 版本。
sdk.no.java.sdk.for.idea.sdk.found=找不到合适的 Java SDK 版本。除了 IntelliJ 平台插件 SDK，还需要定义具有相同 Java 版本({0})的 JDK。
sdk.no.java.sdk.for.idea.sdk.found.title=未找到 Java SDK
sdk.no.specified=未为插件模块 ''{0}'' 指定 SDK 
sdk.select.java.sdk=选择要用于 IntelliJ 平台插件 SDK 的 Java SDK
sdk.select.java.sdk.label=内部 Java 平台\:
sdk.select.java.sdk.title=选择内部 Java 平台
sdk.title=IntelliJ 平台插件 SDK
sdk.type.incorrect=插件模块 ''{0}'' 的 SDK 类型错误。
sdk.type.incorrect.common=插件模块的 SDK 类型错误
select.plugin.module.to.patch=选择要修补的插件模块
select.plugin.modules.description=选择要准备部署的模块
select.plugin.modules.title=选择模块
select.target.location.of.description=选择 {0} 的目标位置
structure.sort.alphabetically.in.groups=在组中按字母顺序排序
structure.sort.alphabetically.in.groups.description=在组中按字母顺序排序
success.deployment.message=已成功进行插件模块 ''{0}'' 部署准备
success.deployment.message.all=已成功进行所有插件的部署准备
suggest.to.delete=是否删除 ''{0}''?
testdata.confirm.create.missing.files.dialog.message=将创建以下 testdata 文件\: \n{0}
testdata.create.dialog.title=创建 Testdata 文件
testdata.create.missing.files=创建缺少的文件
testdata.file.doesn.not.exist=<html>所引用的 testdata 文件 {0} 不存在。是否要创建?</html>
testdata.goto.test.data.action.text=转到 {0}
testdata.notification.no.test.datafiles.content=找不到类的测试数据文件
testdata.notification.no.test.datafiles.title=未找到测试数据文件
testdata.popup.navigation.title=测试数据
testdata.progress.text.searching.for.test.data.files=正在搜索 ''{0}'' 测试数据文件…
testdata.related.navigation.group=测试数据
testdata.related.navigation.title=测试数据
testdata.searching=正在搜索测试数据文件
update.ide.from.sources=从源更新 IDE(&I)
update.ide.from.sources.option=从源
usage.type.module.in.content=在内容中
usage.type.module.in.dependencies=在依赖项中
vm.parameters=虚拟机选项(&V)

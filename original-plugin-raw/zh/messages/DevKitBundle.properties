#module type
module.title=IntelliJ 平台插件
module.description=插件模块用于开发基于 <b>IntelliJ 平台</b>的 IDE 的插件。<br>它们提供 <b>IntelliJ 平台插件 SDK </b>和<b>运行配置</b>，用于在 IDE 中运行和调试插件。
plugin.descriptor=IntelliJ 平台插件描述符

#Gradle wizard
module.wizard.gradle.presentable.name=IntelliJ 平台插件
module.wizard.gradle.learn.title=了解如何<a>使用 Gradle 构建插件</a>
module.wizard.gradle.plugin.xml.template.display.name=基于 Gradle 的项目中的 plugin.xml

module.wizard.devkit.simple.plugin.label=<html>对于简单的插件(例如自定义 UI 主题)，建议使用此项目类型。<br>对于更复杂的插件，<a href="https://plugins.jetbrains.com/docs/intellij/getting-started.html?from=DevkitPluginModuleWizard">建议</a>使用基于 Gradle 的项目。

convert.devkit.to.gradle.notification=将 DevKit 插件迁移到 Gradle
convert.devkit.to.gradle.notification.content=建议为此项目使用基于 Gradle 的设置。
convert.devkit.to.gradle.notification.link.title=迁移指南
convert.devkit.to.gradle.notification.do.not.show.again=不再显示

group.PluginDeployActions.text=插件部署操作

#Module Editor - Deployment
deployment.title=插件部署
deployment.cleanup=清理 {0} 目录
deployment.directory.location=选择 {0} 目录位置
deployment.view.select=选择 {0}
manifest.settings=清单设置
manifest.selection=选定的 {0} 将包含在得到的分发中
manifest.use.user.defined=使用用户清单: 
deployment.view.delete=确定删除{0}?
deployment.view.meta-inf.label={0} 路径
suggest.to.delete=是否删除 ''{0}''?
vm.parameters=VM 选项(&V)
program.parameters=程序实参(&P)

#Prepare for deployment action
action.MakeJarAction.text=准备部署
action.MakeAllJarsAction.text=准备所有要部署的插件
select.plugin.modules.title=选择模块
select.plugin.modules.description=选择要准备部署的模块
prepare.for.deployment.task=进行插件模块 ''{0}'' 部署准备
prepare.for.deployment.task.progress=正在进行部署准备
prepare.for.deployment=为部署准备插件模块 ''{0}''
prepare.for.deployment.all=为部署准备所有插件模块
saved.message.common={0} 将保存在所选目录中
saved.message= 模块 ''{1}'' 的 {0, choice, 1#Zip|2#JAR} 文件保存至 {2}
success.deployment.message=已成功进行插件模块 ''{0}'' 部署准备
success.deployment.message.all=已成功进行所有插件的部署准备

##Idea Sdk
sdk.title=IntelliJ 平台插件 SDK
sdk.select.java.sdk=选择要用于 IntelliJ 平台插件 SDK 的 Java SDK
sdk.select.java.sdk.label=内部 Java 平台:
sdk.select.java.sdk.title=选择内部 Java 平台
sdk.no.java.sdk.for.idea.sdk.found=找不到合适的 Java SDK 版本。除了 IntelliJ 平台插件 SDK，还需要定义具有相同 Java 版本 ({0}) 的 JDK。
sdk.no.idea.sdk.version.found=未能检测出 IntelliJ 平台插件 SDK 所需的 JDK 版本。
sdk.no.java.sdk.for.idea.sdk.found.title=未找到 Java SDK
sdk.from.sources.scanning.roots=正在扫描根

sandbox.specification=请配置沙盒
sandbox.home=沙盒主页
sandbox.home.label=沙盒主页: 
sandbox.no.configured=未为 IntelliJ 平台插件 SDK 指定沙盒
sandbox.no.sdk=请配置 SDK
sandbox.purpose=浏览文件夹以放置目标 IDE 的配置、系统和插件

#errors
error.occurred=出错
sdk.no.specified=未为插件模块 ''{0}'' 指定 SDK 
sdk.type.incorrect=插件模块 ''{0}'' 的 SDK 类型错误。
sdk.type.incorrect.common=插件模块的 SDK 类型错误
error.file.not.found=找不到文件 
error.file.not.found.message=文件 ''{0}'' 不存在
error.no.plugin.xml=找不到 plugin.xml 文件
error.plugin.xml.readonly=无法处理只读 plugin.xml 文件: {0}
error.plugin.xml.tag.invalid=<Invalid>

#run configurations
run.configuration.no.module.specified=未为配置指定插件模块
run.configuration.title=插件
run.configuration.type.description=插件沙盒环境

#Test Data
testdata.create.dialog.title=创建 Testdata 文件
testdata.file.doesn.not.exist=<html>所引用的 testdata 文件 {0} 不存在。是否要创建?</html>
testdata.create.missing.files=创建缺少的文件
testdata.confirm.create.missing.files.dialog.message=将创建以下 testdata 文件: \n{0}
testdata.searching=正在搜索测试数据文件
testdata.goto.test.data.action.text=转到 {0}
testdata.notification.no.test.datafiles.title=未找到测试数据文件
testdata.notification.no.test.datafiles.content=找不到类的测试数据文件
testdata.progress.text.searching.for.test.data.files=正在搜索 ''{0}'' 测试数据文件…

#Misc
info.message=信息
new.action.id=操作 ID(&A):
new.action.description=描述(&D):
new.action.class.name=类名(&C):
new.action.text=名称(&N):
new.action.add.to.group=添加到组
new.action.group.actions=操作(&I):
new.action.group.anchor=定位标记:
new.action.group.anchor.first=第一个(&F)
new.action.group.anchor.=最后一个(&L)
new.action.group.anchor.before=之前 (&B)
new.action.group.anchor.after=后面(&T)
new.action.group.groups=组(&G):
new.action.keyboard.shortcuts=键盘快捷键
new.action.keyboard.first=第一: 
new.action.keyboard.second=第二: 
new.action.keyboard.clear=X
new.action.keyboard.clear.tooltip=清除快捷键
new.action.invalid.id=操作 ID 不得为空
new.action.invalid.class.name=操作类名不是有效的 Java 限定名称
new.action.invalid.name=操作名称不得为空
new.action.cannot.create.class=无法创建操作类

command.implement.externalizable=实现可外部化

new.menu.action.text=操作
new.action.error=无法创建操作
new.action.action.name=正在创建新操作: {0}。{1}
new.action.dialog.title=新操作

action.DevKit.NewMessageBundle.action.name.create.new.message.bundle=创建新消息捆绑包 ''{0}''
action.DevKit.NewMessageBundle.error.title.cannot.create.new.message.bundle=无法创建新消息捆绑包
action.DevKit.NewMessageBundle.text=消息捆绑包
action.DevKit.NewMessageBundle.description=创建新的消息捆绑包类和相应的属性文件
action.DevKit.NewMessageBundle.title.create.new.message.bundle=创建新消息包 '''' 
action.DevKit.NewMessageBundle.label.bundle.name=包名称: 
action.DevKit.NewMessageBundle.error.message.multiple.content.roots.for.module={0} 有多个内容根
action.DevKit.NewMessageBundle.error.message.under.sources.root={0} 在源根下
action.DevKit.NewMessageBundle.error.message.folder.already.exists={1} 下已存在 ''{0}'' 文件夹
action.DevKit.NewMessageBundle.error.message.do.not.put.bundle.to.impl.module=目前不建议为 .impl 模块创建单独的包，请改为使用相应 API 模块中的包
action.DevKit.NewMessageBundle.notification.title.cannot.create.resources.root.for.properties.file=无法创建新消息包
action.DevKit.NewMessageBundle.notification.content.cannot.create.resources.root.for.properties.file=无法为属性文件 {0} 创建资源根


## theming
theme.highlighting.unresolved.key=未解析键 ''{0}''
theme.highlighting.deprecated.key=已弃用键 ''{0}''
theme.choose.color.tooltip=选择颜色
theme.choose.color.dialog.title=选择颜色

theme.json.display.name=IntelliJ 主题
theme.metadata.json.display.name=IntelliJ 主题元数据

theme.json.documentation.key.deprecated=已弃用
theme.json.documentation.key.no.description=(无描述)
theme.json.documentation.section.source.title=源:
theme.json.documentation.section.since.title=自:

new.theme.dialog.title=创建新主题
new.theme.dialog.name.text.field.text=名称:
new.theme.dialog.is.dark.checkbox.text=深色主题
new.theme.dialog.name.empty=主题名称不得为空


new.menu.application.component.text=应用程序组件
new.menu.module.component.text=模块组件
new.menu.project.component.text=项目组件

select.plugin.module.to.patch=选择要修补的插件模块

keyword.extend=扩展
keyword.implement=实现
class.action=操作
class.interface=接口
class.implementation=实现

structure.sort.alphabetically.in.groups=在组中按字母顺序排序
structure.sort.alphabetically.in.groups.description=在组中按字母顺序排序

inspections.group.name=Plugin DevKit
inspections.group.descriptor=插件描述符
inspections.group.description.file=描述文件
inspections.group.code=代码
inspections.group.path=Plugin DevKit
inspections.plugin.xml.inner.class.must.be.separated.with.dollar=内部类必须用 '$' 分隔
inspections.plugin.xml.plugin.should.have.jetbrains.vendor=作为 IntelliJ IDEA 项目的一部分开发的插件应指定 'JetBrains' 作为其供应商
inspections.plugin.xml.plugin.jetbrains.vendor.no.url=作为 IntelliJ IDEA 项目的一部分开发的插件不应指定  ''{0}'' 作为 url
inspections.plugin.xml.plugin.jetbrains.vendor.no.email=作为 IntelliJ IDEA 项目的一部分开发的插件不应指定电子邮箱
inspections.plugin.xml.plugin.jetbrains.no.version=作为 IntelliJ IDEA 项目的一部分开发的插件不应指定版本
inspections.plugin.xml.plugin.jetbrains.no.idea.version=作为 IntelliJ IDEA 项目的一部分开发的插件不应指定 idea-version，因为构建脚本会自动生成
inspections.plugin.xml.plugin.jetbrains.no.change.notes=作为 IntelliJ IDEA 项目的一部分开发的插件不应指定 change-notes
inspections.plugin.xml.plugin.jetbrains.no.generic.plugin.url=作为 IntelliJ IDEA 项目的一部分开发的插件不应指定泛型插件 url
inspections.plugin.xml.ep.qualifiedName.superfluous=通过 'qualifiedName' 进行了不必要的声明
inspections.plugin.xml.ep.qualifiedName.superfluous.fix=通过 'name' 声明
inspections.plugin.xml.ep.doesnt.have.with=<extensionPoint> 没有<with>标记用于指定类字段的类型
inspections.plugin.xml.ep.both.beanClass.and.interface=<extensionPoint>不能同时指定 'interface' 特性和 'beanClass' 特性
inspections.plugin.xml.ep.missing.beanClass.and.interface=<extensionPoint>必须指定 'interface' 特性或 'beanClass' 特性
inspections.plugin.xml.ep.both.name.and.qualifiedName=<extensionPoint>不能同时指定 'name' 特性和 'qualifiedName' 特性
inspections.plugin.xml.ep.missing.name.and.qualifiedName=<extensionPoint>必须指定 'name' 特性或 'qualifiedName' 特性
inspections.plugin.xml.synonym.missing.key.and.text=<synonym> 必须指定 'key' 或 'text' 特性
inspections.plugin.xml.synonym.both.key.and.text=<synonym> 不得同时指定 'key' 或 'text' 特性
inspections.plugin.xml.use.defaultExtensionNs=改为使用 defaultExtensionNs
inspections.plugin.xml.specify.defaultExtensionNs.explicitly=显式指定 defaultExtensionNs="{0}"
inspections.plugin.xml.invalid.build.number=<html>无效内部版本号 ''{0}'' (<a href="https://plugins.jetbrains.com/docs/intellij/build-number-ranges.html?from=DevkitPluginXmlInspection">文档</a>)</html>
inspections.plugin.xml.until.build.use.asterisk.instead.of.big.number=不在 ''until-build'' 中使用 ''{0}''，改用 ''*''
inspections.plugin.xml.until.build.misleading.plain.number=''until-build'' 特性中的纯数字可能会引起误解。''{0}'' 与 ''{0}.0'' 的意义相同，因此该插件不兼容内部版本号 {0}.*。最好改为指定 ''{1}''。
inspections.plugin.xml.until.build.must.be.greater.than.since.build="until-build" 必须大于 "since-build"
inspections.plugin.xml.dependency.superfluous.optional=多余的声明
inspections.plugin.xml.dependency.specify.config.file=必须指定 'config-file'
inspections.plugin.xml.deprecated.ep=弃用的扩展点 ''{0}''
inspections.plugin.xml.deprecated.ep.use.replacement=弃用的扩展点 ''{0}''，请改用 ''{1}''
inspections.plugin.xml.deprecated.ep.marked.for.removal.in.version=已标记为移除版本 ''{1}'' 中的扩展点 ''{0}''
inspections.plugin.xml.no.need.to.specify.itnReporter=由 JetBrains 开发的插件中的异常会通过 ITNReporter 自动报告，无需显式指定
inspections.plugin.xml.third.party.plugins.must.not.use.itnReporter='com.intellij.diagnostic.ITNReporter' 报告 JetBrains 的内部处理错误，不应将其用于第三方插件
inspections.plugin.xml.deprecated.attribute=弃用的特性 ''{0}''
inspections.plugin.xml.deprecated.helpset=Helpset 已不再使用，请改用 'com.intellij.openapi.help.WebHelpProvider' 
inspections.plugin.xml.attribute.not.used.anymore=特性 ''{0}'' 不再使用
inspections.plugin.xml.anchor.must.have.relative-to-action='anchor' 必须使用 'relative-to-action' 进行指定
inspections.plugin.xml.must.use.after.before.with.relative-to-action=''{0}''|''{1}'' 与 ''relative-to-action'' 必须一起使用
inspections.plugin.xml.skipForDefaultProject.deprecated='skipForDefaultProject' 已弃用； 默认情况下，项目组件不加载到默认项目中
inspections.plugin.xml.invalid.ep.name.description=无效的扩展点 {0} ''{1}''，只能包含拉丁字符、数字和点，不能以点开头/结尾，每个片段都必须以小写字母开头，最后一个片段词不得重复任何先前的片段
inspections.plugin.xml.invalid.ep.name=名称
inspections.plugin.xml.invalid.ep.qualifiedName=限定名称
inspections.plugin.xml.ignore.classes.title=注册检查忽略类列表: 
inspections.plugin.xml.add.ignored.class.title=指定要忽略的类
inspections.plugin.xml.plugin.modules.label=多模块插件的模块: 
inspections.plugin.xml.plugin.modules.description=每行指定单独一个插件中包含的模块名称列表，这些名称以逗号分隔。
inspections.plugin.xml.version.must.be.specified=必须指定 <version>
inspections.plugin.xml.vendor.must.be.specified=必须指定 <vendor>
inspections.plugin.xml.do.not.use.template.text=不使用模板文本 ''{0}''
inspections.plugin.xml.must.not.contain.template.text=不得包含模板文本 ''{0}''
inspections.plugin.xml.value.exceeds.max.length=值超过最大长度 {0}
inspections.plugin.xml.value.must.have.minimum.length=值必须达到最小长度 {0}
inspections.plugin.xml.product.descriptor.invalid.date=日期必须为 YYYYMMDD 整数或占位符(例如__DATE__)
inspections.plugin.xml.product.descriptor.invalid.version=版本必须为整数或占位符(例如__VERSION__)
inspections.plugin.xml.no.plugin.icon.svg.file=<html>插件应提供 ''{0}'' (<a href="https://plugins.jetbrains.com/docs/intellij/plugin-icon-file.html?from=DevkitPluginXmlInspection">文档</a>)</html>
inspections.plugin.xml.component.interface.class.redundant=冗余标记 'interfaceClass'
inspections.plugin.xml.service.interface.class.redundant=冗余特性 'serviceInterface'
inspections.plugin.xml.duplicated.dependency=依赖项配置文件 ''{0}'' 重复
inspections.plugin.xml.ComponentModuleRegistrationChecker.element.registered.wrong.module=元素应在定义其类 ''{1}'' 的 ''{0}'' 模块中注册
inspections.plugin.xml.ComponentModuleRegistrationChecker.fix.move.registration.name=将注册移至 {0}
inspections.plugin.xml.ComponentModuleRegistrationChecker.fix.move.registration.family.name=将注册移至正确的模块
inspections.plugin.xml.fix.extension.point.add.with.tag=添加 <with> 标记
inspections.plugin.xml.listener.does.not.inherit=''{0}'' 不是继承自 ''{1}''
inspections.plugin.xml.since.build.could.not.locate.main.descriptor=无法定位主 plugin.xml 文件来确定所需的 <idea-version> 'since-build'
inspections.plugin.xml.since.build.must.be.specified=必须指定 <idea-version> 'since-build'
inspections.plugin.xml.since.build.could.not.determine.platform.version=无法确定目标平台版本，请检查项目设置
inspections.plugin.xml.since.build.listeners.os.attribute=特性 ''os'' 仅在平台版本 {0} 或更高版本中可用，但指定的 ''since-build'' 平台为 ''{1}''
inspections.plugin.xml.since.build.listeners.not.available=功能仅在平台版本 {0} 或更高版本中可用，但指定的 ''since-build'' 平台为 ''{1}''
inspections.plugin.xml.action.group.id.required=应指定 'id'
inspections.plugin.xml.action.class.required.with.use.shortcut.of='class' 必须使用 'use-shortcut-of' 指定
inspections.plugin.xml.action.must.override.method.with.use.shortcut.of=必须使用 ''use-shortcut-of'' 重写 {0}
inspections.plugin.xml.jetbrains.only.api=为 JetBrains 内部使用而保留的 API 的用法
inspections.plugin.xml.usage.of.experimental.api=使用通过 @{0} 标记的 API。在日后的 IDE 版本中，可能会更改或移除此类导致兼容性问题的 API。
inspections.plugin.xml.usage.of.internal.api=使用通过 @{0} 标记的 API。不应在 IntelliJ IDEA 项目之外使用此类 API。
inspections.plugin.xml.vendor.specify.jetbrains=指定 JetBrains 作为供应商
inspections.plugin.xml.change.until.build.name=将 ''until-build'' 更改为 ''{0}''
inspections.plugin.xml.change.until.build.family.name=更正 'until-build' 特性
inspections.plugin.xml.deprecated=已弃用
inspections.plugin.xml.add.version.tag=添加 <version>
inspections.plugin.xml.add.vendor.tag=添加 <vendor>
inspections.plugin.xml.module.descriptor.package.does.not.match=软件包 ''{0}'' 与模块描述符 ''{2}'' 中指定的软件包 ''{1}'' 不匹配
inspections.plugin.xml.module.descriptor.at.least.one.dependency=必须至少定义一个 <module> 条目
inspections.plugin.xml.dependency.descriptor.at.least.one.dependency=必须至少定义一个 <module> 或 <plugin> 依赖项
inspections.plugin.xml.dependency.class.located.in.wrong.package=类 ''{0}'' 必须位于软件包 ''{1}'' 中

inspections.registration.problems.name=组件类型不匹配
inspections.registration.problems.option.check.plugin.xml=检查插件描述符 (plugin.xml)
inspections.registration.problems.option.check.java.actions=检查 Java 操作
inspections.registration.problems.option.check.java.code=检查 Java 代码
inspections.registration.problems.quickfix.read-only=''{0}'' 为只读类
inspections.registration.problems.quickfix.create.constructor=插件非实参构造函数

inspections.registration.problems.incompatible.message=根据它在 plugin.xml 中的注册，此类应为 {0} ''{1}''
inspections.registration.problems.abstract=插件组件类不得为 abstract
inspections.registration.problems.missing.noarg.ctor=操作类必须具有无实参的构造函数

inspections.registration.problems.missing.implementation.class=缺少实现类
inspections.registration.problems.cannot.resolve.class=无法解析 {0} 类
inspections.registration.problems.component.incompatible.interface=组件类不可分配给其接口类 ''{0}''
inspections.registration.problems.component.duplicate.interface=不允许多个组件有相同的接口类
inspections.registration.problems.action.incompatible.class=操作类必须扩展 ''{0}''

inspections.component.not.registered.name=组件/操作未注册
inspections.component.not.registered.message={0} 未在 plugin.xml 中注册
inspections.component.not.registered.option.check.actions=检查操作
inspections.component.not.registered.option.ignore.non.public=忽略非 public 类
inspections.component.not.registered.quickfix.family=注册 {0}
inspections.component.not.registered.quickfix.name=注册 {0}
inspections.component.not.registered.quickfix.error=无法注册 {0}
inspections.statistics.collector.not.registered.name=统计信息收集器未注册
inspections.statistics.collector.not.registered.message=统计信息收集器未在 plugin.xml 中注册

inspections.component.postfix.template.not.found.description.name=后缀模板描述检查器

inspections.presentation.cannot.resolve.icon=无法解析图标 ''{0}''
inspections.plugin.xml.invalid.order.attribute=无效 'order' 特性值
invalid.order.attribute.part=''order'' 特性值部分无效: ''{0}''，必须为 ''first''、''last''、''before <id>'' 或 ''after <id>''

inspections.unregistered.named.color=<html>命名颜色键 ''{0}'' 未在 <code>*.themeMetadata.json</code> 中注册(<a href="https://plugins.jetbrains.com/docs/intellij/themes-metadata.html?from=DevkitUnregisteredNamedColorInspection">文档</a>)</html>

inspections.inspection.description.optional.short.name=检查没有描述 {0}

inspections.inspection.mapping.consistency.specify.bundle=应指定捆绑包
inspections.inspection.mapping.consistency.fix.insert.attribute=插入 ''{0}'' 特性
inspections.inspection.mapping.consistency.specify.displayName.or.key=应指定 displayName 或 key
inspections.inspection.mapping.consistency.specify.groupName.or.groupKey=应指定 groupName 或 groupKey

inspections.intention.description.not.found=意图没有描述
inspections.intention.description.no.before.after.template=意图在 'description.html' 旁必须有 'before.*.template' 和 'after.*.template'

inspections.postfix.description.not.found=后缀模板没有描述
inspections.postfix.description.no.before.after.template=后缀模板在 'description.html' 旁必须有 'before.*.template' 和 'after.*.template'

inspections.plugin.xml.capitalization.missing.resource.bundle.key=缺少资源捆绑包键 ''{0}''
inspections.plugin.xml.capitalization.error=字符串 ''{0}'' 的大小写不正确。其中的 {1} 应当大写
inspections.plugin.xml.capitalization.fix.properly.capitalize=正确大写 ''{0}''
inspections.plugin.xml.capitalization.fix.properly.capitalize.family.name=正确大写

inspections.quick.fix.family.name=QuickFix 的 getFamilyName() 实现不得依赖于特定上下文

inspections.unique.toolbar.id=指定唯一工具栏 ID

inspections.psi.element.concat.psi.element=PsiElement 到字符串的可疑转换
inspections.psi.element.concat.psi.type=PsiType 到字符串的可疑转换
inspections.psi.element.concat.add.get.text.family.name=调用文本表示检索方法
inspections.psi.element.concat.add.get.text.name=使用 ''{0}'' 调用


inspections.plugin.xml.dynamic.plugin.component.usage=由于使用组件而变成非动态的插件。
inspections.plugin.xml.dynamic.plugin.component.usage.docs.link.title=迁移指南
inspections.plugin.xml.dynamic.plugin.option.highlight.usages.ep=高亮显示非动态扩展点的用法
inspections.plugin.xml.dynamic.plugin.extension.point=非动态扩展点 ''{0}''
inspections.plugin.xml.dynamic.plugin.explicit.non.dynamic.extension.point=显式非动态扩展点 ''{0}''
inspections.plugin.xml.dynamic.plugin.id.required.for.group=必须为 <group> 指定 'id'
inspections.plugin.xml.dynamic.plugin.usage.of.non.dynamic.extension.point=使用非动态扩展点 ''{0}''
inspections.plugin.xml.dynamic.plugin.analyze.extension.point=''{1}'' 的{0}

inspections.stateful.extension.point.leak.psi.element=潜在的内存泄漏: 请勿保持 PsiElement，改用 SmartPsiElementPointer
inspections.stateful.extension.point.leak.psi.element.quick.fix=另请参阅 LocalQuickFixOnPsiElement
inspections.stateful.extension.point.do.not.use.in.quick.fix=请勿在快速修复中将 {0} 用作字段
inspections.stateful.extension.point.do.not.use.in.extension=请勿在扩展中将 {0} 用作字段

inspections.file.equals.method=请勿使用 File.equals/hashCode/compareTo，因为它们在 macOS 中不区分大小写。请改用 FileUtil.filesEquals/fileHashCode/compareFiles。

inspections.undesirable.class.use.instead=请改用 ''{0}''

inspections.unsafe.vfs.recursion=从递归方法调用 VirtualFile.getChildren()。这可能会导致循环符号链接无穷循环。请改用 VfsUtilCore.visitChildrenRecursively()。

inspections.use.couple.of=替换为 'Couple.of()'
inspections.use.couple.type=替换为 ''Couple<{0}>''
inspections.use.couple.family.name=将 'Pair' 替换为 'Couple'

inspections.use.dpi.aware.insets=将替换为 JBUI.insets(...)
inspections.use.dpi.aware.insets.family.name=转换为 JBUI.insets(...)

inspections.use.equals.description=''{0}'' 实例应通过 <code>equals()</code> 而不是 <code>==</code> 进行比较

inspections.unsafe.return.insert.family.name=跳过匿名/局部类
inspections.unsafe.return.insert.visit.lambda.expression=插入 visitLambdaExpression 方法
inspections.unsafe.return.insert.visit.class.method=插入 visitClass 方法
inspections.unsafe.return.insert.visit.lambda.expression.and.class.methods=插入 visitLambdaExpression/visitClass 方法
inspections.unsafe.return.message=访问 return 语句的递归访问者最有可能应当专门处理匿名/局部类以及 lambda 表达式

inspections.use.jb.color.change.to.JBColor=更改为 JBColor.{0}
inspections.use.jb.color.replace.with.JBColor=替换为 JBColor
inspections.use.jb.color.fix=转换为 JBColor.{0}
inspections.use.jb.color.fix.family.name=使用 JBColor 常量
inspections.use.jb.color.new.color.fix.family.name=转换为 JBColor

# used by antbuild plugin
# suppress inspection "UnusedProperty"
ant.build.jar.comment=为插件 ''{0}'' 构建归档
# suppress inspection "UnusedProperty"
ant.build.jar.description=为模块 ''{0}'' 构建插件归档

error.cannot.resolve.plugin=无法解析依赖项中的插件 ''{0}''
error.cannot.resolve.plugin.reference.link.title=(引用: 插件依赖项)
error.cannot.resolve.extension.point=无法解析依赖项中的扩展点 ''{0}''
error.cannot.resolve.extension.point.missing.dependency=缺少使用扩展点 ''{0}'' 的依赖关系声明
error.cannot.resolve.extension.point.missing.dependency.fix.family.name=添加缺少的 <depends>

create.description.file=插件描述文件 {0}
create.description.file.family.name=插件描述文件
select.target.location.of.description=选择 {0} 的目标位置
implemented.at.runtime.dom=在运行时实现的 DOM 元素
implemented.at.runtime.jamElement=在运行时实现的 JAM 元素

line.marker.tooltip.extension.declaration=<a href="#navigation/{0}:{1}">{2}</a> 声明位于 {3} 中
line.marker.tooltip.extension.point.declaration=<a href="#navigation/{0}:{1}">{2}</a> 扩展点声明位于 {3} 中
inspections.usage.uelement.as.psi=不建议将 UElement 用作 PsiElement

inspections.missing.recent.api.common.message=''{0}'' 仅从 {1} 开始方可用，但该模块的目标是 {2}。这可能导致与 {1} 之前的 IDE 出现兼容性问题。
inspections.missing.recent.api.class.message=''{0}'' 仅从 {1} 开始方可用，但该模块的目标是 {2}。这可能导致与 {1} 之前的 IDE 出现兼容性问题。请注意，在以前的 IDE 中，此类型可能具有其他完全限定名称。
inspections.missing.recent.api.method.message=''{0}'' 仅从 {1} 开始方可用，但该模块的目标是 {2}。这可能导致与 {1} 之前的 IDE 出现兼容性问题。请注意，在以前的 IDE 中，此方法可能具有不同的完全签名。
inspections.missing.recent.api.field.message=''{0}'' 仅从 {1} 开始方可用，但该模块的目标是 {2}。这可能导致与 {1} 之前的 IDE 出现兼容性问题。请注意，在以前的 IDE 中，此字段可能具有不同的完全签名。
inspections.missing.recent.api.default.constructor.message=''{0}'' 的默认构造函数仅从 {1} 开始方可用，但该模块的目标是 {2}。这可能导致与 {1} 之前的 IDE 出现兼容性问题。
inspections.missing.recent.api.overriding=''{0}'' 的覆盖方法仅从 {1} 开始方可用，但该模块的目标是 {2}。这可能导致与 {1} 之前的 IDE 出现兼容性问题。请注意，在以前的 IDE 中，此覆盖方法可能具有不同的签名。
inspections.missing.recent.api.since.until.range.all.builds=所有构建
inspections.missing.recent.api.settings.range=插件兼容性范围
inspections.missing.recent.api.settings.since=自
inspections.missing.recent.api.settings.since.empty.text=第一个 IDE
inspections.missing.recent.api.settings.until=至
inspections.missing.recent.api.settings.until.empty.text=日后所有 IDE
inspections.missing.recent.api.settings.invalid.build.number=无效构建号: {0}

inspection.renamer.dialog.title=重命名检查描述文件并更改短名称
inspection.renamer.option.name=重命名检查描述文件并更改短名称
inspection.renamer.dialog.description=<html>您还想重命名检查描述文件并更改短名称吗?<br/><b>警告: 它可能会破坏现有的检查配置文件和禁止注释。</b></html>
inspection.renamer.entity.name=元素

intellij.api.annotations.update.task.title=更新 IntelliJ API 注解 {0}

inspections.plugin.xml.i18n.name=提取 i18n 的文本/说明
inspections.plugin.xml.i18n.command.name=提取要进行 I18n 的文本/描述
inspections.plugin.xml.i18n.inspection.tag.command.name=提取要进行 I18n 的{0}
inspections.plugin.xml.i18n.inspection.tag.family.name=提取要进行 i18n 的{0}
inspections.plugin.xml.i18n.choose.bundle.4inspections.title=选择捆绑包
inspections.plugin.xml.i18n.key=提取 i18n 的文本
inspections.plugin.xml.i18n.key.command.name=提取要进行 I18n 的文本

inspections.leakable.map.key.name=映射键可能会泄漏
inspections.leakable.map.key.text=考虑使用 ''String'' 代替 ''{0}'' 作为映射键
inspections.leakable.map.key.quick.fix.name=使用 ''{0}'' 进行形参化

inspections.unresolved.plugin.config.reference=未解析的插件配置引用

inspections.use.gray.convert=转换为 Gray._{0}
inspections.use.gray.convert.family.name=转换为 Gray

line.marker.related.property.tooltip=相关属性
line.marker.related.property.popup.title=相关属性
line.marker.related.property.description=相关属性

action.DevKit.EditThemeEditorColorScheme.text=编辑编辑器配色方案
action.DevKit.RollbackTheme.text=停止主题预览
action.DevKit.ApplyTheme.text=预览主题
action.DevKit.OpenThemeReferenceDocs.text=打开 UI 主题参考文档
action.AnalyzeEPUsageIgnoreSafeClasses.text=分析扩展点用法(不遵循安全类型)
action.AnalyzeEPUsage.text=分析扩展点用法

action.AnalyzeUnloadablePlugins.text=分析可卸载插件
action.AnalyzeUnloadablePlugins.progress.title=正在分析插件({0})

action.DumpCleanTestData.text=转储 Highlighting-Markup-Free 数据
action.DumpCleanTestData.file.chooser.title=选择目录
action.DumpCleanTestData.file.chooser.source.description=包含高亮显示测试数据的目录
action.DumpCleanTestData.file.chooser.destination.description=将放置无高亮显示标记的副本的目录
action.DumpCleanTestData.error.source.destination.must.differ=源根和目标根应不同

action.ShowHelpPageById.text=按 ID 显示帮助页面
action.ShowHelpPageById.dialog.enter.help.id=输入帮助 ID:
action.ShowHelpPageById.dialog.title=显示帮助页面

action.GenerateDomModel.text=生成 DOM 模型…

action.ShowSerializedXml.text=显示类的序列化 XML
action.ShowSerializedXml.message.cannot.find.class=找不到类 ''{0}''
action.ShowSerializedXml.message.cannot.generate.class=无法生成类 ''{0}'': {1}
action.ShowSerializedXml.dialog.title=''{0}'' 的序列化 XML

action.ShuffleNamesAction.text=打乱名称次序/搅乱名称/匿名/改变名称序列
action.ToggleHighlightingMarkup.text=切换预期的高亮显示标记
group.Internal.DevKit.text=DevKit
action.GenerateExternalization.text=生成外部化
action.DevKit.NewTheme.text=主题
action.NewAction.text=操作
action.NewAction.description=创建新操作
group.DevkitNewActions.text=Plugin DevKit
action.Anonymous.text.choose.color=选择颜色…
inspection.serializable.constructor.message=非默认 ctor 应当用 @PropertyMapping 进行注释
inspection.message.wrong.quotes.around.parameter.reference=参数不会被替换，字符串将包含 {0}

action.TestData.Navigate.text=导航到测试数据
testdata.popup.navigation.title=测试数据
testdata.related.navigation.group=测试数据
testdata.related.navigation.title=测试数据

# UI Form converter
convert.form.dialog.title=将表单转换为 UI DSL
convert.form.dialog.label.target.class.name=目标类名:
convert.form.dialog.label.bound.instance.type=绑定实例类型:
convert.form.dialog.label.bound.instance.expression=绑定实例表达式
convert.form.dialog.label.checkbox.generate.descriptors.for.search.everywhere=生成 Search Everywhere 的描述符
convert.form.dialog.base.class.separator=基类
convert.form.dialog.base.class.none=无
convert.form.dialog.base.class.configurable=可配置
convert.form.editor.notification.label=现在不建议在 IntelliJ 项目中使用 UI Designer
convert.form.editor.notification.link.convert=转换为 UI DSL
convert.form.hint.caret.not.in.form.bound.class=请将文本光标放入绑定到表单的 Java 类中
convert.form.hint.class.not.bound.to.form=找不到绑定到 {0} 的表单

# UpdateFromSources
action.UpdateIdeFromSourcesAction.update.show.settings.text=从源代码设置更新 IDE…
action.UpdateIdeFromSourcesAction.update.text=从源代码更新 IDE…
action.UpdateIdeFromSourcesAction.update.description=从当前打开的源代码构建 IntelliJ IDEA 的安装，并用它替换当前的安装。
action.UpdateIdeFromSourcesAction.task.title=从源代码更新
action.UpdateIdeFromSourcesAction.task.failed.title=从源代码更新失败
action.UpdateIdeFromSourcesAction.task.failed.content=构建脚本完成，错误代码为 {0}
action.UpdateIdeFromSourcesAction.task.success.title=从源代码更新
action.UpdateIdeFromSourcesAction.task.success.content=新安装是从源代码准备的。是否<a href="#">重启</a>?
action.UpdateIdeFromSourcesAction.notification.title=从源代码更新
action.UpdateIdeFromSourcesAction.notification.content=新安装在{0}处准备。
action.UpdateIdeFromSourcesAction.settings.title=从源代码更新 IDE
action.UpdateIdeFromSourcesAction.settings.ok.button=更新
action.UpdateIdeFromSourcesAction.settings.do.not.show.description=您可以调用“从源设置更新 IDE”操作来更改设置
action.UpdateIdeFromSourcesAction.settings.row.ide.installation=IDE 安装:
action.UpdateIdeFromSourcesAction.settings.installation.choose.ide.directory.title=选择 IDE 安装目录
action.UpdateIdeFromSourcesAction.settings.enabled.plugins.only=仅构建已启用的插件
action.UpdateIdeFromSourcesAction.settings.restart.automatically=自动重启
action.UpdateIdeFromSourcesAction.error.work.home.not.valid.ide.home={0} 不是有效的 IDE 主目录: {1}
action.UpdateIdeFromSourcesAction.error.config.or.system.directory.under.home=无法更新 {0} 安装，因为 ''{1}'' 属性指向\n它下面的目录，并且在更新过程中将被清除。
action.UpdateIdeFromSourcesAction.error.work.home.not.valid.ide.home.not.directory=它不是目录
action.UpdateIdeFromSourcesAction.error.work.home.not.valid.ide.home.not.exists=''{0}'' 不存在
action.UpdateIdeFromSourcesAction.error.build.scripts.not.exists=''{0}'' 不存在
action.UpdateIdeFromSourcesAction.error.build.scripts.out.of.date=构建脚本已过时，请更新到最新的 'master' 源代码。
action.UpdateIdeFromSourcesAction.error.ide.cannot.restart=此 IDE 无法自行重启，因此不支持从源代码更新
action.UpdateIdeFromSourcesAction.progress.text.new.installation.prepared.ide.will.restart=新安装已准备，IDE 将在 {0, choice, 1#1 秒|2#{0} 秒}后重启
action.UpdateIdeFromSourcesAction.button.postpone=推迟
action.UpdateIdeFromSourcesAction.backup.progress.text=正在备份文件
action.UpdateIdeFromSourcesAction.copy.progress.text=正在将文件复制到 IDE 分发版…
action.UpdateIdeFromSourcesAction.copy.delete.old.files.text=正在删除旧文件
action.UpdateIdeFromSourcesAction.copy.copy.new.files.text=正在复制新文件
action.UpdateIdeFromSourcesAction.update.progress.text=正在从源代码更新 IDE…
action.UpdateIdeFromSourcesAction.update.progress.delete=正在删除 {0}
action.UpdateIdeFromSourcesAction.update.progress.start.gant.script=正在启动 gant 脚本
action.UpdateIdeFromSourcesAction.notification.action.view.output=查看输出
action.UpdateIdeFromSourcesAction.notification.action.view.debug.log=查看调试日志
action.UpdateIdeFromSourcesAction.dialog.message.directory.not.writable=目录 {0} 不可写

inspections.IncorrectParentDisposableInspection.do.not.use.as.disposable=请勿在插件代码中将 {0} 用作可处置对象
inspections.IncorrectParentDisposableInspection.documentation.link.title=选择可处置的父级

extension.point.documentation.link.platform.explorer=在 IntelliJ Platform Explorer 中显示用法
extension.point.documentation.field.required.suffix=(必填)
extension.point.documentation.field.required.can.be.empty.suffix=(必填，允许为空)
extension.point.documentation.implementation.section=扩展点实现

gutter.related.option.description=描述
gutter.related.option.before.after.templates=在模板前面/后面
gutter.related.option.name=描述/在模板前面|后面
gutter.related.navigation.popup.template.title=选择模板
gutter.related.navigation.popup.template.tooltip=在模板前面/后面
gutter.related.extension.declaration=声明
gutter.related.navigation.popup.description.tooltip=描述
gutter.related.navigation.choose.extension=选择扩展
gutter.related.navigation.choose.extension.point=选择扩展点

# plugin.xml resolving
plugin.xml.convert.action.or.group.cannot.resolve=无法解析{0} ''{1}''
plugin.xml.convert.action.or.group.invalid.name=<invalid name>
plugin.xml.convert.action.or.group.type.action.or.group=操作或组
plugin.xml.convert.action.or.group.type.action=操作
plugin.xml.convert.action.or.group.type.group=组

plugin.xml.convert.enum.cannot.resolve=无法解析{1}中的 ''{0}''
plugin.xml.convert.extension.order.cannot.resolve=无法解析 '''''{'0'}''''' {0} 扩展
plugin.xml.convert.extension.property.cannot.resolve=无法解析扩展点属性 ''{0}''
plugin.xml.convert.property.bundle.cannot.resolve=无法解析属性捆绑包
plugin.xml.convert.keymap.cannot.resolve=无法解析键盘映射 ''{0}''
plugin.xml.convert.language.id.cannot.resolve=无法解析 ID 为 ''''{0}'''' 的语言
plugin.xml.convert.language.id.any.language.display.name=<any language>

plugin.xml.convert.module.descriptor.name=无法解析模块 ''{1}'' 的源根中的模块描述符 ''{0}''

# code resolving
code.convert.experimental.feature.id.cannot.resolve=无法解析功能 ''{0}''
code.convert.experimental.feature.no.description=无描述
code.convert.registry.key.cannot.resolve=无法解析注册表键 ''{0}''
code.convert.registry.key.no.description=无描述
code.convert.registry.key.no.default.value=无默认值

code.convert.notification.group.cannot.resolve=无法解析通知组 id ''{0}''

message.bundle.convert.toolwindow.id.cannot.resolve=无法解析工具窗口 ID ''{0}''

message.bundle.convert.advanced.setting.id.cannot.resolve=无法解析高级设置 ID ''{0}''

inspections.unregistered.named.color.fix.navigate.theme.metadata.file=导航到主题元数据文件
inspections.unregistered.named.color.fix.navigate.theme.metadata.file.popup.title=主题元数据文件


plugin.xml.scopes.display.name=插件描述符文件
plugin.xml.scopes.production.display.name=所有生产插件描述符文件

# registry.properties
registry.properties.annotator.plugin.keys.use.ep=特定于插件的键应通过 'com.intellij.registryKey' 扩展点进行注册
registry.properties.annotator.key.no.description.key=键 ''{0}'' 没有描述键
registry.properties.annotator.show.ep.family.name=显示扩展点声明
registry.properties.annotator.show.ep.name=显示 ''{0}'' 的扩展点声明
registry.properties.annotator.show.ep.message=将此声明复制到您的插件描述符 XML 中
registry.properties.annotator.show.ep.title=扩展点声明
registry.properties.annotator.add.description.text=添加 ''{0}'' 的描述键
registry.properties.annotator.add.description.family.name=添加描述键
action.darcula.hidpi.theme.text=Darcula HiDPI
action.darcula.theme.text=Darcula
action.default.hidpi.theme.text=默认 HiDPI
action.default.theme.text=默认

# DOM model Generator
dom.generator.dialog.title=从 XSD 或 DTD 生成 DOM 模型
dom.generator.generate.button=生成
dom.generator.dialog.label.form.title=DOM 生成器配置
dom.generator.dialog.label.namespace=命名空间:
dom.generator.dialog.label.super.class=超类:
dom.generator.dialog.label.package=软件包:
dom.generator.dialog.label.output.directory=输出目录:
dom.generator.dialog.label.scheme.file=方案文件:
dom.generator.dialog.label.skip.schemes=跳过主题:
dom.generator.dialog.label.javadoc.author=@author:
dom.generator.dialog.label.use.fqn=使用 FQN:
dom.generator.dialog.label.use.fqn.tooltip=在生成的代码中使用 FQN 以防止名称冲突
dom.generator.dialog.choose.scheme.label=选择 XSD 或 DTD 架构
dom.generator.dialog.folder.browser.description=确保 XSD 或 DTD 架构所在的目录中仅存在必要的架构
dom.generator.dialog.folder.output=选择生成文件的输出目录
dom.generator.dialog.error.schema.not.exist=架构位置不存在
dom.generator.dialog.error.output.not.exist=输出目录不存在
inspections.use.dpi.aware.empty.border.simplify=简化
inspections.use.dpi.aware.empty.border.family.name=简化
inspections.use.dpi.aware.empty.border.replace=替换为 JBUI.Borders.empty(...)
inspections.use.dpi.aware.empty.border.convert.fix.family.name=转换为 JBUI.Borders.empty(...)


plugin.descriptor.chooser.cannot.find=找不到插件描述符
plugin.descriptor.chooser.popup.title=选择插件描述符

register.extension.fix.name=注册扩展
register.extension.fix.popup.title=选择扩展点
register.inspection.fix.family.name=注册检查
register.inspection.fix.name=注册检查 ''{0}''

inspections.non.default.warning.type.service=服务
inspections.non.default.warning.type.extension=扩展
inspections.non.default.warning.and.suffix.message={0} 不应具有包含参数 {1} 的构造函数
inspections.non.default.warning.suffix.project.or.module=(如果是在相应级别请求，则项目或模块除外)
inspections.non.default.warning.suffix.project=(项目除外)
inspections.non.default.warning.suffix.module=(模块除外)

extension.point.analyzer.not.extension.point.name=非 ExtensionPointName 引用
extension.point.analyzer.analyze.title=正在分析扩展点用法
extension.point.analyzer.analyze.status.bar.info=正在分析 ''{0}'' (总计: {1})
extension.point.analyzer.analyze.no.usages=未找到任何用法
extension.point.analyzer.analyze.usage.all.safe=所有用法均为动态安全
extension.point.analyzer.analyze.xml.not.extension.point=非 <extensionPoint>
extension.point.analyzer.analyze.xml.cannot.resolve.ep.class=无法解析扩展点的类
extension.point.analyzer.analyze.xml.no.implementation.language.extension.point=找不到 LanguageExtensionPoint 的实现类
extension.point.analyzer.analyze.xml.batch.not.extension.points=非 <extensionPoints>
extension.point.analyzer.analyze.xml.batch.title=正在分析扩展点
extension.point.analyzer.analyze.xml.no.extension.point.name.field=找不到 ExtensionPointName 字段
extension.point.analyzer.reason.no.ep.field=没有扩展点字段
extension.point.analyzer.reason.element.of={0} 的元素
extension.point.analyzer.reason.extension.instance=扩展实例
extension.point.analyzer.reason.extension.list=扩展列表
extension.point.analyzer.reason.return.value={0}: 返回 ''{1}'' 的值(类型: {2})
extension.point.analyzer.reason.unknown.usage=ExtensionPoint 的未知用法
extension.point.analyzer.reason.call.not.loop.value=调用不是循环的迭代值
extension.point.analyzer.reason.impure.method={0} 传递给不纯的方法，可能会产生副作用(如果不应这样，请作为 ''@Contract(pure = true)'' 注解)
extension.point.analyzer.reason.unresolved.method.call=未解析的方法调用
extension.point.analyzer.reason.too.many.visited.objects=访问的对象过多，已停止搜索
extension.point.analyzer.reason.get.instance.method.skipped=从 'getInstance' 方法返回(对于搜索调用站点而言代价高昂)
extension.point.analyzer.reason.returned.from.method={0}: 从方法 ''{1}'' 返回
extension.point.analyzer.reason.leak.returned.from.method={0}: 从方法 ''{1}'' 返回，此后泄漏
extension.point.analyzer.reason.unknown.usage.text={0}: 未知用法
extension.point.analyzer.reason.uast.no.source.psi={0}: UVariable 没有源 PSI
extension.point.analyzer.usage.safe.eps=安全 EP
extension.point.analyzer.usage.unsafe.eps=不安全的扩展点用法

inspection.plugin.xml.validity.display.name=Plugin.xml 有效性
inspection.plugin.xml.capitalization.display.name=Plugin.xml 文本大小写
inspection.plugin.xml.dynamic.plugin.display.name=Plugin.xml 动态插件验证
inspection.inspection.description.not.found.inspection.display.name=检查描述检查器
inspection.inspection.using.gray.colors.display.name=使用新的 Color(a,a,a)
inspection.inspection.unique.toolbar.id.display.name=指定工具栏 ID
inspection.intention.description.not.found.inspection.display.name=意图描述检查器
inspection.inspection.mapping.consistency.display.name=<inspection> 标记一致性
inspection.undesirable.class.usage.display.name=不需要的类用法
inspection.file.equals.usage.display.name=File.equals() 用法
inspection.unsafe.vfs.recursion.display.name=不安全的 VFS 递归
inspection.use.JB.color.display.name=使用 Darcula 感知 JBColor
inspection.use.DPI.aware.insets.display.name=使用 DPI 感知嵌入
inspection.use.DPI.aware.borders.display.name=使用 DPI 感知边界
inspection.use.couple.display.name=使用 Couple 而不是 Pair
inspection.use.virtual.file.equals.display.name=使用 'VirtualFile#equals(Object)'
inspection.use.plugin.id.equals.display.name=使用 'PluginId#equals(Object)'
inspection.unsafe.return.statement.visitor.display.name=不安全的 return 语句访问者
inspection.stateful.ep.display.name=有状态扩展
inspection.u.element.as.psi.display.name=UElement 作为 PsiElement 的用法
inspection.use.primitive.types.equals.display.name=使用包含基元类型的 'PsiType#equals(Object)'
inspection.highlight.visitor.internal.display.name=好代码显示为红色
inspection.quick.fix.get.family.name.violation.display.name=QuickFix 的 getFamilyName() 实现不得依赖于特定上下文
inspection.psi.element.concatenation.display.name=使用 PsiElement 字符串表示生成新表达式是不正确的
inspection.non.default.constructor.display.name=服务和扩展类的非默认构造函数
inspection.presentation.annotation.display.name=@Presentation 中的图标路径无效
inspection.unregistered.named.color.display.name=未注册的命名颜色
inspection.missing.recent.api.display.name=在旧 IDE 中无法使用 IntelliJ API
inspection.serializable.ctor.display.name=可序列化类中的非默认构造函数
inspection.incorrect.parent.disposable.display.name=不正确的 parentDisposable 参数
inspection.plugin.xml.i18n.display.name=Plugin.xml i18n 验证
inspection.dev.kit.properties.quotes.validation.display.name=属性文件中的带引号验证
inspection.missing.accessible.context.display.name=缺少可访问上下文
inspection.message.accessible.context.not.defined.for.jpanel=没有为 JPanel 定义可访问上下文
gutter.name.test.data.line.marker=测试数据


### scala/meta/intellij/MetaExpansionsManager.scala
meta.annotation.class.could.not.be.found=未找到元注解类
tree.conversion.error=树转换错误: {0}
semantic.error=语义错误: {0}
stack.overflow.during.expansion=扩展 {0} 时堆栈溢出
internal.error.getmessage=内部错误: {0}

### scala/meta/intellij/QuasiquoteInferUtil.scala
failed.to.get.qq.ref.in.pattern=无法在 {0} 中获取 QQ 引用
unknown.quasiquote.kind.prefix=未知的 Quasiquote 类型 - {0}

### scala/meta/intellij/psi/package.scala
meta.expansions.disabled.in.settings=元扩展在设置中已禁用
no.meta.annotation=没有元注解
recursive.meta.expansion=递归元扩展

### scala/meta/trees/Namer.scala
synthetic.elements.not.implemented=未实现合成元素
package.and.object.types.shoud.be.singleton.not.name...=软件包和对象类型应为单例，而非名称: {0}
failed.to.convert.type.tp=无法转换类型 {0}
super.selector.cannot.be.non.name.type=Super 选择器不能为非名称类型
unexpected.type.in.parents.other=父项中存在意外类型: {0}

### scala/meta/trees/ScalaMetaException.scala
cannot.resolve.class.at.element=无法解析位于 {1} 的 {0}
cannot.calculate.type=无法计算类型: {0}
this.code.should.be.unreachable.reason=此代码应不可到达: {0}
this.code.should.be.unreachable=此代码应不可到达
failed.to.typecheck=无法检查类型: {0}
this.code.path.is.not.implemented.yet.head=此代码路径尚未实现[{0}]

### scala/meta/trees/TreeAdapter.scala
macro.definition.must.have.return.type.defined=宏定义必须已定义返回类型
no.primary.constructor.in.class=类中没有主构造函数
no.constructor.found.in.class=在类 {0} 中未找到构造函数
class.has.no.parents=类 {0} 没有父项
empty.while.condition=空 while 条件
generator.has.no.expression=生成器没有表达式
guard.has.no.condition=临界没有条件
forbinding.has.no.expression=for 绑定没有表达式
imported.name.is.null=导入的名称在非通配符选择器中为 null
reference.is.null=引用在非通配符选择器中为 null
empty.throw.expression=空 throw 表达式

### scala/meta/trees/TypeAdapter.scala
number.of.parts.in.compound.type.must.be.greater.than.2=复合类型的部分数必须大于等于 2
cannot.convert.into.type.variables=无法转换为类型变量

### scala/meta/trees/Utils.scala
unexpected.psi=意外 psi({0}): {1}

### <unused>
unexpected.type.in.constructor.type.element=构造函数类型元素 {0} 中存在意外类型

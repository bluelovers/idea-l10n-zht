### scala/meta/intellij/QuasiquoteInferUtil.scala
failed.to.get.qq.ref.in.pattern=无法在 {0} 中获取 QQ 引用
unknown.quasiquote.kind.prefix=未知的 Quasiquote 类型 - {0}

### scala/meta/trees/Namer.scala
synthetic.elements.not.implemented=未实现合成元素
package.and.object.types.should.be.singleton.not.name...=软件包和对象类型应为单例，而不是名称\: {0}
failed.to.convert.type.tp=无法转换类型 {0}
super.selector.cannot.be.non.name.type=Super 选择器不能为非名称类型

### scala/meta/trees/ScalaMetaException.scala
cannot.resolve.class.at.element=无法解析位于 {1} 的 {0}
cannot.calculate.type=无法计算类型\: {0}
this.code.should.be.unreachable.reason=此代码应不可到达\: {0}
this.code.should.be.unreachable=此代码应不可到达
failed.to.typecheck=无法检查类型\: {0}
this.code.path.is.not.implemented.yet.head=此代码路径尚未实现[{0}]

### scala/meta/trees/TreeAdapter.scala
macro.definition.must.have.return.type.defined=宏定义必须已定义返回值类型
no.primary.constructor.in.class=类中没有主构造函数
no.constructor.found.in.class=在类 {0} 中未找到构造函数
class.has.no.parents=类 {0} 没有父项
empty.while.condition=空 while 条件
generator.has.no.expression=生成器没有表达式
guard.has.no.condition=临界没有条件
forbinding.has.no.expression=for 绑定没有表达式
imported.name.is.null=导入的名称在非通配符选择器中为 null
reference.is.null=引用在非通配符选择器中为 null
empty.throw.expression=空 throw 表达式

### scala/meta/trees/TypeAdapter.scala
number.of.parts.in.compound.type.must.be.greater.than.2=复合类型的部分数必须大于等于 2
cannot.convert.into.type.variables=无法转换为类型变量

### scala/meta/trees/Utils.scala
unexpected.psi=意外 psi({0})\: {1}

add.explicit.type.arguments=添加显式类型实参

# suppress inspection "UnusedProperty"
annotation.target.ANNOTATION_TYPE=注解类型
# suppress inspection "UnusedProperty"
annotation.target.CONSTRUCTOR=构造函数
# suppress inspection "UnusedProperty"
annotation.target.FIELD=字段
# suppress inspection "UnusedProperty"
annotation.target.LOCAL_VARIABLE=局部变量
# suppress inspection "UnusedProperty"
annotation.target.METHOD=方法
# suppress inspection "UnusedProperty"
annotation.target.MODULE=模块
# suppress inspection "UnusedProperty"
annotation.target.PACKAGE=软件包
# suppress inspection "UnusedProperty"
annotation.target.PARAMETER=形参
# suppress inspection "UnusedProperty"
annotation.target.RECORD_COMPONENT=记录组件
# suppress inspection "UnusedProperty"
annotation.target.TYPE=类型
# suppress inspection "UnusedProperty"
annotation.target.TYPE_PARAMETER=类型形参
# suppress inspection "UnusedProperty"
annotation.target.TYPE_USE=类型使用

change.type.arguments=更改类型实参
change.type.arguments.to.0=将类型实参更改为 <{0}>
convert.0.to.float=将 ''{0}'' 转换为 float

dataflow.message.array.index.out.of.bounds=数组索引超出范围
dataflow.message.negative.array.size=数组大小为负
dataflow.message.arraystore=将 <code>{0}</code> 类型的元素存储到 <code>{1}</code> 元素的数组将生成 <code>ArrayStoreException</code>
dataflow.message.assigning.null.notannotated=正在将 <code>null</code> 值指定给非注解字段
dataflow.message.assigning.null=<code>null</code> 被分配到一个是注解变量 @NotNull
dataflow.message.assigning.nullable.notannotated=表达式 <code>#ref</code> #loc 可能为 null，但被指定给非注解字段
dataflow.message.assigning.nullable=表达式 <code>#ref</code> 可能为 null ,但是它被分配了注解 @NotNull
dataflow.message.cce.always=将 <code>{0}</code> 转换为 <code>#ref</code> #loc 会为任意非 null 值生成 <code>ClassCastException</code>
dataflow.message.cce=从<code>{0}</code> 到 <code>#ref</code> #loc 可能产生 <code>java.lang.ClassCastException</code>
dataflow.message.constant.condition.when.reached=到达时，条件 <code>#ref</code> #loc 始终为 <code>{0, choice, 0#false|1#true}</code>
dataflow.message.constant.condition=条件 <code>#ref</code> #loc 始终为 <code>{0, choice, 0#false|1#true}</code>
dataflow.message.constant.method.reference=方法引用结果始终为''{0}''
dataflow.message.constant.no.ref=条件始终为 {0, choice, 0#false|1#true}
dataflow.message.contract.fail.index=由于实参超出范围，对 '#ref' 的调用总是失败
dataflow.message.contract.fail=依据其方法约定，对 '#ref' 的调用始终失败
dataflow.message.immutable.modified=不可变对象已被修改
dataflow.message.immutable.passed=不可变对象在预期可变位置传递
dataflow.message.npe.array.access.sure=数组访问 <code>#ref</code> #loc 可能生成 <code>NullPointerException</code>
dataflow.message.npe.array.access=数组访问 <code>#ref</code> #loc 可能产生 <code>java.lang.NullPointerException</code>
dataflow.message.npe.field.access.sure=引用 <code>#ref</code> #loc 会产生 <code>java.lang.NullPointerException</code>
dataflow.message.npe.field.access=取消引用<code>#ref</code> #loc 可能导致 <code>NullPointerException</code>
dataflow.message.npe.inner.class.construction.sure=内部类构造将生成 <code>NullPointerException</code>
dataflow.message.npe.inner.class.construction=内联类建立可能会产生<code>NullPointerException</code>
dataflow.message.npe.method.invocation.sure=方法调用 <code>#ref</code> #loc 可能生成 <code>NullPointerException</code>
dataflow.message.npe.method.invocation=方法调用 <code>#ref</code> #loc 可能产生 <code>NullPointerException</code>
dataflow.message.npe.methodref.invocation=方法引用调用 <code>#ref</code> #loc 可能会产生 <code>java.lang.NullPointerException</code>
dataflow.message.only.switch.label=Switch 标签 <code>#ref</code> #loc 是整个 switch 中唯一可访问的对象
dataflow.message.passing.null.argument.nonannotated=正在将 <code>null</code> 实参传递到非注解形参
dataflow.message.passing.null.argument=正在将 <code>null</code> 实参传递到注解为 @NotNull 的形参
dataflow.message.passing.nullable.argument.methodref.nonannotated=方法引用实参可能为 null，但被传递给非注解形参
dataflow.message.passing.nullable.argument.methodref=方法引用实参可能为空
dataflow.message.passing.nullable.argument.nonannotated=实参 <code>#ref</code> #loc 可能为 null，但被传递给非注解形参
dataflow.message.passing.nullable.argument=实参 <code>#ref</code> #loc 可能为null
dataflow.message.passing.non.null.argument.to.optional=正在将非 null 实参传递到 <code>Optional</code>
dataflow.message.passing.null.argument.to.optional=正在将 <code>null</code> 实参传递到 <code>Optional</code>
dataflow.message.pointless.assignment.expression=条件 <code>#ref</code> #loc 在赋值表达式的左侧是永远 <code>{0}</code>. 可以简化
dataflow.message.pointless.same.arguments='#ref' 的实参相同。调用包含相同实参的此方法毫无意义
dataflow.message.pointless.same.argument.and.result='#ref' 的结果与{0,choice,1#第 1 个|2#第 2 个}实参相同使调用毫无意义
dataflow.message.redundant.assignment=变量已被指定给此值
dataflow.message.redundant.instanceof=条件 <code>#ref</code> #loc是多余的，可以用 <code>!= null</code>
dataflow.message.redundant.update=变量更新不执行任何操作
dataflow.message.return.notnull.from.nullable=@{0} 方法 ''{1}'' 始终返回非 null 值
dataflow.message.return.null.from.notnull=<code>null</code> 由声明为 @{0} 的方法返回
dataflow.message.return.null.from.notnullable=<code>null</code> 由未被声明为 @{0} 的方法返回
dataflow.message.return.nullable.from.notnull.function=函数可能返回null,但这里不允许
dataflow.message.return.nullable.from.notnull=表达式 <code>#ref</code> 可能会评估为 null，但由声明为 @{0} 的方法返回
dataflow.message.return.nullable.from.notnullable=表达式 <code>#ref</code> 可能会评估为 null，但由未被声明为 @{0} 的方法返回
dataflow.message.storing.array.null=<code>null</code> 已存储到 @NotNull 元素的数组中
dataflow.message.storing.array.nullable=表达式 <code>#ref</code> 可能会评估为 null，但已存储到 @NotNull 元素的数组
dataflow.message.unboxing.nullable.argument.methodref=将实参传递到方法引用需要拆箱，这可能会产生 <code>NullPointerException</code>
dataflow.message.unboxing.method.reference=使用 <code>#ref</code> #loc 需要取消装箱，这可能会产生 <code>java.lang.NullPointerException</code>
dataflow.message.unboxing=拆箱的 <code>#ref</code> #loc 可能产生 <code>java.lang.NullPointerException</code>
dataflow.message.unreachable.switch.label=Switch 标签 <code>#ref</code> #loc 不可到达
dataflow.message.constant.expression=<code>#ref</code> #loc 的结果总是 ''{0}''
dataflow.message.constant.value=值 <code>#ref</code> #loc 总是 ''{0}''
dataflow.method.fails.with.null.argument=当形参为 null 时，方法将抛出异常
dataflow.message.unknown.nullability=(可 null 性未知)
dataflow.not.precise={0} 复杂: 数据流结果可能不准确
dataflow.too.complex=方法 <code>#ref</code> 太复杂，无法通过数据流算法进行分析

delete.repeated.0=删除重复的 ''{0}''
delete.repeated.interface=删除重复的接口
exception.removal.will.break.source.code.proceed.anyway=异常移除会破坏源代码。仍然继续?

feature.generics=泛型
feature.annotations=注解
feature.static.imports=静态导入
feature.for.each=For-each 循环
feature.varargs=可变 arity 方法
feature.hex.fp.literals=十六进制浮点文字
feature.diamond.types=Diamond 类型
feature.multi.catch=多 catch
feature.try.with.resources=Try-with-resources
feature.binary.literals=二进制文字
feature.underscores.in.literals=在文字中加下划线
feature.extension.methods=扩展方法
feature.method.references=方法引用
feature.lambda.expressions=Lambda 表达式
feature.type.annotations=类型注解
feature.type.receivers=接收器形参
feature.intersections.in.casts=转换中的交叉类型
feature.static.interface.calls=static 接口方法调用
feature.try.with.resources.refs=资源引用
feature.modules=模块
feature.lvti=局部变量类型推断
feature.var.lambda.parameter=lambda 形参中的 'var'
feature.text.blocks=文本块文字
feature.text.block.escape.sequences='\\s' 和 '\' 转义序列
feature.enhanced.switch=增强的 'switch' 块
feature.switch.expressions='switch' 表达式
feature.records=记录
feature.patterns.instanceof='instanceof' 中的模式
feature.sealed.classes=密封类
feature.local.interfaces=本地接口
feature.local.enums=本地枚举
feature.inner.statics=内部类中的 static 声明

find.searching.for.references.to.class.progress=正在查找对类 {0} 的引用…
find.usages.panel.title.derived.classes=派生类
find.usages.panel.title.derived.interfaces=派生接口
find.usages.panel.title.implementing.classes=实现类
find.usages.panel.title.implementing.methods=实现方法
find.usages.panel.title.overloaded.methods.usages=重载方法
find.usages.panel.title.overriding.methods=重写方法
message.class.inaccessible.from.module=类 ''{0}'' 无法从模块 ''{1}'' 访问
message.class.inaccessible=类 ''{0}'' 无法在此处访问

inspection.i18n.quickfix.annotate=注解…
inspection.i18n.quickfix.annotate.as=注解为 @{0}
inspection.i18n.quickfix.annotate.element=注释 {0} ''{1}''…
inspection.i18n.quickfix.annotate.element.as=在{0} ''{1}'' 上添加注解 @{2}
inspection.reference.default.package=<默认>
error.message.invalid.java.type=无效的 Java 类型
move.0.to.the.beginning=将 ''{0}'' 移动到开头
move.to.front=移到前面
processing.method.usages=正在处理方法用例…
qualify.0=限定 {0}
qualify.with.0.this=使用 {0}.this 限定
remove.annotation=移除注解
remove.left.side.of.assignment=移除赋值的左侧
replace.get.class.with.class.literal=使用 .class 文字替换 getClass()
service.provides=提供服务
service.uses=使用服务
suppress.for.parameter=对形参禁止
suppress.for.statement.with.comment=对包含注释的语句禁止
intention.add.annotation.family=添加注解
intention.add.type.annotation.family=添加类型注解
intention.text.remove.annotation=移除

scope.package=软件包 {0}

0.field.is.always.initialized.not.null=@{0} 字段始终为初始化的非 null
access.can.be.0=访问可以是 ''{0}''
access.to.field.code.ref.code.outside.of.declared.guards.loc=访问声明的临界外部的字段 <code>#ref</code> #loc
call.to.method.code.ref.code.outside.of.declared.guards.loc=在声明的临界之外调用方法 <code>#ref()</code> #loc
annotate.as.safevarargs=注解为 '@SafeVarargs'
annotate.overridden.methods.parameters.family.name=注解被重写的方法形参
annotate.overridden.methods.parameters=将被重写的方法形参注解为 ''@{0}''
anonymous.ref.loc.can.be.replaced.with.0=匿名 #ref #loc 可被替换为 {0}
anonymous.ref.loc.can.be.replaced.with.lambda=匿名 #ref #loc 可被替换为 lambda
assigning.a.collection.of.nullable.elements=正在将可空元素集合指定给非空元素集合
nullable.stuff.error.overriding.nullable.with.notnull=使用非 null 元素集合重写可 null 元素的集合
nullable.stuff.error.overriding.notnull.with.nullable=使用可 null 元素集合重写非 null 元素的集合
comparision.between.object.and.primitive=对象与基元之间的比较非法，仅在 Java 7 中接受
custom.exception.class.should.have.a.constructor=自定义异常类应具有一个包含字符串类型的单个消息形参的构造函数
delimiters.argument.contains.duplicated.characters=分隔符实参包含重复的字符
deprecated.class.usage.group.xml=XML
deprecated.member.0.is.still.used=弃用的成员 ''{0}'' 仍在使用
detach.library.quickfix.name=分离库
detach.library.roots.quickfix.name=分离未使用的库根
don.t.report.unused.jars.inside.used.library=不要在使用的库内报告未使用的 jar
explicit.type.argument.ref.loc.can.be.replaced.with=显式类型实参 #ref #loc 可被替换为 <>
exports.to.itself.delete.module.ref.fix=删除模块''{0}''的引用
exports.to.itself.delete.statement.fix=删除声明
html.classes.exposed.with.code.module.info.code.html=<html>类通过 <code>module-info</code> 公开</html>
html.ignore.overrides.of.deprecated.abstract.methods=<html>在未弃用的 super 中忽略弃用的 abstract 方法的重写</html>
ignore.casts.in.suspicious.collections.method.calls=忽略澄清转换
ignore.exceptions.thrown.by.entry.points.methods=忽略由入口点方法引发的异常
ignore.in.the.same.outermost.class=在相同的最外侧类中忽略
ignore.inside.deprecated.members=在弃用的成员内忽略
ignore.inside.non.static.imports=在非静态导入内忽略
ignore.members.of.deprecated.classes=忽略弃用类的成员
ignore.operation.which.results.in.negative.value=忽略 '<<' 操作，后者会导致负值
inspection.annotate.method.quickfix.family.name=标注方法
inspection.annotate.method.quickfix.name=使用 ''@{0}'' 注解方法
inspection.annotate.overridden.method.and.self.quickfix.family.name=注解重写的方法和本身
inspection.annotate.overridden.method.and.self.quickfix.name=使用 ''@{0}'' 注解重写的方法和本身
inspection.annotate.overridden.method.quickfix.family.name=注释覆盖方法
inspection.annotate.overridden.method.quickfix.name=使用 ''@{0}'' 注解重写的方法
inspection.annotate.overridden.method.nullable.quickfix.name=将重写的方法注解为 ''@{0}''
inspection.c.style.array.declarations.option=忽略变量中的 C 样式声明
inspection.can.be.final.accept.quickfix=设为 final
inspection.can.be.final.option1=报告方法
inspection.can.be.final.option2=报告字段
inspection.can.be.final.option=报告类
inspection.can.be.local.parameter.problem.descriptor=形参 <code>#ref</code> 可以具有 <code>final</code> 修饰符
inspection.can.be.local.variable.problem.descriptor=变量 <code>#ref</code> 可以具有 <code>final</code> 修饰符
inspection.can.be.replaced.with.message=可被替换为 ''{0}''
inspection.class.getclass.display.name='Class.getClass()' 调用可疑
inspection.class.getclass.fix.remove.name=移除 'getClass()' 调用
inspection.class.getclass.fix.replace.name=替换为 'Class.class'
inspection.class.getclass.message=在类实例上调用了 'getClass()'
inspection.class.has.no.to.string.method.description=类 ''{0}'' 不会重写 ''toString()'' 方法
inspection.class.has.no.to.string.method.exclude.classes.reg.exp.option=排除类 (reg exp):
inspection.class.has.no.to.string.method.ignore.abstract.classes.option=忽略 abstract 类
inspection.class.has.no.to.string.method.ignore.deprecated.classes.option=忽略弃用的类
inspection.class.has.no.to.string.method.ignore.enum.classes.option=忽略枚举类
inspection.class.has.no.to.string.method.ignore.records.option=忽略记录
inspection.class.has.no.to.string.method.ignore.exception.classes.option=忽略异常类
inspection.class.has.no.to.string.method.ignore.inner.classes.option=忽略内部类
inspection.class.has.no.to.string.method.ignore.test.classes.option=忽略测试类
inspection.common.if.parts.disable.highlight.tail.call=如果尾语句是调用，则不要高亮显示公用部分
inspection.common.if.parts.family.else.if.description=可以合并 'else if'
inspection.common.if.parts.family.else.if=合并 'else if' 语句
inspection.common.if.parts.family=提取 'if' 语句的公用部分
inspection.common.if.parts.settings.highlight.when.tail.call=在最后一条公用语句为调用时高亮显示
inspection.compiler.javac.quirks.anno.array.comma.fix=移除尾随逗号
inspection.compiler.javac.quirks.anno.array.comma.problem=注解数组初始值设定项中的尾随逗号可能会在某些 Javac 版本(例如 JDK 5 和 JDK 6)中导致编译错误。
inspection.compiler.javac.quirks.name=Javac 杂项
inspection.compiler.javac.quirks.qualifier.type.args.fix=移除泛型形参
inspection.compiler.javac.quirks.qualifier.type.args.problem=限定符引用中的泛型可能会导致某些Javac版本(例如JDK 5和JDK 6)中的编译错误.
inspection.constant.on.wrong.side.of.a.comparison.side.option=常量应在比较的这一侧:
inspection.contract.display.name=合同的问题
inspection.data.flow.redundant.instanceof.quickfix=替换为!= null
inspection.data.flow.simplify.boolean.expression.quickfix=简化布尔表达式
inspection.data.flow.simplify.to.assignment.quickfix.name=简化正常作业
inspection.data.flow.turn.off.constant.references.quickfix=不要报告总是不变的值
inspection.data.flow.turn.off.nullable.returning.notnull.quickfix=不要报告总是返回非空值的方法
inspection.data.flow.turn.off.true.asserts.quickfix=不要报告总是为true的断言
inspection.duplicate.throws.display.name=重复抛出
inspection.duplicate.throws.ignore.subclassing.option=忽略子类化其他异常的异常
inspection.duplicate.throws.more.general.problem=在抛出列表,这是一个普通异常''{0}''.
inspection.duplicate.throws.problem=throws 重复
inspection.equals.hashcode.only.one.defined.problem.descriptor=类有{0}定义但没有定义{1}
inspection.export.results.can.be.final.description=声明可以具有 final 修饰符
inspection.expression.can.be.replaced.with.message=表达式可被替换为 ''{0}''
inspection.field.not.used.in.to.string.description2=字段 ''{0}'' 未在 ''toString()'' 方法中使用
inspection.field.not.used.in.to.string.description=方法 ''{0}'' 未在 ''toString()'' 方法中使用
inspection.implicit.subclass.display.forClass=类 ''{0}'' 可以隐式子类化，并且不得为 final
inspection.implicit.subclass.display.name=final 声明不能在运行时被重写
inspection.implicit.subclass.extendable=使''{0}''可以覆盖
inspection.implicit.subclass.make.class.extendable=使类''{0}'' {1,choice,0#|1#和方法 {2} |1<和 {1} 个必须的方法}可扩展
inspection.infinite.loop.option=放置在 Thread.run 中时忽略
inspection.java.module.naming.terminal.digits=模块名称组件''{0}''应避免终端数字
inspection.java.module.naming=Java 模块名称与惯例相矛盾
inspection.local.can.be.final.display.name=局部变量或形参可以是 'final'
inspection.local.can.be.final.option1=报告方法形参
inspection.local.can.be.final.option2=报告 catch 形参
inspection.local.can.be.final.option3=报告 foreach 形参
inspection.local.can.be.final.option4=<html>报告为隐式 final 的变量<br/>(多 catch 或使用 try-with-resources 形参)</html>
inspection.local.can.be.final.option=报告局部变量
inspection.module.exports.package.to.itself=模块将软件包导出/打开到本身
inspection.nullable.problems.NotNull.parameter.overrides.Nullable=使用 @{0} 注解的形参不得重写 @{1} 形参
inspection.nullable.problems.NotNull.parameter.overrides.not.annotated=使用 @{0} 注解的形参不应重写非注解形参
inspection.nullable.problems.NotNull.parameter.receives.null.literal=使用 @{0} 注解的形参不应该接收 ''null'' 作为实参
inspection.nullable.problems.Nullable.NotNull.conflict=不能同时使用 @{0} 和 @{1} 注解
inspection.nullable.problems.Nullable.method.overrides.NotNull=@Nullable 注解的方法不能重写为 @NotNull 方法
inspection.nullable.problems.annotated.field.constructor.parameter.not.annotated=@{0} 字段的构造函数形参可能会使用 @{0} 自身注解
inspection.nullable.problems.annotated.field.getter.conflict=@{0}字段的Getter已经注解 @{1}
inspection.nullable.problems.annotated.field.getter.not.annotated=@{0}字段的Getter可能会注解 @{0}本身
inspection.nullable.problems.annotated.field.setter.parameter.conflict=@{0} 字段的 setter 形参使用 @{1} 注解
inspection.nullable.problems.annotated.field.setter.parameter.not.annotated=@{0} 字段的 setter 形参可能会使用 @{0} 自身注解
inspection.nullable.problems.method.overrides.NotNull=未注解的方法重写为 @NotNull 注解的方法
inspection.nullable.problems.parameter.overrides.NotNull=未注解的形参重写 @{0} 形参
inspection.nullable.problems.primitive.type.annotation=不能注解基元类型成员
inspection.nullable.problems.receiver.annotation=接收器参数本身非 null
inspection.nullable.problems.outer.type=外部类型本身非 null
inspection.nullable.problems.at.constructor=可 null 性注解不适用于构造函数
inspection.nullable.problems.at.enum.constant=可 null 性注解不适用于枚举常量
inspection.nullable.problems.at.wildcard=可 null 性注解不适用于通配符类型
inspection.nullable.problems.at.local.variable=可 null 性注解不适用于局部变量
inspection.nullable.problems.at.type.parameter=可 null 性注解不适用于类型形参
inspection.nullable.problems.at.reference.list=可 null 性注解不适用于 extends/implements 子句
inspection.objects.equals.can.be.simplified.display.name='Objects.equals()' 可被替换为 'equals()'
inspection.redundant.cast.problem.descriptor=Casting <code>{0}</code> to <code>#ref</code> #loc is redundant
inspection.redundant.cast.remove.quickfix=移除多余的转换
inspection.redundant.field.initialization.option=仅在初始化为 null 时发出警告
inspection.redundant.requires.statement.description=冗余语句 ''requires {0}''.
inspection.redundant.requires.statement.fix.family=删除冗余 'requires' 语句
inspection.redundant.requires.statement.fix.name=删除语句 ''requires {0}''
inspection.redundant.throws.problem.descriptor1=声明的异常 <code>#ref</code> 从不在此方法或其重写方法中抛出
inspection.redundant.throws.problem.descriptor2=声明的异常 <code>#ref</code> 从不抛出
inspection.redundant.throws.problem.descriptor=声明的异常 <code>#ref</code> 从不在任何方法实现中抛出
inspection.redundant.throws.remove.quickfix=删除不必要的抛出声明
inspection.redundant.type.display.name=冗余类型实参
inspection.redundant.type.no.generics.method.reference.problem.descriptor=类型实参对于非泛型方法引用是冗余的
inspection.redundant.type.no.generics.problem.descriptor=类型实参对于非泛型方法调用是冗余的
inspection.redundant.type.problem.descriptor=显式类型实参可以推断
inspection.redundant.type.remove.quickfix=移除类型实参
inspection.reference.anonymous.name=匿名 ({0})
inspection.reference.implicit.constructor.name=隐式构造函数{0}
inspection.reference.jsp.holder.method.anonymous.name=<% 页面内容 %>
inspection.requires.auto.module.message=自动导入模块需要'requires'指令
inspection.requires.auto.module.option=仅高亮显示可传递依赖项
inspection.requires.auto.module.transitive=自动模块需要'requires transitive'指令
inspection.requires.auto.module=依赖于自动模块
inspection.same.return.value.display.name=方法始终返回相同的值
inspection.same.return.value.problem.descriptor1=方法 <code>#ref()</code> 及其所有重写方法始终返回 <code>{0}</code>
inspection.same.return.value.problem.descriptor2=方法 <code>#ref()</code> 的所有实现始终返回 <code>{0}</code>
inspection.same.return.value.problem.descriptor=方法 <code>#ref()</code> 始终返回 <code>{0}</code>
inspection.surround.requirenonnull.quickfix=替换为''Objects.requireNonNull({0})''
inspection.suspicious.array.method.call.display.name=可疑的 'Arrays' 方法调用
inspection.suspicious.array.method.call.problem.arrays=Array类型不兼容：数组总是不同的
inspection.suspicious.array.method.call.problem.element=元素类型与数组类型不兼容
inspection.suspicious.collections.method.calls.display.name=可疑的集合方法调用
inspection.suspicious.collections.method.calls.problem.descriptor1=可疑的调用''{0}''
inspection.suspicious.collections.method.calls.problem.descriptor=''{0}''可能不包含对象类型''{1}''
inspection.suspicious.getter.setter.field.option=仅在存在字段匹配 getter/setter 名称时发出警告
inspection.suspicious.integer.div.assignment.option=报告可疑但可能准确的除法
inspection.unary.plus.unary.binary.option=仅在混乱的二进制或一元表达式上下文中报告
inspection.unnecessary.super.qualifier.option=忽略说明 'super' 限定符
inspection.use.compare.method.fix.family.name=替换为单个比较方法
inspection.visibility.accept.quickfix=接受建议的访问级别
inspection.visibility.compose.suggestion=可以是 {0}
inspection.visibility.option.constants=为常量建议较弱的可见性
inspection.visibility.option.package.private.members=为类成员建议 package-private 可见性级别
inspection.visibility.package.private.top.level.classes=为顶级类建议 package-private 可见性级别
inspection.visibility.private.inner.members=<html>仅在从外部类引用时为内部类成员建议 private</html>
instance.member.guarded.by.static.0.loc=由 static“{0}”保护的实例成员 #loc
instance.member.guarded.by.static.ref.loc=由 static #ref 保护的实例成员 #loc
make.0.default.annotation=将“{0}”设为默认注解
make.default.the.last.case.family.name=使 'default' 为最后一个 case
make.final.and.annotate.as.safevarargs=设为 final 并注解为 '@SafeVarargs'
method.reference.mapped.to.comparator=映射到 'Comparator' 接口的方法引用不会履行 'Comparator' 约定
module.0.with.language.level.1.depends.on.module.2.with.language.level.3=语言级别为 {1} 的模块 {0} 取决于语言级别为 {3} 的模块 {2}
non.final.field.code.ref.code.in.immutable.class.loc=非最终字段 <code>#ref</code> 位于 @Immutable 类中 #loc
non.final.guarded.by.field.0.loc=非最终 @GuardedBy 字段“{0}”#loc
non.final.guarded.by.field.ref.loc=非最终 @GuardedBy 字段 #ref #loc
non.null.type.argument.is.expected=应为非 null 类型实参
nullable.stuff.problems.overridden.method.parameters.are.not.annotated=被重写的方法形参不会被注解
nullable.stuff.problems.overridden.methods.are.not.annotated=重写的方法不是注释
parameter.can.be.null=形参可以为 null
parameter.is.always.not.null=形参始终为非 null
possible.heap.pollution.from.parameterized.vararg.type.loc=来自形参化 vararg 类型的可能的堆污染 #loc
redundant.block.marker=冗余块标记
remove.block.marker.comments=移除块标记注释
remove.dependency=移除依赖项
remove.switch.branch.0=移除 switch 分支 ''{0}''
remove.switch.label.0=移除 switch 标签 ''{0}''
remove.switch.label=移除 switch 标签
replace.0.with=将“{0}”替换为“=”
replace.anonymous.class.with.lambda.alternative=将匿名类替换为 lambda 替代项
replace.operator.assignment.with.assignment=将运算符赋值替换为赋值
replace.stringtokenizer.delimiters.parameter.with.unique.symbols=将 StringTokenizer 分隔符形参替换为唯一的符号
replace.var.with.explicit.type=将 'var' 替换为显式类型
replace.with.0=替换为 {0}
replace.with.comparator=替换为比较运算符
replace.with.constant.value=替换为常量值
replace.with.expression.lambda=替换为表达式 lambda
replace.with.lambda=替换为 lambda
report.suspicious.but.possibly.correct.method.calls=报告可疑的，但可能是正确的方法调用 (&R)
report.when.interface.is.not.annotated.with.functional.interface=在接口未使用 @FunctionalInterface 注解时报告
searching.for.overriding.methods=正在搜索重写方法
statement.lambda.can.be.replaced.with.expression.lambda=语句 lambda 可被替换为表达式 lambda
static.inheritrance.fix.replace.progress=正在替换 {0} 的用例
static.member.guarded.by.instance.0.loc=由实例“{0}”保护的 static 成员 #loc
static.member.guarded.by.instance.ref.loc=由实例保护的 static 成员 #ref #loc
suppress.all.for.class=禁止类的所有检查
suppress.inspection.class=抑制类(class)
suppress.inspection.field=对字段禁止
suppress.inspection.member=抑制分子
suppress.inspection.method=对方法禁止
suppress.inspection.module=对模块声明禁止
suspected.module.dependency.problem.descriptor=模块''{0}''不依赖于模块''{1}''. 虽然''{2}''不需要为输出依赖关系检查''{1}''
unknown.guardedby.reference.0.loc=未知的 @GuardedBy 引用“{0}”#loc
unknown.guardedby.reference.ref.loc=未知的 @GuardedBy 引用 #ref #loc
unnecessary.module.dependency.display.name=不必要的模块依赖
unnecessary.module.dependency.problem.descriptor=模块''{0}''源不依赖于模块''{1}''源
unused.import.display.name=未使用的 import
unused.import.statement=未使用的 import 语句
unused.library.display.name=未使用的库
unused.library.problem.descriptor=未使用的库''{0}''
unused.library.roots.problem.descriptor=未使用的根{0}从库''{1}''
var.can.be.replaced.with.explicit.type='var' 可被替换为显式类型
vararg.method.call.with.50.poly.arguments=具有超过 50 个 poly 实参的 vararg 方法调用可能会导致编译和分析速度减慢
inspection.inconsistent.language.level.display.name=语言级别设置不一致
inspection.weaker.access.display.name=声明访问可能较弱
inspection.can.be.final.display.name=声明可以有 'final' 修饰符
inspection.redundant.throws.display.name=冗余 'throws' 子句
inspection.java.9.redundant.requires.statement.display.name=module-info 中的冗余 'requires' 指令
inspection.numeric.overflow.display.name=数值溢出
inspection.redundant.cast.display.name=冗余类型转换
inspection.deprecated.is.still.used.display.name=弃用的成员仍在使用
inspection.deprecated.class.usage.inspection.display.name=XML 中的弃用 API 用法
inspection.field.access.not.guarded.display.name=不受保护的字段访问或方法调用
inspection.instance.guarded.by.static.display.name=由 static 字段保护的实例成员
inspection.non.final.field.in.immutable.display.name='@Immutable' 类中有非 final 字段
inspection.non.final.guard.display.name=非 final '@GuardedBy' 字段
inspection.static.guarded.by.instance.display.name=由实例字段或 this 防护的 static 成员
inspection.unknown.guard.display.name=未知 '@GuardedBy' 字段
inspection.use.compare.method.display.name=可以使用 'compare()' 方法比较数值
inspection.convert.2.diamond.display.name=显式类型可被替换为 '<>'
inspection.convert.2.lambda.display.name=匿名类型可被替换为 lambda
inspection.invalid.comparator.method.reference.display.name=用于 'Comparator' 的无效方法引用
inspection.safe.varargs.detector.display.name=形参化 vararg 类型可能导致堆污染
inspection.block.marker.comments.display.name=块标记注释
inspection.string.tokenizer.delimiter.display.name='StringTokenizer' 中的分隔符重复
inspection.anonymous.has.lambda.alternative.display.name=匿名类型有较短的 lambda 替代项
inspection.java.8.list.sort.display.name='Collections.sort()' 可被替换为 'List.sort()'
inspection.class.has.no.to.string.method.display.name=类不会重写 'toString()' 方法
inspection.field.not.used.in.to.string.display.name=字段未在 'toString()' 方法中使用
inspection.contract.checker.clause.syntax=协定子句的格式必须为 arg1, ..., argN -> 返回值
inspection.contract.checker.unknown.return.value=返回值应为以下值之一: {0}。实际为 {1}
inspection.contract.checker.unknown.constraint=约束应为以下值之一: {0}。实际为 {1}
inspection.contract.checker.empty.constraint=约束不应为空
inspection.contract.checker.unreachable.contract.clause=协定子句 ''{0}'' 不可到达: 以前的协定涵盖了所有可能的情况
inspection.contract.checker.contract.clause.never.satisfied=协定子句 ''{0}'' 从未满足，因为以前的协定涵盖了其条件
inspection.contract.checker.pure.method.mutation.contract=纯方法不能有突变协定
inspection.contract.checker.parameter.count.mismatch=方法采用 {0} 个形参，而协定子句 ''{1}'' 预期 {2} 个
inspection.contract.checker.primitive.parameter.nullability=形参 ''{0}'' 具有基元类型 ''{1}''，因此 ''{2}'' 不适用
inspection.contract.checker.inferred.notnull.parameter.null=形参 ''{0}'' 被推断为非 null，因此 ''null'' 不适用
inspection.contract.checker.notnull.parameter.null=形参 ''{0}'' 被注解为非 null，因此 ''null'' 不适用
inspection.contract.checker.inferred.notnull.parameter.notnull=形参 ''{0}'' 被推断为非 null，因此 ''!null'' 始终满足
inspection.contract.checker.notnull.parameter.notnull=形参 ''{0}'' 被注解为非 null，因此 ''!null'' 始终满足
inspection.contract.checker.boolean.condition.for.nonboolean.parameter=形参 ''{0}'' 具有 ''{1}'' 类型(应为布尔型)
inspection.contract.checker.contract.violated=违反协定子句 ''{0}''
inspection.contract.checker.no.exception.thrown=违反协定子句 ''{0}'': 未抛出异常
inspection.contract.checker.method.always.fails.trivial=子句 ''{0}'' 的返回值可被替换为 ''fail''，因为方法总是失败
inspection.contract.checker.method.always.fails.nontrivial=子句 ''{0}'' 的返回值可被替换为 ''fail''，因为此子句中的方法总是失败
contract.return.validator.not.applicable.for.constructor=不适用于构造函数
contract.return.validator.not.applicable.static=不适用于 static 方法
contract.return.validator.not.applicable.primitive=不适用于基元返回类型 ''{0}''
contract.return.validator.return.type.must.be.boolean=方法返回类型必须为 'boolean'
contract.return.validator.method.return.incompatible.with.method.containing.class=方法返回类型应与包含类的方法兼容
contract.return.validator.too.few.parameters=not applicable for method that has {0, choice, 0#no parameters|1#one parameter|2#{0} parameters}
contract.return.validator.incompatible.return.parameter.type=返回类型 ''{0}'' 必须可以从形参类型 ''{1}'' 转换而来
contract.return.value.validation.prefix=协定返回值 ''{0}'':
suspicious.invocation.handler.implementation.display.name=可疑的 'InvocationHandler' 实现
suspicious.invocation.handler.implementation.method.unused.message=方法从未在 'invoke' 中使用: 'hashCode'、'equals' 和 'toString' 不太可能正确实现
suspicious.invocation.handler.implementation.type.mismatch.message=代理方法 ''{0}()'' 时，可能返回不兼容类型: 要求 {1}，实际为 {2}
suspicious.invocation.handler.implementation.null.returned.for.toString.message=代理方法 'toString()' 时，可能返回 null: 不建议如此操作
suspicious.invocation.handler.implementation.null.returned.message=代理方法 ''{0}()'' 时，可能返回 null: 这可能导致 NullPointerException
error.class.not.found=找不到类 {0}
intention.name.qualify.expression=使用 ''{1}'' 限定 {0} 表达式
nullability.null=null
nullability.nullable=可 null
nullability.non.null=非 null
duplication.policy.ask=询问
duplication.policy.replace=替换现有
duplication.policy.generate.duplicate=生成重复方法
dftype.presentation.empty.optional=空 Optional
dftype.presentation.present.optional=目前的 Optional
mutability.unknown=未知
mutability.modifiable=可修改
mutability.must.not.modify=不应修改的输入形参
mutability.unmodifiable.view=不可修改的视图
mutability.unmodifiable=不可修改
special.field.array.length=数组长度
special.field.string.length=字符串长度
special.field.collection.size=大小
special.field.unboxed.value=拆箱的值
special.field.optional.value=可选值
text.unused.import.in.template=未使用的 import (在模板中指定)
text.raw.ctor.reference.with.type.parameters=原始构造函数引用具有构造函数的显式类型形参

dfa.find.cause.unable=找不到原因
dfa.find.cause.cast.may.fail=转换可能失败
dfa.find.cause.may.be.null=可能为 null
dfa.find.cause.call.always.fails=调用始终失败
dfa.find.cause.one.of.the.following.happens=发生以下情况之一:
dfa.find.cause.an.execution.might.exist.where=一个执行可能存在于:
dfa.find.cause.value.is.always.the.same=值始终为 {0}
dfa.find.cause.value.x.is.always.the.same=值 ''{0}'' 始终为 ''{1}''
dfa.find.cause.compile.time.constant=编译时常量，值为 ''{0}''
dfa.find.cause.equality.established.from.condition=''{0}'' 自条件建立
dfa.find.cause.was.assigned.to=''{0}'' 已分配到 ''{1}''
dfa.find.cause.was.assigned=''{0}'' 已分配
dfa.find.cause.operand.of.boolean.expression.is.the.same={1, choice, 0#and|1#or}-链的操作数 #{0} 是 {2}
dfa.find.cause.comparison.arguments.are.the.same=比较实参相同
dfa.find.cause.comparison.arguments.are.different.constants=比较实参为不同常量
dfa.find.cause.variable.is.initialized={0} ''{1}'' 初始化为 {2}
dfa.find.cause.object.kind.generic=对象
dfa.find.cause.object.kind.expression=表达式
dfa.find.cause.object.kind.method.return=方法返回
dfa.find.cause.type.known={0} 类型为 {1}
# ___PLACE___ is replaced with dfa.find.cause.place.*
dfa.find.cause.type.is.known.from.place=从 ___PLACE___ 已知 ''{0}'' 类型
dfa.find.cause.condition.is.known.from.place=已知 ''{0}'' 来自 ___PLACE___
dfa.find.cause.range.is.known.from.place=从 ___PLACE___ 已知范围
dfa.find.cause.value.is.known.from.place=''{0}'' 已知为来自 ___PLACE___ 的 ''{1}''
dfa.find.cause.place.line.number=行 #{0}
dfa.find.cause.place.here=此处
dfa.find.cause.values.cannot.be.equal.because=值不能相等，因为 {0}
dfa.find.cause.condition.was.checked.before=条件 ''{0}'' 先前已检查
dfa.find.cause.condition.was.deduced=条件 ''{0}'' 已被推导
dfa.find.cause.was.passed.as.non.null.parameter=''{0}'' 作为实参传递到接受非 null 形参的方法
dfa.find.cause.was.dereferenced=''{0}'' 已取消引用
dfa.find.cause.instanceof.implies.non.nullity='instanceof' 检查表示非 null
dfa.find.cause.nullability.inferred={0} ''{1}'' 已推断为 ''{2}''
dfa.find.cause.nullability.externally.annotated={0} ''{1}'' 外部注解为 ''{2}''
dfa.find.cause.nullability.explicitly.annotated={0} ''{1}'' 注解为 ''{2}''
dfa.find.cause.nullability.inherited.from.container={0} ''{1}'' 继承容器注解，因此 ''{2}''
dfa.find.cause.nullability.inherited.from.class={0} ''{1}'' 自类 {2} 继承注解，因此 ''{3}''
dfa.find.cause.nullability.inherited.from.package={0} ''{1}'' 自软件包 {2} 继承注解，因此 ''{3}''
dfa.find.cause.nullability.inherited.from.named.element={0} ''{1}'' 继承自 {2}，因此 ''{3}''
dfa.find.cause.field.initializer.nullability=字段 ''{0}'' 初始化为 ''{1}'' 值
dfa.find.cause.field.assigned.nullability=已知字段 ''{0}'' 始终初始化为 ''{1}'' 值
dfa.find.cause.array.length.is.always.non.negative=数组长度始终为非负数
dfa.find.cause.string.length.is.always.non.negative=字符串长度始终为非负数
dfa.find.cause.collection.size.is.always.non.negative=集合大小始终为非负数
dfa.find.cause.range.is.specified.by.annotation=注解将 ''{0}'' 的范围指定为 {1}
# %s is replaced with value range like {0..255} or 'odd', etc. (see long.range.set.presentation.* above)
dfa.find.cause.result.of.primitive.cast.template=''({0})'' 转换的结果为 %s
dfa.find.cause.result.of.numeric.operation.template=''{0}'' 的结果为 %s
dfa.find.cause.left.operand.range.template=左操作数为 %s
dfa.find.cause.right.operand.range.template=右操作数为 %s
dfa.find.cause.numeric.cast.operand.template=转换操作数为 %s
dfa.find.cause.numeric.range.generic.template=值为 %s
# Here {0} is replaced with dfa.find.cause.nonnull.expression.kind.*
dfa.find.cause.obviously.non.null.expression=表达式不可为 null，因为它是 {0}
dfa.find.cause.nonnull.expression.kind.newly.created.object=新创建的对象
dfa.find.cause.nonnull.expression.kind.literal=文字
dfa.find.cause.nonnull.expression.kind.primitive.type=基元类型 ''{0}'' 的值
dfa.find.cause.nonnull.expression.kind.concatenation=串联
dfa.find.cause.nonnull.expression.kind.this.object='this' 对象
# Here {0} is replaced with dfa.find.cause.contract.kind.*
dfa.find.cause.contract.trivial=根据{0}，{1} ''{2}'' 始终返回 ''{3}'' 值
dfa.find.cause.contract.throws.on.condition=根据{0}，{1} ''{2}'' 会在{3}时抛出异常
dfa.find.cause.contract.returns.on.condition=根据{0}，{1} ''{2}'' 会在{4}时返回 ''{3}''
dfa.find.cause.contract.kind.explicit=约定
dfa.find.cause.contract.kind.inferred=推断约定
dfa.find.cause.contract.kind.hard.coded=硬编码约定

type.constraint.assignability.explanation.exact={0} 已知为 {1}
type.constraint.assignability.explanation.exact.subtype={0} 类型恰好是 {1}，是 {2} 的子类型
type.constraint.assignability.explanation.exact.not.subtype={0} 类型恰好是 {1}，不是 {2} 的子类型
type.constraint.assignability.explanation.subtype.of.subtype=已知 {0} 是 {1}，是 {2} 的子类型
type.constraint.assignability.explanation.not.instance.of=已知 {0} 不是 {1}
type.constraint.assignability.explanation.not.instance.of.supertype=已知 {0} 不是 {2} 的父类型 {1}
type.constraint.assignability.explanation.definitely.inconvertible=已知 {0} 是 {1}，与 {2} 绝对不兼容
inspection.message.javac.quick.intersection.type.problem=因为 ''{1}'' 为 final，交叉点类型 ''{0}'' 无法实例化
suggest.package.private.visibility.level.for.classes.in.exported.packages.java.9=在导出的软件包中为类建议 package-private 可见性级别(Java 9+)
generate.members.position.at.caret=文本光标处
generate.members.position.after.equals.and.hashcode=equals() 和 hashCode() 后
generate.members.position.at.the.end.of.class=类结尾处

navigate.to.overridden.methods.title={0} 的重写方法
subclasses.search.progress.title=正在搜索被重写的方法
progress.title.searching.for.overridden.methods=正在搜索被重写的方法
arguments.count.mismatch=应为 {0} 个实参，但实际为 {1} 个
inspection.message.nullable.method.implements.non.null.method=''{1}'' 中可为 null 的方法 ''{0}'' 实现 ''{2}'' 中的非 null 方法
inspection.message.non.annotated.method.implements.non.null.method=''{1}'' 中的非注解方法 ''{0}'' 实现 ''{2}'' 中的非 null 方法
inspection.message.non.null.parameter.should.not.override.nullable.parameter=''{2}'' 中方法 ''{1}'' 的非 null 形参 ''{0}'' 不应当重写 ''{3}'' 中可为 null 的形参
inspection.message.non.annotated.parameter.should.not.override.non.null.parameter=''{2}'' 中方法 ''{1}'' 的非注解形参 ''{0}'' 不应当重写 ''{3}'' 中非 null 形参
inspection.message.non.null.parameter.should.not.override.non.annotated.parameter=''{2}'' 中方法 ''{1}'' 的非 null 形参 ''{0}'' 不应当重写 ''{3}'' 中的非注解形参
element.kind.keys=键
element.kind.values=值
element.kind.objects=对象
mutation.signature.problem.static.method.cannot.mutate.this=static 方法无法改变 'this'
mutation.signature.problem.reference.to.parameter.invalid=形参 #{0} 的引用无效
mutation.signature.problem.parameter.has.immutable.type=形参 #{0} 具有不可变类型 ''{1}''
mutation.signature.problem.invalid.token=无效的令牌: {0}；受支持的令牌为 ''this''、''param1''、''param2'' 等。
required.type=必需类型
provided.type=已提供
type.mismatch.reason=原因: {0}
inspection.message.code.generation.different.nullability.annotation.will.be.used=生成的代码将使用 ''{1}'' 而不是 ''{0}''。
change.visibility.level=将 {0} 设为 {1}
text.shebang.mechanism.in.java.files.not.permitted=不支持在 .java 文件中使用事件机制
inspection.redundant.tostring.option.notnull.qualifier=仅在已知限定符为非 null 时报告
highlighting.try.blocks=正在高亮显示 try 块…
intention.family.name.remove.new.family.name=移除 'new'
intention.name.remove.new.display.name=移除 'new'
inspection.unsatisfied.range.display.name=返回值超出声明的范围
inspection.unsatisfied.range.message=返回值范围 ''{0}'' 在声明的范围 ''{1}'' 之外
inspection.unsatisfied.range.message.value=返回值 ''{0}'' 超出声明的范围 ''{1}''
replace.with.boolean.equals=替换为 Boolean.equals
find.usages.panel.title.base.methods=基方法的用法
feature.patterns.in.switch=switch 中的模式
feature.guarded.and.parenthesised.patterns=受保护和带圆括号的模式
dfa.find.cause.special.field.of.something={0}/{1}
find.usages.panel.title.derived.classes.cap=派生类
find.usages.panel.title.derived.interfaces.cap=派生接口
find.usages.panel.title.implementing.classes.cap=实现类
find.usages.panel.title.implementing.methods.cap=实现方法
find.usages.panel.title.overloaded.methods.usages.cap=重载方法
find.usages.panel.title.overriding.methods.cap=重写方法
find.usages.panel.title.base.methods.cap=基方法的用法
special.field.enum.ordinal=枚举序数
service.click.to.navigate=点击以导航
inspection.reference.lambda.name=lambda ({0})
inspection.reference.default.lambda.name=lambda
inspection.reference.method.reference.name=方法引用({0})
inspection.reference.default.method.reference.name=方法引用
dfa.find.cause.size.is.always.zero=大小始终为 0
dfa.find.cause.primitive.boxed=基元值已装箱
inspection.use.compare.method.option.double=建议使用 Double.compare() 和 Float.compare()
inspection.use.compare.method.turn.off.double=不建议使用 Double.compare() 和 Float.compare() 方法
intention.family.name.move.annotation.to.array=将注解移动到数组
ignore.in.the.same.project=忽略此项目中声明的 API
inspection.message.scheduled.for.removal.annotation.can.be.replaced.by.attribute=@ScheduledForRemoval annotation can be replaced with 'forRemoval' attribute in @Deprecated annotation 
inspection.message.scheduled.for.removal.annotation.can.be.removed=@ScheduledForRemoval annotation can be removed
inspection.fix.name.remove.scheduled.for.removal.annotation.by.attribute=Replace @ScheduledForRemoval with 'forRemoval' attribute in @Deprecated annotation  
inspection.name.redundant.scheduled.for.removal.annotation=Redundant @ScheduledForRemoval annotation
inspection.redundant.requires.statement.message.transitive.dependencies.on.can.be.used.directly=可以直接使用 ''{0}'' 上的传递依赖项。
inspection.redundant.requires.statement.message.module.unused=找不到模块软件包的用法。
inspection.redundant.requires.statement.message.java.base.implicitly.required='java.base' 是隐式必填项。
access.can.be.package.private=访问可以为 package-private
reassign.variable.display.name=重新分配的变量
intention.family.name.remove.repeating.call=Remove repeating call
intention.name.remove.repeating.call=Remove repeating call ''{0}()''
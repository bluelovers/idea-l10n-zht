0.field.is.always.initialized.not.null=@{0} 字段始终初始化为非 null
access.can.be.0=访问可以是 ''{0}''
access.can.be.package.private=访问可以为 package-private
access.to.field.code.ref.code.outside.of.declared.guards.loc=访问声明的 guard 外部的字段 <code>\#ref</code> \#loc
add.explicit.type.arguments=添加显式类型实参
add.explicit.type.arguments.else=向 else-branch 调用添加显式类型实参
add.explicit.type.arguments.then=向 then-branch 调用添加显式类型实参
annotate.as.safevarargs=注解为 '@SafeVarargs'
annotate.overridden.methods.parameters=将重写方法形参注解为 ''@{0}''
annotate.overridden.methods.parameters.family.name=注解重写方法形参
anonymous.ref.loc.can.be.replaced.with.0=匿名 \#ref \#loc 可被替换为 {0}
anonymous.ref.loc.can.be.replaced.with.lambda=匿名 \#ref \#loc 可被替换为 lambda
arguments.count.mismatch=应为{0, choice, 0\#无实参|1\# 1 个实参|1< {0} 个实参}，但实际为 {1} 个
assigning.a.collection.of.nullable.elements=正在将可以为 null 的元素集合指定给非 null 元素集合
call.to.method.code.ref.code.outside.of.declared.guards.loc=在声明的 guard 外调用方法 <code>\#ref()</code> \#loc
change.type.arguments=更改类型实参
change.type.arguments.to.0=将类型实参更改为 <{0}>
change.visibility.level=将 {0} 设为 {1}
chooser.popup.title.select.class.to.move.members.to=选择目标类
comparision.between.object.and.primitive=对象与基元之间的比较非法，仅在 Java 7 中接受
conflicting.nullability.annotations=冲突的为 null 性注解
contract.return.validator.incompatible.return.parameter.type=返回值类型 ''{0}'' 必须可以从形参类型 ''{1}'' 转换而来
contract.return.validator.method.return.incompatible.with.method.containing.class=方法返回值类型应与包含类的方法兼容
contract.return.validator.not.applicable.for.constructor=不适用于构造函数
contract.return.validator.not.applicable.primitive=不适用于基元返回值类型 ''{0}''
contract.return.validator.not.applicable.static=不适用于 static 方法
contract.return.validator.return.type.must.be.boolean=方法返回值类型必须为 'boolean'
contract.return.validator.too.few.parameters=不适用于{0, choice, 0\#无形参|1\#有 1 个形参|2\#有 {0} 个形参}的方法
contract.return.value.validation.prefix=协定返回值 ''{0}''\:
custom.exception.class.should.have.a.constructor=自定义异常类应具有一个包含字符串类型的单个消息形参的构造函数
dataflow.message.array.index.out.of.bounds=数组索引超出范围
dataflow.message.arraystore=将 <code>{0}</code> 类型的元素存储到 <code>{1}</code> 元素的数组将生成 <code>ArrayStoreException</code>
dataflow.message.assigning.null=<code>null</code> 被赋值给了非 null 变量
dataflow.message.assigning.null.notannotated=正在将 <code>null</code> 值指定给非注解字段
dataflow.message.assigning.nullable=表达式 <code>\#ref</code> 的计算结果可能为 null，但被赋值给了非 null 变量
dataflow.message.assigning.nullable.notannotated=表达式 <code>\#ref</code> \#loc 可能为 null，但被指定给非注解字段
dataflow.message.cce=将 <code>{0}</code> 转换为 <code>\#ref</code> \#loc 可能产生 <code>ClassCastException</code>
dataflow.message.cce.always=将 <code>{0}</code> 转换为 <code>\#ref</code> \#loc 会为任意非 null 值生成 <code>ClassCastException</code>
dataflow.message.constant.condition=条件 <code>\#ref</code> \#loc 始终为 <code>{0, choice, 0\#false|1\#true}</code>
dataflow.message.constant.condition.when.reached=到达时，条件 <code>\#ref</code> \#loc 始终为 <code>{0, choice, 0\#false|1\#true}</code>
dataflow.message.constant.expression=<code>\#ref</code> \#loc 的结果总是 ''{0}''
dataflow.message.constant.method.reference=方法引用结果始终为''{0}''
dataflow.message.constant.no.ref=条件始终为 {0, choice, 0\#false|1\#true}
dataflow.message.constant.value=值 <code>\#ref</code> \#loc 总是 ''{0}''
dataflow.message.contract.fail=依据其方法协定，对 '\#ref' 的调用始终失败
dataflow.message.contract.fail.index=由于实参超出范围，对 '\#ref' 的调用总是失败
dataflow.message.fail=对 '\#ref' 的调用始终失败并出现异常
dataflow.message.immutable.modified=不可变对象已被修改
dataflow.message.immutable.passed=不可变对象在预期可变位置传递
dataflow.message.negative.array.size=数组大小为负
dataflow.message.npe.array.access=数组访问 <code>\#ref</code> \#loc 可能产生 <code>NullPointerException</code>
dataflow.message.npe.array.access.sure=数组访问 <code>\#ref</code> \#loc 可能生成 <code>NullPointerException</code>
dataflow.message.npe.field.access=解引用<code>\#ref</code> \#loc 可能导致 <code>NullPointerException</code>
dataflow.message.npe.field.access.sure=解引用 <code>\#ref</code> \#loc 将产生 <code>NullPointerException</code>
dataflow.message.npe.inner.class.construction=内联类建立可能会产生<code>NullPointerException</code>
dataflow.message.npe.inner.class.construction.sure=内部类构造将生成 <code>NullPointerException</code>
dataflow.message.npe.method.invocation=方法调用 <code>\#ref</code> \#loc 可能产生 <code>NullPointerException</code>
dataflow.message.npe.method.invocation.sure=方法调用 <code>\#ref</code> \#loc 可能生成 <code>NullPointerException</code>
dataflow.message.npe.methodref.invocation=方法引用调用 <code>\#ref</code> \#loc 可能产生 <code>NullPointerException</code>
dataflow.message.npe.template.invocation=模板处理器调用可能会产生 <code>NullPointerException</code>
dataflow.message.npe.template.invocation.sure=模板处理器调用将产生 <code>NullPointerException</code>
dataflow.message.only.switch.label=Switch 标签 <code>\#ref</code> \#loc 是整个 switch 中唯一可访问的对象
dataflow.message.passing.non.null.argument.to.optional=具有非 null 实参的 'Optional.ofNullable()' 应被替换为 'Optional.of()'
dataflow.message.passing.null.argument=正在将 <code>null</code> 实参传递到注解为 @NotNull 的形参
dataflow.message.passing.null.argument.nonannotated=正在将 <code>null</code> 实参传递到非注解形参
dataflow.message.passing.null.argument.to.optional=具有 null 实参的 'Optional.ofNullable()' 应被替换为 'Optional.empty()'
dataflow.message.passing.nullable.argument=实参 <code>\#ref</code> \#loc 可能为null
dataflow.message.passing.nullable.argument.methodref=方法引用实参可能为 null
dataflow.message.passing.nullable.argument.methodref.nonannotated=方法引用实参可能为 null，但被传递给非注解形参
dataflow.message.passing.nullable.argument.nonannotated=实参 <code>\#ref</code> \#loc 可能为 null，但被传递给非注解形参
dataflow.message.pointless.assignment.expression=条件 <code>\#ref</code> \#loc 在赋值表达式的左侧是永远 <code>{0}</code>. 可以简化
dataflow.message.pointless.same.argument.and.result='\#ref' 的结果与{0,choice,1\#第 1 个|2\#第 2 个}实参相同使调用毫无意义
dataflow.message.pointless.same.arguments='\#ref' 的实参相同。调用包含相同实参的此方法毫无意义
dataflow.message.redundant.assignment=变量已被指定给此值
dataflow.message.redundant.instanceof=条件 <code>\#ref</code> \#loc是多余的，可以用 <code>\!\= null</code>
dataflow.message.redundant.update=变量更新不执行任何操作
dataflow.message.return.notnull.from.nullable=@{0} 方法 ''{1}'' 始终返回非 null 值
dataflow.message.return.null.from.notnull=<code>null</code> 由声明为 @{0} 的方法返回
dataflow.message.return.null.from.notnullable=<code>null</code> 由未被声明为 @{0} 的方法返回
dataflow.message.return.nullable.from.notnull=表达式 <code>\#ref</code> 的求值结果可能为 null，但由声明为 @{0} 的方法返回
dataflow.message.return.nullable.from.notnull.function=函数可能返回null,但这里不允许
dataflow.message.return.nullable.from.notnullable=表达式 <code>\#ref</code> 的求值结果可能为 null，但由未被声明为 @{0} 的方法返回
dataflow.message.storing.array.null=<code>null</code> 已存储到 @NotNull 元素的数组中
dataflow.message.storing.array.nullable=表达式 <code>\#ref</code> 的求值结果可能为 null，但已存储到 @NotNull 元素的数组
dataflow.message.stream.consumed=流可能已被链接或使用
dataflow.message.stream.consumed.always=流已被链接或使用
dataflow.message.unboxing=<code>\#ref</code> \#loc 取消装箱可能产生 <code>NullPointerException</code>
dataflow.message.unboxing.method.reference=使用 <code>\#ref</code> \#loc 需要取消装箱，这可能会产生 <code>NullPointerException</code>
dataflow.message.unboxing.nullable.argument.methodref=将实参传递到方法引用需要拆箱，这可能会产生 <code>NullPointerException</code>
dataflow.message.unknown.nullability=(为 null 性未知)
dataflow.message.unreachable.switch.label=Switch 标签 <code>\#ref</code> \#loc 不可到达
dataflow.method.fails.with.null.argument=当形参为 null 时，方法将抛出异常
dataflow.not.precise={0} 复杂\: 数据流结果可能不准确
dataflow.too.complex={0}太复杂，无法通过数据流算法进行分析
delete.repeated.0=删除重复的 ''{0}''
delete.repeated.interface=删除重复的接口
delimiters.argument.contains.duplicated.characters=StringTokenizer 'delimiters' 实参包含重复字符
deprecated.class.usage.group.xml=XML
deprecated.member.0.is.still.used=弃用的成员 ''{0}'' 仍在使用
detach.library.quickfix.name=分离库
detach.library.roots.quickfix.name=分离未使用的库根
dfa.find.cause.an.execution.might.exist.where=一个执行可能存在于\:
dfa.find.cause.and.another=和 {0}
dfa.find.cause.array.length.is.always.non.negative=数组长度始终为非负数
dfa.find.cause.call.always.fails=调用始终失败
dfa.find.cause.cast.may.fail=转换可能失败
dfa.find.cause.collection.size.is.always.non.negative=集合大小始终为非负数
dfa.find.cause.comparison.arguments.are.different.constants=比较实参为不同常量
dfa.find.cause.comparison.arguments.are.the.same=比较实参相同
dfa.find.cause.compile.time.constant=编译时常量，求值结果为 ''{0}''
dfa.find.cause.condition.is.known.from.place=已知 ''{0}'' 来自 ___PLACE___
dfa.find.cause.condition.was.checked.before=条件 ''{0}'' 先前已检查
dfa.find.cause.condition.was.deduced=条件 ''{0}'' 已被推导
dfa.find.cause.contract.kind.explicit=约定
dfa.find.cause.contract.kind.hard.coded=硬编码约定
dfa.find.cause.contract.kind.inferred=推断约定
dfa.find.cause.contract.returns.on.condition=根据{0}，{1} ''{2}'' 会在{4}时返回 ''{3}''
dfa.find.cause.contract.throws.on.condition=根据{0}，{1} ''{2}'' 会在{3}时抛出异常
dfa.find.cause.contract.trivial=根据{0}，{1} ''{2}'' 始终返回 ''{3}'' 值
dfa.find.cause.equality.established.from.condition=''{0}'' 自条件建立
dfa.find.cause.field.assigned.nullability=已知字段 ''{0}'' 始终初始化为 ''{1}'' 值
dfa.find.cause.field.initializer.nullability=字段 ''{0}'' 初始化为 ''{1}'' 值
dfa.find.cause.instanceof.implies.non.nullity='instanceof' 检查表示非 null
dfa.find.cause.left.operand.range.template=左操作数为 %s
dfa.find.cause.may.be.null=可能为 null
dfa.find.cause.nonnull.expression.kind.concatenation=串联
dfa.find.cause.nonnull.expression.kind.literal=字面量
dfa.find.cause.nonnull.expression.kind.newly.created.object=新创建的对象
dfa.find.cause.nonnull.expression.kind.primitive.type=基元类型 ''{0}'' 的值
dfa.find.cause.nonnull.expression.kind.this.object='this' 对象
dfa.find.cause.nullability.explicitly.annotated={0} ''{1}'' 注解为 ''{2}''
dfa.find.cause.nullability.externally.annotated={0} ''{1}'' 外部注解为 ''{2}''
dfa.find.cause.nullability.inferred={0} ''{1}'' 已推断为 ''{2}''
dfa.find.cause.nullability.inherited.from.class={0} ''{1}'' 自类 {2} 继承注解，因此 ''{3}''
dfa.find.cause.nullability.inherited.from.container={0} ''{1}'' 继承容器注解，因此 ''{2}''
dfa.find.cause.nullability.inherited.from.named.element={0} ''{1}'' 继承自 {2}，因此 ''{3}''
dfa.find.cause.nullability.inherited.from.package={0} ''{1}'' 自软件包 {2} 继承注解，因此 ''{3}''
dfa.find.cause.numeric.cast.operand.template=转换操作数为 %s
dfa.find.cause.numeric.range.generic.template=值为 %s
dfa.find.cause.object.kind.expression=表达式
dfa.find.cause.object.kind.generic=对象
dfa.find.cause.object.kind.method.return=方法返回值
dfa.find.cause.obviously.non.null.expression=表达式不可为 null，因为它是 {0}
dfa.find.cause.one.of.the.following.happens=发生以下情况之一\:
dfa.find.cause.operand.of.boolean.expression.is.the.same={1, choice, 0\#and|1\#or}-链的操作数 \#{0} 是 {2}
dfa.find.cause.or.another=或{0}
dfa.find.cause.place.here=此处
dfa.find.cause.place.line.number=行 \#{0}
dfa.find.cause.primitive.boxed=基元值已装箱
dfa.find.cause.range.is.known.from.place=从 ___PLACE___ 已知范围
dfa.find.cause.range.is.specified.by.annotation=注解将 ''{0}'' 的范围指定为 {1}
dfa.find.cause.result.of.numeric.operation.template=''{0}'' 的结果为 %s
dfa.find.cause.result.of.primitive.cast.template=''({0})'' 转换的结果为 %s
dfa.find.cause.right.operand.range.template=右操作数为 %s
dfa.find.cause.size.is.always.zero=大小始终为 0
dfa.find.cause.special.field.of.something={0}/{1}
dfa.find.cause.string.length.is.always.non.negative=字符串长度始终为非负数
dfa.find.cause.type.is.known.from.place=从 ___PLACE___ 已知 ''{0}'' 类型
dfa.find.cause.type.known={0} 类型为 {1}
dfa.find.cause.unable=找不到原因
dfa.find.cause.value.is.always.the.same=值始终为 {0}
dfa.find.cause.value.is.known.from.place=''{0}'' 已知为来自 ___PLACE___ 的 ''{1}''
dfa.find.cause.value.x.is.always.the.same=值 ''{0}'' 始终为 ''{1}''
dfa.find.cause.values.cannot.be.equal.because=值不能相等，因为 {0}
dfa.find.cause.variable.is.initialized={0} ''{1}'' 初始化为 {2}
dfa.find.cause.was.assigned=''{0}'' 已分配
dfa.find.cause.was.assigned.to=''{0}'' 已分配到 ''{1}''
dfa.find.cause.was.dereferenced=''{0}'' 已解引用
dfa.find.cause.was.passed.as.non.null.parameter=''{0}'' 作为实参传递到接受非 null 形参的方法
dftype.presentation.empty.optional=空 Optional
dftype.presentation.present.optional=目前的 Optional
don.t.report.unused.jars.inside.used.library=不要在使用的库内报告未使用的 jar
duplication.policy.ask=询问
duplication.policy.generate.duplicate=生成重复方法
duplication.policy.replace=替换现有
element.kind.keys=键
element.kind.objects=对象
element.kind.values=值
error.class.not.found=找不到类 {0}
error.message.invalid.java.type=无效的 Java 类型
exception.handler.will.become.unreachable=Catch 部分将变得无法访问
explicit.type.argument.ref.loc.can.be.replaced.with=显式类型实参 \#ref \#loc 可被替换为 <>
exports.to.itself.delete.module.ref.fix=删除模块''{0}''的引用
exports.to.itself.delete.statement.fix=删除声明
find.searching.for.references.to.class.progress=正在搜索对类 {0} 的引用…
find.usages.panel.title.base.methods=基方法的用法
find.usages.panel.title.base.methods.cap=基方法的用法
find.usages.panel.title.derived.classes=派生类
find.usages.panel.title.derived.classes.cap=派生类
find.usages.panel.title.derived.interfaces=派生接口
find.usages.panel.title.derived.interfaces.cap=派生接口
find.usages.panel.title.implementing.classes=实现类
find.usages.panel.title.implementing.classes.cap=实现类
find.usages.panel.title.implementing.methods=实现方法
find.usages.panel.title.implementing.methods.cap=实现方法
find.usages.panel.title.overloaded.methods.usages=重载方法
find.usages.panel.title.overloaded.methods.usages.cap=重载方法
find.usages.panel.title.overriding.methods=重写方法
find.usages.panel.title.overriding.methods.cap=重写方法
generate.members.position.after.equals.and.hashcode=equals() 和 hashCode() 后
generate.members.position.at.caret=文本光标处
generate.members.position.at.the.end.of.class=类结尾处
highlighting.try.blocks=正在高亮显示 try 块…
html.classes.exposed.with.code.module.info.code.html=<html>类通过 <code>module-info</code> 公开</html>
html.ignore.overrides.of.deprecated.abstract.methods=<html>在未弃用的 super 中忽略弃用的 abstract 方法的重写</html>
ignore.casts.in.suspicious.collections.method.calls=忽略澄清转换
ignore.exceptions.thrown.by.entry.points.methods=忽略由入口点方法抛出的异常
ignore.in.the.same.outermost.class=在相同的最外侧类中忽略
ignore.in.the.same.project=忽略此项目中声明的 API
ignore.inside.deprecated.members=在弃用的成员内忽略
ignore.inside.non.static.imports=在非 static import 内忽略
ignore.members.of.deprecated.classes=忽略弃用类的成员
ignore.operation.which.results.in.negative.value=忽略 '<<' 操作，后者会导致负值
inspection.annotate.method.quickfix.family.name=标注方法
inspection.annotate.method.quickfix.name=使用 ''@{0}'' 注解方法
inspection.annotate.overridden.method.and.self.quickfix.family.name=注解重写方法和自身
inspection.annotate.overridden.method.and.self.quickfix.name=使用 ''@{0}'' 注解重写方法和自身
inspection.annotate.overridden.method.nullable.quickfix.name=向重写方法添加缺少的为 null 性注解
inspection.annotate.overridden.method.quickfix.family.name=注解重写方法
inspection.annotate.overridden.method.quickfix.name=使用 ''@{0}'' 注解重写方法
inspection.anonymous.has.lambda.alternative.display.name=匿名类型有较短的 lambda 替代项
inspection.block.marker.comments.display.name=块标记注释
inspection.c.style.array.declarations.option=忽略变量中的 C 样式声明
inspection.can.be.final.accept.quickfix=设为 final
inspection.can.be.final.display.name=声明可以有 'final' 修饰符
inspection.can.be.final.option=报告类
inspection.can.be.final.option1=报告方法
inspection.can.be.final.option2=报告字段
inspection.can.be.local.parameter.problem.descriptor=形参 <code>\#ref</code> 可以具有 <code>final</code> 修饰符
inspection.can.be.local.variable.problem.descriptor=变量 <code>\#ref</code> 可以具有 <code>final</code> 修饰符
inspection.can.be.replaced.with.message=可被替换为 ''{0}''
inspection.class.getclass.display.name='Class.getClass()' 调用可疑
inspection.class.getclass.fix.remove.name=移除 'getClass()' 调用
inspection.class.getclass.fix.replace.name=替换为 'Class.class'
inspection.class.getclass.message=在类实例上调用了 'getClass()'
inspection.class.has.no.to.string.method.description=类 ''{0}'' 不会重写 ''toString()'' 方法
inspection.class.has.no.to.string.method.display.name=类不会重写 'toString()' 方法
inspection.class.has.no.to.string.method.exclude.classes.reg.exp.option=排除类 (reg exp)\:
inspection.class.has.no.to.string.method.ignore.abstract.classes.option=忽略抽象类
inspection.class.has.no.to.string.method.ignore.deprecated.classes.option=忽略弃用的类
inspection.class.has.no.to.string.method.ignore.enum.classes.option=忽略枚举类
inspection.class.has.no.to.string.method.ignore.exception.classes.option=忽略异常类
inspection.class.has.no.to.string.method.ignore.inner.classes.option=忽略内部类
inspection.class.has.no.to.string.method.ignore.records.option=忽略记录
inspection.class.has.no.to.string.method.ignore.test.classes.option=忽略测试类
inspection.common.if.parts.disable.highlight.tail.call=如果尾语句是调用，则不要高亮显示公用部分
inspection.common.if.parts.family=提取 'if' 语句的公用部分
inspection.common.if.parts.family.else.if=合并 'else if' 语句
inspection.common.if.parts.family.else.if.description=可以合并 'else if'
inspection.common.if.parts.family.else.if.invert=合并反转第二个条件的 'else if' 语句
inspection.common.if.parts.settings.highlight.else.if=高亮显示可以简化的 else-if 链
inspection.common.if.parts.settings.highlight.when.tail.call=在最后一条公用语句为调用时高亮显示
inspection.compiler.javac.quirks.anno.array.comma.fix=移除尾随逗号
inspection.compiler.javac.quirks.anno.array.comma.problem=使用较旧的 javac 版本(例如 JDK 5 和 JDK 6)时，注解数组初始值设定项中的尾随逗号可能会导致编译错误
inspection.compiler.javac.quirks.illegal.forward.reference=使用较旧的 javac 版本(例如 JDK 5 和 JDK 6)时，前向引用可能会导致编译错误
inspection.compiler.javac.quirks.name=Javac 杂项
inspection.compiler.javac.quirks.qualifier.type.args.fix=移除泛型形参
inspection.compiler.javac.quirks.qualifier.type.args.problem=使用较旧的 javac 版本(例如 JDK 5 和 JDK 6)时，限定符引用中的泛型可能会导致编译错误
inspection.constant.on.wrong.side.of.a.comparison.side.option=常量应位于比较一侧
inspection.contract.checker.boolean.condition.for.nonboolean.parameter=形参 ''{0}'' 具有 ''{1}'' 类型(应为布尔型)
inspection.contract.checker.clause.syntax=协定子句的格式必须为 arg1, ..., argN -> 返回值
inspection.contract.checker.contract.clause.never.satisfied=协定子句 ''{0}'' 从未满足，因为以前的协定涵盖了其条件
inspection.contract.checker.contract.violated=违反协定子句 ''{0}''
inspection.contract.checker.empty.constraint=约束不应为空
inspection.contract.checker.inferred.notnull.parameter.notnull=形参 ''{0}'' 被推断为非 null，因此 ''\!null'' 始终满足
inspection.contract.checker.inferred.notnull.parameter.null=形参 ''{0}'' 被推断为非 null，因此 ''null'' 不适用
inspection.contract.checker.method.always.fails.nontrivial=子句 ''{0}'' 的返回值可被替换为 ''fail''，因为此子句中的方法总是失败
inspection.contract.checker.method.always.fails.trivial=子句 ''{0}'' 的返回值可被替换为 ''fail''，因为方法总是失败
inspection.contract.checker.no.exception.thrown=违反协定子句 ''{0}''\: 未抛出异常
inspection.contract.checker.notnull.parameter.notnull=形参 ''{0}'' 被注解为非 null，因此 ''\!null'' 始终满足
inspection.contract.checker.notnull.parameter.null=形参 ''{0}'' 被注解为非 null，因此 ''null'' 不适用
inspection.contract.checker.parameter.count.mismatch=方法采用 {0} 个形参，而协定子句 ''{1}'' 预期 {2} 个
inspection.contract.checker.primitive.parameter.nullability=形参 ''{0}'' 具有基元类型 ''{1}''，因此 ''{2}'' 不适用
inspection.contract.checker.pure.method.mutation.contract=纯方法不能有变异协定
inspection.contract.checker.unknown.constraint=约束应为以下值之一\: {0}。实际为 {1}
inspection.contract.checker.unknown.return.value=返回值应为以下值之一\: {0}。实际为 {1}
inspection.contract.checker.unreachable.contract.clause=协定子句 ''{0}'' 不可到达\: 以前的协定涵盖了所有可能的情况
inspection.contract.display.name=合同的问题
inspection.convert.2.diamond.display.name=显式类型可被替换为 '<>'
inspection.convert.2.lambda.display.name=匿名类型可被替换为 lambda
inspection.data.flow.redundant.instanceof.quickfix=替换为\!\= null
inspection.data.flow.simplify.boolean.expression.quickfix=简化布尔表达式
inspection.data.flow.simplify.to.assignment.quickfix.name=简化正常作业
inspection.data.flow.turn.off.constant.references.quickfix=不要报告总是不变的值
inspection.data.flow.turn.off.nullable.returning.notnull.quickfix=不报告始终返回非 null 值的方法
inspection.data.flow.turn.off.true.asserts.quickfix=不要报告总是为true的断言
inspection.data.flow.warn.when.reading.a.value.guaranteed.to.be.constant=当常量存储在变量中时发出警告
inspection.depends.on.the.java.feature=此检查依赖于 Java 功能 ''{0}''，该功能自 Java {1} 起可用。
inspection.depends.on.the.java.features=此检查依赖于以下 Java 功能\:
inspection.depends.on.the.java.features.minimal.version=这些功能自 Java {0} 起可用。
inspection.deprecated.class.usage.inspection.display.name=XML 中的弃用 API 用法
inspection.deprecated.is.still.used.display.name=弃用的成员仍在使用
inspection.duplicate.throws.display.name=重复抛出
inspection.duplicate.throws.ignore.subclassing.option=忽略子类化其他异常的异常
inspection.duplicate.throws.more.general.problem=throws 列表中已经存在一个更一般的异常 ''{0}''。
inspection.duplicate.throws.problem=throws 重复
inspection.equals.hashcode.only.one.defined.problem.descriptor=类有{0}定义但没有定义{1}
inspection.export.results.can.be.final.description=声明可以具有 final 修饰符
inspection.expression.can.be.replaced.with.message=表达式可被替换为 ''{0}''
inspection.extract.method.dont.suggest.length=不建议提取如此短的方法
inspection.extract.method.dont.suggest.parameters=不建议提取带有 {0} 个或更多形参的方法
inspection.extract.method.inspection.name=方法可以提取
inspection.extract.method.message=可以从长周围方法中提取返回 ''{0}'' 的方法
inspection.extract.method.nothing=无任何内容
inspection.extract.method.option.max.parameters=最大形参数量\:
inspection.extract.method.option.min.length=要提取的最小代码长度\:|符号
inspection.extract.method.preview.html=将 {0} 语句提取到一个方法中，该方法接受 {1} 并返回 <b>{2}</b>
inspection.field.access.not.guarded.display.name=不受保护的字段访问或方法调用
inspection.field.not.used.in.to.string.description=方法 ''{0}'' 未在 ''toString()'' 方法中使用
inspection.field.not.used.in.to.string.description2=字段 ''{0}'' 未在 ''toString()'' 方法中使用
inspection.field.not.used.in.to.string.display.name=字段未在 'toString()' 方法中使用
inspection.fix.name.remove.scheduled.for.removal.annotation.by.attribute=将 @ScheduledForRemoval 替换为 @Deprecated 注解中的 'forRemoval' 特性
inspection.i18n.quickfix.annotate=注解…
inspection.i18n.quickfix.annotate.as=注解为 ''@{0}''
inspection.i18n.quickfix.annotate.choose.container=选择容器
inspection.i18n.quickfix.annotate.container.as=将容器注解为 ''@{0}''
inspection.i18n.quickfix.annotate.element=注解{0} ''{1}''…
inspection.i18n.quickfix.annotate.element.as=将{0} ''{1}'' 注解为 ''@{2}''
inspection.i18n.quickfix.remove.annotation=移除 ''@{0}''
inspection.i18n.quickfix.remove.annotation.from.element=从{1} ''{2}'' 中移除 ''@{0}''
inspection.implicit.subclass.display.forClass=类 ''{0}'' 可以隐式子类化，并且不得为 final
inspection.implicit.subclass.display.name=final 声明不能在运行时被重写
inspection.implicit.subclass.extendable=使''{0}''可以覆盖
inspection.implicit.subclass.make.class.extendable=使类''{0}'' {1,choice,0\#|1\#和方法 {2} |1<和 {1} 个必须的方法}可扩展
inspection.inconsistent.language.level.display.name=语言级别设置不一致
inspection.infinite.loop.option=放置在 Thread.run 中时忽略
inspection.instance.guarded.by.static.display.name=由 static 字段保护的实例成员
inspection.invalid.comparator.method.reference.display.name=用于 'Comparator' 的无效方法引用
inspection.java.8.list.sort.display.name='Collections.sort()' 可被替换为 'List.sort()'
inspection.java.9.redundant.requires.statement.display.name=module-info 中的冗余 'requires' 指令
inspection.java.module.definition=Java 模块定义问题
inspection.java.module.naming=Java 模块名称违反约定
inspection.java.module.naming.terminal.digits=模块名称 ''{0}'' 不应使用末尾数字来编码版本信息
inspection.local.can.be.final.display.name=局部变量或形参可以是 'final'
inspection.local.can.be.final.option=报告局部变量
inspection.local.can.be.final.option1=报告方法形参
inspection.local.can.be.final.option2=报告 catch 形参
inspection.local.can.be.final.option3=报告 foreach 形参
inspection.local.can.be.final.option4=<html>报告为隐式 final 的变量<br/>(多 catch 或使用 try-with-resources 形参)</html>
inspection.local.can.be.final.option5=报告模式变量
inspection.message.expression.compared.to.itself.description=表达式与自身进行比较
inspection.message.javac.quick.intersection.type.problem=因为 ''{1}'' 为 final，交叉类型 ''{0}'' 无法实例化
inspection.message.non.annotated.method.implements.non.null.method=''{1}'' 中的非注解方法 ''{0}'' 实现 ''{2}'' 中的非 null 方法
inspection.message.non.annotated.parameter.should.not.override.non.null.parameter=''{2}'' 中方法 ''{1}'' 的非注解形参 ''{0}'' 不应当重写 ''{3}'' 中非 null 形参
inspection.message.non.null.parameter.should.not.override.non.annotated.parameter=''{2}'' 中方法 ''{1}'' 的非 null 形参 ''{0}'' 不应当重写 ''{3}'' 中的非注解形参
inspection.message.non.null.parameter.should.not.override.nullable.parameter=''{2}'' 中方法 ''{1}'' 的非 null 形参 ''{0}'' 不应当重写 ''{3}'' 中可为 null 的形参
inspection.message.nullable.method.implements.non.null.method=''{1}'' 中可为 null 的方法 ''{0}'' 实现 ''{2}'' 中的非 null 方法
inspection.message.scheduled.for.removal.annotation.can.be.removed=可以移除 @ScheduledForRemoval 注解
inspection.message.scheduled.for.removal.annotation.can.be.replaced.by.attribute=@ScheduledForRemoval 注解可被替换为 @Deprecated 注解中的 'forRemoval' 特性
inspection.module.exports.package.to.itself=模块将软件包导出/打开到本身
inspection.name.can.be.replaced.with.long.hashcode=可以使用标准 'hashCode()' 方法
inspection.name.redundant.scheduled.for.removal.annotation=冗余的 @ScheduledForRemoval 注解
inspection.non.final.field.in.immutable.display.name='@Immutable' 类中有非 final 字段
inspection.non.final.guard.display.name=非 final '@GuardedBy' 字段
inspection.nullable.problems.NotNull.parameter.overrides.Nullable=使用 @{0} 注解的形参不得重写 @{1} 形参
inspection.nullable.problems.NotNull.parameter.overrides.not.annotated=使用 @{0} 注解的形参不应重写非注解形参
inspection.nullable.problems.NotNull.parameter.receives.null.literal=使用 @{0} 注解的形参不应该接收 ''null'' 作为实参
inspection.nullable.problems.Nullable.NotNull.conflict=不能同时使用 @{0} 和 @{1} 注解
inspection.nullable.problems.Nullable.method.overrides.NotNull=@{0} 注解的方法不能重写 @{1} 方法
inspection.nullable.problems.annotated.field.constructor.parameter.not.annotated=@{0} 字段的构造函数形参可能会使用 @{0} 自身注解
inspection.nullable.problems.annotated.field.getter.conflict=@{0}字段的Getter已经注解 @{1}
inspection.nullable.problems.annotated.field.getter.not.annotated=@{0}字段的Getter可能会注解 @{0}本身
inspection.nullable.problems.annotated.field.setter.parameter.conflict=@{0} 字段的 setter 形参使用 @{1} 注解
inspection.nullable.problems.annotated.field.setter.parameter.not.annotated=@{0} 字段的 setter 形参可能会使用 @{0} 自身注解
inspection.nullable.problems.applied.to.package=完全限定名称的注解必须放在最后一个组件之前
inspection.nullable.problems.at.class=为 null 性注解不适用于类
inspection.nullable.problems.at.constructor=为 null 性注解不适用于构造函数
inspection.nullable.problems.at.enum.constant=为 null 性注解不适用于枚举常量
inspection.nullable.problems.at.local.variable=为 null 性注解不适用于局部变量
inspection.nullable.problems.at.reference.list=为 null 性注解不适用于 extends/implements 子句
inspection.nullable.problems.at.throws=为 null 性注解不适用于 'throws' 子句
inspection.nullable.problems.at.type.parameter=为 null 性注解不适用于类型形参
inspection.nullable.problems.at.wildcard=为 null 性注解不适用于通配符类型
inspection.nullable.problems.constructor.not.compatible.non.null.type.argument=构造函数与非 null 类型实参不兼容
inspection.nullable.problems.method.overrides.NotNull=未注解的方法重写注解为 @{0} 的方法
inspection.nullable.problems.nullable.instantiation.of.notnull=非 null 类型形参 ''{0}'' 无法使用 @{1} 类型实例化
inspection.nullable.problems.nullable.instantiation.of.notnull.container=非 null 类型形参 ''{0}'' 无法在 @{1} 下实例化
inspection.nullable.problems.outer.type=外部类型本身非 null
inspection.nullable.problems.parameter.overrides.NotNull=未注解的形参重写 @{0} 形参
inspection.nullable.problems.primitive.type.annotation=不能注解基元类型成员
inspection.nullable.problems.receiver.annotation=接收器形参本身非 null
inspection.nullable.problems.redundant.annotation.inherited.notnull=冗余的为 null 性注解\: 类型形参上限已为非 null
inspection.nullable.problems.redundant.annotation.under.container=@{0} 作用域内的冗余为 null 性注解
inspection.numeric.overflow.display.name=数值溢出
inspection.objects.equals.can.be.simplified.display.name='Objects.equals()' 可被替换为 'equals()'
inspection.quirk.method.reference.return.type.message=目标方法返回值类型提及了不可访问的类 {0}，这将在运行时导致 IllegalAccessError
inspection.redundant.cast.display.name=冗余类型转换
inspection.redundant.cast.methodref.descriptor=转换是冗余的
inspection.redundant.cast.problem.descriptor=将 <code>{0}</code> 转换为 <code>\#ref</code> \#loc 是冗余的
inspection.redundant.cast.remove.quickfix=移除冗余转换
inspection.redundant.field.initialization.option=仅在初始化为 null 时发出警告
inspection.redundant.requires.statement.description=冗余指令 ''requires {0}''。
inspection.redundant.requires.statement.fix.family=删除冗余 'requires' 指令
inspection.redundant.requires.statement.fix.name=删除指令 ''requires {0}''
inspection.redundant.requires.statement.message.java.base.implicitly.required='java.base' 是隐式必填项。
inspection.redundant.requires.statement.message.module.unused=找不到模块软件包的用法。
inspection.redundant.requires.statement.message.transitive.dependencies.on.can.be.used.directly=可以直接使用 ''{0}'' 上的传递依赖项。
inspection.redundant.throws.display.name=冗余 'throws' 子句
inspection.redundant.throws.problem.descriptor=声明的异常 <code>\#ref</code> 从不在任何方法实现中抛出
inspection.redundant.throws.problem.descriptor1=声明的异常 <code>\#ref</code> 从不在此方法或其重写方法中抛出
inspection.redundant.throws.problem.descriptor2=声明的异常 <code>\#ref</code> 从不抛出
inspection.redundant.throws.remove.quickfix=删除不必要的抛出声明
inspection.redundant.tostring.option.notnull.qualifier=仅在限定符已知为非 null 时报告
inspection.redundant.type.display.name=冗余类型实参
inspection.redundant.type.no.generics.method.reference.problem.descriptor=类型实参对于非泛型方法引用是冗余的
inspection.redundant.type.no.generics.problem.descriptor=类型实参对于非泛型方法调用是冗余的
inspection.redundant.type.problem.descriptor=显式类型实参可以推断
inspection.redundant.type.remove.quickfix=移除类型实参
inspection.reference.anonymous.class=匿名类
inspection.reference.anonymous.name=匿名 ({0})
inspection.reference.default.lambda.name=lambda
inspection.reference.default.method.reference.name=方法引用
inspection.reference.default.package=<默认>
inspection.reference.implicit.class=压缩源文件 ''{0}''
inspection.reference.implicit.constructor.name=隐式构造函数{0}
inspection.reference.jsp.holder.method.anonymous.name=<% 页面内容 %>
inspection.reference.lambda.name=lambda ({0})
inspection.reference.method.reference.name=方法引用({0})
inspection.requires.auto.module=依赖于自动模块
inspection.requires.auto.module.message=自动导入模块需要'requires'指令
inspection.requires.auto.module.option=仅高亮显示可传递依赖项
inspection.requires.auto.module.transitive=自动模块需要'requires transitive'指令
inspection.safe.varargs.detector.display.name=形参化 vararg 类型可能导致堆污染
inspection.same.return.value.display.name=方法始终返回相同的值
inspection.same.return.value.problem.descriptor=方法 <code>\#ref()</code> 始终返回 <code>{0}</code>
inspection.same.return.value.problem.descriptor1=方法 <code>\#ref()</code> 及其所有重写方法始终返回 <code>{0}</code>
inspection.same.return.value.problem.descriptor2=方法 <code>\#ref()</code> 的所有实现始终返回 <code>{0}</code>
inspection.static.guarded.by.instance.display.name=由实例字段或 this 保护的 static 成员
inspection.string.tokenizer.delimiter.display.name='StringTokenizer' 中的分隔符重复
inspection.surround.requirenonnull.quickfix=替换为 ''Objects.requireNonNull({0})''
inspection.suspicious.array.method.call.display.name=可疑的 'Arrays' 方法调用
inspection.suspicious.array.method.call.problem.arrays=Array类型不兼容\: 数组总是不同的
inspection.suspicious.array.method.call.problem.element=元素类型与数组类型不兼容
inspection.suspicious.collections.method.calls.display.name=可疑的集合方法调用
inspection.suspicious.collections.method.calls.problem.descriptor=''{0}''可能不包含类型''{1}''的{2}
inspection.suspicious.collections.method.calls.problem.descriptor1=可疑的调用''{0}''
inspection.suspicious.getter.setter.field.option=仅在存在字段匹配 getter/setter 名称时发出警告
inspection.suspicious.integer.div.assignment.option=报告可疑但可能准确的除法
inspection.unary.plus.unary.binary.option=仅在混乱的二进制或一元表达式上下文中报告
inspection.unknown.guard.display.name=未知 '@GuardedBy' 字段
inspection.unnecessary.super.qualifier.option=忽略说明 'super' 限定符
inspection.unreachable.catch.message=无法访问的部分\: {1, choice, 0\#异常|2\#异常} ''{0}'' {1, choice, 0\#已被|2\#已被}捕获
inspection.unreachable.catch.name=不可到达的 catch 部分
inspection.unsatisfied.range.display.name=返回值超出声明的范围
inspection.unsatisfied.range.message=返回值范围 ''{0}'' 在声明的范围 ''{1}'' 之外
inspection.unsatisfied.range.message.value=返回值 ''{0}'' 超出声明的范围 ''{1}''
inspection.use.compare.method.display.name=可以使用 'compare()' 方法比较数值
inspection.use.compare.method.fix.family.name=替换为单个比较方法
inspection.use.compare.method.option.double=建议使用 'Double.compare()' 和 'Float.compare()'
inspection.use.compare.method.turn.off.double=不建议使用 Double.compare() 和 Float.compare() 方法
inspection.visibility.accept.quickfix=接受建议的访问级别
inspection.visibility.compose.suggestion=可以是 {0}
inspection.visibility.option.constants=为常量建议较弱的可见性
inspection.visibility.option.package.private.members=为类成员建议 package-private 可见性级别
inspection.visibility.package.private.top.level.classes=为顶级类建议 package-private 可见性级别
inspection.visibility.private.inner.members=仅在从外部类引用时为内部类成员建议 'private'
inspection.weaker.access.display.name=声明访问可以更弱
instance.member.guarded.by.static.0.loc=由 static“{0}”保护的实例成员 \#loc
instance.member.guarded.by.static.ref.loc=由 static \#ref 保护的实例成员 \#loc
intention.add.annotation.family=添加注解
intention.add.type.annotation.family=添加类型注解
intention.family.name.move.annotation.to.array=将注解移至数组
intention.family.name.move.annotation.to.upper.bound=将注解移到上限
intention.family.name.move.members.into.class=将成员移至类
intention.family.name.move.members.to=将成员移至 {0}
intention.family.name.remove.new.family.name=移除 'new'
intention.family.name.remove.repeating.call=移除重复调用
intention.family.name.replace.with.expression=替换为表达式
intention.family.name.replace.with.unnamed.pattern=替换为未命名的模式
intention.name.do.not.report.conditions.with.possible.side.effect=不报告可能有副作用的情况
intention.name.ignore.exception=忽略异常 ''{0}''
intention.name.make.variable.effectively.final=将变量设为有效 final
intention.name.move.members.into.class=将{0, choice, 1\#成员|2\#成员}移入类中
intention.name.qualify.expression=使用 ''{1}'' 限定 {0} 表达式
intention.name.remove.repeating.call=移除重复调用 ''{0}()''
intention.text.remove.annotation=移除
make.default.the.last.case.family.name=使 'default' 为最后一个 case
make.final.and.annotate.as.safevarargs=设为 final 并注解为 '@SafeVarargs'
message.class.inaccessible=类 ''{0}'' 无法在此处访问
message.class.inaccessible.from.module=类 ''{0}'' 无法从模块 ''{1}'' 访问
method.reference.mapped.to.comparator=映射到 'Comparator' 接口的方法引用不会履行 'Comparator' 约定
missorted.imports.inspection.display.name=错误排序的 import
module.0.with.language.level.1.depends.on.module.2.with.language.level.3=语言级别为 {1} 的模块 {0} 取决于语言级别为 {3} 的模块 {2}
module.ambiguous=不明确的模块引用\: {0}
module.service.unused=提供了服务接口，但未导出或使用
move.0.to.the.beginning=将 ''{0}'' 移至开头
move.annotations.to.package.info.file.family.name=将注解移动到 'package-info.java'
move.to.front=移到前面
mutability.modifiable=可修改
mutability.must.not.modify=不应修改的输入形参
mutability.unknown=未知
mutability.unmodifiable=不可修改
mutability.unmodifiable.view=不可修改的视图
mutation.signature.problem.invalid.token=无效的令牌\: {0}；支持的令牌为 ''this''、''io''、param1''、''param2'' 等。
mutation.signature.problem.parameter.has.immutable.type=形参 \#{0} 具有不可变类型 ''{1}''
mutation.signature.problem.reference.to.parameter.invalid=形参 \#{0} 的引用无效
mutation.signature.problem.static.method.cannot.mutate.this=static 方法无法改变 'this'
navigate.to.overridden.methods.title={0} 的重写方法
non.final.field.code.ref.code.in.immutable.class.loc=非 final 字段 <code>\#ref</code> 位于 @Immutable 类中 \#loc
non.final.guarded.by.field.0.loc=非 final @GuardedBy 字段“{0}”\#loc
non.final.guarded.by.field.ref.loc=非 final @GuardedBy 字段 \#ref \#loc
non.null.type.argument.is.expected=应为非 null 类型实参
notification.content.cannot.move.file=无法将 ''{0}'' 移动到 ''{1}'' 中\: {2}
notification.file.system.issue=文件操作问题
nullability.non.null=非 null
nullability.null=null
nullability.nullable=可 null
nullable.stuff.error.overriding.notnull.with.nullable=使用可为 null 元素集合重写非 null 元素的集合
nullable.stuff.error.overriding.nullable.with.notnull=使用非 null 元素集合重写可 null 元素的集合
nullable.stuff.problems.overridden.method.parameters.are.not.annotated=重写方法形参未注解
nullable.stuff.problems.overridden.methods.are.not.annotated=重写方法未注解
parameter.can.be.null=形参可以为 null
parameter.is.always.not.null=形参始终为非 null
possible.heap.pollution.from.parameterized.vararg.type.loc=来自形参化 vararg 类型的可能的堆污染 \#loc
processing.method.usages=正在处理方法用法…
progress.title.searching.for.overridden.methods=正在搜索被重写的方法
provided.type=已提供
qualify.0=限定 {0}
qualify.with.0.this=使用 {0}.this 限定
reassign.variable.display.name=重新分配的变量
redundant.block.marker=冗余块标记
remove.annotation=移除注解
remove.block.marker.comments=移除块标记注释
remove.dependency=移除依赖项
remove.left.side.of.assignment=移除赋值的左侧
remove.switch.branch.0=移除 switch 分支 ''{0}''
remove.switch.label=移除 switch 标签
remove.switch.label.0=移除 switch 标签 ''{0}''
replace.0.with=将“{0}”替换为“\=”
replace.anonymous.class.with.lambda.alternative=将匿名类替换为 lambda 替代项
replace.get.class.with.class.literal=使用 .class 字面量替换 getClass()
replace.operator.assignment.with.assignment=将运算符赋值替换为赋值
replace.stringtokenizer.delimiters.parameter.with.unique.symbols=从 'delimiters' 实参中移除重复内容
replace.var.with.explicit.type=将 'var' 替换为显式类型
replace.with.0=替换为 {0}
replace.with.boolean.equals=替换为 Boolean.equals
replace.with.comparator=替换为比较运算符
replace.with.constant.value=替换为常量值
replace.with.constant.value.title=替换为常量值
replace.with.expression.lambda=替换为表达式 lambda
replace.with.lambda=替换为 lambda
replace.with.stream.api.fix=使用流 ''{0}()'' 收起循环
report.suspicious.but.possibly.correct.method.calls=报告可疑的，但可能是正确的方法调用 (&R)
report.when.interface.is.not.annotated.with.functional.interface=在接口未使用 @FunctionalInterface 注解时报告
required.type=必需类型
returning.a.class.with.notnull.parameters=应返回带有可为 null 类型形参的类，但实际返回的是带有非 null 类型形参的类
returning.a.class.with.nullable.parameters=应返回带有非 null 类型形参的类，但实际返回的是带有可为 null 类型形参的类
safe.varargs.not.suppress.potentially.unsafe.operations=@SafeVarargs 不禁止潜在的不安全操作
safe.varargs.on.reifiable.type=@SafeVarargs 不适用于可具体化的类型
scope.package=软件包 {0}
searching.for.overriding.methods=正在搜索重写方法
service.click.to.navigate=点击以导航
service.provides=提供服务
service.uses=使用服务
special.field.array.length=数组长度
special.field.collection.size=大小
special.field.consumed.stream=已链接或已使用的流
special.field.enum.ordinal=枚举序数
special.field.instantiable.class=可实例化类
special.field.optional.value=可选值
special.field.string.length=字符串长度
special.field.unboxed.value=拆箱的值
statement.lambda.can.be.replaced.with.expression.lambda=语句 lambda 可被替换为表达式 lambda
static.inheritrance.fix.replace.progress=正在替换 {0} 的用例
static.member.guarded.by.instance.0.loc=由实例“{0}”保护的 static 成员 \#loc
static.member.guarded.by.instance.ref.loc=由实例保护的 static 成员 \#ref \#loc
subclasses.search.progress.title=正在搜索被重写的方法
suggest.package.private.visibility.level.for.classes.in.exported.packages.java.9=在导出的软件包中为类建议 package-private 可见性级别(Java 9+)
suppress.all.for.class=禁止类的所有检查
suppress.for.parameter=对形参禁止
suppress.for.statement.with.comment=使用注释对语句禁止
suppress.inspection.class=对类禁止
suppress.inspection.field=对字段禁止
suppress.inspection.member=对成员禁止
suppress.inspection.method=对方法禁止
suppress.inspection.module=对模块声明禁止
suspected.module.dependency.problem.descriptor=模块 ''{0}'' 不依赖于模块 ''{1}''。不过，未检查 ''{1}'' 是否存在作用域 ''{2}'' 所需的导出依赖项
suspicious.invocation.handler.implementation.display.name=可疑的 'InvocationHandler' 实现
suspicious.invocation.handler.implementation.method.unused.message=方法从未在 'invoke()' 中使用\: 'hashCode()'、'equals()' 和 'toString()' 不太可能正确实现
suspicious.invocation.handler.implementation.null.returned.for.toString.message=代理方法 'toString()' 时，可能返回 null\: 不建议如此操作
suspicious.invocation.handler.implementation.null.returned.message=代理方法 ''{0}()'' 时，可能返回 null\: 这可能导致 NullPointerException
suspicious.invocation.handler.implementation.type.mismatch.message=代理方法 ''{0}()'' 时，可能返回不兼容类型\: 要求 {1}，实际为 {2}
text.raw.ctor.reference.with.type.parameters=原始构造函数引用具有构造函数的显式类型形参
text.unused.import.in.template=未使用的 import (在模板中指定)
type.constraint.assignability.explanation.definitely.inconvertible=已知 {0} 是 {1}，与 {2} 绝对不兼容
type.constraint.assignability.explanation.exact={0} 已知为 {1}
type.constraint.assignability.explanation.exact.not.subtype={0} 类型恰好是 {1}，不是 {2} 的子类型
type.constraint.assignability.explanation.exact.subtype={0} 类型恰好是 {1}，是 {2} 的子类型
type.constraint.assignability.explanation.not.instance.of=已知 {0} 不是 {1}
type.constraint.assignability.explanation.not.instance.of.supertype=已知 {0} 不是 {2} 的父类型 {1}
type.constraint.assignability.explanation.subtype.of.subtype=已知 {0} 是 {1}，是 {2} 的子类型
type.mismatch.reason=原因\: {0}
uast.language.display.name=JVM 语言
unknown.guardedby.reference.0.loc=未知的 @GuardedBy 引用“{0}”\#loc
unknown.guardedby.reference.ref.loc=未知的 @GuardedBy 引用 \#ref \#loc
unnecessary.module.dependency.display.name=不必要的模块依赖
unnecessary.module.dependency.problem.descriptor=模块''{0}''源不依赖于模块''{1}''源
unused.import.display.name=未使用的 import
unused.import.statement=未使用的 import 语句
unused.library.display.name=未使用的库
unused.library.problem.descriptor=未使用的库''{0}''
unused.library.roots.problem.descriptor=未使用的根{0}从库''{1}''
var.can.be.replaced.with.explicit.type='var' 可被替换为显式类型
vararg.method.call.with.50.poly.arguments=具有超过 50 个 poly 实参的 vararg 方法调用可能会导致编译和分析速度减慢

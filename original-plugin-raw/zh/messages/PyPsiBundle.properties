ACT.CMD.use.import=使用导入的模块
ACT.from.some.module.import=导入自…
ACT.qualify.with.module=使用导入的模块进行限定
ANN.assign.to.none=赋值给 None
ANN.assignment.expression.as.a.target=赋值表达式不能用作此处的目标
ANN.assignment.expression.in.an.iterable=不能在推导式 iterable 中使用赋值表达式
ANN.assignment.expressions.within.a.comprehension.cannot.be.used.in.a.class.body=推导式中的赋值表达式不能在类主体中使用
ANN.assignment.to.keyword=关键字赋值
ANN.async.for.outside.function=async 函数外部的 'async for'
ANN.async.with.outside.function=async 函数外部的 'async with'
ANN.await.outside.async.function=异步函数外部的 'await'
ANN.break.outside.loop='break' 在循环外
ANN.can.t.use.starred.expression.here=这里不能使用星号表达式
ANN.cannot.assign.to.debug=无法赋值给 __debug__
ANN.cant.assign.to.await.expr=无法赋值给 await 表达式
ANN.cant.assign.to.call=无法赋值给函数调用
ANN.cant.assign.to.comprh=无法赋值给列表推导式
ANN.cant.assign.to.dict.comprh=无法赋值给字典推导式
ANN.cant.assign.to.generator=无法赋值给生成器表达式
ANN.cant.assign.to.lambda=无法赋值给 lambda
ANN.cant.assign.to.literal=无法赋值给字面量
ANN.cant.assign.to.operator=无法赋值给运算符
ANN.cant.assign.to.parens=无法赋值给 ()
ANN.cant.assign.to.set.comprh=无法赋值给集合推导式
ANN.cant.aug.assign.starred.assignment.target.must.be.in.list.or.tuple=带星号的赋值目标必须位于列表或元组中
ANN.cant.aug.assign.to.comprh=无法对列表推导式进行增强赋值
ANN.cant.aug.assign.to.dict.comprh=无法对字典推导式进行增强赋值
ANN.cant.aug.assign.to.generator=无法对生成器表达式进行增强赋值
ANN.cant.aug.assign.to.list.or.comprh=无法对列表字面量或推导式进行增强赋值
ANN.cant.aug.assign.to.set.comprh=无法对集合推导式进行增强赋值
ANN.cant.aug.assign.to.tuple.or.generator=无法对元组字面量或生成器表达式进行增强赋值
ANN.cant.delete.call=无法删除函数调用
ANN.cant.delete.literal=无法删除字面量
ANN.continue.break.or.return.in.star.except='break'、'continue' 和 'return' 不能出现在 except* 块中
ANN.continue.outside.loop='continue' 在循环外
ANN.default.except.must.be.last=默认 'except\:' 必须为最后一个
ANN.deleting.none=删除 None
ANN.duplicate.param.name=重复的形参名称
ANN.exception.group.in.star.except=ExceptionGroup 不能在 except* 中使用
ANN.fstrings.illegal.conversion.character=非法转换字符 ''{0}''\: 应为 ''s''、''r''、''a'' 之一
ANN.fstrings.missing.conversion.character=应为转换字符\: 应为 's'、'r'、'a' 之一
ANN.fstrings.single.right.brace.not.allowed.inside.fstrings=f-string 中不允许使用单个 '}'
ANN.function.cannot.be.async=函数“{0}”不能是异步函数
ANN.generator.expression.must.be.parenthesized.if.not.sole.argument=如果不是唯一实参，则必须为生成器表达式添加括号
ANN.ignore.errors.like.this=忽略这样的错误
ANN.illegal.target.for.variable.annotation=变量注解的非法目标
ANN.missing.closing.quote=缺少右引号 [{0}]
ANN.missing.closing.triple.quotes=缺少右三引号
ANN.multiple.args=不允许多个 * 形参
ANN.multiple.kwargs=不允许多个 ** 形参
ANN.multiple.slash=不允许多个 / 形参
ANN.name.used.both.as.global.and.param=名称 ''{0}'' 同时用作形参和全局变量
ANN.named.parameters.after.star=仅带有 * 时，后面必须跟随命名形参
ANN.named.parameters.before.slash=仅带有 * 时，前面必须有命名形参
ANN.no.exception.to.reraise=没有要重新引发的异常
ANN.non.default.param.after.default=默认形参后面跟随非默认形参
ANN.non.empty.return.inside.asynchronous.generator=异步生成器内部的 'return' 非空
ANN.patterns.attribute.name.is.repeated=特性名称 ''{0}'' 重复
ANN.patterns.double.star.pattern.cannot.be.used.outside.mapping.patterns=双星号模式不能在映射模式之外使用
ANN.patterns.invalid.complex.number.literal=复杂数字字面量无效
ANN.patterns.key.pattern.can.only.be.value.or.literal.pattern=键模式只能是值模式或字面量模式
ANN.patterns.name.already.bound=名称 ''{0}'' 已被绑定
ANN.patterns.pattern.does.not.bind.names=模式不绑定{0,choice,1\#名称|2\#名称} {1}
ANN.patterns.pattern.makes.remaining.alternatives.unreachable=模式使剩余的替代项无法访问
ANN.patterns.pattern.makes.remaining.case.clauses.unreachable=模式使剩余的 case 子句无法访问
ANN.patterns.repeated.star.pattern=重复的星号模式
ANN.patterns.single.star.pattern.cannot.be.used.outside.sequence.patterns=单星号模式不能在序列模式之外使用
ANN.positional.only.param.after.keyword=仅位置形参跟随非仅位置形参
ANN.python.does.not.support.yield.from.inside.async.functions=Python 不支持在异步函数中使用 'yield from'
ANN.regular.param.after.keyword=正则形参在 ** 形参后面
ANN.regular.param.after.vararg=正则形参在 * 形参后面
ANN.return.outside.of.function='return' 在函数外部
ANN.slash.param.after.keyword=/ 形参必须在 ** 形参前面
ANN.slash.param.after.vararg=/ 形参必须在 * 形参前面
ANN.star.import.at.top.only=仅在模块级别允许 'import *'
ANN.starred.param.after.kwparam=* 形参在 ** 形参后面
ANN.try.except.can.not.have.except.and.star.except=Try 语句不能同时包含 except 和 except*
ANN.tuple.py3=Python 3 中不支持元组形参解包
ANN.unparenthesized.assignment.expression.statement=在表达式语句的顶层禁止使用不带圆括号的赋值表达式
ANN.unparenthesized.assignment.expression.value=在赋值语句右侧的顶层禁止使用不带圆括号的赋值表达式
ANN.variable.annotation.cannot.be.combined.with.tuple.unpacking=变量注解不能与元组解包相结合
ANN.variable.annotation.cannot.be.used.in.assignment.with.multiple.targets=变量注解不能用于具有多个目标的赋值
ANN.yield.outside.of.function='yield' 在函数外部
INLAY.function.return=函数返回值类型
INLAY.reveal.type='reveal_type' 实参类型
INLAY.type.hints=Python 类型提示
INSP.GROUP.pandas=Pandas
INSP.GROUP.python=Python
INSP.NAME.abstract.class=无效的抽象类定义和用法
INSP.NAME.argument.equal.default=函数实参等于默认形参值
INSP.NAME.assert.type=typing.assert_type
INSP.NAME.assignment.to.loop.or.with.parameter=赋值给 'for' 循环或 'with' 语句形参
INSP.NAME.attribute.outside.init=实例特性在 `__init__` 外部定义
INSP.NAME.augment.assignment=赋值可被替换为增强赋值
INSP.NAME.bad.except.clauses.order=顺序错误的 'except' 子句
INSP.NAME.byte.literal=字节字面量包含非 ASCII 字符
INSP.NAME.calling.non.callable=尝试调用不可调用的对象
INSP.NAME.chained.comparisons=过于复杂的链式比较
INSP.NAME.check.can.be.simplified=冗余布尔变量检查
INSP.NAME.class.has.no.init=类没有 `__init__` 方法
INSP.NAME.class.var.variables=ClassVar 变量的用法无效
INSP.NAME.classic.class.usage=经典样式类用法
INSP.NAME.comparison.with.none=使用相等运算符与 None 进行比较
INSP.NAME.compatibility=代码与特定的 Python 版本不兼容
INSP.NAME.coroutine.is.not.awaited=未等待协程 ''{0}''
INSP.NAME.dataclass.definition.and.usages=无效的数据类定义和用法
INSP.NAME.decorator.outside.class=在类的外部使用了特定于类的装饰器
INSP.NAME.default.argument=默认实参是可变实参
INSP.NAME.deprecated.function.class.or.module=弃用的函数、类或模块
INSP.NAME.dict.creation=通过字典字面量可以重写字典创建
INSP.NAME.docstring.types=docstring 中的类型与推断的类型不匹配
INSP.NAME.dunder.slots=具有 '__slots__' 定义的无效类用法
INSP.NAME.duplicate.keys=字典包含重复键
INSP.NAME.enum=无效的枚举定义和用法
INSP.NAME.exception.not.inherit=不从标准 'Exception' 类继承异常
INSP.NAME.final.classes.methods.and.variables=无效的 final 类、方法和变量用法
INSP.NAME.first.arg.assign=此方法的第一个实参被重新赋值
INSP.NAME.from.future.import=位置不当的 from __future__ import
INSP.NAME.global.undefined=全局变量并非在模块级别定义
INSP.NAME.inconsistent.indentation=缩进不一致
INSP.NAME.inconsistent.returns=不一致的 return 语句
INSP.NAME.incorrect.call.arguments=错误的调用实参
INSP.NAME.incorrect.docstring=不正确的 docstring
INSP.NAME.init.return=返回值的 __init__ 方法
INSP.NAME.invalid.cast=不相关类型之间的类型转换
INSP.NAME.invalid.interpreter=无效的解释器
INSP.NAME.invalid.usages.of.override.decorator=@override 装饰器的无效用法
INSP.NAME.list.creation=非最优列表声明
INSP.NAME.mandatory.encoding=未为文件指定编码
INSP.NAME.method.may.be.static=方法未声明为 static
INSP.NAME.method.over=方法签名与被重写方法的签名不匹配
INSP.NAME.missing.or.empty.docstring=缺失或空 docstring
INSP.NAME.missing.super.constructor=缺少对超类 '__init__' 的调用
INSP.NAME.missing.type.hints=缺少函数定义的类型提示
INSP.NAME.nested.decorators=装饰器嵌套有问题
INSP.NAME.new.init.signature=__new__ 和 __init__ 的签名不兼容
INSP.NAME.new.style.generics.type.param.syntax=新型类型形参和类型别名的无效用法
INSP.NAME.new.type=NewType 的无效用法
INSP.NAME.new.type.cannot.be.subclassed=''{0}'' 无法被子类化
INSP.NAME.new.type.expected.class=预期类
INSP.NAME.new.type.new.type.cannot.be.generic=NewType 不能为泛型
INSP.NAME.new.type.new.type.cannot.be.used.with=NewType 不能与 ''{0}'' 一起使用
INSP.NAME.new.type.variable.name.does.not.match.new.type.name=变量名称 ''{0}'' 与 NewType 名称 ''{1}'' 不匹配
INSP.NAME.non.ascii=文件包含非 ASCII 字符
INSP.NAME.none.function.assignment=分配不返回任何内容的函数调用
INSP.NAME.oldstyle.class=老式类包含新式类功能
INSP.NAME.overloads.in.regular.python.files=常规 Python 文件中的重载
INSP.NAME.pep8.naming=PEP 8 命名约定违规
INSP.NAME.problematic.first.parameter=不正确的第一个形参
INSP.NAME.property.access=不当的属性访问
INSP.NAME.property.definition=不正确的属性定义
INSP.NAME.protected.member=访问类或模块的 protected 成员
INSP.NAME.protocol.definition.and.usages=无效的协议定义和用法
INSP.NAME.pytest-parametrized=@pytest.mark.parametrize 中的不正确实参
INSP.NAME.pytest.unpassed.fixture=测试函数未请求固定例程
INSP.NAME.redeclaration=无用法的重新声明名称
INSP.NAME.redundant.parentheses=冗余圆括号
INSP.NAME.relative.import=可疑的相对 import
INSP.NAME.requirements=未满足的软件包要求
INSP.NAME.set.function.to.literal=函数调用可被替换为集合字面量
INSP.NAME.shadowing.builtins=隐藏内置名称
INSP.NAME.single.quoted.docstring=带单引号的 docstring
INSP.NAME.statement.effect=语句不起任何作用
INSP.NAME.str.format=字符串格式设置操作中的错误
INSP.NAME.too.broad.exception.clauses=不明确的异常子句
INSP.NAME.trailing.semicolon=语句中的禁止尾随分号
INSP.NAME.tuple.assignment.balance=元组赋值 balance 不正确
INSP.NAME.tuple.item.assignment=禁止元组条目赋值
INSP.NAME.type.alias.redeclaration=重新声明的类型别名
INSP.NAME.type.checker=错误类型
INSP.NAME.type.hints=无效的类型提示定义和用法
INSP.NAME.typed.dict=无效的 TypedDict 定义和用法
INSP.NAME.unbound=未绑定的局部变量
INSP.NAME.unnecessary.backslash=不必要的反斜杠
INSP.NAME.unnecessary.cast=不必要的类型转换
INSP.NAME.unreachable.code=不可到达的代码
INSP.NAME.unresolved.refs=未解析的引用
INSP.NAME.unused=未使用的局部符号
INSP.NAME.unused.imports=未使用的 import
INSP.NAME.wrong.super.arguments=错误的调用 super 实参
INSP.abstract.class.abstract.methods.are.allowed.in.classes.whose.metaclass.is.abcmeta=允许在元类为 'ABCMeta' 的类中使用抽象方法
INSP.abstract.class.add.to.superclasses=添加 ''{0}'' 至超类
INSP.abstract.class.cannot.instantiate.abstract.class=无法实例化抽象类 ''{0}''
INSP.abstract.class.class.must.implement.all.abstract.methods=类 {0} 必须实现所有 abstract 方法
INSP.abstract.class.set.as.metaclass=设置 ''{0}'' 为元类
INSP.argument.equals.to.default=实参等于默认形参值
INSP.arguments.not.declared.but.provided.by.decorator=以下实参未声明，而是由修饰器提供\: {0}
INSP.assert.type.expected.type.got.type.instead=应为类型 ''{0}''，但实际为 ''{1}''
INSP.assignment.can.be.replaced.with.augmented.assignment=赋值可被替换为增强赋值
INSP.assignment.to.loop.or.with.parameter=已在上面的 ''for'' 循环或 ''with'' 语句中声明变量 ''{0}''
INSP.async.call=协程调用中缺少 `await` 语法
INSP.attribute.outside.init=实例特性 {0} 在 __init__ 外部定义
INSP.auto.to.manual.field.numbering=无法从自动字段编号切换到手动字段规范
INSP.await.call.on.imported.untyped.function=函数 ''{0}'' 既未声明为 ''async''，也未将返回值类型设为 ''Awaitable''
INSP.bad.except.exception.class.already.caught=已捕获异常类 ''{0}''
INSP.bad.except.superclass.of.exception.class.already.caught=已捕获异常类 ''{1}'' 的超类 ''{0}''
INSP.byte.literal.contains.illegal.characters=字节字面量包含的字符数超过 255 个
INSP.cant.return.value.from.init=无法从 __init__ 返回值
INSP.chained.comparisons.ignore.statements.with.constant.in.the.middle=忽略中间有常量的语句
INSP.class.has.no.init=类没有 __init__ 方法
INSP.class.is.not.subtype.of.class=''{0}'' 不是 ''{1}'' 的实例或子类
INSP.class.object.is.not.callable=''{0}'' 对象不可调用
INSP.class.var.can.be.used.only.in.class.body='ClassVar' 只能在类主体中使用
INSP.class.var.can.not.be.assigned.to.instance=无法通过实例赋值给类变量 ''{0}''
INSP.class.var.can.not.be.nested='ClassVar' 无法嵌套
INSP.class.var.can.not.be.used.in.annotation.for.function.return.value=不能在函数返回值注解中使用 'ClassVar'
INSP.class.var.can.not.be.used.in.annotations.for.function.parameters=不能在函数形参注解中使用 'ClassVar'
INSP.class.var.can.not.include.type.variables='ClassVar' 形参不能包含类型变量
INSP.class.var.can.not.override.class.variable=不能使用实例变量重写类变量 ''{0}'' (之前在基类 ''{1}'' 中声明)
INSP.class.var.can.not.override.instance.variable=不能使用类变量重写实例变量 ''{0}'' (之前在基类 ''{1}'' 中声明)
INSP.class.var.can.only.be.parameterized.with.one.type='ClassVar' 只能使用一种类型进行形参化
INSP.class.var.is.not.allowed.here=这里不允许使用 'ClassVar'
INSP.class.var.not.a.valid.type=不是有效的类型
INSP.classic.class.usage.old.style.class=老式类
INSP.classic.class.usage.old.style.class.ancestors=老式类，因为它所继承的所有类都是老式类
INSP.comparison.with.none.performed.with.equality.operators=使用相等运算符执行了与 None 的比较
INSP.compatibility.basestring.type.not.available.in.py3=basestring 类型在 Python 3 中不可用
INSP.compatibility.check.for.compatibility.with.python.versions=检查与 python 版本的兼容性\:
INSP.compatibility.except.clause.different.semantics=Python 版本 {0} 中逗号分隔元素的语义不同。
INSP.compatibility.except.clause.missing.parens=支持 except 子句中缺少圆括号
INSP.compatibility.feature.allow.async.and.await.as.names=允许使用 'async' 和 'await' 作为名称
INSP.compatibility.feature.allow.backslashes.in.f-strings=允许在 f-string 的表达式部分中使用反斜杠
INSP.compatibility.feature.allow.deep.expression.nesting.in.f-strings=允许在此深度的格式说明符中嵌套表达式
INSP.compatibility.feature.allow.duplicate.kwargs=允许重复的 ** 表达式
INSP.compatibility.feature.allow.duplicate.positional.varargs=允许重复的 * 表达式
INSP.compatibility.feature.allow.keyword.arguments.after.kwargs=允许在 ** 表达式后面使用关键字实参
INSP.compatibility.feature.allow.new.lines.in.f-strings=允许在非三重引号的 f-string 的表达式部分中换行
INSP.compatibility.feature.allow.positional.arguments.after.expression=允许在 * 表达式后面使用位置实参
INSP.compatibility.feature.allow.quote.reuse.in.f-strings=允许在 f-string 中嵌套具有相同引号类型的字符串字面量
INSP.compatibility.feature.allow.to.mix.bytes.and.non.bytes.literals=允许混合字节字面量和非字节字面量
INSP.compatibility.feature.allow.trailing.comma.after.kwargs=允许在 ** 表达式后面使用尾随逗号
INSP.compatibility.feature.allow.trailing.comma.after.positional.vararg=允许在 * 表达式后面使用尾随逗号
INSP.compatibility.feature.have.method=具有方法 {0}
INSP.compatibility.feature.have.module=具有模块 {0}
INSP.compatibility.feature.have.module.builtin=具有模块 __builtin__
INSP.compatibility.feature.have.module.builtins=具有模块内置对象
INSP.compatibility.feature.have.nonlocal.keyword=具有非本地关键字
INSP.compatibility.feature.have.type.long=类型为 long。请改用 int。
INSP.compatibility.feature.line.comments.in.f-strings=允许在 f-string 的表达式部分中使用注释
INSP.compatibility.feature.support.arbitrary.expressions.as.decorator=支持任意表达式作为装饰器
INSP.compatibility.feature.support.assignment.expressions=支持赋值表达式
INSP.compatibility.feature.support.backquotes=支持反引号，请改用 repr()
INSP.compatibility.feature.support.break.inside.finally.clause=支持在 'finally'子句内部使用 'break'
INSP.compatibility.feature.support.continue.inside.finally.clause=支持在 'finally'子句内部使用 'continue'
INSP.compatibility.feature.support.diamond.operator=支持 <>，请改用 use \!\=
INSP.compatibility.feature.support.ellipsis.outside.slices=支持在序列切片外部使用 '…'
INSP.compatibility.feature.support.long.integer.literal.suffix=支持尾随 ''{0}''
INSP.compatibility.feature.support.match.statements=支持 match 语句
INSP.compatibility.feature.support.matrix.multiplication.operators=支持矩阵乘法运算符
INSP.compatibility.feature.support.old.style.octal.literals=支持此语法。八进制字面量需要使用 '0o' 前缀
INSP.compatibility.feature.support.parenthesized.context.expressions=支持带圆括号的上下文表达式
INSP.compatibility.feature.support.positional.only.parameters=支持纯位置形参
INSP.compatibility.feature.support.print.statement=支持此语法。print 语句已替换为 print() 函数
INSP.compatibility.feature.support.raise.with.no.arguments.outside.except.block=支持此语法。只能在 except 块中使用不带实参的 raise
INSP.compatibility.feature.support.return.inside.finally.clause=支持在 'finally'子句内部使用 'return'
INSP.compatibility.feature.support.starred.except.part=支持 except* 部分
INSP.compatibility.feature.support.starred.expressions.as.assignment.targets=支持将带星号的表达式作为赋值目标
INSP.compatibility.feature.support.starred.expressions.in.dicts=支持在字典中使用带星号的表达式
INSP.compatibility.feature.support.starred.expressions.in.subscriptions=支持在订阅中使用带星号的表达式
INSP.compatibility.feature.support.starred.expressions.in.tuples.lists.and.sets=支持在元组、列表和集合中使用带星号的表达式
INSP.compatibility.feature.support.starred.expressions.in.type.annotations=支持在类型注解中使用带星号的表达式
INSP.compatibility.feature.support.string.literal.prefix=支持 ''{0}'' 前缀
INSP.compatibility.feature.support.super.without.arguments=支持此语法。在 Python 2 中 super() 应有实参
INSP.compatibility.feature.support.this.syntax=支持此语法
INSP.compatibility.feature.support.this.syntax.in.list.comprehensions=支持在列表推导式中使用此语法
INSP.compatibility.feature.support.type.alias.statements=支持类型别名语句
INSP.compatibility.feature.support.underscores.in.numeric.literals=支持在数值字面量中使用下划线
INSP.compatibility.feature.support.unpacking.without.parentheses.in.return.statements=支持在 return 语句中没有圆括号的情况下解包
INSP.compatibility.feature.support.unpacking.without.parentheses.in.yield.statements=支持在 yield 语句中没有圆括号的情况下解包
INSP.compatibility.feature.support.variable.annotations=支持变量注解
INSP.compatibility.feature.support.yield.from=支持此语法。自 Python 3.3 起可以委托给子生成器；改为对子生成器使用显式迭代。
INSP.compatibility.inspection.unsupported.feature.prefix=Python {0,choice,1\#版本|2\#版本} {1} {0,choice,1\#|2\#}不{2}
INSP.compatibility.keyword.argument.repeated=关键字实参重复
INSP.compatibility.new.union.syntax.not.available.in.earlier.version=允许将联合体类型编写为 X | Y
INSP.compatibility.old.dict.methods.not.available.in.py3=dict.iterkeys()、dict.iteritems() 和 dict.itervalues() 方法在 Python 3 中不可用
INSP.compatibility.positional.argument.after.keyword.argument=位置实参位于关键字实参后面
INSP.compatibility.positional.argument.after.kwargs=位置实参位于 ** 表达式后面
INSP.compatibility.pre35.versions.do.not.allow.return.with.argument.inside.generator=Python 3.3 以下的版本不允许在生成器内部使用带实参的 'return'。
INSP.compatibility.support.equality.signs.in.fstrings=支持在 f-string 中使用等号
INSP.compatibility.this.syntax.available.only.since.py3=此语法仅自 Python 3 起可用
INSP.dataclasses.argument.ignored.if.class.already.defines.method=如果类已定义 ''{1}'' 方法，则忽略 ''{0}''
INSP.dataclasses.attribute.default.set.using.method=使用 ''{0}'' 设置默认值
INSP.dataclasses.attribute.lacks.type.annotation=特性 ''{0}'' 缺少类型注解
INSP.dataclasses.attribute.useless.until.post.init.declared=只有声明 ''__post_init__'' 之后，特性 ''{0}'' 才有用
INSP.dataclasses.attrs.post.init.should.not.take.any.parameters.except.self='__attrs_post_init__' 不应接受除 'self' 以外的任何形参
INSP.dataclasses.attrs.post.init.would.not.be.called.until.init.parameter.set.to.true=只有在 'init' 形参设置为 True 后，才会调用 '__attrs_post_init__'
INSP.dataclasses.cannot.specify.both.default.and.default.factory=无法同时指定 'default' 和 'default_factory'
INSP.dataclasses.cannot.specify.both.default.and.factory=无法同时指定 'default' 和 'factory'
INSP.dataclasses.eq.must.be.true.if.order.true=如果 'order' 为 true，则 'eq' 必须为 true
INSP.dataclasses.field.cannot.have.default.factory=字段不能有默认工厂
INSP.dataclasses.frozen.attribute.should.be.false.if.class.defines.setattr.or.delattr=如果类定义 '__setattr__' 或 '__delattr__'，则 'frozen' 应为 False
INSP.dataclasses.frozen.dataclasses.can.not.inherit.non.frozen.one=冻结的数据类不能继承非冻结的数据类，非冻结的数据类也不能继承冻结的数据类
INSP.dataclasses.hash.ignored.if.class.already.defines.cmp.or.order.or.frozen.parameters=如果类已定义 'cmp/order' 和 'frozen' 形参，则忽略 '__hash__'
INSP.dataclasses.method.is.ignored.if.class.already.defines.parameter=如果类已定义 ''{1}'' 形参，则忽略 ''{0}''
INSP.dataclasses.method.should.be.called.on.attrs.instances=应对特性实例调用 ''{0}'' 方法
INSP.dataclasses.method.should.be.called.on.attrs.types=应对特性类型调用 ''{0}'' 方法
INSP.dataclasses.method.should.be.called.on.dataclass.instances=应对数据类实例调用 ''{0}'' 方法
INSP.dataclasses.method.should.be.called.on.dataclass.instances.or.types=应对数据类实例或类型调用 ''{0}'' 方法
INSP.dataclasses.method.should.take.only.n.parameter=''{0}'' 应仅使用 {1} 个{1,choice, 1\#形参|2\#形参}
INSP.dataclasses.mutable.attribute.default.not.allowed.use.default.factory=不允许使用可变的默认 ''{0}''。使用 ''default_factory''
INSP.dataclasses.object.attribute.read.only=''{0}'' 对象特性 ''{1}'' 为只读特性
INSP.dataclasses.object.could.have.no.attribute.because.it.declared.as.init.only=''{0}'' 对象不能有特性 ''{1}''，因为它被声明为仅初始化
INSP.dataclasses.operator.not.supported.between.instances.of.class=''{1}'' 的实例之间不支持 ''{0}''
INSP.dataclasses.operator.not.supported.between.instances.of.classes=''{1}'' 和 ''{2}'' 的实例之间不支持 ''{0}''
INSP.dataclasses.order.argument.should.be.false.if.class.defines.one.of.order.methods=如果类定义一种 order 方法，则 'order' 应为 False
INSP.dataclasses.post.init.should.take.all.init.only.variables.in.same.order.they.defined='__post_init__' 应按照定义的顺序接受所有仅初始化变量
INSP.dataclasses.post.init.should.take.all.init.only.variables.including.inherited.in.same.order.they.defined='__post_init__' 应按照定义的顺序接受所有仅初始化变量(包括继承的变量)
INSP.dataclasses.post.init.would.not.be.called.until.init.parameter.set.to.true=只有在 'init' 形参设置为 True 后，才会调用 '__post_init__'
INSP.dataclasses.unsafe.hash.attribute.should.be.false.if.class.defines.hash=如果类定义 '__hash__'，则 'unsafe_hash' 应为 False
INSP.decorator.receives.unexpected.builtin=此装饰器将不会收到其所期望的可调用对象；之前调用的装饰器 ''{0}'' 会返回一个特殊对象
INSP.decorators.method.only.decorator.on.method.outside.class=方法上的装饰器 {0} 位于类外部
INSP.default.arguments.default.argument.value.mutable=默认实参值可变
INSP.deleter.should.not.return=删除程序不应返回值
INSP.deleter.signature.advice=删除程序签名应为 (self)
INSP.deprecation.abc.decorator.deprecated.use.alternative=自 Python 3.3 起已弃用 ''{0}''。改为使用 ''{1}'' 和 ''{2}''
INSP.dict.creation.this.dictionary.creation.could.be.rewritten.as.dictionary.literal=字典创建可以作为字典字面量进行重写
INSP.doc.param.should.be.str=doc 形参应为字符串
INSP.docstring.types.change.type=将 {0} 类型从 {1} 更改为 {2}
INSP.docstring.types.dynamically.inferred.type.does.not.match.specified.type=动态推断的类型 ''{0}'' 与指定的类型 ''{1}'' 不匹配
INSP.docstring.types.fix.docstring=修正 docstring
INSP.dunder.slots.class.object.missing.attribute=''{0}'' 对象没有特性 ''{1}''
INSP.dunder.slots.enabled.twice=显式定义 '__slots__' 的数据类不得配置 'slots\=True'
INSP.dunder.slots.name.in.slots.conflicts.with.class.variable=''__slots__'' 中的 ''{0}'' 与类变量冲突
INSP.duplicate.keys.dictionary.contains.duplicate.keys=字典包含重复键 ''{0}''
INSP.empty.docstring=空 docstring
INSP.enum.enum.class.is.final.and.cannot.be.subclassed=枚举类 ''{0}'' 是 final 类，无法被子类化
INSP.enum.type.annotations.are.not.allowed.for.enum.members=枚举成员不允许使用类型注解
INSP.enum.type.is.not.assignable.to.declared.type=类型 ''{0}'' 无法赋值给声明的类型 ''{1}''
INSP.except.clause.missing.parens=为多个异常类指定目标时必须使用圆括号
INSP.exception.inheritance.exception.does.not.inherit.from.base.exception.class=异常未从 'Exception' 基类继承
INSP.expected.dict.got.type=应为映射，但实际为 {0}
INSP.expected.iterable.got.type=应为迭代，得到的是 {0}
INSP.expression.can.be.simplified=可以简化表达式
INSP.expression.is.not.callable=表达式不可调用
INSP.final.already.declared.name.could.not.be.redefined.as.final=已声明的名称无法被重新定义为 'Final'
INSP.final.can.only.be.parameterized.with.one.type='Final' 只能使用一种类型进行形参化
INSP.final.either.instance.attribute.or.class.attribute.could.be.type.hinted.as.final=实例特性或类特性可以有类型提示 'Final'
INSP.final.final.attribute.could.not.be.overridden=''{0}'' 为 ''Final''，不能被重写
INSP.final.final.attribute.should.be.declared.in.class.body.or.init='Final' 特性应在类主体或 '__init__' 中声明
INSP.final.final.class.could.not.contain.abstract.methods='Final' 类不能包含抽象方法
INSP.final.final.could.not.be.mixed.with.abstract.decorators='Final' 不能与抽象装饰器混用
INSP.final.final.could.not.be.used.in.annotation.for.function.return.value=不能在函数返回值的注解中使用 'final'
INSP.final.final.could.not.be.used.in.annotations.for.function.parameters=不能在函数形参注解中使用 'Final'
INSP.final.final.could.not.be.used.inside.loop=不能在循环内部使用 'Final'
INSP.final.final.could.only.be.used.as.outermost.type='Final' 只能用作最外侧的类型
INSP.final.final.name.should.be.initialized.with.value='Final' 名称应使用值进行初始化
INSP.final.final.target.could.not.be.reassigned=''{0}'' 为 ''Final''，不能被重新赋值
INSP.final.if.assigned.value.omitted.there.should.be.explicit.type.argument.to.final=如果忽略所赋之值，则应有一个显式类型实参为 'Final'
INSP.final.method.marked.as.final.should.not.be.overridden=''{0}'' 被标记为 ''@final''，不应被重写
INSP.final.no.need.to.mark.method.in.final.class.as.final=无需将 'Final' 类中的方法标记为 '@final'
INSP.final.non.method.function.could.not.be.marked.as.final=非方法函数不能被标记为 '@final'
INSP.final.super.classes.are.marked.as.final.and.should.not.be.subclassed={0} {1,choice,1\#|2\#}被标记为 ''@final''，不应为子类
INSP.first.arg.assign.method.parameter.reassigned=方法形参 ''{0}'' 已重新赋值
INSP.first.param.must.not.be.tuple=非 static 方法的第一个形参不能是元组
INSP.format.requires.mapping=格式需要映射
INSP.format.requires.no.mapping=格式无需映射
INSP.from.future.import.from.future.imports.must.occur.at.beginning.file=从 __future__ 导入必须在文件开头处进行
INSP.func.property.name.mismatch=函数和装饰器的名称不匹配；未创建属性访问器
INSP.function.lacks.positional.argument=函数 ''{0}'' 缺乏位置实参
INSP.getter.return.smth=Getter 应返回或生成某些内容
INSP.getter.signature.advice=Getter 签名应为 (self)
INSP.global.variable.undefined=全局变量 ''{0}'' 在模块级别未定义
INSP.incompatible.options=块“{0}”中的格式选项不兼容
INSP.inconsistent.indentation.mix.tabs.spaces=缩进不一致\: 混用制表符和空格
INSP.inconsistent.indentation.previous.line.used.spaces.this.line.uses.tabs=缩进不一致\: 上一行使用空格，此行使用制表符
INSP.inconsistent.indentation.previous.line.used.tabs.this.line.uses.spaces=缩进不一致\: 上一行使用制表符，此行使用空格
INSP.inconsistent.returns.missing.return.stmt.on.some.paths=某些路径缺少 return 语句
INSP.inconsistent.returns.return.without.value=没有值的 'return' 与其他路径不一致
INSP.incorrect.arguments=实参不正确
INSP.init.incompatible.to.new=签名不兼容 __new__
INSP.interpreter.checking.existing.environments=正在检查现有环境
INSP.interpreter.configure.python.interpreter=配置 Python 解释器
INSP.interpreter.interpreter.settings=解释器设置
INSP.interpreter.invalid.python.interpreter.selected.for.module=为模块选择的 Python 解释器无效
INSP.interpreter.invalid.python.interpreter.selected.for.project=为项目选择的 Python 解释器无效
INSP.interpreter.no.python.interpreter.configured.for.module=未为模块配置 Python 解释器
INSP.interpreter.no.python.interpreter.configured.for.project=未为项目配置 Python 解释器
INSP.interpreter.pipenv.interpreter.associated.with.another.module=Pipenv 解释器与另一个模块关联\: ''{0}''
INSP.interpreter.pipenv.interpreter.associated.with.another.project=Pipenv 解释器与另一个项目关联\: ''{0}''
INSP.interpreter.pipenv.interpreter.not.associated.with.any.module=Pipenv 解释器未与任何模块关联
INSP.interpreter.pipenv.interpreter.not.associated.with.any.project=Pipenv 解释器未与任何项目关联
INSP.interpreter.python.has.reached.its.end.life.and.is.no.longer.supported.in.python.plugin=Python {0} 已达到寿命终止日期，不再受到 Python 插件支持
INSP.interpreter.python.has.reached.its.end.of.life.and.is.no.longer.supported.in.pycharm=Python {0} 已达到寿命终止日期，不再受到 PyCharm 支持
INSP.interpreter.use.interpreter=使用 {0}
INSP.interpreter.use.suggested.interpreter=使用建议的解释器
INSP.invalid.cast.message=将类型 ''{0}'' 转换为类型 ''{1}'' 可能是错误的，因为它们不在同一继承层次结构中。如果这是有意为之，请先将表达式转换为 ''{2}''。
INSP.list.creation.this.list.creation.could.be.rewritten.as.list.literal=多步列表初始化可被替换为列表字面量
INSP.mandatory.encoding.checkbox.enable.in.python.3=在 Python 3+ 中启用
INSP.mandatory.encoding.label.encoding.comment.format=编码注释格式\:
INSP.mandatory.encoding.label.select.default.encoding=选择默认编码\:
INSP.mandatory.encoding.no.encoding.specified.for.file=未为文件指定编码
INSP.manual.to.auto.field.numbering=无法从手动字段规范切换到自动字段编号
INSP.message.single.quoted.docstring=应对 docstring 使用带三个双引号的字符串。
INSP.method.may.be.static=方法 <code>\#ref</code> 可能为 'static'
INSP.method.parameters.metaclass.method.first.argument.name=元类方法第一个实参的名称
INSP.missing.parameter.in.docstring=docstring 中的缺失形参 {0}
INSP.missing.super.constructor.message=缺少对超类 __init__ 的调用
INSP.missing.type.hints.add.type.hints=添加类型提示
INSP.missing.type.hints.add.type.hints.for=为 ''{0}'' 添加类型提示
INSP.missing.type.hints.checkbox.only.when.types.are.known=仅当类型已知时(从运行时收集或推断)
INSP.missing.type.hints.type.hinting.missing.for.function.definition=函数定义缺少类型提示
INSP.must.have.first.parameter=方法必须有第一个形参，通常叫做 ''{0}''
INSP.named.tuple=无效的 'typing.NamedTuple' 定义
INSP.named.tuple.default.value.order.inherited=在 {0} 中定义的继承的非默认实参位于在 {1} 中定义的继承的默认实参之后
INSP.named.tuple.default.value.order.local=具有默认值的字段必须位于所有没有默认值的字段之后。
INSP.named.tuple.default.value.order.superclass=非默认实参位于 {0} 中定义的默认实参之后
INSP.new.incompatible.to.init=签名不兼容 __init__
INSP.new.style.generics.are.not.allowed.inside.type.param.bounds=在类型形参的约束和边界内不允许使用泛型类型
INSP.new.style.generics.assignment.expressions.not.allowed=不允许在具有类型形参列表的类、函数和类型别名的声明内使用赋值表达式
INSP.new.style.generics.classes.with.type.param.list.should.not.extend.generic=具有显式类型形参列表的类不应扩展 'Generic'
INSP.new.style.generics.extending.protocol.does.not.need.parameterization=扩展 'Protocol' 不需要在具有类型形参列表的类中进行形参化
INSP.new.style.generics.mixing.old.style.and.new.style.type.vars.not.allowed=不允许混合传统类型变量和新型类型变量
INSP.new.style.generics.old.style.type.vars.not.allowed.in.new.style.type.aliases=新型类型别名语句中不允许使用传统 TypeVar
INSP.new.style.type.parameter.out.of.scope=类型变量 ''{0}'' 超出作用域
INSP.no.docstring=缺失 docstring
INSP.no.format.specifier.char=缺少格式说明符
INSP.non.ascii.char.non.ascii.character.in.file.but.no.encoding.declared=文件中有非 ASCII 字符 ''{0}''，但未声明编码
INSP.none.function.assignment=函数 ''{0}'' 不返回任何内容
INSP.oldstyle.class.getattribute=老式类包含 __getattribute__ 定义
INSP.oldstyle.class.slots=老式类包含 __slots__ 定义
INSP.oldstyle.class.super=老式类包含对 super 方法的调用
INSP.overloads.at.least.two.overloads.must.be.present=至少需要存在两个 @overload-decorated {0,choice,0\#函数|1\#方法}
INSP.overloads.final.should.be.placed.on.the.implementation='@final' 应当放在实现中
INSP.overloads.final.should.be.placed.only.on.the.first.overload='@final' 应当只放在第一个重载上
INSP.overloads.override.should.be.placed.on.the.implementation='@override' 应当放在实现中
INSP.overloads.override.should.be.placed.only.on.the.first.overload='@override' 应当只放在第一个重载上
INSP.overloads.series.overloads.should.always.be.followed.by.implementation=一系列 @overload-decorated {0,choice,0\#函数|1\#方法}后应当始终跟着一个非 @overload-ed 实现
INSP.overloads.this.overload.signature.not.compatible.with.implementation=此 @overload-decorated {0,choice,0\#函数|1\#方法}的签名与实现不兼容
INSP.overloads.use.classmethod.inconsistently=重载中 @classmethod 的使用不一致
INSP.overloads.use.staticmethod.inconsistently=重载中 @staticmethod 的使用不一致
INSP.override.missing.super.method=缺少重写的 super 方法
INSP.package.requirements.add.import=添加 import
INSP.package.requirements.administrator.privileges.required=需要管理员权限
INSP.package.requirements.administrator.privileges.required.button.configure=配置
INSP.package.requirements.administrator.privileges.required.button.install.anyway=仍要安装
INSP.package.requirements.administrator.privileges.required.description=将软件包安装到 ''{0}'' 需要具备管理员权限。\n\n将每个项目的虚拟环境配置为项目解释器，\n以避免将包安装到文件系统的受保护区域。
INSP.package.requirements.requirement.has.been.ignored=已忽略 ''{0}''
INSP.package.requirements.requirements.file.empty=要求文件为空
INSP.package.requirements.requirements.have.been.ignored=已忽略要求
INSP.pandas.series.values.replace.with.tolist=推荐方法 Series.to_list()
INSP.pandas.truth.value.is.ambiguous.df=DataFrame 的真值不明确
INSP.pandas.truth.value.is.ambiguous.series=Series 的真值不明确
INSP.parameter(s).unfilled=形参未填
INSP.parameter.unfilled=形参 ''{0}'' 未填
INSP.pep8.coding.style.violation=PEP 8 编码样式违规
INSP.pep8.ignore.base.class=忽略基类
INSP.pep8.ignore.method.names.for.descendants.of.class=忽略类后代的方法名称
INSP.pep8.naming.argument.name.should.be.lowercase=实参名称应小写
INSP.pep8.naming.camelcase.variable.imported.as.constant=骆驼拼写法变量作为常量导入
INSP.pep8.naming.camelcase.variable.imported.as.lowercase=骆驼拼写法变量作为小写导入
INSP.pep8.naming.class.names.should.use.capwords.convention=类名应使用 CapWords 约定
INSP.pep8.naming.column.name.excluded.base.classes=已排除的基类\:
INSP.pep8.naming.column.name.ignored.errors=已忽略的错误\:
INSP.pep8.naming.constant.variable.imported.as.non.constant=常量变量作为非常量导入
INSP.pep8.naming.function.name.should.be.lowercase=函数名称应小写
INSP.pep8.naming.lowercase.variable.imported.as.non.lowercase=小写变量作为非小写导入
INSP.pep8.naming.variable.in.function.should.be.lowercase=函数中的变量应小写
INSP.possible.callees=可能的被调用方
INSP.probably.mistyped.self=你不是指 'self' 吗?
INSP.property.cannot.be.deleted=无法删除属性 ''{0}''
INSP.property.cannot.be.read=无法读取属性 ''{0}''
INSP.property.cannot.be.set=无法设置属性 ''{0}''
INSP.protected.member.access.to.protected.member.of.class=访问类的 protected 成员 {0}
INSP.protected.member.access.to.protected.member.of.module=访问模块的 protected 成员 {0}
INSP.protected.member.ignore.annotations=忽略注解
INSP.protected.member.ignore.test.functions=忽略测试函数
INSP.protected.member.name.not.declared.in.all=__all__ 中未声明 ''{0}''
INSP.protocol.all.bases.protocol.must.be.protocols=协议的所有基础必须为协议
INSP.protocol.cannot.instantiate.protocol.class=无法实例化协议类 ''{0}''
INSP.protocol.element.type.incompatible.with.protocol=''{0}'' 的类型与 ''{1}'' 不兼容
INSP.protocol.element.type.not.classvar=无法使用实例变量重写协议 ''{0}'' 中的类变量
INSP.protocol.element.type.not.instancevar=无法使用类变量重写协议 ''{0}'' 中的实例变量
INSP.protocol.element.type.not.writable=''{0}'' 在协议 ''{1}'' 中可写
INSP.protocol.newtype.cannot.be.used.with.protocol.classes=NewType 不能与协议类一起使用
INSP.protocol.only.runtime.checkable.protocols.can.be.used.with.instance.class.checks=仅 @runtime_checkable 协议可以与实例和类检查一起使用
INSP.python.suppressor.suppress.for.class=对类禁止
INSP.python.suppressor.suppress.for.function=对函数禁止
INSP.python.suppressor.suppress.for.statement=对语句禁止
INSP.redeclared.name=已重新声明上文定义的无用法的 ''{0}''
INSP.redeclared.type.alias=名称 ''{0}'' 已定义
INSP.redundant.parens.ignore.argument.of.operator=忽略 % 运算符的实参
INSP.redundant.parens.ignore.empty.lists.of.base.classes=忽略基类的空列表
INSP.redundant.parens.ignore.tuples=忽略元组
INSP.relative.import.relative.import.outside.package=软件包外部的相对导入
INSP.requirements.ignore.packages.label=已忽略的软件包\:
INSP.requirements.package.containing.module.not.listed.in.project.requirements=项目要求中未列出包含模块 ''{0}'' 的软件包
INSP.requirements.package.requirements.not.satisfied=不满足软件包{1,choice,1\#要求|2\#要求} {0} {1,choice,1\#|2\#}
INSP.setter.should.not.return=setter 不应返回值
INSP.setter.signature.advice=Setter 签名应为 (self, value)
INSP.shadowing.builtins.ignore.built.ins.label=已忽略的内置对象\:
INSP.shadowing.builtins.shadows.built.in.name=隐藏内置名称 ''{0}''
INSP.shadowing.names=正在从外部作用域隐藏名称
INSP.shadows.name.from.outer.scope=从外部作用域隐藏名称 ''{0}''
INSP.signature.mismatch=方法 ''{0}'' 的签名与类 ''{1}'' 中基方法的签名不匹配
INSP.simplify.boolean.check.ignore.comparison.to.zero=忽略与零的比较
INSP.simplify.chained.comparison=简化链式比较
INSP.statement.effect.statement.having.no.effect.can.be.replaced.with.function.call=语句似乎无效，替换为函数调用即可生效
INSP.statement.effect.statement.seems.to.have.no.effect=语句似乎不起任何作用
INSP.str.format.can.not.use.star.in.formats.when.using.mapping=使用映射时，格式中不能使用 '*'
INSP.str.format.key.has.no.argument=键 ''{0}'' 没有相应的实参
INSP.str.format.unexpected.argument.type=意外类型{0}
INSP.str.format.unsupported.format.character.b=不受支持的格式字符 'b'
INSP.strange.arg.want.callable=奇怪实参；应为可调用对象
INSP.stub.packages=存根软件包广播程序
INSP.stub.packages.compatibility=不兼容的存根软件包
INSP.stub.packages.compatibility.ignore=忽略
INSP.stub.packages.compatibility.ignored.packages.label=已忽略的存根软件包\:
INSP.stub.packages.compatibility.incompatible.packages.message=存根 ''{0}'' 与原始软件包不兼容。
INSP.stub.packages.compatibility.install=安装
INSP.symbol.is.not.callable=''{0}'' 不可调用
INSP.too.broad.exception.clause=异常子句过于宽泛
INSP.too.few.args.for.fmt.string=格式字符串的实参太少
INSP.too.few.keys=映射键太少
INSP.too.many.args.for.fmt.string=格式字符串的实参太多
INSP.trailing.semicolon=语句中的尾随分号
INSP.tuple.assignment.balance.need.more.values.to.unpack=需要更多值才能解包
INSP.tuple.assignment.balance.only.one.starred.expression.allowed.in.assignment=赋值中仅允许带一个星号的表达式
INSP.tuple.assignment.balance.too.many.values.to.unpack=值太多，无法解包
INSP.tuples.never.assign.items=元组不支持项目赋值
INSP.type.checker.access.to.generic.instance.variables.via.class.is.ambiguous=通过类访问泛型实例变量的方式不明确
INSP.type.checker.expected.matched.type.got.type.instead=应为类型 ''{0}'' (匹配的泛型类型 ''{1}'')，但实际为 ''{2}''
INSP.type.checker.expected.type.from.dunder.set.got.type.instead=应为类型 ''{0}'' (来自 ''__set__'')，但实际为 ''{1}''
INSP.type.checker.expected.type.got.type.instead=应为类型 ''{0}''，但实际为 ''{1}''
INSP.type.checker.expected.types.prefix=可能的类型\:
INSP.type.checker.init.should.return.none=__init__ 应返回 None
INSP.type.checker.only.concrete.class.can.be.used.where.matched.protocol.expected=在应为 ''{0}'' (匹配的泛型类型 ''{1}'')协议的地方，只能使用一个具体类
INSP.type.checker.only.concrete.class.can.be.used.where.protocol.expected=在应为 ''{0}'' 协议的地方，只能使用一个具体类
INSP.type.checker.tuple.index.out.of.range=元组索引超出范围
INSP.type.checker.type.does.not.have.expected.attribute=类型 ''{0}'' 没有预期的{1, choice,1\#特性|2\#特性} {2}
INSP.type.checker.typed.dict.extra.key=TypedDict ''{1}'' 的额外键 ''{0}''
INSP.type.checker.typed.dict.missing.keys=TypedDict ''{0}'' 缺少{1,choice,1\#键|2\#键}\: {2}
INSP.type.checker.unexpected.argument.from.paramspec=意外实参(来自 ParamSpec ''{0}'')
INSP.type.checker.unexpected.types.prefix=意外类型\:
INSP.type.checker.unfilled.parameter.for.paramspec=形参 ''{0}'' 未填(来自 ParamSpec ''{1}'')
INSP.type.checker.unfilled.vararg=形参 ''{0}'' 未填，应为 ''{1}''
INSP.type.checker.yield.from.async.generator=无法在 ''{0}'' 中使用 yield from，请改用 ''async for''
INSP.type.checker.yield.from.send.type.mismatch=应为 send 类型 ''{0}''，但实际为 ''{1}''
INSP.type.checker.yield.type.mismatch=应为 yield 类型 ''{0}''，但实际为 ''{1}''
INSP.type.hints.annotated.must.be.called.with.at.least.two.arguments=必须至少使用两个实参调用 'Annotated'
INSP.type.hints.argument.to.paramspec.must.be.string.equal.to.variable.name='ParamSpec()' 的实参必须为字符串，且该字符串与被赋予该字符串的变量名称相同
INSP.type.hints.argument.to.typevar.must.be.string.equal.to.variable.name='TypeVar()' 的实参必须为字符串，且该字符串与被赋予该字符串的变量名称相同
INSP.type.hints.argument.to.typevar.tuple.must.be.string.equal.to.variable.name='TypeVarTuple()' 的实参必须为字符串，且该字符串与为它指定的变量名称相同
INSP.type.hints.at.most.one.unpacked.tuple=类型实参列表最多可以有一个已解压缩的 TypeVarTuple 或无界元组
INSP.type.hints.bivariant.type.variables.are.not.supported=不支持双变量类型变量
INSP.type.hints.builtin.cannot.be.parameterized.directly=无法直接形参化内置 ''{0}''
INSP.type.hints.cannot.be.used.in.default.type.of.type.var=''{0}'' 不能用于 TypeVar 的默认类型
INSP.type.hints.cannot.inherit.from.generic.multiple.times=无法从 'Generic[…]' 多次继承
INSP.type.hints.cannot.inherit.from.plain.generic=不能从普通的 'Generic' 继承
INSP.type.hints.cannot.use.contravariant.in.return.type=逆变类型变量不能用于函数返回类型
INSP.type.hints.cannot.use.covariant.in.function.param=协变类型变量不能用于形参类型
INSP.type.hints.circular.reference=循环引用
INSP.type.hints.concatenate.can.only.be.used.inside.callable=在此上下文中，'Concatenate' 只能用作 'Callable' 的第一个实参
INSP.type.hints.default.type.do.not.match.bounds=TypeVar 的默认类型不是绑定的子类型
INSP.type.hints.default.type.do.not.match.constraints=TypeVar 的默认类型必须是约束类型之一
INSP.type.hints.default.type.must.be.type.expression=默认类型必须是类型表达式
INSP.type.hints.default.type.of.param.spec.must.be.param.spec.or.list.of.types=ParamSpec 的默认类型必须是 ParamSpec 类型或类型列表
INSP.type.hints.default.type.of.type.var.tuple.must.be.unpacked=TypeVarTuple 的默认类型必须已解压缩
INSP.type.hints.default.type.refers.to.type.var.out.of.scope=此类型形参的默认类型引用了一个或多个超出作用域的类型变量
INSP.type.hints.default.type.var.cannot.follow.type.var.tuple=具有默认值的 TypeVar 不能跟随 TypeVarTuple
INSP.type.hints.expected.a.type=应为类型
INSP.type.hints.forward.reference.in.union=具有前向引用的联合体类型注解必须完全用引号括起来
INSP.type.hints.generic.or.protocol.should.list.all.type.variables=''Generic[...]'' 或 ''Protocol[...]'' 应列出所有类型变量({0})
INSP.type.hints.generic.type.alias.is.not.generic.or.already.parameterized=类型别名为非泛型或者已专用化
INSP.type.hints.generics.should.be.specified.through.square.brackets=泛型应通过中括号指定
INSP.type.hints.illegal.callable.format='Callable' 必须作为 'Callable[[arg, …], result]' 使用
INSP.type.hints.illegal.first.parameter='Callable' 第一个形参必须为形参表达式
INSP.type.hints.illegal.literal.parameter=可以使用字面量 int、字节和 unicode 字符串、bool、枚举值、None、其他字面量类型或其他字面量类型的类型别名形参化 'Literal'
INSP.type.hints.invalid.type.argument=无效的类型实参
INSP.type.hints.invalid.type.expression=无效的类型表达式
INSP.type.hints.invalid.type.self=无效的类型 'self'
INSP.type.hints.literal.must.have.at.least.one.parameter='Literal' 必须至少有一个形参
INSP.type.hints.metaclass.cannot.be.generic=元类不能为泛型
INSP.type.hints.new.type.type.cannot.be.used.in.isinstance.tests=NewType 类型不能与实例和类检查一起使用
INSP.type.hints.non.default.type.vars.cannot.follow.defaults=非默认 TypeVar 不能跟随具有默认值的 TypeVar
INSP.type.hints.non.self.attribute.could.not.be.type.hinted=非 self 特性不能有类型提示
INSP.type.hints.parameterized.generics.cannot.be.used.with.instance.class.checks=形参化泛型不能与实例和类检查一起使用
INSP.type.hints.parameters.to.generic.must.all.be.type.variables=''{0,choice,0\#Generic|1\#Protocol}[...]' 的形参必须全部为类型变量
INSP.type.hints.parameters.to.generic.must.all.be.unique='Generic[…]' 的形参必须全部唯一
INSP.type.hints.parameters.to.generic.types.cannot.contain.more.than.one.unpacking=泛型的形参不能包含多个解压缩
INSP.type.hints.parameters.to.generic.types.must.be.types=泛型类型的形参必须为类型
INSP.type.hints.paramspec.expects.string.literal.as.first.argument='ParamSpec()' 的第一个实参应为字符串字面量
INSP.type.hints.self.use.for.cls.parameter.with.self.annotation=如果 'cls' 形参未使用 'Self' 注解，则不能使用 'Self'
INSP.type.hints.self.use.for.self.parameter.with.self.annotation=如果 'self' 形参未使用 'Self' 注解，则不能使用 'Self'
INSP.type.hints.self.use.in.staticmethod=不能在 staticmethod 中使用 'Self'
INSP.type.hints.self.use.outside.class=不能在类外使用 'Self'
INSP.type.hints.single.typevar.constraint.not.allowed=不允许单个约束
INSP.type.hints.some.type.variables.are.already.in.use.by.outer.scope=某些类型变量({0})被外部作用域使用
INSP.type.hints.type.alias.cannot.be.parameterized=无法形参化 'TypeAlias'
INSP.type.hints.type.alias.invalid.assigned.value=类型别名的赋值必须是正确的类型
INSP.type.hints.type.alias.must.be.immediately.initialized=类型别名必须立即初始化
INSP.type.hints.type.alias.must.be.top.level.declaration=类型别名必须是顶层声明
INSP.type.hints.type.alias.must.be.used.as.standalone.type.hint='TypeAlias' 必须用作独立的类型提示
INSP.type.hints.type.arguments.class.is.already.parameterized=类 ''{0}'' 已形参化
INSP.type.hints.type.arguments.do.not.match.type.parameters.of.alias=传递的类型实参与类型别名 ''{0}'' 的类型形参不匹配
INSP.type.hints.type.arguments.do.not.match.type.parameters.of.class=传递的类型实参与类 ''{1}'' 的类型实参 {0} 不匹配
INSP.type.hints.type.cannot.be.used.with.instance.class.checks=''{0}'' 不能与实例和类检查一起使用
INSP.type.hints.type.comment.cannot.be.matched.with.unpacked.variables=类型注释不能与解包的变量相匹配
INSP.type.hints.type.hint.is.not.valid=类型提示无效或引用的表达式类型不正确
INSP.type.hints.type.parameter.is.already.in.use.by.outer.scope=类型形参 ''{0}'' 已被外部作用域使用
INSP.type.hints.type.self.not.supertype.its.class=self ''{0}'' 的类型不是其类 ''{1}'' 的父类型
INSP.type.hints.type.signature.has.too.few.arguments=类型签名的实参太少
INSP.type.hints.type.signature.has.too.many.arguments=类型签名的实参太多
INSP.type.hints.type.specified.both.in.type.comment.and.annotation=同时在类型注释和注解中指定了类型
INSP.type.hints.type.statement.incorrect.scope='type' 语句只能在模块或类作用域内使用
INSP.type.hints.type.var.tuple.must.always.be.unpacked=TypeVarTuple 必须始终为已解压缩
INSP.type.hints.type.variables.cannot.be.used.with.instance.class.checks=类型变量不能与实例和类检查一起使用
INSP.type.hints.type.variables.must.not.be.redefined=不得重新定义类型变量
INSP.type.hints.typeIs.does.not.match=TypeIs ''{0}'' 的返回值类型与第一个形参 ''{1}'' 的类型不一致
INSP.type.hints.typeIs.has.zero.parameters=用户定义的 TypeGuard 或 TypeIs 函数必须至少有一个形参
INSP.type.hints.typed.dict.is.not.allowed.as.a.bound.for.a.type.var=不允许将 TypedDict 用作 TypeVar 的边界
INSP.type.hints.typed.dict.type.cannot.be.used.in.isinstance.tests=TypedDict 类型不能与实例和类检查一起使用
INSP.type.hints.typevar.constraints.cannot.be.combined.with.bound=约束不能与 bound\=… 结合使用
INSP.type.hints.typevar.constraints.cannot.be.parametrized.by.type.variables=约束无法被类型变量形参化
INSP.type.hints.typevar.expects.string.literal.as.first.argument='TypeVar()' 的第一个实参应为字符串字面量
INSP.type.hints.typevar.expression.must.be.always.directly.assigned.to.variable='TypeVar()' 表达式始终必须直接赋值给变量
INSP.type.hints.typevar.tuple.expects.string.literal.as.first.argument='TypeVarTuple()' 的第一个实参应为字符串字面量
INSP.type.hints.typing.self.cannot.be.parameterized='Self' 不能形参化
INSP.type.hints.unbound.type.variable=未绑定的类型变量
INSP.typeddict.cannot.add.non.string.key.to.typeddict=无法向 TypedDict“{0}”添加非字符串键
INSP.typeddict.cannot.overwrite.typeddict.field=无法覆盖 TypedDict 字段
INSP.typeddict.cannot.overwrite.typeddict.field.while.merging=合并时无法覆盖 TypedDict 字段 ''{0}''
INSP.typeddict.expected.a.dictionary.literal=应为字典字面量
INSP.typeddict.first.argument.has.to.match.variable.name=第一个实参必须匹配变量名称
INSP.typeddict.invalid.statement.in.typeddict.definition.expected.field.name.field.type=TypedDict 定义中的语句无效；应为 'field_name\: field_type'
INSP.typeddict.key.cannot.be.deleted=无法删除 TypedDict ''{1}'' 的键 ''{0}''
INSP.typeddict.key.should.be.string=键应为字符串
INSP.typeddict.qualifiers.cannot.be.used.outside.typeddict.definition=''{0}'' 只能在 TypedDict 定义中使用
INSP.typeddict.read.only.cannot.be.nested=ReadOnly[] 不能嵌套
INSP.typeddict.required.and.not.required.cannot.be.nested=Required[] 和 NotRequired[] 不能嵌套
INSP.typeddict.required.notrequired.must.have.exactly.one.type.argument=''{0}'' 必须只有一个类型实参
INSP.typeddict.right.hand.side.values.are.not.supported.in.typeddict=TypedDict 不支持右侧值
INSP.typeddict.specifying.metaclass.not.allowed.in.typeddict=TypedDict 中不允许指定元类
INSP.typeddict.this.operation.might.break.typeddict.consistency=此操作可能会破坏 TypedDict 一致性
INSP.typeddict.total.value.must.be.true.or.false='total' 的值必须为 True 或 False
INSP.typeddict.typeddict.cannot.have.key=TypedDict“{0}”不能具有键 ''{1}''
INSP.typeddict.typeddict.cannot.inherit.from.non.typeddict.base.class=TypedDict 无法从非 TypedDict 基类继承
INSP.typeddict.typeddict.field.is.readonly=TypedDict 键“{0}”为 ReadOnly
INSP.typeddict.typeddict.has.no.key=TypedDict“{0}”没有键 ''{1}''
INSP.typeddict.typeddict.has.no.keys=TypedDict“{0}”没有键({1})
INSP.typeddict.typeddict.key.must.be.string.literal.expected.one=TypedDict 键必须为字符串字面量；应为({0})之一
INSP.typeddict.unexpected.argument.for.__init_subclass__.of.TypedDict=TypedDict 的 __init_subclass__ 存在意外实参 ''{0}''
INSP.typeddict.value.must.be.type=值必须为某种类型
INSP.unbound.function.too.large=函数 ''{0}'' 太大，无法分析
INSP.unbound.local.variable=局部变量 ''{0}'' 可能在赋值前引用
INSP.unbound.name.undefined=名称 ''{0}'' 可能未定义
INSP.unbound.nonlocal.variable=非局部变量 ''{0}'' 必须绑定在外部函数作用域中
INSP.unexpected.arg=意外实参
INSP.unexpected.arg(s)=意外实参
INSP.unexpected.parameter.in.docstring=docstring 中的意外形参 {0}
INSP.unnecessary.backslash.unnecessary.backslash.in.expression=表达式中有不必要的反斜杠
INSP.unnecessary.cast.message=不必要的转换；类型已经是 ''{0}''
INSP.unreachable.code=此代码不可到达
INSP.unresolved.refs.cannot.find.reference.in.type=在 ''{1}'' 中找不到引用 ''{0}''
INSP.unresolved.refs.class.does.not.define.operator=类 ''{0}'' 未定义 ''{1}''，所以不能对其实例使用 ''{2}'' 运算符
INSP.unresolved.refs.class.object.has.no.attribute=''{0}'' 对象没有特性 ''{1}''
INSP.unresolved.refs.ignore.references.label=已忽略的引用\:
INSP.unresolved.refs.import.resolves.to.its.containing.file=导入解析为其包含文件
INSP.unresolved.refs.module.not.found=找不到模块 ''{0}''
INSP.unresolved.refs.unresolved.attribute.for.class=类 ''{1}'' 的未解析的特性引用 ''{0}''
INSP.unresolved.refs.unresolved.attribute.in.union.type=''{1}'' 的成员 ''{0}'' 没有特性 ''{2}''
INSP.unresolved.refs.unresolved.reference=未解析的引用 ''{0}''
INSP.unsupported.format.character=格式字符 ''{0}'' 不受支持
INSP.unused.imports.try.except.import.error=包含 ''except ImportError'' 的 try 块中的 ''{0}'' 也应在 except 块中定义
INSP.unused.imports.unused.import.statement=未使用的 import 语句 <code>\#ref</code>
INSP.unused.locals.ignore.lambda.parameters=忽略 lambda 形参
INSP.unused.locals.ignore.range.iteration.variables=忽略范围迭代变量
INSP.unused.locals.ignore.variables.starting.with=忽略以 '_' 开头的变量
INSP.unused.locals.ignore.variables.used.in.tuple.unpacking=忽略元组解包中使用的变量
INSP.unused.locals.local.class.isnot.used=未使用局部类 ''{0}''
INSP.unused.locals.local.function.isnot.used=未使用局部函数 ''{0}''
INSP.unused.locals.local.variable.isnot.used=未使用局部变量 ''{0}'' 的值
INSP.unused.locals.parameter.isnot.used=未使用形参 ''{0}'' 的值
INSP.unused.locals.replace.with.wildcard=替换为 _
INSP.unused.locals.type.alias.isnot.used=未使用本地类型别名 ''{0}''
INSP.unused.locals.type.parameter.isnot.used=类型形参 ''{0}'' 未使用
INSP.use.fixture.without.declaration.in.test.function=测试函数或 ''@pytest.mark.usefixtures'' 标记未请求固定例程 ''{0}''
INSP.usually.named=这些方法的第一个形参通常叫做 ''{0}''
INSP.usually.named.self=方法的第一个形参通常叫做 'self'
INTN.NAME.add.type.hint.for.variable=为变量添加类型提示
INTN.NAME.add.type.hints.for.function=为函数添加类型提示
INTN.NAME.convert.between.f.string.t.string=在 f-string 和 t-string 之间转换
INTN.NAME.convert.collection.literal=将集合转换为{0}
INTN.NAME.convert.import.qualify=将 'from module import' 转换为 'import module'
INTN.NAME.convert.import.unqualify=将 'import module' 转换为 'from module import'
INTN.NAME.convert.type.comment.to.variable.annotation=将类型注释转换为变量注解
INTN.NAME.demorgan.law=德摩根定律
INTN.NAME.flip.comparison=翻转比较
INTN.NAME.hide.type.annotations=隐藏类型注解
INTN.NAME.insert.docstring.stub=插入 docstring 存根
INTN.NAME.join.if=联接 'if' 语句
INTN.NAME.negate.comparison=求反比较
INTN.NAME.specify.type.in.annotation=使用注解指定引用类型
INTN.NAME.specify.type.in.docstring=指定 docstring 中引用的类型
INTN.NAME.split.if=拆分 'if' 语句
INTN.NAME.toggle.import.alias=使用 import 别名进行切换
INTN.add.import.alias=添加别名
INTN.add.import.alias.dialog.message=''{0}'' 的别名\:
INTN.add.import.alias.title=添加别名
INTN.add.import.alias.to.name=添加 ''{0}'' 的别名
INTN.add.parameters.to.docstring=向 docstring 添加形参
INTN.add.qualifier=添加 ''{0}'' 限定符
INTN.add.type.hint.for.variable=为变量 ''{0}'' 添加类型提示
INTN.add.type.hint.for.variable.PEP484.incompatible.type=类型 ''{0}'' 不能以 PEP 484 格式内联表示
INTN.add.type.hints.for.function=为函数 ''{0}'' 添加类型提示
INTN.category.python=Python
INTN.convert.absolute.to.relative=将绝对导入转换为相对导入
INTN.convert.builtin.import=将内置模块导入转换为支持的形式
INTN.convert.collection.literal=将{0}转换为{1}
INTN.convert.dict.constructor.to.dict.literal=将 dict 构造函数转换为 dict 字面量
INTN.convert.dict.literal.to.dict.constructor=将 dict 字面量转换为 dict 构造函数
INTN.convert.except.to=将 'except exceptClass, Target' 转换为 'except exceptClass as Target'
INTN.convert.f.string.to.t.string=将 f-string 转换为 t-string
INTN.convert.lambda.to.function=将 lambda 转换为函数
INTN.convert.method.to.property=将方法转换为属性
INTN.convert.relative.to.absolute=将相对导入转换为绝对导入
INTN.convert.static.method.to.function=将 static 方法转换为函数
INTN.convert.t.string.to.f.string=将 t-string 转换为 f-string
INTN.convert.to.from.import=转换为 ''from {0} import {1}''
INTN.convert.to.fstring.literal=转换为格式化字符串字面量
INTN.convert.to.plain.import=转换为 ''import {0}''
INTN.convert.type.comment.to.variable.annotation=转换为变量注解
INTN.convert.variadic.param=将可变形参转换为正常形参
INTN.flip.comparison=翻转 ''{0}''
INTN.flip.comparison.to.operator=将 ''{0}'' 翻转为 ''{1}''
INTN.format.operator.to.method=将格式运算符转换为 'str.format' 方法调用
INTN.hide.type.annotations=隐藏类型注解
INTN.insert.assertion=插入类型断言
INTN.insert.docstring.stub=插入 docstring 存根
INTN.invert.if.condition=反转 'if' 条件
INTN.join.if=联接两个 'if' 语句
INTN.multiple.usages.of.import.found=已找到 import 的多个用法
INTN.negate.comparison=将 ''{0}'' 求反为 ''{1}''
INTN.quoted.string=将带单引号的字符串转换为带双引号的字符串，反之亦然
INTN.quoted.string.double.to.single=将带双引号的字符串转换为带单引号的字符串
INTN.quoted.string.single.to.double=将带单引号的字符串转换为带双引号的字符串
INTN.remove.import.alias=移除别名 ''{0}''
INTN.remove.qualifier=移除 ''{0}'' 限定符
INTN.remove.qualifier.from.all.usages=从所有用法中移除限定符
INTN.remove.qualifier.from.this.name=从此名称中移除限定符
INTN.replace.backquote.expression=替换反引号表达式
INTN.replace.list.comprehensions=将列表推导式转换为支持的形式
INTN.replace.list.comprehensions.with.for=将列表推导式转换为 'for' 循环
INTN.replace.noteq.operator=替换不等运算符
INTN.replace.octal.numeric.literal=将八进制数字字面量转换为支持的形式
INTN.replace.plus.with.format.operator=将 + 替换为字符串格式设置运算符
INTN.replace.plus.with.str.format=将 + 替换为 str.format 方法调用
INTN.replace.raise.statement=将 raise 语句转换为支持的形式
INTN.replace.with.method=替换为 str.format 方法调用
INTN.specify.return.type.in.annotation=使用注解指定返回值类型
INTN.specify.return.type.in.docstring=指定 docstring 中的返回值类型
INTN.specify.type.in.annotation=使用注解指定引用类型
INTN.specify.type.in.docstring=指定 docstring 中的引用类型
INTN.split.if=拆分成 2 条 'if' 语句
INTN.string.concatenation.to.format=将字符串串联替换为 'str.format'
INTN.transform.into.if.else.statement=将条件表达式转换为 'if/else' 语句
INTN.triple.quoted.string=将三引号字符串转换为带单引号的字符串
INTN.yield.from=将含有 'yield' 的显式迭代转换为 'yield from' 表达式
QDOC.accessor.kind=访问器类型\:
QDOC.assigned.to=赋值给\:
QDOC.attributes=特性\:
QDOC.built.in.description=内置描述
QDOC.class=类
QDOC.class.attribute={1} 的类特性 {0}
QDOC.copied.from=复制自\:
QDOC.directory.name=目录“{0}”
QDOC.file.name=文件“{0}”
QDOC.inferred.type.name=推断类型\: {0}
QDOC.instance.attribute={1} 的实例特性 {0}
QDOC.keyword.args=关键字实参\:
QDOC.module.name=模块 {0}
QDOC.module.path.unknown=(模块路径未知)
QDOC.not.defined.in.parentheses=(未定义)
QDOC.package.name=软件包 {0}
QDOC.parameter.name=形参“{0}”
QDOC.parameter.name.of.link={1} 的形参 {0}
QDOC.parameter.of.function.name=函数“{1}”的形参“{0}”
QDOC.parameter.of.method.name=方法“{1}”的形参“{0}”
QDOC.params=形参\:
QDOC.property.getter=属性 getter
QDOC.property.name.of.link={1} 的属性 {0}
QDOC.python.3.sdk.needed.to.render.docstrings=需要已配置的本地 Python 3 SDK 来呈现 docstring。
QDOC.raises=引发\:
QDOC.returns=返回值\:
QDOC.type.alias.statement.name.of.link={1} 的类型别名语句 {0}
QDOC.type.parameter.kind=种类\:
QDOC.type.parameter.name=类型形参 {0}
QDOC.type.parameter.name.of.link=类型形参 {0}/{1}
QDOC.variable.name=变量“{0}”
QFIX.NAME.add.exception.base=添加 Exception 基类
QFIX.NAME.add.field.to.class=将字段添加到类
QFIX.NAME.add.method.to.class=将方法添加到类
QFIX.NAME.add.specifier=添加格式说明符字符
QFIX.NAME.auto.import=导入
QFIX.NAME.convert.builtin=转换内置模块 import
QFIX.NAME.create.function.in.module=在模块中创建函数
QFIX.NAME.docstring=修正 docstring
QFIX.NAME.ignore.errors.like.this=忽略此类错误
QFIX.NAME.ignore.requirements=忽略{0,choice,1\#要求|2\#要求}
QFIX.NAME.ignore.shadowed.built.in.name=忽略已被隐藏的内置名称
QFIX.NAME.install.and.import.package=安装并导入软件包 ''{0}''
QFIX.NAME.install.requirements=安装{0,choice,1\#要求|2\#要求}
QFIX.NAME.local.auto.import=本地导入
QFIX.NAME.make.function=从方法中生成函数
QFIX.NAME.make.function.return.type=使函数返回推断的类型
QFIX.NAME.make.list=将元组替换为列表
QFIX.NAME.make.static=将方法设为 static
QFIX.NAME.move.except.up=上移 except 子句
QFIX.NAME.remove.argument=移除实参
QFIX.NAME.remove.assignment=移除赋值
QFIX.NAME.remove.assignment.target=移除赋值目标
QFIX.NAME.remove.call=移除调用
QFIX.NAME.remove.dict.key=移除此键
QFIX.NAME.remove.exception.target=移除异常目标
QFIX.NAME.remove.parameter=移除形参
QFIX.NAME.remove.statement=移除语句
QFIX.NAME.remove.string.prefix=移除前缀
QFIX.NAME.remove.type.parameter=移除类型形参
QFIX.NAME.remove.underscores.in.numeric=移除数字字面量中的下划线
QFIX.NAME.remove.with.target=移除 'with' 目标
QFIX.NAME.rename.argument=重命名实参
QFIX.NAME.rename.parameter=重命名形参
QFIX.NAME.replace.with.true.or.false=替换为 True 或 False
QFIX.NAME.simplify.boolean.expression=简化布尔表达式
QFIX.NAME.unpack.type.var.tuple=解压缩 TypeVarTuple
QFIX.NAME.unresolved.reference.add.param=创建引用形参
QFIX.NAME.unresolved.reference.create.function=创建函数 ''{0}''
QFIX.NAME.update.parameters=更新形参
QFIX.action.failed=操作失败
QFIX.add.encoding=添加编码声明
QFIX.add.explicit.return.none=添加显式 'return None'
QFIX.add.field.to.class=将字段 ''{0}'' 添加到类 {1}
QFIX.add.field.to.class.popup.content.added.init=已将 __init__ 添加到类 <code>{0}</code><br/>，以适应新字段 <code>{1}</code>
QFIX.add.fixture.to.test.function.parameters.list=将固定例程添加到测试函数形参
QFIX.add.from.future.import.annotations=添加 'from __future__ import annotations'
QFIX.add.global=添加全局语句
QFIX.add.imported.package.to.declared.packages=将 "{0}" 软件包添加到必要组件中…
QFIX.add.imported.packages.to.requirements=将导入的软件包添加到需求中…
QFIX.add.intermediate.cast=添加转换({0}, ...)
QFIX.add.method.to.class=将方法 {0}() 添加到类 {1}
QFIX.add.parameter.self=添加形参 ''{0}''
QFIX.add.property=添加字段的属性
QFIX.add.qualifier=添加限定符
QFIX.add.super=添加超类调用
QFIX.augment.assignment=将赋值替换为增强赋值
QFIX.auto.import.import.name=导入 ''{0}''
QFIX.auto.import.import.this.name=导入此名称
QFIX.chained.comparison=简化链式比较
QFIX.change.base.class=更改基类
QFIX.classic.class.transform=从对象继承
QFIX.convert.indents=转换缩进
QFIX.convert.indents.to.spaces=将缩进转换为空格
QFIX.convert.indents.to.tabs=将缩进转换为制表符
QFIX.convert.into.async.function=转换为异步函数
QFIX.convert.single.quoted.docstring=将 docstring 转换为带三个双引号的字符串形式
QFIX.convert.to.new.style=转换为新样式类
QFIX.coroutine.is.not.awaited=未等待协程
QFIX.create.class=创建类
QFIX.create.class.0=创建类 ''{0}''
QFIX.create.class.in.module=在模块 {1} 中创建类 ''{0}''
QFIX.create.function.in.module=在模块 {1} 中创建函数 {0}()
QFIX.create.property=创建属性
QFIX.default.argument=替换可变默认实参
QFIX.dict.creation=替换字典创建
QFIX.docstring.add.parameter=添加 docstring 形参 ''{0}''
QFIX.docstring.insert.stub=插入 docstring
QFIX.docstring.remove.parameter=移除 docstring 形参 ''{0}''
QFIX.dunder.slots.enabled.twice=移除 slots\=True
QFIX.except.clause.missing.parens=用括号包裹异常元组
QFIX.failed.to.add.field=<br/>无法添加字段\!<br/><br/>
QFIX.failed.to.add.function=<br/>无法添加函数\!<br/><br/>
QFIX.failed.to.add.method=<br/>无法添加方法\!<br/><br/>
QFIX.ignore.shadowed.built.in.name=忽略隐藏的内置名称“{0}”
QFIX.install.and.import.package=安装并导入软件包
QFIX.introduce.variable=为语句引入变量
QFIX.list.creation=替换为列表字面量
QFIX.local.auto.import.import.locally=本地{0}
QFIX.make.function.return.type=使 ''{0}'' 返回 ''{1}''
QFIX.make.public=设为 public
QFIX.move.attribute=将特性移至 __init__ 方法
QFIX.move.from.future.import=将 'from __future__ import' 移至正确位置
QFIX.optimize.imports=优化 import
QFIX.pandas.series.values.replace.with.tolist=将 list(Series.values) 替换为 Series.to_list()
QFIX.pandas.truth.value.is.ambiguous.emptiness.check=替换为明确的空性检查
QFIX.pandas.truth.value.is.ambiguous.none.check=替换为明确的 None 检查
QFIX.redundant.parentheses=移除冗余圆括号
QFIX.remove.annotation=移除注解
QFIX.remove.argument.equal.default=移除等于默认值的实参
QFIX.remove.cast.call=移除 'cast' 调用
QFIX.remove.decorator=移除装饰器
QFIX.remove.function.annotations=移除函数注解
QFIX.remove.generic.parameters=移除泛型形参
QFIX.remove.square.brackets=移除中括号
QFIX.remove.string.prefix=移除前导 {0}
QFIX.remove.trailing.semicolon=移除尾随分号
QFIX.remove.trailing.suffix=移除尾随后缀
QFIX.remove.type.comment=移除类型注释
QFIX.remove.unnecessary.backslash=移除表达式中不必要的反斜杠
QFIX.rename.parameter=重命名为 ''{0}''
QFIX.rename.unresolved.reference=重命名引用
QFIX.replace.equality=替换相等
QFIX.replace.function.set.with.literal=将函数调用替换为集合字面量
QFIX.replace.star.by.unpack=替换为 typing_extensions.Unpack
QFIX.replace.with.old.union.style=替换为旧式联合体
QFIX.replace.with.return.none=替换为 'return None'
QFIX.replace.with.square.brackets=替换为中括号
QFIX.replace.with.target.name=替换为目标名称
QFIX.replace.with.true.or.false=替换为 {0}
QFIX.replace.with.type.name=替换为类型名称
QFIX.replace.with.typing.alias=替换为类型别名
QFIX.simplify.boolean.expression=将布尔表达式替换为 ''{0}''
QFIX.statement.effect=替换为函数调用
QFIX.surround.with.square.brackets=使用中括号包围
QFIX.unresolved.reference=将 ''{0}'' 替换为 ''{1}.{0}''
QFIX.unresolved.reference.add.param=创建形参 ''{0}''
QFIX.unresolved.reference.create.function=创建函数
QFIX.use.property=使用此字段的属性
custom.type.mimic.name=基于 {0} 的动态类
debugger.cleaning.signature.cache=正在清理动态收集类型的缓存
element.presentation.location.string.in.class=({1}中的{0})
element.presentation.location.string.in.class.stub=({1}存根中的{0})
element.presentation.location.string.module=({0})
element.presentation.location.string.module.stub=({0}存根)
filetype.python.docstring.description=Python docstring
filetype.python.function.type.annotation.description=Python PEP-484 函数类型注释
filetype.python.type.hint.description=Python PEP-484 类型提示
find.usages.class=类
find.usages.function=函数
find.usages.imported.module.alias=已导入的模块别名
find.usages.keyword.argument=关键字实参
find.usages.method=方法
find.usages.parameter=形参
find.usages.unnamed=<unnamed>
find.usages.variable=变量
ignore.overridden.functions=忽略被重写的函数
packaging.could.not.parse.relation=无法解析来自以下的关系\: {0}
python.docstring.format=docstring 格式\:
python.docstring.select.type=选择 Docstring 类型
python.find.usages=查找用法
python.find.usages.base.method.question=方法 {0} 重写类 {1} 的方法。\n是否要查找基方法的用法?
python.find.usages.untyped.probable.usage=(可能的)无类型用法
python.find.usages.usage.in.import.statement=在 import 语句中的用法
python.find.usages.usage.in.isinstance=在 isinstance() 中的用法
python.find.usages.usage.in.superclass.list=在超类列表中的用法
python.find.usages.usage.in.type.hint=类型提示中的用法
refactoring.extract.method=提取方法
refactoring.extract.method.error.bad.selection=无法使用所选元素执行提取方法重构
refactoring.extract.method.error.class.level=无法在类级别执行重构
refactoring.extract.method.error.empty.fragment=无法从空代码段执行重构
refactoring.extract.method.error.interrupted.execution.flow=执行流中断时无法执行重构
refactoring.extract.method.error.local.variable.modifications=无法从代码段内包含局部变量修改的表达式执行重构。
refactoring.extract.method.error.local.variable.modifications.and.returns=无法从代码段内包含局部变量修改和返回指令的表达式执行重构
refactoring.extract.method.error.name.clash=该方法名称与现有名称冲突
refactoring.extract.method.error.returns=无法提取代码段内包含返回指令的方法
refactoring.extract.method.error.star.import=无法使用代码块内的星号 import 语句执行重构
refactoring.extract.method.error.yield=无法使用代码块内的 'yield' 语句执行重构
refactoring.inline.all.border.title=内联
refactoring.inline.all.keep.declaration=内联所有调用并保留声明
refactoring.inline.all.remove.declaration=内联所有调用并移除声明
refactoring.inline.can.not.multiline.string.to.f.string=无法将多行字符串内联到 f-string
refactoring.inline.can.not.string.to.nested.f.string=无法将字符串内联到嵌套的 f-string
refactoring.inline.can.not.string.with.backslashes.or.quotes.to.f.string=无法将带有反斜杠和引号的字符串内联到 f-string
refactoring.inline.function=内联函数 {0}
refactoring.inline.function.async=无法内联异步函数
refactoring.inline.function.builtin=无法内联内置函数
refactoring.inline.function.command.name=正在内联{0}
refactoring.inline.function.constructor=无法内联构造函数调用
refactoring.inline.function.decorator=无法内联包含装饰器的函数
refactoring.inline.function.function.to.inline=要内联的函数
refactoring.inline.function.generator=无法内联生成器
refactoring.inline.function.global=无法内联包含全局变量的函数
refactoring.inline.function.interrupts.flow=无法内联中断控制流的函数
refactoring.inline.function.invocations.to.be.inlined=要在 {0} 文件中内联的调用
refactoring.inline.function.is.decorator=函数 {0} 用作装饰器，无法内联。不会移除函数定义
refactoring.inline.function.is.overridden=无法内联被覆盖的方法
refactoring.inline.function.is.reference=函数 {0} 用作引用，无法内联。不会移除函数定义
refactoring.inline.function.nested=无法内联包含其他函数声明的函数
refactoring.inline.function.nonlocal=无法内联包含非局部变量的函数
refactoring.inline.function.overrides.method=无法内联覆盖其他方法的方法
refactoring.inline.function.self.referrent=无法内联引用自身的函数
refactoring.inline.function.skeleton.only=无法内联二进制模块中的函数
refactoring.inline.function.special.method=无法内联特殊方法
refactoring.inline.function.star=无法内联包含 * 实参的函数
refactoring.inline.function.title=内联函数
refactoring.inline.function.uses.unpacking=函数 {0} 使用实参解包，无法内联。不会移除函数定义
refactoring.inline.label.function=函数 {0}
refactoring.inline.label.method=方法 {0}
refactoring.inline.local.multiassignment=使用多个赋值定义
refactoring.inline.method=内联方法 {0}
refactoring.inline.this.only=仅内联此调用并保留声明
refactoring.introduce.constant.cannot.extract.selected.expression=所选表达式无法提取为常量
refactoring.introduce.constant.dialog.title=提取常量
refactoring.introduce.constant.scope.error=已在作用域中声明该名称
refactoring.introduce.name.error=名称不正确
refactoring.introduce.selection.error=无法使用所选元素执行重构
refactoring.introduce.variable.dialog.title=提取变量
refactoring.introduce.variable.scope.error=该名称与现有变量或形参冲突
refactoring.move.module.members.error.cannot.place.elements.into.nonpython.file=无法将元素放入非 Python 文件中
refactoring.name.label.text={0} 有 {1} 个匹配项{2, choice, 0\#|1\#}
refactoring.progress.title.updating.existing.usages=正在更新现有用法…
type.param.list.annotator.two.or.more.types.required=需要两种或多种类型
type.param.list.annotator.type.parameter.already.defined=已在此类型形参列表中定义了名称为 ''{0}'' 的类型形参
type.param.list.annotator.type.var.tuple.and.param.spec.can.not.have.bounds=ParamSpec 和 TypeVarTuple 不能有约束和上限
unresolved.docstring.param.reference=函数 ''{0}'' 没有形参 ''{1}''
unresolved.import.reference=没有名称为 ''{0}'' 的模块

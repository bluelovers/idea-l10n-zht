abstract.class.not.allowed=不允许 abstract 类
access.static.via.instance=通过实例引用访问 static 成员
action.analyzing.cyclic.dependencies.in.scope={0}的循环依赖
action.create.new.class=创建新的类
action.create.new.class.description=创建新 Java 类
action.create.new.module-info.description=创建新的 module-info.java
action.create.new.module-info.title=module-info.java
action.create.new.package-info.description=创建新的 package-info.java
action.create.new.package-info.title=package-info.java
action.cyclic.dependency.title=分析循环依赖
action.description.copy.whole.thread.dump.to.clipboard=将整个线程转储复制到剪贴板
action.description.group.by.scope=按范围类型分组 (产品, 测试, 库)
action.description.group.threads.with.identical.stacktraces=组合具有相同堆栈跟踪的线程
action.description.mark.directory.as.a.0.for.generated.files=为生成的文件将目录标记为{0}
action.description.mark.directory.as.an.ordinary.0=将目录标记为普通{0}
action.description.show.only.threads.containing.a.specific.string=仅显示包含特定字符串的线程
action.group.by.package=软件包
action.group.by.scope.type=按范围类型分组
action.implement.method=实现方法
action.implement.methods=实现方法
action.override.method=重写方法
action.override.methods=重写方法
action.text.0.on.parameter.1=在形参 ''{1}'' 上{0}
action.text.choose.class.in.0=选择 {0} 中的类…
action.text.copy.to.clipboard=复制到剪贴板
action.text.edit.template=编辑模板
action.text.enter.class.name=输入类名…
action.text.generated.root.0=生成的{0}
action.text.merge.identical.stacktraces=合并相同的堆栈跟踪
action.text.show.methods.to.implement=显示要实现的方法
action.text.show.quick.list=显示快速列表
action.text.unmark.generated.0=取消标记生成的{0}
action.GotoSuperClass.text=转到超类 (_U)
action.GotoSuperClass.MainMenu.text=超类(_U)
action.GotoSuperClass.description=导航到当前类扩展或实现的类的声明
add.to.permits.list=将 ''{0}'' 添加到密封类 ''{1}'' 的 permits 列表
annotate.intention.chooser.title=选择要添加的注解
assignment.to.declared.variable.problem.descriptor=变量''{0}''是自我赋值初始化
assignment.to.itself.problem.descriptor=变量''{0}''是分配给自己
assignment.to.itself.quickfix.name=移除自我赋值
bean.property=Bean属性
boolean.method.is.always.inverted.display.name=布尔方法总是反向的
boolean.method.is.always.inverted.problem.descriptor=布尔方法 '#ref' 总是反转
button.add.blank=添加空白
button.add.class=添加类...
button.add=添加…
button.add.package=添加软件包…
button.add.pattern=添加模式...
button.annotations=注解...
button.base.method=基方法(&B)
button.code.patterns=代码模式…
button.current.method=当前方法(&C)
button.text.settings=设置…
cast.expression=插入转换表达式
cast.to.0=转换为''{0}''
change.color.command.text=更改颜色
change.uid.action.name=随机更改 'serialVersionUID' 初始值设定项
checkbox.after.description=在描述后
checkbox.after.parameter.descriptions=在形参描述后
checkbox.after.return.tag=在return后
checkbox.align.parameter.descriptions=对齐形参说明
checkbox.align.thrown.exception.descriptions=对齐抛出异常说明
checkbox.annotate.local.variables=注解局部变量
checkbox.collapse.annotations=注解
checkbox.collapse.anonymous.classes=匿名类
checkbox.collapse.closures="闭包" (在 Java 8 前，实现一个方法的匿名类)
checkbox.collapse.end.of.line.comments=<html>行尾注释序列</html>
checkbox.collapse.generic.constructor.parameters=<html>通用构造函数和方法形参</html>
checkbox.collapse.i18n.messages=<html>I18n字符串</html>
checkbox.collapse.inferred.type=使用推断类型替换 'var'
checkbox.collapse.inner.classes=内部类
checkbox.collapse.multiline.comments=多行注释
checkbox.collapse.one.line.methods=<html>一行方法<html>
checkbox.collapse.simple.property.accessors=<html>简单属性访问器</html>
checkbox.collapse.suppress.warnings=<html>@SuppressWarnings</html>
checkbox.comments.and.javadoc.count.as.content=注释和 javadoc 计为内容
checkbox.deprecated.members=弃用的成员
checkbox.do.not.indent.top.level.class.members=不缩进顶层类成员
checkbox.do.not.wrap.after.single.annotation=单个注解后不换行
checkbox.do.not.wrap.one.line.comments=一行注释不分行
checkbox.enable.javadoc.formatting=启用JavaDoc格式
checkbox.enable.leading.asterisks=启用前导星号
checkbox.generate.p.on.empty.lines=在空行中生成 "<p>"
checkbox.html.report.inaccessible.symbols=<html>报告无法访问的符号<br>(javadoc 工具可能无法创建超链接)
disable.report.inaccessible.symbols.fix=不报告无法访问的符号
checkbox.ignore.fields.used.in.multiple.methods=忽略多个方法中使用的字段
checkbox.ignore.simple.setters=忽略简单的 setter
checkbox.insert.imports.for.inner.classes=插入导入到内部类
checkbox.iterate.unknown.stream.sources.via.stream.iterator=通过 Stream.iterator() 迭代未知的流源
checkbox.keep.empty.lines=保留空行
checkbox.keep.empty.param.tags=保持空 @param 标签
checkbox.keep.empty.return.tags=保持空 @return 标签
checkbox.keep.empty.throws.tags=保持空 @throws 标签
checkbox.keep.invalid.tags=保持无效标签
checkbox.make.generated.local.variables.final=将生成的局部变量设为 final
checkbox.make.generated.parameters.final=将生成的形参设为 final
checkbox.param.description.on.new.line=形参描述在新行
checkbox.param.indent.on.continuation=缩进连续线
checkbox.prefer.longer.names=提升较长的名称
checkbox.preserve.line.feeds=保留换行
checkbox.spaces.record.header=记录标头
checkbox.spaces.before.colon.in.foreach=在 foreach 中的冒号之前
checkbox.spaces.inside.one.line.enum=在一行枚举大括号内
checkbox.suggest.conversion.to.map.computeifabsent=建议转换为 Map.computeIfAbsent
checkbox.suggest.conversion.to.map.getordefault=建议转换为 Map.getOrDefault
checkbox.suggest.conversion.to.map.merge=建议转换为 Map.merge
checkbox.suggest.conversion.to.map.putifabsent=建议转换为 Map.putIfAbsent
checkbox.suggest.conversion.to.map.replaceall=建议转换为 Map.replaceAll
checkbox.suggest.replacement.even.if.lambda.may.have.side.effects=建议替换，即使 lambda 可能有副作用
checkbox.suppress.with.suppresswarnings=使用 @SuppressWarnings 禁止
checkbox.treat.get.k.null.the.same.as.containskey.k.may.change.semantics=将 'get(k) != null' 视为与 'containsKey(k)' 相同 (可能更改语义)
checkbox.use.fully.qualified.class.names=使用完全限定类名
checkbox.use.single.class.import=使用单个类导入
checkbox.use.throws.rather.than.exception=用 @throws 而不是 @exception
checkbox.warn.if.only.foreach.replacement.is.available=只要 'forEach' 替换可用，就发出警告
checkbox.warn.if.the.loop.is.trivial=循环不重要时发出警告
checkbox.wrap.at.right.margin=在右页边距处换行
choose.class=选择类
chooser.text.choose.where.to.save.0=选择要保存 ''{0}'' 的位置
chooser.title.select.path.to.save.jar=选择要保存 Jar 的路径
class.decorator.or.has.default.constructor=''{0}'' 应具有默认构造函数或者实现 ''Decorator'' 模式
class.filter.editor.add.dialog.title=新的过滤器
class.filter.editor.choose.class.title=选择类
class.has.no.default.constructor=''{0}'' 没有默认的构造函数
class.is.not.a.subclass=''{0}'' 未分配到 ''{1}''
class.is.not.concrete=''{0}'' 不是一个具体类
class.is.not.public=''{0}'' 不为 public
class.not.found.error.message=未找到类 ''{0}''
code.style.generation.override.method.signature=重写方法签名
code.style.generation.repeat.synchronized.modifier=重复 synchronized 修饰符(&S)
code.style.generation.replace.null.check=将 null 检查替换为 Objects::nonNull 或 Objects::isNull
code.style.generation.use.class.isInstance=如果可能，请使用 Class::isInstance 和 Class::cast
code.style.generation.use.integer.sum=如果可能，请使用 Integer::sum 等
combobox.paste.insert.imports=粘贴时插入导入(&I):
command.create.class.from.template=从模板创建类
command.create.new.subdirectory=创建新子目录
command.name.insert.block.statement=插入块语句
command.name.updating.package.statement=更新 package 语句
comment.the.class.will.be.created.in.the.package.0=类将在软件包 ''{0}'' 中创建
completion.class.name.hint.2=再次按{0}可以在搜索时忽略模块依赖关系
completion.no.suggestions.of.type=没有类型为{0}的建议
completion.smart.aslist.hint=再次按{0}查找{1}的集合(Array)
completion.smart.chain.hint=再次按{0}搜索方法的调用链
completion.smart.hint=按{0}仅显示适合类型的变量
completion.smart.toar.hint=再次按{0}查找{1}的集合
completion.smart.type.generate.anonymous.body=生成匿名体
completion.unknown.type=未知类型{0}
configurable.EqualsHashCodeTemplatesPanel.display.name=模板
configurable.GenerateToStringConfigurable.display.name=设置
configurable.TemplatesPanel.display.name=模板
label.new.template.name=新模板名称:
dialog.title.create.new.template=创建新模板
dialog.title.copy.template=复制模板
configure.annotations.option=配置注解…
convert.compareto.expression.to.equals.call=将 'compareTo()' 表达式转换为 'equals()' 调用
convert.compareto.expression.to.equals.call.may.change.semantics=将 'compareTo()' 表达式转换为 'equals()' 调用 (可能更改语义)
copy.abstract.method.intention.name=使用现有实现''{0}''
copy.abstract.method.no.existing.implementations.found=没有找到现有的实现
copy.abstract.method.popup.title=选择要复制的实现
copy.abstract.method.title=使用 abstract 方法实现
copy.paste.reference.notification=<html>已添加 {0} 个{0, choice, 1#导入|2#导入}<p><span><a href=''show''>检查添加的导入…</a></span></html>
cyclic.dependencies.progress.text=正在构建依赖关系图
cyclic.dependencies.scope.dialog.module.button={0}模块''{1}'' (&M)
cyclic.dependencies.scope.dialog.project.button={0}整个项目 (&P)
cyclic.dependencies.scope.dialog.title=指定{0}范围
cyclic.dependencies.scope.include.test.sources.option=包含测试代码(&T)
cyclic.dependencies.tree.cycle.node.text=循环
cyclic.dependencies.usage.view.initial.text=从左边树选择分析的软件包
cyclic.dependencies.usage.view.root.node.text=在软件包 ''{1}'' 中使用软件包 ''{0}''
dataflow.from.here=流出此处的数据流
dataflow.to.here=流入此处的数据流
deannotate.intention.action.text=取消注解 {0}
deannotate.intention.action.several.text=取消注解…
deannotate.intention.action.family.name=取消注释
deannotate.intention.chooser.title=选择要删除的注解
default.file.template.description=默认文件模板
default.file.template.display.name=默认文件模板的使用
default.file.template.edit.template=编辑模板...
default.file.template.replace.with.actual.file.template=替换为实际文件模板
default.package.presentable.name=<默认>
dependencies.libraries.node.text=库
dependencies.tree.node.default.package.abbreviation=<默认软件包>
dialog.create.class.destination.package.label=目标软件包:
dialog.create.class.label=创建 {0}:
dialog.create.class.name=创建{0}{1}
dialog.create.class.package.chooser.title=选择目标软件包
dialog.create.field.from.parameter.already.exists.text=使用现有字段''{0}''？
dialog.create.field.from.parameter.already.exists.use.existing.button=使用现有字段
dialog.create.field.from.parameter.already.exists.title=字段已经存在
dialog.create.field.from.parameter.declare.final.checkbox=声明 final(&F)
dialog.create.field.from.parameter.field.name.label=名称:
dialog.create.field.from.parameter.field.type.label=字段的类型:
dialog.create.field.from.parameter.title=创建字段
dialog.edit.template.checkbox.smart.type.completion=类型匹配补全(&O)
dialog.edit.template.checkbox.use.static.import=尽可能使用静态导入(&I)
dialog.import.on.paste.title=选择要导入的类
dialog.import.on.paste.title2=选择要导入的元素
dialog.import.on.paste.title3=选择要移除的导入
dialog.message.0.update.existing.class={0}。更新现有的类?
dialog.message.create.test.in.the.same.source.root=在相同的源根中创建测试?
dialog.message.infer.nullity.annotations.requires.the.project.language.level=推断可空性注解需要将项目语言级别设置为 1.5 或更高。
dialog.message.jetbrains.annotations.library.is.missing=缺少 JetBrains 注解库。\n没有库，IntelliJ IDEA 将无法运行分析。要添加吗?
dialog.message.no.places.found.to.infer.nullable.notnull=未找到要推断 @Nullable/@NotNull 的位置
dialog.paste.on.import.text=<html>您所粘贴的代码段使用的是不是在新的形势下,可以通过导入类。<br/>选择类,您要导入到新文件。</html>
dialog.paste.on.import.text2=<html>您所粘贴的代码段使用,是不是在新的上下文访问的导入元件。<br/>选择元素,您想导入到新文件。</html>
dialog.paste.on.import.text3=<html>您粘贴的代码段在当前上下文中引入了新的导入。<br/>选择您想要消除的导入。</html>
dialog.title.choose.0.parameters=选择 {0} 形参
dialog.title.choose.class=选择类
dialog.title.configure.annotations=配置注解
dialog.title.configure.code.patterns=配置代码模式
dialog.title.create.class.in.package=在软件包中创建类
dialog.title.create.missed.tests=创建缺少的测试
dialog.title.edit.method.contract=编辑方法约定
dialog.title.edit.range=编辑范围
dialog.title.infer.nullity=推断可空性
action.description.infer.nullity.annotations=推断可空性注解
dialog.title.infer.nullity.results=推断可空性结果
dialog.title.no.test.roots.found=未找到测试根
dialog.title.process.duplicates=处理重复项
dialog.title.super.method.found=发现 super 方法
do.not.import.inner.classes.for=按短名称排除内部类:
do.not.import.inner.classes.no.classes=未定义内部类
editbox.blanklines.around.initializer=初始值设定项周围:
editbox.class.count.to.use.import.with.star=将 import 与 '*' 搭配使用的类计数:
editbox.names.count.to.use.static.import.with.star=将静态 import 与 '*' 搭配使用的名称计数:
enum.not.allowed=枚举不被允许
error.attempt.to.generate.constructor.for.anonymous.class=不能添加构造函数到匿名类
error.hint.no.expression.found=找不到表达式
error.package.already.contains.package-info=''package-info.java'' 的软件包已经存在“{0}”
error.package.already.contains.package.html=软件包 ''{0}'' 已经有一个 ''package.html'' 文件。仍要创建 ''package-info.java''?
error.package.html.found.title=发现“package.html”
error.text.this.is.not.a.valid.java.class.name=这不是有效的 Java 类名
exclude.0.from.completion=从补全中排除 ''{0}''
exclude.accessors=排除访问器(&E)
exclude.from.completion.group=从自动导入和补全中排除:
exclude.from.imports.no.exclusions=添加类、软件包或成员
exclude.from.imports.no.exclusions.2=以从自动导入和补全中排除
exclude.table.mask=类、软件包或成员
exclude.table.scope.column=范围
export.to.html.generate.hyperlinks.checkbox=生成超链接指向类 (&H)
external.annotation.prompt=外部注解提示
external.annotations.external.option=从外部添加(&E)
external.annotations.in.code.option=添加代码(&C)
external.annotations.root.chooser.description=外部注解将被保存在相应的文件夹
external.annotations.root.chooser.title=选择{0}的外部注解根
external.annotations.suggestion.message=<html><body>如果您的代码中不需要注解，可以使用外部存储。<br>要配置外部注解，请指定放置包含注解的文件的根目录</body></html>
find.field.accessors.prompt=搜索字段 ''{0}'' 的访问器?
find.field.accessors.title=已找到字段访问器
find.options.include.overloaded.methods.checkbox=重载方法(&V)
find.what.derived.classes.checkbox=派生类(&D)
find.what.derived.interfaces.checkbox=派生接口(&D)
find.what.fields.usages.checkbox=字段的用法(&F)
find.what.implementing.classes.checkbox=实现类(&I)
find.what.implementing.methods.checkbox=实现方法(&I)
find.what.implicit.to.string.checkbox=隐式调用(&M)
find.what.methods.usages.checkbox=方法的用法 (&M)
find.what.overriding.methods.checkbox=重写方法(&R)
find.what.usages.checkbox=用法 (&U)
find.what.usages.of.classes.and.interfaces=类和接口的用法 (&C)
generate.button.title=生成
generate.constructor.fields.chooser.title=选择要通过构造函数初始化的字段
generate.constructor.super.constructor.chooser.title=选择超类构造函数
generate.delegate.target.chooser.title=选择目标生成的代表
generate.equals.and.hashcode.already.defined.title=生成 'equals()' 和 'hashCode()'
generate.equals.and.hashcode.already.defined.warning=对于类{0},方法''boolean equals(Object)'' 和 ''int hashCode()''已经定义,要继续删除它们吗?
generate.equals.and.hashcode.already.defined.warning.anonymous=对于这个匿名类,方法'boolean equals(Object)' 和 'int hashCode()'已经定义,要继续删除它们吗?
generate.equals.hashcode.accept.sublcasses=接受子类作为 equals() 方法的形参(&S)
generate.equals.hashcode.accept.sublcasses.explanation=<html><body>通常不符合 Object.equals() 接受范围<br>但要使生成的方法在框架中正确工作，可能会需要接受子类<br>在框架中, 会生成像Hibernate这样的代理子类。</body></html>
generate.equals.hashcode.equals.fields.chooser.title=选择要包含在 equals() 中的字段(&F)
generate.equals.hashcode.hashcode.fields.chooser.title=选择要包含在 hashCode() 中的字段(&F)
generate.equals.hashcode.internal.error=内部错误
generate.equals.hashcode.non.null.fields.chooser.title=选择所有非空字段 (&F)
generate.equals.hashcode.template=模板(&T):
generate.equals.hashcode.use.getters=在代码生成过程中使用 &getters
generate.equals.hashcode.warning.hashcode.for.arrays.is.not.supported=hashCode()不支持数组
generate.equals.hashcode.wizard.title=生成 equals() 和 hashCode()
generate.equals.template.title=Equals 模板:
generate.equals.warning.equals.for.nested.arrays.not.supported=equals()不支持嵌套的数组
generate.equals.warning.generated.equals.could.be.incorrect=生成的Object[]的equals()可能不正确
generate.getter.fields.chooser.title=选择要生成 Getter 的字段
generate.getter.setter.title=选择要生成 Getter 和 Setter 的字段
generate.getter.template=Getter 模板(&G):
generate.hashcode.template.title=HashCode 模板:
generate.record.constructor.title=生成记录构造函数
generate.setter.fields.chooser.title=选择要生成 Setter 的字段
generate.setter.template=Setter 模板(&S):
generate.tostring.already.exist.border=当方法已存在时
generate.tostring.available.implicit.variables.label=可用的隐式变量:<br/>{0}
generate.tostring.exclude..transient=排除 transient 字段
generate.tostring.exclude.by.field.name=按名称排除字段 (reg exp)
generate.tostring.exclude.by.field.type=按类型名称排除字段 (reg exp)
generate.tostring.exclude.by.name=按名称排除方法 (reg exp)
generate.tostring.exclude.by.return.type=按返回类型名称排除方法 (reg exp)
generate.tostring.exclude.constant.fields=排除常量字段
generate.tostring.exclude.enum.fields=排除枚举字段
generate.tostring.exclude.logger=排除记录器字段 (Log4j、JDK 日志记录、Jakarta Commons 日志记录)
generate.tostring.exclude.static.fields=排除 static 字段
generate.tostring.fully.qualified.class.name=在代码生成中使用完全限定类名 ($classname)
generate.tostring.getters.in.generated.code=在代码生成中启用 getter ($methods)
generate.tostring.handle.exception.error.message=执行操作时引发不可恢复的异常 - 请参阅 IDEA 日志以获取详细信息 (堆栈跟踪应位于 idea.log 中):\n{0}
generate.tostring.handle.exception.plugin.warning.message=执行操作时引发 PluginException - 请参阅 IDEA 日志以获取详细信息 (堆栈跟踪应位于 idea.log 中):\n{0}
generate.tostring.handle.exception.velocity.error.message=生成代码时出现 Velocity 错误 - 请参阅 IDEA 日志以获取更多详细信息 (堆栈跟踪应位于 idea.log 中):\n{0}
generate.tostring.insert.border=在哪里插入?
generate.tostring.method.already.exists.dialog.me=ssage=替换现有的 {0} 方法
generate.tostring.method.already.exists.dialog.title=方法已存在
generate.tostring.move.to.generated.checkbox=将文本光标移动到生成的方法
generate.tostring.settings=设置
generate.tostring.sort.ascending=升序
generate.tostring.sort.checkbox=对元素进行排序
generate.tostring.sort.descending=降序
generate.tostring.sort.super=超类成员优先
generate.tostring.tab.title=toString() 生成设置
generate.tostring.template.label=模板(&T):
generate.tostring.title=生成 toString()
goto.super.class.chooser.title=选择超类或接口
group.javadoc.alignment=对齐
group.javadoc.blank.lines=空行
group.javadoc.invalid.tags=无效标签
group.javadoc.other=其他
gutter.implemented.method=已实现方法
gutter.implementing.method=实现方法
gutter.overridden.method=重写的方法
gutter.overriding.method=重写方法
gutter.service=服务
gutter.sibling.inherited.method=同级继承的方法
highlight.exceptions.thrown.chooser.title=选择异常类以高亮显示
highlight.imported.classes.chooser.title=选择导入高亮的类
highlight.imported.members.chooser.title=选择导入高亮的成员
highlight.overridden.classes.chooser.title=从...选择高亮重写方法的类
icon.preview=图标预览
ignore.imports.and.formatting=忽略导入和格式设置
illegal.name.validation.info=非法名称: {0}
import.layout.static.imports.separately=单独布局静态导入
import.statically=静态导入
include.accessors=包含访问器(&I)
infer.nullity.progress=正在对结果进行后期处理…
insert.override.annotation=插入 @Override 注解(&O)
inspection.assert.quickfix=断言''{0}''
inspection.capturing.cleaner=已传递到 Cleaner.register() 的可运行对象捕获 ''{0}'' 引用
inspection.capturing.cleaner.description=清理器捕获对象引用
inspection.cast.can.be.removed.narrowing.variable.type.fix.family.name=更改变量类型并移除转换
inspection.cast.can.be.removed.narrowing.variable.type.fix.name=将 ''{0}'' 的类型更改为 ''{1}'' 并移除转换
inspection.cast.can.be.removed.narrowing.variable.type.message=可以通过将 ''{0}'' 的类型更改为 ''{1}'' 来移除转换
inspection.cast.can.be.removed.narrowing.variable.type.name=太弱的变量类型导致不必要的转换
inspection.charset.object.can.be.used.display.name=可以使用标准 'Charset' 对象
inspection.charset.object.can.be.used.fix.family.name=使用字符集常量
inspection.charset.object.can.be.used.message=可以改用{0}
inspection.collection.factories.fix.family.name=替换集合工厂回调
inspection.collection.factories.fix.name=替换为 ''{0}.{1}()'' 调用
inspection.collection.factories.message=可被替换为 ''{0}.{1}()'' 调用
inspection.collection.factories.option.ignore.non.constant=仅在内容为常量时报告
inspection.collection.factories.option.suggest.ofentries=建议 'Map.ofEntries()'
inspection.collection.used.as.vararg.display.name=可迭代对象用作 vararg
inspection.collection.used.as.vararg.message=可迭代对象作为 vararg 传递: 很可能应为数组
inspection.comparator.result.comparison.display.name=compare 方法的可疑用法
inspection.comparator.result.comparison.fix.family.name=修正比较结果
inspection.comparator.result.comparison.problem.display.name=比较方法的结果与特定常数对比
inspection.conditional.break.in.infinite.loop=将条件移动到循环中
inspection.conditional.break.in.infinite.loop.description=无限循环中存在条件中断
inspection.conditional.break.in.infinite.loop.no.conversion.with.do.while=不建议替换为 'do while'
inspection.convert.to.local.quickfix=转换为当地
inspection.data.flow.display.name=恒定条件和例外
inspection.data.flow.filter.notnull.quickfix=插入'filter(Objects::nonNull)'步骤
inspection.data.flow.nullable.quickfix.option=对可 null 值的方法/字段/形参建议使用 @Nullable 注解
inspection.data.flow.true.asserts.option=不报告条件静态证明始终为 <code>true</code> 的断言
inspection.data.flow.ignore.assert.statements=忽略 assert 语句
inspection.data.flow.warn.when.reading.a.value.guaranteed.to.be.constant=读取保证为常量的值时发出警告
inspection.data.flow.treat.non.annotated.members.and.parameters.as.nullable=将未注解的成员和形参视为 @Nullable
inspection.data.flow.report.not.null.required.parameter.with.null.literal.argument.usages=报告使用 null 文字实参用法的非 null 必需形参
inspection.data.flow.report.nullable.methods.that.always.return.a.non.null.value=报告始终返回非 null 值的可 null 方法
inspection.data.flow.report.problems.that.happen.only.on.some.code.paths=报告仅在某些代码路径上发生的问题
inspection.data.flow.use.computeifpresent.quickfix=将 'compute' 替换为 'computeIfPresent'
inspection.dead.code.option.applet=小程序
inspection.dead.code.option.external=非 Java 文件中使用的类
inspection.dead.code.option.main=<html><code>void main(String args[])</code> 方法</html>
inspection.dead.code.option.servlet=Servlet
inspection.default.annotation.param=默认注解形参值
inspection.duplicate.branches.in.switch.default.message='switch' 中的分支是默认分支的重复项
inspection.duplicate.branches.in.switch.delete.fix.family.name=删除冗余 'switch' 分支
inspection.duplicate.branches.in.switch.delete.fix.name=删除冗余 'switch' 分支
inspection.duplicate.branches.in.switch.display.name='switch' 中存在重复分支
inspection.duplicate.branches.in.switch.merge.fix.family.name=合并 'switch' 中的重复分支
inspection.duplicate.branches.in.switch.merge.fix.name=与 ''{0}'' 合并
inspection.duplicate.branches.in.switch.merge.with.default.fix.name=与默认的 'switch' 分支合并
inspection.duplicate.branches.in.switch.message='switch' 中存在重复分支
inspection.duplicate.expressions.complexity.threshold=表达式复杂性阈值
inspection.duplicate.expressions.display.name=同一表达式存在多个匹配项
inspection.duplicate.expressions.introduce.variable.fix.family.name=引入变量
inspection.duplicate.expressions.introduce.variable.fix.name=为 ''{0}'' 引入变量
inspection.duplicate.expressions.message=<code>#ref</code> 的多个匹配项 #loc
inspection.duplicate.expressions.replace.other.occurrences.fix.family.name=替换为表达式的其他可变匹配项
inspection.duplicate.expressions.replace.other.occurrences.fix.name=将 ''{0}'' 替换为 ''{1}'' 的其他匹配项
inspection.duplicate.expressions.reuse.variable.fix.family.name=重用变量
inspection.duplicate.expressions.reuse.variable.fix.name=为 ''{1}'' 重用变量 ''{0}''
inspection.empty.method.delete.quickfix=删除不必要的方法
inspection.empty.method.problem.descriptor=方法只调用它的 super
inspection.empty.method.problem.descriptor1=空方法重写空方法
inspection.empty.method.problem.descriptor2=该方法为空
inspection.empty.method.problem.descriptor3=该方法和所有它的derivables是空的
inspection.empty.method.problem.descriptor4=此方法的所有实现都为空
inspection.endless.stream.description=非短路操作消耗无限流
inspection.equals.hashcode.display.name='equals()' 和 'hashCode()' 未配对
inspection.equals.hashcode.generate.equals.quickfix=生成 'equals()'
inspection.equals.hashcode.generate.hashcode.quickfix=生成 'hashCode()'
inspection.excessive.lambda.fix.family.name=常数替换lambda
inspection.excessive.lambda.fix.name=使用没有lambda的''{0}''方法
inspection.excessive.lambda.message=过度使用 lambda
inspection.explicit.argument.can.be.lambda.fix.family.name=将显式实参替换为函数
inspection.explicit.argument.can.be.lambda.fix.name=使用包含函数实参的 ''{0}'' 方法
inspection.explicit.argument.can.be.lambda.message=显式实参可以转换为 lambda
inspection.explicit.array.filling.description=可被替换为单个 ''Arrays.{0}()'' 方法调用
inspection.explicit.array.filling.fix.family.name=将循环替换为 ''Arrays.{0}()'' 方法调用
inspection.explicit.array.filling.no.suggestion.for.set.all=不建议使用 'Arrays.setAll()'
inspection.explicit.array.filling.redundant.loop.description=新建数组的冗余初始化
inspection.explicit.array.filling.suggest.set.all=建议 'Arrays.setAll()'
inspection.export.results.callees=调用链
inspection.export.results.implicit.constructor=隐式构造函数 -
inspection.export.results.overrides.library.methods=重写库方法
inspection.export.results.package=软件包
inspection.export.results.type.references=以下使用这种类型
inspection.field.can.be.local.display.name=可以为本地字段
inspection.field.can.be.local.problem.descriptor=字段可以被转换为一个局部变量
inspection.field.can.be.local.quickfix.constructor=将字段转换为构造函数中的局部变量
inspection.field.can.be.local.quickfix.initializer=将字段转换为初始值设定项部分中的局部变量
inspection.field.can.be.local.quickfix.one.method=将字段转换为方法 ''{0}'' 中的局部变量
inspection.fold.expression.fix.family.name=折叠表达式
inspection.fold.expression.into.stream.display.name=表达式可以折叠到流链中
inspection.fold.expression.into.stream.fix.name=将表达式折叠到流链中
inspection.fold.expression.into.string.display.name=表达式可以折叠到 'String.join' 中
inspection.fold.expression.into.string.fix.name=将表达式折叠到 'String.join' 中
inspection.forward.compatibility.name=前向兼容性
inspection.fuse.stream.operations.display.name=后续步骤可以融合到Stream API链中
inspection.fuse.stream.operations.fix.family.name=将更多语句融入 Stream API 链
inspection.fuse.stream.operations.fix.name=将 {0} 融合到Stream API 链中
inspection.fuse.stream.operations.message=流可能被拓展替换 {0}
inspection.fuse.stream.operations.option.strict.mode=不建议使用 'toList()' 或 'toSet()' 收集器
inspection.handle.signature.change.type.fix.name=将类型更改为 ''{0}''
inspection.handle.signature.field.cannot.resolve=无法解析字段''{0}''
inspection.handle.signature.field.not.static=字段 ''{0}'' 不为 static
inspection.handle.signature.field.static=字段 ''{0}'' 为 static
inspection.handle.signature.field.type=字段''{0}''的类型是''{1}''
inspection.handle.signature.method.abstract=方法 ''{0}'' 在 ''{1}'' 中是 abstract 方法
inspection.handle.signature.method.not.static=方法 ''{0}'' 不为 static
inspection.handle.signature.method.static=方法 ''{0}'' 为 static
inspection.handle.signature.name=MethodHandle/VarHandle 类型不匹配
inspection.handle.signature.not.subclass=调用者类 ''{0}'' 必须是 ''{1}'' 的子类
inspection.handle.signature.use.constructor.fix.family.name=使用构造函数重载之一
inspection.handle.signature.use.constructor.fix.name=使用构造函数''{0}''
inspection.handle.signature.use.method.fix.family.name=使用方法重载之一
inspection.handle.signature.use.method.fix.name=使用方法''{0}''
inspection.idempotent.loop.body=幂等循环体
inspection.illegal.character=非法字符
inspection.suspicious.ternary.in.varargs.display.name=vararg 方法调用中的可疑三元运算符
inspection.suspicious.ternary.in.varargs.description=vararg 调用中的三元运算符包含数组和非数组分支
inspection.suspicious.ternary.in.varargs.quickfix=包装在数组初始值设定项中
inspection.insert.literal.underscores.display.name=不可读的数字文字
inspection.insert.literal.underscores.family.name=将下划线插入数字文字
inspection.javadoc.label.text=附加 Javadoc 标记:
inspection.javadoc.lint.display.name=Javadoc中的HTML问题(DocLint)
inspection.javadoc.method.problem.missing.param.tag=形参{0}缺少必需的标签 <code>@param</code>
inspection.javadoc.method.problem.missing.tag.description={0}标签说明已丢失
inspection.javadoc.option.ignore.deprecated=忽略标记为 @deprecated 的元素
inspection.javadoc.option.ignore.period=忽略期问题
inspection.javadoc.option.ignore.self.ref=忽略指向自己的Javadoc
inspection.javadoc.option.ignore.simple=忽略简单的属性访问器
inspection.javadoc.option.ignore.throws=忽略重复的'throws'标签
inspection.javadoc.option.tab.title=类
inspection.javadoc.option.tab.title.field=字段
inspection.javadoc.option.tab.title.inner.class=内部类
inspection.javadoc.option.tab.title.method=方法
inspection.javadoc.option.tab.title.module=模块
inspection.javadoc.option.tab.title.package=软件包
inspection.javadoc.problem.add.param.tag=为形参''{0}''添加标签 @param
inspection.javadoc.problem.add.param.tag.family=添加缺少的Javadoc形参标签
inspection.javadoc.problem.add.tag=添加标签 @{0}{1}
inspection.javadoc.problem.add.tag.family=添加缺少的 Javadoc 标签
inspection.javadoc.problem.cannot.resolve=无法解析符号{0}
inspection.javadoc.problem.descriptor=要求Javadoc不在
inspection.javadoc.problem.descriptor1=期在文档缺失.使用期间由工具生成的Javadoc注释的概述页面
inspection.javadoc.problem.disallowed.tag=此处不允许使用标签{0}
inspection.javadoc.problem.duplicate.param=重复的形参''{0}'' @param 标记
inspection.javadoc.problem.duplicate.tag=重复的 @{0} 标记
inspection.javadoc.problem.duplicate.throws=重复 @throws 或 @exception 标记为异常''{0}''
inspection.javadoc.problem.inaccessible=无法从此处访问符号 {0}
inspection.javadoc.problem.missing.tag=需要标记{0}是缺失的
inspection.javadoc.problem.missing.tag.description={0}在 @{1} 标记之后丢失
inspection.javadoc.problem.name.expected=应为名称
inspection.javadoc.problem.pointing.to.itself=Javadoc指向本身
inspection.javadoc.problem.see.tag.expecting.ref=类/方法引用，引用文本或HTML链接，预计后 @see tag
inspection.javadoc.problem.wrong.tag=错误标签{0}
inspection.javadoc.ref.display.name=声明在Javadoc引用中有问题
inspection.javadoc.throws.or.exception.option=@throws 或 @exception
inspection.join.declaration.and.assignment.display.name=赋值可与声明联接
inspection.join.declaration.and.assignment.fix.family.name=联接声明和赋值
inspection.join.declaration.and.assignment.message=赋值可与 ''{0}'' 的声明联接
inspection.labeled.switch.rule.redundant.code.block.display.name=标记的 switch 规则具有冗余代码块
inspection.labeled.switch.rule.redundant.code.block.message=标记规则的代码块冗余
inspection.labeled.switch.rule.redundant.code.fix.name=取消标记规则的代码块换行
inspection.lambda.to.method.call.fix.family.name=用方法调用替换lambda表达式
inspection.lambda.to.method.call.fix.name=用''{0}''替换lambda表达式
inspection.manual.min.max.calculation.description=可被替换为 ''Math.{0}()'' 调用
inspection.manual.min.max.calculation.disable.for.non.integral=禁用 float 和 double
inspection.map.foreach.display.name=可以使用 Map.forEach()
inspection.map.foreach.option.no.loops=不要报告循环
inspection.message.anonymous.ref.loc.can.be.replaced.with.method.reference=匿名s #ref #loc 可被替换为方法引用
inspection.message.can.be.replaced.with.0.constructor=可被替换为 ''{0}'' 构造函数
inspection.message.can.be.replaced.with.files.readstring=可被替换为 'Files.readString()'
inspection.message.can.be.replaced.with.optional.of.nullable=可被替换为 Optional.ofNullable()
inspection.message.can.be.replaced.with.single.expression.in.functional.style=可被替换为函数样式的单个表达式
inspection.message.can.be.replaced.with.string.repeat=可被替换为 'String.repeat()'
inspection.message.lambda.parameter.type.is.redundant=Lambda 形参类型冗余
inspection.message.pseudo.functional.style.code=伪函数样式代码
inspection.message.redundant.default.parameter.value.assignment=冗余的默认形参值赋值
inspection.message.replace.optional.with.if.statements=将 Optional 替换为 if 语句
inspection.no.jdk.error.message=没有为此项目正确配置 JDK。无法进行检查。
inspection.no.modules.error.message=此项目不包含模块。无法进行检查。
inspection.notnull.field.not.initialized.display.name=@NotNull 字段未初始化
inspection.notnull.field.not.initialized.option.implicit=忽略可以隐式初始化的字段
inspection.notnull.field.not.initialized.option.setup=忽略在 setUp() 方法中初始化的字段
inspection.null.value.for.optional.assigned.ignore.fix.name=将 Optional 与 null 比较时不发出警告
inspection.null.value.for.optional.assigned.message=Optional 值与 null 比较
inspection.null.value.for.optional.context.assignment=分配
inspection.null.value.for.optional.context.declaration=声明
inspection.null.value.for.optional.context.lambda=lambda表达式
inspection.null.value.for.optional.context.parameter=形参
inspection.null.value.for.optional.context.return=return 语句
inspection.null.value.for.optional.fix.family.name=替换空的可选方法
inspection.null.value.for.optional.message=Null 用于 {0} 中的 ''Optional'' 类型
inspection.null.value.for.optional.option.comparisons=报告 Optional 与 null 的比较
inspection.nullable.problems.display.name=@NotNull/@Nullable 问题
inspection.nullable.problems.ignore.external.notnull=忽略外部 @NotNull(&I)
inspection.nullable.problems.method.overrides.notnull.option=<html>报告重写 @Nullable 的 @NotNull 形参和<br>重写 @NotNull 的 @Nullable 方法</html>(&P)
inspection.nullable.problems.method.overrides.option=报告未注解的形参或方法重写 @NotNull (&A)
inspection.nullable.problems.not.annotated.getters.for.annotated.fields=报告注解字段的非注解 setter 形参或 getter(&S)
inspection.nullable.problems.notnull.overrides.option=报告重写非注解对象的 @NotNull 形参(&P)
inspection.nullable.problems.notnull.parameters.with.null.literal.option=报告使用 null 文字实参的 @NotNull 形参
inspection.optional.get.without.is.present.message=<code>{0}.#ref()</code> 未进行 ''isPresent()'' 检查
inspection.overflowing.loop.index.inspection.description=循环执行零次或无限次
inspection.overflowing.loop.index.inspection.name=循环执行零次或无限次
inspection.overwritten.key.map.message=重复的Map key
inspection.overwritten.key.set.message=重复的 Set 元素
inspection.overwritten.key.array.message=被覆盖的数组元素
inspection.parameter.can.be.local.display.name=从不读取作为形参传递的值
inspection.parameter.can.be.local.problem.descriptor=形参可以被转化为一个局部变量
inspection.pseudo.functional.style.add.methods.after.quick.fix=快速修复后:
inspection.pseudo.functional.style.add.methods.before.quick.fix=快速修复前:
inspection.pseudo.functional.style.add.methods.fully.qualified.class.name=完全限定类名:
inspection.pseudo.functional.style.add.methods.method.name=方法名称:
inspection.pseudo.functional.style.add.methods.stream.api.replacement=Stream API 替换:
inspection.quickfix.assert.family=断言
inspection.raw.use.of.parameterized.type.problem.descriptor=形参化类 <code>#ref</code> 的原始使用 #loc
raw.variable.type.can.be.generic.family.quickfix=向类型添加泛型形参
raw.variable.type.can.be.generic.quickfix=将 {0} 的类型更改为 {1}
raw.use.of.parameterized.type.ignore.new.objects.option=忽略新对象的构造
raw.use.of.parameterized.type.ignore.type.casts.option=忽略类型转换
raw.use.of.parameterized.type.ignore.uncompilable.option=忽略类型形参无法编译的位置
raw.use.of.parameterized.type.ignore.overridden.parameter.option=忽略重写方法的形参类型
raw.use.of.parameterized.type.ignore.quickfix.not.available.option=在自动快速修复不可用时忽略
inspection.redundant.array.creation.display.name=冗余数组创建
inspection.redundant.array.creation.for.varargs.call.descriptor=调用 vararg 方法的冗余数组创建
inspection.redundant.array.creation.quickfix=移除显式数组创建
inspection.redundant.explicit.close=冗余 'close()'
inspection.redundant.file.creation.display.name=创建冗余 'File' 实例
inspection.redundant.file.creation.description=<code>#ref</code> 冗余 #loc
inspection.redundant.file.creation.quickfix=替换为文件名
inspection.redundant.null.check.always.fail.message=Null 检查始终失败: {0} 永不为 null
inspection.redundant.null.check.fix.family.name=移除冗余 null 检查
inspection.redundant.null.check.fix.notnull.family.name=移除错误的 '!= null'
inspection.redundant.null.check.message=冗余 null 检查: {0} 永不为 null
inspection.redundant.operation.on.empty.array.message=数组 <code>#ref</code> 始终为空
inspection.redundant.operation.on.empty.collection.message=集合 <code>#ref</code> 始终为空
inspection.redundant.operation.on.empty.container.display.name=空容器上存在冗余操作
inspection.redundant.operation.on.empty.map.message=映射 <code>#ref</code> 始终为空
inspection.redundant.record.constructor.can.be.compact.message=规范构造函数可以转换为压缩形式
inspection.redundant.record.constructor.canonical.message=冗余规范构造函数
inspection.redundant.record.constructor.compact.message=冗余压缩构造函数
inspection.redundant.record.constructor.description=冗余记录构造函数
inspection.redundant.record.constructor.fix.family.name=将规范构造函数转换为压缩形式
inspection.redundant.record.constructor.statement.message=压缩构造函数中存在冗余字段赋值
inspection.redundant.stream.optional.call.explanation.at.most.one=流最多包含一个元素
inspection.redundant.stream.optional.call.explanation.distinct=链中存在先前的 'distinct()' 调用
inspection.redundant.stream.optional.call.explanation.distinct.set=收集到集时，元素将保持不重复
inspection.redundant.stream.optional.call.explanation.filter=判定始终为 'true'
inspection.redundant.stream.optional.call.explanation.map.flatMap=上一个 'map()' 调用可以替换 'flatMap()' 步骤
inspection.redundant.stream.optional.call.explanation.parallel=存在会重写此调用的后续 ''{0}()'' 调用
inspection.redundant.stream.optional.call.explanation.parallel.single=从单个元素创建的流不会并行化
inspection.redundant.stream.optional.call.explanation.sorted=后续的 ''{0}()'' 调用不依赖于排序顺序
inspection.redundant.stream.optional.call.explanation.sorted.twice=链中存在后续的 'sorted()' 调用
inspection.redundant.stream.optional.call.explanation.unordered=链中存在先前的 'unordered()' 调用
inspection.redundant.stream.optional.call.fix.collect.to.ordered.family.name=收集到 'LinkedHashSet'
inspection.redundant.stream.optional.call.fix.family.name=移除冗余的调用链
inspection.redundant.stream.optional.call.fix.name=移除 ''{0}()'' 调用
inspection.redundant.stream.optional.call.message=冗余的 ''{0}()'' 调用
inspection.redundant.stream.optional.call.message.with.explanation=冗余的 ''{0}()'' 调用: {1}
inspection.redundant.stream.optional.call.option.streamboxing=报告Stream.map中无用的装箱()
inspection.reflect.handle.invocation.argument.not.array=实参不是数组类型
inspection.reflect.handle.invocation.argument.not.exact=实参类型应该是 ''{0}''
inspection.reflect.handle.invocation.primitive.argument.null=类型 ''{0}'' 的实参不能为 ''null''
inspection.reflect.handle.invocation.receiver.incompatible=回调接收类型不兼容: ''{0}''
inspection.reflect.handle.invocation.receiver.null=调用接收器为 'null'
inspection.reflect.handle.invocation.result.not.assignable=应该被转换为''{0}''或其超类
inspection.reflect.handle.invocation.result.not.exact=应该被转换为''{0}''
inspection.reflect.handle.invocation.result.null=返回值总是'null'
inspection.reflect.handle.invocation.result.void=返回类型为'void'
inspection.reflection.invocation.argument.count=应为{0,choice,0#另个实参|1# 1 个实参|1<{0} 个实参}
inspection.reflection.invocation.argument.not.assignable=实参不能分配给 ''{0}''
inspection.reflection.invocation.array.not.assignable=数组项目具有不兼容的类型
inspection.reflection.invocation.item.count={0,choice,0#空数组|1#1个数组项|1<{0}个数组项}是预期的
inspection.reflection.invocation.item.not.assignable=数组项不能分配给''{0}''
inspection.reflection.invocation.name=反射调用实参不匹配
inspection.reflection.member.access.cannot.resolve.constructor.arguments=无法使用指定的实参类型解析构造函数
inspection.reflection.member.access.cannot.resolve.field=无法解析字段 ''{0}''
inspection.reflection.member.access.cannot.resolve.method=无法解析方法''{0}''
inspection.reflection.member.access.cannot.resolve.method.arguments=无法使用指定的实参类型解析方法''{0}''
inspection.reflection.member.access.check.exists=检查该字段/方法是否存在于非 final 类中
inspection.reflection.member.access.check.exists.exclude.label=排除类:
inspection.reflection.member.access.check.exists.exclude.chooser=要排除的类
inspection.reflection.member.access.constructor.not.public=构造函数不为 public
inspection.reflection.member.access.field.not.in.class=字段''{0}''未在类''{1}''中声明
inspection.reflection.member.access.field.not.public=字段 ''{0}'' 不为 public
inspection.reflection.member.access.fix.family.name=使用适当的反射方法
inspection.reflection.member.access.method.not.in.class=方法''{0}''未在类''{1}''中声明
inspection.reflection.member.access.method.not.public=方法 ''{0}'' 不为 public
inspection.reflection.member.access.name=反射访问不存在/不可见的类成员
inspection.reflection.visibility.name=跨模块问题的反射访问
inspection.remove.literal.underscores.display.name=数字文字中的下划线
inspection.remove.literal.underscores.family.name=从数字文字中移除下划线
inspection.replace.methodref.ternary.quickfix=替换为空检查的lambda
inspection.replace.ternary.quickfix=替换为''{0}!= null吗?''
inspection.replace.with.bulk.fix.family.name=替换大量方法调用
inspection.replace.with.bulk.fix.name=用批量 ''{0}()'' 调用替换迭代
inspection.replace.with.bulk.message=迭代可被替换为批量 ''{0}()'' 调用
inspection.replace.with.bulk.wrap.arrays=使用 'Arrays.asList()' 包装数组
inspection.replace.with.enhanced.switch.statement.fix.name=替换为增强的 'switch' 语句
inspection.replace.with.old.style.switch.statement.fix.name=替换为旧式 'switch' 语句
inspection.replace.with.regular.string.literal.fix=替换为正则字符串文字
inspection.replace.with.switch.expression.fix.name=替换为 'switch' 表达式
inspection.replace.with.text.block.fix=替换为文本块
inspection.replace.with.trivial.lambda.fix.family.name=替换为普通 lambda
inspection.replace.with.trivial.lambda.fix.name=替换为返回 ''{0}'' 的 lambda
inspection.require.non.null=将 null 检查替换为 Objects/Stream static 调用
inspection.require.non.null.description=Null 检查可被替换为方法调用
inspection.require.non.null.message=用对象替换条件.{0}
inspection.require.non.null.no.warning.replacement.bigger=替换长度大于原始长度时不发出警告
inspection.return.separated.from.computation.descriptor=返回与 ''{0}'' 的值的计算分离
inspection.return.separated.from.computation.family.quickfix=将'返回'更接近结果的计算
inspection.return.separated.from.computation.name=与结果计算分离的 'return'
inspection.return.separated.from.computation.quickfix=将“return”更接近计算''{0}''的值
inspection.same.parameter.display.name=方法形参始终是相同的值
inspection.same.parameter.fix.family.name=内联形参为常量值
inspection.same.parameter.fix.name=内联形参 ''{0}'' 的值 ''{1}''
inspection.same.parameter.problem.descriptor=形参 <code>#ref</code> 的实际值始终为 ''{0}''
inspection.simplifiable.comparator.comparing.message=不必要的 ''{0}()'' 调用
inspection.simplifiable.comparator.display.name=可以简化 Comparator 方法
inspection.simplifiable.comparator.entry.comparator.message=可以改用 ''{0}''
inspection.simplifiable.comparator.fix.comparing.family.name=移除冗余调用
inspection.simplifiable.comparator.fix.entry.comparator.family.name=使用预定义的 'Map.Entry' 比较运算符方法
inspection.simplifiable.comparator.fix.remove.name=移除 ''{0}()'' 调用
inspection.simplifiable.comparator.fix.replace.name=移除 ''{0}()'' 调用并使用 ''{1}()''
inspection.simplifiable.comparator.fix.reversed.family.name=简化将 'max' 替换为 'min' 的比较运算符方法
inspection.simplifiable.comparator.fix.reversed.name=替换为简化比较运算符的 ''{0}''
inspection.simplifiable.comparator.reversed.message=如果 ''{0}()'' 调用替换为 ''{1}()''，则可以简化比较运算符方法
inspection.simplify.collector.fix.family.name=简化级联器
inspection.simplify.collector.fix.name=使用''Collectors.{0}''收集
inspection.simplify.collector.message=可以使用 ''{0}'' 收集器简化
inspection.simplify.foreach.display.name=可简化的 forEach() 调用
inspection.sorted.collection.with.non.comparable.keys.display.name=包含不可比较元素的排序集合
inspection.sorted.collection.with.non.comparable.keys.message=包含不可比较元素的排序集合的构造
inspection.sorted.collection.with.non.comparable.keys.option.type.parameters=不报告不可比较的类型形参
inspection.surround.if.family=环绕用if语句
inspection.surround.if.quickfix=环绕用''if({0}!= null)''
inspection.suspicious.list.remove.display.name=循环中的 'List.remove()' 可疑
inspection.switch.expression.backward.expression.migration.inspection.name='switch' 表达式可被替换为旧式 'switch' 语句
inspection.switch.expression.backward.migration.inspection.name=增强的 'switch'
inspection.switch.expression.backward.statement.migration.inspection.name='switch' 语句可被替换为旧式 'switch' 语句
inspection.switch.expression.migration.inspection.name=语句可被替换为增强的 'switch'
inspection.switch.expression.migration.inspection.switch.description=Switch 语句可被替换为增强的 'switch'
inspection.switch.expression.migration.warn.only.on.expression=仅在可以转换为表达式时显示警告
inspection.switch.labeled.rule.can.be.code.block.display.name=标记的 switch 规则可以具有代码块
inspection.switch.labeled.rule.can.be.code.block.expression.message=标记规则的结果表达式可以使用代码块包装
inspection.switch.labeled.rule.can.be.code.block.fix.expression.name=使用代码块包装标记规则的结果表达式
inspection.switch.labeled.rule.can.be.code.block.fix.statement.name=使用代码块包装标记规则的语句
inspection.switch.labeled.rule.can.be.code.block.statement.message=标记规则的语句可以使用代码块包装
inspection.text.block.backward.migration.message=文本块可以转换为正则字符串文字
inspection.text.block.backward.migration.name=文本块可被替换为正则字符串文字
inspection.text.block.migration.string.message=字符串可被替换为文本块
inspection.text.block.migration.concatenation.message=串联可被替换为文本块
inspection.text.block.migration.name=可以使用文本块
inspection.text.block.migration.suggest.literal.replacement=应用于单字符串文字
inspection.inconsistent.text.block.indent.name=文本块中的空格缩进不一致
inspection.inconsistent.text.block.indent.message=文本块缩进由制表符和空格组成
inspection.inconsistent.text.block.indent.spaces.to.tabs.one.to.one.fix=将空格替换为制表符(1 个空格 = 1 个制表符)
inspection.inconsistent.text.block.indent.spaces.to.tabs.many.to.one.fix=将空格替换为制表符({0} 个空格 = 1 个制表符)
inspection.inconsistent.text.block.indent.tabs.to.spaces.one.to.one.fix=将制表符替换为空格(1 个制表符 = 1 个空格)
inspection.inconsistent.text.block.indent.tabs.to.spaces.one.to.many.fix=将制表符替换为空格(1 个制表符 = {0} 个空格)
inspection.trailing.whitespaces.in.text.block.name=文本块中有尾随空格
inspection.trailing.whitespaces.in.text.block.message=文本块内有尾随空格
inspection.trailing.whitespaces.in.text.block.remove.whitespaces=移除尾随空格
inspection.trailing.whitespaces.in.text.block.replaces.whitespaces.with.escapes=尾随空格转义
inspection.undeclared.service.usage.message=服务 ''{0}'' 的使用未在模块信息中声明
inspection.undeclared.service.usage.name=服务的使用未在 'module-info' 中声明
inspection.unused.assignment.option=在可被替换为(i + 1)时报告 ++i
inspection.unused.assignment.option1=在变更后的值后续未使用时报告 i++
inspection.unused.assignment.option2=报告冗余的初始值设定项
inspection.unused.assignment.problem.descriptor1=变量 <code>#ref</code> #loc 从未使用
inspection.unused.assignment.problem.descriptor2=变量 <code>{0}</code> 初始值设定项 <code>#ref</code> #loc 冗余
inspection.unused.assignment.problem.descriptor3=分配给 <code>#ref</code> #loc 的值 <code>{0}</code> 从未使用
inspection.unused.assignment.problem.descriptor4=在 <code>#ref</code> #loc 更改的值从未使用
inspection.unused.assignment.remove.assignment.quickfix=删除冗余分配
inspection.unused.assignment.remove.quickfix=移除冗余的初始值设定项
inspection.unused.parameter.composer=形参 <code>#ref</code> 未用于任何实现
inspection.unused.parameter.composer1=形参 <code>#ref</code> 未在此方法中使用，也未在其重写方法中使用
inspection.unused.parameter.delete.quickfix=安全删除未使用的形参 ''{0}''
inspection.unused.return.value.display.name=方法可以为 'void'
inspection.unused.return.value.make.void.quickfix=使方法无效
inspection.unused.return.value.problem.descriptor=方法的返回值从未使用过
inspection.unused.symbol.check.accessors=Getter/Setter
inspection.unused.symbol.check.classes=类:
inspection.unused.symbol.check.fields=字段:
inspection.unused.symbol.check.inner.classes=内部类:
inspection.unused.symbol.check.localvars=局部变量
inspection.unused.symbol.check.methods=方法:
inspection.unused.symbol.check.parameters=形参位置:
inspection.value.based.warnings=基于值的警告
inspection.preview.feature=预览功能警告
inspection.value.based.warnings.synchronization=尝试对基于值的类的实例同步
inspection.variable.assigned.to.itself.display.name=变量被赋值给自己
inspection.wrapper.type.may.be.primitive.fix.name=将包装器类型转换为基元类型
inspection.wrapper.type.may.be.primitive.name=类型可能是基元
intention.add.explicit.type.arguments.family=添加显式类型实参
intention.add.on.demand.static.import.family=添加按需静态导入
intention.add.on.demand.static.import.text=为 ''{0}'' 添加按需静态导入
intention.add.single.member.import.text=为 ''{0}'' 添加 import
intention.add.single.member.static.import.family=添加单成员静态导入
intention.add.single.member.static.import.text=为 ''{0}'' 添加静态导入
intention.assign.field.from.parameter.family=分配形参场
intention.assign.field.from.parameter.text=将形参分配给字段 ''{0}''
intention.bind.fields.from.parameters.family=将形参绑定到字段
intention.bind.fields.from.parameters.text=将 {0} 个形参绑定到字段
intention.break.string.on.line.breaks.text=在 '\\n' 上断开字符串
intention.compose.function.family=将嵌套函数调用替换为组合
intention.compose.function.text=替换嵌套函数调用和替换后的调用
intention.convert.color.representation.family=转换颜色表示
intention.convert.color.representation.text=转换为''新颜色{0}''
intention.convert.compact.constructor.to.canonical=将压缩构造函数转换为规范构造函数
intention.convert.to.single.return.name=将正文转换成单个出口点形式
intention.convert.to.single.return.progress.title=将正文转换成单个出口点形式
intention.convert.to.single.return.command.text=将主体转换成单个出口点形式
intention.create.field.from.parameter.family=创建字段形参
intention.create.field.from.parameter.text=为形参 ''{0}'' 创建字段
intention.create.test.dialog.choose.super.class=选择超类
intention.create.test.dialog.class.name=类名:
intention.create.test.dialog.fix.library=修正
intention.create.test.dialog.generate=生成:
intention.create.test.dialog.java=Java
intention.create.test.dialog.library.not.found={0}库在该模块中未找到
intention.create.test.dialog.select.methods=为以下对象生成测试方法(&M):
intention.create.test.dialog.setUp=set&Up/@Before
intention.create.test.dialog.show.inherited=显示继承的方法(&I)
intention.create.test.dialog.super.class=超类:
intention.create.test.dialog.tearDown=tear&Down/@After
intention.create.test.dialog.testing.library=测试库(&L):
intention.encapsulate.field.text=封装领域
intention.error.cannot.create.class.message=无法创建类''{0}''
intention.error.cannot.create.class.title=创建类失败
intention.extract.if.condition.family=提取if条件
intention.extract.if.condition.text=提取if({0})
intention.extract.map.step.family=提取分离映射方法
intention.extract.map.step.text=提取变量''{0}''到''{1}''操作
intention.extract.method.text=提取方法
intention.extract.set.from.comparison.chain.duplicates={0} 在此类中检测到 {1} 个可以使用新创建的集替换的代码{1,choice,1#段|2#段}。要替换{1,choice,1#它|2#它们}吗?
intention.extract.set.from.comparison.chain.family=从比较链提取 Set
intention.family.add.javadoc=添加 Javadoc
intention.family.copy.abstract.method.implementation=复制 abstract 方法实现
intention.family.create.a.class.in.package=在软件包中创建类
intention.family.edit.method.contract=编辑方法约定
intention.family.edit.range=编辑范围
intention.family.expand.static.import=展开静态导入
intention.family.fix.bounded.wildcards=修复有界通配符
intention.family.make.external.annotations.explicit=使外部注解为显式
intention.family.make.inferred.annotations.explicit=使推断的注解为显式
intention.family.move.it=移动它
intention.family.put.arguments.on.one.line=将实参放在同一行中
intention.family.put.arguments.on.separate.lines=将实参放在单独的行中
intention.family.put.parameters.on.one.line=将形参放在同一行中
intention.family.put.parameters.on.separate.lines=将形参放在单独的行中
intention.family.put.record.components.on.one.line=将记录组件放在一行
intention.family.put.record.components.on.separate.lines=将记录组件放在单独的行中
intention.family.replace.optional.ispresent.condition.with.functional.style.expression=将 Optional.isPresent() 条件替换为函数样式表达式
intention.family.sort.content=对内容进行排序
intention.family.swap.if.statements=交换 'if' 语句
intention.family.unimplement.interface.class=取消实现接口/类
intention.family.variable.access.from.inner.class=可变的 accessFromInnerClass
intention.implement.abstract.class.default.text=实现 abstract 类
intention.implement.abstract.class.family=实现 abstract 类或接口
intention.implement.abstract.method.command.name=实现方法
intention.implement.abstract.method.error.no.classes.message=没有发现这类方法可以实现
intention.implement.abstract.method.error.no.classes.title=没有找到的类
intention.implement.abstract.method.family=实现 abstract 方法
intention.implement.abstract.method.searching.for.descendants.progress=正在搜索后代…
intention.implement.abstract.method.text=实现方法 ''{0}''
intention.inline.map.family=内联流映射方法
intention.inline.map.inline.text=将 ''{0}()'' 主体内联到下一个 ''{1}()'' 调用中
intention.inline.map.merge.text=合并 ''{0}()'' 调用和 ''{1}()'' 调用
intention.introduce.variable.text=引入局部变量
intention.invert.if.condition=反转 'if' 条件
intention.merge.filter.family=合并过滤器
intention.merge.filter.text=合并过滤器链
intention.move.field.assignment.to.declaration=移动指派到字段声明
intention.move.initializer.to.constructor=将初始值设定项移动到构造函数
intention.move.initializer.to.set.up=将初始值设定项移动到 setUp 方法
intention.override.method.text=重写方法 ''{0}''
intention.replace.cast.with.var.family=用变量替换转换
intention.replace.cast.with.var.text=将 ''{0}'' 替换为 ''{1}''
intention.replace.concatenation.with.formatted.output.family=更换连接与格式化输出
intention.replace.concatenation.with.formatted.output.text=用'java.text.MessageFormat.format()'替换'+'
intention.split.declaration.assignment.text=拆分为声明和赋值
intention.split.declaration.family=拆分声明
intention.split.filter.family=拆分过滤器
intention.split.filter.text=拆分为过滤器链
intention.split.if.family=分裂如果
intention.split.if.text=拆分为 2 条 'if' 语句
intention.split.switch.branch.with.several.case.values.copy.text=复制 'switch' 分支
intention.split.switch.branch.with.several.case.values.family=将包含多个 case 值的 switch 分支拆分成单独的 'switch' 分支
intention.split.switch.branch.with.several.case.values.split.text=拆分 'switch' 分支的值
intention.surround.resource.with.ARM.block=使用 try-with-resources 环绕
intention.surround.with.ARM.block.template=try-with-resources
intention.text.add.method.contract.to.0=将方法约定添加到 ''{0}''
intention.text.add.range.to.0=将范围添加到 ''{0}''
intention.text.annotate.externally=在外部注解
intention.text.collapse.repeating.annotations=收起重复注解
intention.text.create.a.class.in.0=在 ''{0}'' 中创建类
intention.text.edit.method.contract.of.0=编辑 ''{0}'' 的方法约定
intention.text.edit.range.of.0=编辑 ''{0}'' 的范围
intention.text.fix.method.0.parameters.with.bounded.wildcards=修复包含有界通配符的方法 ''{0}'' 形参
intention.text.generate.missed.test.methods=生成缺少的测试方法
intention.text.insert.0.annotation=插入 ''{0}''
intention.text.replace.implements.with.static.import=将实现替换为静态导入
intention.text.replace.static.import.with.qualified.access.to.0=将静态导入替换为 {0} 的限定访问
intention.text.unimplement.0=取消实现{0}
intention.text.implements.list.remove.others=移除其他 ''{0} 引用
intention.unroll.loop.family=展开循环
intention.unwrap.else.branch=解开 'else' 分支
intention.unwrap.else.branch.changes.semantics=解开 'else' 分支(更改语义)
intention.use.single.member.static.import.text=对 ''{0}'' 使用静态导入
intention.wrap.with.unmodifiable=使用不可修改的集合或映射包装
intention.wrap.with.unmodifiable.list=使用不可修改的列表包装
intention.wrap.with.unmodifiable.map=使用不可修改的映射包装
intention.wrap.with.unmodifiable.set=使用不可修改的集包装
interface.not.allowed=不允许接口
java.line.markers=Java 行标记
java.preview.features.accept.notification.link=接受
java.preview.features.alert.title=实验性功能警报
java.preview.features.legal.notice=您必须接受测试版 Java 规范的法律通知条款才能启用对“{0}”的支持。<br/><br/><b>根据 Java Community Process (JCP) 开发的早期规范草案的实现仅用于测试和评估目的，与 JCP 的任何规范都不兼容。</b>{1}
java.preview.features.notification.title=Java 预览功能
java.preview.features.warning=较新的 IDE 版本可能会停止对预览功能的支持。发布 Java {0} 时，{1} (预览)语言级别的支持可能会中断
java.terms.exception=异常
java.terms.instance.initializer=实例初始值设定项
java.terms.of.annotation.type=注解类型{1}的{0}
java.terms.of.anonymous.class=匿名类的{0}
java.terms.of.class=类 {1} 的 {0}
java.terms.of.enum=枚举 {1} 的 {0}
java.terms.of.interface=接口 {1} 的 {0}
java.terms.static.initializer=static 初始值设定项
java.terms.type.parameter=类型形参
java.terms.variable.of.method={0}/{1}
javadoc.candidates.not.found=<html>找不到方法调用 <b>{0}</b> 的候选者。</html>
javadoc.constructor.candidates=<html>新的候选 <b>{0}</b>() 是:<br>{1}</html>
javadoc.deprecated=已弃用
javadoc.description.copied.from.class=来自类:
javadoc.description.copied.from.field=来自字段:
javadoc.description.copied.from.interface=来自接口:
javadoc.generate.arguments=命令行实参:
javadoc.generate.exited=\njavadoc退出,退出代码$EXIT_CODE$\n
javadoc.generate.heap.size=最大堆大小(&M):
javadoc.generate.include.jdk.library.sources.in.sourcepath.option=在 -sourcepath 中包含 JDK 和库源
javadoc.generate.link.to.jdk.documentation.option=链接到 JDK 文档 (使用 -link 选项)
javadoc.generate.locale=区域设置(&L):
javadoc.generate.no.classes.in.selected.packages.error=选定的范围不包含Java类
javadoc.generate.no.jdk=无法生成 JavaDoc - 没有为项目配置 Java SDK。请在“设置 | 项目结构”中指定 Java SDK。
javadoc.generate.no.javadoc.tool=无法生成 JavaDoc - 在 {0} 或 {1} 上找不到 javadoc 工具。请在“设置 | 项目结构”中指定有效的 Java SDK。
javadoc.generate.open.in.browser=生成文档并用浏览器打开 (&G)
javadoc.generate.options.hierarchy=生成层次结构树
javadoc.generate.options.index=生成索引
javadoc.generate.options.index.per.letter=每个字母单独的索引
javadoc.generate.options.navigator=生成导航栏
javadoc.generate.output.directory=输出目录 (&D):
javadoc.generate.output.directory.browse=浏览输出目录
javadoc.generate.sources.progress=寻找资源来生成Javadoc
javadoc.generate.tag.list.deprecated=弃用列表
javadoc.generate.temp.file.error=无法创建临时文件
javadoc.generate.temp.file.does.not.exist=临时文件不存在或无法打开
javadoc.generate.title=生成JavaDoc
javadoc.method.in.class={0}在类{1}里边
javadoc.method.in.interface=接口 {1} 中的 {0}
javadoc.method.overrides=重写:
javadoc.method.specified.by=指定的:
javadoc.option.automatically.insert.closing.tag.javadoc=在 JavaDoc 中自动插入结束标记
javadoc.option.javadoc.title=JavaDoc
javadoc.see.also=请参阅:
javadoc.settings.title=Javadoc
javadoc.since=自:
javadoc.author=作者:
javadoc.version=版本:
javadoc.apiNote=API 说明:
javadoc.implNote=实现<br>说明:
javadoc.implSpec=实现<br>要求:
javadoc.type.parameters=类型形参:
jrt.node.short=[JRT]
label.add.math.max.0.count.to.avoid.possible.semantics.change=添加 Math.max(0, count) 以避免可能的语义变更
label.class.filter.editor.add.dialog.filter.pattern=输入过滤器模式:
label.contract=&约定:
label.enter.fully.qualified.class.name=输入完全限定类名
label.entry.points=入口点:
label.forbid.api.usages=禁止使用 API:
label.from.inclusive=&起始 (包含):
label.implementation=实现:
label.implements.method.of_class_or_interface.name=实现{0, choice, 0#接口|1#类} ''{1}'' 的方法。
label.implements.method.of_interfaces=以下类/接口的实现方法:
label.maximal.reported.method.visibility=报告方法最大可见性:
label.method=方法 ''{0}''
label.minimal.reported.method.usage.count=报告方法最小使用计数:
label.mutates=&变异:
label.name.prefix=名称前缀:
label.name.suffix=名称后缀:
label.naming.field=字段:
label.naming.local.variable=局部变量:
label.naming.parameter=形参:
label.naming.static.field=static 字段:
label.naming.subclass=子类:
label.naming.test.class=测试类:
label.overrides.method.of_class_or_interface.name=重写{0, choice, 0#接口|1#类} ''{1}'' 的方法。
label.show.import.popup.for=显示自动导入工具提示:
label.to.inclusive=&结束(包含):
label.unused.declaration.reachable.from.tests.option=当入口点位于测试源中时，将被调用方标记为:
line.marker.recursive.call=递归调用
line.marker.type.external.annotations=外部注解
line.marker.type.inferred.contract.annotations=推断约定注解
line.marker.type.inferred.nullability.annotations=推断可空性注解
listbox.import.package=软件包
listbox.import.static=static
listbox.import.with.subpackages=以及子软件包
# suppress inspection "UnusedProperty"
macro.array.variable=arrayVariable()
macro.class.name=类名
macro.classpath.entry=该元素所属的类路径中的条目
macro.component.type.of.array=componentTypeOf(Array)
macro.descendant.classes.enum=descendantClassesEnum(String)
macro.expression.type=expressionType(Expression)
macro.file.fully.qualified.package=文件完全合格软件包
macro.file.package=文件软件包
macro.guess.element.type.of.container=guessElementType(Container)
macro.iterable.component.type=iterableComponentType(ArrayOrIterable)
# suppress inspection "UnusedProperty"
macro.iterable.variable=iterableVariable()
macro.javadoc.output.directory=JavaDoc输出目录
macro.project.classpath=项目的类路径
macro.variable.of.type=variableOfType(Type)
methods.to.implement.chooser.title=选择要实现的方法
methods.to.override.chooser.title=选择要重写的方法
methods.to.override.implement.chooser.title=选择覆盖/实现的方法
module.not.in.requirements=模块 ''{0}'' 的要求中缺少模块 ''{1}''
module.package.not.exported=模块 ''{0}'' 不会将软件包 ''{1}'' 导入到模块 ''{2}''
module.package.not.open=模块 ''{0}'' 不会打开模块 ''{2} ''的软件包 ''{1}''
module.type.java.description=Java 模块用于开发<b>基于 JVM 的</b>桌面和 Web 应用程序，包括使用 <b>Java EE</b> 和其他企业开发框架的应用程序。
module.type.java.name=Java模块
navigate.to.duplicate.fix=导航到重复位置
no.methods.overriding.0.are.found=没有重写方法 {0, choice, 0#|1# ''{1}''|2#这些类} 被发现
no.patterns=没有类模式配置
node.call.hierarchy.unknown.jsp=未知的jsp
node.hierarchy.java.lang.object=所有类都派生自java.lang.Object
notification.navigation.to.overriding.classes=索引更新时无法导航到重写类
notification.navigation.to.overriding.methods=索引更新时无法导航到重写方法
notification.text.full.thread.dump.was.successfully.copied.to.clipboard=已成功将完整线程转储复制到剪贴板
nullable.notnull.annotations.panel.title={0}注解:
nullable.notnull.annotations.runtime.instrumentation.tooltip=为非空注解的方法和形参添加运行时断言
nullable.notnull.configuration.dialog.title=可空/非空配置
nullable.stuff.inspection.navigate.null.argument.usages.fix.family.name=导航到 'null' 实参用法
nullable.stuff.inspection.navigate.null.argument.usages.view.name=形参 {0} 的 ''null'' 实参用法
offline.inspections.jdk.not.found=找不到 {0}
offline.inspections.library.urls.were.not.resolved=未解析模块 ''{2}'' 中库 ''{1}'' 的根 {0}
offline.inspections.library.was.not.resolved=请配置库''{0}''用于模块''{1}''
offline.inspections.no.source.roots=未检测到模块 ''{0}'' 的源根
options.java.attribute.descriptor.abstract.class=类和接口//抽象类
options.java.attribute.descriptor.abstract.method=方法//abstract 方法
options.java.attribute.descriptor.annotation.attribute.name=注解//注解特性名称
options.java.attribute.descriptor.annotation.name=注解//注解名称
options.java.attribute.descriptor.anonymous.class=类和接口//匿名类
options.java.attribute.descriptor.class=类和接口//类
options.java.attribute.descriptor.constructor.call=方法//构造函数调用
options.java.attribute.descriptor.constructor.declaration=方法//构造函数声明
options.java.attribute.descriptor.enum=类和接口//枚举
options.java.attribute.descriptor.implicit.anonymous.parameter=形参//隐式的匿名类形参
options.java.attribute.descriptor.inherited.method=方法//继承的方法
options.java.attribute.descriptor.instance.field=类字段//实例字段
options.java.attribute.descriptor.instance.final.field=类字段//实例化final字段
options.java.attribute.descriptor.interface=类和接口//接口
options.java.attribute.descriptor.javadoc.comment=注释//JavaDoc//文本
options.java.attribute.descriptor.javadoc.markup=注释//JavaDoc//标记
options.java.attribute.descriptor.javadoc.tag=注释//JavaDoc//标签
options.java.attribute.descriptor.javadoc.tag.value=注释//JavaDoc//标签值
options.java.attribute.descriptor.lambda.parameter=形参//Lambda 形参
options.java.attribute.descriptor.method.call=方法//方法调用
options.java.attribute.descriptor.method.declaration=方法//方法声明
options.java.attribute.descriptor.method.imported.call=方法//static 导入方法调用
options.java.attribute.descriptor.reassigned.local.variable=变量//重新分配局部变量
options.java.attribute.descriptor.reassigned.parameter=形参//重新分配形参
options.java.attribute.descriptor.static.field=类字段//静态字段
options.java.attribute.descriptor.static.final.field=类字段//常量(static final 字段)
options.java.attribute.descriptor.static.final.imported.field=类字段//常量 (static final 导入字段)
options.java.attribute.descriptor.static.imported.field=类字段//静态导入字段
options.java.attribute.descriptor.static.method=方法//静态方法
options.java.attribute.descriptor.type.parameter=形参//类型形参
options.java.attribute.descriptor.public=可见性//Public
options.java.attribute.descriptor.protected=可见性//Protected
options.java.attribute.descriptor.package.private=可见性//Package-private
options.java.attribute.descriptor.private=可见性//Private
options.java.display.name=Java
override.implement.broken.file.template.message=请更正“重写/实现的方法体”模板
override.implement.broken.file.template.title=文件模板错误
package.dependencies.production.node.text=生产类
package.dependencies.test.node.text=测试类
packaging.jlink.artifact.name=JLink
packaging.jlink.artifact.title=运行时映像(JLink)
packaging.jlink.compression.level=压缩级别
packaging.jlink.compression.zero.level=不压缩
packaging.jlink.compression.first.level=字符串共享
packaging.jlink.compression.second.level=Zip
packaging.jlink.verbose.tracing=启用详细跟踪
paste.class.command.name=粘贴类 ''{0}''
please.report.a.bug=请报告错误
popup.title.choose.framework=选择框架
popup.title.choose.test=选择测试
popup.title.select.a.jar.file=选择 JAR 文件
popup.title.select.qualified.name=选择限定名称
postfix.template.language.level.title=最低语言级别:
press.0.to.see.inheritors.of.1=按 {0} 以查看 {1} 的继承者
press.0.to.see.non.imported.classes=按 {0} 以查看未导入的类
pressing.0.twice.without.a.class.qualifier=不使用类限定符，按 {0} 两次会显示所有可访问的 static 方法
project.problems.hint.text={0} 个相关{0, choice, 0#问题|2#问题}
project.problems.window.title={0} 的相关问题
project.problems.fix.text=显示相关问题
project.problems.fix.description=发现与 ''{0}'' 相关的问题
project.problems.title=相关问题
progress.creating.class=创建类{0}
progress.title.check.applicability=检查适用性…
progress.title.download.library.descriptor=下载库描述符
progress.title.find.references.in.implement.extends.lists=在实现/展开列表中查找引用…
progress.title.finding.cause=正在查找原因
progress.title.looking.for.jdk.locations=正在查找 JDK 位置…
progress.title.looking.for.libraries=正在查找库
progress.title.optimize.imports=优化 import…
progress.title.preprocess.usages=预处理用法
progress.title.search.for.overriding.methods=搜索重写方法…
progress.title.searching.for.sub.classes=正在搜索子类
prompt.choose.base.class.of.the.hierarchy=选择层次结构基类,搜索
prompt.create.non.existing.package=软件包 {0} 不存在。\n要创建吗?
prompt.delete.class=个类
prompt.delete.field=个字段
prompt.delete.interface=个接口
prompt.delete.method=个方法
prompt.delete.package={0,choice,1#软件包|2#软件包}
prompt.delete.type.parameter={0,choice,1#类型形参|2#类型形参}
#{1} presents an action verb with preposition: "to refactor" is the default value, RefactorinBundle:to.refactor
prompt.do.you.want.to.action_verb.the.method.from_class=要改为对基{0,choice,1#方法|2#方法}{1}吗?
psi.search.overriding.progress=搜索覆盖方法
quickfix.add.variable.family.name=初始化变量
quickfix.add.variable.text=初始化变量 ''{0}''
quickfix.family.avoid.mutation.using.stream.api=使用 Stream API 避免变异
quickfix.family.change.javadoc.to=更改为…
quickfix.family.find.cause=查找原因
quickfix.family.remove.javadoc.tag=移除标记
quickfix.family.remove.redundant.parameter=删除冗余形参
quickfix.family.remove.redundant.parameter.types=删除冗余形参类型
quickfix.family.replace.cast.type=替换转换类型
quickfix.family.replace.inefficient.stream.count=替换低效的 Stream.count()
quickfix.family.replace.optional.chain.with.if.statements=将 Optional 链替换为 if 语句
quickfix.family.replace.stream.api.chain.with.loop=将 Stream API 链替换为循环
quickfix.family.replace.with.java.stream.api.pipeline=替换为 Java Stream API 管道
quickfix.family.replace.with.magic.constant=替换为魔术常量
quickfix.family.replace.with.method.reference=替换为方法引用
quickfix.family.replace.with.optional.of.nullable.chain=替换为 Optional.ofNullable() 链
quickfix.family.replace.with.stream.api.equivalent=替换为 Stream API 对等项
quickfix.family.simplify.foreach.lambda=简化 forEach lambda
quickfix.family.simplify.stream.call.chain=简化流调用链
quickfix.family.use.flatmap=使用 'flatMap'
quickfix.family.wrap.with.mutable.collection=使用可变集合包装
quickfix.name.find.jar.on.web=在 web 上查找 JAR
quickfix.text.0.may.not.work.before.jdk.11.0.2={0} (可能无法在 JDK 11.0.2 之前的版本上运行)
quickfix.text.avoid.mutation.using.stream.api.0.operation=使用 Stream API ''{0}'' 操作避免变异
quickfix.text.remove.javadoc.0=移除 ''@{0}'' 标记
quickfix.text.remove.javadoc.0.1=移除 @{0} {1}
quickfix.text.remove.not.null.annotation=移除非空注解
quickfix.text.replace.0.stream.with.1.2=将 {0}.stream() 替换为 {1}.{2}()
quickfix.text.replace.collect.0.with.1.2=将 ''collect({0}())'' 替换为 ''{1}''{2}
quickfix.text.replace.filter.0.is.present.with.any.match=将 ''filter().{0}().isPresent()'' 替换为 ''anyMatch()''
quickfix.text.replace.stream.0.with.1.2=将 ''stream().{0}()'' 替换为 ''{1}()''{2}
quickfix.text.suffix.may.change.semantics=\ (可能更改语义)
quickfix.text.wrap.0.with.1=用 ''{1}'' 包装 ''{0}''
quickfix.text.replace.url.with.html=将 URL 替换为 HTML 链接
radio.button.higher.than=高于:
radio.button.respecting.to.project.language.level.settings=遵循项目语言级别设置
radio.button.subclass.of.0=''{0}'' 的子类
radio.button.unused.declaration.unused.option=未使用
radio.button.unused.declaration.used.option=已使用
radio.button.with.provider.method=带有 'provider()' 方法
radio.use.fully.qualified.class.names.in.javadoc=在 JavaDoc 中使用完全限定类名:
radio.use.fully.qualified.class.names.in.javadoc.always=始终
radio.use.fully.qualified.class.names.in.javadoc.if.not.imported=如果尚未导入
radio.use.fully.qualified.class.names.in.javadoc.never=切勿使用短名称和添加导入
scope.hierarchy={0}的层次结构
sdk.cannot.create=无法创建 SDK
sdk.java.no.classes=无法在''{0}''中找到JDK classes
section.title.inspection.suspicious.names.ignore.methods=忽略方法:
set.language.level=设置语言级别
set.language.level.to.0=设置语言级别为{0}
settings.completion.ml.java.display.name=Java
settings.inlay.java.annotations=注解
settings.inlay.java.builder.like.methods=类似于构建器的方法
settings.inlay.java.complex.expressions.binary.functional.array.access.and.other=复杂表达式作为实参
settings.inlay.java.enum.constants=枚举常量
settings.inlay.java.external.annotations=外部注解
settings.inlay.java.inferred.annotations=推断注解
settings.inlay.java.inheritors=继承者
settings.inlay.java.insert.annotation=插入注解
settings.inlay.java.implicit.types=隐式类型
settings.inlay.java.methods.with.same.named.numbered.parameters=包含相同名称的编号形参的方法
settings.inlay.java.new.expressions='New' 表达式
settings.inlay.java.non.literals.in.case.of.multiple.parameters.with.the.same.type=在具有相同类型的多个形参的情况下的非文字
settings.inlay.java.parameters.with.names.that.are.contained.in.the.method.name=具有方法名称中包含的名称的形参
settings.inlay.java.show.hints.for=显示以下项的提示:
settings.inlay.java.show.parameter.hints.for=为以下对象显示形参提示:
settings.inlay.java.show.parameter.hints.when.expression.type.is.clear.description=数组初始值设定项、switch、条件、引用、实例、赋值、调用、限定、类型转换、类对象访问表达式。
settings.inlay.java.turn.off.external.annotations=关闭外部注解
settings.inlay.java.turn.off.inferred.annotations=关闭推断注解
settings.inlay.java.usages=用法
show.import.popup.for.classes=类(&C)
show.import.popup.for.static.methods.and.fields=Static 方法和字段(&S)
exclude.import.wildcard.comment=使用 * 通配符排除指定类或软件包的所有成员
special.annotations.annotations.list=附加特殊注解:
special.annotations.list.add.annotation.class=添加注解类
special.annotations.list.annotation.class=注解类
special.annotations.list.annotation.pattern.message=添加注解模式
special.annotations.list.annotation.pattern=添加注解模式
special.annotations.list.remove.pattern=移除
spi.extension.error.message=注册的扩展应实现{0}
filetype.spi.description=服务提供程序接口
spi.no.provider.error.message=未找到服务提供程序“{0}”
status.bar.overridden.methods.highlighted.message=找到{0}重写方法  (按{1}再次移除高亮显示, Esc移除所有高亮)
surround.with.dowhile.template=do / while
surround.with.for.template=for
surround.with.ifelse.expression.template=if (expr) {...} else {...}
surround.with.not.instanceof.template=!(表达式实例类型)
surround.with.runnable.template=Runnable
surround.with.synchronized.template=synchronized
surround.with.try.catch.finally.template=try / catch / finally
surround.with.try.catch.incorrect.template.message=无效的文件模板,用于catch body
surround.with.try.catch.incorrect.template.title=环绕用try-catch
surround.with.try.catch.template=try / catch
tab.title.entry.points=入口点
tab.title.members.to.report=要报告的成员
table.cell.constructors=构造函数
title.cannot.create.class=无法创建类
title.import.layout=导入布局
title.javadoc=JavaDoc
title.naming=命名
title.naming.final.modifier=final 修饰符
title.naming.functional.expressions=Lambda 体
title.package.not.found=找不到软件包
title.packages=软件包
title.packages.to.use.import.with=将 import 与 '*' 搭配使用的软件包
to.import.a.method.statically.press.0=要静态导入方法，请按 {0}
unscramble.detect.analyze.threaddump.from.clipboard.item=自动检测和分析从 IntelliJ IDEA 外部复制到剪贴板的线程转储
unscramble.log.path.label=日志文件: (&L)
unscramble.no.unscrambler.item=<未安装译码器>
unscramble.normalize.button=标准化 (&N)
unscramble.stacktrace.caption=将一个堆栈跟踪或完整的线程转储放在此处:
unscramble.unscrambled.deadlock.tab=<死锁>
unscramble.unscrambled.stacktrace.tab=<堆栈跟踪>
unscramble.unscrambled.threaddump.tab=<线程>
unscramble.unscrambler.combobox=译码器(&S):
unscramble.use.unscrambler.checkbox=译码堆栈跟踪(&U)
unwrap.anonymous=开启 'anonymous...'
unwrap.array.initializer=解包数组初始值设定项
unwrap.conditional=开启 'f ? a : b'
unwrap.lambda=取消 'lambda...' 换行
unwrap.synchronized=解开 'synchronized…'
unwrap.switch.expression=解开 'switch' 表达式
unwrap.switch.statement=解开 'switch' 语句
usage.target.exception=异常
usage.target.package.in.directory={0} (在 {1} 中)
use.external.annotations=使用外部注解 (&E)
wrapping.annotation.parameters=注解形参
wrapping.record.components=记录组件
wrapping.text.blocks=文本块
wrong.package.statement=错误的 package 语句
title.code.vision=Code Vision
highlight.throws.popup.throwing.places=引发 {0} 的位置
highlight.throws.popup.usages={0} 的用法
psi.error.incorrect.class.template.message=无法创建{0} - {1}模板不正确。
presentable.text.anonymous.class=匿名类
presentable.text.code.from.context=来自 {0} 的代码
presentable.text.code.display=代码
presentable.text.invalid.element.name=无效
inspection.simplify.for.each.replace=替换为 {0}
inspection.simplify.for.each.extract.intermediate.operations=提取中间操作
inspection.message.can.be.replaced.with.files.writestring=可被替换为 'Files.writeString()'
inspection.notnull.field.not.initialized.message=必须初始化 {0} 字段
highlight.throws.class.name=高亮显示 Throws {0}
class.patterns.panel.add.class=添加类
multiple.usages.of.static.import.found=已找到静态导入的多个用法
external.annotations.roots=注解根
inspection.stream.api.migration.can.be.replaced.with.call=可被替换为 ''{0}'' 调用
highlight.suppressed.warnings.choose.inspections=选择检查以高亮显示此项中的已禁止问题
inspection.magic.constants.should.be.one.of.values=应当为以下之一: {0}{1,choice,0#|1#或其组合}
live.template.context.consumer.function=使用者函数
live.template.context.statement=语句
live.template.context.expression=表达式
live.template.context.declaration=声明
inspection.unused.display.name=未使用的声明
inspection.empty.method.display.name=空方法
inspection.unused.assignment.display.name=未使用的赋值
inspection.unchecked.warning.display.name=未检查的警告
inspection.convert.2.streamapi.display.name=可以通过 Stream API 收起循环
inspection.optional.to.if.display.name='Optional' 可被替换为 'if' 语句序列
inspection.stream.to.loop.display.name=Stream API 调用链可被替换为循环
inspection.anonymous.2.method.ref.display.name=匿名类型可被替换为方法引用
inspection.convert.2.method.ref.display.name=lambda 可被替换为方法引用
inspection.lambda.can.be.method.call.display.name=lambda 可被替换为方法调用
inspection.functional.expression.can.be.folded.display.name=函数表达式可以折叠
inspection.trivial.functional.expression.usage.display.name=函数表达式的普通用法
inspection.magic.constant.display.name=魔术常量
inspection.static.pseudo.functional.style.method.display.name=使用 static 类的伪函数表达式
inspection.static.pseudo.functional.style.table.label=转换为 'Stream' API 的 static 方法调用:
inspection.overwritten.key.display.name=被覆盖的 Map、Set 或数组元素
inspection.collection.add.all.can.be.replaced.with.constructor.display.name=冗余的 'Collection.addAll()' 调用
inspection.manual.min.max.calculation.display.name=手动最小值/最大值计算
inspection.explicit.array.filling.display.name=显式数组填充
inspection.java.8.collection.remove.if.display.name=循环可被替换为 'Collection.removeIf()'
inspection.java.8.map.api.display.name=可简化的 'Map' 运算
inspection.string.repeat.can.be.used.display.name=可以使用 String.repeat()
inspection.read.write.string.can.be.used.display.name=可以使用 'Files.readString()' 或 'Files.writeString()'
inspection.java.9.collection.factory.display.name=不可变集合创建可被替换为集合工厂调用
inspection.explicit.argument.can.be.lambda.display.name=显式实参可以是 lambda
inspection.excessive.lambda.usage.display.name=过度使用 lambda
inspection.redundant.stream.optional.call.display.name='Stream' 或 'Optional' 调用链中存在冗余步骤
inspection.obvious.null.check.display.name=使用明显非空实参调用 null 检查方法
inspection.simplify.stream.api.call.chains.display.name=可以简化 Stream API 调用链
inspection.simplify.optional.call.chains.display.name=可以简化 Optional 调用链
inspection.simplify.collector.display.name=可简化的收集器
inspection.use.bulk.operation.display.name=可以使用批量操作代替迭代
inspection.comparator.combinators.display.name=可以使用 'Comparator' 连结符
inspection.replace.inefficient.stream.count.display.name=以 count() 结尾的低效 Stream API 调用链
inspection.redundant.lambda.parameter.type.display.name=冗余 lambda 形参类型
inspection.wrapper.type.may.be.primitive.display.name=包装器类型可能是基元
inspection.optional.get.without.is.present.display.name=在不进行 isPresent() 检查的情况下调用 Optional.get()
inspection.optional.is.present.display.name=非函数样式 'Optional.isPresent()' 用法
inspection.conditional.can.be.optional.display.name=条件可被替换为 Optional
inspection.optional.assigned.to.null.display.name=Optional 类型的 null 值
inspection.excessive.range.check.display.name=过度范围检查
inspection.condition.covered.by.further.condition.display.name=条件由进一步的条件覆盖
inspection.move.field.assignment.to.initializer.display.name=字段赋值可以移动到初始值设定项中
inspection.frequently.used.inheritor.inspection.display.name=类可以扩展常用的基类
inspection.slow.abstract.set.remove.all.description=调用 'set.removeAll(list)' 可能较为缓慢
inspection.slow.abstract.set.remove.all.fix.family.name=使用 'Set.remove' 而不是 'Set.removeAll'
slice.filter.parse.error.null.filter.not.applicable.for.primitive.type=''null'' 筛选器不适用于基元类型 {0}
slice.filter.parse.error.not.null.filter.not.applicable.for.primitive.type=''!null'' 筛选器不适用于基元类型 {0}
slice.filter.parse.error.enum.constant.not.found=找不到枚举常量: {0}
slice.filter.parse.error.incorrect.expression=表达式不正确: {0}
slice.filter.parse.error.incorrect.constant.type=常量类型不正确(要求: {0})
slice.filter.parse.error.expression.must.evaluate.to.constant=表达式必须评估为常量: {0}
slice.filter.parse.error.incorrect.constant.expected.number=常量不正确(应为数字): {0}
action.dfa.from.stacktrace.text=查找 ''{0}'' 可以是 {1} 的原因
slice.usage.message.assertion.violated=(违反断言!)
slice.usage.message.in.file.stopped.here=(在 {0} 文件中 - 在此处停止)
slice.usage.message.tracking.container.contents=(正在跟踪容器 ''{0}{1}'' 内容)
slice.usage.message.location=({0} 中)
intention.name.move.into.if.branches=上移至 'if' 语句分支
intention.name.collapse.into.loop=收起到循环中
intention.family.name.make.sealed=密封类
intention.error.make.sealed.class.is.used.in.functional.expression=类用于函数表达式
intention.make.sealed.class.hint.title=使其密封
intention.error.make.sealed.class.has.anonymous.or.local.inheritors=部分继承者为匿名或局部
intention.error.make.sealed.class.different.packages=模块未命名，某些继承者位于不同的软件包中
intention.error.make.sealed.class.inheritors.not.in.java.file=有些继承者不在 Java 文件中
intention.error.make.sealed.class.different.modules=有些继承者位于不同模块中
intention.error.make.sealed.class.interface.has.no.inheritors=接口没有继承者
intention.make.sealed.class.task.title.set.inheritors.modifiers=正在设置继承者修饰符
intention.family.name.move.member.into.class=将成员移至类
inspection.fill.permits.list.no.missing.inheritors=密封类没有缺失的继承者
inspection.fill.permits.list.display.name=密封类的 permits 子句中缺失同一文件子类
inspection.fill.permits.list.fix.name=将缺失的子类添加到 permits 子句
update.external.annotations=更新外部注解
intention.create.switch.statement=创建 switch 语句
sort.threads.by.type=按类型对线程排序
sort.threads.by.name=按名称对线程排序
inspection.message.record.can.be.converted.to.class=记录可以转换为类
intention.family.name.convert.record.to.class=将记录转换为类
class.can.be.record.display.name=类可以为记录
class.can.be.record.quick.fix=转换为记录
class.can.be.record.suggest.renaming.accessors=建议重命名 get/is 访问器
class.can.be.record.conversion.strategy.do.not.convert=不建议转换
class.can.be.record.conversion.strategy.show.members=在冲突视图中显示受影响的成员
class.can.be.record.conversion.strategy.convert.silently=无提示转换
extracted.class.should.have.unique.name=已提取类应具有唯一名称。已有一个内部类使用名称 ''{0}''
invalid.extracted.class.name=''{0}'' 是无效的已提取类名
caller.chooser.referenced.code.title=引用代码
dialog.title.choose.annotation=选择 {0} 注解
unchecked.warning.inspection.settings.ignore.unchecked.assignment=忽略未检查的赋值
unchecked.warning.inspection.settings.ignore.unchecked.generics.array.creation.for.vararg.parameter=忽略 vararg 形参的未检查的泛型数组创建
unchecked.warning.inspection.settings.ignore.unchecked.call.as.member.of.raw.type=忽略作为原始类型成员的未检查的调用
unchecked.warning.inspection.settings.ignore.unchecked.cast=忽略未检查的转换
unchecked.warning.inspection.settings.ignore.unchecked.overriding=忽略未检查的重写
unchecked.warning.inspection.reason.expr.has.raw.type.so.result.erased=。原因: ''{0}'' 具有原始类型，因此消除了 {1} 的结果
unchecked.warning.inspection.message.unchecked.generics.array.creation.for.varargs.parameter=vararg 形参的未检查的泛型数组创建
type.migration.dialog.message.invalid.type=''{0}'' 是无效类型
type.migration.dialog.message.void.not.applicable='void' 不可用
stream.to.loop.inspection.message.replace.stream.api.chain.with.loop=将 Stream API 链替换为循环
stream.to.loop.inspection.message.replace.foreach.call.with.loop=将 'forEach()' 调用替换为循环
todo.index.not.available=不适用
simplify.stream.inspection.message.can.be.replaced=''{0}'' 可被替换为 ''{1}''
simplify.stream.inspection.message.can.be.replaced.may.change.semantics=''{0}'' 可被替换为 ''{1}'' (可能会改变语义)
inspection.message.filter.is.present.chain.can.be.replaced.with.anymatch=''filter().{0}().isPresent()'' 链可被替换为 ''anyMatch()''
simplify.stream.match.negation.fix.name=将 {0} 替换为 {1}(…)
simplify.stream.collection.creation.fix.name=替换为 ''{0}'' 构造函数
simplify.stream.simple.stream.of.fix.name.use.stream.element.explicitly=显式使用 Stream 元素
simplify.stream.simple.stream.of.message=不必要的单元素 Stream
simplify.stream.replace.with.element.iteration.fix.message=可被替换为元素迭代
simplify.stream.remove.boolean.identity.fix.name=与上一个 'map()' 调用合并
simplify.stream.remove.boolean.identity.fix.message=可以与上一个 'map()' 调用合并
simplify.stream.replace.support.with.collection.fix.name=替换为 ''{0}.{1}()'' 调用
simplify.stream.replace.support.with.collection.fix.message=可被替换为 ''{0}.{1}()'' 调用
simplify.stream.swap.filter.and.map.fix.name=交换 'filter()' 和 'map()'
simplify.stream.swap.filter.and.map.fix.message=可以交换 'filter()' 和 'map()'
simplify.stream.inspection.iterate.take.while.fix.name=替换为三实参 'iterate()'
simplify.stream.inspection.iterate.take.while.fix.message=可被替换为三实参 'iterate()'
side.effects.pattern.message=<html>\n<body>\n{0} 中可能存在副作用<br>\n您可以:\n<br>\n-\\&nbsp;<b>移除</b>变量用法以及所有涉及的表达式，或<br>\n-\\&nbsp;<b>自行将分配到变量的表达式转换</b>到语句中。<br>\n<div style="padding-left: 0.6cm;">\n  即<br>\n  <table border="0">\n    <tr>\n      <td><code>{1};</code></td>\n    </tr>\n  </table>\n  成为: <br>\n  <table border="0">\n    <tr>\n      <td><code>{2};</code></td>\n    </tr>\n  </table>\n</div>\n</body>\n</html>
side.effects.non.fixable.message=<html><body>  表达式 ''{0}'' 中可能存在副作用<br>您可以<b>移除</b>类引用以及涉及的全部表达式</body></html>
side.effects.expression.presentation=表达式 ''{0}''
change.signature.from.usage.short.name=<html> 更改 {0}({1}) 的签名</html>
default.param.value.warning=具有所选签名的{0, choice, 0#构造函数|1#方法}已存在
qualify.static.constant.access=限定 static 常量访问
qualify.static.access.command.name=限定 static 访问
qualify.static.call.fix.text=限定 static 调用
side.effects.expressions.assigned.to.the.variable=分配到变量 ''{0}'' 的表达式
pull.members.up.fix.name=将成员上移
extract.superclass.command.name=提取超类
extract.interface.command.name=提取接口
choose.super.class.popup.title=选择超类
intention.name.pull.method.up.and.make.it.abstract.conditionally=将方法 ''{0}'' 拉取到 ''{1}''{2, choice, 0#并将其设为 abstract|1#}
intention.name.extract.method.to.new.interface=将方法 ''{0}'' 提取到新接口
intention.name.pull.method.up.make.it.abstract=向上拉取方法 ''{0}'' 并使其抽象
intention.name.pull.method.up=向上拉取方法 ''{0}''
intention.name.copy.to.final.temp.variable=复制''{0}'' {1, choice, 0#|1#effectively }final 临时变量
intention.name.make.variable.final=将 {1, choice, 0#''''{0}''''|1#变量} 设为 final
intention.name.transform.variables.into.final.one.element.array=将 {1, choice, 0#''''{0}''''|1#变量} 转换成 final 单元素数组
type.information.value=值
type.information.not.equal.to=不等于
type.information.range=范围
type.information.nullability=可 null 性
type.information.constraints=约束
type.information.mutability=可变性
type.information.locality=本地性
type.information.local.object=本地对象
type.information.type=类型
simplify.optional.chain.inspection.remove.redundant.steps.from.optional.chain=从可选链中移除冗余步骤
simplify.optional.chain.inspection.to.x=将可选链简化为 ''{0}''
simplify.optional.chain.inspection.map.or.else.description=Optional 链可以简化
simplify.optional.chain.inspection.optional.rewrapping.name=解开
simplify.optional.chain.inspection.optional.rewrapping.description=不必要的 Optional 重新包装
simplify.optional.chain.inspection.or.else.return.fix.name=将 null 检查替换为 {0}({1})
simplify.optional.chain.inspection.or.else.return.fix.description=null 检查可被消除
simplify.optional.chain.inspection.or.else.non.null.fix.name=将 null 检查替换为 ifPresent()
simplify.optional.chain.inspection.or.else.non.null.fix.description=null 检查可被 'ifPresent' 消除
generate.test.support.method.error.no.template.found.for.framework=没有找到 {0} 的模板: {1}
generate.test.support.method.error.method.already.exists=方法 {0} 已存在
generate.test.support.method.error.cannot.generate.method=无法生成方法: {0}
base.package.project.wizard.error.x.not.valid.package={0} 不是有效的软件包名称
class.patterns.separator.mark.code.as.entry.point.if.qualified.name.matches=如果限定名称匹配，则将代码标记为入口点
class.patterns.error.method.pattern.0.must.be.a.valid.java.identifier=方法模式 ''{0}'' 必须是有效的 java 标识符，仅接受 ''*'' 作为占位符
class.patterns.error.class.pattern.0.must.be.a.valid.java.qualifier=模式必须是有效的 java 限定名称，仅接受 '*' 作为占位符
code.style.generation.settings.error.not.valid.identifier.part.in.prefix=在前缀 ''{0}'' 中不是有效的 java 标识符部分
code.style.generation.settings.error.not.valid.identifier.part.in.suffix=在后缀 ''{0}'' 中不是有效的 java 标识符部分
hide.out.of.cyclic.packages.action.text=隐藏没有循环依赖的软件包
hide.out.of.cyclic.packages.action.description=隐藏没有循环依赖的软件包
generate.missed.tests.action.error.no.tests.found=找不到测试。
generate.missed.tests.action.failed.to.detect.framework=无法检测到 {0} 的测试框架
pull.up.accessible.conflict={0} 无法访问
pull.up.accessible.conflict.1=无法从 {1} 访问 {0}
pull.up.concrete.inherit.abstract.method.conflict=具体的 ''{0}'' 将继承一个新的抽象方法
pull.up.members.usage.view.description.code.references.node=将成员向上拉取到“{0}”的类
pull.up.members.usage.view.description.processed.elements.node=从类 {0} 上移成员
refactoring.method.reference.to.lambda.conflict=方法引用将转换为 lambda
introduce.variable.change.semantics.warning=提取所选表达式将改变整个表达式的语义。
introduce.variable.change.type.adv=按 {0} 更改类型
introduce.variable.reassign.adv=按 {0} 重新分配现有变量
introduce.functional.variable.accessibility.conflict=变量 {0} 不是有效的 final 变量，无法在函数表达式中访问
introduce.functional.variable.interface.chooser.title=选择适用的函数接口: {0} -> {1}
introduce.functional.variable.nothing.found.message=找不到适用的函数接口
introduce.parameter.object.no.accessor.conflict.message=字段 ''{1}'' 需要 {0, choice, 0#Getter|1#Setter}
push.down.anonymous.conflict=无法将实现推送到匿名类
push.down.static.nonstatic.conflict=static {0} 无法推送到非 static {1}
push.down.missed.implementation.conflict=非抽象 {0} 将错过 {1} 的实现
push.down.super.method.call.changed.conflict=super 方法调用将解析为另一种方法
move.classes.invalid.destination.package.name.message=''{0}'' 是无效的目标软件包名称
move.classes.destination.class.not.found.message=未找到目标类
move.class.import.from.default.package.conflict=无法从默认软件包访问 {0}
destination.combo.test.root.not.expected.conflict=应为源根，但选择了测试根
destination.combo.source.root.not.expected.conflict=应为测试根，但选择了源根
leave.in.same.source.root.item=留在同一源根中
move.inner.select.target.package.title=选择目标软件包
move.member.enum.conflict=枚举类型不适用于当前上下文
move.member.final.initializer.conflict=移动后，final 变量初始值设定项将不可用。
rename.package.invalid.name.error=不是有效的软件包名称
rename.package.ignored.name.warning=正在尝试创建具有忽略名称的软件包，结果将不可见
rename.package.class.already.exist.conflict=具有限定名称 ''{0}''  的类已存在
rename.package.command.name=重命名软件包
class.filter.editor.table.model.column.name.pattern=模式
class.filter.editor.table.model.column.name.isActive=活跃
create.class.mapping.dialog.title=选择 {0} 类
import.layout.panel.up.button=上
import.layout.panel.down.button=下
import.layout.panel.blank.line.entry=<空行>
import.layout.panel.all.other.imports=所有其他导入
edit.contract.dialog.hint=<html>请指定约定文本<p>示例: <code>_, null -> false</code><br><small>请参阅意图操作描述了解详细信息</small></html>
edit.range.dialog.message=<html>请指定值范围<p>如果不受限制，将 'from' 或 'to' 留空</html>
edit.range.error.invalid.value=无效值
edit.range.value.should.be.less.than=不应小于 {0}
edit.range.value.should.be.bigger.than=不应大于 {0}
edit.range.should.not.be.less.than.from=不应小于 'from'
generate.constructor.already.exists=构造函数已存在
generate.equals.no.fields.for.generation=找不到要包含在 equals/hashCode 中的字段
generate.getter.and.setter.error.setters.for.read.only.not.generated=未生成只读字段的 setter
generate.getter.and.setter.error.no.fields=找不到要为之生成 getter/setter 的字段
generate.getter.and.setter.error.no.fields.without.getters.and.setters=找不到没有 getter/setter 的字段
generate.getter.error.no.fields=找不到要为之生成 getter 的字段
generate.getter.error.no.fields.without.getters=找不到没有 getter 的字段
generate.getter.setter.header.visibility.hint.=根据“文件 | 设置 | 编辑器 | 代码样式 | Java | 代码生成“应用可见性
generate.members.nothing.to.insert=未找到要插入的内容
generate.setters.no.fields=找不到要为之生成 setter 的字段
generate.setters.no.fields.without.setters=找不到没有 setter 的字段
implement.abstract.method.potential.implementations.with.weaker.access=找到具有较弱访问权限的潜在实现: {0}
implement.method.no.methods.to.implement=找不到要实现的方法
action.sort.by.percent.classes.which.overrides.method.text=按重写方法的类百分比排序
action.sort.by.percent.classes.which.overrides.method.description=按重写方法的类百分比排序
override.methods.error.no.methods=找不到要重写的方法
base.package.parameter.wizard.label=基础软件包(&P):
type.migration.multi.root.toolwindow.title=迁移 {0} 的类型
type.migration.single.root.toolwindow.title=将 {0} 的类型从 ''{1}'' 迁移到 ''{2}''
type.migration.processed.elements.header=类型迁移的根
type.migration.cannon.convert.tooltip=无法将类型 <b>{0}</b> 的表达式{3, choice, 0#|1# 从 '<'b'>'{1}'<'/b'>' 转换为 '<'b'>'{2}'<'/b'>'}<br>
type.migration.replaced.notification=替换为 {0}
type.migration.cannot.convert.tooltip=无法将表达式的类型从 {0} 转换为 {1}
type.migration.getter.rename.suggestion.text=由于返回类型已迁移到 ''{2}''，getter 名称是否从 ''{0}'' 迁移到 ''{1}''?
type.migration.getter.rename.suggestion.never.migrate.method.names=从不迁移方法名称
type.migration.getter.rename.suggestion.always.migrate.method.names=始终迁移方法名称
hint.text.press.to.go.through.inlined.occurrences=按 {0} 遍历 {1} 个已内联匹配项
hint.text.occurrences.were.inlined={0} 个匹配项已内联
action.expand.static.import.text=展开静态导入
class.cannot.be.inlined.because.a.call.to.its.constructor.is.unresolved=无法内联类，因为其构造函数的调用未解析
class.cannot.be.inlined.because.it.is.used.as.a.this.qualifier=无法内联类，因为其用作 'this' 限定符
class.cannot.be.inlined.because.it.is.used.in.a.throws.clause=无法内联类，因为其用于 'throws' 子句
class.cannot.be.inlined.because.it.is.used.in.a.catch.clause=无法内联类，因为其用于 'catch' 子句
class.cannot.be.inlined.because.it.has.usages.of.its.class.literal=无法内联类，因为其具有自身类文字的用法
class.cannot.be.inlined.because.it.has.static.initializers=无法内联类，因为其具有 static 初始值设定项
class.cannot.be.inlined.because.it.has.usages.of.fields.not.inherited.from.its.superclass=无法内联类，因为其具有未从自身超类继承的字段的用法
class.cannot.be.inlined.because.it.has.static.fields.with.non.constant.initializers=无法内联类，因为其具有带非常量初始值设定项的 static 字段
class.cannot.be.inlined.because.it.has.static.non.final.fields=无法内联类，因为其具有 static 非 final 字段
class.cannot.be.inlined.because.it.has.usages.of.its.inner.classes=无法内联类，因为其具有自身内部类的用法
class.cannot.be.inlined.because.it.has.static.inner.classes=无法内联类，因为其具有 static 内部类
class.cannot.be.inlined.because.it.has.static.methods=无法内联类，因为其具有 static 方法
class.cannot.be.inlined.because.there.are.usages.of.its.methods.not.inherited.from.its.superclass.or.interface=无法内联类，因为其方法的部分用法并非继承自其超类或接口
class.cannot.be.inlined.because.its.constructor.contains.return.statements=无法内联类，因为其构造函数包含 'return' 语句
class.cannot.be.inlined.because.an.interface.implemented.by.it.cannot.be.resolved=无法内联类，因为无法解析其实现的一个接口
class.cannot.be.inlined.because.its.superclass.cannot.be.resolved=无法内联类，因为无法解析其超类
library.classes.cannot.be.inlined=库类无法内联
enums.cannot.be.inlined=枚举无法内联
interfaces.cannot.be.inlined=接口无法内联
annotation.types.cannot.be.inlined=注解类型无法内联
type.parameters.cannot.be.inlined=类型形参无法内联
postfix.template.editor.choose.class.title=选择类
null.check.surrounder.description=if (expr != null) {…}
push.method.down.command.name=向下推送方法…
replace.implements.with.static.import.field.usages.progress=查找常量字段用法…
show.siblings.choose.super.class.title=选择超类或接口
show.siblings.find.usages.method.title=super 方法
show.siblings.find.usages.class.title=超类/接口
switch.stmt.template.description=switch (expr) {…}
wrap.return.value.created.class.not.accessible.conflict=创建的类将无法在调用位置访问
wrap.return.value.existing.class.does.not.have.getter.conflict=现有类没有所选字段的 getter
wrap.return.value.existing.class.does.not.have.appropriate.constructor.conflict=现有类没有适当的构造函数
wrap.return.value.anonymous.class.presentation=匿名 {0}
empty.title=空
separator.annotations.to.copy=要复制的注解
action.go.to.implementation.text=转到实现
action.go.to.subclass.text=转到子类
action.go.to.overriding.methods.text=转到重写方法
action.go.to.super.method.text=转到 super 方法
tooltip.recursive.call=递归调用
label.compact.constructor=压缩构造函数
label.canonical.constructor=规范构造函数
edit.contract.dialog.checkbox.pure.method=方法为纯方法(没有副作用) (&P)
separator.mark.as.entry.point.if.annotated.by=如果已注解，则标记为入口点:
separator.mark.field.as.implicitly.written.if.annotated.by=如果已注解，则将字段标记为隐式写入:
rename.super.methods.chooser.popup.title={0} 具有 super 方法
rename.super.base.chooser.popup.title={0} {1, choice, 0#实现|1#重写} {2} 的方法
add.methods.dialog.or=\ 或
command.name.delegate.detected.change=委托
encapsulate.fields.dialog.javadoc.title=Javadoc
find.jar.hint.text.no.libraries.found.for.fqn=未找到 ''{0}'' 的库
dependant.sdk.unsatisfied.dependency.message=需要先配置 Java SDK
javadoc.gen.error.modules.without.module.info=IDEA 无法生成 Javadoc，因为模块 {0} 不含 module-info.java 文件
javadoc.gen.error.module.source.path.is.not.evaluated=IDEA 无法生成 Javadoc，因为无法评估 module-source-path
generate.members.implement.command=实现
code.style.settings.angle.spacing.brackets=尖括号
code.style.settings.spacing.after.closing.angle.bracket=右尖括号之后
code.style.settings.spacing.around.type.bounds=类型界限周围
non.code.annotations.explanation.external.and.inferred.available=外部和<i>推断</i>注解可用。
non.code.annotations.explanation.external.available=外部注解可用。
non.code.annotations.explanation.inferred.available=<i>推断</i>注解可用。
non.code.annotations.explanation.full.signature=完整签名:
type.migration.command.name=TypeMigration
dfa.constraint.not.null=非 null
dfa.constraint.0.not.null={0}(非 null)
dfa.constraint.null.or.0=null 或 {0}
label.class.pattern.syntax.explanation=将此方法留空以表示构造函数\n任何 * 将匹配限定名称中的一个或多个字符(包括点)
dialog.message.modules.dont.refer.to.existing.annotations.library={0, choice, 0#模块|2#模块}{1}{0, choice, 0#不|2#不}引用具有 IntelliJ IDEA 可空性注解的 ''{2}'' 库。是否要立即添加{0, choice, 0#依赖项|2#依赖项}?
tab.title.slices.grouped.by.nullness=\ (按可空性分组)
exclude.0.from.auto.import=从自动导入中排除 ''{0}''
column.name.method.entry.point=方法
column.name.class.entry.point=类
column.name.with.subclasses.entry.point=包含子类
code.vision.implementations.hint={0, choice, 1#1 个实现|2#{0,number} 个实现}
code.vision.inheritors.hint={0, choice, 1#1 个继承者|2#{0,number} 个继承者}
code.vision.overrides.hint={0, choice, 1#1 个重写|2#{0,number} 个重写}
hint.text.tostring.method.could.not.be.created.from.template=无法从模板 ''{0}'' 创建 ''toString()'' 方法
hint.text.tostring.template.invalid=toString() 模板 ''{0}'' 无效
command.name.generate.tostring=生成 toString()
column.name.ignore.suppressions=忽略禁止
ignored.suppressions=已忽略禁止:
hint.text.removed.imports=已移除 {0} 个{1, choice, 0#导入|1#导入}
hint.text.added.imports=，已添加 {0} 个{1, choice, 0#导入|1#导入}
hint.text.rearranged.imports=已重新排列导入
enum.constant.ordinal=枚举常量序数: 
tab.title.infer.nullity.preview=推断可空性预览
inspection.message.full.description=完整描述
popup.title.debug.recent.tests=调试最近的测试
list.item.suite=[套件] {0}
list.item.configuration=[配置] {0}
no.jre.description=<无 JRE>
popup.content.tests.were.not.found.in.module.use.instead=改用{0, choice, 0#模块 {1} |1# \n{2} 之一\n}
postfix.template.provider.name=Java
postfix.template.condition.void.name=void
postfix.template.condition.non.void.name=非 void
postfix.template.condition.boolean.name=布尔
postfix.template.condition.number.name=数字
postfix.template.condition.not.primitive.type.name=非基元类型
postfix.template.condition.array.name=数组
inspection.redundant.unmodifiable.call.display.name=''{0}'' 包装器的冗余用法
inspection.redundant.unmodifiable.call.description=不可修改的集合包装器的冗余用法
inspection.redundant.unmodifiable.call.unwrap.argument.quickfix=解开实参
completion.override.implement.methods=重写/实现方法…
lambda.tree.node.presentation=Lambda
inspection.meaningless.record.annotation.description=无意义的记录注解
inspection.meaningless.record.annotation.message.method.and.parameter=注解不起任何作用: 它的目标是 METHOD 和 PARAMETER，但显式声明了访问器和规范构造函数
inspection.meaningless.record.annotation.message.method=注解不起任何作用: 它的目标是 METHOD，但显式声明了相应的访问器
inspection.meaningless.record.annotation.message.parameter=注解不起任何作用: 它的目标是 PARAMETER，但显式声明了规范构造函数
header.method.to.be.converted=要转换的方法
accessible.name.change.modifier=更改修饰符
usages.telescope={0,choice, 0#0 个用法|1#1 个用法|2#{0,number} 个用法}
press.to.navigate=按 {0} 导航
label.jvm.method.name=JVM 方法名称
link.configure.classes.excluded.from.completion=配置从补全中排除的类
inspection.preview.feature.0.is.preview.api.message={0} 是预览 API，可能会在将来的版本中移除
progress.title.detect.overridden.methods=检查重写方法
intention.name.iterate.over=迭代 {0}
advanced.settings.group.compiler=编译器
advanced.setting.compiler.automake.allow.when.app.running=即使开发的应用程序当前正在运行，也允许自动 make 启动
advanced.setting.compiler.automake.allow.when.app.running.description=自动启动 make 最终可能会删除该应用程序所需的一些类。

dialog.title.check.functional.interface.candidates=检查功能接口候选项…
scheduled.thread.pool.executor.with.zero.core.threads.display.name=带零个核心线程的 'ScheduledThreadPoolExecutor'
scheduled.thread.pool.executor.with.zero.core.threads.description='ScheduledThreadPoolExecutor' 不应具有零个核心线程
popup.content.tests.were.not.found.in.module=在模块 ''{0}'' 中找不到测试。
popup.content.tests.were.not.found.in.module.search.in.dependencies=改为在模块依赖项中搜索
find.options.include.accessors.checkbox=搜索访问器(&A)
find.options.include.accessors.base.checkbox=搜索访问器的基方法(&E)
find.options.include.accessors.base.checkbox.comment=默认使用顶层层次结构方法作为查找用法目标
find.options.search.overriding.methods.checkbox=在重写方法中搜索(&O)
find.what.search.for.base.methods.checkbox=搜索基方法用法(&E)
find.what.search.for.base.methods.checkbox.comment=默认使用顶层层次结构方法作为查找用法目标
popup.title.select.target.code.block=选择目标代码块
target.code.block.presentable.text=包含块
conflict.message.method.will.override.method.base.class=重命名的 {0} 将重写基 {1} 的方法
progress.title.looking.for.jdk=正在查找 JDK…
intention.category.collections=Java/集合
intention.category.conditional.operator=Java/条件运算符
intention.category.i18n=Java/I18N
dialog.title.check.configuration=检查配置…
dialog.message.template.not.found=找不到模板
dialog.message.template.not.applicable=模板不适用
dialog.message.class.not.found=找不到模板类 ''{0}''
notification.content.was.set.up=已为项目设置了 JDK ''{0}''
notification.content.change.jdk=更改 JDK
nullable.notnull.annotation.used.label=用于生成代码的注解:
button.to.another.directory=到目录(&D)
button.to.another.source.root=到源根(&S)
where.do.you.want.to.move.directory.prompt={0}\n\n要将目录移动到另一个源根还是另一个目录?
loading.additional.annotations=正在加载其他注解…
tooltip.anonymous=匿名
tooltip.has.several.functional.implementations=有多个函数实现
tooltip.implements.method=实现方法
tooltip.in=位置
tooltip.is.functionally.implemented.in=函数实现位置:
tooltip.is.implemented.by=实现对象:
tooltip.is.implemented.by.several.subclasses=由多个子类实现
tooltip.is.implemented.in=在以下位置实现:
tooltip.is.implemented.in.several.subclasses=在多个子类中实现
tooltip.is.overridden.by.several.subclasses=被多个子类重写
tooltip.is.overridden.in=在以下位置被重写:
tooltip.is.overridden.in.several.subclasses=在多个子类中被重写
tooltip.is.subclassed.by=被以下对象子类化
tooltip.overrides.method=重写方法
tooltip.via.subclass=通过子类
label.ignore.complicated.fix=当内联形参初始值设定项不成功时忽略
tooltip.implements.method.in=在以下位置实现方法:
tooltip.overrides.method.in=在以下位置重写方法:
progress.title.calculate.applicable.types=计算适用类型…
completion.inner.scope.tail.text=(来自 {0} 块)
completion.inner.scope=内部
javadoc.documentation.url.checked=已检查以下文档 {0, choice, 1#URL|2#URL}:
javadoc.edit.api.docs.paths=编辑 API 文档路径
inspection.unused.symbol.check.parameters.excluding.hierarchy=排除层次结构
tooltip.reassigned.local.variable=重新分配的局部变量
tooltip.reassigned.parameter=重新指定的形参
javadoc.generate.options.separator=JavaDoc 选项
simplify.optional.chain.inspection.fix.name.remove.redundant.optional.chain=移除冗余的 Optional 链
simplify.optional.chain.inspection.fix.description.optional.chain.can.be.eliminated=Optional 链可被消除
inspection.optional.get.without.is.present.method.reference.message=<code>#ref</code> 未进行 'isPresent()' 检查
inlay.parameters.java.method.name.contains.parameter.name=从方法名中清除预期实参时接受单个实参的方法，如访问器方法。
inlay.parameters.java.multiple.params.same.type=对具有同一类型的多个非文字实参的方法的调用。
inlay.parameters.java.build.like.method=返回方法本身操作的类的实例的方法，例如，StringBuilder 链中的调用或 Java 8 Stream API 中的中间操作。
inlay.parameters.java.simple.sequentially.numbered=接受多个形参的方法，这些形参的名称由一个字母后跟一个数字组成。
inlay.parameters.java.enums=使用形参化构造函数的枚举常量声明。
inlay.parameters.java.new.expr=对形参化构造函数的调用。
inlay.parameters.java.clear.expression.type=使用复杂表达式作为实参的方法调用，例如，三元运算符或 Java 13 switch 语句。
add.to.permits.list.family.name=将类添加到 permits 列表
raw.variable.type.can.be.generic.cast.quickfix=将转换类型更改为 {0}
raw.variable.type.can.be.generic.cast.quickfix.family=形参化转换类型
inlay.MethodChainsInlayProvider.description=调用链中的方法返回类型。
intention.family.name.move.class.to.test.root=将类移至测试根
intention.name.move.class.to.test.root=将 ''{0}'' 移至测试根
inlay.annotation.hints.inferred.annotations=IntelliJ IDEA 通过扫描库和项目代码生成的注解。这些注解可以帮助您理解代码协定，并提高静态分析的能力。注解包括: <br> @Contract <br> @Nullable <br> @NotNull <br> @Unmodifiable <br>@UnmodifiableView <br><br><a href='https://www.jetbrains.com/help/idea/inferring-nullity.html#inferred-annotations'>文档</a>
inlay.annotation.hints.external.annotations=存储在源代码外部的注解。<br>当您需要注解时，这些注解会很有用，但不能将其添加到源代码(例如，在使用库代码时)。<br><br><a href='https://www.jetbrains.com/help/idea/external-annotations.html'>文档</a>
title.related.problems.inlay.hints=相关问题
title.code.vision.inlay.hints=Code Vision
javadoc.generate.scope.row=可见性级别:
javadoc.generate.ok=生成
javadoc.generate.validation.error=指定输出目录。
megabytes.unit=MB
java.platform.module.system.name=Java 平台模块系统
simplify.optional.chain.inspection.fix.description.replace.with.value.of.name=替换为 'String.valueOf()'
simplify.optional.chain.inspection.fix.description.replace.with.value.of.description=Optional 链可被替换为 'String.valueOf()'
dialog.title.move.directory=移动目录
progress.title.checking.if.class.exists=检查目标类 ''{0}'' 是否存在
wrapping.multi.catch.types=多 catch 中的类型
align.types.in.multi.catch=在多 catch 中对齐类型
quickfix.find.cause.description=尝试高亮显示导致此警告的代码元素，并解释它们的确切作用。
completion.generate.via.wizard=(通过向导生成)
inspection.slow.list.contains.all.description=对 'list.containsAll(collection)' 的调用可能具有较差性能
inspection.slow.list.contains.all.fix.family.name=包装在 'HashSet' 构造函数中
inspection.slow.list.contains.all.fix.name=将 ''{0}'' 包装在 ''HashSet'' 构造函数中
checkbox.spaces.around.annotation.eq=在注解值对的周围环绕 '='
live.template.context.else='else' 位置
inspection.javadoc.problem.snippet.tag.is.not.available='@snippet' 标记在此语言级别不可用
checkbox.don.t.warn.in.case.of.multiline.lambda=如果 'List.replaceAll()' 的形参为多行 lambda，则不发出警告
inspection.java.8.list.replace.all.display.name=循环可以替换为 'List.replaceAll()'
notification.group.jdk.resolve.problems=无法解析 JDK
notification.group.jshell=发生了JShell 问题
notification.group.repository=JAR 文件已与仓库同步
notification.group.source.searcher=找不到 JAR 文件的源
notification.group.language.level=预览 Java 语言级别需要接受许可证
notification.group.preview.features=预览 Java 语言级别可能会中断
notification.group.redundant.exports=可以移除冗余的导出/打开
notification.group.setup.sdk=JDK 已配置
external.annotations.problem.title=无法读取外部注解
external.annotations.problem.parse.error=文件: {0}<br>问题: {1}
external.annotations.open.file=打开注解文件
inspection.io.stream.constructor.description=可以使用 'Files' 方法构建 'InputStream' 和 'OutputStream'
inspection.input.stream.constructor.message=可以使用 'Files.newInputStream' 构建 'InputStream'
inspection.output.stream.constructor.message=可以使用 'Files.newOutputStream' 构建 'OutputStream'
popup.title.effective.visibility=有效可见性
introduce.parameter.inlay.title.delegate=代理
introduce.parameter.inlay.tooltip.delegate=通过重载方法委托
introduce.parameter.advertisement.text=按 {0} 通过重载方法进行委托，或按 {1} 显示更多选项
intention.family.name.set.explicit.variable.type=设置显式变量类型
intention.name.set.variable.type=将变量类型设置为 ''{0}''
notification.group.setup.external.annotations=加载外部注解失败
inspection.bulk.file.attributes.read.description=可以使用批量 'Files.readAttributes' 调用，而不是多个文件特性调用
inspection.replace.with.bulk.file.attributes.read.fix.family.name=替换为批量 'Files.readAttributes' 调用
inspection.bulk.file.attributes.read.message=多个文件特性调用可以替换为单个 'Files.readAttributes' 调用
progress.title.collect.method.overriders=收集方法重写器...
settings.inlay.java.implicit.types.description=当推断的类型可能无法从赋值的右侧部分看清时(例如，使用工厂方法时)，使用 var 关键字声明的局部变量。
inspection.missingJavadoc.display.name=缺少 Javadoc
inspection.missingJavadoc.label.minimalVisibility=最小可见性:
inspection.missingJavadoc.label.requiredTags=必需标记:
inspection.javadocDeclaration.display.name=Javadoc 声明问题
unresolved.class.reference.repair.message=尝试解析类引用
remove.var.keyword.text=移除 'var'
javadoc.description.inferred.annotation.hint=i
intention.family.name.upgrade.jdk=升级 JDK
intention.name.upgrade.jdk.to=将 JDK 升级到 {0}+
inspection.javadoc.blank.lines.display.name=空行应替换为 <p> 以换行
inspection.javadoc.blank.lines.message=空白行将被忽略
inspection.javadoc.blank.lines.fix.name=插入 <p>
inspection.javadoc.blank.lines.fix.family.name=将空白行替换为 <p>
methods.to.override.generate.javadoc=生成缺失的 JavaDoc
inspection.javadoc.link.as.plain.text.display.name=指定为纯文本的链接
inspection.javadoc.link.as.plain.text.message=指定为纯文本的链接
class.can.be.record.suppress.conversion.if.annotated=如果类用以下项注解，则禁止转换:
class.can.be.record.suppress.conversion.if.annotated.fix.name=如果用 ''{0}'' 注解，则禁止记录转换
class.can.be.record.suppress.conversion.if.annotated.fix.family.name=禁止记录转换
class.can.be.record.conversion.make.member.more.accessible=当转换使成员更易于访问时:
advanced.setting.compiler.lower.process.priority=以较低优先级运行编译
advanced.setting.compiler.lower.process.priority.description=在 Windows 上以 IDLE 优先级运行外部 JPS 进程，在 Linux/MacOS 上以 nice 级别 10 运行
action.title.infer.nullity.annotations=推断可空性注解
intention.family.name.box.primitive.in.conditional.branch=装箱条件分支中的基元值
progress.title.detecting.jdk=正在检测 JDK
inspection.replace.javadoc.display.name=可用 Javadoc 替换的注释
inspection.replace.with.javadoc=替换为 Javadoc 注释
inspection.replace.with.javadoc.comment=可以将注释转换为 Javadoc
assignment.array.element.to.itself.problem.descriptor=数组元素被分配给自己
inspection.unused.parameter.delete.family=安全删除未使用的形参
inspection.unused.parameter.problem.descriptor=未使用形参 <code>#ref</code>
inspection.redundant.stream.optional.call.fix.bind.name=将 ''{0}()'' 步骤与前一个 ''{1}()'' 步骤合并
intention.category.annotations=Java/注解
intention.category.boolean=Java/布尔值
intention.category.comments=Java/注释
intention.category.concurrency=Java/并发
intention.category.control.flow=Java/控制流
intention.category.declaration=Java/声明
intention.category.imports=Java/导入
intention.category.junit=Java/JUnit
intention.category.other=Java/其他
intention.category.refactorings=Java/重构
intention.category.streams=Java/流
intention.category.strings=Java/字符串
intention.category.try.statements=Java/Try 语句
intention.category.code.style=Java/代码样式
intention.category.expressions=Java/表达式
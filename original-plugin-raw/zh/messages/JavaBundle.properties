abstract.class.not.allowed=不允许抽象类
access.static.via.instance=通过实例引用访问 static 成员
accessible.name.change.modifier=更改修饰符
action.GotoSuperClass.MainMenu.text=超类或接口(_U)
action.GotoSuperClass.description=导航到当前类扩展或实现的类的声明
action.GotoSuperClass.text=转到超类或接口(_U)
action.InsertAnnotationAction.text=插入注解
action.ToggleExternalAnnotationsAction.text=切换外部注解
action.ToggleInferredAnnotationsAction.text=切换推断的注解
action.analyzing.cyclic.dependencies.in.scope={0}的循环依赖
action.create.new.class=创建新的类
action.create.new.class.description=创建新 Java 类
action.create.new.compact.source.file=Java 压缩文件
action.create.new.compact.source.file.description=创建新的 java 压缩文件
action.create.new.module-info.description=创建新的 module-info.java
action.create.new.module-info.title=module-info.java
action.create.new.package-info.description=创建新的 package-info.java
action.create.new.package-info.title=package-info.java
action.cyclic.dependency.title=分析循环依赖
action.description.group.by.scope=按作用域类型(产品、测试、库)分组
action.description.infer.nullity.annotations=推断为 null 性注解
action.description.mark.directory.as.a.0.for.generated.files=为生成的文件将目录标记为{0}
action.description.mark.directory.as.an.ordinary.0=将目录标记为普通{0}
action.dfa.from.stacktrace.text=查找 ''{0}'' 可以是 {1} 的原因
action.expand.static.import.text=展开 static import
action.find.similar.stack.call.diverged=行号可能出现分叉。尝试在 ''{0}.{1}()'' 内查找当前位置
action.find.similar.stack.call.location.not.found=''{0}.{1}()'' 内没有类似的位置
action.find.similar.stack.call.methods=与 ''{0}.{1}()'' 类似的方法
action.find.similar.stack.call.methods.not.found=没有与 ''{0}.{1}()'' 类似的方法
action.find.similar.stack.call.similar.calls=''{0}.{1}()'' 内的可能位置
action.go.to.functional.implementation.text=查找函数式接口实现
action.go.to.implementation.text=转到实现
action.go.to.overriding.methods.text=转到重写方法
action.go.to.subclass.text=转到子类
action.go.to.super.method.text=转到 Super 方法
action.group.by.package=软件包
action.group.by.scope.type=按作用域类型分组
action.implement.method=实现方法
action.implement.methods=实现方法
action.override.method=重写方法
action.override.methods=重写方法
action.sort.by.percent.classes.which.overrides.method.description=按重写方法的子类的百分比排序
action.sort.by.percent.classes.which.overrides.method.text=按重写方法的子类的百分比排序
action.text.0.on.parameter.1=在形参 ''{1}'' 上{0}
action.text.choose.class.in.0=选择 {0} 中的类…
action.text.edit.template=编辑模板
action.text.enter.class.name=输入类名…
action.text.generated.root.0=生成的{0}
action.text.show.methods.to.implement=显示要实现的方法
action.text.unmark.generated.0=取消标记生成的{0}
action.title.infer.nullity.annotations=推断为 null 性注解
add.methods.dialog.or=\ 或
add.to.permits.list=将 ''{0}'' 添加到 sealed 类 ''{1}'' 的 permit 列表
add.to.permits.list.family.name=将类添加到 permits 列表
adds.ext.library.preview=将库 ''{0}'' 添加到模块 ''{1}''
adds.ext.library.preview.import=将库 ''{0}'' 添加到模块 ''{1}'' 的依赖项并根据需要导入 ''{2}''
adds.library.preview=将{0, choice, 1\#库“{1}”|2\#其中一个{2}}添加到模块 ''{3}'' 的依赖项并导入未解析的 ''{4}''
adds.library.preview.no.import=将{0, choice, 1\#库“{1}”|2\#其中一个{2}}添加到模块 ''{3}'' 的依赖项
adds.module.dependencies.preview=将{0, choice, 1\#模块 ''''{1}''''|2\#其中一个 {2}}添加到模块 ''{3}'' 的依赖项并根据需要导入未解析的类
advanced.setting.code.vision.java.minimal.usages=Code Vision\: 显示嵌入提示所需的最小用法数量
advanced.setting.compiler.automake.allow.when.app.running=即使开发的应用程序当前正在运行，也允许自动 make 启动
advanced.setting.compiler.automake.allow.when.app.running.description=自动启动 make 最终可能会删除该应用程序所需的一些类。
advanced.setting.compiler.inMemoryLogger=在构建失败时收集详细的调试日志报告
advanced.setting.compiler.inMemoryLogger.description=保存失败构建的详细日志，以协助调试和排查故障。日志与其他构建日志一起存储
advanced.setting.compiler.lower.process.priority=以较低优先级运行编译
advanced.setting.compiler.lower.process.priority.description=在 Windows 上以 IDLE 优先级运行外部 JPS 进程，在 Linux/MacOS 上以 nice 级别 10 运行
advanced.setting.compiler.unified.ic.implementation=启用统一的 Java/Kotlin 增量编译实现
advanced.setting.compiler.unified.ic.implementation.description=外部 JPS 进程将使用新的增量编译实现，该实现可以处理 Java 和 Kotlin 生成的字节码
advanced.setting.java.completion.qualifier.as.argument=启用对使用限定符作为第一个实参的 static 方法补全
advanced.setting.java.sdkmanrc.watcher=项目打开时开始侦听配置文件('.sdkmanrc'、'.tool-versions' 等)中的更改
advanced.setting.java.show.irrelevant.templates.in.source.roots=在 Java 源根中显示不相关的“新建文件”模板
advanced.settings.group.compiler=编译器
advanced.settings.group.java=Java
align.types.in.multi.catch=在多 catch 中对齐类型
annotate.intention.chooser.title=选择要添加的注解
annotation.types.cannot.be.inlined=注解类型无法内联
annotations.new.line.record.component=为注解添加新行
arch.checker.notification.content=JDK ''{0}'' ({1})与系统架构({2})不匹配。
arch.checker.notification.project.structure=配置 JDK
arch.checker.notification.title=所选 JDK 可能会导致构建缓慢
assignment.array.element.to.itself.problem.descriptor=数组元素被分配给自己
assignment.to.declared.variable.problem.descriptor=变量''{0}''是自我赋值初始化
assignment.to.itself.problem.descriptor=变量''{0}''是分配给自己
auto.static.import.class=类或 static 成员
auto.static.import.comment=添加一个类或类成员以包含在自动导入和补全中
auto.static.import.completion.group=在补全中包含 static 成员的自动导入\:
auto.static.import.example=示例\: 'java.util.Objects' 或 'java.util.Objects.requireNonNull'
auto.static.import.scope=作用域
base.package.parameter.wizard.label=基础软件包(&P)\:
base.package.project.wizard.error.x.not.valid.package={0} 不是有效的软件包名称
bean.property=Bean属性
boolean.method.is.always.inverted.display.name=布尔方法总是反向的
boolean.method.is.always.inverted.problem.descriptor=始终反转对布尔方法 '\#ref()' 的调用
button.add=添加…
button.add.blank=添加空白
button.add.class=添加类…
button.add.dependency=添加依赖项
button.add.package=添加软件包…
button.add.pattern=添加模式…
button.annotations=注解…
button.base.method=基方法(&B)
button.code.patterns=代码模式…
button.current.method=当前方法(&C)
button.text.settings=设置…
button.to.another.directory=到目录(&D)
button.to.another.source.root=到源根(&S)
caller.chooser.referenced.code.title=引用代码
cast.expression=插入转换表达式
cast.to.0=转换为''{0}''
change.color.command.text=更改颜色
change.signature.from.usage.short.name=<html> 更改 {0}({1}) 的签名</html>
change.uid.action.name=随机更改 'serialVersionUID' 初始值设定项
checkbox.annotate.local.variables=注解局部变量
checkbox.check.for.jdk.updates=检查 JDK 更新
checkbox.collapse.annotations=注解
checkbox.collapse.anonymous.classes=匿名类
checkbox.collapse.closures="闭包" (在 Java 8 前，实现一个方法的匿名类)
checkbox.collapse.end.of.line.comments=行尾注释序列
checkbox.collapse.generic.constructor.parameters=<html>通用构造函数和方法形参</html>
checkbox.collapse.i18n.messages=I18n 字符串
checkbox.collapse.inferred.type=使用推断类型替换 'var'
checkbox.collapse.inner.classes=内部类
checkbox.collapse.multiline.comments=多行注释
checkbox.collapse.one.line.methods=<html>一行方法<html>
checkbox.collapse.simple.property.accessors=<html>简单属性访问器</html>
checkbox.collapse.suppress.warnings=<html>@SuppressWarnings</html>
checkbox.declare.var.type=对局部变量声明使用 'var'
checkbox.deprecated.members=弃用的成员
checkbox.don.t.warn.in.case.of.multiline.lambda=如果 'List.replaceAll()' 的形参为多行 lambda，则不发出警告
checkbox.html.report.inaccessible.symbols=<html>报告无法访问的符号<br>(javadoc 工具可能无法创建超链接)
checkbox.ignore.chains=忽略可链接方法
checkbox.ignore.fields.used.in.multiple.methods=忽略多个方法中使用的字段
checkbox.iterate.unknown.stream.sources.via.stream.iterator=通过 Stream.iterator() 迭代未知的流源
checkbox.make.generated.local.variables.final=将生成的局部变量设为 final
checkbox.make.generated.parameters.final=将生成的形参设为 final
checkbox.prefer.longer.names=提升较长的名称
checkbox.preserve.line.feeds=保留换行
checkbox.spaces.record.header=记录标头
checkbox.suggest.conversion.to.map.computeifabsent=建议转换为 Map.computeIfAbsent
checkbox.suggest.conversion.to.map.getordefault=建议转换为 Map.getOrDefault
checkbox.suggest.conversion.to.map.merge=建议转换为 Map.merge
checkbox.suggest.conversion.to.map.putifabsent=建议转换为 Map.putIfAbsent
checkbox.suggest.conversion.to.map.replaceall=建议转换为 Map.replaceAll
checkbox.suggest.replacement.even.if.lambda.may.have.side.effects=建议替换，即使 lambda 可能有副作用
checkbox.suppress.with.suppresswarnings=使用 @SuppressWarnings 禁止
checkbox.treat.get.k.null.the.same.as.containskey.k.may.change.semantics=将 'get(k) \!\= null' 视为与 'containsKey(k)' 相同 (可能更改语义)
checkbox.warn.if.only.foreach.replacement.is.available=只要 'forEach' 替换可用，就发出警告
checkbox.warn.if.the.loop.is.trivial=循环不重要时发出警告
choose.class=选择类
choose.super.class.popup.title=选择超类
class.can.be.record.display.name=类可以是记录类
class.can.be.record.quick.fix=转换为记录类
class.can.be.record.record.highlight.when.semantics.change=如果成员变得更易于访问，则不报告
class.can.be.record.record.highlight.when.semantics.change.description=快速修复仍将可用
class.can.be.record.suggest.renaming.accessors=建议重命名访问器方法
class.can.be.record.suppress.conversion.if.annotated=如果类具有以下注解，则禁止转换\:
class.can.be.record.suppress.conversion.if.annotated.fix.name=如果用 ''{0}'' 注解，则禁止记录转换
class.cannot.be.inlined.because.a.call.to.its.constructor.is.unresolved=无法内联类，因为其构造函数的调用未解析
class.cannot.be.inlined.because.an.interface.implemented.by.it.cannot.be.resolved=无法内联类，因为无法解析其实现的一个接口
class.cannot.be.inlined.because.it.has.static.fields.with.non.constant.initializers=无法内联类，因为其具有带非常量初始值设定项的 static 字段
class.cannot.be.inlined.because.it.has.static.initializers=无法内联类，因为其具有 static 初始值设定项
class.cannot.be.inlined.because.it.has.static.inner.classes=无法内联类，因为其具有 static 内部类
class.cannot.be.inlined.because.it.has.static.methods=无法内联类，因为其具有 static 方法
class.cannot.be.inlined.because.it.has.static.non.final.fields=无法内联类，因为其具有 static 非 final 字段
class.cannot.be.inlined.because.it.has.usages.of.fields.not.inherited.from.its.superclass=无法内联类，因为其具有未从自身超类继承的字段的用法
class.cannot.be.inlined.because.it.has.usages.of.its.class.literal=无法内联类，因为其具有自身类字面量的用法
class.cannot.be.inlined.because.it.has.usages.of.its.inner.classes=无法内联类，因为其具有自身内部类的用法
class.cannot.be.inlined.because.it.is.used.as.a.this.qualifier=无法内联类，因为其用作 'this' 限定符
class.cannot.be.inlined.because.it.is.used.in.a.catch.clause=无法内联类，因为其用于 'catch' 子句
class.cannot.be.inlined.because.it.is.used.in.a.throws.clause=无法内联类，因为其用于 'throws' 子句
class.cannot.be.inlined.because.its.constructor.contains.return.statements=无法内联类，因为其构造函数包含 'return' 语句
class.cannot.be.inlined.because.its.superclass.cannot.be.resolved=无法内联类，因为无法解析其超类
class.cannot.be.inlined.because.there.are.usages.of.its.methods.not.inherited.from.its.superclass.or.interface=无法内联类，因为其方法的部分用法并非继承自其超类或接口
class.decorator.or.has.default.constructor=''{0}'' 应具有默认构造函数或者实现 ''Decorator'' 模式
class.filter.editor.add.dialog.title=新的过滤器
class.filter.editor.choose.class.title=选择类
class.filter.editor.table.model.column.name.isActive=活跃
class.filter.editor.table.model.column.name.pattern=模式
class.has.no.default.constructor=''{0}'' 没有默认的构造函数
class.is.not.a.subclass=''{0}'' 未分配到 ''{1}''
class.is.not.concrete=''{0}'' 不是一个具体类
class.is.not.public=''{0}'' 不为 public
class.not.found.error.message=未找到类 ''{0}''
class.patterns.error.class.pattern.0.must.be.a.valid.java.qualifier=模式必须是有效的 java 限定名称，仅接受 '*' 作为占位符
class.patterns.error.method.pattern.0.must.be.a.valid.java.identifier=方法模式 ''{0}'' 必须是有效的 java 标识符，仅接受 ''*'' 作为占位符
class.patterns.panel.add.class=添加类
class.patterns.separator.mark.code.as.entry.point.if.qualified.name.matches=如果限定名称匹配，则将代码标记为入口点
code.style.generation.override.method.signature=重写方法签名
code.style.generation.repeat.synchronized.modifier=重复 synchronized 修饰符(&S)
code.style.generation.replace.null.check=将 null 检查替换为 Objects\:\:nonNull 或 Objects\:\:isNull
code.style.generation.settings.error.not.valid.identifier.part.in.prefix=在前缀 ''{0}'' 中不是有效的 java 标识符部分
code.style.generation.settings.error.not.valid.identifier.part.in.suffix=在后缀 ''{0}'' 中不是有效的 java 标识符部分
code.style.generation.use.class.isInstance=如果可能，请使用 Class\:\:isInstance 和 Class\:\:cast
code.style.generation.use.integer.sum=如果可能，请使用 Integer\:\:sum 等
code.vision.implementations.hint={0, choice, 1\#1 个实现|2\#{0,number} 个实现}
code.vision.inheritors.hint={0, choice, 1\#1 个继承者|2\#{0,number} 个继承者}
code.vision.java.external.configuration.description=外部配置文件(.sdkmanrc、.tool-versions)中配置的 JDK 的状态。
code.vision.java.external.configuration.name=Java 配置
code.vision.overrides.hint={0, choice, 1\#1 个重写|2\#{0,number} 个重写}
column.name.class.entry.point=类
column.name.method.entry.point=方法
column.name.with.subclasses.entry.point=包含子类
combobox.paste.insert.imports=粘贴时插入 import(&I)\:
command.completion.delete.element.text=删除元素
command.completion.generate.all.args.constructor.text=全实参构造函数
command.completion.generate.getter=生成 'Getter'
command.completion.generate.getter.setter=生成 'Getter' 和 'Setter'
command.completion.generate.no.args.constructor.text=无实参构造函数
command.completion.generate.setter=生成 'Setter'
command.completion.getters.and.setters.text=getter 和 setter
command.completion.getters.text=getter
command.completion.inline.text=内联
command.completion.setters.text=setter
command.create.class.from.template=从模板创建类
command.create.new.subdirectory=创建新子目录
command.name.delegate.detected.change=委托
command.name.generate.tostring=生成 toString()
command.name.replace.type=替换类型
command.name.updating.package.statement=更新 package 语句
comment.the.class.will.be.created.in.the.package.0=类将在软件包 ''{0}'' 中创建
compiler.options=编译器选项
completion.class.name.hint.2=再次按{0}可以在搜索时忽略模块依赖关系
completion.generate.via.wizard=(通过向导生成)
completion.inner.scope=内部
completion.inner.scope.tail.text=(来自 {0} 块)
completion.no.suggestions.of.type=没有类型为{0}的建议
completion.override.implement.methods=重写/实现方法…
completion.provider.method.declaration.type=provider() 方法声明
completion.smart.aslist.hint=再次按{0}查找{1}的集合(Array)
completion.smart.chain.hint=再次按{0}搜索方法的调用链
completion.smart.hint=按{0}仅显示适合类型的变量
completion.smart.toar.hint=再次按{0}查找{1}的集合
completion.smart.type.generate.anonymous.body=生成匿名体
completion.unknown.type=未知类型{0}
configurable.EqualsHashCodeTemplatesPanel.display.name=模板
configurable.GenerateToStringConfigurable.display.name=设置
configurable.TemplatesPanel.display.name=模板
configure.annotations.option=配置注解…
conflict.message.method.will.override.method.base.class=重命名的 {0} 将重写基 {1} 的方法
convert.compareto.expression.to.equals.call=将 'compareTo()' 表达式转换为 'equals()' 调用
convert.compareto.expression.to.equals.call.may.change.semantics=将 'compareTo()' 表达式转换为 'equals()' 调用 (可能更改语义)
convert.number.binary=二进制
convert.number.decimal=十进制
convert.number.hex=十六进制
convert.number.octal=八进制
convert.number.plain.format=普通格式
convert.number.scientific.format=科学格式
copy.abstract.method.intention.name=使用现有实现''{0}''
copy.abstract.method.no.existing.implementations.found=没有找到现有的实现
copy.abstract.method.popup.title=选择要复制的实现
copy.abstract.method.title=使用 abstract 方法实现
copy.paste.reference.notification=<html>已添加 {0} 个{0, choice, 1\#导入|2\#导入}<p><span><a href\=''show''>检查添加的导入…</a></span></html>
create.class.mapping.dialog.title=选择 {0} 类
cyclic.dependencies.progress.text=正在构建依赖关系图
cyclic.dependencies.scope.dialog.module.button={0}模块''{1}'' (&M)
cyclic.dependencies.scope.dialog.project.button={0}整个项目(&P)
cyclic.dependencies.scope.dialog.title=指定{0}作用域
cyclic.dependencies.scope.include.test.sources.option=包含测试代码(&T)
cyclic.dependencies.tree.cycle.node.text=循环
cyclic.dependencies.usage.view.initial.text=从左边树选择分析的软件包
cyclic.dependencies.usage.view.root.node.text=在软件包 ''{1}'' 中使用软件包 ''{0}''
dataflow.from.here=流出此处的数据流
dataflow.to.here=流入此处的数据流
deannotate.intention.action.family.name=取消注解
deannotate.intention.action.several.text=取消注解…
deannotate.intention.action.text=取消注解 {0}
deannotate.intention.chooser.title=选择要删除的注解
default.package.presentable.name=<默认>
default.param.value.warning={0} 已存在
delete.assignment.completely=完全删除赋值
delete.initializer.completely=完全删除初始值设定项
dependant.sdk.unsatisfied.dependency.message=需要先配置 Java SDK
dependencies.libraries.node.text=库
dependencies.tree.node.default.package.abbreviation=<默认软件包>
destination.combo.source.root.not.expected.conflict=应为测试根，但选择了源根
destination.combo.test.root.not.expected.conflict=应为源根，但选择了测试根
dfa.constraint.0.not.null={0}(非 null)
dfa.constraint.not.null=非 null
dfa.constraint.null.or.0=null 或 {0}
dialog.create.class.destination.package.label=目标软件包\:
dialog.create.class.label=创建 {0}\:
dialog.create.class.name=创建{0}{1}
dialog.create.class.package.chooser.title=选择目标软件包
dialog.edit.template.checkbox.smart.type.completion=类型匹配补全(&O)
dialog.edit.template.checkbox.use.static.import=尽可能使用静态导入(&I)
dialog.import.on.paste.title=选择要导入的类
dialog.import.on.paste.title2=选择要导入的元素
dialog.import.on.paste.title3=选择要移除的 import
dialog.message.0.update.existing.class={0}。更新现有的类?
dialog.message.class.not.found=找不到模板类 ''{0}''
dialog.message.create.test.in.the.same.source.root=在相同的源根中创建测试?
dialog.message.infer.nullity.annotations.requires.the.project.language.level=推断为 null 性注解需要将项目语言级别设置为 1.5 或更高。
dialog.message.jetbrains.annotations.library.is.missing=缺少 JetBrains 注解库。\n没有库，IntelliJ IDEA 将无法运行分析。要添加吗?
dialog.message.modules.dont.refer.to.existing.annotations.library={0, choice, 0\#模块|2\#模块}{1}{0, choice, 0\#不|2\#不}引用具有 IntelliJ IDEA 为 null 性注解的 ''{2}'' 库。是否要立即添加{0, choice, 0\#依赖项|2\#依赖项}?
dialog.message.no.places.found.to.infer.nullable.notnull=未找到要推断 @Nullable/@NotNull 的位置
dialog.message.parameter.has.write.usages.inline.not.supported=形参具有写入用法。不支持内联
dialog.message.template.not.applicable=模板不适用
dialog.message.template.not.found=找不到模板
dialog.paste.on.import.text=<html>您所粘贴的代码段使用了在新上下文中无法通过导入访问的类。<br/>请选择要导入到新文件中的类。</html>
dialog.paste.on.import.text2=<html>您所粘贴的代码段使用了在新上下文中无法通过导入访问的元素。<br/>请选择要导入到新文件中的元素。</html>
dialog.paste.on.import.text3=<html>您粘贴的代码段在当前上下文中引入了新的导入。<br/>选择您想要消除的导入。</html>
dialog.title.check.configuration=检查配置…
dialog.title.check.functional.interface.candidates=检查函数式接口候选项…
dialog.title.choose.0.parameters=选择 {0} 形参
dialog.title.choose.annotation=选择 {0} 注解
dialog.title.choose.class=选择类
dialog.title.choose.logger=选择记录器
dialog.title.configure.annotations=配置注解
dialog.title.configure.code.patterns=配置代码模式
dialog.title.copy.template=复制模板
dialog.title.create.class.in.package=在软件包中创建类
dialog.title.create.missing.tests=创建缺少的测试
dialog.title.create.new.template=创建新模板
dialog.title.edit.method.contract=编辑方法协定
dialog.title.edit.range=编辑 ''{0}'' 的范围
dialog.title.infer.nullity=推断为 null 性
dialog.title.infer.nullity.results=推断为 null 性结果
dialog.title.move.directory=移动目录
dialog.title.no.test.roots.found=未找到测试根
dialog.title.process.duplicates=处理重复项
dialog.title.super.method.found=发现 super 方法
dialog.title.testdatapath.file.generate=从类生成文件到 @TestDataPath
dialog.title.testdatapath.method.generate=从 @TestDataPath 生成方法
disable.report.inaccessible.symbols.fix=不报告无法访问的符号
edit.contract.dialog.checkbox.impure.method=方法可能会产生副作用(&S)
edit.contract.dialog.hint=<html>请指定约定文本<p>示例\: <code>_, null -> false</code><br><small>请参阅意图操作描述了解详细信息</small></html>
edit.contract.dialog.mutates.hint=指定可以改变的逗号分隔元素<p>示例\: <code>this,param1</code><p>如果未指定副作用，则留空。
edit.range.dialog.message=如果不受限制则留空
edit.range.error.invalid.value=无效值
edit.range.should.not.be.greater.than.to=不应大于 'to'
edit.range.should.not.be.less.than.from=不应小于 'from'
edit.range.value.should.be.bigger.than=不应大于 {0}
edit.range.value.should.be.less.than=不应小于 {0}
empty.title=空
encapsulate.fields.dialog.javadoc.title=Javadoc
enum.constant.ordinal=枚举常量序数\: 
enum.not.allowed=枚举不被允许
enums.cannot.be.inlined=枚举无法内联
environment.key.description.project.jdk=项目 JDK 的绝对路径
environment.key.description.project.jdk.name=项目 JDK 的 IDE 可见名称。
error.attempt.to.generate.constructor.for.anonymous.class=不能添加构造函数到匿名类
error.attempt.to.generate.constructor.for.implicit.class=无法将构造函数添加到压缩源文件的隐式声明类
error.hint.no.expression.found=找不到表达式
error.message.ide.does.not.support.starting.processes.using.old.java=IDE 不支持使用 Java {0} 启动 Java 进程，支持的最低版本为 8。更改运行配置以使用较新的 Java 版本。
error.message.ide.does.not.support.starting.processes.using.old.java.app=IDE 不支持使用 Java {0} 启动 Java 进程，最低支持版本为 Java 8。要解决此问题，请执行以下其中一项操作\:\n* 更改运行配置以使用较新的 Java 版本。\n* 将 `idea.no.launcher` 自定义属性设置为 `true` 以禁用 IntelliJ 启动器(诸如 `soft exit` 之类的附加功能将停止工作)。
error.no.annotation.class.found=找不到注解类
error.package.already.contains.package-info=''package-info.java'' 的软件包已经存在“{0}”
error.package.already.contains.package.html=软件包 ''{0}'' 已经有一个 ''package.html'' 文件。仍要创建 ''package-info.java''?
error.package.html.found.title=发现“package.html”
error.text.this.is.not.a.valid.java.class.name=这不是有效的 Java 类名
exclude.0.from.auto.import=从自动导入中排除 ''{0}''
exclude.0.from.completion=从补全中排除 ''{0}''
exclude.accessors=排除访问器(&E)
exclude.from.completion.group=从自动导入和补全中排除\:
exclude.from.imports.no.exclusions=添加要从自动导入和补全中排除的类、软件包或成员
exclude.import.wildcard.comment=使用 * 通配符排除指定类或软件包的所有成员
exclude.table.mask=类、软件包或成员
exclude.table.scope.column=作用域
export.to.html.generate.hyperlinks.checkbox=生成超链接指向类 (&H)
external.annotation.place=选择注解存储位置
external.annotation.place.external=在外部 XML 文件中…
external.annotation.place.in.code=直接在源代码中
external.annotation.prompt=外部注解提示
external.annotations.external.option=从外部添加(&E)
external.annotations.in.code.option=添加代码(&C)
external.annotations.no.package=找不到注解所有者的软件包
external.annotations.open.file=打开注解文件
external.annotations.problem.parse.error=文件\: {0}<br>问题\: {1}
external.annotations.problem.title=无法读取外部注解
external.annotations.root.chooser=外部注解根文件夹
external.annotations.root.chooser.error=找不到文件夹\: {0}
external.annotations.roots=注解根
external.annotations.suggestion.message=<html><body>如果您的代码中不需要注解，可以使用外部存储。<br>要配置外部注解，请指定放置包含注解的文件的根目录</body></html>
external.java.configuration.copy.command=复制下载命令
external.java.configuration.inlay.already.configured=项目 JDK ({0})
external.java.configuration.inlay.found=设为项目 JDK
external.java.configuration.inlay.missing=找不到 JDK.
external.java.configuration.inlay.missing.actions=未找到 JDK。更多…
external.java.configuration.inlay.provider.name=外部 JDK 配置
external.java.configuration.inlay.unknown=正在同步…
external.java.configuration.refresh=刷新
extract.interface.command.name=提取接口
extract.superclass.command.name=提取超类
extracted.class.should.have.unique.name=已提取类应具有唯一名称。已有一个内部类使用名称 ''{0}''
filetype.spi.description=服务提供程序接口
find.field.accessors.prompt=搜索字段 ''{0}'' 的访问器?
find.field.accessors.title=已找到字段访问器
find.options.include.accessors.base.checkbox=搜索访问器的基方法(&E)
find.options.include.accessors.base.checkbox.comment=默认使用顶层层次结构方法作为查找用法目标
find.options.include.accessors.checkbox=搜索访问器(&A)
find.options.include.overloaded.methods.checkbox=重载方法(&V)
find.options.search.overriding.methods.checkbox=在重写方法中搜索(&O)
find.what.derived.classes.checkbox=派生类(&D)
find.what.derived.interfaces.checkbox=派生接口(&D)
find.what.fields.usages.checkbox=字段的用法(&F)
find.what.implementing.classes.checkbox=实现类(&I)
find.what.implementing.methods.checkbox=实现方法(&I)
find.what.implicit.to.string.checkbox=隐式调用(&M)
find.what.methods.usages.checkbox=方法的用法 (&M)
find.what.overriding.methods.checkbox=重写方法(&R)
find.what.search.for.base.methods.checkbox=搜索基方法用法(&E)
find.what.search.for.base.methods.checkbox.comment=默认使用顶层层次结构方法作为查找用法目标
find.what.usages.checkbox=用法(&U)
find.what.usages.of.classes.and.interfaces=类和接口的用法 (&C)
fix.move.to.source.root=移至源根
generate.button.title=生成
generate.constructor.already.exists=构造函数已存在
generate.constructor.fields.chooser.title=选择要通过构造函数初始化的字段
generate.constructor.super.constructor.chooser.title=选择超类构造函数
generate.delegate.target.chooser.title=选择目标生成的代表
generate.equals.and.hashcode.already.defined.title=生成 equals() 和 hashCode()
generate.equals.and.hashcode.already.defined.warning=对于类 {0}，已定义方法 ''boolean equals(Object)'' 和 ''int hashCode()''。是否要将其删除并继续?
generate.equals.and.hashcode.already.defined.warning.anonymous=对于此匿名类，已定义方法 'boolean equals(Object)' 和 'int hashCode()'。是否要将其删除并继续?
generate.equals.hashcode.accept.sublcasses=接受子类作为 equals() 方法的形参(&S)
generate.equals.hashcode.accept.sublcasses.explanation=<html><body>虽然通常不符合 Object.equals() 的约定，<br>但要使生成的方法与生成代理子类的框架（如 Hibernate）一起正常工作，<br>可能需要接受子类。</body></html>
generate.equals.hashcode.comparison.table=<html><table><tr><th><th>instanceof<th>getClass()<tr><td>允许子类的实例与超类的实例相等<td align\=center>是<td align\=center>否<tr><td>允许不同子类的实例彼此相等<td align\=center>是<td align\=center>否<tr><td>重写生成的 equals() 方法不会破坏其约定<td align\=center>否<td align\=center>是<tr><td>避免额外的 null 检查<td align\=center>是<td align\=center>否<tr><td>遵循里氏替换原则<td align\=center>是<td align\=center>否</table></html>
generate.equals.hashcode.equals.fields.chooser.title=选择要包含在 equals() 中的字段(&F)
generate.equals.hashcode.getclass.type.comparison=get&Class() 比较表达式
generate.equals.hashcode.hashcode.fields.chooser.title=选择要包含在 hashCode() 中的字段(&F)
generate.equals.hashcode.instanceof.type.comparison=instanceof 表达式(&I)
generate.equals.hashcode.internal.error=内部错误
generate.equals.hashcode.non.null.fields.chooser.title=选择所有非 null 字段(&F)
generate.equals.hashcode.template=模板(&T)\:
generate.equals.hashcode.type.comparison.label=对于 equals() 方法中的类类型比较，生成\:
generate.equals.hashcode.use.getters=可用时使用 getter(&G)
generate.equals.hashcode.warning.hashcode.for.arrays.is.not.supported=不支持数组的 hashCode()
generate.equals.hashcode.wizard.title=生成 equals() 和 hashCode()
generate.equals.no.fields.for.generation=找不到要包含在 equals/hashCode 中的字段
generate.equals.template.title=Equals 模板\:
generate.equals.warning.equals.for.nested.arrays.not.supported=equals()不支持嵌套的数组
generate.equals.warning.generated.equals.could.be.incorrect=生成的Object[]的equals()可能不正确
generate.equals.wizard.title=生成 equals()
generate.file.extension.text=输入文件扩展名\: .php、.java、.kt、.cpp …
generate.file.extension.validation.error=文件扩展名 ''{0}'' 无效。必须以 ''.'' 开头，不能包含空格，也不能为空
generate.getter.and.setter.error.no.fields=找不到要为之生成 getter/setter 的字段
generate.getter.and.setter.error.no.fields.without.getters.and.setters=找不到没有 getter/setter 的字段
generate.getter.and.setter.error.setters.for.read.only.not.generated=未生成只读字段的 setter
generate.getter.error.no.fields=找不到要为之生成 getter 的字段
generate.getter.error.no.fields.without.getters=找不到没有 getter 的字段
generate.getter.fields.chooser.title=选择要生成 Getter 的字段
generate.getter.setter.generate.all.annotations=复制所有注解(&A)
generate.getter.setter.generate.all.annotations.tooltip=从字段复制所有适用的注解。否则，将只复制为 null 性注解
generate.getter.setter.header.visibility.hint.=根据“文件 | 设置 | 编辑器 | 代码样式 | Java | 代码生成”应用可见性
generate.getter.setter.title=选择要生成 Getter 和 Setter 的字段
generate.getter.template=Getter 模板(&G)\:
generate.hashcode.template.title=HashCode 模板\:
generate.hashcode.wizard.title=生成 hashCode()
generate.logger.no.place.found.dialog.message=找不到插入记录器的位置
generate.logger.no.place.found.dialog.title=找不到位置
generate.logger.specify.place.popup.title=选择位置
generate.members.implement.command=实现
generate.members.nothing.to.insert=未找到要插入的内容
generate.method.nofiles.warn=在类 {0} 中找不到测试方法
generate.method.nosuites.warn=在 @TestDataPath("{0}") 中找不到测试套件
generate.missed.tests.action.error.no.tests.found=找不到测试。
generate.missed.tests.action.failed.to.detect.framework=无法检测到 {0} 的测试框架
generate.quickfix.files=创建 QF 方案(使用 '.after' 后缀)
generate.record.constructor.title=生成记录构造函数
generate.select.default.modifier.text=选择修饰符
generate.setter.fields.chooser.title=选择要生成 Setter 的字段
generate.setter.template=Setter 模板(&S)\:
generate.setters.no.fields=找不到要为之生成 setter 的字段
generate.setters.no.fields.without.setters=找不到没有 setter 的字段
generate.test.support.method.error.cannot.generate.method=无法生成方法\: {0}
generate.test.support.method.error.method.already.exists=方法 {0} 已存在
generate.test.support.method.error.no.template.found.for.framework=没有找到 {0} 的模板\: {1}
generate.tostring.already.exist.border=当方法已存在时
generate.tostring.available.implicit.variables.label=可用的隐式变量\:<br/>{0}
generate.tostring.exclude..transient=排除 transient 字段
generate.tostring.exclude.by.field.name=按名称排除字段 (reg exp)
generate.tostring.exclude.by.field.type=按类型名称排除字段 (reg exp)
generate.tostring.exclude.by.name=按名称排除方法 (reg exp)
generate.tostring.exclude.by.return.type=按返回值类型名称排除方法 (reg exp)
generate.tostring.exclude.constant.fields=排除常量字段
generate.tostring.exclude.enum.fields=排除枚举字段
generate.tostring.exclude.logger=排除记录器字段 (Log4j、JDK 日志记录、Jakarta Commons 日志记录)
generate.tostring.exclude.static.fields=排除 static 字段
generate.tostring.fully.qualified.class.name=在生成的 toString() 中使用完全限定类名($classname)
generate.tostring.getters.in.generated.code=如果可用，在生成的 toString() 中使用 getter ($methods)
generate.tostring.handle.exception.error.message=执行操作时抛出不可恢复的异常 - 请参阅 IDEA 日志以获取详细信息 (堆栈跟踪应位于 idea.log 中)\:\n{0}
generate.tostring.handle.exception.plugin.warning.message=执行操作时抛出 PluginException - 请参阅 IDEA 日志以获取详细信息 (堆栈跟踪应位于 idea.log 中)\:\n{0}
generate.tostring.handle.exception.velocity.error.message=生成代码时出现 Velocity 错误 - 请参阅 IDEA 日志以获取更多详细信息 (堆栈跟踪应位于 idea.log 中)\:\n{0}
generate.tostring.insert.border=在哪里插入?
generate.tostring.method.already.exists.dialog.me=ssage\=替换现有的 {0} 方法
generate.tostring.method.already.exists.dialog.title=方法已存在
generate.tostring.move.to.generated.checkbox=将文本光标移至生成的方法
generate.tostring.settings=设置
generate.tostring.sort.ascending=升序
generate.tostring.sort.checkbox=对元素进行排序
generate.tostring.sort.descending=降序
generate.tostring.sort.super=超类成员优先
generate.tostring.tab.title=toString() 生成设置
generate.tostring.template.label=模板(&T)\:
generate.tostring.title=生成 toString()
generate.type.use.before.type=将生成的带有目标 TYPE_USE 的注解放在修饰符和类型之间
generate.type.use.before.type.description=<html>带有目标 TYPE_USE 的注解将被放置在任何修饰符之后，并且直接位于<br>类型之前。禁用时，它们将被放置在任何修饰符之前。</html>
goto.super.class.chooser.title=选择超类或接口
gutter.implemented.method=已实现方法
gutter.implementing.method=实现方法
gutter.overridden.method=重写的方法
gutter.overriding.method=重写方法
gutter.service=服务
gutter.sibling.inherited.method=同级继承的方法
header.method.to.be.converted=要转换的方法
hide.out.of.cyclic.packages.action.description=隐藏没有循环依赖的软件包
hide.out.of.cyclic.packages.action.text=隐藏没有循环依赖的软件包
highlight.exceptions.thrown.chooser.title=选择异常类以高亮显示
highlight.imported.classes.chooser.title=选择导入高亮的类
highlight.imported.members.chooser.title=选择导入高亮的成员
highlight.overridden.classes.chooser.title=选择高亮显示其中重写的方法的类
highlight.suppressed.warnings.choose.inspections=选择检查以高亮显示此项中的已禁止问题
highlight.throws.class.name=高亮显示 Throws {0}
highlight.throws.popup.throwing.places=抛出 {0} 的位置
highlight.throws.popup.usages={0} 的用法
hint.text.added.imports=，已添加 {0} 个{1, choice, 0\#导入|1\#导入}
hint.text.not.valid.java.identifier=不是有效的 Java 标识符
hint.text.occurrences.were.inlined={0} 个匹配项已内联
hint.text.press.to.go.through.inlined.occurrences=按 {0} 遍历 {1} 个已内联匹配项
hint.text.rearranged.imports=已重新排列导入
hint.text.removed.imports=已移除 {0} 个{1, choice, 0\#导入|1\#导入}
hint.text.tostring.method.could.not.be.created.from.template=无法从模板 ''{0}'' 创建 ''toString()'' 方法
hint.text.tostring.template.invalid=toString() 模板 ''{0}'' 无效
icon.preview=图标预览
ignore.imports.and.formatting=忽略导入和格式设置
illegal.name.validation.info=非法名称\: {0}
implement.abstract.method.potential.implementations.with.weaker.access=找到具有较弱访问权限的潜在实现\: {0}
implement.method.no.methods.to.implement=找不到要实现的方法
import.statically=静态导入
include.accessors=包含访问器(&I)
increase.language.level.preview.description=模块 ''{0}'' 的语言级别将被更改为 ''{1}''
infer.nullity.progress=正在对结果进行后期处理…
inlay.MethodChainsInlayProvider.description=调用链中的方法返回值类型。
inlay.annotation.hints.external.annotations=存储在源代码外部的注解。<br>当您需要注解时，这些注解会很有用，但不能将其添加到源代码(例如，在使用库代码时)。<br><br><a href\='https\://www.jetbrains.com/help/idea/external-annotations.html'>文档</a>
inlay.annotation.hints.inferred.annotations=IntelliJ IDEA 通过扫描库和项目代码生成的注解。这些注解可以帮助您理解代码协定，并提高静态分析的能力。注解包括\: <br> @Contract <br> @Nullable <br> @NotNull <br> @Unmodifiable <br>@UnmodifiableView <br><br><a href\='https\://www.jetbrains.com/help/idea/inferring-nullity.html\#inferred-annotations'>文档</a>
inlay.parameters.java.build.like.method=返回方法本身操作的类的实例的方法，例如，StringBuilder 链中的调用或 Java 8 Stream API 中的中间操作。
inlay.parameters.java.clear.expression.type=使用复杂表达式作为实参的方法调用，例如，三元运算符或 Java 13 switch 语句。
inlay.parameters.java.enums=使用形参化构造函数的枚举常量声明。
inlay.parameters.java.method.name.contains.parameter.name=从方法名中清除预期实参时接受单个实参的方法，如访问器方法。
inlay.parameters.java.multiple.params.same.type=对具有同一类型的多个非字面量实参的方法的调用。
inlay.parameters.java.new.expr=对形参化构造函数的调用。
inlay.parameters.java.simple.sequentially.numbered=接受多个形参的方法，这些形参的名称由一个字母后跟一个数字组成。
insert.override.annotation=插入 @Override 注解(&O)
inspection.anonymous.2.method.ref.display.name=匿名类型可被替换为方法引用
inspection.assert.quickfix=断言''{0}''
inspection.auto.add.module.requirements.quickfix=填写模块依赖项
inspection.bulk.file.attributes.read.description=可使用批量 'Files.readAttributes()' 调用
inspection.bulk.file.attributes.read.message=多个文件特性调用可被替换为单个 'Files.readAttributes()' 调用
inspection.call.message=冗余的 ''{0}()'' 调用
inspection.capturing.cleaner=已传递到 Cleaner.register() 的可运行对象捕获 ''{0}'' 引用
inspection.capturing.cleaner.description=清理器捕获对象引用
inspection.cast.can.be.removed.narrowing.variable.type.fix.family.name=更改变量类型并移除转换
inspection.cast.can.be.removed.narrowing.variable.type.fix.name=将 ''{0}'' 的类型更改为 ''{1}'' 并移除转换
inspection.cast.can.be.removed.narrowing.variable.type.message=可以通过将 ''{0}'' 的类型更改为 ''{1}'' 来移除转换
inspection.cast.can.be.removed.narrowing.variable.type.name=太弱的变量类型导致不必要的转换
inspection.charset.object.can.be.used.display.name=可以使用标准 'Charset' 对象
inspection.charset.object.can.be.used.fix.family.name=使用字符集常量
inspection.charset.object.can.be.used.message=可以改用{0}
inspection.collection.add.all.can.be.replaced.with.constructor.display.name=冗余的 'Collection.addAll()' 调用
inspection.collection.factories.fix.family.name=替换集合工厂回调
inspection.collection.factories.fix.name=替换为 ''{0}.{1}()'' 调用
inspection.collection.factories.message=可被替换为 ''{0}.{1}()'' 调用
inspection.collection.factories.option.ignore.non.constant=仅在内容为常量时报告
inspection.collection.factories.option.suggest.ofentries=建议 'Map.ofEntries()'
inspection.collection.used.as.vararg.display.name=可迭代对象用作 vararg
inspection.collection.used.as.vararg.message=可迭代对象作为 vararg 传递\: 很可能应为数组
inspection.comparator.combinators.display.name=可以使用 'Comparator' 连结符
inspection.comparator.result.comparison.display.name=compare 方法的可疑用法
inspection.comparator.result.comparison.fix.family.name=修正比较结果
inspection.comparator.result.comparison.problem.display.name=比较方法的结果与特定常数对比
inspection.condition.covered.by.further.condition.display.name=条件由进一步的条件覆盖
inspection.conditional.break.in.infinite.loop=将条件移至循环中
inspection.conditional.break.in.infinite.loop.allow.condition.fusion=允许与现有循环条件合并
inspection.conditional.break.in.infinite.loop.description=循环内条件中断
inspection.conditional.break.in.infinite.loop.no.conversion.with.do.while=不建议替换为 'do while'
inspection.conditional.break.in.infinite.loop.suggest.conversion.when.if.is.single.stmt.in.loop=当 'if' 是循环中的单条语句时建议转换
inspection.conditional.can.be.optional.display.name=条件可被替换为 Optional
inspection.convert.2.method.ref.display.name=lambda 可被替换为方法引用
inspection.convert.2.streamapi.display.name=可以通过 Stream API 收起循环
inspection.convert.to.local.quickfix=转换为局部变量
inspection.data.flow.constant.values.display.name=常量值
inspection.data.flow.display.name=为 null 性和数据流问题
inspection.data.flow.filter.notnull.quickfix=插入'filter(Objects\:\:nonNull)'步骤
inspection.data.flow.ignore.assert.statements=忽略 assert 语句
inspection.data.flow.nullable.quickfix.option=对可 null 值的方法/字段/形参建议使用 @Nullable 注解
inspection.data.flow.optional.of.nullable.misuse.display.name=使用具有 null 或非 null 实参的 Optional.ofNullable
inspection.data.flow.report.not.null.required.parameter.with.null.literal.argument.usages=报告使用 null 字面量实参用法的非 null 必需形参
inspection.data.flow.report.nullable.methods.that.always.return.a.non.null.value=报告始终返回非 null 值的可以为 null 的方法
inspection.data.flow.report.problems.that.happen.only.on.some.code.paths=报告仅在某些代码路径上发生的问题
inspection.data.flow.treat.non.annotated.members.and.parameters.as.nullable=将未注解的成员和形参视为 @Nullable
inspection.data.flow.true.asserts.option=不报告条件被静态证明始终为 true 的断言
inspection.data.flow.unreachable.code.display.name=不可到达的代码
inspection.data.flow.unreachable.code.option.ignore.trivial.description=不报告不可到达的语句，例如 <code>return 0</code>、<code>break</code> 等，因为它们可能是满足 Java 控制流规则所必需。
inspection.data.flow.unreachable.code.option.ignore.trivial.name=忽略普通退出语句
inspection.data.flow.unreachable.code.option.respect.suppression.description=尽量避免报告由常量条件引起的不可到达的代码，此时相应的警告会被禁止。
inspection.data.flow.unreachable.code.option.respect.suppression.name=遵循 'Constant value' 检查禁止
inspection.data.flow.use.computeifpresent.quickfix=将 'compute' 替换为 'computeIfPresent'
inspection.dead.code.option.applet=小程序
inspection.dead.code.option.external=非 Java 文件中使用的类
inspection.dead.code.option.main=<html><code>void main(String args[])</code> 方法</html>
inspection.dead.code.option.servlet=Servlet
inspection.default.annotation.param=默认注解形参值
inspection.duplicate.branches.in.switch.default.message='switch' 中的分支是默认分支的重复项
inspection.duplicate.branches.in.switch.delete.fix.family.name=删除冗余 'switch' 分支
inspection.duplicate.branches.in.switch.delete.fix.name=删除冗余 'switch' 分支
inspection.duplicate.branches.in.switch.display.name='switch' 中存在重复分支
inspection.duplicate.branches.in.switch.merge.fix.family.name=合并 'switch' 中的重复分支
inspection.duplicate.branches.in.switch.merge.fix.name=与 ''{0}'' 合并
inspection.duplicate.branches.in.switch.merge.with.default.fix.name=与默认的 'switch' 分支合并
inspection.duplicate.branches.in.switch.message='switch' 中存在重复分支
inspection.duplicate.expressions.complexity.threshold=表达式复杂性阈值
inspection.duplicate.expressions.display.name=同一表达式存在多个匹配项
inspection.duplicate.expressions.introduce.variable.fix.family.name=引入变量
inspection.duplicate.expressions.introduce.variable.fix.name=为 ''{0}'' 引入变量
inspection.duplicate.expressions.message=<code>\#ref</code> 的多个匹配项 \#loc
inspection.duplicate.expressions.replace.other.occurrences.fix.family.name=替换为表达式的其他可变匹配项
inspection.duplicate.expressions.replace.other.occurrences.fix.name=将 ''{0}'' 替换为 ''{1}'' 的其他匹配项
inspection.duplicate.expressions.reuse.variable.fix.family.name=重用变量
inspection.duplicate.expressions.reuse.variable.fix.name=为 ''{1}'' 重用变量 ''{0}''
inspection.empty.module.info.file=空的 'module-info.java' 文件
inspection.endless.stream.description=非短路操作消耗无限流
inspection.equals.hashcode.display.name='equals()' 和 'hashCode()' 未配对
inspection.equals.hashcode.generate.equals.quickfix=生成 'equals()'
inspection.equals.hashcode.generate.equals.quickfix.preview=打开一个对话框以配置 'equals()' 生成。
inspection.equals.hashcode.generate.hashcode.quickfix=生成 'hashCode()'
inspection.equals.hashcode.generate.hashcode.quickfix.preview=打开一个对话框以配置 'hashCode()' 生成。
inspection.excessive.lambda.fix.family.name=常数替换lambda
inspection.excessive.lambda.fix.name=使用没有lambda的''{0}''方法
inspection.excessive.lambda.message=过度使用 lambda
inspection.excessive.lambda.usage.display.name=过度使用 lambda
inspection.excessive.range.check.display.name=过度范围检查
inspection.explicit.argument.can.be.lambda.display.name=显式实参可以是 lambda
inspection.explicit.argument.can.be.lambda.fix.family.name=将显式实参替换为函数
inspection.explicit.argument.can.be.lambda.fix.name=使用包含函数实参的 ''{0}'' 方法
inspection.explicit.argument.can.be.lambda.message=显式实参可以转换为 lambda
inspection.explicit.array.filling.description=可被替换为单个 ''Arrays.{0}()'' 方法调用
inspection.explicit.array.filling.display.name=显式数组填充
inspection.explicit.array.filling.fix.family.name=将循环替换为 ''Arrays.{0}()'' 方法调用
inspection.explicit.array.filling.no.suggestion.for.set.all=不建议使用 'Arrays.setAll()'
inspection.explicit.array.filling.redundant.loop.description=新建数组的冗余初始化
inspection.explicit.array.filling.suggest.set.all=建议 'Arrays.setAll()'
inspection.explicit.to.implicit.class.migration.fix.name=转换成压缩源文件
inspection.explicit.to.implicit.class.migration.name=显式类声明可以转换为压缩源文件
inspection.explicit.to.implicit.convert.to.io=将 'System.out.print()' 和 'System.out.println()' 替换为 'java.lang.IO' 类中的方法
inspection.explicit.to.implicit.move.to.root.delete.package=不移动，仅删除 package 语句
inspection.explicit.to.implicit.move.to.root.move=移动到项目根下
inspection.explicit.to.implicit.move.to.root.title=移动简单源文件
inspection.export.results.callees=调用链
inspection.export.results.implicit.constructor=隐式构造函数 -
inspection.export.results.overrides.library.methods=重写库方法
inspection.export.results.package=软件包
inspection.export.results.type.references=以下使用这种类型
inspection.field.can.be.local.display.name=字段可以是局部变量
inspection.field.can.be.local.problem.descriptor=字段可以被转换为一个局部变量
inspection.field.can.be.local.quickfix.constructor=将字段转换为构造函数中的局部变量
inspection.field.can.be.local.quickfix.initializer=将字段转换为初始值设定项部分中的局部变量
inspection.field.can.be.local.quickfix.one.method=将字段转换为方法 ''{0}'' 中的局部变量
inspection.fill.permits.list.display.name=密封类的 permits 子句中缺失同一文件子类
inspection.fill.permits.list.fix.name=将缺失的子类添加到 permits 子句
inspection.fill.permits.list.no.missing.inheritors=密封类没有缺失的继承者
inspection.fold.expression.fix.family.name=折叠表达式
inspection.fold.expression.into.stream.display.name=表达式可以折叠到流链中
inspection.fold.expression.into.stream.fix.name=将表达式折叠到流链中
inspection.fold.expression.into.string.display.name=表达式可以折叠到 'String.join' 中
inspection.fold.expression.into.string.fix.name=将表达式折叠到 'String.join' 中
inspection.forward.compatibility.name=前向兼容性
inspection.frequently.used.inheritor.inspection.display.name=类可以扩展常用的基类
inspection.functional.expression.can.be.folded.display.name=函数表达式可以折叠
inspection.fuse.stream.operations.display.name=后续步骤可以融合到Stream API链中
inspection.fuse.stream.operations.fix.family.name=将更多语句融入 Stream API 链
inspection.fuse.stream.operations.fix.name=将 {0} 融合到Stream API 链中
inspection.fuse.stream.operations.message=流可能被拓展替换 {0}
inspection.fuse.stream.operations.option.strict.mode=不建议使用 'toList()' 或 'toSet()' 收集器
inspection.handle.signature.change.type.fix.name=将类型更改为 ''{0}''
inspection.handle.signature.field.cannot.resolve=无法解析字段''{0}''
inspection.handle.signature.field.not.static=字段 ''{0}'' 不为 static
inspection.handle.signature.field.static=字段 ''{0}'' 为 static
inspection.handle.signature.field.type=字段''{0}''的类型是''{1}''
inspection.handle.signature.method.abstract=方法 ''{0}'' 在 ''{1}'' 中是 abstract 方法
inspection.handle.signature.method.not.static=方法 ''{0}'' 不为 static
inspection.handle.signature.method.static=方法 ''{0}'' 为 static
inspection.handle.signature.name=MethodHandle/VarHandle 类型不匹配
inspection.handle.signature.not.subclass=调用者类 ''{0}'' 必须是 ''{1}'' 的子类
inspection.handle.signature.use.constructor.fix.family.name=使用构造函数重载之一
inspection.handle.signature.use.constructor.fix.name=使用构造函数''{0}''
inspection.handle.signature.use.method.fix.family.name=使用方法重载之一
inspection.handle.signature.use.method.fix.name=使用方法''{0}''
inspection.idempotent.loop.body=幂等循环体
inspection.illegal.character=非法字符
inspection.implicit.to.explicit.class.backward.migration.fix.name=转换为常规类
inspection.implicit.to.explicit.class.backward.migration.name=压缩源文件可以替换为常规类
inspection.inconsistent.text.block.indent.message=文本块缩进由混合制表符和空格组成
inspection.inconsistent.text.block.indent.name=文本块中的空格缩进不一致
inspection.inconsistent.text.block.indent.spaces=仅使用空格缩进文本块
inspection.inconsistent.text.block.indent.tabs=仅使用制表符缩进文本块
inspection.input.stream.constructor.message=可以使用 'Files.newInputStream()' 构建 'InputStream'
inspection.insert.literal.underscores.display.name=数字字面量可以使用下划线分隔符
inspection.insert.literal.underscores.family.name=将下划线插入数字字面量
inspection.io.stream.constructor.description=可以使用 'Files' 方法构建 'InputStream' 和 'OutputStream'
inspection.java.8.collection.remove.if.display.name=循环可被替换为 'Collection.removeIf()'
inspection.java.8.list.replace.all.display.name=循环可被替换为 'List.replaceAll()'
inspection.java.8.map.api.display.name=可简化的 'Map' 运算
inspection.java.9.collection.factory.display.name=不可变集合创建可被替换为集合工厂调用
inspection.javadoc.additional.tags=附加 Javadoc 标记\:
inspection.javadoc.additional.tags.description=已知非标准标记列表
inspection.javadoc.blank.lines.display.name=空行应替换为 <p> 以换行
inspection.javadoc.blank.lines.fix.family.name=将空白行替换为 <p>
inspection.javadoc.blank.lines.fix.name=插入 <p>
inspection.javadoc.blank.lines.message=空白行将被忽略
inspection.javadoc.link.as.plain.text.display.name=指定为纯文本的链接
inspection.javadoc.link.as.plain.text.message=指定为纯文本的链接
inspection.javadoc.lint.display.name=Javadoc中的HTML问题(DocLint)
inspection.javadoc.method.problem.missing.param.tag=形参{0}缺少必需的标签 <code>@param</code>
inspection.javadoc.method.problem.missing.tag.description={0}标签说明已丢失
inspection.javadoc.option.ignore.deprecated=忽略标记为 @deprecated 的元素
inspection.javadoc.option.ignore.deprecated.description=不报告 Javadoc 中描述已弃用类或成员的任何问题
inspection.javadoc.option.ignore.period=忽略期问题
inspection.javadoc.option.ignore.period.description=不报告与描述的第一句缺失或不完整相关的问题。
inspection.javadoc.option.ignore.self.ref=忽略指向自己的Javadoc
inspection.javadoc.option.ignore.self.ref.description=不报告 Javadoc 中指向同一元素的引用
inspection.javadoc.option.ignore.simple=忽略简单的属性访问器
inspection.javadoc.option.ignore.syntax.errors=忽略 Javadoc 语法错误
inspection.javadoc.option.ignore.syntax.errors.description=不报告 Javadoc 解析错误，例如格式错误的引用
inspection.javadoc.option.ignore.throws=忽略重复的'throws'标签
inspection.javadoc.option.ignore.throws.description=不报告描述相同异常的重复 <code>@throws</code> 标记
inspection.javadoc.option.tab.title=类
inspection.javadoc.option.tab.title.field=字段
inspection.javadoc.option.tab.title.inner.class=内部类
inspection.javadoc.option.tab.title.method=方法
inspection.javadoc.option.tab.title.module=模块
inspection.javadoc.option.tab.title.package=软件包
inspection.javadoc.problem.add.param.tag=为形参''{0}''添加标签 @param
inspection.javadoc.problem.add.param.tag.family=添加缺少的Javadoc形参标签
inspection.javadoc.problem.add.tag=添加标签 @{0}{1}
inspection.javadoc.problem.add.tag.family=添加缺少的 Javadoc 标签
inspection.javadoc.problem.cannot.resolve=无法解析符号{0}
inspection.javadoc.problem.descriptor=要求Javadoc不在
inspection.javadoc.problem.descriptor1=文档中缺少句号。Javadoc 工具使用该句号生成概述页面的注释
inspection.javadoc.problem.disallowed.tag=此处不允许使用标签{0}
inspection.javadoc.problem.duplicate.param=重复的形参''{0}'' @param 标记
inspection.javadoc.problem.duplicate.tag=重复的 @{0} 标记
inspection.javadoc.problem.duplicate.throws=重复 @throws 或 @exception 标记为异常''{0}''
inspection.javadoc.problem.inaccessible=无法从此处访问符号 {0}
inspection.javadoc.problem.missing.tag=需要标记{0}是缺失的
inspection.javadoc.problem.missing.tag.description={0}在 @{1} 标记之后丢失
inspection.javadoc.problem.name.expected=应为名称
inspection.javadoc.problem.pointing.to.itself=Javadoc指向本身
inspection.javadoc.problem.see.tag.expecting.ref=类/方法引用，引用文本或HTML链接，预计后 @see tag
inspection.javadoc.problem.snippet.tag.is.not.available='@snippet' 标记在此语言级别不可用
inspection.javadoc.problem.wrong.tag=错误标签{0}
inspection.javadoc.ref.display.name=声明在Javadoc引用中有问题
inspection.javadocDeclaration.display.name=Javadoc 声明问题
inspection.join.declaration.and.assignment.display.name=赋值可与声明联接
inspection.join.declaration.and.assignment.fix.family.name=联接声明和赋值
inspection.join.declaration.and.assignment.fix.title=联接声明和赋值
inspection.join.declaration.and.assignment.message=赋值可与 ''{0}'' 的声明联接
inspection.labeled.switch.rule.redundant.code.block.display.name=标记的 switch 规则具有冗余代码块
inspection.labeled.switch.rule.redundant.code.block.message=标记规则的代码块冗余
inspection.labeled.switch.rule.redundant.code.fix.name=取消标记规则的代码块换行
inspection.lambda.can.be.method.call.display.name=lambda 可被替换为方法调用
inspection.lambda.to.method.call.fix.family.name=用方法调用替换lambda表达式
inspection.lambda.to.method.call.fix.name=用''{0}''替换lambda表达式
inspection.magic.constant.display.name=魔术常量
inspection.magic.constants.should.be.one.of.values=应当为以下之一\: {0}{1,choice,0\#|1\#或其组合}
inspection.manual.min.max.calculation.description=可被替换为 ''Math.{0}()'' 调用
inspection.manual.min.max.calculation.disable.for.non.integral=禁用 float 和 double
inspection.manual.min.max.calculation.display.name=手动最小值/最大值计算
inspection.map.foreach.display.name=可以使用 Map.forEach()
inspection.map.foreach.option.no.loops=不要报告循环
inspection.mapping.before.count.family.name=count() 之前的映射调用
inspection.mapping.before.count.message=''{0}()'' 调用不会更改最终计数，并且可能会被优化掉。
inspection.meaningless.record.annotation.description=无意义的记录注解
inspection.meaningless.record.annotation.message.method=注解不起任何作用\: 它的目标是 METHOD，但显式声明了相应的访问器
inspection.meaningless.record.annotation.message.method.and.parameter=注解不起任何作用\: 它的目标是 METHOD 和 PARAMETER，但显式声明了访问器和规范构造函数
inspection.meaningless.record.annotation.message.parameter=注解不起任何作用\: 它的目标是 PARAMETER，但显式声明了规范构造函数
inspection.message.anonymous.ref.loc.can.be.replaced.with.method.reference=匿名s \#ref \#loc 可被替换为方法引用
inspection.message.can.be.replaced.with.0.constructor=可被替换为 ''{0}'' 构造函数
inspection.message.can.be.replaced.with.files.readstring=可被替换为 'Files.readString()'
inspection.message.can.be.replaced.with.files.writestring=可被替换为 'Files.writeString()'
inspection.message.can.be.replaced.with.optional.of.nullable=可被替换为 Optional.ofNullable()
inspection.message.can.be.replaced.with.single.expression.in.functional.style=可被替换为函数样式的单个表达式
inspection.message.can.be.replaced.with.string.repeat=可被替换为 'String.repeat()'
inspection.message.external.snippet.differs.from.inline.snippet=外部代码段与内联代码段不同
inspection.message.filter.is.present.chain.can.be.replaced.with.anymatch=''filter().{0}().isPresent()'' 链可被替换为 ''anyMatch()''
inspection.message.full.description=完整描述
inspection.message.lambda.parameter.type.is.redundant=Lambda 形参类型冗余
inspection.message.pattern.variables.can.be.replaced.with.cast=将 'instanceof' 与模式一起使用
inspection.message.pattern.variables.can.be.replaced.with.cast.family.name=无模式替换
inspection.message.pattern.variables.can.be.replaced.with.cast.fix.name=将 ''{0}'' 替换为转换
inspection.message.pattern.variables.can.be.replaced.with.cast.preserve.option=尝试在快速修复期间保留模式中未使用的变量
inspection.message.pseudo.functional.style.code=伪函数样式代码
inspection.message.record.can.be.converted.to.class=记录可以转换为类
inspection.message.redundant.default.parameter.value.assignment=冗余的默认形参值赋值
inspection.message.replace.optional.with.if.statements=将 Optional 替换为 if 语句
inspection.message.snippet.file.not.found=找不到代码段文件 ''{0}''
inspection.message.snippet.region.not.found=找不到区域
inspection.migrate.from.java.lang.io.fix.family=替换为 'System.out' 方法
inspection.migrate.from.java.lang.io.fix.name=替换为 ''{0}''
inspection.migrate.from.java.lang.io.name=可以使用 'System.out' 中的方法来代替 'java.lang.IO'
inspection.migrate.to.java.lang.io.fix.family=使用 'java.lang.IO' 类中的方法
inspection.migrate.to.java.lang.io.fix.name=替换为 ''{0}''
inspection.migrate.to.java.lang.io.name=可以使用 'java.lang.IO' 类中的方法
inspection.migrate.to.java.lang.io.option.implicit=在压缩源文件中报告
inspection.migrate.to.java.lang.io.option.ordinary=在常规类中报告
inspection.missingJavadoc.display.name=缺少 Javadoc
inspection.missingJavadoc.label.minimalVisibility=最小可见性\:
inspection.missingJavadoc.label.requiredTags=必需标记\:
inspection.move.field.assignment.to.initializer.display.name=字段赋值可以移至初始值设定项中
inspection.no.jdk.error.message=没有为此项目正确配置 JDK。无法进行检查。
inspection.no.modules.error.message=此项目不包含模块。无法进行检查。
inspection.notnull.field.not.initialized.display.name=@NotNull 字段未初始化
inspection.notnull.field.not.initialized.message=必须初始化 {0} 字段
inspection.notnull.field.not.initialized.option.implicit=忽略可以隐式初始化的字段
inspection.notnull.field.not.initialized.option.implicit.description=选中后，已知隐式初始化(例如通过依赖项注入)的字段将不会被报告
inspection.notnull.field.not.initialized.option.setup=忽略在 setUp() 方法中初始化的字段
inspection.notnull.field.not.initialized.option.setup.description=选中后，将不会报告在 setUp 方法中初始化(例如通过 <code>@Before</code> 或 <code>@BeforeEach</code> 注解)的测试用例类中的字段。
inspection.null.value.for.optional.assigned.ignore.fix.name=将 Optional 与 null 比较时不发出警告
inspection.null.value.for.optional.assigned.message=Optional 值与 null 比较
inspection.null.value.for.optional.context.assignment=分配
inspection.null.value.for.optional.context.declaration=声明
inspection.null.value.for.optional.context.lambda=lambda表达式
inspection.null.value.for.optional.context.parameter=形参
inspection.null.value.for.optional.context.return=return 语句
inspection.null.value.for.optional.fix.family.name=替换空的可选方法
inspection.null.value.for.optional.message=Null 用于 {0} 中的 ''Optional'' 类型
inspection.null.value.for.optional.option.comparisons=报告 Optional 与 null 的比较
inspection.nullable.problems.display.name=@NotNull/@Nullable 问题
inspection.nullable.problems.ignore.external.notnull=忽略外部 @NotNull(&I)
inspection.nullable.problems.method.overrides.notnull.option=报告重写 @Nullable 的 @NotNull 形参，反之亦然(&P)
inspection.nullable.problems.method.overrides.option=报告未注解的形参或方法重写 @NotNull (&A)
inspection.nullable.problems.not.annotated.getters.for.annotated.fields=报告注解字段的非注解 setter 形参或 getter(&S)
inspection.nullable.problems.notnull.overrides.option=报告重写非注解对象的 @NotNull 形参(&P)
inspection.nullable.problems.notnull.parameters.with.null.literal.option=报告使用 null 字面量实参的 @NotNull 形参
inspection.nullable.problems.nullability.on.locals=当局部变量的为 null 性注解不适用时，报告这些注解
inspection.obvious.null.check.display.name=使用明显非 null 实参调用 null 检查方法
inspection.optional.assigned.to.null.display.name=Optional 类型的 null 值
inspection.optional.get.without.is.present.display.name=在不进行 isPresent() 检查的情况下调用 Optional.get()
inspection.optional.get.without.is.present.message=<code>{0}.\#ref()</code> 未进行 ''isPresent()'' 检查
inspection.optional.get.without.is.present.method.reference.message=<code>\#ref</code> 未进行 'isPresent()' 检查
inspection.optional.is.present.display.name=非函数样式 'Optional.isPresent()' 用法
inspection.optional.to.if.display.name='Optional' 可被替换为 'if' 语句序列
inspection.output.stream.constructor.message=可以使用 'Files.newOutputStream()' 构建 'OutputStream'
inspection.overflowing.loop.index.inspection.description=循环执行零次或无限次
inspection.overflowing.loop.index.inspection.name=循环执行零次或无限次
inspection.overwritten.key.array.message=被覆盖的数组元素
inspection.overwritten.key.display.name=被覆盖的 Map、Set 或数组元素
inspection.overwritten.key.map.message=重复的Map key
inspection.overwritten.key.set.message=重复的 Set 元素
inspection.parameter.can.be.local.display.name=从不读取作为形参传递的值
inspection.parameter.can.be.local.problem.descriptor=形参可以被转化为一个局部变量
inspection.preview.feature=预览功能警告
inspection.quickfix.assert.family=断言
inspection.raw.use.of.parameterized.type.problem.descriptor=形参化类 <code>\#ref</code> 的原始使用 \#loc
inspection.read.write.string.can.be.used.display.name=可以使用 'Files.readString()' 或 'Files.writeString()'
inspection.redundant.array.creation.display.name=冗余数组创建
inspection.redundant.array.creation.for.varargs.call.descriptor=调用 vararg 方法的冗余数组创建
inspection.redundant.array.creation.quickfix=移除显式数组创建
inspection.redundant.explicit.close=冗余 'close()'
inspection.redundant.file.creation.description=<code>\#ref</code> 冗余 \#loc
inspection.redundant.file.creation.display.name=创建冗余 'File' 实例
inspection.redundant.file.creation.quickfix=替换为文件名
inspection.redundant.lambda.parameter.type.display.name=冗余 lambda 形参类型
inspection.redundant.null.check.always.fail.message=Null 检查始终失败\: {0} 永不为 null
inspection.redundant.null.check.fix.family.name=移除冗余 null 检查
inspection.redundant.null.check.fix.notnull.family.name=移除错误的 '\!\= null'
inspection.redundant.null.check.message=冗余 null 检查\: {0} 永不为 null
inspection.redundant.operation.on.empty.array.message=数组 <code>\#ref</code> 始终为空
inspection.redundant.operation.on.empty.collection.message=集合 <code>\#ref</code> 始终为空
inspection.redundant.operation.on.empty.container.display.name=空容器上存在冗余操作
inspection.redundant.operation.on.empty.map.message=映射 <code>\#ref</code> 始终为空
inspection.redundant.record.constructor.can.be.compact.message=规范构造函数可以转换为压缩形式
inspection.redundant.record.constructor.canonical.message=冗余规范构造函数
inspection.redundant.record.constructor.compact.message=冗余压缩构造函数
inspection.redundant.record.constructor.description=冗余记录构造函数
inspection.redundant.record.constructor.fix.family.name=将规范构造函数转换为压缩形式
inspection.redundant.record.constructor.statement.message=压缩构造函数中存在冗余字段赋值
inspection.redundant.stream.optional.call.display.name='Stream' 或 'Optional' 调用链中存在冗余步骤
inspection.redundant.stream.optional.call.explanation.at.most.one=流最多包含一个元素
inspection.redundant.stream.optional.call.explanation.distinct=链中存在先前的 'distinct()' 调用
inspection.redundant.stream.optional.call.explanation.distinct.set=收集到集时，元素将保持不重复
inspection.redundant.stream.optional.call.explanation.filter=判定始终为 'true'
inspection.redundant.stream.optional.call.explanation.map.flatMap=上一个 'map()' 调用可以替换 'flatMap()' 步骤
inspection.redundant.stream.optional.call.explanation.parallel=存在会重写此调用的后续 ''{0}()'' 调用
inspection.redundant.stream.optional.call.explanation.parallel.single=从单个元素创建的流不会并行化
inspection.redundant.stream.optional.call.explanation.parallel.source=流是通过 'parallelStream()' 创建的，所以它已经是并行的
inspection.redundant.stream.optional.call.explanation.sequential.source=流是通过 'stream()' 创建的，所以它已经是顺续的
inspection.redundant.stream.optional.call.explanation.sorted=后续的 ''{0}()'' 调用不依赖于排序顺序
inspection.redundant.stream.optional.call.explanation.sorted.parallel=后续的 ''{0}()'' 操作不依赖于并行流的排序顺序
inspection.redundant.stream.optional.call.explanation.sorted.twice=链中存在后续的 'sorted()' 调用
inspection.redundant.stream.optional.call.explanation.unordered=链中存在先前的 'unordered()' 调用
inspection.redundant.stream.optional.call.fix.bind.name=将 ''{0}()'' 步骤与前一个 ''{1}()'' 步骤合并
inspection.redundant.stream.optional.call.fix.collect.to.ordered.family.name=收集到 'LinkedHashSet'
inspection.redundant.stream.optional.call.fix.family.name=移除冗余的调用链
inspection.redundant.stream.optional.call.fix.name=移除 ''{0}()'' 调用
inspection.redundant.stream.optional.call.fix.replace.terminal=替换终端操作
inspection.redundant.stream.optional.call.fix.replace.terminal.text=将终端操作替换为 ''{0}()''
inspection.redundant.stream.optional.call.message.with.explanation=冗余的 ''{0}()'' 调用\: {1}
inspection.redundant.stream.optional.call.option.streamboxing=报告 Stream.map() 中的冗余装箱
inspection.redundant.unmodifiable.call.description=不可修改的集合包装器的冗余用法
inspection.redundant.unmodifiable.call.display.name=''{0}'' 包装器的冗余用法
inspection.redundant.unmodifiable.call.unwrap.argument.quickfix=解包实参
inspection.reflect.handle.invocation.argument.not.array=实参不是数组类型
inspection.reflect.handle.invocation.argument.not.exact=实参类型应该是 ''{0}''
inspection.reflect.handle.invocation.primitive.argument.null=类型 ''{0}'' 的实参不能为 ''null''
inspection.reflect.handle.invocation.receiver.incompatible=回调接收类型不兼容\: ''{0}''
inspection.reflect.handle.invocation.receiver.null=调用接收器为 'null'
inspection.reflect.handle.invocation.result.not.assignable=应该被转换为''{0}''或其超类
inspection.reflect.handle.invocation.result.not.exact=应该被转换为''{0}''
inspection.reflect.handle.invocation.result.null=返回值总是'null'
inspection.reflect.handle.invocation.result.void=返回值类型为'void'
inspection.reflection.invocation.argument.count=应为{0,choice,0\# 0 个实参|1\# 1 个实参|1< {0} 个实参}
inspection.reflection.invocation.argument.not.assignable=实参不能分配给 ''{0}''
inspection.reflection.invocation.array.not.assignable=数组{0,choice,1\#项目具有|1<项目具有}不兼容的{0,choice,1\#类型 |1< 类型}
inspection.reflection.invocation.item.count={0,choice,0\#空数组|1\#1个数组项|1<{0}个数组项}是预期的
inspection.reflection.invocation.item.not.assignable=数组项不能分配给''{0}''
inspection.reflection.invocation.name=反射调用实参不匹配
inspection.reflection.invocation.reflective.argument.count=通过反射调用的方法需要 {0,choice,0\#0 个实参|1\#1 个实参|1<{0} 个实参}
inspection.reflection.member.access.cannot.resolve.constructor.arguments=无法使用指定的实参类型解析构造函数
inspection.reflection.member.access.cannot.resolve.field=无法解析字段 ''{0}''
inspection.reflection.member.access.cannot.resolve.method=无法解析方法''{0}''
inspection.reflection.member.access.cannot.resolve.method.arguments=无法使用指定的实参类型解析方法''{0}''
inspection.reflection.member.access.check.exists=检查该字段/方法是否存在于非 final 类中
inspection.reflection.member.access.check.exists.exclude.chooser=要排除的类
inspection.reflection.member.access.check.exists.exclude.label=排除类\:
inspection.reflection.member.access.constructor.not.public=构造函数不为 public
inspection.reflection.member.access.field.not.in.class=字段''{0}''未在类''{1}''中声明
inspection.reflection.member.access.field.not.public=字段 ''{0}'' 不为 public
inspection.reflection.member.access.fix.family.name=使用适当的反射方法
inspection.reflection.member.access.method.not.in.class=方法''{0}''未在类''{1}''中声明
inspection.reflection.member.access.method.not.public=方法 ''{0}'' 不为 public
inspection.reflection.member.access.name=对不存在或不可见的类成员的反射访问
inspection.reflection.visibility.name=跨模块问题的反射访问
inspection.remove.literal.underscores.display.name=数字字面量中的下划线
inspection.remove.literal.underscores.family.name=从数字字面量中移除下划线
inspection.replace.inefficient.stream.count.display.name=以 count() 结尾的低效 Stream API 调用链
inspection.replace.javadoc.display.name=可用 Javadoc 替换的注释
inspection.replace.methodref.ternary.quickfix=替换为 null 检查 lambda
inspection.replace.ternary.quickfix=替换为''{0}\!\= null吗?''
inspection.replace.with.bulk.file.attributes.read.fix.family.name=替换为批量 'Files.readAttributes()' 调用
inspection.replace.with.bulk.fix.family.name=替换大量方法调用
inspection.replace.with.bulk.fix.name=用批量 ''{0}()'' 调用替换迭代
inspection.replace.with.bulk.message=迭代可被替换为批量 ''{0}()'' 调用
inspection.replace.with.bulk.wrap.arrays=使用 'Arrays.asList()' 包装数组
inspection.replace.with.enhanced.switch.statement.fix.name=替换为增强的 'switch' 语句
inspection.replace.with.javadoc=替换为 Javadoc 注释
inspection.replace.with.javadoc.comment=可以将注释转换为 Javadoc
inspection.replace.with.old.style.switch.statement.fix.name=替换为旧式 'switch' 语句
inspection.replace.with.regular.string.literal.fix=替换为正则字符串字面量
inspection.replace.with.string.concatenation.fix=替换为字符串串联
inspection.replace.with.string.template.fix=替换为字符串模板
inspection.replace.with.switch.expression.fix.family.name=迁移到增强的 switch
inspection.replace.with.switch.expression.fix.name=替换为 'switch' 表达式
inspection.replace.with.switch.rule.expression.fix.family.name=迁移至带有规则的增强型 switch
inspection.replace.with.text.block.fix=替换为文本块
inspection.replace.with.trivial.lambda.fix.family.name=替换为普通 lambda
inspection.replace.with.trivial.lambda.fix.name=替换为返回 ''{0}'' 的 lambda
inspection.require.non.null=将 null 检查替换为 Objects/Stream static 调用
inspection.require.non.null.description=Null 检查可被替换为方法调用
inspection.require.non.null.message={0, choice, 1\#''if'' 语句|2\#条件表达式}可被替换为对 ''{1}()'' 的调用
inspection.require.non.null.no.warning.replacement.bigger=替换长度大于原始长度时不发出警告
inspection.require.non.null.quickfix=将{0, choice, 1\# ''if'' 语句|2\#条件表达式}替换为 ''{1}()'' 调用
inspection.return.separated.from.computation.descriptor=返回与 ''{0}'' 的值的计算分离
inspection.return.separated.from.computation.family.quickfix=将'返回'更接近结果的计算
inspection.return.separated.from.computation.name=与结果计算分离的 'return'
inspection.return.separated.from.computation.quickfix=将“return”更接近计算''{0}''的值
inspection.same.parameter.display.name=方法形参始终具有相同的值
inspection.same.parameter.fix.family.name=内联形参为常量值
inspection.same.parameter.fix.name=内联形参 ''{0}'' 的值 ''{1}''
inspection.same.parameter.problem.descriptor=形参 <code>\#ref</code> 的值始终为 ''{0}''
inspection.simplifiable.comparator.comparing.message=不必要的 ''{0}()'' 调用
inspection.simplifiable.comparator.display.name=可以简化 Comparator 方法
inspection.simplifiable.comparator.entry.comparator.message=可以改用 ''{0}''
inspection.simplifiable.comparator.fix.comparing.family.name=移除冗余调用
inspection.simplifiable.comparator.fix.entry.comparator.family.name=使用预定义的 'Map.Entry' 比较运算符方法
inspection.simplifiable.comparator.fix.remove.name=移除 ''{0}()'' 调用
inspection.simplifiable.comparator.fix.replace.name=移除 ''{0}()'' 调用并使用 ''{1}()''
inspection.simplifiable.comparator.fix.reversed.family.name=简化将 'max' 替换为 'min' 的比较运算符方法
inspection.simplifiable.comparator.fix.reversed.name=替换为简化比较运算符的 ''{0}''
inspection.simplifiable.comparator.reversed.message=如果 ''{0}()'' 调用替换为 ''{1}()''，则可以简化比较运算符方法
inspection.simplify.collector.display.name=可简化的收集器
inspection.simplify.collector.fix.family.name=简化级联器
inspection.simplify.collector.fix.name=使用 ''Collectors.{0}()'' 收集器
inspection.simplify.collector.message=可以使用 ''{0}()'' 收集器简化
inspection.simplify.for.each.extract.intermediate.operations=提取中间操作
inspection.simplify.foreach.display.name=可简化的 forEach() 调用
inspection.simplify.optional.call.chains.display.name=可以简化 Optional 调用链
inspection.simplify.stream.api.call.chains.display.name=可以简化 Stream API 调用链
inspection.slow.abstract.set.remove.all.description=调用 'set.removeAll(list)' 可能较为缓慢
inspection.slow.abstract.set.remove.all.fix.family.name=使用 'Set.remove' 而不是 'Set.removeAll'
inspection.slow.list.contains.all.description=对 'list.containsAll(collection)' 的调用可能具有较差性能
inspection.slow.list.contains.all.fix.family.name=包装在 'HashSet' 构造函数中
inspection.slow.list.contains.all.fix.name=将 ''{0}'' 包装在 ''HashSet'' 构造函数中
inspection.sorted.collection.with.non.comparable.keys.display.name=包含不可比较元素的排序集合
inspection.sorted.collection.with.non.comparable.keys.message=包含不可比较元素的排序集合的构造
inspection.sorted.collection.with.non.comparable.keys.option.type.parameters=不报告不可比较的类型形参
inspection.static.import.can.be.used.display.name=可以根据自动导入表使用 static import
inspection.static.import.can.be.used.fix.name=添加 static import
inspection.static.pseudo.functional.style.method.display.name=Guava 伪函数调用可被转换为 Stream API 调用
inspection.stream.api.migration.can.be.replaced.with.call=可被替换为 ''{0}'' 调用
inspection.stream.to.loop.display.name=Stream API 调用链可被替换为循环
inspection.string.repeat.can.be.used.display.name=可以使用 String.repeat()
inspection.string.template.migration.concatenation.message=串联可被替换为字符串模板
inspection.string.template.migration.name=可以使用字符串模板
inspection.string.template.migration.string.message=字符串可被替换为模板
inspection.string.template.reverse.migration.name=字符串模板可以是串联字符串
inspection.string.template.reverse.migration.string.message=字符串模板可被替换为字符串串联
inspection.surround.if.family=使用 if 包围
inspection.surround.if.quickfix=使用 ''if ({0}{1})'' 包围
inspection.suspicious.list.remove.display.name=循环中的 'List.remove()' 可疑
inspection.suspicious.return.byte.input.stream.convert.to.unsigned=转换为无符号字节
inspection.suspicious.return.byte.input.stream.name=从 'InputStream.read()' 返回的可疑字节
inspection.suspicious.ternary.in.varargs.description=vararg 调用中的三元运算符包含数组和非数组分支
inspection.suspicious.ternary.in.varargs.display.name=vararg 方法调用中的可疑三元运算符
inspection.suspicious.ternary.in.varargs.quickfix=包装在数组初始值设定项中
inspection.switch.expression.backward.expression.migration.inspection.name='switch' 表达式可被替换为旧式 'switch' 语句
inspection.switch.expression.backward.migration.inspection.name=增强的 'switch'
inspection.switch.expression.backward.statement.migration.inspection.name='switch' 语句可被替换为旧式 'switch' 语句
inspection.switch.expression.migration.expression.max.statements=一个分支中要转换为 switch 表达式的最大语句数
inspection.switch.expression.migration.inspection.name=语句可被替换为增强的 'switch'
inspection.switch.expression.migration.inspection.switch.description=Switch 语句可被替换为增强的 'switch'
inspection.switch.expression.migration.inspection.switch.expression.description=switch 表达式可被替换为带有规则的增强型 'switch'
inspection.switch.expression.migration.option.expression.max.statements=不报告在单个分支中有超过 {0} 条{0, choice, 1\#语句|2\#语句}的 switch
inspection.switch.expression.migration.warn.only.on.expression=仅在可以转换为表达式时显示警告
inspection.switch.labeled.rule.can.be.code.block.display.name=标记的 switch 规则可以具有代码块
inspection.switch.labeled.rule.can.be.code.block.expression.message=标记规则的结果表达式可以使用代码块包装
inspection.switch.labeled.rule.can.be.code.block.fix.expression.name=使用代码块包装标记规则的结果表达式
inspection.switch.labeled.rule.can.be.code.block.fix.statement.name=使用代码块包装标记规则的语句
inspection.switch.labeled.rule.can.be.code.block.statement.message=标记规则的语句可以使用代码块包装
inspection.testframework.assert.quickfix=使用{0} ''{1}'' 断言
inspection.text.block.backward.migration.message=文本块可以转换为正则字符串字面量
inspection.text.block.backward.migration.name=文本块可被替换为正则字符串字面量
inspection.text.block.migration.concatenation.message=串联可被替换为文本块
inspection.text.block.migration.name=可以使用文本块
inspection.text.block.migration.string.message=字符串可被替换为文本块
inspection.text.block.migration.suggest.literal.replacement=报告单个字符串字面量
inspection.trailing.whitespaces.in.text.block.message=文本块内有尾随空格字符
inspection.trailing.whitespaces.in.text.block.name=文本块中的尾随空格
inspection.trailing.whitespaces.in.text.block.remove.whitespaces=移除尾随空格字符
inspection.trailing.whitespaces.in.text.block.replaces.whitespaces.with.escapes=转义尾随空格字符
inspection.trivial.functional.expression.usage.display.name=函数表达式的普通用法
inspection.unchecked.warning.display.name=未检查的警告
inspection.undeclared.service.usage.message=服务 ''{0}'' 的使用未在模块信息中声明
inspection.undeclared.service.usage.name=服务的使用未在 'module-info' 中声明
inspection.unresolved.module.dependencies.problem.descriptor=未解析的模块依赖项
inspection.unused.assignment.display.name=未使用的赋值
inspection.unused.assignment.option=报告可被替换为二元表达式的前缀表达式
inspection.unused.assignment.option1=报告未使用更改后的值的后缀表达式
inspection.unused.assignment.option2=报告冗余的初始值设定项
inspection.unused.assignment.option3=报告其值从未被使用的模式变量
inspection.unused.assignment.option4=报告其值从未被使用的迭代形参
inspection.unused.assignment.problem.descriptor1=变量 <code>\#ref</code> \#loc 从未使用
inspection.unused.assignment.problem.descriptor2=变量 <code>{0}</code> 初始值设定项 <code>\#ref</code> \#loc 冗余
inspection.unused.assignment.problem.descriptor3=赋给 <code>\#ref</code> \#loc 的值 <code>{0}</code> 从未使用
inspection.unused.assignment.problem.descriptor4=在 <code>\#ref</code> \#loc 更改的值从未使用
inspection.unused.assignment.problem.descriptor5=模式变量 <code>\#ref</code> \#loc 的值从未使用
inspection.unused.assignment.problem.descriptor6=foreach 迭代形参 <code>\#ref</code> \#loc 的值从未使用
inspection.unused.assignment.remove.assignment.quickfix=删除冗余分配
inspection.unused.assignment.remove.assignment.quickfix.title=移除冗余的赋值
inspection.unused.assignment.remove.initializer.quickfix=移除冗余的初始值设定项
inspection.unused.assignment.remove.initializer.quickfix.title=移除冗余的初始值设定项
inspection.unused.display.name=未使用的声明
inspection.unused.parameter.composer=形参 <code>\#ref</code> 未用于任何实现
inspection.unused.parameter.composer1=形参 <code>\#ref</code> 未在此方法中使用，也未在其重写方法中使用
inspection.unused.parameter.delete.family=安全删除未使用的形参
inspection.unused.parameter.delete.quickfix=安全删除未使用的形参 ''{0}''
inspection.unused.parameter.problem.descriptor=未使用形参 <code>\#ref</code>
inspection.unused.return.value.display.name=方法可以为 'void'
inspection.unused.return.value.make.void.quickfix=使方法无效
inspection.unused.return.value.problem.descriptor=方法的返回值从未使用过
inspection.unused.symbol.check.accessors=Getter/Setter
inspection.unused.symbol.check.classes=类\:
inspection.unused.symbol.check.fields=字段\:
inspection.unused.symbol.check.inner.classes=内部类\:
inspection.unused.symbol.check.localvars=局部变量
inspection.unused.symbol.check.methods=方法\:
inspection.unused.symbol.check.parameters=形参位置\:
inspection.unused.symbol.check.parameters.excluding.hierarchy=排除层次结构
inspection.use.bulk.operation.display.name=可以使用批量操作代替迭代
inspection.value.based.warnings=基于值的警告
inspection.value.based.warnings.synchronization=基于值的类的实例同步
inspection.variable.assigned.to.itself.display.name=变量被赋值给自己
inspection.wrapper.type.may.be.primitive.display.name=包装器类型可能是基元
inspection.wrapper.type.may.be.primitive.fix.name=将包装器类型转换为基元类型
inspection.wrapper.type.may.be.primitive.name=类型可能是基元
intention.add.explicit.type.arguments.family=添加显式类型实参
intention.add.on.demand.static.import.family=添加按需 static import
intention.add.on.demand.static.import.text=为 ''{0}'' 添加按需 static import
intention.add.on.demand.static.import.to.auto.import.family=将按需 static import 添加到自动导入
intention.add.on.demand.static.import.to.auto.import.text=将按需 static import ''{0}'' 添加到自动导入
intention.add.single.member.import.text=为 ''{0}'' 添加 import
intention.add.single.member.static.import.family=添加单成员 static import
intention.add.single.member.static.import.text=为 ''{0}'' 添加 static import
intention.assign.field.from.parameter.family=分配形参场
intention.assign.field.from.parameter.text=将形参分配给字段 ''{0}''
intention.bind.fields.from.parameters.family=将形参绑定到字段
intention.bind.fields.from.parameters.text=将 {0} 个形参绑定到字段
intention.break.string.on.line.breaks.text=在 '\\n' 上断开字符串
intention.category.annotations=Java/注解
intention.category.collections=Java/集合
intention.category.comments=Java/注释
intention.category.concurrency=Java/并发
intention.category.conditional.operator=Java/条件
intention.category.control.flow=Java/控制流
intention.category.declaration=Java/声明
intention.category.expressions=Java/表达式
intention.category.i18n=Java/国际化
intention.category.imports=Java/导入
intention.category.junit=Java/JUnit
intention.category.other=Java/其他
intention.category.refactorings=Java/重构
intention.category.streams=Java/流
intention.category.strings=Java/字符串
intention.category.try.statements=Java/Try 语句
intention.compose.function.family=将嵌套函数调用替换为组合
intention.compose.function.text=替换嵌套函数调用和替换后的调用
intention.convert.color.representation.family=转换颜色表示
intention.convert.color.representation.text=转换为''新颜色{0}''
intention.convert.compact.constructor.to.canonical=将压缩构造函数转换为规范构造函数
intention.convert.to.single.return.command.text=将主体转换成单个出口点形式
intention.convert.to.single.return.name=将正文转换成单个出口点形式
intention.convert.to.single.return.progress.title=将正文转换成单个出口点形式
intention.create.annotation.method.from.usage=创建 @interface 方法 ''{0}()''
intention.create.field.from.parameter.family=创建字段形参
intention.create.field.from.parameter.text=为形参 ''{0}'' 创建字段
intention.create.switch.statement=创建 switch 语句
intention.create.test.dialog.choose.super.class=选择超类
intention.create.test.dialog.class.name=类名\:
intention.create.test.dialog.fix.library=修正
intention.create.test.dialog.generate=生成\:
intention.create.test.dialog.java=Java
intention.create.test.dialog.library.not.found={0}库在该模块中未找到
intention.create.test.dialog.select.methods=为以下对象生成测试方法(&M)\:
intention.create.test.dialog.setUp=set&Up/@Before
intention.create.test.dialog.show.inherited=显示继承的方法(&I)
intention.create.test.dialog.super.class=超类\:
intention.create.test.dialog.tearDown=tear&Down/@After
intention.create.test.dialog.testing.library=测试库(&L)\:
intention.encapsulate.field.text=封装领域
intention.error.cannot.create.class.message=无法创建类''{0}''
intention.error.cannot.create.class.title=创建类失败
intention.error.make.sealed.class.different.modules=有些继承者位于不同模块中
intention.error.make.sealed.class.different.packages=模块未命名，某些继承者位于不同的软件包中
intention.error.make.sealed.class.has.anonymous.or.local.inheritors=部分继承者为匿名或局部
intention.error.make.sealed.class.inheritors.not.in.java.file=有些继承者不在 Java 文件中
intention.error.make.sealed.class.interface.has.no.inheritors=接口没有继承者
intention.error.make.sealed.class.is.used.in.functional.expression=类用于函数表达式
intention.extract.if.condition.family=提取 'if' 条件
intention.extract.if.condition.text=提取if({0})
intention.extract.map.step.family=提取分离映射方法
intention.extract.map.step.text=提取变量''{0}''到''{1}''操作
intention.extract.method.text=提取方法
intention.extract.set.from.comparison.chain.family=从比较链提取 Set
intention.extract.set.from.comparison.chain.popup.title=从比较链提取 Set
intention.extract.set.from.comparison.chain.replace.all=替换所有匹配项
intention.extract.set.from.comparison.chain.replace.only.this=仅替换此匹配项
intention.family.add.javadoc=添加 Javadoc
intention.family.copy.abstract.method.implementation=复制 abstract 方法实现
intention.family.create.a.class.in.package=在软件包中创建类
intention.family.edit.method.contract=编辑方法协定
intention.family.edit.range=编辑范围
intention.family.expand.static.import=展开 static import
intention.family.fix.bounded.wildcards=修复有界通配符
intention.family.make.external.annotations.explicit=使外部注解为显式
intention.family.make.inferred.annotations.explicit=使推断的注解为显式
intention.family.move.it=移动它
intention.family.name.add.main.method=添加 'main' 方法
intention.family.name.box.primitive.in.conditional.branch=装箱条件分支中的基元值
intention.family.name.convert.record.to.class=将记录转换为类
intention.family.name.delete.possible.side.effects=删除可能的副作用
intention.family.name.delete.private.method=删除 private 方法
intention.family.name.dismiss=关闭
intention.family.name.extract.possible.side.effects=提取可能的副作用
intention.family.name.ignore.project=不再在此项目中显示
intention.family.name.make.sealed=密封类
intention.family.name.move.class.to.test.root=将类移至测试根
intention.family.name.rename.to.ignored=重命名为忽略
intention.family.name.set.explicit.variable.type=设置显式变量类型
intention.family.name.synchronize.inline.snippet=同步内联代码段
intention.family.name.upgrade.jdk=升级 JDK
intention.family.put.arguments.on.one.line=将实参放在同一行中
intention.family.put.arguments.on.separate.lines=将实参放在单独的行中
intention.family.put.parameters.on.one.line=将形参放在同一行中
intention.family.put.parameters.on.separate.lines=将形参放在单独的行中
intention.family.put.record.components.on.one.line=将记录组件放在一行
intention.family.put.record.components.on.separate.lines=将记录组件放在单独的行中
intention.family.replace.optional.ispresent.condition.with.functional.style.expression=将 Optional 存在条件替换为函数样式表达式
intention.family.sort.content=对内容进行排序
intention.family.swap.if.statements=交换 'if' 语句
intention.family.unimplement.interface.class=取消实现接口/类
intention.family.variable.access.from.inner.class=移入匿名对象
intention.implement.abstract.class.default.text=实现抽象类
intention.implement.abstract.class.family=实现抽象类或接口
intention.implement.abstract.method.command.name=实现方法
intention.implement.abstract.method.error.no.classes.message=没有发现这类方法可以实现
intention.implement.abstract.method.error.no.classes.title=没有找到的类
intention.implement.abstract.method.family=实现 abstract 方法
intention.implement.abstract.method.searching.for.descendants.progress=正在搜索后代…
intention.implement.abstract.method.text=实现方法 ''{0}''
intention.inline.map.family=内联流映射方法
intention.inline.map.inline.text=将 ''{0}()'' 主体内联到下一个 ''{1}()'' 调用中
intention.inline.map.merge.text=合并 ''{0}()'' 调用和 ''{1}()'' 调用
intention.introduce.variable.text=引入局部变量
intention.invert.if.condition=反转 'if' 条件
intention.make.final.fixer.if=通过将初始值设定项移至 ''if'' 语句高效地将 ''{0}'' 设为 final
intention.make.final.fixer.stream=使用流 API 高效地将 ''{0}'' 设为 final
intention.merge.filter.family=合并过滤器
intention.merge.filter.text=合并过滤器链
intention.move.field.assignment.to.declaration=移动指派到字段声明
intention.move.initializer.to.constructor=将初始值设定项移至构造函数
intention.move.initializer.to.set.up=将初始值设定项移至 setUp 方法
intention.name.collapse.into.loop=收起到循环中
intention.name.copy.to.final.temp.variable={1, choice, 0\#|1\#高效地}将 ''{0}'' 复制到 final 临时变量
intention.name.delete.method=删除方法 ''{0}()''
intention.name.delete.method.only=…再无其他
intention.name.delete.method.title=删除方法 ''{0}()''
intention.name.delete.method.with.callees=…以及仅在那里使用的其他 private 方法
intention.name.extract.method.to.new.interface=将方法 ''{0}'' 提取到新接口
intention.name.iterate.over=迭代 {0}
intention.name.make.variable.final=将{1, choice, 0\#“{0}”|1\#变量}设为 final
intention.name.move.class.to.test.root=将 ''{0}'' 移至测试根
intention.name.move.into.if.branches=上移至 'if' 语句分支
intention.name.pull.method.up=向上拉取方法 ''{0}''
intention.name.pull.method.up.and.make.it.abstract.conditionally=将方法 ''{0}'' 拉取到 ''{1}''{2, choice, 0\#并将其设为 abstract|1\#}
intention.name.pull.method.up.make.it.abstract=向上拉取方法 ''{0}'' 并使其抽象
intention.name.set.variable.type=将变量类型设置为 ''{0}''
intention.name.transform.variables.into.final.one.element.array=将{1, choice, 0\#“{0}”|1\#变量}转换成 final 单元素数组
intention.name.upgrade.jdk.to=将 JDK 升级到 {0}+
intention.override.method.text=重写方法 ''{0}''
intention.replace.concatenation.with.formatted.output.family=更换连接与格式化输出
intention.replace.concatenation.with.formatted.output.text=将 '+' 替换为 'java.text.MessageFormat.format()'
intention.sequenced.collection.can.be.used.display.name=可以使用 SequencedCollection 方法
intention.sequenced.collection.can.be.used.fix.name=替换为 SequencedCollection 方法调用
intention.split.declaration.assignment.text=拆分为声明和赋值
intention.split.declaration.family=拆分声明
intention.split.filter.family=拆分过滤器
intention.split.filter.text=拆分为过滤器链
intention.split.if.family=分裂如果
intention.split.if.text=拆分为 2 条 'if' 语句
intention.split.switch.branch.with.several.case.values.copy.text=复制 'switch' 分支
intention.split.switch.branch.with.several.case.values.family=将包含多个 case 值的 switch 分支拆分成单独的 'switch' 分支
intention.split.switch.branch.with.several.case.values.split.text=拆分 'switch' 分支的值
intention.surround.resource.with.ARM.block=使用 try-with-resources 包围
intention.surround.with.ARM.block.template=try-with-resources
intention.text.add.method.contract.to.0=将方法协定添加到 ''{0}()''…
intention.text.add.range.to.0=将范围添加到 ''{0}''…
intention.text.annotate.externally=在外部注解
intention.text.collapse.repeating.annotations=收起重复注解
intention.text.create.a.class.in.0=在 ''{0}'' 中创建类
intention.text.create.a.class.in.package.preview=打开一个对话框以在软件包 ''{0}'' 中创建类
intention.text.edit.method.contract.of.0=编辑 ''{0}()'' 的方法协定…
intention.text.edit.range.of.0=编辑 ''{0}'' 的范围…
intention.text.fix.method.0.parameters.with.bounded.wildcards=修复包含有界通配符的方法 ''{0}'' 形参
intention.text.generate.missing.test.methods=生成缺少的测试方法
intention.text.implements.list.remove.others=移除其他 ''{0} 引用
intention.text.replace.all.delete.import=全部替换并删除 import
intention.text.replace.implements.with.static.import=将实现替换为 static import
intention.text.replace.static.import.with.qualified.access.to.0=将 static import 替换为 {0} 的限定访问
intention.text.replace.this.occurrence.keep.import=替换此匹配项并保留 import
intention.text.unimplement.0=取消实现{0}
intention.unroll.loop.family=展开循环
intention.unwrap.else.branch=解包 'else' 分支
intention.unwrap.else.branch.changes.semantics=解包 'else' 分支(更改语义)
intention.use.single.member.static.import.text=对 ''{0}'' 使用 static import
intention.wrap.with.unmodifiable=使用不可修改的集合或映射包装
intention.wrap.with.unmodifiable.list=使用不可修改的列表包装
intention.wrap.with.unmodifiable.map=使用不可修改的映射包装
intention.wrap.with.unmodifiable.set=使用不可修改的集包装
interface.not.allowed=不允许接口
interfaces.cannot.be.inlined=接口无法内联
introduce.functional.variable.accessibility.conflict=变量 {0} 不是有效的 final 变量，无法在函数表达式中访问
introduce.functional.variable.interface.chooser.title=选择适用的函数式接口\: {0} -> {1}
introduce.functional.variable.nothing.found.message=找不到适用的函数式接口
introduce.parameter.advertisement.text=按 {0} 通过重载方法进行委托，或按 {1} 显示更多选项
introduce.parameter.inlay.title.delegate=委托
introduce.parameter.inlay.tooltip.delegate=通过重载方法委托
introduce.parameter.object.no.accessor.conflict.message=字段 ''{1}'' 需要 {0, choice, 0\#Getter|1\#Setter}
introduce.variable.change.type.adv=按 {0} 更改类型
introduce.variable.reassign.adv=按 {0} 重新分配现有变量
invalid.extracted.class.name=''{0}'' 是无效的已提取类名
invert.quickfix.preview=打开一个对话框以反转所选布尔值并选择其新名称。
java.completion.tag={0, choice, 1\#标签\:|2\#标签\:}
java.configurable.logger.identifier.long=标识符过长
java.configurable.logger.not.found=在项目内部找不到记录器
java.configurable.logger.unspecified=未指定
java.implicit.types.lambda.inlay.provider.name=Lambda 形参类型
java.implicit.types.local.inlay.provider.name=隐式类型
java.line.markers=Java 行标记
java.method.chains.inlay.provider.name=方法链
java.platform.module.system.name=Java 平台模块系统
java.preview.features.accept.notification.link=接受
java.preview.features.alert.title=实验性功能警报
java.preview.features.legal.notice=您必须接受测试版 Java 规范的法律通知条款才能启用对“{0}”的支持。<br/><br/><b>根据 Java Community Process (JCP) 开发的早期规范草案的实现仅用于测试和评估目的，与 JCP 的任何规范都不兼容。</b>{1}
java.preview.features.notification.title=Java 预览功能
java.preview.features.unsupported=不再支持此项目中使用的 Java 语言级别 <b>{0} (预览)</b>。预览功能的代码洞察可能无法正常工作。<br>强烈建议迁移到较新的 Java 版本或停止使用预览功能。
java.preview.features.unsupported.title=不支持的 Java 预览功能
java.preview.features.warning=较新的 IDE 版本可能会停止对 Java 预览功能的支持。当 Java {0} 发布时，对 {1} (预览)语言级别的支持可能会中断。
java.preview.level={0} (预览)
java.terms.exception=异常
java.terms.instance.initializer=实例初始值设定项
java.terms.of.annotation.type=注解类型{1}的{0}
java.terms.of.anonymous.class=匿名类的{0}
java.terms.of.class=类 {1} 的 {0}
java.terms.of.enum=枚举 {1} 的 {0}
java.terms.of.interface=接口 {1} 的 {0}
java.terms.region=区域
java.terms.static.initializer=static 初始值设定项
java.terms.type.parameter=类型形参
java.terms.variable.of.method={0}/{1}
java.test.overall.time=总体时间\: {0}
java.test.sum.time=总时间\: {0}
java.test.use.wall.time=使用挂钟时间
javadoc.apiNote=API 说明\:
javadoc.author=作者\:
javadoc.candidates.not.found=<html>找不到方法调用 <b>{0}</b> 的候选者。</html>
javadoc.constructor.candidates=<html>新的候选 <b>{0}</b>() 是\:<br>{1}</html>
javadoc.deprecated=已弃用
javadoc.description.copied.from.class=来自类\:
javadoc.description.copied.from.field=来自字段\:
javadoc.description.copied.from.interface=来自接口\:
javadoc.description.inferred.annotation.hint=i
javadoc.documentation.url.checked=已检查以下文档 {0, choice, 1\#URL|2\#URL}\:
javadoc.edit.api.docs.paths=编辑 API 文档路径
javadoc.gen.error.module.source.path.is.not.evaluated=IDEA 无法生成 Javadoc，因为无法评估 module-source-path
javadoc.gen.error.modules.without.module.info=IDEA 无法生成 Javadoc，因为模块 {0} 不含 module-info.java 文件
javadoc.generate.arguments=命令行实参\:
javadoc.generate.exited=\n"javadoc" 完成，退出代码为 $EXIT_CODE$
javadoc.generate.heap.size=堆大小上限(&M)\:
javadoc.generate.include.jdk.library.sources.in.sourcepath.option=在 -sourcepath 中包含 JDK 和库源
javadoc.generate.link.to.jdk.documentation.option=链接到 JDK 文档 (使用 -link 选项)
javadoc.generate.locale=区域设置(&L)\:
javadoc.generate.no.classes.in.selected.packages.error=在所选作用域内未找到 Java 源代码
javadoc.generate.no.javadoc.tool=无法生成 JavaDoc - 在 {0} 或 {1} 上找不到 javadoc 工具。请在“设置 | 项目结构”中指定有效的 Java SDK。
javadoc.generate.no.jdk=无法生成 JavaDoc - 没有为项目配置 Java SDK。请在“设置 | 项目结构”中指定 Java SDK。
javadoc.generate.ok=生成
javadoc.generate.open.in.browser=生成文档并用浏览器打开 (&G)
javadoc.generate.options.hierarchy=生成层次结构树
javadoc.generate.options.index=生成索引
javadoc.generate.options.index.per.letter=每个字母单独的索引
javadoc.generate.options.navigator=生成导航栏
javadoc.generate.options.separator=JavaDoc 选项
javadoc.generate.output.directory=输出目录 (&D)\:
javadoc.generate.output.directory.browse=浏览输出目录
javadoc.generate.scope.row=可见性级别\:
javadoc.generate.sources.progress=寻找资源来生成Javadoc
javadoc.generate.tag.list.deprecated=弃用列表
javadoc.generate.temp.file.does.not.exist=临时文件不存在或无法打开
javadoc.generate.temp.file.error=无法创建临时文件
javadoc.generate.title=生成 JavaDoc
javadoc.generate.validation.error=指定输出目录。
javadoc.implNote=实现<br>说明\:
javadoc.implSpec=实现<br>要求\:
javadoc.method.in.class={0}在类{1}里边
javadoc.method.in.interface=接口 {1} 中的 {0}
javadoc.method.overrides=重写\:
javadoc.method.specified.by=指定的\:
javadoc.option.automatically.insert.closing.tag.javadoc=在 JavaDoc 中自动插入结束标记
javadoc.option.javadoc.title=JavaDoc
javadoc.see.also=请参阅\:
javadoc.settings.title=Javadoc
javadoc.since=自\:
javadoc.snippet.error.both.substring.and.regex=@{0}\: 应指定正则表达式或子字符串，但不应同时指定
javadoc.snippet.error.duplicate.attribute=@{0}\: 重复的特性\: ''{1}''
javadoc.snippet.error.malformed.regular.expression=@{0}\: 格式错误的正则表达式\: {1}
javadoc.snippet.error.malformed.replacement=@{0}\: 格式错误的正则表达式替换 ''{1}''\: {2}
javadoc.snippet.error.markup.tag.expected=应为标记标签或特性
javadoc.snippet.error.missing.required.attribute=@{0}\: 缺少 ''{1}'' 特性
javadoc.snippet.error.regex.too.complex=@{0}\: 过于复杂的正则表达式 ''{1}''
javadoc.snippet.error.unknown.enum.value=@{0}\: 未知的{1} ''{2}''；仅支持 {3}
javadoc.snippet.error.unsupported.attribute=@{0}\: 不受支持的特性\: ''{1}''
javadoc.snippet.not.found=找不到代码段\: {0}
javadoc.snippet.region.not.found=找不到区域\: {0}
javadoc.type.parameters=类型形参\:
javadoc.version=版本\:
jrt.node.short=[JRT]
jvm.logging.configurable.display.name=JVM 日志记录
jvm.logging.configurable.id=jvm.logging
jvm.logging.configurable.java.group.display.name=Java
label.add.math.max.0.count.to.avoid.possible.semantics.change=添加 Math.max(0, count) 以避免可能的语义更改
label.canonical.constructor=规范构造函数
label.class.filter.editor.add.dialog.filter.pattern=输入过滤器模式\:
label.class.pattern.syntax.explanation=将此方法留空以表示构造函数\n任何 * 将匹配限定名称中的一个或多个字符(包括点)
label.compact.constructor=压缩构造函数
label.configurable.logger.generation.variable.name=变量名称\:
label.configurable.logger.type=记录器\:
label.contract=约定(&C)\:
label.enter.fully.qualified.class.name=输入完全限定类名
label.entry.points=入口点\:
label.forbid.api.usages=禁止使用比以下版本更新的 API
label.forbid.api.usages.project=(根据项目设置)
label.from.inclusive=自(包含)(&F)\:
label.ignore.complicated.fix=当无法提供快速修复时忽略
label.ignored.exceptions=忽略的异常\:
label.implementation=实现\:
label.implements.method.of_class_or_interface.name=实现{0, choice, 0\#接口|1\#类} ''{1}'' 的方法。
label.implements.method.of_interfaces=以下类/接口的实现方法\:
label.jvm.class.name=JVM 类名
label.jvm.field.name=JVM 字段名称
label.jvm.method.name=JVM 方法名称
label.maximal.reported.method.visibility=最大方法可见性\:
label.method=方法 ''{0}''
label.minimal.reported.method.usage.count=要报告形参的最小方法用法计数\:
label.mutates=改变(&M)\:
label.name.prefix=名称前缀\:
label.name.suffix=名称后缀\:
label.naming.field=字段\:
label.naming.local.variable=局部变量\:
label.naming.parameter=形参\:
label.naming.static.field=static 字段\:
label.naming.subclass=子类\:
label.naming.test.class=测试类\:
label.new.template.name=新模板名称\:
label.overrides.method.of_class_or_interface.name=重写{0, choice, 0\#接口|1\#类} ''{1}'' 的方法。
label.show.import.popup.for=显示自动导入工具提示\:
label.to.inclusive=结束(包含)(&T)\:
label.unused.declaration.reachable.from.tests.option=当入口点位于测试源中时，将被调用方标记为\:
lambda.tree.node.presentation=Lambda
leave.in.same.source.root.item=留在同一源根中
library.classes.cannot.be.inlined=库类无法内联
line.marker.recursive.call=递归调用
line.marker.type.external.annotations=外部注解
line.marker.type.inferred.contract.annotations=推断约定注解
line.marker.type.inferred.nullability.annotations=推断为 null 性注解
link.configurable.logger.generator.display.name=<a href\='link'>设置</a>
link.configure.classes.excluded.from.completion=配置从补全中排除的类
list.item.configuration=[配置] {0}
list.item.suite=[套件] {0}
live.template.context.consumer.function=使用者函数
live.template.context.declaration=声明
live.template.context.else='else' 位置
live.template.context.expression=表达式
live.template.context.implicit.class.declaration=压缩源文件中的声明
live.template.context.normal.class.after.instance.main.declaration=在包含实例 'main' 方法的普通类内部的声明
live.template.context.normal.class.before.instance.main.declaration=在没有实例 'main' 方法的普通类内部的声明
live.template.context.statement=语句
live.template.context.statement.java.lang.io=带可用 java.lang.IO 的语句
live.template.context.statement.java.structured.concurrency.constructors=包含带构造函数的可用 StructuredTaskScope 的语句
live.template.context.statement.java.structured.concurrency.static.factory.methods=包含带 static 工厂方法的可用 StructuredTaskScope 的语句
livetemplate.description.geti=插入单一实例方法 getInstance
livetemplate.description.if.not.null=插入 'if not null' 语句
livetemplate.description.if.null=插入 'if null' 语句
livetemplate.description.inst=检查包含 instanceof 的对象类型并向下转换
livetemplate.description.iop=使用 IO 软件包打印字符串
livetemplate.description.ior=使用 IO 软件包读取字符串
livetemplate.description.itar=遍历数组元素
livetemplate.description.itco=遍历 java.util.Collection 的元素
livetemplate.description.iten=遍历 java.util.Enumeration
livetemplate.description.iter=迭代可迭代对象或数组
livetemplate.description.itit=遍历 java.util.Iterator
livetemplate.description.itli=遍历 java.util.List 的元素
livetemplate.description.itm=迭代 java.util.Map 的键和值
livetemplate.description.ittok=从字符串遍历标记
livetemplate.description.lazy=执行延迟初始化
livetemplate.description.lst=提取数组的最后一个元素
livetemplate.description.mn=为变量设置较小的值
livetemplate.description.mx=为变量设置较大的值
livetemplate.description.prsf=private static final
livetemplate.description.psf=public static final
livetemplate.description.psfi=public static final int
livetemplate.description.psfs=public static final String
livetemplate.description.psvm=main() 方法声明
livetemplate.description.ritar=以相反顺序遍历数组的元素
livetemplate.description.serr=将一个字符串打印到 System.err
livetemplate.description.short.psvm=void main()
livetemplate.description.short.psvma=void main(String[] args)
livetemplate.description.short.static.psvm=static void main()
livetemplate.description.short.static.psvma=static void main(String[] args)
livetemplate.description.souf=将一个格式化字符串打印到 System.out
livetemplate.description.sout=将一个字符串打印到 System.out
livetemplate.description.soutm=将当前类和方法名称打印到 System.out
livetemplate.description.soutp=将方法形参名称和值打印到 System.out
livetemplate.description.soutv=将一个值打印到 System.out
livetemplate.description.st=String
livetemplate.description.sts=创建并打开 StructuredTaskScope
livetemplate.description.stsf=创建一个 StructuredTaskScope.ShutdownOnFailure
livetemplate.description.stss=创建一个 StructuredTaskScope.ShutdownOnSuccess
livetemplate.description.surround.with.callable=使用可调用对象包围
livetemplate.description.surround.with.read.lock=使用 ReadWriteLock.readLock 包围
livetemplate.description.surround.with.write.lock=使用 ReadWriteLock.writeLock 包围
livetemplate.description.thr=抛出新
livetemplate.description.toar=将 java.util.Collection 的元素存储到数组中
loading.additional.annotations=正在加载附加注解…
macro.array.variable=arrayVariable()
macro.class.name=类名
macro.classpath.entry=该元素所属的类路径中的条目
macro.component.type.of.array=componentTypeOf(Array)
macro.descendant.classes.enum=descendantClassesEnum(String)
macro.expression.type=expressionType(Expression)
macro.file.fully.qualified.package=文件完全合格软件包
macro.file.package=文件软件包
macro.guess.element.type.of.container=guessElementType(Container)
macro.iterable.component.type=iterableComponentType(ArrayOrIterable)
macro.iterable.variable=iterableVariable()
macro.javadoc.output.directory=JavaDoc输出目录
macro.project.classpath=项目的类路径
macro.variable.of.type=variableOfType(Type)
megabytes.unit=MB
methods.to.implement.chooser.title=选择要实现的方法
methods.to.override.chooser.title=选择要重写的方法
methods.to.override.generate.javadoc=生成缺失的 JavaDoc
methods.to.override.implement.chooser.title=选择覆盖/实现的方法
module.not.in.requirements=模块 ''{0}'' 的要求中缺少模块 ''{1}''
module.package.not.exported=模块 ''{0}'' 不会将软件包 ''{1}'' 导入到模块 ''{2}''
module.package.not.open=模块 ''{0}'' 不会打开模块 ''{2} ''的软件包 ''{1}''
module.type.java.description=Java 模块用于开发<b>基于 JVM 的</b>桌面和 Web 应用程序，包括使用 <b>Java EE</b> 和其他企业开发框架的应用程序。
module.type.java.name=Java模块
move.class.import.from.default.package.conflict=无法从默认软件包访问 {0}
move.classes.destination.class.not.found.message=未找到目标类
move.classes.invalid.destination.package.name.message=''{0}'' 是无效的目标软件包名称
move.inner.select.target.package.title=选择目标软件包
move.member.enum.conflict=枚举类型不适用于当前上下文
move.member.final.initializer.conflict=final {0}的初始值设定项将被留下。
multiple.usages.of.static.import.found=已找到 static import 的多个用法
navigate.to.duplicate.fix=导航到重复位置
new.line.when.body.is.presented=显示正文时换行
no.jre.description=<无 JRE>
no.methods.overriding.0.are.found=没有发现重写 {0, choice, 0\#|1\#“{1}”|2\#这些类} 的方法
no.patterns=没有类模式配置
node.call.hierarchy.unknown.jsp=未知的jsp
node.hierarchy.java.lang.object=所有类都派生自 java.lang.Object
non.code.annotations.explanation.external.and.inferred.available=外部和<i>推断</i>注解可用。
non.code.annotations.explanation.external.available=外部注解可用。
non.code.annotations.explanation.full.signature=完整签名\:
non.code.annotations.explanation.inferred.available=<i>推断</i>注解可用。
notification.content.added.annotations=已添加 {0} {0, choice, 1\#注解|2\#注解}
notification.content.change.jdk=更改 JDK
notification.content.was.set.up=已为项目设置了 JDK ''{0}''
notification.group.arch.checker=JDK 和系统架构不同
notification.group.jdk.resolve.problems=无法解析 JDK
notification.group.jshell=发生了JShell 问题
notification.group.language.level=预览 Java 语言级别需要接受许可证
notification.group.legacy.library=旧版库依赖于 IDE 安装
notification.group.preview.features=预览 Java 语言级别可能会中断
notification.group.redundant.exports=可以移除冗余的导出/打开
notification.group.repository=JAR 文件已与仓库同步
notification.group.setup.external.annotations=加载外部注解失败
notification.group.setup.jdk=JDK 已配置
notification.group.source.searcher=找不到 JAR 文件的源
notification.group.testintegration=无法为 @TestDataPath 生成测试
notification.group.unsupported.jdk=不受支持的 JDK
notification.navigation.to.overriding.classes=索引更新时无法导航到重写类
notification.navigation.to.overriding.methods=索引更新时无法导航到重写方法
null.check.surrounder.description=if (expr \!\= null) {…}
nullable.notnull.annotation.used.label=用于生成代码的注解\:
nullable.notnull.annotations.panel.title={0}注解\:
nullable.notnull.annotations.runtime.instrumentation.tooltip=为非 null 注解的方法和形参添加运行时断言
nullable.notnull.configuration.dialog.title=可以为 null/非 null 配置
nullable.stuff.inspection.navigate.null.argument.usages.fix.family.name=导航到 'null' 实参用法
nullable.stuff.inspection.navigate.null.argument.usages.fix.family.preview=显示将 'null' 作为实参传递的用法列表。
nullable.stuff.inspection.navigate.null.argument.usages.view.name=形参 {0} 的 ''null'' 实参用法
offline.inspections.jdk.not.found=找不到 {0}
offline.inspections.library.urls.were.not.resolved=未解析模块 ''{2}'' 中库 ''{1}'' 的根 {0}
offline.inspections.library.was.not.resolved=请配置库''{0}''用于模块''{1}''
offline.inspections.no.source.roots=未检测到模块 ''{0}'' 的源根
open.settings.dialog.for.module.preview.text=打开模块 ''{0}'' 的设置对话框
options.java.attribute.descriptor.package.private=可见性//Package-private
options.java.attribute.descriptor.private=可见性//Private
options.java.attribute.descriptor.protected=可见性//Protected
options.java.attribute.descriptor.public=可见性//Public
options.java.attribute.descriptor.static.field=类字段//静态字段
options.java.attribute.descriptor.static.final.field=类字段//常量(static final 字段)
options.java.attribute.descriptor.static.final.imported.field=类字段//常量 (static final 导入字段)
options.java.attribute.descriptor.static.imported.field=类字段//static import 字段
options.java.attribute.descriptor.static.method=方法//静态方法
options.java.attribute.descriptor.type.parameter=形参//类型形参
options.java.display.name=Java
override.implement.broken.file.template.message=请更正“重写/实现的方法体”模板
override.implement.broken.file.template.title=文件模板错误
override.methods.error.no.methods=找不到要重写的方法
package.chooser.modal.progress.title=正在搜索软件包…
package.classes=软件包类\:
package.dependencies.production.node.text=生产类
package.dependencies.test.node.text=测试类
package.pattern.provider.hint.label=使用 <b>*.txt</b> 匹配项目中的 'txt' 文件，使用 <b>file\:path_in_project//*</b> 递归匹配目录中的所有文件，使用 <b>src\:foo..*</b> 递归匹配软件包中的所有类。
packaging.jlink.artifact.name=JLink
packaging.jlink.artifact.title=运行时映像(JLink)
packaging.jlink.compression.first.level=字符串共享
packaging.jlink.compression.level=压缩级别
packaging.jlink.compression.second.level=Zip
packaging.jlink.compression.zero.level=不压缩
packaging.jlink.verbose.tracing=启用详细跟踪
paste.class.command.name=粘贴类 ''{0}''
please.report.a.bug=请报告错误
popup.content.tests.were.not.found.in.module=在模块 ''{0}'' 中找不到测试。
popup.content.tests.were.not.found.in.module.search.in.dependencies=改为在模块依赖项中搜索
popup.content.tests.were.not.found.in.module.use.instead=改用{0, choice, 0\#模块 {1} |1\# \n{2} 之一\n}
popup.title.choose.framework=选择框架
popup.title.choose.target.class=选择目标类
popup.title.choose.test=选择测试
popup.title.debug.recent.tests=调试最近的测试
popup.title.remove.unused.variable=移除未使用的变量
popup.title.select.target.code.block=选择目标代码块
postfix.template.condition.array.name=数组
postfix.template.condition.array.reference.name=非基元类型数组
postfix.template.condition.boolean.name=布尔
postfix.template.condition.non.void.name=非 void
postfix.template.condition.not.primitive.type.name=非基元类型
postfix.template.condition.number.name=数字
postfix.template.condition.void.name=void
postfix.template.editor.choose.class.title=选择类
postfix.template.language.level.title=最低语言级别\:
postfix.template.provider.name=Java
presentable.text.anonymous.class=匿名类
presentable.text.code.display=代码
presentable.text.code.from.context=来自 {0} 的代码
presentable.text.invalid.element.name=无效
press.0.to.see.inheritors.of.1=按 {0} 以查看 {1} 的继承者
press.0.to.see.non.imported.classes=按 {0} 以查看未导入的类
pressing.0.twice.without.a.class.qualifier=不使用类限定符，按 {0} 两次会显示所有可访问的 static 方法
preview.api.usage={0} 为预览 API，可能会在未来版本中移除
preview.api.usage.reflective={0} 为反射预览 API，可能会在未来版本中移除
progress.creating.class=创建类{0}
progress.title.calculate.applicable.types=正在计算适用类型…
progress.title.check.applicability=正在检查适用性…
progress.title.checking.if.class.exists=检查目标类 ''{0}'' 是否存在
progress.title.collect.method.overriders=正在收集方法重写器…
progress.title.detect.overridden.methods=检查重写方法
progress.title.detecting.jdk=正在检测 JDK
progress.title.find.references.in.implement.extends.lists=正在 implements / extends 列表中查找引用…
progress.title.finding.cause=正在查找原因
progress.title.looking.for.jdk=正在查找 JDK…
progress.title.optimize.imports=正在优化 import…
progress.title.preprocess.usages=预处理用法
progress.title.restore.references=正在还原引用
progress.title.search.for.overriding.methods=正在搜索重写方法…
progress.title.searching.for.sub.classes=正在搜索子类
progress.title.searching.references=正在搜索引用…
project.problems.fix.description=发现与 ''{0}'' 相关的问题
project.problems.fix.text=显示相关问题
project.problems.hint.text={0} 个相关{0, choice, 0\#问题|2\#问题}
project.problems.title=相关问题
project.problems.window.title={0} 的相关问题
prompt.choose.base.class.of.the.hierarchy=选择要搜索的层次结构的基类
prompt.create.non.existing.package=软件包 {0} 不存在。\n是否要创建?
prompt.delete.class={0,choice,1\#类|2\#类}
prompt.delete.field={0,choice,1\#个字段|2\#个字段}
prompt.delete.interface={0,choice,1\#个接口|2\#个接口}
prompt.delete.method={0,choice,1\#个方法|2\#个方法}
prompt.delete.package={0,choice,1\#软件包|2\#软件包}
prompt.delete.type.parameter={0,choice,1\#类型形参|2\#类型形参}
prompt.do.you.want.to.action_verb.the.method.from_class=要改为对基{0,choice,1\#方法|2\#方法}{1}吗?
psi.error.incorrect.class.template.message=无法创建{0} - {1}模板不正确。
psi.search.overriding.progress=正在搜索重写方法…
pull.members.up.fix.name=将成员上移
pull.up.accessible.conflict={0} 无法访问
pull.up.accessible.conflict.1=无法从 {1} 访问 {0}
pull.up.concrete.inherit.abstract.method.conflict=具体的{0}将继承一个新的抽象方法
pull.up.members.usage.view.description.code.references.node=将成员向上拉取到“{0}”的类
pull.up.members.usage.view.description.processed.elements.node=从类 {0} 上移成员
push.down.anonymous.conflict=无法将实现推送到匿名类
push.down.missed.implementation.conflict=非抽象 {0} 将错过 {1} 的实现
push.down.static.nonstatic.conflict=static {0} 无法推送到非 static {1}
push.down.super.method.call.changed.conflict=super 方法调用将解析为另一种方法
push.method.down.command.name=向下推送方法…
qualify.static.access.command.name=限定 static 访问
qualify.static.call.fix.text=限定 static 调用
qualify.static.constant.access=限定 static 常量访问
quickfix.add.variable.family.name=初始化变量
quickfix.add.variable.text=初始化变量 ''{0}''
quickfix.family.avoid.mutation.using.stream.api=使用 Stream API 避免变异
quickfix.family.change.javadoc.to=更改为…
quickfix.family.find.cause=查找原因
quickfix.family.remove.javadoc.tag=移除标记
quickfix.family.remove.redundant.parameter=删除冗余形参
quickfix.family.remove.redundant.parameter.types=删除冗余形参类型
quickfix.family.replace.cast.type=替换转换类型
quickfix.family.replace.inefficient.stream.count=替换低效的 Stream.count()
quickfix.family.replace.optional.chain.with.if.statements=将 Optional 链替换为 if 语句
quickfix.family.replace.stream.api.chain.with.loop=将 Stream API 链替换为循环
quickfix.family.replace.with.java.stream.api.pipeline=替换为 Java Stream API 管道
quickfix.family.replace.with.magic.constant=替换为魔术常量
quickfix.family.replace.with.method.reference=替换为方法引用
quickfix.family.replace.with.optional.of.nullable.chain=替换为 Optional.ofNullable() 链
quickfix.family.replace.with.stream.api.equivalent=替换为 Stream API 对等项
quickfix.family.simplify.foreach.lambda=简化 forEach lambda
quickfix.family.simplify.stream.call.chain=简化流调用链
quickfix.family.use.flatmap=使用 'flatMap'
quickfix.family.wrap.with.mutable.collection=使用可变集合包装
quickfix.find.cause.description=尝试高亮显示导致此警告的代码元素，并解释它们的确切作用。
quickfix.name.find.jar.on.web=在 web 上查找 JAR
quickfix.text.0.may.not.work.before.jdk.11.0.2={0} (可能无法在 JDK 11.0.2 之前的版本上运行)
quickfix.text.avoid.mutation.using.stream.api.0.operation=使用 Stream API ''{0}()'' 操作避免变异
quickfix.text.remove.javadoc.0=移除 ''@{0}'' 标记
quickfix.text.remove.javadoc.0.1=移除 @{0} {1}
quickfix.text.remove.not.null.annotation=移除非 null 注解
quickfix.text.replace.0.stream.with.1.2=将 {0}.stream() 替换为 {1}.{2}()
quickfix.text.replace.collect.0.with.1.2=将 ''collect({0}())'' 替换为 ''{1}''{2}
quickfix.text.replace.filter.0.is.present.with.any.match=将 ''filter().{0}().isPresent()'' 替换为 ''anyMatch()''
quickfix.text.replace.stream.0.with.1.2=将 ''stream().{0}()'' 替换为 ''{1}()''{2}
quickfix.text.replace.url.with.link=将 URL 替换为链接
quickfix.text.suffix.may.change.semantics=\ (可能更改语义)
quickfix.text.wrap.0.with.1=用 ''{1}'' 包装 ''{0}''
radio.button.subclass.of.0=''{0}'' 的子类
radio.button.unused.declaration.unused.option=未使用
radio.button.unused.declaration.used.option=已使用
radio.button.with.provider.method=带有 'provider()' 方法
raw.use.of.parameterized.type.ignore.new.objects.option=忽略新对象的构造
raw.use.of.parameterized.type.ignore.overridden.parameter.option=忽略重写方法的形参类型
raw.use.of.parameterized.type.ignore.quickfix.not.available.option=在自动快速修复不可用时忽略
raw.use.of.parameterized.type.ignore.type.casts.option=忽略类型转换
raw.use.of.parameterized.type.ignore.uncompilable.option=忽略类型形参无法编译的位置
raw.variable.type.can.be.generic.cast.quickfix=将转换类型更改为 {0}
raw.variable.type.can.be.generic.cast.quickfix.family=形参化转换类型
raw.variable.type.can.be.generic.family.quickfix=向类型添加泛型形参
raw.variable.type.can.be.generic.quickfix=将{0}的类型更改为{1}
records.cannot.be.inlined=记录类不能被内联
refactoring.method.reference.to.lambda.conflict=方法引用将转换为 lambda
remove.var.keyword.text=移除 'var'
rename.package.class.already.exist.conflict=具有限定名称 ''{0}''  的类已存在
rename.package.command.name=重命名软件包
rename.package.ignored.name.warning=正在尝试创建具有忽略名称的软件包，结果将不可见
rename.package.invalid.name.error=不是有效的软件包名称
rename.super.base.chooser.popup.title={0} {1, choice, 0\#实现|1\#重写} {2} 的方法
rename.super.methods.chooser.popup.title={0} 具有 super 方法
scheduled.thread.pool.executor.with.zero.core.threads.description='ScheduledThreadPoolExecutor' 不应具有零个核心线程
scheduled.thread.pool.executor.with.zero.core.threads.display.name=带零个核心线程的 'ScheduledThreadPoolExecutor'
scope.hierarchy={0}的层次结构
sdk.cannot.create=无法创建 SDK
sdk.configured=''{0}'' 被设置为项目 JDK。
sdk.configured.external.config.title=JDK 已配置({0})
sdk.configured.notification.title=JDK 已配置
sdk.java.no.classes=无法在''{0}''中找到JDK classes
section.title.inspection.suspicious.names.ignore.methods=忽略方法\:
separator.annotations.to.copy=要复制的注解
separator.mark.as.entry.point.if.annotated.by=如果已注解，则标记为入口点\:
separator.mark.field.as.implicitly.written.if.annotated.by=如果已注解，则将字段标记为隐式写入\:
set.language.level=设置语言级别
set.language.level.to.0=设置语言级别为{0}
settings.completion.ml.java.display.name=Java
settings.inlay.java.annotations=注解
settings.inlay.java.builder.like.methods=类似于构建器的方法
settings.inlay.java.complex.expressions.binary.functional.array.access.and.other=复杂表达式作为实参
settings.inlay.java.enum.constants=枚举常量
settings.inlay.java.external.annotations=外部注解
settings.inlay.java.implicit.types.lambda=Lambda 类型
settings.inlay.java.implicit.types.lambda.description=显示 lambda 形参类型的嵌入提示
settings.inlay.java.implicit.types.local=隐式类型
settings.inlay.java.implicit.types.local.description=当从赋值的右侧推断的类型不明确时（例如，使用工厂方法时），使用 var 关键字声明的局部变量。
settings.inlay.java.inferred.annotations=推断注解
settings.inlay.java.inheritors=继承者
settings.inlay.java.methods.with.same.named.numbered.parameters=包含相同名称的编号形参的方法
settings.inlay.java.new.expressions='New' 表达式
settings.inlay.java.non.literals.in.case.of.multiple.parameters.with.the.same.type=在具有相同类型的多个形参的情况下的非字面量
settings.inlay.java.parameters.with.names.that.are.contained.in.the.method.name=具有方法名称中包含的名称的形参
settings.inlay.java.show.hints.for=显示以下项的提示\:
settings.inlay.java.show.parameter.hints.for=为以下对象显示形参提示\:
settings.inlay.java.show.parameter.hints.when.expression.type.is.clear.description=数组初始值设定项、switch、条件、引用、实例、赋值、调用、限定、类型转换、类对象访问表达式。
settings.inlay.java.turn.off.showExternal.annotations=关闭外部注解
settings.inlay.java.turn.off.showInferred.annotations=关闭推断注解
settings.inlay.java.turn.on.showExternal.annotations=开启外部注解
settings.inlay.java.turn.on.showInferred.annotations=开启推断注解
settings.inlay.java.usages=用法
show.import.popup.for.classes=类(&C)
show.import.popup.for.static.methods.and.fields=Static 方法和字段(&S)
show.siblings.choose.super.class.title=选择超类或接口
show.siblings.find.usages.class.title=超类/接口
show.siblings.find.usages.method.title=super 方法
side.effects.expression.presentation=表达式 ''{0}''
side.effects.pattern.message=<html>\n<body>\n{0} 中可能存在副作用<br>\n您可以\:\n<br>\n-\\&nbsp;<b>移除</b>变量用法以及所有涉及的表达式，或<br>\n-\\&nbsp;<b>自行将分配到变量的表达式转换</b>到语句中。<br>\n<div style\="padding-left\: 0.6cm;">\n  即<br>\n  <table border\="0">\n    <tr>\n      <td><code>{1};</code></td>\n    </tr>\n  </table>\n  成为\: <br>\n  <table border\="0">\n    <tr>\n      <td><code>{2};</code></td>\n    </tr>\n  </table>\n</div>\n</body>\n</html>
simplify.optional.chain.inspection.fix.description.optional.chain.can.be.eliminated=Optional 链可被消除
simplify.optional.chain.inspection.fix.description.replace.with.value.of.description=Optional 链可被替换为 'String.valueOf()'
simplify.optional.chain.inspection.fix.description.replace.with.value.of.name=替换为 'String.valueOf()'
simplify.optional.chain.inspection.fix.name.remove.redundant.optional.chain=移除冗余的 Optional 链
simplify.optional.chain.inspection.map.or.else.description=Optional 链可以简化
simplify.optional.chain.inspection.optional.rewrapping.description=不必要的 Optional 重新包装
simplify.optional.chain.inspection.optional.rewrapping.name=解包
simplify.optional.chain.inspection.or.else.non.null.fix.description=null 检查可被 'ifPresent' 消除
simplify.optional.chain.inspection.or.else.non.null.fix.name=将 null 检查替换为 ifPresent()
simplify.optional.chain.inspection.or.else.return.fix.description=null 检查可被消除
simplify.optional.chain.inspection.or.else.return.fix.name=将 null 检查替换为 {0}({1})
simplify.optional.chain.inspection.remove.redundant.steps.from.optional.chain=从可选链中移除冗余步骤
simplify.optional.chain.inspection.to.x=将可选链简化为 ''{0}''
simplify.stream.collection.creation.fix.name=替换为 ''{0}'' 构造函数
simplify.stream.inspection.iterate.take.while.fix.message=可被替换为三实参 'iterate()'
simplify.stream.inspection.iterate.take.while.fix.name=替换为三实参 'iterate()'
simplify.stream.inspection.message.can.be.replaced=''{0}'' 可被替换为 ''{1}''
simplify.stream.inspection.message.can.be.replaced.may.change.semantics=''{0}'' 可被替换为 ''{1}'' (可能会改变语义)
simplify.stream.match.negation.fix.name=将 {0} 替换为 {1}(…)
simplify.stream.remove.boolean.identity.fix.message=可以与上一个 'map()' 调用合并
simplify.stream.remove.boolean.identity.fix.name=与上一个 'map()' 调用合并
simplify.stream.replace.support.with.collection.fix.message=可被替换为 ''{0}.{1}()'' 调用
simplify.stream.replace.support.with.collection.fix.name=替换为 ''{0}.{1}()'' 调用
simplify.stream.replace.with.element.iteration.fix.message=可被替换为元素迭代
simplify.stream.simple.stream.of.fix.name.use.stream.element.explicitly=显式使用 Stream 元素
simplify.stream.simple.stream.of.message=不必要的单元素 Stream
simplify.stream.swap.filter.and.map.fix.message=可以交换 'filter()' 和 'map()'
simplify.stream.swap.filter.and.map.fix.name=交换 'filter()' 和 'map()'
slice.filter.parse.error.enum.constant.not.found=找不到枚举常量\: {0}
slice.filter.parse.error.expression.must.evaluate.to.constant=表达式的求值结果必须为常量\: {0}
slice.filter.parse.error.incorrect.constant.expected.number=常量不正确(应为数字)\: {0}
slice.filter.parse.error.incorrect.constant.type=常量类型不正确(要求\: {0})
slice.filter.parse.error.incorrect.expression=表达式不正确\: {0}
slice.filter.parse.error.not.null.filter.not.applicable.for.primitive.type=''\!null'' 筛选器不适用于基元类型 {0}
slice.filter.parse.error.null.filter.not.applicable.for.primitive.type=''null'' 筛选器不适用于基元类型 {0}
slice.usage.message.assertion.violated=(违反断言\!)
slice.usage.message.in.file.stopped.here=(在 {0} 文件中 - 在此处停止)
slice.usage.message.location=({0} 中)
slice.usage.message.tracking.container.contents=(正在跟踪容器 ''{0}{1}'' 内容)
special.annotations.annotations.list=附加特殊注解\:
special.annotations.annotations.preview=将 ''@{0}'' 添加到此检查将忽略的注解列表中
special.annotations.list.add.annotation.class=添加注解类
special.annotations.list.annotation.class=注解类
special.annotations.list.annotation.pattern=添加注解模式
special.annotations.list.annotation.pattern.message=添加注解模式
special.annotations.list.remove.pattern=移除
spi.extension.error.message=注册的扩展应实现{0}
spi.no.provider.error.message=未找到服务提供程序“{0}”
status.bar.overridden.methods.highlighted.message=找到 {0} 个被重写的{0, choice, 1\#方法|2\#方法}(再次按 {1} 以移除高亮显示，按 Escape 以移除所有高亮显示)
stream.to.loop.inspection.message.replace.foreach.call.with.loop=将 'forEach()' 调用替换为循环
stream.to.loop.inspection.message.replace.stream.api.chain.with.loop=将 Stream API 链替换为循环
surround.with.cast=使用转换包围
surround.with.dowhile.template=do / while
surround.with.for.template=for
surround.with.ifelse.expression.template=if (expr) {...} else {...}
surround.with.not.instanceof.template=\!(表达式实例类型)
surround.with.runnable.template=Runnable
surround.with.synchronized.template=synchronized
surround.with.try.catch.finally.template=try / catch / finally
surround.with.try.catch.incorrect.template.message=catch 体的文件模板无效
surround.with.try.catch.template=try / catch
switch.stmt.template.description=switch (expr) {…}
tab.title.entry.points=入口点
tab.title.infer.nullity.preview=推断为 null 性预览
tab.title.members.to.report=要报告的成员
tab.title.slices.grouped.by.nullness=\ (按为 null 性分组)
table.cell.constructors=构造函数
target.code.block.presentable.text=包含块
title.cannot.create.class=无法创建类
title.code.vision=Code Vision
title.naming=命名
title.naming.final.modifier=变量声明
title.naming.functional.expressions=Lambda 体
title.naming.variable=变量
title.package.not.found=找不到软件包
title.packages=软件包
title.related.problems.inlay.hints=相关问题
to.import.a.method.statically.press.0=要静态导入方法，请按 {0}
todo.0=TODO "{0}"
todo.index.not.available=不适用
todo.item=TODO 条目
tooltip.anonymous=匿名
tooltip.has.several.functional.implementations=有多个函数实现
tooltip.implements.method=实现方法
tooltip.implements.method.in=在以下位置实现方法\:
tooltip.incorrect.file.template=''{0}'' 文件模板不正确
tooltip.is.functionally.implemented.in=函数实现位置\:
tooltip.is.implemented.by=实现对象\:
tooltip.is.implemented.by.several.subclasses=由多个子类实现
tooltip.is.implemented.in=在以下位置实现\:
tooltip.is.implemented.in.several.subclasses=在多个子类中实现
tooltip.is.overridden.by.several.subclasses=被多个子类重写
tooltip.is.overridden.in=在以下位置被重写\:
tooltip.is.overridden.in.several.subclasses=在多个子类中被重写
tooltip.is.subclassed.by=被以下类子类化
tooltip.overrides.method=重写方法
tooltip.overrides.method.in=在以下位置重写方法\:
tooltip.reassigned.local.variable=重新赋值的局部变量
tooltip.reassigned.parameter=重新赋值的形参
tooltip.recursive.call=递归调用
tooltip.variable.used=未使用变量 ''{0}''
tooltip.via.subclass=通过子类
type.information.constraints=约束
type.information.local.object=本地对象
type.information.locality=本地性
type.information.mutability=可变性
type.information.not.equal.to=不等于
type.information.nullability=为 null 性
type.information.range=范围
type.information.type=类型
type.information.value=值
type.migration.cannot.convert.message=无法将表达式 <b>{0}</b> 的类型{3, choice, 0\#|1\#从 '<'b'>'{1}'<'/b'>' }转换为 <b>{2}</b>
type.migration.cannot.convert.tooltip=无法将表达式的类型从 {0} 转换为 {1}
type.migration.cannot.convert.vararg.message=无法将调用 <b>{0}</b> 从 vararg 转换为非 vararg
type.migration.cannot.convert.vararg.tooltip=无法将调用从 vararg 转换为非 vararg
type.migration.command.name=TypeMigration
type.migration.dialog.message.disjunction.type.not.applicable=只有 catch 块形参可以迁移到联合体类型
type.migration.dialog.message.invalid.type=''{0}'' 不是有效的类型
type.migration.dialog.message.vararg.type.not.applicable=只有方法的最后一个形参可以迁移到 vararg 类型
type.migration.dialog.message.void.not.applicable=只有方法返回类型可以迁移到 'void'
type.migration.getter.rename.suggestion.always.migrate.method.names=始终迁移方法名称
type.migration.getter.rename.suggestion.never.migrate.method.names=从不迁移方法名称
type.migration.getter.rename.suggestion.text=由于返回值类型已被迁移到 ''{2}''，是否将 getter 从 ''{0}'' 重命名为 ''{1}''?
type.migration.multi.root.toolwindow.title=迁移 {0} 的类型
type.migration.processed.elements.header=类型迁移的根
type.migration.replaced.notification=替换为 {0}
type.migration.single.root.toolwindow.title=将 {0} 的类型从 ''{1}'' 迁移到 ''{2}''
type.parameters.cannot.be.inlined=类型形参无法内联
unchecked.warning.inspection.message.unchecked.generics.array.creation.for.varargs.parameter=vararg 形参的未检查的泛型数组创建
unchecked.warning.inspection.reason.expr.has.raw.type.so.result.erased=。原因\: ''{0}'' 具有原始类型，因此消除了 {1} 的结果
unchecked.warning.inspection.settings.ignore.unchecked.assignment=忽略未检查的赋值
unchecked.warning.inspection.settings.ignore.unchecked.call.as.member.of.raw.type=忽略作为原始类型成员的未检查的调用
unchecked.warning.inspection.settings.ignore.unchecked.cast=忽略未检查的转换
unchecked.warning.inspection.settings.ignore.unchecked.generics.array.creation.for.vararg.parameter=忽略 vararg 形参的未检查的泛型数组创建
unchecked.warning.inspection.settings.ignore.unchecked.overriding=忽略未检查的重写
unknown.library=未知库
unscramble.detect.analyze.threaddump.from.clipboard.item=自动检测和分析从 IntelliJ IDEA 外部复制到剪贴板的线程转储
unscramble.log.path.label=日志文件\: (&L)
unscramble.no.unscrambler.item=<未安装译码器>
unscramble.normalize.button=标准化 (&N)
unscramble.stacktrace.caption=将一个堆栈跟踪或完整的线程转储放在此处\:
unscramble.unscrambled.deadlock.tab=<死锁>
unscramble.unscrambled.stacktrace.tab=<堆栈跟踪>
unscramble.unscrambled.threaddump.tab=<线程>
unscramble.unscrambler.combobox=译码器(&S)\:
unscramble.use.unscrambler.checkbox=译码堆栈跟踪(&U)
unsupported.jdk.notification.content=Oracle 对 Java 7 的扩展支持已于 2022 年结束。使用 ''{0}'' 可能会导致安全问题。
unsupported.jdk.notification.title=不受支持的 JDK
unwrap.anonymous=解包 'anonymous...'
unwrap.array.initializer=解包数组初始值设定项
unwrap.conditional=开启 'f ? a \: b'
unwrap.lambda=取消 'lambda...' 换行
unwrap.switch.expression=解包 'switch' 表达式
unwrap.switch.statement=解包 'switch' 语句
unwrap.synchronized=解包 'synchronized…'
update.external.annotations=更新外部注解
usage.target.exception=异常
usage.target.package.in.directory={0} (在 {1} 中)
usages.telescope={0,choice, 0\#0 个用法|1\#1 个用法|2\#{0,number} 个用法}
use.external.annotations=使用外部注解 (&E)
validator.text.class.not.found=找不到类
validator.text.directory.not.found=找不到目录
validator.text.no.annotation=必须为注解
validator.text.not.directory=不是一个目录
validator.text.not.valid.class.name=不是有效的类名
validator.text.wrong.superclass=错误的超类
vm.option.description.category=类别\:
vm.option.description.default.value=默认值\:
vm.option.description.description=描述\:
vm.option.description.diagnostic=诊断
vm.option.description.experimental=实验性
vm.option.description.option=选项\:
vm.option.description.product=产品
vm.option.description.requires=\ (要求 {0})
vm.option.description.standard=标准
vm.option.description.type=类型\:
warning.java.file.outside.source.root=Java 文件位于模块源根之外，因此不会被编译
where.do.you.want.to.move.directory.prompt={0}\n\n要将目录移至另一个源根还是另一个目录?
wrap.return.value.anonymous.class.presentation=匿名{0}
wrap.return.value.created.class.not.accessible.conflict=创建的类将无法在调用位置访问
wrap.return.value.existing.class.does.not.have.appropriate.constructor.conflict=现有类没有适当的构造函数
wrap.return.value.existing.class.does.not.have.getter.conflict=现有类没有所选字段的 getter
wrapping.text.blocks=文本块
wrong.package.statement=错误的 package 语句

dialog.message.no.inheritors.are.selected=未选择继承者
progress.title.inplace.rename.appending.additional.elements=追加其他元素
progress.title.inplace.rename.collecting.references=正在收集引用
progress.title.inplace.rename.preparing=正在准备重命名
extract.invalid.name.for.class.type.error={0} 名称无效
refactoring.introduce.constant.name=引入常量
refactoring.introduce.define.name=引入 Define
refactoring.introduce.typedef.name=引入 Typedef
refactoring.introduce.variable.name=引入变量
refactoring.introduce.ivar.name=引入 Ivar
refactoring.introduce.property.name=引入属性
refactoring.introduce.instance.variable.name=引入实例变量
refactoring.introduce.parameter.name=引入形参
refactoring.move.no.members.are.selected.error=未选择成员
refactoring.move.members.ok.button.text=移动(&M)
refactoring.move.pull.up.ok.button.text=拉取(&U)
refactoring.move.push.down.ok.button.text=推送(&U)
refactoring.move.escalate.visibility.declare.in.interface=在接口中声明
refactoring.move.namespace.has.no.members=命名空间“{0}”没有要移动的成员
refactoring.move.file.has.no.members=文件“{0}”没有要移动的成员
refactoring.symbol.has.no.members.to.move={0} 没有要移动的成员
refactoring.move.caret.position=文本光标应置于类内部
refactoring.move.cant.find.symbol=找不到所选类的符号
refactoring.move.members.error.no.target.class.selected=未选择目标类
refactoring.move.members.error.class.name.invalid=类名无效
refactoring.move.members.error.not.in.project.sources={0} 不在项目内部
refactoring.move.members.error.the.same.source.and.target=源和目标类应该不同
refactoring.move.members.message.target.does.not.exist=目标类 "{0}" 尚不存在。
refactoring.extract.super.protocol.title=提取超级协议
refactoring.extract.subclass.title=提取子类
refactoring.extract.category.title=提取类别
refactoring.introduce.block.expression.represent.error=所选块应该代表 {0}
refactoring.introduce.expressions.choose.dialog.title=表达式
refactoring.introduce.put.to.header=置于头(&H)
refactoring.change.signature.target.symbols.panel=目标:
refactoring.rename=重命名 {0}(&R)
refactoring.rename.class.aliases=重命名类别名(&R)
refactoring.rename.associated.file=重命名关联文件
refactoring.introduce.constant.static.declaration=声明 static(&S)
refactoring.ivar.inplace.introducer.generate.property=生成属性(&P)
refactoring.ivar.inplace.introducer.declare.interface=在接口中声明(&I)
refactoring.introducer.declare.const=声明 const(&C)
refactoring.introducer.declare.auto=声明 auto(&A)
refactoring.parameter.introducer.refactor.super.method=重构 super {0}(&S)
refactoring.property.introducer.make.readonly=设为只读(&R)
refactoring.property.introducer.generate.synthesize=生成 @synthesize(&S)
refactoring.property.introducer.generate.instance.variable=生成实例变量(&I)
refactoring.property.introducer.put.to.private.category=移至私有类别(&P)
dialog.title.choose.containing.class=选择包含类
dialog.message.variable.must.be.const=变量“{0}”必须为常量
dialog.message.cannot.find.method.function=找不到方法/函数
dialog.message.cannot.inline.parameters.blocks=无法内联块的参数
dialog.message.cannot.inline.parameters.lambdas=无法内联 lambda 的参数
dialog.message.several.call.sites.with.different.parameter.initializers=存在多个带有不同参数初始值设定项的调用站点
dialog.message.there.are.no.usages=没有 {0} 的用法
dialog.message.cannot.inline.blocks=无法内联块
dialog.message.cannot.inline.protocol.method=无法内联协议方法
dialog.message.interface.was.not.implemented=接口 {0} 未实现
dialog.message.cannot.inline.with.empty.body=无法将 {0} 和空体内联
dialog.message.there.are.no.calls.in.project=项目中没有 {0} 调用
dialog.message.cannot.inline.methods.with.return.statements.interrupting.execution.flow=return 语句中断执行流时无法内联方法
question.inline.usage=内联 {2} 的 {0} 用法{1, choice, 0#|1#}吗?
message.never.used={0} 从未使用
dialog.message.accessed.for.writing={0} 可写
dialog.message.accessed.for.address=访问 {0} 以获取地址
dialog.title.inline=内联 {0}
button.inline.current.usage=内联当前用法(&C)
button.inline.all.usages.file=内联{0, choice, 0#文件中的|1#}所有用法(&A)
button.view.usages=显示用法(&S)
button.cancel=取消(&C)
button.inline=内联(&I)
button.rename=重命名(&R)
button.rename.code=仅重命名代码用法(&C)
button.rename.all=重命名所有用法(&R)
dialog.message.must.have.initializer={0} 必须具有初始值设定项

rename.reference.command.name=重命名引用
rename.reference.invalid.dialog.title=无效标识符
rename.reference.invalid.dialog.button.yes=继续编辑

rename.multiple.macro.usages.message={0} 对 "{1}" 有几种映射不同的用法。重命名可能会破坏代码。是否要继续?
rename.non.code.usages.message=在注释和非代码文件中发现 {0} 个{0, choice, 1#用法|2#用法}。\n要将{0, choice, 1#其|2#其}重命名吗?
dialog.title.extract.method=提取方法
dialog.title.extract.function=提取函数
dialog.title.extract.block.parameter=提取块参数
dialog.title.extract.lambda.parameter=提取 Lambda 形参
dialog.message.lambdas.not.supported=当前语言标准不支持 lambda
dialog.message.lambdas.cant.extract.initializer.list=无法将初始值设定项列表提取到 lambda 参数
dialog.message.lambdas.cant.extract.functional.type=无法将函数类型的表达式提取到 lambda 参数
dialog.message.lambdas.cant.extract.dependent.types=无法将具有依赖类型的表达式提取到 lambda 参数
dialog.message.cant.refactor.operators=无法重构 C++ 运算符函数
button.extract=提取
dialog.message.cannot.extract.there.are.multiple.exit.points.in.selected.code.fragment=无法提取{0}。\n所选代码段中有多个出口点.
dialog.message.selected.statements.should.be.inside.function.choice.or.method=选定的语句应在函数{0, choice, 0#或方法|1#}内
dialog.message.can.t.refactor.with.variable.arguments=无法重构具有可变实参的{0}
dialog.message.overrides.in.choice.which.out.project={0} 重写{3, choice, 0#项目外的|1#} {2} 中的 {1}。
dialog.message.do.you.want.to.proceed.refactoring=继续进行重构?
dialog.message.do.you.want.to.refactor.base.s=重构基{0}?
label.declaration.place=声明位置:
refactoring.rename.command.name=重命名
trying.to.rename.0.to.existing.file.name.1=试图将 {0} 重命名为现有文件名 {1}
file.0.already.exists.in.the.project=文件 ''{0}'' 已经存在于项目中
refactoring.rename.0.already.exists.in.1={1} 中已存在 {0}
refactoring.rename.0.already.exists.in.the.scope=范围中已存在 {0}
dialog.message.name.invalid={0} 名称无效
dialog.message.return.type.invalid={0} 的返回类型无效
dialog.message.no.selector.parts.for={0} 没有选择器部分
dialog.message.containing.class.invalid=包含类“{0}”无效
dialog.message.containing.class.outside.project=包含类“{0}”在项目之外
dialog.message.selector.part.invalid=选择器部分 ''{0}'' 无效
dialog.message.parameter.name.invalid=参数名 ''{0}'' 无效
selected.expression.should.be.inside.a.block.statement=所选表达式应位于块语句内
can.t.refactor.the.compound.initializer=无法重构复合初始值设定项
cannot.determine.type.of.the.selected.expression=无法确定所选表达式的类型
cannot.perform.refactoring.selected.expression.has.void.type=无法执行重构，因为所选表达式具有 void 类型。
selected.expression.cannot.be.a.constant.initializer=所选表达式不能是常量初始值设定项
selected.expression.should.be.inside.an.instance.method=所选表达式应位于实例方法内
selected.expression.should.be.inside.a.function.or.method=所选表达式应位于函数或方法内
can.t.introduce.parameter.to.a.function.with.default.parameter.values=无法将参数引入具有默认形参值的函数
selected.expression.should.be.inside.an.instance.method1=所选表达式应位于实例方法内
property.inplace.introducer.label.semantics=语义
declaration.must.have.one.declarator.to.introduce.the.type=声明必须具有一个声明器以引入类型
namespace.qualifier.should.be.resolved.to.the.class=命名空间限定符应解析为该类
the.type.is.empty=类型为空
can.t.extract.type.of.0.definition=无法提取 {0} 定义的类型
dialog.message.can.t.move.to.itself=无法将 ''{0}'' 移至自身
dialog.message.can.t.copy.to.itself=无法将 ''{0}'' 复制到自身
dialog.message.directory.already.exists.at=目录在 ''{0}'' 已存在
dialog.message.file.already.exists.at=''{0}'' 已存在文件
dialog.message.file.already.exists=文件已存在
extract.dialog.button.extract=提取(&R)
escalate.visibility.member.column=成员
escalate.visibility.current.visibility.column=当前可见性
escalate.visibility.required.visibility.column=所需可见性
push.down.inheritor.column=继承者
text.parameter.initializer.not.available.in=参数初始值设定项在 {0} 中不可用: {1}。
cannot.inline.function.type=无法内联函数类型
cannot.inline.constructor.expression=无法内联构造函数表达式
can.t.inline.definition=无法内联 {0} 定义
cannot.inline.the.macro.inside.another.macro.definition=无法内联另一个宏定义中的宏
cannot.find.the.method.function=找不到方法/函数
there.are.usages.in.other.blocks=在其他块中存在用法
0.was.not.initialized={0} 未初始化
there.are.several.definitions.of={0} 存在多个定义
the.address.of.is.taken={0} 的地址已被占用
element.is.written.in.the.block={0} 写于块中
several.definitions.of.0={0} 存在多个定义
element.is.accessed.for.writing={0} 可写
cannot.inline.usages.inside.the.macro.substitutions=无法内联宏替换内的用法
element.has.inheritor={0} 带有继承者{1, choice, 0#方法|1#函数}
element.inherits.method={0} 从 {1} 继承方法
cannot.inline.method.reference.in.selector.expression=无法在 '@selector' 表达式中内联方法引用
cannot.inline.method.reference.in.xml.file=无法在 XML 文件中内联方法引用
cannot.inline.method.reference.in.property.attribute=无法在属性特性中内联方法引用
cannot.inline.function.reference.in.non.call.expression=无法在非调用表达式中内联函数引用
cannot.inline.usage.in.swift.code=无法在 Swift 代码中内联用法
cannot.inline.recursive=无法内联递归 {0} 调用
dialog.message.elements.to=要{0}的元素
top.level.namespace.placeholder=顶层命名空间

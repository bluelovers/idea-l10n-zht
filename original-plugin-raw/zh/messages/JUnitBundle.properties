fork.mode.label=复刻模式(&F):
fork.mode.name=复刻模式

repeat.label=重复(&R):
repeat.name=重复
repeat.count.label=重复计数(&R):

search.scope.name=搜索测试
search.scope.project=在整个项目中
search.scope.module=在单个模块中
search.scope.module.deps=在模块依赖项中

test.group=测试
#possible run targets
category.label=类别
change.list.label=变更列表
directory.label=目录
pattern.label=模式
tag.expression.label=标记表达式
uniqueid.label=UniqueId

#actions
action.AddToISuite.text=添加到 JUnit 模式套件
action.excludeFromSuite.text=从套件中排除
action.text.test.unknown.target=未知
action.text.test.category={0} 的测试
action.text.test.tags={0} 的测试

unused.declaration.junit.test.entry.point=JUnit 测试用例
test.discovery.by.all.changes.combo.item=所有
module.does.not.exists=模块''{0}''不存在于项目''{1}''
junit.configuration.description=JUnit 测试配置
junit.configuration.class.label=类:
no.pattern.error.message=未选择模式
junit.configuration.method.label=方法:
default.junit.config.name.whole.project=整个项目
default.junit.config.name.all.in.module={0}中的所有
default.junit.configuration.name=<无名称>
default.junit.config.name.all.in.package.in.module={1}中的{0}
default.junit.config.name.temp.suite=临时套件
default.junit.config.name.tags=标记({0})
default.junit.config.empty.category=无效
default.junit.config.name.category=@Category({0})
junit.configuration.in.single.module.radio=在单一模块
no.test.class.specified.error.text=未指定测试类
directory.not.found.error.message=未找到目录 ''{0}''
junit5.malformed.repeated.test.display.name=JUnit 5 格式错误的重复测试
junit5.nested.test.display.name=JUnit 5 格式错误的 '@Nested' 类
junit5.malformed.nested.class.inspection.description=只有非 static 嵌套类才能用作 '@Nested' 测试类。
junit5.malformed.repetition.description.injected.for.test=不会为 @Test 方法注入 RepetitionInfo
junit5.malformed.repetition.description.injected.for.each=仅会为 @BeforeEach/@AfterEach 注入 RepetitionInfo，但不会为 {0} 注入
junit5.malformed.repetition.description.injected.for.repeatedtest=仅会为 @RepeatedTest 注入 RepetitionInfo 
junit5.malformed.repetition.description.positive.number=重复次数必须大于零
junit5.malformed.repetition.description.suspicious.combination=可疑的 @Test 和 @RepeatedTest 组合
create.setup.dialog.message=方法 setUp 已存在，但未使用 {0} 注解。是否注解?
junit.configuration.display.name=JUnit
class.isnt.inheritor.of.testcase.error.message={0}没有继承人的TestCase
cannot.browse.test.inheritors.dialog.title=无法浏览TestCase继承器
junit.configuration.package.label=包:
create.setup.dialog.title=创建 setUp 方法
junit.not.found.in.module.error.message=在模块''{0}''中未找到JUnit
junit.configuration.across.module.dependencies.radio=跨模块依赖项
method.name.not.specified.error.message=未指定方法名称
junit.configuration.search.for.tests.label=搜索测试:
class.not.test.error.message=类 ''{0}'' 不是测试
configuration.not.specified.message=配置测试类型未指定: {0}
package.does.not.exist.error.message=软件包 ''{0}'' 不存在
test.method.doesnt.exist.error.message=测试方法''{0}''不存在
junit.configuration.in.whole.project.radio=在整个项目
junit.entry.point.suggest.package.private.visibility.junit5=建议 Junit 5 测试的 package-private 可见性级别
category.is.not.specified.error.message=未指定类别
directory.is.not.specified.error.message=未指定目录
directory.0.is.not.found.error.message=找不到目录 ''{0}''
module.to.choose.classpath.not.specified.error.message=未指定从中选择类路径的模块
tags.are.not.specified.error.message=未指定标记
tag.name.0.must.be.syntactically.valid.warning=标记名称 [{0}] 的语法必须有效
dialog.message.no.unique.id.specified.exception=未指定唯一 ID
test.kind.hint=用于搜索测试的资源类型
test.pattern.hint=用于匹配包含测试的类的名称的正则表达式
test.class.hint=包含测试的类的完全限定名称
test.method.hint=测试方法的完全限定名称
test.package.hint=包含测试的软件包的名称

# configuration kinds
junit.configuration.kind.all.in.package=软件包中的所有
junit.configuration.kind.all.in.directory=目录中的所有
junit.configuration.kind.by.pattern=模式
junit.configuration.kind.class=类
junit.configuration.kind.method=方法
junit.configuration.kind.category=类别
junit.configuration.kind.by.unique.id=UniqueId
junit.configuration.kind.by.tags=标记

# repeat modes
junit.configuration.repeat.mode.once=一次
junit.configuration.repeat.mode.n.times=N 次
junit.configuration.repeat.mode.until.failure=直至失败

# fork modes
junit.configuration.fork.mode.none=无
junit.configuration.fork.mode.method=方法
junit.configuration.fork.mode.class=类
junit.configuration.fork.mode.repeat=重复

combobox.changelists.all=所有

no.module.selected.error.message=未选择模块
category.interface.dialog.title=类别接口
running.tests.disabled.during.index.update.error.message=运行测试在索引更新期间处于禁用状态
dialog.message.failed.to.resolve.maven.id=无法解析 {0}
junit5.migration.description=将 JUnit 4 测试注解转移到新的 Jupiter 注解中时，可能会导致出现红色代码! 不会迁移断言。请参阅“Java | JUnit 问题 | JUnit 4 测试可能为 JUnit 5”检查，只迁移可以完全自动转换的测试。
junit.configuration.repeat.mode.until.stopped=直至停止
junit5.malformed.parameterized.display.name=格式错误的形参化测试
junit5.malformed.parameterized.inspection.description.method.source.unresolved=无法解析目标方法源: ''{0}''
junit5.malformed.parameterized.inspection.description.wrapped.in.arguments=必须在 'Arguments' 中包装多个参数
junit5.malformed.parameterized.inspection.description.method.source.return.type=方法源 ''{0}'' 必须具有以下返回类型之一: ''Stream<?>''、''Iterator<?>''、''Iterable<?>'' 或 ''Object[]''
junit5.malformed.parameterized.inspection.description.method.source.no.params=方法源 ''{0}'' 不应有参数
junit5.malformed.parameterized.inspection.description.method.source.static=方法源 ''{0}'' 必须为 static
junit5.malformed.parameterized.inspection.description.method.source.assignable=未找到将 ''{0}'' 类型的对象转换为 ''{1}'' 的隐式转换
junit5.malformed.parameterized.inspection.description.duplicated.enum=重复的 'enum' 常量名称
junit5.malformed.parameterized.inspection.description.unresolved.enum=无法解析 'enum' 常量引用。
junit5.malformed.parameterized.inspection.description.no.value.source.is.defined=未定义值源
junit5.malformed.parameterized.inspection.description.exactly.one.type.of.input.must.be.provided=必须恰好提供一种类型的输入
junit5.malformed.parameterized.inspection.description.file.source=无法解析文件源: ''{0}''
junit5.malformed.parameterized.fix.text=更改为 ''{0}''
junit5.malformed.parameterized.inspection.description.suspicious.combination.test.and.parameterizedtest='@Test' 和 '@ParameterizedTest' 的组合可疑
junit5.malformed.parameterized.inspection.description.suspicious.combination=可疑的 '@Test' 和形参化源组合
junit5.malformed.parameterized.inspection.description.multiple.parameters.are.not.supported.by.this.source=此源不支持多个参数
junit5.malformed.parameterized.inspection.description.no.sources.are.provided=没有提供源，套件将为空
junit5.malformed.parameterized.fix.family.name=替换注解
progress.title.download.additional.dependencies=下载其他依赖项…
junit5.malformed.parameterized.inspection.description.nullsource.cannot.provide.argument.no.params=''@{0}'' 无法向方法提供实参，因为方法没有形参
junit5.malformed.parameterized.inspection.description.nullsource.cannot.provide.argument.too.many.params=''@{0}'' 无法向方法提供实参，因为方法提供了过多形参
junit5.malformed.parameterized.inspection.description.emptysource.cannot.provide.argument=''@{0}'' 无法向方法提供实参，因为方法具有不受支持的 ''{1}'' 类型的形参
junit5.extensions.display.name=JUnit5 格式错误的扩展程序注册
junit5.malformed.extension.registration.message={0} 应实现 {1}
junit5.malformed.extension.class.level.message={0} 应在类级别注册，否则将不会执行 BeforeAll/AfterAll 方法
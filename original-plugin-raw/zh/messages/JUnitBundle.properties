action.AddToISuite.text=添加到 JUnit 模式套件
action.excludeFromSuite.text=从套件中排除
action.text.test.category={0} 的测试
action.text.test.tags={0} 的测试
action.text.test.unknown.target=未知
async.stack.trace.for.exceptions.name=打印异常的异步堆栈跟踪
cannot.browse.test.inheritors.dialog.title=无法浏览TestCase继承器
category.interface.dialog.title=类别接口
category.is.not.specified.error.message=未指定类别
category.label=类别
change.list.label=更改列表
class.isnt.inheritor.of.testcase.error.message={0}没有继承人的TestCase
class.not.test.error.message=类 ''{0}'' 不是测试
combobox.changelists.all=所有
configuration.not.specified.message=配置测试类型未指定\: {0}
create.setup.dialog.message=方法 setUp 已存在，但未使用 {0} 注解。是否注解?
create.setup.dialog.title=创建 setUp 方法
default.junit.config.empty.category=无效
default.junit.config.name.all.in.module={0}中的所有
default.junit.config.name.all.in.package.in.module={1}中的{0}
default.junit.config.name.category=@Category({0})
default.junit.config.name.tags=标记({0})
default.junit.config.name.temp.suite=临时套件
default.junit.config.name.whole.project=整个项目
default.junit.configuration.name=<无名称>
dialog.message.failed.to.resolve.maven.id=无法解析 {0}
dialog.message.no.unique.id.specified.exception=未指定唯一 ID
dialog.title.preparing.test=正在准备测试
directory.0.is.not.found.error.message=找不到目录 ''{0}''
directory.is.not.specified.error.message=未指定目录
directory.label=目录
directory.not.found.error.message=未找到目录 ''{0}''
expected.exception.never.thrown.display.name=从未在测试方法正文中抛出预期异常
expected.exception.never.thrown.problem.descriptor=从未在 ''{0}()'' 的正文中抛出预期 <code>\#ref</code> \#loc
fix.data.provider.create.method.fix.name=创建数据提供程序方法 '@Parameters public static Iterable<Object> parameters()'
fix.data.provider.multiple.methods.problem=类 <code>\#ref</code> 中存在多个 @Parameters 数据提供程序方法
fix.data.provider.signature.family.name=修正数据提供程序方法签名
fix.data.provider.signature.fix.name=将方法签名更改为 ''{0}''
fix.data.provider.signature.incorrect.problem=数据提供程序方法 <code>\#ref()</code> 的签名不正确
fix.data.provider.signature.missing.method.problem=形参化测试类 <code>\#ref</code> 缺少用 '@Parameters' 注解的数据提供程序方法
fork.mode.label=复刻模式(&F)\:
fork.mode.name=复刻模式
inspection.parameterized.parameters.static.collection.display.name=没有数据提供程序方法的形参化测试类
junit.config.with.parameter.0=带有形参“{0}”
junit.configuration.across.module.dependencies.radio=跨模块依赖项
junit.configuration.class.label=类\:
junit.configuration.description=JUnit 测试配置
junit.configuration.display.name=JUnit
junit.configuration.fork.mode.class=类
junit.configuration.fork.mode.method=方法
junit.configuration.fork.mode.none=无
junit.configuration.fork.mode.repeat=重复
junit.configuration.in.single.module.radio=在单一模块
junit.configuration.in.whole.project.radio=在整个项目
junit.configuration.kind.all.in.directory=目录中的所有
junit.configuration.kind.all.in.package=软件包中的所有
junit.configuration.kind.by.pattern=模式
junit.configuration.kind.by.tags=标记
junit.configuration.kind.by.unique.id=UniqueId
junit.configuration.kind.category=类别
junit.configuration.kind.class=类
junit.configuration.kind.method=方法
junit.configuration.method.label=方法\:
junit.configuration.package.label=包\:
junit.configuration.repeat.mode.n.times=N 次
junit.configuration.repeat.mode.once=一次
junit.configuration.repeat.mode.until.failure=直至失败
junit.configuration.repeat.mode.until.stopped=直至停止
junit.configuration.repeat.mode.until.success=直到成功
junit.configuration.search.for.tests.label=搜索测试\:
junit.entry.point.suggest.package.private.visibility.junit5=建议 Junit 5 测试的 package-private 可见性级别
junit.inspections.group.name=JUnit
junit.not.found.in.module.error.message=在模块''{0}''中未找到JUnit
junit3.style.test.method.in.junit4.class.display.name=JUnit 4 类中的旧样式 JUnit 测试方法
junit3.style.test.method.in.junit4.class.problem.descriptor=JUnit 4 类中的旧样式 JUnit 测试方法 <code>\#ref()</code> \#loc
junit5.migration.description=将 JUnit 4 测试注解迁移到新的 Jupiter 注解中时，可能会导致出现红色代码\! 断言不会迁移。请参阅“JUnit 问题 | JUnit 4 测试可能为 JUnit 5”检查，只迁移可以完全自动转换的测试。
jvm.inspections.junit.assertequals.may.be.assertsame.display.name='assertEquals()' 可能是 'assertSame()'
jvm.inspections.junit.assertequals.may.be.assertsame.problem.descriptor=<code>\#ref()</code> 可能是 'assertSame()' \#loc
jvm.inspections.junit.assertequals.on.array.display.name=在数组上调用了 'assertEquals()'
jvm.inspections.junit.assertequals.on.array.problem.descriptor=在数组上调用了 <code>\#ref()</code> \#loc
jvm.inspections.junit.ignored.test.class.problem.descriptor=测试类 ''{0}'' 已被{1, choice, 1\#|2\#无理由}忽略/禁用 \#loc
jvm.inspections.junit.ignored.test.display.name=使用 '@Ignore'/'@Disabled' 注解的 JUnit 测试
jvm.inspections.junit.ignored.test.ignore.reason.option=只报告没有原因的注解
jvm.inspections.junit.ignored.test.method.problem.descriptor=测试方法 ''{0}()'' 已被{1, choice, 1\#|2\#无理由}忽略/禁用 \#loc
jvm.inspections.junit.malformed.annotated.double.descriptor=使用 ''@{1}'' 注解的{0, choice, 0\#字段|1\#方法} <code>\#ref</code> 应为 {2} 和 {3}
jvm.inspections.junit.malformed.annotated.double.typed.descriptor=使用 ''@{1}'' 注解的{0, choice, 0\#字段|1\#方法} <code>\#ref</code> 应为 {2}、{3} 且类型应为 ''{4}''
jvm.inspections.junit.malformed.annotated.method.double.param.double.descriptor=使用 ''@{0}'' 注解的方法 <code>\#ref</code> 应为 {1}，{2}，且不应声明形参 ''{3}'' 和 ''{4}''
jvm.inspections.junit.malformed.annotated.method.double.param.single.descriptor=使用 ''@{0}'' 注解的方法 <code>\#ref</code> 应为 {1}，{2}，且不应声明形参 ''{3}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.double.descriptor=使用 ''@{0}'' 注解的方法 <code>\#ref</code> 应为 {1}，{2}，类型应为 ''{3}''，且不应声明形参 {4} 和 ''{5}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.single.descriptor=使用 ''@{0}'' 注解的方法 <code>\#ref</code> 应为 {1}，{2}，类型应为 ''{3}''，且不应声明形参 ''{4}''
jvm.inspections.junit.malformed.annotated.method.param.double.descriptor=使用 ''@{0}'' 注解的方法 <code>\#ref</code> 不应声明形参 {1} 和 ''{2}''
jvm.inspections.junit.malformed.annotated.method.param.single.descriptor=使用 ''@{0}'' 注解的方法 <code>\#ref</code> 不应声明形参 ''{1}''
jvm.inspections.junit.malformed.annotated.method.single.param.double.descriptor=使用 ''@{0}'' 注解的方法 <code>\#ref</code> 应为 {1} 且不应声明形参 ''{2}'' 和 ''{3}''
jvm.inspections.junit.malformed.annotated.method.single.param.single.descriptor=使用 ''@{0}'' 注解的方法 <code>\#ref</code> 应为 {1} 且不应声明形参 ''{2}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.double.descriptor=使用 ''@{0}'' 注解的方法 <code>\#ref</code> 应为 {1}，类型应为 ''{2}''，且不应声明形参 {3} 和 ''{4}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.single.descriptor=使用 ''@{0}'' 注解的方法 <code>\#ref</code> 应为 {1}，类型应为 ''{2}''，且不应声明形参 ''{3}''
jvm.inspections.junit.malformed.annotated.method.typed.param.double.descriptor=使用 ''@{0}'' 注解的方法 <code>\#ref</code> 的类型应为 ''{1}''，且不应声明形参 {2} 和 ''{3}''
jvm.inspections.junit.malformed.annotated.method.typed.param.single.descriptor=使用 ''@{0}'' 注解的方法 <code>\#ref</code> 的类型应为 ''{1}'' 且不应声明形参 ''{2}''
jvm.inspections.junit.malformed.annotated.single.descriptor=使用 ''@{1}'' 注解的{0, choice, 0\#字段|1\#方法} <code>\#ref</code> 应为 {2}
jvm.inspections.junit.malformed.annotated.single.typed.descriptor=使用 ''@{1}'' 注解的{0, choice, 0\#字段|1\#方法} <code>\#ref</code> 应为 {2} 且类型应为 ''{3}''
jvm.inspections.junit.malformed.annotated.suspend.function.descriptor=使用 ''@{0}'' 注解的方法 <code>\#ref</code> 不应为挂起函数
jvm.inspections.junit.malformed.annotated.typed.descriptor=使用 ''@{1}'' 注解的{0, choice, 0\#字段|1\#方法} <code>\#ref</code> 类型应为 ''{2}''
jvm.inspections.junit.malformed.declaration.name=JUnit 格式错误的声明
jvm.inspections.junit.malformed.extension.class.level.descriptor=应在类级别注册{0}
jvm.inspections.junit.malformed.fix.class.signature=修正类签名
jvm.inspections.junit.malformed.fix.class.signature.descriptor=修正 ''{0}'' 类签名
jvm.inspections.junit.malformed.fix.class.signature.multi=修正类签名
jvm.inspections.junit.malformed.fix.field.signature=修正字段签名
jvm.inspections.junit.malformed.fix.field.signature.descriptor=修正 ''{0}'' 字段签名
jvm.inspections.junit.malformed.fix.method.signature=修复方法签名
jvm.inspections.junit.malformed.fix.method.signature.descriptor=修复 ''{0}'' 方法签名
jvm.inspections.junit.malformed.missing.nested.annotation.descriptor=不会执行嵌套类中的测试
jvm.inspections.junit.malformed.no.arg.descriptor=方法 <code>\#ref</code> 应为 {0}、{1}{2, choice, 0\#且无形参|1\#，无形参，且类型为 void}
jvm.inspections.junit.malformed.option.ignore.test.parameter.if.annotated.by=由以下对象注解时忽略测试形参\:
jvm.inspections.junit.malformed.param.duplicated.enum.descriptor=重复的 'enum' 常量名称
jvm.inspections.junit.malformed.param.empty.source.unsupported.descriptor=''@{0}'' 无法向方法提供实参，因为方法具有不受支持的 ''{1}'' 类型的形参
jvm.inspections.junit.malformed.param.exactly.one.type.of.input.must.be.provided.descriptor=必须恰好提供一种类型的输入
jvm.inspections.junit.malformed.param.field.source.return.type.descriptor=字段源 ''{0}'' 类型必须可转换为 Stream
jvm.inspections.junit.malformed.param.field.source.static.descriptor=字段源 ''{0}'' 必须为 static
jvm.inspections.junit.malformed.param.field.source.unresolved.descriptor=无法解析目标字段源\: ''{0}''
jvm.inspections.junit.malformed.param.file.source.descriptor=无法解析文件源\: ''{0}''
jvm.inspections.junit.malformed.param.method.source.assignable.descriptor=未找到将 ''{0}'' 转换为 ''{1}'' 的隐式转换
jvm.inspections.junit.malformed.param.method.source.missing.name.descriptor=使用 @MethodSource 和 @ParameterizedClass 时必须指定方法名称
jvm.inspections.junit.malformed.param.method.source.no.params.descriptor=方法源 ''{0}'' 不应有形参
jvm.inspections.junit.malformed.param.method.source.return.type.descriptor=方法源 ''{0}'' 必须具有以下其中一种返回值类型\: ''Stream<?>''、''Iterator<?>''、''Iterable<?>'' 或 ''Object[]''
jvm.inspections.junit.malformed.param.method.source.static.descriptor=方法源 ''{0}'' 必须为 static
jvm.inspections.junit.malformed.param.method.source.unresolved.descriptor=无法解析目标方法源\: ''{0}''
jvm.inspections.junit.malformed.param.multiple.parameters.descriptor=''@{0}'' 只能提供一个形参
jvm.inspections.junit.malformed.param.no.sources.are.provided.descriptor=没有提供源，套件将为空
jvm.inspections.junit.malformed.param.no.value.source.is.defined.descriptor=未定义值源
jvm.inspections.junit.malformed.param.unresolved.enum.descriptor=无法解析 'enum' 常量引用。
jvm.inspections.junit.malformed.param.wrapped.in.arguments.descriptor=必须在 'Arguments' 中包装多个形参
jvm.inspections.junit.malformed.repetition.number.descriptor=重复次数必须大于零
jvm.inspections.junit.malformed.single.constructor.descriptor=类 {0} 必须声明单一构造函数
jvm.inspections.junit.malformed.source.without.constructor=''@{0}'' 无法向构造函数 [''{1}''] 提供实参\: 未声明任何形参
jvm.inspections.junit.malformed.source.without.params.descriptor=''@{0}'' 无法向方法提供实参，因为方法没有形参
jvm.inspections.junit.malformed.suspend.function.descriptor=方法 <code>\#ref</code> 不应为挂起函数
jvm.inspections.junit.malformed.test.combination.descriptor=可疑的 {0} 与 ''@{1}'' 组合
jvm.inspections.junit.mixed.annotations.junit.descriptor=扩展 JUnit {1} TestCase 的类内使用 ''@{0}'' 注解的方法 <code>\#ref()</code> \#loc
jvm.inspections.junit.mixed.annotations.name=在单个 TestCase 中使用多个版本的 JUnit API
jvm.inspections.junit3.super.teardown.display.name=未从 'finally' 块调用 JUnit 3 'super.tearDown()'
jvm.inspections.junit3.super.teardown.problem.descriptor=未从 'finally' 块调用 <code>\#ref()</code> \#loc
jvm.inspections.junit4.converter.display.name=JUnit 3 测试可以是 JUnit 4
jvm.inspections.junit4.converter.problem.descriptor=<code>\#ref</code> 可以转换为 JUnit4 测试用例
jvm.inspections.junit4.converter.quickfix.conflict.call.compile=如果 {1} 被转换为 JUnit 4，方法调用 {0} 将不编译
jvm.inspections.junit4.converter.quickfix.conflict.name=方法 {0} 将与其 super 方法发生名称冲突
jvm.inspections.junit4.converter.quickfix.conflict.semantics=如果 {1} 被转换为 JUnit 4，方法调用 {0} 可能会更改语义
jvm.inspections.junit4.converter.quickfix.conflict.suite={0} 的 suite 方法的迁移有副作用，将被删除
jvm.inspections.junit4.converter.quickfix.name=转换为 JUnit 4 测试用例
jvm.inspections.junit4.inherited.runwith.display.name='@RunWith' 注解已存在于父类中
jvm.inspections.junit4.inherited.runwith.problem.descriptor=''@RunWith'' 注解已存在于{0}类中
jvm.inspections.junit5.assertions.converter.display.name=JUnit 5 已废弃断言
jvm.inspections.junit5.assertions.converter.familyName=替换为 JUnit 5 兼容调用
jvm.inspections.junit5.assertions.converter.problem.descriptor=对来自 ''{0}'' 的 <code>\#ref()</code> 的调用应替换为对来自 ''{1}'' 的方法的调用 \#loc
jvm.inspections.junit5.assertions.converter.quickfix=替换为 ''{0}'' 方法调用
jvm.inspections.junit5.converter.display.name=JUnit 4 测试可以为 JUnit 5
jvm.inspections.junit5.converter.problem.descriptor=\#ref 可以为 JUnit 5 测试
jvm.inspections.junit5.converter.quickfix=迁移到 JUnit 5
jvm.inspections.junit5.converter.quickfix.conflict.inheritor=由于存在不兼容的继承者，类 {0} 无法转换为 JUnit 5\: {1}
jvm.inspections.junit5.converter.quickfix.presentation.text=转换断言
jvm.inspections.migrate.assert.to.matcher.description=断言表达式 <code>\#ref</code> 可被替换为 ''{0}'' 调用 \#loc
jvm.inspections.migrate.assert.to.matcher.option=静态导入匹配程序的方法
jvm.inspections.migrate.assertion.name=JUnit 断言可以是 'assertThat()' 调用
jvm.inspections.unconstructable.test.case.junit3.descriptor=测试类 <code>\#ref</code> 不可构造，因为它没有 'public' 无实参或单个 'String' 形参构造函数 \#loc
jvm.inspections.unconstructable.test.case.junit4.descriptor=测试类 <code>\#ref</code> 不可构造，因为它应当正好有一个 'public' 无实参构造函数 \#loc
jvm.inspections.unconstructable.test.case.not.public.descriptor=测试类 <code>\#ref</code> 不可构造，因为它不是 'public' \#loc
method.name.not.specified.error.message=未指定方法名称
module.does.not.exists=模块''{0}''不存在于项目''{1}''
module.to.choose.classpath.not.specified.error.message=未指定从中选择类路径的模块
multiple.exceptions.declared.on.test.method.display.name=在测试方法上声明的多个异常
multiple.exceptions.declared.on.test.method.problem.descriptor=<code>\#ref</code> 可被替换为 'throws Exception' \#loc
no.module.selected.error.message=未选择模块
no.pattern.error.message=未选择模式
no.test.class.specified.error.text=未指定测试类
package.does.not.exist.error.message=软件包 ''{0}'' 不存在
pattern.label=模式
progress.title.download.additional.dependencies=下载其他依赖项…
repeat.count.label=重复计数(&R)\:
repeat.label=重复(&R)\:
repeat.name=重复
running.tests.disabled.during.index.update.error.message=运行测试在索引更新期间处于禁用状态
search.scope.module=在单个模块中
search.scope.module.deps=在模块依赖项中
search.scope.name=搜索测试
search.scope.project=在整个项目中
tag.expression.label=标记表达式
tag.name.0.must.be.syntactically.valid.warning=标记名称 [{0}] 的语法必须有效
tags.are.not.specified.error.message=未指定标记
test.class.hint=包含测试的类的完全限定名称
test.discovery.by.all.changes.combo.item=所有
test.group=测试
test.kind.hint=用于搜索测试的资源类型
test.method.doesnt.exist.error.message=测试方法''{0}''不存在
test.method.hint=测试方法的完全限定名称
test.package.hint=包含测试的软件包的名称
test.pattern.hint=用于匹配包含测试的类的名称的正则表达式
uniqueid.label=UniqueId
unused.declaration.junit.test.entry.point=JUnit 测试用例
usage.of.obsolete.assert.display.name=使用废弃的 'junit.framework.Assert' 方法
use.of.obsolete.assert.problem.descriptor=对来自 ''{0}'' 的 <code>\#ref()</code> 的调用应被替换为对来自 ''org.junit.Assert'' 的方法的调用 \#loc
use.of.obsolete.assert.quickfix=替换为 'org.junit.Assert' 方法调用

access.static.field.via.class.reference.text=通过引用类 ''{1}'' 限定 static ''{0}'' 访问
access.static.method.via.class.reference.text=通过引用类 ''{1}'' 限定 static ''{0}'' 调用
access.static.via.class.reference.family=通过类引用限定 static 成员访问
access.static.via.class.reference.title=通过类引用限定 static 成员访问
add.0.to.classpath=将 ''{0}'' 添加到类路径中
add.annotation.attribute.name=添加 ''{0}\=''
add.annotation.attribute.name.family.name=添加注解特性名称
add.catch.clause.family=将异常添加到 catch 子句
add.catch.clause.text=添加 'catch' 子句
add.class.to.extends.list=使 ''{0}'' 扩展 ''{1}''
add.compiler.option.fix.name=将 ''{0}'' 添加到模块编译器选项
add.constructor.parameter.name=添加构造函数形参
add.constructor.parameters=添加构造函数形参
add.default.branch.to.variable.initializing.switch.fix.name=将 ''default'' 分支添加到初始化 ''{0}'' 的 ''switch'' 语句中
add.default.constructor.family=添加默认构造函数
add.default.constructor.text=将 {0} 无实参构造函数添加到 {1}
add.docTag.to.custom.tags=将 ''@{0}'' 添加到自定义标记
add.docTag.to.custom.tags.preview=将此标记添加到此检查将忽略的自定义标记列表中。
add.exception.from.field.initializer.to.constructor.throws.family.text=将异常添加到构造函数签名
add.exception.from.field.initializer.to.constructor.throws.text=将异常添加到构造函数{0, choice, 0\#签名|1\#签名|2\#签名}
add.exception.to.existing.catch.chooser.title=选择 Catch 块
add.exception.to.existing.catch.family=向现有 Catch 子句添加异常
add.exception.to.existing.catch.generic=向现有 Catch 子句添加异常
add.exception.to.existing.catch.no.replacement=将 ''{1}'' 添加到具有 ''{0}'' 的 catch
add.exception.to.existing.catch.replacement=用更通用的 ''{1}'' 替换 ''{0}''
add.exception.to.throws.family=向方法签名添加异常
add.exception.to.throws.header=向方法签名添加{0, choice, 0\#异常|2\#异常}
add.exception.to.throws.hierarchy=更改层次结构中的所有方法
add.exception.to.throws.only.this=只更改此方法
add.exception.to.throws.text=添加{0, choice, 0\#异常|2\#异常}到方法签名
add.finally.block.family=添加 'finally' 块
add.import=添加导入
add.interface.to.implements.list=使 ''{0}'' 实现 ''{1}''
add.library.copy.files.to.radio.button=将''{0}''库文件复制到 (&C)
add.library.description.choose.folder=选择要复制的库所在的目录
add.library.error.cannot.copy=无法将 ''{0}'' 复制到 ''{1}''\n({2})
add.library.error.not.found=库文件 ''{0}'' 不存在
add.library.title.choose.folder=选择目录
add.library.title.dialog=将 ''{0}'' 库添加到项目
add.library.use.bundled.library.radio.button=使用{1}分发中的''{0}'' (&U)
add.method.body.text=添加方法体
add.method.family=添加方法
add.method.qualifier.fix.family=添加方法限定符
add.method.qualifier.fix.text=将限定符 ''{0}'' 添加到方法
add.method.text=将方法 ''{0}'' 添加到类 ''{1}''
add.missing.annotation.parameters.fix=添加缺少的注解形参 - {0}
add.missing.annotation.single.parameter.fix=添加缺少的注解形参 ''{0}''
add.missing.nested.patterns.fix.text=添加缺少的嵌套模式{0, choice, 1\#|2\#}
add.missing.str.processor=添加 'STR.' 处理器
add.modifier.fix=将 ''{0}'' 设为{1}
add.modifier.fix.family=设为{0}
add.new.array.family=添加缺少的新表达式
add.new.array.text=添加 ''new {0}[]''
add.parameter.from.usage.text=将 ''{0}'' 作为第 {1,number,ordinal} 个{2}添加到{3} ''{4}'' 中
add.qualifier=添加限定符
add.qualifier.original.class.chooser.title=原始类
add.return.statement.text=添加 'return' 语句
add.runtime.exception.to.throws.family=向方法签名添加运行时异常
add.runtime.exception.to.throws.header=向方法签名添加运行时异常
add.runtime.exception.to.throws.text=将 ''{0}'' 添加到方法签名
add.type.arguments.single.argument.text=添加显式类型实参
add.type.arguments.text=添加显式类型实参到第 {0, choice, 1\#1|2\#2|3\#3|4\#{0,number}} 个实参
add.typecast.cast.text=将{1}转换为 ''{0}''
add.typecast.convert.text=将{1}转换为 ''{0}''
add.typecast.family=添加类型转换
add.typecast.text=转换到 ''{0}''
adjust.method.accepting.functional.expression.fix.family.name=调整接受函数表达式的方法
adjust.method.accepting.functional.expression.fix.text=将 ''{0}()'' 替换为 ''{1}()''
adjust.package.family=调整软件包名称
adjust.package.text=将软件包名称设置为 ''{0}''
annotations.fix=注解
anonymous.class.presentation=派生自 {0} 的匿名类
bring.variable.to.scope.family=将变量引入作用域
bring.variable.to.scope.text=将 ''{0}'' 引入作用域
cannot.change.field.exception=无法更改字段 ''{0}'' 类型。\n原因\: {1}
cannot.create.java.file.error.text=无法在{1}中创建 {0}.java\: {2}
cannot.create.java.file.error.title=文件创建失败
cannot.create.java.package.error.text=无法在{1}中创建 {0}\: {2}
cannot.create.java.package.error.title=软件包创建失败
change.class.signature.family=更改类签名
change.class.signature.text=更改 ''{0}'' 的签名以匹配 ''{1}''
change.extends.list.family=扩展类自
change.method.parameters.family=更改方法形参
change.method.parameters.text=将方法形参更改为 ''{0}''
change.method.signature.from.usage.family=从用法更改方法签名
change.method.signature.from.usage.text=将 ''{0}'' 的签名更改为 ''{1}({2})''
change.new.operator.type.family=更改新运算符类型
change.new.operator.type.text=将 ''{0}'' 更改为 ''new {1}{2}''
change.parameter.class.family=更改形参类
change.parameter.from.usage.text=将{2} ''{3}'' 的第 {0,number,ordinal} 个{1}从 ''{4}'' 更改为 ''{5}''
change.to.append.family=修正 StringBuilder 追加
change.to.append.text=更改为 ''{0}''
change.to.similar.keyword.fix.family.name=更改为类似关键字
change.to.similar.keyword.fix.name=将拼写错误 ''{0}'' 修正为 ''{1}''
change.type.family=更改类型
change.type.text=将类型更改为 ''{0}''
choose.class.to.move.popup.title=选择要移动的类
choose.constructors.to.add.parameter.to=选择要向其添加形参的构造函数
choose.default.value.parameters.popup.title=选择默认值形参
choose.fields.to.generate.constructor.parameters.for=选择要为其生成构造函数形参的字段
class.initializer.presentation={0} 类初始值设定项
class.to.import.chooser.title=要导入的类
collection.addall.can.be.replaced.with.constructor.fix.description='\#ref()' 方法可被替换为形参化构造函数调用
collection.addall.can.be.replaced.with.constructor.fix.family.name=将 'addAll()/putAll()' 调用替换为形参化构造函数调用
collection.addall.can.be.replaced.with.constructor.fix.name=将 ''{0}()'' 调用替换为形参化构造函数调用
collection.addall.can.be.replaced.with.constructor.fix.options.dialog.title=添加要检查的类
collection.addall.can.be.replaced.with.constructor.fix.options.label=要检查的类\:
collection.to.array.family.name=应用转换 '.toArray()'
collection.to.array.text=应用转换 ''.toArray({0})''
convert.primitive.to.boxed.type=将基元类型转换为装箱类型
convert.to.string.family=修正字符字面量
convert.to.string.text=转换为字符串字面量
convert.variable.to.field.in.anonymous.class.fix.name=将 ''{0}'' 移至匿名对象
create.accessor.for.unused.field.family=创建未使用字段的访问器
create.annotation.family=将注解添加到声明
create.annotation.text=注解为 @{0}
create.block=创建块
create.class.from.new.family=从新的运算符创建类
create.class.from.usage.family=从用法创建类
create.class.from.usage.text=创建{0} ''{1}''
create.constant.from.usage.family=从用法创建常量
create.constructor.body.command=创建构造函数体
create.constructor.family=创建构造函数
create.constructor.from.new.family=从新的运算符创建构造函数
create.constructor.from.new.text=创建构造函数
create.constructor.from.super.call.family=从 super() 调用创建构造函数
create.constructor.from.this.call.family=从 this() 调用创建构造函数
create.constructor.matching.super=创建匹配 super 的构造函数
create.constructor.text=在 ''{0}'' 中创建构造函数
create.element.in.class=在 ''{2}'' 中创建{0} ''{1}''
create.field.from.usage.family=从用法创建字段
create.field.text=创建字段 {0}
create.getter=创建 Getter
create.getter.and.setter.for.field=为 ''{0}'' 创建 getter 和 setter
create.getter.for.field=为 ''{0}'' 创建 getter
create.getter.setter=创建 getter/setter
create.inner.class.from.usage.text=创建内部{0} ''{1}''
create.local.from.instanceof.usage.family=从 instanceof 用法创建局部变量
create.local.from.instanceof.usage.text=插入 ''({0}){1}'' 声明
create.local.from.usage.family=从用法创建本地
create.member.from.usage.family=从用法创建成员
create.method.body=创建方法体
create.method.from.usage.family=从用法创建方法
create.method.from.usage.text=创建方法 ''{0}''
create.parameter.from.usage.family=从用法创建形参
create.property.from.usage.family=从用法创建属性
create.property.from.usage.full.text=在 ''{1}'' 中创建属性 ''{0}''
create.property.from.usage.text=创建属性 ''{0}''
create.property.text=创建属性 {0}
create.read.only.property.from.usage.full.text=在 ''{1}'' 中创建只读属性 ''{0}''
create.read.only.property.from.usage.text=创建只读属性 ''{0}''
create.service=创建服务
create.service.implementation=创建服务实现
create.service.implementation.fix.family.name=创建服务实现类
create.service.implementation.fix.name=创建类 ''{0}''
create.service.interface.fix.family.name=创建服务
create.service.interface.fix.name=创建服务 ''{0}''
create.setter=创建 Setter
create.setter.for.field=为 ''{0}'' 创建 setter
create.type.parameter.from.usage.chooser.title=要添加类型形参的位置
create.type.parameter.from.usage.family=从用法创建类型形参
create.type.parameter.from.usage.text=创建类型形参 ''{0}''
create.write.only.property.from.usage.full.text=在 ''{1}'' 中创建只写属性 ''{0}''
create.write.only.property.from.usage.text=创建只写属性 ''{0}''
defer.final.assignment.with.temp.family=使用临时变量推迟最终赋值
defer.final.assignment.with.temp.text=使用临时变量推迟 ''{0}'' 赋值
delete.body.text=删除方法体
delete.catch.family=删除 catch
delete.catch.text=删除 ''{0}'' 的 catch
delete.reference.fix.text=删除引用
delete.return.fix.family=删除 return
delete.return.fix.side.effects.text=删除 return {0} 并提取副作用
delete.return.fix.text=删除 return {0}
delete.unreachable.statement.fix.text=删除不可到达的语句
enable.optimize.imports.on.the.fly=启用 '设置 | 编辑器 | 常规 | 自动导入 | 动态优化 import'
exchange.extends.implements.keyword=将 ''{0} {2}'' 更改为 ''{1} {2}''
extend.sealed.name=使 ''{0}'' {1, choice, 1\#扩展|2\#实现} ''{2}''
extend.sealed.title=使 ''{0}'' {1, choice, 1\#扩展|2\#实现} ''{2}''，并
extract.side.effects=提取副{0, choice, 1\#作用|2\#作用}
extract.side.effects.convert.to.if=作为 'if' 语句提取副作用
extract.side.effects.family.name=删除提取副作用的语句
field.to.import.chooser.title=要导入的字段
fix.add.special.annotation.family=添加到特殊注解
fix.add.special.annotation.text=将 ''{0}'' 添加到特殊注解列表
fix.add.write.annotation.description=将 ''@{0}'' 添加到标记隐式写入字段的注解列表中。<p>之后可以在“入口点 | 注解”下的“未使用的声明”检查设置中编辑此列表。
fix.add.write.annotation.text=假设由 ''@{0}'' 注解的字段为隐式写入
fix.argument.family=修正实参
fix.expression.role.argument=实参
fix.expression.role.expression=表达式
fix.expression.role.lambda.return=lambda 返回值
fix.expression.role.literal=字面量
fix.expression.role.nth.argument={0, choice, 1\#第 1|2\#第 2|3\#第 3|4\#第 {0,number}} 个实参
fix.expression.role.qualifier=限定符
fix.javadoc.family=修正 Javadoc
fix.modifiers.family=修正修饰符
fix.parameter.type.family=修正形参类型
fix.parameter.type.text=使 ''{0}'' 在此处获取类型为 ''{1}'' 的形参
fix.receiver.parameter.name.family=修复接收器形参的名称
fix.receiver.parameter.type.family=修正接收器形参类型
fix.receiver.parameter.type.text=更改为封闭类类型
fix.return.type.family=修正返回值类型
fix.return.type.or.predecessor.text=使 ''{0}'' 返回 ''{1}'' 或上级
fix.return.type.text=使 ''{0}'' 返回 ''{1}''
fix.single.character.string.to.char.literal.family=修正字面量类型
fix.single.character.string.to.char.literal.text=将 {0} 更改为 {1}({2} 字面量)
fix.super.method.return.type.family=修复 Super 方法返回值类型
fix.super.method.return.type.text=使 ''{0}'' 返回 ''{1}''
fix.throws.list.add.exception=将 ''{0}'' 添加到 ''{1}'' throws 列表
fix.throws.list.family=修正 throws 列表
fix.throws.list.remove.exception=从 ''{1}'' throws 列表移除 ''{0}''
fix.unused.symbol.injection.family=添加到依赖项注入注解
fix.unused.symbol.injection.text=如果用 ''{0}'' 注解，则禁止未使用的警告
fix.update.modifier.change.inheritors=更改此方法和继承者
fix.update.modifier.change.this=只更改此方法
fix.variable.type.family=修正变量类型
fix.variable.type.text=将{0} ''{1}'' 的类型更改为 ''{2}''
generate.overloaded.method.or.constructor.with.default.parameter.values=使用默认形参值生成重载{0}
generate.overloaded.method.with.default.parameter.values=使用默认形参值生成重载方法
implement.methods.fix=实现方法
implement.or.extend.fix.family=实现/扩展所需的基类
import.class.fix=导入类
initialize.final.field.in.constructor.choose.dialog.title=选择要向其添加初始化的构造函数
initialize.final.field.in.constructor.name=在构造函数中初始化
insert.empty.parenthesis=插入 '()'
insert.new.fix=插入 new
insert.sam.method.call.fix.family.name=插入单一 abstract 方法调用
insert.sam.method.call.fix.name=插入 ''.{0}'' 以调用函数式接口方法
insert.super.constructor.call.family=插入基类构造函数调用
intention.move.parenthesis.name=修复右括号位置
iterate.iterable=迭代
java.8.collection.removeif.inspection.description=此循环可被替换为 'Collection.removeIf'
java.8.collection.removeif.inspection.fix.name=将此循环替换为 'Collection.removeIf'
java.8.list.replaceall.inspection.description=循环可被替换为 'List.replaceAll'
java.8.list.replaceall.inspection.fix.name=将循环替换为 'List.replaceAll'
java.8.list.sort.inspection.description=Collections.sort 可被替换为 List.sort
java.8.list.sort.inspection.fix.name=替换为 List.sort
java.8.map.api.inspection.description=可被替换为单个 ''Map.{0}'' 方法调用
java.8.map.api.inspection.fix.family.name=替换为单个 Map 方法调用
java.8.map.api.inspection.fix.text=替换为 ''{0}'' 方法调用
java.9.merge.module.statements.fix.family.name=与其他 ''{0}'' 指令合并
java.9.merge.module.statements.fix.name=与其他 ''{0} {1}'' 指令合并
lift.throw.out.of.switch.expression.fix.name=从 'switch' 表达式中提取 'throw'
make.annotation.applicable.to.0.fix=使注解适用于 {0}
make.class.an.interface.family=使类成为接口
make.class.an.interface.text=将 ''{0}'' 设为接口
make.final.family=设为 final
make.interface.an.class.text=使 ''{0}'' 设为类
make.receiver.parameter.first.family=将接收器形参作为第一项
make.receiver.parameter.first.text=将 'this' 移到列表开头
make.vararg.parameter.last.family=将 vararg 形参设置为最后应形参
make.vararg.parameter.last.text=将 ''{0}'' 移至列表的末尾
merge.duplicate.attributes.family=合并重复特性
method.to.import.chooser.title=要导入的方法
module.info.add.directive.family.name=将指令添加到 module-info.java
module.info.add.exports.name=将 ''exports {0}'' 指令添加到 module-info.java
module.info.add.opens.name=将 ''opens {0}'' 指令添加到 module-info.java
module.info.add.requires.name=将 ''requires {0}'' 指令添加到 module-info.java
module.info.add.uses.name=将 ''uses {0}'' 指令添加到 module-info.java
move.0.from.module.1.to.2=将 ''{0}'' 从模块 ''{1}'' 移至 ''{2}''
move.0.in.1=移动 ''{1}'' 中的 ''{0}''…
move.bound.class.to.front.fix.text=将界限 ''{0}'' 移至类型形参 ''{1}'' 的界限列表的开头
move.catch.up.family=上移 'catch'
move.catch.up.text=将 ''{0}'' 的 catch 移至 ''{1}'' 之前
move.class.0.to.package.text=将{0} ''{1}'' 移至软件包 ''{2}''
move.class.in.extend.list.family=在扩展列表中移动类
move.class.to.package.family=移至软件包
move.class.to.package.text=移至软件包 ''{0}''
move.class.to.separate.file.family=将类移至单独的文件
move.class.to.separate.file.text=将类 ''{0}'' 移至 ''{0}.java''
move.file.to.source.root.text=将文件移至源根
move.switch.branch.up.family=将 switch 分支上移
move.switch.branch.up.text=将 switch 分支 ''{0}'' 移至 ''{1}'' 之前
navigate.duplicate.element.text=导航到重复的 {0}
navigate.variable.declaration.family=导航到变量声明
navigate.variable.declaration.text=导航到上一个变量声明 ''{0}''
negation.broader.scope.family=否定更宽的范围
negation.broader.scope.text=更改为 ''\!({0})''
new.method.body.template.error.text=请更正“新方法体”模板
new.method.body.template.error.title=文件模板错误
optimize.imports.fix=优化 import
orderEntry.fix.add.dependency.on.module=添加对模块 ''{0}'' 的依赖
orderEntry.fix.add.dependency.on.module.choose=添加对模块的依赖…
orderEntry.fix.add.library.to.classpath=将库 ''{0}'' 添加到类路径
orderEntry.fix.choose.module.to.add.dependency.on=选择要依赖的模块
orderEntry.fix.circular.dependency.warning=添加对模块 ''{0}'' 的依赖将在模块 ''{1}'' 和 ''{2}'' 之间引入循环依赖关系。\n添加依赖关系?
orderEntry.fix.family.add.library.to.classpath=将库添加到类路径
orderEntry.fix.family.add.library.to.classpath.options=将库添加到类路径…
orderEntry.fix.family.add.module.dependency=添加模块依赖项
orderEntry.fix.title.circular.dependency.warning=循环依赖关系警告
permute.arguments=重新排列实参
popup.title.choose.library.to.add.dependency.on=选择要依赖的库
qualify.method.call.family=限定方法调用
qualify.method.call.fix=使用 ''{0}'' 限定调用
record.delegate.to.canonical.constructor.fix.name=委托给规范构造函数
remove.annotation.fix.family=移除注解
remove.annotation.fix.text=移除 ''@{0}'' 注解
remove.class.from.extends.list=使 ''{0}'' 不扩展 ''{1}''
remove.interface.from.implements.list=使 ''{0}'' 不实现 ''{1}''
remove.modifier.fix=将 ''{0}'' 设为非{1}
remove.modifier.fix.family=设为非 {0}
remove.one.modifier.fix=移除 ''{0}'' 修饰符
remove.override.fix.family=移除重写
remove.override.fix.text=从方法声明中移除重写注解
remove.parameter.from.usage.text=从{2} ''{3}'' 中移除第 {0,number,ordinal} 个{1}
remove.parameter.list=移除形参列表
remove.qualifier.action.text=移除限定符
remove.qualifier.fix=移除限定符
remove.redundant.arguments.family=移除冗余实参
remove.redundant.arguments.text=移除冗余的{1, choice, 1\#实参|1<实参}以调用 ''{0}''
remove.redundant.nested.patterns.fix.text=移除冗余的嵌套模式{0, choice, 1\#|2\#}
remove.redundant.str.processor=移除冗余的 'STR' 处理器
remove.suppression.action.family=移除禁止
remove.suppression.action.name=移除 ''{0}'' 禁止
remove.unreachable.branches=移除不可到达的分支
remove.unused.element.family=移除未使用的{0}
rename.wrong.reference.family=重命名错误引用
rename.wrong.reference.text=重命名引用
replace.for.each.loop.with.iterator.for.loop=将 'for each' 循环替换为迭代器 'for' 循环
replace.import.module.fix.text=将 'import module' 替换为单类 import
replace.type.new.expression.family.name=替换构造函数调用类型
replace.type.new.expression.name=将构造函数调用类型替换为 ''{0}''
replace.type.variable.name=将变量类型替换为 ''{0}''
replace.with.getter=替换为 getter
replace.with.getter.setter=替换为 getter/setter
replace.with.list.access.text=替换为列表访问
replace.with.qualifier.text=替换为限定符
replace.with.qualifier.text.role=将 {0} 替换为限定符
replace.with.setter=替换为 setter
replace.with.type.pattern.fix=替换为类型模式
reuse.variable.declaration.family=重用上一个变量
reuse.variable.declaration.text=重用上一个变量 ''{0}''
safe.delete.family=安全删除
safe.delete.text=安全删除 ''{0}''
seal.class.from.permits.list.fix=密封继承者
searching.for.usages.progress.title=正在搜索用法…
setup.jdk.location.family=设置 JDK 位置
setup.jdk.location.text=设置 JDK
show.duplicate.elements.family=显示重复项
show.duplicate.elements.navigate.family=导航到重复项
show.duplicate.elements.navigate.text=行 \#{0}
show.duplicate.elements.popup.title=选择重复项
show.duplicate.elements.text=显示 ''{0}'' 重复项
side.effect.action.cancel=取消(&C)
side.effect.action.remove=移除(&R)
side.effect.action.transform=转换(&T)
side.effects.warning.dialog.title=发现副作用
simplify.boolean.expression.extracting.side.effects=(提取副作用)
simplify.boolean.expression.family=简化布尔表达式
simplify.boolean.expression.text=将 ''{0}'' 简化为 {1}
static.import.constant.kind.text=static 常量
static.import.constant.text=导入 static 常量
static.import.method.choose.method.to.import=选择导入的方法
static.import.method.kind.text=static 方法
static.import.method.text=导入 static 方法
super.class.constructors.chooser.title=选择超类构造函数
surround.annotation.parameter.value.with.quotes=使用引号包围注解形参值
surround.with.array.initialization=使用数组初始化包围
surround.with.try.catch.fix=使用 try/catch 包围
target.class.chooser.title=选择目标类
target.method.chooser.title=选择目标方法
uidesigner.change.bound.field.type=更改绑定的字段类型
uidesigner.change.gui.component.type=更改 GUI 组件类型
unwrap.array.initializer.fix=将数组初始值设定项替换为其元素
wrap.expression.using.static.accessor.family=包装表达式
wrap.expression.using.static.accessor.text=使用 ''{0}()'' 包装
wrap.expression.using.static.accessor.text.role=使用 ''{0}()'' 封装 {1}
wrap.with.adapter.call.family.name=使用调用或新对象适应
wrap.with.adapter.parameter.multiple.text=使用 ''{1}'' 适应{0, choice, 1\#第 1 个|2\#第 2 个|3\#第 3 个|4\#第 {0,number} 个}实参
wrap.with.adapter.parameter.single.text=使用 ''{0}'' 适应实参
wrap.with.adapter.text=使用 ''{0}'' 适应
wrap.with.adapter.text.role=使用 ''{0}'' 适应 {1}
wrap.with.block=使用块包装
wrap.with.optional.parameter.text=使用 ''java.util.Optional'' 包装第 {0, choice, 1\#1|2\#2|3\#3|4\#{0,number}} 个实参
wrap.with.optional.single.parameter.text=使用 'java.util.Optional' 包装

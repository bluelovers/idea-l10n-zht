add.import=添加导入
class.to.import.chooser.title=要导入的类
method.to.import.chooser.title=要导入的方法
field.to.import.chooser.title=要导入的字段
access.static.via.class.reference.family=通过类引用访问 static
access.static.via.class.reference.text=通过类 ''{2}'' 引用访问 static ''{1}.{0}''
add.default.constructor.family=添加默认构造函数
add.default.constructor.text=将 {0} 无实参构造函数添加到 {1}
add.catch.clause.family=将异常添加到 catch 子句
add.catch.clause.text=添加 'catch' 子句
add.finally.block.family=添加 'finally' 块
add.exception.to.throws.inherited.method.warning.text=方法 ''{0}'' 被继承。\n\
您是否希望在整个方法层次结构中向方法签名添加异常?
method.is.inherited.warning.title=方法被继承
add.exception.to.throws.text=添加{0, choice, 0#异常|2#异常}到方法签名
add.exception.to.throws.family=向方法签名添加异常
add.exception.to.existing.catch.family=向现有 Catch 子句添加异常
add.exception.to.existing.catch.generic=向现有 Catch 子句添加异常
add.exception.to.existing.catch.replacement=用更通用的 ''{1}'' 替换 ''{0}''
add.exception.to.existing.catch.no.replacement=将 ''{1}'' 添加到具有 ''{0}'' 的 catch
add.exception.to.existing.catch.chooser.title=选择 Catch 块

add.method.body.text=添加方法体
add.method.family=添加方法
add.method.text=将方法 ''{0}'' 添加到类 ''{1}''
add.new.array.family=添加缺少的新表达式
add.new.array.text=添加 ''new {0}[]''
add.return.statement.text=添加 'return' 语句
add.runtime.exception.to.throws.text=向方法签名添加运行时异常
add.runtime.exception.to.throws.family=向方法签名添加运行时异常
add.typecast.family=添加类型转换
add.typecast.text=转换到 ''{0}''
add.qualifier.typecast.text=将限定符转换为 ''{0}''
add.docTag.to.custom.tags=将 {0} 添加到自定义标签
fix.javadoc.family=修正 Javadoc
adjust.package.family=调整软件包名称
adjust.package.text=将软件包名称设置为 ''{0}''
bring.variable.to.scope.family=将变量引入范围
bring.variable.to.scope.text=将 ''{0}'' 引入范围

cast.parameter.text=将{0, choice, 1#第 1 个|2#第 2 个|3#第 3 个|4#第 {0,number} 个}实参转换为 ''{1}''
cast.single.parameter.text=将实参转换为 ''{0}''

add.type.arguments.text=添加显式类型实参到第{0, choice, 1#1|2#2|3#3|4#{0,number}}个实参
add.type.arguments.single.argument.text=添加显式类型实参

change.class.signature.text=更改 ''{0}'' 的签名以匹配 ''{1}''
change.class.signature.family=更改类签名

uidesigner.change.bound.field.type=更改绑定的字段类型
cannot.change.field.exception=无法更改字段 ''{0}'' 类型。\n\
原因: {1}

# {0} - original keyword (extends or implements), {1} - proposed keyword (implements or extends), {2} - class name
exchange.extends.implements.keyword=将 ''{0} {2}'' 更改为 ''{1} {2}''
uidesigner.change.gui.component.type=更改 GUI 组件类型
change.method.signature.from.usage.family=从用法更改方法签名

# {0} - original method signature including name, {1} - method name, {2} - proposed new parameters list
change.method.signature.from.usage.text=将 ''{0}'' 的签名更改为 ''{1}({2})''
add.parameter.from.usage.text=将 ''{0}'' 作为第 {1,number,ordinal} 个{2}添加到{3} ''{4}'' 中
remove.parameter.from.usage.text=从{2} ''{3}'' 中移除第 {0,number,ordinal} 个{1}
change.parameter.from.usage.text=将{2} ''{3}'' 的第 {0,number,ordinal} 个{1}从 ''{4}'' 更改为 ''{5}''
searching.for.usages.progress.title=正在搜索用法…
create.class.from.new.family=从新的运算符创建类
create.class.from.usage.family=从用法创建类
# suppress inspection "UnusedProperty"
create.class.from.usage.text=创建{0} ''{1}''
create.inner.class.from.usage.text=创建内部{0} ''{1}''
create.element.in.class=在 ''{2}'' 中创建{0} ''{1}''
# suppress inspection "UnusedProperty"
create.constant.from.usage.family=从用法创建常量
# suppress inspection "UnusedProperty"
create.constructor.from.new.family=从新的运算符创建构造函数
create.constructor.from.new.text=创建构造函数
# suppress inspection "UnusedProperty"
create.constructor.from.super.call.family=从 super() 调用创建构造函数
# suppress inspection "UnusedProperty"
create.constructor.from.this.call.family=从 this() 调用创建构造函数
create.constructor.family=创建构造函数
create.constructor.text=在 ''{0}'' 中创建构造函数
create.constructor.matching.super=创建匹配 super 的构造函数
super.class.constructors.chooser.title=选择超类构造函数
create.field.from.usage.family=从用法创建字段
target.class.chooser.title=选择目标类
new.method.body.template.error.text=请更正“新方法体”模板
new.method.body.template.error.title=文件模板错误
cannot.create.java.file.error.text=无法在{1}中创建 {0}.java: {2}
cannot.create.java.file.error.title=文件创建失败
cannot.create.java.package.error.text=无法在{1}中创建 {0}: {2}
cannot.create.java.package.error.title=软件包创建失败
create.accessor.for.unused.field.family=创建未使用字段的访问器
create.getter.for.field=为 ''{0}'' 创建 getter
create.setter.for.field=为 ''{0}'' 创建 setter
create.getter.and.setter.for.field=为 ''{0}'' 创建 getter 和 setter
create.local.from.usage.family=从用法创建本地
create.local.from.instanceof.usage.family=从 instanceof 用法创建局部变量
create.local.from.instanceof.usage.text=插入 ''({0}){1}'' 声明
create.member.from.usage.family=从用法创建成员
create.method.from.usage.family=从用法创建方法
create.method.from.usage.text=创建方法 ''{0}''
create.type.parameter.from.usage.family=从用法创建类型形参
create.type.parameter.from.usage.text=创建类型形参 ''{0}''
create.type.parameter.from.usage.chooser.title=用于添加类型形参的位置
create.parameter.from.usage.family=从用法创建形参
create.property.from.usage.family=从用法创建属性
create.property.from.usage.text=创建属性 ''{0}''
create.property.from.usage.full.text=在 ''{1}'' 中创建属性 ''{0}''
create.read.only.property.from.usage.text=创建只读属性 ''{0}''
create.read.only.property.from.usage.full.text=在 ''{1}'' 中创建只读属性 ''{0}''
create.write.only.property.from.usage.text=创建只写属性 ''{0}''
create.write.only.property.from.usage.full.text=在 ''{1}'' 中创建只写属性 ''{0}''
# suppress inspection "UnusedProperty"
create.getter=创建 Getter
# suppress inspection "UnusedProperty"
create.setter=创建 Setter
create.annotation.family=将注解添加到声明
create.annotation.text=注解为 @{0}
defer.final.assignment.with.temp.family=使用临时变量推迟最终赋值
defer.final.assignment.with.temp.text=使用临时变量推迟 ''{0}'' 赋值
delete.catch.family=删除 catch
delete.catch.text=删除 ''{0}'' 的 catch
delete.body.text=删除方法体
enable.optimize.imports.on.the.fly=启用 '设置 | 编辑器 | 常规 | 自动导入 | 动态优化 import'
generify.family=泛化文件
generify.text=尝试泛化 ''{0}''
implement.methods.fix=实现方法
import.class.fix=导入类
insert.new.fix=插入 new
insert.super.constructor.call.family=插入基类构造函数调用
insert.super.constructor.call.text=插入 ''{0}''
make.class.an.interface.family=使类成为接口
make.class.an.interface.text=将 ''{0}'' 设为接口
make.interface.an.class.text=使 ''{0}'' 设为类
make.vararg.parameter.last.family=将 vararg 形参设置为最后应形参
make.vararg.parameter.last.text=将 ''{0}'' 移至列表的末尾
make.receiver.parameter.first.family=将接收器形参作为第一项
make.receiver.parameter.first.text=将 'this' 移到列表开头
fix.parameter.type.family=修正形参类型
fix.parameter.type.text=使 ''{0}'' 在此处获取类型为 ''{1}'' 的形参
fix.return.type.family=修正返回类型
fix.return.type.or.predecessor.text=使 ''{0}'' 返回 ''{1}'' 或前置符
fix.return.type.text=使 ''{0}'' 返回 ''{1}''
fix.throws.list.family=修正 throws 列表
fix.throws.list.add.exception=将 ''{0}'' 添加到 ''{1}'' throws 列表
fix.throws.list.remove.exception=从 ''{1}'' throws 列表移除 ''{0}''
fix.modifiers.family=修正修饰符

anonymous.class.presentation=派生自 {0} 的匿名类
# {0} owner class name
class.initializer.presentation={0} 类初始值设定项
add.modifier.fix=将 ''{0}'' 设为{1}
remove.modifier.fix=将 ''{0}'' 设为非{1}
add.modifier.fix.family=设为 {0}
remove.modifier.fix.family=设为非 {0}

change.inheritors.visibility.warning.text=是否将继承者的可见性更改为基方法的可见性?
change.inheritors.visibility.warning.title=更改继承者
move.class.in.extend.list.family=在扩展列表中移动类
move.bound.class.to.front.fix.text=将界限 ''{0}'' 移至类型形参 ''{1}'' 的界限列表的开头
move.catch.up.family=上移 Catch
move.catch.up.text=将 ''{0}'' 的 catch 移动到 ''{1}'' 之前
move.class.to.separate.file.family=将类移至单独的文件
move.class.to.separate.file.text=将类 ''{0}'' 移至 ''{0}.java''
move.class.to.package.family=将类移至软件包
move.class.to.package.text=移至软件包 ''{0}''

# change if (!a == b) ...  =>  if (!(a == b)) ...
negation.broader.scope.family=否定更宽的范围
negation.broader.scope.text=更改为 ''!({0})''

optimize.imports.fix=优化 import
remove.qualifier.fix=移除限定符
remove.unused.element.family=移除未使用的{0}
rename.wrong.reference.family=重命名错误引用
rename.wrong.reference.text=重命名引用
reuse.variable.declaration.family=重用变量声明
reuse.variable.declaration.text=重用上一个变量 ''{0}'' 声明
navigate.variable.declaration.family=导航到变量声明
navigate.variable.declaration.text=导航到上一个变量声明 ''{0}''
navigate.duplicate.element.text=导航到重复的 {0}
safe.delete.family=安全删除
safe.delete.text=安全删除 ''{0}''
setup.jdk.location.family=设置 JDK 位置
setup.jdk.location.text=设置 JDK
side.effects.warning.dialog.title=发现副作用
simplify.boolean.expression.family=简化布尔表达式
simplify.boolean.expression.text=将 ''{0}'' 简化为 {1}
fix.super.method.return.type.family=修复 Super 方法返回类型
fix.super.method.return.type.text=使 ''{0}'' 返回 ''{1}''
surround.with.try.catch.fix=使用 try/catch 环绕
make.final.family=设为 final
# suppress inspection "UnusedProperty"
make.final.copy.to.temp=将 ''{0}'' 复制到 {1} 临时变量
fix.variable.type.family=修正变量类型
fix.variable.type.text=将{0} 的类型由''{1}''更改为 ''{2}''
fix.receiver.parameter.type.family=修正接收器形参类型
fix.receiver.parameter.type.text=更改为封闭类类型

# Sample: Boolean b = "true"; -> Boolean b = Boolean.valueOf("true");
wrap.expression.using.static.accessor.family=包装表达式
wrap.expression.using.static.accessor.text=使用 ''{0}()'' 包装

# {0} - qualified class name suggested to be imported.
side.effect.action.remove=移除(&R)
side.effect.action.transform=转换(&T)
side.effect.action.cancel=取消(&C)
side.effect.message1=<html><body>分配给变量 ''{0}'' 的表达式中可能存在副作用<br>您可以: <ul><li><b>移除</b>涉及的变量用法以及所有表达式</li></body></html>
# {0} - variable name, {1} - variable type, {2} - expression with side effect, {3} - same expression transformed to hold the effect

change.parameter.class.family=更改形参类

change.extends.list.family=扩展类自
add.class.to.extends.list=使 ''{0}'' 扩展 ''{1}''
remove.class.from.extends.list=使 ''{0}'' 不扩展 ''{1}''
add.interface.to.implements.list=使 ''{0}'' 实现 ''{1}''
remove.interface.from.implements.list=使 ''{0}'' 不实现 ''{1}''
convert.method.to.constructor=使方法成为构造函数

create.field.text=创建字段 {0}
create.property.text=创建属性 {0}
add.constructor.parameter.name=添加构造函数形参
remove.suppression.action.name=移除 ''{0}'' 禁止
remove.suppression.action.family=移除禁止
remove.qualifier.action.text=移除限定符
fix.argument.family=修正实参
change.new.operator.type.text=将 ''{0}'' 更改为 ''new {1}{2}''
change.new.operator.type.family=更改新运算符类型

fix.unused.symbol.injection.family=添加到依赖项注入注解
fix.unused.symbol.injection.text=如果用 ''{0}'' 注解，则禁止未使用的警告
fix.add.special.annotation.family=添加到特殊注解
fix.add.special.annotation.text=将 ''{0}'' 添加到特殊注解列表

orderEntry.fix.add.dependency.on.module=添加对模块 ''{0}'' 的依赖
orderEntry.fix.add.dependency.on.module.choose=添加对模块的依赖…
orderEntry.fix.choose.module.to.add.dependency.on=选择要依赖的模块
orderEntry.fix.family.add.module.dependency=添加模块依赖项
orderEntry.fix.add.library.to.classpath=将库 ''{0}'' 添加到类路径
orderEntry.fix.family.add.library.to.classpath=将库添加到类路径
orderEntry.fix.circular.dependency.warning=添加对模块 ''{0}'' 的依赖将在模块 ''{1}'' 和 ''{2}'' 之间引入循环依赖关系。\n\
添加依赖关系?
orderEntry.fix.title.circular.dependency.warning=循环依赖关系警告
static.import.method.text=导入 static 方法
static.import.method.choose.method.to.import=选择导入的方法
static.import.constant.text=导入 static 常量

add.library.title.dialog=将 ''{0}'' 库添加到项目
add.library.title.choose.folder=选择目录
add.library.description.choose.folder=选择要复制的库所在的目录
add.library.error.not.found=库文件 ''{0}'' 不存在
add.library.error.cannot.copy=无法将 ''{0}'' 复制到 ''{1}''\n\
({2})
add.library.use.bundled.library.radio.button=使用{1}分发中的''{0}'' (&U)
add.library.copy.files.to.radio.button=将''{0}''库文件复制到 (&C)

permute.arguments=重新排列实参
fix.single.character.string.to.char.literal.text=将 {0} 更改为 {1}({2} 文字)
fix.single.character.string.to.char.literal.family=修正文字类型

change.to.append.family=修正 StringBuilder 追加
change.to.append.text=更改为 ''{0}''

convert.to.string.family=修正字符文字
convert.to.string.text=转换为字符串文字

initialize.final.field.in.constructor.name=在构造函数中初始化
initialize.final.field.in.constructor.choose.dialog.title=选择要添加初始化的构造函数

remove.redundant.arguments.text=移除冗余实参以调用 ''{0}''
remove.redundant.arguments.family=移除冗余参数

replace.with.list.access.text=替换为列表访问

add.qualifier=添加限定符
add.qualifier.original.class.chooser.title=原始类

annotations.fix=注解
add.missing.annotation.parameters.fix=添加缺少的注解形参 - {0}
add.missing.annotation.single.parameter.fix=添加缺少的注解形参 ''{0}''

add.method.qualifier.fix.text=将限定符 ''{0}'' 添加到方法
add.method.qualifier.fix.family=添加方法限定符

collection.addall.can.be.replaced.with.constructor.fix.options.column.title=已检查类
collection.addall.can.be.replaced.with.constructor.fix.options.dialog.title=添加要检查的类
collection.addall.can.be.replaced.with.constructor.fix.options.label=要检查的类:
collection.addall.can.be.replaced.with.constructor.fix.description='#ref()' 方法可被替换为形参化构造函数调用
collection.addall.can.be.replaced.with.constructor.fix.family.name=将 'addAll()/putAll()' 调用替换为形参化构造函数调用
collection.addall.can.be.replaced.with.constructor.fix.name=将 ''{0}()'' 调用替换为形参化构造函数调用

add.exception.from.field.initializer.to.constructor.throws.text=添加类{0, choice, 0#默认构造函数|1#构造函数|2#构造函数}签名的异常
add.exception.from.field.initializer.to.constructor.throws.family.text=向类构造函数签名添加异常
java.8.map.api.inspection.fix.text=替换为 ''{0}'' 方法调用
java.8.map.api.inspection.description=可被替换为单个 ''Map.{0}'' 方法调用
java.8.map.api.inspection.fix.family.name=替换为单个 Map 方法调用
java.8.collection.removeif.inspection.description=此循环可被替换为 'Collection.removeIf'
java.8.collection.removeif.inspection.fix.name=将此循环替换为 'Collection.removeIf'
java.8.list.sort.inspection.description=Collections.sort 可被替换为 List.sort
java.8.list.sort.inspection.fix.name=替换为 List.sort

wrap.with.optional.parameter.text=使用 ''java.util.Optional'' 包装第 {0, choice, 1#1|2#2|3#3|4#{0,number}} 个实参
wrap.with.optional.single.parameter.text=使用 'java.util.Optional' 包装

move.file.to.source.root.text=将文件移至源根
delete.return.fix.family=删除 return
delete.return.fix.text=删除 return {0}
delete.return.fix.side.effects.text=删除 return {0} 并提取副作用

delete.reference.fix.text=删除引用
delete.unreachable.statement.fix.text=删除不可到达的语句

extract.side.effects.convert.to.if=作为 'if' 语句提取副作用
extract.side.effects=提取副{0, choice, 1#作用|2#作用}
extract.side.effects.family.name=删除提取副作用的语句

module.info.add.directive.family.name=将指令添加到 module-info.java
module.info.add.requires.name=将 ''requires {0}'' 指令添加到 module-info.java
module.info.add.exports.name=将 ''exports {0}'' 指令添加到 module-info.java
module.info.add.uses.name=将 ''uses {0}'' 指令添加到 module-info.java

collection.to.array.text=应用转换 ''.toArray({0})''
collection.to.array.family.name=应用转换 '.toArray()'

insert.sam.method.call.fix.name=插入 ''.{0}'' 以调用函数接口方法
insert.sam.method.call.fix.family.name=插入单一 abstract 方法调用

wrap.with.adapter.call.family.name=使用调用或新对象适应
wrap.with.adapter.text=使用 ''{0}'' 适应
wrap.with.adapter.parameter.single.text=使用 ''{0}'' 适应实参
wrap.with.adapter.parameter.multiple.text=使用 ''{1}'' 适应 {0, choice, 1#第 1 个|2#第 2 个|3#第 3 个|4#第 {0,number} 个} 实参

java.9.merge.module.statements.fix.family.name=与其他 ''{0}'' 指令合并
java.9.merge.module.statements.fix.name=与其他 ''{0} {1}'' 指令合并


adjust.method.accepting.functional.expression.fix.family.name=调整接受函数表达式的方法
adjust.method.accepting.functional.expression.fix.text=将 ''{0}()'' 替换为 ''{1}()''

add.compiler.option.fix.name=将 ''{0}'' 添加到模块编译器选项

create.service.implementation.fix.family.name=创建服务实现类
create.service.implementation.fix.name=创建类 ''{0}''

create.service.interface.fix.family.name=创建服务
create.service.interface.fix.name=创建服务 ''{0}''

convert.variable.to.field.in.anonymous.class.fix.name=将 ''{0}'' 移动到匿名对象
change.method.parameters.text=将方法参数更改为 ''{0}''
change.method.parameters.family=更改方法参数

add.default.branch.to.variable.initializing.switch.fix.name=将 ''default'' 分支添加到初始化 ''{0}'' 的 ''switch'' 语句中

insert.empty.parenthesis=插入 '()'
remove.parameter.list=移除形参列表

convert.primitive.to.boxed.type=将基元类型转换为装箱类型

choose.class.to.move.popup.title=选择要移动的类
move.0.in.1=移动 ''{1}'' 中的 ''{0}''…
move.0.from.module.1.to.2=将 ''{0}'' 从模块 ''{1}'' 移动到 ''{2}''

add.0.to.classpath=将 ''{0}'' 添加到类路径中

iterate.iterable=迭代

choose.fields.to.generate.constructor.parameters.for=选择要为其生成构造函数形参的字段
choose.constructors.to.add.parameter.to=选择要向其添加形参的构造函数
add.constructor.parameters=添加构造函数形参

add.annotation.attribute.name.family.name=添加注解特性名称
add.annotation.attribute.name=添加 ''{0}=''

replace.with.getter.setter=替换为 getter/setter
replace.with.getter=替换为 getter
replace.with.setter=替换为 setter

wrap.with.block=使用块包装
create.block=创建块

replace.for.each.loop.with.iterator.for.loop=将 'for each' 循环替换为迭代器 'for' 循环

surround.annotation.parameter.value.with.quotes=使用引号环绕注解形参值
surround.with.array.initialization=通过数组初始化环绕

create.service.implementation=创建服务实现
create.service=创建服务

choose.default.value.parameters.popup.title=选择默认值参数
generate.overloaded.method.or.constructor.with.default.parameter.values=使用默认形参值生成重载{0}
generate.overloaded.method.with.default.parameter.values=使用默认形参值生成重载方法

remove.unreachable.branches=移除不可到达的分支
set.inspection.option.fix=设置检查选项
simplify.boolean.expression.extracting.side.effects=(提取副作用)
intention.move.parenthesis.name=修复右括号位置

extend.sealed.title=扩展密封类并标记为
implement.sealed.title=实现密封接口并标记为

implement.or.extend.fix.family=实现/扩展所需的基类
implement.or.extend.fix.implement.text=实现 ''{0}''
implement.or.extend.fix.extend.text=扩展 ''{0}''

seal.class.from.permits.list.fix=密封继承者

unwrap.array.initializer.fix=将数组初始值设定项替换为其元素
orderEntry.fix.family.add.library.to.classpath.options=将库添加到类路径…
popup.title.choose.library.to.add.dependency.on=选择要依赖的库
replace.with.type.pattern.fix=替换为类型模式
merge.duplicate.attributes.family=合并重复特性
move.switch.branch.up.family=将 switch 分支上移
move.switch.branch.up.text=将 switch 分支 ''{0}'' 移动到 ''{1}'' 之前
change.type.family=更改类型
change.type.text=将类型更改为 ''{0}''
make.annotation.applicable.to.0.fix=使注解适用于 {0}
set.inspection.option.description.uncheck=取消选中检查选项:
set.inspection.option.description.check=选中检查选项:
java.8.list.replaceall.inspection.description=循环可以替换为 'List.replaceAll'
java.8.list.replaceall.inspection.fix.name=将循环替换为 'List.replaceAll'
fix.receiver.parameter.name.family=修复接收器形参的名称
qualify.method.call.fix=使用 ''{0}'' 限定调用
qualify.method.call.family=限定方法调用
0.already.contains.a.1={0}已包含{1}
0.already.exists.in.the.target.class={0} 已经存在于目标类中。
0.has.1.usages.that.are.not.safe.to.delete={0} 有 {1,choice,1\#1 个用法|2\#{1,number} 个用法}不能安全删除。
0.has.detected.1.code.fragments.in.this.file.that.can.be.replaced.with.a.call.to.extracted.method={0} 检测到此文件中有 {1} 个代码{1,choice,1\#段|2\#段}可被替换为提取方法调用。要检查并替换{1,choice,1\#它|2\#它们}吗?
0.is.already.defined.in.1={0} 已在 {1} 中定义
0.is.already.overridden.in.1={0}在{1}中已被重写。不会将方法向下推送至该类。
0.is.located.in.a.jar.file={0} 位于只读容器中。
0.is.not.a.legal.fq.name=''{0}'' 不是合法的完全限定名称
0.is.not.an.identifier=<b><code>{0}</code></b> 不是一个要在 <b><code>{1}</code></b> 中使用的正确标识符
0.is.read.only={0} 为只读条目。
0.refactoring.cannot.be.applied.to.constructors={0}重构无法应用于构造函数
0.referenced.in.1.will.not.be.accessible.from.module.2={0}，在{1}中引用，将无法从模块 {2} 访问
0.referenced.in.1.will.not.be.accessible.from.production.of.module.2={0}，在{1}中引用，将无法从模块 {2} 的生产源中访问
0.referenced.in.1.will.not.be.accessible.in.module.2={0}，在{1}中引用，将无法在模块 {2} 中访问
0.that.is.used.in.inlined.method.is.not.accessible.from.call.site.s.in.1=内联方法中使用的{0}无法从{1}中的调用点访问
0.to.be.renamed.to.1.2={0}将被重命名为{1} {2}
0.to.change.signature={0}以更改签名
0.uses.1.which.is.not.accessible.from.the.superclass={0}使用{1}，后者无法从超类访问
0.uses.1.which.is.not.moved.to.the.superclass={0}使用{1}，后者无法移至超类
0.uses.1.which.is.pushed.down={0}使用{1}，后者已被向下推送
0.which.is.used.in.1.not.accessible.from.call.site.s.in.2=当 {1} 内联到 {2} 中时，{0} 将无法访问
0.with.1.visibility.is.not.accessible.from.2=可见性为 {1} 的 {0} 将无法从 {2} 访问
ExtractSuperClass.superclass=超类
action.next.conflict=下一个冲突
action.open.in.find.window=在“查找”窗口中打开(&F)
action.previous.conflict=上一个冲突
action.show.conflicts.in.view.text=在视图中显示冲突
add.object.as.a.parameter.with.name=将对象作为具有以下名称的形参添加(&O)\:
advanced.setting.promote.suggested.refactoring.in.editor=在编辑器中显示建议的重构的提示
all.invocations.and.remove.the.method=内联所有调用并移除方法(&A)
all.invocations.in.project=项目中的所有调用(&A)
all.references.and.remove.the.local=内联所有引用并移除变量(&A)
also.generated=同时生成\:
ask.to.delete.related.file=<html>找到相关文件\: <code>{0}</code>。<br/>是否同时删除它?</html>
ask.to.delete.related.files=<html>找到相关文件\: <br/><code>{0}</code><br/><br/>是否同时删除它们?</html>
ask.to.move.related.file=<html>找到相关文件\: <code>{0}</code>。<br/>是否同时移动它?</html>
ask.to.move.related.files=<html>找到相关文件\: <br/><code>{0}</code><br/><br/>是否同时移动它们?</html>
attempting.to.delete.targets.node.text=试图删除
automatic.renamer.entity.name.column={0} 名称
automatic.renamer.rename.to.column=重命名为
automatic.renaming.dialog.identifier.invalid.error=标识符 ''{0}'' 无效
automatic.renaming.dialog.new.name.label=新名称
automatic.renaming.dialog.rename.selected.title=重命名选中项
border.title.introduce.parameter.class=形参类
border.title.introduce.parameters.to.extract=要提取的形参
caller.chooser.callee.method=被调用方方法
caller.chooser.caller.method=调用方方法
caller.chooser.looking.for.callers=正在查找调用方…
cancel.button=取消(&N)
cannot.create.directory=无法创建目录
cannot.extract.selected.elements.into.include.file=无法将所选元素提取到 include 文件中
cannot.make.abstract.method.static=无法将 abstract 方法设为 static
cannot.perform.refactoring=无法执行重构。
change.signature.code.vision.name=更改签名
change.signature.code.vision.text=更改签名
change.signature.default.value.chooser.title=需要形参“{0}”的默认值
change.signature.default.value.description=在调用此方法时，如果恰好找到了一个正确类型的变量，请使用它。否则请留空。
change.signature.feel.lucky=感到幸运(&L)
change.signature.leave.blank.default.value=留空(&B)
change.signature.use.selected.value=使用所选值(&V)
changeSignature.cannot.resolve.parameter.type=无法解析形参 ''{1}'' 的类型''{0}''。\n是否继续?
changeSignature.default.value.label=默认值\:
changeSignature.name.prompt=名称(&N)\:
changeSignature.parameter.caller.chooser=选择要传播新形参的方法
changeSignature.parameters.wont.propagate=将不会执行形参更改的递归传播
changeSignature.propagate.parameters.title=传播形参(&G)…
changeSignature.refactoring.name=更改签名
changeSignature.return.type.prompt=返回值类型(&T)\:
changing.signature.of.0=更改{0}的签名
checkbox.introduce.parameter.object.keep.method.as.delegate=使方法保持为委托(&D)
choose.destination.class=选择目标类
choose.destination.directory=选择目标目录
choose.destination.package=选择目标软件包
class.0.does.not.exist=类 {0} 不存在。\n是否要创建?
class.0.does.not.have.inheritors=类 {0} 没有继承者。
class.constructors.radio=类构造函数(&C)
class.does.not.have.base.classes.interfaces.in.current.project={0} 在当前项目中没有基类/接口
classes.to.push.down.members.to=要将成员向下推送至{0}的类
column.name.any.var=任意变量
column.name.default.value=默认值\:
column.name.name=名称
column.name.type=类型\:
command.name.copy=复制
command.name.move=移动
command.name.rename=重命名
comments.and.strings=注释和字符串(&C)
comments.elements.header=在注释、字符串和非代码文件 {0} 中发现匹配项
conflicts.count.label={0} 个冲突
conflicts.detected.title=检测到冲突
conflicts.tab.name=冲突
constructor.cannot.be.made.static=构造函数不能设为 static
continue.button=继续(&C)
copy.directories=复制目录…
copy.directory=复制目录…
copy.file=复制文件…
copy.files=复制文件…
copy.files.and.directories=复制文件和目录…
copy.files.clone.directory.0=克隆目录 {0}
copy.files.clone.file.0=克隆文件 {0}
copy.files.clone.title=克隆
copy.files.copy.directory.0=复制目录 {0}
copy.files.copy.file.0=复制文件 {0}
copy.files.copy.specified.directories.label=复制指定的目录
copy.files.copy.specified.files.label=复制指定的文件
copy.files.copy.specified.mixed.label=复制指定的文件和目录
copy.files.copy.title=复制
copy.files.new.name.label=新名称\:
copy.files.to.directory.label=到目录(&D)\:
copy.handler.clone.files.directories=克隆文件/目录
copy.handler.copy.files.directories=复制文件/目录
copy.overwrite.button=覆盖
copy.overwrite.for.all.button=全部覆盖
copy.skip.button=跳过
copy.skip.for.all.button=全部跳过
copy.update.references=更新引用
create.class.command=创建类 {0}
create.directory=创建目录
create.explicit.package.warning=隐式软件包 ''{0}'' 将变为显式
current.method.radio=当前方法(&M)
declare.folded.parameters=折叠形参(&F)
delegation.panel.delegate.via.overloading.method=通过重载方法委托(&L)
delegation.panel.method.calls.label=方法调用\:
delegation.panel.modify.radio=修改(&M)
delete.anyway.button=仍然删除(&D)
delete.title=删除
detecting.possible.conflicts=正在检测可能的冲突…
dialog.message.cannot.inline.reference.from.0=无法从 {0} 内联引用
dialog.message.file.already.exists.in.directory=文件 ''{0}'' 在目录 ''{1}'' 中已存在
dialog.message.method.overridden.in.language.that.doesn.t.support.this.refactoring=使用 {1} 重写了 {0}。此语言不支持“引入形参对象”重构
dialog.message.new.directory.with.ignored.name.warning=正在尝试创建具有忽略名称的目录，结果将不可见
dialog.message.not.supported.source.target.pair.detected=检测到不受支持的源/目标对
dialog.message.refactoring.not.available.in.current.scope={0} 在当前作用域内不可用
dialog.message.selected.element.used.from.non.project.files=从非项目文件中使用所选元素。不会重命名这些用法。仍要继续?
dialog.title.rename.package.directories=重命名软件包目录
directories.and.all.references.to.package.will.be.renamed=\n\n您要重命名哪些目录?
directory.chooser.hide.non.existing.checkBox.text=仅显示现有源根(&H)
directory.description=目录 {0}
do.you.wish.to.continue=您是否希望继续?
do.you.wish.to.ignore.them.and.continue=您是否希望忽略它们并继续?
enter.new.project.name=输入新项目名称\:
entity.name.form=形式
error.cannot.be.renamed=此元素无法重命名
error.in.injected.lang.prefix.suffix=所选{0}位于注入语言文档的只读部分中
error.interface.cannot.be.extracted.from.implicit.class=无法执行重构。\n无法从隐式声明的类中提取接口
error.out.of.project.element=所选{0}不位于项目中
error.out.of.project.element.default=所选元素不位于项目中
error.select.class.to.be.refactored=无法执行重构。\n重构应在要重构的类或成员上调用。
error.superclass.cannot.be.extracted.from.implicit.class=无法执行重构。\n无法从隐式声明的类中提取超类
error.title=错误
error.wrong.caret.position.class=文本光标应置于要重构的类内
error.wrong.caret.position.method.or.class.name=文本光标应置于要重构的方法或类的名称处
error.wrong.caret.position.method.or.local.name=文本光标应置于要重构的元素的名称处
error.wrong.caret.position.method.or.variable.name=文本光标应置于要重构的方法或变量的名称处
error.wrong.caret.position.symbol.to.refactor=文本光标应置于要重构的符号处
error.wrong.caret.position.symbol.to.rename=文本光标应置于要重命名的符号处
extract.include.file.action.title=提取 Include 文件…
extract.include.file.title=提取 Include 文件
extract.interface.command.name=从 {1} 提取接口 {0}
extract.interface.from=从中提取接口\:
extract.interface.title=提取接口
extract.method.progress=提取方法
extract.method.replace.duplicate.command.name=替换重复项
extract.method.title=提取方法
extract.superclass.command.name=从 {1} 提取超类 {0}
extract.superclass.elements.header=将包含成员的超类提取至目录
extract.superclass.from=从中提取超类\:
extract.superclass.title=提取超类
extract.to.directory=提取至目录(&D)\:
extractIncludeFile.name=提取 Include 文件
extractSuper.extract=提取{0}(&X)
extractSuper.rename.original.class=重命名原始类并在可能的情况下使用{0}(&E)
extractSuperInterface.interface=接口
field.0.is.not.static=字段 {0} 不为 static。\n仅 static 成员支持{1}重构。
field.exists=名称为 {0} 的字段\n已存在于类 ''{1}'' 中。\n是否继续?
file.already.exist=文件 {0} 已存在
file.already.exist.title=提取 Include 文件
file.description=文件 {0}
generated.code.usage.that.is.not.safe.to.delete=在生成的代码中使用了无法安全删除的 {0}。
idea.has.found.fragments.that.can.be.replaced.with.include.directive={0} 已发现可以使用 include 指令替换的片段。\n是否要审查这些片段?
initialize.in.border.title=初始化位置(&I)
inline.command=内联{0}
inline.field.border.title=内联
inline.local.variable.prompt=内联局部变量 ''{0}''?
inline.method.action.name=内联方法…
inline.method.border.title=内联
inline.method.command=正在内联方法 {0}
inline.method.method.label=方法{0} {1}
inline.method.title=内联方法
inline.popup.all=所有 {0} 个引用并移除变量
inline.popup.all.keep.name=保留 ''{0}'' 名称
inline.popup.this.only=仅限此引用
inline.title=内联
inline.variable.title=内联变量
inner.classes.cannot.have.static.members=内部类不能有 static 成员
inplace.change.signature.preview.label=已执行签名修改\:
inplace.refactoring.abandon.started=放弃已开始的重构
inplace.refactoring.advertisement.text=按 {0} 显示包含更多选项的对话框
inplace.refactoring.cancel.current=取消当前重构
inplace.refactoring.continue.started=继续已开始的重构
inplace.refactoring.navigate.to.started=导航到已开始的重构
inplace.refactoring.press.again.to.complete=再次按 {0} 以执行重构。
inplace.refactoring.tab.advertisement.text=按 {0} 显示选项弹出窗口
intention.family.name.apply.signature.change=应用签名更改
interface.member.dependency.required.by.interfaces.list={0,choice,1\#接口|2\#接口} {1} 所需
interface.name.prompt=接口名称(&I)\:
introduce.constant.title=引入常量
introduce.field.title=引入字段
introduce.functional.parameter.title=引入函数形参
introduce.functional.variable.title=引入函数变量
introduce.normalize.declaration.command.name=标准化声明
introduce.parameter.title=引入形参
introduce.selection.error=无法使用所选元素执行重构
introduce.target.chooser.expressions.title=表达式
introduce.variable.title=引入变量
invert.0.1=反转{0} {1} 及其用法
invert.boolean.elements.header=要反转的{0}
invert.boolean.name.of.inverted.element=反转的{0}的名称(&N)\:
invert.boolean.refs.to.invert=要反转的引用 {0}
invert.boolean.title=反转布尔
is.not.supported.in.the.current.context=当前上下文不支持{0}
items.to.be.deleted=要被删除的条目
javadoc.as.is=保留原样(&A)
javadoc.copy=复制(&C)
javadoc.move=移动(&M)
keep.abstract.column.header=保持 abstract
label.change.signature.in.all.calls.to.this.method.leave.the.parameter.blank=在对此方法的所有调用中，将形参留空
make.abstract=设为 abstract
member.column=成员
member.info.extends.0=扩展{0}
member.info.implements.0=实现{0}
member.is.already.static=成员已经为 static
members.to.be.moved.should.belong.to.the.same.class=要移动的成员应属于同一类
members.to.be.pulled.up=要被向上拉取的成员(&B)
members.to.be.pushed.down.panel.title=要被向下推送的成员(&B)
members.to.form.interface=要构成接口的成员(&B)
members.to.form.superclass=要构成超类的成员(&B)
method.0.is.already.defined.in.the.1=方法 {0} 已在{1}中定义。
method.0.is.not.static=方法 {0} 不为 static。\n仅 static 成员支持{1}重构。
migration.new.button=新…
move.0.title=移动 {0}
move.classes.destination.package.prompt=到软件包\:
move.classes.move.to.another.source.folder=移至另一个源文件夹(&F)
move.declarations.group=移动声明\:
move.directories.elements.header=目录将被移至 {0}
move.directories.with.dialog=移动目录…
move.directory=移动目录…
move.directory.0=移动目录 {0}
move.file=移动文件…
move.file.0=移动文件 {0}
move.files=移动文件…
move.files.and.directories=移动文件和目录…
move.files.elements.header=文件将被移至 {0}
move.files.group=移动文件\:
move.files.to.directory.label=到目录\:
move.handler.is.dumb.during.indexing=在项目分析进行期间移动文件不会更新其使用情况。在非项目文件中，所选元素不会被重命名。是否仍要继续?
move.inner.to.upper.level.title=将内部类移至上一级
move.instance.method.command=移动实例方法
move.instance.method.title=移动实例方法
move.members.elements.header=要移动的成员
move.members.members.to.be.moved.border.title=需要移动的成员(仅限 static)(&B)
move.members.move.members.from.label=从以下位置移动成员\:
move.members.title=移动 static 成员
move.members.to.fully.qualified.name.label=到(完全限定名称)\:
move.method.is.not.supported.when.method.is.part.of.inheritance.hierarchy=当方法是继承层次结构的一部分时，不支持 Move 方法
move.single.element.elements.header={0} 将被移至 {1}
move.specified.directories=移动指定的目录
move.specified.elements=移动指定的元素
move.specified.files=移动指定的文件
move.title=移动
move.to.different.language=目标类 {2} 具有与{0} {1} 不同的语言
moveInstanceMethod.select.an.instance.parameter=选择一个实例表达式(&I)\:
moving.directories.command=移动目录
multiple.directories.correspond.to.package=软件包 ''{0}'' 存在于多个目录中\:
multiple.directories.correspond.to.package.current.marker=已选择
name.for.extracted.include.file=提取的 include 文件的名称(默认扩展名\: {0})(&N)
name.is.not.a.valid.file.name=名称不是有效的文件名
name.prompt=名称(&N)
no.button=否(&N)
no.destination.class.specified=未指定目标类
no.field.name.specified=未指定字段名称
no.interface.name.specified=未指定接口名称
no.members.selected=未选择任何成员
no.new.name.specified=未指定新名称
no.selection=无选择。
no.superclass.name.specified=未指定超类名
no.target.directory.specified=未指定目标目录
non.code.usage.that.is.not.safe.to.delete=字符串、注释或非代码文件中使用了无法安全删除的 {0}。
occurrences.found.in.comments.strings.and.non.java.files=在注释、字符串和非代码文件中找到匹配项
occurrences.string=({0,choice,1\#1 个匹配项|2\#{0,number} 个匹配项})
open.copy.in.editor=在编辑器中打开副本(&O)
open.in.editor.label=在编辑器中打开(&O)
package.for.new.interface=新接口的软件包(&P)\:
package.for.new.superclass=新超类的软件包(&P)\:
package.for.original.class=原始类的软件包(&P)\:
package.for.original.interface=原始接口的软件包(&P)\:
package.occurs.in.package.prefixes.of.the.following.source.folders.n=软件包 {0} 位于以下源文件夹的软件包前缀中\:
parameters.border.title=形参
path.completion.shortcut=使用 {0} 进行路径补全
please.enter.a.valid.name.for.inverted.element=请为反转的{0}输入一个有效的名称
press.escape.to.remove.the.highlighting=按 Esc 移除高亮显示
preview.button=预览(&P)
problems.detected.title=检测到问题
progress.text=正在查找用法…
progress.title.collect.read.only.files=正在收集只读文件…
progress.title.collecting.references=正在收集引用…
progress.title.collecting.suggested.names=正在收集建议的名称
progress.title.prepare.additional.searcher=准备额外的搜索器
progress.title.prepare.to.delete=准备删除
progress.title.update.added.files=更新添加的文件
pull.members.up.title=向上拉取成员
pull.up.members.to=将{0}的成员向上拉取至(&U)\:
pullUp.command=从 {0} 向上拉取成员
push.down.javadoc.panel.title=摘要的 JavaDoc
push.down.members.elements.header=从 {0} 向下推送成员
push.down.will.delete.members=向下推送成员将导致它们被删除? 要创建新的子类吗?
push.members.down.title=向下推送成员
push.members.from.0.down.label=从{0}向下推送成员
pushed.members.will.not.be.visible.from.certain.call.sites=推送的成员将无法从特定调用点查看
readonly.occurences.found=在只读文件中找到匹配项
refactor.anyway.button=仍然重构(&R)
refactor.button=重构(&R)
refactor.this.title=重构
refactoring.cannot.be.performed=无法执行重构
refactoring.dumb.mode.notification=在索引准备就绪前，重构不可用
refactoring.extract.method.dialog.empty=空
refactoring.extract.method.dialog.method.name=方法名称\:
refactoring.extract.method.dialog.output.variables=输出变量
refactoring.extract.method.dialog.parameters=形参
refactoring.extract.method.dialog.signature.preview=签名预览
refactoring.extract.method.dialog.title=提取方法
refactoring.extract.method.from.duplicate.code=从重复的代码中提取方法
refactoring.extract.method.inplace.options.tooltip=使用 {0} 导航到选项
refactoring.index.corruption.notifiction=检测到索引损坏。请重试重构 - 将自动重新构建索引
refactoring.indexing.warning.title=正在编制索引
refactoring.introduce.context.error=无法在此上下文中执行重构
refactoring.introduce.name.error=名称不正确
refactoring.introduce.name.used.error=此名称已被使用
refactoring.introduce.parameter.incomplete.call.less.params=调用不完整({0})\: 应为 {1} 个形参，但仅找到 {2} 个
refactoring.introduce.parameter.incomplete.call.param.not.found=调用不完整({0})\: 应删除 {1} 形参，但仅找到 {2} 个形参
refactoring.introduce.parameter.interface.chooser.popup.title=选择适用的函数式接口\: {0} -> {1}
refactoring.introduce.parameter.invalid.name=''{0}'' 是无效的形参名称
refactoring.introduce.parameter.object.command.name={1}() 的引入形参类 {0}
refactoring.introduce.parameter.object.method.to.extract.parameters.from.label=要从中提取形参的方法
refactoring.introduce.parameter.object.method.whose.parameters.are.to.wrapped=要包装其形参的方法
refactoring.introduce.parameter.object.references.to.be.modified=要修改的引用
refactoring.introduce.parameter.object.title=引入形参对象
refactoring.introduce.parameter.popup.title=将形参引入方法
refactoring.introduce.selection.error=无法使用所选元素执行重构
refactoring.introduce.variable.scope.error=名称与现有变量的名称冲突
refactoring.introduceVariable=“引入变量”重构
refactoring.is.not.supported.for.recursive.methods=无法应用{0}重构来移除递归方法。\n您只能内联各个方法调用。
refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow=当 return 语句中断执行流时，不支持{0}重构
refactoring.not.available.indexing=索引编制期间，无法使用重构
refactoring.prepare.progress=准备…
refactoring.preprocess.usages.progress=预处理用法
references.found.in.code=在代码中找到引用
references.in.code=代码中的引用 {0}
references.in.code.to.0=代码中对{0}的引用
references.in.code.to.0.1=代码中对{0} {1} 的引用
references.to.be.changed=待更改引用 {0}
related.file=相关文件
remove.duplicates.command=删除重复项
rename.0.and.its.usages.preview.text=重命名 {0} 及其用法
rename.0.and.its.usages.to=将{0}及其用法重命名为\:
rename.bound.forms=重命名绑定形式(&F)
rename.bound.forms.title=重命名绑定形式
rename.code.vision.command.name=重命名代码
rename.code.vision.label=重命名重构
rename.code.vision.text=重命名用法
rename.command.name.0.1=重命名\: {0} → ''{1}''
rename.command.name.0.in.place.template=重命名\: {0}
rename.dialog.new.name.label=新名称(&N)\:
rename.directories.command.name=重命名目录
rename.directory.button.text=仅所选目录(&S)
rename.directory.command.name=重命名目录
rename.directory.title=重命名目录(&D)
rename.finding.auto.rename.options.modal.title=正在查找自动重命名选项
rename.forms.with.the.following.names.to=将具有以下名称的形式重命名为\:
rename.implementation.class.to=将实现类重命名为\:
rename.inheritors=重命名继承者(&I)
rename.inheritors.title=重命名继承者
rename.module.title=重命名模块(&M)
rename.not.all.usages.message=<html>已安全跳过以下用法\:<br>{0}</html>
rename.not.all.usages.title=并非所有用法都已重命名
rename.not.supported=操作不受支持
rename.original.interface.to=将原始接口重命名为\:
rename.package.button.text=所有目录(&A)
rename.parameters.hierarchy=重命名层次结构中的形参(&A)
rename.preview.tab.title=重命名预览
rename.progress.title.0=正在重命名\: {0}…
rename.project=重命名项目
rename.project.action.title=重命名项目…
rename.project.handler.title=重命名项目(&P)
rename.related.file.dialog.description=将相关文件重命名为\:
rename.related.files.option.name=重命名相关文件(具有相同的名称)
rename.source.root.button.text=所选模块中的所有(&M)
rename.string.occurrences.found.title=找到字符串匹配项
rename.string.select.all.occurrences=重命名所有匹配项
rename.string.select.code.occurrences=重命名代码匹配项
rename.target.text.0.1={0} → ''{1}''
rename.title=重命名
rename.usage.unmodifiable=用法无法更新
renames.project=重命名项目
renaming.0.1.to.2=将{0} {1} 重命名为{2}
renaming.command.name=重命名{0}
replace.all.occurences=替换所有匹配项({0} 个匹配项)(&A)
replace.all.occurences.checkbox=替换所有匹配项(&A)
replace.all.occurrences=替换全部 {0} 个匹配项
replace.all.occurrences.but.write=替换所有匹配项但写入
replace.fragment=替换片段
replace.multiple.occurrences.found=找到多个匹配项
replace.this.occurrence.only=仅替换此匹配项
rerun.safe.delete=重新运行安全删除(&S)
retry.command=重试
safe.delete.command=正在删除 {0}
safe.delete.comment.occurences.header=在注释、字符串和非代码文件中发现匹配项 {0}。将不会更改这些匹配项
safe.delete.conflict.title=删除代码中发现的引用可能不安全
safe.delete.not.available.indexing=项目分析期间无法使用安全删除重构
safe.delete.of.those.0.in.comments.strings.non.code=其中 {0,choice,1\#1 个用法|2\#{0,number} 个用法}位于字符串、注释、非代码文件或生成的代码中。
safe.delete.title=安全删除
search.for.references=搜索引用(&F)
search.for.references.dumb.mode=搜索引用(&F)(项目分析期间不可用)
search.for.text.occurrences=搜索文本匹配项(&T)
search.in.comments.and.strings=在注释和字符中搜索(&C)
searching.for.duplicates=正在搜索重复项…
searching.for.overrides=正在搜索重写…
searching.for.variables=正在搜索变量
select.all.button=全选(&A)
select.refactoring.title=选择重构
select.target.directory=选择目标目录
select.target.directory.description=将在此目录中创建文件
selected.block.should.represent.a.set.of.statements.or.an.expression=所选块应代表一组语句或表达式
selected.block.should.represent.an.expression=所选块应该表示一个表达式
selection.does.not.form.a.fragment.for.extraction=选区无法构成要提取的片段
setup.method.radio=setUp 方法(&S)
show.more.conflicts.link=显示更多…
signature.preview.border.title=签名预览
source.and.destination.classes.should.be.different=源类和目标类应不同
statusBar.noUsages=未找到匹配项
statusBar.refactoring.result={0, choice, 1\#1 个匹配项|2\#{0,number} 个匹配项}已更改
suggested.refactoring.change.signature.command.name=更新{0}
suggested.refactoring.change.signature.gutter.icon.tooltip=更新 ''{1}'' 的 {0} 以反映签名更改… {2}
suggested.refactoring.change.signature.intention.text=更新{0}以反映签名更改
suggested.refactoring.change.signature.label.text=更新 {0} 以反映签名更改\:
suggested.refactoring.declaration=声明
suggested.refactoring.disabled.gutter.icon.tooltip=签名已更改，但用法无任何更新
suggested.refactoring.group.key=建议的重构
suggested.refactoring.ignore.button.text=忽略
suggested.refactoring.implementations=实现
suggested.refactoring.next.button.text=下一个
suggested.refactoring.overrides=重写
suggested.refactoring.parameter.values.label.text=为新形参添加值\:
suggested.refactoring.parameter.values.placeholder=可选值
suggested.refactoring.rename.button.text=重命名
suggested.refactoring.rename.command.name=重命名用法
suggested.refactoring.rename.gutter.icon.tooltip=将 ''{0}'' 的用法重命名为 ''{1}''… {2}
suggested.refactoring.rename.intention.text=重命名 ''{0}'' 的用法
suggested.refactoring.rename.popup.text=将 ''{0}'' 的用法重命名为 ''{1}''
suggested.refactoring.rename.text.occurrences=将 ''{0}'' 重命名为 ''{1}'' 时在注释和字符串中发现匹配项。您也想将它们重命名吗?
suggested.refactoring.rename.text.occurrences.title=重命名文本匹配项
suggested.refactoring.rename.with.preview.button.text=使用预览重命名
suggested.refactoring.update.button.text=更新
suggested.refactoring.usages=用法
suggested.refactoring.use.any.variable.checkbox.hint=如果调用位置存在合适类型的单个变量，则会将其用作实参值
suggested.refactoring.use.any.variable.checkbox.text=使用任意变量
superclass.cannot.be.extracted.from.an.interface=无法从接口中提取超类
superclass.name=超类名(&S)\:
target.destination.folder=目标目录(&D)\:
text.identifier.invalid=标识符 ''{0}'' 无效
text.occurrences=文本匹配项(&T)
text.signature.change.was.detected.highlight.tooltip=检测到签名更改
the.caret.should.be.positioned.at.the.class.method.or.field.to.be.refactored=文本光标应置于要重构的类、方法或字段处
the.caret.should.be.positioned.inside.a.class.to.pull.members.from=文本光标应置于要从中拉取成员的类内
the.caret.should.be.positioned.inside.a.class.to.push.members.from=文本光标应置于要从中推送成员的类内
the.file.will.be.copied.to.this.directory=文件将被复制到此目录
the.file.will.be.moved.to.this.directory=文件将被移至此目录
the.following.problems.were.found=发现以下问题\:
the.language.for.selected.elements.has.no.associated.file.type=所选元素的语言没有关联的文件类型
there.is.already.a.0.in.1.it.will.conflict.with.the.new.parameter={1} 中已有一个{0}。它将与新形参冲突。
there.is.already.a.0.in.the.1.it.will.conflict.with.the.renamed.parameter={1} 中已有一个{0}。它将与重命名的形参冲突。
these.package.prefixes.will.be.changed=这些软件包前缀将被更改。
this.invocation.only.and.keep.the.method=仅内联此调用并保留方法(&K)
this.member.does.not.seem.to.belong.to.any.class=此成员似乎不属于任何类
this.reference.only.and.keep.the.variable=仅内联此引用并保留变量(&K)
title.rename.parameters.hierarchy=重命名层次结构中的形参
to.refactor=重构
to.rename=重命名
unselect.all.button=取消全选(&U)
unsupported.refs.found=在 {0} 个文件中找到不受支持的引用
usage.that.is.not.safe.to.delete=使用了无法安全删除的 {0}。
usageView.doAction=重构(&R)
usageView.need.reRun=无法执行重构操作。\n找到用法后代码有更改。\n请再次执行用法搜索。
usageView.tabText=重构预览
usageView.usagesText=用法
usages.detected=检测到用法
used.by.0=被{0}使用
uses.0=使用{0}
variable.has.no.dominating.definition=找不到要内联的单一定义
variable.has.no.initializer=变量 {0} 没有初始值设定项。
variable.is.accessed.for.writing.and.used.with.inlined=另一个变量 ''{0}'' 定义与内联定义结合使用
variable.is.never.used=变量 {0} 从未使用
variable.is.referenced.in.multiple.files=变量 {0} 在多个文件中引用
view.usages=查看用法(&V)
visibility.as.is=保留原样(&A)
visibility.border.title=可见性
visibility.combo.title=可见性(&V)\:
visibility.escalate=升级(&E)
visibility.package.local=Package local(&K)
visibility.private=private(&V)
visibility.protected=protected(&O)
visibility.public=public(&B)
warning.title=警告
what.would.you.like.to.do=您想做什么?
yes.button=是(&Y)

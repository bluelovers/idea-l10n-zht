1.occurrence=(1 个匹配项)
abstract.member.not.have.private.modifier=abstract 成员可能没有 private 修饰符
abstract.modifier.is.not.allowed=''abstract'' 修饰符仅允许用于类或包含 ''override'' 修饰符的定义
abstract.modifier.redundant.fot.traits=''abstract'' 修饰符对于特征是冗余的
abstract.override.modifier.is.not.allowed=''abstract override'' 修饰符仅允许用于特征的成员
access.modifier.is.not.allowed.here=此处不允许使用 ''{0}'' 修饰符
action.implement.method=实现方法
action.import.member=导入成员
action.override.method=重写方法
add.braces.around.single.line.expression=在单行表达式周围添加大括号
add.collection.breakout.argument=添加 `collection.breakOut` 实参
add.import.action=添加导入操作
add.modifier.fix.without.name=添加 ''{0}'' 修饰符
add.override.modifier=插入 "override"(&O)
add.return.type=添加返回值类型
add.to.definition=添加到定义
additional.compiler.options=其他编译器选项(&O)\:
additional.support.has.been.found.popup=<p>已为您的某些库找到了其他支持。</p><p>是否要启用该支持? <a href\="Yes">是</a> / <a href\="No">否</a></p>
align.list.items.content=对齐列表项内容
ambiguous.artifact.resolved=解析了模糊的工件\: {0}
annotation.ascriptions.in.pattern.definitions.require.scala3=模式定义中的注解归属需要使用 Scala 3.0
annotation.or.type.expected=应为注解或类型
annotator.error.annotation.type.expected=应为注解类型
annotator.error.bean.property.should.not.be.private=Bean 属性不应为私有
annotator.error.cannot.apply.constructor=无法应用构造函数 {0}
annotator.error.cannot.find.constructor.for.this.call=找不到此调用的构造函数
annotator.error.cannot.resolve.overloaded.constructor=无法解析重载的构造函数 `{0}`
annotator.error.cannot.resolve.overloaded.method=无法解析重载方法
annotator.error.class.type.required.but.found=需要类类型，但找到的是({0})
annotator.error.constructor.has.malformed.definition=构造函数的定义格式错误
annotator.error.enum.case.must.extend.parent=枚举 case 必须扩展其枚举类 {0}
annotator.error.enum.nonvariant.type.param,in.enum=无法确定枚举类父级 {0} 的类型实参，类型形参 {1} 不变
annotator.error.enum.two.type.parameter.clauses=需要显式 extends 子句，因为枚举 case 和枚举类都有类型形参
annotator.error.expansion.for.non.repeated.parameter=非重复形参扩展
annotator.error.missing.argument.list.for.constructor=构造函数 {0} 缺少实参列表
annotator.error.missing.arguments.for.method=方法 {0} 缺少实参
annotator.error.missing.parameter.type=缺少形参类型
annotator.error.missing.type.annotation.for.parameter=形参缺少类型注解\: {0}
annotator.error.name.has.malformed.definition=''{0}'' 的定义格式错误
annotator.error.no.constructor.accessible=从此处无法访问构造函数
annotator.error.parameter.specified.multiple.times=多次指定了形参
annotator.error.parameter.without.an.owner.name=没有所有者的形参\: {0}
annotator.error.positional.after.named.argument=位于命名实参后
annotator.error.reassignment.to.val=重新赋值给 val
annotator.error.repeated.or.default=带 *-形参的形参部分不允许有默认实参
annotator.error.repeated.parameter.must.be.last=*-形参必须位于最后
annotator.error.target.does.not.take.parameters={0} 不接受形参
annotator.error.too.many.arguments=实参过多
annotator.error.too.many.arguments.for.constructor=构造函数 {0} 的实参过多
annotator.error.too.many.arguments.method=方法 {0} 的实参过多
annotator.error.too.many.parameters=形参过多
annotator.error.trait.has.no.constructor={0} 是特征；不接受构造函数实参
annotator.error.unspecified.value.parameters=未指定的值形参\: {0}
annotator.error.wrong.right.assignment.side=赋值右侧错误
assign.expected=应为 ''\=''
assignment.missing.right.side=右侧缺少赋值
auto.import.add.unambiguous.imports.on.the.fly.for=动态添加明确的 import\:
auto.import.find.more.configuration.options=在<a>代码样式</a>中查找更多配置选项
auto.import.optimize.imports.on.the.fly=动态优化 import
auto.import.show.import.popup.for=为下列对象显示 import 弹出窗口\:
auto.import.show.popup.classes=类
auto.import.show.popup.conversions=隐式转换
auto.import.show.popup.extension.methods=扩展方法
auto.import.show.popup.implicits=隐式定义
auto.import.show.popup.methods=static 成员
auxiliary.constructor.definition.expected=应为辅助构造函数定义
auxiliary.constructor.may.not.have.a.type.annotation=辅助构造函数不能有类型注解
bad.interpolated.string.injection=插值字符串注入错误
balance.header=平衡标头
base.package.help=<html>如果基础软件包为 <code>org.example.application</code>，软件包 <code>org.example.application.NAME</code> 应定义为<br><code>package org.example.application</code><br><code>package NAME</code></html>
better.monadic.for.invalid.pattern=实参必须有显式类型注解
blank.lines.panel.around.class.in.inner.scopes=内部作用域中的类周围
blank.lines.panel.around.field.in.inner.scopes=内部作用域中的字段周围
blank.lines.panel.around.method.in.inner.scopes=内部作用域中的方法周围
bold.surrounder.template.description=粗体\: '''' ''''
both.stub.and.name.identifier.node.are.null={0} 的存根和名称标识符节点均为 null \n{1}
brew.packages=Brew 软件包
bundled.distribution.info.name=已捆绑
by.name.parameters.cannot.be.used=此方法有 Java 重写器，无法使用值类的传名形参。
bytecode.indices.target.for.comprehension.method=for-comprehension 方法
bytecode.indices.target.implicit.definition=隐式定义
bytecode.indices.target.sam.type=SAM 类型
bytecode.indices.target.unapply.method=apply/unapply 方法
call.is.recursive=递归调用
called.constructor.definition.must.precede=被调用的构造函数的定义必须在调用构造函数的定义前面
can.not.override.final={0} ''{1}'' 无法重写 final 成员
can.t.find.implicit.argument.for.this.definition=找不到此定义的隐式实参
can.t.infer.proper.types.for.type.parameters=无法推断类型形参的正确类型
can.t.resolve.type=无法解析类型
cannot.be.a.top.level.definition.in.scala.2=不能是 Scala 2 中的顶层定义
cannot.create.expression=无法创建表达式
cannot.create.field.from.this.expression=无法根据此表达式创建字段
cannot.define.expected.type=无法定义预期类型
cannot.desugarize.typename=无法对 {0} 脱糖
cannot.determine.expected.type=无法确定预期类型
cannot.extract.empty.message=重构选择错误。应为完整表达式或语句的数量。
cannot.extract.self.invocation=无法提取自我调用。
cannot.extract.used.function.definition=不支持重构\: 选区内的函数定义在所选代码段之外使用
cannot.extract.used.type.definition=不支持重构\: 选区内的类型定义在所选代码段外部使用
cannot.find.directory.for.package=找不到软件包的目录\: {0}
cannot.find.enclosing.container=找不到封闭的容器
cannot.find.method.of.stringcontext=找不到 StringContext 的方法 {0}
cannot.find.package.with.name=找不到具有此名称的软件包\: {0}
cannot.find.partialfunction.class=找不到 PartialFunction 类
cannot.find.place.for.the.new.field=找不到新字段的位置
cannot.find.template.for.this.reference=找不到此引用的模板
cannot.find.throwable.class=找不到 Throwable 类
cannot.handle.compatibility.for=无法处理 {0} 的兼容性
cannot.have.infix.type.directly.in.typed.pattern.try.to...=不能直接在类型化模式中使用中缀类型。尝试使用圆括号将其括起。
cannot.infer.type=无法推断类型
cannot.infer.type.of.super.expression=无法推断 `super'' 表达式的类型
cannot.infer.type.without.an.expression=没有表达式，无法推断类型
cannot.infer.type.without.expected.type=没有预期类型，无法推断类型
cannot.infer.type.without.function.expected.type=没有 scala.FunctionN 或 scala.PartialFunction 的预期类型，无法推断类型
cannot.inline.different.files=成员在另一个文件中声明。不支持内联。
cannot.inline.function.functional.parameters=不支持函数与函数形参内联
cannot.inline.function.implicit.parameters=具有隐式形参的函数不支持内联
cannot.inline.function.multiple.clauses=具有多个形参子句的函数不支持内联
cannot.inline.function.varargs=具有 vararg 形参的函数不支持内联
cannot.inline.generic.function=泛型函数不支持内联
cannot.inline.implicit.element=隐式元素不支持内联
cannot.inline.never.used=定义从未使用
cannot.inline.not.method.call=仅常规方法调用支持内联
cannot.inline.not.simple.definition=仅简单的 {0} 定义支持内联
cannot.inline.notsimple.typealias=仅简单的类型别名支持内联
cannot.inline.read.only=无法内联只读元素
cannot.inline.recursive.function=递归函数不支持内联
cannot.inline.special.function=特殊函数不支持内联
cannot.inline.stable.reference=值用于稳定的引用，不能内联
cannot.inline.used.outside.class=成员在包含的类外部使用。不支持内联。
cannot.inline.value.functional.type=不支持值与函数类型内联
cannot.refactor.arg.in.self.invocation.of.constructor=构造函数主体中的自调用实参不支持重构
cannot.refactor.class.parameter.top.level=顶层类的形参不支持重构
cannot.refactor.constr.expression=所选块不应显示为构造函数表达式
cannot.refactor.interpolated.string.prefix=插值字符串前缀不支持重构
cannot.refactor.literal.pattern=文字模式不支持重构
cannot.refactor.named.arg=命名实参不支持重构
cannot.refactor.no.function=找不到用于引入形参的函数
cannot.refactor.not.expression=所选字符串无法提取为表达式
cannot.refactor.not.expression.nor.type=应选择表达式或类型元素
cannot.refactor.not.valid.type=应选择类型元素
cannot.refactor.scope.not.found=找不到适合的类或软件包
cannot.refactor.self.invocation=辅助构造函数中的构造函数调用不支持重构
cannot.refactor.under.generic.call=泛型调用中不支持重构
cannot.resolve=无法解析符号 {0}
cannot.resolve.apply.method=无法解析方法 {0}.apply
cannot.resolve.expression=无法解析表达式
cannot.resolve.in.StringContext=值 ''{0}'' 不是 StringContext 的成员
cannot.resolve.overloaded=无法解析重载方法 ''{0}''
cannot.resolve.parent.class=无法解析父类
cannot.resolve.ref=无法解析引用{0}
cannot.resolve.reference=无法解析引用
cannot.resolve.unapply.method=无法解析方法 {0}.unapply
cannot.resolve.unknown.symbol=无法解析符号
cannot.shape.resolve.self.invocation=无法解析自我调用
cannot.upcast.type.to.other.type=无法将 {0} 向上转换为 {1}
case.class.has.no.primary.constructor=case 类没有主构造函数
case.classes.without.parameter.list.deprecated=已弃用没有形参列表的 case 类
case.classes.without.parameter.list.not.allowed=不允许使用没有形参列表的 case 类
case.clause=case 子句
case.clauses.expected=应为 case 子句
change.signature.add.parameter.clause=添加形参子句
change.signature.not.supported.extractors=提取程序不支持更改签名
change.signature.not.supported.implicit.functions=隐式函数不支持更改签名
change.signature.not.supported.implicit.parameters=具有隐式形参的函数不支持更改签名
change.signature.parameters.same.name.{0}=形参的名称相同\: {0}
change.signature.remove.parameter.clause=移除形参子句
change.signature.specify.type.for.parameter=指定形参 ''{0}'' 的类型
change.signature.vararg.should.be.last.in.clause=Vararg 形参应当为形参子句中的最后一个形参
change.type.to=将 ''{0}'' 类型更改为 ''{1}''
changes.in.scalatest.highlighting.will.be.processed...=只有在新高亮显示的文件上，ScalaTest 中高亮显示的更改才会正确处理。为了获得最佳体验，请重启 Intellij IDEA
channel.early.access.program=抢先体验
channel.nightly.builds=Nightly 版本
channel.stable.releases=稳定版本
choose.class.for.introduce.field=选择用于引入字段的类
choose.either.a.scala.sdk.directory.or.scala.jar.files=选择 Scala SDK 目录或 Scala jar 文件(允许\: 二进制、源代码、文档)
choose.expected=生成器语句中应有 ''<-''
choose.expression.for=选择 {0} 的表达式
choose.function.for.refactoring=选择 {0} 的函数
choose.level.for.extract.method=选择提取方法的级别
choose.level.popup.title=选择级别
choose.scope.for=选择 {0} 的作用域
choose.type.element.for=选择 {0} 的类型元素
class.already.exists.in.package=软件包 {1} 中已存在名称为 {0} 的类
class.has.several.subclasses=由 {0} 个子类扩展
class.has.subclasses=由以下对象扩展
class.is.abstract.it.cannot.be.instantiated=''{0}'' 为 abstract；无法实例化
class.to.pull.up.members.to.class=要将成员向上拉取到 {0} 的类
click.or.press.shortcut.to.change=(点击或按 {0} 进行更改)
click.to.change=(点击以更改)
code.block=代码块
codegeneration.panel.title=代码生成
colon.expected=应为 ''\:''
column.enabled=已启用
column.transformation=转换
command.introduce.type.alias=引入类型别名
companion.class=类
companion.enum=枚举
companion.object=对象
companion.trait=特征
compile.order=编译顺序(&O)\:
compile.order.java.then.scala=先 Java，后 Scala
compile.order.mixed=混合
compile.order.scala.then.java=先 Scala，后 Java
compiler.plugins=编译器插件
compound.type.expected=应为复合类型
condition.expected=应为布尔条件
configure.updates=配置更新…
constructor=构造函数
constructor.cannot.be.instantiated.to.expected.type=构造函数无法实例化为预期类型，实际为 {0}，要求 {1}
constructor.invocation.expected=辅助构造函数必须以调用 ''this'' 开头
context.bounds.not.allowed=此处不允许上下文边界
contravariant.type.covariant.position.of.method=逆变类型 {0} 出现在方法 {2} 的类型 {1} 中的协变位置
contravariant.type.covariant.position.of.value=逆变类型 {0} 出现在值 {2} 的类型 {1} 中的协变位置
contravariant.type.invariant.position.of.method=逆变类型 {0} 出现在方法 {2} 的类型 {1} 中的不变位置
contravariant.type.invariant.position.of.value=逆变类型 {0} 出现在值 {2} 的类型 {1} 中的不变位置
control.curly.braces.based.on.line.indents=根据缩进控制大括号\:
convert.java.to.scala.collection.hint=使用 asScala 转换为 Scala 集合?
convert.java.to.scala.collection.name=转换为 Scala 集合
convert.scala.to.java.collection.hint=使用 asJava 转换为 Java 集合?
convert.scala.to.java.collection.name=转换为 Java 集合
convert.to.explicit.symbol=转换为 Symbol("{0}")
convert.to.explicit.symbol.family=转换为显式符号
convert.to.hex.fix=将八进制文字转换为十六进制
convert.to.long.fix=转换为 long 文字
convert.to.typed.pattern=转换为类型化模式
convert.view.and.context.bounds.to.implicit.parameters=将上下文边界转换为隐式形参
copy.link.to.clipboard=将链接复制到剪贴板
copy.scaladoc=复制 ScalaDoc(&S)
could.not.decompile.file.comment=//无法反编译 {0}
could.not.find.type.for.selection=找不到选择的类型
could.not.infer.type.of.underscore.section=无法推断下划线部分的类型
could.not.perform.inplace.rename=无法执行就地重命名\:\n要重命名的元素\: {0} {1}\n替代\: {2}\n文本光标周围\: {3}
could.not.understand.type=无法理解类型 {0}
coursier.v1.cache=Coursier v1 缓存
covariant.type.contravariant.position.of.method=协变类型 {0} 出现在方法 {2} 的类型 {1} 中的逆变位置
covariant.type.contravariant.position.of.value=协变类型 {0} 出现在值 {2} 的类型 {1} 中的逆变位置
covariant.type.invariant.position.of.method=协变类型 {0} 出现在方法 {2} 的类型 {1} 中的不变位置
covariant.type.invariant.position.of.value=协变类型 {0} 出现在值 {2} 的类型 {1} 中的不变位置
create.annotation.class.named=创建注解类 ''{0}''
create.apply.method.in=在 {0} 中创建 ''apply'' 方法
create.case.class.named=创建案例类 ''{0}''
create.class.named=创建类 ''{0}''
create.companion.object.for.class=为类创建伴生对象
create.extractor.object.named=创建提取程序对象 ''{0}''
create.method.named=创建方法 ''{0}''
create.new.scala.class=创建新的 Scala 类
create.new.scala.class.or.file=新建 Scala 类/文件
create.object.named=创建对象 ''{0}''
create.parameter.named=创建形参 {0}
create.parameterless.method.named=创建无形参方法 ''{0}''
create.trait.named=创建特征 ''{0}''
create.unapply.method.in=在 {0} 中创建 ''unapply'' 方法
create.value.named=创建值 ''{0}''
create.variable.named=创建变量 ''{0}''
debug.info.level.complete.no.tail.call.optimization=完整，无尾调用优化
debug.info.level.none=无
debug.info.level.source=源代码文件特性
debug.info.level.source.and.line.number=源代码和行号信息
debug.info.level.source.line.number.and.local.variable=源代码、行号和局部变量信息
debugging.info.level=调试信息级别(&L)\:
def.dcl.expected=应为定义或声明
def.name=def {0}
default.init.prohibited.literal.types=文字型变量禁止默认初始化
default.ta.settings=设置
default.ta.tooltip=配置类型注解设置
default.value.is.missing.default.arguments=缺少默认值。默认实参将包含空值，而不是新的形参值。
default.value.is.missing.method.calls=缺少默认值。方法调用将包含空值，而不是新的形参值。
default.values=默认值\:
delete.closing.brace=删除 '{' 后删除右大括号
delete.inlined.tag=删除内联标记
delete.unknown.tag=删除未知标记
dependent.function.types.are.not.yet.supported=尚不支持依赖函数类型
deprecation.warnings=弃用警告(&D)
deprecation.warnings.tooltip=发出弃用 API 用法的警告和位置。
derives.cannot.be.unified=无法将 {0} 与 {1} 的类型实参统一
derives.no.member.named.derived=派生值不是对象 {0} 的成员
derives.not.a.class.type={0} 不是类类型，无法派生
derives.scala.class.expected=应为 Scala class/trait
derives.type.has.no.companion.object=无法派生 {0} ，其不含伴生对象
derives.type.has.no.type.parameters=无法派生 {0} ，其不含类型形参
descriptive.name.anonymous=匿名
desugar.add.explicit.override.modifier=添加显式“override”修饰符
desugar.append.semicolon=附加分号
desugar.canonize.arity.0.call=规范化 arity-0 调用
desugar.canonize.block.argument=规范化块实参
desugar.canonize.infix.call=规范化 infix 调用
desugar.canonize.postfix.call=规范化后缀调用
desugar.convert.implicit.class.to.class.and.function=将隐式类转换为类和函数
desugar.convert.parentheses.to.braces.in.for.comprehensions=为推导式将括号转换为大括号
desugar.enforce.parentheses.in.constructor.invocation=在构造函数调用中强制括号
desugar.expand.apply.call=展开“apply”调用
desugar.expand.assignment.call=展开赋值调用
desugar.expand.auto.tupling=展开自动编制元组
desugar.expand.context.bound=展开上下文边界
desugar.expand.dynamic.call=展开动态调用
desugar.expand.eta.expansion=展开 eta 扩展
desugar.expand.for.comprehensions=展开 for 推导式
desugar.expand.function.instantiation=展开函数实例化
desugar.expand.function.type=展开函数类型
desugar.expand.implicit.conversion=展开隐式转换
desugar.expand.macro=展开宏
desugar.expand.placeholder.syntax=展开占位符语法
desugar.expand.procedure.syntax=展开过程语法
desugar.expand.property.declaration=展开属性声明
desugar.expand.property.definition=展开属性定义
desugar.expand.property.setter.call=展开属性 setter 调用
desugar.expand.single.abstract.methods=扩展单一抽象方法
desugar.expand.string.interpolation=展开字符串内插
desugar.expand.to.equals.call=将“\=\=”展开为“equals”调用
desugar.expand.tuple.instantiation=展开元组实例化
desugar.expand.tuple.type=展开元组类型
desugar.expand.type.alias=展开类型别名
desugar.expand.unary.call=展开一元调用
desugar.expand.update.call=展开“update”调用
desugar.expand.vararg.argument=展开 vararg 实参
desugar.expand.view.bound=展开视图边界
desugar.expand.wildcard.import=展开通配符导入
desugar.for.comprehension=for 推导脱糖
desugar.fully.qualify.import.expression=完全限定导入表达式
desugar.fully.qualify.reference=完全限定引用
desugar.function.parameter=函数形参
desugar.group.declarations=声明
desugar.group.expressions=表达式
desugar.group.functions=函数
desugar.group.general=常规
desugar.group.implicits=隐式
desugar.group.method.invocations=方法调用
desugar.group.references=引用
desugar.group.type.annotations=类型注解
desugar.group.types=类型
desugar.inscribe.default.arguments=写入默认实参
desugar.inscribe.explicit.braces=记录显式大括号
desugar.inscribe.implicit.parameters=写入隐式形参
desugar.make.eta.expansion.explicit=使 eta 扩展为显式
desugar.make.method.return.expressions.explicit=使方法 return 表达式为显式
desugar.method.definition=方法定义
desugar.partially.qualify.simple.reference=部分限定简单引用
desugar.reference.pattern=引用模式
desugar.replace.underscore.section.with.default.value=将下划线部分替换为默认值
desugar.scala.code.action.description=Scala 代码脱糖(所选部分/整个文件)
desugar.scala.code.action.text=Scala 代码脱糖…
desugar.scala.code.in.scope=Scala代码脱糖({0})
desugar.substitute.anyref=替换 AnyRef
desugar.type.parameters=类型形参
desugar.underscore.parameter=为形参加下划线
desugar.value.definition=值定义
desugar.variable.definition=变量定义
disabled.word=已禁用
displayname.scala.compiler=Scala 编译器
do.statement=do 语句
documentation.for.project={0} 文档
does.not.take.parameter.default.target=应用程序
dot.expected=应为 ''.''
dot.or.cq.expected=应为 ''.'' 或类限定符
downloading.scala.version=正在下载 Scala {0}
downloading.url=正在下载 {0}
edit.package.prefix=编辑软件包前缀…
else.expected=应为 ''else''
empty.new.expression=空 new 表达式
enable.continuations=启用继续(&C)
enable.loading.external.extensions=启用加载外部扩展
enable.specialization=启用专用化(&S)
enable.specialization.tooltip=遵循 @specialize 注解
enable.warnings=启用警告(&W)
enable.warnings.tooltip=生成警告
enabled.word=已启用
end.of.string.expected=应为字符串结尾
enumerators.binding.case.keyword.found=应为模式，但找到的是 ''case''
enumerators.binding.val.keyword.deprecated=枚举器中的 ''val'' 关键字已弃用
enumerators.expected=''for'' 语句中应有枚举器
enumerators.generator.val.keyword.found=应为模式，但找到的是 ''val''
erasure.warning=(但仍可能匹配其擦除)
error.downloading.scala.version=下载 Scala {0} 时出错
error.message.title.create.entity.quickfix=创建实体快速修复
error.wrong.caret.position.method.name=文本光标应置于要重构的方法的名称处。
except.for.base.package=对基础软件包例外
exclude.value.from.auto.import=从自动导入中排除 ''{0}''
existential.block.expected=应为存在子句
expand.macro=展开宏
expand.to.new.pattern=扩展到\: {0}
expected.another.pattern=应为另一种模式
expected.at.least.one.extension.method=应至少为一种扩展方法
expected.case.on.a.new.line=应为新行中的 case
expected.do=应为 ''do''
expected.do.or.yield=应为 ''do'' 或 ''yield''
expected.more.types=预期更多类型
expected.new.line.after.colon=冒号后应为新行
expected.then=应为 ''then''
expected.type.boolean=预期布尔类型作为方法 {0} 返回值类型
expected.type.constructor=应为类型构造函数 {0}
explain.type.errors=解释类型错误(&E)
explain.type.errors.tooltip=更详细地解释类型错误
expr.type.does.not.conform.expected.type=类型 {0} 的表达式不符合预期类型 {1}
expression.expected=应为表达式
extension.method.expected=应为扩展方法
extension.method.overrides.regular=方法 {0} 是一个扩展方法，无法重写普通方法
extensions.in.selected.library=所选库中的扩展
extract.abstracts=提取 abstract 项
extract.file.method=提取文件方法
extract.local.method=提取 {0} 中的局部方法
extract.local.method.in.else.block=提取 else 块中的局部方法
extract.method.cannot.find.possible.scope=找不到所提取方法的可能作用域
extract.method.title=提取方法
extract.method.to.anonymous.class=将方法提取到匿名类
extract.method.to.class.name=将方法提取到类 {0}
extract.method.to.object.name=将方法提取到对象 {0}
extract.method.to.package.name=将方法提取到软件包 {0}
extract.method.to.trait.name=将方法提取到特征 {0}
extract.trait.action.description=从所选类提取特征
extract.trait.action.text=提取特征…
extract.trait.name=特征名称\:
extract.trait.package.label=新特征的软件包\:
extract.trait.title=提取特征
extract.trait.top.label.text=从中提取特征\:
extraction.of.anonymous.class.with.vars.refs.unsupported=目前不支持提取引用超出作用域的变量的匿名类
failed.to.found.corresponding.underscore.section=找不到相应的下划线部分
family.name.add.braces=添加大括号
family.name.add.collection.breakout=添加 `collection.breakOut`
family.name.add.empty.parentheses=添加空圆括号
family.name.adjust.types=调整类型
family.name.change.type=更改类型
family.name.comparing.length=替换为 .sizeIs
family.name.convert.from.infix.expression=从中缀表达式转换
family.name.convert.implicit.bounds=转换隐式绑定
family.name.convert.parameter.to.underscore.section=将形参转换为下划线部分
family.name.convert.to.curly.braces=转换为大括号
family.name.convert.to.desugared.expression=转换为脱糖表达式
family.name.convert.to.infix.expression=转换为中缀表达式
family.name.convert.to.object=转换为对象
family.name.convert.underscore.section.to.parameter=将下划线部分转换为形参
family.name.create.annotation.class=创建注解类
family.name.create.apply.method=创建 ''apply'' 方法
family.name.create.case.class=创建案例类
family.name.create.class=创建类
family.name.create.companion.object=创建伴生对象
family.name.create.extractor.object=创建提取程序对象
family.name.create.method=创建方法
family.name.create.object=创建对象
family.name.create.parameter=创建形参
family.name.create.parameterless.method=创建无形参方法
family.name.create.trait=创建特征
family.name.create.unapply.method=创建 ''unapply'' 方法
family.name.create.value=创建值
family.name.create.variable=创建变量
family.name.enable.type.mismatch.hints=启用类型不匹配提示
family.name.expand.to.constructor.pattern=扩展到构造函数模式
family.name.filter.set.contains=移除筛选器中的冗余 ''contains''
family.name.give.a.name.to.anonymous.abstract.given=为给定的匿名 abstract 命名
family.name.implement.anonymous.abstract.given=实施给定的匿名 abstract
family.name.import.additional.identifiers=导入附加标识符
family.name.import.all.members=导入所有成员
family.name.import.member.with.stable.path=通过稳定路径导入成员
family.name.make.implicit.conversion.explicit=将隐式转换设为显式
family.name.remove.braces=移除大括号
family.name.remove.case.from.enumerator=从枚举器中移除 ''case''
family.name.remove.tailrec.annotation=移除 @tailrec 注解
family.name.remove.unnecessary.apply=移除不必要的 apply
family.name.replace.type.check.with.pattern.matching=将类型检查替换为模式匹配
family.name.replace.type.with.type.in.vararg.pattern=将 ''\:'' 替换为 vararg 模式中的 ''@''
family.name.replace.with.scala3.vararg.pattern=将 ''\:'' 语法替换为 Scala 3.0 vararg 模式
family.name.some.to.option=Some 转换为 Option
family.name.use.infix.type.syntax=使用中缀类型语法
family.name.use.prefix.type.syntax=使用前缀类型语法
feature.dynamics=动态(&D)
feature.existential.types=存在类型(&E)
feature.experimental.features=实验性功能(&X)
feature.higher.kinded.types=高阶类型(&H)
feature.implicit.conversions=隐式转换(&I)
feature.macros=宏(&M)
feature.postfix.notation=后缀运算符表示法(&P)
feature.reflective.calls=反射调用(&R)
feature.warnings=功能警告(&F)
feature.warnings.tooltip=发出语言功能警告。
features=功能
field.occurrences={0} 个匹配项
file.is.not.writable=文件没有写入权限
file.type.scala.outlines=Scala 概述
final.modifier.is.not.allowed.here=此处不允许使用 ''final'' 修饰符
final.modifier.is.redundant.with.final.parents=''final'' 修饰符对于对象或 final 类成员是冗余的
final.modifier.not.with.declarations=''final'' 修饰符不能用于不完整的成员
final.modifier.not.with.trait=不允许对特征使用 ''final'' 修饰符
find.what.companion.module.checkbox=伴生模块的用法(&C)
find.what.implementing.type.definitions.checkbox=实现类型定义(&D)
find.what.members.usages.checkbox=成员的用法(&M)
find.what.new.instances.usages=仅创建实例(&I)
for.pattern.bindings.require.scala3=''for'' 模式绑定中的 ''case'' 语法需要 Scala 3.0
for.statement=for 语句
forward.reference.detected=错误的前向引用
fruitless.type.test=fruitless type test\: 类型 {0} 的值不能同时也为 {1}
fun.sign.expected=应为 ''\=>''
function.expression=函数表达式
function.must.define.type.explicitly=方法 {0} 包含 return 语句；需要结果类型
function.recursive.need.result.type=递归方法 {0} 需要结果类型
generate.scaladoc=生成 Scaladoc
generate.scaladoc.action.description=生成 scaladoc
generate.scaladoc.action.text=生成 Scaladoc
given.alias.declaration.must.be.named=给定的匿名不能为 abstract
go.to.companion=转到伴生 {0}
go.to.implementation=转到实现
go.to.super.method=转到 super 成员
goto.super.class.chooser.title=选择超类
goto.super.class.or.member.chooser.title=选择超类/super 成员
goto.super.member.chooser.title=选择 super 成员
gutter.companion=伴生
gutter.implemented=被实现成员
gutter.implementing=实现成员
gutter.overridden=被重写成员
gutter.overriding=重写成员
gutter.recursion=递归类型
gutter.sam=实现 SAM
has.companion=具有伴生 {0}
has.implementations=成员有多个实现
has.no.reference=无引用
hint.label.expected=预期
hint.label.non.singleton=非单例
hint.label.original=原始
hint.label.simplified=简化
how.to.add.custom.macro.support.help.link.title=如何添加自定义 Scala 宏支持
html.unable.to.launch.web.browser=无法启动 web 浏览器，请手动打开\: {0}
id.is.already.defined=此作用域中已定义 {0}
idea.based.scala.project=基于 IDEA 的 Scala 项目
idea.is.outdated.please.update=您的 IDEA 已过时，无法对 Scala 插件 {0} 分支使用。<br/>请至少将 IDEA 更新到 {1}，以使用最新的 Scala 插件。
idea.will.try.to.search.for.extra.support.for.particular.libraries=IDEA 将尝试搜索对您项目中特定库的额外支持
identifier.expected=应为标识符
identifier.expected.but.0.found=应为标识符，但实际是{0}
identifier.expected.comma.found=应为标识符，但找到的是 '',''
identifier.or.opening.brace.expected=应为标识符或左括号
identifier.or.wild.sign.expected=应为标识符或 ''_''
if.block=if 块
illegal.assignment.target=非法赋值目标
illegal.inheritance.extends.enum=禁止扩展枚举
illegal.inheritance.from.final.kind=从 final {0} ''{1}'' 的非法继承
illegal.inheritance.from.sealed.kind=从密封的 {0} ''{1}'' 非法继承
illegal.inheritance.from.value.class=从值类 {0} 非法继承
illegal.inheritance.multiple={0} ''{1}'' 继承了多次
illegal.inheritance.self.type=非法继承，自类型 {0} 不符合 {1}
illegal.instantiation={0} ''{1}'' 为 abstract；无法实例化
illegal.mixin={0} ''{1}'' 必须是特征才可以混入
illegal.modifiers.combination=非法的修饰符组合\: {0} 和 {1}
illegal.secondary.constructors.value.class=值类中不允许使用辅助构造函数
illegal.undefined.member=仅类可以具有已声明但未定义的成员
illegal.underscore.separator=下划线分隔符需要使用 Scala 2.13
implement.members.fix=实现成员
implements.member.from.prefix=成员实现自
implements.member.from.several.classes=实现 {0} 类中的成员
implements.member.prefix=实现成员
implicit.argument.is.applicable=隐式实参适用
implicit.arguments=隐式实参\:
implicit.arguments.for.implicit.conversion=适用于隐式转换的隐式实参\:
implicit.class.must.have.a.primary.constructor.with.one.argument=隐式类必须具有主构造函数，并且该构造函数恰好包含第一个形参列表中的一个实参
implicit.conversions.action.description=显示隐式转换
implicit.conversions.action.text=显示隐式转换
implicit.is.diverged=implicit 已分叉
implicit.modifier.can.be.used.only.for=''implicit'' 修饰符只能用于值、变量、方法和类
implicit.modifier.cannot.be.used.for.top.level.objects=''implicit'' 修饰符无法用于顶层对象
implicit.params.excepted=隐式形参子句必须至少有一个形参
import.additional.identifiers.from.qualifier=从限定符导入其他标识符
import.all.members.of.reference=导入 {0} 的所有成员
import.as=作为 ''{0}'' 导入
import.class=导入类
import.class.chooser.title=要导入的类
import.conversion.chooser.title=要导入的转换
import.expr.should.be.qualified=必须限定 import 表达式
import.extension.method=导入扩展方法…
import.extension.method.chooser.title=要导入的扩展方法
import.global.member=导入全局成员
import.hint.text={0}? {1} Alt+Enter
import.implicit=导入隐式…
import.implicit.chooser.title=要导入的隐式定义
import.implicit.conversion=导入转换…
import.multiple.choices=(多重选择…)
import.package=导入软件包
import.package.chooser.title=要导入的软件包
import.selector.expected=应为 import 选择器
import.something=导入…
import.something.chooser.title=要导入的名称
import.stable.member=导入 {0}
import.with=导入 ''{0}''
import.with.prefix=通过前缀导入
import.with.prefix.ellipsis=通过前缀导入…
imports.panel.add.fully.qualified.imports=添加完全限定 import
imports.panel.add.import.statement.in.closest.block=添加最接近的块中的 import 语句
imports.panel.add.import.to.always.mark.it.as.used=添加 import 以始终将其标记为已使用
imports.panel.add.package.name=添加软件包名
imports.panel.add.pattern.to.use.appropriate.classes.only.with.prefix=添加模式以使用仅带有前缀的适当的类
imports.panel.always.mark.as.used=始终标记为已使用
imports.panel.base.package.help=如果基础软件包为 <code>org.example.application</code>，类 <code>org.example.application.NAME</code> 应导入为 <code>import NAME</code>
imports.panel.class.count.to.use.import.with=将 import 与 ''_'' 搭配使用的类计数\:
imports.panel.classes.to.use.only.with.prefix=仅使用指定前缀的类
imports.panel.do.not.change.path.during.optimize.imports.for.local.imports=在针对本地 import 优化 import 期间不更改路径
imports.panel.force.scala2.in.source3=使用 -Xsource\:3 时导入语法\:
imports.panel.honestly.mark.imports.as.unused=如实将 import 标记为未使用
imports.panel.import.layout=导入布局
imports.panel.import.layout.manager=导入布局管理器
imports.panel.imports.always.marked.as.used=import 始终标记为已使用
imports.panel.lexicographically=字典顺序
imports.panel.merge.imports.with.the.same.prefix.into.one.statement=将具有相同前缀的 import 合并到一条语句中
imports.panel.no.imports.with.prefix=没有带前缀的 import
imports.panel.scalastyle.consistent=scalastyle 一致
imports.panel.sort.imports.for.optimize.imports=import 排序(用于优化 import)\:
imports.panel.title=Import
imports.panel.use.references.with.prefix=使用带前缀的引用\:
imports.panel.use.the.shortest.path.when.trying.to.import.reference.with.already.imported.name=在尝试导入具有已导入名称的引用时，请使用最短路径
incompatible.plugin.detected=检测到不兼容的插件
incrementality.type=递增类型(&I)\:
indent.pasted.lines.at.caret=在文本光标处缩进粘贴的行
indented.definitions.expected=应为缩进定义
inline.local.method.elements.header=要内联的局部方法
inline.local.method.label=是否内联局部方法 {0}?
inline.local.type.alias.elements.header=要内联的局部类型别名
inline.local.type.alias.label=是否内联局部类型别名 {0}?
inline.local.variable.elements.header=要内联的局部变量
inline.local.variable.label=是否内联局部变量 {0}?
inline.method.elements.header=方法内联
inline.method.label=是否内联方法 {0}?
inline.method.title=内联方法
inline.occurrences.label=({0} 个{0, choice, 1\#匹配项|2\#匹配项})
inline.type.alias.elements.header=要内联的类型别名
inline.type.alias.label=是否内联类型别名 {0}?
inline.type.alias.title=内联类型别名
inline.variable.elements.header=要内联的变量
inline.variable.label=是否内联变量 {0}?
inline.variable.title=内联变量
insert.block.braces.automatically.based.on.indentation=自动添加大括号
insert.block.braces.automatically.based.on.indentation.tooltip=在编辑代码时，当单行块变为多行块时添加大括号
insert.pair.multiline.quotes=为多行字符串插入成对引号
integer.literal.is.out.of.range=整数文字超出 Int 类型的范围
intention.add.explicit.unit.type.annotation=添加显式 Unit 类型注解
intention.family.put.on.one.line=将{0}放在同一行中
intention.family.put.on.separate.lines=将{0}放在单独的行中
intention.for.comprehension.convert.to.parentheses=转换为圆括号
intention.type.annotation.function.add.text=将类型注解添加到函数定义
intention.type.annotation.function.regenerate.text=重新生成函数定义的类型注解
intention.type.annotation.function.remove.text=从函数定义中移除类型注解
intention.type.annotation.parameter.add.text=将类型注解添加到形参
intention.type.annotation.parameter.remove.text=从形参中移除类型注解
intention.type.annotation.pattern.add.text=将类型注解添加到模式定义
intention.type.annotation.pattern.remove.text=从模式定义中移除类型注解
intention.type.annotation.regen.family=重新生成类型注解
intention.type.annotation.toggle.family=切换类型注解
intention.type.annotation.underscore.add.text=将类型注解添加到下划线形参
intention.type.annotation.underscore.remove.text=从下划线形参中移除类型注解
intention.type.annotation.value.add.text=将类型注解添加到值定义
intention.type.annotation.value.regenerate.text=重新生成值定义的类型注解
intention.type.annotation.value.remove.text=从值定义中移除类型注解
intention.type.annotation.variable.add.text=将类型注解添加到变量定义
intention.type.annotation.variable.regenerate.text=重新生成变量定义的类型注解
intention.type.annotation.variable.remove.text=从变量定义中移除类型注解
introduce.field.title=提取字段
introduce.parameter.title=引入形参
introduce.type.alias.title=引入类型别名
introduce.variable.declare.as.var=变量(&V)
introduce.variable.identifier.is.not.valid=标识符无效
introduce.variable.specify.type.explicitly=指定类型
introduce.variable.title=引入值/变量
introduced.typeAlias.will.conflict.with.class.name=引入的类型别名与类名冲突\: {0}
introduced.typeAlias.will.conflict.with.type.name=引入的类型别名与类型名称冲突\: {0}
introduced.variable.will.conflict.with.class.parameter=引入的变量与类形参冲突(或可能被其隐藏)\: {0}
introduced.variable.will.conflict.with.field=引入的变量将与没有形参的字段或方法冲突(或可能被其隐藏)\: {0}
introduced.variable.will.conflict.with.local=引入的变量与局部变量冲突(或可能被其隐藏)\: {0}
introduced.variable.will.conflict.with.parameter=引入的变量与形参冲突(或可能被其隐藏)\: {0}
invalid.scala.version.format=无效的 Scala 版本格式\: {0}
invalid.update.channel=更新通道无效
is.overridden.by=成员有多个重写
italic.surrounder.template.description=斜体\: '' ''
ivy2.cache=Ivy2 缓存
ivy2.indexing.mode.classes=类
ivy2.indexing.mode.disabled=已禁用
ivy2.indexing.mode.metadata=元数据
java.collection=Java 集合
java.constructors.only.have.one.parameter.section=Java 构造函数只有一个形参部分
known.extension.libraries=已知扩展库
lazy.modifier.is.not.allowed.here=''lazy'' 修饰符仅允许用于值定义
lazy.modifier.is.not.allowed.with.param=此处不允许使用 ''lazy'' 修饰符，请改用传名调用形参
lazy.values.may.not.be.abstract=lazy 值可能不为 abstract
lbrace.expected=应为 '{'
library.type.scala.sdk=Scala SDK
line.is.indented.too.far.to.the.left=行向左缩进过多
local.project.libraries=本地项目库
local.variables.must.be.initialized=局部变量必须初始化
location.description.anonymous.class=匿名类
location.description.body.of.name={0} 的正文
location.description.containing.block=包含块
location.description.parameter.of.getclassnametext={0} 的形参
location.description.parameter.of.name={0} 的形参
long.literal.is.out.of.range=整数甚至超出 Long 类型的范围
lower.bound.conform.to.upper=下界与上界不符
lowercase.long.marker=小写的 long 文字标记
lowercase.long.marker.fix=将 long 文字标记转换为大写
macro.defs.must.have.explicit.return.type=宏定义必须有显式指定的返回值类型
main.method.parameters.table.column.title.name=名称
main.method.parameters.table.column.title.type=类型
main.method.parameters.table.column.title.value=值
make.explicit=设为显式
make.explicit.and.import.method=设为显式(导入方法)
make.implicit.conversion.explicit.action.description=将隐式转换设为显式
make.implicit.conversion.explicit.action.text=将隐式转换设为显式
make.import.fully.qualified=将 import 设为完全限定
make.non.private.title=将属性设为非私有属性
make.protected.fix=将属性设为 protected
make.public.fix=将属性设为公共属性
make.type.more.specific=使声明类型更具体
make.type.more.specific.fun=使返回值类型更具体
match.type.cases.expected=应为 match 类型 case 子句
maven.local.repo=Maven 本地仓库
member.cannot.override.val=方法 {0} 必须为不可变的稳定值
member.implementation.required={0} ''{1}'' 必须声明为 abstract，或者必须在 ''{3}'' 中实现 abstract 成员 ''{2}''
member.is.not.defined={1} 中的成员 {0} 未定义
member.needs.override.modifier={0} ''{1}'' 需要重写修饰符
member.of.anonymous.class.cannot.be.used.in.extracted.member=匿名类的成员 {0} 无法在提取的成员 {1} 中使用
member.overrides.nothing={0} ''{1}'' 不重写任何内容
members.to.extract=要提取的成员
method.annotated.with.tailrec.contains.no.recursive.calls=使用 @tailrec 注解的方法不包含任何递归调用
method.annotated.with.tailrec.is.neither.private.nor.final=使用 @tailrec 注解的方法既不为 private 也不为 final (因此可以重写)
method.invocation.might.produce.nullpointerexception=方法调用可能会产生 NullPointerException
method.invocation.will.produce.nullpointerexception=方法调用将产生 NullPointerException
method.is.not.member=方法 {0} 不是类型 {1} 的成员
method.is.overridden.by.class.parameter.of.class=方法被 {0} 的传类形参重写。不支持将其转换为函数定义。
method.is.overridden.in.a.composite.pattern.definition=方法在 {0} 的复合模式定义中被重写。不支持将其转换为函数定义。
method.is.overridden.in.a.composite.variable.definition=方法在 {0} 的复合变量定义中被重写。不支持将其转换为函数定义。
method.is.recursive=方法 ''{0}'' 为递归方法
method.is.tail.recursive=方法 ''{0}'' 为尾递归方法
method.of.containingclass={0}/{1}
missing.argument.list.for.method=方法 {0} 缺少实参列表
missing.argument.list.for.method.with.explicit.list=方法 {1} 缺少实参列表 {0}
missing.char.value=缺少字符值
missing.getter.implementation=缺少 getter 的实现\: {0}
missing.parameter.type.name=缺少形参类型\: {0}
missing.setter.implementation=缺少 setter 的实现\: {0}
missing.statement.for.annotation=注解的语句缺失
mixin.required={0} ''{1}'' 需要为 mixin，因为 ''{3}'' 中的成员 ''{2}'' 被标记为 ''abstract'' 和 ''override''，但在基类中找不到具体的实现
modifier.is.redundant.for.this.definition=''{0}'' 修饰符对于此定义冗余
modify.method.calls=修改方法调用
module.with.a.scala.sdk=包含 Scala SDK 的模块
monospace.surrounder.template.description=等宽\: ` `
move.anonymousToInner.dialog.title=将匿名转换成内部
move.anonymousToInner.name=将匿名转换成内部…
move.members=移动成员
move.members.cannot.find.object=找不到具有此名称的对象
move.members.not.supported.implicits=隐式定义不支持移动重构
move.members.not.supported.overridden=被重写的定义不支持移动重构
move.members.object.name.or.qualified.name.expected=应为 Scala 对象的名称或限定名称
move.members.source.title=移动此对象中的成员\:
move.members.supported.only.stable.objects=仅稳定的对象成员支持移动重构
move.members.target.title=到对象\:
move.text.after.header.to.new.line=将文本移至靠近新行的标头后面
move.to.inner.is.not.supported=Scala 不支持将类移至内部
move.to.inner.is.not.supported.title=不支持重构
move.with.companion=与伴生对象一起移动
multi.line.string.panel.align.dangling.closing.quotes=对齐悬空的右引号(&A)
multi.line.string.panel.insert.margin.char.on.enter=在新行中按 enter 键时插入边距字符(&I)
multi.line.string.panel.margin.char.indent=边距字符缩进\:
multi.line.string.panel.margin.char.value=边距字符\:
multi.line.string.panel.opening.quotes.on.new.line=在新行中放置左引号(&O)
multi.line.string.panel.place.closing.quotes.on.new.line.on.enter.press=在新行中按 enter 键时放置右引号(&C)
multi.line.string.panel.process.margin.on.copy.paste=在复制/粘贴时去除/插入边距(&S)
multi.line.string.panel.title=多行字符串
multi.occurrences=({0} 个匹配项)
multiple.overriden.tooltip=多个被重写成员
multiple.overriding.tooltip=多个重写成员
name.does.not.take.type.arguments={0} 不接受类型实参
name.implements.member.of.qualname={0} 实现 {1} 的成员
name.overrides.member.of.qualname={0} 重写 {1} 的成员
navigate=导航
navigation.findUsages.title.implementing.member={0} 的实现成员
navigation.findUsages.title.inheritors.class={0} 的子类
navigation.findUsages.title.inheritors.trait={0} 的实现
navigation.findUsages.title.overriding.member={0} 的重写成员
navigation.findUsages.title.super.members={0} 的 super 成员
navigation.findUsages.title.super.types={0} 的父类型成员
navigation.title.implementing.member=<html>选择 <b>{0}</b> 的实现成员(找到 {1} 个成员)</html>
navigation.title.inheritors.class=<html>选择 <b>{0}</b> 的子类(找到 {1} 个类)</html>
navigation.title.inheritors.trait=<html>选择 <b>{0}</b> 的实现(找到 {1} 个类)</html>
navigation.title.overriding.member=<html>选择 <b>{0}</b> 的重写成员(找到 {1} 个成员)</html>
navigation.title.super.members=选择 {0} 的 super 成员
navigation.title.super.types=选择 {0} 的父类型成员
new.class.location.inner.in.class={0} 中的内部
new.class.location.local.scope=局部作用域
new.class.location.new.file=新文件
new.class.location.top.level.in.this.file=此文件的顶层
new.on.case.class.instantiation.redundant=移除 ''new'' 修饰符
new.packageobject.menu.action.description=创建新的 Scala 软件包对象
new.packageobject.menu.action.text=软件包对象
newclass.menu.action.description=创建新的 Scala 类
newclass.menu.action.text=Scala 类
newclassorfile.menu.action.description=创建新的 Scala 类或文件
newclassorfile.menu.action.text=Scala 类/文件
no.alias.type=无别名类型
no.clazz.type.found=找不到类类型
no.containing.file=未包含文件
no.declared.type.found=找不到声明的类型
no.defined.return.type=没有定义的返回值类型
no.element.found=找不到元素
no.expected.type.for.wildcard.naming=通配符命名没有预期的类型
no.expression.in.parentheses=圆括号中无表达式
no.implicit.arguments=无隐式实参
no.implicit.arguments.of.type=无类型的隐式实参\: {0}
no.implicits.applicable.by.type=没有按类型适用的隐式定义
no.known.extension.libraries=无已知的扩展库
no.program.arguments=无程序实参
no.response.status.from.connection.to.url=与 {0} 的连接无响应状态
no.type.element.for.typed.pattern=类型化模式没有类型元素
no.type.element.found=在 ''{0}'' 中找不到类型元素
no.type.inferred=没有为表达式 ''{0}'' 推断出类型
no.type.inferred.for.unknown.expression=没有为此表达式推断出类型
no.type.pattern=无类型模式
no.versions.available.for.download=没有可供下载的版本
not.a.polymorphic.lambda=非多态 lambda。
not.enough.parameter.sections=形参部分不足
not.found.scala.xml.node=找不到 scala.xml.Node
nothing.to.type=没有可以计算的类型
notification.navigation.to.overriding.members=在索引更新期间无法导航到重写成员
nullable.to.notnull.param.always.message=Null 被传递给使用 @NotNull 注解的形参
nullable.to.notnull.param.sometimes.message=可能为 null 的实参被传递给使用 @NotNull 注解的形参
nullable.to.unannotated.param.always.message=Null 被传递给可能无法处理 null 值的形参。考虑使用 @Nullable 对其进行注解。
nullable.to.unannotated.param.sometimes.message=可能为 null 的实参被传递给可能无法处理 null 值的形参。考虑使用 @Nullable 对其进行注解。
numeric.literal.family=数字文字
object.creation.impossible.since=由于{0}，无法创建对象
octal.literals.removed=自 Scala 2.11 起已禁用八进制文字语法
only.classes.can.be.open=只有类可以打开
only.for.scala=这仅适用于 scala 文件
only.inline.methods.may.have.inline.args=`inline` 修饰符只能用于内联方法的实参
opaque.modifier.allowed.only.for.type.aliases=''opaque'' 修饰符仅允许用于类型别名
optimise.bytecode=优化字节码(慎用*)(&O)
optimise.bytecode.tooltip=通过对程序应用优化来更快地生成字节码。可能会触发各种编译问题。慎用。
options=选项
options.scala.display.name=Scala
other.panel.alternate.indentation.for.constructor.args.and.parameter.declarations=构造函数实参和形参声明的备选缩进\:
other.panel.enforce.functional.syntax.for.methods.with.unit.return.type=对具有 Unit 返回值类型的方法强制执行函数语法
other.panel.implicit.class.prefix.suffix=隐式类前缀/后缀
other.panel.kind.projector.replace.lambda.with.unicode.symbol=Kind Projector\: 将 ''Lambda'' 替换为 unicode 符号
other.panel.reformat.on.compile=编译时重新格式化
other.panel.replace.in.for.generator.with.unicode.symbol=将 "for" 生成器中的 ''<-'' 替换为 unicode 符号
other.panel.replace.with.unicode.symbol=将 ''\=>'' 替换为 unicode 符号
other.panel.replace.with.unicode.symbol1=将 ''->'' 替换为 unicode 符号
other.panel.spaces=空格
other.panel.title=其他
out.of.compilation.unit=超出编译单元
output.dir=输出目录
override.modifier.is.not.allowed=此处不允许使用 ''override'' 修饰符
override.modifier.is.not.allowed.for.classes=''override'' 修饰符仅允许用于类型定义成员
override.types.not.conforming=重写类型 {0} 与基本类型 {1} 不符
overrides.member.from.prefix=重写成员自
overrides.member.from.several.classes=重写 {0} 类中的成员
overrides.type.from.super.several.classes=重写 {0} 类中的类型
overrides.type.prefix=重写类型
package.prefix.example=例如 ''org.example.application''
package.prefix.help=如果软件包前缀为 <code>org.example.application</code>，源目录中的 <code>PATH</code> 意味着 <code>org/example/application/PATH</code>，所以不必创建显式 <code>org</code>、<code>example</code> 和 <code>application</code> 子目录。
package.prefix.label=软件包前缀\:
package.qualID.expected=应为软件包限定标识符
param.clause.expected=应为形参子句
parameter.could.not.be.repeated.and.by.name=形参不能同时为重复形参和传名形参
parameter.expected=应为形参
parameter.info.not.matchable=<非可匹配>
parameter.label.default.value=默认值\:
parameter.label.name=名称\:
parameter.label.type=类型\:
parameter.type.expected=应为形参类型
parameterised.trait.is.implemented.indirectly=形参化特征 {0} 为间接实现，需要直接实现，以便可以传递实参
passed.as.by.name.parameter=作为传名形参传递
pattern.expected=应为模式
pattern.on.refinement.unchecked=细化类型中的模式匹配未检查
pattern.type.incompatible.with.expected=模式类型与预期类型不兼容，实际为 {0}，要求 {1}
please.select.scala.plugin.update.channel=请选择 Scala 插件更新通道\:
poly.function.without.parameters=多态函数 {0} 必须有一个值形参
presentable.definition.unnamed=未命名
presentable.type.unnamed=未命名类型
press.alt.enter=按 Alt+Enter
press.escape.to.remove.the.highlighting=按 esc 移除高亮显示
press.hotkey.to.show.more.options=按 ctrl + alt + v 显示带有更多选项的对话框
private.member.cannot.be.used.in.extracted.member=私有成员 {0} 无法在提取的成员 {1} 中使用
problem.prefix.ambiguous=(模糊)
problem.prefix.not.found=(未找到)
process.duplicates=处理重复项
processing.imports.modified.during.refactoring=正在处理重构期间修改的 import
provide.program.arguments=提供程序实参
pull.method.to=将方法 ''{0}'' 拉取到…
pull.up.members.from=向上拉取成员自
pull.value.to=将值 ''{0}'' 拉取到…
pull.variable.to=将变量 ''{0}'' 拉取到…
rbrace.expected=应为 '}'
rearranger.panel.keep.java.style.getters.and.setters.together=java 样式的 getter 和 setter 保持在一起
rearranger.panel.keep.scala.style.getters.and.setters.together=scala 样式的 getter 和 setter 保持在一起
rearranger.panel.split.into.unarrangeable.blocks.by.expressions=通过表达式拆分为不可排列的块
rearranger.panel.split.into.unarrangeable.blocks.by.implicits=通过隐式拆分为不可排列的块
reason.prefix.applicable=适用\: 
reason.prefix.candidate=候选\: 
reason.prefix.cannot.infer.type=无法推断类型\: 
reason.prefix.diverged=分叉\: 
recursive.call.not.in.tail.position=递归调用不在尾部位置(在 @tailrec 注解的方法中)
recursive.non.value.type.of.type.element=类型元素的递归非值类型
recursive.type.of.type.element=类型元素的递归类型
refactoring.is.not.supported.contains.return=不支持重构\: 选区包含 return 语句
refactoring.is.not.supported.in.guard=临界中不支持重构，它很可能破坏代码结构
refresh.roots.synchronizing.output.directories=正在同步输出目录…
regular.method.overrides.extension=方法 {0} 是一个普通方法，无法重写扩展方法
remove.all.erroneous.semicolons.from.forexpression=从 for 表达式中移除所有错误的分号
remove.block.braces.automatically.based.on.indentation=自动移除大括号
remove.block.braces.automatically.based.on.indentation.tooltip=在编辑代码时，当多行块变为单行块时移除大括号
remove.braces.from.import=移除 import 语句中的大括号
remove.case=移除 ''case''
remove.case.clause=移除 case 子句
remove.catch=移除 catch 块
remove.finally=移除 finally 块
remove.generic=移除 {0}
remove.named.modifier.fix=移除 ''{0}'' 修饰符
remove.return.keyword=移除 return 关键字
remove.unnecessary.parentheses=移除不必要的圆括号
remove.val=移除 ''val''
rename=重命名
rename.aliased.rename.actual=重命名实际元素
rename.aliased.title=不支持重命名 import 别名
rename.all.base.members=重命名所有基本成员
rename.base.member=重命名基本成员
rename.cancel=取消
rename.companion.module=重命名伴生 {0}
rename.getters.and.setters.title=函数有同名的 getter 或 setter。是否也对它们进行重命名?
rename.has.multiple.base.members={0} 有多个基本成员
rename.only.current.member=仅重命名当前成员
rename.only.in=仅在 {0} {1} 中重命名
rename.special.method.rename.class=重命名包含{0}
rename.special.method.title=此方法无法重命名
repeated.param.non.method=仅方法签名中允许重复的形参。改用 `Seq`
replace.all.occurrences=替换所有匹配项
replace.all.x.occurrences=替换全部 {0} 个匹配项
replace.fun.type=将 FunctionN[A1, A1, ...,  AN, R] 替换为 (A1, A1, ...,  AN) \=> R
replace.occurrences.available.from.companion.class=替换伴生类 {0} 中可用的匹配项
replace.tag.with.esc.seq=将标记替换为转义序列
replace.tuple.type=将 TupleN[A1, A1, ...,  AN] 替换为 (A1, A1, ...,  AN)
replace.with.type=替换为 ''{0}''
replace.with.wiki.syntax=将内联标记替换为等宽的 wiki 语法
report.highlighting.error.fix=报告高亮显示错误…
resolving.compiler.bridge.progress.message=正在解析编译器桥
response.to.connection.to.url.was.code=与 {0} 连接的响应为 ''{1}''
return.expression.is.redundant=从 Unit 结果类型的方法返回 {0}
return.outside.method.definition=return 语句在方法定义外部
right.brace.expected=应为 '}'
rparenthesis.expected=应为 '')''
rsqbracket.expected=应为 '']''
scala.3.support.is.experimental=Scala 3 支持正在积极开发中。<br>请使用 Nightly 版本来获取新的改进。
scala.collection.highlighting.type.all=所有
scala.collection.highlighting.type.none=无
scala.collection.highlighting.type.only.non.qualified=仅非限定
scala.compiler.profiles.panel.create.new.profile=创建新的配置文件
scala.compiler.profiles.panel.move.to=移至
scala.compiler.profiles.panel.profile.already.exists=配置文件 {0} 已存在
scala.compiler.profiles.panel.profile.name=配置文件名称
scala.compiler.profiles.panel.profile.should.not.be.empty=配置文件名称不应为空
scala.immutable.collection=不可变集合
scala.library.editor.form.compiler.bridge.jar=编译器桥\:
scala.library.editor.form.compiler.classpath=编译器类路径\:
scala.library.editor.form.scala.version=Scala 版本\:
scala.library.editor.form.standard.library=标准库\:
scala.line.markers=Scala 行标记
scala.meta.mode.disabled=已禁用
scala.meta.mode.enabled=已启用
scala.meta.mode.manual=手动
scala.mutable.collection=可变集合
scala.notification.group.id.features.advertiser=Scala 功能广播程序
scala.notification.group.id.general=Scala (常规)
scala.notification.group.id.java.to.scala.converter=Java 到 Scala 转换器
scala.notification.group.id.plugin.updater=Scala 插件更新程序
scala.notification.group.id.plugin.verifier=Scala 插件验证程序
scala.notification.group.id.sbt.project.import=SBT 项目导入
scala.notification.group.id.sbt.shell=SBT shell
scala.notification.group.id.scala3.disclaimer=Scala 3 免责声明
scala.notification.group.id.scalafmt=Scalafmt
scala.notification.group.id.scalafmt.fatal.errors=Scalafmt 致命错误
scala.notification.group.id.scalafmt.format.errors=Scalafmt 格式设置错误
scala.plugin.chanel.eap=抢先体验计划
scala.plugin.chanel.nightly=Nightly 版本
scala.plugin.chanel.release=稳定版本
scala.plugin.update=Scala 插件更新
scala.project.data.service.scalaLibraryNotFound=无法为模块 ''{0}'' 配置 Scala SDK (找不到模块 ''{0}'' 的项目 Scala 库 {1})
scala.project.settings=Scala 项目设置
scala.project.settings.form.add.override.keyword.to.method.implementation=向方法实现中添加重写关键字
scala.project.settings.form.ahead.of.time.completion=提前补全(形参和变量名称)
scala.project.settings.form.alias.definition=定义
scala.project.settings.form.alias.export=导出
scala.project.settings.form.alias.export.semantics=scala 和 scala.Predef 中的别名为\:
scala.project.settings.form.autocomplete=自动补全
scala.project.settings.form.automatically.convert.to.scala.code.without.dialog=粘贴时不显示对话框，并自动转换为 Scala 代码
scala.project.settings.form.base.package.custom=使用自定义\:
scala.project.settings.form.base.package.inherit=继承自源文件夹的软件包前缀
scala.project.settings.form.check.for.updates=立即检查
scala.project.settings.form.code.conversion=代码转换
scala.project.settings.form.collapse.long.output.by.default=默认收起长输出
scala.project.settings.form.collection.type.highlighting.option=集合类型高亮显示\:
scala.project.settings.form.convert.java.code.to.scala.on.copy.paste=复制粘贴时将 Java 代码转换为 Scala
scala.project.settings.form.custom.scalatest.keywords.highlighting=自定义 scalaTest 关键字高亮显示
scala.project.settings.form.delay.before.auto.run=自动运行前延迟\:
scala.project.settings.form.delay.before.auto.run.units=毫秒
scala.project.settings.form.disable.language.injection.in.scala.files=<html>禁用 Scala 文件中的语言注入。<br>(注入的语言可能会对自动弹出窗口补全冻结键入)</html>
scala.project.settings.form.disable.parsing.of.documentation.comments=<html>禁用文档注释解析。<br>对于极大的文件，可以提高编辑器性能。</html>
scala.project.settings.form.dont.cache.compound.types=不缓存复合类型(在 GC 中出现严重停顿的情况下使用)
scala.project.settings.form.error.highlighting=错误高亮显示
scala.project.settings.form.error.highlighting.use.compiler.ranges=使用 Scala 编译器报告的文本范围
scala.project.settings.form.group.package.object.with.package=使用软件包对软件包对象分组(&G)
scala.project.settings.form.highlight.arguments.to.by.name.parameters=高亮显示传名形参的实参
scala.project.settings.form.highlight.implicit.conversions=高亮显示隐式转换
scala.project.settings.form.highlight.nodes.with.errors=高亮显示有错误的节点(&H)
scala.project.settings.form.highlighting=高亮显示
scala.project.settings.form.implicit.parameters.search.depth=隐式形参搜索深度(若为无，则搜索深度为 -1)\:
scala.project.settings.form.include.block.expressions=包含块表达式
scala.project.settings.form.include.literals=包含文字
scala.project.settings.form.info=您可以始终选择“稳定版本”或“抢先体验计划”以还原为更稳定的版本。
scala.project.settings.form.output.cutoff.limit=输出截止限制\:
scala.project.settings.form.output.cutoff.limit.units=行
scala.project.settings.form.plugin.update.channel=更新通道\:
scala.project.settings.form.run.worksheet.in.the.compiler.process=在编译器过程中运行工作表(仅限普通模式)
scala.project.settings.form.sbt.index.ivy2.mode=本地 ivy2 缓存索引模式
scala.project.settings.form.sbt.index.ivy2.mode.hint=禁用 - 完全无索引\n元数据 - 仅索引库名称和版本，用于 SBT 文件依赖项补全\n类 - 也索引缓存中的类名，由“添加 sbt 依赖项”快速修复使用
scala.project.settings.form.scala.meta.settings.annot212=执行 scala.meta 程序
scala.project.settings.form.scala.meta.settings.annot212.tooltip=由于二进制文件不兼容，2.12 模块中的注解必须使用基于字符串的非常缓慢的序列化和重新解析。这可能会严重影响整体性能。
scala.project.settings.form.scala.meta.settings.modeOptions.tooltip=已启用 - 在类型推断期间执行所有元程序\n已禁用 - 在类型推断期间跳过元程序\n手动 - 仅在手动扩展时运行元程序
scala.project.settings.form.scala.meta.settings.trimBodies.caption=修剪方法体由 scala.meta 扩展
scala.project.settings.form.scala.meta.settings.trimBodies.tooltip=依赖所生成方法的显式返回值类型(主体替换为 ???)。通过跳过方法体类型检查可加快类型推断。
scala.project.settings.form.scalatest.default.super.class=ScalaTest 默认超类\:
scala.project.settings.form.search.all.symbols=搜索所有符号(包括局部符号)
scala.project.settings.form.show.hints.if.ambiguous.implicit.arguments.found=找到模糊的隐式实参时显示提示
scala.project.settings.form.show.hints.if.no.implicit.arguments.found=找不到隐式实参时显示提示
scala.project.settings.form.show.type.mismatch.hints=显示类型不匹配的提示
scala.project.settings.form.tabs.base.package=基础软件包
scala.project.settings.form.tabs.base.packages=基础软件包
scala.project.settings.form.tabs.editor=编辑器
scala.project.settings.form.tabs.extensions=扩展
scala.project.settings.form.tabs.misc=杂项
scala.project.settings.form.tabs.performance=性能
scala.project.settings.form.tabs.project.view=项目视图
scala.project.settings.form.tabs.updates=更新
scala.project.settings.form.tabs.worksheet=工作表
scala.project.settings.form.tabs.xray.mode=透视模式
scala.project.settings.form.trailing.commas=尾随逗号\:
scala.project.settings.form.treat.sc.files.as=将 .sc 文件视为\:
scala.project.settings.form.treat.scala.scratch.files.as.worksheet.files=将 Scala 临时文件视为工作表文件
scala.project.settings.form.use.eclipse.compatibility.mode=使用“eclipse 兼容”模式
scala.project.settings.form.use.scala.classes.priority.over.java=Scala 类的使用优先级高于 Java 类
scala.project.settings.form.xray.activate=激活条件\:
scala.project.settings.form.xray.by-name.argument.hints=按名称实参提示
scala.project.settings.form.xray.double.press.and.hold=按两次 Ctrl 并按住
scala.project.settings.form.xray.implicit.hints=隐式提示
scala.project.settings.form.xray.indent.guides=缩进参考线
scala.project.settings.form.xray.lambda.parameters=Lambda 形参
scala.project.settings.form.xray.lambda.placeholders=Lambda 占位符
scala.project.settings.form.xray.local.variables=局部变量
scala.project.settings.form.xray.member.variables=成员变量
scala.project.settings.form.xray.method.chain.hints=方法链提示
scala.project.settings.form.xray.method.results=方法结果
scala.project.settings.form.xray.method.separators=方法分隔符
scala.project.settings.form.xray.parameter.name.hints=形参名称提示
scala.project.settings.form.xray.press.and.hold=按 Ctrl 并按住
scala.project.settings.form.xray.show=显示\:
scala.project.settings.form.xray.type.hints=类型提示\:
scala.project.settings.form.xray.variable.patterns=变量模式
scala.project.settings.form.xray.widget=微件\:
scala.project.settings.form.xray.widget.display=显示\:
scala.root.code.style.panel.formatter=格式化程序\:
scala.sdk.component.name.compiler.classpath=编译器类路径
scala.sdk.component.name.library=库
scala.sdk.component.name.library.scaladoc=库 scaladoc
scala.sdk.component.name.library.source=库源代码
scala.sdk.descriptor.contains.duplicated.files=Scala SDK 描述符包含重复的 {0} 文件\:
scala.sdk.selection.button.browse=浏览…
scala.sdk.selection.button.download=下载…
scala.type.aware.highlighting.indicator=Scala 类型感知高亮显示指示器
scala3.panel.title=Scala 3
scala3.panel.use.indentation.based.syntax=使用基于缩进的语法
scaladoc.noon=Scaladoc
scaladoc.panel.add.additional.space.for.leading.asterisk=为前导星号添加额外空格
scaladoc.panel.after.parameter.comments=在形参描述后
scaladoc.panel.after.tags=return 之后
scaladoc.panel.align.other.tags.descriptions=对齐其他标记描述
scaladoc.panel.align.parameter.descriptions=对齐形参描述
scaladoc.panel.align.return.value.description=对齐返回值描述
scaladoc.panel.align.throws.exception.descriptions=对齐抛出异常描述
scaladoc.panel.before.parameter.descriptions=在形参描述前面
scaladoc.panel.before.tags=标记之前
scaladoc.panel.between.parameter.descriptions=在形参描述之间
scaladoc.panel.blank.lines.keep=保留(不移除标记之间的空白行)
scaladoc.panel.enable.scaladoc.formatting=启用 scaladoc 格式化
scaladoc.panel.groups.alignment=对齐
scaladoc.panel.groups.blank.lines=空行
scaladoc.panel.groups.other=其他
scaladoc.panel.preserve.spaces.in.tags=保留标记中的空格
scaladoc.panel.title=ScalaDoc
scaladoc.parsing.closing.code.tag.before.opening=结束代码标记在起始代码标记前面
scaladoc.parsing.closing.link.tag.before.opening=结束链接标记在起始链接标记前面
scaladoc.parsing.cross.tags=交叉标记
scaladoc.parsing.error.bad.token=错误\: 错误令牌\: {0}
scaladoc.parsing.header.closed.by.opening.new.one=标头由起始新标头结束
scaladoc.parsing.inline.tag=内联标记
scaladoc.parsing.missing.tag.param=缺少标记形参
scaladoc.parsing.no.closing.element=无结束元素
scaladoc.parsing.open.syntax.element=打开语法元素
scaladoc.parsing.unclosed.code.tag=未结束的代码标记
scaladoc.parsing.unexpected.end.of.tag.body=标记主体意外结束
scaladoc.parsing.unknown.tag=未知标记\: {0}
scaladoc.parsing.wiki.syntax.closed.by.inner.code.tag=内部代码标记
scaladoc.parsing.wiki.syntax.closed.by.new.paragraph=新段落
scaladoc.parsing.wiki.syntax.closed.by.tag=标记
scaladoc.parsing.wiki.syntax.element.closed.by.message=Wiki 语法元素由 {0} 结束
scalafmt.can.not.create.config.file=无法创建配置文件
scalafmt.can.not.find.config.file=找不到配置文件\: {0}
scalafmt.can.not.find.config.file.create.new=创建新文件
scalafmt.can.not.find.config.file.go.to.settings=设置…
scalafmt.config.load.actions.open.config.file=打开配置文件
scalafmt.config.load.errors.cyclic.includes.detected=检测到循环 include
scalafmt.config.load.errors.failed.to.load.config=无法加载 scalafmt 配置
scalafmt.config.load.errors.parse.error=解析错误\: {0}
scalafmt.default=默认
scalafmt.default.path=默认\: {0}
scalafmt.download=下载
scalafmt.format.errors.failed.to.find.correct.surrounding.code=Scalafmt 错误({0})\: <br>找不到要为 scalafmt 传递的正确的包围代码，不会执行格式化
scalafmt.format.errors.scala.file.parse.error=Scalafmt 解析错误({0})\:<br>{1}
scalafmt.picked.new.config=Scalafmt 选择了新样式配置(v{0})
scalafmt.progress.downloading.scalafmt.version=正在下载 scalafmt 版本 {0}
scalafmt.progress.downloading.scalafmt.version.cancel=停止下载
scalafmt.progress.resolving.scalafmt.version=正在解析 scalafmt 版本 {0}
scalafmt.progress.resolving.scalafmt.version.cancel=停止解析
scalafmt.progress.version.was.downloaded=已下载 Scalafmt 版本 {0}
scalafmt.resolve.again=再次解析
scalafmt.resolve.errors.cant.resolve.scalafmt.version=无法解析 scalafmt 版本 {0}
scalafmt.resolve.errors.classpath.is.corrupted=类路径损坏
scalafmt.resolve.errors.download.is.in.progress=正在下载
scalafmt.resolve.errors.downloading.error.occurred=下载时出错
scalafmt.resolve.errors.unknown.error=未知错误
scalafmt.resolve.errors.version.is.not.downloaded.yet=尚未下载 Scalafmt 版本 `{0}`。<br>要下载吗?
scalafmt.settings.panel.configuration.label=配置
scalafmt.settings.panel.errors.cant.find.config.file=找不到具有以下路径的 scalafmt 配置文件\:<br> {0}
scalafmt.settings.panel.errors.cant.resolve.version=无法解析 scalafmt 版本 {0}
scalafmt.settings.panel.errors.failed.to.parse.config=无法解析配置\:<br> {0}
scalafmt.settings.panel.fallback.to.default.settings=回退到默认 IntelliJ 设置
scalafmt.settings.panel.no.config.found.under.path.using.default=未在指定路径下找到配置文件
scalafmt.settings.panel.reformat.on.file.save=保存时重新格式化({0})
scalafmt.settings.panel.reformat.on.file.save.tooltip=提示\: 使用“重新格式化代码”({0})
scalafmt.settings.panel.scalafmt.version.label=Scalafmt 版本
scalafmt.settings.panel.select.custom.scalafmt.configuration.file=选择自定义 scalafmt 配置文件
scalafmt.settings.panel.show.warnings.when.formatting.invalid.code=在尝试格式化无效代码时显示警告
scalafmt.settings.panel.use.intellij.formatter.for.code.range.formatting=使用 IntelliJ 格式化程序进行代码范围格式化
scalafmt.settings.panel.use.intellij.formatter.for.code.range.formatting.warning.tooltip=使用 Scalafmt 格式化代码范围可能导致代码不一致。<br>Scalafmt 设计为仅格式化包含 scala 代码的整个文件
scalafmt.suggester.detected.in.project=在此项目中检测到了 Scalafmt 配置，是否启用 scalafmt 格式化程序?
scalafmt.suggester.dont.show=不显示
scalafmt.suggester.enable=启用
scope.file=文件
scope.selection=选区
script.file.mode.always.ammonite=始终选择 Ammonite
script.file.mode.always.worksheet=始终为工作表
script.file.mode.ammonite.in.test.sources.otherwise.worksheet=测试源代码中的 Ammonite，否则为工作表
scrutinee.incompatible.pattern.type=Scrutinee 与模式类型不兼容，实际为 {0}，要求 {1}
sdk.create.select.files=选择适用于新 Scala SDK 的 JAR
sdk.notification.provider.no.scala.sdk.in.module=模块中没有 Scala SDK
sdk.notification.provider.setup.scala.sdk=设置 Scala SDK
sdk.scan.title=正在定位 Scala SDK\: {0}
sdk.table.model.docs=文档
sdk.table.model.location=位置
sdk.table.model.sources=源代码
sdk.table.model.version=版本
sdkman=SDKMAN\!
sealed.modifier.is.not.allowed.here=此处不允许使用 ''sealed'' 修饰符
searching.for.overriding.members=正在搜索重写成员
select.library.from.the.list.above=从以上列表中选择库
select.method.implement=选择要实现的成员
select.method.override=选择要重写的成员
selected.file.is.not.a.valid.jar.file=所选文件不是有效的 jar 文件
semi.expected=应为 '';'' 或换行符
semicolon.not.allowed.here=此处不允许使用分号
show.implicit.arguments.action.description=显示隐式实参
show.implicit.arguments.action.text=显示隐式实参
simple.pattern.expected=简单模式的起始非法
spaces.panel.after.colon.before.declarations.type=冒号后面，声明的类型前面
spaces.panel.around.at.in.pattern.bindings=模式绑定中的 ''@'' 周围
spaces.panel.before.colon.after.declarations.name=冒号前面，声明的名称后面
spaces.panel.before.context.bound.colon.leading=在上下文边界冒号前面(前导)
spaces.panel.before.context.bound.colon.leading.higher.kinded=在上下文边界冒号前面(前导高阶)
spaces.panel.before.context.bound.colon.rest=在上下文边界冒号前面(剩余)
spaces.panel.before.opening.square.bracket=在左中括号前面
spaces.panel.constructor.parameters.with.modifiers=带修饰符的构造函数形参
spaces.panel.import.braces=导入大括号
spaces.panel.infix.method.call.parentheses=中缀方法调用圆括号
spaces.panel.infix.method.parentheses=中缀方法圆括号
spaces.panel.infix.operator.like.method.call.parentheses=类似于中缀运算符的方法调用圆括号
spaces.panel.inside.closure.braces=右大括号内
spaces.panel.keep.one.line.comments.on.same.line=在同一行中保留一行注释
spaces.panel.method.call.left.brace=方法调用左大括号
spaces.panel.newline.after.annotations=在注解后面换行
spaces.panel.preserve.space.before.method.parentheses=保留方法圆括号前面的空格
spaces.panel.self.type.braces=自类型大括号
spaces.panel.simple.one.line.block.braces=简单的单行块大括号
specify.result.type=指定结果类型
specify.return.type.explicitly=指定类型(&T)
specify.type.of.exception=指定异常类型
stable.identifier.required=需要稳定的标识符，但找到的是 {0}
string.literal.invalid.escape.character=无效的转义字符
string.literal.invalid.unicode.escape=无效的 unicode 转义
string.literal.is.too.long=字符串文字大小超出编译器限制
subscript.surrounder.template.description=下标\: ,, ,,
suitable.method.not.found=找不到适合的方法
super.reference.used.in.extracted.member=提取的成员 {0} 引用了 super 成员，但提取的特征不会有基类
superscript.surrounder.template.description=上标\: ^ ^
support.back.references.in.shared.sources=支持共享资源中的反向引用(实验性)(&S)
support.back.references.in.shared.sources.tooltip=启用此设置后，IntelliJ 将能够处理从共享源模块<br>对依赖模块中的声明的引用
suspicious.forward.reference.template.body=类中的可疑前向引用
symbol.is.inaccessible.from.this.place=无法从此处访问符号 {0}
symbolliterals.are.deprecated=Scala 2.13 中已弃用符号文字。请改用 Symbol("{0}")。
system.wide.scala=系统范围 Scala
target.0.already.contains.definition.of.1=<b>{0}</b> 已包含成员 <b>{1}</b> 的定义
this.is.not.a.valid.scala.qualified.name=这不是有效的 Scala 限定名称
title.choose.implicit.conversion.method=选择隐式转换方法\:
title.download=下载
title.error.downloading.scala.libraries=下载 Scala 库时出错
title.expressions=表达式
title.extensions.available=可用的扩展
title.failed.to.load.extension.jar=无法加载扩展 JAR
title.fetching.available.this.versions=正在提取可用的 {0} 版本
title.problem.opening.web.page=打开网页时出现问题
title.scala.sdk.files=Scala SDK 文件
title.searching.for.library.extensions=正在搜索库表达式
to.import.method.statically.press.hotkey=要静态导入方法，请按 {0}
toggle.type.aware.highlighting.menu.action.description=切换类型感知高亮显示
toggle.type.aware.highlighting.menu.action.text=切换类型感知高亮显示
too.many.type.arguments.for.typeparamowner={0}的类型实参过多，应为 {1} 个，实际为 {2} 个
topic.parameters.may.not.be.call.by.name={0} 形参可能不是传名调用
trailing.comma.panel.add.when.multiline=多行时添加
trailing.comma.panel.keep=保留
trailing.comma.panel.remove.when.multiline=多行时移除
trailing.comma.panel.scope.arguments.list=实参列表
trailing.comma.panel.scope.import.selector=import 选择器
trailing.comma.panel.scope.parameters.list=形参列表
trailing.comma.panel.scope.pattern.arguments.list=模式实参列表
trailing.comma.panel.scope.tuple=元组
trailing.comma.panel.scope.tuple.type=元组类型
trailing.comma.panel.scope.type.parameters.list=类型形参列表
trailing.comma.panel.title=尾随逗号
trailing.commas.mode.auto=自动
trailing.commas.mode.disabled=已禁用
trailing.commas.mode.enabled=已启用
trailing.underscore.separator=不允许使用尾随的下划线分隔符
trait.has.implementations=混合到
trait.has.several.implementations=混合到 {0} 类中
trait.is.already.implemented.by.superclass=特征 {0} 已由超类 {1} 实现，不能再次调用其构造函数
trait.may.not.call.constructor=特征 {0} 不能调用 {1} 的构造函数
trait.parameter.require.scala3=特征形参需要使用 Scala 3.0
traits.cannot.have.type.parameters.with.context.bounds=特征不能具有包含上下文边界的类型形参
traits.cannot.have.type.parameters.with.view.bounds=特征不能具有包含视图边界的类型形参
transparent.method.must.be.inline=关键字 `transparent` 只能用于内联方法
tree.mismatch.tooltip=<html><body>{0}<table><tr><td>要求 </td>{1}</tr><tr><td>实际\: </td>{2}</tr></table></body></html>
try.block=try 块
type.annotations.panel.accidental.structural.type=意外结构类型
type.annotations.panel.accidental.structural.type.tooltip=<html>强制对值执行类型注解，它们具有推断的结构类型，例如<br>\n<pre><code>\nval foo \= Runnable {\n  override def run()\: Unit \= ()\n  def helper()\: Unit \= ()\n} // foo 具有推断类型 Runnable { def helper()\: Unit } \n</code></pre></html>
type.annotations.panel.annotated.with=注解方式\:
type.annotations.panel.annotations=注解
type.annotations.panel.classes=类
type.annotations.panel.constant.final.val=常量(final val)
type.annotations.panel.enforce.for=对以下对象实施
type.annotations.panel.except.when=以下情况除外
type.annotations.panel.function.literal.parameter=函数文字形参
type.annotations.panel.implicit.definition=隐式定义
type.annotations.panel.in.scala.dialect.sources=在 Scala 方言源代码中
type.annotations.panel.in.scala.dialect.sources.tooltip=*.sbt、*.sc 等
type.annotations.panel.in.test.sources=测试源代码中
type.annotations.panel.local.definition=本地定义
type.annotations.panel.member.of=成员上级\:
type.annotations.panel.member.of.anonymous.class=匿名类的成员
type.annotations.panel.member.of.private.class=私有类的成员
type.annotations.panel.private.member=private 成员
type.annotations.panel.protected.member=protected 成员
type.annotations.panel.public.member=public 成员
type.annotations.panel.title=类型注解
type.annotations.panel.type.is.stable=类型稳定
type.annotations.panel.type.is.stable.tooltip=<html><body>当右侧为\:<br> 文字\: <code>123</code>、<code>"string"</code> 等( <code>null</code> 除外)<br> Unit 表达式\: <code>()</code><br> 对象创建\: <code>new Foo(...)</code> (包含细化的除外\: <code>new Foo() {}</code>)<br> 工厂方法调用\: <code>Foo(...)</code> (遇到伴生对象时调用 <code>apply(...)</code>)<br> 空集合\: <code>Seq.empty[Int]</code>、<code>Map.empty[Int, String]</code> 等。<br> Java 枚举常量\: <code>Enum.VALUE</code><br> 异常\: <code>throw Exception()</code> </body></html>
type.annotations.panel.type.matches=类型匹配\:
type.annotations.panel.type.patterns=类型模式
type.annotations.panel.underscore.parameter=为形参加下划线
type.annotations.panel.unit.type=Unit 类型
type.annotations.panel.use.for=用于
type.arg.does.not.conform.to.lower.bound=类型 {0} 不符合类型形参 {2} 的下界 {1}
type.arg.does.not.conform.to.upper.bound=类型 {0} 不符合类型形参 {2} 的上界 {1}
type.aware.highlighting.title=Scala 类型感知高亮显示
type.cannot.be.used.in.type.pattern=类型 {0} 不能在类型模式或 isInstanceOf 测试中使用
type.checker.built.in=内置
type.checker.compiler=编译器
type.checker.help=<html><strong>内置</strong>\: 更多功能，更快的反馈，轻量化。发现复杂代码中可能的虚假错误。<br><br><strong>编译器</strong>\: 更精确。更慢，使用更多资源，但不支持类型差异、快速修复、检查等功能。<br><br>除非特定代码库中有许多虚假错误，否则建议使用内置类型检查器。</html>
type.checker.label.scala2=Scala 2\:
type.checker.label.scala3=Scala 3\:
type.constructor.does.not.conform=类型构造函数 {0} 不符合 {1}
type.constructor.mismatch=类型构造函数不匹配。
type.expected=应为类型
type.info.description=显示类型信息
type.info.text=类型信息
type.is.not.a.valid.result.type.of.an.unapply.method={0} 不是 unapply 方法的有效结果类型
type.is.not.a.valid.result.type.of.an.unapplyseq.method={0} 不是 unapplySeq 方法的有效结果类型
type.lambda.expected=应为 ''\=>>''
type.mismatch.default.args.expected.actual=类型不匹配涉及默认实参，应为\: {0}，实际为\: {1}
type.mismatch.dot=类型不匹配。
type.mismatch.expected=类型不匹配，应为 {0}，实际为 {1}
type.mismatch.expected.actual=类型不匹配，应为 {0}，实际为 {1}
type.mismatch.found.required=类型不匹配，实际为 {0}，要求 {1}
type.mismatch.hint.context.menu.configure=配置类型不匹配提示…
type.mismatch.message=类型不匹配。要求 {0}， 实际为 {1}
type.parameter.value.class.may.not.be.specialized=值类的类型形参可能没有专用化
type.parameters.for.self.type.not.supported=提取的特征将以 {0} 作为自类型，但不支持识别其类型形参
type.takes.type.parameters=类型 {0} 接受类型形参
typed.statement.is.not.complete.for.underscore.section=下划线部分的类型化语句不完整
unbound.placeholder.parameter=未绑定的占位符形参
unchecked.warnings=未检查的警告(&U)
unchecked.warnings.tooltip=生成的代码取决于假设时，启用其他警告。
underline.surrounder.template.description=下划线\: __ __
unknown.exception=未知异常\: {0}
unknown.extraction=未知提取
unknown.macro.in.type.position=类型位置中的宏未知
unknown.resolve.issues=未知的解析问题\: {0}
unknown.type=<未知>
unreachable.error=发现意外错误
unresolved.artifact=未解析的工件\: {0}
unspecified.type.parameters=未指定的类型形参\: {0}
unwrap.case.clause=解包 case 子句
unwrap.finally=解包 finally
unwrap.interpolated.string.injection=解包插值字符串注入
unwrap.try.with.finally=解包 try / finally
updating.of.usages.of.generated.unapply=不支持对生成的 `unapply` 方法的用法进行更新
upgrade.to.interpolated=键入 '${' 后，将简单字符串升级为插值字符串
usage.access.modifier=访问修饰符
usage.extractor=提取程序
usage.function.expression=函数表达式
usage.implicit.conversion.parameter=隐式转换/形参
usage.interpolated.string.prefix=插值字符串前缀
usage.method.apply=`apply` 方法
usage.named.parameter=命名形参
usage.package.clause=软件包子句
usage.parameter.in.pattern=模式中的形参
usage.sam.interface.implementation=SAM 接口实现
usage.secondary.constructor=辅助构造函数
usage.self.type=自类型
usage.this.reference=This 引用
usage.type.alias=类型别名
usage.type.bound=类型绑定
usage.typed.pattern=类型化模式
usage.typed.statement=类型化语句
usage.unresolved.implicit.conversion.parameter=未解析的隐式转换/形参
use.compiler.ranges.help=<html><strong>适用于 Scala 3 项目，并且当错误高亮显示设置为“编译器”时。</strong><br><br>启用后，会将 Scala 编译器报告的文本范围用于高亮显示编辑器中的代码。这可能会导致针对给定的编译错误高亮显示较大的文本范围。<br><br>禁用后，会在编辑器中针对给定的编译错误高亮显示较小的文本范围。</html>
using.parameter.clause.expected=应为 ''using'' 形参子句
val.name=val {0}
val.on.case.class.param.redundant=对于 case 类主构造函数的形参而言，''val'' 修饰符冗余
val.or.var.can.only.be.used.in.class.parameters=''{0}'' 仅可在类形参中使用
val.var.expected=应为 val 或 var 关键字
value.class.can.have.only.one.parameter=值类只能有一个形参
value.class.can.have.only.val.parameter=值类只能有一个非私有 val 形参
value.classes.can.have.only.defs=值类中不允许字段定义
value.classes.cannot.have.nested.objects=值类不能有嵌套的类、对象或特征
value.classes.cannot.redefine.equals.hashcode=值类无法重新定义 equals 和 hashCode
value.classes.may.not.be.member.of.another.class=值类不得为另一个类的成员
var.cannot.be.overridden=不能重写可变变量
var.cannot.override.val=变量 {0} 无法重写不可变值
var.name=var {0}
vararg.pattern.must.be.last.pattern=_* 仅可用于最后一个实参
vararg.pattern.with.at.deprecated.since.scala3=vararg 模式中的 ''@'' 语法自 Scala 3.0 起已弃用
vararg.pattern.with.colon.requires.scala3=vararg 模式中的 ''\:'' 语法需要使用 Scala 3.0
variable.names=变量名称\: {0}
variance.annotation.not.allowed=此处不允许差异注解
variance.bivariant=双变
variance.contravariant=逆变
variance.covariant=协变
variance.invariant=不变
view.bounds.not.allowed=此处不允许视图边界
while.expected=''do'' 语句中应有 while 关键字
while.statement=while 语句
wrap.in.option.hint=使用 Option(...) 包装表达式?
wrap.in.option.name=使用 Option 包装
wrap.single.expression.body=键入 '{' 后，使用右大括号包装单个表达式主体
wrapping.and.braces.panel.align.if.else.statements=对齐 if-else 语句
wrapping.and.braces.panel.align.in.columns.case.branches=对齐列 ''case'' 分支
wrapping.and.braces.panel.align.multiline.pattern.alternatives=对齐多行模式替代项
wrapping.and.braces.panel.align.parameter.types.in.multiline.declarations=多行时对齐形参类型
wrapping.and.braces.panel.align.tuple.elements=对齐元组元素
wrapping.and.braces.panel.do.not.align.block.expression.parameters=不对齐块表达式形参
wrapping.and.braces.panel.do.not.indent.case.clause.body=不缩进 case 子句体
wrapping.and.braces.panel.do.not.indent.tuples.closing.parenthesis=不缩进元组右圆括号
wrapping.and.braces.panel.extends.align.to.extends=对齐 ''extends''
wrapping.and.braces.panel.extends.do.not.align=不对齐
wrapping.and.braces.panel.extends.on.first.token=在第一个令牌上
wrapping.and.braces.panel.for.indent.yield.after.one.line.enumerators=缩进单行枚举器后面的 yield
wrapping.and.braces.panel.force.braces=强制使用大括号
wrapping.and.braces.panel.force.case.branch.braces=强制使用 ''case'' 分支大括号
wrapping.and.braces.panel.force.finally.braces=强制 ''finally'' 大括号
wrapping.and.braces.panel.force.try.braces=强制使用 ''try'' 大括号
wrapping.and.braces.panel.groups.anonymous.method.definition=匿名方法定义
wrapping.and.braces.panel.groups.class.definition=类定义
wrapping.and.braces.panel.groups.method.definition=方法定义
wrapping.and.braces.panel.groups.tuple=元组
wrapping.and.braces.panel.groups.type.arguments=类型实参
wrapping.and.braces.panel.groups.type.parameters=类型形参
wrapping.and.braces.panel.groups.xml.formatting=XML 格式化
wrapping.and.braces.panel.indent=缩进
wrapping.and.braces.panel.indent.braced.arguments=缩进带大括号的实参
wrapping.and.braces.panel.indent.first.parameter.clause.if.on.new.line=遇到新行时缩进第一个形参子句
wrapping.and.braces.panel.indent.first.parameter.if.on.new.line=遇到新行时缩进第一个形参
wrapping.and.braces.panel.keep.xml.formatting=保持 xml 格式化
wrapping.and.braces.panel.match.statement=''match'' 语句
wrapping.and.braces.panel.new.line.options.new.line.always=始终换行
wrapping.and.braces.panel.new.line.options.new.line.for.multiple.arguments=对多行实参换行
wrapping.and.braces.panel.new.line.options.no.new.line=不换行
wrapping.and.braces.panel.parameters.on.new.line=新行中的形参
wrapping.and.braces.panel.place.self.type.on.new.line=将自类型置于新行中
wrapping.and.braces.panel.renamed.extends.keyword=extends 关键字
wrapping.and.braces.panel.renamed.extends.with.list=extends/with 列表
wrapping.and.braces.panel.renamed.force.yield.braces=强制使用 yield 大括号
wrapping.and.braces.panel.renamed.infix.expressions=中缀表达式
wrapping.and.braces.panel.simple.one.line.lambdas.in.arg.list=实参列表中简单的单行 lambda
wrapping.and.braces.panel.use.normal.indent.for.parameters=对形参使用标准缩进
wrapping.and.braces.panel.wrap.before.with.keyword=在 ''with'' 关键字前换行
wrong.annotation.expression=错误的注解表达式
wrong.binding=错误形参
wrong.case.modifier=错误的 case 修饰符。将它用于类或对象
wrong.constr.expression=错误的构造函数表达式
wrong.declaration.in.block=块不能包含声明
wrong.existential.declaration=错误的存在声明。它必须是类型声明或值声明
wrong.expression=错误的表达式
wrong.number.arguments.extractor=提取程序的实参数量错误，实际为 {0} 个，应为 {1} 个
wrong.number.arguments.extractor.unapplySeq=提取程序的实参数量错误，实际为 {0} 个，应为 {1} 个或更多
wrong.parameter=错误形参
wrong.pattern=错误模式
wrong.postfix.expression=错误的后缀表达式
wrong.psi.for.literal.type="用于获取文字类型的元素错误"
wrong.qual.identifier=错误的限定标识符
wrong.string.literal=字符串文字错误
wrong.stub.problem=错误的存根问题
wrong.top.statement.declaration=错误的顶部语句声明
wrong.type=错误类型
wrong.type.associativity=错误的关联性。所有运算符应有相同的关联性
wrong.type.element=错误的类型元素
wrong.type.no.literal.types=错误的类型 `{0}`，使用 Scala 2.13 或带有 `-Yliteral-types` 编译器标志的 Typelevel Scala 来支持文字类型
wrong.val.declaration=错误的值声明
wrong.var.declaration=错误的变量声明
xml.PI.end.expected=应为 xml 处理指令结尾
xml.attribute.end.expected=应为 xml 特性值结束分隔符
xml.attribute.value.expected=应为特性值
xml.cdata.end.expected=应为 xml CData 结尾
xml.comment.end.expected=应为 xml 注释结束 (''-->'')
xml.delete.unmatched.tag=删除不匹配的标记
xml.end.tag.expected=应为 xml 结束标记(''</'' name '>')
xml.eq.expected=应为 ''\=''
xml.name.expected=应为 xml 标记名称
xml.no.closing.tag=无结束标记
xml.no.opening.tag=无起始标记
xml.rename.closing.tag=重命名结束标记
xml.rename.opening.tag=重命名起始标记
xml.scala.expression.expected=xml 注入中应有 Scala 表达式
xml.scala.injection.end.expected=应为 xml 中的 Scala 注入结尾('}')
xml.scala.patterns.expected=xml 注入中应有 Scala 模式
xml.tag.end.expected=应为 xml 标记结尾
xml.wrong.character=xml 注释中的错误字符

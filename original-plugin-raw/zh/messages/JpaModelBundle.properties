AddAttributeItem.attributeAlreadyExist.description=已在 {1} 实体中定义 {0} 特性
AddAttributeItem.attributeAlreadyExist.title={0} 特性已定义
AddAttributeItem.idAlreadyExist=主键已存在
AddAttributeItem.idAlreadyExistDescr=已在 {0} 实体中定义 ID 特性
AssociationType.JoinColumnMappedBy=双向 JoinColumn
AssociationType.JoinColumnUnidirectional=单向 JoinColumn
AssociationType.JoinTableMappedBy=双向 JoinTable
AssociationType.JoinTableMtM=单向 JoinTable
AssociationType.MappedByJoinColumn=双向 mappedBy
AssociationType.MappedByJoinTable=双向 mappedBy
AssociationType.WithoutJoinColumnOtM=单向 JoinTable
AttributeDeleteDialog.safeDeleteField=搜索用法
AttributeOverridesValidator.emptyName.errorMessage=提供特性名称以生成特性重写。
AttributeOverridesValidator.errorMessage=列名 {0} 在 {1} 实体中重复。
AttributePropertiesPanel.TableGeneratorName=生成器表
AttributePropertiesPanel.allocationSize=分配大小
AttributePropertiesPanel.asc=ASC
AttributePropertiesPanel.associationType=映射类型
AttributePropertiesPanel.associationType.hint.joinColumnMappedByUpdater={0}\#{1} 上的 @JoinColumn 和 {4}\#{5} 上的 @{2}(mappedBy\={3})
AttributePropertiesPanel.associationType.hint.joinColumnUpdater={0}\#{1} 上的 @JoinColumn
AttributePropertiesPanel.associationType.hint.joinTableMappedByUpdater={0}\#{1} 上的 @JoinTable 和 {4}\#{5} 上的 @{2}(mappedBy\={3})
AttributePropertiesPanel.associationType.hint.joinTableUpdater={0}\#{1} 上的 @JoinTable
AttributePropertiesPanel.associationType.hint.mappedByJoinColumnUpdater={0}\#{1} 上的 @{2}(mappedBy\={3}) 和 {4}\#{3} 上的 @JoinColumn
AttributePropertiesPanel.associationType.hint.mappedByJoinTableUpdater={0}\#{1} 上的 @{2}(mappedBy\={3}) 和 {4}\#{3} 上的 @JoinTable
AttributePropertiesPanel.associationType.hint.oneToManyWithoutJoinColumnUpdater={0}\#{1} 上的 @JoinTable
AttributePropertiesPanel.attributeExists=有一个名为“{0}”的继承特性
AttributePropertiesPanel.attributeOverrides=特性重写
AttributePropertiesPanel.cardinality=基数
AttributePropertiesPanel.cardinality.empty=请选择基数
AttributePropertiesPanel.cardinality.manyToMany=多对多
AttributePropertiesPanel.cardinality.manyToMany.hint=多个 ''{0}'' 对象与多个{1}对象关联
AttributePropertiesPanel.cardinality.manyToOne=多对一
AttributePropertiesPanel.cardinality.manyToOne.mandatoryHint=多个 ''{0}'' 对象与一个{1}对象关联
AttributePropertiesPanel.cardinality.manyToOne.nonMandatoryHint=多个 ''{0}'' 对象与零个或一个{1}对象关联
AttributePropertiesPanel.cardinality.oneToMany=一对多
AttributePropertiesPanel.cardinality.oneToMany.hint=一个 ''{0}'' 对象与多个{1}对象关联
AttributePropertiesPanel.cardinality.oneToOne=一对一
AttributePropertiesPanel.cardinality.oneToOne.mandatoryHint=一个 ''{0}'' 对象与一个{1}对象关联
AttributePropertiesPanel.cardinality.oneToOne.nonMandatoryHint=一个 ''{0}'' 对象与零个或一个{1}对象关联
AttributePropertiesPanel.cardinality.singleValue=单一值
AttributePropertiesPanel.cascade=级联类型
AttributePropertiesPanel.collection=集合
AttributePropertiesPanel.collectionTable=集合表
AttributePropertiesPanel.collectionTableJoinColumn=联接列
AttributePropertiesPanel.collectionType=集合类型
AttributePropertiesPanel.column=列
AttributePropertiesPanel.columnDefinition=列定义
AttributePropertiesPanel.conversionType=大小写转换
AttributePropertiesPanel.converter=转换器
AttributePropertiesPanel.createField=创建字段
AttributePropertiesPanel.createMappedAttribute=创建映射的特性
AttributePropertiesPanel.currencyValue=货币
AttributePropertiesPanel.ddl=列 DDL
AttributePropertiesPanel.decimalSep=小数分隔符
AttributePropertiesPanel.dependsOnProperties=相关特性
AttributePropertiesPanel.desc=DESC
AttributePropertiesPanel.disableUniqueField=无法创建唯一约束，因为实体已被软删除，但实体表中没有 'delete_ts' 列
AttributePropertiesPanel.elementCollection=元素集合
AttributePropertiesPanel.enterAttributeName=输入特性名称
AttributePropertiesPanel.enumType=枚举类型
AttributePropertiesPanel.errorIntPositive={0} 必须 > 0
AttributePropertiesPanel.errorPrecision=创建属性
AttributePropertiesPanel.errorPrecisionBiggerScale=精度必须大于或等于小数位数
AttributePropertiesPanel.errorScaleZero=小数位数必须 >\= 0
AttributePropertiesPanel.fetchMode=提取模式
AttributePropertiesPanel.fetchType=提取类型
AttributePropertiesPanel.fkConstraintAction=FK 约束操作
AttributePropertiesPanel.generateAttributeOverrides=生成特性重写
AttributePropertiesPanel.generateEqualsAndHashCode=生成 Equals 和 HashCode
AttributePropertiesPanel.generatedStrategy=ID 生成
AttributePropertiesPanel.generatorName=生成器名称
AttributePropertiesPanel.goTo=转到
AttributePropertiesPanel.groupSep=组分隔符
AttributePropertiesPanel.id=ID
AttributePropertiesPanel.idAttribute=ID 特性
AttributePropertiesPanel.indexColumns=列
AttributePropertiesPanel.indexName=名称
AttributePropertiesPanel.indexUnique=唯一
AttributePropertiesPanel.initialValue=初始值
AttributePropertiesPanel.insertable=可插入
AttributePropertiesPanel.inverseAttribute.msg=找不到合适的反向特性。是否要进行创建?
AttributePropertiesPanel.inverseAttribute.title=反向特性
AttributePropertiesPanel.inverseAttributeCreated=反向特性已创建，相关实体已保存
AttributePropertiesPanel.inverseJoinColumnLengthError={0} 上的<b>反向联接列</b>名称不得超过 {1} 个字符
AttributePropertiesPanel.inverseJoinColumnName=反向联接列
AttributePropertiesPanel.inverseJoinColumnReferencedColumnName=反向引用列
AttributePropertiesPanel.jdbcTypeCode=JDBC 类型代码
AttributePropertiesPanel.joinColumnLengthError={0} 上的<b>联接列</b>名称不得超过 {1} 个字符
AttributePropertiesPanel.joinColumnName=联接列
AttributePropertiesPanel.joinColumnReferencedColumnName=引用列
AttributePropertiesPanel.joinTable=联接表
AttributePropertiesPanel.joinTableLengthError={0} 上的<b>联接表</b>名称必须不超过 {1} 个字符
AttributePropertiesPanel.joinTableName=联接表
AttributePropertiesPanel.length=长度
AttributePropertiesPanel.lengthFieldUnlimited=无限制
AttributePropertiesPanel.lob=大型对象
AttributePropertiesPanel.lookupActions=查找操作
AttributePropertiesPanel.lookupType=查找类型
AttributePropertiesPanel.mandatory=强制
AttributePropertiesPanel.mappedBy=映射方式
AttributePropertiesPanel.mappingType=特性类型
AttributePropertiesPanel.mutable=可变
AttributePropertiesPanel.name=名称
AttributePropertiesPanel.newType=类型
AttributePropertiesPanel.numberFormat=数字格式
AttributePropertiesPanel.numberFormatExample=例如\: \#,\#\#\#,\#\#\#,\#\#\#.\#\#
AttributePropertiesPanel.numberFormatIsRequired=特性 ''{0}'' 需要“数字格式”字段
AttributePropertiesPanel.numberFormatStyle=数字格式样式
AttributePropertiesPanel.onDelete=删除时
AttributePropertiesPanel.onDelete.cascade.hint=删除 ''{0}'' 对象后，自动删除关联的{1}对象
AttributePropertiesPanel.onDelete.cascade.hintInverse=删除关联的{1}对象时自动删除 ''{0}'' 对象
AttributePropertiesPanel.onDelete.default.hint=删除 ''{0}'' 对象后，关联的{1}对象保持原样
AttributePropertiesPanel.onDelete.default.hintInverse=删除关联的{1}对象时，''{0}'' 对象保持原样
AttributePropertiesPanel.onDelete.deny.hint=如果 ''{0}'' 对象与{1}对象关联，则阻止删除该对象
AttributePropertiesPanel.onDelete.deny.hintInverse=阻止删除与 ''{0}'' 对象关联的{1}对象
AttributePropertiesPanel.onDelete.unlink.hint=删除 ''{0}'' 对象后，清除{1}对象的关联链接
AttributePropertiesPanel.onDelete.unlink.hintInverse=删除关联的{1}对象后，清除 ''{0}'' 对象的链接
AttributePropertiesPanel.onDeleteInverse=删除反向时
AttributePropertiesPanel.orderBy=排序方式
AttributePropertiesPanel.orderByExample=示例\: order.date DESC, name, age DESC
AttributePropertiesPanel.orphanRemoval=孤立项移除
AttributePropertiesPanel.owner=拥有方
AttributePropertiesPanel.persistAttrCreated=相关实体 ID 特性已创建
AttributePropertiesPanel.persistRelatedId.msg=您已创建对来自不同数据存储的实体的引用。是否要创建持久特性来存储相关实体 ID?
AttributePropertiesPanel.persistRelatedId.title=相关实体 ID 特性
AttributePropertiesPanel.precision=精度
AttributePropertiesPanel.readOnly=只读
AttributePropertiesPanel.renameAttribute=重命名特性
AttributePropertiesPanel.scale=小数位数
AttributePropertiesPanel.sequenceGeneratorName=序列名称
AttributePropertiesPanel.sequenceOrTableGeneratorName=序列名称
AttributePropertiesPanel.sequenceType=生成类型
AttributePropertiesPanel.smartRefactoring=智能重构
AttributePropertiesPanel.sort=排序
AttributePropertiesPanel.targetEntity=目标实体
AttributePropertiesPanel.temporalType=Temporal
AttributePropertiesPanel.timeZoneColumn=时区列类型
AttributePropertiesPanel.timeZoneStorageType=时区存储
AttributePropertiesPanel.transient=瞬时
AttributePropertiesPanel.transientCardinality=基数
AttributePropertiesPanel.transientWarning=该属性将被转换为 Transient，所有不兼容的注解将被移除。
AttributePropertiesPanel.type=类型
AttributePropertiesPanel.unique=唯一
AttributePropertiesPanel.updatable=可更新
AttributePropertiesPanel.version=版本
AttributePropertiesPanel.warning.caption=警告
AttributePropertiesPanel.warningMappedBy=关联“MANY_TO_MANY”的所有特性都不是拥有方。特性 {0}
AttributePropertiesPanel.warningOwningSide=关联的所有特性都不是拥有方。\n是否要使对方成为所有者?
AttributePropertiesPanel.warningRemovePropertyFromView=如果在更改特性类型后保存实体，该特性将从以下视图中移除\:
BasicRepositoryAttribute.Nullability.NonNull=NonNull
BasicRepositoryAttribute.Nullability.NotSet=-
BasicRepositoryAttribute.Nullability.Nullable=可为 null
CollectionDatatype.Collection=集合
CollectionDatatype.LinkedHashSet=LinkedHashSet
CollectionDatatype.Map=映射
CollectionDatatype.Set=设置
CreateAttributeWindow.addColumnToExistConstraintOrIndex=将列“{0}”添加到现有索引/约束
CreateAttributeWindow.chooseExistingIndex=选择现有索引/约束
CreateAttributeWindow.createConstraintByAttribute=按特性“{0}”创建约束
CreateAttributeWindow.createIndexByAttribute=按特性“{0}”创建索引
CreateAttributeWindow.createIndexOrConstraintByAttribute=按特性“{0}”的索引/约束
CreateAttributeWindow.createInverseAttribute=创建反向特性
CreateAttributeWindow.createInverseAttributeWithParams=创建反向特性 {0}
CreateAttributeWindow.createPersistRelatedIdAttribute=创建持久的相关 ID 特性
CreateAttributeWindow.indexesAndConstraints=索引和约束
CustomTypeEditorDialog.parametrized=形参化
DataSourceEditor.caption=数据库连接
DataSourceEditor.database.properties=数据库属性
DataStoreEditor.name=数据库连接名称\:
DataStoreEditor.nameEmpty=请输入数据库连接名称
Datastore.notification.provideCredentials=请提供数据库凭据
EntityCreator.write.command.create=创建
EntityPropertiesPanel.EmbeddedField=嵌入式类
EntityPropertiesPanel.IdField=ID
EntityPropertiesPanel.SequenceField=生成类型
EntityPropertiesPanel.addPersistenceUnit=添加到持久性
EntityPropertiesPanel.catalog=目录
EntityPropertiesPanel.changePackage=更改软件包
EntityPropertiesPanel.className=名称
EntityPropertiesPanel.createAttributeCaption=新建特性
EntityPropertiesPanel.createAttributeWithParametersCaption=新建 {0} 特性
EntityPropertiesPanel.discriminator=判别器值
EntityPropertiesPanel.discriminatorColumnName=判别器列
EntityPropertiesPanel.discriminatorLength=判别器长度
EntityPropertiesPanel.discriminatorType=判别器类型
EntityPropertiesPanel.entityType=实体类型
EntityPropertiesPanel.inheritanceType=继承
EntityPropertiesPanel.learnMore=了解详情…
EntityPropertiesPanel.name=实体名称
EntityPropertiesPanel.optimizations=建议的优化
EntityPropertiesPanel.optimizations.fix.generateEqualsAndHashCodeFix=生成 equals() 和 hashCode()
EntityPropertiesPanel.optimizations.fix.makeAttributeNotOwnerFix=将 mappedBy 与另一侧的 OneToMany 一起使用
EntityPropertiesPanel.optimizations.fix.setWithoutEqualsAndHashCodeInfo=集合类型为 ‘Set\\&lt;{0}\\&gt;’，但 ‘{0}’ 实体未实现 equals()/hashCode() 方法。\nSet 在底层使用这些方法，默认实现可能会导致实体比较出现问题。\n例如，使用不同 Hibernate 会话提取的具有相同 ID 的两个实体将不相等。
EntityPropertiesPanel.optimizations.fix.useJoinColumnTypeFix=添加 @JoinColumn 注解
EntityPropertiesPanel.optimizations.fix.useSetCollectionTypeFix=改用 Set<>
EntityPropertiesPanel.package=软件包
EntityPropertiesPanel.packageName=软件包
EntityPropertiesPanel.packageSelector.title=选择实体软件包
EntityPropertiesPanel.parent=父项
EntityPropertiesPanel.performance.manyToManyCollectionInfo=当 Collection 用于映射 ManyToMany 关联时，Hibernate 无法有效地从联接表中移除此类关联。\n相反，它会移除与拥有实体关联的所有记录并重新插入剩余记录。将集合类型更改为 Set 可以减少删除所需的查询数量。
EntityPropertiesPanel.performance.manyToManyListInfo=使用 List 来映射 ManyToMany 关联时，Hibernate 无法有效地从联接表中删除此类关联。
EntityPropertiesPanel.performance.oneToManyJoinColumnInfo=带有 @JoinColumn 的单向 OneToMany 可能会导致额外的查询。\n由于联接列不存在于引用的 JPA 实体中而仅存在于数据库中，Hibernate 会在单独的查询中更新它。\n使关联成为双向可以解决此问题。
EntityPropertiesPanel.performance.oneToManyJoinTableListInfo=带 @JoinTable 的单向 OneToMany 会引入一个新表，该表需要额外的 insert/delete 查询并占用空间。\n可以使用单个 @JoinColumn 表达相同的关联。
EntityPropertiesPanel.performanceWarning=此映射声明效率不高，可能会导致性能问题。
EntityPropertiesPanel.persistenceUnit=持久性单元
EntityPropertiesPanel.primaryKeyJoinColumnDefinition=PK 联接列定义
EntityPropertiesPanel.primaryKeyJoinColumnName=PK 联接列
EntityPropertiesPanel.referenceType=引用类型
EntityPropertiesPanel.renameClass=重命名类名
EntityPropertiesPanel.schema=架构
EntityPropertiesPanel.table=表
EntityPropertyPathReference.inspection.unresolvedMessagePattern=属性路径“{0}”对于实体类“{1}”无效
EntitySettingsWindow.jpb.title=新建实体
EntityType.EMBEDDABLE=可嵌入
EntityType.MAPPED_SUPERCLASS=映射的超类
EntityType.PERSISTENT=实体
ExistingAttributeNameValidator.errorMessage=具有相同名称的特性已存在
ExistingColumnNameValidator.attributeNameEqualsDiscriminatorColumn=列名称为 {0} 的特性等于类 {1} 的判别器列名
ExistingColumnNameValidator.discriminatorNameNotUnique=判别器列名 ''{0}'' 对于 ''{1}'' 实体不唯一
ExistingColumnNameValidator.errorMessageEmbedded=实体 {1} 有一个列名为 {0} 的嵌入式特性
ExistingColumnNameValidator.errorMessageInherited=存在列名为 {0} 的继承特性
ExistingColumnNameValidator.errorMessageNamed=列名为 {0} 的特性已存在
ExistingSequenceNameValidator.errorMessage=具有相同名称的序列已存在
HibernateCustomTypeDialog.title=创建自定义类型
HibernateCustomTypeDialog.type=类型
IndexesEditor.availableColumns.title=可用列
IndexesEditor.selectedColumns.title=所选列
IndexesEditor.validation.makeManyToOneFix=建立 {0} 多对一关联
IndexesEditor.validation.makeOneToOneFix=建立 {0} 一对一关联
JpaConverterEditorDialog.autoApply=自动应用
JpaConverterEditorDialog.dbType=数据库列类型
JpaConverterEditorDialog.entityType=实体特性类型
JpaPalette.createdDate=创建日期
JpaPalette.equalsAndHashCode=equals 和 hashCode
JpaPalette.toString=ToString
LombokPropertiesPanel.getter=Getter
LombokPropertiesPanel.isLombokAllArgsConstructor=AllArgsConstructor
LombokPropertiesPanel.isLombokBuilder=Builder
LombokPropertiesPanel.isLombokNoArgsConstructor=NoArgsConstructor
LombokPropertiesPanel.isLombokSuperBuilder=SuperBuilder
LombokPropertiesPanel.onlyExplicitlyIncluded=仅显式包含
LombokPropertiesPanel.setter=Setter
LombokPropertiesPanel.toString=ToString
LombokPropertiesPanel.toStringInclude=包含到 ToString 中
OrmStructurePanel.attributes=特性
OrmStructurePanel.persistenceUnits=持久性单元
OrmStructurePanel.referencedBy=引用者
OrmToolwindow.title=持久性
PersistenceUnitEditor.create.title=创建持久性单元
PersistenceUnitEditor.edit.title=编辑持久性单元
PersistenceUnitEditor.package.chooser.title=选择持久性单元软件包
PersistenceUnitEditor.select.entity=选择实体
PersistenceUnitEditor.validation.indexing=当索引编制正在进行时，无法完成
PersistenceUnitEditor.validation.name.empty=名称不应为空
PersistenceUnitEditor.validation.name.unique=名称应唯一
PersistenceUnitValidationDialog.proceed=继续
PersistenceUnitValidationDialog.title=空持久性单元
PrimitiveTypeValidator.errorMessage=类型不应为基元
ProjectPropertiesPage.connection=测试连接
ProjectPropertiesPage.connectionSuccessful=已成功连接到 ''{0}''
ProjectPropertiesPage.connectionTestCaption=测试
ProjectPropertiesPage.dbConnectionParams=连接参数
ProjectPropertiesPage.dbPassword=密码
ProjectPropertiesPage.dbPassword.showCheckBox=显示密码
ProjectPropertiesPage.dbType=数据库类型
ProjectPropertiesPage.dbUrl=数据库 URL
ProjectPropertiesPage.dbUser=数据库用户
ProjectPropertiesPage.emptyUrl=无法使用空 URL 进行连接
ProjectPropertiesPage.incorrectDbHost=无效的数据库主机值\: ''{0}''。\n主机必须仅类似于 localhost[\:port]。
ProjectPropertiesPage.integratedSecurity=集成安全性
ProjectPropertiesPage.integratedSecurityInstruction=<html>要使 MSSQL Integrated Security 正常工作\:<ol><li>下载 <a href\="{0}">Windows 身份验证库归档</a></li><li>将下载的 jar 文件解压到“{1}”目录</li><li>重启 IDEA</li></ol>
ProjectPropertiesPage.testConnection.title=正在建立连接
ProjectPropertiesPage.validation.empty=空值
RelatedAttributeRemover.attributeDeleted=特性 {0}.{1} 已被移除
RelatedAttributeRemover.dialogMessage=<html>实体 <b>{0}</b> 包含相关特性 <b>{1}</b>。是否将其移除?</html>
RelatedAttributeRemover.dialogTitle=相关特性移除
RepositoryAttribute.OperatorType.And=And
RepositoryAttribute.OperatorType.NotSet=-
RepositoryAttribute.OperatorType.Or=Or
RepositoryConditionType.EQUALS=Equals
RepositoryConditionType.ING_POSTFIX=-ing
RepositoryConditionType.IS=Is
RepositoryConditionType.IS_ING=Is + -ing
RepositoryConditionType.NONE=无
RepositoryConditionType.SIMPLE=简单
SerializableType.NoSerializable=非 Serializable
SerializableType.Serializable=Serializable
SerializableType.SerializableWithVersionUID=带版本 UID 的 Serializable
SubDtoType.EXIST_CLASS=现有类
SubDtoType.FLAT=扁平
SubDtoType.NEW_CLASS=新类
SubDtoType.NEW_NESTED_CLASS=新嵌套类
Validation.blankOrEmptyClassName=类名为空白或为空
Validation.converterExists=指定的软件包中已存在使用此名称的{0}
Validation.dtoExists=指定的软件包中已存在使用此名称的 DTO 类
Validation.embeddedRequired=字段嵌入式类为必需项
Validation.entityExists=指定的软件包中已存在使用此名称的实体
Validation.hibernateEventListener=指定的软件包中已存在使用此名称的 Hibernate 事件侦听器
Validation.indexColumns={0} 必须至少包含一列
Validation.indexExists=已存在使用此名称的{0}
Validation.invalidRepoEntityType=不支持嵌入式实体的仓库
Validation.language.null=未指定语言
Validation.mapperExists=指定的软件包中已存在使用此名称的 mapper
Validation.notQualifiedName=这不是有效的 Java 限定名称
Validation.notValidClassName=这不是有效的类名
Validation.notValidType=这不是有效的类型
Validation.package.empty=软件包名称不能为空
Validation.package.invalid=软件包名称只应包含数字、字母或下划线，并且不应以点结尾
Validation.projectionExists=指定的软件包中已存在使用此名称的投影
Validation.repositoryExists=指定的软件包中已存在使用此名称的仓库
Validation.repositoryExists.name=指定的软件包中已存在具有相同名称“{0}”的仓库
Validation.reservedName=这是 JPA 注解的保留名称
Validation.select.repository=选择至少一个仓库
ViewPropertiesPanel.collapseAll=全部收起
ViewPropertiesPanel.expandAll=全部展开
ViewPropertiesPanel.openInView=在持久性视图中选择
ViewPropertiesPanel.selectAll=全选
ViewPropertiesPanel.selectBasicAttributes=选择所有基本特性
ViewPropertiesPanel.showLibrariesClasses=显示库中的类
ViewPropertiesPanel.unselectAll=取消全选
action.OpenInOrmToolwindowAction.text=在持久性视图中选择
action.browse.text=浏览
action.ddl.sql.ddl=DDL
action.editor.and.preview.text=编辑器和预览
action.editor.text=编辑器
action.preview.text=预览
action.select.action.text=选择操作
action.text.open.settings=打开设置
actions=操作
add=添加
add.attributes.dto=将特性添加到 DTO
add.entity.attribute=添加实体特性
add.index=添加索引
add.lifecycle.callback.method=添加生存期回调方法
add.listener=添加侦听器
add.log=添加记录器
add.named.query=添加命名查询
add.order.by.attribute=添加按特性排序({0})
add.query.condition=添加查询条件({0})
add.spring.repos.derived.method=添加 Spring 仓库派生方法
add.spring.repos.query.method=添加 Spring 仓库查询方法
add.update.value.assignment=添加更新值赋值({0})
addAllArgs.fix=添加 @AllArgsConstructor 注解
addAllArgsAndNoArgs.fix=添加 @NoArgsConstructor 和 @AllArgsConstructor 注解
addConstructor.family=添加构造函数
addJpaConverterAnnotation.fix=添加 @Converter 注解
addModifyingAnnotation.fix=添加 @Modifying 注解
addModifyingAnnotation.fix.command=添加 @Modifying 注解
addNoArgs.fix=添加 @NoArgsConstructor 注解
addSimpleAllArgsConstructor.fix=将 {0} 全实参构造函数添加到 {1}
addSimpleConstructors.fix=将全实参和无实参构造函数添加到 {0}
additional.db.drivers=其他数据库驱动程序
additional.part.of.method.name=方法中缀
advanced=高级
aggregate.root=聚合根
all.args.constructor=全实参构造函数
all.args.constructor.and.mutable.unselect=DTO 必须有一个全实参构造函数或者为可变，否则无法设置其属性
all.ignore.case=全部忽略大小写
artifact.drivers.files.unload=无法加载驱动程序信息。请检查您的互联网连接。
assignJpaConverter.fix=指定 JPA 转换器/Hibernate 类型
async=异步
attribute=特性
attribute.comment.text=/*\n TODO [逆向工程]会创建字段来映射 ''{0}'' 列\n 可用操作\:
attribute.name=特性名称
attribute.type=特性类型
attributes.mapped.super.class=提取特性
audit.fields=审核字段
audit.type.validation=指定型的审核器类不正确
audited=已审核
auditing.entity.listener.not.found=<html>无法通过您的实体类检测到 AuditingEntityListener。如果未指定此侦听器或类似侦听器，则不会填充审核字段。 <a href\='\#ADD_IT'>添加 AuditingEntityListener</a> 或在使用自定义审核侦听器的情况下<a href\='\#HIDE_IT'>忽略此警告</a>。</html>
auditor.aware.inheritor.not.found.info=未检测到 AuditorAware{0} 的实现。您可以手动指定任何审核器类型并稍后创建相应的 AuditAware 实现。
auditor.type=审核器类型
blaze.persistence.entity.view=Blaze 持久性实体视图
calculation.of.structure.section=树部分 {0} 的计算持续时间为 {1} 秒
cancel=取消
cancel.selection=取消选择
cancel.selection.description=表的选择将被清除。<br>是否要继续?
caption=标题
cardinality=基数
cascade.remove.warning=CascadeType.REMOVE 最终删除的内容可能会超出预期
cast.event.entity=应用于实体
choose.attribute=选择特性
choose.class=选择类
choose.hibernate.entity=选择实体
choose.hibernate.event.listener=选择 Hibernate 事件 {0}
choose.package=选择软件包
choose.table.or.view=选择表或视图
class=类
class.name=类名
class.name.validation.error=指定的软件包中已存在使用此名称的类
column.definition.not.found=找不到列定义
column.name.name=名称
column.name.value=值
columnWidth=字段宽度
command.name.create.entity=创建实体
command.name.create.enum=创建枚举
command.name.update.entity.attribute=更新实体特性\: {0}
comment.saving.strategy.annotation=@Comment 注解
comment.saving.strategy.ignore=忽略
comment.saving.strategy.javaDoc=Java 文档
connecting.to.dataSource=正在连接到 ''{0}''
continue=继续
could.not.parse.repository.method.name=无法解析仓库方法名称。\n请检查“{0}”是否使用 Spring Data 方法命名约定。
creatable=可创建
create.blaze.persistence.entity.view=创建 Blaze 持久性实体视图
create.count.method=创建 Count 方法
create.delete.method=创建 Delete 方法
create.dto=创建 DTO
create.dto.action.text=创建 DTO…
create.dto.or.projection.class=创建 DTO 或投影类
create.entities.and.attributes=创建实体和特性…
create.entity.attributes=创建实体特性
create.entity.indicator=创建实体“{0}”
create.entity.models=创建实体模型
create.exists.method=创建 Exists 方法
create.find.collection.method=创建 Find Collection 方法
create.find.instance.method=创建 Find Instance 方法
create.new.dto.class=创建新的 DTO 类
create.new.mapped.superclass=新建 MappedSuperclass
create.new.projection.class=创建新的 Projection 类
create.projection=创建 Spring Data 投影
create.query.count.method=创建 @Query Count 方法
create.query.delete.method=创建 @Query Delete 方法
create.query.exists.method=创建 @Query Exists 方法
create.query.find.collection.method=创建 @Query Find Collection 方法
create.query.find.instance.method=创建 @Query Find Instance 方法
create.query.repository.method=创建 Query 仓库方法 ''{0}''
create.query.update.method=创建 @Query Update 方法
create.revision.entity=创建修订实体
create.revision.listener=创建修订侦听器
create.spring.data.repository=创建 Spring Data 仓库
create.spring.data.repository.method=创建 Spring Data 仓库方法
createDbConnection=创建数据库连接
createJpaConverter.fix=创建自定义类型
createPageableParameter.fix=将 Pageable 形参添加到方法签名中
created.by=创建者
created.date=创建日期
criteria.api.specification=标准 API 规范
data.source=数据源
database=数据库
database.driver.not.selected=未选择数据库驱动程序
database.drivers=数据库驱动程序
date.type=日期类型
date.type.validation=指定的日期类型不正确
db.connection=数据库连接
db.connection.delete=删除
db.connection.save=保存
db.connection.updated=数据库连接“{0}”已成功更新。
db.connection.was.deleted=数据库连接“{0}”已删除
db.driver.column.name.path=路径
db.driver.download.version=下载 {0}
db.driver.switchToVersion=切换到 {0}
db.driver.title.downloading=正在下载 {0}
db.driver.version=驱动程序版本
db.driver.version.not.set=未设置\!
db.generated.id.description=<ul><li><b>NONE</b> - 数据库和 ORM 均不提供 ID 值。ID 应在源代码中明确指定。</li><li><b>IDENTITY</b> - ID 由数据库管理。适用于自动增量类型以及使用 `nextval("sequence_name")` 或任何其他函数作为 ID 列的默认值的情况。</li><li><b>SEQUENCE</b> - ID 由 ORM 管理。该策略需要数据库端的序列。针对批量插入进行了优化。</li></ul>
db.generated.id.description.uuid=<ul><li><b>NONE</b> - 数据库和 ORM 均不提供 ID 值。ID 应在源代码中明确指定。</li><li><b>UUID</b> - ID 由客户端管理。可以使用 Hibernate 生成器、字段初始化或自定义工厂来指定该值。对于在全球部署了多个应用程序和数据库实例的分布式系统来说，这是唯一的选择。</li></ul>
db.generated.id.jpa.entity=JPA 实体中数据库生成的 ID
db.snapshot.help.description=如果进行逆向工程时未更改数据库架构，我们建议启用数据库架构缓存。否则，每次逆向工程使用时都会从数据库加载数据库架构。如果启用缓存，将为临时目录中的所选数据库创建快照文件 - <code>{0}</code>
db.view.without.id.columns=未选择任何列用作主键
db.views.without.id.columns.msg=未选择任何列用作以下关系的主键。<br><ul>{0}</ul>所有 JPA 实体都必须有一个 ID。是否要创建没有 ID 的实体?
ddl.type=DDL 类型
declare.new=声明新
default.db.connection=数据库连接
default.method.name.will.be.generated=将生成默认方法名称
define.entity.graph=定义实体图
defined.target.java.type=定义目标 Java 类型
delete.db.connection=是否删除数据库连接“{0}”?
dialog.message.attribute.name.reserved.keyword=特性名称为保留关键字
dialog.message.duplicates.are.found.for.items=找到了以下条目的重复项 \:{0}
dialog.message.entity.attribute.should.have.name.written.in.camelcase.naming.convention=实体特性的名称应采用骆驼拼写法命名约定
dialog.message.field.required=字段 {0} 为必需项
dialog.message.must.not.be.empty={0} 不得为空
dialog.message.parameters.with.blank.names.are.not.allowed=不允许使用名称为空的形参
dialog.message.there.inherited.attribute.with.such.name=存在使用此名称的继承特性
dialog.title.choose.class=选择类
dialog.title.downloading.driver.files=正在下载驱动程序文件
dialog.title.params=形参
dialog.title.select.item=选择条目
diff.scope.all.places=所有位置
diff.scope.count=\ {0}/{1}
diff.scope.project=项目
diff.scope.project.and.libraries=项目和库
diff.scope.project.and.tests=项目和测试
diff.scope.selected.entities=所选实体
diff.scope.test=仅测试
director.of.class.not.found=找不到“{0}”类的目录
directory=目录
distinct=Distinct
domain.entity=域实体
down=下
download.driver.files=下载驱动程序文件
download.missing.driver.files=<a href\="{0}">下载</a>缺少的驱动程序文件
downloading.driver.files=正在下载驱动程序文件
driver.0.not.found=找不到驱动程序 {0}\!
driver.class=驱动程序类
driver.files.not.found=找不到驱动程序文件
driver.files.were.not.loaded=驱动程序文件未加载
dto=DTO
dto.and.spring.data.projections=DTO 和 Spring Data 投影
dto.class=DTO 类
dto.class.already.exists=<html>这样的类已经存在。<br>选择类型“现有类”或为该类提供唯一的名称。
dto.class.name=DTO 类名
dto.class.not.exists=所选类不存在
dto.type=DTO 类型
duplicate.attribute.name=重复的特性名称“{0}”
duplicate.db.connection.name=数据库连接名称“{0}”在项目中必须唯一
duplicate.query.mapping=重复的查询映射名称“{0}”。实体 -“{1}”
dynamic.projection=动态投影
edit=编辑
elementCreationDialog.scaffoldingLanguage=语言\:
empty.db.connection=数据库连接不应为空
empty.generation.type.value=生成类型不能为空
enable.jpa.auditing.info=<html>未检测到 @EnableJpaAuditing 注解。无法配置 Spring 审核。请确保 Spring 审核已在您的应用程序中正确配置。<a href\='https\://docs.spring.io/spring-data/jpa/docs/current/reference/html/\#jpa.auditing.configuration'>在此处阅读有关其配置的更多信息…</a></html>
enable.mongo.auditing.info=<html>未检测到 @EnableMongoAuditing 注解。无法配置 Spring 审核。请确保 Spring 审核已在您的应用程序中正确配置。<a href\='https\://docs.spring.io/spring-data/mongodb/docs/current/reference/html/\#mongo.auditing'>在此处阅读有关其配置的更多信息…</a></html>
entities=实体
entities.from.db=数据库中的{0}
entity=用于实体
entity.attribute.from.db=数据库中的{0}
entity.class=实体类
entity.graph=实体图
entity.graph.field=实体图
entity.graph.type.fetch=<html>使用 javax.persistence.fetchgraph 属性指定实体图时，<br>由实体图的特性节点指定的特性<br>会被视为 FetchType.EAGER，<br>而未指定的特性会作为 FetchType.LAZY 进行处理。<br><br></html>
entity.graph.type.load=<html>使用 javax.persistence.loadgraph 属性指定实体图时，<br>由实体图的特性节点指定的特性<br>会被视为 FetchType.EAGER，<br>而未指定的特性会根据其指定或默认 FetchType 进行处理。<br><br></html>
entity.listener.class=实体侦听器类
entity.package=目标软件包
entity.projection.or.dto.return.type=实体、Spring 投影或 DTO 类
entity.view.class.name=实体视图类名
entity.view.type=实体视图类型
equals.hash.code=equals() 和 hashCode()
error=错误
excludeLazyField.fix=从 @ToString 中排除此字段。
excludeLazyFields.fix=使用 @ToString.Exclude 排除所有延迟加载字段。
excludeLazyFieldsFromHeader.fix=排除所有延迟加载的字段。
existing.db.upgrade=现有数据库更新(差异)
existing.parent.class=现有父类
extract.and.configure.jpql.query=提取 JPQL 查询并配置…
extract.jpql.query=提取 JPQL 查询
extract.mapped.super.class=提取到 MappedSuperclass
extract.mapped.super.class.from=提取自
extract.mapped.super.class.to=提取到
extracting.jpql.using.limit.query=无法使用“Top”或“First”选项从方法中提取 JPQL 查询
extracting.jpql.using.updateOrDelete.query=无法从“Update”或“Delete”查询中提取 JPQL 查询
extracting.warning=正在提取警告
extracting.warning.msg=其中一个提取方法中使用的某些特性/方法将不会被提取到父类，因为您尚未选择它们。这可能会导致无法编译的代码。是否仍要继续?
field.name=字段名称
field.required=字段 ''{0}'' 为必需项
file.name=文件名
find=查找
find.first=查找第一个
fixes.create.jpa.projection=创建 Spring 投影
fluent.help.description=生成的 setter 将返回 `this` 而不是 `void`。如果您想链接多个方法调用，此类 setter 会很有帮助。
fluent.setters=Fluent setter
found.override.properties=是否要重写这些属性?
from.existing.attributes=从现有特性
from.parent=从父项
generate.columns.from.db=从数据库生成列
generate.ddl.by.entities=通过实体生成 DDL…
generate.ddl.by.entity=通过{0}生成 DDL
generate.equals.and.hashcode.already.defined.warning=已为类 {0} 定义方法 ''boolean equals(Object)'' 或 ''int hashCode()''。是否要删除这些方法并继续?
generate.equals.and.hashcode.already.defined.warning.anonymous=已为匿名类定义方法 'boolean equals(Object)' 或 'int hashCode()'。是否要删除这些方法并继续?
generate.equals.and.hashcode.composite.warning={0} {1} 必须实现 equals 和 hashcode 方法。要生成它们吗?
generate.equals.and.hashcode.several.warning=找到多个密钥。是否要在 equals() 和 hashCode() 方法中使用?
generate.equals.and.hashcode.several.warning.title=选择生成策略
generate.tostring.already.defined.title=生成 toString()
generate.tostring.already.defined.warning=已为类 {0} ''String toString()'' 定义方法。是否要删除这些方法并继续?
generate.tostring.composite.warning=是否要在 {0} 类中实现 toString() 方法?
generateEqualsAndHashCode.fix=生成 equals()、hashCode() 和 toString()
generateNoArgsConstructor.fix=将无实参构造函数添加到类
generated.ddl=生成的 DDL
go.to.domain.entity=转到“{0}”域实体
graph=图
graph.fetch.type=提取类型
graph.fields.load=要加载的字段
group.com.intellij.orm.structure.popup.new.text=新
group.names.jpa.issues=JPA
hibernate=Hibernate
hibernate.ddl.auto=DDL 自动
hibernate.entity.field.tooltip=实体的名称。如有多个则用逗号分隔
hibernate.event=Hibernate 事件
hibernate.event.listener=Hibernate 事件 {0}
hibernate.events.field.tooltip=Hibernate 事件的名称。如有多个则用逗号分隔
hibernate.format.sql=设置 SQL 格式
hibernate.show.sql=显示 SQL
id=ID
id.generated.strategy=ID 生成
idea.data.source.refresh.exception=IDEA 数据源刷新异常
incorrect.attribute.value=实体特性的名称应采用骆驼拼写法命名约定
incorrect.length.value=不正确的长度值\: {0}
inspection.LombokAllArgsInspection=对没有定义无实参构造函数的 JPA 实体使用 @AllArgsConstructor 会破坏 JPA 规范。
inspection.LombokBuilderAllArgsInspection=Lombok @Builder 需要针对此类的适当构造函数
inspection.LombokBuilderInspection=对没有定义无实参构造函数的 JPA 实体使用 @Builder 会破坏 JPA 规范。
inspection.ManyToManyCascadeRemove=对于 @ManyToMany 关联，REMOVE 实体状态过渡没有级联意义，因为它将传播到链接表之外。
inspection.OneToOneWithLazyFetchType=为 @OneToOne 关联的非拥有方指定 FetchType.LAZY 不会影响加载。相关实体仍将被加载，就像定义了 FetchType.EAGER 一样。
inspection.associationFieldHasColumnAnnotation.name=使用 @Colum 标记的关联字段
inspection.associationFieldHasColumnAnnotation.replaceFix=将 @Column 更改为 @JoinColumn
inspection.associationFieldHasColumnAnnotation.warning=不允许在{0}属性上使用 @Column
inspection.associationNotMarkedInspection=实体特性未使用关联注解标记
inspection.converterNotAnnotated=JPA 转换器必须使用 @Converter 进行注解
inspection.message.unknown.column=未知列 {0}
inspection.moreThanOneId=实体有多个 ID 特性。
inspections.replaceAnnotation=替换为 {0}
invalid.attribute.name=列\:“{0}”。特性名称的 Java 标识符无效或为保留标识符\:“{1}”
invalid.class.name=无效类名
invalid.domain.entity.class=无效的域实体类“{0}”
invalid.field.name=实体特性“{0}”的字段名称无效
invalid.field.name.changed=<html>使用 MapStruct mapper 生成时，无法更改 Collection 类型的特性的属性名称。<br/>此类属性的名称已被重置。</html>
invalid.or.empty.domain.entity.class=域实体类无效或为空
invalid.or.empty.dto.class=DTO 类值无效或为空
invalid.package.name=无效的软件包名称
invalid.parent.class=无效的父类
invalid.subDto.type=<html>无效的 subDto 类型特性“{0}”。<br/>不支持创建具有超过 1 个嵌套级别的扁平<br/>集合特性的 mapper。</html>
invalid.subEntityView.type=<html>子实体视图类型特性“{0}”无效。<br/>不支持创建具有超过 1 个嵌套级别的扁平<br/>集合特性的实体视图。</html>
java.record=Java 记录
java.type.is.empty=列\:“{0}”。Java 类型为必需项
jpa.buddy.common.notifications=JPA Buddy 常见通知
jpa.buddy.logs=JPA Buddy 日志
jpa.buddy.template.group=JPA Buddy
jpa.converter.or.hibernate.type=JPA 转换器/Hibernate 类型
jpa.converters=JPA 转换器
jpa.entities=JPA 实体
jpa.entity=JPA 实体
jpa.entity.attributes=实体特性
jpa.persistence.unit=持久性单元
json.ignore.unknown.properties=忽略 JSON 反序列化的未知属性
last.modified.by=最后修改者
last.modified.date=上次修改日期
last.update=(在以下位置捕获了数据库的实际状态\: {0})
learn.more=了解详情
limit=限制
limit.prefix=限制前缀
limit.size=限制大小
listener.class.not.selected=未选择实体侦听器类。请选择一个类。
loading.database.model=正在加载数据库模型…
loading.time=加载时间 - {0} 秒
lock.mode=锁定模式
logical.orm.attribute.column.mappings=列映射
logical.orm.attribute.maps=映射
logical.orm.embedded.usages=用法
logical.orm.superclass.implementations=实现
makeCompositeClassSerializable.fix=使 {0} 类实现 Serializable
makeTransient.fix=标记为 @Transient
mandatory.attribute.not.added=强制特性将不会添加到实体
mapStruct.collectionMappingCollection=为集合创建 mapper 方法
mapStruct.collectionMappingStream=使用 stream().map(…)
mapStruct.createMapStructClassCaption=创建 MapStruct 接口
mapStruct.mapper=MapStruct 接口
mapStruct.mapperClassName=Mapper 类名
mapStruct.mapperParentInterface=父接口
mapStruct.packageChooserDialogCaption=选择 MapStruct Mapper 软件包
mapped.columns=映射的列
mapped.relations=映射的关系
mapped.super.class.extract.generator=将 @SequenceGenerator 声明提取到 {0} 中
mapped.super.class.generator.name=生成器名称
mapped.super.class.name=MappedSuperclass 名称
mapper.methodName=方法名称
mapper.methods=Mapper 方法
mapper.naming.options.collection=使用集合类型后缀
mapper.naming.options.plural=使用复数形式
mapper.naming.options.singular=使用单数形式
mapping.java.type=映射 Java 类型
mapping.settings=映射设置
mapping.types=映射类型
menuItem=菜单
method=方法
method.infix.help=这是位于 "{0}" 前缀和 "By" 条件之间的方法名称段。它支持简洁的方法命名，并且可用于针对同一查询条件返回多种数据类型。
method.name=方法名称
method.prefix=方法前缀
methods.mapped.super.class=提取方法
microsoft.sql.server=Microsoft SQL Server
microsoft.sql.server.jtds=Microsoft SQL Server (jtds)
migrate.default.values=迁移默认值
migrate.indexes.and.constraints=迁移索引和约束
migrate.other.columns=将其他列迁移到实体
missing.primary.key.columns=缺少主键列
modifying=正在修改
module=在模块中
mutable=可变
name=名称
named.parameters=命名形参
named.query=命名查询
named.query.attr.name.empty=特性名称为必需项。表行\: {0}
named.query.creation.error=命名查询创建错误
new=新
new.attribute=新特性
new.dto=新建 DTO
new.mapper.class=新建 MapStruct 接口
no.attributes=无特性
no.attributes.detected=未检测到特性
no.attributes.selected=未选择任何特性
no.auditor.aware.classes.info=<html>未检测到 AuditorAware 接口的实现。您可以手动指定审核器类型并稍后创建相应的 AuditAware 实现。</html>
no.columns.for.reverse.engineering=没有用于逆向工程的列
no.driver.files.configured=未配置驱动程序文件。<a href\="{0}">切换</a>至 {1}
no.entities=无实体
notification.content.exception.during.create.directory=创建目录期间出现异常\: {0}
notification.content.please.select.directory.for.create.action=请选择用于创建操作的目录
notification.title.exception.during.creation.projection=创建投影期间出现异常
notification.title.exception.when.entity.column.name.calculating.column.name.template=计算实体列名时出现异常。列名模板\: {0}
notification.title.exception.when.entity.name.calculating.entity.name.template=计算实体名称时出现异常。实体名称模板\: {0}
notification.title.exception.when.entity.table.name.calculating.table.name.template=计算实体表名时出现异常。表名模板\: {0}
notification.title.project.not.contains.modules=项目不包含模块
nullability=为 null 性
nullable=可为 null
open.db.connection=打开数据库连接
order.by.attributes=按特性排序
other=其他
other.settings=其他设置
override.properties=重写属性
packageName=软件包
pageable=Pageable
parent=父项
persistence.unit.file=persistence.xml 文件
persistence.unit.manuallyAdded=手动添加
persistence.unit.scanAllPackages=扫描所有软件包
persistenceUnit=映射上下文
please.check.internet.connection=请检查您的互联网连接
pojo.class=POJO 类
presentation=表示
progress.details.extracting=正在提取 {0}
progress.loadDriversTitle=正在加载数据库驱动程序列表…
progress.text.choice.downloading.resolving={0, choice, 0\#正在下载 |1\#正在解析 }{1}
project.jdk.select.title=选择项目 SDK
project.sdk.not.defined=未定义项目 JDK
projection=投影
projection.class.name=投影类名
projection.type=投影类型
property.name=属性名称
pu.without.entities.error=所选持久性单元不包含实体。这可能是由于最近对软件包名称进行了重构或在 persistence.xml 中进行了更改。如果应该包含实体，请编辑持久性单元，或者继续生成 drop 语句。点击“取消”以选择其他持久性单元。
query=查询
query.conditions=查询条件
query.options=查询选项
query.string=查询字符串
radio.hibernate.custom.type=Hibernate 自定义类型
radio.jpa.converter=JPA 转换器
references=引用
refers.to.entities=引用实体
refresh.idea.data.source=刷新 IDEA 数据源
relation.panel.loadParents=正在加载父实体
remove=移除
remove.column.mapping=移除列映射
remove.listener=移除侦听器
removeAnnotation.fix=移除 @{0} 注解。
removeCascadeType.fix=移除实参 CascadeType.REMOVE
removeLazyForOneToOneAnnotation.fix=移除实参 FetchType.LAZY
replaceCascadeTypeAll.fix=将级联上除 CascadeType.REMOVE 之外的所有类型替换为 CascadeType.ALL
replaceData.fix=将 @Data 替换为安全注解和自动生成的 equals() 和 hashCode()
replaceEqualsAndHashCode.fix=将 @EqualsAndHashCode 替换为推荐的 equals() 和 hashCode() 实现。
replacePageToList.fix=将 {0} 替换为 {1}
replaceToString.fix=将 @ToString 替换为推荐的 toString() 实现。
repositories=仓库
repository.creation.dialog.entity=实体
repository.method.overridden=在基类中找到了具有相同名称“{0}”的方法\! 该方法已被重写。
repository.name=代码库名称
repository.query.method=仓库查询方法
result=结果
return.type=返回值类型
revision.listener=修订侦听器
revision.number=修订号
revision.repository=修订仓库
revision.timestamp=修订时间戳
run.action=运行操作
save.entity.indicator=保存实体“{0}”
scan.packages=扫描软件包
scratch.db.initialization=数据库架构初始化
select.any.dto.type=选择任意 DTO 类型
select.any.entity.attribute.type=选择任意实体特性类型
select.any.entity.view.type=选择任意实体视图类型
select.any.projection.type=选择任意投影类型
select.at.least.one.entity=至少选择一个实体来创建自定义作用域
select.columns.for.id.attribute=选择要用作主键的列
select.entities=选择自定义作用域的实体
select.id.attributes=选择主键特性
select.id.columns=选择主键列
select.repository=选择仓库
select.repository.method.type=选择仓库方法类型
sequence=序列
sequence.field.required=字段序列为必需项
serializable=Serializable
settings=设置
several.auditor.aware.classes.info=<html>已检测到 AuditorAware 接口的多个实现。确保您选择的审核器类型与 Spring 审核配置中使用的审核器类型相对应。</html>
shorten.method.name=缩短方法名称
show.basic.attributes=显示基本特性
signature=签名
snapshot.file.not.exists=快照文件不存在
snapshot.incorrect.message=无法从数据库架构缓存读取数据。请尝试刷新或将其关闭。
snapshot.incorrect.title=快照读取错误
sort.table.unavailable=<b>排序方式</b>表不可用。先选择<b>查找第一个</b>选项。
sortable=Sortable
source.class=源类型
source.root=源根
source.scope=源作用域
specification=规范
spring.data.repositories=Spring Data 仓库
start.text.todo.reverse.engineering=TODO [逆向工程]
start.text.todo.reverse.engineering.odd=TODO 逆向工程
success=标准屏幕已成功创建
table=表
table.name=表名
table.view=表/视图
tables=表
target.class=目标类型
to.string=toString()
todo.comment=TODO
todo.java.type.render=此字段将在稍后生成
todo.reverse.engineering=//TODO [逆向工程] 从数据库生成列
transactional.read.only=Transactional readOnly
tree.persistence.units.missing.package.tooltip=持久性单元引用缺少的软件包
type.migration.label=将{0} "{1}" 迁移到
uncomment.as.is=按原样取消注释
unselect.columns=取消选择列
unselect.table.has.usages=<html>表 <b>{0}</b> 具有无法安全取消选择的用法\: <ul>{1}</ul>
up=上
updatable=可更新
update.re.mappings=映射更新
update.re.mappings.message=您刚刚更改了命名规则和/或列到特性类型映射。是否要立即应用新设置? 请注意，所做的所有映射设置都将被重置。
update.values=更新值
update.values.attribute.is.empty=“更新值”表中的特性为空
update.values.is.empty=指定至少一个更新值
usages.detected=检测到用法
use.named.parameters=使用命名形参
use.table.schema=使用表架构
used.by=使用对象\:
validation.attributes.and.order.by.empty=查询条件和排序方式特性为空
validation.attributes.empty=查询条件为空
validation.delete.update.join=方法不应在条件中包含相关实体特性
validation.delete.void.id=Void 是 deleteById() 方法唯一可能的返回值类型。
validation.duplicate.repository.method.name=<html>已存在具有相同名称“{0}”的方法。</html>
validation.duplicate.repository.method.name.action=<html><a href\=''\#ADD_IT''>应用返回值类型名称作为中缀并使用“{0}”作为方法名称</a></html>
validation.incorrect.pageable.return.type=返回分页数据的方法必须具有以下返回值类型之一\: Page<T>、Slice<T>、List<T>
validation.incorrect.repository.return.type=不正确的仓库返回值类型
validation.repository.method.have.pageable.and.sort=方法不能同时为 Pageable 和 Sortable。请在 Pageable 上改用排序功能。
validation.repository.not.selected=未选择仓库
validation.update.only.basic=方法不应更新相关实体特性
value=值
value.type=值类型
velocity.template=Velocity 模板
view=查看
views=视图
wrap.type=包装类型

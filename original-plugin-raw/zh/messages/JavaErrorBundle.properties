annotation.annotation.type.expected=应为注解类型
annotation.interface.is.not.used=@interface ''{0}'' 从未使用
annotation.missing.method=找不到 @interface 方法 ''{0}()''
annotation.not.applicable=''@{0}'' 不适用于{1}
annotation.on.static.member.qualifying.type.family.name=移动类型注解
annotation.unknown.method=找不到 @interface 方法 ''{0}()''
assert.identifier.warn=自 Java 1.4 起，不支持使用 'assert' 作为标识符
binary.operator.not.applicable=运算符 ''{0}'' 不能应用于 ''{1}''、''{2}''
cannot.resolve.constructor=无法解析构造函数 ''{0}''
cannot.resolve.method=无法解析方法 ''{0}''
cannot.resolve.package=无法解析软件包 {0}
cannot.resolve.symbol=无法解析符号 ''{0}''
catch.without.try='catch' 没有 'try'
class.is.not.used=类 ''{0}'' 从未使用
class.must.be.abstract=类“{0}”必须声明为抽象，或为实现“{2}”中的抽象方法“{1}”
constructor.is.not.used=构造函数 ''{0}'' 从未使用
create.class.action.this.not.valid.java.qualified.name=这不是有效的 Java 限定名称
deconstruction.pattern.requires.record=析构模式只能应用于记录，''{0}'' 不是记录
deprecated.default.constructor=''{0}'' 中的默认构造函数已弃用
deprecated.since.symbol=''{0}'' 自版本 {1} 起已弃用
deprecated.symbol=''{0}'' 已弃用
else.without.if='else' 没有 'if'
enum.identifier.warn=自 Java 1.5 起，不支持使用 'enum' 作为标识符
enum.is.not.used=枚举 ''{0}'' 从未使用
error.cannot.resolve.class=无法解析类 ''{0}''
error.cannot.resolve.class.or.package=无法解析类或软件包 ''{0}''
exception.is.never.thrown=此方法中从未抛出异常 ''{0}''
expected.boolean.expression=应为布尔表达式
expected.catch.or.finally=应为 'catch' 或 'finally'
expected.comma=应为 ','
expected.expression=应为表达式
expected.identifier=应为标识符
expected.identifier.or.type=应为标识符或类型
expected.lbrace=应为 '{'
expected.lparen=应为 '('
expected.lparen.or.lbracket=应为 '(' 或 '['
expected.parameter=应为形参
expected.rbrace=应为 '}'
expected.rbracket=应为 ']'
expected.rparen=应为 ')'
expected.semicolon=应为 ';'
expected.statement=应为语句
expected.switch.label=应为 'case'、'default' 或 '}'
expected.switch.rule=应为表达式、块或 throw 语句
expected.while=应为 'while'
expression.expected=应为表达式
field.is.not.used=字段 ''{0}'' 从未使用
field.is.not.used.for.reading={0} 字段 ''{1}'' 已被分配，从未被访问
finally.without.try='finally' 没有 'try'
generics.unchecked.assignment=未检查的赋值\: ''{0}'' 赋值给 ''{1}''
generics.unchecked.call=未检查的方法 ''{0}'' 调用
generics.unchecked.call.to.member.of.raw.type=作为原始类型 ''{1}'' 的成员对 ''{0}'' 的未检查的调用
generics.unchecked.cast=未检查的转换\: ''{0}'' 转换为 ''{1}''
incompatible.types=不兼容的类型。实际为 {1}''，需要 ''{0}''
inconvertible.type.cast=不可转换的类型；无法将 ''{0}'' 转换为 ''{1}''
interface.is.not.used=接口 ''{0}'' 从未使用
local.class.is.not.used=本地类 ''{0}'' 从未使用
local.variable.is.never.used=''{0}'' 从未使用变量
local.variable.is.not.assigned=变量 ''{0}'' 从未被赋值
local.variable.is.not.used.for.reading=''{0}'' 已被赋值，从未被访问
marked.for.removal.default.constructor=''{0}'' 中的默认构造函数已弃用并被标记为移除
marked.for.removal.symbol=''{0}'' 已弃用并被标记为移除
marked.for.removal.symbol.since=''{0}'' 自版本 {1} 起已弃用并标记为移除
method.is.not.used=方法 ''{0}'' 从未使用
missing.package.statement=缺少 package 语句\: ''{0}''
missing.package.statement.package.name.invalid=缺少软件包语句，但与文件路径相对应的软件包名称 ''{0}'' 无效
missing.return.statement=缺少 return 语句
module.open.duplicate.text=转到重复项
module.unwanted.modifier.warn=自 Java 10 起，禁止对 'requires java.base' 使用修饰符
numeric.overflow.in.expression=表达式中出现数值溢出
overrides.deprecated.method=重写 ''{0}'' 中弃用的方法
overrides.marked.for.removal.method=重写 ''{0}'' 中弃用并标记为移除的方法
package.name.file.path.mismatch=软件包名称 ''{0}'' 与文件路径 ''{1}'' 不对应
parameter.excluding.hierarchy.disable.text=不高亮显示继承方法的形参
parameter.is.not.used=形参 ''{0}'' 从未使用
pattern.variable.is.not.used=模式变量 ''{0}'' 从未使用
private.constructor.is.not.used=private 构造函数 ''{0}'' 从未使用
private.field.is.not.assigned=private 字段 ''{0}'' 从未分配
private.field.is.not.used=private 字段 ''{0}'' 从未使用
private.inner.class.is.not.used=private 内部类 ''{0}'' 从未使用
private.inner.interface.is.not.used=private 内部接口 ''{0}'' 从未使用
private.method.is.not.used=private 方法 ''{0}'' 从未使用
qualified.enum.constant.in.switch.remove.fix=移除限定符
record.canonical.constructor=规范构造函数
record.compact.constructor=紧凑构造函数
record.is.not.used=记录 ''{0}'' 从未使用
redundant.semicolon.warn=从 Java 21 开始禁止在 import 语句之间使用冗余的分号
remove.unused.imports.quickfix.text=移除未使用的 import
restricted.identifier=''{0}'' 是受限标识符，不能用于类型声明
restricted.identifier.warn=自 Java {1} 起的版本中不支持使用 ''{0}'' 作为类名
static.member.accessed.via.instance.reference=通过实例引用访问 static 成员 ''{0}.{1}''
suspicious.name.assignment=''{0}'' 可能不应分配给 ''{1}''
suspicious.name.parameter=''{0}'' 可能不应作为形参 ''{1}'' 传递
suspicious.name.return=''{0}'' 可能不应从方法 ''{1}'' 返回
switch.dominance.of.preceding.label=标签由先前的 case 标签 ''{0}'' 支配
switch.expr.empty='switch' 表达式没有任何 case 子句
switch.expr.incomplete='switch' 表达式未涵盖所有可能的输入值
switch.statement.empty='switch' 语句没有任何 case 子句
switch.statement.incomplete='switch' 语句未涵盖所有可能的输入值
text.class.is.not.accessible={0} 在当前上下文中不可访问
type.parameter.is.not.used=类型形参 ''{0}'' 从未使用
unchecked.overriding.incompatible.return.type=未检查的重写\: 返回值类型需要未经检查的转换。实际为 ''{0}''，需要 ''{1}''
underscore.identifier.warn=自 Java 9 起，不支持使用 '_' 作为标识符
unexpected.token=意外的标记
unhandled.exceptions=未处理 {1, choice, 0\#异常|2\#异常}\: {0}
variable.already.defined=作用域中已定义变量 ''{0}''
yield.unqualified.method.warn=自 Java 14 起的版本中不支持对 'yield' 方法进行非限定调用

# @interface (annotation) related messages
annotation.not.allowed.here=此处不允许注解
annotation.unknown.method=无法解析方法 ''{0}''
annotation.missing.method=无法找到方法 ''{0}''
annotation.illegal.array.initializer=''{0}'' 的初始值设定项非法
annotation.duplicate.annotation=注解重复
annotation.duplicate.attribute=特性 ''{0}'' 重复
annotation.missing.attribute={0} 必要，但缺少
annotation.not.applicable=''@{0}'' 不适用于{1}
annotation.non.constant.attribute.value=特性值必须为常量
annotation.non.class.literal.attribute.value=特性值必须为类文字
annotation.non.enum.constant.attribute.value=特性值必须为枚举常量
annotation.invalid.annotation.member.type=注解成员的类型 ''{0}'' 无效
annotation.cyclic.element.type=循环注解元素类型
annotation.annotation.type.expected=应为注解类型
annotation.members.may.not.have.throws.list=@interface 成员可能没有 throws 列表
annotation.may.not.have.extends.list=@interface 可能没有 extends 列表
annotation.not.allowed.ref=注解不适用于此类引用
annotation.not.allowed.static=限定类型的 static 成员可能未注解
annotation.not.allowed.void='void' 类型可能未进行注解
annotation.not.allowed.var='var' 类型可能未注解
annotation.not.allowed.class=类文字类型可能未进行注解
annotation.container.no.value=无效的容器注解 ''{0}'': 未声明 ''value'' 方法
annotation.container.bad.type=无效的容器注解 ''{0}'': ''value'' 方法的类型应为 ''{1}''
annotation.container.low.retention=容器注解 ''{0}'' 的保留长度(''{1}'')比包含的注解短
annotation.container.wide.target=容器注解 ''{0}'' 的目标不是此注解目标的子集
annotation.container.abstract=容器注解 ''{0}'' 没有包含 ''{1}'' 的默认值
annotation.container.missed.annotation=容器注解 ''{0}'' 没有必需的 @{1} 注解
annotation.duplicate.explained=注解重复。{0}
annotation.non.repeatable=''{0}'' 的声明没有有效的 java.lang.annotation.Repeatable 注解
annotation.container.wrong.place=容器注解 ''{0}'' 不得与它所包含的元素同时存在
annotation.container.not.applicable=容器注解 ''@{0}'' 不适用于 {1}

receiver.wrong.context=不允许接收器超出方法参数列表
receiver.static.context=接收器不能在 static 上下文中使用
receiver.wrong.position=接收器应为第一个参数
receiver.type.mismatch=接收器类型不匹配封闭类类型
receiver.name.mismatch=接收器名称不匹配封闭类类型

# generics related messages
generics.holder.type=类型
generics.holder.method=方法

generics.inferred.type.for.type.parameter.is.not.within.its.bound.extend=类型形参 ''{0}'' 的推断类型 ''{2}'' 不在其界限内；应扩展 ''{1}''
generics.inferred.type.for.type.parameter.is.not.within.its.bound.implement=类型形参 ''{0}'' 的推断类型 ''{2}'' 不在其界限内；应实现 ''{1}''
generics.type.parameter.is.not.within.its.bound.extend=类型形参 ''{0}'' 不在其界限内；应扩展 ''{1}''
generics.type.parameter.is.not.within.its.bound.implement=类型形参 ''{0}'' 不在其界限内；应实现 ''{1}''

# {0} - Type (class) or Method
generics.type.or.method.does.not.have.type.parameters={0} ''{1}'' 没有类型形参
generics.wrong.number.of.type.arguments=类型实参的数量错误: {0}；要求 {1} 个
generics.cannot.be.inherited.with.different.type.arguments=''{0}'' 不能使用不同的类型实参继承: ''{1}'' 和 ''{2}''
generics.select.static.class.from.parameterized.type=无法从形参化类型选择 static 类 ''{0}''
generics.methods.have.same.erasure={0}；两个方法具有相同的擦除
generics.methods.have.same.erasure.override={0}；两个方法具有相同的擦除，但都没有重写另一个
generics.methods.have.same.erasure.hide={0}；两个方法具有相同的擦除，但都没有隐藏另一个
generics.type.parameter.cannot.be.instantiated=类型形参 ''{0}'' 不能直接实例化
wildcard.type.cannot.be.instantiated=通配符类型 ''{0}'' 不能直接实例化
generics.wildcard.not.expected=应为非通配符
generics.wildcards.may.be.used.only.as.reference.parameters=通配符只能用作引用参数
generics.type.argument.cannot.be.of.primitive.type=类型实参不能为基元类型
generics.unchecked.assignment=未检查的赋值: ''{0}'' 赋值给 ''{1}''
generics.unchecked.cast=未检查的转换: ''{0}'' 转换为 ''{1}''
generics.unchecked.call.to.member.of.raw.type=作为原始类型 ''{1}'' 的成员对 ''{0}'' 的未检查的调用
generics.unchecked.call=未检查的方法 ''{0}'' 调用
generics.diamond.not.applicable=菱形运算符不适用于非形参化类型
generics.reference.parameters.not.allowed=此处不允许引用参数
foreach.not.applicable=foreach 不适用于类型 ''{0}''
illegal.to.access.static.member.from.enum.constructor.or.instance.initializer=从枚举构造函数或实例初始值设定项访问 static 成员 ''{0}'' 是非法的
enum.types.cannot.be.instantiated=无法实例化枚举类型
generic.array.creation=创建泛型数组
array.creation.with.type.arguments=无法创建具有类型实参的数组
generics.enum.may.not.have.type.parameters=枚举可能没有类型形参
generics.annotation.members.may.not.have.type.parameters=@interface 成员可能没有类型形参
annotation.may.not.have.type.parameters=@interface 可能没有类型形参
generics.duplicate.type.parameter=重复的类型形参: ''{0}''
generics.cannot.catch.type.parameters=无法捕获类型形参
generics.cannot.instanceof.type.parameters=应为类或数组
illegal.generic.type.for.instanceof=instanceof 的泛型类型非法
unsafe.cast.in.instanceof=''{0}'' 无法安全转换为 ''{1}''
instanceof.pattern.supertype=模式类型 ''{0}'' 是表达式类型 ''{1}'' 的父类型
instanceof.pattern.equals=模式类型 ''{0}'' 与表达式类型相同
cannot.select.dot.class.from.type.variable=无法从类型变量中选择
method.does.not.override.super=方法未从其超类重写方法
call.to.super.is.not.allowed.in.enum.constructor=枚举构造函数中不允许调用 super
vararg.not.last.parameter=Vararg 形参必须为列表中的最后一个形参
modifiers.for.enum.constants=不允许对枚举常量使用修饰符
generics.type.arguments.on.raw.type=在原始类型上提供类型实参
generics.type.arguments.on.raw.method=在原始方法上提供类型实参
classes.extends.prohibited.super=类无法直接扩展 ''{0}''
unchecked.overriding.incompatible.return.type=未检查的重写: 返回类型需要未经检查的转换。实际为 ''{0}''，需要 ''{1}''

interface.expected=此处应为接口
no.interface.expected=此处不应为接口
class.expected=此处应为类名
implements.after.interface=不允许对接口使用 implements 子句
extends.after.enum=不允许对枚举使用 extends 子句
permits.after.enum=枚举不允许 permits 子句
class.must.be.abstract=类 "{0}" 必须声明为抽象，或为实现 "{2}" 中的抽象方法 "{1}"
enum.constant.must.implement.method=枚举常量 ''{0}'' 必须在 ''{2}'' 中实现 abstract 方法 ''{1}''
class.must.implement.method=类 ''{0}'' 必须在 ''{2}'' 中实现 abstract 方法 ''{1}''
abstract.cannot.be.instantiated=''{0}'' 为 abstract；无法实例化
duplicate.class.in.other.file=在文件 ''{0}'' 中找到重复类
duplicate.class=重复的类: ''{0}''
public.class.should.be.named.after.file=类 ''{0}'' 为 public，应在文件 ''{0}.java'' 中声明
inheritance.from.final.class=无法从{1} ''{0}'' 继承
package.name.file.path.mismatch=软件包名称 ''{0}'' 与文件路径 ''{1}'' 不对应
missing.package.statement=缺少 package 语句: ''{0}''
cyclic.inheritance=涉及 ''{0}'' 的循环继承
class.already.imported=已在此编译单元中定义 ''{0}''
class.cannot.extend.multiple.classes=类不能扩展多个类
not.allowed.in.interface=在接口中不允许
qualified.new.of.static.class=限定新增 static 类
invalid.qualified.new=限定 new 无效
class.name.expected=应为类名
no.enclosing.instance.in.scope=范围中没有类型 ''{0}'' 的封闭实例
is.not.an.enclosing.class=''{0}'' 不是封闭类
cannot.be.referenced.from.static.context=无法从 static 上下文引用 ''{0}'' 
no.default.constructor.available=''{0}'' 中没有可用的默认构造函数。
missing.return.statement=缺少 return 语句
unreachable.statement=不可到达的语句
variable.not.initialized=变量 ''{0}'' 可能尚未初始化
variable.already.assigned=变量 ''{0}'' 可能尚未被赋值
variable.assigned.in.loop=变量 ''{0}'' 可能在循环中赋值
assignment.to.final.variable=无法将值赋给 final 变量 ''{0}''
variable.must.be.final=变量 ''{0}'' 从内部类中访问，需要声明为 final
variable.must.be.final.or.effectively.final=变量 ''{0}'' 从内部类中访问，需要为 final 或有效 final
lambda.variable.must.be.final=lambda 表达式中使用的变量应为 final 或有效 final
resource.variable.must.be.final=用作 try-with-resources 资源的变量应为 final 或有效 final
declaration.or.variable.expected=应为声明、final 或 effectively final 变量
initializer.must.be.able.to.complete.normally=初始值设定项必须能够正常完成
weaker.privileges={0}；尝试分配较弱的访问权限(''{1}'')；曾为 ''{2}''
incompatible.return.type=尝试使用不兼容的返回类型
final.method.override=''{0}'' 无法重写 ''{2}'' 中的 ''{1}''；重写的方法为 final
overridden.method.does.not.throw={0}；重写的方法未抛出 ''{1}''
exception.is.never.thrown=此方法中从未抛出异常 ''{0}''
wrong.method.arguments=''{1}'' 中的 ''{0}'' 无法应用于 ''{2}''
method.call.expected=应为方法调用
ambiguous.method.call=方法调用不明确: ''{0}'' 和 ''{1}'' 均匹配
ambiguous.reference=对 ''{0}'' 的引用不明确，''{1}'' 和 ''{2}'' 均匹配
cannot.resolve.method=无法解析方法 ''{0}''
ambiguous.method.call.no.match=无法解析 ''{1}'' 中的方法 ''{0}''
missing.method.body=缺少方法体，或声明为 abstract
abstract.method.in.non.abstract.class=非 abstract 类中存在 abstract 方法
missing.return.type=方法声明无效；需要返回类型
duplicate.method=已在 ''{1}'' 中定义 ''{0}''
constructor.call.must.be.first.statement=''{0}'' 调用必须是构造函数主体中的第一条语句
direct.abstract.method.access=无法直接访问 abstract 方法 ''{0}''
unrelated.overriding.methods.return.types=方法有不相关的返回类型
overrides.deprecated.method=重写 ''{0}'' 中弃用的方法
overrides.marked.for.removal.method=重写 ''{0}'' 中弃用并标记为移除的方法
deprecated.default.constructor=''{0}'' 中的默认构造函数已被弃用
marked.for.removal.default.constructor=''{0}'' 中的默认构造函数已被弃用并被标记为移除
recursive.constructor.invocation=递归构造函数调用
wrong.constructor.arguments=''{0}'' 无法应用于 ''{1}''
cannot.resolve.constructor=无法解析构造函数 ''{0}''
invalid.package.annotation.containing.file=软件包注解应位于文件 package-info.java 中
repeated.annotation.target=重复的注解目标

clash.methods.message=''{0}'' 与 ''{1}'' 冲突
clash.methods.message.show.classes=''{2}'' 中的 ''{0}'' 与 ''{3}'' 中的 ''{1}'' 冲突

package.clashes.with.class=软件包 ''{0}'' 与同名的类冲突
class.clashes.with.package=类 ''{0}'' 与同名的软件包冲突

# {0} - colspan, {1} - method1, {2} - class1, {3} - method2, {4} - class2
ambiguous.method.html.tooltip=<html><body><table border=0><tr><td colspan={0}>方法调用不明确。<b>{2}</b> 中的 </td></tr><tr>{1}<td>\\&nbsp;和 <b>{4}</b> 中的 </td></tr><tr>{3}<td>\\&nbsp;均匹配</td></tr></table></body></html>

# {0} - left raw type, {1} - required type arguments row, {2} - right raw type, {3} - found type arguments row, {4} - reason, {5} - greyed title color
incompatible.types.html.tooltip=<html><body><table><tr><td style=''padding: 0px 16px 8px 4px;color: {5}''>需要的类型: </td><td style=''padding: 0px 4px 8px 0px;''>{0}</td>{1}</tr><tr><td style=''padding: 0px 16px 0px 4px;color: {5}''>提供的类型: </td><td style=''padding: 0px 4px 0px 0px;''>{2}</td>{3}</tr></table>{4}</body></html>

interface.methods.cannot.have.body=接口 abstract 方法不能有主体
abstract.methods.cannot.have.a.body=abstract 方法不能有主体
native.methods.cannot.have.a.body=原生方法不能有主体
static.methods.in.interfaces.should.have.body=接口中的 static 方法应具有主体
private.methods.in.interfaces.should.have.body=接口中的 private 方法应具有主体
extension.method.should.have.a.body=扩展方法应有主体
extension.method.in.class=扩展方法只能在接口中使用

instance.method.cannot.override.static.method=''{1}'' 中的实例方法 ''{0}'' 无法重写 ''{3}'' 中的 static 方法 ''{2}''
static.method.cannot.override.instance.method=''{1}'' 中的 static 方法 ''{0}'' 无法重写 ''{3}'' 中的实例方法 ''{2}''
inconvertible.type.cast=不可转换的类型；无法将 ''{0}'' 转换为 ''{1}''
variable.expected=应为变量
binary.operator.not.applicable=运算符 ''{0}'' 不能应用于 ''{1}''、''{2}''
unary.operator.not.applicable=运算符 ''{0}'' 不能应用于 ''{1}''
return.outside.method=return 位于方法外部
return.from.void.method=无法从结果类型为 void 的方法返回值
missing.return.value=缺少返回值
return.outside.switch.expr=return 位于封闭 switch 表达式外部

#{0} - exceptions list (comma separated), {1} - exceptions count in the list, {2} - exception source
unhandled.exceptions=未处理 {1, choice, 0#异常|2#异常}: {0}
unhandled.close.exceptions={2} 中有未处理的 {1, choice, 0#异常|2#异常}：{0}

variable.already.defined=范围中已定义变量 ''{0}''
break.outside.switch.or.loop=break 位于 switch 或循环外部
yield.unexpected=yield 位于 switch 表达式外部
yield.void=表达式类型不应为 'void'
break.outside.switch.expr=不允许 switch 表达式外的 break
continue.outside.loop=continue 位于循环外部
continue.outside.switch.expr=continue 位于封闭 switch 表达式外部
class.member.declared.outside=在类外部声明的类成员
not.loop.label=不是循环标签: ''{0}''
incompatible.modifiers=非法的修饰符组合: ''{0}'' 和''{1}''
modifier.not.allowed=此处不允许使用修饰符 ''{0}''
exception.never.thrown.try=相应的 try 块中从未抛出异常 ''{0}''
exception.already.caught.warn=无法访问的部分: {1, choice, 0#已|2#已经} 捕获 {1, choice, 0# 个异常|2# 个异常} ''{0}''
not.a.statement=不是语句
invalid.statement=语句无效
incompatible.types=不兼容的类型。实际为 {1}''，需要 ''{0}''
incompatible.types.reason.ambiguous.method.reference=<br/>原因: 方法引用不明确: ''{0}'' 和 ''{1}'' 均匹配
inaccessible.type=类 ''{0}'' 在此处无法访问
valid.switch.selector.types=byte、char、short 或 int
valid.switch.17.selector.types=char、byte、short、int、Character、Byte、Short、Integer、String 或枚举
dot.expected.after.super.or.this=应为 '.'
unqualified.super.disallowed=扩展方法中不允许非限定 super 引用
static.interface.method.call.qualifier=只能在包含接口类时调用 static 方法
non.static.symbol.referenced.from.static.context=无法从 static 上下文引用非 static {0} ''{1}'' 
private.symbol=''{0}'' 在 ''{1}'' 中具有 private 访问权限
protected.symbol=''{0}'' 在 ''{1}'' 中具有 protected 访问权限
package.local.symbol=''{0}'' 在 ''{1}'' 中不为 public。无法从外部软件包访问
visibility.access.problem=无法访问 ''{1}'' 中的 ''{0}''
visibility.module.access.problem=对 ''{1}'' 中 ''{0}'' 的访问被 {2} 阻止
array.type.expected=应为数组类型；实际为 ''{0}''
expression.expected=应为表达式
array.initializer.not.allowed=此处不允许数组初始值设定项
case.statement.outside.switch=case 语句位于 switch 外部
qualified.enum.constant.in.switch=枚举 switch case 标签必须是枚举常量的非限定名称
constant.expression.required=需要常量表达式
duplicate.default.switch.label=默认标签重复
duplicate.switch.label=标签 ''{0}'' 重复
switch.expr.empty='switch' 表达式没有任何 case 子句
switch.expr.incomplete='switch' 表达式未涵盖所有可能的输入值
switch.expr.no.result=Switch 表达式没有任何结果表达式
switch.expr.should.produce.result=switch 表达式应在所有执行路径中产生结果
switch.expr.rule.should.produce.result=switch 表达式规则应在所有执行路径中产生结果

illegal.forward.reference=非法前向引用
illegal.self.reference=非法自引用

unknown.class=未知类: ''{0}''
illegal.type.void=非法类型: 'void'
member.referenced.before.constructor.called=在调用父类型构造函数之前无法引用 ''{0}''
label.without.statement=无语句的标签
duplicate.label=标签 ''{0}'' 已在使用中
unclosed.comment=未闭合注释
exception.already.caught=已捕捉到异常 ''{0}''
exception.must.be.disjoint=多 catch 中的类型必须不相交: ''{0}'' 是 ''{1}'' 的子类
statement.must.be.prepended.with.case.label=必须在语句前面预置 case 标签
different.case.kinds.in.switch=switch 中使用了不同的 case 种类
void.type.is.not.allowed=此处不允许 'void' 类型
single.import.class.conflict=已在单类型导入中定义 ''{0}''
numeric.overflow.in.expression=表达式中出现数值溢出
static.member.accessed.via.instance.reference=通过实例引用访问 static 成员 ''{0}.{1}''
unresolved.label=未定义的标签: ''{0}''
deprecated.symbol=''{0}'' 已被弃用
marked.for.removal.symbol=''{0}'' 已被弃用并被标记为移除
qualifier.must.be.expression=限定符必须是表达式
cannot.resolve.symbol=无法解析符号 ''{0}''
class.is.already.defined.in.single.static.import=已在单一静态导入中定义类 ''{0}''
class.is.ambiguous.in.single.static.import=类 ''{0}'' 在单一静态导入中不明确
field.is.already.defined.in.single.static.import=已在单一静态导入中定义字段 ''{0}''
field.is.ambiguous.in.single.static.import=字段 ''{0}'' 在单一静态导入中不明确
annotation.interface.members.may.not.have.parameters=@interface 成员可能没有参数
class.in.default.package=类 ''{0}'' 位于默认软件包中

local.variable.is.never.used=''{0}'' 从未使用变量
local.variable.is.not.used.for.reading=''{0}'' 已被赋值，从未被访问
local.variable.is.not.assigned=变量 ''{0}'' 从未被赋值
private.field.is.not.used=private 字段 ''{0}'' 从未使用
field.is.not.used=字段 ''{0}'' 从未使用
field.is.not.used.for.reading={0} 字段 ''{1}'' 已被分配，从未被访问
private.field.is.not.assigned=private 字段 ''{0}'' 从未分配
parameter.is.not.used=形参 ''{0}'' 从未使用
pattern.variable.is.not.used=模式变量 ''{0}'' 从未使用
private.method.is.not.used=private 方法 ''{0}'' 从未使用
method.is.not.used=方法 ''{0}'' 从未使用
constructor.is.not.used=构造函数 ''{0}'' 从未使用
private.constructor.is.not.used=private 构造函数 ''{0}'' 从未使用
private.inner.class.is.not.used=private 内部类 ''{0}'' 从未使用
private.inner.interface.is.not.used=private 内部接口 ''{0}'' 从未使用
type.parameter.is.not.used=类型形参 ''{0}'' 从未使用
local.class.is.not.used=本地类 ''{0}'' 从未使用
class.is.not.used=类 ''{0}'' 从未使用
interface.is.not.used=接口 ''{0}'' 从未使用
enum.is.not.used=枚举 ''{0}'' 从未使用

hexadecimal.numbers.must.contain.at.least.one.hexadecimal.digit=十六进制数值必须至少包含一个十六进制数字
binary.numbers.must.contain.at.least.one.hexadecimal.digit=二进制数值必须至少包含一个二进制数字
integer.number.too.large=整数过大
long.number.too.large=长整数过大
malformed.floating.point.literal=浮点文字格式不正确
illegal.escape.character.in.character.literal=字符串文字中有非法转义字符
too.many.characters.in.character.literal=字符文字中的字符数过多
empty.character.literal=空字符文字
illegal.line.end.in.string.literal=字符文字中的行尾非法
unclosed.char.literal=字符文字未闭合
illegal.escape.character.in.string.literal=字符串文字中的非法转义字符
floating.point.number.too.large=浮点数过大
floating.point.number.too.small=浮点数过小
illegal.underscore=下划线非法
text.block.new.line=非法的文本块起始: 左引号后缺少新行
text.block.unclosed=文本块未闭合

# suppress inspection "UnusedProperty"
expected.identifier=应为标识符
# suppress inspection "UnusedProperty"
unexpected.token=意外的标记
expected.identifier.or.type=应为标识符或类型
# suppress inspection "UnusedProperty"
expected.rbracket=应为 ']'
# suppress inspection "UnusedProperty"
expected.expression=应为表达式
expected.semicolon=应为 ';'
# suppress inspection "UnusedProperty"
expected.lparen=应为 '('
# suppress inspection "UnusedProperty"
expected.rparen=应为 ')'
# suppress inspection "UnusedProperty"
expected.rbrace=应为 '}'
# suppress inspection "UnusedProperty"
expected.lbrace=应为 '{'
expected.parameter=应为形参
expected.comma=应为 ','
# suppress inspection "UnusedProperty"
expected.lparen.or.lbracket=应为 '(' 或 '['
# suppress inspection "UnusedProperty"
else.without.if='else' 没有 'if'
# suppress inspection "UnusedProperty"
catch.without.try='catch' 没有 'try'
# suppress inspection "UnusedProperty"
finally.without.try='finally' 没有 'try'
# suppress inspection "UnusedProperty"
expected.statement=应为语句
# suppress inspection "UnusedProperty"
expected.while=应为 'while'
# suppress inspection "UnusedProperty"
expected.catch.or.finally=应为 'catch' 或 'finally'
# suppress inspection "UnusedProperty"
expected.boolean.expression=应为布尔表达式
# suppress inspection "UnusedProperty"
expected.switch.label=应为 'case'、'default' 或 '}'
# suppress inspection "UnusedProperty"
expected.switch.rule=应为表达式、块或 throw 语句
error.cannot.resolve.class=无法解析类 ''{0}''
error.cannot.resolve.class.or.package=无法解析类或软件包 ''{0}''
expected.class.or.package=应为类或软件包
suspicious.name.assignment=''{0}'' 可能不应分配给 ''{1}''
suspicious.name.parameter=''{0}'' 可能不应作为参数 ''{1}'' 传递
suspicious.name.return=''{0}'' 可能不应从方法 ''{1}'' 返回
type.parameter.cannot.be.followed.by.other.bounds=类型形参后面不能跟随其他边界
generic.extend.exception=泛型类不能扩展 'java.lang.Throwable'
illegal.initializer=''{0}'' 的初始值设定项非法
class.cannot.inherit.from.its.type.parameter=类无法从其类型形参继承
cannot.resolve.package=无法解析软件包 {0}
override.not.allowed.in.interfaces=实现接口方法时不允许 @Override
declaration.not.allowed=此处不允许声明

underscore.identifier.error=从 Java 9 起，'_' 是关键字，不能用作标识符
underscore.lambda.identifier=不允许使用 '_' 作为 lambda 形参名称

assert.identifier.warn=自 Java 1.4 起，不支持使用 'assert' 作为标识符
enum.identifier.warn=自 Java 1.5 起，不支持使用 'enum' 作为标识符
underscore.identifier.warn=自 Java 9 起，不支持使用 '_' 作为标识符
# {0} = restricted identifier, like 'var', {1} = java version like '10'
restricted.identifier.warn=自 Java {1} 起的版本中不支持使用 ''{0}'' 作为类名
module.unwanted.modifier.warn=自 Java 10 起，禁止对 'requires java.base' 使用修饰符
yield.unqualified.method.warn=自 Java 14 起的版本中不支持对 'yield' 方法进行非限定调用

module.no.package=模块文件不应具有 'package' 语句
module.file.wrong.name=模块声明应位于名为 'module-info.java' 的文件中
module.file.duplicate=模块中已存在 'module-info.java'
module.duplicate.requires=重复的 ''requires'': {0}
module.duplicate.exports=重复的 ''exports'': {0}
module.duplicate.opens=重复的 ''opens'': {0}
module.duplicate.uses=重复的 ''uses'': {0}
module.duplicate.provides=重复的 ''provides'': {0}
module.duplicate.exports.target=重复的 ''exports'' 目标: {0}
module.duplicate.opens.target=重复的 ''opens'' 目标: {0}
module.duplicate.impl=重复的实现: {0}
module.file.wrong.location=模块声明应位于模块的源根中
module.open.duplicate.text=转到重复项
module.not.found=找不到模块: {0}
module.ambiguous=不明确的模块引用: {0}
module.not.on.path=模块不在依赖项中: {0}
module.cyclic.dependence=循环依赖关系: {0}
module.opens.in.weak.module=打开的模块中不允许 'opens'
package.not.found=找不到软件包: {0}
package.is.empty=软件包为空: {0}
module.service.enum=服务定义为枚举: {0}
module.service.alien=服务实现必须在 provides 指令所在的同一模块中定义
module.service.impl=服务实现类型必须为服务接口类型的子类型，或者具有 public static 无实参 'provider' 方法
module.service.abstract=该服务实现是 abstract 类: {0}
module.service.inner=服务实现为内部类: {0}
module.service.no.ctor=服务实现没有 public 默认构造函数: {0}
module.service.provider.type=''provider'' 方法返回类型必须是服务接口类型的子类型: {0}
module.service.unused=提供了服务接口，但未导出或使用
module.conflicting.reads=模块 ''{0}'' 同时从 ''{2}'' 和 ''{3}'' 读取软件包 ''{1}''
module.conflicting.packages=软件包 ''{0}'' 存在于另一个模块中: {1}
module.access.to.unnamed=软件包 ''{0}'' 在未命名的模块中声明，但模块 ''{1}'' 没有读取它
module.access.from.named=软件包 ''{0}'' 在模块 ''{1}'' 中声明，但后者没有将它导出到模块 ''{2}''
module.access.from.unnamed=软件包 ''{0}'' 在模块 ''{1}'' 中声明，但后者没有将它导出到未命名模块
module.access.does.not.read=软件包 ''{0}'' 在模块 ''{1}'' 中声明，但模块 ''{2}'' 没有读取它
module.access.not.in.graph=软件包 ''{0}'' 在模块 ''{1}'' 中声明，但后者不在模块图中
module.access.bad.name=软件包 ''{0}'' 在具有无效名称(''{1}'')的模块中声明

restricted.identifier=''{0}'' 是受限标识符，不能用于类型声明
restricted.identifier.reference=非法引用受限类型 ''{0}''

lvti.no.initializer=无法推断类型: 'var' 位于没有初始值设定项的变量上
lvti.lambda=无法推断类型: lambda 表达式需要显式目标类型
lvti.method.ref=无法推断类型: 方法引用需要显式目标类型
lvti.compound=复合声明中不允许 'var'
lvti.array=不允许将 'var' 作为数组的元素类型
lvti.null=无法推断类型: 变量初始值设定项为 'null'
lvti.void=无法推断类型: 变量初始值设定项为 'void'
lvti.selfReferenced=无法推断 ''{0}'' 的类型，它用于其自己的变量初始值设定项中

record.no.header=记录没有声明标头
record.header.regular.class=为非记录声明了记录标头
record.extends=不允许对记录使用 extends 子句
record.component.vararg.not.last=Vararg 记录组件必须为列表中的最后一项
record.component.cstyle.declaration=不允许 C 样式记录组件声明
record.component.restricted.name=记录组件名称 ''{0}'' 非法
record.instance.initializer=记录中不允许实例初始值设定项
record.instance.field=记录中不允许实例字段
record.accessor.wrong.return.type=组件访问器返回类型不正确。应为 ''{0}''，实际为 ''{1}''
record.canonical.constructor.wrong.parameter.type=记录组件 ''{0}'' 的形参类型不正确。应为 ''{1}''，实际为 ''{2}''
record.canonical.constructor.wrong.parameter.name=规范构造函数形参名称必须匹配记录组件名称。应为 ''{0}''，实际为 ''{1}''
record.constructor.call.in.canonical=规范构造函数不能委托给其他构造函数
record.no.constructor.call.in.non.canonical=非规范记录构造函数必须委托给其他构造函数
record.special.method.type.parameters={0} 不能有类型形参
record.special.method.non.public={0} 必须为 ''public''
record.special.method.stronger.access={0} 访问级别的限制不能超过记录访问级别(''{1}'')
record.special.method.throws={0} 无法声明抛出的异常
record.canonical.constructor=规范构造函数
record.compact.constructor=紧凑构造函数
record.accessor=记录组件访问器
record.component.not.initialized=记录组件 ''{0}'' 可能无法在规范构造函数中初始化
compact.constructor.in.regular.class=应为形参列表
record.compact.constructor.return=紧凑构造函数中不允许 'return' 语句
record.permits=记录不允许 permits 子句

insufficient.language.level=语言级别 ''{1}'' 不支持 {0}

cannot.select.from.a.type.parameter=无法从类型形参中选择
method.reference.expression.is.not.expected=不应在此处使用方法引用表达式
not.a.functional.interface={0} 不是函数接口
cannot.find.class=找不到类 {0}
cannot.infer.functional.interface.type=无法推断函数接口类型
lambda.expression.not.expected=不应在此处使用 lambda 表达式
lambda.parameters.consistency.message=不能在 lambda 表达式中将 'var' 和显式类型形参混合
target.method.is.generic=目标方法为泛型
multiple.non.overriding.abstract.methods.found.in.0=在 {0} 中找到多个非重写 abstract 方法
multiple.non.overriding.abstract.methods.found.in.interface.0=在接口 {0} 中找到多个非重写 abstract 方法
no.target.method.found=未找到目标方法
target.type.of.a.lambda.conversion.must.be.an.interface=lambda 转换的目标类型必须是接口
incompatible.parameter.types.in.lambda=lambda 表达式中的形参类型不兼容: 应为 {0}，但找到的是 {1}
incompatible.parameter.types.in.lambda.wrong.number.of.parameters=lambda 表达式中的形参类型不兼容: 参数的数量错误: 应为 {0} 个，但发现了 {1} 个
an.enclosing.instance.of.type.not.in.scope.method.reference.context=范围中没有类型 {0} 的封闭实例
parameterized.qualifier.on.static.method.reference.context=static 方法引用上的形参化限定符
static.method.referenced.through.receiver.method.reference.context=通过接收器引用 static 方法
static.method.referenced.through.non.static.qualifier.method.reference.context=通过非 static 限定符引用 static 方法
non.static.method.cannot.be.referenced.from.a.static.context.method.reference.context=无法从 static 上下文引用非 static 方法
abstract.method.0.cannot.be.accessed.directly.method.reference.context=无法直接访问 abstract 方法 ''{0}''
error.interface.member.clashes=@interface 成员与 {1} 中的 ''{0}'' 冲突
anonymous.class.implements.interface.cannot.have.type.arguments=匿名类实现接口；不能具有类型实参
formal.varargs.element.type.inaccessible.here=无法在此处访问正式的 vararg 元素类型 {0}
unexpected.type.class.expected=意外的类型: 应为类
repeated.interface=重复的接口
class.cannot.be.inherited.with.different.arguments={0} 不能用不同的参数继承: {1}
bad.type.in.switch.expression=switch 表达式中存在错误类型: {0} 无法转换为 {1}
switch.expression.cannot.be.void=switch 表达式的目标类型不能为 void
annotation.on.static.member.qualifying.type.family.name=移动类型注解
not.inner.class=''{0}'' 不是内部类
anonymous.class.implements.interface.cannot.have.qualifier=匿名类实现接口；new 不能有限定符
qualified.class.reference.not.allowed.in.qualified.new=限定 new 中不允许使用限定类引用
actual.type.argument.contradict.inferred.type=实际类型实参与推断的类型相矛盾
default.method.overrides.object.member=默认方法 ''{0}'' 重写 ''java.lang.Object'' 的成员
two.methods.are.inherited.with.same.signature={1} 中的方法 {0} 和 {3} 中的方法 {2} 使用相同的签名继承
cannot.select.from.parameterized.type=无法从形参化类型中选择
safevarargs.not.allowed.non.final.instance.methods=非 final 实例方法中不允许 @SafeVarargs
safevarargs.not.suppress.potentially.unsafe.operations=@SafeVarargs 不禁止潜在的不安全操作
safevarargs.not.applicable.for.reifiable.types=@SafeVarargs 不适用于可具体化的类型
type.parameter.has.incompatible.upper.bounds=类型形参 {0} 的上限不兼容: {1}
safevarargs.not.allowed.on.methods.with.fixed.arity=具有固定元数的方法不允许使用 @SafeVarargs
functional.interface.must.not.be.sealed.error.description=函数接口不能声明为 ''{0}''
sealed.type.inheritor.expected.modifiers=应为 {0}、{1} 或 {2} 修饰符
not.allowed.in.sealed.hierarchy=密封层次结构中不允许使用 ''{0}''
invalid.permits.clause=无效的 permits 子句: 必须密封 ''{0}''
invalid.permits.clause.direct.implementation=无效的许可条款: ''{0}'' 必须直接{1, choice, 1#扩展|2#实现} ''{2}''
sealed.must.have.inheritors=密封类必须有子类
permit.list.must.contain.outside.inheritors=密封类 permit 子句必须包含所有子类
permitted.subclass.must.have.modifier=所有 sealed 类的子类必须为 fianl、sealed 或 non-sealed 类型
permits.list.generics.are.not.allowed=允许列表中不支持泛型
local.classes.must.not.extend.sealed.classes=局部类不得扩展密封类
anonymous.classes.must.not.extend.sealed.classes=匿名类不得扩展密封类
class.not.allowed.to.extend.sealed.class.from.another.package=不允许类扩展另一个软件包中的密封类
class.not.allowed.to.extend.sealed.class.from.another.module=不允许类扩展另一个模块中的密封类
annotation.cannot.be.local=不允许局部注解
create.class.action.this.not.valid.java.qualified.name=这不是有效的 Java 限定名称
text.class.inherits.abstract.and.default={0} 从类型 {2} 和 {3} 继承 {1} 的抽象和默认值
text.class.inherits.unrelated.defaults={0} 从类型 {2} 继承 {1} 的不相关默认值
text.improper.formed.type=成型类型不正确；部分类型形参丢失
text.class.is.not.accessible={0} 在当前上下文中不可访问
text.class.cannot.access=无法访问 {0}
auto.closeable.resource=可自动关闭资源
annotation.type.permits=不允许为注解类型使用 permits 子句
safevararg.annotation.cannot.be.applied.for.record.component=@SafeVarargs 注解不能应用于记录组件
incompatible.switch.null.type=''{0}'' 无法转换为 ''{1}''
switch.illegal.fall.through.from=从模式的非法直落
switch.illegal.fall.through.to=到模式的非法直落
switch.dominance.of.preceding.label=标签由先前的 case 标签 ''{0}'' 支配
switch.total.pattern.and.default.exist='switch' 具有总模式和默认标签
switch.class.or.array.type.expected=类或数组
switch.constant.expression.required=常量表达式、模式或 null 为必需项
switch.statement.incomplete='switch' 语句未涵盖所有可能的输入值
switch.statement.empty='switch' 语句没有任何 case 子句
switch.invalid.selector.types=不支持 ''{0}'' 的选择器类型
bad.qualifier.in.super.method.reference.overridden=默认 super 调用中的类型限定符错误: 方法 {0} 在 {1} 中被重写
bad.qualifier.in.super.method.reference.extended=默认 super 调用中的类型限定符错误: 冗余接口 {0} 由 {1} 扩展
guarded.pattern.variable.must.be.final=受保护模式中使用的变量应当为 final 或有效 final
unexpected.type=意外类型。实际为 ''{1}'' ，需要 ''{0}''
generics.cannot.be.inherited.as.raw.and.generic=''{0}'' 不能作为原始类型和包含泛型类型实参 ''{1}'' 来继承
parameter.excluding.hierarchy.disable.text=不高亮显示继承方法的形参
type.pattern.expected=应为类型模式
duplicate.total.pattern.label=重复的总计模式
sealed.cannot.be.functional.interface=密封类不能用作函数接口
missing.package.statement.package.name.invalid=缺少软件包语句，但与文件路径相对应的软件包名称 ''{0}'' 无效
unreachable.statement.false.condition=循环条件始终为 false，使循环体不可到达
qualified.enum.constant.in.switch.remove.fix=移除限定符
static.method.cannot.be.annotated.with.override=Static 方法不能用 @Override 注解
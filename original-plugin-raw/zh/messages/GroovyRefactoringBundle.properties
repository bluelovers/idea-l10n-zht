introduce.variable.title=引入变量
only.in.groovy.files=此重构仅在 Groovy 文件中可用
selected.block.should.represent.an.expression=所选块应代表一个表达式
refactoring.is.not.supported.in.the.current.context=当前上下文中不支持重构
refactoring.is.not.supported.in.method.parameters=闭包或方法参数中不支持重构
declare.final.checkbox=声明 final(&F)
press.escape.to.remove.the.highlighting=按 Esc 移除高亮显示
selected.expression.has.void.type=所选表达式有空隙类型
introduced.variable.conflicts.with.parameter.0=引入的变量与参数 {0} 冲突
introduced.variable.conflicts.with.variable.0=引入的变量与局部变量 {0} 冲突
cannot.find.a.single.definition.to.inline.local.var=无法找到内联局部变量的单一定义
cannot.find.a.single.definition.to.inline.field=字段没有初始值设定项
local.variable.is.lvalue=要内联的变量在赋值中以左值形式出现
inline.local.variable.prompt.0.1=内联局部变量 ''{0}''?
extract.method.title=提取方法
selected.block.should.represent.a.statement.set=所选块应代表一组语句或表达式
multiple.output.values=所选代码段有多个输出值
selected.block.contains.invocation.of.another.class.constructor=所选块包含调用另一个类构造函数
specify.type.label=显式指定返回类型(&T)
signature.preview.border.title=签名预览
method.is.already.defined.in.class=方法 {0} 已在类 {1} 中定义。
method.is.already.defined.in.script=方法 {0} 已在脚本 {1} 中定义。
inline.method.title=内联方法
inline.method.border.title=内联
inline.method.label=方法 {0}
all.invocations.and.remove.the.method=内联所有调用并移除方法(&A)
all.invocations.in.project=内联项目中的所有调用(&A)
this.invocation.only.and.keep.the.method=仅内联此调用并保留方法(&T)
refactoring.cannot.be.applied.to.abstract.methods=重构不能应用于 abstract 方法
refactoring.cannot.be.applied.no.sources.attached=无法应用重构: 未附加任何源
refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow=当 return 语句中断执行流时，不支持重构
refactoring.cannot.be.applied.to.constructors=重构不能应用于构造函数
refactoring.is.not.supported.in.parameter.initializers=参数初始值设定项中不支持重构
refactoring.is.available.only.for.method.calls=重构仅适用于方法调用
method.is.not.accessible.form.context.0=不能从调用站点访问内联方法中使用的方法 {0}
field.is.not.accessible.form.context.0=不能从调用站点访问内联方法中使用的字段 {0}
super.reference.is.used=内联方法中使用的 super 调用在内联后将无效。
variable.conflicts.with.parameter.0=所选名称与参数 {0} 冲突
variable.conflicts.with.variable.0=所选名称与局部变量 {0} 冲突
variable.conflicts.with.field.0=所选名称与字段 {0} 冲突
error.wrong.caret.position.method.name=文本光标应置于要重构的方法的名称处。
method.duplicate=具有签名 {0} 的方法已在 {1} 中定义
replace.setter.for.property=属性 ''{0}'' 的默认 setter 将被覆盖
replace.getter.for.property=属性 ''{0}'' 的默认 getter 将被覆盖
name.is.wrong=名称 ''{0}'' 不正确
return.type.is.wrong=返回类型错误
type.for.parameter.is.incorrect=形参 ''{0}'' 的类型不正确
specify.default.value=为形参 ''{0}'' 指定默认值或初始值设定项
refactored.method.will.cover.closure.property=重构的方法将重写 {1} 中的闭包属性 ''{0}''
changeSignature.not.throwable.type=类型错误: 异常的 ''{0}''，应扩展 java.lang.Throwable
changeSignature.wrong.type.for.exception=类型错误: 异常的 ''{0}''
changeSignature.no.type.for.exception=指定异常的类型
no.occurrences.found=未找到匹配项
class.does.not.exist.in.the.module=模块中不存在类。要创建吗?
closure.uses.external.variables=闭包使用外部非常量变量
class.language.is.not.groovy=目标类的语言不是 Groovy
implicit.getter.will.by.overridden.by.method=属性 {0} 的隐式 getter 将被方法 {1} 重写
implicit.setter.will.by.overridden.by.method=属性 {0} 的隐式 setter 将被方法 {1} 重写
usage.will.be.overridden.by.method=用法 {0} 将被方法 {1} 重写
target.class.must.not.be.script=目标类不得为脚本
rename.is.not.applicable.to.implicit.elements=无法重命名隐式元素
rename.member=重命名 {0}
rename.property=重命名属性 ''{0}''
cannot.introduce.field.in.script=范围内没有类
cannot.introduce.field.in.interface=无法在接口中引入字段
expression.contains.errors=表达式包含错误
field.0.is.already.defined=字段 {0} 已定义
access.to.created.field.0.will.be.overridden.by.method.1=对字段 {0} 的访问将被 {1} 重写
final.field.cant.be.initialized.in.cur.method=无法在当前方法中初始化最终字段
Field.cannot.be.final.because.replaced.variable.has.lhs.usages=所选变量用于写入
field.cannot.be.initialized.in.field.declaration=无法在声明中初始化字段
field.cannot.be.initialized.in.constructor(s)=无法在构造函数中初始化字段
selected.variable.is.used.for.write=所选变量用于写入
there.is.no.method.or.closure=没有包含方法或闭包
remove.parameter.0.no.longer.used=移除不再使用的形参 ''{0}''
convert.to.java.refactoring.name=转换为 Java
convert.to.java.can.work.only.with.groovy=转换为 Java 重构仅适用于 Groovy 文件
files.to.be.converted=要转换的文件
converting.files.to.java=正在将文件转换为 Java
converting.files.to.static=正在将文件转换为 @CompileStatic
intention.converting.to.static=将转换应用于 @CompileStatic
intention.converting.to.static.family=转换为 @CompileStatic
rename.groovy.property=重命名 Groovy 属性(&G)
reference.to.accessor.0.is.used=无法内联对访问器 <bold>{0}<bold> 的引用。
variable.is.accessed.for.writing=变量 ''{0}'' 被访问以进行写入
introduce.closure.parameter.elements.header=正在将参数添加到闭包
cannot.process.usage.in.language.{0}=无法处理 {0} 中的用法
you.cannot.pass.as.parameter.0.because.you.remove.1.from.base.method=您无法将 ''{0}'' 作为参数传递，因为您从方法中移除了与其关联的参数 ''{1}''。您应当在参数表中取消选择“移除不再使用的形参 ''{0}''”或取消选择参数 ''{1}''。
selected.expression.should.not.be.lvalue=所选表达式不应位于赋值的左侧
cannot.inline.0.=无法内联 {0}
ref.0.will.not.be.resolved.outside.of.current.context=不会在当前上下文范围外解析引用 ''{0}''
cannot.rename.property.0=无法重命名重写方法 <bold>''{1}''</bold> 的属性 <bold>''{0}''</bold>
cannot.inline.reference.0=无法内联引用 ''{0}''
cannot.rename.script.class.to.0=无法将脚本类 ''{0}'' 重命名为 ''{1}''
extract.method.dialog.explicit.return.checkbox=使用显式 return 语句(&X)
inplace.introduce.constant.move.checkbox=移至另一个类(&M)
type.label=类型(&T):
name.label=名称(&N):
introduce.constant.class.label=对类引入(完全限定名称)(&C):
replace.all.occurrences.checkbox=替换所有匹配项(&A)
initialize.in.label=初始化位置(&I):
initialize.in.border.title=初始化位置
initialize.in.current.method.choice=当前方法(&M)
initialize.in.field.declaration.choice=字段声明(&D)
initialize.in.class.constructor.choice=类构造函数(&C)
initialize.in.setup.method.choice=setUp 方法
visibility.border.title=可见性
visibility.private.choice=私有(&V)
visibility.public.choice=public(&B)
visibility.protected.choice=Protected(&O)
visibility.property.choice=属性(&R)

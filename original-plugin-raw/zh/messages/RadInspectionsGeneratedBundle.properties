DFAStrings.CppDFAArrayIndexOutOfBoundsDescription=报告索引可能超出数组或已分配缓冲区的范围的数组或指针变量访问表达式
DFAStrings.CppDFAArrayIndexOutOfBoundsTitle=索引可能超出范围的数组访问表达式
DFAStrings.CppDFAConstantConditionsDescription=报告始终为 true 或 false 的条件以及值被静态证明为常量的表达式
DFAStrings.CppDFAConstantConditionsTitle=始终为 true 或 false 的条件
DFAStrings.CppDFAConstantFunctionResultDescription=报告返回值始终为同一个常量的函数
DFAStrings.CppDFAConstantFunctionResultTitle=返回值始终为同一个常量的函数
DFAStrings.CppDFAConstantParameterDescription=报告始终具有相同值的函数形参
DFAStrings.CppDFAConstantParameterTitle=始终具有相同值的函数形参
DFAStrings.CppDFADeletedPointerDescription=报告引用已被删除运算符或 free(void* ptr) 函数删除的内存的指针的用法
DFAStrings.CppDFADeletedPointerTitle=引用已删除内存的指针的用法
DFAStrings.CppDFAEndlessLoopDescription=报告仅通过抛出异常退出的 'for'、'while'、'do-while' 和 'goto' 语句
DFAStrings.CppDFAEndlessLoopTitle=无限循环语句
DFAStrings.CppDFAInfiniteRecursionDescription=报告除非抛出异常否则无限调用自己的函数
DFAStrings.CppDFAInfiniteRecursionTitle=无限调用自己的函数
DFAStrings.CppDFAInvalidatedMemoryDescription=报告对无效容器的内容的引用
DFAStrings.CppDFAInvalidatedMemoryTitle=对无效容器的内容的引用
DFAStrings.CppDFALocalValueEscapesFunctionDescription=报告对通过返回、对全局变量或字段赋值转义该函数的局部值的引用
DFAStrings.CppDFALocalValueEscapesFunctionTitle=引用转义函数的局部值
DFAStrings.CppDFALocalValueEscapesScopeDescription=报告引用了转义其作用域的局部变量的变量
DFAStrings.CppDFALocalValueEscapesScopeTitle=引用转义其作用域的局部变量
DFAStrings.CppDFALoopConditionNotUpdatedDescription=报告循环内未更新的循环条件
DFAStrings.CppDFALoopConditionNotUpdatedTitle=循环内未更新的循环条件
DFAStrings.CppDFAMemoryLeakDescription=报告在无法访问之前未释放的内存分配(使用 'new' 或 'malloc()')
DFAStrings.CppDFAMemoryLeakTitle=未释放的内存分配
DFAStrings.CppDFANotInitializedFieldDescription=报告在使用之前可能尚未初始化的字段。初始化和使用可能发生在不同的函数中。
DFAStrings.CppDFANotInitializedFieldTitle=使用前可能尚未初始化的字段
DFAStrings.CppDFANullDereferenceDescription=报告可能包含 nullptr 的指针的解引用
DFAStrings.CppDFANullDereferenceTitle=可能包含 nullptr 的指针的解引用
DFAStrings.CppDFATimeOverDescription=数据流检查已达到时间或内存限值，无法在上下文敏感或上下文不敏感模式下进行评估
DFAStrings.CppDFATimeOverTitle=数据流检查已超时
DFAStrings.CppDFAUnreachableCodeDescription=报告从未在任何控制流中执行并且可以安全移除的代码片段
DFAStrings.CppDFAUnreachableCodeTitle=不可到达的代码
DFAStrings.CppDFAUnreachableFunctionCallDescription=报告其调用从未使用的函数。此类函数也永远不会被执行。
DFAStrings.CppDFAUnreachableFunctionCallTitle=其调用从未使用的函数
DFAStrings.CppDFAUnreadVariableDescription=报告已声明但从未访问以进行读取的局部变量
DFAStrings.CppDFAUnreadVariableTitle=已声明但从未访问以进行读取的局部变量
DFAStrings.CppDFAUnusedValueDescription=报告赋值后从未使用过的变量值
DFAStrings.CppDFAUnusedValueTitle=赋值后从未使用过的变量值
Strings.AClassDefinitionCanBeMarkedAsFinalSoItCannotBeInheritedFrom=类定义可被标记为 final，因此它不能被继承
Strings.AClassIsNeverUsed=类从未被使用
Strings.ACoroutineRelatedFunctionWhichIsRequiredByTheCStandardCannotBeResolved=不能解析 C++20 标准要求的协程相关函数
Strings.ADeclarationDoesNotDeclareAnything=声明未声明任何内容
Strings.ADeclarationSpecifierIsIgnoredWhenThereAreNoDeclarators=没有声明符时忽略声明说明符
Strings.ADeclaratorIsNeverUsed=声明符从未被使用
Strings.ADeclaratorIsOnlyAssignedButNeverAccessed=声明符只是被赋值，从未被访问
Strings.ADeclaratorIsUsedOnlyInUnevaluatedContext=声明符仅在未求值的上下文中使用
Strings.AEnumeratorIsNeverUsed=枚举器从未被使用
Strings.AFormatStringOfBoostFormatContainsALegacyPrintfLikeCodeTypeSpecifierIsNotTakenIntoAccount=boost\:\:format 的格式字符串包含遗留的类似 printf 的代码；未考虑类型说明符
Strings.AFormatStringOfBoostFormatContainsAnErroneousFormatCode=boost\:\:format 的格式字符串包含错误的格式指令
Strings.AFunctionDefinitionInAHeaderFileThatWillCauseMultipleDefinitionLinkageError=将导致多定义链接错误的头文件中的函数定义
Strings.AFunctionIsNotImplemented=函数未被实现
Strings.AFunctionOrALambdaWithNonVoidReturnTypeShouldReturnAValue=具有非 void 返回值类型的函数或 lambda 应返回一个值
Strings.AFunctionOrALambdaWithNonVoidReturnTypeShouldReturnAValue8=具有非 void 返回值类型的函数或 lambda 应返回一个值
Strings.ALambdaCaptureIsNeverUsed=lambda 捕获从未被使用
Strings.ALocalDeclarationHidesAnotherLocalDeclaration=一个局部声明会隐藏另一个局部声明
Strings.ALocalDeclarationInsideALambdaHidesAnUncapturedLocalDeclaration=lambda 内的局部声明会隐藏未被捕获的局部声明
Strings.ALocalVariableMightNotBeInitialized=局部变量可能未被初始化
Strings.ANonOverridingVirtualFunctionInAFinalOrSealedClassCannotBeOverriddenSoThevirtualSpecifierIsRedundant=不能重写 final 或 sealed 类中的非重写虚拟函数，因此 'virtual' 说明符冗余
Strings.ANumericTypeCanBeReplacedWithauto=数值类型可被替换为 'auto'
Strings.APolymorphicClassWithANonVirtualPublicDestructor=带有非虚拟 public 析构函数的多态类
Strings.APrivateSpecialMemberFunctionShouldBeDefinedOrDeleted=必须定义或删除 private 特殊成员函数
Strings.AStandardAlgorithmAcceptingRangeIteratorsIsUsedInsteadOfTheVariantAcceptingAnIteratorAndACount=使用接受范围迭代器的标准算法，而非接受迭代器和计数的变体
Strings.ATemplateParameterFromAnOuterScopeIsShadowedByADeclarationWithTheSameName=来自外部作用域的模板形参被同名的声明遮蔽
Strings.ATypeAliasIsNeverUsed=类型别名从未被使用
Strings.ATypeTraitCanBeSimplifiedUsingATemplateAliasOrAVariableTemplate=可以使用模板别名或变量模板简化类型特征
Strings.AVariableDefinitionInAHeaderFileThatWillCauseMultipleDefinitionLinkageError=将导致多定义链接错误的头文件中的变量定义
Strings.AVirtualFunctionIsMarkedfinalAndDoesNotOverrideABaseFunction=虚拟函数被标记为 'final' 并且不会重写基函数
Strings.AbstractFinalClass=abstract final 类
Strings.AccessSpecifierDoesNotAffectAnyDeclaration=访问说明符不会影响任何声明
Strings.AccessSpecifierDoesNotChangeAccessibilityLevel=访问说明符不会更改访问级别
Strings.AddingCvQualifiersToReferencesHasNoEffect=向引用添加 cv-限定符没有影响
Strings.AddingCvQualifiersToReferencesHasNoEffect9=向引用添加 cv-限定符没有影响
Strings.AlgorithmAcceptingAnIteratorAndACountCanBeUsed=可以使用接受迭代器和计数的算法
Strings.AlgorithmAcceptingIteratorsIsUsedInsteadOfTheCorrespondingAlgorithmFromStdRanges=使用接受迭代器的算法而非来自 std\:\:ranges 的相应算法
Strings.AlgorithmOperatingOnRangesCanBeUsed=可以使用在范围上运行的算法
Strings.AnAbstractFinalClassIsMarkedAsfinalOrsealed=abstract final 类被标记为 'final' 或 'sealed'
Strings.AnAccessSpecifierDoesNotAffectAnyDeclarationAndIsRedundant=访问说明符不影响任何声明并且冗余
Strings.AnAccessSpecifierDoesNotChangeAccessibilityLevelAndIsRedundant=访问说明符不会更改可访问性级别并且冗余
Strings.AnArgumentOfBoostFormatShouldContainEitherPositionalNNOrSerialsArgumentsNotBoth=boost\:\:format 的实参应包含位置(%N%, %|N$...|)实参或序列(%|...|, %s)实参，而不是两者
Strings.AnIncompleteTypeIsUsedInsideATemplateDeclarationOrDefinition=在模板声明或定义内使用了不完整的类型
Strings.AnObjectMemberMightNotBeInitialized=对象成员可能未被初始化
Strings.AnOverrideFunctionRedefinesADefaultParameterArgumentPreviouslyDefinedInABaseFunction=重写函数重新定义之前在基函数中定义的默认形参实参
Strings.AwaiterTypeIsNotAClass=awaiter 类型不是类
Strings.BackslashAndNewlineAreSeparatedBySpace=反斜杠和换行符用空格分隔
Strings.BackslashIsNotALineContinuatorBecauseThereIsASpaceBetweenItAndTheEndOfTheLine=反斜杠不是续行符，因为它和行尾之间有一个空格
Strings.BadFormatCodeForBoostFormat=boost\:\:format 中的格式指令不正确
Strings.BinaryOperatorActsOnEqualOperands=二进制运算符用作相等的操作数
Strings.BinaryOperatorActsOnEqualOperands40=二进制运算符用作相等的操作数
Strings.BinaryOperatorActsOnIdenticalOperands=二进制运算符用作相同的操作数
Strings.BinaryOperatorActsOnIdenticalOperands39=二进制运算符用作相同的操作数
Strings.BindingRValueToLValueReferenceIsNonStandardMicrosoftCExtension=将 r-value 绑定到 l-值引用为非标准 Microsoft C++ 扩展
Strings.BindingRValueToLValueReferenceIsNonStandardMicrosoftCExtension2=将 r-value 绑定到 l-值引用为非标准 Microsoft C++ 扩展
Strings.BracesCanBeSafelyRemovedWithoutChangingCodeSemantics=可以安全地移除大括号而不更改代码语义
Strings.CStyleCastIsUsedInsteadOfACCast=使用 C 样式的转换，而非 C++ 转换
Strings.CStyleCastIsUsedInsteadOfACCast1=使用 C 样式的转换，而非 C++ 转换
Strings.CallOfDeletedCopyConstructorElidedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension=复制初始化过程中省略了已删除的复制构造函数的调用。这是非标准的 Microsoft C++ 扩展。
Strings.CallOfDeletedCopyConstructorElidedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension5=复制初始化过程中省略了已删除的复制构造函数的调用。这是非标准的 Microsoft C++ 扩展。
Strings.CallToAVirtualFunctionInsideAConstructorDestructorIsResolvedAtCompileTime=在编译时解析了对构造函数/析构函数内虚拟函数的调用
Strings.CallToAVirtualFunctionInsideAConstructorDestructorWillResultInAPureVirtualFunctionCall=构造函数/析构函数内虚拟函数的调用将导致纯虚拟函数调用
Strings.CallsToPureVirtualFunctionsInsideConstructorsAndDestructorsAreARuntimeError=在构造函数和析构函数内调用纯虚拟函数将导致运行时错误
Strings.CannotResolveARequiredCoroutineFunction=不能解析必需的协程函数
Strings.CastIsRedundantAndCanBeDeleted=转换冗余，可以删除
Strings.CastingFromNullptrToPointerTypeWithReinterpretCastIsNonStandardMicrosoftCExtension=使用 reinterpret_cast 将 nullptr 转换为指针类型为非标准 Microsoft C++ 扩展
Strings.CastingFromNullptrToPointerTypeWithReinterpretCastIsNonStandardMicrosoftCExtension1=使用 reinterpret_cast 将 nullptr 转换为指针类型为非标准 Microsoft C++ 扩展
Strings.ClassCanBeMadeFinal=类可被设为 final
Strings.ClassConstructorDoesntInitializeAFieldExplicitlyOrImplicitly=类构造函数不会显式或隐式初始化字段
Strings.ClassIsAbstractButNotExplicitlyDeclaredAsSuch=类为 anstract，但未显式进行此类声明
Strings.ClassIsNeverUsed=类从未使用
Strings.ClassMemberFunctionHidesANonVirtualFunctionFromABaseClass=类成员函数对基类隐藏非虚拟函数
Strings.ClassMemberFunctionHidingANonVirtualFunctionFromABaseClass=从基类隐藏非虚拟函数的类成员函数
Strings.ClassShouldHaveAUserDefinedConstructorBecauseOfAnUninitializedDataMember=由于未初始化的数据成员，类应该具有用户定义的构造函数
Strings.ClassShouldHaveAUserDefinedConstructorBecauseOfAnUninitializedDataMember25=由于未初始化的数据成员，类应该具有用户定义的构造函数
Strings.ComparisonOfUnsignedExpressionWith=将无符号表达式与 0 比较
Strings.ComparisonOfUnsignedExpressionWith41=将无符号表达式与 0 比较
Strings.CompileTimeConstantExpressionCanBeReplacedByEithertrueOrfalse=编译时常量表达式可由“true”或“false”替换
Strings.CompileTimeIntegralConstantExpressionOrNullptrIsConvertedToBoolAndCanBeReplacedBytrueOrfalse=编译时整型常量表达式或 nullptr 被转换为 bool 并且可被替换为 'true' 或 'false'
Strings.ConceptIsNeverUsed=概念从未被使用
Strings.ConstQualificationOfParametersHasAnEffectOnlyInFunctionDefinitions=形参的 const 限定仅在函数定义中有作用
Strings.ConstQualifiedParameterInAFunctionDeclaration=函数声明中的 const 限定参数
Strings.ConstevalIfIsAlwaysConstantDescription=consteval if 始终为常量
Strings.ConstevalIfIsAlwaysConstantTitle=consteval if 始终为常量
Strings.ConstructorOfASmartPointerBoostStdSharedPtrUniquePtrIsUsedInsteadOfTheCorrespondingMakeSharedMakeUniqueMakeFunctionsAreExceptionSafeAndMoreEfficient=使用智能指针的构造函数(boost/std\:\:shared_ptr/unique_ptr)，而非相应的 make_shared/make_unique。Make 函数为异常安全函数且更高效。
Strings.ConstructorOfSmartPointerIsUsedInsteadOfItsMakeFunction=使用智能指针的构造函数，而非其 make 函数
Strings.CppConditionalExpressionCanBeSimplifiedDescription=可以简化条件表达式
Strings.CppConditionalExpressionCanBeSimplifiedTitle=可以简化条件表达式
Strings.CppEvaluationFailureDescription=由于 'constexpr' 计算期间出错，表达式或声明符值的计算结果不是常量。
Strings.CppEvaluationFailureTitle=编译时间计算失败
Strings.CppEvaluationInternalFailureTitle=[INTERNAL] 编译时间计算失败
Strings.CppRedundantComplexityInComparison=可以简化表达式
Strings.CppRedundantConditionalExpressionDescription=冗余条件表达式
Strings.CppRedundantConditionalExpressionTitle=冗余条件表达式
Strings.CppRedundantDereferencingAndTakingAddressDescription=冗余的取消引用和获取地址
Strings.CppRedundantDereferencingAndTakingAddressTitle=冗余的取消引用和获取地址
Strings.DeclarationAndAssignmentCanBeJoined=声明和赋值可以结合
Strings.DeclarationDoesNotDeclareAnything=声明不会声明任何内容
Strings.DeclarationOfANonOverridingVirtualFunctionInAFinalOrSealedClass=final 或 sealed 类中非重写虚拟函数的声明
Strings.DeclarationOfAVariableAndAssignmentToItCanBeJoined=可以联接变量声明和对它的赋值
Strings.DeclarationSpecifierWithNoDeclarators=无声明符的声明说明符
Strings.DeclarationSpecifierlongCanNotBeCombinedWithfloat=声明说明符 'long' 不能与 'float' 组合
Strings.DeclaratorDisambiguatedAsAFunctionDeclaration=以函数声明区分声明符
Strings.DeclaratorIsDisambiguatedAsAFunctionDeclarationMakeSureAVariableDefinitionIsNotIntendedInstead=声明符被澄清为函数声明。请确保变量定义是无意的。
Strings.DeclaratorIsNeverUsed=从不使用声明符
Strings.DeclaratorIsOnlyAssignedButNeverAccessed=声明符只是被赋值，从未被访问
Strings.DeclaratorIsUsedOnlyInUnevaluatedContext=仅在未求值的上下文中使用声明符
Strings.DefaultCaseIsNotHandledInASwitchStatement=switch 语句中的默认 case 不作处理。
Strings.DefaultCaseIsNotHandledInASwitchStatement20=switch 语句中的默认 case 不作处理。
Strings.DefaultInitializationOfAConstQualifiedObjectOfATypeWithoutAUserProvidedDefaultConstructor=不使用用户提供的默认构造函数对类型的 const 限定对象的默认初始化
Strings.DefaultInitializationOfAConstQualifiedObjectOfATypeWithoutAUserProvidedDefaultConstructor3=不使用用户提供的默认构造函数对类型的 const 限定对象的默认初始化
Strings.DefaultedSpecialMemberFunctionIsImplicitlyDeleted=默认的特殊成员函数被隐式删除
Strings.DeletingAVoidPointer=删除无效的指针
Strings.DeletingAVoidPointerIsUndefinedBehavior=删除 void 指针是未定义的行为
Strings.DependentTemplateWithouttemplateKeyword=没有“template”关键词的依赖模板
Strings.DependentTemplateWithouttemplateKeyword24=没有“template”关键词的依赖模板
Strings.DependentTypeWithouttypenameKeyword=没有“typename”关键词的依赖类型
Strings.DependentTypeWithouttypenameKeyword23=没有“typename”关键词的依赖类型
Strings.DeprecatedregisterStorageClassSpecifier=已被弃用的 'register' 存储类说明符
Strings.DereferenceOperatorLimitIsExceeded=超出解引用运算符限制
Strings.DereferenceOperatorLimitIsExceeded10=超出解引用运算符限制
Strings.DetectsLeakProneResourceAcquisitionFreeingConstructs=检测易泄漏的资源获取/释放结构
Strings.DontIntroduceANamespaceDefinitionOnlyForClassSpecializationSpecializationCanBeDefinedUsingQualifiedClassName=请勿仅为类专用化引入命名空间定义，可以使用限定类名定义专用化
Strings.DontIntroduceAVariableBeforeYouNeedToUseIt=在需要使用变量之前，请勿引入变量
Strings.ElaboratedTypeSpecifierIsRedundantAndCanBeDeleted=详细类型说明符冗余，可以删除
Strings.EmptyParameterListInLambdaDeclaratorCanBeDeleted=可以删除 lambda 声明符中的空形参列表
Strings.EnforceBracesIndoWhileStatement=在 'do-while' 语句中强制使用大括号
Strings.EnforceBracesInforStatement=在 'for' 语句中强制使用大括号
Strings.EnforceBracesInifStatement=在 'if' 语句中强制使用大括号
Strings.EnforceBracesInwhileStatement=在 'while' 语句中强制使用大括号
Strings.EnforceFunctionDeclarationStyle=强制函数声明样式
Strings.EnforceNestedNamespacesStyle=强制嵌套命名空间样式
Strings.EnforceOverridingDestructorStyle=强制重写析构函数样式
Strings.EnforceOverridingFunctionStyle=强制重写函数样式
Strings.EnforceTheOrderOfCvQualifiers=强制 cv 限定符的顺序
Strings.EnforceTheOrderOfCvQualifiers_Description=强制 cv 限定符的顺序
Strings.EnforceThePlacementOfCvQualifiers=强制 cv 限定符的位置
Strings.EnforceThePlacementOfCvQualifiers_Description=强制 cv 限定符的位置
Strings.EnforceTheSyntaxUsedToDefineNestedNamespaces=强制用于定义嵌套命名空间的语法
Strings.EnforceThevirtualAndoverrideSpecifiersOnOverridingDestructors=在重写析构函数上强制使用 'virtual' 和 'override' 说明符
Strings.EnforceThevirtualAndoverrideSpecifiersOnOverridingFunctions=在重写函数上强制使用 'virtual' 和 'override' 说明符
Strings.EnforceTypeAliasCodeStyle=强制类型别名代码样式
Strings.EnforceUsageOfTheTrailingReturnTypeOrTheRegularReturnTypeSyntax=强制使用尾随返回值类型或常规返回值类型语法
Strings.EnforceUsageOfTypedefsOrTypeAliasesDependingOnTheSyntaxStyleSetting=根据语法样式设置强制使用 typedef 或类型别名
Strings.EntityIsDeprecated=实体已弃用
Strings.EntityIsDeprecated37=实体已弃用
Strings.EnumeratorIsNeverUsed=从不使用枚举
Strings.ExplicitSpecializationInNonNamespaceScope=非命名空间范围内的显式专用化
Strings.ExplicitSpecializationsOfATemplateInNonNamespaceScope=模板显式专用于非命名空间作用域
Strings.ExplicitlyDefaultedSpecialMemberFunctionIsImplicitlyDeleted=显式默认的特殊成员函数被隐式删除
Strings.ExpressionWhichEvaluatesToZeroIsUsedAsANullPointerConstant=求值结果为零的表达式被用作 null 指针常量
Strings.ExpressionWhichEvaluatesToZeroIsUsedAsANullPointerConstant27=求值结果为零的表达式被用作 null 指针常量
Strings.FinalFunctionInAFinalClass=final 类中的 final 函数
Strings.FinalNonOverridingVirtualFunction=final 非重写虚拟函数
Strings.ForExampleWhenIteratingOnKeyValuePairsStdViewsKeysAllowsToIgnoreTheValues=例如，对键值对进行迭代时，std\:\:views\:\:keys 允许忽略这些值。
Strings.ForLoopCanBeReplacedWithWhileLoop=for 循环可被替换为 while 循环
Strings.ForLoopWithoutInitStatementAndUpdateExpressionIsEquivalentToWhileLoop=没有 init 语句和更新表达式的 for 循环等效于 while 循环
Strings.FormatStringContainsAPotentialError=格式字符串包含潜在错误
Strings.FormatStringContainsAnInvalidPrintfFormatSpecifier=格式字符串包含无效的 printf 格式说明符
Strings.ForwardEnumDeclarationWithoutUnderlyingTypeDescription=ISO C++ 禁止没有基础类型的枚举的前向声明
Strings.ForwardEnumDeclarationWithoutUnderlyingTypeTitle=没有基础类型的前向枚举声明
Strings.FunctionIsNotImplemented=不实现函数
Strings.FunctionParameterIsNeverUsed=函数形参从未被使用
Strings.FunctionResultShouldBeUsedDescription=函数返回应在调用点处理的类型的值
Strings.FunctionResultShouldBeUsedTitle=应使用函数结果
Strings.FunctionReturnsByConstValue=根据 const 值返回函数
Strings.FunctionalStyleCastIsUsedInsteadOfACCast=使用函数样式转换，而非 C++ 转换
Strings.FunctionalStyleCastIsUsedInsteadOfACCast2=使用函数样式转换，而非 C++ 转换
Strings.GuardedHeaderHasAlreadyBeenIncluded=已包含带有保护符的标头
Strings.GuardedHeaderHasAlreadyBeenIncluded50=已包含带有保护符的标头
Strings.HidingAnUncapturedLocalDeclaration=隐藏未被捕获的局部声明
Strings.HidingLocalDeclaration=隐藏局部声明
Strings.IfStatementWithConstantConditionCanBeReplacedByifConstexpr=包含常量条件的 if 语句可被替换为 'if constexpr'
Strings.IfStatementWithConstantConditionCanBeReplacedByifConstexpr14=包含常量条件的 if 语句可被替换为 'if constexpr'
Strings.IfStdIsConstantEvaluatedCanBeReplacedDescription='if' 可被替换为 'if consteval'
Strings.IfStdIsConstantEvaluatedCanBeReplacedTitle='if' 可被替换为 'if consteval'
Strings.ImplicitConversionToIncompatiblePointerType=隐式转换为不兼容的指针类型
Strings.ImplicitConversionToIncompatiblePointerType32=隐式转换为不兼容的指针类型
Strings.ImplicitConversionToLessQualifiedPointerType=隐式转换为指针类型并丢失限定符
Strings.ImplicitConversionToLessQualifiedPointerType33=隐式转换为指针类型并丢失限定符
Strings.ImplicitDefaultConstructorIsNotAvailable=隐式默认构造函数不可用
Strings.ImplicitDefaultConstructorIsNotAvailableBecauseABaseClassOrAClassMemberDoesNotHaveAnAccessibleDefaultConstructor=隐式默认构造函数不可用，因为基类或类成员没有可访问的默认构造函数
Strings.ImplicitIntegerToPointerConversion=隐式整数到指针转换
Strings.ImplicitIntegerToPointerConversion30=隐式整数到指针转换
Strings.ImplicitPointerToIntegerConversion=隐式指针到整数转换
Strings.ImplicitPointerToIntegerConversion31=隐式指针到整数转换
Strings.InHLSLoutParametersMustBeAssignedBeforeExitingTheFunction=在 HLSL 中，在退出函数之前必须为 'out' 形参赋值
Strings.IncludeGuardIsNotFoundAtTheBeginningOfAHeaderFile=在头文件的开头找不到 include 保护
Strings.InconsistentNaming_Description=名称与为此类符号定义的命名样式不匹配
Strings.InconsistentNaming_Text=命名不一致
Strings.IncorrectSpacing=间距不正确
Strings.IncrementingExpressionOfTypeBool=bool 类型的增量表达式
Strings.IncrementingExpressionOfTypeBoolIsDeprecatedInCAndRemovedInC=bool 类型的递增表达式在 C++11 中被弃用，在 C++17 中已被移除
Strings.InvalidPrintfFormatSpecifier=无效的 printf 格式说明符
Strings.KeyworddefaultIsUsedAsIdentifier=关键词“default”用作标识符
Strings.LambdaCanBeRewrittenToUseExplicitTemplateParameters=可重写 lambda 以使用显式模板形参
Strings.LambdaCanBeRewrittenToUseExplicitTemplateParameters19=可重写 lambda 以使用显式模板形参
Strings.LambdaCaptureIsNeverUsed=lambda 捕获从未被使用
Strings.LegacyFormatCodeForBoostFormat=boost\:\:format 中的格式指令已过时
Strings.LocalVariableCanBeMadeConst=局部变量可被设为 const
Strings.LocalVariableCanBeMadeConst8=局部变量可被设为 const
Strings.LocalVariableIsNeverUsedButMayHaveSideEffectsInItsDestructor=从不使用局部变量，但可能会在析构函数中有副作用
Strings.LocalVariableIsNeverUsedButMayHaveSideEffectsInItsDestructor4=从不使用局部变量，但可能会在析构函数中有副作用
Strings.LocalVariableMightNotBeInitialized=局部变量可能未初始化
Strings.LocalVariableUsedWithoutBeingInitialized=局部变量在未被初始化的情况下使用
Strings.LocalVariableUsedWithoutBeingInitialized5=局部变量在未被初始化的情况下使用
Strings.MayBeMissingKeywordthrow=可能缺少关键字 'throw'
Strings.MemberFunctionCanBeMadeConst=成员函数可被设为 const
Strings.MemberFunctionCanBeMadeConst6=成员函数可被设为 const
Strings.MemberFunctionCanBeMadeStatic=成员函数可被设为 static
Strings.MemberFunctionCanBeMadeStatic7=成员函数可被设为 static
Strings.MethodMustBePublicAndVirtualToImplementACCLIInterfaceMember=方法必须为 public 和 virtual 才能实现 C++/CLI 接口成员
Strings.MethodMustBePublicAndVirtualToImplementACCLIInterfaceMember29=方法必须为 public 和 virtual 才能实现 C++/CLI 接口成员
Strings.MismatchedClassTags=不匹配的类标记
Strings.MissingFunctionParameterDescriptionInADocumentationComment=文档注释中缺少函数参数说明
Strings.MissingFunctionParameterDescriptionInADocumentationComment38=文档注释中缺少函数参数说明
Strings.MissingIncludeGuard=缺少 include guard
Strings.MixedSerialAndPositionalArgumentsForBoostFormat=位置和非位置实参位于同一个 boost\:\:format 调用中
Strings.ModulePartitionWithSeveralPartitionUnitsDescription=根据 C++ 标准，一个模块分区不能具有多个分区单元
Strings.ModulePartitionWithSeveralPartitionUnitsTitle=模块分区具有多个分区单元
Strings.MoreThanOneImplicitConversionAppliedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension=复制初始化过程中应用了多个隐式转换。这是非标准的 Microsoft C++ 扩展。
Strings.MoreThanOneImplicitConversionAppliedDuringCopyInitializationThisIsNonStandardMicrosoftCExtension4=复制初始化过程中应用了多个隐式转换。这是非标准的 Microsoft C++ 扩展。
Strings.MultiCharacterLiteralDescription=多字符字符文字
Strings.MultiCharacterLiteralTitle=多字符字符文字
Strings.MultiCharacterWideLiteralDescription=多字符宽字符文字
Strings.MultiCharacterWideLiteralTitle=多字符宽字符文字
Strings.NamespaceDefinitionContainingSingleClassSpecialization=包含单个类专用化的命名空间定义
Strings.NoCorrespondingFileWithThePrecompiledHeaderPropertySetToCreateYcIsFound=找不到 'Precompiled Header' 属性设置为 'Create' (/Yc) 的对应文件
Strings.NoReturnStatementInAFunctionOrALambdaReturningNonVoid=函数或 lambda 中的返回声明不会返回非空值
Strings.NoReturnStatementInAFunctionOrALambdaWithNonVoidReturnType=函数或 lambda 中的所有返回声明均没有非 void 返回值类型
Strings.NoTypeSpecifierFoundInADeclarationDefaultsToint=在声明中找不到类型说明符。默认为 'int'。
Strings.NodiscardCannotBeAppliedToFunctionsWithoutAReturnValue=[[nodiscard]] 不能应用于没有返回值的函数
Strings.NonExplicitConversionOperator=非显式转换运算符
Strings.NonExplicitConversionOperator5=非显式转换运算符
Strings.NonExplicitConvertingConstructor=非显式转换构造函数
Strings.NonExplicitConvertingConstructor4=非显式转换构造函数
Strings.NonInlineFunctionDefinitionInAHeaderFile=头文件中的非内联函数定义
Strings.NonInlineVariableDefinitionInAHeaderFile=头文件中的非内联变量定义
Strings.NonSafeResourceAcquisition=非安全资源获取
Strings.NonStaticDataMemberIsUninitialized=非静态数据成员未初始化
Strings.NonStaticDataMemberIsUninitialized26=非静态数据成员未初始化
Strings.NonVirtualClassMemberFunctionHiddenInADerivedClass=隐藏在派生类中的非虚拟类成员函数
Strings.NonVirtualClassMemberFunctionIsHiddenInADerivedClass=非 virtual 类成员函数隐藏在派生类中
Strings.NotAllControlPathsInsideAFunctionOrALambdaReturnAValue=并非函数或 lambda 内的所有控制路径都返回值
Strings.NotAllControlPathsReturnAValue=一部分控制路径不返回值
Strings.NotEnoughArgumentsInACallToBoostFormat=boost\:\:format 调用中的参数不足
Strings.NotEnoughArgumentsInACallToBoostFormat36=boost\:\:format 调用中的参数不足
Strings.NotEnoughArgumentsInACallToPrintf=printf 调用中的参数不足
Strings.NotEnoughArgumentsInACallToPrintfSomeFormatCodesDoNotHaveAMatchingArgument=对 printf 的调用中没有足够的实参。某些格式指令没有匹配的实参。
Strings.NotInitializedStaticConstLocalVariableOfScalarTypeThisIsNonStandardMicrosoftCExtension=不是标量类型的初始化 static const 局部变量。这是非标准的 Microsoft C++ 扩展。
Strings.NumericTypeCanBeReplacedWithAuto=数值类型可被替换为 auto
Strings.ObjectMemberMightNotBeInitialized=对象成员可能未初始化
Strings.ObjectOfExceptionTypeIsCreatedButIsNotThrown=异常类型的对象已被创建，但未被抛出
Strings.OrderOfIncludeDirectivesDoesNotMatchCodeStyleSettings=\#include 指令的顺序与代码样式设置不匹配
Strings.OrderOfIncludeDirectivesDoesNotMatchCodeStyleSettings1=\#include 指令的顺序与代码样式设置不匹配
Strings.OrderOfMemberInitializersDoesNotMatchTheInitializationOrder=成员初始值设定项的顺序与初始化顺序不一致
Strings.OrderOfMemberInitializersDoesNotMatchTheInitializationOrder3=成员初始值设定项的顺序与初始化顺序不一致
Strings.OverrideFunctionRedefinesADefaultParameterArgument=重写函数重新定义默认的参数自变量
Strings.OverridenMethodIsDeprecated=重写的方法已被弃用
Strings.ParameterCanBeMadeConst=形参可被设为 const
Strings.ParameterCanBeMadeConst9=形参可被设为 const
Strings.ParameterCanBeMadePointerReferenceToConst=形参可被设为 const 的指针/引用
Strings.ParameterCanBeMadePointerReferenceToConst11=形参可被设为 const 的指针/引用
Strings.ParameterIsNeverUsed=从不使用参数
Strings.ParameterNamesDifferInDifferentDeclarationsOfTheSameFunction=形参名称在同一函数的不同声明中不同
Strings.ParameterNamesDoNotMatch=参数名称不匹配
Strings.ParenthesesDontChangeOrderOfOperationsAndCanBeDeleted=圆括号不会改变运算顺序，可以删除
Strings.PassValueParameterByConstReferenceDescription=复制开销很高的类型的形参通过值传递，但可以改为通过常量引用来传递。
Strings.PassValueParameterByConstReferenceTitle=通过常量引用传递值形参
Strings.PolymorphicClassWithNonVirtualPublicDestructor=带有非虚拟公共析构函数的多态类
Strings.PossiblyErroneousEmptyStatement=可能错误的空语句
Strings.PossiblyErroneousEmptyStatementUsedInAControlStatement=控制语句中使用了可能错误的空语句
Strings.PossiblyErroneousExpressionWithoutSideEffects=可能错误的表达式（无副作用）
Strings.PossiblyErroneousExpressionWithoutSideEffects21=可能错误的表达式（无副作用）
Strings.PossiblyErroneousIncompleteSwitchStatement=可能错误的不完整 switch 语句
Strings.PossiblyInvalidPrintfFormatSpecifier=可能无效的 printf 格式说明符
Strings.PossiblyUninitializedClassMember=可能未初始化的类成员
Strings.PossiblyUninitializedDependentBaseClass=可能未初始化的依赖基类
Strings.PossiblyUnintendedIncompatibleReferenceTypeInRangeDeclaration=范围声明中可能非有意的不兼容引用类型
Strings.PossiblyUnintendedObjectSlicing=可能非有意的对象切割
Strings.PossiblyUnintendedObjectSlicing28=可能非有意的对象切割
Strings.PossiblyUnusedIncludeDirective=可能未使用的 \#include 指令
Strings.PossiblyUnusedIncludeDirective7=可能未使用的 \#include 指令
Strings.PragmaEndRegionIsMissingAMatchingEndRegionDescription='\#pragma endregion' 指令缺少匹配的 '\#pragma region' 指令
Strings.PragmaEndRegionIsMissingAMatchingEndRegionTitle=缺少匹配的 '\#pragma region' 指令
Strings.PragmaRegionIsMissingAMatchingEndRegionDescription='\#pragma region' 指令缺少匹配的 '\#pragma endregion' 指令
Strings.PragmaRegionIsMissingAMatchingEndRegionTitle=缺少匹配的 '\#pragma endregion' 指令
Strings.PrecompiledHeaderIsNotFound=未找到预编译的标头
Strings.PrecompiledHeaderIsNotIncluded=未包含预编译的标头
Strings.PrecompiledHeaderMustBeIncludedAtTheTopOfSourceFile=预编译头必须包含在源文件的顶部
Strings.PrivateSpecialMemberFunctionIsNotImplemented=未实现私有特殊成员函数
Strings.ProhibitsTheUseOfTabulationCharacterEverywhereInFile=禁止在文件中的任何地方使用制表符
Strings.QualifierIsRedundantADLAndCanBeDeleted=限定符冗余(由于 ADL)，可以删除
Strings.QualifierIsRedundantAndCanBeDeleted=限定符冗余，可以删除
Strings.RedeclarationOfATemplateParameterFromAnOuterScope=从外部范围重新声明模板参数
Strings.RedundantArgumentInConditionalExpression=条件表达式中的冗余参数
Strings.RedundantArgumentInConditionalExpression54=条件表达式中的冗余参数
Strings.RedundantBaseClassAccessSpecifier=冗余基类访问说明符
Strings.RedundantBaseClassAccessSpecifier53=冗余基类访问说明符
Strings.RedundantBaseClassInitializerDescription=成员初始值设定项列表中的冗余基类初始值设定项
Strings.RedundantBaseClassInitializerTitle=冗余的基类初始值设定项
Strings.RedundantCastExpression=冗余转换表达式
Strings.RedundantControlFlowJumpStatement=冗余的控制流跳过语句
Strings.RedundantControlFlowJumpStatement47=冗余的控制流跳过语句
Strings.RedundantElaboratedTypeSpecifier=冗余的详细类型说明符
Strings.RedundantEmptyDeclaration=冗余的空声明
Strings.RedundantEmptyDeclaration49=冗余的空声明
Strings.RedundantEmptyStatement=冗余的空语句
Strings.RedundantEmptyStatement48=冗余的空语句
Strings.RedundantExportKeywordMessage=关键字 'export' 冗余，因为存在封闭导出声明
Strings.RedundantFwdClassOrEnumSpecifier=冗余的前向声明
Strings.RedundantMemberInitializerInConstructorInitializationList=构造函数初始化列表中的冗余成员初始值设定项
Strings.RedundantMemberInitializerInConstructorInitializationList56=构造函数初始化列表中的冗余成员初始值设定项
Strings.RedundantParameterListInLambdaDeclarator=lambda 声明符中存在冗余形参列表
Strings.RedundantParentheses=冗余圆括号
Strings.RedundantQualifier=冗余限定符
Strings.RedundantQualifierADL=冗余限定符(ADL)
Strings.RedundantStaticSpecifierOnThreadLocalLocalVariableDescription='thread_local' 局部变量上存在冗余 'static' 说明符
Strings.RedundantStaticSpecifierOnThreadLocalLocalVariableTitle='thread_local' 局部变量上存在冗余 'static' 说明符
Strings.RedundantTemplateArguments=冗余模板参数
Strings.RedundantVoidArgumentList=冗余的“void”参数列表
Strings.RedundantVoidArgumentList55=冗余的“void”参数列表
Strings.RedundantWhitespaceCharactersAtTheEndOfALine=行尾的冗余空格字符
Strings.RedundantWhitespacesAtTheEndOfALine=行尾的冗余空格
Strings.RedundantZeroInitializerInAggregateInitializationMessage=聚合初始化中的零初始值设定项冗余
Strings.RedundantconstSpecifier=冗余“const”说明符
Strings.RedundantelseKeyword=冗余的“else”关键词
Strings.RedundantelseKeyword45=冗余的“else”关键词
Strings.RedundantelseKeywordInsideCompoundStatement=复合语句中冗余的“else”关键词
Strings.RedundantelseKeywordInsideCompoundStatement46=复合语句中冗余的“else”关键词
Strings.RedundantfinalSpecifierOnAFunctionInAFinalClass=final 类中的函数上存在冗余的 'final' 说明符
Strings.RedundantinlineSpecifier=冗余“inline”说明符
Strings.RedundantstaticSpecifierOnAMemberAllocationDeallocationFunction=分配函数/释放函数中成员上的冗余“static”说明符
Strings.RedundantstaticSpecifierOnAnAnonymousNamespaceMember=匿名命名空间成员上的冗余“static”说明符
Strings.RedundantstaticSpecifierOnAnAnonymousNamespaceMember52=匿名命名空间成员上的冗余“static”说明符
Strings.RedundanttemplateKeyword=冗余的“template”关键词
Strings.RedundanttemplateKeyword43=冗余的“template”关键词
Strings.RedundanttypenameKeyword=冗余的“typename”关键词
Strings.RedundanttypenameKeyword42=冗余的“typename”关键词
Strings.ReferenceClassMemberWithmutableSpecifier=通过“mutable”说明符引用类成员
Strings.ReferenceClassMembersCannotHavemutableSpecifier=引用类成员不能具有 'mutable' 说明符
Strings.ReinterpretCastIsUsedInsteadOfAStaticCast=使用 reinterpret_cast，而非 static_cast
Strings.ReinterpretCastIsUsedInsteadOfAStaticCast3=使用 reinterpret_cast，而非 static_cast
Strings.RemoveRedundantBraces=移除冗余大括号
Strings.ResultOfAPostfixOperatorIsDiscarded=后缀运算符的结果已被舍弃
Strings.ResultOfAPostfixOperatorIsDiscardedItMightBeMoreEfficientToUseAPrefixFormOfTheOperator=后缀运算符的结果已被舍弃。使用运算符的前缀形式可能更有效。
Strings.ResultOfAssignmentIsUsedAsCondition=赋值结果用作条件
Strings.ResultOfNodiscardFunctionIsNotUsed=nodiscard 函数的结果未被使用
Strings.ResultOfNodiscardFunctionIsNotUsed22=nodiscard 函数的结果未被使用
Strings.ReturningFromAFunctionByConstValueIsUsuallyNotBeneficialConsiderReturningValuesAsNonConstToTakeAdvantageOfMoveSemantics=根据 const 值从函数返回通常没有益处。请考虑将值作为非 const 返回以利用移动语义。
Strings.SlashSymbolUsedInIncludeDirectiveDoesntMatchCodeStyleSettings=\#include 指令中使用的斜杠符号与代码样式设置不匹配
Strings.SlashSymbolUsedInIncludeDirectiveDoesntMatchCodeStyleSettings2=\#include 指令中使用的斜杠符号与代码样式设置不匹配
Strings.SomeObjectMembersMightNotBeInitialized=一些对象成员可能未初始化
Strings.SpecialFunctionDoesntHaveAnyNoexceptSpecification=特殊函数没有任何 noexcept 规范
Strings.SpecialFunctionWithoutNoexceptSpecification=无 noexcept 说明符的特殊函数
Strings.StaticAssertFailedDescription=static_assert 失败
Strings.StaticAssertFailedTitle=static_assert 失败
Strings.StaticDataMemberInAnAnonymousClassIsNotAllowedByTheCStandard=C++ 标准不允许在匿名类中使用静态数据成员
Strings.StaticDataMembersAreNotAllowedInAnonymousClasses=匿名类中不允许使用 static 数据成员
Strings.StdIsConstantEvaluatedWillAlwaysEvaluateToConstantDescription='std\:\:is_constant_evaluated' 将始终求值为常量
Strings.StdIsConstantEvaluatedWillAlwaysEvaluateToConstantTitle='std\:\:is_constant_evaluated' 将始终求值为常量
Strings.StdSizeCanBeUsed=可以使用 std\:\:size
Strings.StdSizeIsTypeSafeAlternativeToCIdiomForArraySizeCalculation=std\:\:size 是用于计算数组大小的 C 惯用法的类型安全的替代方案
Strings.StdViewsKeysValuesCanBeUsed=可以使用 std\:\:views\:\:keys/values
Strings.StringLiteralToCharPointerConversion=字符串字面量到 char 指针转换
Strings.StringLiteralToCharPointerConversion34=字符串字面量到 char 指针转换
Strings.StructuredBindingsCanBeUsed=可以使用结构化绑定
Strings.StructuredBindingsCanBeUsedDescription=可以使用结构化绑定
Strings.StructuredBindingsCanBeUsedInsteadOfTie=可以使用结构化绑定而非 tie(..)
Strings.SyntaxErrorInADoxygenComment=doxygen 注释中的语法错误
Strings.SyntaxErrorInDoxygenComment=doxygen 注释中的语法错误
Strings.TabsAreProhibited=禁止使用制表符
Strings.TagsOfTheDeclaredClassDoNotMatchPreviousDeclarations=所声明类的标记与之前的声明不匹配
Strings.TakingAnAddressOfClassRValueIsNonStandardMicrosoftCExtension=使用类 r-value 的地址为非标准 Microsoft C++ 扩展
Strings.TakingAnAddressOfClassRValueIsNonStandardMicrosoftCExtension3=使用类 r-value 的地址为非标准 Microsoft C++ 扩展
Strings.TemplateArgumentsCanBeDeduced=可以推导模板实参
Strings.TemplateParameterIsNeverUsedDescription=模板形参从未被使用
Strings.TemplateParameterIsNeverUsedTitle=模板形参从未被使用
Strings.TheAwaiterTypeMustBeAAClassAccordingToTheCStandard=根据 C++20 标准，awaiter 类型必须是类
Strings.TheClassIsAbstractButNotExplicitlyDeclaredAsSuch=类为 abstract，但不会进行显式声明
Strings.TheNodiscardAttributeCannotBeAppliedToFunctionsWithoutAReturnValue=[[nodiscard]] 特性不能应用于没有返回值的函数
Strings.TheSwitchStatementDoesntCoverTheWholeRangeOfTheEnumerationUsed=switch 语句不涵盖所用枚举的整个范围
Strings.TheconstSpecifierOnAVariableDefinitionIsRedundant=变量定义上的 'const' 说明符冗余
Strings.TheinlineSpecifierOnAFunctionDefinitionIsRedundant=函数定义上的 'inline' 说明符冗余
Strings.TheoutParameterMustBeAssigned=必须为 'out' 形参赋值
Strings.TheregisterStorageClassSpecifierIsDeprecatedInCAndRemovedInC='register' 存储类说明符在 C++11 中被弃用，在 C++17 中已被移除
Strings.ThestaticSpecifierIsOptionalForMemberAllocationDeallocationFunctions='static' 说明符为分配函数/释放函数的可选项
Strings.ThrowExpressionCanBeReplacedWithARethrowExpression=throw 表达式可由 rethrow 表达式替换
Strings.ThrowExpressionCanBeReplacedWithARethrowExpression12=throw 表达式可由 rethrow 表达式替换
Strings.TooManyArgumentsInACallToBoostFormat=boost\:\:format 调用中的参数过多
Strings.TooManyArgumentsInACallToBoostFormatSomeOfTheArgumentsAreNotUsed=对 boost\:\:format 的调用中的实参过多。一些实参未使用。
Strings.TooManyArgumentsInACallToPrintf=printf 调用中的参数过多
Strings.TooManyArgumentsInACallToPrintfSomeOfTheArgumentsAreNotUsed=对 printf 的调用中的实参过多。一些实参未使用。
Strings.TypeAliasIsNeverUsed=类型别名从未被使用
Strings.TypeCanBeReplacedWithAuto=类型可被替换为 auto
Strings.TypeCanBeReplacedWithauto4=类型可被替换为 'auto'
Strings.TypeSpecifierMissingDefaultsToInt=类型说明符缺失，默认为 int
Strings.TypeTraitCanBeSimplifiedUsingATemplateAliasOrAVariableTemplate=可以使用模板别名或变量模板简化类型特征
Strings.UninitializedDependentBaseClass=未初始化的依赖基类
Strings.UnionMemberOfReferenceType=引用类型的联合成员
Strings.UnionsCannotContainNonStaticDataMembersOfReferenceTypes=联合不能包含引用类型的非 static 数据成员
Strings.UnnamedNamespaceInAHeaderFile=头文件中未命名的命名空间
Strings.UnnamedNamespacesShouldNotBeUsedInHeaderFiles=不应在头文件中使用未命名的命名空间
Strings.UnresolvedReferenceInADoxygenComment=doxygen 注释中未解析的引用
Strings.UnresolvedReferenceInDoxygenComment=doxygen 注释中未解析的引用
Strings.UseBracesToSeparatedoWhileStatementBody=使用大括号分隔 'do-while' 语句体
Strings.UseBracesToSeparateforStatementBody=使用大括号分隔 'for' 语句体
Strings.UseBracesToSeparateifStatementBody=使用大括号分隔 'if' 语句体
Strings.UseBracesToSeparatewhileStatementBody=使用大括号分隔 'while' 语句体
Strings.UseOfAnIncompleteTypeInsideATemplate=在模板内使用不完整类型
Strings.UsePreferredBracesStyle=使用首选大括号样式
Strings.UsePreferredCvQualifiersStyle=使用首选 cv 限定符样式
Strings.UsePreferredDeclarationStyle=使用首选声明样式
Strings.UsePreferredIncludeDirectiveStyle=使用首选 include 指令样式
Strings.UsePreferredInitializationStyle=使用首选初始化样式
Strings.UsePreferredOverridingFunctionStyle=使用首选重写函数样式
Strings.UsePreferredautoStyle=使用首选 'auto' 样式
Strings.UserDefinedLiteralSuffixesMustStartWithAnUnderscore=用户定义的字面量后缀必须以下划线开头
Strings.UserDefinedLiteralSuffixesMustStartWithAnUnderscoreTheSuffixesThatDoNotBeginWithAnUnderscoreAreReservedForTheLiteralOperatorsProvidedByTheStandardLibrary=用户定义的字面量后缀必须以下划线开头。不以下划线开头的后缀为标准库提供的文字运算符保留。
Strings.UsingAnIncompatibleReferenceTypeInTheRangeDeclarationIsLikelyToCauseUnwantedObjectCopying=在范围声明中使用不兼容的引用类型很可能导致不需要的对象复制
Strings.VariableCanBeMadeConstexpr=变量可被设为 constexpr
Strings.VariableCanBeMadeConstexpr10=变量可被设为 constexpr
Strings.VariableCanBeMovedToInitStatement=变量可被移动到 init 语句中
Strings.VariableCanBeMovedToInnerScope=变量可被移动到内部作用域中
Strings.VolatileQualificationOfParametersHasAnEffectOnlyInFunctionDefinitions=形参的 volatile 限定仅在函数定义中有作用
Strings.VolatileQualifiedParameterInAFunctionDeclaration=函数声明中的可变限定参数
Strings.WarningDirectiveDescription=\#warning 预处理程序指令
Strings.WarningDirectiveTitle=\#warning 指令
Strings.ZeroConstantCanBeReplacedWithNullptr=零常量可由 nullptr 替换
Strings.ZeroConstantCanBeReplacedWithNullptr13=零常量可由 nullptr 替换
Strings.ZeroInitializationCanBeUsedInsteadOfMemset=可以使用零值初始化而非 memset
Strings.ZeroInitializationCanBeUsedInsteadOfMemset16=可以使用零值初始化而非 memset
Strings.containsMemberFunctionCanBeUsed=可以使用 'contains' 成员函数
Strings.containsMemberFunctionCanBeUsed17=可以使用 'contains' 成员函数
Strings.defaultIsAKeywordInTheCStandardAndCannotBeUsedAsAnIdentifier='default' 是 C++ 标准中的关键字，不能用作标识符
Strings.longFloatsAreNotAllowedByTheCStandard=C++ 标准不允许使用 'long' 浮点数
Strings.stdErasestdEraseIfCanBeUsedInsteadOfTheRemoveEraseIdiom=可以使用 'std\:\:erase'/'std\:\:erase_if' 而非 remove-erase 惯用法
Strings.stdErasestdEraseIfCanBeUsedInsteadOfTheRemoveEraseIdiom18=可以使用 'std\:\:erase'/'std\:\:erase_if' 而非 remove-erase 惯用法

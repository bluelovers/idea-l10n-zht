0.1.be.lifted.out.of.2=可从 ''{1}'' 提取出 ''{0}''
0.1.could.be.private={0} ''{1}'' 可以为 private
0.1.is.never.used={0} ''{1}'' 从未使用
0.already.exists={0} 已存在
0.always.returns.non.null.type=''{0}'' 始终返回非 null 类型
0.call.could.be.simplified.to.1={0} 调用可以简化为 {1}
0.call.should.be.replaced.with.array.literal=''{0}'' 调用应被替换为数组字面量 [...]
0.from.1={0} 来自 {1}
0.has.detected.1.code.fragments.in.2.that.can.be.replaced.with.3={0} 已在 {2} 中检测到 {1} 代码 {1,choice,1\#片段|2\#片段}，可以用 {3} 替换。您想要查看并替换 {1,choice,1\#它|2\#它们}吗?
0.has.empty.body=''{0}'' 具有空体
0.in.1.will.require.class.instance={1} 中的 ''{0}'' 将需要类接口
0.interface.1={0}接口 ''{1}''
0.is.always.non.null.type=''{0}'' 始终为非 null 类型
0.is.expected.to.be.used.since.kotlin.1.3=从 Kotlin 1.3 起，预期使用 ''{0}''
0.is.missing.documentation={0} 缺少文档
0.is.overridden.by.declaration.s.in.a.subclass={0} 已由子类中的声明重写
0.may.break.code={0}(可能中断代码)
0.on.a.readonly.1.creates.a.new.1.under.the.hood=只读{1}上的 ''{0}'' 在后台创建新的{1}
0.references.type.parameters.of.the.containing.class=包含类的 {0} 引用类型形参
0.should.return.unit={0} 应返回 Unit
0.try.1.with.2.fails.and.3.verifications={0} [尝试 {1}，{2} 次失败和 {3} 次验证]
0.will.become.invisible.after.extraction={0} 在提取之后将变为不可见
0.will.no.longer.be.accessible.after.extraction={0} 在提取之后将不再可访问
a.constructor.call.is.not.yet.supported=尚不支持构造函数调用
a.field.without.an.initializer.is.not.yet.supported=尚不支持没有初始值设定项的字段
accessing.non.final.property.0.in.constructor=正在访问构造函数中的非 final 属性 {0}
action.CacheResetOnProcessCanceledToggleAction.text=ProcessCanceledException 时重置缓存
action.CheckComponentsUsageSearchAction.text=检查组件函数用法搜索
action.ConfigureKotlinInProject.text=在项目中配置 Kotlin
action.ConvertJavaToKotlin.text=将 Java 文件转换为 Kotlin 文件
action.CopyAsDiagnosticTest.text=将当前文件复制为诊断测试
action.CopyKotlinProjectInformation.text=将 Kotlin 项目概览复制到剪贴板
action.DecompileKotlinToJava.text=将 Kotlin 反编译为 Java
action.DumbModeTremble.text=Tremble Dumb 模式
action.ExtractFunction.command.completion.description=将所选代码段转换为函数
action.ExtractFunction.text=提取函数(_F)…
action.ExtractFunctionToScope.text=将函数提取到作用域(_S)…
action.FindImplicitNothingAction.text=查找隐式 Nothing 调用
action.GotoSuperClass.MainMenu.text=超类(_U)
action.GotoSuperClass.text=转到超类(_U)
action.GotoSuperInterface.MainMenu.text=Super 接口(_U)
action.GotoSuperInterface.text=转到 super 接口(_U)
action.GotoSuperProperty.MainMenu.text=super 属性(_U)
action.GotoSuperProperty.description=导航到当前属性重写或实现的属性的声明
action.GotoSuperProperty.text=转到 super 属性(_U)
action.HighlightingBenchmarkAction.text=基准高亮显示
action.InspectBreakpointApplicability.text=检查断点可用性
action.IntroduceProperty.text=引入属性(_R)…
action.IntroduceTypeAlias.text=引入类型别名(_A)…
action.IntroduceTypeParameter.text=引入类型形参(_Y)…
action.Kotlin.ClearScratch.description=清除 Kotlin 临时文件
action.Kotlin.ClearScratch.text=清除 Kotlin 临时文件
action.Kotlin.NewFile.description=创建新的 Kotlin 类或文件
action.Kotlin.NewFile.text=Kotlin 类/文件
action.Kotlin.NewScript.description=创建新的 Kotlin 脚本或工作表
action.Kotlin.NewScript.text=Kotlin 脚本
action.Kotlin.RunScratch.description=运行 Kotlin 临时文件
action.Kotlin.RunScratch.text=运行 Kotlin 临时文件
action.Kotlin.StopScratch.description=停止执行临时文件
action.Kotlin.StopScratch.text=停止执行临时文件
action.Kotlin.XDebugger.ToggleKotlinVariableView.text=仅显示 Kotlin 变量
action.KotlinCodeMigration.text=运行代码迁移
action.KotlinCodeMigrationToggle.text=启用迁移检测
action.KotlinConfigurePlugin.text=配置 Kotlin 插件
action.KotlinConsoleREPL.text=Kotlin REPL (实验性)
action.KotlinFormattingSettingsStatusAction.text=格式化程序设置信息
action.KotlinGenerateDataMethod.text=形参函数
action.KotlinGenerateEqualsAndHashCode.text=equals() 和 hashCode()
action.KotlinGenerateMavenCompileExecutionAction.text=Kotlin 编译执行
action.KotlinGenerateMavenPluginAction.text=Kotlin 插件
action.KotlinGenerateMavenTestCompileExecutionAction.text=Kotlin 测试编译执行
action.KotlinGenerateSecondaryConstructor.text=辅助构造函数
action.KotlinGenerateSetUpMethod.text=SetUp 函数
action.KotlinGenerateTearDownMethod.text=TearDown 函数
action.KotlinGenerateTestMethod.text=测试函数
action.KotlinGenerateToString.text=toString()
action.KotlinShellExecute.description=在控制台中执行 Kotlin 代码
action.KotlinShellExecute.text=执行 Kotlin 代码
action.KotlinThrowException.text=删除来自 Kotlin 插件的错误
action.KtAddToExcludeListAction.text=不显示当前方法的提示
action.LibraryToSourceDependencySupportToggleAction.text=将库切换为源依赖项支持
action.LocalCompletionBenchmarkAction.text=本地方案
action.PrintOutNotPropertyMatches.text=搜索非属性候选项
action.ShortenSelectionAction.text=缩短所选内容
action.ShowKotlinBytecode.text=显示 Kotlin 字节码
action.StoredExceptionsThrowToggleAction.text=抛出缓存的 PCE
action.TestMoveRefactiringAction.text=在打开的项目上测试移动重构
action.TopLevelCompletionBenchmarkAction.text=顶级方案
action.add.import.chooser.title=Import
action.generate.equals.choose.equals=选择要包含在 'equals()' 中的属性
action.generate.equals.choose.hashcode=选择要包含在 'hashCode()' 中的属性
action.generate.functions.already.defined=对于类 {1}，函数 {0} 已经定义。是否要将其删除并继续?
action.generate.secondary.constructor.choose.properties=选择要通过构造函数初始化的属性
action.generate.secondary.constructor.error.already.exists=构造函数已存在
action.generate.super.type=显式指定 super 类型
action.generate.test.support.choose.framework=选择框架
action.generate.test.support.choose.test.name=选择测试名称\:
action.generate.test.support.edit.template=编辑模板
action.generate.test.support.error.cant.convert.java.template=无法将 Java 模板转换为 Kotlin
action.generate.test.support.error.cant.generate.method=无法生成方法\: {0}
action.generate.test.support.error.no.template.found=没有找到 {0} 的模板\: {1}
action.generate.tostring.choose.implementation=选择实现\:
action.generate.tostring.choose.implementation.mnemonic=i
action.generate.tostring.generate.super.call=生成对 super.toString() 的调用
action.generate.tostring.generate.super.call.mnemonic=秒
action.generate.tostring.name=生成 'toString()'
action.generate.tostring.template.multiple=包含串联的多个模板
action.generate.tostring.template.multiple.with.super=带有串联和 super 调用的多个模板
action.generate.tostring.template.single=单个模板
action.generate.tostring.template.single.with.super=带有 super 调用的单个模板
action.hints.settings.text=提示设置…
action.j2k.correction.errors.multiple=''{0}'' 和 {1} 其他 Java 文件包含语法错误，转换结果可能不正确
action.j2k.correction.errors.single=''{0}'' 包含语法错误，转换结果可能不正确
action.j2k.correction.investigate=调查错误
action.j2k.correction.proceed=继续转换
action.j2k.correction.required=您项目其余部分的一些代码在执行此转换后可能需要更正。是否要查找此类代码并更正?
action.j2k.error.cant.find.document=找不到 ''{0}'' 的文档
action.j2k.error.cant.save.result=无法保存转换结果\: {0}
action.j2k.error.nothing.to.convert=没有要转换的内容\:<br>找不到可写的 Java 文件
action.j2k.error.read.only=文件 ''{0}'' 为只读文件
action.j2k.name=将 Java 转换为 Kotlin
action.j2k.task.name=将文件从 Java 转换为 Kotlin
action.move.method=移动方法…
action.new.file.dialog.annotation.title=注解
action.new.file.dialog.class.title=类
action.new.file.dialog.data.class.title=数据类
action.new.file.dialog.enum.title=枚举类
action.new.file.dialog.file.title=文件
action.new.file.dialog.interface.title=接口
action.new.file.dialog.object.title=对象
action.new.file.dialog.sealed.class.title=密封类
action.new.file.dialog.sealed.interface.title=密封接口
action.new.file.dialog.title=新 Kotlin 类/文件
action.new.file.error.empty.name=名称不能为空
action.new.file.error.empty.name.part=名称不能有空白部分
action.new.script.dialog.script=新建 Kotlin 脚本
action.new.script.dialog.title=新建 Kotlin 脚本文件
action.new.script.name=Kotlin 脚本
action.text.append=追加
action.text.cancel=取消
action.text.continue=继续
action.text.install=安装
action.text.overwrite=覆盖
action.usage.update.command=用法更新
add.0.constructor.to.1=将 {0} 构造函数添加到 ''{1}''
add.0.library=添加 ''{0}'' 库
add.0.to.argument=将 ''{0} \='' 添加到实参
add.all.should.be.replaced.with.map.to=''{0}({1} '{}')'' 应替换为 ''{1}''
add.an.opt.in.requirement.marker.compiler.argument=添加选择加入要求标记编译器实参
add.braces=添加大括号
add.braces.to.0.statement=将大括号添加到 ''{0}'' 语句
add.braces.to.all.branches=向所有分支添加大括号
add.braces.to.if.all.statements=向所有 'if' 语句添加大括号
add.braces.to.when.all.entries=向所有 'when' 条目添加大括号
add.braces.to.when.entry=将大括号添加到 'when' 条目
add.call.or.unwrap.type.fix.text=将 ''.{0}()'' 添加到函数结果 (中断使用站点\!)
add.call.or.unwrap.type.fix.text1=解包 ''{0}'' 返回值类型(中断 use-site\!)
add.clarifying.braces.to.nested.else.statement=为嵌套的 'else' 语句添加明确的大括号
add.constructor.keyword=添加 'constructor' 关键字
add.constructor.parameters.from.0.1=从 {0}{1} 添加构造函数形参
add.constructor.parameters.from.superclass=从超类添加构造函数形参
add.documentation.fix.text=添加文档
add.empty.argument.list=添加空实参列表
add.empty.brackets.after.primary.constructor=在主构造函数后添加空括号
add.explicit.parameter.to.outer.lambda.fix.text=将显式形参名称添加到外部 lambda
add.explicit.type.arguments=添加显式类型实参
add.external.keyword=添加 external 关键字
add.full.qualifier=添加完全限定符
add.fun.modifier.to.0=将 ''fun'' 修饰符添加到 ''{0}''
add.import.for.0=为 ''{0}'' 添加 import
add.import.for.member=为成员添加导入
add.indices.to.for.loop=将索引添加到 'for' 循环
add.initializer=添加初始值设定项
add.interpolation.prefix=添加插值前缀
add.jvminline.annotation=添加 '@JvmInline' 注解
add.jvmoverloads.annotation=添加 '@JvmOverloads' 注解
add.jvmoverloads.annotation.to.0=将 ''@JvmOverloads'' 注解添加到 {0}
add.jvmstatic.annotation=添加 '@JvmStatic' 注解
add.kotlin.coroutines=添加 Kotlin 协程库
add.kotlin.coroutines.description=添加 Kotlin 协程库
add.labeled.return.to.last.expression.in.a.lambda=将带标签的 return 添加到 lambda 中的最后一个表达式
add.method=添加方法
add.method.0.to.1=将方法 ''{0}'' 添加到 ''{1}''
add.missing.class.keyword=添加缺少的 'class' 关键字
add.missing.component=添加缺失的析构组件
add.modifier=添加修饰符
add.name.to.argument=将名称添加到实参
add.names.in.comment.to.call.arguments=在注释中为调用实参添加名称
add.names.to.call.arguments=将名称添加到调用实参
add.names.to.this.argument.and.following.arguments=将名称添加到此实参和所有后续实参
add.operator.modifier=添加 'operator' 修饰符
add.qualifier=添加链接限定符
add.qualifier.command=添加链接限定符
add.remaining.branches=添加剩余的分支
add.replacewith.argument.to.specify.replacement.pattern=添加 'replaceWith' 实参以指定替换模式
add.return.at.0=添加 ''return@{0}''
add.return.expression=添加 'return' 表达式
add.source.retention=添加源保留
add.throws.annotation=添加 '@Throws' 注解
add.underscores=添加下划线
add.use.site.target=添加使用站点目标
add.val.to.parameter.0=将 ''val'' 添加到形参 ''{0}''
add.val.var.to.parameter.0=将 ''val'' 或 ''var'' 添加到形参 ''{0}''
add.val.var.to.primary.constructor.parameter=将 'val' 或 'var' 添加到主构造函数形参
add.variance.fix.family.name=添加差异
add.variance.fix.text=添加 ''{0}'' 差异
advanced.setting.kotlin.mpp.experimental=启用实验性多平台 IDE 功能
advanced.setting.kotlin.mpp.experimental.description=需要 IDE 重启
all.expected.and.actual.classes.must.be.sealed.classes=所有预期和实际类必须为密封类。\n
all.inheritors.must.be.nested.objects.of.the.class.itself.and.may.not.inherit.from.other.classes.or.interfaces=所有继承者必须为类自己的嵌套对象，且不会从其他类或接口继承。\n
ambiguous.actuals.for.0={0} 在模块 {1} 中具有多个兼容的实际声明
ambiguous.coroutinecontext.due.to.coroutinescope.receiver.of.suspend.function=由于挂起函数的 CoroutineScope 接收器，coroutineContext 不明确
ambiguous.non.local.break.or.continue.display.name=不明确的非局部 'break' 或 'continue'
ambiguous.non.local.break.or.continue.use.label=不明确的非本地 ''{0}'' (''{1}'' 与 ''{2}'')。使用明确的标签。
ambiguous.non.local.break.or.continue.use.label.or.contract=不明确的非本地 ''{0}'' (''{1}'' 与 ''{2}'')。使用明确的标签或将 ''callsInPlace'' 约定添加到 ''{3}''。
analyzed.0.classes.no.difference.found=已分析 {0} 类。未找到差异。
analyzing.functions=正在分析函数…
analyzing.members=正在分析成员…
and.delete.initializer=并删除初始值设定项
apply.also.to.internal.members=同时应用于 internal 成员
apply.also.to.private.members=同时应用于 private 成员
apply.in.the.project.0=在项目中应用\: {0}
apply.only.to.public.or.protected.members=仅应用于 public 或 protected 成员
applying.0=正在应用 ''{0}''
array.property.in.data.class.it.s.recommended.to.override.equals.hashcode='data' 类中存在类型为 'Array' 的属性\: 建议重写 'equals()' 和 'hashCode()'
assert.should.be.replaced.with.operator=断言应替换为运算符
assign.backing.field.fix.text=分配支持字段
assigned.value.is.never.read=指定的值从未被读取
base.property.0=基本属性 {0}
big.decimal.equals=在 'BigDecimal' 上调用了 'equals()'
big.decimal.equals.problem.descriptor=BigDecimal 值之间的 <code>\#ref()</code> 可能应当是 'compareTo()' \#loc
block.body=块主体
boolean.literal.argument.without.parameter.name=不包含形参名称的布尔字面量实参
boolean.property.in.external.interface.should.be.nullable=external 接口中的布尔属性应为可以为 null
breadcrumbs.tooltip.indexing=正在编制索引…
button.add.package=添加软件包
button.rename.base=重命名基
button.rename.current=重命名当前
button.text.move.nested.class.0.to.another.class=将嵌套类 {0} 移至另一个类(&M)
button.text.move.nested.class.0.to.upper.level=将嵌套类 {0} 移至上一级别(&N)
call.chain.length.to.transform=要转换的调用链长度\:
call.chain.on.collection.could.be.converted.into.sequence.to.improve.performance=可以将集合上的调用链转换为 'Sequence' 来改善性能
call.chain.on.collection.type.may.be.simplified=可以简化集合类型上的调用链
call.is.replaceable.with.another.scope.function=调用可被替换为另一个作用域函数
call.of.inline.function.with.nullable.extension.receiver.can.cause.npe.in.kotlin.1.2=调用包含可为 null 的接收器的 'inline fun' 在 Kotlin 1.2 及更低版本中可能引起 'NPE'
call.of.java.mutator.0.on.immutable.kotlin.collection.1=在不可变的 Kotlin 集合 ''{1}'' 上调用 Java 转变器 ''{0}''
call.on.collection.type.may.be.reduced=可以简化集合类型上的调用
call.on.not.null.type.may.be.reduced=可以简化非 null 类型上的调用
call.replaceable.with.binary.operator=调用可被替换为二元运算符
call.with.arguments.will.be.skipped.0=将跳过具有实参的调用\: {0}
callable.reference.fix.family.name=添加显式 ''{0}''
callable.reference.transformation.is.not.supported.0=不支持可调用的引用转换\: {0}
calling.non.final.function.0.in.constructor=正在调用构造函数中的非 final 函数 {0}
calls.with.explicit.extension.receiver.won.t.be.processed.0=不会处理包含隐式扩展接收器的调用\: {0}
can.be.converted.to.to=显式 'Pair' 初始化可被替换为中缀 'to()' 调用
can.be.joined.with.assignment=可以与赋值联接
can.convert.argument.to.set=可将实参转换为 'Set' 以提高性能
can.t.finish.while.indexing.is.in.progress=当索引编制正在进行时，无法完成
can.t.modify.0=无法修改 {0}
can.t.replace.foreign.reference.with.call.expression.0=无法将外来引用替换为调用表达式\: {0}
can.t.replace.non.kotlin.reference.with.call.expression.0=无法将非 Kotlin 引用替换为调用表达式\: {0}
cannot.extract.super.call=不能提取 super-call
cannot.get.or.create.results.file=无法获取或生成结果文件
cannot.get.project.root.directory=无法获取项目根目录
cannot.infer.type.for.this.declaration=无法推断此声明的类型
cannot.inline.property.with.accessor.s.and.backing.field=无法使用访问器和支持字段内联属性
cannot.introduce.parameter.of.0.type=无法引入类型为 ''{0}'' 的形参
cannot.refactor.expression.has.unit.type=无法引入 unit 类型的表达
cannot.refactor.no.container=无法在此位置重构
cannot.refactor.no.expression=没有表达无法执行重构
cannot.refactor.no.type=没有类型无法执行重构
cannot.refactor.not.expression=找不到要引入的表达式
cannot.refactor.package.expression=无法引入软件包引用
cannot.refactor.syntax.errors=由于错误的代码无法重构
cannot.refactor.synthesized.function=无法重构合成函数
cascade.if.should.be.replaced.with.when=级联 'if' 应替换为 'when'
cast.explicitly.fix.text=显式转换
category.class=Kotlin/基于类
category.comments=Kotlin/注释、KDoc 和元数据
category.declaration=Kotlin/声明
category.expressions=Kotlin/表达式
category.interesting=Kotlin/关注
category.operators=Kotlin/运算符
change.all.usages.of.0.in.this.file.to.1=将此文件中所有的 ''{0}'' 用法例更改为 ''{1}''
change.all.usages.of.0.in.this.file.to.a.kotlin.class=将此文件中所有的 ''{0}'' 用法例更改为 Kotlin 类
change.existent.retention.to.source=将现有保留更改为源
change.main.function.return.type.to.unit.fix.text=添加显式 Unit 返回值类型
change.main.function.return.type.to.unit.fix.text2=将返回值类型更改为 Unit
change.signature.conflict.text.kotlin.default.parameter.in.non.kotlin.files=其他语言可能不支持该默认形参
change.signature.conflict.text.kotlin.default.value.in.non.kotlin.files=默认的 Kotlin 调用值可能会导致其他语言的代码不正确
change.to.0=更改为 ''{0}''
change.to.constructor.invocation=更改为构造函数调用
change.to.correct.long.suffix.l=更改为正确的长后缀 'L'
change.to.correct.primitive.type=更改为正确的基元类型
change.to.kotlin.class=更改为 Kotlin 类
change.to.val=更改为 'val'
change.to.var=更改为 'var'
change.type.of.0.to.1=将 {0} 的类型更改为 ''{1}''
change.type.to.0=将类型更改为 ''{0}''
change.type.to.mutable.fix.text=将类型更改为可变
change.visibility=更改可见性
change.visibility.modifier=更改可见性修饰符
change.visibility.popup=更改可见性
checkbox.collapse.to.expression.body=收起到表达式主体
checkbox.text.declare.with.var=使用 var 声明(&V)
checkbox.text.delete.empty.source.files=删除空白源文件(&D)
checkbox.text.extension.property=扩展属性(&X)\:
checkbox.text.introduce.default.value=引入默认值(&D)
checkbox.text.open.moved.files.in.editor=在编辑器中打开移动的成员
checkbox.text.replace.all.occurrences.0=替换所有匹配项 ({0})(&R)
checkbox.text.search.references=搜索引用(&R)
checkbox.text.specify.type.explicitly=显式指定类型(&T)
checkbox.text.update.package.directive=更新软件包指令(Kotlin 文件)
checking.data.class.0.of.1=正在检查数据类 {0}/{1}…
checking.data.classes=正在检查数据类
choose.actual.members.title=选择实际成员
choose.actual.module=选择 actual 的模块
choose.an.appropriate.kotlin.class=选择适当的 Kotlin 类
choose.class.container=选择类容器
choose.target.class.or.interface=选择目标类或接口
class=类
class.0.already.contains.1=类 ''{0}'' 已包含 {1}
class.name.prompt=类名(&N)\:
class.should.be.external.interface=类应为 external 接口
clipboard.content.copied.from.java.file.do.you.want.to.convert.it.to.kotlin.code=剪贴板内容复制自 Java 文件。是否要将其转换为 Kotlin 代码?
code.insight.workspace.settings.title=Kotlin
codestyle.layout.import.aliases.separately=单独导入别名
codestyle.name.kotlin=Kotlin
column.name.context.parameter=上下文参数\:
column.name.default.parameter=默认形参\:
column.name.receiver=接收器\:
column.name.val.var=Val/Var
command.generate.test.support.generate.test.function=生成测试函数
command.move.declarations=移动声明
comment=注释
companion.object.already.contains.0=伴生对象已包含 {0}
compiling.project=正在编译项目…
condition.is.always.0=条件始终为 ''{0}''
configuration.kotlin.code.style.group.name=Kotlin 官方代码样式可用
configuration.maven.group.name=Kotlin Maven 项目导入
configuration.message.enter.fully.qualified.method.name=输入完全限定方法名称\:
configuration.migration.group.name=Kotlin\: 可迁移到较新版本
configuration.name.method=方法
configuration.status.text.installing=正在安装…
configuration.title.add.exclusion=添加排除
configuration.title.edit.exclusion=编辑排除
const.might.be.used.instead.of.jvmfield=可能使用了 'const'，而不是 '@JvmField'
const.property=const 属性
constructor=构造函数
constructor.has.non.null.self.reference.parameter=构造函数具有非 null 自引用形参
constructor.parameter.is.never.used.as.a.property=构造函数形参从未被用作属性
context.default=默认
context.property.getter.or.setter=具有显式 getter/setter 的属性
convert.0.to.1=将 ''{0}'' 转换为 ''{1}''
convert.anonymous.function.to.lambda.expression=将匿名函数转换为 lambda 表达式
convert.argument.to.set.fix.text=将实参转换为 'Set'
convert.body.to.expression=将正文转换为表达式
convert.boolean.const.to.elvis=将 Boolean? \=\= const 转换为 elvis
convert.call.chain.into.sequence.fix.text=将调用链转换为 'Sequence'
convert.class.0.to.kotlin=将类 ''{0}'' 转换为 Kotlin
convert.collection.constructor.to.function=将集合构造函数转换为函数
convert.comparisons.to.range.check=将比较转换为 ''{0}''
convert.concatenation.to.build.string=将串联转换为 'buildString' 调用
convert.concatenation.to.raw.string=将串联转换为原始字符串
convert.concatenation.to.template=将串联转换为模板
convert.concatenation.to.template.before.text='String' 串联可以转换为模板
convert.context.parameter.to.receiver.parameter=将上下文形参转换为接收器
convert.context.parameter.to.regular.parameter=将上下文形参转换为值形参
convert.context.parameter.to.regular.parameter.progress=正在转换…
convert.expression.to.0=将表达式转换为 ''{0}''
convert.expression.to.0.by.inserting.1=通过插入 ''.{1}'' 将表达式转换为 ''{0}''
convert.extension.function.type.to.regular.function.type=将扩展函数类型转换为常规函数类型
convert.extension.property.initializer.to.getter=将扩展属性初始值设定项转换为 getter
convert.from.class.to.kclass=将 'KClass' 转换为 'Class'
convert.function.to.property=将函数转换为属性
convert.function.type.parameter.to.receiver=将函数类型形参转换为接收器
convert.function.type.receiver.to.parameter=将函数类型接收器转换为形参
convert.lambda.expression.to.anonymous.function=将 lambda 表达式转换为匿名函数
convert.lambda.to.reference=将 lambda 转换为引用
convert.lambda.to.reference.before.text=lambda' 可以转换为引用
convert.left.hand.side.to.0=将左侧转换为 ''{0}''
convert.member.to.extension=将成员转换为扩展
convert.na.n.equality.quick.fix.text=替换为 'isNaN()'
convert.object.literal.to.class=将对象字面量转换为类
convert.object.literal.to.lambda=将对象字面量转换为 lambda
convert.pair.constructor.to.to.fix.text=替换为中缀 'to'
convert.parameter.to.receiver=将形参转换为接收器
convert.path.to.explicit.collection=将 Path 转换为显式 Collection
convert.property.getter.to.initializer=将属性 getter 转换为初始值设定项
convert.property.initializer.to.getter=将属性初始值设定项转换为 getter
convert.property.to.function=将属性转换为函数
convert.put.to.assignment=将 put 转换为赋值
convert.receiver.parameter.to.context.parameter=将接收器转换为上下文形参
convert.receiver.to.parameter=将接收器转换为形参
convert.reference.to.lambda=将引用转换为 lambda
convert.reference.to.lambda.before.text=引用可以转换为 lambda
convert.right.hand.side.to.0=将右侧转换为 ''{0}''
convert.scope.function.fix.family.name=转换为 ''{0}''
convert.sealed.subclass.to.object.fix.family.name=将 sealed 子类转换为对象
convert.string.template.to.build.string=转换为 'buildString' 调用
convert.string.to.character.literal=将字符串转换为字符字面量
convert.supertype.to.0=将父类型转换为 ''{0}''
convert.template.to.concatenated.string=将模板转换为串联字符串
convert.to.0=转换为 {0}
convert.to.0.as.1=转换为 ''{0} as {1}''
convert.to.0.unsafecast.1=转换为 ''{0}.unsafeCast<{1}>()''
convert.to.a.range.check=转换为范围检查
convert.to.anonymous.function=转换为匿名函数
convert.to.anonymous.object=转换为匿名对象
convert.to.array.parameter=转换为数组形参
convert.to.assignment.expression=将赋值语句转换为表达式
convert.to.block.body=转换为块主体
convert.to.comparisons=转换为比较
convert.to.data.object=转换为 'data object'
convert.to.enum.class=转换为枚举类
convert.to.expression.body.fix.text=转换为表达式主体
convert.to.indexed.function.call=转换为索引函数调用
convert.to.lambda=转换为 lambda
convert.to.lambda.expression=转换为 lambda 表达式
convert.to.lateinit.var=转换为 lateinit 变量
convert.to.lazy.property=转换为延迟属性
convert.to.minus.element.call=转换为 'minusElement' 调用(会更改语义)
convert.to.multi.dollar.string=转换为多美元字符串
convert.to.notnull.delegate=转换为非 null 委托
convert.to.nullable.type=转换为可为 null 类型
convert.to.nullable.type.fix.text=转换为可为 null 类型
convert.to.nullable.var=转换为可为 null 变量
convert.to.object.declaration=转换为对象声明
convert.to.ordinary.property=转换为普通属性
convert.to.ordinary.string.literal=转换为普通字符串字面量
convert.to.plus.element.call=转换为 'plusElement' 调用(会更改语义)
convert.to.primary.constructor=转换为主构造函数
convert.to.primary.constructor.before.text=辅助构造函数应转换为主构造函数
convert.to.raw.string.literal=转换为原始字符串字面量
convert.to.sealed.class=转换为密封类
convert.to.secondary.constructor=转换为辅助构造函数
convert.to.trim.indent=转换为 'trimIndent()' 调用
convert.to.trim.margin=转换为 'trimMargin()' 调用
convert.to.unicode.escape=转换为 Unicode 转义
convert.to.unsafe.cast=转换为不安全的转换
convert.to.unsafecast.call=转换为 unsafeCast() 调用
convert.to.vararg.parameter=转换为 vararg 形参
convert.too.long.character.literal.to.string=将过长的字符字面量转换为字符串
convert.try.finally.to.use=将 'try-finally' 替换为 'use()'
convert.try.finally.to.use.before.text=try-finally 可被替换为 'use()'
convert.value.parameter.to.context.parameter=将值形参转换为上下文形参
copy.concatenation.text.to.clipboard=将串联文本复制到剪贴板
copy.method.of.data.class.is.called.without.named.arguments=应为 'copy()' 方法调用显式指定形参名称
copy.paste.reference.notification=已添加 {0} 个{0, choice, 1\#导入|2\#导入}<p><span><a href\=''show''>检查添加的导入…</a></span>
copy.paste.resolve.pasted.references=解析粘贴的引用
copy.paste.restore.pasted.references=还原粘贴的引用
copy.paste.restore.pasted.references.capitalized=还原粘贴的引用
copy.paste.select.imports.to.remove.dialog=选择要移除的 import
copy.paste.select.imports.to.remove.text=<html>您粘贴的代码段使用了在新上下文中无法访问的元素。已添加必要的 import。<br/>选择要从文件中移除哪些已添加的 import。</html>
could.be.replaced.with.size=可被替换为 'size'
could.be.replaced.with.unboxed.first=可被替换为未装箱的 'first'
could.be.replaced.with.unboxed.last=可被替换为未装箱的 'last'
create.0=创建 {0}
create.0.1=创建 {0} ''{1}''
create.0.in.1=在 {1} 中创建 {0}
create.actual=创建 actual
create.actual.0.for.module.1.2=为模块 {1} 创建实际{0} ({2})
create.actual.in.0=在 ''{0}'' 中创建 actual
create.actuals=创建缺失的 actual…
create.expected.0.in.common.module.1=在通用模块 {1} 中创建预期{0}
create.kotlin.file=创建 Kotlin 文件
create.kotlin.subclass=创建 Kotlin 子类
create.label=创建标签
create.label.0=创建标签 {0}@
create.package.0=创建软件包 ''{0}''
create.parameter.0=创建形参 ''{0}''
create.property.0.as.constructor.parameter=作为构造函数形参创建属性 ''{0}''
create.subclass=创建子类
create.test=创建测试
dangerous.array.comparison=危险的数组比较
declaration.has.type.inferred.from.a.platform.call.which.can.lead.to.unchecked.nullability.issues=声明已从平台调用推断出类型，这可能导致未检查的为 null 性问题。将类型显式指定为可为 null 或不可为 null。
declarations.are.used.outside.of.selected.code.fragment=下面的声明使用于选择的代码段之外\:
declarations.will.move.out.of.scope=以下声明在提取的函数体之外不可用\:
deferred.result.is.never.used='Deferred' 结果未被使用
delegating.to.var.property.does.not.take.its.changes.into.account=委托给 'var' 属性不会考虑其更改
delete.0=删除 {0}
delete.assignment.completely=完全删除赋值
delete.equals.and.hash.code.fix.text=删除 equals()/hashCode()
delete.fix.family.name=移除箭头
delete.redundant.extension.property=删除冗余扩展属性
delete.with.usage.search=删除 (通过用法搜索)
demorgan.law=德摩根定律
deprecated.annotation.without.replacewith.argument=不包含 'replaceWith' 实参的 '@Deprecated' 注解
description.a.reference.to.extracted.type.parameter=引用提取的类型形参
destination.not.found.for.package.0=没有为软件包 ''{0}'' 找到目标
diagnostic.name.should.be.replaced.by.the.new.one=诊断名称应替换为新名称
dialog.message.incorrect.target.path.directory.not.specified=目标路径错误。未指定目录。
dialog.message.none.elements.were.selected=未选择任何元素
dialog.progress.collect.members.to.generate=收集成员…
dialog.title.build.super.types.hierarchy=为 {0} 构建父类型层次结构
dialog.title.resolving.inheritable.status=正在解析可继承状态…
difference.found.for.data.class.0.found.1.2=为数据类 {0} 找到差异。找到 {1} 个用法，但应为 {2}
do.you.want.to.delete.expected.declaration.together.with.all.related.actual.ones=是否要删除预期声明和所有相关实际声明?
do.you.want.to.delete.this.parameter.in.expected.declaration.and.all.related.actual.ones=是否要在预期声明和所有相关实际声明中删除此形参?
do.you.want.to.make.new.extension.an.expected.declaration=是否要将新扩展设为预期声明?
doesn.t.match.regex.0=与正则表达式 ''{0}'' 不匹配
don.t.show.this.dialog.next.time=下次不显示此对话框(&D)
double.negation.fix.text=移除冗余求反
editor.checkbox.title.auto.add.val.keyword.to.data.value.class.constructor.parameters=自动将 'val' 关键字添加到数据/值类构造函数形参
editor.checkbox.title.convert.pasted.java.code.to.kotlin=将粘贴的 Java 代码转换为 Kotlin
editor.checkbox.title.don.t.show.java.to.kotlin.conversion.dialog.on.paste=粘贴时不显示 Java 至 Kotlin 转换对话框
editor.title.kotlin=Kotlin
enter.package.fqname=输入软件包 FqName
enum.entry=枚举条目
equality.check.0.be.used.instead.of.elvis.for.nullable.boolean.check=使用相等检查 {0} 而不是 elvis 进行可为 null 布尔检查
equality.check.with.nan.should.be.replaced.with.isnan=包含 NaN 的相等检查应替换为 'isNaN()'
equals.between.objects.of.inconvertible.types='equals()' 位于不可转换类型的对象之间
equals.hashcode.in.object.declaration=对象声明中的 'equals()'/'hashCode()'
equals.should.take.any.as.its.argument='equals' 应将 'Any?' 作为其实参
equals.text=生成 'equals()'
error.cant.refactor.vararg.functions=不能重构具有可变实参的函数
error.context.getter.or.setter=此上下文仅适用于具有显式 getter/setter 的属性。(将文件类型设置为 Kotlin)
error.expected.an.expression=应为表达式
error.expected.catch.or.finally=应为 'catch' 或 'finally'
error.hint.cannot.modify.0.declaration.from.1.file=无法修改 ''{1}'' 文件中的 ''{0}'' 声明
error.hint.library.declarations.cannot.be.changed=库声明不能更改
error.hint.text.cannot.inline.0.from.a.decompiled.file=无法从反编译文件内联 ''{0}''
error.param.can.t.be.null.at.index.0.in.1=形参在 {1} 中索引 {0} 处不能为 null。
error.text.can.t.change.signature.of.method=无法更改 {0} 方法的签名
error.text.can.t.copy.class.to.the.containing.file=无法将类复制到包含文件
error.text.can.t.generate.0.1=无法生成{0}\: {1}
error.text.can.t.introduce.constant.for.this.expression=无法为此表达式引入常量
error.text.can.t.introduce.constant.for.this.expression.because.not.constant=无法为非常量表达式引入常量
error.text.can.t.introduce.lambda.parameter.for.this.expression=无法为此表达式引入 lambda 形参
error.text.can.t.introduce.property.for.this.expression=无法为此表达式引入属性
error.text.different.name.expected=应为不同名称
error.text.expression.has.no.type=表达式没有类型
error.text.extraction.from.expect.class.is.not.yet.supported=尚不支持从预期类提取
error.text.extraction.from.non.jvm.class.is.not.yet.supported=尚不支持从非 JVM 类提取
error.text.inline.function.is.not.supported.for.functions.with.multiple.return.statements=具有多个 return 语句的函数不支持“内联函数”。
error.text.inline.function.is.not.supported.for.functions.with.return.statements.not.at.the.end.of.the.body=return 语句不在主体末尾的函数不支持“内联函数”。
error.text.interface.cannot.be.extracted.from.an.annotation.class=无法从注解类中提取接口
error.text.introduce.parameter.is.not.available.for.default.value=“引入形参”不适用于默认值
error.text.introduce.parameter.is.not.available.inside.of.annotation.entries=“引入形参”不适用于注解条目内部
error.text.invalid.name=名称无效
error.text.invalid.parameter.name=形参名无效
error.text.invalid.parameter.type=形参类型无效
error.text.invalid.receiver.type=接收器类型无效
error.text.invalid.return.type=返回值类型无效
error.text.no.type.to.refactor=没有要重构的类型
error.text.refactoring.is.not.applicable.in.the.current.context=重构不适用于当前上下文
error.text.superclass.cannot.be.extracted.from.an.annotation.class=无法从注解类中提取超类
error.text.type.reference.is.expected=应为类型引用
error.types.in.generated.function=无法生成返回值类型错误的函数
error.wrong.caret.position.function.or.constructor.name=文本光标应置于要重构的函数或构造函数的名称处。
evaluate.compile.time.expression=对编译时表达式求值
excluded.methods=排除的方法\:
existing.backing.field.is.not.assigned.by.the.setter=现有支持字段未由 setter 分配
expand.boolean.expression.to.if.else=将布尔表达式扩展为 'if else'
experimental.coroutines.usages.are.obsolete.since.1.3=从 1.3 起，实验性协程用法遭到废弃
explicit.0.call=显式 ''{0}'' 调用
explicit.this.expression.fix.family.name=移除冗余的 ''{0}''
explicit.type.arguments.can.be.inferred=显式类型实参可以推断
explicitly.given.type.is.redundant.here=显式给定类型在此处冗余
explicitly.ignore.return.value=显式忽略返回值
expression=表达式
external.interface.contains.non.nullable.property.name=external 接口包含不可为 null 的布尔属性
external.interface.contains.val.property.name=external 接口包含 val 属性
extract.function=提取函数
extract.new.parameter.name.receiver=<接收器>
extract.side.effects=提取副作用
failed.to.create.a.wrapper.for.inlining.to.kotlin=无法创建内联到 Kotlin 的包装器
family.name.update.usages.on.declarations.cut.paste=剪切/粘贴声明时更新用法
file.entity=文件
file.lines=文件行
files.to.visit=要访问的文件
find.declaration.constructor.usages.checkbox=构造函数的用法(&C)
find.declaration.derived.classes.checkbox=派生类(&D)
find.declaration.derived.interfaces.checkbox=派生接口(&I)
find.declaration.functions.usages.checkbox=函数的用法(&F)
find.declaration.implementing.methods.checkbox=实现函数(&I)
find.declaration.implementing.properties.checkbox=实现属性(&I)
find.declaration.include.overloaded.methods.checkbox=包含重载函数和扩展(&V)
find.declaration.overriding.methods.checkbox=重写函数(&R)
find.declaration.overriding.properties.checkbox=重写属性(&R)
find.declaration.properties.usages.checkbox=属性的用法(&P)
find.declaration.property.readers.checkbox=读取器
find.declaration.property.writers.checkbox=编写器
find.usages.checkbox.name.expected.classes=预期类
find.usages.checkbox.name.expected.functions=预期函数
find.usages.checkbox.name.expected.properties=预期属性
find.usages.checkbox.text.fast.data.class.component.search=快速数据类组件搜索
find.usages.class=类
find.usages.class.name.anonymous=匿名
find.usages.companion.object=伴生对象
find.usages.constructor=构造函数
find.usages.facade.class=外观类
find.usages.for.property=属性的{0}
find.usages.function=函数
find.usages.getter=getter
find.usages.import.alias=导入别名
find.usages.interface=接口
find.usages.label=标签
find.usages.lambda=lambda
find.usages.object=对象
find.usages.parameter=形参
find.usages.prepare.dialog.progress=准备对话框
find.usages.progress.text.declaration.superMethods=正在解析 super 方法…
find.usages.property=属性
find.usages.property.accessor=属性访问器
find.usages.setter=setter
find.usages.text.find.usages.for.data.class.components.and.destruction.declarations=<p>查找数据类组件和析构声明的用法<br/>可以<a href\="{0}">一次禁用</a>或<a href\="{1}">单独为项目禁用</a>。</p>
find.usages.tool.tip.text.disable.search.for.data.class.components.and.destruction.declarations.project.wide.setting=禁用搜索数据类组件和析构声明。(项目范围设置)
find.usages.type.alias=类型别名
find.usages.type.callable.reference=可调用引用
find.usages.type.class.object=嵌套类/对象
find.usages.type.companion.object=伴生对象
find.usages.type.constructor.delegation.reference=构造函数委托引用
find.usages.type.delegate=委托
find.usages.type.extension.receiver.type=扩展接收器类型
find.usages.type.function.call=函数调用
find.usages.type.function.return.type=函数返回值类型
find.usages.type.implicit.get=隐式 'get'
find.usages.type.implicit.invoke=隐式 'invoke'
find.usages.type.implicit.iteration=隐式迭代
find.usages.type.implicit.set=隐式 'set'
find.usages.type.is='is' 操作的目标类型
find.usages.type.named.argument=命名实参
find.usages.type.nonLocal.property.type=类/对象属性类型
find.usages.type.packageDirective=软件包指令
find.usages.type.packageMemberAccess=软件包成员访问
find.usages.type.parameter=类型形参
find.usages.type.property.delegation=属性委托
find.usages.type.receiver=接收器
find.usages.type.super.type.qualifier=super 类型限定符
find.usages.type.superType=父类型
find.usages.type.type.alias=类型别名
find.usages.type.type.constraint=类型约束
find.usages.type.value.parameter.type=形参类型
find.usages.variable=变量
fix.add.annotation.family=添加注解
fix.add.annotation.target=添加注解目标
fix.add.annotation.text.constructor=将 ''@{0}'' 注解添加到构造函数
fix.add.annotation.text.containing.class=将 ''@{0}'' 注解添加到包含类 ''{1}''
fix.add.annotation.text.containing.file=将 ''@{0}'' 注解添加到包含文件 ''{1}''
fix.add.annotation.text.declaration=将 ''@{0}'' 注解添加到 ''{1}''
fix.add.annotation.text.self=添加 ''@{0}'' 注解
fix.add.annotation.with.arguments.text.copy=将 ''@{0}'' 注解从 ''{1}'' 复制到 ''{2}''
fix.add.argument.name.family=将名称添加到实参
fix.add.argument.name.step.choose.parameter.title=选择形参名称
fix.add.argument.name.text=将名称添加到实参\: ''{0}''
fix.add.argument.name.text.generic=将名称添加到实参…
fix.add.array.of.type.family=添加 'arrayOf' 包装器
fix.add.array.of.type.text=添加 {0} 包装器
fix.add.constructor.parameter=添加构造函数形参 ''{0}''
fix.add.default.constructor=将默认构造函数添加到 'expect' 类
fix.add.else.branch.when=添加 else 分支
fix.add.eq.eq.true=添加 '\=\= true'
fix.add.exception.to.throws=添加 ''{0}''
fix.add.explicit.coroutine.scope.receiver=添加显式 'this' 接收器
fix.add.explicit.import=添加显式导入
fix.add.explicit.receiver.family=添加显式接收器
fix.add.function.body=添加函数体
fix.add.function.parameters.add.parameter.constructor=将第 {0,number,ordinal} 个{1,choice,1\#形参|2\#形参}添加到构造函数 ''{2}''
fix.add.function.parameters.add.parameter.function=将第 {0,number,ordinal} 个{1,choice,1\#形参|2\#形参}添加到函数 ''{2}''
fix.add.function.parameters.add.parameter.generic.constructor=将{0,choice,1\#形参|2\#形参}添加到构造函数 ''{1}''
fix.add.function.parameters.add.parameter.generic.function=将{0,choice,1\#形参|2\#形参}添加到函数 ''{1}''
fix.add.function.parameters.change.signature.constructor=更改构造函数 ''{0}'' 的签名
fix.add.function.parameters.change.signature.function=更改函数 ''{0}'' 的签名
fix.add.generic.upperbound.family=添加泛型上限
fix.add.generic.upperbound.text=作为 {1} 的上限添加 ''{0}''
fix.add.is.to.when=在 ''{0}'' 前面添加 ''is''
fix.add.loop.label.text=将 ''{0}'' 添加到 {1}
fix.add.loop.label.text.generic=将标签添加到循环
fix.add.member.supertype.add.to=将 ''{0}'' 添加到 ''{1}''
fix.add.member.supertype.choose.type=选择类型
fix.add.member.supertype.family=将 {0} 添加到父类型
fix.add.member.supertype.progress=将 {0} 添加到类型
fix.add.member.supertype.text=将 {0} 添加到父类型…
fix.add.modifier.family=添加修饰符
fix.add.modifier.inline.function.family=将 'inline' 添加到函数
fix.add.modifier.inline.function.text=将 ''inline'' 添加到函数 ''{0}''
fix.add.modifier.inline.parameter.family=将 ''{0}'' 添加到形参
fix.add.modifier.inline.parameter.text=将 ''{0}'' 添加到形参 ''{1}''
fix.add.modifier.text=使{0} ''{1}''
fix.add.modifier.text.generic=添加 ''{0}'' 修饰符
fix.add.new.line.after.annotations=在注解后面添加新行
fix.add.remaining.branches=添加剩余的分支
fix.add.remaining.branches.with.star.import=使用 * 导入添加剩余的分支
fix.add.return.before.expression=在表达式前面添加 'return'
fix.add.return.before.lambda.expression=在 lambda 表达式前面添加 'run'
fix.add.return.last.expression=将 'return' 添加到上一个表达式
fix.add.semicolon.lambda.expression=使用分号终止前面的调用
fix.add.spread.operator.after.sam=在作为 'vararg' 传递的数组之前添加展开运算符
fix.add.star.projection.family=添加星号投影
fix.add.star.projection.text=添加 ''{0}''
fix.add.suspend.modifier.function=将 {0} 设为suspend
fix.add.suspend.modifier.function.generic=使包含函数挂起
fix.add.suspend.modifier.receiver=使{0}类型挂起
fix.add.suspend.modifier.receiver.generic=使接收器类型挂起
fix.add.tostring.call.family=添加 'toString()' 调用
fix.add.tostring.call.text=添加 'toString()' 调用
fix.add.tostring.call.text.safe=添加安全的 '?.toString()' 调用
fix.add.type.annotation.family=添加类型注解
fix.add.type.annotation.text=将类型 ''{0}'' 添加到形参 ''{1}''
fix.assign.to.property=分配给属性
fix.cast.expression.family=转换表达式
fix.cast.expression.text=将表达式 ''{0}'' 转换为 ''{1}''
fix.change.accessor.family=更改访问器类型
fix.change.accessor.getter=将 getter 类型更改为 {0}
fix.change.accessor.setter.parameter=将 setter 形参类型更改为 {0}
fix.change.jvm.name=更改 JVM 名称
fix.change.mutability.change.to.val=将 ''{0}'' 更改为 val
fix.change.object.to.class=将 'object' 更改为 'class'
fix.change.package.family=更改文件的软件包以匹配目录
fix.change.package.text=将文件的软件包更改为 {0}
fix.change.progress.analyzing.class.hierarchy=正在分析类层次结构…
fix.change.progress.looking.inheritors=正在查找类 {0} 继承者…
fix.change.return.type.command.function=将函数 ''{1}'' 的形参 ''{0}'' 类型更改为 ''{2}''
fix.change.return.type.command.primary.constructor=将类 ''{1}'' 的主构造函数的形参 ''{0}'' 类型更改为 ''{2}''
fix.change.return.type.family=更改类型
fix.change.return.type.lambda=将 lambda 表达式返回值类型更改为 {0}
fix.change.return.type.presentation.accessed=访问的{0}
fix.change.return.type.presentation.base=基{0}
fix.change.return.type.presentation.called=调用的{0}
fix.change.return.type.presentation.called.function=调用的函数
fix.change.return.type.presentation.enclosing=封闭的 {0}
fix.change.return.type.presentation.enclosing.function=封闭的函数
fix.change.return.type.presentation.function=函数 {0}
fix.change.return.type.presentation.property=属性 {0}
fix.change.return.type.remove.explicit.return.type=移除显式指定的返回值类型
fix.change.return.type.remove.explicit.return.type.of=移除 {0} 的显式指定的返回值类型
fix.change.return.type.return.type.text=将返回值类型更改为 ''{0}''
fix.change.return.type.return.type.text.of=将 {0} 的返回值类型更改为 ''{1}''
fix.change.return.type.text.function=将函数 ''{1}'' 的形参 ''{0}'' 类型更改为 ''{2}''
fix.change.return.type.text.primary.constructor=将类 ''{1}'' 主构造函数的形参 ''{0}'' 类型更改为 ''{2}''
fix.change.return.type.type.text=将类型更改为 ''{0}''
fix.change.return.type.type.text.of=将 {0} 的类型更改为 ''{1}''
fix.change.signature.error=<错误>
fix.change.signature.family=更改函数/构造函数的签名
fix.change.signature.function.family=更改函数签名
fix.change.signature.function.popup.title=选择签名
fix.change.signature.function.text=将函数签名更改为 ''{0}''
fix.change.signature.function.text.generic=更改函数签名…
fix.change.signature.lambda=更改 lambda 表达式的签名
fix.change.signature.lambda.command=更改 Lambda 表达式的签名
fix.change.signature.prepare=准备…
fix.change.signature.remove.parameter=移除形参 ''{0}''
fix.change.signature.remove.parameter.command=移除形参 ''{0}''
fix.change.signature.unavailable=<不可用>
fix.change.signature.unnamed.parameter=形参
fix.change.suspend.hierarchy.add=将 'suspend' 修饰符添加到层次结构中的所有函数
fix.change.suspend.hierarchy.remove=从层次结构中的所有函数中移除 'suspend' 修饰符
fix.change.to.function.invocation=更改为函数调用
fix.change.to.labeled.return.family=更改为带标签的返回
fix.change.to.labeled.return.text=更改为 ''{0}''
fix.change.to.mutable.type.family=将类型更改为可变
fix.change.to.mutable.type.text=将类型更改为 {0}
fix.change.to.property.access.family.change=更改为属性访问
fix.change.to.property.access.family.remove=移除调用
fix.change.to.star.projection.family=更改为星号投影
fix.change.to.star.projection.text=将类型实参更改为 {0}
fix.change.to.use.spread.operator.family=更改为使用展开运算符
fix.change.to.use.spread.operator.text=将 ''{0}'' 更改为 ''{1}''
fix.change.type.argument=将类型实参更改为 {0}
fix.change.type.family=更改类型
fix.change.type.text=将类型从 ''{0}'' 更改为 ''{1}''
fix.convert.to.is.array.of.call=转换为 'isArrayOf' 调用
fix.copy.mismatched.annotation.to.actual.declaration.may.change.semantics=将不匹配的注解 ''{0}'' 从 ''expect'' 声明复制到 ''actual'' 声明(可能会更改语义)
fix.create.declaration.error=无法生成 {0}\: {1}
fix.create.declaration.error.inaccessible.type=无法访问的类型
fix.create.declaration.error.some.types.inaccessible=有些类型无法访问\:
fix.create.expect.actual=创建预期/实际声明
fix.create.from.usage.abstract.property=创建抽象属性 ''{0}''
fix.create.from.usage.dialog.title=根据用法创建
fix.create.from.usage.extension.property=创建扩展属性 ''{0}''
fix.create.from.usage.family=从用法创建
fix.create.from.usage.local.variable=创建局部变量 ''{0}''
fix.create.from.usage.property=创建属性 ''{0}''
fix.create.missing.actual.declarations=添加缺少的实际声明
fix.create.missing.actual.declarations.title=添加缺少的实际声明
fix.create.missing.actual.members=添加缺少的实际成员
fix.import=Import
fix.import.exclude=从自动导入中排除 ''{0}''
fix.import.kind.0.name.1.2=导入{0} ''{1}''{2,choice,0\#|1\# 和其他 {2} 个}
fix.import.kind.0.name.1.and.name.2=导入{0} ''{1}''、''{2}''
fix.import.kind.component.functions=组件函数
fix.import.kind.delegate.accessors=委托访问器
fix.import.question=导入{0}?
fix.insert.delegation.call=插入 ''{0}()'' 调用
fix.introduce.non.null.assertion.family=添加非 null 断言调用
fix.introduce.non.null.assertion.text=添加非 null 断言({0}\!\!)调用
fix.make.data.class=将 ''{0}'' 设为数据类
fix.make.field.public.family=将字段设为 public
fix.make.field.public.text=将字段 ''{0}'' 设为 public
fix.make.type.parameter.reified=使 {0} 具体化且使 {1} 内联
fix.make.upperbound.not.nullable.any.text=将 ''Any'' 添加为 {0} 的上限以使其不可为 null
fix.make.upperbound.not.nullable.family=使泛型类型形参不可为 null
fix.make.upperbound.not.nullable.remove.nullability.text=将 {0} 的上限更改为 ''{1}'' 以使 {0} 不可为 null
fix.move.file.to.package.dir.name.text=源根
fix.move.file.to.package.family=将文件移至软件包匹配目录
fix.move.file.to.package.text=将文件移至{0}
fix.move.to.sealed.family=将层次结构成员移至其密封父级的软件包/模块
fix.move.to.sealed.text=将 {0} 移至 {1} 的软件包/模块
fix.move.typealias.to.top.level=将类型别名移到顶层
fix.opt_in.annotation.family=注解选择加入功能用法
fix.opt_in.migrate.experimental.annotation.remove=移除已弃用的 '@Experimental' 注解
fix.opt_in.migrate.experimental.annotation.replace=将已弃用的 '@Experimental' 注解替换为 '@RequiresOptIn'
fix.opt_in.move.requirement.from.getter.to.property=将 ''{0}'' 选择加入要求从 getter 移至属性
fix.opt_in.move.requirement.from.value.parameter.to.property=将 ''{0}'' 选择加入要求从值形参移至属性
fix.opt_in.remove.all.forbidden.targets=移除禁止的选择加入注解目标
fix.opt_in.remove.forbidden.retention=移除禁止的选择加入注解保留
fix.opt_in.text.propagate.constructor=将 ''{0}'' 选择加入要求传播到构造函数
fix.opt_in.text.propagate.containing.class=将 ''{0}'' 选择加入要求传播到所包含的类 ''{1}''
fix.opt_in.text.propagate.containing.object=将 ''{0}'' 选择加入要求传播到包含对象 ''{1}''
fix.opt_in.text.propagate.declaration=将 ''{0}'' 选择加入要求传播到 ''{1}''
fix.opt_in.text.use.constructor=在构造函数上选择加入 ''{0}''
fix.opt_in.text.use.containing.anonymous.object=在包含对象上选择加入 ''{0}''
fix.opt_in.text.use.containing.class=在所包含的类 ''{1}'' 上选择加入 ''{0}''
fix.opt_in.text.use.containing.file=在所包含的文件 ''{1}'' 中选择加入 ''{0}''
fix.opt_in.text.use.containing.object=在包含对象 ''{1}'' 上选择加入 ''{0}''
fix.opt_in.text.use.declaration=在 ''{1}'' 上选择加入 ''{0}''
fix.opt_in.text.use.module=在模块 ''{1}'' 中选择加入 ''{0}''
fix.opt_in.text.use.statement=在语句上选择加入 ''{0}''
fix.potentially.broken.inheritance.message=此更改可能会破坏继承者
fix.receiver.shadowed.by.context.add.explicit.receiver.context=使用 ''{0}'' 作为接收器
fix.receiver.shadowed.by.context.add.explicit.receiver.family=添加显式接收器
fix.receiver.shadowed.by.context.add.explicit.receiver.surround.with=用 'with(this) { ... }' 包围
fix.receiver.shadowed.by.context.add.explicit.receiver.surround.with.context=用 ''with({0}) '{' ... '}''' 包围
fix.receiver.shadowed.by.context.add.explicit.receiver.this=使用 'this' 作为接收器
fix.remove.annotation.text=移除注解
fix.remove.argument.text=移除实参
fix.remove.mismatched.annotation.from.expect.declaration.may.change.semantics=从 ''expect'' 声明中移除不匹配的注解 ''{0}'' (可能会更改语义)
fix.remove.non.null.assertion=移除不必要的非 null 断言(\!\!)
fix.remove.redundant.star.text=移除冗余的 *
fix.replace.annotation.family=替换注解
fix.replace.annotation.text=将注解替换为 ''@{0}''
fix.replace.mismatched.annotation.args.on.actual.declaration.may.change.semantics=替换 ''actual'' 声明中不匹配的注解 ''{0}'' 的实参(可能会更改语义)
fix.replace.mismatched.annotation.args.on.expect.declaration.may.change.semantics=替换 ''expect'' 声明中不匹配的注解 ''{0}'' 的实参(可能会更改语义)
fix.replace.run.blocking.with.inline=用内联代码替换 'runBlocking'
fix.replace.run.blocking.with.run=将 'runBlocking' 替换为 'run'
fix.replace.run.blocking.with.withContext=将 'runBlocking' 替换为 'withContext'
fix.replace.run.family=将 'runBlocking' 替换为内联执行、'withContext' 或 'run'
fix.replace.with.assign.function.call=替换为 ''{0}'' 调用
fix.replace.with.declaring.java.class=替换为 'declaringJavaClass'
fix.unused.receiver.parameter.remove=移除冗余的接收器形参
fix.use.fully.qualified.call=使用完全限定的调用
fix.with.asdynamic=使用 'asDynamic' 修复
flatten.when.expression=平展 'when' 表达式
flip.0=翻转 ''{0}''
flip.binary.expression=翻转二元表达式
flip.equals=翻转 'equals'
floating.point.literal.precision.inspection=浮点字面量无法以所需的精度表示
floating.point.literal.precision.inspection.display.name=浮点字面量超出可用精度
flow.constructed.but.not.used=Flow 已构建但未使用
foldable.if.then=可折叠的 if-then
following.expression.won.t.be.processed.since.refactoring.can.t.preserve.its.semantics.0=不会处理下列表达式，因为重构无法保留其语义\: {0}
following.problems.are.found=发现以下问题\:\n
for.0=对于 ''{0}''
for.api.stability.it.s.recommended.to.specify.explicitly.declaration.types=为确保 API 稳定性，建议显式指定声明类型
for.api.stability.it.s.recommended.to.specify.explicitly.public.protected.declaration.types=为确保 API 稳定性，建议显式指定 public 和 protected 声明类型
for.loop.over.indices.could.be.replaced.with.loop.over.elements=索引的循环可被替换为元素的循环
formatter.button.text.use.import.with=将 import 与 '*' 搭配使用
formatter.button.text.use.import.with.when.at.least=至少以下条件下将 import 与 '*' 搭配使用
formatter.button.text.use.single.name.import=使用单个名称导入
formatter.checkbox.text.collection.literal.expression=集合字面量表达式
formatter.checkbox.text.context.receiver.list=上下文接收器列表
formatter.checkbox.text.destructuring.declaration=析构声明
formatter.checkbox.text.function.literal=函数字面量
formatter.checkbox.text.indices=索引
formatter.checkbox.text.insert.imports.for.nested.classes=为嵌套类插入导入
formatter.checkbox.text.type.argument.list=类型实参列表
formatter.checkbox.text.type.parameter.list=类型形参列表
formatter.checkbox.text.use.trailing.comma=使用尾随逗号
formatter.checkbox.text.value.argument.list=值实参列表
formatter.checkbox.text.value.parameter.list=值形参列表
formatter.checkbox.text.when.entry=进入时
formatter.settings.title=Kotlin 格式化程序设置
formatter.text.names.used=\ 使用的名称
formatter.text.use.defaults.from=使用以下位置的默认值\:
formatter.title.after.colon.before.declaration.type=冒号后，声明类型前
formatter.title.after.colon.in.new.type.definition=新类型定义中的冒号后
formatter.title.align.when.branches.in.columns=对齐列中的 'when' 分支
formatter.title.around.arrow.in=“when”子句中箭头周围
formatter.title.around.arrow.in.function.types=函数类型中箭头周围
formatter.title.around.when.branches.with=带有 {} 的 'when' 分支周围
formatter.title.before.colon.after.declaration.name=冒号前，声明名称后
formatter.title.before.colon.in.new.type.definition=新类型定义中的冒号前
formatter.title.before.declaration.with.comment.or.annotation=在带有注释或注解的声明之前
formatter.title.before.lambda.arrow=lambda 箭头前
formatter.title.chained.function.calls=链式函数调用
formatter.title.elvis.expressions=Elvis 表达式
formatter.title.elvis.operator=Elvis 运算符(?\:)
formatter.title.expression.body.functions=表达式主体函数
formatter.title.function.annotations=函数注解
formatter.title.function.call.arguments=函数调用实参
formatter.title.function.context.parameters=函数上下文形参
formatter.title.function.declaration.parameters=函数声明形参
formatter.title.function.parentheses=函数括号
formatter.title.in.simple.one.line.methods=在简单的一行方法中
formatter.title.indent.before.arrow.on.new.line=在新行的 '->' 前缩进
formatter.title.java.statics.and.enum.members=Java static 和枚举成员
formatter.title.line.break.after.multiline.when.entry=在多行条目后换行
formatter.title.load.save=加载/保存
formatter.title.other=其他
formatter.title.property.annotations=属性注解
formatter.title.property.context.parameters=属性上下文形参
formatter.title.put.left.brace.on.new.line=将左大括号置于新行中
formatter.title.range.operator=范围运算符 (..、..<)
formatter.title.top.level.symbols=顶级符号
formatter.title.trailing.comma=尾随逗号
formatter.title.use.continuation.indent=使用延续缩进
formatter.title.use.continuation.indent.in.conditions=在条件中使用延续缩进
formatter.title.when.parentheses='when' 括号
formatter.title.when.statements='when' 语句
function=函数
function.0=函数 ''{0}''
function.0.returning.1.without.the.corresponding=函数 ''{0}'' 返回 ''{1}''，而相应的函数 ''{2}'' 未返回 ''{3}''
function.01=函数“{0}”
function.name.is.invalid=函数名无效
function.returning.0.with.a.name.that.does.not.end.with.1=返回名称不以 {1} 结尾的 {0} 的函数
function.should.have.operator.modifier=函数应具有 'operator' 修饰符
generate.equals.and.hashcode.fix.text=生成 equals() 和 hashCode()
generate.identity.equals.fix.family.name=通过标识生成 equals 和 hashCode
goto.related.provider.in.module.0=(在模块 {0} 中)
goto.super.chooser.class.title=选择超类或接口
goto.super.chooser.function.title=选择 super 函数
goto.super.chooser.property.title=选择 super 属性
group.InternalKotlin.text=Kotlin 内部操作
group.KotlinCompletionBenchmarkGroup.text=基准补全
group.KotlinInternalGroup.text=Kotlin
group.KotlinRefactoringTesting.text=Kotlin 重构测试
group.KotlinToolsGroup.text=Kotlin
group.advanced.settings.kotlin=Kotlin
group.names.code.migration=代码迁移
group.names.coroutine=协程检查
group.names.gradle=Gradle
group.names.java.interop.issues=Java 互操作问题
group.names.kotlin=Kotlin
group.names.logging=日志记录
group.names.maven=Maven
group.names.migration=迁移
group.names.naming.conventions=命名约定
group.names.numeric.issues=数值问题
group.names.other.problems=其他问题
group.names.probable.bugs=可能的 bug
group.names.redundant.constructs=冗余结构
group.names.style.issues=样式问题
group.path.kotlin.migration=Kotlin，迁移
hash.code.text=生成 'hashCode()'
hierarchy.legend.member.defined.in.superclass=成员未在类中定义，但在超类中定义
hierarchy.legend.member.is.defined.in.class=成员在类中定义
hierarchy.legend.member.should.be.defined=应定义成员，因为类不为 abstract
hierarchy.text.anonymous=[匿名]
hierarchy.text.in=\ 在 {0} 中
highlight.usages.of.receiver=高亮显示接收器的用法
highlighter.action.text.go.to.actual.declarations=转到实际声明
highlighter.action.text.go.to.expected.declaration=转到预期声明
highlighter.action.text.go.to.implementations=转到实现
highlighter.action.text.go.to.overridden.methods=转到重写方法
highlighter.action.text.go.to.overridden.properties=转到重写属性
highlighter.action.text.go.to.subclasses=转到子类
highlighter.action.text.go.to.super.method=转到 super 方法
highlighter.action.text.go.to.super.property=转到 super 属性
highlighter.descriptor.text.android.extensions.property=属性和变量//Android 扩展合成属性
highlighter.descriptor.text.annotation=注解//注解名称
highlighter.descriptor.text.annotation.attribute.name=注解//注解特性名称
highlighter.descriptor.text.arrow=括号和运算符//箭头
highlighter.descriptor.text.builtin.annotation=关键字//修饰符
highlighter.descriptor.text.builtin.keyword=关键字//关键字
highlighter.descriptor.text.builtin.keyword.val=关键字//'val'
highlighter.descriptor.text.builtin.keyword.var=关键字//'var'
highlighter.descriptor.text.captured.variable=属性和变量//闭包中捕获的变量和值
highlighter.descriptor.text.closure.braces=括号和运算符//lambda 表达式大括号和箭头
highlighter.descriptor.text.colon=大括号和运算符//冒号
highlighter.descriptor.text.constructor.call=函数//构造函数调用
highlighter.descriptor.text.data.class=类和接口//数据类
highlighter.descriptor.text.data.object=类和接口//数据对象
highlighter.descriptor.text.double.colon=括号和运算符//双重冒号
highlighter.descriptor.text.dynamic.fun.call=函数//动态函数调用
highlighter.descriptor.text.dynamic.property=属性和变量//动态属性
highlighter.descriptor.text.enum=类和接口//枚举
highlighter.descriptor.text.enumEntry=类和接口//枚举条目
highlighter.descriptor.text.exclexcl=括号和运算符//非 null 断言
highlighter.descriptor.text.extension.fun.call=函数//扩展函数调用
highlighter.descriptor.text.extension.property=属性和变量//扩展属性
highlighter.descriptor.text.field=属性和变量//支持字段变量
highlighter.descriptor.text.fun=函数//函数声明
highlighter.descriptor.text.fun.call=函数//函数调用
highlighter.descriptor.text.instance.property=属性和变量//实例属性
highlighter.descriptor.text.instance.property.custom.property.declaration=属性和变量//包含自定义属性声明的实例属性
highlighter.descriptor.text.it=形参//lambda 表达式默认形参
highlighter.descriptor.text.kdoc.comment=注释//KDoc//KDoc 注释
highlighter.descriptor.text.kdoc.tag=注释//KDoc//KDoc 标记
highlighter.descriptor.text.kdoc.value=注释//KDoc//KDoc 标记中的链接
highlighter.descriptor.text.label=标签
highlighter.descriptor.text.local.variable=属性和变量//局部变量或值
highlighter.descriptor.text.named.argument=命名实参
highlighter.descriptor.text.object=类和接口//对象
highlighter.descriptor.text.package.fun.call=函数//软件包级函数调用
highlighter.descriptor.text.package.property=属性和变量//软件包级属性
highlighter.descriptor.text.package.property.custom.property.declaration=属性和变量//包含自定义属性声明的软件包级属性
highlighter.descriptor.text.quest=括号和运算符//为 null 性类型标记
highlighter.descriptor.text.safe.access=括号和运算符//安全访问的点
highlighter.descriptor.text.smart.cast=智能转换//智能转换值
highlighter.descriptor.text.smart.cast.receiver=智能转换//智能转换隐式接收器
highlighter.descriptor.text.smart.constant=智能转换//智能常量
highlighter.descriptor.text.string.escape=字符串//字符串和模板大括号中的转义
highlighter.descriptor.text.suspend.fun.call=函数//挂起函数调用
highlighter.descriptor.text.synthetic.extension.property=属性和变量//合成扩展属性
highlighter.descriptor.text.typeAlias=类和接口//类型别名
highlighter.descriptor.text.var=属性和变量//Var (可变变量、形参或属性)
highlighter.descriptor.text.variable.as.function.call=属性和变量//变量作为函数调用
highlighter.descriptor.text.variable.as.function.like.call=属性和变量//变量作为类似函数的调用
highlighter.message.suspend.function.call=挂起函数调用
highlighter.message.suspending.iteration=正在挂起迭代
highlighter.name.dsl=Dsl//
highlighter.name.dsl.markers=DSL 标记
highlighter.name.expect.actual.line.markers=Kotlin 'expect'//'actual' 行标记
highlighter.name.implemented.declaration=实现的声明
highlighter.name.implementing.declaration=实现声明
highlighter.name.kotlin.line.markers=Kotlin 行标记
highlighter.name.multiplatform.actual.declaration=多平台实际声明
highlighter.name.multiplatform.expect.declaration=多平台预期声明
highlighter.name.overridden.declaration=重写的声明
highlighter.name.overriding.declaration=重写声明
highlighter.name.style=样式 {0}
highlighter.notification.text.navigation.to.overriding.classes.is.not.possible.during.index.update=索引更新时无法导航到重写类
highlighter.prefix.text.has.actuals.in=在 {0} {1, choice, 0\#模块|1\#模块}中存在 actual
highlighter.text.click.for.navigate=点击“{0}”进行导航
highlighter.text.has.functional.implementations=具有函数实现
highlighter.text.implements=实现
highlighter.text.in=''{1}'' 中的 {0}
highlighter.text.or.press=\ 或按 {0}
highlighter.text.overrides=重写
highlighter.title.overriding.declarations.of={0} 的重写声明
highlighter.title.searching.for.overriding.declarations=正在搜索重写声明
highlighter.title.searching.for.overriding.methods=正在搜索重写方法
highlighter.tool.tip.has.expect.declaration.in=在 {0} {1, choice, 0\#模块|1\#模块}中存在 expect
highlighter.tool.tip.marker.annotation.for.dsl=DSL 的标记注解
highlighter.tool.tip.text.function=函数
highlighter.tool.tip.text.property=属性
highlighter.tool.tip.text.recursive.call=递归调用
hint.text.no.expression.found=找不到表达式
hints.codevision.implementations.format={0, choice, 1\#1 个实现|2\#{0,number} 个实现}
hints.codevision.implementations.too_many.format={0,number}+ 实现
hints.codevision.inheritors.format={0, choice, 1\#1 个继承者|2\#{0,number} 个继承者}
hints.codevision.inheritors.to_many.format={0,number}+ 继承者
hints.codevision.overrides.format={0, choice, 1\#1 个重写|2\#{0,number} 个重写}
hints.codevision.overrides.to_many.format={0,number}+ 重写
hints.codevision.settings=设置…
hints.codevision.usages.format={0, choice, 1\#1 个用法|2\#{0,number} 个用法}
hints.codevision.usages.too_many.format={0,number}+ 用法
hints.description.compiler.plugins.declarations=Kotlin 编译器插件生成的声明
hints.description.compiler.plugins.modality=提供声明模态由 Kotlin 编译器插件更改的提示
hints.description.compiler.plugins.supertypes=提供父类型由 Kotlin 编译器插件生成的提示
hints.ranges.greaterOrEqual=≥
hints.ranges.less=<
hints.ranges.lessOrEqual=≤
hints.settings.common.items=显示以下项的提示\:
hints.settings.compiled.parameters=编译的形参名称
hints.settings.compiler.plugins.declarations=Kotlin 编译器插件生成的声明
hints.settings.compiler.plugins.declarations.show.hidden.description=显示调用站点不可见的声明
hints.settings.compiler.plugins.declarations.show.hidden.name=显示隐藏的声明
hints.settings.compiler.plugins.modality=Kotlin 编译器插件更改的模态
hints.settings.compiler.plugins.supertypes=Kotlin 编译器插件添加的父类型
hints.settings.default.parameters=默认形参值
hints.settings.dont.show.lambda.receivers.parameters=不显示隐式接收器和形参提示
hints.settings.dont.show.lambda.return=不显示返回表达式提示
hints.settings.dont.show.ranges=不显示范围提示
hints.settings.dont.show.suspending=不显示挂起调用提示
hints.settings.dont.show.types.parameter=不显示函数形参类型提示
hints.settings.dont.show.types.property=不显示属性类型提示
hints.settings.dont.show.types.return=不显示函数返回值类型提示
hints.settings.dont.show.types.variable=不显示局部变量类型提示
hints.settings.excluded.parameters=排除的形参名称
hints.settings.lambda.receivers.parameters=隐式接收器和形参
hints.settings.lambda.return=返回表达式
hints.settings.lambdas=Lambda
hints.settings.parameters=形参
hints.settings.ranges=范围
hints.settings.show.lambda.receivers.parameters=显示隐式接收器和形参提示
hints.settings.show.lambda.return=显示返回表达式提示
hints.settings.show.ranges=显示范围提示
hints.settings.show.suspending=显示挂起调用提示
hints.settings.show.types.parameter=显示函数形参类型提示
hints.settings.show.types.property=显示属性类型提示
hints.settings.show.types.return=显示函数返回值类型提示
hints.settings.show.types.variable=显示局部变量类型提示
hints.settings.suspending=正在暂停调用
hints.settings.types=类型
hints.settings.types.parameter=函数形参类型
hints.settings.types.property=属性类型
hints.settings.types.return=函数返回值类型
hints.settings.types.variable=局部变量类型
hints.settings.value.kotlin.time=kotlin.time 警告
hints.settings.value.ranges=范围
hints.settings.values.ranges=范围
hints.title.argument.name.enabled=实参名称
hints.title.codevision=Code Vision
hints.title.dont.show.argument.name.enabled=不显示实参名称提示
hints.title.show.argument.name.enabled=显示实参名称提示
hints.tooltip.compiler.plugins.declarations=由 Kotlin 编译器插件生成
hints.tooltip.compiler.plugins.declarations.expand=由 Kotlin 编译器插件生成的 Kotlin 声明。展开类主体以查看它们
hints.tooltip.compiler.plugins.modality=Kotlin 编译器插件将模态从 ''{0}'' 更改为 ''{1}''
hints.tooltip.compiler.plugins.supertypes=Kotlin 编译器插件添加的父类型
hints.types=类型提示
if.null.return.break.foldable.to=If-Null return/break/... 可折叠为 '?\:'
if.then.foldable.to=If-Then 可折叠为 '?\:'
ignore.imports.and.formatting=忽略导入和格式设置
implement.abstract.class=实现抽象类
implement.abstract.function=实现 abstract 函数
implement.abstract.member=实现 abstract 成员
implement.abstract.property=实现 abstract 属性
implement.as.constructor.parameter=作为构造函数形参实现
implement.interface=实现接口
implement.sealed.class=实现密封类
implicit.nothing.s=隐式无内容
implicit.parameter.it.of.enclosing.lambda.is.shadowed=封闭 lambda 的隐式形参 'it' 已被隐藏
implicit.unsafe.cast.from.dynamic.to.0=从动态到 {0} 的隐式 (不安全) 转换
import.members.from.0=从 ''{0}'' 导入成员
import.members.with=导入带有 '*' 的成员
import.optimizer.notification.text.unused.imports.not.found=找不到未使用的 import
import.optimizer.progress.indicator.text.collect.imports.for=收集 {0} 的导入
import.optimizer.text.import={0, choice, 0\#导入|2\#导入}
import.optimizer.text.non.zero=移除的{0} {1}{2, choice, 0\#|1\#, 添加的{2} {3}}
import.optimizer.text.zero=重新排列的导入
import.order.button.text.add.package=添加软件包
import.order.button.text.down=下
import.order.button.text.remove=移除
import.order.button.text.up=上
import.progress.text.resolve.imports=查找所有 import…
import.text.all.alias.imports=所有别名导入
import.text.all.other.imports=所有其他导入
import.text.import=导入
in.class.0=在类 ''{0}'' 中
inaccessible.declaration=无法访问的声明
incomplete.destructuring.declaration.text=析构声明不完整
incomplete.destructuring.fix.family.name=将缺失的变量添加到析构声明
indent.raw.string=缩进原始字符串
index.is.not.used.in.the.loop.body=索引未在循环体中使用
infix.call.may.be.dot.call=中缀调用可以是点调用
inheritance.of.kotlin.sealed=Java {0,choice,0\#接口|1\#类}不能作为 Kotlin 密封层次结构的一部分
initialize.with.constructor.parameter=使用构造函数形参初始化
initialize.with.constructor.parameter.analyzing.existing.variables=正在分析现有变量…
initializer.is.redundant=初始值设定项冗余
inlay.kotlin.call.chains.hints=显示调用链的嵌入提示
inlay.kotlin.compiler.plugins.declarations.description=Kotlin 编译器插件生成的声明
inlay.kotlin.default.parameters.hints=在重写的方法中显示默认形参值
inlay.kotlin.lambdas.hints=显示 lambda 的嵌入提示
inlay.kotlin.lambdas.hints.hints.lambda.receivers.parameters=显示隐式接收器和形参的嵌入提示
inlay.kotlin.lambdas.hints.hints.lambda.return=显示返回表达式的嵌入提示
inlay.kotlin.parameters.hints=在函数调用点显示形参名称。
inlay.kotlin.parameters.hints.compiled=显示编译后的形参名称
inlay.kotlin.parameters.hints.excluded=显示排除的形参名称
inlay.kotlin.references.types.hints=显示类型的嵌入提示
inlay.kotlin.references.types.hints.hints.type.function.parameter=显示函数形参类型的嵌入提示
inlay.kotlin.references.types.hints.hints.type.function.return=显示函数返回值类型的嵌入提示
inlay.kotlin.references.types.hints.hints.type.property=显示属性类型的嵌入提示
inlay.kotlin.references.types.hints.hints.type.variable=显示局部变量类型的嵌入提示
inlay.kotlin.value.kotlin.time=显示 kotlin.time 软件包警告嵌入提示
inlay.kotlin.value.ranges=显示范围的嵌入提示
inlay.kotlin.values.hints=显示值的嵌入提示
inlay.kotlin.values.hints.kotlin.values.ranges=显示范围的嵌入提示
inline.type.parameter=内联类型形参
inline.variable=内联变量
inline.when.argument=内联 'when' 实参
insert.curly.braces.around.variable=在变量周围插入大括号
insert.explicit.delegation.call=插入显式委托调用
insert.number.conversion=插入数字转换
inspection.add.annotation.target.problem.description=该注解仅适用于形参。建议使用显式注解使用位置目标。
inspection.add.conversion.call.display.name=自 1.9 起需要从 `Int` 显式转换
inspection.add.kotlin.coroutines.display.name=添加 Kotlin 协程库
inspection.add.operator.modifier.display.name=函数应具有 'operator' 修饰符
inspection.add.variance.modifier.display.name=类型形参可以具有 'in' 或 'out' 差异
inspection.ambiguous.actuals.display.name=不明确的 actual
inspection.ambiguous.expression.when.branch.migration.display.name=自 1.7 起 'when' 分支中不明确的逻辑表达式
inspection.array.in.data.class.display.name=数据类中的数组属性
inspection.assigned.value.is.never.read.display.name=指定的值从未被读取
inspection.boolean.literal.argument.display.name=不包含形参名称的布尔字面量实参
inspection.can.be.parameter.display.name=构造函数形参从未被用作属性
inspection.can.be.primary.constructor.property.display.name=属性已明确分配给构造函数形参
inspection.can.be.val.display.name=本地 'var' 从未被修改，且可以声明为 'val'
inspection.can.convert.to.multi.dollar.string.display.name=多美元符号插值可用于字符串字面量
inspection.can.convert.to.multi.dollar.string.problem.description=插值前缀可以简化字符串
inspection.can.sealed.subclass.be.object.display.name=没有状态和重写的 equals 的 sealed 子类
inspection.can.unescape.dollar.literal.inspection.display.name=字符串字面量中的冗余转义美元字符
inspection.can.unescape.dollar.literal.inspection.problem.description=字符串中的转义美元字符可以简化
inspection.cascade.if.display.name=级联 'if' 可被替换为 'when'
inspection.class.name.display.name=类命名约定
inspection.complex.redundant.let.display.name=基于实参的冗余 'let' 调用
inspection.conflicting.extension.property.display.name=扩展属性与合成属性冲突
inspection.const.property.name.display.name=const 属性命名约定
inspection.constant.condition.if.display.name='if' 表达式的条件为常量
inspection.context.parameters.migration.display.text=使用了过时的上下文接收器
inspection.context.parameters.migration.problem.description=上下文接收器应替换为上下文形参
inspection.context.parameters.migration.quick.fix.text=将上下文接收器替换为上下文形参
inspection.control.flow.with.empty.body.display.name=带空体的控制流
inspection.convert.argument.to.set.display.name=实参可以转换为 'Set' 以提高性能
inspection.convert.call.chain.into.sequence.display.name=可以将集合上的调用链转换为 'Sequence' 来改善性能
inspection.convert.lambda.to.reference.display.name=可被替换为函数引用
inspection.convert.na.n.equality.display.name=将带 'NaN' 的相等检查转换为 'isNaN' 调用
inspection.convert.object.to.data.object.display.name=将 'object' 转换为 'data object'
inspection.convert.pair.constructor.to.to.function.display.name=将 Pair 构造函数转换为 'to' 函数
inspection.convert.reference.to.lambda.display.name=可被替换为 lambda
inspection.convert.secondary.constructor.to.primary.display.name=转换为主构造函数
inspection.convert.to.string.template.display.name=可以转换为字符串模板的字符串串联
inspection.convert.try.finally.to.use.call.display.name=将 try / finally 转换为 use() 调用
inspection.convert.two.comparisons.to.range.check.display.name=两个比较应转换为范围检查
inspection.copy.without.named.arguments.display.name=数据类的 'copy' 方法在没有命名实参的情况下调用
inspection.coroutine.context.with.job.description.cancellable=将 ''CoroutineContext'' 与 ''Job'' 一起传递给 ''{0}'' 构建器可能会导致结构化并发冲突
inspection.coroutine.context.with.job.description.non.cancellable=''NonCancellable'' 对象不应与 ''{0}'' 构建器一起使用，因为它违反了结构化并发
inspection.coroutine.context.with.job.display.name='CoroutineContext' 可以包含 'Job' 元素
inspection.data.class.private.constructor.display.name=private 数据类构造函数通过 'copy' 方法公开
inspection.deferred.is.result.display.name=函数直接返回 Deferred
inspection.deferred.result.unused.display.name='@Deferred' 结果未被使用
inspection.delegation.to.var.property.display.name=正在委托给 'var' 属性
inspection.deprecated.callable.add.replace.with.display.name=不包含 'replaceWith' 实参的 @Deprecated 注解
inspection.deprecated.enum.declaring.class.property=已弃用的 'Enum.declaringClass' 属性
inspection.deprecated.gradle.dependency.display.name=在 Gradle 中使用了弃用的库
inspection.deprecated.inline.class.text=已弃用的内联类
inspection.deprecated.inline.classes.migration.display.name=从 1.5 版本开始，内联类已弃用。
inspection.deprecated.maven.dependency.display.name=在 Maven 中使用了弃用的库
inspection.destructure.display.name=使用析构声明
inspection.destructuring.wrong.name.display.name=析构声明中的变量使用错误数据类属性的名称
inspection.different.kotlin.gradle.version.display.name=Kotlin Gradle 和 IDE 插件版本不同
inspection.different.kotlin.maven.version.display.name=Maven 和 IDE 插件版本不同
inspection.different.maven.stdlib.version.display.name=库和 Maven 插件版本不同
inspection.different.stdlib.gradle.version.display.name=Kotlin 库和 Gradle 插件版本不同
inspection.do.not.propagate.method.deprecation.through.overrides=自 1.9 起不得通过重写传播方法描述
inspection.empty.range.display.name=start 大于 endInclusive 的范围为空
inspection.enum.entry.name.display.name=枚举条目命名约定
inspection.enum.values.method.soft.deprecate.in.java.display.name=从 Kotlin 1.9 开始，建议将 'Enum.values()' 替换为 'Enum.getEntries()'
inspection.enum.values.method.soft.deprecate.migration.display.name=从 1.9 开始，建议将 'Enum.values()' 替换为 'Enum.entries'
inspection.equals.or.hash.code.display.name='equals()' 和 'hashCode()' 未配对
inspection.explicit.this.display.name=冗余显式 'this'
inspection.fake.jvm.field.constant.display.name=Kotlin 非 const 属性用作 Java 常量
inspection.filter.is.instance.call.with.class.literal.argument.display.name=带有类字面量实参的 'filterIsInstance' 调用
inspection.filter.is.instance.call.with.class.literal.argument.quick.fix.text=将类字面量实参替换为具体化类型形参
inspection.fold.initializer.and.if.to.elvis.display.name=If-Null return/break/… 可折叠为 '?\:'
inspection.for.each.parameter.not.used.display.name=迭代元素不在 forEach 中使用
inspection.foreach.join.on.collection.of.job.description=在 'Collection<Job>' 上使用 'forEach { it.join() }'，而不是单个 'joinAll()'
inspection.foreach.join.on.collection.of.job.display.name=在 'Collection<Job>' 上调用 'forEach { it.join() }'，而不是单个 'joinAll()'
inspection.foreach.join.on.collection.of.job.replace.with.joinAll=替换为 'joinAll()'
inspection.from.closed.range.migration.display.name=从 1.3 起，fromClosedRange() 中存在 MIN_VALUE 步骤
inspection.function.name.display.name=函数命名约定
inspection.function.with.lambda.expression.body.display.name=具有 '\= { ... }' 和推断返回值类型的函数
inspection.gradle.kotlinx.coroutines.deprecation.display.name=不兼容的 kotlinx.coroutines 依赖项在 Gradle 中与 Kotlin 1.3+ 一起使用
inspection.has.platform.type.display.name=函数或属性具有平台类型
inspection.if.then.to.elvis.display.name=If-Then 可折叠为 '?\:'
inspection.if.then.to.safe.access.display.name=If-Then 可折叠为 '?.'
inspection.implicit.nullable.nothing.type.display.name=隐式 'Nothing?' 类型
inspection.implicit.this.action.name=添加显式 'this'
inspection.implicit.this.display.name=隐式 'this'
inspection.incomplete.destructuring.declaration.display.name=析构声明不完整
inspection.inconsistent.comment.for.java.parameter.display.name=Java 形参的注释不一致
inspection.introduce.when.subject.display.name=可以通过引入实参简化的 'when'
inspection.java.collections.static.method.display.name=Java 集合 static 方法调用可被替换为 Kotlin stdlib
inspection.java.collections.static.method.on.immutable.list.display.name=在不可变的 Kotlin 集合上调用 Java 转变器方法
inspection.java.default.methods.not.overridden.by.delegation.display.name=Java 默认方法未被委托重写
inspection.java.default.methods.not.overridden.by.delegation.message=Java 默认方法未被委托重写
inspection.java.io.serializable.object.must.have.read.resolve.display.name=Serializable 对象必须实现 'readResolve'
inspection.java.io.serializable.object.must.have.read.resolve.quick.fix.name=实现 'readResolve'
inspection.java.io.serializable.object.must.have.read.resolve.warning=Serializable 对象必须实现 'readResolve'
inspection.java.map.for.each.display.name=Java Map.forEach 方法调用应被替换为 Kotlin 的 forEach
inspection.join.declaration.and.assignment.display.name=联接声明和赋值
inspection.join.declaration.and.assignment.option.report.with.complex.initialization.of.member.properties=报告成员属性的复杂初始化
inspection.k.doc.missing.documentation.display.name=public 声明缺少 KDoc 注释
inspection.k.doc.unresolved.reference.display.name=KDoc 中存在未解析的引用
inspection.kotlin.catch.may.ignore.exception.display.name='catch' 块可能会忽略异常
inspection.kotlin.constant.conditions.display.name=恒定条件
inspection.kotlin.covariant.equals.display.name=协变 'equals()'
inspection.kotlin.deprecation.display.name=使用了冗余或弃用的语法或弃用的符号
inspection.kotlin.double.negation.action.name=移除冗余的双重求反
inspection.kotlin.double.negation.display.name=冗余双重求反
inspection.kotlin.equals.between.inconvertible.types.display.name='equals()' 位于不可转换类型的对象之间
inspection.kotlin.internal.in.java.display.name=使用来自 Java 的 Kotlin 内部声明
inspection.kotlin.invalid.bundle.or.property.display.name=无效属性健
inspection.kotlin.jvm.annotation.in.java.description=Kotlin JVM 注解 ''{0}'' 在 Java 中不起任何作用
inspection.kotlin.jvm.annotation.in.java.display.name=Java 中的 Kotlin JVM 注解
inspection.kotlin.maven.plugin.phase.display.name=Kotlin Maven 插件配置错误
inspection.kotlin.options.to.compiler.options.display.name=使用已弃用的 'kotlinOptions' DSL
inspection.kotlin.redundant.override.display.name=冗余重写方法
inspection.kotlin.redundant.suppression.display.name=冗余的诊断禁止
inspection.kotlin.result.of.filterIsInstance.call.always.empty.collection='filterIsInstance' 调用的结果始终为空
inspection.kotlin.sealed.in.java.display.name=从 Java 继承 Kotlin 密封接口/类
inspection.kotlin.test.j.unit.display.name=kotlin-test-junit 可以使用
inspection.kotlin.throwable.not.thrown.display.name=Throwable 未抛出
inspection.kotlin.unused.import.display.name=未使用的 import 指令
inspection.kotlin.unused.variable.display.name=未使用的变量
inspection.lateinit.var.overrides.lateinit.var.display.name='lateinit var' 属性重写 'lateinit var' 属性
inspection.leaking.this.display.name=在构造函数中泄漏 'this'
inspection.lift.return.or.assignment.display.name=可以提取 return 或赋值
inspection.lift.return.or.assignment.option.only.single.statement=仅在每个分支都是单条语句时报告
inspection.local.variable.name.display.name=局部变量命名约定
inspection.logger.initialized.with.foreign.class.display.name=使用外类初始化记录器
inspection.logger.placeholder.count.matches.argument.count.display.name=占位符数量与日志调用中的实参数量不匹配
inspection.loop.to.call.chain.display.name=循环可被替换为 stdlib 运算
inspection.main.function.return.unit.display.name=main 函数应返回 'Unit'
inspection.map.await.on.collection.of.deferred.description=在 'Collection<Deferred>' 上使用 'map { it.await() }'，而不是单个 'awaitAll()'
inspection.map.await.on.collection.of.deferred.display.name=在 'Collection<Deferred>' 上调用 'map { it.await() }'，而不是单个 'awaitAll()'
inspection.map.await.on.collection.of.deferred.replace.with.awaitAll=替换为 'awaitAll()'
inspection.map.can.be.replaced.with.for.each.display.name='map' 调用可被替换为 'forEach'
inspection.map.can.be.replaced.with.for.each.warning=''{0}'' 调用可被替换为 ''forEach''
inspection.map.get.with.not.null.assertion.operator.display.name=包含非 null 断言运算符 (\!\!) 的 'map.get()'
inspection.maven.coroutines.deprecation.display.name=不兼容的 kotlinx.coroutines 依赖项在 Maven 中与 Kotlin 1.3+ 一起使用
inspection.may.be.constant.display.name=可能为 'const'
inspection.member.visibility.can.be.private.display.name=类成员可以具有 'private' 可见性
inspection.message.cast.will.always.fail=转换总是失败
inspection.message.condition.always.false=条件 ''{0}'' 始终为 false
inspection.message.condition.always.false.when.reached=条件 ''{0}'' 满足后始终为 false
inspection.message.condition.always.true=条件 ''{0}'' 始终为 true
inspection.message.condition.always.true.when.reached=条件 ''{0}'' 满足后始终为 true
inspection.message.empty.catch.block=空 catch 块
inspection.message.for.never.visited='for' 范围始终为空
inspection.message.inconsistent.parameter.name.for.0=''{0}'' 的形参名称不一致
inspection.message.index.out.of.bounds=索引总是超出界限
inspection.message.nonnull.cast.will.always.fail=操作将始终失败，因为操作数始终为 null
inspection.message.object.with.manual.tostring.can.be.converted.to.data.object=带有手动 'toString' 的 'object' 可以转换为 'data object'
inspection.message.result.of.0.always.empty.collection=''{0}'' 的结果始终为空集合
inspection.message.sealed.object.can.be.converted.to.data.object='sealed' 子对象可以转换为 'data object'
inspection.message.value.always.false=''{0}'' 的值始终为 false
inspection.message.value.always.null=''{0}'' 的值始终为 null
inspection.message.value.always.true=''{0}'' 的值始终为 true
inspection.message.value.always.zero=''{0}'' 的值始终为零
inspection.message.when.condition.always.false='when' 分支永远无法到达
inspection.migrate.diagnostic.suppression.display.name=应替换诊断名称
inspection.move.lambda.outside.parentheses.display.name=圆括号内的 lambda 实参
inspection.move.suspicious.callable.reference.into.parentheses.display.name=可疑的可调用引用用作 lambda 结果
inspection.move.variable.declaration.into.when.display.name=变量声明可以在 'when' 中移动
inspection.nested.lambda.shadowed.implicit.parameter.display.name=嵌套 lambda 具有隐藏的隐式形参
inspection.no.actual.for.expect.display.name=expect 声明中没有 actual
inspection.non.exhaustive.when.statement.migration.display.name=将从 1.7 开始禁止非穷举的 'when' 语句
inspection.null.checks.to.safe.call.display.name=null 检查可被替换为安全调用
inspection.nullable.boolean.elvis.action.name=使用相等检查而不是 elvis 进行可以为 null 布尔检查
inspection.nullable.boolean.elvis.display.name=可以使用相等检查代替 elvis 进行可以为 null 布尔检查
inspection.nullable.type.argument.in.java.collection.display.name=Java 集合中不支持 null 的可为 null 的类型实参
inspection.object.exception.to.class.display.name=异常不应为对象
inspection.object.exception.to.class.quick.fix.name=将异常对象更改为类
inspection.object.exception.to.class.warning=异常不应为对象
inspection.object.literal.to.lambda.display.name=对象字面量可以转换为 lambda
inspection.object.private.property.name.display.name=对象 private 属性命名约定
inspection.object.property.name.display.name=object 属性命名约定
inspection.obsolete.experimental.coroutines.display.name=从 1.3 起，实验性协程用法遭到废弃
inspection.obsolete.kotlin.js.packages.display.name='kotlin.browser' 和 'kotlin.dom' 软件包自 1.4 起已弃用
inspection.optional.expectation.display.name=可选预期注解没有实际注解
inspection.package.directory.mismatch.display.name=软件包名称与包含的目录不匹配
inspection.package.name.display.name=软件包命名约定
inspection.platform.extension.receiver.of.inline.display.name=在 Kotlin 1.2 及更低版本中包含可为 null 的接收器的 'inline fun'
inspection.prefer.current.coroutine.context.to.coroutine.context.inspection.description='kotlin.coroutine.coroutineContext' 的用法可能存在歧义
inspection.prefer.current.coroutine.context.to.coroutine.context.inspection.display.name=可能存在歧义的 'kotlin.coroutine.coroutineContext' 用法
inspection.prefer.current.coroutine.context.to.coroutine.context.inspection.fix=替换为 'currentCoroutineContext()'
inspection.private.property.name.display.name=private 属性命名约定
inspection.progression.resolution.change.migration.display.name=自 1.9 起的进度分辨率更改
inspection.prohibit.jvm.overloads.on.constructors.of.annotation.classes.migration.display.name=从 1.4 起，'@JvmOverloads' 注解无法用于注解类的构造函数
inspection.prohibit.repeated.use.site.target.annotations.migration.display.name=未被标记为 '@Repeatable' 的重复注解
inspection.prohibit.type.parameters.for.local.variables.migration.display.name=带类型形参的局部变量
inspection.prohibit.use.site.target.annotations.on.super.types.migration.display.name=超类上的无意义注解目标
inspection.property.name.display.name=属性命名约定
inspection.protected.in.final.display.name='protected' 可见性在 final 类中实际是 'private'
inspection.public.api.implicit.type.display.name=具有隐式返回值类型的公共 API 声明
inspection.recursive.equals.call.display.name=递归 equals 调用
inspection.recursive.property.accessor.display.name=递归属性访问器
inspection.redundant.anonymous.function.description=创建冗余匿名函数
inspection.redundant.assequence.call=冗余 'asSequence' 调用
inspection.redundant.async.display.name=冗余 'async' 调用
inspection.redundant.call.on.collection.display.name=对集合类型的冗余调用
inspection.redundant.call.on.not.null.display.name=对非 null 类型的冗余调用
inspection.redundant.companion.reference.display.name=冗余 'Companion' 引用
inspection.redundant.else.in.if.display.name='if' 中冗余的 'else'
inspection.redundant.elvis.return.null.descriptor=冗余 '?\: return null'
inspection.redundant.elvis.return.null.display.name=冗余 '?\: return null'
inspection.redundant.empty.initializer.block.display.name=冗余空白初始值设定项块
inspection.redundant.enum.constructor.invocation.display.name=冗余枚举构造函数调用
inspection.redundant.explicit.type.display.name=明显的显式类型
inspection.redundant.getter.display.name=冗余属性 getter
inspection.redundant.if.display.name=冗余的 'if' 语句
inspection.redundant.inner.class.modifier.descriptor=冗余 'inner' 修饰符
inspection.redundant.inner.class.modifier.display.name=冗余 'inner' 修饰符
inspection.redundant.interpolation.prefix.display.name=冗余的插值前缀
inspection.redundant.interpolation.prefix.problem.description=冗余的插值前缀
inspection.redundant.interpolation.prefix.quick.fix.text=移除冗余的插值前缀
inspection.redundant.label.display.name=冗余标签
inspection.redundant.label.migration.display.name=冗余标签
inspection.redundant.label.problem.description=标签是冗余的，因为它不能在 'break、'continue' 或 'return' 表达式中引用
inspection.redundant.label.text=冗余标签
inspection.redundant.labeled.return.on.last.expression.in.lambda.display.name=lambda 中最后一个表达式上带标签的冗余 return
inspection.redundant.lambda.arrow.display.name=冗余 lambda 箭头
inspection.redundant.lambda.description=创建冗余 lambda
inspection.redundant.lambda.or.anonymous.function.display.name=创建冗余 lambda 或匿名函数
inspection.redundant.lambda.or.anonymous.function.fix=内联主体
inspection.redundant.modality.modifier.display.name=冗余形式修饰符
inspection.redundant.not.null.extension.receiver.of.inline.display.name='inline fun' 扩展接收器在 Kotlin 1.2 及更低版本中可以显式设为可为 null
inspection.redundant.nullable.return.type.display.name=冗余可 null 返回值类型
inspection.redundant.object.type.check.display.name=对象的非惯用 'is' 类型检查
inspection.redundant.require.not.null.call.display.name=冗余 'requireNotNull' 或 'checkNotNull' 调用
inspection.redundant.return.keyword.action.name=移除 'return' 关键字
inspection.redundant.return.keyword.display.name=冗余的 'return' 关键字
inspection.redundant.return.label.display.name=冗余 'return' 标签
inspection.redundant.run.catching.display.name=冗余 'runCatching' 调用
inspection.redundant.sam.constructor.display.name=冗余 SAM 构造函数
inspection.redundant.semicolon.display.name=冗余分号
inspection.redundant.setter.display.name=冗余属性 setter
inspection.redundant.suspend.modifier.display.name=冗余 'suspend' 修饰符
inspection.redundant.unit.expression.display.name=冗余 'Unit'
inspection.redundant.unit.return.type.action.name=移除冗余的 'Unit' 返回类型
inspection.redundant.unit.return.type.display.name=冗余 'Unit' 返回值类型
inspection.redundant.upper.bound.fix.text=移除冗余的上限 'Any?'
inspection.redundant.upper.bound.problem=冗余的上限 'Any?'
inspection.redundant.value.argument.annotation=值实参与形参 ''{0}'' 的默认值匹配
inspection.redundant.value.argument.display.name=冗余值实参
inspection.redundant.visibility.modifier.display.name=冗余可见性修饰符
inspection.redundant.with.display.name=冗余 'with' 调用
inspection.remove.curly.braces.from.template.display.name=字符串模板中的冗余大括号
inspection.remove.empty.class.body.display.name=替换空类主体
inspection.remove.empty.parentheses.from.annotation.entry.display.name=注解中存在多余的括号
inspection.remove.empty.parentheses.from.lambda.call.action.name=从带 lambda 的函数调用中移除不必要的圆括号
inspection.remove.empty.parentheses.from.lambda.call.display.name=带 lambda 的函数调用中不必要的圆括号
inspection.remove.empty.primary.constructor.display.name=冗余空主构造函数
inspection.remove.empty.secondary.constructor.body.display.name=冗余构造函数体
inspection.remove.explicit.super.qualifier.display.name=不必要的父类型限定
inspection.remove.explicit.type.arguments.display.name=不必要的类型实参
inspection.remove.for.loop.indices.display.name=未使用的循环索引
inspection.remove.interpolation.prefix.display.name=可移除的多美元符号插值前缀
inspection.remove.interpolation.prefix.problem.description=字符串前缀可以移除
inspection.remove.interpolation.prefix.quick.fix.text=移除多美元符号前缀
inspection.remove.redundant.backticks.display.name=冗余反引号
inspection.remove.redundant.calls.of.conversion.methods.display.name=转换方法的冗余调用
inspection.remove.redundant.qualifier.name.display.name=冗余限定符名称
inspection.remove.redundant.spread.operator.display.name=冗余展开运算符
inspection.remove.setter.parameter.type.display.name=冗余 setter 形参类型
inspection.remove.single.expression.string.template.display.name=冗余字符串模板
inspection.remove.to.string.in.string.template.display.name=字符串模板中的冗余 'toString()' 调用
inspection.remove.unnecessary.parentheses.display.name=冗余的圆括号
inspection.remove.unnecessary.parentheses.problem.description=冗余的圆括号
inspection.remove.unnecessary.parentheses.quickfix.text=移除冗余圆括号
inspection.replace.addAll.with.mapTo.display.name='addAll(map/filter {})' 可以替换为 'mapTo/filterTo'
inspection.replace.array.equality.op.with.arrays.equals.display.name=通过 '\=\=' 和 '\!\=' 进行数组比较
inspection.replace.array.of.with.literal.display.name='arrayOf' 调用可被替换为数组字面量 […]
inspection.replace.assert.boolean.with.assert.equality.display.name=断言布尔可被替换为断言等式
inspection.replace.associate.function.display.name='associate' 可被替换为 'associateBy' 或 'associateWith'
inspection.replace.call.with.binary.operator.display.name=可被替换为二元运算符
inspection.replace.collection.count.with.size.display.name=集合计数可以转换为大小
inspection.replace.get.or.set.display.name=显式 'get' 或 'set' 调用
inspection.replace.guard.clause.with.function.call.display.name=guard 子句可被替换为 Kotlin 的函数调用
inspection.replace.isempty.with.ifempty.display.name='if' 条件可被替换为 lambda 调用
inspection.replace.java.static.method.with.kotlin.analog.display.name=Java 方法应替换为 Kotlin 模拟
inspection.replace.manual.range.with.indices.calls.display.name=范围可以转换为索引或迭代
inspection.replace.mapIndexed.with.list.generator.display.name=将 'mapIndexed' 替换为 List 生成器
inspection.replace.negated.is.empty.with.is.not.empty.display.name=可以简化否定调用
inspection.replace.not.null.assertion.with.elvis.return.display.name=非 null 断言可被替换为 'return'
inspection.replace.put.with.assignment.display.name='map.put()' 可以转换为赋值
inspection.replace.range.start.end.inclusive.with.first.last.display.name=装箱的属性应替换为未装箱的属性
inspection.replace.range.to.with.rangeUntil.display.name='rangeTo' 或 '..' 调用应被替换为 '..<'
inspection.replace.range.to.with.until.display.name='rangeTo' 或 '..' 调用应被替换为 'until'
inspection.replace.readline.with.readln.display.name='readLine' 可被替换为 'readln' 或 'readlnOrNull'
inspection.replace.size.check.with.is.not.empty.display.name=大小检查可被替换为 'isNotEmpty()'
inspection.replace.size.zero.check.with.is.empty.display.name=零大小检查可被替换为 'isEmpty()'
inspection.replace.string.format.with.literal.display.name='String.format' 调用可被替换为字符串模板
inspection.replace.substring.with.drop.last.display.name='substring' 调用应被替换为 'dropLast' 调用
inspection.replace.substring.with.indexing.operation.display.name='substring' 调用应被替换为索引运算符
inspection.replace.substring.with.substring.after.display.name='substring' 调用应被替换为 'substringAfter'
inspection.replace.substring.with.substring.before.display.name='substring' 调用应被替换为 'substringBefore'
inspection.replace.substring.with.take.display.name='substring' 调用应被替换为 'take' 调用
inspection.replace.to.string.with.string.template.display.name='toString' 的调用可被替换为字符串模板
inspection.replace.to.with.infix.form.display.name='to' 调用应被替换为中缀形式
inspection.replace.until.with.rangeUntil.operator.display.name=将 'until' 替换为 '..<' 运算符
inspection.replace.with.enum.map.display.name='HashMap' 可被替换为 'EnumMap'
inspection.replace.with.ignore.case.equals.display.name=应替换为 'equals(..., ignoreCase \= true)'
inspection.replace.with.import.alias.display.name=完全限定名称可被替换为现有的导入别名
inspection.replace.with.operator.assignment.display.name=赋值可被替换为运算符赋值
inspection.replace.with.string.builder.append.range.display.name=JVM 上的 'StringBuilder.append(CharArray, offset, len)' 调用
inspection.restrict.return.statement.target.migration.display.name=从 1.4 起，目标标签不表示函数
inspection.run.blocking.in.suspend.function.description=在 suspend 函数内使用 'runBlocking' 会阻塞调用线程，从而违背异步编程的目的
inspection.run.blocking.in.suspend.function.display.name=suspend 函数内存在 'runBlocking'
inspection.runblocking.analysis.found.runblocking=--> runBlocking
inspection.runblocking.analysis.graphbuilding.progress=正在处理 {0}
inspection.runblocking.presentation.descriptor=正在分析 runBlocking\:
inspection.runblocking.presentation.display.name=协程中的 RunBlocking
inspection.runblocking.presentation.settings.exploration.option.all=是，包括重写
inspection.runblocking.presentation.settings.exploration.option.declaration=是，排除重写
inspection.runblocking.presentation.settings.exploration.option.strict=否
inspection.runblocking.presentation.settings.exploration.title=浏览具有重写的函数
inspection.runblocking.presentation.text=从协程调用的 RunBlocking 构建器
inspection.safe.cast.with.return.display.name=带有 'return' 的安全转换应替换为 'if' 类型检查
inspection.scope.function.conversion.display.name=作用域函数可以转换为另一个
inspection.self.assignment.display.name=冗余赋值
inspection.self.reference.constructor.parameter.display.name=构造函数永远无法补全
inspection.setter.backing.field.assignment.display.name=不包含赋值的现有支持字段
inspection.simple.redundant.let.display.name=基于接收器的冗余 'let' 调用
inspection.simplifiable.call.chain.display.name=可以简化集合类型上的调用链
inspection.simplifiable.call.display.name=可以简化库函数调用
inspection.simplifiable.scope.function.display.name=嵌套 forEach 的作用域函数可以简化
inspection.simplify.assert.not.null.display.name='assert' 调用可被替换为 '\!\!' 或 '?\:'
inspection.simplify.boolean.with.constants.display.name=可以简化布尔表达式
inspection.simplify.negated.binary.expression.display.name=可以简化求反布尔表达式
inspection.simplify.when.with.boolean.constant.condition.display.name=可简化的 'when'
inspection.sort.modifiers.display.name=非规范修饰符顺序
inspection.suspend.coroutine.lacks.cancellation.guarantees.description='suspendCoroutine' 缺乏取消保证；建议使用 'kotlinx.coroutines.suspendCancellableCoroutine' 以获得正确的取消支持
inspection.suspend.coroutine.lacks.cancellation.guarantees.display.name='suspendCoroutine' 缺乏取消保证
inspection.suspend.coroutine.lacks.cancellation.guarantees.fix=替换为更易于取消的 'suspendCancellableCoroutine'
inspection.suspend.function.on.coroutine.scope.display.name=由于挂起函数的 CoroutineScope 接收器，coroutineContext 不明确
inspection.suspicious.as.dynamic.display.name=可疑的 'asDynamic' 成员调用
inspection.suspicious.call.on.collection.to.add.or.remove.path.display.name=在 Collection 上添加或移除 Java NIO Path 的可疑调用
inspection.suspicious.cascading.if.display.name=可疑的级联 'if' 表达式
inspection.suspicious.collection.reassignment.display.name=增强赋值在后台创建新集合
inspection.suspicious.equals.combination.display.name=可疑的 \=\= 与 \=\=\= 组合
inspection.suspicious.implicit.coroutine.scope.receiver.add.explicit.receiver.fix.text=添加显式带标签的接收器(不改变语义)
inspection.suspicious.implicit.coroutine.scope.receiver.description=suspend 上下文中存在可疑的隐式 'CoroutineScope' 接收器访问
inspection.suspicious.implicit.coroutine.scope.receiver.detect.subclasses.option=检测 'CoroutineScope' 子类型的接收器
inspection.suspicious.implicit.coroutine.scope.receiver.display.name=可疑的隐式 'CoroutineScope' 接收器访问
inspection.suspicious.var.property.display.name=可疑的 'var' 属性\: 它的 setter 不会影响其 getter 结果
inspection.test.function.name.display.name=测试函数命名约定
inspection.this.class.does.not.have.a.constructor=禁止的构造函数调用
inspection.trailing.comma.add.line.break=添加换行
inspection.trailing.comma.add.trailing.comma=添加尾随逗号
inspection.trailing.comma.comma.loses.the.advantages.in.this.position=逗号在这个位置没有优势
inspection.trailing.comma.display.name=尾随逗号推荐
inspection.trailing.comma.fix.comma.position=修复逗号位置
inspection.trailing.comma.missing.line.break=缺少换行
inspection.trailing.comma.missing.trailing.comma=缺少尾随逗号
inspection.trailing.comma.redundant.trailing.comma=冗余的尾随逗号
inspection.trailing.comma.remove.trailing.comma=移除尾随逗号
inspection.trailing.comma.report.also.a.missing.comma=还报告缺少的逗号或换行
inspection.unlabeled.return.inside.lambda.display.name=lambda 中存在未标记的 return
inspection.unnecessary.opt_in.annotation.display.name=不必要的 '@OptIn' 注解
inspection.unnecessary.opt_in.redundant.annotation=选择加入注解冗余\: 没有使用匹配的实验 API
inspection.unnecessary.opt_in.redundant.marker=选择加入标记冗余\: 未使用标记为 ''{0}'' 的实验 API
inspection.unnecessary.opt_in.remove.annotation.fix.family.name=移除注解
inspection.unnecessary.opt_in.remove.marker.fix.family.name=移除选择加入标记
inspection.unnecessary.variable.display.name=不必要的局部变量
inspection.unnecessary.variable.option.report.immediately.returned.variables=报告立即返回的变量
inspection.unreachable.code=不可到达的代码
inspection.unreachable.code.remove.unreachable.code=移除不可到达的代码
inspection.unsafe.cast.from.dynamic.display.name=从动态类型的隐式(不安全)转换
inspection.unsafe.cast.with.return.display.name=带 'return' 的不安全转换应替换为安全的转换
inspection.unused.equals.display.name=未使用的 equals 表达式
inspection.unused.expression.display.name=未使用的表达式
inspection.unused.expression.problem.description=表达式未使用
inspection.unused.flow.display.name=未使用的 flow
inspection.unused.lambda.expression.body.display.name=包含 lambda 表达式主体的函数未使用的返回值
inspection.unused.lambda.expression.inspection.display.name=未使用的 lambda 表达式
inspection.unused.lambda.expression.inspection.problem.description=Lambda 表达式从未被调用。要创建作用域块，请使用 'run { ... }'
inspection.unused.main.parameter.display.name=主形参不必要
inspection.unused.receiver.parameter=接收器形参从未使用
inspection.unused.receiver.parameter.display.name=未使用的接收器形参
inspection.unused.result.of.data.class.copy=数据类复制的未使用结果
inspection.unused.symbol.display.name=未使用的符号
inspection.unused.unary.operator.display.name=未使用的一元运算符
inspection.use.expression.body.display.name=此处更适合表达式主体语法
inspection.use.property.access.syntax.display.name=可被替换为属性访问语法的访问器调用
inspection.use.with.index.display.name=手动递增的索引变量可被替换为使用 'withIndex()'
inspection.use.with.index.k2.display.name=手动递增索引变量
inspection.use.with.index.k2.problem.description=手动递增的索引变量可被替换为使用 'withIndex()'
inspection.variable.initializer.is.redundant.display.name=变量初始值设定项冗余
inspection.variable.is.never.read.display.name=变量从未被读取
inspection.verbose.nullability.and.emptiness.call=将后续检查替换为 ''{0}()'' 调用
inspection.verbose.nullability.and.emptiness.display.name=详细的为 null 性和空性检查
inspection.warning.on.main.unused.parameter.migration.display.name=从 1.4 起，'main' 上不再使用 'args'
inspection.when.with.only.else.action.name=仅使用 'else' 分支简化 'when'
inspection.when.with.only.else.display.name='when' 仅包含 'else' 分支且可以简化
inspection.wrap.unary.operator.display.name=模糊一元运算符与数字常量一同使用
intention.add.import.alias.group.name=添加导入别名
intention.change.package.text=更改软件包
intention.collection.concatenation.to.build.collection.call.family.name=转换为集合构建器
intention.convert.lambda.line=转换为{0,choice,0\#单|1\#多}行 lambda
intention.create.test.dialog.kotlin=Kotlin
intention.error.cannot.create.class.message=无法创建类''{0}''
intention.error.cannot.create.class.title=创建类失败
intention.extract.declarations.from.file.text=从当前文件中提取声明
intention.extract.declarations.from.file.text.details=从当前文件中提取 ''{0}'' {1, choice, 0\#|1\#和子类}
intention.flow.on.dispatchers.io='Dispatchers.IO' 的 Flow
intention.implement.abstract.method.command.name=实现方法
intention.implement.abstract.method.searching.for.descendants.progress=正在搜索后代…
intention.name.specify.supertype=指定父类型
intention.name.specify.supertype.title=指定父类型
intention.name.use.correct.parameter.name=请使用正确的形参名称
intention.switch.context.to.dispatchers.io=切换到 'Dispatchers.IO' 上下文
intention.trailing.comma.custom.text=在格式化程序中默认{0,choice,0\#启用|1\#禁用}尾随逗号
intention.trailing.comma.text=在格式化程序中默认启用/禁用尾随逗号
intention.wrap.in.with.context=在 'withContext' 中包装调用
interface=接口
interface.member.dependency.required.by.interfaces={0,choice,1\#接口|2\#接口}所需
interface.should.be.external=接口应为 external
internal.toggle.throwing.cached.pce.title=内部\: 切换抛出缓存的 PCE
introduce.0.as.subject.0.when=将 ''{0}'' 作为 ''when'' 的主体引入
introduce.anonymous.parameter.fix.family.name=引入匿名形参
introduce.backing.property=引入支持属性
introduce.constant=引入常量
introduce.import.alias=引入导入别名
introduce.property=引入属性
introduce.type.parameter=引入类型形参
introduce.type.parameter.to.declaration=将类型形参引入声明
introduce.variable=引入变量
introduce.when.subject=引入 'when' 主体
invert.if.condition=反转 'if' 条件
it.s.prohibited.to.call.0.with.min.value.step.since.1.3=从 1.3 起，禁止使用 MIN_VALUE 步骤调用 {0}
iterate.over.0=迭代 ''{0}''
iterate.over.collection=迭代集合
java.collection.is.parameterized.with.nullable.type=Java 集合 ''{0}'' 使用{1,choice,1\#一个可为 null 类型|2\#可为 null 类型}进行形参化
java.collections.static.method.call.should.be.replaced.with.kotlin.stdlib=Java 集合 static 方法调用应被替换为 Kotlin stdlib
java.collections.to.process=要处理的 Java 集合\:
java.map.foreach.method.call.should.be.replaced.with.kotlin.s.foreach=Java Map.forEach 方法调用应被替换为 Kotlin 的 forEach
join.declaration.and.assignment=联接声明和赋值
join.with.initializer.fix.text=与初始值设定项联接
junit.static.methods=JUnit static 方法
kdoc.comment.unresolved=未解决
kdoc.section.title.author=作者
kdoc.section.title.constructor=构造函数
kdoc.section.title.parameters=形参
kdoc.section.title.properties=属性
kdoc.section.title.receiver=接收器
kdoc.section.title.returns=返回
kdoc.section.title.samples=示例
kdoc.section.title.see.also=另请参阅
kdoc.section.title.since=自
kdoc.section.title.suppress=禁止
kdoc.section.title.throws=抛出
kotlin.call.chains.hints=Kotlin\: 显示调用链的嵌入提示
kotlin.compiler.configurable=Kotlin 编译器
kotlin.dist.downloading.failed.group.name=Kotlin dist 下载失败
kotlin.external.compiler.updates.notification.group.name=可用的 Kotlin 外部编译器更新
kotlin.jps.plugin.group.name=Kotlin JPS 插件
kotlin.lambdas.hints=Kotlin\: 显示 Lambda 的嵌入提示
kotlin.lambdas.hints.hints.lambda.receivers.parameters=Kotlin\: 显示隐式接收器和形参的嵌入提示
kotlin.lambdas.hints.hints.lambda.return=Kotlin\: 显示返回表达式的嵌入提示
kotlin.references.types.hints=Kotlin\: 显示类型的嵌入提示
kotlin.references.types.hints.hints.type.function.parameter=Kotlin\: 显示函数形参类型的嵌入提示
kotlin.references.types.hints.hints.type.function.return=Kotlin\: 显示函数返回值类型的嵌入提示
kotlin.references.types.hints.hints.type.property=Kotlin\: 显示属性类型的嵌入提示
kotlin.references.types.hints.hints.type.variable=Kotlin\: 显示局部变量类型的嵌入提示
kotlin.script.definitions.model.name.autoReloadScriptDependencies=自动重新加载
kotlin.script.definitions.model.name.autoReloadScriptDependencies.description=如果要在文件更改时自动加载脚本配置，启用自动重新加载
kotlin.script.definitions.model.name.is.enabled=启用
kotlin.script.definitions.model.name.name=名称
kotlin.script.definitions.model.name.pattern.extension=模式/扩展
kotlin.script.definitions.title=管理脚本定义\:
kotlin.script.in.beta.stage=Kotlin 脚本现在处于测试阶段
kotlin.script.in.beta.stage.link=https\://kotlinlang.org/docs/components-stability.html\#stability-levels-explained
kotlin.script.in.project.sources=<html>此脚本不应位于源根内。在 Kotlin 1.9 之后，它将在模块编译期间被忽略。</html>
kotlin.script.in.project.sources.1.9=<html>此脚本不应位于源根内。自 Kotlin 1.9 起，它将在模块编译期间被忽略。</html>
kotlin.script.in.project.sources.allow=允许…
kotlin.script.in.project.sources.hide=隐藏
kotlin.script.in.project.sources.later=以后再说
kotlin.script.in.project.sources.link=https\://youtrack.jetbrains.com/issue/KT-52735
kotlin.script.in.project.sources.move=移至…
kotlin.script.lookup.definitions=正在查找 Kotlin 脚本定义…
kotlin.script.sources.index=索引
kotlin.script.sources.not.yet.indexed=未为源文件编制索引以减少项目启动时间
kotlin.script.warning.more.info=更多信息
kotlin.scripting.configurable=Kotlin 脚本
kotlin.unreachable.code.display.name=不可到达的代码
kotlin.values.hints=显示值的嵌入提示
kotlin.values.hints.kotlin.values.ranges=Kotlin\: 显示范围的嵌入提示
label.text.default.receiver.value=默认接收器值(&D)\:
label.text.destination=目标(&D)\:
label.text.destination.directory=目标目录(&D)\:
label.text.file=文件(&F)\:
label.text.file.name=文件名(&N)\:
label.text.introduce.as=引入为(&I)\:
label.text.move.expect.actual.counterparts=移动预期/实际对应项(&M)
label.text.name=名称(&N)\:
label.text.package=软件包(&A)\:
label.text.package.name=软件包名称(&G)\:
label.text.receiver.type=接收器类型(&T)\:
label.text.source.sets=源集\:
label.text.target.file.name=目标文件名\:
label.text.to.class=到类\:
label.text.to.file=到文件(&P)\:
label.text.to.object=到对象\:
label.text.to.package=到软件包(&A)\:
label.text.type=类型(&T)\:
label.text.visibility=可见性(&V)\:
lambda.argument.0.be.moved.out=Lambda 实参{0,choice,0\#可以|1\#应该}从圆括号中移出
leaking.this.in.constructor.of.enum.class.0.with.overridable.members=在枚举类 {0} (具有可重写成员) 的构造函数中泄漏 ''this''
leaking.this.in.constructor.of.non.final.class.0=在非 final 类 {0} 的构造函数中泄漏 ''this''
let.0.1=使{0} {1}
let.type.implement.interface=使类型实现接口
lift.assignment.out.fix.text.0=从 ''{0}'' 中提取赋值
lift.assignment.out.of.try.expression=从 'try' 表达式中提取赋值
lift.function.call.out.of.if=从 'if' 中解除函数调用
lift.function.call.out.of.when=从 'when' 中解除函数调用
lift.return.out.fix.text.0=从 ''{0}'' 中提取返回
lift.return.out.of.if.expression=从 'if' 表达式中提取 return
listbox.import.package=软件包
listbox.import.with.subpackages=以及子软件包
livetemplate.description.anonymous=匿名类
livetemplate.description.closure=闭包(没有名称的函数)
livetemplate.description.exfun=扩展函数
livetemplate.description.exval=扩展只读属性
livetemplate.description.exvar=扩展读写属性
livetemplate.description.fun0=无形参函数
livetemplate.description.fun1=单形参函数
livetemplate.description.fun2=双形参函数
livetemplate.description.ifn=插入 'if null' 表达式
livetemplate.description.inn=插入 'if not null' 表达式
livetemplate.description.interface=接口
livetemplate.description.iter=迭代 iterable 的元素(for-in loop)
livetemplate.description.main=main() 函数
livetemplate.description.maina=main(args) 函数
livetemplate.description.serr=将一个字符串打印到 System.err
livetemplate.description.singleton=单例
livetemplate.description.sout=将一个字符串打印到 System.out
livetemplate.description.soutp=将函数形参名称和值打印到 System.out
livetemplate.description.soutv=将一个值打印到 System.out
livetemplate.description.void=函数不返回任何内容
local.variable=局部变量
logger.initialized.with.foreign.class=使用外类 ''{0}'' 初始化记录器
looking.for.usages.and.conflicts=正在查找用法和冲突…
looking.for.usages.in.java.files=正在 Java 文件中查找用法…
loop.can.be.replaced.with.stdlib.operations=循环可被替换为 stdlib 运算
loop.parameter.0.is.unused=未使用循环形参 ''{0}''
loop.to.call.fix.family.name=替换为 stdlib 运算
loop.to.call.fix.family.name2=替换为使用 'asSequence()' 的 stdlib 运算
make.0=设为{0}
make.0.1=将 ''{0}'' 设为{1}
make.0.1.explicitly=将 ''{0}'' 明确设为{1}
make.0.an.annotation.class=将 ''{0}'' 设为注解类
make.0.explicitly=明确生成{0}
make.0.in.1.open=使 {1} 中的 ''{0}'' 打开
make.0.not.1=将{0}设为非 {1}
make.class.an.annotation.class=使类为注解类
make.constructor.parameter.a.property.0=使构造函数形参为属性{0}
make.member.static.quickfix=将 ''{0}'' 设为 static
make.not.nullable=设为不可为 null
make.open=设为 'open'
make.open.fix.text=使类开放
make.override.accessor.function.0=将重写访问器函数设为 ''{0}''
make.primary.constructor.0=设为主构造函数 {0}
make.private.and.0.1=设为 private 并{0} ''{1}''
make.private.fix.text=设为 private
make.script.executable=将脚本设为可执行
make.type.parameter.reified.and.function.inline=使类型形参具体化且使函数内联
making.member.static=正在将成员设为 static…
map.get.or.default.can.be.replaced.with.indexing.and.elvis.operator='map.getOrDefault()' 可以替换为索引运算符和 elvis 运算符
map.get.with.not.null.assertion.operator=包含非 null 断言运算符 '(\!\!)' 的 'map.get()'
map.put.should.be.converted.to.assignment=map.put() 应转换为赋值
mark.as.deprecated.level.deprecationlevel.hidden=标记为 '@Deprecated(..., level \= DeprecationLevel.HIDDEN)'
max.functions.to.visit=要访问的最大函数
maximum.count.of.applied.refactoring.before.validity.check=验证检查前应用重构的最大计数
may.contain.only.letters.and.digits=仅可以包含字母和数字
may.contain.only.letters.digits.or.underscores=仅可以包含字母、数字或下划线
member.info.abstract.0=abstract {0}
member.info.companion.0=伴生{0}
merge.else.if=合并 'else if'
merge.if.s=合并 'if'
message.change.signature.is.not.applicable.to.dynamically.invoked.functions=“更改签名”不适用于动态调用的函数
message.do.not.show.for.local.variables.in.future=以后不为局部变量显示
message.text.property.receiver.type.cannot.be.resolved=无法解析属性接收器类型 ''{0}''。\n是否继续?
message.text.property.type.cannot.be.resolved=无法解析属性类型 ''{0}''。\n是否继续?
message.text.return.type.cannot.be.resolved=无法解析返回值类型 ''{0}''。\n是否继续?
message.type.for.cannot.be.resolved=无法解析 {1} 的类型 ''{0}''。\n继续?
methods.are.absent.in.coroutines.class.since.1.3=从 1.3 起，协程类中不存在方法
microservices.url.path.inlay.hints=Kotlin\: 显示 URL 路径的嵌入提示
might.be.const=可能为 'const'
migrate.type.parameter.list.syntax=迁移类型形参列表语法
migrate.unsupported.yield.syntax=迁移不受支持的 yield 语法
minimal.line.count=最小行计数
minus.call.removes.path.elements='minus' 调用会移除 Path 元素
missing.documentation=缺少文档
modifiers.should.follow.annotations=修饰符应遵循注解
move.annotation.to.receiver.type=将注解移至接收器类型
move.else.branch.to.the.end=将 else 分支移至末尾
move.lambda.argument.into.parentheses=将 lambda 实参移入圆括号
move.lambda.argument.out.of.parentheses=将 lambda 实参移出圆括号
move.members.from=从以下位置移动成员\:
move.out.of.companion.object=移出伴生对象
move.refactoring.error.text.cannot.perform.refactoring.since.the.following.files.already.exist=无法执行重构，因为以下文件已存在\:
move.refactoring.test=移动重构测试
move.refactoring.testing=移动重构测试
move.reference.into.parentheses=将引用移到圆括号中
move.to.class.body=移至类主体
move.to.companion.object=移至伴生对象
move.to.companion.object.command=移至伴生对象
move.to.constructor=移至构造函数
move.to.constructor.parameters=移至构造函数形参
move.to.top.level=移至顶层
move.type.parameter.constraint.to.where.clause=将类型形参约束移至 'where' 子句
move.unary.operator.to.previous.line.fix.text=将一元运算符移至上一行
move.variable.declaration.into.when=将变量声明移至 'when' 中
moving.to.companion.object=正在移至伴生对象…
name=名称(&N)\:
name.extract.interface=提取接口
name.introduce.import.alias=引入导入别名
name.introduce.lambda.parameter=引入 Lambda 形参
name.introduce.parameter1=引入形参
name.introduce.type.alias=引入类型别名
naming.convention.will.be.violated.after.rename=重命名后将违反命名约定
negated.operation.can.be.simplified=求反运算可以简化
nested.1.call.in.0.could.be.simplified.to.2=''{0}'' 中的嵌套 ''{1}'' 调用可以简化为 {2}
no.actual.for.expect.declaration=以下模块中的 expect 声明中没有 actual\: {0}
non.canonical.modifiers.order=非规范修饰符顺序
non.external.classifier.extending.state.or.props.name=扩展 State 或 Props 的非外部分类器
not.found.in.0.files=在 {0} 个文件中未找到
nothing.to.do=没有要执行的操作
notification.navigation.to.overriding.classes=索引更新时无法导航到重写类
notification.text.kotlin.js.compiler.body=使用新的 Kotlin/JS IR 编译器来缩减应用程序的捆绑包大小并自动生成 TypeScript 定义(d.ts)。
notification.text.kotlin.js.compiler.learn.more=了解详情
notification.text.kotlin.js.compiler.link=https\://kotl.in/jsirstable
notification.text.kotlin.js.compiler.title=Kotlin/JS IR 在 1.8.0 及更高版本中是稳定的\!
null.checks.replaceable.with.safe.calls=null 检查可被替换为安全调用
null.checks.to.safe.call.check.fix.text=将链式 null 检查替换为安全的调用
number.of.attempts.then.files.in.project.0=尝试次数 > 项目中随后的文件，{0}
object.0=对象“{0}”
object.or.top.level.property=对象或顶层属性
object.private.property=对象 private 属性
object.should.be.external.interface=对象应为 external 接口
obsolete.coroutine.usage.fix.family.name=修复实验性协程用法
obsolete.coroutine.usage.in.whole.fix.family.name=修复项目中的实验性协程用法
obsolete.kotlin.js.packages.usage.in.whole.fix.family.name=修复项目中的 'kotlin.dom' 和 'kotlin.browser' 软件包用法
obsolete.package.usage.fix.family.name=修正 ''{0}'' 软件包用法
one.line.return=一行返回
open.moved.members.in.editor=在编辑器中打开移动的成员
open.moved.method.in.editor=在编辑器中打开移动的方法
optimize.imports=优化 import
optimize.imports.collect.unused.imports=正在收集未使用的 import
optimize.imports.task.removing.redundant.imports=正在移除冗余 import
optionally.expected.annotation.has.no.actual.annotation.in.module.0.for.platform.1=可选预期注解在用于平台 {1} 的模块 {0} 中没有实际注解
overridden.marker.implementation=在以下位置实现\:
overridden.marker.implementations.choose.implementation.find.usages={0} 的重写属性
overridden.marker.implementations.choose.implementation.title=选择 {0} 的实现
overridden.marker.implementations.multiple=具有实现
overridden.marker.overrides=在以下位置被重写\:
overridden.marker.overrides.choose.implementation.find.usages={0} 的 super 实现
overridden.marker.overrides.choose.implementation.title=选择 {0} 的 super 实现
overridden.marker.overrides.multiple=在子类中被重写
override.accessor.functions.instead=改为重写访问器函数
override.declaration.choose.to.delete=<html>有一些未使用的成员重写了将被删除的方法。请选择您也想要删除的成员\:</html>
override.declaration.delete.multiple.parameters={0} 是方法层次结构的一部分。是否要删除多个形参?
override.declaration.member=成员
override.declaration.unused.overriding.methods.title=未使用的重写成员
override.declaration.x.implements.y={0}实现{1}。
override.declaration.x.in.y={0} ({1} 内)
override.declaration.x.overrides.y.in.class.list={0} 重写以下类/接口中的声明\: {1} 是否要{2}基声明?
override.java.default.methods.delegate.fix.text=通过委托给委托对象来重写 Java 默认方法
override.java.default.methods.superclass.fix.text=通过显式委托给超类来重写 Java 默认方法
package.0.already.contains.1=软件包 ''{0}'' 已包含 {1}
package.name=软件包名称
package.usages.are.obsolete.since.1.4=''{0}'' 软件包用法自 1.4 起已过时
parameter.0=形参“{0}”
parameter.hints.old=Kotlin\: 显示形参的嵌入提示
parameter.name.is.invalid=形参名 ''{0}'' 无效
parameter.name.prompt=形参名称(&M)\:
parameter.type.is.invalid=形参类型 ''{0}'' 无效
parameter.types.are.not.denotable=无法提取方法，因为以下类型在目标作用域中不可表示\:
parameter.used.in.declaration.body.warning=''{0}'' 用于声明体
parentheses.should.be.removed=应移除括号
pass.outer.class.instance.as.parameter=将外部类实例作为形参传递(&O)
perform.refactoring=执行重构…
placeholder.count.matches.argument.count.fewer.problem.descriptor=提供的实参数量({0})少于指定的占位符数({1}) \#loc
placeholder.count.matches.argument.count.more.problem.descriptor=提供的实参数量({0})多于指定的占位符数({1}) \#loc
plus.assign.should.be.replaced.with.map.to=''+\= {0} '{}''' 应替换为 ''{0}''
plus.call.appends.path.elements='plus' 调用会附加 Path 元素
popup.title.choose.supertype=选择父类型
popup.title.elements=元素
popup.title.expressions=表达式
popup.title.types=类型
predefined.configuration.all.methods.of.the.class=类的所有方法
predefined.configuration.all.vars.of.the.class=类的所有 var
predefined.configuration.all.vars.of.the.object=对象的所有 var
predefined.configuration.also.match.vals=同时匹配 var 和 val
predefined.configuration.annotations=注解
predefined.configuration.anonymous.class=匿名类
predefined.configuration.array.access=数组访问
predefined.configuration.assert.not.null=非 null 断言运算符
predefined.configuration.assignments=赋值
predefined.configuration.casts=转换
predefined.configuration.class.annotation=注解类
predefined.configuration.comments.containing.word=包含给定词的注释
predefined.configuration.companion.object.method.calls=来自伴生对象的方法调用
predefined.configuration.do.while=Do...while 循环
predefined.configuration.elvis=Elvis 运算符
predefined.configuration.for=For 循环
predefined.configuration.function.annotation=注解函数
predefined.configuration.function.explicit.inferred.type=显式和推断类型
predefined.configuration.function.signature=函数签名
predefined.configuration.ifs=If
predefined.configuration.instance=实例
predefined.configuration.kdoc.tag=KDoc 标记
predefined.configuration.lambda=lambda 表达式
predefined.configuration.method.calls=方法调用
predefined.configuration.object.companion.object=对象和伴生对象
predefined.configuration.properties.getter=具有显式 getter 的属性
predefined.configuration.safe.call.operator=安全调用运算符
predefined.configuration.string.literals=字符串字面量
predefined.configuration.strings=字符串
predefined.configuration.strings.with.long.template=包含长模板的字符串
predefined.configuration.trys=Try
predefined.configuration.vars.of.given.type=给定类型的 var
predefined.configuration.when=when 表达式
predefined.configuration.while=While 循环
premature.end.of.template=模板过早结束
preparing.move.descriptor=正在准备 move 描述符
presentation.text.for.receiver.in.container.paren=({1}中的{0})
presentation.text.for.receiver.in.container.paren.no.brackets=对象\: {1}中的{0}
presentation.text.in.container={0} ({1} 内)
presentation.text.in.container.paren=({0} 中)
presentation.text.in.container.paren.no.brackets=({0} 中)
presentation.text.object.in.container={0}中的对象
presentation.text.paren=({0})
presentation.text.paren.no.brackets={0}
print.should.be.replaced.with.logging.display.name=对 'print()' 或 'println()' 的调用
private.data.class.constructor.is.exposed.via.the.generated.copy.method=private 主构造函数通过 'data' 类的生成的 'copy' 方法公开。
private.property=private 属性
progress.finding.implicit.nothing.s=正在查找隐式无内容
progress.looking.up.add.annotation.usage=正在查找注解用法…
progress.looking.up.sealed.subclass.usage=正在查找 sealed 子类的用法…
progress.title.analyze.extraction.data=分析提取数据…
progress.title.calculate.occurrences=计算匹配项…
progress.title.calculating.type=正在计算类型…
progress.title.check.for.conflicts=检查冲突…
progress.title.collect.hierarchy=收集 ''{0}'' 层次结构…
progress.title.collect.members.to.generate=收集成员…
progress.title.converting.to.if.then.else.expression=正在转换为 if-then-else 表达式…
progress.title.introducing.value.for.condition=正在引入条件的值…
progress.title.searching.for.expected.actual=正在搜索预期/实际…
project.view.class.error.name=未提供名称
project.view.class.initializer=类初始值设定项
project.view.expression=表达式
property=属性
property.0=属性“{0}”
property.has.an.actual.declaration.in.the.class.constructor=属性在类构造函数中具有实际声明
property.in.external.interface.should.be.var=external 接口中的属性应为 var
property.is.explicitly.assigned.to.parameter.0.can=属性已明确分配给形参 {0}，因此可以直接在构造函数中声明
property.overloaded.in.child.class.constructor=属性在子类构造函数中重载
protected.visibility.is.effectively.private.in.a.final.class='protected' 可见性在 final 类中实际是 'private'
provide.return.value=提供返回值
put.arguments.on.one.line=将实参放在同一行中
put.arguments.on.separate.lines=将实参放在单独的行中
put.calls.on.separate.lines=将调用放在单独的行中
put.expressions.on.separate.lines=将表达式放在单独的行中
put.parameters.on.one.line=将形参放在同一行中
put.parameters.on.separate.lines=将形参放在单独的行中
quick.doc.no.documentation=无可用文档
quick.doc.section.deprecated=已弃用\:
quick.doc.section.java.declaration=Java 声明\:
quick.doc.section.replace.with=替换为\:
quick.doc.text.enum.ordinal=枚举常数序号\: {0}
quick.doc.text.lateinit='lateinit' 允许初始化<a href\="https\://kotlinlang.org/docs/reference/properties.html\#late-initialized-properties-and-variables">构造函数外部的非 null 属性</a>
quick.doc.text.tailrec='tailrec' 将函数标记为<a href\="https\://kotlinlang.org/docs/reference/functions.html\#tail-recursive-functions">尾递归</a> (允许编译器将递归替换为迭代)
quickFix.add.property.text=将 ''{0}{1}'' 属性 ''{2}'' 添加到 ''{3}''
quickfix.add.property.familyName=添加属性
quickfix.text.suffix.may.change.semantics=\ (可能更改语义)
random.seed=随机种子
range.could.be.replaced.with.indices.call=范围可被替换为 '.indices' 调用
recursive.equals.call=递归 equals 调用
recursive.property.accessor=递归属性访问器
recursive.synthetic.property.accessor=递归合成属性访问器
redundant.0=冗余 ''@{0}''
redundant.0.call=冗余的 ''{0}'' 调用
redundant.0.modifier=冗余的 ''{0}'' 修饰符
redundant.async.call.may.be.reduced.to.0=冗余 ''async'' 调用可简化为 ''{0}''
redundant.call.of.the.conversion.method=转换方法的冗余调用
redundant.call.on.collection.type=对集合类型的冗余调用
redundant.call.on.not.null.type=对非 null 类型的冗余调用
redundant.companion.reference=冗余伴生引用
redundant.constructor.keyword=冗余的 'constructor' 关键字
redundant.curly.braces.in.string.template=字符串模板中的冗余大括号
redundant.double.negation=冗余双重求反
redundant.else=冗余的 'else'
redundant.empty.class.body=冗余空类主体
redundant.empty.initializer.block=冗余空白初始值设定项块
redundant.enum.constructor.invocation=冗余枚举构造函数调用
redundant.explicit.this=冗余显式 this
redundant.getter=冗余 getter
redundant.getter.body=冗余的 getter 主体
redundant.if.option.ignore.chained=忽略链式 'if' 语句
redundant.if.statement=冗余的 'if' 语句
redundant.if.statement.analyzing.type=正在分析条件类型…
redundant.lambda.arrow=冗余 lambda 箭头
redundant.let.call.could.be.removed=可以移除冗余 'let' 调用
redundant.modality.modifier=冗余形式修饰符
redundant.override.fix.text=移除冗余重写方法
redundant.overriding.method=冗余重写方法
redundant.qualifier.name=冗余限定符名称
redundant.qualifier.unnecessary.non.direct.parent.class.qualifier=不必要的非直接父类限定符
redundant.runcatching.call.may.be.reduced.to.0=冗余 ''runCatching'' 调用可简化为 ''{0}''
redundant.sam.constructor=冗余 SAM 构造函数
redundant.sam.constructors=冗余 SAM 构造函数
redundant.semicolon=冗余分号
redundant.semicolon.text=移除冗余分号
redundant.setter=冗余 setter
redundant.setter.body=冗余的 setter 主体
redundant.setter.parameter.type=冗余 setter 形参类型
redundant.string.template=冗余字符串模板
redundant.suspend.modifier=冗余 'suspend' 修饰符
redundant.tostring.call.in.string.template=字符串模板中存在冗余 'toString()' 调用
redundant.type.checks.for.object=对象的冗余类型检查
redundant.unit=冗余 'Unit'
redundant.unit.return.type=冗余 'Unit' 返回值类型
redundant.visibility.modifier=冗余可见性修饰符
refactoring.cannot.be.applied.no.sources.attached=“{0}”重构无法应用\: 未附加任何源
refactoring.cannot.be.applied.to.abstract.declaration={0} 重构不能应用于 abstract 声明
refactoring.cannot.be.applied.to.anonymous.function.without.invocation={0} 重构不能在未经调用的情况下应用于匿名函数
refactoring.cannot.be.applied.to.expect.declaration={0} 重构不能应用于 expect 声明
refactoring.cannot.be.applied.to.lambda.expression.without.invocation={0} 重构不能在未经调用的情况下应用于 lambda 表达式
refactoring.cannot.find.target.class=找不到目标类
refactoring.class.destination=类目标
refactoring.extract.to.separate.file.text=提取到单独文件中
refactoring.file.destination=文件目标
refactoring.move.non.kotlin.file=目标必须是 Kotlin 文件
refactoring.the.function.cannot.be.converted.to.anonymous.function=该函数不能转换为匿名函数
refactoring.the.function.not.found=找不到函数
refactoring.the.invocation.cannot.be.resolved=调用无法解析
remove.0=移除 ''.{0}''
remove.0.from.parameter=从形参中移除 ''{0}''
remove.0.from.property=从属性中移除{0}
remove.0.modifier=移除 ''{0}'' 修饰符
remove.0.variance.from.1=从 ''{1}'' 中移除 ''{0}'' 差异
remove.all.argument.names=移除所有实参名称
remove.annotation.doesnt.have.any.effect=移除注解，因为它不起任何作用。请参阅 https\://youtrack.jetbrains.com/issue/KT-48141
remove.argument.name=移除实参名称
remove.as.dynamic.call.fix.text=移除 'asDynamic' 调用
remove.assequence.call.fix.text=移除 'asSequence' 调用
remove.braces=移除大括号
remove.braces.fix.text=移除大括号
remove.braces.from.0.statement=从 ''{0}'' 语句中移除大括号
remove.braces.from.all.branches=移除所有分支中的大括号
remove.braces.from.if.all.statements=移除所有 'if' 语句中的大括号
remove.braces.from.when.all.entries=移除所有 'when' 条目中的大括号
remove.braces.from.when.entry=从 'when' 条目移除大括号
remove.branch=移除分支
remove.condition=移除条件
remove.conflicting.import.0=移除冲突的导入 {0}
remove.constructor.call=移除构造函数调用
remove.conversion.from.kclass.to.class=移除从 'KClass' 到 'Class' 的转换
remove.curly.braces=移除大括号
remove.default.parameter.value=移除默认形参值
remove.deprecated.symbol.import=移除弃用的符号导入
remove.element=移除元素
remove.else=移除 ''{0}'' 中的 else
remove.else.branch=移除 else 分支
remove.empty.constructor.body=移除空构造函数主体
remove.empty.parentheses.from.annotation.entry.fix.text=移除不必要的圆括号
remove.empty.primary.constructor=移除空主构造函数
remove.enum.constructor.invocation.fix.text=移除枚举构造函数调用
remove.explicit.lambda.parameter.types.may.break.code=移除显式 lambda 形参类型(可能中断代码)
remove.explicit.supertype.qualification=移除显式父类型限定
remove.explicit.type.arguments=移除显式类型实参
remove.explicit.type.specification=移除显式类型规范
remove.explicit.type.specification.from.0=移除 ''{0}'' 中的显式类型规范
remove.expression=移除 ''{0}''
remove.expression.target=移除表达式目标
remove.extension.function.type.annotation=移除不适用的 @ExtensionFunctionType 注解
remove.final.upper.bound=移除最终上限
remove.fix.text=删除表达式
remove.from.annotation.argument=从注解实参中移除 @
remove.function.body=移除函数体
remove.identifier.from.anonymous.function=从匿名函数中移除标识符
remove.indices.in.for.loop=移除 'for' 循环中的索引
remove.initializer.block.fix.text=移除初始值设定项块
remove.jvmfield.annotation=移除 @JvmField 注解
remove.jvmoverloads.annotation=移除 @JvmOverloads 注解
remove.labeled.return.from.last.expression.in.a.lambda=从 lambda 中的最后一个表达式移除带标签的 return
remove.let.call=移除 'let' 调用
remove.modifier=移除修饰符
remove.modifier.fix=将 ''{0}'' 设为非{1}
remove.modifier.fix.family=设为非 {0}
remove.parameter.0=移除形参 ''{0}''
remove.parameter.name=移除形参名称
remove.parts.from.property=从属性中移除部分
remove.redundant=移除冗余的 '?'
remove.redundant.0.modifier=移除冗余 ''{0}'' 修饰符
remove.redundant.assignment=移除冗余赋值
remove.redundant.assignment.title=移除冗余的赋值
remove.redundant.backticks.quick.fix.text=移除冗余反引号
remove.redundant.call.fix.text=移除冗余调用
remove.redundant.calls.of.the.conversion.method=移除转换方法的冗余调用
remove.redundant.cast=移除冗余转换
remove.redundant.companion.reference.fix.text=移除冗余伴生引用
remove.redundant.constructor.keyword.fix.text=移除冗余的 'constructor' 关键字
remove.redundant.else.fix.text=移除冗余的 'else'
remove.redundant.elvis.operator=移除冗余的 elvis 运算符
remove.redundant.elvis.return.null.text=移除冗余 '?\: return null'
remove.redundant.empty.class.body=移除冗余的空类主体
remove.redundant.getter.body.fix.text=移除冗余的 getter 主体
remove.redundant.getter.fix.text=移除冗余 getter
remove.redundant.if.expression=移除冗余 'if' 表达式
remove.redundant.if.may.change.semantics.with.floating.point.types=删除冗余 'if' 语句(可能会更改浮点类型的语义)
remove.redundant.if.text=移除冗余 'if' 语句
remove.redundant.initializer=移除冗余的初始值设定项
remove.redundant.is.check=移除冗余的 'is' 检查
remove.redundant.label=移除冗余标签
remove.redundant.modality.modifier=移除冗余的形式修饰符
remove.redundant.qualifier.name.quick.fix.text=移除冗余限定符名称
remove.redundant.return=移除冗余的 return
remove.redundant.sam.constructor=移除冗余 SAM 构造函数
remove.redundant.sam.constructors=移除冗余 SAM 构造函数
remove.redundant.setter.body.fix.text=移除冗余的 setter 主体
remove.redundant.setter.fix.text=移除冗余 setter
remove.redundant.spread.operator.quickfix.text=移除冗余展开运算符
remove.redundant.unit.fix.text=移除冗余 'Unit'
remove.redundant.visibility.modifier=移除冗余的可见性修饰符
remove.redundant.with.fix.text=移除冗余'with' 调用
remove.require.not.null.call.fix.text=移除 ''{0}'' 调用
remove.return.0=移除 return@{0}
remove.return.label.fix.family=移除冗余标签
remove.return.label.fix.text=移除冗余 ''@{0}''
remove.self.assignment.fix.text=移除自我赋值
remove.single.expression.string.template=移除单表达式字符串模板
remove.single.lambda.parameter.declaration=移除单个 lambda 形参声明
remove.star=移除 '*'
remove.supertype=移除父类型
remove.to.string.fix.text=移除 'toString()' 调用
remove.token.from.function.declaration=从函数声明中移除 '\=' 令牌
remove.type.arguments=移除类型实参
remove.type.parameters=移除类型形参
remove.unary.operator.fix.text=移除未使用的一元运算符
remove.underscores=移除下划线
remove.unnecessary.parentheses.from.function.call.with.lambda=从带 lambda 的函数调用中移除不必要的圆括号
remove.unused.imports.quickfix.text=移除未使用的 import
remove.use.site.get.target=移除 'get\:' 以使注解生效。(会更改语义。请参阅\: https\://youtrack.jetbrains.com/issue/KT-48141)
remove.useless=移除无用的 '?'
remove.val.or.var.from.parameter=从形参中移除 'val' 或 'var'
remove.var.keyword.text=移除 'var'
remove.variable=移除变量
remove.variable.0=移除变量 ''{0}''
rename.0.to.explicitly.ignore.return.value=重命名变量 ''{0}'' 以显式忽略返回值
rename.base.0=重命名基{0,choice,1\#函数|2\#属性|3\#成员|4\#方法|11\#函数|12\#属性|13\#成员|14\#方法}
rename.class.to.0=将类重命名为 {0}
rename.class.to.containing.file.name=将类重命名为包含文件名称
rename.declaration.title.0.implements.1.2.of.3={0} {1,choice,1\#实现|2\#重写}{3}的{2}
rename.file=重命名文件
rename.file.0=将文件重命名为 ''{0}''
rename.file.to.0.1=将文件重命名为 {0}.{1}
rename.file.to.match.top.level.class.name=重命名文件以匹配顶层类名
rename.identifier.fix.text=重命名
rename.only.current.0=仅重命名当前的{0,choice,1\#函数|2\#属性}
rename.parameter.to.match.overridden.method=重命名形参以匹配重写的方法
rename.redundant.call.fix.text=将调用更改为 ''{0}''
rename.searching.for.all.overrides=正在搜索所有重写
rename.searching.for.super.declaration=正在搜索最深的 super 声明
rename.to.0=重命名为 ''{0}''
rename.to.01=重命名为 {0}
rename.to.fix.text=重命名为 ''{0}''
rename.to.underscore=重命名为 _
reorder.parameters=对形参重新排序
reorder.parameters.command=对形参重新排序
repair.actual.members=修复实际成员
replace.&&.with.||=将 '\\&\\&' 替换为 '||'
replace.0.call.with.indexing.operator=将 ''{0}'' 调用替换为索引运算符
replace.0.name.with.spaces=将 {0} 名称替换为空格
replace.0.with=将 ''{0}()'' 替换为 ''+\=''
replace.0.with.1=将 ''{0}'' 替换为 ''{1}''
replace.0.with.1.and.vice.versa=将 ''{0}'' 替换为 ''{1}''，反之亦然
replace.and.with.when.guard=将 '\\&\\&' 替换为 'if'
replace.annotation=替换注解
replace.annotation.with.0=将注解替换为 {0}
replace.array.of.boxed.with.array.of.primitive=将装箱数组替换为基元数组
replace.assert.boolean.with.assert.equality=将断言布尔替换为断言等式
replace.assert.with.operator=将断言替换为运算符
replace.assignment.with.if.expression=将赋值替换为 'if' 表达式
replace.assignment.with.when.expression=将赋值替换为 'when' 表达式
replace.by.0=由 ''{0}'' 替换
replace.by.reconstructed.type=由重构造类型替换
replace.call.with.unary.operator=将调用替换为一元运算符
replace.cast.with.call.to.to.0=将转换替换为对 ''to{0}()'' 的调用
replace.cast.with.primitive.conversion.method=将转换替换为基元转换方法
replace.collection.count.with.size.quick.fix.text=将 'count' 替换为 'size'
replace.contains.call.with.in.operator=将 'contains' 调用替换为 'in' 运算符
replace.contains.call.with.in.operator.description=使用了 Java 'contains' 调用，而非 Kotlin 惯用的 'in' 运算符
replace.deprecated.symbol.usage=替换弃用的符号用法
replace.deprecated.symbol.usage.in.whole.project=替换整个项目中弃用的符号用法
replace.diagnostic.name.fix.family.name=替换诊断名称
replace.diagnostic.name.fix.text={0} 替换为 {1}
replace.elvis.expression.with.if.expression=将 elvis 表达式替换为 'if' 表达式
replace.equal.with.content.equals=将 '\=\=' 替换为 'contentEquals'
replace.explicit.lambda.parameter.with.it=将显式 lambda 形参替换为 'it'
replace.explicit.parameter.0.with.it=将显式形参 ''{0}'' 替换为 ''it''
replace.expression.with.if.expression=将 '\!\!' 表达式替换为 'if' 表达式
replace.function.call.with.if=将函数调用替换为 'if'
replace.function.call.with.the.opposite=将函数调用替换为相反的函数调用
replace.function.call.with.when=将函数调用替换为 'when'
replace.get.or.set.call.with.indexing.operator=将 get 或 set 调用替换为索引运算符
replace.guard.clause.with.kotlin.s.function.call=将 guard 子句替换为 Kotlin 函数调用
replace.if.expression.with.elvis.expression=将 'if' 表达式替换为 elvis 表达式
replace.if.expression.with.return=将 'if' 表达式替换为 return
replace.if.expression.with.safe.access.expression=将 'if' 表达式替换为安全访问表达式
replace.if.expression.with.safe.cast.expression=将 'if' 表达式替换为安全的转换表达式
replace.if.with.elvis.operator=将 'if' 替换为 elvis 运算符
replace.if.with.when=将 'if' 替换为 'when'
replace.if.with.when.changes.semantics=将 'if' 替换为 'when' (改变语义)
replace.index.loop.with.collection.loop.quick.fix.text=替换为元素的循环
replace.infix.call.with.ordinary.call=将中缀调用替换为普通调用
replace.int.range.end.inclusive.with.last.quick.fix.text=将 'endInclusive' 替换为 'last'
replace.int.range.start.with.first.quick.fix.text=将 'start' 替换为 'first'
replace.invalid.positioned.arguments.for.annotation=替换注解的无效定位实参
replace.invoke.with.direct.call=将 'invoke' 替换为直接调用
replace.it.with.explicit.parameter=将 'it' 替换为显式形参
replace.jvmfield.with.const=将 '@JvmField' 替换为 'const'
replace.kotlin.options.with.compiler.options=将 'kotlinOptions' 替换为 'compilerOptions'
replace.manual.range.with.indices.call.quick.fix.text=替换为索引
replace.modifier=替换修饰符
replace.negated.0.operation.with.1=将求反的 ''{0}'' 运算替换为 ''{1}''
replace.negated.0.operation.with.1.may.change.semantics.with.floating.point.types=将求反的 ''{0}'' 运算替换为 ''{1}'' (可能会更改浮点类型的语义)
replace.negated.0.with.1=将求反的 ''{0}'' 替换为 ''{1}''
replace.not.equal.with.content.equals=将 '\!\=' 替换为 'contentEquals'
replace.nullable.type.with.non.nullable.family.name=将可为 null 的类型替换为不可为 null 的类型
replace.overloaded.operator.with.function.call=将重载运算符替换为函数调用
replace.property.initializer.with.if.expression=将属性初始值设定项替换为 'if' 表达式
replace.property.initializer.with.when.expression=将属性初始值设定项替换为 'when' 表达式
replace.return.with.if.expression=将 return 替换为 'if' 表达式
replace.return.with.when.expression=将 return 替换为 'when' 表达式
replace.safe.access.expression.with.if.expression=将安全访问表达式替换为 'if' 表达式
replace.scope.function.with.safe.call=将作用域函数替换为 (?.) 调用
replace.size.check.with.0=将大小检查替换为 ''{0}''
replace.size.check.with.isnotempty=将大小检查替换为 'isNotEmpty'
replace.size.zero.check.with.isempty=将大小零检查替换为 'isEmpty'
replace.substring.call.with.droplast.call=将 'substring' 调用替换为 'dropLast' 调用
replace.substring.call.with.indexing.operation.call=将 'substring' 调用替换为索引操作调用
replace.substring.call.with.substringafter.call=将 'substring' 调用替换为 'substringAfter' 调用
replace.substring.call.with.substringbefore.call=将 'substring' 调用替换为 'substringBefore' 调用
replace.substring.call.with.take.call=将 'substring' 调用替换为 'take' 调用
replace.to.with.infix.form.quickfix.text=将 'to' 替换为中缀形式
replace.tostring.with.string.template=将 'toString' 替换为字符串模板
replace.total.order.equality.with.ieee.754.equality=使用 IEEE 754 等式替换总订单等式
replace.unsafe.cast.with.safe.one.text=将不安全的转换替换为安全的转换
replace.usages.of.0.in.whole.project=替换整个项目中的 ''{0}'' 用法
replace.when.with.if=将 'when' 替换为 'if'
replace.with.0=替换为 ''{0}''
replace.with.0.1.2=替换为 {0}[{1}] ?\: {2}
replace.with.0.call=替换为 ''{0}()'' 调用
replace.with.0.operator=替换为 ''{0}'' 运算符
replace.with.a.for.loop=替换为 'for' 循环
replace.with.a.foreach.function.call=替换为 ''{0}'' 函数调用
replace.with.array.call=替换为数组调用
replace.with.array.literal.fix.family.name=替换为 [...]
replace.with.arrayof=替换为 'arrayOf'
replace.with.assignment.fix.text=替换为赋值 (原始为空)
replace.with.binary.operator=替换为二元运算符
replace.with.block.comment=替换为块注释
replace.with.content.equals=替换为 'contentEquals'
replace.with.dollar.literals=将转义的美元符号替换为字面量
replace.with.dot.call=替换为点调用
replace.with.elvis.error.fix.text=替换为 '?\: error("")'
replace.with.elvis.return.fix.text=替换为 ''?\: return{0}''
replace.with.end.of.line.comment=替换为行尾注释
replace.with.enum.map.fix.text=替换为 'EnumMap'
replace.with.equality.check.fix.text=替换为相等检查
replace.with.equality.fix.text=将 ''{0}'' 替换为 ''{1}''
replace.with.error=替换为 '?\: error(...)'
replace.with.explicit.type=将 '_' 替换为显式类型
replace.with.field.fix.text=替换为 'field'
replace.with.filter.fix.text=替换为筛选器
replace.with.generated.publishedapi.bridge.call.0=替换为生成的 @PublishedApi 桥调用 ''{0}''
replace.with.get.or.else.fix.text=替换为 'getOrElse' 调用
replace.with.get.value.call.fix.text=替换为 'getValue' 调用
replace.with.if.fix.text=替换为 'if' 类型检查
replace.with.import.alias=替换为导入别名
replace.with.in.when=将 ',' 替换为 '||'\:
replace.with.indexing.and.elvis.operator=替换为索引和 elvis 运算符
replace.with.infix.function.call=替换为中缀函数调用
replace.with.kotlin.analog.function.family.name=替换为 Kotlin 模拟
replace.with.kotlin.analog.function.text=替换为 ''{0}'' 函数
replace.with.kotlin.s.foreach=替换为 Kotlin 的 forEach
replace.with.kotlin.s.function.call=替换为 Kotlin 的函数调用
replace.with.label.0.at=替换为标签 {0}@
replace.with.list.generator.fix.text=替换为 List 生成器
replace.with.map.to=替换为 ''{0}''
replace.with.operator.assignment=替换为运算符赋值
replace.with.ordinary.assignment=替换为普通赋值
replace.with.parameter.name=将 '_' 替换为形参名称
replace.with.publishedapi.bridge.call=替换为 @PublishedApi 桥调用
replace.with.rangeUntil.quick.fix.text=替换为 '..<'
replace.with.repeat.fix.family.name=替换为 'repeat()'
replace.with.return=将 '\!\!' 替换为 '?\: return'
replace.with.safe.call=替换为安全的 (?.) 调用
replace.with.safe.cast.text=替换为安全的转换
replace.with.safe.this.call=替换为安全的 (this?.) 调用
replace.with.std.lib.fix.text=替换为 {0}.{1}
replace.with.stdlib.operations=替换为 stdlib 运算
replace.with.stdlib.operations.with.use.of.assequence=替换为使用 'asSequence()' 的 stdlib 运算
replace.with.string.literal.fix.family.name=替换为字符串模板
replace.with.underscore=将显式类型替换为 '_'
replace.with.until.quick.fix.text=替换为 'until'
replace.with1=替换为 '+\='
replace.||.with.&&=将 '||' 替换为 '\\&\\&'
replaceable.with.enummap=可被替换为 'EnumMap'
replaceable.with.operator.assignment=可被替换为运算符赋值
report.also.for.a.variables.without.a.whitespace.around=同时为周围没有空格的变量报告
report.also.on.call.with.single.boolean.literal.argument=同时在包含单个布尔字面量实参的调用上报告
report.also.on.statement=也在语句上报告
report.for.types.with.platform.arguments=为包含平台实参的类型报告
reports.only.function.calls.from.kotlinx.coroutines=仅报告来自 'kotlinx.coroutines' 的函数调用
reset.files=重置文件…
resolve.pasted.references=解析粘贴的引用
result.of.0.call.is.not.thrown=未抛出 ''{0}'' 调用的结果
retargeting.usages.progress=正在重新定位用法
rethrow.stored.pce.as.a.new.runtime.exception=将存储的 PCE 作为新运行时异常再次抛出
return.type=返回值类型(&R)\:
return.type.is.invalid=返回值类型无效
return.when='返回 when'
revert.applied.imports.command=还原已应用的导入
roots.description.text.update.source.roots.for.non.jvm.modules.in.kotlin.project=为 Kotlin 项目中的非 JVM 模块更新源根
round.using.0=使用 {0}() 舍入
safe.delete.constructor=安全删除构造函数
saving.files=正在保存文件…
scanning.files.0.fo.1.file.2.occurrences.found=正在扫描文件\: 第 {0} 个，共 {1} 个。已找到 {2} 个匹配项
script.action.text.ignore=忽略
script.action.text.open.settings=打开设置
script.action.text.show.all=全部显示
script.name.kotlin.scripting=Kotlin 脚本
script.not.executable.missing.execute.permission=脚本不可执行。缺少执行权限。
script.text.multiple.script.definitions.are.applicable.for.this.script=多个脚本定义适用于此脚本。已使用 {0}
sealed.sub.class.has.no.state.and.no.overridden.equals='sealed' 子类没有状态，且没有被重写的 'equals()'
search.for.not.property.candidates=搜索非属性候选项
search.for.text.occurrences=搜索文本匹配项(&T)
search.in.comments.and.strings=在注释和字符中搜索(&C)
searching.0=正在搜索 {0}…
searching.for.0=正在搜索 {0}
searching.for.imports.to.delete.title=正在搜索要删除的导入
searching.for.not.property.candidates=正在搜索非属性候选项
searching.for.overriding.methods=正在搜索重写方法
searching.inheritors=正在搜索继承者…
searching.usages.of.0.parameter=正在搜索 ''{0}'' 形参的用法
select.lambda.to.label=选择要标记的 lambda
select.loop.statement.to.label=选择要标记的循环语句
select.target.code.block.file=选择目标代码块/文件
select.target.file=选择目标文件
selected.code.fragment.has.multiple.exit.points=选择的代码段具有多个退出点
selected.code.fragment.has.multiple.output.values=选择的代码段具有 3 个以上的输出值\:
selected.code.fragment.has.output.values.and.exit.points=选择的代码段既有输出值，也有可选的退出点
setter.of.0.will.become.invisible.after.extraction=提取后 {0} 的 Setter 将变为不可见
shortening.usages.progress=正在缩短用法
should.be.replaced.with.if.type.check=应替换为 'if' 类型检查
should.be.replaced.with.indexing=应替换为索引
should.be.replaced.with.kotlin.function=应替换为 Kotlin 函数
should.be.replaced.with.list.generator=应替换为 List 生成器
should.not.contain.lowercase.letter=不应包含小写字母
should.not.contain.underscores=不应包含下划线
should.not.contain.underscores.in.the.middle.or.the.end=中间或结尾不应包含下划线
should.not.contain.underscores.with.camel.case=使用骆驼拼写法时不应包含下划线
should.not.start.with.an.underscore=不应以下划线开头
should.not.start.with.an.uppercase.letter=不应以大写字母开头
should.start.with.a.lowercase.letter=应以小写字母开头
should.start.with.an.uppercase.letter=应以大写字母开头
signature.preview=签名预览
simplify.0.to.1=将 ''{0}'' 简化为 ''{1}''
simplify.boolean.expression=简化布尔表达式
simplify.call.chain.fix.text=将调用链合并为 ''{0}''
simplify.call.fix.text=将 ''{0}'' 调用转换为 ''{1}''
simplify.comparison=简化对比
simplify.fix.text=简化表达式
simplify.foldable.if.then=简化可折叠的 if-then
simplify.negated.operation=简化求反运算
simplify.when.fix.text=简化 'when'
since.kotlin.1.3.main.parameter.is.not.necessary=从 Kotlin 1.3 起，主形参不必要
slicer.text.in=位置
slicer.text.tracking.enclosing.lambda=\ (跟踪封闭的 lambda)
slicer.text.tracking.lambda.argument=\ (跟踪 lambda 形参)
slicer.text.tracking.lambda.calls=\ (跟踪 lambda 调用)
slicer.text.tracking.lambda.receiver=\ (跟踪 lambda 接收器)
slicer.title.dataflow.from.here=流出此处的数据流
slicer.title.dataflow.to.here=流入此处的数据流
slicer.tool.tip.text.variable.dereferenced=已解引用变量
some.types.are.not.accessible.from.0.1=无法从 {0} 访问一些类型\:\n{1}
sort.modifiers=对修饰符排序
specify.all.remaining.arguments.by.name=按名称指定所有剩余实参
specify.all.types.explicitly.in.destructuring.declaration=在析构声明中显式指定所有类型
specify.explicit.lambda.signature=指定显式 lambda 签名
specify.override.explicitly=显式指定重写
specify.override.for.0.explicitly=为 ''{0}'' 显式指定重写
specify.remaining.required.arguments.by.name=按名称指定剩余的必需实参
specify.return.type.explicitly=显式指定返回值类型
specify.super.type=显式指定父类型 ''{0}''
specify.type.explicitly=显式指定类型
split.if.into.two=将 'if' 拆分为两部分
split.property.declaration=拆分属性声明
spring.secured.urls.inlay.hints=Kotlin\: 显示安全的 Spring URL 的嵌入提示
ssr.modifier.match.call.semantically=在语义上匹配调用
ssr.modifier.match.companion.object=匹配伴生对象
ssr.modifier.match.val=匹配 val
ssr.modifier.match.var=匹配 var
start.import.button.text.add=添加
start.import.button.text.remove=移除
statement=语句
status=(状态)
status.text.no.definitions=无定义
step.1.collecting.0.1.2=第 1 步\: 收集 {0}\:{1}\:{2}
step.2.0.of.1=第 2 步\: {0}/{1}
step.3.0.of.1=第 3 步\: {0}/{1}
surround.with.0=使用 {0}(...) 包围
surround.with.array.of=使用 arrayOf(...) 包围
surround.with.lambda=使用 lambda 包围
surround.with.null.check=使用 null 检查包围
surround.with.star.0=使用 *{0}(...) 包围
suspicious.asdynamic.member.invocation=可疑的 'asDynamic' 成员调用
suspicious.callable.reference.as.the.only.lambda.element=可疑的可调用引用作为唯一的 lambda 元素
suspicious.combination.of.and=可疑的 \=\= 与 \=\=\= 组合
suspicious.var.property.its.setter.does.not.influence.its.getter.result=可疑的 'var' 属性\: 它的 setter 不会影响其 getter 结果
test.function=测试函数
test.integration.button.text.cancel=取消
test.integration.button.text.rewrite=重写
test.integration.message.text.create.test.in.the.same.source.root=在相同的源根中创建测试?
test.integration.message.text.kotlin.class=Kotlin 类 ''{0}'' 已存在。是否要更新它?
test.integration.title.no.test.roots.found=找不到测试根
test.result.log.file.will.be.placed.here=测试结果日志文件将位于此处
text.0.1.must.be.moved.with.sealed.parent.class.and.all.its.subclasses={0} ''{1}'' 必须随 sealed 父类及其全部子类一起移动
text.0.already.contains.1={0} 已包含 {1}
text.0.already.contains.nested.class.1={0} 已包含名为 {1} 的嵌套类
text.0.already.declared.in.1={0} 已在 {1} 中声明
text.0.have.no.inheritors.warning={0} 没有继承者\n向下推动成员会导致它们被删除。要继续吗?
text.0.in.1.will.override.corresponding.member.of.2.after.refactoring={1} 中的 {0} 会在重构后重写 {2} 的相应成员
text.0.inherits.from.1.it.will.not.be.affected.by.refactoring={0} 继承自 {1}。\n它不会受重构影响
text.0.is.invalid.destination.package=''{0}'' 是无效的目标软件包名称
text.0.is.not.allowed.in.the.target.context=目标上下文中不允许出现 ''{0}''
text.0.is.not.valid.package.name={0} 不是有效的软件包名称
text.0.to.inline=要内联的 {0}
text.0.uses.1.which.is.not.accessible.from.2={0} 使用 {1}，后者无法从 {2} 访问
text.0.uses.1.which.will.be.inaccessible.after.move={0} 使用 {1}，后者在移动后将无法访问
text.0.uses.1.which.will.not.be.accessible.from.subclass={0} 使用 {1}，后者无法从子类访问。
text.0.uses.internal.1.which.will.be.inaccessible.after.move={0} 使用 internal {1}，后者在移动后将无法访问
text.0.will.be.shadowed.by.1={0} 将被 {1} 隐藏
text.0.will.clash.with.existing.1.in.2=重命名后的 {0} 会与 {2} 中的现有 {1} 冲突
text.0.will.no.longer.be.accessible.after.signature.change={0} 在签名更改后将无法访问
text.Assignment=赋值
text.Function=函数
text.Name=名称
text.Package=软件包
text.Property=属性
text.Return=返回
text.abstract=抽象
text.actual.moved.to.common.modules.target=actual 声明 ''{0}'' 将被移至通用模块。
text.add.getter=添加 getter
text.add.getter.and.setter=添加 getter 和 setter
text.add.setter=添加 setter
text.add.use.site.target.0=添加使用站点目标 ''{0}''
text.all.declarations.must.belong.to.the.same.directory.or.class=所有声明必须属于同一目录或类
text.annotation=注解
text.annotation.class=注解类
text.anonymous=[匿名]
text.anonymous.function=匿名函数
text.at.least.one.file.must.be.selected=应至少选择一个成员
text.callee.text.would.be.shown.here=此处将显示被调用方文本
text.caller.text.with.highlighted.callee.call.would.be.shown.here=此处将显示包含\n突出显示的被调用方调用的调用方文本
text.can=可以
text.cannot.create.target.directory.0=无法创建目标目录 {0}
text.cannot.determine.source.directory=无法确定源目录
text.cannot.find.package.corresponding.to.0=找不到 {0} 对应的软件包
text.cannot.find.target.package.name=找不到目标软件包名称
text.cannot.inline.reference.from.0.to.1=无法将引用从 {0} 内联到 {1}
text.cannot.move.expect.actual.declaration.to.file=无法将预期/实际声明移至文件
text.cannot.move.for.current.project=无法为当前项目移动
text.cannot.move.inner.class.0.into.itself=无法将嵌套的类 {0} 移至类自身
text.cannot.move.to.original.file=无法移至原始文件
text.change.file.package.to.0=将文件的软件包更改为 ''{0}''
text.change.use.site.target.0=将使用场所目标更改为 ''{0}''
text.choose.containing.file=选择包含文件
text.class=类
text.class.0={0,choice,1\#类|2\#类}
text.class.0.already.contains.member.1={0} 已包含 {1}
text.class.0.already.exists.in.package.1=类 {0} 在软件包 {1} 中已存在
text.class.0.already.exists.in.the.target.scope=类 {0} 在目标作用域中已存在
text.class.0.is.final={0} 为 final
text.constructor=构造函数
text.convert._it_.to.explicit.lambda.parameter=无法将 'it' 转换为显式 lambda 形参
text.create=创建
text.create.destructuring.declaration=创建析构声明
text.create.single.variable=创建单个变量
text.declaration=声明
text.declarations.clash.move.0.destination.1.declared.in.scope.2=以下声明将冲突\: 移动 {0} 和在作用域 {2} 中声明的目标 {1}
text.default.value=\ // 默认值 \= {0}
text.destination.class.should.be.kotlin.class=目标类必须为 Kotlin 类
text.do.you.want.to.rename.0.as.well=是否还要重命名 {0}()?
text.do.you.want.to.rename.base.property=是否要重命名基本属性?
text.do.you.want.to.rename.base.property.from.0=是否要从 {0} 重命名基本属性?
text.done=完成
text.duplicating.local.variable=正在复制局部变量 ''{0}''
text.duplicating.parameter=正在复制形参 ''{0}''
text.duplicating.property=正在复制属性 ''{0}''
text.enable.annotation.target.feature=添加编译器实参\: {0}
text.enum=枚举
text.enum.class=枚举类
text.enum.constant=枚举常量
text.enum.entry.0={0,choice,1\#枚举条目|2\#枚举条目}
text.expected.moved.to.platform.modules.target=预期声明 ''{0}'' 将被移至平台模块。
text.explicit.receiver.is.already.present.in.call.element.0=显式接收器在调用元素中已存在\: {0}
text.extend=扩展
text.extension=扩展
text.extension.function=扩展函数
text.extension.function.0=扩展{0,choice,1\#函数|2\#函数}
text.extension.property=扩展属性
text.extension.property.0=扩展{0,choice,1\#属性|2\#属性}
text.extract.superclass=提取超类
text.file.0.already.exists.in.1=文件 {0} 在 {1} 中已存在
text.file.name.cannot.be.empty=文件名不能为空
text.first.definition.that.matches.script.pattern.extension.applied.starting.from.top=从顶部开始，第一个与脚本模式/扩展匹配的定义会被应用
text.function=函数
text.function.0={0,choice,1\#函数|2\#函数}
text.function.already.exists=函数已存在\: ''{0}''
text.function.in.ticks.0=函数 ''{0}''
text.getter=getter
text.implement=实现
text.implements=实现
text.implicit.companion.object.will.be.inaccessible.0=隐式伴生对象将无法访问\: {0}
text.incorrect.target.path.directory.0.does.not.belong.to.current.project=目标路径不正确。目录 {0} 不属于当前项目。
text.indirect.outer.instances.will.not.be.extracted.0=将不会提取间接外部实例\: {0}
text.infix.extension.function=中缀扩展函数
text.infix.extension.function.0=中缀扩展{0,choice,1\#函数|2\#函数}
text.infix.function=中缀函数
text.infix.function.0=中缀{0,choice,1\#函数|2\#函数}
text.initializer=初始值设定项
text.inline.0=内联{0}
text.inline.all.references.and.verb.0.the.kind.1.occurrences.2=内联所有引用并{0} {1} {2}
text.inline.function.not.supported=尚不支持内联函数
text.inline.recursive.function.is.supported.only.on.references=仅在引用上支持内联递归函数
text.inline.this.reference.and.keep.the.0=内联此引用并保留 {0}
text.inlined.0.overrides.0.1=已内联的 {0} 重写 {0} {1}
text.inlining.0.1=正在内联{0} {1}
text.inner.class.0.cannot.be.moved.to.interface={0} 是内部类。无法移至接口
text.interface=接口
text.introduce.default.value=引入默认值(&D)
text.invalid.target.path.0=目标路径 {0} 无效
text.invalid.target.specified=指定了无效目标
text.keep=保留
text.lambda.parameter=lambda 形参
text.lambda.parameters=Lambda 形参(&P)\:
text.lambda.return.type=Lambda 返回值类型(&T)
text.lazy.property=延迟属性
text.local.property=属性
text.local.variable=局部变量
text.looking.for.usages=正在查找用法…
text.member=成员
text.member.0.in.super.class.will.clash.with.existing.member.of.1=超类中的 {0} 将与 {1} 的现有成员冲突
text.member.extension.call.will.not.be.processed.0=不会处理成员扩展调用\: {0}
text.move.declaration.no.support.for.companion.objects=伴生对象不支持“移动声明”
text.move.declaration.no.support.for.enums=枚举条目不支持“移动声明”
text.move.declaration.no.support.for.multi.file=不支持从不同文件移动声明
text.move.declaration.no.support.incorrect.modality=不支持 'abstract'、'open' 和 'override' 成员的移动
text.move.declaration.only.support.for.single.elements=多重嵌套声明不支持移动声明
text.move.declaration.only.support.for.some.nested.declarations=除嵌套类、函数和属性之外的嵌套声明不支持移动声明
text.move.declaration.proceed.move.without.mpp.counterparts.text=此重构将移动所选声明(不包含可能导致编译错误的 expect/actual 对应项)。\n是否要继续?
text.move.declaration.proceed.move.without.mpp.counterparts.title=无法执行重构。此重构不支持 MPP 声明。
text.move.declaration.supports.only.top.levels.and.nested.classes=仅顶级声明和嵌套类支持“移动声明”
text.move.declarations=移动声明
text.move.file.0=移动 {0}
text.move.file.no.support.for.file.target=非目录目标不支持移动文件
text.move.method.is.not.supported.for.generic.classes=泛型类不支持 Move 方法
text.move.method.is.not.supported.for.non.project.methods=非项目方法不支持 Move 方法
text.move.method.is.not.supported.when.method.is.a.part.of.inheritance.hierarchy=当方法是继承层次结构的一部分时，不支持 Move 方法
text.move.refactoring.not.available.during.indexing=移动重构不可用，正在分析项目…
text.moving.multiple.nested.classes.to.top.level.not.supported=不支持将多个嵌套类移至顶级
text.name=名称
text.nested.classes.to.upper.level=嵌套类到上一级
text.no.destination.object.specified=未指定目标对象
text.no.elements.to.move.are.selected=未选择要移动的元素
text.no.files.to.move=没有要移动的给定文件
text.no.name.provided.for.type.alias=没有为类型别名提供名称
text.no.package.corresponds.to.directory=没有对应于此目录的软件包
text.non.kotlin.0.will.not.be.affected.by.refactoring=非 Kotlin {0} 将不会受重构影响
text.object=对象
text.object.0={0,choice,1\#对象|2\#对象}
text.operator.0={0,choice,1\#运算符|2\#运算符}
text.overload=重载
text.overrides=重写
text.package.directive.dont.match.file.location=软件包指令与文件位置不匹配
text.parameter=形参
text.parameter.0=形参 ''{0}''
text.parameter.name=形参名(&N)\:
text.parameter.reference.can.t.be.safely.replaced.with.0.since.1.is.ambiguous.in.this.context=形参引用无法安全地替换为 {0}，因为 {1} 在此上下文中不明确
text.parameter.reference.can.t.be.safely.replaced.with.0.since.target.function.can.t.be.referenced.in.this.context=形参引用无法安全地替换为 {0}，因为在此上下文中无法引用目标函数
text.parameter.type=形参类型(&T)\:
text.parameters=形参(&P)
text.part=部分
text.pattern=模式\:
text.primary=主
text.primary.constructor=主构造函数
text.proceed.with.extraction=仍然继续提取
text.process.duplicates=处理重复项
text.processing.file.0=正在处理 {0}
text.property=属性
text.property.0={0,choice,1\#属性|2\#属性}
text.property.in.ticks.0=属性 ''{0}''
text.property.with.getter=包含 getter 的属性
text.property.with.initializer=包含初始值设定项的属性
text.property.would.conflict.with.superclass.primary.constructor.parameter.0=属性 ''{0}'' 将与超类中的主构造函数形参 ''{1}'' 冲突。
text.pushed.member.will.not.be.available.in.0=推送的成员无法在 ''{0}'' 中使用
text.qualified.call.will.not.be.processed.0=将不会处理限定调用\: {0}
text.receiver=接收器
text.receiver.can.t.be.safely.transformed.to.value.argument=接收器无法安全地转换为值实参\: {0}
text.refactoring.can.t.be.performed.on.the.selected.code.element=无法对选定的代码元素执行重构
text.refactoring.is.not.applicable.to.this.code.fragment=重构不适用于此代码段
text.reference.cannot.be.converted.to.a.lambda=引用无法转换为 lambda
text.references.in.code.to.0.1.and.its.declarations=在代码中引用{0} {1} 及其声明
text.references.to.outer.classes.have.to.be.added.manually=移动后必须手动添加对外部类的引用
text.remove=移除
text.remove.0.no.longer.used=移除不再使用的{0}
text.remove.question=移除 '?'
text.rename.as.part.of.phrase=重命名
text.rename.is.not.applicable.to.compiler.plugin.generated.declarations=重命名不适用于编译器插件生成的声明
text.rename.is.not.applicable.to.secondary.constructors=“重命名”不适用于辅助构造函数
text.rename.is.not.applicable.to.synthetic.declarations=“重命名”不适用于合成声明
text.rename.not.applicable.to.backing.field.reference=“重命名”不适用于支持字段引用
text.rename.not.applicable.to.dynamically.invoked.methods=“重命名”不适用于动态调用的成员
text.rename.overloads.title=重命名重载
text.rename.parameters.title=重命名形参
text.return=返回
text.sealed.broken.hierarchy.none.in.target=''{0}'' 的 sealed 层次结构将被拆分。它的成员都不在模块 ''{2}'' 的软件包 ''{1}'' 中\: {3}。
text.sealed.broken.hierarchy.still.in.source=''{0}'' 的 sealed 层次结构将被拆分。模块 ''{2}'' 的软件包 ''{1}'' 仍将包含其成员\: {3}。
text.sealed.class.0.must.be.moved.with.all.its.subclasses=密封类 ''{0}'' 必须随其所有子类一起移动
text.secondary=辅助
text.secondary.constructor=辅助构造函数
text.select.target.code.block=选择目标代码块
text.select.target.code.block.file=选择目标代码块/文件
text.select.target.file=选择目标文件
text.setter=setter
text.should=应当
text.there.is.already.a.parameter={1} 中已存在形参 ''{0}''。它会与新形参冲突。
text.there.is.already.a.variable.0.in.1.it.will.conflict.with.the.new.parameter={1} 中已存在变量 ''{0}''。它会与新形参冲突。
text.type=类型
text.type.alias=类型别名
text.type.alias.0=类型{0,choice,1\#别名|2\#别名}
text.type.alias.cannot.refer.to.types.which.aren.t.accessible.in.the.scope.where.it.s.defined=类型别名无法引用在定义作用域中无法访问的类型
text.type.alias.name.must.be.a.valid.identifier.0=类型别名名称必须为有效的标识符\: {0}
text.type.already.exists.in.the.target.scope=类型 {0} 在目标作用域中已存在
text.type.parameter=类型{0, choice, 0\#形参|2\#形参}
text.type.parameter.names.must.be.distinct=类型形参名称必须不同
text.type.parameters=类型形参(&P)
text.unexpected.element.type.0=意外元素类型\: {0}
text.update.usages.to.reflect.declaration.0.move=更新用法以反映{0, choice, 0\#声明n|1\#声明}移动
text.updating.usages.progress=正在更新用法…
the.anonymous.object=匿名对象
the.declaration.has.0.modifier=声明包含 ''{0}'' 修饰符
the.function.declaration.shouldn.t.have.a.default.implementation=函数声明不应具有默认实现
the.package.0.does.not.match.the.implicit.prefix.1=所选软件包 ''{0}'' 与目标的隐式软件包前缀不兼容\: ''{1}''。执行重构将破坏隐式软件包前缀。
there.are.possible.side.effects.found.in.expressions.assigned.to.the.variable.0=在分配给变量 ''{0}'' 的表达式中发现可能的副作用<br>您可以\:<br>-\\&nbsp;<b>移除</b>整个赋值，或<br>-\\&nbsp;<b>将赋值右侧转换</b>为其自己的语句。<br>
there.is.own.replacewith.on.0.that.is.used.through.this.alias.please.replace.usages.first=通过此别名使用的 ''{0}'' 上有自己的 ''ReplaceWith''。请先替换用法。
these.declarations.cannot.be.transformed=无法转换这些声明\:
this.call.is.redundant.with=此调用与 ? 冗余。
this.property.conflicts.with.synthetic.extension.and.should.be.removed.or.renamed.to.avoid.breaking.code.by.future.changes.in.the.compiler=属性与合成扩展冲突，应移除或重命名，以避免未来版本的 Kotlin 编译器破坏代码
this.range.is.empty=此范围为空。
this.range.is.empty.did.you.mean.to.use.0=此范围为空。是否要使用 ''{0}''?
this.type.probably.can.be.changed.to.nullable=此类型或许可以更改为可为 null
this.when.is.simplifiable=此 'when' 可以简化
throwable.instance.0.is.not.thrown=未抛出 Throwable 实例 ''{0}''
titile.not.found=未找到
title.choose.destination.object=选择目标对象
title.choose.logger.factory.class=选择记录器工厂类
title.choose.use.site.target=选择 Use-Site 目标
title.done=完成
title.error=错误
title.import.layout=导入布局
title.inline.function=内联函数
title.inline.property=内联属性
title.inline.type.alias=内联类型别名
title.introduce.parameter.to.declaration=将形参引入声明
title.kdoc.for.abstracts=Abstract 的 KDoc
title.lateinit.var.overrides.lateinit.var='lateinit var' 重写 super 'lateinit var'
title.logger.factory.class.name=记录器工厂类名
title.logger.factory.method.name=记录器工厂方法名称
title.move.method=Move 方法
title.move.nested.classes.to.upper.level=将嵌套类移至上一级
title.packages.to.use.import.with=将 import 与 '*' 搭配使用的软件包
title.parameters=形参
title.rename.file=重命名文件
title.rename.file.to=将文件重命名为\:
title.rename.overloads.to=将重载重命名为\:
title.rename.warning=重命名警告
title.select.a.name.for.this.parameter=为 ''this@{0}'' 形参选择一个名称
title.select.target.code.block=选择目标代码块
title.success=成功
to.fully.qualified.name=到(完全限定名称)\:
tooltip.implements.function=在以下位置实现函数\:
tooltip.implements.property=在以下位置实现属性\:
tooltip.is.implemented.by=实现对象\:
tooltip.is.subclassed.by=被以下类子类化
tooltip.overrides.function=在以下位置重写函数\:
tooltip.overrides.property=在以下位置重写属性\:
top.level=顶层
two.comparisons.should.be.converted.to.a.range.check=两个比较应转换为范围检查
type.0.1.is.not.accessible.from.target.module=无法从目标模块访问{0, choice, 0\#类型|2\#类型} {1}
type.alias.0=类型别名“{0}”
type.arguments.will.be.lost.after.conversion.0=转换后类型实参将丢失\: {0}
type.parameter.0=类型形参“{0}”
type.parameter.can.have.0.variance=类型形参可以具有 ''{0}'' 差异
type.provider.anonymous.object=匿名对象
type.provider.no.expression.found=找不到表达式
type.provider.smart.cast.from=(从 {0} 智能转换)
type.provider.unknown.type=类型未知
unclear.precedence.of.binary.expression.inspection=表达式应当使用明确的圆括号
unclear.precedence.of.binary.expression.inspection.display.name=具有不同优先级的多个运算符
unclear.precedence.of.binary.expression.quickfix=添加明确的圆括号
unclear.precedence.of.binary.expression.report.even.obvious.cases.checkbox=即使是明显的案例也报告
unknown.types.title=未知类型
unlabeled.return.inside.lambda=lambda 中存在未标记的返回
unrecognized.reference.will.be.skipped.0=将跳过无法识别的引用\: {0}
unsupported.usage.0=不支持的用法\: {0}
until.can.be.replaced.with.rangeUntil.operator='until' 可被替换为 '..<' 运算符
unused.equals.expression=未使用的 equals 表达式
unused.import.directive=未使用的 import 指令
unused.return.value.of.a.function.with.lambda.expression.body=包含 lambda 表达式主体的函数未使用的返回值
unused.unary.operator=未使用的一元运算符
unwrap.else=展开 ''{0}'' 中的 else
unwrap.expression=解包 ''{0}''
unwrap.parameter=解包 ''{0}'' arg ''{1}''
update.indices=更新索引…
update.obsolete.label.syntax=更新过时的标签语法
usage.of.kotlin.internal.declaration.from.different.module=使用了来自不同模块的 Kotlin 内部声明
usage.of.redundant.or.deprecated.syntax.or.deprecated.symbols=使用了冗余或弃用的语法或弃用的符号
usage.provider.text.property.of.0={0}/{1}
usage.provider.text.unnamed=<未命名>
usages.of.nested.declarations.from.non.kotlin.code.won.t.be.processed=非 Kotlin 代码中的嵌套声明用法将不会被处理
usages.of.outer.class.instance.inside.declaration.0.won.t.be.processed=声明 ''{0}'' 内的外部类实例的用法将不会被处理
usages.of.outer.class.instance.inside.of.property.0.won.t.be.processed=不会处理属性 ''{0}'' 内外部类实例的用法
use.destructuring.declaration=使用析构声明
use.expression.body.instead.of.0=使用表达式主体，而不是{0}
use.inherited.visibility=使用继承的可见性
use.of.getter.method.instead.of.property.access.syntax=使用 getter 方法代替属性访问语法
use.of.non.const.kotlin.property.as.java.constant.is.incorrect.will.be.forbidden.in.1.4=将非常量 Kotlin 属性用作 Java 常量不正确。将在 1.4 中禁止
use.of.setter.method.instead.of.property.access.syntax=使用 setter 方法代替属性访问语法
use.property.access.syntax=使用属性访问语法
use.property.access.syntax.option.report.non.trivial.accessors=报告非普通的访问器
use.withindex.instead.of.manual.index.increment=使用 withIndex() 代替手动索引增量
uses.of.should.be.replaced.with.logging=<code>{0}</code> 的使用可能应当被替换为更可靠的日志调用
variable.0.is.assigned.to.itself=变量 ''{0}'' 已分配给自己
variable.declaration.could.be.inlined=变量声明可以内联
variable.declaration.could.be.moved.into.when=变量声明可以移至 'when' 中
variable.is.never.modified.and.can.be.declared.immutable.using.val=变量从未被修改，因此可以使用 'val' 声明
variable.is.never.read=变量 ''{0}'' 从未被读取
variable.is.same.as.0.and.should.be.inlined=变量与 ''{0}'' 相同且可以内联
variable.name.0.matches.the.name.of.a.different.component=变量名称 ''{0}'' 与其他组件的名称匹配
variable.used.only.in.following.return.and.should.be.inlined=变量仅用于以下返回且可以内联
vcs.code.author=Kotlin\: 显示代码作者的嵌入提示
version={version}
visibility=可见性(&V)\:
when.has.only.else.branch.and.should.be.simplified='when' 仅包含 'else' 分支且应简化
when.with.subject.should.be.used=应使用包含主体的 'when'
wrap.argument.with.parentheses=使用圆括号包装实参
wrap.element.with.0.call=使用 ''{0}()'' 调用包装元素
wrap.expression.in.parentheses=将表达式括在圆括号中
wrap.run.fix.text=转换为运行 { ... }
wrap.unary.operator.quickfix.text=使用 () 包装一元运算符和值
wrap.with=使用 [] 包装
wrap.with.array.literal=使用数组字面量包装
wrap.with.collection.literal.call=使用集合字面量调用包装
wrap.with.coroutine.scope.fix.family.name=使用 coroutineScope 包装
wrap.with.coroutine.scope.fix.text=使用 'coroutineScope { ... }' 包装函数体
wrap.with.coroutine.scope.fix.text2=使用 'coroutineScope { ... }' 包装调用
wrap.with.coroutine.scope.fix.text3=移除接收器并使用 'coroutineScope { ... }' 包装
wrap.with.let.call=使用 '?.let { ... }' 调用包装

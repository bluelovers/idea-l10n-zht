# suppress inspection "UnusedProperty" for whole file
makefile=Makefile

external.system.name=Makefile

group.Makefile.ToolsMenu.text=Makefile

analysis.critical.failure.check.settings.quick.fix={0}<br/><a href="{1}">检查设置</a>

analysis.compilation.command.message=编译命令。目录: ''{0}''。命令: ''{1}''
analysis.stored.compilation.command.message=存储的编译命令。文件: ''{0}''
analysis.build.target.message=构建目标 ''{0}''
analysis.external.module.message=外部模块: {0}
constructor.module.data.message=外部模块数据: {0}
command.cannot.parse.message=无法解析命令行: ''{0}''
command.no.input.file.parse.message=无法解析命令行: ''{0}''\n\
未指定输入文件
command.assembly.file.ignored.message=程序集文件: "{0}" 在目录中被忽略: "{1}"
command.link.command.message=命令被识别为链接器命令: ''{0}''
cache.used.info.message={0} 条编译{0,choice,1#命令|2#命令}已从缓存恢复
constructor.general.error.message=出错了

# used MakefileListenerArbiter.myAnalyzerListener
analysis.task.display.name=正在分析 makefile

analysis.scan.build.failure.general.message=无法生成 ``compilation_commands.json``
analysis.make.execution.exit.code.error=Make 执行失败，退出代码 = {0}
analysis.process.not.created.error.description=无法运行程序 ''{0}'' (在目录 ''{1}'' 中)
analysis.finished.status=Makefile 分析完成。成功 = {0}
analysis.finished.failure=Makefile 分析失败
analysis.finished.nothing.found.failure=未找到编译命令
analysis.targets.unexpected.stdout=意外 make 输出:\n\
{0}
analysis.targets.unexpected.stderr=意外 make 错误:\n\
{0}
analysis.untrackable.directory.change=无法跟踪目录变更: "{0}"

make.output.analysis.stage.display.name=正在收集项目信息
make.output.analysis.stage.failure.general.message.description=无法收集项目信息
make.output.analysis.stage.failure.general.message.details=无法收集项目信息
build.targets.analysis.stage.display.name=正在搜索构建目标
build.targets.analysis.stage.failure.general.message=无法找到构建目标
clean.analysis.stage.display.name=正在清理项目
clean.analysis.stage.failure.general.message=无法清理项目

# used in MakefileListenerArbiter.myConstructorListener
construct.task.display.name=正在配置项目

# used MakefileListenerArbiter.myAnalyzerListener
upload.task.display.name=上传项目
upload.failure.message=无法上传项目

clangd.disabled.title=clangd 已禁用
clangd.disabled.description=Makefile 项目构造函数需要 clangd 来解析编译命令。

remote.not.supported.title=不支持远程工具链
remote.not.supported.description=Makefile 项目不支持远程工具链<br/><a href="{0}">检查设置</a>
remote.not.supported.warning.message=不支持远程工具链


refresh.project.action.name=重新加载 Makefile 项目
refresh.project.action.description=强制重新加载链接的 Makefile 项目
clean.and.refresh.project.action.name=清理并重新加载 Makefile 项目
clean.and.refresh.project.action.description=清理项目并强制重新加载链接的 Makefile 项目

open.settings.action.name=Makefile 设置
open.settings.action.description=打开 Makefile 设置

unexpected.error.message=重新加载 Makefile 项目期间发生意外错误
resolve.cancelled.error.message=项目重新加载已被取消

configurable.empty.text=未检测到 Makefile 项目

makefile.analyzer.type.label=分析器
makefile.analyzer.output.parsing.type.label=正在解析 Make 输出
makefile.analyzer.compdb.type.label=正在构建编译数据库

compdb.generator.label=CompDB 生成器
compdb.generator.comment=仅支持 <a href="https://github.com/nickdiego/compiledb">compiledb</a>
compdb.generator.browser.title=选择 compiledb

reload.project.row.title=用于提取项目相关信息的 make 目标和实参
build.options.label=构建选项
switches.field.label=实参
build.target.label=构建目标
build.target.tooltip=将此字段留空会使用 `Makefile` 中指定的第一个目标。
clean.target.label=清理目标
clean.target.comment=加载前用于清理项目的 make 目标。

clean.confirmation.dialog.title=加载项目
clean.confirmation.clean.checkbox.text=清理项目
clean.confirmation.clean.target.field.text=创建要运行的目标
clean.confirmation.dialog.text=导入最适合干净项目。导入未被清理的项目时，重新加载过程会忽略包含最新目标的源文件。
clean.confirmation.reload.cancelled.message=已取消重新加载
show.clean.confirmation.dialog.action.text=显示“正在加载项目”对话框

toolchain.lookup.error=无法找到名称为 {0} 的请求工具链
make.process.start.error=无法启动 ''{0}''

external.target.empty.targets.field.error=目标不应为空。
external.target.invalid.targets.field.error=目标无效。
external.target.invalid.targets.field.configurationException=目标无效
external.target.build.target.comment=用于构建工件的 make 目标或目标列表
external.target.clean.target.comment=用于清理工件的 make 目标或目标列表

external.configuration.type.name=Make

build.task.name=构建 ''{0}''
build.task.name.empty.target=构建
clean.task.name=清理 ''{0}''
clean.task.name.empty.target=清理

makefile.build.before.run.no.runners.found=无法构建 ''{0}''\n\
检查您是否启用了 ''Makefile'' 插件

clion.native.app.configuration.type.name=Makefile 应用程序
clion.native.app.configuration.type.description=Makefile 应用程序配置

makefile.content.reader.directory.contains.no.makefiles=“{0}”不包含任何 Makefile。
makefile.content.reader.is.a.directory=“{0}”是目录。
makefile.content.reader.no.such.file.or.directory=“{0}”: 无此文件或目录。
makefile.content.reader.not.a.directory=“{0}”不是一个目录。

makefile.libtool.unknown.options=未知 libtool 选项: 解析实参期间 "{0}": "{1}"
makefile.libtool.mode.not.set=解析实参期间未设置 libtool 模式: "{0}"
makefile.libtool.unknown.mode=未知 libtool 模式: 解析实参期间 "{0}": "{1}"
makefile.libtool.unknown.tag=忽略未知的 libtool 标记: 解析实参期间 "{0}": "{1}"
makefile.libtool.unknown.warning.category=未知 libtool 警告类别: 解析实参期间 "{0}": "{1}"


error.no.environment=无环境

environment.to.local.conversion.failure=无法将 "{0}" 转换为本地路径; 本地目录为 "{1}": {2}

group.advanced.settings.makefile=Makefile
advanced.setting.makefile.output.analyzer.options=隐式 Make 输出分析器选项
advanced.setting.makefile.output.analyzer.options.description=默认设置为 '--just-print --print-directory --keep-going'。\n\
将这些设置为 '--print-directory --keep-going'，以便一步分析并构建项目。
advanced.setting.makefile.log.make.output.to.file=将 Make 输出保存到 ''${TMP}'' 目录下的日志文件 ''clion-make-*.{out,err}''
advanced.setting.makefile.mingw.use.posix.shell.parser=在 MinGW 工具链中使用 POSIX shell 解析器
advanced.setting.makefile.mingw.use.posix.shell.parser.description=默认为使用 Windows 批处理分析器
load.makefile.project.action.name=加载 Makefile 项目
preconfigure.project.commands.not.started=未启动预配置命令
preconfigure.project.commands.finished=已使用代码完成预配置命令: {0}
preconfigure.project.commands.io.error=由于 I/O 错误，预配置命令失败
preconfigure.project.commands.unknown.error=预配置命令失败: {0}
preconfigure.project.row.title=为生成 Makefile 而执行的预配置命令
preconfigure.project.commands.field.label=命令
preconfigure.project.commands.field.comment=允许 Shell 命令(在 Windows 中将使用 %ComSpec% 执行，在 UNIX 中将使用 ${SHELL} 执行)。
common.example=示例: {0}
environment.problem=环境问题
build.directory.label=构建目录
build.directory.browse.dialog.title=构建目录
build.directory.invalid=构建目录的路径无效。
build.directory.outside.project.directory=构建目录在项目目录之外。请务必根据需要添加路径映射。
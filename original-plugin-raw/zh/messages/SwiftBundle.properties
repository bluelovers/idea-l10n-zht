swift.name=Swift

### formatter #############################################################################################################################

### indent
code.style.indent.group.title.directives=指令

code.style.indent.multiline.strings=缩进多行字符串
code.style.indent.directives.as.code=遵循代码缩进
code.style.indent.directives.children=缩进子项

### spaces
code.style.spaces.group.title.colon=冒号周围
code.style.spaces.group.title.in.ternary=在三元条件运算中

code.style.spaces.before.method.parentheses=方法/函数声明括号
code.style.spaces.after.operator.in.function.declarations=函数声明中的运算符
code.style.spaces.before.method.call.parentheses=方法/函数调用括号
code.style.spaces.equality.operator=相等运算符 '=='
code.style.spaces.shift.operators=移位运算符(<<, >>)
code.style.spaces.around.range.operators=范围运算符(..., ..<)
code.style.spaces.closure.arrow=闭包箭头(->)
code.style.spaces.attribute.parameters=特性形参
code.style.spaces.within.literal.brackets=数组和字典文字中括号
code.style.spaces.within.method.parentheses=方法/函数声明括号
code.style.spaces.within.empty.method.parentheses=空方法/函数声明括号
code.style.spaces.within.method.call.parentheses=方法/函数调用括号
code.style.spaces.within.empty.method.call.parentheses=空方法/函数调用括号
code.style.spaces.attribute.parentheses=特性括号
code.style.spaces.before.argument.colon=方法/函数调用中的冒号之前
code.style.spaces.after.argument.colon=方法/函数调用中的冒号之后
code.style.spaces.before.type.colon=类型注解中的冒号之前
code.style.spaces.after.type.colon=类型注解中的冒号之后
code.style.spaces.before.superclass.colon=类型继承子句中的冒号之前
code.style.spaces.after.superclass.colon=类型继承子句中的冒号之后
code.style.spaces.before.dictionary.type.colon=字典类型中的冒号之前
code.style.spaces.after.dictionary.type.colon=字典类型中的冒号之后
code.style.spaces.before.dictionary.literal.colon=字典文字 'key:value' 对中的冒号之前
code.style.spaces.after.dictionary.literal.colon=字典文字 'key:value' 对中的冒号之后
code.style.spaces.within.string.interpolations=字符串插值
code.style.spaces.before.class.lbrace=类型声明左大括号
code.style.spaces.before.method.lbrace=方法/函数左大括号
code.style.spaces.before.semicolon=分号之前
code.style.spaces.after.semicolon=分号之后

### wrapping
code.style.wrapping.group.title.method.parameters=方法/函数声明参数
code.style.wrapping.group.title.method.arguments=方法/函数调用参数
code.style.wrapping.group.title.closure=闭包
code.style.wrapping.group.title.condition.clauses=条件子句
code.style.wrapping.group.title.if='if' 语句
code.style.wrapping.group.title.guard='guard' 语句
code.style.wrapping.group.title.do.while='repeat … while' 语句
code.style.wrapping.group.title.try='do' 语句
code.style.wrapping.group.title.superclass.list=基类和采用的协议列表
code.style.wrapping.group.title.ternary=三元条件运算
code.style.wrapping.group.title.variable.groups=变量组

code.style.wrapping.align.when.multiline=多行时对齐
code.style.wrapping.align.in.columns=列中对齐
code.style.wrapping.keep.control.statement.in.one.line=控制语句在同一行
code.style.wrapping.keep.simple.methods.in.one.line=方法和函数在同一行
code.style.wrapping.keep.simple.blocks.in.one.line=块和(尾随)闭包在同一行
code.style.wrapping.keep.simple.argument.blocks.in.one.line=闭包参数在同一行
code.style.wrapping.structures.in.one.line=空类型声明在同一行
code.style.wrapping.method.brace.placement=在方法和函数中
code.style.wrapping.array.literal=数组和字典文字
code.style.wrapping.array.new.line.after.left.bracket=在 '[' 后换行
code.style.wrapping.array.right.bracket.on.new.line=将 ']' 置于新行中
code.style.wrapping.classes.annotation=类型声明特性
code.style.wrapping.methods.annotation=方法特性
code.style.wrapping.fields.annotation=属性特性
code.style.wrapping.parameters.annotation=形参特性
code.style.wrapping.local.variables.annotation=局部变量特性
code.style.wrapping.closure.signature.on.next.line=多行时参数在新行中
code.style.wrapping.brace.placement.class.declaration=在类型声明中

### blank lines
code.style.blank.lines.around.class=在类型声明周围:
code.style.blank.lines.around.field.in.protocol=在协议中的属性周围:
code.style.blank.lines.around.field=围绕属性:
code.style.blank.lines.around.method.in.protocol=在协议中的方法/函数周围:
code.style.blank.lines.around.method=在方法/函数周围:
code.style.blank.lines.before.method.body=方法/函数主体之前:

### code generation
code.style.code.generation.tab.title=代码生成
code.style.code.generation.prefer.void=首选 Void 而不是 ()(&V)
code.style.code.generation.prefer.explicit.return=首选显式返回(&R)

### color scheme ##########################################################################################################################

color.settings.keyword=关键字和指令//关键字
color.settings.property=标识符//属性
color.settings.colon=大括号和运算符//冒号
color.settings.module.name=类型//模块名称
color.settings.protocol=类型//协议
color.settings.class=类型//类
color.settings.actor=类型//Actor
color.settings.type.alias=类型//类型别名
color.settings.struct.and.enum=类型//结构和枚举
color.settings.operator.sign=大括号和运算符//运算符
color.settings.enum.case.value=标识符//枚举 case 值
color.settings.self.and.super.keywords=关键字和指令//'self' 和 'super'
color.settings.function.and.method.declaration=函数//函数和方法声明
color.settings.function.and.method.call=函数//函数和方法调用
color.settings.nested.function.declaration=函数//嵌套函数声明
color.settings.nested.function.call=函数//嵌套函数调用
color.settings.external.parameter.name=标识符//外部形参名称
color.settings.inline.closure.parameter=标识符//内联闭包参数
color.settings.anonymous.closure.parameter=标识符//匿名闭包参数
color.settings.wildcard=标识符//通配符
color.settings.type.parameter=类型//泛型形参
color.settings.attribute.name=特性//特性名称
color.settings.attribute.argument=特性//特性实参
color.settings.inline.hints.type.hint=内联提示//类型提示
color.settings.inline.hints.error.hint=内联提示//错误提示
color.conditionally.non.compiled=关键字和指令//有条件的未编译代码
color.settings.directive=关键字和指令//指令

### navigation ############################################################################################################################

### goto super
goto.super.action=选择 {0}
goto.super.menu.action=超级 {0}(_U)
goto.super.location={0} ({1} 内)
goto.super.typealias=类型别名或关联类型
goto.super.class=类或协议
goto.base.type=基类型

goto.super.extension.of.0={0} 的扩展

### inheritance

inheritance.relation.overrides=重写 {0}
inheritance.relation.implements=实现 {0}

inheritance.relation.is.implemented=被实现
inheritance.relation.is.subclassed=被子类化
inheritance.relation.is.overridden=被重写

### find usages
find.usages.base.member.warning.title=警告

find.usages.base.member.warning.message.implements.method={0} 实现 {1} 中声明的方法\n\n要查找协议{3,choice,1#方法|2#方法}的用法吗?
find.usages.base.member.warning.message.implements.subscript={0} 实现 {1} 中声明的下标\n\n要查找协议{3,choice,1#下标|2#下标}的用法吗?
find.usages.base.member.warning.message.implements.property={0} 实现 {1} 中声明的属性\n\n要查找协议{3,choice,1#属性|2#属性}的用法吗?

find.usages.base.member.warning.message.override.method={0} 重写 {2} 中声明的方法\n\n要查找基本{3,choice,1#方法|2#方法}的用法吗?
find.usages.base.member.warning.message.override.subscript={0} 重写 {2} 中声明的下标\n\n要查找基本{3,choice,1#下标|2#下标}的用法吗?
find.usages.base.member.warning.message.override.property={0} 重写 {2} 中声明的属性\n\n要查找基本{3,choice,1#属性|2#属性}的用法吗?

find.usages.base.member.warning.message.override.implemented.method={0} 重写 {2} 中声明的方法，并实现 {1} 中声明的方法\n\n要查找基本和协议{3,choice,1#方法|2#方法}的用法吗?
find.usages.base.member.warning.message.override.implemented.subscript={0} 重写 {2} 中声明的下标，并实现 {1} 中声明的下标\n\n要查找基本和协议{3,choice,1#下标|2#下标}的用法吗?
find.usages.base.member.warning.message.override.implemented.property={0} 重写 {2} 中声明的属性，并实现 {1} 中声明的属性\n\n要查找基本和协议{3,choice,1#属性|2#属性}的用法吗?

find.usages.base.member.warning.message.default.implementation.method={0} 是对 {1} 中声明的方法的默认实现\n\n要查找协议{3, choice,1#方法|2#方法}的用法吗?
find.usages.base.member.warning.message.default.implementation.subscript={0} 是对 {1} 中声明的下标的默认实现\n\n要查找协议{3, choice,1#下标|2#下标}的用法吗?
find.usages.base.member.warning.message.default.implementation.property={0} 是对 {1} 中声明的属性的默认实现\n\n要查找协议{3, choice,1#属性|2#属性}的用法吗?

### usage kinds
usage.type.type.parameter=类型形参
usage.type.extension=扩展
usage.type.requirement=要求中的用法
usage.type.type.alias=类型别名
usage.type.argument.label=实参标签
usage.type.key.path=键路径表达式
usage.type.function.declaration=函数声明
usage.type.operator.declaration=运算符声明
usage.type.precedence.group.declaration=优先组声明
usage.type.raw.value=原始值

### call hierarchy
call.hierarchy.usage.in=''{0}'' 中的用法


### Actions ###############################################################################################################################

action.SwiftToggleGlobalTypeHints.text=显示 Swift 类型提示
action.SwiftToggleTypeHints.text=显示类型提示
action.SwiftToggleGlobalErrorHints.text=显示 Swift 错误提示
action.SwiftToggleErrorHints.text=显示错误提示
action.SwiftIntroduceClosureVariable.text=提取闭包…
action.SwiftExtractFunction.text=提取函数…
action.SwiftGenerateDocComment.text=生成文档注释
action.Swift.Generate.Init.text=初始值设定项
action.Swift.Generate.Init.description=生成初始值设定项
action.Swift.Generate.Description.text=description…
action.Swift.Generate.Description.description=生成描述
action.Swift.Generate.DebugDescription.text=debugDescription…
action.Swift.Generate.DebugDescription.description=生成 debugDescription
action.Swift.Generate.EqualsHashValue.text=equals 和 hash
action.Swift.Generate.EqualsHashValue.description=生成 equals 和 hash

### code generation #######################################################################################################################

### new file dialog
create.file.title=Swift 文件
create.file.dialog.title=新建 Swift 文件
create.file.description=创建新的 Swift 文件
create.file.action=创建 Swift 文件 {0}

create.file.or.type.title=Swift 文件/类型
create.file.or.type.description=创建新的 Swift 文件或类型

create.file.type.title=Swift 类型
create.file.type.dialog.title=新建 Swift 类型
create.file.type.dialog.title.with.kind=新建 Swift {0}
create.file.type.description=创建新的 Swift 类型

create.file.kind=种类(&K):
create.file.kind.file=文件

### override/implement
override.implement.nothing.to.override=没有要重写的内容
override.implement.nothing.to.implement=没有要实现的内容
override.implement.override.not.allowed=无法重写
override.implement.implement.not.allowed=无法实现
override.implement.show.members.to.implement.title=显示要实现的成员
override.implement.elements.to.implement.chooser.title=选择要实现的成员
override.implement.elements.to.override.chooser.title=选择要重写的成员
override.implement.elements.to.override.implement.chooser.title=选择要重写/实现的成员

override.implement.progress=正在处理要重写/实现的成员…
override.implement.show.optional.member=显示 1 个可选成员(&O)
override.implement.show.optional.members=显示 {0} 个可选成员(&O)
override.implement.show.no.optional.members=显示可选成员(无可选项)
override.implement.show.only.optional.members=显示可选成员(仅可选项)

### generate
generate.init.init.already.exists=初始值设定项已存在
generate.init.choose.super.init=选择超类初始值设定项
generate.init.choose.properties=选择要初始化的属性

generate.0.title=生成 {0}
generate.description.single.string.template=单字符串
generate.description.string.concatenation.template=包含串联的多个字符串(+)
generate.description.multi.string.template=多行字符串
generate.template.title=模板(&T):

generate.property.0.is.already.defined=已定义属性 ''{0}''。要将其删除并继续吗?
generate.method.0.is.already.defined=已定义方法 ''{0}''。要将其删除并继续吗?
generate.operator.function.0.is.already.defined=已定义运算符函数 ''{0}''。要将其删除并继续吗?
generate.method.0.and.property.1.are.already.defined=已定义方法 ''{0}'' 和属性 ''{1}''。要删除它们并继续吗?
generate.method.0.and.operator.function.1.are.already.defined=已定义方法 ''{0}'' 和运算符函数 ''{1}''。要删除它们并继续吗?
generate.property.0.and.operator.function.1.are.already.defined=已定义属性 ''{0}'' 和运算符函数 ''{1}''。要删除它们并继续吗?
generate.method.0.property.1.and.operator.function.2.are.already.defined=已定义方法 ''{0}''、属性 ''{1}'' 和运算符函数 ''{2}''。要删除它们并继续吗?

generate.equals.hash=equals 和 hash
generate.equals.hash.choose.in.0=选择要包含在 {0} 中的属性
generate.single.expression.equals.template=单表达式
generate.if.statements.equals.template=多个 if 语句

generate.cannot.generate.0.for.1=无法为 {1} 生成 {0}
generate.preparing.generation.title=正在准备生成…

### create from usage
create.from.usage.create.function.command=根据用法创建函数
create.from.usage.create.init.command=根据用法创建初始值设定项
create.from.usage.create.variable.command=根据用法创建变量
create.from.usage.create.type.command=创建新的 Swift 类型

create.from.usage.choose.target.type=选择目标类型
create.from.usage.location.new.file=新建文件
create.from.usage.location.this.file=此文件
create.from.usage.location.in=({0} 中)

### SourceKit #############################################################################################################################
sourcekit.fix.it=应用 Fix-it
sourcekit.inspections=SourceKit 检查

### syntax annotators #####################################################################################################################

syntax.error.hashbang.line.is.allowed.only.in.the.first.line.of.the.main.file=仅在主文件的第一行中允许 Hashbang 行
syntax.error.hashbang.line.is.allowed.only.in.the.first.line.of.the.file=仅在文件的第一行中允许 Hashbang 行
syntax.error.hashbang.line.is.allowed.only.in.the.main.file=仅在主文件中允许 Hashbang 行
syntax.error.unrecognized.platform.name.0=无法识别的平台名称 ''{0}''
syntax.error.missing.asterisk=必须使用 '*' 处理潜在的未来平台
syntax.error.missing.asterisk.fix=添加 '*'
syntax.error.duplicate.platform=已指定平台 ''{0}''
syntax.error.typealias.without.assignment=类型别名声明缺少赋值
syntax.error.variable.declaration.with.multiple.variables.cannot.have.explicit.getters.setters=具有多个变量的 'var' 声明不能具有显式 getter/setter
syntax.error.variable.declaration.with.multiple.variables.cannot.have.implicit.getter.clause=具有多个变量的 'var' 声明不能具有隐式 getter 子句
syntax.error.variable.declaration.with.multiple.variables.cannot.have.willset.didset.clause=具有多个变量的 'var' 声明不能具有 willSet/didSet 子句

### error handling
syntax.error.rethrows.is.not.allowed.in.function.type.elements=只有函数声明可以标记为 'rethrows'
syntax.error.rethrows.is.not.allowed.in.subscripts=下标中不允许 'rethrows'
syntax.error.rethrows.is.not.allowed.in.closures=闭包中不允许 'rethrows'
syntax.error.rethrows.function.must.take.a.throwing.function.argument='rethrows' 函数必须包含 throwing 函数实参
syntax.error.throws.is.not.allowed.in.subscripts=下标中不允许 'throws'
syntax.error.thrown.expression.type.0.does.not.conform.to.ErrorType=已引发的表达式类型 ''{0}'' 不符合 ''{1}''
syntax.error.try.cannot.appear.to.the.right='try' 不能出现在非赋值运算符右侧
syntax.error.try.cannot.appear.to.the.right.fix=向左移动 'try'

syntax.error.call.can.throw.in.property.initializer=调用可以抛出，但无法从属性初始值设定抛出错误
syntax.error.call.can.throw.in.default.argument=调用可以抛出，但无法从默认实参抛出错误
syntax.error.call.can.throw.not.marked.with.try=调用可以抛出，但未使用 'try' 标记
syntax.error.call.can.throw.not.marked.with.try.not.handled=调用可以抛出，但未使用 'try' 标记，并且错误未被处理
syntax.error.call.can.throw.not.marked.with.try.not.exhaustive=调用可以抛出，但未使用 'try' 标记，并且封闭 catch 不详尽
syntax.error.call.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=调用可以抛出，但在非抛出自动闭包中执行
syntax.error.call.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=调用可以抛出，但未使用 'try' 标记，并且在非抛出自动闭包中执行
syntax.error.operator.can.throw.not.marked.with.try=可能抛出运算符，但表达式未使用 'try' 进行标记

syntax.error.errors.are.not.handled=从此处引发的错误未被处理
syntax.error.errors.are.not.handled.not.exhaustive=从此处引发的错误未被处理，因为封闭 catch 不详尽
syntax.error.error.is.not.handled=错误未被处理，因为封闭函数未声明 'throws'
syntax.error.error.is.not.handled.not.exhaustive=错误未被处理，因为封闭 catch 不详尽

syntax.error.rethrows.function.can.only.throw.parameter.call=声明 'rethrows' 的函数只能在其参数引发时引发

### error handling fixing intentions
intention.mark.the.enclosing.function.as.throws=将 'throws' 添加到函数签名
intention.add.try.to.expression=将 'try' 添加到表达式
intention.suppress.call.error.with.try=使用 'try!' 禁止此错误
intention.surround.with.do.catch=使用 'do/catch' 环绕
intention.add.default.catch.clause=添加默认 'catch' 子句
intention.add.catch.clause=添加 'catch'
intention.replace.rethrows.with.throws=将 'rethrows' 替换为 'throws'

### syntax/logic error fixing intentions
intention.create.new.swift.type.in.a.new.file=在新文件中新建 Swift 类型
intention.create.new.swift.declaration=创建新的 Swift 声明

intention.create.kind.{0}.from.usage.{1}=创建 {0} ''{1}''
intention.create.type.from.usage.{0}=创建类型 ''{0}''
intention.create.initializer=创建初始值设定项
intention.create.location.in=(在 ''{0}'' 中)
intention.create.location.in.a.new.file=(在新文件中)
intention.create.location.in.type=(在 {0} ''{1}'' 中)
intention.create.location.nested.in.type=(嵌套在 {0} ''{1}'' 中)

intention.implement.members.error=类型 {0} 不符合 {1} {2}
intention.implement.members.implement.missing=实现 {0} 个缺少的{0, choice,1#成员|2#成员}

### access control
# suppress inspection "UnusedProperty"
intention.access.control.error.access=无法访问 {0}: 它在 {2} 中为 {1}
# suppress inspection "UnusedProperty"
intention.access.control.error.access.dynamic=无法访问 {0}: 动态成员下标在 {2} 中为 {1}
intention.access.control.error.override=无法重写 {0}: 它在 {2} 中为 {1}
intention.access.control.fix=在 {2} 中使{0} {1}
intention.access.control.remove.setter=从 {0} 移除 {1}

intention.wrong.return.type.error.void=void 函数中有意外的非 void 返回值
intention.wrong.return.type.fix=使 ''{0}'' 返回 ''{1}''

### inspections ###########################################################################################################################

inspection.redundant.attribute=冗余特性
inspection.redundant.attribute.error=''@{0}'' 冗余
inspection.redundant.attribute.fix=移除冗余 ''@{0}''
inspection.redundant.return=冗余 'return'
inspection.redundant.return.error='return' 冗余
inspection.redundant.return.fix=移除冗余 'return'
inspection.unnecessary.argument.list=闭包前的空实参圆括号
inspection.unnecessary.argument.list.error=实参圆括号不必要
inspection.unnecessary.argument.list.fix=移除不必要的实参圆括号
inspection.unnecessary.parentheses=不必要的圆括号
inspection.unnecessary.parentheses.error=圆括号不必要
inspection.unnecessary.parentheses.fix=移除不必要的圆括号
inspection.unnecessary.self=不必要的 'self'
inspection.unnecessary.self.error='self' 不必要
inspection.unnecessary.self.fix=移除不必要的 'self'
inspection.unnecessary.tuple.wrap=不必要的元组换行
inspection.unnecessary.tuple.wrap.error=单元素元组可被替换为类型
inspection.unnecessary.tuple.wrap.fix=将单元素元组替换为类型
inspection.missing.localization=缺少本地化
inspection.missing.localization.all.languages.only=仅报告所有语言中都缺少的本地化

### refactorings ##########################################################################################################################

error.cannot.perform.refactoring=无法执行重构
error.no.expression.found=找不到表达式

### refactoring intentions
intention.replace.if.with.guard=将 'if' 替换为 'guard'
intention.replace.guard.with.if=将 'guard' 替换为 'if'
intention.add.explicit.type=添加显式类型
intention.remove.explicit.type=移除显式类型
intention.add.explicit.qualifier=添加显式限定符
intention.convert.to.multiline.string=转换为多行字符串文字
intention.convert.to.string=转换为单行字符串文字
intention.convert.to.decimal=转换为十进制
intention.convert.to.hex=转换为十六进制
intention.convert.to.octal=转换为八进制
intention.convert.to.binary=转换为二进制
intention.convert.to.trailing.closure=转换为尾随闭包
intention.convert.to.closure.argument=转换为闭包实参
intention.increase.string.escape.level=提高字符串转义级别
intention.decrease.string.escape.level=降低字符串转义级别
intention.add.digit.separators=添加数字分隔符
intention.remove.digit.separators=移除数字分隔符
intention.split.into.separate.declarations=拆分为单独的声明
intention.split.declaration.and.assignment=拆分为声明和赋值
intention.join.declaration.and.assignment=联接声明和赋值
intention.merge.else.if=合并 'else if'
intention.split.else.if=拆分 'else if'
intention.invert.if.statement=反转 'if' 语句
intention.demorganslaw=德摩根定律
intention.demorganslaw.format=将 ''{0}'' 替换为 ''{1}''
intention.merge.nested.if=合并嵌套的 'if'
intention.split.nested.if=拆分为嵌套的 if
intention.merge.conditions=合并条件
intention.split.condition=拆分为单独的条件
intention.negate.comparison=求反比较
intention.negate.comparison.format=将 ''{0}'' 求反为 ''{1}''
intention.flip.binary.expression=翻转二元表达式
intention.flip.binary.expression.format=翻转 ''{0}''
intention.flip.comparison=翻转比较
intention.flip.comparison.format=将 ''{0}'' 翻转为 ''{1}''
intention.localize.string=本地化字符串
intention.localize.string.title.case=本地化字符串

### extract method
extract.method.title.method=提取方法
extract.method.title.function=提取函数
extract.method.title.closure=提取闭包
extract.method.error.should.represent.expr.or.statements=所选块应代表一组语句或表达式
extract.method.error.cannot.determine.expr.type=无法确定所选表达式的类型
extract.method.error.cannot.extract.expr.with.var.declarations=无法从包含变量声明的表达式中提取
extract.method.error.cannot.determine.function.result.type=无法确定函数结果的类型
extract.method.error.multiple.exit.points=所选代码段有多个出口点。
extract.method.error.cannot.extract.with.returns=无法提取代码段内包含返回指令的函数
extract.method.error.cannot.determine.parameters.type=无法确定形参类型
extract.method.error.fragment.should.be.inside.code.block=所选代码段应在代码块内
extract.method.error.result.builder.block=无法提取结果构建器闭包中的函数
extract.method.function.0.will.conflict.with.1.2=函数 ''{0}'' 将与 {1} {2} 冲突
extract.method.method.0.will.conflict.with.1.in.2.3=方法 ''{0}'' 将与{2} ''{3}'' 中的 {1} 冲突
extract.method.at.least.two.parameters.have.name.0=至少两个形参的名称为 ''{0}''
extract.method.variable.0.will.no.longer.be.accessible=变量 ''{0}'' 重构后不再可访问
extract.method.cannot.extract.mutable.value=无法提取可变值
extract.method.0.1.will.be.shadowed.by.2.1={0} ''{1}'' 将被 {2} ''{1}'' 遮盖

### introduce variable
introduce.variable.declare.with.var=使用 var 声明(&V)
introduce.variable.specify.type.explicitly=显式指定类型(&T)
introduce.variable.expression.will.be.ambiguous.without.explicit.type=表达式将不明确，<br/>无显式类型

### renaming
rename.inheritors=重命名继承者
rename.inheritors.to=将继承者重命名为:
rename.inheritor.entity.name=继承者

rename.init.is.not.supported=不支持重命名 Swift 初始值设定项
rename.self.is.not.supported=不支持重命名自形参
rename.title=Swift 名称重命名

rename.related.dialog.title=重命名相关声明
rename.related.dialog.description=将具有以下名称的相关声明重命名为:
rename.related.entity.name=相关声明

rename.containing.file.dialog.title=重命名包含文件
rename.containing.file.dialog.description=将具有以下名称的包含文件重命名为:
rename.containing.file.entity.name=Include 文件

rename.error.message.renaming.swift.member.elements.in.objective.c.code.is.not.supported=不支持在 Objective-C 代码中重命名 Swift 成员元素
rename.error.title=Swift - 重命名
rename.error.dynamic.called.values=无法重命名动态调用值

### Change signature
change.signature.initializer.will.conflict.with.0.in.1.2=初始值设定项将与 {1} ''{2}'' 中的 {0} 冲突
change.signature.subscript.will.conflict.with.0.in.1.2=下标将与 {1} ''{2}'' 中的 {0} 冲突
change.signature.dialog.title=更改签名
change.info.return.type.label=返回类型:
change.info.name.label=名称:
change.info.internal.name.label=内部名称:
change.info.type.label=类型:
change.info.optional.label=可选:
change.info.default.value.label=默认值:
change.signature.target.not.found=文本光标应位于函数、初始值设定项或下标处
change.signature.processed.elements.header=要更改签名的元素
change.signature.title=更改签名
change.signature.0.1.will.no.longer.be.visible.from.overriding.0.in.2.3={0} ''{1}'' 在{2} ''{3}'' 的重写{0}中将不再可见
change.signature.0.1.with.2.visibility.wont.be.accessible.from.3.4=可见性为“{2}”的{0} ''{1}'' 将无法从{3} ''{4}'' 访问
change.info.async.throws.label=async/throws:
change.info.throw.kind.label=抛出种类:
change.signature.0.can.throw.but.thrown.errors.are.not.handled=''{0}'' 可以抛出，但是没有处理抛出的错误
change.signature.0.is.async.but.not.awaited=''{0}'' 等待调用，但未被标记为 async

change.info.dialog.invalid.function.name.0=无效函数名称: ''{0}''
change.info.dialog.invalid.parameter.name.0=无效形参名称: ''{0}''
change.info.dialog.invalid.parameter.internal.name.0=无效形参内部名称: ''{0}''
change.info.dialog.no.function.name.specified=未指定函数名称
change.info.dialog.parameter.after.variadic.should.have.nonempty.name=可变形参后面的形参应为非空名称
change.info.dialog.rethrows.should.have.throwing.parameter='rethrows' 函数必须有一个抛出函数形参
change.info.default.value.code.comment="默认值 = {0}"

### super declaration refactoring
refactor.base.declaration=重构基本{0,choice,1#声明|2#声明}
refactor.only.current.declaration=仅重构当前声明
refactor.0.overrides.method.of.1={0} 重写 {1} 的方法
refactor.0.overrides.property.of.1={0} 重写 {1} 的属性
refactor.0.overrides.initializer.of.1={0} 重写 {1} 的初始值设定项
refactor.0.overrides.subscript.of.1={0} 重写 {1} 的下标
refactor.0.overrides.associated.type.of.1={0} 重写 {1} 的关联类型
refactor.0.overrides.declaration.in.1={0} 重写 {1} 中的声明
### other #################################################################################################################################

### documentation
doc.comments.enable.markdown=要想文档注释格式整洁，请启用 Markdown 插件

### appearance
editor.appearance.type.hints=显示 Swift 类型提示
editor.appearance.error.hints=显示 Swift 错误提示

### actions
action.Swift.ShowSwiftIDETest.text=运行 Swift IDE 报告

### template contexts
context.declaration=声明
context.statement=语句

color.settings.argument.label=标识符//实参标签
color.settings.tuple.label=标识符//元组标签
color.settings.tuple.type.label=标识符//元组类型标签
command.name.extract.function=提取函数
color.settings.directive.condition=关键字和指令//指令条件
color.settings.directive.flag=关键字和指令//指令标志
intention.category.swift=Swift
syntax.error.subscript.can.throw.in.property.initializer=下标访问可以抛出，但无法从属性初始值设定项抛出错误
syntax.error.property.can.throw.in.property.initializer=属性访问可以抛出，但无法从属性初始值设定项抛出错误
syntax.error.interpolation.can.throw.in.property.initializer=插值可以抛出，但无法从属性初始值设定项抛出错误
syntax.error.subscript.can.throw.in.default.argument=下标访问可以抛出，但无法从默认实参抛出错误
syntax.error.property.can.throw.in.default.argument=属性访问可以抛出，但无法从默认实参抛出错误
syntax.error.interpolation.can.throw.in.default.argument=插值可以抛出，但无法从默认实参抛出错误
syntax.error.subscript.can.throw.not.marked.with.try=下标访问可以抛出，但未使用 'try' 标记
syntax.error.property.can.throw.not.marked.with.try=属性访问可以抛出，但未使用 'try' 标记
syntax.error.interpolation.can.throw.not.marked.with.try=插值可以抛出，但未使用 'try' 标记
syntax.error.subscript.can.throw.not.marked.with.try.not.handled=下标访问可以抛出，但未使用 'try' 标记，并且错误未被处理
syntax.error.property.can.throw.not.marked.with.try.not.handled=属性访问可以抛出，但未使用 'try' 标记，并且错误未被处理
syntax.error.interpolation.can.throw.not.marked.with.try.not.handled=插值可以抛出，但未使用 'try' 标记，并且错误未被处理
syntax.error.subscript.can.throw.not.marked.with.try.not.exhaustive=下标访问可以抛出，但未使用 'try' 标记，并且封闭 catch 不详尽
syntax.error.property.can.throw.not.marked.with.try.not.exhaustive=属性访问可以抛出，但未使用 'try' 标记，并且封闭 catch 不详尽
syntax.error.interpolation.can.throw.not.marked.with.try.not.exhaustive=插值可以抛出，但未使用 'try' 标记，并且封闭 catch 不详尽
syntax.error.subscript.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=下标访问可以抛出，但在非抛出自动闭包中执行
syntax.error.property.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=属性访问可以抛出，但在非抛出自动闭包中执行
syntax.error.interpolation.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=插值可以抛出，但在非抛出自动闭包中执行
syntax.error.subscript.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=下标访问可以抛出，但未使用 'try' 标记，并且在非抛出自动闭包中执行
syntax.error.property.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=属性访问可以抛出，但未使用 'try' 标记，并且在非抛出自动闭包中执行
syntax.error.interpolation.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=插值可以抛出，但未使用 'try' 标记，并且在非抛出自动闭包中执行
syntax.error.call.rethrows.function.can.only.throw.parameter.call.not.handled=调用可以引发，但错误未被处理; 声明 'rethrows' 的函数只能在其参数引发时引发
syntax.error.subscript.rethrows.function.can.only.throw.parameter.call.not.handled=下标访问可以抛出，但错误未被处理；声明 'rethrows' 的函数只能在其形参抛出时抛出
syntax.error.property.rethrows.function.can.only.throw.parameter.call.not.handled=属性访问可以抛出，但错误未被处理；声明 'rethrows' 的函数只能在其形参抛出时抛出
syntax.error.interpolation.rethrows.function.can.only.throw.parameter.call.not.handled=插值可以抛出，但错误未被处理；声明 'rethrows' 的函数只能在其形参抛出时抛出
syntax.error.call.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=调用可以引发，但未使用 'try' 标记，错误未被处理; 声明 'rethrows' 的函数只能在其参数引发时引发
syntax.error.subscript.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=下标访问可以抛出，但未使用 'try' 标记，错误未被处理；声明 'rethrows' 的函数只能在其形参抛出时抛出
syntax.error.property.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=属性访问可以抛出，但未使用 'try' 标记，错误未被处理；声明 'rethrows' 的函数只能在其形参抛出时抛出
syntax.error.interpolation.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=插值可以抛出，但未使用 'try' 标记，错误未被处理；声明 'rethrows' 的函数只能在其形参抛出时抛出
searching.for.implementations=正在搜索实现…
searching.for.subclasses=正在搜索子类…
searching.for.overriders=正在搜索重写者…
inspection.missing.doc.comment.parameter.item=不匹配的 doc 注释和函数签名
inspection.missing.doc.comment.parameter.item.error=doc 注释中未描述形参 {0}
inspection.missing.doc.comment.parameter.item.fix=更新 doc 注释
intention.unwrap.with.if.let=使用 'if let' 解开 Optional
intention.unwrap.with.guard.let=使用 'guard let' 解开 Optional
code.style.indent.method.chain=链式方法缩进:
syntax.error.iteration.can.throw.not.marked.with.try=迭代可以抛出，但未使用 'try' 标记
syntax.error.iteration.can.throw.not.marked.with.try.not.handled=迭代可以抛出，但未使用 'try' 标记，并且错误未被处理
syntax.error.iteration.can.throw.not.marked.with.try.not.exhaustive=迭代可以抛出，但未使用 'try' 标记，并且封闭 catch 不详尽
intention.add.try.to.iteration=将 'try' 添加到迭代
code.style.wrapping.method.chain.dot.on.new.line='.' 在新行
intention.generate.documentation.comment=添加文档注释
color.settings.associated.type=类型//关联类型
intention.swift.module.info=显示模块信息
goto.class.kind=类型
goto.class.kinds.title=类型
code.style.wrapping.guard.else='否则'
code.style.wrapping.guard.else.always=始终换行
code.style.wrapping.guard.else.wrapped=有条件换行
code.style.wrapping.guard.else.never=不换行
action.Swift.ExtractFunction.text=提取函数…
action.Swift.FormatFileWithSwiftFormat.text=使用 Swift Format 重新设置代码格式
action.Swift.Generate.DebugDescription.description=生成 debugDescription
action.Swift.Generate.DebugDescription.text=debugDescription…
action.Swift.Generate.Description.description=生成描述
action.Swift.Generate.Description.text=description…
action.Swift.Generate.EqualsHashValue.description=生成 equals 和 hash
action.Swift.Generate.EqualsHashValue.text=equals 和 hash
action.Swift.Generate.Init.description=生成初始值设定项
action.Swift.Generate.Init.text=初始值设定项
action.Swift.GenerateDocComment.text=生成文档注释
action.Swift.IntroduceClosureVariable.text=提取闭包…
action.Swift.ShowSwiftIDETest.text=运行 Swift IDE 报告
action.Swift.SwiftFormatCreateConfigFileAction.text=创建 Swift Format 配置文件
action.Swift.ToggleErrorHints.text=显示错误提示
action.Swift.ToggleGlobalErrorHints.text=显示 Swift 错误提示
action.Swift.ToggleGlobalTypeHints.text=显示 Swift 类型提示
action.Swift.ToggleTypeHints.text=显示类型提示
auto.import.command.name=自动导入模块
auto.import.completion.presentation.tail.from.0=\ ({0})
auto.import.settings.checkbox.sort=对 import 排序
auto.import.settings.import.symbol=自动导入具体符号
auto.import.settings.import.symbol.help=自动导入符号时，最好添加符号本身的 import，而不是导入声明该符号的整个模块
auto.import.settings.optimize.non.module=优化非模块 import
auto.import.settings.optimize.non.module.help=在优化 import 时，将函数、结构、类等的显式 import 替换为其父模块的 import
call.hierarchy.usage.in=''{0}'' 中的用法
change.info.async.throws.label=async/throws\:
change.info.default.value.code.comment="默认值 \= {0}"
change.info.default.value.label=默认值\:
change.info.dialog.invalid.function.name.0=无效函数名称\: ''{0}''
change.info.dialog.invalid.parameter.internal.name.0=无效形参内部名称\: ''{0}''
change.info.dialog.invalid.parameter.name.0=无效形参名称\: ''{0}''
change.info.dialog.no.function.name.specified=未指定函数名称
change.info.dialog.parameter.after.variadic.should.have.nonempty.name=可变形参后面的形参应为非空名称
change.info.dialog.rethrows.should.have.throwing.parameter='rethrows' 函数必须有一个抛出函数形参
change.info.internal.name.label=内部名称\:
change.info.name.label=名称\:
change.info.optional.label=可选\:
change.info.options.label=选项
change.info.return.type.label=返回值类型\:
change.info.type.label=类型\:
change.signature.0.1.will.no.longer.be.visible.from.overriding.0.in.2.3={0} ''{1}'' 在{2} ''{3}'' 的重写{0}中将不再可见
change.signature.0.1.with.2.visibility.wont.be.accessible.from.3.4=可见性为“{2}”的{0} ''{1}'' 将无法从{3} ''{4}'' 访问
change.signature.0.can.throw.but.thrown.errors.are.not.handled=''{0}'' 可以抛出，但是没有处理抛出的错误
change.signature.0.is.async.but.not.awaited=''{0}'' 等待调用，但未被标记为 async
change.signature.dialog.title=更改签名
change.signature.initializer.will.conflict.with.0.in.1.2=初始值设定项将与 {1} ''{2}'' 中的 {0} 冲突
change.signature.processed.elements.header=要更改签名的元素
change.signature.subscript.will.conflict.with.0.in.1.2=下标将与 {1} ''{2}'' 中的 {0} 冲突
change.signature.target.not.found=文本光标应位于函数、初始值设定项或下标处
change.signature.title=更改签名
code.style.blank.lines.around.class=在类型声明周围\:
code.style.blank.lines.around.field=围绕属性\:
code.style.blank.lines.around.field.in.protocol=在协议中的属性周围\:
code.style.blank.lines.around.method=在方法/函数周围\:
code.style.blank.lines.around.method.in.protocol=在协议中的方法/函数周围\:
code.style.blank.lines.before.method.body=方法/函数主体之前\:
code.style.code.generation.doc.comment.style=首选块(/** */)而不是行(///)文档注释
code.style.code.generation.doc.comment.tag.delimiter=列表条目分隔符\:
code.style.code.generation.prefer.explicit.return=首选显式返回(&R)
code.style.code.generation.prefer.void=首选 Void 而不是 ()(&V)
code.style.code.generation.tab.title=代码生成
code.style.indent.directives.as.code=遵循代码缩进
code.style.indent.directives.children=缩进子项
code.style.indent.group.title.directives=指令
code.style.indent.method.chain=链式方法缩进\:
code.style.indent.multiline.string.or.regex=缩进多行字符串或正则表达式
code.style.spaces.after.argument.colon=方法/函数调用中的冒号之后
code.style.spaces.after.dictionary.literal.colon=字典字面量 'key\:value' 对中的冒号之后
code.style.spaces.after.dictionary.type.colon=字典类型中的冒号之后
code.style.spaces.after.operator.in.function.declarations=函数声明中的运算符
code.style.spaces.after.semicolon=分号之后
code.style.spaces.after.superclass.colon=类型继承子句中的冒号之后
code.style.spaces.after.type.colon=类型注解中的冒号之后
code.style.spaces.around.range.operators=范围运算符(...、..<)
code.style.spaces.attribute.parameters=特性形参
code.style.spaces.attribute.parentheses=特性圆括号
code.style.spaces.before.argument.colon=方法/函数调用中的冒号之前
code.style.spaces.before.class.lbrace=类型声明左大括号
code.style.spaces.before.dictionary.literal.colon=字典字面量 'key\:value' 对中的冒号之前
code.style.spaces.before.dictionary.type.colon=字典类型中的冒号之前
code.style.spaces.before.method.call.parentheses=方法/函数调用圆括号
code.style.spaces.before.method.lbrace=方法/函数左大括号
code.style.spaces.before.method.parentheses=方法/函数声明圆括号
code.style.spaces.before.semicolon=分号之前
code.style.spaces.before.superclass.colon=类型继承子句中的冒号之前
code.style.spaces.before.type.colon=类型注解中的冒号之前
code.style.spaces.closure.arrow=闭包箭头(->)
code.style.spaces.equality.operator=相等运算符 '\=\='
code.style.spaces.group.title.colon=冒号周围
code.style.spaces.group.title.in.ternary=在三元条件运算中
code.style.spaces.shift.operators=移位运算符(<<, >>)
code.style.spaces.within.empty.method.call.parentheses=空方法/函数调用圆括号
code.style.spaces.within.empty.method.parentheses=空方法/函数声明圆括号
code.style.spaces.within.literal.brackets=数组和字典字面量中括号
code.style.spaces.within.method.call.parentheses=方法/函数调用圆括号
code.style.spaces.within.method.parentheses=方法/函数声明圆括号
code.style.spaces.within.string.interpolations=字符串内插
code.style.wrapping.align.in.columns=在列中对齐
code.style.wrapping.align.when.multiline=多行时对齐
code.style.wrapping.array.literal=数组和字典字面量
code.style.wrapping.array.new.line.after.left.bracket=在 '[' 后换行
code.style.wrapping.array.right.bracket.on.new.line=将 ']' 置于新行中
code.style.wrapping.brace.placement.class.declaration=在类型声明中
code.style.wrapping.classes.annotation=类型声明特性
code.style.wrapping.closure.signature.on.next.line=多行时形参在新行中
code.style.wrapping.fields.annotation=属性特性
code.style.wrapping.group.title.closure=闭包
code.style.wrapping.group.title.condition.clauses=条件子句
code.style.wrapping.group.title.do.while='repeat … while' 语句
code.style.wrapping.group.title.guard='guard' 语句
code.style.wrapping.group.title.if='if' 语句
code.style.wrapping.group.title.method.arguments=方法/函数调用实参
code.style.wrapping.group.title.method.parameters=方法/函数声明形参
code.style.wrapping.group.title.superclass.list=基类和采用的协议列表
code.style.wrapping.group.title.ternary=三元条件运算
code.style.wrapping.group.title.try='do' 语句
code.style.wrapping.group.title.variable.groups=变量组
code.style.wrapping.guard.else='否则'
code.style.wrapping.guard.else.always=始终换行
code.style.wrapping.guard.else.never=不换行
code.style.wrapping.guard.else.wrapped=有条件换行
code.style.wrapping.keep.control.statement.in.one.line=控制语句在同一行
code.style.wrapping.keep.simple.argument.blocks.in.one.line=闭包实参在同一行
code.style.wrapping.keep.simple.blocks.in.one.line=块和(尾随)闭包在同一行
code.style.wrapping.keep.simple.methods.in.one.line=方法和函数在同一行
code.style.wrapping.local.variables.annotation=局部变量特性
code.style.wrapping.method.brace.placement=在方法和函数中
code.style.wrapping.method.chain.dot.on.new.line='.' 在新行
code.style.wrapping.methods.annotation=方法特性
code.style.wrapping.parameters.annotation=形参特性
code.style.wrapping.structures.in.one.line=空类型声明在同一行
color.conditionally.not.compiled=关键字和指令//有条件的未编译代码
color.settings.actor=类型//Actor
color.settings.anonymous.closure.parameter=标识符//匿名闭包形参
color.settings.argument.label=标识符//实参标签
color.settings.associated.type=类型//关联类型
color.settings.attribute.argument=特性//特性实参
color.settings.attribute.name=特性//特性名称
color.settings.class=类型//类
color.settings.colon=大括号和运算符//冒号
color.settings.directive=关键字和指令//指令
color.settings.directive.condition=关键字和指令//指令条件
color.settings.directive.flag=关键字和指令//指令标志
color.settings.enum.case.value=标识符//枚举 case 值
color.settings.external.parameter.name=标识符//外部形参名称
color.settings.function.and.method.call=函数//函数和方法调用
color.settings.function.and.method.declaration=函数//函数和方法声明
color.settings.inline.closure.parameter=标识符//内联闭包形参
color.settings.inline.hints.error.hint=内联提示//错误提示
color.settings.inline.hints.type.hint=内联提示//类型提示
color.settings.keyword=关键字和指令//关键字
color.settings.module.name=类型//模块名称
color.settings.nested.function.call=函数//嵌套函数调用
color.settings.nested.function.declaration=函数//嵌套函数声明
color.settings.operator.sign=大括号和运算符//运算符
color.settings.property=标识符//属性
color.settings.protocol=类型//协议
color.settings.self.and.super.keywords=关键字和指令//'self' 和 'super'
color.settings.struct.and.enum=类型//结构体和枚举
color.settings.tuple.label=标识符//元组标签
color.settings.tuple.type.label=标识符//元组类型标签
color.settings.type.alias=类型//类型别名
color.settings.type.parameter=类型//泛型形参
color.settings.wildcard=标识符//通配符
command.name.extract.function=提取函数
context.declaration=声明
context.statement=语句
create.file.description=创建新的 Swift 文件
create.file.dialog.title=新建 Swift 文件
create.file.kind=种类(&K)\:
create.file.kind.file=文件
create.file.title=Swift 文件
create.file.type.description=创建新的 Swift 类型
create.file.type.dialog.title=新建 Swift 类型
create.file.type.dialog.title.with.kind=新建 Swift {0}
create.file.type.title=Swift 类型
create.from.usage.choose.target.type=选择目标类型
create.from.usage.create.function.command=根据用法创建函数
create.from.usage.create.init.command=根据用法创建初始值设定项
create.from.usage.create.type.command=创建新的 Swift 类型
create.from.usage.create.variable.command=根据用法创建变量
create.from.usage.location.in=({0} 中)
create.from.usage.location.new.file=新建文件
create.from.usage.location.this.file=此文件
doc.comments.enable.markdown=启用 Markdown 插件以设置文档注释的格式
editor.appearance.error.hints=显示 Swift 错误提示
editor.appearance.type.hints=显示 Swift 类型提示
error.cannot.perform.refactoring=无法执行重构
error.no.expression.found=找不到表达式
extract.method.0.1.will.be.shadowed.by.2.1={0} ''{1}'' 将被 {2} ''{1}'' 遮盖
extract.method.at.least.two.parameters.have.name.0=至少两个形参的名称为 ''{0}''
extract.method.cannot.extract.mutable.value=无法提取可变值
extract.method.error.cannot.determine.expr.type=无法确定所选表达式的类型
extract.method.error.cannot.determine.function.result.type=无法确定函数结果的类型
extract.method.error.cannot.determine.parameters.type=无法确定形参类型
extract.method.error.cannot.extract.expr.with.var.declarations=无法从包含变量声明的表达式中提取
extract.method.error.cannot.extract.with.returns=无法提取代码段内包含返回指令的函数
extract.method.error.fragment.should.be.inside.code.block=所选代码段应在代码块内
extract.method.error.multiple.exit.points=所选代码段有多个出口点。
extract.method.error.result.builder.block=无法提取结果构建器闭包中的函数
extract.method.error.should.represent.expr.or.statements=所选块应代表一组语句或表达式
extract.method.function.0.will.conflict.with.1.2=函数 ''{0}'' 将与 {1} {2} 冲突
extract.method.method.0.will.conflict.with.1.in.2.3=方法 ''{0}'' 将与{2} ''{3}'' 中的 {1} 冲突
extract.method.title.closure=提取闭包
extract.method.title.function=提取函数
extract.method.title.method=提取方法
extract.method.variable.0.will.no.longer.be.accessible=变量 ''{0}'' 重构后不再可访问
find.usages.base.member.warning.message.default.implementation.method={0} 是对 {1} 中声明的方法的默认实现\n\n是否要查找协议{3, choice,1\#方法|2\#方法}的用法?
find.usages.base.member.warning.message.default.implementation.property={0} 是对 {1} 中声明的属性的默认实现\n\n是否要查找协议{3, choice,1\#属性|2\#属性}的用法?
find.usages.base.member.warning.message.default.implementation.subscript={0} 是对 {1} 中声明的下标的默认实现\n\n是否要查找协议{3, choice,1\#下标|2\#下标}的用法?
find.usages.base.member.warning.message.implements.method={0} 实现 {1} 中声明的方法\n\n是否要查找协议{3,choice,1\#方法|2\#方法}的用法?
find.usages.base.member.warning.message.implements.property={0} 实现 {1} 中声明的属性\n\n是否要查找协议{3,choice,1\#属性|2\#属性}的用法?
find.usages.base.member.warning.message.implements.subscript={0} 实现 {1} 中声明的下标\n\n是否要查找协议{3,choice,1\#下标|2\#下标}的用法?
find.usages.base.member.warning.message.override.implemented.method={0} 重写 {2} 中声明的方法，并实现 {1} 中声明的方法\n\n是否要查找基和协议{3,choice,1\#方法|2\#方法}的用法?
find.usages.base.member.warning.message.override.implemented.property={0} 重写 {2} 中声明的属性，并实现 {1} 中声明的属性\n\n是否要查找基和协议{3,choice,1\#属性|2\#属性}的用法?
find.usages.base.member.warning.message.override.implemented.subscript={0} 重写 {2} 中声明的下标，并实现 {1} 中声明的下标\n\n是否要查找基和协议{3,choice,1\#下标|2\#下标}的用法?
find.usages.base.member.warning.message.override.method={0} 重写 {2} 中声明的方法\n\n是否要查找基{3,choice,1\#方法|2\#方法}的用法?
find.usages.base.member.warning.message.override.property={0} 重写 {2} 中声明的属性\n\n是否要查找基{3,choice,1\#属性|2\#属性}的用法?
find.usages.base.member.warning.message.override.subscript={0} 重写 {2} 中声明的下标\n\n是否要查找基{3,choice,1\#下标|2\#下标}的用法?
find.usages.base.member.warning.title=警告
find.usages.option.search.in.not.compiled.code=显示有条件的未编译代码中的潜在用法
generate.0.title=生成 {0}
generate.cannot.generate.0.for.1=无法为 {1} 生成 {0}
generate.description.multi.string.template=多行字符串
generate.description.single.string.template=单字符串
generate.description.string.concatenation.template=包含串联的多个字符串(+)
generate.equals.hash=equals 和 hash
generate.equals.hash.choose.in.0=选择要包含在 {0} 中的属性
generate.if.statements.equals.template=多个 if 语句
generate.init.choose.properties=选择要初始化的属性
generate.init.choose.super.init=选择超类初始值设定项
generate.init.init.already.exists=初始值设定项已存在
generate.method.0.and.operator.function.1.are.already.defined=已定义方法 ''{0}'' 和运算符函数 ''{1}''。是否要将其删除并继续?
generate.method.0.and.property.1.are.already.defined=已定义方法 ''{0}'' 和属性 ''{1}''。是否要将其删除并继续?
generate.method.0.is.already.defined=已定义方法 ''{0}''。是否要将其删除并继续?
generate.method.0.property.1.and.operator.function.2.are.already.defined=已定义方法 ''{0}''、属性 ''{1}'' 和运算符函数 ''{2}''。是否要将其删除并继续?
generate.operator.function.0.is.already.defined=已定义运算符函数 ''{0}''。是否要将其删除并继续?
generate.preparing.generation.title=正在准备生成…
generate.property.0.and.operator.function.1.are.already.defined=已定义属性 ''{0}'' 和运算符函数 ''{1}''。是否要将其删除并继续?
generate.property.0.is.already.defined=已定义属性 ''{0}''。是否要将其删除并继续?
generate.single.expression.equals.template=单表达式
generate.template.title=模板(&T)\:
got.it.no.refactoring.in.not.compiled.code.header=重构操作不可用
got.it.no.refactoring.in.not.compiled.code.message=重构操作在有条件的未编译代码中不可用。切换到不同的解析上下文以启用周围的 `\#if directive` 分支。
got.it.search.not.compiled.code.header=有条件的未编译代码中的用法
got.it.search.not.compiled.code.message=可以从“重命名”对话框启用在有条件的未编译代码中搜索用法。要显示“重命名”对话框，请再次按 {0}。
goto.base.type=基类型
goto.class.kind=类型
goto.class.kinds.title=类型
goto.super.action=选择 {0}
goto.super.class=类或协议
goto.super.extension.of.0={0} 的扩展
goto.super.location={0} ({1} 内)
goto.super.menu.action=超级 {0}(_U)
goto.super.typealias=类型别名或关联类型
inheritance.relation.implements=实现 {0}
inheritance.relation.is.implemented=被实现
inheritance.relation.is.overridden=被重写
inheritance.relation.is.subclassed=被子类化
inheritance.relation.overrides=重写 {0}
inline.0.action.1=正在内联{0} {1}
inline.0.command.1=正在内联{0} {1}
inline.all.invocations.and.keep.the.0=全部内联，保留{0}(&A)
inline.all.invocations.and.remove.the.0=全部内联，移除{0}(&A)
inline.all.references.and.keep.the.0=全部内联，保留{0}(&A)
inline.all.references.and.remove.the.0=全部内联，移除{0}(&A)
inline.all.typealias.and.keep.the.0=全部内联，保留{0}(&A)
inline.all.typealias.and.remove.the.0=全部内联，移除{0}(&A)
inline.error.cannot.access.symbol.0=无法访问符号 {0}
inline.error.cannot.resolve.symbol=无法解析符号
inline.error.function.definition.contains.no.body=函数定义不包含正文
inline.error.function.no.return.statement=函数缺少 return 语句
inline.error.implements.function.from.0=内联方法实现方法从{0}
inline.error.inline.function.has.conditionally.compiled.code=该函数可能未正确内联，因为它包含有条件的未编译代码
inline.error.inline.function.only.in.swift.code=仅在 Swift 代码中支持函数内联
inline.error.inline.recursive.function.only.on.invocations=仅在调用时才支持内联递归函数
inline.error.inline.typealias.has.conditionally.compiled.code=该类型别名可能未正确内联，因为它包含有条件的未编译代码
inline.error.inline.variable.has.conditionally.compiled.code=该变量可能未正确内联，因为它包含有条件的未编译代码
inline.error.inline.variable.no.single.definition=找不到要内联的单一定义
inline.error.inlined.expression.should.be.part.of.statement=内联表达式应为语句的一部分
inline.error.invalid.function.arguments=函数实参无效
inline.error.is.overridden.by.function.from.0=内联方法被来自 {0} 的方法重写
inline.error.not.function.call=不是函数调用
inline.error.overrides.associated.type.from.0=内联的类型别名会重写来自 {0} 的关联类型
inline.error.overrides.function.from.0=从{0}内联方法重写方法
inline.error.unexpected.error=内联时出现意外错误
inline.function.description=将函数调用替换为其主体
inline.function.label.kind.0.name.1=内联{0} {1}\:
inline.function.label.kind.0.name.1.2.occurrences=内联{0} {1} 的 {2} 个调用\:
inline.function.label.kind.0.name.1.occurence=内联{0} {1} 的调用\:
inline.include.doc.comments=内联文档注释
inline.recursively=递归内联
inline.this.invocation.only.and.keep.the.0=仅内联此调用，保留{0}
inline.this.reference.only.and.keep.the.0=仅内联此引用，保留{0}
inline.this.typealias.only.and.keep.the.0=仅内联此用法，保留{0}
inline.title.0=内联{0}
inline.typealias.label.kind.0.name.1=内联{0} {1}\:
inline.typealias.label.kind.0.name.1.2.occurrences=内联{0} {1} 的 {2} 个用法\:
inline.typealias.label.kind.0.name.1.occurence=内联{0} {1} 的用法\:
inline.variable.label.kind.0.name.1=内联{0} {1}\:
inline.variable.label.kind.0.name.1.2.occurrences=内联{0} {1} 的 {2} 个引用\:
inline.variable.label.kind.0.name.1.occurence=内联{0} {1} 的引用\:
inspection.conditionally.not.compiled.code=有条件的未编译代码
inspection.missing.doc.comment.parameter.item.error=doc 注释中未描述形参 {0}
inspection.missing.doc.comment.parameter.item.fix=更新 doc 注释
inspection.missing.localization.all.languages.only=仅报告所有语言中都缺少的本地化
inspection.redundant.attribute.error=''@{0}'' 冗余
inspection.redundant.attribute.fix=移除冗余 ''@{0}''
inspection.redundant.closure.error=冗余的闭包创建
inspection.redundant.closure.fix=内联主体
inspection.redundant.nullable.function.type.error=''{0}'' 始终返回非 null 类型
inspection.redundant.nullable.type.error=''{0}'' 始终为非 null 类型
inspection.redundant.nullable.type.fix=移除冗余的 '?'
inspection.redundant.return.error='return' 冗余
inspection.redundant.return.fix=移除冗余 'return'
inspection.unnecessary.argument.list.error=实参圆括号不必要
inspection.unnecessary.argument.list.fix=移除不必要的实参圆括号
inspection.unnecessary.parentheses.error=圆括号不必要
inspection.unnecessary.parentheses.fix=移除不必要的圆括号
inspection.unnecessary.self.error='self' 不必要
inspection.unnecessary.self.fix=移除不必要的 'self'
inspection.unnecessary.tuple.wrap.error=单元素元组可被替换为类型
inspection.unnecessary.tuple.wrap.fix=将单元素元组替换为类型
intention.access.control.error.access=无法访问 {0}\: 它在{2}中为{1}
intention.access.control.error.access.dynamic=无法访问 {0}\: 动态成员下标在 {2} 中为 {1}
intention.access.control.error.override=无法重写 {0}\: 它在 {2} 中为 {1}
intention.access.control.fix=在 {2} 中使{0} {1}
intention.access.control.remove.setter=从 {0} 移除 {1}
intention.add.catch.clause=添加 'catch'
intention.add.default.catch.clause=添加默认 'catch' 子句
intention.add.digit.separators=添加数字分隔符
intention.add.explicit.qualifier=添加显式限定符
intention.add.explicit.type=添加显式类型
intention.add.try.to.expression=将 'try' 添加到表达式
intention.add.try.to.iteration=将 'try' 添加到迭代
intention.category.swift=Swift
intention.convert.to.binary=转换为二进制
intention.convert.to.closure.argument=转换为闭包实参
intention.convert.to.decimal=转换为十进制
intention.convert.to.hex=转换为十六进制
intention.convert.to.multiline.string=转换为多行字符串字面量
intention.convert.to.octal=转换为八进制
intention.convert.to.string=转换为单行字符串字面量
intention.convert.to.trailing.closure=转换为尾随闭包
intention.create.actor.0=创建 actor ''{0}''
intention.create.actor.0.in.new.file=在新文件中创建 actor ''{0}''
intention.create.actor.0.nested.in.1=创建嵌套在 ''{1}'' 中的 actor ''{0}''
intention.create.class.0=创建类 ''{0}''
intention.create.class.0.in.new.file=在新文件中创建类 ''{0}''
intention.create.class.0.nested.in.1=创建嵌套在 ''{1}'' 中的类 ''{0}''
intention.create.enum.0=创建枚举 ''{0}''
intention.create.enum.0.in.new.file=在新文件中创建枚举 ''{0}''
intention.create.enum.0.nested.in.1=创建嵌套在 ''{1}'' 中的枚举 ''{0}''
intention.create.enum.case.0=创建枚举 case ''{0}''
intention.create.global.function.0=创建全局函数 ''{0}''
intention.create.global.variable.0=创建全局变量 ''{0}''
intention.create.initializer=创建初始值设定项
intention.create.local.variable.0=创建局部变量 ''{0}''
intention.create.method.0=创建方法 ''{0}''
intention.create.method.0.in.extension=创建扩展方法 ''{0}''
intention.create.new.swift.declaration=创建新的 Swift 声明
intention.create.new.swift.type.in.a.new.file=在新文件中新建 Swift 类型
intention.create.property.0=创建属性 ''{0}''
intention.create.property.0.in.extension=创建扩展属性 ''{0}''
intention.create.protocol.0=创建协议 ''{0}''
intention.create.protocol.0.in.new.file=在新文件中创建协议 ''{0}''
intention.create.protocol.0.nested.in.1=创建嵌套在 ''{1}'' 中的协议 ''{0}''
intention.create.struct.0=创建结构体 ''{0}''
intention.create.struct.0.in.new.file=在新文件中创建结构体 ''{0}''
intention.create.struct.0.nested.in.1=创建嵌套在 ''{1}'' 中的结构体 ''{0}''
intention.create.type.0=创建类型 ''{0}''
intention.create.type.0.in.new.file=在新文件中创建类型 ''{0}''
intention.create.type.0.nested.in.1=创建嵌套在 ''{1}'' 中的类型 ''{0}''
intention.create.type.method.0=创建类型方法 ''{0}''
intention.create.type.method.0.in.extension=创建扩展类型方法 ''{0}''
intention.create.type.property.0=创建类型属性 ''{0}''
intention.create.type.property.0.in.extension=创建扩展类型属性 ''{0}''
intention.decrease.string.escape.level=降低字符串转义级别
intention.demorgans.law=德摩根定律
intention.demorgans.law.format=将 ''{0}'' 替换为 ''{1}''
intention.extract.class.0.to.extension=将类 ''{0}'' 提取到扩展
intention.extract.class.0.to.type.declaration=将类 ''{0}'' 提取到类型声明
intention.extract.conformance.to.extension.cannot.add.protocol.conformance.to.protocol=协议扩展无法符合其他协议
intention.extract.conformance.to.extension.cannot.extract.class=无法将类继承 ''{0}'' 提取到扩展
intention.extract.conformance.to.extension.familyName=将一致性提取到扩展
intention.extract.conformance.to.extension.type.cannot.be.local=无法在局部作用域中创建扩展
intention.extract.conformance.to.extension.type.must.be.fileprivate=类型必须至少为 fileprivate
intention.extract.enum.0.to.extension=将枚举 ''{0}'' 提取到扩展
intention.extract.enum.0.to.type.declaration=将枚举 ''{0}'' 提取到类型声明
intention.extract.from.extension.to.type.declaration.error.message.title=将成员提取到其原始类型声明
intention.extract.from.extension.to.type.declaration.familyName=将成员提取到其原始类型声明
intention.extract.from.extension.to.type.declaration.original.analysis.on.type.not.allowed=原始类型声明超出作用域
intention.extract.from.extension.to.type.declaration.original.type.not.found=找不到原始类型声明
intention.extract.function.0.to.extension=将函数 ''{0}'' 提取到扩展
intention.extract.function.0.to.type.declaration=将函数 ''{0}'' 提取到类型声明
intention.extract.initializer.to.extension=将初始值设定项提取到扩展
intention.extract.initializer.to.type.declaration=将初始值设定项提取到类型声明
intention.extract.member.to.extension.cannot.extract.from.protocol=无法从协议中提取
intention.extract.member.to.extension.type.cannot.be.local=无法在局部作用域中创建扩展
intention.extract.member.to.extension.type.must.be.fileprivate=类型必须至少为 fileprivate
intention.extract.members.to.extension.error.message.title=将成员提取到扩展
intention.extract.members.to.extension.familyName=将成员提取到扩展
intention.extract.multiple.members.to.extension=将成员提取到扩展
intention.extract.multiple.members.to.type.declaration=将成员提取到类型声明
intention.extract.property.0.to.extension=将属性 ''{0}'' 提取到扩展
intention.extract.property.0.to.type.declaration=将属性 ''{0}'' 提取到类型声明
intention.extract.struct.0.to.extension=将结构体 ''{0}'' 提取到扩展
intention.extract.struct.0.to.type.declaration=将结构体 ''{0}'' 提取到类型声明
intention.extract.subscript.to.extension=将下标提取到扩展
intention.extract.subscript.to.type.declaration=将下标提取到类型声明
intention.extract.typealias.0.to.extension=将类型别名 ''{0}'' 提取到扩展
intention.extract.typealias.0.to.type.declaration=将类型别名 ''{0}'' 提取到类型声明
intention.flip.binary.expression=翻转二元表达式
intention.flip.binary.expression.format=翻转 ''{0}''
intention.flip.comparison=翻转比较
intention.flip.comparison.format=将 ''{0}'' 翻转为 ''{1}''
intention.generate.documentation.comment=添加文档注释
intention.implement.equals=实现缺少的 equals
intention.implement.hash=实现缺少的 hash
intention.implement.members.error=类型 {0} 不符合{1} {2}
intention.implement.members.implement.missing=实现 {0} 个缺少的{0, choice,1\#成员|2\#成员}
intention.implement.missing.equals.hash=实现缺少的 equals 和 hash
intention.increase.string.escape.level=提高字符串转义级别
intention.invert.if.statement=反转 'if' 语句
intention.join.declaration.and.assignment=联接声明和赋值
intention.localize.string=本地化字符串
intention.localize.string.title.case=本地化字符串
intention.mark.the.enclosing.function.as.throws=将 'throws' 添加到函数签名
intention.merge.conditions=合并条件
intention.merge.else.if=合并 'else if'
intention.merge.nested.if=合并嵌套的 'if'
intention.negate.comparison=求反比较
intention.negate.comparison.format=将 ''{0}'' 求反为 ''{1}''
intention.remove.digit.separators=移除数字分隔符
intention.remove.explicit.type=移除显式类型
intention.replace.guard.with.if=将 'guard' 替换为 'if'
intention.replace.if.with.guard=将 'if' 替换为 'guard'
intention.replace.rethrows.with.throws=将 'rethrows' 替换为 'throws'
intention.simplifyifelse.collapse.conditional.expression=收起条件表达式
intention.simplifyifelse.collapse.guard=收起 'guard'
intention.simplifyifelse.collapse.ifelse=收起 'if else'
intention.simplifyifelse.familyName=简化 if-else
intention.simplifyifelse.replace.guard.with.0=将 ''guard'' 替换为 ''{0}''
intention.simplifyifelse.replace.if.else.with.0=将 ''if else'' 替换为 ''{0}''
intention.simplifyifelse.simplify=简化
intention.simplifyifelse.simplify.guard=简化 'guard'
intention.simplifyifelse.simplify.if.else=简化 'if else'
intention.split.condition=拆分为单独的条件
intention.split.declaration.and.assignment=拆分为声明和赋值
intention.split.else.if=拆分 'else if'
intention.split.into.separate.declarations=拆分为单独的声明
intention.split.nested.if=拆分为嵌套的 'if'
intention.suppress.call.error.with.try=使用 'try\!' 禁止此错误
intention.surround.with.do.catch=使用 'do/catch' 包围
intention.swift.module.info=显示模块信息
intention.switch.resolve.configuration.specified=切换到 ''{0}''，将此分支设置为有效
intention.unresolved.reference.0.1=导入{0} ''{1}''
intention.unwrap.with.guard.let=使用 'guard let' 解包
intention.unwrap.with.if.let=使用 'if let' 解包
intention.wrong.return.type.fix=修正函数返回值类型
intention.wrong.return.type.fix.with.types=使 ''{0}'' 返回 ''{1}''
introduce.variable.declare.with.var=使用 var 声明(&V)
introduce.variable.expression.will.be.ambiguous.without.explicit.type=表达式将不明确，<br/>无显式类型
introduce.variable.specify.type.explicitly=显式指定类型(&T)
notification.group.plugin.errors=Swift 语言服务失败
optimize.imports.rearranged.imports=重新排列的 import
optimize.imports.removed.0.added.1.imports=已移除 {0} 条 {0,choice,0\#import|1\#import|1<import}，已添加 {1} 条 {1,choice,0\#import|1\#import|1<import}
optimize.imports.removed.0.imports=已移除 {0} 条 {0,choice,0\#import|1\#import|1<import}
override.implement.elements.to.implement.chooser.title=选择要实现的成员
override.implement.elements.to.override.chooser.title=选择要重写的成员
override.implement.elements.to.override.implement.chooser.title=选择要重写/实现的成员
override.implement.implement.not.allowed=无法实现
override.implement.nothing.to.implement=没有要实现的内容
override.implement.nothing.to.override=没有要重写的内容
override.implement.override.not.allowed=无法重写
override.implement.progress=正在处理要重写/实现的成员…
override.implement.show.members.to.implement.title=显示要实现的成员
override.implement.show.no.optional.members=显示可选成员(无可选项)
override.implement.show.only.optional.members=显示可选成员(仅可选项)
override.implement.show.optional.member=显示 1 个可选成员(&O)
override.implement.show.optional.members=显示 {0} 个可选成员(&O)
refactor.0.overrides.associated.type.of.1={0} 重写 {1} 的关联类型
refactor.0.overrides.declaration.in.1={0} 重写 {1} 中的声明
refactor.0.overrides.initializer.of.1={0} 重写 {1} 的初始值设定项
refactor.0.overrides.method.of.1={0} 重写 {1} 的方法
refactor.0.overrides.property.of.1={0} 重写 {1} 的属性
refactor.0.overrides.subscript.of.1={0} 重写 {1} 的下标
refactor.base.declaration=重构基{0,choice,1\#声明|2\#声明}
refactor.only.current.declaration=仅重构当前声明
refactoring.option.search.in.not.compiled.code=适用于有条件的未编译代码
rename.containing.file.dialog.description=将具有以下名称的包含文件重命名为\:
rename.containing.file.dialog.title=重命名包含文件
rename.containing.file.entity.name=Include 文件
rename.error.dynamic.called.values=无法重命名动态调用值
rename.error.message.renaming.swift.member.elements.in.objective.c.code.is.not.supported=不支持在 Objective-C 代码中重命名 Swift 成员元素
rename.error.title=Swift - 重命名
rename.inheritor.entity.name=继承者
rename.inheritors=重命名继承者
rename.inheritors.to=将继承者重命名为\:
rename.init.is.not.supported=不支持重命名 Swift 初始值设定项
rename.related.dialog.description=将具有以下名称的相关声明重命名为\:
rename.related.dialog.title=重命名相关声明
rename.related.entity.name=相关声明
rename.self.is.not.supported=不支持重命名自形参
rename.title=Swift 名称重命名
searching.for.implementations=正在搜索实现…
searching.for.overriders=正在搜索重写…
searching.for.subclasses=正在搜索子类…
sourcekit.fix.it=应用 Fix-it
sourcekit.inspections=SourceKit 检查
swift-format.dump.progress=正在创建默认的 '.swift-format' 配置文件
swift-format.format.progress=重新格式化 {0}
swift.format.failed.message=Swift Format 无法格式化代码。请确保文件语法正确，然后重试。
swift.format.failed.title=Swift Format 失败
swift.name=Swift
syntax.error.call.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=调用可以抛出，但在非抛出自动闭包中执行
syntax.error.call.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=调用可以抛出，但未使用 'try' 标记，并且在非抛出自动闭包中执行
syntax.error.call.can.throw.in.default.argument=调用可以抛出，但无法从默认实参抛出错误
syntax.error.call.can.throw.in.property.initializer=调用可以抛出，但无法从属性初始值设定抛出错误
syntax.error.call.can.throw.not.marked.with.try=调用可以抛出，但未使用 'try' 标记
syntax.error.call.can.throw.not.marked.with.try.not.exhaustive=调用可以抛出，但未使用 'try' 标记，并且封闭 catch 不详尽
syntax.error.call.can.throw.not.marked.with.try.not.handled=调用可以抛出，但未使用 'try' 标记，并且错误未被处理
syntax.error.call.rethrows.function.can.only.throw.parameter.call.not.handled=调用可以抛出，但错误未被处理；被声明为 'rethrows' 的函数只能在其形参抛出时抛出
syntax.error.call.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=调用可以抛出，但未使用 'try' 标记，错误未被处理；被声明为 'rethrows' 的函数只能在其形参抛出时抛出
syntax.error.duplicate.platform=已指定平台 ''{0}''
syntax.error.error.is.not.handled=错误未被处理，因为封闭函数未被声明为 'throws'
syntax.error.error.is.not.handled.not.exhaustive=错误未被处理，因为封闭 catch 不详尽
syntax.error.errors.are.not.handled=从此处抛出的错误未被处理
syntax.error.errors.are.not.handled.not.exhaustive=从此处抛出的错误未被处理，因为封闭 catch 不详尽
syntax.error.hashbang.line.is.allowed.only.in.the.first.line.of.the.file=仅在文件的第一行中允许 Hashbang 行
syntax.error.hashbang.line.is.allowed.only.in.the.first.line.of.the.main.file=仅在主文件的第一行中允许 Hashbang 行
syntax.error.hashbang.line.is.allowed.only.in.the.main.file=仅在主文件中允许 Hashbang 行
syntax.error.interpolation.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=插值可以抛出，但在非抛出自动闭包中执行
syntax.error.interpolation.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=插值可以抛出，但未使用 'try' 标记，并且在非抛出自动闭包中执行
syntax.error.interpolation.can.throw.in.default.argument=插值可以抛出，但无法从默认实参抛出错误
syntax.error.interpolation.can.throw.in.property.initializer=插值可以抛出，但无法从属性初始值设定项抛出错误
syntax.error.interpolation.can.throw.not.marked.with.try=插值可以抛出，但未使用 'try' 标记
syntax.error.interpolation.can.throw.not.marked.with.try.not.exhaustive=插值可以抛出，但未使用 'try' 标记，并且封闭 catch 不详尽
syntax.error.interpolation.can.throw.not.marked.with.try.not.handled=插值可以抛出，但未使用 'try' 标记，并且错误未被处理
syntax.error.interpolation.rethrows.function.can.only.throw.parameter.call.not.handled=插值可以抛出，但错误未被处理；声明 'rethrows' 的函数只能在其形参抛出时抛出
syntax.error.interpolation.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=插值可以抛出，但未使用 'try' 标记，错误未被处理；声明 'rethrows' 的函数只能在其形参抛出时抛出
syntax.error.iteration.can.throw.not.marked.with.try=迭代可以抛出，但未使用 'try' 标记
syntax.error.iteration.can.throw.not.marked.with.try.not.exhaustive=迭代可以抛出，但未使用 'try' 标记，并且封闭 catch 不详尽
syntax.error.iteration.can.throw.not.marked.with.try.not.handled=迭代可以抛出，但未使用 'try' 标记，并且错误未被处理
syntax.error.operator.can.throw.not.marked.with.try=可能抛出运算符，但表达式未使用 'try' 进行标记
syntax.error.property.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=属性访问可以抛出，但在非抛出自动闭包中执行
syntax.error.property.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=属性访问可以抛出，但未使用 'try' 标记，并且在非抛出自动闭包中执行
syntax.error.property.can.throw.in.default.argument=属性访问可以抛出，但无法从默认实参抛出错误
syntax.error.property.can.throw.in.property.initializer=属性访问可以抛出，但无法从属性初始值设定项抛出错误
syntax.error.property.can.throw.not.marked.with.try=属性访问可以抛出，但未使用 'try' 标记
syntax.error.property.can.throw.not.marked.with.try.not.exhaustive=属性访问可以抛出，但未使用 'try' 标记，并且封闭 catch 不详尽
syntax.error.property.can.throw.not.marked.with.try.not.handled=属性访问可以抛出，但未使用 'try' 标记，并且错误未被处理
syntax.error.property.rethrows.function.can.only.throw.parameter.call.not.handled=属性访问可以抛出，但错误未被处理；声明 'rethrows' 的函数只能在其形参抛出时抛出
syntax.error.property.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=属性访问可以抛出，但未使用 'try' 标记，错误未被处理；声明 'rethrows' 的函数只能在其形参抛出时抛出
syntax.error.rethrows.function.can.only.throw.parameter.call=声明 'rethrows' 的函数只能在其形参抛出时抛出
syntax.error.rethrows.function.must.take.a.throwing.function.argument='rethrows' 函数必须包含 throwing 函数实参
syntax.error.rethrows.is.not.allowed.in.closures=闭包中不允许 'rethrows'
syntax.error.rethrows.is.not.allowed.in.function.type.elements=只有函数声明可以标记为 'rethrows'
syntax.error.rethrows.is.not.allowed.in.subscripts=下标中不允许 'rethrows'
syntax.error.subscript.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=下标访问可以抛出，但在非抛出自动闭包中执行
syntax.error.subscript.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=下标访问可以抛出，但未使用 'try' 标记，并且在非抛出自动闭包中执行
syntax.error.subscript.can.throw.in.default.argument=下标访问可以抛出，但无法从默认实参抛出错误
syntax.error.subscript.can.throw.in.property.initializer=下标访问可以抛出，但无法从属性初始值设定项抛出错误
syntax.error.subscript.can.throw.not.marked.with.try=下标访问可以抛出，但未使用 'try' 标记
syntax.error.subscript.can.throw.not.marked.with.try.not.exhaustive=下标访问可以抛出，但未使用 'try' 标记，并且封闭 catch 不详尽
syntax.error.subscript.can.throw.not.marked.with.try.not.handled=下标访问可以抛出，但未使用 'try' 标记，并且错误未被处理
syntax.error.subscript.rethrows.function.can.only.throw.parameter.call.not.handled=下标访问可以抛出，但错误未被处理；声明 'rethrows' 的函数只能在其形参抛出时抛出
syntax.error.subscript.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=下标访问可以抛出，但未使用 'try' 标记，错误未被处理；声明 'rethrows' 的函数只能在其形参抛出时抛出
syntax.error.thrown.expression.type.0.does.not.conform.to.ErrorType=已抛出的表达式类型 ''{0}'' 不符合 ''{1}''
syntax.error.throws.is.not.allowed.in.subscripts=下标中不允许 'throws'
syntax.error.try.cannot.appear.to.the.right='try' 不能出现在非赋值运算符右侧
syntax.error.try.cannot.appear.to.the.right.fix=向左移动 'try'
syntax.error.typealias.without.assignment=类型别名声明缺少赋值
syntax.error.unrecognized.platform.name.0=无法识别的平台名称 ''{0}''
syntax.error.variable.declaration.with.multiple.variables.cannot.have.explicit.getters.setters=具有多个变量的 'var' 声明不能具有显式 getter/setter
syntax.error.variable.declaration.with.multiple.variables.cannot.have.implicit.getter.clause=具有多个变量的 'var' 声明不能具有隐式 getter 子句
syntax.error.variable.declaration.with.multiple.variables.cannot.have.willset.didset.clause=具有多个变量的 'var' 声明不能具有 willSet/didSet 子句
usage.type.argument.label=实参标签
usage.type.conditionally.not.compiled=有条件的未编译代码中的潜在用法
usage.type.extension=扩展
usage.type.function.declaration=函数声明
usage.type.key.path=键路径表达式
usage.type.operator.declaration=运算符声明
usage.type.precedence.group.declaration=优先组声明
usage.type.raw.value=原始值
usage.type.requirement=要求中的用法
usage.type.type.alias=类型别名
usage.type.type.parameter=类型形参

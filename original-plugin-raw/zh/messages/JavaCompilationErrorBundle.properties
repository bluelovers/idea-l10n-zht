access.generic.problem=无法访问 ''{1}'' 中的 ''{0}''
access.package.local=''{0}'' 在 ''{1}'' 中不为 public。无法从外部软件包访问
access.private=''{0}'' 在 ''{1}'' 中具有 private 访问权限
access.protected=''{0}'' 在 ''{1}'' 中具有 protected 访问权限
annotation.attribute.duplicate=特性 ''{0}'' 重复
annotation.attribute.illegal.array.initializer=''{0}'' 的初始值设定项非法
annotation.attribute.incompatible.type=不兼容的类型。实际为 {1}''，需要 ''{0}''
annotation.attribute.name.missing=应为格式为 'name\=value' 的注解特性
annotation.attribute.non.class.literal=特性值必须为类字面量
annotation.attribute.non.constant=特性值必须为常量
annotation.attribute.non.enum.constant=特性值必须为枚举常量
annotation.attribute.unknown.method=找不到 @interface 方法 ''{0}()''
annotation.cannot.be.local=不允许局部注解
annotation.container.abstract=容器注解 ''{0}'' 没有包含 ''{1}'' 的默认值
annotation.container.bad.type=无效的容器注解 ''{0}''\: ''value'' 方法的类型应为 ''{1}''
annotation.container.low.retention=容器注解 ''{0}'' 的保留长度(''{1}'')比包含的注解短
annotation.container.missed.annotation=容器注解 ''{0}'' 没有必需的 @{1} 注解
annotation.container.no.value=无效的容器注解 ''{0}''\: 未声明 ''value'' 方法
annotation.container.not.applicable=容器注解 ''@{0}'' 不适用于 {1}
annotation.container.wide.target=容器注解 ''{0}'' 的目标不是此注解目标的子集
annotation.container.wrong.place=容器注解 ''{0}'' 不得与它所包含的元素同时存在
annotation.cyclic.element.type=循环注解元素类型
annotation.duplicate=注解重复
annotation.duplicate.explained=注解重复。{0}
annotation.duplicate.non.repeatable=重复的注解。''{0}'' 的声明没有有效的 java.lang.annotation.Repeatable 注解
annotation.malformed.repeatable.explained={0}
annotation.may.not.have.extends.list=@interface 上不允许使用 'extends'
annotation.member.clash=@interface 成员与 {1} 中的 ''{0}'' 冲突
annotation.member.invalid.type=注解成员的类型 ''{0}'' 无效
annotation.member.may.not.have.parameters=@interface 成员可能没有形参
annotation.member.may.not.have.throws.list=@interface 方法上不允许使用 'throws'
annotation.missing.attribute={0} 必要，但缺少
annotation.not.allowed.class=类字面量类型可能未进行注解
annotation.not.allowed.here=此处不允许注解
annotation.not.allowed.in.permit.list='permits' 列表中不允许使用注解
annotation.not.allowed.on.package=软件包注解应位于文件 package-info.java 中
annotation.not.allowed.ref=注解不适用于此类引用
annotation.not.allowed.static=限定类型的 static 成员可能未注解
annotation.not.allowed.var='var' 类型可能未注解
annotation.not.allowed.void='void' 类型可能未进行注解
annotation.not.applicable=''@{0}'' 不适用于{1}
annotation.permits=@interface 上不允许使用 'permits'
annotation.repeated.target=重复的注解目标
annotation.type.expected=应为注解类型
array.empty.diamond=不允许使用 '<>' 创建数组
array.generic=不允许创建泛型数组
array.illegal.initializer=''{0}'' 的初始值设定项非法
array.initializer.not.allowed=此处不允许数组初始值设定项
array.too.many.dimensions=数组维度过多
array.type.arguments=不允许使用类型实参创建数组
array.type.expected=应为数组类型；实际为 ''{0}''
assignment.declared.outside.guard=无法为变量 ''{0}'' 赋值，因为它是在 guard 外部声明的
assignment.to.final.variable=无法将值赋给 final 变量 ''{0}''
binary.operator.not.applicable=运算符 ''{0}'' 不能应用于 ''{1}''、''{2}''
break.out.of.switch.expression=不允许 switch 表达式外的 break
break.outside.switch.or.loop='break' 位于 switch 或循环外部
call.ambiguous=方法调用不明确\: ''{0}'' 和 ''{1}'' 均匹配
call.ambiguous.no.match=无法解析 ''{1}'' 中的方法 ''{0}''
call.ambiguous.tooltip=<html><body><table border\=0><tr><td colspan\={0}>方法调用不明确。<b>{2}</b> 中的 </td></tr><tr>{1}<td>\\&nbsp;和 <b>{4}</b> 中的 </td></tr><tr>{3}<td>\\&nbsp;均匹配</td></tr></table></body></html>
call.constructor.duplicate=构造函数中只允许一次显式构造函数调用
call.constructor.must.be.first.statement=''{0}'' 调用必须是构造函数主体中的第一条语句
call.constructor.must.be.top.level.statement=对 ''{0}'' 的调用必须是构造函数主体中的顶层语句
call.constructor.only.allowed.in.constructor=只允许在构造函数主体中调用 ''{0}''
call.constructor.record.in.canonical=规范构造函数不能委托给其他构造函数
call.constructor.recursive=递归构造函数调用
call.direct.abstract.method.access=无法直接访问 abstract 方法 ''{0}''
call.expected=应为方法调用
call.formal.varargs.element.type.inaccessible.here=无法从此处访问正式的 vararg 元素类型 {0}
call.member.before.constructor=在调用超类构造函数之前无法调用 ''{0}''
call.parsed.as.deconstruction.pattern=常量表达式、模式或 null 为必需项
call.qualifier.primitive=无法调用 ''{0}'' 类型的方法
call.static.interface.method.qualifier=static 方法只能在其包含接口上调用
call.super.enum.constructor=枚举构造函数中不允许调用 'super'
call.super.qualifier.not.inner.class=不允许使用限定符，因为超类 ''{0}'' 不是非 static 内部类
call.type.inference.error={0}
call.unresolved=无法解析方法 ''{0}''
call.unresolved.name=无法解析方法 ''{0}''
call.wrong.arguments=''{1}'' 中的 ''{0}'' 无法应用于 ''{2}''
call.wrong.arguments.count.mismatch=应为{0, choice, 0\#无实参|1\#1 个实参|1<{0} 个实参}，但实际为 {1} 个
cast.inconvertible=不可转换的类型；无法将 ''{0}'' 转换为 ''{1}''
cast.intersection.inheritance.clash=无法使用不同的实参继承 {0}\: {1} 和 {2}
cast.intersection.not.interface=此处应为接口
cast.intersection.repeated.interface=重复的接口
cast.intersection.unexpected.type=意外的类型\: 应为类
catch.type.parameter=无法捕获类型形参
clash.methods.message=''{0}'' 与 ''{1}'' 冲突
clash.methods.message.show.classes=''{2}'' 中的 ''{0}'' 与 ''{3}'' 中的 ''{1}'' 冲突
class.already.imported=已在此编译单元中定义 ''{0}''
class.anonymous.extends.sealed=匿名类不得扩展 sealed 类
class.cannot.be.referenced.from.static.context=无法从 static 上下文引用 ''{0}''
class.cannot.extend.multiple.classes=类不能扩展多个类
class.clashes.with.package=类 ''{0}'' 与同名的软件包冲突
class.cyclic.inheritance=涉及 ''{0}'' 的循环继承
class.duplicate=重复的类\: ''{0}''
class.duplicate.in.other.file=在文件 ''{0}'' 中找到重复类
class.extends.final=无法继承自{1, choice, 1\# final 类|2\#枚举|3\#记录|4\#非抽象值类} ''{0}''
class.extends.interface=此处不应为接口
class.extends.prohibited.class=类无法直接扩展 ''{0}''
class.extends.sealed.another.module=不允许类扩展另一个模块中的 sealed 类
class.extends.sealed.another.package=另一个软件包中的{0} ''{1}'' 不允许扩展未命名模块中的 sealed {2} ''{3}''
class.extends.sealed.local=局部类不得扩展 sealed 类
class.extends.sealed.not.permitted=sealed 层次结构中不允许使用 ''{0}''
class.generic.extends.exception=泛型类不能扩展 'java.lang.Throwable'
class.implements.class=此处应为接口
class.implicit.initializer=压缩源文件中不允许使用初始值设定项
class.implicit.invalid.file.name=压缩源文件的名称不是有效的标识符
class.implicit.no.main.method=压缩源文件未包含 'main' 方法
class.implicit.package.statement=压缩源文件中不允许使用软件包语句
class.inheritance.different.type.arguments=''{0}'' 不能使用不同的类型实参继承\: ''{1}'' 和 ''{2}''
class.inheritance.method.clash={1} 中的方法 {0} 和 {3} 中的方法 {2} 使用相同的签名继承
class.inheritance.raw.and.generic=''{0}'' 不能作为原始类型继承，也不能使用泛型类型实参 ''{1}'' 继承
class.inherits.abstract.and.default={0} 从类型 {2} 和 {3} 继承 {1} 的 abstract 和 default 方法
class.inherits.type.parameter=类无法从其类型形参继承
class.inherits.unrelated.defaults={0} 从类型 {2} 和 {3} 中继承 {1} 的不相关默认值
class.initializer.must.complete.normally=初始值设定项必须能够正常完成
class.must.implement.method=类 ''{0}'' 必须在 ''{2}'' 中实现 abstract 方法 ''{1}''
class.must.implement.method.enum.constant=枚举常量 ''{0}'' 必须在 ''{2}'' 中实现 abstract 方法 ''{1}''
class.must.implement.method.or.abstract=类“{0}”必须声明为抽象，或实现 ''{2}'' 中的 abstract 方法 ''{1}''
class.not.accessible=无法访问 {0}
class.not.enclosing=''{0}'' 不是封闭类
class.or.package.expected=应为类或软件包
class.permitted.must.have.modifier=所有 sealed 类的子类必须为 fianl、sealed 或 non-sealed 类型
class.permitted.not.direct.subclass=无效的 ''permits'' 子句\: ''{0}'' 必须直接{1, choice, 1\#扩展|2\#实现} ''{2}''
class.reference.list.duplicate=对 ''{1}'' 列表中 ''{0}'' 的重复引用
class.reference.list.inner.private=''{0}'' 在 ''{1}'' 中具有 private 访问权限
class.reference.list.name.expected=应为类名
class.reference.list.no.enclosing.instance=作用域中没有 ''{0}'' 类型的封闭实例
class.sealed.incomplete.permits=sealed 类 permit 子句必须包含所有子类
class.sealed.inheritor.expected.modifiers=应为修饰符 'sealed' 或 'non-sealed'
class.sealed.inheritor.expected.modifiers.can.be.final=应为修饰符 'sealed'、'non-sealed' 或 'final'
class.sealed.no.inheritors=sealed 类必须有子类
class.sealed.permits.on.non.sealed=无效的 ''permits'' 子句\: ''{0}'' 必须为 sealed
class.wrong.filename=类 ''{0}'' 为 public，应在文件 ''{0}.java'' 中声明
comment.shebang.java.file=不支持在 .java 文件中使用事件机制
comment.unclosed=未闭合注释
constructor.ambiguous.implicit.call=不明确的隐式构造函数调用\: ''{0}'' 和 ''{1}'' 均匹配
constructor.in.implicit.class=不允许在压缩源文件的隐式声明类中使用显式构造函数
constructor.no.default=''{0}'' 中没有可用的无实参构造函数
continue.out.of.switch.expression=不允许在 switch 表达式外部使用 continue
continue.outside.loop='continue' 语句不在 for 循环内
enum.constant.illegal.access.in.constructor=不允许从枚举{1, choice, 1\#构造函数|2\#实例字段初始值设定项|3\#实例初始值设定项}访问{0, choice, 1\# static 字段|2\#枚举常量}
enum.constant.modifier=不允许对枚举常量使用修饰符
enum.extends=枚举上不允许使用 'extends'
enum.permits=枚举上不允许使用 'permits'
exception.already.caught=已捕捉到异常 ''{0}''
exception.must.be.disjoint=多 catch 中的类型必须不相交\: ''{0}'' 是 ''{1}'' 的子类
exception.never.thrown.try=相应的 try 块中从未抛出异常 ''{0}''
exception.never.thrown.try.multi=相应的 try 块中从未抛出异常 ''{0}''
exception.unhandled=未处理的{1, choice, 0\#异常|2\#异常}\: {0}
exception.unhandled.close=来自可自动关闭资源的未处理{1, choice, 0\#异常|2\#异常}\: {0}
expression.class.parameterized.type=无法访问形参化类型的类对象
expression.class.type.parameter=无法访问类型形参的类对象
expression.expected=应为表达式
expression.qualified.class.expected=此处应为类名
expression.super.bad.qualifier.method.overridden=默认 super 调用中的类型限定符错误\: 方法 {0} 在 {1} 中被重写
expression.super.bad.qualifier.redundant.extended=默认 super 调用中的类型限定符错误\: 冗余接口 {0} 由 {1} 扩展
expression.super.dot.expected=应为 '.'
expression.super.no.enclosing.instance=作用域中没有 ''{0}'' 类型的封闭实例
expression.super.not.enclosing.class=''{0}'' 不是封闭类
expression.super.unqualified.default.method=扩展方法中不允许非限定 super 引用
field.initialized.before.constructor.call=无法在调用超类构造函数之前指定初始化的字段 ''{0}''
field.not.initialized=字段 ''{0}'' 可能尚未初始化
foreach.not.applicable=Foreach 不适用于类型 ''{0}''
guard.evaluated.to.false=此 case 标签有一个 guard，后者是一个值为 'false' 的常量表达式
guard.misplaced=只允许在模式后使用 guard
identifier.restricted=''{0}'' 为受限标识符，不能用于类型声明
illegal.character=非法字符\: {0}
illegal.unicode.escape=非法 Unicode 转义序列
import.list.extra.semicolon=import 语句之间不允许有额外的分号
import.single.class.conflict=已在单类型 import 中定义 ''{0}''
import.single.static.class.already.defined=已在单一 static import 中定义类 ''{0}''
import.single.static.class.ambiguous=类 ''{0}'' 在单一 static import 中不明确
import.single.static.field.already.defined=已在单一 static import 中定义字段 ''{0}''
import.single.static.field.ambiguous=字段 ''{0}'' 在单一 static import 中不明确
import.static.on.demand.resolves.to.class=找不到类 {0}
incomplete.project.state.pending.reference=直到项目完全加载后才会解析
instanceof.illegal.generic.type=instanceof 的泛型类型非法
instanceof.type.parameter=应为类或数组
instanceof.unsafe.cast=''{0}'' 无法安全地转换为 ''{1}''
instantiation.abstract=''{0}'' 为 abstract；无法实例化
instantiation.enum=无法实例化枚举类型
instantiation.local.class.wrong.static.context=无法从其他 static 上下文实例化本地类 ''{0}''
insufficient.language.level=语言级别 ''{1}'' 不支持 {0}
interface.class.initializer=接口中不允许使用类初始值设定项
interface.constructor=接口中不允许使用构造函数
interface.extends.class=此处应为接口
interface.implements=接口上不允许使用 'implements'
label.duplicate=标签 ''{0}'' 已在使用中
label.must.be.loop=''continue'' 目标必须为循环标签\: ''{0}''
label.unresolved=未定义的标签\: ''{0}''
label.without.statement=无语句的标签
lambda.incompatible.parameter.types=lambda 表达式中的形参类型不兼容\: 应为 {0} 个，但实际为 {1} 个
lambda.inference.error={0}
lambda.multiple.sam.candidates=在 {0} 中找到多个非重写 abstract 方法
lambda.no.target.method.found=找不到目标方法
lambda.not.a.functional.interface={0} 不是函数式接口
lambda.not.expected=意外的 lambda 表达式
lambda.parameters.inconsistent.var=不能在 lambda 表达式中将 'var' 和显式类型形参混合
lambda.return.type.error={0}
lambda.sam.generic=目标方法为泛型
lambda.sealed=Lambda 无法实现 sealed 接口
lambda.sealed.functional.interface=函数式接口不能声明为 'sealed'
lambda.target.not.interface=lambda 转换的目标类型必须为接口
lambda.type.inference.failure=无法推断函数式接口类型
lambda.wrong.number.of.parameters=lambda 表达式中的形参数量错误\: 应为 {0} 个，但实际为 {1} 个
literal.binary.no.digits=二进制数值必须至少包含一个二进制数字
literal.character.empty=空字符字面量
literal.character.illegal.escape=字符串字面量中有非法转义字符
literal.character.too.long=字符字面量中的字符数过多
literal.character.unclosed=字符字面量未闭合
literal.floating.malformed=浮点字面量格式不正确
literal.floating.too.large=浮点数过大
literal.floating.too.small=浮点数过小
literal.hexadecimal.no.digits=十六进制数值必须至少包含一个十六进制数字
literal.illegal.underscore=非法下划线
literal.integer.too.large=整数过大
literal.long.too.large=长整数过大
literal.string.illegal.escape=字符串字面量中存在非法转义字符
literal.string.illegal.line.end=字符串字面量中不允许出现行尾
literal.text.block.no.new.line=非法的文本块起始\: 左引号后缺少新行
literal.text.block.unclosed=文本块未闭合
lvalue.variable.expected=应为变量
lvti.array=不允许将 'var' 作为数组的元素类型
lvti.compound=复合声明中不允许 'var'
lvti.lambda=无法推断类型\: lambda 表达式需要显式目标类型
lvti.method.reference=无法推断类型\: 方法引用需要显式目标类型
lvti.no.initializer=无法推断类型\: 'var' 位于没有初始值设定项的变量上
lvti.null=无法推断类型\: 变量初始值设定项为 'null'
lvti.self.referenced=无法推断 ''{0}'' 的类型，它被用于自己的变量初始值设定项中
lvti.void=无法推断类型\: 变量初始值设定项为 'void'
method.abstract.body=abstract 方法不能有主体
method.abstract.in.non.abstract.class=非抽象类中存在 abstract 方法
method.default.in.class=扩展方法只能在接口中使用
method.default.overrides.object.member=默认方法 ''{0}'' 重写 ''java.lang.Object'' 的成员
method.default.should.have.body=扩展方法应有主体
method.duplicate=已在 ''{1}'' 中定义 ''{0}''
method.generic.same.erasure={0}；两个方法具有相同的擦除
method.generic.same.erasure.hide={0}；两个方法具有相同的擦除，但都没有隐藏另一个
method.generic.same.erasure.override={0}；两个方法具有相同的擦除，但都没有重写另一个
method.inheritance.clash.does.not.throw={0}；重写的方法未抛出 ''{1}''
method.inheritance.clash.incompatible.return.types={0}；返回值类型不兼容
method.inheritance.clash.unrelated.return.types={0}；方法有不相关的返回值类型
method.inheritance.weaker.privileges={0}；尝试指定较弱的访问权限(''{1}'')；曾为 ''{2}''
method.instance.overrides.static=''{1}'' 中的实例方法 ''{0}'' 无法重写 ''{3}'' 中的 static 方法 ''{2}''
method.interface.body=接口 abstract 方法不能有主体
method.missing.return.type=方法声明无效；需要返回值类型
method.native.body=原生方法不能有主体
method.no.parameter.list=应为形参列表
method.overrides.final=''{0}'' 无法重写 ''{2}'' 中的 ''{1}''；被重写的方法为 final
method.private.in.interface.should.have.body=接口中的 private 方法应具有主体
method.reference.abstract.method=无法直接访问 abstract 方法 ''{0}''
method.reference.enclosing.instance.not.in.scope=作用域中没有类型 {0} 的封闭实例
method.reference.inference.error={0}
method.reference.non.static.method.in.static.context=无法从 static 上下文引用非 static 方法
method.reference.not.expected=不应在此处使用方法引用表达式
method.reference.parameterized.qualifier=static 方法引用上存在形参化限定符
method.reference.qualifier.class.unresolved=找不到类 {0}
method.reference.qualifier.wildcard=意外通配符
method.reference.raw.constructor=原始构造函数引用具有构造函数的显式类型形参
method.reference.return.type.error={0}
method.reference.sealed=方法引用无法实现 sealed 接口
method.reference.static.method.non.static.qualifier=通过非 static 限定符引用 static 方法
method.reference.static.method.receiver=通过接收器引用 static 方法
method.reference.unresolved.constructor=无法解析构造函数 ''{0}''
method.reference.unresolved.method=无法解析方法 ''{0}''
method.should.have.body=应为方法体
method.should.have.body.or.abstract=应为方法体或 'abstract' 修饰符
method.static.in.interface.should.have.body=接口中的 static 方法应具有主体
method.static.overrides.instance=''{1}'' 中的 static 方法 ''{0}'' 无法重写 ''{3}'' 中的实例方法 ''{2}''
method.throws.class.name.expected=应为类名
modifier.incompatible=非法的修饰符组合 ''{0}'' 和 ''{1}''
modifier.not.allowed=此处不允许使用修饰符 ''{0}''
modifier.not.allowed.local.class=不允许在局部类上使用修饰符 ''{0}''
modifier.not.allowed.non.sealed=不允许在没有 sealed 超类的类上使用修饰符 'non-sealed'
modifier.repeated=重复的修饰符 ''{0}''
module.access.bad.name=模块 ''{0}'' 的名称无效
module.access.does.not.read=模块 ''{0}'' 无法读取 ''{1}''
module.access.from.named=软件包 ''{0}'' 在模块 ''{1}'' 中声明，但后者没有将它导出到模块 ''{2}''
module.access.from.unnamed=软件包 ''{0}'' 在模块 ''{1}'' 中声明，但后者没有将它导出到未命名模块
module.access.jps.dependency.problem=项目结构中未指定 ''{0}'' 的模块依赖项
module.access.not.in.graph=模块图中缺少模块 ''{0}''
module.access.package.bad.name=软件包 ''{0}'' 在具有无效名称(''{1}'')的模块中声明
module.access.package.does.not.read=软件包 ''{0}'' 在模块 ''{1}'' 中声明，但模块 ''{2}'' 没有读取它
module.access.package.not.in.graph=软件包 ''{0}'' 在模块 ''{1}'' 中声明，但后者不在模块图中
module.access.to.unnamed=软件包 ''{0}'' 在未命名的模块中声明，但模块 ''{1}'' 没有读取它
module.conflicting.packages=软件包 ''{0}'' 存在于另一个模块中\: {1}
module.conflicting.reads=模块 ''{0}'' 同时从 ''{2}'' 和 ''{3}'' 读取软件包 ''{1}''
module.cyclic.dependence=循环依赖关系\: {0}
module.duplicate.exports=重复的 ''exports''\: {0}
module.duplicate.exports.target=重复的 ''exports'' 目标\: {0}
module.duplicate.implementation=重复的实现\: {0}
module.duplicate.opens=重复的 ''opens''\: {0}
module.duplicate.opens.target=重复的 ''opens'' 目标\: {0}
module.duplicate.provides=重复的 ''provides''\: {0}
module.duplicate.requires=重复的 ''requires''\: {0}
module.duplicate.uses=重复的 ''uses''\: {0}
module.file.duplicate=模块中已存在 'module-info.java'
module.file.wrong.location=模块声明应位于模块的源根中
module.file.wrong.name=模块声明应位于名为 'module-info.java' 的文件中
module.import.not.allowed=不允许导入模块
module.no.package=模块文件不应具有 'package' 语句
module.not.found=找不到模块\: {0}
module.not.on.path=模块不在依赖项中\: {0}
module.opens.in.weak.module=打开的模块中不允许 'opens'
module.reference.package.empty=软件包为空\: {0}
module.reference.package.not.found=找不到软件包\: {0}
module.service.abstract=该服务实现是抽象类\: {0}
module.service.alien=服务实现必须在 provides 指令所在的同一模块中定义
module.service.enum=服务定义为枚举\: {0}
module.service.implementation.type=服务实现类型必须为服务接口类型的子类型，或者具有 public static 无实参 'provider' 方法
module.service.inner=服务实现为内部类\: {0}
module.service.no.constructor=服务实现没有 public 默认构造函数\: {0}
module.service.provider.type=''provider'' 方法返回值类型必须是服务接口类型的子类型\: {0}
new.expression.anonymous.implements.interface.with.type.arguments=匿名类实现接口；不能具有类型实参
new.expression.arguments.to.default.constructor.call=默认构造函数通过实参调用
new.expression.diamond.anonymous.inner.non.private=由于非 private 方法不会重写或实现父类型中的方法，无法使用 '<>'
new.expression.diamond.inference.failure={0}
new.expression.diamond.not.allowed=此处不允许菱形运算符
new.expression.diamond.not.applicable=菱形运算符不适用于非形参化类型
new.expression.qualified.anonymous.implements.interface=实现接口的匿名类的意外限定符
new.expression.qualified.malformed=限定 new 无效
new.expression.qualified.qualified.class.reference=限定 new 中不允许使用限定类引用
new.expression.qualified.static.class=static 类的限定 new
new.expression.type.parameter=类型形参 ''{0}'' 不能直接实例化
new.expression.unresolved.constructor=无法解析构造函数 ''{0}''
override.on.non-overriding.method=方法未从其超类重写方法
override.on.static.method=static 方法不能使用 @Override 注解
package.clashes.with.class=软件包 ''{0}'' 与同名的类冲突
pattern.cannot.infer.type=无法推断模式类型\: {0}
pattern.deconstruction.annotation=析构模式类型中不允许使用注解
pattern.deconstruction.count.mismatch=嵌套模式的数量不正确\: 应为 {0} 个，但实际为 {1} 个
pattern.deconstruction.requires.record=析构模式只能应用于记录，''{0}'' 不是记录
pattern.deconstruction.variable=此处不允许使用标识符
pattern.expected.class.or.array.type=需要类或数组类型
pattern.instanceof.equals=模式类型 ''{0}'' 与表达式类型相同
pattern.instanceof.supertype=模式类型 ''{0}'' 是表达式类型 ''{1}'' 的父类型
pattern.not.exhaustive=模式 ''{0}'' 在 ''{1}'' 上不详尽
pattern.type.pattern.expected=应为类型模式
pattern.unsafe.cast=''{0}'' 无法安全地转换为 ''{1}''
preview.api.usage={0} 是预览 API，默认情况下处于禁用状态
receiver.name.mismatch=接收器名称不匹配封闭类类型
receiver.static.context=接收器不能在 static 上下文中使用
receiver.type.mismatch=接收器类型不匹配封闭类类型
receiver.wrong.context=不允许接收器超出方法形参列表
receiver.wrong.position=接收器应为第一个形参
record.accessor=记录组件访问器
record.accessor.non.public=记录组件访问器必须为 'public'
record.accessor.wrong.return.type=组件访问器返回值类型不正确。应为 ''{0}''，实际为 ''{1}''
record.canonical.constructor=规范构造函数
record.canonical.constructor.wrong.parameter.name=规范构造函数形参名称必须匹配记录组件名称。应为 ''{0}''，实际为 ''{1}''
record.canonical.constructor.wrong.parameter.type=记录组件 ''{0}'' 的形参类型不正确。应为 ''{1}''，实际为 ''{2}''
record.compact.constructor=紧凑构造函数
record.component.cstyle.declaration=记录组件中不允许 C 样式的数组声明
record.component.not.initialized=记录组件 ''{0}'' 可能无法在规范构造函数中初始化
record.component.restricted.name=记录组件名称 ''{0}'' 非法
record.component.vararg.not.last=Vararg 记录组件必须为列表中的最后一项
record.constructor.stronger.access={0} 访问级别的限制不能超过记录访问级别(''{1}'')
record.extends=记录上不允许使用 'extends'
record.header.regular.class=为非记录声明了记录标头
record.instance.field=记录中不允许实例字段
record.instance.initializer=记录中不允许实例初始值设定项
record.no.constructor.call.in.non.canonical=非规范记录构造函数必须委托给其他构造函数
record.no.header=记录没有声明标头
record.permits=记录上不允许使用 'permits'
record.special.method.throws={0} 不应声明 ''throws'' 子句
record.special.method.type.parameters={0} 不能有类型形参
reference.ambiguous=对 ''{0}'' 的引用不明确，''{1}'' 和 ''{2}'' 均匹配
reference.class.in.default.package=类 ''{0}'' 位于默认软件包中
reference.enum.forward=无法在定义枚举常量 ''{0}'' 之前对其进行引用
reference.enum.self=无法从枚举常量 ''{0}'' 自己的定义中其进行引用
reference.field.forward=无法在定义字段 ''{0}'' 之前读取它的值
reference.field.self=无法从字段定义内部读取字段 ''{0}'' 的值
reference.implicit.class=无法引用压缩源文件 ''{0}'' 的隐式声明类
reference.local.class.other.switch.branch=无法从另一个 switch 分支引用局部类 ''{0}''
reference.member.before.constructor=在调用超类构造函数之前无法引用 ''{0}''
reference.non.static.from.static.context=无法从 static 上下文引用非 static {0} ''{1}''
reference.outer.type.parameter.from.static.context=无法从 static 上下文引用 ''{0}''
reference.package.not.found=找不到软件包\: {0}
reference.qualifier.not.expression=限定符必须为表达式
reference.qualifier.primitive=无法访问 ''{0}'' 类型的字段
reference.select.from.type.parameter=无法从类型形参中选择
reference.type.argument.static.class=此处不允许类型实参，因为类 ''{0}'' 为 static
reference.type.needs.type.arguments=格式不正确的类型\: ''{0}'' 需要类型实参，因为其限定符具有类型实参
reference.unresolved=无法解析符号 ''{0}''
resource.declaration.or.variable.expected=应为声明、final 或 effectively final 变量
return.before.explicit.constructor.call=不允许在 ''{0}'' 调用之前使用 ''return''
return.compact.constructor=紧凑构造函数中不允许 'return' 语句
return.from.constructor=无法从构造函数返回值
return.from.void.method=无法从结果类型为 void 的方法返回值
return.missing=缺少 return 语句
return.outside.method=return 位于方法外部
return.outside.switch.expression=return 位于封闭 switch 表达式外部
return.value.missing=缺少返回值
safe.varargs.on.fixed.arity=具有固定元数的方法中不允许使用 @SafeVarargs
safe.varargs.on.non.final.method=非 final 实例方法中不允许使用 @SafeVarargs
safe.varargs.on.record.component=记录组件中不允许使用 @SafeVarargs
statement.bad.expression=不是语句
statement.case.outside.switch=case 语句位于 switch 外部
statement.declaration.not.allowed=此处不允许声明
statement.invalid=语句无效
statement.unreachable=不可到达的语句
statement.unreachable.loop.body=循环条件始终为 false，使循环体不可到达
string.template.processor.missing=字符串模板表达式中缺少处理器
string.template.raw.processor=不允许使用原始处理器类型\: {0}
string.template.void.not.allowed.in.embedded=不允许将 'void' 类型的表达式作为字符串模板嵌入表达式
switch.default.and.boolean='switch' 具有所有布尔值和一个 default 标签
switch.default.label.contains.case=默认 case 的标签只能使用 'default' 关键字，不能使用 'case'
switch.default.label.not.allowed=此处不允许使用默认标签\: 'default' 只能用作单个 case 标签或仅与 'null' 配对
switch.default.null.order=无效的 case 标签顺序\: 'null' 必须为第一个，'default' 必须为第二个
switch.different.case.kinds='switch' 中使用了不同的 'case' 种类
switch.dominance.violation=标签由先前的 case 标签 ''{0}'' 支配
switch.empty=''switch'' {0} 没有任何 case 子句
switch.expression.cannot.be.void=switch 表达式的目标类型不能为 void
switch.expression.incompatible.type=switch 表达式中存在错误类型\: {0} 无法转换为 {1}
switch.expression.no.result='switch' 表达式没有任何结果表达式
switch.expression.should.produce.result=switch 表达式应在所有执行路径中产生结果
switch.fallthrough.to.pattern=到模式的直落非法
switch.incomplete=''switch'' {0} 未涵盖所有可能的输入值
switch.label.combination.constants.and.patterns=无效的 case 标签组合\: 一个 case 标签必须包含 case 常量列表或单个 case 模式
switch.label.combination.constants.and.patterns.unnamed=无效的 case 标签组合\: 一个 case 标签必须包含一个 case 常量列表或一个 case 模式列表
switch.label.constant.expected=需要常量表达式
switch.label.duplicate=标签 ''{0}'' 重复
switch.label.duplicate.default=default 标签重复
switch.label.duplicate.unconditional.pattern=无条件模式重复
switch.label.expected=必须在语句前面预置 case 标签
switch.label.multiple.patterns=无效的 case 标签组合\: 一个 case 标签不得包含一个以上的 case 模式
switch.label.multiple.patterns.unnamed=无效的 case 标签组合\: 只有所有模式都不声明任何模式变量时，才允许使用多个模式
switch.label.pattern.expected=switch 选择器类型 ''{0}'' 需要模式
switch.label.qualified.enum=枚举 switch case 标签必须是枚举常量的非限定名称
switch.label.unexpected=常量表达式、模式或 null 为必需项
switch.multiple.labels.with.pattern.variables=只有所有标签都不声明任何模式变量时，才允许为 switch 标记语句组使用多个 switch 标签
switch.null.label.not.allowed=无效的 case 标签组合\: 'null' 只能用作单个 case 标签或仅与 'default' 配对
switch.null.type.incompatible=''null'' 无法转换为 ''{0}''
switch.rule.should.produce.result=switch 表达式规则应在所有执行路径中产生结果
switch.selector.type.invalid=不支持 ''{0}'' 的选择器类型
switch.selector.type.invalid.level=语言级别 ''{1}'' 不支持选择器类型 ''{0}''
switch.unconditional.pattern.and.boolean='switch' 具有所有布尔值和一个无条件模式
switch.unconditional.pattern.and.default='switch' 同时具有无条件模式和 default 标签
syntax.error={0}
type.argument.in.permits.list=permits 列表中不允许泛型
type.argument.not.allowed=此处不允许引用形参
type.argument.on.raw.method=在原始方法上提供类型实参
type.argument.on.raw.type=在原始类型上提供类型实参
type.argument.primitive=类型实参不能为基元类型
type.inaccessible=''{0}'' 无法从此处访问
type.incompatible=不兼容的类型。实际为 {1}''，需要 ''{0}''
type.incompatible.reason.ambiguous.method.reference=原因\: 方法引用不明确\: ''{0}'' 和 ''{1}'' 均匹配
type.incompatible.reason.inference=原因\: {0}
type.incompatible.tooltip.provided.type=提供\:
type.incompatible.tooltip.required.type=必需类型\:
type.parameter.absent.class=类型 ''{0}'' 没有类型形参
type.parameter.absent.method=方法 ''{0}'' 没有类型形参
type.parameter.actual.inferred.mismatch=实际类型实参与推断的类型相矛盾
type.parameter.cannot.be.followed.by.other.bounds=类型形参后面不能跟随其他边界
type.parameter.count.mismatch=类型实参的数量错误\: {0} 个；要求 {1} 个
type.parameter.duplicate=重复的类型形参\: ''{0}''
type.parameter.extends.interface.expected=此处应为接口
type.parameter.incompatible.upper.bounds=类型形参 {0} 的上限不兼容\: {1}
type.parameter.inferred.type.not.within.extend.bound=类型形参 ''{0}'' 的推断类型 ''{2}'' 不在其界限内；应扩展 ''{1}''
type.parameter.inferred.type.not.within.implement.bound=类型形参 ''{0}'' 的推断类型 ''{2}'' 不在其界限内；应实现 ''{1}''
type.parameter.on.annotation=@interface 可能没有类型形参
type.parameter.on.annotation.member=@interface 成员可能没有类型形参
type.parameter.on.enum=枚举可能没有类型形参
type.parameter.type.not.within.extend.bound=类型形参 ''{0}'' 不在其界限内；应扩展 ''{1}''
type.parameter.type.not.within.implement.bound=类型形参 ''{0}'' 不在其界限内；应实现 ''{1}''
type.restricted.identifier=非法引用受限类型 ''{0}''
type.unknown.class=未知类\: ''{0}''
type.void.illegal=非法类型\: 'void'
type.void.not.allowed=此处不允许使用 'void' 类型
type.wildcard.cannot.be.instantiated=通配符类型 ''{0}'' 不能直接实例化
type.wildcard.may.be.used.only.as.reference.parameters=通配符只能用作引用形参
type.wildcard.not.expected=应为非通配符
unary.operator.not.applicable=运算符 ''{0}'' 不能应用于 ''{1}''
underscore.identifier=从 Java 9 起，'_' 为关键字，不能用作标识符
underscore.identifier.lambda=不允许使用 '_' 作为 lambda 形参名称
underscore.identifier.unnamed=不允许使用 '_' 作为引用
unnamed.field.not.allowed=不允许使用未命名的字段
unnamed.method.parameter.not.allowed=不允许使用未命名的方法形参
unnamed.variable.brackets=未命名变量声明后不允许使用中括号
unnamed.variable.not.allowed.in.this.context=此上下文中不允许使用未命名的变量声明
unnamed.variable.without.initializer=未命名变量声明必须具有初始值设定项
value.class.extends.non.abstract=值类只能扩展抽象值类或 'java.lang.Object'
vararg.cstyle.array.declaration=vararg 形参中不允许 C 样式的数组声明
vararg.not.last.parameter=Vararg 形参必须为列表中的最后一个形参
variable.already.assigned=变量 ''{0}'' 可能尚未被赋值
variable.already.assigned.constructor=无法在链式构造函数调用''{0}'' {1, choice, 1\#前|2\#后}为 final 字段赋值
variable.already.assigned.field=final 字段 ''{0}'' 已在另一个字段初始值设定项中初始化
variable.already.assigned.initializer=final 字段 ''{0}'' 已在类初始值设定项中初始化
variable.already.defined=作用域中已定义变量 ''{0}''
variable.assigned.in.loop=变量 ''{0}'' 可能在循环中赋值
variable.must.be.effectively.final=变量 ''{0}'' 从内部类中访问，需要为 final 或有效 final
variable.must.be.effectively.final.guard=guard 表达式中使用的变量应为 final 或有效 final
variable.must.be.effectively.final.lambda=lambda 表达式中使用的变量应为 final 或有效 final
variable.must.be.final=变量 ''{0}'' 从内部类中访问，需要声明为 final
variable.must.be.final.resource=用作 try-with-resources 资源的变量应为 final 或有效 final
variable.not.initialized=变量 ''{0}'' 可能尚未初始化
yield.unexpected='yield' 位于 switch 表达式外部
yield.void=表达式类型不应为 'void'

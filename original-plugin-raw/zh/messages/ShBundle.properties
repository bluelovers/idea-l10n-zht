sh.code.style.binary.ops.like.and.may.start.a.line=允许在二元运算符后换行
sh.code.style.choose.path=选择 Shfmt 的路径:
sh.code.style.download.link=下载 Shfmt 格式化程序
sh.code.style.keep.column.alignment.padding=保持列对齐填充
sh.code.style.minify.program.to.reduce.its.size=缩小程序以缩减其大小
sh.code.style.unix.line.separator=使用 Unix 行分隔符(\\n)
sh.code.style.redirect.operators.will.be.followed.by.a.space=在重定向运算符后添加空格
sh.code.style.switch.cases.will.be.indented=缩进 case 语句

sh.disable.inspection.text=禁用检查 {0}

sh.explain.command.to.explain=要解释的命令
sh.explain.inspection.text=解释 shell
sh.explain.message.nothing.to.explain=没有要解释的内容
sh.explain.title.nothing.to.explain=没有要解释的内容

sh.fmt.cannot.download=无法下载 shfmt 格式化程序。请手动安装。
sh.fmt.cannot.update=无法更新 shfmt 格式化程序。回滚到上一版。
sh.fmt.formatter=Shfmt 格式化程序
sh.fmt.indent.label=缩进
sh.fmt.update.question=要更新 shell 脚本格式化程序吗?
sh.fmt.install.question=要安装 shell 脚本格式化程序吗?
sh.fmt.success.update=Shell 脚本格式化程序已成功更新
sh.fmt.success.install=Shell 脚本格式化程序已成功安装
sh.fmt.missing.formatter=缺少格式化程序

sh.parser.expected.similar.close.bracket=应为类似的右中括号
sh.path.label=路径:

sh.rename.all.occurrences=重命名所有匹配项
sh.rename.occurence=重命名 {0}

sh.shell.script=Shell 脚本
filetype.sh.shell.script.description=Shell 脚本
sh.shellcheck.download.label.text=下载 shellcheck
sh.shellcheck.cannot.download=无法下载 shellcheck。请手动安装。
sh.shellcheck.cannot.update=无法更新 shellcheck。回滚到上一版。
sh.shellcheck.path.label=选择 Shellcheck 的路径:
sh.shellcheck.install.question=要安装 shellcheck 来验证您的 shell 脚本吗?
sh.shellcheck.update.question=要更新 shellcheck 吗?
sh.shellcheck.success.install=Shellcheck 已成功安装
sh.shellcheck.success.update=Shellcheck 已成功更新
sh.shellcheck.missing=\ 缺少 shellcheck

sh.suppress.inspection=禁止 {0}
sh.unnamed.element.presentable.name=<unnamed>

sh.label.download.shfmt.formatter=下载 shfmt 格式化程序
sh.label.choose.interpreter=选择解释器
sh.label.choose.script.working.directory=选择脚本工作目录
sh.label.choose.shell.script=选择 Shell 脚本

action.ShGenerateUntilLoop.text=Until 循环
action.ShGenerateUntilLoop.description=创建 until 循环
action.ShGenerateWhileLoop.text=While 循环
action.ShGenerateWhileLoop.description=创建 while 循环
action.ShGenerateForLoop.text=For 循环
action.ShGenerateForLoop.description=创建 for 循环
action.runShellFileAction.text=运行文件
action.runShellFileAction.description=运行终端当前的 shell 文件

sh.color.function.declaration=函数声明
sh.color.conditional.operators=条件运算符
sh.color.commands.subshell.command=命令//subshell 命令
sh.color.commands.generic.command=命令//泛型命令
sh.color.redirection=重定向
sh.color.backquotes=反引号
sh.color.braces.square.brackets=大括号//方括号
sh.color.braces.curly.brackets=大括号//大括号
sh.color.braces.parentheses=大括号//圆括号
sh.color.here.documents.end=Here 文档结束
sh.color.here.documents.start=Here 文档开始
sh.color.here.documents=Here 文档
sh.color.shebang.comment=Shebang 注释
sh.color.line.comment=行注释
sh.color.raw.string=原始字符串
sh.color.string=字符串
sh.color.variables.composed.variable=变量//组合变量
sh.color.variables.variable.declaration=变量//变量声明
sh.color.variables.variable.usage=变量//变量用法
sh.color.keyword=关键字
sh.color.number=数字

sh.run.interpreter.options=解释器选项:
sh.run.interpreter.path=解释器路径:
sh.run.interpreter=解释器
sh.run.interpreter.not.found=找不到解释器
sh.run.interpreter.should.be.executable=解释器应为可执行文件
sh.run.working.dir=工作目录:
sh.run.working.dir.not.found=找不到工作目录
sh.run.script.options=脚本选项:
sh.run.script.path=脚本路径:
sh.run.script.not.found=找不到 Shell 脚本
sh.run.execute.terminal=在终端中执行
sh.run.environment.variables=环境变量:
sh.run.execute.script.text=脚本文本
sh.run.execute.script.text.title=脚本文本:
sh.run.execute.script.file=脚本文件
sh.run.execute=执行:

sh.update=更新
sh.install=安装
sh.no.thanks=不
sh.skip.version=跳过此版本
sh.download=下载
sh.invalid.path=无效路径。
find.usages.type.function=函数
# {0} is non-translated 'Shell Script' - language name
sh.run.configuration.description.0.configuration={0} 配置
error.message.cannot.determine.shell.script.parent.directory=无法确定 shell 脚本的父目录
check1000.is.not.used.specially.and.should.therefore.be.escaped=$ 应转义。
check1001.this.o.will.be.a.regular.o.in.this.context=在此上下文中，\\o 将是常规的 'o'。
check1003.want.to.escape.a.single.quote.echo.this.is.how.it.s.done=要转义单引号? 对 'This is how it'\'s done' 进行 echo。
check1004.this.backslash.linefeed.is.literal.break.outside.single.quotes.if.you.just.want.to.break.the.line=此反斜杠+换行符是文字。如果您想断行，应在单引号外断行。
check1007.remove.space.after.if.trying.to.assign.a.value.or.for.empty.string.use.var=如果要赋值，请移除 '=' 后的空格(对于空字符串，请使用 var=' … )。
check.1008.this.shebang.was.unrecognized.shellcheck.only.supports.sh.bash.dash.ksh.add.a.shell.directive.to.specify=此 shebang 未被识别。ShellCheck 仅支持 sh/bash/dash/ksh。添加 'shell' 指令进行指定。
check.1009.the.mentioned.parser.error.was.in=提及的解析器错误位于…
check.1010.use.semicolon.or.linefeed.before.done.or.quote.to.make.it.literal=在 'done' 前使用分号或换行符(或加引号使其为文字)。
check.1011.this.apostrophe.terminated.the.single.quoted.string=这个撇号终止了带单引号的字符串!
check.1012.is.just.literal.t.here.for.tab.use.printf.instead=`\t` 此处仅为文字 `t`。要添加制表符，请改用 "$(printf '\t')"。
check.1014.use.if.cmd.then.to.check.exit.code.or.if.cmd.to.check.output=使用 'if cmd; then ..' 检查退出代码，或使用 'if [ "$(cmd)" = .. ]' 检查输出。
check.1015.this.is.a.unicode.double.quote.delete.and.retype.it=这是 Unicode 双引号。将其删除并重新输入。
check.1016.this.is.a.unicode.single.quote.delete.and.retype.it=这是 Unicode 的单引号。将其删除并重新输入。
check.1017.literal.carriage.return.run.script.through.tr.d=文字回车。通过 `tr -d '\n'` 运行脚本。
check.1018.this.is.a.unicode.non.breaking.space.delete.it.and.retype.as.space=这是 Unicode 的不间断空格。将其删除并使用空格键重新输入。
check.1019.expected.this.to.be.an.argument.to.the.unary.condition=这应是一元条件的参数。
check.1020.you.need.a.space.before.the.if.single.then.else=在 `]` 或 `]]` 前添加空格
check.1026.if.grouping.expressions.inside.use=如果对 [[..]] 内部的表达式分组，请使用 ( .. )。
check.1028.in.you.have.to.escape.or.preferably.combine.expressions=在 [..] 中需要转义 \\( \\) 或优先结合 [..] 表达式。
check.1029.in.you.shouldn.t.escape.or=在 `[[..]]` 中不应转义 `(` 或 `)`。
check.1035.you.need.a.space.here=在此处添加空格。
check.1036.is.invalid.here.did.you.forget.to.escape.it=`(` 在此处无效。您是否忘记将其转义?
check.1037.braces.are.required.for.positionals.over.9.e.g.10=大于 9 (例如 10)的位置需要大括号。
check.1038.shells.are.space.sensitive.use.cmd.not.cmd=Shell 会受空格影响。使用 '< <(cmd)' 而非 '<<(cmd)'。
check.1039.remove.indentation.before.end.token.or.use.and.indent.with.tabs=移除结束令牌前的缩进(或使用 `<<-` 并以制表符缩进)。
check.1040.when.using.you.can.only.indent.with.tabs=使用 <<- 时，使用制表符缩进。
check.1041.found.eof.further.down.but.not.on.a.separate.line=在更下方找到 'eof'，但不在单独的一行中。
check.1042.found.eof.further.down.but.not.on.a.separate.line=在更下方找到 'eof'，但不在单独的一行中。
check.1044.couldn.t.find.end.token.eof.in.the.here.document=在 here 文档中找不到结束令牌 `EOF'。
check.1045.it.s.not.foo.bar.just.foo.bar='foo \\&; bar' 中的分号冗余。应为 'foo \\& bar'。
check.1046.couldn.t.find.fi.for.this.if=找不到此 'if' 的 'fi'。
check.1047.expected.fi.matching.previously.mentioned.if='fi' 应匹配先前提及的 'if'。
check.1048.can.t.have.empty.then.clauses.use.true.as.a.no.op=不能有空 then 子句(使用 'true' 作为无操作)。
check.1049.did.you.forget.the.then.for.this.if=您是否忘记了为这个 'if' 指定 'then'?
check.1045.expected.then=应为 'then'。
check.1051.semicolons.directly.after.then.are.not.allowed.just.remove.it=不允许在 'then' 后面直接使用分号。
check.1052.semicolons.directly.after.then.are.not.allowed.just.remove.it=不允许在 'then' 后面直接使用分号。
check.1053.semicolons.directly.after.else.are.not.allowed.just.remove.it=不允许在 'else' 后面直接使用分号。
check.1054.you.need.a.space.after.the=在 '{' 后面添加空格。
check.1058.expected.do=应为 `do`。
check.1061.couldn.t.find.done.for.this.do=找不到此 'do' 的 'done'。
check.1062.expected.done.matching.previously.mentioned.do='done' 应匹配先前提及的 'do'。
check.1064.expected.a.to.open.the.function.definition=应使用 '{' 来打开函数定义。
check.1065.trying.to.declare.parameters.don.t.use.and.refer.to.params.as.1.2=不声明形参。使用 ()，并将形参引用为 $1、$2，以此类推。
check.1066.don.t.use.on.the.left.side.of.assignments=不在赋值的左侧使用 '$'。
check.1068.don.t.put.spaces.around.the.in.assignments=不在赋值中的 '=' 周围放置空格。
check.1069.you.need.a.space.before.the=在 '[' 前面添加空格。
check.1071.shellcheck.only.supports.sh.bash.dash.ksh.scripts.sorry=ShellCheck 仅支持 sh/bash/dash/ksh 脚本。
check.1072.unexpected=意外 ..
check.1073.couldn.t.parse.this.thing.fix.to.allow.more.checks=无法解析此项。修正以允许更多检查。
check.1075.use.elif.instead.of.else.if=使用 'elif' 而非 'else if'。
check.1077.for.command.expansion.the.tick.should.slant.left.vs=对于命令扩展，请使用反引号: (` vs ´)。
check.1078.did.you.forget.to.close.this.double.quoted.string=您是否忘记关闭带双引号的字符串?
check.1079.this.is.actually.an.end.quote.but.due.to.next.char.it.looks.suspect=这是右引号，但是由于下一个字符的缘故，它看起来很可疑。
check.1081.scripts.are.case.sensitive.use.if.not.if=脚本区分大小写。使用 'if'，而不是 'If'。
check.1082.this.file.has.a.utf.8.bom.remove.it.with.lc.ctype.c.sed.1s.yourscript=此文件具有 UTF-8 BOM。使用此命令将其移除: LC_CTYPE=C sed '1s/^...//' < yourscript
check.1083.this.is.literal.check.expression.missing.or.quote.it=此 `{`/`}` 为文字。检查是否缺少 `;` 或使用引号将表达式引起。
check.1084.use.not.for.the.shebang=该 shebang 不是 '!#'，而是 '#!'。
check.1086.don.t.use.on.the.iterator.name.in.for.loops=不要在 for 循环的迭代器名称中使用 '$'。
check.1087.use.braces.when.expanding.arrays.e.g.array.idx.or.var.to.quiet=展开数组时使用大括号，例如: ${array[idx]} (或 ${var}[.. 以静默)。
check.1088.parsing.stopped.here.invalid.use.of.parentheses=解析到此为止。括号使用是否无效?
check.1089.parsing.stopped.here.is.this.keyword.correctly.matched.up=解析在此处停止。此关键字是否正确匹配?
check.1090.can.t.follow.non.constant.source.use.a.directive.to.specify.location=无法追踪非常量源。使用指令指定位置。
check.1091.not.following.error.message.here=未遵循: (此处为错误消息)
check.1094.parsing.of.sourced.file.failed.ignoring.it=解析源文件失败。忽略。
check.1095.you.need.a.space.or.linefeed.between.the.function.name.and.body=您需要在函数名称和体之间使用空格或换行符。
check.1097.unexpected.for.assignment.use.for.comparison.use=意外 '=='。对于赋值，请使用 '='。对于比较，请将 '==' 表达式放在方括号中。
check.1098.quote.escape.special.characters.when.using.eval.e.g.eval.a.b=使用 eval 时，使用引号或转义特殊字符，例如: eval "a=(b)"。
check.1099.you.need.a.space.before.the=在 '#' 前面添加空格。
check.1100.this.is.a.unicode.dash.delete.and.retype.as.ascii.minus=这是 Unicode 短划线。删除并重新输入为 ASCII 减号字符。
check.1101.delete.trailing.spaces.after.to.break.line.or.use.quotes.for.literal.space=删除 \\ 后面的尾随空格以断行(或用引号表示文字空格)。
check.1102.shells.disambiguate.differently.or.not.at.all.if.the.first.should.start.command.substitution.add.a.space.after.it=Shell 以不同方式消除 $(( 歧义或根本不消除歧义。如果首个 $( 应开始命令替换，则在其后添加空格。
check.1104.use.not.just.for.the.shebang=该 shebang 不是 '!'，而是 '#!'。
check.1105.shells.disambiguate.differently.or.not.at.all.if.the.first.should.start.a.subshell.add.a.space.after.it=Shell 以不同方式消除 (( 歧义或根本不消除歧义。如果首个 ( 应开始 subshell，则在其后添加空格。
check.1107.this.directive.is.unknown.it.will.be.ignored=该指令未知。它将被忽略。
check.1108.you.need.a.space.before.and.after.the=在 '=' 前后添加空格。
check.1109.this.is.an.unquoted.html.entity.replace.with.corresponding.character=这是未加引号的 HTML 实体。替换为相应的字符。
check.1110.this.is.a.unicode.quote.delete.and.retype.it.or.quote.to.make.literal=这是 Unicode 引号。删除或重新输入(或加引号使其为文字)。
check.1111.this.is.a.unicode.quote.delete.and.retype.it.or.ignore.singlequote.for.literal=这是 Unicode 引号。删除或重新输入(或加单引号使其为文字)。
check.1112.this.is.a.unicode.quote.delete.and.retype.it.or.ignore.doublequote.for.literal=这是 Unicode 引号。删除或重新输入(或加双引号使其为文字)。
check.1113.use.not.just.for.the.sheban=该 shebang 不是 '#'，而是 '#!'。
check.1114.remove.leading.spaces.before.the.shebang=移除 shebang 的前导空格。
check.1115.remove.spaces.between.and.in.the.shebang=在 shebang 中移除 '#' 和 '!' 之间的空格。
check.1116.missing.on.a.expression.or.use.for.arrays='$((..))' 表达式中缺少 '$'? 如果是数组，请使用 '( ('。
check.1117.backslash.is.literal.in.prefer.explicit.escaping.n=反斜杠为 "\n" 中的文字。首选显式转义: "\\n"。
check.1118.delete.whitespace.after.the.here.doc.end.token=删除 here document 结束标记后面的空格。
check.1119.add.a.linefeed.between.end.token.and.terminating=在结束令牌和终止 ')' 之间添加换行符。
check.1120.no.comments.allowed.after.here.doc.token.comment.the.next.line.instead=here document 标记后面不允许注释。改为注释下一行。
check.1121.add.terminators.and.other.syntax.on.the.line.with.the.not.here=在含有 '<<' 的行中添加 ;/\\& 终止符(和其他语法)，而不是在这里添加。
check.1122.nothing.allowed.after.end.token.to.continue.a.command.put.it.on.the.line.with.the=结束令牌后面不允许有任何内容。要继续一条命令，请将其放在包含 `<<` 的行中。
check.1123.shellcheck.directives.are.only.valid.in.front.of.complete.compound.commands.like.if.not.e.g.individual.elif.branches=ShellCheck 指令仅在 `if` 等完整复合命令(而非单个 `elif` 分支)前有效。
check.1124.shellcheck.directives.are.only.valid.in.front.of.complete.commands.like.case.statements.not.individual.case.branches=ShellCheck 指令仅在完整命令前有效，如 'case' 语句，而非单个 case 分支。
check.1126.place.shellcheck.directives.before.commands.not.after=将 ShellCheck 指令放在命令前面，而不是后面。
check.1127.was.this.intended.as.a.comment.use.in.sh=如果这是注释，请使用 `#`。
check.1128.the.shebang.must.be.on.the.first.line.delete.blanks.and.move.comments=shebang 必须在第一行。删除空格并移动注释。
check.1129.you.need.a.space.before.the=在 '!' 前面添加空格。
check.1130.you.need.a.space.before.the=在 ':' 前面添加空格。
check.1131.use.elif.to.start.another.branch=使用 `elif` 开始另一个分支。
this.terminates.the.command.escape.it.or.add.space.after.to.silence=此 `\\&` 会终止命令。将其转义或在 `\\&` 后面添加空格以静默。
unexpected.start.of.line.if.breaking.lines.should.be.at.the.end.of.the.previous.one=意外的新行首。如需断行，|/||/\\&\\& 应在前一个行的末尾。
arrays.implicitly.concatenate.in.use.a.loop.or.explicit.instead.of=数组在 `[[ ]]` 中隐式串联。使用循环(或显式 '*' 来代替 '@')。
arrays.don.t.work.as.operands.in.use.a.loop.or.concatenate.with.instead.of=数组在 '[ ]' 中不作为操作数使用。使用循环(或以 '*' 代替 '@' 来进行串联)。
fgrep.is.non.standard.and.deprecated.use.grep.f.instead=fgrep 非标准，已弃用。请改用 grep -F。
egrep.is.non.standard.and.deprecated.use.grep.e.instead=egrep 非标准，已弃用。请改用 grep -E。
this.pattern.will.never.match.the.case.statement.s.word.double.check.them=此模式决不会与 case 语句的单词匹配。
this.word.is.constant.did.you.forget.the.on.a.variable=此单词为常量。您是否忘记了变量上的 '$' 字符?
the.arguments.to.this.comparison.can.never.be.equal.make.sure.your.syntax.is.correct=此比较的参数永远不能相等。确保您的语法正确。
this.array.element.has.no.value.remove.spaces.after.or.use.for.empty.string=该数组元素没有值。移除 '=' 后面的空格，或使用 "" 表示空字符串。
the.here.is.literal.to.assign.by.index.use.index.value.with.no.spaces.to.keep.as.literal.quote.it=此处的等号字符 '=' 是文字。要按索引赋值，请使用 ( [index]=值 )，不带空格。要保留为文字，请使用引号。
elements.in.associative.arrays.need.index.e.g.array.index.value=关联数组中的元素要求索引，例如: array=( [index]=value )。
you.can.t.have.between.this.redirection.and.the.command.it.should.apply.to=您不能在此重定向与其应用的命令之间放置 '|'。
this.redirection.doesn.t.have.a.command.move.to.its.command.or.use.true.as.no.op=此重定向没有命令。移动到其命令(或使用 'true' 作为无操作)。
ash.scripts.will.be.checked.as.dash.add.shellcheck.shell.dash.to.silence=Ash 脚本将被检查为 Dash。添加 '# shellcheck shell=dash' 以静默。
tempfile.is.deprecated.use.mktemp.instead=tempfile 已弃用。请改用 mktemp。
some.finds.don.t.have.a.default.path.specify.explicitly=部分查找没有默认路径。显式指定 '.'。
quote.arguments.to.unset.so.they.re.not.glob.expanded=将实参放在引号中以忽略 glob 语法。
this.format.string.has.2.variables.but.is.passed.1.arguments=该格式字符串有 2 个变量，但传递了 1 个实参。
this.printf.format.string.has.no.variables.other.arguments.are.ignored=此 printf 格式字符串没有变量。其他参数被忽略。
check.exit.code.directly.with.e.g.if.mycmd.not.indirectly.with=使用 'if mycmd;' 直接检查退出代码，而不是使用 '$'? 间接检查。
bash.does.not.support.multidimensional.arrays.use.1d.or.associative.arrays=Bash 不支持多维数组。只使用一维数组或关联数组。
use.array.item.to.append.items.to.an.array=使用 'array+=("item")' 将条目追加到数组。
variable.was.used.as.an.array.but.is.now.assigned.a.string=变量被用作数组，但现在被分配了一个字符串。
time.is.undefined.for.compound.commands.time.sh.c.instead=未对组合命令定义 'time'，改用 'time sh -c'。
time.is.undefined.for.pipelines.time.single.stage.or.bash.c.instead=未对管道定义 'time'。改用单阶段的 `time` 或 `time bash -c`。
quote.this.invalid.brace.expansion.since.it.should.be.passed.literally.to.eval=为此无效大括号展开加引号，因为它应照字面传递给 eval。
when.used.with.p.m.only.applies.to.the.deepest.directory=与 '-p' 一起使用时，'-m' 仅适用于最深的目录。
sigkill.sigstop.can.not.be.trapped=SIGKILL 和 SIGSTOP 无法被捕获。
trapping.signals.by.number.is.not.well.defined.prefer.signal.names=按数字捕获信号的定义不明确。首选信号名称。
numerical.eq.does.not.dereference.in.expand.or.use.string.operator=数字 '-'eq 在 [..] 中不取消引用。展开或使用字符串运算符。
in.dash.something.is.not.supported=Dash 中不支持此功能。
local.is.only.valid.in.functions='local' 仅在函数中有效。
this.parent.loop.has.its.index.variable.overridden=此父循环的索引变量被重写。
prefer.p.q.as.p.a.q.is.not.well.defined=首选 '[ p ] \\&\\& [ q ]'，因为 '[ p -a q ]' 的定义不明确。
this.nested.loop.overrides.the.index.variable.of.its.parent=此嵌套循环重写其父级的索引变量。
use.cd.exit.in.case.cd.fails=如果持续部署失败，请使用 cd … || exit。
this.does.not.export.foo.remove.for.that.or.use.var.to.quiet=这不会导出 'FOO'。移除 '$' 和 '${}' 或使用 '${var?}' 以静默。
read.without.r.will.mangle.backslashes=没有 '-r' 的 'read' 将扰乱反斜杠。
instead.of.1.use.true=使用 'true' 代替 '[ 1 ]'。
instead.of.true.just.use.true=不使用 '[ true ]'，而是使用 'true'。
0.is.true.use.false.instead='[ 0 ]' 为 true。改用 'false'。
false.is.true.remove.the.brackets='[ false ]' 为 true。移除中括号。
argument.to.implicit.n.is.always.true.due.to.literal.strings=由于文字字符串，隐式 '-n' 的实参始终为 true。
injecting.filenames.is.fragile.and.insecure.use.parameters=注入文件名脆弱且不安全。使用参数。
declare.and.assign.separately.to.avoid.masking.return.values=分别声明和分配，避免掩盖返回值。
var.is.referenced.but.not.assigned='var' 被引用但未赋值。
possible.misspelling.myvariable.may.not.be.assigned.but.my.variable.is=可能拼写错误: MYVARIABLE 可能未分配，而分配的是 MY_VARIABLE。
can.only.return.0.255.other.data.should.be.written.to.stdout=只能返回 0-255。其他数据应写入 stdout。
only.one.integer.0.255.can.be.returned.use.stdout.for.other.data=只能返回一个整数 0-255。将 stdout 用于其他数据。
exec.does.not.automatically.invoke.a.shell.use.exec.sh.c.for.that='-exec' 不自动调用 shell。为此使用 '-exec sh -c'。
remove.for.numeric.index.or.escape.it.for.string=对于数字索引，移除 '$' 和 '${}'；对于字符串，将其转义。
tips.depend.on.target.shell.and.yours.is.unknown.add.a.shebang=提示取决于目标 shell。添加 shebang。
literal.tilde.in.path.works.poorly.across.programs=PATH 中的文字颚化符在各个程序之间的效果不佳。
this.action.ignores.everything.before.the.o.use.to.group=此操作将忽略 '-o' 前面的所有内容。使用 \\( \\) 分组。
argument.mixes.string.and.array.use.or.separate.argument=实参混合字符串和数组。使用 '*' 或单独的实参。
e.doesn.t.work.with.globs.use.a.for.loop='-e' 不适用于 glob。使用 for 循环。
use.grep.q.instead.of.comparing.output.with.n=使用 'grep -q' 而不是将输出与 '[ -n .. ]' 相比较。
aliases.can.t.use.positional.parameters.use.a.function=别名无法使用位置参数。使用函数。
did.you.mean.ifs=是否为 IFS=$'\t' ?
word.is.on.the.form.a.b.c.b.indicated.did.you.mean.abc.or.a.b.c=\ 单词格式为“A”B“C”(表示 B)。您是否指的是“ABC”或“A\\”B\\“C”?
this.expands.when.defined.not.when.used.consider.escaping=在定义时展开，而不是在使用时。考虑转义。
eq.is.for.integer.comparisons.use.instead='-eq' 用于整数比较。改用 '='。
consider.using.cmd1.cmd2.file.instead.of.individual.redirects=考虑使用 '{ cmd1; cmd2; } >> file' 替换单个重定向。
expanding.an.array.without.an.index.only.gives.the.first.element=展开没有索引的数组只会得到第一个元素。
consider.using.grep.c.instead.of.grep.wc=考虑使用 'grep -c' 代替 'grep|wc'。
brace.expansions.and.globs.are.literal.in.assignments.quote.it.or.use.an.array=大括号展开和 glob 是赋值中的文字。使用引号或数组。
assigning.an.array.to.a.string.assign.as.array.or.use.instead.of.to.concatenate=将数组分配给字符串! 分配为数组或使用 '*' 代替 '@' 进行串联。
path.is.the.shell.search.path.use.another.name=PATH 是 shell 搜索路径。使用其他名称。
is.not.a.valid.operator.use.a.b.instead='>=' 不是有效运算符。改用 '! a < b'。
to.assign.a.variable.use.just.var.value.no.set=要分配变量，不要使用 'set ..'，而是使用 'var=value'。
foo.references.arguments.but.none.are.ever.passed='foo' 引用了实参，但这些实参从未被传递。
use.foo.if.function.s.1.should.mean.script.s.1=如果函数的 '$1' 实参应表示脚本的 '$1' 实参，则使用 'foo "$@"'。
to.run.commands.as.another.user.use.su.c.or.sudo=要以其他用户身份运行命令，请使用 'su -c' 或 'sudo'。
useless.echo.instead.of.cmd.echo.foo.just.use.cmd.foo=冗余的 echo? 不使用 'cmd $(echo foo)'，而是使用 'cmd foo'。
use.var.to.ensure.this.never.expands.to=使用“${var:?}”确保其绝不展开至 /*。
warning.deletes.a.system.directory=警告: 删除系统目录。
function.keyword.is.non.standard.delete.it='function' 关键字非标准。将其删除。
in.use.instead.of.o=在 '[\\[..]]' 中，不使用 '-o'，而是使用 '||'。
instead.of.a.b.use.a.b=不使用 '[ a || b ]'，而是使用 '[ a ] || [ b ]'。
in.use.instead.of.a=在 '[\\[..]]' 中，不使用 '-a'，而是使用 '\\&\\&'。
instead.of.a.b.use.a.b2=不使用 '[ a \\&\\& b ]'，而是使用 '[ a ] \\&\\& [ b ]'。
sc2106.this.only.exits.the.subshell.caused.by.the.pipeline=SC2106: 这仅退出由管道引起的 subshell。
break.is.only.valid.in.loops=`break` 仅在循环中有效。
in.functions.use.return.instead.of.break=在函数中，不使用 'break'，而是使用 'return'。
use.a.subshell.to.avoid.having.to.cd.back=使用 ( subshell ) 避免必须反向持续部署。
ranges.can.only.match.single.chars.mentioned.due.to.duplicates=范围只能匹配单个字符(由于重复而提及)。
named.class.needs.outer.e.g.digit=命名类需要外部 '[]'，例如: [[:digit:]\\]
use.for.arithmetics.e.g.i.i.2=为算数使用 `$((..))`，例如: i=$((i + 2))
this.expansion.will.not.see.the.mentioned.assignment=此展开将看不到提及的赋值。
this.assignment.is.only.seen.by.the.forked.process=仅在复刻进程中才能看到此赋值。
on.most.os.shebangs.can.only.specify.a.single.parameter=在大多数操作系统中，shebang 只能指定一个形参。
add.dev.null.to.prevent.ssh.from.swallowing.stdin=添加 '< /dev/null' 以防止 ssh 吞下 stdin。
sc2094.make.sure.not.to.read.and.write.the.same.file.in.the.same.pipeline=SC2094 确保不要在同一管道中读取和写入同一文件。
remove.exec.if.script.should.continue.after.this.command=如果脚本应在此命令后继续，则移除 "exec "。
remove.backticks.to.avoid.executing.output=移除反引号以避免执行输出。
remove.surrounding.to.avoid.executing.output=移除环绕的 '$()' 以避免执行输出。
quotes.backslashes.in.this.variable.will.not.be.respected=该变量中的引号和反斜杠将不被遵循。
quotes.backslashes.will.be.treated.literally.use.an.array=引号和反斜杠将按文字处理。使用数组。
tilde.does.not.expand.in.quotes.use.home=引号中的颚化符不会展开。使用 $HOME。
quote.eof.to.make.here.document.expansions.happen.on.the.server.side.rather.than.on.the.client=在 'EOF' 周围添加引号，以使 here document 在服务器端而不是在客户端展开。
double.quote.to.prevent.globbing.and.word.splitting=使用双引号防止乱码和单词分割。
remove.or.use.expr.to.avoid.executing.output=移除 '$' 或使用 '_=$((expr))' 以避免执行输出。
to.expand.via.indirection.use.name.foo.n.echo.name=要通过间接展开，请使用 name="foo$n"; echo "${!name}"。
can.t.match.globs.use.or.grep=`[ .. ]` 无法匹配 glob。使用 `[[ .. ]]` 或 grep。
numbers.with.leading.0.are.considered.octal=认为前导 0 的数字为八进制。
doesn.t.support.decimals.use.bc.or.awk='(( ))' 不支持十进制。使用 'bc' 或 'awk'。
this.expression.is.constant.did.you.forget.a.somewhere=此表达式为常量。您是否遗忘了 `$`?
you.need.spaces.around.the.comparison.operator=比较运算符周围需要空格。
don.t.quote.rhs.of.it.ll.match.literally.rather.than.as.a.regex=不要为 =~ 的 rhs 加引号，它会按文字匹配而不是作为正则表达式。
can.t.use.in.use.instead=无法在 `[ ]` 中使用 `=~`。改用 `[[..]]`。
decimals.are.not.supported.either.use.integers.only.or.use.bc.or.awk.to.compare=不支持十进制。仅使用整数，或使用 'bc' 或 'awk' 进行比较。
is.for.string.comparisons.use.gt.instead='>' 用于字符串比较。改用 '-gt'。
n.doesn.t.work.with.unquoted.arguments.quote.or.use=`-n` 不适用于未加引号的参数。加引号或使用 ``[[ ]]``。
to.redirect.stdout.stderr.2.1.must.be.last.or.use.cmd.file.2.1.to.clarify=要重定向 stdout+stderr，'2>\\&1' 必须是最后一个(或者用 '{ cmd > file; } 2>\\&1' 说明)。
double.quote.array.expansions.to.avoid.re.splitting.elements=用双引号引起数组扩展，避免重新分割元素。
missing.or.terminating.exec.you.can.t.use.and.has.to.be.a.separate.quoted.argument=缺少 ';' 或 '+' 将终止 '-exec'。不使用 |/||/\\&\\&，并使用引号将 ';' 引起。
since.you.double.quoted.this.it.will.not.word.split.and.the.loop.will.only.run.once=由于您用双引号将其引起，因此单词不会分割，并且循环将只运行一次。
this.is.interpreted.as.a.shell.file.redirection.not.a.comparison=这被解释为 shell 文件重定向，而非比较。
use.single.quotes.otherwise.this.expands.now.rather.than.when.signalled=仅在发出信号时才使用单引号展开，而不是立即展开。
grep.uses.regex.but.this.looks.like.a.glob=Grep 使用正则表达式，但这看起来像是 glob。
quote.the.grep.pattern.so.the.shell.won.t.interpret.it=为 grep 模式加引号，这样 shell 就不会解释它。
quote.the.parameter.to.name.so.the.shell.won.t.interpret.it=为 '-name' 的形参加引号，这样 shell 就不会解释它。
quote.parameters.to.tr.to.prevent.glob.expansion=为 'tr' 的形参加引号，防止 glob 展开。
don.t.use.variables.in.the.printf.format.string.use.printf.s.foo=不要在 printf 格式字符串中使用变量。而是使用如下语法: printf "..%s.." "$foo"。
unknown.unaryoperator=未知一元运算符。
unknown.binary.operator=未知二元运算符。
you.probably.wanted.here=使用 '\\&\\&'.
use.spaces.not.commas.to.separate.array.elements=使用空格而非逗号分隔数组元素。
quote.the.rhs.of.in.to.prevent.glob.matching=在 '[[ ]]' 中为 'rhs of =' 加引号，防止 glob 匹配。
bash.doesn.t.support.variables.in.brace.range.expansions=Bash 在大括号范围展开中不支持变量。
this.expression.is.constant.did.you.forget.the.on.a.variable=此表达式为常量。您是否遗忘了变量上的 `$`?
is.for.regex.but.this.looks.like.a.glob.use.instead='=~' 用于正则表达式，但这看起来像是 glob。改用 '='。
use.with.quotes.to.prevent.whitespace.problems=使用“$@”(不带引号)防止空格问题。
quote.this.to.prevent.word.splitting=使用引号将其引起，以防止单词分割。
iterating.over.ls.output.is.fragile.use.globs=对 ls 输出进行迭代较为脆弱。使用 glob。
for.loops.over.find.output.are.fragile.use.find.exec.or.a.while.read.loop=find 输出上的 for 循环较脆弱。使用 'find -exec' 或 while read 循环。
this.loop.will.only.ever.run.once.for.a.constant.value.did.you.perhaps.mean.to.loop.over.dir.var.or.cmd=此循环只对一个常量值运行一次。是否想在 'dir/*'、'$var' 或 '$(cmd)'上循环?
this.is.a.literal.string.to.run.as.a.command.use.instead.of=这是文字字符串。要作为命令运行，不要使用 '..'，而是使用 '$(..)'。
bin.sh.was.specified.so.is.not.supported.even.when.sh.is.actually.bash='#!/bin/sh' 已指定，因此即使 sh 实际是 bash 也不支持 ____。
in.posix.sh.something.is.undefined=在 POSIX sh 中，某些行为未定义。
use.print0.0.or.find.exec.to.allow.for.non.alphanumeric.filenames=使用 '-print0'、'-0' 或 'find -exec +'，以允许使用非字母数字文件名。
to.assign.the.output.of.a.command.use.var.cmd=要分配命令的输出，请使用 'var=$(cmd)'。
if.you.wanted.to.assign.the.output.of.the.pipeline.use.a.b.c=如果您想分配管道的输出，请使用 'a=$(b | c)'。
use.glob.or.glob.so.names.with.dashes.won.t.become.options=使用 './\\*glob*' 或 '-- \\*glob*'，以使带短划线的名称不会成为选项。
foo.appears.unused.verify.it.or.export.it='foo' 似乎未使用。对其进行验证或导出。
shell.functions.can.t.be.passed.to.external.commands=Shell 函数不能传递给外部命令。
use.own.script.or.sh.c.to.run.this.from.su=使用自身脚本或 sh -c '..' 从 su 运行。
var.was.modified.in.a.subshell.that.change.might.be.lost=在 subshell 中对 'var' 进行了修改。这种变更可能丢失。
modification.of.var.is.local.to.subshell.caused.by.pipeline='var' 的修改是局部的(对于管道引起的 subshell)。
note.that.unescaped.this.expands.on.the.client.side=如果未转义，将在客户端展开。
echo.won.t.expand.escape.sequences.consider.printf='echo' 不会展开转义序列。考虑使用 'printf'。
the.surrounding.quotes.actually.unquote.this.remove.or.escape.them=周围的引号实际取消了引号。将其移除或转义。
this.word.is.outside.of.quotes.did.you.intend.to.nest.single.quotes.instead=这个词在引号之外。您是想 '嵌套 '"'单引号'"' 吗?
make.sure.all.escape.sequences.are.enclosed.in.to.prevent.line.wrapping.issues=确保所有转义序列都被 `\\[..\\]` 封闭，防止出现换行问题
sudo.doesn.t.affect.redirects.use.sudo.tee.file=`sudo` 不影响重定向。使用 `..| sudo tee file`
note.that.unlike.globs.o.here.matches.ooo.but.not.oscar=请注意，不同于 glob，'o*' 在此处匹配 'ooo' 而非 'oscar'
don.t.use.around.ranges.in.tr.it.replaces.literal.square.brackets=不要在 'tr' 范围内使用 '[]'，它会替换文字方中括号。
tr.replaces.sets.of.chars.not.words.mentioned.due.to.duplicates='tr' 替换字符集，而非单词(由于重复而提及)。
use.upper.to.support.accents.and.foreign.alphabets=使用 '[:upper:]' 支持重音和外来字母。
use.lower.to.support.accents.and.foreign.alphabets=使用 '[:lower:]' 支持重音和外来字母。
increase.precision.by.replacing.a.b.c.with.a.c.b=将 'a/b\\*c' 替换为 'a\\*c/b' 以提高精度。
expressions.don.t.expand.in.single.quotes.use.double.quotes.for.that=表达式不应用单引号展开，使用双引号。
note.that.a.b.c.is.not.if.then.else.c.may.run.when.a.is.true=注意，'A \\&\\& B || C' 并非 'if-then-else'。A 为 true 时 C 可能运行。
this.will.expand.once.before.find.runs.not.per.file.found=这将在 find 运行之前展开一次，而不是针对每个文件。
to.read.lines.rather.than.words.pipe.redirect.to.a.while.read.loop=要读取行而不是单词，应通过管道通向或重定向输出到 'while read' 循环。
use.find.instead.of.ls.to.better.handle.non.alphanumeric.filenames=使用 `find` 而不是 `ls` 以更好地处理非字母数字文件名。
don.t.use.ls.grep.use.a.glob.or.a.for.loop.with.a.condition.to.allow.non.alphanumeric.filenames=不要使用 'ls | grep'。使用 glob 或 for 循环与条件，以允许使用非字母数字文件名。
sc2009.consider.using.pgrep.instead.of.grepping.ps.output=SC2009 考虑使用 pgrep 代替 grepping ps 输出。
echo.doesn.t.read.from.stdin.are.you.sure.you.should.be.piping.to.it='echo' 不从 stdin 读取。不建议通过管道来通向它。
use.instead.of.deprecated=不使用弃用的 '$[..]'，而是使用 '$((..))'。
use.notation.instead.of.legacy.backticked=不使用过去的反引号 `` `...` `，而是使用 '$(...)' 表示法。
useless.echo.instead.of.echo.cmd.just.use.cmd=冗余的 `echo`? 不使用 `echo $(cmd)`，而是使用 `cmd`。
is.unnecessary.on.arithmetic.variables='$' 和 '${}' 在算术变量上不必要。
expr.is.antiquated.consider.rewriting.this.using.or='expr' 已过时。可使用 '$((..))'、'${}' 或 '\\[\\[ \\]\\]' 进行重写。
useless.cat.consider.cmd.file.or.cmd.file.instead=冗余的 'cat'。可以考虑改用 'cmd < file | ..' 或 'cmd file | ..'。
sc2001.see.if.you.can.use.variable.search.replace.instead=SC2001: 确认是否可改用 ${variable//search/replace}。
consider.adding.a.default.case.even.if.it.just.exits.with.error=考虑添加默认 '*)' case，即便它因为错误而退出。
flip.leading.and.if.this.should.be.a.quoted.substitution=如果这应是加引号的替换，则翻转前导 '$' 和 '"'。
this.shebang.specifies.a.directory.ensure.the.interpreter.is.a.file=该 shebang 指定目录。确保解释器是文件。
d.only.applies.to.the.first.expansion.of.this.glob.use.a.loop.to.check.any.all='-d' 仅适用于此 glob 的第一个展开。使用循环检查任意一个/全部。
prefer.explicit.n.to.check.non.empty.string.or.use.ne.to.check.boolean.integer=首选显式 '-n' 检查非空字符串。使用 '=' 或 '-ne' 检查布尔值和整数。
prefer.explicit.n.to.check.for.output.or.run.command.without.to.check.for.success=首选显式 '-n' 检查输出。运行无 '[' 和 '[[' 的命令以检查成功与否。
can.only.exit.with.status.0.255.other.data.should.be.written.to.stdout.stderr=只能以 0-255 状态退出。其他数据应写入 stdout/stderr。
the.exit.status.can.only.be.one.integer.0.255.use.stdout.for.other.data=退出状态只能是一个整数 0-255。将 stdout 用于其他数据。
the.dot.command.does.not.support.arguments.in.sh.dash.set.them.as.variables=dot 命令不支持 sh/dash 中的参数。将它们设置为变量。
ensure.the.shebang.uses.the.absolute.path.to.the.interpreter=确保 shebang 指定解释器的绝对路径。
redirecting.to.from.command.name.instead.of.file.did.you.want.pipes.xargs.or.quote.to.ignore=重定向到或重定向自命令名称而非文件。改用管道或 xargs (或加引号以忽略)。
use.n.instead.of.z=使用 `[ -n .. ]` 而不是 `! [ -z .. ]`。
use.n.instead.of.z2=使用 `-n` 而不是 `! -z`。
use.instead.of.to.avoid.subshell.overhead=使用 `{ ..; }` 而非 `(..)` 以避免 subshell 开销。
remove.superfluous.around.test.command=移除测试命令周围多余的 `(..)`。
remove.superfluous.around.condition=移除条件周围多余的 `(..)`。
can.t.use.sudo.with.builtins.like.cd.did.you.want.sudo.sh.c.instead=无法对 'cd' 等内置项使用 'sudo'。改用 'sudo sh -c'。
quote.expansions.in.this.for.loop.glob.to.prevent.wordsplitting.e.g.dir.txt=在此 for 循环 glob 中为展开加引号，防止单词分割，例如: "$dir"/*.txt
which.is.non.standard.use.builtin.command.v.instead=非标准 'which'。改用内置的 'command -v'。
this.does.not.read.foo.remove.for.that.or.use.var.to.quiet=这不会读取 'foo'。移除 '$' 和 '${}' 或使用 '${var?}' 以静默。
redirection.applies.to.the.find.command.itself.rewrite.to.work.per.action.or.move.to.end=重定向适用于 'find' 命令本身。重写到每个操作的工作(或移至末尾)。
this.ln.has.no.destination.check.the.arguments.or.specify.explicitly=此 'ln' 没有目标。检查实参，或显式指定 '.'。
this.cp.has.no.destination.check.the.arguments=此 'cp' 没有目标。检查实参。
this.mv.has.no.destination.check.the.arguments=此 'mv' 没有目标。检查实参。
this.default.assignment.may.cause.dos.due.to.globbing.quote.it=此默认赋值可能会由于 glob 而导致 DoS。使用引号将其引起。
this.pattern.never.matches.because.of.a.previous.pattern=由于先前的模式，此模式永远不会匹配。
this.pattern.always.overrides.a.later.one=此模式始终会重写后续模式。
invalid.flags.are.not.handled.add.a.case=不处理无效的标志。添加一个 `*)` case。
instead.of.let.expr.prefer.expr=相较于 `let expr` 更偏好 `(( expr ))`。
this.function.is.only.defined.later.move.the.definition.up=此函数仅在后续定义。向上移动定义。
redirecting.to.echo.a.command.that.doesn.t.read.stdin.bad.quoting.or.missing.xargs=重定向到 'echo'，一个不读取 stdin 的命令。引号使用错误还是缺少 xargs?
piping.to.rm.a.command.that.doesn.t.read.stdin.wrong.command.or.missing.xargs=管道通向 'rm'，一个不读取 stdin 的命令。命令错误还是缺少 xargs?
this.flag.is.used.as.a.command.name.bad.line.break.or.missing=此标志被用作命令名称。换行错误还是缺少 `[ .. ]`?
this.case.is.not.specified.by.getopts='getopts' 未指定此 case。
getopts.specified.n.but.it.s.not.handled.by.this.case='getopts' 指定了 '-n'，但未被此 'case' 处理。
use.false.instead.of.empty.conditionals=使用 'false'，不使用空的 '[' 和 '[[' 条件。
this.is.a.glob.used.as.a.command.name.was.it.supposed.to.be.in.array.or.is.it.missing.quoting=这是一个用作命令名称的 glob。它是应该在 ''${..}'' 还是数组中? 如果不是，使用引号。
this.is.a.file.redirection.was.it.supposed.to.be.a.comparison.or.fd.operation=这是文件重定向。它应是比较还是 fd 运算?
use.var.command.to.assign.output.or.quote.to.assign.string=使用 'var=$(command)' 分配输出(或加引号以分配字符串)。
use.or.quote.arguments.to.v.to.avoid.glob.expansion=使用 `[[ ]]` 或为 '-v' 选项的实参加引号以避免 glob 展开。
prefer.mapfile.or.read.a.to.split.command.output.or.quote.to.avoid.splitting=首选 'mapfile' 或 'read -a' 以分割命令输出(或加引号以避免分割)。
quote.to.prevent.word.splitting.or.split.robustly.with.mapfile.or.read.a=加引号以防止单词分割，或使用 'mapfile' 或 'read -a' 进行稳健分割。
is.a.subshell.did.you.mean.a.test.expression='(..)' 为 subshell。您是否指的是测试表达式 '[ .. ]'?
globs.are.ignored.in.except.right.of.use.a.loop=除了 '=' 和 '!=' 的右侧外，glob 在 `[[ ]]` 中被忽略。使用循环。
globs.don.t.work.as.operands.in.use.a.loop=glob 不能用作 '[ ]' 中的操作数。使用循环。
brace.expansion.doesn.t.happen.in.use.a.loop=大括号展开不会在 `[[ ]]` 中发生。使用循环。
brace.expansions.don.t.work.as.operands.in.use.a.loop=大括号展开不能用作 '[ ]' 中的操作数。使用循环。
error.message.can.t.find.info.in.your.path=在 $PATH 变量中找不到信息。
# {)} is a file name
line.marker.run.0=运行 {0}
i.do.mind.path.placeholder=我会在意
display.name.shell.check=ShellCheck
intention.shell.script=Shell 脚本
sh.markdown.runner.title=在终端中运行
notification.group.shell.script=有可用的 shell 脚本工具
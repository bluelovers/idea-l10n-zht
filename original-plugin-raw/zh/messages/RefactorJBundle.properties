cannot.perform.the.refactoring=不能执行重构。
extract.class.title=提取委托
extract.class.from.label=从{0}提取委托
name.for.new.class.label=新类的名称(&N):
choose.destination.package.label=选择目标软件包
package.for.new.class.label=软件包名称(&P):
members.to.extract.label=要提取的成员(&B)
there.already.exists.a.class.with.the.chosen.name=已存在一个具有所选名称的类。
introduce.parameter.object=引入形参对象
the.caret.should.be.positioned.within.a.class.to.be.refactored=文本光标应置于要重构的类内。
the.selected.class.is.an.enumeration=选定类是枚举。
remove.middleman=移除中间人
the.caret.should.be.positioned.at.the.name.of.the.field.to.be.refactored=文本光标应置于要重构的字段的名称处。
field.selected.is.not.used.as.a.delegate=选定字段不用作委托。
wrap.return.value=包装返回值
the.caret.should.be.positioned.within.a.method.declaration.to.be.refactored=文本光标应置于要重构的方法声明内。
method.selected.returns.void=选定方法返回 'void'。
constructor.returns.can.not.be.wrapped=无法包装构造函数返回值。
wrap.return.value.title=包装返回值
method.to.wrap.returns.from.label=从中包装返回值的方法:
method.whose.return.are.to.wrapped=要包装其返回值的方法
references.to.be.modified.usage.view=要修改的引用{0, choice, 0#(找不到)|1#{0} 个引用|2#{0} 个引用}{1, choice, 0#|1#位于 {1} 个文件中|2#位于 {1} 个文件中}
reference=引用
remove.middleman.field.header=移除中间人字段:
references.to.expose.usage.view=要显示的引用{0, choice, 0#(找不到)|1#{0} 个引用|2#{0} 个引用}{1, choice, 0#|1#位于 {1} 个文件中|2#位于 {1} 个文件中}
remove.middleman.title=移除中间人
refactor=重构
preview=预览
wrapped.return.command.name=将返回值包装为 {1}() 的{0}
exposed.delegation.command.name=已将委托公开给 {0}
annotation=注解
the.selected.class.is.an.interface=选定类是接口。
the.selected.class.is.an.annotation.type=选定类是注解类型。
the.refactoring.is.not.supported.on.non.static.inner.classes=非 static 内部类上不支持重构。
the.selected.class.has.no.members.to.extract=选定类没有要提取的成员。
the.selected.class.should.belong.to.project.sources=所选类应属于项目源
references.to.extract=要提取的引用( {0, choice, 0#(找不到)|1#{0} 个引用|2#{0} 个引用}{1, choice, 0#|1#位于 {1} 个文件中|2#位于 {1} 个文件中})
extract.class.as.enum.column.title=作为枚举
extract.class.depends.on.0.from.1.tooltip=依赖 {1} 的 {0}
extract.class.depends.on.0.from.new.class=依赖新类 {1} 的 {0}
extracting.from.class=正在从类提取:
extracted.class.command.name=已提取类 {0}
extracted.class.not.accessible.in.0=已提取类无法在 {0} 中访问
method.selected.has.no.parameters=选定方法没有参数。
parameter=形参
the.selected.method.cannot.be.wrapped.because.it.is.defined.in.a.non.project.class=不能包装选定方法，因为它在非项目类中定义
select.wrapper.class=选择形参类
could.not.find.selected.wrapping.class=无法找到选定包装类
there.already.exists.a.class.with.the.selected.name=已存在一个具有选定名称的类
dialog.message.invalid.inner.class.name=''{0}'' 是无效的内部类名称
dialog.message.inner.class.with.name.already.exist=名称为 ''{0}'' 的内部类已存在
dialog.message.invalid.qualified.wrapper.class.name=''{0}'' 是无效的限定包装器类名称
dialog.message.invalid.wrapper.class.name=''{0}'' 是无效的包装器类名称
dialog.message.wrapper.field.not.found=找不到包装器字段
dialog.message.invalid.wrapper.class.package.name=''{0}'' 是无效的包装器类软件包名称
popup.title.effective.visibility=有效可见性
field.needs.getter=字段 ''{0}'' 需要 getter
field.needs.setter=字段 ''{0}'' 需要 setter
initializer.requires.moved.members=类初始值设定项需要移动的成员
constructor.requires.moved.members=构造函数需要移动的成员
case.value.can.not.be.replaced.with.enum={0} 不可以替换为枚举
referenced.element.out.of.project={0} 位于项目外
unable.to.migrate.statement.to.enum=无法将语句迁移到枚举常量。{0}
codestyle.settings.extractor.command.name=CodeStyleSettings 提取程序


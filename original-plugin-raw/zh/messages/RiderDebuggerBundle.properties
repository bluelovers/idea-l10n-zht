AttachFromCommandLineInternalAction.dialog.field.label.pid=PID\:
AttachFromCommandLineInternalAction.dialog.message.invalid.pid=PID 无效
AttachFromCommandLineInternalAction.dialog.note.enter.pid=输入 PID\:
AttachFromCommandLineInternalAction.dialog.title.pid.selector=PID 选择器
AttachOpenSolutionStarter.notification.content.run.configuration.was.created=''{0}'' 运行配置已创建。现在，来自 ''{1}'' 的 Debugger.Launch 将自动附加到此解决方案。要取消此行为，请移除此运行配置。
AttachOpenSolutionStarter.notification.title.jit.debugger.run.config=JIT 调试器运行配置
ChooseCoreDumpConfiguration.popup.title.choose.core.dump=选择核心转储
DotNetCoreAttachGroup.group.name.net.core.processes=.NET Core 进程
DotNetDebugProcess.curr.state.message.target.ready=目标就绪
DotNetDebugProcess.curr.state.message.waiting.for.target=正在等待目标就绪
DotNetDebugSourceHashChecker.notification.content.source.may.have.changed=自构建模块以来，源文件 {0} 可能已更改
DotNetDebugSourceHashChecker.notification.content.source.may.have.changed.hyperlink.message=不对当前调试会话显示
DotNetDebuggerAllLanguagesConfigurableUi.checkbox.show.prompt.to.allow.editing=显示提示以允许编辑
DotNetDebuggerGeneralConfigurableUi.0.net.core.only={0} (不包括 Mono)
DotNetDebuggerGeneralConfigurableUi.0.typing.is.not.allowed={0} (不允许输入)
DotNetDebuggerGeneralConfigurableUi.checkbox.allow.implicit.target.invoke=允许属性求值和其他隐式函数调用
DotNetDebuggerGeneralConfigurableUi.checkbox.automatically.refresh.watches=在调试器暂停时刷新监视值
DotNetDebuggerGeneralConfigurableUi.checkbox.de.optimize.methods=去优化步入的方法和具有断点的方法(Windows\: .NET 8，所有操作系统\: .NET 9+)
DotNetDebuggerGeneralConfigurableUi.checkbox.disable.jit.optimization=在加载模块时禁用 JIT 优化
DotNetDebuggerGeneralConfigurableUi.checkbox.enable.breakpoint.suggestion=鼠标悬停时显示断点预览
DotNetDebuggerGeneralConfigurableUi.checkbox.enable.external.source.debug=启用外部源调试
DotNetDebuggerGeneralConfigurableUi.checkbox.ignore.precompiled.assemblies=即使可以使用预编译的程序集，也使用 JIT
DotNetDebuggerGeneralConfigurableUi.checkbox.pin.to.top.ai.enabled=启用 AI“置顶”建议
DotNetDebuggerGeneralConfigurableUi.checkbox.pin.to.top.should.change.presentation=“置顶”应该会改变调试器对象的显示
DotNetDebuggerGeneralConfigurableUi.checkbox.process.exceptions.outside.of.my.code=我的代码以外的进程异常(不包括 Mono)
DotNetDebuggerGeneralConfigurableUi.checkbox.restore.previous.debugger=还原之前的默认调试器
DotNetDebuggerGeneralConfigurableUi.checkbox.save.all.files.on.debugger.launch=调试器启动时保存所有文件
DotNetDebuggerGeneralConfigurableUi.checkbox.set.rider.jit.debugger=将 Rider 设置为默认调试器
DotNetDebuggerGeneralConfigurableUi.checkbox.show.return.values=显示返回值
DotNetDebuggerGeneralConfigurableUi.checkbox.show.run.to.panel.1=在编辑器中显示浮动调试器操作(
DotNetDebuggerGeneralConfigurableUi.checkbox.show.run.to.panel.2=和
DotNetDebuggerGeneralConfigurableUi.checkbox.show.run.to.panel.3=)
DotNetDebuggerGeneralConfigurableUi.dialog.message.timeout.should.be.non.negative=超时必须为非负值
DotNetDebuggerGeneralConfigurableUi.group.name.jit=JIT (不包括 Mono)
DotNetDebuggerGeneralConfigurableUi.help.label.de.optimize.methods.assemblies=调试器在插入断点的位置或发生步入的位置将 JIT 配置为从外部代码重新编译方法。它会改进在外部源调试期间的步进、评估和许多其他调试器功能。
DotNetDebuggerGeneralConfigurableUi.help.label.disable.jit.optimizations=如果进程由调试器启动，此选项可以避免对在发布模式下编译的所有程序集(系统和二进制引用)进行优化。它会降低进程的运行速度，但可以让您检查这些程序集中经过优化的局部变量。
DotNetDebuggerGeneralConfigurableUi.help.label.use.jit.for.precompiled.assemblies=如果为程序集加载了预编译的映像(NGen、CrossGen 或任何 AOT)，则 JIT 将不运行，并且禁用 JIT 优化不起任何作用。此选项可以让调试器忽略预编译的映像并让 JIT 编译程序集。它会减慢进程启动速度，但可以让您检查程序集中经过优化的局部变量(如果禁用了 JIT 优化)。
DotNetDebuggerGeneralConfigurableUi.label.editing.during.debug=调试期间编辑\:
DotNetDebuggerGeneralConfigurableUi.label.evaluation.timeout.ms=求值超时(ms)
DotNetDebuggerGeneralConfigurableUi.label.exceptions=异常\:
DotNetDebuggerGeneralConfigurableUi.label.exceptions.unhandled.info=未处理异常的忽略列表已移至 <hyperlink>Rider 异常断点</hyperlink>窗​​口
DotNetDebuggerGeneralConfigurableUi.label.jit.debugger.cant.get.localappdata.folder.path=JIT 调试器设置\: 无法获取 'Program Files' 文件夹的路径
DotNetDebuggerGeneralConfigurableUi.label.just.in.time.debugger=即时调试器\:
DotNetDebuggerGeneralConfigurableUi.label.maximum.recursion.level=最大递归级别\:
DotNetDebuggerGeneralConfigurableUi.label.pin.to.top=固定至顶部\:
DotNetDebuggerGeneralConfigurableUi.label.value.inspections=值检查\:
DotNetDebuggerSettings.checkbox.add.raw.view.for.debugger.browsable.values=添加调试器可浏览值的原始视图
DotNetDebuggerSettings.checkbox.allow.editing.in.the.debug.mode=允许在调试模式下编辑
DotNetDebuggerSettings.checkbox.cluster.big.arrays=为大数组划分聚类
DotNetDebuggerSettings.checkbox.flatten.objects.hierarchy=平展对象层次结构
DotNetDebuggerSettings.checkbox.show.compiler.generated.members=显示编译器生成的成员
DotNetDebuggerSettings.checkbox.show.fully.qualified.type.names=显示完全限定类型名称
DotNetDebuggerSettings.checkbox.show.hex.value.for.integers=显示整数的十六进制值
DotNetDebuggerSettings.checkbox.show.non.public.members.in.separate.group=在单独的组中显示非 public 成员
DotNetDebuggerSettings.checkbox.show.type.variables=显示类型变量
DotNetDebuggerSettings.checkbox.truncate.long.strings=截断长字符串的表示
DotNetDebuggerSettings.checkbox.truncate.long.strings.counter=阈值
DotNetDebuggerSettings.configurable.name.all.languages=所有语言
DotNetDebuggerSettings.configurable.name.net.languages=.NET 语言
DotNetDebuggerSettings.configurable.name.remote.debug=远程调试
DotNetEvaluator.dialog.message.evaluation.request.was.cancelled=求值请求已被取消
DotNetExceptionBreakpointType.tab.title.clr.exception.breakpoints=CLR 异常断点
DotNetExecutionStack.tooltip.drag.to.skip.code=拖动以跳过代码
DotNetInitializeDebuggerTask.progress.title.initializing.debugger=正在初始化调试器…
DotNetLineBreakpointType.all.breakpoints.message=所有
DotNetLineBreakpointType.line.in.function={1}中的行 {0}
DotNetLineBreakpointType.net.line.breakpoints=.NET 行断点
DotNetMethodBreakpointType.dialog.message.method.name.not.set=未设置方法名称
DotNetMethodBreakpointType.dialog.message.type.name.not.set=未设置类型名称
DotNetMethodBreakpointType.dialog.title.add.method.breakpoint=添加方法断点
DotNetMethodBreakpointType.label.method.name=方法名称\:
DotNetMethodBreakpointType.label.type.name=类型名称\:
DotNetMethodBreakpointType.title.method.breakpoints=方法断点
DotNetNewExceptionBreakpointsDialog.dialog.title.add.clr.exception.breakpoints=添加 CLR 异常断点
DotNetStackFrame.location.line.presentation.suffix.message=\:行 {0}
DotNetStackFrame.location.presentation.suffix.message=在 {0}
DotNetStackFrame.presentation.suffix.message=(在 {0}, {1} 中)
DotNetStackFrame.presentation.suffix.message.empty.namespace=({0} 中)
DotNetSteppingConfigurableUi.checkbox.always.do.smart.step.into=始终进行智能单步执行
DotNetSteppingConfigurableUi.checkbox.show.executed.calls.in.smart.step.into=在“智能步入”中显示已执行的调用
DotNetThreadSpecificBreakpointsPanel.checkbox.suspend.only.on.specific.thread=仅在特定线程上挂起\:
DotNetUserUnhandledIgnoreList.dialog.title.add.exceptions.to.ignore=添加要忽略的异常
DotNetUserUnhandledIgnoreList.label.except=排除\:
DotNetValueModifier.dialog.message.operation.was.cancelled=操作已被取消
ElevateActionDebugger.display.name=提升
ElevateActionDebugger.group.name.elevation.required=需要提升
ExternalCodeMetaFrame.multiple.frames.text=帧
ExternalCodeMetaFrame.single.frame.text=框架
HotReloadBuildToolWindowFactory.label.external.code=[外部代码\:
HotReloadBuildToolWindowFactory.tab.title.hot.reload.build.results=热重载构建结果
ImmediateWindow.not.supported.for.old.debugger.tab=要使用 Immediate 窗口，请启用新的调试器工具窗口并重新启动调试器会话
ImmediateWindow.placeholder.evaluation.with.breakpoints.available=在考虑断点的情况下对表达式求值
ImmediateWindowContentManager.enable.new.debugger.tab=启用
JITDebuggerNotifier.message=您可以将 Rider 设置为默认 JIT 调试器
JITDebuggerUpdater.actions.retry.text=重试更新
JITDebuggerUpdater.command.exit-code=更新命令退出代码\: {0}
JITDebuggerUpdater.notification.content.new.version.available=存在新版本的 JIT 调试器。Debugger.Launch 现在可能无法运行。
JITDebuggerUpdater.notification.content.new.version.available.hyperlink=立即更新
JITDebuggerUpdater.notification.content.successfully.updated=JIT 调试器工具已成功更新
JITDebuggerUpdater.notification.failed-to-update.content=失败原因\: {0}
JITDebuggerUpdater.notification.failed-to-update.title=JIT 调试器工具更新失败
JITDebuggerUpdater.notification.title.should.be.updated=应更新 JIT 调试器
JITDebuggerUpdater.notification.unknown-error=未知错误
MemoryViewGetValuesTask.progress.title.getting.memory.snapshot=正在获取内存快照…
MonoAttachDebugger.display.name.mono.debugger=Mono 调试器
MonoAttachDebugger.display.short.name.mono.debugger=Mono
MonoAttachGroup.group.name.mono.processes=Mono 进程
MsClrAttachGroup.group.name.net.processes=.NET 进程
MsNetAttachDebugger.display.short.name=.NET
MsNetAttachProvider.display.name=.NET 调试器
MsNetAttachProvider.mixed.debug.display.name=.NET 和原生调试器
MsNetUwpAttachDebugger.display.name=UWP 调试器
MsNetUwpAttachDebugger.mixed.debug.display.name=UWP 和原生调试器
PinnedItemsNotificationManager.notification.content.pinned.items.are.in.favorites=固定条目列在 'Bookmarks' 中
RemoteDebugConfigurableUi.border.title.generate.ssh.tools=生成 SSH 工具
RemoteDebugConfigurableUi.border.title.ssh.credentials.for.remote.debugging=远程调试的 SSH 凭据
RemoteDebugConfigurableUi.button.generate=生成
RemoteDebugConfigurableUi.checkbox.use.existing.key=使用现有密钥
RemoteDebugConfigurableUi.checkbox.use.passphrase=使用密码短语
RemoteDebugConfigurableUi.dialog.message.exception.occurred.0=发生异常\: {0}
RemoteDebugConfigurableUi.dialog.message.generation.completed.successfully=生成成功完成
RemoteDebugConfigurableUi.dialog.message.passphrase.is.empty=密码短语为空
RemoteDebugConfigurableUi.dialog.title.cant.generate.key.pair=无法生成密钥对
RemoteDebugConfigurableUi.dialog.title.generation.error=生成错误
RemoteDebugConfigurableUi.dialog.title.remote.tools.generator=远程工具生成器
RemoteDebugConfigurableUi.dialog.title.select.output.folder=选择输出文件夹
RemoteDebugConfigurableUi.dialog.title.select.public.key=选择公钥
RemoteDebugConfigurableUi.label.authentication=身份验证
RemoteDebugConfigurableUi.label.confirm.passphrase=确认密码短语\:
RemoteDebugConfigurableUi.label.host=主机
RemoteDebugConfigurableUi.label.os=OS\:
RemoteDebugConfigurableUi.label.output.folder=输出文件夹\:
RemoteDebugConfigurableUi.label.passphrase=密码短语\:
RemoteDebugConfigurableUi.label.public.key.file=公钥文件\:
RemoteDebugConfigurableUi.label.select.folder.to.write.generated.keys.scripts=选择用于编写生成的密钥和脚本的文件夹
RemoteDebugConfigurableUi.label.select.public.key=选择公钥以生成用于配置 SSH 服务器的脚本
RemoteDebugConfigurableUi.label.user.name=用户名
RemoteDebugConfigurableUi.message.given.passphrases.do.not.match=给定密码短语不匹配
RemoteDebugConfigurableUi.public.key.comment=公钥注释\:
RemoteDebugConfigurableUi.ubuntu=Ubuntu
RemoteDebugConfigurableUi.upload.debug.symbols.for.remote.debugger=上传远程调试器的调试符号
RemoteDebugTools.calculate.processes.error.message=无法列出进程。
RemoteDebugTools.calculate.processes.error.message.action=重试.
RemoteDebugToolsNotLoadedProcessInfo.remote.debugger.tools.are.not.loaded=<html><center>为了能够调试远程主机上的进程，<br>Rider 需要在此主机上安装<br>JetBrains Remote 工具</center></html>
RemoteDebugToolsNotLoadedProcessInfo.remote.debugger.tools.are.not.loaded.action=将工具安装到远程计算机
RemoteDebugger.authentication.failed.error.message=使用{1}方法对 {0} 进行身份验证的尝试失败.
RemoteDebugger.authentication.other.error.message=请检查用户名和身份验证方法是否正确。
RemoteDebugger.authentication.passphrase.error.message=正在尝试使用密钥对进行身份验证，但未提供密码短语。
RemoteDebugger.authentication.password.error.message=正在尝试使用密码进行身份验证，但未提供密码。
RemoteDebugger.enter.edit.credentials.action.message=编辑凭据…
RemoteDebugger.enter.passphrase.description.message=SSH 密钥 {0} 的密码短语\:
RemoteDebugger.enter.passphrase.message=输入密码短语…
RemoteDebugger.enter.password.description.message=用户 {0} 的密码\:
RemoteDebugger.enter.password.message=输入密码…
RemoteDebugger.establish.connection.error.message.first=无法与 {0} 建立连接。
RemoteDebugger.establish.connection.error.message.second=请检查主机名({0})和端口({1})是否正确，以及 SSH 服务器是否正在远程主机上运行。
RemoteDebugger.get.jetbrains.ssh.tool.link=获取 JetBrains 远程调试 SSH 工具
RemoteDebugger.host.resolve.error.message.first=未知主机\: ''{0}''。
RemoteDebugger.host.resolve.error.message.second=请检查主机名是否正确，并确认网络没有问题。
RemoteDebugger.progress.text.adding.execution.permissions=添加执行权限
RemoteDebugger.sftp.error.message.first=SSH 连接成功，但 SFTP 连接失败。
RemoteDebugger.sftp.error.message.second=请检查 SSH 服务器的设置中是否启用了 SFTP。
RemoteDebugger.unknown.error.message.first=未知错误\: {0}.
RemoteDebugger.unknown.error.message.second=请联系支持团队以获取更多信息。
RemoteDebuggerUtils.download.header=远程调试器工具
RemoteDebuggerUtils.popup.title.attach.to.process.from=从 {0}@{1}\:{2} 附加到进程
RemoteDebuggerUtils.progress.text.compressing=正在压缩调试器工具 {0}/{1}…
RemoteDebuggerUtils.progress.text.compressing.additional=正在压缩额外调试器文件({0}/{1})
RemoteDebuggerUtils.progress.text.extracting=正在提取…
RemoteDebuggerUtils.progress.text.extracting.additional=正在提取额外调试器文件
RemoteDebuggerUtils.progress.text.retrieve.tools=正在检索远程调试器工具信息，第 {0} 步，共 3 步…
RemoteDebuggerUtils.progress.text.tools.uploading=正在上传远程调试器工具…
RemoteDebuggerUtils.progress.text.upload.additional.debugger.files=正在上传额外调试器文件
RemoteDebuggerUtils.progress.text.upload.enumerator.and.debugger.workers=正在上传枚举器和调试器工作进程…
RemoteDebuggerUtils.progress.text.uploaded.remaining.time=已上传 {0} 个，共 {1} 个，剩余时间\: {2} 秒
RemoteDebuggerUtils.progress.title.checking.remote.debugger.tools=正在检查远程调试器工具
RemoteDebuggerUtils.progress.title.uploading.remote.debugger.tools=正在上传远程调试器工具
RiderAttachToRemoteProcessAction.debugger.display.name.create.host=创建主机
RiderAttachToRemoteProcessAction.group.name.remote.hosts=远程主机
RiderAttachToRemoteProcessAction.text.add.remote.host=添加远程主机…
RiderClassesTable.column.name.size.bytes=大小(字节)
RiderCollectionAsTablePresenter.tab.name.text=集合
RiderDataBreakpoint.popup.description.message={1} ({2})上的{0}在会话 ''{3}'' 中发生更改。
RiderDataBreakpoint.popup.title.message=数据断点命中
RiderDataBreakpointPane.label.new.value=新值\:
RiderDataBreakpointPane.label.previous.value=上一个值\:
RiderDebugContextActionsHost.hint.text.instances.are.not.available=无法获取类 ''{0}'' 的实例
RiderDebugContextActionsHost.hint.text.instances.not.found=找不到类 ''{0}'' 的实例
RiderDebugContextActionsHost.hint.text.updating.class.instances=正在更新类实例…
RiderDebugDumpAction.notification.content.format.not.supported=不支持所选核心转储文件 ''{0}'' 的格式
RiderDebugDumpAction.popup.title.debug.core.dump.as=将核心转储调试为…
RiderDebugRunner.dialog.message.worker.process.exited.unexpectedly=调试器工作进程已意外退出，退出代码为 {0}
RiderDebugRunner.dialog.message.worker.was.not.initialized.within.ms=调试器工作线程未在 {0} 毫秒内初始化
RiderDebugWritingAccessManager.checkbox.always.allow.editing.during.debug=为新会话禁用热重载(您可以稍后在设置中启用)
RiderDebugWritingAccessManager.dialog.message.0.continue.editing={0}\n是否禁用热重载并继续编辑?
RiderDebugWritingAccessManager.dialog.message.allow.typing=是否要在调试期间允许输入?
RiderDebugWritingAccessManager.dialog.message.changes.while.not.ready=热重载已启用，需要完成初始化才能允许在运行时进行编辑
RiderDebugWritingAccessManager.dialog.title.hot.reload=热重载
RiderDebugWritingAccessManager.dialog.title.write.access.is.denied=调试期间的写入权限被拒
RiderDebugWritingAccessManager.notification.content.readonly.settings=您可以在调试期间在<a href\="settings">调试器设置</a>中更改只读模式设置
RiderDebugWritingAccessManager.notification.title.readonly.settings=只读模式设置
RiderDebuggerDisableMethodToInvokeAction.disable=禁用对所选条目的求值
RiderDebuggerDisableMethodToInvokeAction.disable.multi=禁用对所选条目的求值
RiderDebuggerDisableMethodToInvokeAction.enable=启用对所选条目的求值
RiderDebuggerDisableMethodToInvokeAction.enable.multi=启用对所选条目的求值
RiderDetachDebuggerAction.action.detach.0.text=分离 ''{0}''
RiderExceptionGroupByNamespaceRule.rule.name.group.by.namespace=按命名空间分组
RiderExceptionGroupBySourceRule.group.name.group.by.exception.source=按异常源分组
RiderExternalSourceDebugNotifier.notification.action.configure.external.source.debug=配置外部源调试
RiderExternalSourceDebugNotifier.notification.action.configure.jit=配置 JIT 行为
RiderExternalSourceDebugNotifier.notification.message.debugging.external.code=正在调试外部代码，实时反编译
RiderExternalSourceDebugNotifier.notification.message.debugging.external.code.suggest.jit.configuring=正在调试外部代码，实时反编译。要检查优化后的局部变量，请配置 JIT 行为
RiderHotReloadNotifier.apply.changes=应用更改
RiderHotReloadNotifier.changes.will.be.applied=更改将在下一步或恢复时应用。
RiderHotReloadNotifier.hide.for.this.session=对此会话隐藏
RiderHotReloadNotifier.sources.are.modified=源代码已修改。
RiderInstancesView.label.shown.0.1=已显示\: {0} / {1}
RiderInstancesView.label.shown.more=显示更多
RiderMarkObjectHandler.failed.to.mark.message=无法标记对象\: {0}
RiderMarkObjectHandler.tooltip.text.label.name.is.not.valid=标签名称无效\: {0, choice, 0\#名称必须符合变量限制|1\#已存在}
RiderNewSmartStepIntoHandler.popup.title.method.to.step.into=进入的方法
RiderRunToPopupManager.tooltip.run.to.here=运行到此处
RiderRunToPopupManager.tooltip.skip.to.here=跳到此处
RiderSmartStepIntoUtils.choose.smart.step.into.target=选择智能步入目标
RiderSmartStepIntoUtils.execute.again=再次执行
RiderSmartStepIntoUtils.notification.content.unable.smart.step.into.list=无法获取智能步入列表
RiderSmartStepIntoUtils.notification.content.unable.smart.step.into.list.reason=无法获取智能步入列表\: {0}
RiderSmartStepIntoVariant.description.execute.again=再次执行
RiderSshRemoteGroup.group.name.remote.hosts=远程主机
RiderStopOnExceptionAction.notification.content.new.exception.rule=已创建类型 ''{0}'' 的异常规则
RiderStopOnExceptionAction.notification.title.new.exception.rule=新异常规则
SymbolServerConfigurable.checkbox.allow.downloading.symbols.from.remote.locations=允许从远程位置下载符号
SymbolServerConfigurable.checkbox.decompile.methods=反编译方法
SymbolServerConfigurable.checkbox.decompile.protected.assemblies=反编译受保护的程序集
SymbolServerConfigurable.checkbox.enable.private.source.link.support=启用不公开源链接支持
SymbolServerConfigurable.checkbox.show.non.public.compiled.items=在“转到…”结果中显示非 public 编译条目
SymbolServerConfigurable.checkbox.use.sources.from.symbol.files.when.available=尽可能使用符号文件中的源代码
SymbolServerConfigurable.configurable.name.external.symbols=外部符号
SymbolServerConfigurable.dialog.message.enter.symbol.server.url=输入符号服务器 URL
SymbolServerConfigurable.dialog.title.symbol.server=符号服务器
SymbolServerConfigurable.empty.text.no.symbol.servers.configured=未配置符号服务器
SymbolServerConfigurable.error.text.malformed.uri=URI 格式不正确
SymbolServerConfigurable.error.text.unsupported.uri.scheme=不受支持的 URI 方案\: {0}
SymbolServerConfigurable.error.text.uri.scheme.not.specified=未指定 URI 方案。支持的 URI 方案\: file、http、https。
SymbolServerConfigurable.separator.symbol.servers=符号服务器
SymbolServerConfigurable.tooltip.text.decompile.method.bodies=反编译方法体
SymbolServerConfigurable.tooltip.text.decompile.protected.assemblies=反编译受保护的程序集(忽略 SuppressIldasm 特性)
SymbolServerConfigurable.tooltip.text.download.symbol.files.from.symbol.server.s=从符号服务器下载符号文件
SymbolServerConfigurable.tooltip.text.show.non.public.compiled.items.in.go.to=在“转到…”结果中显示非 public 编译条目
SymbolServerConfigurable.tooltip.text.use.symbol.files.to.get.compiled.code.source=使用符号文件获取编译的代码源
UWPAppAttachGroup.group.name.uwp.processes=UWP 进程
UploadErrorProcessInfo.error.show.details=显示详细信息.
action.disable.external.decompiled.sources.text=禁用反编译的源代码
action.disable.external.symbol.files.text=禁用外部符号文件
action.enable.external.decompiled.sources.text=启用反编译的源代码
action.enable.external.symbol.files.text=启用外部符号文件
action.navigate.current.location.text=导航到任务的当前位置
action.navigate.initial.location.text=导航到任务的初始位置
action.show.dotnet.value.text=显示 .NET 值
assembly.was.not.found=找不到程序集
async.stacks.count={0} 个异步逻辑{1,choice, 1\#堆栈|2\#堆栈}
blazor.wasm.debug.exception.access.userdatadir=无法访问浏览器用户数据目录\: {0}
blazor.wasm.debug.exception.application.url=无法附加 Blazor 调试器\: applicationUrl 为空
blazor.wasm.debug.exception.browser.closed=Blazor 调试代理错误\: 浏览器关闭
blazor.wasm.debug.exception.browser.incorrect=无法附加 Blazor 调试器\: 所选的浏览器系列 {0} 不受支持。目前，只有 ''Chrome'' 系列的浏览器可以用于 Blazor WASM 调试。
blazor.wasm.debug.exception.browser.pages=Blazor 调试代理错误\: 浏览器中没有可调试的页面。请重新启动会话并等待调试器完成连接。
blazor.wasm.debug.exception.core.runtime=无法附加 Blazor 调试器\: 找不到 Core 运行时
blazor.wasm.debug.exception.inspect.uri=无法附加 Blazor 调试器\: 没有要检查的 URI
blazor.wasm.debug.exception.launch.url=无法附加 Blazor 调试器\: launchUrl 为空
blazor.wasm.debug.exception.nuget=不能附加 Blazor 调试器\: 找不到 Blazor 代理服务器 NuGet 软件包。请为独立版本安装 {0} 软件包，或者为 ASP.NET Core 托管模型安装 {1}。
blazor.wasm.debug.exception.redirect=Blazor 调试代理错误\: 应从 /ws-proxy 重定向，但收到的是 {0} 状态代码。请参阅日志以了解详情。
blazor.wasm.debug.exception.target.path.missing=无法附加 Blazor 调试器\: 无法检索输出程序集路径
blazor.wasm.debug.exception.timeout=Blazor 调试代理错误\: 无法连接到代理。请检查 DevServer 是否未运行以及 ASP.NET Core 开发证书是否正确配置。
blazor.wasm.debug.exception.unknown.profile=无法附加 Blazor 调试器\: 未知的运行配置文件状态，应该无法实现
blazor.wasm.debug.exception.uri=Blazor 调试代理错误\: 无法构建调试代理 URL，'inspectUri' 不正确
blazor.wasm.debug.gateway.exception.text=Blazor 调试代理错误\: 无法获取 DevTools 网关，浏览器未响应
blazor.wasm.debug.gateway.notification.text=Rider 无法获取浏览器 DevTools 网关。请关闭其他正在运行的浏览器和项目实例，然后重试。
blazor.wasm.debug.notification.dev.cert.not.exists=Blazor WASM 调试\: 没有有效的 ASP.NET Core 开发证书，调试可能无法运行
blazor.wasm.debug.notification.lockfile.force=Blazor WASM 调试\: 存在锁定文件，但找不到 'DevToolsActivePort' 文件。浏览器必须使用 '--remote-debugging-port\=0' 实参启动才能允许调试。
blazor.wasm.debug.notification.lockfile.ok=Blazor WASM 调试\: 存在锁定文件，正在连接到已在运行的浏览器
blazor.wasm.debug.popup.not.chosen=Blazor 调试代理错误\: 未选择可调试的页面
browser.hot.reload.error.occurred=热重载项目构建过程中出错。如需了解详情，请参阅 Rider 窗口。
callframe.async.completed.label=[已完成]
collection.presenter.explore.link=探索
debugger.action.link.create.breakpoint=配置
debugger.action.link.force.refresh=Force Refresh
debugger.action.link.refresh=刷新
debugger.action.link.view=查看
debugger.exception.breakpoint.default.display.name.message=任何异常
debugger.new.exception.breakpoint.entry.message=添加断点
debugger.pinned.item.favourites.list.name=已在调试器中固定
decompiled.symbols=反编译的符号
dialog.message.failed.to.launch.application.file.doesn.t.exist=无法启动应用程序\: 文件 ''{0}'' 不存在
dialog.message.remote.debugging.uwp.not.supported=尚不支持 UWP 应用程序的远程调试
dialog.message.request.was.cancelled=请求已被取消
dialog.message.rider.has.to.be.restarted.elevation.for.debug=必须使用提升的权限重新启动 Rider 才能调试此应用程序。是否要重新启动 Rider?
dialog.message.rider.has.to.be.restarted.elevation.for.run=必须使用提升的权限重新启动 Rider 才能运行此应用程序。是否要重新启动 Rider?
dialog.message.this.run.profile.not.supported=不支持此运行配置文件\: {0}
dialog.message.you.have.incorrect.browser.cli.options=您的浏览器 CLI 选项不正确
dialog.title.collection.view=集合视图\: {0}
dialog.title.dotnet.dump=.NET 进程转储
dialog.title.elevated.permissions.required=需要提升的权限
dialog.title.ssh.key.passphrase=SSH 密钥密码短语
dialog.title.ssh.password.login=SSH 密码登录
display.name.memory=内存
elapsed.milliseconds.between.debugger.stops=用时 ≤ {0} 毫秒
exception.filters.update.message=正在查找有效的 .NET 堆栈跟踪…
highlight.call.stacks.in.output.message=在“调试输出”窗口中高亮显示调用堆栈
immediate.window.action.evaluate.in.dialog.window.text=在对话框中求值
immediate.window.toolbar.got.it.action.link.text=明白了
immediate.window.toolbar.got.it.description.message={0} 以在最后一个表达式上设置监视
in.memory.symbols=内存中的符号
managed.thread.id=托管线程 ID
no.tasks.found=找不到任务
notification.content.can.t.get.type=无法获取类型
notification.content.can.t.navigate.to.type=无法导航到类型 {0}
notification.content.exception.suspend=断点 ''{0}'' 异常 - {1, choice, 0\#已禁用|1\#已启用} ''{2}'' 场景的 ''Suspend'' 选项
notification.content.unable.to.modify.properties.exception=无法修改异常 ''{0}'' 的属性
notification.group.can't.navigate.to.delegate.method=无法导航到委托方法
notification.group.debugger.event.log.messages=调试器事件日志消息
notification.group.immediate.window.is.not.supported.for.the.old.debugger.tool.window=旧的调试器工具窗口不支持 Immediate 窗口
notification.group.jit.debugger.run.configuration=JIT 调试器运行配置
notification.group.jit.debugger.updater.host=JIT 调试器更新程序主机
notification.group.rider.debug.dump.action=Rider 调试转储操作
notification.group.rider.debugger.symbols.loading=符号加载中
notification.group.rider.remote.debugger=Rider 远程调试器
notification.group.rider.remote.debugger.upload.error.upload.error=Rider 远程调试器\: 上传错误
notification.title.authentication.failed=身份验证失败
notification.title.failed.to.connect=无法连接
notification.title.failed.to.list.processes=无法列出进程
notification.title.failed.to.open.sftp.connection=无法打开 SFTP 连接
notification.title.failed.to.resolve.host=无法解析主机
notification.title.no.passphrase.provided=未提供密码短语
notification.title.no.password.provided=未提供密码
parallel.tasks.are.not.supported=不支持并行任务
parallelTasks.popup.column.frame=帧
parallelTasks.popup.column.id=任务 ID
parallelTasks.popup.column.status=状态
parallelTasks.popup.column.thread=线程
popup.title.debugger=调试器
rider.attach.console.kind.message=当调试器附加到正在运行的进程时，控制台输出不可用
rider.breakpoint.equal.to.hit.count.mode.message=等于
rider.breakpoint.greater.than.hit.count.mode.message=大于
rider.breakpoint.greater.than.or.equal.to.hit.count.mode.message=大于或等于
rider.breakpoint.hit.count.message=命中数\:
rider.breakpoint.less.than.hit.count.mode.message=小于
rider.breakpoint.less.than.or.equal.to.hit.count.mode.message=小于或等于
rider.breakpoint.multiple.of.hit.count.mode.message=多倍
rider.children.evaluation.failed.message=无法计算子节点
rider.copy.all.stacks.progress.message=正在复制堆栈帧…
rider.debug.ImmediateWindowCollapseExpandAction.collapse.text=收起
rider.debug.ImmediateWindowCollapseExpandAction.expand.text=展开
rider.debug.ImmediateWindowConsoleImpl.add.watch.action.description=在当前表达式上设置监视，如果输入为空，则在最后求值的表达式上设置监视
rider.debug.ImmediateWindowConsoleImpl.add.watch.action.text=添加监视
rider.debug.ImmediateWindowConsoleImpl.file.name=Immediate 窗口
rider.debug.ImmediateWindowConsoleImpl.stop.on.break.events.text=在断点和异常处停止
rider.debug.add.exceptions.message=添加异常
rider.debug.apply.changes.message=应用更改
rider.debug.attach.generated.solution.name=处理 ''{0}''
rider.debug.attach.unknown.runtime.message=未知类型的目标进程运行时\: {0}
rider.debug.critical.error.message=发生严重错误。{0}
rider.debug.downloading.debugger.tools.message=正在下载调试器工具…
rider.debug.failed.conditional.breakpoint.description.text=无法对条件断点表达式求值。\n错误\: {0}。\n是否要在断点处停止?
rider.debug.failed.conditional.breakpoint.title.text=断点条件错误
rider.debug.memory.fetching.is.not.supported.message=不支持内存提取
rider.debug.navigate.to.link.text=导航
rider.debug.navigate.to.underlying.delegate.fail.notification.text=无法导航到委托方法
rider.debug.restart.with.elevated.privileges.action.text=使用提升的权限重新启动 Rider
rider.debug.unsupported.architecture.message=调试尚不支持进程架构 {0}
rider.debugger.DFA.colorized=启用着色模式
rider.debugger.DFA.colorized.help.text=对逻辑表达式着色，而不是将其值显示为嵌入提示
rider.debugger.DFA.enable.dfa.gutter.line.indicator=启用装订区域行指示器
rider.debugger.DFA.enable.title=启用预测调试器
rider.debugger.DFA.gutter.line.indicator.tooltip.on.hover=由预测调试器分析的代码
rider.debugger.DFA.mode=预测调试器
rider.debugger.DFA.mode.enter.debugger.DFA.mode=启用预测调试器
rider.debugger.DFA.mode.exit.debugger.DFA.mode=为此会话禁用预测调试器
rider.debugger.DFA.mode.link.change.timeout=更改超时…
rider.debugger.DFA.mode.link.configure=配置…
rider.debugger.DFA.mode.popup.description=<p>预测调试器会可视化显示执行流程，显示条件的值，高亮显示将采用和不采用的分支，让您在循环中向前迭代</p>
rider.debugger.DFA.settings.title=预测调试器
rider.debugger.DFA.status=<p>从当前点预测\: <b>{0}</b></p>
rider.debugger.DFA.status.completed=已完成
rider.debugger.DFA.status.in.progress=正在运行
rider.debugger.DFA.status.no.results=无结果
rider.debugger.DFA.status.not.started=未启动
rider.debugger.DFA.status.timed.out=超时
rider.debugger.DFA.timeout=预测调试器超时(ms)
rider.debugger.DFA.timeout.help.text=分析的时间段有限，函数越复杂，分析所需的时间越多
rider.debugger.DFA.timeout.setting=预测调试器超时
rider.debugger.DFA.title=预测调试器
rider.debugger.attach.copy.debugger.tools.to.target.machine=正在将远程调试器工具复制到目标机器…
rider.debugger.attach.copy.debugger.tools.to.target.machine.progress=正在将远程调试器工具复制到目标机器 [{0} / {1} Mb]
rider.debugger.attach.debugger.tools.connecting.to.debugger=正在连接到调试器…
rider.debugger.attach.download.remote.debugger.tools=正在下载远程调试器工具…
rider.debugger.attach.extract.debugger.tools=正在从归档中提取调试工具…
rider.debugger.attach.unable.to.get.debugger.tools.directory=无法在目标机器上找到 .NET 调试器工具目录
rider.debugger.attach.unable.to.start.debugger.on.host=无法在目标机器上启动调试器进程
rider.debugger.attach.unable.to.start.process.explorer.on.host=无法在目标机器上启动进程资源管理器
rider.debugger.collecting.sequence.points.message=正在收集序列点…
rider.debugger.create.breakpoint.message=创建断点
rider.debugger.exception.breakpoint.text=异常断点
rider.debugger.external.exceptions.group.name=外部异常
rider.debugger.external.source.debugging.mac.m1.message=在采用 ARM64 架构的 macOS 上，步入外部方法在 .NET 8 或更低版本中不受支持
rider.debugger.line.breakpoint.text=行断点
rider.debugger.loading.external.symbol.title=正在加载源代码\: {0}
rider.debugger.mixed.mode.evaluation.not.needed.any.anymore=不再需要求值
rider.debugger.mixed.mode.managed.evaluation.impossible.thread.in.native.code=未执行求值，因为调试器会话已恢复
rider.debugger.mixed.mode.simultaneous.evaluations.not.supported=混合模式下不支持同时求值
rider.debugger.no.variants.available=没有可用的变体
rider.debugger.process.does.not.exist.message=无法附加到 ''{0}'' 进程。确保此进程存在。
rider.debugger.show.in.editor.action.description=将集合表放在编辑器中
rider.debugger.show.in.editor.action.name=在编辑器中显示
rider.debugger.show.in.window.action.description=将集合表放在“调试”工具窗口中
rider.debugger.show.in.window.action.name=在工具窗口中显示
rider.debugger.table.visualizers.loader.message=正在加载调试器信息…
rider.debugger.user.exceptions.group.name=用户异常
rider.debugger.view.visualizers.formatted=已格式化
rider.debugger.view.visualizers.raw=原始
rider.debugger.worker.connector.dialog.backend.port.row=调试器工作进程端口的后端
rider.debugger.worker.connector.dialog.button=连接
rider.debugger.worker.connector.dialog.frontend.port.row=调试器工作进程端口的前端
rider.debugger.worker.connector.dialog.process.id.row=进程 ID
rider.debugger.worker.connector.dialog.title=连接到调试器工作进程
rider.debugger.worker.connector.session=内部会话
rider.evaluation.failed.message=无法计算{0}的对象属性
rider.exception.panel.exception.disabled.due.to.handler.warning=异常断点当前停用，因为所有<b>异常处理程序</b>选项均已禁用
rider.exception.panel.exception.disabled.due.to.source.warning=异常断点当前停用，因为所有<b>异常抛出</b>选项均已禁用
rider.exception.panel.exception.handler.external.code.comment=Mono 忽略外部异常处理程序设置
rider.exception.panel.exception.handler.external.code.message=外部代码
rider.exception.panel.exception.handler.message=异常处理程序\:
rider.exception.panel.exception.handler.unhandled.message=未处理
rider.exception.panel.exception.handler.user.code.message=用户代码
rider.exception.panel.exception.thrown.in.external.code.message=外部代码
rider.exception.panel.exception.thrown.in.message=异常抛出位置\:
rider.exception.panel.exception.thrown.in.user.code.message=用户代码
rider.exception.panel.trigger.breakpoint.header.message=挂起条件
rider.exception.popup.exception.message={0}异常{1}
rider.exception.popup.exception.source.nonuser.message=非用户
rider.exception.popup.exception.source.user.message=用户
rider.exception.popup.handled.exception.message=已处理
rider.exception.popup.others.handled.exception.message=已在外部代码中处理
rider.exception.popup.others.handled.exception.scenario.name.message=已在外部代码中处理
rider.exception.popup.unhandled.exception.message=未处理
rider.exception.popup.unhandled.exception.scenario.name.message=未处理
rider.exception.popup.unknown.exception.message=异常
rider.exception.popup.user.handled.exception.message=已在用户代码中处理
rider.exception.popup.user.handled.exception.scenario.name.message=已在用户代码中处理
rider.external.console.kind.message=选择 ''{0}'' 时，控制台输出不可用
rider.hide.threads.action.name=隐藏线程
rider.reattach.looking.for.process.message=正在检测要附加到的进程…
rider.remote.debug.enumerator.exited.error.message=无法列出进程。进程枚举器意外退出.
rider.remote.debug.unarchiver.is.missing.message=缺失 {0} 的解档程序
rider.remote.debug.unknown.os.and.cpu.message=目标操作系统和 CPU 架构({0})组合不受支持
rider.show.threads.action.name=显示线程
rider.smart.step.into.hidden.target.message=已隐藏
rider.smart.step.into.iterator.target.message=迭代器方法
rider.smart.step.into.native.target.message=原生
rider.smart.step.into.step.through.target.message=逐步执行
scheduled.and.waiting.to.run=已安排并等待运行
show.elapsed.time.between.debugger.stops=显示调试器停止期间经过的时间
sources.disabled=已禁用
sources.enabled=已启用
symbol.files.label=符号文件
symbols.are.not.loaded.yet=符号尚未加载
symbols.file.signature.does.not.match.assembly.signature=符号文件签名与程序集签名不匹配
symbols.for.this.module.are.already.loaded=此模块的符号已加载
symbols.were.not.found=找不到符号
symbols.were.not.loaded.0=符号未加载\: {0}
tab.display.name.debug.output=调试输出
tab.display.name.modules=模块
tab.display.name.parallel.stacks=并行堆栈
tab.display.name.tasks=任务
tab.display.name.threads=线程
tab.modules.action.loadSymbols=加载符号
tab.modules.action.reloadSymbols=重新加载符号
tab.modules.action.viewInExplorer=在程序集资源管理器中查看
tab.modules.column.appDomain=AppDomain
tab.modules.column.appDomain.copy=AppDomain 名称
tab.modules.column.decompiledSources=反编译的源代码
tab.modules.column.symbols=符号
tab.modules.column.version=版本
tab.modules.column.version.copy=模块版本
tab.title.value=.NET 值
tasks.view.not.supported=不支持任务视图
tasks.view.table=表
tasksView.column.asyncState=异步状态
tasksView.column.id=ID
tasksView.column.initial.location=初始位置
tasksView.column.location=位置
tasksView.column.parent=父项
tasksView.column.status=状态
tasksView.column.thread=线程
tasksView.subView.graph=图
text.no.tasks.found=找不到任务
text.press.pause.to.work.with.tasks=暂停程序来分析任务
text.tasks.are.not.available=任务不可用
text.tasks.view.not.supported=不支持任务视图
unknown.reason=未知原因
wasm.splash.initializing=正在初始化…
wasm.splash.standby=您的 WASM 应用正在准备由 Rider 调试器使用，请稍候…
welcometab.attach=附加到进程
wrong.file=指定的符号文件不受支持或已损坏
wrong.symbols.kind.were.specified=指定了错误的符号种类

action.rbs.cli.ancestors.description=显示给定类或模块的上级。
action.rbs.cli.ancestors.text=运行 RBS Ancestors
action.rbs.cli.ast.description=打印所加载环境的 JSON AST。您可以指定使用文件名筛选声明的模式
action.rbs.cli.ast.text=运行 RBS Ast
action.rbs.cli.constant.description=解析 RBS 内的给定常量
action.rbs.cli.constant.text=运行 RBS Constant
action.rbs.cli.list.description=列出所有类、模块和接口与定义
action.rbs.cli.list.text=运行 RBS List
action.rbs.cli.method.description=显示通过 `type_name` 和 `method_name` 指定的方法的定义
action.rbs.cli.method.text=运行 RBS Method
action.rbs.cli.methods.description=显示在给定类或模块中定义的所有方法
action.rbs.cli.methods.text=运行 RBS Methods
action.rbs.cli.parse.description=解析给定 RBS 文件并打印任何语法错误
action.rbs.cli.parse.text=运行 RBS Parse
action.rbs.cli.paths.description=显示用于加载 RBS 文件的路径
action.rbs.cli.paths.text=运行 RBS Paths
action.rbs.cli.prototype.description=生成原型 RBS 文件。支持的生成器包括 rb、rbi 和 runtime
action.rbs.cli.prototype.text=运行 RBS Prototype
action.rbs.cli.test.description=使用给定选项运行测试
action.rbs.cli.test.text=运行 RBS Test
action.rbs.cli.validate.description=确保 RBS 文件中存在类型名称并且类型应用程序具有正确的实参数量
action.rbs.cli.validate.text=运行 RBS Validate
action.rbs.cli.vendor.description=项目目录中的供应商签名
action.rbs.cli.vendor.text=运行 RBS Vendor
action.rbs.create.new.class.file.description=创建新的 RBS 类/文件
action.rbs.create.new.class.file.text=RBS 类/文件
action.rbs.generate.from.ruby.description=生成 Ruby 文件的 RBS 签名
action.rbs.generate.from.ruby.popup.text=类型签名
action.rbs.generate.from.ruby.text=生成类型签名
action.steep.cli.annotations.description=检查给定源代码中的注解
action.steep.cli.annotations.text=运行 Steep Annotations
action.steep.cli.check.description=运行类型检查
action.steep.cli.check.text=运行 Steep Check
action.steep.cli.init.description=生成 Steepfile
action.steep.cli.init.text=运行 Steep Init
action.steep.cli.langserver.text=运行 Steep Langserver
action.steep.cli.project.text=运行 Steep Project
action.steep.cli.stats.text=运行 Steep Stats
action.steep.cli.validate.description=验证 Steep 配置
action.steep.cli.validate.text=运行 Steep Validate
action.steep.cli.watch.text=运行 Steep Watch
filetype.rbs.description=RBS
rbs.action.error.generating.rbs=生成 RBS 时出错\: {0}
rbs.action.generate.title=正在生成类型签名
rbs.action.non.zero.exit.code=RBS 的非零退出代码\: {0}
rbs.action.output.null=无法运行 RBS prototype 命令
rbs.action.tab.title=运行 {0}
rbs.actions.create.class.file.dialog.class=类
rbs.actions.create.class.file.dialog.file=文件
rbs.actions.create.class.file.dialog.interface=接口
rbs.actions.create.class.file.dialog.module=模块
rbs.actions.create.class.file.error.invalid.class.name=该名称不是有效的类名
rbs.actions.create.class.file.error.invalid.file.name=该名称不是有效的文件名
rbs.actions.create.class.file.error.invalid.interface.name=该名称不是有效的接口名称
rbs.actions.create.class.file.error.invalid.module.name=该名称不是有效的模块名称
rbs.actions.create.class.file.name=创建 RBS 类/文件 {0}
rbs.actions.create.class.file.title=新建 RBS 类/文件
rbs.actions.run.anything.group.name=RBS
rbs.actions.run.anything.help.placeholder=rbs <command>
rbs.annotation.block.with.untyped.parameters=与非类型化形参一起使用的块
rbs.annotation.block.with.untyped.parameters.quickfix.family.name=移除块
rbs.annotation.block.with.untyped.parameters.quickfix.name=移除 ''{0}''
rbs.annotation.interface.prepended=接口无法预置
rbs.annotation.interface.prepended.remove.quickfix.family.name=移除预置接口
rbs.annotation.interface.prepended.remove.quickfix.name=移除 ''prepend {0}''
rbs.annotation.interface.prepended.replace.extend.quickfix.family.name=将预置接口更改为 'extend'
rbs.annotation.interface.prepended.replace.extend.quickfix.name=将 ''prepend {0}'' 更改为 ''extend {0}''
rbs.annotation.interface.prepended.replace.include.quickfix.family.name=将预置接口更改为 'include'
rbs.annotation.interface.prepended.replace.include.quickfix.name=将 ''prepend {0}'' 更改为 ''include {0}''
rbs.annotation.module.included.in.interface=接口中包含的类/模块
rbs.annotation.remove.include.statement.quickfix.name=移除 'include' 语句
rbs.annotation.remove.statement.fix=移除语句
rbs.annotation.self.type.in.method=方法中使用了 self 类型绑定
rbs.annotation.self.type.in.method.remove.quickfix.family.name=移除自类型绑定
rbs.annotation.self.type.in.method.remove.quickfix.name=移除 ''{0}''
rbs.annotation.self.type.in.proc.with.untyped.parameters=与非类型化形参一起使用的 self 类型绑定
rbs.annotation.self.type.in.proc.with.untyped.parameters.remove.quickfix.family.name=移除 self 类型绑定
rbs.annotation.self.type.in.proc.with.untyped.parameters.remove.quickfix.name=移除 ''{0}''
rbs.annotation.singleton.alias.in.interface.quickfix.family.name=将单例别名转换为实例别名
rbs.annotation.singleton.alias.in.interface.quickfix.name=转换为实例别名
rbs.annotation.singleton.in.interface=接口内部的单例方法定义
rbs.annotation.singleton.in.interface.remove.alias.quickfix.name=移除单例别名
rbs.annotation.singleton.in.interface.remove.quickfix.name=移除单例方法
rbs.annotation.singleton.method.in.interface.quickfix.family.name=将单例方法转换为实例方法
rbs.annotation.singleton.method.in.interface.quickfix.name=转换为实例方法
rbs.annotation.type.alias.used.as.self.type=用作自类型的类型别名
rbs.annotation.type.alias.used.as.self.type.remove.intention.family.name=移除无效的自类型
rbs.annotation.type.alias.used.as.self.type.remove.intention.name=移除 ''{0}''
rbs.annotation.type.contexts.keyword.in.invalid.context=在无效上下文中使用了 ''{0}''
rbs.annotation.type.contexts.keyword.in.invalid.context.replace.quickfix.family.name=替换无效的类型用法
rbs.annotation.type.contexts.keyword.in.invalid.context.replace.quickfix.name=替换 ''{0}''
rbs.annotation.type.variable.after.optional.type.variable=必选类型变量位于可选类型变量之后
rbs.annotation.type.variable.after.optional.type.variable.quickfix.family.name=添加默认类型
rbs.annotation.type.variable.after.optional.type.variable.quickfix.name=添加默认类型
rbs.annotation.type.variable.depends.on.optional.type.variable=默认类型中引用的可选类型变量
rbs.annotation.type.variable.depends.on.optional.type.variable.quickfix.family.name=替换无效的类型变量引用
rbs.annotation.type.variable.depends.on.optional.type.variable.quickfix.name=替换 ''{0}''
rbs.annotation.use.alias.mismatched.case.interface=''{0}'' 不是有效的接口名称
rbs.annotation.use.alias.mismatched.case.lowercase=''{0}'' 不是有效的类型别名
rbs.annotation.use.alias.mismatched.case.uppercase=''{0}'' 不是有效的类/模块名称
rbs.annotation.visibility.modifier.remove.quickfix.family.name=移除无效的可见性修饰符
rbs.annotation.visibility.modifier.remove.quickfix.name=移除 ''{0}''
rbs.annotation.visibility.modifier.used.in.interface=在接口内部使用的可见性修饰符
rbs.annotation.visibility.modifier.used.in.module.method=模块方法中使用的可见性修饰符
rbs.collection.banner=捆绑的签名文件(使用 RBS 集合下载)
rbs.collection.location=库根
rbs.collection.name=rbs_collection [捆绑]
rbs.collection.name.with.module=rbs_collection ({0}) [捆绑]
rbs.collection.notification.installGem.body=允许在后台下载 gem 的类型签名(项目及其文件不会被修改)
rbs.collection.notification.installGem.install.action.title=启用
rbs.collection.notification.installGem.title=改进的类型支持
rbs.collection.notificationGroup=RBS 收集自动化
rbs.collection.runner.init=正在初始化 {0} 的 RBS 集合…
rbs.collection.runner.update=正在更新 {0} 的 RBS 集合…
rbs.collection.update.title=正在更新 RBS 集合
rbs.expected.argument.type.group.rbs=RBS
rbs.expected.constant.type.group.rbs=RBS
rbs.expected.globalVariable.type.group.rbs=RBS
rbs.expected.method.signature.group.rbs=RBS
rbs.expected.parameter.type.group.rbs=RBS
rbs.expected.return.type.group.rbs=RBS
rbs.expected.variable.type.group.rbs=RBS
rbs.inlay.hints.choose.declaration.title=选择声明
rbs.inlay.hints.ruby.attribute.type.description=关联的声明旁边的特性类型(来自 RBS)。显示访问器、读取器和写入器的类型。<br/><br/>按住 Ctrl 并点击提示可导航到类型签名。
rbs.inlay.hints.ruby.attribute.type.name=特性类型
rbs.inlay.hints.ruby.block.parameter.type.description=关联声明旁边的块形参类型(来自 RBS)。将同时显示命名形参和编号形参的类型。<br/><br/>按住 Ctrl 并点击提示可导航到类型签名。
rbs.inlay.hints.ruby.block.parameter.type.name=块形参类型
rbs.inlay.hints.ruby.block.self.type.description=关联声明旁边的块 self 类型(来自 RBS)。<br/><br/>按住 Ctrl 并点击提示可导航到类型签名。
rbs.inlay.hints.ruby.block.self.type.name=块 self 类型
rbs.inlay.hints.ruby.constant.type.description=关联的声明旁边的常量类型(来自 RBS)。<br/><br/>按住 Ctrl 并点击提示可导航到类型签名。
rbs.inlay.hints.ruby.constant.type.name=常量类型
rbs.inlay.hints.ruby.container.type.description=类/模块声明旁边的类型变量名称(来自 RBS)。<br/><br/>按住 Ctrl 并点击提示可导航到类型签名。
rbs.inlay.hints.ruby.container.type.name=类/模块类型变量
rbs.inlay.hints.ruby.global.variable.type.description=关联的声明旁边的全局变量类型(来自 RBS)。<br/><br/>按住 Ctrl 并点击提示可导航到类型签名。
rbs.inlay.hints.ruby.global.variable.type.name=全局变量类型
rbs.inlay.hints.ruby.method.parameter.type.description=关联的声明旁边的方法形参类型(来自 RBS)。<br/><br/>按住 Ctrl 并点击提示可导航到类型签名。
rbs.inlay.hints.ruby.method.parameter.type.name=方法形参类型
rbs.inlay.hints.ruby.method.return.type.description=关联的声明旁边的方法返回值类型(来自 RBS)。<br/><br/>按住 Ctrl 并点击提示可导航到类型签名。
rbs.inlay.hints.ruby.method.return.type.name=方法返回值类型
rbs.inspection.bad.type.argument.type.description=''{0}'' 不是 ''{1}'' 的子类型
rbs.inspection.bad.type.argument.type.name=错误的类型实参类型
rbs.inspection.bad.type.argument.type.replace.quickfix.family.name=替换错误的类型实参
rbs.inspection.bad.type.argument.type.replace.quickfix.name=替换 ''{0}''
rbs.inspection.bad.type.variable.default.type.description=''{0}'' 不是 ''{1}'' 的子类型
rbs.inspection.bad.type.variable.default.type.name=错误的类型变量默认类型
rbs.inspection.bad.type.variable.default.type.replace.quickfix.family.name=替换错误的默认类型
rbs.inspection.bad.type.variable.default.type.replace.quickfix.name=替换 ''{0}''
rbs.inspection.conflicting.type.variable.count.add.quickfix.family.name=添加缺少的类型变量
rbs.inspection.conflicting.type.variable.count.add.quickfix.name=添加{0, choice, 1\#类型变量|2\# {0} 个类型变量}
rbs.inspection.conflicting.type.variable.count.description={0}{1, choice, 0\#没有类型变量|1\#有 1 个类型变量|2\#有 {1} 个类型变量}，这与其他声明冲突
rbs.inspection.conflicting.type.variable.count.goTo.quickfix.family.name=转到冲突的声明
rbs.inspection.conflicting.type.variable.count.goTo.quickfix.name.popup.title=选择冲突的声明
rbs.inspection.conflicting.type.variable.count.name=冲突的类型变量计数
rbs.inspection.conflicting.type.variable.count.remove.quickfix.family.name=移除多余的类型变量
rbs.inspection.conflicting.type.variable.count.remove.quickfix.name=移除{0, choice, 1\#类型变量|2\# {0} 个类型变量}
rbs.inspection.conflicting.type.variable.variance.description={0} 有一个与{1, choice, 1\#其他声明|2\#其他声明}冲突的差异
rbs.inspection.conflicting.type.variable.variance.name=冲突的类型变量差异
rbs.inspection.cyclic.class.alias.name=循环类别名声明
rbs.inspection.cyclic.class.module.alias.name=循环类/模块别名声明
rbs.inspection.cyclic.module.alias.name=循环模块别名声明
rbs.inspection.duplicate=重复声明
rbs.inspection.duplicate.class.alias=重复的类别名声明
rbs.inspection.duplicate.class.alias.container=''{0}'' 已作为类存在
rbs.inspection.duplicate.class.exists=''{0}'' 已作为类存在
rbs.inspection.duplicate.constant=重复的常量声明
rbs.inspection.duplicate.different.superclass={0} 已使用 ''{1}'' 进行声明
rbs.inspection.duplicate.global.variable=重复的全局变量声明
rbs.inspection.duplicate.go.to.alias.quickfix.name=转到别名声明
rbs.inspection.duplicate.go.to.class.quickfix.name=转到类声明
rbs.inspection.duplicate.go.to.conflicting.declarations.quickfix.name=转到冲突的声明
rbs.inspection.duplicate.go.to.conflicting.declarations.title=选择冲突的声明
rbs.inspection.duplicate.go.to.duplicate.included.method.quickfix.name=转到重复的包含方法
rbs.inspection.duplicate.go.to.duplicate.included.method.title=选择重复的包含方法
rbs.inspection.duplicate.go.to.duplicate.quickfix.name=转到重复的声明
rbs.inspection.duplicate.go.to.duplicate.title=选择重复的声明
rbs.inspection.duplicate.go.to.module.quickfix.name=转到模块声明
rbs.inspection.duplicate.includes.method=包括方法 ''{0}'' 的重复定义
rbs.inspection.duplicate.inclusion.call.remove.quickfix.name=移除 ''{0}'' 调用
rbs.inspection.duplicate.interface=重复的接口声明
rbs.inspection.duplicate.interface.include=已包含 {0}
rbs.inspection.duplicate.keyword.parameter=重复的关键字形参
rbs.inspection.duplicate.method=重复的方法定义
rbs.inspection.duplicate.module.alias=重复的模块别名声明
rbs.inspection.duplicate.module.alias.container=''{0}'' 已作为模块存在
rbs.inspection.duplicate.module.exists=''{0}'' 已作为模块存在
rbs.inspection.duplicate.opened.class.alias=无法打开类别名 ''{0}''
rbs.inspection.duplicate.opened.module.alias=无法打开模块别名 ''{0}''
rbs.inspection.duplicate.remove.class.alias.quickfix.name=移除重复的类别名
rbs.inspection.duplicate.remove.conflicting.class.quickfix.name=移除冲突的类
rbs.inspection.duplicate.remove.conflicting.module.quickfix.name=移除冲突的模块
rbs.inspection.duplicate.remove.constant.quickfix.name=移除重复的常量
rbs.inspection.duplicate.remove.global.variable.quickfix.name=移除重复的全局变量
rbs.inspection.duplicate.remove.interface.quickfix.name=移除重复的接口
rbs.inspection.duplicate.remove.method.quickfix.name=移除重复的方法
rbs.inspection.duplicate.remove.module.alias.quickfix.name=移除重复的模块别名
rbs.inspection.duplicate.remove.quickfix.family.name=移除重复的声明
rbs.inspection.duplicate.remove.superclass.quickfix.name=移除冲突的超类
rbs.inspection.duplicate.remove.type.alias.quickfix.name=移除重复的类型别名
rbs.inspection.duplicate.type.alias=重复的类型别名声明
rbs.inspection.group.rbs=RBS
rbs.inspection.group.rbs.code.style.name=代码样式问题
rbs.inspection.group.rbs.data.flow.name=数据流
rbs.inspection.group.rbs.inheritance.name=继承问题
rbs.inspection.group.rbs.naming.conventions.name=命名约定
rbs.inspection.group.rbs.probable.bugs.name=可能的 bug
rbs.inspection.group.ruby=Ruby
rbs.inspection.group.ruby.rbs.name=RBS
rbs.inspection.inconsistent.class.alias.name=模块 ''{0}'' 用作类别名目标
rbs.inspection.inconsistent.class.module.alias.name=不一致的类/模块别名
rbs.inspection.inconsistent.class.module.alias.quickfix.name=转到冲突的声明
rbs.inspection.inconsistent.module.alias.name=类 ''{0}'' 用作模块别名目标
rbs.inspection.incorrect.inclusion.call=不正确的包含调用
rbs.inspection.incorrect.inclusion.call.extend.description=在 ''extend'' 调用中使用的{0}
rbs.inspection.incorrect.inclusion.call.extend.remove.quickfix.name=移除 ''extend {0}''
rbs.inspection.incorrect.inclusion.call.include.description=在 ''include'' 调用中使用的{0}
rbs.inspection.incorrect.inclusion.call.include.remove.quickfix.name=移除 ''include {0}''
rbs.inspection.incorrect.inclusion.call.prepend.description=在 ''prepend'' 调用中使用的{0}
rbs.inspection.incorrect.inclusion.call.prepend.remove.quickfix.name=移除 ''prepend {0}''
rbs.inspection.incorrect.inclusion.call.remove.quickfix.family.name=移除不正确的包含调用
rbs.inspection.incorrect.type.argument.count.add.description={0} 需要 {1, choice, 1\#1 个类型实参|2\#{1} 个类型实参}
rbs.inspection.incorrect.type.argument.count.add.quickfix.family.name=添加缺少的类型实参
rbs.inspection.incorrect.type.argument.count.add.quickfix.name=添加{0, choice, 1\#类型实参|2\# {0} 个类型实参}
rbs.inspection.incorrect.type.argument.count.name=类型实参计数不正确
rbs.inspection.incorrect.type.argument.count.remove.all.quickfix.name=移除{0, choice, 1\#类型实参|2\#类型实参}
rbs.inspection.incorrect.type.argument.count.remove.description=提供的类型实参过多
rbs.inspection.incorrect.type.argument.count.remove.quickfix.family.name=移除多余的类型实参
rbs.inspection.incorrect.type.argument.count.remove.quickfix.name=移除多余的{0, choice, 1\#类型实参|2\#类型实参}
rbs.inspection.incorrect.type.argument.variance.description=用作{2, choice, 0\#不变|1\#协变|2\#逆变}实参的{0} {1}
rbs.inspection.incorrect.type.argument.variance.name=不正确的类型实参差异
rbs.inspection.invalid.method.overload.description=找不到 {0} 的非重载声明
rbs.inspection.invalid.method.overload.name=无效的方法重载
rbs.inspection.invalid.method.overload.remove.method.quickfix.family.name=移除方法
rbs.inspection.invalid.method.overload.remove.method.quickfix.name=移除 ''{0}''
rbs.inspection.invalid.method.overload.remove.quickfix.family.name=移除 '...'
rbs.inspection.invalid.method.overload.replace.quickfix.family.name=替换为 '-> untyped'
rbs.inspection.invalid.type.argument.usage.description={0} {1} 用于{2, choice, 0\#不变|1\#协变|2\#逆变}位置
rbs.inspection.invalid.type.argument.usage.name=类型实参用法无效
rbs.inspection.literal.class.referenced.description=引用的是 ''{0}''，而不是 ''{1}''
rbs.inspection.literal.class.referenced.name=引用的字面量类
rbs.inspection.literal.class.referenced.replace.quickfix.family.name=替换为各自的字面量
rbs.inspection.literal.class.referenced.replace.quickfix.name=替换为 ''{0}''
rbs.inspection.mismatch.edit.typeSignature.family.name=编辑类型签名
rbs.inspection.mismatch.goto.typeSignature.error=无类型签名
rbs.inspection.mismatch.goto.typeSignature.family.name=转到类型签名
rbs.inspection.mismatch.goto.typeSignature.popup.title=选择类型签名
rbs.inspection.missing.type.signature.add.command.name=添加类型签名
rbs.inspection.missing.type.signature.add.create.file.name=创建 RBS 文件 {0}
rbs.inspection.missing.type.signature.add.create.file.title=新建 RBS 文件
rbs.inspection.missing.type.signature.add.disambiguate.title=选择类/模块
rbs.inspection.missing.type.signature.add.family.name=添加类型签名
rbs.inspection.missing.type.signature.declaration=缺少类型签名
rbs.inspection.missing.type.signature.declaration.attr.description=缺少{0, choice, 1\#{1}“{2}”|2\#{1}“{2}”和{3}“{4}”}的类型签名
rbs.inspection.missing.type.signature.declaration.description=缺少 ''{0}'' 的类型签名
rbs.inspection.module.used.as.superclass.description=用作超类的{0}
rbs.inspection.module.used.as.superclass.name=用作超类的模块
rbs.inspection.module.used.as.superclass.remove.quickfix.family.name=移除无效的超类
rbs.inspection.module.used.as.superclass.remove.quickfix.name=移除 ''< {0}''
rbs.inspection.simplifiable.boolean.union.description=可以简化 ''{0} | {1}''
rbs.inspection.simplifiable.boolean.union.name=可简化的布尔并集
rbs.inspection.simplifiable.boolean.union.replace.quickfix.family.name=简化布尔并集
rbs.inspection.simplifiable.boolean.union.replace.quickfix.name=将 ''{0} | {1}'' 替换为 ''bool''
rbs.inspection.unconventional.interface.name.name=非常规接口名称
rbs.inspection.unconventional.name.mismatched.description=''{0}'' 与 ''{1}'' 不匹配
rbs.inspection.unconventional.name.too.long.description=''{0}'' 过长，应为 {1} 个{1, choice, 1\#字符|2\#或更少字符}
rbs.inspection.unconventional.name.too.short.description=''{0}'' 过短，至少应为 {1} 个{1, choice, 1\#字符|2\#字符}
rbs.inspection.unconventional.type.alias.name.name=非常规类型别名名称
rbs.inspection.unconventional.type.variable.name.name=非常规类型变量名称
rbs.inspection.unconventional.use.alias.name.name=非常规 use 别名名称
rbs.inspection.unnecessary.parentheses.description=函数类型中不必要的圆括号
rbs.inspection.unnecessary.parentheses.name=不必要的圆括号
rbs.inspection.unnecessary.parentheses.remove.quickfix.name=移除不必要的圆括号
rbs.inspection.unnecessary.qualifier.description=''{0}'' 可以缩短
rbs.inspection.unnecessary.qualifier.name=不必要的限定符
rbs.inspection.unnecessary.qualifier.replace.quickfix.family.name=移除不必要的限定符
rbs.inspection.unnecessary.qualifier.replace.quickfix.name=替换为 ''{0}''
rbs.inspection.unresolved.reference.add.use.clause.quickfix.command=添加 use 子句
rbs.inspection.unresolved.reference.add.use.clause.quickfix.family.name=添加 use 子句
rbs.inspection.unresolved.reference.add.use.clause.quickfix.title=选择目标
rbs.inspection.unresolved.reference.description=找不到 ''{0}''
rbs.inspection.unresolved.reference.name=未解析的引用
rbs.inspection.unused.interface.description={0} 未使用
rbs.inspection.unused.interface.name=未使用的接口
rbs.inspection.unused.interface.remove.quickfix.family.name=移除未使用的接口
rbs.inspection.unused.interface.remove.quickfix.name=移除 ''{0}''
rbs.inspection.unused.type.alias.description={0} 未使用
rbs.inspection.unused.type.alias.name=未使用的类型别名
rbs.inspection.unused.type.alias.remove.quickfix.family.name=移除未使用的类型别名
rbs.inspection.unused.type.alias.remove.quickfix.name=移除 ''{0}''
rbs.inspection.unused.type.variable.description={0} 未使用
rbs.inspection.unused.type.variable.name=未使用的类型变量
rbs.inspection.unused.type.variable.remove.quickfix.family.name=移除未使用的类型变量
rbs.inspection.unused.type.variable.remove.quickfix.name=移除 ''{0}''
rbs.inspection.unused.use.clause.name=未使用的 use 子句
rbs.inspection.unused.use.clause.optimize.quickfix.family.name=优化 use 子句
rbs.inspection.unused.use.clause.shadowed.description=隐藏的 use 子句
rbs.inspection.unused.use.clause.unnecessary.alias.description=不必要的 use 别名
rbs.inspection.unused.use.clause.unnecessary.description=不必要的 use 子句
rbs.inspection.unused.use.clause.unused.description=未使用的 use 子句
rbs.intention.ruby.category.rbs=Ruby/RBS
rbs.intention.ruby.edit.typeSignature.command.name=编辑类型签名
rbs.intention.ruby.edit.typeSignature.disambiguate.title=选择类型签名
rbs.intention.ruby.edit.typeSignature.text=编辑类型签名
rbs.language.configurable=RBS
rbs.language.configurable.collection.description=<a href\="https\://github.com/ruby/gem_rbs_collection">RBS 集合</a>是一个社区管理的类型签名集合，适用于未带任何签名的 gem。类型签名将在后台自动下载，从而改进项目中使用的所有 gem 的类型支持和代码洞察。此功能不会修改项目或其文件。
rbs.language.configurable.collection.enable=通过 RBS 集合改进类型支持
rbs.language.configurable.name=RBS
rbs.lineMarker.overloaded.declarations=RBS 重载方法
rbs.lineMarker.overloaded.declarations.title=选择重载声明
rbs.lineMarker.overloaded.declarations.tooltip.few=在以下位置有重载声明\:
rbs.lineMarker.overloaded.declarations.tooltip.many=在多个文件中有重载声明
rbs.lineMarker.overloaded.declarations.tooltip.one=在以下位置有重载声明\:
rbs.lineMarker.partial.declarations=RBS 部分声明
rbs.lineMarker.partial.declarations.title=选择部分声明
rbs.lineMarker.partial.declarations.tooltip.few=在以下位置有部分声明\:
rbs.lineMarker.partial.declarations.tooltip.many=在多个文件中有部分声明
rbs.lineMarker.partial.declarations.tooltip.one=在以下位置有部分声明\:
rbs.live.template.presentable.name=RBS
rbs.model.attribute.accessor.longDescription={1} 的特性访问器 ''{0}''
rbs.model.attribute.accessor.shortDescription=特性访问器 ''{0}''
rbs.model.attribute.reader.longDescription={1} 的特性读取器 ''{0}''
rbs.model.attribute.reader.shortDescription=特性读取器 ''{0}''
rbs.model.attribute.writer.longDescription={1} 的特性编写器 ''{0}''
rbs.model.attribute.writer.shortDescription=特性编写器 ''{0}''
rbs.model.class.longDescription=''{1}'' 中的类 ''{0}''
rbs.model.class.shortDescription=类 ''{0}''
rbs.model.class.variable.longDescription={1} 的类变量 ''{0}''
rbs.model.class.variable.shortDescription=类变量 ''{0}''
rbs.model.constant.longDescription=''{1}'' 中的常量 ''{0}''
rbs.model.constant.shortDescription=常量 ''{0}''
rbs.model.descriptions.contravariant=逆变
rbs.model.descriptions.covariant=协变
rbs.model.descriptions.invariant=不变
rbs.model.descriptions.private.prefix=Private
rbs.model.global.variable.shortDescription=全局变量 ''{0}''
rbs.model.instance.variable.longDescription={1} 的实例变量 ''{0}''
rbs.model.instance.variable.shortDescription=实例变量 ''{0}''
rbs.model.interface.longDescription=''{1}'' 中的接口 ''{0}''
rbs.model.interface.shortDescription=接口 ''{0}''
rbs.model.keyword.shortDescription=关键字 ''{0}''
rbs.model.method.alias.longDescription={1} 的方法别名 ''{0}''
rbs.model.method.alias.shortDescription=方法别名 ''{0}''
rbs.model.method.longDescription={1} 的方法 ''{0}''
rbs.model.method.shortDescription=方法 ''{0}''
rbs.model.module.longDescription=''{1}'' 中的模块 ''{0}''
rbs.model.module.method.longDescription={1} 的模块方法 ''{0}''
rbs.model.module.method.shortDescription=模块方法 ''{0}''
rbs.model.module.shortDescription=模块 ''{0}''
rbs.model.parameter.shortDescription=形参 ''{0}''
rbs.model.singleton.fullName=单例类
rbs.model.singleton.longDescription=''{1}'' 中的单例 ''{0}''
rbs.model.singleton.name=单例类
rbs.model.singleton.shortDescription=单例 ''{0}''
rbs.model.type.alias.longDescription=''{1}'' 中的类型别名 ''{0}''
rbs.model.type.alias.shortDescription=类型别名 ''{0}''
rbs.model.type.variable.longDescription={1} 的类型变量 ''{0}''
rbs.model.type.variable.shortDescription=类型变量 ''{0}''
rbs.model.use.clause.alias.shortDescription=Use 别名 ''{0}''
rbs.notificationGroup.fileGeneration=RBS 文件生成
rbs.parameter.info.untyped.parameters=<非类型化形参>
rbs.ruby.model.class.longDescription=''{1}'' 中的类 ''{0}''
rbs.ruby.model.class.shortDescription=类 ''{0}''
rbs.ruby.model.module.longDescription=''{1}'' 中的模块 ''{0}''
rbs.ruby.model.module.shortDescription=模块 ''{0}''
rbs.ruby.model.singleton.longDescription=''{1}'' 中的单例 ''{0}''
rbs.ruby.model.singleton.shortDescription=单例 ''{0}''
rbs.rubysigs.banner=捆绑的签名文件
rbs.rubysigs.banner.with.versions=捆绑的签名文件(使用 RBS v{0} 和 Ruby v{1} 生成)
rbs.rubysigs.location=库根
rbs.rubysigs.name=rbs [bundled]
rbs.rubysigs.name.with.version=rbs (v{0}) [bundled]
rbs.search.presentation.in.container=({0} 中)
rbs.search.presentation.of.container=/{0}
rbs.search.scope.display.name=集合文件
rbs.search.usageType.alias.group=别名
rbs.search.usageType.declaration.group=声明
rbs.search.usageType.extend.include.prepend.call.group=extend/include/prepend 调用中的用法
rbs.search.usageType.nested.constant.access.group=嵌套常量访问
rbs.search.usageType.self.type.clause.group=自类型子句
rbs.search.usageType.superclass.clause.group=超类子句
rbs.search.usageType.type.signature.group=类型签名
rbs.search.usageType.type.variable.default.group=类型变量默认值
rbs.search.usageType.type.variable.upper.bound.group=类型变量上限
rbs.search.usageType.use.clause.group=use 子句
rbs.structure.view.qualified.name={1}中的{0}
steep.actions.run.anything.group.name=Steep
steep.actions.run.anything.help.placeholder=steep <command>

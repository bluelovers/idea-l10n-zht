filetype.rbs.description=RBS

rbs.model.attribute.accessor.shortDescription=特性访问器 ''{0}''
rbs.model.attribute.accessor.longDescription={1} 的特性访问器 ''{0}''
rbs.model.attribute.reader.shortDescription=特性读取器 ''{0}''
rbs.model.attribute.reader.longDescription={1} 的特性读取器 ''{0}''
rbs.model.attribute.writer.shortDescription=特性编写器 ''{0}''
rbs.model.attribute.writer.longDescription={1} 的特性编写器 ''{0}''
rbs.model.class.shortDescription=类 ''{0}''
rbs.model.class.longDescription=''{1}'' 中的类 ''{0}''
rbs.model.class.variable.shortDescription=类变量 ''{0}''
rbs.model.class.variable.longDescription={1} 的类变量 ''{0}''
rbs.model.constant.shortDescription=常量 ''{0}''
rbs.model.global.variable.shortDescription=全局变量 ''{0}''
rbs.model.instance.variable.shortDescription=实例变量 ''{0}''
rbs.model.instance.variable.longDescription={1} 的实例变量 ''{0}''
rbs.model.interface.shortDescription=接口 ''{0}''
rbs.model.interface.longDescription=''{1}'' 中的接口 ''{0}''
rbs.model.method.shortDescription=方法 ''{0}''
rbs.model.method.longDescription={1} 的方法 ''{0}''
rbs.model.module.shortDescription=模块 ''{0}''
rbs.model.module.longDescription=''{1}'' 中的模块 ''{0}''
rbs.model.singleton.shortDescription=单例 ''{0}''
rbs.model.type.alias.shortDescription=类型别名 ''{0}''
rbs.model.type.variable.shortDescription=类型变量 ''{0}''
rbs.model.type.variable.longDescription={1} 的类型变量 ''{0}''

rbs.model.descriptions.private.prefix=Private


# inspections
rbs.inspection.group.rbs.probable.bugs.name=可能的错误

# annotations
rbs.annotation.module.included.in.interface=接口中包含的类/模块
rbs.annotation.singleton.in.interface=接口内部的单例方法定义

# Line markers

rbs.lineMarker.partial.declarations=RBS 部分声明
rbs.lineMarker.partial.declarations.title=选择部分声明

# actions

rbs.actions.create.file.text=RBS 文件/类
rbs.actions.create.file.description=创建新的 RBS 文件/类
rbs.actions.create.file.name=创建 RBS 文件/类 {0}
rbs.actions.create.file.title=新建 RBS 文件/类名
rbs.actions.create.dialog.file=文件
rbs.actions.create.dialog.class=类
rbs.actions.create.dialog.module=模块
rbs.actions.create.dialog.interface=接口
rbs.actions.create.error.invalid.name=此名称对所选类型无效
rbs.model.keyword.shortDescription=关键字 ''{0}''
rbs.model.parameter.shortDescription=形参 ''{0}''
rbs.inspection.duplicate=重复声明
rbs.inspection.duplicate.type.alias=重复的类型别名声明
rbs.inspection.duplicate.global.variable=重复的全局变量声明
rbs.inspection.duplicate.constant=重复的常量声明
rbs.inspection.duplicate.class.exists=''{0}'' 已作为类存在
rbs.inspection.duplicate.module.exists=''{0}'' 已作为模块存在
rbs.inspection.duplicate.different.superclass={0} 已使用 ''{1}'' 进行声明
rbs.inspection.duplicate.interface=重复的接口声明
rbs.inspection.duplicate.method=重复的方法定义
rbs.inspection.duplicate.includes.method=包括方法 ''{0}'' 的重复定义
rbs.inspection.duplicate.interface.include=已包含 {0}
rbs.inspection.duplicate.parameter=重复的形参
rbs.live.template.presentable.name=RBS
rbs.model.constant.longDescription=''{1}'' 中的常量 ''{0}''
rbs.model.type.alias.longDescription=''{1}'' 中的类型别名 ''{0}''
rbs.actions.run.anything.group.name=RBS
steep.actions.run.anything.group.name=Steep
rbs.actions.run.anything.help.placeholder=rbs <command>
steep.actions.run.anything.help.placeholder=steep <command>
action.rbs.cli.validate.description=确保 RBS 文件中存在类型名称并且类型应用程序具有正确的实参数量
action.rbs.cli.prototype.description=生成原型 RBS 文件。支持的生成器包括 rb、rbi 和 runtime
action.rbs.cli.ancestors.description=显示给定类或模块的上级。
action.rbs.cli.ast.description=打印所加载环境的 JSON AST。您可以指定使用文件名筛选声明的模式
action.rbs.cli.constant.description=解析 RBS 内的给定常量
action.rbs.cli.list.description=列出所有类、模块和接口与定义
action.rbs.cli.method.description=显示通过 `type_name` 和 `method_name` 指定的方法的定义
action.rbs.cli.methods.description=显示在给定类或模块中定义的所有方法
action.rbs.cli.parse.description=解析给定 RBS 文件并打印任何语法错误
action.rbs.cli.paths.description=显示用于加载 RBS 文件的路径
action.rbs.cli.test.description=使用给定选项运行测试
action.rbs.cli.vendor.description=项目目录中的供应商签名
action.steep.cli.init.description=生成 Steepfile
action.steep.cli.validate.description=验证 Steep 配置
action.steep.cli.check.description=运行类型检查
action.steep.cli.annotations.description=检查给定源代码中的注解
action.rbs.generate.from.ruby.description=生成 Ruby 文件的 RBS 签名
rbs.action.output.null=无法运行 RBS prototype 命令
rbs.action.non.zero.exit.code=RBS 的非零退出代码: {0}
rbs.action.error.generating.rbs=生成 RBS 时出错: {0}
action.rbs.generate.from.ruby.text=生成类型签名
rbs.action.generate.title=正在生成类型签名
action.rbs.cli.validate.text=运行 RBS Validate
action.rbs.cli.prototype.text=运行 RBS Prototype
action.rbs.cli.ancestors.text=运行 RBS Ancestors
action.rbs.cli.ast.text=运行 RBS Ast
action.rbs.cli.constant.text=运行 RBS Constant
action.rbs.cli.list.text=运行 RBS List
action.rbs.cli.method.text=运行 RBS Method
action.rbs.cli.methods.text=运行 RBS Methods
action.rbs.cli.parse.text=运行 RBS Parse
action.rbs.cli.paths.text=运行 RBS Paths
action.rbs.cli.test.text=运行 RBS Test
action.rbs.cli.vendor.text=运行 RBS Vendor
action.steep.cli.init.text=运行 Steep Init
action.steep.cli.validate.text=运行 Steep Validate
action.steep.cli.check.text=运行 Steep Check
action.steep.cli.annotations.text=运行 Steep Annotations
action.steep.cli.project.text=运行 Steep Project
action.steep.cli.watch.text=运行 Steep Watch
action.steep.cli.langserver.text=运行 Steep Langserver
action.steep.cli.stats.text=运行 Steep Stats
action.rbs.generate.from.ruby.popup.text=类型签名
rbs.lineMarker.partial.declarations.tooltip.one=在以下位置有部分声明:
rbs.lineMarker.partial.declarations.tooltip.few=在以下位置有部分声明:
rbs.lineMarker.partial.declarations.tooltip.many=在多个文件中有部分声明
rbs.action.tab.title=运行 {0}
rbs.structure.view.qualified.name={0} ({1} 内)
rbs.rubysigs.location=库根
rbs.rubysigs.name=rbs ({0}) [bundled]
rbs.rubysigs.name.with.version=rbs (v{0}, {1}) [bundled]
rbs.rubysigs.banner=已捆绑的签名文件(使用 RBS v{0} 和 Ruby v{1} 生成)
rbs.lineMarker.overloaded.declarations=RBS 重载方法
rbs.lineMarker.overloaded.declarations.title=选择重载声明
rbs.lineMarker.overloaded.declarations.tooltip.one=在以下位置有重载声明:
rbs.lineMarker.overloaded.declarations.tooltip.few=在以下位置有重载声明:
rbs.lineMarker.overloaded.declarations.tooltip.many=在多个文件中有重载声明
rbs.inspection.group.rbs=RBS
rbs.inspection.group.rbs.code.style.name=代码样式问题
rbs.inspection.literal.class.referenced.name=引用的文字类
rbs.inspection.literal.class.referenced.description=引用的是 ''{0}''，而不是 ''{1}''
rbs.inspection.literal.class.referenced.replace.quickfix.name=替换为 ''{0}''
rbs.inspection.literal.class.referenced.replace.quickfix.family.name=替换为各自的文字
rbs.inspection.unnecessary.parentheses.name=不必要的圆括号
rbs.inspection.unnecessary.parentheses.description=函数类型中不必要的圆括号
rbs.inspection.unnecessary.parentheses.remove.quickfix.name=移除不必要的圆括号
rbs.inspection.incorrect.type.argument.count.name=类型实参计数不正确
rbs.inspection.incorrect.type.argument.count.add.description={0} 需要 {1, choice, 1#1 个类型实参|2#{1} 个类型实参}
rbs.inspection.incorrect.type.argument.count.add.quickfix.name=添加{0, choice, 1#类型实参|2# {0} 个类型实参}
rbs.inspection.incorrect.type.argument.count.add.quickfix.family.name=添加缺少的类型实参
rbs.inspection.incorrect.type.argument.count.remove.description=提供的类型实参过多
rbs.inspection.incorrect.type.argument.count.remove.quickfix.name=移除多余的{0, choice, 1#类型实参|2#类型实参}
rbs.inspection.incorrect.type.argument.count.remove.all.quickfix.name=移除{0, choice, 1#类型实参|2#类型实参}
rbs.inspection.incorrect.type.argument.count.remove.quickfix.family.name=移除多余的类型实参
rbs.annotation.type.alias.used.as.self.type=用作自类型的类型别名
rbs.annotation.type.alias.used.as.self.type.remove.intention.name=移除 ''{0}''
rbs.annotation.type.alias.used.as.self.type.remove.intention.family.name=移除无效的自类型
rbs.inspection.group.rbs.data.flow.name=数据流
rbs.inspection.unused.type.alias.name=未使用的类型别名
rbs.inspection.unused.type.alias.description={0} 未使用
rbs.inspection.unused.type.alias.remove.quickfix.name=移除 ''{0}''
rbs.inspection.unused.type.alias.remove.quickfix.family.name=移除未使用的类型别名
rbs.inspection.unused.interface.name=未使用的接口
rbs.inspection.unused.interface.description={0} 未使用
rbs.inspection.unused.interface.remove.quickfix.name=移除 ''{0}''
rbs.inspection.unused.interface.remove.quickfix.family.name=移除未使用的接口
rbs.inspection.simplifiable.boolean.union.name=可简化的布尔并集
rbs.inspection.simplifiable.boolean.union.description=可以简化 ''{0} | {1}''
rbs.inspection.simplifiable.boolean.union.replace.quickfix.name=将 ''{0} | {1}'' 替换为 ''bool''
rbs.inspection.simplifiable.boolean.union.replace.quickfix.family.name=简化布尔并集
rbs.inspection.dynamic.type.used.in.static.context.name=在 static 上下文中使用的动态类型
rbs.inspection.dynamic.type.used.in.static.context.description=在 static 上下文中使用的 ''{0}''
rbs.inspection.dynamic.type.used.in.static.context.replace.quickfix.name=替换为 ''{0}''
rbs.inspection.dynamic.type.used.in.static.context.replace.quickfix.family.name=替换为 static 对等项
rbs.search.presentation.element.in.container={0} ({1} 内)
rbs.search.usageType.alias.group=别名
rbs.search.usageType.declaration.group=声明
rbs.search.usageType.superclass.clause.group=超类子句
rbs.search.usageType.self.type.clause.group=self 型子句
rbs.search.usageType.extend.include.prepend.call.group=extend/include/prepend 调用中的用法
rbs.search.usageType.nested.constant.access.group=嵌套常量访问
rbs.search.usageType.type.signature.group=类型签名
rbs.inspection.group.rbs.inheritance.name=继承问题
rbs.inspection.module.used.as.superclass.name=用作超类的模块
rbs.inspection.module.used.as.superclass.description=用作超类的{0}
rbs.inspection.module.used.as.superclass.remove.quickfix.name=移除 ''< {0}''
rbs.inspection.module.used.as.superclass.remove.quickfix.family.name=移除无效的超类
rbs.annotation.interface.prepended=接口无法预置
rbs.annotation.interface.prepended.remove.quickfix.name=移除 ''prepend {0}''
rbs.annotation.interface.prepended.remove.quickfix.family.name=移除预置接口
rbs.inspection.unused.type.variable.name=未使用的类型变量
rbs.inspection.unused.type.variable.description={0} 未使用
rbs.inspection.unused.type.variable.remove.quickfix.name=移除 ''{0}''
rbs.inspection.unused.type.variable.remove.quickfix.family.name=移除未使用的类型变量
rbs.inspection.invalid.method.overload.name=无效的方法重载
rbs.inspection.invalid.method.overload.description=找不到 {0} 的非重载声明
rbs.inspection.invalid.method.overload.remove.quickfix.family.name=移除 '...'
rbs.inspection.invalid.method.overload.replace.quickfix.family.name=替换为 '() -> untyped'
rbs.inspection.invalid.method.overload.remove.method.quickfix.name=移除 ''{0}''
rbs.inspection.invalid.method.overload.remove.method.quickfix.family.name=移除方法
rbs.inspection.unresolved.reference.name=未解析的引用
rbs.inspection.unresolved.reference.description=无法找到 ''{0}''
rbs.inspection.incorrect.declaration.type.variable.count.name=不正确的类型变量计数
rbs.inspection.incorrect.declaration.type.variable.count.description={0} {1, choice, 0#没有类型变量|1#有 1 个类型变量|2#有 {1} 个类型变量}，这与其他声明冲突
rbs.inspection.incorrect.declaration.type.variable.count.add.quickfix.name=添加{0, choice, 1#类型变量|2# {0} 个类型变量}
rbs.inspection.incorrect.declaration.type.variable.count.add.quickfix.family.name=添加缺少的类型变量
rbs.inspection.incorrect.declaration.type.variable.count.remove.quickfix.name=移除{0, choice, 1#类型变量|2# {0} 个类型变量}
rbs.inspection.incorrect.declaration.type.variable.count.remove.quickfix.family.name=移除多余的类型变量
rbs.inspection.incorrect.declaration.type.variable.count.goTo.quickfix.family.name=转到冲突的声明
rbs.inspection.incorrect.declaration.type.variable.count.goTo.quickfix.name.popup.title=选择冲突的声明
rbs.inspection.incorrect.inclusion.statement=不正确的包含调用
rbs.inspection.incorrect.inclusion.statement.remove.quickfix.family.name=移除不正确的包含调用
rbs.inspection.incorrect.inclusion.statement.include.description=在 ''include'' 调用中使用的{0}
rbs.inspection.incorrect.inclusion.statement.include.remove.quickfix.name=移除 ''include {0}''
rbs.inspection.incorrect.inclusion.statement.prepend.description=在 ''prepend'' 调用中使用的{0}
rbs.inspection.incorrect.inclusion.statement.prepend.remove.quickfix.name=移除 ''prepend {0}''
rbs.inspection.incorrect.inclusion.statement.extend.description=在 ''extend'' 调用中使用的{0}
rbs.inspection.incorrect.inclusion.statement.extend.remove.quickfix.name=移除 ''extend {0}''
rbs.annotation.interface.prepended.replace.include.quickfix.name=将 ''prepend {0}'' 更改为 ''include {0}''
rbs.annotation.interface.prepended.replace.include.quickfix.family.name=将预置接口更改为 'include'
rbs.annotation.interface.prepended.replace.extend.quickfix.name=将 ''prepend {0}'' 更改为 ''extend {0}''
rbs.annotation.interface.prepended.replace.extend.quickfix.family.name=将预置接口更改为 'extend'
rbs.annotation.interface.prepended.replace.quickfix.name=将 ''prepend {0}'' 更改为 ''include {0}''
rbs.annotation.interface.prepended.replace.quickfix.family.name=将预置接口更改为 'include'
rbs.annotation.remove.statement.fix=移除语句
rbs.annotation.singleton.in.interface.remove.quickfix.name=移除单例方法
rbs.annotation.singleton.in.interface.remove.alias.quickfix.name=移除单例别名
rbs.annotation.singleton.method.in.interface.quickfix.name=转换为实例方法
rbs.annotation.singleton.alias.in.interface.quickfix.name=转换为实例别名
rbs.annotation.remove.include.statement.quickfix.name=移除 'include' 语句
rbs.annotation.singleton.method.in.interface.quickfix.family.name=将单例方法转换为实例方法
rbs.annotation.singleton.alias.in.interface.quickfix.family.name=将单例别名转换为实例别名
rbs.inspection.duplicate.inclusion.call.remove.quickfix.name=移除 ''{0}'' 调用
rbs.inspection.duplicate.remove.superclass.quickfix.name=移除冲突的超类
rbs.inspection.duplicate.remove.quickfix.family.name=移除重复的声明
rbs.inspection.duplicate.remove.method.quickfix.name=移除重复的方法
rbs.inspection.duplicate.remove.interface.quickfix.name=移除重复的接口
rbs.inspection.duplicate.remove.constant.quickfix.name=移除重复的常量
rbs.inspection.duplicate.remove.global.variable.quickfix.name=移除重复的全局变量
rbs.inspection.duplicate.remove.type.alias.quickfix.name=移除重复的类型别名
rbs.inspection.duplicate.go.to.duplicate.quickfix.name=转到重复的声明
rbs.inspection.duplicate.go.to.duplicate.title=选择重复的声明
rbs.inspection.duplicate.go.to.conflicting.declarations.quickfix.name=转到冲突的声明
rbs.inspection.duplicate.go.to.conflicting.declarations.title=选择冲突的声明
rbs.inspection.duplicate.remove.conflicting.class.quickfix.name=移除冲突的类
rbs.inspection.duplicate.remove.conflicting.module.quickfix.name=移除冲突的模块
rbs.inspection.duplicate.go.to.duplicate.included.method.quickfix.name=转到重复的包含方法
rbs.inspection.duplicate.go.to.duplicate.included.method.title=选择重复的包含方法
flash.module.type.name=Flash 模块
flash.module.type.description=Flash 模块旨在用于开发以 <b>Adobe Flash</b> 平台为目标的内容。<br>利用该模块提供的构建配置，您可以为 web (Flash Player)、桌面 (Adobe AIR) 和 AIR 移动平台创建 <b>Flex</b> 或纯 <b>ActionScript</b> 应用程序和库。

debugger.waiting.player=正在等待 AIR 或 Flash Player 连接
remote.flash.debug.computer=<html>调试器正在等待 Flash 应用程序连接:<br><ul><li>在此计算机上启动 Flash 或 AIR 应用程序。它将自动连接到调试器。</li><li>或右键点击此计算机或远程计算机上正在运行的 Flash Player，然后从上下文菜单中选择“调试器”。</li></ul>此计算机的 IP 地址: {0}</html>
remote.flash.debug.mobile.network=<html>在 {0} 设备上启动移动 AIR 应用程序以开始调试。<br>(必须打包该应用程序，才能通过网络进行调试)。<br><br>此计算机的 IP 地址: {1}</html>
remote.flash.debug.mobile.usb=<html>在 {0} 设备上启动移动 AIR 应用程序以开始调试。<br>(必须打包该应用程序，才能通过 USB 进行调试，端口 {1})。
initializing.flex.debugger=初始化 Flex 调试器
flex.debugger.startup.error=Flex 调试器启动错误
flex.debugger.unexpected.communication.error=意外的调试播放器通信问题

must.accompany.includein.or.excludefrom.attribute={0} 必须伴随 includeIn 或 excludeFrom 特性。
flex.invalid.enumeration.value={0} 不在可接受的枚举值内
flex.break.point.title=Flex 断点
flex.invalid.integer.value=整数值无效
flex.invalid.number.value=数值无效

no.file.to.run=找不到 HTML 包装器或 SWF 文件来开始运行/调试
remote.url.is.not.accessible.title=远程 URL 不可访问
remote.url.is.not.accessible.message=尝试提取 ''{0}'' 时遇到以下 IO 异常: \n\
{1}\n\
要继续吗?
flex.run.config.url.can.not.be.run.with.flash.player=无法使用 Flash Player 启动 URL
html.wrapper.can.not.be.run.with.flash.player=无法使用 Flash Player 启动 HTML 包装器
path.to.flash.player.not.set=未设置 Flash Player 的路径('Launch with' 选项)
flash.player.not.found=找不到 Flash Player 可执行文件: {0}
run.trusted=将输出文件夹放到本地信任沙盒中(&E)
flex.run.config.incorrect.url=URL 不正确
flex.run.config.url.not.set=未设置要启动的 URL 或文件
debugger.sdk.not.found=找不到 SDK: {0}
file.not.found=找不到文件: {0}
main.class.not.set=未指定主类
main.class.not.found=找不到主类 ''{0}''
rlm.main.class.not.set=未指定运行时加载模块的主类。
rlm.main.class.not.found=找不到运行时加载模块的主类: {0}
rlm.main.class.equal.to.bc.main.class=运行时加载模块的主类等于主应用程序类: ''{0}''
rlm.output.equal.to.bc.output=运行时加载模块的输出文件等于主应用程序的输出文件: ''{0}''
output.file.name.not.specified=未指定输出文件名。
rlm.output.file.name.not.specified=未指定运行时加载模块的输出文件。
output.file.must.have.swf.extension=输出文件必须有 swf 扩展名。
rlm.output.file.must.have.swf.extension=运行时加载模块的输出文件必须有 swf 扩展名。
flex.sdk.version.unknown=未知版本
popup.title.step.into.function=单步进入函数
sdk.can.not.be.selected=无法在此处选择 SDK ''{0}''。\n\
请选择 Flex/AIR SDK。
select.flex.sdk=选择 Flex/AIR SDK
cannot.resolve.state=状态引用无效
configuration.not.valid=运行配置错误: {0}
module.not.specified=未指定模块
module.not.found=找不到模块 ''{0}''
flexunit.not.found.for.bc=构建配置 ''{0}'' 的依赖项不包括 FlexUnit 库
no.test.method.specified=未指定测试方法
method.not.valid=方法 ''{0}'' 不存在或不适合在测试中运行
package.not.valid=缺少 ''{0}'' 软件包或此软件包为空
class.not.public=''{0}'' 不为 public
class.not.specified=未指定类
test.class.not.specified=未指定测试类
class.not.found=未找到类 ''{0}''
class.contains.no.tests=类 ''{0}'' 不包含测试
tests.in=''{0}'' 中的测试
no.free.port=找不到空闲端口
flexunit.startup.error=无法启动 FlexUnit 会话: {0}
port.is.busy=端口 {0} 繁忙

flexunit.inspections.group=FlexUnit
flexunit.inspection.testclassvisibility.displayname=测试类不为 public
flexunit.inspection.testmethodvisibility.displayname=测试方法不为 public
flexunit.inspection.testclassvisibility.message=测试类应为 public
flexunit.inspection.testmethodvisibility.message=测试方法应为 public
flexunit.inspection.testmethodisstatic.displayname=测试方法为 static
flexunit.inspection.testmethodisstatic.message=测试方法不应为 static
flexunit.fix.remove.static.modifier=移除 static 修饰符
flexunit.inspection.testmethodisproperty.displayname=测试方法为 getter/setter
flexunit.inspection.testmethodisproperty.message=测试方法不应为 getter 或 setter
flexunit.inspection.testmethodhasparameters.displayname=测试方法具有必需参数
flexunit.inspection.testmethodhasparameters.message=测试方法不应具有必需参数
flexunit.inspection.testmethodreturntype.displayname=测试方法应返回 void
flexunit.inspection.testmethodreturntype.message=测试方法应返回 void
flexunit.inspection.mixedapi.displayname=扩展 FlexUnit 1 或 Flunit TestCase 的类中的 FlexUnit 4 测试方法
flexunit.inspection.mixedapi.message=扩展 FlexUnit 1 或 Flunit TestCase 的类中的 FlexUnit 4 测试方法
flexunit.inspection.testclassinproductsource.displayname=产品源中的测试类
flexunit.inspection.testclassinproductsource.message=产品源中的测试类
flexunit.inspection.testclasswithnotests.displayname=测试类没有测试
flexunit.inspection.testclasswithnotests.message=测试类没有测试
flexunit.inspection.runnerclass.displayname=自定义运行程序类实现 IRunner 接口
flexunit.inspection.runnerclass.message=类未实现 IRunner 接口
flexunit.inspection.testmethodinsuite.message=测试方法位于套件中
flexunit.inspection.testmethodinsuite.displayname=测试方法位于套件中
flexunit.inspection.emptysuite.message=测试套件为空
flexunit.inspection.emptysuite.displayname=测试套件为空
flexunit.inspection.suitewithnorunner.displayname=测试套件未指定运行程序类
flexunit.inspection.suitewithnorunner.message=测试套件未指定运行程序类
flexunit.test.runner.caption=FlexUnit 测试运行程序
invalid.flex.compiler.heap.size=Flex 编译器堆大小无效
fcsh.out.of.memory.and.restarted=Flex 编译器 shell 内存不足，将重启。在“{0} | 编译器 | Flex 编译器”页面可以增加其堆大小
compiling.module=正在编译模块 ''{0}''…
unnamed=未命名
js.actionscript.specific.group.name=ActionScript 特定
js.implicitly.internal.declaration.inspection.name=具有隐式访问类型的声明
js.implicitly.internal.declaration.problem=声明具有隐式软件包内部范围 #loc
js.implicitly.internal.declaration.problem.add.internal.fix=添加显式 internal 修饰符
js.untyped.declaration.inspection.name=没有类型的声明
js.untyped.variable.problem=变量 {0} 没有类型 #loc
js.untyped.function.problem=函数 {0} 没有返回类型 #loc
js.untyped.declaration.problem.addtype.fix=向声明中添加类型
js.field.can.be.local.name=字段可以为本地字段
js.field.can.be.converted.to.local=字段可以被转换为一个局部变量
js.convert.to.local.quick.fix=转换为本地

flash.builder=Flash Builder
flash.builder.project.import.title=Flash Builder 项目导入
sdk.for.imported.projects=所导入的 Flash Builder {0, choice, 1#项目|2#项目}的 SDK: 
flash.builder.workspace.or.project.dir=Flash Builder 工作区或项目，*.fxp、*.fxpl 或 *.zip 文件(&F)
select.flash.builder.workspace.or.project=选择 *.fxp、*.fxpl 或 *.zip 文件、Flash Builder 工作区或项目
specify.flash.builder.workspace.or.project.dir=未设置文件或文件夹路径
dialog.title.import.from.flash.builder=从 Flash Builder 导入 {0}
folder.not.empty=文件夹不为空: \n\
{0}\n\
某些文件可能会被覆盖。\n\
\n\
是否继续?
folder.does.not.exist=文件夹不存在: ''{0}''
file.or.folder.not.found=找不到文件或文件夹: {0}
flash.builder.projects.not.found.in=在所选文件夹中找不到 Flash Builder 项目
not.flash.builder.project=所选文件不是 Flash Builder 项目
does.not.contain.flash.builder.projects=所选归档不包含 Flash Builder 项目
incorrect.file.format=所选归档的格式不正确
folder.to.unzip.one.FB.project=将项目提取到
folder.to.unzip.several.FB.projects=找到多个项目。将它们提取到以下项目的对应子文件夹:
note.multiple.projects.extract.to.subfolders=注意: 找到多个项目。它们将被提取到对应的子文件夹。
extract.single.to.subfolder.0=为提取的项目创建子文件夹 ''{0}''
project.location=项目位置
project.files.location=项目文件位置
open.project.0=打开项目 ''{0}''
failed.to.extract.project=无法提取项目: \n\
{0}
project.name.empty=项目名称不能为空
project.path.empty=项目文件的位置不能为空
looking.for.flash.builder.projects=正在查找 Flash Builder 项目

adl.not.set.check.sdk.settings=未设置 AIR Debug Launcher。检查 SDK ''{0}'' 的配置
adl.not.found.check.sdk.settings=在 ''{0}'' 处找不到 AIR Debug Launcher。检查 SDK ''{1}'' 的配置
adl.not.found.check.sdk.installation=在 ''{0}'' 处找不到 AIR Debug Launcher。检查 SDK ''{1}'' 的安装
air.runtime.not.set.check.sdk.settings=未设置 AIR 运行时。检查 SDK ''{0}'' 的配置
air.runtime.not.found.check.sdk.settings=在 ''{0}'' 处找不到 AIR 运行时。检查 SDK ''{1}'' 的配置
checking.url=正在检查 URL ''{0}''
bad.url=错误的 URL: {0}
no.response.from.server={0} 秒内服务器无响应
choose.event.class.title=选择事件类
compilation.skipped.because.nothing.changed.in=自上次编译以来，模块 ''{0}'' 中没有进行过任何更改。跳过…\n\
点击“构建”菜单中的“重新构建项目”以强制进行编译。
compilation.skipped.because.nothing.changed=自上次编译以来没有进行过任何更改。跳过…\n\
点击“构建”菜单中的“重新构建项目”以强制进行编译。
compilation.skipped=已跳过编译
dumb.mode.flex.unit.warning=更新索引时无法运行 FlexUnit 测试。构建索引后，请再次执行此运行配置。
debugger.show.full.value=查看
breakpoint.condition.error=断点条件错误
failed.to.evaluate.breakpoint.condition=无法评估断点条件: {0}\n\
\n\
要在断点处停止吗?
not.boolean.breakpoint.condition=无法评估断点条件: {0}\n\
结果值不是布尔值: {1}\n\
\n\
要在断点处停止吗?

error.creating.flash.player.trust.folder=SWF 文件未添加到本地信任沙盒\n\
无法创建 FlashPlayerTrust 文件夹: {0}
flash.player.trust.folder.does.not.exist=SWF 文件未添加到本地信任沙盒\n\
FlashPlayerTrust 文件夹不存在
error.creating.idea.trust.cfg.file=SWF 文件未添加到本地信任沙盒\n\
无法在 FlashPlayerTrust 文件夹中创建 {0} 文件: {1}
could.not.find.swf.to.trust=找不到要添加到本地信任沙盒的 SWF 文件
failed.to.update.idea.trust.cfg.file=无法更新 FlashPlayerTrust 文件夹中的 {0} 文件: {1}

file.created=已创建 <a href="">{0}</a>
html.wrapper.creation.failed=无法创建 HTML 包装器\n\
{0}
error.title=错误

root.tag.must.contain.language.namespace=根标记必须包含语言命名空间声明
different.language.namespaces=在 MXML 文件中声明了不同的语言命名空间
remove.namespace.declaration=移除命名空间声明
declare.namespace=声明命名空间 {0}
flex.choose.color.dialog.title=选择颜色
system.default.application=系统默认应用程序
launch.with.title=启动方式
cant.launch=无法使用 {1}\n\
打开 {0}\n\
错误: {2}
css.files.title=要编译为 SWF 的 CSS 文件

livetemplate.description.iter=迭代 (for each..in)
livetemplate.description.itin=迭代(for..in)
livetemplate.description.itar=遍历数组元素
livetemplate.description.ritar=反序遍历数组元素

create.skin=创建皮肤 ''{0}''
invalid.element.name=无效 {0} 名称: {1}
element.name.empty={0} 名称为空
choose.host.component=选择主机组件
css.inspections.stray.brace=Flex CSS 中的杂散大括号
css.inspections.stray.closing.brace=右大括号没有对应的左大括号
css.inspections.stray.opening.brace=左大括号没有对应的右大括号
choose.parent.component.dialog.title=选择父组件
intention.create.subclass.or.implement.interface=创建子类或实现接口
intention.create.event.handler=创建事件处理程序

threads=线程
processes=进程
using.builtin.compiler=使用内置的编译器 shell，最多 {0} 个并行线程
using.mxmlc.compc=使用 Flex SDK 中的 mxmlc/compc 工具，最多 {0} 个并行进程
or.asc.2.0=，或 ASC 2.0(如果可用)，用于纯 ActionScript 构建配置
see.flex.compiler.page=在“{0} | 编译器 Flex 编译器”页面中查看编译器设置
can.not.use.built.in.compiler.shell=无法使用内置的编译器 shell，原因是为不同的构建配置配置了不同的 Flex SDK。

add.doc.url.button=添加文档 URL

generating.flex.configs=正在生成 Flex 编译器配置文件
generating.flex.config.for=正在为 {0} 生成 Flex 编译器配置文件
flexmojos.warning.short=<html>无法生成 Flex 编译器配置文件。<br><a href="">详细信息…</a></html>
flexmojos.warning.detailed=<html><p>IntelliJ IDEA 无法生成 <b>Flex 编译器配置文件</b>和其他辅助文件<br>(target/[project_name]-config-report.xml and target/classes/config-[version]/*.*)</p><br><p>这些文件对于 Flexmojos 项目中的正确代码高亮显示、补全和编译而言必不可少。<br>要确保所需文件处于最新状态，请从命令行运行以下 Maven 命令: </p><pre><b>mvn compile -DconfigurationReport=true</b></pre></html>

flexmojos4.details.start=日志中提供了完整的信息(帮助 | 显示日志)\n\
\n\
{0}
flexmojos4.warning=无法生成 Flex 编译器配置文件。\n\
{0}
flexmojos4.warning.with.link=<html>无法生成 Flex 编译器配置文件。<br><a href="">详细信息…</a></html>
flexmojos.maven.plugin.outdated.warning=请从您的 POM ({0})中移除过时的 idea-flexmojos-maven-plugin

flexmojos.project.import=Flexmojos 项目导入
run.when.ide.builder.turned.off=<html>为<a href="BuildConfiguration">构建配置 ''{0}''</a>(模块 ''{1}'')设置了“跳过编译”标志。<br>启动的应用程序可能丢失或已过时。<br><br><a href="DisableWarning">禁用警告</a></html>
run.when.compile.before.run.turned.off=<html>此<a href="RunConfiguration">运行配置</a>的“启动前构建”选项已关闭。<br>启动的应用程序可能丢失或已过时。<br><br><a href="DisableWarning">禁用警告</a></html>
flex.sdk.3.mac.debug.problem=<html>Flex SDK {0} 中的调试器不适用于 Flash Player11.x。<br/>建议在<a href="RunConfiguration">运行配置</a>的“使用 SDK 中的调试器”字段选择 Flex SDK 4.x。
edit.configuration.title=编辑配置
replace.base.component.prompt=将基础组件 ''{0}'' 替换为 ''{1}''?
replace.base.class.prompt=将基类 ''{0}'' 替换为 ''{1}''?
create.edge.title=创建边缘
create.extends.relationship.command.name={0} 扩展 {1}
create.implements.relationship.command.name={0} 实现 {1}
base.component.needed.message=无法移除与基础组件的关系
remove.edge.title=移除边缘
remove.inheritance.link.prompt=移除 ''{0}'' 与 ''{1}'' 之间的继承链接?
remove.relationship.command.name=移除继承关系
move.0=移动 {0} {1}
move.file.local.0=移动内部{0}{1}
move.elements=移动指定的元素
move.command.name=将 {0} 移至 {1}
element.to.be.moved.to={0} 将被移至 {1}
elements.to.be.moved.to=元素将被移至{0}
references.in.code.to.0=在代码中引用到{0}
package.name.title=软件包名称:
to.package.title=到软件包:
element.to.be.moved.to.upper.level=内部{0}将被移至上一个级别({1})
move.to.upper.level.command.name=将内部{0}移至{1}
references.in.code.to.inner.0=代码中对内部{0}的引用
element.name={0} 名称(&N):
android.application.launched=在设备上启动的 Android 应用
ios.application.packaged.to.run=<html>iOS 应用程序软件包 <a href="">{0}</a> 已成功创建。<br>您现在可以使用 iTunes 将其安装在设备上。</html>
ios.application.packaged.to.debug=<html>iOS 应用程序软件包 <a href="">{0}</a> 已成功创建。<br>您现在可以使用 iTunes 在设备上进行安装。<br><br>调试器正在等待在该设备上启动应用程序…</html>
ios.application.installed.to.run=已成功安装 iOS 应用程序 ''{0}''，\n\
现在您可以在设备上启动它了。
ios.application.installed.to.debug=已成功安装 iOS 应用程序 ''{0}''，\n\
现在您可以在设备上启动并开始调试了。
ios.simulator.application.launched=在 iOS 模拟器上启动的应用程序

css.flex.dialect.name=Flex
unexpected.empty.adt.output=ADT 工具无输出
air.mobile.version.problem.title=AIR 版本
air.ios.debug.via.usb.requires.3.4=要通过 USB 调试 iOS 应用程序，需要使用 <b>AIR 3.4 或更高版本</b>。
air.ios.simulator.requires.3.3=要在 iOS 模拟器上运行应用程序，需要使用 <b>AIR 3.3 或更高版本</b>。
air.captive.packaging.requires.3.0=要使用 captive runtime 创建 AIR 软件包，需要使用 <b>AIR 3.0 或更高版本</b>。
air.mobile.ios.fast.packaging.requires.2.7=要在解释器模式(快速打包)下创建 iOS 软件包，需要使用 <b>AIR 2.7 或更高版本</b>。
air.mobile.packaging.requires.2.6=要创建 AIR 移动软件包，需要使用 <b>AIR 2.6 或更高版本</b>。
air.mobile.packaging.version.problem=<html>{0}<br><br>SDK ''{1}'' 包含 AIR {2}。<br>您可以执行下面的一项操作:<ul><li>在当前使用的 Flex SDK 上解压缩 AIR SDK {3} 或更高版本</li><li>使用已包含 AIR {3} 或更高版本的 Flex SDK 的另一个版本</li></ul></html>
launch.android.application.title=启动 Android 应用
launching.android.application=启动 Android 应用 {0}
launch.ios.application.title=启动 iOS 应用程序
launching.ios.application=启动 iOS 应用程序 {0}
adb.forward.title=ADB 前向
check.ios.devices.title=检查 iOS 设备
checking.ios.devices=正在检查 iOS 设备
more.than.one.ios.device=多台 iOS 设备已连接到计算机
idb.forward=IDB 前向
idb.forward.title=IDB 前向
packaging.application=打包 {0} 应用程序
air.application.created=创建的 <html>AIR {0, choice, 1#应用程序|2#应用程序}: <br>{1}</html>
dialog.edit.template.checkbox.mxml=MXML(&M)
air.runtime.version.title=AIR 运行时版本
air.runtime.not.installed=设备上未安装 AIR 运行时。\n\
SDK ''{0}'' 包含 AIR 运行时 {1}。\n\
\n\
要安装吗?
update.air.runtime.question=设备上已安装 AIR 运行时 {0}。\n\
SDK ''{1} 包含 AIR 运行时 {2}。\n\
\n\
要安装较新的版本吗?
check.air.version.title=检查 AIR 版本
checking.air.version=正在检查 AIR 版本
uninstall.air.runtime.title=卸载 AIR 运行时
uninstalling.air.runtime=正在卸载 AIR 运行时
install.air.runtime.title=安装 AIR 运行时
installing.air.runtime=正在安装 AIR 运行时 {0}
create.android.package.title=创建 Android 软件包
create.ios.package.title=创建 iOS 软件包
creating.android.package=正在创建 Android 软件包
creating.ios.package=正在创建 iOS 软件包
install.android.application.title=安装 Android 应用
install.ipa.on.simulator.title=在 iOS 模拟器上安装应用程序
install.ios.app.title=安装 iOS 应用程序
installing.0=正在安装 {0}
uninstall.android.application.title=卸载 Android 应用
uninstall.ios.simulator.application.title=从 iOS 模拟器卸载应用程序
uninstalling.0=正在卸载 {0}
clear.directive.state.specific.error='@Clear' 指令只能用于状态特定的样式属性
clear.directive.IStyleClient.error=仅允许实现 mx.styles.IStyleClient 接口的类的样式属性使用 '@Clear()' 指令
unknown.color.error=未知颜色: ''{0}''
sdk.not.set=未设置 SDK
output.file.name.not.set=未设置输出文件名
output.file.wrong.extension=输出文件名必须有 {0} 扩展名
not.a.css.runtime.stylesheet=文件 ''{0}'' 不能用作运行时样式表，仅允许使用 CSS 文件。
css.not.found=运行时样式表: 文件不存在: {0}
file.to.include.in.swc.not.found=要包含在 SWC 中的文件: 文件 ''{0}'' 不存在
output.folder.not.set=未设置输出文件夹
flexunit.output.folder.not.set=未设置项目输出文件夹或其路径不是绝对路径(FlexUnit 需要绝对路径)
output.folder.not.absolute=输出文件夹的路径必须为绝对路径: {0}
html.template.folder.not.set=未设置包含 HTML 包装器模板的文件夹
html.template.folder.not.found=包含 HTML 包装器模板的文件夹不存在: ''{0}''
package.file.name.not.set=未设置 {0} 软件包文件名
packaging.options.empty.file.name={0} 打包选项，要打包的文件: 表中的路径为空
packaging.options.empty.relative.path={0} 打包选项，要打包的文件: 表中的相对路径为空
folder.to.package.includes.output={0} 打包选项: 要打包的文件夹包含输出文件夹: {1}
packaging.options.bad.ios.sdk.path={0} 打包选项: 在 {1} 下找不到 iOS SDK
ios.provisioning.profile.not.set=未设置 iOS 预配配置文件
ios.provisioning.profile.not.found=找不到 iOS 预配配置文件: {0}
keystore.not.set={0} 签名选项: 未设置密钥库
keystore.not.found={0} 签名选项: 找不到密钥库文件: {1}
packaging.options.relative.path.not.matches={0} 打包选项，要打包的文件: 相对文件夹路径与其完整路径不匹配: {1}
packaging.options.file.not.found={0} 打包选项，找不到文件: {1}
additional.config.file.not.found=找不到其他编译器配置文件: {0}
bc.dependency.problem=发现禁止的依赖项: \n\
构建配置 ''{0}'' ({2}，模块 ''{1}'')\n\
依赖于构建配置 ''{3}'' ({5}，模块 ''{4}'')。\n\
依赖项类型: {6}
run.configuration.0=运行配置 ''{0}''
project.setup.problem=项目设置问题: {0}
project.setup.problem.title=项目设置问题
bc.dependency.does.not.exist=构建配置 ''{0}'' (模块''{1}'')不存在。\n\
设置为构建配置 ''{2}'' (模块 ''{3}'')的依赖项
bc.not.specified=未指定构建配置
module.does.not.contain.bc=模块 ''{0}'' 不包含构建配置 ''{1}''
bc.does.not.produce.app=构建配置 ''{0}'' (模块 ''{1}'')不会生成可运行的应用程序
android.disabled.in.bc=未在构建配置 ''{0}'' (模块 ''{1}'')中启用 Android 支持
ios.disabled.in.bc=未在构建配置 ''{0}'' (模块 ''{1}'')中启用 iOS 支持
bc.0.module.1.android.custom.descriptor.not.set=构建配置 ''{0}'' (模块 ''{1}''):\n\
未设置自定义 Android 应用描述符路径
bc.0.module.1.ios.custom.descriptor.not.set=构建配置 ''{0}'' (模块 ''{1}''):\n\
未设置自定义 iOS 应用描述符路径
bc.0.module.1.custom.descriptor.not.set=构建配置 ''{0}'' (模块 ''{1}''):\n\
未设置自定义应用描述符路径
bc.0.module.1.android.custom.descriptor.not.found=构建配置 ''{0}'' (模块 ''{1}''): \n\
找不到自定义 Android 应用描述符:\n\
{2}
bc.0.module.1.ios.custom.descriptor.not.found=构建配置 ''{0}'' (模块 ''{1}''): \n\
找不到自定义 iOS 应用描述符:\n\
{2}
bc.0.module.1.custom.descriptor.not.found=构建配置 ''{0}'' (模块 ''{1}''):\n\
找不到自定义应用描述符: \n\
{2}
bc.0.module.1.air.version.mismatch.warning=构建配置 ''{0}'' (模块 ''{1}''):<br>应用描述符中的 AIR 版本({2})与 AIR SDK 版本不匹配: {3}。<br>{4}
custom.descriptor.not.set=未设置自定义 {0} 应用描述符路径
custom.descriptor.not.found=找不到自定义 {0} 应用描述符: {1}
air.version.mismatch.warning=警告: {0} 应用描述符 {1} 中的 AIR 版本({2})与 AIR SDK 版本不匹配: {3}
same.output.files=输出文件与构建配置 ''{0}'' (模块 ''{1}'')中的相同: {2}
same.output.files.as.in.bcs=输出文件与构建{0, choice, 1#配置|2#配置} {1} 相同: {2}
sdk.does.not.support.air.mobile=Flex SDK {0} 不支持 AIR 移动开发
sample.app.name.empty=未指定示例应用程序文件名
sample.app.incorrect.extension=示例应用程序必须具有 .mxml 或 .as 文件扩展名
failed.to.create.folder=无法创建文件夹 {0}: \n\
{1}
create.html.wrapper.template.title=创建 HTML 包装器模板
selected.path.not.folder=所选路径不是文件夹: \n\
{0}
folder.not.empty.clear.or.overwrite=所选文件夹不为空。\n\
要移除其内容还是保留现有文件(在后一种情况下，某些文件可能会被覆盖)?
folder.not.empty.clear.option=移除(&R)
folder.not.empty.keep.option=保持(&K)
folder.not.empty.cancel.option=取消(&C)
failed.to.delete=无法移除文件: \n\
{0}
html.wrapper.in.sdk.not.found=在 SDK 安装中找不到包含 HTML 包装器模板的文件夹: \n\
{0}
create.air.descriptor.template.title=创建 AIR 描述符模板
use.same.descriptor.for.android.and.ios=要将创建的 AIR 描述符模板用于 Android 和 iOS 打包吗?
file.exists.replace.question=要替换现有文件({0})吗?
default.compiler.options.for.module.title=模块 ''{0}'' 的默认编译器选项
default.compiler.options.for.project.title=项目 ''{0}'' 的默认编译器选项
overridden.in.config.file={0} 被其他编译器配置文件覆盖。实际值: {1}
main.class.and.output.overridden.in.config.file=主类和输出路径在其他编译器配置文件中被覆盖
actual.value.from.config.file.0=配置文件中的实际值: {0}
set.up.sdk.title=设置构建配置 SDK
choose.build.configuration.popup.title=模块 ''{0}'' 的有效 Flash 构建配置
active.bc.widget.tooltip=Flash 构建配置 ''{0}'' 用于模块 ''{1}'' 中的源代码高亮显示和补全
active.bc.widget.empty.tooltip=<html>此窗格显示了上下文中该模块的有效 Flash 构建配置。<br>有效构建配置用于高亮显示和补全源代码。</html>
active.bc.widget.empty.text=Flash 构建配置
flex.sdk.presentable.name=Flex/AIR SDK
add.build.configuration.title=添加构建配置(模块 ''{0}'')
copy.build.configuration=复制构建配置 ''{0}'' (模块 ''{1}'')
build.configurations.popup.separator.text=构建配置
module.sdk.label=模块 SDK(&S):
project.sdk.label=项目 SDK(&S):
bc.0.module.1.problem.2=构建配置 ''{0}'' (模块 ''{1}''): {2}
bc.tab.general.display.name=常规
bc.tab.dependencies.display.name=依赖项
bc.tab.compiler.options.display.name=编译器选项
bc.tab.air.desktop.display.name=AIR 软件包
bc.tab.android.display.name=Android
bc.tab.ios.packaging.display.name=iOS
bc.problem.no.sdk=未定义 SDK。
bc.problem.sdk.not.found=找不到 Flex SDK ''{0}''。
bc.problem.dependency.module.not.found=缺少依赖项模块 ''{0}''。
bc.problem.dependency.bc.not.found=模块 ''{1}'' 中缺少依赖项构建配置 ''{0}''。
bc.structure.element.type.name=构建配置
can.not.package.bc=<html><b>{0}</b>: {1}</html>
package.bc.with.disabled.compilation=<html>为以下构建{0, choice, 1#配置|2＃配置} 禁用编译: <br><br>{1}<br>现有 SWF {0, choice, 1#文件|2#文件} 可能已过时。<br><br>根据现有的SWF {0, choice, 1#文件|2#文件} 创建{0, choice, 1#软件包|2#软件包}?</html>
package.air.application.title=打包 AIR 应用程序
packaging.air.application=正在打包 AIR 应用程序: {0}
failed.to.create.air.package=<html>无法打包 AIR 应用程序 {0}: <br><br>{1}<br><br>[<a href="adt.command.line">ADT 命令行</a>]</html>
failed.to.create.air.package.truncated=<html>无法打包 AIR 应用程序 {0}: <br><br>{1}<br><br>[<a href="full.error.message">完整错误消息</a>]<br>[<a href="adt.command.line">ADT 命令行</a>]</html>
copying.0=正在复制 {0}…
add.bc.dependency.dialog.title=添加依赖项
add.dependency.bc.dialog.label=选择要依赖的构建配置:
no.applicable.bcs=找不到适用的构建配置
choose.bc.dialog.title=选择 Flash 构建配置
choose.bc.dialog.label=库 ''{0}'' 将添加到所选构建配置:
swc.libraries.root.detector.name=SWC 或 ANE 库
docs.root.detector.name=文档
as.libraries.root.detector.name=原始 ActionScript 库
sources.root.detector.name=库源代码
swc.folders.root.detector.name=包含 SWC 或 ANE 的文件夹
add.module.library.action.text=新建库…
documentation.order.root.type.name=文档
items.to.include.in.swc.dialog.title=要包含在 SWC 中的文件和文件夹
rlms.dialog.title=运行时加载的模块
choose.rlm.main.class.title=选择运行时加载的模块的主类
css.files.to.compile.dialog.title=要编译的 CSS 文件
different.debug.settings=无法同时为  {0, choice, 1#Android |2#iOS} 创建可调试软件包，也无法同时为  {0, choice, 1#Android |2#iOS} 创建不可调试软件包
compilation.is.switched.off=编译已关闭且输出 SWF 不存在
main.class.is.not.a.subclass.of=主类 ''{0}'' 不是 {1} 的 public 子类。
change.bc.type.title=更改构建配置类型
bc.dialog.up.down.tooltip=使用上下键更改目标平台，按住 Shift 键更改输出类型
check.flash.app.compiled.before.launch.notification.group=启动前未编译 Flash 应用
0.module.1=''{0}'' (模块 ''{1}'')
open.project.structure=项目结构…
autodetected.source.root.type=ActionScript/Flex
create.bc.action.text=Flash 构建配置
create.bc.action.description=新建 Flash 构建配置
library.editor.title.plural=库
library.editor.title.singular=库
make.before.launch.warning.disabled=已禁用有关跳过编译的警告。\n\
要再次启用，请使用“事件日志”工具窗口中的“设置”按钮。
sdk.version.unknown=无法读取 SDK ''{0}'' 的版本。确保 [SDK 主页]/flex-sdk-description.xml (或 [SDK 主页]/air-sdk-description.xml)文件未损坏，然后尝试重新创建 SDK
air.sdk.requires.pure.as=构建配置应标记为“纯 ActionScript”，因为 AIR SDK ''{0}'' 不包含 Flex 组件
html.wrapper.folder.clash=包含 HTML 包装器模板的文件夹与 {0} 冲突: {1}
html.wrapper.folder.clash.for.dialog=路径与 {0} 冲突: {1}
take.wrapper.template.from.sdk=从以下 Flex/AIR SDK 中获取 HTML 包装器模板(&T):
choose.library.files.description=<html>选择 *.swc 或 *.ane 文件和/或包含 *.swc、*.ane 或原始 ActionScript 文件的文件夹。<br>{0} 将分析所选文件夹的内容，并自动将其中包含的文件分配至适当的类别(类、源代码和文档)。</html>
add.shared.library.dependency.action.text=项目或全局库…
add.dependency.popup.title=添加依赖关系:
add.dependency.action.name=添加依赖项
add.library.components.action.name=添加库组件(&L)…
uml.calculating.dependencies.message=正在计算依赖项
uml.dependencies.one.to.one=一对一
uml.dependencies.one.to.many=一对多
uml.dependencies.usages=用法
uml.dependencies.self=自我链接
uml.dependencies.create=创建
own.lib.used.as.3rd.party=依赖于检测到的文件 {0}，即构建配置 ''{1}'' (模块 ''{2}'')的输出。更为典型的情况是，一个构建配置依赖于另一个构建配置，而不是依赖于其输出。
instead.setup.dependency.on.bc=替换为对构建配置 ''{0}'' (模块 ''{1}'')的依赖
uml.create.relationship.label=<html>&laquo;创建&raquo;</html>
ios.simulator.on.mac.only.warning=iOS 模拟器仅在 Mac OS 上可用
ios.simulator.on.mac.only.button.text=iOS 模拟器(仅限 Mac)
ios.simulator.sdk.not.set=未设置 iOS 模拟器 SDK 的路径
ios.simulator.sdk.not.found=找不到 iOS 模拟器 SDK: {0}
cant.execute.flexunit1.for.pure.as.bc=无法为纯 ActionScript 构建配置执行 FlexUnit 1 测试。请使用 FlexUnit 4 或更高版本。
locales.dialog.label=Flex SDK ''{0}'' 支持的区域设置:
new.flex.component.command.name=创建 MXML 组件
create.flex.component.intention.name=创建 MXML 组件 ''{0}''
new.flex.component.action.description=新建 MXML 组件
new.flex.component.dialog.title=新 MXML 组件
new.flex.component.uml.action.text=MXML 组件
parent.component.label.text=父组件(&C):
parallel.compilation.hint.title=提示
parallel.compilation.hint=独立 Flash 构建配置的并行编译<br/>可以提高编译性能。<br/><br/><a href="enable">启用并行编译</a>    <a href="open">打开编译器设置 </a>
parallel.compilation.enabled=已启用并行编译
see.settings.compiler=要配置编译器设置，请使用<a href="">设置->编译器</a>页面。
define.0=声明条件编译器定义 ''{0}''
failed.to.read.app.id=无法从以下文件读取应用程序 ID: \n\
{0}
add.as.library.title=添加为库
bc.output.file.source.item={0}: 仅输出文件({1})
bc.output.file.and.wrapper.source.item={0}: 输出文件和 HTML 包装器
bc.output.folder.source.item={0}: 整个输出文件夹内容

# Annotator
javascript.validation.message.no.return.value.required.for.constructor=从构造函数中返回不需要返回值
configurable.FlexCompilerProjectConfigurable.display.name=ActionScript 和 Flex 编译器
remove.annotation.from.class=从类中移除注解
this.will.remove.relationship.link.between.classes=这将移除类之间的关系
flash.builder.project.file=<b>Flash Builder</b> 项目文件({0})

# used in FlashUmlVisibilityManager
javascript.uml.visibility.public=public
javascript.uml.visibility.protected=protected
javascript.uml.visibility.package_local=protected \\&\\& internal
javascript.uml.visibility.private=所有
javascript.uml.show.supers.header={0} 的超类
javascript.uml.show.implementations.header={0} 的实现

javascript.validation.message.static.method.in.interface=接口中不允许使用 static 方法
javascript.validation.message.static.method.with.override=static 函数不能包含重写修饰符
invalid.identifier.value=标识符值无效
class.0.does.not.have.default.constructor=类 {0} 没有默认构造函数
javascript.validation.empty.component.type=组件标记不应为空
javascript.validation.tag.must.be.last.child.of.root.tag=<{0}> 标记必须是根文档标记的最后一个子级
javascript.validation.tag.must.be.first.child.of.root.tag=<{0}> 标记必须是根文档标记的第一个子级
javascript.validation.tag.must.be.direct.child.of.fx.library.tag=<{0}> 标记必须是 <{1}> 标记的直接子级
javascript.validation.tag.must.have.exactly.one.child.tag=<{0}> 标记必须只有一个子标记
javascript.validation.tag.must.have.attribute.includein.or.excludefrom=<{0}> 标记必须有特性 ''includeIn'' 或 ''excludeFrom''
javascript.validation.only.this.tag.is.allowed.here=此处仅允许使用 <{0}> 标记
asdoc=ASDoc
invalid.package=无效软件包: {0}
actionscript.template.context.type=ActionScript(&I)
to.indent.package.statement.children=缩进 package 语句子级(&I)
javascript.validation.message.file.should.be.under.source.root=对象位于源根目录外的文件中，某些功能不可用
javascript.validation.message.more.than.one.named.object.in.package=软件包中的非唯一对象
javascript.validation.message.constructor.in.mxml.is.not.allowed=MXML 类不允许使用构造函数
javascript.validation.message.nested.packages.are.not.allowed=不允许嵌套软件包
javascript.validation.message.package.shouldbe.first.statement=软件包应为文件中的第一条语句
javascript.validation.message.incorrect.package.name=软件包名称 ''{0}'' 与文件路径 ''{1}'' 不对应
javascript.fix.package.name=将软件包名称设置为 ''{0}''
javascript.validation.message.more.than.one.externally.visible.symbol=文件中定义了多个外部可见符号
javascript.validation.message.vector.without.parameters=无类型的矢量
javascript.validation.message.vector.without.parameters2=无类型的矢量无法实例化
javascript.validation.message.access.modifier.allowed.only.for.package.members=软件包成员仅允许使用 public/internal 修饰符
javascript.validation.message.access.modifier.allowed.only.for.class.members=仅类成员允许使用访问修饰符
javascript.validation.message.namespace.allowed.only.for.class.members=仅类成员允许使用命名空间
javascript.validation.message.embed.annotation.used.with.var.of.wrong.type=嵌入注解应与类或字符串类型的变量一起使用
javascript.namespace.initializer.should.be.string.or.another.namespace.reference=命名空间初始值设定项应为字符串文字或其他命名空间引用
javascript.validation.message.class.should.be.in.file=应在文件 ''{1}'' 中定义类 ''{0}''
javascript.validation.message.function.should.be.in.file=应在文件 ''{1}'' 中定义函数 ''{0}''
javascript.validation.message.namespace.should.be.in.file=应在文件 ''{1}'' 中定义命名空间 ''{0}''
javascript.validation.message.variable.should.be.in.file=应在文件 ''{1}'' 中定义变量 ''{0}''
javascript.invalid.e4x.filter.query.receiver=e4x 筛选器查询实参无效，应为 XML 或 XMLList 类型
javascript.callback.signature.mismatch=回调应只有一个事件类型的参数
javascript.callback.signature.mismatch.event.class=回调应只有一个{0}类型的参数
actionscript.binary.operand.type.mismatch=二元运算实参类型{0}与类型{1}不兼容
top.level=顶层
js.uml.presentable.name=ActionScript/Flex
actionscript.create.constructor.intention.name=创建构造函数 ''{0}''
new.actionscript.class.uml.action.text=ActionScript 类
new.actionscript.class.command.name=创建 ActionScript 类
new.actionscript.class.action.description=创建新的 ActionScript 类
cannot.resolve.package.0=无法解析软件包 ''{0}''
cannot.resolve.class.0=无法解析类 ''{0}''
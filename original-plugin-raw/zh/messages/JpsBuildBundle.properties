build.message.0.was.used.to.compile.1={0} 用于编译 [{1}]
build.message.0.was.used.to.compile.1.modules={0} 用于编译 {1} 模块
build.message.0.was.used.to.compile.java.sources={0} 用于编译 java 源
build.message.annotation.processing.is.not.supported.for.module.cycles=模块循环不支持注解处理。请确保将循环 [{0}] 中的所有模块排除在注解处理之外
build.message.archive.0.doesn.t.contain.files.so.it.won.t.be.created=归档 ''{0}'' 不包含文件，所以不会被创建
build.message.builder.0.requested.build.stop=构建器 {0} 请求构建停止
build.message.cannot.build.0.artifact.it.includes.itself=无法构建 ''{0}'' 工件\: {2, choice, 0\#其|1\#“{1}”工件}将自身包含在输出布局中
build.message.cannot.build.0.artifact.output.path.is.not.specified=无法构建 ''{0}'' 工件\: 未指定输出路径
build.message.cannot.build.0.because.it.is.included.into.a.circular.dependency.1=无法构建 {0}，因为它处在一个循环依赖关系中({1})
build.message.cannot.build.circular.dependency.found.between.0.and.1=无法构建\: 在 ''{0}'' 和 ''{1}'' 之间发现循环依赖关系
build.message.cannot.compile.a.module.cycle.with.multiple.module.info.files=无法编译带有多个 module-info.java 文件的模块循环\: {0}
build.message.cannot.compile.associated.jdk.not.supported=无法编译为 JVM 目标 {1} 配置的模块 ''{0}''\: IDE 不支持当前与该模块关联的 JDK {2}。
build.message.cannot.compile.associated.jdk.unsupported.jvm.target=无法编译为 JVM 目标 {1} 配置的模块 ''{0}''\: 当前与该模块关联的 JDK {2} 不支持所需的 jvm 目标 {1}。
build.message.cannot.compile.fallback.jdk.not.supported=无法编译为 JVM 目标 {1} 配置的模块 ''{0}''\: IDE 不支持指定的回退 SDK 版本 {2}。
build.message.cannot.compile.fallback.jdk.unsupported.jvm.target=无法编译为 JVM 目标 {1} 配置的模块 ''{0}''\: 指定的回退 SDK 版本 {2} 不支持所需的 jvm 目标 {1}。
build.message.cannot.create.0.1=无法创建 ''{0}''\: {1}
build.message.cannot.create.manifest.mf.from.0.1=无法从 {0} 创建 MANIFEST.MF\: {1}
build.message.cannot.delete.file.0=无法删除文件 ''{0}''
build.message.cannot.extract.0.from.1.while.building.2.artifact.3=构建 ''{2}'' 工件时，无法从 ''{1}'' 中提取 ''{0}''\: {3}
build.message.cannot.find.jdk.0.for.module.1=找不到模块 ''{1}'' 的 JDK ''{0}''
build.message.cannot.find.jdk.for.module.0.1.points.to.2=找不到模块 ''{0}'' 的 JDK\: ''{1}'' 指向 {2}
build.message.cannot.instrument.0.1=无法插桩 {0}\: {1}
build.message.cannot.start.javac.process.for.0.unknown.jdk.home=无法启动 {0} 的 javac 进程\: 未知 JDK 主路径或版本。\n请检查项目配置。
build.message.class.dependency.information.may.be.incomplete=类依赖项信息可能不完整。解析生成类 {0} 时出错
build.message.compilation.failed.errors.0.warnings.1=编译失败\: 错误\: {0}；警告\: {1}
build.message.compilation.failed.internal.java.compiler.error=编译失败\: 内部 java 编译器错误
build.message.conflicting.outputs.error=输出文件“{0}”已由“{1}”注册
build.message.consider.building.whole.project.or.rebuilding.the.module=考虑构建整个项目或重新构建模块。
build.message.deletion.of.outdated.files.stopped=由于太多文件无法删除，已停止删除过时文件
build.message.dependency.data.format.has.changed.project.rebuild.required=依赖数据格式已改变，需要重新构建项目
build.message.error.bind.repository.id.not.found=找不到 ID 为 ''{0}'' 的绑定仓库
build.message.error.bind.repository.missing=库 ''{0}''\: 没有绑定仓库
build.message.error.cleaning.compiler.storages=清理编译器存储时出错
build.message.error.cleaning.library.roots.storage=清理库根存储时出错
build.message.error.cleaning.timestamps.storage=清理时间戳存储时出错
build.message.error.compile.roots.verification.mismatch=库 ''{0}''\: 验证元数据与编译的根不匹配
build.message.error.invalid.sha256.checksum=库 ''{0}''\: {1} 的 SHA256 校验和无效，应为 {2}，但实际为 {3}
build.message.error.missing.artifacts=库 ''{0}''\: 找不到预期的工件 {1}
build.message.error.resolving.dependencies.for=解析 {0} 的依赖项时出错
build.message.errors.occurred.while.compiling.module.0=编译模块 ''{0}'' 时发生错误
build.message.failed.to.delete.output.files.from.obsolete.0.target.1=无法从过时 ''{0}'' 目标删除输出文件\: {1}
build.message.failed.to.load.project.configuration.0=加载项目配置失败\: {0}
build.message.fallback.javac.used=已为 JVM 目标 {1} 配置模块 ''{0}''。正在使用已配置的回退 SDK 中的 Java 编译器 {2} 编译该模块。
build.message.fallback.jdk.hint=请在“项目结构 | 平台设置 | SDK”中添加 JDK {0} 或更高版本。添加的 JDK 应支持针对 JVM 目标 {1} 的交叉编译。IDE 将自动选择此 JDK 来为旧版 JVM 目标进行编译。
build.message.incremental.annotation.processing.disabled.0=JPS 增量注解进程已禁用。部分重新编译的编译结果可能不准确。使用构建进程“{0}”VM 标志启用/禁用增量注解处理环境。
build.message.insufficient.memory=OutOfMemoryError\: 内存不足
build.message.internal.caches.are.corrupted=内部缓存损坏或格式过期，需要强制重新构建项目\: {0}
build.message.internal.error.0=内部错误\: \n{0}
build.message.internal.error.0.1=内部错误 ({0})\: {1}
build.message.jdk.isn.t.specified.for.module.0=没有为模块 ''{0}'' 指定 JDK
build.message.manifest.file.0.included.into.archive.does.not.contain.required.attribute=纳入归档 ''{1}'' 中的清单文件 ''{0}'' 不包含 ''{2}'' 特性。此类清单文件无效，并且其内容未纳入 JAR 文件。
build.message.missing.content.for.file.0=文件 {0} 缺少内容
build.message.modules.0.and.1.must.have.the.same.additional.command.line.parameters=模块 {0} 和 {1} 必须指定相同的“附加命令行形参”，因为它们之间存在循环依赖关系
build.message.modules.0.and.1.must.have.the.same.language.level=模块 {0} 和 {1} 必须具有相同的语言级别，因为它们之间存在循环依赖关系
build.message.multiple.encodings.set.for.module.chunk=模块的块 {0} 的多编码设置{2, choice, 0\#“{1}”将被编译器使用|1\#}
build.message.output.path.0.intersects.with.a.source.root=输出路径 {0} 与源根相交。只有通过构建创建的文件会被清理。
build.message.perform.full.project.rebuild=请执行完整的项目重新构建(构建 | 重新构建项目)
build.message.problems.clearing.output.files.for.target.0.1=清理目标“{0}”的输出文件时出现问题\: {1}
build.message.project.rebuild.forced.0=已强制项目重新构建\: {0}
build.message.rmi.stub.generation.failed=RMI 存根生成失败
build.message.some.modules.with.cyclic.dependencies.0.have.additional.command.line.parameters=某些具有循环依赖关系 [{0}] 的模块在项目设置中已重写“附加命令行形参”。\n这些编译选项已应用于循环中的所有模块。
build.message.the.build.has.been.canceled=构建已取消
build.message.too.many.modules.require.recompilation.forcing.full.project.rebuild=过多模块需要重新编译，强制整个项目重新构建
build.message.unknown.host.0=未知主机\: {0}
build.message.unsupported.compact.compilation.profile.was.requested=已请求紧凑的编译配置文件，但是模块“{0}”的目标平台与 javac 的平台({1})不同\n此类配置不支持编译配置文件
build.message.unsupported.javac.version=无法启动 {0} 的 javac 进程\: 它被配置为使用 JDK {1}，但 IDE 仅支持使用 JDK {2} 和更高版本进行编译。\n请考虑将该模块与受支持的 JDK 版本相关联。\n请注意，可以保持当前的 Java 语言级别，使生成的 *.class 文件与 Java {3} 兼容，即使它们使用较新的编译器版本编译。
build.message.unsupported.message.type.0=不支持的消息类型\: {0}
build.message.user.specified.option.0.for.1.may.conflict.with.calculated.option=“{1}”的用户指定选项“{0}”可能会与根据项目设置自动计算的相应选项发生冲突。
build.message.user.specified.option.0.is.ignored.for.1=已对“{1}”忽略用户指定选项“{0}”。该编译形参根据项目设置自动设置。
build.messages.modules.were.fully.rebuilt={1, choice, 1\#模块 {0} 已经|2\#模块 {0} 已经|7\#模块 {0} 和其他 {2} 个已经}完全重新构建，因为项目配置{3, choice, 0\#|1\#/依赖项}发生更改
builder.0.requested.rebuild.of.module.chunk.1=构建器“{0}”请求重新构建模块的块“{1}”
builder.name.artifacts.builder=工件构建器
builder.name.backward.references.indexer=后向引用索引器
builder.name.maven.dependency.resolver=Maven 依赖项解析器
builder.name.notnull.instrumentation=NotNull 插桩
builder.name.project.dependencies.resolver=项目依赖项解析器
builder.name.resource.compiler=资源编译器
builder.name.root=构建
error.file.download.failed=无法下载 ''{0}''\:\n{1}
intellilang.pattern.validator.presentable.name=IntelliLang 模式验证器
intellilang.pattern.validator.progress.message=正在添加模式断言…
packaging.jlink.build.task.failure=jlink 任务失败
packaging.jlink.build.task.modules.not.found=找不到 JPMS 模块
packaging.jlink.build.task.run.time.image.deletion.failure=无法删除现有的运行时镜像
packaging.jlink.build.task.unknown.artifact.path=未知工件输出路径
packaging.jlink.build.task.wrong.java.version=使用 jlink 构建运行时镜像要求 Java 9 或更高版本
progress.details.applying.changes.for.module=正在为 {0} 模块应用更改
progress.details.applying.downloaded.caches=正在应用已下载的缓存
progress.details.extracting.compilation.outputs.for.module=正在提取 {0} 模块的编译输出
progress.details.extracting.project.caches=正在提取项目缓存
progress.download.file.text=正在从 ''{1}'' 下载 ''{0}''…
progress.downloading.0.files.text=正在下载 {0} 个{0, choice, 1\#文件|2\#文件}…
progress.message.adding.notnull.assertions=正在添加为 null 性断言…
progress.message.building.archives=正在构建归档…
progress.message.building.artifact.0=正在构建工件 ''{0}''…
progress.message.building.artifact.0.copying.files=正在构建工件 ''{0}''\: 正在复制文件…
progress.message.building.jar.0=正在构建 {0}…
progress.message.checking.dependencies.0=正在检查依赖项… [{0}]
progress.message.checking.sources=正在检查源
progress.message.cleaning.old.output.directories=正在清理旧输出目录…
progress.message.cleaning.output.directories=正在清理输出目录…
progress.message.copying.archives=正在复制归档…
progress.message.copying.resources.0=正在复制资源… [{0}]
progress.message.deleting.outdated.files=正在删除过时的文件…
progress.message.dependency.analysis.found.0.affected.files=依赖分析发现 {0} 个受影响的文件
progress.message.finished.saving.caches=已完成，正在保存缓存…
progress.message.generating.rmi.stubs=正在生成 RMI 存根…
progress.message.marking.0.and.direct.dependants.for.recompilation=正在标记 {0} 和直接依赖项以重新编译
progress.message.parsing.java.0=正在解析 java… [{0}]
progress.message.processing.library=库 ''{0}''\: 已解析 {1} 个类文件
progress.message.removing.invalid.artifact=库 ''{0}''\: 正在移除无效(可能已损坏)的工件 {1}
progress.message.resolving.0.library=正在解析 ''{0}'' 库…
progress.message.resolving.repository.libraries.in.the.project=正在解析项目中的仓库库…
progress.message.running.0.tasks.for.1.artifact=正在为 ''{1}'' 工件运行{0, choice, 0\#预处理|1\#完成|2\#后处理}任务…
progress.message.running.after.tasks=正在运行 'after' 任务
progress.message.running.before.tasks=正在运行 'before' 任务
progress.message.updating.dependency.information.0=正在更新依赖项信息… [{0}]
progress.message.updating.library.state=库依赖项\: 找到 {2} 的 {0} 个已更新的库根 {1} 个已移除的库根
progress.message.writing.classes.0=正在编写类… {0}
progress.text.applying.jps.caches=正在应用 JPS 缓存…
progress.text.calculating.affected.modules=正在计算受影响的模块
progress.text.extracting.downloaded.results=正在提取已下载的结果…
progress.text.fetching.cache.for.commit=正在提取提交的缓存\: {0}
progress.text.local.build.is.quicker=在本地构建项目比下载缓存更快
progress.text.removing.old.caches=正在移除下载前的旧缓存
progress.text.rolling.back=正在回滚
progress.text.rolling.back.downloaded.caches=正在回滚已下载的缓存
target.description.0.and.1.more={0} 和其他 {1} 个
target.description.tests.of.0={0} 的测试

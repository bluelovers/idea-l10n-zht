jvm.inspections.group.name=JVM 语言

jvm.inspections.unstable.api.usage.display.name=不稳定的 API 用法
jvm.inspections.unstable.api.usage.annotations.list=不稳定的 API 注解:
jvm.inspections.unstable.api.usage.ignore.inside.imports=在导入内忽略
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=忽略此项目中声明的 API
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}'' 使用 @{1} 标记为不稳定
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}'' 在标记为 @{3} 的不稳定{1} ''{2}'' 中声明
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=重写方法 ''{0}'' 使用 @{1} 标记为不稳定
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=重写方法 ''{0}'' 在标记为 @{3} 的不稳定{1} ''{2}'' 中声明
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}'' 不稳定，因为其签名引用了标记为 @{3} 的不稳定{1} ''{2}''

jvm.inspections.scheduled.for.removal.future.version=未来版本
jvm.inspections.scheduled.for.removal.predefined.version=版本 {0}
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}'' 已计划从 {1} 中移除
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}'' 在已计划从 {3} 中移除的{1} ''{2}'' 中声明
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=重写方法 ''{0}'' 已计划从 {1} 中移除
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=重写方法 ''{0}'' 在已计划从 {3} 中移除的{1} ''{2}'' 中声明
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}'' 已计划移除，因为其签名引用了已计划从 {3} 中移除的{1} ''{2}''

jvm.inspections.unstable.type.used.in.signature.display.name=签名中使用了不稳定的类型
jvm.inspections.unstable.type.used.in.class.signature.description=类必须使用 ''@{0}'' 注解标记，因为其声明引用了不稳定的类型 ''{1}''
jvm.inspections.unstable.type.used.in.method.signature.description=方法必须使用 ''@{0}'' 注解标记，因为其签名引用了不稳定的类型 ''{1}''
jvm.inspections.unstable.type.used.in.field.signature.description=字段必须使用 ''@{0}'' 注解标记，因为其类型引用了不稳定的类型 ''{1}''

jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=已计划移除的 API 上缺少 '@Deprecated' 注解
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=已计划移除的 API 也必须使用 '@Deprecated' 注解标记
jvm.inspections.must.already.be.removed.api.display.name=API 必须已移除
jvm.inspections.must.already.be.removed.api.earlier.version.description=API 必须已在版本 {0} 中移除，但当前版本为 {1}
jvm.inspections.must.already.be.removed.api.current.version.description=API 必须在当前版本 {0} 中移除
jvm.inspections.blocking.method.problem.descriptor=在非阻塞上下文中使用阻塞调用可能会导致线程匮乏
jvm.inspections.blocking.method.display.name=可能在非阻塞上下文中使用阻塞调用
jvm.inspections.blocking.method.annotation.blocking=阻塞注解
jvm.inspections.blocking.method.annotation.non-blocking=非阻塞注解
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=添加阻塞注解
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=添加非阻塞注解
jvm.inspections.blocking.method.annotation.configure.empty.text=未添加注解。

jvm.inspections.api.no.extension.display.name=不应扩展类、接口或方法
jvm.inspections.api.no.extension.class.description=不得扩展类 ''{0}''
jvm.inspections.api.no.extension.interface.implement.description=不得实现接口 ''{0}''
jvm.inspections.api.no.extension.interface.extend.description=不得扩展接口 ''{0}''
jvm.inspections.api.no.extension.method.overriding.description=不得重写方法 ''{0}''
jvm.inspections.api.override.only.display.name=方法只能重写
jvm.inspections.api.override.only.description=方法 ''{0}'' 只能重写

jvm.inspections.dependency.display.name=非法的软件包依赖项
jvm.inspections.dependency.edit.rules.text=编辑依赖关系规则 "{0} "
jvm.inspections.dependency.edit.rules.family=编辑依赖关系规则
jvm.inspections.dependency.configure.button.text=配置依赖关系规则
jvm.inspections.dependency.violator.problem.descriptor=违反依赖关系规则 ''{0}.''


jvm.inspections.testonly.display.name=生产代码中的纯测试用法
jvm.inspections.testonly.class.reference=在生产代码中引用纯测试类
jvm.inspections.testonly.field.reference=在生产代码中引用纯测试字段
jvm.inspections.testonly.method.call=在生产代码中调用纯测试方法
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting 对 @TestOnly 代码意义不大

jvm.inspections.string.touppercase.tolowercase.without.locale.description=在未使用国际化字符串指定区域设置的情况下调用 <code>String.{0}()</code> #loc
can.t.build.uast.tree.for.file=无法为文件构建 UAST 树
title.uast=UAST
current.version=当前版本:
dialog.title.choose.annotation=选择 {0}
jvm.inspections.junit.malformed.annotated.suspend.function.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 不应为挂起函数
jvm.inspections.junit.malformed.suspend.function.descriptor=方法 <code>#ref</code> 不应为挂起函数
jvm.inspections.junit.malformed.nested.class.descriptor=使用 ''@Nested'' 注解的类 <code>#ref</code> 应为 {0, choice, 1#{1}|2#{1} 和 {2}}
jvm.inspection.test.failed.line.display.name=测试中失败的行
jvm.inspections.source.to.sink.flow.display.name=不安全字符串被传递至安全方法
jvm.inspections.junit5.converter.display.name=JUnit 4 测试可以为 JUnit 5
jvm.inspections.junit5.converter.problem.descriptor=#ref 可以为 JUnit 5 测试
jvm.inspections.junit5.converter.quickfix=迁移到 JUnit 5
jvm.inspections.junit5.converter.quickfix.presentation.text=转换断言
jvm.inspections.junit5.converter.quickfix.conflict.inheritor=由于存在不兼容的继承者，类 {0} 无法转换为 JUnit 5: {1}
jvm.inspections.thread.run.display.name=调用 'Thread.run()'
jvm.inspections.serializable.class.without.serialversionuid.display.name=不带 'serialVersionUID' 的可序列化类
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>#ref</code> 未定义 'serialVersionUID' 字段 #loc
jvm.inspections.source.to.sink.flow.passed.unsafe=不安全字符串用作安全形参
jvm.inspections.source.to.sink.flow.passed.unknown=未知字符串用作安全形参
jvm.inspections.source.to.sink.flow.returned.unsafe=不安全字符串返回自安全方法
jvm.inspections.source.to.sink.flow.returned.unknown=未知字符串返回自安全方法
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=标记为需要验证
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=将 ''{0}'' 标记为需要验证
jvm.inspections.blocking.method.consider.unknown.context.blocking=考虑未知上下文阻塞
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.family=传播安全注解
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.text=从 ''{0}'' 传播安全注解
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.title=选择要注解为安全的成员
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.annotate=注解除排除外的所有对象
propagated.from=标记为安全的原因:
propagated.to=要标记为安全的目标:
propagate.from.empty.text=此处将显示标记为安全的原因
propagate.to.empty.text=此处将显示要标记为安全的目标
jvm.inspections.blocking.method.problem.wildcard.descriptor=在{0}中使用阻塞调用可能会导致线程匮乏
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.unsafe.flow=不安全的流
jvm.inspections.source.to.sink.flow.assigned.unsafe=不安全的字符串分配给安全变量
jvm.inspections.source.to.sink.flow.assigned.unknown=未知字符串分配给安全变量
jvm.inspections.source.to.sink.flow.common.unsafe=不安全字符串在安全上下文中使用
jvm.inspections.source.to.sink.flow.common.unknown=未知字符串在安全上下文中使用
jvm.inspections.api.display.name=使用在配置的语言级别下不可用的 API
jvm.inspections.1.5.problem.descriptor=使用记录为 @since {0}+ 的 API
jvm.inspections.1.7.problem.descriptor=使用自 1.6 以来通用的 API，这可能会导致 JDK {0} 出现编译问题。
jvm.inspections.1.8.problem.descriptor=默认{0, choice, 0#|1#方法|2#方法}不会被重写。它会导致 JDK {1} 出现编译问题
jvm.inspections.1.8.problem.single.descriptor=默认方法 ''{0}'' 不会被重写。它会导致 JDK {1} 出现编译问题
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.command.name=标记为需要验证
jvm.inspections.source.unsafe.to.sink.flow.preview.multiple.files=将 ''@Untainted'' 注解添加到 {0}
jvm.inspections.dependency.on.internal.display.name=对内部软件包的非法依赖
inspection.message.illegal.dependency.module.doesn.t.export=非法依赖: 模块 ''{0}'' 不导出软件包 ''{1}''
jvm.inspections.test.frameworks.group.name=测试框架
assertequals.between.inconvertible.types.display.name='assertEquals()' 位于不可转换类型的对象之间
jvm.inspections.assertequals.between.inconvertible.types.problem.descriptor=<code>#ref()</code> 位于 ''{0}'' 和 ''{1}'' 不可转换类型的对象之间 #loc
jvm.inspections.assertnotsame.between.inconvertible.types.problem.descriptor=冗余断言: 比较不兼容的类型 ''{0}'' 和 ''{1}''
jvm.inspections.assertnotequals.between.inconvertible.types.problem.descriptor=可能的冗余断言: 比较不兼容的类型 ''{0}'' 和 ''{1}''
jvm.inspections.junit.malformed.declaration.name=JUnit 格式错误的声明
jvm.inspections.junit.malformed.option.ignore.test.parameter.if.annotated.by=由以下对象注解时忽略测试形参:
jvm.inspections.junit.malformed.test.combination.descriptor=可疑的 {0} 与 ''@{1}'' 组合
jvm.inspections.junit.malformed.repetition.number.descriptor=重复次数必须大于零
jvm.inspections.junit.malformed.extension.class.level.descriptor=应在类级别注册{0}
jvm.inspections.junit.malformed.param.method.source.unresolved.descriptor=无法解析目标方法源: ''{0}''
jvm.inspections.junit.malformed.param.wrapped.in.arguments.descriptor=必须在 'Arguments' 中包装多个形参
jvm.inspections.junit.malformed.param.method.source.return.type.descriptor=方法源 ''{0}'' 必须具有以下其中一种返回值类型: ''Stream<?>''、''Iterator<?>''、''Iterable<?>'' 或 ''Object[]''
jvm.inspections.junit.malformed.param.method.source.no.params.descriptor=方法源 ''{0}'' 不应有形参
jvm.inspections.junit.malformed.param.method.source.static.descriptor=方法源 ''{0}'' 必须为 static
jvm.inspections.junit.malformed.param.method.source.assignable.descriptor=未找到将 ''{0}'' 转换为 ''{1}'' 的隐式转换
jvm.inspections.junit.malformed.param.duplicated.enum.descriptor=重复的 'enum' 常量名称
jvm.inspections.junit.malformed.param.unresolved.enum.descriptor=无法解析 'enum' 常量引用。
jvm.inspections.junit.malformed.param.no.value.source.is.defined.descriptor=未定义值源
jvm.inspections.junit.malformed.param.exactly.one.type.of.input.must.be.provided.descriptor=必须恰好提供一种类型的输入
jvm.inspections.junit.malformed.param.file.source.descriptor=无法解析文件源: ''{0}''
jvm.inspections.junit.malformed.param.no.sources.are.provided.descriptor=没有提供源，套件将为空
jvm.inspections.junit.malformed.annotated.method.param.single.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 不应声明形参 ''{1}''
jvm.inspections.junit.malformed.annotated.method.typed.param.single.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 的类型应为 ''{1}'' 且不应声明形参 ''{2}''
jvm.inspections.junit.malformed.annotated.method.single.param.single.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 应为 {1} 且不应声明形参 ''{2}''
jvm.inspections.junit.malformed.annotated.method.double.param.single.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 应为 {1}，{2}，且不应声明形参 ''{3}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.single.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 应为 {1}，类型应为 ''{2}''，且不应声明形参 ''{3}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.single.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 应为 {1}，{2}，类型应为 ''{3}''，且不应声明形参 ''{4}''
jvm.inspections.junit.malformed.annotated.method.param.double.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 不应声明形参 {1} 和 ''{2}''
jvm.inspections.junit.malformed.annotated.method.typed.param.double.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 的类型应为 ''{1}''，且不应声明形参 {2} 和 ''{3}''
jvm.inspections.junit.malformed.annotated.method.single.param.double.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 应为 {1} 且不应声明形参 ''{2}'' 和 ''{3}''
jvm.inspections.junit.malformed.annotated.method.double.param.double.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 应为 {1}，{2}，且不应声明形参 ''{3}'' 和 ''{4}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.double.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 应为 {1}，类型应为 ''{2}''，且不应声明形参 {3} 和 ''{4}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.double.descriptor=使用 ''@{0}'' 注解的方法 <code>#ref</code> 应为 {1}，{2}，类型应为 ''{3}''，且不应声明形参 {4} 和 ''{5}''
jvm.inspections.junit.malformed.fix.method.signature=修复方法签名
jvm.inspections.junit.malformed.fix.method.signature.descriptor=修复 ''{0}'' 方法签名
jvm.inspections.junit.malformed.fix.field.signature=修正字段签名
jvm.inspections.junit.malformed.fix.field.signature.descriptor=修正 ''{0}'' 字段签名
jvm.inspections.junit3.super.teardown.display.name=未从 'finally' 块调用 JUnit 3 'super.tearDown()'
jvm.inspections.junit3.super.teardown.problem.descriptor=未从 'finally' 块调用 <code>#ref()</code> #loc
jvm.inspections.junit.assertequals.on.array.display.name=在数组上调用了 'assertEquals()'
jvm.inspections.junit.assertequals.on.array.problem.descriptor=在数组上调用了 <code>#ref()</code> #loc
jvm.inspections.junit.assertequals.may.be.assertsame.display.name='assertEquals()' 可能是 'assertSame()'
jvm.inspections.junit.assertequals.may.be.assertsame.problem.descriptor=<code>#ref()</code> 可能是 'assertSame()' #loc
jvm.inspections.migrate.assertion.name=JUnit 断言可以是 'assertThat()' 调用
jvm.inspections.migrate.assert.to.matcher.option=静态导入匹配程序的方法
jvm.inspections.migrate.assert.to.matcher.description=断言表达式 <code>#ref</code> 可被替换为 ''{0}'' 调用 #loc
jvm.inspections.junit.ignored.test.display.name=使用 '@Ignore'/'@Disabled' 注解的 JUnit 测试
jvm.inspections.junit.ignored.test.ignore.reason.option=只报告没有原因的注解
jvm.inspections.junit.ignored.test.class.problem.descriptor=测试类 ''{0}'' 已被{1, choice, 1#|2#无理由}忽略/禁用 #loc
jvm.inspections.junit.ignored.test.method.problem.descriptor=测试方法 ''{0}()'' 已被{1, choice, 1#|2#无理由}忽略/禁用 #loc
jvm.inspections.test.method.without.assertion.display.name=不带断言的测试方法
jvm.inspections.test.method.without.assertion.problem.descriptor=测试方法 <code>#ref()</code> 不包含断言 #loc
jvm.inspections.test.case.with.constructor.display.name=具有非普通构造函数的 TestCase
jvm.inspections.test.case.with.constructor.problem.descriptor=构造函数 <code>#ref()</code> 中的初始化逻辑，而不是 'setup()' 生命周期方法 #loc
jvm.inspections.test.case.with.constructor.problem.descriptor.initializer=初始值设定项中的初始化逻辑，而不是 'setup()' 生命周期方法
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.preview=打开工具窗口以配置安全注解的传播
jvm.inspections.test.case.in.product.source.display.name=产品源中的测试
jvm.inspections.test.case.in.product.source.problem.descriptor=测试用例 <code>#ref</code> 可能应被放置在测试源树中 #loc
jvm.inspections.test.method.in.product.source.problem.descriptor=测试方法 <code>#ref()</code> 可能应被放置在测试源树中 #loc
jvm.inspections.junit.malformed.no.arg.descriptor=方法 <code>#ref</code> 应为 {0}, {1}{2, choice, 0# 且无形参|1#, 无形参，且类型为 void}
jvm.inspections.junit.malformed.annotated.single.descriptor=使用 ''@{1}'' 注解的{0, choice, 0#字段|1#方法} <code>#ref</code> 应为 {2}
jvm.inspections.junit.malformed.annotated.double.descriptor=使用 ''@{1}'' 注解的{0, choice, 0#字段|1#方法} <code>#ref</code> 应为 {2} 和 {3}
jvm.inspections.junit.malformed.annotated.typed.descriptor=使用 ''@{1}'' 注解的{0, choice, 0#字段|1#方法} <code>#ref</code> 类型应为 ''{2}''
jvm.inspections.junit.malformed.annotated.single.typed.descriptor=使用 ''@{1}'' 注解的{0, choice, 0#字段|1#方法} <code>#ref</code> 应为 {2} 且类型应为 ''{3}''
jvm.inspections.junit.malformed.annotated.double.typed.descriptor=使用 ''@{1}'' 注解的{0, choice, 0#字段|1#方法} <code>#ref</code> 应为 {2}, {3} 且类型应为 ''{4}''
jvm.inspections.junit.malformed.fix.class.signature=修复类签名
jvm.inspections.junit.malformed.fix.class.signature.descriptor=修复 ''{0}'' 类签名
jvm.inspections.junit.malformed.source.without.params.descriptor=''@{0}'' 无法向方法提供实参，因为方法没有形参
jvm.inspections.junit.malformed.param.empty.source.unsupported.descriptor=''@{0}'' 无法向方法提供实参，因为方法具有不受支持的 ''{1}'' 类型的形参
jvm.inspections.junit.malformed.param.multiple.parameters.descriptor=此源不支持多个形参
jvm.inspections.junit4.converter.display.name=JUnit 3 测试可以是 JUnit 4
jvm.inspections.junit4.converter.problem.descriptor=<code>#ref</code> 可以转换为 JUnit4 测试用例
jvm.inspections.junit4.converter.quickfix.name=转换为 JUnit 4 测试用例
jvm.inspections.junit4.converter.quickfix.conflict.semantics=如果 {1} 转换为 JUnit 4，方法调用 {0} 可能会更改语义
jvm.inspections.junit4.converter.quickfix.conflict.suite={0} 的 suite 方法的迁移有副作用，将被删除
jvm.inspections.junit4.converter.quickfix.conflict.name=方法 {0} 将与其 super 方法发生名称冲突
jvm.inspections.junit4.converter.quickfix.conflict.call.compile=如果 {1} 转换为 JUnit 4，方法调用 {0} 将不编译
jvm.inspections.dependency.intention.description=Opens a dialog to configure dependency rules between scopes.
jvm.inspections.blocking.method.intention.text=Enables the inspection option ''{0}''.
jvm.inspections.blocking.method.consider.unknown.context.nonblocking=Consider unknown contexts non-blocking
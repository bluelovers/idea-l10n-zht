jvm.inspections.group.name=JVM 语言

jvm.inspections.unstable.api.usage.display.name=不稳定的 API 用法
jvm.inspections.unstable.api.usage.annotations.list=不稳定的 API 注解:
jvm.inspections.unstable.api.usage.ignore.inside.imports=在导入内忽略
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=忽略此项目中声明的 API
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}'' 使用 @{1} 标记为不稳定
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}'' 在标记为 @{3} 的不稳定{1} ''{2}'' 中声明
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=重写方法 ''{0}'' 使用 @{1} 标记为不稳定
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=重写方法 ''{0}'' 在标记为 @{3} 的不稳定{1} ''{2}'' 中声明
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}'' 不稳定，因为其签名引用了标记为 @{3} 的不稳定{1} ''{2}''

jvm.inspections.scheduled.for.removal.future.version=未来版本
jvm.inspections.scheduled.for.removal.predefined.version=版本 {0}
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}'' 已计划从 {1} 中移除
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}'' 在已计划从 {3} 中移除的{1} ''{2}'' 中声明
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=重写方法 ''{0}'' 已计划从 {1} 中移除
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=重写方法 ''{0}'' 在已计划从 {3} 中移除的{1} ''{2}'' 中声明
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}'' 已计划移除，因为其签名引用了已计划从 {3} 中移除的{1} ''{2}''

jvm.inspections.unstable.type.used.in.signature.display.name=签名中使用了不稳定的类型
jvm.inspections.unstable.type.used.in.class.signature.description=类必须使用 ''@{0}'' 注解标记，因为其声明引用了不稳定的类型 ''{1}''
jvm.inspections.unstable.type.used.in.method.signature.description=方法必须使用 ''@{0}'' 注解标记，因为其签名引用了不稳定的类型 ''{1}''
jvm.inspections.unstable.type.used.in.field.signature.description=字段必须使用 ''@{0}'' 注解标记，因为其类型引用了不稳定的类型 ''{1}''

jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=已计划移除的 API 上缺少 '@Deprecated' 注解
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=已计划移除的 API 也必须使用 '@Deprecated' 注解标记
jvm.inspections.must.already.be.removed.api.display.name=API 必须已移除
jvm.inspections.must.already.be.removed.api.earlier.version.description=API 必须已在版本 {0} 中移除，但当前版本为 {1}
jvm.inspections.must.already.be.removed.api.current.version.description=API 必须在当前版本 {0} 中移除
jvm.inspections.blocking.method.problem.descriptor=不适当的阻塞方法调用
jvm.inspections.blocking.method.display.name=不适当的线程阻塞方法调用
jvm.inspections.blocking.method.annotation.blocking=阻塞注解
jvm.inspections.blocking.method.annotation.non-blocking=非阻塞注解
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=添加阻塞注解
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=添加非阻塞注解
jvm.inspections.blocking.method.annotation.configure.empty.text=未添加注解。

jvm.inspections.api.no.extension.display.name=不应扩展类、接口或方法
jvm.inspections.api.no.extension.class.description=不得扩展类 ''{0}''
jvm.inspections.api.no.extension.interface.implement.description=不得实现接口 ''{0}''
jvm.inspections.api.no.extension.interface.extend.description=不得扩展接口 ''{0}''
jvm.inspections.api.no.extension.method.overriding.description=不得重写方法 ''{0}''
jvm.inspections.api.override.only.display.name=方法只能重写
jvm.inspections.api.override.only.description=方法 ''{0}'' 只能重写

jvm.inspections.dependency.display.name=非法的软件包依赖项
jvm.inspections.dependency.edit.rules.text=编辑依赖关系规则 "{0} "
jvm.inspections.dependency.edit.rules.family=编辑依赖关系规则
jvm.inspections.dependency.configure.button.text=配置依赖关系规则
jvm.inspections.dependency.violator.problem.descriptor=违反依赖关系规则 ''{0}.''

jvm.inspections.junit.rule.display.name=@Rule/@ClassRule 字段的格式错误
jvm.inspections.junit.rule.problem.descriptor=使用 ''@{0}'' 注解的字段应当为 {1}
jvm.inspections.junit.rule.type.problem.descriptor=字段类型应当为 'org.junit.rules.TestRule' 的子类型

jvm.inspections.testonly.display.name=生产代码中的纯测试用法
jvm.inspections.testonly.class.reference=在生产代码中引用纯测试类
jvm.inspections.testonly.field.reference=在生产代码中引用纯测试字段
jvm.inspections.testonly.method.call=在生产代码中调用纯测试方法
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting 对 @TestOnly 代码意义不大

jvm.inspection.test.failed.line.display.name=测试中失败的行

jvm.inspections.string.touppercase.tolowercase.without.locale.description=在未使用国际化字符串指定区域设置的情况下调用 <code>String.{0}()</code> #loc
can.t.build.uast.tree.for.file=无法为文件构建 UAST 树
title.uast=UAST
current.version=当前版本:
dialog.title.choose.annotation=选择 {0}
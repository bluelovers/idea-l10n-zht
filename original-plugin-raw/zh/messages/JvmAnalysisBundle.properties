action.find.similar.stack.call.methods.not.found=未找到类似的类
advanced.setting.process.console.output.to.find.class.names=处理终端输出以查找并高亮显示类名
allow.suppressions.fix.family.name=允许禁止
allow.suppressions.fix.text=允许这些禁止
assertequals.between.inconvertible.types.display.name='assertEquals()' 位于不可转换类型的对象之间
can.t.build.uast.tree.for.file=无法为文件构建 UAST 树
checkbox.comments.and.javadoc.count.as.content=注释和 javadoc 计为内容
current.version=当前版本\:
dialog.title.choose.annotation=选择 {0}
group.advanced.settings.jvm=JVM 语言
ignored.suppressions=已忽略禁止\:
inspection.empty.method.delete.quickfix=删除不必要的方法
inspection.empty.method.display.name=空方法
inspection.empty.method.problem.descriptor=方法只调用它的 super
inspection.empty.method.problem.descriptor1=空方法重写空方法
inspection.empty.method.problem.descriptor2=该方法为空
inspection.empty.method.problem.descriptor3=该方法和所有它的derivables是空的
inspection.empty.method.problem.descriptor4=此方法的所有实现都为空
inspection.message.illegal.dependency.module.doesn.t.export=非法依赖\: 模块 ''{0}'' 不导出软件包 ''{1}''
inspection.suppression.annotation.display.name=检查禁止注解
inspection.suppression.annotation.problem.descriptor=注解会禁止 {0} \#loc
inspection.suppression.comment.problem.descriptor=注释会禁止 {0} \#loc
jvm.class.filter.choose.calls=类似的日志调用\:
jvm.inspection.log.guarded.display.name=日志记录调用受日志条件保护
jvm.inspection.log.guarded.fix.family.name=解包日志 guard 条件
jvm.inspection.log.guarded.problem.descriptor=日志记录调用受日志条件保护 \#loc
jvm.inspection.log.guarded.warn.if.fix.possible=仅在修正可用时发出警告
jvm.inspection.log.statement.not.guarded.all.levels.option=所有日志级别
jvm.inspection.log.statement.not.guarded.debug.level.and.lower.option=调试级别及更低
jvm.inspection.log.statement.not.guarded.display.name=日志记录调用不受日志条件保护
jvm.inspection.log.statement.not.guarded.info.level.and.lower.option=信息级别及更低
jvm.inspection.log.statement.not.guarded.log.fix.family.name=使用日志条件包围
jvm.inspection.log.statement.not.guarded.log.problem.descriptor=日志记录调用不受日志记录条件保护 \#loc
jvm.inspection.log.statement.not.guarded.trace.level.option=跟踪级别
jvm.inspection.log.statement.not.guarded.unguarded.constant.option=使用常量消息处理不受保护的日志记录调用
jvm.inspection.log.statement.not.guarded.unguarded.constant.option.comment=处理所有不受保护的日志调用，而不仅仅是那些具有非常量实参的日志调用
jvm.inspection.log.statement.not.guarded.warn.level.and.lower.option=警告级别及更低
jvm.inspection.log.statement.not.guarded.warn.on.label=警告对象\:
jvm.inspection.logging.condition.disagrees.with.log.statement.display.name=日志条件与日志记录调用不匹配
jvm.inspection.logging.condition.disagrees.with.log.statement.fix.family.name=更改日志级别
jvm.inspection.logging.condition.disagrees.with.log.statement.fix.name=更改{0, choice, 0\#条件|1\#调用}的级别
jvm.inspection.logging.condition.disagrees.with.log.statement.problem.descriptor=条件 ''{0}'' 的级别与日志记录调用 ''{1}'' 的级别不匹配
jvm.inspection.logging.placeholder.count.matches.argument.count.display.name=占位符数量与日志记录调用中的实参数量不匹配
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.descriptor=提供的实参数量({0})少于指定的占位符数({1}) \#loc
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.partial.descriptor=提供的实参数量({0})少于指定的占位符数(至少 {1}) \#loc
jvm.inspection.logging.placeholder.count.matches.argument.count.incorrect.problem.descriptor=非法格式字符串指定符 \#loc
jvm.inspection.logging.placeholder.count.matches.argument.count.more.problem.descriptor=提供的实参数量({0})多于指定的占位符数({1}) \#loc
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option=SLF4J 将 Log4j 2 用作实现
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.auto=自动检查
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.no=否
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.yes=是
jvm.inspection.logging.similar.message.display.name=不可区分的日志记录调用
jvm.inspection.logging.similar.message.problem.descriptor=类似的日志消息
jvm.inspection.logging.similar.message.problem.min.similar.length=相似序列的最小长度
jvm.inspection.logging.similar.message.problem.skip.on.error=不报告具有 `error` 日志级别的调用
jvm.inspection.logging.string.template.as.argument.all.levels.option=所有日志级别
jvm.inspection.logging.string.template.as.argument.debug.level.and.lower.option=调试级别和更低
jvm.inspection.logging.string.template.as.argument.display.name=字符串模板作为日志记录调用的实参
jvm.inspection.logging.string.template.as.argument.info.level.and.lower.option=信息级别和更低
jvm.inspection.logging.string.template.as.argument.problem.descriptor=作为 <code>\#ref()</code> 日志记录调用实参的字符串模板 \#loc
jvm.inspection.logging.string.template.as.argument.quickfix.name=替换为占位符
jvm.inspection.logging.string.template.as.argument.skip.on.only.exception=当调用仅在消息实参之后以异常作为实参时不发出警告。
jvm.inspection.logging.string.template.as.argument.skip.on.primitives=仅包含具有基元类型的表达式、其包装器或字符串时不发出警告
jvm.inspection.logging.string.template.as.argument.trace.level.option=跟踪级别
jvm.inspection.logging.string.template.as.argument.warn.level.and.lower.option=警告级别和更低
jvm.inspection.logging.string.template.as.argument.warn.on.label=警告对象\:
jvm.inspection.test.failed.line.display.name=测试中失败的行
jvm.inspections.1.5.problem.descriptor=使用记录为 @since {0}+ 的 API
jvm.inspections.1.5.problem.descriptor.preview=使用记录为 @since {0}+ 的预览 API
jvm.inspections.1.7.problem.descriptor=使用自 1.6 以来通用的 API，这可能会导致 JDK {0} 出现编译问题。
jvm.inspections.1.8.problem.descriptor=默认{0, choice, 0\#|1\#方法|2\#方法}不会被重写。它会导致 JDK {1} 出现编译问题
jvm.inspections.1.8.problem.single.descriptor=默认方法 ''{0}'' 不会被重写。它会导致 JDK {1} 出现编译问题
jvm.inspections.api.display.name=使用在配置的语言级别下不可用的 API
jvm.inspections.api.no.extension.class.description=不得扩展类 ''{0}''
jvm.inspections.api.no.extension.display.name=不应扩展类、接口或方法
jvm.inspections.api.no.extension.interface.extend.description=不得扩展接口 ''{0}''
jvm.inspections.api.no.extension.interface.implement.description=不得实现接口 ''{0}''
jvm.inspections.api.no.extension.method.overriding.description=不得重写方法 ''{0}''
jvm.inspections.api.no.extension.on.invalid.target.class.description={0} ''{1}'' 标有 ''@ApiStatus.NonExtendable''，但无法扩展
jvm.inspections.api.no.extension.on.invalid.target.method.description=方法 ''{0}'' 标有 ''@ApiStatus.NonExtendable''，但无法被重写
jvm.inspections.api.no.extension.on.redundant.target.method.description=注解 '@ApiStatus.NonExtendable' 冗余
jvm.inspections.api.override.only.description=方法 ''{0}'' 只能重写
jvm.inspections.api.override.only.display.name=方法只能重写
jvm.inspections.api.override.only.on.invalid.class.description={0} ''{1}'' 标有 ''@ApiStatus.OverrideOnly''，但无法扩展，也无法重写其方法
jvm.inspections.api.override.only.on.invalid.method.description=方法 ''{0}'' 标有 ''@ApiStatus.OverrideOnly''，但无法被重写
jvm.inspections.api.override.only.on.invalid.method.redundant.description=注解 '@ApiStatus.OverrideOnly' 冗余
jvm.inspections.assertequals.between.inconvertible.types.problem.descriptor=<code>\#ref()</code> 位于 ''{0}'' 和 ''{1}'' 不可转换类型的对象之间 \#loc
jvm.inspections.assertnotequals.between.inconvertible.types.problem.descriptor=可能的冗余断言\: 比较不兼容的类型 ''{0}'' 和 ''{1}''
jvm.inspections.assertnotsame.between.inconvertible.types.problem.descriptor=冗余断言\: 比较不兼容的类型 ''{0}'' 和 ''{1}''
jvm.inspections.blocking.method.annotation.blocking=阻塞注解\:
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=添加阻塞注解
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=添加非阻塞注解
jvm.inspections.blocking.method.annotation.non-blocking=非阻塞注解\:
jvm.inspections.blocking.method.consider.suspend.context.non.blocking=考虑 Kotlin 挂起上下文非阻塞
jvm.inspections.blocking.method.consider.unknown.context.blocking=考虑未知上下文阻塞
jvm.inspections.blocking.method.consider.unknown.context.nonblocking=考虑未知上下文非阻塞
jvm.inspections.blocking.method.display.name=可能在非阻塞上下文中使用阻塞调用
jvm.inspections.blocking.method.in.implicit.ctr.problem.descriptor=在非阻塞上下文中使用来自隐式构造函数调用的阻塞调用可能会导致线程匮乏
jvm.inspections.blocking.method.in.implicit.ctr.problem.wildcard.descriptor=在{0}中使用来自隐式构造函数调用的阻塞调用可能会导致线程匮乏
jvm.inspections.blocking.method.problem.descriptor=在非阻塞上下文中使用阻塞调用可能会导致线程匮乏
jvm.inspections.blocking.method.problem.wildcard.descriptor=在{0}中使用阻塞调用可能会导致线程匮乏
jvm.inspections.collection.contains.url.problem.descriptor=''{0}'' 可能包含 URL 对象 \#loc
jvm.inspections.dependency.display.name=非法的软件包依赖项
jvm.inspections.dependency.edit.rules.family=编辑依赖关系规则
jvm.inspections.dependency.edit.rules.text=编辑依赖关系规则“{0}”
jvm.inspections.dependency.intention.description=打开一个对话框以配置作用域之间的依赖关系规则。
jvm.inspections.dependency.on.internal.display.name=对内部软件包的非法依赖
jvm.inspections.dependency.violator.problem.descriptor=违反依赖关系规则 ''{0}.''
jvm.inspections.equals.hashcode.called.on.url.display.name=在 'URL' 对象上调用 'equals()' 或 'hashCode()'
jvm.inspections.equals.hashcode.called.on.url.problem.descriptor=在 URL 对象上调用 ''{0}''
jvm.inspections.group.name=JVM 语言
jvm.inspections.logging.frameworks.group.name=日志记录
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=已计划移除的 API 也必须使用 '@Deprecated' 注解标记
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=已计划移除的 API 上缺少 '@Deprecated' 注解
jvm.inspections.must.already.be.removed.api.current.version.description=API 必须在当前版本 {0} 中移除
jvm.inspections.must.already.be.removed.api.display.name=API 必须已移除
jvm.inspections.must.already.be.removed.api.earlier.version.description=API 必须已在版本 {0} 中移除，但当前版本为 {1}
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}'' 在已计划从 {3} 中移除的{1} ''{2}'' 中声明
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}'' 已计划从 {1} 中移除
jvm.inspections.scheduled.for.removal.future.version=未来版本
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=重写方法 ''{0}'' 在已计划从 {3} 中移除的{1} ''{2}'' 中声明
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=重写方法 ''{0}'' 已计划从 {1} 中移除
jvm.inspections.scheduled.for.removal.predefined.version=版本 {0}
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}'' 已计划移除，因为其签名引用了已计划从 {3} 中移除的{1} ''{2}''
jvm.inspections.serializable.class.without.serialversionuid.display.name=不带 'serialVersionUID' 的可序列化类
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>\#ref</code> 未定义 'serialVersionUID' 字段 \#loc
jvm.inspections.source.to.sink.flow.assigned.unknown=未知字符串分配给安全变量
jvm.inspections.source.to.sink.flow.assigned.unsafe=不安全的字符串分配给安全变量
jvm.inspections.source.to.sink.flow.common.unknown=未知字符串在安全上下文中使用
jvm.inspections.source.to.sink.flow.common.unsafe=不安全字符串在安全上下文中使用
jvm.inspections.source.to.sink.flow.display.name=不安全字符串被传递至安全方法
jvm.inspections.source.to.sink.flow.passed.unknown=未知字符串用作安全形参
jvm.inspections.source.to.sink.flow.passed.unsafe=不安全字符串用作安全形参
jvm.inspections.source.to.sink.flow.returned.unknown=未知字符串返回自安全方法
jvm.inspections.source.to.sink.flow.returned.unsafe=不安全字符串返回自安全方法
jvm.inspections.source.to.sink.flow.too.complex=太复杂，无法检查字符串在安全上下文中是否安全
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods=将 private 方法的形参视为安全
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods.comment=如果启用，则 private 方法的形参会被视为安全，否则将被视为未知
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex=报告情况是否太复杂而无法检查
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex.comment=报告由于复杂性而无法检查的对象
jvm.inspections.source.unsafe.to.sink.flow.checked.types=检查的类型\:
jvm.inspections.source.unsafe.to.sink.flow.config=未被污染的注解将被添加到元素 ''{0}'' 的检查设置中
jvm.inspections.source.unsafe.to.sink.flow.depth.inside=方法内部的分析深度\:
jvm.inspections.source.unsafe.to.sink.flow.impossible=元素 ''{0}'' 不支持未被污染的注解。该元素将被跳过
jvm.inspections.source.unsafe.to.sink.flow.index.parameter=形参索引
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.command.name=标记为需要验证
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=标记为需要验证
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=将元素标记为需要验证
jvm.inspections.source.unsafe.to.sink.flow.not.number=非数字
jvm.inspections.source.unsafe.to.sink.flow.place.class.column.title=上下文的类名
jvm.inspections.source.unsafe.to.sink.flow.place.method.column.title=上下文的方法名称正则表达式
jvm.inspections.source.unsafe.to.sink.flow.preview=添加 '@Untainted' 注解
jvm.inspections.source.unsafe.to.sink.flow.preview.propagate=显示传播树
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.family=传播树
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.preview=打开工具窗口以检查安全注解的传播
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.text=从此处显示传播树
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.annotate=注解除排除外的所有对象
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.title=不安全的成员
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.unsafe.flow=不安全的流
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.arguments=参数
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.classes=类
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.comment=这些方法会将限定符标记为 'untainted' (实参必须用逗号分隔)
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.methods=方法
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.table=清理限定符的方法\:
jvm.inspections.source.unsafe.to.sink.flow.safe.class=安全类\:
jvm.inspections.source.unsafe.to.sink.flow.safe.class.comment=这些类不能包含不安全的数据
jvm.inspections.source.unsafe.to.sink.flow.show.unknown.object=报告未知对象
jvm.inspections.source.unsafe.to.sink.flow.show.unsafe.object=报告不安全的对象
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations=被污染的注解\:
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations.comment=这些注解将在分析过程中用作 '@Tainted' 注解
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods=被污染的方法\:
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods.comment=这些方法被视为只返回不安全的对象
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters=被污染的形参\:
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters.comment=这些形参被视为具有 '@Tainted' 注解
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations=未被污染的注解\:
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations.comment=这些注解将在分析过程中用作 '@Untainted' 注解。如果此列表中的第一个注解存在于类路径中，则该注解将用于传播。
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields=未被污染的字段\:
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.comment=这些字段被视为只包含安全对象
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.name=字段名称
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods=未被污染的方法\:
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods.comment=这些方法被视为只返回安全的对象
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters=未被污染的形参\:
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters.comment=这些形参被视为具有 '@Untainted' 注解
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments=如果接收器和实参未被污染，则认为外部方法未被污染
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments.comment=如果启用，则当前类外部的外部方法在其接收器和实参安全的情况下将被视为安全。在某些情况下，它不适用，但对于无状态类可能很有用。否则，所有外部方法都会被视为不安全
jvm.inspections.string.touppercase.tolowercase.without.locale.description=在未使用国际化字符串指定区域设置的情况下调用 <code>String.{0}()</code> \#loc
jvm.inspections.system.get.property.display.name=对 'System.getProperty(str)' 的调用可以简化
jvm.inspections.system.get.property.problem.descriptor=可以简化 ''{0} 的调用 ''<code>\#ref</code>
jvm.inspections.test.case.in.product.source.display.name=产品源中的测试
jvm.inspections.test.case.in.product.source.problem.descriptor=测试用例 <code>\#ref</code> 可能应被放置在测试源树中 \#loc
jvm.inspections.test.case.with.constructor.display.name=具有非普通构造函数的 TestCase
jvm.inspections.test.case.with.constructor.problem.descriptor=构造函数 <code>\#ref()</code> 中的初始化逻辑，而不是 'setup()' 生存期方法 \#loc
jvm.inspections.test.case.with.constructor.problem.descriptor.initializer=初始值设定项中的初始化逻辑，而不是 'setup()' 生存期方法
jvm.inspections.test.case.without.test.methods.display.name=没有测试的测试类
jvm.inspections.test.case.without.test.methods.option=忽略具有带测试方法的超类的测试用例
jvm.inspections.test.case.without.test.methods.problem.descriptor=测试类 <code>\#ref</code> 没有测试 \#loc
jvm.inspections.test.frameworks.group.name=测试框架
jvm.inspections.test.method.in.product.source.problem.descriptor=测试方法 <code>\#ref()</code> 可能应被放置在测试源树中 \#loc
jvm.inspections.test.method.without.assertion.display.name=不带断言的测试方法
jvm.inspections.test.method.without.assertion.problem.descriptor=测试方法 <code>\#ref()</code> 不包含断言 \#loc
jvm.inspections.testonly.class.reference=在生产代码中引用纯测试类
jvm.inspections.testonly.display.name=生产代码中的纯测试用法
jvm.inspections.testonly.field.reference=在生产代码中引用纯测试字段
jvm.inspections.testonly.method.call=在生产代码中调用纯测试方法
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting 对 @TestOnly 代码意义不大
jvm.inspections.thread.run.display.name=调用 'Thread.run()'
jvm.inspections.unstable.api.usage.annotations.list=不稳定的 API 注解\:
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}'' 在标记为 @{3} 的不稳定{1} ''{2}'' 中声明
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}'' 使用 @{1} 标记为不稳定
jvm.inspections.unstable.api.usage.display.name=不稳定的 API 用法
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=忽略此项目中声明的 API
jvm.inspections.unstable.api.usage.ignore.inside.imports=在导入内忽略
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=重写方法 ''{0}'' 在标记为 @{3} 的不稳定{1} ''{2}'' 中声明
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=重写方法 ''{0}'' 使用 @{1} 标记为不稳定
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}'' 不稳定，因为其签名引用了标记为 @{3} 的不稳定{1} ''{2}''
jvm.inspections.unstable.type.used.in.class.signature.description=类必须使用 ''@{0}'' 注解标记，因为其声明引用了不稳定的类型 ''{1}''
jvm.inspections.unstable.type.used.in.field.signature.description=字段必须使用 ''@{0}'' 注解标记，因为其类型引用了不稳定的类型 ''{1}''
jvm.inspections.unstable.type.used.in.method.signature.description=方法必须使用 ''@{0}'' 注解标记，因为其签名引用了不稳定的类型 ''{1}''
jvm.inspections.unstable.type.used.in.signature.display.name=签名中使用了不稳定的类型
jvm.inspections.usages.of.obsolete.api.description=使用了过时的 API
jvm.inspections.usages.of.obsolete.api.display.name=ApiStatus.@Obsolete 的用法
jvm.options.general.color.descriptor.logging.string.placeholder=日志字符串//占位符
propagated.from=传播原因\:
propagated.to=要传播的目标\:
remove.suppress.comment.fix.family.name=移除 //{0}
title.uast=UAST

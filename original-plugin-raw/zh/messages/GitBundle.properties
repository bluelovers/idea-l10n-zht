abort=中止
abort.operation.cherry.pick.name=优选
abort.operation.dialog.msg=中止 {0}{1}?
abort.operation.dialog.title=中止 {0}
abort.operation.failed={0} 中止失败
abort.operation.indicator.text=git {0} --abort{1}
abort.operation.merge.name=合并
abort.operation.progress.title=正在中止 {0} 进程
abort.operation.rebase.name=变基
abort.operation.revert.name=还原
abort.operation.succeeded={0} 中止成功
action.CopyPathFromRepositoryRootProvider.text=仓库根路径
action.Git.Add.text=添加
action.Git.Branches.text=分支(_B)…
action.Git.BrowseRepoAtRevision.text=在修订版中显示仓库
action.Git.CheckoutRevision.text=签出修订
action.Git.CherryPick.Abort.text=中止优选
action.Git.Clone.text=克隆…
action.Git.Commit.Stage.text=提交…
action.Git.Compare.Selected.Heads.description=显示所选分支 head 之间的差异
action.Git.Compare.Selected.Heads.title=显示文件差异
action.Git.Compare.Selected.description=相互比较选定分支
action.Git.Compare.Selected.description.disabled=从同一仓库中选择分支
action.Git.Compare.Selected.title=比较分支
action.Git.Compare.With.Current.title=与当前分支进行比较
action.Git.CompareWithBranch.text=与分支或标签比较…
action.Git.Configure.Remotes.text=管理远程…
action.Git.CreateNewBranch.FromCommit.description=从所选提交开始创建新分支
action.Git.CreateNewBranch.FromCommit.text=新建分支…
action.Git.CreateNewBranch.text=新建分支…
action.Git.CreateNewTag.description=创建指向此提交的新标签
action.Git.CreateNewTag.text=新建标记…
action.Git.Delete.Branch.title=删除{0,choice,1\#分支|2\#分支}
action.Git.Drop.Commits.text=删除提交
action.Git.Drop.Selected.Changes.text=删除所选更改
action.Git.Fetch.description.fetch.in.progress=正在提取…
action.Git.Fetch.text=提取
action.Git.Fetch.title=提取所有远程
action.Git.Fixup.To.Commit.description=创建 fixup 提交
action.Git.Fixup.To.Commit.description.nothing.to.commit=没有要提交的内容
action.Git.Fixup.To.Commit.text=Fixup…
action.Git.InMemory.Extract.Selected.Changes.description=根据所选更改创建一个新的提交，并将其直接放置在历史记录中原始提交之后
action.Git.InMemory.Extract.Selected.Changes.text=将所选更改提取到单独的提交…
action.Git.InMemory.Reword.Commit.description=通过内存中变基更改提交消息
action.Git.InMemory.Reword.Commit.text=编辑提交消息…(内存中)
action.Git.Init.Stage.error=向 Git 添加文件失败
action.Git.Init.Vcs.Toolbar.Widget.text=创建 Git 仓库…
action.Git.Init.error=Git init 失败
action.Git.Init.text=创建 Git 仓库…
action.Git.Interactive.Rebase.description=显示交互式变基的对话框，可以在该对话中对提交执行压缩、fixup、重新排序、移除和改写
action.Git.Interactive.Rebase.text=从这里进行交互式变基…
action.Git.Loading.Branches.progress=正在加载分支…
action.Git.Log.Branches.Change.Branch.Filter.On.Selection.description=选择分支后，按此分支筛选日志
action.Git.Log.Branches.Change.Branch.Filter.On.Selection.text=更新分支筛选器
action.Git.Log.Branches.Change.Branch.Filter.description=使用所选分支更新日志中的分支筛选器
action.Git.Log.Branches.Change.Branch.Filter.text=更新日志中的分支筛选器
action.Git.Log.Branches.Navigate.Log.To.Branch.On.Selection.description=选择分支后，在日志中导航到该分支 HEAD
action.Git.Log.Branches.Navigate.Log.To.Branch.On.Selection.text=在日志中导航到分支 Head
action.Git.Log.Branches.Navigate.Log.To.Selected.Branch.text=在日志中导航到所选分支 Head
action.Git.Log.DeepCompare.description=高亮显示尚未优选到当前分支的提交
action.Git.Log.DeepCompare.text=无优选提交
action.Git.Log.Edit.Remote.text=编辑远程
action.Git.Log.Hide.Branches.text=隐藏 Git 分支
action.Git.Log.Remove.Remote.text=移除{0,choice,1\#远程|2\#远程}
action.Git.Log.Show.Branches.text=分支
action.Git.Log.Show.Command.text=显示命令的 Git 日志
action.Git.Log.text=显示 Git 仓库日志…
action.Git.Merge.Abort.text=中止合并
action.Git.Merge.text=合并…
action.Git.New.Branch.description=仅选择一个分支以继续创建新分支
action.Git.New.Branch.dialog.title=从 {0} 创建分支
action.Git.Pull.text=拉取…
action.Git.Push.Tag.text=推送标签
action.Git.Push.Tag.text.to=推送到{1,choice,0\#|1\# {2} 中的} {0}
action.Git.PushUpToCommit.description=推送所有之前的提交，包括所选提交
action.Git.PushUpToCommit.text=推送此前所有提交…
action.Git.Rebase.Abort.text=中止变基
action.Git.Rebase.Continue.text=继续变基
action.Git.Rebase.Skip.progress.title=变基期间跳过提交…
action.Git.Rebase.Skip.text=跳过提交
action.Git.Rebase.operation.name=变基
action.Git.Rebase.text=变基…
action.Git.Reset.In.Log.text=将当前分支重置到此处…
action.Git.Reset.text=重置 HEAD…
action.Git.ResolveConflicts.text=解决冲突…
action.Git.Revert.Abort.text=中止还原
action.Git.Revert.In.Log.description=生成新提交，这会还原在原始提交中所做的更改
action.Git.Revert.In.Log.template.text=还原{0,choice,1\#提交|2\#提交}
action.Git.Revert.In.Log.text=还原提交
action.Git.RevertResolved.confirmation=是否要还原已解析的{0,choice,1\#文件|2\#文件}\: {1}?
action.Git.RevertResolved.confirmation.title=还原已解析的文件
action.Git.RevertResolved.progress=正在还原已解决的冲突…
action.Git.RevertResolved.text=还原已解决
action.Git.Reword.Commit.description=通过 git rebase 或 amend 的改写选项更改提交消息
action.Git.Reword.Commit.text=编辑提交消息…
action.Git.Show.My.Branches.description.calculating.branches.progress=正在计算我的分支
action.Git.Show.My.Branches.description.is.my.branch=如果分支的所有独占提交都是由“我”(即当前 Git 作者)执行的，则此分支为“我的”。
action.Git.Show.My.Branches.description.not.all.roots.indexed=并没有为所有仓库编制索引。
action.Git.Show.My.Branches.description.not.graph.ready=该日志尚未就绪，请稍候。
action.Git.Show.My.Branches.description.not.support.indexing=某些仓库不支持索引。
action.Git.Show.My.Branches.title=显示我的分支
action.Git.Show.Stage.text=显示暂存区域
action.Git.Show.Stash.With.Shelf.description=打开“隐藏和搁置”标签页
action.Git.Show.Stash.With.Shelf.text=显示隐藏和搁置
action.Git.Show.Stash.description=打开“Git 隐藏”标签页
action.Git.Show.Stash.text=显示 Git 隐藏
action.Git.ShowBranches.pretty.description=显示分支
action.Git.ShowBranches.text=显示分支
action.Git.Squash.Commits.description=交互式变基以将所选提交合并为一个提交
action.Git.Squash.Commits.text=压缩提交…
action.Git.Squash.Into.Commit.description=提交本地更改，以便将其压缩到所选提交中
action.Git.Squash.Into.Commit.text=压缩到…
action.Git.Stage.Add.All.description=将所有未暂存的更改和未跟踪的文件添加到索引
action.Git.Stage.Add.All.text=全部暂存
action.Git.Stage.Add.Tracked.description=将跟踪文件中所有未暂存的更改添加到索引
action.Git.Stage.Add.Tracked.text=暂存全部已跟踪项
action.Git.Stage.Compare.Local.Staged.text=与暂存版本比较
action.Git.Stage.Compare.Staged.Head.text=与 HEAD 版本比较
action.Git.Stage.Compare.Staged.Local.text=与本地版本比较
action.Git.Stage.Compare.Three.Versions.text=比较 HEAD 版本、暂存版本和本地版本
action.Git.Stage.Disable.description=禁用暂存区域并切换到更改列表
action.Git.Stage.Disable.text=变更列表
action.Git.Stage.Enable.description=使用原生 Git 暂存概念进行提交
action.Git.Stage.Enable.text=暂存区域
action.Git.Stage.Show.Local.description=在编辑器中显示当前文件的本地内容
action.Git.Stage.Show.Local.text=显示本地版本
action.Git.Stage.Show.Staged.description=在编辑器中显示当前文件的暂存内容
action.Git.Stage.Show.Staged.text=显示暂存版本
action.Git.Stage.ThreeSideDiff.description=显示包含 HEAD、暂存和本地版本的差异窗口，从中可以交互式地将更改添加到暂存区域
action.Git.Stage.ThreeSideDiff.text=比较 HEAD 版本、暂存版本和本地版本
action.Git.Stage.ToggleCommitAll.description=没有暂存文件时提交所有文件
action.Git.Stage.ToggleCommitAll.text=无任何内容暂存时全部提交
action.Git.Stash.Apply.description=应用所选隐藏
action.Git.Stash.Apply.text=应用(&A)
action.Git.Stash.Clear.description=清除所有隐藏
action.Git.Stash.Clear.in.root.description=清除所选根中的所有隐藏
action.Git.Stash.Clear.in.root.text=清除 {0} 中的隐藏(&C)
action.Git.Stash.Clear.text=清除(&C)
action.Git.Stash.Drop.description=丢弃所选隐藏
action.Git.Stash.Drop.text=删除(&D)
action.Git.Stash.Pop.description=弹出所选隐藏
action.Git.Stash.Pop.text=弹出(&P)
action.Git.Stash.Refresh.description=刷新隐藏列表
action.Git.Stash.Refresh.text=刷新隐藏
action.Git.Stash.Silently.text=无提示隐藏
action.Git.Stash.Toggle.Split.Preview.text=预览差异
action.Git.Stash.UnstashAs.description=弹出或应用选定的隐藏作为新分支(带或不带索引)
action.Git.Stash.UnstashAs.text=取消隐藏(&U)…
action.Git.Stash.text=隐藏更改…
action.Git.Tag.text=新建标记…
action.Git.Toggle.Favorite.title=标记/取消标记为收藏项
action.Git.Toolbar.ShowMoreActions.description=VCS 操作
action.Git.Toolbar.ShowMoreActions.text=版本控制
action.Git.Uncommit.description=撤消最后一次提交并将其更改放入所选更改列表
action.Git.Uncommit.text=撤消提交…
action.Git.Unshallow.failure.title=无法取消浅层化仓库
action.Git.Unshallow.progress.title=正在取消浅层化仓库…
action.Git.Unshallow.text=取消浅层化仓库
action.Git.Unstash.text=取消隐藏更改…
action.Git.Update.Selected.description=从跟踪的远程提取并使用 {1} 或像 `git fetch branch\:branch` 一样的快进(如果可能)更新所选{0,choice,1\#分支|2\#分支}
action.Git.Update.Selected.description.already.running=更新已在运行
action.Git.Update.Selected.description.select.non.current=仅选择非当前分支
action.Git.Update.Selected.description.tracking.not.configured=没有为所选{0,choice,1\#分支|2\#分支}配置跟踪分支
action.Git.Update.Selected.text=更新所选
action.New.Branch.disabled.fresh.description=无法在空仓库中创建新分支。首先进行初始提交
action.New.Branch.disabled.several.commits.description=选择单个提交以创建新分支
action.NotificationAction.GitDeleteBranchOperation.text.delete.tracked.branch=删除跟踪的分支
action.NotificationAction.GitDeleteBranchOperation.text.restore=还原
action.NotificationAction.GitDeleteBranchOperation.text.view.commits=查看提交
action.NotificationAction.GitDeleteTagOperation.text.restore=还原
action.NotificationAction.GitMergeAction.text.view.commits=查看提交
action.NotificationAction.GitRewordOperation.text.undo=撤消
action.NotificationAction.GitUpdateSession.text.view.commits=查看提交
action.NotificationAction.GithubNotifications.text.configure=配置…
action.NotificationAction.text.resolve=解决…
action.description.cant.revert.merge.commit=不允许还原合并提交
action.fetch.text=提取
action.git.branches.group.by.prefix.text=按前缀分组
action.git.branches.popup.filter.by.action.single.text=在搜索结果中显示操作
action.git.branches.popup.filter.by.action.text=操作
action.git.branches.popup.filter.by.repository.text=仓库
action.git.branches.show.recent.text=显示最近的分支
action.git.branches.show.tags.text=显示标签
action.git.update.force.pushed.branch.description=对可能强制推送的当前分支执行更新。此操作可以利用现有的“更新项目”操作(例如，当存在本地合并提交时)。
action.git.update.force.pushed.branch.not.all.local.commits.chery.picked=并非所有本地提交都是从 {0} 分支中优选的
action.git.update.force.pushed.branch.progress=正在执行强制推送的分支更新…
action.git.update.force.pushed.branch.success=可能强制推送的分支更新成功
action.git.update.force.pushed.branch.text=更新强制推送的分支
action.git4idea.commands.TestGitHttpLoginDialogAction.text=测试 Git 登录对话框
action.gpg.agent.configuration.text=配置 GPG 代理
action.label.add.unstaged.range=暂存
action.label.add.unstaged.range.tooltip=向索引中添加新的更改
action.label.reset.staged.range=取消暂存
action.label.reset.staged.range.tooltip=移除索引中的更改
action.main.toolbar.git.Branches.text=VCS 微件
action.main.toolbar.git.MergeRebase.text=VCS 合并/变基微件
action.main.toolbar.git.project.not.trusted.separator.text=安全模式，版本控制不可用
action.not.possible.in.fresh.repo.checkout=签出
action.not.possible.in.fresh.repo.generic=操作
action.selected.directory.text=选定{0,choice,1\#目录|2\#目录}
action.selected.file.text=选定{0,choice,1\#文件|2\#文件}
activity.name.abort.command=Git abort {0}
activity.name.checkout=Git checkout
activity.name.cherry.pick=Git cherry-pick
activity.name.merge=Git merge
activity.name.rebase=Git rebase
activity.name.reset=Git reset
activity.name.revert=Git revert
activity.name.stash=Git stash
activity.name.undo.commit=Git undo commit
activity.name.unstash=Git unstash
add.adding=正在添加文件…
advanced.setting.git.branch.cleanup.symbol=分支名称清理符号
advanced.setting.git.branch.cleanup.symbol.description=将在 Git 分支名称中代替禁用符号的符号
advanced.setting.git.clone.recurse.submodules=递归克隆项目中的子模块
advanced.setting.git.clone.recurse.submodules.description=启用后，从 Git 调用 'git clone --recurse-submodules' 签出，即克隆主仓库与所有子模块 (如有)
advanced.setting.git.commit.do.not.run.commit.hooks=不运行 Git 提交挂钩
advanced.setting.git.commit.do.not.run.commit.hooks.description=启用后，提交始终使用 '--no-verify' 选项运行
advanced.setting.git.read.content.with=从 Git 读取时应用内容转换
advanced.setting.git.read.content.with.description=从 Git 读取文件内容时为 'git cat-file' 命令使用 '--filters' 或 '--textconv' 标志
advanced.setting.git.recent.projects.show.branch=在最近项目列表中显示分支名称
advanced.setting.git.recent.projects.show.branch.description=分支名称将显示在欢迎屏幕和主菜单中的最近项目列表中
advanced.setting.git.search.everywhere.tab.enabled=在“随处搜索”中显示 Git 标签页
advanced.setting.git.update.incoming.outgoing.info=检查传入和传出提交
advanced.setting.git.update.incoming.outgoing.info.description=在“分支”弹出窗口中更新具有传入/传出提交的分支信息
advanced.setting.git.use.push.force.with.lease=使用安全强制推送
advanced.setting.git.use.push.force.with.lease.description=从 IDE 调用强制推送时使用 '--force-with-lease'，而非仅使用 '--force'
advanced.setting.git.use.schannel.on.windows=使用 Windows 证书存储
advanced.setting.git.use.schannel.on.windows.description=强制 Git 使用 Windows 证书存储来验证 SSL 连接。适用于 Git 2.14 及更高版本。
advanced.settings.git=版本控制. Git
annotate.cannot.annotate.dir=无法注解目录
annotate.line.mismatch.exception=正在为第 {0} 行添加信息，但应当为第 {1} 行添加信息
annotate.output.lack.data=第 {0} 行的输出缺少必要的数据
annotate.repository.is.shallow=浅层仓库中的注解可能不准确
annotations.options.detect.movements.across.files=检测跨文件的移动
annotations.options.detect.movements.within.file=检测文件内的移动
annotations.options.group=选项
annotations.options.ignore.whitespaces=忽略空格
apply.changes.applied.for.commits={0} {1,choice,1\#项提交|2\#{1,number} 项提交} 来自于 {2}
apply.changes.everything.applied={0} 中的所有更改已被{1}
apply.changes.nothing.to.do=没要有{0}的内容
apply.changes.operation.canceled={0} 已取消
apply.changes.operation.failed={0} 失败
apply.changes.operation.performed.with.conflicts={0}已执行，但存在冲突
apply.changes.operation.successful={0}成功
apply.changes.operation.successful.for.commits=但是，对以下{1, choice,1\#提交|2\#提交}成功进行了{0}\:
apply.changes.resolving.conflicts.progress.title=正在解决冲突…
apply.changes.restore.notification.description=本地更改已在{0}之前保存
apply.changes.restore.notification.title=还原本地更改
apply.changes.save.and.retry.operation={0}更改并重试
apply.changes.skipped={0} {1,choice,1\#被|2\#被}跳过，因为所有更改已被{2}。
apply.changes.unresolved.conflicts.notification.abort.action.text=中止{0}
apply.changes.unresolved.conflicts.notification.resolve.action.text=解决…
apply.changes.unresolved.conflicts.text=工作树中有未解决的冲突。
apply.conflict.dialog.description.label.text=在由 {2} 执行的提交 {1} 的{0}过程中发生冲突{3}
blob.not.found=找不到 Blob\: {0} - {1}
branch.checking.out.branch.from.process=正在从 {1} 签出 {0}…
branch.checking.out.new.branch.process=正在签出新分支 {0}…
branch.checking.out.process=正在签出 {0}…
branch.creating.branch.process=正在创建分支 {0}…
branch.deleting.branch.process=正在删除 {0}…
branch.deleting.remote.branch=正在删除 {0}…
branch.deleting.tag.on.remote.process=正在删除远程分支上的标记 {0}…
branch.direction.panel.base.repo.label=base 仓库\:
branch.direction.panel.branch.label=分支\:
branch.direction.panel.head.repo.label=head 仓库\:
branch.direction.panel.save.button=保存
branch.direction.panel.select.link=选择…
branch.direction.panel.warning.not.synced=本地分支未与远程分支同步。\n''{0}'' 分支将与 ''{1}'' 同步。
branch.direction.panel.warning.push=''{0}'' 没有远程分支。\n将在 ''{1}'' 上创建新的远程分支。
branch.merging.process=正在合并 {0}…
branch.not.fully.merged.dialog.all.commits.from.branch.were.merged=已合并来自分支 {0} 的所有提交
branch.not.fully.merged.dialog.repository.label=仓库\:
branch.not.fully.merged.dialog.restore.button=还原(&R)
branch.not.fully.merged.dialog.the.branch.was.not.fully.merged.to=分支 {0} 未完全合并到 {1}。<br/>以下是未合并提交的列表。
branch.not.fully.merged.dialog.title=分支未完全合并
branch.operation.could.not.0.operation.name.1.reference=无法{0} {1}
branch.operation.in={0} ({1} 中)
branch.rebasing.onto.process=正在变基到 ''{0}''…
branch.rebasing.process=正在变基 {0}…
branch.renaming.branch.process=正在将 {0} 重命名为 {1}…
branch.ui.handler.can.not.operation.name.because.of.unmerged.files=由于存在未合并的文件而无法{0}
branch.ui.handler.delete.all=全部删除
branch.ui.handler.delete.remote.branches=删除远程 {0,choice,1\#分支|2\#分支}
branch.ui.handler.delete.remote.branches.question=删除远程 {0,choice,1\#分支|2\#分支} {1}?
branch.ui.handler.delete.tracking.local.branch.as.well=同时删除跟踪本地分支 {0}
branch.ui.handler.delete.tracking.local.branches=删除跟踪本地分支\:
branch.ui.handler.do.not.rollback=不回滚
branch.ui.handler.merge.error.notification.title=仍然存在未解决的文件。
branch.ui.handler.merge.notification.description=以下文件存在未解决的冲突。您需要先解决它们，然后再{0}。
branch.ui.handler.rollback=回滚
branch.ui.handler.unmerged.files.error.notification.text=您需要在{0}之前解决所有合并冲突。<br/>解决冲突后，请不要忘记在切换到另一个分支之前将文件提交到当前分支。
branch.ui.handler.unmerged.files.error.resolve.conflicts.action.text=解决冲突…
branch.ui.handler.you.have.to.resolve.all.conflicts.before.operation.name=您需要先解决所有合并冲突，然后才能{0}。<br/>{1}
branch.worker.could.not.create.tag=无法{1,choice,0\#|1\#|2\# 在 {2} 中}创建标记 {0}
branches.action.delete=删除(&D)
branches.action.pull.into.branch.using.merge=使用“合并”拉入 {0}
branches.action.pull.into.branch.using.merge.description=使用合并拉入 {0}
branches.action.pull.into.branch.using.merge.selected=使用“合并”拉入当前分支
branches.action.pull.into.branch.using.rebase=使用“变基”拉入 {0}
branches.action.pull.into.branch.using.rebase.description=使用变基拉入 {0}
branches.action.pull.into.branch.using.rebase.selected=使用“变基”拉入当前分支
branches.branch.0=分支 ''{0}''
branches.branches=分支
branches.checking.existing.commits.process=正在检查现有提交…
branches.checkout=签出
branches.checkout.and.rebase.error.current.with.same.name=无法覆盖当前分支 {0}
branches.checkout.and.rebase.failed=签出和变基失败
branches.checkout.and.rebase.onto.branch=签出并变基到 {0}
branches.checkout.and.rebase.onto.current=签出并变基到当前分支
branches.checkout.and.rebase.onto.current.process=正在签出 {0} 并变基到当前分支
branches.checkout.and.rebase.onto.in.one.step=签出 {0}，并在一个步骤中将其变基到 {1} (类似于 `git rebase HEAD {2}`)
branches.checkout.local=签出本地分支
branches.checkout.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。将 ''{0}'' 变基到 ''{1}''，还是签出 ''{0}''?
branches.checkout.s=签出 {0}
branches.checkout.tag.or.revision=签出标记或修订…
branches.checkout.with.reset.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。将 ''{0}'' 变基到 ''{1}''，还是删除本地提交?
branches.compare.the.current.working.tree.with=将当前工作树与 {0} 中的树进行比较
branches.compare.with.branch=与{0}比较
branches.compare.with.current=与当前分支进行比较
branches.create.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。是否要在其他仓库中创建分支?
branches.create.new.branch.dialog.title=创建新分支
branches.create.with.reset.local.has.more.commits=本地分支 ''{0}'' 具有 ''{1}'' 中不存在的提交。是否要删除本地提交?
branches.current.branch=当前分支
branches.current.branch.name=当前
branches.drop.local.commits=删除本地提交
branches.enter.reference.branch.tag.name.or.commit.hash=输入引用(分支、标记)名称或提交哈希\:
branches.fetch.finished=已提取 {0} 个目标
branches.local.branches=本地分支
branches.local.branches.in.repo={0} 中的本地分支
branches.merge.into=将 {0} 合并到 {1} 中
branches.merge.into.current=合并到当前分支
branches.new.branch.from.branch=从 {0} 新建分支…
branches.new.branch.from.branch.current=从当前位置新建分支…
branches.new.branch.from.branch.description=从 {0} 创建新分支
branches.rebase.current.onto.selected=将当前分支变基到所选分支
branches.rebase.is.not.possible.in.the.detached.head.state=在游离的 HEAD 状态下无法变基
branches.rebase.onto=将 {0} 变基到 {1}
branches.rebase.onto.selected.commit=将 {0} 变基到所选提交
branches.rebase.onto.selected.commit.description=将 {0} 变基到 {1}
branches.remote.branches=远程分支
branches.remote.branches.in.repo={0} 中的远程分支
branches.rename.branch=重命名分支 {0}
branches.selected.branch.name=已选择
branches.show.commits.in=在{0}中显示{1}中缺少的提交
branches.show.diff.with.working.tree=显示与工作树的差异
branches.tag.0=标记 ''{0}''
branches.tags=标记
branches.tags.in.repo={0} 中的标签
branches.there.are.incoming.and.outgoing.commits=存在传入和传出提交
branches.there.are.incoming.commits=存在传入提交
branches.there.are.outgoing.commits=存在传出提交
branches.tooltip.number.incoming.commits={0} 个传入{0,choice,1\#提交|2\#提交}
branches.tooltip.number.incoming.commits.in.repositories={1} 个{1, choice, 1\#仓库|2\#仓库}中的 {0} 个传入{0,choice,1\#提交|2\#提交}
branches.tooltip.number.outgoing.commits={0} 个传出{0,choice,1\#提交|2\#提交}
branches.tooltip.number.outgoing.commits.in.repositories={1} 个{1, choice, 1\#仓库|2\#仓库}中的 {0} 个传出{0,choice,1\#提交|2\#提交}
branches.tooltip.some.incoming.commits.not.fetched=一些传入提交未被提取
branches.tracking.branch.doesn.t.configured.for.s=没有为 {0} 配置跟踪分支
branches.update=更新
branches.update.failed=更新失败
branches.update.info.process=更新分支信息…
branches.update.is.already.running=更新已在运行
branches.updating.process=正在更新分支…
button.changes.excluded.from.commit.commit.anyway=仍然提交
button.crlf.fix.dialog.commit.as.is=按原样提交
button.crlf.fix.dialog.fix.and.commit=修复并提交
button.don.t.rollback=不回滚
button.rollback=回滚
button.set.name.and.commit.template=设置并{0}
changes.retrieving=检索修订 {0} 的更改
changes.view.merge.action.text=合并
changes.view.rollback.action.text=回滚
checkbox.dont.warn.again=不再警告(&W)
checkbox.run.git.hooks=运行 Git 挂钩(&H)
checkbox.set.config.property.globally=全局设置属性(&G)
checkout.0=签出 {0}
checkout.and.rebase=变基到远程
checkout.new.branch.operation.branch.was.created=已创建分支 {0}
checkout.new.branch.operation.checked.out.0.and.deleted.1.on.2.3=已在{2,choice,1\#根|2\#根}{3}上签出 {0} 并删除 {1}
checkout.new.branch.operation.could.not.create.new.branch=无法创建新分支 {0}
checkout.new.branch.operation.error.during.rollback=回滚期间出错
checkout.new.branch.operation.errors.during.checkout=签出期间出错\:
checkout.new.branch.operation.errors.during.deleting=删除 {0} 期间出错\:
checkout.new.branch.operation.however.checkout.has.succeeded.for.the.following=不过，{0,choice,1\#仓库|2\#仓库}的签出已成功\:
checkout.new.branch.operation.rollback.successful=回滚成功
checkout.new.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滚(签回上一个分支并删除 {0})以使分支不出现分叉。
checkout.operation.checked.out=已签出 {0}
checkout.operation.checked.out.new.branch.from=已从 {1} 中签出新分支 {0}
checkout.operation.could.not.checkout.error=无法签出 {0}
checkout.operation.could.not.checkout.error.title=无法签出 {0}
checkout.operation.error.during.rollback=回滚期间出错
checkout.operation.errors.during.checkout=签出期间出错\:
checkout.operation.errors.during.deleting=删除 {0} 期间出错\:
checkout.operation.force.checkout=强制签出(&F)
checkout.operation.however.checkout.has.succeeded.for.the.following=不过，以下{0,choice,1\#仓库|2\#仓库}的签出已成功\:
checkout.operation.in={1,choice,0\#|1\#{2}中的}{0}
checkout.operation.name=签出
checkout.operation.previous.branch=上一个分支
checkout.operation.revision.not.found=在{0,choice,0\#|1\#{1}中}未找到修订
checkout.operation.rollback.action=回滚
checkout.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滚(签回 {0})以使分支不出现分叉。
cherry.pick.applied=应用
cherry.pick.name=优选
clone.dialog.checking.git.version=正在检查 Git 版本…
clone.dialog.shallow.clone=浅层化克隆，历史记录被截断为
clone.dialog.shallow.clone.depth=提交
column.name.commit.signature=GPG 签名
combobox.item.file.invalid=(无效)
commit.action.commit.and.rebase.text=提交并变基…
commit.action.name=提交 (&I)
commit.author=作者(&U)\:
commit.author.diffs=<html>作者与默认不同</html>
commit.author.with.committer={0}，通过 {1}
commit.check.warning.title.commit.during.rebase=正在仓库中进行变基\: {0}。在变基期间提交可能会导致提交丢失。
commit.check.warning.title.commit.during.rebase.details=有关 Git 变基的更多信息
commit.check.warning.title.commit.with.detached.head=仓库处于游离的 HEAD 状态\: {0}
commit.check.warning.title.commit.with.detached.head.details=有关游离的 HEAD 的更多信息
commit.check.warning.title.large.file=您即将向仓库提交一个大文件\: {0} 个{0,choice,1\#文件|2\#文件}，总大小为 {1}MB。\n不建议在 Git 仓库中存储大文件。请考虑使用 Git LFS。
commit.check.warning.user.name.email.not.set=未设置 Git user.name 和 user.email
commit.options.create.extra.commit.with.file.movements=使用文件移动创建额外提交
commit.options.sign.off.commit.checkbox=Sign-off 提交(&G)
commit.options.sign.off.commit.message.line=在提交消息结尾添加以下行\:<br/>Signed-off by\: {0}
commit.signature.bad=错误的 GPG 签名
commit.signature.fingerprint=签名指纹\:
commit.signature.none=无 GPG 签名
commit.signature.signed.by=通过密钥签名\:
commit.signature.unverified=未验证的 GPG 签名
commit.signature.unverified.reason.cannot.verify=无法验证(例如，缺少密钥)
commit.signature.unverified.reason.expired=过期的签名
commit.signature.unverified.reason.expired.key=使用过期的密钥创建
commit.signature.unverified.reason.revoked.key=使用撤消的密钥创建
commit.signature.unverified.reason.unknown=未知有效性
commit.signature.unverified.with.reason=未验证的 GPG 签名\: {0}
commit.signature.verified=已验证的 GPG 签名
common.current.branch=当前分支\:
common.current.branch.tooltip=当前已签出的分支。
common.git.root=Git 根(&R)\:
common.git.root.tooltip=选择 Git VCS 根
common.local.branches=公共本地分支
common.no.active.branch=<无活动分支>
common.refreshing=正在刷新文件
common.remote.branches=公共远程分支
common.suffix.in.one.repository=在 {0} 中
common.suffix.in.several.repositories=在 {0} 个仓库中
common.tags=常用标签
computing.annotation=正在计算 {0} 的注解
conflict.resolver.unmerged.files.check.error.notification.description.text=由于错误，无法检查工作树中是否有未合并的文件。{0}
conflicts.accept.progress=正在解析 {0,choice,1\#个冲突|2\#个冲突}
conflicts.accept.theirs.action.text=接受他们的更改
conflicts.accept.yours.action.text=接受您的更改
conflicts.loading.status=正在加载合并冲突…
conflicts.merge.window.error.message=找不到 {0} 的文件
conflicts.merge.window.error.title=无法解决冲突
conflicts.resolve.action.text=解决
conflicts.type.added.by.them=由他们添加
conflicts.type.added.by.you=由您添加
conflicts.type.both.added=均已添加
conflicts.type.both.deleted=均已删除
conflicts.type.both.modified=均已修改
conflicts.type.deleted.by.them=由他们删除
conflicts.type.deleted.by.you=由您删除
convert.language.extra.commit.commit.message=将 .{0} 重命名为 .{1}
convert.language.extra.commit.description=.{0} > .{1} 重命名的额外提交
create.branch.operation.branch.created=已创建分支 {0}
create.branch.operation.could.not.create.new.branch=无法创建新分支 {0}
create.branch.operation.deleted.branch=已删除 {0}
create.branch.operation.error.during.rollback=回滚期间出错
create.branch.operation.however.the.branch.was.created.in.the.following.repositories=不过，已在以下{0,choice,1\#仓库|2\#仓库}中创建分支\:
create.branch.operation.name=创建分支
create.branch.operation.rollback.successful=回滚成功
create.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滚(删除 {0})以使分支不出现分叉。
delete.branch.operation.branch.was.not.deleted.error=分支 {0} 未删除
delete.branch.operation.collecting.unmerged.commits.process=正在收集未合并的提交…
delete.branch.operation.could.not.restore.branch.error=无法还原 {0}
delete.branch.operation.deleted.branch=已删除分支 {0}
delete.branch.operation.deleted.branch.bold=<b>已删除的分支\:</b> {0}
delete.branch.operation.error.during.rollback.of.branch.deletion=分支删除回滚期间出错
delete.branch.operation.however.branch.deletion.has.succeeded.for.the.following=不过，以下{0,choice,1\#仓库|2\#仓库}的分支删除已成功\:
delete.branch.operation.name=分支删除
delete.branch.operation.restoring.branch.process=正在还原分支 {0}…
delete.branch.operation.unmerged.commits.were.discarded=未合并的提交已被舍弃
delete.branch.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滚(在这些根中重新创建 {0})以使分支不出现分叉。
delete.remote.branch.operation.also.deleted.local.branches=同时删除了本地 {0,choice,1\#分支|2\#分支}\: {1}
delete.remote.branch.operation.couldn.t.find.remote.by.name=无法按名称查找远程\: {0}
delete.remote.branch.operation.deleted.remote.branch=已删除远程分支 {0}
delete.remote.branch.operation.deleting.process=正在删除 {0}
delete.remote.branch.operation.failed.to.delete.remote.branch=无法删除远程分支 {0}
delete.remote.tag.operation.deleted.tag.on.remotes=<b>已删除{0,choice,1\#远程|2\#远程}上的标记\:</b> {1}
delete.remote.tag.operation.failed.to.delete.tag.on.remotes=无法删除 {1,choice,1\#远程|2\#远程} 上的标记 {0}
delete.remote.tag.operation.tag.does.not.exist.on.remotes=<b>标记在{0,choice,1\#远程|2\#远程}上不存在\:</b> {1}
delete.tag.operation.could.not.find.tag=找不到标记 {0}
delete.tag.operation.could.not.find.tag.in=在 {0} 中找不到标记
delete.tag.operation.could.not.restore.tag=无法还原 {0}
delete.tag.operation.delete.on.remote=在{0,choice,1\#远程|2\#远程}上删除
delete.tag.operation.deleted.tag=<b>已删除的标记\:</b> {0}
delete.tag.operation.error.during.rollback.of.tag.deletion=标记删除回滚期间出错
delete.tag.operation.however.tag.deletion.has.succeeded.for.the.following=不过，以下{0,choice,1\#仓库|2\#仓库}的标签删除已成功\:
delete.tag.operation.restored.tag=已还原标记 {0}
delete.tag.operation.restoring.tag.process=正在还原标记 {0}…
delete.tag.operation.rollback.successful=回滚成功
delete.tag.operation.tag.was.not.deleted=未删除标记 {0}
delete.tag.operation.you.may.rollback.not.to.let.tags.diverge=您可以回滚(在这些根中重新创建 {0})以使标记不出现分叉。
dialog.message.rebasing.merge.commits=您即将变基存在冲突的合并提交。\n\n如果您不想再次解决冲突，请选择“合并”; 如果要将历史记录线性化，仍可进行变基。
dialog.message.untracked.files.will.be.overwritten.by.operation=这些未跟踪的文件将被{0}覆盖
dialog.message.update.branch=您即将从 {1} 更新 {0}。\n\n如果要创建合并提交，请选择“合并”；如果要变基到 {1}，请选择“变基”。
dialog.title.could.not.operation=无法{0}
dialog.title.local.changes.prevent.from.operation=本地更改阻止{0}
dialog.title.rebasing.merge.commits=正在变基合并提交
dialog.title.untracked.files.preventing.operation=阻止{0}的未跟踪文件
dialog.title.update.branch=更新 {0}
diff.find.error=正在查找差异的修订\: {0}
editor.promo.close.link=不再显示
editor.promo.commit.text=使用提交接口直接从 {0} 提交。
editor.promo.commit.try.link=尝试
editor.promo.help.link=了解详情
error.cannot.delete.file=无法删除文件\: {0}
error.cant.set.user.name.email=无法设置 user.name 和 user.email
error.commit.cant.collect.partial.changes=无法收集要提交的部分更改
error.commit.cant.commit.multiple.changelists=无法一次提交多个更改列表中的更改
error.commit.cant.commit.with.unmerged.paths=由于您有未合并的文件，因此无法提交。
error.commit.cant.create.message.file=创建提交消息文件失败
error.dialog.title=错误
error.git.parse.not.a.revision.number=字符串 ''{0}'' 不表示修订号
error.git.parse.unknown.file.status=未知文件状态\: {0}
error.git.repository.not.found=该仓库不再存在\: {0}
error.list.title={0} 错误\:
error.no.changed.files.no.commit.message=修改要提交的文件并指定提交消息
error.no.changed.files.to.commit=修改要提交的文件
error.no.selected.roots.to.commit=选择要提交的根
error.no.staged.changes.no.commit.message=暂存要提交的文件并指定提交消息
error.no.staged.changes.to.commit=暂存要提交的文件
error.occurred.during=''{0}'' 时出错
error.unresolved.conflicts=解决冲突以提交
errors.message=Git 操作以多个错误结束\: {0}
errors.message.item=\n   {0}
exception.message.could.not.stash.root.error=无法隐藏 {0}\: {1}
executable.error.git.not.installed=未安装 Git
executable.mac.error.invalid.path.to.command.line.tools=Command Line Tools 的路径无效
executable.mac.fix.path.action=修正路径
exportable.Git.Application.Settings.presentable.name=Git
fetch.action.name=提取
fetch.pruned.obsolete.remote.references=删除过时的远程 {0,choice,1\#引用|2\#引用}\: {1}
fetching=正在提取…
find.git.error.title=运行 Git 时出错
find.git.success.title=Git 执行成功
find.git.unsupported.message=<html><tt>{0}</tt><br>此版本不受支持，某些插件功能可能无法工作。<br>支持的最低版本是 <em>{1}</em>。</html>
git.add.to.exclude.file.action.description=将条目添加到 .git/info/exclude
git.add.to.exclude.file.action.text=.git/info/exclude
git.branches.popup.loading.tags=正在加载 Git 标签…
git.branches.popup.search.field.actions.empty.text={0,choice,1\#和|2\#、}操作
git.branches.popup.search.field.empty.text=搜索分支{0}{1}
git.branches.popup.search.field.repositories.empty.text={0,choice,1\#和|2\#、}仓库
git.branches.popup.tree.accessible.name=分支树
git.branches.popup.tree.no.branches=找不到分支 ''{0}''
git.branches.popup.tree.no.nodes=找不到 ''{0}''
git.commit.message.empty.title=提交消息为空
git.commit.nothing.to.commit.error.message=没有要提交的内容
git.compare.branches.empty.status={0} 包含来自 {1} 的所有提交
git.compare.branches.explanation.message=存在于 {0} 中但不存在于 {1} 中的提交
git.compare.branches.tab.name=比较
git.compare.branches.tab.suffix={0} 和 {1}
git.compare.with.branch.search.field.empty.text=搜索分支{0,choice,0\#|1\#和标签}
git.compare.with.branch.search.not.found=找不到 ''{0}''
git.compare.with.tag.file.not.found.in.tag=标记 ''{2}'' 中不存在{0,choice,1\#文件|2\#目录} {1}
git.compare.with.tag.loading.error.title=无法加载标记
git.compare.with.tag.modal.progress.loading.tags=正在加载标记…
git.compare.with.tag.popup.title=选择要比较的标记
git.content.transform.filters=筛选器
git.content.transform.none=无
git.content.transform.textconv=TextConv
git.error.cant.process.output=无法处理 Git 输出\: {0}
git.error.exit=Git 进程退出，代码为 {0}
git.executable.detect.progress.title=正在检测 Git 可执行文件
git.executable.error.bash.not.found=找不到 bash 可执行文件
git.executable.error.file.not.found=没有此类文件\: {0}
git.executable.install.available=安装 Git {0}
git.executable.new.version.update.available=更新为 Git {0}
git.executable.unknown.error.message=无法启动 Git 进程\: {0}
git.executable.validation.cant.identify.executable.message=无法识别 Git 可执行文件 {0} 的版本
git.executable.validation.cant.run.in.safe.mode=无法在安全模式下运行 Git 命令
git.executable.validation.error.no.response.in.n.attempts.message=无法识别 Git 可执行文件的版本\: {0,choice,0\#|2\# {0} 次尝试后}无响应
git.executable.validation.error.start.title=无法运行 Git
git.executable.validation.error.version.message=至少需要 {0}
git.executable.validation.error.version.title=Git 版本 {0} 不受支持
git.executable.validation.error.wsl.start.title=无法在 WSL 中运行 Git
git.executable.validation.error.wsl1.unsupported.message=不支持 WSL 版本 1，请参阅 <a href\='https\://youtrack.jetbrains.com/issue/IDEA-242469'>IDEA-242469</a> 了解可能的解决方案。
git.executable.validation.error.xcode.message=运行“sudo xcodebuild -license”并重试(需要管理员权限)
git.executable.validation.error.xcode.title=接受 XCode/iOS 许可证以运行 Git
git.executable.version.is=Git 版本为 {0}
git.executable.version.progress.title=正在识别 Git 版本
git.fetch.progress=正在提取…
git.history.diff.handler.choose.parent.popup=选择要比较的父项
git.history.diff.handler.git.show.error=执行 git show {0}\:{1} 时出错
git.history.diff.handler.load.changes.process=正在加载更改…
git.history.diff.handler.no.changes.in.file.info=此合并提交中的文件 {0} 无更改
git.integration.could.not.git.init=无法 git init {0}
git.integration.created.git.repository.in=已在 {0} 中创建 Git 仓库
git.light.cant.find.current.revision.exception.message=找不到 {0} 的当前修订
git.light.status.bar.display.name=Git
git.light.status.bar.text=Git\: {0}
git.light.status.bar.tooltip=当前 Git 分支\: {0}
git.log.action.checkout.group=签出
git.log.action.checkout.revision.full.text=签出修订 ''{0}''
git.log.action.checkout.revision.short.text=修订 ''{0}''
git.log.branches.search.field.accessible.description=按 {0} 转到 VCS 日志表筛选器
git.log.branches.search.field.accessible.name=Git 分支搜索
git.log.branches.tree.accessible.name=Git 分支
git.log.cherry.picked.highlighter.cancelled.message=已取消对 ''{0}'' 中未选取提交的高亮显示，因为分支筛选器已被更改。
git.log.cherry.picked.highlighter.error.message=无法与分支 {0} 进行比较
git.log.cherry.picked.highlighter.process=正在比较分支…
git.log.cherry.picked.highlighter.select.branch.popup=选择源分支
git.log.diff.handler.changes.between.revisions.in.paths.title={2} 中 {0} 与 {1} 之间的更改
git.log.diff.handler.changes.between.revisions.title={0} 与 {1} 之间的更改
git.log.diff.handler.local.version.content.title=本地
git.log.diff.handler.local.version.name=本地版本
git.log.external.loading.process=正在加载 Git 日志…
git.log.external.tab.description={0} 的日志
git.log.external.window.title=Git 日志
git.log.refGroup.local=本地
git.log.show.commit.in.log.process=正在搜索修订 {0}
git.new.tag.dialog.tag.name.label=输入新标记的名称
git.new.tag.dialog.title=在 {0}上创建新标记
git.open.exclude.file.action.description=在编辑器中打开 .git/info/exclude
git.open.exclude.file.action.text=打开 .git/info/exclude
git.recent.projects.show.branch.mode.always=所有项目
git.recent.projects.show.branch.mode.for.duplicate.names=同名项目
git.recent.projects.show.branch.mode.never=从不
git.rename.branch.could.not.rename.from.to=无法将 {0} 重命名为 {1}
git.rename.branch.could.not.unset.upstream=无法取消设置分支 {0} 的上游
git.rename.branch.has.succeeded.for.the.following.repositories=不过，以下{0,choice,1\#仓库|2\#仓库}的重命名已成功\:
git.rename.branch.renamed.back.to=已重命名回 {0}
git.rename.branch.rollback.failed=回滚失败
git.rename.branch.rollback.successful=回滚成功
git.rename.branch.was.renamed.to=分支 {0} 已被重命名为 {1}
git.rename.branch.you.may.rename.branch.back=您可以回滚(将分支重命名回 {0})以使分支不出现分叉。
git.reset.button=重置
git.reset.dialog.description=<nobr>这会将当前分支 HEAD 重置为所选提交，<nobr/><br><nobr>并根据所选模式更新工作树和索引\:<nobr/>
git.reset.dialog.description.commit.details.by.author={0}，作者 {1}
git.reset.dialog.description.source.in.repository={0} ({1} 内)
git.reset.dialog.title=Git 重置
git.reset.failed.notification.title=重置失败
git.reset.hard.button=硬重置(&H)
git.reset.mode.hard=硬
git.reset.mode.hard.description=<nobr>文件将还原为所选提交的状态。<nobr/><br><nobr>警告\: 任何本地更改都将丢失。<nobr/>
git.reset.mode.keep=保留
git.reset.mode.keep.description=<nobr>文件将还原为所选提交的状态，<nobr/><br><nobr>但本地更改将保持不变。<nobr/>
git.reset.mode.mixed=混合
git.reset.mode.mixed.description=文件不会更改，差异也不进行暂存。
git.reset.mode.soft=软
git.reset.mode.soft.description=文件不会更改，差异将暂存以进行提交。
git.reset.operation=重置
git.reset.partially.failed.notification.msg={0} 重置成功\n但 {1} 重置失败\:\n{2}
git.reset.partially.failed.notification.title=重置部分失败
git.reset.process=Git 重置
git.reset.successful.notification.message=重置成功
git.rollback=回滚(&R)
git.running=运行\: {0}
git.status.bar.widget.name=Git 分支
git.status.bar.widget.text.cherry.pick=正在 {0} 中优选
git.status.bar.widget.text.merge=正在合并 {0}
git.status.bar.widget.text.rebase=正在变基 {0}
git.status.bar.widget.text.revert=正在 {0} 中还原
git.status.bar.widget.text.unknown=<未知>
git.status.bar.widget.tooltip.detached=Git\: 游离的 HEAD 不指向任何分支
git.status.bar.widget.tooltip.rebasing=Git\: 正在进行变基
git.status.copied=已复制
git.status.index=在暂存区域中{0}
git.status.not.changed=未更改
git.status.renamed=已重命名
git.status.type.changed=已更改类型
git.status.unmerged=已取消合并
git.status.unmerged.both=两者{0}
git.status.unmerged.index=我们{0}
git.status.unmerged.work.tree=由他人{0}
git.status.untracked=已取消跟踪
git.status.work.tree=在工作目录中{0}
git.tag.could.not.create.tag=无法创建标记
git.tag.created.tag.successfully=已成功创建标记 {0}。
git.toolbar.widget.no.loaded.repo=Git
git.toolbar.widget.no.repo=版本控制
git.toolbar.widget.no.repo.tooltip=为项目配置版本控制
git.undo.action.cant.undo.commit.failure=无法撤消提交
git.undo.action.could.not.load.changes.of.commit=无法加载 {0} 的更改
git.undo.action.description=所选提交不是当前分支中的最后一次提交
git.undo.action.failed.notification.title=撤消提交失败
git.undo.action.operation=撤消提交
git.undo.action.refreshing.changes.process=正在刷新更改…
git.undo.action.select.target.changelist.title=选择目标更改列表
git.undo.action.successful.notification.message=撤消提交成功
git.undo.action.undoing.last.commit.process=正在撤消最后一次提交…
git.update.commits.matching.filters={0,choice,1\#{0} 个提交|2\#{0} 个提交}与筛选器匹配
git.update.files.updated.in.commits=已更新 {1,choice,1\#{1} 个提交|2\#{1} 个提交}中的 {0,choice,1\#{0} 个文件|2\#{0} 个文件}
git.update.no.commits.matching.filters=没有与筛选器匹配的提交
git.update.operation=更新
git.update.project.partially.updated.title=项目已部分更新
git.update.repo.was.skipped=已跳过 {0} ({1})
git.update.skipped.repositories=已跳过 {0} 个仓库\:
git4idea.vcs.name=Git
git4idea.vcs.name.with.mnemonic=Git(_G)
gpg.error.see.documentation.link.text=参阅 GPG 设置指南
gpg.error.text=提交签名失败
gpg.jb.manual.link=Set_up_GPG_commit_signing
gpg.pinentry.agent.configuration.configuration.backup.exception=无法创建配置备份
gpg.pinentry.agent.configuration.confirmation.text=GPG 代理将被配置为使用 {0} 内置 pinentry 程序。<br/><br/>如果 {0} 未处于有效状态，将使用当前配置的 pinentry 程序\: <tt>{1}</tt>
gpg.pinentry.agent.configuration.confirmation.title=更新 GPG 代理配置
gpg.pinentry.agent.configuration.confirmation.yes=更新
gpg.pinentry.agent.configuration.detect.default.pinentry.exception=无法检测 pinentry 程序
gpg.pinentry.agent.configuration.exception=无法更新 GPG 配置\: {0}
gpg.pinentry.agent.configuration.launcher.generation.exception=无法生成 pinentry 启动器
gpg.pinentry.agent.configuration.read.exception=无法读取 GPG 配置
gpg.pinentry.agent.configuration.save.exception=无法保存更新的 GPG 配置
gpg.pinentry.configuration.error.title=GPG 代理配置失败
gpg.pinentry.configuration.global.suggestion.do.not.ask.again.display.name=GPG 代理配置(建议)
gpg.pinentry.configuration.proposal.configure=配置…
gpg.pinentry.configuration.proposal.message=要{0,choice,0\#在远程主机上|1\#在 WSL 中|2\#}支持 GPG 提交签名，请将 GPG 代理配置为使用 {1} 内置 pinentry 程序
gpg.pinentry.configuration.proposal.title=GPG 代理配置
gpg.pinentry.configuration.suggestion.do.not.ask.again.display.name=GPG 代理配置(无效提交后的建议)
gpg.pinentry.configured.successfully.backup.message=已在 <code>{0}</code> 中创建现有配置的备份
gpg.pinentry.configured.successfully.message=GPG 代理配置已在 <code>{0}</code> 中更新
gpg.pinentry.configured.successfully.title=GPG 代理配置成功
gpg.pinentry.default.description=请输入密码短语以解锁 GPG 私钥\:
gpg.pinentry.jb.manual.link=Set_up_GPG_pinentry_for_commit_signing
gpg.pinentry.title=解锁 GPG 私钥
group.Git.Branch.Tracked.name=跟踪分支操作
group.Git.Branch.Tracked.name.withBranch=跟踪分支 ''{0}''
group.Git.CheckoutGroup.description=签出所选修订或所选提交中的分支
group.Git.CheckoutGroup.text=签出
group.Git.ContextMenu.text=Git(_G)
group.Git.HEAD.Branch.Filter.title=HEAD(当前分支)
group.Git.Local.Branch.title=本地
group.Git.Log.Branches.Grouping.Settings.text=分组依据
group.Git.Log.Branches.Settings.Separator.text=点击时
group.Git.Log.Branches.Settings.text=分支窗格设置
group.Git.Log.ShareLogIndexData.text=共享 Git 日志索引数据
group.Git.MainMenu.LocalChanges.text=未提交的更改(_U)
group.Git.MainMenu.MergeActions.text=合并(_M)
group.Git.MainMenu.RebaseActions.text=变基(_R)
group.Git.Menu.text=Git(_G)
group.Git.Recent.Branch.in.repo.title={0} 中最近的分支
group.Git.Recent.Branch.title=最近
group.Git.Remote.Branch.title=远程
group.Git.Stage.Configure.text=配置本地更改
group.Git.Stage.Index.File.Menu.text=Git
group.Git.Stage.Ui.Settings.text=视图选项
group.Git.Tags.loading.text=正在加载…
group.Git.Tags.title=标签
group.MainToolbarVCSGroup.text=VCS 组
group.Vcs.ToolbarWidget.ShareProject.text=在以下平台上共享项目\:
history.filters.unsupported.error.message=不支持按“{0}”筛选历史记录
history.for.revision.filters.unsupported.error.message=不支持按“{0}”筛选修订历史记录
in.branches.all.repositories=在所有仓库中
in.memory.rebase.data.contains.empty.reword.message.for.entry=内存中变基数据包含条目的空改写消息\: {0}
in.memory.rebase.data.contains.entry.with.unsupported.action=内存中变基数据包含具有不受支持操作的条目\: {0}
in.memory.rebase.data.contains.missing.reword.message.for.entry=内存中变基数据包含条目缺失的改写消息\: {0}
in.memory.rebase.fail.head.move=在提交编辑操作期间 HEAD 发生移动
in.memory.rebase.failed.rebase.data=无法生成有效的内存中变基数据
in.memory.rebase.interactive.failed.message=正在回退到常规变基
in.memory.rebase.interactive.failed.title=内存中变基失败
in.memory.rebase.log.change.extract.action.progress.indicator.title=正在提取更改…
in.memory.rebase.log.changes.action.operation.extract.name=提取所选更改
in.memory.rebase.log.changes.extract.action.description.all.changes.selected=无法从提交中提取所有更改
in.memory.rebase.log.changes.extract.action.failure.title=无法提取所选更改
in.memory.rebase.log.changes.extract.action.notification.successful.title=已提取的更改
in.memory.rebase.log.changes.extract.action.notification.undo.failed.title=撤消提取更改失败
in.memory.rebase.log.changes.extract.action.notification.undo.not.allowed.title=无法撤消提取更改
in.memory.rebase.log.changes.extract.action.progress.indicator.undo.title=正在撤消提取更改…
in.memory.rebase.log.changes.extract.dialog.description.label=由 {1} 从提交 {0} 中提取的更改
in.memory.rebase.log.changes.extract.dialog.title=新的提交消息
in.memory.rebase.log.changes.extract.failed.title=无法提取所选更改
in.memory.rebase.log.interactive.action.notification.successful=变基成功
in.memory.rebase.log.interactive.action.notification.undo.failed.title=撤消交互式变基失败
in.memory.rebase.log.interactive.action.notification.undo.not.allowed.title=无法撤消交互式变基
in.memory.rebase.log.interactive.action.progress.indicator.undo.title=正在撤消交互式变基…
in.memory.rebase.log.interactive.failed.title=交互式变基失败
in.memory.rebase.log.reword.failed.title=改写失败
in.memory.rebase.log.squash.failed.title=压缩失败
in.memory.split.tree.mixed.error=无法提取所选更改
in.memory.split.tree.submodules.error=不支持通过 git 子模块条目拆分树
init.destination.directory.description=选择将在其中创建新 Git 仓库的目录。
init.destination.directory.title=创建 Git 仓库
init.warning.already.under.git=所选目录 <tt>{0}</tt> 已在 Git 下。\n确定要创建新的 VCS 根吗?
init.warning.title=Git Init
initializing.title=正在初始化仓库…
install.download.and.install.action=下载并安装
install.downloading.progress=正在下载…
install.general.error=无法安装 Git
install.installing.progress=正在安装…
install.mac.error.couldnt.start.command.line.tools=无法启动 Command Line Tools 安装
install.mac.requesting.command.line.tools=正在请求 XCode Command Line Developer Tools
install.success.message=已安装 Git
label.changes.excluded.from.commit.are.you.sure.want.to.continue=确定要从合并提交中排除这些更改过的文件吗?
label.credential.store.key.http.password=Git HTTP
label.diff.content.title.submodule.suffix={0} (子模块)
label.name.email.not.defined.in.n.roots={0,choice,1\#根|2\#根}中未定义 Git 的 user.name 和 user.email 属性
label.user.email=电子邮件(&E)\:
label.user.name=名称(&N)\:
link.label.commit.with.detached.head.read.more=阅读有关游离的 HEAD 的更多信息
link.label.commit.with.unfinished.rebase.read.more=阅读有关 Git 变基的更多信息
link.label.editor.notification.merge.conflicts.resolve.in.progress=正在解决合并冲突
link.label.editor.notification.merge.conflicts.suggest.resolve=文件存在未解决的合并冲突
link.label.merge.conflicts.resolve.in.progress.cancel.resolve=取消解决
link.label.merge.conflicts.resolve.in.progress.focus.window=显示解析冲突窗口
link.label.merge.conflicts.suggest.resolve.show.window=解决冲突…
local.changes.freeze.message.git.operation.prefix=Git {0}
local.changes.save.policy.shelve=搁置
local.changes.save.policy.stash=隐藏
local.changes.would.be.overwritten.by.merge.view.them.action=查看这些变更
log.command.empty.text=[<options>] [<revision-range>] [[--] <path>...]
log.parser.exception.message.could.not.parse.output=无法解析 Git 日志输出“{0}”
log.parser.exception.message.error.command.line={0}\n命令行\: [{1}]
log.parser.exception.message.error.parsing.line=解析第“{0}”行时出错
login.dialog.button.login=登录
login.dialog.error.password.cant.be.empty=密码不能为空
login.dialog.error.username.cant.be.empty=用户名不能为空
login.dialog.label.login.to.url=登录 {0}
login.dialog.login.with.selected.provider=使用 {0} 登录…
login.dialog.password.label=密码\:
login.dialog.prompt.enter.credentials=输入凭据\:
login.dialog.select.login.way.credentials=输入凭据
login.dialog.select.login.way.use.helper=使用凭据帮助程序
login.dialog.username.label=用户名\:
mention.in=\ ({0} 中)
merge.action.after.update.label=更新后
merge.action.before.update.label=更新前
merge.action.name=合并
merge.action.operation.failed=Git {0} 失败
merge.branch.already.merged=分支 ''{0}'' 已被合并
merge.branch.field.placeholder=指定分支
merge.branch.into.current.title=合并到 {0}
merge.branch.loading.branches.progress=正在加载未合并的分支…
merge.branch.popup.empty.text=无分支
merge.branch.title=合并更改
merge.commit.message.label=提交消息\:
merge.dialog.customizer.collecting.details.progress=正在收集提交详细信息…
merge.dialog.customizer.filter.by.conflicted.file.checkbox=按冲突文件筛选
merge.dialog.customizer.show.details.link.label=显示详细信息
merge.dialog.description.cherry.pick.label.text=在优选{2,choice,0\#|1\#由 {3}{4} 执行的}{0,choice,1\#提交 {1}|2\#多个提交}期间出现冲突
merge.dialog.description.merge.label.text=将{0,choice,1\#分支 {1} |2\#分叉的分支}合并到{2,choice,1\#分支 {3}|2\#分叉的分支}
merge.dialog.description.rebase.conflict.current.commit=当前提交 {0} 由 {1} 完成\:
merge.dialog.description.rebase.with.hash.label.text=正在{0,choice,0\#|1\#将分支 {1} }变基到 {2}
merge.dialog.description.rebase.with.onto.branch.label.text=正在{0,choice,0\#|1\#将分支 {1} }变基到分支 {2}{3,choice,0\#|1\#，修订 {4}}
merge.dialog.description.rebase.without.onto.info.label.text=正在{0,choice,0\#|1\#将分支 {1} }变基到分叉的分支
merge.dialog.diff.left.title.cherry.pick.label.text=本地更改
merge.dialog.diff.left.title.default.branch.label.text=您的版本，分支 {0}
merge.dialog.diff.left.title.rebase.label.text=正在从 {1} 变基 {0}
merge.dialog.diff.right.title.cherry.pick.label.text=来自优选 {0} 的更改
merge.dialog.diff.right.title.default.with.hash.label.text=来自 {0} 的更改
merge.dialog.diff.right.title.default.with.onto.branch.label.text=来自分支 {0}{1,choice,0\#|1\#，修订 {2}} 的更改
merge.dialog.diff.right.title.default.without.onto.info.label.text=来自分叉分支的更改
merge.dialog.diff.right.title.rebase.with.branch.label.text=已变基的提交和来自 {0} 的提交
merge.dialog.diff.right.title.rebase.without.branch.label.text=已变基的提交
merge.dialog.diff.title.changes.from.branch.label.text=来自 {0} 的更改
merge.error.unable.to.read.merge.head=无法读取文件 {0}\: {1}
merge.no.branch.selected.error=应选择该合并分支。
merge.no.matching.branch.error=没有匹配分支。
merge.operation.already.up.to.date=已处于最新状态
merge.operation.branch.merged.with.conflicts={0} 已合并，但存在冲突
merge.operation.could.not.merge.branch=无法合并 {0}
merge.operation.delete.branch.action=删除 {0}
merge.operation.error.during.rollback=回滚期间出错
merge.operation.however.merge.has.succeeded.for.the.following.repositories=不过，以下{0,choice,1\#仓库|2\#仓库}的合并已成功\:
merge.operation.merged.to=已将 {0} 合并到 {1}
merge.operation.name=合并
merge.operation.you.may.rollback.not.to.let.branches.diverge=您可以回滚(重置为合并之前的提交)以使分支不出现分叉。
merge.option.allow.unrelated.histories=允许合并不具有共同上级的历史记录
merge.option.ff.only=仅在可以快进时合并
merge.option.msg=指定合并提交的消息
merge.option.no.commit=不提交合并结果
merge.option.no.ff=即使可以快进也创建合并提交
merge.option.no.verify=绕过预合并和提交消息挂钩
merge.option.squash=为所有合并更改创建一个提交
merge.options.modify=修改选项
merge.options.modify.popup.title=添加合并选项
merge.progress.indicator.loading.unmerged.files.title=正在加载未合并的文件…
merge.tool.column.status.deleted=已删除
merge.tool.column.status.modified=已修改
merge.tool.column.theirs.status=他人的更改
merge.tool.column.theirs.with.branch.status=他人的更改({0})
merge.tool.column.yours.status=您的更改
merge.tool.column.yours.with.branch.status=您的更改({0})
merge.unresolved.conflicts.remaining.notification.body=有挂起的未解决的冲突。
merge.unresolved.conflicts.remaining.notification.title=正在挂起未解决的冲突
merge.update.project.conflict.merge.description.label=检测到合并冲突。请先解决这些冲突，然后再继续更新。
merge.update.project.generic.error.title=无法完成更新
merging.title=将更改合并到 {0}
message.unresolved.conflicts.prevent.commit=由于有未解决的冲突，无法提交更改。
modal.commit.deprecation.notification.description=模态提交模式已移至一个将在 {0} {1} 中解绑的插件
new.branch.dialog.branch.name=分支名称\:
new.branch.dialog.branch.root.all.name=所有
new.branch.dialog.branch.root.all.override.warning=根将位于不同的分支上。某些分支操作不会同时在所有根上执行。
new.branch.dialog.branch.root.name=根\:
new.branch.dialog.checkout.branch.checkbox=签出分支(&C)
new.branch.dialog.error.branch.already.exists=分支名称 {0} 已存在
new.branch.dialog.error.branch.clashes.with.directory=分支名称 {0} 与同名的本地分支目录冲突
new.branch.dialog.error.branch.clashes.with.remote=分支名称 {0} 与同名的远程分支冲突
new.branch.dialog.error.branch.name.empty=指定新分支的名称
new.branch.dialog.error.branch.name.head=HEAD 是保留关键字
new.branch.dialog.error.branch.name.invalid=分支名称 {0} 无效
new.branch.dialog.operation.checkout.description=签出现有分支，并在其他仓库中创建新分支
new.branch.dialog.operation.checkout.name=签出
new.branch.dialog.operation.create.description=在其他仓库中创建新分支
new.branch.dialog.operation.create.name=创建
new.branch.dialog.operation.rename.name=重命名
new.branch.dialog.overwrite.existing.branch.checkbox=覆盖现有分支(&R)
new.branch.dialog.overwrite.existing.branch.warning=更改名称或覆盖现有分支
new.branch.dialog.set.tracking.branch.checkbox=设置跟踪分支(&T)
new.branch.dialog.unset.upstream.branch.checkbox=取消设置上游分支(&T)
no.revisions.available=无修订
notification.content.branch.in.repo.has.no.tracked.branch={0} {1} 没有跟踪的分支
notification.content.couldn.t.authorize=授权错误
notification.content.couldnt.collect.updated.files.info={0} 更新成功，但由于发生了一个错误，我们无法收集更新的更改
notification.content.detached.state.in.root.checkout.branch=您处于“游离的 HEAD”状态，这表明您不在任何分支 {0} 上<br/>签出分支以更新项目。
notification.content.fetch.failed.couldn.t.authorize=提取失败\: 授权错误
notification.content.fetched.successfully=已成功提取
notification.content.untracked.files.prevent.operation.move.or.commit=在 {0} 前移动或提交<br/>{1}
notification.content.updating.root.failed.with.error=更新 {0} 失败，出现错误\: {1}
notification.ignore.file.generation.error.text.files.progress.title=无法生成 .gitignore 文件
notification.title.can.t.update.no.current.branch=无法更新\: 无当前分支
notification.title.couldn.t.reset.merge=无法中止合并操作
notification.title.couldnt.collect.updated.files.info=无法收集已更新文件的信息
notification.title.error.merging=合并错误
notification.title.error.updating.root=更新 {0} 期间出错
notification.title.fetch.details=提取详细信息
notification.title.fetch.failed=提取失败
notification.title.fetch.failure=提取失败
notification.title.fetch.success=提取成功
notification.title.git.operation.failed=Git {0} 失败
notification.title.unstash.failed=取消隐藏失败
notification.title.unstash.failed.index.conflict=由于索引冲突，取消隐藏失败
notification.title.untracked.files.prevent.operation=未跟踪的文件会阻止{0}
notification.title.update.failed=更新失败
open.in.browser.error=无法在浏览器中打开
open.in.browser.getting.revision=正在获取最新的文件修订
open.in.browser.getting.revision.error=无法检索文件的最新修订
operation.action.message=多个 Git 根有未完成的 {0} 进程，请选择要对其执行操作的根。
operation.name.loading.revision=加载修订
operation.name.validating.revision.0=验证修订 {0}
output.parse.exception.unexpected.end.message=文本在 ''{0}'' 意外结束
paths.affected.title=提交 {0} 中受影响的路径
post.commit.check.load.changes.error=无法为 {1} 加载根 {0} 中的更改
preserving.process.local.changes.not.restored.error.title=未还原本地更改
progress.checking.line.separator.issues=正在检查行分隔符问题…
progress.details.refreshing.files.for.root=正在刷新根 {0} 的文件
progress.finishing.conflict.resolve=正在解决冲突
progress.setting.config.value=正在更新 Git 配置…
progress.setting.user.name.email=正在设置 Git 用户名…
progress.text.merging.repository=正在合并 {0}…
progress.title.calculating.commit.messages=正在计算提交消息
progress.title.creating.git.repository=正在创建 Git 仓库…
progress.title.enabling.git=正在启用 Git…
progress.title.moving.files=正在移动文件…
progress.title.reverting.n.commits=正在还原{0,choice,1\#提交|2\#提交}
progress.title.update=更新
progress.title.validating.revision=正在验证修订…
progress.update.destination.remote=远程
pull.action.name=拉取
pull.branch.field.placeholder=指定分支
pull.branch.no.matching.remotes=无远程
pull.branch.not.selected.error=应选择要从中拉取的分支。
pull.branch.nothing.to.pull=无分支
pull.button=拉取
pull.dialog.fetch.shortcuts.hint=按 {0} 更新分支
pull.dialog.title=拉取
pull.dialog.with.branch.title=拉取到 {0}
pull.fetch.failed.notification.text=选择一个本地仓库和一个远程仓库
pull.fetch.failed.notification.title=无法加载远程分支
pull.option.ff.only=仅在可以快进时合并
pull.option.no.commit=合并，但不提交结果
pull.option.no.ff=即使可以快进也创建合并提交
pull.option.rebase=在传入更改上变基当前分支
pull.option.squash.commit=为所有拉取更改创建一个提交
pull.options.modify.popup.title=添加拉取选项
pull.remote.not.selected=选择要从中拉取的远程仓库
pull.repository.not.selected.error=选择一个仓库
pulling.title=从 {0} 中拉取更改
push.dialog.preview.commits.before.push=对于向不受保护分支的提交和推送，应在推送之前预览提交
push.dialog.prohibited.branch.configurable.path={0} | 版本控制 | Git
push.dialog.push.tags=推送标记(&T)
push.dialog.push.tags.combo.all=所有
push.dialog.push.tags.combo.current.branch=当前分支
push.dialog.target.panel.add.remote=添加远程
push.dialog.target.panel.adding.remote=正在添加远程…
push.dialog.target.panel.can.t.push=无法推送
push.dialog.target.panel.couldnt.add.remote=无法添加远程\: {0}
push.dialog.target.panel.define.remote=定义远程
push.dialog.target.panel.empty.repository=空仓库
push.dialog.target.panel.new=新建
push.dialog.target.panel.new.and.upstream=新建和上游
push.dialog.target.panel.upstream.checkbox=设置上游
push.dialog.target.panel.upstream.label=上游
push.failed.error.message=推送失败\: {0}
push.local.history.system.label.after=推送后
push.local.history.system.label.before=推送前
push.notification.description.force.pushed=强制推送 {0} 到 {1}
push.notification.description.new.branch=已推送 {0} 到新分支 {1}
push.notification.description.new.branch.with.many.tags=推送 {0} 到新分支 {1}，并将 {2} 标签到 {3}
push.notification.description.new.branch.with.single.tag=推送 {0} 到新分支 {1}，并将 {2} 标签到 {3}
push.notification.description.push.with.lease.rejected=使用 Force-with-lease 推送 {0} 到 {1} 被拒
push.notification.description.pushed=已将 {0} 个{0,choice,1\#提交|2\#提交} 推送到 {1}
push.notification.description.pushed.many.tags=已推送 {0} 标签到 {1}
push.notification.description.pushed.single.tag=已推送标签 {0} 到 {1}
push.notification.description.pushed.with.many.tags=已将 {0} 个{0,choice,1\#提交|2\#提交} 推送到 {1}，将 {2} 标签推送到 {3}
push.notification.description.pushed.with.single.tag=已将 {0} 个{0,choice,1\#提交|2\#提交} 推送到 {1}，将标签 {2} 推送到 {3}
push.notification.description.rejected=推送到 {0} 被拒
push.notification.description.rejected.and.cancelled=推送被拒，更新被取消
push.notification.description.rejected.and.conflicts=由于更新期间发生冲突，推送被取消。<br/>检查是否已正确解决冲突，然后再次调用推送。
push.notification.description.rejected.and.failed=因发生错误，推送被拒，更新失败
push.notification.description.rejected.and.incomplete=由于更新过程中并未解决所有冲突，推送被取消。<br/>请解决冲突并再次调用推送
push.notification.description.rejected.by.remote=推送 {0} 到 {1} 被远程拒绝
push.notification.description.rejected.by.remote.without.target={0} 的推送被远程拒绝
push.notification.description.up.to.date=所有内容都已处于最新状态
push.notification.force.push.anyway.action=仍然强制推送
push.notification.force.push.progress.title.pushing=正在推送…
push.notification.force.with.lease.help=何为 Force-with-Lease?
push.notification.force.with.lease.help.description.first=Force-with-lease 推送阻止重写尚未提取到本地仓库的远程更改
push.notification.force.with.lease.help.description.second=提取最新更改，以确认能否安全舍弃更改并重复执行推送操作
push.notification.partially.failed.title=推送部分失败
push.notification.partially.rejected.title=推送部分被拒
push.notification.push.failed.title=推送失败
push.notification.rejected.title=推送被拒
push.notification.single.repo.success.description=推送操作期间收到 {0} 个{0, choice,1\#提交|2\#提交}
push.notification.successful.title=推送成功
push.notification.update.action=更新
push.notification.view.files.action=查看在推送期间更新的文件
push.notification.view.filtered.commits.actions=查看与筛选器匹配的 {0} 个{0,choice,1\#提交|2\#提交}
push.notification.view.received.commits.action=查看收到的{0,choice,1\#提交|2\#提交}
push.rejected.dialog.title=推送被拒
push.rejected.many.repos=当前分支的推送被拒\:
push.rejected.many.repos.item={1} 中的 {0}
push.rejected.many.repos.single.branch=当前分支“{0}”的推送被拒。
push.rejected.merge=合并(&M)
push.rejected.merge.needed=推送前需要合并远程更改。
push.rejected.merge.needed.with.problem=在推送前，必须先合并远程更改。<br/><br/>在这种情况下，强烈建议进行<b>合并</b>，因为存在未推送的合并提交。\n<br/>进行变基可能导致问题。
push.rejected.only.one.git.repo=当前分支“{0}”的推送被拒。
push.rejected.rebase=变基(&R)
push.rejected.rebase.anyway=仍然变基
push.rejected.remember.checkbox=请记住更新方法，并在日后进行无提示更新(&S)。稍后可以在“{0} | 版本控制”中进行更改。<br/>
push.rejected.specific.repo=仓库“{1}”中的当前分支“{0}”推送被拒。
push.up.to.commit.allowed.progress.title=正在检查是否允许推送到选定的提交…
push.up.to.commit.getting.reference.progress.title=正在获取对 HEAD 的提交引用…
push.upto.here.failed.dialog.title=无法启动推送
rebase.abort.and.rollback.dialog.message=仅中止 {0} 中的变基还是同时回滚 {1} 中的变基?
rebase.abort.and.rollback.dialog.no.button.text=仅中止
rebase.abort.and.rollback.dialog.yes.button.text=中止并回滚
rebase.abort.dialog.message=中止{0} 中的变基?
rebase.abort.dialog.ok.button.text=中止
rebase.abort.dialog.title=中止变基
rebase.abort.notification.failed.title=中止变基失败
rebase.abort.notification.successful.message=中止变基成功
rebase.abort.notification.warning.rollback.failed.message={0}中的回滚失败\:{1}{2}
rebase.abort.notification.warning.rollback.failed.title=变基回滚失败
rebase.abort.notification.warning.rollback.failed.with.repo.message=成功中止 {0} 中的变基，但 {1}\:{2}{3} 中的回滚失败
rebase.abort.progress.indicator.command.in.repo.title={0} ({1} 内)
rebase.abort.rollback.successful.rebase.dialog.message=是否要回滚 {0} 中成功的变基?
rebase.abort.rollback.successful.rebase.dialog.ok.button.text=回滚
rebase.confirmation.dialog.published.commits.button.cancel.text=取消
rebase.confirmation.dialog.published.commits.button.rebase.text=仍然变基
rebase.confirmation.dialog.published.commits.message.first=您正在尝试变基一些已推送到受保护分支的提交。
rebase.confirmation.dialog.published.commits.message.second=对这些提交进行变基将使提交重复，这是不推荐的，而且很可能是不需要的。
rebase.confirmation.dialog.published.commits.title=变基已发布的提交
rebase.conflict.diff.dialog.left.title=正在从 {1} 变基 {0}
rebase.conflict.diff.dialog.right.simple.title=已变基的提交
rebase.conflict.diff.dialog.right.with.branch.title=已变基的提交和来自 {0} 的提交
rebase.couldnt.resolve.file=无法解析 {0}
rebase.dialog.branch.field=源分支
rebase.dialog.error.base.not.selected=选择新基
rebase.dialog.error.branch.invalid=分支 ''{0}'' 不存在
rebase.dialog.error.branch.not.selected=选择要切换到的分支
rebase.dialog.error.branch.or.tag.not.exist=没有这样的分支或标记
rebase.dialog.error.rebase.in.progress=此 Git 根目录已经在进行交互式变基
rebase.dialog.error.upstream.not.selected=选择上游
rebase.dialog.help=显示 Git 变基帮助
rebase.dialog.new.base=新基础(分支或哈希)
rebase.dialog.old.base=原基础(分支或哈希)
rebase.dialog.progress.loading.tags=正在加载标记…
rebase.dialog.root.invalid.label.text=(无效)
rebase.dialog.start.rebase=变基
rebase.dialog.target=分支或哈希
rebase.dialog.title=变基
rebase.entry.action.name.drop=删除
rebase.entry.action.name.edit=编辑
rebase.entry.action.name.fixup=Fixup
rebase.entry.action.name.pick=选取
rebase.entry.action.name.reword=改写
rebase.entry.action.name.squash=压缩
rebase.entry.action.name.unknown=未知
rebase.entry.action.name.update.ref=更新引用
rebase.git.operation.name=变基
rebase.help.link=git-scm.com 上的 git 变基
rebase.help.popup.ad.text=按空格打开外部链接
rebase.help.rebase.branch=将基于一个分支的分支变基到另一个分支\:
rebase.interactive.dialog.cancel.reword.warning.body=输入的提交消息将会丢失
rebase.interactive.dialog.cancel.reword.warning.cancel=取消改写
rebase.interactive.dialog.cancel.reword.warning.continue=继续编辑
rebase.interactive.dialog.cancel.reword.warning.title=取消改写
rebase.interactive.dialog.discard.modifications.cancel=取消变基
rebase.interactive.dialog.discard.modifications.continue=继续变基
rebase.interactive.dialog.discard.modifications.discard=舍弃
rebase.interactive.dialog.discard.modifications.message=舍弃更改并取消变基?
rebase.interactive.dialog.git.commands=Git 命令
rebase.interactive.dialog.git.commands.column.action=操作
rebase.interactive.dialog.git.commands.column.hash=哈希
rebase.interactive.dialog.git.commands.column.subject=主题
rebase.interactive.dialog.reset.link.text=重置
rebase.interactive.dialog.reword.hint.text=按 {0} 应用更改
rebase.interactive.dialog.start.rebase=启动变基
rebase.interactive.dialog.stop.to.edit.text=停止以编辑
rebase.interactive.dialog.title=正在变基提交
rebase.interactive.dialog.view.git.commands.text=查看 Git 命令
rebase.interactive.edit.commit.message.dialog.title=Git 提交消息
rebase.interactive.edit.commit.message.ok.action.title=继续变基
rebase.interactive.noop.dialog.text=由于当前分支直接位于基础分支的正下方或它们指向同一个提交，因此没有要变基的提交('noop' 情况)。\n 是否要继续? (这会将当前分支重置为基础分支)
rebase.interactive.noop.dialog.title=Git 变基
rebase.interactive.unstructured.editor.dialog.root.label=Git 根\: {0}
rebase.log.action.loading.commit.message.failed.message=无法加载{0,choice,1\#提交|2\#提交}的更改
rebase.log.action.operation.rebase.name=变基
rebase.log.action.operation.reword.name=改写
rebase.log.action.progress.indicator.loading.commit.message.title=正在加载{0,choice,1\#提交|2\#提交}详细信息…
rebase.log.changes.action.operation.drop.name=删除所选更改
rebase.log.changes.drop.action.description.all.changes.selected=无法删除提交中的所有更改
rebase.log.changes.drop.action.failure.title=无法删除所选更改
rebase.log.changes.drop.action.notification.successful.title=更改已删除
rebase.log.changes.drop.action.notification.undo.failed.title=撤消删除更改失败
rebase.log.changes.drop.action.notification.undo.not.allowed.title=无法撤消删除更改
rebase.log.changes.drop.action.progress.indicator.title=正在删除更改…
rebase.log.changes.drop.action.progress.indicator.undo.title=正在撤消删除更改…
rebase.log.changes.drop.failed.title=无法删除所选更改
rebase.log.commit.editing.action.commit.not.in.head.error.text=该提交不在当前分支中
rebase.log.commit.editing.action.commit.pushed.to.protected.branch.error.text=该提交已被推送到受保护分支 ''{0}''
rebase.log.commit.editing.action.disabled.parents.description=所选提交已{0}父项
rebase.log.commit.editing.action.initial.commit.dialog.text=确定要编辑初始提交吗?
rebase.log.commit.editing.action.initial.commit.dialog.title=正在编辑初始提交
rebase.log.commit.editing.action.progress.containing.branches.title=正在搜索包含所选提交的分支…
rebase.log.commit.editing.action.prohibit.state=不能{0}
rebase.log.commit.editing.action.prohibit.state.grafting=优选期间不能{0}
rebase.log.commit.editing.action.prohibit.state.merging=合并期间不能{0}
rebase.log.commit.editing.action.prohibit.state.rebasing=变基期间不能{0}
rebase.log.commit.editing.action.prohibit.state.reverting=还原期间不能{0}
rebase.log.create.fixup.commit.action.failure.title=无法创建 Fixup 提交
rebase.log.create.squash.commit.action.failure.title=无法创建压缩提交
rebase.log.drop.action.confirmation.message=是否要从 <b>{1}</b> 分支删除 {0} 个{0,choice,1\#提交|2\#提交}?
rebase.log.drop.action.confirmation.message.detached.head=仓库处于分离的 HEAD 状态。是否要删除 {0} 个{0,choice,1\#提交|2\#提交}?
rebase.log.drop.action.confirmation.title=删除{0,choice,1\#提交|2\#提交}
rebase.log.drop.action.custom.text=删除{0,choice,1\#提交|2\#提交}
rebase.log.drop.action.failure.title=无法删除提交
rebase.log.drop.progress.indicator.title=正在删除{0, choice, 1\#提交|2\#提交}…
rebase.log.drop.success.notification.title=已删除 {0} 个{0,choice,1\#提交|2\#提交}
rebase.log.drop.undo.failed.title=撤消删除失败
rebase.log.drop.undo.impossible.title=无法撤消删除
rebase.log.drop.undo.progress.title=正在撤消删除…
rebase.log.interactive.action.failure.title=无法启动变基
rebase.log.multiple.commit.editing.action.cant.find.head=在包含选定{0,choice,1\#提交|2\#提交}的仓库中找不到 HEAD 分支
rebase.log.multiple.commit.editing.action.disabled.external.repository.description=所选{0, choice, 1\#提交|2\#提交}{0, choice,1\#|2\#}来自外部仓库
rebase.log.multiple.commit.editing.action.disabled.multiple.repository.description=所选{0, choice, 1\#提交|2\#提交}{0, choice,1\#|2\#}来自不同的仓库
rebase.log.multiple.commit.editing.action.progress.indicator.action.possibility.check=正在检查是否允许编辑所选提交…
rebase.log.multiple.commit.editing.action.specific.commit.not.in.head=提交 {0} 不在当前分支中
rebase.log.multiple.commit.editing.action.specific.commit.root.or.merge=提交 {0} 有 {1} 个父项
rebase.log.reword.action.failure.title=无法编辑提交消息
rebase.log.reword.action.notification.successful.title=已更改提交消息
rebase.log.reword.action.notification.undo.failed.title=撤消提交消息编辑失败
rebase.log.reword.action.notification.undo.not.allowed.repository.changed.message=仓库已被更改
rebase.log.reword.action.notification.undo.not.allowed.title=无法撤消提交消息编辑
rebase.log.reword.action.progress.indicator.title=正在改写…
rebase.log.reword.action.progress.indicator.undo.title=正在撤消改写…
rebase.log.reword.dialog.description.label=编辑由 {1} 执行的提交 {0} 的消息
rebase.log.reword.dialog.failed.pushed.to.protected.message=无法编辑所选{0,choice,1\#提交|2\#提交}\: 提交 {1} 已被推送到受保护的分支 ''{2}''
rebase.log.reword.dialog.failed.repository.changed.message=无法编辑所选{0,choice,1\#提交|2\#提交}\: 仓库状态已更改
rebase.log.reword.dialog.title=编辑提交消息
rebase.log.squash.action.failure.title=无法压缩提交
rebase.log.squash.new.message.dialog.label=编辑已压缩提交的消息
rebase.log.squash.new.message.dialog.title=已压缩提交消息
rebase.log.squash.progress.indicator.title=正在压缩…
rebase.log.squash.success.notification.title=提交已压缩
rebase.log.squash.undo.failed.title=撤消压缩失败
rebase.log.squash.undo.impossible.title=无法撤消压缩
rebase.log.squash.undo.progress.title=正在撤消压缩…
rebase.log.undo.impossible.pushed.to.protected.branch.notification.text=来自当前分支的提交已被推送到受保护的分支 {0}
rebase.notification.action.abort.text=中止
rebase.notification.action.continue.text=继续
rebase.notification.action.retry.text=重试
rebase.notification.action.stage.and.retry.text=暂存并重试
rebase.notification.action.view.shelf.text=查看搁置…
rebase.notification.action.view.stash.text=查看隐藏…
rebase.notification.all.conflicts.resolved.continue.rebase.action.text=继续变基(&T)
rebase.notification.all.conflicts.resolved.text=所有冲突都已解决。是否要继续变基?
rebase.notification.all.conflicts.resolved.title=解决冲突
rebase.notification.conflict.title=由于冲突，变基停止
rebase.notification.continue.failed.stage.changes.text=无法暂存跟踪文件中的更改
rebase.notification.continue.failed.unstaged.changes.text=跟踪文件中存在未暂存的更改，阻止继续变基
rebase.notification.editing.title=变基已停止，可以进行编辑
rebase.notification.failed.continue.title=继续变基失败
rebase.notification.failed.rebase.title=变基失败
rebase.notification.no.rebase.in.progress.abort.title=无法中止变基
rebase.notification.no.rebase.in.progress.continue.title=无法继续变基
rebase.notification.no.rebase.in.progress.message=没有正在进行的变基
rebase.notification.not.allowed.empty.repository.message=仓库 {0} 为空。
rebase.notification.not.allowed.grafting.message.first={0} 中有一个未完成的优选进程。
rebase.notification.not.allowed.grafting.message.second=在开始变基前，应先完成这项操作。
rebase.notification.not.allowed.merging.message.first={0} 中有一个未完成的合并进程。
rebase.notification.not.allowed.merging.message.second=在开始变基前，应先完成合并。
rebase.notification.not.allowed.message=无法在 {0} 中进行变基。
rebase.notification.not.allowed.rebasing.message.first={0} 中有一个未完成的变基进程。
rebase.notification.not.allowed.rebasing.message.second=在开始另一个变基前，应先完成这项操作。
rebase.notification.not.allowed.reverting.message.first={0} 中有一个未完成的还原进程。
rebase.notification.not.allowed.reverting.message.second=在开始变基前，应先完成这项操作。
rebase.notification.not.allowed.title=不允许变基
rebase.notification.not.started.title=变基未启动
rebase.notification.saved.local.changes.part.shelf.text=变基前已搁置本地更改。
rebase.notification.saved.local.changes.part.stash.text=变基前已隐藏本地更改。
rebase.notification.successful.rebased.checkout.message=已签出{0,choice,0\#|1\# {1} }并将其变基{2,choice,0\#|1\#到 {3}}
rebase.notification.successful.rebased.message=已{0,choice,0\#|1\#将 {1} }变基{2,choice,0\#|1\#到 {3}}
rebase.notification.successful.title=变基成功
rebase.operation.name=变基
rebase.option.autosquash=自动压缩标记为 fixup 或 squash 的提交
rebase.option.interactive=在变基之前编辑提交
rebase.option.keep.empty=变基期间不移除空提交
rebase.option.onto=为变基的提交指定新基
rebase.option.rebase.merges=重新创建提交拓扑
rebase.option.root=变基分支中的所有提交
rebase.option.switch.to.branch=选择另一个要变基的分支
rebase.option.update.refs=自动更新指向变基的提交的分支
rebase.options.modify.dialog.title=添加变基选项
rebase.progress.indicator.aborting.title=正在中止变基进程…
rebase.progress.indicator.conflicts.collecting.title=正在收集要解决的冲突…
rebase.progress.indicator.continue.title=正在继续变基进程…
rebase.progress.indicator.preparing.title=正在准备变基…
rebase.progress.indicator.retry.title=正在重试变基进程…
rebase.progress.indicator.title=正在变基…
rebase.simple.editor.dialog.title=Git 编辑器
rebase.tracked.files.with.unstaged.changes.empty.text=没有未暂存的文件
rebase.tracked.files.with.unstaged.changes.title=具有未暂存更改的跟踪文件
rebase.update.project.abort.task.title=正在中止变基…
rebase.update.project.conflict.error.notification.description=然后，您可以<b>继续变基</b>。<br/>您也可以<b>中止变基</b>以还原原始分支并停止变基。
rebase.update.project.conflict.error.notification.title=无法继续变基
rebase.update.project.conflict.merge.description.label=检测到合并冲突。请先解决这些冲突，然后再继续变基。
rebase.update.project.notification.abort.error.message=中止变基时出错
rebase.update.project.notification.abort.success.message=已中止变基
rebase.update.project.notification.failed.message=无法继续变基。{0}
rebase.update.project.notification.failed.title=变基错误
rebase.using.log.couldnt.start.error=由于 IDE 生成的 'git-rebase-todo' 文件无效，因此无法执行变基。是否要使用 Git 原生文件生成来重试变基?
rebasing.merge.commits.button.cancel=取消
rebasing.merge.commits.button.merge=合并
rebasing.merge.commits.button.rebase=变基
reference.validating.progress.indicator.title=正在验证修订…
remote.dialog.add.remote=添加远程
remotes.changing.remote.error.message=无法将远程 {0} 更改为 {1} ''{2}''
remotes.changing.remote.error.title=更改远程
remotes.changing.remote.progress=正在更改远程…
remotes.define.duplicate.remote.name.validation.message=远程名称 ''{0}'' 已被使用
remotes.define.empty.remote.name.validation.message=远程名称不能为空
remotes.define.empty.remote.url.validation.message=远程 URL 不能为空
remotes.define.invalid.remote.name.validation.message=远程名称包含非法字符
remotes.define.remote=定义远程
remotes.define.remote.name=名称\:
remotes.define.remote.url=URL\:
remotes.dialog.adding.remote=正在添加远程…
remotes.dialog.cannot.add.remote.error.message=无法添加远程 {0} ''{1}''
remotes.dialog.remove.remote.message=移除{0,choice,1\#远程|2\#远程}{1}?
remotes.dialog.remove.remote.title=移除{0,choice,1\#远程|2\#远程}
remotes.dialog.removing.remote.error.message=无法移除{0, choice, 1\#远程|2\#远程} {1}
remotes.dialog.removing.remote.error.title=移除{0,choice,1\#远程|2\#远程}
remotes.dialog.removing.remote.progress=正在移除{0,choice,1\#远程|2\#远程}…
remotes.dialog.title=Git 远程
remotes.fetch.remote.text=提取远程
remotes.operation.error.message=在 {1} 中{0}\:\n{2}
remotes.operation.not.executed.message=操作未执行
remotes.remote.column.name=名称
remotes.remote.column.url=URL
remove.removing=正在移除文件…
rename.branch.operation.name=重命名
repositories=仓库
repository.action.missing.roots.misconfigured=配置的 Git 根都不在 Git 下。配置的目录中必须包含“.git”目录。
repository.action.missing.roots.title=没有 Git 根
repository.action.missing.roots.unconfigured.message=没有为项目配置 Git 根。
repository.not.found.error=找不到 {0} 的已配置 Git 仓库
reset.action.name=重置 Head…
reset.commit.invalid=指定的提交表达式未通过验证。
reset.commit.label=为提交(&C)\:
reset.commit.tooltip=由于重置操作而将成为当前 HEAD 的提交。
reset.title=重置 Head
reset.type=重置类型(&T)\:
reset.type.tooltip=<html>重置类型(另请参阅 <code>git reset</code> man 页面)\:<ul><li><b>Mixed</b> 将重置索引，但不会重置工作树</li><li><b>Soft</b> 将保留索引和工作树，只是移动 HEAD 指针</li><li><b>Hard</b> 将重置索引和工作树。<em>工作树中的更改会丢失</em></li></ul></html>
reset.validate=验证(&V)
resetting.title=正在重置 HEAD…
restore.conflict.dialog.description.label.text=在 {0} 之前保存的未提交更改与 {1} 中的文件冲突
restore.conflict.diff.dialog.left.shelf.title=搁置中的未提交更改
restore.conflict.diff.dialog.left.stash.title=隐藏中的未提交更改
restore.conflict.diff.dialog.right.title=来自 {0} 的更改
restore.notification.failed.shelf.message=在{0}之前，您未提交的更改已保存至搁置。
restore.notification.failed.show.changes.action=查看已保存的更改…
restore.notification.failed.stash.message=在{0}之前，您的未提交的更改已保存至隐藏。
restore.notification.failed.title=未还原本地更改
revert.operation.applied=还原
revert.operation.name=还原
revision.load.contents=加载修订内容
revision.number.cannot.parse.output=无法解析输出\: [{0}]
save.load.conflict.dialog.diff.left.title=您未提交的更改
save.load.conflict.dialog.diff.right.title=远程更改
save.notification.failed.shelf.text=无法搁置本地未提交的更改\:
save.notification.failed.stash.text=无法隐藏本地未提交的更改\:
save.notification.failed.title=无法保存 {0} 上未提交的更改
search.everywhere.group.full.name=Git 引用
search.everywhere.group.name=Git
search.everywhere.items.commit.by.hash=提交(按哈希)
search.everywhere.items.commit.by.message=提交(按消息)
search.everywhere.items.local.branch=本地分支
search.everywhere.items.remote.branch=远程分支
search.everywhere.items.tag=标记
search.scope.project.git.exclude.ignored=项目文件，不包括 Git 忽略的文件
search.scope.project.git.tracked=Git 跟踪的项目文件
separator.Git.Stage.Configure.display.as=显示为
separator.git.branches.popup.filter.by=在搜索结果中添加
separator.show=显示
settings.add.suffix=在挑选推送到受保护分支的提交时，添加 'cherry-picked from <hash>' 后缀
settings.auto.update.on.push.rejected=如果当前分支的推送被拒，则自动更新
settings.bad.file.names=提交名称可能会导致其他系统出现问题的文件时发出警告
settings.clean.working.tree=使用以下方法清理工作树\:
settings.commit.group.title=提交
settings.configure.sign.gpg.do.not.sign.table.text=不签署
settings.configure.sign.gpg.error.no.available.keys.found.text=找不到适用的私钥
settings.configure.sign.gpg.error.table.text=错误\: {0}
settings.configure.sign.gpg.for.repo.dialog.title=配置 GPG 密钥 {0}
settings.configure.sign.gpg.for.repos.dialog.title=配置 GPG 密钥
settings.configure.sign.gpg.gpg.kep.table.column.name=GPG 密钥
settings.configure.sign.gpg.loading.table.text=正在加载…
settings.configure.sign.gpg.root.table.column.name=根
settings.configure.sign.gpg.synced.with.gitconfig.text=与 gitconfig 同步
settings.configure.sign.gpg.with.key.checkbox.text=使用 GPG 密钥签署提交\:
settings.credential.helper=使用凭据帮助程序
settings.crlf=如果即将提交 CRLF 行分隔符，则发出警告
settings.detached.head=在游离的 HEAD 中或变基期间提交时发出警告
settings.enable.staging.area=启用暂存区域
settings.enable.staging.area.comment=这将禁用更改列表支持。仅适用于非模式提交界面。
settings.enable.stashes.and.shelves=将隐藏和搁置合并到一个标签页中
settings.explicitly.check=显式检查远程分支上的传入提交\:
settings.explicitly.check.condition.comment=需要在“高级设置”中启用 ''{0}'' 选项
settings.filter.update.info=按路径过滤“更新项目”信息\:
settings.git.fetch.tag.mode.always=始终
settings.git.fetch.tag.mode.default=自动
settings.git.fetch.tag.mode.default.description=遵循 git 配置
settings.git.fetch.tag.mode.never=从未
settings.git.fetch.tag.mode.prune=同步
settings.git.fetch.tags.label=提取标记\:
settings.git.incoming.change.strategy.text.always=始终
settings.git.incoming.change.strategy.text.auto=自动
settings.git.incoming.change.strategy.text.never=从不
settings.git.option.group=Git
settings.git.update.method.branch.default=分支默认
settings.git.update.method.merge=合并
settings.git.update.method.merge.description=&将传入更改合并到当前分支
settings.git.update.method.rebase=变基
settings.git.update.method.rebase.description=&在传入更改上变基当前分支
settings.label.sign.gpg.commits.enabled.different.keys.text=提交使用不同的 GPG 密钥签署
settings.label.sign.gpg.commits.enabled.n.roots.of.m.text=提交使用 {1} 的 {0} 个{0,choice,1\#根|2\#根}中的 GPG 密钥签署
settings.label.sign.gpg.commits.enabled.text=提交使用 GPG 密钥签署\: {0}
settings.label.sign.gpg.commits.no.roots.text=项目中没有 Git 根
settings.label.sign.gpg.commits.not.configured.text=未配置使用 GPG 密钥签署提交
settings.large.files=提交大于以下大小的文件时发出警告\:
settings.large.files.suffix=MB
settings.protected.branched=受保护分支\:
settings.protected.branched.validation=跳过无效的受保护分支模式 ''{0}''\: {1}
settings.push.dialog=显示提交和推送的推送对话框
settings.push.dialog.for.protected.branches=仅在提交到受保护分支时显示推送对话框
settings.push.group.title=推送
settings.show.rebase.log.drop.confirmation=要求确认删除提交
settings.show.rebase.log.drop.confirmation.description=适用于 Git
settings.sign.gpg.configure.link.text=配置 GPG 密钥…
settings.stash=隐藏
settings.stash.show.diff.group=调用“显示差异”时，比较隐藏的更改\:
settings.stash.show.diff.with.head=与父提交
settings.stash.show.diff.with.local=与文件的本地版本
settings.synchronize.branch.protection.rules=从 GitHub 加载分支保护规则
settings.synchronize.branch.protection.rules.description=将 GitHub 规则添加到本地规则中，并在每次提取时进行同步
settings.update.group.title=更新
settings.update.method=更新方法\:
share.action.remote.is.on.host=远程已经在 {0} 上\:
share.action.remotes.are.on.host={0} 上已经有以下远程\:
share.anyway.button=仍然共享
share.error.cannot.find.git.repo=找不到 Git 仓库
share.error.cannot.finish=无法完成 {0} 共享过程
share.error.created.project=项目创建成功
share.error.failed.to.create.repo=无法创建仓库
share.error.init.commit.failed=({0})，但初始提交失败\:<br/>
share.error.project.is.on.host=项目已在 {0} 上
share.error.push.failed=({0})，但初始推送失败\:<br/>{1}
share.error.push.no.current.branch=({0})，但初始推送失败\: 没有当前分支
share.error.unknown=未知错误
share.error.unknownHost=未知主机\: {0}
share.process=正在 {0} 中共享项目…
share.process.adding.files=正在将文件添加到 git…
share.process.adding.gh.as.remote.host=正在将 {0} 添加为远程主机…
share.process.creating.git.repository=正在创建空 git 仓库…
share.process.creating.repository=正在创建 {0} 仓库…
share.process.empty.project.created=已在 {0} 上成功创建空仓库
share.process.loading.account.info=正在加载 {0} 的帐户信息
share.process.performing.commit=正在执行提交…
share.process.pushing.to.host.master=正在推送至 {0} {1}…
share.process.retrieving.username=正在检索用户名…
share.process.successfully.shared=在 {0} 中成功共享项目
share.untracked.files.dialog.title=为初始提交添加文件
show.diff.between.dialog.could.not.load.diff.with.branch.error=无法加载与 {0} 的差异\: {1}
show.diff.between.dialog.no.differences.empty.text=无差异
show.diff.between.dialog.title={0}与当前工作树之间的更改
smart.operation.dialog.don.t.operation.name=不{0}
smart.operation.dialog.git.operation.name.problem=Git {0} 问题
smart.operation.dialog.north.panel.label.shelf.text=<html>您对以下文件的本地更改将被{0}覆盖。<br/>{1}可以搁置这些更改，{0}，并在之后取消搁置。</html>
smart.operation.dialog.north.panel.label.stash.text=<html>您对以下文件的本地更改将被{0}覆盖。<br/>{1} 可以隐藏这些更改，{0}，并在之后取消隐藏。</html>
smart.operation.dialog.ok.action.shelf.description=搁置本地更改，{0}，取消搁置
smart.operation.dialog.ok.action.stash.description=隐藏本地更改，{0}，取消隐藏
smart.operation.dialog.operation.name.and.overwrite.local.changes={0}并覆盖本地更改
smart.operation.dialog.smart.operation.name=智能{0}
stage.add.action.text=暂存
stage.add.error.title=无法暂存文件
stage.add.no.content.action.text=在没有内容的情况下暂存
stage.add.process=正在暂存文件…
stage.add.range.command.name=暂存更改
stage.commit.all.text=全部提交(&I)
stage.commit.failed=无法提交 {0}
stage.commit.process=正在提交暂存更改…
stage.commit.successful=已提交 {0}\: {1}
stage.content.local=本地
stage.content.staged=已暂存
stage.default.status=没有要提交的内容，工作树是干净的
stage.default.status.help=暂存区域入门
stage.diff.local.content.exception.message=无法获取本地文件\: ''{0}''
stage.diff.staged.content.exception.message=无法获取暂存内容\: ''{0}''
stage.loading.status=正在加载更改…
stage.reset.action.text=取消暂存
stage.reset.error.title=无法取消暂存文件
stage.reset.process=正在取消暂存文件…
stage.revert.action.text=回滚
stage.revert.error.title=无法回滚文件
stage.revert.process=正在回滚文件…
stage.revert.staged.range.command.name=回滚暂存的更改
stage.revert.unstaged.range.command.name=回滚未暂存的更改
stage.tree.node.ignored=已忽略
stage.tree.node.staged=已暂存
stage.tree.node.unmerged=已取消合并
stage.tree.node.unstaged=未暂存
stage.tree.node.untracked=已取消跟踪
stage.vfs.editor.notification.link=打开本地版本
stage.vfs.editor.notification.text=这是暂存版本的 ''{0}''
stage.vfs.editor.tab.tooltip=''{0}'' 的暂存版本
stage.vfs.presentable.file.name=已暂存\: {0}
stage.vfs.read.process=正在从 Git 索引读取 {0}
stage.vfs.shutdown.process=正在关闭 Git 索引 VFS
stage.vfs.write.process=正在将 {0} 写入 Git 索引
stash.action.name=隐藏
stash.button=创建隐藏
stash.changes.non.empty.index.for.roots.notification.text={0} 中的暂存区域包含对保存到隐藏的其他文件的修改
stash.changes.non.empty.index.notification.action=不再显示
stash.editor.diff.preview.empty.title=隐藏
stash.editor.diff.preview.id.change.title={0}\: {1}
stash.empty.text.help.link=隐藏和搁置入门
stash.enable.stashes.link=启用并查看 Git 隐藏
stash.error=无法隐藏 {0}
stash.error.can.not.stash.changes.now=现在无法隐藏更改
stash.files.action.text=隐藏文件
stash.files.error.message=无法隐藏文件
stash.files.in.roots.success={0} 中的文件已成功隐藏
stash.files.progress.title=正在隐藏文件
stash.files.success=文件已成功隐藏
stash.keep.index=保留索引(&I)
stash.keep.index.tooltip=如果选中此复选框，所有已添加到索引中的更改将保持不变
stash.load.changes.error=无法在解析为 {1} 的隐藏中加载根 {0} 中的更改
stash.message=消息(&M)\:
stash.message.tooltip=在此处输入隐藏消息
stash.progress.indicator.title=正在隐藏来自 ''{0}'' 的更改…
stash.root.node.title=隐藏
stash.tab.name=储藏
stash.title=隐藏
stash.unstash.changes.current.branch.label=当前分支\:
stash.unstash.changes.in.root.dialog.title=取消隐藏 {0} 中的更改
stash.unstash.conflict.dialog.description.label.text=更新前隐藏的未提交更改与更新后的文件冲突。
stash.unstash.progress.indicator.title=正在消除对 ''{0}'' 的更改…
stash.unstash.unresolved.conflict.warning.notification.message=您的未提交更改已保存到隐藏。<br/>取消隐藏未完成，您的工作树中有未解决的合并<br/>请解决冲突并删除隐藏。
stash.unstash.unresolved.conflict.warning.notification.resolve.conflicts.action=解决冲突…
stash.unstash.unresolved.conflict.warning.notification.show.stash.action=查看已保存的更改…
stash.unstash.unresolved.conflict.warning.notification.title=本地更改已还原，但存在冲突
stash.view.stashes.link=查看 Git 隐藏
stashes.and.shelves.tab.name=储藏和搁置
stashing.progress.title=正在隐藏更改…
stashing.title=正在隐藏更改…
stats.wrong.git.shortlog.response=Git 快捷日志输出中出现意外行 ''{0}''
status.exception.message.format.message.xstatus.ystatus.line.output={0} xStatus\=[{1}]，yStatus\=[{2}]，行\=[{3}]\n输出\:\n{4}
status.exception.message.line.is.too.short=此行过短
status.exception.message.missing.path=缺少初始路径
status.exception.message.unexpected=意外的状态符号
status.exception.message.unexpected.status=意外的状态符号\: ''{0}''
status.exception.message.unexpected.xstatus.ystatus=意外的状态符号\: ''{0}{1}''
tab.title.conflicts=冲突
tab.title.repo.root.name.at.revision={1} 的 {0}
tag.action.name=标记
tag.button=创建标签
tag.commit.label=提交(&C)
tag.commit.tooltip=输入要标记的提交或对象的名称，或留空以使用 HEAD。
tag.error.creating.message.file.message=无法创建消息文件\: {0}
tag.error.invalid.commit=该提交或对象名称无效。
tag.error.tag.exists=存在同名的标记。
tag.force=强制(&F)
tag.force.tooltip=强制创建标记，即使已存在另一个具有此名称的标记。
tag.getting.existing.tags=正在获取现有标记…
tag.message.label=消息(&M)\:
tag.message.tooltip=如果消息不为空，则创建带注解的标记。
tag.name.label=标记名称(&N)\:
tag.name.tooltip=在此处输入新的标记名称。
tag.progress.title=正在添加标记…
tag.title=标记
tag.validate=验证(&V)
tag.validate.tooltip=点击此按钮验证要标记的提交
text.crlf.fix.dialog.description.proposed.fix=如果选择<b>修正并提交</b>，将执行 {0}。<br/>如果选择<b>按原样提交</b>，则不会更改配置值。
text.crlf.fix.dialog.description.warning=您即将把 CRLF 行分隔符提交到 Git 仓库。<br/>建议将 {0} Git 特性设置为 {1}，以免发生行分隔符问题。
text.crlf.fix.notification.description.warning=您即将向 Git 仓库提交 CRLF 行分隔符
title.changes.excluded.from.commit=已从合并提交中排除更改
title.crlf.fix.dialog=行分隔符警告
title.sudo.command.install.git=安装 Git
title.unresolved.conflicts.pre.commit.check=未解决的冲突
title.user.name.email.not.specified=未定义 Git 用户名
tooltip.run.git.hooks=如果未选中，会在即将进行的提交中使用 '--no-verify' 选项跳过 Git 挂钩
tooltip.run.git.hooks.disabled=已在“高级设置”中禁用运行 Git 挂钩
tracked.branch.fix.dialog.branch.placeholder=指定分支
tracked.branch.fix.dialog.not.on.branch.message=将跳过以下仓库\:
tracked.branch.fix.dialog.not.on.branch.title=游离的 HEAD 中的 Git 仓库
tracked.branch.fix.dialog.ok.button.text=更新
tracked.branch.fix.dialog.set.as.tracked=设为跟踪分支
tracked.branch.fix.dialog.title=更新
unexpected.tree.entries.error=意外的树条目\: {0}
unexpected.tree.object.error=意外的树对象\: {0}
unshallow.repository.notification.message=检测到浅层仓库
unshallow.repository.notification.success.title=仓库已转换为完整仓库
unshallow.repository.notification.title=此仓库可以转换为完整仓库
unstash.action.name=取消隐藏
unstash.branch.label=作为新分支(&B)\:
unstash.branch.tooltip=如果输入非空名称，该隐藏将作为新分支签出
unstash.button.apply=应用隐藏
unstash.button.branch=分支
unstash.button.pop=消除隐藏
unstash.clear=清除(&C)
unstash.clear.confirmation.message=移除所有隐藏? 此操作无法撤消。
unstash.clear.confirmation.title=移除所有隐藏?
unstash.clear.tooltip=删除仓库中的所有隐藏
unstash.clearing.stashes=正在清除隐藏…
unstash.conflict.dialog.description.label.text=取消隐藏 {0} 时发生冲突
unstash.conflict.diff.dialog.left.title=本地更改
unstash.conflict.diff.dialog.right.title=来自隐藏的更改
unstash.dialog.remove.stash.progress.indicator.title=正在移除隐藏 {0}…
unstash.dialog.show.stashes.error.dialog.title=无法显示隐藏列表
unstash.dialog.stash.list.load.progress.indicator.title=正在加载隐藏列表…
unstash.dialog.unresolved.conflict.warning.notification.message=取消隐藏未完成，您的工作树中存在未解决的合并。
unstash.dialog.unresolved.conflict.warning.notification.title=取消隐藏期间未解决冲突
unstash.dialog.unresolved.conflict.warning.resolve.conflicts.action=解决冲突…
unstash.drop=删除(&D)
unstash.drop.confirmation.message=<html>是否要移除 {0}?<br/>“{1}”</html>
unstash.drop.confirmation.title=移除隐藏 {0}?
unstash.drop.tooltip=删除所选隐藏
unstash.error.can.not.unstash.changes.now=现在无法取消隐藏更改
unstash.operation.name=取消隐藏
unstash.pop.stash=消除隐藏(&P)
unstash.pop.stash.tooltip=如果选中，则该隐藏在应用后会被删除
unstash.reinstate.index=复原索引(&I)
unstash.reinstate.index.tooltip=尝试复原索引以及工作树更改
unstash.stash.applied=已成功应用隐藏
unstash.stashes=隐藏(&S)\:
unstash.title=取消隐藏更改
unstash.unstashed.with.conflicts.error.title=已取消隐藏，但存在冲突
unstash.unstashing=正在取消隐藏…
unstash.view=查看(&V)
unstash.view.dialog.title=受 {0} 影响的路径
unstash.view.tooltip=查看所选隐藏
update.checks.not.supported.git.2.9.required=不支持更新检查。需要 Git 2.9 及以上版本
update.notification.choose.upstream.branch=选择上游分支
update.notification.update.error=无法更新
update.options.display.name=Git 更新设置
update.process.error.additional.description.unfinished.rebase=然后，您可以<b>继续变基</b>。<br/>您也可以<b>中止变基</b>以还原原始分支并停止变基。
update.process.error.description.unfinished.rebase=您有未完成的变基进程。必须先解决这些冲突，然后才能更新。
update.process.error.message.unfinished.merge=您有未完成的合并。必须先解决这些冲突，然后才能更新。
update.process.error.message.unmerged.files=检测到未合并的文件。必须先解决这些冲突，然后才能更新。
update.process.error.notification.title=无法设置上游分支
update.process.generic.error.title=无法更新
update.process.nothing.to.update=没有要更新的内容
update.process.progress.title=正在更新…
update.skip.root.reason.detached.head=游离的 HEAD
update.skip.root.reason.no.tracked.branch=无跟踪分支
util.remote.renderer.none=无
validation.error.email.no.at=电子邮件地址必须包含 '@' 符号
validation.warning.set.name.email.for.git=您必须为 Git 指定用户名和电子邮件
vcs.history.action.gitlog=在 Git 日志中显示
vcs.log.archiving.log.index.data=正在归档 Git 日志索引数据…
vcs.log.create.archive.with.log.index.data=转储 Git 日志索引数据
vcs.log.status.bar.extracting.log.index.data=正在提取 Git 日志索引数据…
vcs.log.status.bar.replacing.log.index.data=正在替换 Git 日志索引数据…
vcs.log.use.log.index.data=使用共享 Git 日志索引数据
vfs.listener.add.single.prompt=是否要安排将以下文件添加到 Git?\n{0}\n\n如果您选择“取消”，以后仍可以手动添加。
vfs.listener.add.single.title=将文件添加到 Git
vfs.listener.add.title=将文件添加到 Git
vfs.listener.checking.ignored=正在检查忽略的文件…
vfs.listener.delete.single.prompt=是否要从 Git 中删除以下文件?\n{0}\n\n如果您选择“取消”，以后仍可以手动删除。
vfs.listener.delete.single.title=从 Git 中删除文件
vfs.listener.delete.title=从 Git 中删除文件
warning.message.commit.with.bad.windows.file.name.bad.character=某些文件名包含 Windows 不允许的字符\: ''{0}''。\n如果提交，可能无法在 Windows 上检出 Git 仓库。
warning.message.commit.with.bad.windows.file.name.reserved=某些文件使用 Windows 不允许的保留名称\: ''{0}。\n如果提交，将无法在 Windows 上检出 Git 仓库。
warning.message.commit.with.detached.head=以下路径中的 Git 仓库处于<b>游离的 HEAD</b> 状态\: <br/>{0}<br/>您可以进行检查，尝试做出更改并提交，但务必签出分支，以免丢失您的工作。<br/>否则，可能会丢失所做的更改。
warning.message.commit.with.unfinished.rebase=以下路径中的 Git 仓库有一个<b>未完成的变基</b>进程\: <br/> {0}<br/>您可能想<b>继续变基</b>而不是提交。<br/>在变基期间提交可能会导致提交丢失。
warning.title.commit.with.bad.windows.file.name=文件名不允许在 Windows 上使用
warning.title.commit.with.detached.head=在游离的 HEAD 中提交
warning.title.commit.with.unfinished.rebase=未完成变基进程
warning.your.local.changes.would.be.overwritten.by=您的本地更改将被 {0} 覆盖。\n提交、{1}或还原您的更改以继续。

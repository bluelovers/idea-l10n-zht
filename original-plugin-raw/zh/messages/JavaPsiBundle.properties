0.is.not.an.identifier=''{0}'' 不是一个标识符。
annotation.name.is.missing=应为格式为 'name\=value' 的注解特性
annotation.target.ANNOTATION_TYPE=注解类型
annotation.target.CONSTRUCTOR=构造函数
annotation.target.FIELD=字段
annotation.target.LOCAL_VARIABLE=局部变量
annotation.target.METHOD=方法
annotation.target.MODULE=模块
annotation.target.PACKAGE=软件包
annotation.target.PARAMETER=形参
annotation.target.RECORD_COMPONENT=记录组件
annotation.target.TYPE=类型
annotation.target.TYPE_PARAMETER=类型形参
annotation.target.TYPE_USE=类型使用
anonymous.class.context.display=匿名在{0}
anonymous.class.derived.display=派生自 {0} 的匿名类
aux.context.display=/{0}
bad.return.type.in.lambda.expression=lambda 表达式中存在错误返回值类型\: {0} 无法转换为 {1}
bad.return.type.in.lambda.expression1=lambda 表达式中存在错误返回值类型\: {0} 无法转换为 void
bad.return.type.in.method.reference=方法引用中存在错误返回值类型\: 无法将{0}转换为{1}
bound.not.expected=意外绑定
catch.without.try='catch' 没有 'try'
class.context.display={0} ({1} 内)
class.file.version=版本 {0}
class.literal.expected=应为 .class
command.name.insert.block.statement=插入块语句
conflicting.conjuncts={0} 和 {1}
context.type.java.comment=注释
context.type.string=字符串
default.language.level.description=SDK 默认值
diamond.error.anonymous.inner.classes=无法将 '<>' 用于匿名内部类
diamond.error.anonymous.inner.classes.non.private=由于非 private 方法不会重写或实现父类型中的方法，无法使用 '<>'
diamond.error.cannot.infer.arguments=无法推断实参
diamond.error.cannot.infer.arguments.unable.to.resolve.constructor=无法推断实参(无法解析构造函数)
diamond.error.cannot.infer.type.arguments=无法推断 {0} 的类型实参
diamond.error.explicit.type.parameters.for.constructor=无法将 diamond 与显式类型形参用于构造函数
element.abstract_method=abstract 方法
element.annotation=注解
element.anonymous_class=匿名类
element.class=类
element.constant=常量字段
element.constructor=构造函数
element.enum=枚举
element.enum_constant=枚举常量
element.expression=表达式
element.extends.list=extends 列表
element.field=字段
element.initializer=初始值设定项
element.interface=接口
element.kind.and.name={0} {1}
element.label=标签
element.local_variable=局部变量
element.method=方法
element.method.call=方法调用
element.module=模块
element.package=软件包
element.package.statement=package 语句
element.parameter=形参
element.pattern_variable=模式变量
element.permits.list=permits 列表
element.receiver.parameter=接收器形参
element.record=记录
element.record_component=记录组件
element.record_header=记录头
element.snippet_body=代码段正文
element.statement=语句
element.throws.list=throws 列表
element.type.arguments=类型实参
element.type.parameter=类型形参
element.type.parameters=类型形参
element.type.semicolon=分号
element.unknown=元素
element.variable=变量
else.without.if='else' 没有 'if'
enum.constant.context=枚举常数 ''{0}'' 在 ''{1}''
error.incompatible.type={0} 与 {1} 不兼容
error.incompatible.type.bad.lambda.return.type=lambda 表达式中存在错误返回值类型\: {0} 无法转换为 {1}
error.incompatible.type.declaration.for.the.method.reference.not.found=未找到方法引用的编译时声明
error.incompatible.type.expected.non.void.got.void.method.reference=不兼容的类型\: 不应当为 void，但方法引用的编译时声明具有 void 返回值类型
error.incompatible.type.expected.value.lambda=不兼容的类型\: 不应当为 void，但 lambda 体是与值不兼容的块
error.incompatible.type.failed.to.resolve.argument=无法解析实参
error.incompatible.type.incompatible.equality.constraint=不兼容的相等约束\: {0} 和 {1}
error.incompatible.type.incompatible.parameter.types.in.lambda=Lambda 形参数量错误\: 应为 {0} 个，但实际为 {1} 个
error.incompatible.type.incompatible.parameter.types.in.method.reference=方法引用表达式中存在不兼容的形参类型
error.incompatible.type.incompatible.types.expected.not.void.got.void.method.reference=不兼容的类型\: 不应当为 void，但方法引用的编译时声明具有 void 返回值类型
error.incompatible.type.incompatible.types.expected.void.lambda=不兼容的类型\: 应为 void，但 lambda 体既不是语句表达式，也不是与 void 兼容的块
error.incompatible.type.no.type.variable=不存在类型变量的实例，使 {0}
error.incompatible.type.no.type.variable.0=不存在类型变量 {0} 的实例，使 {1}
error.incompatible.type.no.valid.function.type.found=未找到 {0} 的有效函数类型
error.incompatible.type.not.a.functional.interface={0} 不是函数式接口
error.incompatible.type.not.convertible=不兼容的类型\: {0} 无法转换为 {1}
error.incompatible.type.parameter.type.is.not.yet.inferred=形参类型尚未推断\: {0}
error.incompatible.type.return.type.is.not.yet.inferred=返回值类型尚未推断\: {0}
error.incompatible.type.unhandled.exception=未处理的异常\: {0}
error.incompatible.upper.bounds=不兼容的上限\: {0}
error.inference.variable.has.incompatible.bounds=推断变量 {0} 的界限不兼容\:\n {1}\: {2}\n{3}\: {4}
error.message.wildcard.not.expected=意外通配符
error.type.parameter.has.incompatible.upper.bounds=类型形参 {0} 的上限不兼容\: {1}
expected.array.initializer=应为数组初始值设定项
expected.boolean.expression=应为布尔表达式
expected.case.label.element=应为表达式、模式、'default' 或 'null'
expected.catch.or.finally=应为 'catch' 或 'finally'
expected.class.or.interface=应为 'class' 或 'interface'
expected.class.reference=应为类引用
expected.colon=应为 '\:'
expected.colon.or.arrow=应为 '\:' 或 '->'
expected.comma=应为 ','
expected.comma.or.rparen=应为 ',' 或 ')'
expected.comma.or.semicolon=应为 ',' 或 ';'
expected.dot=应为 '.'
expected.eq=应为 '\='
expected.expression=应为表达式
expected.gt=应为 '>'。
expected.gt.or.comma=应为 '>' 或 ','
expected.identifier=应为标识符
expected.identifier.or.semicolon=应为标识符或 ';'
expected.identifier.or.type=应为标识符或类型
expected.lbrace=应为 '{'
expected.lbrace.or.semicolon=应为 '{' 或 ';'
expected.lbracket=应为 '['
expected.lparen=应为 '('
expected.lparen.or.lbracket=应为 '(' 或 '['
expected.lt.or.lparen=应为 '<' 或 '('
expected.module.declaration=应为模块声明
expected.module.statement=应为模块指令
expected.package.reference=应为软件包引用
expected.parameter=应为形参
expected.parameter.or.rparen=应为注解特性或 ')'
expected.pattern=应为模式
expected.rbrace=应为 '}'
expected.rbracket=应为 ']'
expected.resource=应为资源定义
expected.rparen=应为 ')'
expected.semicolon=应为 ';'
expected.statement=应为语句
expected.string=应为字符串字面量
expected.switch.label=应为 'case'、'default' 或 '}'
expected.switch.rule=应为表达式、块或 throw 语句
expected.template.fragment=应为模板片段
expected.type=应为类型
expected.type.parameter=应为类型形参
expected.value=应为值
expected.while=应为 'while'
expected.with=应为 'with'
filetype.class.description=Java 类
filetype.class.display.name=Java 类
filetype.java.description=Java
filetype.java.module.description=Java 模块
filetype.java.module.display.name=Java 模块
filetype.jshell.description=JShell 代码段
finally.without.try='finally' 没有 'try'
implicit.class.context.display=压缩源文件
import.statement.identifier.or.asterisk.expected.=应为标识符或 '*'
java.terms.anonymous.class.base.ref=匿名{0}
javadoc.exception.tag.class.is.not.throwable=类 {0} 不是 Throwable 的后代
javadoc.exception.tag.exception.is.not.thrown={0} 未被声明为由方法 {1} 抛出
javadoc.exception.tag.wrong.tag.value=标签值错误
javadoc.param.tag.parameter.name.expected=应为形参名称
javadoc.param.tag.type.parameter.gt.expected=应为 '>'
javadoc.param.tag.type.parameter.name.expected=应为类型形参名称
javadoc.ref.tag.class.ref.expected=应为类引用
javadoc.value.field.required=@value 标记必须引用字段
javadoc.value.field.with.initializer.required=@value 标记必须引用具有常量初始值设定项的字段
javadoc.value.static.field.required=@value 标记必须引用 static 字段
javadoc.value.tag.jdk15.required=使用 JDK 1.4 或更早版本时，@value 标记可能没有任何实参
lambda.body.must.be.a.statement.expression=lambda 体必须是语句表达式
list.item.no.module=<无模块>
local.class.preposition=本地
method.context.display={0}() 在 {1}
missing.return.value.lambda=缺少返回值
node.abstract.flag.tooltip=abstract
node.annotation.tooltip=注解
node.anonymous.class.tooltip=匿名类
node.class.tooltip=类
node.enum.tooltip=枚举
node.exception.tooltip=异常
node.field.tooltip=字段
node.final.flag.tooltip=Final
node.interface.tooltip=接口
node.junit.test.tooltip=JUnit测试
node.method.tooltip=方法
node.record.tooltip=记录
node.runnable.class.tooltip=Runnable类
node.simple.source.file.tooltip=压缩源文件
node.static.flag.tooltip=static
psi.error.attempt.to.edit.class.file=无法修改文件中的已编译元素''{0}''
task.background.title.maven=Maven
type.can.be.converted={0} 无法转换为 {1}
type.conforms.to.constraint={0} 符合 {1}
unexpected.identifier=意外标识符
unexpected.return.value=意外返回值
unexpected.token=意外的标记
unexpected.tokens=意外的标记

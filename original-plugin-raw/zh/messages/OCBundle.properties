method=方法
function=函数
block=块
lambda=Lambda
callable.type.title=可调用类型
annotator.type.literals.are.not.supported=编译器不支持 {0} 文字
extract.category.dialog=提取类别
extract.category.unable.create.file=无法创建文件
extract.unavailable.for.protocols=此操作不适用于协议
extract.method.selected.block.hint=所选块应代表一组语句或表达式
extract.method.cannot.determine.hint=无法确定所选表达式的类型
extract.class.use.protocol.instead=改用“提取超级协议”
extract.class.element.not.located.hint=所选元素是一个不在项目内部的类上的类别
extract.subclass.dialog.title=提取子类
extract.symbol.already.exist={0} 已存在
create.file.title=文件
create.file.description=创建新文件

create.field.name.category=类别名称(&N):

create.field.language=语言(&L):
create.field.class=类(&C):
create.class.title=Objective-C 类
create.class.dialog.title=新建 Objective-C 类
create.class.objc=Objective-C (.m)
create.class.objcpp=Objective-C++ (.mm)
create.class.description=创建新的 Objective-C 类和头文件
create.protocol.title=Objective-C 协议
create.protocol.description=创建新的 Objective-C 协议
create.protocol.dialog.title=新建 Objective-C 协议
create.category.title=Objective-C 类别
create.category.description=创建新的 Objective-C 类别
create.category.dialog.title=新建 Objective-C 类别
create.checkbox.category.interface=创建接口文件(&I)
create.category.no.class.dialog=找不到类 ''{0}''。\n要创建类别吗?
create.category.no.class.dialog.title=类无效
create.implementation.title=实现
create.implementation.description=创建新的实现
create.interface.title=接口
create.interface.description=创建新的接口
codeassists.surroundwith.expression=环绕方式
copy.files.handler.fail=无法将文件复制到 ''{0}''
code.style.remember.choice=记住选择
refactoring.categoryElement.not.in.project=所选元素位于不在项目内部的类上的类别中
refactoring.category.not.in.project=所选元素是一个不在项目内部的类上的类别
navigation.import.hierarchy.including.title=包含 {0} 的文件
navigation.import.hierarchy.including.action=包含层次结构
navigation.import.hierarchy.including.action.description=切换到包含层次结构
navigation.import.hierarchy.included.title={0} 包含的文件
navigation.import.hierarchy.included.action=已包含的层次结构
navigation.import.hierarchy.included.action.description=切换到已包含的层次结构
navigation.import.hierarchy.next.occurence=转到下一个文件
navigation.import.hierarchy.previous.occurence=转到上一个文件
navigation.goto.please.wait=请稍候…
navigation.goto.resolving.target=正在解析目标…
naming.convention.title=命名惯例
naming.convention.header.guard.style.help=您可以使用预定义变量，例如:<br><b>${PROJECT_NAME}</b>、 <b>${PROJECT_REL_PATH}</b>、 <b>${FILE_NAME}</b>、 <b>${EXT}</b> 和 <b>${UUID}</b>。<br>所有来自<i>编辑器/文件和代码模板</i> (<i>“文件”选项卡</i>)<br>的预定义变量也可用(例如 <b>${USER}</b>、<b>${DATE}</b> 等)
naming.convention.entity.kind=实体种类
naming.convention.visibility=可见性
naming.convention.specifier=说明符
naming.convention.entity.any=任意
naming.convention.entity.namespace=命名空间
naming.convention.entity.macro=宏
naming.convention.entity.class=类
naming.convention.entity.struct=结构
naming.convention.entity.enumeration=枚举
naming.convention.entity.union=联合
naming.convention.entity.typedef=Typedef
naming.convention.entity.global.function=全局函数
naming.convention.entity.global.variable=全局变量
naming.convention.entity.class.member.function=类成员函数
naming.convention.entity.struct.member.function=结构成员函数
naming.convention.entity.class.member.field=类成员字段
naming.convention.entity.struct.member.field=结构成员字段
naming.convention.entity.enumerator=枚举器
naming.convention.entity.parameter=形参
naming.convention.entity.local.variable=局部变量
naming.convention.prefix=前缀
naming.convention.suffix=后缀
refactoring.convertIvarUsagesToProperties=将 ivar 用法转换为属性(&C)
refactoring.ambiguous=不明确的函数无法被重构
title.function.return.type.group=函数返回类型之后
title.function.top.return.type=在全局和命名空间范围中
title.function.nontop.return.type=在类范围中
title.function.parameters.group=函数声明形参
title.function.call.arguments.group=函数调用实参
title.template.decl.class.group=模板类声明
title.template.decl.func.group=模板函数声明
title.template.parameters.group=模板声明形参
title.template.call.arguments.group=模板实例化实参
title.ctor.init.list.group=构造函数初始化列表
title.superclass.list.group=基类列表
title.shift.operators.group='<<', '>>' 运算符
title.capture.list.group=Lambda 捕获列表
wrapping.new.line.after.lt=在 '<' 后换行
wrapping.gt.on.new.line=将 '>' 置于新行中
wrapping.align.multiline.parentheses=对齐多行括号
wrapping.align.multiline.brackets=对齐多行中括号
wrapping.align.multiline.lt.gt=对齐多行 '<','>'
wrapping.keep.simple.case.inline=将简单 case 保持在同一行
wrapping.keep.simple.methods.in.one.line=简单函数在同一行
wrapping.keep.simple.methods.in.one.line.oc=简单方法和函数在同一行
wrapping.keep.simple.blocks.in.one.line=简单的 lambda 在同一行
wrapping.keep.simple.blocks.in.one.line.oc=简单块和 lambda 在同一行
wrapping.keep.nested.namespaces.in.one.line=将嵌套命名空间保持在同一行
wrapping.keep.directive.at.first.column=指令在第一列
wrapping.brace.placement.class.declaration=在类和结构中
wrapping.property.declaration.oc=@property 声明
wrapping.try.statement='try'语句
wrapping.catch.on.new.line='catch' 在新行
wrapping.array.initializer=初始值设定项列表
wrapping.array.initializer.oc=集合文字和初始值设定项列表
wrapping.align.multiline.fields.groups=变量组
wrapping.align.in.columns=列中对齐
wrapping.structures.in.one.line=类和结构在同一行
wrapping.before.brace.namespace=在命名空间中
wrapping.ternary.short.inline='a ?: b' 中的 '?:' 不换行
wrapping.try.statement.oc='@try' 语句
wrapping.catch.on.new.line.oc='@catch' 在新行
wrapping.finally.on.new.line.oc='@finally' 在新行
wrapping.array.initializer.lbrace.on.next.line.oc=在'{'、'[' 后换行
wrapping.array.initializer.rbrace.on.next.line.oc=将 '}'、']' 置于新行中
wrapping.method.brace.placement=在方法中
wrapping.function.brace.placement=在函数中
wrapping.block.brace.placement=在 lambda 中
wrapping.block.brace.placement.oc=在块和 lambda 中
wrapping.method.parameters.align.by.colons=通过冒号对齐
wrapping.method.call.arguments.special.dictionary.pairs.treatment=特殊 NSDictionary 初始化处理
wrapping.indent.template.body.if.wrapped=若换行则缩进模板主体
wrapping.new.line.after.colon=在 ':' 后换行
wrapping.new.line.before.colon=将 ':' 置于新行中
wrapping.new.line.never=从不
wrapping.new.line.always=始终
wrapping.new.line.if.long=如果过长
align.dictionary.values=对齐列中的字典值
align.init.list.values=对齐列中的初始值设定项列表值
space.within.empty.code.blocks=空代码大括号
space.within.template=在 <...> 内
space.within.empty.diamond=在空 <> 内
space.within.template.double.gt=在模板中防止 >> 串联
space.within.bracket=数组中括号
space.within.array.initializer.braces=初始值设定项列表大括号
space.within.array.empty.initializer.braces=空初始值设定项列表大括号
space.within.array.initializer.braces.oc=集合文字和初始值设定项列表大括号
space.within.array.empty.initializer.braces.oc=空集合文字和初始值设定项列表大括号
space.within.function.declaration.parentheses=函数声明圆括号
space.within.empty.function.declaration.parentheses=空函数声明括号
space.within.function.call.parentheses=函数调用圆括号
space.within.empty.function.call.parentheses=空函数调用括号
space.within.lambda.capture.list.brackets=Lambda 捕获列表中括号
space.within.empty.lambda.capture.list.brackets=空 lambda 捕获列表中括号
space.within.catch.parentheses.oc='@catch' 圆括号
space.within.synchronized.parentheses.oc='@synchronized' 括号
space.within.protocols.brackets.oc=协议列表中括号
space.within.property.attributes.parentheses.oc='@property' 特性括号
space.within.method.return.type.parentheses.oc=方法返回类型括号
space.within.method.parameter.type.parentheses.oc=方法形参类型括号
space.within.send.message.brackets.oc=发送消息中括号
space.within.template.declaration=在模板声明中
space.within.template.inst=在模板实例化中
space.within.class=在类/结构中
space.before.initialization.lists.colon=构造函数初始化列表冒号之前
space.after.initialization.lists.colon=构造函数初始化列表冒号之后
space.before.lt.template=在 '<' 前面
space.before.function.call.parentheses=函数调用圆括号
space.before.function.parentheses=函数声明圆括号
space.before.class.lbrace=类/结构左大括号
space.before.method.lbrace=函数左大括号
space.before.method.lbrace.oc=方法/函数左大括号
space.before.namespace.lbrace=命名空间左大括号
space.before.init.list.lbrace=初始值设定项列表左大括号
space.before.superclass.colon=基类冒号之前
space.before.pointer.in.declaration=声明中的 '*' 之前
space.before.reference.in.declaration=声明中的 '\\&' 之前
space.before.catch.parentheses.oc='@catch' 圆括号
space.before.try.lbrace.oc='@try' 左大括号
space.before.catch.lbrace.oc='@catch' 左大括号
space.before.finally.lbrace.oc='@finally' 左大括号
space.before.synchronized.lbrace.oc='@synchronized' 左大括号
space.before.catch.keyword.oc='@catch' 关键字
space.before.finally.keyword.oc='@finally' 关键字
space.before.synchronized.parentheses.oc='@synchronized' 括号
space.before.autorelease.pool.lbrace.oc='@autoreleasepool' 左大括号
space.before.category.parentheses.oc=类别括号之前
space.before.protocols.brackets.oc=协议列表中括号之前
space.before.chained.send.message.oc=链式消息发送之前
space.before.property.attributes.parentheses.oc='@property' 特性括号
space.before.dictionary.literal.colon=位字段中的冒号之前
space.before.dictionary.literal.colon.oc=字典文字 'key:value' 对中的冒号和位字段之前
space.after.superclass.colon=基类冒号之后
space.after.structures.rbrace=结构中的右大括号之后
space.after.pointer.in.declaration=声明中的 '*' 之后
space.after.reference.in.declaration=声明中的 '\\&' 之后
space.after.reference.in.rvalue=取消引用和 address-of 之后
space.after.method.return.type.parentheses.oc=方法返回类型括号之后
space.after.method.parameter.type.parentheses.oc=方法形参类型括号之后
space.after.visibility.sign.in.method.declaration.oc=方法声明中的 +/- 之后
space.after.colon.in.selector.oc=选择器中的冒号之后
space.after.cup.in.blocks.oc=块中的 '^' 之后
space.after.dictionary.literal.colon=位字段中的冒号之后
space.after.dictionary.literal.colon.oc=字典文字 'key:value' 对中的冒号和位字段之后
space.between.adjacent.brackets=在相同类型的中括号之间保持空格
space.between.operator.punctuator='operator' 关键字和标点符号之间
space.discharged.short.ternary.operator='?' 与 'a ? : b' 中的 ':' 之间空格
space.around.relational.operators=关系运算符 (<, >, <=, >=, <=>)
space.around.shift.operators=移位运算符 (<<, >>)
space.around.lambda.arrow='->' 在返回类型中
space.around.pm.operators=指针成员运算符(->、 .、->*、.*)
blank.lines.before.includes=包含之前:
blank.lines.after.includes=包含之后:
blank.lines.around.classes=类/结构周围:
blank.lines.after.class.header=类/结构头之后:
blank.lines.around.member.variable=环绕字段:
blank.lines.around.member.variable.oc=实例变量/字段周围:
blank.lines.around.global.variable=全局变量周围:
blank.lines.around.function.declaration=函数声明周围:
blank.lines.around.function.declaration.oc=方法/函数声明周围:
blank.lines.around.function.definition=函数定义周围:
blank.lines.around.function.definition.oc=方法/函数定义周围:
blank.lines.before.function.body=函数主体之前:
blank.lines.before.function.body.oc=方法/函数主体之前:
completion.press.keyboard.shortcut.for.all.methods.selectors=为所有方法选择器再次按 {0}
completion.press.keyboard.shortcut.to.filter.results.by.type=按 {0} 按类型筛选结果
completion.press.keyboard.shortcut.for.non.imported.symbols=为未导入的符号再次按 {0}
completion.press.keyboard.shortcut.for.global.symbols=为全局符号再次按 {0}
completion.press.shortcut.again.for.non.public.members=为非 public 成员 {1, choice, 0#|1#再次} 按 {0}
completion.press.shortcut.again.for.non.imported.members=为非导入的成员和 NSObject 类别的成员 {1, choice, 0#|1#再次}按 {0}
collapse.ivars=实例变量
collapse.synthesizes=合成语句
collapse.localized.strings=已本地化的字符串
collapse.multiline.comments=多行注释
collapse.block.expressions.oc=块和 lambda
collapse.block.expressions=Lambda
collapse.conditionally.non-compiled=有条件的未编译代码
collapse.template.param.list=模板形参
collapse.new.line.before.lbrace=如果收起，则在 '{' 之前用空格代替换行
color.this.keywords='this' 关键字
color.preprocessor.directive=预处理程序//指令
color.preprocessor.path=预处理程序//头路径
color.format.string.token=字符串实参中的格式说明符
color.conditionally.non-compiled=有条件的未编译代码
color.macro.name=宏名称
color.macro.parameter=宏形参
color.global.variable=全局变量
color.extern.variable=extern 变量
color.struct.union.oc=结构/枚举/联合
color.struct.union=类/结构/枚举/联合
color.struct.field=结构字段
color.concept=概念
color.template.type=模板类型
color.template.value=模板值
color.namespace=命名空间
color.enum.const=枚举常量
color.function.declaration=函数声明
color.function.call=函数调用
color.overloaded.operator=大括号和运算符//重载运算符
color.typedef=Typedef
color.label=标签
color.dependent_code=依赖代码
color.deduction_guide=推导指南
color.this.keywords.oc='self'、'super'、'this' 关键字
color.instance.variable.oc=实例变量
color.method.declaration.oc=方法声明
color.method.call.oc=方法调用
color.property.oc=属性
color.property.attribute.oc=属性特性
color.class.reference.oc=类
color.protocol.reference.oc=协议
color.generic.parameter.oc=泛型形参
indent.namespace=缩进命名空间成员
indent.interface.protocol=缩进 '@interface' 和 '@protocol' 成员
indent.not.ivar=实例变量列表除外
indent.implementation=缩进 '@implementation' 成员
indent.visibility.keywords=缩进类/结构中的可见性关键字
indent.block=在 lambda 中缩进
indent.block.oc=在块和 lambda 中缩进
indent.c.struct=缩进纯结构成员和枚举
indent.class=缩进类成员
indent.class.oc=缩进 C++ 类成员
indent.preprocessor.directive=预处理程序指令缩进
indent.preprocessor.directive.as.code=遵循代码缩进
#indent.preprocessor.directive.after.hash=Indent after #
inline.handler.check.for.validness=正在验证…
checkbox.block.comment.indent=在块注释中缩进新行
override.implement.show.no.optional.members=显示可选成员(无可选项)
override.implement.show.only.optional.members=显示可选成员(仅可选项)
override.implement.show.no.synthesized.accessors=显示合成访问器(无访问器)
override.implement.show.only.synthesized.accessors=显示合成访问器(仅访问器)
override.implement.cpp.action.title=重写/实现函数
override.implement.cpp.action.name=重写函数…
override.implement.cpp.action.memberChooserTitle=选择要重写/实现的函数
override.implement.cpp.action.noMember={0} 没有要重写/实现的函数
override.implement.cpp.action.noParent=没有要重写/实现的函数
override.implement.cpp.action.insertOverride=插入“override”特性(&I)
override.implement.cpp.action.showNonVirtual=显示非虚拟函数(&N)
override.implement.cpp.action.insertVirtualWithOverride=将“virtual”特性与“override”一起插入
implement.cpp.action.name=实现函数…
implement.cpp.action.memberChooserTitle=选择要实现的函数
implement.cpp.action.noMember={0} 没有要实现的函数
implement.cpp.action.noParent=没有要实现的函数
changeSignature.usages.cantBeUnnamed=形参 {0} 已被使用，不能取消命名
changeSignature.usages.cantBeRemoved=形参 {0} 已被使用，不能移除
changeSignature.usages.cantConvertSelectorToFuncBlock=无法将选择器表达式转换为函数/块
changeSignature.usages.cantConvertToBlock=无法转换为块:
changeSignature.usages.cantConvertLanguage=无法转换 {0} 代码中的用法
#changeSignature.usages.ambiguousReference=Function {0} is ambiguously referenced
changeSignature.usages.noUsagesFound=找不到用法
changeSignature.usages.moreThan1Found=找到超过 1 个用法
changeSignature.usages.usageInsideFunction=用法在函数/方法内部
changeSignature.usages.functionHasSeveralDefinitions=函数 ''{0}'' 具有多个定义
changeSignature.usages.atLeasTwoParams=至少两个形参的名称为 ''{0}''
changeSignature.usages.conflictsWithNewParameter={0} 与新形参冲突
changeSignature.usages.unrelatedSelector=可能不相关的同名选择器将被重命名
changeSignature.usages.willConflictWith={0} 将与 {1} 冲突
changeSignature.usages.willConflictWithMethod={0} 将与 {1} 中的方法冲突
changeSignature.targetNotFound=文本光标应置于函数、方法或块处
changeSignature.dialog.containing.class=包含类:
changeSignature.dialog.callable.type=可调用类型:
changeSignature.parameter.selector.part=选择器部分:
rename.renameAssociatedFiles=同时重命名关联的文件?
rename.renameContainingFile=同时重命名包含文件?
rename.renameAssociatedClass=同时重命名关联的类/结构
find.existing.operators.progress.title=正在搜索现有的运算符
generate.definitions.intention.familyName=生成定义
generate.definitions.intention.outsideText=生成定义
generate.definitions.intention.inlineText=就地生成定义
generate.definitions.action.name=生成定义…
generate.definitions.action.title=生成定义
generate.definitions.action.memberChooserTitle=选择要为其生成定义的函数
generate.definitions.action.noParent=没有要为其生成定义的函数
generate.definitions.action.noMembers={0} 没有要为其生成定义的函数
generate.definitions.quickfix.inlineText=就地为 {0} 生成定义
generate.definitions.quickfix.outsideText=为 {0} 生成定义
generate.definitions.progress.text=正在查找现有定义…
generate.comparison.operators.action.title=生成比较运算符
generate.comparison.operators.action.title.eq=生成相等运算符
generate.comparison.operators.action.title.rel=生成关系运算符
generate.comparison.operators.member.chooser.title=选择要使用的字段
generate.comparison.operators.as.member.option=作为类成员生成(&M)
generate.comparison.operators.use.std.tie=使用 std::&tie
generate.comparison.operators.additional.eq.option=将 != 与 == 一起生成(&W)
generate.comparison.operators.additional.eq.option.desc=将 != 与 == 一起生成
generate.comparison.operators.additional.rel.option=将 >、<=、>= 与 < 一起生成(&W)
generate.comparison.operators.additional.rel.option.desc=将 >、<=、>= 与 < 一起生成
generate.comparison.operators.usages.all.defined=所有运算符均已定义。
generate.comparison.operators.usages.some.defined=部分运算符已定义。
generate.comparison.operators.usages.existing.text=现有运算符
generate.getter.add.prefix=将 get/is 前缀添加到 getter
generate.setter.add.prefix=将 set 前缀添加到 setter
generate.stream.output.action.title=生成流输出运算符
generate.stream.output.member.chooser.title=选择要使用的字段
generate.stream.output.usages.all.defined=流输出运算符已定义
generate.stream.output.usages.existing.text=现有运算符
generate.configurable.retain.parameters=在 initWith 中保留对象形参…
generate.configurable.use.property.setters=在 initWith 中使用属性 setter…
generate.configurable.put.ivars=尽可能将 ivars 放入实现
generate.configurable.semicolon.after.method=实现中方法签名后的分号
generate.configurable.use.nsinteger.and.cgfloat=在引入变量中使用 NSInteger 和 CGFloat
generate.configurable.instance.variable.prefix=实例变量的前缀:
generate.configurable.instance.variable.suffix=实例变量的后缀:
generate.configurable.add.brief.tag=添加 @brief 标记
generate.configurable.const.volatile.placement=const/volatile 限定符位置
generate.configurable.top.level.declarations.order=顶层声明顺序
generate.configurable.ivars.release.style=Ivars 释放样式(对于 'dealloc')
generate.configurable.ivars.generation=为属性生成 ivar 声明
generate.configurable.ivars.generation.always=始终生成
generate.configurable.ivars.generation.never=从不生成
generate.configurable.ivars.generation.ask=询问
generate.configurable.tag.prefix.comments=行注释中的标记前缀
generate.configuralble.tag.prefix.block.comments=块注释中的标记前缀
generate.configurable.documentation.title=文档注释
inspections.templateArguments.tooFew=模板实参过少，应为 {0} 个
inspections.templateArguments.tooFewAtLeast=模板实参过少，应为至少 {0} 个
inspections.templateArguments.tooMany=模板实参过多，应为 {0} 个
inspections.templateArguments.tooManyAtMost=模板实参过多，应为至多 {0} 个
inspections.templateArguments.valueInsteadOfType=应为值而不是类型
inspections.templateArguments.typeInsteadOfValue=应为类型而不是值
inspections.typeChecks.volatileConflict=正在将非 volatile 结构分配至 volatile 结构
inspections.duplicate.explicitInstantiation=重复的显式实例化
inspections.typeChecks.neitherNumericNorPointer=类型 ''{0}'' 的表达式既不是数字也不是指针
inspections.typeChecks.notNumeric=类型 ''{0}'' 的表达式不是数字
inspections.fileChecks.outOfProject=此文件不属于任何项目目标；代码洞察功能可能无法正常工作。
inspections.fileChecks.allContextsUnloaded=编制索引已对此目标的所有可用解析上下文禁用；代码洞察功能可能无法正常工作。
inspections.fileChecks.sourceTooLarge=文件大小({0})超出了为 {1} 配置的限制({2})。代码洞察功能不可用。
inspections.fileChecks.headerTooLarge=文件包含长度({0})超出为 {1} 配置的限制({2})的内联头({3})。头未解析。
inspections.fileChecks.headerTooLargePlatform=文件包含长度({0})超出配置限制({1})的内联头({2})。头未解析。
checkbox.allow.import.in.completion=在补全中自动导入
group.option.predefine=在 .m 内的 .h/Import 中预声明 
group.option.import=在 .h 中导入
progressbar.long.resolve.description=解析操作需要更多时间…\n如果您取消，则依赖于解析的编辑器操作将不可用
action.invalid.title=无效
change.signature.convert.action=选择要转换为{0}的实现
header.source.looking.for.the.best.file=正在查找关联文件
resolve.contexts.select.automatically=自动选择
oc.inlay.hints.blacklist.pattern.explanation=<html> 要禁用方法的提示，请使用相应模式: <p> <code><b>(*info)<b></code> - 形参名称以 info 结尾的单形参方法<br> <code><b>(key, value)<b></code> - 具有形参键和值的方法<br> <code><b>*::put(key, value)<b></code> - 具有键和值形参的 put 方法<br> </p> </html>
oc.inlay.hints.show.hints.for.enum.constants=显示枚举常量提示
oc.inlay.hints.show.hints.for.constructors=显示构造函数表达式提示
oc.inlay.hints.show.amp.nonconst.references=为非常量引用显示 '\\&'
include.cpp.message='#include <C++>' 一个面向对 C++ 感兴趣的开发者的全球性、包容性和多元化社区
include.cpp.url=https://www.includecpp.org/
include.cpp.intention.text=了解详情
usage.properties.search.message.delete=也要删除 {0} 吗?
usage.properties.search.message.find.usages=也要查找 {0} 的用法吗?
usage.properties.search.title=属性搜索
usage.instance.variables.search.message.delete=也要删除 {0} 吗?
usage.instance.variables.search.message.find.usages=也要查找 {0} 的用法吗?
usage.instance.variables.search.title=实例变量搜索
usage.method.search.title=方法搜索
usage.method.search.message.delete={0}\n\n要删除基{1}吗?
usage.method.search.message.find.usages={0}\n\n要查找基{1}的用法吗?
usage.delete.out.of.project.title=警告
usage.delete.out.of.project.message={0} 要继续执行重构吗?
usage.overrides.message={0} 重写 {2} 中的 {1}。
usage.overrides.out.of.project.message={0} 重写项目外的 {2} 中的 {1}。
usage.include.property.checkbox.text=包含 {0}
usage.include.ivar.checkbox.text=包含 {0}
usage.include.derived.classes.checkbox.text=包含派生类
switch.header.source.popup.title=转到头/源
switch.header.source.no.results=无相关文件
command.line.parser.unknown.exception=命令行解析期间出错
command.line.parser.cancellation.exception=命令行解析被中断
command.line.parser.invalid.exception=无法解析命令行:\n{0}\n选项 #{1} 中出错: ''{2}''
configurable.OCGenerateCodeConfigurable.display.name=代码生成
abstract.extract.dialog.class.name={0} 名称:
abstract.extract.dialog.unable.create.file=无法创建文件
browse.include.hierarchy.action=导入层次结构
escalate.visibility=升级可见性
escalate.visibility.description=是否要升级以下成员的可见性?
dump.file.symbol.stats=文件符号统计信息
dump.symbol.stats=符号统计信息
highlighter.change.file.length.limit=更改最大文件长度
highlighter.change.file.length.limit.input=以字符为单位输入 {0} 文件的新最大长度
highlighter.max.file.length.title=最大文件长度
if.responds.to.surround.error.hint=所选代码中没有发送消息表达式
quickfixes.implement.missing.getter=实现缺少的 getter 方法
quickfixes.implement.missing.setter=实现缺少的 setter 方法
quickfixes.import.symbol=导入符号
quickfixes.make.function.virtual=使函数为虚拟
quickfixes.make.property.dynamic=使 {0} 为 @dynamic
quickfixes.synthesize=合成{0}
move.dialog.move.members.to.class=将成员移至类(现有或新的):
move.dialog.move.declarations.to.file=将声明移至文件(现有或新的):
move.dialog.put.to.namespace=置于命名空间(现有或新的):
move.dialog.move.declarations=移动声明
move.dialog.destination=目标:
move.dialog.target.file.does.not.exist=目标文件 ''{0}'' 尚不存在。
move.dialog.create.new.file=创建新文件
move.dialog.create.new.class=创建新类
move.processor.skip=跳过
push.down.members.dialog=将{0}的成员下推至:
push.down.dialog.searching.inheritors=搜索继承者
resolve.show.related.contexts=仅显示相关上下文
resolve.show.all.contexts=显示所有上下文…
symbol.table.activity.building.symbols=正在构建符号…
symbol.table.activity.loading.symbols=正在加载符号…
symbol.table.activity.updating.symbols=正在更新符号…
symbol.table.activity.loading.header.maps=正在加载标头映射…
symbol.table.dump.stats.action=统计信息写入{0}
# action names
action.CIDR.DebugDumpBuildingSymbols.text=C/C++: 转储符号构建状态
action.CIDR.Lang.Format.Extractor.text=提取代码格式
action.CIDR.Lang.DropPsiForOpenedFiles.text=删除打开的文件的 PSI
action.CIDR.Lang.RemoveBodiesAndComments.text=移除函数主体和注释
action.CIDR.Lang.DumpFileSymbolStats.text=转储文件符号统计信息
action.CIDR.Lang.DumpSymbolStats.text=转储常规符号统计信息
action.CIDR.Lang.CompactSymbols.text=更新/压缩符号
action.CIDR.Lang.ImportsHierarchy.text=导入层次结构
action.CIDR.Lang.ObjC.GenerateSharedInstance.text=+sharedInstance
action.CIDR.Lang.ObjC.GenerateSharedInstance.description=生成共享实例
action.CIDR.Lang.ObjC.GenerateDescription.text=-description…
action.CIDR.Lang.ObjC.GenerateDescription.description=从类成员生成 -description
action.CIDR.Lang.ObjC.GenerateIsEqualAndHash.text=-isEqual: 和 -hash…
action.CIDR.Lang.ObjC.GenerateIsEqualAndHash.description=从类成员生成 -isEqual: 和 -hash
action.CIDR.Lang.ObjC.GenerateCopy.text=-copyWithZone:…
action.CIDR.Lang.ObjC.GenerateCopy.description=从类成员生成 -copyWithZone:
action.CIDR.Lang.ObjC.GenerateEncode.text=-init/encodeWithCoder:…
action.CIDR.Lang.ObjC.GenerateEncode.description=从类成员生成 -encodeWithCoder: 和 initWithCoder:
action.CIDR.Lang.ObjC.GenerateInitWith.text=-initWith…
action.CIDR.Lang.ObjC.GenerateInitWith.description=从类成员生成 -initWith…
action.CIDR.Lang.Cpp.GenerateDefinitions.text=生成定义…
action.CIDR.Lang.Cpp.GenerateDefinitions.description=生成定义
action.CIDR.Lang.Cpp.GenerateStreamOutputOperator.text=流输出运算符
action.CIDR.Lang.Cpp.GenerateStreamOutputOperator.description=生成流输出运算符
action.CIDR.Lang.Cpp.GenerateRelationalOperators.text=关系运算符
action.CIDR.Lang.Cpp.GenerateRelationalOperators.description=生成关系运算符
action.CIDR.Lang.Cpp.GenerateEqualityOperators.text=相等运算符
action.CIDR.Lang.Cpp.GenerateEqualityOperators.description=生成相等运算符
action.CIDR.Lang.Cpp.GenerateGetterAndSetter.text=Getter 和 Setter
action.CIDR.Lang.Cpp.GenerateGetterAndSetter.description=为字段生成 getter 和 setter 函数
action.CIDR.Lang.Cpp.GenerateSetter.text=Setter
action.CIDR.Lang.Cpp.GenerateSetter.description=为字段生成 setter 函数
action.CIDR.Lang.Cpp.GenerateGetter.text=Getter
action.CIDR.Lang.Cpp.GenerateGetter.description=为字段生成 getter 函数
action.CIDR.Lang.Cpp.GenerateDestructor.text=析构函数
action.CIDR.Lang.Cpp.GenerateDestructor.description=生成析构函数
action.CIDR.Lang.Cpp.GenerateConstructor.text=构造函数
action.CIDR.Lang.Cpp.GenerateConstructor.description=从类成员生成构造函数
action.CIDR.Lang.ObjC.Synthesize.text=@synthesize…
action.CIDR.Lang.ObjC.Synthesize.description=生成合成变量和实例变量(可选)
action.CIDR.Lang.ObjC.DeclareMembers.text=声明成员…
action.CIDR.Lang.ObjC.DeclareMembers.description=声明接口或私有类别中的类成员
action.CIDR.Lang.ObjC.ConvertToIvar.text=转换为实例变量…
action.CIDR.Lang.ObjC.ConvertToIvar.description=将属性转换为实例变量
action.CIDR.Lang.ObjC.ConvertToProperty.text=转换为属性…
action.CIDR.Lang.ObjC.ConvertToProperty.description=将实例变量转换为属性
action.CIDR.Lang.ObjC.ConvertToBlock.text=转换为块…
action.CIDR.Lang.ObjC.ConvertToBlock.description=转换为块
action.CIDR.Lang.ObjC.ConvertToFunction.text=转换为函数…
action.CIDR.Lang.ObjC.ConvertToFunction.description=转换为函数
action.CIDR.Lang.ObjC.ConvertToMethod.text=转换为方法…
action.CIDR.Lang.ObjC.ConvertToMethod.description=转换为方法
action.CIDR.Lang.ObjC.ExtractCategory.text=类别…
action.CIDR.Lang.ObjC.ExtractCategory.description=将成员提取到新类别
action.CIDR.Lang.ObjC.ExtractProtocol.text=协议…
action.CIDR.Lang.ObjC.ExtractProtocol.description=将成员提取到新协议
action.CIDR.Lang.ObjC.ExtractSubclass.text=子类…
action.CIDR.Lang.ObjC.ExtractSubclass.description=将成员提取到新子类
action.CIDR.Lang.ObjC.ExtractBlock.text=块形参…
action.CIDR.Lang.ObjC.ExtractBlock.description=提取块形参
action.CIDR.Lang.Cpp.ExtractLambda.text=Lambda 形参…
action.CIDR.Lang.Cpp.ExtractLambda.description=提取 Lambda 形参
action.CIDR.Lang.IntroduceTypedef.text=Typedef…
action.CIDR.Lang.IntroduceTypedef.description=引入 Typedef
action.CIDR.Lang.IntroduceDefine.text=定义…
action.CIDR.Lang.IntroduceDefine.description=引入 Define
action.CIDR.Lang.IntroduceParameter.text=形参…
action.CIDR.Lang.IntroduceParameter.description=引入形参
action.CIDR.Lang.ObjC.IntroduceProperty.text=属性…
action.CIDR.Lang.ObjC.IntroduceProperty.description=引入属性
action.CIDR.Lang.ObjC.IntroduceIvar.text=实例变量…
action.CIDR.Lang.ObjC.IntroduceIvar.description=引入实例变量
action.CIDR.Lang.IntroduceConstant.text=常量…
action.CIDR.Lang.IntroduceConstant.description=引入常量
action.CIDR.Lang.IntroduceVariable.text=变量…
action.CIDR.Lang.IntroduceVariable.description=引入变量
action.CIDR.Lang.SwitchHeaderSourceDebug.text=调试头/源
action.CIDR.Lang.SwitchHeaderSource.text=头文件/源码
action.CIDR.Lang.Wrap.By.Pragma.Region=#pragma region...endregion
action.CIDR.Lang.goto.definition.declaration=转到定义/声明
action.CIDR.Lang.goto.super.definition=超定义(&U)
action.CIDR.Lang.goto.definition=定义(&E)
loading.module.maps=正在加载模块映射…
saving.module.maps=正在保存模块映射…
building.module.maps=正在构建模块映射…
processing.module.maps=正在处理模块映射…
loading.headers.search.roots=正在加载标头搜索根…
goto.definition.settings.title=前往声明或用法
goto.definition.settings.toggle.assoc.title=对包含预声明的符号调用时:
goto.definition.settings.toggle.assoc.on=跳转到预声明
goto.definition.settings.toggle.assoc.off=显示用法弹出窗口
goto.symbol=转到
goto.symbol.ellipsis=转到…
goto.related.symbol.name1=转到定义
goto.related.symbol.name2=转到 ''{1}'' 的{0}
goto.related.symbol.name3=转到{0}的预定义
goto.related.symbol.name4=转到{0}的定义
goto.related.symbol.name5=转到{0}的声明
goto.related.symbol.name6=转到相关{0}
goto.super.type.name1=转到{1}中的父{0}
goto.super.type.name2=转到{0}中的基函数
goto.super.type.name3=转到父类型
goto.subclass=转到子类
goto.overridden=转到被重写的{0}…
goto.overridden.methods=转到被重写的方法…
goto.overridden.functions=转到被重写的函数…
saving.symbols=正在保存符号…
progress.text.updating.symbols=正在更新符号…
inspection.message.function.not.implemented={0} 未实现
command.name.add.parameter.to.constructor=将形参添加到构造函数
dialog.title.select.constructor.to.update=选择要更新的构造函数
command.name.add.parameter.to.initwith=将形参添加到 'initWith…'
dialog.title.select.initwith.method.to.update=选择要更新的 'initWith…' 方法
dialog.message.objc.do.you.want.to.generate.instance.variables.for.chosen.properties=要为所选属性生成实例变量吗?
dialog.title.objc.generate.instance.variables=生成实例变量
dialog.message.do.you.want.to.move.class.member.definitions=要移动类成员定义吗?
dialog.title.move.refactoring.adding.imports=正在添加 import
filetype.asm.description=程序集语言文件
filetype.qt.ui.designer.form.description=Qt UI Designer 表单
statement.name=语句
expression.name=表达式
declaration.name=声明

surround.with.block.expression.template=^{ return expr; }
surround.with.do.while.template=do / while
surround.with.for.template=for
surround.with.while.template=while
surround.with.if.else.template=if / else
surround.with.if.template=if
surround.with.not.expr.template=!(expr)
surround.with.parenthesis.template=(expr)
surround.with.if.respondsToSelector.template=if respondsToSelector
refactoring.dialog.no.target.file.selected=未选择目标文件
refactoring.dialog.file.name.invalid=文件名无效
refactoring.dialog.file.not.located.inside.project=文件“{0}”不在项目内部
refactoring.dialog.source.and.target.should.be.different=源和目标应该不同
refactoring.dialog.target.namespace.name.invalid=目标命名空间名称无效
refactoring.dialog.target.ns.is.part.of.qualified.ns=目标命名空间是限定命名空间的一部分
refactoring.dialog.can.t.move.to.itself=无法将 {0} 移至自身
inspection.name.is.never.used={0} 从未使用

element.description.provider.symbol.of.parent={1} 的 {0}
element.description.provider.predefinition.of={0} 的预定义

qdoc.definition=定义:
qdoc.declared.in=声明位置:
qdoc.replacement=替换:
qdoc.description.copied.from=描述复制自:

formatter.item.allman.braces=Allman 大括号
formatter.item.kr.braces=K\\&R 大括号
formatter.item.whitesmiths.braces=Whitesmiths 大括号
formatter.item.stroustrup.braces=Stroustrup
formatter.title.code.generation=代码生成

settings.title.objective.c.class.order=Objective-C 类顺序
settings.prefix.must.start.with.letter.or.symbol=前缀必须以字母或 '_' 符号开头
settings.hint.choice.prefix.suffix.must.contain.only.letters.or.digits.or.symbols={0, choice, 0#前缀|1#后缀}必须只包含字母或数字或 '_' 符号
settings.title.naming.convention=命名惯例
settings.naming.convention=命名惯例
resolve.contexts.all.contexts=已列出所有项目上下文
resolve.contexts.available=可用解析上下文
resolve.contexts.current.file=当前 {0} 文件在 ''{1}'' 的上下文中解析
resolve.contexts.file.resolved.in=此文件将在所选上下文中解析
resolve.contexts.loading=正在加载解析上下文…
resolve.contexts.name=解析上下文
resolve.contexts.no.context=<无上下文>
resolve.contexts.prefix.no.context=当前文件无解析上下文
resolve.contexts.prefix=上下文
resolve.contexts.unindexed.contexts=未索引的上下文
hmap.description={0} 头映射

search.scope.project.source.files=项目源文件
search.scope.project.non.source.files=项目非源文件

header.search.root.custom.headers=自定义头
header.search.root.frameworks=框架
header.search.root.explicit.frameworks=显式框架

find.usages.unknown.type=未知

switch.header.source.separator.headers=头
switch.header.source.separator.sources=源
new.definition.dialog.title.create.new.constructor=创建新构造函数
new.definition.dialog.title.create.new.function=创建新函数
new.definition.button.create=创建
new.definition.dialog.title.create.new.method=创建新方法
action.context.file.name=文件 ''{0}''
oc.declare.members.implementation.undeclared=实现(未声明)
dialog.message.some.members.are.defined=部分已定义
dialog.message.all.members.are.defined=全部均已定义
tab.title.existing=现有
label.copy.depth=深度
copy.depths.option.deep=深层
copy.depths.option.shallow=浅层
button.generate=生成
other.categories.and.inherited.members=其他类别和继承的成员
action.show.inherited.text=显示继承项
action.show.inherited.members.members.in.other.categories.description=显示继承的成员和其他类别的成员
polymorphic.call=(多态调用)
label.or.in.objective.c.code=或在 Objective-C 代码中

symbol.kind.name.uppercase.type=类型
symbol.kind.name.uppercase.enum.constant=枚举常量
symbol.kind.name.uppercase.field=字段
symbol.kind.name.uppercase.function=函数
symbol.kind.name.uppercase.constructor=构造函数
symbol.kind.name.uppercase.parameter=形参
symbol.kind.name.uppercase.global.variable=全局变量
symbol.kind.name.uppercase.built.in.symbol=内置符号
symbol.kind.name.uppercase.local.variable=局部变量
symbol.kind.name.uppercase.exception.variable=异常变量
symbol.kind.name.uppercase.implementation=实现
symbol.kind.name.uppercase.instance.variable=实例变量
symbol.kind.name.uppercase.interface=接口
symbol.kind.name.uppercase.label=标签
symbol.kind.name.uppercase.macro=宏
symbol.kind.name.uppercase.macro.parameter=宏形参
symbol.kind.name.uppercase.import=导入
symbol.kind.name.uppercase.compatibility.alias=兼容性别名
symbol.kind.name.uppercase.method1=方法
symbol.kind.name.uppercase.block=块
symbol.kind.name.uppercase.lambda=Lambda
symbol.kind.name.uppercase.property=属性
symbol.kind.name.uppercase.synthesize.statement=合成语句
symbol.kind.name.uppercase.protocol=协议
symbol.kind.name.uppercase.struct=结构
symbol.kind.name.uppercase.union=联合
symbol.kind.name.uppercase.enum=枚举
symbol.kind.name.uppercase.namespace=命名空间
symbol.kind.name.uppercase.type.parameter=类型形参
symbol.kind.name.uppercase.template.parameter=模板形参
symbol.kind.name.uppercase.using=Using
symbol.kind.name.uppercase.localized.string=已本地化的字符串
symbol.kind.name.uppercase.expression=表达式
symbol.kind.name.uppercase.generic.parameter=泛型形参
symbol.kind.name.uppercase.concept=概念
symbol.kind.name.uppercase.keyword=关键字
symbol.kind.name.uppercase.file=文件
symbol.kind.name.uppercase.folder=文件夹
symbol.kind.name.uppercase.default=符号

symbol.kind.name.lowercase.type=类型
symbol.kind.name.lowercase.enum.constant=枚举常量
symbol.kind.name.lowercase.field=字段
symbol.kind.name.lowercase.function=函数
symbol.kind.name.lowercase.constructor=构造函数
symbol.kind.name.lowercase.parameter=形参
symbol.kind.name.lowercase.global.variable=全局变量
symbol.kind.name.lowercase.built.in.symbol=内置符号
symbol.kind.name.lowercase.local.variable=局部变量
symbol.kind.name.lowercase.exception.variable=异常变量
symbol.kind.name.lowercase.implementation=实现
symbol.kind.name.lowercase.instance.variable=实例变量
symbol.kind.name.lowercase.interface=接口
symbol.kind.name.lowercase.label=标签
symbol.kind.name.lowercase.macro=宏
symbol.kind.name.lowercase.macro.parameter=宏形参
symbol.kind.name.lowercase.import=导入
symbol.kind.name.lowercase.compatibility.alias=兼容性别名
symbol.kind.name.lowercase.method1=方法
symbol.kind.name.lowercase.block=块
symbol.kind.name.lowercase.lambda=lambda
symbol.kind.name.lowercase.property=属性
symbol.kind.name.lowercase.synthesize.statement=合成语句
symbol.kind.name.lowercase.protocol=协议
symbol.kind.name.lowercase.struct=struct
symbol.kind.name.lowercase.union=联合
symbol.kind.name.lowercase.enum=枚举
symbol.kind.name.lowercase.namespace=命名空间
symbol.kind.name.lowercase.type.parameter=类型形参
symbol.kind.name.lowercase.template.parameter=模板形参
symbol.kind.name.lowercase.using=using
symbol.kind.name.lowercase.localized.string=已本地化的字符串
symbol.kind.name.lowercase.expression=表达式
symbol.kind.name.lowercase.generic.parameter=泛型形参
symbol.kind.name.lowercase.concept=概念
symbol.kind.name.lowercase.keyword=关键字
symbol.kind.name.lowercase.file=文件
symbol.kind.name.lowercase.folder=文件夹
symbol.kind.name.lowercase.default=符号
command.name.codestylesettings.extractor=代码样式设置提取程序
symbol.kind.name.uppercase.destructor=析构函数
symbol.kind.name.uppercase.class=类
symbol.kind.name.lowercase.destructor=析构函数
symbol.kind.name.lowercase.class=类
popup.title.element.found.singular={0} (已找到 {1} 元素)
popup.title.elements.found.plural={0} (已找到 {1} 元素)

resource.language.unknown=未知

color.doxygen.comment=注释//Doxygen//文本
color.doxygen.tag=注释//Doxygen//标记
color.doxygen.tag.value=注释//Doxygen//标记值
oc.inlay.hints.type.name=类型
oc.inlay.hints.type.for.variables=变量类型
oc.inlay.hints.type.for.lambdas=Lambda 类型
oc.inlay.hints.type.deduced.return.types=推导的返回类型
oc.inlay.hints.type.main.checkbox=显示类型提示:
completion.no.suggestions.press.for.not.imported=无建议，对于未导入的成员按 {0}
color.std.initializer.list.oc=大括号和运算符//初始值设定项列表
action.CIDR.Lang.goto.definition.declaration.tooltip=转到定义/声明
goto.related.symbol.name1.tooltip=转到定义
goto.related.symbol.name2.tooltip=转到 ''{1}'' 的{0}
goto.related.symbol.name3.tooltip=转到 {0} 的预定义
goto.related.symbol.name4.tooltip=转到 {0} 的定义
goto.related.symbol.name5.tooltip=转到 {0} 的声明
goto.related.symbol.name6.tooltip=转到相关 {0}
goto.subclass.title=转到子类
goto.overridden.title=转到被重写的{0}
goto.overridden.methods.title=转到被重写的方法
goto.overridden.functions.title=转到被重写的函数
oc.inlay.hints.show.settings=提示设置…
cache.downloader.updating.title=更新缓存
cache.downloader.not.now.option=以后再说
cache.downloader.download.option=下载
cache.downloader.always.download.option=始终下载
oc.inlay.hints.type.obvious.types=明显类型
checkbox.local.files.with.quotes=使用引号自动导入本地文件
popup.title.element.found.so.far.singular={0} (目前已找到 {1} 个元素)
popup.title.elements.found.so.far.plural={0} (目前已找到 {1} 个元素)
space.before.colon.in.foreach='for' 冒号之前
space.after.colon.in.foreach='for' 冒号之后
action.CIDR.Lang.QualifiedNames.text=显示限定名称
action.CIDR.Lang.QualifiedNames.description=显示限定名称
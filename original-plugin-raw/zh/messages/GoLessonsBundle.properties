go.apply.fix=选择 {0} 并按 {1}。
go.basic.and.smart.type.completion.difference.basic=要调用基本补全，您还可以按 {0}。\n按 {0}，查看建议列表，然后选择“{1}”。
go.basic.and.smart.type.completion.difference.smart=我们需要返回一个指针，但基本补全提示没有指针。在这种情况下，智能类型匹配代码补全可能会有所帮助。它会筛选建议列表并仅显示适用于当前上下文的类型。\n按 {0} 调用智能补全，从列表中选择“{1}”，然后按 {2} 替换当前值。
go.basic.and.smart.type.completion.goto.next.error=所选建议会在文件中高亮显示为错误，按 {0} 可了解原因。
go.basic.and.smart.type.completion.name=基本和智能类型补全
go.basic.and.smart.type.completion.type.and.choose=默认情况下，<ide/> 会立即补全您的代码。在文本光标所在的位置开始输入 {0}，您将看到带有匹配建议的弹出列表。您可以按 {2} 从列表中选择“{1}”。
go.basic.completion.invoke.completion=请注意，<ide/> 会自动插入一个新的导入。接下来，按 {0} 激活基本补全，选择 {1}，然后按 {2}。
go.basic.completion.lesson.name=基本补全
go.check.sdk.version=要尝试本课程，您需要 Go {0}。您可以在设置中进行设置或下载。有关安装 Go SDK 的详细信息，请参阅 <a href\="https\://www.jetbrains.com/help/go/create-new-go-project.html\#installing-go-sdk">GoLand 文档中的说明</a>。
go.choose.name=按 {0} 完成重构。
go.code.completion.module.name=代码补全
go.comment.navigation.lesson.name=注释中的声明
go.comment.navigation.task={0} 软件包并不大，我们可以在其中轻松导航。但是某些软件包可能非常庞大，其中会包含数百个代码和注释行。\n在 IDE 中，如果这些声明在同一软件包内，那么您可以从注释转到声明。注释中，这些方法、函数和结构的名称的颜色略有不同。类似于第 32 行注释部分中的 {1} 函数。\n要从该注释导航到函数声明，请先将文本光标放在注释中的函数名称处，然后按 {2}。
go.comments.comment.block=您可以注释掉代码块。例如，注释掉选定的块，然后按 {0}。
go.comments.comment.one.line=使用 {0} 注释掉任意一行。
go.comments.lesson.name=添加和移除注释
go.comments.uncomment.block=取消注释代码块。再次按 {0}。
go.comments.uncomment.line=撤消对使用相同快捷键 {0} 注释过的行的注释。
go.completion.for.functions.choose.item=从列表选择闪烁的 {0} 函数，然后按 {1}。当您看到建议列表时，即可开始输入，以减少结果数量。
go.completion.for.functions.press.twice=现在，输入一个点({0})并按<strong>两次</strong> {1}。在这种情况下，IDE 会查找所有接受字符串作为第一个实参的函数。请注意，点使它看起来像一个方法，但实际上不是。
go.debug.function.calls.add.arguments.for.evaluation=在括号内，键入 {0}。该字段必须显示 {1}。
go.debug.function.calls.click.evaluate=点击“{0}”或按 {1}。随后您可以关闭对话框。
go.debug.function.calls.enter.expression.to.evaluate=在 {0} 字段中，开始键入 {1}，从建议列表中选择 {2}。
go.debug.function.calls.evaluate.expression=按 {1} 调用 {0} 操作。
go.debug.function.calls.lesson.name=调试函数调用
go.debug.function.calls.mac.note=请记住，您的操作系统可能会要求您输入密码以启动调试服务器。
go.debug.function.calls.run.to.cursor=现在，文本光标位于第 15 行的末尾。按 {0} 查看 {1} 操作的工作方式。
go.debug.function.calls.step.over=尝试使用 {1} 单步跳过 {0} 构造。
go.debug.function.calls.toggle.breakpoint=在调试模式下，您可以将不同的值传递至函数，并查看函数返回的内容。在<a href\="{0}">文档</a>中了解有关“对表达式求值”功能的更多信息。\n{1}要开始调试，您需要创建一个断点。按 {2} 切换断点。
go.debug.function.calls.version.warning=<strong>注</strong>\: 对于此功能，您需要安装 Go 1.11 或更高版本。
go.debug.function.context.menu=可以通过多种方式调试代码。其中之一是借助上下文菜单。\n右键点击编辑器中的某个区域，然后选择高亮显示的菜单条目“{0}”。请注意，确切的措辞可能有所不同\: 在 {2} 函数的上下文中可能为“{1}”，在其他上下文中可能为“{3}”。
go.debug.function.more.menu=点击“{1}”工具窗口中的“{0}”按钮。
go.debug.run.sample=选择 {0} 目录项或尝试 {1}。
go.debug.stop.debug=按 {0} 停止调试并完成课次。
go.dump.goroutines.click.button.DlvFilterGoroutinesAction=在打开的 {0} 标签页中，点击“{1}”按钮。
go.dump.goroutines.click.button.more=从下拉列表中选择“{0}”。
go.dump.goroutines.dump.tab={0} 标签页会显示应用程序的 Goroutine 列表。我们的应用程序有几个 goroutine。但您的实际应用程序可能不止这些。\n在 <ide/> 中，您可以应用筛选器来搜索特定的 goroutine，并研究筛选后的结果。
go.dump.goroutines.filter.goroutines=在 {0} 搜索字段中，键入 {1} 以筛选列表。此筛选器只保留名称中含有 {1} 的 goroutine 的执行堆栈。
go.dump.goroutines.name=转储 goroutine
go.dump.goroutines.toggle.breakpoint=在 Go 中，并发任务称为 goroutine。要创建 goroutine，可以在函数或方法调用之前使用 {0} 语句。\n您可以创建程序使用的所有 goroutine 的转储，应用搜索特定 goroutine 的筛选器，并研究筛选的结果。\n要转储 goroutine，需要启动调试。但首先要创建一个断点。按 {1} 可切换断点。{2}
go.extract.inline.variables.extract.task=按 {0} 提取变量，选择一个字符串表达式，输入新名称，然后按 {1} 完成重构。
go.extract.inline.variables.inline.task=与 {0} 重构相反，{1} 有助于移除冗余变量。按 {2} 可将变量内联到其单个用法中。
go.extract.inline.variables.lesson.name=提取和内联变量
go.extract.methods.with.returns.complete.refactoring=键入 {0} 并按 {1}。
go.extract.methods.with.returns.intro=使用 {0} 重构，您可以获取代码段，将其移至单独的方法，并用对新方法的调用替换旧代码。如果代码在 return 语句中退出，则按原样提取。在<a href\="{1}">提取函数和方法</a>一文中进一步了解 {0} 重构。
go.extract.methods.with.returns.invoke.refactoring=文本光标位于您可以提取的 {0} 子句之前。按 {1}。
go.extract.methods.with.returns.lesson.name=提取方法
go.feature.trainer.specify.sdk.to.continue.learning.title=指定 Go SDK 以继续学习
go.feature.trainer.too.old.go.sdk.notification.text=教程需要 Go SDK <b>{1}</b> 或更高版本才能对 Go 模块进行依赖项管理。您当前的 Go SDK 版本为 <b>{0}</b>。
go.feature.trainer.too.old.go.sdk.notification.title=将 Go SDK 更新到 <b>{0}</b> 或更高版本
go.fmt.lesson.name=使用 go fmt 设置代码格式
go.fmt.task=如果您倾向于使用“{0}”设置代码格式，可以按 {1} 运行。
go.formatting.clear.selection=要清理选区，按 {0}。
go.formatting.lesson.name=使用内置格式化程序设置代码格式
go.formatting.reformat.selection=<ide/> 可以帮助您进行代码格式化。点击 {0} 重新设置所选代码块的格式。
go.formatting.whole.file=要重新设置整个源文件的格式，请在未选择任何行的情况下使用 {0}。
go.generics.change.casing=在生成测试文件之前，我们先修正一下代码样式。在官方 Go 文档中，类型形参的名称为大写，我们代码中的 {0} 形参为小写。\n要修正大小写，我们可以使用快速修复。要执行此操作，请按 {1}，然后选择“{2}”。
go.generics.click.function=点击“{0}”，然后在“{1}”弹出窗口中，选择“{2}”。
go.generics.fix.type=我们代码中的下一个问题是类型包含其本身，您将收到 {0} 错误。要避免此错误，应该包括指向类型的指针，而不是类型本身。IDE 有一个针对此情况的快速修复。\n按 {1}，然后选择“{2}”。
go.generics.implement.methods.name=泛型\: 实现缺少的方法
go.generics.inspections.change.interface.to.any=继续深入之前，我们再来重构一个东西。我们使用一个可被替换为 {0} 的空接口。\n按 {1}，然后选择“{2}”。
go.generics.inspections.delete.type.parameters={0} 函数使用中括号来使用类型形参，但在这些中括号中，我们看到了空的形参列表。要修正该错误，请按 {1}，然后选择“{2}”。
go.generics.inspections.title=类型形参的检查
go.generics.inspections.union.interfaces.with.methods=根据 <a href\="{0}">Go 团队</a>，在联合体中您不能将接口与方法一起使用。因此，不能将 {1} 用作联合体元素中的术语。\n删除以 {1} 开头、以竖线及其之后空格结尾的所选组。
go.generics.inspections.unused.type.parameter=类型形参为灰显，因为我们在代码中的任何地方都不使用它们。我们来通过将形参部分中的 {0} 类型替换为 {1} 进行修正。
go.generics.right.click.function=我们已消除文件中的所有错误，可以尝试为 {0} 函数生成测试。\n右键点击 {0} 函数。
go.generics.running.code.click.link=现在，点击结果链接，在浏览器中打开您的代码。\n要使用类型形参运行代码，点击“{0}”按钮即可。
go.generics.running.code.missing.go118.download.or.local=如果您之前安装过 Go {0}，可以尝试使用下拉列表进行查找。或者，点击“{1}”按钮并选择是要下载所需的 SDK 版本({2})，还是要导航到硬盘驱动器上的本地副本({3})。\n通过上述方式，选择比 Go {0} 更高的版本，然后在所有对话框中点击“{4}”以应用新的 SDK。
go.generics.running.code.missing.go118.downloading=<ide/> 现在会下载并解压缩 SDK。完成此步骤后，IDE 将为这些文件编制索引，以便将它们用于代码辅助。
go.generics.running.code.missing.go118.indexing=现在，<ide/> 会索引 SDK 文件。请等待处理完毕。之后，您就可以使用此 Go SDK 了。
go.generics.running.code.missing.go118.quickfix=您当前正在使用 Go {0}。要在本课次中使用泛型，您需要安装或切换到 Go 1.18 或更高版本。\n您可以按 {1}，然后选择“{2}”以执行该操作。
go.generics.running.code.name=运行代码
go.generics.running.code.playground=另一种运行代码的方法是使用“{0}”。\n要试用此功能，请按 {1}。如果出现确认对话框，请点击“{2}”将文件设为公开。将在编辑器的右下角显示包含{0}中页面的链接的弹出窗口。
go.generics.test.generation.module=为类型形参生成测试
go.goto.next.error=要导航到文件中下一个高亮显示的错误，请按 {0}。
go.navigation.module.description=在代码库中进行移动
go.navigation.module.name=导航
go.new.features.experimental.gc.intro=Go 1.25 引入了一个名为 GreenTea GC 的全新实验性垃圾回收器(GC)，旨在提升 Go 应用程序的运行速度和可扩展性，尤其适用于会创建大量小对象或在多核 CPU 上运行的应用程序。默认不启用此 GC，但您可以使用特殊标志进行试用。
go.new.features.experimental.gc.run.with.flag=在终端中输入以下命令，使用 GreenTea GC 运行程序\: {0}
go.new.features.experimental.gc.run.without.flag=现在运行不带该标志的程序。输入以下命令并按 {0}\: {1}。\n注意\: 此功能尚处于实验阶段，每次运行的结果可能会有所不同。
go.new.features.experimental.gc.title=实验性垃圾回收器
go.new.features.flight.recorder.intro=认识一下 {0}\: 这是一种内置工具，可以记录最近的活动，并允许您在发生值得注意的事件(例如错误、峰值或 panic)时捕获快照。
go.new.features.flight.recorder.run=让我们模拟程序中的一个关键事件，并查看输出。\n在编辑器中的任意位置点击右键，然后选择 {0}；如果您在 {2} 函数的上下文中，则选择 {1}。
go.new.features.flight.recorder.study.output=该跟踪已保存到名为 {0} 的文件中。\n要分析 Go 执行跟踪，您需要使用 {1} 运行本地服务器。\n按 {2} 打开终端。
go.new.features.flight.recorder.title=Flight Recorder
go.new.features.flight.version.json.m.build=在终端中，输入并运行以下命令来构建应用程序\: {0}
go.new.features.flight.version.json.m.intro=Go 1.25 添加了一个有用的新命令行选项，能以 JSON 格式打印有关已编译 Go 二进制文件的详细构建信息，从而可以轻松地使用工具进行解析、分析或自动化。
go.new.features.flight.version.json.m.print=现在运行以下命令来打印有关二进制文件的构建信息\: {0}
go.new.features.flight.version.json.m.title=正在打印 'runtime/debug.BuildInfo' 结构
go.new.features.go.doc.open.terminal=按 {0} 打开终端。
go.new.features.go.doc.running.go.doc=输入 {0} 并按 {1}。等待服务器启动后，包含您文档的浏览器将自动打开。
go.new.features.go.doc.stopping.go.doc=点击 {0} 工具窗口中的命令提示符，然后按 {1} 停止服务器。
go.new.features.go.doc.title=新的 'go doc -http' 选项
go.new.features.go.doc.what.it.does={0} 命令会启动一个本地 Web 服务器，该服务器会在您的浏览器中显示您 Go 代码的文档。您可以像浏览网站一样浏览您自己的软件包，阅读根据您的注释生成的文档，并探索您的代码和示例。您无需互联网连接即可使用此功能。
go.new.features.go.vet.hostport.summary={0} 分析器会确保您的地址不会呈现为如下格式\: {1}。此模式无法正确处理类似 {2} 的 IPv6 地址，因为它会创建无效地址。\n请检查编辑器中所选的行。您可以在此处改用 {3}。
go.new.features.go.vet.open.terminal=按 {0} 打开终端。
go.new.features.go.vet.summary=Go 1.25 为 {0} 添加了两项检查以帮助您发现常见错误\: {1} 和 {2}。
go.new.features.go.vet.title=新的 vet 分析器
go.new.features.go.vet.waitgroup.summary={0} 分析器会检查 goroutine 内部是否存在对 {1} 的调用。如果 goroutine 在 {2} 被调用之前就开始运行，可能会导致 {3} 过早完成，从而引发错误。\n请在编辑器中检查所选行。要解决此问题，可以将 {1} 移出 goroutine。
go.new.features.ignore.directive.adding.to.ignore=在 {0} 指令内，输入 {1} 和 {2}。
go.new.features.ignore.directive.running.go.list=输入 {0} 并按 {1}。该命令列出了 {5} 模块中的 {2}、{3} 和 {4} 软件包。
go.new.features.ignore.directive.running.go.list.again=再次运行 {0} 以确保 {1} 和 {2} 软件包被忽略。
go.new.features.ignore.directive.title=MOD 文件中的 'ignore' 指令
go.new.features.ignore.directive.what.it.does={0} 指令的作用是什么? ''ignore'' 指令会告诉 Go 工具\:在构建或测试应用时不要使用这些文件夹中的代码。它会在 {1}、{2}、{3} 等命令中隐藏这些文件夹。\n{4}\: 但被忽略的文件夹仍然是您模块的一部分，并且当有人下载您的模块时(例如，使用 {5} 或通过模块 ZIP 文件)，仍会包含这些文件夹中的文件。
go.new.features.ignore.directive.why.to.use.it=使用 {2} 指令排除非 Go 代码或不需要构建的文件夹。例如，{0} 或 {1} 文件夹中的前端代码，或 JavaScript 库。目前，{2} 指令为空。我们来运行 {3} 并在 {4} 工具窗口中检查其输出。{3} 列出了我们模块中的所有 Go 软件包。按 {5} 打开终端。
go.new.features.in.go.description=Go 1.25 中可能引起您注意的内容
go.new.features.in.go.name=Go 1.25 亮点
go.new.features.json.2.run.experiment=要使用此功能，您需要在<a href\="https\://www.jetbrains.com/help/go/configuring-build-constraints-and-vendoring.html\#using_go_experiments">设置</a>中启用 {0} 实验。或者，您也可以在命令行中使用 {1} 环境变量。\n要打开终端，请按 {2}。
go.new.features.json.2.running.with.env.variable=键入 {0} 并按 {1}。
go.new.features.json.2.study.the.output=检查应用程序输出。大多数示例的两个 JSON 版本都会运行，以便您进行比较。
go.new.features.json.2.summary=Go 1.25 引入了一种全新的、更快且更灵活的 JSON 实现。新的实现提升了性能(尤其是解码性能)、错误消息的可读性、API 灵活性(新的功能和选项)以及 JSON 处理方式的一致性。请注意，{0} 仍处于实验阶段，其设计可能仍会发生变化。
go.new.features.json.2.title=新的 JSON 引擎('json/v2')
go.new.features.repanic.note={0}\:在本例中，您需要在 Go 1.24 和 Go 1.25 之间切换。要了解如何更改 Go SDK 版本，请参阅 <a href\="https\://www.jetbrains.com/help/go/create-new-go-project.html\#installing-go-sdk">GoLand 文档</a>。如果您不想切换版本，可以在 <a href\="https\://tip.golang.org/doc/go1.25\#change-to-unhandled-panic-output">tip.golang.org 上的 Go 1.25 发行说明</a>中比较输出差异。
go.new.features.repanic.run.with.go.124=我们来运行应用程序。在编辑器中点击右键，然后选择高亮显示的菜单项 {0}。请注意，具体文字可能会有所不同\: 在 {2} 函数的上下文中，它可能是 {1}。
go.new.features.repanic.run.with.go.125=很好\! 再次在编辑器中点击右键，重新运行应用程序，并检查 panic 的输出。现在输出打印内容为\:\n{0}
go.new.features.repanic.set.go.124=将您的 Go SDK 版本设置为 1.24。要切换 SDK，请按照 <a href\="https\://www.jetbrains.com/help/go/create-new-go-project.html\#installing-go-sdk">GoLand 文档中的说明</a>进行操作。
go.new.features.repanic.set.go.125=如果检查输出，您会看到其打印内容为\:\n{0}\n{1}\n{2}\n现在，我们来看看 Go 1.25 中是如何处理的。切换回 Go 1.25。
go.new.features.repanic.title=恢复后 panic 输出更好
go.new.features.root.type.intro=Go 1.25 扩展了 {1} 软件包中的 {0} 类型，提供了一种在特定根目录下执行安全、沙盒化文件操作的强大方法。此更新添加了许多常见的文件函数，例如 {2}、{3}、{4} 等。现在，您可以在单个受控的根中安全便捷地处理文件。
go.new.features.root.type.run=您可以运行该应用程序来查看其实际运行情况。出于安全考虑，{0} 方法尚未实现。\n在编辑器中的任意位置点击右键，然后选择 {1}；如果您在 {3} 函数的上下文中，则选择 {2}。
go.new.features.root.type.title='os' 软件包中 'root' 类型的扩展
go.new.features.synctest.results={0} 几乎立即完成。这是因为测试在一个虚拟时间气泡中运行\: 第一次调用立即运行，第二次调用被阻塞，时间通过 {1} 快进 10 秒，第二次调用立即完成，无需任何实际等待。
go.new.features.synctest.running.slow.test=我们准备了一个同时使用常规方法和 {3} 方法的测试套件。应用程序本身包含 {0} 方法，该方法确保每次调用之间至少间隔 10 秒。之后，它会返回字符串 {1}。\n运行 {2} 函数，查看此测试不使用 {3} 时的运行情况。右键点击测试名称，然后选择 {4}。
go.new.features.synctest.running.synctest.test=完成测试实际大约需要 10 秒。\n现在我们来运行 {0} 测试。右键点击测试名称并选择 {1}。
go.new.features.synctest.summary={0} 软件包可帮助您测试并发代码，即使用 goroutine、计时器或休眠的代码。\n它允许您在受控环境(称为“气泡”)中使用虚拟时钟来运行测试，而无需实际等待。我们来看一个示例。
go.new.features.synctest.title=更快地测试并发代码
go.new.features.testing.package.attributes=在 {0} 工具窗口中，您首先可能会注意到的改进是能够将 key–value 特性附加到测试用例。当您想使用自定义元数据(例如版本、输入或上下文)为测试运行添加标签，或改进测试日志的筛选和可读性时，此功能会非常有用。为了生成这些标记，我们使用了以下代码\: {1}。在 {0} 工具窗口中生成输出的行会在编辑器中高亮显示。
go.new.features.testing.package.delete=删除所选代码。
go.new.features.testing.package.intro=Go 1.25 对 {0} 软件包进行了多项虽小但实用的改进，使您的测试日志更加清晰，调试更加容易，尤其是在大型或并行测试套件中。
go.new.features.testing.package.output=在 {0} 工具窗口中向下滚动。您将看到，现在可以生成不带文件和行引用的输出，这与 {1} 函数生成的输出不同。新的 {2} 方法会返回一个直接写入测试输出的 {3}。\n点击 {4} 链接导航到使用标准 {1} 方法的代码；在此行下方，您将看到新的 {2} 方法。
go.new.features.testing.package.parallel=另一个重要更新是将 {0} 与 {1} 结合使用。之前，在并行测试执行期间运行 {1} 可能会产生不可靠的结果。现在，此代码将导致 panic。\n按 {2} 取消注释以下行\: {3}
go.new.features.testing.package.rerun=点击装订区中高亮显示的图标并选择 {0} 以重新运行测试。
go.new.features.testing.package.run=我们来运行整个测试套件以查看这些改进。右键点击高亮显示的装订区图标，然后选择 {0}。\n在 {1} 工具窗口中查看结果。
go.new.features.testing.package.title='testing' 软件包中的其他更新
go.new.features.typeassert.intro=Go 1.25 在 {0} 软件包中引入了一个新函数\: {1}。此函数可帮助您更高效地从 {2} 中提取值，而无需先调用 {3}。
go.new.features.typeassert.new.way=现在看看 {0} 函数，它使用直接转换，无需额外分配内存。这就像打开一个神秘盒子，立刻就能知道里面是什么，而无需将其取出、复印并检查。
go.new.features.typeassert.old.way=假设你有一个神秘盒子，里面可能装着不同类型的物品\: 可能是字符串、数字，也可能是个人信息。类型断言就是一种确定盒子里装着什么并进行适当处理的方式。\n请看 {0} 函数。它使用 {1} 来检查里面是什么类型的物品。在这种方法中，首先会将物品从神秘盒子中取出并复制，然后再检查其类型。
go.new.features.typeassert.run=我们来运行该应用程序。在编辑器中的任意位置点击右键，然后选择高亮显示的菜单项 {0}。\n应用程序运行完成后，比较两种方法之间的性能差异。
go.new.features.typeassert.title=直接值转换
go.onboarding.apply.action=选择“{0}”操作，然后按 {1}。
go.onboarding.apply.intention=选择 {0} 并按 {1}。
go.onboarding.balloon.about.debug.panel=“{0}”工具窗口为工具栏提供了各种调试操作。您可以稍后在“{1}”课次中进行尝试。
go.onboarding.balloon.click.here=点击此处设置断点
go.onboarding.balloon.open.file=双击以打开 {0}
go.onboarding.balloon.open.learn.toolbar=切换到“{0}”工具窗口继续学习本课次
go.onboarding.balloon.project.directory=双击项目目录可以将其展开并查看项目文件
go.onboarding.balloon.project.view=点击以打开<strong>项目</strong>视图
go.onboarding.balloon.start.debugging=点击该图标以开始调试
go.onboarding.balloon.stop.debugging=点击该图标以停止调试
go.onboarding.case.changed=大小写已更改。
go.onboarding.change.ui.settings=在本课次中，<ide/> 会将某些 UI 设置更改为默认状态。完成或退出课次后，将恢复您的偏好设置。
go.onboarding.click.run.button=点击高亮显示的运行按钮“{0}”以显示运行选项。
go.onboarding.click.run.button.balloon=点击以显示运行选项
go.onboarding.close.debug.tool.window=要关闭{0}工具窗口，请按 {1}。
go.onboarding.context.menu=可以通过不同的方式运行代码。其中之一是借助 {1} 函数附近的运行按钮“{0}”。
go.onboarding.epilog=恭喜\! 您已完成入门导览。此时，您可以\:\n- <callback id\="{0}">关闭</callback>学习项目{1}\n- <callback id\="{2}">显示</callback>更多课次
go.onboarding.feedback.system.found.sdks=已找到 SDK\:
go.onboarding.feedback.system.no.sdks=无
go.onboarding.feedback.system.used.sdk=已使用 SDK\:
go.onboarding.indexing.description=第一次打开项目时，<ide/> 会扫描 Go SDK 和项目本身，以收集编码辅助所需的详细信息。要继续，请等待索引完成。
go.onboarding.invoke.completion.tip=<strong>提示</strong>\: 您可以按 {0} 在代码的任何位置显示补全条目。
go.onboarding.invoke.intention.for.code=意图还可以节省您的时间，让编码更轻松。我们使用意图将 {0} 函数快速转换为导出函数。按 {1}。
go.onboarding.invoke.intention.for.code.balloon=按 {0} 显示所有可用的意图
go.onboarding.invoke.intention.for.warning.1=您刚刚修正了一个错误，但还可以进一步改进这段代码。<ide/> 将高亮显示可以改进的代码行，并为这些行添加黄色灯泡。
go.onboarding.invoke.intention.for.warning.2=按 {0} 预览警告并应用快速修复。
go.onboarding.invoke.intention.for.warning.balloon=按 {0} 显示所有可用的快速修复
go.onboarding.invoke.search.everywhere.1=在 <ide/> 中进行处理时，您可能想要搜索项目中的文件、符号、类型，乃至 IDE 操作。在本课次中，我们将搜索 {0} 操作，以将 {1} 字符串改为小写。
go.onboarding.invoke.search.everywhere.2=按两次 {0} 以打开“{1}”对话框。
go.onboarding.lesson.name=熟悉 {0}
go.onboarding.module.description={0} 中的主要功能概览
go.onboarding.module.name=入门导览
go.onboarding.project.view.description=<strong>项目</strong>视图是主要工具窗口之一。它包含项目目录、SDK 特定的软件包和临时文件。点击带条纹的按钮可以预览演示项目。您也可以按 {0} 打开。
go.onboarding.return.to.welcome=\ 并返回欢迎屏幕
go.onboarding.run.sample=选择“{0}”或尝试“{1}”。
go.onboarding.run.widget.balloon=使用此微件，您可以为所选配置执行常用的运行操作
go.onboarding.search.everywhere.description=可以看到，所选文本 {0} 已被自动复制到输入字符串中。我们不输入 {0}，而是输入 {1}。
go.onboarding.select.fix=应用第一个条目\: {0}。通过该修正消除了不必要的圆括号。
go.onboarding.select.item=<ide/> 会在您输入时自动显示补全选项。使用键盘上的箭头选择“{0}”条目，然后按 {1}。
go.onboarding.start.debugging=点击“{0}”图标启动调试过程。
go.onboarding.start.typing=现在，开始输入 {0} 以显示补全选项。
go.onboarding.start.typing.balloon=开始输入 {0} 以显示补全选项
go.onboarding.stop.debugging=我们来停止调试。点击“{0}”图标。
go.onboarding.temporary.configuration.description=<ide/> 刚刚创建了一个临时运行配置。您可以在“{0}”中找到此配置。使用此微件，您可以为所选配置执行常用的运行操作，例如运行 {1}、调试 {2}。其他操作，如分析 {3} 以及使用覆盖率运行 {4} 可通过点击 {5} 显示。
go.onboarding.toggle.breakpoint.1=您可能会注意到 {1} 方法没有返回预期值 {0}，而是返回 {2}。我们来查看 return 语句，调试有问题的代码。
go.onboarding.toggle.breakpoint.2=点击高亮显示区域内的装订区域以设置断点。
go.onboarding.type.division=发现代码中的问题后，我们来修正。将得到的和除以值的长度。课次脚本已插入 {0}。
go.playground.module.name=在 Go Playground 中运行代码
go.playground.note=<strong>注意</strong>\: 在本课次中，您需要连接到 Go Playground 服务器。
go.playground.paste.url=在“{0}”字段中，按 {1} 粘贴 URL，然后点击“{2}”。
go.playground.run.code.in.playground=按工具栏上的“{0}”按钮可使用 Go Playround 服务器运行您的代码。
go.playground.run.code.locally=按工具栏上的“{0}”按钮在您的计算机上运行代码。
go.playground.run.copy.link=您可以从文件和 Go Playground 链接导入代码。按 {0} 复制所选链接。
go.playground.select.open.in.playground=右键点击所选代码并导航到“{0} | {1}”。\n<ide/> 会将此代码导入到临时文件。
go.playground.select.run.locally=我们在本地运行这段代码。要执行此操作，请选中工具栏上的“{0}”复选框。
go.playground.select.url=在“{0}”对话框中，选择“{1}”单选按钮。
go.postfix.completion.better.variable.names.in.templates.description=<ide/> 可以帮助您对使用 {0} 和 {1} 后缀模板生成的变量进行命名。例如，在以下建议中，您可以会遇到\: 用于索引的 {2} 或 {3}，或者用于 {5} 的 {4}。\n输入 {6}，然后从补全列表中选择 {7} 后缀模板。
go.postfix.completion.lesson.name=后缀补全
go.postfix.completion.task=使用后缀模板，您可以根据点号、表达式类型及其上下文后的后缀，将已经输入的表达式转换为其他表达式。\n我们的字母切片已被打乱。要对字符串切片正确排序，可以将 {1} 软件包中的 {0} 函数应用于切片。\n我们已经输入保留切片的变量。接下来应用 {1} 后缀模板，无需反复操作。在 {3} 变量之后输入点号({2})，查看后缀补全建议列表。从列表选择 {1}，或在编辑器中输入，然后按 {4} 补全语句。
go.press.and.apply.fix=按 {0} 并选择 {1}。
go.refactoring.inline.dialog=在打开的对话框中，点击“{0}”。
go.refactoring.menu.extract.method=现在，我们来提取一个计算两点之间距离的方法。按 {0} 并从列表中选择“{1}”，或按 {2} 直接调用此操作。
go.refactoring.menu.inline.refactoring=要内联方法，请按 {0} 并选择“{1}”。
go.refactoring.menu.introduce.parameter.eng=假设您需要将 {0} 提取为常量。{1} 完全可以做到这一点。在重构菜单中，从列表中选择“{1}”，然后按 {2}。
go.refactoring.menu.lesson.name=重构菜单
go.refactoring.menu.select.math.sqrt=选择闪烁的表达式以提取代码中的整个方法，然后按 {0}。
go.refactoring.menu.show.refactoring.list=<ide/> 提供了各种重构。其中许多重构都有自己的快捷键，但您可以随时按 {0} 来列出当前上下文中可用的所有重构。
go.refactoring.menu.start.refactoring=选择“{0}”以替换代码中 {1} 的所有匹配项。
go.refactorings.module.description=重构可使您的代码可靠、简洁并易于维护
go.refactorings.module.name=重构
go.rename.apply.intention=为此字段输入新名称。例如，键入 {0}，然后按 {1} 保存结果。
go.rename.invoke.intentions=您可以将文本光标放在符号上，并使用 {0} 重构来重命名任何内容。将文本光标放在代码任意位置的 {1} 字段上，然后按 {2}。
go.rename.lesson.name=重命名
go.running.code.context.menu=您可以通过不同的方式运行代码。其中一种方式是利用上下文菜单。\n尝试通过右键点击代码所在编辑器中的区域调用上下文菜单。
go.running.code.run.sample=点击“{0}”运行您的代码。应用程序的输出将显示在“{1}”工具窗口中。
go.search.everywhere.goto.type=太棒了\! 但是，有时您需要只查找类型，或者只在某些特定目录中进行搜索。使用“{0}”搜索类型。
go.search.everywhere.quick.documentation=按 {0} 可预览所选类型的文档。
go.search.everywhere.type.popup.closed.warning.message=按 {0} 可再次打开搜索窗口。
go.search.everywhere.type.type.name=假设您需要查找名为 {0} 的类型。输入搜索词的首字母 – {1}。暂时不要导航到找到的类型。
go.search.everywhere.use.all.places=在演示项目中找到匹配类型。但是，您可以查找项目中未包含的其他类型。我们将“{0}”筛选器切换为“{1}”以从 Go SDK 中调出匹配的类型。
go.smart.type.completion.lesson.name=智能类型补全
go.smart.type.completion.task=智能类型补全可以筛选建议列表，使其仅包含当前上下文中适用的类型。按 {0} 以查看匹配建议的列表。按 {1} 选择第一个。
go.statement.completion.complete.condition=在括号 {0} 内添加一个条件，然后按 {1} 跳转到 {2} 语句内。
go.statement.completion.complete.finish.body=键入一行代码\: {0}，然后按 {1} 补全语句并应用格式。
go.statement.completion.complete.for=按 {0} 补全 {1} 语句。
go.statement.completion.complete.if=键入 {0}，然后按 {1} 以生成语句。
go.statement.completion.help.link=语句补全
go.statement.completion.lesson.name=语句补全
go.support.for.table.tests.call.context.menu=在 <ide/> 中，您可以运行函数中的所有测试，或只运行部分测试。例如，点击 {0} 函数附近的装订区域中的运行图标，然后选择“{1}”。您将运行此函数中的所有测试。
go.support.for.table.tests.name=支持表测试
go.support.for.table.tests.run.subtest=您可以使用相同的方法运行单个子测试。点击 {0} 子测试附近的装订区域图标，然后选择“{1}”。\n这种方式当前存在多种限制，您可以在 <a href\="{2}">GoLand 文档</a>中了解这些限制。
go.support.fuzz.testing.check.failing=糟糕，模糊测试失败了\! 要找出原因，请在“{0}”工具窗口中向下滚动输出，然后点击指向 {1} 目录的链接。
go.support.fuzz.testing.run=模糊测试是一种通过不断提交各种输入来自动执行测试的方式。我们来运行模糊测试，根据各种生成的数据检查我们的函数。\n要运行模糊测试，请点击装订区域中的闪烁图标，然后选择“{0}”。
go.support.fuzz.testing.title=模糊测试
go.support.of.godebug.directive.apply.quickfix=警告指出，该指令应在 {0} 子句之前声明。\n要将该指令移动到正确位置，请按 {1} 并选择“{2}”。
go.support.of.godebug.directive.go.to.warning={0} 指令是 Go 1.21 中引入的一项功能，允许开发者影响 Go 运行时的行为。<ide/> 提供了高亮显示和快速修复来帮助管理此指令。\n按 {1} 可导航至警告。
go.support.of.godebug.directive.name=go\:debug 指令的基本支持
go.to.internal.directory=您可以导航到存储在 {0} 文件夹中的接口。\n按 {1} 可转到 {2} 接口的实现。
go.to.internal.directory.hover.over.tab=顺便说一下，要查看文件位置，您可以将鼠标指标悬停在编辑器中的标签页上。例如，将指针悬停在“{0}”标签页上。
go.to.internal.directory.name=导航和代码格式设置
go.to.internal.directory.reformat.gofmt.on.save={0} 文件需要重新设置代码格式。按 {1} 重新设置文件格式。\n此外，默认情况下，<ide/> 将在内置的 <ide/> 格式化程序后运行{2}工具。此设置通过 {5} 中的“{4}”标签页上的“{3}”选项进行配置。
go.type.parameters.description=可能有助于您使用泛型的功能
go.type.parameters.module.name=泛型(类型形参)
go.view.hierarchies.choose.any.implementation=选择任何实现，然后按 {0} 或点击它。
go.view.hierarchies.goto.implementation=按 {0} 查找 {1} 的实现。
go.view.hierarchies.hide.find.tool.window=按 {0} 隐藏“{1}”工具窗口。
go.view.hierarchies.hide.method.hierarchy=我们也隐藏“{0}”。再次按 {1}。
go.view.hierarchies.invoke.implementations.again=基方法的声明具有自身的装订区域图标 {0}。点击它或再次按 {1}。
go.view.hierarchies.lesson.name=查看层次结构
go.view.hierarchies.navigate.to.base=您可以从派生方法导航到基方法。按 {0} 或点击编辑器装订区域中的“{1}”图标。
go.view.hierarchies.open.in.find.tool.window=对于大型层次结构，您可能需要在“{0}”工具窗口中查找实现。点击“{1}”。
go.view.hierarchies.open.method.hierarchy=您可能需要探索此方法的整个层次结构。按 {0}。
go.view.hierarchies.open.type.hierarchy=要查看子类型，请按 {0}。
go.working.with.json.add.key.to.tags=要添加 XML 和 ASN1 标记，也可以使用意图操作。\n按 {0} 再次调用意图操作，然后选择 {1} 并键入 {2}。
go.working.with.json.change.style=您可以为标记中的字段名称应用不同的代码样式。例如，将其更改为骆驼拼写法。\n按 {0}，点击“{1}”，然后选择“{2}”。
go.working.with.json.copy=<ide/> 有几种工具可以帮助您更有效地处理 JSON 代码。\n按 {0} 复制所选的 JSON。
go.working.with.json.introduce.type=我们来提取 {0} 嵌入式结构体。\n按 {1} 并选择“{2}”。
go.working.with.json.name=使用 JSON
go.working.with.json.name.struct=如果需要，请更改结构体名称，然后按 {0} 完成编辑。IDE 将自动修正您的格式设置。
go.working.with.json.replace=按 {0} 替换注释部分。\n<ide/> 会自动将复制的 JSON 部分转换为结构体类型。
go.working.with.json.update.value.in.tags=标记值的批处理更新也是如此。假设我们想将 {0} 添加到当前结构体中的每个标记。\n按 {1}，选择 {2}，然后键入 {3}。\n您也可以从建议列表中选择 {0}。<ide/> 知道 JSON、XML 和 ASN1 标记的最常用值。
go.working.with.parameters.invoke.intentions.1=文本光标位于 {0} 方法的第一个形参处。按 {1} 调用意图操作。
go.working.with.parameters.invoke.intentions.2=查看编辑器中的 {0} 方法。文本光标位于第一个形参处。按 {1} 调用意图操作。
go.working.with.parameters.invoke.intentions.3=如果方法实现接口时需要形参，那么将其移除会不安全。按 {0} 查看可能选项的列表。
go.working.with.parameters.lesson.name=上下文操作
go.working.with.parameters.press.action.again=现在，再按一下 {0}。
go.working.with.parameters.remove.parameters=<ide/> 仅高亮显示未使用形参的名称，前提是其类型用于实现方法规范。在这种情况下，您可以将此形参重命名为 {0} 或完全移除其名称。
go.working.with.parameters.signature.combined=注意签名类型的组合方式。
go.working.with.parameters.signature.expanded=要将签名恢复到初始状态，请选择 {0}。
go.working.with.parameters.single.type=如果函数或方法签名中具有单个类型的多个形参，则可以为这些形参使用简短的类型规范({0})，也可以为每个形参使用单独的类型规范({1})。
go.working.with.parameters.that.are.not.used=<ide/> 可以检测签名中未用于方法或函数体的形参。只要它们未被使用，就可以通过“{0}”快速修复将其删除。
toggle.case.part=切换大小写

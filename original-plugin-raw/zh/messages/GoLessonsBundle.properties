go.feature.trainer.specify.sdk.to.continue.learning.title=指定 Go SDK 以继续学习
go.feature.trainer.too.old.go.sdk.notification.title=将 Go SDK 更新到 <b>{0}</b> 或更高版本
go.feature.trainer.too.old.go.sdk.notification.text=教程需要 Go SDK <b>{1}</b> 或更高版本，才能使用 Go 模块进行依赖项管理。您当前的 Go SDK 版本为 <b>{0}</b>。

## Release Module






## Basic Editing Module

go.wrapping.lesson.name=换行并删除代码行
go.wrapping.put.arguments.on.separate.lines=我们将大量实参传递到 {0} 函数。问题在于第一个实参很长，无法看到它后面的内容。\n\
将文本光标放在左中括号之后，接着按 {1} 并选择 {2}，即可解决这个问题。
go.wrapping.enable.soft.wrap=第一个参数仍在可见区域之外。可能需要为长行启用软换行。按 {0}，键入 {1}，然后切换 {2} 开关。随后您可以按 {3} 关闭搜索。
go.wrapping.put.parameters.on.same.lines=也许，{0} 函数中的实参都在一行中会看起来更好。要进行合并，应将文本光标放在左中括号之后，按 {1} 调用意图操作，然后选择 {2}。






go.comments.lesson.name=添加和移除注释
go.comments.comment.one.line=使用 {0} 注释掉任意一行。
go.comments.uncomment.line=撤消对使用相同快捷键 {0} 注释过的行的注释。
go.comments.comment.block=您可以注释掉代码块。例如，注释掉选定的块，然后按 {0}。


## Completion Module


go.basic.completion.lesson.name=基本补全
go.basic.completion.type.and.choose=默认情况下，<ide/> 会立即补全您的代码。在文本光标的位置开始键入 {0}，您将看到带有匹配建议的“查找”菜单。您可以按 {2} 从“查找”菜单选择 {1}。

go.smart.type.completion.lesson.name=智能类型补全
go.smart.type.completion.task=智能类型补全可以筛选建议列表，以使其仅包含当前上下文中适用的类型。按 {0} 以查看匹配建议的列表。按 {1} 选择第一个。


go.smart.type.completion.and.pointers.lesson.name=智能类型补全: 指针
go.smart.type.completion.and.pointers.first.task=<ide/> 可以为您建议可能的指针和变量地址的列表。\n\
让我们从 {1} 函数返回 {0} 的地址。按 {2}，然后从补全列表中选择 {3}。
go.smart.type.completion.and.pointers.second.task=SmartType 补全也可以与指针一起使用。按 {0} 返回指针，然后选择 {1}。


go.postfix.completion.lesson.name=后缀补全
go.postfix.completion.task=我们的字母切片被打乱了。要对字符串切片正确排序，可以将 {1} 软件包中的 {0} 函数应用于切片。\n\
我们已经键入了保留切片的变量。接下来应用 {1} 后缀模板，无需反复操作。在 {3} 变量之后键入点({2})，查看后缀补全建议列表。从列表选择 {1}，或在编辑器中键入，然后按 {4} 补全语句。


## Debug Module

go.debug.function.calls.lesson.name=调试函数调用
go.debug.function.calls.version.warning=<strong>注</strong>: 对于此功能，您需要安装 Go 1.11 或更高版本。
go.debug.function.calls.toggle.breakpoint=在调试模式下，您可以将不同的值传递至函数，并查看函数返回的内容。在<a href="{0}">文档</a>中了解有关评估表达式功能的更多信息。\n\
{1}要开始调试，您需要创建一个断点。按 {2} 切换断点。
go.debug.function.calls.mac.note=请记住，您的操作系统可能会要求您输入密码以启动调试服务器。
go.debug.function.calls.run.to.cursor=现在，文本光标位于第 15 行的末尾。按 {0} 查看 {1} 操作的工作方式。
go.debug.function.calls.step.over=尝试使用 {1} 单步跳过 {0} 构造。
go.debug.function.calls.evaluate.expression=按 {1} 调用 {0} 操作。
go.debug.function.calls.enter.expression.to.evaluate=在 {0} 字段中，开始键入 {1}，从建议列表中选择 {2}。
go.debug.function.calls.add.arguments.for.evaluation=在括号内，键入 {0}。该字段必须显示 {1}。
go.debug.function.calls.click.evaluate=点击 {0} 或按 {1}。随后您可以关闭对话框。


go.dump.goroutines.name=转储 goroutine
go.dump.goroutines.toggle.breakpoint=在 Go 中，并发任务称为 goroutine。要创建 goroutine，可以在函数或方法调用之前使用 {0} 语句。\n\
您可以创建程序使用的所有 goroutine 的转储，应用搜索特定 goroutine 的筛选器，并研究筛选的结果。\n\
要转储 goroutine，需要启动调试。但首先要创建一个断点。按 {1} 可切换断点。{2}
go.dump.goroutines.click.button.DlvFilterGoroutinesAction=在打开的 {0} 选项卡中，点击 {1} 按钮。
go.dump.goroutines.filter.goroutines=在 {0} 搜索字段中，键入 {1} 以筛选列表。此筛选器只保留名称中含有 {1} 的 goroutine 的执行堆栈。

# Code Generation

go.general.templates.lesson.name=实时模板: fori 和 vars
go.general.templates.fori=我们从循环开始。输入{0} 并从建议列表中选择 {0}。在循环中设置以下条件: {1}。
go.general.templates.type.iteration=每次迭代，{0} 循环必须执行 {1}。
go.general.templates.vars=目前，程序会读取用户从键盘上输入的数字，并在 {0} 循环中使用。但是从 <ide/> 2020.1 起，您可以使用常量的 {1}、变量的 {2}、类型的 {3} 以及导入的 {4} 等模板，更快地编写结构组的代码。\n\
来用 {5} 和 {6} 变量的代码值替换用户输入吧。开始键入 {7}，然后从补全列表选择 {2} 实时模板。为 {5} 和 {6} 变量设置任意值。


go.live.templates.with.types.lesson.name=实时模板: 创建类型和接口
go.live.templates.with.types.struct.template=struct 是一种包含命名字段的类型。struct 适用于将数据共同分组以形成记录。让我们为此代码创建。\n\
开始键入 {0}，然后选择 {1}。使用 {2} 作为 struct 名称。按 {3}。
go.live.templates.with.types.type.fields=将 {0} 添加为 {1} struct 的字段。
go.live.templates.with.types.interface.template=在 Go 中，接口是一种自定义类型，您可以在其中指定一组方法签名。我们来添加一个!\n\
键入 {0}，然后选择 {1}。将接口命名为 {2}，然后按 {3}。
go.live.templates.with.types.add.method=将 {0} 添加为 {1} 接口的方法签名。
go.live.templates.with.types.complete.in.comment=注释解释了程序的工作方式及其意图。在注释中，可以使用代码补全来补全参数、函数和方法的名称。\n\
按 {0} 并选择 {1} 补全 {2} 函数之前的注释。
go.live.templates.with.types.add.second.return.value=目前，{0} 方法仅返回字符串参数。我们需要添加 {1} 返回保留面积值的值。<ide/> 自动在多个返回类型周围添加括号。\n\
键入一个逗号({2})，按空格键，然后键入 {3}。
go.live.templates.with.types.fill.all.fields=最后，来创建一个矩形的新实例，并传递 {0} 和 {1} 的值。\n\
开始键入 {2}，然后从自动补全列表中选择此类型。接下来选择 {3} 操作。输入 {4} 和 {5} 的任意值。


## Intentions Module


go.quick.fix.refactorings.lesson.name=重命名、创建变量并将 Println 改为 Printf
go.quick.fix.refactorings.change.to.formatting={0} 函数使用默认格式打印变量列表。同时，{1} 函数允许指定输出的格式。在示例中，我们将格式动词({2})用于浮点数。但是我们以 {0} 代替 {1}。\n\
来解决这个问题吧!按 {3}，然后选择 {4}。
go.quick.fix.refactorings.create.variable=有许多方法可以声明变量。声明变量后，即可使用等号({0})为其分配一个值。\n\
我们已经声明了 {1} 变量，但是尚未声明 {2} 变量。\n\
按 {3}，然后选择 {4}。现在该变量已声明但未初始化。让我们在其中存储一个零值!请从建议列表中选择 {5}。
go.quick.fix.refactorings.rename=在 <ide/> 中，您可以重命名元素，然后应用变更。<ide/> 重命名代码元素并相应地更新其用法。\n\
在 {1} 函数之前键入 {0} 将函数重命名为 {2}。按 {3}，然后选择 {4}。
go.quick.fix.refactorings.extract.method=使用 Extract Method 重构，您可以获取代码段，将其移动到单独的函数，并用对该函数的调用替换旧代码。我们来将所有打印移至单独的函数。\n\
按 {0}。
go.quick.fix.refactorings.external.doc=外部文档会在 Web 浏览器中打开必要信息，以便您导航到相关符号，同时保留信息以备后续引用。\n\
现在，文本光标位于 {0} 函数上，按 {1}，打开 {2} 上有关 {0} 的文档。









## Refactorings




go.extract.methods.with.returns.lesson.name=提取方法
go.extract.methods.with.returns.intro=使用 {0} 重构，您可以获取代码段，将其移动到单独的方法，并用对新方法的调用替换旧代码。如果代码在 return 语句中退出，则按原样提取。在<a href="{1}">提取函数和方法</a>一文中进一步了解 {0} 重构。
go.extract.methods.with.returns.invoke.refactoring=文本光标位于您可以提取的 {0} 子句之前。按 {1}。
go.extract.methods.with.returns.complete.refactoring=键入 {0} 并按 {1}。



go.rename.lesson.name=重命名
go.rename.invoke.intentions=您可以将文本光标放在符号上，并使用 {0} 重构来重命名任何内容。将文本光标放在代码任意位置的 {1} 字段上，然后按 {2}。
go.rename.apply.intention=为此字段输入新名称。例如，键入 {0}，然后按 {1} 保存结果。
go.what.s.new.module.name=GoLand 2021.3 中的最新变化
go.what.s.new.module.description=GoLand 2021.3 的新功能(2021 年 11 月)
go.basic.editing.module.name=代码编辑
go.basic.editing.module.description=可以帮助您编辑代码的操作
go.code.completion.module.name=代码补全
go.code.completion.module.description=上下文感知的代码补全可加快编码过程并减少拼写错误
go.debugging.module.name=调试
go.debugging.module.description=调试可以帮助您发现并解决应用程序中的问题
go.testing.module.name=测试
go.testing.module.description=测试可确保代码的行为正确无误且符合预期
go.generating.code.module.name=生成代码
go.generating.code.module.description=生成代码块的操作和模板
go.intention.actions.module.name=意图操作
go.intention.actions.module.description=意图操作可以为您提供代码的替代变体，甚至为检测到的问题提供解决方案
go.refactorings.module.name=重构
go.refactorings.module.description=重构可使您的代码可靠、简洁并易于维护

##Testing

go.support.for.table.tests.name=支持表测试
go.support.for.table.tests.call.context.menu=在运行测试时，<ide/> 会考虑文本光标的位置。例如，现在文本光标位于 {0} 函数处。按 {1} 运行此函数中的所有测试。
go.support.for.table.tests.run.subtest=您可以使用相同的方法运行单个子测试。现在文本光标位于 {2} 子测试中。要运行，请按 {0}。\n\
这种方法当前存在多种限制，您可以在 <a href="{1}">GoLand 文档</a>中了解这些限制。

go.code.completion.for.benchmarks.bn.name=基准和测试的代码补全
go.code.completion.for.benchmarks.bn.for.loop=在基准中键入 {0} 时，<ide/> 建议在 {0} 循环的条件表达式中使用 {1}。\n\
例如，键入 {0}，然后从建议列表中选择 {2}。
go.code.completion.for.benchmarks.bn.create.bench=要创建一个新的基准，请开始键入 {0}，然后从建议列表中选择 {0}。

go.support.of.testify.framework.completion.and.subtests.name=验证框架中的代码补全和子测试
go.support.of.testify.framework.completion.and.subtests.assert=<strong>先决条件</strong>: 要完成本课程，<a href="{0}">请启用整个 GOPATH 的索引</a>并<a href="{1}">安装 {2} 包</a>。\n\
<strong>注意</strong>: 对整个 GOPATH 编制索引可能需要一些时间。编制索引速度取决于 GOPATH 下包的数量以及您的计算机性能。\n\
<ide/> 可以补全接受 {3} 作为第一个参数的函数或方法，IDE 会自动传递该参数。\n\
例如，将文本光标放在第 16 行 {6} 之后。在点后面键入 {4}，然后从补全列表中选择 {4}。键入 {5} (不要忘记逗号后面的空格)来完成参数列表。
go.support.of.testify.framework.completion.and.subtests.run.subtest=另外，只要子测试名称是字符串常量，就可以运行 {0} 和 {1} 子测试。\n\
例如，现在文本光标位于 {2}，您可以通过按 {3} 来运行它。

go.onboarding.module.name=入门导览
go.onboarding.module.description={0} 中的主要功能概览
go.onboarding.lesson.name=熟悉 {0}
go.onboarding.project.view.description=<strong>项目</strong>视图是主要工具窗口之一。它包含项目目录、SDK 特定的软件包和临时文件。使用带条纹的按钮可以将其打开，您会看到一个简单的演示项目。也可以按 {0} 打开。
go.onboarding.balloon.project.view=点击以打开<strong>项目</strong>视图
go.onboarding.balloon.project.directory=双击项目目录可以将其展开并查看项目文件
go.onboarding.balloon.open.file=双击以打开 {0}
go.onboarding.balloon.open.learn.toolbar=切换到“{0}”工具窗口继续学习本课
go.onboarding.context.menu=您可以通过不同的方式运行代码。其中的一种方式是利用上下文菜单。\n\
尝试通过右键点击代码所在编辑器中的区域调用上下文菜单。
go.onboarding.run.sample=选择 {0} 或尝试 {1}。
go.onboarding.temporary.configuration.description=<ide/> 刚刚创建了一个临时运行配置。您可以在“运行”工具栏中找到此配置。使用此工具栏，您可以为所选配置执行常用的运行操作，例如运行 {0}、调试 {1}、分析代码 {2} 以及运行代码覆盖率 {3}。
go.onboarding.balloon.click.here=点击此处设置断点
go.onboarding.toggle.breakpoint.1=您可能会注意到 {1} 方法没有返回预期值 {0}，而是返回 {2}。我们来查看 return 语句，调试有问题的代码。
go.onboarding.toggle.breakpoint.2=点击高亮显示区域中的间距以设置断点。
go.onboarding.balloon.start.debugging=点击该图标以开始调试
go.onboarding.start.debugging=点击 {0} 图标启动调试过程。
go.onboarding.balloon.about.debug.panel={0} 工具窗口能够为 {1,choice,0#工具栏|1#工具栏} 提供各种调试操作。您可以稍后在 {2} 课程中进行尝试。
go.onboarding.balloon.stop.debugging=点击该图标以停止调试
go.onboarding.stop.debugging=我们来停止调试。点击 {0} 图标。
go.onboarding.type.division=发现代码中的问题后，我们来进行修正。将得到的和除以值的长度。键入 {0}。
go.onboarding.choose.len.item=<ide/> 会在您键入时自动显示补全选项。使用键盘上的箭头选择 {0} 条目，然后按 {1}。
go.onboarding.invoke.completion=现在调用代码补全，在括号 {1} 中插入 {0}。按 {2} 打开补全列表。
go.onboarding.choose.values.item=您可以键入 {0} 来减少建议的条目数。选择 {1} 并按 {2}。
go.onboarding.invoke.intention.for.warning.1=您刚刚修正了一个错误，但还可以进一步改进这段代码。<ide/> 将高亮显示可以改进的代码行，并为这些行添加黄色灯泡。
go.onboarding.invoke.intention.for.warning.2=按 {0} 预览警告并应用快速修复。
go.onboarding.select.fix=应用第一个条目: {0}。通过该修正消除了不必要的圆括号。
go.onboarding.invoke.intention.for.code=意图还可以节省您的时间，让编码更轻松。我们使用意图将 {0} 函数快速转换为导出函数。按 {1}。
go.onboarding.apply.intention=选择 {0} 并按 {1}。
go.onboarding.invoke.search.everywhere.1=在 <ide/> 中进行处理时，您可能想要搜索项目中的文件、符号、类型乃至 IDE 操作。在本课中，我们将搜索 {0} 操作，以将 {1} 字符串改为小写。
go.onboarding.invoke.search.everywhere.2=按两次 {0} 以打开“{1}”对话框。
go.onboarding.search.everywhere.description=可以看到，所选文本 {0} 已被自动复制到输入字符串中。我们不键入 {0}，而是键入 {1}。
go.onboarding.apply.action=选择“{0}”操作，然后按 {1}。
go.onboarding.case.changed=大小写已更改。
go.onboarding.epilog=恭喜! 您已完成入门导览。此时，您可以:\n\
  - <callback id="{0}">关闭</callback>学习项目{1}\n\
  - <callback id="{2}">显示</callback>更多教程
go.onboarding.return.to.welcome=\ 并返回欢迎屏幕
go.onboarding.finish.title=恭喜
go.onboarding.finish.text=您刚刚完成了 <ide/> 入门导览。\n\
现在可以关闭学习项目{0}。\n\
您也可以继续学习，尝试其他课程。
go.onboarding.finish.exit=关闭演示项目
go.onboarding.finish.modules=显示更多课目
toggle.case.part=大小写
go.onboarding.close.debug.tool.window=要关闭{0}工具窗口，请按 {1}。
go.wrapping.delete.line=警告指出，我们尝试将两个 struct 字段（{0} 和 {1}）映射到相同的 JSON 字段名称，此做法并不好。遇到此错误，程序仍能运行，但将在输出中遗漏一个键。\n\
要修正此问题，您可以重命名标记字符串中的值或删除整个字符串。简单起见，我们按 {2} 移除整个字符串。
go.error.handling.module.name=错误处理
go.error.handling.module.description=了解如何在 Go 中加快错误处理速度
go.advanced.module.name=高级
go.advanced.module.description=需要对该语言有更深理解的功能
go.navigation.module.name=导航
go.navigation.module.description=在代码库中进行移动
go.code.style.module.name=代码样式
go.code.style.module.description=在您的源代码中应用 Go 编码惯例
go.search.module.name=搜索
go.search.module.description=了解 IDE 的搜索功能
go.postfix.completion.intro=使用后缀模板，您可以根据点号、表达式类型及其上下文后的后缀，将已经输入的表达式转换为其他表达式。您可以使用一组预定义的后缀补全模板或创建新模板。有关自定义后缀模板的更多信息，请参阅<a href = "{0}">此文档文章</a>。
go.postfix.completion.better.variable.names.in.templates.description=<ide/> 可以帮助您对使用 {0} 和 {1} 后缀模板生成的变量进行命名。例如，在以下建议中，您可以会遇到：用于索引的 {2} 或 {3}，或者用于 {5} 的 {4} 。
go.postfix.completion.better.variable.names.in.templates.use.forr=键入 {0}，然后从补全列表中选择 {1} 后缀模板。
go.struct.inspections.lesson.name=struct 检查
go.struct.inspections.jump.to.warning=Go 按惯例会对 struct 标记编程。您可以阅读 <a href="{0}">pkg.go.dev 的文章</a>了解更多有关这些惯例的信息。\n\
IDE 已经了解这些惯例，并且将帮助您查找违反 Go 惯例的不一致部分。找到的所有问题都会高亮显示。例如，{1} 字段周围的高亮显示。\n\
来导航到该错误，看看有什么问题吧。要跳转到警告，请按 {2}。
go.struct.inspections.delete.line=警告指出，我们尝试将两个 struct 字段({0} 和 {1})映射到相同的 JSON 字段名称，这并不好。遇到此错误，程序仍将运行，但是我们将在输出中错过一个键。\n\
要修正此问题，您可以重命名标记字符串中的值或删除整个字符串。我们简单点，按 {2} 删除整个字符串。
go.inspection.unsafe.context.cancellation.name=不安全的上下文取消
go.inspection.unsafe.context.cancellation.go.to.error=您可以在 <ide/> 于代码分析期间发现的问题之间导航。\n\
示例中包含一个问题。按 {0} 查看此问题。
go.inspection.unsafe.context.cancellation.add.defer={0} 代码检查会检查是否在所有执行路径上调用了 {2} 返回的 {1} 函数和类似函数。\n\
由于我们不在 {4} 执行路径上调用 {3}，因此您需要键入 {5} 来修复警告。
go.formatting.lesson.name=内置格式化程序
go.formatting.reformat.selection=<ide/> 可以帮助您进行代码格式化。点击 {0} 重新格式化所选代码块。
go.formatting.clear.selection=要清理选区，按 {0}。
go.formatting.whole.file=要重新格式化整个源文件，请在未选择任何行的情况下使用 {0}。
go.fmt.lesson.name=运行 go fmt
go.fmt.task=如果您倾向于使用 {0} 格式化代码，可以按 {1} 运行。
go.general.templates.intro=实时模板可在代码中插入常见结构，如循环、条件、各种声明或打印语句。
go.handling.errors.with.templates.lesson.name=实时和后缀模板: if 和 rr
go.handling.errors.with.templates.if.not.null=部分函数返回两个值。例如，{0} 返回指向 {1} 的指针和错误值。如果错误值为 {2}，则文件成功打开。如果错误不是 {3}，则说明发生了错误。在 <ide/> 中，实时和后缀模板可以帮助您更快速地编写错误值的处理进程。\n\
键入 {4}，然后从补全列表选择 {5} 实时模板。
go.handling.errors.with.templates.return.nil.err=如果打开文件时出错，则需要返回一个切片和一个错误。我们可以返回 {0} 和 {1}。开始键入 {2}，选择 {3} 实时模板。
go.handling.errors.with.templates.error.case=后缀代码补全可帮助您减少编写代码时的后向文本光标跳转。使用这些模板，可以将已经键入的表达式转换为另一种表达式。您可以在 {0} 部分中找到有关后缀补全的更多课程。\n\
扫描文件时，{1} 可能会遇到错误。如果发生错误，在扫描仪上调用 {2} 方法将返回该错误。\n\
要处理从 {2} 方法返回的可能错误，只需键入 {3} 并按 {4} 应用后缀模板。
go.working.with.parameters.lesson.name=使用形参
go.working.with.parameters.single.type=如果函数或方法签名中具有单个类型的多个参数，则可以为这些参数使用简短的类型规范({0})，也可以为每个参数使用单独的类型规范({1})。
go.working.with.parameters.invoke.intentions.1=文本光标位于 {0} 方法的第一个参数处。按 {1} 调用意图操作。
go.working.with.parameters.signature.combined=注意签名类型是如何组合的。
go.working.with.parameters.press.action.again=现在再按一下 {0}。
go.working.with.parameters.signature.expanded=要将签名恢复到初始状态，请选择 {0}。
go.working.with.parameters.that.are.not.used=<ide/> 可以检测签名中未用于方法或函数体的参数。只要它们不被使用，就可以通过 {0} 快速修复将其删除。
go.working.with.parameters.invoke.intentions.2=注意编辑器中的 {0} 方法。文本光标位于第一个参数处。按 {1} 调用意图操作。
go.working.with.parameters.remove.parameters=<ide/> 仅高亮显示未使用形参的名称，前提是其类型用于实现方法规范。在这种情况下，您可以将此形参重命名为 {0} 或完全移除其名称。
go.working.with.parameters.invoke.intentions.3=如果方法要实现接口时需要形参，那么移除将产生不安全的结果。按 {0} 查看可能选项的列表。
go.extract.inline.variables.lesson.name=提取和内联变量
go.extract.inline.variables.extract.task=按 {0} 提取变量，选择一个字符串表达式，输入新名称，然后按 {1} 完成重构。
go.extract.inline.variables.inline.task=与 {0} 重构相反，{1} 有助于移除冗余变量。按 {2} 可将变量内联到其单个用法中。
go.working.with.json.name=使用 JSON
go.working.with.json.copy=<ide/> 有几种工具可以帮助您更有效地处理 JSON 代码。\n\
按 {0} 复制所选的 JSON。
go.working.with.json.replace=按 {0} 替换注释部分。出现“{1}” 对话框时，请点击<strong>是</strong>。\n\
<ide/> 自动将复制的 JSON 部分转换为结构类型。
go.working.with.json.name.struct=更改结构名称，键入 {0}，然后按 {1} 完成编辑。IDE 将自动修复您的格式设置。
go.working.with.json.introduce.type=提取嵌入到 {1} 结构中的 {0} 结构。\n\
按 {2} 并选择 {3}。
go.working.with.json.change.style=您可以为标记中的字段名称应用不同的代码样式。例如，将其更改为骆驼拼写法。\n\
按 {0}，点击“{1}”，然后选择“{2}”。
go.working.with.json.update.value.in.tags=标记值的批处理更新也是如此。假设我们想将 {0} 添加到当前结构中的每个标记。\n\
按 {1}，选择 {2}，然后键入 {3}。\n\
您也可以从建议列表中选择 {0}。<ide/> 知道 JSON、XML 和 ASN1 标记的最常用值。
go.working.with.json.add.key.to.tags=要添加 XML 和 ASN1 标记，也可以使用意图操作。\n\
按 {0} 再次调用意图操作，然后选择 {1} 并键入 {2}。
go.code.completion.for.time.package.name=基础补全: time 软件包
go.code.completion.for.time.package.year= 要设置日期和时间元素的格式，{0} 软件包使用以下预定义布局中的值: {1}。这意味着您可以使用引用时间元素作为占位符来定义格式。因此，在编码时间而不是 {4} 时，您应该编写 {5}。\n\
如果您忘记了预定义布局中的值，则可以使用代码补全作为提示。例如，按 {2} 并选择 {3} 可粘贴年份元素。
go.code.completion.for.time.package.month= 再次按 {0}，然后为月选择 {1}。
go.code.completion.for.time.package.hour=为小时执行同样的操作，从建议列表中选择 {0}。
go.code.completion.for.time.package.minute=为分钟选择 {0}，完成模板。
go.support.of.go.embed.name=基础补全: 使用 //go:embed
go.support.of.go.embed.string=使用 {0} 指令，可以在构建期间将文件和目录嵌入到 Go 二进制文件中。\n\
我们来将 {1} 文件作为 {2} 类型嵌入。按 {3}，然后从建议列表中选择 {1}。
go.support.of.go.embed.note={0}: 要使用 {1} 指令，请确保已安装 Go 1.16 或更高版本。有关 Go SDK 安装的详细信息，请参阅<a href="{2}">在文档中下载 Go SDK</a>。
go.support.of.go.embed.navigate=我们的文件还有问题。按 {0} 导航到其他问题
go.support.of.go.embed.fs=检查表明所指定的目录不存在。我们可以将它替换成现有目录。\n\
按 {0}，选择 {1}，键入 {2}，然后选择 {3}。
go.dump.goroutines.click.button.more=在 {0} 工具窗口中，点击 {1}。
go.dump.goroutines.dump.tab={0} 选项卡会显示应用程序的 Goroutine 列表。我们的应用程序有几个 goroutine。但您的实际应用程序可能不止这些。\n\
在 <ide/> 中，您可以应用筛选器来搜索特定的 goroutine，并研究筛选后的结果。
go.struct.fields.lesson.name=创建结构并填充结构字段
go.struct.fields.create.type=使用结构时，您可能希望先编写具有字段及其值的结构，然后在结构类型中定义所有内容。与示例一样，我们创建了一个新结构并为其字段定义了值。但我们仍然缺少结构定义。\n\
我们通过按 {0} 并选择 {1} {2} 快速修复来解决这个问题。
go.struct.fields.type.defined= 现在，已使用相应的字段对 {0} 结构进行了定义。
go.struct.fields.struct.no.fields=还有另一种情况，我们定义了所有内容，但需要为新结构填充字段名。我们可以手动重新输入，但 <ide/> 针对此过程有一个意图操作。
go.struct.fields.invoke.intentions=按 {0} 调用意图操作。
go.apply.fix=选择 {0} 并按 {1}。
go.navigate.to.error=按 {0} 转到下一个错误。
go.generate.getters.and.setters.name=生成 getter 和 setter
go.generate.getters.and.setters.action=在需要为结构字段生成 getter 和 setter 的情况下，可以使用意图操作。\n\
按 {0} 并选择“{1}”。在“{2}”对话框中，按 {3} 并选择所有可用字段。点击“{4}”。
go.implement.missing.methods.lesson.name=实现缺少的方法
go.introduce.function.lesson.name=从函数类型创建函数
go.introduce.function.intro=<ide/> 可以从调用创建函数和方法。现在，如果缺少函数或方法，还可以根据其类型进行创建。
go.introduce.function.invoke.intentions=注意文本光标位于 {0} 标识符下，该标识符用作函数引用。按 {1} 调用意图操作。
go.introduce.function.final.propose=您现在可以根据需要调整参数。
go.fixing.test.lesson.name=修复测试文件
go.fixing.test.open.problems.toolwindow={0} 工具窗口显示当前文件中的警告和错误列表，并描述了这些问题。\n\
测试文件已损坏，来看看有什么问题。\n\
按 {1} 打开 {0} 工具窗口。
go.fixing.test.close.problems=有一些问题需要我们注意。您可以直接在 {0} 工具窗口中解决部分问题。但是有些问题需要编辑器中的特定操作。我们将在编辑器中应用所有修复!\n\
再次按 {2} 关闭 {1} 工具窗口。
go.fixing.test.fix.string.conversion=此 {0} 转换返回 Unicode 代码点的 UTF-8 表示，而不是我们期望的十进制字符串表示。\n\
要解决这个问题，请使用 {2} 软件包的 {1} 方法。按 {3}，然后选择 {4}。
go.fixing.test.use.multicursors=下一个错误非常明显，我们在匿名 struct 中缺少右大括号和逗号。但是我们不想在每行中都重复键入。多光标可能会有所帮助。\n\
要触发多光标，选择区域并按 {0}。键入 {1} 补全该 struct。
go.fixing.test.fix.camelcase={1} 软件包的 <a href="{0}">Go 文档</a>指出，函数名称必须以骆驼拼写法书写(如 {2})。我们的 {3} 函数不符合此惯例。\n\
要修复函数名称，请按 {4}，然后选择 {5}。
go.fixing.test.negate=最后一个并不是真正的错误，而是一些重构，能够简化我们的代码。注意 {0} 函数中的求反，让我们看看能做些什么。\n\
按 {1}，将选择移至 {2} 节点，然后按 {3} 预览我们将要执行的更改。\n\
看起来不错，按 {5} 应用 {4} 建议。
go.postfix.templates.lesson.name=后缀模板(nn、panic、rr 和 return)
go.postfix.templates.nn=键入 {0}，然后从补全列表中选择 {1} 后缀模板。
go.postfix.templates.choose.item=键入 {0}，然后按 <action>EditorEnter</action>。从建议列表选择 {1}。
go.postfix.templates.rr={0} 后缀补全模板生成一段代码，用于检查错误变量是否不为 {1}。您可以使用 {0} 后缀补全模板进行错误处理。\n\
现在键入 {2}，然后按 {3} 选择后缀模板。
go.postfix.templates.return=键入 {0} 并应用 {1} 后缀模板。
go.var.check.error.postfix.template.name=varCheckError 后缀模板
go.var.check.error.postfix.template.call=来继续讨论错误处理。这次是讨论 {0} 后缀模板。如果是在返回错误的标识符之后键入它，<ide/> 会自动添加默认变量名，并且函数会返回错误。\n\
尝试在 {2} 函数后键入 {1}，然后从建议列表中选择 {0}。
go.var.check.error.postfix.template.anonymous.variable=键入 {0} 以使用空标识符，然后按 {1}。
go.var.check.error.postfix.template.quick.fix=Go 1.16 为 {0} 引入了新检查。它确保解封字节切片的值不是 {1}。<ide/> 会检测此类情况，并提供用于解决这些问题的快速修复。\n\
按 {2} 并选择 {3}。
go.handling.unhandled.errors.name=处理未处理的错误
go.handling.unhandled.errors.handle.error={0} 代码检查会通知您返回错误值的函数或方法，但不会检查这些错误值。要进行处理，可以使用以下快速修复。\n\
第一个是 {1} 快速修复。它将调用结果分配给变量并生成 {2} 检查。\n\
我们将它应用到示例中! 按 {3} 并选择 {1}。
go.handling.unhandled.errors.handle.error.var.name=为变量名键入 {0}，然后按 {1}。
go.handling.unhandled.errors.wrap.in.closure=另一种快速修复适用于 {0} 和 {1} 语句。它的运作方式与 {2} 快速修复类似，但也会将代码包装在闭包中。\n\
按 {3} 并选择 {4}。
go.improve.names.lesson.name=错误变量的更好名称
go.improve.names.intro=<ide/> 为错误({0})和上下文({1})变量推荐最受欢迎的名称变体。
go.improve.names.introduce.variable=文本光标在 {0} 调用处。按 {1} 提取变量。
go.improve.names.apply.fix=在列表中选择整个调用，然后按 {0}。注意，<ide/> 为变量建议了 {1} 名称，因为它是错误的最常用名称。
go.smart.type.completion.special.cases.lesson.name=类型断言和 switch 结构
go.smart.type.completion.special.cases.number=如果需要验证或检查变量的类型，可以使用类型断言或 switch 构造。<ide/> 将这些类型显示在建议列表的开头。要减少大量建议，可继续键入类型名称。\n\
让我们在 {0} 函数中补全验证。要完成操作，我们需要为 {2} 接口传递 {1} 类型。按 {3}，然后选择 {4} 类型。
go.smart.type.completion.special.cases.line=如果您决定将字符串传递至 {0} 函数，会导致 {1} 错误。要检查任意值的类型，可以使用类型 switch 构造。按 {2}，然后选择 {3}。
go.delete.conversion.lesson.name=冗余类型转换
go.delete.conversion.intro=<strong>冗余类型转换</strong>检查会警告可以省略的冗余类型转换(例如，当您将字符串文字转换为字符串时)。在<a href="{0}">冗余类型转换</a>中可了解有关检查的更多信息。
go.delete.conversion.invoke.intentions=注意编辑器中的 {0} 函数。文本光标位于 {2} 的 {1} 类型转换上。按 {3} 调用意图操作。
go.variadic.functions.lesson.name=可变函数(快速修复和重构)
go.variadic.functions.unpack.slice=可变函数是可以使用不同数量的参数调用的函数，例如 {0}。\n\
可变函数将可变实参作为切片处理。\n\
在我们的示例中，该可变函数为 {1}。\n\
但是，我们无法按原样将 {2} 切片传递至可变函数 {3}。对于这种情况，Go 提供了特殊语法。就是切片之后的省略号({4})。\n\
要解决该错误，按 {5}，然后选择 {6}。
go.variadic.functions.inline=您可以使用切片的可变实参替换切片。按 {0} 调用 {1} 重构。
go.variadic.functions.introduce.variable=要还原 {0} 重构，请使用 {1} 重构。按 {2}，然后从建议列表中选择 {3}。
go.basic.completion.invoke.completion=请注意，<ide/> 会自动插入一个新的导入。接下来，按 {0} 激活基本补全，选择 {1}，然后按 {2}。
go.press.and.apply.fix=按 {0} 并选择 {1}。
go.apply.fix.at.once=或者，如果工具提示仍然可见，您可以按 {0} 立即应用建议的快速修复。
go.onboarding.change.ui.settings=在本课中，<ide/> 会将某些 UI 设置更改为默认状态。完成或退出课程后，将恢复您的偏好设置。
go.onboarding.indexing.description=第一次打开项目时，<ide/> 会扫描 Go SDK 和项目本身，以收集编码辅助所需的详细信息。要继续，请等待索引完成。
go.debug.function.context.menu=您可以通过不同的方式调试代码。其中的一种方式是利用上下文菜单。\n\
尝试通过右键点击代码所在编辑器中的区域调用上下文菜单。
go.autocomplete.json.name=JSON 结构标记的自动补全
go.autocomplete.json.autocomplete=开始填写 JSON 标记时，在输入反引号 ({0}) 之后，<ide/> 将建议输入一个键。键入一个反引号 {0}，然后选择 {1}。
go.autocomplete.json.select.style=现在选择要应用的样式。我们选择 {0}！IDE 将保存您的选择，并为此结构的其他字段建议相同的样式。
go.export.types.name=导出类型
go.export.types.quickfix=如果您编写一个返回未导出类型的导出函数，<ide/> 将建议一个快速修复方法来导出该类型。按 {0} 并选择 {1}。
go.implement.methods.with.todo=使用 TODO 实现方法
go.implement.methods.with.todo.introduction=当您使用 {1} 操作时，{0} 注释会自动添加到生成的模板中。这些特殊注释会在编辑器中高亮显示，编制索引并在 {2} 工具窗口中列出。它将提醒您注意未实现的方法。
go.implement.methods.with.todo.select.type=要添加缺少的类型，请按 {0} 并选择 {1}。
go.implement.methods.with.todo.select.interface=在 {0} 字段中，输入 {1}，然后按 {2}。
go.implement.methods.with.todo.enter.struct.name=输入 {0} 作为新结构的名称。
go.error.string.formatting.name=将字符串转换为数字
go.error.string.formatting.parsefloat=<ide/> 有特殊的后缀模板，可以帮助您将字符串转换为数字。通过输入点号 ({0}) 并从建议列表中选择 {1} 来尝试第一个选项。
go.error.string.formatting.parseint=我们将 {0} 后缀模板应用于 {1}。再次输入 {2}，选择 {0}，然后按 {3} 接受默认值。
go.error.string.formatting.goto=我们的程序中仍有一个弱警告。
go.error.string.formatting.introduction=根据<a href="{0}">Go 惯例</a>，您不应将错误字符串大写。如果您不小心忘记了这个惯例，<ide/> 会提醒您。\n\
要更正警告，请按 {1} 并选择 {2}。
go.to.internal.directory.name=导航、构建约束和代码格式设置
go.to.internal.directory.build.constraints=根据 <a href="{0}">Bug-resistant build constraints 提案</a>，{1} 将被 {2} 替换。从 {1} 到 {2} 语法的过渡期将从 Go 1.16 持续到 1.18。在 Go 1.16 中，您可以使用旧语法或者同时使用两种语法。\n\
按 {3} 删除所选新语法声明。
go.to.internal.directory=从 {0} 2021.2 开始，您可以导航到 {1} 文件夹中存储的接口。\n\
按 {2} 转到 {3} 接口的实现。
go.to.internal.directory.hover.over.tab=顺便说一下，要查看文件位置，您可以将鼠标指标悬停在编辑器中的选项卡上。例如，将指针悬停在“{0}”选项卡上。
go.to.internal.directory.reformat.gofmt.on.save= {0} 文件需要重新设置代码格式。按 {1} 重新设置文件格式。\n\
此外，默认情况下，<ide/> 将在内置的 <ide/> 格式化程序后运行{2}工具。此设置通过 {5} 中的“{4}”选项卡上的“{3}”选项进行配置。
go.type.parameters.module.name=类型形参
go.type.parameters.description=可能有助于您使用类型形参的功能
go.enable.generics.in.go.files.name=使用类型形参
go.enable.generics.in.go.files.enable.quick.fix=默认情况下，对类型形参(或泛型)的支持被禁用。在 2021.2 之前，您仅可以在 {1} 文件中尝试类型形参，现在此支持已扩展到 {0} 文件。\n\
要在当前 {0} 文件中启用对类型形参的支持，请在 {3} 类型上按 {2} 并选择 {4}。
go.enable.generics.in.go.files.use.rename.file=运行代码的最简单方式是使用 {0}。为此，您需要将文件转换成 {3} 扩展名。您可以使用{1}操作进行转换。\n\
按 {2}，键入 {1}，然后从补全列表中选择该操作。
go.enable.generics.in.go.files.change.extension=更改文件扩展名。完整的文件名应为 {0}。
go.enable.generics.in.go.files.run.in.playground=要在 {0} 中运行生成的文件，请按 {1}。\n\
如果出现确认对话框，请点击“{2}”将文件设为公开。将在编辑器的右下角显示包含 {0} 中页面的链接的弹出窗口。
go.enable.generics.in.go.files.click.link=现在，点击生成的链接以在浏览器中打开您的代码。\n\
要在 {0} 中运行您的代码，请按 {1}。
go.goto.next.error=按 {0} 转到文件中下一个高亮显示的错误。
go.debug.nil.hide.types.name=类型和 nil 接口的表示
go.debug.nil.hide.types.introduction=Go 中的接口有两个组件，类型和该类型的值。要使接口为 {0}，这两个组件都必须为 {0}。如果您的程序中有一个接口，其值包含 {0} 指针，则该接口将不等于 {0}，因为内部类型不是 {0}。在调试过程中，<ide/> 会检测这种情况，并以不同的方式显示它们。\n\
我们从创建断点开始调试。按 {1} 切换断点。{2}
go.debug.nil.hide.types.variables=在 {0} 窗格中，您可以看到 {1} 和 {2} 接口之间的差异。{1} 接口是 {3}，因为它的值和类型都未设置。与在接口值内部存储 {4} 类型的 {3} 指针的 {2} 接口不同。无论指针的值是什么，{2} 接口的内部类型都是 {3}。
go.debug.nil.hide.types=如果对象类型占用大量空间，则可以在 {0} 工具窗口中隐藏该对象类型。\n\
试试看！右击 {1} 窗格中的变量，然后清除显示的列表中的 {2} 选项。
go.debug.stop.debug=按 {0} 停止调试并完成课程。
go.goto.next.warning=按 {0} 转到文件中高亮显示的警告。
go.debug.run.sample=选择 {0} 目录项或尝试 {1}。
go.onboarding.feedback.system.found.sdks=已找到 SDK：
go.onboarding.feedback.system.no.sdks=无
go.onboarding.feedback.system.used.sdk=已使用 SDK：
go.onboarding.option.sdk.issues=SDK 问题
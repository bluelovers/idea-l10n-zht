go.feature.trainer.specify.sdk.to.continue.learning.title=指定 Go SDK 以继续学习
go.feature.trainer.too.old.go.sdk.notification.title=将 Go SDK 更新到 <b>{0}</b> 或更高版本
go.feature.trainer.too.old.go.sdk.notification.text=教程需要 Go SDK <b>{1}</b> 或更高版本，才能使用 Go 模块进行依赖项管理。您当前的 Go SDK 版本为 <b>{0}</b>。

## Onboarding tour


go.onboarding.module.name=入门导览
go.onboarding.module.description={0} 中的主要功能概览。
go.onboarding.lesson.name=熟悉 {0}
go.onboarding.project.view.description=<strong>项目</strong>视图是主要工具窗口之一。它包含项目目录、SDK 特定的软件包和临时文件。使用带条纹的按钮可以将其打开，您会看到一个简单的演示项目。也可以按 {0} 打开。
go.onboarding.balloon.project.view=点击以打开<strong>项目</strong>视图
go.onboarding.balloon.project.directory=双击项目目录可以将其展开并查看项目文件
go.onboarding.balloon.open.file=双击以打开 {0}
go.onboarding.balloon.open.learn.toolbar=切换到“{0}”工具窗口继续学习本课
go.onboarding.context.menu=您可以通过不同的方式运行代码。其中的一种方式是利用上下文菜单。\n\
尝试通过右键点击代码所在编辑器中的区域调用上下文菜单。
go.onboarding.run.sample=选择 {0} 或尝试 {1}。
go.onboarding.temporary.configuration.description=<ide/> 刚刚创建了一个临时运行配置。您可以在“运行”工具栏中找到此配置。使用此工具栏，您可以为所选配置执行常用的运行操作，例如运行 {0}、调试 {1}、分析代码 {2} 以及运行代码覆盖率 {3}。
go.onboarding.balloon.click.here=点击此处设置断点
go.onboarding.toggle.breakpoint.1=您可能会注意到 {1} 方法没有返回预期值 {0}，而是返回 {2}。我们来查看 return 语句，调试有问题的代码。
go.onboarding.toggle.breakpoint.2=点击高亮显示区域中的间距以设置断点。
go.onboarding.balloon.start.debugging=点击该图标以开始调试
go.onboarding.start.debugging=点击 {0} 图标启动调试过程。
go.onboarding.balloon.about.debug.panel=“{0}”工具窗口中的工具栏提供了各种调试操作。您可以在以后的“{1}”课中试用。
go.onboarding.balloon.stop.debugging=点击该图标以停止调试
go.onboarding.stop.debugging=我们来停止调试。点击 {0} 图标。
go.onboarding.close.debug.tool.window=要关闭{0}工具窗口，请按 {1}。
go.onboarding.type.division=发现代码中的问题后，我们来进行修正。将得到的和除以值的长度。键入 {0}。
go.onboarding.choose.len.item=<ide/> 会在您键入时自动显示补全选项。使用键盘上的箭头选择 {0} 条目，然后按 {1}。
go.onboarding.invoke.completion=现在调用代码补全，在括号 {1} 中插入 {0}。按 {2} 打开补全列表。
go.onboarding.choose.values.item=您可以键入 {0} 来减少建议的条目数。选择 {1} 并按 {2}。
go.onboarding.invoke.intention.for.warning.1=您刚刚修正了一个错误，但还可以进一步改进这段代码。<ide/> 将高亮显示可以改进的代码行，并为这些行添加黄色灯泡。
go.onboarding.invoke.intention.for.warning.2=按 {0} 预览警告并应用快速修复。
go.onboarding.select.fix=应用第一个条目: {0}。通过该修正消除了不必要的圆括号。
go.onboarding.reformat.code=继续整理代码。按 {0} 重新格式化代码。
go.onboarding.invoke.intention.for.code=意图还可以节省您的时间，让编码更轻松。我们使用意图将 {0} 函数快速转换为导出函数。按 {1}。
go.onboarding.apply.intention=选择 {0} 并按 {1}。
go.onboarding.invoke.search.everywhere.1=在 <ide/> 中进行处理时，您可能想要搜索项目中的文件、符号、类型乃至 IDE 操作。在本课中，我们将搜索 {0} 操作，以将 {1} 字符串改为小写。
go.onboarding.invoke.search.everywhere.2=按两次 {0} 以打开“{1}”对话框。
go.onboarding.search.everywhere.description=可以看到，所选文本 {0} 已被自动复制到输入字符串中。我们不键入 {0}，而是键入 {1}。
go.onboarding.apply.action=选择“{0}”操作，然后按 {1}。
go.onboarding.case.changed=大小写已更改。
go.onboarding.epilog=恭喜! 您已完成入门导览。此时，您可以:\n\
  - <callback id="{0}">关闭</callback>学习项目{1}\n\
  - <callback id="{2}">显示</callback>更多教程
go.onboarding.return.to.welcome=\ 并返回欢迎屏幕
go.onboarding.finish.title=恭喜
go.onboarding.finish.text=您刚刚完成了 <ide/> 入门导览。\n\
现在可以关闭学习项目{0}。\n\
您也可以继续学习，尝试其他课程。
go.onboarding.finish.exit=关闭演示项目
go.onboarding.finish.modules=显示更多课目
toggle.case.part=大小写

## Release Module
go.working.with.json.name=使用 JSON
go.working.with.json.copy=<ide/> 有几种工具可以帮助您更有效地处理 JSON 代码。\n\
按 {0} 复制所选的 JSON。
go.working.with.json.replace=按 {0} 替换注释部分。出现“{1}” 对话框时，请点击<strong>是</strong>。\n\
<ide/> 自动将复制的 JSON 部分转换为结构类型。
go.working.with.json.name.struct=更改结构名称，键入 {0}，然后按 {1} 完成编辑。IDE 将自动修复您的格式设置。
go.working.with.json.introduce.type=提取嵌入到 {1} 结构中的 {0} 结构。\n\
按 {2} 并选择 {3}。
go.working.with.json.change.style=您可以为标记中的字段名称应用不同的代码样式。例如，将其更改为骆驼拼写法。\n\
按 {0}，点击“{1}”，然后选择“{2}”。
go.working.with.json.update.value.in.tags=标记值的批处理更新也是如此。假设我们想将 {0} 添加到当前结构中的每个标记。\n\
按 {1}，选择 {2}，然后键入 {3}。\n\
您也可以从建议列表中选择 {0}。<ide/> 知道 JSON、XML 和 ASN1 标记的最常用值。
go.working.with.json.add.key.to.tags=要添加 XML 和 ASN1 标记，也可以使用意图操作。\n\
按 {0} 再次调用意图操作，然后选择 {1} 并键入 {2}。

go.quick.fixes.create.type.type.incompatibility.name=创建类型并修复类型不兼容性
go.quick.fixes.create.type=在示例中，我们使用了带有字段的结构类型，但没有定义结构类型。\n\
按 {0} 并选择 {1} {2} 快速修复来进行修复。
go.quick.fixes.navigate.to.error= 按 {0} 转到下一个错误。
go.quick.fixes.type.incompatibility=在这里，<ide/> 需要 {0} 类型，但传递的是 {1} 切片。\n\
要将此类型转换为所需类型，请按 {2} 并选择 {3} {4}。

go.generate.getters.and.setters.name=生成 getter 和 setter
go.generate.getters.and.setters.action=在需要为结构字段生成 getter 和 setter 的情况下，可以使用意图操作。\n\
按 {0} 并选择“{1}”。在“{2}”对话框中，按 {3} 并选择所有可用字段。点击“{4}”。

go.handling.unhandled.errors.name=处理未处理的错误
go.handling.unhandled.errors.handle.error={0} 代码检查会通知您返回错误值的函数或方法，但不会检查这些错误值。要进行处理，可以使用以下快速修复。\n\
第一个是 {1} 快速修复。它将调用结果分配给变量并生成 {2} 检查。\n\
我们将它应用到示例中! 按 {3} 并选择 {1}。
go.handling.unhandled.errors.handle.error.var.name=为变量名键入 {0}，然后按 {1}。
go.handling.unhandled.errors.wrap.in.closure=另一种快速修复适用于 {0} 和 {1} 语句。它的运作方式与 {2} 快速修复类似，但也会将代码包装在闭包中。\n\
按 {3} 并选择 {4}。

go.support.of.go.embed.name=//go:embed 支持
go.support.of.go.embed.string=使用 {0} 指令，可以在构建期间将文件和目录嵌入到 Go 二进制文件中。\n\
我们来将 {1} 文件作为 {2} 类型嵌入。按 {3}，然后从建议列表中选择 {1}。
go.support.of.go.embed.note={0}: 要使用 {1} 指令，请确保已安装 Go 1.16 或更高版本。有关 Go SDK 安装的详细信息，请参阅<a href="{2}">在文档中下载 Go SDK</a>。
go.support.of.go.embed.navigate=我们的文件还有问题。按 {0} 导航到其他问题
go.support.of.go.embed.fs=检查表明所指定的目录不存在。我们可以将它替换成现有目录。\n\
按 {0}，选择 {1}，键入 {2}，然后选择 {3}。

go.var.check.error.postfix.template.name=varCheckError 后缀模板
go.var.check.error.postfix.template.call=来继续讨论错误处理。这次是讨论 {0} 后缀模板。如果是在返回错误的标识符之后键入它，<ide/> 会自动添加默认变量名，并且函数会返回错误。\n\
尝试在 {2} 函数后键入 {1}，然后从建议列表中选择 {0}。
go.var.check.error.postfix.template.anonymous.variable=键入 {0} 以使用空标识符，然后按 {1}。
go.var.check.error.postfix.template.quick.fix=Go 1.16 为 {0} 引入了新检查。它确保解封字节切片的值不是 {1}。<ide/> 会检测此类情况，并提供用于解决这些问题的快速修复。\n\
按 {2} 并选择 {3}。

## Basic Editing Module

go.wrapping.lesson.name=长行换行
go.wrapping.put.arguments.on.separate.lines=我们将大量实参传递到 {0} 函数。问题在于第一个实参很长，无法看到它后面的内容。\n\
将文本光标放在左中括号之后，接着按 {1} 并选择 {2}，即可解决这个问题。
go.wrapping.enable.soft.wrap=第一个参数仍在可见区域之外。可能需要为长行启用软换行。按 {0}，键入 {1}，然后切换 {2} 开关。随后您可以按 {3} 关闭搜索。
go.wrapping.put.parameters.on.same.lines=也许，{0} 函数中的实参都在一行上会看起来更好。要进行合并，应将文本光标放在左中括号之后，按 {1} 调用意图操作，然后选择 {2}。

go.struct.inspections.lesson.name=struct 检查
go.struct.inspections.jump.to.warning=Go 按惯例会对 struct 标记编程。您可以阅读 <a href="{0}">golang.org 的文章</a>了解更多有关这些惯例的信息。\n\
IDE 已经了解这些惯例，并且将帮助您查找违反 Go 惯例的不一致部分。找到的所有问题都会高亮显示。例如，{1} 字段周围的高亮显示。\n\
来导航到该错误，看看有什么问题吧。要跳转到警告，请按 {2}。
go.struct.inspections.delete.line=警告指出，我们尝试将两个 struct 字段({0} 和 {1})映射到相同的 JSON 字段名称，这并不好。遇到此错误，程序仍将运行，但是我们将在输出中错过一个键。\n\
要解决此问题，您可以重命名标记字符串中的值或删除整个字符串。我们简单点，按 {2} 删除整个字符串。

go.comment.navigation.lesson.name=从注释导航
go.comment.navigation.task={0} 软件包并不大，我们可以在其中轻松导航。但是某些软件包可能非常庞大，其中会包含数百个代码和注释行。\n\
在 IDE 中，如果这些声明在同一软件包内，那么您可以从注释转到声明。注释中，这些方法、函数和结构的名称的颜色略有不同。类似于第 32 行注释部分中的 {1} 函数。\n\
要从该注释导航到函数声明，请先将文本光标放在注释中的函数名称处，然后按 {2}。

go.inspection.unsafe.context.cancellation.name=导航至检测到的问题
go.inspection.unsafe.context.cancellation.go.to.error=您可以在 <ide/> 于代码分析期间发现的问题之间导航。\n\
示例中包含一个问题。按 {0} 查看此问题。
go.inspection.unsafe.context.cancellation.add.defer={0} 代码检查会检查是否在所有执行路径上调用了 {2} 返回的 {1} 函数和类似函数。\n\
由于我们不在 {4} 执行路径上调用 {3}，因此您需要键入 {5} 来修复警告。

go.formatting.lesson.name=将代码样式应用到您的代码
go.formatting.reformat.selection=<ide/> 可以帮助您进行代码格式化。点击 {0} 重新格式化所选代码块。
go.formatting.clear.selection=要清理选择，按 {0}。
go.formatting.whole.file=要重新格式化整个源文件，请在未选择任何行的情况下使用 {0}。

go.fmt.lesson.name=运行 go fmt
go.fmt.task=如果您倾向于使用 {0} 格式化代码，可以按 {1} 运行。

go.comments.lesson.name=添加和移除注释
go.comments.comment.one.line=使用 {0} 注释掉任意一行。
go.comments.uncomment.line=撤消对使用相同快捷键 {0} 注释过的行的注释。
go.comments.comment.block=您可以注释掉代码块。例如，注释掉选定的块，然后按 {0}。


## Completion Module

go.code.completion.for.time.package.name=时间软件包的代码补全
go.code.completion.for.time.package.year= 要格式化日期和时间元素，{0} 软件包使用以下预定义的布局: {1}。这意味着您可以使用引用时间元素作为占位符来定义格式。\n\
如果您忘记了预定义的布局，则可以使用代码补全作为提示。例如，按 {2} 并选择 {3} 可粘贴年份元素。
go.code.completion.for.time.package.month= 再次按 {0}，然后为月选择 {1}。
go.code.completion.for.time.package.hour=为小时执行同样的操作，从建议列表中选择 {0}。
go.code.completion.for.time.package.minute=为分钟选择 {0}，完成模板。

go.basic.completion.lesson.name=基本补全
go.basic.completion.complete.again=在查找菜单中选择 {0}，然后按 {1}。
go.basic.completion.complete.statement=按 {0} 补全此语句然后移到新一行。
go.basic.completion.invoke.completion=注意，<ide/> 会自动插入新的导入。现在，要激活“基本补全”，请按 {0}，您会再次看到查找菜单。
go.basic.completion.type.and.choose=默认情况下，<ide/> 会立即补全您的代码。在文本光标的位置开始键入 {0}，您将看到带有匹配建议的“查找”菜单。您可以按 {2} 从“查找”菜单选择 {1}。

go.smart.type.completion.lesson.name=智能类型补全
go.smart.type.completion.task=智能类型补全可以筛选建议列表，以使其仅包含当前上下文中适用的类型。按 {0} 以查看匹配建议的列表。按 {1} 选择第一个。

go.smart.type.completion.special.cases.lesson.name=类型断言和 switch 结构
go.smart.type.completion.special.cases.number=如果需要验证或检查变量的类型，可以使用类型断言或 switch 构造。<ide/> 将这些类型显示在建议列表的开头。要减少大量建议，可继续键入类型名称。\n\
让我们在 {0} 函数中补全验证。要完成操作，我们需要为 {2} 接口传递 {1} 类型。按 {3}，然后选择 {4} 类型。
go.smart.type.completion.special.cases.line=如果您决定将字符串传递至 {0} 函数，会导致 {1} 错误。要检查任意值的类型，可以使用类型 switch 构造。按 {2}，然后选择 {3}。

go.smart.type.completion.and.pointers.lesson.name=智能类型补全和指针
go.smart.type.completion.and.pointers.first.task=<ide/> 可以为您建议可能的指针和变量地址的列表。\n\
让我们从 {1} 函数返回 {0} 的地址。按 {2}，然后从补全列表中选择 {3}。
go.smart.type.completion.and.pointers.second.task=SmartType 补全也可以与指针一起使用。按 {0} 返回指针，然后选择 {1}。

go.postfix.templates.lesson.name=后缀模板(nn、panic、rr 和 return)
go.postfix.templates.nn=使用后缀模板，您可以根据点、表达式类型及其上下文后的后缀，将已经键入的表达式转换为其他表达式。您可以使用一组预定义的后缀补全模板或创建新模板。有关自定义后缀模板的更多信息，请参阅<a href = "{0}">此文档文章</a>。\n\
键入 {1}，然后从补全列表中选择 {2} 后缀模板。
go.postfix.templates.choose.item=键入 {0}，然后按 <action>EditorEnter</action>。从建议列表选择 {1}。
go.postfix.templates.rr={0} 后缀补全模板生成一段代码，用于检查错误变量是否不为 {1}。您可以使用 {0} 后缀补全模板进行错误处理。\n\
现在键入 {2}，然后按 {3} 选择后缀模板。
go.postfix.templates.return=键入 {0} 并应用 {1} 后缀模板。

go.postfix.completion.lesson.name=后缀补全与排序
go.postfix.completion.task=我们的字母切片被打乱了。要对字符串切片正确排序，可以将 {1} 软件包中的 {0} 函数应用于切片。\n\
我们已经键入了保留切片的变量。接下来应用 {1} 后缀模板，无需反复操作。在 {3} 变量之后键入点({2})，查看后缀补全建议列表。从列表选择 {1}，或在编辑器中键入，然后按 {4} 补全语句。

go.completion.for.functions.lesson.name=函数的代码补全
go.completion.for.functions.choose.item=从列表选择 {0}，然后点击 {1}。当您看到建议列表时，即可开始键入，减少结果数量。
go.completion.for.functions.press.twice=要查找接受元素作为第一个参数的所有函数，按<strong>两次</strong> {0}。注意，该点使它看起来像一个方法，而实际上它并不是。

## Debug Module

go.debug.function.calls.lesson.name=调试函数调用
go.debug.function.calls.version.warning=<strong>注</strong>: 对于此功能，您需要安装 Go 1.11 或更高版本。
go.debug.function.calls.toggle.breakpoint=在调试模式下，您可以将不同的值传递至函数，并查看函数返回的内容。在<a href="{0}">文档</a>中了解有关评估表达式功能的更多信息。\n\
{1}要开始调试，您需要创建一个断点。按 {2} 切换断点。
go.debug.function.calls.mac.note=请记住，您的操作系统可能会要求您输入密码以启动调试服务器。
go.debug.function.calls.start.debug=按 {0} 运行调试会话。
go.debug.function.calls.run.to.cursor=现在，文本光标位于第 15 行的末尾。按 {0} 查看 {1} 操作的工作方式。
go.debug.function.calls.step.over=尝试使用 {1} 单步跳过 {0} 构造。
go.debug.function.calls.evaluate.expression=按 {1} 调用 {0} 操作。
go.debug.function.calls.enter.expression.to.evaluate=在 {0} 字段中，开始键入 {1}，从建议列表中选择 {2}。
go.debug.function.calls.add.arguments.for.evaluation=在括号内，键入 {0}。该字段必须显示 {1}。
go.debug.function.calls.click.evaluate=点击 {0} 或按 {1}。随后您可以关闭对话框。
go.debug.function.calls.stop.debug=按 {0} 停止调试并完成课程。

go.better.variable.names.in.templates.lesson.name=实时和后缀模板中更好的变量名
go.better.variable.names.in.templates.description=<ide/> 可以帮助您对使用 {0} 和 {1} 实时模板创建的变量进行命名。例如，在以下建议中，您可以对索引使用 {2} 或 {3}，对值使用 {4}、{5} 和 {6}。
go.better.variable.names.in.templates.use.forr=键入 {0}，然后从补全列表中选择 {1} 后缀模板。
go.better.variable.names.in.templates.finish=注意 <ide/> 会为索引建议 {0}，为值建议 {1}。按 {2} 完成本课。

go.dump.goroutines.name=转储 goroutine
go.dump.goroutines.toggle.breakpoint=在 Go 中，并发任务称为 goroutine。要创建 goroutine，可以在函数或方法调用之前使用 {0} 语句。\n\
您可以创建程序使用的所有 goroutine 的转储，应用搜索特定 goroutine 的筛选器，并研究筛选的结果。\n\
要转储 goroutine，需要启动调试。但首先要创建一个断点。按 {1} 可切换断点。{2}
go.dump.goroutines.click.button.DlvDumpAction=在 {0} 工具窗口中，点击 {1} 按钮。
go.dump.goroutines.click.button.DlvFilterGoroutinesAction=在打开的 {0} 选项卡中，点击 {1} 按钮。
go.dump.goroutines.filter.goroutines=在 {0} 搜索字段中，键入 {1} 以筛选列表。此筛选器只保留名称中含有 {1} 的 goroutine 的执行堆栈。

# Code Generation

go.general.templates.lesson.name=实时和后缀模板: else、fori 和 var
go.general.templates.else=实时模板将常见结构插入您的代码，例如循环、条件、各种声明或 print 语句。与后缀模板一起使用，它们可以帮助您更快速地编写代码。\n\
我们将从 {0} 后缀模板开始。使用 {0} 后缀模板，可以检查表达式是否为 {1}。\n\
在点后开始键入 {2}。如果 {3} 字段为 {1}，则运行 {4} 函数。
go.general.templates.fori=现在键入 {0} 并从建议列表中选择此实时模板。在循环中设置以下条件: {1}。
go.general.templates.type.iteration=每次迭代，{0} 循环必须执行 {1}
go.general.templates.vars=目前，程序会读取用户从键盘上输入的数字，并在 {0} 循环中使用。但是从 <ide/> 2020.1 起，您可以使用常量的 {1}、变量的 {2}、类型的 {3} 以及导入的 {4} 等模板，更快地编写结构组的代码。\n\
来用 {5} 和 {6} 变量的代码值替换用户输入吧。开始键入 {7}，然后从补全列表选择 {2} 实时模板。为 {5} 和 {6} 变量设置任意值。

go.handling.errors.with.templates.lesson.name=使用实时和后缀模板处理错误: if 和 rr
go.handling.errors.with.templates.if.not.null=部分函数返回两个值。例如，{0} 返回指向 {1} 的指针和错误值。如果错误值为 {2}，则文件成功打开。如果错误不是 {3}，则说明发生了错误。在 <ide/> 中，实时和后缀模板可以帮助您更快速地编写错误值的处理进程。\n\
键入 {4}，然后从补全列表选择 {5} 实时模板。
go.handling.errors.with.templates.return.nil.err=如果打开文件时出错，则需要返回一个切片和一个错误。我们可以返回 {0} 和 {1}。开始键入 {2}，选择 {3} 实时模板。
go.handling.errors.with.templates.error.case=后缀代码补全可帮助您减少编写代码时的后向文本光标跳转。使用这些模板，可以将已经键入的表达式转换为另一种表达式。您可以在 {0} 部分中找到有关后缀补全的更多课程。\n\
扫描文件时，{1} 可能会遇到错误。如果发生错误，在扫描仪上调用 {2} 方法将返回该错误。\n\
要处理从 {2} 方法返回的可能错误，只需键入 {3} 并按 {4} 应用后缀模板。

go.live.templates.with.types.lesson.name=使用实时模板和类型
go.live.templates.with.types.struct.template=struct 是一种包含命名字段的类型。struct 适用于将数据共同分组以形成记录。让我们为此代码创建。\n\
开始键入 {0}，然后选择 {1}。使用 {2} 作为 struct 名称。按 {3}。
go.live.templates.with.types.type.fields=将 {0} 添加为 {1} struct 的字段。
go.live.templates.with.types.interface.template=在 Go 中，接口是一种自定义类型，您可以在其中指定一组方法签名。我们来添加一个!\n\
键入 {0}，然后选择 {1}。将接口命名为 {2}，然后按 {3}。
go.live.templates.with.types.add.method=将 {0} 添加为 {1} 接口的方法签名。
go.live.templates.with.types.complete.in.comment=注释解释了程序的工作方式及其意图。在注释中，可以使用代码补全来补全参数、函数和方法的名称。\n\
按 {0} 并选择 {1} 补全 {2} 函数之前的注释。
go.live.templates.with.types.add.second.return.value=目前，{0} 方法仅返回字符串参数。我们需要添加 {1} 返回保留面积值的值。<ide/> 自动在多个返回类型周围添加括号。\n\
键入一个逗号({2})，按空格键，然后键入 {3}。
go.live.templates.with.types.complete.return=如果文本光标停留在函数内的 {0} 关键字之后，代码补全将建议局部变量和零值，即使它们会导致错误。让我们补全计算面积的 {1} 方法。\n\
首先键入 {2}，然后选择 {3}。接下来选择 {4} 变量，按 {5}。键入以下计算矩形面积的公式: {6}。
go.live.templates.with.types.fill.all.fields=最后，来创建一个矩形的新实例，并传递 {0} 和 {1} 的值。\n\
开始键入 {2}，然后从自动补全列表中选择此类型。接下来选择 {3} 操作。输入 {4} 和 {5} 的任意值。

go.generate.missing.methods.lesson.name=生成缺少的方法
go.generate.missing.methods.task=使用 {0} 操作，即使接口定义中已省略，您仍可以生成缺失的方法并指定形参名称。\n\
按 {1}，选择 {2} 类型。在 {3} 窗口中，键入 {4}，然后按 {5}。

## Intentions Module

go.fixing.test.lesson.name=修复测试文件
go.fixing.test.open.problems.toolwindow={0} 工具窗口显示当前文件中的警告和错误列表，并描述了这些问题。\n\
测试文件已损坏，来看看有什么问题。\n\
按 {1} 打开 {0} 工具窗口。
go.fixing.test.close.problems=有一些问题需要我们注意。您可以直接在 {0} 工具窗口中解决部分问题。但是有些问题需要编辑器中的特定操作。我们将在编辑器中应用所有修复!\n\
再次按 {2} 关闭 {1} 工具窗口。
go.fixing.test.fix.string.conversion=此 {0} 转换返回 Unicode 代码点的 UTF-8 表示，而不是我们期望的十进制字符串表示。\n\
要解决这个问题，请使用 {2} 软件包的 {1} 方法。按 {3}，然后选择 {4}。
go.fixing.test.use.multicursors=下一个错误非常明显，我们在匿名 struct 中缺少右大括号和逗号。但是我们不想在每行上都重复键入。多光标可能会有所帮助。\n\
要触发多光标，选择区域并按 {0}。键入 {1} 补全该 struct。
go.fixing.test.fix.camelcase={1} 软件包的 <a href="{0}">Go 文档</a>指出，函数名称必须以骆驼拼写法书写(如 {2})。我们的 {3} 函数不符合此惯例。\n\
要修复函数名称，请按 {4}，然后选择 {5}。
go.fixing.test.negate=最后一个并不是真正的错误，而是一些重构，能够简化我们的代码。注意 {0} 函数中的求反，让我们看看能做些什么。\n\
按 {1}，将选择移至 {2} 节点，然后按 {3} 预览我们将要执行的更改。\n\
看起来不错，按 {5} 应用 {4} 建议。

go.quick.fix.refactorings.lesson.name=快速修复、重构和外部文档
go.quick.fix.refactorings.change.to.formatting={0} 函数使用默认格式打印变量列表。同时，{1} 函数允许指定输出的格式。在示例中，我们将格式动词({2})用于浮点数。但是我们以 {0} 代替 {1}。\n\
来解决这个问题吧!按 {3}，然后选择 {4}。
go.quick.fix.refactorings.create.variable=有许多方法可以声明变量。声明变量后，即可使用等号({0})为其分配一个值。\n\
我们已经声明了 {1} 变量，但是尚未声明 {2} 变量。\n\
按 {3}，然后选择 {4}。现在该变量已声明但未初始化。让我们在其中存储一个零值!请从建议列表中选择 {5}。
go.quick.fix.refactorings.rename=在 <ide/> 中，您可以重命名元素，然后应用变更。<ide/> 重命名代码元素并相应地更新其用法。\n\
在 {1} 函数之前键入 {0} 将函数重命名为 {2}。按 {3}，然后选择 {4}。
go.quick.fix.refactorings.extract.method=使用 Extract Method 重构，您可以获取代码段，将其移动到单独的函数，并用对该函数的调用替换旧代码。我们来将所有打印移至单独的函数。\n\
按 {0}。
go.quick.fix.refactorings.external.doc=外部文档会在 Web 浏览器中打开必要信息，以便您导航到相关符号，同时保留信息以备后续引用。\n\
现在，文本光标位于 {0} 函数上，按 {1}，打开 {2} 上有关 {0} 的文档。

go.apply.fix=选择 {0} 并按 {1}。

go.introduce.function.lesson.name=从函数类型创建函数
go.introduce.function.intro=<ide/> 可以从调用创建函数和方法。现在，如果缺少函数或方法，还可以根据其类型进行创建。
go.introduce.function.invoke.intentions=注意文本光标位于 {0} 标识符下，该标识符用作函数引用。按 {1} 调用意图操作。
go.introduce.function.final.propose=您现在可以根据需要调整参数。

go.delete.parameter.names.lesson.name=删除形参名称
go.delete.parameter.names.intro=<ide/> 仅高亮显示未使用形参的名称，前提是其类型用于实现方法规范。在这种情况下，您可以将此形参重命名为 {0} 或完全移除其名称。
go.delete.parameter.names.invoke.intentions=如果方法要实现接口时需要形参，那么移除将产生不安全的结果。按 {0} 查看可能选项的列表。

go.delete.unused.parameters.lesson.name=删除未使用的形参
go.delete.unused.parameters.intro=<ide/> 可以检测签名中未用于方法或函数体的参数。只要它们不被使用，就可以通过 {0} 快速修复将其删除。
go.delete.unused.parameters.invoke.intentions=注意编辑器中的 {0} 方法。文本光标位于第一个参数处。按 {1} 调用意图操作。

go.fill.struct.fields.lesson.name=填写 struct 字段
go.fill.struct.fields.intro=创建新 struct 时，可以自动为其生成字段名称。有关 {0} 意图操作的文章，请参阅 <a href="{1}">GoLand 文档</a>。
go.fill.struct.fields.invoke.intentions=文本光标位于 {0} struct 的大括号之间。按 {1} 调用意图操作。

go.implement.missing.methods.lesson.name=实现缺少的方法
go.implement.missing.methods.goto.next.error=按 {0} 转到文件中下一个高亮显示的错误。

go.delete.conversion.lesson.name=冗余类型转换
go.delete.conversion.intro=<strong>冗余类型转换</strong>检查会警告可以省略的冗余类型转换(例如，当您将字符串文字转换为字符串时)。在<a href="{0}">冗余类型转换</a>中可了解有关检查的更多信息。
go.delete.conversion.invoke.intentions=注意编辑器中的 {0} 函数。文本光标位于 {2} 的 {1} 类型转换上。按 {3} 调用意图操作。

go.parameters.specification.lesson.name=参数的短和长类型规范
go.parameters.specification.intro=如果函数或方法签名中具有单个类型的多个参数，则可以为这些参数使用简短的类型规范({0})，也可以为每个参数使用单独的类型规范({1})。
go.parameters.specification.invoke.intentions=文本光标位于 {0} 方法的第一个参数处。按 {1} 调用意图操作。
go.parameters.specification.notice.signature.combined=注意签名类型是如何组合的。
go.parameters.specification.press.again=现在再按一下 {0}。
go.parameters.specification.notice.signature.expanded=要将签名恢复到初始状态，请选择 {0}。

## Refactorings

go.variadic.functions.lesson.name=处理可变函数
go.variadic.functions.unpack.slice=可变函数是可以使用不同数量的参数调用的函数，例如 {0}。\n\
可变函数将可变实参作为切片处理。\n\
在我们的示例中，该可变函数为 {1}。\n\
但是，我们无法按原样将 {2} 切片传递至可变函数 {3}。对于这种情况，Go 提供了特殊语法。就是切片之后的省略号({4})。\n\
要解决该错误，按 {5}，然后选择 {6}。
go.variadic.functions.inline=您可以使用切片的可变实参替换切片。按 {0} 调用 {1} 重构。
go.variadic.functions.introduce.variable=要还原 {0} 重构，请使用 {1} 重构。按 {2}，然后从建议列表中选择 {3}。

go.improve.names.lesson.name=错误变量的更好名称
go.improve.names.intro=<ide/> 为错误({0})和上下文({1})变量推荐最受欢迎的名称变体。
go.improve.names.introduce.variable=文本光标在 {0} 调用处。按 {1} 提取变量。
go.improve.names.apply.fix=在列表中选择整个调用，然后按 {0}。注意，<ide/> 为变量建议了 {1} 名称，因为它是错误的最常用名称。

go.extract.method.lesson.name=提取函数和方法
go.extract.method.task=使用 {0} 重构，您可以将代码封装到具有可自定义参数和返回类型的新函数或方法中。我们来将一些代码行提取到新函数中。按 {1}。

go.extract.methods.with.returns.lesson.name=以 return 提取方法
go.extract.methods.with.returns.intro=使用 {0} 重构，您可以获取代码段，将其移动到单独的方法，并用对新方法的调用替换旧代码。如果代码在 return 语句中退出，则按原样提取。在<a href="{1}">提取函数和方法</a>一文中进一步了解 {0} 重构。
go.extract.methods.with.returns.invoke.refactoring=文本光标位于您可以提取的 {0} 子句之前。按 {1}。
go.extract.methods.with.returns.complete.refactoring=键入 {0} 并按 {1}。

go.extract.variable.lesson.name=提取变量
go.extract.variable.task=按 {0} 提取变量，选择一个字符串表达式，输入新名称，然后按 {1} 完成重构。

go.inline.variable.lesson.name=内联提取的变量
go.inline.variable.task=与 {0} 重构相反，{1} 有助于移除冗余变量。按 {2} 将 {3} 变量内联到其单个用法。

go.rename.lesson.name=重命名
go.rename.invoke.intentions=您可以将文本光标放在符号上，并使用 {0} 重构来重命名任何内容。将文本光标放在代码任意位置的 {1} 字段上，然后按 {2}。
go.rename.apply.intention=为此字段输入新名称。例如，键入 {0}，然后按 {1} 保存结果。
go.what.s.new.module.name=GoLand 2021.2 中的最新变化
go.what.s.new.module.description=GoLand 2021.2 的新功能(2021 年 7 月)。
go.basic.editing.module.name=基本编辑
go.basic.editing.module.description=能够帮助您编辑代码的基本操作。
go.code.completion.module.name=代码补全
go.code.completion.module.description=上下文感知的代码补全可加快编码过程并减少拼写错误。
go.debugging.module.name=调试
go.debugging.module.description=调试可以帮助您发现并解决应用程序中的问题。
go.testing.module.name=测试
go.testing.module.description=测试可确保代码的行为正确无误且符合预期。
go.generating.code.module.name=生成代码
go.generating.code.module.description=生成代码块的操作和模板。
go.intention.actions.module.name=意图操作
go.intention.actions.module.description=意图操作可以为您提供代码的替代变体，甚至为检测到的问题提供解决方案。
go.refactorings.module.name=重构
go.refactorings.module.description=重构可使您的代码可靠、简洁并易于维护。

##Testing

go.support.for.table.tests.name=支持表测试
go.support.for.table.tests.call.context.menu=在运行测试时，<ide/> 会考虑文本光标的位置。例如，现在文本光标位于 {0} 函数处。按 {1} 运行此函数中的所有测试。
go.support.for.table.tests.run.subtest=您可以使用相同的方法运行单个子测试。现在文本光标位于 {2} 子测试中。要运行，请按 {0}。\n\
这种方法当前存在多种限制，您可以在 <a href="{1}">GoLand 文档</a>中了解这些限制。

go.code.completion.for.benchmarks.bn.name=基准和测试的代码补全
go.code.completion.for.benchmarks.bn.for.loop=在基准中键入 {0} 时，<ide/> 建议在 {0} 循环的条件表达式中使用 {1}。\n\
例如，键入 {0}，然后从建议列表中选择 {2}。
go.code.completion.for.benchmarks.bn.create.bench=要创建一个新的基准，请开始键入 {0}，然后从建议列表中选择 {0}。

go.support.of.testify.framework.completion.and.subtests.name=验证框架中的代码补全和子测试
go.support.of.testify.framework.completion.and.subtests.assert=<strong>先决条件</strong>: 要完成本课程，<a href="{0}">请启用整个 GOPATH 的索引</a>并<a href="{1}">安装 {2} 包</a>。\n\
<strong>注意</strong>: 对整个 GOPATH 编制索引可能需要一些时间。编制索引速度取决于 GOPATH 下包的数量以及您的计算机性能。\n\
<ide/> 可以补全接受 {3} 作为第一个参数的函数或方法，IDE 会自动传递该参数。\n\
例如，将文本光标放在第 16 行 {6} 之后。在点后面键入 {4}，然后从补全列表中选择 {4}。键入 {5} (不要忘记逗号后面的空格)来完成参数列表。
go.support.of.testify.framework.completion.and.subtests.run.subtest=另外，只要子测试名称是字符串常量，就可以运行 {0} 和 {1} 子测试。\n\
例如，现在文本光标位于 {2}，您可以通过按 {3} 来运行它。

go.to.internal.directory.name=导航、构建约束和代码格式设置
go.to.internal.directory.build.constraints=根据 <a href="{0}">Bug-resistant build constraints 提案</a>，{1} 将被 {2} 替换。从 {1} 到 {2} 语法的过渡期将从 Go 1.16 持续到 1.18。在 Go 1.16 中，您可以使用旧语法或者同时使用两种语法。\n\
按 {3} 删除所选新语法声明。
go.to.internal.directory=从 {0} 2021.2 开始，您可以导航到 {1} 文件夹中存储的接口。\n\
按 {2} 转到 {3} 接口的实现。
go.to.internal.directory.hover.over.tab=顺便说一下，要查看文件位置，您可以将鼠标指标悬停在编辑器中的选项卡上。例如，将指针悬停在“{0}”选项卡上。
go.to.internal.directory.reformat.gofmt.on.save= {0} 文件需要重新设置代码格式。按 {1} 重新设置文件格式。\n\
此外，默认情况下，<ide/> 将在内置的 <ide/> 格式化程序后运行{2}工具。此设置通过 {5} 中的“{4}”选项卡上的“{3}”选项进行配置。
go.enable.generics.in.go.files.name=使用类型形参
go.enable.generics.in.go.files.enable.quick.fix=默认情况下，对类型形参(或泛型)的支持被禁用。在 2021.2 之前，您仅可以在 {1} 文件中尝试类型形参，现在此支持已扩展到 {0} 文件。\n\
要在当前 {0} 文件中启用对类型形参的支持，请在 {3} 类型上按 {2} 并选择 {4}。
go.enable.generics.in.go.files.use.rename.file=运行代码的最简单方式是使用 {0}。为此，您需要将文件转换成 {3} 扩展名。您可以使用{1}操作进行转换。\n\
按 {2}，键入 {1}，然后从补全列表中选择该操作。
go.enable.generics.in.go.files.change.extension=更改文件扩展名。完整的文件名应为 {0}。
go.enable.generics.in.go.files.run.in.playground=要在 {0} 中运行生成的文件，请按 {1}。\n\
如果出现确认对话框，请点击“{2}”将文件设为公开。将在编辑器的右下角显示包含 {0} 中页面的链接的弹出窗口。
go.enable.generics.in.go.files.click.link=现在，点击生成的链接以在浏览器中打开您的代码。\n\
要在 {0} 中运行您的代码，请按 {1}。
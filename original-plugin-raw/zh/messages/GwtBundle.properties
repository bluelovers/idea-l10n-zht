#config
google.web.toolkit.title=Google Web Toolkit

#actions
dialog.title.google.web.toolkit=Google Web Toolkit
error.class.not.found.in.jar=在 ''{1}'' 中找不到类 ''{0}''
error.file.not.found.message=找不到文件 ''{0}''
error.invalid.gwt.installation.message=''{0}'' 不是有效的 GWT 安装: {1}
error.message.path.to.gwt.sdk.must.not.contain.character=GWT SDK 路径不得包含 '!' 字符
fix.download.gwt=下载 GWT…

new.service.dlg.prompt=输入新 GWT 远程服务的名称
new.service.dlg.title=新建 GWT 远程服务
new.service.progress.text=创建 GWT 远程服务 ''{0}''

new.serial.dlg.prompt=输入新的 GWT 可序列化类的名称
new.serial.dlg.title=新建 GWT 可序列化类
new.serial.progress.text=正在创建 GWT 可序列化类 ''{0}''

new.module.dlg.prompt=输入新 GWT 模块的名称(&E)
new.module.dlg.title=新建 GWT 模块
new.module.progress.text=正在创建 GWT 模块 ''{0}''

new.entry.point.dlg.prompt=输入新 GWT 入口点的名称
new.entry.point.dlg.title=新建 GWT 入口点
new.entry.point.progress.text=正在创建 GWT EntryPoint ''{0}''


problem.description.unknown.css.class=未知 CSS 类 ''{0}''
quickfix.name.create.css.class.0=创建 CSS 类 ''{0}''
quickfix.family.name.create.css.class=创建 CSS 类
quickfix.name.create.local.css.class.0=创建局部 CSS 类 ''{0}''
quickfix.family.name.create.local.css.class=创建局部 CSS 类
inspection.unresolved.references.to.css.classes.display.name=对 CSS 类的未解析引用
group.gwt.inspections.name=Google Web Toolkit
css.usages.variable=变量

problem.description.methods.of.async.remote.service.0.isn.t.synchronized.with.1=异步远程服务 ''{0}'' 的方法与 ''{1}'' 不一致
problem.description.remote.service.0.does.not.have.corresponding.async.variant=远程服务 ''{0}'' 没有相应的异步变体
problem.description.async.remote.service.0.does.not.define.corresponding.method=异步远程服务 ''{0}'' 未定义相应的方法
inspection.name.inconsistent.gwt.remote.service=不一致的远程服务
quick.fix.name.synchronize.all.methods.of.0.with.1=将 ''{0}'' 的所有方法与 ''{1}'' 同步
quickfix.name.create.async.method.for.sync.0=为方法 ''{0}'' 创建异步变体
quickfix.family.name.create.async.variant=创建异步变体
problem.description.async.method.does.not.have.sync.variant=方法 ''{0}'' 没有相应的同步变体
quickfix.name.create.sync.method.for.async.0=为方法 ''{0}'' 创建同步变体
quickfix.family.name.create.sync.variant=创建同步变体
problem.description.the.asynchronous.version.of.method.0.must.have.a.return.type.void=方法 ''{0}'' 的异步版本必须具有返回类型 ''void''、\n''com.google.gwt.http.client.Request'' 或 ''com.google.gwt.http.client.RequestBuilder''
quickfix.name.make.0.return.void=使 ''{0}'' 返回 ''void''
quickfix.family.name.make.method.return.void=使方法返回 'void'

problem.description.type.is.not.serializable=类型 ''{0}'' 不可序列化
problem.description.type.of.collection.elements.is.not.specified=未指定 ''{0}'' 元素的类型
problem.description.gwt.serializable.type.0.should.implements.marker.interface.1=类型 ''{0}'' 未实现标记接口 {1}
text.0.or.1=''{0}'' 或 ''{1}''
problem.description.0.is.not.a.checked.exception=''{0}'' 不是检查过的例外
quickfix.name.create.interface.0=创建接口 ''{0}''
quickfix.family.name.create.interface=创建接口
inspection.name.non.serializable.service.method.parameters=不可序列化的服务方法形参类型或返回类型
problem.description.generics.isnt.supported.in.gwt.before.1.5.version=1.5 版之前的 GWT 不支持泛型
checkbox.text.report.interfaces=报告接口

label.choose.module.text=模块(&M):
run.gwt.configuration.display.name=GWT 配置
run.gwt.configuration.description=GWT 配置
default.gwt.run.configuration.name=未命名
error.text.gwt.facet.not.configured.in.module.0=未为模块 ''{0}'' 配置 GWT Facet
error.text.gwt.sdk.is.not.specified.correctly=在模块 ''{0}'' 的 GWT Facet 设置中未正确指定 GWT SDK 路径
error.text.no.gwt.modules.in.module.0=在 ''{0}'' 中找不到 GWT 模块
question.text.gwt.facet.is.not.configured.for.module.0.do.you.want.to.create.it=没有为模块 ''{0}'' 配置 GWT Facet。要创建吗?

inspection.name.unresolved.references.to.html.tags=对 html 标记的未解析引用
problem.description.html.tag.with.id.0.is.not.found=找不到 ID 为 ''{0}'' 的 HTML 标记
quick.fix.name.rename.reference=重命名引用

inspection.name.classes.not.from.jre.emulation.library.in.client.code=使用 JRE Emulation Library 中不存在的类和方法
problem.description.class.0.is.not.presented.in.jre.emulation.library=JRE 仿真库中不存在类 ''{0}''，因此不能在 ''{1}'' GWT 模块的客户端代码中使用
problem.description.method.0.is.not.presented.in.jre.emulation.library=JRE 仿真库中不存在方法 ''{0}''，因此不能在 ''{1}'' GWT 模块的客户端代码中使用
problem.description.class.0.is.defined.in.module.1.which.is.not.inherited.in.module.2=类 ''{0}'' 在模块 ''{1}'' 中定义，而该模块在模块 ''{2}'' 中未被继承
quickfix.name.inherit.module.0.from.1=从 ''{1}'' 集成模块 ''{0}''
quickfix.family.name.inherit.module=继承模块

inspection.name.client.class.from.non.inherited.module.usage=使用未继承的 GWT 模块中的客户端类

inspection.name.gwt.remote.service.is.not.registered.in.web.xml=GWT 远程服务未在 web.xml 中注册
problem.description.remote.service.is.not.registered.as.a.servlet.in.web.xml=远程服务 ''{0}'' 未在 web.xml 中注册为 servlet。
quickfix.name.register.remote.service.0.in.web.xml=在 ''web.xml'' 中注册远程服务 ''{0}''
quickfix.family.name.register.remote.service.in.web.xml=在 'web.xml' 中注册远程服务
problem.description.correct.servlet.mapping.is.not.specified.for.remote.service.0=没有为远程服务 ''{0}'' 指定正确的 servlet 映射
quickfix.name.add.servlet.mapping.for.remote.service.0=为远程服务 ''{0}'' 添加 servlet 映射
quickfix.family.name.add.servlet.mapping.for.remote.service=为远程服务添加 servlet 映射
problem.description.incorrect.servlet.mapping.for.remote.service.0=远程服务 ''{0}'' 的 URL 格式不正确
quickfix.name.set.correct.servlet.mapping.for.remote.service.0=为远程服务 ''{0}'' 设置正确的 URL 格式
quickfix.family.name.set.servlet.mapping.for.remote.service=为远程服务设置正确的 URL 格式
quickfix.name.create.web.facet.and.register.remote.service.0.in.web.xml=创建 Web Facet 并在 ''web.xml'' 中注册远程服务 ''{0}''
quickfix.family.name.create.web.facet.and.register.remote.service.in.web.xml=创建 Web Facet 并在 'web.xml' 中注册远程服务
quickfix.name.connect.gwt.facet.to.0.facet.and.register.remote.service.1.in.web.xml=将 GWT Facet 连接到 ''{0}'' Facet，并在 ''web.xml'' 中注册远程服务 ''{1}''
quickfix.family.name.connect.gwt.facet.and.register.remote.service.in.web.xml=连接 GWT Facet 并在 'web.xml' 中注册远程服务

file.template.group.title.gwt=Google Web Toolkit

action.group.gwt.title=Google Web Toolkit
action.group.gwt.description=Google Web Toolkit

label.text.path.to.gwt.installation=GWT 安装目录路径(&P):
gwt.installation.chooser.title=GWT 安装目录路径
gwt.installation.chooser.description=请指定 GWT 安装目录的路径
error.message.gwt.user.jar.library.not.found.in.dependencies.of.module=在模块的依赖项中找不到 gwt-user.jar 库
error.message.gwt.user.jar.in.library.0.does.not.correspond.to.selected.gwt.installation=库 ''{0}'' 中的 gwt-user.jar 与所选 GWT 安装不相符
label.select.script.output.style.text=JavaScript 输出样式(&O):
label.select.web.facet.text=目标 Web Facet(&W):
label.text.gwt.compiler.heap.size=编译器最大堆大小 (Mb)(&H):
table.column.name.gwt.module=GWT 模块
table.column.name.output.relative.path=输出相对路径
label.text.additional.compiler.parameters=附加编译器 VM 选项(&A):
label.text.gwt.compiler.parameters=编译器参数(&C):
label.html.to.open.text=起始页面(&P):
dialog.caption.vm.parameters=VM 选项
label.text.vm.parameters=虚拟机选项(&V):
label.text.gwt.dev.mode.parameters=开发模式参数(&D):
dialog.caption.gwt.dev.mode.parameters=GWT 开发模式参数
checkbox.text.use.custom.web.xml=使用自定义 'web.xml' 描述符的内容(&W)
choose.text.select.gwt.module=选择 GWT 模块:
dialog.title.choose.gwt.module=GWT 模块
label.text.gwt.module.to.load=要加载的 GWT 模块(&G):
text.gwt.modules.to.load.all=所有
text.gwt.modules.to.load.none=无

i18n.interface.method.gutter.tooltip=<html><body>方法在 {0} {0, choice, 1#个文件|2#个文件}中有关联的属性
i18n.goto.property.popup.title=<html><body>选择 <b>{0}</b> 的本地化(找到 {1} 个文件)</body></html>
i18n.class.gutter.tooltip.text=类有 {0} 个关联的属性 {0, choice, 1#文件|2#文件}

inspection.name.inconsistent.gwt.localizable.interface=不一致的可本地化接口
problem.description.property.0.does.not.have.corresponding.method.in.1=属性 ''{0}'' 在 ''{1}'' 中没有对应的方法
quickfix.name.create.method.for.property.0.in.1=为 ''{1}'' 中的属性 ''{0}'' 创建方法
quickfix.name.synchronize.all.methods.in.0=将所有缺少的方法添加到 ''{0}''
quickfix.family.name.create.missing.methods=创建缺少的方法
problem.description.method.0.does.not.have.corresponding.property=方法 ''{0}'' 没有对应的属性
quickfix.name.create.property.0=创建属性 ''{0}''
quickfix.family.name.create.property=创建属性
quickfix.popup.title.choose.properties.file=选择属性文件

quickfix.name.change.0.type.to.1=将 ''{0}'' 类型更改为 ''{1}''
quickfix.family.name.change.field.type=更改字段类型

quickfix.name.create.def.declaration.for.0=为 ''{0}'' 创建 ''@def'' 声明
quickfix.family.name.create.def.declaration=创建 '@def' 声明

quickfix.name.register.0.subpackage.as.1.path=将 ''{0}'' 子软件包注册为 {1} 路径
quickfix.family.name.register.subpackage=注册子软件包

quickfix.name.create.0.method=创建 ''{0}'' 方法

quickfix.name.replace.0.with.1=将 ''{0}'' 替换为 ''{1}''
quickfix.family.name.replace.listener.with.handler=将侦听器替换为处理程序

inspection.name.incorrect.serializable.class=不正确的可序列化类
problem.description.field.0.is.not.serializable=类型 ''{0}'' 不可序列化
problem.description.serializable.class.should.provide.public.no.args.constructor=可序列化的类应提供 public 无实参构造函数
inspection.name.method.with.parameters.in.interface.extending.constants=接口扩展 Constants 中带有参数的方法
problem.description.methods.with.parameters.are.not.allowed.in.an.interface.extending.constants=接口扩展 Constants 中不允许使用带有参数的方法
problem.description.properties.with.parameters.are.not.allowed.if.the.associated.interface.extends.constants=如果关联接口扩展 Constants，则不允许使用带有参数的属性
quickfix.name.inherit.0.from.messages.instead.of.constants=从消息而不是 Constants 继承 ''{0}''
quickfix.family.name.inherit.from.messages.instead.of.constants=将 Constants 替换为 Messages

inspection.name.unresolved.references.in.jsni.methods=JSNI 方法中未解析的引用
inspection.name.unresolved.references.in.ui.xml.files=ui.xml 文件中未解析的引用
problem.description.cannot.resolve.0=无法解析 ''{0}''
problem.description.cannot.resolve.symbol.0.in.1=无法解析 ''{1}'' 中的符号 ''{0}''
problem.description.ambiguous.wildcard.match=不明确的通配符匹配: ''{2}'' 中的 ''{0}'' 和 ''{1}'' 都与 ''{3}'' 匹配
problem.description.class.is.not.widget=类 ''{0}'' 未实现 ''IsWidget'' 接口

problem.description.inconsistent.element.type=UiBinder 接口参数与 ''{0}'' 标记不一致。应为 ''{1}'' 或其超类
problem.description.ui.xml.not.found=UiBinder 接口没有对应的 ui.xml 文件
problem.description.ui.xml.root.not.found=无法在对应的 ui.xml 文件中检测到根标记
problem.description.ui.xml.root.ambiguity=在对应的 ui.xml 文件中检测到过多根标记

inspection.name.incorrect.java.methods.calls.in.js=从 JavaScript 代码中不正确调用 Java 方法
problem.description.cannot.call.instance.method.without.object.instance=没有对象实例，无法调用实例方法 ''{0}''
problem.description.incorrect.number.of.arguments.for.method=''{0}'' 方法的参数数量不正确: 应为 {1} 个，但实际为 {2} 个

inspection.name.overlay.type.restrictions.violated=违反覆盖类型限制
problem.description.constructor.in.overlay.type.cannot.have.parameters=覆盖类型中的构造函数不能有参数
problem.description.constructor.in.overlay.type.must.be.protected=覆盖类型中的构造函数必须为 protected
problem.description.constructor.in.overlay.type.must.have.empty.body=覆盖类型中的构造函数的主体必须为空
problem.description.overlay.type.must.have.protected.empty.no.arg.constructor=覆盖类型必须具有不带参数的 protected 空构造函数
problem.description.overlay.type.cannot.have.instance.fields=覆盖类型不能包含实例字段
problem.description.inner.classes.in.overlay.type.must.be.static=覆盖类型中的内部类必须为 static
problem.description.instance.methods.in.overlay.type.must.be.final=覆盖类型中的实例方法必须为 final

inspection.name.obsolete.gwt.type.args.tag.in.javadoc.comments=JavaDoc 注释中的已弃用 '@gwt.typeArgs' 标记
problem.description.gwt.type.args.tag.is.obsolete.in.gwt.1.5='@gwt.typeArgs' 标记在 GWT 1.5 中被弃用
quickfix.name.generify.types.in.method.0.instead.of.using.gwt.type.args.tags=在方法 ''{0}'' 中使用形参化类型，不使用 ''@gwt.typeArgs'' 标记
quickfix.family.name.generify.types.in.method=使用形参化类型
gwt.searching.for.implementations=正在搜索实现…

quickfix.name.set.provided.to.true=将 'provided' 特性设置为 'true'

inspection.name.raw.use.of.async.callback.in.asynchronous.service.interfaces=在异步服务接口中原始使用 AsyncCallback
problem.description.raw.use.of.async.callback.interface=在方法 ''{0}'' 中原始使用 AsyncCallback 接口
quickfix.name.replace.async.callback.by.async.callback.0=将 ''AsyncCallback'' 替换为 ''AsyncCallback<{0}>''
quickfix.family.name.replace.async.callback.by.generic.async.callback=泛化 'AsyncCallback'

inspection.name.redundant.set.service.entry.point.methods.calls=冗余的 'setServiceEntryPoint()' 方法调用
error.message.set.service.entry.point.method.call.can.be.replaced.by.remote.service.relative.path.annotation='setServiceEntryPoint()' 方法调用可替换为 '@RemoteServiceRelativePath' 注解
error.message.set.service.entry.point.method.call.is.redundant='setServiceEntryPoint()' 方法调用冗余，因为入口点由 '@RemoteServiceRelativePath' 注解指定

inspection.name.incorrect.argument.of.gwt.create.method=不正确的 GWT.create() 方法参数
problem.description.only.class.literals.may.be.used.as.arguments.to.gwt.create=只能将类文字用作 GWT.create() 的参数

error.message.this.action.is.allowed.only.for.client.side.packages.of.a.gwt.module=此操作仅适用于 GWT 模块的客户端软件包

border.title.gwt.compilation=GWT 编译
framework.title.google.web.toolkit=Google Web 工具包(&G)
inspection.name.deprecated.gwt.key.tag.in.javadoc.comments=JavaDoc 注释中的已弃用 '@gwt.key' 标记
problem.description.gwt.key.tag.is.deprecated.in.gwt.1.5='@gwt.key' 标记在 GWT 1.5 中被弃用
quickfix.name.replace.gwt.key.tag.with.key.annotation.in.method.0=将 ''@gwt.key'' 标记替换为方法 ''{0}'' 中的 @Key 注解
quickfix.family.name.replace.gwt.key.tag.with.key.annotation=将 '@gwt.key' 标记替换为 @Key 注解
dialog.promt.enter.name.for.gwt.test.case=输入 GWT 测试用例的名称:
dialog.title.new.gwt.test.case=新建 GWT 测试用例
action.progress.creating.gwt.test.case.0=创建 GWT 测试用例 ''{0}''

quickfix.name.replace.set.service.entry.point.call.by.annotation=通过注解替换 'setServiceEntryPoint()' 调用
quickfix.name.remove.redundant.set.service.entry.point.call=移除冗余的 'setServiceEntryPoint()' 调用
error.message.0.is.not.under.public.roots.of.gwt.modules.nor.under.web.roots=''{0}'' 不在 GWT 模块的 ''public'' 根目录下，也不在 Web 根目录下，因此无法在托管模式浏览器中打开。
error.message.uibinder.is.supported.in.gwt.2.0.or.later=GWT 2.0 或更高版本支持 UiBinder
label.text.enter.name.for.new.gwt.uibinder.class.and.ui.xml.file=输入新的 GWT UiBinder 类和 ui.xml 文件的名称(&E):
dialog.title.create.new.gwt.uibinder.class.and.ui.xml.file=创建新的 GWT UiBinder 类和 ui.xml 文件
action.name.create.gwt.uibinder.0.and.1.ui.xml.file=创建 GWT UiBinder ''{0}'' 和 ''{1}.ui.xml'' 文件
error.message.uirenderer.is.supported.in.gwt.2.5.or.later=GWT 2.5 或更高版本支持 UiRenderer
label.text.enter.name.for.new.gwt.uirenderer.class.and.ui.xml.file=输入新的 GWT UiRenderer 类和 ui.xml 文件的名称(&E):
dialog.title.create.new.gwt.uirenderer.class.and.ui.xml.file=创建新的 GWT UiRenderer 类和 ui.xml 文件
action.name.create.gwt.uirenderer.0.and.1.ui.xml.file=创建 GWT UiRenderer ''{0}'' 和 ''{1}.ui.xml'' 文件
label.text.select.root.element.type=指定根元素的类型(&S):

dialog.title.create.gwt.event.with.handler=创建新的 GWT 事件和处理程序类
action.name.create.gwt.event.with.handler=创建 GWT 事件 ''{0}'' 及其处理程序类
error.message.gwt.event.not.supported=GWT 1.6 或更高版本支持 GwtEvent

popup.title.resource.method.goto=<html><body>为 <b>{0}</b> 选择文件(找到 {1} 个文件)</body></html>
tooltip.text.resource.method.gutter=方法{0, choice, 1#有|2#有} {0} 个关联的资源{0, choice, 1#文件|2#文件}

popup.title.css.class.method.goto=<html><body>为 <b>{0}</b> 方法选择文件(找到 {1} 个文件)</body></html>
tooltip.text.css.class.method.gutter=方法{0, choice, 1#有|2#有}  个关联的 css {0, choice, 1#类|2#类}
tooltip.text.css.declaration.method.gutter=方法{0, choice, 1#有|2#有}  个关联的 css {0, choice, 1#元素|2#元素}

popup.title.css.file.goto=<html><body>为 <b>{0}</b> 选择文件(找到 {1} 个文件)</body></html>
tooltip.text.css.file.gutter=类{0, choice, 1#有|2#有} {0} 个关联的 css {0, choice, 1#文件|2#文件}
label.text.event.class.name=事件类名(&E):
label.text.handler.class.name=处理程序类名(&H):
label.text.event.handler.method.name=处理方法名称(&M):

popup.title.ui.xml.file.goto=<html><body>为 <b>{0}</b> 选择 ui.xml 文件(找到 {1} 个文件)</body></html>
tooltip.text.ui.xml.file.gutter=类{0, choice, 1#有|2#有} {0} 个关联的 ui.xml {0, choice, 1#文件|2#文件}
popup.title.ui.tag.file.goto=<html><body>为 <b>{0}</b> 字段选择 ui.xml 文件(找到 {1} 个文件)</body></html>
tooltip.text.ui.tag.file.gutter=字段在 {0} 个 ui.xml {0, choice, 1#文件|2#文件}中{0, choice, 1#有|2#有} 个关联的{0, choice, 1#标签|2#标签}


gwt.intention.category=Google Web Toolkit

exportable.GwtSdkManager.presentable.name=GWT SDK

checkbox.text.separate.methods=为每个字段生成单独的方法(&S)

gwt.insufficient.language.level={0} (由 GWT Facet 配置)

gwt.notification.display.id=GWT
implementation.provided=由 GWT 提供实现

action.GWT.GenerateUiHandlerMethod.text=@UiHandler 方法…
action.GWT.NewSerialClass.text=GWT 可序列化类
action.GWT.NewSerialClass.description=创建实现 IsSerializable 的新 GWT 类
action.GWT.NewRemoteService.text=GWT 远程服务
action.GWT.NewRemoteService.description=创建扩展 RemoteService、对应的异步版本和实现类的新 GWT 接口
action.GWT.GenerateCompileReport.text=生成 GWT 编译报告…
action.GWT.GenerateCompileReport.description=运行 GWT 编译器以生成编译报告，并在浏览器中打开结果
action.GWT.NewUiBinder.text=GWT UiBinder 和 ui.xml 文件
action.GWT.NewUiRenderer.text=GWT UiRenderer 和 ui.xml 文件
action.GWT.NewEventWithHandler.text=GWT 事件和处理程序类
action.GWT.NewEntryPoint.text=GWT 入口点
action.GWT.NewEntryPoint.description=创建扩展 EntryPoint 的新 GWT 类
action.GWT.NewModule.text=GWT 模块
action.GWT.NewModule.description=创建新的 GWT 模块框架
action.GWT.NewTestCase.text=GWT 测试用例
group.GWT.text=Google Web Toolkit

message.text.gwt.module.chooser.isn.t.available.while.updating.indices=在 {0} 更新索引期间，GWT 模块选择器不可用
dialog.title.choose.gwt.modules.to.load=选择要加载的 GWT 模块
label.none.facet.selected=<none>
dialog.title.no.gwt.modules.found.in.the.project=在项目中找不到 GWT 模块
intention.text.create.uihandler.for.tag=为标记创建 '@UiHandler'
label.text.0.is.used=使用了 {0}
content.display.name.server=服务器
content.display.name.modules=模块
content.display.name.dev.mode=开发模式
psi.viewer.name.gwt.ui.xml.file=GWT ui.xml 文件
popup.step.title.select.artifact=选择工件
validation.result.gwt.compiler.output.is.not.included.in.an.artifact=GWT 编译器输出未包含在工件中
validation.result.gwt.servlet.jar.is.not.included.in.0.artifact=gwt-servlet.jar 不包含在工件 ''{0}'' 中
task.title.updating.gwt.dev.mode.resources=正在更新 GWT 开发模式资源
progress.indicator.copying.files=正在复制文件…
progress.indicator.deleting.obsolete.files=正在删除过时的文件…
progress.indicator.processing.files=正在处理文件…
task.title.preparing.war.directory.for.gwt.dev.mode=为 GWT 开发模式准备 WAR 目录
problem.descriptor.description.template.expected.0.but.1.found=应为 ''{0}''，但实际为 ''{1}''
problem.descriptor.description.template.uifield.0.should.not.be.private=@UiField ''{0}'' 不应为 ''private''
problem.descriptor.description.template.0.is.not.annotated.with.uifield=''{0}'' 未使用 @UiField 进行注解
problem.descriptor.description.template.0.field.is.not.bound.to.tag.in.1.file=''{0}'' 字段未绑定到 ''{1}'' 文件中的标记
problem.descriptor.description.template.duplicate.declaration.bound.to.0.field=绑定到 ''{0}'' 字段的声明重复
problem.descriptor.description.template.uibinder.class.not.found.for.0=找不到 ''{0}'' 的 UiBinder 类
problem.descriptor.description.template.cannot.resolve.0.field=无法解析 ''{0}'' 字段
problem.descriptor.description.template.handler.0.cannot.be.registered.methods.1.and.2.are.ambiguous=无法注册处理程序 ''{0}'': 方法 ''{1}'' 和 ''{2}'' 不明确
problem.descriptor.description.template.field.0.does.not.have.addhandler.method.for.1=字段 ''{0}'' 没有用于 ''{1}'' 的 ''addHandler'' 方法
problem.descriptor.description.template.handler.method.0.signature.does.not.match.1.signature=处理程序方法 ''{0}'' 签名与 ''{1}'' 签名不匹配
problem.descriptor.description.template.handler.class.0.1=处理程序类 ''{0}'' {1, choice, 0#没有方法|2#定义了一个以上的方法}
problem.descriptor.description.template.cannot.get.eventhandler.type.for.0=无法获取 ''{0}'' 的 EventHandler 类型
problem.descriptor.description.template.cannot.get.eventhandler.type.for.02=无法获取 ''{0}'' 的 EventHandler 类型
problem.descriptor.description.template.parameter.0.is.not.an.event.subclass.of.gwtevent=形参 ''{0}'' 不是事件(GwtEvent 的子类)
problem.descriptor.description.template.uihandler.0.must.have.a.single.event.parameter.defined=@UiHandler ''{0}'' 必须只定义一个事件参数
problem.descriptor.description.template.uihandler.0.must.have.at.least.one.parameter.defined=@UiHandler ''{0}'' 必须至少定义一个参数
problem.descriptor.description.template.uihandler.0.should.not.be.private=''@UiHandler ''{0}'' 不应为 ''private''
intention.text.create.uifield.for.tag=为标记创建 '@UiField'
dialog.message.incorrect.number.of.type.parameters.in.0.class={0} 类中的类型形参数量不正确。
dialog.message.0.class.not.found=找不到 {0} 类。
action.ViewReportAction.text=查看报告
label.text.compile.report.was.generated.0.ago=编译报告于 {0}前生成
button.text.generate=生成
dialog.title.generate.gwt.compile.report=生成 GWT 编译报告
label.text.download.gwt=下载 GWT
label.text.gwt.sdk.path.not.specified=未指定 GWT SDK 路径。
task.title.looking.for.changed.classes=正在查找更改的类
running.app.updater.description.update.0=更新 ''{0}''
dialog.message.root.element.type.is.not.specified=未指定根元素类型
dialog.message.cannot.create.sample.gwt.application.0=无法创建示例 GWT 应用程序: {0}
library.presentation.description=GWT SDK 库
gwt.compiler.deploy.output.element.type.name=GWT 编译器部署输出
gwt.compiler.output.element.type.dialog.title=选择模块
gwt.compiler.output.element.type.dialog.description=选择包含 GWT Facet 的模块
gwt.compiler.output.element.type.name=GWT 编译器输出
popup.title.choose.css.file=选择 CSS 文件
command.create.sample.gwt.project.files=创建示例 GWT 项目文件
notification.content.gwt.file.mapping.is.not.possible.during.index.update=在索引更新期间无法进行 GWT 文件映射
artifact.node.gwt.compiler.output=GWT 编译器输出
artifact.node.gwt.deploy.output=GWT 部署输出
quickfix.text.include.in.artifact=包含在工件中
quickfix.text.include.into.0=包含到 ''{0}'' 中
quickfix.text.create.artifact=创建工件
tooltip.gwt.modules.without.entry.points.cannot.be.compiled=无法编译没有入口点的 GWT 模块
dialog.title.select.event.type=选择事件类型
dialog.title.choose.fields.to.generate.handler.for=选择要为其生成处理程序的字段
label.gwt.0.sdk.from.maven.repository=来自 Maven 仓库的 GWT {0} SDK
notification.content.unable.to.configure.gwt.unit.tests.during.index.update=在索引更新期间无法配置 GWT 单元测试
dialog.title.select.type.of.root.element=选择根元素的类型
inspection.message.0.is.deprecated.in.gwt.1.6=''{0}'' 在 GWT 1.6 中被弃用
label.text.gwt.0.sdk.from.gradle.repository=来自 Gradle 的 GWT {0} SDK
status.bar.text.gwt.dev.mode.resources.for.0.updated=''{0}'' 的 GWT 开发模式资源{2, choice, 0#已于 {1} 更新|1#已处于最新状态}
tab.title.0.gwt.output=''{0}'' GWT 输出
inspection.message.assignment.to.uifield.annotated.field.will.be.ignored=对 @UiField 注解字段的赋值将被忽略，因为它由 UiBinder 初始化
quickfix.name.create.missing.methods=创建缺少的方法
inspection.message.0.css.classes.do.not.have.corresponding.methods={0} CSS 类没有对应的方法
quickfix.name.create.method.for.0=为 ''{0}'' 创建方法
inspection.message.css.class.0.does.not.have.corresponding.method=CSS 类 ''{0}'' 没有对应的方法
quickfix.name.0.css.class.or.def.element.not.found=找不到 ''{0}'' css 类或 ''@def'' 元素
item.text.0.and.more.modules={0} 和{2, choice, 0#其他 1 个模块|1#其他 {1} 个模块}
error.message.0.parameter.used.without.corresponding.war=使用的 {0} 参数时未使用对应的 -war
error.message.cannot.create.socket.0=无法创建套接字: {0}
error.message.unknown.gwt.dev.mode.server.0=未知的 GWT 开发模式服务器: {0}
inspection.message.0.subpackage.is.not.registered.as.1.path.in.2=''{0}'' 子软件包未在 ''{2}'' 中作为 {1} 路径进行注册
console.message.dev.mode.initialized.startup.urls=开发模式已初始化{0, choice, 0#|1#。启动 URL:|2#。启动 URL:}
parsing.error.rule.expected=应为规则
checkbox.create.html.and.css.files.in.directory=在目录中创建 HTML 和 CSS 文件(&C)
checkbox.show.compiler.output=显示编译器输出(&S)
label.gwt.modules.are.not.available.while.index.update.is.in.progress=GWT 模块在索引更新期间不可用
label.label=标签
checkbox.create.sample.application=创建示例应用程序(&C)
label.gwt.sdk=GWT SDK:
label.gwt.module=GWT 模块(&G):
checkbox.update.resources.on.frame.deactivation=切换出IDE时更新资源(&U)
checkbox.open.in.browser=在浏览器中打开(&B):
label.server=服务器(&R):
checkbox.use.super.dev.mode=使用超级开发模式
checkbox.with.javascript.debugger=使用 JavaScript 调试器
label.module=模块:

inspection.GwtDeprecatedEventListeners.name=使用弃用的事件侦听器
inspection.GwtUiFieldErrors.name=包含 '@UIField' 注解的不一致字段
inspection.GwtUiHandlerErrors.name=包含 '@UiHandler' 注解的不一致方法
inspection.GwtUiBinderErrors.name='UiBinder' 接口的不一致实现
inspection.GwtDefaultPackageNotRegistered.name='client' 软件包或 'public' 目录未在 gwt.xml 文件中注册
inspection.GwtUiFieldAssignment.name=赋值给包含 '@UiField' 注解的字段
inspection.GwtCssResourceErrors.name=扩展 'CssResource' 的不一致接口
action.GWT.NewUiBinder.description=创建一个扩展 UiBinder 的类和相应的 ui.xml 文件
action.GWT.NewUiRenderer.description=创建一个扩展 UiRenderer 的类和相应的 ui.xml 文件
action.GWT.NewEventWithHandler.description=创建一个扩展 GwtEvent 的类和相应的扩展 EventHandler 的类
action.GWT.NewTestCase.description=创建一个扩展 GWTTestCase 的新类
action.GWT.GenerateCompileReport.description=运行 GWT 编译器以生成编译报告，并在浏览器中打开结果
action.GWT.GenerateCompileReport.text=生成 GWT 编译报告…
action.GWT.GenerateUiHandlerMethod.text=@UiHandler 方法…
action.GWT.NewEntryPoint.description=创建扩展 EntryPoint 的新 GWT 类
action.GWT.NewEntryPoint.text=GWT 入口点
action.GWT.NewEventWithHandler.description=创建一个扩展 GwtEvent 的类和相应的扩展 EventHandler 的类
action.GWT.NewEventWithHandler.text=GWT 事件和处理程序类
action.GWT.NewModule.description=创建新的 GWT 模块框架
action.GWT.NewModule.text=GWT 模块
action.GWT.NewRemoteService.description=创建扩展 RemoteService、对应的异步版本和实现类的新 GWT 接口
action.GWT.NewRemoteService.text=GWT 远程服务
action.GWT.NewSerialClass.description=创建实现 IsSerializable 的新 GWT 类
action.GWT.NewSerialClass.text=GWT 可序列化类
action.GWT.NewTestCase.description=创建一个扩展 GWTTestCase 的新类
action.GWT.NewTestCase.text=GWT 测试用例
action.GWT.NewUiBinder.description=创建一个扩展 UiBinder 的类和相应的 ui.xml 文件
action.GWT.NewUiBinder.text=GWT UiBinder 和 ui.xml 文件
action.GWT.NewUiRenderer.description=创建一个扩展 UiRenderer 的类和相应的 ui.xml 文件
action.GWT.NewUiRenderer.text=GWT UiRenderer 和 ui.xml 文件
action.ViewReportAction.text=查看报告
action.name.create.gwt.event.with.handler=创建 GWT 事件 ''{0}'' 及其处理程序类
action.name.create.gwt.uibinder.0.and.1.ui.xml.file=创建 GWT UiBinder ''{0}'' 和 ''{1}.ui.xml'' 文件
action.name.create.gwt.uirenderer.0.and.1.ui.xml.file=创建 GWT UiRenderer ''{0}'' 和 ''{1}.ui.xml'' 文件
action.progress.creating.gwt.test.case.0=创建 GWT 测试用例 ''{0}''
artifact.node.gwt.compiler.output=GWT 编译器输出
artifact.node.gwt.deploy.output=GWT 部署输出
border.title.gwt.compilation=GWT 编译
button.text.generate=生成
checkbox.create.html.and.css.files.in.directory=在目录中创建 HTML 和 CSS 文件(&C)
checkbox.create.sample.application=创建示例应用程序(&C)
checkbox.open.in.browser=在浏览器中打开(&B)\:
checkbox.show.compiler.output=显示编译器输出(&S)
checkbox.text.report.interfaces=报告接口
checkbox.text.separate.methods=为每个字段生成单独的方法(&S)
checkbox.text.use.custom.web.xml=使用自定义 'web.xml' 描述符的内容(&W)
checkbox.update.resources.on.frame.deactivation=切换出 IDE 时更新资源(&U)
checkbox.use.super.dev.mode=使用超级开发模式
checkbox.with.javascript.debugger=使用 JavaScript 调试器
choose.text.select.gwt.module=选择 GWT 模块\:
command.create.sample.gwt.project.files=创建示例 GWT 项目文件
console.message.dev.mode.initialized.startup.urls=开发模式已初始化{0, choice, 0\#|1\#。启动 URL\:|2\#。启动 URL\:}
content.display.name.dev.mode=开发模式
content.display.name.modules=模块
content.display.name.server=服务器
css.usages.variable=变量
default.gwt.run.configuration.name=未命名
dialog.caption.gwt.dev.mode.parameters=GWT 开发模式形参
dialog.caption.vm.parameters=虚拟机选项
dialog.message.0.class.not.found=找不到 {0} 类。
dialog.message.cannot.create.sample.gwt.application.0=无法创建示例 GWT 应用程序\: {0}
dialog.message.incorrect.number.of.type.parameters.in.0.class={0} 类中的类型形参数量不正确。
dialog.message.root.element.type.is.not.specified=未指定根元素类型
dialog.promt.enter.name.for.gwt.test.case=输入 GWT 测试用例的名称\:
dialog.title.choose.fields.to.generate.handler.for=选择要为其生成处理程序的字段
dialog.title.choose.gwt.module=GWT 模块
dialog.title.choose.gwt.modules.to.load=选择要加载的 GWT 模块
dialog.title.create.gwt.event.with.handler=创建新的 GWT 事件和处理程序类
dialog.title.create.new.gwt.uibinder.class.and.ui.xml.file=创建新的 GWT UiBinder 类和 ui.xml 文件
dialog.title.create.new.gwt.uirenderer.class.and.ui.xml.file=创建新的 GWT UiRenderer 类和 ui.xml 文件
dialog.title.generate.gwt.compile.report=生成 GWT 编译报告
dialog.title.google.web.toolkit=Google Web Toolkit
dialog.title.new.gwt.test.case=新建 GWT 测试用例
dialog.title.no.gwt.modules.found.in.the.project=在项目中找不到 GWT 模块
dialog.title.select.event.type=选择事件类型
dialog.title.select.type.of.root.element=选择根元素的类型
error.class.not.found.in.jar=在 ''{1}'' 中找不到类 ''{0}''
error.file.not.found.message=找不到文件 ''{0}''
error.invalid.gwt.installation.message=''{0}'' 不是有效的 GWT 安装\: {1}
error.message.0.is.not.under.public.roots.of.gwt.modules.nor.under.web.roots=''{0}'' 不在 GWT 模块的 ''public'' 根目录下，也不在 Web 根目录下，因此无法在托管模式浏览器中打开。
error.message.0.parameter.used.without.corresponding.war=使用的 {0} 形参时未使用对应的 -war
error.message.cannot.create.socket.0=无法创建套接字\: {0}
error.message.gwt.event.not.supported=GWT 1.6 或更高版本支持 GwtEvent
error.message.gwt.user.jar.in.library.0.does.not.correspond.to.selected.gwt.installation=库 ''{0}'' 中的 gwt-user.jar 与所选 GWT 安装不相符
error.message.gwt.user.jar.library.not.found.in.dependencies.of.module=在模块的依赖项中找不到 gwt-user.jar 库
error.message.path.to.gwt.sdk.must.not.contain.character=GWT SDK 路径不得包含 '\!' 字符
error.message.set.service.entry.point.method.call.can.be.replaced.by.remote.service.relative.path.annotation='setServiceEntryPoint()' 方法调用可被替换为 '@RemoteServiceRelativePath' 注解
error.message.set.service.entry.point.method.call.is.redundant='setServiceEntryPoint()' 方法调用冗余，因为入口点由 '@RemoteServiceRelativePath' 注解指定
error.message.this.action.is.allowed.only.for.client.side.packages.of.a.gwt.module=此操作仅适用于 GWT 模块的客户端软件包
error.message.uibinder.is.supported.in.gwt.2.0.or.later=GWT 2.0 或更高版本支持 UiBinder
error.message.uirenderer.is.supported.in.gwt.2.5.or.later=GWT 2.5 或更高版本支持 UiRenderer
error.message.unknown.gwt.dev.mode.server.0=未知的 GWT 开发模式服务器\: {0}
error.text.gwt.facet.not.configured.in.module.0=未为模块 ''{0}'' 配置 GWT Facet
error.text.gwt.sdk.is.not.specified.correctly=在模块 ''{0}'' 的 GWT Facet 设置中未正确指定 GWT SDK 路径
error.text.no.gwt.modules.in.module.0=在 ''{0}'' 中找不到 GWT 模块
exportable.GwtSdkManager.presentable.name=GWT SDK
file.template.group.title.gwt=Google Web Toolkit
fix.download.gwt=下载 GWT…
framework.title.google.web.toolkit=Google Web 工具包(&G)
google.web.toolkit.title=Google Web Toolkit
group.GWT.description=Google Web Toolkit
group.GWT.text=Google Web Toolkit
group.gwt.inspections.name=Google Web Toolkit
gwt.compiler.deploy.output.element.type.name=GWT 编译器部署输出
gwt.compiler.output.element.type.dialog.description=选择包含 GWT Facet 的模块
gwt.compiler.output.element.type.dialog.title=选择模块
gwt.compiler.output.element.type.name=GWT 编译器输出
gwt.installation.chooser.description=请指定 GWT 安装目录的路径
gwt.installation.chooser.title=GWT 安装目录路径
gwt.insufficient.language.level={0} (由 GWT Facet 配置)
gwt.intention.category=Google Web Toolkit
gwt.notification.display.id=GWT
gwt.searching.for.implementations=正在搜索实现…
i18n.class.gutter.tooltip.text=类有 {0} 个关联的属性 {0, choice, 1\#文件|2\#文件}
i18n.goto.property.popup.title=<html><body>选择 <b>{0}</b> 的本地化(找到 {1} 个文件)</body></html>
i18n.interface.method.gutter.tooltip=<html><body>方法在 {0} {0, choice, 1\#个文件|2\#个文件}中有关联的属性
implementation.provided=由 GWT 提供实现
inspection.GwtCssResourceErrors.name=扩展 'CssResource' 的不一致接口
inspection.GwtDefaultPackageNotRegistered.name='client' 软件包或 'public' 目录未在 gwt.xml 文件中注册
inspection.GwtDeprecatedEventListeners.name=使用弃用的事件侦听器
inspection.GwtUiBinderErrors.name='UiBinder' 接口的不一致实现
inspection.GwtUiFieldAssignment.name=赋值给包含 '@UiField' 注解的字段
inspection.GwtUiFieldErrors.name=包含 '@UIField' 注解的不一致字段
inspection.GwtUiHandlerErrors.name=包含 '@UiHandler' 注解的不一致方法
inspection.message.0.css.classes.do.not.have.corresponding.methods={0} CSS 类没有对应的方法
inspection.message.0.is.deprecated.in.gwt.1.6=''{0}'' 在 GWT 1.6 中被弃用
inspection.message.0.subpackage.is.not.registered.as.1.path.in.2=''{0}'' 子软件包未在 ''{2}'' 中作为 {1} 路径进行注册
inspection.message.assignment.to.uifield.annotated.field.will.be.ignored=对 @UiField 注解字段的赋值将被忽略，因为它由 UiBinder 初始化
inspection.message.css.class.0.does.not.have.corresponding.method=CSS 类 ''{0}'' 没有对应的方法
inspection.name.classes.not.from.jre.emulation.library.in.client.code=使用 JRE Emulation Library 中不存在的类和方法
inspection.name.client.class.from.non.inherited.module.usage=使用未继承的 GWT 模块中的客户端类
inspection.name.deprecated.gwt.key.tag.in.javadoc.comments=JavaDoc 注释中的已弃用 '@gwt.key' 标记
inspection.name.gwt.remote.service.is.not.registered.in.web.xml=GWT 远程服务未在 web.xml 中注册
inspection.name.inconsistent.gwt.localizable.interface=不一致的可本地化接口
inspection.name.inconsistent.gwt.remote.service=不一致的远程服务
inspection.name.incorrect.argument.of.gwt.create.method=不正确的 GWT.create() 方法实参
inspection.name.incorrect.java.methods.calls.in.js=从 JavaScript 代码中不正确调用 Java 方法
inspection.name.incorrect.serializable.class=不正确的可序列化类
inspection.name.method.with.parameters.in.interface.extending.constants=接口扩展 Constants 中带有形参的方法
inspection.name.non.serializable.service.method.parameters=不可序列化的服务方法形参类型或返回值类型
inspection.name.obsolete.gwt.type.args.tag.in.javadoc.comments=JavaDoc 注释中的已弃用 '@gwt.typeArgs' 标记
inspection.name.overlay.type.restrictions.violated=违反覆盖类型限制
inspection.name.raw.use.of.async.callback.in.asynchronous.service.interfaces=在异步服务接口中原始使用 AsyncCallback
inspection.name.redundant.set.service.entry.point.methods.calls=冗余的 'setServiceEntryPoint()' 方法调用
inspection.name.unresolved.references.in.jsni.methods=JSNI 方法中未解析的引用
inspection.name.unresolved.references.in.ui.xml.files=ui.xml 文件中未解析的引用
inspection.name.unresolved.references.to.html.tags=对 html 标记的未解析引用
inspection.unresolved.references.to.css.classes.display.name=对 CSS 类的未解析引用
intention.text.create.uifield.for.tag=为标记创建 '@UiField'
intention.text.create.uihandler.for.tag=为标记创建 '@UiHandler'
item.text.0.and.more.modules={0} 和{2, choice, 0\#其他 1 个模块|1\#其他 {1} 个模块}
label.choose.module.text=模块(&M)\:
label.gwt.0.sdk.from.maven.repository=来自 Maven 仓库的 GWT {0} SDK
label.gwt.module=GWT 模块(&G)\:
label.gwt.modules.are.not.available.while.index.update.is.in.progress=GWT 模块在索引更新期间不可用
label.gwt.sdk=GWT SDK\:
label.html.to.open.text=起始页面(&P)\:
label.label=标签
label.module=模块\:
label.none.facet.selected=<none>
label.select.script.output.style.text=JavaScript 输出样式(&O)\:
label.select.web.facet.text=目标 Web Facet(&W)\:
label.server=服务器(&R)\:
label.text.0.is.used=使用了 {0}
label.text.additional.compiler.parameters=附加编译器虚拟机选项(&A)\:
label.text.compile.report.was.generated.0.ago=编译报告于 {0}前生成
label.text.download.gwt=下载 GWT
label.text.enter.name.for.new.gwt.uibinder.class.and.ui.xml.file=输入新的 GWT UiBinder 类和 ui.xml 文件的名称(&E)\:
label.text.enter.name.for.new.gwt.uirenderer.class.and.ui.xml.file=输入新的 GWT UiRenderer 类和 ui.xml 文件的名称(&E)\:
label.text.event.class.name=事件类名(&E)\:
label.text.event.handler.method.name=处理方法名称(&M)\:
label.text.gwt.0.sdk.from.gradle.repository=来自 Gradle 的 GWT {0} SDK
label.text.gwt.compiler.heap.size=编译器堆大小上限 (Mb)(&H)\:
label.text.gwt.compiler.parameters=编译器形参(&C)\:
label.text.gwt.dev.mode.parameters=开发模式形参(&D)\:
label.text.gwt.module.to.load=要加载的 GWT 模块(&G)\:
label.text.gwt.sdk.path.not.specified=未指定 GWT SDK 路径。
label.text.handler.class.name=处理程序类名(&H)\:
label.text.path.to.gwt.installation=GWT 安装目录路径(&P)\:
label.text.select.root.element.type=指定根元素的类型(&S)\:
label.text.vm.parameters=虚拟机选项(&V)\:
library.presentation.description=GWT SDK 库
message.text.gwt.module.chooser.isn.t.available.while.updating.indices=GWT 模块选择器目前不可用，正在分析项目…
new.entry.point.dlg.prompt=输入新 GWT 入口点的名称
new.entry.point.dlg.title=新建 GWT 入口点
new.entry.point.progress.text=正在创建 GWT EntryPoint ''{0}''
new.module.dlg.prompt=输入新 GWT 模块的名称(&E)
new.module.dlg.title=新建 GWT 模块
new.module.progress.text=正在创建 GWT 模块 ''{0}''
new.serial.dlg.prompt=输入新的 GWT 可序列化类的名称
new.serial.dlg.title=新建 GWT 可序列化类
new.serial.progress.text=正在创建 GWT 可序列化类 ''{0}''
new.service.dlg.prompt=输入新 GWT 远程服务的名称
new.service.dlg.title=新建 GWT 远程服务
new.service.progress.text=创建 GWT 远程服务 ''{0}''
notification.content.gwt.file.mapping.is.not.possible.during.index.update=在索引更新期间无法进行 GWT 文件映射
notification.content.unable.to.configure.gwt.unit.tests.during.index.update=在索引更新期间无法配置 GWT 单元测试
parsing.error.rule.expected=应为规则
popup.step.title.select.artifact=选择工件
popup.title.choose.css.file=选择 CSS 文件
popup.title.css.class.method.goto=<html><body>为 <b>{0}</b> 方法选择文件(找到 {1} 个文件)</body></html>
popup.title.css.file.goto=<html><body>为 <b>{0}</b> 选择文件(找到 {1} 个文件)</body></html>
popup.title.resource.method.goto=<html><body>为 <b>{0}</b> 选择文件(找到 {1} 个文件)</body></html>
popup.title.ui.tag.file.goto=<html><body>为 <b>{0}</b> 字段选择 ui.xml 文件(找到 {1} 个文件)</body></html>
popup.title.ui.xml.file.goto=<html><body>为 <b>{0}</b> 选择 ui.xml 文件(找到 {1} 个文件)</body></html>
problem.description.0.is.not.a.checked.exception=''{0}'' 不是检查过的例外
problem.description.ambiguous.wildcard.match=不明确的通配符匹配\: ''{2}'' 中的 ''{0}'' 和 ''{1}'' 都与 ''{3}'' 匹配
problem.description.async.method.does.not.have.sync.variant=方法 ''{0}'' 没有相应的同步变体
problem.description.async.remote.service.0.does.not.define.corresponding.method=异步远程服务 ''{0}'' 未定义相应的方法
problem.description.cannot.call.instance.method.without.object.instance=没有对象实例，无法调用实例方法 ''{0}''
problem.description.cannot.resolve.0=无法解析 ''{0}''
problem.description.cannot.resolve.symbol.0.in.1=无法解析 ''{1}'' 中的符号 ''{0}''
problem.description.class.0.is.defined.in.module.1.which.is.not.inherited.in.module.2=类 ''{0}'' 在模块 ''{1}'' 中定义，而该模块在模块 ''{2}'' 中未被继承
problem.description.class.0.is.not.presented.in.jre.emulation.library=JRE 仿真库中不存在类 ''{0}''，因此不能在 ''{1}'' GWT 模块的客户端代码中使用
problem.description.class.is.not.widget=类 ''{0}'' 未实现 ''IsWidget'' 接口
problem.description.constructor.in.overlay.type.cannot.have.parameters=覆盖类型中的构造函数不能有形参
problem.description.constructor.in.overlay.type.must.be.protected=覆盖类型中的构造函数必须为 protected
problem.description.constructor.in.overlay.type.must.have.empty.body=覆盖类型中的构造函数的主体必须为空
problem.description.correct.servlet.mapping.is.not.specified.for.remote.service.0=没有为远程服务 ''{0}'' 指定正确的 servlet 映射
problem.description.field.0.is.not.serializable=类型 ''{0}'' 不可序列化
problem.description.generics.isnt.supported.in.gwt.before.1.5.version=1.5 版之前的 GWT 不支持泛型
problem.description.gwt.key.tag.is.deprecated.in.gwt.1.5='@gwt.key' 标记在 GWT 1.5 中被弃用
problem.description.gwt.serializable.type.0.should.implements.marker.interface.1=类型 ''{0}'' 未实现标记接口 {1}
problem.description.gwt.type.args.tag.is.obsolete.in.gwt.1.5='@gwt.typeArgs' 标记在 GWT 1.5 中被弃用
problem.description.html.tag.with.id.0.is.not.found=找不到 ID 为 ''{0}'' 的 HTML 标记
problem.description.inconsistent.element.type=UiBinder 接口形参与 ''{0}'' 标记不一致。应为 ''{1}'' 或其超类
problem.description.incorrect.number.of.arguments.for.method=''{0}'' 方法的实参数量不正确\: 应为 {1} 个，但实际为 {2} 个
problem.description.incorrect.servlet.mapping.for.remote.service.0=远程服务 ''{0}'' 的 URL 格式不正确
problem.description.inner.classes.in.overlay.type.must.be.static=覆盖类型中的内部类必须为 static
problem.description.instance.methods.in.overlay.type.must.be.final=覆盖类型中的实例方法必须为 final
problem.description.method.0.does.not.have.corresponding.property=方法 ''{0}'' 没有对应的属性
problem.description.method.0.is.not.presented.in.jre.emulation.library=JRE 仿真库中不存在方法 ''{0}''，因此不能在 ''{1}'' GWT 模块的客户端代码中使用
problem.description.methods.of.async.remote.service.0.isn.t.synchronized.with.1=异步远程服务 ''{0}'' 的方法与 ''{1}'' 不一致
problem.description.methods.with.parameters.are.not.allowed.in.an.interface.extending.constants=接口扩展 Constants 中不允许使用带有形参的方法
problem.description.only.class.literals.may.be.used.as.arguments.to.gwt.create=只能将类字面量用作 GWT.create() 的实参
problem.description.overlay.type.cannot.have.instance.fields=覆盖类型不能包含实例字段
problem.description.overlay.type.must.have.protected.empty.no.arg.constructor=覆盖类型必须具有不带形参的 protected 空构造函数
problem.description.properties.with.parameters.are.not.allowed.if.the.associated.interface.extends.constants=如果关联接口扩展 Constants，则不允许使用带有形参的属性
problem.description.property.0.does.not.have.corresponding.method.in.1=属性 ''{0}'' 在 ''{1}'' 中没有对应的方法
problem.description.raw.use.of.async.callback.interface=在方法 ''{0}'' 中原始使用 AsyncCallback 接口
problem.description.remote.service.0.does.not.have.corresponding.async.variant=远程服务 ''{0}'' 没有相应的异步变体
problem.description.remote.service.is.not.registered.as.a.servlet.in.web.xml=远程服务 ''{0}'' 未在 web.xml 中注册为 servlet。
problem.description.serializable.class.should.provide.public.no.args.constructor=可序列化的类应提供 public 无实参构造函数
problem.description.the.asynchronous.version.of.method.0.must.have.a.return.type.void=方法 ''{0}'' 的异步版本必须具有返回值类型 ''void''、\n''com.google.gwt.http.client.Request'' 或 ''com.google.gwt.http.client.RequestBuilder''
problem.description.type.is.not.serializable=类型 ''{0}'' 不可序列化
problem.description.type.of.collection.elements.is.not.specified=未指定 ''{0}'' 元素的类型
problem.description.ui.xml.not.found=UiBinder 接口没有对应的 ui.xml 文件
problem.description.ui.xml.root.ambiguity=在对应的 ui.xml 文件中检测到过多根标记
problem.description.ui.xml.root.not.found=无法在对应的 ui.xml 文件中检测到根标记
problem.description.unknown.css.class=未知 CSS 类 ''{0}''
problem.descriptor.description.template.0.field.is.not.bound.to.tag.in.1.file=''{0}'' 字段未绑定到 ''{1}'' 文件中的标记
problem.descriptor.description.template.0.is.not.annotated.with.uifield=''{0}'' 未使用 @UiField 进行注解
problem.descriptor.description.template.cannot.get.eventhandler.type.for.0=无法获取 ''{0}'' 的 EventHandler 类型
problem.descriptor.description.template.cannot.get.eventhandler.type.for.02=无法获取 ''{0}'' 的 EventHandler 类型
problem.descriptor.description.template.cannot.resolve.0.field=无法解析 ''{0}'' 字段
problem.descriptor.description.template.duplicate.declaration.bound.to.0.field=绑定到 ''{0}'' 字段的声明重复
problem.descriptor.description.template.expected.0.but.1.found=应为 ''{0}''，但实际为 ''{1}''
problem.descriptor.description.template.field.0.does.not.have.addhandler.method.for.1=字段 ''{0}'' 没有用于 ''{1}'' 的 ''addHandler'' 方法
problem.descriptor.description.template.handler.0.cannot.be.registered.methods.1.and.2.are.ambiguous=无法注册处理程序 ''{0}''\: 方法 ''{1}'' 和 ''{2}'' 不明确
problem.descriptor.description.template.handler.class.0.1=处理程序类 ''{0}'' {1, choice, 0\#没有方法|2\#定义了一个以上的方法}
problem.descriptor.description.template.handler.method.0.signature.does.not.match.1.signature=处理程序方法 ''{0}'' 签名与 ''{1}'' 签名不匹配
problem.descriptor.description.template.parameter.0.is.not.an.event.subclass.of.gwtevent=形参 ''{0}'' 不是事件(GwtEvent 的子类)
problem.descriptor.description.template.uibinder.class.not.found.for.0=找不到 ''{0}'' 的 UiBinder 类
problem.descriptor.description.template.uifield.0.should.not.be.private=@UiField ''{0}'' 不应为 ''private''
problem.descriptor.description.template.uihandler.0.must.have.a.single.event.parameter.defined=@UiHandler ''{0}'' 必须只定义一个事件形参
problem.descriptor.description.template.uihandler.0.must.have.at.least.one.parameter.defined=@UiHandler ''{0}'' 必须至少定义一个形参
problem.descriptor.description.template.uihandler.0.should.not.be.private=''@UiHandler ''{0}'' 不应为 ''private''
progress.indicator.copying.files=正在复制文件…
progress.indicator.deleting.obsolete.files=正在删除过时的文件…
progress.indicator.processing.files=正在处理文件…
psi.viewer.name.gwt.ui.xml.file=GWT ui.xml 文件
question.text.gwt.facet.is.not.configured.for.module.0.do.you.want.to.create.it=没有为模块 ''{0}'' 配置 GWT Facet。是否要创建?
quick.fix.name.rename.reference=重命名引用
quick.fix.name.synchronize.all.methods.of.0.with.1=将 ''{0}'' 的所有方法与 ''{1}'' 同步
quickfix.family.name.add.servlet.mapping.for.remote.service=为远程服务添加 servlet 映射
quickfix.family.name.change.field.type=更改字段类型
quickfix.family.name.connect.gwt.facet.and.register.remote.service.in.web.xml=连接 GWT Facet 并在 'web.xml' 中注册远程服务
quickfix.family.name.create.async.variant=创建异步变体
quickfix.family.name.create.css.class=创建 CSS 类
quickfix.family.name.create.def.declaration=创建 '@def' 声明
quickfix.family.name.create.interface=创建接口
quickfix.family.name.create.local.css.class=创建局部 CSS 类
quickfix.family.name.create.missing.methods=创建缺少的方法
quickfix.family.name.create.property=创建属性
quickfix.family.name.create.sync.variant=创建同步变体
quickfix.family.name.create.web.facet.and.register.remote.service.in.web.xml=创建 Web Facet 并在 'web.xml' 中注册远程服务
quickfix.family.name.generify.types.in.method=使用形参化类型
quickfix.family.name.inherit.from.messages.instead.of.constants=将 Constants 替换为 Messages
quickfix.family.name.inherit.module=继承模块
quickfix.family.name.make.method.return.void=使方法返回 'void'
quickfix.family.name.register.remote.service.in.web.xml=在 'web.xml' 中注册远程服务
quickfix.family.name.register.subpackage=注册子软件包
quickfix.family.name.replace.async.callback.by.generic.async.callback=泛化 'AsyncCallback'
quickfix.family.name.replace.gwt.key.tag.with.key.annotation=将 '@gwt.key' 标记替换为 @Key 注解
quickfix.family.name.replace.listener.with.handler=将侦听器替换为处理程序
quickfix.family.name.set.servlet.mapping.for.remote.service=为远程服务设置正确的 URL 格式
quickfix.name.0.css.class.or.def.element.not.found=找不到 ''{0}'' css 类或 ''@def'' 元素
quickfix.name.add.servlet.mapping.for.remote.service.0=为远程服务 ''{0}'' 添加 servlet 映射
quickfix.name.change.0.type.to.1=将 ''{0}'' 类型更改为 ''{1}''
quickfix.name.connect.gwt.facet.to.0.facet.and.register.remote.service.1.in.web.xml=将 GWT Facet 连接到 ''{0}'' Facet，并在 ''web.xml'' 中注册远程服务 ''{1}''
quickfix.name.create.0.method=创建 ''{0}'' 方法
quickfix.name.create.async.method.for.sync.0=为方法 ''{0}'' 创建异步变体
quickfix.name.create.css.class.0=创建 CSS 类 ''{0}''
quickfix.name.create.def.declaration.for.0=为 ''{0}'' 创建 ''@def'' 声明
quickfix.name.create.interface.0=创建接口 ''{0}''
quickfix.name.create.local.css.class.0=创建局部 CSS 类 ''{0}''
quickfix.name.create.method.for.0=为 ''{0}'' 创建方法
quickfix.name.create.method.for.property.0.in.1=为 ''{1}'' 中的属性 ''{0}'' 创建方法
quickfix.name.create.missing.methods=创建缺少的方法
quickfix.name.create.property.0=创建属性 ''{0}''
quickfix.name.create.sync.method.for.async.0=为方法 ''{0}'' 创建同步变体
quickfix.name.create.web.facet.and.register.remote.service.0.in.web.xml=创建 Web Facet 并在 ''web.xml'' 中注册远程服务 ''{0}''
quickfix.name.generify.types.in.method.0.instead.of.using.gwt.type.args.tags=在方法 ''{0}'' 中使用形参化类型，不使用 ''@gwt.typeArgs'' 标记
quickfix.name.inherit.0.from.messages.instead.of.constants=从消息而不是 Constants 继承 ''{0}''
quickfix.name.inherit.module.0.from.1=从 ''{1}'' 集成模块 ''{0}''
quickfix.name.make.0.return.void=使 ''{0}'' 返回 ''void''
quickfix.name.register.0.subpackage.as.1.path=将 ''{0}'' 子软件包注册为 {1} 路径
quickfix.name.register.remote.service.0.in.web.xml=在 ''web.xml'' 中注册远程服务 ''{0}''
quickfix.name.remove.redundant.set.service.entry.point.call=移除冗余的 'setServiceEntryPoint()' 调用
quickfix.name.replace.0.with.1=将 ''{0}'' 替换为 ''{1}''
quickfix.name.replace.async.callback.by.async.callback.0=将 ''AsyncCallback'' 替换为 ''AsyncCallback<{0}>''
quickfix.name.replace.gwt.key.tag.with.key.annotation.in.method.0=将 ''@gwt.key'' 标记替换为方法 ''{0}'' 中的 @Key 注解
quickfix.name.replace.set.service.entry.point.call.by.annotation=通过注解替换 'setServiceEntryPoint()' 调用
quickfix.name.set.correct.servlet.mapping.for.remote.service.0=为远程服务 ''{0}'' 设置正确的 URL 格式
quickfix.name.set.provided.to.true=将 'provided' 特性设置为 'true'
quickfix.name.synchronize.all.methods.in.0=将所有缺少的方法添加到 ''{0}''
quickfix.popup.title.choose.properties.file=选择属性文件
quickfix.text.create.artifact=创建工件
quickfix.text.include.in.artifact=包含在工件中
quickfix.text.include.into.0=包含到 ''{0}'' 中
run.gwt.configuration.description=GWT 配置
run.gwt.configuration.display.name=GWT 配置
running.app.updater.description.update.0=更新 ''{0}''
status.bar.text.gwt.dev.mode.resources.for.0.updated=''{0}'' 的 GWT 开发模式资源{2, choice, 0\#已于 {1} 更新|1\#已处于最新状态}
tab.title.0.gwt.output=''{0}'' GWT 输出
table.column.name.gwt.module=GWT 模块
table.column.name.output.relative.path=输出相对路径
task.title.looking.for.changed.classes=正在查找更改的类…
task.title.preparing.war.directory.for.gwt.dev.mode=为 GWT 开发模式准备 WAR 目录
task.title.updating.gwt.dev.mode.resources=正在更新 GWT 开发模式资源
text.0.or.1=''{0}'' 或 ''{1}''
text.gwt.modules.to.load.all=所有
text.gwt.modules.to.load.none=无
tooltip.gwt.modules.without.entry.points.cannot.be.compiled=无法编译没有入口点的 GWT 模块
tooltip.text.css.class.method.gutter=方法{0, choice, 1\#有|2\#有}  个关联的 css {0, choice, 1\#类|2\#类}
tooltip.text.css.declaration.method.gutter=方法{0, choice, 1\#有|2\#有}  个关联的 css {0, choice, 1\#元素|2\#元素}
tooltip.text.css.file.gutter=类{0, choice, 1\#有|2\#有} {0} 个关联的 css {0, choice, 1\#文件|2\#文件}
tooltip.text.resource.method.gutter=方法{0, choice, 1\#有|2\#有} {0} 个关联的资源{0, choice, 1\#文件|2\#文件}
tooltip.text.ui.tag.file.gutter=字段在 {0} 个 ui.xml {0, choice, 1\#文件|2\#文件}中{0, choice, 1\#有|2\#有} 个关联的{0, choice, 1\#标签|2\#标签}
tooltip.text.ui.xml.file.gutter=类{0, choice, 1\#有|2\#有} {0} 个关联的 ui.xml {0, choice, 1\#文件|2\#文件}
validation.result.gwt.compiler.output.is.not.included.in.an.artifact=GWT 编译器输出未包含在工件中
validation.result.gwt.servlet.jar.is.not.included.in.0.artifact=gwt-servlet.jar 不包含在工件 ''{0}'' 中

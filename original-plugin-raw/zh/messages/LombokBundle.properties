plugin.settings.title=Lombok
config.warn.dependency.outdated.title=Lombok 依赖项可能已过时
config.warn.dependency.outdated.message=<br>项目 "{0}" 似乎具有过时的 Lombok 依赖项。<br>已配置版本 "{1}"，但至少版本 "{2}" 已经发布<br><a href="https://projectlombok.org/download">也许您想进行更新?</a> <br>
replace.with.annotations.lombok=替换为注解(Lombok)
replace.0.with.explicit.type.lombok=将 ''{0}'' 替换为显式类型(Lombok)
replace.explicit.type.with.0.lombok=将显式类型替换为 ''{0}'' (Lombok)
dialog.message.logger.field.s.not.private.sfinal.field.named.s.refactor.anyway=记录程序字段: "{0}" 不是名称为 "{2}" 的 private {1, choice, 0#|1#static} final 字段。是否仍然重构?
dialog.title.attention=注意!
dialog.message.this.element.cannot.be.renamed=此元素不能被重命名。
inspection.message.lombok.annotation.deprecated.not.supported=Lombok 注解 ''{0}'' 已弃用，lombok-plugin 不再提供支持。请改用 ''{1}''。
inspection.message.default.constructor.doesn.t.exist=默认构造函数不存在
inspection.message.slf4j.logger.defined.explicitly=Slf4j 记录程序为显式定义。请改用 Lombok @Slf4j 注解。
intention.name.replace.with.lombok=替换为 Lombok
attribute.descriptor.key=键
attribute.descriptor.separator=分隔符
attribute.descriptor.value=值
configurable.name.lombok.config=Lombok 配置
filetype.lombok.config.description=Lombok 配置文件
inspection.message.annotation.not.lombok.copyable=Lombok 不会将注解 ''{0}'' 复制到构造函数中
inspection.message.val.works.only.on.local.variables='val' 仅适用于局部变量和 foreach 循环
inspection.message.var.works.only.on.local.variables.on.for.foreach.loops='val' 仅适用于局部变量和 for/foreach 循环
inspection.message.on.local.variable.requires.initializer.expression=局部变量上的 ''{0}'' 需要初始值设定项表达式
inspection.message.not.compatible.with.array.initializer.expressions=''{0}'' 与数组初始值设定项表达式不兼容。使用完整形式 (新的 int[] '{' ... '}'，而不只是 '{' ... '}')
inspection.message.not.allowed.with.lambda.expressions=Lambda 表达式不允许使用 ''{0}''。
inspection.message.not.allowed.in.old.style.for.loops=旧式 for 循环中不允许使用 ''{0}''
intention.name.create.new.field.s=创建新字段 ''{0}''
inspection.message.utility.class.already.marks.class.final=@UtilityClass 已将类标记为 final。
inspection.message.utility.class.already.marks.fields.static=@UtilityClass 已将字段标记为 static。
inspection.message.utility.class.already.marks.methods.static=@UtilityClass 已将方法标记为 static。
inspection.message.utility.class.already.marks.inner.classes.static=@UtilityClass 已将内部类标记为 static。
inspection.message.val.already.marks.variables.final='val' 已将变量标记为 final。
inspection.message.value.already.marks.class.final=@Value 已将类标记为 final。
inspection.message.value.already.marks.non.static.fields.final=@Value 已将非 static 字段标记为 final。
inspection.message.value.already.marks.non.static.package.local.fields.private=@Value 已将非 static 的 package-local 字段标记为 private。
inspection.message.cleanup.method.s.not.found.on.target.class='@Cleanup': 在目标类中找不到方法 '%s()'
inspection.message.cleanup.legal.only.on.local.variable.declaration.inside.block='@Cleanup': 仅在块内的局部变量声明上合法
inspection.message.cleanup.variable.declarations.need.to.be.initialized='@Cleanup' 变量声明需要初始化。
inspection.message.cleanup.value.cannot.be.empty.string='@Cleanup': 值不能为空字符串
inspection.message.cleanup.legal.only.on.local.variable.declarations='@Cleanup' 仅在局部变量声明上合法
inspection.message.synchronized.legal.only.on.concrete.methods='@Synchronized' 仅在具体方法上合法。
inspection.message.synchronization.on.non.final.field.s=在非 final 字段 %s 上同步。
inspection.message.field.s.does.not.exist=字段 %s 不存在。
inspection.message.synchronized.legal.only.on.methods='@Synchronized' 仅在方法上合法。
inspection.message.field.s.does.not.exist.exclude=字段 ''{0}'' 不存在
inspection.message.field.s.would.have.been.excluded.anyway=字段 ''{0}'' 本应被排除在外
inspection.message.field.s.does.not.exist.field=字段 ''{0}'' 不存在
inspection.message.data.only.supported.on.class.type=仅类类型支持 '@Data'
inspection.message.exclude.are.mutually.exclusive.exclude.parameter.will.be.ignored=exclude 和 of 互斥；'exclude' 参数将被忽略
inspection.message.equals.and.hashcode.only.supported.on.class.type=仅类类型支持 @EqualsAndHashCode
inspection.message.not.generating.equals.hashcode=未生成 equals 和 hashCode: 已存在采用其中一个名称的方法。(或者生成这两种方法，或者都不生成)。
inspection.message.generating.equals.hashcode.with.super.call=使用对 java.lang.Object 的超级调用生成 equals/hashCode 没有意义。
inspection.message.generating.equals.hashcode.implementation=生成 equals/hashCode 实现，但即使此类未扩展 java.lang.Object，也不调用超类。如果这是有意为之，请在您的类型中添加 '(callSuper=false)'。
inspection.message.lazy.not.supported.for.getter.on.type=类型上的 @Getter 不支持 'lazy'
inspection.message.getter.only.supported.on.class.enum.or.field.type=仅类、枚举或字段类型上支持 '@Getter'
inspection.message.s.only.supported.on.class.or.field.type=仅类或字段类型上支持 '@%s'
inspection.message.to.string.only.supported.on.class.or.enum.type=仅类或枚举类型上支持 @ToString
inspection.message.not.generated.s.method.with.same.name.already.exists=未生成 '%s'(): 已存在具有相同名称的方法
inspection.message.utility.classes.cannot.have.declared.constructors=@UtilityClasses 不能具有声明的构造函数。
inspection.message.utility.class.only.supported.on.class=仅类上支持 @UtilityClass (不能为接口、枚举或注解)。
inspection.message.utility.class.automatically.makes.class.static=@UtilityClass 自动将此类设为 static，但此类不能为 static。
inspection.message.utility.class.cannot.be.placed=@UtilityClass 不能置于方法的局部类或匿名内部类上，也不能置于此类中嵌套的任何类。
inspection.message.value.only.supported.on.class.type=仅类类型上支持 '@Value'
inspection.message.wither.only.supported.on.class.or.field=仅类或字段上支持 @Wither。
inspection.message.annotation.only.supported.on.class.or.enum.type=仅类或枚举类型上支持注解
inspection.message.lombok.needs.default.constructor.in.base.class=Lombok 要求基类中有默认构造函数
inspection.message.constructor.without.parameters.already.defined=已定义不带参数的构造函数
inspection.message.constructor.with.d.parameters.already.defined=已定义带有 ''{0}'' 参数的构造函数
inspection.message.method.s.matched.static.constructor.name.already.defined=已定义与 staticConstructorName 匹配的方法 ''{0}''
inspection.message.method.s.with.d.parameters.matched.static.constructor.name.already.defined=已定义与 staticConstructorName 匹配的带有 ''{1}'' 参数的方法 ''{0}''
inspection.message.field.name.constants.only.supported.on.class.or.enum=仅类或枚举上支持 '@FieldNameConstants'
inspection.message.field.name.constants.only.supported.on.class.enum.or.field.type=仅类、枚举或字段类型上支持 '@FieldNameConstants'
inspection.message.field.name.constants.inner.type=@FieldNameConstants 内部类型已存在，但 asEnum = {0} 与现有类型不匹配
inspection.message.s.legal.only.on.classes.enums=@%s 仅在类和枚举上合法
inspection.message.not.generating.field.s.field.with.same.name.already.exists=不生成字段 %s: 已存在具有相同名称的字段
inspection.message.custom.log.not.configured.correctly=@CustomLog 未正确配置；请在 lombok.config 中设置 log.custom.declaration。
inspection.message.custom.log.does.not.allow.topic=@CustomLog 不允许主题。
inspection.message.custom.log.requires.topic=@CustomLog 要求主题。
inspection.message.not.generating.constant=不为此字段生成常量: 否则常量名称将等于此字段的名称。
inspection.message.lazy.does.not.work.with.access.level.none='lazy' 不适用于 AccessLevel.NONE。
inspection.message.lazy.requires.field.to.be.private.final='lazy' 要求该字段为 private 和 final
inspection.message.lazy.requires.field.initialization='lazy' 要求字段初始化。
inspection.message.annotation.copy.duplicate=字段上已有注解 ''{0}''，将被 onX 配置复制
inspection.message.not.generating.getter.for.this.field=没有为此字段生成 getter: 它不适合您的 @Accessors 前缀列表。
inspection.message.not.generated.s.method.with.similar.name.s.already.exists=未生成 '%s'(): 已存在具有类似名称 '%s' 的方法
inspection.message.not.generating.setter.for.this.field.it=没有为此字段生成 setter: 它不适合您的 @Accessors 前缀列表。
inspection.message.not.generating.setter.for.this.field.setters=没有为此字段生成 setter: 无法为 final 字段生成 setter。
inspection.message.wither.needs.constructor.for.all.fields.d.parameters=@Wither 需要所有字段的构造函数(%d 个参数)
inspection.message.not.generating.s.method.with.that.name.already.exists=未生成 %s(): 已存在使用该名称的方法
inspection.message.not.generating.wither.for.this.field.withers=不为此字段生成 wither: 无法为以 $ 开头的字段生成 wither。
inspection.message.not.generating.wither=不为此字段生成 wither: 无法为 static 字段生成 wither。
inspection.message.not.generating.wither.for.this.field.withers.cannot.be.generated=不为此字段生成 wither: 无法为初始化的 final 字段生成 wither。
inspection.message.s.can.be.used.on.classes.only=@%s 仅可在类上使用
inspection.message.syntax.either.obtain.via.field=语法为 @ObtainVia(field = "fieldName") 或 @ObtainVia(method = "methodName")。
inspection.message.lombok.annotations.are.not.allowed.on.builder.class=在 builder 类中不允许使用 Lombok 注解。
inspection.message.s.not.valid.identifier=%s 不是有效的标识符
inspection.message.can.t.singularize.this.name=不能单一化此名称: "%s"；请显式指定单数(即 @Singular("sheep"))
inspection.message.lombok.does.not.know=Lombok 不知道如何为类型 '%s' 创建单数形式的 builder 方法；将不会生成它们。
inspection.message.builder.default.requires.initializing.expression=@Builder.Default 要求初始化表达式('= something;')。
inspection.message.builder.default.singular.cannot.be.mixed=@Builder.Default 和 @Singular 不能混用。
inspection.message.obtain.via.is.static.true.not.valid.unless.method.has.been.set=除非已设置 'method'，否则 @ObtainVia(isStatic = true) 无效。
inspection.message.delegate.does.not.support.recursion.delegating=@Delegate 不支持递归(委托给本身具有 @Delegate 成员的类型)。成员 "%s" 是类型为 "%s" 的 @Delegate
inspection.message.delegate.legal.only.on.instance.fields=@Delegate 仅对实例字段或无实参实例方法合法。
inspection.message.delegate.can.only.use.concrete.class.types=@Delegate 仅可使用具体的类类型，不能使用通配符、数组、类型变量或基元。'%s' 是错误的类类型
inspection.message.existing.builder.must.be.abstract.static.inner.class=现有 Builder 必须是抽象的 static 内部类。
inspection.message.delegate.legal.only.on.no.argument.methods=@Delegate 仅对于无实参方法合法。
action.defaultLombokData.text=默认 @Data
action.defaultLombokData.description=将 getter/setter/equals/hashcode/toString 方法替换为 lombok @Data 注解的操作
action.defaultLombokSetter.text=默认 @Setter
action.defaultLombokSetter.description=将所有 setter 方法替换为 lombok @Setter 注解的操作
action.defaultLombokEqualsAndHashcode.text=默认 @EqualsAndHashcode
action.defaultLombokEqualsAndHashcode.description=将 equals 和 hashcode 方法替换为 lombok @EqualsAndHashcode 注解的操作
action.defaultLombokToString.text=默认 @ToString
action.defaultLombokToString.description=将 toString 方法替换为 lombok @ToString 注解的操作
action.defaultLombokLogger.text=@Log (和朋友)
action.defaultLombokLogger.description=将记录程序替换为 lombok @Log 注解的操作
group.DelombokActionGroup.text=Delombok
group.DelombokActionGroup.description=重构移除 lombok 注解的代码
action.delombokAny.text=所有 lombok 注解
action.delombokAny.description=将所有 lombok 注解替换为纯 java 方法的操作
action.delombokData.text=@Data
action.delombokData.description=将 lombok @Data 注解替换为纯 java 方法的操作
action.delombokValue.text=@Value
action.delombokValue.description=将 lombok @Value 注解替换为纯 java 方法的操作
action.delombokWither.text=@Wither
action.delombokWither.description=将 lombok @Wither 注解替换为纯 java 方法的操作
action.delombokDelegate.text=@Delegate
action.delombokDelegate.description=将 lombok @Delegate 注解替换为纯 java 方法的操作
action.delombokBuilder.text=@Builder
action.delombokBuilder.description=将 lombok @Builder 注解替换为纯 java 方法的操作
action.delombokSuperBuilder.text=@SuperBuilder
action.delombokSuperBuilder.description=将 lombok @SuperBuilder 注解替换为纯 java 方法的操作
action.delombokConstructor.text=@Constructors
action.delombokConstructor.description=将 lombok @NoArgsConstructor、@RequiredArgsConstructor 和 @AllArgsConstructor 注解替换为纯 java 方法的操作
action.delombokGetter.text=@Getter
action.delombokGetter.description=将 lombok @Getter 注解替换为纯 getter 方法的操作
action.delombokSetter.text=@Setter
action.delombokSetter.description=将 lombok @Setter 注解替换为纯 setter 方法的操作
action.delombokEqualsAndHashCode.text=@EqualsAndHashCode
action.delombokEqualsAndHashCode.description=将 lombok @EqualsAndHashCode 注解替换为纯 java 方法的操作
action.delombokToString.text=@ToString
action.delombokToString.description=将 lombok @ToString 注解替换为纯 java 方法的操作
action.delombokLogger.text=@Log (和朋友)
action.delombokLogger.description=将 lombok @Log (及其他)注解替换为纯日志字段的操作
action.delombokFieldNameCostants.text=@FieldNameConstants
action.delombokFieldNameCostants.description=将 lombok @FieldNameConstants 注解替换为纯 java 字段的操作
action.delombokUtilityClass.text=@UtilityClass
action.delombokUtilityClass.description=将 lombok @UtilityClass 注解替换为纯 java 字段的操作
action.defaultLombokGetter.text=默认 @Getter
action.defaultLombokGetter.description=将所有 getter 方法替换为 lombok @Getter 注解的操作
group.LombokActionGroup.text=Lombok
group.LombokActionGroup.description=使用 lombok 注解重构代码
inspection.redundant.modifiers.val.lombok.display.name='val' 前的不必要 final
inspection.redundant.slf.4.j.definition.display.name=@Slf4j
inspection.redundant.modifiers.utility.class.lombok.display.name=@UtilityClass 修饰符
inspection.redundant.modifiers.value.lombok.display.name=@Value 修饰符
inspection.springqualifiercopyable.lombok.display.name=@Qualifier 不可通过 lombok 复制
inspection.deprecated.lombok.display.name=已弃用的 Lombok 注解
inspection.lombok.display.name=Lombok 注解
checkbox.settings.version.warning=启用旧 Lombok 版本的 Lombok 版本警告
inspection.lombok.group.name.lombok=Lombok
inspection.lombok.group.name.redundant.modifiers=冗余修饰符
inspection.lombok.group.name.redundant.definitions=冗余定义

intention.category.lombok=Java/Lombok
inspection.message.lombok.builder.needs.proper.constructor.for.this.class=Lombok @Builder 需要为此类的适当构造函数
checkbox.settings.jps.fix=为旧(<1.18.16) Lombok 版本自动添加 '-Djps.track.ap.dependencies=false' 编译选项
config.warn.annotation-processing.disabled.title=Lombok 要求已启用的注解处理
popup.content.java.annotation.processing.has.been.enabled=已启用 Java 注解处理
inspection.message.standardexception.class.only.supported.on.class=@StandardException 仅在类上支持
inspection.message.standardexception.should.extend.throwable=@StandardException 要求您扩展 Throwable 类型
inspection.message.standardexception.accesslevel.none.not.valid=AccessLevel.NONE 在此处无效
action.delombokStandardException.text=@StandardException
action.delombokStandardException.description=将 lombok @StandardException 注解替换为纯 java 方法的操作
notification.enable.annotation.processing=启用注解处理
action.defaultLombokData.description=将 getter/setter/equals/hashcode/toString 方法替换为 lombok @Data 注解的操作
action.defaultLombokData.text=默认 @Data
action.defaultLombokEqualsAndHashcode.description=将 equals 和 hashcode 方法替换为 lombok @EqualsAndHashcode 注解的操作
action.defaultLombokEqualsAndHashcode.text=默认 @EqualsAndHashcode
action.defaultLombokGetter.description=将所有 getter 方法替换为 lombok @Getter 注解的操作
action.defaultLombokGetter.text=默认 @Getter
action.defaultLombokLogger.description=将记录程序替换为 lombok @Log 注解的操作
action.defaultLombokLogger.text=@Log (和朋友)
action.defaultLombokSetter.description=将所有 setter 方法替换为 lombok @Setter 注解的操作
action.defaultLombokSetter.text=默认 @Setter
action.defaultLombokToString.description=将 toString 方法替换为 lombok @ToString 注解的操作
action.defaultLombokToString.text=默认 @ToString
action.delombokAny.description=将所有 lombok 注解替换为纯 java 方法的操作
action.delombokAny.text=所有 lombok 注解
action.delombokBuilder.description=将 lombok @Builder 注解替换为纯 java 方法的操作
action.delombokBuilder.text=@Builder
action.delombokConstructor.description=将 lombok @NoArgsConstructor、@RequiredArgsConstructor 和 @AllArgsConstructor 注解替换为纯 java 方法的操作
action.delombokConstructor.text=@Constructors
action.delombokData.description=将 lombok @Data 注解替换为纯 java 方法的操作
action.delombokData.text=@Data
action.delombokDelegate.description=将 lombok @Delegate 注解替换为纯 java 方法的操作
action.delombokDelegate.text=@Delegate
action.delombokEqualsAndHashCode.description=将 lombok @EqualsAndHashCode 注解替换为纯 java 方法的操作
action.delombokEqualsAndHashCode.text=@EqualsAndHashCode
action.delombokFieldNameCostants.description=将 lombok @FieldNameConstants 注解替换为纯 java 字段的操作
action.delombokFieldNameCostants.text=@FieldNameConstants
action.delombokGetter.description=将 lombok @Getter 注解替换为纯 getter 方法的操作
action.delombokGetter.text=@Getter
action.delombokLogger.description=将 lombok @Log (及其他)注解替换为纯日志字段的操作
action.delombokLogger.text=@Log (和朋友)
action.delombokSetter.description=将 lombok @Setter 注解替换为纯 setter 方法的操作
action.delombokSetter.text=@Setter
action.delombokStandardException.description=将 lombok @StandardException 注解替换为纯 java 方法的操作
action.delombokStandardException.text=@StandardException
action.delombokSuperBuilder.description=将 lombok @SuperBuilder 注解替换为纯 java 方法的操作
action.delombokSuperBuilder.text=@SuperBuilder
action.delombokToString.description=将 lombok @ToString 注解替换为纯 java 方法的操作
action.delombokToString.text=@ToString
action.delombokUtilityClass.description=将 lombok @UtilityClass 注解替换为纯 java 字段的操作
action.delombokUtilityClass.text=@UtilityClass
action.delombokValue.description=将 lombok @Value 注解替换为纯 java 方法的操作
action.delombokValue.text=@Value
action.delombokWither.description=将 lombok @Wither 注解替换为纯 java 方法的操作
action.delombokWither.text=@Wither
checkbox.settings.jps.fix=为旧(<1.18.16) Lombok 版本自动添加 '-Djps.track.ap.dependencies\=false' 编译选项
checkbox.settings.version.warning=启用旧 Lombok 版本的 Lombok 版本警告
color.settings.clear=清除
color.settings.comment=评论
color.settings.key=键
color.settings.separator=分隔符
color.settings.value=值
config.warn.annotation-processing.disabled.title=Lombok 要求已启用的注解处理
config.warn.dependency.outdated.message=<br>项目“{0}”似乎具有过时的 Lombok 依赖项。<br>已配置版本“{1}”，但至少版本“{2}”已经发布<br><a href\="https\://projectlombok.org/download">也许您想进行更新?</a> <br>
config.warn.dependency.outdated.title=Lombok 依赖项可能已过时
configurable.name.lombok.config=Lombok 配置
dialog.message.logger.field.s.not.private.sfinal.field.named.s.refactor.anyway=记录程序字段\:“{0}”不是名称为“{2}”的 private {1, choice, 0\#|1\#static} final 字段。是否仍然重构?
dialog.message.this.element.cannot.be.renamed=此元素不能被重命名。
dialog.title.attention=注意\!
filetype.lombok.config.description=Lombok 配置文件
group.DelombokActionGroup.description=重构移除 lombok 注解的代码
group.DelombokActionGroup.text=Delombok
group.LombokActionGroup.description=使用 lombok 注解重构代码
group.LombokActionGroup.text=Lombok
inspection.builder.static.import.name=对 Lombok 生成的方法使用 static import
inspection.deprecated.lombok.display.name=已弃用的 Lombok 注解
inspection.lombok.display.name=Lombok 注解
inspection.lombok.getter.may.be.used.display.class.message=类 ''{0}'' 可以使用 Lombok @Getter
inspection.lombok.getter.may.be.used.display.field.message=字段 ''{0}'' 可以具有 Lombok @Getter
inspection.lombok.getter.may.be.used.display.fix.family.name=将显式 getter 方法替换为 Lombok @Getter
inspection.lombok.getter.may.be.used.display.fix.name=对 ''{0}'' 使用 Lombok @Getter
inspection.lombok.getter.may.be.used.display.name=可以使用 Lombok @Getter
inspection.lombok.group.name.lombok=Lombok
inspection.lombok.group.name.redundant.definitions=冗余定义
inspection.lombok.group.name.redundant.modifiers=冗余修饰符
inspection.lombok.setter.may.be.used.display.class.message=类 ''{0}'' 可以使用 Lombok @Setter
inspection.lombok.setter.may.be.used.display.field.message=字段 ''{0}'' 可以具有 Lombok @Setter
inspection.lombok.setter.may.be.used.display.fix.family.name=将显式 setter 方法替换为 Lombok @Setter
inspection.lombok.setter.may.be.used.display.fix.name=对 ''{0}'' 使用 Lombok @Setter
inspection.lombok.setter.may.be.used.display.name=可以使用 Lombok @Setter
inspection.message.annotation.copy.duplicate=字段上已有注解 ''{0}''，将被 onX 配置复制
inspection.message.annotation.not.lombok.copyable=Lombok 不会将注解 ''{0}'' 复制到构造函数中
inspection.message.annotation.only.supported.on.class.or.enum.type=仅在类或枚举上支持 {0}
inspection.message.builder.can.be.used.only=仅在类、记录、构造函数和方法上支持 @Builder。
inspection.message.builder.default.requires.builder.annotation=@Builder.Default 要求类中有 @Builder 或 @SuperBuilder 才有意义。
inspection.message.builder.default.requires.initializing.expression=@Builder.Default 要求初始化表达式('\= something;')。
inspection.message.builder.default.singular.cannot.be.mixed=@Builder.Default 和 @Singular 不能混用。
inspection.message.can.t.singularize.this.name=无法单一化此名称\: ''{0}''；显式指定单数形式(即 @Singular("sheep"))
inspection.message.cleanup.legal.only.on.local.variable.declaration.inside.block=@Cleanup\: 仅在块内的局部变量声明上合法
inspection.message.cleanup.legal.only.on.local.variable.declarations=@Cleanup 仅在局部变量声明上合法
inspection.message.cleanup.method.s.not.found.on.target.class=@Cleanup\: 在目标类中找不到方法 ''{0}()''
inspection.message.cleanup.value.cannot.be.empty.string=@Cleanup\: 值不能为空字符串
inspection.message.cleanup.variable.declarations.need.to.be.initialized=@Cleanup 变量声明需要初始化。
inspection.message.constructor.noargs.needs.to.be.forced=类包含必选字段，必须强制 NoArgsConstructor。
inspection.message.constructor.with.d.parameters.already.defined=构造函数 ''{0}'' 已定义
inspection.message.constructor.without.parameters.already.defined=已定义不带形参的构造函数
inspection.message.custom.log.does.not.allow.topic=@CustomLog 不允许主题。
inspection.message.custom.log.not.configured.correctly=@CustomLog 未正确配置；请在 lombok.config 中设置 log.custom.declaration。
inspection.message.custom.log.requires.topic=@CustomLog 要求主题。
inspection.message.data.only.supported.on.class.type=仅在类类型上支持 @Data
inspection.message.default.constructor.doesn.t.exist=默认构造函数不存在
inspection.message.delegate.can.only.use.concrete.class.types=@Delegate 仅可使用具体的类类型，不能使用通配符、数组、类型变量或基元。''{0}'' 是错误的类类型
inspection.message.delegate.does.not.support.recursion.delegating=@Delegate 不支持递归(委托给本身具有 @Delegate 成员的类型)。成员 ''{0}'' 是类型为 ''{1}'' 的 @Delegate
inspection.message.delegate.legal.only.on.instance.fields=@Delegate 仅对实例字段或无实参实例方法合法。
inspection.message.delegate.legal.only.on.no.argument.methods=@Delegate 仅对于无实参方法合法。
inspection.message.delegate.unknown.type.method=找不到方法 ''{0}''
inspection.message.equals.and.hashcode.only.supported.on.class.type=仅类类型支持 @EqualsAndHashCode
inspection.message.exclude.are.mutually.exclusive.exclude.parameter.will.be.ignored=形参'exclude' 和 'of' 互斥；'exclude' 形参将被忽略
inspection.message.existing.builder.must.be.abstract.static.inner.class=现有 Builder 必须是抽象的 static 内部类。
inspection.message.field.name.constants.inner.type=@FieldNameConstants 内部类型已存在，但 asEnum \= {0} 与现有类型不匹配
inspection.message.field.name.constants.only.supported.on.class.enum.or.field.type=仅类、枚举、记录或字段类型上支持 @FieldNameConstants
inspection.message.field.name.constants.only.supported.on.class.or.enum=仅类、枚举或记录上支持 @FieldNameConstants。
inspection.message.field.s.does.not.exist=字段 ''{0}'' 不存在。
inspection.message.field.s.does.not.exist.exclude=字段 ''{0}'' 不存在
inspection.message.field.s.does.not.exist.field=字段 ''{0}'' 不存在
inspection.message.field.s.would.have.been.excluded.anyway=字段 ''{0}'' 本应被排除在外
inspection.message.generating.equals.hashcode.implementation=正在生成 equals/hashCode 实现，但即使此类未扩展 java.lang.Object，也不调用超类。如果这是有意为之，请在您的类型中添加 '(callSuper\=false)'。
inspection.message.generating.equals.hashcode.with.super.call=使用对 java.lang.Object 的超级调用生成 equals/hashCode 没有意义。
inspection.message.getter.only.supported.on.class.enum.or.field.type=仅类、枚举或字段类型上支持 @Getter
inspection.message.jacksonized.builder.on.abstract.classes=抽象类上的构建器无法 @Jacksonized (构建器永远不会被使用)。
inspection.message.jacksonized.cannot.process.both.builder.superbuilder=@Jacksonized 无法在同一个类上同时处理 @Builder 和 @SuperBuilder。
inspection.message.jacksonized.jsondeserialize.already.exists=类中已存在 @JsonDeserialize。要么删除 @JsonDeserialize，要么移除 @Jacksonized 并手动配置 Jackson。
inspection.message.jacksonized.requires.builder.superbuilder=@Jacksonized 需要 @Builder 或 @SuperBuilder 才有意义。
inspection.message.lazy.does.not.work.with.access.level.none='lazy' 不适用于 AccessLevel.NONE。
inspection.message.lazy.not.supported.for.getter.on.type=类型上的 @Getter 不支持 'lazy'
inspection.message.lazy.requires.field.initialization='lazy' 要求字段初始化。
inspection.message.lazy.requires.field.to.be.private.final='lazy' 要求该字段为 private 和 final
inspection.message.lombok.annotation.deprecated.not.supported=Lombok 的注解 ''{0}'' 已弃用，Lombok 插件不再提供支持。请改用 ''{1}''。
inspection.message.lombok.annotations.are.not.allowed.on.builder.class=在 builder 类中不允许使用 Lombok 的注解。
inspection.message.lombok.builder.needs.proper.constructor.for.this.class=Lombok @Builder 需要为此类的适当构造函数
inspection.message.lombok.does.not.know=Lombok 无法为类型 ''{0}'' 生成单数形式的 builder 方法
inspection.message.lombok.needs.default.constructor.in.base.class=Lombok 要求基类中有默认构造函数
inspection.message.method.s.matched.static.constructor.name.already.defined=已定义与 staticConstructorName 匹配的方法 ''{0}''
inspection.message.method.s.with.d.parameters.matched.static.constructor.name.already.defined=已定义与 staticConstructorName 匹配的带有 ''{1}'' 形参的方法 ''{0}''
inspection.message.not.allowed.in.old.style.for.loops=旧式 for 循环中不允许使用 ''{0}''
inspection.message.not.allowed.with.lambda.expressions=Lambda 表达式不允许使用 ''{0}''。
inspection.message.not.compatible.with.array.initializer.expressions=''{0}'' 与数组初始值设定项表达式不兼容。使用完整形式 (新的 int[] '{' ... '}'，而不只是 '{' ... '}')
inspection.message.not.generated.s.method.with.same.name.already.exists=未生成 ''{0}()''\: 已存在具有相同名称的方法
inspection.message.not.generated.s.method.with.similar.name.s.already.exists=未生成 ''{0}()''\: 已存在具有类似名称 ''{0}'' 的方法
inspection.message.not.generating.constant=不为此字段生成常量\: 否则常量名称将等于此字段的名称。
inspection.message.not.generating.equals.hashcode=未生成 equals 和 hashCode\: 已存在采用其中一个名称的方法。(或者生成这两种方法，或者都不生成)。
inspection.message.not.generating.field.s.field.with.same.name.already.exists=不生成字段 ''{0}''\: 已存在具有相同名称的字段
inspection.message.not.generating.getter.for.this.field=没有为此字段生成 getter\: 它不适合您的 @Accessors 前缀列表。
inspection.message.not.generating.s.method.with.that.name.already.exists=未生成 ''{0}()''\: 已存在使用该名称的方法
inspection.message.not.generating.setter.for.this.field.it=没有为此字段生成 setter\: 它不适合您的 @Accessors 前缀列表。
inspection.message.not.generating.setter.for.this.field.setters=没有为此字段生成 setter\: 无法为 final 字段生成 setter。
inspection.message.not.generating.wither=不为此字段生成 wither\: 无法为 static 字段生成 wither。
inspection.message.not.generating.wither.for.this.field.withers=不为此字段生成 wither\: 无法为以 $ 开头的字段生成 wither。
inspection.message.not.generating.wither.for.this.field.withers.cannot.be.generated=不为此字段生成 wither\: 无法为初始化的 final 字段生成 wither。
inspection.message.obtain.via.is.static.true.not.valid.unless.method.has.been.set=除非已设置 'method'，否则 @ObtainVia(isStatic \= true) 无效。
inspection.message.on.local.variable.requires.initializer.expression=局部变量上的 ''{0}'' 需要初始值设定项表达式
inspection.message.s.legal.only.on.classes.enums=''@{0}'' 仅在类和枚举上合法
inspection.message.s.not.valid.identifier=''{0}'' 不是有效的标识符
inspection.message.setter.only.supported.on.class.or.field.type=仅类或字段类型上支持 @Setter
inspection.message.slf4j.logger.defined.explicitly=Slf4j 记录程序为显式定义。请改用 Lombok @Slf4j 注解。
inspection.message.sneakythrows.calls.to.sibling.super.constructors.excluded=对同级/超级构造函数的调用始终从 @SneakyThrows 中排除；@SneakyThrows 已被忽略，因为此构造函数中没有其他代码。
inspection.message.standardexception.accesslevel.none.not.valid=AccessLevel.NONE 在此处无效
inspection.message.standardexception.class.only.supported.on.class=@StandardException 仅在类上支持
inspection.message.standardexception.should.extend.throwable=@StandardException 要求您扩展 Throwable 类型
inspection.message.superbuilder.can.be.used.on.classes.only=仅在类上支持 @SuperBuilder。
inspection.message.superbuilder.can.be.used.on.static.inner.classes.only=在非 static 嵌套类上不支持 @SuperBuilder。
inspection.message.synchronized.field.is.not.static=字段 ''{0}'' 为非 static，无法在此 static 方法上使用
inspection.message.synchronized.legal.only.on.concrete.methods=@Synchronized 仅在具体方法上合法。
inspection.message.synchronized.legal.only.on.methods.in.classes.enums=@Synchronized 仅在类和枚举中的方法上合法。
inspection.message.syntax.either.obtain.via.field=语法为 @ObtainVia(field \= "fieldName") 或 @ObtainVia(method \= "methodName")。
inspection.message.to.string.only.supported.on.class.or.enum.type=仅类或枚举类型上支持 @ToString
inspection.message.utility.class.already.marks.class.final=@UtilityClass 已将类标记为 final。
inspection.message.utility.class.already.marks.fields.static=@UtilityClass 已将字段标记为 static。
inspection.message.utility.class.already.marks.inner.classes.static=@UtilityClass 已将内部类标记为 static。
inspection.message.utility.class.already.marks.methods.static=@UtilityClass 已将方法标记为 static。
inspection.message.utility.class.automatically.makes.class.static=@UtilityClass 自动将此类设为 static，但此类不能为 static。
inspection.message.utility.class.cannot.be.placed=@UtilityClass 不能置于方法的局部类或匿名内部类上，也不能置于此类中嵌套的任何类。
inspection.message.utility.class.only.supported.on.class=仅类上支持 @UtilityClass (不能为接口、枚举或注解)。
inspection.message.utility.classes.cannot.have.declared.constructors=@UtilityClasses 不能具有声明的构造函数。
inspection.message.val.already.marks.variables.final='val' 已将变量标记为 final。
inspection.message.val.works.only.on.local.variables='val' 仅适用于局部变量和 foreach 循环
inspection.message.value.already.marks.class.final=@Value 已将类标记为 final。
inspection.message.value.already.marks.non.static.fields.final=@Value 已将非 static 字段标记为 final。
inspection.message.value.already.marks.non.static.package.local.fields.private=@Value 已将非 static 的 package-local 字段标记为 private。
inspection.message.value.only.supported.on.class.type=仅在类类型上支持 @Value
inspection.message.var.works.only.on.local.variables.on.for.foreach.loops='val' 仅适用于局部变量和 for/foreach 循环
inspection.message.wither.needs.constructor.for.all.fields.d.parameters=@Wither 需要所有字段的构造函数(''{0}'' 个形参)
inspection.message.wither.only.supported.on.class.or.field=仅类或字段上支持 @Wither。
inspection.redundant.modifiers.utility.class.lombok.display.name=@UtilityClass 修饰符
inspection.redundant.modifiers.val.lombok.display.name='val' 前的不必要 final
inspection.redundant.modifiers.value.lombok.display.name=@Value 修饰符
inspection.redundant.slf.4.j.definition.display.name=@Slf4j
inspection.springqualifiercopyable.lombok.display.name=@Qualifier 不可通过 Lombok 复制
inspection.static.method.import.error=Lombok 生成的方法的 static import 不适用于 javac
intention.category.lombok=Java/Lombok
intention.family.name.slf4j.annotation=使用 @Slf4j 注解替换记录器字段
intention.name.create.new.field.s=创建新字段 ''{0}''
intention.name.replace.with.lombok=替换为 Lombok
make.abstract.and.static.modifier.quickfix=将 ''{0}'' 设为 abstract 和 static
make.abstract.and.static.modifier.quickfix.family.name=更改修饰符
notification.enable.annotation.processing=启用注解处理
notification.group.lombok=Lombok 集成问题
plugin.settings.title=Lombok
popup.content.java.annotation.processing.has.been.enabled=已启用 Java 注解处理
replace.0.with.explicit.type.lombok=将 ''{0}'' 替换为显式类型(Lombok)
replace.explicit.type.with.0.lombok=将显式类型替换为 ''{0}'' (Lombok)
replace.synchronized.lombok.intention=替换为 Lombok @Synchronized
replace.with.annotations.lombok=替换为注解(Lombok)

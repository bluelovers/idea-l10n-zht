action.AJ.NewAspect.description=创建新的 AspectJ 切面
action.AJ.NewAspect.text=切面
action.AJ.PushIn.description=将类型间声明推入其目标类
action.AJ.PushIn.text=推入 ITD(_I)…
action.create.aspect.bad.template=无法创建切面 - 模板 {0} 不正确
action.create.aspect.description=创建新切面
action.create.aspect.error=无法创建切面
action.create.aspect.kind.annotation=@Aspect
action.create.aspect.kind.class=Aspect
action.create.aspect.name=创建新切面
action.create.aspect.title=创建切面 {0}
action.push.in.bad.target=无法解析目标类(''{0}'')
action.push.in.class.conflict=内部类 ''{0}'' 与 ''{1}'' 中的一个冲突
action.push.in.compiled.target=无法推入已编译的类 ''{0}''
action.push.in.delete.aspects=删除空切面(&D)
action.push.in.field.conflict=字段 ''{0}'' 与 ''{1}'' 中的一个冲突
action.push.in.interface=不支持推入接口(''{0}'')
action.push.in.method.conflict=方法 ''{0}'' 与 ''{1}'' 中的一个冲突
action.push.in.name=推入
action.push.in.nothing.found=找不到类型间声明
action.push.in.preview.sources=从以下位置({0})移动 ITD\:
action.push.in.preview.usages={1,choice, 1\#1 个文件|2\#{1,number} 个文件}中{0,choice, 0\#没有声明|1\#有 1 个声明|2\#有 {0,number} 个声明}
action.push.in.progress=正在执行重构…
action.push.in.title=推入类型间声明
action.push.in.type.pattern=类型模式 ''{0}'' 不支持推入
action.push.in.wrong.position=推入重构只能在类型间声明、切面、软件包或模块上执行
aj.button.test=测试(&T)
aspect.path.add.title=选择切面路径条目
aspect.path.no.deps.message=找不到合适的依赖项。
aspect.path.no.items.title=没有要添加的项
border.title.ajc.options=Ajc 选项
border.title.compiler=编译器
checkbox.delegate.to.javac=委托给 Javac
checkbox.enable.annotation.processing.options=启用注解处理选项
checkbox.generate.debug.info=生成调试信息
checkbox.post.compile.weave.mode=编译后编织模式
command.line.parameters=命令行形参\:
compiler.ajc.bad.heap=堆大小无效
compiler.ajc.checking=正在检查编译器版本
compiler.ajc.error=编译器错误
compiler.ajc.name=Ajc
compiler.ajc.no.jdk=未配置项目 JDK
compiler.ajc.select.path=选择 AspectJ 编译器的路径('aspectjtools.jar')
compiler.ajc.test.ok=成功
facet.validation.stray.entry=切面路径条目 ''{0}'' 不在模块的类路径中
facet.validation.unknown.entry=未知的切面路径条目 ''{0}''
file.template.group=AspectJ
highlighting.aspect.params=具体切面仅允许零实参构造函数
highlighting.declaration.conflict.in.aspect=类型间声明 ''{0}'' 与 ''{1}'' 中的一个冲突
highlighting.declaration.conflict.in.class=''{0}'' 与来自 ''{1}'' 的类型间声明冲突
highlighting.explicit.constructor.call=缺少显式构造函数调用\: 目标类型的字段初始值设定项将不会执行
highlighting.generic.abstract=泛型切面必须为 abstract
highlighting.inherits.aspect=类 ''{0}'' 无法从切面 ''{1}'' 继承
highlighting.inherits.concrete=无法从具体 ''{0}'' 继承
highlighting.nested.static=内部切面必须为 static
highlighting.non.static.access=无法从 static 上下文引用非 static 成员 ''{0}''
highlighting.private.access=''{0}'' 在 ''{1}'' 中具有 private 访问权限
highlighting.protected.declaration=不允许 protected 类型间声明
highlighting.target.enum=无法对枚举类型进行类型间声明
highlighting.target.interface=无法在接口上声明新成员类型
highlighting.target.not.generic=目标类型 ''{0}'' 非泛型
highlighting.tooltip.html=<html><body>{0}</body></html>
highlighting.tooltip.link=<a href\="\#navigation/{0}\:{1}">{2}</a>
highlighting.unsupported=IDEA 尚不支持 AspectJ 语句
highlighting.wildcard.not.allowed=此处不允许使用通配符类型实参
highlighting.wrong.num.of.type.refs=目标类型 ''{0}'' 需要 {1} 个类型{1,choice, 1\#形参|2\#形参}
inspection.unused.display.name=切面
item.presentation.location=({0} 中)
label.aspect.path=切面路径\:
label.path.to.aspectjtools.jar=aspectjtools.jar 路径\:
maven.importer.aspect.library=<html>无法在模块 ''{2}'' 中解析切面库 ''{0}\:{1}''。</html>
maven.importer.compiler.settings.action=编译器设置
maven.importer.no.dependency=<html>在插件依赖项中找不到 AspectJ 编译器 .jar。检查 ''{0}'' 配置并重新导入项目，或手动设置编译器。</html>
maven.importer.open.file.action=打开 pom.xml
maven.importer.project.jdk=<html>无法解析 'aspectj-maven-plugin' 的依赖项。将项目 SDK 设置为 Java 8 (或更早版本)，然后重新导入项目。</html>
maven.importer.project.settings.action=项目设置
migration.project.aspect.path=<html>该项目已配置项目范围的切面路径。此功能不再受支持。检查项目配置并为各个模块设置切面路径。使用了以下库\: {0}</html>
notification.group.aspectj=AspectJ
parser.message.annotation.expected=应为注解
parser.message.pointcut.expression.expected=应为切入点表达式
parser.message.type.def.expected=应为切面声明或类声明
plugin.title=AspectJ 支持
produce.annotation.processing.options.for.experimental.ajc.builds.which.are.able.to.handle.them=生成注解处理选项(针对能够处理注解的实验性 Ajc 构建)
quickFix.family.name=AspectJ
quickFix.make.abstract=设为 abstract
quickFix.make.static=设为 static
requires.settings.java.compiler.ajc.delegate.to.javac=需要“设置 | … | Java 编译器 | Ajc | 委托给 Javac”
structure.view.action.show.inter-type=显示类型间声明
structure.view.toggle.show.inter-type=类型间声明(&I)
use.javac.to.compile.modules.without.aspectj.facet.or.with.post.compile.weaving.enabled=使用 Javac 编译没有 AspectJ facet 的模块或启用编译后编织的模块

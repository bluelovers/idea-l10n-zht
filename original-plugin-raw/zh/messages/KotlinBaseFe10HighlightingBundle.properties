always.null=始终为 null
cannot.be.inferred=无法推断
defined.in=定义位置
found.space=已找到\:
function.arguments=实参\:
function.receiver.0=接收器\: {0}
gutter.name.suspend.call=挂起调用
html.0.has.no.corresponding.expected.declaration.1.html={0} 没有相应的预期声明{1}
html.0.is.not.abstract.and.does.not.implement.abstract.base.class.member.br.1.html={0} 非抽象且无法实现抽象的基类成员<br/>{1}
html.0.is.not.abstract.and.does.not.implement.abstract.member.br.1.html={0} 非抽象且无法实现抽象成员<br/>{1}
html.0.method.may.be.missing.none.of.the.following.functions.will.be.called.ul.1.ul.html=可能缺失 ''{0}'' 方法。不会调用以下函数\: <ul>{1}</ul>
html.0.must.override.1.br.because.it.inherits.many.implementations.of.it.html={0} 必须重写 {1}，<br />因为它继承了后者的许多实现
html.accidental.override.0.html=意外重写\: {0}
html.actual.class.0.has.no.corresponding.members.for.expected.class.members.1.html=实际类 ''{0}'' 没有适合预期类成员的相应成员\: {1}
html.assignment.operators.ambiguity.all.these.functions.match.ul.0.ul.table.html=赋值运算符多义性。所有这些函数均匹配。<ul>{0}</ul></table>
html.candidate.resolution.will.be.changed.soon.please.use.fully.qualified.name.to.invoke.the.following.closer.candidate.explicitly.ul.0.ul.html=候选解析即将更改，请使用完全限定名称显式调用以下更接近的候选\: <ul>{0}</ul>
html.cannot.choose.among.the.following.candidates.without.completing.type.inference.ul.0.ul.html=不完成类型推断，将无法选择以下候选项\: <ul>{0}</ul>
html.expected.0.has.no.actual.declaration.in.module.1.2.html=预期的 {0} 在模块 {1}{2} 中没有实际声明
html.function.return.type.mismatch.table.tr.td.expected.td.td.1.td.tr.tr.td.found.td.td.2.td.tr.table.html=函数返回值类型不匹配。<table><tr><td>应为\:</td><td>{1}</td></tr><tr><td>实际\:</td><td>{2}</td></tr></table>
html.getter.return.type.must.be.equal.to.the.type.of.the.property.table.tr.td.expected.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=getter 返回值类型必须与属性类型相等。<table><tr><td>应为\:</td><td>{0}</td></tr><tr><td>实际\:</td><td>{1}</td></tr></table>
html.internal.error.occurred.while.analyzing.this.expression.br.0.html=<strong>分析此表达式时出现内部错误\:</strong><br/>{0}
html.javascript.0.html=JavaScript\: {0}
html.loop.parameter.type.mismatch.table.tr.td.iterated.values.td.td.0.td.tr.tr.td.parameter.td.td.1.td.tr.table.html=循环形参类型不匹配。<table><tr><td>迭代的值\:</td><td>{0}</td></tr><tr><td>形参\:</td><td>{1}</td></tr></table>
html.method.contains.from.concurrenthashmap.may.have.unexpected.semantics.it.calls.containsvalue.instead.of.containskey.br.use.explicit.form.of.the.call.to.containskey.containsvalue.contains.or.cast.the.value.to.kotlin.collections.map.instead.br.see.https.youtrack.jetbrains.com.issue.kt.18053.for.more.details.html=来自 ConcurrentHashMap 的方法 'contains' 可能具有意外的语义\: 它会调用 'containsValue' 而不是 'containsKey'。<br/>使用显式形式的 'containsKey'/'containsValue'/'contains' 调用或将值转换为 kotlin.collections.Map。<br/>有关更多详细信息，请参见 https\://youtrack.jetbrains.com/issue/KT-18053
html.method.iterator.is.ambiguous.for.this.expression.ul.0.ul.html=方法 ''iterator()'' 对此表达式不明确。<ul>{0}</ul>
html.non.final.expect.class.and.its.actual.class.must.declare.exactly.the.same.non.private.members.html={0}\: actual 及其非 final expect 类必须声明相同的非 private 成员。actual 类中的以下非 private 成员不匹配\: {1}<br/>发生此错误是因为 expect 类 ''{2}'' 为非 final。此警告将在未来的版本中变成错误。<br/>如需了解详情，另请参阅 https\://youtrack.jetbrains.com/issue/KT-22841
html.none.of.the.following.functions.can.be.called.with.the.arguments.supplied.ul.0.ul.html=使用提供的实参无法调用以下函数。<ul>{0}</ul>
html.overload.resolution.ambiguity.all.these.functions.match.ul.0.ul.html=重载解析多义性。所有这些函数均匹配。<ul>{0}</ul>
html.overload.resolution.ambiguity.on.method.0.all.these.functions.match.ul.1.ul.html=方法 ''{0}'' 具有重载解析多义性。所有这些函数均匹配。<ul>{1}</ul>
html.platform.declaration.clash.0.html=平台声明冲突\: {0}
html.property.delegate.must.have.a.0.method.none.of.the.following.functions.are.suitable.ul.1.ul.html=属性委托必须具有 ''{0}'' 方法。以下函数均不合适。<ul>{1}</ul>
html.property.type.is.0.which.is.not.a.subtype.type.of.overridden.br.1.html=属性类型为 {0}，它不是已重写项的子类型<br/>{1}
html.return.type.is.0.which.is.not.a.subtype.of.overridden.br.1.html=返回值类型为 ''{0}''，它不是已重写项的子类型<br/>{1}
html.return.types.of.inherited.members.are.incompatible.br.0.br.1.html=继承成员的返回值类型不兼容\:<br/>{0}，<br/>{1}
html.setter.parameter.type.must.be.equal.to.the.type.of.the.property.table.tr.td.expected.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=setter 形参类型必须与属性类型相等。<table><tr><td>应为\:</td><td>{0}</td></tr><tr><td>实际\:</td><td>{1}</td></tr></table>
html.type.argument.is.not.within.its.bounds.table.tr.td.expected.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=类型实参不在其边界内。<table><tr><td>应为\:</td><td>{0}</td></tr><tr><td>实际\:</td><td>{1}</td></tr></table>
html.type.inference.failed.0.html=类型推断失败\: {0}
html.type.mismatch.table.tr.td.required.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.br.projected.type.2.restricts.use.of.br.3.html=类型不匹配。<table><tr><td>要求\:</td><td>{0}</td></tr><tr><td>实际\:</td><td>{1}</td></tr></table><br />\n映射的类型 {2} 限制使用 <br />\n{3}\n
html.type.mismatch.table.tr.td.required.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=类型不匹配。<table><tr><td>要求\:</td><td>{0}</td></tr><tr><td>实际\:</td><td>{1}</td></tr></table>
html.types.of.inherited.properties.are.incompatible.br.0.br.1.html=继承的属性类型不兼容\:<br/>{0}，<br/>{1}
html.types.of.inherited.var.properties.do.not.match.br.0.br.1.html=继承的 var 属性类型不匹配\:<br/>{0}，<br/>{1}
html.unresolved.reference.br.none.of.the.following.candidates.is.applicable.because.of.receiver.type.mismatch.ul.0.ul.html=存在未解析的引用。<br/>以下候选项均不合适，因为接收器类型不匹配\: <ul>{0}</ul>
html.val.property.cannot.override.var.property.br.1.html=val 属性无法重写 var 属性<br />{1}
html.var.property.type.is.0.which.is.not.a.type.of.overridden.br.1.html=var 属性类型为 {0}，它不是已重写项的类型<br/>{1}
i.for.i.br.0=<i> for </i><br/>{0}
kotlin.compiler.error=Kotlin 编译器错误
kotlin.compiler.warning=Kotlin 编译器警告
required.space=需要\: 
root.package=根软件包
smart.cast.to.0.for.1.call=智能转换为 {0} (适用于 {1} 调用)
the.feature.0.is.not.supported.in.k1.mode=K1 模式不支持功能“{0}”
the.following.declarations.have.the.same.jvm.signature.code.0.1.code.br.ul.2.ul=以下声明具有相同的 JVM 签名(<code>{0}{1}</code>)\:<br/>\n<ul>\n{2}</ul>
type.inference.failed.expected.type.mismatch=类型推断失败。预期类型不匹配\:
type.parameters.where=where
unknown.receiver=未知接收器
value.captured.in.a.closure=在闭包中捕获的值
wrapped.into.a.reference.object.to.be.modified.when.captured.in.a.closure=在闭包中捕获时包装成要修改的引用对象

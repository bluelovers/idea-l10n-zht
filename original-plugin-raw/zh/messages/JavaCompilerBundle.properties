0.errors.1.warnings={0} 个错误，{1} 个警告
0.manifest.properties=''{0}'' 清单属性\:
ArtifactPropertiesEditor.tab.post.processing=正在后处理
ArtifactPropertiesEditor.tab.pre.processing=正在预处理
ArtifactPropertiesEditor.tab.validation=验证
abnormal.build.process.termination=构建进程终止异常
action.compile.description.module=模块 ''{0}''
action.compile.description.selected.files=所选文件
action.compiler.properties.text=编译器属性
action.compiler.reference.direct.inheritor.search.text=编译器引用直接继承者搜索
action.compiler.reference.find.usages.text=编译器引用查找用法
action.compiler.reference.functional.expression.search.text=编译器引用函数表达式搜索
action.description.package.file=更新对应工件中的文件
action.disabled.in.fork.mode={0} 在复刻模式下被禁用。<br/>将复刻模式更改为 \\&lt;none\\&gt; 以{1}。
action.disabled.when.per.module.working.directory.configured=配置按模块工作目录时将禁用 ''{0}''。<br/>只指定一个工作目录，或将测试作用域更改为一个模块。
action.make.few.modules.text=构建模块 {0}(_M)
action.make.selected.modules.text=构建选定的模块 (_M)
action.make.single.module.text=构建模块 ''{0}''(_M)
action.name.exclude.from.validation=从验证中排除
action.name.package.file=打包文件
action.name.package.files=打包文件
action.run.all.affected.tests.text=运行所有受影响的测试
action.show.snapshot.location.text=显示快照位置
action.text.move.to=移至
actions.exclude.from.compile.text=从编译中排除
add.notnull.assertions=为非 null 注解的方法和形参添加运行时断言(&A)
affected.tests.counts=\ /{0} 个{1, choice, 0\#测试|1\#测试}
all.inheritors=所有({0})
all.modules=<所有模块>
artifact.configuration.problem.text={0, choice, 1\#{1} 个工件|2\#{0} 个工件}
artifact.type.plain=其他
artifacts.menu.item.all=所有工件
artifacts.menu.item.build=构建
artifacts.menu.item.clean=清理
artifacts.menu.item.edit=编辑…
artifacts.menu.item.rebuild=重新构建
bad.resource.patterns.dialog.title=格式不正确的资源模式
build.artifacts.before.run.description.empty=编译 Artifacts
build.artifacts.before.run.description.multiple=编译 {0} artifacts
build.artifacts.before.run.description.single=构建 ''{0}'' 工件
build.artifacts.before.run.selector.title=编译 Artifacts
build.process.ecj.path.does.not.exist=eclipse ecj 编译器的路径不存在\: {0}
build.process.no.free.debug.port=找不到可用的端口来调试构建进程
build.process.no.javac.found=JRE 未提供系统 java 编译器。确保 IntelliJ IDEA 类路径中存在 tools.jar。
build.process.no.javac.path.found=无法确定 {0} ({1})到 ''tools.jar'' 库的路径
build.process.wsl.distribution.dont.match=正在尝试使用 JDK {0} 开始构建，该版本的 JDK 未存储在项目的 WSL 发行版中。\n运行构建的 JDK 以及项目使用的 JDK 必须存储在存储项目的同一 WSL 发行版中。\n运行构建需要 JDK {1} 或更高版本。如果您的项目使用的是较旧的 JDK，请将 JDK {1} 或更高版本添加到您的 SDK 配置表中。此 JDK 将被自动选取以运行构建。
button.add=添加(&A)…
button.rebuild=重新构建
button.text.checkin.handler.show.errors=展示错误 (&S)
cannot.clean.0.artifact=无法清理 ''{0}'' 工件
cannot.create.directory.0.1=无法创建目录 ''{0}''\: {1}
cannot.delete.0=无法删除 ''{0}''
cannot.package.file=无法打包文件
checkbox.text.compile.affected.unloaded.modules=编译受影响的已卸载模块 (&U)
choose.members=选择成员
chooser.description.select.output.directory.for.0.artifact=选择''{0}'' artifact的输出目录
class.can.be.record.suppress.conversion.if.annotated.description=指定类名或软件包通配符，例如 <code>com.example.*</code>
class.can.have.more.common.super.class=类可以拥有更常见的超类
classes.up.to.date.check=类最新状态检查
clean.artifacts=清理工件
cleaning.artifacts=正在清理工件
compilation.finished=编译已完成
compiler.build.messages.classes.check.outdated=构建结果对请求的编译作用域来说已过时。\n后续增量构建将为更改的源编译文件，并移除先前构建的过时结果。
compiler.build.messages.classes.check.uptodate=构建结果对请求的编译作用域来说处于最新状态。\n后续增量构建将不会执行任何操作。
compiler.cache.description=编译器缓存
compiler.cache.option.cleanup.asynchronously=异步清理
compiler.cache.option.disable.update=禁用缓存下载
compiler.cache.option.force.update=强制更新缓存
compiler.cache.option.max.download.time=缓存下载的最长持续时间\:
compiler.cache.option.max.download.time.units=分钟
compiler.configurable.display.name=编译器
compiler.content.name.make=构建
compiler.content.name.rebuild=重新构建
compiler.content.name.recompile=重新编译
compiler.eclipse.name=Eclipse
compiler.error.failed.to.delete=无法删除 {0}
compiler.javac.name=Javac
compiler.results.export.text.prefix=行 ({0})
compiler.running.dialog.title=编译器运行中
compiler.ui.pattern.context.help=<ul><li><code>?</code> \\&\#8594; 仅一个符号；<li><code>*</code> \\&\#8594; 无或更多符号；<li><code>/</code> \\&\#8594; 路径分隔符；<li><code>/**/</code> \\&\#8594; 任何数量的目录；<li><code>\\&lt;dir_name\\&gt;\:\\&lt;pattern\\&gt;</code> \\&\#8594; 限制为具有指定名称的源根。</ul>
compiler.ui.pattern.context.help.title=已接受的通配符
compiler.ui.pattern.legend.text=使用 <b>;</b> 分隔模式，使用 <b>\!</b> 求反模式。
configurable.AnnotationProcessorsConfigurable.display.name=注解处理器
configurable.CompilerUIConfigurable.display.name=常规
configuration.for.java.scratch.files=Java 临时文件的配置
confirm.project.rebuild=确认项目重新构建
create.jar.from.modules=从模块创建 JAR
dialog.message.action.apply.fix=自动修复
dialog.message.compilation.of.unloaded.modules.failed=项目中有未加载的模块依赖于更改的文件。\n这些模块的编译已完成，但存在错误。
dialog.message.enter.directory.name=输入目录名称\:
dialog.message.error.jdk.not.specified.with.fixSuggestion=没有为 {0} {1,choice, 1\#模块|2\#模块}指定 SDK，或其 SDK 已损坏。自动解析以下 SDK?
dialog.message.error.jdk.not.specified.with.noFix=需要手动配置\:
dialog.message.jar.file.doesn.t.exist=JAR 文件 ''{0}'' 不存在
dialog.message.output.dir.artifact=''{0}'' 工件(''{1}'')
dialog.message.output.dir.contains.source.roots=''{1}'' 工件的输出目录 ''{0}'' 包含项目的源根。是否继续并将其清除?
dialog.message.output.dirs.contain.source.roots=以下工件的输出目录包含源根\:\n{0}是否要继续并清除这些目录?
dialog.message.profile.name=配置文件名称
dialog.title.choose.artifacts=选择 Artifacts
dialog.title.choose.module=选择模块
dialog.title.manifest.select.main.class=选择主类
dialog.title.output.directory.for.artifact=Artifact输出目录
dialog.title.packaging.choose.library=选择库
dialog.title.packaging.choose.module=选择模块
directory.copy.element.type.name=目录内容
disabled.in.power.save.mode=在省电模式下禁用
eclipse.compiler.path.comment=留空以使用捆绑
eclipse.compiler.path.label=ECJ 批量编译器工具的路径\:
eclipse.compiler.proceed.on.errors.option=遇到错误时继续
eclipse.options.group.title=Eclipse 选项
edit.classpath=编辑类路径
element.type.name.archive=归档
element.type.name.artifact=工件
element.type.name.directory=目录
element.type.name.library.files=库文件
element.type.name.module.output=模块输出
element.type.name.module.source=模块源
element.type.name.module.test.output=模块测试输出
element.with.manifest.button.create.manifest=创建清单(&C)…
element.with.manifest.button.use.existing.manifest=使用现有清单(&U)…
element.with.manifest.label.manifest.file=清单文件(&F)\:
element.with.manifest.label.meta.inf.manifest.mf.file.not.found=找不到 META-INF/MANIFEST.MF 文件
enter.archive.name=输入归档名称\:
error.associated.scratch.file.not.found=未找到关联的临时文件
error.bad.resource.patterns=以下资源模式格式错误\:{0}
error.chunk.modules.must.have.same.jdk=以下模块必须具有相同的 JDK 分配，因为它们之间的循环依赖关系\:\n{0}\n请更新模块配置
error.chunk.modules.must.have.same.language.level=以下模块必须具有相同的语言级别，因为它们之间存在循环依赖关系\:\n{0}\n请更新模块配置
error.clean.state.rebuild.not.possible=如果选项“重建时清除输出目录”设置为“false”，则无法完全清除构建系统数据。构建系统数据将作为项目重建的一部分被清除。
error.compiler.configurable.malformed.patterns=以下资源模式格式错误\:\n{0}
error.javac.out.of.memory=内存不足。在“项目属性|编译器”设置中增加堆大小上限。
error.jdk.module.names.overflow.element.ellipsis=…
error.jdk.not.specified=没有为{0,choice, 1\#模块|2\#模块} {1} 指定 SDK
error.no.scratch.file.associated.with.configuration=没有与配置关联的临时文件
error.output.not.specified=没有为{0,choice, 1\#模块|2\#模块} {1} 指定输出路径
error.task.0.execution.failed=任务 {0} 失败，请参阅 idea.log 了解详细信息
exclude.from.compile.table.path.column.name=路径
exclude.from.compile.table.recursively.column.name=递归
extracted.directory.element.type.name=已提取目录
file.title=文件
intention.name.make.extends=生成扩展 ''{0}''
intention.name.make.implements=生成实现 ''{0}''
jar.artifacts.dialog.border.title.jar.files.from.libraries=来自库的 JAR 文件
jar.artifacts.dialog.checkbox.include.tests=包含测试(&I)
jar.artifacts.dialog.label.directory.for.metainf=META-INF/MANIFEST.MF 的目录(&D)\:
jar.artifacts.dialog.label.main.class=主类(&C)\:
jar.artifacts.dialog.label.module=模块(&M)\:
jar.artifacts.dialog.radio.button.copy.to.the.output.directory.and.link.via.manifest=复制到输出目录并通过清单链接(&T)
jar.artifacts.dialog.radio.button.extract.to.the.target.jar=提取到目标 JAR(&E)
jar.from.modules.presentable.name=从具有依赖项的模块…
jar.text=JAR
java.compiler.description=Java编译器
java.compiler.option.additional.command.line.parameters=附加命令行形参\:
java.compiler.option.generate.debugging.info=生成调试信息
java.compiler.option.generate.no.warnings=不生成警告
java.compiler.option.prefer.target.jdk.compiler=尽可能使用模块目标 JDK 中的编译器
java.compiler.option.report.deprecated=报告使用弃用的功能
java.scratch=Java 草稿
javac.options.group.title=Javac 选项
jshell.console=JShell 控制台
jshell.dropped.x.code.snippets=已丢弃 {0} 代码段
jshell.internal.error=内部错误
jshell.nothing.to.execute=没有要执行的内容
label.address=地址(&A)\:
label.debugger.mode=调试器模式(&D)\:
label.extracted.dir.presentation=已提取 ''{0}''
label.host=主机(&H)\:
label.in.path.suffix=(在 {0} 中)
label.library.element.module=模块 ''{0}''
label.option.autoshow.first.error=在编辑器中自动显示错误 (&E)
label.option.clear.output.directory.on.rebuild=在重新构建时清除输出目录 (&L)
label.option.display.notification.popup=在构建完成时显示通知
label.option.resource.patterns.text=资源模式\:
label.port=端口(&P)\:
label.text.class.path=类路径 (&P)\:
label.text.main.class=主类 (&M)\:
label.transport=传输(&T)\:
label.unknown.value=<未知>
link.label.checkin.handler.show.errors=显示错误
macro.output.path=输出路径
mesage.text.deployment.descriptor.file.not.exist=部署描述符文件 ''{0}'' 不存在
message.category.error=错误
message.category.information=信息
message.category.statistics=统计
message.category.warning=警告
message.resource.patterns.format.changed=资源模式的格式已更改。\n{0} 无法转换现有的正则表达式模式\:\n{1}\n请以新格式输入模式字符串。\n每个资源模式可以包含以下通配符\:\n? - 一个字符\n* - 零个或多个字符\n\! - 反转匹配（仅允许在模式开头）\n使用 ; (分号)来分隔资源模式；\n使用反斜杠(“\\”)转义“\!”字符。\n您可能还需要修改模板项目设置。\n按 ''{2}'' 接受输入的模式，按 ''{3}'' 以新格式加载默认模式。
message.tect.package.file.io.error=IO异常\:\n{0}
message.text.deployment.description.invalid.file=无效文件
message.text.error.copying.file.to.file=将文件 ''{0}'' 复制到 ''{1}'' 时出错。
message.text.xml.file.invalid=XML文件 ''{0}'' 无效
meta.inf.manifest.mf.file.not.found.in.0=在 ''{0}'' 中未找到 META-INF/MANIFEST.MF 文件
module.sources.set.display.name={0, choice, 0\#|1\#测试 }''{1}'' 模块
modules.classpath.title=依赖
no.compilation.problems.found=未找到编译问题
no.excludes=不排除
no.validators=没有验证器可用
node.excluded.flag.tooltip=排除
node.text.0.compile.output=''{0}'' 编译输出
node.text.0.directory.content=''{0}'' 目录内容
node.text.0.module.sources=''{0}'' 源
node.text.0.test.compile.output=''{0}'' 测试编译输出
notification.action.enable.space.plugin=启用 Space 插件
notification.action.install.space.plugin=安装 Space 插件
notification.action.jps.open.configuration.dialog=配置…
notification.compiler.auto.build.completed.with.errors=自动构建完成但有错误
notification.compiler.auto.build.failure=自动构建失败\: {0}
notification.content.git.crlf.config=要使编译器缓存正常工作，您需要执行 <code>{0}</code> 命令并强制签出项目
notification.content.space.plugin.required.for.correct.work=要使用 JPS 缓存，必须先安装或启用 Space 插件
notification.group.compiler=构建已完成
notification.group.title.jps.cannot.start.compiler=构建启动失败
notification.title.cpu.snapshot.build.has.been.captured=已捕获构建 CPU 快照
notification.title.git.crlf.config=Git 行尾配置错误
notification.title.jps.caches.downloader=JPS 缓存下载程序
notification.title.jps.cannot.start.compiler=无法启动编译器
only.works.while.not.running.debugging=仅在不运行/不调试时工作
option.use.compiler.text=使用编译器\:
packaging.element.text.output.root=<输出根>
packaging.files=正在打包文件
path.to.ecj.compiler.tool=ECJ 编译器工具的路径
pattern.conversion.dialog.title=模式转换
plugins.advertiser.feature.artifact=工件
popup.advertisement.debug.with.shift.navigate.with.f4=使用 {0} 调试，使用 F4 导航
popup.title.affected.tests.counts=已在{2}{3, choice, 0\#类|1\#类}中为 {4} 找到 {0} 个{1, choice, 0\#测试|1\#测试}
popup.title.choose.suite.to.add=选择要添加的套件
popup.title.chosen.artifact.action={0,choice,0\#{0} 个工件|1\#|2\# {0} 个工件}的操作
popup.title.debug.recent.tests=调试最近的测试
popup.title.run.recent.tests=运行最近的测试
progress.compiling.class=正在编译 {0}…
progress.executing.postcompile.tasks=执行后编译任务…
progress.executing.precompile.tasks=执行预编译任务…
progress.loading.classes=正在加载类…
progress.parsing.file=解析 {0}…
progress.preparing.wsl.build.environment=正在准备 WSL 构建环境…
progress.text.clearing.build.system.data=正在清除构建系统数据…
progress.title.cancelling.running.builds=正在取消运行中的构建
progress.updating.caches=正在更新缓存…
rebuild.lvcs.label.no.errors=''{0}''没有错误
rebuild.lvcs.label.with.errors=''{0}''没有错误
reference.projectsettings.compiler.annotationProcessors=注解处理器
reference.projectsettings.compiler.excludes=排除
rmi.compiler.description=RMI编译器
rmic.option.enable.rmi.stubs=启用RMI存根生成
rmic.option.generate.iiop.stubs=生成IIOP存根
select.directory.for.meta.inf.manifest.mf.file=为 META-INF/MANIFEST.MF 文件选择目录
separator.choose.members.to.delete=<html>选择已在 <b>{0}</b> 中定义的成员将其删除
settings.actions.on.save.page.build.project.on.save.checkbox=构建项目
settings.actions.on.save.page.build.project.on.save.checkbox.comment=运行/调试时未触发
settings.actions.on.save.page.compiler.settings.link=编译器设置…
settings.additional.compilation.options=其他编译选项也同样适用于所有模块
settings.all.modules.will.be.compiled.with.project.bytecode.version=所有模块都将使用项目字节码版本进行编译
settings.annotation.processing.proc.only=在编译 java(-proc\:only 模式)之前，在单独的步骤中运行处理器 
settings.annotation.processor.options=注解处理器选项\:
settings.annotation.processors=注解处理器\:
settings.auto.build.only.works.while.not.running=仅在不运行/不调试时工作
settings.build.process.group=构建进程
settings.build.process.heap.size=共享堆大小\:
settings.build.project.automatically=自动构建项目
settings.column.option.name=选项名称
settings.column.value=值
settings.compile.independent.modules.in.parallel=并行编译独立模块\:
settings.compile.independent.modules.in.parallel.automatic=自动的
settings.compile.independent.modules.in.parallel.disabled=已禁用
settings.compile.independent.modules.in.parallel.enabled=已启用
settings.compiler.will.run.all.automatically.discovered.processors=编译器将运行所有自动发现的处理器
settings.configure.annotations=配置注解(&C)…
settings.enable.annotation.processing=启用注解处理
settings.exclude.from.validation=从验证中排除\:
settings.module.column=模块
settings.module.content.root=模块内容根
settings.module.output.directory=模块输出目录
settings.module.path.warning=假设指定的路径是 'module path'\: JAR 或包含打包 java 模块的路径。\n要确保被发现并从模块路径运行，注解处理器应打包为 java 模块并使用模块声明中的 ServiceLoader 注册。
settings.no.processor.specific.options.configured=未配置处理器特定选项
settings.obtain.processors.from.project.classpath=从项目类路径获取处理器
settings.override.compilation.options.column=编译选项
settings.override.compiler.parameters.per.module=按模块重写编译器形参\:
settings.override.module.column=模块
settings.parallel.module.compile.context.help.description=在自动模式下，根据硬件规格启用并行编译。</p>
settings.parallel.module.compile.context.help.title=可能需要更大的堆
settings.per.module.bytecode.version=按模块字节码版本\:
settings.processor.fq.name=处理器 FQ 名称
settings.processor.path=处理器路径\:
settings.production.sources.directory=生产源目录\:
settings.project.bytecode.version=项目字节码版本\:
settings.rebuild.module.on.dependency.change=依赖关系更改时重新构建模块
settings.recommended.in.paths=建议在路径中使用 '/' 进行跨平台配置
settings.same.as.language.level=与语言级别相同
settings.shared.build.process.vm.options=共享虚拟机选项\:
settings.size.mbytes=MB
settings.store.generated.sources.relative.to=存储相对于下列位置生成的源\:
settings.target.bytecode.version=目标字节码版本
settings.test.sources.directory=测试源目录\:
settings.use.processor.module.path.compiler.option.for.java.9.and.later=使用 --processor-module-path 编译器选项 (适用于 Java 9 及更高版本)
settings.use.release.option.for.cross.compilation=使用 '--release' 选项进行交叉编译 (Java 9 及更高版本)
settings.user.local.build.process.heap.size=用户本地堆大小\:
settings.user.local.build.process.heap.size.comment=重写共享大小
settings.user.local.build.process.vm.options=用户本地虚拟机选项\:
settings.user.local.build.process.vm.options.comment=重写共享选项
settings.validate.on.build=构建时验证
settings.validators=验证器\:
settings.warn.on.arch.mismatch=如果 JDK 和系统架构不匹配则发出警告
settings.warning=警告\: 如果启用，存储生成源的目录的全部内容将在重建时被清除。
shift.key=Shift
show.content.of.included.artifacts=显示已包含工件的内容
show.library.files=显示库文件
specify.path.to.manifest.mf.file=指定 MANIFEST.MF 文件的路径
status.all.up.to.date=所有文件都处于最新状态
status.compilation.aborted=编译中止
status.compilation.completed.successfully=构建在 {0}内成功完成
status.compilation.completed.successfully.with.warnings=在 {1}内成功完成编译，包含 {0} 个{0,choice, 0\#警告|1\#警告|2\#警告}
status.compilation.completed.successfully.with.warnings.and.errors=在 {2}内成功完成编译，包含 {0} 个{0,choice, 0\#错误|1\#错误|2\#错误}和 {1} 个{1,choice, 0\#警告|1\#警告|2\#警告}
status.text.file.has.been.packaged={0, choice, 1\#文件|2\#文件} {1} {0, choice, 1\#已|2\#已}在 {2} 打包。
synchronizing.output.directories=正在同步输出目录…
tab.title.thread.dump=转储 {0}
test.discovery.find.affected.tests=查找受影响的测试…
test.discovery.parametrized=已形参化
test.discovery.show.affected.tests=显示受影响的测试
test.discovery.tests.tab.title={0} 的测试
test.discovery.unused.test.data.tab.title=未使用的测试数据
text.empty.profile=配置文件名称不应为空
text.profile.exists=配置文件 {0} 已存在
title.create.new.profile=创建新的配置文件
title.new.archive=新建归档
title.new.directory=新建目录
unknown.artifact.properties.0=未知工件属性\: {0}
unknown.artifact.remove.confirmation=是否要移除工件 ''{0}''?
unknown.artifact.type.0=未知工件类型\: {0}
unknown.build.process.error=未知错误
unknown.element.0=未知元素\: {0}
validation.display.name=验证
warning.compiler.running.on.toolwindow.close=编译器正在运行。将其终止?
warning.text.file.has.been.changed=文件在编译期间已更改，跳过检查验证
whole.project=<整个项目>
wsl.network.connection.failure=无法建立从 WSL 到 Windows 主机的网络连接(可能被防火墙阻止)。\n要了解详细信息，请参阅\: https\://jb.gg/wsl-firewall
you.are.about.to.rebuild.the.whole.project=您将重新构建整个项目。\n运行“构建项目”?

message.category.error=错误
message.category.warning=警告
message.category.information=信息
message.category.statistics=统计
error.javac.out.of.memory=内存不足. 在 项目属性|编译器 设置中增加最大堆大小.
progress.loading.classes=加载类...
progress.compiling.class=编译 {0}...
progress.parsing.file=解析 {0}...
action.compile.description.module=模块 ''{0}''
action.compile.description.selected.files=所选文件
rebuild.lvcs.label.no.errors=''{0}''没有错误
rebuild.lvcs.label.with.errors=''{0}''没有错误
action.make.selected.modules.text=构建选定的模块 (_M)
message.resource.patterns.format.changed=资源模式的格式发生变化.\n\
{0} 无法转换现有的正则表达式模式:\n\
{1}\n\
请以新格式输入模式字符串.\n\
每个资源模式可能包含以下通配符:\n\
? - 一个字符\n\
* - 零或更多的字符\n\
! - 否定模式 (仅在模式开始时允许)\\u4F7F用 ; (分号) 分隔资源模式;\n\
避免 "!" 带有反斜杠 ("\")的字符.\n\
您可能还需要修改模板项目设置.\\u6309''{2}''接受输入的模式, ''{3}''将默认模式加载新格式.
pattern.conversion.dialog.title=模式转换
error.bad.resource.patterns=以下资源模式格式错误:{0}
bad.resource.patterns.dialog.title=格式不正确的资源模式
compiler.results.export.text.prefix=行 ({0})
status.compilation.aborted=编译中止
status.all.up.to.date=所有文件都处于最新状态
compiler.error.failed.to.delete=无法删除 {0}
compiler.build.messages.classes.check.uptodate=构建结果对请求的编译范围来说处于最新状态。\n\
后续增量构建将不会执行任何操作。
compiler.build.messages.classes.check.outdated=构建结果对请求的编译范围来说已过时。\n\
后续增量构建将为更改的源编译文件，并移除先前构建的过时结果。
progress.updating.caches=更新缓存...
compiler.content.name.rebuild=重新构建
compiler.content.name.recompile=重新编译
compiler.content.name.make=构建
modules.classpath.title=依赖
status.compilation.completed.successfully.with.warnings=成功编译完成{1}中 {0} {0,choice, 0#个警告|1#个警告|2#个警告}
status.compilation.completed.successfully=构建在 {0} 中成功完成
status.compilation.completed.successfully.with.warnings.and.errors=编译完成{2}中 {0} {0,choice, 0#个错误|1#个错误|2#个错误} 和 {1} {1,choice, 0#个警告|1#个警告|2#个警告}
progress.executing.precompile.tasks=执行预编译任务...
progress.executing.postcompile.tasks=执行后编译任务...
error.chunk.modules.must.have.same.jdk=以下模块必须具有相同的JDK分配, 因为它们之间的循环依赖关系:\n\
{0}\n\
请更新模块配置
error.chunk.modules.must.have.same.language.level=以下模块必须具有相同的语言级别,因为它们之间存在循环依赖关系:\n\
{0}\n\
请更新模块配置
action.compiler.properties.text=编译器属性
actions.exclude.from.compile.text=从编译中排除
java.compiler.description=Java编译器
rmi.compiler.description=RMI编译器
error.jdk.not.specified=没有为{0,choice, 1#模块|2#模块} {1} 指定 SDK
error.jdk.module.names.overflow.element.ellipsis=…
dialog.message.error.jdk.not.specified.with.fixSuggestion=没有为 {0} {1,choice, 1#模块|2#模块}指定 SDK，或其 SDK 已损坏。自动解析以下 SDK?
dialog.message.error.jdk.not.specified.with.noFix=需要手动配置:
dialog.message.action.apply.fix=自动修复
error.output.not.specified=没有为{0,choice, 1#模块|2#模块} {1} 指定输出路径
compiler.javac.name=Javac
compiler.configurable.display.name=编译器
label.option.clear.output.directory.on.rebuild=在重新构建时清除输出目录 (&L)
label.option.resource.patterns.text=资源模式:
error.compiler.configurable.malformed.patterns=以下资源模式格式错误:\n\
{0}
exclude.from.compile.table.path.column.name=路径
exclude.from.compile.table.recursively.column.name=递归
no.excludes=不排除
option.use.compiler.text=使用编译器:
java.compiler.option.additional.command.line.parameters=附加命令行形参:
java.compiler.option.generate.no.warnings=不生成警告
java.compiler.option.generate.debugging.info=生成调试信息
java.compiler.option.report.deprecated=报告使用弃用的功能
javac.options.group.title=Javac 选项
rmic.option.generate.iiop.stubs=生成IIOP存根
rmic.option.enable.rmi.stubs=启用RMI存根生成
compiler.running.dialog.title=编译器运行中
warning.compiler.running.on.toolwindow.close=编译器正在运行. 终止它?
add.notnull.assertions=为非空注释的方法和参数,添加运行时断言 (&A)

compiler.eclipse.name=Eclipse
eclipse.options.group.title=Eclipse 选项

#artifacts
packaging.element.text.output.root=<输出根>
label.text.main.class=主类 (&M):
label.text.class.path=类路径 (&P):
element.type.name.artifact=工件
dialog.title.choose.artifacts=选择 Artifacts
node.text.0.directory.content=''{0}'' 目录内容
element.type.name.library.files=库文件
node.text.0.compile.output=''{0}'' 编译输出
node.text.0.test.compile.output=''{0}'' 测试编译输出
node.text.0.module.sources=''{0}'' 源
element.type.name.module.source=模块源
element.type.name.module.output=模块输出
element.type.name.module.test.output=模块测试输出
element.type.name.directory=目录
element.type.name.archive=档案
artifact.type.plain=其他
build.artifacts.before.run.description.empty=编译 Artifacts
build.artifacts.before.run.description.single=编译 ''{0}'' artifact
build.artifacts.before.run.description.multiple=编译 {0} artifacts
build.artifacts.before.run.selector.title=编译 Artifacts

message.text.error.copying.file.to.file=拷贝文件 ''{0}'' 到 ''{1}''错误.
message.text.xml.file.invalid=XML文件 ''{0}'' 无效
mesage.text.deployment.descriptor.file.not.exist=部署描述符文件 ''{0}'' 不存在
message.text.deployment.description.invalid.file=无效文件
warning.text.file.has.been.changed=文件在编译期间已更改, 跳过检查验证

dialog.message.compilation.of.unloaded.modules.failed=项目中有未加载的模块取决于更改的文件。<br>这些模块的编译已完成，但出现错误。
dialog.title.compilation.failed=编译失败
button.text.checkin.handler.commit=提交 (&C)
button.text.checkin.handler.show.errors=展示错误 (&S)
checkbox.text.compile.affected.unloaded.modules=编译受影响的已卸载模块 (&U)

#artifacts
dialog.title.output.directory.for.artifact=Artifact输出目录
chooser.description.select.output.directory.for.0.artifact=选择''{0}'' artifact的输出目录

#package file action
action.name.package.file=打包文件
action.description.package.file=更新对应工件中的文件
message.tect.package.file.io.error=IO异常:\n\
{0}
status.text.file.has.been.packaged={0, choice, 1#文件|2#文件} {1} {0, choice, 1#已|2#已}在 {2} 打包。
action.name.package.files=打包文件

# validation
validation.display.name=验证
action.name.exclude.from.validation=从验证中排除
no.validators=没有验证器可用
label.option.autoshow.first.error=在编辑器中自动显示错误 (&E)
label.option.display.notification.popup=在构建完成时显示通知

java.compiler.option.prefer.target.jdk.compiler=尽可能使用模块目标JDK的编译器
configurable.CompilerUIConfigurable.display.name=常规
configurable.AnnotationProcessorsConfigurable.display.name=注解处理器
settings.configure.annotations=配置注解(&C)…
settings.build.project.automatically=自动构建项目
settings.compile.independent.modules.in.parallel=并行编译独立模块
settings.rebuild.module.on.dependency.change=依赖关系更改时重新构建模块
settings.build.process.heap.size=共享构建进程堆大小(MB):
settings.user.local.build.process.heap.size=用户本地构建进程堆大小(MB)(重写共享大小):
settings.shared.build.process.vm.options=共享构建过程 VM 选项:
settings.user.local.build.process.vm.options=用户本地构建过程 VM 选项 (重写共享选项):
settings.auto.build.only.works.while.not.running=(仅在不运行/不调试时工作)
settings.parallel.module.compile.may.require.larger.heap.size=(可能需要更大的堆)
settings.warning=<html>警告!<br>如果已启用选项“重新构建时清除输出目录”，存储生成源的目录的全部内容将在重新构建时清除。</html>
settings.use.release.option.for.cross.compilation=使用 '--release' 选项进行交叉编译 (Java 9 及更高版本)
settings.project.bytecode.version=项目字节码版本:
settings.per.module.bytecode.version=按模块字节码版本:
settings.same.as.language.level=与语言级别相同
settings.all.modules.will.be.compiled.with.project.bytecode.version=所有模块都将使用项目字节码版本进行编译
settings.module.column=模块
settings.target.bytecode.version=目标字节码版本
settings.recommended.in.paths=(建议在路径中使用 '/' 进行跨平台配置)
settings.override.compiler.parameters.per.module=按模块重写编译器参数:
settings.override.module.column=模块
settings.override.compilation.options.column=编译选项
settings.additional.compilation.options=其他编译选项也同样适用于所有模块
settings.enable.annotation.processing=启用注解处理
settings.annotation.processing.proc.only=在编译 java(-proc:only 模式)之前，在单独的步骤中运行处理器 
settings.obtain.processors.from.project.classpath=从项目类路径获取处理器
settings.processor.path=处理器路径:
settings.use.processor.module.path.compiler.option.for.java.9.and.later=使用 --processor-module-path 编译器选项 (适用于 Java 9 及更高版本)
settings.module.content.root=模块内容根
settings.module.output.directory=模块输出目录
settings.annotation.processors=注解处理器:
settings.compiler.will.run.all.automatically.discovered.processors=编译器将运行所有自动发现的处理器
settings.annotation.processor.options=注解处理器选项:
settings.no.processor.specific.options.configured=未配置处理器特定选项
settings.module.path.warning=假设指定的路径是 'module path': JAR 或包含打包 java 模块的路径。\n\
要确保被发现并从模块路径运行，注解处理器应打包为 java 模块并使用模块声明中的 ServiceLoader 注册。
settings.store.generated.sources.relative.to=存储相对于下列位置生成的源:
settings.production.sources.directory=生产源目录:
settings.column.option.name=选项名称
settings.column.value=值
settings.test.sources.directory=测试源目录:
settings.processor.fq.name=处理器 FQ 名称
settings.validate.on.build=构建时验证
settings.exclude.from.validation=从验证中排除:
settings.validators=验证器:
no.compilation.problems.found=未找到编译问题
cannot.package.file=无法打包文件
packaging.files=正在打包文件
only.works.while.not.running.debugging=(仅在不运行/不调试时工作)
disabled.in.power.save.mode=(在省电模式下禁用)
path.to.ecj.compiler.tool=ecj 编译器工具的路径
choose.members=选择成员
all.modules=<所有模块>
create.jar.from.modules=从模块创建 JAR
cannot.delete.0=无法删除 ''{0}''
cannot.clean.0.artifact=无法清理 ''{0}'' 工件
cleaning.artifacts=正在清理工件
clean.artifacts=清理工件
0.errors.1.warnings={0} 个错误，{1} 个警告
compilation.finished=编译已完成
meta.inf.manifest.mf.file.not.found.in.0=在 ''{0}'' 中未找到 META-INF/MANIFEST.MF 文件
0.manifest.properties=''{0}'' 清单属性:
specify.path.to.manifest.mf.file=指定 MANIFEST.MF 文件的路径
edit.classpath=编辑类路径
synchronizing.output.directories=正在同步输出目录…
button.rebuild=重新构建
confirm.project.rebuild=确认项目重新构建
you.are.about.to.rebuild.the.whole.project=您将重新构建整个项目。\n\
运行“构建项目”?
class.can.have.more.common.super.class=类可以拥有更常见的超类
cannot.create.directory.0.1=无法创建目录 ''{0}'': {1}
select.directory.for.meta.inf.manifest.mf.file=为 META-INF/MANIFEST.MF 文件选择目录
title.new.archive=新建归档
enter.archive.name=输入归档名称:
action.text.move.to=移至
title.create.new.profile=创建新的配置文件
dialog.message.profile.name=配置文件名称
title.new.directory=新建目录
dialog.message.enter.directory.name=输入目录名称:
dialog.title.packaging.choose.module=选择模块
dialog.title.packaging.choose.library=选择库
node.excluded.flag.tooltip=排除
macro.output.path=输出路径
button.add=添加(&A)…
eclipse.compiler.cross.platform.help.message=(建议在路径中使用 '/' 进行跨平台配置)
eclipse.compiler.path.leave.empty.help.message=ECJ 批处理编译器工具的路径(若留空，则使用捆绑路径):
eclipse.compiler.proceed.on.errors.option=遇到错误时继续
progress.title.cancelling.auto.make.builds=正在取消自动生成构建
abnormal.build.process.termination=构建进程终止异常
wsl.network.connection.failure=无法建立从 WSL 到 Windows 主机的网络连接(可能被防火墙阻止)。\n\
要了解详细信息，请参阅: https://jb.gg/wsl-firewall
unknown.build.process.error=未知错误
intention.name.make.implements=生成实现 ''{0}''
intention.name.make.extends=生成扩展 ''{0}''
classes.up.to.date.check=类最新状态检查

action.run.all.affected.tests.text=运行所有受影响的测试
popup.title.affected.tests.counts=已在{2}{3, choice, 0#类|1#类}中为 {4} 找到 {0} 个{1, choice, 0#测试|1#测试}

popup.title.chosen.artifact.action={0,choice,0#{0} 工件|1#|2# {0} 工件}的操作
dialog.message.output.dir.contains.source.roots=''{1}'' 工件的输出目录 ''{0}'' 包含项目的源根。是否继续并将其清除?
dialog.message.output.dir.artifact= ''{0}'' 工件(''{1}'')
dialog.message.output.dirs.contain.source.roots=以下工件的输出目录包含源根:\n\
{0}是否继续并清除这些目录?
action.compiler.reference.find.usages.text=编译器引用查找用法
action.compiler.reference.functional.expression.search.text=编译器引用函数表达式搜索
action.compiler.reference.direct.inheritor.search.text=编译器引用直接继承者搜索
progress.text.clearing.build.system.data=正在清除构建系统数据…
separator.choose.members.to.delete=<html>选择已在 <b>{0}</b> 中定义的成员将其删除
text.empty.profile=配置文件名称不应为空
text.profile.exists=配置文件 {0} 已存在
compiler.ui.pattern.legend.text=使用 <b>;</b> 分隔模式，使用 <b>!</b> 求反模式。已接受通配符: <b>?</b> \\&mdash; 仅一个符号；<b>*</b> \\&mdash; 无或更多符号；<b>/</b> \\&mdash; 路径分隔符；<b>/**/</b> \\&mdash; 任何数量的目录；<i>\\&lt;dir_name\\&gt;</i>:<i>\\&lt;pattern\\&gt;</i> \\&mdash; 限制为具有指定名称的源根
notification.compiler.auto.build.failure=自动构建失败: {0}
notification.compiler.auto.build.completed.with.errors=自动构建完成但有错误
dialog.title.manifest.select.main.class=选择主类
label.unknown.value=<未知>
label.extracted.dir.presentation=已提取 ''{0}''
label.library.element.module=模块 ''{0}''
label.in.path.suffix=(在 {0} 中)
jar.text=JAR
jar.from.modules.presentable.name=来自具有依赖项的模块…
unknown.artifact.type.0=未知工件类型: {0}
unknown.element.0=未知元素: {0}
unknown.artifact.properties.0=未知工件属性: {0}
artifact.configuration.problem.text={0, choice, 1#{1} 个工件|2#{0} 个工件}
unknown.artifact.remove.confirmation=是否要移除工件 ''{0}''?
show.content.of.included.artifacts=显示已包含工件的内容
show.library.files=显示库文件
directory.copy.element.type.name=目录内容
extracted.directory.element.type.name=已提取目录
file.title=文件
action.disabled.when.per.module.working.directory.configured=配置按模块工作目录时将禁用 ''{0}''。<br/>只指定一个工作目录，或将测试范围更改为一个模块。
action.disabled.in.fork.mode={0} 在复刻模式下被禁用。<br/>将复刻模式更改为 \\&lt;none\\&gt; 以{1}。
popup.title.choose.suite.to.add=选择要添加的套件
tab.title.thread.dump=转储 {0}
whole.project=<整个项目>
dialog.message.jar.file.doesn.t.exist=JAR 文件 ''{0}'' 不存在
jshell.nothing.to.execute=没有要执行的内容
jshell.internal.error=内部错误
jshell.dropped.x.code.snippets=已丢弃 {0} 代码段
jshell.console=JShell 控制台
all.inheritors=所有({0})
label.debugger.mode=调试器模式(&D):
label.host=主机(&H):
label.transport=传输(&T):
label.port=端口(&P):
label.address=地址(&A):
error.no.scratch.file.associated.with.configuration=没有与配置关联的临时文件
error.associated.scratch.file.not.found=未找到关联的临时文件
java.scratch=Java 草稿
configuration.for.java.scratch.files=Java 临时文件的配置
test.discovery.show.affected.tests=显示受影响的测试
test.discovery.parametrized=已形参化
test.discovery.unused.test.data.tab.title=未使用的测试数据
test.discovery.tests.tab.title={0} 的测试
popup.title.debug.recent.tests=调试最近的测试
popup.title.run.recent.tests=运行最近的测试
shift.key=Shift
popup.advertisement.debug.with.shift.navigate.with.f4=使用 {0} 调试，使用 F4 导航
module.sources.set.display.name={0, choice, 0#|1#测试 }''{1}'' 模块
ArtifactPropertiesEditor.tab.validation=验证
ArtifactPropertiesEditor.tab.post.processing=正在后处理
ArtifactPropertiesEditor.tab.pre.processing=正在预处理
reference.projectsettings.compiler.excludes=排除
reference.projectsettings.compiler.annotationProcessors=注解处理器
affected.tests.counts=\ / {0} 个{1, choice, 0#测试|1#测试}
artifacts.menu.item.all=所有工件
artifacts.menu.item.build=构建
artifacts.menu.item.clean=清理
artifacts.menu.item.rebuild=重新构建
artifacts.menu.item.edit=编辑…
error.task.0.execution.failed=任务 {0} 失败，请参阅 idea.log 了解详细信息
dialog.title.choose.module=选择模块
build.process.no.javac.found=JRE 未提供系统 java 编译器。确保 IntelliJ IDEA 类路径中存在 tools.jar。
build.process.no.javac.path.found=无法确定 {0} ({1})到 ''tools.jar'' 库的路径
build.process.no.free.debug.port=找不到可用的端口来调试构建进程
build.process.ecj.path.does.not.exist=eclipse ecj 编译器的路径不存在: {0}
jar.artifacts.dialog.label.directory.for.metainf=META-INF/MANIFEST.MF 的目录(&D):
jar.artifacts.dialog.checkbox.include.tests=包含测试(&I)
jar.artifacts.dialog.label.module=模块(&M):
jar.artifacts.dialog.border.title.jar.files.from.libraries=来自库的 JAR 文件
jar.artifacts.dialog.radio.button.extract.to.the.target.jar=提取到目标 JAR(&E)
jar.artifacts.dialog.radio.button.copy.to.the.output.directory.and.link.via.manifest=复制到输出目录并通过清单链接(&T)
jar.artifacts.dialog.label.main.class=主类(&C):

element.with.manifest.button.create.manifest=创建清单(&C)…
element.with.manifest.button.use.existing.manifest=使用现有清单(&U)…
element.with.manifest.label.meta.inf.manifest.mf.file.not.found=找不到 META-INF/MANIFEST.MF 文件
element.with.manifest.label.manifest.file=清单文件(&F):

notification.group.title.jps.cannot.start.compiler=构建启动失败
notification.action.jps.open.configuration.dialog=配置…
notification.title.jps.cannot.start.compiler=无法启动编译器
notification.title.cpu.snapshot.build.has.been.captured=已捕获构建 CPU 快照
action.show.snapshot.location.text=显示快照位置
dialog.message.failed.to.determine.host.ip.for.wsl.jdk=无法确定 WSL JDK 的主机 IP
progress.preparing.wsl.build.environment=正在准备 WSL 构建环境…

plugins.advertiser.feature.artifact=工件
action.make.single.module.text=构建模块 ''{0}''(_M)
action.make.few.modules.text=构建模块 {0}(_M)
settings.actions.on.save.page.compiler.settings.link=编译器设置…
notification.group.compiler=构建已完成
notification.title.jps.caches.downloader=Jps 缓存下载程序
internal.authentication.plugin.missing.token=意外状态: 缺少 jetbrains.team 标记。请报告此异常，并执行操作“从 JetBrains.team 注销”和“登录 JetBrains.team”作为解决方法
notification.content.internal.authentication.plugin.required.for.correct.work=必须具备 <a href="https://plugins.jetbrains.com/plugin/14567-jetbrains-internal-authentication">JetBrains Internal Authentication</a>，JPS 缓存才能正常工作
notification.title.git.crlf.config=Git 行尾配置错误
notification.content.git.crlf.config=要使编译器缓存正常工作，您需要执行 <code>{0}</code> 命令并强制签出项目
settings.actions.on.save.page.build.project.on.save.checkbox=构建项目
settings.actions.on.save.page.build.project.on.save.checkbox.comment=运行/调试时未触发
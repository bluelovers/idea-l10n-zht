add.require.amd.module.fix=添加 {0} 模块依赖项
add.require.amd.module.group.name=Node.js
add.return.statement.fix.name=添加 return 语句
anonymous.function.contains.multiple.loops.error.string=\#ref 包含 {0} 个循环 \#loc
anonymous.function.contains.multiple.return.points.error.string=\#ref 具有 {0} 个返回点 \#loc
anonymous.function.contains.too.many.negation.error.string=\#ref 包含 {0} 个否定 \#loc
anonymous.function.display.name=匿名函数
anonymous.function.error.string=匿名函数 \#loc
anonymous.function.has.inconsistent.return.points.error.string=\#ref 的返回点不一致 \#loc
anonymous.function.has.too.many.parameters.error.string=\#ref 的形参过多 (形参数量 \= {0}) \#loc
anonymous.function.is.overly.complex.cyclomatic.complexity.error.string=\#ref 过于复杂 (循环复杂度 \= {0}) \#loc
anonymous.function.is.overly.long.statement.error.string=\#ref 过长 (语句数量 \= {0}) \#loc
anonymous.function.is.overly.nested.error.string=\#ref 过度嵌套 (嵌套深度为 {0}，但允许的最大值为 {1}) \#loc
assignment.replaceable.with.operator.assignment.display.name=赋值可被替换为运算符赋值
assignment.replaceable.with.operator.assignment.error.string=\#ref 可以简化为 {0} \#loc
assignment.to.for.loop.parameter.display.name=赋值给 'for' 循环形参
assignment.to.for.loop.parameter.error.string=赋值给 for 循环形参 \#ref \#loc
assignment.to.function.parameter.display.name=赋值给函数形参
assignment.to.function.parameter.error.string=赋值给函数形参 '\#ref' \#loc
break.statement.display.name='break' 语句
break.statement.error.string='\#ref' 语句 \#loc
break.statement.with.label.display.name=带标签的 'break' 语句
break.statement.with.label.error.string='\#ref' 语句带有标签 \#loc
call.to.document.write.display.name=调用 'document.write()'
caller.display.name=使用 'caller' 属性
caller.error.string=使用 '\#ref' 属性 \#loc
chained.equality.display.name=链式相等
chained.equality.error.string=链式相等比较 <code>\#ref</code> \#loc
chained.function.call.display.name=链式函数调用
chained.function.call.problem.descriptor=链式调用函数 '\#ref' \#loc
class.name.doesnt.match.regex.error.string=类名 ''{0}'' 与正则表达式 ''{1}'' 不匹配 \#loc
class.name.is.too.long.error.string=类名 ''{0}'' 过长 \#loc
class.name.is.too.short.error.string=类名 ''{0}'' 过短 \#loc
class.naming.convention.display.name=类命名约定
collapse.conditional.expression.fix=收起条件表达式
collapse.if.statement.fix=收起 'if' 语句
comma.expression.display.name=逗号表达式
comma.expression.error.string=逗号表达式 \#loc
conditional.expression.display.name=条件表达式
conditional.expression.error.string=条件表达式 \#loc
conditional.expression.with.identical.branches.display.name=具有相同分支的条件表达式
conditional.expression.with.identical.branches.error.string=具有相同分支的条件表达式 <code>\#ref</code> \#loc
confusing.floating.point.literal.change.quickfix=更改为规范形式
confusing.floating.point.literal.display.name=浮点字面量会引起混淆
confusing.floating.point.literal.problem.descriptor=引起混淆的浮点字面量 <code>\#ref</code> \#loc
confusing.pluses.or.minuses.display.name=令人困惑的 '+' 或 '-' 序列
confusing.pluses.or.minuses.error.string=如果移除空格，则 '+' 或 '-' 序列的含义可能会改变 \#loc
constant.conditional.expression.display.name=常量条件表达式
constant.conditional.expression.error.string=<code>\#ref</code> 可以简化 \#loc
constant.on.left.side.of.comparison.display.name=常量位于比较的左侧
constant.on.left.side.of.comparison.error.string=\#ref\: 常量位于比较的左侧 \#loc
constant.on.right.side.of.comparison.display.name=常量位于比较的右侧
constant.on.right.side.of.comparison.error.string=\#ref\: 常量位于比较的右侧 \#loc
constructor.name.doesnt.match.regex.error.string=构造函数名称 ''{0}'' 与正则表达式 ''{1}'' 不匹配 \#loc
constructor.name.is.too.long.error.string=构造函数名称 ''{0}'' 过长 \#loc
constructor.name.is.too.short.error.string=构造函数名称 ''{0}'' 过短 \#loc
continue.or.break.inside.finally.block.display.name='continue' 或 'break' 位于 'finally' 块内
continue.or.break.inside.finally.block.error.string='\#ref' 位于 'finally' 块内 \#loc
continue.statement.display.name='continue' 语句
continue.statement.error.string='\#ref' 语句 \#loc
continue.statement.with.label.display.name=带标签的 'continue' 语句
continue.statement.with.label.error.string='\#ref' 语句带有标签 \#loc
debugger.statement.display.name='debugger' 语句
debugger.statement.error.string='\#ref' 语句 \#loc
default.branch.not.last.case.in.switch.error.string=<code>\#ref</code> 分支不是 'switch' 中的最后一个 case \#loc
default.not.last.case.in.switch.display.name='default' 不是 'switch' 中的最后一个 case
divide.by.zero.display.name=除以零
division.by.zero.error.string=除以零 \#loc
document.write.error.string=调用 '\#ref()' \#loc
duplicate.case.label.display.name=重复的 'case' 标签
duplicate.case.label.error.string=重复的 case 标签 \#ref \#loc
duplicate.condition.error.string=重复条件 <code>\#ref</code> \#loc
duplicate.condition.in.if.statement.display.name='if' 语句中的重复条件
dynamically.generated.code.display.name=执行动态生成的代码
dynamically.generated.code.error.string=函数 '\#ref' 表示动态生成的代码 \#loc
empty.catch.block.display.name=空 'catch' 块
empty.catch.block.error.string='\#ref' 块为空 \#loc
empty.finally.block.display.name=空 'finally' 块
empty.finally.block.error.string=空 'finally' 块 \#loc
empty.try.block.display.name=空 'try' 块
empty.try.block.error.string='\#ref' 块为空 \#loc
exception.caught.locally.error.string=本地捕获异常的 '\#ref' \#loc
exception.used.for.local.control.flow.display.name=将异常用于本地控制流
expression.statement.is.not.assignment.or.call.error.string=表达式语句不是赋值或调用 \#loc
expression.statement.which.is.not.assignment.or.call.display.name=非赋值或调用的表达式语句
fall.through.in.switch.statement.display.name='switch' 语句中的直落
fall.through.in.switch.statement.error.string='switch' 语句中存在 fallthrough \#loc。缺少 'break' 或 'return'
flip.comparison.fix=翻转比较
for.loop.not.use.loop.variable.display.name='for' 循环中的 update 或 condition 未使用循环变量
for.loop.not.use.loop.variable.problem.descriptor.both.condition.and.update=<code>\#ref</code> 语句中的 condition 和 update 未使用 for 循环变量 \#loc
for.loop.not.use.loop.variable.problem.descriptor.condition=<code>\#ref</code> 语句中的 condition 未使用 for 循环变量 \#loc
for.loop.not.use.loop.variable.problem.descriptor.update=<code>\#ref</code> 语句中的 update 未使用 for 循环变量 \#loc
for.loop.replaceable.by.while.display.name='for' 循环可被替换为 'while' 循环
for.loop.replaceable.by.while.ignore.option=忽略无条件循环的 'infinite'
for.loop.replaceable.by.while.problem.descriptor=<code>\#ref</code> 循环可被替换为 'while' 循环 \#loc
for.loop.replaceable.by.while.replace.quickfix=替换为 'while'
function.complexity.limit.parameter=函数复杂度限制\:
function.contains.multiple.loops.error.string=函数 ''\#ref'' 包含 {0} 个循环 \#loc
function.contains.multiple.return.points.error.string=函数 ''\#ref'' 具有 {0} 个返回点 \#loc
function.contains.too.many.negation.error.string=函数 ''\#ref'' 包含 {0} 个否定 \#loc
function.has.inconsistent.return.points.error.string=函数 '\#ref' 的返回点不一致 \#loc
function.has.too.many.parameters.error.string=函数 ''\#ref'' 的形参过多 (形参数量 \= {0}) \#loc
function.is.overly.long.statement.error.string=函数 ''\#ref'' 过长 (语句数量 \= {0}) \#loc
function.is.overly.nested.error.string=函数 ''\#ref'' 过度嵌套 (嵌套深度为 {0}，但允许的最大值为 {1}) \#loc
function.name.doesnt.match.regex.error.string=函数名称 ''{0}'' 与正则表达式 ''{1}'' 不匹配 \#loc
function.name.is.too.long.error.string=函数名称 ''{0}'' 过长 \#loc
function.name.is.too.short.error.string=函数名称 ''{0}'' 过短 \#loc
function.naming.convention.display.name=函数命名约定
function.parameter.limit=函数形参限制\:
function.parameter.naming.convention.display.name=函数形参命名约定
function.ref.is.overly.complex.cyclomatic.complexity.error.string=函数 ''\#ref'' 过于复杂 (循环复杂度 \= {0}) \#loc
function.with.inconsistent.returns.display.name=函数的返回不一致
function.with.more.than.three.negations.display.name=函数包含三个以上的否定
function.with.multiple.loops.display.name=函数具有多个循环
function.with.multiple.return.points.display.name=函数具有多个返回点
function.with.too.many.parameters.display.name=函数的形参过多
group.path.javascript=JavaScript
if.statement.with.identical.branches.display.name='if' 语句的分支相同
if.statement.with.too.many.branches.display.name='if' 语句的分支过多
if.statement.with.too.many.branches.error.string=''\#ref'' 的分支过多 ({0}) \#loc
include.anonymous.functions.parameter=包括匿名函数
include.statement.bodies.that.are.empty.code.blocks.parameter=包含空代码块语句正文
incompatible.mask.operation.display.name=不兼容的按位掩码运算
incompatible.mask.operation.problem.descriptor.always.false=<code>\#ref</code> 始终为 false \#loc
incompatible.mask.operation.problem.descriptor.always.true=<code>\#ref</code> 始终为 true \#loc
infinite.loop.error.string=<code>\#ref</code> 语句不能在未抛出异常的情况下完成 \#loc
infinite.loop.statement.display.name=无限循环语句
infinite.recursion.display.name=无限递归
infinite.recursion.problem.descriptor=函数 <code>\#ref</code> 无限递归，只能以抛出异常结束 \#loc
inner.html.error.string=使用 '\#ref' 属性 \#loc
invert.condition.fix=反转条件
invert.if.condition.fix=反转 'if' 条件
javascript.dom.issues.group.name=DOM 问题
js.inspection.group.path=JavaScript 和 TypeScript
js.inspection.switch.group.name=switch 语句问题
labeled.statement.display.name=标记语句
local.variable.naming.convention.display.name=局部变量命名约定
loop.statement.that.doesn.t.loop.display.name=不循环的循环语句
loop.statement.that.doesnt.loop.error.string=<code>\#ref</code> 语句未循环 \#loc
magic.number.display.name=幻数
magic.number.problem.descriptor=幻数 '\#ref' \#loc
maximum.number.of.branches.parameter=最大分支数\:
maximum.number.of.terms.parameter=最大项数\:
maximum.statements.per.function=每个函数的最大语句数\:
missing.return.statement.error.string=缺少 return 语句 \#loc
negated.conditional.expression.display.name=否定条件表达式
negated.conditional.expression.error.string=否定的条件表达式 \#loc
negated.if.statement.display.name=否定的 'if' 语句
negated.ref.statement.error.string=否定的 '\#ref' 语句 \#loc
nested.anonymous.function.error.string=嵌套 \#ref \#loc
nested.assignment.display.name=嵌套赋值
nested.assignment.error.string=嵌套赋值 <code>\#ref</code> \#loc
nested.conditional.expression.display.name=嵌套条件表达式
nested.conditional.expression.error.string=嵌套条件表达式 \#loc
nested.function.call.display.name=嵌套函数调用
nested.function.call.problem.descriptor=嵌套调用函数 '\#ref' \#loc
nested.function.display.name=嵌套函数
nested.function.error.string=嵌套函数 '\#ref' \#loc
nested.switch.statement.display.name=嵌套 'switch' 语句
nested.switch.statement.error.string=嵌套 '\#ref' 语句 \#loc
nesting.depth.limit=嵌套深度限制\:
non.block.body.error.string=<code>\#ref</code> 语句具有非块主体 \#loc
non.block.branch.error.string=<code>\#ref</code> 语句具有非块分支 \#loc
non.block.statement.body.display.name=没有大括号的语句体
octal.integer.display.name=八进制整数
overly.complex.arithmetic.expression.display.name=过于复杂的算术表达式
overly.complex.arithmetic.expression.error.string=过于复杂的算术表达式 \#loc
overly.complex.boolean.expression.display.name=过度复杂的布尔表达式
overly.complex.boolean.expression.error.string=布尔表达式过于复杂 \#loc
overly.complex.function.display.name=函数过于复杂
overly.long.function.display.name=函数过长
overly.nested.function.display.name=函数过度嵌套
parameter.name.doesnt.match.regex.error.string=形参名称 ''\#ref'' 与正则表达式 ''{0}'' 不匹配 \#loc
parameter.name.is.too.long.error.string=形参名称 '\#ref' 过长 \#loc
parameter.name.is.too.short.error.string=形参名称 '\#ref' 过短 \#loc
platform.detection.display.name=平台检测不准确
platform.detection.error.string='\#ref' 可能用于平台检测 \#loc
pointless.arithmetic.error.message=\#ref 可被替换为 {0} \#loc
pointless.arithmetic.expression.display.name=无意义的算术表达式
pointless.bitwise.expression.display.name=可以简化按位表达式
pointless.bitwise.expression.ignore.option=在确定无意义表达式时忽略命名常量
pointless.bitwise.expression.problem.descriptor=''{1}'' 可被替换为 ''{0}'' \#loc
pointless.bitwise.expression.simplify.quickfix=简化
pointless.boolean.error.string=可以简化为 {0} \#loc
pointless.boolean.expression.display.name=无意义的语句或布尔表达式
pointless.statement.error.string={0} 语句可以简化 \#loc
redundant.conditional.expression.display.name=冗余条件表达式
redundant.if.statement.display.name=冗余的 'if' 语句
redundant.local.variable.display.name=冗余局部变量
redundant.local.variable.ignore.option=忽略立即返回或抛出的变量
redundant.local.variable.quickfix=内联变量
ref.statement.with.identical.branches.error.string=<code>\#ref</code> 语句具有相同的分支 \#loc
remove.label.fix=移除标签
remove.unnecessary.continue.fix=移除不必要的 continue
remove.unnecessary.return.fix=移除不必要的 return
rename.fix=重命名
replace.redundant.await.family.name=替换冗余的 await
replace.with.operator.assign.fix=将 \= 替换为 {0}\=
reserved.word.used.as.name.display.name=保留词用作名称
reserved.word.used.as.name.error.string=保留词 '\#ref' 用作名称
result.of.assignment.expression.used.error.string=使用的赋值表达式的结果 \#loc
result.of.assignment.used.displayName=使用的赋值的结果
result.of.increment.or.decrement.expression.used.error.string=使用增量或减量表达式的结果 \#loc
result.of.increment.or.decrement.used.display.name=使用增量或减量的结果
result.of.object.allocation.ignored.display.name=对象分配的结果已忽略
result.of.object.allocation.ignored.error.string=<code>new \#ref()</code> 的结果被忽略 \#loc
return.inside.finally.block.display.name='return' 位于 'finally' 块内
return.inside.finally.block.error.string='\#ref' 位于 'finally' 块内 \#loc
reuse.of.local.variable.display.name=局部变量的重用
reuse.of.local.variable.problem.descriptor=局部变量 <code>\#ref</code> 的重用 \#loc
set.return.type.to.void.fix.name=将返回值类型设置为 void
shift.operation.by.inappropriate.constant.display.name=通过可能错误的常量进行移位运算
shift.operation.by.inappropriate.constant.problem.descriptor.negative=对 <code>\#ref</code> 进行移位运算时使用的常量值为负 \#loc
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=对 <code>\#ref</code> 进行移位运算时使用的常量值过大 \#loc
shift.out.of.range.family.name=修复移位值
silly.assignment.display.name=变量被赋值给自己
silly.assignment.error.string=变量已分配给自己 \#loc
simplify.fix=简化
statement.has.empty.body.error.string=<code>\#ref</code> 语句具有空体 \#loc
statement.has.empty.branch.error.string=<code>\#ref</code> 语句的分支为空 \#loc
statement.label.error.string=语句标签 '\#ref' \#loc
statement.simplify.quickfix=简化语句
statement.with.empty.body.display.name=带空体的语句
string.literal.breaks.html.display.name=中断 HTML 解析的字符串字面量
string.literal.breaks.html.error.string=字符串字面量 \#ref 可能会中断 HTML 解析器 \#loc
tail.recursion.display.name=尾递归
tail.recursion.problem.descriptor=尾部递归 \#loc
terminate.statement.fix=终止语句
text.label.in.switch.statement.display.name='switch' 语句中的文本标签
text.label.in.switch.statement.error.string='switch' 语句中存在文本标签 <code>\#ref\:</code> \#loc
this.expression.references.global.object.error.string=顶层 '\#ref' 表达式 \#loc
this.expression.which.references.the.global.object.display.name=引用全局对象的 'this' 表达式
throw.inside.finally.block.display.name='throw' 位于 'finally' 块内
throw.inside.finally.block.error.string='\#ref' 位于 'finally' 块内 \#loc
trivial.conditional.error.string=''{0}'' 可以简化为 ''{1}'' \#loc
trivial.if.error.string=<code>\#ref</code> 语句可以简化 \#loc
typeof.using.incorrect.case.display.name=包含非标准值的 'typeof' 比较
typeof.using.incorrect.case.error=typeof 比较含非标准值
typeof.using.incorrect.convert=转换为 {0}
typeof.using.incorrect.family.name=转换为标准值
unnecessary.block.statement.display.name=不必要的块语句
unnecessary.block.statement.error.string=不必要的块语句 \#loc
unnecessary.continue.error.string=<code>\#ref</code> 不必要，因为是循环中的最后一条语句 \#loc
unnecessary.continue.statement.display.name=不必要的 'continue' 语句
unnecessary.label.display.name=不必要的标签
unnecessary.label.error.string=不必要的标签 <code>\#ref</code> \#loc
unnecessary.label.on.break.error.string=<code>\#ref</code> 语句包含不必要的标签 \#loc
unnecessary.label.on.break.statement.display.name='break' 语句上的标签不必要
unnecessary.label.on.continue.error.string=<code>\#ref</code> 语句包含不必要的标签 \#loc
unnecessary.label.on.continue.statement.display.name='continue' 语句上的不必要标签
unnecessary.local.variable.problem.descriptor=局部变量 {0} 冗余
unnecessary.return.error.string=<code>\#ref</code> 不必要，因为它是没有返回值的函数中的最后一条语句 \#loc
unnecessary.return.statement.display.name=不必要的 'return' 语句
unreachable.code.display.name=不可到达的代码
unreachable.code.error.string=不可到达的代码 \#loc
unterminated.statement.display.name=未终止的语句
unterminated.statement.error.string=未终止的语句 \#loc
unterminated.statement.ignore.atend.of.block=允许块末尾没有分号
unterminated.statement.possibly.unterminated.statement.error=语句可能未终止 \#loc
unused.catch.parameter.display.name=未使用的 'catch' 形参
unused.catch.parameter.ignore.catch.option=忽略包含注释的 catch 块
unused.catch.parameter.problem.descriptor=未使用的 catch 形参 <code>\#ref</code> \#loc
use.of.innerhtml.property.display.name=使用 'innerHTML' 属性
variable.name.doesnt.match.regex.error.string=变量名称 ''\#ref'' 与正则表达式 ''{0}'' 不匹配 \#loc
variable.name.is.too.long.error.string=变量名称 '\#ref' 过长 \#loc
variable.name.is.too.short.error.string=变量名称 '\#ref' 过短 \#loc
void.expression.display.name='void' 表达式
void.expression.error.string='\#ref' 表达式 \#loc
with.expression.error.string='\#ref' 语句 \#loc
with.statement.display.name='with' 语句
wrap.statement.body.fix=包装语句主体
xhtml.incompatabilities.error.string='\#ref' 可能会为 XHTML 文档生成不一致的结果 \#loc
xhtml.incompatibilities.display.name=不兼容的 XHTML 用法

#
# Copyright 2000-2010 JetBrains s.r.o.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

########################################################################################################################
# Module type
########################################################################################################################
module.ruby.title=Ruby 模块
module.ruby.description=Ruby 模块用于开发 <b>Ruby</b> 和 <b>Ruby on Rails</b> 应用程序。

########################################################################################################################
# Ruby Sdk
########################################################################################################################
sdk.ruby.title=Ruby SDK
sdk.jruby.title=JRuby SDK
sdk.ruby.add=添加 Ruby SDK…
sdk.ruby.scanning=正在扫描 Ruby SDK…

#Configuration
ruby.configuration.gems.bin.dir.path=Gem bin 目录:
ruby.configuration.gems.bin.dir.path.tooltip=gem 可执行脚本的安装路径
ruby.configuration.gems.bin.dir.select.path=选择 gem bin 目录

#Errors
jdk.no.specified=未指定 SDK
jdk.type.incorrect=SDK 类型错误
sdk.error.home.path.doesnt.exists=Ruby SDK ''{1}'' 的主路径({0})不存在。
sdk.error.isnt.valid=SDK ''{0}'' 不是有效的 Ruby SDK
sdk.error.gems.bindir.doesnt.exist=Gem bin 目录不存在
sdk.error.gems.bindir.isnt.directory=Gem bin 目录不是目录
sdk.error.old.x64=您可能在 Windows x64 中使用 JRuby 1.1.3 或更早的版本
sdk.error.invalid.interpreter.name=所选文件 ''{0}'' 不是 {1} 解释器。选择名称为 ''{2}'' 的可执行文件。

rails.sdk.gem.not.found=选择 'Rails' 版本

sdk.error.no.rails.found=[未在 SDK 中找到 Rails]

sdk.error.no.server.gem.found=[未在 SDK 中找到 ''{0}'' gem]
sdk.error.no.server.gem.found.rails3=[未在 SDK 中找到 ''{0}'' gem 或者它未添加到 Gemfile]

sdk.error.jruby.jdk.type.incorrect={0} 服务器只能和 JRuby SDK 一起运行
#########################################################################################################################
# Execution errors
########################################################################################################################
execution.error.title=执行错误
execution.error.no.executable.cmd.for.gem.name=无法运行 gem ''{0}''，无法找到 ''{1}''
execution.ruby.script.get.available.generators=用于获取可用生成器的脚本执行出错:\n\
{0}
execution.error.testunit.spork.script.not.found=找不到 Spork 测试运行程序 'testdrb' 脚本。

########################################################################################################################
# Run configuration
########################################################################################################################
run.configuration.type.name=Ruby
run.configuration.type.description=Ruby 运行配置

run.configuration.remote.debug.name=Ruby 远程调试

run.configuration.coverage.enable.in.test.folders=在测试文件夹中启用覆盖率(&T)
run.configuration.coverage.do.not.use.the.optimized.c.runtime=不使用优化的 C 运行时(&O)

run.configuration.messages.select.working.dir=选择工作目录
run.configuration.messages.script.args=脚本实参

run.configuration.messages.select.ruby.script.path=选择 Ruby 脚本
run.configuration.messages.select.sdk.bound=Ruby SDK:
run.configuration.messages.select.module=从模块中选择 SDK:
run.configuration.messages.select.module.rubymine=使用项目 SDK:
run.configuration.messages.working.dir=工作目录:
run.configuration.messages.ruby.args=Ruby 实参
run.configuration.messages.script.path=Ruby 脚本:
run.configuration.messages.folder.path=文件夹:
run.configuration.messages.select.folder.path=选择文件夹
run.configuration.messages.runner.version.no.gems=[未在 SDK 中找到 {0} gem]
run.configuration.messages.runner.version=''{0}'' gem:
run.configuration.tests.runner.options=运行程序选项
run.configuration.messages.use.rails.runner=在 Rails 的上下文中执行

## Cucumber
cucumber.jruby.run.configuration.type.name=JRuby Cucumber
cucumber.jruby.run.configuration.type.description=使用 JRuby 和 Java 编写步骤定义的 Cucumber 功能的运行配置。
cucumber.jruby.errors.module.not.specified=未指定项目模块
cucumber.jruby.errors.jruby.facet.not.specified=没有为模块 ''{0}'' 配置 JRuby Facet
cucumber.jruby.errors.jruby.sdk.not.specified=没有为模块 ''{0}'' 指定 JRuby SDK

cucumber.run.configuration.type.name=Cucumber
cucumber.run.configuration.type.description=Cucumber 功能运行配置

cucumber.run.configuration.tests.form.testtype.title=模式:
cucumber.run.configuration.tests.dialog.rb.allInFolder=文件夹中的所有功能(&F)
cucumber.run.configuration.messages.feature.paths=功能文件(&F)
cucumber.run.configuration.tests.backtrace.checkbox=输出完整回溯(&B)
cucumber.run.configuration.tests.verbose.checkbox=显示加载的文件和功能(&L)
cucumber.run.configuration.messages.scripts.paths=功能文件(&I):
cucumber.run.configuration.tests.dialog.components.folder=功能文件夹(&O)
cucumber.run.configuration.tests.dialog.components.filter.tags=标签筛选器(&T)
cucumber.run.configuration.tests.dialog.components.filter.elements=元素名称筛选器(&N)
cucumber.run.configuration.test.default.name={0} 中的所有功能: {1}
cucumber.params.editor.tags.filter.text=例如: '@tag1,@tag2,~@excluded_tag'
cucumber.params.editor.element.name.filter.text=仅执行与给定名称的一部分相匹配的功能元素。

## RSpec
rspec.run.configuration.type.name=RSpec
rspec.run.configuration.type.description=RSpec 示例运行配置

rspec.run.configuration.tests.dialog.components.search.mask=文件名掩码:
rspec.run.configuration.tests.dialog.components.example.name=示例名称
rspec.run.configuration.tests.dialog.components.folder=规范文件夹
rspec.run.configuration.tests.dialog.components.filenames=规范
rspec.run.configuration.tests.dialog.rb.allInFolder=文件夹中的所有规范(&A)
rspec.run.configuration.tests.dialog.rb.file=规范脚本(&S)
rspec.run.configuration.tests.dialog.rb.custom=多种规范(&M)
rspec.run.configuration.tests.form.testtype.title=模式:
rspec.run.configuration.messages.script.path=规范脚本:

rspec.run.configuration.tests.dialog.components.select.spec.custom.runner=选择自定义 RSpec 运行程序脚本
rspec.run.configuration.tests.dialog.components.spec.custom.use=使用自定义 RSpec 运行程序脚本:
rspec.run.configuration.tests.backtrace.checkbox=输出完整回溯(&B)
rspec.run.configuration.log.tab.name=RSpec 日志

run.configuration.tests.display.name=Test::Unit/Shoulda/Minitest
run.configuration.tests.description=基于 Test::Unit 和 Minitest 的运行配置
run.configuration.tests.messages.method.name=方法:
run.configuration.test.form.testtype.title=模式:
run.configuration.tests.dialog.components.folder=测试文件夹
run.configuration.tests.dialog.components.search.mask=测试文件名掩码:
run.configuration.tests.dialog.components.file=Ruby 脚本
run.configuration.tests.dialog.components.files=Ruby 脚本
run.configuration.tests.dialog.components.method=测试名称筛选器
run.configuration.tests.dialog.rb.allInFolder=文件夹中的所有测试(&A)
run.configuration.tests.dialog.rb.method=测试方法(&M)
run.configuration.tests.dialog.rb.files=测试脚本(&S)
run.configuration.messages.runner.options=运行程序选项
run.configuration.tests.use.alternative.sdk.checkbox=使用其他 SDK:
run.configuration.tests.use.gem.from.sdk.checkbox=使用其他 SDK 和 ''{0}'' gem:
run.configuration.tests.producer.more.files={0} 和其他 {1} 个

rails.run.configuration.type.name=Rails
rails.run.configuration.type.description=Rails 运行配置
run.configuration.server.dialog.dummy.app=虚拟应用
run.configuration.server.dialog.port=端口
run.configuration.server.dialog.ip=IP 地址
run.configuration.server.dialog.server=服务器
run.configuration.server.dialog.run.browser.text=运行浏览器
run.configuration.server.dialog.auto.start.js.debugger.text=调试时自动启动 JavaScript 调试器
run.configuration.server.args=服务器实参
run.configuration.server.dialog.environment=环境

run.configuration.messages.not.specified=[未指定]
sdk.renderer.no.sdk.chosen=[未选择 SDK]

run.configuration.rake.description=Rake 任务运行配置
run.configuration.rake.task.name=任务名称
run.configuration.rake.task.arguments=实参
run.configuration.rake.task.attach.test.runner.ui=为框架附加测试运行程序 UI
run.configuration.rake.task.options.trace=开启 invoke/execute 跟踪，启用完整回溯 (--trace)
run.configuration.rake.task.options.dry.run=在不执行操作的情况下进行试运行 (--dry-run)
run.configuration.rake.task.options.prereqs=显示任务和依赖项，然后退出 (--prereqs)
run.configuration.rake.validation.error.no.gem=无法在 SDK ''{0}'' 中找到 Rake 可执行脚本
run.configuration.rake.validation.error.no.rakefile=在工作目录中找不到 'Rakefile' 或 'Rakefile.rb'
run.configuration.rake.validation.error.no.task=未指定任务
run.configuration.rake.line.marker.tooltip=运行 Rake 任务

# before run
run.configuration.before.run.rake.description.empty=运行 Rake 任务
run.configuration.before.run.rake.description=运行 Rake 任务 ''{0}''
run.configuration.before.run.rake.settings.dialog.title=Rake 任务
run.configuration.before.run.rake.error.dialog.title=无法启动 Rake 任务
run.configuration.before.run.rake.error.dialog.module.not.specified=未指定模块。
run.configuration.before.run.rake.execution.bg.title.main=准备 ''{0}'' 启动
run.configuration.before.run.rake.execution.bg.title.second=正在运行 ''{0}'' 任务…
run.configuration.before.run.rake.messages.tab.title=Rake 任务: {0}

run.configuration.before.run.jruby.compiler.description=运行 JRuby 编译器
run.configuration.before.run.jruby.compiler.execute.error.title=无法运行 JRuby 编译器
run.configuration.before.run.jruby.compiler.execute.error.title2=无法添加 JRuby 编译器任务
run.configuration.before.run.jruby.compiler.execute.error=请配置 JRuby Sdk，以便运行 JRuby 编译器
run.configuration.before.run.jruby.compiler.execute.error2=JRuby 编译器仅支持 Ruby 运行配置
run.configuration.before.run.jruby.compiler.execute.title=正在编译 Ruby 文件…
run.configuration.before.run.jruby.compiler.execute.title2=JRuby 编译器
run.configuration.before.run.jruby.compiler.execute=JRuby 编译器设置
run.configuration.before.run.jruby.compiler.settings.target.path.title=请指定编译器目标路径
run.configuration.before.run.jruby.compiler.settings.clear.target.dir.text=启动前清除目标目录(&C)
run.configuration.before.run.jruby.compiler.setting.target.path.text=目标路径(&T):
run.configuration.before.run.jruby.compiler.setting.additional.params.text=附加命令行形参(&P):
run.configuration.before.run.jruby.compiler.setting.heap.size.text=编译器进程堆大小 (MB)(&S):
run.configuration.before.run.jruby.compiler.setting.edit.params.text=编辑命令行形参
# remote debug
run.configuration.remote.debug.remote.host.not.specified=未指定远程主机
run.configuration.remote.debug.remote.port.not.specified=未指定端口或端口不是数值
run.configuration.remote.debug.remote.root.not.specified=未指定远程根
run.configuration.remote.debug.local.root.not.specified=未指定本地根或本地根不正确
run.configuration.remote.debug.wrong.sdk.title=有限的调试信息
run.configuration.remote.debug.wrong.sdk.error=请选择相关的远程 Ruby SDK 以查看完整调试信息
action.select.sdk.text=选择 SDK
remote.debug.info=信息
remote.debug.server.command.text=服务器命令:
remote.debug.server.hint=在服务器端使用以下命令以启用远程调试
remote.debug.settings=设置
remote.debug.remote.host=远程主机
remote.debug.port=远程端口
remote.debug.dispatcher.port=本地端口
remote.debug.remote.root.folder=远程根文件夹
remote.debug.local.root.folder=本地根文件夹

########################################################################################################################
# Run configurations errors
########################################################################################################################
run.configuration.script.port.bad.format='port' 值不正确
run.configuration.script.ip.bad.format='ip address' 值不正确
run.configuration.script.not.specified=未指定 Ruby 脚本
run.configuration.script.not.exists=Ruby 脚本不存在
run.configuration.script.is.not.file=Ruby 脚本似乎不是文件

# rails
run.configuration.rails.server.workdir.not.found=无法确定 Rails 应用程序主页。已为此应用程序禁用 Rails 支持。
run.configuration.rails.server.script.not.specified=未在项目中找到 Rails 服务器启动器
run.configuration.rails.server.script.not.exists=未在项目中找到 Rails 服务器启动器 ''{0}''
run.configuration.rails.server.script.instead.of.detected=找到 Rails {1}.x 启动器脚本，而不是 Rails {2}.x 启动器脚本。您需要 ''{0}'' 脚本以启动 Rails 服务器。请根据 Rails {2}.x 文档更新服务器启动器。
run.configuration.rails.server.script.is.not.file=Rails 服务器启动器 ''{0}'' 似乎不是文件

#test unit
run.configuration.working.directory.not.exists=工作目录不存在
run.configuration.working.directory.error=工作目录不是目录
run.configuration.working.directory.not.specified=未指定工作目录
run.configuration.test.folder.not.exists=测试文件夹不存在
run.configuration.test.folder.not.specified=未指定测试文件夹
run.configuration.test.folder.not.dir=测试文件夹不是目录
run.configuration.test.no.mask=为测试名称定义掩码，例如: {0}
run.configuration.test.script.not.exists=测试脚本不存在
run.configuration.test.script.not.specified=未指定测试脚本
run.configuration.test.method.name.not.specified=未指定测试名称
run.configuration.test.script.is.dir=测试脚本是目录
run.configuration.test.default.name={0} 中的所有测试: {1}
minitest.run.configuration.prefix=Minitest: {0}

#rspec
rspec.run.configuration.test.folder.not.exists=规范文件夹不存在
rspec.run.configuration.test.folder.not.specified=未指定规范文件夹
rspec.run.configuration.test.folder.not.dir=规范文件夹不是目录
rspec.run.configuration.test.script.not.specified=未指定规范测试脚本
rspec.run.configuration.test.script.not.exists=规范测试脚本不存在
rspec.run.configuration.test.custom.runner.not.exists=自定义 RSpec 运行程序脚本不存在
rspec.run.configuration.test.script.is.dir=规范脚本是目录
rspec.run.configuration.test.default.name={0} 中的所有规范: {1}
rspec.run.configuration.prefix=RSpec: {0}
rspec.run.configuration.test.cannot.find.script=无法找到 {0} SDK 的 RSpec 运行程序脚本
rspec.run.configuration.test.no.rspec.rails.support=由于缺少 'rspec-rails' gem，已禁用 RSpec 支持。请先安装并激活该 gem。

rspec.run.configuration.test.no.spec.scrip.error.run.generator=找不到 RSpec ''./{1}'' 和 ''./{2}'' 脚本。请安装 ''rspec-rails'' gem，重新加载生成器，并从 RubyMine 运行 ''{0}'' 生成器(使用“工具 | 运行 Rails 生成器…”操作)

#cucumber
cucumber.run.configuration.test.no.rails.cucumber.scrip.error.run.generator=找不到 Cucumber ''./script/cucumber'' 脚本。要初始化 Cucumber 支持，请安装 ''cucumber-rails'' gem，重新加载生成器，并从 RubyMine 运行 ''{0}'' (使用“工具 | 运行 Rails 生成器…”操作)
cucumber.run.configuration.tags.filter.with.spaces=标记必须用逗号分隔且没有空格
cucumber.run.configuration.cucumber.rails.support.isnt.attached=由于缺少 'cucumber-rails' gem，已禁用 Cucumber 支持。请安装该 gem 并将其添加到 Gemfile。
cucumber.run.configuration.cucumber.gem.version.isnt.supported=图形测试运行程序不支持 Cucumber gem ''{0}''，请对 ''{2}'' SDK 使用 ''{1}'' 或更高版本
cucumber.run.configuration.test.folder.not.exists=功能文件夹不存在
cucumber.run.configuration.test.folder.not.specified=未指定功能文件夹
cucumber.run.configuration.test.folder.not.dir=功能文件夹不是目录
cucumber.run.configuration.test.script.not.exists=功能文件 ''{0}'' 不存在
cucumber.run.configuration.test.script.not.specified=未指定功能文件
cucumber.run.configuration.test.custom.runner.not.exists=自定义 Cucumber 运行程序脚本不存在
cucumber.run.configuration.tests.dialog.components.use.custom.runner=使用自定义 Cucumber 运行程序脚本:
cucumber.run.configuration.tests.dialog.components.select.custom.runner=选择自定义 Cucumber 运行程序脚本
cucumber.run.configuration.test.script.is.dir=Cucumber 功能文件 ''{0}'' 是目录
cucumber.run.configuration.test.no.gem.in.sdk=未为 {0} SDK 安装 Cucumber Gem
cucumber.run.configuration.log.tab.name=Cucumber 日志
cucumber.run.configuration.prefix=Cucumber: {0}

preload.use.server=使用预加载服务器(&U):
spring.pre.loader.name=Spring
spring.pre.loader.option=Spring 预加载器
spring.rake.pre.loader.option=Rake 任务 Spring 预加载器
spring.rails.pre.loader.option=Rails 生成器 Spring 预加载器
spring.debug.config.modification.request.title=修补 Spring 配置以调试应用程序
spring.debug.config.modification.request=您是要修补系统 (~/.spring.rb) 还是项目 (config/spring.rb) 配置文件?
spring.debug.config.modification.system=修补系统配置
spring.debug.config.modification.project=修补项目配置
spring.debug.config.modification.disable=对调试禁用 Spring
spring.debug.config.modification.title=Spring 配置已修改
spring.debug.config.modification=配置文件 ''{0}'' 已修改。如果您有要用来调试应用程序的活动 Spring 服务器，请重新启动这些服务器。
spring.debug.config.modification.write.access.title=Spring 配置写入访问错误
spring.debug.config.modification.write.access=对用户主目录没有写入访问权限。

spring.debug.config.deprecated.patch.title=更新过期的 Spring 补丁
spring.debug.config.deprecated.patch=Spring 配置文件包含调试所需的过期补丁。是否要更新该补丁?

# spork
spork.run.drb=DRb
spork.run.drb_server.run.conf.name={0}Spork DRb 服务器: {1}
spork.run.settings.title=Spork DRb 启动选项
spork.run.settings.rspec=RSpec(&S)
spork.run.settings.cucumber=Cucumber(&C)
spork.run.settings.testunit=TestUnit/Shoulda/Minitest(&U)
spork.run.settings.info=选择测试框架:
spork.run.settings.button.ok.caption=运行
spork.run.settings.bootstrap=执行引导(&B)
spork.run.error.gem.not.installed=''{0}'' SDK 中未安装 Spork gem
spork.run.error.remote.sdk=远程 sdk 尚不支持 Spork 执行 (''{0}'')
spork.run.error.bin.script.not.found=找不到 ''{0}'' SDK 的 Spork 启动器脚本
spork.run.settings.needed.to.be.updated=Spork DRb 启动选项已过期。{0} 将自动更新这些选项。\n\
如果要保留以前的设置，请先重命名您的 ''{1}'' 运行配置。\n\
\n\
是否更新选项?
spork.run.configuration.settings.framework=测试框架:
spork.server.run.configuration.type.name=Spork DRb
spork.server.run.configuration.type.description=Spork DRb 服务器运行配置
spork.server.run.configuration.script.not.specified=未指定 Spork 服务器脚本
spork.server.run.configuration.script.not.exists=Spork 服务器脚本不存在
spork.server.run.configuration.script.is.not.file=Spork 服务器脚本似乎不是文件
spork.server.run.configuration.messages.select.ruby.script.path=选择 Spork 服务器脚本
spork.server.run.configuration.messages.script.args=其他实参
spork.server.run.configuration.messages.script.path=Spork 脚本:
spork.server.run.unexpected.framework.exception=意外框架: {0}

# Zeus
zeus.server.name=Zeus
zeus.server.action.start=启动 Zeus 服务器: {0}
zeus.server.use=使用 Zeus 服务器(&Z)
zeus.server.run.configuration.type.name=Zeus 服务器
zeus.server.run.configuration.type.description=Zeus 服务器运行配置
zeus.server.run.configuration.command=命令名称
zeus.server.run.configuration.arguments=命令实参
zeus.server.run.configuration.editor.command.text=命令
zeus.server.run.configuration.editor.arguments.text=实参
# rails console
rails.console=Rails 控制台: {0}
rails.console.select.environment=选择 Rails 环境
rails.console.environment=环境(&E):
rails.console.actions.reload=重新加载源代码
rails.console.actions.reload.description=在 Rails 控制台中动态重新加载 Ruby 脚本
# irb
irb.console.actions.load.text.title=加载到 Ruby 控制台
irb.console.actions.load.text.error.running.not.found=找不到正在运行的 Ruby 控制台实例。
pry.console=Pry: {0}
irb.console=IRB: {0}
irb.run.configuration.type.name=Ruby 控制台
irb.run.configuration.type.description=控制台运行配置
irb.run.configuration.messages.select.ruby.script.path=选择控制台脚本
irb.run.configuration.messages.edit.script.args=控制台脚本实参
irb.run.configuration.messages.script.args=其他实参
irb.run.configuration.messages.script.path=控制台脚本:
irb.run.configuration.script.not.specified=未指定控制台脚本
irb.run.configuration.script.not.exists=控制台脚本不存在
irb.run.configuration.script.is.not.file=控制台脚本似乎不是文件
irb.run.configuration.invalid.console.type=控制台类型无效。\n\
请尝试移除并重新创建此运行配置。
# Nailgun server
nailgun.server=Nailgun
nailgun.server.name=Nailgun 服务器
nailgun.server.settings=Nailgun 服务器设置
nailgun.server.in.debug=无法在 Nailgun 服务器上进行调试。已从命令行中移除相应形参。
nailgun.server.rc.settings.text=运行 Nailgun 服务器的新实例或使用已启动的实例
nailgun.server.port.label=服务器端口(&P):
nailgun.server.classpath.label=类路径(&C):
nailgun.server.fail=无法启动 Nailgun 服务器
nailgun.server.fail.port=该 Nailgun 服务器位于另一个端口。\n\
已更新命令行形参 "--nailgun-port"。
nailgun.server.fail.gemset=发现使用不同 gemset 的 Nailgun 服务器。\n\
已从命令行中移除 "--ng" 形参。

########################################################################################################################
# Run Configuration extensions:
########################################################################################################################
# Bundler
run.configuration.extension.bundler.editorTitle=Bundler
run.configuration.extension.bundler.label.bundle.exec.required.warning=启用 bundle exec 以便与图形测试运行程序兼容

#########################################################################################################################
# Rake action
########################################################################################################################
rake.action.title=Rake ''{0}''
rake.action.group.name=Rake 任务
rake.action.group.loading.title=正在加载 Rake 任务…
rake.action.execute.task.dialog.title=执行 ''{0}''
rake.action.execute.task.dialog.title.ex=为 ''{1}'' 执行 ''{0}'' 
rake.action.execute.task.dialog.task.args.label=实参(&A):
rake.action.execute.task.dialog.rails.env.label=环境(&E):
rake.action.execute.task.version.dialog.version.label=版本(&V):
rake.action.execute.task.version.dialog.trace.cb=完整回溯(&T)
rake.action.execute.task.version.dialog.step.label=步骤(&S):
rake.action.execute.template.location=模板位置(&T)
rake.popup.prompt.text=输入任务名称或名称的一部分:
rake.popup.checkbox.show.undocumented=包含未记录项(&U)
rake.popup.find.not.in.documented=未找到记录的任务
rake.popup.find.not.found=找不到任务
rake.popup.execute.task.error.title=无法执行任务
rake.popup.execute.task.error.sdk.not.set=未设置 Ruby SDK。检查项目设置。
rake.popup.execute.task.error.unknown=无法在当前项目上下文中启动 Rake 操作。
rake.popup.reload.action.text=[重新加载 Rake 任务列表]
rake.popup.loading.text=正在加载 Rake 任务…

#########################################################################################################################
# Capistrano
########################################################################################################################
run.configuration.capistrano.task.name=任务名称
run.configuration.capistrano.task.arguments=任务实参
run.configuration.capistrano.task.description=Capistrano 任务配置
run.configuration.capistrano.stage.default=默认阶段
run.configuration.capistrano.error.task.name=请指定任务名称
run.configuration.capistrano.error.capistrano.gem=未在 SDK 中找到 Capistrano gem
capistrano.configuration.stage=阶段
capistrano.popup.prompt.text=输入任务名称或名称的一部分:
capistrano.popup.checkbox.name=包含未记录项
capistrano.action.execute.task.dialog.title=执行 ''{0}''
capistrano.action.execute.task.dialog.title.ex=为 ''{1}'' 执行 ''{0}''
capistrano.getting.tasks.progress.title=获取 Capistrano 任务
capistrano.run.configuration.editor.stages.field.text=阶段
capistrano.staged.action.panel.stage.field.text=阶段:

#Rack
run.configuration.rack.name=Rack
run.configuration.rack.description=Rack 应用程序配置
run.configuration.rack.select.rackup.path=设置脚本路径
run.configuration.rack.config.path=Rack 配置文件
run.configuration.rack.rackup.error=未在 SDK 中找到 Rackup 脚本
run.configuration.rack.config.error=指定 rack 配置文件
run.configuration.rack.config.run.browser.text=运行浏览器
run.configuration.rack.config.auto.start.js.debugger.text=调试时自动启动 JavaScript 调试器

#########################################################################################################################
# Generate action
########################################################################################################################
new.generate.common.action.prompt.title=生成 ''{0}''
new.generate.common.action.prompt.title.ex=在 ''{1}'' 中生成 ''{0}''
new.generate.common.error.title=生成错误
new.generate.common.action.title=生成 ''{0}''
new.generate.common.action.description=生成新的 ''{0}''
new.generate.common.generating.title=生成脚本
new.generate.common.error.script.arguments.should.be.specified=必须指定脚本实参。
new.generate.common.error.no.rails=在您的 SDK 中找不到 Rails 脚本。如果不安装 Rails，就无法调用 Rails 生成器。在模块设置中选择其他 SDK 或安装 Rails。

new.generate.controller.actions=操作
new.generate.controller.actions.text.field.info=输入操作并用空格分隔

new.generate.entity.error.name.not.valid={1} 名称必须带下划线，但指定的是 "{0}"
new.generate.entity.error.name.asymmetrical.conversion={0} 名称应相对于“驼峰命名法 <->下划线转换”对称

dialog.generate.common.label.arguments.text=生成器实参(&A):
dialog.generate.common.checkBox.pretend.text=假定(&P)
dialog.generate.common.checkBox.pretend.tooltip=运行但不进行任何更改。
dialog.generate.common.checkBox.force.text=强制(&F)
dialog.generate.common.checkBox.force.tooltip=覆盖已存在的文件。
dialog.generate.common.checkBox.skip.text=跳过(&S)
dialog.generate.common.checkBox.skip.tooltip=跳过已存在的文件。
dialog.generate.common.checkBox.backtrace.text=回溯(&B)
dialog.generate.common.checkBox.backtrace.tooltip=调试: 出错时显示回溯。
dialog.generate.common.checkBox.svn.text=Svn(&V)
dialog.generate.common.checkBox.svn.tooltip=使用 Subversion 修改文件。(注意: svn 必须位于路径中)。
dialog.generate.common.checkBox.git.text=Git(&G)
dialog.generate.common.checkBox.git.tooltip=使用 Git 修改文件。(注意: git 必须位于路径中)。
dialog.generate.common.help.title=''{0}'' 的帮助
progress.dialog.generate.common.help.wait.title=正在加载帮助…
progress.dialog.generate.common.help.cannot.fetch.help.info=无法提取帮助信息。
progress.dialog.generate.common.help.cannot.fetch.generators.list=无法提取生成器列表。
progress.dialog.generate.common.help.no.sdk.set=Ruby SDK 未设置或无效。{0}
progress.dialog.generate.common.help.no.sdk.set.rubymine=请检查“{0} | Ruby SDK 和 Gem”。
progress.dialog.generate.common.help.no.sdk.set.ruby.plugin=请在模块设置中设置 SDK。

new.generate.rspec.name=RSpec

new.generate.cucumber.name=Cucumber
new.generate.feature.description=为新功能生成框架
new.generate.feature.action.prompt.title=添加新功能
new.generate.feature.action.prompt.title.ex=在 ''{0}'' 中添加新功能
new.generate.feature.error.title=生成功能错误
dialog.generate.feature.label.arguments.text=生成器实参: (ModelName [field1:type1 field2:type2])

new.generate.initialize.error=设置 {0} 支持错误
new.generate.initialize.action.description=创建必要的内容以在 Rails 项目中利用 {0} 支持
new.generate.initialize.action.dialog.title=设置 {0} 支持
new.generate.initialize.action.dialog.title.ex=为 ''{1}'' 设置 {0} 支持

new.generate.controller.description=为 Rails 应用程序生成控制器
new.generate.controller.action.prompt.title=添加新控制器
new.generate.controller.action.prompt.title.ex=在 ''{0}'' 中添加新控制器
new.generate.controller.error.title=生成控制器错误
dialog.generate.controller.label.dir.text=目录(&D): (例如 'admin')
dialog.generate.controller.label.addition.options.text=其他选项:
dialog.generate.controller.label.name.text=&{0} 名称: (例如 ''CreditCard'')
new.generate.channel.description=为 Rails 应用程序生成通道
new.generate.channel.action.prompt.title=添加新通道
new.generate.channel.action.prompt.title.ex=在 ''{0}'' 中添加新通道
new.generate.channel.error.title=生成通道错误

new.generate.migration.description=为迁移生成器创建 rails 文件
new.generate.migration.action.prompt.title=添加新迁移
new.generate.migration.action.prompt.title.ex=在 ''{0}'' 中添加新迁移
new.generate.migration.error.title=生成迁移错误
dialog.generate.migration.label.arguments.text=生成器实参: (MigrationName [field1:type1 field2:type2] [options])
new.generate.model.description=为 Rails 应用程序生成模型
new.generate.model.action.prompt.title=添加新模型
new.generate.model.action.prompt.title.ex=在 ''{0}'' 中添加新模型
new.generate.model.error.title=生成模型错误
dialog.generate.model.autocompletion.ad=在 ':' 后使用以进行数据库字段类型自动补全
dialog.generate.model.cb.skip-timestamps=不向此模型的迁移文件添加时间戳(&T)
dialog.generate.model.cb.skip-migration=不为此模型生成迁移文件(&M)
dialog.generate.model.cb.skip-fixture=不为此模型生成固定例程文件(&F)
dialog.generate.scaffold.label.arguments.text=生成器实参: (ModelName [controller_actions and field:type])
dialog.generate.scaffold.label.arguments.text.rails3=生成器实参: (ModelName [field:type])

new.generate.scaffold.description=为整个资源生成基架，从模型到迁移再到控制器和视图，以及完整的测试套件
new.generate.scaffold.action.prompt.title=基架
new.generate.scaffold.action.prompt.title.ex=为 ''{0}'' 生成基架
new.generate.scaffold.error.title=生成基架错误
dialog.generate.scaffold.cb.force-plural=强制生成复数 ModelName(&U)
dialog.generate.scaffold.cb.skip-model=不生成模型或迁移文件(&O)
dialog.generate.scaffold.cb.skip-controller=不生成控制器、帮助程序或视图(&C)
dialog.generate.scaffold.cb.invert=生成除提及操作之外的所有控制器操作(&E)
dialog.generate.scaffold.cb.haml=生成 HAML 视图而不是 ERB(&H)
dialog.generate.scaffold.combo.testframework=为测试文件选择测试框架
dialog.generate.scaffold.combo.default=<默认>
dialog.generate.scaffold.options.title=选项(&O)
dialog.generate.model.label.arguments.text=生成器实参: (ModelName [field1:type1 field2:type2])

# Cucumber support
dialog.generate.cucumber.label.testframework.text=为 Cucumber 选择测试框架:
dialog.generate.cucumber.tframework.spec=RSpec(&R)
dialog.generate.cucumber.tframework.testunit=Test::Unit(&T)
dialog.generate.cucumber.label.options.backend.text=Webapp 交互后端:
dialog.generate.cucumber.sframework.capybara=Capybara(&C)
dialog.generate.cucumber.sframework.webrat=Webrat(&W)
dialog.generate.cucumber.spork.text=与 Spork DRb 一起使用(&D)

# Generators popup
rails.generators.popup.prompt.text=输入生成器名称或名称的一部分:
rails.generators.popup.checkbox.show.hidden=包含隐藏项(&H)
rails.generators.popup.find.not.in.documented=未找到生成器
rails.generators.popup.find.not.found=未找到生成器
rails.generators.popup.execute.task.error.title=无法启动生成器
rails.generators.popup.execute.task.error.sdk.not.set=未设置 Ruby SDK。检查项目设置。
rails.generators.popup.execute.task.error.unknown=无法在当前项目上下文中启动生成器操作。
rails.generators.popup.reload.action.text=[重新加载生成器列表]
rails.generators.popup.loading.text=正在加载生成器…

########################################################################################################################
# Additional registered shortcuts
########################################################################################################################
rails.actions.execution.run.rails.script.title=运行 Rails 脚本
rails.actions.execution.run.rails.script.dialog.button.ok.caption=运行
rails.actions.execution.run.rails.script.dialog.description.caption=您可以从“[{0}]/script”目录运行 Rails 脚本
rails.actions.execution.run.rails.script.dialog.component.script.args.caption=实参
rails.actions.execution.run.rails.script.dialog.component.script.path.caption=脚本
rails.actions.execution.run.rails.script.dialog.component.script.path.caption.select=选择脚本
rails.actions.execution.run.rails.script.error.no.scripts.folder=无法执行 Rails 脚本。未找到“{0}/script”文件夹!
rails.actions.execution.run.rails.script.error.script.want.found=无法执行 Rails 脚本。未找到脚本“{0}”!

########################################################################################################################
# Additional registered shortcuts
########################################################################################################################
keymap.extension.rake.group.name=Rake
action.registered.shortcut.execute.disabled.title=不正确的操作
action.registered.shortcut.execute.invalid.rake.task.msg=未为模块 ''{1}'' 定义 Rake 任务 ''{0}'' \n\
\n\
如果您确定为模块定义了此任务，\n\
请执行“工具 | 重新加载 Rake 任务”，\n\
然后重试。

action.console.runner.edit.cmdline.description=编辑命令行实参
action.console.runner.edit.cmdline.text=编辑命令行实参
action.console.runner.edit.cmdline.dialog.text=命令行实参:
action.console.runner.edit.cmdline.dialog.title=编辑命令行实参

########################################################################################################################
# Color settings page
########################################################################################################################
color.settings.rhtml.name=ERB
color.settings.rhtml.scriptlet.start=Scriptlet 开始
color.settings.rhtml.scriptlet.end=Scriptlet 结束
color.settings.rhtml.expr.start=表达式开始
color.settings.rhtml.expr.end=表达式结束
color.settings.rhtml.scripting.bkg=Ruby 注入后台
color.settings.rhtml.omit.new.line=省略新行修饰符
color.settings.rhtml.comment=注释

color.settings.ruby.name=Ruby

color.settings.ruby.bad_character=错误字符

color.settings.ruby.braces=大括号和运算符//大括号
color.settings.ruby.brackets=大括号和运算符//中括号
color.settings.ruby.colon=大括号和运算符//冒号
color.settings.ruby.comma=大括号和运算符//逗号
color.settings.ruby.dot=大括号和运算符//点
color.settings.ruby.line_continuation=大括号和运算符//续行
color.settings.ruby.operation=大括号和运算符//运算符号
color.settings.ruby.parentheses=大括号和运算符//圆括号
color.settings.ruby.semicolon=大括号和运算符//分号

color.settings.ruby.comment=注释

color.settings.ruby.constant=常量//常量
color.settings.ruby.constant.declaration=常量//常量声明

color.settings.ruby.hash.key=哈希//哈希键
color.settings.ruby.hash_assoc=哈希//哈希火箭

color.settings.ruby.identifier=标识符//标识符
color.settings.ruby.parameter=标识符//形参

color.settings.ruby.keyword=关键字

color.settings.ruby.method.name=方法//方法名称
color.settings.ruby.ruby.paramdef.call=方法//Rails 特殊调用
color.settings.ruby.ruby.specific.call=方法//Ruby 特殊调用

color.settings.ruby.number=数字

color.settings.ruby.invalid.escape.sequence=字符串和符号//转义序列//无效
color.settings.ruby.escape.sequence=字符串和符号//转义序列//有效
color.settings.ruby.heredoc.content=字符串和符号//Heredoc//内容
color.settings.ruby.heredoc.id=字符串和符号//Heredoc//标记
color.settings.ruby.interpolated.string=字符串和符号//插值字符串//内容
color.settings.ruby.expression.substitution.marks=字符串和符号//插值字符串//表达式替换标记
color.settings.ruby.regexp=字符串和符号//RegExp//边界
color.settings.ruby.nth_ref=字符串和符号//RegExp//组引用
color.settings.ruby.string=字符串和符号//字符串
color.settings.ruby.symbol=字符串和符号//符号
color.settings.ruby.words=字符串和符号//单词

color.settings.ruby.class.variable=变量//类变量
color.settings.ruby.global.variable=变量//全局变量
color.settings.ruby.instance.variable=变量//实例变量
color.settings.ruby.local.variable=变量//局部变量

#RDoc
color.settings.rdoc.name=RDoc
color.settings.rdoc.directive=指令
color.settings.rdoc.email=电子邮件
color.settings.rdoc.url=Url
color.settings.rdoc.heading=标题
color.settings.rdoc.identifier=标识符
color.settings.rdoc.tag=标记

button.configure=配置…
sdk.select.prompt.title=选择 SDK
########################################################################################################################
# Module rails
########################################################################################################################
module.rails.generate.app.rails.label=Rails 版本(&V):
module.rails.generate.app.progress.title=正在为 $IDE_DEPENDENT_MODULE$ ''{0}'' 生成 Rails 应用程序…
module.rails.generate.app.rails.new.overwrite.title=创建新的 Rails 应用程序
module.rails.generate.app.rails.new.overwrite.message=''{0}'' 中已存在 Rails 应用程序。\n\
是否覆盖?
module.rails.generate.app.template=Rails 模板(&T):
module.rails.generate.app.template.not.supported=所选 Rails 版本不支持
module.rails.generate.app.template.select=选择 Rails 模板
module.rails.generate.app.template.description=模板允许自定义新的 Rails 应用程序创建
module.rails.generate.app.javascript.select=JavaScript 库(&J):
module.rails.generate.app.working.dir.text=工作目录:
module.rails.create.rake.tasks.title=正在生成 Rake 任务层次结构…
module.rails.create.rake.tasks.for=生成 ''{0}'' 的 Rake 任务层次结构
module.rails.create.rake.generators.title=正在搜索可用的生成器…
module.rails.create.rake.generators.for=搜索 ''{0}'' 的可用生成器
module.rails.create.rake.generators.spring.disabling=在禁用 Spring 的条件下加载
module.rails.create.rake.generators.spring.disabling.content=由于 Spring 挂起，无法加载生成器列表。
module.rails.create.rake.generators.spring.disabling.title=Spring 挂起
module.settings.add.directory.title=添加目录
module.settings.directory.is.already.included=已包含此目录
module.settings.refreshing.sdk=刷新 Sdk
module.rails.create.app.presentable.name=Rails API

#########################################################################################################################
# Parsing
########################################################################################################################
parsing.error.expression=表达式
parsing.symbol.content=符号内容
parsing.alias.object=别名对象
parsing.operation=运算
parsing.method.name=方法名称
parsing.module.name=模块名称
parsing.class.name=类名
parsing.singleton=单例
parsing.local.variables=局部变量
parsing.do.block=do 块调用
parsing.end.of.arg.list=实参列表末尾
parsing.block.arg.or.end=块实参或实参列表末尾
parsing.end.of.expr.or.line=应为: ; 或行结束
parsing.pattern=模式
parsing.error.rest.after.named=不允许在命名实参后使用 rest 实参
parsing.error.rest.one=仅允许一个 rest 实参
parsing.error.predefined.after.named=不允许在命名实参后面使用预定义实参
parsing.error.predefined.not.applicable=预定义实参不适用于模式
parsing.error.capture.argument.after.complex.argument=仅允许在简单实参后转发实参
parsing.error.hash.variables.in.array=哈希变量不适用于数组析构匹配器
parsing.error.array.variables.in.hash=数组变量不适用于哈希析构匹配器
parsing.rhtml.injection.in.ruby.title=%> 或 <% 或 <%=
parsing.haml.end=Haml 中存在不必要的“- end”，请改用缩进
parsing.error.too.complex=表达式过于复杂，无法解析

os.not.supported=OS 不受支持!
select.in.rails=Rails 项目视图

########################################################################################################################
# Rails project view
########################################################################################################################
rails.project.module.view.presentable=Rails
rails.project.module.view.nodes.application.presentable=应用程序
rails.project.module.view.nodes.controllers.presentable=控制器
rails.project.module.view.nodes.model.presentable=模型
rails.project.module.view.nodes.lib.presentable=库
rails.project.module.view.nodes.public.presentable=public
rails.project.module.view.nodes.unclassified.mark=未分类
rails.project.module.view.nodes.helpers.partial.presentable=帮助程序
rails.project.module.view.nodes.views.partial.presentable=视图
rails.project.module.view.nodes.views.layouts.presentable=布局
rails.project.module.view.nodes.minitest.presentable=测试
rails.project.module.view.nodes.minitest.shoulda.presentable=Minitest/Shoulda
rails.project.module.view.nodes.config.presentable=配置
rails.project.module.view.nodes.rspec.presentable=RSpec
rails.project.module.view.nodes.partials.presentable=部分
rails.project.module.view.nodes.shared.partials.presentable=共享部分
rails.project.module.view.nodes.migrations.presentable=迁移
rails.project.module.view.nodes.mailers.presentable=邮件程序
#########################################################################################################################
# RSpec Structure View
########################################################################################################################
ruby.structureview.show.variables=显示变量
#########################################################################################################################
# RSpec Structure View
########################################################################################################################
rspec.structure.view.example.undocumented=<无文档>
rspec.structure.view.actions.list.view.title=列表视图
rspec.structure.view.actions.list.view.description=显示规范示例列表
rspec.structure.view.filters.before.after.calls.title=隐藏调用前/调用后
rspec.structure.view.filters.before.after.calls.description=在结构视图中隐藏调用前/调用后
rspec.structure.view.filters.examples.disabled.title=隐藏禁用的示例
rspec.structure.view.filters.examples.disabled.description=在结构视图中隐藏禁用的示例
rspec.structure.view.filters.examples.pending.title=隐藏挂起示例
rspec.structure.view.filters.examples.pending.description=在结构视图中隐藏挂起的示例
rspec.structure.view.filters.examples.active.title=隐藏活动示例
rspec.structure.view.filters.examples.active.description=在结构视图中隐藏活动 (未禁用和未挂起) 示例

#########################################################################################################################
# File types
########################################################################################################################
filetype.rb.description=Ruby
filetype.rb.display.name=Ruby
filetype.rjs.description=RJS
filetype.rjs.display.name=RJS
filetype.rhtml.description=RHTML
filetype.rhtml.display.name=RHTML
filetype.rxml.description=RXML
filetype.rxml.display.name=RXML
filetype.rdoc.description=RDoc
filetype.rdoc.display.name=RDoc

########################################################################################################################
# Intentions
########################################################################################################################
ruby.intentions.relative.path.to.absolute=转换为绝对路径
ruby.intentions.prepend.cur.dir.to.path=预置当前目录

ruby.intentions.string.to.symbol=转换为符号
ruby.intentions.erb.convert.name=转换为 ERB 注释
ruby.intentions.symbol.to.string=转换为字符串
ruby.intentions.qualified.name.to.import=导入 Java 类
ruby.intentions.string.import.to.dot.reference=转换为点引用
ruby.intentions.string.import.to.camel.reference=转换为限定常量
ruby.intentions.java.to.ruby.call.style=将 '.' 替换为 '::'
ruby.intentions.statement.to.modifier=替换为 ''{0}'' 修饰符
ruby.intentions.statement.to.modifier.familyName=替换为条件修饰符
ruby.intentions.modifier.to.statement=替换为 ''{0}'' 语句
ruby.intentions.modifier.to.statement.familyName=替换为条件语句
ruby.intentions.string.sum.to.substitution=替换为表达式替代
ruby.intentions.braces.to.do=转换为 'do' 块
ruby.intentions.do.to.braces=转换为 ''{ }'' 块
ruby.intentions.extract.block.to.method=将块提取到方法
ruby.intentions.rocket.to.new.hash.style=将 '=>' 转换为 ':'
ruby.intentions.all.rocket.to.new.hash.style=将所有 '=>' 转换为 ':'
ruby.intentions.all.new.hash.style.to.rocket=将所有 ':' 转换为 '=>'
ruby.intentions.new.hash.style.to.rocket=将 ':' 转换为 '=>'
ruby.intentions.sort.hash.by.keys=按键对哈希排序
ruby.intentions.if.to.ternary=将 'if else' 替换为 '?:'
ruby.intentions.ternary.to.if=将 '?:' 替换为 'if else'
ruby.intentions.i18n=国际化硬编码字符串
ruby.intentions.i18n.change.preview.locale=更改预览区域设置
ruby.intentions.i18n.change.preview.locale.rails.default=Rails 默认值
ruby.intentions.i18n.rails.config.adapter.title=查询 Rails 默认区域设置
ruby.intentions.i18n.expand.key=展开 lazy 键
ruby.intentions.heredoc.to.squiggly.name=将 heredoc 转换为 '<<~'
ruby.intentions.flip=翻转 ''{0}''
ruby.intentions.flip.changes.semantics=翻转 ''{0}'' (更改语义)
ruby.intentions.flip.matching.operation=将 ''{0}'' 翻转为 ''{1}''
ruby.intentions.replace.with=将 ''{0}'' 替换为 ''{1}''
ruby.intentions.demorgans=德摩根定律
ruby.intentions.flip.expression=翻转表达式
ruby.intention.assign.field.from.parameter=将形参分配给字段
ruby.intentions.flip.ternary=翻转 '?:'
ruby.intentions.invert.ifElse=反转 'if else'
ruby.intentions.replace.with.block.comment=替换为块注释
ruby.intentions.replace.with.line.comments=替换为行注释
ruby.intention.convert.numbered.parameters.to.named=将编号形参转换为命名形参
ruby.intention.convert.named.parameters.to.numbered=将命名形参转换为编号形参
ruby.intentions.merge.else.if=合并 'else if'
ruby.intentions.split.else.if=拆分 'elsif'
ruby.intentions.merge.nested.ifs=合并嵌套的 'if'
ruby.intentions.merge.nested.ifs.changes.semantics=合并嵌套 'if' (更改语义)
ruby.intentions.merge.sequential.ifs=合并顺序 'if'
ruby.intentions.split.condition=拆分为多个 'if'
ruby.intentions.add.underscores=添加下划线
ruby.intentions.remove.underscores=移除下划线
ruby.intentions.introduce.local.variable=引入局部变量
ruby.intentions.inline.local.variable=内联局部变量
ruby.intentions.add.clarifying.parentheses=添加明确的圆括号
ruby.intentions.remove.parentheses=移除不必要的圆括号
ruby.intentions.expand.namespace=扩展命名空间
ruby.intentions.expand.namespace.changes.semantics=扩展命名空间(更改语义)
ruby.intentions.flatten.namespace=平展命名空间
ruby.intentions.flatten.namespace.changes.semantics=平展命名空间(更改语义)
ruby.intentions.add.accessor=添加特性访问器
ruby.intentions.add.reader=添加特性读取器
ruby.intentions.add.writer=添加特性编写器


########################################################################################################################
# Titles
########################################################################################################################
progress.indicator.title.directories.scanning=正在扫描目录。
progress.indicator.title.please.wait=请稍候…
progress.backgnd.indicator.title.please.wait={0}。请稍候…

########################################################################################################################
#Console
########################################################################################################################
progress.title.console.runner.modal.dialog.running=正在运行: ''{0}''
debugger.console.history.traverse.hint=使用 {0} 和 {1} 滚动浏览已执行的语句
debugger.console.no.stack.frame.available=无法执行语句: 当前堆栈帧不可用。请暂停进程以使用控制台解释器。
debugger.console.layout.tab.name=交互式控制台

########################################################################################################################
# Code Insight
#########################################################################################################################
codeInsight.rails.action_to_view.tooltip=''{0}'' 操作的视图
codeInsight.rails.mailer_to_view.tooltip=''{0}'' mailer 方法的模板
codeInsight.rails.controller_to_view.tooltip=''{0}'' 控制器的视图和部分
codeInsight.rails.view_to_action.tooltip=''{0}'' 视图的操作
codeInsight.rails.view_to_mailer.tooltip=''{0}'' 模板的 mailer 方法
codeInsight.rails.view_to_controller.tooltip=''{0}'' 视图的控制器
codeInsight.rails.layout_to_controller.tooltip=''{0}'' 布局的控制器

codeInsight.rails.switch.to.view.title=转到视图
codeInsight.rails.switch.to.view.create.prompt=未找到视图。输入要创建的视图文件的名称:
codeInsight.rails.switch.to.view.cant.navigate=无法导航到相应视图

codeInsight.rails.switch.to.model.title=转到模型
codeInsight.rails.switch.to.model.cant.navigate=无法导航到相应模型

codeInsight.rails.switch.to.controller.title=转到控制器
codeInsight.rails.switch.to.controller.cant.navigate=无法导航到相应控制器
codeInsight.rails.switch.to.helper.title=转到帮助程序
codeInsight.rails.switch.to.helper.cant.navigate=无法导航到相应帮助程序
codeInsight.rails.navigation.title.action.view=选择视图
codeInsight.rails.create.view.file=创建视图文件 ''{0}''
codeInsight.rails.sprockets.reference.unresolved.message={0} {1} 或 {2} ''{3}''
tests.go.to.test.generate.tests.popup.title=生成测试
tests.go.to.test.generate.tests.gem.not.found=找不到 Gem ''{0}''。
tests.go.to.test.generate.tests.gem.not.found.action.bundle=捆绑
tests.go.to.test.generate.tests.gem.not.found.title=缺少 gem
generator.notification.group=生成测试
generator.notification.after.title=生成已完成
generator.notification.after.content=''{0}'': 生成已成功完成。
generator.notification.not.found.title=未找到生成器
generator.notification.not.found.content=找不到生成器 ''{0}''。请检查可用的生成器。
generator.notification.not.found.action.rollback=回滚
########################################################################################################################
# Annotations
#########################################################################################################################
annotation.error.cannot.make.alias.for.nth.variable=无法为数字变量创建别名
annotation.error.class.module.name.must.be.constant=类/模块名称必须以大写字母开头
annotation.error.class.in.method=方法体中存在类定义
annotation.error.unsupported.endless.method.definition=无穷方法定义至少需要 Ruby 3.0
annotation.error.unsupported.endless.method.definition.setter=setter 方法无法在无穷方法定义中定义
annotation.error.module.in.method=方法体中存在模块定义
annotation.error.formal.arg.cannot.be.constant=形式参数不能是常量
annotation.error.formal.arg.cannot.be.inst.var=形式参数不能是实例变量
annotation.error.formal.arg.cannot.be.global.var=形式参数不能是全局变量
annotation.error.formal.arg.cannot.be.class.var=形式参数不能是类变量
annotation.error.duplicated.arg.name=实参名称重复
annotation.error.block.given.to.yield=无法将块指定给 yield
annotation.error.else.without.rescue.is.useless=不带 rescue 的 else 没有意义
annotation.error.unsupported.i=SDK 不支持 %i
annotation.error.unsupported.i_u=SDK 不支持 %I
annotation.error.unexpected.named.arg=意外 ':'，应为 ')'
annotation.error.unsupported.named.arg=仅 Ruby 2.0 支持命名实参
annotation.error.unsupported.block.local.vars=SDK 不支持块局部变量
annotation.error.unsupported.numeric.modifiers=SDK 不支持数字文字的修饰符
annotation.error.unsupported.hash.to.arguments=SDK 不支持哈希到实参的转换
annotation.error.unsupported.safe.navigation=对于安全导航运算符，至少需要 Ruby 2.3
annotation.error.unsupported.squiggly.heredoc=对于“Squiggly”heredoc，至少需要 Ruby 2.3
annotation.error.unsupported.rescue.in.do.block=对于 do 块中的 rescue/else/ensure，至少需要 Ruby 2.5
annotation.error.unsupported.endless.range=对于无穷范围，至少需要 Ruby 2.6
annotation.error.ambiguous.range='...' 位于 EOL 处，是否应加圆括号?
annotation.error.unsupported.beginless.range=对于无起始范围，至少需要 Ruby 2.7
annotation.error.unsupported.pattern.matching=对于模式匹配，至少需要 Ruby 2.7
annotation.error.unsupported.in.match.rocket.operator=与 '=>' 运算符匹配的模式至少需要 Ruby 3.0
annotation.error.class.module.name.must.be.constant.unicode=类/模块名称必须为常量。对于以非 ASCII 大写字母开头的常量，至少需要 Ruby 2.6
annotation.error.pattern.matching.symbol.literal.with.interpolation.is.not.allowed=不允许带插值的符号文字
annotation.error.numbered.parameter.ordinary.defined=已定义普通形参
annotation.error.numbered.parameter.cant.assign=无法赋值给编号形参
annotation.warning.numbered.parameter.assignment=''{0}'' 为编号形参保留; 考虑其他名称
annotation.error.numbered.parameter.already.used.in.outer.block=编号形参已在外部块中使用
annotation.error.numbered.parameter.already.used.in.inner.block=编号形参已在先前的内部块中使用
annotation.error.unsupported.forward.arguments=对于实参转发，至少需要 Ruby 2.7
annotation.error.unsupported.forward.arguments.with.leading=包含前导实参的实参转发至少需要 Ruby 3.0
annotation.error.unexpected.forward.arguments=意外…
annotation.error.both.block.arg.and.block.given=给定了块实参和实际块
annotation.error.only.one.rest.arg.allowed=仅允许一个 rest 实参
annotation.error.unexpected.rest.arg=意外 rest 实参

#########################################################################################################################
# Autocomplete, resolve
#########################################################################################################################
in=位置:
assoc.key=哈希键
parameter=形参
numbered.parameter=编号形参
local.variable=局部变量
constant=常量
global.variable=全局变量
class.variable=类变量
instance.variable=实例变量
field.write=字段写入
call=调用
method=方法
singleton.method=单例方法
class=类
module=模块
alias=别名
symbol=符号
delegated.method=委派方法
required.named.argument=必选
optional.named.argument=可选

########################################################################################################################
# Rename
#########################################################################################################################
rename.incorrect.name=名称不正确: ''{0}''
rename.cannot.rename.accessor.method.to.common=无法将访问器名称重命名为常用方法名称
rename.same.name=名称相同
rename.already.existing.variable=变量 ''{0}'' 已存在
rename.quick.fix.family.name=重命名
rename.quick.fix.name=重命名
rename.quick.fix.name.to=重命名为 {0}
########################################################################################################################
# RubyPsiDocumentation
#########################################################################################################################
ruby.doc.file=文件
ruby.doc.module=模块
ruby.doc.class=类
ruby.doc.method.class=类方法
ruby.doc.method.instance=实例方法
ruby.doc.method=方法
ruby.doc.field.reader=字段读取器
ruby.doc.field.writer=字段编写器
ruby.doc.alias=别名
ruby.doc.original=原始
ruby.doc.several.variants=找到多个变量
ruby.doc.usage=用法
ruby.doc.description=描述
ruby.doc.documentation.from.partial={0} 中的部分声明:
ruby.doc.documentation.from.partial.no.address=部分声明:

##########################################################################################################################
# Inspections
#########################################################################################################################
inspection.group.ruby.name=Ruby
inspection.group.ruby.rails.name=Rails
inspection.group.ruby.code.metrics.name=代码指标
inspection.group.ruby.codestyle.name=代码样式问题
inspection.group.ruby.control.flow.name=控制流问题
inspection.group.ruby.data.flow.name=数据流
inspection.group.ruby.gems.name=Gem 和 gem 管理
inspection.group.ruby.general.name=常规
inspection.group.ruby.inheritance.name=继承问题
inspection.group.ruby.internal.name=内部
inspection.group.ruby.language.migration.name=语言级别迁移帮助
inspection.group.ruby.probable.bugs.name=可能的错误
inspection.group.ruby.redundant.code.name=冗余代码
inspection.group.jruby.name=JRuby

# Inspection: Missing YARD @param tag
inspection.missing.yard.param.tag.name=方法形参中缺少 '@param' 标记
inspection.missing.yard.param.tag.syntax.format=生成的标记格式:
inspection.missing.yard.param.tag.name.type=@param 名称 [Type]
inspection.missing.yard.param.tag.type.name=@param [Type] 名称
inspection.missing.yard.param.tag.parameter.not.annotated=形参未使用 '@param' 标记进行注解
inspection.missing.yard.param.tag.method.params.not.annotated=方法的某些形参缺少 '@param' 标记
inspection.missing.yard.param.tag.quickfix.name=添加 '@param' 标记
inspection.missing.yard.param.tag.quickfix.name.for.method=添加 '@param' 标记

# Inspection: Missing YARD @return tag
inspection.missing.yard.return.tag.name=方法中缺少 '@return' 标记
inspection.missing.yard.return.tag.method.not.annotated=方法未使用 '@return' 标记进行注解
inspection.missing.yard.return.tag.quickfix.name=添加 '@return' 标记

# Inspection: call
inspection.argcount.name=不正确的调用实参计数
inspection.argcount.required.at.least=需要 {0} 个或以上
inspection.argcount.required.max=需要 {0} 个或以下
inspection.argcount.missing.argument=缺少实参 {0}
inspection.argcount.missing.arguments=缺少实参 {0}
inspection.argcount.unknown.keyword=未知关键字 ''{0}''
inspection.argcount.unknown.keyword.fix=移除未知关键字
inspection.argcount.required=需要 {0} 个
inspection.argcount.extra.argument=找到额外实参
inspection.argcount.extra.arguments=找到额外实参
inspection.argcount.extra.argument.fix=移除额外实参
inspection.argcount.extra.arguments.fix=移除额外实参
inspection.argcount.block.required=缺少块
inspection.argcount.block.generate=生成块

# Inspection: duck type
# Inspection: ruby interpreter
inspection.invalid.interpreter.not.configured=没有为项目配置 Ruby 解释器
inspection.invalid.interpreter.configured=为项目选择的 Ruby 解释器无效
inspection.invalid.interpreter.quick.fix.name=配置

# Inspection: resolve
inspection.resolve.name=未解析的引用
inspection.resolve.cannot.find=无法找到 ''{0}''
inspection.resolve.field.cannot.find=无法找到字段 ''{0}'' 的声明
inspection.resolve.cannot.find.in.type=找不到类型 ''{1}'' 的 ''{0}''
inspection.resolve.implicit.required.item=隐式必需文件，未检查
inspection.resolve.cannot.find.required.file=没有要加载的此类文件
inspection.resolve.cannot.resolve.include=无法正确解析，未处理
inspection.resolve.warn.implicit.resolve.results=报告类型接收器上未解析的引用
inspection.weak.match.incorrect.resolve.display.name=错误解析的引用(弱匹配)
inspection.approximate.match.incorrect.resolve.display.name=错误解析的引用(近似匹配)
inspection.exact.match.incorrect.resolve.display.name=错误解析的引用(精确匹配)

# Inspection: ruby incorrect resolve
inspection.incorrect.resolve.text.based=使用基于文本的解析

# Inspection: YARD return type match

# Inspection: YARD param type match

# Inspection: YARD param/return type match

# Inspection: Invalid call to protected/private method
inspection.invalid.call.to.protected.private.method=对 protected/private 方法的调用无效
inspection.invalid.call.to.protected.private.method.replace.quick.fix=将 ''{0}'' 替换为 ''{1}''
inspection.invalid.call.to.protected.private.method.required=必填:
inspection.invalid.call.to.protected.private.method.passed=已通过:
inspection.invalid.call.to.protected.private.method.visibility.violation=可见性违规
inspection.invalid.call.to.protected.private.method.warning.text=对 {0} 方法 ''{1}'' 的调用无效

# AccessModifierProblem
access.modifier.problem.remove.explicit.self=移除显式 'self'
access.modifier.problem.wrap.call.with.send=用 'send' 包装调用

# Inspection: scopes local var
inspection.scopes.name=变量/形参范围
inspection.scopes.parameter.shadows.outer=形参 ''{0}'' 隐藏了外部形参或局部变量
inspection.scopes.uninitialized.local.variable=局部变量 ''{0}'' 可能未初始化
inspection.scopes.redundant.block.local.variable=局部变量声明 ''{0}'' 冗余
inspection.scopes.too.big.for.type.inference=''{0}'' 太大，无法进行类型推理
inspection.scopes.do.block.too.big.for.type.inference=块太大，无法进行类型推理

# Inspection: unused local variable
inspection.unused.locals.name=未使用的局部变量/形参
inspection.unused.locals.local.is.not.used=未使用局部变量 ''{0}''
inspection.unused.locals.local.value.is.not.used.anymore=局部变量 ''{0}'' 赋值后未使用
inspection.unused.locals.parameter.is.not.used=未使用形参 ''{0}''
inspection.unused.locals.parameter.value.is.not.used.anymore=形参 ''{0}'' 赋值后未使用
inspection.unused.locals.replace.with.wildcard=替换为 '_'
inspection.unused.locals.remove.assignment=移除赋值
inspection.unused.locals.rename.to.constant=重命名为常量


# Inspection: implement java interface/override abstract class
inspection.implement.interface.name=类缺少 Java 接口方法实现
inspection.implement.interface.fix=实现方法
inspection.implement.interface.class.should.implement.method=类缺少对 ''{0}'' 的实现

# Inspection: super class must be a class
inspection.super.class.must.be.a.class.name=超类为接口
inspection.super.class.must.be.a.class.message=超类为接口
inspection.super.class.must.be.a.class.fix.name=将继承更改为 'include' 该接口

# Inspection: super class must be a class
inspection.imported.class.should.be.public.name=导入了 private 类
inspection.imported.class.should.be.public.message=导入了 private 类
inspection.imported.class.should.be.public.fix.name=将此类设为 'public'

# Inspection: call
inspection.unnecessary.semicolon.name=冗余分号
inspection.unnecessary.semicolon.message=冗余分号
inspection.unnecessary.semicolon.quickfix.message=移除分号

# Inspection: unnecessary return statement
inspection.unnecessary.return.statement.name=冗余的 'return' 语句
inspection.unnecessary.return.statement.message=冗余的 'return' 关键字
inspection.unnecessary.return.statement.remove.fix=移除 'return'
inspection.unnecessary.return.statement.replace.with.nil.fix=替换为 'nil'
inspection.unnecessary.return.statement.in.assignment.message=赋值方法中存在冗余的 'return' 语句
inspection.unnecessary.return.statement.warn.multiple.values.return=针对 return 语句中有多个值发出警告

# Inspection: unnecessary return value
inspection.unnecessary.return.value.name=冗余变量用作 'return' 值
inspection.unnecessary.return.value.message=冗余变量用作 'return' 值
inspection.unnecessary.return.value.remove.fix=移除变量和赋值

# Inspection: string jruby import
inspection.jruby.string.import.name=无效的导入格式
inspection.jruby.string.import.message=无效的导入格式
inspection.jruby.string.import.fix1=将 '::' 替换为 '.'
inspection.jruby.string.import.fix2=移除 'Java' 前缀

# Inspection: jruby java field access
inspection.jruby.java.field.access.name=找不到字段访问器
inspection.jruby.java.field.access.message=无法使用点引用访问非 public Java 字段，请使用 'field_reader'、'field_writer' 或 'field_accessor'
inspection.jruby.java.field.access.enum.message=无法使用点引用访问枚举字段
inspection.jruby.java.field.access.enum.fix=将 '.' 替换为 '::'

# Inspection: parentheses around conditional
inspection.parentheses.around.conditional.name=条件表达式带括号
inspection.parentheses.around.conditional=条件表达式具有括号
inspection.parentheses.around.conditional.message=移除括号

# Inspection: wrong top level package
inspection.wrong.top.level.package=不正确的顶层软件包规范
inspection.wrong.top.level.package.fix=向软件包中添加 'Java::'
inspection.wrong.top.level.package.should.be.one.of=使用的顶层 Java 软件包应为 {0} 之一

# Inspection: large class
inspection.large.class.methods.name=类/模块的方法过多
inspection.large.class.methods=''{0}'' 的方法过多 (方法计数 = {1})
inspection.large.class.methods.property=方法数
inspection.large.class.methods.checkbox.name=忽略测试类
inspection.large.class.variables.name=类/模块的实例变量过多
inspection.large.class.variables=''{0}'' 的实例变量过多 (实例变量计数 = {1})
inspection.large.class.variables.property=实例变量数

# Inspection: hashes
inspection.duplicated.keys.in.hash=哈希中存在重复键
inspection.duplicated.keys.in.hash.msg=重复键
inspection.duplicated.keys.in.hash.fix.delete=移除键
inspection.duplicated.keys.in.hash.msg1=不正确的 'Hash[...]' 调用，应为偶数个实参
inspection.hash.keys.types='Hash[...]' 调用不正确
inspection.hash.double.quoted.keys.name=用字符串作为键的哈希
inspection.hash.double.quoted.keys=哈希中存在字符串键
inspection.hash.double.quoted.keys.fix=转换为符号键
inspection.hash.convert.in.file=传统哈希语法
inspection.hash.convert.in.file.fix=转换为 ruby 1.9+ 样式

# Inspection: blocks
inspection.block.replace.with.method.reference.name=使用块而不是方法引用
inspection.block.replace.with.method.reference=块可替换为方法引用
inspection.block.replace.with.method.reference.msg=转换为方法引用(更改语义)
inspection.block.replace.with.method.reference.option.name=忽略 \\&method(…) 引用

# Inspection: double quoted string to single quoted
inspection.quoted.string=在字符串中不必要地使用双引号
inspection.quoted.string.msg=在字符串中不必要地使用双引号
inspection.quoted.string.label=忽略包含单引号的字符串
inspection.quoted.string.fix=转换为单引号

# Inspection: expression in '' string
inspection.expression.in.string=带单引号的字符串中的表达式替换
inspection.expression.in.string.msg=转换为双引号

# Inspection: empty rescue block
inspection.empty.rescue.block='rescue' 块为空
inspection.empty.rescue.block.msg=添加 'ignored' 注释
inspection.empty.rescue.block.with.comments.checkbox.label=忽略包含注释的 'rescue' 块
inspection.empty.rescue.block.param.underscore.checkbox.label=对名称为 '_' 的 'rescue' 形参忽略

# Inspection: if can be switch
inspection.if.can.be.case=可简化 'if' 语句
inspection.if.can.be.case.option=最小分支数

# Inspection: case without else block and empty else block
inspection.case.without.else.name='case' 语句没有 'else' 块
inspection.case.without.else='case' 语句没有 'else' 块
inspection.case.without.else.msg=添加 'else' 块
inspection.empty.else.block='else' 块为空
inspection.empty.else.block.with.comments.checkbox.label=忽略包含注释的 'else' 块

# Inspection: deprecated syntax
inspection.deprecated.syntax.name=弃用的语法
inspection.deprecated.syntax=弃用的语法
inspection.deprecated.syntax.ruby19=弃用的语法 (已从 Ruby 1.9 中移除)
inspection.deprecated.syntax.fix1=替换为 'then'
inspection.deprecated.syntax.fix2=替换为 ''{0}''
inspection.deprecated.syntax.fix2.family.name=替换为建议的语法


# Inspection: parentheses around arguments of def
inspection.def.parentheses.name=方法定义中不正确的圆括号
inspection.def.parentheses.no.arg=没有形参的方法定义具有括号
inspection.def.no.parentheses=带形参的方法定义没有圆括号
inspection.def.parentheses.msg=添加括号
inspection.def.parentheses.msg2=移除括号

# Inspection: assignment expression in conditional
inspection.assignment.in.conditional=条件中存在赋值表达式
inspection.assignment.in.conditional.name=条件中存在赋值表达式
inspection.assignment.in.conditional.msg=将 '=' 替换为 '=='
inspection.assignment.in.conditional.msg2=添加明确的圆括号
inspection.assignment.in.conditional.parentheses.checkbox.label=报告带括号的赋值

# Inspection: literal array
inspection.literal.array=字符串文字数组，而不是 '%w'
inspection.literal.array.msg=转换为 '%w' 语法

# Inspection: nested ternary operators
inspection.nested.ternary.operators=嵌套的三元运算符
inspection.nested.ternary.operators.fix=将外部三元转换为 'if' 语句

# Inspection: then in multiline conditional
inspection.then.in.multiline.conditional=位于多行 'if'/'unless' 块中的 'then'
inspection.then.in.multiline.conditional.msg=移除 'then'

# Inspection: for to each
inspection.for.to.each.quickfix.message=转换为 '.each'

# Inspection: call
inspection.dead.code.name=不可到达的代码
inspection.dead.code.unreachable.code=不可到达的代码
inspection.dead.code.unreachable.method=不可到达的代码，此方法在引用之前被重写

# Inspection: nil analysis
inspection.nil.analysis.name='nil' 取消引用
inspection.nil.analysis.warning=方法调用 ''{0}'' 可能导致 ''NoMethodError''

# Inspection: redundant safe navigation
inspection.redundant.safe.navigation.name=冗余的安全导航
inspection.redundant.safe.navigation.warning=冗余的安全导航
inspection.redundant.safe.navigation.message=将 '\\&.' 替换为 '.'

# Inspection: Dynamic constant assignment error
inspection.dynamic.const.assignment.name=动态常量赋值
inspection.dynamic.constant.assignment=动态常量赋值

# Inspection: Don't put space before parentheses
inspection.parentheses.name=方法调用中圆括号前的空格
inspection.parentheses.warning=方法调用的括号前有空格

#Inspection: Redundant parentheses after method call
inspection.parentheses.after.method.call.name=无实参方法调用中的冗余圆括号
inspection.parentheses.after.method.call=无实参方法调用具有圆括号
inspection.parentheses.after.method.call.fix=移除括号

# Inspection: jump error
inspection.jump.error.name=jump 语句的上下文不正确
inspection.jump.error.return.inside.class.or.module='return' 语句位于类或模块主体内
inspection.jump.error.no.loop.for.break='break' 语句没有相应的循环
inspection.jump.error.no.loop.for.next='next' 语句没有相应的循环
inspection.jump.error.no.loop.for.redo='redo' 语句没有相应的循环
inspection.jump.error.no.context.for.retry='retry' 语句没有相应的上下文
# Inspection: ParamDef resolve inspection
inspection.paramdef.resolve.name=方法调用中的意外实参
inspection.paramdef.unexpected.param.value=此方法调用的意外形参值
inspection.paramdef.hash.unexpected.key=意外哈希键 ''{0}''
inspection.paramdef.hash.unexpected.key.type=应为符号，而不是字符串键: ''{0}''
inspection.paramdef.array.arg.out.of.bounds.warning=额外的数组元素。此数组应仅包含 {0} 个元素
inspection.paramdef.class.ref.warning=应为类名
inspection.paramdef.classifiable.ref.warning=应为类名
inspection.paramdef.association.warning=找不到 ''{0}'' 关联字段的关联 Rails 模型
inspection.paramdef.controller_action.warning=无法找到 Rails 操作 ''{0}''
inspection.paramdef.controller.warning=应为 Rails 控制器名称 (例如: 对于 LoginController 为 login)，但找到的是 ''{0}''
inspection.paramdef.module.warning=找不到模块 ''{0}''
inspection.paramdef.helper.warning=应为帮助程序名称(例如对于 ''app/helpers/login_helper.rb''，应为 :''login'')或 '':all'' 形参，但实际为 ''{0}''
inspection.paramdef.file.warning=应为文件名(例如 :''/public/404.html''，但实际为 ''{0}'')
inspection.paramdef.image.warning=应为图像或 ''public'' 文件夹中图像的相对路径(例如: '' icon''、''icon.png''、''/icons/icon.gif'')，但实际为 ''{0}''
inspection.paramdef.method.warning=应为方法名称 {0}，但实际为 ''{1}''。
inspection.paramdef.access.warning=方法访问修饰符应至少为 {0}
inspection.paramdef.method.warning.up.to.part=从当前类或父类到 ''{0}''
inspection.paramdef.migration.warning=应为表 ''{0}''{2} 的数据库字段名称，但实际为 ''{1}''
inspection.paramdef.migration.warning.undefined.db=类 ''{0}'' 的未定义表的数据库字段 ''{1}''
inspection.paramdef.rails.model.class.ref.warning=应为 Rails 模型类名
inspection.paramdef.rails.model.association.ref.warning=无法找到 rails 关联 ''{0}''
inspection.paramdef.model.warning=应为数据库表名称 (例如: 对于模型 Person 为 people)，但找到的是 ''{0}''
inspection.paramdef.partial.warning=应为模板名称或模板路径的一部分(例如 ''partial'' 或 ''/login/partial'')，但实际为 ''{0}''
inspection.paramdef.script.warning=应为 ''public/scripts'' 文件夹中 javascript 的相对路径(例如: ''prototype'')，但实际为 ''{0}''
inspection.paramdef.stylesheet.warning=应为样式表或 ''public'' 文件夹中样式表的相对路径(例如: ''coderay.css''、''coderay''、''/stylesheets/user-styles'')，但实际为 ''{0}''
inspection.paramdef.view.warning=应为位于 [VIEW_TEMPLATE_ROOT] 中的视图模板(例如对于 ''[VIEW_TEMPLATE_ROOT]/login/index.html.erb''，应为 ''login/index'')，但实际为 ''{0}''
inspection.paramdef.layout.warning=应为位于 [VIEW_TEMPLATE_ROOT]/layouts 中的布局文件的路径或对布局方法名称的符号引用(例如对于 ''[VIEW_TEMPLATE_ROOT]/layouts/login.html.erb''，应为 ''login''，或者 :my_render_method)，但实际为 ''{0}''
inspection.paramdef.table_name.warning=应为数据库表名 {1}，但实际为 ''{0}''。
inspection.paramdef.warning.eg.singular=(例如 {0})
inspection.paramdef.warning.forbidden.symbol.usage=此处无法使用符号值
inspection.paramdef.warning.forbidden.symbol.in.assoc.class_name=Rails 在此处不接受符号值，应改用字符串
inspection.paramdef.warning.expected.type=此处应为 {0} 类型
inspection.paramdef.aggregated.expected.warning=应满足如下预期之一:\n\
{0}
# Inspection: Rails 3.0 deprecated feature
inspection.rails3.deprecated.name=已弃用功能
inspection.rails3.constant.deprecated=已弃用 ''{0}'' 常量
inspection.rails3.call.deprecated=已弃用 ''{0}'' 调用
inspection.rails4.dynamic.finders=动态查找器已弃用，将在 Rails {0} 移除，建议使用 ''where'' 重写

# Inspection: Shoulda unsupported file name
inspection.shoulda.reassignment.name=Shoulda 测试的文件名错误
inspection.shoulda.reassignment.error.msg=Shoulda 测试的文件名错误

# Inspection: Simplify
inspection.simplify.name=可以简化表达式
inspection.simplify.familyName=简化
inspection.simplify.message.quickfix.message=简化为 ''{0}''

# Inspection: Class variable usage
inspection.class.variables.name=类变量用法
inspection.class.variables=类变量的用法

# Inspection: Super call without superclass
inspection.call.super='super' 调用未定义超类
inspection.call.super.outside.of.method='super' 调用在方法之外

# Inspection: Instance variable in string
inspection.instance.variable.to.string.name=插值变量无大括号
inspection.instance.variable.to.string=插值的实例变量没有大括号
inspection.global.variable.to.string=插值的全局变量没有大括号
inspection.instance.variable.to.string.fix=添加大括号

# Inspection: Convert control flow
inspection.control.flow.conversion.name=控制流语句中的负条件
inspection.control.flow.conversion=控制流语句中的负条件
inspection.control.flow.conversion.quickfix.message=将 ''{0}'' 转换为 ''{1}''
inspection.control.flow.conversion.quickfix.family.name=求反语句
inspection.unless.with.else.name='unless' 语句包含 'else'
inspection.unless.with.else.quickfix.message=转换为 'if' 语句

# Inspection: wrong bracket balance
inspection.bracket.balance=不平衡的中括号
inspection.bracket.balance.message=缺少 ''{0}''
inspection.bracket.balance.fix=插入缺少的 ''{0}''

# Inspection: For loop usage
inspection.for.loop.name=非常规 'for' 循环
inspection.for.loop=非常规 'for' 循环

# Suppress : Ruby
suppress.inspection.statement=对语句禁止
suppress.inspection.method=对方法禁止
suppress.inspection.class.module=对类/模块禁止
suppress.inspection.class.module.all=禁止类/模块的所有检查

inspection.duplicate.step.definition.message=发现多个同名的步骤定义
inspection.duplicate.step.definition.gutter.tooltip.message=发现多个同名的步骤定义
inspection.duplicate.step.definition.gutter.title=多个步骤定义同名
inspection.duplicate.step.definition.gutter.balloon.title=选择重复的步骤定义
inspection.step.definition.parameter.count.message=块部分中的形参计数与步骤名称中的形参计数不匹配

# Rails checklist inspections
inspection.rails.checklist.view.calls.find.name=视图中存在 'find' 或 'find_by' 方法调用
inspection.rails.checklist.view.calls.find.message=视图中存在 'find' 或 'find_by' 方法调用

# Rails ActionMailbox inspections
inspection.rails.actionMailbox.missing.process.name=邮箱缺少 'process' 方法
inspection.rails.actionMailbox.missing.process.message=邮箱缺少 'process' 方法
inspection.rails.actionMailbox.missing.process.fix.name=添加 'process' 方法

inspection.rails.actionMailbox.missing.routes.name=邮箱没有路由
inspection.rails.actionMailbox.missing.routes.message=邮箱没有路由

# Inspection: yard
inspection.group.yard.name=YARD

inspection.yard.name=标记用法不正确
inspection.yard.several.param.tags=''{0}'' 的 ''@param'' 标记重复
inspection.yard.wrong.param=''@param'' 标记中存在未定义的形参 ''{0}''
inspection.yard.remove.tag=移除标记

# Inspections: unused import
inspection.jruby.unused.import.name=未使用的 import
inspection.jruby.unused.import=未使用的 import
inspection.jruby.remove.import=移除未使用的 import

# Inspection: java deprecated method usage
inspection.jruby.deprecated.java.method.name=弃用的方法用法
inspection.jruby.deprecated.java.method.usage=''{0}'' 已被弃用
inspection.jruby.deprecated.java.method.override=重写 ''{0}'' 中弃用的方法

# Inspection: Ruby 2.3 safe navigation adoption
inspection.ruby.one.if.to.safe.nav.name=复杂调用链
inspection.ruby.one.if.to.safe.nav.problem.name=链式 nil-safe 调用可简化为 '\\&.'
inspection.ruby.one.if.to.safe.nav.quickfix.name=简化为 '\\&.'
inspection.ruby.safe.nav.to.one.if.intention.name=将 '\\&.' 替换为链式调用
inspection.ruby.safe.nav.to.multiple.ifs.intention.name=将 '\\&.' 替换为嵌套 'nil' 检查

# Inspection: using a module as superclass
inspection.module.as.superclass=用作超类的模块

# Inspection: Frozen String literals modification
inspection.modified.object.name=冻结对象修改
inspection.modified.object.problem.name=冻结对象已修改

# Inspection: Parameter naming convention
inspection.ruby.parameter.naming.convention.block=对块形参忽略
inspection.ruby.parameter.naming.convention.lambda=对 lambda 形参忽略
inspection.ruby.parameter.naming.convention.rescue=对 rescue 形参忽略

inspection.ruby.constant.naming.convention.display.name=非常规常量名称
inspection.ruby.global.variable.naming.convention.display.name=非常规全局变量名称
inspection.ruby.class.module.naming.convention.display.name=非常规类/模块名称
inspection.ruby.instance.variable.naming.convention.display.name=非常规实例变量名称
inspection.ruby.instance.method.naming.convention.display.name=非常规实例方法名称
inspection.ruby.class.variable.naming.convention.display.name=非常规类变量名称
inspection.ruby.class.method.naming.convention.display.name=非常规类方法名称
inspection.ruby.local.variable.naming.convention.display.name=非常规局部变量名称
inspection.ruby.parameter.naming.convention.display.name=非常规形参名称

# Inspection: Rubocop
inspection.rubocop.name=RuboCop
inspection.rubocop.error=RuboCop 错误
inspection.rubocop.error.code=RuboCop 返回退出代码 {0}，有关详细信息，请参阅日志
inspection.rubocop.error.starting=无法启动 RuboCop: {0}
inspection.rubocop.error.starting.no.details=RuboCop 执行错误
inspection.rubocop.details=详细信息…
inspection.rubocop.error.parsing=无法解析 RuboCop 响应
inspection.rubocop.disable=禁用 RuboCop
inspection.rubocop.disabled=RuboCop 检查已禁用
inspection.rubocop.no.gem=当前 $IDE_DEPENDENT_MODULE$ SDK 中缺少 ''{0}''。
inspection.rubocop.no.gem.manual.text=如果要使用 ''{0}'' linter，请安装该工具并重新启用 RuboCop 检查。
inspection.rubocop.no.gem.action.title=安装 ''{0}'' 并重新启用
inspection.rubocop.no.suitable.sdk=未找到已安装 ''{0}'' 的合适 Ruby SDK。请将其安装到 SDK 并重新运行分析。
inspection.rubocop.use.standard=使用 'standard' gem
inspection.rubocop.severities.mapping=RuboCop 严重性映射
intention.rubocop.autocorrect=修复所有可自动更正的错误
intention.rubocop.autocorrect.filtered=修复 [{0}] 个错误
intention.rubocop.autocorrecting.progress=使用 RuboCop 进行更正: {0}
intention.rubocop.autocorrecting=使用 RuboCop 自动更正
intention.rubocop.error.output=无法解析 RuboCop 的输出。请参阅以下 {0} 以了解详情。
intention.rubocop.error.output.see.link.text=讨论
intention.rubocop.error.no.output=RuboCop 进程没有输出
intention.rubocop.error.readonly=RuboCop 正在运行。请稍候…
rubocop.notification.group=RuboCop
########################################################################################################################
# LineMarkers
#########################################################################################################################
overrides=重写
overridden=被重写
mixed.in=混合
partial=部分声明
superclass=超类
line.marker.select.overridden.variant=选择被重写的方法
line.marker.select.overriding.variant.class=选择子类
line.marker.select.overriding.variant.module=选择包含类
line.marker.select.overriding.variant.method=选择重写方法
line.marker.navigate.overridden.variant=转到 super 方法
line.marker.navigate.overriding.variant.class=转到子类
line.marker.navigate.overriding.variant.method=转到重写方法

#########################################################################################################################
# Module settings dialog
#########################################################################################################################
module.create.dialog.init.errors.title=模块 ''{0}'': 设置错误

module.settings.dialog.i18n.folders.tab.title=I18n 文件夹
module.settings.dialog.i18n.folders.with.locales.title=具有区域设置的文件夹

module.settings.dialog.load.path.tab.title=加载路径
module.settings.dialog.load.path.list.caption=加载路径(&L):

##########################################################################################################################
# JRuby Facet
#########################################################################################################################
jruby.facet=JRuby
jruby.select.sdk=选择 JRuby SDK
jruby.framework.configurable.select.sdk.text=JRuby SDK:

#Settings tab: Gem Manager and SDK
jruby.settings.tabs.gem.manager.title=Gem 管理器
jruby.settings.tabs.gem.manager.error.wrong.sdk=所选 SDK 不是 JRuby SDK


jruby.framework.configurable.sdk=JRuby SDK:
jruby.action.import.java.class.text=导入 Java 类
jruby.action.import.java.class.familyName=导入

##########################################################################################################################
# Rails Facet
#########################################################################################################################
rails.facet=Ruby on Rails
jrails.facet=JRuby on Rails
rails.application.project.generator.name=应用程序
rails.application.api.generator.name=Rails API
rails.application.generator.install.rails.gem=安装 Rails Gem…
rails.application.settings=Rails 应用程序设置
rails.mountable.engine.project.generator.name=可安装引擎
rails.mountable.engine.settings=Rails 引擎设置
rails.api.settings=Rails Api 设置
rails.facet.wizard.error.no.skd=您未选择包含 Rails 框架的 Ruby SDK
rails.facet.wizard.error.skd.without.rails=您的 SDK 不包含 Rails 框架
rails.facet.wizard.tab.rails.project.generator.title=Rails 应用程序
rails.facet.wizard.tab.rails.project.generator.select.rails.relative.path=<html>请指定将在其中生成应用程序的目录。路径应该相对于模块内容目录。如果将此字段留空，将使用模块内容目录。 (示例: 'myapp' 或 'src/rails/myapp' 或留空):</html>
rails.facet.wizard.tab.rails.project.generator.select.rails.preconfigure.for.db=为选定数据库预配置(&P):
rails.facet.wizard.tab.rails.project.generator.select.rails.generate.mountable.engine=生成 Rails 可安装引擎(&E)
rails.facet.wizard.tab.rails.project.generator.select.rails.skip.test.unit=跳过 Test::Unit 文件(&S)
rails.facet.wizard.tab.rails.project.rails.version.title=刷新 Rails 版本

rails.test.creator.name=运行 'rails generate'…
rails.test.creator.bundle.install.command.name=捆绑 gem ''{0}''

##########################################################################################################################
# Gem Facet
#########################################################################################################################
gem.facet.wizard.error.no.skd=您未选择 Ruby SDK
gem.facet.wizard.error.no.bundler=无法找到 Bundler
gem.facet.settings.tab.general.title=信息
gem.facet.settings.tab.general.homeDir=Ruby Gem 基目录:

##########################################################################################################################
# Ruby application
#########################################################################################################################
ruby.project.wizard.tab.project.generator.ruby.sdk=Ruby SDK(&S):

##########################################################################################################################
# Gem application
#########################################################################################################################
gem.project.generator.name=Gem
gem.wizard.generate.project.title=Gem 设置
gem.wizard.bundler.version=Bundler 版本(&V):
gem.wizard.create.exe.folder=创建可执行文件(&E)
gem.wizard.create.test.minitest=使用 minitest(&M)
gem.wizard.create.test.rspec=使用 rspec(&R)
gem.wizard.create.coc=添加行为准则(&O)
gem.wizard.create.c.ext=创建 C 扩展样本(&C)
gem.wizard.create.mit=添加 MIT 许可证(&T)
gem.wizard.no.bundler.before.link.text=未找到 bundler gem。 
gem.wizard.no.bundler.link.text=安装…
gem.bundler.not.found=未在 SDK 中找到 Bundler gem。请安装 Bundler
gem.download.bundler.gem=下载 Bundler gem 列表
gem.download.bundler.error=未找到 bundler gem。\n\
请检查代理设置和 gem url
gem.build.options.dialog.title={0} Gem {1}
gem.build.options.arguments=可选实参
empty.project.generator.name=空项目

#------- Rails Facet Builder
rails.facet.builder.run.configuration.server.creating=创建 Rails 运行配置
rails.facet.builder.run.configuration.server.creating.for=为 ''{0}'' 创建 Rails 运行配置
rails.facet.builder.rails.application.searching=搜索 Rails 应用程序
rails.facet.builder.rails.application.choose.title=Rails 应用程序根文件夹
rails.facet.builder.rails.application.choose.relative.path=选择模块内容根的相对路径。

#------- Settings --
rails.facet.settings.tab.general.title=信息
rails.facet.settings.tab.general.railsHomePath.caption=Rails 应用程序主目录:

#------ Actions -----
rails.facet.action.regenerate.generators.error.wrong.sdk=无法重新加载可用的生成器。没有为模块指定 SDK。
rails.facet.action.regenerate.rakeTasks.error.wrong.sdk=无法重新加载可用的 Rake 任务。没有为模块指定 SDK。

rails.spring.stop.title=Spring 停止

##########################################################################################################################
# Wizard
#########################################################################################################################
new.project.wizard.rvm.gemset=创建
new.project.wizard.rvm.gemset.exists=使用 gemset ''{0}''(&U)
new.project.wizard.rvm.gemset.create.title=创建 RVM Gemset ''{0}''
new.project.wizard.rvm.gemset.create.gemsets.title=创建 RVM Gemset
rvm.gemset.create.refreshing.sdk.progress.title=刷新 RVM SDK

##########################################################################################################################
# RHTML Parsing
#########################################################################################################################
rhtml.parsing.flex.error=Lexer 错误!!!
rhtml.parsing.named.element.is.not.closed=元素 {0} 未关闭
rhtml.parsing.unexpected.end.of.file=意外的文件结尾

##########################################################################################################################
# Breadcrumbs
#########################################################################################################################
breadcrumbs.rhtml.presentation.omit.new.line=省略新行
breadcrumbs.rhtml.presentation.comment=注释
breadcrumbs.rhtml.presentation.ruby.injection=Ruby 注入

##########################################################################################################################
# Refactoring
#########################################################################################################################
# introduce
refactoring.introduce.name.error=名称错误
refactoring.introduce.selection.error=使用选定的元素不能执行重构
refactoring.introduce.context.error=不能执行重构在这个上下文
refactoring.introduce.command.error=无法对命令调用执行重构
refactoring.introduce.input.error=无法执行重构。所选片段取决于局部变量
refactoring.introduce.state.changed.error=无法执行重构。所选片段内的状态已更改
refactoring.introduce.variable.changed.error=无法执行重构。语句内的变量已更改
refactoring.introduce.occurrences.checkbox.text={0}（{1} 个匹配项）
refactoring.introduce.dialog.name.text=名称(&N):
refactoring.introduce.dialog.type.text=类型(&T):
refactoring.introduce.dialog.replace.all.occurrences.checkbox.text=替换所有匹配项(&A)

# introduce variable
refactoring.introduce.variable.scope.error=名称与现有局部变量或形参冲突

# introduce parameter
refactoring.introduce.parameter.dialog.title=提取形参
refactoring.introduce.named.parameter.error=名称与现有命名形参冲突
refactoring.introduce.parameter.outside.method.error=无法在任何方法之外执行重构
refactoring.introduce.parameter.has.error.arguments=无法在形参错误的方法内执行重构
refactoring.introduce.parameter.no.acceptable.type=无法执行重构: 未找到可接受的实参类型
refactoring.introduce.parameter.parameter.to.method=正在将形参添加到方法

# introduce constant
refactoring.introduce.constant.scope.error=已在范围中声明名称

# introduce field
refactoring.introduce.field.scope.error=名称与现有字段冲突
refactoring.introduce.field.context.error=无法替换类和实例上下文中的所有匹配项
refactoring.introduce.field.class.context.error=无法在类上下文中使用 @@ 变量

# override implement
refactoring.override.methods.title=选择要重写的方法
refactoring.implement.java.methods.title=选择要实现的方法

# generate
refactoring.generate.methods.writer=为变量生成 attr_writer
refactoring.generate.methods.reader=为变量生成 attr_reader
refactoring.generate.methods.accessor=为变量生成 attr_accessor
refactoring.generate.methods.accessor.cant.find=未找到可为其生成访问器的变量
refactoring.generate.methods.reader.cant.find=未找到可为其生成读取器的变量
refactoring.generate.methods.writer.cant.find=未找到可为其生成编写器的变量

# extract method
refactoring.extract.method.error.method.name.clashes.with.existing.method=方法名称与现有方法名称冲突
refactoring.extract.method.error.cannot.perform.refactoring.no.corresponding.loop.for.break=代码段内没有用于 break 语句的相应循环
refactoring.extract.method.error.cannot.perform.refactoring.no.corresponding.loop.for.next=代码段内没有用于 next 语句的相应循环
refactoring.extract.method.error.cannot.perform.refactoring.no.corresponding.loop.for.redo=代码段内没有用于 redo 语句的相应循环
refactoring.extract.method.error.cannot.perform.refactoring.no.corresponding.context.for.retry=代码段内没有用于 retry 语句的相应上下文
refactoring.extract.method.error.cannot.perform.refactoring.when.execution.flow.is.interrupted=执行流中断时无法执行重构
refactoring.extract.method.error.cannot.perform.refactoring.when.class.declaration.inside=当类声明位于代码段中时，无法执行重构
refactoring.extract.method.error.cannot.perform.refactoring.when.module.declaration.inside=当模块声明位于代码段中时，无法执行重构
refactoring.extract.method.error.cannot.perform.refactoring.when.method.declaration.inside=当方法声明位于代码段内部时，无法执行重构
refactoring.extract.method.error.cannot.perform.refactoring.using.selected.elements=无法使用所选元素执行提取方法
refactoring.extract.method.error.cannot.perform.refactoring.with.return.statement.inside.and.not.empty.output.variables=无法通过内部的 return 语句和代码段中的局部变量修改来执行重构
refactoring.extract.method.error.cannot.perform.refactoring.from.expression.with.not.empty.output.variables=无法通过代码段内具有局部变量修改的表达式执行重构

rails.refactoring.extract.partial.dialog.title=提取部分
rails.refactoring.extract.partial.action.title=部分…

#rspec let introduction
rspec.refactoring.extract.let.error.cannot.perform.refactoring.using.selected.elements=无法使用选定元素执行提取 RSpec let
rspec.refactoring.extract.let.title=提取 RSpec 'let'
rspec.refactoring.extract.let.error.cannot.perform.refactoring.with.not.in.example.scope=无法在示例组范围外执行 'extract RSpec let' 重构
rspec.refactoring.extract.let.error.cannot.perform.refactoring.with.input.variables=无法执行重构。\n\
选定的代码段中存在输入变量“{0}”。\n\
请将其声明包含在选定的代码段中，然后重试。
rspec.refactoring.extract.let.error.cannot.perform.refactoring.with.input.variable=无法执行重构。\n\
选定的代码段中存在输入变量“{0}”。\n\
请将其声明包含在选定的代码段中，然后重试。
rspec.refactoring.extract.delete.unnecessary.let.calls.command.name=删除不必要的 RSpec let 调用
rspec.refactoring.extract.let.reduced.count.message=已移除不必要的调用

# push down
refactoring.push.down.error.cannot.perform.refactoring.no.child.classes=类 {0} 没有继承者

# extract superbase
refactoring.extract.superbase.name.error={0} 名称应为 Ruby 常量
refactoring.extract.superbase.directory.does.not.exist=目录 {0} 不存在
refactoring.extract.superbase.directory.file.exists=文件 {0} 已存在
refactoring.extract.superbase.name.prompt=&{0} 名称:
refactoring.extract.superbase.from=从以下位置提取 {0}:
refactoring.extract.superbase.no.members=未选择要构成的成员

# extract module
refactoring.extract.module.command=从 {0} 提取模块
refactoring.extract.module.header=提取模块
refactoring.extract.module.members.to.form.module=用于构成模块的成员(&F)
refactoring.extract.module.directory.for.module=新模块的目录(&D):
refactoring.extract.module.context=用于构成模块的上下文:
refactoring.extract.module.context.static=static (extend)(&E)
refactoring.extract.module.context.instance=实例 (include)(&I)

# extract super class
refactoring.extract.superclass.directory.for.class=新类的目录(&D):

# extract  class to file
refactoring.move.class.module=将类或模块移到上一级
refactoring.move.class.module.header=将{0}移到上一级
refactoring.move.class.command.name=将 {0} 移至 {1}
refactoring.move.class.module.to.file.name.prompt=新文件路径(&F):
refactoring.move.class.module.command=移动 {0}
refactoring.move.class.module.directory=新 {0} 的目录(&D):
refactoring.move.class.module.name.prompt=新{0}名称(&N):
refactoring.move.class.module.type=移动 {0} {1}
refactoring.move.class.module.warning.directory=指定的目标目录不存在
refactoring.move.class.module.warning.file.exists=文件已存在
refactoring.move.class.module.members=要重构的成员

#inline local
refactoring.inline.local.multi.assignment=使用多个赋值定义

#rename application controller
refactoring.rename.application.controller=无法重命名应用程序控制器

haml.refactoring.extract.partial.dialog.title=部分提取
haml.refactoring.extract.partial.action.title=部分…

##########################################################################################################################
# Execution
#########################################################################################################################
execution.error.title.generators.list={0}: 获取可用的生成器列表
execution.error.title.rake.tasks={0}: 获取可用的 Rake 任务
execution.error.title.generate.rails.app=为模块 ''{0}'' 生成 Rails 应用程序
execution.error.title.abstract.script={0}: 脚本执行错误
execution.disable.spring.notification.content=由于 Spring 挂起，无法加载可用的 Rake 任务。
execution.disable.spring.notification.title=Spring 挂起
execution.disable.spring.notification.action.title=在禁用 Spring 的条件下加载

##########################################################################################################################
# Find usages
#########################################################################################################################
find.usages.search.for.super.title=查找用法
find.usages.search.for.super.message=方法 {0} 重写来自 {1} {2} 的方法。\n\
要改为查找基方法的用法吗?

find.usages.filteringRule.show.symbols=显示符号/哈希键

find.usages.ruby.method.call=方法调用
find.usages.ruby.message.send.group=发送消息
find.usages.ruby.declarations.group=声明
find.usages.ruby.namespace.declaration.group=命名空间声明
find.usages.ruby.partial.declarations.group=部分声明
find.usages.ruby.superclass.clause.group=超类子句
find.usages.ruby.alias.occurrence.group=别名
find.usages.ruby.require.load.file.occurrence.group=需要或加载文件
find.usages.ruby.untyped.group=无类型 (潜在) 用法
find.usages.ruby.string.group=字符串文字中的用法
find.usages.ruby.symbol.or.hash.key.group=符号/哈希键
find.usages.ruby.extend.include.prepend.group=extend/include/prepend 调用中的用法
find.usages.ruby.nested.constant.access.group=嵌套常量访问
find.usages.ruby.constant.member.access.group=常量成员访问
find.usages.ruby.rescue.clause.group=rescue 块形参列表
find.usages.ruby.type.check.group=类型检查调用中的用法
find.usages.ruby.defined.statement.group=defined? 语句中的用法
find.usages.ruby.visibility.modifier.group=可见性修饰符调用中的用法

find.usages.rails.delegate.group=委托调用中的用法

##########################################################################################################################
# Unwrap
##########################################################################################################################
unwrap.if=解开 if...
unwrap.unless=解开 unless…
unwrap.while=解开 while...
unwrap.until=解开 until…
unwrap.else=解开 else...
remove.else=移除 else...

##########################################################################################################################
# Gem messages
##########################################################################################################################
gem.not.found.executable.for.gem=Gem ''{0}'' 未安装或其可执行文件脚本 ''{1}'' 不存在。

error.module.ror.valid.expected=应为 Ruby、Rails 或带 JRuby Facet 的 Java 模块，但实际为 {0}

sdk.no.specified=未指定 SDK

##########################################################################################################################
# Ruby Unit Test Runner
##########################################################################################################################
ruby.test.runner.sdk.script.not.found=未在带解释器的 Ruby SDK 的 $LOAD_PATH 中找到文件 ''{0}'': ''{1}''
ruby.test.runner.sdk.gem.lib.not.found=在包含解释器的 Ruby SDK 的 ''test-unit'' gem 中找不到 Lib 文件夹: ''{0}''
ruby.test.runner.sdk.test-unit.gem.not.attached=测试运行程序需要 ''test-unit'' gem，但后者{0}。
ruby.test.test.name.group.delimiter=，位置:

##########################################################################################################################
# Web Preview
##########################################################################################################################
rails.web.preview.unknown.controller=文件 ''{0}'' 不是 Rails 视图或相应的 Rails 控制器不存在。
rails.web.preview.unknown.action=无法在 Rails 控制器 ''{1}'' 中找到 ''{0}'' 操作。
rails.web.preview.unsupported.layouts=预览不支持 Rails 布局。
##########################################################################################################################
# Debugging
##########################################################################################################################
ruby.debugger.smart.step.into.title=单步进入函数
ruby.debugger.line.breakpoint.title=Ruby 行断点
ruby.debugger.exception.breakpoint.title=Ruby 异常断点
ruby.debugger.exception.breakpoint.default.display.text=任何异常
ruby.debugger.exception.breakpoint.display.text=异常 ''{0}''
ruby.debugger.could.not.evaluate=无法评估: {0}
ruby.debugger.is.not.ready=调试器未就绪
ruby.debugger.stackframe.not.available=堆栈帧不可用
ruby.debugger.no.stack.frames.available=没有可用的堆栈帧
ruby.debugger.global.variables=全局变量
ruby.debugger.cannot.start.debug=无法启动调试器。{0}
ruby.debugger.cannot.find.gem=未找到 Gem“{0}”
ruby.debugger.cannot.connect=无法连接到调试器
ruby.debugger.cannot.connect.timeout=正在使用 {0} 秒超时连接到调试器，请稍候…
ruby.debugger.connecting=连接到调试器
ruby.debugger.choose.exception.class.dialog.title=选择异常类
ruby.debugger.cannot.find.free.port=无法找到空闲端口
ruby.debugger.timeout=调试连接超时
ruby.debugger.timeout.units=秒
ruby.debugger.verbose.output=Verbose 调试器输出
ruby.debugger.key.value.presentation=哈希内容的键/值表示
ruby.debugger.enable.to_s.control=跟踪 `to_s` 求值
ruby.debugger.ignore.non.project=忽略非项目源
ruby.debugger.use.smart.step.into=始终执行智能单步进入
ruby.debugger.step.over.should.go.into.blocks=将块视为方法代码
ruby.debugger.execution.time.limit=时间限制
ruby.debugger.execution.time.limit.units=毫秒
ruby.debugger.execution.memory.limit=内存限制
ruby.debugger.execution.memory.limit.units=MB
ruby.debugger.disable.spring.for.debug=对调试禁用 Spring
ruby.debugger.attach.to.subprocesses.automatically.text=调试时自动附加到子进程
ruby.debugger.read.frames.of.non.suspended.threads.text=读取非挂起线程的框架（Ruby 2.0 不提供支持）
ruby.debugger.rails.initializer=在 {0} 上调试 Rails 应用程序需要其他初始值设定项
ruby.debugger.rails.initializer.dialog.message={0}\n\
是否要添加?
ruby.debugger.debugger.gem.is.too.old=您的 Gemfile 中有 ''{0}''，但是版本太低。支持的最低版本是 ''{1}''
ruby.debugger.debugger.unlimited.memory.limit=无限制
ruby.debugger.cant.step.into=无法单步进入 {0}:{1} 中的方法，因为它具有 C 级实现
ruby.debugger.notification.group.console=调试器控制台

ruby.attach.add.sdk.for.host=配置 SDK
ruby.attach.add.sdk.for.host.title=附加

error=错误
expected=应为: {0}
unexpected=意外: {0}
or={0} 或 {1}
codeInsight.rails.switch.to.view.error.creating=根据模板创建视图时出错: {0}

##########################################################################################################################
# Model dependencies diagram
##########################################################################################################################
##########################################################################################################################
# Gem management
##########################################################################################################################
gems.gems=Gem

gem.notification.group=Gem
gem.notification.group.installing.errors=Gem 安装错误

# ui common for panel and dialog
gems.ui.common.not.available=不适用

# add gems dialog
gems.add.dialog.version.to.install=要安装的版本(&V):
gems.add.dialog.auto.add.install=自动安装依赖 gem(&A)
gems.add.dialog.install=安装
gems.add.dialog.generate.documentation=生成 RDoc 和 ri 文档(&G)
gems.add.dialog.title.quick.install=安装 {0} Gem

# edit gems urls dialog

# gems inspection
gems.inspection.unattached.gem=缺少 gem
gems.inspection.gem.not.available=''{0}'' 在 ''{1}'' 中不可用
gems.inspection.gem.no.sdk=''{0}'' 不可用；未设置 SDK
gems.inspection.requirement.not.satisfiable=''{0}'' 的版本要求互相矛盾，无法满足
gems.inspection.gem.not.supported.by.sdk=''{0}'' 不能与 SDK ''{1}'' 一起使用
gems.inspection.gem.with.requirements.not.available=''{0}'' 在具有指定版本要求的 ''{1}'' 中不可用
gems.inspection.try.to.install=安装 ''{0}''
gems.inspection.try.to.install.from=从 ''{1}'' 安装 ''{0}''
gems.inspection.remove.version.requirements=移除版本要求
gems.inspection.install.using.bundler=使用 'bundler' 安装缺少的 gem
gems.inspection.git.dependency.not.allowed=Git 依赖项位于 Gemfile 外部

gems.inspection.deprecated.gem.quick.fix.replace.name=替换为 ''{0}''
gems.inspection.deprecated.gem.quick.fix.replace.version=更新为 ''{0}''
gems.inspection.deprecated.gem.quick.fix.replace.name.and.version=替换为 ''{0}''，''{1}''
gems.inspection.wrong.ruby.version=您的 Ruby 版本是 ''{0}''，但您的 Gemfile 指定了 ''{1}''
gems.inspection.no.ruby.version.set=未检测到 SDK，但您的 Gemfile 指定了 ''{0}''
gems.inspection.ruby.version.fix=尝试为项目设置 ruby ''{0}''
gems.inspection.ruby.version.fix.family.name=更改 Ruby 版本
gem.inspection.notification.no.matching.sdk=没有与请求的版本匹配的 SDK: ''{0}''
gem.inspection.notification.no.matching.sdk.body=请单独安装 Gemfile 中指定的 SDK
# Gem Manager panel
gems.gem.manager=Gem 管理器
gems.ruby.gem.manager=Ruby gem 管理器
# debug gems
gems.debugger.alert.title=RubyMine 调试器
gems.bundled.debug.not.found=未找到捆绑的调试 gem
gems.install.debug.gem=未安装调试 gem。是否要安装?
gems.update.debug.gem=调试 gem 已过期。是否要更新?
gems.debugger.in.gemfile=您的 Gemfile 中似乎有 ''{0}'' gem。这可能导致调试过程中出现某些问题。\n\
确定要继续吗?\n\
如果不确定，请查看{1}。
gems.debugger.in.gemfile.check.link.text=调试帮助部分

# gem command
gems.gem.listing.remote=正在列出远程 gem…
gems.gem.listing.remote.url=正在列出远程 gem: {0}…
gems.gem.running.command=运行 gem 命令: {0}
gems.running.command.error=运行 gem {0} 命令时出错
gems.gem.running.remote.error.message=无法运行远程命令: {0}
gems.gem.installing=正在安装 gem…
gems.gem.installing.gem=安装 gem {0}
gems.gem.not.found=未找到 {0} gem。\n\
请检查代理设置和 gem url
gems.gem.installing.failed=安装 Gem 失败
gems.gem.installing.failed.with.reason=无法安装 Gem。{0}
gems.gem.installing.failed.no.sdk=无法安装 gem: 未指定 SDK
gems.gem.installing.failed.list=未安装以下 gem:
gems.gem.installing.error.running.bundler=运行时出错 
gems.reading.environment=正在加载 {0} 的 gem 环境
gems.downloading.gems.list.title=正在下载 ''{0}'' Gem 列表…
gems.install.search.progress.indicator.text=正在搜索 gem 仓库…

gems.running.command.gem.environment.title=正在运行 'gem environment' 命令…
gems.running.command.gem.environment.dialog.title=RubyGems 环境
gems.running.command.gem.environment.dialog.error.message=运行 'gem environment' 时出错
command.run.configuration.display.name=Gem 命令
command.run.configuration.description=gem 命令配置
command.run.configuration.editor.gem.component.text=Gem 名称
command.run.configuration.editor.gem.command.component.text=Gem 命令名称
command.run.configuration.editor.gem.command.arguments.component.text=实参
command.run.configuration.editor.gem.command.exec.name.text=可执行文件名称
command.run.configuration.editor.gem.name.component.text=Gem 名称
# requirements
gems.requirements.missing=未安装 ''{0}'' 所需的某些 gem。 
gems.requirements.missing.action.install=安装缺少的 gem
gems.scanning.title=正在 ''{0}'' 中扫描 Gem 要求
# quick install gem action
gems.quick.additional.params=附加命令行实参(&C):
# miscellaneous
gems.version.not.detected=无法检测到 RubyGems 版本
gems.not.installed.for.sdk=未为 SDK 安装 RubyGems: {0}。<br>\n\
请下载并安装 
gems.not.installed.for.sdk.install.link.text=RubyGems
gems.no.rails.gem=选择版本
gems.not.activated=未激活
gems.not.activated.bundler=不是捆绑包的一部分
gems.directory.excluded.title=已排除自定义 gem 目录
gems.directory.excluded.message=已自动排除目录 (''{0}'')
#Rename models
rails.run.migration.title=已生成迁移
rails.run.migration.action.message=运行迁移
##########################################################################################################################
# Ruby Sdk configuration
##########################################################################################################################
ruby.ide.sdk.configurable.name=Ruby SDK 和 Gem
ruby.ide.sdk.configurable.add.sdk=添加 SDK(&A)…
ruby.ide.sdk.configurable.new.local=新建本地…
ruby.ide.sdk.configurable.new.local.with.configuration.script=使用自定义配置器新建本地解释器…
ruby.ide.sdk.configurable.new.remote=新建远程…
ruby.ide.sdk.configurable.new.rvm.gemset=新建 RVM gemset...
ruby.ide.sdk.configurable.new.local.version.manager=新建本地版本管理器…
ruby.ide.sdk.configurable.no.module.sdk.marked=没有为 $IDE_DEPENDENT_MODULE$ ''{0}'' 配置 Ruby 解释器
ruby.ide.sdk.configurable.no.sdk.found=未找到 Ruby SDK。请参阅
ruby.ide.sdk.configurable.no.sdk.found.topic=设置 Ruby 开发环境
ruby.ide.sdk.configurable.no.default.project.sdk.marked=没有为默认项目配置 Ruby 解释器
ruby.ide.sdk.configurable.errors.text=请解决错误:\n\
 {0}
ruby.ide.sdk.configurable.custom.configurator.dialog.title=使用自定义配置器创建 Ruby SDK
ruby.ide.sdk.configurable.custom.configurator.dialog.editor.label=自定义配置器:
ruby.ide.sdk.configurable.custom.configurator.dialog.no.path.specified=指定 Ruby 解释器路径
ruby.ide.sdk.configurable.custom.configurator.dialog.no.valid.interpreter=指定的路径不包含有效的 Ruby 解释器
ruby.ide.sdk.configurable.custom.configurator.dialog.no.script.specified=指定自定义配置器及其实参
ruby.ide.sdk.language.level=语言级别(&L): 
ruby.ide.sdk.configurable.show.gem.path.title=显示 Gem 路径
ruby.ide.sdk.configurable.synchronize.gems.title=同步 gem 和 RubyMine 帮助程序文件
ruby.ide.sdk.configurable.show.gem.description.title=显示 Gem 说明
ruby.ide.sdk.configurable.select.language.level.action.text=选择语言级别
ruby.ide.sdk.configurable.select.language.level.title=语言级别
ruby.ide.sdk.configurable.create.rvm.gemset.sdk.label=Ruby SDK(&S):
ruby.ide.sdk.configurable.create.rvm.gemset.dialog.title=创建新的 RVM gemset
ruby.ide.sdk.configurable.create.rvm.gemset.text.edit=RVM Gemset(&G):
ruby.ide.sdk.configurable.create.rvm.gemset.validation.failed=RVM gemset 名称无效。必须匹配 [A-Za-z0-9._-]+   
ruby.ide.sdk.configurable.create.rvm.gemset.no.sdk=未选择 SDK
ruby.ide.sdk.configurable.create.rvm.gemset.already.exists=Gemset ''{0}'' 在 SDK ''{1}'' 中已存在
ruby.ide.sdk.configurable.create.sdk.existing.title=存在 SDK
ruby.ide.sdk.configurable.create.sdk.existing=SDK ''{0}'' 已在列表中。请尝试其他路径。
ruby.ide.sdk.configurable.create.remote.host.warning=缺少 Remote Hosts Access 插件。请在“''{0}'' | 插件”中启用此插件。
ruby.ide.sdk.configurable.create.remote.host.warning.title=添加远程解释器
ruby.ide.sdk.init.gem.tree.updating.text=正在更新…
ruby.ide.sdk.patcher.refresh.gem.paths.title=正在刷新 Gem 路径
ruby.ide.sdk.type.home.chooser.descriptor.title=选择 Ruby 解释器路径
ruby.ide.sdk.type.home.field.label=Ruby 解释器路径:
ruby.ide.sdk.init.progress.title=正在初始化 SDK {0}
ruby.ide.sdk.version.manager.presentable.name.system=系统 Ruby
ruby.ide.sdk.version.manager.presentable.name.with.custom.configurator=带有自定义配置器 ({0}) 的 Ruby

ruby.rbenv.gemset.name=Rbenv gemset
ruby.rbenv.gemsets.inspection.name=缺少 Rbenv gemset
ruby.rbenv.gemset.inspection.creating=创建 gemset ''{0}''
ruby.rbenv.gemset.inspection.fix.name=创建 ''{0}''
ruby.rbenv.gemset.inspection.fix.text=在 ''{1}'' 中找不到 ''{0}''
ruby.rbenv.local.gemset.inspection.fix.text=''{0}'' 未从项目文件中排除
ruby.rbenv.local.gemset.inspection.fix.name=排除 ''{0}''，并将其 gem 添加为库
ruby.rbenv.local.gemset.inspection.fix.family.name=排除 gemset 并将其 gem 添加为库
ruby.rbenv.local.gemset.create.inspection.fix.text=找不到 ''{0}''
ruby.rbenv.local.gemset.create.inspection.fix.name=创建 ''{0}''
ruby.rbenv.gemset.refresh.libs.text='.rbenv-gemsets' 已更改
ruby.rbenv.gemset.refresh.libs.inspection.fix.name=更新库
ruby.rbenv.gemset.config.parser.unexpected.token.error.message=意外的标记

filetype.rbenv.description=Rbenv gemset 配置

ruby.action.create.new.class.text=Ruby 文件/类
ruby.action.create.new.class.description=创建新的 Ruby 文件/类
ruby.action.create.new.class.dialog.title=新建 Ruby 文件/类
ruby.action.create.new.class.dialog.wrong.name=名称应为有效的限定常量
ruby.action.create.new.class.dialog.wrong.filename=名称应为有效的文件名
ruby.action.create.new.class.name=创建 Ruby 文件/类 {0}
ruby.action.create.new.class.fix.name=创建新的 Ruby 类
ruby.action.create.new.class.fix.as.inner.name=在当前文件中创建新的 Ruby 类
ruby.action.create.new.class.familyName=创建 Ruby 类
ruby.action.create.new.class.action.name=创建类 ''{0}''

ruby.action.create.new.method.fix.name=创建方法 ''{0}''
ruby.action.create.new.method.fix.familyName=创建方法

ruby.action.create.new.test.text=Ruby 测试
ruby.action.create.new.test.description=根据模板创建新的 Ruby 测试
ruby.action.create.new.test.dialog.title=新建 Ruby 测试
ruby.action.create.new.test.dialog.kind.minitest=Minitest
ruby.action.create.new.test.dialog.kind.minitestSpec=Minitest 规范
ruby.action.create.new.test.dialog.kind.rspec=RSpec
ruby.action.create.new.test.dialog.kind.testUnit=Test::Unit
ruby.action.create.new.test.name=创建 Ruby 测试 {0}

ruby.action.create.named.file.fix.name=创建 {0} 文件 ''{1}''
ruby.action.create.named.file.fix.familyName=创建 {0} 文件
ruby.action.create.named.file.fix.message=输入要创建的文件的名称:
ruby.action.create.named.file.fix.title=创建 {0}

ruby.test.creator.dialog.title=在 {0} 中新建测试
ruby.test.creator.dialog.kind.noTemplate=无模板
ruby.test.creator.dialog.directory.not.in.project=''{0}'' 不在项目中

ruby.erb.action.create.new.file.text=ERB 文件
ruby.erb.action.create.new.file.description=创建新的 ERB 文件
ruby.erb.action.create.new.file.dialog.title=新建 ERB 文件
ruby.erb.action.create.new.file.name=创建 ERB 文件 {0}

##########################################################################################################################
# Ruby code style page
##########################################################################################################################
ruby.code.style.align.right.parts.of.assignments.or.hashes=对齐右侧部分
ruby.code.style.align.right.parts.of.assignments.or.hashes.group=赋值和哈希
ruby.code.style.list.items.group=列表项
ruby.code.style.indent.when.cases=遇到 case 时缩进
ruby.code.style.spaces.around.braces=哈希中的大括号
ruby.code.style.spaces.around.braces.blocks=块中的大括号
ruby.code.style.spaces.around.arrows=哈希火箭
ruby.code.style.spaces.around.operators.range=范围运算符
ruby.code.style.spaces.around.operators.assign=赋值运算符
ruby.code.style.spaces.around.operators.relational=关系运算符
ruby.code.style.spaces.around.operators.other=其他运算符
ruby.code.style.force.newlines.around.visibility.modifiers=在可见性修饰符周围强制使用新行
ruby.code.style.indent.after=缩进访问修饰符后面的方法：
ruby.code.style.indent.private=private
ruby.code.style.indent.protected=protected
ruby.code.style.indent.public=public
ruby.code.style.convert.brace.block.by.enter=按 Enter 将 {} 块转换为 do..end
ruby.code.style.chain.methods.alignment=对齐
ruby.code.style.chain.methods.alignment.none=无
ruby.code.style.chain.methods.alignment.receiver=初始接收器
ruby.code.style.chain.methods.alignment.dot=前导点
ruby.code.style.empty.declarations.style.label=空声明
ruby.code.style.empty.declarations.style.as.is=保留原样
ruby.code.style.empty.declarations.style.single=单行
ruby.code.style.empty.declarations.style.multi=多行

##########################################################################################################################
# Live Templates
##########################################################################################################################
live.templates.context.erb.name=ERB
live.templates.context.generic.name=Ruby
live.templates.context.ruby.code.name=Ruby 代码
live.templates.context.ruby.string.name=Ruby 字符串
live.templates.context.ruby.comments.name=Ruby 注释

##########################################################################################################################
# Rails I18n
##########################################################################################################################
rails.i18n.property.key=属性
rails.i18n.presentable.name.default=未知

inspection.rails.i18n.name=未翻译的 i18n 属性
inspection.rails.i18n.translate.call.wrong.arguments='translate' 调用至少应有一个实参
inspection.rails.i18n.key.not.found=未找到 ''{0}'' 的翻译
inspection.rails.i18n.key.not.defined=''{0}'' 缺少一些翻译
inspection.rails.i18n.create.property=创建属性

dialog.rails.i18n.create.property.title=创建属性
dialog.rails.i18n.create.property.info=属性信息
dialog.rails.i18n.create.property.key=键:
dialog.rails.i18n.create.property.variables=变量:
dialog.rails.i18n.create.property.locale=区域设置
dialog.rails.i18n.create.property.locale.example=拉丁语 [la.yml]
dialog.rails.i18n.create.property.translation=翻译
# suppress inspection "SpellCheckingInspection"
dialog.rails.i18n.create.property.translation.example=Lorem ipsum dolor sit amet, consectetur adipiscing elit.
dialog.rails.i18n.create.property.no.translations=未添加翻译
dialog.rails.i18n.create.property.select.locale=选择区域设置
dialog.rails.i18n.create.property.locale.contains.key=键 ''{0}'' 的翻译已在区域设置 ''{1}'' 中定义

annotator.rails.i18n.locale.file.name=区域设置文件名应包含 ''{0}''
annotator.rails.i18n.locale.file.no.root=区域设置文件应具有根键
annotator.rails.i18n.locale.file.multiple.roots=区域设置文件应只有一个根键
annotator.rails.i18n.locale.missing.locale.entry=无法找到主区域设置条目

refactoring.rename.rails.i18n.conflict.duplicate.property.key=属性 ''{0}'' 已存在

doc.rails.i18n.available.translations=可用翻译

new.name.conflicts.with=键与现有键冲突: ''{0}''

i18n.index.truncated.suffix=<文本已截断>

i18n.folding.options.checkbox.title=Ruby i18n 字符串

##########################################################################################################################
# RVM
##########################################################################################################################
rvm.rvmrc.project.notifications.title=项目 {0} 设置
rvm.rvmrc.project.sdk.changed.message=根据 <b>{0}</b> 项目 {1} 文件，Ruby SDK 已被更改<br>为 <b>{2}</b>"
rvm.rvmrc.project.cannot.find.sdk.message=无法切换 SDK。找不到 RVM SDK ''<b>{0}</b>''。
rvm.rvmrc.project.cannot.find.gemset.for.sdk.message=无法切换 SDK。没有为 ''<b>{1}</b>'' RVM SDK 定义 Gemset ''<b>{0}</b>''，或未在 {2} 中配置此类 SDK。
rvm.support.notification.group=RVM 支持
ruby.sdk.scanning=正在扫描 Ruby 解释器…
##########################################################################################################################
# Bundler
##########################################################################################################################
bundler.cmd.options.dialog.additional.cmdline.parameters=''bundle {0}'' 的可选实参
bundler.cmd.options.dialog.title=捆绑 {0}
bundler.cmd.options.dialog.title.ex=为 {1} 捆绑 {0}
bundler.notification.group=Bundler
bundler.notification.error.title=无法启动 Bundler
bundler.notification.error.message=无法找到 Bundler 脚本，请参阅日志了解更多详细信息。
bundler.action.no.sdk.title=无法执行 Bundler 操作
bundler.action.no.sdk.message=没有为当前项目选择 SDK
bundler.console.gem.not.found.title=Bundler: 找不到 gem
bundler.action.update.old.bundler=安装
bundler.action.update.failed=更新 Bundler 时出错
bundler.action.cancel=取消
bundler.action.run=运行
bundler.action.continue=仍然继续
bundler.action.dialog.old.version=您的 Gemfile.lock 需要 Bundler {0}。是否要安装?
bundler.console.gem.not.found.action.bundle.install=运行 'bundle install'
bundler.gem.not.found.install.missing.dialog.title=未找到 Bundler Gem
bundler.gem.not.found.install.missing.dialog.message=未找到 Bundler Gem，但存在 Gemfile。 \n\
是否要安装 Bundler 并使用它来安装缺少的 gem?

##########################################################################################################################
# Warbler
##########################################################################################################################
warbler.dialog.caption=Warble
warbler.dialog.error.title=Warbler 的错误
warbler.dialog.title=构建 .WAR 文件
warbler.dialog.toggle.web.inf.config=WEB-INF 配置
warbler.dialog.feature.executable=可执行文件(&X)
warbler.dialog.feature.precompiled=已预编译(&P)
warbler.dialog.feature.gemJar=包括 gem 仓库(&G)
warbler.dialog.label.outputFileName=输出文件名(&F):
warbler.dialog.mode.trace=开启 invoke/execute 跟踪，启用完整回溯(&T)
warbler.config.patching.error=无法更改 Warbler 配置文件。%s
warbler.validation.error.fileName=输出文件名不正确
warbler.validation.error.jruby.sdk.not.found=SDK 不正确! 应为 JRuby SDK
warbler.validation.error.jruby.sdk.not.found.fix.title=配置 SDK
warbler.validation.error.rails.not.found=未找到 Rails gem
warbler.validation.error.rails.not.found.fix.title=安装 Rails
warbler.validation.error.warbler.not.found=未找到 Warbler gem
warbler.validation.error.warbler.not.found.fix.title=安装 Warbler
warbler.error.cant.write.to.config=无法写入 config/warble.rb 文件
##########################################################################################################################
# Test Frameworks Names
##########################################################################################################################
test.frameworks.names.testunit=Test::Unit
test.frameworks.names.shoulda=Shoulda
test.frameworks.names.rspec=RSpec
test.frameworks.names.cucumber=Cucumber

rails.assets.scan.paths=扫描 Rails 资产路径注册
rails.assets.scan.paths.for=扫描 ''{0}'' 的 Rails 资产路径注册

actions.types.ruby.script.errors.no.module.in.context.rubymine=无法根据操作上下文确定当前项目
actions.types.ruby.script.errors.no.module.in.context.ruby.plugin=无法在操作上下文中找到具有 Ruby 支持的模块
actions.types.ruby.script.errors.no.sdk.in.context.rubymine=项目 Ruby SDK 未配置或无效。是否立即配置?
actions.types.ruby.script.errors.no.sdk.in.context.ruby.plugin=模块(或 Ruby facet) Ruby SDK 未配置或无效。是否立即配置?
actions.types.ruby.script.errors.execution.error.title=执行错误

#Rails destroy components
destroy.dialog.message=销毁或删除 {0}
destroy.dialog.title=销毁或删除 {0}
destroy.dialog.button=销毁

#refactorings
refactoring.inlineVariable=内联变量重构
refactoring.inlineMethod=内联方法重构
refactoring.inlineMethod.libraries.error.message=无法使用库中的方法执行重构
refactoring.inlineMethod.constructor.error.message=无法使用构造函数执行重构
refactoring.inlineMethod.block.parameter.error.message=无法使用具有块形参的方法执行重构
refactoring.introduceField=提取字段重构
refactoring.introduceParameter=提取形参重构
refactoring.introduceConstant=提取常量重构
refactoring.extractMethod=提取方法重构

##########################################################################################################################
# Diagrams
##########################################################################################################################
diagrams.rails.add.new.model=将模型添加到关系图
diagrams.rails.presentable.name=Rails 模型依赖关系图
diagrams.rails.go.to.model=输入模型名称:
diagrams.rails.go.to.model.checkbox=包括非项目模型(&P)
diagrams.rails.generate.new.model=生成新的 ActiveRecord 模型
diagrams.rails.activerecord.model=ActiveRecord 模型
diagrams.gems.presentable.name=Gem 依赖关系图
diagrams.gems.action.name=Gem 依赖关系图

# remote interpreter
remote.interpreter.configure.title=配置远程 Ruby 解释器
# suppress inspection "UnusedProperty"
remote.interpreter.configure.path.title=选择 Ruby 解释器
# suppress inspection "UnusedProperty"
remote.interpreter.configure.temp.files.path.title=为 Ruby 帮助程序选择文件夹
# suppress inspection "UnusedProperty"
remote.interpreter.default.interpreter.path=/usr/bin/ruby
# suppress inspection "UnusedProperty"
remote.interpreter.wsl.default.interpreter.path=/usr/bin/ruby
# suppress inspection "UnusedProperty"
remote.interpreter.docker.default.interpreter.path=ruby
# suppress inspection "UnusedProperty"
remote.interpreter.unspecified.interpreter.path=指定 Ruby 解释器路径
# suppress inspection "UnusedProperty"
remote.interpreter.wrong.interpreter.path=所选文件不是 {0} 的有效主路径
remote.interpreter.invalid.chars.in.interpreter.path=所选文件名包含无效的字符 ({})
# suppress inspection "UnusedProperty"
remote.interpreter.unspecified.temp.files.path=为 Ruby 帮助程序指定路径
# suppress inspection "UnusedProperty"
remote.interpreter.configure.path.label=Ruby 或版本管理器路径(&R):
# suppress inspection "UnusedProperty"
remote.interpreter.configure.temp.files.path.label=Ruby 帮助程序路径:
# suppress inspection "UnusedProperty"
remote.interpreter.entity.name=Ruby
# suppress inspection "UnusedProperty"
remote.interpreter.ssh.level.incompatibility=所选 SSH 配置仅在当前项目中可用。
# suppress inspection "UnusedProperty"
remote.interpreter.move.ssh.config.hyperlink.label=要将其与所有项目中的应用程序级远程 Ruby 解释器结合使用，请将其<a href=#>移动</a>到应用程序级。
remote.interpreter.creating=创建 Ruby SDK
remote.interpreter.already.existing=已经有相同的解释器:\n\
{0}
remote.interpreter.cannot.find.interpreter.path=无法按照提供的解释器路径找到 Ruby
remote.find.available.ports.title=正在搜索可用端口
remote.action.edit.path.mappings.text=编辑路径映射
file.system.moving.file=移动文件: ''{0}''
file.system.copying.file=复制文件: ''{0}''
file.system.removing.file=移除文件: ''{0}''
ruby.fetching.version=正在提取版本字符串

downloading.gems.title=正在下载 Gem
upload.helpers=正在上传 Rubymine 帮助程序…

erb.title=ERB

#ActionCable
rails.action.cable.channel=通道
rails.action.cable.channel.client=通道客户端
rails.action.cable.undefined.channel.inspection.name=未定义通道
rails.action.cable.undefined.channel.inspection.quickfix.name=创建通道
rails.action.cable.undefined.channel.inspection.text=未定义通道
rails.action.cable.client.gutter.title=Action cable 客户端
rails.action.cable.client.gutter.tooltip.text=“{0}”类
rails.action.cable.client.action.gutter.tooltip.text=“{0}”操作
rails.action.cable.switch.to.client.title=转到通道客户端
rails.action.cable.switch.to.client.create.prompt=未找到通道客户端。输入要创建的文件的名称:
rails.action.cable.gutter.tooltip.text=“{0}”客户端
rails.action.cable.gutter.title=Action cable
rails.action.cable.action.gutter.tooltip.text=“{0}”操作调用
rails.action.cable.choose.client.text=选择客户端
rails.action.cable.choose.action.call.text=选择操作调用
rails.action.cable.channels.folder.name=通道

#line markers gutters
rails.line.marker.gutter.action.to.view.title=Rails 视图
rails.line.marker.gutter.view.to.action.title=Rails 操作

# module manager notification
module.manager.notification.title=在项目中找到 Gemfile
module.manager.notification.text=可以为每个 Gemfile 创建 $IDE_DEPENDENT_MODULE_CAPITALIZED$。
module.manager.notification.dont.show=不再询问
module.manager.dialog.title=Gemfile 未与找到的任何 $IDE_DEPENDENT_MODULE$ 关联
module.manager.dialog.text=为 Gemfile 创建 $IDE_DEPENDENT_MODULE$:
module.manager.dialog.create=为新 Gemfile 创建 $IDE_DEPENDENT_MODULE$
module.manager.option.auto.create=自动为 Gemfile 创建 ruby $IDE_DEPENDENT_MODULE$
module.manager.option.show.notifications=针对没有 $IDE_DEPENDENT_MODULE$ 的新 Gemfile 发出通知
module.manager.mark.directory.title=Ruby $IDE_DEPENDENT_MODULE_CAPITALIZED$ 根
module.manager.unmark.directory.title=取消标记为 Ruby $IDE_DEPENDENT_MODULE_CAPITALIZED$ 根

module.manager.option.use.idea=将嵌套的 Ruby $IDE_DEPENDENT_MODULE$ 的 *.iml 文件放入其中

run.anything.custom.activity.sdk.message=已选择 SDK ''{0}''
run.anything.custom.activity.sdk.title=SDK 已更改
run.anything.custom.activity.no.sdk=未选择 SDK

run.anything.rvm.sdk=在当前项目中选择 rvm sdk[@gemset]
run.anything.rvm.use.group.title=rvm 使用
run.anything.rvm.use.undefined=<undefined>

run.anything.select.rbenv.shell.help.description=选择 <版本> 版的 rbenv sdk
run.anything.select.rbenv.shell.completion.group=rbenv shell

run.anything.ruby.help.group.title=Ruby
run.anything.rspec.help.description=rspec <spec_name.rb> --示例 <名称>

run.anything.bundler.title=Bundler

run.anything.rails.generators.group.title=Rails 生成器

run.anything.rake.help.group.title=Rake 任务

#Ruby editor actions
editor.expressionTypeProvider.unknownType=未知
editor.expressionTypeProvider.untypedType=非类型化
editor.expressionTypeProvider.errorHint=找不到表达式
ruby.make.brace.block=生成 {} 块
run.anything.sdk.notification.warning.content=已选择目标 sdk
run.anything.sdk.notification.warning.title=选择 Sdk
version.manager.rbenv.fetching.root=正在获取 rbenv 根
version.manager.rvm.fetching.environment=正在获取 rvm 环境
version.manager.refreshing.sdks=正在刷新 Sdk
version.manager.fetching.distributions.list=正在提取分发列表
version.manager.computing.interpreter.path=正在计算解释器路径
version.manager.error.fetching.distributions.list=获取已安装 ruby 列表时出错
version.manager.unable.to.find.executable=无法找到 {0} 的 ruby 可执行文件
version.manager.unable.to.get.environment=获取 {0} 的环境时出错: {1}
version.manager.you.should.choose=您应该选择一个分发
version.manager.no.rubies.installed=未安装 ruby
version.manager.select.distribution=选择分发
version.manager.detection.path=正在确定 {0} 可执行文件的路径
version.manager.detection.dialog.title={0} 可执行文件的路径
version.manager.detection.dialog.message=自 2018 年 2 月起，必须有 {0} 可执行文件的路径才能运行脚本。\n\
我们无法使用 `which {0}` 命令针对以下项自动检测此路径:\n\
{1}\n\
请手动指定 {0} 可执行文件的路径:
version.manager.detection.not.found=无法找到 {0} 可执行文件
stub.builder.service.updating.stubs=正在更新原生扩展的存根
stub.builder.service.generating.stubs=正在生成 gem 的存根: {0}
run.without.parent.environment.title=在禁用父环境的条件下执行
run.without.parent.environment.text=自 2018 年 2 月起使用空环境 (<nobr><code>env -i</code></nobr>)，可能无法按预期运行，或者根本无法运行。
run.without.parent.environment.action.enable=为此运行配置启用 (需要重新启动)

completion.preselect.first.element=预先选择第一个补全元素
rbconfig.fetching.progress=正在加载 {0} 的 RbConfig…
ruby.smart.keys.option.interpolation=在字符串中的 # 处启动 ruby 插值
ruby.smart.keys.option.prolong.comment=按回车后继续输入注释
sdk.searching.for=正在搜索 ''{0}''

ruby.rails.gotoRelated.application.title=应用程序
ruby.rails.gotoRelated.model.group=模型
ruby.rails.gotoRelated.controller.group=控制器
ruby.rails.gotoRelated.mailer.group=Mailer
ruby.rails.gotoRelated.helper.group=帮助程序
ruby.rails.gotoRelated.view.group=视图
ruby.rails.gotoRelated.views.group=视图
ruby.rails.gotoRelated.layout.group=布局
ruby.rails.gotoRelated.layouts.group=布局
ruby.rails.gotoRelated.schema.group=架构
ruby.rails.gotoRelated.routes.group=路由

ruby.presentation.invalid=<invalid>
ruby.presentation.unknown=<unknown>

editor.empty.text.painter.advertise.action.project.view=项目视图
editor.empty.text.painter.advertise.action.go.to.file=转到文件
editor.empty.text.painter.advertise.action.recent.files=最近的文件
editor.empty.text.painter.advertise.action.navigation.bar=导航栏
editor.empty.text.painter.advertise.action.run.anything=运行任何内容
editor.empty.text.painter.advertise.action.run.anything.ctrl=Ctrl
editor.empty.text.painter.advertise.action.run.anything.double=按两次

# Factory Bot
ruby.factoryBot.usage.type.partial.declaration.name=部分声明
ruby.factoryBot.usage.type.build.strategy.name=构建策略中的用法
ruby.factoryBot.usage.type.definition.name=工厂/特征定义中的用法
ruby.factoryBot.usage.type.inheritance.name=父选项中的用法

ruby.factoryBot.findUsages.search.for.original.title=查找用法
ruby.factoryBot.findUsages.search.for.original.message={0} ''{2}'' 是 ''{3}'' 的别名。\n\
\n\
是否要查找原始 {1} 的用法?

ruby.factoryBot.gotoRelated.factories.title=工厂

ruby.factoryBot.lineMarker.overridden.factory.name=FactoryBot 部分声明
ruby.factoryBot.lineMarker.overridden.factory.title=选择部分声明
ruby.factoryBot.lineMarker.overridden.factory.findUsages.title={0} 的部分声明

ruby.factoryBot.lineMarker.implicit.references.name=FactoryBot 隐式引用
ruby.factoryBot.lineMarker.implicit.references.tooltip.title=隐式引用 {0}

ruby.factoryBot.paramDefs.attributeRef.invalid.reference=应为字段读取器
ruby.factoryBot.paramDefs.factoryRef.invalid.reference=应为工厂名称
ruby.factoryBot.paramDefs.traitRef.invalid.reference=应为特征名称

ruby.factoryBot.presentation.factory.type=工厂
ruby.factoryBot.presentation.factoryOrTrait.type=工厂/特征
ruby.factoryBot.presentation.sequence.type=序列
ruby.factoryBot.presentation.trait.type=特征

ruby.factoryBot.rename.factory.conflict=工厂 ''{0}'' 已存在
ruby.factoryBot.rename.sequence.collision={0} ''{1}'' 中的字段读取器隐式引用旧名称
ruby.factoryBot.rename.sequence.conflict=序列 ''{0}'' 已存在
ruby.factoryBot.rename.trait.conflict=特征 ''{0}'' 已存在

# Rails ActiveRecord

rails.activeRecord.presentation.association.type=关联
rails.activeRecord.presentation.attribute.type=特性
rails.activeRecord.presentation.enum.type=枚举
rails.activeRecord.presentation.scope.type=范围

action.rspec.LetIntroduce.text=RSpec 'let'
action.UnmarkLoadPathRoot.text=取消标记加载路径根
action.MarkLoadPathRoot.text=加载路径根
action.RUBY_GEN_DICT.text=生成 Ruby 拼写检查器字典
action.RUBY_GEN_DICT.description=为当前 Ruby Sdk 和附加的 Gem 生成拼写检查器字典
action.GemRequirements.Attach.text=为要求添加 Gem
action.org.jetbrains.plugins.ruby.rails.console.ReloadSources.text=重新加载源代码
action.org.jetbrains.plugins.ruby.rails.console.ReloadSources.description=在 Rails 控制台中动态重新加载 Ruby 脚本
action.Rails.RunGenerator.text=Rails 生成器
action.Rails.RunGenerator.description=允许快速启动 Rails 生成器
action.org.jetbrains.plugins.ruby.jruby.warbler.actions.WarblerAction.text=构建 .WAR 文件…
action.org.jetbrains.plugins.ruby.jruby.warbler.actions.WarblerAction.description=运行 warbler 以生成 .war 文件
action.org.jetbrains.plugins.ruby.rails.preload.zeus.RunZeusAction.text=运行 Zeus 服务器…
action.org.jetbrains.plugins.ruby.rails.preload.zeus.RunZeusAction.description=运行 Zeus 服务器
action.org.jetbrains.plugins.ruby.rails.spork.RunSporkServerScriptAction.text=运行 Spork DRb 服务器…
action.org.jetbrains.plugins.ruby.rails.spork.RunSporkServerScriptAction.description=运行 spork DRB 服务器以加快测试执行
action.org.jetbrains.plugins.ruby.rails.actions.execution.RunRailsScriptAction.text=运行 Rails 脚本…
action.org.jetbrains.plugins.ruby.rails.actions.execution.RunRailsScriptAction.description=运行 ./script 文件夹中的脚本
action.org.jetbrains.plugins.ruby.rails.console.RunRailsConsoleAction.text=运行 Rails 控制台…
action.org.jetbrains.plugins.ruby.rails.console.RunRailsConsoleAction.description=允许快速运行 Rails 控制台
action.org.jetbrains.plugins.ruby.rails.actions.generators.GeneratorsPopupAction.text=运行 Rails 生成器…
action.org.jetbrains.plugins.ruby.rails.actions.generators.GeneratorsPopupAction.description=允许快速启动 Rails 生成器
group.ROR_TOOLS.text=Ruby on Rails
action.org.jetbrains.plugins.ruby.tasks.capistrano.actions.CapistranoTaskPopupAction.text=运行 Capistrano 任务
action.org.jetbrains.plugins.ruby.tasks.capistrano.actions.CapistranoTaskPopupAction.description=运行 Capistrano 任务
action.org.jetbrains.plugins.ruby.tasks.capistrano.actions.CapifyAction.text=Capify 应用程序
action.org.jetbrains.plugins.ruby.tasks.capistrano.actions.CapifyAction.description=Capifies Rails 应用程序
group.CAPISTRANO_TOOLS.text=Capistrano
action.org.jetbrains.plugins.ruby.rails.actions.generators.ReloadGeneratorsAction.text=重新加载生成器
action.org.jetbrains.plugins.ruby.rails.actions.generators.ReloadGeneratorsAction.description=重新加载可用生成器列表
action.org.jetbrains.plugins.ruby.rails.actions.rake.ReloadRakeTasksAction.text=重新加载 Rake 任务
action.org.jetbrains.plugins.ruby.rails.actions.rake.ReloadRakeTasksAction.description=重新加载可用 rake 任务列表
group.RAKE_GROUP.text=Rake 任务
action.org.jetbrains.plugins.ruby.tasks.rake.actions.RakeTasksPopupAction.text=运行 Rake 任务…
action.org.jetbrains.plugins.ruby.tasks.rake.actions.RakeTasksPopupAction.description=允许快速执行 Rake 任务
group.RAKE_TOOLS.text=Rake
action.org.jetbrains.plugins.ruby.gem.util.ShowGemEnvironmentAction.text=显示 Gem 环境(&H)
action.org.jetbrains.plugins.ruby.gem.util.ShowGemEnvironmentAction.description=显示有关当前 SDK 的 RubyGems 环境的信息
action.org.jetbrains.plugins.ruby.gem.bundler.actions.RunBundlerOutdatedAction.text=过时(&T)
action.org.jetbrains.plugins.ruby.gem.bundler.actions.RunBundlerOutdatedAction.description=显示使用 'bundler' gem 的 gem 清单中所有过时的 gem
action.org.jetbrains.plugins.ruby.gem.bundler.actions.RunBundlerLockAction.text=锁定(&L)
action.org.jetbrains.plugins.ruby.gem.bundler.actions.RunBundlerLockAction.description=锁定使用 'bundler' gem 的 gem 清单中声明的 gem
action.org.jetbrains.plugins.ruby.gem.bundler.actions.RunBundlerPackAction.text=打包(&P)
action.org.jetbrains.plugins.ruby.gem.bundler.actions.RunBundlerPackAction.description=将使用 'bundler' gem 的 gem 清单中声明的 .gem 文件复制到供应商/缓存中
action.org.jetbrains.plugins.ruby.gem.bundler.actions.RunBundlerGemAction.text=创建 gem(&G)
action.org.jetbrains.plugins.ruby.gem.bundler.actions.RunBundlerGemAction.description=使用 'bundler' gem 创建适合使用 bundler 开发的简单 gem
action.org.jetbrains.plugins.ruby.gem.bundler.actions.RunBundlerInitAction.text=初始化 (&N)
action.org.jetbrains.plugins.ruby.gem.bundler.actions.RunBundlerInitAction.description=使用 'bundler' gem 创建 gemfile
action.org.jetbrains.plugins.ruby.gem.bundler.actions.RunBundlerCleanAction.text=清理(&C)
action.org.jetbrains.plugins.ruby.gem.bundler.actions.RunBundlerCleanAction.description=清理 bundler 目录中未使用的 gem
action.org.jetbrains.plugins.ruby.gem.bundler.actions.RunBundlerUpdateAction.text=更新(&U)
action.org.jetbrains.plugins.ruby.gem.bundler.actions.RunBundlerUpdateAction.description=使用 'bundler' gem 更新 gem 清单中声明的 gem
action.org.jetbrains.plugins.ruby.gem.bundler.actions.RunBundlerInstallAction.text=安装(&I)
action.org.jetbrains.plugins.ruby.gem.bundler.actions.RunBundlerInstallAction.description=使用 'bundler' gem 安装 gem 清单中声明的 gem
action.org.jetbrains.plugins.ruby.gem.bundler.actions.InstallBundlerAction.text=安装 Bundler(&I)
action.org.jetbrains.plugins.ruby.gem.bundler.actions.InstallBundlerAction.description=将 'bundler' gem 安装到当前 SDK
group.BUNDLER_ACTIONS.text=Bundler(&B)
action.org.jetbrains.plugins.ruby.gem.application.actions.PushGemAction.text=推送 Gem(&P)
action.org.jetbrains.plugins.ruby.gem.application.actions.PushGemAction.description=将 gem 推送到 gem 仓库
action.org.jetbrains.plugins.ruby.gem.application.actions.BuildGemAction.text=构建 Gem(&B)
action.org.jetbrains.plugins.ruby.gem.application.actions.BuildGemAction.description=为项目构建 gemfile
group.GEM_BUILD_ACTION.text=Gem (&G)
action.org.jetbrains.plugins.ruby.console.LoadInIrbConsoleAction.text=将文件/所选内容加载到 IRB/Rails 控制台中
action.org.jetbrains.plugins.ruby.console.LoadInIrbConsoleAction.description=将当前 Ruby 文件或所选文本加载到正在运行的 IRB/Rails 控制台
action.org.jetbrains.plugins.ruby.ruby.run.configuration.nailgun.JRubyRunNailgunServerAction.text=运行 Nailgun 服务器…
action.org.jetbrains.plugins.ruby.ruby.run.configuration.nailgun.JRubyRunNailgunServerAction.description=运行 Nailgun 服务器以快速启动 JRuby
action.org.jetbrains.plugins.ruby.console.RunIRBConsoleAction.text=运行 IRB(&I)…
action.org.jetbrains.plugins.ruby.console.RunIRBConsoleAction.description=允许快速运行 IRB
action.org.jetbrains.plugins.ruby.console.RunPryConsoleAction.text=运行 Pry(&P)…
action.org.jetbrains.plugins.ruby.console.RunPryConsoleAction.description=允许快速运行 Pry 控制台
group.RUBY_TOOLS.text=Ruby 工具
group.ScriptsErb.text=Erb
action.InsertSession.text=插入 'session[:user]'
action.InsertSession.description=插入 'session[:user]'
action.InsertParams.text=插入 'params[:id]'
action.InsertParams.description=插入 'params[:id]'
group.ScriptsRails.text=Rails
action.InsertHashRocket.text=插入 ' => '
action.InsertHashRocket.description=插入 ' => '
group.ScriptsRuby.text=Ruby
group.ToolsExtensions.text=扩展
action.Rails.SwitchToModel.text=切换到模型
action.Rails.SwitchToModel.description=导航到相应的 Rails 模型
action.org.jetbrains.plugins.ruby.rails.actions.navigation.SwitchToView.text=切换到视图
action.org.jetbrains.plugins.ruby.rails.actions.navigation.SwitchToView.description=导航到相应的 Rails 视图
action.org.jetbrains.plugins.ruby.rails.actions.navigation.SwitchToHelper.text=切换到帮助程序
action.org.jetbrains.plugins.ruby.rails.actions.navigation.SwitchToHelper.description=导航到相应的 Rails 帮助程序
action.org.jetbrains.plugins.ruby.rails.actions.navigation.SwitchToController.text=切换到控制器
action.org.jetbrains.plugins.ruby.rails.actions.navigation.SwitchToController.description=导航到相应的 Rails 控制器
group.RailsNavigateActions.text=Rails 导航
action.Ruby.GenerateAccessor.text=生成访问器
action.Ruby.GenerateAccessor.description=生成访问器
action.Ruby.GenerateWriter.text=生成编写器
action.Ruby.GenerateWriter.description=生成编写器
action.Ruby.GenerateReader.text=生成读取器
action.Ruby.GenerateReader.description=生成读取器
action.Ruby.GenerateConstructor.text=构造函数
action.Ruby.GenerateConstructor.description=生成构造函数
action.ToggleCamelSnakeCase.text=切换骆驼拼写法/蛇形拼写法
action.ToggleCamelSnakeCase.description=将采用骆驼拼写法的字符串与采用蛇形拼写法的字符串互换。
configurable.RubyCodeCompletionConfigurable.display.name=Ruby
configurable.RubyEditorOptionsProvider.display.name=Ruby
configurable.RubyProjectStructureConfigurable.display.name=项目结构
settings.highlight.rdoc.and.ruby.syntax.in.comments=在注释中高亮显示 RDoc 和 Ruby 语法

ruby.regexp.language.name=Ruby 1.9 正则表达式
dialog.kind.module1=模块
dialog.kind.class1=类
dialog.kind.file=文件
error.hint.no.members.to.pull.up.found=未找到要向上拉取的成员
pull.up.handler.no.base.classes.in.project={0} 在当前项目中没有基类/模块
completion.advertisement.press.again.to.see.all.declared.names=再次按下以查看所有已声明的名称
error.hint.no.members.to.push.down.found=未找到要向下推送的成员
popup.title.select.interpreter.path=选择解释器路径
project.view.node.text.assets=资产

parameter.hint.method.name.contains.parameter.name=不显示方法名称是否包含形参名称
parameter.hint.non.literals=仅对文字实参显示
parameter.hint.show.param.grouping=显示隐式形参分组

remote.wsl.transfer.linux.distribution.unavailable=Linux 分发版不可用
coverage.pattern.dialog.include.files.text=包括文件(&I)
coverage.pattern.dialog.include.files.tooltip=为匹配给定模式的文件生成信息
coverage.pattern.dialog.exclude.files.text=排除文件(&E)
coverage.pattern.dialog.exclude.files.tooltip=不为匹配给定模式的文件生成信息
coverage.pattern.dialog.pattern.text=模式(&P):
coverage.pattern.dialog.regexp.list.text=逗号分隔的正则表达式列表
coverage.pattern.dialog.pattern.type.text=模式类型:
coverage.settings.editor.install.text=安装(&I)…
intention.name.assign.parameter.to.field=将形参 ''{0}'' 分配给字段 ''@{1}''
button.build=构建
button.push=推送
notification.title.failed.to.load.remote.gems=无法加载远程 gem {0}
dialog.message.unable.load.to.console=无法加载到控制台 {0}
parsing.error.ruby=[RUBY] {0}
alias.new.name.old.name=别名 {0} {1}
action.text.rubocop.install.to=安装到: {0}
list.item.thread.id.status.process.info=线程 {0} [{1}]{2}
dialog.message.bundled.rcov.gem.not.found=找不到捆绑的 RCov gem
dialog.message.missing.config.initializers.directory=缺少配置/初始值设定项目录
dialog.message.failed.to.create.initializer=无法创建初始值设定项
dialog.message.debug.configuration.not.supported=不支持调试配置
dialog.message.no.rubymotion.support.found=找不到 RubyMotion 支持
dialog.message.xml.debugger.does.not.currently.support.attach.mode=XML 调试器当前不支持附加模式。改用 'ruby-debug-ide' gem。
text.fragment.of.class.name=，类 {0}
command.name.generate.description=生成 {0}
inspection.message.element.position.reference.must.resolve.to={0} ({1}) 引用必须解析为 {2}
popup.context.compilation.failed.ruby.devkit=本机编译失败。请确保您已安装 Ruby {0}。
action.rspec.controller.text=RSpec 控制器
popup.title.select.console.to.load.to=选择要加载到的控制台
show.migration.fields=显示迁移字段
class.anonymous=<anonymous>
text.root.type.ruby.consoles=Ruby 控制台
torquebox.deploy.failed.exception.message=无法部署 {0}
class.method.name.ref.is.too.short=类方法名称 '#ref' 过短
class.method.name.ref.is.too.long=类方法名称 '#ref' 过长
class.method.name.ref.doesn.t.match.regex=类方法名称 ''#ref'' 不匹配正则表达式 ''{0}'' #loc
class.module.name.ref.is.too.short=类/模块名称 '#ref' 过短
class.module.name.ref.is.too.long=类/模块名称 '#ref' 过长
class.module.name.ref.doesn.t.match.regex=类/模块名称 ''#ref'' 不匹配正则表达式 ''{0}'' #loc
class.variable.name.ref.is.too.short=类变量名称 '#ref' 过短
class.variable.name.ref.is.too.long=类变量名称 '#ref' 过长
class.variable.name.ref.doesn.t.match.regex=类变量名称 ''#ref'' 不匹配正则表达式 ''{0}'' #loc
constant.name.ref.is.too.short=常量名称 '#ref' 过短
constant.name.ref.is.too.long=常量名称 '#ref' 过长
constant.name.ref.doesn.t.match.regex=常量名称 ''#ref'' 不匹配正则表达式 ''{0}'' #loc
global.variable.name.ref.is.too.short=全局变量名称 '#ref' 过短
global.variable.name.ref.is.too.long=全局变量名称 '#ref' 过长
global.variable.name.ref.doesn.t.match.regex=全局变量名称 ''#ref'' 不匹配正则表达式 ''{0}'' #loc
method.name.ref.is.too.short=方法名称 '#ref' 过短
method.name.ref.is.too.long=方法名称 '#ref' 过长
method.name.ref.doesn.t.match.regex=方法名称 ''#ref'' 不匹配正则表达式 ''{0}'' #loc
instance.variable.name.ref.is.too.short=实例变量名称 '#ref' 过短
instance.variable.name.ref.is.too.long=实例变量名称 '#ref' 过长
instance.variable.name.ref.doesn.t.match.regex=实例变量名称 ''#ref'' 不匹配正则表达式 ''{0}'' #loc
local.variable.name.ref.is.too.short=局部变量名称 '#ref' 过短
local.variable.name.ref.is.too.long=局部变量名称 '#ref' 过长
local.variable.name.ref.doesn.t.match.regex=局部变量名称 ''#ref'' 不匹配正则表达式 ''{0}'' #loc
parameter.name.ref.is.too.short=形参名称 '#ref' 过短
parameter.name.ref.is.too.long=形参名称 '#ref' 过长
parameter.name.ref.doesn.t.match.regex=形参名称 ''#ref'' 不匹配正则表达式 ''{0}'' #loc
action.project.group.other.text=其他
action.project.group.web.text=Web
rails.db.version.latest.migration=最新迁移
configurable.name.project.structure=项目结构
dialog.message.failed.to.find.free.socket.port.for.process.dispatcher=找不到进程调度程序的可用套接字端口
dialog.message.unable.to.find.local.free.socket=找不到可用的本地套接字。
multiple.declarations=\ (多个声明)
dialog.message.no.evaluator.available.for.frame=没有适用于框架 {0} 的评估器
dialog.message.specify.gem.name=指定 gem 名称
dialog.message.specify.gem.executable=指定 gem 可执行文件
dialog.message.gem.executable.can.t.be.found=找不到 gem 可执行文件
dialog.message.cannot.find.bundler.in.sdk=在 {0} SDK 中找不到 Bundler。
dialog.message.no.gemfile.found=找不到 Gemfile
dialog.title.choose.local.root.folder=选择本地根文件夹
label.command.parameters=命令形参
dialog.message.module.should.be.passed.as.data.to.execution.environment=模块应作为数据传递至 ExecutionEnvironment
dialog.message.can.t.debug.without.sdk=没有 SDK 则无法调试
dialog.message.unable.to.start.process=无法启动进程
dialog.message.unable.to.read.rbconfig.from.specified.interpreter=无法从指定的解释器读取 RBConfig。
dialog.message.please.try.increasing.timeout.in=请尝试增大 {0} 中的超时
dialog.message.can.t.copy.gems=无法复制 gem
dialog.message.unable.to.detect.full.path.for.interpreter=无法检测解释器的完整路径: {0}
label.name.for.extracted.partial.file.default.extension=提取的部分文件的名称(默认扩展名: {0})
dialog.title.extract.partial=部分提取
migration.fields=迁移字段
list.item.usages={0} 的用法
inspection.message.expected=应为 {0}
border.title.ruby.i18n=Ruby i18n
action.fix.gemspec.errors.text=修正 Gemspec 错误
settings.completion.ml.ruby.display.name=Ruby
popup.content.debug.zeus.enabled=您正在启用 Zeus 的情况下调试测试，将不会使用 Zeus 服务器。
popup.content.debug.drb.enabled=您正在启用 DRb 的情况下调试测试，将不会使用 DRb 服务器。 
popup.content.debug.spring.enabled=您正在启用 Spring 的情况下调试测试，将不会使用 Spring 服务器。
action.more.information.text=更多信息
notification.content.cannot.find.corresponding.generator=找不到相应的生成器
list.item.unknown.directory=未知
debugger.breakpoint.position.line=行
notification.group.preloader.warning=Ruby 预加载程序警告


inspection.mismatched.return.type.name=不匹配的返回类型
gem.notification.group.manager.missing.gems=Gem 管理器: 缺少 gem
run.configuration.remote.debug.notification.group.name=远程调试
jruby.compiler.notification.group.name=JRuby 编译器
spring.notification.group.name=Spring
spring.debug.notification.group.name=Spring 调试
nailgun.run.notification.group.name=Nailgun 服务器(运行)
nailgun.debug.notification.group.name=Nailgun 服务器(调试)
gem.manager.notification.group.name=Gem 管理器
bundler.integration.notification.group.name=Bundler 集成
module.manager.notification.group.name=Ruby 模块管理器
run.without.parent.environment.notification.group.name=在无父环境的条件下执行 Ruby
rake.before.run.notification.group.name=Rake 运行前任务
label.run.bundle.check.with.dry.run=使用 --dry-run 运行静默捆绑包检查
notification.group.ruby.settings=Ruby 设置
notification.bundle.check.dry.run.title=捆绑包检查处于 dry 模式
notification.bundle.check.dry.run.message=启用此选项后，您将负责更新锁定文件。确保在更改 Gemfile 后运行捆绑包检查/锁定。
inspection.mismatched.type.warning.title=不兼容的类型
inspection.mismatched.type.expected=必需:
inspection.mismatched.type.actual=实际:
inspection.mismatched.type.nilability.warning.title=不兼容的零值性
inspection.mismatched.type.nilability.nilable=可为零
inspection.mismatched.type.nilability.not.nil=非 nil
rspec.refactoring.extract.let.reduced.count.plural.message=已移除 {0} 个不必要的调用
line.marker.partial.declarations=部分声明
line.marker.partial.declarations.title=选择部分声明
line.marker.partial.declarations.tooltip.one=在以下位置有部分声明:
line.marker.partial.declarations.tooltip.few=在以下位置有部分声明:
line.marker.partial.declarations.tooltip.many=在多个文件中有部分声明
action.Ruby.GenerateAccessor.popup.text=访问器
action.Ruby.GenerateWriter.popup.text=编写器
action.Ruby.GenerateReader.popup.text=读取器
action.RubyMarkVendorLibraryRoot.text=库根
action.RubyUnmarkVendorLibraryRoot.text=项目的一部分
projectView.VendorLibraryRoot.location=库根
run.configuration.extension.bundler.checkbox.bundle.exec=在捆绑包的上下文中运行脚本(‘bundle exec’):
run.configuration.extension.bundler.checkbox.bundle.exec.enable=已启用
run.configuration.extension.bundler.checkbox.bundle.exec.disable=已禁用
run.configuration.extension.bundler.checkbox.bundle.exec.auto=自动检测
run.configuration.extension.bundler.checkbox.bundle.exec.auto.tooltip=IDE 自动检测是否可以通过 ‘bundle exec’ 运行 Ruby 脚本。
ruby.intentions.category.blocks=Ruby/块
ruby.intentions.category.comments=Ruby/注释
ruby.intentions.category.control.flow=Ruby/控制流
ruby.intentions.category.declarations=Ruby/声明
ruby.intentions.category.erb=Ruby/ERB
ruby.intentions.category.hashes=Ruby/哈希
ruby.intentions.category.i18n=Ruby/I18n
ruby.intentions.category.numbers=Ruby/数字
ruby.intentions.category.operators=Ruby/运算符
ruby.intentions.category.refactorings=Ruby/重构
ruby.intentions.category.require.statements=Ruby/require 语句
ruby.intentions.category.strings.symbols=Ruby/字符串和符号
jruby.intentions.category=JRuby
progress.title.starting.ssh.process=正在启动 SSH 进程…
ruby.rubystubs.banner=已捆绑的存根文件(使用 Ruby v{0} 生成)
inspection.mismatched.type.nilability.setting=检查零值性
inspection.mismatched.constant.type.name=不匹配的常量类型
inspection.mismatched.constant.type.actual=已分配:
inspection.mismatched.return.type.actual=返回:
inspection.mismatched.variable.type.name=不匹配的变量类型
inspection.mismatched.variable.type.actual=已分配:
inspection.mismatched.argument.type.name=不匹配的实参类型
inspection.mismatched.argument.type.actual=合格:
inspection.mismatched.parameter.type.name=不匹配的形参类型
inspection.mismatched.parameter.type.actual=已分配:
sdk.ruby.new.wizard.label=Ruby SDK:
inspection.mismatched.globalVariable.type.name=不匹配的全局变量类型
inspection.mismatched.globalVariable.type.actual=已分配:
ruby.gotoRelated.typeSignature.title=类型签名
ruby.gotoRelated.associatedDeclaration.title=关联的声明
action.Ruby.GotoTypeSignature.text=转到类型签名
action.Ruby.GotoTypeSignature.MainMenu.text=类型签名
ruby.actions.goto.typeSignature.text=转到类型签名
ruby.actions.goto.typeSignature.shortText=类型签名
ruby.actions.goto.typeSignature.intentionMenu.text=转到类型签名
ruby.actions.goto.typeSignature.popupTitle=类型签名
ruby.actions.goto.typeSignature.error=无类型签名
action.Ruby.GotoAssociatedDeclaration.text=转到关联的声明
action.Ruby.GotoAssociatedDeclaration.MainMenu.text=关联的声明
ruby.actions.goto.associatedDeclaration.text=转到关联的声明
ruby.actions.goto.associatedDeclaration.shortText=关联的声明
ruby.actions.goto.associatedDeclaration.intentionMenu.text=转到关联的声明
ruby.actions.goto.associatedDeclaration.popupTitle=关联的声明
ruby.actions.goto.associatedDeclaration.error=无关联的声明
inspection.mismatched.type.incoercible.warning=无法将 ''{0}'' 和 ''{1}'' 强制转换为通用类型
checkbox.run.rubocop.on.document.save=保存时运行 `rubocop -a`
dialog.title.auto.correcting.with.rubocop=使用 RuboCop 自动更正
irb.run.configuration.default.script=使用内置可执行文件
ruby.parsing.too.complex.error=文件过于复杂，无法使用默认 JVM 设置进行解析。请考虑使用 -XSS 增加堆栈大小(例如，对于 10 兆字节的堆栈大小，使用 -Xss10M)。
annotation.error.unsupported.valueless.hash=对于哈希值省略，至少需要 Ruby 3.1
annotation.error.unsupported.pattern.matching.pin.expression=针对全局变量的模式匹配 pin 运算符至少需要 Ruby 3.1
parsing.pattern.matching.pin.operator.argument=标识符、实例/类/全局变量，或带括号的表达式
annotation.error.unsupported.pattern.matching.pin.instance.var=针对实例变量的模式匹配 pin 运算符至少需要 Ruby 3.1
annotation.error.unsupported.pattern.matching.pin.class.var=针对类变量的模式匹配 pin 运算符至少需要 Ruby 3.1
annotation.error.unsupported.pattern.matching.pin.global.var=针对全局变量的模式匹配 pin 运算符至少需要 Ruby 3.1
rails.spring.patching.title=修补 Binstubs
parsing.block.name=块实参名称
annotation.error.unexpected.anonymous.block=对于匿名块，至少需要 Ruby 3.1
annotation.error.missing.anonymous.block.parameter=未定义匿名块形参
pry.suggest.to.edit.pryrc=在 Windows 上运行 RubyMine 中的 Pry 之前，请将以下配置选项添加到您的 "{0}" 文件:\n\
\n\
Pry.config.input = STDIN\n\
\n\
如果此文件不存在，请先创建。\n\
谢谢!\n\

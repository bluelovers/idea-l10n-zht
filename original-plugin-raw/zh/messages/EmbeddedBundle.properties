action.CLionDebugTarget.OpenServices.popup.text=打开调试服务器控制台
action.CLionDebugTarget.OpenSettings.popup.text=打开调试服务器设置
action.CLionDebugTarget.Stop.popup.text=停止调试服务器
action.DebugTargets.ShowServiceAction.description=在“服务”工具窗口中显示此调试服务器
action.DebugTargets.ShowServiceAction.text=打开调试服务器控制台
action.add.to.live.watches.text=添加到实时监视
action.clion.embedded.execution.debugtargets.DebugTargetsComboboxAction.description=调试服务器
action.clion.embedded.execution.debugtargets.DebugTargetsComboboxAction.text=调试服务器
action.columns.text=列
action.com.intellij.clion.embedded.execution.debugtargets.live.EditorAddToLiveWatchesAction.text=添加到实时监视
action.com.intellij.clion.embedded.execution.wizard.GdbServerWizardAction.description=GDB 服务器配置向导
action.com.intellij.clion.embedded.execution.wizard.GdbServerWizardAction.text=新建嵌入式配置…
action.com.jetbrains.cidr.embedded.stm32cubemx.update.text=使用 STM32CubeMX 更新 CMake 项目
action.copy.cell.value.text=复制单元
action.copy.cells.values.text=复制列单元
action.copy.selection.to.clipboard.text=将选区复制到剪贴板
action.copy.table.to.clipboard.text=将表复制到剪贴板
action.export.history.text=在编辑器中显示历史记录
action.intellij.clion.embedded.mcu.reset.text=重置 MCU
action.intellij.clion.embedded.run.stm32cubemx.text=通过 STM32CubeMX 打开
action.live.watches.empty.text=添加实时监视…
border.title.connection=连接
build.configuration.executable=可执行的二进制文件
cell.no.data=无数据
checkbox.live.watches=实时监视
checkbox.start.monitor.after.upload=上传后启动监测
comment.download=<a href\="{0}">下载…</a>
compiler.implicit.include.not.found=找不到隐式 include 文件 {0}
compiler.run.failed=无法运行编译器\: {0} \n {1}
configurable.RtosSettingsConfigurable.display.name=RTOS 集成
connection.arguments.hint={0} 实参
console=控制台
console.rtt=RTT
console.semihosting=半托管
console.swo=SWO
cube.file.is.not.dir=不是目录
cube.file.is.not.file=不是文件
cube.file.is.not.found=文件不存在
cube.mx.editor.open=通过 STM32CubeMX 打开
cube.mx.editor.opened=在 STM32CubeMX 中打开
cube.mx.file.not.found=找不到文件
cube.mx.file.not.found.description=在项目目录 {1} 中找不到文件 {0}。\n请在 STM32CubeMX 中运行“Generate Code”
cube.mx.file.read.error=文件读取错误
cube.mx.file.read.error.description=无法在项目目录 {1} 中读取 {0}\n({2})
cube.mx.file.write.error=文件写入错误
cube.mx.invalid.file.content=无效文件内容
cube.mx.more.information.link=更多信息
cube.mx.open.external.editor=打开外部编辑器
cube.mx.project.sources.not.generated=没有生成项目源。在 STM32CubeMX 中运行 'GENERATE CODE'
cube.mx.project.sources.outdated=生成的源似乎已过时。在 STM32CubeMX 中运行 'GENERATE CODE'
cube.mx.project.updated=已更新 STM32CubeMX 项目
cube.mx.wrong.ide=选择了错误的目标 IDE。在“STM32CubeMX -> Project Manager”中将目标设置为 'CMake'
debug.server.generic.get.help.label=获取帮助(--help)
debug.server.generic.test.run.comment=运行 GDB 服务器并编辑命令行
debug.server.settings.advanced=高级
debug.server.terminated=调试服务器已终止\: {0}
debug.targets.configurable.tab.debugger=调试器
debug.targets.configurable.tab.gdbserver=GDB 服务器
debug.targets.configurable.tab.target=设备设置
debug.targets.edit.arguments.empty.text=GDB 服务器的命令行实参
debug.targets.edit.button.validate=测试运行(&T)…
debug.targets.edit.comment.disabled=此 GDB 服务器已被禁用
debug.targets.edit.debugger.extended.remote.hint=target extended-remote
debug.targets.edit.debugger.extended.remote.label=持久会话(&R)
debug.targets.edit.debugger.remote.hint=target remote
debug.targets.edit.dialog.title.gdbserver.working.directory=Gdbserver 工作目录
debug.targets.edit.label.arguments=实参(&R)\:
debug.targets.edit.label.console=控制台
debug.targets.edit.label.console.port=端口(&P)\:
debug.targets.edit.label.debugger=调试器\:
debug.targets.edit.label.debugger.environment.variables=环境变量(&E)\:
debug.targets.edit.label.debugger.work.dir=工作目录(&W)\:
debug.targets.edit.label.environment.variables=环境变量(&E)\:
debug.targets.edit.label.executable=可执行文件(&X)\:
debug.targets.edit.label.external=使用外部 GDB 服务器(&E)
debug.targets.edit.message.debugger.work.dir.not.found=调试器工作目录不存在
debug.targets.edit.message.gdb.server.not.found=找不到或无法执行 GDB 服务器
debug.targets.edit.title.debugger.working.directory=调试器工作目录
debug.targets.edit.title.gdbserver.executable=Gdbserver 可执行文件
debug.targets.gotit.debug=使用此按钮可以开始使用所选调试服务器进行调试。
debug.targets.gotit.debugger.services.header=MCU 控制台
debug.targets.gotit.debugger.services.text=在“服务”工具窗口中查看 MCU 控制台输出
debug.targets.gotit.run=使用此按钮可以将您的程序上传至开发板。
debug.targets.gotit.selector=此切换器允许您创建和选择调试服务器。例如，您可以为 J-Link 探针创建调试服务器。
debug.tooltip.esp32=在 ESP32 上调试 ''{0}''
debug.tooltip.generic=在 {1} 上调试 ''{0}''
debug.tooltip.jlink=将 ''{0}'' 调试至目标
debug.tooltip.stlink=在 ''{1}'' 上调试 ''{0}''
devices.dialog.search.textfield.empty.text=搜索
devices.dialog.search.tree.empty.text=找不到任何设备
devices.dialog.title=选择设备
dialog.message.cmake.not.loaded=CMake 项目未加载
dialog.message.cmake.profile.not.defined=CMake 配置文件未定义
dialog.message.debugger.not.defined=调试器未定义
dialog.message.device.not.found=找不到设备
dialog.message.device.not.selected=未选择设备
dialog.message.failed.to.parse.project.description.json=无法解析 project_description.json\: {0} - {1}
dialog.message.failed.to.read.project.description=无法从 project_description.json 中检索 `{0}`\: {1}
dialog.message.gdbserver.working.directory.not.found=Gdbserver 工作目录不存在
dialog.message.invalid.debugger.path=调试器路径无效
dialog.message.project.configuration.error={0} {1} 项目可能无法正常运行。
dialog.message.project_description.json.not.found=找不到文件\: project_description.json。请确保 ESP-IDF 项目正确
dialog.message.wrong.cmake.profile.name=CMake 配置文件名称错误
dialog.title.configure.gdb.server=新的嵌入式 GDB 服务器运行配置
dialog.title.segger.jlinkgdbserver=SEGGER J-Link GDB 服务器
disable.refresh.on.step=禁用逐步刷新
edit.configuration.action=运行/调试
embedded.display.name=嵌入式
embedded.gdb.server.description=使用第三方的 GDB 服务器上传并运行应用程序
embedded.gdb.server.title=嵌入式 GDB 服务器
enable.console=启用控制台
enable.refresh.on.step=启用逐步刷新
error.convert.generic.not.possible=转换失败\: 项目不是 ESP-IDF 项目，或其 CMake 设置无法解析。\n确保项目基于 ESP-IDF，并且 CMakeLists.txt 语法正确且可解析。
esp.idf=ESP-IDF
expected.gdbserver.name=预期名称\: {0}
export.livewatches.time.label=时间(秒)
export.name.embedded.development=嵌入式开发
export.name.embedded.gdbserver.wizard=嵌入式 GDB 服务器向导
file.cannot.be.executed=二进制文件无法执行
file.extension.not.found=找不到 .{0} 文件。
file.is.empty=文件名为空
file.is.not.valid.cube.executable=不是有效的 {0} 可执行文件
filetype.stm32cubemx.project.description=STM32CubeMX 项目
firmware.downloaded=已下载固件
format.binary=二进制
format.decimal=十进制
format.enum=符号
format.hex=十六进制
format.octal=八进制
freertos.heap.allocations.label=分配次数
freertos.heap.block.table.address.range.column=地址范围
freertos.heap.block.table.details.column=详细信息
freertos.heap.block.table.size.column=大小
freertos.heap.free.label=释放
freertos.heap.frees.label=释放计数
freertos.heap.info.not.available=堆信息仅对 HEAP_[2,4,5] 可用
freertos.heap.panel.name=FreeRTOS 堆
freertos.heap.table.address.range.column=地址范围
freertos.heap.type.label=类型
freertos.heap.usage.label=用法
freertos.integration.enabled=FreeRTOS 集成已启用
freertos.integration.not.full=缺少可选定义。某些功能可能不可用。
freertos.integration.sizeof.failed=无法检索 sizeof {0}
freertos.panel.name=FreeRTOS 对象
freertos.queue.data.table.address.column=地址
freertos.queue.data.table.data.dec.column=十进制数据
freertos.queue.data.table.number.column=顺序编号
freertos.queue.enable.text=添加 \#define configQUEUE_REGISTRY_SIZE > 0
freertos.queue.table.address.column=地址
freertos.queue.table.head.label=头
freertos.queue.table.length.column=长度
freertos.queue.table.name=队列数据
freertos.queue.table.name.column=名称
freertos.queue.table.read.from.label=读取自
freertos.queue.table.rx.column=RX
freertos.queue.table.size.column=条目大小
freertos.queue.table.tail.label=尾部
freertos.queue.table.tx.column=TX
freertos.queue.table.type.column=类型
freertos.queue.table.write.to.label=写入到
freertos.task.table.event.object.column=事件对象
freertos.task.table.handle.column=任务句柄
freertos.task.table.id.column=TCB №
freertos.task.table.name=任务数据
freertos.task.table.name.column=任务名称
freertos.task.table.priority.column=优先级
freertos.task.table.runtime.column=运行时
freertos.task.table.stack.end.label=堆栈结束
freertos.task.table.stack.hwmark.label=堆栈 HW 标记
freertos.task.table.stack.start.label=堆栈开始
freertos.task.table.stack.usage.column=堆栈使用情况
freertos.task.table.state.column=任务状态
freertos.timer.enable.text=添加 \#define configUSE_TIMERS 1
freertos.timer.table.handle.column=期间 [Ticks]
freertos.timer.table.id.column=ID
freertos.timer.table.name=定时器数据
freertos.timer.table.name.column=名称
freertos.timer.table.stack.usage.column=回调函数
freertos.timer.table.state.column=状态
gdb.parameters.panel.reset.command=重置命令
gdb.parameters.panel.reset.command.field=监视器重置
gdb.parameters.reset.type.after.download=上传后
gdb.parameters.reset.type.always=始终
gdb.parameters.reset.type.before.download=上传前
gdb.parameters.reset.type.never=从不
gdb.servers.wizard.devices.parse.error=无法从输入行解析设备\: {0}，可能是 GDB 服务器位置错误
gdb.servers.wizard.download.binary=上传二进制文件\:
gdb.servers.wizard.exception.occurred.while.executable.invoke=运行 {0} 时出现异常\:\n{1}
gdbserver.app.cannot.report.supported.devices=GDB 服务器 {0} 无法报告支持的设备列表。
gdbserver.cannot.report.supported.devices=GDB 服务器无法报告支持的设备列表。
gdbserver.progress=正在启动 GDB 服务器… {0}s
generic=泛型
ioc.file.not.found.comment=这可能不是 STM32CubeMX 项目。
jlink.device.dialog.button.tooltip=选择…
jlink.exitcode.m1.message=未知错误。
jlink.exitcode.m2.hint=检查端口 {0} 是否已被使用。
jlink.exitcode.m2.message=无法打开侦听器端口。
jlink.exitcode.m3.hint=未检测到目标电压或连接失败。\n请检查 J-Link 探针是否已连接到设备。
jlink.exitcode.m3.message=连接到目标失败。
jlink.exitcode.m4.hint=无法接受来自 GDB 的连接。
jlink.exitcode.m4.message=GDB 连接失败。
jlink.exitcode.m5.hint=无法解析命令行选项，命令行形参错误或缺失。
jlink.exitcode.m5.message=命令行选项不正确。
jlink.exitcode.m6.hint.empty=未选择设备。
jlink.exitcode.m6.hint.unknown=未知的设备名称“{0}”。
jlink.exitcode.m6.message=未知或没有设备名称。
jlink.exitcode.m7.hint=检查设备是否已连接到计算机。
jlink.exitcode.m7.message=J-Link 连接失败。
jlink.gdb.server.displayname=Segger JLink
label.device=设备\:
label.executable=可执行的二进制文件\:
label.gdb=调试器\:
label.gdb.server.type=GDB 服务器类型\:
label.gdbserver.port=GDB 服务器端口\:
label.initial.speed=初始速度\:
label.jlink.gdb.server=Segger J-Link
label.khz=kHz
label.live.watches.warning=通用调试服务器可能无法配合实时监视正常工作
label.location=位置\:
label.msec=毫秒
label.name.config=名称\:
label.pemicro=PE Micro Cyclone、Multilink 或 OpenSDA
label.port=端口\:
label.pyocd=PyOCD
label.qemu=QEMU 模拟器
label.reset.strategy=重置策略\:
label.sampling.period.ms.too.short.please.increase.period.or.remove.several.watches=采样周期({0} 毫秒)过短。请考虑增加采样周期或移除一些监视。
label.st.util.gdb.server=st-util
label.stlink.gdb.server=STM32CubeIDE ST-LINK GDB 服务器
label.swo.cpu.freq=CPU 频率\:
label.swo.freq=频率\:
label.swo.mask=掩码\:
label.target=目标\:
label.tcp.ip.port=TCP/IP 端口\:
label.transport.interface=传输接口\:
label.type.error=<错误>
label.uart=UART\:
label.unit.hz=Hz
label.unit.khz=kHz
link.label.edit=编辑…
live.watches.empty.text.1=观察全局变量和外设注册表值在一段时间内的变化，
live.watches.empty.text.2=而不停止调试进程。
livewatches.action.add.text=添加
livewatches.action.edit.text=编辑表达式
livewatches.action.pause.text=暂停
livewatches.action.remove.text=移除
livewatches.action.update.text=更新
livewatches.actiongroup.sampling.period.text=采样周期
livewatches.column.name.changes=更改
livewatches.column.name.max=最大值
livewatches.column.name.min=最小值
livewatches.column.name.type=类型
livewatches.column.name.value=值
livewatches.column.name.watch=监视
livewatches.format.default=默认
livewatches.period.1sec=1000 毫秒
livewatches.period.2sec=2000 毫秒
livewatches.period.500msec=500 毫秒
livewatches.period.custom=自定义…
livewatches.period.custom.set=自定义({0} 毫秒)…
livewatches.popup.separator.title=数据格式
livewatches.popup.title.add=添加到实时监视
livewatches.popup.title.edit=编辑实时监视表达式
livewatches.tab.title=实时监视
mcu.chip.detected=检测到芯片\: {0} (ARM {1})
mcu.communication.failure.detailed=MCU 通信故障。请检查您的<i>运行配置</i>
mcu.is.configured=已配置 {0}。
mcu.reset.type.HALT=停止
mcu.reset.type.INIT=初始化
mcu.reset.type.NONE=无
mcu.reset.type.RUN=运行
message.expected.name=预期名称为 {0}
message.read.error=读取错误({0}\: {1})
modal.progress.title.exporting=正在导出…
new.live.watches=新功能\: 实时监视
no.mcu.configured=未配置 MCU
non.readable=<Non-readable>
notification.group.embedded.development=嵌入式开发
openocd.assist.button=辅助…
openocd.board.config.file.label=面板配置文件\:
openocd.board.config.not.defined=未定义面板配置文件
openocd.download.label=下载\:
openocd.download.run.description=使用 OpenOCD 下载并运行嵌入式应用程序
openocd.download.run.title=OpenOCD 下载并运行
openocd.gdb.port.label=GDB 端口\:
openocd.invalid.run.file=运行文件 {0} 无效
openocd.is.not.valid.executable=不是有效的可执行文件
openocd.ports.should.be.different=端口值应不同
openocd.reset.label=重置\:
openocd.telnet.port.label=Telnet 端口\:
openocd.wrong.installation=OpenOCD 安装错误。找不到开发板配置文件夹。
pemicro.gdb.server.displayname=PE Micro (OpenSDA)
please.enter.port.number=请输入介于 {0} 到 {1} 之间的 TCP 端口号
please.enter.positive.number=请输入一个正数
popup.title.update.period=采样周期
port.number.auto=自动
progress.title.csv.export=CSV 导出…
progress.title.loading.devices=正在加载设备…
progress.title.looking.for.installed.utility=正在查找已安装的实用程序
pyocd.gdb.server.displayname=PyOCD
qemu.displayname=QEMU 模拟器
queue.data.text.double.click.to.see.more=… (双击查看更多内容)
radio.jtag=JTAG
radio.swd=SWD
read.more=阅读更多内容
reset.strategy.attach=附加
reset.strategy.default=默认
reset.strategy.halt=停止
reset.strategy.pre_reset=Pre-Reset
reset.strategy.under_reset=Init-Under-Reset
rtos.auto.display.name=自动
rtos.azure.display.name=Azure RTOS ThreadX
rtos.freertos.display.name=FreeRTOS
rtos.panel.selector.hint=需要支持 Python 的 GDB 7.4 或更高版本
rtos.panel.selector.label=启用 RTOS 集成
rtos.panel.threads.hint=如果您使用的调试服务器支持类似功能，则可能需要禁用此选项。
rtos.panel.threads.label=启用线程感知
rtos.zephyr.display.name=Zephyr
rtos.zephyr.integration.error=Zephyr 配置失败
rtos.zephyr.thread.monitor.missing=Define CONFIG_THREAD_MONITOR 未设置
rtos.zephyr.thread.name.missing=Define CONFIG_THREAD_NAME 未设置
run.configuration.name.is.taken=运行配置名称“{0}”已被占用
run.tooltip.esp32=监测 ESP32
run.tooltip.generic=将 ''{0}'' 上传到 {1}
run.tooltip.jlink=将 ''{0}'' 刷写至目标
run.tooltip.stlink=将 ''{0}'' 刷写到 ''{1}''
segger.jlink=SEGGER J-Link
select.board.dialog.copy.and.use.action=复制到项目并使用
select.board.dialog.overwrite.file=文件 {0} 已存在于项目中。是否覆盖?
select.board.dialog.overwrite.title=是否覆盖面板配置?
select.board.dialog.title=选择面板配置文件
separator.refresh.period=采样周期
set.openocd.location=请通过嵌入式开发设置对 OpenOCD 位置进行设置
set.sampling.period.x2=双倍采样周期
show.settings.action=设置
show.toolchains.action=工具链
skip.board.button=跳过
st.link.gdb.server.displayname=STM32CubeIDE ST-LINK GDB 服务器
st.link.gdbserver.not.found=找不到 ST-LINK_gdbserver
stlink.dialog.title.st.link.gdb.server.executable=ST-LINK GDB 服务器可执行文件
stlink.dialog.title.stm32cubeprogrammer.bin.directory=STM32CubeProgrammer bin 目录
stlink.exitcode.1.hint=已有程序连接到开发板，例如 STM32CubeProgrammer。
stlink.exitcode.1.message=端口已被占用。
stlink.exitcode.10.message=命令错误。
stlink.exitcode.11.message=应用程序重置错误。
stlink.exitcode.12.message=版本错误。
stlink.exitcode.13.message=获取状态错误。
stlink.exitcode.14.message=强制停止错误。
stlink.exitcode.16.hint=仅连接一个设备，或将此调试服务器转换为通用，然后使用 -i <S/N> 命令行实参手动指定序列号。
stlink.exitcode.16.message=多个开发板已连接。
stlink.exitcode.17.hint=找不到指定的序列号。
stlink.exitcode.17.message=ST-LINK 序列号不正确。
stlink.exitcode.18.message=无法验证供应商信息。
stlink.exitcode.2.hint=检查设备是否已连接到计算机。
stlink.exitcode.2.message=没有连接 ST-LINK。
stlink.exitcode.255.message=未知错误.
stlink.exitcode.3.message=USB 通信错误。
stlink.exitcode.4.hint=检查 ST-LINK 探针是否连接到设备。
stlink.exitcode.4.message=未连接 MCU。
stlink.exitcode.5.hint=未知 MCU 或无法建立 {0} 连接。请尝试将传输接口更改为 {1}。
stlink.exitcode.5.message=未知的 MCU 目标。
stlink.exitcode.6.hint=使用 STM32CubeCLT 中的 STLinkUpgrade 脚本或在 STM32CubeProgrammer GUI 中升级固件。
stlink.exitcode.6.message=旧版 ST-LINK 固件。
stlink.exitcode.7.message=重置错误。
stlink.exitcode.8.hint=设备上的重置按钮被按下。
stlink.exitcode.8.message=在重置状态下保持。
stlink.exitcode.9.message=目标无法停止。
stlink.gdb.server.tab.name=ST-LINK GDB 服务器
stlink.group.label.multicore=多核
stlink.group.label.swo=SWO
stlink.groupname=ST-LINK
stlink.label.apid=访问端口\:
stlink.label.halt=停止所有核心
stlink.label.programmer=程序员\:
stlink.label.reset.type=重置类型\:
stlink.label.shared=共享 ST-LINK
stlink.label.swo.clock.divider=SWO 时钟分频器\:
stlink.label.swo.cpu.frequency=CPU 频率\:
stlink.label.verify.flash.download=验证闪存下载
stlink.programmer.validation.warning.bin=预期目录名称为 {0}
stlink.programmer.validation.warning.exe=预期文件名名称为 {0}
stlink.reset.connect.under.reset=重置时连接
stlink.reset.strategy.core=核心
stlink.reset.strategy.hardware=硬件
stlink.reset.strategy.software=软件
stm32.cube.ide.wrong.executable=指定了错误的 STM32CubeIDE 可执行文件
stm32.cube.mx.is.not.found=STM32CubeMX 未找到
stm32.cube.mx.project.generation.failure=项目生成失败
stm32.cube.mx.project.wizard.button=继续
stm32.cube.mx.project.wizard.cmake.fail.text=无法从 {0} 导入。
stm32.cube.mx.project.wizard.cmake.fail.title=CMake 错误
stm32.cube.mx.project.wizard.html=<ol style\="margin-top\: 0;"><li>在 STM32CubeMX 中\:<ol type\="a"><li>在 <i>New Project</i> 面板中，点击 <i>ACCESS TO MCU SELECTOR</i>。您也可以选择 <i>ACCESS TO BOARD SELECTOR</i>。</li><li>选择您的 MCU 或开发板。</li><li>点击 <i>Start Project</i>。</li><li>在生成的设备配置窗口中，配置必要的外设和中间件。</li><li>导航到 <i>Project Manager</i> 标签页。</li><li>从 <i>Toolchain / IDE</i> 下拉菜单中选择 <i>CMake</i>。</li><li>在 <i>Project Name</i> 字段中输入您的项目的名称。</li><li>点击 <i>GENERATE CODE</i>。</li><li>使用键盘快捷键 <i>{0}</i> 从 <i>Toolchain Folder Location</i> 字段复制路径。</li></ol></li><li>在 CLion 中\:<ol type\="a"><li>在此对话框顶部的<i>位置</i>字段中输入您复制的路径。</li><li>点击<i>{1}</i>。</li></ol></li><li>您的 STM32CubeMX 项目现已创建完成。</li></ol>
stm32.cube.mx.project.wizard.notice=需要由 STM32CubeMX 生成一个 STM32CubeMX 项目。
stm32.cube.mx.project.wizard.open.failed.text=打开 STM32CubeMX 项目 ''{0}'' 失败。
stm32.cube.mx.project.wizard.open.failed.title=打开项目
stm32cubeclt=STM32CubeCLT
stm32cubeclt.not.detected=找不到 STM32CubeCLT。请确保您已安装兼容的工具链。
stm32cubemx=STM32CubeMX
stm32cubemx.is.not.found=STM32CubeMX 未找到或无效。
stm32cubemx.launch=启动 STM32CubeMX
stm32cubeprogrammer.not.found=找不到 STM32CubeProgrammer
stutil.displayname=st-util
svd.hide.node=隐藏 {0}
svd.load.file=加载 .svd 文件
svd.load.hardware.definitions.description=从 .svd 文件加载硬件定义
svd.no.registers.loaded=未加载注册说明。
svd.panel.configure.action=配置
svd.panel.export.csv.to.clipboard=作为 CSV 导出到剪贴板
svd.panel.open.csv.editor=作为 CSV 在编辑器中打开
svd.panel.peripherals=外设
svd.panel.refresh=刷新
svd.register.edit.action.text=编辑
svd.register.invalid.value=无效值
svd.register.not.suspended.error=只有在程序暂停时才能编辑寄存器值
svd.register.not.writable.error=此寄存器不可写
svd.register.write.already.pending.error=在将寄存器值写入内存之前，无法编辑寄存器值
svd.register.write.failed=<写入失败>
svd.registers.loading=正在加载寄存器描述…
svd.root.load.error=Svd 加载错误
svd.select.peripherals.filter=外设文件
svd.select.peripherals.to.show=选择要显示的外设
svd.table.copy.peripheral.address.action=复制地址
svd.table.copy.value.action.description=复制到剪贴板
svd.table.copy.value.action.title=复制值
svd.table.description.column=描述
svd.table.hide.node.action=隐藏
svd.table.name.column=名称
svd.table.value.column=值
svd.unload.action=卸载
svd.unload.action.description=卸载 .svd 文件
svd.write.only=<Write-Only>
target.device.is.not.selected=未选择目标设备
template.do.not.change=此文件从模板自动生成\! 请勿更改\!
text.uart.auto=自动
the.file.s.is.already.loaded=文件 {0} 已加载
tool.found=已找到
tool.location={0} 位置\:
tool.not.found=找不到
uart.comment=(例如 /dev/ttyS4 或 COM1)
unknown.binary=未知二进制文件
use.board.button=使用
validation.intl.characters=Stm32CubeMX 和 OpenOCD 在“项目位置”中不支持国际字符或空格。
validation.missing.cmake.file=找不到 {0}。请确保该项目是为 CMake 生成的。
validation.missing.directory=目录不存在。生成项目并在“位置”字段中输入其路径。
watch.global.variables.in.real.time.without.stopping.the.debug.process=在不停止调试进程的情况下实时监视全局变量
wrong.gdb.server.location=GDB 服务器位置错误

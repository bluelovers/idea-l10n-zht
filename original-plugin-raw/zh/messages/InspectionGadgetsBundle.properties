0.will.no.longer.be.overridable.by.1={0} 将不再可被 {1} 重写
absolute.alignment.in.user.interface.display.name=AWT/Swing 代码中的绝对对齐
absolute.alignment.in.user.interface.fix.family.name=替换为常量
absolute.alignment.in.user.interface.problem.descriptor=使用了绝对对齐常量 <code>{0}.\#ref</code> \#loc
abstract.class.extends.concrete.class.display.name=抽象类扩展具体类
abstract.class.extends.concrete.class.problem.descriptor=类 <code>\#ref</code> 被声明为 'abstract'，并扩展一个具体类 \#loc
abstract.class.naming.convention.element.description=抽象类
abstract.class.never.implemented.display.name=没有具体子类的抽象类
abstract.class.never.implemented.problem.descriptor=抽象类 <code>\#ref</code> 没有具体子类 \#loc
abstract.class.with.only.one.direct.inheritor.display.name=只有一个直接继承者的抽象类
abstract.class.with.only.one.direct.inheritor.problem.descriptor=只有一个直接继承者的抽象类 <code>\#ref</code> \#loc
abstract.class.without.abstract.methods.display.name=没有 'abstract' 方法的抽象类
abstract.class.without.abstract.methods.ignore.utility.class.option=忽略实用程序类
abstract.class.without.abstract.methods.problem.descriptor=类 <code>\#ref</code> 被声明为 'abstract'，并且没有 'abstract' 方法 \#loc
abstract.method.call.in.constructor.display.name=对象构造期间调用的 abstract 方法
abstract.method.call.in.constructor.problem.descriptor=对象构造期间调用 'abstract' 方法 <code>\#ref()</code> \#loc
abstract.method.overrides.abstract.method.display.name=abstract 方法重写 abstract 方法
abstract.method.overrides.abstract.method.ignore.different.javadoc.option=忽略 Javadoc 与其 super 方法不同的方法
abstract.method.overrides.abstract.method.problem.descriptor=abstract 方法 <code>\#ref()</code> 重写 abstract 方法 \#loc
abstract.method.overrides.abstract.method.remove.quickfix=移除冗余 abstract 方法声明
abstract.method.overrides.concrete.method.display.name=abstract 方法重写具体方法
abstract.method.overrides.concrete.method.problem.descriptor=abstract 方法 <code>\#ref()</code> 重写具体方法 \#loc
abstract.method.with.missing.implementations.display.name=缺少实现的 abstract 方法
abstract.method.with.missing.implementations.problem.descriptor=abstract 方法 <code>\#ref()</code> 未在每个子类中实现 \#loc
access.to.non.thread.safe.static.field.from.instance.class.chooser.title=选择非线程安全类
access.to.non.thread.safe.static.field.from.instance.display.name=非线程安全的 'static' 字段访问
access.to.non.thread.safe.static.field.from.instance.field.problem.descriptor=访问类型为 ''{0}'' 的非线程安全 static 字段 <code>\#ref</code> \#loc
access.to.non.thread.safe.static.field.from.instance.option.title=非线程安全类\:
access.to.static.field.locked.on.instance.display.name=访问实例数据上锁定的 'static' 字段
access.to.static.field.locked.on.instance.fix.name=忽略类型 ''{0}'' 的 static 字段
access.to.static.field.locked.on.instance.problem.descriptor=访问实例数据上锁定的 static 字段 <code>\#ref</code> \#loc
accessing.non.public.field.of.another.object.display.name=访问另一个对象的非 public 字段
accessing.non.public.field.of.another.object.problem.descriptor=直接访问另一个对象的非 public 字段 <code>\#ref</code> \#loc
add.0.to.ignore.if.annotated.by.list.quickfix=将 ''{0}'' 添加到“由以下对象注解时忽略”列表中
add.catch.section.fix.family.name=添加 'catch' 子句
add.read.write.object.methods.fix.family.name=添加始终抛出异常的 'readObject()' 和 'writeObject()' 方法
add.read.write.object.methods.fix.text=添加始终抛出异常的 'writeObject()' 方法
add.read.write.object.methods.fix.text2=添加始终抛出异常的 'readObject()' 方法
add.serialversionuidfield.quickfix=添加 'serialVersionUID' 字段
add.this.qualifier.quickfix=添加 'this' 限定符
add.throws.clause.fix.family.name=修复 'throws' 子句
all.levels.option=所有日志级别
allow.resource.to.be.opened.inside.a.try.block=允许在 'try' 块内打开资源
ambiguous.field.access.display.name=对继承字段的访问类似于对周围代码中元素的访问
ambiguous.field.access.hides.field.problem.descriptor=访问超类 ''{0}'' 中的 <code>\#ref</code> 字段类似于访问周围类中的字段 \#loc
ambiguous.field.access.hides.local.variable.problem.descriptor=访问超类 ''{0}'' 中的 <code>\#ref</code> 字段类似于访问局部变量 \#loc
ambiguous.field.access.hides.parameter.problem.descriptor=访问超类 ''{0}'' 中的 <code>\#ref</code> 字段类似于访问形参 \#loc
ambiguous.field.access.navigate.quickfix=导航到明显访问过的{0, choice, 1\#局部变量|2\#形参|3\#字段}
ambiguous.field.access.quickfix=将 'super' 限定符添加到字段访问
ambiguous.method.call.display.name=对继承方法的调用类似于对本地方法的调用
ambiguous.method.call.problem.descriptor=对来自超类 ''{0}'' 的方法 <code>\#ref()</code> 的调用类似于对来自类 ''{1}'' 的方法的调用 \#loc
ambiguous.method.call.quickfix=向方法调用中添加 'super' 限定符
annotation.class.display.name=注解接口
annotation.class.problem.descriptor=注解接口 <code>\#ref</code> \#loc
annotation.display.name=注解
annotation.naming.convention.element.description=注解接口
annotation.problem.descriptor=注解 <code>\#ref</code> \#loc
anonymous.class.field.hides.containing.method.variable.problem.descriptor=匿名类字段 <code>\#ref</code> 隐藏包含方法中的变量 \#loc
anonymous.class.parameter.hides.containing.method.variable.problem.descriptor=匿名类形参 <code>\#ref</code> 隐藏包含方法中的变量 \#loc
anonymous.class.variable.hides.containing.method.variable.display.name=匿名类变量隐藏包含方法中的变量
anonymous.class.variable.hides.containing.method.variable.problem.descriptor=匿名类局部变量 <code>\#ref</code> 隐藏包含方法中的变量 \#loc
anonymous.extends.concrete.collection.problem.descriptor=匿名类显式扩展 ''{0}'' \#loc
anonymous.extends.thread.problem.descriptor=匿名类直接扩展 'java.lang.Thread' \#loc
anonymous.extends.throwable.problem.descriptor=匿名类直接扩展 'java.lang.Throwable' \#loc
anonymous.inner.class.display.name=匿名类可被替换为内部类
anonymous.inner.class.problem.descriptor=匿名类 <code>\#ref</code> \#loc
anonymous.inner.class.with.too.many.methods.display.name=具有太多方法的匿名类
anonymous.inner.class.with.too.many.methods.problem.descriptor=具有太多方法的匿名类 (方法计数 \= {0}) \#loc
anonymous.inner.may.be.named.static.inner.class.display.name=匿名类可能是命名为 'static' 的内部类
anonymous.inner.may.be.named.static.inner.class.problem.descriptor=匿名类 <code>\#ref</code> 可能是命名为 'static' 的内部类 \#loc
anonymous.inner.may.be.named.static.inner.class.quickfix=转换为命名 'static' 内部类
any.method.may.close.resource.argument=任何方法都可能关闭作为实参传递的资源
array.allocation.zero.length.display.name=零长度数组分配
array.allocation.zero.length.problem.descriptor=零长度数组的分配 \#loc
array.can.be.replaced.with.enum.values=可以将数组替换为枚举值
array.can.be.replaced.with.enum.values.family.quickfix=将数组替换为 EnumType.values()
array.can.be.replaced.with.enum.values.quickfix=将数组替换为 {0}.values()
array.comparison.display.name=使用 '\=\=' 而不是 'Arrays.equals()' 进行数组比较
array.comparison.problem.descriptor=使用 <code>\#ref</code> 而不是 'Arrays.equals()' 来比较数组对象 \#loc
array.creation.without.new.keyword.family.quickfix=添加 'new' 表达式
array.creation.without.new.keyword.name=创建不带 'new' 表达式的数组
array.creation.without.new.keyword.quickfix=添加 ''new {0}''
array.equals.problem.descriptor=或许应当使用 ''{0}'' 完成数组比较''
array.hash.code.display.name=在数组上调用了 'hashCode()'
array.hash.code.fix.family.name=替换为 'Arrays.hashCode()' 调用
array.hash.code.problem.descriptor=数组上调用的 <code>\#ref()</code> 可能应当是 'Arrays.hashCode()' \#loc
array.hashcode.problem.descriptor=或许应当使用 ''{0}'' 完成数组哈希代码计算
array.length.in.loop.condition.display.name=循环条件下的 Array.length
array.length.in.loop.condition.problem.descriptor=检查循环条件下的数组 <code>\#ref</code> \#loc
array.objects.equals.display.name=对数组使用浅层方法或 'Objects' 方法
arrays.as.list.with.one.argument.problem.descriptor=仅使用一个实参调用 <code>\#ref()</code> \#loc
arrays.as.list.with.zero.arguments.problem.descriptor=调用 <code>\#ref()</code> 以创建空列表 \#loc
arrays.as.list.with.zero.or.one.argument.display.name='Arrays.asList()' 调用的实参过少
assert.can.be.if.quickfix=将 'assert' 替换为 'if' 语句
assert.keyword.is.considered.an.assertion='assert' 关键字被视为断言
assert.message.not.string.display.name='assert' 消息不是字符串
assert.message.not.string.only.warn.boolean.option=仅当 'assert' 消息为 'boolean' 或 'java.lang.Boolean' 时发出警告
assert.message.of.type.boolean.problem.descriptor=类型为 ''{0}'' 的 ''assert'' 消息 \#loc
assert.statement.display.name='assert' 语句
assert.with.side.effects.call.mutates.expression=调用 ''{0}()'' 会改变 ''{1}''
assert.with.side.effects.call.mutates.field=调用 ''{0}()'' 会改变字段 ''{1}''
assert.with.side.effects.call.performs.io=调用 ''{0}()'' 会执行输入/输出操作
assert.with.side.effects.display.name=具有副作用的 'assert' 语句
assert.with.side.effects.problem.descriptor=<code>\#ref</code> 具有副作用\: {0} \#loc
assert.without.message.problem.descriptor=没有消息的 <code>\#ref()</code> \#loc
assert.without.message.quick.fix.family.name=添加错误消息
assertion.can.be.if.name=断言可被替换为 'if' 语句
asserts.without.messages.display.name=断言上缺少消息
assignment.and.return.of.mutable.record.component={1} 记录组件的隐式{0, choice, 1\#赋值|2\#返回|3\#赋值和返回} <code>\#ref</code> \#loc
assignment.of.field.with.mutable.type.problem.descriptor=赋值给形参 <code>\#ref</code> 中的 {0} 字段 ''{1}'' \#loc
assignment.or.return.of.field.with.mutable.type.display.name=具有可变类型的字段的赋值或返回
assignment.replaceable.with.operator.assignment.display.name=赋值可被替换为运算符赋值
assignment.replaceable.with.operator.assignment.ignore.conditional.operators.option=忽略条件运算符
assignment.replaceable.with.operator.assignment.ignore.obscure.operators.option=忽略模糊的 ^ 和 % 运算符
assignment.replaceable.with.operator.assignment.problem.descriptor=<code>\#ref</code> 可以简化为 ''{0}'' \#loc
assignment.to.catch.block.parameter.display.name=赋值给 'catch' 块形参
assignment.to.catch.block.parameter.problem.descriptor=赋值给 'catch' 块形参 <code>\#ref</code> \#loc
assignment.to.for.loop.parameter.check.foreach.option=检查增强型 'for' 循环形参
assignment.to.for.loop.parameter.display.name=赋值给 'for' 循环形参
assignment.to.for.loop.parameter.problem.descriptor=赋值给 for 循环形参 <code>\#ref</code> \#loc
assignment.to.lambda.parameter.display.name=赋值给 lambda 形参
assignment.to.lambda.parameter.problem.descriptor=赋值给 lambda 形参 <code>\#ref</code> \#loc
assignment.to.method.parameter.display.name=赋值给方法形参
assignment.to.method.parameter.ignore.transformation.option=<html>如果赋值是原始形参的转换，则忽略</html>
assignment.to.method.parameter.problem.descriptor=赋值给方法形参 <code>\#ref</code> \#loc
assignment.to.null.display.name='null' 赋值
assignment.to.null.option=忽略对字段的赋值
assignment.to.null.problem.descriptor='null' 已赋值给变量 <code>\#ref</code> \#loc
assignment.to.static.field.from.instance.method.display.name=从实例上下文赋值给 static 字段
assignment.to.static.field.from.instance.method.problem.descriptor=从实例上下文赋值给 static 字段 <code>\#ref</code> \#loc
assignment.to.superclass.field.display.name=构造函数将值赋给在超类中定义的字段
assignment.to.superclass.field.problem.descriptor=赋值给在超类 ''{1}'' 中定义的字段 ''{0}'' \#loc
assignment.used.as.condition.display.name=用作条件的赋值
assignment.used.as.condition.problem.descriptor=赋值 <code>\#ref</code> 作为条件使用 \#loc
atomic.field.updater.issues.display.name='AtomicFieldUpdater' 声明不一致
atomic.field.updater.not.static.final.display.name='AtomicFieldUpdater' 字段未被声明为 'static final'
atomic.field.updater.not.static.final.problem.descriptor={0} 字段 <code>\#ref</code> 未被声明为 ''static final'' \#loc
auto.boxing.display.name=自动装箱
auto.boxing.ignore.added.to.collection.option=忽略添加到集合的表达式
auto.boxing.make.boxing.explicit.quickfix=使装箱显式
auto.boxing.problem.descriptor=自动装箱 <code>\#ref</code> \#loc
auto.closeable.resource.display.name=在没有 'try-with-resources' 的情况下使用 AutoCloseable
auto.closeable.resource.problem.descriptor=在没有 ''try-with-resources'' 语句的情况下使用 ''{0}'' \#loc
auto.closeable.resource.quickfix=忽略此方法返回的 'AutoCloseable'
auto.closeable.resource.quickfix.preview=将方法 <code>{0}</code> 添加到忽略方法列表中
auto.closeable.resource.returned.option=忽略从所有方法调用返回的 AutoCloseable 实例
auto.unboxing.display.name=自动拆箱
auto.unboxing.make.unboxing.explicit.quickfix=使拆箱显式
auto.unboxing.problem.descriptor=自动拆箱 <code>\#ref</code> \#loc
await.not.in.loop.display.name=未在循环中调用的 'await()'
await.not.in.loop.problem.descriptor=<code>\#ref()</code> 调用不在循环中 \#loc
await.without.corresponding.signal.display.name=没有相应 'signal()' 的 'await()'
await.without.corresponding.signal.problem.descriptor=在没有相应 <code>signal()</code> 或 <code>signalAll()</code> 的情况下调用 <code>\#ref()</code> \#loc
bad.exception.caught.display.name=已捕获禁止的 'Exception'
bad.exception.caught.problem.descriptor=已捕获禁止异常 <code>\#ref</code> \#loc
bad.exception.declared.display.name=已声明禁止异常
bad.exception.declared.problem.descriptor=已声明禁止异常 <code>\#ref</code> \#loc
bad.exception.thrown.display.name=已抛出禁止异常
bad.exception.thrown.problem.descriptor=已抛出禁止异常 ''{0}'' \#loc
bad.oddness.display.name=可疑的奇数检查
bad.oddness.problem.descriptor=对负值进行奇数检查将会失败 \#loc
big.decimal.equals.display.name=在 'BigDecimal' 上调用了 'equals()'
big.decimal.equals.problem.descriptor=BigDecimal 值之间的 <code>\#ref()</code> 可能应当是 'compareTo()' \#loc
big.decimal.method.without.rounding.called.display.name='BigDecimal' 方法调用没有舍入模式实参
big.decimal.method.without.rounding.called.problem.descriptor=在没有舍入模式实参的情况下调用了 'BigDecimal.\#ref()'
bigdecimal.legacy.method.display.name=调用了 'BigDecimal' 遗留方法
bigdecimal.legacy.method.problem.descriptor=对 'BigDecimal.\#ref()' 的调用可以使用 'RoundingMode' 枚举常量
bigdecimal.legacy.method.quickfix=使用 'RoundingMode' 枚举常量
boolean.constructor.display.name=布尔构造函数调用
boolean.constructor.problem.descriptor=布尔构造函数调用 \#loc
boolean.constructor.simplify.quickfix=简化
boolean.expression.can.be.simplified.problem.descriptor=<code>\#ref</code> 可以简化为 ''{0}'' \#loc
boolean.expression.does.not.modify.problem.descriptor=<code>\#ref</code> 未修改 ''{0}'' 的值 \#loc
boolean.expression.may.be.conditional.display.name=布尔表达式可被替换为条件表达式
boolean.expression.remove.compound.assignment.quickfix=移除无意义的复合赋值
boolean.field.always.inverted.problem.descriptor=布尔字段 <code>\#ref</code> 始终反转 \#loc
boolean.method.name.must.start.with.question.display.name=布尔方法名称必须以疑问词开头
boolean.method.name.must.start.with.question.problem.descriptor=布尔方法名称 <code>\#ref</code> 未以疑问词开头 \#loc
boolean.method.name.must.start.with.question.table.label=布尔方法名称前缀\:
boolean.parameter.constructor.problem.descriptor='public' 构造函数 <code>\#ref()</code> 具有 'boolean' 形参 \#loc
boolean.parameter.display.name='public' 方法具有 'boolean' 形参
boolean.parameter.only.report.multiple.option=仅报告具有多个布尔形参的方法
boolean.parameter.problem.descriptor='public' 方法 <code>\#ref()</code> 具有 'boolean' 形参 \#loc
boolean.parameters.constructor.problem.descriptor='public' 构造函数 <code>\#ref()</code> 具有 'boolean' 形参 \#loc
boolean.parameters.problem.descriptor='public' 方法 <code>\#ref()</code> 具有 'boolean' 形参 \#loc
boolean.variable.always.inverted.display.name=布尔变量始终反转
boolean.variable.always.inverted.problem.descriptor=布尔变量 <code>\#ref</code> 始终反转 \#loc
bounded.wildcard.contravariant.descriptor=可以泛化为 <code>? super \#ref</code> \#loc
bounded.wildcard.covariant.descriptor=可以泛化为 <code>? extends \#ref</code> \#loc
bounded.wildcard.display.name=可以使用有界通配符
bounded.wildcard.report.instance.option=报告实例方法
bounded.wildcard.report.invariant.option=报告固定类
bounded.wildcard.report.private.option=报告 private 方法
boxing.boxed.value.display.name=装箱已装箱的值
boxing.boxed.value.problem.descriptor=装箱已装箱的 <code>\#ref</code> \#loc
boxing.boxed.value.quickfix=移除不必要的装箱
break.statement.display.name='break' 语句
break.statement.with.label.display.name=带标签的 'break' 语句
break.statement.with.label.problem.descriptor=带标签的 <code>\#ref</code> 语句 \#loc
busy.wait.display.name=忙等待
busy.wait.problem.descriptor=在循环中调用 <code>Thread.\#ref()</code>，可能处于忙等待 \#loc
c.style.array.declaration.display.name=C 样式数组声明
c.style.array.declaration.replace.quickfix=替换为 Java 样式数组声明
cached.number.constructor.call.display.name=数字构造函数调用具有基元实参
cached.number.constructor.call.ignore.string.arguments.option=忽略具有字符串实参的新数字表达式
cached.number.constructor.call.problem.descriptor=数字构造函数调用具有基元实参 \#loc
cached.number.constructor.call.report.only.deprecated=仅在构造函数为 @Deprecated 时报告
call.to.date.tostring.display.name=调用 'Date.toString()'
call.to.date.tostring.problem.descriptor=国际化上下文中使用的 <code>Date.\#ref()</code> \#loc
call.to.native.method.while.locked.display.name=锁定时调用 'native' 方法
call.to.native.method.while.locked.problem.descriptor=在同步上下文中调用本地方法 <code>\#ref()</code> \#loc
call.to.numeric.tostring.display.name=调用 'Number.toString()'
call.to.numeric.tostring.problem.descriptor=国际化上下文中调用的 <code>Number.\#ref()</code> \#loc
call.to.private.setter.in.class.option=仅在 setter 为 'private' 时报告
call.to.private.simple.getter.in.class.option=仅在 getter 为 'private' 时报告
call.to.simple.getter.in.class.display.name=从类内调用简单 getter
call.to.simple.getter.in.class.ignore.option=忽略其他对象上的 getter 调用
call.to.simple.getter.in.class.inline.quickfix=内联调用 getter
call.to.simple.getter.in.class.problem.descriptor=从类内调用简单 getter <code>\#ref()</code> \#loc
call.to.simple.setter.in.class.display.name=从类内调用简单 setter
call.to.simple.setter.in.class.ignore.option=忽略其他对象上的 setter 调用
call.to.simple.setter.in.class.inline.quickfix=内联调用 setter
call.to.simple.setter.in.class.problem.descriptor=从类内调用简单 setter <code>\#ref()</code> \#loc
call.to.string.concat.can.be.replaced.by.operator.display.name=对 'String.concat()' 的调用可被替换为 '+'
call.to.string.concat.can.be.replaced.by.operator.problem.descriptor=对 <code>\#ref()</code> 的调用可被替换为 '+' 表达式 \#loc
call.to.string.concat.can.be.replaced.by.operator.quickfix=用 '+' 替换 'concat()'
call.to.suspicious.string.method.display.name=调用可疑的 'String' 方法
call.to.suspicious.string.method.problem.descriptor=国际化上下文中调用的 <code>String.\#ref()</code> \#loc
cast.conflicts.with.instanceof.display.name=转换与 'instanceof' 冲突
cast.conflicts.with.instanceof.problem.descriptor=转换为 ''{0}'' 类型将与前面的 ''instanceof {1}'' 检查冲突
cast.conflicts.with.instanceof.quickfix1=在转换中将 ''{0}'' 替换为 ''{1}''
cast.conflicts.with.instanceof.quickfix2=在 instanceof 中将 ''{0}'' 替换为 ''{1}''
cast.that.loses.precision.display.name=损失精度的数字转换
cast.that.loses.precision.negative.problem.descriptor=''{0}'' 到 <code>\#ref</code> 的转换可能导致负实参的精度损失 \#loc
cast.that.loses.precision.option=忽略从 int 到 char 的转换
cast.that.loses.precision.problem.descriptor=''{0}'' 到 <code>\#ref</code> 的转换可能导致精度损失 \#loc
cast.to.concrete.class.problem.descriptor=转换为具体类 <code>{0}</code> \#loc
casting.to.incompatible.interface.display.name=转换为不兼容的类型
casting.to.incompatible.interface.problem.descriptor=将类型为 ''{1}'' 的表达式转换为不兼容的{0, choice, 1\#接口|2\#类} <code>\#ref</code> \#loc
caught.exception.immediately.rethrown.display.name=捕获的异常被立即重新抛出
caught.exception.immediately.rethrown.problem.descriptor=捕获的异常 <code>\#ref</code> 被立即重新抛出 \#loc
chain.of.class.equality.checks.problem.descriptor=类相等检查链指示抽象失败 \#loc
chain.of.instanceof.checks.display.name='instanceof' 检查链
chain.of.instanceof.checks.problem.descriptor='instanceof' 检查链指示抽象失败 \#loc
chained.equality.comparisons.display.name=链式相等比较
chained.equality.comparisons.problem.descriptor=链式相等比较 <code>\#ref</code> \#loc
chained.method.call.display.name=链式方法调用
chained.method.call.ignore.option=忽略字段初始值设定项中的链式方法调用
chained.method.call.ignore.self.types.option=忽略对返回类型与其封闭类相同的方法的调用
chained.method.call.problem.descriptor=链式方法调用 <code>\#ref()</code> \#loc
change.modifier.fix.family.name=更改修饰符
change.modifier.package.private.quickfix=设为 package-private
change.modifier.quickfix=设为 ''{0}''
channel.opened.not.closed.display.name=打开了 'Channel'，但未安全关闭
char.used.in.arithmetic.content.cast.fix.family.name=插入转换
char.used.in.arithmetic.context.cast.quickfix=插入到 {0} 的转换
char.used.in.arithmetic.context.display.name=在算术上下文中使用 'char' 表达式
char.used.in.arithmetic.context.problem.descriptor=算术上下文中使用了 'char' \#loc
char.used.in.arithmetic.context.quickfix=转换为字符串字面量
character.comparison.display.name=字符比较
character.comparison.problem.descriptor=国际化上下文中的字符比较 <code>\#ref</code> \#loc
checkbox.ignore.null.on.wrong.side=忽略错误侧的 'null'
checked.exception.class.display.name=已检查的异常类
checked.exception.class.problem.descriptor=已检查的异常类 <code>\#ref</code> \#loc
choose.autocloseable.type.to.ignore.title=选择要忽略的 AutoCloseable 资源类型
choose.class=选择类
choose.class.hierarchy.to.ignore.title=选择要忽略的类层次结构
choose.class.type.to.ignore=选择要忽略的类
choose.exception.class=选择异常类
choose.exception.label=被禁止的异常\:
choose.io.resource.type.to.ignore=选择要忽略的 I/O 资源类型
choose.logger.class=选择记录器类
class.escapes.defined.scope.display.module.option=报告在模块 API 中公开的非导出类(Java 9+)
class.escapes.defined.scope.display.name=类在其可见性作用域之外公开
class.escapes.defined.scope.display.package.option=报告在 package-local API 中公开的 private 类
class.escapes.defined.scope.display.public.option=报告在公开 API 中公开的不可访问类
class.escapes.defined.scope.java9.modules.descriptor=类 <code>\#ref</code> 未从模块 ''{0}'' 导出
class.escapes.defined.scope.problem.descriptor=类 <code>\#ref</code> 在其定义的可见性作用域之外公开 \#loc
class.extends.utility.class.display.name=类扩展实用程序类
class.extends.utility.class.ignore.utility.class.option=如果重写类为实用程序类，则忽略
class.extends.utility.class.problem.descriptor=类 <code>\#ref</code> 扩展实用程序类 ''{0}'' \#loc
class.independent.of.module.display.name=独立于其模块的类
class.independent.of.module.problem.descriptor=类 <code>\#ref</code> 在其模块中没有依赖或依赖项 \#loc
class.initializer.display.name=非 'static' 初始值设定项
class.initializer.may.be.static.display.name=实例初始值设定项可以设为 'static'
class.initializer.may.be.static.problem.descriptor=类初始值设定项可能为 'static' \#loc
class.initializer.move.code.to.constructor.quickfix=将初始值设定项代码移至构造函数
class.initializer.option=仅在类具有一个或多个构造函数时警告
class.initializer.problem.descriptor=非 'static' 初始值设定项 \#loc
class.loader.instantiation.display.name='ClassLoader' 实例化
class.loader.instantiation.problem.descriptor=实例化 <code>\#ref</code> 可能造成安全问题 \#loc
class.may.be.interface.convert.quickfix=将类转换为接口
class.may.be.interface.display.name='abstract' 类可以是 'interface'
class.may.be.interface.java8.option=使用 Java 8 时报告包含非 abstract 方法的类
class.may.be.interface.problem.descriptor=抽象类 <code>\#ref</code> 可能是接口 \#loc
class.name=类名
class.name.differs.from.file.name.display.name=类名与文件名不同
class.name.differs.from.file.name.problem.descriptor=类名 <code>\#ref</code> 与文件名不同 \#loc
class.name.prefixed.with.package.name.display.name=使用软件包名称作为前缀的类名
class.name.prefixed.with.package.name.problem.descriptor=类名 <code>\#ref</code> 以其软件包名称开始 \#loc
class.name.same.as.ancestor.name.display.name=类名与上级名称相同
class.name.same.as.ancestor.name.problem.descriptor=类名 <code>\#ref</code> 与其超类的名称之一相同 \#loc
class.naming.convention.display.name=类命名约定
class.naming.convention.element.description=类
class.new.instance.display.name=对 'Class.newInstance()' 的调用不安全
class.new.instance.problem.descriptor=对 <code>\#ref()</code> 的调用可能会抛出未声明的已检查的异常 \#loc
class.only.used.in.one.module.display.name=仅在其他模块中使用的类
class.only.used.in.one.module.problem.descriptor=类 <code>\#ref</code> 在其模块 ''{0}'' 中只有依赖和/或依赖性 \#loc
class.only.used.in.one.package.display.name=仅在其他软件包中使用的类
class.only.used.in.one.package.problem.descriptor=类 <code>\#ref</code> 在其软件包 ''{0}'' 中只有依赖和/或依赖项 \#loc
class.references.subclass.display.name=类引用其子类之一
class.references.subclass.problem.descriptor=类 ''{0}'' 引用子类 <code>\#ref</code> \#loc
class.references.subclass.problem.descriptor.anonymous=匿名类引用子类 <code>\#ref</code> \#loc
class.too.deep.display.name=类在继承树中太深
class.too.deep.inheritance.depth.limit.option=继承深度限制\:
class.too.deep.problem.descriptor=<code>\#ref</code> 在继承树中太深 (继承深度 \= {0}) \#loc
class.unconnected.to.package.display.name=独立于其软件包的类
class.unconnected.to.package.problem.descriptor=类 <code>\#ref</code> 在其软件包中没有依赖或依赖项
class.with.only.private.constructors.display.name=仅包含 'private' 构造函数的类应被声明为 'final'
class.with.only.private.constructors.problem.descriptor=仅包含 'private' 构造函数的类 <code>\#ref</code> 应被声明为 'final'
class.with.too.many.dependencies.display.name=依赖过多的类
class.with.too.many.dependencies.max.option=最大依赖项数
class.with.too.many.dependencies.problem.descriptor=类 ''{0}'' 的依赖过多 ({1} > {2})
class.with.too.many.dependents.display.name=依赖项过多的类
class.with.too.many.dependents.max.option=最大依赖项数
class.with.too.many.dependents.problem.descriptor=类 ''{0}'' 的依赖项过多 ({1} > {2})
class.with.too.many.transitive.dependencies.display.name=可传递依赖项过多的类
class.with.too.many.transitive.dependencies.max.option=最大可传递依赖项数
class.with.too.many.transitive.dependencies.problem.descriptor=类 ''{0}'' 的可传递依赖项过多({1} > {2})
class.with.too.many.transitive.dependents.display.name=传递依赖项过多的类
class.with.too.many.transitive.dependents.max.option=最大传递依赖项数
class.with.too.many.transitive.dependents.problem.descriptor=类 ''{0}'' 的可传递依赖项过多({1} > {2})
class.without.constructor.create.quickfix=生成空构造函数
class.without.constructor.display.name=不带构造函数的类
class.without.constructor.problem.descriptor=类 <code>\#ref</code> 没有构造函数 \#loc
class.without.logger.annotations.tab=注解
class.without.logger.loggers.tab=记录器
class.without.no.arg.constructor.display.name=没有无实参构造函数的类
class.without.no.arg.constructor.ignore.option=如果类具有默认构造函数，则忽略
class.without.no.arg.constructor.problem.descriptor=类 <code>\#ref</code> 缺少无实参构造函数 \#loc
clone.doesnt.declare.clonenotsupportedexception.declare.quickfix=将 'CloneNotSupportedException' 添加到 throws 子句
clone.doesnt.declare.clonenotsupportedexception.display.name='clone()' 未声明 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.problem.descriptor=<code>\#ref()</code> \#loc 未声明 'CloneNotSupportedException'
clone.instantiates.new.array.problem.descriptor=''clone()'' 创建新的 {0} 数组 \#loc
clone.instantiates.objects.with.constructor.display.name='clone()' 用构造函数实例化对象
clone.instantiates.objects.with.constructor.problem.descriptor='clone()' 创建新的 <code>\#ref</code> 实例 \#loc
clone.method.in.non.cloneable.anonymous.class.problem.descriptor=<code>\#ref()</code> 在派生自 ''{0}'' 的不可克隆匿名类中定义 \#loc
clone.method.in.non.cloneable.class.display.name=不可克隆类中的 'clone()' 方法
clone.method.in.non.cloneable.class.problem.descriptor=<code>\#ref()</code> 在不可克隆类 ''{0}'' 中定义 \#loc
clone.method.in.non.cloneable.interface.problem.descriptor=<code>\#ref()</code> 在不可克隆接口 ''{0}'' 中定义 \#loc
clone.returns.class.type.display.name='clone()' 应当具有等于其所包含类的返回值类型
clone.returns.class.type.family.quickfix=将返回值类型更改为类类型
clone.returns.class.type.problem.descriptor=''clone()'' 应当具有返回值类型 ''{0}'' \#loc
clone.returns.class.type.quickfix=将返回值类型更改为 ''{0}''
cloneable.class.in.secure.context.display.name=安全上下文中的可克隆类
cloneable.class.in.secure.context.problem.descriptor=类 <code>\#ref</code> 可能被克隆，影响安全性 \#loc
cloneable.class.in.secure.context.quickfix=生成始终抛出异常的 'clone()' 方法
cloneable.class.without.clone.display.name=没有 'clone()' 方法的可克隆类
cloneable.class.without.clone.ignore.option=忽略由于继承而可克隆的类
cloneable.class.without.clone.ignore.when.clone.called.option=如果调用超类的 clone() 方法需要 Cloneable，则忽略
cloneable.class.without.clone.problem.descriptor=<code>\#ref</code> 为 'Cloneable'，但未定义 'clone()' 方法 \#loc
cloneable.class.without.clone.quickfix=生成 'clone()' 方法
cloneable.class.without.clone.todo.message=TODO\: 复制此处的可变状态，这样此克隆就不能更改初始克隆的内部项
collection.added.to.self.display.name=集合已添加到自身
collection.added.to.self.problem.descriptor=在以自身作为实参的集合 <code>\#ref</code> 上调用了 ''{0}()'' \#loc
collection.declared.by.class.display.name=按类 (而不是接口) 声明的集合
collection.declared.by.class.ignore.locals.option=忽略局部变量
collection.declared.by.class.ignore.private.members.option=忽略 'private' 字段和方法
collection.declared.by.class.problem.descriptor=<code>\#ref</code> 的声明可能应当被削弱为 ''{0}'' \#loc
collections.field.access.replaceable.by.method.call.display.name=对空集合字段的引用可被替换为方法调用
collections.field.access.replaceable.by.method.call.fix.family.name=将 Collections.EMPTY_* 替换为调用
collections.field.access.replaceable.by.method.call.problem.descriptor=<code>\#ref</code> 可被替换为 ''Collections.{0}'' \#loc
collections.must.have.initial.capacity.display.name=没有初始容量的集合
collections.must.have.initial.capacity.problem.descriptor=没有初始容量的 <code>new \#ref()</code> \#loc
commented.out.code.delete.quickfix=删除注释
commented.out.code.uncomment.quickfix=撤消代码注释
comments.as.content.option=注释计为内容
comparable.implemented.but.equals.not.overridden.display.name=已实现 'Comparable'，但 'equals()' 未被重写
comparable.implemented.but.equals.not.overridden.fix.add.note.name=添加 'ordering inconsistent with equals' JavaDoc 记录
comparable.implemented.but.equals.not.overridden.fix.generate.equals.name=生成 'equals()' 方法
comparable.implemented.but.equals.not.overridden.problem.descriptor=类 <code>\#ref</code> 实现 'java.lang.Comparable'，但未重写 'equals()' \#loc
comparator.not.serializable.display.name='Comparator' 类未被声明为 'Serializable'
comparator.not.serializable.problem.descriptor=比较器类 <code>\#ref</code> 未被声明为可序列化 \#loc
comparison.of.short.and.char.display.name=比较 'short' 和 'char' 值
comparison.of.short.and.char.problem.descriptor=short 和 char 值的相等比较 <code>\#ref</code> \#loc
comparison.to.nan.display.name=与 'Double.NaN' 或 'Float.NaN' 比较
comparison.to.nan.problem.descriptor1=与 <code>\#ref</code> 的比较始终为 false \#loc
comparison.to.nan.problem.descriptor2=与 <code>\#ref</code> 的比较始终为 true \#loc
concrete.class.method.parameter.problem.descriptor=具体类 <code>\#ref</code> 的形参 ''{0}'' \#loc
concrete.class.use.display.name=具体类的使用
condition.signal.display.name=调用 'signal()' 而不是 'signalAll()'
condition.signal.problem.descriptor=<code>\#ref</code> 可能应当替换为 'signalAll()' \#loc
conditional.can.be.pushed.inside.expression.display.name=可以将条件推送到分支表达式内部
conditional.can.be.pushed.inside.expression.option=在条件将仅作为方法调用的实参时忽略
conditional.can.be.pushed.inside.expression.problem.descriptor=条件表达式可以推送到分支内 \#loc
conditional.can.be.pushed.inside.expression.quickfix=在分支内推送条件表达式
conditional.expression.display.name=条件表达式
conditional.expression.expression.context.option=忽略无法使用 if 语句的位置
conditional.expression.option=对简单赋值和返回值忽略
conditional.expression.problem.descriptor=条件表达式 <code>\#ref</code> \#loc
conditional.expression.quickfix=替换为 'if' 语句
conditional.expression.with.identical.branches.collapse.quickfix=收起条件表达式
conditional.expression.with.identical.branches.display.name=具有相同分支的条件表达式
conditional.expression.with.identical.branches.problem.descriptor=具有相同分支的条件表达式 <code>\#ref</code> \#loc
confusing.else.option=当 'if' 语句之后没有其他语句时报告
confusing.floating.point.literal.change.quickfix=更改为规范形式
confusing.floating.point.literal.display.name=引起混淆的浮点字面量
confusing.floating.point.literal.option=在科学记数法中忽略浮点字面量
confusing.floating.point.literal.problem.descriptor=引起混淆的浮点字面量 <code>\#ref</code> \#loc
confusing.main.method.display.name=引起混淆的 'main()' 方法
confusing.main.method.problem.descriptor=方法 <code>\#ref</code> 没有签名 'public static void main(String[])' \#loc
confusing.octal.escape.sequence.display.name=引起混淆的八进制转义序列
confusing.octal.escape.sequence.problem.descriptor=八进制转义序列 <code>\#ref</code> 后面紧跟数字 \#loc
connection.opened.not.safely.closed.display.name=集合已打开，但未安全关闭
consider.static.final.fields.constant.option=考虑 'static final' 字段常量
constant.assert.condition.display.name='assert' 语句中的常量条件
constant.assert.condition.problem.descriptor=断言条件 <code>\#ref</code> 是常量 \#loc
constant.conditional.expression.display.name=常量条件表达式
constant.conditional.expression.problem.descriptor=<code>\#ref</code> 可以简化为 ''{0}'' \#loc
constant.conditional.expression.simplify.quickfix=简化
constant.conditional.expression.simplify.quickfix.sideEffect=提取副作用并简化
constant.declared.in.abstract.class.display.name=在 'abstract' 类中声明的常量
constant.declared.in.abstract.class.problem.descriptor=常量 <code>\#ref</code> 在抽象类中声明 \#loc
constant.declared.in.interface.display.name=在接口中声明的常量
constant.declared.in.interface.problem.descriptor=常量 <code>\#ref</code> 在接口中声明 \#loc
constant.for.zero.length.array.display.name=不必要的零长度数组用法
constant.for.zero.length.array.problem.descriptor=零长度数组可更改为常量 \#loc
constant.for.zero.length.array.quickfix.family=替换为常量
constant.junit.assert.argument.display.name=常量断言实参
constant.junit.assert.argument.problem.descriptor=实参 <code>\#ref</code> 是常量 \#loc
constant.math.call.display.name=对 'Math' 的常量调用
constant.math.call.problem.descriptor=对 <code>\#ref()</code> 的常量调用可以简化 \#loc
constant.naming.convention.element.description=常量
constant.on.lhs.of.comparison.options.item.left=左
constant.on.lhs.of.comparison.options.item.right=右
constant.on.lhs.of.comparison.problem.descriptor=常量 <code>\#ref</code> 位于比较的左侧 \#loc
constant.on.rhs.of.comparison.problem.descriptor=常量 <code>\#ref</code> 位于比较的右侧 \#loc
constant.on.side.of.comparison.display.name=常量位于比较的错误一侧
constant.value.variable.use.display.name=使用已知值为常量的变量
constant.value.variable.use.problem.descriptor=<code>\#ref</code> 的值已知为常量 \#loc
constant.with.mutable.field.naming.convention.element.description=具有可变类型的常量
constructor.visibility.option=忽略具有以下可见性的构造函数\:
continue.or.break.from.finally.block.display.name='continue' 或 'break' 位于 'finally' 块内
continue.or.break.from.finally.block.problem.descriptor=<code>\#ref</code> 位于 'finally' 块内 \#loc
continue.statement.display.name='continue' 语句
continue.statement.with.label.display.name=带标签的 'continue' 语句
continue.statement.with.label.problem.descriptor=带标签的 <code>\#ref</code> 语句 \#loc
control.flow.statement.without.braces.add.quickfix=将大括号添加到语句
control.flow.statement.without.braces.display.name=不带大括号的控制流语句
control.flow.statement.without.braces.message=将大括号添加到 ''{0}'' 语句
control.flow.statement.without.braces.problem.descriptor=不带大括号的 <code>{0}</code> \#loc
convert.double.unary.quickfix=替换为 ''{0}{1}''
convert.empty.anonymous.to.new.fix.family.name=移除 '{}'
convert.octal.literal.to.decimal.literal.quickfix=将八进制字面量转换为十进制字面量
convert.octal.literals.to.decimal.literals.quickfix=将八进制字面量转换为十进制字面量
convert.system.out.to.log.call.family.name=将 'System.out' 调用转换为日志调用
convert.system.out.to.log.call.name=将 ''System.out'' 调用转换为对 ''{0}'' 的调用
convert.to.variable.arity.method.quickfix=转换为 vararg 方法
copy.constructor.misses.field.display.name=复制缺少字段的构造函数
copy.constructor.misses.field.problem.descriptor.1=复制未复制字段 ''{0}'' 的构造函数
copy.constructor.misses.field.problem.descriptor.2=复制未复制字段 ''{0}'' 和 ''{1}'' 的构造函数
copy.constructor.misses.field.problem.descriptor.3=复制未复制字段 ''{0}''、''{1}'' 和 ''{2}'' 的构造函数
copy.constructor.misses.field.problem.descriptor.many=复制未复制 {0} 个字段的构造函数
covariant.equals.display.name=协变 'equals()'
covariant.equals.problem.descriptor=<code>\#ref()</code> 应当以 'Object' 作为其实参 \#loc
create.default.branch.fix.family.name=创建 'default' 分支
create.missing.boolean.switch.branches.fix.family.name=创建缺少的布尔 switch 分支
create.missing.branches.with.null.branch.fix.family.name=创建缺少的分支和 'null' 分支
create.missing.enum.switch.branches.fix.family.name=创建缺少的枚举 switch 分支
create.missing.record.deconstructions.switch.branches.fix.family.name=创建缺失记录析构 switch 分支
create.missing.sealed.class.switch.branches.fix.family.name=创建缺少的密封类 switch 分支
create.missing.switch.branch=创建缺少的分支 {0}
create.missing.switch.branches=创建缺少的分支 {0}
create.null.branch.fix.family.name=创建 'null' 分支
create.package.info.java.family.name=创建 'package-info.java'
cstyle.array.method.declaration.problem.descriptor=方法 <code>{0}()</code> 具有 C 样式数组返回值类型声明 \#loc
cstyle.array.variable.declaration.problem.descriptor={0, choice, 1\#字段|2\#形参|3\#记录组件|4\#局部变量} <code>{1}</code> 具有 C 样式数组类型声明 \#loc
custom.classloader.display.name=声明了自定义的 'ClassLoader'
custom.classloader.problem.descriptor=自定义 ClassLoader 类 <code>\#ref</code> \#loc
custom.security.manager.display.name=自定义 'SecurityManager'
custom.security.manager.problem.descriptor=自定义 SecurityManager 类 <code>\#ref</code> \#loc
cyclic.class.dependency.1.problem.descriptor=类 ''{0}'' 循环依赖于类 ''{1}''
cyclic.class.dependency.2.problem.descriptor=类 ''{0}'' 循环依赖于类 ''{1}'' 和 ''{2}''
cyclic.class.dependency.display.name=循环类依赖
cyclic.class.dependency.ignore.in.same.file=忽略位于同一文件中的类之间的循环
cyclic.class.dependency.problem.descriptor=类 ''{0}'' 循环依赖于其他 {1} 个类
cyclic.package.dependency.1.problem.descriptor=软件包 ''{0}'' 循环依赖于软件包 ''{1}''
cyclic.package.dependency.2.problem.descriptor=软件包 ''{0}'' 循环依赖于软件包 ''{1}'' 和 ''{2}''
cyclic.package.dependency.display.name=循环软件包依赖关系
cyclic.package.dependency.problem.descriptor=软件包 ''{0}'' 循环依赖于其他 {1} 个软件包
cyclomatic.complexity.display.name=过度复杂的方法
cyclomatic.complexity.limit.option=循环复杂度限制\:
cyclomatic.complexity.problem.descriptor=过度复杂的方法 <code>\#ref()</code> (循环复杂度 \= {0}) \#loc
dangling.javadoc.convert.line.comment.quickfix=替换为行注释
dangling.javadoc.convert.quickfix=替换为块注释
dangling.javadoc.delete.quickfix=移除悬空的注释
dangling.javadoc.display.name=悬空的 Javadoc 注释
dangling.javadoc.ignore.copyright.option=忽略 JavaDoc 格式的文件头注释
dangling.javadoc.problem.descriptor=悬空的 Javadoc 注释 \#loc
debug.level.and.lower.option=调试级别和更低
declare.collection.as.interface.fix.family.name=削弱类型
declare.collection.as.interface.quickfix=削弱为 ''{0}''
default.not.last.case.in.switch.display.name='default' 不是 'switch' 中的最后一个 case
default.not.last.case.in.switch.problem.descriptor=''default'' 分支不是 ''switch'' {0} 中的最后一个 case \#loc
default.tostring.call.display.name=调用默认 'toString()'
default.tostring.call.problem.descriptor=调用 <code>\#ref</code> 上的默认 'toString()' \#loc
delete.catch.section.fix.family.name=删除 catch 语句
delete.catch.section.quickfix=删除 'catch' 部分
delete.import.quickfix=删除不必要的导入
delete.unnecessary.statement.fix.family.name=移除冗余语句
deserializable.class.in.secure.context.problem.descriptor=类 <code>\#ref</code> 可能被反序列化，影响安全性 \#loc
design.for.extension.display.name=为扩展设计
design.for.extension.problem.descriptor=方法 <code>\#ref()</code> 可能被重写，其功能会被忽略 \#loc
diamond.can.be.replaced.with.explicit.type.arguments.name=diamond 可被替换为显式类型实参
diamond.can.be.replaced.with.explicit.type.arguments.quickfix=将 '<>' 替换为显式类型实参
disjoint.package.display.name=具有不相交依赖关系图的软件包
disjoint.package.problem.descriptor=软件包 {0} 可以分解为 {1} 个独立软件包
divide.by.zero.display.name=除以零
divide.by.zero.problem.descriptor=除以零 \#loc
divide.by.zero.problem.may.descriptor=可能存在除以零的情况 \#loc
divide.by.zero.problem.may.option=报告条件性除以零问题
divide.by.zero.problem.may.option.description=高亮显示某些执行分支中可能变为零的除法操作
divide.by.zero.problem.may.option.disabled=不要建议条件性除以零问题
dollar.sign.in.name.display.name=在标识符中使用 '$'
dollar.sign.in.name.problem.descriptor=标识符 <code>\#ref</code> 包含 '$' \#loc
double.brace.initialization.display.name=双大括号初始化
double.brace.initialization.quickfix=替换为正则初始化
double.checked.locking.display.name=双重检查锁定
double.checked.locking.fix.family.name=将字段设为 volatile
double.checked.locking.problem.descriptor=双重检查锁定 \#loc
double.checked.locking.quickfix=将 ''{0}'' 设为 volatile
double.literal.may.be.float.literal.display.name=转换为 'float' 可以是 'float' 字面量
double.negation.display.name=双重否定
double.negation.problem.descriptor=<code>\#ref</code> 中的双重否定 \#loc
double.negation.quickfix=移除双重否定
drivermanager.call.display.name=使用 'DriverManager' 获取 JDBC 连接
drivermanager.call.problem.descriptor=调用 <code>DriverManager.\#ref()</code> \#loc
dumpstack.call.display.name=调用 'Thread.dumpStack()'
dumpstack.call.problem.descriptor=对 <code>Thread.\#ref()</code> 的调用可能应当替换为更可靠的日志 \#loc
duplicate.condition.display.name=条件重复
duplicate.condition.ignore.method.calls.option=忽略可能有副作用的条件
duplicate.condition.ignore.method.calls.option.description=如果选中，则不会报告具有潜在副作用的条件(例如，未知的方法调用)。已知会产生副作用的方法在任何情况下都不会被报告。
duplicate.condition.problem.descriptor=重复条件 <code>\#ref</code> \#loc
dynamic.regex.replaceable.by.compiled.pattern.display.name=动态正则表达式可被替换为已编译的 'Pattern'
dynamic.regex.replaceable.by.compiled.pattern.problem.descriptor=<code>\#ref()</code> 可被替换为已编译的 'java.util.regex.Pattern' 结构 \#loc
dynamic.regex.replaceable.by.compiled.pattern.quickfix=替换为对已编译 'Pattern' 常量的方法的调用
empty.anonymous.class.problem.descriptor=匿名类为空 \#loc
empty.class.display.name=空类
empty.class.file.without.class.problem.descriptor=Java 文件未声明任何类 \#loc
empty.class.ignore.parameterization.option=如果类是父类型的形参化，则将其忽略
empty.class.initializer.delete.quickfix=删除空类初始值设定项
empty.class.initializer.display.name=空类初始值设定项
empty.class.initializer.problem.descriptor=空类初始值设定项 \#loc
empty.class.problem.descriptor=类 <code>\#ref</code> 为空 \#loc
empty.enum.problem.descriptor=枚举 <code>\#ref</code> 为空 \#loc
empty.finally.block.display.name=空 'finally' 块
empty.finally.block.problem.descriptor=空 <code>\#ref</code> 块 \#loc
empty.synchronized.statement.display.name=空 'synchronized' 语句
empty.synchronized.statement.problem.descriptor=空 <code>\#ref</code> 语句 \#loc
empty.try.block.display.name=空 'try' 块
empty.try.block.problem.descriptor=空 <code>\#ref</code> 块 \#loc
encapsulate.variable.fix.family.name=封装字段
encapsulate.variable.quickfix=封装字段 ''{0}''
enum.singleton.problem.descriptor=枚举 <code>\#ref</code> 为单例 \#loc
enum.switch.statement.which.misses.cases.display.name=缺少 case 的枚举 'switch' 语句
enum.switch.statement.which.misses.cases.option=忽略具有默认分支的 switch 语句
enum.switch.statement.which.misses.cases.problem.descriptor=枚举类型 ''{0}'' 上的 <code>\#ref</code> 语句缺少 case {1} \#loc
enum.switch.statement.which.misses.cases.problem.descriptor.single=枚举类型 ''{0}'' 上的 <code>\#ref</code> 语句缺少 case ''{1}'' \#loc
enumerated.class.display.name=枚举类
enumerated.class.naming.convention.element.description=枚举类
enumerated.class.problem.descriptor=枚举类 <code>\#ref</code> \#loc
enumerated.constant.naming.convention.element.description=枚举常量
enumeration.can.be.iteration.display.name=枚举可以是迭代
enumeration.can.be.iteration.problem.descriptor=<code>\#ref()</code> 可被替换为 ''{0}'' 结构 \#loc
enumeration.can.be.iteration.quickfix=替换为 'Iterator' 结构
equality.to.safe.equals.quickfix=用 null 安全 'equals()' 替换 '\=\='
equals.between.inconvertible.types.display.name='equals()' 位于不可转换类型的对象之间
equals.between.inconvertible.types.mutual.subclass.option=如果未找到相互子类，则发出警告
equals.between.inconvertible.types.no.mutual.subclass.problem.descriptor=未找到属于 ''{0}'' 和 ''{1}'' 这两个子类型的类 \#loc
equals.between.inconvertible.types.problem.descriptor=<code>\#ref</code> 位于 ''{0}'' 和 ''{1}'' 不可转换类型的对象之间 \#loc
equals.called.on.array.display.name=在数组上调用了 'equals()'
equals.called.on.array.problem.descriptor=数组之间的 <code>\#ref()</code> 可能应当是 'Arrays.equals()' \#loc
equals.called.on.enum.constant.display.name=对枚举值调用了 'equals()'
equals.called.on.enum.constant.problem.descriptor=对枚举值调用了 <code>\#ref()</code> \#loc
equals.called.on.suspicious.object.display.name=在不对其进行重写的类上调用了 'equals()'
equals.called.on.suspicious.object.fix.family.name=替换为代表值的比较
equals.called.on.suspicious.object.fix.name=替换为 ''{0}()'' 调用结果的比较
equals.called.on.suspicious.object.problem.descriptor=''{0}'' 对象上存在可疑的 ''equals()'' 调用
equals.doesnt.check.class.parameter.display.name=不检查其形参的类的 'equals()' 方法
equals.doesnt.check.class.parameter.problem.descriptor=<code>\#ref()</code> 应当检查其形参的类 \#loc
equals.replaceable.by.objects.call.display.name='equals()' 表达式可被替换为 'Objects.equals()' 表达式
equals.replaceable.by.objects.call.problem.descriptor=<code>\#ref</code> 可被替换为 'Objects.equals()' 表达式 \#loc
equals.replaceable.by.objects.check.not.null.option=高亮显示与 'a \!\= null \\&\\& a.equals(b)' 类似的表达式
equals.with.itself.display.name=在自身上调用了 'equals()'
equals.with.itself.option=忽略可能的约定测试
equals.with.itself.option.description=选中后，某些情况(如 <code>assertEquals(myObj, myObj)</code>)将不会被报告，以避免在检查 <code>equals()</code> 方法正确性的测试中出现警告。
equals.with.itself.problem.descriptor=在自身上调用了 <code>\#ref()</code>
error.rethrown.display.name='Error' 未重新抛出
error.rethrown.problem.descriptor=错误 <code>\#ref</code> 未重新抛出 \#loc
exception.from.catch.which.doesnt.wrap.display.name='throw' 位于忽略已捕获异常的 'catch' 块内
exception.from.catch.which.doesnt.wrap.problem.descriptor='catch' 块内的 <code>\#ref</code> 忽略捕获的异常 \#loc
exception.from.catch.which.doesntwrap.ignore.cant.wrap.option=如果抛出的异常无法包装异常，则忽略
exception.from.catch.which.doesntwrap.ignore.option=如果使用异常方法调用的结果，则忽略
exception.name.doesnt.end.with.exception.display.name=异常类名不以 'Exception' 结尾
exception.name.doesnt.end.with.exception.problem.descriptor=异常类名 <code>\#ref</code> 未以 'Exception' 结尾 \#loc
exception.package.display.name=异常软件包
exception.package.problem.descriptor=软件包 ''{0}'' 仅包含异常类
explicit.array.to.string.problem.descriptor=调用数组上的 '\#ref()' \#loc
expression.can.be.replaced.no.quotes.problem.descriptor={0} 可被替换为 {1}
expression.can.be.replaced.problem.descriptor=<code>\#ref</code> 可被替换为 ''{0}'' \#loc
expression.may.be.factorized.display.name=表达式可以因式分解
extend.exception.fix.family.name=使类扩展 'Exception'
extended.for.statement.display.name=增强的 'for' 语句
extended.for.statement.problem.descriptor=扩展 <code>\#ref</code> 语句 \#loc
extended.for.statement.replace.quickfix=替换为旧式 'for' 语句
extends.annotation.display.name=类扩展注解接口
extends.annotation.interface.problem.descriptor=接口 ''{0}'' 扩展注解接口 <code>\#ref</code> \#loc
extends.annotation.problem.descriptor=类 ''{0}'' 实现注解接口 <code>\#ref</code> \#loc
extends.concrete.collection.display.name=类显式扩展 'Collection' 类
extends.concrete.collection.problem.descriptor=类 <code>\#ref</code> 显式扩展 ''{0}'' \#loc
extends.object.display.name=类显式扩展 'Object'
extends.object.problem.descriptor=类 <code>\#ref</code> 显式扩展 'java.lang.Object' \#loc
extends.object.remove.quickfix=移除冗余的 'extends Object'
extends.thread.display.name=类直接扩展 'Thread'
extends.thread.problem.descriptor=类 <code>\#ref</code> 直接扩展 'java.lang.Thread' \#loc
extends.throwable.display.name=类直接扩展 'Throwable'
extends.throwable.problem.descriptor=类 <code>\#ref</code> 直接扩展 'java.lang.Throwable' \#loc
externalizable.with.serialization.methods.display.name=具有 'readObject()' 或 'writeObject()' 的可外部化类
externalizable.with.serialization.methods.problem.descriptor.both=可外部化{0, choice, 1\#类|2\#接口|3\#派生的匿名类|4\#注解类型|5\#枚举|6\#记录} <code>\#ref</code> 定义 'readObject()' 和 'writeObject()' \#loc
externalizable.with.serialization.methods.problem.descriptor.read=可外部化{0, choice, 1\#类|2\#接口|3\#派生的匿名类|4\#注解类型|5\#枚举|6\#记录} <code>\#ref</code> 定义 'readObject()' \#loc
externalizable.with.serialization.methods.problem.descriptor.write=可外部化{0, choice, 1\#类|2\#接口|3\#派生的匿名类|4\#注解类型|5\#枚举|6\#记录} <code>\#ref</code> 定义 'writeObject()' \#loc
externalizable.without.public.no.arg.constructor.display.name=没有 'public' 无实参构造函数的 'Externalizable' 类
externalizable.without.public.no.arg.constructor.problem.descriptor=可外部化类 <code>\#ref</code> 没有 'public' 无实参构造函数 \#loc
extract.method.quickfix=提取方法
extract.parameter.as.local.variable.quickfix=提取形参作为局部变量
fallthru.in.switch.statement.display.name='switch' 语句中的直落
fallthru.in.switch.statement.problem.descriptor='switch' 语句存在直落 \#loc
fallthru.in.switch.statement.quickfix=添加 ''{0}''
feature.envy.display.name=特性依恋
feature.envy.problem.descriptor=类 ''{0}'' 在方法 <code>\#ref()</code> 中被重复访问 \#loc
field.accessed.synchronized.and.unsynchronized.display.name=同时在 'synchronized' 和未同步上下文中访问字段
field.accessed.synchronized.and.unsynchronized.option=简单的 getter 和 setter 也被视为字段访问
field.accessed.synchronized.and.unsynchronized.problem.descriptor=同时在同步和未同步上下文中访问字段 <code>\#ref</code> \#loc
field.count.inspection.include.constant.fields.in.count.checkbox=在计数中包含常量字段
field.count.inspection.include.enum.constants.in.count=在计数中包含枚举常量
field.count.inspection.static.final.fields.count.as.constant.checkbox=将 'static final' 字段计为常量
field.has.setter.but.no.getter.display.name=字段具有 setter 但没有 getter
field.has.setter.but.no.getter.problem.descriptor=字段 <code>\#ref</code> 有 setter 但没有 getter \#loc
field.has.static.modifier.problem.descriptor=字段 ''{0}'' 具有 ''static'' 修饰符
field.incorrect.type.problem.descriptor=字段 ''{0}'' 没有类型 ''{1}''
field.may.be.final.display.name=字段可能为 'final'
field.may.be.final.problem.descriptor=字段 <code>\#ref</code> 可能为 'final' \#loc
field.may.be.static.display.name=字段可以为 'static'
field.may.be.static.problem.descriptor=字段 <code>\#ref</code> 可能为 'static' \#loc
field.missing.volatile.modifier.problem.descriptor=字段 ''{0}'' 没有 ''volatile'' 修饰符
field.name.hides.in.superclass.display.name=子类字段隐藏超类字段
field.name.hides.in.superclass.ignore.option=忽略不可访问字段
field.name.hides.in.superclass.ignore.static.field.option=忽略隐藏 static 字段的 static 字段
field.name.hides.in.superclass.problem.descriptor=字段 <code>\#ref</code> 隐藏超类中的字段 \#loc
field.naming.convention.display.name=字段命名约定
field.not.found.in.class.problem.descriptor=类 ''{1}'' 中未找到命名为 ''{0}'' 的字段
final.class.display.name=类禁止继承
final.class.problem.descriptor=类 ''{0}'' 声明了 <code>\#ref</code> \#loc
final.method.display.name=不能重写方法
final.method.in.final.class.display.name='final' 类位于 'final' 方法中
final.method.in.final.class.problem.descriptor=方法在 'final' 类中被声明为 <code>\#ref</code> \#loc
final.method.problem.descriptor=方法被声明为 <code>\#ref</code> \#loc
final.private.method.display.name='private' 方法被声明为 'final'
final.private.method.problem.descriptor='private' 方法被声明为 <code>\#ref</code> \#loc
final.static.method.display.name='static' 方法被声明为 'final'
final.static.method.problem.descriptor='static' 方法被声明为 <code>\#ref</code> \#loc
finalize.called.explicitly.display.name='finalize()' 被显式调用
finalize.called.explicitly.problem.descriptor=<code>\#ref()</code> 被显式调用 \#loc
finalize.declaration.display.name='finalize()' 不应被重写
finalize.declaration.problem.descriptor='finalize()' 不应被重写 \#loc
finalize.not.declared.protected.display.name='finalize()' 应为 protected，不应为 public
finalize.not.declared.protected.problem.descriptor='finalize()' 应具有 protected 访问权限，不应具有 public 访问权限 \#loc
finally.block.cannot.complete.normally.display.name=不能正常完成的 'finally' 块
finally.block.cannot.complete.normally.problem.descriptor=<code>\#ref</code> 块无法正常完成 \#loc
fix.add.argument.family.name=添加实参
fix.add.argument.name=添加 ''{0}'' 实参
fix.eliminate.folded.if.present.description=可以消除折叠的 'ifPresent()' 调用
fix.eliminate.folded.if.present.name=移除折叠的 'ifPresent()' 调用
fix.replace.map.with.flat.map.description='map()' 可被替换为 'flatMap()'
flip.comparison.quickfix=翻转比较
floating.point.equality.display.name=浮点相等比较
floating.point.equality.problem.descriptor=<code>\#ref</code>\: 比较浮点值以实现完全相等 \#loc
for.can.be.foreach.display.name='for' 循环可被替换为增强的 for 循环
for.can.be.foreach.fix.no.indexed=不报告索引的 'java.util.List' 循环
for.can.be.foreach.option=报告索引的 'java.util.List' 循环
for.can.be.foreach.option2=不报告无类型集合上的迭代
for.can.be.foreach.problem.descriptor=<code>\#ref</code> 循环可被替换为增强的 'for' \#loc
for.loop.replaceable.by.while.display.name='for' 循环可被替换为 'while' 循环
for.loop.replaceable.by.while.ignore.option=忽略无条件循环的 'infinite'
for.loop.replaceable.by.while.problem.descriptor=<code>\#ref</code> 循环语句可被替换为 'while' 循环 \#loc
for.loop.with.missing.component.collection.loop.option=忽略集合迭代
for.loop.with.missing.component.display.name=缺少组件的 'for' 循环
for.loop.with.missing.component.problem.descriptor1=<code>\#ref</code> 语句缺少初始值设定项 \#loc
for.loop.with.missing.component.problem.descriptor2=<code>\#ref</code> 语句缺少条件 \#loc
for.loop.with.missing.component.problem.descriptor3=<code>\#ref</code> 语句缺少更新 \#loc
for.loop.with.missing.component.problem.descriptor4=<code>\#ref</code> 语句缺少初始值设定项和条件 \#loc
for.loop.with.missing.component.problem.descriptor5=<code>\#ref</code> 语句缺少初始值设定项和条件 \#loc
for.loop.with.missing.component.problem.descriptor6=<code>\#ref</code> 语句缺少条件和更新 \#loc
for.loop.with.missing.component.problem.descriptor7=<code>\#ref</code> 语句缺少初始值设定项、条件和更新 \#loc
foreach.replace.quickfix=替换为增强 'for'
format.string.error.duplicate.flag=''{1}'' 中存在重复的标志 ''{0}''
format.string.error.flags.not.allowed=''{1}'' 中不允许使用{2, choice, 1\#标志|1<标志} ''{0}''
format.string.error.illegal.flag.combination=''{2}'' 中的标志组合 ''{0}'' 和 ''{1}'' 非法
format.string.error.illegal.position.specifier=''{1}'' 存在非法的位置说明符 ''{0}''
format.string.error.invalid.precision=''{0}'' 中指定的精度无效
format.string.error.left.justify.no.width=使用了左对齐标志 ''-''，但 ''{0}'' 中未指定宽度
format.string.error.precision.not.allowed=''{1}'' 中不允许该精度 (''{0}'')
format.string.error.previous.element.not.found=使用了以前的标志 '<'，但没有找到 ''{0}'' 以前的格式说明符
format.string.error.unexpected.flag=''{1}'' 中出现意外字符 ''{0}''
format.string.error.unknown.conversion=''{0}'' 中存在未知的转换
format.string.error.unnecessary.position.specifier=''{1}'' 存在不必要的实参位置说明符 ''{0}''
format.string.error.width.not.allowed=''{1}'' 中不允许该宽度 (''{0}'')
format.string.error.zero.padding.no.width=使用了零填充标志 ''0''，但 ''{0}'' 中未指定宽度
gc.call.display.name=调用 'System.gc()' 或 'Runtime.gc()'
gc.call.problem.descriptor=<code>\#ref</code> 不应在生产代码中调用 \#loc
generate.to.string.quick.fix.family.name=生成
generate.to.string.quick.fix.text=生成 toString()
hardcoded.file.separator.display.name=硬编码文件分隔符
hardcoded.file.separator.ignore.methods.option=忽略以下方法的实参\:
hardcoded.file.separator.include.option=在已识别的 MIME 媒体类型中包括 'example/*'
hardcoded.file.separator.problem.descriptor=硬编码文件分隔符 <code>\#ref</code> \#loc
hardcoded.line.separator.display.name=硬编码行分隔符
hardcoded.line.separator.problem.descriptor=硬编码行分隔符 <code>\#ref</code> \#loc
hibernate.resource.opened.not.closed.display.name=Hibernate 资源已打开，但未安全关闭
html.tag.can.be.javadoc.tag.display.name='<code>…</code>' 可被替换为 '{@code …}'
html.tag.can.be.javadoc.tag.problem.descriptor=<code>\#ref...\\&lt;/code\\&gt;</code> 可被替换为 '{@code …}' \#loc
i.o.resource.opened.not.closed.display.name=I/O 资源已打开，但未安全关闭
if.can.be.assertion.name=语句可被替换为 'assert' 或 'Objects.requireNonNull'
if.can.be.assertion.replace.with.assertion.quickfix=将语句替换为 'assert' 语句
if.can.be.assertion.replace.with.objects.requirenonnull.quickfix=将语句替换为 'Objects.requireNonNull()'
if.can.be.switch.display.name='if' 可被替换为 'switch'
if.can.be.switch.enum.option=对枚举启用 switch 建议
if.can.be.switch.int.option=对数字启用 switch 建议
if.can.be.switch.minimum.branch.option='if' 条件分支的最小数量\:
if.can.be.switch.null.safe.option=仅对 null-safe 表达式启用建议
if.can.be.switch.problem.descriptor=<code>\#ref</code> 语句可被替换为 'switch' 语句 \#loc
if.may.be.conditional.problem.descriptor=<code>\#ref</code> 可被替换为条件表达式 \#loc
if.may.be.conditional.quickfix=替换为条件表达式
if.may.be.factorized.problem.descriptor=<code>\#ref</code> 可以因式分解 \#loc
if.may.be.factorized.quickfix=替换为因式分解表达式
if.statement.with.identical.branches.display.name=具有相同分支或通用部分的 'if' 语句
if.statement.with.too.many.branches.display.name='if' 语句的分支过多
if.statement.with.too.many.branches.max.option=最大分支数\:
if.statement.with.too.many.branches.problem.descriptor=<code>\#ref</code> 的分支过多 ({0}) \#loc
ignore.accesses.from.equals.method=忽略来自 'equals()' 方法的访问
ignore.accesses.from.the.same.class=忽略来自同一类的访问
ignore.anonymous.inner.classes=忽略匿名类
ignore.boolean.methods.in.an.interface.option=忽略 @&interface 中的布尔方法
ignore.branches.of.switch.statements=忽略 'switch' 语句的分支
ignore.calls.to.property.getters=忽略对属性 getter 的调用
ignore.calls.to.static.methods=忽略对 static 方法的调用
ignore.classes.annotated.by=由以下对象注解时忽略类\:
ignore.classes.in.hierarchy.column.name=忽略以下对象的子类\:
ignore.cloneable.option=忽略 'java.lang.Cloneable'
ignore.constructor.method.references=忽略产生 AutoCloseable 的构造函数方法引用
ignore.enhanced.for.loop.statements=忽略增强型 for 循环
ignore.equals.hashcode.and.tostring=忽略 'equals()'、'hashCode()' 和 'toString()' 方法
ignore.exceptions.declared.on.library.override.option=忽略在重写库方法的方法上声明的异常(&L)
ignore.for.equals.methods.option=对 'equals()' 方法忽略(&E)
ignore.getters.returning.resource=忽略返回源的 getter
ignore.guard.clauses.option=忽略 guard 子句(&G)
ignore.if.annotated.by=由以下对象注解时忽略\:
ignore.in.module.statements.option=在 Java 9 模块语句中忽略
ignore.instanceof.on.library.classes=忽略库类上的 instanceof
ignore.methods.in.anonymous.classes=忽略匿名类中的方法
ignore.methods.overriding.super.method=忽略重写/实现 super 方法的方法(O&)
ignore.methods.with.boolean.return.type.option=忽略具有 'java.lang.Boolean' 返回值类型的方法(&B)
ignore.overflowing.byte.casts.option=忽略从 int 128-255 到字节的转换
ignore.parentheses.around.single.no.formal.type.lambda.parameter=忽略单个非正式类型 lambda 形参周围的括号
ignore.private.methods.option=忽略 private 方法中的赋值和返回值
ignore.serializable.option=忽略 'java.io.Serializable'
ignore.single.field.static.imports.option=忽略单字段 static import(&F)
ignore.single.method.static.imports.option=忽略单方法 static import(&M)
ignore.trivial.finalizers.option=对普通 'finalize()' 实现忽略
ignored.autocloseable.types.label=已忽略的 AutoCloseable 资源类型\:
ignored.class.hierarchies.border.title=忽略以下对象的子类\:
ignored.class.label=已忽略类(包括子类)\:
ignored.class.names=忽略类(包括子类)
ignored.io.resource.types.label=已忽略的 I/O 资源类型\:
implicit.array.to.string.display.name=调用数组上的 'toString()'
implicit.array.to.string.fix.family.name=将 Array.toString() 设为隐式
implicit.array.to.string.method.call.problem.descriptor=隐式调用调用 <code>\#ref</code> 返回的数组上的 'toString()' \#loc
implicit.array.to.string.problem.descriptor=隐式调用数组 <code>\#ref</code> 上的 'toString()' \#loc
implicit.array.to.string.quickfix=使用 ''{0}'' 表达式包装
implicit.call.to.super.display.name=隐式调用 'super()'
implicit.call.to.super.ignore.option=对 'java.lang.Object' 的直接子类忽略
implicit.call.to.super.make.explicit.quickfix=使对 'super()' 的调用显式
implicit.call.to.super.problem.descriptor=隐式调用 'super()' \#loc
implicit.default.charset.usage.constructor.problem.descriptor=<code>new \#ref()</code> 调用使用平台的默认字符集
implicit.default.charset.usage.display.name=隐式平台默认字符集
implicit.default.charset.usage.fix.family.name=指定 UTF-8 字符集
implicit.default.charset.usage.problem.descriptor=对 <code>\#ref()</code> 的调用使用平台的默认字符集
implicit.numeric.conversion.assignment.problem.descriptor=将结果值从 ''{0}'' 隐式数字转换为 ''{1}'' \#loc
implicit.numeric.conversion.display.name=隐式数字转换
implicit.numeric.conversion.ignore.char.conversion.option=忽略 'char' 之间的转换
implicit.numeric.conversion.ignore.constant.conversion.option=忽略从常量和字面量的转换
implicit.numeric.conversion.ignore.widening.conversion.option=忽略扩大转换
implicit.numeric.conversion.make.explicit.quickfix=使转换显式
implicit.numeric.conversion.problem.descriptor=将 <code>\#ref</code> 从 ''{0}'' 隐式数字转换为 ''{1}'' \#loc
import.display.name='*' 导入
import.from.same.package.display.name=相同软件包中的不必要 import
import.from.same.package.problem.descriptor=相同软件包 <code>\#ref</code> 中有不必要的 import \#loc
import.problem.descriptor=软件包导入 <code>\#ref</code> \#loc
include.java.system.classes.option=包括与 Java 系统类的耦合
include.library.classes.option=包括与库类的耦合
incompatible.mask.operation.display.name=不兼容的按位掩码运算
incompatible.mask.operation.problem.descriptor.always.false=<code>\#ref</code> 始终为 false \#loc
incompatible.mask.operation.problem.descriptor.always.true=<code>\#ref</code> 始终为 true \#loc
incorrect.date.format.fix.family.name=修复不正确的日期格式
increment.decrement.display.name=使用 '++' 或 '--' 的结果
increment.decrement.used.as.expression.fix.family.name=提取到分离语句中
increment.decrement.used.as.expression.quickfix=提取 ''{0}'' 以分离语句
inequality.to.safe.not.equals.quickfix=用 null 安全 '\!equals()' 替换 '\!\='
infinite.loop.statement.display.name=无限循环语句
infinite.loop.statement.problem.descriptor=<code>\#ref</code> 语句不能在未抛出异常的情况下完成 \#loc
infinite.recursion.display.name=无限递归
infinite.recursion.problem.descriptor=方法 <code>\#ref()</code> 无限递归，只能以抛出异常结束 \#loc
info.level.and.lower.option=信息级别和更低
inline.call.quickfix=内联调用
inline.variable.quickfix=内联变量
inner.class.field.hides.outer.display.name=内部类字段隐藏外部类字段
inner.class.field.hides.outer.ignore.option=忽略从内部类不可见的外部字段
inner.class.field.hides.outer.problem.descriptor=内部类字段 <code>\#ref</code> 隐藏外部类字段 \#loc
inner.class.may.be.static.display.name=内部类可能为 'static'
inner.class.may.be.static.problem.descriptor=内部类 <code>\#ref</code> 可能为 'static' \#loc
inner.class.on.interface.display.name=接口的内部类
inner.class.on.interface.ignore.option=忽略接口的内部接口
inner.class.on.interface.problem.descriptor=接口 ''{0}'' 具有内部类 <code>\#ref</code> \#loc
inner.class.referenced.via.subclass.display.name=通过子类引用的内部类
inner.class.referenced.via.subclass.problem.descriptor=内部类 <code>\#ref</code> 在类 ''{0}'' 中声明，但通过子类 ''{1}'' 引用 \#loc
inner.class.referenced.via.subclass.quickfix=使内部类访问合理化
inner.class.too.deeply.nested.display.name=内部类嵌套太深
inner.class.too.deeply.nested.nesting.limit.option=嵌套限制\:
inner.class.too.deeply.nested.problem.descriptor=<code>\#ref</code> 嵌套太深 (嵌套级别 \= {0}) \#loc
inspection.autocloseable.resource.ignored.methods.title=忽略从这些方法返回的 AutoCloseable 实例\:
inspection.byte.array.output.stream.to.string.message=ByteArrayOutputStream 转换低效
inspection.case.mismatch.display.name='String' 操作中不匹配的大小写
inspection.case.mismatch.message.arg.is.lower=方法 ''{0}()'' 始终返回 {1}\: 实参包含小写符号，而限定符不包含小写符号
inspection.case.mismatch.message.arg.is.upper=方法 ''{0}()'' 始终返回 {1}\: 实参包含大写符号，而限定符不包含大写符号
inspection.case.mismatch.message.label.is.lower=无法访问 switch 分支\: 标签包含小写符号，而选择器仅支持大写
inspection.case.mismatch.message.label.is.upper=无法访问 switch 分支\: 标签包含大写符号，而选择器仅支持小写
inspection.cast.can.be.replaced.with.variable.display.name=转换可被替换为变量
inspection.cast.can.be.replaced.with.variable.family.name=用变量替换转换
inspection.cast.can.be.replaced.with.variable.message=可以使用变量 ''{0}'' 替代 ''{1}''
inspection.catch.ignores.exception.display.name=catch 块可能会忽略异常
inspection.catch.ignores.exception.empty.message=空 <code>\#ref</code> 块 \#loc
inspection.catch.ignores.exception.option.comments=当 'catch' 块包含注释时不发出警告
inspection.catch.ignores.exception.option.ignored.used=当名称为 'ignore(d)' 的异常实际上未被忽略时不发出警告
inspection.catch.ignores.exception.option.nonempty=当 'catch' 块不为空时不发出警告
inspection.catch.ignores.exception.unused.message=未使用的 'catch' 形参 <code>\#ref</code> \#loc
inspection.catch.ignores.exception.used.message=已使用命名为 <code>\#ref</code> 的 'catch' 形参 \#loc
inspection.catch.ignores.exception.vm.ignored.message=<code>\#ref</code> 块中可能会忽略 ''{0}'' 之类的意外虚拟机异常 \#loc
inspection.collection.must.have.initial.capacity.initializers.option=不报告字段初始值设定项
inspection.commented.out.code.disable.short.fragments=不报告此类短片段
inspection.commented.out.code.display.name=注释掉的代码
inspection.commented.out.code.min.lines.options=最少代码行数
inspection.commented.out.code.problem.descriptor=注释掉的代码 ({0} {0, choice, 1\#行|1<行})
inspection.common.if.parts.description.complete.duplicate=可以收起 ''if'' 语句{0}
inspection.common.if.parts.description.complete.duplicate.side.effect=可以通过提取副作用收起 'if' 语句
inspection.common.if.parts.description.variables.only=可以从 ''if'' 中提取变量{0}
inspection.common.if.parts.description.whole.branch=可以提取通用部分，同时移除分支{0}
inspection.common.if.parts.description.with.variables.extract=可以从 ''if'' 中提取包含变量的通用部分{0}
inspection.common.if.parts.description.without.variables.extract=可以从 ''if'' 中提取通用部分{0}
inspection.common.if.parts.message.complete.duplicate=收起 ''if'' 语句{0}
inspection.common.if.parts.message.complete.duplicate.side.effect=收起 'if' 语句并提取副作用
inspection.common.if.parts.message.variables.only=从 ''if'' 中提取变量{0}
inspection.common.if.parts.message.whole.branch=提取通用部分，同时移除分支{0}
inspection.common.if.parts.message.with.variables.extract=从 ''if'' 中提取包含变量的通用部分{0}
inspection.common.if.parts.message.without.variables.extract=从 ''if'' 中提取通用部分{0}
inspection.common.subexpression.in.switch.display.name=可以从 'switch' 中提取通用子表达式
inspection.common.subexpression.in.switch.fix.family.name=向下推送 'switch' 表达式
inspection.comparator.combinators.description=可被替换为 'Comparator' 链
inspection.comparator.combinators.description2=可被替换为 ''{0}''
inspection.comparator.combinators.fix.chain=替换为 'Comparator' 链
inspection.condition.covered.by.further.condition.descr=条件 ''{0}'' 由后面的{1, choice, 1\#条件 ''''{2}''''|2\#条件}覆盖
inspection.constant.expression.display.name=可以对常量表达式求值
inspection.constant.expression.fix.family.name=计算常量值
inspection.constant.expression.fix.name=计算 ''{0}'' 的常量值
inspection.constant.expression.fix.name.short=替换为常量值
inspection.constant.expression.message=常量表达式的求值结果可以为 ''{0}''
inspection.constant.expression.report.compile.time=仅报告编译时常量
inspection.constant.expression.report.compile.time.description=默认情况下，该检查可以评估一些涉及库方法调用的常量，甚至可以根据周围代码推断常量值。选中此选项可以根据 Java 语言规范仅报告编译时常量。
inspection.constant.expression.skip.non.literal=不报告包含对已定义常量的引用的表达式
inspection.constant.expression.skip.non.literal.description=忽略包含对非字面量操作数(例如字段和变量)引用的表达式。
inspection.deconstruction.can.be.used.display.name=可以使用记录模式
inspection.deconstruction.can.be.used.fix.family.name=替换为记录模式
inspection.deconstruction.can.be.used.message=可被替换为记录模式
inspection.empty.catch.block.generate.body=从模板生成 'catch' 正文
inspection.empty.class.ignore.subclasses.option=忽略 {0} 的子类
inspection.enhanced.for.with.record.pattern.can.be.used.components.option=要析构的记录组件的最大数量\:
inspection.enhanced.for.with.record.pattern.can.be.used.display.name=可以使用带有记录模式的增强 'for'
inspection.enhanced.for.with.record.pattern.can.be.used.fix.family.name=替换为记录模式
inspection.enhanced.for.with.record.pattern.can.be.used.level.option=嵌套深度限制\:
inspection.enhanced.for.with.record.pattern.can.be.used.maximum.depth.disabled=不建议带有 {0} 种和更多嵌套模式的模式
inspection.enhanced.for.with.record.pattern.can.be.used.maximum.number.disabled=不建议带有 {0} 个或更多组件的记录
inspection.enhanced.for.with.record.pattern.can.be.used.message=可被替换为带有记录模式的增强 'for'
inspection.enhanced.for.with.record.pattern.can.be.used.not.used.option=未使用的记录组件的最大数量\:
inspection.excessive.range.check.fix.family.name=简化过度范围检查
inspection.excessive.range.check.message=可被替换为 ''{0}''
inspection.if.statement.missing.break.in.loop.description=满足条件后，可以终止循环
inspection.if.statement.missing.break.in.loop.name=在 'if' 条件下提前退出循环
inspection.if.statement.missing.break.in.loop.quickfix=添加 'break'
inspection.incorrect.date.format.display.name=不正确的 'DateTimeFormat' 模式
inspection.incorrect.date.format.message.literal=左单引号({0})后未跟随右单引号
inspection.incorrect.date.format.message.padding=没有连续模式字母的填充修饰符 ''{0}''
inspection.incorrect.date.format.message.reserved.character=使用保留字符 ''{0}''
inspection.incorrect.date.format.message.unpaired=在没有事先打开 ''{0}'' 的情况下关闭 <code>\#ref</code>
inspection.incorrect.date.format.message.unsupported=非法模式字母 ''{0}''
inspection.incorrect.date.format.too.few.letters=连续模式字母 ''{0}'' 过少；最小\: {1}；指定\: {2}
inspection.incorrect.date.format.too.many.letters=连续模式字母 ''{0}'' 过多；最大\: {1}；指定\: {2}
inspection.incorrect.date.format.wrong.number.of.letters=连续模式字母 ''{0}'' 的数量错误；允许\: {1}；指定\: {2}
inspection.incorrect.message.custom.classes.methods=自定义 MessageFormat 方法\:
inspection.incorrect.message.format.choice.limit.incorrect=选择模式中的下限 ''{0}'' 不正确
inspection.incorrect.message.format.choice.limit.not.found=选择模式中的下限为空
inspection.incorrect.message.format.display.name='MessageFormat' 模式不正确
inspection.incorrect.message.format.incorrect.index=索引 ''{0}'' 不正确
inspection.incorrect.message.format.incorrect.order.choice=选择模式中的下限未按升序排列
inspection.incorrect.message.format.incorrect.quotes.number=引号的数量可能不正确，将打印超过 1 个引号
inspection.incorrect.message.format.not.found.argument=索引 ''{0}'' 没有实参''
inspection.incorrect.message.format.not.found.arguments=索引没有实参\: {0}
inspection.incorrect.message.format.not.used.argument=模式中未使用索引为 ''{0}'' 的实参
inspection.incorrect.message.format.pattern=消息格式模式 ''{1}'' 中的 {0}
inspection.incorrect.message.format.quotes.around.parameter=占位符 ''{0}'' 不会被替换，因为它包含在引号中
inspection.incorrect.message.format.unclosed.brace=未闭合的大括号
inspection.incorrect.message.format.unknown.format.type=未知格式类型 ''{0}''
inspection.incorrect.message.format.unmatched.brace=不匹配的大括号
inspection.incorrect.message.format.unpaired.quote=消息模式中不成对的引号
inspection.list.remove.in.loop.display.name=在循环中调用了 'List.remove()'
inspection.list.remove.in.loop.message=可被替换为 'List.subList().clear()'
inspection.lossy.conversion.compound.assignment.display.name=复合赋值中从 ''{0}'' 到 ''{1}'' 的隐式转换可能是有损的
inspection.lossy.conversion.compound.assignment.name=复合赋值中可能存在有损隐式转换
inspection.meta.annotation.without.runtime.description={0} 应具有 @Retention(RetentionPolicy.RUNTIME)
inspection.method.call.in.loop.ignore.known.methods.option=忽略有副作用的已知方法
inspection.new.object.equality.display.name=使用 '\=\=' 比较新对象
inspection.new.object.equality.message=使用 ''{0}'' 比较新对象
inspection.non.strict.comparison.equality.display.name=非严格不等式 '>\=' 或 '<\=' 可被替换为 '\=\='
inspection.non.strict.comparison.equality.message=可被替换为等式
inspection.note.may.change.semantics=可能更改语义
inspection.only.one.element.used.array=仅使用了一个数组元素
inspection.only.one.element.used.display.name=仅使用了一个元素
inspection.only.one.element.used.fix.family=替换为已访问的元素
inspection.only.one.element.used.list=仅使用了一个列表元素
inspection.only.one.element.used.string=仅使用了一个字符串字符
inspection.option.ignore.as.initial.capacity=忽略 StringBuilders 和 Collections 的初始容量
inspection.option.ignore.assert=对断言语句描述实参忽略
inspection.option.ignore.constant.initializers=对常量字段的初始值设定项忽略
inspection.option.ignore.exceptions=对 Throwable 子类的构造函数实参忽略
inspection.option.ignore.in.annotations=在注解中忽略
inspection.option.ignore.in.hashcode=忽略 'hashCode()' 方法中的常量
inspection.option.ignore.in.tostring=在 toString() 方法内部忽略
inspection.option.ignore.nonnls=通过 @NonNls 进行注解时忽略
inspection.option.ignore.system.err=对 'System.err.print' 实参忽略
inspection.option.ignore.system.out=对 'System.out.print' 实参忽略
inspection.pattern.variable.can.be.used.display.name=可以使用模式变量
inspection.pattern.variable.can.be.used.existing.cast.message=可以使用现有模式变量 ''{0}'' 代替转换表达式
inspection.pattern.variable.can.be.used.existing.fix.family.name=替换为现有模式变量
inspection.pattern.variable.can.be.used.existing.fix.name=将 ''{0}'' 替换为现有模式变量 ''{1}''
inspection.pattern.variable.can.be.used.existing.message=可以使用现有模式变量 ''{0}'' 代替 ''{1}''
inspection.pattern.variable.can.be.used.fix.family.name=替换为模式变量
inspection.pattern.variable.can.be.used.fix.name=将 ''{0}'' 替换为模式变量
inspection.pattern.variable.can.be.used.instead.of.cast.message=转换表达式可被替换为模式变量
inspection.pattern.variable.can.be.used.message=变量 ''{0}'' 可被替换为模式变量
inspection.pattern.variable.can.be.used.report.cast.only=报告可被替换为新引入的模式变量的转换表达式
inspection.pattern.variable.instead.of.cast.can.be.used.existing.fix.name=将转换表达式替换为现有模式变量 ''{0}''
inspection.pattern.variable.instead.of.cast.can.be.used.fix.family.name=将转换表达式替换为模式变量
inspection.redundant.arguments.message=不必要的实参
inspection.redundant.class.call.display.name=冗余的 'isInstance()' 或 'cast()' 调用
inspection.redundant.collection.operation.display.name=冗余的 'Collection' 操作
inspection.redundant.collection.operation.fix.family.name=简化集合操作
inspection.redundant.collection.operation.problem.arraycopy=为复制数组而创建的集合不必要
inspection.redundant.collection.removal.by.index.fix=使用按对象移除
inspection.redundant.collection.removal.by.index.problem=按索引移除可被替换为按对象移除
inspection.redundant.collection.unnecessary.contains.fix=移除 ''{0}()'' 检查
inspection.redundant.collection.unnecessary.contains.problem=不必要的 ''{0}()'' 检查
inspection.redundant.compare.call.display.name=冗余的 'compare()' 方法调用
inspection.redundant.compare.call.fix.name=内联 'compare()' 调用
inspection.redundant.embedded.expression.display.name=字符串模板中的冗余嵌入式表达式
inspection.redundant.embedded.expression.fix.family.name=内联嵌入式表达式
inspection.redundant.embedded.expression.message.empty=冗余的空嵌入式表达式
inspection.redundant.embedded.expression.message.literal=冗余的嵌入式字面量
inspection.redundant.empty.string.argument.message=不必要的空字符串实参
inspection.redundant.explicit.variable.type.description=可以省略局部变量的显式类型
inspection.redundant.java.time.operation.compare.java.time.family.name=使用 'java.time' 'compareTo()' 调用简化表达式
inspection.redundant.java.time.operation.compare.java.time.problem.descriptor=带有 'java.time' <code>\#ref()</code> 调用的表达式可以简化
inspection.redundant.java.time.operation.creation.java.time.error.message=''{0}'' 对象的冗余创建
inspection.redundant.java.time.operation.creation.java.time.error.remove.fix.message=移除 ''{0}'' 调用
inspection.redundant.java.time.operation.creation.java.time.error.replace.fix.message=替换为 ''{0}'' 调用
inspection.redundant.java.time.operation.creation.java.time.family.name=简化 'java.time' 对象的创建
inspection.redundant.java.time.operation.creation.java.time.redundant.call.message=冗余的 ''{0}'' 调用
inspection.redundant.java.time.operation.creation.java.time.remove.family.name=移除不必要的调用
inspection.redundant.java.time.operation.display.name='java.time' 对象上的冗余操作
inspection.redundant.java.time.operation.explicit.chrono.field.family.name=简化带有显式 'ChronoField' 或 'ChronoUnit' 实参的调用
inspection.redundant.java.time.operation.explicit.chrono.field.problem.descriptor=带有显式 'ChronoField' 或 'ChronoUnit' 实参的调用可以简化
inspection.redundant.length.check.display.name=冗余的数组长度检查
inspection.redundant.string.call.message=<code>\#ref()</code> 的调用冗余 \#loc
inspection.redundant.string.constructor.message=<code>new \#ref()</code> 冗余 \#loc
inspection.redundant.string.fix.family.name=移除冗余调用
inspection.redundant.string.fix.remove.str.processor.description=字符串模板可以转换为普通字符串字面量
inspection.redundant.string.intern.on.constant.message=编译时常量上 <code>\#ref()</code> 的调用不必要 \#loc
inspection.redundant.string.length.argument.message=不必要的字符串长度实参
inspection.redundant.string.new.array.message=<code>\#ref</code> 冗余 \#loc
inspection.redundant.string.operation.display.name=冗余的 'String' 操作
inspection.redundant.string.option.do.not.report.single.argument.substring=不报告冗余的单实参 substring() 调用
inspection.redundant.string.option.do.not.report.string.constructors=不报告 String 构造函数调用
inspection.redundant.string.remove.argument.fix.name=移除实参
inspection.redundant.string.replace.with.arg.fix.name=替换为实参
inspection.redundant.string.replace.with.empty.fix.name=替换为空字符串
inspection.redundant.zero.argument.message=不必要的零实参
inspection.refused.bequest.super.annotated.option=仅在通过以下方式注解 super 方法时报告\:
inspection.remove.redundant.call.fix.name=移除冗余的 ''{0}()'' 调用
inspection.replace.on.literal.display.name=替换操作不起任何作用
inspection.simplifiable.if.statement.display.name='if' 语句可被替换为条件或布尔表达式
inspection.simplifiable.if.statement.fix.family.name=将 'if else' 替换为条件运算符
inspection.simplifiable.if.statement.fix.name=将 ''if else'' 替换为 ''{0}''
inspection.simplifiable.if.statement.message=If 语句可被替换为 ''{0}''
inspection.simplifiable.if.statement.option.dont.warn.on.ternary=不建议使用 '?\:' 运算符
inspection.suspicious.date.format.display.name=可疑的日期格式模式
inspection.suspicious.date.format.message.lower=使用了小写 ''{0}'' ({1}) 模式\: 预期可能为 ''{2}'' ({3})
inspection.suspicious.date.format.message.upper=使用了大写 ''{0}'' ({1}) 模式\: 预期可能为 ''{2}'' ({3})
inspection.suspicious.package.private.access.description={0} 是 {1}，但在不同的模块 ''{2}'' 中声明
inspection.suspicious.package.private.access.from.tests.description={0} 是 {1} 且在测试中使用，但在生产源中声明
inspection.suspicious.package.private.access.from.tests.problem=测试中的 {0} 重写了生产源中声明的 {1} 中的 package-private 方法
inspection.suspicious.package.private.access.problem={0} 重写了来自在不同模块 ''{2}'' 中声明的 {1} 的 package-private 方法
inspection.test.method.without.assertion.list.name=断言方法\:
inspection.test.method.without.assertions.exceptions.option=忽略声明异常的测试方法
inspection.trivial.functional.expression.usage.description=可以简化方法调用
inspection.type.may.be.weakened.add.stop.class.family=添加停止类
inspection.type.may.be.weakened.add.stop.class.selection.popup=选择停止类
inspection.type.may.be.weakened.add.stop.class.selection.table=停止类
inspection.type.may.be.weakened.add.stop.class.selection.table.label=停止类\:
inspection.type.may.be.weakened.add.stopper=作为停止类添加以减弱
inspection.type.may.be.weakened.add.stopper.preview=停止类将被添加到此检查的停止类列表中。
inspection.type.may.be.weakened.add.stopper.single=添加 {0} 作为停止类以削弱
inspection.type.may.be.weakened.display.name=类型可能被削弱
inspection.type.may.be.weakened.do.not.weaken.inferred.variable.type=不建议削弱声明为 'var' 的变量
inspection.type.may.be.weakened.field.problem.descriptor=字段 <code>\#ref</code> 的类型可能被削弱为 {0} \#loc
inspection.type.may.be.weakened.method.problem.descriptor=方法 <code>\#ref()</code> 的返回值类型可能被削弱为 {0} \#loc
inspection.type.may.be.weakened.only.weaken.to.an.interface=仅削弱为接口
inspection.type.may.be.weakened.parameter.problem.descriptor=形参 <code>\#ref</code> 的类型可能被削弱为 {0} \#loc
inspection.type.may.be.weakened.problem.descriptor=变量 <code>\#ref</code> 的类型可能被削弱为 {0} \#loc
inspection.type.may.be.weakened.quickfix=将类型削弱为 ''{0}''
inspection.type.may.be.weakened.weaken.type.family=削弱类型
inspection.unnecessary.string.escape.report.char.literals.option=报告字符字面量
inspection.unsupported.chrono.field.unit.call.display.name=使用不受支持的 'java.time.temporal.ChronoUnit' 和 'java.time.temporal.ChronoField' 调用方法
inspection.unsupported.chrono.value.message=不支持的实参值\: {0}
inspection.unsupported.chrono.values.message=不支持的实参值\: {0}
inspection.use.of.private.field.inner.classes.option=忽略来自内部类的访问
inspection.use.of.slash.s.display.name='\\s' 转义序列的非终止使用
inspection.use.of.slash.s.fix.family=将 '\\s' 序列替换为空格
inspection.use.of.slash.s.message=使用转义序列 '\\s' 作为非尾随空格
inspection.use.of.slash.s.non.text.block.message=在文本块之外使用转义序列 '\\s'
inspection.while.can.be.replaced.with.do.while.display.name='while' 可被替换为 'do while'
inspection.while.can.be.replaced.with.do.while.family.name=将 'while' 替换为 'do while'
inspection.while.can.be.replaced.with.do.while.message=将 'while' 替换为 'do while'
inspection.x.call.can.be.replaced.with.y=<code>\#ref()</code> 调用可被替换为 ''{0}()''
instance.Variable.may.not.be.initialized.problem.descriptor.junit=实例字段 <code>\#ref</code> 在对象构造或 'setUp()' 调用期间可能无法初始化 \#loc
instance.method.naming.convention.element.description=实例方法
instance.variable.may.not.be.initialized.display.name=实例字段可能无法初始化
instance.variable.may.not.be.initialized.problem.descriptor=实例字段 <code>\#ref</code> 在对象构造期间可能无法初始化 \#loc
instance.variable.naming.convention.element.description=实例字段
instance.variable.of.concrete.class.problem.descriptor=具体类 <code>\#ref</code> 的实例字段 ''{0}'' \#loc
instance.variable.used.before.initialized.display.name=实例字段在初始化前使用
instance.variable.used.before.initialized.problem.descriptor=初始化前使用的实例字段 <code>\#ref</code> \#loc
instanceof.catch.parameter.display.name='catch' 形参上的 'instanceof'
instanceof.catch.parameter.problem.descriptor='catch' 形参 <code>\#ref</code> 上的 'instanceof' \#loc
instanceof.check.for.this.display.name='this' 的 'instanceof' 检查
instanceof.check.for.this.equality.problem.descriptor='this' 的类比较 \#loc
instanceof.check.for.this.problem.descriptor=<code>\#ref</code> 的 'instanceof' 检查 \#loc
instanceof.concrete.class.equality.problem.descriptor=与具体类 <code>\#ref</code> 的类比较 \#loc
instanceof.concrete.class.pattern.problem.descriptor=针对具体类 <code>\#ref</code> 的模式测试 \#loc
instanceof.concrete.class.problem.descriptor='instanceof' 具体类 <code>\#ref</code> \#loc
instanceof.with.incompatible.interface.display.name=具有不兼容类型的 'instanceof'
instanceof.with.incompatible.interface.problem.descriptor=类型为 ''{1}'' 的表达式中具有不兼容{0, choice, 1\#接口|2\#类}的 ''instanceof'' <code>\#ref</code> \#loc
instantiating.datetimeformatter.without.locale.problem.descriptor=在未在国际化上下文中指定区域设置的情况下调用 <code>DateTimeFormatter.\#ref()</code> \#loc
instantiating.object.to.get.class.object.display.name=实例化对象以获取 'Class' 对象
instantiating.object.to.get.class.object.problem.descriptor=实例化对象以获取类对象 \#loc
instantiating.object.to.get.class.object.replace.quickfix=替换为直接类对象访问
instantiating.simpledateformat.without.locale.display.name=无区域设置的 'SimpleDateFormat'
instantiating.simpledateformat.without.locale.problem.descriptor=在未在国际化上下文中指定区域设置的情况下实例化 <code>\#ref</code> \#loc
instantiation.utility.class.display.name=实用程序类的实例化
instantiation.utility.class.problem.descriptor=实用程序类 <code>\#ref</code> 的实例化 \#loc
int.literal.may.be.long.literal.display.name=转换为 'long' 可以是 'long' 字面量
int.literal.may.be.long.literal.problem.descriptor=<code>\#ref</code> 可被替换为 ''{0}'' \#loc
integer.division.in.floating.point.context.display.name=浮点上下文中的整数除法
integer.division.in.floating.point.context.fix.family.name=将分子转换为浮点类型
integer.division.in.floating.point.context.fix.name=将分子转换为 ''{0}''
integer.division.in.floating.point.context.problem.descriptor=<code>\#ref</code>\: 浮点上下文中的整数除法 \#loc
integer.multiplication.implicit.cast.to.long.display.name=整数乘法或移位隐式转换为 'long'
integer.multiplication.implicit.cast.to.long.option=<html>忽略静态证明不可能溢出的表达式</html>
integer.multiplication.implicit.cast.to.long.problem.descriptor=\#ref\: 整数乘法隐式转换为 long \#loc
integer.multiplication.implicit.cast.to.long.quickfix=转换为 long
integer.shift.implicit.cast.to.long.problem.descriptor=\#ref\: 整数移位隐式转换为 long \#loc
interface.clashes.with.object.class.display.name=接口方法与 'Object' 中的方法冲突
interface.clashes.with.object.class.problem.descriptor=<code>\#ref()</code> 与 'java.lang.Object' 中的方法冲突
interface.may.be.annotated.functional.display.name=接口可以注解为 '@FunctionalInterface'
interface.may.be.annotated.functional.problem.descriptor=接口 <code>\#ref</code> 可以使用 @FunctionalInterface 注解
interface.naming.convention.element.description=接口
interface.never.implemented.display.name=没有具体子类的接口
interface.never.implemented.option=忽略仅声明常量的接口
interface.never.implemented.problem.descriptor=接口 <code>\#ref</code> 没有具体子类 \#loc
interface.one.inheritor.display.name=只有一个直接继承者的接口
interface.one.inheritor.problem.descriptor=只有一个直接继承者的接口 <code>\#ref</code> \#loc
introduce.holder.class.quickfix=引入 holder 类
introduce.variable.may.change.semantics.quickfix=引入变量 (可能更改语义)
introduce.variable.quickfix=引入变量
invert.method.quickfix=反转方法
invert.quickfix=反转 ''{0}''
invert.quickfix.family.name=反转布尔
iterator.hasnext.which.calls.next.display.name=调用 'next()' 的 'Iterator.hasNext()'
iterator.hasnext.which.calls.next.problem.descriptor=<code>Iterator.{0}()</code> 包含 ''\#ref()'' 调用 \#loc
iterator.next.does.not.throw.nosuchelementexception.display.name=无法抛出 'NoSuchElementException' 的 'Iterator.next()'
iterator.next.does.not.throw.nosuchelementexception.problem.descriptor=无法抛出 'NoSuchElementException' 的 <code>Iterator.\#ref()</code> '\#loc
java.lang.import.display.name='java.lang' 软件包中有不必要的 import
java.lang.import.problem.descriptor='java.lang' 软件包中有不必要的 import \#loc
jdbc.execute.with.non.constant.string.display.name='Statement.execute()' 调用具有非常量字符串
jdbc.execute.with.non.constant.string.problem.descriptor=<code>Statement.\#ref()</code> 调用具有非常量实参 \#loc
jdbc.prepare.statement.with.non.constant.string.display.name='Connection.prepare*()' 调用具有非常量字符串
jdbc.prepare.statement.with.non.constant.string.problem.descriptor=<code>Connection.\#ref()</code> 调用具有非常量实参 \#loc
jdbc.resource.opened.not.closed.display.name=JDBC 资源已打开，但未安全关闭
jndi.resource.opened.not.closed.display.name=JNDI 资源已打开，但未安全关闭
junit.abstract.test.class.naming.convention.element.description=抽象测试类
junit.test.class.naming.convention.element.description=测试类
junit.test.suite.naming.convention.element.description=测试套件
junit3.method.naming.convention.element.description=JUnit 3 测试方法
junit4.method.naming.convention.element.description=JUnit 4+ 测试方法
key.set.iteration.may.use.entry.set.display.name=可以优化对 'keySet()' 的迭代
key.set.iteration.may.use.entry.set.problem.descriptor=<code>\#ref</code> 上的迭代可被替换为 ''{0}'' 迭代 \#loc
key.set.iteration.may.use.entry.set.quickfix=优化 Map 迭代
labeled.statement.display.name=标记语句
labeled.statement.problem.descriptor=标记语句 <code>\#ref\:</code> \#loc
lambda.body.can.be.code.block.name=lambda 体可以是代码块
lambda.body.can.be.code.block.quickfix=将 lambda 体扩展为 {...}
lambda.can.be.replaced.with.anonymous.name=lambda 可被替换为匿名类
lambda.can.be.replaced.with.anonymous.quickfix=将 lambda 替换为匿名类
lambda.parameter.hides.member.variable.display.name=lambda 形参隐藏字段
lambda.parameter.hides.member.variable.ignore.invisible.option=忽略从 lambda 实际不可见的字段
lambda.parameter.hides.member.variable.problem.descriptor=lambda 形参 <code>\#ref</code> 隐藏类 ''{0}'' 中的字段 \#loc
lambda.parameter.naming.convention.display.name=lambda 形参命名约定
lambda.parameter.naming.convention.element.description=lambda 形参
lambda.parameter.type.can.be.specified.descriptor=Lambda 形参类型可以扩展为{0}
lambda.parameter.type.can.be.specified.family.quickfix=指定 lambda 形参类型
lambda.parameter.type.can.be.specified.name=可以指定 lambda 形参类型
lambda.parameter.type.can.be.specified.quickfix=将形参类型扩展为{0}
lambda.unfriendly.constructor.overload.problem.descriptor=构造函数 <code>\#ref()</code> 的重载对 lambda 不友好
lambda.unfriendly.method.overload.display.name=方法重载对 lambda 不友好
lambda.unfriendly.method.overload.problem.descriptor=方法 <code>\#ref()</code> 的重载对 lambda 不友好
large.array.allocation.no.outofmemoryerror.display.name=没有 OutOfMemoryError 检查的大型数组分配
large.array.allocation.no.outofmemoryerror.maximum.number.of.elements.option=最大元素数\:
large.array.allocation.no.outofmemoryerror.problem.descriptor=未检查内存不足情况的大型数组分配 \#loc
large.initializer.primitive.type.array.display.name=原始类型数组的过大初始值设定项
large.initializer.primitive.type.array.maximum.number.of.elements.option=最大元素数\:
large.initializer.primitive.type.array.problem.descriptor=具有太多元素 ({0}) 的原始数组初始值设定项 \#loc
law.of.demeter.display.name=迪米特法则
law.of.demeter.field.problem.descriptor=对 <code>\#ref()</code> 的访问违反迪米特法则 \#loc
law.of.demeter.ignore.library.calls.option=忽略对库方法的调用和对库字段的访问
law.of.demeter.problem.descriptor=对 <code>\#ref()</code> 的调用违反迪米特法则 \#loc
length.one.string.in.indexof.display.name='String.indexOf()' 调用中的单字符字符串实参
length.one.strings.in.concatenation.display.name=单字符字符串串联
length.one.strings.in.concatenation.replace.quickfix=替换为字符
limited.scope.inner.class.display.name=局部类
limited.scope.inner.class.problem.descriptor=局部类 <code>\#ref</code> \#loc
list.indexof.replaceable.by.contains.display.name='List.indexOf()' 表达式可被替换为 'contains()'
listener.may.use.adapter.display.name=类可以扩展适配器而不是实现侦听器
listener.may.use.adapter.emtpy.methods.option=仅在找到空实现方法时发出警告(&O)
listener.may.use.adapter.fix.family.name=替换为适配器
listener.may.use.adapter.problem.descriptor=类 ''{0}'' 可以扩展 ''{1}'' 而不是实现 <code>\#ref</code> \#loc
literal.as.arg.to.string.equals.display.name=字符串字面量可以为 'equals()' 限定符
literal.as.arg.to.string.equals.flip.quickfix=翻转 ''{0}()''
literal.as.arg.to.string.equals.problem.descriptor=字面量 \#ref 是 ''{0}()'' 的实参，而不是其限定符 \#loc
load.library.with.non.constant.string.display.name='System.loadLibrary()' 调用具有非常量字符串
load.library.with.non.constant.string.problem.descriptor=<code>{0}.\#ref()</code> 调用具有非常量实参 \#loc
local.variable.hides.member.variable.display.name=局部变量隐藏字段
local.variable.hides.member.variable.ignore.option=忽略隐藏非 static 字段的 static 上下文中的局部变量
local.variable.hides.member.variable.problem.descriptor=局部变量 <code>\#ref</code> 隐藏类 ''{0}'' 中的字段 \#loc
local.variable.naming.convention.display.name=局部变量命名约定
local.variable.naming.convention.element.description=局部变量
local.variable.naming.convention.ignore.catch.option=忽略 'catch' 块形参
local.variable.naming.convention.ignore.option=忽略 for 循环形参
local.variable.of.concrete.class.problem.descriptor=具体类 <code>\#ref</code> 的局部变量 ''{0}'' \#loc
log.condition.text=日志条件文本
log.method.name=记录方法名称
log.statement.guarded.by.log.condition.display.name=日志调用不受日志条件保护
log.statement.guarded.by.log.condition.flag.all.unguarded.option=标记所有不受保护的日志调用
log.statement.guarded.by.log.condition.problem.descriptor=<code>\#ref()</code> 日志调用不受日志条件保护 \#loc
log.statement.guarded.by.log.condition.quickfix=使用日志条件包围
log4j.use.parameterized.logger=对于 Log4j 2，请使用与形参化记录器相同的修正
log4j.use.parameterized.logger.description=对于 Log4j 2，如果类型无法推断，请使用与形参化记录器相同的修正；否则，将不会建议修正
logger.class.name=记录器类名\:
logger.factory.class.name=记录器工厂类名
logger.factory.method.name=记录器工厂方法名称
logger.initialized.with.foreign.class.display.name=使用外类初始化记录器
logger.initialized.with.foreign.class.fix.family.name=替换外类
logger.initialized.with.foreign.class.ignore.non.public.classes.option=忽略非 public 类中的记录器
logger.initialized.with.foreign.class.ignore.not.final.field=忽略未在 final 字段中初始化的记录器
logger.initialized.with.foreign.class.ignore.super.class.option=忽略使用超类初始化的记录器
logger.initialized.with.foreign.class.problem.descriptor=使用外类 <code>\#ref</code> 初始化记录器 \#loc
logger.name.option=记录器类名(&C)\:
long.literals.ending.with.lowercase.l.display.name='long' 字面量以 'l' 而不是 'L' 结尾
long.literals.ending.with.lowercase.l.problem.descriptor='long' 字面量 <code>\#ref</code> 以小写 'l' 结尾 \#loc
loop.condition.not.updated.inside.loop.display.name=循环变量未在循环内更新
loop.condition.not.updated.inside.loop.problem.descriptor=条件 '\#ref' 未在循环内更新\#loc
loop.statements.that.dont.loop.display.name=不循环的循环语句
loop.statements.that.dont.loop.problem.descriptor=<code>\#ref</code> 语句未循环 \#loc
loop.variable.not.updated.inside.loop.option.nonlocal=忽略可能的非本地更改
loop.variable.not.updated.inside.loop.problem.descriptor=变量 '\#ref' 未在循环内更新\#loc
loop.with.implicit.termination.condition.display.name=具有隐式终止条件的循环
loop.with.implicit.termination.condition.dowhile.problem.descriptor=具有隐式终止条件的 <code>\#ref-while</code> 循环 \#loc
loop.with.implicit.termination.condition.problem.descriptor=具有隐式终止条件的 <code>\#ref</code> 循环 \#loc
loop.with.implicit.termination.condition.quickfix=使条件显式
magic.character.display.name=魔幻字符
magic.character.problem.descriptor=国际化上下文中使用的魔幻字符 <code>\#ref</code> \#loc
magic.number.display.name=幻数
magic.number.problem.descriptor=幻数 <code>\#ref</code> \#loc
make.class.final.fix.family.name=将类设为 final
make.class.final.fix.name=将类 ''{0}'' 设为 ''final''
make.constructor.public=将构造函数设为 'public'
make.field.final.fix.family.name=设为 final
make.field.final.quickfix=将 ''{0}'' 设为 ''final''
make.field.static.final.fix.family.name=设为 static final
make.initialization.explicit.quickfix=使初始化显式
make.method.ctr.quickfix=使方法成为构造函数
make.method.final.fix.family.name=将方法设为 'final'
make.method.final.fix.name=将方法 ''{0}()'' 设为 ''final''
make.package.private.fix.family.name=设为 package-private
make.static.final.quickfix=将 ''{0}'' 设为 static final
make.static.quickfix=设为 'static'
malformed.format.string.display.name=字符串的格式错误
malformed.format.string.problem.descriptor.arguments.do.not.match.type=实参类型 ''{0}'' 与格式说明符 ''{1}'' 的类型不匹配 \#loc
malformed.format.string.problem.descriptor.at.least.too.few.arguments=格式字符串的实参过少(实际\: {0}，至少应为\: {1}) \#loc
malformed.format.string.problem.descriptor.illegal=非法格式字符串指定符\: {0} \#loc
malformed.format.string.problem.descriptor.malformed=格式字符串 <code>\#ref</code> 的格式错误 \#loc
malformed.format.string.problem.descriptor.too.few.arguments=格式字符串的实参太少(实际\: {0}，应为\: {1}) \#loc
malformed.format.string.problem.descriptor.too.many.arguments=格式字符串的实参太多(实际\: {0}，应为\: {1}) \#loc
manual.array.copy.display.name=手动数组复制
manual.array.copy.problem.descriptor=手动数组复制 \#loc
manual.array.to.collection.copy.display.name=手动数组到集合复制
manual.array.to.collection.copy.problem.descriptor=手动数组到集合复制 \#loc
map.replaceable.by.enum.map.display.name='Map' 可被替换为 'EnumMap'
map.replaceable.by.enum.map.problem.descriptor=<code>\#ref</code> 可被替换为 'EnumMap' \#loc
markdown.documentation.comments.migration.display.name=Javadoc 注释可以是 Markdown 文档注释
markdown.documentation.comments.migration.fix=转换为 Markdown 文档注释
marker.interface.display.name=标记接口
marker.interface.problem.descriptor=标记接口 <code>\#ref</code> \#loc
masked.assertion.display.name=断言通过 'catch' 禁止
masked.assertion.problem.description=''{0}'' 不能失败，因为它被包围 ''catch'' 禁止
math.random.cast.to.int.display.name='Math.random()' 转换为 'int'
math.random.cast.to.int.problem.descriptor=<code>\#ref</code> 转换为 ''{0}'' 时始终向下舍入为 ''0'' \#loc
math.random.cast.to.int.quickfix=添加括号以在转换前执行乘法
math.rounding.with.int.argument.display.name=使用 'int' 实参调用数学舍入
math.rounding.with.int.argument.family.name=简化舍入调用
math.rounding.with.int.argument.problem.descriptor=带有 'int' 类型实参的 <code>\#ref()</code> \#loc
math.rounding.with.int.argument.quickfix=简化 ''{0}()'' 调用
meta.annotation.without.runtime.retention=不含 '@Retention(RUNTIME)' 注解的测试注解
method.call.in.loop.condition.display.name=循环条件下的方法调用
method.call.in.loop.condition.problem.descriptor=循环条件下调用方法 <code>\#ref()</code> \#loc
method.can.be.variable.arity.method.display.name=方法可以有 varargs 形参
method.can.be.variable.arity.method.ignore.all.primitive.arrays.option=忽略所有原始数组类型
method.can.be.variable.arity.method.ignore.byte.short.option=忽略具类型为 byte[] 或 short[] 的形参
method.can.be.variable.arity.method.ignore.multidimensional.arrays.option=忽略多维数组形参
method.can.be.variable.arity.method.ignore.multiple.arrays.option=忽略具有多个数组形参的方法
method.can.be.variable.arity.method.problem.descriptor=<code>\#ref()</code> 可以转换为 vararg 方法 \#loc
method.complexity.limit.option=方法复杂度限制\:
method.count.ignore.getters.setters.option=忽略简单的 getter 和 setter 方法(&I)
method.count.limit.option=方法计数限制\:
method.coupling.display.name=过度耦合的方法
method.coupling.limit.option=方法耦合限制\:
method.coupling.problem.descriptor=<code>\#ref</code> 过度耦合 (\# 引用的类 \= {0}) \#loc
method.may.be.static.display.name=方法可以为 'static'
method.may.be.static.empty.option=忽略空方法
method.may.be.static.ignore.default.methods.option=忽略 'default' 方法
method.may.be.static.only.option=仅检查 'private' 或 'final' 方法
method.may.be.static.problem.descriptor=方法 <code>\#ref()</code> 可能为 'static' \#loc
method.may.be.static.replaces.qualifiers.with.class.references.option=快速修复可将实例限定符替换为类引用
method.may.be.synchronized.display.name=只有一个 'synchronized' 块的方法可被替换为 'synchronized' 方法
method.may.be.synchronized.problem.descriptor=带 synchronized 块的方法 <code>\#ref()</code> 可以是 synchronized 方法 \#loc
method.may.be.synchronized.quickfix=将方法设为 synchronized 并移除 synchronized 块
method.name.regex=方法名称正则表达式
method.name.same.as.class.name.display.name=方法名称与类名相同
method.name.same.as.class.name.problem.descriptor=方法名称 <code>\#ref</code> 与其类名相同 \#loc
method.name.same.as.parent.name.display.name=方法名称与父类名相同
method.name.same.as.parent.name.problem.descriptor=方法名称 <code>\#ref</code> 与其父类名相同 \#loc
method.names.differ.only.by.case.display.name=方法名称仅大小写不同
method.names.differ.only.by.case.problem.descriptor=方法名称 <code>\#ref</code> 和方法名称 ''{0}'' 仅大小写不同 \#loc
method.only.used.from.inner.class.display.name=仅在内部类中使用 private 方法
method.only.used.from.inner.class.ignore.option=忽略从匿名类或局部类调用的方法(&A)
method.only.used.from.inner.class.problem.descriptor=方法 <code>\#ref()</code>\#loc 只能从{0, choice, 1\#内部|2\#局部|3\#}{1, choice, 1\#类|2\#接口|3\#派生的匿名类|4\#注解类型|5\#枚举|6\#记录} ''{2}'' 使用 \#loc
method.overloads.display.name=可能是超类方法意外重载
method.overloads.problem.descriptor=当可能打算重写时，方法 <code>\#ref()</code> 重载超类的兼容方法 \#loc
method.overloads.report.incompatible.option=即使形参类型不兼容，也会报告
method.overrides.inaccessible.method.display.name=方法重写了超类不可访问的方法
method.overrides.package.local.method.problem.descriptor=方法 <code>\#ref()</code> 重写了位于另一个软件包中的超类的 package-private 方法 \#loc
method.overrides.private.display.name.problem.descriptor=方法 <code>\#ref()</code> 重写了超类的 'private' 方法 \#loc
method.overrides.static.display.name=方法尝试重写超类的 'static' 方法
method.overrides.static.problem.descriptor=方法 <code>\#ref()</code> 尝试重写超类的 static 方法 \#loc
method.ref.can.be.replaced.with.lambda.name=方法引用可被替换为 lambda
method.ref.can.be.replaced.with.lambda.quickfix=将方法引用替换为 lambda
method.ref.can.be.replaced.with.lambda.quickfix.no.side.effects=将可能的副作用保留在 lambda 内部
method.ref.can.be.replaced.with.lambda.quickfix.side.effects=将可能的副作用提取到变量中
method.return.always.constant.display.name=方法返回类特定的常量
method.return.always.constant.problem.descriptor=方法 <code>\#ref()</code> 及其所有派生方法始终返回常量
method.return.concrete.class.problem.descriptor=方法返回一个具体类 <code>\#ref</code> \#loc
method.with.multiple.loops.display.name=具有多个循环的方法
method.with.multiple.loops.problem.descriptor=<code>\#ref</code> 包含 {0} 个循环 \#loc
mismatched.read.write.array.display.name=数组的读取和写入不匹配
mismatched.read.write.array.problem.descriptor.read.not.write=数组 <code>\#ref</code> 的内容已读取，但从未被写入 \#loc
mismatched.read.write.array.problem.descriptor.write.not.read=数组 <code>\#ref</code> 的内容已写入，但从未被读取 \#loc
mismatched.string.builder.queried.problem.descriptor=<code>{0} \#ref</code> 的内容已查询，但从未更新 \#loc
mismatched.string.builder.query.update.display.name='StringBuilder' 的查询和更新不匹配
mismatched.string.builder.updated.problem.descriptor=<code>{0} \#ref</code> 的内容已更新，但从未被查询 \#loc
mismatched.update.collection.display.name=不匹配的集合查询和更新
mismatched.update.collection.problem.description.no.effect.updates=对空集合 <code>\#ref</code> 进行的更新操作无效 \#loc
mismatched.update.collection.problem.description.queried.empty=空集合 <code>\#ref</code> 的内容已被查询，但从未填充 \#loc
mismatched.update.collection.problem.description.queried.not.updated=集合 <code>\#ref</code> 的内容已被查询，但从未更新 \#loc
mismatched.update.collection.problem.description.updated.not.queried=集合 <code>\#ref</code> 的内容已更新，但从未被查询 \#loc
misordered.assert.equals.arguments.display.name=顺序错误的 'assertEquals()' 实参
misordered.assert.equals.arguments.flip.quickfix=翻转比较实参
misordered.assert.equals.arguments.problem.descriptor=<code>\#ref()</code> 的实参顺序错误 \#loc
missing.add.deprecated.javadoc.tag.quickfix=添加 '@deprecated' Javadoc 标记说明
missing.deprecated.annotation.add.quickfix=添加 '@Deprecated' 注解
missing.deprecated.annotation.display.name=缺少 '@Deprecated' 注解
missing.deprecated.annotation.problem.descriptor=缺少 '@Deprecated' 注解 \#loc
missing.deprecated.tag.option=警告缺少 @deprecated Javadoc 标记说明
missing.deprecated.tag.problem.descriptor=缺少 '@deprecated' Javadoc 标记说明 \#loc
missing.override.annotation.display.name=缺少 '@Override' 注解
missing.override.annotation.in.overriding.problem.descriptor=重写方法未使用 '@Override' 注解
missing.override.annotation.problem.descriptor=缺少关于 <code>\#ref()</code> 的 '@Override' 注解 \#loc
missing.override.warn.on.super.option=当方法的重写方法并非全部具有 '@Override' 注解时，高亮显示该方法
missing.package.html.problem.descriptor=软件包 ''{0}'' 缺少 <code>package.html</code> 文件
missing.package.info.display.name=缺少 'package-info.java'
missing.package.info.problem.descriptor=软件包 ''{0}'' 缺少 <code>package-info.java</code> 文件
missing.serial.annotation.display.name=可以使用 '@Serial' 注解
missing.serial.annotation.on.field.problem.descriptor=<code>\#ref</code> 可以使用 '@Serial' 进行注解
missing.serial.annotation.on.method.problem.descriptor=<code>\#ref()</code> 可以使用 '@Serial' 进行注解
missorted.modifiers.allowed.place=TYPE_USE 注解遵循生成选项
missorted.modifiers.allowed.place.description=启用此选项时，如果目标 TYPE_USE 注解的位置不符合<pre>设置 | 编辑器 | 代码样式 | Java | 代码生成</pre>中的 <pre>{0}</pre> 选项，将报告目标 TYPE_USE 注解。禁用此选项时，目标 TYPE_USE 注解可以直接位于类型之前或修饰符关键字之前。
missorted.modifiers.display.name=错位修饰符
missorted.modifiers.problem.descriptor=错位修饰符 <code>{0}</code> \#loc
missorted.modifiers.require.option=检查注解顺序
missorted.modifiers.require.option.description=使用此选项可以报告错误位置的注解\: 带有 <code>ElementType.TYPE_USE</code> 的注解<em>不</em>直接位于类型之前且位于修饰符关键字之后，或者其他注解<em>不</em>位于修饰符关键字之前。禁用此选项时，注解可以位于修饰符关键字之前或之后。将始终报告位于修饰符关键字之间的注解。
missorted.modifiers.sort.quickfix=对修饰符排序
misspelled.equals.display.name='equal()' 代替 'equals()'
misspelled.equals.problem.descriptor=<code>\#ref()</code> 方法可能应当是 'equals()' \#loc
module.with.too.few.classes.display.name=类过少的模块
module.with.too.few.classes.min.option=最小类数\:
module.with.too.few.classes.problem.descriptor=模块 ''{0}'' 包含过少的类 ({1} < {2})
module.with.too.many.classes.display.name=类过多的模块
module.with.too.many.classes.max.option=最大类数\:
module.with.too.many.classes.problem.descriptor=模块 ''{0}'' 包含过多的类 ({1} > {2})
move.anonymous.to.inner.quickfix=转换为命名内部类
move.class.quickfix=移动类
move.exception.to.javadoc.fix.family.name=移至 Javadoc '@throws'
move.local.to.inner.quickfix=转换为内部类
multi.catch.can.be.split.name=多 catch 可拆分为单独的 catch 块
multi.catch.can.be.split.quickfix=将多 catch 拆分为单独的 'catch' 块
multiple.declaration.array.only.option=仅在单个声明中对不同的数组维度发出警告
multiple.declaration.display.name=一个声明中的多个变量
multiple.declaration.ignore.for.option=忽略 'for' 循环声明
multiple.declaration.problem.descriptor=一个声明中的多个变量 \#loc
multiple.loggers.display.name=具有多个记录器的类
multiple.loggers.problem.descriptor=类 <code>\#ref</code> 声明多个记录器 \#loc
multiple.return.points.per.method.display.name=具有多个返回点的方法
multiple.return.points.per.method.problem.descriptor=<code>\#ref</code> 具有 {0} 个返回点 \#loc
multiple.top.level.classes.in.file.display.name=单个文件中的多个顶级类
multiple.top.level.classes.in.file.problem.descriptor=文件中的多个顶级类
multiple.typed.declaration.problem.descriptor=在一个声明中具有不同数组维度的变量 \#loc
multiply.or.divide.by.power.of.two.display.name=乘以或除以 2 的幂
multiply.or.divide.by.power.of.two.divide.option=还通过 2 的幂检查除法
multiply.or.divide.by.power.of.two.replace.quickfix=替换为移位
naked.notify.display.name=没有相应状态更改的 'notify()' 或 'notifyAll()'
naked.notify.problem.descriptor=在没有相应状态更改的情况下调用 <code>\#ref()</code> \#loc
naming.convention.problem.descriptor.long={0} 名称 <code>\#ref</code> 过长({1} > {2}) \#loc
naming.convention.problem.descriptor.regex.mismatch={0} 名称 <code>\#ref</code> 不匹配正则表达式 ''{1}'' \#loc
naming.convention.problem.descriptor.short={0} 名称 <code>\#ref</code> 过短({1} < {2}) \#loc
native.method.display.name=本地方法
native.method.naming.convention.element.description='native' 方法
native.method.problem.descriptor=声明为 <code>\#ref</code> 的方法不可移植 \#loc
negated.conditional.display.name=具有否定条件的条件表达式
negated.conditional.expression.display.name=否定条件表达式
negated.conditional.expression.problem.descriptor=否定条件表达式 \#loc
negated.conditional.expression.quickfix=移除否定
negated.conditional.invert.quickfix=反转条件
negated.conditional.problem.descriptor=具有否定条件的条件表达式 \#loc
negated.equality.expression.display.name=否定相等表达式
negated.equality.expression.problem.descriptor=否定 ''{0}'' \#loc
negated.equality.expression.quickfix=移除否定
negated.if.else.display.name=具有否定条件的 'if' 语句
negated.if.else.ignore.negated.null.option=忽略 '\!\= null' 比较
negated.if.else.ignore.negated.zero.option=忽略 '\!\= 0' 比较
negated.if.else.invert.quickfix=反转 'if' 条件
negated.if.else.problem.descriptor=带嵌套条件的 <code>\#ref</code> 语句 \#loc
negative.int.constant.in.long.context.display.name=长整型上下文中的负整型十六进制常量
negative.int.constant.in.long.context.fix.add.suffix=添加 'L' 后缀(更改语义)
negative.int.constant.in.long.context.fix.convert=转换为长整型常量(保留语义)
negatively.named.boolean.variable.display.name=否定命名的布尔变量
negatively.named.boolean.variable.problem.descriptor=布尔变量 <code>\#ref</code> 已否定命名 \#loc
nested.assignment.display.name=嵌套赋值
nested.assignment.problem.descriptor=使用的赋值表达式的结果 \#loc
nested.conditional.expression.display.name=嵌套条件表达式
nested.conditional.expression.problem.descriptor=嵌套条件表达式 <code>\#ref</code> \#loc
nested.method.call.display.name=嵌套方法调用
nested.method.call.ignore.option=忽略字段初始值设定项中的嵌套方法调用
nested.method.call.problem.descriptor=嵌套方法调用 <code>\#ref()</code> \#loc
nested.switch.statement.display.name=嵌套 'switch' 语句
nested.switch.statement.problem.descriptor=嵌套 <code>\#ref</code> {0} \#loc
nested.synchronized.statement.display.name=嵌套 'synchronized' 语句
nested.synchronized.statement.problem.descriptor=嵌套 <code>\#ref</code> 语句 \#loc
nested.try.statement.display.name=嵌套 'try' 语句
nested.try.statement.problem.descriptor=嵌套 <code>\#ref</code> 语句 \#loc
nesting.depth.display.name=过度嵌套的方法
nesting.depth.limit.option=嵌套深度限制\:
nesting.depth.problem.descriptor=<code>\#ref</code> 过度嵌套 (最大嵌套深度 \= {0}) \#loc
new.exception.without.arguments.display.name=未使用实参调用异常构造函数
new.exception.without.arguments.problem.descriptor=<code>new \#ref()</code> 没有实参 \#loc
new.method.naming.convention.display.name=方法命名约定
new.string.buffer.replaceable.by.string.problem.descriptor=<code>\#ref</code> 可被替换为 'String' \#loc
new.string.buffer.with.char.argument.display.name=StringBuilder 构造函数调用具有 'char' 实参
new.string.buffer.with.char.argument.problem.descriptor=<code>new \#ref()</code> 具有 'char' 类型的实参 \#loc
new.string.buffer.with.char.argument.quickfix=将字符实参替换为字符串字面量
no.logger.display.name=不带记录器的类
no.logger.problem.descriptor=类 <code>\#ref</code> 未声明记录器 \#loc
non.atomic.operation.on.volatile.field.display.name='volatile' 字段上的非原子操作
non.atomic.operation.on.volatile.field.problem.descriptor=volatile 字段 <code>\#ref</code> 上的非原子操作 \#loc
non.boolean.method.name.must.not.start.with.question.display.name=非布尔方法名称不能以疑问词开头
non.boolean.method.name.must.not.start.with.question.problem.descriptor=非布尔方法名称 <code>\#ref</code> 以疑问词开头 \#loc
non.comment.source.statements.display.name=过长的方法
non.comment.source.statements.limit.option=非注释源语句限制\:
non.comment.source.statements.problem.descriptor=<code>\#ref</code> 过长 (\# 非注释源语句 \= {0}) \#loc
non.constant.logger.display.name=非常量记录器
non.constant.logger.problem.descriptor=非常量记录器字段 <code>\#ref</code> \#loc
non.exception.name.ends.with.exception.display.name=非异常类名以 'Exception' 结尾
non.exception.name.ends.with.exception.problem.descriptor=非异常类名 <code>\#ref</code> 以 'Exception' 结尾 \#loc
non.exception.name.ends.with.exception.quickfix=使 ''{0}'' 扩展 ''java.lang.Exception''
non.final.clone.display.name=非 final 'clone()' 位于安全上下文中
non.final.clone.problem.descriptor=非 final <code>\#ref()</code> 方法，影响安全性 \#loc
non.final.field.compareto.display.name='compareTo()' 中引用了非 final 字段
non.final.field.compareto.problem.descriptor=在 'compareTo()' 中访问了非 final 字段 <code>\#ref</code> \#loc
non.final.field.in.enum.display.name='enum' 中的非 final 字段
non.final.field.in.enum.problem.descriptor=枚举 ''{0}'' 中存在非 final 字段 <code>\#ref</code> \#loc
non.final.field.in.enum.quickfix.option=忽略无法成为 'final' 的字段
non.final.field.in.equals.display.name='equals()' 中引用了非 final 字段
non.final.field.in.equals.problem.descriptor=在 'equals()' 中访问了非 final 字段 <code>\#ref</code> \#loc
non.final.field.in.hashcode.display.name='hashCode()' 中引用了非 final 字段
non.final.field.in.hashcode.problem.descriptor=在 'hashCode()' 中访问了非 final 字段 <code>\#ref</code> \#loc
non.final.field.of.exception.display.name='Exception' 类的非 final 字段
non.final.field.of.exception.problem.descriptor=异常类的非 final 字段 <code>\#ref</code> \#loc
non.final.static.variable.initialization.display.name=在类初始化期间使用非 final static 字段
non.final.static.variable.initialization.problem.descriptor=在类初始化期间使用非 final static 字段 <code>\#ref</code> \#loc
non.final.utility.class.display.name=实用程序类不为 'final'
non.final.utility.class.problem.descriptor=实用程序类 <code>\#ref</code> 不为 'final' \#loc
non.protected.constructor.in.abstract.class.display.name=抽象类中的 public 构造函数
non.protected.constructor.in.abstract.class.ignore.option=对非 public 类忽略
non.protected.constructor.in.abstract.class.problem.descriptor=抽象类的构造函数 <code>\#ref()</code> 不应声明为 'public' \#loc
non.public.clone.display.name='clone()' 方法不是 'public'
non.public.clone.problem.descriptor=<code>\#ref()</code> 方法不是 'public' \#loc
non.reproducible.math.call.display.name=对 'Math' 的不可重现调用
non.reproducible.math.call.problem.descriptor=<code>Math.\#ref()</code> 可能产生不可重现的结果 \#loc
non.reproducible.math.call.replace.quickfix=替换为 'StrictMath' 调用
non.serializable.@interface.with.serialversionuid.problem.descriptor=定义 'serialVersionUID' 字段的不可序列化 @interface <code>\#ref</code> \#loc
non.serializable.anonymous.with.serialversionuid.problem.descriptor=派生自 <code>\#ref</code> 的不可序列化匿名类定义 'serialVersionUID' 字段 \#loc
non.serializable.class.with.readwriteobject.display.name=具有 'readObject()' 或 'writeObject()' 的不可序列化类
non.serializable.class.with.readwriteobject.problem.descriptor.both=不可序列化{0, choice, 1\#类|2\#接口|3\#派生的匿名类|4\#注解类型|5\#枚举|6\#记录} <code>\#ref</code> 定义 'readObject()' 和 'writeObject()' \#loc
non.serializable.class.with.readwriteobject.problem.descriptor.read=不可序列化{0, choice, 1\#类|2\#接口|3\#派生的匿名类|4\#注解类型|5\#枚举|6\#记录} <code>\#ref</code> 定义 'readObject()' \#loc
non.serializable.class.with.readwriteobject.problem.descriptor.write=不可序列化{0, choice, 1\#类|2\#接口|3\#派生的匿名类|4\#注解类型|5\#枚举|6\#记录} <code>\#ref</code> 定义 'writeObject()' \#loc
non.serializable.class.with.serialversionuid.problem.descriptor=定义 'serialVersionUID' 字段的不可序列化类 <code>\#ref</code> \#loc
non.serializable.component.in.serializable.record.problem.descriptor=Serializable 记录中存在非 Serializable 组件 '\#ref' \#loc
non.serializable.field.in.serializable.class.display.name='Serializable' 类中有不可序列化的字段
non.serializable.field.in.serializable.class.problem.descriptor=Serializable 类中存在非 Serializable 字段 '\#ref' \#loc
non.serializable.interface.with.serialversionuid.problem.descriptor=定义 'serialVersionUID' 字段的不可序列化接口 <code>\#ref</code> \#loc
non.serializable.object.bound.to.http.session.display.name=不可序列化的对象被绑定到了 'HttpSession'
non.serializable.object.bound.to.http.session.problem.descriptor=传递给 HttpSession 的不可序列化对象 \#loc
non.serializable.object.passed.to.object.stream.display.name=不可序列化的对象被传递给了 'ObjectOutputStream'
non.serializable.object.passed.to.object.stream.problem.descriptor=传递给 ObjectOutputStream 的不可序列化对象 \#loc
non.serializable.with.serialversionuid.display.name=具有 'serialVersionUID' 的不可序列化类
non.short.circuit.boolean.expression.display.name=非短路布尔表达式
non.short.circuit.boolean.expression.problem.descriptor=非短路布尔表达式 <code>\#ref</code> \#loc
non.short.circuit.boolean.expression.replace.quickfix=替换为短路表达式
non.synchronized.method.overrides.synchronized.method.display.name=未同步方法重写 'synchronized' 方法
non.synchronized.method.overrides.synchronized.method.problem.descriptor=未同步方法 <code>\#ref()</code> 重写 synchronized 方法 \#loc
non.thread.safe.lazy.initialization.display.name=不安全的 'static' 字段延迟初始化
non.thread.safe.lazy.initialization.problem.descriptor='static' 字段 <code>\#ref</code> 的延迟初始化不是线程安全 \#loc
none=无
noop.method.in.abstract.class.display.name='abstract' 类中的无运算方法
noop.method.in.abstract.class.problem.descriptor=无操作方法 <code>\#ref()</code> 应当设为 abstract \#loc
normalize.declaration.quickfix=拆分为单独的声明
not.object.equals.can.be.equality.problem.descriptor=<code>\!\#ref()</code> 可被替换为 '\!\='
notify.called.on.condition.display.name=在 'java.util.concurrent.locks.Condition' 对象上调用了 'notify()' 或 'notifyAll()'
notify.called.on.condition.problem.descriptor=在条件对象上调用 <code>\#ref()</code> \#loc
notify.without.corresponding.wait.display.name=没有相应 'wait()' 的 'notify()'
notify.without.corresponding.wait.problem.descriptor=在没有相应 <code>wait()</code> 的情况下调用 <code>\#ref()</code> \#loc
null.argument.to.var.arg.method.display.name=引起混淆的 vararg 方法实参
null.argument.to.var.arg.method.problem.descriptor=引起混淆的实参 <code>\#ref</code>，不清楚是否需要 vararg 或非 vararg 调用 \#loc
null.thrown.display.name=已抛出 'null'
null.thrown.problem.descriptor=已抛出 <code>\#ref</code> \#loc
number.comparison.display.name=使用 '\=\=' 而不是 'equals()' 进行数字比较
number.comparison.problem.descriptor=使用 <code>\#ref</code> 而不是 'equals()' 来比较数字对象 \#loc
object.allocation.in.loop.display.name=循环中的对象分配
object.allocation.in.loop.new.descriptor=循环中的对象分配 <code>new \#ref()</code> \#loc
object.allocation.in.loop.problem.array.initializer.descriptor=循环中的数组分配 \#loc
object.allocation.in.loop.problem.call.descriptor=对象分配通过循环中的 <code>\#ref()</code> 调用完成 \#loc
object.allocation.in.loop.problem.lambda.descriptor=对象分配通过捕获循环中的 lambda 完成 \#loc
object.allocation.in.loop.problem.methodref.descriptor=对象分配通过循环中的实例绑定方法引用 <code>\#ref()</code> 完成 \#loc
object.allocation.in.loop.problem.string.concat=对象分配通过循环中的字符串串联完成 \#loc
object.comparison.display.name=使用 '\=\=' 而不是 'equals()' 进行对象比较
object.comparison.enumerated.ignore.option=忽略枚举变量之间的 '\=\='
object.comparison.klass.ignore.option=忽略没有 'equals()' 实现的 final 类类型之间的 '\=\='
object.comparison.problem.description=使用 <code>\#ref</code> 而不是 'equals()' 来比较对象值 \#loc
object.equality.ignore.between.objects.of.a.type.with.only.private.constructors.option=忽略只有 'private' 构造函数的类型对象之间的 '\=\='
object.equals.can.be.equality.display.name='equals()' 调用可被替换为 '\=\='
object.equals.can.be.equality.problem.descriptor=<code>\#ref()</code> 可被替换为 '\=\='
object.instantiation.inside.equals.or.hashcode.display.name='equals()' 或 'hashCode()' 内部的对象实例化
object.instantiation.inside.equals.or.hashcode.problem.descriptor=''{0}()'' 内部的对象实例化 \#loc
object.instantiation.inside.equals.or.hashcode.problem.descriptor2=''{0}()'' ({1}) 内部的对象实例化 \#loc
object.notify.display.name=调用 'notify()' 而不是 'notifyAll()'
object.notify.problem.descriptor=<code>\#ref</code> 可能应当替换为 'notifyAll()' \#loc
objects.hash.fix.family.name=使用 'Arrays.hashCode()' 包装
objects.hash.problem.descriptor=传递给 'Objects.hash()' 的数组应包装在 'Arrays.hashcode()' 中
octal.and.decimal.integers.in.same.array.display.name=同一数组中的八进制和十进制整数
octal.and.decimal.integers.in.same.array.problem.descriptor=同一数组初始值设定项中的八进制和十进制整数 \#loc
octal.literal.display.name=八进制整数
octal.literal.problem.descriptor=八进制整数 <code>\#ref</code> \#loc
only.report.public.methods.option=仅报告 'public' 方法
only.report.qualified.static.usages.option=仅报告来自 static 上下文的限定静态访问
only.report.static.methods=仅报告 'static' 方法(&O)
only.warn.on.protected.clone.methods=仅对 'protected' 克隆方法发出警告
only.warn.on.public.clone.methods=仅对 'public' 克隆方法发出警告
optional.contains.array.problem.descriptor='Optional' 包含数组 <code>\#ref</code>
optional.contains.collection.display.name='Optional' 包含数组或集合
optional.contains.collection.problem.descriptor='Optional' 包含集合 <code>\#ref</code>
optional.used.as.field.or.parameter.type.display.name=用作字段或形参类型的 'Optional'
optional.used.as.field.type.problem.descriptor=<code>\#ref</code> 用作字段 ''{0}'' 的类型
optional.used.as.parameter.type.problem.descriptor=<code>\#ref</code> 用作形参 ''{0}'' 的类型
options.label.ignored.classes=已忽略的类\:
options.title.ignored.classes=已忽略的类
overloaded.methods.with.same.number.parameters.display.name=具有相同形参数量的重载方法
overloaded.methods.with.same.number.parameters.option=<html>忽略形参类型绝对不兼容的重载方法</html>
overloaded.methods.with.same.number.parameters.problem.descriptor=具有相同数量形参的多个方法命名 <code>\#ref</code> \#loc
overloaded.vararg.constructor.problem.descriptor=重载 vararg 构造函数 <code>\#ref()</code> \#loc
overloaded.vararg.method.display.name=重载 vararg 方法
overloaded.vararg.method.problem.descriptor=重载 vararg 方法 <code>\#ref()</code> \#loc
overloaded.vararg.method.problem.option=忽略形参类型绝对不兼容的重载方法
overly.broad.throws.clause.display.name=过宽的 'throws' 子句
overly.broad.throws.clause.ignore.thrown.option=忽略隐藏其他异常但自身被抛出的异常(&H)
overly.broad.throws.clause.problem.descriptor1=<code>throws \#ref</code> 过宽，掩码异常 ''{0}'' \#loc
overly.broad.throws.clause.problem.descriptor2=<code>throws \#ref</code> 过宽，掩码异常 ''{0}'' 和 ''{1}'' \#loc
overly.broad.throws.clause.quickfix1=添加特定异常
overly.broad.throws.clause.quickfix2=替换为特定异常
overly.broad.throws.clause.threshold.option=要报告的最大隐藏异常数\:
overly.complex.anonymous.inner.class.display.name=过度复杂的匿名类
overly.complex.anonymous.inner.class.problem.descriptor=过度复杂的匿名类 (循环复杂度 \= {0}) \#loc
overly.complex.arithmetic.expression.display.name=过于复杂的算术表达式
overly.complex.arithmetic.expression.max.number.option=最大项数\:
overly.complex.arithmetic.expression.problem.descriptor=过于复杂的算术表达式 \#loc
overly.complex.boolean.expression.display.name=过度复杂的布尔表达式
overly.complex.boolean.expression.ignore.option=忽略纯合取和析取
overly.complex.boolean.expression.max.terms.option=最大项数\:
overly.complex.boolean.expression.problem.descriptor=过度复杂的布尔表达式 ({0} 项) \#loc
overly.complex.class.display.name=过度复杂的类
overly.complex.class.problem.descriptor=过度复杂的类<code>\#ref</code> (循环复杂度 \= {0}) \#loc
overly.coupled.class.class.coupling.limit.option=类耦合限制\:
overly.coupled.class.display.name=过度耦合的类
overly.coupled.class.problem.descriptor=<code>\#ref</code> 过度耦合 (依赖 \= {0}) \#loc
overly.long.lambda.display.name=过长的 lambda 表达式
overly.long.lambda.problem.descriptor=lambda 表达式过长 (\# 非注释源语句 \= {0}) \#loc
overly.strong.type.cast.display.name=过强的类型转换
overly.strong.type.cast.ignore.in.matching.instanceof.option=忽略具有匹配 instanceof 表达式的转换
overly.strong.type.cast.problem.descriptor=到 <code>\#ref</code> 的转换可以被削弱为 ''{0}'' \#loc
overly.strong.type.cast.weaken.quickfix=削弱过强的转换
overridable.method.call.in.constructor.display.name=对象构造期间调用的可重写方法
overridable.method.call.in.constructor.problem.descriptor=对象构造期间调用可重写方法 <code>\#ref()</code> \#loc
overridden.method.call.in.constructor.display.name=重写的方法在对象构造期间调用
overridden.method.call.in.constructor.problem.descriptor=对象构造期间调用已重写方法 <code>\#ref()</code> \#loc
package.dot.html.may.be.package.info.convert.quickfix=转换为 'package-info.java'
package.dot.html.may.be.package.info.delete.quickfix=删除 'package.html'
package.dot.html.may.be.package.info.display.name='package.html' 可以转换为 'package-info.java'
package.dot.html.may.be.package.info.exists.problem.descriptor=<code>package.html</code> 被忽略，因为 <code>package-info.java</code> 存在
package.dot.html.may.be.package.info.problem.descriptor=<code>package.html</code> 可以转换为 <code>package-info.java</code>
package.in.multiple.modules.display.name=具有多个模块中的类的软件包
package.in.multiple.modules.problem.descriptor.many=软件包 ''{0}'' 具有模块 ''{1}''、''{2}'' 以及其他 {3} 个模块中的类
package.in.multiple.modules.problem.descriptor2=软件包 ''{0}'' 具有模块 ''{1}'' 和 ''{2}'' 中的类
package.in.multiple.modules.problem.descriptor3=软件包 ''{0}'' 具有模块 ''{1}''、''{2}'' 和 ''{3}'' 中的类
package.info.java.without.package.display.name=不带 'package' 语句的 'package-info.java'
package.info.without.package.family.quickfix=添加 package 语句
package.info.without.package.problem.descriptor='package-info.java' 没有 'package' 语句
package.info.without.package.quickfix=添加 ''package {0};''
package.local.field.not.accessible=package-private 字段 ''{0}'' 无法从此处访问
package.local.private=package-private 与 private
package.naming.convention.display.name=软件包命名约定
package.naming.convention.problem.descriptor.long=软件包名称 <code>{0}</code> 过长
package.naming.convention.problem.descriptor.regex.mismatch=软件包名称 <code>{0}</code> 与正则表达式 ''{1}'' 不匹配
package.naming.convention.problem.descriptor.short=软件包名称 <code>{0}</code> 过短
package.visible.field.display.name=软件包可见字段
package.visible.field.problem.descriptor=软件包可见字段 <code>\#ref</code> \#loc
package.visible.inner.class.display.name=软件包可见的嵌套类
package.visible.inner.class.ignore.enum.option=忽略软件包可见的内部枚举
package.visible.inner.class.ignore.interface.option=忽略软件包可见的内部接口
package.visible.inner.class.problem.descriptor=软件包可见的嵌套类 <code>\#ref</code> \#loc
package.with.too.few.classes.display.name=软件包具有过少类
package.with.too.few.classes.min.option=最小类数\:
package.with.too.few.classes.problem.descriptor=软件包 ''{0}'' 包含过少的类 ({1} < {2})
package.with.too.many.classes.display.name=类过多的软件包
package.with.too.many.classes.max.option=最大类数\:
package.with.too.many.classes.problem.descriptor=软件包 ''{0}'' 包含过多的类 ({1} > {2})
parameter.hides.member.variable.display.name=形参隐藏字段
parameter.hides.member.variable.ignore.abstract.methods.option=对 abstract 方法忽略
parameter.hides.member.variable.ignore.constructors.option=对构造函数忽略
parameter.hides.member.variable.ignore.setters.option=对属性 setter 忽略
parameter.hides.member.variable.ignore.static.parameters.option=对隐藏实例字段的 static 方法形参忽略
parameter.hides.member.variable.ignore.superclass.option=忽略从子类不可见的超类字段
parameter.hides.member.variable.problem.descriptor=形参 <code>\#ref</code> 隐藏类 ''{0}'' 中的字段 \#loc
parameter.limit.option=形参限制\:
parameter.name.differs.from.overridden.parameter.display.name=形参名称与重写或重载方法中的形参不同
parameter.name.differs.from.overridden.parameter.ignore.character.option=如果重写的形参仅包含一个字符，则忽略
parameter.name.differs.from.overridden.parameter.ignore.library.option=如果重写的形参来自库，则忽略
parameter.name.differs.from.overridden.parameter.problem.descriptor=形参名 <code>\#ref</code> 不同于{1, choice, 1\#super 方法|2\#重载方法|3\#super 构造函数|4\#重载构造函数}中的形参 ''{0}'' \#loc
parameter.naming.convention.display.name=方法形参命名约定
parameter.naming.convention.element.description=形参
parameter.type.prevents.overriding.display.name=形参类型阻止重写
parameter.type.prevents.overriding.family.quickfix=更改形参类型
parameter.type.prevents.overriding.problem.descriptor=形参类型 <code>\#ref</code> 位于 ''{0}''，而 super 方法形参类型位于 ''{1}''，可防止重写 \#loc
parameter.type.prevents.overriding.quickfix=将形参类型更改为 ''{0}''
parameters.per.constructor.display.name=形参过多的构造函数
parameters.per.constructor.problem.descriptor=<code>\#ref()</code> 的形参过多(形参数量 \= {0}) \#loc
parameters.per.method.display.name=形参过多的方法
parameters.per.method.problem.descriptor=<code>\#ref()</code> 的形参过多(形参数量 \= {0}) \#loc
pattern.variable.hides.field.display.name=模式变量隐藏字段
pattern.variable.hides.field.problem.descriptor=模式变量 <code>\#ref</code> 隐藏类 ''{0}'' 中的字段 \#loc
pointless.arithmetic.expression.display.name=无意义的算术表达式
pointless.bitwise.expression.display.name=无意义的按位表达式
pointless.bitwise.expression.simplify.quickfix=简化
pointless.boolean.expression.display.name=无意义的布尔表达式
pointless.boolean.expression.ignore.option=在确定无意义表达式时忽略命名常量
pointless.indexof.comparison.always.false.problem.descriptor=<code>\#ref</code> 始终为 false \#loc
pointless.indexof.comparison.always.true.problem.descriptor=<code>\#ref</code> 始终为 true \#loc
pointless.indexof.comparison.display.name=无意义的 'indexOf()' 比较
pointless.nullcheck.display.name=方法调用前出现不必要的 'null' 检查
pointless.nullcheck.problem.descriptor.call=''{0}()'' 调用之前的 ''null'' 检查不必要
possible.throw.from.finally.block.problem.descriptor=<code>{0}</code> 可能在 ''finally'' 块内抛出 \#loc
prefer.empty.array.options.mode.always=始终
prefer.empty.array.options.mode.always.never=从不(首选预设大小的数组)
prefer.empty.array.options.mode.by.level=根据语言级别
prefer.empty.array.options.title=首选空数组\:
prefix.operation.quickfix.family.name=替换为前缀运算符
press.escape.to.remove.highlighting.message=按 Esc 移除高亮显示
primitive.array.argument.to.var.arg.method.display.name=引起混淆的 vararg 方法基元数组实参
primitive.array.argument.to.var.arg.method.problem.descriptor=引起混淆的 vararg 方法基元数组实参 \#loc
primitive.fields.ignore.option=忽略原始字段
printstacktrace.call.display.name=调用 'printStackTrace()'
printstacktrace.call.problem.descriptor=对 <code>\#ref()</code> 的调用可能应当替换为更可靠的日志 \#loc
private=private
private.field.not.accessible.problem.descriptor=''private'' 字段 ''{0}'' 无法从此处访问
private.member.access.between.outer.and.inner.classes.display.name=合成访问器调用
private.member.access.between.outer.and.inner.classes.make.constructor.package.local.quickfix=将 ''{0}'' 构造函数设为 package-private
private.member.access.between.outer.and.inner.classes.make.local.quickfix=将 ''{0}'' 设为 package-private
private.member.access.between.outer.and.inner.classes.problem.descriptor=访问类 ''{0}'' 的 ''private'' 成员需要合成访问器 \#loc
problematic.varargs.method.display.name=非 vararg 方法重写 vararg 方法
problematic.varargs.method.override.problem.descriptor=非 vararg 方法 <code>\#ref()</code> 重写 vararg 方法 \#loc
progress.text.analyzing.package.0=正在分析软件包 {0}
properties.object.as.hashtable.display.name=将 'Properties' 对象用作 'Hashtable'
properties.object.as.hashtable.problem.descriptor=在属性对象上调用 <code>Hashtable.\#ref()</code> \#loc
property.value.set.to.itself.display.name=属性值设置为自身
protected.field.display.name=protected 字段
protected.field.not.accessible.problem.descriptor=''protected'' 字段 ''{0}'' 无法从此处访问
protected.field.problem.descriptor=protected 字段 <code>\#ref</code> \#loc
protected.inner.class.display.name=protected 嵌套类
protected.inner.class.ignore.enum.option=忽略 'protected' 内部枚举
protected.inner.class.ignore.interface.option=忽略 'protected' 内部接口
protected.inner.class.problem.descriptor=protected 嵌套类 <code>\#ref</code> \#loc
protected.member.in.final.class.display.name='protected' 成员位于 'final' 类中
protected.member.in.final.class.problem.descriptor=类成员在 'final' 类中被声明为 <code>\#ref</code> \#loc
protected.package.local.private=protected、package-private 和 private
public.constructor.display.name='public' 构造函数可被替换为工厂方法
public.constructor.in.non.public.class.display.name='public' 构造函数位于非 public 类中
public.constructor.in.non.public.class.problem.descriptor=构造函数在非 public 类 ''{0}'' 中被声明为 <code>\#ref</code> \#loc
public.constructor.in.non.public.class.quickfix=将构造函数设为 private
public.constructor.problem.descriptor=public 构造函数 <code>\#ref()</code> \#loc
public.constructor.quickfix=将构造函数替换为工厂方法
public.default.constructor.problem.descriptor=类 <code>\#ref</code> 具有默认 'public' 构造函数
public.field.accessed.in.synchronized.context.display.name=在 'synchronized' 上下文中访问d了非 private 字段
public.field.accessed.in.synchronized.context.problem.descriptor=在同步上下文中访问非 private 字段 <code>\#ref</code> \#loc
public.field.display.name='public' 字段
public.field.ignore.enum.type.fields.option=忽略枚举类型的 'public final' 字段
public.field.problem.descriptor='public' 字段 <code>\#ref</code> \#loc
public.inner.class.display.name='public' 嵌套类
public.inner.class.ignore.enum.option=忽略 'public' 内部枚举
public.inner.class.ignore.interface.option=忽略 'public' 内部接口
public.inner.class.problem.descriptor='public' 嵌套类 <code>\#ref</code> \#loc
public.method.not.in.interface.display.name='public' 方法在接口中未公开
public.method.not.in.interface.option=<html>如果包含类未实现非库接口，则忽略</html>
public.method.not.in.interface.problem.descriptor='public' 方法 <code>\#ref()</code> 未通过接口公开 \#loc
public.method.without.logging.display.name='public' 方法没有日志记录
public.method.without.logging.problem.descriptor='public' 方法 <code>\#ref()</code> 没有日志调用 \#loc
public.static.array.field.display.name='public static' 数组字段
public.static.array.field.problem.descriptor='public static' 数组字段 <code>\#ref</code>，影响安全性 \#loc
public.static.collection.field.display.name='public static' 集合字段
public.static.collection.field.problem.descriptor='public static' 集合字段 <code>\#ref</code>，影响安全性 \#loc
qualify.call.fix.family.name=限定调用
query.label=查询名称开头\:
questionable.name.display.name=可疑名称
questionable.name.list.label=报告的名称\:
questionable.name.problem.descriptor=可疑名称 <code>\#ref</code> \#loc
random.double.for.random.integer.display.name=使用 'Random.nextDouble()' 获取随机整数
random.double.for.random.integer.problem.descriptor=使用 <code>Random.\#ref</code> 创建随机整数 \#loc
raw.use.of.parameterized.type.display.name=形参化类的原始使用
readobject.initialization.display.name=实例字段可能无法被 'readObject()' 初始化
readobject.initialization.problem.descriptor=实例字段 <code>\#ref</code> 在 'readObject()' 调用期间可能无法初始化 \#loc
readresolve.writereplace.protected.display.name='readResolve()' 或 'writeReplace()' 未被声明为 'protected'
readresolve.writereplace.protected.problem.descriptor=<code>\#ref()</code> 未被声明为 'protected' \#loc
readwriteobject.private.display.name='readObject()' 或 'writeObject()' 未被声明为 'private'
readwriteobject.private.problem.descriptor=<code>\#ref</code> 未被声明为 'private' \#loc
recordstore.opened.not.safely.closed.display.name=打开了 'RecordStore'，但未安全关闭
redundant.as.list.for.iteration.fix.name=解包
redundant.as.list.for.iteration.problem=不必要的 'Arrays.asList()' 调用
redundant.call.problem.descriptor=冗余调用 <code>\#ref()</code> \#loc
redundant.else.display.name=冗余的 'else'
redundant.else.problem.descriptor=<code>\#ref</code> 分支可以解包，因为 'if' 分支永远不会正常完成 \#loc
redundant.else.unwrap.quickfix=移除冗余的 'else'
redundant.escape.in.regex.replacement.display.name=正则表达式替换字符串中的冗余转义
redundant.escape.in.regex.replacement.problem.descriptor=''{0}'' 的冗余转义
redundant.escape.in.regex.replacement.quickfix=移除冗余转义
redundant.explicit.var.type.display.name=可以省略局部变量类型
redundant.field.initialization.display.name=冗余字段初始化
redundant.field.initialization.problem.descriptor=<code>\#ref</code> 的字段初始化是冗余的 \#loc
redundant.field.initialization.remove.quickfix=移除初始值设定项
redundant.implements.display.name=冗余接口声明
redundant.implements.problem.descriptor=冗余接口声明 <code>\#ref</code> \#loc
redundant.implements.remove.quickfix=移除冗余接口声明
redundant.local.variable.annotation.option=忽略具有注解的变量
redundant.local.variable.display.name=冗余局部变量
redundant.local.variable.ignore.option=忽略立即返回或抛出的变量
redundant.method.override.delegate.quickfix=将方法替换为到 super 的委托
redundant.method.override.delegates.to.super.problem.descriptor=方法 <code>\#ref()</code> 仅委托给 super 方法 \#loc
redundant.method.override.display.name=方法与其 super 方法相同
redundant.method.override.option.check.library.methods=检查重写库方法的方法
redundant.method.override.option.ignore.delegates=忽略到 super 方法的委托
redundant.method.override.problem.descriptor=方法 <code>\#ref()</code> 与其 super 方法相同 \#loc
redundant.method.override.quickfix=移除冗余方法
redundant.string.format.call.display.name=冗余调用 'String.format()'
redundant.string.format.call.quickfix=移除对 'String.format()' 的冗余调用
redundant.string.formatted.call.quickfix=移除对 'String.formatted()' 的冗余调用
referencing.subclass.0.from.superclass.1.initializer.might.lead.to.class.loading.deadlock=从超类 {1} 初始值设定项引用子类 {0} 可能会导致类加载死锁
reflection.for.unavailable.annotation.display.name=对仅源注解的反射访问
reflection.for.unavailable.annotation.problem.descriptor=注解 '\#ref' 不保留用于反射访问 \#loc
refused.bequest.display.name=方法不调用 super 方法
refused.bequest.fix.family.name=将调用插入 super 方法
refused.bequest.ignore.default.super.methods.option=忽略 'default' super 方法
refused.bequest.ignore.empty.super.methods.option=忽略空 super 方法
refused.bequest.problem.descriptor=方法 <code>\#ref()</code> 未调用 'super.\#ref()' \#loc
remove.annotation.parameter.0.fix.name=移除注解形参 ''{0}''
remove.call.fix.family.name=移除调用
remove.cloneable.quickfix=从 'implements' 子句中移除 'Cloneable'
remove.finally.block.quickfix=移除 'finally' 块
remove.leading.zero.to.make.decimal.quickfix=移除前导零以变为十进制
remove.leading.zeroes.to.make.decimals.quickfix=移除前导零以变为十进制
remove.loop.fix.family.name=移除循环
remove.modifier.fix.family.name=移除修饰符
remove.modifier.quickfix=移除 ''{0}'' 修饰符
remove.redundant.polyadic.operand.fix.family.name=移除不必要的条件
remove.redundant.polyadic.operand.fix.name=移除不必要的 ''{0}'' 条件
remove.redundant.string.fix.text=使用 ''{0}()'' 并移除冗余的 ''{1}()'' 调用
remove.redundant.substring.fix.family.name=移除冗余的 'substring()' 调用
remove.try.finally.block.quickfix=移除 'try-finally' 块
remove.unnecessary.0.call.quickfix=移除不必要的 ''{0}()'' 调用
rename.quickfix=重命名
renameto.quickfix=重命名为 ''{0}''
replace.all.dot.display.name=可疑的正则表达式实参
replace.all.dot.problem.descriptor=''{0}()'' 调用中存在可疑的正则表达式 \#ref \#loc
replace.all.dot.quickfix=转义正则表达式元字符
replace.all.file.separator.problem.descriptor=File.separator 用作正则表达式；无法在 Windows 上工作
replace.anonymous.with.lambda.body.fix.family.name=将调用替换为方法体
replace.case.default.null.with.null.default=将 'case default, null' 替换为 'case null, default'
replace.case.default.with.default=将 'case default' 替换为 'default'
replace.cast.fix.family.name=替换转换类型
replace.casted.literal.with.just.literal.fix.family.name=替换为 {0} 字面量
replace.field.reference.fix.family.name=替换字段引用
replace.field.reference.fix.text=将字段引用替换为 ''{0}''
replace.inheritance.with.delegation.quickfix=将继承替换为委托
replace.instanceof.fix.family.name=替换 instanceOf 类型
replace.method.call.fix.family.name=替换方法调用
replace.method.call.fix.text=将方法调用替换为 ''{0}''
replace.method.ref.with.qualifier.fix.family.name=替换为限定符
replace.method.ref.with.qualifier.problem.lambda=lambda 可被替换为调用限定符
replace.method.ref.with.qualifier.problem.method=方法引用可被替换为限定符
replace.with.cast.fix.family.name=替换为转换
replace.with.catch.clause.for.runtime.exception.quickfix=针对 'RuntimeException' 替换为 'catch' 子句
replace.with.comparator.fix.family.name=使用 'Comparator' static 方法简化比较器
replace.with.lambda.body.fix.family.name=将 lambda 上的方法调用替换为 lambda 体
replace.with.method.ref.fix.family.name=将 lambda 替换为方法引用
replace.with.method.ref.fix.name.may.change.semantics=将 lambda 替换为方法引用(可能更改语义)
replace.with.method.reference.fix.family.name=将方法引用上的方法调用替换为相应的方法调用
replace.with.var.fix.family.name=将显式类型替换为 'var'
resource.opened.not.closed.problem.descriptor=''{0}'' 应在 ''try'' 块之前打开，并在相应的 ''finally'' 块中关闭 \#loc
result.of.method.call.ignored.class.column.title=类名
result.of.method.call.ignored.display.name=方法调用的结果已忽略
result.of.method.call.ignored.non.library.option=报告所有忽略的非库调用
result.of.method.call.ignored.problem.descriptor=<code>{0}.\#ref()</code> 的结果已忽略 \#loc
result.of.object.allocation.fix.name=忽略类型 ''{0}'' 的对象的分配
result.of.object.allocation.ignored.display.name=对象分配的结果已忽略
result.of.object.allocation.ignored.options.chooserTitle=选择可以忽略对象分配的类
result.of.object.allocation.ignored.problem.descriptor=<code>new \#ref()</code> 的结果已忽略 \#loc
result.of.object.allocation.ignored.problem.descriptor.methodRef=在 <code>\#ref</code> 内部分配的对象已被舍弃 \#loc
return.from.finally.block.display.name='return' 位于 'finally' 块内
return.from.finally.block.problem.descriptor='return' 位于 'finally' 块内 \#loc
return.of.anonymous.class.problem.descriptor=返回匿名类的实例 \#loc
return.of.collection.field.fix.family.name=使返回集合 'unmodifiable'
return.of.field.with.mutable.type.problem.descriptor={0} 字段 <code>\#ref</code> 的返回值 \#loc
return.of.inner.class.display.name=返回匿名、局部或内部类的实例
return.of.inner.class.ignore.non.public.option=忽略非 public 方法的返回值
return.of.inner.class.problem.descriptor=返回非 static 内部类 <code>{0}</code> 的实例 \#loc
return.of.local.class.problem.descriptor=返回局部类 <code>{0}</code> 的实例 \#loc
return.of.null.arrays.option=报告返回数组的方法
return.of.null.collections.option=报告返回集合对象的方法
return.of.null.display.name=返回 'null'
return.of.null.ignore.private.option=忽略 'private' 方法、匿名类和 lambda
return.of.null.objects.option=报告返回对象的方法
return.of.null.problem.descriptor=返回 <code>\#ref</code> \#loc
return.point.limit.option=返回点限制(&R)\:
return.this.display.name=返回 'this'
return.this.problem.descriptor=返回 <code>\#ref</code> \#loc
reuse.of.local.variable.display.name=局部变量的重用
reuse.of.local.variable.problem.descriptor=局部变量 <code>\#ref</code> 的重用 \#loc
reuse.of.local.variable.split.quickfix=拆分局部变量
runtime.exec.call.display.name=调用 'Runtime.exec()'
runtime.exec.call.problem.descriptor=对 <code>Runtime.\#ref()</code> 的调用不可移植 \#loc
runtime.exec.with.non.constant.string.display.name='Runtime.exec()' 调用具有非常量字符串
runtime.exec.with.non.constant.string.problem.descriptor=<code>Runtime.\#ref()</code> 调用具有非常量实参 \#loc
safe.lock.display.name=已获取但未安全解锁的锁
safe.lock.problem.descriptor=''{0}'' 应在 ''try'' 块之前锁定，并在相应的 ''finally'' 块中解锁 \#loc
sequenced.collection.method.can.be.used.ignore.option=忽略用作实参的命名常量
serial.annotation.used.on.wrong.member.display.name=对错误的成员使用了 '@Serial' 注解
serial.annotation.used.on.wrong.member.problem.descriptor=注解的成员不是序列化机制的一部分
serializable.anonymous.class.stores.non.serializable.problem.descriptor=可序列化匿名类隐式存储类型为 ''{0}'' 的不可序列化对象
serializable.class.in.secure.context.display.name=安全上下文中的可序列化类
serializable.class.in.secure.context.problem.descriptor=类 <code>\#ref</code> 可能被序列化，影响安全性 \#loc
serializable.deserializable.class.in.secure.context.problem.descriptor=类 <code>\#ref</code> 可能被序列化和反序列化，影响安全性 \#loc
serializable.has.serialization.methods.display.name=不带 'readObject()' 和 'writeObject()' 的可序列化类
serializable.has.serialization.methods.ignore.option=忽略未定义实例字段的类
serializable.has.serialization.methods.problem.descriptor=可序列化类 <code>\#ref</code> 未定义 'readObject()' 或 'writeObject()' \#loc
serializable.has.serialization.methods.problem.descriptor1=可序列化类 <code>\#ref</code> 未定义 'writeObject()' \#loc
serializable.has.serialization.methods.problem.descriptor2=可序列化类 <code>\#ref</code> 未定义 'readObject()' \#loc
serializable.inner.class.has.serial.version.uid.field.display.name=没有 'serialVersionUID' 的可序列化非 static 内部类
serializable.inner.class.has.serial.version.uid.field.problem.descriptor=内部类 <code>\#ref</code> 未定义 'serialVersionUID' 字段 \#loc
serializable.inner.class.with.non.serializable.outer.class.display.name=可序列化非 'static' 内部类具有不可序列化外部类
serializable.inner.class.with.non.serializable.outer.class.problem.descriptor=内部类 <code>\#ref</code> 可序列化，而其外部类不可序列化 \#loc
serializable.lambda.stores.non.serializable.problem.descriptor=可序列化 lambda 隐式存储类型为 ''{0}'' 的不可序列化对象
serializable.local.class.stores.non.serializable.problem.descriptor=可序列化局部类 ''{1}'' 隐式存储类型为 ''{0}'' 的不可序列化对象
serializable.record.contains.ignored.field.problem.descriptor=在记录序列化期间将忽略 <code>\#ref</code>
serializable.record.contains.ignored.members.display.name='record' 包含被忽略的成员
serializable.record.contains.ignored.method.problem.descriptor=在记录序列化期间将忽略 <code>\#ref()</code>
serializable.stores.non.serializable.display.name='Serializable' 对象隐式存储非 'Serializable' 对象
serializable.with.unconstructable.ancestor.display.name=具有不可构造上级的可序列化类
serializable.with.unconstructable.ancestor.problem.descriptor=<code>\#ref</code> 具有不带无实参构造函数的不可序列化上级 ''{0}'' \#loc
serialpersistentfields.with.wrong.signature.display.name='serialPersistentFields' 字段未被声明为 'private static final ObjectStreamField[]'
serialpersistentfields.with.wrong.signature.problem.descriptor=可序列化类的 <code>\#ref</code> 字段未被声明为 'private static final ObjectStreamField[]' \#loc
serialversionuid.private.static.final.long.display.name='serialVersionUID' 字段未被声明为 'private static final long'
serialversionuid.private.static.final.long.problem.descriptor=可序列化类的 <code>\#ref</code> 字段未被声明为 'private static final long' \#loc
serialversionuid.private.static.final.long.quickfix=将 serialVersionUID 设为 'private static final'
set.annotation.parameter.0.1.fix.name=将注解形参 {0} 设置为“{1}”
set.replaceable.by.enum.set.display.name='Set' 可被替换为 'EnumSet'
set.replaceable.by.enum.set.problem.descriptor=<code>\#ref</code> 可被替换为 'EnumSet' \#loc
shared.thread.local.random.display.name='ThreadLocalRandom' 实例可能是共享的
shared.thread.local.random.problem.descriptor='ThreadLocalRandom' 实例可能在线程之间共享
shift.operation.by.inappropriate.constant.display.name=按不当常量进行移位运算
shift.operation.by.inappropriate.constant.problem.descriptor.negative=对 <code>\#ref</code> 进行移位运算时使用的常量值 {0} 为负 \#loc
shift.operation.by.inappropriate.constant.problem.descriptor.out.of.bounds=按超出范围的值 {0} 进行移位运算 <code>\#ref</code> \#loc
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=对 <code>\#ref</code> 进行移位运算时使用的常量值 {0} 过大 \#loc
shift.out.of.range.fix.family.name=修复移位值
signal.without.corresponding.await.display.name=没有相应 'await()' 的 'signal()'
signal.without.corresponding.await.problem.descriptor=在没有相应 <code>await()</code> 的情况下调用 <code>\#ref()</code> \#loc
simplifiable.annotation.braces.problem.descriptor=注解中 <code>{0}</code> 周围不必要的圆括号 \#loc
simplifiable.annotation.display.name=可简化注解
simplifiable.annotation.problem.descriptor=注解中有不必要的 <code>\#ref</code> \#loc
simplifiable.annotation.quickfix=简化注解
simplifiable.annotation.whitespace.problem.descriptor=注解中有不必要的空格 \#loc
simplifiable.boolean.expression.display.name=可简化的布尔表达式
simplifiable.conditional.expression.display.name=可简化的条件表达式
simplifiable.conditional.expression.problem.descriptor=<code>{1}</code> 可以简化为 ''{0}'' \#loc
simplifiable.equals.expression.display.name='equals()' 调用之前的 'null' 检查不必要
simplifiable.equals.expression.option.non.constant=报告具有非常量非 null 实参的 equals
simplifiable.equals.expression.problem.descriptor=''{0}()'' 调用之前的 ''null'' 检查不必要 \#loc
simplifiable.equals.expression.quickfix=翻转 ''.{0}()'' 并移除不必要的 ''null'' 检查
simplifiable.junit.assertion.display.name=可简化断言
simplifiable.junit.assertion.problem.descriptor=<code>\#ref()</code> 可以简化为 ''{0}'' \#loc
simplify.junit.assertion.simplify.quickfix=简化断言
single.character.startswith.display.name=单个字符 'startsWith()' 或 'endsWith()'
single.character.startswith.problem.descriptor=单个字符 <code>\#ref()</code> 可被替换为 'charAt()' 表达式 \#loc
single.character.startswith.quickfix=替换为 'charAt()' 表达式
single.class.import.display.name=单个类导入
single.class.import.problem.descriptor=单个类导入 <code>\#ref</code> \#loc
single.element.annotation.family.quickfix=将注解扩展为标准形式
single.element.annotation.name=非规范化注解
single.element.annotation.quickfix=添加 'value\='
single.statement.in.block.descriptor=''{0}'' 包含单条语句
single.statement.in.block.family.quickfix=从语句中移除大括号
single.statement.in.block.name=代码块包含单条语句
single.statement.in.block.quickfix=从 ''{0}'' 语句中移除大括号
singleton.display.name=单例
singleton.problem.descriptor=类 <code>\#ref</code> 为单例 \#loc
size.replaceable.by.isempty.display.name='size() \=\= 0' 可被替换为 'isEmpty()'
size.replaceable.by.isempty.fix.ignore.calls=忽略类型 ''{1}'' 上的 ''.{0}()'' 调用
size.replaceable.by.isempty.negation.ignore.option=忽略将替换为 '\!isEmpty()' 的表达式
sleep.while.holding.lock.display.name=同步时调用 'Thread.sleep()'
sleep.while.holding.lock.problem.descriptor=同步时调用 <code>Thread.\#ref()</code> \#loc
smth.unnecessary.remove.quickfix=移除不必要的 ''{0}''
socket.opened.not.closed.display.name=套接字已打开，但未安全关闭
standard.variable.names.display.name=标准变量名称
standard.variable.names.ignore.override.option=对与 super 方法形参相同的形参名称忽略
standard.variable.names.problem.descriptor=变量命名 <code>\#ref</code> 没有类型 ''{0}'' \#loc
standard.variable.names.problem.descriptor2=变量命名 <code>\#ref</code> 没有类型 ''{0}'' 或 ''{1}'' \#loc
statement.problem.descriptor=<code>\#ref</code> 语句 \#loc
statement.with.empty.body.display.name=带空体的语句
statement.with.empty.body.include.option=包含空代码块语句正文
statement.with.empty.body.problem.descriptor=<code>\#ref</code> 语句具有空体 \#loc
static.collection.display.name=静态集合
static.collection.ignore.option=忽略弱静态集合或映射
static.collection.problem.descriptor=静态集合 <code>\#ref</code> \#loc
static.field.via.subclass.display.name=static 字段通过子类引用
static.field.via.subclass.problem.descriptor=static 字段 <code>\#ref</code> 在类 ''{0}'' 中声明，但通过子类 ''{1}'' 引用 \#loc
static.field.via.subclass.rationalize.quickfix=使 static 字段访问合理化
static.import.display.name=static import
static.import.fix.ignore.class=允许类 ''{0}'' 的 static import
static.import.options.border.title=静态可导入类\:
static.import.options.chooserTitle=选择静态可导入类
static.import.problem.descriptor=static import <code>\#ref</code>  \#loc
static.import.replace.quickfix=替换为非 static import
static.inheritance.display.name=静态继承
static.inheritance.fix.family.name=将继承替换为限定引用
static.inheritance.problem.descriptor=接口 <code>\#ref</code> 仅针对其 static 常量实现 \#loc
static.inheritance.replace.quickfix=将继承替换为 {0} 中的限定引用
static.initializer.references.subclass.display.name=static 初始值设定项引用子类
static.method.naming.convention.element.description='static' 方法
static.method.only.used.in.one.anonymous.class.problem.descriptor=static {0, choice, 1\#方法|2\#字段} <code>\#ref{0, choice, 1\#()|2\#}</code> 仅在派生自 ''{1}'' 的匿名类中使用 \#loc
static.method.only.used.in.one.class.display.name=static 成员仅在其他一个类中使用
static.method.only.used.in.one.class.ignore.anonymous.option=仅在匿名类中使用时忽略
static.method.only.used.in.one.class.ignore.on.conflicts=当方法无法在不产生冲突的情况下移动时忽略
static.method.only.used.in.one.class.ignore.test.option=仅在测试类中使用时忽略
static.method.only.used.in.one.class.ignore.utility.classes=忽略位于实用程序类中的成员
static.method.only.used.in.one.class.problem.descriptor=static {0, choice, 1\#方法|2\#字段} <code>\#ref{0, choice, 1\#()|2\#}</code> 仅在 ''{1}'' 类中使用 \#loc
static.method.only.used.in.one.class.quickfix=将 {0} 移至使用类
static.method.only.used.in.one.class.quickfix.preview=将 static 成员移至使用它的类。
static.method.via.subclass.display.name=static 方法通过子类引用
static.method.via.subclass.problem.descriptor=static 方法 <code>\#ref()</code> 在类 ''{0}'' 中声明，但通过子类 ''{1}'' 引用 \#loc
static.method.via.subclass.rationalize.quickfix=使 static 方法调用合理化
static.non.final.field.display.name='static' 非 'final' 字段
static.non.final.field.option=仅报告 'public' 字段
static.non.final.field.problem.descriptor='static' 非 'final' 字段 <code>\#ref</code> \#loc
static.variable.may.not.be.initialized.display.name=static 字段可能无法初始化
static.variable.may.not.be.initialized.problem.descriptor=static 字段 <code>\#ref</code> 在类初始化期间可能无法初始化 \#loc
static.variable.naming.convention.element.description='static' 字段
static.variable.of.concrete.class.problem.descriptor=具体类 <code>\#ref</code> 的 static 字段 ''{0}'' \#loc
static.variable.used.before.initialization.display.name=static 字段在初始化前使用
static.variable.used.before.initialization.problem.descriptor=static 字段 <code>\#ref</code> 在初始化前使用 \#loc
string.buffer.must.have.initial.capacity.display.name=没有初始容量的 'StringBuilder'
string.buffer.must.have.initial.capacity.problem.descriptor=没有初始容量的 <code>new \#ref()</code> \#loc
string.buffer.replaceable.by.string.builder.display.name='StringBuffer' 可能是 'StringBuilder'
string.buffer.replaceable.by.string.builder.problem.descriptor=<code>StringBuffer \#ref</code> 可能被声明为 'StringBuilder' \#loc
string.buffer.replaceable.by.string.display.name='StringBuilder' 可被替换为 'String'
string.buffer.replaceable.by.string.problem.descriptor=<code>{0} \#ref</code> 可被替换为 ''String'' \#loc
string.comparison.display.name=使用 '\=\=' 而不是 'equals()' 进行字符串比较
string.comparison.problem.descriptor=使用 <code>\#ref</code> 而不是 'equals()' 来比较字符串值 \#loc
string.concatenation.argument.to.log.call.display.name=非常量字符串串联作为日志调用的实参
string.concatenation.argument.to.log.call.problem.descriptor=非常量字符串作为 <code>\#ref()</code> 日志记录调用的实参 \#loc
string.concatenation.argument.to.log.call.quickfix=将串联替换为形参化的日志消息
string.concatenation.argument.to.log.message.format.call.quickfix=将 'Message.format()' 替换为形参化日志消息
string.concatenation.argument.to.log.string.format.call.quickfix=将 'String.format()' 替换为形参化日志消息
string.concatenation.display.name=字符串串联
string.concatenation.in.format.call.display.name=字符串串联作为 'format()' 调用的实参
string.concatenation.in.format.call.fix.family.name=将串联替换为实参
string.concatenation.in.format.call.problem.descriptor=''{0}()'' 调用包含字符串串联实参
string.concatenation.in.format.call.quickfix=将串联替换为单独的实参
string.concatenation.in.loops.display.name=字符串串联在循环中
string.concatenation.in.loops.problem.descriptor=循环中的字符串串联 <code>\#ref</code> \#loc
string.concatenation.in.message.format.call.display.name=字符串串联作为 'MessageFormat.format()' 调用的实参
string.concatenation.in.message.format.call.problem.descriptor=字符串串联作为 'MessageFormat.format()' 调用的实参 \#loc
string.concatenation.inside.string.buffer.append.display.name=字符串串联作为 'StringBuilder.append()' 调用的实参
string.concatenation.inside.string.buffer.append.problem.descriptor=字符串串联作为 <code>{0}.\#ref()</code> 调用的实参 \#loc
string.concatenation.inside.string.buffer.append.replace.quickfix=替换为链式 'append()' 调用
string.concatenation.introduce.fix=引入 StringBuilder
string.concatenation.introduce.fix.name=引入新的 {1} 以更新变量 ''{0}''
string.concatenation.introduce.fix.name.null.safe=引入新的 {1} 以更新变量 ''{0}'' (null 安全)
string.concatenation.missing.whitespace.display.name=字符串串联中可能缺少空格
string.concatenation.missing.whitespace.option=忽略具有变量字符串的串联
string.concatenation.missing.whitespace.problem.descriptor=字符串串联中可能缺少空格 \#loc
string.concatenation.problem.descriptor=国际化上下文中的字符串串联 <code>\#ref</code> \#loc
string.concatenation.replace.fix=替换为 StringBuilder
string.concatenation.replace.fix.name=将变量 ''{0}'' 从字符串转换为 {1}
string.concatenation.replace.fix.name.null.safe=将变量 ''{0}'' 从字符串转换为 {1} (null 安全)
string.equals.char.sequence.display.name=使用 'CharSequence' 实参调用了 'String.equals()'
string.equals.char.sequence.problem.descriptor=使用 ''{0}'' 实参调用了 <code>String.equals()</code> \#loc
string.equals.empty.string.display.name='String.equals()' 可被替换为 'String.isEmpty()'
string.equals.empty.string.fix.family.name=简化空字符串检查
string.equals.empty.string.is.empty.problem.descriptor=<code>\#ref("")</code> 可被替换为 'isEmpty()' \#loc
string.equals.empty.string.option.do.not.add.null.check=当有必要进行 null 检查时，不必报告
string.equals.empty.string.problem.descriptor=<code>\#ref("")</code> 可被替换为 'length()\=\=0' \#loc
string.format.choose.class=选择格式化程序类
string.format.class.label=附加格式化程序类\:
string.format.class.method.label=附加格式化程序方法\:
string.indexof.replaceable.by.contains.display.name='String.indexOf()' 表达式可被替换为 'contains()'
string.replace.quickfix=移除空字符串操作数
string.replaceable.by.string.buffer.display.name=非常量 'String' 可被替换为 'StringBuilder'
string.replaceable.by.string.buffer.in.loop.option=仅在循环中追加时发出警告
string.replaceable.by.string.buffer.problem.descriptor=非常量字符串 <code>\#ref</code> 可能应被声明为 'StringBuilder' \#loc
string.touppercase.tolowercase.without.locale.display.name=调用无区域设置的 'String.toUpperCase()' 或 'toLowerCase()'
string.touppercase.tolowercase.without.locale.problem.descriptor=在未使用国际化字符串指定区域设置的情况下调用 <code>String.\#ref()</code> \#loc
stringbuffer.field.display.name='StringBuilder' 字段
stringbuffer.field.problem.descriptor=''{0}'' 字段 <code>\#ref</code> \#loc
subtraction.in.compareto.display.name='compareTo()' 中的减法
subtraction.in.compareto.problem.descriptor='compareTo()' 中的减法 <code>\#ref</code> 可能导致溢出或精度损失 \#loc
super.class.logger.option=在超类有可访问的记录器时忽略
suppress.for.tests.scope.quickfix=对 'Tests' 作用域禁止
suspicious.array.cast.display.name=可疑的数组转换
suspicious.array.cast.problem.descriptor=可疑转换为 <code>\#ref</code> \#loc
suspicious.comparator.compare.descriptor.min.value=不建议从比较函数返回 Integer.MIN_VALUE
suspicious.comparator.compare.descriptor.non.negative=比较器从不返回负值
suspicious.comparator.compare.descriptor.non.positive=比较器从不返回正值
suspicious.comparator.compare.descriptor.non.reflexive=对于相等的元素，比较器不返回 0
suspicious.comparator.compare.descriptor.parameter.not.used=未使用 ''{0}()'' 形参 <code>\#ref</code> \#loc
suspicious.comparator.compare.display.name=可疑的 'Comparator.compare()' 实现
suspicious.getter.problem.descriptor=getter <code>\#ref()</code> 返回字段 ''{0}'' \#loc
suspicious.getter.setter.display.name=可疑的 getter/setter
suspicious.indent.after.control.statement.display.name=没有大括号的控制语句后存在可疑缩进
suspicious.indent.after.control.statement.problem.descriptor=''{0}'' 语句后存在可疑缩进 \#loc
suspicious.integer.div.assignment.display.name=可疑的整数除法赋值
suspicious.integer.div.assignment.problem.descriptor=除法结果被截断为整数
suspicious.integer.div.assignment.quickfix=转换为 double
suspicious.literal.underscore.display.name=数字字面量中的可疑下划线
suspicious.literal.underscore.problem.descriptor=带下划线的数字字面量中的组没有长度 3 \#loc
suspicious.package.private.access.display.name=可疑的 package-private 访问权限
suspicious.setter.problem.descriptor=setter <code>\#ref()</code> 对字段 ''{0}'' 赋值 \#loc
suspicious.system.arraycopy.display.name=可疑的 'System.arraycopy()' 调用
suspicious.system.arraycopy.problem.descriptor.length.bigger.dest=长度始终大于 ''dest.length - destPos'' {0}
suspicious.system.arraycopy.problem.descriptor.length.bigger.src=长度始终大于 ''src.length - srcPos'' {0}
suspicious.system.arraycopy.problem.descriptor.ranges.intersect=复制到具有相交范围的同一数组
suspicious.system.arraycopy.problem.descriptor4=<code>\#ref</code> 不是数组类型 \#loc
suspicious.system.arraycopy.problem.descriptor5=<code>\#ref</code> 不是数组类型 \#loc
suspicious.system.arraycopy.problem.descriptor6=源形参类型 ''{0}'' 不可分配给类型为 ''{1}'' 的目标形参 <code>\#ref</code> \#loc
suspicious.to.array.call.display.name=可疑的 'Collection.toArray()' 调用
suspicious.to.array.call.fix.family.name=替换为正确数组
suspicious.to.array.call.problem.descriptor=应为类型 ''{0}[]'' 的数组，找到的是 ''{1}[]'' \#loc
swap.equals.fix.family.name=翻转方法调用
switch.expression.with.single.default.message='switch' 表达式只有 'default' case
switch.expression.with.too.few.branches.problem.descriptor=''switch'' 表达式的 case 标签太少 ({0})，并且可能应当替换为 ''if'' 语句或条件运算符 \#loc
switch.statement.density.display.name='switch' 语句的分支密度过低
switch.statement.density.min.option=分支的最小密度\: %
switch.statement.density.problem.descriptor=<code>\#ref</code> 分支密度过低({0}%) \#loc
switch.statement.display.name='switch' 语句
switch.statement.with.confusing.declaration.display.name=在不同 'switch' 分支中使用并声明的局部变量
switch.statement.with.confusing.declaration.problem.descriptor=局部变量 <code>\#ref</code> 在一个 'switch' 分支中声明，并在另一个分支中使用 \#loc
switch.statement.with.single.default.message='switch' 语句只有 'default' case
switch.statement.with.too.few.branches.display.name=最小 'switch' 分支
switch.statement.with.too.few.branches.ignore.pattern.option=不报告模式 switch 语句
switch.statement.with.too.few.branches.min.option=最小分支数\:
switch.statement.with.too.few.branches.problem.descriptor=''switch'' 语句的 case 标签太少({0})，并且可能应当替换为 ''if'' 语句 \#loc
switch.statement.with.too.many.branches.display.name=最大 'switch' 分支
switch.statement.without.default.ignore.option=忽略详尽的 switch 语句
switch.statements.without.default.display.name=不带 'default' 分支的 'switch' 语句
switch.statements.without.default.problem.descriptor=没有 'default' 分支的 <code>\#ref</code> 语句 \#loc
synchronization.on.get.class.display.name=在 'getClass()' 上同步
synchronization.on.get.class.problem.descriptor=在 <code>\#ref()</code> 上同步 \#loc
synchronization.on.local.variable.or.method.parameter.display.name=在局部变量或方法形参上同步
synchronization.on.local.variable.problem.descriptor=在局部变量 <code>\#ref</code> 上同步 \#loc
synchronization.on.method.parameter.problem.descriptor=在方法形参 <code>\#ref</code> 上同步 \#loc
synchronization.on.static.field.display.name=在 'static' 字段上同步
synchronization.on.static.field.problem.descriptor=在 'static' 字段 <code>\#ref</code> 上同步 \#loc
synchronize.on.class.problem.descriptor=对类的锁定操作可能会产生不可预见的副作用 \#loc
synchronize.on.lock.display.name=在 'Lock' 对象上同步
synchronize.on.lock.problem.descriptor=在 ''{0}'' 对象上同步不太可能是故意的 \#loc
synchronize.on.non.final.field.display.name=在非 final 字段上同步
synchronize.on.non.final.field.problem.descriptor=在非 final 字段 <code>\#ref</code> 上同步 \#loc
synchronize.on.this.display.name=在 'this' 上同步
synchronize.on.this.problem.descriptor=对 'this' 的锁定操作可能会产生不可预见的副作用 \#loc
synchronized.method.display.name='synchronized' 方法
synchronized.method.ignore.synchronized.super.option=忽略重写 synchronized 方法的方法
synchronized.method.include.option=包含本地方法
synchronized.method.move.quickfix=将同步移至方法中
synchronized.method.problem.descriptor=方法 ''{0}()'' 被声明为 <code>\#ref</code> \#loc
synchronized.on.direct.literal.object.problem.descriptor=在 {0} 字面量 <code>\#ref</code> 上同步 \#loc
synchronized.on.literal.object.name=在使用字面量初始化的对象上同步
synchronized.on.literal.object.problem.descriptor=在使用字面量初始化的 {0} <code>\#ref</code> 上同步 \#loc
synchronized.on.literal.object.warn.on.all.option=警告所有可能的字面量
synchronized.on.possibly.literal.object.problem.descriptor=在 {0} <code>\#ref</code> 上同步 \#loc
system.exit.call.display.name=调用 'System.exit()' 或相关方法
system.exit.call.ignore.option=在 main 方法中忽略
system.exit.call.problem.descriptor=对 <code>{0}.\#ref()</code> 的调用不可移植 \#loc
system.getenv.call.display.name=调用 'System.getenv()'
system.getenv.call.problem.descriptor=对 <code>System.\#ref()</code> 的调用不可移植 \#loc
system.properties.display.name=系统属性的访问
system.properties.problem.descriptor=对 <code>Integer.\#ref()</code> 的调用可能造成安全问题 \#loc
system.properties.problem.descriptor1=对 <code>Boolean.\#ref()</code> 的调用可能造成安全问题 \#loc
system.run.finalizers.on.exit.display.name=调用 'System.runFinalizersOnExit()'
system.run.finalizers.on.exit.problem.descriptor=调用 <code>System.\#ref()</code> \#loc
system.set.problem.descriptor=对 <code>System.\#ref()</code> 的调用可能造成安全问题 \#loc
system.set.security.manager.display.name=调用 'System.setSecurityManager()'
system.set.security.manager.problem.descriptor=对 <code>System.\#ref()</code> 的调用可能造成安全问题 \#loc
tail.recursion.display.name=尾递归
tail.recursion.problem.descriptor=尾部递归调用 <code>\#ref()</code> \#loc
tail.recursion.replace.quickfix=用迭代替换尾部递归
text.label.in.switch.statement.display.name='switch' 语句中的文本标签
text.label.in.switch.statement.problem.descriptor='switch' {0, choice, 1\#语句|2\#表达式}中存在文本标签 <code>\#ref\:</code> \#loc
the.whole.project=整个项目
this.class=此类
this.reference.escaped.in.construction.display.name=对象构造中转义的 'this' 引用
this.reference.escaped.in.construction.problem.descriptor=对象构造期间转义 <code>\#ref</code> \#loc
thread.death.rethrown.display.name='ThreadDeath' 未重新抛出
thread.death.rethrown.problem.descriptor=ThreadDeath <code>\#ref</code> 未重新抛出 \#loc
thread.local.not.static.final.display.name='ThreadLocal' 字段未被声明为 'static final'
thread.local.not.static.final.problem.descriptor=ThreadLocal <code>\#ref</code> 未被声明为 'static final' \#loc
thread.local.set.with.null.display.name=以 null 作为实参的 'ThreadLocal.set()'
thread.local.set.with.null.problem.descriptor=使用 null 作为实参的 'ThreadLocal.set()' 可能会导致内存泄漏
thread.local.set.with.null.quickfix=替换为 'ThreadLocal.remove()' 调用
thread.priority.display.name=调用 'Thread.setPriority()'
thread.priority.problem.descriptor=调用 <code>Thread.\#ref()</code> \#loc
thread.run.problem.descriptor=对 <code>\#ref()</code> 的调用可能应当替换为 'start()' \#loc
thread.start.in.construction.display.name=对象构造期间调用 'Thread.start()'
thread.start.in.construction.problem.descriptor=对象构造期间调用 <code>\#ref()</code> \#loc
thread.stop.suspend.resume.display.name=调用 'Thread.stop()'、'suspend()' 或 'resume()'
thread.stop.suspend.resume.problem.descriptor=调用 <code>Thread.\#ref()</code> \#loc
thread.with.default.run.method.display.name=使用默认的 'run()' 方法实例化 'Thread'
thread.with.default.run.method.problem.descriptor=使用默认的 'run()' 方法实例化 <code>\#ref</code> \#loc
thread.yield.display.name=调用 'Thread.yield()'
thread.yield.problem.descriptor=调用 <code>Thread.\#ref()</code> \#loc
three.negations.per.method.display.name=具有三个以上否定的方法
three.negations.per.method.ignore.assert.option=忽略 'assert' 语句中的否定
three.negations.per.method.ignore.option=忽略 'equals()' 方法中的否定
three.negations.per.method.problem.descriptor=<code>\#ref</code> 包含 {0} 个否定 \#loc
throw,from.finally.block.everywhere.option=在可能抛出已声明异常的每一处发出警告
throw.caught.locally.display.name=通过包含 'try' 语句捕获 'throw'
throw.caught.locally.ignore.option=忽略重新抛出的异常
throw.caught.locally.problem.descriptor=通过包含 'try' 语句捕获 <code>\#ref</code> \#loc
throw.from.finally.block.display.name='throw' 位于 'finally' 块内
throw.from.finally.block.problem.descriptor=<code>\#ref</code> 位于 'finally' 块内 \#loc
throwable.instance.never.thrown.checked.exception.problem.descriptor=已检查的异常实例 <code>\#ref</code> 未抛出 \#loc
throwable.instance.never.thrown.error.problem.descriptor=错误实例 <code>\#ref</code> 未抛出 \#loc
throwable.instance.never.thrown.problem.descriptor=Throwable 实例 <code>\#ref</code> 未抛出 \#loc
throwable.instance.never.thrown.runtime.exception.problem.descriptor=运行时异常实例 <code>new \#ref()</code> 未抛出 \#loc
throwable.not.thrown.display.name='Throwable' 未抛出
throwable.printed.to.system.out.display.name='Throwable' 打印到 'System.out'
throwable.printed.to.system.out.problem.descriptor=''Throwable'' 实参 <code>\#ref</code> 到 ''System.{0}.{1}()'' 调用
throwable.printed.to.system.out.problem.fix.level.option=修正的日志方法\:
throwable.result.of.method.call.ignored.problem.descriptor=<code>\#ref()</code> 的结果未抛出 \#loc
throwable.supplier.only.throw.exception.name=Throwable 供应商从不返回值
throwable.supplier.only.throw.exception.problem.descriptor=Throwable 供应商不返回任何异常
throwable.supplier.only.throw.exception.quickfix=将 lambda 中的 'throw' 替换为 'return'
thrown.exceptions.per.method.display.name=方法声明的异常过多
thrown.exceptions.per.method.limit.option=异常抛出限制\:
thrown.exceptions.per.method.problem.descriptor=<code>\#ref</code> 声明的异常过多 (异常数量 \= {0}) \#loc
throws.runtime.exception.display.name=在 'throws' 子句中声明的未检查的异常
throws.runtime.exception.fix.family.name=从 'throws' 子句中移除
throws.runtime.exception.move.quickfix=将 ''{0}'' 移至 Javadoc ''@throws'' 标记中
throws.runtime.exception.problem.descriptor=在 'throws' 子句中声明的未检查的异常 <code>\#ref</code> \#loc
throws.runtime.exception.quickfix=从 ''throws'' 子句中移除 ''{0}''
time.tostring.call.display.name=调用 'Time.toString()'
time.tostring.call.problem.descriptor=国际化上下文中的 <code>Time.\#ref()</code> \#loc
to.array.call.style.display.name='Collection.toArray()' 调用样式
to.array.call.style.problem.descriptor.presized=<code>\#ref()</code> 调用具有预设大小的数组实参 ''{0}'' \#loc
to.array.call.style.problem.descriptor.zero=<code>\#ref()</code> 调用具有空数组实参 ''{0}'' \#loc
to.array.call.style.quickfix.family.name=修复传递到 'toArray()' 调用的数组的大小
to.array.call.style.quickfix.make.presized=将实参替换为预设大小的数组
to.array.call.style.quickfix.make.zero=将实参替换为空数组
too.broad.catch.display.name=过宽的 'catch' 块
too.broad.catch.option=仅对 RuntimeException、异常、错误或 Throwable 发出警告(&O)
too.broad.catch.problem.descriptor=<code>\#ref</code> 的 ''catch'' 过宽，掩码异常 ''{0}'' \#loc
too.broad.catch.problem.descriptor1=<code>\#ref</code> 的 ''catch'' 过宽，掩码异常 ''{0}'' 和 ''{1}'' \#loc
too.broad.catch.quickfix=向 ''{0}'' 添加 ''catch'' 子句
too.broad.scope.allow.option=<html>报告使用新表达式作为初始值设定项的变量<br>(可能不安全)</html>
too.broad.scope.display.name=变量作用域过宽
too.broad.scope.inspection.fix.family.name=缩小作用域
too.broad.scope.narrow.quickfix=将 ''{0}'' 的声明移近用法
too.broad.scope.only.blocks.option=仅报告可移入内部块的变量
too.broad.scope.problem.descriptor=变量 <code>\#ref</code> 的作用域过宽 \#loc
too.many.constructors.count.limit.option=构造函数计数限制\:
too.many.constructors.display.name=构造函数过多的类
too.many.constructors.ignore.deprecated.option=忽略弃用的构造函数
too.many.constructors.problem.descriptor=<code>\#ref</code> 的构造函数过多 (构造函数计数 \= {0}) \#loc
too.many.fields.count.limit.option=字段计数限制\:
too.many.fields.display.name=字段过多的类
too.many.fields.problem.descriptor=<code>\#ref</code> 的字段过多 (字段计数 \= {0}) \#loc
too.many.methods.display.name=方法过多的类
too.many.methods.problem.descriptor=<code>\#ref</code> 的方法过多 (方法计数 \= {0}) \#loc
trace.level.option=跟踪级别
transient.field.in.non.serializable.class.display.name=不可序列化类中存在 transient 字段
transient.field.in.non.serializable.class.problem.descriptor=字段 ''{0}'' 已在不可序列化类中标记为 <code>\#ref</code> \#loc
transient.field.not.initialized.display.name=transient 字段在反序列化时未初始化
transient.field.not.initialized.problem.descriptor=transient 字段 <code>\#ref</code> 在反序列化时未初始化 \#loc
trivial.if.display.name=冗余的 'if' 语句
trivial.if.fix.family.name=简化 'if else'
trivial.if.option.ignore.assert.statements=忽略带有简单 'assert' 的 'if' 语句
trivial.if.option.ignore.chained=忽略链式 'if' 语句
trivial.if.problem.descriptor=<code>\#ref</code> 语句可以简化 \#loc
trivial.string.concatenation.display.name=与空字符串串联
trivial.string.concatenation.option.only.necessary=仅报告无需其他更改即可移除空字符串的情况
trivial.string.concatenation.problem.descriptor=串联中存在空字符串
try.finally.can.be.try.with.resources.display.name='try finally' 可被替换为 'try' with resources
try.finally.can.be.try.with.resources.problem.descriptor=<code>\#ref</code> 可以使用自动资源管理 \#loc
try.finally.can.be.try.with.resources.quickfix=替换为 'try-with-resources'
try.statement.with.multiple.resources.name=可以拆分具有多个资源的 'try' 语句
try.statement.with.multiple.resources.quickfix=拆分具有多个资源的 'try' 语句
try.with.identical.catches.checkbox.different.comments=不报告带有不同注释的 catch 块
try.with.identical.catches.display.name='try' 语句中的相同 'catch' 分支
try.with.identical.catches.problem.descriptor=''catch'' 分支与 ''{0}'' 分支相同 \#loc
try.with.identical.catches.quickfix=收起 'catch' 块
type.parameter.extends.enum.type.parameter.problem.descriptor=类型形参 <code>\#ref</code> 隐式扩展 final 枚举 ''{0}'' \#loc
type.parameter.extends.enum.wildcard.problem.descriptor=通配符类型实参 <code>\#ref</code> 隐式扩展了 final 枚举 ''{0}'' \#loc
type.parameter.extends.final.class.display.name=类型形参扩展 'final' 类
type.parameter.extends.final.class.quickfix=将类型形参替换为实际类
type.parameter.extends.final.class.type.parameter.problem.descriptor=类型形参 <code>\#ref</code> 扩展 ''final'' 类{0} \#loc
type.parameter.extends.final.class.wildcard.problem.descriptor=通配符类型实参 <code>\#ref</code> 扩展了 ''final'' 类 ''{0}'' \#loc
type.parameter.extends.object.display.name=类型形参显式扩展 'Object'
type.parameter.extends.object.ignore.annotated=注解 java.lang.Object 时忽略
type.parameter.extends.object.problem.descriptor1=类型形参 <code>\#ref</code> 显式扩展 'java.lang.Object' \#loc
type.parameter.extends.object.problem.descriptor2=通配符类型实参 <code>\#ref</code> 显式扩展 'java.lang.Object' \#loc
type.parameter.hides.type.parameter.problem.descriptor=类型形参 <code>\#ref</code> 隐藏类型形参 ''{0}'' \#loc
type.parameter.hides.visible.type.display.name=类型形参隐藏可见类型
type.parameter.hides.visible.type.problem.descriptor=类型形参 <code>\#ref</code> 隐藏可见类型 ''{0}'' \#loc
type.parameter.naming.convention.element.description=类型形参
unary.plus.display.name=一元正号
unary.plus.problem.descriptor=一元 <code>\#ref</code> 运算符 \#loc
unary.plus.quickfix=移除一元 '+'
unchecked.exception.class.display.name=未检查的 'Exception' 类
unchecked.exception.class.problem.descriptor=未检查的异常类 <code>\#ref</code> \#loc
unclear.binary.expression.display.name=具有不同优先级的多个运算符
unclear.binary.expression.problem.descriptor=表达式可以使用澄清括号 \#loc
unclear.binary.expression.quickfix=添加澄清括号
unconditional.wait.display.name=无条件的 'wait()' 调用
unconditional.wait.problem.descriptor=无条件调用 <code>\#ref()</code> \#loc
unnecessarily.qualified.inner.class.access.display.name=不必要的限定内部类访问
unnecessarily.qualified.inner.class.access.option=忽略需要导入的引用
unnecessarily.qualified.inner.class.access.problem.descriptor=使用 <code>\#ref</code> 限定 ''{0}'' 不必要 \#loc
unnecessarily.qualified.inner.class.access.quickfix=移除限定符
unnecessarily.qualified.static.usage.display.name=不必要的限定静态访问
unnecessarily.qualified.static.usage.ignore.field.option=忽略不必要的限定字段访问
unnecessarily.qualified.static.usage.ignore.method.option=忽略不必要的限定方法调用
unnecessarily.qualified.static.usage.problem.descriptor=对 static 方法 <code>{0}()</code> 不必要的限定调用 \#loc
unnecessarily.qualified.static.usage.problem.descriptor1=对 static 字段 <code>{0}</code> 不必要的限定访问 \#loc
unnecessarily.qualified.statically.imported.element.display.name=不必要的限定静态导入元素
unnecessarily.qualified.statically.imported.element.problem.descriptor=静态导入元素 ''{0}'' 使用 <code>\#ref</code> 不必要限定 \#loc
unnecessarily.qualified.statically.imported.element.quickfix=移除不必要的限定符
unnecessary.block.statement.problem.descriptor=此语句周围的大括号不必要 \#loc
unnecessary.boxing.display.name=不必要的装箱
unnecessary.boxing.inside.value.of.problem.descriptor=冗余装箱，可以改用 <code>{0}.{1}()</code> 调用 \#loc
unnecessary.boxing.problem.descriptor=不必要的装箱 \#loc
unnecessary.boxing.remove.quickfix=移除装箱
unnecessary.boxing.superfluous.option=仅报告真正多余的装箱表达式
unnecessary.break.display.name=不必要的 'break' 语句
unnecessary.break.problem.descriptor=<code>\#ref</code> 语句不必要 \#loc
unnecessary.code.block.display.name=不必要的代码块
unnecessary.code.block.unwrap.quickfix=解包块
unnecessary.constant.array.creation.expression.display.name=常量数组创建中的冗余 'new' 表达式
unnecessary.constant.array.creation.expression.family.quickfix=从新数组表达式中移除类型规范
unnecessary.constant.array.creation.expression.problem.descriptor=可从新数组表达式中移除 <code>\#ref</code> \#loc
unnecessary.constructor.annotation.option=忽略有注解的构造函数
unnecessary.constructor.display.name=冗余无实参构造函数
unnecessary.constructor.problem.descriptor=无实参构造函数 <code>\#ref()</code> 是冗余的 \#loc
unnecessary.constructor.remove.quickfix=移除冗余构造函数
unnecessary.continue.display.name=不必要的 'continue' 语句
unnecessary.continue.problem.descriptor=<code>\#ref</code> 不必要，因为是循环中的最后一条语句 \#loc
unnecessary.conversion.to.string.display.name=到 'String' 的不必要转换
unnecessary.default.display.name=枚举 'switch' 语句的 'default' 不必要
unnecessary.default.expressions.option=仅报告 switch 表达式
unnecessary.default.problem.descriptor=<code>\#ref</code> 分支不必要 \#loc
unnecessary.default.quickfix=移除 'default' 分支
unnecessary.enum.constructor.modifier.problem.descriptor=修饰符 <code>\#ref</code> 对于枚举构造函数是冗余的 \#loc
unnecessary.explicit.numeric.cast.display.name=不必要的显式数字转换
unnecessary.explicit.numeric.cast.problem.descriptor=''{0}'' 不必要转换为 <code>\#ref</code> \#loc
unnecessary.explicit.numeric.cast.quickfix=移除转换
unnecessary.final.on.local.variable.or.parameter.display.name=局部变量或形参上存在不必要的 'final'
unnecessary.final.on.local.variable.problem.descriptor=变量 ''{0}'' 上存在不必要的 <code>\#ref</code> \#loc
unnecessary.final.on.parameter.only.interface.option=仅对 abstract 或接口方法发出警告
unnecessary.final.on.parameter.only.interface.option.description=<code>abstract</code> 或接口方法的 <code>final</code> 形参可能会被认为是不必要的，因为它们不会影响这些方法的实现。
unnecessary.final.on.parameter.problem.descriptor=形参 ''{0}'' 上存在不必要的 <code>\#ref</code> \#loc
unnecessary.final.report.catch.parameters.option=报告 catch 形参
unnecessary.final.report.foreach.parameters.option=报告 foreach 形参
unnecessary.final.report.local.variables.option=报告局部变量
unnecessary.final.report.method.parameters.option=报告方法形参
unnecessary.final.report.pattern.variables.option=报告模式变量
unnecessary.fully.qualified.name.display.name=不必要的完全限定名称
unnecessary.fully.qualified.name.fix.family.name=替换完全限定名称
unnecessary.fully.qualified.name.problem.descriptor1=限定符 <code>\#ref</code> 不必要，可被替换为导入 \#loc
unnecessary.fully.qualified.name.problem.descriptor2=限定符 <code>\#ref</code> 不必要，可以移除 \#loc
unnecessary.fully.qualified.name.remove.quickfix=移除不必要的限定
unnecessary.fully.qualified.name.replace.quickfix=将限定名称替换为导入
unnecessary.inherit.doc.class.invalid.problem.descriptor=<code>\#ref</code> 在类上无效 \#loc
unnecessary.inherit.doc.constructor.invalid.problem.descriptor=<code>\#ref</code> 在构造函数上无效 \#loc
unnecessary.inherit.doc.constructor.no.super.problem.descriptor=找不到继承 Javadoc 的 super 方法 \#loc
unnecessary.inherit.doc.display.name=不必要的 '{@inheritDoc}' Javadoc 注释
unnecessary.inherit.doc.field.invalid.problem.descriptor=<code>\#ref</code> 在字段上无效 \#loc
unnecessary.inherit.doc.module.invalid.problem.descriptor=<code>\#ref</code> 在模块声明上无效 \#loc
unnecessary.inherit.doc.problem.descriptor=仅包含 <code>\#ref</code> 的 Javadoc 注释不必要 \#loc
unnecessary.inherit.doc.quickfix=移除不必要的 {@inheritDoc}
unnecessary.initcause.display.name=对 'Throwable.initCause()' 的调用不必要
unnecessary.initcause.problem.descriptor=不必要的 <code>Throwable.\#ref()</code> 调用
unnecessary.initcause.quickfix=移除 'Throwable.initCause()' 调用
unnecessary.inner.enum.modifier.problem.descriptor=修饰符 <code>\#ref</code> 对于内部枚举是冗余的 \#loc
unnecessary.inner.interface.modifier.problem.descriptor=修饰符 <code>\#ref</code> 对于内部接口是冗余的 \#loc
unnecessary.inner.record.modifier.problem.descriptor=修饰符 <code>\#ref</code> 对于内部记录是冗余的
unnecessary.interface.field.modifier.problem.descriptor=修饰符 <code>\#ref</code> 对于接口字段是冗余的 \#loc
unnecessary.interface.inner.class.modifier.problem.descriptor=修饰符 <code>\#ref</code> 对于接口的内部类是冗余的 \#loc
unnecessary.interface.member.modifier.problem.descriptor=修饰符 <code>\#ref</code> 对于接口成员是冗余的 \#loc
unnecessary.interface.method.modifier.problem.descriptor=修饰符 <code>\#ref</code> 对于接口方法是冗余的 \#loc
unnecessary.interface.modifier.problem.descriptor=修饰符 <code>\#ref</code> 对于接口是冗余的 \#loc
unnecessary.java.doc.link.fix.family.name=移除冗余标记
unnecessary.javadoc.link.display.name=不必要的 Javadoc 链接
unnecessary.javadoc.link.option=忽略 super 方法的内联链接
unnecessary.javadoc.link.quickfix=移除不必要的 ''{0}''
unnecessary.javadoc.link.super.method.problem.descriptor=指向 super 方法的 <code>\#ref</code> 不必要 \#loc
unnecessary.javadoc.link.this.class.problem.descriptor=指向包含类的 <code>\#ref</code> 不必要 \#loc
unnecessary.javadoc.link.this.method.problem.descriptor=指向此方法的 <code>\#ref</code> 不必要 \#loc
unnecessary.label.on.break.statement.display.name='break' 语句上的标签不必要
unnecessary.label.on.break.statement.problem.descriptor=Break 语句上存在不必要的标签 <code>\#ref</code> \#loc
unnecessary.label.on.continue.statement.display.name='continue' 语句上的不必要标签
unnecessary.label.on.continue.statement.problem.descriptor=Continue 语句上存在不必要的标签 <code>\#ref</code> \#loc
unnecessary.label.remove.quickfix=移除标签
unnecessary.local.variable.problem.descriptor=局部变量 <code>\#ref</code> 是冗余的 \#loc
unnecessary.main.modifier.problem.descriptor=修饰符 <code>\#ref</code> 对于 Java {0} 的 ''main'' 方法是冗余的 \#loc
unnecessary.modifier.display.name=不必要的修饰符
unnecessary.parentheses.conditional.option=忽略条件表达式条件周围的圆括号
unnecessary.parentheses.display.name=不必要的圆括号
unnecessary.parentheses.option=忽略澄清圆括号
unnecessary.parentheses.problem.descriptor=<code>\#ref</code> 周围的圆括号不必要 \#loc
unnecessary.parentheses.remove.quickfix=移除不必要的圆括号
unnecessary.qualifier.for.super.problem.descriptor='super' 上的限定符 <code>\#ref</code> 在此上下文中不必要 \#loc
unnecessary.qualifier.for.this.display.name='this' 或 'super' 的限定符不必要
unnecessary.qualifier.for.this.problem.descriptor='this' 上的限定符 <code>\#ref</code> 在此上下文中不必要 \#loc
unnecessary.qualifier.for.this.remove.quickfix=移除不必要的限定符
unnecessary.record.modifier.problem.descriptor=修饰符 <code>\#ref</code> 对于记录是冗余的
unnecessary.return.constructor.problem.descriptor=<code>\#ref</code> 不必要，因为是构造函数中的最后一条语句 \#loc
unnecessary.return.display.name=不必要的 'return' 语句
unnecessary.return.option=在具有 'else' 分支的 'if' 语句的 then 分支中忽略
unnecessary.return.problem.descriptor=<code>\#ref</code> 不必要，因为是 'void' 方法中的最后一条语句 \#loc
unnecessary.semicolon.display.name=不必要的分号
unnecessary.semicolon.ignore.after.enum.constants.option=忽略枚举常量后的不必要分号
unnecessary.semicolon.problem.descriptor=不必要的分号 <code>\#ref</code> \#loc
unnecessary.semicolon.remove.quickfix=移除不必要的分号
unnecessary.strictfp.modifier.problem.descriptor=修饰符 <code>\#ref</code> 在 Java 17 和更高版本上是冗余的
unnecessary.string.escape.display.name=不必要的转义字符
unnecessary.string.escape.problem.descriptor=<code>{0}</code> 进行了不必要的转义
unnecessary.string.escape.quickfix=移除不必要的转义
unnecessary.super.constructor.display.name=对 'super()' 的调用不必要
unnecessary.super.constructor.problem.descriptor=<code>\#ref</code> 不必要 \#loc
unnecessary.super.constructor.remove.quickfix=移除不必要的 'super()'
unnecessary.super.qualifier.display.name=不必要的 'super' 限定符
unnecessary.super.qualifier.problem.descriptor=限定符 <code>\#ref</code> 在此上下文中不必要 \#loc
unnecessary.super.qualifier.quickfix=移除不必要的 'super' 限定符
unnecessary.temporary.object.fix.family.name=替换串联
unnecessary.temporary.on.conversion.from.string.display.name=从 'String' 转换时有不必要的临时对象
unnecessary.temporary.on.conversion.to.string.display.name=转换为 'String' 时有不必要的临时对象
unnecessary.this.display.name=不必要的 'this' 限定符
unnecessary.this.ignore.assignments.option=忽略字段赋值
unnecessary.this.problem.descriptor=<code>\#ref</code> 在此上下文中不必要 \#loc
unnecessary.this.remove.quickfix=移除不必要的 'this' 限定符
unnecessary.tostring.call.display.name=对 'toString()' 的调用不必要
unnecessary.tostring.call.option.report.with.empty.string=报告可被替换为带空字符串的串联的调用
unnecessary.tostring.call.problem.descriptor=不必要的 <code>\#ref()</code> 调用 \#loc
unnecessary.tostring.call.problem.empty.string.descriptor=可以替换为带空字符串的串联
unnecessary.transient.modifier.problem.descriptor=修饰符 <code>\#ref</code> 对于 'static' 字段是冗余的
unnecessary.unary.minus.display.name=不必要的一元负号
unnecessary.unary.minus.problem.descriptor=不必要的一元 <code>\#ref</code> 运算符 \#loc
unnecessary.unary.minus.quickfix=移除一元负号并反转父运算符号
unnecessary.unary.minus.remove.quickfix=移除双一元减号
unnecessary.unboxing.display.name=不必要的拆箱
unnecessary.unboxing.problem.descriptor=不必要的拆箱 \#loc
unnecessary.unboxing.remove.quickfix=移除拆箱
unnecessary.unboxing.superfluous.option=仅报告真正多余的拆箱表达式
unnecessary.unicode.escape.display.name=不必要的 Unicode 转义序列
unnecessary.unicode.escape.fix.family.name=替换为字符
unnecessary.unicode.escape.fix.text=替换为{0, choice, 1\#新行|2\#制表符|3\#空格}字符
unnecessary.unicode.escape.problem.descriptor=Unicode 转义序列 <code>\#ref</code> 可被替换为 ''{0}'' \#loc
unnecessary.unicode.escape.problem.newline.descriptor=Unicode 转义序列 <code>\#ref</code> 可被替换为换行字符 \#loc
unpredictable.big.decimal.constructor.call.display.name=不可预知的 'BigDecimal' 构造函数调用
unpredictable.big.decimal.constructor.call.ignore.complex.literals.option=忽略具有多个字面量的构造函数调用 (例如 0.1 + 0.2)
unpredictable.big.decimal.constructor.call.ignore.references.option=忽略具有变量或方法调用实参的构造函数调用
unpredictable.big.decimal.constructor.call.problem.descriptor=不可预知的 <code>new \#ref()</code> 调用 \#loc
unqualified,static.usage.only.report.static.usages.option=仅报告来自非 static 上下文的静态访问
unqualified.field.access.display.name=未使用 'this' 限定的实例字段访问
unqualified.field.access.problem.descriptor=未使用 'this' 限定的实例字段访问 <code>\#ref</code> \#loc
unqualified.inner.class.access.display.name=非限定内部类访问
unqualified.inner.class.access.option=忽略对本地内部类的引用
unqualified.inner.class.access.problem.descriptor=<code>\#ref</code> 未使用外部类限定 \#loc
unqualified.inner.class.access.quickfix=使用外部类限定
unqualified.method.access.display.name=未使用 'this' 限定的实例方法调用
unqualified.method.access.problem.descriptor=未使用 'this' 限定实例方法调用 <code>\#ref()</code> \#loc
unqualified.static.access.fix.family.name=限定静态访问
unqualified.static.usage.display.name=非限定静态访问
unqualified.static.usage.ignore.field.option=忽略非限定字段访问
unqualified.static.usage.ignore.method.option=忽略非限定方法调用
unqualified.static.usage.problem.descriptor=非限定 static 方法调用 <code>\#ref()</code> \#loc
unqualified.static.usage.problem.descriptor1=非限定 static 字段访问 <code>\#ref</code> \#loc
unqualified.static.usage.qualify.field.quickfix=限定 static 字段访问
unqualified.static.usage.qualify.method.quickfix=限定 static 方法调用
unrunnable.main.method.problem.descriptor=无法运行方法 <code>\#ref()</code>，因为包含类没有完全限定名称
unsecure.random.number.generation.display.name=不安全的随机数生成
unsecure.random.number.generation.problem.descriptor1=出于安全目的，请使用 'java.security.SecureRandom' 而不是 <code>java.lang.Math.\#ref()</code> \#loc
unsecure.random.number.generation.problem.descriptor2=出于安全目的，请使用 'java.security.SecureRandom' 而不是 <code>java.util.\#ref</code> \#loc
unsecure.random.number.generation.problem.descriptor3=出于安全目的，请使用 'java.security.SecureRandom' 而不是 <code>\#ref</code> \#loc
unused.import.problem.descriptor=未使用的 import <code>\#ref</code> \#loc
unused.label.display.name=未使用的标签
unused.label.problem.descriptor=未使用的标签 <code>\#ref</code> \#loc
unused.label.remove.quickfix=移除未使用的标签
update.label=更新名称开头\:
upper.case.field.name.not.constant.display.name=具有大写名称的非常量字段
upper.case.field.name.not.constant.problem.descriptor=带常量样式名称的非常量字段 <code>\#ref</code> \#loc
use.0index.in.jdbc.prepared.statement.problem.descriptor=在 JDBC PreparedStatement 中使用索引 '0' \#loc
use.0index.in.jdbc.resultset.display.name=在 JDBC ResultSet 中使用索引 0
use.0index.in.jdbc.resultset.problem.descriptor=在 JDBC ResultSet 中使用索引 '0' \#loc
use.contentequals=使用 'contentEquals()' 与 'AbstractStringBuilder' 进行比较
use.equalsignorecase.for.case.insensitive.comparison=为不区分大小写的比较使用 'equalsIgnoreCase()'
use.isblank.to.check.if.string.is.whitespace.or.empty=使用 'isBlank()' 检查字符串是否为空或者仅包含空格
use.obsolete.collection.type.display.name=使用废弃的集合类型
use.obsolete.collection.type.ignore.library.arguments.option=在需要的位置忽略废弃的集合类型
use.obsolete.collection.type.problem.descriptor=使用了废弃的集合类型 <code>\#ref</code> \#loc
use.of.awt.peer.class.display.name=使用 AWT 对等类
use.of.awt.peer.class.problem.descriptor=AWT 对等类 <code>\#ref</code> 的使用不可移植 \#loc
use.of.clone.call.method.problem.descriptor=实现 <code>\#ref()</code>
use.of.clone.call.problem.descriptor=调用 <code>\#ref()</code>
use.of.clone.display.name=使用 'clone()' 或 'Cloneable'
use.of.clone.reference.problem.descriptor=使用 <code>\#ref</code>
use.of.concrete.class.option.ignore.abstract=忽略抽象类类型
use.of.concrete.class.option.ignore.records=忽略 Java 记录
use.of.concrete.class.option.report.cast=报告转换表达式中使用的类型
use.of.concrete.class.option.report.instance.fields=报告实例字段类型
use.of.concrete.class.option.report.instanceof=报告 instanceof、patterns 或 getClass() 比较中使用的类型
use.of.concrete.class.option.report.local.variable=报告局部变量类型
use.of.concrete.class.option.report.method.returns=报告方法返回值类型
use.of.concrete.class.option.report.parameter=报告方法形参类型
use.of.concrete.class.option.report.static.fields=报告 static 字段类型
use.of.concrete.jdbc.driver.class.display.name=使用具体的 JDBC 驱动程序类
use.of.concrete.jdbc.driver.class.problem.descriptor=具体 JDBC 驱动程序类 <code>\#ref</code> 的使用不可移植 \#loc
use.of.obsolete.date.time.api.display.name=使用废弃的日期时间 API
use.of.obsolete.date.time.api.problem.descriptor=使用了废弃的日期时间类型 <code>\#ref</code> \#loc
use.of.properties.as.hashtable.fix.family.name=修复属性访问
use.processbuilder.class.display.name=使用 'java.lang.ProcessBuilder' 类
use.processbuilder.class.problem.descriptor=<code>\#ref</code> 的使用不可移植 \#loc
use.stringtokenizer.display.name=使用 'StringTokenizer'
use.stringtokenizer.problem.descriptor=国际化上下文中的 <code>\#ref</code> \#loc
use.sun.classes.display.name=使用 'sun.*' 类
use.sun.classes.problem.descriptor=Sun 提供的类 <code>\#ref</code> 的使用不可移植 \#loc
use.system.out.err.display.name=使用 'System.out' 或 'System.err'
use.system.out.err.problem.descriptor=<code>\#ref</code> 的使用可能应当替换为更可靠的日志 \#loc
use.system.out.err.problem.fix.err.option='System.err' 的日志方法\:
use.system.out.err.problem.fix.out.option='System.out' 的日志方法\:
utility.class.can.be.enum.display.name=实用程序类可以是 'enum'
utility.class.code.can.be.enum.problem.descriptor=实用程序类 <code>\#ref</code> 可以是 'enum' \#loc
utility.class.code.can.be.enum.quickfix=转换为 'enum'
utility.class.display.name=实用程序类
utility.class.problem.descriptor=类 <code>\#ref</code> 只有 'static' 成员，指示程序构造 \#loc
utility.class.with.public.constructor.display.name=实用程序类具有 'public' 构造函数
utility.class.with.public.constructor.fix.family.name=将构造函数设为非 public
utility.class.with.public.constructor.make.private.quickfix=将{0, choice, 1\#构造函数|2\#构造函数}设为 'private'
utility.class.with.public.constructor.make.protected.quickfix=将{0, choice, 1\#构造函数|2\#构造函数}设为 'protected'
utility.class.with.public.constructor.problem.descriptor=类 <code>\#ref</code> 只有 'static' 成员和 'public' 构造函数 \#loc
utility.class.without.private.constructor.cant.generate.constructor.message=实用程序类具有实例化，将不会创建 private 构造函数
utility.class.without.private.constructor.create.quickfix=生成空 'private' 构造函数
utility.class.without.private.constructor.display.name=实用程序类没有 'private' 构造函数
utility.class.without.private.constructor.make.quickfix=将构造函数设为 'private'
utility.class.without.private.constructor.option=忽略仅具有主方法的类
utility.class.without.private.constructor.problem.descriptor=类 <code>\#ref</code> 只有 'static' 成员，缺少 'private' 构造函数 \#loc
value.of.post.decrement.problem.descriptor=使用后减量表达式 <code>\#ref</code> 的值 \#loc
value.of.post.increment.problem.descriptor=使用后增量表达式 <code>\#ref</code> 的值 \#loc
value.of.pre.decrement.problem.descriptor=使用前减量表达式 <code>\#ref</code> 的值 \#loc
value.of.pre.increment.problem.descriptor=使用前增量表达式 <code>\#ref</code> 的值 \#loc
variable.argument.method.display.name=vararg 方法
variable.argument.method.problem.descriptor=vararg 方法 <code>\#ref()</code> \#loc
variable.argument.method.quickfix=将 vararg 形参转换为数组
variable.not.used.inside.conditional.problem.descriptor=条件内未使用检查为 'null' 的 <code>\#ref</code> \#loc
variable.not.used.inside.if.display.name='if' 内未使用检查为 'null' 的引用
variable.not.used.inside.if.problem.descriptor='if' 内未使用检查为 'null' 的 <code>\#ref</code> \#loc
variable.type.can.be.explicit.display.name=变量类型可以是显式的
volatile.array.field.display.name=volatile 数组字段
volatile.field.problem.descriptor=类型 ''{0}'' 的 volatile 字段 <code>\#ref</code> \#loc
wait.called.on.condition.display.name=在 'java.util.concurrent.locks.Condition' 对象上调用了 'wait()'
wait.called.on.condition.problem.descriptor=在条件对象上调用 <code>\#ref()</code> \#loc
wait.not.in.loop.display.name=未在循环中调用的 'wait()'
wait.not.in.loop.problem.descriptor=<code>\#ref()</code> 调用不在循环中 \#loc
wait.notify.not.in.synchronized.context.display.name='wait()' 或 'notify()' 不在同步的上下文中
wait.notify.while.not.synchronized.on.problem.descriptor=''{0}'' 未同步时调用 <code>\#ref</code> \#loc
wait.or.await.without.timeout.display.name=无超时的 'wait()' 或 'await()'
wait.or.await.without.timeout.problem.descriptor=无超时的 <code>\#ref</code> \#loc
wait.while.holding.two.locks.display.name=保持两个锁时 'wait()'
wait.while.holding.two.locks.problem.descriptor=在保持两个锁的情况下调用 <code>\#ref()</code> \#loc
wait.without.corresponding.notify.display.name=没有相应 'notify()' 的 'wait()'
wait.without.corresponding.notify.problem.descriptor=在没有相应 <code>notify()</code> 或 <code>notifyAll()</code> 的情况下调用 <code>\#ref()</code> \#loc
warn.level.and.lower.option=警告级别和更低
warn.on.label=警告对象\:
weaken.visibility.quickfix=削弱可见性
while.can.be.foreach.display.name='while' 循环可被替换为增强的 'for' 循环
while.can.be.foreach.problem.descriptor=<code>\#ref</code> 循环可被替换为增强的 'for' \#loc
while.loop.spins.on.field.display.name='while' 循环在字段上自旋
while.loop.spins.on.field.fix.family.name=修复自旋循环
while.loop.spins.on.field.fix.spinwait=添加 Thread.onSpinWait()
while.loop.spins.on.field.fix.volatile=将 ''{0}'' 设为 volatile
while.loop.spins.on.field.fix.volatile.spinwait=将 ''{0}'' 设为 volatile 并添加 Thread.onSpinWait()
while.loop.spins.on.field.ignore.non.empty.loops.option=仅当循环为空时才发出警告
while.loop.spins.on.field.problem.descriptor=<code>\#ref</code> 循环在字段上自旋 \#loc
wrap.with.arrays.hash.code.quickfix=使用 ''{0}'' 包装
write.only.object.display.name=只写入对象
write.only.object.option.ignore.impure.constructors=忽略不纯的构造函数

cast.to.concrete.class.problem.descriptor=转换为具体类 <code>{0}</code> #loc
class.references.subclass.display.name=类引用其子类之一
class.references.subclass.problem.descriptor=类 ''{0}'' 引用子类 <code>#ref</code> #loc
class.references.subclass.problem.descriptor.anonymous=匿名类引用子类 <code>#ref</code> #loc
collection.declared.by.class.display.name=按类 (而不是接口) 声明的集合
collection.declared.by.class.problem.descriptor=<code>#ref</code> 的声明可能应当被削弱为 ''{0}'' #loc
collection.declared.by.class.ignore.locals.option=忽略局部变量
collection.declared.by.class.ignore.private.members.option=忽略 'private' 字段和方法
feature.envy.display.name=特性依恋
feature.envy.problem.descriptor=类 ''{0}'' 在方法 <code>#ref()</code> 中被重复访问 #loc
bounded.wildcard.display.name=可以使用有界通配符
bounded.wildcard.contravariant.descriptor=可以泛化为 <code>? super #ref</code> #loc
bounded.wildcard.covariant.descriptor=可以泛化为 <code>? extends #ref</code> #loc
bounded.wildcard.report.invariant.option=报告固定类
bounded.wildcard.report.private.option=报告 private 方法
bounded.wildcard.report.instance.option=报告实例方法
instance.variable.of.concrete.class.problem.descriptor=具体类 <code>#ref</code> 的实例字段 ''{0}'' #loc
chain.of.instanceof.checks.display.name='instanceof' 检查链
chain.of.instanceof.checks.problem.descriptor='instanceof' 检查链指示抽象失败 #loc
chain.of.class.equality.checks.problem.descriptor=类相等检查链指示抽象失败 #loc
instanceof.concrete.class.problem.descriptor='instanceof' 具体类 <code>#ref</code> #loc
instanceof.concrete.class.equality.problem.descriptor=与具体类 <code>#ref</code> 的类比较 #loc
instanceof.check.for.this.display.name='this' 的 'instanceof' 检查
instanceof.check.for.this.problem.descriptor=<code>#ref</code> 的 'instanceof' 检查 #loc
instanceof.check.for.this.equality.problem.descriptor='this' 的类比较 #loc
local.variable.of.concrete.class.problem.descriptor=具体类 <code>#ref</code> 的局部变量 ''{0}'' #loc
magic.number.display.name=幻数
magic.number.problem.descriptor=幻数 <code>#ref</code> #loc
concrete.class.use.display.name=具体类的使用
method.return.concrete.class.problem.descriptor=方法返回一个具体类 <code>#ref</code> #loc
overly.strong.type.cast.display.name=过强的类型转换
overly.strong.type.cast.weaken.quickfix=削弱过强的转换
concrete.class.method.parameter.problem.descriptor=具体类 <code>#ref</code> 的形参 ''{0}'' #loc
public.method.not.in.interface.display.name='public' 方法在接口中未公开
public.method.not.in.interface.problem.descriptor='public' 方法 <code>#ref()</code> 未通过接口公开 #loc
public.method.not.in.interface.option=<html>如果包含类未实现非库接口，则忽略</html>
static.variable.of.concrete.class.problem.descriptor=具体类 <code>#ref</code> 的 static 字段 ''{0}'' #loc
incompatible.mask.operation.display.name=不兼容的按位掩码运算
incompatible.mask.operation.problem.descriptor.always.false=<code>#ref</code> 始终为 false #loc
incompatible.mask.operation.problem.descriptor.always.true=<code>#ref</code> 始终为 true #loc
pointless.bitwise.expression.display.name=无意义的按位表达式
pointless.bitwise.expression.simplify.quickfix=简化
shift.operation.by.inappropriate.constant.display.name=按不当常量进行移位运算
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=对 <code>#ref</code> 进行移位运算时使用的常量值 {0} 过大 #loc
shift.operation.by.inappropriate.constant.problem.descriptor.negative=对 <code>#ref</code> 进行移位运算时使用的常量值 {0} 为负 #loc
shift.operation.by.inappropriate.constant.problem.descriptor.out.of.bounds=按超出范围的值 {0} 进行移位运算 <code>#ref</code> #loc
equals.called.on.array.display.name=在数组上调用了 'equals()'
equals.called.on.array.problem.descriptor=数组之间的 <code>#ref()</code> 可能应当是 'Arrays.equals()' #loc
assignment.to.null.display.name='null' 赋值
assignment.to.null.problem.descriptor='null' 已赋值给变量 <code>#ref</code> #loc
assignment.to.null.option=忽略对字段的赋值
assignment.to.static.field.from.instance.method.display.name=从实例上下文赋值给 static 字段
assignment.to.static.field.from.instance.method.problem.descriptor=从实例上下文赋值给 static 字段 <code>#ref</code> #loc
assignment.used.as.condition.display.name=用作条件的赋值
assignment.used.as.condition.problem.descriptor=赋值 <code>#ref</code> 作为条件使用 #loc
cast.conflicts.with.instanceof.display.name=转换与 'instanceof' 冲突
cast.conflicts.with.instanceof.problem.descriptor=转换为 ''{0}'' 类型将与前面的 ''instanceof {1}'' 检查冲突
casting.to.incompatible.interface.display.name=转换为不兼容的接口
casting.to.incompatible.interface.problem.descriptor=转换为不兼容的接口 <code>#ref</code> #loc
collection.added.to.self.display.name=集合已添加到自身
collection.added.to.self.problem.descriptor=在以自身作为实参的集合 <code>#ref</code> 上调用了 ''{0}()'' #loc
non.final.field.compareto.display.name='compareTo()' 中引用了非最终字段
non.final.field.compareto.problem.descriptor=在 'compareTo()' 中访问了非 final 字段 <code>#ref</code> #loc
covariant.equals.display.name=协变 'equals()'
covariant.equals.problem.descriptor=<code>#ref()</code> 应当以 'Object' 作为其实参 #loc
empty.class.initializer.display.name=空类初始值设定项
empty.class.initializer.problem.descriptor=空类初始值设定项 #loc
empty.class.initializer.delete.quickfix=删除空类初始值设定项
statement.with.empty.body.display.name=带空体的语句
statement.with.empty.body.problem.descriptor=<code>#ref</code> 语句具有空体 #loc
statement.with.empty.body.include.option=包含空代码块语句正文
equals.between.inconvertible.types.display.name='equals()' 位于不可转换类型的对象之间
equals.between.inconvertible.types.problem.descriptor=<code>#ref</code> 位于 ''{0}'' 和 ''{1}'' 不可转换类型的对象之间 #loc
equals.between.inconvertible.types.no.mutual.subclass.problem.descriptor=未找到属于 ''{0}'' 和 ''{1}'' 这两个子类型的类 #loc
equals.between.inconvertible.types.mutual.subclass.option=如果未找到相互子类，则发出警告
equals.called.on.suspicious.object.display.name=在 'StringBuilder'上调用了 'equals()'
equals.called.on.suspicious.object.problem.descriptor=''{0}'' 对象上存在可疑的 ''equals()'' 调用
non.final.field.in.equals.display.name='equals()' 中引用了非最终字段
non.final.field.in.equals.problem.descriptor=在 'equals()' 中访问了非 final 字段 <code>#ref</code> #loc
equals.doesnt.check.class.parameter.display.name=不检查形参的类的 'equals()' 方法
equals.doesnt.check.class.parameter.problem.descriptor=<code>#ref()</code> 应当检查其形参的类 #loc
non.final.field.in.hashcode.display.name='hashCode()' 中引用了非最终字段
non.final.field.in.hashcode.problem.descriptor=在 'hashCode()' 中访问了非 final 字段 <code>#ref</code> #loc
result.of.method.call.ignored.display.name=方法调用的结果已忽略
write.only.object.display.name=只写入对象
write.only.object.option.ignore.impure.constructors=忽略不纯的构造函数
result.of.method.call.ignored.problem.descriptor=<code>{0}.#ref()</code> 的结果已忽略 #loc
result.of.method.call.ignored.class.column.title=类名
result.of.method.call.ignored.method.column.title=方法名称正则表达式
result.of.method.call.ignored.non.library.option=报告所有忽略的非库调用
infinite.recursion.display.name=无限递归
infinite.recursion.problem.descriptor=方法 <code>#ref()</code> 无限递归，只能以抛出异常结束 #loc
instanceof.with.incompatible.interface.display.name=具有不兼容接口的 'instanceof'
instanceof.with.incompatible.interface.problem.descriptor=具有不兼容接口 <code>#ref</code> 的 'instanceof' #loc
instantiation.utility.class.display.name=实用程序类的实例化
instantiation.utility.class.problem.descriptor=实用程序类 <code>#ref</code> 的实例化 #loc
iterator.hasnext.which.calls.next.display.name=调用 'next()' 的 'Iterator.hasNext()'
iterator.hasnext.which.calls.next.problem.descriptor=<code>Iterator.{0}()</code> 包含 ''#ref()'' 调用 #loc
iterator.next.does.not.throw.nosuchelementexception.display.name=无法抛出 'NoSuchElementException' 的 'Iterator.next()'
malformed.format.string.display.name=字符串的格式错误
malformed.format.string.problem.descriptor.malformed=格式字符串 <code>#ref</code> 的格式错误 #loc
malformed.format.string.problem.descriptor.illegal=非法格式字符串指定符: {0} #loc
malformed.format.string.problem.descriptor.too.many.arguments=格式字符串的实参太多(实际: {0}，应为: {1}) #loc
malformed.format.string.problem.descriptor.too.few.arguments=格式字符串的实参太少(实际: {0}，应为: {1}) #loc
malformed.format.string.problem.descriptor.arguments.do.not.match.type=实参类型 ''{0}'' 与格式说明符 ''{1}'' 的类型不匹配 #loc
format.string.error.flags.not.allowed=''{1}'' 中不允许使用{2, choice, 1#标志|1<标志} ''{0}''
format.string.error.unexpected.flag=''{1}'' 中出现意外字符 ''{0}''
format.string.error.duplicate.flag=''{1}'' 中存在重复的标志 ''{0}''
format.string.error.width.not.allowed=''{1}'' 中不允许该宽度 (''{0}'')
format.string.error.precision.not.allowed=''{1}'' 中不允许该精度 (''{0}'')
format.string.error.unnecessary.position.specifier=''{1}'' 存在不必要的实参位置说明符 ''{0}''
format.string.error.illegal.position.specifier=''{1}'' 存在非法的位置说明符 ''{0}''
format.string.error.previous.element.not.found=使用了以前的标志 '<'，但没有找到 ''{0}'' 以前的格式说明符
format.string.error.unknown.conversion=''{0}'' 中存在未知的转换
format.string.error.invalid.precision=''{0}'' 中指定的精度无效
format.string.error.illegal.flag.combination=''{2}'' 中的标志组合 ''{0}'' 和 ''{1}'' 非法
format.string.error.left.justify.no.width=使用了左对齐标志 ''-''，但 ''{0}'' 中未指定宽度
format.string.error.zero.padding.no.width=使用了零填充标志 ''0''，但 ''{0}'' 中未指定宽度
mismatched.read.write.array.display.name=数组的读取和写入不匹配
mismatched.read.write.array.problem.descriptor.write.not.read=数组 <code>#ref</code> 的内容已写入，但从未被读取 #loc
mismatched.read.write.array.problem.descriptor.read.not.write=数组 <code>#ref</code> 的内容已读取，但从未被写入 #loc
mismatched.update.collection.display.name=不匹配的集合查询和更新
mismatched.update.collection.problem.descriptor.updated.not.queried=集合 <code>#ref</code> 的内容已更新，但从未被查询 #loc
mismatched.update.collection.problem.description.queried.not.updated=集合 <code>#ref</code> 的内容已被查询，但从未更新 #loc
rename.quickfix=重命名
renameto.quickfix=重命名为 ''{0}''
misspelled.equals.display.name='equal()' 代替 'equals()'
misspelled.equals.problem.descriptor=<code>#ref()</code> 方法可能应当是 'equals()' #loc
non.short.circuit.boolean.expression.display.name=非短路布尔表达式
non.short.circuit.boolean.expression.problem.descriptor=非短路布尔表达式 <code>#ref</code> #loc
non.short.circuit.boolean.expression.replace.quickfix=替换为短路表达式
null.argument.to.var.arg.method.display.name=引起混淆的 vararg 方法实参
null.argument.to.var.arg.method.problem.descriptor=引起混淆的实参 <code>#ref</code>，不清楚是否需要 vararg 或非 vararg 调用 #loc
primitive.array.argument.to.var.arg.method.display.name=引起混淆的 vararg 方法基元数组实参
primitive.array.argument.to.var.arg.method.problem.descriptor=引起混淆的 vararg 方法基元数组实参 #loc
object.comparison.display.name=使用 '==' 而不是 'equals()' 进行对象比较
object.comparison.enumerated.ignore.option=忽略枚举变量之间的 '=='
object.comparison.klass.ignore.option=忽略没有 'equals()' 实现的 final 类类型之间的 '=='
object.comparison.problem.description=使用 <code>#ref</code> 而不是 'equals()' 来比较对象值 #loc
equality.to.safe.equals.quickfix=用 null 安全 'equals()' 替换 '=='
inequality.to.safe.not.equals.quickfix=用 null 安全 '!equals()' 替换 '!='
default.tostring.call.display.name=调用默认 'toString()'
default.tostring.call.problem.descriptor=调用 <code>#ref</code> 上的默认 'toString()' #loc
octal.and.decimal.integers.in.same.array.display.name=同一数组中的八进制和十进制整数
octal.and.decimal.integers.in.same.array.problem.descriptor=同一数组初始值设定项中的八进制和十进制整数 #loc
result.of.object.allocation.ignored.display.name=对象分配的结果已忽略
result.of.object.allocation.ignored.problem.descriptor=<code>new #ref()</code> 的结果已忽略 #loc
result.of.object.allocation.ignored.options.chooserTitle=选择可以忽略对象分配的类
result.of.object.allocation.fix.name=忽略类型 ''{0}'' 的对象的分配
use.0index.in.jdbc.resultset.display.name=在 JDBC ResultSet 中使用索引 0
use.0index.in.jdbc.resultset.problem.descriptor=在 JDBC ResultSet 中使用索引 '0' #loc
use.0index.in.jdbc.prepared.statement.problem.descriptor=在 JDBC PreparedStatement 中使用索引 '0' #loc
return.of.null.display.name=返回 'null'
return.of.null.problem.descriptor=返回 <code>#ref</code> #loc
return.of.null.arrays.option=报告返回数组的方法
return.of.null.objects.option=报告返回对象的方法
return.of.null.collections.option=报告返回集合对象的方法
return.of.null.ignore.private.option=忽略 'private' 方法、匿名类和 lambda
static.method.via.subclass.display.name=static 方法通过子类引用
static.method.via.subclass.problem.descriptor=static 方法 <code>#ref()</code> 在类 ''{0}'' 中声明，但通过子类 ''{1}'' 引用 #loc
static.method.via.subclass.rationalize.quickfix=使 static 方法调用合理化
static.field.via.subclass.display.name=static 字段通过子类引用
static.field.via.subclass.problem.descriptor=static 字段 <code>#ref</code> 在类 ''{0}'' 中声明，但通过子类 ''{1}'' 引用 #loc
static.field.via.subclass.rationalize.quickfix=使 static 字段访问合理化
string.comparison.display.name=使用 '==' 而不是 'equals()' 进行字符串比较
number.comparison.display.name=使用 '==' 而不是 'equals()' 进行数字比较
string.comparison.problem.descriptor=使用 <code>#ref</code> 而不是 'equals()' 来比较字符串值 #loc
number.comparison.problem.descriptor=使用 <code>#ref</code> 而不是 'equals()' 来比较数字对象 #loc
subtraction.in.compareto.display.name='compareTo()' 中的减法
subtraction.in.compareto.problem.descriptor='compareTo()' 中的减法 <code>#ref</code> 可能导致溢出或精度损失 #loc
text.label.in.switch.statement.display.name='switch' 语句中的文本标签
text.label.in.switch.statement.problem.descriptor='switch' {0, choice, 1#语句|2#表达式}中存在文本标签 <code>#ref:</code> #loc
properties.object.as.hashtable.display.name=将 'Properties' 对象用作 'Hashtable'
properties.object.as.hashtable.problem.descriptor=在属性对象上调用 <code>Hashtable.#ref()</code> #loc
assignment.replaceable.with.operator.assignment.display.name=赋值可被替换为运算符赋值
unnecessary.code.block.display.name=不必要的代码块
unnecessary.code.block.unwrap.quickfix=解开块
redundant.local.variable.display.name=冗余局部变量
redundant.local.variable.ignore.option=忽略立即返回或抛出的变量
redundant.local.variable.annotation.option=忽略具有注解的变量
static.collection.display.name=静态集合
static.collection.problem.descriptor=静态集合 <code>#ref</code> #loc
static.collection.ignore.option=忽略弱静态集合或映射
stringbuffer.field.display.name='StringBuilder' 字段
stringbuffer.field.problem.descriptor=''{0}'' 字段 <code>#ref</code> #loc
gc.call.display.name=调用 'System.gc()' 或 'Runtime.gc()'
gc.call.problem.descriptor=<code>#ref</code> 不应在生产代码中调用 #loc
array.allocation.zero.length.display.name=零长度数组分配
array.allocation.zero.length.problem.descriptor=零长度数组的分配 #loc
constant.for.zero.length.array.display.name=不必要的零长度数组用法
constant.for.zero.length.array.problem.descriptor=零长度数组可更改为常量 #loc
constant.for.zero.length.array.quickfix.family=替换为常量
multiple.loggers.display.name=具有多个记录器的类
logger.name.option=记录器类名(&C):
multiple.loggers.problem.descriptor=类 <code>#ref</code> 声明多个记录器 #loc
no.logger.display.name=不带记录器的类
no.logger.problem.descriptor=类 <code>#ref</code> 未声明记录器 #loc
non.constant.logger.display.name=非常量记录器
non.constant.logger.problem.descriptor=非常量记录器字段 <code>#ref</code> #loc
public.method.without.logging.display.name='public' 方法没有日志记录
public.method.without.logging.problem.descriptor='public' 方法 <code>#ref()</code> 没有日志调用 #loc
ignore.trivial.finalizers.option=对普通 'finalize()' 实现忽略
finalize.declaration.display.name='finalize()' 不应被重写
finalize.declaration.problem.descriptor='finalize()' 不应被重写 #loc
finalize.not.declared.protected.display.name='finalize()' 应为 protected，不应为 public
finalize.not.declared.protected.problem.descriptor='finalize()' 应具有 protected 访问权限，不应具有 public 访问权限 #loc
finalize.called.explicitly.display.name='finalize()' 被显式调用
finalize.called.explicitly.problem.descriptor=<code>#ref()</code> 被显式调用 #loc
java.lang.import.display.name='java.lang' 软件包中有不必要的 import
java.lang.import.problem.descriptor='java.lang' 软件包中有不必要的 import #loc
import.display.name='*' 导入
import.problem.descriptor=软件包导入 <code>#ref</code> #loc
import.from.same.package.display.name=相同软件包中的不必要 import
import.from.same.package.problem.descriptor=相同软件包 <code>#ref</code> 中有不必要的 import #loc
single.class.import.display.name=单个类导入
single.class.import.problem.descriptor=单个类导入 <code>#ref</code> #loc
static.import.display.name=静态导入
static.import.problem.descriptor=静态导入 <code>#ref</code>  #loc
static.import.replace.quickfix=替换为非静态导入
static.import.fix.ignore.class=允许类 ''{0}'' 的静态导入
static.import.options.border.title=静态可导入类:
static.import.options.chooserTitle=选择静态可导入类
unused.import.problem.descriptor=未使用的 import <code>#ref</code> #loc
clone.instantiates.objects.with.constructor.display.name='clone()' 用构造函数实例化对象
clone.instantiates.objects.with.constructor.problem.descriptor='clone()' 创建新的 <code>#ref</code> 实例 #loc
clone.instantiates.new.array.problem.descriptor=''clone()'' 创建新的 {0} 数组 #loc
clone.doesnt.declare.clonenotsupportedexception.display.name='clone()' 未声明 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.problem.descriptor=<code>#ref()</code> #loc 未声明 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.declare.quickfix=将 'CloneNotSupportedException' 添加到 throws 子句
clone.method.in.non.cloneable.class.display.name=不可克隆类中的 'clone()' 方法
clone.method.in.non.cloneable.class.problem.descriptor=<code>#ref()</code> 在不可克隆类 ''{0}'' 中定义 #loc
clone.method.in.non.cloneable.anonymous.class.problem.descriptor=<code>#ref()</code> 在派生自 ''{0}'' 的不可克隆匿名类中定义 #loc
clone.method.in.non.cloneable.interface.problem.descriptor=<code>#ref()</code> 在不可克隆接口 ''{0}'' 中定义 #loc
cloneable.class.without.clone.display.name=没有 'clone()' 方法的可克隆类
cloneable.class.without.clone.problem.descriptor=<code>#ref</code> 为 'Cloneable'，但未定义 'clone()' 方法 #loc
cloneable.class.without.clone.ignore.option=忽略由于继承而可克隆的类
cloneable.class.without.clone.quickfix=生成 'clone()' 方法
use.obsolete.collection.type.display.name=使用废弃的集合类型
use.obsolete.collection.type.problem.descriptor=使用了废弃的集合类型 <code>#ref</code> #loc
use.obsolete.collection.type.ignore.library.arguments.option=在需要的位置忽略废弃的集合类型
inspection.suppression.annotation.display.name=检查禁止注解
inspection.suppression.annotation.problem.descriptor=检查禁止注解 <code>#ref</code> #loc
use.system.out.err.display.name=使用 'System.out' 或 'System.err'
use.system.out.err.problem.descriptor=<code>#ref</code> 的使用可能应当替换为更可靠的日志 #loc
dumpstack.call.display.name=调用 'Thread.dumpStack()'
dumpstack.call.problem.descriptor=对 <code>Thread.#ref()</code> 的调用可能应当替换为更可靠的日志 #loc
printstacktrace.call.display.name=调用 'printStackTrace()'
printstacktrace.call.problem.descriptor=对 <code>#ref()</code> 的调用可能应当替换为更可靠的日志 #loc
abstract.method.call.in.constructor.display.name=对象构造期间调用的 abstract 方法
abstract.method.call.in.constructor.problem.descriptor=对象构造期间调用 'abstract' 方法 <code>#ref()</code> #loc
instance.variable.may.not.be.initialized.display.name=实例字段可能无法初始化
instance.variable.may.not.be.initialized.problem.descriptor=实例字段 <code>#ref</code> 在对象构造期间可能无法初始化 #loc
instance.Variable.may.not.be.initialized.problem.descriptor.junit=实例字段 <code>#ref</code> 在对象构造或 'setUp()' 调用期间可能无法初始化 #loc
primitive.fields.ignore.option=忽略原始字段
instance.variable.used.before.initialized.display.name=实例字段在初始化前使用
instance.variable.used.before.initialized.problem.descriptor=初始化前使用的实例字段 <code>#ref</code> #loc
non.final.static.variable.initialization.display.name=在类初始化期间使用非 final static 字段
non.final.static.variable.initialization.problem.descriptor=在类初始化期间使用非 final static 字段 <code>#ref</code> #loc
overridable.method.call.in.constructor.display.name=对象构造期间调用的可重写方法
overridable.method.call.in.constructor.problem.descriptor=对象构造期间调用可重写方法 <code>#ref()</code> #loc
overridden.method.call.in.constructor.display.name=重写的方法在对象构造期间调用
overridden.method.call.in.constructor.problem.descriptor=对象构造期间调用已重写方法 <code>#ref()</code> #loc
static.variable.may.not.be.initialized.display.name=static 字段可能无法初始化
static.variable.may.not.be.initialized.problem.descriptor=static 字段 <code>#ref</code> 在类初始化期间可能无法初始化 #loc
static.variable.used.before.initialization.display.name=static 字段在初始化前使用
static.variable.used.before.initialization.problem.descriptor=static 字段 <code>#ref</code> 在初始化前使用 #loc
this.reference.escaped.in.construction.display.name=对象构造中转义的 'this' 引用
this.reference.escaped.in.construction.problem.descriptor=对象构造期间转义 <code>#ref</code> #loc
assignment.to.catch.block.parameter.display.name=赋值给 'catch' 块形参
extract.parameter.as.local.variable.quickfix=提取形参作为局部变量
assignment.to.for.loop.parameter.display.name=赋值给 'for' 循环形参
assignment.to.for.loop.parameter.check.foreach.option=检查增强型 'for' 循环形参
assignment.to.for.loop.parameter.problem.descriptor=赋值给 for 循环形参 <code>#ref</code> #loc
assignment.to.method.parameter.display.name=赋值给方法形参
chained.equality.comparisons.display.name=链式相等比较
confusing.octal.escape.sequence.display.name=引起混淆的八进制转义序列
increment.decrement.display.name=使用 '++' 或 '--' 的结果
nested.assignment.display.name=嵌套赋值
nested.assignment.problem.descriptor=使用的赋值表达式的结果 #loc
overloaded.methods.with.same.number.parameters.display.name=具有相同形参数量的重载方法
overloaded.vararg.method.display.name=重载 vararg 方法
refused.bequest.display.name=方法不调用 super 方法
reuse.of.local.variable.display.name=局部变量的重用
reuse.of.local.variable.split.quickfix=拆分局部变量
character.comparison.display.name=字符比较
character.comparison.problem.descriptor=国际化上下文中的字符比较 <code>#ref</code> #loc
package.visible.field.display.name=软件包可见字段
package.visible.field.problem.descriptor=软件包可见字段 <code>#ref</code> #loc
package.visible.inner.class.display.name=软件包可见的嵌套类
package.visible.inner.class.problem.descriptor=软件包可见的嵌套类 <code>#ref</code> #loc
package.visible.inner.class.ignore.enum.option=忽略软件包可见的内部枚举
package.visible.inner.class.ignore.interface.option=忽略软件包可见的内部接口
protected.field.display.name=protected 字段
protected.field.problem.descriptor=protected 字段 <code>#ref</code> #loc
protected.inner.class.display.name=protected 嵌套类
protected.inner.class.problem.descriptor=protected 嵌套类 <code>#ref</code> #loc
protected.inner.class.ignore.enum.option=忽略 'protected' 内部枚举
protected.inner.class.ignore.interface.option=忽略 'protected' 内部接口
public.field.display.name='public' 字段
public.field.problem.descriptor='public' 字段 <code>#ref</code> #loc
public.field.ignore.enum.type.fields.option=忽略枚举类型的 'public final' 字段
public.inner.class.display.name='public' 嵌套类
public.inner.class.problem.descriptor='public' 嵌套类 <code>#ref</code> #loc
public.inner.class.ignore.enum.option=忽略 'public' 内部枚举
public.inner.class.ignore.interface.option=忽略 'public' 内部接口
accessing.non.public.field.of.another.object.display.name=访问另一个对象的非 public 字段
accessing.non.public.field.of.another.object.problem.descriptor=直接访问另一个对象的非 public 字段 <code>#ref</code> #loc
call.to.date.tostring.display.name=调用 'Date.toString()'
call.to.date.tostring.problem.descriptor=国际化上下文中使用的 <code>Date.#ref()</code> #loc
magic.character.display.name=魔幻字符
magic.character.problem.descriptor=国际化上下文中使用的魔幻字符 <code>#ref</code> #loc
call.to.numeric.tostring.display.name=调用 'Number.toString()'
call.to.numeric.tostring.problem.descriptor=国际化上下文中调用的 <code>Number.#ref()</code> #loc
instantiating.simpledateformat.without.locale.display.name=无区域设置的 'SimpleDateFormat'
instantiating.simpledateformat.without.locale.problem.descriptor=在未在国际化上下文中指定区域设置的情况下实例化 <code>#ref</code> #loc
string.concatenation.display.name=字符串串联
string.concatenation.problem.descriptor=国际化上下文中的字符串串联 <code>#ref</code> #loc
inspection.option.ignore.system.out=对 'System.out.print' 实参忽略
inspection.option.ignore.system.err=对 'System.err.print' 实参忽略
inspection.option.ignore.assert=对断言语句描述实参忽略
inspection.option.ignore.exceptions=对 Throwable 子类的构造函数实参忽略
inspection.option.ignore.nonnls=通过 @NonNls 进行注解时忽略
inspection.option.ignore.constant.initializers=对常量字段的初始值设定项忽略
inspection.option.ignore.in.annotations=在注解中忽略
inspection.option.ignore.in.tostring=在 toString() 方法内部忽略
inspection.option.ignore.as.initial.capacity=忽略 StringBuilders 和 Collections 的初始容量
inspection.option.ignore.in.hashcode=忽略 'hashCode()' 方法中的常量
string.touppercase.tolowercase.without.locale.display.name=调用无区域设置的 'String.toUpperCase()' 或 'toLowerCase()'
string.touppercase.tolowercase.without.locale.problem.descriptor=在未使用国际化字符串指定区域设置的情况下调用 <code>String.#ref()</code> #loc
use.stringtokenizer.display.name=使用 'StringTokenizer'
use.stringtokenizer.problem.descriptor=国际化上下文中的 <code>#ref</code> #loc
time.tostring.call.display.name=调用 'Time.toString()'
time.tostring.call.problem.descriptor=国际化上下文中的 <code>Time.#ref()</code> #loc
class.escapes.defined.scope.display.name=不可访问的类公开
class.escapes.defined.scope.display.module.option=模块的 API 公开未导出的类(Java 9+)
class.escapes.defined.scope.display.public.option=公共 API 公开不可访问的类
class.escapes.defined.scope.display.package.option=Package-local API 公开 private 类
class.escapes.defined.scope.problem.descriptor=类 <code>#ref</code> 在其定义范围之外公开 #loc
class.escapes.defined.scope.java9.modules.descriptor=类 <code>#ref</code> 未从模块 ''{0}'' 导出
field.name.hides.in.superclass.display.name=子类字段隐藏超类字段
field.name.hides.in.superclass.problem.descriptor=字段 <code>#ref</code> 隐藏超类中的字段 #loc
field.name.hides.in.superclass.ignore.option=忽略不可访问字段
field.name.hides.in.superclass.ignore.static.field.option=忽略隐藏 static 字段的 static 字段
inner.class.field.hides.outer.display.name=内部类字段隐藏外部类字段
inner.class.field.hides.outer.ignore.option=忽略从内部类不可见的外部字段
inner.class.field.hides.outer.problem.descriptor=内部类字段 <code>#ref</code> 隐藏外部类字段 #loc
local.variable.hides.member.variable.display.name=局部变量隐藏字段
local.variable.hides.member.variable.problem.descriptor=局部变量 <code>#ref</code> 隐藏类 ''{0}'' 中的字段 #loc
local.variable.hides.member.variable.ignore.option=忽略隐藏非 static 字段的 static 上下文中的局部变量
method.overloads.display.name=可能是超类方法意外重载
method.overloads.problem.descriptor=当可能打算重写时，方法 <code>#ref()</code> 重载超类的兼容方法 #loc
method.overloads.report.incompatible.option=即使形参类型不兼容，也会报告
method.overrides.private.display.name.problem.descriptor=方法 <code>#ref()</code> 重写了超类的 'private' 方法 #loc
method.overrides.static.display.name=方法尝试重写超类的 'static' 方法
method.overrides.static.problem.descriptor=方法 <code>#ref()</code> 尝试重写超类的 static 方法 #loc
parameter.hides.member.variable.display.name=形参隐藏字段
parameter.hides.member.variable.problem.descriptor=形参 <code>#ref</code> 隐藏类 ''{0}'' 中的字段 #loc
parameter.hides.member.variable.ignore.setters.option=对属性 setter 忽略
parameter.hides.member.variable.ignore.superclass.option=忽略从子类不可见的超类字段
parameter.hides.member.variable.ignore.constructors.option=对构造函数忽略
parameter.hides.member.variable.ignore.abstract.methods.option=对 abstract 方法忽略
parameter.hides.member.variable.ignore.static.parameters.option=对隐藏实例字段的 static 方法形参忽略
type.parameter.hides.visible.type.display.name=类型形参隐藏可见类型
type.parameter.hides.visible.type.problem.descriptor=类型形参 <code>#ref</code> 隐藏可见类型 ''{0}'' #loc
type.parameter.hides.type.parameter.problem.descriptor=类型形参 <code>#ref</code> 隐藏类型形参 ''{0}'' #loc
anonymous.class.variable.hides.containing.method.variable.display.name=匿名类变量隐藏包含方法中的变量
anonymous.class.parameter.hides.containing.method.variable.problem.descriptor=匿名类形参 <code>#ref</code> 隐藏包含方法中的变量 #loc
anonymous.class.field.hides.containing.method.variable.problem.descriptor=匿名类字段 <code>#ref</code> 隐藏包含方法中的变量 #loc
anonymous.class.variable.hides.containing.method.variable.problem.descriptor=匿名类局部变量 <code>#ref</code> 隐藏包含方法中的变量 #loc
channel.opened.not.closed.display.name=打开了 'Channel'，但未安全关闭
drivermanager.call.display.name=使用 'DriverManager' 获取 JDBC 连接
drivermanager.call.problem.descriptor=调用 <code>DriverManager.#ref()</code> #loc
hibernate.resource.opened.not.closed.display.name=Hibernate 资源已打开，但未安全关闭
i.o.resource.opened.not.closed.display.name=I/O 资源已打开，但未安全关闭
resource.opened.not.closed.problem.descriptor=''{0}'' 应在 ''try'' 块之前打开，并在相应的 ''finally'' 块中关闭 #loc
jdbc.resource.opened.not.closed.display.name=JDBC 资源已打开，但未安全关闭
jndi.resource.opened.not.closed.display.name=JNDI 资源已打开，但未安全关闭
socket.opened.not.closed.display.name=套接字已打开，但未安全关闭
annotation.class.display.name=注解接口
annotation.class.problem.descriptor=注解接口 <code>#ref</code> #loc
annotation.display.name=注解
annotation.problem.descriptor=注解 <code>#ref</code> #loc
assert.statement.display.name='assert' 语句
statement.problem.descriptor=<code>#ref</code> 语句 #loc
auto.boxing.display.name=自动装箱
auto.boxing.problem.descriptor=自动装箱 <code>#ref</code> #loc
auto.boxing.make.boxing.explicit.quickfix=使装箱显式
auto.boxing.ignore.added.to.collection.option=忽略添加到集合的表达式
auto.unboxing.display.name=自动拆箱
auto.unboxing.problem.descriptor=自动拆箱 <code>#ref</code> #loc
auto.unboxing.make.unboxing.explicit.quickfix=使拆箱显式
enumerated.class.display.name=枚举类
enumerated.class.problem.descriptor=枚举类 <code>#ref</code> #loc
extended.for.statement.display.name=增强的 'for' 语句
extended.for.statement.replace.quickfix=替换为旧式 'for' 语句
variable.argument.method.display.name=vararg 方法
variable.argument.method.problem.descriptor=vararg 方法 <code>#ref()</code> #loc
variable.argument.method.quickfix=将 vararg 形参转换为数组
hardcoded.file.separator.display.name=硬编码文件分隔符
hardcoded.file.separator.problem.descriptor=硬编码文件分隔符 <code>#ref</code> #loc
hardcoded.file.separator.include.option=在已识别的 MIME 介质类型中包括 "example/*"
hardcoded.line.separator.display.name=硬编码行分隔符
hardcoded.line.separator.problem.descriptor=硬编码行分隔符 <code>#ref</code> #loc
native.method.display.name=本地方法
native.method.problem.descriptor=声明为 <code>#ref</code> 的方法不可移植 #loc
runtime.exec.call.display.name=调用 'Runtime.exec()'
runtime.exec.call.problem.descriptor=对 <code>Runtime.#ref()</code> 的调用不可移植 #loc
system.exit.call.display.name=调用 'System.exit()' 或相关方法
system.exit.call.problem.descriptor=对 <code>{0}.#ref()</code> 的调用不可移植 #loc
system.exit.call.ignore.option=在主方法中忽略
system.getenv.call.display.name=调用 'System.getenv()'
system.getenv.call.problem.descriptor=对 <code>System.#ref()</code> 的调用不可移植 #loc
use.of.awt.peer.class.display.name=使用 AWT 对等类
use.of.awt.peer.class.problem.descriptor=AWT 对等类 <code>#ref</code> 的使用不可移植 #loc
use.of.concrete.jdbc.driver.class.display.name=使用具体的 JDBC 驱动程序类
use.of.concrete.jdbc.driver.class.problem.descriptor=具体 JDBC 驱动程序类 <code>#ref</code> 的使用不可移植 #loc
use.processbuilder.class.display.name=使用 'java.lang.ProcessBuilder' 类
use.processbuilder.class.problem.descriptor=<code>#ref</code> 的使用不可移植 #loc
use.sun.classes.display.name=使用 'sun.*' 类
use.sun.classes.problem.descriptor=Sun 提供的类 <code>#ref</code> 的使用不可移植 #loc
abstract.class.with.only.one.direct.inheritor.display.name=只有一个直接继承者的 abstract 类
anonymous.inner.may.be.named.static.inner.class.display.name=匿名类可能是命名为 'static' 的内部类
anonymous.inner.may.be.named.static.inner.class.problem.descriptor=匿名类 <code>#ref</code> 可能是命名为 'static' 的内部类 #loc
array.length.in.loop.condition.display.name=循环条件下的 Array.length
array.length.in.loop.condition.problem.descriptor=检查循环条件下的数组 <code>#ref</code> #loc
large.array.allocation.no.outofmemoryerror.display.name=没有 OutOfMemoryError 检查的大型数组分配
large.array.allocation.no.outofmemoryerror.problem.descriptor=未检查内存不足情况的大型数组分配 #loc
large.array.allocation.no.outofmemoryerror.maximum.number.of.elements.option=最大元素数:
connection.opened.not.safely.closed.display.name=集合已打开，但未安全关闭
interface.one.inheritor.display.name=只有一个直接继承者的接口
interface.one.inheritor.problem.descriptor=只有一个直接继承者的接口 <code>#ref</code> #loc
method.call.in.loop.condition.display.name=循环条件下的方法调用
method.call.in.loop.condition.problem.descriptor=循环条件下调用方法 <code>#ref()</code> #loc
large.initializer.primitive.type.array.display.name=原始类型数组的过大初始值设定项
large.initializer.primitive.type.array.problem.descriptor=具有太多元素 ({0}) 的原始数组初始值设定项 #loc
large.initializer.primitive.type.array.maximum.number.of.elements.option=最大元素数:
private.member.access.between.outer.and.inner.classes.display.name=合成访问器调用
private.member.access.between.outer.and.inner.classes.problem.descriptor=访问类 ''{0}'' 的 ''private'' 成员需要合成访问器 #loc
private.member.access.between.outer.and.inner.classes.make.local.quickfix=将 ''{0}'' 设为 package-private
private.member.access.between.outer.and.inner.classes.make.constructor.package.local.quickfix=将 ''{0}'' 构造函数设为 package-private
recordstore.opened.not.safely.closed.display.name=打开了 'RecordStore'，但未安全关闭
overly.complex.anonymous.inner.class.display.name=过度复杂的匿名类
cyclomatic.complexity.limit.option=循环复杂度限制:
overly.complex.anonymous.inner.class.problem.descriptor=过度复杂的匿名类 (循环复杂度 = {0}) #loc
anonymous.inner.class.with.too.many.methods.display.name=具有太多方法的匿名内部类
method.count.limit.option=方法计数限制:
anonymous.inner.class.with.too.many.methods.problem.descriptor=具有太多方法的匿名内部类 (方法计数 = {0}) #loc
overly.complex.class.display.name=过度复杂的类
overly.complex.class.problem.descriptor=过度复杂的类<code>#ref</code> (循环复杂度 = {0}) #loc
overly.coupled.class.display.name=过度耦合的类
overly.coupled.class.class.coupling.limit.option=类耦合限制:
include.java.system.classes.option=包括与 Java 系统类的耦合
include.library.classes.option=包括与库类的耦合
overly.coupled.class.problem.descriptor=<code>#ref</code> 过度耦合 (依赖 = {0}) #loc
class.too.deep.display.name=类在继承树中太深
class.too.deep.inheritance.depth.limit.option=继承深度限制:
class.too.deep.problem.descriptor=<code>#ref</code> 在继承树中太深 (继承深度 = {0}) #loc
inner.class.too.deeply.nested.display.name=内部类嵌套太深
inner.class.too.deeply.nested.nesting.limit.option=嵌套限制:
inner.class.too.deeply.nested.problem.descriptor=<code>#ref</code> 嵌套太深 (嵌套级别 = {0}) #loc
too.many.constructors.display.name=构造函数过多的类
too.many.constructors.count.limit.option=构造函数计数限制:
too.many.constructors.ignore.deprecated.option=忽略弃用的构造函数
too.many.constructors.problem.descriptor=<code>#ref</code> 的构造函数过多 (构造函数计数 = {0}) #loc
too.many.fields.display.name=字段过多的类
too.many.fields.count.limit.option=字段计数限制:
too.many.fields.problem.descriptor=<code>#ref</code> 的字段过多 (字段计数 = {0}) #loc
too.many.methods.display.name=方法过多的类
too.many.methods.problem.descriptor=<code>#ref</code> 的方法过多 (方法计数 = {0}) #loc
externalizable.with.serialization.methods.display.name=具有 'readObject()' 或 'writeObject()' 的可外部化类
externalizable.with.serialization.methods.problem.descriptor.both=可外部化{0, choice, 1#类|2#接口|3#派生的匿名类|4#注解类型|5#枚举|6#记录} <code>#ref</code> 定义 'readObject()' 和 'writeObject()' #loc
externalizable.with.serialization.methods.problem.descriptor.write=可外部化{0, choice, 1#类|2#接口|3#派生的匿名类|4#注解类型|5#枚举|6#记录} <code>#ref</code> 定义 'writeObject()' #loc
externalizable.with.serialization.methods.problem.descriptor.read=可外部化{0, choice, 1#类|2#接口|3#派生的匿名类|4#注解类型|5#枚举|6#记录} <code>#ref</code> 定义 'readObject()' #loc
non.serializable.with.serialversionuid.display.name=具有 'serialVersionUID' 的不可序列化类
non.serializable.class.with.serialversionuid.problem.descriptor=定义 'serialVersionUID' 字段的不可序列化类 <code>#ref</code> #loc
non.serializable.interface.with.serialversionuid.problem.descriptor=定义 'serialVersionUID' 字段的不可序列化接口 <code>#ref</code> #loc
non.serializable.@interface.with.serialversionuid.problem.descriptor=定义 'serialVersionUID' 字段的不可序列化 @interface <code>#ref</code> #loc
non.serializable.anonymous.with.serialversionuid.problem.descriptor=派生自 <code>#ref</code> 的不可序列化匿名类定义 'serialVersionUID' 字段 #loc
non.serializable.class.with.readwriteobject.display.name=具有 'readObject()' 或 'writeObject()' 的不可序列化类
non.serializable.class.with.readwriteobject.problem.descriptor.both=不可序列化{0, choice, 1#类|2#接口|3#派生的匿名类|4#注解类型|5#枚举|6#记录} <code>#ref</code> 定义 'readObject()' 和 'writeObject()' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.write=不可序列化{0, choice, 1#类|2#接口|3#派生的匿名类|4#注解类型|5#枚举|6#记录} <code>#ref</code> 定义 'writeObject()' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.read=不可序列化{0, choice, 1#类|2#接口|3#派生的匿名类|4#注解类型|5#枚举|6#记录} <code>#ref</code> 定义 'readObject()' #loc
readwriteobject.private.display.name='readObject()' 或 'writeObject()' 未被声明为 'private'
readwriteobject.private.problem.descriptor=<code>#ref</code> 未被声明为 'private' #loc
readobject.initialization.display.name=实例字段可能无法被 'readObject()' 初始化
readobject.initialization.problem.descriptor=实例字段 <code>#ref</code> 在 'readObject()' 调用期间可能无法初始化 #loc
readresolve.writereplace.protected.display.name='readResolve()' 或 'writeReplace()' 未被声明为 'protected'
readresolve.writereplace.protected.problem.descriptor=<code>#ref()</code> 未被声明为 'protected' #loc
missing.serial.annotation.display.name=可以使用 '@Serial' 注解
missing.serial.annotation.on.field.problem.descriptor=<code>#ref</code> 可以使用 '@Serial' 进行注解
missing.serial.annotation.on.method.problem.descriptor=<code>#ref()</code> 可以使用 '@Serial' 进行注解
serial.annotation.used.on.wrong.member.display.name=对错误的成员使用了 '@Serial' 注解
serial.annotation.used.on.wrong.member.problem.descriptor=注解的成员不是序列化机制的一部分
serializable.record.contains.ignored.members.display.name='record' 包含被忽略的成员
serializable.record.contains.ignored.field.problem.descriptor=在记录序列化期间将忽略 <code>#ref</code>
serializable.record.contains.ignored.method.problem.descriptor=在记录序列化期间将忽略 <code>#ref()</code>
serialpersistentfields.with.wrong.signature.display.name='serialPersistentFields' 字段未被声明为 'private static final ObjectStreamField[]'
serialpersistentfields.with.wrong.signature.problem.descriptor=可序列化类的 <code>#ref</code> 字段未被声明为 'private static final ObjectStreamField[]' #loc
serialversionuid.private.static.final.long.display.name='serialVersionUID' 字段未被声明为 'private static final long'
serialversionuid.private.static.final.long.problem.descriptor=可序列化类的 <code>#ref</code> 字段未被声明为 'private static final long' #loc
serialversionuid.private.static.final.long.quickfix=将 serialVersionUID 设为 'private static final'

#dynamic
non.protected.constructor.in.abstract.class.display.name=abstract 类中的 public 构造函数
unnecessary.qualifier.for.this.display.name='this' 或 'super' 的限定符不必要
multiple.declaration.display.name=一个声明中的多个变量
thread.priority.display.name=调用 'Thread.setPriority()'
too.broad.scope.display.name=变量范围过宽
infinite.loop.statement.display.name=无限循环语句
asserts.without.messages.display.name=断言上缺少消息
constant.naming.convention.element.description=常量
constant.with.mutable.field.naming.convention.element.description=具有可变类型的常量
random.double.for.random.integer.display.name=使用 'Random.nextDouble()' 获取随机整数
test.method.without.assertion.display.name=没有任何断言的 JUnit 测试方法
string.buffer.replaceable.by.string.builder.display.name='StringBuffer' 可能是 'StringBuilder'
comparison.of.short.and.char.display.name=比较 'short' 和 'char' 值
unnecessary.fully.qualified.name.display.name=不必要的完全限定名称
ignore.in.module.statements.option=在 Java 9 模块语句中忽略
unnecessary.label.on.break.statement.display.name='break' 语句上的标签不必要
exception.name.doesnt.end.with.exception.display.name=异常类名不以 'Exception' 结尾
bad.exception.declared.display.name=已声明禁止异常
pointless.boolean.expression.display.name=无意义的语句或布尔表达式
class.without.constructor.display.name=不带构造函数的类
break.statement.display.name='break' 语句
unconditional.wait.display.name=无条件的 'wait()' 调用
cyclomatic.complexity.display.name=过度复杂的方法
final.class.display.name=类禁止继承
labeled.statement.display.name=标记语句
notify.called.on.condition.display.name=在 'java.util.concurrent.locks.Condition' 对象上调用了 'notify()' 或 'notifyAll()'
loop.statements.that.dont.loop.display.name=不循环的循环语句
ignore.enhanced.for.loop.statements=忽略增强型 for 循环
non.synchronized.method.overrides.synchronized.method.display.name=未同步方法重写 'synchronized' 方法
synchronize.on.this.display.name=在 'this' 上同步
switch.statement.with.too.many.branches.display.name=最大 'switch' 分支
utility.class.without.private.constructor.display.name=实用程序类没有 'private' 构造函数
throw.caught.locally.display.name=通过包含 'try' 语句捕获 'throw'
exception.from.catch.which.doesnt.wrap.display.name='throw' 位于忽略已捕获异常的 'catch' 块内
type.parameter.naming.convention.element.description=类型形参
multiply.or.divide.by.power.of.two.display.name=乘以或除以 2 的幂
multiply.or.divide.by.power.of.two.divide.option=还通过 2 的幂检查除法
serializable.with.unconstructable.ancestor.display.name=具有不可构造上级的可序列化类
missorted.modifiers.display.name=错位修饰符
sleep.while.holding.lock.display.name=同步时调用 'Thread.sleep()'
singleton.display.name=单例
thread.death.rethrown.display.name='ThreadDeath' 未重新抛出
if.statement.with.too.many.branches.display.name='if' 语句的分支过多
redundant.implements.display.name=冗余接口声明
nesting.depth.display.name=过度嵌套的方法
return.this.display.name=返回 'this'
busy.wait.display.name=忙等待
utility.class.display.name=实用程序类
instantiating.object.to.get.class.object.display.name=实例化对象以获取 'Class' 对象
abstract.class.extends.concrete.class.display.name=abstract 类扩展具体类
parameter.naming.convention.display.name=方法形参命名惯例
parameter.naming.convention.element.description=形参
integer.division.in.floating.point.context.display.name=浮点上下文中的整数除法
interface.naming.convention.element.description=接口
length.one.strings.in.concatenation.display.name=单字符字符串串联
length.one.string.in.indexof.display.name= 'String.indexOf()' 调用中的单字符字符串实参
thread.yield.display.name=调用 'Thread.yield()'
confusing.floating.point.literal.display.name=浮点文字会引起混淆
wait.not.in.loop.display.name=未在循环中调用的 'wait()'
string.concatenation.inside.string.buffer.append.display.name=字符串串联作为 'StringBuilder.append()' 调用的实参
class.initializer.display.name=非 'static' 初始值设定项
enumerated.class.naming.convention.element.description=枚举类
non.thread.safe.lazy.initialization.display.name=不安全的 'static' 字段延迟初始化
call.to.simple.setter.in.class.display.name=从类内调用简单 setter
comparison.to.nan.display.name=与 'Double.NaN' 或 'Float.NaN' 比较
new.method.naming.convention.display.name=方法命名惯例
instance.method.naming.convention.element.description=实例方法
unnecessary.semicolon.display.name=不必要的分号
fallthru.in.switch.statement.display.name='switch' 语句中的直落
call.to.native.method.while.locked.display.name=锁定时调用 'native' 方法
switch.statement.display.name='switch' 语句
custom.classloader.display.name=声明了自定义的 'ClassLoader'
nested.conditional.expression.display.name=嵌套条件表达式
duplicate.condition.display.name=条件重复
method.with.multiple.loops.display.name=具有多个循环的方法
non.comment.source.statements.display.name=过长的方法
local.variable.naming.convention.display.name=局部变量命名惯例
local.variable.naming.convention.element.description=局部变量
negated.if.else.display.name=具有否定条件的 'if' 语句
class.naming.convention.display.name=类命名惯例
class.naming.convention.element.description=类
abstract.class.naming.convention.element.description=abstract 类
serializable.inner.class.with.non.serializable.outer.class.display.name=可序列化非 'static' 内部类具有不可序列化外部类
pointless.arithmetic.expression.display.name=无意义的算术表达式
method.name.same.as.class.name.display.name=方法名称与类名相同
unnecessary.temporary.on.conversion.to.string.display.name=转换为 'String' 时有不必要的临时对象
unnecessary.continue.display.name=不必要的 'continue' 语句
inner.class.on.interface.display.name=接口的内部类
unused.label.display.name=未使用的标签
overly.complex.boolean.expression.display.name=过度复杂的布尔表达式
continue.statement.with.label.display.name=带标签的 'continue' 语句
class.loader.instantiation.display.name='ClassLoader' 实例化
return.from.finally.block.display.name='return' 位于 'finally' 块内
unnecessary.boxing.display.name=不必要的装箱
annotation.naming.convention.element.description=注解接口
checked.exception.class.display.name=已检查的异常类
switch.statement.with.confusing.declaration.display.name=在不同 'switch' 分支中使用并声明的局部变量
cast.that.loses.precision.display.name=损失精度的数字转换
manual.array.copy.display.name=手动数组复制
manual.array.to.collection.copy.display.name=手动数组到集合复制
long.literals.ending.with.lowercase.l.display.name='long' 文字以 'l' 而不是 'L' 结尾
overly.complex.arithmetic.expression.display.name=过于复杂的算术表达式
junit.abstract.test.class.naming.convention.element.description=Abstract 测试类
unnecessary.parentheses.display.name=不必要的圆括号
test.case.in.product.code.display.name=产品源中的 JUnit 'TestCase'
test.method.in.product.code.display.name=产品源中的 JUnit 测试方法
serializable.class.in.secure.context.display.name=安全上下文中的可序列化类
static.variable.naming.convention.element.description='static' 字段
nested.method.call.display.name=嵌套方法调用
throw.from.finally.block.display.name='throw' 位于 'finally' 块内
field.accessed.synchronized.and.unsynchronized.display.name=同时在 'synchronized' 和未同步上下文中访问字段
abstract.method.overrides.abstract.method.display.name=abstract 方法重写 abstract 方法
static.non.final.field.display.name='static' 非 'final' 字段
static.non.final.field.option=仅报告 'public' 字段
class.without.no.arg.constructor.display.name=没有无实参构造函数的类
unnecessary.return.display.name=不必要的 'return' 语句
final.static.method.display.name='static' 方法被声明为 'final'
constant.declared.in.abstract.class.display.name=在 'abstract' 类中声明的常量
too.broad.catch.display.name=过宽的 'catch' 块
floating.point.equality.display.name=浮点相等比较
thrown.exceptions.per.method.display.name=方法声明的异常过多
public.static.array.field.display.name='public static' 数组字段
await.not.in.loop.display.name=未在循环中调用的 'await()'
method.names.differ.only.by.case.display.name=方法名称仅大小写不同
unsecure.random.number.generation.display.name=不安全的随机数生成
parameters.per.method.display.name=形参过多的方法
parameters.per.constructor.display.name=形参过多的构造函数
unnecessary.unboxing.display.name=不必要的拆箱
extends.thread.display.name=类直接扩展 'Thread'
test.case.with.constructor.display.name=具有非普通构造函数的 JUnit TestCase
parameter.name.differs.from.overridden.parameter.display.name=形参名称与重写或重载方法中的参数不同
final.private.method.display.name='private' 方法被声明为 'final'
enum.switch.statement.which.misses.cases.display.name=缺少 case 的枚举 'switch' 语句
enum.switch.statement.which.misses.cases.option=忽略具有默认分支的 switch 语句
string.buffer.must.have.initial.capacity.display.name=没有初始容量的 'StringBuilder'
method.may.be.static.display.name=方法可以为 'static'
class.initializer.may.be.static.display.name=类初始值设定项可能为 'static'
class.initializer.option=仅在类具有一个或多个构造函数时警告
class.initializer.move.code.to.constructor.quickfix=将初始值设定项代码移动到构造函数
nested.switch.statement.display.name=嵌套 'switch' 语句
c.style.array.declaration.display.name=C 样式数组声明
final.method.in.final.class.display.name='final' 类位于 'final' 方法中
extends.annotation.display.name=类扩展注解接口
naked.notify.display.name=没有相应状态更改的 'notify()' 或 'notifyAll()'
switch.statement.density.display.name='switch' 语句的分支密度过低
switch.statement.with.too.few.branches.display.name=最小 'switch' 分支
upper.case.field.name.not.constant.display.name=具有大写名称的非常量字段
unnecessary.label.on.continue.statement.display.name='continue' 语句上的不必要标签
jdbc.prepare.statement.with.non.constant.string.display.name='Connection.prepare*()' 调用具有非常量字符串
synchronize.on.non.final.field.display.name=在非 final 字段上同步
noop.method.in.abstract.class.display.name='abstract' 类中的无运算方法
non.final.field.of.exception.display.name='Exception' 类的非 final 字段
nested.try.statement.display.name=嵌套 'try' 语句
condition.signal.display.name=调用 'signal()' 而不是 'signalAll()'
jdbc.execute.with.non.constant.string.display.name='Statement.execute()' 调用具有非常量字符串
system.set.security.manager.display.name=调用 'System.setSecurityManager()'
system.set.security.manager.problem.descriptor=对 <code>System.#ref()</code> 的调用可能造成安全问题 #loc
control.flow.statement.without.braces.display.name=不带大括号的控制流语句
trivial.if.display.name=冗余的 'if' 语句
trivial.if.fix.family.name=简化 'if else'
trivial.if.option.ignore.chained=忽略链式 'if' 语句
thread.with.default.run.method.display.name=使用默认的 'run()' 方法实例化 'Thread'
while.loop.spins.on.field.display.name='while' 循环在字段上自旋
while.loop.spins.on.field.fix.family.name=修复自旋循环
while.loop.spins.on.field.fix.volatile=将 ''{0}'' 设为 volatile
while.loop.spins.on.field.fix.spinwait=添加 Thread.onSpinWait()
while.loop.spins.on.field.fix.volatile.spinwait=将 ''{0}'' 设为 volatile 并添加 Thread.onSpinWait()
if.statement.with.identical.branches.display.name='if' 语句的分支相同
inspection.common.if.parts.message.variables.only=从 ''if'' 中提取变量{0}
inspection.common.if.parts.message.with.variables.extract=从 ''if'' 中提取包含变量的通用部分{0}
inspection.common.if.parts.message.without.variables.extract=从 ''if'' 中提取通用部分{0}
inspection.common.if.parts.message.whole.branch=提取通用部分，同时移除分支{0}
inspection.common.if.parts.message.complete.duplicate=收起 ''if'' 语句{0}
inspection.common.if.parts.message.complete.duplicate.side.effect=收起 'if' 语句并提取副作用
inspection.common.if.parts.description.variables.only=可以从 ''if'' 中提取变量{0}
inspection.common.if.parts.description.with.variables.extract=可以从 ''if'' 中提取包含变量的通用部分{0}
inspection.common.if.parts.description.without.variables.extract=可以从 ''if'' 中提取通用部分{0}
inspection.common.if.parts.description.whole.branch=可以提取通用部分，同时移除分支{0}
inspection.common.if.parts.description.complete.duplicate=可以收起 ''if'' 语句{0}
inspection.common.if.parts.description.complete.duplicate.side.effect=可以通过提取副作用收起 'if' 语句
inspection.note.may.change.semantics=可能更改语义
multiple.return.points.per.method.display.name=具有多个返回点的方法
break.statement.with.label.display.name=带标签的 'break' 语句
public.constructor.in.non.public.class.display.name='public' 构造函数位于非 public 类中
questionable.name.display.name=可疑名称
empty.finally.block.display.name=空 'finally' 块
abstract.method.overrides.concrete.method.display.name=abstract 方法重写具体方法
thread.stop.suspend.resume.display.name=调用 'Thread.stop()'、'suspend()' 或 'resume()'
constant.math.call.display.name=对 'Math' 的常量调用
volatile.array.field.display.name=volatile 数组字段
literal.as.arg.to.string.equals.display.name=字符串文字可以为 'equals()' 限定符
inner.class.may.be.static.display.name=内部类可能为 'static'
redundant.field.initialization.display.name=冗余字段初始化
string.buffer.to.string.in.concatenation.display.name=连接中的 'StringBuilder.toString()'
utility.class.with.public.constructor.display.name=实用程序类具有 'public' 构造函数
for.loop.replaceable.by.while.display.name='for' 循环可被替换为 'while' 循环
missing.deprecated.annotation.display.name=缺少 '@Deprecated' 注解
cloneable.class.in.secure.context.display.name=安全上下文中的可克隆类
static.inheritance.display.name=静态继承
class.name.prefixed.with.package.name.display.name=使用软件包名称作为前缀的类名
call.to.simple.getter.in.class.display.name=从类内调用简单 getter
class.name.differs.from.file.name.display.name=类名与文件名不同
protected.member.in.final.class.display.name='protected' 成员位于 'final' 类中
load.library.with.non.constant.string.display.name='System.loadLibrary()' 调用具有非常量字符串
instanceof.catch.parameter.display.name='catch' 形参上的 'instanceof'
implicit.numeric.conversion.display.name=隐式数字转换
confusing.main.method.display.name=引起混淆的 'main()' 方法
octal.literal.display.name=八进制整数
misordered.assert.equals.arguments.display.name=顺序错误的 'assertEquals()' 实参
unnecessary.constructor.display.name=冗余无实参构造函数
method.name.same.as.parent.name.display.name=方法名称与父类名相同
while.can.be.foreach.display.name='while' 循环可被替换为增强的 'for' 循环
big.decimal.equals.display.name=在 'BigDecimal' 上调用了 'equals()'
implicit.call.to.super.display.name=隐式调用 'super()'
unqualified.static.usage.display.name=非限定静态访问
simplifiable.junit.assertion.display.name=可简化断言
object.notify.display.name=调用 'notify()' 而不是 'notifyAll()'
thread.start.in.construction.display.name=对象构造期间调用 'Thread.start()'
non.final.clone.display.name=非 final 'clone()' 位于安全上下文中
unnecessary.temporary.on.conversion.from.string.display.name=从 'String' 转换时有不必要的临时对象
unnecessary.this.display.name=不必要的 'this' 限定符
unnecessary.this.ignore.assignments.option=忽略字段赋值
runtime.exec.with.non.constant.string.display.name='Runtime.exec()' 调用具有非常量字符串
system.properties.display.name=系统属性的访问
chained.method.call.display.name=链式方法调用
safe.lock.display.name=已获取但未安全解锁的锁
system.run.finalizers.on.exit.display.name=调用 'System.runFinalizersOnExit()'
for.can.be.foreach.display.name='for' 循环可被替换为增强的 for 循环
type.parameter.extends.object.display.name=类型形参显式扩展 'Object'
type.parameter.extends.object.ignore.annotated=注解 java.lang.Object 时忽略
marker.interface.display.name=标记接口
limited.scope.inner.class.display.name=局部类
switch.statements.without.default.display.name=不带 'default' 分支的 'switch' 语句
unchecked.exception.class.display.name=未检查的 'Exception' 类
for.loop.with.missing.component.display.name=缺少组件的 'for' 循环
for.loop.with.missing.component.collection.loop.option=忽略集合迭代
double.checked.locking.display.name=双重检查锁定
double.checked.locking.problem.descriptor=双重检查锁定 #loc
string.buffer.replaceable.by.string.display.name='StringBuilder' 可被替换为 'String'
boolean.method.name.must.start.with.question.display.name=布尔方法名称必须以疑问词开头
class.name.same.as.ancestor.name.display.name=类名与上级名称相同
error.rethrown.display.name='Error' 未重新抛出
serializable.has.serialization.methods.display.name=不带 'readObject()' 和 'writeObject()' 的可序列化类
serializable.has.serialization.methods.ignore.option=忽略未定义实例字段的类
missing.override.annotation.display.name=缺少 '@Override' 注解
wait.while.holding.two.locks.display.name=保持两个锁时 'wait()'
empty.class.display.name=冗余空类
trivial.string.concatenation.display.name=与空字符串串联
empty.synchronized.statement.display.name=空 'synchronized' 语句
unnecessary.default.display.name=枚举 'switch' 语句的 'default' 不必要
simplifiable.conditional.expression.display.name=可简化的条件表达式
unnecessary.super.constructor.display.name=对 'super()' 的调用不必要
unnecessarily.qualified.static.usage.display.name=不必要的限定静态访问
bad.exception.caught.display.name=已捕获禁止的 'Exception'
custom.security.manager.display.name=自定义 'SecurityManager'
string.concatenation.in.loops.display.name=字符串串联在循环中
boolean.constructor.display.name=布尔构造函数调用
continue.statement.display.name='continue' 语句
extends.object.display.name=类显式扩展 'Object'
serializable.inner.class.has.serial.version.uid.field.display.name=没有 'serialVersionUID' 的可序列化非 static 内部类
static.method.naming.convention.element.description='static' 方法
empty.try.block.display.name=空 'try' 块
field.has.setter.but.no.getter.display.name=字段具有 setter 但没有 getter
three.negations.per.method.display.name=具有三个以上否定的方法
conditional.expression.display.name=条件表达式
string.equals.empty.string.display.name='String.equals()' 可被替换为 'String.isEmpty()'
synchronize.on.lock.display.name=在 'Lock' 对象上同步
synchronized.on.literal.object.name=在使用文字初始化的对象上同步
field.may.be.static.display.name=字段可以为 'static'
class.may.be.interface.display.name='abstract' 类可以是 'interface'
abstract.class.without.abstract.methods.display.name=没有 'abstract' 方法的 abstract 类
divide.by.zero.display.name=除以零
default.not.last.case.in.switch.display.name='default' 不是 'switch' 中的最后一个 case
nested.synchronized.statement.display.name=嵌套 'synchronized' 语句
constant.conditional.expression.display.name=常量条件表达式
redundant.else.display.name=冗余的 'else'
public.field.accessed.in.synchronized.context.display.name=在 'synchronized' 上下文中访问d了非 private 字段
string.replaceable.by.string.buffer.display.name=非常量 'String' 可被替换为 'StringBuilder'
junit.test.class.naming.convention.element.description=测试类
junit.test.suite.naming.convention.element.description=测试套件
method.coupling.display.name=过度耦合的方法
collections.must.have.initial.capacity.display.name=没有初始容量的集合
anonymous.inner.class.display.name=匿名内部类可被替换为内部类
negated.conditional.display.name=具有否定条件的条件表达式
non.reproducible.math.call.display.name=对 'Math' 的不可重现调用
multiple.top.level.classes.in.file.display.name=单个文件中的多个顶级类
set.replaceable.by.enum.set.display.name='Set' 可被替换为 'EnumSet'
tail.recursion.display.name=尾递归
finally.block.cannot.complete.normally.display.name=不能正常完成的 'finally' 块
non.atomic.operation.on.volatile.field.display.name='volatile' 字段上的非原子操作
public.static.collection.field.display.name='public static' 集合字段
non.exception.name.ends.with.exception.display.name=非异常类名以 'Exception' 结尾
synchronized.method.display.name='synchronized' 方法
enumerated.constant.naming.convention.element.description=枚举常量
final.method.display.name=不能重写方法
transient.field.in.non.serializable.class.display.name=不可序列化类中存在 transient 字段
bad.exception.thrown.display.name=已抛出禁止异常
conditional.expression.with.identical.branches.display.name=具有相同分支的条件表达式
conditional.can.be.pushed.inside.expression.display.name=可以将条件推送到分支表达式内部
conditional.can.be.pushed.inside.expression.option=在条件将仅作为方法调用的实参时忽略
conditional.can.be.pushed.inside.expression.quickfix=在分支内推送条件表达式
raw.use.of.parameterized.type.display.name=形参化类的原始使用
standard.variable.names.display.name=标准变量名称
field.naming.convention.display.name=字段命名惯例
instance.variable.naming.convention.element.description=实例字段
dollar.sign.in.name.display.name=在标识符中使用 '$'
map.replaceable.by.enum.map.display.name='Map' 可被替换为 'EnumMap'
extends.concrete.collection.display.name=类显式扩展 'Collection' 类
continue.or.break.from.finally.block.display.name='continue' 或 'break' 位于 'finally' 块内
abstract.method.with.missing.implementations.display.name=缺少实现的 abstract 方法
object.allocation.in.loop.display.name=循环中的对象分配
wait.called.on.condition.display.name=在 'java.util.concurrent.locks.Condition' 对象上调用了 'wait()'
test.case.with.no.test.methods.display.name=没有测试的测试类
abstract.class.never.implemented.display.name=没有具体子类的 abstract 类
interface.never.implemented.display.name=没有具体子类的接口
constant.declared.in.interface.display.name=在接口中声明的常量


#problem descriptors
exception.name.doesnt.end.with.exception.problem.descriptor=异常类名 <code>#ref</code> 未以 'Exception' 结尾 #loc
non.exception.name.ends.with.exception.problem.descriptor=非异常类名 <code>#ref</code> 以 'Exception' 结尾 #loc
class.name.prefixed.with.package.name.problem.descriptor=类名 <code>#ref</code> 以其软件包名称开始 #loc
class.name.same.as.ancestor.name.problem.descriptor=类名 <code>#ref</code> 与其超类的名称之一相同 #loc
method.name.same.as.class.name.problem.descriptor=方法名称 <code>#ref</code> 与其类名相同 #loc
method.name.same.as.parent.name.problem.descriptor=方法名称 <code>#ref</code> 与其父类名相同 #loc
boolean.method.name.must.start.with.question.problem.descriptor=布尔方法名称 <code>#ref</code> 未以疑问词开头 #loc
questionable.name.problem.descriptor=可疑名称 <code>#ref</code> #loc
confusing.main.method.problem.descriptor=方法名称 <code>#ref</code> 没有签名 'public static void main(String[])' #loc
upper.case.field.name.not.constant.problem.descriptor=带常量样式名称的非常量字段 <code>#ref</code> #loc
dollar.sign.in.name.problem.descriptor=标识符 <code>#ref</code> 包含 '$' #loc
integer.division.in.floating.point.context.problem.descriptor=<code>#ref</code>: 浮点上下文中的整数除法 #loc
comparison.of.short.and.char.problem.descriptor=short 和 char 值的相等比较 <code>#ref</code> #loc
big.decimal.equals.problem.descriptor=BigDecimal 值之间的 <code>#ref()</code> 可能应当是 'compareTo()' #loc
divide.by.zero.problem.descriptor=除以零 #loc
non.reproducible.math.call.problem.descriptor=<code>Math.#ref()</code> 可能产生不可重现的结果 #loc
constant.math.call.problem.descriptor=对 <code>#ref()</code> 的常量调用可以简化 #loc
floating.point.equality.problem.descriptor=<code>#ref</code>: 比较浮点值以实现完全相等 #loc
fallthru.in.switch.statement.problem.descriptor='switch' 语句存在直落 #loc
switch.statements.without.default.problem.descriptor=没有 'default' 分支的 <code>#ref</code> 语句 #loc
default.not.last.case.in.switch.problem.descriptor=<code>#ref</code> 分支不是 ''switch'' {0} 中的最后一个 case #loc
loop.statements.that.dont.loop.problem.descriptor=<code>#ref</code> 语句未循环 #loc
conditional.expression.with.identical.branches.problem.descriptor=具有相同分支的条件表达式 <code>#ref</code> #loc
conditional.can.be.pushed.inside.expression.problem.descriptor=条件表达式可以推送到分支内 #loc
duplicate.condition.problem.descriptor=重复条件 <code>#ref</code> #loc
duplicate.condition.ignore.method.calls.option=忽略有副作用的条件
iterator.next.does.not.throw.nosuchelementexception.problem.descriptor=无法抛出 'NoSuchElementException' 的 <code>Iterator.#ref()</code> '#loc
infinite.loop.statement.problem.descriptor=<code>#ref</code> 语句不能在未抛出异常的情况下完成 #loc
confusing.floating.point.literal.problem.descriptor=引起混淆的浮点文字 <code>#ref</code> #loc
overly.complex.arithmetic.expression.problem.descriptor=过于复杂的算术表达式 #loc
overly.complex.boolean.expression.problem.descriptor=过度复杂的布尔表达式 ({0} 项) #loc
labeled.statement.problem.descriptor=标记语句 <code>#ref:</code> #loc
break.statement.with.label.problem.descriptor=带标签的 <code>#ref</code> 语句 #loc
continue.statement.with.label.problem.descriptor=带标签的 <code>#ref</code> 语句 #loc
conditional.expression.problem.descriptor=条件表达式 <code>#ref</code> #loc
conditional.expression.option=对简单赋值和返回值忽略
conditional.expression.expression.context.option=忽略无法使用 if 语句的位置
conditional.expression.quickfix=替换为 'if' 语句
nested.conditional.expression.problem.descriptor=嵌套条件表达式 <code>#ref</code> #loc
long.literals.ending.with.lowercase.l.problem.descriptor='long' 文字 <code>#ref</code> 以小写 'l' 结尾 #loc
nested.switch.statement.problem.descriptor=嵌套 <code>#ref</code> {0} #loc
chained.method.call.problem.descriptor=链式方法调用 <code>#ref()</code> #loc
nested.method.call.problem.descriptor=嵌套方法调用 <code>#ref()</code> #loc
octal.literal.problem.descriptor=八进制整数 <code>#ref</code> #loc
implicit.call.to.super.problem.descriptor=隐式调用 'super()' #loc
negated.if.else.problem.descriptor=带嵌套条件的 <code>#ref</code> 语句 #loc
negated.conditional.problem.descriptor=具有否定条件的条件表达式 #loc
redundant.else.problem.descriptor=<code>#ref</code> 分支可以解开，因为 'if' 分支永远不会正常完成 #loc
switch.statement.with.confusing.declaration.problem.descriptor=局部变量 <code>#ref</code> 在一个 'switch' 分支中声明，并在另一个分支中使用 #loc
final.class.problem.descriptor=类被声明为 <code>#ref</code> #loc
empty.class.problem.descriptor=类 <code>#ref</code> 为空 #loc
empty.enum.problem.descriptor=枚举 <code>#ref</code> 为空 #loc
empty.class.file.without.class.problem.descriptor=Java 文件未声明任何类 #loc
empty.anonymous.class.problem.descriptor=匿名类为空 #loc
anonymous.inner.class.problem.descriptor=匿名内部类 <code>#ref</code> #loc
limited.scope.inner.class.problem.descriptor=局部类 <code>#ref</code> #loc
final.method.problem.descriptor=方法被声明为 <code>#ref</code> #loc
class.initializer.problem.descriptor=非 'static' 初始值设定项 #loc
class.may.be.interface.problem.descriptor=abstract 类 <code>#ref</code> 可能是接口 #loc
non.protected.constructor.in.abstract.class.problem.descriptor=abstract 类的构造函数 <code>#ref()</code> 不应声明为 'public' #loc
class.without.constructor.problem.descriptor=类 <code>#ref</code> 没有构造函数 #loc
abstract.class.without.abstract.methods.problem.descriptor=类 <code>#ref</code> 被声明为 'abstract'，并且没有 'abstract' 方法 #loc
final.method.in.final.class.problem.descriptor=方法在 'final' 类中被声明为 <code>#ref</code> #loc
protected.member.in.final.class.problem.descriptor=类成员在 'final' 类中被声明为 <code>#ref</code> #loc
utility.class.with.public.constructor.problem.descriptor=类 <code>#ref</code> 只有 'static' 成员和 'public' 构造函数 #loc
utility.class.without.private.constructor.problem.descriptor=类 <code>#ref</code> 只有 'static' 成员，缺少 'private' 构造函数 #loc
abstract.method.overrides.concrete.method.problem.descriptor=abstract 方法 <code>#ref()</code> 重写具体方法 #loc
abstract.method.with.missing.implementations.problem.descriptor=abstract 方法 <code>#ref()</code> 未在每个子类中实现 #loc
abstract.method.overrides.abstract.method.problem.descriptor=abstract 方法 <code>#ref()</code> 重写 abstract 方法 #loc
abstract.method.overrides.abstract.method.ignore.different.javadoc.option=忽略 Javadoc 与其 super 方法不同的方法
abstract.class.extends.concrete.class.problem.descriptor=类 <code>#ref</code> 被声明为 'abstract'，并扩展一个具体类 #loc
static.non.final.field.problem.descriptor='static' 非 'final' 字段 <code>#ref</code> #loc
constant.declared.in.abstract.class.problem.descriptor=常量 <code>#ref</code> 在 abstract 类中声明 #loc
constant.declared.in.interface.problem.descriptor=常量 <code>#ref</code> 在接口中声明 #loc
static.inheritance.problem.descriptor=接口 <code>#ref</code> 仅针对其 static 常量实现 #loc
utility.class.problem.descriptor=类 <code>#ref</code> 只有 'static' 成员，指示程序构造 #loc
singleton.problem.descriptor=类 <code>#ref</code> 为单例 #loc
enum.singleton.problem.descriptor=枚举 <code>#ref</code> 为单例 #loc
final.private.method.problem.descriptor='private' 方法被声明为 <code>#ref</code> #loc
noop.method.in.abstract.class.problem.descriptor=无操作方法 <code>#ref()</code> 应当设为 abstract #loc
final.static.method.problem.descriptor='static' 方法被声明为 <code>#ref</code> #loc
class.without.no.arg.constructor.problem.descriptor=<code>#ref</code> 没有无实参构造函数 #loc
multiple.top.level.classes.in.file.problem.descriptor=文件中的多个顶级类
class.name.differs.from.file.name.problem.descriptor=类名 <code>#ref</code> 与文件名不同 #loc
marker.interface.problem.descriptor=标记接口 <code>#ref</code> #loc
field.has.setter.but.no.getter.problem.descriptor=字段 <code>#ref</code> 有 setter 但没有 getter #loc
abstract.class.never.implemented.problem.descriptor=abstract 类 <code>#ref</code> 没有具体子类 #loc
interface.never.implemented.problem.descriptor=接口 <code>#ref</code> 没有具体子类 #loc
missing.deprecated.annotation.problem.descriptor=缺少 '@Deprecated' 注解 #loc
missing.deprecated.tag.problem.descriptor=缺少 '@deprecated' Javadoc 标记说明 #loc
missing.deprecated.tag.option=警告缺少 @deprecated Javadoc 标记说明
missing.override.annotation.problem.descriptor=缺少关于 <code>#ref()</code> 的 '@Override' 注解 #loc
missing.override.annotation.in.overriding.problem.descriptor=重写方法未使用 '@Override' 注解
non.thread.safe.lazy.initialization.problem.descriptor='static' 字段 <code>#ref</code> 的延迟初始化不是线程安全 #loc
empty.finally.block.problem.descriptor=空 <code>#ref</code> 块 #loc
finally.block.cannot.complete.normally.problem.descriptor=<code>#ref</code> 块无法正常完成 #loc
empty.try.block.problem.descriptor=空 <code>#ref</code> 块 #loc
throw.from.finally.block.problem.descriptor=<code>#ref</code> 位于 'finally' 块内 #loc
possible.throw.from.finally.block.problem.descriptor=<code>{0}</code> 可能在 ''finally'' 块内引发 #loc
throw,from.finally.block.everywhere.option=警告随处都可能引发声明的异常
throw.caught.locally.problem.descriptor=通过包含 'try' 语句捕获 <code>#ref</code> #loc
throw.caught.locally.ignore.option=忽略重新抛出的异常
return.from.finally.block.problem.descriptor='return' 位于 'finally' 块内 #loc
continue.or.break.from.finally.block.problem.descriptor=<code>#ref</code> 位于 'finally' 块内 #loc
bad.exception.declared.problem.descriptor=已声明禁止异常 <code>#ref</code> #loc
bad.exception.caught.problem.descriptor=已捕获禁止异常 <code>#ref</code> #loc
checked.exception.class.problem.descriptor=已检查的异常类 <code>#ref</code> #loc
unchecked.exception.class.problem.descriptor=未检查的异常类 <code>#ref</code> #loc
thread.death.rethrown.problem.descriptor=ThreadDeath <code>#ref</code> 未重新抛出 #loc
error.rethrown.problem.descriptor=错误 <code>#ref</code> 未重新抛出 #loc
nested.try.statement.problem.descriptor=嵌套 <code>#ref</code> 语句 #loc
exception.from.catch.which.doesnt.wrap.problem.descriptor='catch' 块内的 <code>#ref</code> 忽略捕获的异常 #loc
instanceof.catch.parameter.problem.descriptor='catch' 形参 <code>#ref</code> 上的 'instanceof' #loc
non.final.field.of.exception.problem.descriptor=异常类的非 final 字段 <code>#ref</code> #loc
unnecessary.label.on.break.statement.problem.descriptor=Break 语句上存在不必要的标签 <code>#ref</code> #loc
unnecessary.label.on.continue.statement.problem.descriptor=Continue 语句上存在不必要的标签 <code>#ref</code> #loc
trivial.if.problem.descriptor=<code>#ref</code> 语句可以简化 #loc
unnecessary.parentheses.problem.descriptor=<code>#ref</code> 周围的圆括号不必要 #loc
unnecessary.local.variable.problem.descriptor=局部变量 <code>#ref</code> 是冗余的 #loc
unnecessary.this.problem.descriptor=<code>#ref</code> 在此上下文中不必要 #loc
unnecessary.block.statement.problem.descriptor=此语句周围的大括号不必要 #loc
unnecessary.continue.problem.descriptor=<code>#ref</code> 不必要，因为是循环中的最后一条语句 #loc
unnecessary.semicolon.problem.descriptor=不必要的分号 <code>#ref</code> #loc
unnecessary.semicolon.ignore.after.enum.constants.option=忽略枚举常量后的不必要分号
unnecessary.fully.qualified.name.problem.descriptor1=限定符 <code>#ref</code> 不必要，可被替换为导入 #loc
unnecessary.fully.qualified.name.problem.descriptor2=限定符 <code>#ref</code> 不必要，可以移除 #loc
unnecessary.qualifier.for.this.problem.descriptor='this' 上的限定符 <code>#ref</code> 在此上下文中不必要 #loc
unnecessary.qualifier.for.super.problem.descriptor='super' 上的限定符 <code>#ref</code> 在此上下文中不必要 #loc
unused.label.problem.descriptor=未使用的标签 <code>#ref</code> #loc
redundant.field.initialization.problem.descriptor=<code>#ref</code> 的字段初始化是冗余的 #loc
redundant.implements.problem.descriptor=冗余接口声明 <code>#ref</code> #loc
extends.object.problem.descriptor=类 <code>#ref</code> 显式扩展 'java.lang.Object' #loc
type.parameter.extends.object.problem.descriptor1=类型形参 <code>#ref</code> 显式扩展 'java.lang.Object' #loc
type.parameter.extends.object.problem.descriptor2=通配符类型实参 <code>#ref</code> 显式扩展 'java.lang.Object' #loc
unnecessary.super.constructor.problem.descriptor=<code>#ref</code> 不必要 #loc
unnecessary.constructor.problem.descriptor=无实参构造函数 <code>#ref()</code> 是冗余的 #loc
unnecessary.constructor.annotation.option=忽略有注解的构造函数
for.loop.replaceable.by.while.problem.descriptor=<code>#ref</code> 循环语句可被替换为 'while' 循环 #loc
unnecessary.default.problem.descriptor=<code>#ref</code> 分支不必要 #loc
unnecessary.default.expressions.option=仅报告 switch 表达式
unnecessary.default.quickfix=移除 'default' 分支
unnecessary.boxing.problem.descriptor=不必要的装箱 <code>#ref</code> #loc
unnecessary.boxing.inside.value.of.problem.descriptor=<code>#ref</code> 内的装箱冗余 #loc
unnecessary.unboxing.problem.descriptor=不必要的拆箱 <code>#ref</code> #loc
unnecessary.boxing.superfluous.option=仅报告真正多余的装箱表达式
unnecessary.unboxing.superfluous.option=仅报告真正多余的拆箱表达式
for.can.be.foreach.problem.descriptor=<code>#ref</code> 循环可被替换为增强的 'for' #loc
while.can.be.foreach.problem.descriptor=<code>#ref</code> 循环可被替换为增强的 'for' #loc
too.broad.scope.problem.descriptor=变量 <code>#ref</code> 的范围过宽 #loc
return.this.problem.descriptor=返回 <code>#ref</code> #loc
constant.on.side.of.comparison.display.name=常量位于比较的错误一侧
constant.on.lhs.of.comparison.problem.descriptor=常量 <code>#ref</code> 位于比较的左侧 #loc
constant.on.rhs.of.comparison.problem.descriptor=常量 <code>#ref</code> 位于比较的右侧 #loc
control.flow.statement.without.braces.problem.descriptor=不带大括号的 <code>{0}</code> #loc
missorted.modifiers.problem.descriptor=错位修饰符 <code>{0}</code> #loc
cstyle.array.variable.declaration.problem.descriptor={0, choice, 1#字段|2#形参|3#记录组件|4#局部变量} <code>#ref</code> 的 C 样式数组声明 #loc
cstyle.array.method.declaration.problem.descriptor=方法 <code>#ref()</code> 返回类型的 C 样式数组声明 #loc
multiple.declaration.problem.descriptor=一个声明中的多个变量 #loc
multiple.typed.declaration.problem.descriptor=在一个声明中具有不同数组维度的变量 #loc
serializable.inner.class.has.serial.version.uid.field.problem.descriptor=内部类 <code>#ref</code> 未定义 'serialVersionUID' 字段 #loc
serializable.inner.class.with.non.serializable.outer.class.problem.descriptor=内部类 <code>#ref</code> 可序列化，而其外部类不可序列化 #loc
busy.wait.problem.descriptor=在循环中调用 <code>Thread.#ref()</code>，可能处于忙等待 #loc
sleep.while.holding.lock.problem.descriptor=同步时调用 <code>Thread.#ref()</code> #loc
non.atomic.operation.on.volatile.field.problem.descriptor=volatile 字段 <code>#ref</code> 上的非原子操作 #loc
call.to.native.method.while.locked.problem.descriptor=在同步上下文中调用本地方法 <code>#ref()</code> #loc
object.notify.problem.descriptor=<code>#ref</code> 可能应当替换为 'notifyAll()' #loc
condition.signal.problem.descriptor=<code>#ref</code> 可能应当替换为 'signalAll()' #loc
thread.with.default.run.method.problem.descriptor=使用默认的 'run()' 方法实例化 <code>#ref</code> #loc
extends.thread.problem.descriptor=类 <code>#ref</code> 直接扩展 'java.lang.Thread' #loc
anonymous.extends.thread.problem.descriptor=匿名类直接扩展 'java.lang.Thread' #loc
naked.notify.problem.descriptor=在没有相应状态更改的情况下调用 <code>#ref()</code> #loc
unconditional.wait.problem.descriptor=无条件调用 <code>#ref()</code> #loc
system.run.finalizers.on.exit.problem.descriptor=调用 <code>System.#ref()</code> #loc
thread.priority.problem.descriptor=调用 <code>Thread.#ref()</code> #loc
thread.yield.problem.descriptor=调用 <code>Thread.#ref()</code> #loc
thread.stop.suspend.resume.problem.descriptor=调用 <code>Thread.#ref()</code> #loc
while.loop.spins.on.field.problem.descriptor=<code>#ref</code> 循环在字段上自旋 #loc
wait.not.in.loop.problem.descriptor=<code>#ref()</code> 调用不在循环中 #loc
await.not.in.loop.problem.descriptor=<code>#ref()</code> 调用不在循环中 #loc
wait.called.on.condition.problem.descriptor=在条件对象上调用 <code>#ref()</code> #loc
notify.called.on.condition.problem.descriptor=在条件对象上调用 <code>#ref()</code> #loc
wait.while.holding.two.locks.problem.descriptor=在保持两个锁的情况下调用 <code>#ref()</code> #loc
thread.run.problem.descriptor=对 <code>#ref()</code> 的调用可能应当替换为 'start()' #loc
thread.start.in.construction.problem.descriptor=对象构造期间调用 <code>#ref()</code> #loc
synchronize.on.lock.problem.descriptor=在 ''{0}'' 对象上同步不太可能是故意的 #loc
synchronized.on.literal.object.problem.descriptor=在使用文字初始化的 {0} <code>#ref</code> 上同步 #loc
synchronized.on.direct.literal.object.problem.descriptor=在 {0} 文字 <code>#ref</code> 上同步 #loc
synchronized.on.possibly.literal.object.problem.descriptor=在 {0} <code>#ref</code> 上同步 #loc
synchronize.on.non.final.field.problem.descriptor=在非 final 字段 <code>#ref</code> 上同步 #loc
synchronized.on.literal.object.warn.on.all.option=警告所有可能的文字
synchronize.on.this.problem.descriptor=对 'this' 的锁定操作可能会产生不可预见的副作用 #loc
synchronize.on.class.problem.descriptor=对类的锁定操作可能会产生不可预见的副作用 #loc
nested.synchronized.statement.problem.descriptor=嵌套 <code>#ref</code> 语句 #loc
empty.synchronized.statement.problem.descriptor=空 <code>#ref</code> 语句 #loc
non.synchronized.method.overrides.synchronized.method.problem.descriptor=未同步方法 <code>#ref()</code> 重写 synchronized 方法 #loc
public.field.accessed.in.synchronized.context.problem.descriptor=在同步上下文中访问非 private 字段 <code>#ref</code> #loc
field.accessed.synchronized.and.unsynchronized.problem.descriptor=同时在同步和未同步上下文中访问字段 <code>#ref</code> #loc
extended.for.statement.problem.descriptor=扩展 <code>#ref</code> 语句 #loc
object.allocation.in.loop.new.descriptor=循环中的对象分配 <code>new #ref()</code> #loc
object.allocation.in.loop.problem.array.initializer.descriptor=循环中的数组分配 #loc
object.allocation.in.loop.problem.call.descriptor=对象分配通过循环中的 <code>#ref()</code> 调用完成 #loc
object.allocation.in.loop.problem.methodref.descriptor=对象分配通过循环中的实例绑定方法引用 <code>#ref()</code> 完成 #loc
object.allocation.in.loop.problem.lambda.descriptor=对象分配通过捕获循环中的 lambda 完成 #loc
object.allocation.in.loop.problem.string.concat=对象分配通过循环中的字符串串联完成 #loc
instantiating.object.to.get.class.object.problem.descriptor=实例化对象以获取类对象 #loc
field.may.be.static.problem.descriptor=字段 <code>#ref</code> 可能为 'static' #loc
method.may.be.static.problem.descriptor=方法 <code>#ref()</code> 可能为 'static' #loc
class.initializer.may.be.static.problem.descriptor=类初始值设定项可能为 'static' #loc
map.replaceable.by.enum.map.problem.descriptor=<code>#ref</code> 可被替换为 'EnumMap' #loc
set.replaceable.by.enum.set.problem.descriptor=<code>#ref</code> 可被替换为 'EnumSet' #loc
inner.class.may.be.static.problem.descriptor=内部类 <code>#ref</code> 可能为 'static' #loc
string.buffer.must.have.initial.capacity.problem.descriptor=没有初始容量的 <code>new #ref()</code> #loc
string.buffer.replaceable.by.string.builder.problem.descriptor=<code>StringBuffer #ref</code> 可能被声明为 'StringBuilder' #loc
string.buffer.replaceable.by.string.problem.descriptor=<code>{0} #ref</code> 可被替换为 ''String'' #loc
new.string.buffer.replaceable.by.string.problem.descriptor=<code>#ref</code> 可被替换为 'String' #loc
string.replaceable.by.string.buffer.problem.descriptor=非常量 <code>String #ref</code> 可能应被声明为 'StringBuilder' #loc
collections.must.have.initial.capacity.problem.descriptor=没有初始容量的 <code>new #ref()</code> #loc
string.concatenation.in.loops.problem.descriptor=循环中的字符串串联 <code>#ref</code> #loc
string.concatenation.inside.string.buffer.append.problem.descriptor=字符串串联作为 <code>{0}.#ref()</code> 调用的实参 #loc
boolean.constructor.problem.descriptor=布尔构造函数调用 #loc
string.buffer.to.string.in.concatenation.problem.descriptor=在串联中调用 <code>{0}.#ref()</code> #loc
tail.recursion.problem.descriptor=尾部递归调用 <code>#ref()</code> #loc
string.equals.empty.string.problem.descriptor=<code>#ref("")</code> 可被替换为 'length()==0' #loc
string.equals.empty.string.is.empty.problem.descriptor=<code>#ref("")</code> 可被替换为 'isEmpty()' #loc
random.double.for.random.integer.problem.descriptor=使用 <code>Random.#ref</code> 创建随机整数 #loc
manual.array.copy.problem.descriptor=手动数组复制 #loc
manual.array.to.collection.copy.problem.descriptor=手动数组到集合复制 #loc
call.to.simple.getter.in.class.problem.descriptor=从类内调用简单 getter <code>#ref()</code> #loc
call.to.simple.setter.in.class.problem.descriptor=从类内调用简单 setter <code>#ref()</code> #loc
assert.without.message.problem.descriptor=没有消息的 <code>#ref()</code> #loc
assert.without.message.quick.fix.family.name=添加错误消息
test.case.with.constructor.problem.descriptor=构造函数 <code>#ref()</code> 中的初始化逻辑，而不是 'setUp()' #loc
test.case.with.constructor.problem.descriptor.initializer=初始值设定项中的初始化逻辑，而不是 'setUp()'
misordered.assert.equals.arguments.problem.descriptor=<code>#ref()</code> 的实参顺序错误 #loc
simplifiable.junit.assertion.problem.descriptor=<code>#ref()</code> 可以简化为 ''{0}'' #loc
test.method.without.assertion.problem.descriptor=JUnit 测试方法 <code>#ref()</code> 不包含断言 #loc
test.case.with.no.test.methods.problem.descriptor=测试类 <code>#ref</code> 没有测试 #loc
test.case.in.product.code.problem.descriptor=测试用例 <code>#ref</code> 可能应当放置在测试源树中 #loc
test.method.in.product.code.problem.descriptor=测试方法 <code>#ref()</code> 可能应当放置在测试源树中 #loc
deserializable.class.in.secure.context.problem.descriptor=类 <code>#ref</code> 可能被反序列化，影响安全性 #loc
serializable.class.in.secure.context.problem.descriptor=类 <code>#ref</code> 可能被序列化，影响安全性 #loc
serializable.deserializable.class.in.secure.context.problem.descriptor=类 <code>#ref</code> 可能被序列化和反序列化，影响安全性 #loc
cloneable.class.in.secure.context.problem.descriptor=类 <code>#ref</code> 可能被克隆，影响安全性 #loc
cloneable.class.in.secure.context.quickfix=生成始终抛出异常的 'clone()' 方法
remove.cloneable.quickfix=从 'implements' 子句中移除 'Cloneable'
non.final.clone.problem.descriptor=非 final <code>#ref()</code> 方法，影响安全性 #loc
runtime.exec.with.non.constant.string.problem.descriptor=<code>Runtime.#ref()</code> 调用具有非常量实参 #loc
load.library.with.non.constant.string.problem.descriptor=<code>{0}.#ref()</code> 调用具有非常量实参 #loc
jdbc.execute.with.non.constant.string.problem.descriptor=<code>Statement.#ref()</code> 调用具有非常量实参 #loc
jdbc.prepare.statement.with.non.constant.string.problem.descriptor=<code>Connection.#ref()</code> 调用具有非常量实参 #loc
custom.classloader.problem.descriptor=自定义 ClassLoader 类 <code>#ref</code> #loc
custom.security.manager.problem.descriptor=自定义 SecurityManager 类 <code>#ref</code> #loc
system.set.problem.descriptor=对 <code>System.#ref()</code> 的调用可能造成安全问题 #loc
class.loader.instantiation.problem.descriptor=实例化 <code>#ref</code> 可能造成安全问题 #loc
public.static.array.field.problem.descriptor='public static' 数组字段 <code>#ref</code>，影响安全性 #loc
public.static.collection.field.problem.descriptor='public static' 集合字段 <code>#ref</code>，影响安全性 #loc
abstract.class.with.only.one.direct.inheritor.problem.descriptor=只有一个直接继承者的 abstract 类 <code>#ref</code> #loc

#other
abstract.method.overrides.abstract.method.remove.quickfix=移除冗余 abstract 方法声明
class.may.be.interface.convert.quickfix=将类转换为接口
class.without.constructor.create.quickfix=生成空构造函数
class.without.no.arg.constructor.ignore.option=如果类具有默认构造函数，则忽略
extends.annotation.problem.descriptor=类 ''{0}'' 实现注解接口 <code>#ref</code> #loc
extends.annotation.interface.problem.descriptor=接口 ''{0}'' 扩展注解接口 <code>#ref</code> #loc
extends.concrete.collection.problem.descriptor=类 <code>#ref</code> 显式扩展 ''{0}'' #loc
anonymous.extends.concrete.collection.problem.descriptor=匿名类显式扩展 ''{0}'' #loc
inner.class.on.interface.ignore.option=忽略接口的内部接口
inner.class.on.interface.problem.descriptor=接口 ''{0}'' 具有内部类 <code>#ref</code> #loc
missing.deprecated.annotation.add.quickfix=添加 @Deprecated 注解
missing.add.deprecated.javadoc.tag.quickfix=添加 '@deprecated' Javadoc 标记
non.protected.constructor.in.abstract.class.ignore.option=对非 public 类忽略
public.constructor.in.non.public.class.problem.descriptor=构造函数在非 public 类 ''{0}'' 中被声明为 <code>#ref</code> #loc
static.inheritance.replace.quickfix=将继承替换为 {0} 中的限定引用
utility.class.with.public.constructor.make.quickfix=将{0, choice, 1#构造函数|2#构造函数}设为 'private'
utility.class.without.private.constructor.create.quickfix=生成空 'private' 构造函数
utility.class.without.private.constructor.make.quickfix=将构造函数设为 'private'
naming.convention.problem.descriptor.short={0} 名称 <code>#ref</code> 过短({1} < {2}) #loc
naming.convention.problem.descriptor.long={0} 名称 <code>#ref</code> 过长({1} > {2}) #loc
naming.convention.problem.descriptor.regex.mismatch={0} 名称 <code>#ref</code> 不匹配正则表达式 ''{1}'' #loc
local.variable.naming.convention.ignore.option=忽略 for 循环形参
local.variable.naming.convention.ignore.catch.option=忽略 'catch' 块形参
method.names.differ.only.by.case.problem.descriptor=方法名称 <code>#ref</code> 和方法名称 ''{0}'' 仅大小写不同 #loc
parameter.name.differs.from.overridden.parameter.ignore.character.option=如果重写的形参仅包含一个字符，则忽略
parameter.name.differs.from.overridden.parameter.ignore.library.option=如果重写的形参来自库，则忽略
parameter.name.differs.from.overridden.parameter.problem.descriptor=参数名 <code>#ref</code> 不同于{1, choice, 1#super 方法|2#重载方法|3#super 构造函数|4#重载构造函数}中的形参 ''{0}'' #loc
questionable.name.column.title=名称
questionable.name.list.label=报告的名称:
standard.variable.names.problem.descriptor=变量命名 <code>#ref</code> 没有类型 ''{0}'' #loc
standard.variable.names.problem.descriptor2=变量命名 <code>#ref</code> 没有类型 ''{0}'' 或 ''{1}'' #loc
standard.variable.names.ignore.override.option=对与 super 方法形参相同的形参名称忽略
boolean.method.name.must.start.with.question.table.column.name=布尔方法名称前缀
boolean.method.name.must.start.with.question.table.label=布尔方法名称前缀:
conditional.expression.with.identical.branches.collapse.quickfix=收起条件表达式
redundant.else.unwrap.quickfix=移除冗余的 'else'
constant.conditional.expression.problem.descriptor=<code>#ref</code> 可以简化为 ''{0}'' #loc
constant.conditional.expression.simplify.quickfix=简化
constant.conditional.expression.simplify.quickfix.sideEffect=提取副作用并简化
enum.switch.statement.which.misses.cases.problem.descriptor.single=枚举类型 ''{0}'' 上的 <code>#ref</code> 语句缺少 case ''{1}'' #loc
enum.switch.statement.which.misses.cases.problem.descriptor=枚举类型 ''{0}'' 上的 <code>#ref</code> 语句缺少 case: {1} #loc
for.loop.replaceable.by.while.ignore.option=忽略无条件循环的 'infinite'
for.loop.with.missing.component.problem.descriptor1=<code>#ref</code> 语句缺少初始值设定项 #loc
for.loop.with.missing.component.problem.descriptor2=<code>#ref</code> 语句缺少条件 #loc
for.loop.with.missing.component.problem.descriptor3=<code>#ref</code> 语句缺少更新 #loc
for.loop.with.missing.component.problem.descriptor4=<code>#ref</code> 语句缺少初始值设定项和条件 #loc
for.loop.with.missing.component.problem.descriptor5=<code>#ref</code> 语句缺少初始值设定项和条件 #loc
for.loop.with.missing.component.problem.descriptor6=<code>#ref</code> 语句缺少条件和更新 #loc
for.loop.with.missing.component.problem.descriptor7=<code>#ref</code> 语句缺少初始值设定项、条件和更新 #loc
foreach.replace.quickfix=替换为增强 'for'
unnecessary.boxing.remove.quickfix=移除装箱
unnecessary.unboxing.remove.quickfix=移除拆箱
misordered.assert.equals.arguments.flip.quickfix=翻转比较实参
simplify.junit.assertion.simplify.quickfix=简化断言
system.properties.problem.descriptor=对 <code>Integer.#ref()</code> 的调用可能造成安全问题 #loc
system.properties.problem.descriptor1=对 <code>Boolean.#ref()</code> 的调用可能造成安全问题 #loc
unsecure.random.number.generation.problem.descriptor1=出于安全目的，请使用 'java.security.SecureRandom' 而不是 <code>java.lang.Math.#ref()</code> #loc
unsecure.random.number.generation.problem.descriptor2=出于安全目的，请使用 'java.security.SecureRandom' 而不是 <code>java.util.#ref</code> #loc
unsecure.random.number.generation.problem.descriptor3=出于安全目的，请使用 'java.security.SecureRandom' 而不是 <code>#ref</code> #loc
serializable.has.serialization.methods.problem.descriptor=可序列化类 <code>#ref</code> 未定义 'readObject()' 或 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor1=可序列化类 <code>#ref</code> 未定义 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor2=可序列化类 <code>#ref</code> 未定义 'readObject()' #loc
serializable.with.unconstructable.ancestor.problem.descriptor=<code>#ref</code> 具有不带无实参构造函数的不可序列化上级 ''{0}'' #loc
transient.field.in.non.serializable.class.problem.descriptor=字段 ''{0}'' 已在不可序列化类中标记为 <code>#ref</code> #loc
safe.lock.problem.descriptor=''{0}'' 应在 ''try'' 块之前锁定，并在相应的 ''finally'' 块中解锁 #loc
synchronized.method.problem.descriptor=方法 ''{0}()'' 被声明为 <code>#ref</code> #loc
synchronized.method.include.option=包含本地方法
synchronized.method.ignore.synchronized.super.option=忽略重写 synchronized 方法的方法
synchronized.method.move.quickfix=将同步移动到方法中
volatile.field.problem.descriptor=类型 ''{0}'' 的 volatile 字段 <code>#ref</code> #loc
string.format.choose.class=选择格式化程序类
string.format.class.column.name=附加格式化程序类
string.format.class.label=附加格式化程序类:
string.format.class.method.name=附加格式化程序方法
string.format.class.method.label=附加格式化程序方法:
exception.class.column.name=异常类
bad.exception.thrown.problem.descriptor=已抛出禁止异常 ''{0}'' #loc
too.broad.catch.problem.descriptor=<code>#ref</code> 的 ''catch'' 过宽，掩码异常 ''{0}'' #loc
too.broad.catch.problem.descriptor1=<code>#ref</code> 的 ''catch'' 过宽，掩码异常 ''{0}'' 和 ''{1}'' #loc
add.serialversionuidfield.quickfix=添加 'serialVersionUID' 字段
delete.import.quickfix=删除不必要的导入
encapsulate.variable.quickfix=封装字段 ''{0}''
extract.method.quickfix=提取方法
inline.call.quickfix=内联调用
inline.variable.quickfix=内联变量
pointless.nullcheck.display.name=方法调用前出现不必要的 'null' 检查
pointless.nullcheck.problem.descriptor.call=''{0}()'' 调用之前的 ''null'' 检查不必要
remove.redundant.polyadic.operand.fix.name=移除不必要的 ''{0}'' 条件
remove.redundant.polyadic.operand.fix.family.name=移除不必要的条件
introduce.constant.quickfix=引入常量
make.initialization.explicit.quickfix=使初始化显式
move.anonymous.to.inner.quickfix=转换为命名内部类
anonymous.inner.may.be.named.static.inner.class.quickfix=转换为命名 'static' 内部类
move.class.quickfix=移动类
normalize.declaration.quickfix=拆分为单独的声明
remove.modifier.quickfix=移除 ''{0}'' 修饰符
replace.inheritance.with.delegation.quickfix=将继承替换为委托
cast.that.loses.precision.problem.descriptor=''{0}'' 到 <code>#ref</code> 的转换可能导致精度损失 #loc
cast.that.loses.precision.negative.problem.descriptor=''{0}'' 到 <code>#ref</code> 的转换可能导致负实参的精度损失 #loc
comparison.to.nan.problem.descriptor1=与 <code>#ref</code> 的比较始终为 false #loc
comparison.to.nan.problem.descriptor2=与 <code>#ref</code> 的比较始终为 true #loc
confusing.floating.point.literal.change.quickfix=更改为规范形式
implicit.numeric.conversion.ignore.widening.conversion.option=忽略扩大转换
implicit.numeric.conversion.ignore.char.conversion.option=忽略 'char' 之间的转换
implicit.numeric.conversion.ignore.constant.conversion.option=忽略从常量和文字的转换
implicit.numeric.conversion.problem.descriptor=将 <code>#ref</code> 从 ''{0}'' 隐式数字转换为 ''{1}'' #loc
implicit.numeric.conversion.assignment.problem.descriptor=将结果值从 ''{0}'' 隐式数字转换为 ''{1}'' #loc
implicit.numeric.conversion.make.explicit.quickfix=使转换显式
non.reproducible.math.call.replace.quickfix=替换为 'StrictMath' 调用
overly.complex.arithmetic.expression.max.number.option=最大项数:
expression.can.be.replaced.problem.descriptor=<code>#ref</code> 可被替换为 ''{0}'' #loc
method.complexity.limit.option=方法复杂度限制:
expression.can.be.replaced.no.quotes.problem.descriptor={0} 可被替换为 {1}
cyclomatic.complexity.problem.descriptor=过度复杂的方法 <code>#ref()</code> (循环复杂度 = {0}) #loc
method.coupling.limit.option=方法耦合限制:
method.coupling.problem.descriptor=<code>#ref</code> 过度耦合 (# 引用的类 = {0}) #loc
method.with.multiple.loops.problem.descriptor=<code>#ref</code> 包含 {0} 个循环 #loc
return.point.limit.option=返回点限制(&R):
multiple.return.points.per.method.problem.descriptor=<code>#ref</code> 具有 {0} 个返回点 #loc
nesting.depth.limit.option=嵌套深度限制:
nesting.depth.problem.descriptor=<code>#ref</code> 过度嵌套 (最大嵌套深度 = {0}) #loc
non.comment.source.statements.limit.option=非注释源语句限制:
non.comment.source.statements.problem.descriptor=<code>#ref</code> 过长 (# 非注释源语句 = {0}) #loc
parameters.per.method.problem.descriptor=<code>#ref()</code> 的形参过多(形参数量 = {0}) #loc
parameters.per.constructor.problem.descriptor=<code>#ref()</code> 的形参过多(形参数量 = {0}) #loc
parameter.limit.option=形参限制:
constructor.visibility.option=忽略具有以下可见性的构造函数:
three.negations.per.method.ignore.option=忽略 'equals()' 方法中的否定
three.negations.per.method.ignore.assert.option=忽略 'assert' 语句中的否定
three.negations.per.method.problem.descriptor=<code>#ref</code> 包含 {0} 个否定 #loc
thrown.exceptions.per.method.problem.descriptor=<code>#ref</code> 声明的异常过多 (异常数量 = {0}) #loc
thrown.exceptions.per.method.limit.option=异常抛出限制:
call.to.simple.getter.in.class.ignore.option=忽略其他对象上的 getter 调用
call.to.private.simple.getter.in.class.option=仅在 getter 为 'private' 时报告
call.to.simple.getter.in.class.inline.quickfix=内联调用 getter
call.to.simple.setter.in.class.ignore.option=忽略其他对象上的 setter 调用
call.to.private.setter.in.class.option=仅在 setter 为 'private' 时报告
call.to.simple.setter.in.class.inline.quickfix=内联调用 setter
make.static.quickfix=设为 'static'
length.one.strings.in.concatenation.replace.quickfix=替换为字符
multiply.or.divide.by.power.of.two.replace.quickfix=替换为移位
boolean.expression.can.be.simplified.problem.descriptor=<code>#ref</code> 可以简化为 ''{0}'' #loc
boolean.expression.does.not.modify.problem.descriptor=<code>#ref</code> 未修改 ''{0}'' 的值 #loc
boolean.expression.remove.compound.assignment.quickfix=移除无意义的复合赋值
trivial.string.concatenation.problem.descriptor=串联中使用的空字符串
string.replace.quickfix=将串联替换为 ''{0}''
instantiating.object.to.get.class.object.replace.quickfix=替换为直接类对象访问
method.may.be.static.only.option=仅检查 'private' 或 'final' 方法
method.may.be.static.empty.option=忽略空方法
string.concatenation.inside.string.buffer.append.replace.quickfix=替换为链式 'append()' 调用
string.equals.empty.string.option.do.not.add.null.check=当有必要进行 null 检查时，不必报告
tail.recursion.replace.quickfix=用迭代替换尾部递归
if.statement.with.too.many.branches.max.option=最大分支数:
if.statement.with.too.many.branches.problem.descriptor=<code>#ref</code> 的分支过多 ({0}) #loc
negated.conditional.invert.quickfix=反转条件
negated.if.else.ignore.negated.null.option=忽略 '!= null' 比较
negated.if.else.ignore.negated.zero.option=忽略 '!= 0' 比较
negated.if.else.invert.quickfix=反转 'if' 条件
overly.complex.boolean.expression.max.terms.option=最大项数:
pointless.boolean.expression.ignore.option=在确定无意义表达式时忽略命名常量
simplifiable.conditional.expression.problem.descriptor=<code>{1}</code> 可以简化为 ''{0}'' #loc
switch.statement.density.min.option=分支的最小密度: %
switch.statement.density.problem.descriptor=<code>#ref</code> 的分支密度过低 ({0}%) #loc
switch.statement.with.too.few.branches.min.option=最小分支数:
switch.statement.with.too.few.branches.problem.descriptor=''switch'' 语句的 case 标签太少({0})，并且可能应当替换为 ''if'' 语句 #loc
switch.statement.with.single.default.message='switch' 语句只有 'default' case
switch.expression.with.too.few.branches.problem.descriptor=''switch'' 表达式的 case 标签太少 ({0})，并且可能应当替换为 ''if'' 语句或条件运算符 #loc
switch.expression.with.single.default.message='switch' 表达式只有 'default' case
switch.statement.without.default.ignore.option=忽略详尽的 switch 语句
unnecessary.label.remove.quickfix=移除标签
unnecessary.return.problem.descriptor=<code>#ref</code> 不必要，因为是 'void' 方法中的最后一条语句 #loc
unnecessary.return.constructor.problem.descriptor=<code>#ref</code> 不必要，因为是构造函数中的最后一条语句 #loc
unused.label.remove.quickfix=移除未使用的标签
unnecessarily.qualified.static.usage.problem.descriptor=不必要的限定 static 方法调用 <code>{0}()</code> #loc
unnecessarily.qualified.static.usage.problem.descriptor1=不必要的限定静态访问 <code>{0}</code> #loc
unnecessarily.qualified.static.usage.ignore.field.option=忽略不必要的限定字段访问
unnecessarily.qualified.static.usage.ignore.method.option=忽略不必要的限定方法调用
unnecessary.interface.modifier.problem.descriptor=修饰符 <code>#ref</code> 对于接口是冗余的 #loc
smth.unnecessary.remove.quickfix=移除不必要的 ''{0}''
unqualified.static.usage.problem.descriptor=非限定 static 方法调用 <code>#ref()</code> #loc
unqualified.static.usage.problem.descriptor1=非限定 static 字段访问 <code>#ref</code> #loc
unqualified.static.usage.ignore.field.option=忽略非限定字段访问
unqualified.static.usage.ignore.method.option=忽略非限定方法调用
unqualified.static.usage.qualify.field.quickfix=限定 static 字段访问
unqualified.static.usage.qualify.method.quickfix=限定 static 方法调用
too.broad.scope.allow.option=<html>报告使用新表达式作为初始值设定项的变量<br>(可能不安全)</html>
too.broad.scope.only.blocks.option=仅报告可移入内部块的变量
too.broad.scope.narrow.quickfix=将 ''{0}'' 的声明移近用法
press.escape.to.remove.highlighting.message=按 Esc 移除高亮显示
literal.as.arg.to.string.equals.problem.descriptor=文字 #ref 是 ''{0}()'' 的实参，而不是其限定符 #loc
literal.as.arg.to.string.equals.flip.quickfix=翻转 ''{0}()''
c.style.array.declaration.replace.quickfix=替换为 Java 样式数组声明
chained.method.call.ignore.option=忽略字段初始值设定项中的链式方法调用
chained.method.call.ignore.self.types.option=忽略对返回类型与其封闭类相同的方法的调用
introduce.variable.quickfix=引入变量
introduce.variable.may.change.semantics.quickfix=引入变量 (可能更改语义)
flip.comparison.quickfix=翻转比较
control.flow.statement.without.braces.add.quickfix=将大括号添加到语句
control.flow.statement.without.braces.message=将大括号添加到 ''{0}'' 语句
extends.object.remove.quickfix=移除冗余的 'extends Object'
implicit.call.to.super.ignore.option=对 'java.lang.Object' 的直接子类忽略
implicit.call.to.super.make.explicit.quickfix=使对 'super()' 的调用显式
missorted.modifiers.require.option=检查注解顺序
missorted.modifiers.typeuse.before.type.option=目标 TYPE_USE 注解始终位于类型前
missorted.modifiers.sort.quickfix=对修饰符排序
nested.method.call.ignore.option=忽略字段初始值设定项中的嵌套方法调用
ignore.calls.to.static.methods=忽略对 static 方法的调用
ignore.calls.to.property.getters=忽略对属性 getter 的调用
redundant.field.initialization.remove.quickfix=移除初始值设定项
redundant.implements.remove.quickfix=移除冗余接口声明
unnecessary.constructor.remove.quickfix=移除冗余构造函数
unnecessary.fully.qualified.name.replace.quickfix=将限定名称替换为导入
unnecessary.fully.qualified.name.remove.quickfix=移除不必要的限定
unnecessary.fully.qualified.name.status.bar.escape.highlighting.message={0} 个完全限定{0, choice, 1#名称|2#名称}替换为导入 (按 Esc 移除高亮显示)
unnecessary.parentheses.remove.quickfix=移除不必要的圆括号
unnecessary.qualifier.for.this.remove.quickfix=移除不必要的限定符
unnecessary.semicolon.remove.quickfix=移除不必要的分号
unnecessary.super.constructor.remove.quickfix=移除不必要的 'super()'
unnecessary.this.remove.quickfix=移除不必要的 'this' 限定符
overly.strong.type.cast.problem.descriptor=到 <code>#ref</code> 的转换可以被削弱为 ''{0}'' #loc
field.count.inspection.include.constant.fields.in.count.checkbox=在计数中包含常量字段
field.count.inspection.static.final.fields.count.as.constant.checkbox=将 'static final' 字段计为常量
field.count.inspection.include.enum.constants.in.count=在计数中包含枚举常量
make.method.final.fix.name=将方法 ''{0}()'' 设为 ''final''
make.class.final.fix.name=将类 ''{0}'' 设为 ''final''
non.boolean.method.name.must.not.start.with.question.display.name=非布尔方法名称不能以疑问词开头
non.boolean.method.name.must.not.start.with.question.problem.descriptor=非布尔方法名称 <code>#ref</code> 以疑问词开头 #loc
boolean.constructor.simplify.quickfix=简化
unnecessary.temporary.on.conversion.from.string.problem.descriptor=<code>#ref</code> #loc 可以简化为 ''{0}''
only.report.qualified.static.usages.option=仅报告来自 static 上下文的限定静态访问
unqualified,static.usage.only.report.static.usages.option=仅报告来自非 static 上下文的静态访问
assignment.to.catch.block.parameter.problem.descriptor=赋值给 'catch' 块形参 <code>#ref</code> #loc
assignment.to.method.parameter.problem.descriptor=赋值给方法形参 <code>#ref</code> #loc
value.of.post.increment.problem.descriptor=使用后增量表达式 <code>#ref</code> 的值 #loc
value.of.post.decrement.problem.descriptor=使用后减量表达式 <code>#ref</code> 的值 #loc
value.of.pre.increment.problem.descriptor=使用前增量表达式 <code>#ref</code> 的值 #loc
value.of.pre.decrement.problem.descriptor=使用前减量表达式 <code>#ref</code> 的值 #loc
assignment.replaceable.with.operator.assignment.problem.descriptor=<code>#ref</code> 可以简化为 ''{0}'' #loc
assignment.replaceable.with.operator.assignment.ignore.conditional.operators.option=忽略条件运算符
assignment.replaceable.with.operator.assignment.ignore.obscure.operators.option=忽略模糊的 ^ 和 % 运算符
object.equality.ignore.between.objects.of.a.type.with.only.private.constructors.option=忽略只有 'private' 构造函数的类型对象之间的 '=='
redundant.method.override.display.name=方法与其 super 方法相同
redundant.method.override.delegates.to.super.problem.descriptor=方法 <code>#ref()</code> 仅委托给 super 方法 #loc
redundant.method.override.problem.descriptor=方法 <code>#ref()</code> 与其 super 方法相同 #loc
redundant.method.override.quickfix=移除冗余方法
redundant.method.override.option.check.library.methods=检查重写库方法的方法
refused.bequest.problem.descriptor=方法 <code>#ref()</code> 未调用 'super.#ref()' #loc
refused.bequest.ignore.empty.super.methods.option=忽略空 super 方法
refused.bequest.ignore.default.super.methods.option=忽略 'default' super 方法
overly.complex.boolean.expression.ignore.option=忽略纯合取和析取
pointless.indexof.comparison.display.name=无意义的 'indexOf()' 比较
pointless.indexof.comparison.always.true.problem.descriptor=<code>#ref</code> 始终为 true #loc
pointless.indexof.comparison.always.false.problem.descriptor=<code>#ref</code> 始终为 false #loc
reuse.of.local.variable.problem.descriptor=局部变量 <code>#ref</code> 的重用 #loc
single.character.startswith.display.name=单个字符 'startsWith()' 或 'endsWith()'
single.character.startswith.problem.descriptor=单个字符 <code>#ref()</code> 可被替换为 'charAt()' 表达式 #loc
list.indexof.replaceable.by.contains.display.name='List.indexOf()' 表达式可被替换为 'contains()'
string.indexof.replaceable.by.contains.display.name='String.indexOf()' 表达式可被替换为 'contains()'
overloaded.methods.with.same.number.parameters.problem.descriptor=具有相同数量形参的多个方法命名 <code>#ref</code> #loc
overloaded.vararg.method.problem.descriptor=重载 vararg 方法 <code>#ref()</code> #loc
overloaded.vararg.constructor.problem.descriptor=重载 vararg 构造函数 <code>#ref()</code> #loc
cached.number.constructor.call.display.name=数字构造函数调用具有基元实参
cached.number.constructor.call.problem.descriptor=数字构造函数调用具有基元实参 #loc
cached.number.constructor.call.ignore.string.arguments.option=忽略具有字符串实参的新数字表达式
cached.number.constructor.call.report.only.deprecated=仅在构造函数为 @Deprecated 时报告
chained.equality.comparisons.problem.descriptor=链式相等比较 <code>#ref</code> #loc
confusing.octal.escape.sequence.problem.descriptor=八进制转义序列 <code>#ref</code> 后面紧跟数字 #loc
field.accessed.synchronized.and.unsynchronized.option=简单的 getter 和 setter 也被视为字段访问
method.overrides.inaccessible.method.display.name=方法重写了超类不可访问的方法
method.overrides.package.local.method.problem.descriptor=方法 <code>#ref()</code> 重写了位于另一个软件包中的超类的 package-private 方法 #loc
suspicious.to.array.call.display.name=可疑的 'Collection.toArray()' 调用
suspicious.to.array.call.problem.descriptor=应为类型 ''{0}[]'' 的数组，找到的是 ''{1}[]'' #loc
suspicious.system.arraycopy.display.name=可疑的 'System.arraycopy()' 调用
suspicious.system.arraycopy.problem.descriptor4=<code>#ref</code> 不是数组类型 #loc
suspicious.system.arraycopy.problem.descriptor5=<code>#ref</code> 不是数组类型 #loc
suspicious.system.arraycopy.problem.descriptor6=源形参类型 ''{0}'' 不可分配给类型为 ''{1}'' 的目标形参 <code>#ref</code> #loc
suspicious.system.arraycopy.problem.descriptor.length.bigger.src=长度始终大于 ''src.length - srcPos'' {0}
suspicious.system.arraycopy.problem.descriptor.length.bigger.dest=长度始终大于 ''dest.length - destPos'' {0}
suspicious.system.arraycopy.problem.descriptor.ranges.intersect=复制到具有相交范围的同一数组
method.only.used.from.inner.class.display.name=仅在内部类中使用 private 方法
method.only.used.from.inner.class.problem.descriptor=方法 <code>#ref()</code>#loc 只能从{0, choice, 1#内部|2#局部|3#}{1, choice, 1#类|2#接口|3#派生的匿名类|4#注解类型|5#枚举|6#记录} ''{2}'' 使用 #loc
method.only.used.from.inner.class.ignore.option=忽略从匿名类或局部类调用的方法(&A)
only.report.static.methods=仅报告 'static' 方法(&O)
single.character.startswith.quickfix=替换为 'charAt()' 表达式
interface.never.implemented.option=忽略仅声明常量的接口
size.replaceable.by.isempty.display.name='size() == 0' 可被替换为 'isEmpty()'
size.replaceable.by.isempty.negation.ignore.option=忽略将替换为 '!isEmpty()' 的表达式
size.replaceable.by.isempty.fix.ignore.calls=忽略类型 ''{1}'' 上的 ''.{0}()'' 调用
choose.class.type.to.ignore=选择要忽略的类
loop.condition.not.updated.inside.loop.display.name=循环变量未在循环内更新
loop.variable.not.updated.inside.loop.problem.descriptor=变量 '#ref' 未在循环内更新#loc
loop.condition.not.updated.inside.loop.problem.descriptor=条件 '#ref' 未在循环内更新#loc
loop.variable.not.updated.inside.loop.option.nonlocal=忽略可能的非本地变更
utility.class.without.private.constructor.option=忽略仅具有主方法的类
super.class.logger.option=在超类有可访问的记录器时忽略
static.method.only.used.in.one.class.display.name=static 成员仅在其他一个类中使用
static.method.only.used.in.one.class.problem.descriptor=static {0, choice, 1#方法|2#字段} <code>#ref{0, choice, 1#()|2#}</code> 仅在 ''{1}'' 类中使用 #loc
static.method.only.used.in.one.anonymous.class.problem.descriptor=static {0, choice, 1#方法|2#字段} <code>#ref{0, choice, 1#()|2#}</code> 仅在派生自 ''{1}'' 的匿名类中使用 #loc
static.method.only.used.in.one.class.quickfix=将 {0} 移至使用类
static.method.only.used.in.one.class.ignore.test.option=仅在测试类中使用时忽略
static.method.only.used.in.one.class.ignore.anonymous.option=仅在匿名类中使用时忽略
static.method.only.used.in.one.class.ignore.on.conflicts=当方法无法在不产生冲突的情况下移动时忽略
static.method.only.used.in.one.class.ignore.utility.classes=忽略位于实用程序类中的成员
unary.plus.display.name=一元正号
unary.plus.problem.descriptor=一元 <code>#ref</code> 运算符 #loc
await.without.corresponding.signal.display.name=没有相应 'signal()' 的 'await()'
await.without.corresponding.signal.problem.descriptor=在没有相应 <code>signal()</code> 或 <code>signalAll()</code> 的情况下调用 <code>#ref()</code> #loc
signal.without.corresponding.await.display.name=没有相应 'await()' 的 'signal()'
signal.without.corresponding.await.problem.descriptor=在没有相应 <code>await()</code> 的情况下调用 <code>#ref()</code> #loc
wait.without.corresponding.notify.display.name=没有相应 'notify()' 的 'wait()'
wait.without.corresponding.notify.problem.descriptor=在没有相应 <code>notify()</code> 或 <code>notifyAll()</code> 的情况下调用 <code>#ref()</code> #loc
notify.without.corresponding.wait.display.name=没有相应 'wait()' 的 'notify()'
notify.without.corresponding.wait.problem.descriptor=在没有相应 <code>wait()</code> 的情况下调用 <code>#ref()</code> #loc
integer.multiplication.implicit.cast.to.long.display.name=整数乘法或移位隐式转换为 'long'
integer.multiplication.implicit.cast.to.long.problem.descriptor=#ref: 整数乘法隐式转换为 long #loc
integer.multiplication.implicit.cast.to.long.quickfix=转换为 long
integer.shift.implicit.cast.to.long.problem.descriptor=#ref: 整数移位隐式转换为 long #loc
integer.multiplication.implicit.cast.to.long.option=<html>忽略静态证明不可能溢出的表达式</html>
wait.or.await.without.timeout.display.name=无超时的 'wait()' 或 'await()'
wait.or.await.without.timeout.problem.descriptor=无超时的 <code>#ref</code> #loc
method.return.always.constant.display.name=方法返回类特定的常量
method.return.always.constant.problem.descriptor=方法 <code>#ref()</code> 及其所有派生方法始终返回常量
class.with.too.many.dependencies.display.name=依赖过多的类
class.with.too.many.dependencies.problem.descriptor=类 ''{0}'' 的依赖过多 ({1} > {2})
class.with.too.many.transitive.dependencies.display.name=可传递依赖项过多的类
class.with.too.many.transitive.dependencies.problem.descriptor=类 ''{0}'' 的可传递依赖项过多({1} > {2})
class.with.too.many.dependents.display.name=依赖项过多的类
class.with.too.many.dependents.problem.descriptor=类 ''{0}'' 的依赖项过多 ({1} > {2})
class.with.too.many.transitive.dependents.display.name=传递依赖项过多的类
class.with.too.many.transitive.dependents.problem.descriptor=类 ''{0}'' 的可传递依赖项过多({1} > {2})
class.with.too.many.dependencies.max.option=最大依赖项数
class.with.too.many.dependents.max.option=最大依赖项数
class.with.too.many.transitive.dependencies.max.option=最大可传递依赖项数
class.with.too.many.transitive.dependents.max.option=最大传递依赖项数
cyclic.class.dependency.display.name=循环类依赖
cyclic.class.dependency.problem.descriptor=类 ''{0}'' 循环依赖于其他 {1} 个类
cyclic.class.dependency.1.problem.descriptor=类 ''{0}'' 循环依赖于类 ''{1}''
cyclic.class.dependency.2.problem.descriptor=类 ''{0}'' 循环依赖于类 ''{1}'' 和 ''{2}''
cyclic.package.dependency.display.name=循环软件包依赖关系
cyclic.package.dependency.problem.descriptor=软件包 ''{0}'' 循环依赖于其他 {1} 个软件包
cyclic.package.dependency.1.problem.descriptor=软件包 ''{0}'' 循环依赖于软件包 ''{1}''
cyclic.package.dependency.2.problem.descriptor=软件包 ''{0}'' 循环依赖于软件包 ''{1}'' 和 ''{2}''
class.unconnected.to.package.display.name=独立于其软件包的类
class.unconnected.to.package.problem.descriptor=类 <code>#ref</code> 在其软件包中没有依赖或依赖项
exception.package.display.name=异常软件包
exception.package.problem.descriptor=软件包 ''{0}'' 仅包含异常类
package.with.too.many.classes.display.name=类过多的软件包
package.with.too.many.classes.problem.descriptor=软件包 ''{0}'' 包含过多的类 ({1} > {2})
package.with.too.many.classes.max.option=最大类数:
package.with.too.few.classes.display.name=软件包具有过少类
package.with.too.few.classes.problem.descriptor=软件包 ''{0}'' 包含过少的类 ({1} < {2})
package.with.too.few.classes.min.option=最小类数:
suspicious.package.private.access.display.name=可疑的 package-private 访问权限
groups.of.modules.loaded.together.label=一起加载的模块组:
groups.of.modules.loaded.together.description=每行指定以逗号分隔的模块名称列表，已知这些模块名称是由同一 ClassLoader 加载的，因此，不应报告对此类模块之间的 package-private 成员的访问。
module.with.too.many.classes.display.name=类过多的模块
module.with.too.many.classes.problem.descriptor=模块 ''{0}'' 包含过多的类 ({1} > {2})
module.with.too.many.classes.max.option=最大类数:
module.with.too.few.classes.display.name=类过少的模块
module.with.too.few.classes.problem.descriptor=模块 ''{0}'' 包含过少的类 ({1} < {2})
module.with.too.few.classes.min.option=最小类数:
package.in.multiple.modules.display.name=具有多个模块中的类的软件包
disjoint.package.display.name=具有不相交依赖关系图的软件包
disjoint.package.problem.descriptor=软件包 {0} 可以分解为 {1} 个独立软件包
package.naming.convention.display.name=软件包命名惯例
package.naming.convention.problem.descriptor.short=软件包名称 <code>{0}</code> 过短
package.naming.convention.problem.descriptor.long=软件包名称 <code>{0}</code> 过长
package.naming.convention.problem.descriptor.regex.mismatch=软件包名称 <code>{0}</code> 与正则表达式 ''{1}'' 不匹配
design.for.extension.display.name=为扩展设计
design.for.extension.problem.descriptor=方法 <code>#ref()</code> 可能被重写，其功能会被忽略 #loc
bad.oddness.display.name=可疑的奇数检查
bad.oddness.problem.descriptor=对负值进行奇数检查将会失败 #loc
comparator.not.serializable.display.name='Comparator' 类未被声明为 'Serializable'
comparator.not.serializable.problem.descriptor=比较器类 <code>#ref</code> 未被声明为可序列化 #loc
non.serializable.field.in.serializable.class.display.name='Serializable' 类中有不可序列化的字段
non.serializable.field.in.serializable.class.problem.descriptor=可序列化类中不可序列化的字段 '#ref' #loc
non.serializable.object.passed.to.object.stream.display.name=不可序列化的对象被传递给了 'ObjectOutputStream'
non.serializable.object.passed.to.object.stream.problem.descriptor=传递给 ObjectOutputStream 的不可序列化对象 #loc
non.serializable.object.bound.to.http.session.display.name=不可序列化的对象被绑定到了 'HttpSession'
non.serializable.object.bound.to.http.session.problem.descriptor=传递给 HttpSession 的不可序列化对象 #loc
reflection.for.unavailable.annotation.display.name=对仅源注解的反射访问
reflection.for.unavailable.annotation.problem.descriptor=注解 '#ref' 不保留用于反射访问 #loc
access.to.static.field.locked.on.instance.display.name=访问实例数据上锁定的 'static' 字段
access.to.static.field.locked.on.instance.problem.descriptor=访问实例数据上锁定的 static 字段 <code>#ref</code> #loc
access.to.static.field.locked.on.instance.fix.name=忽略类型 ''{0}'' 的 static 字段
make.method.ctr.quickfix=使方法成为构造函数
replace.all.dot.display.name=可疑的正则表达式实参
replace.all.dot.problem.descriptor=''{0}()'' 调用中存在可疑的正则表达式 #ref #loc
replace.all.dot.quickfix=转义正则表达式元字符
class.extends.utility.class.display.name=类扩展实用程序类
class.extends.utility.class.problem.descriptor=类 <code>#ref</code> 扩展实用程序类 ''{0}'' #loc
class.extends.utility.class.ignore.utility.class.option=如果重写类为实用程序类，则忽略
public.constructor.in.non.public.class.quickfix=将构造函数设为 private
assignment.to.method.parameter.ignore.transformation.option=<html>如果赋值是原始形参的转换，则忽略</html>
type.parameter.extends.final.class.display.name=类型形参扩展 'final' 类
type.parameter.extends.final.class.type.parameter.problem.descriptor=类型形参 <code>#ref</code> 扩展 ''final'' 类{0} #loc
type.parameter.extends.enum.type.parameter.problem.descriptor=类型形参 <code>#ref</code> 隐式扩展 final 枚举 ''{0}'' #loc
type.parameter.extends.final.class.wildcard.problem.descriptor=通配符类型实参 <code>#ref</code> 扩展了 ''final'' 类 ''{0}'' #loc
type.parameter.extends.enum.wildcard.problem.descriptor=通配符类型实参 <code>#ref</code> 隐式扩展了 final 枚举 ''{0}'' #loc
type.parameter.extends.final.class.quickfix=将类型形参替换为实际类
double.negation.display.name=双重否定
double.negation.problem.descriptor=<code>#ref</code> 中的双重否定 #loc
double.negation.quickfix=移除双重否定
exception.from.catch.which.doesntwrap.ignore.option=如果使用异常方法调用的结果，则忽略
exception.from.catch.which.doesntwrap.ignore.cant.wrap.option=如果抛出的异常无法包装异常，则忽略
comparable.implemented.but.equals.not.overridden.display.name=已实现 'Comparable'，但 'equals()' 未被重写
comparable.implemented.but.equals.not.overridden.problem.descriptor=类 <code>#ref</code> 实现 'java.lang.Comparable'，但未重写 'equals()' #loc
comparable.implemented.but.equals.not.overridden.fix.add.note.name=添加 'ordering inconsistent with equals' JavaDoc 记录
comparable.implemented.but.equals.not.overridden.fix.generate.equals.name=生成 'equals()' 方法
unqualified.field.access.display.name=未使用 'this' 限定的实例字段访问
unqualified.field.access.problem.descriptor=未使用 'this' 限定的实例字段访问 <code>#ref</code> #loc
unqualified.method.access.display.name=未使用 'this' 限定的实例方法调用
unqualified.method.access.problem.descriptor=未使用 'this' 限定实例方法调用 <code>#ref()</code> #loc
add.this.qualifier.quickfix=添加 'this' 限定符
while.loop.spins.on.field.ignore.non.empty.loops.option=仅当循环为空时才发出警告
method.may.be.synchronized.problem.descriptor=带 synchronized 块的方法 <code>#ref()</code> 可以是 synchronized 方法 #loc
method.may.be.synchronized.display.name=只有一个 'synchronized' 块的方法可被替换为 'synchronized' 方法
method.may.be.synchronized.quickfix=将方法设为 synchronized 并移除 synchronized 块
fallthru.in.switch.statement.quickfix=添加 ''{0}''
law.of.demeter.display.name=方法调用违反迪米特法则
law.of.demeter.problem.descriptor=对 <code>#ref()</code> 的调用违反迪米特法则 #loc
law.of.demeter.ignore.library.calls.option=忽略库方法上的调用
masked.assertion.display.name=断言通过 'catch' 禁止
masked.assertion.problem.description=''{0}'' 不能失败，因为它通过环绕的 ''catch'' 禁止
enumeration.can.be.iteration.display.name=枚举可以是迭代
enumeration.can.be.iteration.problem.descriptor=<code>#ref()</code> 可被替换为 ''{0}'' 结构 #loc
enumeration.can.be.iteration.quickfix=替换为 'Iterator' 结构
equals.hashcode.called.on.url.display.name=在 'URL' 对象上调用了 'equals()' 或 'hashCode()'
equals.hashcode.called.on.url.problem.descriptor=在 URL 对象上调用 <code>#ref()</code> #loc
collection.contains.url.problem.decriptor={0} <code>#ref</code> 可能包含 URL 对象 #loc
collection.contains.url.display.name='Map' 或 'Set' 可能包含 'URL' 对象
implicit.array.to.string.problem.descriptor=隐式调用数组 <code>#ref</code> 上的 'toString()' #loc
explicit.array.to.string.problem.descriptor=调用数组上的 '#ref()' #loc
implicit.array.to.string.method.call.problem.descriptor=隐式调用调用 <code>#ref</code> 返回的数组上的 'toString()' #loc
implicit.array.to.string.display.name=调用数组上的 'toString()'
implicit.array.to.string.quickfix=使用 ''{0}'' 表达式包装
suspicious.indent.after.control.statement.problem.descriptor=''{0}'' 语句后存在可疑缩进 #loc
suspicious.indent.after.control.statement.display.name=没有大括号的控制语句后存在可疑缩进
unpredictable.big.decimal.constructor.call.display.name=不可预知的 'BigDecimal' 构造函数调用
unpredictable.big.decimal.constructor.call.problem.descriptor=不可预知的 <code>new #ref()</code> 调用 #loc
unpredictable.big.decimal.constructor.call.ignore.references.option=忽略具有变量或方法调用实参的构造函数调用
unpredictable.big.decimal.constructor.call.ignore.complex.literals.option=忽略具有多个文字的构造函数调用 (例如 0.1 + 0.2)
unnecessary.unary.minus.display.name=不必要的一元负号
unnecessary.unary.minus.problem.descriptor=不必要的一元 <code>#ref</code> 运算符 #loc
unnecessary.unary.minus.quickfix=移除一元负号并反转父运算符号
unnecessary.unary.minus.remove.quickfix=移除双一元减号
make.field.final.quickfix=将 ''{0}'' 设为 ''final''
increment.decrement.used.as.expression.quickfix=提取 ''{0}'' 以分离语句
ignore.classes.in.hierarchy.column.name=忽略以下对象的子类:
overly.strong.type.cast.ignore.in.matching.instanceof.option=忽略具有匹配 instanceof 表达式的转换
access.to.non.thread.safe.static.field.from.instance.display.name=非线程安全的 'static' 字段访问
access.to.non.thread.safe.static.field.from.instance.field.problem.descriptor=访问类型为 ''{0}'' 的非线程安全 static 字段 <code>#ref</code> #loc
access.to.non.thread.safe.static.field.from.instance.option.title=非线程安全类:
access.to.non.thread.safe.static.field.from.instance.class.chooser.title=选择非线程安全类
transient.field.not.initialized.display.name=transient 字段在反序列化时未初始化
transient.field.not.initialized.problem.descriptor=transient 字段 <code>#ref</code> 在反序列化时未初始化 #loc
call.to.string.concat.can.be.replaced.by.operator.display.name=对 'String.concat()' 的调用可被替换为 '+'
call.to.string.concat.can.be.replaced.by.operator.problem.descriptor=对 <code>#ref()</code> 的调用可被替换为 '+' 表达式 #loc
call.to.string.concat.can.be.replaced.by.operator.quickfix=用 '+' 替换 'concat()'
new.string.buffer.with.char.argument.display.name=StringBuilder 构造函数调用具有 'char' 实参
new.string.buffer.with.char.argument.problem.descriptor=<code>new #ref()</code> 具有 'char' 类型的实参 #loc
new.string.buffer.with.char.argument.quickfix=将字符实参替换为字符串文字
suspicious.comparator.compare.display.name=可疑的 'Comparator.compare()' 实现
suspicious.comparator.compare.descriptor.parameter.not.used=未使用 'compare()' 形参 <code>#ref</code> #loc
suspicious.comparator.compare.descriptor.non.reflexive=对于相等的元素，比较器不返回 0
to.array.call.style.display.name='Collection.toArray()' 调用样式
to.array.call.style.problem.descriptor.zero=<code>#ref()</code> 调用具有空数组实参 ''{0}'' #loc
to.array.call.style.problem.descriptor.presized=<code>#ref()</code> 调用具有预设大小的数组实参 ''{0}'' #loc
to.array.call.style.quickfix.family.name=修复传递到 'toArray()' 调用的数组的大小
to.array.call.style.quickfix.make.presized=将实参替换为预设大小的数组
to.array.call.style.quickfix.make.zero=将实参替换为空数组
throwable.instance.never.thrown.runtime.exception.problem.descriptor=运行时异常实例 <code>#ref</code> 未抛出 #loc
throwable.instance.never.thrown.checked.exception.problem.descriptor=已检查的异常实例 <code>#ref</code> 未抛出 #loc
throwable.instance.never.thrown.error.problem.descriptor=错误实例 <code>#ref</code> 未抛出 #loc
throwable.instance.never.thrown.problem.descriptor=Throwable 实例 <code>#ref</code> 未抛出 #loc
ignore.guard.clauses.option=忽略临界子句(&G)
ignore.for.equals.methods.option=对 'equals()' 方法忽略(&E)
caught.exception.immediately.rethrown.display.name=捕获的异常被立即重新抛出
caught.exception.immediately.rethrown.problem.descriptor=捕获的异常 <code>#ref</code> 被立即重新抛出 #loc
delete.catch.section.quickfix=删除 'catch' 部分
loop.with.implicit.termination.condition.display.name=具有隐式终止条件的循环
loop.with.implicit.termination.condition.dowhile.problem.descriptor=具有隐式终止条件的 <code>#ref-while</code> 循环 #loc
loop.with.implicit.termination.condition.problem.descriptor=具有隐式终止条件的 <code>#ref</code> 循环 #loc
loop.with.implicit.termination.condition.quickfix=使条件显式
rename.catch.parameter.to.ignored=将 ''catch'' 形参重命名为 ''{0}''
inspection.empty.catch.block.generate.body=从模板生成 'catch' 正文
unnecessary.super.qualifier.display.name=不必要的 'super' 限定符
unnecessary.super.qualifier.problem.descriptor=限定符 <code>#ref</code> 在此上下文中不必要 #loc
unnecessary.super.qualifier.quickfix=移除不必要的 'super' 限定符
collections.field.access.replaceable.by.method.call.display.name=对空集合字段的引用可被替换为方法调用
collections.field.access.replaceable.by.method.call.problem.descriptor=<code>#ref</code> 可被替换为 ''Collections.{0}'' #loc
synchronization.on.local.variable.or.method.parameter.display.name=在局部变量或方法形参上同步
synchronization.on.local.variable.problem.descriptor=在局部变量 <code>#ref</code> 上同步 #loc
synchronization.on.method.parameter.problem.descriptor=在方法形参 <code>#ref</code> 上同步 #loc
too.broad.catch.quickfix=向 ''{0}'' 添加 ''catch'' 子句
replace.with.catch.clause.for.runtime.exception.quickfix=针对 'RuntimeException' 替换为 'catch' 子句
too.broad.catch.option=仅对 RuntimeException、异常、错误或 Throwable 发出警告(&O)
unnecessary.conversion.to.string.display.name=到 'String' 的不必要转换
unnecessary.tostring.call.display.name=对 'toString()' 的调用不必要
unnecessary.tostring.call.problem.descriptor=不必要的 <code>#ref()</code> 调用 #loc
throwable.not.thrown.display.name='Throwable' 未抛出
throwable.result.of.method.call.ignored.problem.descriptor=<code>#ref()</code> 的结果未抛出 #loc
char.used.in.arithmetic.context.display.name=在算术上下文中使用 'char' 表达式
char.used.in.arithmetic.context.problem.descriptor=算术上下文中使用了 'char' #loc
char.used.in.arithmetic.context.quickfix=转换为字符串文字
char.used.in.arithmetic.context.cast.quickfix=插入到 {0} 的转换
unnecessary.constant.array.creation.expression.display.name=常量数组创建中的冗余 'new' 表达式
unnecessary.constant.array.creation.expression.problem.descriptor=可从新数组表达式中移除 <code>#ref</code> #loc
unnecessary.constant.array.creation.expression.family.quickfix=从新数组表达式中移除类型规范
ambiguous.method.call.display.name=对继承方法的调用类似于对本地方法的调用
ambiguous.method.call.problem.descriptor=对来自超类 ''{0}'' 的方法 <code>#ref()</code> 的调用类似于对来自类 ''{1}'' 的方法的调用 #loc
ambiguous.method.call.quickfix=向方法调用中添加 'super' 限定符
change.modifier.quickfix=设为 ''{0}''
the.whole.project=整个项目
this.class=此类
assertequals.may.be.assertsame.display.name='assertEquals()' 可能是 'assertSame()'
assertequals.may.be.assertsame.problem.descriptor=<code>#ref()</code> 可能是 'assertSame()' #loc
logger.initialized.with.foreign.class.problem.descriptor=使用外类 <code>#ref</code> 初始化记录器 #loc
logger.initialized.with.foreign.class.display.name=使用外类初始化记录器
logger.factory.method.name=记录器工厂方法名称
logger.factory.class.name=记录器工厂类名
make.static.final.quickfix=将 ''{0}'' 设为 static final
logging.condition.disagrees.with.log.statement.display.name=日志条件与日志记录调用不匹配
logging.condition.disagrees.with.log.statement.problem.descriptor=日志条件 <code>#ref()</code> 与 ''{0}()'' 日志调用不匹配 #loc
log.statement.guarded.by.log.condition.display.name=日志调用不受日志条件保护
log.statement.guarded.by.log.condition.problem.descriptor=<code>#ref()</code> 日志调用不受日志条件保护 #loc
log.statement.guarded.by.log.condition.quickfix=用日志条件环绕
log.statement.guarded.by.log.condition.flag.all.unguarded.option=标记所有不受保护的日志调用
key.set.iteration.may.use.entry.set.display.name=可以优化对 'keySet()' 的迭代
key.set.iteration.may.use.entry.set.problem.descriptor=<code>#ref</code> 上的迭代可被替换为 ''{0}'' 迭代 #loc
key.set.iteration.may.use.entry.set.quickfix=优化 Map 迭代
string.replaceable.by.string.buffer.in.loop.option=仅在循环中追加时发出警告
declare.collection.as.interface.quickfix=削弱为 ''{0}''
non.exception.name.ends.with.exception.quickfix=使 ''{0}'' 扩展 ''java.lang.Exception''
constant.value.variable.use.display.name=使用已知值为常量的变量
constant.value.variable.use.problem.descriptor=<code>#ref</code> 的值已知为常量 #loc
unnecessary.parentheses.option=忽略澄清圆括号
unnecessary.parentheses.conditional.option=忽略条件表达式条件周围的圆括号
field.may.be.final.display.name=字段可能为 'final'
field.may.be.final.problem.descriptor=字段 <code>#ref</code> 可能为 'final' #loc
cast.that.loses.precision.option=忽略从 int 到 char 的转换
ignore.overflowing.byte.casts.option=忽略从 int 128-255 到字节的转换
variable.not.used.inside.if.display.name='if' 内未使用检查为 'null' 的引用
variable.not.used.inside.if.problem.descriptor='if' 内未使用检查为 'null' 的 <code>#ref</code> #loc
variable.not.used.inside.conditional.problem.descriptor=条件内未使用检查为 'null' 的 <code>#ref</code> #loc
boolean.expression.may.be.conditional.display.name=布尔表达式可被替换为条件表达式
if.may.be.conditional.problem.descriptor=<code>#ref</code> 可被替换为条件表达式 #loc
if.may.be.conditional.quickfix=替换为条件表达式
redundant.string.format.call.display.name=冗余调用 'String.format()'
redundant.call.problem.descriptor=冗余调用 <code>#ref()</code> #loc
redundant.string.format.call.quickfix=移除对 'String.format()' 的冗余调用
redundant.string.formatted.call.quickfix=移除对 'String.formatted()' 的冗余调用
junit4.test.method.in.class.extending.junit3.testcase.display.name=扩展 JUnit 3 TestCase 中的 JUnit 4 测试方法
convert.junit3.test.case.error.string=<code>#ref</code> 可以转换为 JUnit4 测试用例
convert.junit3.test.case.family.name=转换为 JUnit 4 测试用例
convert.junit3.test.case.display.name=JUnit 3 测试可以是 JUnit 4
junit4.test.method.in.class.extending.junit3.testcase.problem.descriptor=方法 <code>#ref()</code> 在扩展 JUnit 3 TestCase 的类内使用 '@Test' 注解 #loc
ignore.test.method.in.class.extending.junit3.testcase.problem.descriptor=使用 '@Ignore' 注解的 JUnit 3 测试方法 <code>#ref()</code> 不会被忽略 #loc
ignore.test.method.in.class.extending.junit3.testcase.quickfix=移除 ''@Ignore'' 并将方法重命名为 ''{0}''
convert.junit3.test.class.quickfix=将 JUnit 3 类 ''{0}'' 转换为 JUnit 4
remove.junit4.test.annotation.quickfix=移除 '@Test' 注解
remove.junit4.test.annotation.and.rename.quickfix=移除 ''@Test'' 注解并重命名为 ''{0}''
equals.called.on.enum.constant.display.name=对枚举值调用了 'equals()'
equals.called.on.enum.constant.problem.descriptor=对枚举值调用了 <code>#ref()</code> #loc
int.literal.may.be.long.literal.display.name=转换为 'long' 可以是 'long' 文字
int.literal.may.be.long.literal.problem.descriptor=<code>#ref</code> 可被替换为 ''{0}'' #loc
constant.assert.condition.display.name='assert' 语句中的常量条件
constant.assert.condition.problem.descriptor=断言条件 <code>#ref</code> 是常量 #loc
assert.with.side.effects.display.name=具有副作用的 'assert' 语句
assert.with.side.effects.problem.descriptor=<code>#ref</code> 具有副作用: {0} #loc
method.count.ignore.getters.setters.option=忽略简单的 getter 和 setter 方法(&I)
class.new.instance.display.name=对 'Class.newInstance()' 的调用不安全
class.new.instance.problem.descriptor=对 <code>#ref()</code> 的调用可能会抛出未声明的已检查的异常 #loc
dynamic.regex.replaceable.by.compiled.pattern.display.name=动态正则表达式可被替换为已编译的 'Pattern'
dynamic.regex.replaceable.by.compiled.pattern.problem.descriptor=<code>#ref()</code> 可被替换为已编译的 'java.util.regex.Pattern' 结构 #loc
dynamic.regex.replaceable.by.compiled.pattern.quickfix=替换为对已编译 'Pattern' 常量的方法的调用
ignore.serializable.option=忽略 'java.io.Serializable'
ignore.cloneable.option=忽略 'java.lang.Cloneable'
listener.may.use.adapter.display.name=类可以扩展适配器而不是实现侦听器
listener.may.use.adapter.problem.descriptor=类 ''{0}'' 可以扩展 ''{1}'' 而不是实现 <code>#ref</code> #loc
listener.may.use.adapter.emtpy.methods.option=仅在找到空实现方法时发出警告(&O)
unnecessary.inherit.doc.display.name=不必要的 '{@inheritDoc}' Javadoc 注释
unnecessary.inherit.doc.problem.descriptor=仅包含 <code>#ref</code> 的 Javadoc 注释不必要 #loc
unnecessary.inherit.doc.field.invalid.problem.descriptor=<code>#ref</code> 在字段上无效 #loc
unnecessary.inherit.doc.constructor.invalid.problem.descriptor=<code>#ref</code> 在构造函数上无效 #loc
unnecessary.inherit.doc.class.invalid.problem.descriptor=<code>#ref</code> 在类上无效 #loc
unnecessary.inherit.doc.module.invalid.problem.descriptor=<code>#ref</code> 在模块声明上无效 #loc
unnecessary.inherit.doc.constructor.no.super.problem.descriptor=找不到继承 Javadoc 的 super 方法 #loc
unnecessary.inherit.doc.quickfix=移除不必要的 {@inheritDoc}
multiple.exceptions.declared.on.test.method.display.name=在测试方法上声明的多个异常
multiple.exceptions.declared.on.test.method.problem.descriptor=<code>#ref</code> 可被替换为 'throws Exception' #loc
unnecessary.javadoc.link.display.name=不必要的 Javadoc 链接
unnecessary.javadoc.link.super.method.problem.descriptor=指向 super 方法的 <code>#ref</code> 不必要 #loc
unnecessary.javadoc.link.this.method.problem.descriptor=指向此方法的 <code>#ref</code> 不必要 #loc
unnecessary.javadoc.link.this.class.problem.descriptor=指向包含类的 <code>#ref</code> 不必要 #loc
unnecessary.javadoc.link.quickfix=移除不必要的 ''{0}''
thread.local.not.static.final.display.name='ThreadLocal' 字段未被声明为 'static final'
thread.local.not.static.final.problem.descriptor=ThreadLocal <code>#ref</code> 未被声明为 'static final' #loc
remove.try.finally.block.quickfix=移除 'try-finally' 块
remove.finally.block.quickfix=移除 'finally' 块
remove.leading.zero.to.make.decimal.quickfix=移除前导零以变为十进制
remove.leading.zeroes.to.make.decimals.quickfix=移除前导零以变为十进制
convert.octal.literal.to.decimal.literal.quickfix=将八进制文字转换为十进制文字
convert.octal.literals.to.decimal.literals.quickfix=将八进制文字转换为十进制文字
ignore.single.field.static.imports.option=忽略单字段静态导入(&F)
ignore.single.method.static.imports.option=忽略单方法静态导入(&M)
ignore.methods.with.boolean.return.type.option=忽略具有 'java.lang.Boolean' 返回类型的方法(&B)
ignore.boolean.methods.in.an.interface.option=忽略 @&interface 中的布尔方法
ignore.methods.overriding.super.method=忽略重写/实现 super 方法的方法(O&)
ignored.io.resource.types=已忽略的 I/O 资源类型
ignored.io.resource.types.label=已忽略的 I/O 资源类型:
choose.io.resource.type.to.ignore=选择要忽略的 I/O 资源类型
ignore.accesses.from.the.same.class=忽略来自同一类的访问
ignore.accesses.from.equals.method=忽略来自 'equals()' 方法的访问
ignore.branches.of.switch.statements=忽略 'switch' 语句的分支
ignore.equals.hashcode.and.tostring=忽略 'equals()'、'hashCode()' 和 'toString()' 方法
ignore.methods.in.anonymous.classes=忽略匿名类中的方法
class.name=类名
method.name.regex=方法名称正则表达式
column.assertion.class.name=断言类名
choose.class=选择类
query.column.name=查询名称开头
query.label=查询名称开头:
update.column.name=更新名称开头
update.label=更新名称开头:
assert.keyword.is.considered.an.assertion='assert' 关键字被视为断言
expected.exception.never.thrown.display.name=从未在测试方法正文中抛出预期异常
expected.exception.never.thrown.problem.descriptor=从未在 ''{0}()'' 的正文中抛出预期 <code>#ref</code> #loc
choose.logger.class=选择记录器类
logger.class.name=记录器类名:
ignore.exceptions.declared.on.library.override.option=忽略在重写库方法的方法上声明的异常(&L)
allow.resource.to.be.opened.inside.a.try.block=允许在 'try' 块内打开资源
any.method.may.close.resource.argument=任何方法都可能关闭作为实参传递的资源
ignore.constructor.method.references=忽略产生 AutoCloseable 的构造函数方法引用
ignore.getters.returning.resource=忽略返回源的 getter
log.method.name=记录方法名称
log.condition.text=日志条件文本
ignore.if.annotated.by=有注解时忽略:
ignore.classes.annotated.by=由以下对象注解时忽略类:
ignored.class.hierarchies.border.title=忽略以下对象的子类:
choose.class.hierarchy.to.ignore.title=选择要忽略的类层次结构
unqualified.inner.class.access.display.name=非限定内部类访问
unqualified.inner.class.access.problem.descriptor=<code>#ref</code> 未使用外部类限定 #loc
unqualified.inner.class.access.quickfix=使用外部类限定
unnecessarily.qualified.inner.class.access.problem.descriptor=使用 <code>#ref</code> 限定 ''{0}'' 不必要 #loc
unnecessarily.qualified.inner.class.access.display.name=不必要的限定内部类访问
unnecessarily.qualified.inner.class.access.quickfix=移除限定符
synchronization.on.static.field.display.name=在 'static' 字段上同步
synchronization.on.static.field.problem.descriptor=在 'static' 字段 <code>#ref</code> 上同步 #loc
assertequals.called.on.arrays.display.name=在数组上调用了 'assertEquals()'
assertequals.called.on.arrays.problem.descriptor=在数组上调用了 <code>#ref()</code> #loc
overly.broad.throws.clause.display.name=过宽的 'throws' 子句
overly.broad.throws.clause.problem.descriptor1=<code>throws #ref</code> 过宽，掩码异常 ''{0}'' #loc
overly.broad.throws.clause.problem.descriptor2=<code>throws #ref</code> 过宽，掩码异常 ''{0}'' 和 ''{1}'' #loc
overly.broad.throws.clause.quickfix1=添加特定异常
overly.broad.throws.clause.quickfix2=替换为特定异常
overly.broad.throws.clause.ignore.thrown.option=忽略隐藏其他异常但自身被抛出的异常(&H)
unnecessarily.qualified.statically.imported.element.display.name=不必要的限定静态导入元素
unnecessarily.qualified.statically.imported.element.problem.descriptor=静态导入元素 ''{0}'' 使用 <code>#ref</code> 不必要限定 #loc
unnecessarily.qualified.statically.imported.element.quickfix=移除不必要的限定符
ignore.instanceof.on.library.classes=忽略库类上的 instanceof
for.can.be.foreach.option=报告索引的 'java.util.List' 循环
for.can.be.foreach.option2=不报告无类型集合上的迭代
cast.conflicts.with.instanceof.quickfix1=在转换中将 ''{0}'' 替换为 ''{1}''
cast.conflicts.with.instanceof.quickfix2=在 instanceof 中将 ''{0}'' 替换为 ''{1}''
double.checked.locking.quickfix=将 ''{0}'' 设为 volatile
double.literal.may.be.float.literal.display.name=转换为 'float' 可以是 'float' 文字
multiple.declaration.ignore.for.option=忽略 'for' 循环声明
multiple.declaration.array.only.option=仅在单个声明中对不同的数组维度发出警告
simplifiable.annotation.display.name=可简化注解
simplifiable.annotation.problem.descriptor=注解中有不必要的 <code>#ref</code> #loc
simplifiable.annotation.whitespace.problem.descriptor=注解中有不必要的空格 #loc
simplifiable.annotation.quickfix=简化注解
overloaded.methods.with.same.number.parameters.option=<html>忽略形参类型绝对不兼容的重载方法</html>
string.concatenation.in.format.call.display.name=字符串串联作为 'format()' 调用的实参
string.concatenation.in.format.call.problem.descriptor=''{0}()'' 调用包含字符串串联实参
string.concatenation.in.format.call.quickfix=将串联替换为单独的实参
string.concatenation.in.message.format.call.display.name=字符串串联作为 'MessageFormat.format()' 调用的实参
string.concatenation.in.message.format.call.problem.descriptor=字符串串联作为 'MessageFormat.format()' 调用的实参 #loc
boxing.boxed.value.display.name=装箱已装箱的值
boxing.boxed.value.problem.descriptor=装箱已装箱的 <code>#ref</code> #loc
boxing.boxed.value.quickfix=移除不必要的装箱
unnecessary.javadoc.link.option=忽略 super 方法的内联链接
constant.junit.assert.argument.display.name=常量断言实参
constant.junit.assert.argument.problem.descriptor=实参 <code>#ref</code> 是常量 #loc
test.case.with.no.test.methods.option=忽略具有带测试方法的超类的测试用例
package.dot.html.may.be.package.info.display.name='package.html' 可以转换为 'package-info.java'
package.dot.html.may.be.package.info.exists.problem.descriptor=<code>package.html</code> 被忽略，因为 <code>package-info.java</code> 存在
package.dot.html.may.be.package.info.problem.descriptor=<code>package.html</code> 可以转换为 <code>package-info.java</code>
package.dot.html.may.be.package.info.delete.quickfix=删除 'package.html'
package.dot.html.may.be.package.info.convert.quickfix=转换为 'package-info.java'
ignore.anonymous.inner.classes=忽略匿名内部类
try.with.identical.catches.display.name='try' 语句中的相同 'catch' 分支
try.with.identical.catches.problem.descriptor=''catch'' 分支与 ''{0}'' 分支相同 #loc
if.can.be.switch.display.name='if' 可被替换为 'switch'
if.can.be.switch.problem.descriptor=<code>#ref</code> 语句可被替换为 'switch' 语句 #loc
if.can.be.switch.minimum.branch.option='if' 条件分支的最小数量:
if.can.be.switch.int.option=对数字启用 switch 建议
if.can.be.switch.enum.option=对枚举启用 switch 建议
if.can.be.switch.null.safe.option=仅对 null-safe 表达式启用建议
unnecessarily.qualified.inner.class.access.option=忽略需要导入的引用
unqualified.inner.class.access.option=忽略对本地内部类的引用
try.with.identical.catches.quickfix=收起 'catch' 块
confusing.else.option=当 'if' 语句之后没有其他语句时报告
html.tag.can.be.javadoc.tag.display.name='<code>...</code>' 可被替换为 '{@code ...}'
html.tag.can.be.javadoc.tag.problem.descriptor=<code>#ref...\\&lt;/code\\&gt;</code> 可被替换为 '{@code ...}' #loc
try.finally.can.be.try.with.resources.display.name='try finally' 可被替换为 'try' with resources
try.finally.can.be.try.with.resources.problem.descriptor=<code>#ref</code> 可以使用自动资源管理 #loc
try.finally.can.be.try.with.resources.quickfix=替换为 'try-with-resources'
array.comparison.display.name=使用 '==' 而不是 'Arrays.equals()' 进行数组比较
array.comparison.problem.descriptor=使用 <code>#ref</code> 而不是 'Arrays.equals()' 来比较数组对象 #loc
array.hash.code.display.name=在数组上调用了 'hashCode()'
array.hash.code.problem.descriptor=数组上调用的 <code>#ref()</code> 可能应当是 'Arrays.hashCode()' #loc
objects.hash.problem.descriptor=传递给 'Objects.hash()' 的数组应包装在 'Arrays.hashcode()' 中
wrap.with.arrays.hash.code.quickfix=使用 ''{0}'' 包装
method.can.be.variable.arity.method.display.name=方法可以有 varargs 形参
method.can.be.variable.arity.method.problem.descriptor=<code>#ref()</code> 可以转换为 vararg 方法 #loc
method.can.be.variable.arity.method.ignore.byte.short.option=忽略具类型为 byte[] 或 short[] 的形参
method.can.be.variable.arity.method.ignore.all.primitive.arrays.option=忽略所有原始数组类型
method.can.be.variable.arity.method.ignore.multiple.arrays.option=忽略具有多个数组形参的方法
method.can.be.variable.arity.method.ignore.multidimensional.arrays.option=忽略多维数组形参
convert.to.variable.arity.method.quickfix=转换为 vararg 方法
mismatched.string.builder.query.update.display.name='StringBuilder' 的查询和更新不匹配
mismatched.string.builder.updated.problem.descriptor=<code>{0} #ref</code> 的内容已更新，但从未被查询 #loc
mismatched.string.builder.queried.problem.descriptor=<code>{0} #ref</code> 的内容已查询，但从未更新 #loc
math.random.cast.to.int.display.name='Math.random()' 转换为 'int'
math.random.cast.to.int.problem.descriptor=<code>#ref</code> 转换为 ''{0}'' 时始终向下舍入为 ''0'' #loc
math.random.cast.to.int.quickfix=添加括号以在转换前执行乘法
boolean.variable.always.inverted.display.name=布尔变量始终反转
boolean.field.always.inverted.problem.descriptor=布尔字段 <code>#ref</code> 始终反转 #loc
boolean.variable.always.inverted.problem.descriptor=布尔变量 <code>#ref</code> 始终反转 #loc
unnecessary.explicit.numeric.cast.display.name=不必要的显式数字转换
unnecessary.explicit.numeric.cast.problem.descriptor=''{0}'' 不必要转换为 <code>#ref</code> #loc
unnecessary.explicit.numeric.cast.quickfix=移除转换
null.thrown.display.name=已抛出 'null'
null.thrown.problem.descriptor=已引发 <code>#ref</code> #loc
unnecessary.final.on.local.variable.or.parameter.display.name=局部变量或形参上存在不必要的 'final'
unnecessary.final.on.local.variable.problem.descriptor=变量 ''{0}'' 上存在不必要的 <code>#ref</code> #loc
unnecessary.final.on.parameter.problem.descriptor=形参 ''{0}'' 上存在不必要的 <code>#ref</code> #loc
unnecessary.final.report.local.variables.option=报告局部变量
unnecessary.final.report.parameters.option=报告形参
unnecessary.final.on.parameter.only.interface.option=仅对 abstract 或接口方法发出警告
choose.exception.class=选择异常类
choose.exception.label=被禁止的异常:
class.independent.of.module.display.name=独立于其模块的类
class.independent.of.module.problem.descriptor=类 <code>#ref</code> 在其模块中没有依赖或依赖项 #loc
class.only.used.in.one.module.display.name=仅在其他模块中使用的类
class.only.used.in.one.module.problem.descriptor=类 <code>#ref</code> 在其模块 ''{0}'' 中只有依赖和/或依赖性 #loc
simplifiable.equals.expression.option.non.constant=报告具有非常量非空实参的等于
simplifiable.equals.expression.display.name='equals()' 调用之前的 'null' 检查不必要
simplifiable.equals.expression.problem.descriptor=''{0}()'' 调用之前的 ''null'' 检查不必要 #loc
simplifiable.equals.expression.quickfix=翻转 ''.{0}()'' 并移除不必要的 ''null'' 检查
use.of.concrete.class.option.ignore.abstract=忽略抽象类类型
use.of.concrete.class.option.report.method.returns=报告方法返回类型
use.of.concrete.class.option.report.local.variable=报告局部变量类型
use.of.concrete.class.option.report.parameter=报告方法形参类型
use.of.concrete.class.option.report.static.fields=报告 static 字段类型
use.of.concrete.class.option.report.instance.fields=报告实例字段类型
use.of.concrete.class.option.report.instanceof=报告 instanceof、patterns 或 getClass() 比较中使用的类型
use.of.concrete.class.option.report.cast=报告转换表达式中使用的类型
class.only.used.in.one.package.display.name=仅在其他软件包中使用的类
class.only.used.in.one.package.problem.descriptor=类 <code>#ref</code> 在其软件包 ''{0}'' 中只有依赖和/或依赖项 #loc
unnecessary.return.option=在具有 'else' 分支的 'if' 语句的 then 分支中忽略
usage.of.obsolete.assert.display.name=使用废弃的 'junit.framework.Assert' 方法
use.of.obsolete.assert.problem.descriptor=对来自 ''{0}'' 的 <code>#ref()</code> 的调用应替换为对来自 ''org.junit.Assert'' 的方法的调用 #loc
use.of.obsolete.assert.quickfix=替换为 'org.junit.Assert' 方法调用
ignored.junit.test.display.name=使用 '@Ignore'/'@Disabled' 注解的 JUnit 测试
ignored.junit.test.classproblem.descriptor=使用 <code>#ref</code> 注解的测试类 ''{0}'' #loc
ignored.junit.test.method.problem.descriptor=使用 <code>#ref</code> 注解的测试方法 ''{0}()'' #loc
ignored.junit.test.ignore.reason.option=只报告没有原因的注解
unclear.binary.expression.display.name=具有不同优先级的多个运算符
unclear.binary.expression.problem.descriptor=表达式可以使用澄清括号 #loc
unclear.binary.expression.quickfix=添加澄清括号
new.exception.without.arguments.display.name=未使用实参调用异常构造函数
new.exception.without.arguments.problem.descriptor=<code>new #ref()</code> 没有实参 #loc
absolute.alignment.in.user.interface.display.name=AWT/Swing 代码中的绝对对齐
absolute.alignment.in.user.interface.problem.descriptor=使用了绝对对齐常量 <code>{0}.#ref</code> #loc
throws.runtime.exception.display.name=在 'throws' 子句中声明的未检查的异常
throws.runtime.exception.problem.descriptor=在 'throws' 子句中声明的未检查的异常 <code>#ref</code> #loc
throws.runtime.exception.quickfix=从 ''throws'' 子句中移除 ''{0}''
throws.runtime.exception.move.quickfix=将 ''{0}'' 移动到 Javadoc ''@throws'' 标记中
empty.class.ignore.parameterization.option=如果类是父类型的形参化，则将其忽略
ambiguous.field.access.display.name=对继承字段的访问类似于对周围代码中元素的访问
ambiguous.field.access.hides.local.variable.problem.descriptor=访问超类 ''{0}'' 中的 <code>#ref</code> 字段类似于访问局部变量 #loc
ambiguous.field.access.hides.parameter.problem.descriptor=访问超类 ''{0}'' 中的 <code>#ref</code> 字段类似于访问参数 #loc
ambiguous.field.access.hides.field.problem.descriptor=访问超类 ''{0}'' 中的 <code>#ref</code> 字段类似于访问周围类中的字段 #loc
ambiguous.field.access.quickfix=将 'super' 限定符添加到字段访问
add.0.to.ignore.if.annotated.by.list.quickfix=将 ''{0}'' 添加到“有注解时忽略”列表中
non.final.field.in.enum.display.name='enum' 中的非 final 字段
non.final.field.in.enum.problem.descriptor=枚举 ''{0}'' 中存在非 final 字段 <code>#ref</code> #loc
externalizable.without.public.no.arg.constructor.display.name=没有 'public' 无实参构造函数的 'Externalizable' 类
externalizable.without.public.no.arg.constructor.problem.descriptor=可外部化类 <code>#ref</code> 没有 'public' 无实参构造函数 #loc
make.constructor.public=将构造函数设为 'public'
string.concatenation.missing.whitespace.display.name=字符串串联中可能缺少空格
string.concatenation.missing.whitespace.problem.descriptor=字符串串联中可能缺少空格 #loc
string.concatenation.missing.whitespace.option=忽略具有变量字符串的串联
negated.equality.expression.display.name=否定相等表达式
negated.equality.expression.problem.descriptor=否定 ''{0}'' #loc
negated.equality.expression.quickfix=移除否定
negated.conditional.expression.display.name=否定条件表达式
negated.conditional.expression.problem.descriptor=否定条件表达式 #loc
negated.conditional.expression.quickfix=移除否定
suspicious.array.cast.display.name=可疑的数组转换
suspicious.array.cast.problem.descriptor=可疑转换为 <code>#ref</code> #loc
public.constructor.display.name='public' 构造函数可被替换为工厂方法
public.default.constructor.problem.descriptor=类 <code>#ref</code> 具有 'public' 默认构造函数
public.constructor.problem.descriptor=public 构造函数 <code>#ref()</code> #loc
public.constructor.quickfix=将构造函数替换为工厂方法
junit3.style.test.method.in.junit4.class.display.name=JUnit 4 类中的旧样式 JUnit 测试方法
junit3.style.test.method.in.junit4.class.problem.descriptor=JUnit 4 类中的旧样式 JUnit 测试方法 <code>#ref()</code> #loc
none=无
private=private
package.local.private=package-private 与 private
protected.package.local.private=protected、package-private 和 private
non.final.utility.class.display.name=实用程序类不为 'final'
non.final.utility.class.problem.descriptor=实用程序类 <code>#ref</code> 不为 'final' #loc
0.will.no.longer.be.overridable.by.1={0} 将不再可被 {1} 重写
arrays.as.list.with.zero.or.one.argument.display.name='Arrays.asList()' 调用的实参过少
arrays.as.list.with.one.argument.problem.descriptor=仅使用一个实参调用 <code>#ref()</code> #loc
arrays.as.list.with.zero.arguments.problem.descriptor=调用 <code>#ref()</code> 以创建空列表 #loc
string.concatenation.argument.to.log.call.display.name=非常量字符串串联作为日志调用的实参
string.concatenation.argument.to.log.call.problem.descriptor=非常量字符串串联作为 <code>#ref()</code> 日志调用的实参 #loc
string.concatenation.argument.to.log.call.quickfix=将串联替换为形参化的日志消息
placeholder.count.matches.argument.count.display.name=占位符数量与日志调用中的实形参量不匹配
placeholder.count.matches.argument.count.more.problem.descriptor=提供的实形参量({0})多于指定的占位符({1}) #loc
placeholder.count.matches.argument.count.fewer.problem.descriptor=提供的实形参量({0})少于指定的占位符数({1}) #loc
assignment.to.superclass.field.display.name=构造函数将值赋给在超类中定义的字段
assignment.to.superclass.field.problem.descriptor=赋值给在超类 ''{1}'' 中定义的字段 ''{0}'' #loc
inner.class.referenced.via.subclass.display.name=通过子类引用的内部类
inner.class.referenced.via.subclass.problem.descriptor=内部类 <code>#ref</code> 在类 ''{0}'' 中声明，但通过子类 ''{1}'' 引用 #loc
inner.class.referenced.via.subclass.quickfix=使内部类访问合理化
boolean.parameter.display.name='public' 方法具有 'boolean' 形参
boolean.parameter.problem.descriptor='public' 方法 <code>#ref()</code> 具有 'boolean' 形参 #loc
boolean.parameters.problem.descriptor='public' 方法 <code>#ref()</code> 具有 'boolean' 形参 #loc
boolean.parameter.constructor.problem.descriptor='public' 构造函数 <code>#ref()</code> 具有 'boolean' 形参 #loc
boolean.parameters.constructor.problem.descriptor='public' 构造函数 <code>#ref()</code> 具有 'boolean' 形参 #loc
boolean.parameter.only.report.multiple.option=仅报告具有多个布尔形参的方法
unnecessary.unicode.escape.display.name=不必要的 Unicode 转义序列
unnecessary.unicode.escape.problem.descriptor=Unicode 转义序列 <code>#ref</code> 可被替换为 ''{0}'' #loc
unnecessary.unicode.escape.problem.tab.descriptor=Unicode 转义序列 <code>#ref</code> 可被替换为制表符 #loc
unnecessary.unicode.escape.problem.newline.descriptor=Unicode 转义序列 <code>#ref</code> 可被替换为换行字符 #loc
missing.package.info.display.name=缺少 'package-info.java'
missing.package.info.problem.descriptor=软件包 ''{0}'' 缺少 <code>package-info.java</code> 文件
missing.package.html.problem.descriptor=软件包 ''{0}'' 缺少 <code>package.html</code> 文件
package.info.java.without.package.display.name=不带 'package' 语句的 'package-info.java'
package.info.without.package.problem.descriptor='package-info.java' 没有 'package' 语句
package.info.without.package.quickfix=添加 ''package {0};''
package.info.without.package.family.quickfix=添加 package 语句
auto.closeable.resource.display.name=在没有 'try-with-resources' 的情况下使用 AutoCloseable
auto.closeable.resource.problem.descriptor=在没有 ''try-with-resources'' 语句的情况下使用 ''{0}'' #loc
auto.closeable.resource.quickfix=忽略此方法返回的 'AutoCloseable'
auto.closeable.resource.returned.option=忽略从所有方法调用返回的 AutoCloseable 实例
problematic.varargs.method.display.name=非 vararg 方法重写 vararg 方法
problematic.varargs.method.override.problem.descriptor=非 vararg 方法 <code>#ref()</code> 重写 vararg 方法 #loc
negatively.named.boolean.variable.problem.descriptor=布尔变量 <code>#ref</code> 已否定命名 #loc
negatively.named.boolean.variable.display.name=否定命名的布尔变量
invert.quickfix.family.name=反转布尔
invert.method.quickfix=反转方法
invert.quickfix=反转 ''{0}''
throwable.printed.to.system.out.display.name='Throwable' 打印到 'System.out'
throwable.printed.to.system.out.problem.descriptor=''Throwable'' 实参 <code>#ref</code> 到 ''System.{0}.{1}()'' 调用
suppress.for.tests.scope.quickfix=对 'Tests' 范围禁止
implicit.default.charset.usage.display.name=隐式平台默认字符集
implicit.default.charset.usage.problem.descriptor=对 <code>#ref()</code> 的调用使用平台的默认字符集
implicit.default.charset.usage.constructor.problem.descriptor=<code>new #ref()</code> 调用使用平台的默认字符集
interface.may.be.annotated.functional.display.name=接口可以注解为 '@FunctionalInterface'
interface.may.be.annotated.functional.problem.descriptor=接口 <code>#ref</code> 可以使用 @FunctionalInterface 注解
only.report.public.methods.option=仅报告 'public' 方法
lambda.parameter.hides.member.variable.display.name=lambda 形参隐藏字段
static.initializer.references.subclass.display.name=static 初始值设定项引用子类
lambda.parameter.hides.member.variable.problem.descriptor=lambda 形参 <code>#ref</code> 隐藏类 ''{0}'' 中的字段 #loc
lambda.parameter.hides.member.variable.ignore.invisible.option=忽略从 lambda 实际不可见的字段
shared.thread.local.random.display.name='ThreadLocalRandom' 实例可能是共享的
shared.thread.local.random.problem.descriptor='ThreadLocalRandom' 实例可能在线程之间共享
native.method.naming.convention.element.description='native' 方法
use.of.obsolete.date.time.api.display.name=使用废弃的日期时间 API
use.of.obsolete.date.time.api.problem.descriptor=使用了废弃的日期时间类型 <code>#ref</code> #loc
warn.on.label=警告对象:
all.levels.option=所有日志级别
warn.level.and.lower.option=警告级别和更低
info.level.and.lower.option=信息级别和更低
debug.level.and.lower.option=调试级别和更低
trace.level.option=跟踪级别
ignored.autocloseable.types.column.label=已忽略 AutoCloseable 资源类型
ignored.autocloseable.types.label=已忽略的 AutoCloseable 资源类型:
choose.autocloseable.type.to.ignore.title=选择要忽略的 AutoCloseable 资源类型
big.decimal.method.without.rounding.called.display.name='BigDecimal' 方法调用没有舍入模式实参
big.decimal.method.without.rounding.called.problem.descriptor=在没有舍入模式实参的情况下调用了 'BigDecimal.#ref()'
bigdecimal.legacy.method.display.name=调用了 'BigDecimal' 遗留方法
bigdecimal.legacy.method.problem.descriptor=对 'BigDecimal.#ref()' 的调用可以使用 'RoundingMode' 枚举常量
bigdecimal.legacy.method.quickfix=使用 'RoundingMode' 枚举常量
serializable.stores.non.serializable.display.name='Serializable' 对象隐式存储非 'Serializable' 对象
serializable.lambda.stores.non.serializable.problem.descriptor=可序列化 lambda 隐式存储类型为 ''{0}'' 的不可序列化对象
serializable.local.class.stores.non.serializable.problem.descriptor=可序列化局部类 ''{1}'' 隐式存储类型为 ''{0}'' 的不可序列化对象
serializable.anonymous.class.stores.non.serializable.problem.descriptor=可序列化匿名类隐式存储类型为 ''{0}'' 的不可序列化对象
assignment.to.lambda.parameter.display.name=赋值给 lambda 形参
assignment.to.lambda.parameter.problem.descriptor=赋值给 lambda 形参 <code>#ref</code> #loc
class.with.only.private.constructors.display.name=仅包含 'private' 构造函数的类应被声明为 'final'
class.with.only.private.constructors.problem.descriptor=仅包含 'private' 构造函数的类 <code>#ref</code> 应被声明为 'final'
property.value.set.to.itself.display.name=属性值设置为自身
equals.with.itself.display.name=在自身上调用了 'equals()'
equals.with.itself.problem.descriptor=在自身上调用了 <code>#ref()</code>
junit4.method.naming.convention.element.description=JUnit 4+ 测试方法
junit3.method.naming.convention.element.description=JUnit 3 测试方法
introduce.holder.class.quickfix=引入 holder 类
double.brace.initialization.display.name=双大括号初始化
double.brace.initialization.quickfix=替换为正则初始化
return.of.inner.class.display.name=返回匿名、局部或内部类的实例
return.of.anonymous.class.problem.descriptor=返回匿名类的实例 #loc
return.of.local.class.problem.descriptor=返回局部类 <code>{0}</code> 的实例 #loc
return.of.inner.class.problem.descriptor=返回非 static 内部类 <code>{0}</code> 的实例 #loc
return.of.inner.class.ignore.non.public.option=忽略非 public 方法的返回值
parameter.type.prevents.overriding.display.name=形参类型阻止重写
parameter.type.prevents.overriding.problem.descriptor=形参类型 <code>#ref</code> 位于 ''{0}''，而 super 方法形参类型位于 ''{1}''，可防止重写 #loc
parameter.type.prevents.overriding.quickfix=将形参类型更改为 ''{0}''
parameter.type.prevents.overriding.family.quickfix=更改形参类型
suspicious.getter.setter.display.name=可疑的 getter/setter
suspicious.setter.problem.descriptor=setter <code>#ref()</code> 对字段 ''{0}'' 赋值 #loc
suspicious.getter.problem.descriptor=getter <code>#ref()</code> 返回字段 ''{0}'' #loc
unnecessary.break.display.name=不必要的 'break' 语句
unnecessary.break.problem.descriptor=<code>#ref</code> 语句不必要 #loc
utility.class.can.be.enum.display.name=实用程序类可以是 'enum'
utility.class.code.can.be.enum.problem.descriptor=实用程序类 <code>#ref</code> 可以是 'enum' #loc
utility.class.code.can.be.enum.quickfix=转换为 'enum'
non.public.clone.display.name='clone()' 方法不是 'public'
non.public.clone.problem.descriptor=<code>#ref()</code> 方法不是 'public' #loc
only.warn.on.public.clone.methods=仅对 'public' 克隆方法发出警告
only.warn.on.protected.clone.methods=仅对 'protected' 克隆方法发出警告
clone.returns.class.type.display.name='clone()' 应当具有等于其所包含类的返回类型
clone.returns.class.type.problem.descriptor=''clone()'' 应当具有返回类型 ''{0}'' #loc
clone.returns.class.type.quickfix=将返回类型更改为 ''{0}''
clone.returns.class.type.family.quickfix=将返回类型更改为类类型
use.of.clone.display.name=使用 'clone()' 或 'Cloneable'
use.of.clone.call.problem.descriptor=调用 <code>#ref()</code>
use.of.clone.call.method.problem.descriptor=实现 <code>#ref()</code>
use.of.clone.reference.problem.descriptor=使用 <code>#ref</code>
dangling.javadoc.display.name=悬空的 Javadoc 注释
dangling.javadoc.problem.descriptor=悬空的 Javadoc 注释 #loc
dangling.javadoc.convert.quickfix=替换为块注释
dangling.javadoc.delete.quickfix=移除悬空的注释
equals.replaceable.by.objects.call.display.name='equals()' 表达式可被替换为 'Objects.equals()' 表达式
equals.replaceable.by.objects.call.problem.descriptor=<code>#ref</code> 可被替换为 'Objects.equals()' 表达式 #loc
equals.replaceable.by.objects.check.not.null.option=高亮显示与 'a != null \\&\\& a.equals(b)' 类似的表达式
array.objects.equals.display.name=对数组使用浅层方法或 'Objects' 方法
array.equals.problem.descriptor=或许应当使用 ''{0}'' 完成数组比较''
array.hashcode.problem.descriptor=或许应当使用 ''{0}'' 完成数组哈希代码计算
extends.throwable.display.name=类直接扩展 'Throwable'
anonymous.extends.throwable.problem.descriptor=匿名类直接扩展 'java.lang.Throwable' #loc
extends.throwable.problem.descriptor=类 <code>#ref</code> 直接扩展 'java.lang.Throwable' #loc
lambda.parameter.naming.convention.display.name=lambda 形参命名惯例
lambda.parameter.naming.convention.element.description=lambda 形参
assert.message.not.string.display.name='assert' 消息不是字符串
assert.message.of.type.boolean.problem.descriptor=类型为 ''{0}'' 的 ''assert'' 消息 #loc
assert.message.not.string.only.warn.boolean.option=仅当 'assert' 消息为 'boolean' 或 'java.lang.Boolean' 时发出警告
suspicious.literal.underscore.display.name=数字文字中的可疑下划线
suspicious.literal.underscore.problem.descriptor=带下划线的数字文字中的组没有长度 3 #loc
unary.plus.quickfix=移除一元 '+'
convert.double.unary.quickfix=替换为 ''{0}{1}''
prefix.operation.quickfix.family.name=替换为前缀运算符
super.tear.down.in.finally.display.name=未从 'finally' 块调用 'super.tearDown()'
super.tear.down.in.finally.problem.descriptor=未从 'finally' 块调用 <code>#ref()</code> #loc
confusing.floating.point.literal.option=忽略科学记数法中的浮点文字
class.may.be.interface.java8.option=使用 Java 8 时报告包含非 abstract 方法的类
simplifiable.boolean.expression.display.name=可简化的布尔表达式
unnecessary.initcause.display.name=对 'Throwable.initCause()' 的调用不必要
unnecessary.initcause.problem.descriptor=不必要的 <code>Throwable.#ref()</code> 调用
unnecessary.initcause.quickfix=移除 'Throwable.initCause()' 调用
consider.static.final.fields.constant.option=考虑 'static final' 字段常量
atomic.field.updater.not.static.final.display.name='AtomicFieldUpdater' 字段未被声明为 'static final'
atomic.field.updater.not.static.final.problem.descriptor={0} 字段 <code>#ref</code> 未被声明为 ''static final'' #loc
atomic.field.updater.issues.display.name='AtomicFieldUpdater' 声明不一致
field.not.found.in.class.problem.descriptor=类 ''{1}'' 中未找到命名为 ''{0}'' 的字段
field.incorrect.type.problem.descriptor=字段 ''{0}'' 没有类型 ''{1}''
field.missing.volatile.modifier.problem.descriptor=字段 ''{0}'' 没有 ''volatile'' 修饰符
field.has.static.modifier.problem.descriptor=字段 ''{0}'' 具有 ''static'' 修饰符
private.field.not.accessible.problem.descriptor=''private'' 字段 ''{0}'' 无法从此处访问
package.local.field.not.accessible=package-private 字段 ''{0}'' 无法从此处访问
protected.field.not.accessible.problem.descriptor=''protected'' 字段 ''{0}'' 无法从此处访问
interface.clashes.with.object.class.display.name=接口方法与 'Object' 中的方法冲突
interface.clashes.with.object.class.problem.descriptor=<code>#ref()</code> 与 'java.lang.Object' 中的方法冲突
optional.used.as.field.or.parameter.type.display.name=用作字段或形参类型的 'Optional'
optional.used.as.field.type.problem.descriptor=<code>#ref</code> 用作字段 ''{0}'' 的类型
optional.used.as.parameter.type.problem.descriptor=<code>#ref</code> 用作形参 ''{0}'' 的类型
lambda.unfriendly.method.overload.display.name=方法重载对 lambda 不友好
lambda.unfriendly.method.overload.problem.descriptor=方法 <code>#ref()</code> 的重载对 lambda 不友好
lambda.unfriendly.constructor.overload.problem.descriptor=构造函数 <code>#ref()</code> 的重载对 lambda 不友好
optional.contains.collection.display.name='Optional' 包含数组或集合
optional.contains.collection.problem.descriptor='Optional' 包含集合 <code>#ref</code>
optional.contains.array.problem.descriptor='Optional' 包含数组 <code>#ref</code>
synchronization.on.get.class.display.name=在 'getClass()' 上同步
synchronization.on.get.class.problem.descriptor=在 <code>#ref()</code> 上同步 #loc
object.instantiation.inside.equals.or.hashcode.display.name='equals()' 或 'hashCode()' 内部的对象实例化
object.instantiation.inside.equals.or.hashcode.problem.descriptor=''{0}()'' 内部的对象实例化 #loc
object.instantiation.inside.equals.or.hashcode.problem.descriptor2=''{0}()'' ({1}) 内部的对象实例化 #loc
lambda.body.can.be.code.block.name=lambda 体可以是代码块
lambda.body.can.be.code.block.quickfix=将 lambda 体扩展为 {...}
lambda.parameter.type.can.be.specified.name=可以指定 lambda 形参类型
lambda.parameter.type.can.be.specified.descriptor=Lambda 形参类型可以扩展为{0}
lambda.parameter.type.can.be.specified.quickfix=将形参类型扩展为{0}
lambda.parameter.type.can.be.specified.family.quickfix=指定 lambda 形参类型
diamond.can.be.replaced.with.explicit.type.arguments.name=diamond 可被替换为显式类型实参
diamond.can.be.replaced.with.explicit.type.arguments.quickfix=将 '<>' 替换为显式类型实参
lambda.can.be.replaced.with.anonymous.name=lambda 可被替换为匿名类
lambda.can.be.replaced.with.anonymous.quickfix=将 lambda 替换为匿名类
method.ref.can.be.replaced.with.lambda.name=方法引用可被替换为 lambda
method.ref.can.be.replaced.with.lambda.quickfix=将方法引用替换为 lambda
try.statement.with.multiple.resources.name=可以拆分具有多个资源的 'try' 语句
try.statement.with.multiple.resources.quickfix=拆分具有多个资源的 'try' 语句
multi.catch.can.be.split.name=多 catch 可拆分为单独的 catch 块
multi.catch.can.be.split.quickfix=将多 catch 拆分为单独的 'catch' 块
assertion.can.be.if.name=断言可被替换为 'if' 语句
assert.can.be.if.quickfix=将 'assert' 替换为 'if' 语句
if.can.be.assertion.name=语句可被替换为 'assert' 或 'Objects.requireNonNull'
if.can.be.assertion.replace.with.assertion.quickfix=将语句替换为 'assert' 语句
if.can.be.assertion.replace.with.objects.requirenonnull.quickfix=将语句替换为 'Objects.requireNonNull()'
single.statement.in.block.name=代码块包含单条语句
single.statement.in.block.descriptor=''{0}'' 包含单条语句
single.statement.in.block.quickfix=从 ''{0}'' 语句中移除大括号
single.statement.in.block.family.quickfix=从语句中移除大括号
single.element.annotation.name=非规范化注解
single.element.annotation.quickfix=添加 'value='
single.element.annotation.family.quickfix=将注解扩展为标准形式
array.creation.without.new.keyword.name=创建不带 'new' 表达式的数组
array.creation.without.new.keyword.quickfix=添加 ''new {0}''
array.creation.without.new.keyword.family.quickfix=添加 'new' 表达式
overly.long.lambda.display.name=过长的 lambda 表达式
overly.long.lambda.problem.descriptor=lambda 表达式过长 (# 非注释源语句 = {0}) #loc
wait.notify.not.in.synchronized.context.display.name='wait()' 或 'notify()' 不在同步的上下文中
wait.notify.while.not.synchronized.on.problem.descriptor=''{0}'' 未同步时调用 <code>#ref</code> #loc
call.to.suspicious.string.method.display.name=调用可疑的 'String' 方法
call.to.suspicious.string.method.problem.descriptor=国际化上下文中调用的 <code>String.#ref()</code> #loc
unnecessary.string.escape.display.name=不必要的转义字符
unnecessary.string.escape.problem.descriptor=<code>#ref</code> 进行了不必要的转义
unnecessary.string.escape.quickfix=将不必要的转义字符替换为未转义字符

array.can.be.replaced.with.enum.values = 可以将数组替换为枚举值
array.can.be.replaced.with.enum.values.quickfix = 将数组替换为 {0}.values()
array.can.be.replaced.with.enum.values.family.quickfix = 将数组替换为 EnumType.values()

string.concatenation.replace.fix=替换为 StringBuilder
string.concatenation.replace.fix.name=将变量 ''{0}'' 从字符串转换为 {1}
string.concatenation.replace.fix.name.null.safe=将变量 ''{0}'' 从字符串转换为 {1} (null 安全)
string.concatenation.introduce.fix=引入 StringBuilder
string.concatenation.introduce.fix.name=引入新的 {1} 以更新变量 ''{0}''
string.concatenation.introduce.fix.name.null.safe=引入新的 {1} 以更新变量 ''{0}'' (null 安全)

ignored.class.names=忽略类(包括子类)
ignored.class.label=已忽略类(包括子类):
meta.annotation.without.runtime.retention=不含 '@Retention(RUNTIME)' 注解的测试注解
string.equals.char.sequence.display.name=使用 'CharSequence' 实参调用了 'String.equals()'
string.equals.char.sequence.problem.descriptor=使用 ''{0}'' 实参调用了 <code>String.equals()</code> #loc
object.equals.can.be.equality.display.name='equals()' 调用可被替换为 '=='
object.equals.can.be.equality.problem.descriptor=<code>#ref()</code> 可被替换为 '=='
not.object.equals.can.be.equality.problem.descriptor=<code>!#ref()</code> 可被替换为 '!='
redundant.explicit.var.type.display.name=可以省略局部变量类型
variable.type.can.be.explicit.display.name=变量类型可以是显式的
assignment.or.return.of.field.with.mutable.type.display.name=具有可变类型的字段的赋值或返回
assignment.of.field.with.mutable.type.problem.descriptor=赋值给形参 <code>#ref</code> 中的 {0} 字段 ''{1}'' #loc
return.of.field.with.mutable.type.problem.descriptor=返回 {0} 字段 <code>{1}</code> #loc
ignore.private.methods.option=忽略 private 方法中的赋值和返回值

inspection.redundant.string.operation.display.name=冗余的 'String' 操作
inspection.redundant.string.remove.fix.name=移除冗余的 ''{0}()'' 调用
inspection.redundant.string.fix.family.name=移除冗余调用
inspection.redundant.string.call.message=<code>#ref()</code> 的调用冗余 #loc
inspection.redundant.empty.string.argument.message=不必要的空字符串实参
inspection.redundant.string.length.argument.message=不必要的字符串长度实参
inspection.redundant.zero.argument.message=不必要的零实参
inspection.redundant.string.remove.argument.fix.name=移除实参
inspection.redundant.string.intern.on.constant.message=编译时常量上 <code>#ref()</code> 的调用不必要 #loc
inspection.redundant.string.constructor.message=<code>#ref</code> 是冗余的 #loc
inspection.redundant.string.replace.with.arg.fix.name=替换为实参
inspection.redundant.string.replace.with.empty.fix.name=替换为空字符串
inspection.redundant.string.option.do.not.report.string.constructors=不报告字符串构造函数
inspection.x.call.can.be.replaced.with.y=''{0}'' 调用可被替换为 ''{1}''

inspection.type.may.be.weakened.display.name=类型可能被削弱
inspection.type.may.be.weakened.problem.descriptor=变量 <code>#ref</code> 的类型可能被削弱为 {0} #loc
inspection.type.may.be.weakened.method.problem.descriptor=方法 <code>#ref()</code> 的返回类型可能被削弱为 {0} #loc
inspection.type.may.be.weakened.parameter.problem.descriptor=形参 <code>#ref</code> 的类型可能被削弱为 {0} #loc
inspection.type.may.be.weakened.field.problem.descriptor=字段 <code>#ref</code> 的类型可能被削弱为 {0} #loc
inspection.type.may.be.weakened.quickfix=将类型削弱为 ''{0}''
inspection.type.may.be.weakened.ignore.option=在赋值中使用右手类型作为最弱的类型(&R)
inspection.type.may.be.weakened.collection.method.option=对方法调用实参使用形参化集合类型(&P)
inspection.type.may.be.weakened.do.not.weaken.to.object.option=不削弱为 'java.lang.Object'(&W)
inspection.type.may.be.weakened.add.stopper=作为停止类添加以减弱
inspection.type.may.be.weakened.add.stopper.single=添加 {0} 作为停止类以削弱
inspection.type.may.be.weakened.only.weaken.to.an.interface=仅削弱为接口
inspection.type.may.be.weakened.do.not.weaken.return.type=不削弱返回类型
inspection.type.may.be.weakened.add.stop.class.family=添加停止类
inspection.type.may.be.weakened.weaken.type.family=削弱类型
inspection.type.may.be.weakened.add.stop.class.selection.table=停止类
inspection.type.may.be.weakened.add.stop.class.selection.table.label=停止类:
inspection.type.may.be.weakened.add.stop.class.selection.popup=选择停止类
inspection.type.may.be.weakened.do.not.weaken.inferred.variable.type=不建议削弱声明为 'var' 的变量

inspection.commented.out.code.display.name=注释掉的代码
inspection.commented.out.code.problem.descriptor=注释掉的代码 ({0} {0, choice, 1#行|1<行})
commented.out.code.delete.quickfix=删除注释
commented.out.code.uncomment.quickfix=撤消代码注释
inspection.commented.out.code.min.lines.options=最少代码行数

inspection.catch.ignores.exception.display.name=catch 块可能会忽略异常
inspection.catch.ignores.exception.option.comments=当 'catch' 块包含注释时不发出警告
inspection.catch.ignores.exception.option.nonempty=当 'catch' 块不为空时不发出警告
inspection.catch.ignores.exception.option.ignored.used=当名称为 'ignore(d)' 的异常实际上未被忽略时不发出警告
inspection.catch.ignores.exception.used.message=已使用命名为 <code>#ref</code> 的 'catch' 形参 #loc
inspection.catch.ignores.exception.empty.message=空 <code>#ref</code> 块 #loc
inspection.catch.ignores.exception.unused.message=未使用的 'catch' 形参 <code>#ref</code> #loc
inspection.catch.ignores.exception.vm.ignored.message=<code>#ref</code> 块中可能会忽略 ''{0}'' 之类的意外虚拟机异常 #loc

inspection.redundant.collection.operation.display.name=冗余的 'Collection' 操作
inspection.redundant.collection.operation.fix.family.name=简化集合操作
inspection.redundant.collection.operation.problem.arraycopy=为复制数组而创建的集合不必要
inspection.redundant.collection.removal.by.index.problem=按索引移除可被替换为按对象移除
inspection.redundant.collection.removal.by.index.fix=使用按对象移除
inspection.redundant.collection.unnecessary.contains.problem=不必要的 ''{0}()'' 检查
inspection.redundant.collection.unnecessary.contains.fix=移除 ''{0}()'' 检查

comments.as.content.option=注释计为内容
copy.constructor.misses.field.display.name=复制缺少字段的构造函数
copy.constructor.misses.field.problem.descriptor.1=复制未复制字段 ''{0}'' 的构造函数
copy.constructor.misses.field.problem.descriptor.2=复制未复制字段 ''{0}'' 和 ''{1}'' 的构造函数
copy.constructor.misses.field.problem.descriptor.3=复制未复制字段 ''{0}''、''{1}'' 和 ''{2}'' 的构造函数
copy.constructor.misses.field.problem.descriptor.many=复制未复制 {0} 个字段的构造函数

fix.add.argument.family.name=添加实参
fix.add.argument.name=添加 ''{0}'' 实参

inspection.constant.expression.display.name=可以计算常量表达式
inspection.constant.expression.message=常量表达式可以计算为 ''{0}''
inspection.constant.expression.fix.name=计算 ''{0}'' 的常量值
inspection.constant.expression.fix.name.with.value=将 ''{0}'' 替换为常量值 ''{1}''
inspection.constant.expression.fix.family.name=计算常量值

inspection.redundant.compare.call.display.name=冗余的 'compare()' 方法调用
inspection.redundant.compare.call.fix.name=内联 'compare()' 调用

inspection.simplifiable.if.statement.display.name='if' 语句可被替换为条件或布尔表达式
inspection.simplifiable.if.statement.message=If 语句可被替换为 ''{0}''
inspection.simplifiable.if.statement.option.dont.warn.on.ternary=不建议使用 '?:' 运算符
inspection.simplifiable.if.statement.fix.name=将 ''if else'' 替换为 ''{0}''
inspection.simplifiable.if.statement.fix.family.name=将 'if else' 替换为条件运算符

inspection.list.remove.in.loop.display.name=在循环中调用了 'List.remove()'
inspection.list.remove.in.loop.message=可被替换为 'List.subList().clear()'

implicit.default.charset.usage.fix.family.name=指定 UTF-8 字符集

inspection.redundant.class.call.display.name=冗余的 'isInstance()' 或 'cast()' 调用
inspection.new.object.equality.display.name=使用 '==' 比较新对象
inspection.new.object.equality.message=使用 ''{0}'' 比较新对象
inspection.excessive.range.check.message=可被替换为 ''{0}''
inspection.excessive.range.check.fix.family.name=简化过度范围检查
suspicious.integer.div.assignment.problem.descriptor=除法结果被截断为整数
suspicious.integer.div.assignment.display.name=可疑的整数除法赋值
suspicious.integer.div.assignment.quickfix=转换为 double
inspection.if.statement.missing.break.in.loop.name=在 'if' 条件下提前退出循环
inspection.if.statement.missing.break.in.loop.description=满足条件后，可以终止循环
inspection.if.statement.missing.break.in.loop.quickfix=添加 'break'

inspection.case.mismatch.display.name='String' 操作中不匹配的大小写
inspection.case.mismatch.message.arg.is.lower=方法 ''{0}()'' 始终返回 {1}: 实参包含小写符号，而限定符仅为大写
inspection.case.mismatch.message.arg.is.upper=方法 ''{0}()'' 始终返回 {1}: 实参包含大写符号，而限定符仅为小写

inspection.suspicious.date.format.display.name=可疑的日期格式模式
inspection.suspicious.date.format.message.upper=使用了大写 ''{0}'' ({1}) 模式: 预期可能为 ''{2}'' ({3})
inspection.suspicious.date.format.message.lower=使用了小写 ''{0}'' ({1}) 模式: 预期可能为 ''{2}'' ({3})

fix.replace.map.with.flat.map.description='map()' 可被替换为 'flatMap()'

fix.eliminate.folded.if.present.name=移除折叠的 'ifPresent()' 调用
fix.eliminate.folded.if.present.description=可以消除折叠的 'ifPresent()' 调用

inspection.pattern.variable.can.be.used.display.name=可以使用模式变量
inspection.pattern.variable.can.be.used.message=变量 ''{0}'' 可被替换为模式变量
inspection.pattern.variable.can.be.used.fix.family.name=替换为模式变量
inspection.pattern.variable.can.be.used.fix.name=将 ''{0}'' 替换为模式变量
inspection.pattern.variable.can.be.used.existing.message=可以使用现有模式变量 ''{0}'' 代替 ''{1}''
inspection.pattern.variable.can.be.used.existing.fix.family.name=替换为现有模式变量
inspection.pattern.variable.can.be.used.existing.fix.name=将 ''{0}'' 替换为现有模式变量 ''{1}''

array.hash.code.fix.family.name=替换为隐式 'hashCode'
objects.hash.fix.family.name=使用 'Arrays.hashCode()' 包装
unqualified.static.access.fix.family.name=限定静态访问
replace.field.reference.fix.family.name=替换字段引用
replace.field.reference.fix.text=将字段引用替换为 {0}
replace.method.call.fix.family.name=替换方法调用
replace.method.call.fix.text=将方法调用替换为 {0}
delete.unnecessary.statement.fix.family.name=移除冗余语句
increment.decrement.used.as.expression.fix.family.name=提取到分离语句中
use.of.properties.as.hashtable.fix.family.name=修复属性访问
unnecessary.java.doc.link.fix.family.name=移除冗余标记
swap.equals.fix.family.name=翻转方法调用
remove.modifier.fix.family.name=移除修饰符
shift.out.of.range.fix.family.name=修复移位值
unnecessary.unicode.escape.fix.family.name=替换为字符
unnecessary.unicode.escape.fix.text=替换为换行字符
absolute.alignment.in.user.interface.fix.family.name=替换为常量
static.inheritance.fix.family.name=将继承替换为限定引用
suspicious.to.array.call.fix.family.name=替换为正确数组
incorrect.date.format.fix.family.name=修复不正确的日期格式
referencing.subclass.0.from.superclass.1.initializer.might.lead.to.class.loading.deadlock=从超类 {1} 初始值设定项引用子类 {0} 可能会导致类加载死锁
collections.field.access.replaceable.by.method.call.fix.family.name=将 Collections.EMPTY_* 替换为调用
delete.catch.section.fix.family.name=删除 catch 语句
make.field.static.final.fix.family.name=设为 static final
string.concatenation.in.format.call.fix.family.name=将串联替换为实参
implicit.array.to.string.fix.family.name=将 Array.toString() 设为隐式
listener.may.use.adapter.fix.family.name=替换为适配器
unnecessary.temporary.object.fix.family.name=替换串联
utility.class.with.public.constructor.fix.family.name=将构造函数设为 private
change.modifier.fix.family.name=更改修饰符
make.field.final.fix.family.name=设为 final
generate.to.string.quick.fix.family.name=生成
generate.to.string.quick.fix.text=生成 toString()
replace.instanceof.fix.family.name=替换 instanceOf 类型
replace.cast.fix.family.name=替换转换类型
make.package.private.fix.family.name=设为 package-private
make.method.final.fix.family.name=将方法设为 'final'
replace.casted.literal.with.just.literal.fix.family.name=替换为 {0} 文字
char.used.in.arithmetic.content.cast.fix.family.name=插入转换
ignore.parentheses.around.single.no.formal.type.lambda.parameter=忽略单个非正式类型 lambda 形参周围的括号
double.checked.locking.fix.family.name=将字段设为 volatile
declare.collection.as.interface.fix.family.name=削弱类型
string.equals.empty.string.fix.family.name=简化空字符串检查
class.without.logger.annotations.tab=注解
class.without.logger.loggers.tab=记录器
options.title.ignored.classes=已忽略的类
options.label.ignored.classes=已忽略的类:
add.catch.section.fix.family.name=添加 'catch' 子句
inspection.autocloseable.resource.ignored.methods.title=忽略从这些方法返回的 AutoCloseable 实例:
logger.initialized.with.foreign.class.fix.family.name=替换外类
extend.exception.fix.family.name=使类扩展 'Exception'
inspection.use.of.private.field.inner.classes.option=忽略来自内部类的访问
refused.bequest.fix.family.name=将调用插入 super 方法
mark.modules.as.loaded.together.fix.family.name=将模块标记为一起加载
mark.modules.as.loaded.together.fix.text=将 ''{0}'' 和 ''{1}'' 模块标记为一起加载
inspection.suspicious.package.private.access.description={0} 是 {1}，但在不同的模块 ''{2}'' 中声明
ignore.class.fix.family.name=对这些类型忽略
create.default.branch.fix.family.name=插入 'default' 分支
unnecessary.fully.qualified.name.fix.family.name=替换完全限定名称
return.of.collection.field.fix.family.name=使返回集合 'unmodifiable'
remove.redundant.substring.fix.family.name=移除冗余的 'substring()' 调用
remove.redundant.string.fix.text=使用 ''{0}()'' 并移除冗余的 ''{1}()'' 调用
use.equalsignorecase.for.case.insensitive.comparison=为不区分大小写的比较使用 equalsIgnoreCase()
make.class.final.fix.family.name=将类设为 final
side.effects.method.ref.to.lambda.fix.family.name={0} (副作用)
encapsulate.variable.fix.family.name=封装字段
method.may.be.static.replaces.qualifiers.with.class.references.option=快速修复可将实例限定符替换为类引用
method.may.be.static.ignore.default.methods.option=忽略 'default' 方法
make.public.static.void.fix.family.name=修复修饰符
make.public.static.void.fix.name=将 ''{0}'' 的签名更改为 ''{1}''
convert.empty.anonymous.to.new.fix.family.name=移除 '{}'
replace.method.ref.with.qualifier.fix.family.name=替换为限定符
replace.method.ref.with.qualifier.problem.method=方法引用可被替换为限定符
replace.method.ref.with.qualifier.problem.lambda=lambda 可被替换为调用限定符
add.throws.clause.fix.family.name=修复 'throws' 子句
prefer.empty.array.options.title=首选空数组:
prefer.empty.array.options.mode.always=始终
prefer.empty.array.options.mode.by.level=根据语言级别
prefer.empty.array.options.mode.always.never=从不(首选预设大小的数组)
too.broad.scope.inspection.fix.family.name=缩小范围
replace.with.cast.fix.family.name=替换为转换
replace.anonymous.with.lambda.body.fix.family.name=将调用替换为方法体
replace.with.method.reference.fix.family.name=将方法引用上的方法调用替换为相应的方法调用
replace.with.lambda.body.fix.family.name=将 lambda 上的方法调用替换为 lambda 体
inspection.trivial.functional.expression.usage.description=可以简化方法调用
replace.with.var.fix.family.name=将显式类型替换为 'var'
inspection.redundant.explicit.variable.type.description=可以省略局部变量的显式类型
add.read.write.object.methods.fix.family.name=添加始终抛出异常的 'readObject()' 和 'writeObject()' 方法
add.read.write.object.methods.fix.text=添加始终抛出异常的 'writeObject()' 方法
add.read.write.object.methods.fix.text2=添加始终抛出异常的 'readObject()' 方法
replace.with.method.ref.fix.family.name=将 lambda 替换为方法引用
replace.with.method.ref.fix.name.may.change.semantics=将 lambda 替换为方法引用(可能更改语义)
qualify.call.fix.family.name=限定调用
replace.with.comparator.fix.family.name=使用 'Comparator' static 方法简化比较器
inspection.comparator.combinators.description=可被替换为 'Comparator' 链
inspection.comparator.combinators.description2=可被替换为 ''{0}''
inspection.unnecessary.string.escape.report.char.literals.option=报告字符文字
inspection.method.call.in.loop.ignore.known.methods.option=忽略有副作用的已知方法
fix.data.provider.signature.family.name=修正数据提供程序方法签名
allow.suppressions.fix.family.name=允许禁止
allow.suppressions.fix.text=允许这些禁止
remove.suppress.comment.fix.family.name=移除 //{0}
convert.to.j.unit.4.fix.family.name=将 JUnit 3 类转换为 JUnit 4
throws.runtime.exception.fix.family.name=从 'throws' 子句中移除
move.exception.to.javadoc.fix.family.name=移动到 Javadoc '@throws'
create.package.info.java.family.name=创建 'package-info.java'
remove.loop.fix.family.name=移除循环
remove.call.fix.family.name=移除调用
inspection.meta.annotation.without.runtime.description={0} 应具有 @Retention(RetentionPolicy.RUNTIME)
inspection.refused.bequest.super.annotated.option=仅在通过以下方式注解 super 方法时报告:
inspection.empty.class.ignore.subclasses.option=忽略 {0} 的子类
inspection.test.method.without.assertions.exceptions.option=忽略声明异常的测试方法
inspection.collection.must.have.initial.capacity.initializers.option=不报告字段初始值设定项
utility.class.without.private.constructor.cant.generate.constructor.title=无法生成构造函数
utility.class.without.private.constructor.cant.generate.constructor.message=实用程序类具有实例化，将不会创建 private 构造函数
inspection.suspicious.package.private.access.problem={0} 重写了来自在不同模块 ''{2}'' 中声明的 {1} 的 package-private 方法
inspection.condition.covered.by.further.condition.descr=条件 ''{0}'' 由后面的{1, choice, 1#条件 ''''{2}''''|2#条件}覆盖
inspection.parameterized.parameters.static.collection.display.name=没有数据提供程序方法的形参化测试类
create.missing.switch.branch=创建缺少的 switch 分支 ''{0}''
create.missing.switch.branches=创建缺少的分支: {0}
redundant.as.list.for.iteration.problem=不必要的 'Arrays.asList()' 调用
redundant.as.list.for.iteration.fix.name=解开
assert.with.side.effects.call.mutates.expression=调用 ''{0}()'' 会改变 ''{1}''
assert.with.side.effects.call.mutates.field=调用 ''{0}()'' 会改变字段 ''{1}''
inspection.comparator.combinators.fix.chain=替换为 'Comparator' 链
logger.initialized.with.foreign.options.title=选择记录器工厂类
test.without.assertion.options.choose.class=选择断言类
constant.on.lhs.of.comparison.options.item.left=左
constant.on.lhs.of.comparison.options.item.right=右
convert.junit3.test.fix.conflict.semantics=如果 {1} 转换为 JUnit 4，方法调用 {0} 可能会更改语义
convert.junit3.test.fix.conflict.compile=如果 {1} 转换为 JUnit 4，方法调用 {0} 将不编译
convert.junit3.test.fix.conflict.compile.2=如果 {1} 转换为 JUnit 4，引用 {0} 将不编译
inspection.byte.array.output.stream.to.string.message=ByteArrayOutputStream 转换低效

fix.data.provider.signature.fix.name=将方法签名更改为 ''{0}''
fix.data.provider.create.method.fix.name=创建数据提供程序方法 '@Parameters public static Iterable<Object> parameters()'
fix.data.provider.signature.missing.method.problem=形参化测试类 <code>#ref</code> 缺少用 '@Parameters' 注解的数据提供程序方法
fix.data.provider.signature.incorrect.problem=数据提供程序方法 <code>#ref()</code> 的签名不正确
fix.data.provider.multiple.methods.problem=类 <code>#ref</code> 中存在多个 @Parameters 数据提供程序方法
cloneable.class.without.clone.todo.message=TODO: 复制此处的可变状态，这样此克隆就不能更改初始克隆的内部项
cloneable.class.without.clone.ignore.when.clone.called.option=如果调用超类的 clone() 方法需要 Cloneable，则忽略
trivial.if.option.ignore.assert.statements=忽略带有简单 'assert' 的 'if' 语句
if.may.be.factorized.problem.descriptor=<code>#ref</code> 可以因式分解 #loc
if.may.be.factorized.quickfix=替换为因式分解表达式
weaken.visibility.quickfix=削弱可见性
non.final.field.in.enum.quickfix.option=在快速修复不可用时忽略字段
checkbox.ignore.null.on.wrong.side=<html>忽略错误侧的 <code>null</code></html>
cyclic.class.dependency.ignore.in.same.file=忽略位于同一文件中的类之间的循环
ambiguous.field.access.navigate.quickfix=导航到明显访问过的{0, choice, 1#局部变量|2#形参|3#字段}
logger.initialized.with.foreign.class.ignore.super.class.option=忽略使用超类初始化的记录器
logger.initialized.with.foreign.class.ignore.non.public.classes.option=忽略非 public 类中的记录器
dangling.javadoc.ignore.copyright.option=忽略 JavaDoc 格式的文件头注释
package.in.multiple.modules.problem.descriptor2=软件包 ''{0}'' 具有模块 ''{1}'' 和 ''{2}'' 中的类
package.in.multiple.modules.problem.descriptor3=软件包 ''{0}'' 具有模块 ''{1}''、''{2}'' 和 ''{3}'' 中的类
package.in.multiple.modules.problem.descriptor.many=软件包 ''{0}'' 具有模块 ''{1}''、''{2}'' 以及其他 {3} 个模块中的类
use.isblank.to.check.if.string.is.whitespace.or.empty=使用 'isBlank()' 检查字符串是否为空或者仅包含空格
expression.may.be.factorized.display.name=表达式可以因式分解
create.missing.enum.switch.branches.fix.family.name=创建缺少的枚举 switch 分支
create.missing.sealed.class.switch.branches.fix.family.name=创建缺少的密封类 switch 分支
inspection.case.mismatch.message.label.is.lower=无法访问 switch 分支: 标签包含小写符号，而选择器仅支持大写
inspection.case.mismatch.message.label.is.upper=无法访问 switch 分支: 标签包含大写符号，而选择器仅支持小写
for.can.be.foreach.fix.no.indexed=不报告索引的 'java.util.List' 循环
use.of.concrete.class.option.ignore.records=忽略 Java 记录
create.null.branch.fix.family.name=插入 'null' 分支
instanceof.concrete.class.pattern.problem.descriptor=针对具体类 <code>#ref</code> 的模式测试 #loc
remove.annotation.parameter.0.fix.name=移除注解形参 ''{0}''
set.annotation.parameter.0.1.fix.name=将注解形参 {0} 设置为 "{1}"
progress.text.analyzing.package.0=正在分析软件包 {0}
unnecessary.inner.interface.modifier.problem.descriptor=修饰符 <code>#ref</code> 对于内部接口是冗余的 #loc
unnecessary.interface.method.modifier.problem.descriptor=修饰符 <code>#ref</code> 对于接口方法是冗余的 #loc
unnecessary.interface.inner.class.modifier.problem.descriptor=修饰符 <code>#ref</code> 对于接口的内部类是冗余的 #loc
unnecessary.interface.field.modifier.problem.descriptor=修饰符 <code>#ref</code> 对于接口字段是冗余的 #loc
unnecessary.modifier.display.name=不必要的修饰符
unnecessary.enum.constructor.modifier.problem.descriptor=修饰符 <code>#ref</code> 对于枚举构造函数是冗余的 #loc
unnecessary.inner.enum.modifier.problem.descriptor=修饰符 <code>#ref</code> 对于内部枚举是冗余的 #loc
unnecessary.record.modifier.problem.descriptor=修饰符 <code>#ref</code> 对于记录是冗余的
unnecessary.inner.record.modifier.problem.descriptor=修饰符 <code>#ref</code> 对于内部记录是冗余的
unnecessary.transient.modifier.problem.descriptor=修饰符 <code>#ref</code> 对于 'static' 字段是冗余的
unnecessary.strictfp.modifier.problem.descriptor=修饰符 <code>#ref</code> 在 Java 17 和更高版本上是冗余的
inspection.replace.on.literal.display.name=替换操作无效
missing.override.warn.on.super.option=当方法的重写方法并非全部具有 '@Override' 注解时，高亮显示该方法
unnecessary.interface.member.modifier.problem.descriptor=修饰符 <code>#ref</code> 对于接口成员是冗余的 #loc
try.with.identical.catches.checkbox.different.comments=不报告带有不同注释的 catch 块
unresolved.class.reference.repair.display.name=未解析的类引用
unresolved.class.reference.repair.problem.descriptor=无法解析 ''{0}'' 引用
switch.statement.with.too.few.branches.ignore.pattern.option=不报告模式切换语句
pattern.variable.hides.field.display.name=模式变量隐藏字段
pattern.variable.hides.field.problem.descriptor=模式变量 <code>#ref</code> 隐藏类 ''{0}'' 中的字段 #loc
law.of.demeter.field.problem.descriptor=对 <code>#ref()</code> 的访问违反迪米特法则 #loc
instantiating.datetimeformatter.without.locale.problem.descriptor=在未在国际化上下文中指定区域设置的情况下调用 <code>DateTimeFormatter.#ref()</code> #loc
change.modifier.package.private.quickfix=设为 package-private
inspection.non.strict.comparison.equality.message=可以替换为等式
inspection.non.strict.comparison.equality.display.name=非严格不等式 '>=' 或 '<=' 可以替换为 '=='
inspection.quirk.method.reference.return.type.message=目标方法返回类型提及了不可访问的类 {0}。这将在运行时导致 IllegalAccessError。
test.method.is.public.void.no.arg.problem.descriptor1=测试方法 <code>#ref()</code> 不应具有形参 #loc
test.method.is.public.void.no.arg.problem.descriptor2=测试方法 <code>#ref()</code> 未被声明为 'public void' #loc
test.method.is.public.void.no.arg.problem.descriptor3=测试方法 <code>#ref()</code> 不应为 'static' #loc
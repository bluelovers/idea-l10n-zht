0.is.not.a.legal.name=''{0}'' 不是合法的类名
0.is.not.accessible.from.1=无法从 {1} 访问 {0}
0.is.not.allowed.in.interface=接口中不允许使用 {0} 
0.with.1.visibility.in.the.target.class.is.not.accessible.from.2=目标类中可见性为 {1} 的 {0} 无法从 {2} 访问
0.with.1.visibility.is.not.accessible.from.2=可见性为 {1} 的 {0} 将无法从 {2} 访问
action.Anonymous.text.configure=配置
action.ES6.Generate.Index.description=生成 index.js/index.ts
action.ES6.Generate.Index.text=生成 index.js/index.ts
action.EnablePackageJsonMismatchedDependenciesNotification.text=启用有关从 package.json 安装依赖项的通知
action.EslintImportCodeStyle.description=应用 ESLint 代码样式规则
action.EslintImportCodeStyle.text=应用 ESLint 代码样式规则
action.ExplainNodeModulesLibrariesAction.text=解释 node__modules 库
action.FindDuplicatedIndexedFilesInNodeModulesAction.text=在 node__modules 中查找重复的索引文件
action.FlowJS.Restart.All.Servers.description=重启所有 Flow 服务器
action.FlowJS.Restart.All.Servers.text=重启所有 Flow 服务器
action.Generate.Constructor.JavaScript.text=构造函数
action.Generate.GetAccessor.JavaScript.text=Getter
action.Generate.GetSetAccessor.JavaScript.text=Getter 和 Setter
action.Generate.Missing.Members.ES6.text=实现方法…
action.Generate.Missing.Members.TypeScript.text=实现成员…
action.Generate.SetAccessor.JavaScript.text=Setter
action.InstallNodeLocalDependencies$Root.text=在项目根中运行 'npm install'
action.InstallNodeLocalDependencies$Root.text.template=为 {1} 运行 ''{0}''
action.InstallNodeLocalDependencies.text=安装 Node.js 依赖项
action.JS.TypeScript.Include.Generated.Declarations.description=在项目中包含 .d.ts 子文件
action.JS.TypeScript.Include.Generated.Declarations.text=包括 '.d.ts' 子文件
action.JSShowUsagesFloatingToolbar.description=显示文本光标处符号的用法
action.JSShowUsagesFloatingToolbar.text=显示用法(_S)
action.JasmineGenerateAfterEachMethodAction.text=Jasmine afterEach
action.JasmineGenerateBeforeEachMethodAction.text=Jasmine beforeEach
action.JasmineGenerateNewSpecAction.text=Jasmine Spec
action.JasmineGenerateNewSuiteAction.text=Jasmine Suite
action.JavaScript.DownloadNode.text=下载 Node.js…
action.JavaScript.SearchForComponentUsageAction.description=显示当前所选组件的用法
action.JavaScript.SearchForComponentUsageAction.text=显示组件用法
action.JavaScript.ShowComponentUsages.description=显示当前所选组件的用法
action.JavaScript.ShowComponentUsages.text=显示组件用法
action.JavaScriptGenerateDictionaries.text=生成 JavaScript 拼写检查器字典
action.LearnWebstormAction.description=查看自定义和代码编辑提示以充分利用 WebStorm
action.LearnWebstormAction.text=学习 WebStorm
action.NewJavaScriptFile.description=从指定的模板创建 JavaScript 文件
action.NewJavaScriptFile.text=JavaScript 文件
action.NewPackageJsonFile.description=创建 package.json 文件
action.NewPackageJsonFile.text=package.json
action.NewTypeScriptFile.description=创建新的 TypeScript 文件
action.NewTypeScriptFile.text=TypeScript 文件
action.NodeServicesProfilerAction.text=启动 Node.js 服务分析
action.QUnitGenerateNewTestAction.text=QUnit Test
action.QUnitGenerateSetupAction.text=QUnit Setup
action.QUnitGenerateTearDownAction.text=QUnit TearDown
action.RestartEsLintServiceAction.description=停止运行 ESLint 服务，根据需要自动重启
action.RestartEsLintServiceAction.text=根据需要停止和自动运行 ESLint 服务
action.RunJsbtTask.text=运行 Gulp/Grunt/npm 任务
action.StopSingleEsLintServiceAction.text=根据需要停止和自动运行服务
action.ToggleNodeCoreCodingAssistanceAction.text=切换 Node.js 的编码辅助
action.TypeScript.Enable.Service.text=TypeScript 语言服务
action.TypeScript.Include.Sources.text=包括 JavaScript 文件
action.TypeScript.Restart.Service.text=重启 TypeScript 服务
action.TypeScript.Show.Structure.text=显示 TypeScript 服务器项目
action.TypeScript.Test.Slow.Server.text=测试慢速 TypeScript 服务器
action.TypeScriptAddEnumTextInlayAction.text=添加枚举显式值
action.TypeScriptExtractTypeAlias.description=提取类型别名
action.TypeScriptExtractTypeAlias.text=类型别名…
action.already.set.for.containing.folder.or.project.description=已针对包含的文件夹或项目进行设置。
action.creates.new.file.description=创建新的 {0} 文件
action.don.t.ask.again.text=不再询问
action.don.t.use.library.description=不使用库
action.js.tagged.literal.injection.text=JS 标记字面量注入
action.jump.to.text=跳转到…
action.name.disable.category=禁用 {0}
action.restart.service=重启服务
action.show.error.details.text=显示错误详细信息
action.show.structure.text=显示结构
action.structureview.show.object.inherited=从对象继承
action.use.library.description=使用库
action.view.install.text=查看并安装…
actionscript.space.after.dots.in.rest.parameter=在 rest 形参中的 '…' 后面
actionscript.validation.message.get.method.access.type.is.different.from.setter=Flash 编译器错误 174646\: Get 访问器方法访问类型不同于 set 访问器访问类型，应为 ''{0}''
actionscript.validation.message.set.method.access.type.is.different.from.getter=Flash 编译器错误 174646\: Set 访问器方法访问类型不同于 get 访问器访问类型，应为 ''{0}''
activity.key.node.js.name=Node.js
activity.tracker.node.modules.name=node_modules 跟踪器
add.import.binding.to.import=将导入绑定添加到导入
add.import.specifier.to.import=将导入说明符添加到导入
add.variable.to.require=添加 require 调用的变量
advanced.setting.js.FindInFiles.with.library.files=在“在文件中查找”中选择“目录”时，在库文件中搜索
advanced.setting.js.fallback.to.old.eval.outside.of.import.graph=使用来自服务器的类型时，回退到 IDE 类型评估器以处理当前导入图之外的文件。
advanced.setting.js.fallback.to.old.eval.outside.of.import.graph.description=IDE 可以尝试评估不在当前 TypeScript 项目(tsconfig.json) import 图内的文件中的类型。在这种情况下，服务器可以加载和解析大量新文件来提供类型。回退到 IDE 评估器可以显著提高大型项目的性能。
advanced.setting.js.js.advanced.annotator=高级 JavaScript 注解器
advanced.setting.js.js.advanced.annotator.description=JavaScript 注解器会检查 JS / JSX 中的基本语义 JS 错误。高级注解器可以发现更多错误，但可能会消耗更多 CPU 资源。
advanced.setting.js.jsx.advanced.annotator=高级 JSX 注解器
advanced.setting.js.jsx.advanced.annotator.description=JSX 注解器会验证 JSX 和 TSX 中的 JSX 标签。高级注解器可以发现更多错误，但可能消耗更多 CPU 资源。如果您使用 TypeScript 语言服务，请考虑禁用此选项。
advanced.setting.js.jsx.client.components=高亮显示 JSX 客户端组件
advanced.setting.js.jsx.client.components.description=对 JSX 服务器/客户端组件使用不同的颜色。可能会消耗额外的 CPU 资源
advanced.setting.js.semantic.highlighting.accuracy=语义高亮显示准确性
advanced.setting.js.semantic.highlighting.accuracy.basic=基本
advanced.setting.js.semantic.highlighting.accuracy.description=语义高亮显示会为代码元素指定不同的颜色，以区分本地和全局、函数和对象等。更高的准确性可以更深入地分析代码，但可能会消耗更多的 CPU 资源。
advanced.setting.js.semantic.highlighting.accuracy.high=高
advanced.setting.js.semantic.highlighting.accuracy.limited=有限
advanced.setting.js.semantic.highlighting.accuracy.normal=正常
advanced.settings.js=JavaScript 和 TypeScript
and.more=以及更多…
anonymous.to.named.intention.function.name=函数名称\:
automatically.replace.with.template.string.on.typing=输入 '${' 时自动将字符串字面量替换为模板字符串
border.title.inspection.export.results.capitalized.location=位置
build.event.title.failed.to.list.tasks=无法列出 {0} 任务
buildTools.EditRunSettingsAction.text=编辑 ''{0}'' 设置(&E)…
buildTools.JsbtAddBuildfileAction.text=添加 {0}
buildTools.JsbtReloadTasksAction.npm.text=重新加载脚本
buildTools.JsbtReloadTasksAction.text=重新加载任务
buildTools.JsbtRemoveBuildfileAction.text=移除 {0}
buildTools.JsbtShowTasksAction.npm.text=显示 npm 脚本
buildTools.JsbtShowTasksAction.text=显示 {0} 任务
buildTools.ShowSettingsAction.npm.text=编辑 npm 配置(&E)…
buildTools.ShowSettingsAction.text={0}设置…
buildTools.add.with=使用 {1} 添加 {0}
buildTools.choose_buildfile.text=选择 {0}
buildTools.edit.run.configuration=编辑运行配置
buildTools.failed.to.list.tasks=无法列出任务
buildTools.failed.to.list.tasks.details.reference=详细信息
buildTools.no.files.added=未添加文件
buildTools.no.such.file=没有此类文件
buildTools.no.tasks.found=未找到任务
buildTools.searchEverywhere.npm.text=运行 {0} npm 脚本
buildTools.searchEverywhere.text=运行“{0}”任务
buildTools.tooltip.click.to.show.error.details=点击以显示错误详细信息
buildTools.tree.sortBy.definitionOrder.text=定义顺序
buildTools.tree.sortBy.name.text=名称
buildTools.tree.sortBy.text=排序方式
bundler.configuration.automatic=自动
bundler.configuration.automatic.hint={0} 将使用当前文件所在文件夹或其任意父文件夹中的 {1} 配置文件内的模块解析规则。
bundler.configuration.automatic.how.it.works=运作方式
bundler.configuration.detect.description=检测适合模块解析的 {0} 配置文件\:
bundler.configuration.disabled=已禁用
bundler.configuration.field=配置文件\:
bundler.configuration.field.required.error=手动模式下需要配置文件路径
bundler.configuration.manual=手动
button.abort=中止
button.continue=继续
button.install.update=安装/更新
can.t.find.flow.executable=找不到 Flow 可执行文件
cannot.modify.library.code=无法修改库或 SDK 代码
cannot.parse.service.initialization.answer.0=无法解析服务初始化回复 {0}\n
cannot.refactor.anonymous.function=现有非调用用法阻止调用点分析。
change.method.signature.and.update.delegating.call.fix.family.name=更改方法签名并更新委托调用
change.method.signature.and.update.delegating.call.fix.text=更改 {0} 签名以匹配 {1} 调用和更新调用
change.method.signature.and.update.delegating.call.noname.fix.text=更改签名以匹配 {0} 调用和更新调用
change.method.signature.delegating.default.text=委托
change.method.signature.fix.family.name=更改方法签名
change.method.signature.fix.text=更改 {0} 签名
change.signature.call.expression.contains.spreads=函数调用包含传播实参。用法将保持不变。
change.signature.column.name=名称
change.signature.column.name.call.value=调用中的值
change.signature.column.name.default.parameter=默认形参
change.signature.column.name.initializer=初始值设定项
change.signature.column.name.modifier=修饰符
change.signature.column.name.optional.flag=可选
change.signature.column.type=类型
change.signature.conflict.eliminating.parameter.property.breaks.usages=将形参-属性转换为简单的形参将中断 {0} 的字段用法
change.signature.conflict.incompatible.implementation=实现 {0} 的形参个数与重构 {1} 的形参个数不同。重构期间将忽略 {2}。
change.signature.conflict.incompatible.override=重写 {0} 的形参个数与重构 {1} 的形参个数不同。重构期间将忽略 {2}。
change.signature.conflict.readonly.parameter.property.write.usage=将 {0} 变为只读将中断非读取用法
change.signature.dialog.title=更改 {0} 的签名
change.signature.method.references.arguments=函数引用实参，更改签名后代码可能会中断
change.signature.parameter.table.empty.message=使用  '+' 按钮添加新形参
change.signature.tagged.template.issue=无法更新标记的模板调用。用法将保持不变。
change.signature.usage.view.declarations.header=要重构的方法
change.signature.value.column.title=值
changeSignature.vararg.not.last=Rest 形参应当为方法签名中的最后一个形参
checkbox.collapse.array.literals=数组字面量
checkbox.collapse.object.literals=对象字面量
checkbox.collapse.one.line.function.literals=JavaScript 和 TypeScript 中的单行函数
checkbox.collapse.xml.literals=XML 字面量
checkbox.enable=启用
checkbox.move.simple.expressions.to.field.initializer=将简单表达式移至字段初始值设定项
choose.base.component.title=选择超类
choose.class.to.import.title=要导入的类
choose.declaration.element=<html><body>选择 TypeScript 声明</body></html>
choose.destination.scope=选择目标作用域
choose.field.type=选择字段类型
choose.implementing.class=<html><body>选择 <b>{0}</b> 的实现(找到 {1})</body></html>
choose.implementing.method=<html><body>选择 <b>{0}</b> 的实现(找到 {1} 个)</body></html>
choose.overriding.function=<html><body>选择 <b>{0}</b> 的重写函数(找到 {1} 个)</body></html>
choose.overriding.method=<html><body>选择 <b>{0}</b> 的重写方法(找到 {1} 个)</body></html>
choose.subclass=<html><body>选择 <b>{0}</b> 的子类(找到 {1})</body></html>
choose.super.class.title=选择超类
choose.super.classifier=<html><body>选择 <b>{0}</b> 的超类或接口(找到 {1})</body></html>
choose.super.field=<html><body>选择 <b>{0}</b> 的 Super 字段(找到 {1})</body></html>
choose.super.function=<html><body>选择 <b>{0}</b> 的 Super 函数(找到 {1})</body></html>
choose.super.interface.title=选择 Super 接口
choose.super.method=<html><body>选择 <b>{0}</b> 的 Super 方法(找到 {1})</body></html>
class.0.cannot.be.created=无法创建目标类 {0}，因为存在同名的限定元素
class.already.contains.field.warning=类 ''{0}'' 已包含字段 ''{1}''。\n是否继续?
class.already.contains.method.warning=类 ''{0}''已经 {1, choice, 1\# 包含|2\#继承} 方法 ''{2}()''。\n是否继续?
class.chooser.not.available.in.dumb.mode=正在进行索引更新，选择器不可用。
class.does.not.have.inheritors.in.current.project={0} 在当前项目中没有继承者
class.names={0,choice,1\#类|2\#类} {1}
class.template.title=类
class.with.supers.template.title=包含 Super 的类
code.vision.implementations.hint={0, choice, 1\#1 个实现|2\#{0,number} 个实现}
code.vision.inheritors.hint={0, choice, 1\#1 个继承者|2\#{0,number} 个继承者}
code.vision.overrides.hint={0, choice, 1\#1 个重写|2\#{0,number} 个重写}
code.vision.performance.watcher.notification.configure=配置…
code.vision.performance.watcher.notification.disable.code.vision=禁用提示
code.vision.performance.watcher.notification.message=禁用 Code Vision 提示可以通过减少 CPU 负载来提高性能。
code.vision.performance.watcher.notification.title=Code Vision 提示评估缓慢
codestyle.ui.field.prefix=字段前缀 (&F)\:
codestyle.ui.file.name.style=文件命名约定 (&N)\:
codestyle.ui.generated.jsdoc.use.types.checkbox=在 JSDoc 中包括类型 (&T)
codestyle.ui.property.prefix=属性前缀 (&P)\:
collection.queried.but.not.update=查询了集合 <code>\#ref</code> 的内容，但从未写入
collection.updated.but.not.queried=更新了集合 <code>\#ref</code> 的内容，但从未被查询
command.name.add.explicit.value=添加显式值 ''{0}''
command.name.create.javascript.file=创建 JavaScript 文件 {0}
command.name.create.typescript.file=创建 TypeScript 文件 {0}
command.name.extract.named.type=提取已命名类型
command.name.import=导入 {0}
complete.import.binding=完整的导入绑定
complete.import.name=完整的导入名称
configurable.JSCodeCompletionConfigurable.display.name=JavaScript
configurable.JSSmartKeysConfigurable.display.name=JavaScript
configurable.JSTemplateLangConfigurable.display.name=模板
configurable.MyConfigurable.display.name=JSX
configure.code.completion.settings=配置代码补全设置
configure.node.interpreter.path=配置 Node.js 路径…
copying.files=正在复制文件
create.button.text=创建(&C)
create.class.interfaces.label=接口(&I)\:
create.class.name.label=名称(&N)\:
create.class.ok.button.text=创建
create.class.package.label=软件包\:
create.class.superclass.label=超类(&S)\:
create.class.template.label=模板(&T)\:
create.constructor.dialog.title=创建构造函数
create.field.dialog.title=创建字段
create.file.name=创建文件 ''{0}''
create.file.name.with=使用 {1} 创建文件 ''{0}''
create.file.name.with.and=使用 {1} 和 {2} 创建文件 ''{0}''
create.method.dialog.title=创建方法
create.mobile.view=创建视图 ''{0}''
create.react.app.warning.deprecated=不建议使用 <b>create-react-app</b> 创建 React 应用程序。在没有框架的情况下使用 React 时，首选方式是使用带 <a href\="https\://vitejs.dev/guide/\#trying-vite-online">Vite Bundler</a> 的模板。
custom.template.variables=自定义模板变量(&C)\:
custom.variables.step.title.label.text=模板 ''{0}'' 中的自定义变量 (&C)\:
declare.event.0=声明事件 ''{0}''
declare.static=声明 static(&S)
diagram.element.not.found={0} (未找到)
dialog.kind.0.file={0} 文件
dialog.message.cannot.compile.typescript.config.file.incorrect=无法编译 TypeScript。配置文件不正确。
dialog.message.cannot.create.argument.stubs.invoked.method.function=无法创建实参存根\: 调用的方法不是函数
dialog.message.cannot.determine.package.json.directory=无法确定 package.json 目录
dialog.message.cannot.find.file=找不到文件 {0}
dialog.message.cannot.find.module.for.import=无法构建用于导入的模块路径
dialog.message.cannot.find.module.types=找不到模块 @types/{0}
dialog.message.cannot.find.npx.bundled.with=找不到使用 {0} 捆绑的 npx
dialog.message.cannot.infer.type.new.parameter=无法推断新形参的类型
dialog.message.cannot.locate.wrapper.config.file=找不到包装器配置文件
dialog.message.cannot.proceed.when.having.non.read.usages.in.embedded.expressions=嵌入式表达式中有非读取用法时，无法继续
dialog.message.cannot.propagate.variable=无法传播变量\: {0}
dialog.message.cannot.propagate.when.having.usages.declarations.in.different.files=用法和声明位于不同文件中时，无法传播
dialog.message.cannot.transform.object.array.destructuring.patterns.for.same.element=无法为相同的元素转换对象和数组析构模式
dialog.message.command.supported.by={1} 不支持命令 ''{0}''
dialog.message.component.name=组件名称\:
dialog.message.expression.indexed.by.non.numeric.value=表达式使用非数字值编制索引
dialog.message.failed.to.download.0.1=无法下载 {0}。{1}
dialog.message.incomplete.destructuring.pattern.encountered.in.code=在代码中遇到不完整的析构模式
dialog.message.incorrect.path.to.typescript.package=typescript 软件包的路径不正确
dialog.message.invalid.npm.package=无效的 {0} 软件包\: 无此类文件或目录
dialog.message.invalid.npx.command=无效的 npx 命令
dialog.message.invalid.package.file.specified.but.directory.with.package.json.expected={0} 软件包无效\: 指定了一个文件，但应为包含 package.json 的目录
dialog.message.invalid.package.no.such.directory=无效的 {0} 软件包\: 无此类目录
dialog.message.no.npm.script=无 ''{0}'' npm 脚本
dialog.message.no.path.to.package.json.found=未找到 package.json 的路径。
dialog.message.no.results.for.after={1} 之后没有 {0} 的结果
dialog.message.no.such=没有这样的 {0}
dialog.message.node.interpreter.is.located.in.another.wsl.distribution=Node.js 运行时位于与指定项目路径不同的 WSL 发行版中。
dialog.message.node.interpreter.must.be.located.in.wsl=Node.js 运行时必须位于 WSL 中，并具有指定的项目路径。
dialog.message.node.interpreter.unspecified.error.text=请指定 Node.js 运行时
dialog.message.package.yarn.installed.package.format.yarn.relative.path.to.package.json.package.name={0}软件包\: Yarn 安装的软件包格式为 ''yarn\:[package.json 的相对路径]\:[软件包名称]''。
dialog.message.please.select.distribution=请选择发行版
dialog.message.please.specify.npm.scripts.to.run=请指定要运行的 npm 脚本
dialog.message.please.specify.package.json=请指定 package.json
dialog.message.please.specify.package.json.correctly=请正确指定 package.json
dialog.message.please.specify.wsl.path.to.node.js.interpreter=请指定 WSL 中安装的 Node.js 运行时的路径
dialog.message.some.usages.cannot.be.updated.properly=有些用法无法正常更新。\n导入和导出中的用法、字符串用法或动态引用无法替换为析构。
dialog.message.some.usages.cannot.be.updated.properly.wrong.access=有些用法无法正常更新。\n无法替换不按名称访问属性的用法或者不按索引访问元素的用法。
dialog.message.transforming.multiple.nested.patterns.not.supported=数组析构不支持转换多个嵌套模式
dialog.message.unspecified=未指定的 {0}
dialog.message.unspecified.package=未指定 {0} 软件包
dialog.message.unspecified.package.name=未指定软件包名称。
dialog.message.unspecified.suite.name=未指定的套件名称
dialog.message.unspecified.test.name=未指定的测试名称
dialog.message.unsupported.destructuring.container=不支持的析构容器\: {0}
dialog.message.usages.search.was.interrupted=用法搜索被中断
dialog.message.variables.from.destructuring.pattern.have.no.usages=来自于析构模式的变量没有用法
dialog.message.write.usages.cannot.be.updated.with.destructuring=写入用法无法通过重构进行更新
dialog.title.cannot.convert=无法转换
dialog.title.cannot.introduce.new.interface=无法引入新接口
dialog.title.cannot.propagate=无法传播
dialog.title.configure.coding.assistance.for.node.js.api=配置 Node.js API 编码辅助
dialog.title.download.error=下载错误
dialog.title.edit.run.debug.configuration=编辑运行/调试配置\: ''{0}''
dialog.title.grunt.settings=Grunt 设置
dialog.title.gulp.settings=Gulp 设置
dialog.title.missing.dependencies=缺少依赖项
dialog.title.move.members=移动成员
dialog.title.new.javascript.file=新建 JavaScript 文件
dialog.title.new.typescript.file=新建 TypeScript 文件
dialog.title.select.navigation.target=选择导航目标
dialog.title.select.parameters.to.convert.to.parameter.properties=选择要转换为形参-属性的形参
dialog.title.select.targets.to.convert.to.class=选择要转换为类的目标
dialog.title.wsl.node.interpreter={0} WSL Node 运行时
dialog.title.wsl.node.interpreter.edit=编辑
dialog.title.wsl.node.interpreter.edit.add=添加
directory.already.contains.file=目录 ''{0}'' 已包含文件 ''{1}''
duplicate.parameter.name=重复的形参名称\: {0}
editor.notification.label.enable.babel.file.watcher.question=是否启用 File Watcher 以使用 Babel 将 ECMAScript 6 转换为 ECMAScript 5?
element.name.anonymous=<匿名>
element.name.default=<默认>
entity.in.parent.description={0} ({1} 内)
env.variable.empty={0} 为空
env.variable.undefined={0} 未定义
environment.key.description.package_json.install.dependencies=指示 IDE 是否应安装项目文件中发现的 'package.json' 的依赖项。\n值为 'true' 或 'false'
error.not.available.in.javascript.code={0} 在 JavaScript 代码中不可用
error.wrong.caret.position.method.name=文本光标应置于要重构的方法的名称处。
es6.auto.import.options.completion.add.imports=自动添加 JavaScript import
es6.auto.import.options.title=TypeScript / JavaScript
es6.change.to.default.fix=对 ''{0}'' 使用默认导入
es6.change.to.named.import.fix=对 ''{0}'' 使用命名导入
es6.changeSignature.call.value.not.allowed=形参 ''{0}'' 不允许使用调用中的值。因为没有为前面的形参指定它。
es6.changeSignature.no.call.value=新形参 ''{0}'' 已添加。\n指定要用于此方法的所有现有调用的默认值或值。
es6.code.style.path.mapping.always=始终
es6.code.style.path.mapping.different.paths=仅在指定路径以外的文件中
es6.code.style.path.mapping.never=从不
es6.default.export.not.declared=未在导入的模块中声明默认导出
es6.extract.super.destination.label=目标文件 (&D)\:
es6.extract.super.different.name.expected=应为不同名称
es6.extract.super.members.in.interface=新接口中的成员
es6.extract.super.members.in.superclass=新超类中的成员
es6.extract.super.overload.declaration.without.implementation.conflict=类中不允许没有实现的重载声明 {0}
es6.import.options.blacklist.title=不从指定路径或路径模式导入\:
es6.import.options.exts.help=此选项用于配置 import 语句中的扩展名。<br><br>选择“自动”时，IDE 会向 vue 文件、来自在 package.json 中具有 "type"\: "module" 的项目的文件，以及扩展名为 .mjs 或 .cjs 的文件的名称添加扩展名。<br><br>选择“始终”时，IDE 会始终向文件名添加扩展名。<br><br>选择“从不”时，IDE 会始终使用不带扩展名的文件名。
es6.import.options.not.import.help=此选项会配置 IDE 在自动导入符号期间跳过的确切路径。相反，IDE 将寻找替代路径来导入符号。路径应符合 glob 模式规则。
es6.import.options.paths=使用路径别名\:
es6.import.options.paths.help=此选项用于配置 import 语句中使用的路径样式。<br><br>选择“始终”时，IDE 会始终使用来自 webpack、vite 或 jsconfig.json 配置的别名。<br><br>选择“仅在指定路径之外的文件中”时，IDE 会针对为之定义了别名的文件之间的导入使用相对路径。在所有其他文件中，使用路径映射。<br><br>选择“从不”时，则从不使用别名。
es6.insert.await.fix=插入 await
es6.missing.await.report.for.promises=报告 return 语句中的 promise
es6.missing.await.report.for.promises.hint=在异步函数调用前插入 'await' 有助于 V8 提供异步堆栈跟踪
es6.move.module.members.cannot.detect.js.language=目标文件不是 JS 文件
es6.move.module.members.destination.contains.default.export=目标模块包含默认导出
es6.move.module.members.destination.does.not.support.jsx={0} 包含 JSX 标签，但目标语言不支持这些标签
es6.move.module.members.destination.not.es6=目标文件 {0} 不是 ES6 模块
es6.move.module.members.has.local.usage.message=文件 {1} 中使用未导出的 {0}
es6.move.module.members.incompatible.language=目标模块具有不兼容的语言
es6.move.module.members.non.es6.module.usage=在非 ES6 模块的文件 {1} 中使用 {0}
es6.move.module.members.refactoring.create.file=创建文件
es6.move.module.members.refactoring.create.file.message=文件 {0} 不存在。\n是否要创建?
es6.move.module.members.refactoring.dialog.error.incorrect.module=目标模块不正确
es6.move.module.members.refactoring.dialog.error.invalid.file.name=目标文件名在此操作系统中无效
es6.move.module.members.refactoring.dialog.error.modules.same=源模块和目标模块应不同
es6.move.module.members.refactoring.dialog.error.no.script.tag=目标文件不包含脚本标签
es6.move.module.members.refactoring.dialog.error.no.selected.items=没有要移动的选定成员
es6.move.module.members.refactoring.dialog.field.from=从\:
es6.move.module.members.refactoring.dialog.field.to=到\:
es6.move.module.members.refactoring.dialog.move.member.to=成员移动至
es6.move.module.members.refactoring.file.does.not.exist=文件 {0} 不存在
es6.move.module.members.refactoring.name=移动模块成员
es6.move.module.members.references.local.message=选择的 {0} 引用非导出 {1}
es6.move.module.members.references.unresolved.import.message=选择的 {0} 引用未解析导入 {1}
es6.move.module.members.syntax.errors=移动 {0} 将引入语法错误，因为目标语言不同于源语言
es6.move.module.members.table.title=要移动的成员
es6.prefer.short.import.name=可以缩短导入
es6.redundant.await.report.for.promises=报告 promise
es6.redundant.await.report.for.promises.hint=总是报告 'return await' 为冗余，但这会破坏 V8 的异步堆栈跟踪功能
es6.replace.import.action.name=替换为 {0}
es6.replace.import.family.name=替换为较短的路径
es6.validate.import.error=无法解析符号 ''{0}''
es6.validation.message.const.variable.without.initializer=不允许使用无初始值设定项的 'const' 变量
escape.jsdoc.copy.pasted.text=在复制和粘贴时转义 JSDoc 前导星号
escape.pasted.text=在粘贴字符串字面量时转义文本
eslint.action.fix.problems.description=通过调用 'eslint --fix' 修正 ESLint 问题
eslint.additional.rules.directory.field.name=其他规则目录
eslint.code.style.apply.message=应用 ESLint 的代码样式?
eslint.code.style.apply.text=是
eslint.code.style.dismiss.text=否
eslint.configurable.additionalRulesDir.browseDialogTitle=选择 ESLint 其他规则目录
eslint.configurable.additionalRulesDir.label=其他规则目录 (&R)\:
eslint.configurable.config.autoSearch.description.bodyInnerHtml=ESLint 将在要 lint 的文件的目录中以及连续的父目录中查找 .eslintrc.* 和 package.json 文件，直至查找到文件系统的根目录。<div style\="padding-top\:8px">要使用 package.json，请将您的配置添加到 <code>eslintConfig</code> 属性下。</div>
eslint.configurable.config.select.config.text=选择 ESLint 配置文件(*.eslintrc.*)
eslint.configurable.eslintPackage.label=ESLint 软件包(&E)\:
eslint.configurable.extraOptions.label=额外 eslint 选项 (&O)\:
eslint.configurable.label.working.directories=工作目录(&W)\:
eslint.configurable.working.dir.field.empty.text=由最近的 .eslintrc 或 .eslintignore 检出
eslint.configurable.working.directories.comment=路径或 <a href\='https\://github.com/isaacs/node-glob\#glob-primer'>glob 模式</a>，以分号分隔。为自动检测留空。
eslint.configuration.file.field.name=ESLint 配置文件
eslint.error.package.directory.expected=应为软件包目录
eslint.files.pattern.comment=使用 <a href\=''https\://github.com/isaacs/node-glob\#glob-primer''>glob 模式</a>，例如 <code>**/*.{js,ts}</code>
eslint.fix.problems.family.name={0}\: 修复当前错误
eslint.fix.problems.text.current={0}\: 修复当前错误
eslint.fix.problems.text.with.error.code={0}\: 修复 ''{1}''
eslint.inspections.error.can.not.parse.message=无法解析消息，应为 JSON 对象，但实际为\: {0}
eslint.inspections.error.messages.not.array=消息不是数组\: {0}
eslint.inspections.error.unexpected.language.service.response=意外的语言服务响应\: {0}
eslint.inspections.error.unknown.message.severity=未知的消息严重性\: {0}\n主体\:\n{1}
eslint.run.for.files.label=为文件运行(&F)\:
eslint.run.on.save=保存时运行 eslint --fix(&U)
eslint.run.on.save.auto.configuration.comment=自动 ESLint 配置
eslint.run.on.save.checkbox.on.actions.on.save.page=运行 eslint --fix
eslint.run.on.save.disabled.comment=已禁用 ESLint 集成
eslint.run.on.save.link.enable.eslint=启用 ESLint…
eslint.run.on.save.manual.configuration.comment=手动 ESLint 配置
eslint.version.0.is.not.supported.please.upgrade.eslint=ESLint 版本 {0} 不受支持。请升级 ESLint。
extract.0.turn.refs=提取 {0} 并尽量使用 (&T)
extract.constant.type=类型(&T)\:
extract.function.declare.arrow.function=&箭头函数
extract.function.function=函数
extract.function.name=名称(&N)\:
extract.function.parameters=形参
extract.function.return.type=返回值类型(&T)\:
extract.function.signature.preview=签名预览
extract.interface.command.name=提取接口
extract.method.declare.static=声明 static(&S)
extract.subclass.command.name=从 {1} 提取子类 {0}
extract.type.alias.command.name=提取类型别名
failed.to.download=无法下载
fetch.client.generator.title=JavaScript Fetch
field.initializer.is.not.specified=未指定字段初始值设定项
file.name.masks.to.skip.from.analysis=要在分析中排除的文件名掩码\:
filetype.actionscript.description=ActionScript
filetype.js.testing.snapshot.description=JavaScript 测试快照(Jest)
filetype.js.testing.snapshot.display.name=JavaScript 测试快照
filetype.jshint.config.description=JSHint 配置
filetype.jshint.config.display.name=JSHint 配置
filetype.yarn.lock.description=Yarn lock
filetype.yarn.lock.display.name=Yarn Lock
find.usages.of.base.class={1} 的方法 {0}\n重写 {2} 的方法。\n要{3}基方法吗?
find.usages.of.base.interface={1} 的方法 {0}\n实现 {2} 的方法。\n要{3}基方法吗?
flow.js.get.type=Flow JS\:Get 类型
flow.js.show.settings=配置 Flow…
flow.js.version.not.supported=Flow JS 版本 {0} 不受支持
flow.js.widget.display.name=Flow JS
flow.js.widget.name=Flow
function.names={1}{0,choice,1\#函数|2\#函数} 
function.returns=函数返回值类型
function.returns.description=函数返回值类型
generate.constructor.overloads.and.fields.chooser.title=选择要使用的重载和要初始化的字段
generate.delegate.method.conflict.message=无法通过不同的属性为同名成员生成委托
generate.delegate.method.conflict.message.title=无法生成委托
generate.filter.button.description=在列表中显示 {0} 
generate.filter.button.tooltip=显示 {0}
generate.filter.fields=字段和属性
generate.filter.indexers=索引器
generate.filter.methods=方法
generate.to.string.chooser.title=选择要在 toString 函数中使用的字段
generating.0=正在生成 {0}
generating.errors.cannot.generate=无法生成 {0}
generating.errors.in.console=查看控制台中的错误(退出代码 {0}})
generating.installing.deps=正在安装依赖项…
generating.new.project=新建项目
generating.template.processing=模板处理
generating.with.tips=生成带有入门提示的 Playground 项目
generating.with.tips.comment=基于 Vite 的计数器项目
generation.bindable.event=可绑定事件(&B)\:
generation.event.constant=事件常量(&E)\:
group.Editor.JSLibrariesMenu.description=选择要与当前文件一起使用的 JavaScript 库
group.Editor.JSLibrariesMenu.text=使用 JavaScript 库
group.Floating.CodeToolbar.JS.Refactor.text=重构
group.Floating.CodeToolbar.JS.text=浮动代码工具栏 Web
grunt.before.run.task=运行 Grunt 任务
grunt.before.run.task.descr=运行 Grunt {0, choice, 0\#任务|1\#任务 |2\#任务 }{1} [{2}]
grunt.gruntfile.not.found=未找到 Gruntfile
grunt.rc.arguments.label=实参(&R)\:
grunt.rc.environmentVariables.label=环境(&E)\:
grunt.rc.gruntCliPackage.label=软件包 grunt-cli (&P)\:
grunt.rc.gruntfile.browseDialogTitle=选择 Gruntfile
grunt.rc.gruntfile.label=Gruntfile (&F)\:
grunt.rc.nodeOptions.label=Node 选项(&O)\:
grunt.rc.tasks.label=任务(&T)\:
grunt.task.title=Grunt 任务
grunt.unspecified.gruntfile=未指定 Gruntfile
gulp.before.run.task=运行 gulp 任务
gulp.before.run.task.descr=运行 gulp {0, choice, 0\#任务|1\#任务 |2\#任务 }{1} [{2}]
gulp.gulpfile.not.found=未找到 Gulpfile
gulp.gulpfile.unspecified=未指定 Gulpfile
gulp.rc.arguments.label=实参(&R)\:
gulp.rc.environmentVariables.label=环境(&E)\:
gulp.rc.gulpPackage.label=Gulp 软件包(&G)\:
gulp.rc.gulpfile.browseDialogTitle=选择 gulpfile.js
gulp.rc.gulpfile.label=Gulpfile (&F)\:
gulp.rc.nodeOptions.label=Node 选项(&O)\:
gulp.rc.tasks.label=任务(&T)\:
gulp.task.title=Gulp 任务
header.declarations.to.be.refactored=要重构的声明
icon.icons.nodes.readonlyMark.tooltip=只读
ignore.unused.option.all=所有
ignore.unused.option.before.used=使用前
ignore.unused.option.none=无
implement.members.abstract=实现 abstract 成员
import.options.find.more.configuration.options=在<a>代码样式</a>中查找更多配置选项
initialize.fields.intention.visibility=可见性\:
inlay.hints.max.one.usage.text={0,choice, 0\#无用法|1\#显示用法}
inlay.hints.usages.text={0,choice, 0\#无用法|1\#1 个用法|2\#{0,number}'{1,choice, |1\#+}' 用法}
inlay.parameters.angular.show.names.for.all.args=Angular HTML 模板中的命名对象形参。<p style\="padding-left\: 5px; padding-top\: 5px; font-size\: 0.85em">注意\: 启用 TypeScript 服务后，请改用 "TypeScript" 组。</p>
inlay.parameters.angular.show.names.for.literal.args=Angular HTML 模板中的字面量形参。<p style\="padding-left\: 5px; padding-top\: 5px; font-size\: 0.85em">注意\: 启用 TypeScript 服务后，请改用 "TypeScript" 组。</p>
inlay.parameters.angular.show.names.for.pipes=<a href\='https\://angular.io/guide/pipes'>Angular HTML 模板中的管道。</a> <p style\="padding-left\: 5px; padding-top\: 5px; font-size\: 0.85em">注意\: 启用 TypeScript 服务后，请改用 "TypeScript" 组。</p>
inlay.parameters.js.only.show.names.for.all.args=非字面量实参，例如引用和表达式。
inlay.parameters.js.only.show.names.for.literal.args=字面量实参，例如基元、对象和数组初始值设定项。
inlay.parameters.js.only.show.names.for.pipes=<a href\='https\://github.com/tc39/proposal-pipeline-operator'>管道运算符中的形参。</a>
inlay.parameters.js.only.show.names.for.tagged=<a href\='https\://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals\#tagged_templates'>标记模板中的实参<a>。
inlay.parameters.js.param.hints.show.names.for.all.args=非字面量实参，例如引用和表达式。
inlay.parameters.js.param.hints.show.names.for.tagged=标记模板中的实参。
inlay.parameters.ts.param.hints.show.names.for.literal.args=字面量实参，例如基元、对象和数组初始值设定项。<p style\="padding-left\: 5px; padding-top\: 5px; font-size\: 0.85em">注意\: 从 TypeScript v4.4 开始，启用“非字面量实参”时，禁用此选项没有任何效果。</p>
inlay.parameters.vuejs.show.names.for.all.args=非字面量实参。
inlay.parameters.vuejs.show.names.for.filters=<a href\='https\://v2.vuejs.org/v2/guide/filters.html'>筛选器(Vue 2)。</a>
inlay.parameters.vuejs.show.names.for.literal.args=字面量实参。
inline.cannot.inline.has.supers=无法内联扩展其他类型的 {0} 
inline.cannot.inline.references.this.type=无法内联引用 'this' 类型的接口
inline.type.used.in.reference.list=无法在''{0}'' 列表中内联用法
insert.class.fix.name=添加类名限定符
insert.new.keyword.fix.name=插入新关键字
insert.this.keyword.fix.name=添加 this 限定符
inspection.NodeCoreCodingAssistanceInspection.no.coding.assistance.message=Node.js 的编码辅助已被禁用
inspection.message.installed.version.doesn.t.match.version.range=安装的版本 {0} 与版本范围 {1} 不匹配
inspection.message.package.installed=未安装 {0} 软件包
inspection.message.package.version.specified=未指定软件包版本
inspection.message.reference.includes.files.outside.project=引用包括项目范围之外的文件
inspection.message.sm.test.runner.magnitude.assertion.failed.title=断言失败
inspection.update.package_json.dependency.action.text=将 ''{0}'' 更新到最新版本 {1}
inspection.update.package_json.dependency.message=有可用的 ''{0}'' 新版本\: {1}
intellilang.tagged.literal.expression.border.title=模板标签
intellilang.tagged.literal.injection.name.label=模式\:
intention.category.ecmascript6=JavaScript/ECMAScript 6
intention.category.javascript=JavaScript
intention.category.react=React
intention.category.typescript=TypeScript
intention.family.name.add.required.property=添加所需的属性
intention.family.name.enable.web.types=启用 HTMX 支持
intention.family.name.introduce.parameter.properties.for.unused.parameters=转换为形参属性
intention.family.name.run.npm.install=运行 'npm install'
intention.family.name.select.in.test.tree=在测试树中选择
intention.family.name.suppress.with.ts.ignore=使用 @ts-ignore 禁止
intention.family.name.surround.with.tag=使用标记包围
intention.name.add.file.to.tsconfig=将文件 ''{0}'' 添加到 tsconfig.json
intention.name.create.library.with.files.outside.project=使用项目外部的文件创建库
intention.name.import.augmentation=导入扩大 {0}
intention.name.loading.service.fixes=正在加载服务修正…
intention.name.navigate.to=导航到 {0}
intention.name.run.npm=运行 ''{0}''
intention.name.surround.with.tag=使用 <{0}> 包围
interface.cannot.be.extracted.from.enum=无法从枚举中提取接口
interface.cannot.be.extracted.from.type.alias=无法从类型别名中提取接口
interface.template.title=接口
introduce.constant.target.class=目标类(&A)\:
introduce.field.class.constructor=类构造函数(&C)
introduce.field.current.method=当前方法(&M)
introduce.field.declaration=字段声明(&D)
introduce.field.initialize.in=初始化位置
introduce.field.type=类型(&T)\:
introduce.parameter.optional=可选形参(&O)
introduce.parameter.type=类型(&T)\:
introduce.variable.const=const(&C)
introduce.variable.declaration=变量声明
introduce.variable.let=let(&L)
introduce.variable.make.constant=设为常量(&C)
introduce.variable.var=var(&V)
introduce.variable.var.of.type=类型的变量(&T)\:
invalid.field.type.expression=无效字段类型\: ''{0}''
invalid.identifier.value.0=无效标识符\: ''{0}''
invalid.parameter.type.expression=形参类型 ''{0}'' 无效
invalid.return.type.expression=返回值类型 ''{0}'' 无效
item.already.exists={0} {1} 已存在
javascript.abstract.class.can.not.be.instantiated.message=无法实例化抽象类
javascript.ambient.declaration.const.should.be.primitive=环境上下文中的 'const' 初始值设定项必须是基元字面量或字面量枚举引用
javascript.ambient.declaration.should.have.no.initializer=环境声明不应有初始值设定项
javascript.argument.type.mismatch=实参类型 {1} 不可分配给形参类型 {0}
javascript.argument.types.mismatch=实参类型与形参不匹配
javascript.assign.parameter.to.field.intention.name=分配形参 ''{0}'' 给字段
javascript.assigned.expression.type.mismatch=分配的表达式类型 {1} 不可分配给类型 {0}
javascript.assume.uppercase.functions.to.be.constructors=假设只有大写的函数是构造函数
javascript.auto.import.options.add.imports.on.the.fly=动态明确 import
javascript.auto.import.options.add.on.code.completion=代码补全时
javascript.auto.import.options.show.popup=包含自动导入工具提示
javascript.cannot.return.expression.from.function.with.void.result.type=无法从结果类型为 void 的函数返回值
javascript.cannot.return.expression.from.function.with.void.result.type.fix=移除返回值
javascript.change.jsdoc.type.family.name=更改 JSDoc 中元素的类型
javascript.change.language.level.family=更改 JavaScript 语言版本
javascript.change.language.level.message=更改 JavaScript 语言版本为 {0}
javascript.change.signature.invalid.function.name.0=无效函数名称\: ''{0}''
javascript.change.signature.invalid.parameter.declaration=无效形参\: ''{0}''
javascript.changeSignature.call.value.not.allowed=形参 ''{0}'' 不允许使用默认值。因为没有为前面的形参指定它。
javascript.changeSignature.no.call.value=新的必选形参 ''{0}'' 已添加。\n指定要用于此方法的所有现有调用的默认值。
javascript.check.global.definitions=检查全局作用域内的赋值
javascript.completion.several.definitions=(多个定义)
javascript.constructor.call.without.new.message=不带 <code>new</code> 的构造函数调用
javascript.constructor.with.lower.case.name.used.message=构造函数名称通常以大写字母开头。拼写错误?
javascript.create.class.intention.name=创建类 ''{0}''
javascript.create.constant.field.intention.name=创建常量字段 ''{0}''
javascript.create.constant.holding.arrow.function.intention.name=创建含有常量 ''{0}'' 的箭头函数
javascript.create.constant.intention.name=创建常量 ''{0}''
javascript.create.constructor.intention.name=在 ''{0}'' 类中创建构造函数
javascript.create.event.handler.intention.name=创建事件处理程序 ''{0}''
javascript.create.field.holding.arrow.function.intention.name=创建含有字段 ''{0}'' 的箭头函数
javascript.create.field.intention.name=创建字段 ''{0}''
javascript.create.function.intention.family=创建 JavaScript 函数或方法
javascript.create.function.intention.name=创建函数 ''{0}''
javascript.create.function.property.intention.name=创建函数属性 ''{0}''
javascript.create.get.property.intention.name=创建 ''get'' 属性 ''{0}''
javascript.create.interface.intention.name=创建接口 ''{0}''
javascript.create.method.intention.name=创建方法 ''{0}''
javascript.create.property.holding.arrow.function.intention.name=创建含有属性 ''{0}'' 的箭头函数
javascript.create.property.intention.name=创建属性 ''{0}''
javascript.create.set.property.intention.name=创建 ''set'' 属性 ''{0}''
javascript.create.variable.holding.arrow.function.intention.name=创建含有变量 ''{0}'' 的箭头函数
javascript.create.variable.intention.family=创建 JavaScript 变量或属性
javascript.create.variable.intention.name=创建变量 ''{0}''
javascript.declare.variable.in.previous.var.statement.intention.family=将 var 声明插入之前的 var 语句
javascript.declare.variable.in.previous.var.statement.intention.name=将 ''{0}'' 的 var 声明插入之前的 var 语句
javascript.declare.variable.intention.family.name=插入 var 声明
javascript.declare.variable.intention.name=为 ''{1}'' 插入 {0} 声明
javascript.deprecated.symbol.replace.fix=将弃用的代码替换为 {0}
javascript.deprecated.symbol.replace.fix.family=将弃用的代码替换为建议的替换
javascript.deprecated.symbol.used.name.message=使用了弃用的符号，请查阅文档，以获取更好的替代性 \#loc
javascript.deprecated.symbol.used.name.message2=自版本 {0} 符号被标记为弃用以来，使用 {1} 作为替换用 \#loc
javascript.destructuring.initializer=初始值设定项 {0}
javascript.destructuring.variable.only=仅析构变量
javascript.element.default.instead.named=使用了默认导入而不是命名导入
javascript.element.is.not.accessible.message=元素不可访问 \#loc
javascript.element.need.to.be.exported=未导出元素
javascript.element.need.to.be.imported=未导入元素
javascript.element.need.to.be.included.to.config=tsconfig.json 中不包含相应文件
javascript.equality.comparison.with.coercion.display.name=相等运算符可能导致类型强制
javascript.equality.comparison.with.coercion.error.string=比较 \#ref 可能导致意外类型强制 \#loc
javascript.equality.comparison.with.coercion.family.name=替换但不进行类型强制
javascript.equality.comparison.with.coercion.fix=替换为 ''{0}''
javascript.equality.comparison.with.coercion.option.always=所有
javascript.equality.comparison.with.coercion.option.always.except.null=与 null 或 typeof 比较时除外
javascript.equality.comparison.with.coercion.option.only.suspicious=仅可疑表达式
javascript.equality.comparison.with.coercion.options.label=高亮显示 '\=\=' 和 '\!\=' 的用法\:
javascript.expected.class.or.descendant=应为类 {0} 或后代
javascript.export.only.member=元素仅导出
javascript.expression.type.implicitly.coerced.to.unrelated.type=表达式类型 {1} 隐式强制为不相关类型 {0}
javascript.extract.method.title=提取函数
javascript.falsy.typeof.guard=''typeof'' 检查始终为 false\: {0}'' 始终具有类型 ''{1}''
javascript.find.usages.destructuring.target.dialog=速记析构变量使用 {0} 初始化。\n您想查找哪些用法?
javascript.fix.add.enum.values=添加枚举值
javascript.fix.add.override.modifier=添加重写修饰符
javascript.fix.add.string.enum.values=添加字符串枚举值
javascript.fix.change.parameter.type=形参 ''{0}'' 类型更改为 ''{1}''
javascript.fix.change.type=''{0}'' 类型更改为 ''{1}''
javascript.fix.create.constructor.invoke.super=创建匹配 super 的构造函数
javascript.fix.create.extends=使 ''{0}'' 扩展 ''{1}''
javascript.fix.create.implements=使 ''{0}'' 实现 ''{1}''
javascript.fix.create.inheritor.family=从 super 类型继承
javascript.fix.create.invoke.super=插入超类构造函数调用
javascript.fix.create.parameter=创建形参 ''{0}''
javascript.fix.generate.argument.stubs=生成实参存根
javascript.fix.implement=实现 {0}
javascript.fix.implement.chooser.all=所有类
javascript.fix.implement.chooser.title=从中实现成员
javascript.fix.implement.family=在派生类中实现
javascript.fix.implement.members=实现成员
javascript.fix.implement.methods=实现方法
javascript.fix.initialize.parameter=初始化形参
javascript.fix.message.change.parameters.to.expected=将这些形参更改为预期形参
javascript.fix.message.change.return.type.to.expected=将返回值类型更改为预期类型
javascript.fix.optimize.imports=优化 import
javascript.fix.property.spelling.family=修复属性名称中可能的拼写错误
javascript.fix.property.spelling.text=将拼写调整为 ''{0}''
javascript.fix.remove.abstract.keyword=移除 'abstract' 修饰符
javascript.fix.remove.access.modifier=移除访问修饰符
javascript.fix.remove.circular.dependency=移除循环依赖关系
javascript.fix.remove.comma=移除逗号
javascript.fix.remove.constructor=移除构造函数
javascript.fix.remove.default=移除默认子句
javascript.fix.remove.dynamic.modifier=移除动态修饰符
javascript.fix.remove.externally.visible.symbol=移除外部可见符号
javascript.fix.remove.final.modifier=移除 final 修饰符
javascript.fix.remove.initializer=移除初始值设定项
javascript.fix.remove.modifier=移除修饰符
javascript.fix.remove.namespace.reference=移除命名空间引用
javascript.fix.remove.override.modifier=移除重写修饰符
javascript.fix.remove.parameter=移除形参
javascript.fix.remove.parameters=移除形参
javascript.fix.remove.setter.parameter.initializer=移除形参默认值
javascript.fix.remove.static.modifier=移除 static 修饰符
javascript.fix.remove.type.reference=移除类型引用
javascript.fix.remove.virtual.modifier=移除虚拟修饰符
javascript.fix.remove.visibility.modifier=移除可见性修饰符
javascript.fix.set.element.visibility=将 {0} 设为 {1}
javascript.fix.set.method.return.type=使 ''{0}'' 返回 ''{1}''
javascript.fix.visibility.family=修复可见性问题
javascript.formatting.options.panel.comments=注释
javascript.formatting.options.panel.naming.conventions=命名约定
javascript.formatting.web.spacing.within.group=内部
javascript.formatting.web.spacing.within.interpolations=插值
javascript.formatting.web.wrapping.interpolations=插值
javascript.formatting.web.wrapping.new-line-after-start-delimiter=在 '{{' 后换行
javascript.formatting.web.wrapping.new-line-before-end-delimiter='}}' 前新起一行
javascript.ignore.unused.catch.parameters=忽略未使用的 catch 形参
javascript.ignore.unused.function.parameters=忽略未使用的形参\:
javascript.illegal.variable.type.void=非法变量类型\: 'void'
javascript.implement.all.interfaces=实现所有成员
javascript.implement.members.abstract=实现 abstract 成员
javascript.implement.required.interfaces=实现所需的所有成员
javascript.import.options.use.resource.root=使用相对于项目、资源或源根目录的路径
javascript.incorrect.array.type.in.for-in=数组键类型应为字符串
javascript.incorrect.variable.type.mismatch=变量类型 {1} 不可分配给类型 {0}
javascript.indexed.property.instead.of.computed.name=索引属性访问中括号位于单独的行中。是否应为计算的名称?
javascript.initializer.type.mismatch=初始值设定项类型 {1} 不可分配给变量类型 {0}
javascript.inline.element.is.not.used={0} 从未使用
javascript.insert.cast.fix=插入转换
javascript.insert.generic.wrapper.fix.family.name=使用泛型类型包装
javascript.insert.primitive.wrapper.fix.family.name=使用基元类型包装
javascript.insert.symbol.fix=插入{0}
javascript.insert.wrapper.fix.text=使用 ''{0}'' 包装
javascript.instance.member.is.not.accessible.message=实例成员不可访问 \#loc
javascript.intention.add.default.export.family.name=添加默认导出
javascript.intention.add.export.family.name=添加导出
javascript.intention.add.export.fix.text=将 {0} 导出在文件 {1} 中
javascript.intention.add.template.argument=插入模板字符串实参
javascript.intention.call.chain.to.pipe=将嵌套调用替换为管道表达式
javascript.intention.code.optimizations.text=正在优化生成的代码
javascript.intention.create.getter=为 ''{0}'' 创建 getter
javascript.intention.create.getter.desc=创建 getter
javascript.intention.create.getter.setter=为 ''{0}'' 创建 getter 和 setter
javascript.intention.create.getter.setter.desc=创建 getter 和 setter
javascript.intention.create.setter=为 ''{0}'' 创建 setter
javascript.intention.create.setter.desc=创建 setter
javascript.intention.expand.nullish.coalescing=展开 null 合并
javascript.intention.expand.opt.chain=展开可选链接
javascript.intention.expand.opt.chain.and.nullish.coalescing=展开可选链接和 null 合并
javascript.intention.expand.opt.chain.and.or.coalescing=展开可选链接并使用 ?\: 运算符
javascript.intention.expand.opt.chain.family=将可选链接或 null 合并扩展到显式检查
javascript.intention.expand.or.coalescing=使用 ?\: 运算符
javascript.intention.explicit.fields=声明显式类字段
javascript.intention.explicit.fields.dialog.title=选择要显式声明的字段
javascript.intention.explicit.fields.single=声明显式类字段
javascript.intention.init.fields=从形参初始化新字段
javascript.intention.init.fields.dialog.title=选择形参以初始化字段
javascript.intention.opt.chain.chain.and.coalesce=使用可选链接和 null 合并
javascript.intention.opt.chain.chain.only=使用可选链接
javascript.intention.opt.chain.coalesce.only=使用 null 合并
javascript.intention.opt.chain.conditional.only=使用 '||'
javascript.intention.opt.chain.family=使用可选链接或 null 合并
javascript.intention.pipe.to.call.chain=将管道表达式替换为嵌套调用
javascript.intention.promise.to.async.name=转换为异步函数
javascript.intention.remove.export.family.name=移除导出
javascript.intention.remove.export.inaccessible.conflict.text={0} 在 {1} 中进行了使用
javascript.interface.can.not.be.instantiated.message=无法实例化接口
javascript.introduce.breaks.operator.precedence=无法调用重构。\n通过引入将更改表达式中的运算符优先级。
javascript.introduce.constant.error.expression.has.void.type=无法引入常量。\n选定的表达式类型无效。
javascript.introduce.constant.error.no.expression.selected=无法引入常量。\n选定内容不构成表达式。
javascript.introduce.constant.error.not.constant.expression.selected=无法引入常量。\n选定内容不是常量表达式。
javascript.introduce.constant.in.es5=无法调用重构。\n无法在 ECMAScript 3 或 ECMAScript 5 代码中引入常量。
javascript.introduce.constant.title=引入常量
javascript.introduce.element.already.exists=作用域中已存在同名的 {0}。
javascript.introduce.field.before.super.call=无法引入字段。\n在"super"调用前无法访问"this"。
javascript.introduce.field.constructor=构造函数
javascript.introduce.field.current.method=当前方法
javascript.introduce.field.error.expression.has.void.type=无法引入变量。\n选定的表达式类型无效。
javascript.introduce.field.error.no.enclosing.class=无法引入字段。\n没有封闭类。
javascript.introduce.field.error.no.expression.selected=无法引入字段。\n选定内容不构成表达式。
javascript.introduce.field.field.declaration=字段声明
javascript.introduce.field.initialize.in.scope=初始化位置(&I)\:
javascript.introduce.field.keyboard.hint=按 {0} 用于键盘快捷键
javascript.introduce.field.make.readonly=设为只读(&R)
javascript.introduce.field.title=引入字段
javascript.introduce.field.visibility=可见性(&V)\:
javascript.introduce.in.embedded.expression=无法调用重构。\n无法在嵌入式表达式中引入
javascript.introduce.incorrect.context=无法引入变量。\n选定内容包含对"this"的引用
javascript.introduce.parameter.error.expression.has.void.type=无法引入形参。\n选定的表达式类型无效。
javascript.introduce.parameter.error.no.containing.function=无法引入形参。\n找不到要使用的包含函数。
javascript.introduce.parameter.error.no.expression.selected=无法引入形参。\n选定内容不构成表达式。
javascript.introduce.parameter.error.not.async.context=无法为包含 'await' 的表达式引入形参。\n并非所有用法都包含在异步函数中
javascript.introduce.parameter.error.target.not.async=无法为包含 'await' 的表达式引入形参。\n目标函数不是异步函数
javascript.introduce.parameter.error.yield=无法为包含 'yield 的表达式引入形参。
javascript.introduce.parameter.generate.jsdoc=生成 JSDoc
javascript.introduce.parameter.introduced.variable.value=值(&V)\:
javascript.introduce.parameter.optional.parameter=可选形参
javascript.introduce.parameter.title=提取形参
javascript.introduce.throw.expressions.unsupported=无法调用重构。\n“提取”重构中当前不支持 throw 表达式。
javascript.introduce.variable.arrow.await.referenced=无法引入。\n选定内容包含 await 表达式
javascript.introduce.variable.arrow.function.parameter.referenced=无法引入。\n选定内容包含对箭头函数形参的引用
javascript.introduce.variable.error.expression.has.void.type=无法引入变量。\n选定的表达式类型无效。
javascript.introduce.variable.error.no.expression.selected=无法引入变量。\n选定内容不构成表达式。
javascript.introduce.variable.invalid.name=请输入有效名称。
javascript.introduce.variable.make.constant=设为常量
javascript.introduce.variable.name.prompt=名称(&N)\:
javascript.introduce.variable.replace.all.occurrences=替换所有匹配项(找到 {0} 个匹配项)(&A)
javascript.introduce.variable.title=提取变量
javascript.introduce.variable.title.local=引入局部变量
javascript.introduce.variable.xml.embedded=无法在嵌入式表达式中引入变量
javascript.invalid.delete.target.message=删除运算符目标无效，应为字段引用
javascript.invalid.extended.unicode.escape=扩展的 Unicode 转义仅允许介于 0x0 和 0x10FFFF 之间的值
javascript.invalid.invoker.target=无效调用目标
javascript.invalid.number.of.parameters=实参数量无效，应为 {0} 个
javascript.jsdoc.private.member.is.not.accessible.message=private 成员不可访问 \#loc
javascript.jsdoc.protected.member.is.not.accessible.message=protected 成员不可访问 \#loc
javascript.kind.unknown=未知元素
javascript.known.props.only=对象字面量只能指定已知属性，但以下为额外属性\: {0}
javascript.label.visibility.package_local=internal(&I)
javascript.label.visibility.private=private(&V)
javascript.label.visibility.protected=protected(&O)
javascript.label.visibility.public=公共 (&B)
javascript.language.service.cannot.get.results=无法从语言服务获得结果
javascript.language.service.cannot.start=无法启动语言服务进程
javascript.language.service.default.empty.text=无错误
javascript.language.service.start.timeout=启动语言服务进程超时
javascript.language.service.tracking.disabled=错误跟踪已禁用
javascript.language.service.tracking.is.not.started=服务未启动
javascript.language.simple.name=JavaScript
javascript.language.term.attribute=特性
javascript.language.term.attribute.value=特性值
javascript.language.term.class=类
javascript.language.term.const=常量
javascript.language.term.const.field=常量字段
javascript.language.term.constructor=构造函数
javascript.language.term.decorator=装饰器
javascript.language.term.default.export=默认导出
javascript.language.term.definition=定义
javascript.language.term.destructuring.property=析构属性
javascript.language.term.entity.name=实体名称
javascript.language.term.enum=枚举
javascript.language.term.export.specifier=导出说明符
javascript.language.term.exported.default.binding=已导出默认绑定
javascript.language.term.external.module.reference=外部模块引用
javascript.language.term.field=字段
javascript.language.term.file=文件
javascript.language.term.function=函数
javascript.language.term.import.specifier=导入说明符
javascript.language.term.import.statement=import 语句
javascript.language.term.imported.default.binding=已导入默认绑定
javascript.language.term.inner.class=内部类
javascript.language.term.inner.function=内部函数
javascript.language.term.inner.interface=内部接口
javascript.language.term.interface=接口
javascript.language.term.jsdoc.tag=JSDoc 标记
javascript.language.term.label=标签
javascript.language.term.local.const=局部常量
javascript.language.term.local.variable=局部变量
javascript.language.term.method=方法
javascript.language.term.module=模块
javascript.language.term.namespace=命名空间
javascript.language.term.namespace.export=命名空间导出
javascript.language.term.namespace.import=命名空间导入
javascript.language.term.package=软件包
javascript.language.term.parameter=形参
javascript.language.term.property=属性
javascript.language.term.readonly.field=只读字段
javascript.language.term.shorthand.property=速记属性
javascript.language.term.tag=标记
javascript.language.term.top.level=顶层
javascript.language.term.type.alias=类型别名
javascript.language.term.type.parameter=类型形参
javascript.language.term.variable=变量
javascript.language.term.xml.tag=xml 标签
javascript.library.built.in=内置
javascript.linter.action.edit.config=编辑 {0}
javascript.linter.action.edit.property=编辑 {1} 中的 {0}
javascript.linter.action.edit.settings.text={0}设置…
javascript.linter.action.fix.problems.file.text={0}\: 修复当前文件
javascript.linter.action.fix.problems.name=修复 {0} 问题
javascript.linter.action.fix.problems.name.finish=已结束修复 {0} 问题
javascript.linter.action.fix.problems.name.start=已开始修复 {0} 问题
javascript.linter.action.fix.prompt=使用 {0} 重新设置所选文件的格式?
javascript.linter.configurable.config.autoSearch.title=自动搜索 (&S)
javascript.linter.configuration.file.title=配置文件
javascript.linter.error.can.not.find.document=找不到 {0} 的文档
javascript.linter.error.can.not.find.psi.file=找不到 {0} 的 PSI 文件
javascript.linter.error.empty.path=路径为空
javascript.linter.error.failed.to.lint=Lint {0} 失败
javascript.linter.error.invalid.path.to.package=指定 ''{0}'' 软件包的正确路径
javascript.linter.error.no.path.to.package=指定 ''{0}'' 软件包的路径
javascript.linter.error.no.such.file=没有此类文件
javascript.linter.error.notification.problem.with.reformatting=重新设置 {0} 的格式时出现问题\:<br/>{1}
javascript.linter.error.package.not.installed=安装 ''{0}'' 软件包
javascript.linter.error.specify.correct.path.to=指定 {0} 的正确路径
javascript.linter.import.error.bin.file.not.found=无法 ''{1}'' 软件包下找到 ''{0}''
javascript.linter.import.error.entry.point.not.found=无法在 ''{0}'' 软件包中找到入口点
javascript.linter.import.error.generic=应用配置文件中的代码样式规则时出错，可能是配置文件无效。
javascript.linter.import.error.package.not.found=找不到 ''{0}'' 软件包
javascript.linter.import.error.timeout.processing.configuration.file=处理配置文件时超时
javascript.linter.import.nothing.to.import={0}\: 已应用所有已知规则
javascript.linter.import.notification={0}\: 项目代码样式和编辑器设置基于 ''{1}'' 更新。
javascript.linter.import.notification.edit=编辑 ''{0}''
javascript.linter.import.notification.reset=重置
javascript.linter.import.notification.restored=默认代码样式和编辑器设置已还原
javascript.linter.import.notification.rules.applied=应用了以下 {0}\: {1}。
javascript.linter.import.translate.config.file.error=无法应用代码样式规则
javascript.linter.import.translate.config.progress.title=应用 {0} 代码样式规则
javascript.linter.intention.family.name.show.details={0}\: 显示详细信息
javascript.linter.intention.name.details=详细信息
javascript.linter.progress.reformatting.with=正在使用 {0} 重新设置格式…
javascript.linter.radio.button.configuration.file=配置文件(&C)\:
javascript.linter.suppress.all.rules.for.file.description=禁止当前文件的所有 {0} 规则
javascript.linter.suppress.all.rules.for.line.description=禁止当前行的所有 {0} 规则
javascript.linter.suppress.rule.for.file.description=禁止当前文件的 ''{0}''
javascript.linter.suppress.rule.for.line.description=禁止当前行的 ''{0}''
javascript.linter.suppress.rules.for.file.family.name=对当前文件禁止
javascript.linter.suppress.rules.for.line.family.name=对当前行禁止
javascript.linter.use.severity.from.config.label=使用配置文件中的规则严重性
javascript.member.from.unopened.namespace.message=未打开命名空间的成员 \#loc
javascript.missed.argument.for.parameter=形参 {0} 缺少实参
javascript.missing.read.property=未解析的读取属性 \#loc
javascript.missing.write.property=未解析的写入属性 \#loc
javascript.module.dependencies.empty.got.it.text=<div align\='left'>当前文件或文件夹没有任何依赖关系。<br/>请尝试使用其他文件或文件夹。</div>
javascript.module.dependencies.got.it.text=<div align\='left'>此图显示所选文件或目录具有的模块依赖关系。<br/>要查看多个文件或目录的依赖关系，请在<i>项目视图</i><br/>中将其选定，然后从所选项目上下文菜单中选择<i>图 – 显示图</i>。</div>
javascript.module.dependencies.got.it.title=模块依赖关系图
javascript.mutable.variable.accessible.from.closure=可从闭包访问可变变量
javascript.no.call.signatures=分配的类型不包含调用签名
javascript.not.a.constructor.call.message=不是构造函数调用
javascript.object.is.null={0} 为 null
javascript.object.is.null.or.undefined={0} 为 null 或 undefined
javascript.object.is.possibly.null={0} 可能为 null
javascript.object.is.possibly.null.or.undefined={0} 可能为 null 或 undefined
javascript.object.is.possibly.undefined={0} 可能为 undefined
javascript.object.is.undefined={0} 未定义
javascript.object.null.or.undefined.desc=对象为 'null' 或 'undefined'
javascript.octal.literals.are.not.allowed.es5.message=前缀为 '0' 的八进制字面量已过时，不建议使用
javascript.octal.literals.are.not.allowed.es6.message=不允许使用前缀为 '0' 的八进制字面量。改用 '0o' 前缀
javascript.octal.literals.are.not.allowed.in.strict.mode=在严格模式下不允许八进制字面量
javascript.octal.literals.warn.always=关于 ES5-代码中过时八进制字面量的警告
javascript.octal.sequences.are.not.allowed.message=不允许八进制转义序列
javascript.potentially.invalid.target.of.indexed.property.access=索引的属性访问的目标可能无效
javascript.potentially.invalid.usage.of.class.this=通过嵌套函数的 'this.' 对类字段的引用访问可能无效
javascript.potentially.invalid.usage.of.this=This 的用法可能无效
javascript.private.constructor.is.not.accessible.message=private 构造函数不可访问 \#loc
javascript.private.member.is.not.accessible.message=private 成员不可访问 \#loc
javascript.property.is.read.only.message=只读属性 \#loc
javascript.property.is.write.only.message=只写属性 \#loc
javascript.protected.constructor.is.not.accessible.message=protected 构造函数不可访问 \#loc
javascript.protected.member.is.not.accessible.message=protected 成员不可访问 \#loc
javascript.qualified.class.name.expected=应为限定的类名
javascript.qualified.name.is.not.imported.message=未导入限定名称 \#loc
javascript.redundant.typeof.guard=''typeof'' 检查冗余\: ''{0}'' 始终具有类型 ''{1}''
javascript.refactoring.asdoc.for.abstracts=abstract 的 ASDoc
javascript.refactoring.cannot.find.usages.of.definition.to.inline=找不到要内联的定义的用法
javascript.refactoring.cannot.inline.ambient.function=无法内联没有实现的声明
javascript.refactoring.cannot.inline.complex.expression.evaluation=无法内联复杂表达式求值
javascript.refactoring.cannot.inline.constructor=无法内联构造函数
javascript.refactoring.cannot.inline.destructuring.rest.variable=无法内联析构 rest 变量
javascript.refactoring.cannot.inline.destructuring.variable.with.default=无法内联使用默认值的析构变量
javascript.refactoring.cannot.inline.function.defined.in.library=无法内联外部库中定义的函数
javascript.refactoring.cannot.inline.function.referencing.arguments=无法内联引用实参的函数
javascript.refactoring.cannot.inline.function.referencing.rest.parameter=无法内联函数引用的 rest 形参
javascript.refactoring.cannot.inline.function.with.multiple.returns=无法内联有多个退出点的函数
javascript.refactoring.cannot.inline.interface.method=无法内联接口方法
javascript.refactoring.cannot.inline.jsx.usage=无法内联 JSX 标签用法
javascript.refactoring.cannot.inline.not.initialized.variable=无法内联未初始化的变量
javascript.refactoring.cannot.inline.overrided.or.overridden.method=无法内联参与层次结构的方法
javascript.refactoring.cannot.inline.recursive.function=无法内联递归函数
javascript.refactoring.extract.function.already.exists.in.this.scope=此作用域中已存在 {0}
javascript.refactoring.extract.function.bad.selection=所选块应代表一组语句或表达式
javascript.refactoring.extract.function.function.used.before.declaring=选定内容包含在声明之前使用的函数
javascript.refactoring.extract.function.multiple.exit.points=所选代码段有多个退出点
javascript.refactoring.extract.function.no.loop.for.break=代码段内没有用于 break 语句的相应循环
javascript.refactoring.extract.function.no.loop.for.continue=代码段内没有用于 continue 语句的相应循环
javascript.refactoring.extract.function.no.switch.for.break=代码段内没有用于 break 语句的相应 'switch'
javascript.refactoring.extract.function.title=提取函数
javascript.refactoring.extract.function.yield.and.return=所选片段同时包含 yield 表达式和 return 语句
javascript.refactoring.function.to.es6.class.command=将函数 {0} 转换为类
javascript.refactoring.function.to.es6.class.defineProperty.warning.text=警告\: 将使用“Object.defineProperty”、“Object.defineProperties”或“Object.create”创建的属性转换为 ES6 语法可能会影响其可枚举性和可配置性
javascript.refactoring.inline.all.message=内联所有引用并移除 {0} ({1}) (&A)
javascript.refactoring.inline.dialog.title=内联{0}
javascript.refactoring.inline.function.title=内联函数
javascript.refactoring.inline.this.only=仅内联此引用并保留 {0}(&K)
javascript.refactoring.inline.variable.title=内联变量
javascript.refactoring.searching.usages=查找用法
javascript.refactoring.variable.used.as.lvalue=要内联的变量在赋值的左侧使用
javascript.refactoring.variable.value.is.changed.when.accessed.from.closure=从闭包访问时变量值被更改
javascript.rename.choose.target.message=您要重命名哪一个?
javascript.rename.containing.file.message=是否还要将该文件重命名为 {0}?\n{1} 的用法和 import 语句中的文件路径将进行相应更新。
javascript.rename.destructuring.target.dialog.title=速记析构变量使用 {0} 初始化
javascript.rename.element.with.related.elements.title=重命名 {0}
javascript.rename.reference.intention.name=重命名引用
javascript.rename.related.declaration.message=是否还要重命名 {0}?\nimport 语句中的 {0} 用法将进行相应更新。
javascript.rename.shorthand.target.dialog.title=速记属性使用 {0} 初始化
javascript.rename.shorthand.target.option.both.label=两者
javascript.rename.shorthand.target.option.property.label=属性
javascript.rename.symbol.intention.name=重命名符号
javascript.report.unused.definitions=报告未使用的定义
javascript.report.unused.properties=报告未使用的属性
javascript.returned.expression.type.mismatch=返回的表达式类型 {1} 不可分配给类型 {0}
javascript.service.is.disabled.in.safe.mode=服务在安全模式下被禁用
javascript.service.node.error=Node 运行时路径不正确。请检查运行时设置。
javascript.starting.service=启动 {0} 服务
javascript.static.member.is.not.accessible.message=static 成员不可访问 \#loc
javascript.strictly.check.global.vars=将未声明的全局符号报告为错误
javascript.strictly.check.object.properties=将未声明的属性报告为错误
javascript.surround.with.cast=Type(expr)
javascript.surround.with.do.while=do / while
javascript.surround.with.for=for
javascript.surround.with.function=函数
javascript.surround.with.function.expression=函数表达式
javascript.surround.with.if=if
javascript.surround.with.if.cond=if (cond)
javascript.surround.with.if.else=if / else
javascript.surround.with.if.else.cond=if (cond) / else
javascript.surround.with.not.parenthesis=\!(expr)
javascript.surround.with.object.literal=对象字面量
javascript.surround.with.parenthesis=(expr)
javascript.surround.with.try.catch=try / catch
javascript.surround.with.try.catch.finally=try / catch / finally
javascript.surround.with.try.finally=try / finally
javascript.surround.with.while=while
javascript.surround.with.with=with
javascript.suspicious.type.guard.desc=类型 guard 检查不健全
javascript.suspicious.typeof.guard=''typeof'' 检查无效\: ''{0}'' 不能具有类型 ''{1}''
javascript.template.context.type=JavaScript(&R)
javascript.term.does.not.evaluate.to.function=方法表达式不是函数类型
javascript.term.does.not.evaluate.to.function.line.break=表达式不可调用。如果这不应是调用，请检查是否缺少分号
javascript.term.does.not.evaluate.to.function.nullable=方法表达式可以为 null 或 undefined
javascript.term.does.not.evaluate.to.function2=属性不能作为函数调用
javascript.term.does.not.evaluate.to.function2.fix=移除实参列表
javascript.term.nullable.indexer.qualifier=索引的表达式可以为 null 或 undefined
javascript.type.is.not.assignable.to.type=类型 {1} 不可分配给类型 {0}
javascript.undeclared.variable.name.message=隐式声明变量 {0} \#loc
javascript.unfiltered.for.in.loop=可能迭代意外(自定义/继承)成员，可能缺少 hasOwnProperty 检查
javascript.unknown.metadata.attribute=未知元数据特性
javascript.unknown.metadata.tag=未知元数据标签
javascript.unresolved.circle.definition=导入的圆定义
javascript.unresolved.file.or.dir=无法解析 {0} {1}
javascript.unresolved.function.name.message=未解析的函数或方法 <code>{0}()</code> \#loc
javascript.unresolved.symbol.message=未解析的符号
javascript.unresolved.type.name.message=未解析的类型 {0} \#loc
javascript.unresolved.variable.name.message=未解析的变量 {0} \#loc
javascript.unresolved.variable.null.or.undefined.qualifier.message=''{0}'' 的限定符可能为 null 或 undefined \#loc
javascript.unresolved.variable.null.qualifier.message=''{0}'' 的限定符可能为 null \#loc
javascript.unresolved.variable.or.type.name.message=未解析的变量或类型 {0} \#loc
javascript.unresolved.variable.or.type.name.message2=未解析的变量或类型 {0}
javascript.unresolved.variable.undefined.qualifier.message=''{0}'' 的限定符可能未定义 \#loc
javascript.unused.import.remove=移除未使用的 'import'
javascript.unused.import.remove.specifier=移除未使用的元素
javascript.validate.imports.name=未解析的已导入名称
javascript.validation.destructuring.without.initializer=析构声明必须有初始值设定项
javascript.validation.fqn.to.replace.with.import=限定名称可被替换为 import 语句
javascript.validation.generators.yield.not.assignable.to.return=类型 ''{1}'' 不可分配给类型 ''{0}''
javascript.validation.generators.yield.not.in.generator=只允许在生成器正文中使用 'yield' 表达式。
javascript.validation.generators.yield.not.iterable=表达式类型没有定义 [Symbol.iterator] 或 [Symbol.asyncIterator]
javascript.validation.initialized.var.in.for.loop=''{0}'' 循环中不允许变量初始值设定项
javascript.validation.message.abstract.get.accessor.not.implemented=未实现类 {1} 的 abstract get 访问器 {0}
javascript.validation.message.abstract.method.not.implemented=未实现类 {1} 中的 abstract 方法 {0}
javascript.validation.message.abstract.set.accessor.not.implemented=未实现类 {1} 的 abstract set 访问器 {0}
javascript.validation.message.accessor.could.not.be.nested.under.other.function=访问器方法不能嵌套在其他函数中
javascript.validation.message.arguments.is.readonly='arguments' 只读
javascript.validation.message.arguments.with.rest.parameter=使用 rest 形参时，'arguments' 对象不可用
javascript.validation.message.assignment.to.const=尝试分配给常量或只读变量
javascript.validation.message.assignment.to.const.fix.remove.readonly=移除只读修饰符
javascript.validation.message.assignment.to.const.fix.replace=替换为 let
javascript.validation.message.attribute.was.specified.multiple.times=多次指定修饰符 {0}
javascript.validation.message.base.constructor.in.not.derived=仅允许在派生构造函数中调用基类构造函数
javascript.validation.message.baseMethod.before.super.call=超类构造函数调用前不允许有 'super'
javascript.validation.message.break.without.target=无法确定 'break' 的目标
javascript.validation.message.can.not.override.final.method=无法从{0}重写 final 方法
javascript.validation.message.circular.dependency=循环依赖关系
javascript.validation.message.class.method.incompatible=''{1}'' 类中的方法 ''{0}'' 不可分配给基类 ''{2}'' 中的同一方法
javascript.validation.message.class.method.not.implemented=未实现类 {1} 的方法 {0}
javascript.validation.message.class.name.expected.here=此处应为类名
javascript.validation.message.class.property.incompatible=''{1}'' 类中的属性 ''{0}'' 不可分配给基类 ''{2}'' 中的同一属性
javascript.validation.message.class.property.not.implemented=未实现类 {1} 的属性 {0}
javascript.validation.message.class.setter.cannot.have.return.type='set' 访问器不能有返回值类型
javascript.validation.message.comma.is.not.allowed.after.last.parameter=最后一个形参后不允许有逗号
javascript.validation.message.comma.is.not.allowed.after.rest.element=rest 元素后不允许有逗号
javascript.validation.message.conflicting.definition.was.found.with.the.same.name=在命名空间 {1} 中发现冲突性的继承声明 {0}
javascript.validation.message.const.variable.without.initializer='const' 变量不包含初始值设定项。以后无法赋予有意义的值。
javascript.validation.message.constructor.cannot.be.static=构造函数不能为 static
javascript.validation.message.constructor.cannot.have.custom.visibility=构造函数应为 public 或未指定可见性
javascript.validation.message.constructor.field.not.allowed=类可能没有名为 'constructor' 的非 static 字段
javascript.validation.message.continue.outside.loop='continue' 在循环语句外部
javascript.validation.message.continue.without.target=无法确定 'continue' 的目标
javascript.validation.message.duplicate.catch.block=重复 catch 块 \#loc
javascript.validation.message.duplicate.catch.block.fix=移除重复的 catch 块
javascript.validation.message.duplicate.declaration=重复声明
javascript.validation.message.duplicate.declaration.fix.remove=移除类型
javascript.validation.message.duplicate.declaration.fix.text=导航到上一个声明 ''{0}''
javascript.validation.message.duplicate.declaration.fix.text.no.name=导航到上一个声明
javascript.validation.message.duplicate.default.export.declaration=一个模块不能有多个默认导出
javascript.validation.message.duplicate.default.export.in.module=默认导出只能在 ECMAScript-style 模块中使用
javascript.validation.message.duplicate.export.declaration=导出声明与已导出的声明 ''{0}'' 相冲突
javascript.validation.message.duplicate.label=重复标签
javascript.validation.message.dynamic.can.be.applied.to.class=动态特性只能应用于类声明
javascript.validation.message.es5.function.declarations.allowed.on.top.level.or.function=禁止在程序或函数的顶层使用函数语句
javascript.validation.message.eval.cannot.be.assigned=不能在严格模式下分配 'eval'
javascript.validation.message.extend.final.class=无法扩展 final 类 ''{0}''
javascript.validation.message.extend.multiple.classes=类不能扩展多个类
javascript.validation.message.final.modifier.allowed.only.for.methods=final 修饰符只能应用于类和类方法
javascript.validation.message.flowjs.path=Flow 路径不正确
javascript.validation.message.for.await.no.async.context='for await' 只能在 'async' 函数中使用
javascript.validation.message.for.await.top.level=使用了顶层 'for await'
javascript.validation.message.function.method.invalid.overridden.parameter.type=不兼容重写，应有类型 ''{0}''
javascript.validation.message.function.override.for.interface=对 {0} 中的方法进行了不兼容的重写
javascript.validation.message.function.override.for.object.method=从 Object 继承的方法无需重写
javascript.validation.message.function.override.incompatible.access.modifier=不兼容重写，应有 ''{0}'' 访问修饰符
javascript.validation.message.function.override.incompatible.signature=不兼容重写，应有签名 ''{0}''
javascript.validation.message.function.override.incompatible.signature.generic=不兼容重写
javascript.validation.message.function.override.incompatible.signature2=不兼容重写，应有返回值类型 ''{0}''
javascript.validation.message.function.override.incompatible.signature3=不兼容重写，应有种类 ''{0}''
javascript.validation.message.function.override.without.override.modifier=方法重写了没有 override 关键字的超类 {0} 中的方法
javascript.validation.message.function.override.without.parent.method=方法不重写超类的方法
javascript.validation.message.get.method.should.be.valid.type=getter 定义的返回值类型不应为 {0}
javascript.validation.message.get.method.should.have.no.parameter=getter 定义不得有形参
javascript.validation.message.get.method.type.is.different.from.setter=Get 访问器方法的类型与 set 访问器类型不兼容，应为 ''{0}''
javascript.validation.message.identifier.not.allowed.in.strict.mode=在严格模式下不能将 ''{0}'' 用作标识符
javascript.validation.message.implements.for.interface.not.allowed=接口不允许有实现列表
javascript.validation.message.implements.is.not.allowed=标准 ECMAScript 中不允许有实现子句
javascript.validation.message.incompatible.override=对 {0} 中的成员进行了不兼容的重写
javascript.validation.message.index.no.type=索引签名形参必须具有类型注解
javascript.validation.message.index.wrong.type=索引签名形参类型必须可以分配给 'string | number | symbol'
javascript.validation.message.interface.call.signature.not.implemented=未实现接口 {0} 的调用签名
javascript.validation.message.interface.cannot.be.final.modifiers=接口不能为最终
javascript.validation.message.interface.get.accessor.not.implemented=未实现接口 {1} 的属性 get 访问器 {0}
javascript.validation.message.interface.index.signature.not.implemented=未实现接口 {0} 的索引签名
javascript.validation.message.interface.members.cannot.be.final.modifiers=接口成员不能为最终
javascript.validation.message.interface.members.cannot.have.access.modifiers=接口成员不能具有访问修饰符
javascript.validation.message.interface.members.cannot.have.namespace.attributes=接口成员不能具有命名空间特性
javascript.validation.message.interface.method.invalid.access.modifier=不兼容实现，应有 'public' 访问修饰符
javascript.validation.message.interface.method.invalid.signature=不兼容实现，应有签名 ''{0}''
javascript.validation.message.interface.method.invalid.signature2=不兼容实现，应有返回值类型 ''{0}''
javascript.validation.message.interface.method.invalid.signature3=不兼容实现，应有 get / set ''{0}''
javascript.validation.message.interface.method.not.implemented=未实现来自接口 {1} 的方法 {0}
javascript.validation.message.interface.name.expected.here=此处应为接口名称
javascript.validation.message.interface.property.not.implemented=未实现接口 {1} 的属性 {0}
javascript.validation.message.interface.set.accessor.not.implemented=未实现接口 {1} 的属性 set 访问器 {0}
javascript.validation.message.jsdoc.types.are.used=JSDoc 类型只能在文档注释内部使用
javascript.validation.message.missed.super.constructor.call=缺少超类构造函数调用
javascript.validation.message.missing.catch.or.finally=缺少 catch 或 finally 子句
javascript.validation.message.must.be.lvalue={0} 中的左侧无效
javascript.validation.message.nested.classes.are.not.allowed=不允许嵌套类
javascript.validation.message.one.visibility.modifier.allowed=只允许一个可见性修饰符(public、protected、internal、private)
javascript.validation.message.only.one.default.is.allowed=\ switch 中只允许一个默认子句
javascript.validation.message.override.can.be.applied.to.method=重写只能应用于函数声明
javascript.validation.message.parameter.is.not.allowed.after.rest.parameter=rest 形参后不允许有任何形参
javascript.validation.message.parameter.non.optional.after.optional=必选形参不能位于可选形参后
javascript.validation.message.parameter.rest.optional=rest 形参不能是可选形参
javascript.validation.message.parameter.should.be.initialized=应初始化形参
javascript.validation.message.redeclaration.of.block.scope=不能重复声明块作用域变量
javascript.validation.message.redeclaration.of.block.scope.in.scope.of.var=块作用域变量不能与同一块作用域中的"var"变量或形参使用相同的名称
javascript.validation.message.redeclaration.of.var.in.scope.of.block.scope="var" 变量不能与其可见性作用域内的块作用域变量使用相同的名称
javascript.validation.message.redefining.is.not.allowed=不允许重新定义 {0}
javascript.validation.message.redundant.type=显式类型实参 {0} 可被替换为 {1}
javascript.validation.message.redundant.type.remove=可以移除显式类型实参 {0}
javascript.validation.message.referencing.arguments.caller.callee.is.not.allowed=不允许从实参中引用 'caller' 和 'callee'
javascript.validation.message.referencing.function.arguments.property.is.not.allowed=不允许引用 'arguments' 函数属性
javascript.validation.message.remove.unneeded.comma.fix=移除不需要的逗号
javascript.validation.message.rest.parameter.should.not.be.initialized=不应初始化 Rest 形参
javascript.validation.message.return.outside.function.definition='return' 在函数定义外部
javascript.validation.message.return.statement.required=非无效返回值类型必需具备 return 语句
javascript.validation.message.return.value.of.type.is.required=必需具备类型 {0} 的返回值
javascript.validation.message.set.method.should.be.void.or.without.type=setter 定义的返回值类型必须为未指定或无效
javascript.validation.message.set.method.should.have.one.parameter=setter 定义必须正好有一个形参
javascript.validation.message.set.method.type.is.different.from.getter=set 访问器方法的类型与 get 访问器类型不兼容，应为 ''{0}''
javascript.validation.message.setter.parameter.cannot.have.initializer=Setter 定义不能具有可选形参
javascript.validation.message.static.method.cannot.be.final=静态方法不能为最终
javascript.validation.message.static.modifier.is.allowed.only.for.class.members=仅允许类成员使用 static 修饰符
javascript.validation.message.super.constructor.call.should.be.in.constructor=超类构造函数调用应位于构造函数本体中
javascript.validation.message.super.referenced.from.static.context=在 static 上下文中引用了 'super'
javascript.validation.message.super.referenced.without.class.instance.context=在没有类实例上下文的情况下引用了'super'
javascript.validation.message.this.before.super.call=超类构造函数调用前不允许有 'this'
javascript.validation.message.this.referenced.from.static.context=在 static 上下文中引用了 'this'
javascript.validation.message.unexpected.type.for.rest.parameter=Rest 形参不应有类型
javascript.validation.message.unknown.metadata.annotation.used=使用了未知的元数据特性
javascript.validation.message.unneeded.comma=不需要的逗号
javascript.validation.message.unresolved.component=未解析的组件 {0}
javascript.validation.message.use.namespace.reference.or.access.modifier=使用命名空间或访问修饰符
javascript.validation.multiple.var.in.for.loop=''{0}'' 循环中只允许一个变量
javascript.validation.new.target.not.in.function=仅允许函数声明、函数表达式或构造函数的本体中有元属性 'new.target'
javascript.validation.unused.import=未使用的 import
javascript.vector.literal.element.type.mismatch=矢量字面量元素类型 {1} 不可分配给类型 {0}
javascript.visibility.internal=internal
javascript.visibility.private=private
javascript.visibility.protected=protected
javascript.visibility.public=public
javascript.with.clause.assert.deprecated.message=import 特性的 'assert' 关键字已弃用。请改用 'with' 语法。
javascript.with.statement.is.not.allowed.in.strict.mode.message=严格模式下不允许使用 With 语句
jest.cannot.find.bin.file.for.package.dialog.message=找不到 ''{0}'' 软件包的 bin 文件
jest.coverage.cannot.find.lcov.info.notification.content=无法显示 Jest 覆盖率\: 找不到 {0}。
jest.coverage.directory.not.found.notification.content=无法从 Jest 配置中读取 coverageDirectory 选项
jest.coverage.notification.title=Jest 覆盖率
jest.go.to.snapshot.text=转到 ''{0}'' 快照
jest.package.placeholder.text=软件包目录的路径，可选择 jest、react-scripts 或 react-scripts 替代项
jest.rc.configurationFile.label=配置文件(&C)\:
jest.rc.configurationFile.title=选择 Jest 配置文件
jest.rc.jestOptions.emptyText=CLI 选项，例如 --watch 或 --env\=jsdom
jest.rc.jestOptions.label=Jest 选项\:
jest.rc.jestPackageField.label=Jest 软件包(&J)\:
jest.snapshot.label=Jest 快照
jest.snapshot.update.all.tests.text=<link>点击以更新所有失败的快照</link>
jest.snapshot.update.rc.name=更新 {0} 的快照
jest.snapshot.update.single.test.text=<link>点击以更新 ''{0}'' 的快照</link>
jest.snapshot.update.test.file.text=<link>点击以更新 {0} 中失败的快照</link>
jquery.documentation.not.found=找不到 jQuery 文档
js.accessibility.check.inspection.name=已引用无法访问的 @private 和 @protected 成员
js.add.braces.to.arrow.function=向箭头函数中添加大括号
js.add.members.to.type=将成员 {0} 添加到 ''{1}''
js.add.members.to.type.desc=将成员添加到类或接口
js.add.then.fix=添加 '.then()'
js.align.multiline.extends.list=多行时对齐
js.align.properties.none=不对齐
js.align.properties.on.colon=冒号上
js.align.properties.on.value=值上
js.annotator.assignment.pattern.rhs=赋值模式必须位于赋值的左侧
js.annotator.inspection.name=未遵循 ECMAScript 规范
js.annotator.newline.before.arrow=箭头前不允许换行符
js.annotator.replace.with.fat.arrow=替换为粗箭头
js.annotator.rest.element.must.be.last=rest 元素必须位于最后
js.annotator.thin.arrow.used=使用了细箭头
js.annotator.unary.operator.within.exponential=一元运算符 ''{0}'' 不允许直接位于指数表达式之前。建议添加括号以解决歧义问题。
js.annotator.yield.cannot.be.used.inside.generator='yield' 不能用作生成器内部的标识符
js.anonymous.to.named.function=匿名函数转换为命名函数
js.arrangement.group.arrow.fields.with.methods=使用包含方法的箭头函数初始化的组字段
js.array.new.line.after.left.bracket=在 '[' 后换行
js.array.new.line.before.right.bracket=将 ']' 置于新行中
js.arrow.function.braces.can.be.removed.fix.family.name=移除箭头函数体周围的大括号
js.arrow.function.braces.can.be.removed.key=箭头函数体周围的大括号冗余
js.arrow.function.braces.can.be.removed.problem.description=可以移除箭头函数体周围的大括号
js.assigning.to.primitive.type.property=赋给基元的值将丢失
js.assignment.issues.group.name=赋值问题
js.assignment.used.as.condition.fix=将 ''\='' 替换为 ''{0}''
js.assignment.used.as.condition.name=用作条件的赋值
js.assignment.used.as.condition.text=<code>\#ref</code> 作为条件使用
js.await-using.in.synchronous.function='await using' 指令只能在 'async' 函数中使用
js.await.in.synchronous.function='await' 运算符只能在 'async' 函数中使用
js.await.promise.double.await.inspection=冗余 'await await'
js.await.promise.reject.inspection=冗余 'await Promise.reject()'
js.await.promise.resolve.fix=替换为 ''{0}''
js.await.promise.resolve.inspection=冗余 'await Promise.resolve()'
js.await.promise.return.await.inspection=冗余 'return await'
js.await.promise.trivial.await.inspection=非 promise 类型的冗余 'await'
js.bitwise.operator.usage.name=按位运算符用法
js.bitwise.operator.usage.popup=使用了按位运算符
js.bitwise.operator.usage.quickfix=替换为 {0}
js.blank.lines.around.function=Around 函数\:
js.blank.lines.around.method=方法周围\:
js.breadcrumbs.callback.for=\ {0}({1}) 回调
js.chained.call.dot.on.next.line='.' 在新行
js.check.function.signature.guess.optionality=将非类型化形参视为必选
js.check.function.signature.guess.optionality.hint=如果禁用，则所有未键入的形参均视为可选形参
js.checkbox.make.readonly=设为只读(&R)
js.class.context.type=类/接口
js.class.member.expression.context.type=类成员表达式
js.class.member.initialization.inspection.name=在 static 初始值设定项中使用可能未分配的属性
js.class.member.initialization.inspection.text=字段 ''{1}'' 在 ''{0}'' 之后声明，并且可能尚未分配
js.class.member.initialization.inspection.text.id=字段 ''{0}'' 引用本身
js.class.member.statement.context.type=类成员语句
js.closure.compiler.syntax.cyclic.inheritance=涉及 {0} 的循环继承
js.closure.compiler.syntax.empty.type=空类型不可用
js.closure.compiler.syntax.implements.not.interface={0} 未用 @interface 进行注解
js.closure.compiler.syntax.inspection.name=JSDoc 标记不正确的用法
js.closure.compiler.syntax.invalid.type=类型语法无效
js.code.style.align.caption=对齐
js.code.style.align.from.clause.caption=对齐 'from' 子句
js.code.style.align.var.statements=当多行时
js.code.style.align.var.statements.and.assignments=分组时
js.code.style.array.group.name=数组
js.code.style.do.not.align.var.statement=不对齐
js.code.style.file.name.camel.style=驼峰命名法 (appComponent)
js.code.style.file.name.lisp.style=中线命名法 (app-component)
js.code.style.file.name.mixed.style=带后缀的中线命名法 (my-app.component)
js.code.style.file.name.pascal.style=帕斯卡命名法 (AppComponent)
js.code.style.file.name.relaxed.style=重用当前文件的 case
js.code.style.file.name.snake.style=蛇形命名法 (app_component)
js.code.style.issues.group.name=代码样式问题
js.code.style.object.literals.category.name=对象
js.code.style.punctuation.tab.title=标点
js.code.style.tab.name=JavaScript
js.code.vision.component.usages=组件用法
js.code.vision.component.usages.action=显示组件用法
js.code.vision.component.usages.description=用于调用组件的“查找用法”的可点击提示。
js.code.vision.component.usages.tooltip=点击查看该组件的用法
js.command.name.auto-import-symbols=自动导入外部符号
js.commandline.configure.language.version=为项目配置 JavaScript 语言版本
js.commandline.configure.nodejs=配置 NodeJS 运行时并为 package.json 文件安装软件包
js.comment.matches.signature.inspection.name=不匹配的 JSDoc 和函数签名
js.comment.matches.signature.inspection.problem1=JSDoc 中未描述形参 {0}
js.comment.matches.signature.inspection.problem2=JSDoc 中描述的形参 {0} 未出现在函数签名中
js.comment.matches.signature.inspection.quickfix=更新 JSDoc 注释
js.comparison.with.nan.inspection.name=与 NaN 比较
js.comparison.with.nan.inspection.problem=与 NaN 的相等比较的求值结果始终为 false
js.comparison.with.nan.inspection.problem2=与 NaN 的不等比较的求值结果始终为 true
js.comparison.with.nan.inspection.quickfix=替换为 {0}isNaN(…)
js.component.usage.in.template.group.display.name=模板中的用法
js.component.usage.type.display.name=组件
js.consecutive.commas.in.array.literal.inspection.insert.undefined=插入 'undefined'
js.consecutive.commas.in.array.literal.inspection.message=数组字面量中的连续逗号
js.consecutive.commas.in.array.literal.inspection.name=数组字面量中的连续逗号
js.constructor.cant.have.return.type=构造函数不能有返回值类型
js.convert.default.export.to.named.intention.family=将 default export 转换为命名 export
js.convert.default.export.to.named.intention.working=将 default export 和 import 转换为命名 export 和 import…
js.convert.for.each.to.for.of.intention.family=将 'forEach' 替换为 'for..of' 循环
js.convert.for.each.to.indexed.intention.family=将 'forEach' 替换为索引的 'for' 循环
js.convert.for.in.to.for.of.family.name=将 'for..in' 转换为 'for..of'
js.convert.for.in.to.for.of.inspection.text=使用了 'for..in' 而不是 'for..of'
js.convert.for.in.to.for.of.text=将 'for..in' 转换为 'for..of'
js.convert.for.of.to.indexed.intention.family=将 'for..of' 替换为索引的 'for' 循环
js.convert.indexed.for.to.for.of.family.name=将带索引的 'for' 转换为 'for..of'
js.convert.indexed.for.to.for.of.inspection.text=已使用索引的 'for' 而不是 'for..of'
js.convert.indexed.for.to.for.of.text=将带索引的 'for' 转换为 'for..of'
js.convert.indexed.for.to.foreach.intention.family=将索引的 'for' 转换为 'forEach' 调用
js.convert.let.to.const.inspection.text=已使用 'let' 而不是 'const'
js.convert.map.to.for.of.intention.family=将 'map' 数组调用替换为 'for..of' 循环
js.convert.module.exports.into.es6.export.family.name=转换为 export
js.convert.module.exports.into.es6.export.inspection.text=使用了 'module.exports' 而不是 'export'
js.convert.module.exports.into.es6.export.text=转换为 export
js.convert.named.export.to.default.intention.family=将命名 export 转换为 default export
js.convert.named.export.to.default.intention.working=正在将命名 export 和 import 转换为 default export 和 import…
js.convert.parameters.to.object.intention.name=将形参转换为对象
js.convert.parameters.to.object.non.call.usage.will.not.be.updated=不更新非调用用法
js.convert.parameters.to.object.usage.will.not.be.updated.for.contextual.type=方法会重写另一个方法。不会更新基方法
js.convert.parameters.to.object.usage.will.not.be.updated.for.spread=不会更新使用非终端传播实参进行的调用
js.convert.parameters.to.object.with.interface.intention.name=将形参转换为对象并引入接口
js.convert.require.into.es6.import.family.name=将 require() 转换为 import
js.convert.require.into.es6.import.inspection.text=使用了 'require()' 而不是 'import'
js.convert.require.into.es6.import.inspection.withConditional.option=使用“全部修复”操作在内部作用域内转换 require()
js.convert.require.into.es6.import.inspection.withConditional.option.description=在内部作用域内转换 require() (例如 'if' 语句或内部函数)
js.convert.require.into.es6.import.text=将 require() 转换为 import
js.convert.to.anonymous.function=转换为匿名函数
js.convert.to.anonymous.function.family.name=箭头函数转换为匿名函数
js.convert.to.arrow.function=转换为箭头函数
js.convert.to.es6.class=转换为类
js.convert.to.es6.class.family.name=将函数及其成员声明转换为类
js.convert.to.foreach.intention.name=将 'for-in' 转换为 'forEach' 调用
js.convert.to.named.function=转换为命名函数
js.convert.to.named.function.to.class.method=转换为类方法
js.convert.var.to.const.text=转换为 const
js.convert.var.to.let.or.const=转换为 let/const
js.convert.var.to.let.or.const.family.name=将 var 转换为 let/const
js.convert.var.to.let.or.const.inspection.conservative.option=使用“全部修复”操作保守地转换 var
js.convert.var.to.let.or.const.inspection.conservative.option.description=在第一次使用变量之前，声明可能会移至函数器顶部。\n要在使用“全部修复”操作时禁用此行为，请选中“保守转换 var”选项。
js.convert.var.to.let.or.const.inspection.text=已使用 'var' 而不是 'let' 或 'const'
js.convert.var.to.let.text=转换为 let
js.copy.qualified.to.clipboard=将限定名称复制到剪贴板
js.create.derived.type.abstract.class=实现抽象类
js.create.derived.type.class=创建派生类
js.create.derived.type.family=创建派生类/实现接口
js.create.derived.type.interface=实现接口
js.create.switch.cases=创建缺少的 'switch' 分支
js.create.switch.cases.fix=创建缺少的分支\: {0}
js.declaration.is.not.at.scope.start=var 语句不在作用域开始
js.declarations.at.scope.start.inspection='var' 未在函数开头声明
js.deprecated.symbols.inspection.name=已使用弃用的符号
js.destructuring.merge.inspection=正在析构具有相同键的属性
js.destructuring.merge.inspection.fix=合并析构属性
js.destructuring.merge.inspection.text=可以合并具有多个相同键的析构属性
js.dialect.settings.caption=
js.dialect.settings.dialog.title=JavaScript 语言版本
js.dialect.settings.empty.text=使用 + 按钮添加目录，并选择 JavaScript 版本
js.dialect.settings.override.question=重写子目录和文件的语言版本?
js.dialect.settings.override.title=重写语言版本设置
js.dialect.settings.tableTitle=语言
js.dialects.customized.label=根据目录自定义
js.documentation.fires=触发\:
js.documentation.jsdoc.aliases=别名\:
js.documentation.jsdoc.dialect=方言\:
js.documentation.jsdoc.supported-also-by=还受以下对象的支持\:
js.documentation.more.overload=其他 +{0} 个重载
js.documentation.more.overloads=其他 +{0} 个重载
js.dot.property.access.context.type=点号属性访问
js.duplicate.declaration.inspection.name=重复声明
js.edit.object.literal=编辑对象字面量属性的值
js.expand.shorthand.property.quick.fix=展开速记属性
js.expression.context.type=表达式
js.extends.keyword.wrap=扩展关键字
js.extends.list.wrap=Extends 列表
js.extjs.unresolved.ext.xtype.inspection.name=未解析的 Ext JS xtype
js.file.references.inspection.ignore.complex.cases=忽略复杂 case
js.file.references.inspection.name=未解析的文件引用
js.file.watcher.6to5.description=使用 Babel 将 ECMAScript 6 代码转换成 ECMAScript 5
js.fix.change.member.access.to.sharp=使用 '\#' 设为 private
js.flow.enable.flow.service.error=\ 不正确的 Flow 路径
js.flow.enable.flow.service.error.empty=Flow 可执行文件的路径为空
js.flow.enable.flow.service.error.message={0}。禁用所有 Flow 服务或为可执行文件提供有效路径。
js.flow.enable.flow.service.error.on.checking=检查 Flow 路径时出错\: {0}
js.flow.enable.other.services=导航、代码补全和类型提示
js.flow.enable.type.checking=类型检查
js.flow.has.unsaved.files=由于修改了某些文件，因此没有执行高亮显示
js.flow.process.log=Flow 流程日志
js.flow.services.label=为之使用 Flow 服务器\:
js.flow.settings.auto.save=自动保存所有修改的文件
js.flow.settings.auto.save.warning.lsp=这样 Flow 将始终显示最新的错误状态。
js.flow.settings.executable.dialog.title=选择 Flow 软件包或可执行文件
js.flow.settings.executable.label=Flow 软件包或可执行文件 (&F)\:
js.flowjs.annotation.inspection.name=Flow 类型检查器
js.flowjs.config.inspection.message=无关联的 .flowconfig
js.flowjs.config.inspection.name=缺少 .flowconfig
js.flowjs.config.inspection.to.current.path.name=向当前目录中添加 .flowconfig
js.flowjs.config.inspection.to.module.path.name=向模块内容根中添加 .flowconfig
js.flowjs.config.inspection.to.project.path.name=向项目根中添加 .flowconfig
js.flowjs.flag.without.language.version=无 Flow 语言版本的 Flow 标志
js.flowjs.group.name=Flow 类型检查器
js.format.cstyle.comments=对齐多行
js.frameworks.sencha.xtype.not.found=找不到 xtype ''{0}'' 的 Ext JS 类
js.function.brace.style=在函数声明中
js.function.call.parentheses=函数调用括号
js.function.call.wrap=函数调用实参
js.function.declaration.parentheses=函数声明括号
js.function.expression.brace.style=在函数表达式中
js.function.metrics.group.name=函数指标
js.function.parameters.wrap=函数声明形参
js.generated.explicit.return.expression.types=函数表达式返回
js.generated.explicit.return.types=函数声明返回
js.generated.explicit.types=此项的首选显式类型\:
js.generated.explicit.var.types=变量和字段
js.generated.types=类型
js.generated.types.settings.link=显式类型的代码样式设置
js.generated.use.as.cast=首选 'as' 类型转换
js.generated.use.public.modifier=使用 'public' 修饰符
js.import.options.merge.import=合并同一模块中成员的导入
js.import.options.sort.members=对导入的成员排序
js.import.options.sort.module.name=按模块对 import 排序
js.import.options.use.explicit.js.extension=使用文件扩展名\:
js.import.options.use.explicit.js.extension.auto=自动
js.import.options.use.explicit.js.extension.no=从不
js.import.options.use.explicit.js.extension.yes=始终
js.import.options.use.explicit.js.extension.yes.ts=始终为 ".js"
js.import.options.use.import-type=在 import 中使用 type 修饰符\:
js.import.options.use.import-type.always=始终使用 type
js.import.options.use.import-type.auto=自动
js.import.options.use.import-type.help=此选项用于配置导入类型时 TypeScript 'import type' 语句或类型说明符的用法。<br><br>选择“始终使用 type”时，会始终使用 'import type' 或类型说明符。<br> <br>选择“从不”时，所有类型都会像值一样导入，没有 'type' 关键字。<br><br>选择“自动”时，IDE 会检查 TypeScript 版本和 tsconfig.json 以选择最合适的选项。
js.import.options.use.import-type.never=从不
js.import.options.use.node.resolution=在 index.js 可用时使用目录导入(Node 样式模块解析)
js.imports.dependencies.group.name=Import 和依赖项
js.incompatible.types.comparison.inspection.name=类型不兼容的表达式的比较
js.incompatible.types.comparison.message=条件始终为 {0, choice, 0\#false|1\#true}，因为类型 ''{1}'' 和 ''{2}'' 没有重叠
js.indexer.to.property.intention=替换为属性访问
js.infer.parameter.types.intention=从用法中推断形参类型
js.infer.parameter.types.intention.failure.readonly.text=无法从用法中推断类型\: 为只读文件
js.infer.parameter.types.intention.failure.text=无法从用法中推断类型
js.infer.parameter.types.intention.failure.title=无法推断类型
js.infer.parameter.types.intention.jsdoc=从用法中推断 JSDoc 形参类型
js.infer.parameter.types.intention.progress.text=正在推断类型
js.inject.dont.format.intention.text=禁用注入内容的格式设置
js.inject.with.comment.intention.family.name=使用注释对注射做出注解
js.inspection.amd.modules.dependencies.family.name=缺少 AMD 模块依赖关系
js.inspection.async.group.name=Async 代码和 promise
js.inspection.bitwise.group.name=按位运算问题
js.inspection.convert.to.es6.group.name=ES2015 迁移协助
js.inspection.es6.modules.dependencies.family.name=缺少 import 语句
js.inspection.function.expression.is.used.instead.of.arrow=使用了函数表达式而不是箭头函数
js.inspection.group.name=常规
js.inspection.group.path=JavaScript 和 TypeScript
js.inspection.missing.amd.dependency=缺少 AMD 模块依赖关系
js.inspection.missing.import=缺少 import 语句
js.inspection.missing.module.dependency=缺少模块依赖关系
js.inspection.package.json.dependencies=package.json 中的依赖关系不匹配
js.inspection.package.json.update.dependency.to.latest.version=将 package.json 依赖项更新为最新版本
js.inspection.promise.ignored.display.name=返回 promise 的方法调用结果被忽略
js.inspection.promise.ignored.problem.descriptor=从 {0} 返回的 Promise 被忽略
js.inspection.promise.value.expected.problem.descriptor=应为值，但使用了从 {0} 返回的 Promise
js.inspection.switch.group.name=switch 语句问题
js.iterate=使用 'for..of' 进行迭代
js.iterate.async=使用 'for await..of' 进行迭代
js.join.declaration.assignment.inspection.fix=联接变量声明和赋值
js.join.declaration.assignment.inspection.name=变量声明可与变量的第一个赋值合并
js.join.vars.intention=加入后续变量声明
js.jquery.efficiency.inspection.allow.attribute.and.pseudo.selectors=允许特性和伪选择器
js.jquery.efficiency.inspection.attribute.used.message=jQuery 特性选择器可能低效
js.jquery.efficiency.inspection.duplicated.selector=重复的 jQuery 选择器
js.jquery.efficiency.inspection.name=可以优化 JQuery 选择器
js.jquery.efficiency.inspection.pseudoselector.used.message=jQuery 伪选择器可能低效
js.language.version.label=JavaScript 语言版本
js.last.comma.in.array.literal.inspection.name=数组字面量中的最后一个逗号多余
js.last.comma.in.object.literal.inspection.name=对象字面量中的最后一个逗号多余
js.library.attach.debug=附加调试版本(&D)…
js.library.attach.release=附加发布版本(&R)…
js.library.configurable.name=库
js.library.documentation=文档
js.library.download.fix=下载库
js.library.download.stubs.label=TypeScript 社区存根
js.library.downloading.library=正在下载库
js.library.successfully.downloaded=已成功下载 {0}
js.library.unresolved.url.inspection.name=HTTP 链接缺少本地存储的库
js.linter.guesser.linter.disabled={0} 已禁用。
js.linter.guesser.linter.enabled.because.of.config.file=已启用 {0}\: 配置文件位于项目中。
js.linter.guesser.linter.enabled.because.of.dependency=已启用 {0}\: ''{1}'' 列出在 package.json 中。
js.linter.guesser.linter.enabled.because.of.package.json.section=已启用 {0}\: ''{1}'' 位于 package.json 中。
js.linters.detect.automatically.caption=从最近的 package.json 检测软件包和配置文件
js.linters.inspection.group.name=代码质量工具
js.make.single.var.statement=设为单变量语句
js.method.can.be.static=方法可以为 'static'
js.method.can.be.static.option=仅检查 'private' 方法
js.mismatched.update.collection.inspection.name=不匹配的集合查询和更新
js.mismatched.update.collection.update.method.names=更新方法名称\:
js.missing.await.symbol.inspection.for.generator.name=异步生成器应使用 for-await 循环进行迭代
js.missing.await.symbol.inspection.for.returns=始终对异步函数调用使用 'await' 以避免错误，并帮助进行 V8 异步堆栈跟踪
js.missing.await.symbol.inspection.name=异步函数调用缺少 await
js.missing.switch.branches.ignore.with.default=忽略具有默认分支的 switch 语句
js.missing.switch.branches.inspection.desc=''switch'' 语句缺少 case\: {0}
js.missing.switch.branches.inspection.name='switch' 语句缺少分支
js.module.uml.presentable.name=JavaScript 模块依赖项
js.move.to.scope.start=将 var 语句移至作用域开始
js.move.type.to.file.family=移至名称匹配的文件
js.move.type.to.file.text=将 {0} 移至文件 {1}
js.named.to.anonymous.family.name=转换为函数表达式
js.named.to.arrow.text=转换为含有 {0} 的箭头函数
js.named.to.function.expression.text=转换为包含变量的函数表达式
js.named.to.function.hoisting.conflict.text=函数在声明之前使用。转换为变量后，将中断使用
js.nested.template.literal.fix=内联嵌套字面量
js.nested.template.literal.inspection=模板字面量中的冗余嵌套
js.node.service.memory.configurable.autoIncrease=如果可用，自动增加内存
js.node.service.memory.configurable.autoIncrease.hint=当需要更多内存时，将添加 {0,number,\#} MB 并重新启动 LS。最大限制为 {1,number,\#} MB
js.node.service.memory.configurable.footer=该设置适用于在 <code>node</code> 上运行的所有 TS 语言服务。<a href\="{0}">详细了解 LS 内存和故障排查。</a>
js.node.service.memory.configurable.header=语言服务内存
js.node.service.memory.configurable.manualIncrease=设置内存限制\:
js.node.service.memory.configurable.manualIncrease.MB=MB
js.node.service.memory.configurable.manualIncrease.addMB=添加 {0,number,\#} MB
js.node.service.memory.configurable.manualIncrease.validation.tooLarge=没有此大小的可用 RAM。请使用小于 {0,number,\#} MB 的值。
js.node.service.memory.oom.notification.actions.addMB=添加 {0,number,\#} MB
js.node.service.memory.oom.notification.actions.configure=配置…
js.node.service.memory.oom.notification.actions.disableAutoIncrease=禁用自动增加
js.node.service.memory.oom.notification.actions.enableAutoIncrease=启用自动增加
js.node.service.memory.oom.notification.actions.howTo=如何手动修复
js.node.service.memory.oom.notification.autoIncreased=该项目的语言服务内存大小已自动增加 {0,number,\#} MB
js.node.service.memory.oom.notification.content=这会影响自动补全和代码分析等基本功能。要解决此问题，请增加分配的内存。
js.node.service.memory.oom.notification.header=语言服务内存不足
js.node.services.profiler.disable=停止 Node.js 服务分析
js.node.services.profiler.enable=启动 Node.js 服务分析
js.param.hints.blacklist.pattern.explanation=要禁用方法或函数提示，请使用下面的其中一种模式\: <p style\="margin-left\: 5px"><code><b>(*info)</b></code> - 所有形参名称以 <em>info</em> 结尾的单形参方法<br><code><b>(key, value)</b></code> - 所有包含形参<em>键</em>和<em>值</em>的方法<br><code><b>*.put(key, value)</b></code>- 所有包含<em>键</em>和<em>值</em>形参的 <em>put</em> 方法<br><code><b>Console.log(*, *)</b></code> - 正好包含两个形参的 <em>Console</em> 类型的 <em>log</em> 方法</p><br><p>必须为所有形参(包括可选形参)提供名称或占位符。<br>限定方法名称必须包含类或接口名称或占位符。<br>在编辑代码时，请使用“不为当前方法显示提示”{0} 操作来添加模式。</p>
js.param.hints.show.names.for.all.args=非字面量实参
js.param.hints.show.names.for.literal.args=字面量实参
js.param.hints.show.names.for.pipes=管道运算符
js.param.hints.show.names.for.tagged=标记的模板实参
js.possibly.async.function.inspection=非异步函数中的 'await'
js.possibly.async.function.quick.fix=令函数 {0} 为异步函数
js.possibly.async.function.quick.fix.family.name=将函数设为异步
js.potentially.invalid.constructor.usages.inspection.name=可能无效的构造函数用法
js.potentially.invalid.target.of.indexed.property.access.inspection.name=索引的属性访问的目标可能不正确
js.potentially.invalid.usage.of.class.this.inspection.name=从闭包对类中 'this' 的引用可能无效
js.potentially.invalid.usage.of.this.inspection.name=从闭包对 'this' 的引用可能无效
js.primitive.type.improper.instantiation.inspection={0} 实例化可以简化
js.primitive.type.wrapper.usage.inspection=使用了基元类型对象包装器
js.probable.bugs.group.name=可能的 bug
js.progress.title.auto-importing-symbols-on-paste=粘贴时自动导入外部符号…
js.property.can.be.replaced.with.shorthand=属性可被替换为速记形式
js.property.can.be.replaced.with.shorthand.method=属性可被替换为速记方法
js.property.to.indexer.intention=替换为索引器访问
js.pull.up.will.be.made.abstract=非 abstract {0}将被设为 abstract
js.quote.unquote.intention.plural={0} 属性名称
js.quote.unquote.intention.quote=引用
js.quote.unquote.intention.quote.family=使用引号包装属性名称
js.quote.unquote.intention.singular={0} 属性名称
js.quote.unquote.intention.unquote=取消引用
js.quote.unquote.intention.unquote.family=移除属性名称中的引号
js.react.group.name=React
js.redundant.await.inspection=冗余 'await' 表达式
js.redundant.switch.problems.inspection.default='switch' 语句仅包含一个 'default' 子句
js.redundant.switch.problems.inspection.default.unwrap=解包 'switch' 语句
js.redundant.switch.problems.inspection.empty='switch' 语句为空
js.redundant.switch.problems.inspection.empty.remove=移除空的 'switch' 语句
js.redundant.switch.problems.inspection.name='switch' 语句冗余，可以替换
js.redundant.switch.problems.inspection.side.effects=并提取副作用
js.redundant.switch.problems.inspection.single='switch' 语句仅包含一个非默认子句
js.redundant.switch.problems.inspection.single.replace=将 'switch' 替换为 'if'
js.referencing.mutable.variable.from.closure.inspection.name=从闭包中引用可变变量
js.regex.flag.d=匹配索引 - 用于子字符串匹配的索引
js.regex.flag.g=全局匹配 - 返回所有匹配项
js.regex.flag.i=忽略大小写 - 不区分大小写的匹配
js.regex.flag.m=多行 - ^ 和 $ 的每行匹配
js.regex.flag.s=dotAll - . 匹配换行符
js.regex.flag.u=unicode - 完整 unicode 支持
js.regex.flag.y=粘性 - 在确切的位置搜索
js.remove.digit.separators=移除数字分隔符
js.remove.redundant.initializer.fix=移除冗余的初始值设定项
js.remove.unused.assignment=移除未使用的赋值
js.rename.base.member=重命名基{0}
js.rename.component.usage.provide.name.error=组件名称应为有效的 JavaScript 标识符
js.rename.component.usage.provide.name.message=输入新组件名称
js.rename.component.usage.provide.name.title=重命名组件
js.rename.current.member=重命名当前 {0}
js.rename.file.to.match.type.name=将文件重命名为 {0} 以匹配 {1} 名称
js.rename.file.to.match.type.name.family=重命名文件以匹配类型名称
js.rename.member.title={0} {1} {3} 的 {2}
js.rename.member.title.implements=实现
js.rename.member.title.overrides=重写
js.rename.search.for.component.usages=搜索组件用法(&O)
js.replace.string.concatenation.with.es6.template.fix.text=替换为模板字符串
js.replace.string.concatenation.with.es6.template.inspection.name=已使用字符串串联而不是模板字面量
js.replace.string.with.es6.template=替换为模板字符串
js.replace.with.literal=替换为 {0} 字面量
js.replace.with.shorthand.method.quick.fix=替换为速记方法
js.replace.with.shorthand.property.quick.fix=替换为速记属性
js.replace.with.type.cast.to.primitive=替换为 {0} 的类型转换
js.search.for.default.imports=正在搜索 default import…
js.search.for.named.imports=正在搜索命名 import…
js.searching.for.component.usages=正在搜索组件用法…
js.separate.bytes=分隔字节
js.separate.digits=分隔数字
js.separate.nibbles=分隔半字节
js.separate.thousands=分隔千分位
js.separate.thousands.in.integer.part=分隔整数中的千分位
js.separate.words=分隔 16 位单词
js.show.dynamic.usages=显示动态用法
js.show.type.info.action.error=找不到表达式
js.space.before.function.left.brace=函数左大括号
js.spaces.in.flow.category=在 Flow 中
js.split.declarations=拆分声明
js.split.into.multiple.declarations=拆分为多个声明
js.statement.context.type=语句
js.strict.mode.inspection.error={0} 不处于严格模式下
js.strict.mode.inspection.fix=添加“use strict”杂注
js.strict.mode.inspection.name=使用了非严格模式
js.strict.mode.inspection.redundant.pragma="use strict"杂注冗余
js.strict.mode.remove.pragma=移除“use strict”杂注
js.string.template.line.separators.multispan=转换为多行字符串模板
js.string.template.line.separators.multispan.family.name=转换为多行字符串模板
js.string.template.line.separators.visible=转换为可见行分隔符
js.string.template.line.separators.visible.family.name=转换模板字符串以使用可见行分隔符
js.suspicious.bind.with.arrow.function=箭头函数 'bind' 用法可疑
js.suspicious.eq.plus.fix.name=替换为 '+\='
js.suspicious.eq.plus.inspection.desc=可疑的 '\=+' 赋值\: '+\=' 可能拼写错误
js.suspicious.eq.plus.inspection.name=可疑的 '\=+' 赋值
js.suspicious.name.assignment=''{0}'' 可能不应分配给 ''{1}''
js.suspicious.name.combination.inspection.name=可疑的变量/形参名称组合
js.suspicious.name.parameter=''{0}'' 可能不应作为形参 ''{1}'' 传递
js.suspicious.name.return=''{0}'' 可能不应从方法 ''{1}'' 返回
js.switch.no.default='switch' 语句没有 'default' 分支
js.switch.no.default.add=创建缺少的默认分支
js.switch.to.jsx.inspection.dismiss=关闭
js.testing.autoWatch.action.name=监视更改
js.testing.highlight.line=在测试代码中高亮显示失败的行
js.testing.inspection.group.name=单元测试
js.tool.window.limit=显示前 {0} 个错误。
js.tool.window.limit.all=查看所有 {0} 个错误
js.top.level.await.expression.inspection=顶层 'await' 表达式
js.top.level.await.expression.inspection.description=使用了顶层 'await' 表达式
js.top.level.statement.context.type=顶级语句
js.trailing.comma.keep=保持
js.trailing.comma.remove=移除
js.trailing.comma.whenMultiline=多行时添加
js.undeclared.variable.inspection.name=隐式声明的全局 JavaScript 变量
js.undefined.property.assignment.inspection.message=类型 {1} 中未定义属性 {0}
js.undefined.property.assignment.inspection.name=未定义的属性赋值
js.unfiltered.for.in.loop.inspection.name=未过滤 for..in 循环
js.unfiltered.for.in.loop.skip.primitives=使用数组或对象初始值设定项跳过引用迭代
js.unfiltered.for.in.loop.skip.primitives.tooltip=在未修改 Object.prototype 和 Array.prototype 时启用它
js.unnecessary.semicolon.fix.name=移除不必要的分号
js.unnecessary.semicolon.inspection.name=不必要的分号
js.unnecessary.semicolon.problem=不必要的分号 \#loc
js.unreachable.switch.branches.ignore.with.dynamic=不在动态类型的上下文中显示此警告
js.unreachable.switch.branches.inspection.desc=不可到达的 'case' 分支
js.unreachable.switch.branches.inspection.name=不可到达 'switch' 语句的 'case' 分支
js.unreachable.switch.branches.remove=移除不可到达的 'case' 分支
js.unresolved.variable.inspection.name=未解析的引用
js.unused.assignment.inspection.name=未使用的赋值
js.unused.es6.import.inspection.name=未使用的 import
js.unused.global.symbol.inspection.name=未使用的全局符号
js.unused.local.symbol.inspection.name=未使用的局部符号
js.unused.symbol=未使用的 {0} \#ref
js.unused.symbol.full=未使用的 {0}
js.unused.symbol.remove=移除未使用的 {0}
js.unused.symbols.group.name=未使用的符号
js.unwanted.symbols.group.name=可能不合需要的代码结构
js.url.import.usage.inspection.download.module.0.quick.fix.failed=下载模块 ''{0}'' 失败
js.url.import.usage.inspection.download.module.0.quick.fix.progress=正在下载模块 ''{0}''
js.url.import.usage.inspection.download.module.0.quick.fix.success=模块 ''{0}'' 已成功下载
js.url.import.usage.inspection.download.module.0.quick.fix.warning=模块 ''{0}'' 已下载，但有错误
js.url.import.usage.inspection.download.module.0.quick.fix.warning.urls=失败的 URL\:
js.url.import.usage.inspection.download.module.quick.fix.name=下载模块
js.url.import.usage.inspection.name=使用了 URL 导入
js.usage.type.call=函数调用中的用法
js.validate.jsdoc.inspection.name=JSDoc 中的语法错误和未解析的引用
js.validate.signature.inspection.name=签名不匹配
js.validate.types.inspection.name=类型不匹配
js.validity.issues.group.name=有效性问题
js.value.assigned.is.never.used=从未使用过所赋之值 \#loc
js.value.assigned.to.is.never.used=赋给 ''{0}'' 的值从未使用 \#loc
js.variable.initializer.is.redundant=变量初始值设定项冗余 \#loc
js.variable.might.not.been.initialized=变量可能尚未初始化 \#loc
js.variable.problems.ignore.desc=对可变变量忽略
js.variable.problems.inspection.desc=变量 ''{0}'' 在子句 ''{1}'' 中声明， 但在子句 ''{2}'' 中使用
js.variable.problems.inspection.desc.ref.error=访问时引用错误
js.variable.problems.inspection.name=声明了变量并在不同的 'case' 子句中使用
js.void.function.result.used.description=使用了 void 函数返回值
js.void.function.result.used.name=使用了 void 函数返回值
js.wrap.settings.class.decorators=类装饰器
js.wrap.settings.class.field.decorators=类字段装饰器
js.wrap.settings.class.method.decorators=类方法装饰器
js.wrap.settings.function.parameter.decorators=函数形参装饰器
js.wrap.settings.import=ES6 导入/导出
js.wrap.settings.object.types=对象类型
js.wrap.settings.union.and.intersection.types=联合体与相交类型
js.wrap.settings.var.group.name=变量声明
jshint.clear.field.to.disable=清除要禁用的字段
jshint.config.default.description=<div style\="padding-bottom\:10px"><div><b>.jshintrc</b></div><div style\="padding-left\:10px; padding-top\:4px;">对 JavaScript 文件进行 Linting 检查时，IDE 会从文件所在的文件夹开始查找 .jshintrc，然后上行到文件系统根目录。</div></div><div><div><b>package.json</b></div><div style\="padding-left\:10px; padding-top\:4px;">将您的配置添加到项目的 package.json 文件中的 <code>jshintConfig</code> 属性下。</div></div>
jshint.config.error.cannot.locate.ext.config=JSHint\: 无法定位扩展配置
jshint.config.error.cannot.parse.ext.config=JSHint\: 无法解析扩展配置
jshint.config.error.failed.to.read.property=无法从 package.json 读取 ''{0}'' 属性
jshint.config.extends.cyclically=JSHint 配置循环扩展
jshint.config.failed.to.read=无法读取 JSHint 配置
jshint.config.option.custom.browser.title=选择 JSHint 配置文件 (*.jshintrc)
jshint.config.option.custom.name=自定义配置文件
jshint.config.option.default.name=默认
jshint.exception.balloon.action.configure.proxy.or.retry=<a href\=''{0}''>配置 HTTP 代理</a>或<a href\=''{1}''>重试</a>
jshint.exception.balloon.action.retry=<a href\=''{0}''>重试</a>
jshint.illegal.integer=非法整数
jshint.inspection.message.config.not.found=未找到 JSHint 配置
jshint.inspection.message.duplicate.options=重复 JSHint 选项\: {0}，{1}。
jshint.inspection.message.expected.value=预期值\: {0}
jshint.inspection.message.expected.values.x.or.y=预期值\: {0} 或 {1}
jshint.inspection.message.malformed.config=JSHint 配置格式错误
jshint.inspection.message.not.loaded=未加载 JSHint {0}
jshint.inspection.message.object.or.array.expected=应为对象或数组
jshint.inspection.message.prefix=JSHint\:
jshint.inspection.message.unexpected.jshint.option.name=意外的 JSHint 选项名称
jshint.inspection.message.unexpected.value=意外值
jshint.label.bundled.suffix=(捆绑)
jshint.label.no.version=无版本
jshint.latedef.false.text=不警告
jshint.latedef.nofunc.text=<html><body>禁止变量在未定义的情况下使用，<br>但允许函数声明。</body></html>
jshint.latedef.true.text=禁止变量在未定义的情况下使用
jshint.option.asi.description.short=禁止缺少分号的警告
jshint.option.bitwise.description.short=有关使用逐位运算符的警告
jshint.option.boss.description.short=禁止有关 <code>if/for/…</code> 内部赋值的警告
jshint.option.browser.description.short=浏览器
jshint.option.camelcase.description.short=有关变量命名的警告
jshint.option.curly.description.short=块省略 <code>{}</code> 时发出警告
jshint.option.debug.description.short=禁止有关调试模式的警告
jshint.option.devel.description.short=开发
jshint.option.edit.dialog.title=设置 ''{0}'' 选项
jshint.option.elision.description.short=禁止有关 ES3 数组省略元素的警告
jshint.option.enforceall.description.short=代码未遵守最严格的配置时发出警告
jshint.option.eqeqeq.description.short=有关不安全比较的警告
jshint.option.eqnull.description.short=禁止有关 <code>\=\= null</code> 的警告
jshint.option.es3.description.short=有关与 ES3 规范不兼容的警告
jshint.option.es5.description.short=有关与 ES5 规范不兼容的警告
jshint.option.esnext.description.short=EcmaScript.next
jshint.option.esversion.description.short=在与指定的 ECMAScript 版本不兼容时发出警告
jshint.option.evil.description.short=禁止有关 <code>eval</code> 的警告
jshint.option.expr.description.short=禁止有关将表达式用作语句的警告
jshint.option.forin.description.short=有关不安全 <code>for..in</code> 的警告
jshint.option.freeze.description.short=有关覆盖原生对象原型的警告
jshint.option.funcscope.description.short=禁止有关在已声明块外部使用变量的警告
jshint.option.futurehostile.description.short=有关使用在以后的 JavaScript 版本中定义的标识符的警告
jshint.option.gcl.description.short=将 JSHint 设为与 Google Closure Compiler 兼容
jshint.option.globalstrict.description.short=禁止有关使用全局严格模式的警告
jshint.option.immed.description.short=有关未使用括号包装函数而直接调用函数的警告
jshint.option.indent.description.short=缩进
jshint.option.iterator.description.short=禁止有关 <code>__iterator__</code> 属性的警告
jshint.option.lastsemic.description.short=禁止有关缺少分号的警告，但仅当单行块中的最后一条语句省略分号时才显示该警告
jshint.option.latedef.description.short=当变量在未定义的情况下使用时发出警告
jshint.option.laxbreak.description.short=禁止有关不安全换行的警告
jshint.option.laxcomma.description.short=禁止有关编码样式以逗号开头的警告
jshint.option.loopfunc.description.short=禁止有关函数在循环内部的警告
jshint.option.maxcomplexity.description.short=代码中的最大循环复杂度
jshint.option.maxdepth.description.short=块的最大深度
jshint.option.maxerr.description.short=最大错误数
jshint.option.maxlen.description.short=行的最大长度
jshint.option.maxparams.description.short=函数中的最大形参数量
jshint.option.maxstatements.description.short=函数中的最大语句数量
jshint.option.module.description.short=ECMAScript 6 模块
jshint.option.moz.description.short=检查代码是否使用 Mozilla JavaScript 扩展
jshint.option.multistr.description.short=禁止有关多行字符串的警告
jshint.option.newcap.description.short=有关使用非大写形式的构造函数的警告
jshint.option.noarg.description.short=有关 <code>arguments.caller</code> 和 <code>.callee</code> 的警告
jshint.option.nocomma.description.short=有关使用逗号运算符的警告
jshint.option.noempty.description.short=有关空块的警告
jshint.option.nomen.description.short=不允许使用 _ in 变量
jshint.option.nonbsp.description.short=有关“不间断空格”字符的警告
jshint.option.nonew.description.short=有关副作用 <code>new</code> 用法的警告
jshint.option.nonstandard.description.short=转义和未转义
jshint.option.notypeof.description.short=禁止有关无效 <code>typeof</code> 运算符值的警告
jshint.option.noyield.description.short=禁止在生成器函数中无 yield 语句时有关生成器函数的警告
jshint.option.onevar.description.short=每个函数一个变量语句
jshint.option.passfail.description.short=出现第一个错误时停止
jshint.option.plusplus.description.short=有关使用一元递增和递减运算符的警告
jshint.option.predef.description.short=预定义(以 , 分隔)
jshint.option.predef.details=指定全局变量及其可分配状态\:\n<pre>DISQUS\:true、jQuery\:false</pre>\n<p/>此时，JSHint 允许您重写 DISQUS，但禁止重写 jQuery。
jshint.option.proto.description.short=禁止有关 <code>__proto__</code> 属性的警告
jshint.option.quotmark.description.short=引号
jshint.option.scripturl.description.short=禁止有关使用以脚本为目标的 URL 的警告
jshint.option.shadow.description.short=禁止有关变量隐藏的警告
jshint.option.singlegroups.description.short=如果未严格要求使用分组运算符，禁止使用该运算符
jshint.option.smarttabs.description.short=在空格仅用于对齐时，禁止有关将制表符和空格混合使用的警告
jshint.option.strict.description.short=代码未采用严格模式时发出警告
jshint.option.sub.description.short=如果可以使用点符号表示 <code>[]</code> 符号，则禁止有关使用后者的警告
jshint.option.supernew.description.short=禁止有关“怪异”构造的警告
jshint.option.trailing.description.short=有关尾随空格的警告
jshint.option.typed.description.short=输入的数组
jshint.option.undef.description.short=未定义变量时发出警告
jshint.option.unused.description.short=存在未使用的变量时发出警告
jshint.option.validthis.description.short=禁止有关可能违反严格要求的警告
jshint.option.varstmt.description.short=有关使用 VariableStatements 的警告
jshint.option.white.description.short=不允许使用杂乱的空格
jshint.option.withstmt.description.short=禁止有关使用 with 语句的警告
jshint.option.worker.description.short=Web 工作线程
jshint.option.wsh.description.short=Windows Script Host
jshint.options.tree.tooltip.set.a.new.value=设置新值
jshint.progress.title=JSHint {0}
jshint.progress.title.downloading=正在下载 {0}
jshint.progress.title.updating.jshint=正在将 JSHint 更新到 {0}
jshint.quotmark.double.text=仅允许双引号
jshint.quotmark.false.text=允许两种引号
jshint.quotmark.single.text=仅允许单引号
jshint.quotmark.true.text=仅允许单引号或双引号
jshint.suppress.text.suppress.for.line=禁止行
jshint.tree.link.set=设置
jshint.unused.false.text=不检查任何内容
jshint.unused.strict.text=检查所有变量和形参
jshint.unused.true.text=<html><body>检查所有变量和形参，但允许<br>使用的形参后存在未使用形参</body></html>
jshint.unused.vars.text=检查变量，而不是函数形参
jshint.use.config.files=使用配置文件
jshint.version.label=版本(&V)\:
jsx.code.style.attribute.default.value=为 JSX 特性添加\:
jsx.code.style.attribute.default.value.braces=大括号
jsx.code.style.attribute.default.value.none=无
jsx.code.style.attribute.default.value.quotes=引号
jsx.code.style.attribute.default.value.typebased=基于类型
jsx.convert.html.attributes.to.jsx=将代码粘贴到 JSX 文件时关闭 HTML 单一标记
jsx.convert.html.attributes.to.react=将代码粘贴到 React JSX 文件时转换 HTML 特性名称
jsx.convert.html.to.jsx.command.name=将 HTML 代码转换为 JSX
jsx.convert.html.to.jsx.progress=正在将 HTML 代码转换为 JSX…
jsx.dom.nesting.inspection.message=''{0}'' 不能作为 ''{1}'' 的子级出现
jsx.dom.nesting.inspection.message.text=文本节点不能显示为 ''{0}'' 的子级
jsx.dom.nesting.inspection.message.tr=''{0}'' 不能作为 ''{1}'' 的子级出现。在您的代码中添加 <tbody>、<thead> 或 <tfoot> 以匹配浏览器生成的 DOM 树。
jsx.dom.nesting.inspection.name=无效的 DOM 元素嵌套
jsx.html.context.type=JSX HTML
jsx.missing.namespace.inspection.name=缺少 JSX 命名空间
jsx.missing.namespace.inspection.text=在未导入 {0} 的情况下使用 JSX
jsx.syntax.used.description=已使用 JSX 语法
jsx.syntax.used.name=已使用 JSX 语法
jsx.unresolved.component.name=未解析的 JSX 组件
jsx.unresolved.prop.name=未解析的 JSX 属性
label.compiles.js.files=编译 .js 文件
label.compress.js.files=压缩 .js 文件
label.exclude.methods.classes=排除类方法\:
label.import.popup=自动导入工具提示
label.method.should.be.defined=方法应已定义
label.minimum.language.level=最低语言级别\:
label.name.injection=名称(&N)\:
label.namespace=命名空间\:
label.path=路径(&P)\:
label.wsl.node.interpreter=WSL Node.js 运行时(&N)\:
linemarker.implemented=已实现
linemarker.implementing=实现
linemarker.implements.invalid=<无效>
linemarker.implements.several=实现多种接口方法
linemarker.implements.text=实现 {1} 中的 {0}
linemarker.javascript.sources=JavaScript 源
linemarker.javascript.typescript=JavaScript/TypeScript 行标记
linemarker.overridden=重写
linemarker.overrides.text=重写 {1} 中的 {0}
linemarker.overriding=重写
linemarker.typescript.declaration=TypeScript 声明
list.item.class.field=类字段
list.item.declarations.function.members.to.be.converted.to.class.members=要转换为类成员的函数成员的声明
list.item.declarations.that.were.not.converted=未转换的声明
list.item.function.converted.to.class=转换为类的函数
list.item.function.to.be.converted.to.class=要转换为类的函数
list.item.global.or.module.constant=全局或模块常量
list.item.google.javascript.style.guide=Google JavaScript 样式指南
list.item.javascript.file=JavaScript 文件
list.item.javascript.jsx.file=JSX 文件
list.item.javascript.standard.style=JavaScript 标准样式
list.item.local.constant=局部常量
list.item.typescript.file=TypeScript 文件
list.item.typescript.jsx.file=TypeScript JSX 文件
live.template.con.description=带 props 实参的构造函数
live.template.fsc.description=React Flow 箭头函数组件
live.template.fsf.description=React Flow 函数组件
live.template.props.description=this.props.
live.template.rcc.description=React 类组件
live.template.rccp.description=带有 PropTypes 的 React 类组件
live.template.rcfc.description=带有 PropTypes 和生存期方法的 React 类组件
live.template.rsc.description=React 箭头函数组件
live.template.rscp.description=带有 propTypes 的 React 箭头函数组件
live.template.rsf.description=React 函数组件
live.template.rsfp.description=带有 propTypes 的 React 函数组件
live.template.rsi.description=带有隐式 return 的 React 箭头函数组件
live.template.state.description=this.state.
livetemplate.description.arf=使用箭头函数包围
livetemplate.description.console.assert=console.assert()
livetemplate.description.console.error=console.error()
livetemplate.description.console.info=console.info()
livetemplate.description.console.log=console.log()
livetemplate.description.console.trace=console.trace()
livetemplate.description.console.warn=console.warn()
livetemplate.description.defi=插入 define() 表达式
livetemplate.description.exportall=导出语句 - 从 'a' 导出 *
livetemplate.description.exportfrom=导出语句 - 从 ''a'' 导出 {b} 
livetemplate.description.exportitems=导出语句 - export {b}
livetemplate.description.flow=插入 @flow 注解
livetemplate.description.fori=创建迭代循环
livetemplate.description.importdefault=import 语句 - 从 'a' 导入 b
livetemplate.description.importfrom=import 语句 - 从 ''a'' 导入 {b}
livetemplate.description.importns=import 语句 - 从 'a' 导入 * as b
livetemplate.description.itar=遍历数组元素
livetemplate.description.iter=迭代 (for..of)
livetemplate.description.itera=迭代 (for await..of)
livetemplate.description.itin=迭代(for..in)
livetemplate.description.moduleexports=导出语句 - module.exports \= a
livetemplate.description.ref=插入引用路径注释
livetemplate.description.ritar=以相反顺序遍历数组的元素
livetemplate.description.us=插入 'use strict' 语句
lsp.executable.error=找不到 {0} 的可执行文件。
lsp.interpreter.error=未配置本地或 WSL Node.js 运行时。
macro.js.component.type.of=jsComponentTypeOf(Array)
macro.js.suggest.default.variable.kind=jsSuggestDefaultVariableKind(Boolean)
make.method.static=设为 'static'
make.private=设为 private
members.to.implement.chooser.title=选择要实现的成员
members.to.override.chooser.title=选择要重写的成员
merged.process.output.text={0}{2, choice, 0\#\n\n标准错误\:\n{1}|1\#}{4, choice, 0\#\n\n标准输出\:\n{3}|1\#}\n\n{5}
method.return.types.in.call.chains=调用链中的函数返回值类型
modules.selected=选定
move.members.dialog.title=移动成员
move.members.refactoring.name=移动成员
multiple.inheritance=多重继承
new.actionscript.class.dialog.title=新建 ActionScript 类
new.actionscript.interface.dialog.title=新建 ActionScript 接口
new.constructor.action.description=创建构造函数
new.constructor.action.text=构造函数
new.field.action.description=在类中创建新字段
new.field.action.text=字段
new.method.action.description=在类中创建新方法
new.method.action.text=方法
no.candidates=无候选项
no.executable.found.in.path=在 {0, choice, 0\#%PATH%|1\#$PATH} 中未找到可执行文件
no.members.to.implement=找不到要实现的成员
no.members.to.override=找不到要重写的成员
no.methods.to.implement=找不到要实现的方法
no.methods.to.override=找不到要重写的方法
no.variables.for.getter=找不到没有 getter 的字段
no.variables.for.getter.setter=找不到没有 getter 和 setter 的字段
no.variables.for.setter=找不到没有 setter 的字段
node.core.core_modules_fetch_timed_out.dialog.message=无法提取核心模块\: 已超时
node.core.enable_coding_assistance_intention.name=启用 Node.js 的编码辅助
node.core.failed_to_fetch_node_core_modules.dialog.message=无法提取 Node 核心模块
node.core.make.sure.javascript.debugger.plugin.enabled.dialog.message=确保已启用 'JavaScript Debugger' 插件
node.core.navigate_action_text.text=配置 Node.js…
node.core.not_ready_for_core_modules_configuration.dialog.message=未准备好进行核心模块配置
node.debug.cannot_connect_to_vm.error.message=无法连接到虚拟机 {0}
node.debug.cannot_get_localhost_IPv4.error.message=无法获取 127.0.0.1 IPv4
node.download.broken.installation.error=Node.js 安装损坏。
node.download.cannot_find_interpreter.error=找不到已下载的 Node.js 运行时。
node.download.dialog.error.failed_to_fetch_versions=无法提取可用的 Node.js 版本
node.download.dialog.full.version.label=版本\:
node.download.dialog.location.description=选择下载 Node.js 的路径\:
node.download.dialog.location.error.blank=位置路径为空
node.download.dialog.location.error.existing_non_empty_directory=位置指向现有的非空目录
node.download.dialog.location.error.failed_to_resolve=无法解析位置
node.download.dialog.location.error.file.exists=位置指向现有文件
node.download.dialog.location.label=位置\:
node.download.dialog.major.version.label=发布\:
node.download.dialog.no_version.label=无版本
node.download.dialog.ok_text=下载
node.download.dialog.released_on.label={0} 发布
node.download.dialog.unavailable.label=不可用
node.download.download.cancelled.error=操作已被取消。
node.download.editor.suggestion={0} 需要 Node.js 才能正常工作。
node.download.failure.notification=无法下载 Node.js {0}。{1}
node.download.fetching.version=正在提取 Node.js 版本…
node.download.node.archive=正在下载 Node.js {0}
node.download.open.settings=打开设置
node.download.success.notification=Node.js {0} 已配置。
node.download.supported_later.platform=Node.js 在版本 {2} 或更高版本中支持 {0}，{1}
node.download.unsupported.platform=Node.js 不支持 {0}，{1}
node.execution.failed.to.prepare.target.environment.error=无法准备环境\: {0}
node.execution.starting.process.progress.title=正在启动 ''{0}''…
node.interpreter.command_timed_out.dialog.message=''{0}'' 命令运行超时(>{1} 毫秒)
node.interpreter.download=下载 Node.js
node.interpreter.field.add.item.text=添加…
node.interpreter.field.popup.download.item=下载…
node.interpreter.field.unexpected_value.text=意外值 {0}
node.interpreter.invalid_interpreter.error.message=无效 ''{0}''
node.interpreter.label=Node 运行时(&R)\:
node.interpreter.no_local_interpreter.error.message=没有本地 Node.js 运行时
node.interpreter.node_from_path.reference.name=node
node.interpreter.not.found=找不到 {0}
node.interpreter.project_node.reference.name=项目
node.interpreter.reference_not_found.text=未找到
node.interpreter.specified_interpreter_correctly.dialog.message=请正确指定 Node.js 运行时
node.interpreter.unavailable.target=不可用的目标\: {0}
node.interpreter.unresolved_reference.error.message=未解析的运行时 ''{0}''
node.interpreter.unspecified.error.text=请指定 Node.js 运行时
node.interpreter.unspecified_interpreter.dialog.message=请指定 Node.js 运行时
node.interpreter.unspecified_interpreter_with_link.dialog.message=请指定 <a href\="">Node.js 运行时</a>
node.interpreter.unspecified_local_interpreter.dialog.message=请指定本地 Node.js 运行时
node.js.add.interpreter.action=添加{0}…
node.js.configure.interpreter=配置{0}
node.js.downloading=正在下载 Node.js {0}
node.js.inspection.group.name=Node.js
node.js.interpreters=Node.js 运行时
node.js.invalid.node=该项目使用了无效的 Node.js 路径。<br>它已更新为使用 {0} 中的 Node.js。
node.js.missing.require=缺少 require() 语句
node.js.quickfix.install.node.module.devDependencies.family.name=安装模块作为开发依赖关系
node.js.quickfix.install.node.module.error.no.interpreter.text=无法安装 Node.js 模块\: 请指定默认 Node.js 运行时。
node.js.quickfix.install.node.module.error.no.interpreter.title=安装 Node.js 模块
node.js.quickfix.install.node.module.error.prefix.text=无法安装 Node.js 模块\: {0}
node.js.quickfix.install.node.module.family.name=安装模块
node.js.quickfix.install.node.module.text=安装 ''{0}''
node.js.quickfix.install.node.module.update.modules.family.name=运行 'npm install'
node.js.quickfix.install.node.module.with.dev.dependencies.text=安装 ''{0}'' 作为开发依赖关系
node.js.quickfix.run.command=运行 ''{0}''
node.js.remote.interpreters.plugin.missing=缺少 Node.js 远程解释器插件。请启用 {0} 中的插件
node.js.select.file=选择 {0} 文件
node.js.set.project.interpreter.action=设置为项目运行时
node.js.unresolved.api=未解析的 Node.js API
node.no.interpreter=无运行时
node.npm.cannot_find_package_by_reference.dialog.message=找不到软件包管理器 ''{0}''
node.npm.cannot_find_project_package_manager.dialog.message=找不到项目 Node.js 软件包管理器
node.npm.cannot_resolve_package_manager.dialog.message=无法解析 ''{0}'' 软件包管理器
node.npm.correct_path_to_npm_or_yarn_package.dialog.message=指定 npm 或 yarn 软件包的正确路径\: 无此类目录“{0}”
node.npm.invalid_package_manager.binary_file_not_found.dialog.message=指定有效的软件包管理器\: 在 ''{0}'' 目录内部找不到二进制文件
node.npm.package_manager_link.text=软件包管理器
node.npm.project_package_manager_disallowed_here.dialog.message=无法在此处引用项目 npm 软件包
node.npm.specify_npm_or_yarn_package.dialog.message=指定 npm 或 yarn 软件包
node.npm.unspecified_package_manager.dialog.message=未指定软件包管理器
node.package.binary.file.hint=指向 {0} 的二进制文件的路径
node.package.cannot.find.bin.file.dialog.message=找不到 ''{0}'' 软件包的 bin 文件
node.package.dropDownList.select=选择…
node.package.empty.error.message=项目名称为空
node.package.empty.hint={0} 软件包目录路径
node.package.empty.hint.pkg1.or.pkg2={0} 或 {1}
node.package.field.not_found.text=未找到
node.package.manager.label=软件包管理器 (&M)\:
node.package.name.URL-friendly.characters.error.message=项目文件夹名称应仅包含适用于 URL 的字符
node.package.name.capital.letters.error.message=项目文件夹名称不应包含大写字母
node.package.name.core.module.error.message=''{0}'' 不能用作项目名称，因为它是 Node.js 核心模块的名称
node.package.name.forbidden.error.message=''{0}'' 不能用作项目名称
node.package.name.leading.or.trailing.spaces.error.message=项目文件夹名称不应包含前导空格或尾随空格
node.package.name.period.error.message=项目文件夹名称不应以句点开头
node.package.name.special.characters.error.message=项目文件夹名称不应包含特殊字符("~'\!()*")
node.package.name.too.long.error.message=项目文件夹名称不应超过 214 个字符
node.package.name.underscore.error.message=项目文件夹名称不应以下划线开头
node.package.none=无软件包
node.package.selector.multiple.packages.binary.file.title=选择 {0} 的软件包目录或二进制文件
node.package.selector.multiple.packages.description=选择 {0}
node.package.selector.multiple.packages.title=选择软件包目录
node.package.selector.single.package.title=选择 {0} 软件包目录
node.package_documentation.installed_version.text=已安装版本\: {0}
node.package_documentation.latest_version.text=最新版本\: {0}
node.wsl.network.connection.failure=无法建立从 WSL 到 Windows 主机的网络连接(可能被防火墙阻止)。\n要了解详细信息，请参阅\: https\://jb.gg/wsl-firewall
node.wsl.unavailable.dialog.message=WSL 不可用
non.ascii.identifiers.inspection.name=包含非 ASCII 符号的标识符
non.ascii.identifiers.mixed.set=<html>名称同时包含 ASCII 和非 ASCII 符号\: {0}</html>
non.ascii.identifiers.non.ascii.found=<html>名称包含非 ASCII 符号\: {0}</html>
non.ascii.identifiers.only.ascii=仅允许 ASCII 名称
non.parenthesized.single.parameter=未使用括号括起来的单个形参
non.parenthesized.single.parameter.description=未使用括号括起来的单个形参
not.installed.package=未安装软件包
notification.content.html.href.settings.show.inspection.settings.or.href.undo.undo.html=<html><a href\='settings'>显示检查设置</a>或<a href\='undo'>撤消</a></html>
notification.content.notifications.are.enabled.for.all.package.json.files=为所有 package.json 文件启用通知
notification.content.notifications.are.enabled.for.current.package.json=为当前 package.json 启用通知
notification.content.show.details=显示详细信息
notification.group.code.vision.performance.watcher=JavaScript\: Code Vision 性能观察程序
notification.group.grunt.console=Grunt 'watch' 任务状态已更改
notification.group.jest=Jest 测试执行失败
notification.group.linters=JavaScript linter
notification.group.narrowed.types=JavaScript\: 已禁用缩小的类型的着色
notification.group.nodejs.assistance=Node.js 编码辅助失败
notification.group.nodejs.interpreter=Node.js 运行时路径已更新
notification.group.package.json=来自 package.json 的依赖项可用
notification.group.package.json.disabled=来自 package.json 的依赖项\: 通知已禁用
notification.group.project.generator=JavaScript 项目生成失败
notification.group.vitest=Vitest 测试执行失败
notification.provideInlayHints.group=provideInlayHints 状态
notification.provideInlayHints.serviceDisabled=<code>provideInlayHints</code> 方法在 TypeScript 服务器上失败。请尝试将 TypeScript 升级到至少 v5.9。<br/>当前正在使用内部嵌入提示实现。
notification.provideInlayHints.serviceRestored=<code>provideInlayHints</code> 方法已恢复正常运行。
notification.title.cannot.download.types.node=无法下载 @types/node
notification.title.cannot.enable.node.js.coding.assistance=无法启用 Node.js 编码辅助
notification.title.cannot.generate=无法生成 {0}
notification.title.coloring.types.narrowed.by.type.guard.was.disabled=按类型防护缩小类型着色被禁用
notify.urls.more=…和其他 {0,number} 个
npm.before.run.task=运行 npm 脚本
npm.before.run.task.descr=运行 npm {0, choice, 0\#脚本|1\#脚本|2\#脚本}{1} [{2}]
npm.dialog.message.cannot.resolve.package.manager=无法解析 ''{0}'' 软件包管理器
npm.downloading_package=正在下载 {0}…
npm.failed_to_install_package.title.message=无法安装 {0}
npm.modules.inspection.content.of.require.module.not.installed.warning=未安装模块
npm.modules.inspection.content.of.require.not.in.dependencies.warning=package.json 依赖关系中未列出模块
npm.modules.install.global.types.dialog.title=安装 TypeScript 定义
npm.modules.install.global.types.directory.error=无法创建所需的目录
npm.modules.install.global.types.fix.name=安装 TypeScript 定义以提供更好的类型信息
npm.no.scripts.found=未找到脚本
npm.rc.command.label=命令\:(&C)
npm.rc.environmentVariables.label=环境\:
npm.rc.nodeOptions.label=Node 选项\:
npm.rc.packageJson.browseDialogTitle=选择 package.json 文件
npm.rc.packageJson.label=package.json(&P)\:
npm.rc.scripts.label=脚本 (&T)\:
npm.rc.scriptsArguments.label=实参(&R)\:
npm.searching_for_previously_installed_package=正在搜索先前安装的 {0}…
npm.task.title=NPM 脚本
numeric.enum.values=数值枚举值
package.description=软件包 {0}
package.downloader.create.package.directory=正在创建软件包目录…
package.json.install.types.fix.family.name=为软件包安装 @types
package.version.range.hint={0, choice, 0\#允许|1\#允许次要更新\:|2\#允许补丁更新} {1} ≤ 版本 \\&lt; {2}
package.version.range.info={0, choice, 0\#未安装|1\#已安装\: ?|2\#已安装\: {1}}，最新\: {2, choice, 0\#正在加载…|1\#找不到|2\#{3}}
package_json.install_dependencies.notification.content=来自 {0}
package_json.install_dependencies.notification.title=安装依赖项
package_json.install_dependencies_multiple.notification.content=来自 {0} 和其他 {1} 个
package_json.notifications_are_disabled.notification.content=已禁用从 {0} 安装依赖项的通知。<p>使用“{1}”操作重新启用通知。
package_json.update_dependencies.notification.title=更新依赖项
parameter.type.is.not.specified=形参 ''{0}'' 的类型未指定。\n是否继续?
parameters.in.parentheses=圆括号中的形参
parameters.in.parentheses.description=圆括号中的形参
please.specify.package.manager=指定<a href\="">软件包管理器</a>。
popup.advertisement.latest.available.versions.for.all.distribution.tags=所有发行版标签的最新可用版本
popup.advertisement.start.typing.package.name=开始输入软件包名称，以从 npm 官方公共注册表中获取更具体的结果
popup.content.cannot.edit.selected.node.js.interpreter=无法编辑所选 Node.js 运行时
popup.title.choose.class=选择类
popup.title.select.destructuring.assignment.target=选择析构赋值目标
popup.title.target.function=目标函数
postfix.template.condition.array.name=数组
postfix.template.condition.non.void.name=非 Void
postfix.template.provider.name=JavaScript 和 TypeScript
process.terminated=进程已终止
progress.subtitle.install=正在通过 {1} 安装 {0}…
progress.text.initializing.opened.files=正在初始化打开的文件
progress.text.modifying=正在修改 {0}
progress.text.processing=正在处理 {0}{1}
progress.title.compiling.typescript.files=正在编译 TypeScript 文件
progress.title.configuring.node.js.coding.assistance=正在配置 Node.js 编码辅助…
progress.title.detect.overridden.methods=检查重写方法
progress.title.downloading.documentation=正在下载文档
progress.title.downloading.library=正在下载库
progress.title.downloading.typings=正在下载 typings
progress.title.executing.performance.task.on.files=正在文件上执行性能任务
progress.title.find.usages=正在查找用法…
progress.title.install=安装 {0}
progress.title.install.npm.module=安装 npm 模块 ''{0}''
project.generation=生成项目
protractor.rc.configurationFile.label=配置文件(&C)\:
protractor.rc.configurationFile.title=选择 Protractor 配置文件
protractor.rc.protractorOptions.emptyText=CLI 选项，例如 --browser 或 --rootElement
protractor.rc.protractorOptions.label=Protractor 选项 (&O)\:
protractor.rc.protractorPackage.label=Protractor 软件包(&P)\:
rc.browser.error.unspecified.url.text={0} 中未指定 URL
rc.browser.liveEdit.tab.name=浏览器 / Live Edit
rc.configuration.tab.name=配置
rc.environmentVariables.label=环境变量(&E)\:
rc.nodeOptions.label=Node 选项 (&O)\:
rc.testConfig.presentable.name={0} 中的所有测试
rc.testDirectory.presentable.name={0} 中的测试
rc.testOrSuiteScope.emptyTest=空测试名称
rc.testOrSuiteScope.suite.label=套件名称\:
rc.testOrSuiteScope.suite.title=编辑套件名称
rc.testOrSuiteScope.test.label=测试名称\:
rc.testOrSuiteScope.test.title=编辑测试名称
rc.testRunScope.all=所有测试(&L)
rc.testRunScope.directory=目录(&D)
rc.testRunScope.suite=套件
rc.testRunScope.test=测试(&T)
rc.testRunScope.testDirectory.browseTitle=选择测试目录
rc.testRunScope.testDirectory.label=测试目录\:
rc.testRunScope.testFile=测试文件(&F)
rc.testRunScope.testFile.browseTitle=选择测试文件
rc.testRunScope.testFile.label=测试文件\:
rc.workingDirectory.browseDialogTitle=选择工作目录
rc.workingDirectory.label=工作目录(&W)\:
recursive.call=递归调用
refactoring.destructuring.vars.for.refactor.this=对象或数组析构…
refactoring.destructuring.vars.intention.const.to.var.warning=在转换期间，高亮显示的 const 变量将转换为 let 变量。\n是否要继续?
refactoring.destructuring.vars.intention.const.to.var.warning.title=变量关键字更改
refactoring.destructuring.vars.intention.deconstruct=生成析构模式
refactoring.destructuring.vars.intention.depropagate=将析构替换为属性和索引访问
refactoring.destructuring.vars.intention.guard.conflict=通过类型 guard 将表达式类型缩小为 ''{0}''，该类型 guard 在重构后将不起作用
refactoring.destructuring.vars.intention.name=引入对象或数组析构
refactoring.destructuring.vars.intention.name.array=引入数组析构
refactoring.destructuring.vars.intention.name.object=引入对象析构
refactoring.destructuring.vars.intention.propagate=传播到析构声明
refactoring.destructuring.vars.intention.replace.array=替换为数组析构
refactoring.destructuring.vars.intention.replace.object=替换为对象析构
refactoring.destructuring.vars.intention.replace.promise=替换为 'await Promise.all'
refactoring.destructuring.vars.intention.replace.shorthand=替换为析构和速记属性
reg.exp.tagged.template=''{1}'' 标记模板中的 {0}
remove.type.prefix=移除类型前缀
remove.unnecessary.parentheses.fix.text=移除不必要的圆括号
rename.accessors.dialog.text=是否将属性访问器也重命名为 ''{0}''?
rename.accessors.dialog.title=重命名字段
rename.css.definition.description=检测到 CSS 类型声明的用法。应重命名相关属性，否则可能导致代码不一致。
rename.css.definition.title=重命名类型声明成员
rename.destructuring.property.description=析构属性引用多个成员。应重命名相关属性，否则可能导致代码不一致。
rename.destructuring.property.title=重命名析构属性
rename.prompt.do.you.want.to.rename.base.method=是否要重命名基方法?
rename.react.hook.variable.description=将相关状态变量重命名为\:
rename.react.hook.variable.title=重命名状态变量
rename.type.members.destructuring.description=检测到析构属性中的用法。应重命名相关属性，否则可能导致代码不一致。
rename.type.members.title=重命名类型成员
rename.type.members.union.intersection.mapped.description=检测到联合体、相交或映射类型用法。应重命名相关属性，否则可能导致代码不一致。
replace.implements.keyword.fix.name=将 'implements' 更改为 'extends'
required.parameters.are.not.permitted.after.optional.parameters=必选形参不能位于可选形参后
return.type.is.not.resolved=返回值类型 ''{0}'' 未解析。\n是否继续?
service.configurable.default={0} (默认)
service.highlighting.progress={0} 服务高亮显示
settings.code.style.Trailing.comma=尾随逗号(&T)\:
settings.code.style.always=始终
settings.code.style.dont.use=不使用
settings.code.style.double=双
settings.code.style.in.new.code=在 IDE 生成的代码中
settings.code.style.indent.all.chained.calls.in.a.group=缩进组中的所有链式调用
settings.code.style.indent.chained.methods=缩进链式方法
settings.code.style.option.use=使用
settings.code.style.quotes=引号(&Q)
settings.code.style.semicolon.to.terminate.statements=分号(&S)
settings.code.style.single=单
settings.code.style.use=使用
settings.javascript.field.names.completion=为类字段建议名称 (&F)
settings.javascript.lang.templates.configurable.name=模板
settings.javascript.linters.autodetect.configure.automatically=自动 {0} 配置 (&A)
settings.javascript.linters.autodetect.configure.automatically.help.text={0} 将使用 node_modules 目录中的 {1} 软件包，还会使用与当前文件或其任何父文件夹位于同一文件夹中的 {2} 配置文件。
settings.javascript.linters.autodetect.configure.manually=手动 {0} 配置 (&M)
settings.javascript.linters.autodetect.disabled=禁用 {0}(&D)
settings.javascript.linters.configurable.name=代码质量工具
settings.javascript.linters.eslint.configurable.name=ESLint
settings.javascript.linters.jshint.configurable.name=JSHint
settings.javascript.only.type.based.completion=仅基于类型补全 (&C)
settings.javascript.only.type.based.completion.tooltip=根据类型信息显示较少的补全建议。可能会显著提高性能。
settings.javascript.opt.chain.completion=为可 null 类型建议包含可选链接的条目(&O)
settings.javascript.overrides.completion=在重写补全中展开方法体
settings.javascript.root.configurable.name=JavaScript
settings.javascript.runtime.configurable.name=JavaScript 运行时
settings.javascript.runtime.preferred.runtime.auto-detected.text=自动检测
settings.javascript.runtime.preferred.runtime.context.help.description=用于在项目内运行和调试。语言服务、ESLint 和测试仍将使用 Node.js
settings.javascript.runtime.preferred.runtime.label.name=首选运行时\:
settings.javascript.runtime.preferred.runtime.unavailable.text=不可用
settings.javascript.var.names.completion=建议变量和形参名称(&V)
settings.javascript.var.names.completion.desc=补全名称
settings.javascript.var.names.completion.names.only=无类型
settings.javascript.var.names.completion.types=为建议的形参名称添加类型注解(&T)
settings.javascript.var.names.completion.types.everywhere=随处都是类型
settings.javascript.var.names.completion.types.except.fields=随处都是类型，字段除外
settings.javascript.var.names.completion.types.for.params=具有函数形参的类型
settings.javascript.var.names.completion.types.for.params.fields=具有形参和字段的类型
settings.nodejs.coding.assistance.label=Node.js 编码协助 (&A)\:
settings.nodejs.coding.assistance.manage.scopes.label=管理作用域…
settings.nodejs.name=Node.js
settings.typescript.root.configurable.name=TypeScript
space.after.dots.in.rest.spread=在 rest/spread 中的 '…' 后面
space.after.generator.mult=在生成器中的 '*' 后面 
space.after.name.value.separator=在属性名称-值分隔符 '\:' 后面
space.after.type.colon=在类型引用冒号 '\:' 后面
space.before.class.interface.module.lbrace=类/接口/模块左大括号
space.before.class.lbrace=类的左大括号
space.before.function.left.parenth=在函数表达式中
space.before.generator.mult=在生成器中的 '*' 前面 
space.before.name.value.separator=在属性名称-值分隔符 '\:' 前面
space.before.type.colon=在类型引用冒号 '\:' 前面
spaces.after.unary.not=在 'not' (\!) 和 '\!\!' 后面
spaces.arrow.function=箭头函数(\=>)
spaces.async.arrow.function=在异步箭头函数中
spaces.before.unary.not=在 'not' (\!) 和 '\!\!' 前面
spaces.within.array.initializer=数组中括号
spaces.within.import.braces=ES6 导入/导出大括号
spaces.within.indexer.brackets=索引访问中括号
spaces.within.interpolation.expressions=插值表达式
spaces.within.object.literal.braces=对象字面量大括号
spaces.within.object.type.braces=对象字面量类型大括号
spaces.within.type.assertion=类型断言
spaces.within.unary.additive=一元加法运算符 (+,-,++,--)
spaces.within.union.and.intersection=联合体与相交类型
standardjs.action.fix.problems.description=修正标准代码样式问题
standardjs.codestyle.updated={0}\: 项目代码样式设置已更新
standardjs.codestyle.updated.config.section={0}\: 项目代码样式设置已根据 package.json 中的 ''standard'' 部分更新
standardjs.codestyle.updated.dependency={0}\: 项目代码样式设置已根据 package.json 中的 ''standard'' 依赖项更新
standardjs.edit.settings.caption=ESlint/标准代码样式
standardjs.editor.notification.action=是
standardjs.editor.notification.can.be.enabled.text=为此项目使用 JavaScript 标准代码样式?
standardjs.editor.notification.do.not.show.text=否
standardjs.error.unsupported.package=不支持的软件包版本。请将 ''Standard'' 软件包升级到最低版本 {0}。
standardjs.name=标准代码样式
start.template.string.interpolation.on.typing=键入 '$' 时启动模板字符串内插
status.text.add.interpreter.with=使用 {0} 添加运行时
status.text.javascript.language.service.default.project.errors=显示项目错误
status.text.javascript.language.service.suggestions=显示建议
status.text.no.interpreters.added=未添加任何运行时
status.text.project.structure.isn.t.available=项目结构不可用
status.text.running.which.node=正在运行 `which node`…
status.text.service.doesn.t.contain.open.projects=服务不包含开放项目
status.text.service.is.not.started=服务未启动
structural.search.anonymous.functions=匿名函数
structural.search.classes=类
structural.search.comparison.to.self=与自身比较
structural.search.console.log.calls=调用 console.log()
structural.search.constants=常量
structural.search.empty.functions=空函数
structural.search.function.calls=函数调用
structural.search.functions=函数
structural.search.functions.with.boolean.parameters=使用布尔形参的函数
structural.search.var.statements=Var 语句
structural.search.variables=变量
structural.search.while.loops=While 循环
structural.search.with.statements=With 语句
successfully.downloaded=已成功下载
superclass.cannot.be.extracted.from.enum=无法从枚举中提取超类
superclass.cannot.be.extracted.from.mxml.component=无法从 MXML 组件中提取超类。
superclass.cannot.be.extracted.from.type.alias=无法从类型别名中提取超类
superclass.label.text=超类(&S)\:
tab.title.compile.errors=编译错误
tab.title.convert.to.class=转换为类
tab.title.project.errors=项目错误
tab.title.refactoring.preview=重构预览
tab.title.refactoring.result=重构结果
template.add.imports=添加明确的 import
terminal.add_node_modules_bin_to_path.label=将 ''node_modules/.bin'' 从项目根添加到 {0}
testing.select.in.test.tree.name=在测试树中选择 ''{0}''
testing.snapshot.update.all.tests.text=<link>点击以更新所有失败的快照</link>
testing.snapshot.update.single.test.text=<link>点击以更新 ''{0}'' 的快照</link>
testing.snapshot.update.test.file.text=<link>点击以更新 {0} 中所有失败的快照</link>
text.cannot.download=无法下载 {0}。{1}
text.html.front.end.template.a.href.http.html5boilerplate.com=<html>前端模板<a href\='http\://html5boilerplate.com'>http\://html5boilerplate.com</a></html>
text.html.sleek.intuitive.and.powerful.front.end.framework=<html>整洁、直观、强大的前端框架，更快、更轻松地进行 Web 开发 <a href\='http\://getbootstrap.com'>http\://getbootstrap.com</a></html>
titled.separator.predefined=预定义
top.level.package=顶层软件包
ts.add.import.all.family.name=添加所有 import
ts.add.import.hint.all.part=或全部使用 {0} 导入
ts.add.import.hint.multiple.text=使用  {1} 为 {0} 添加导入
ts.add.import.hint.text=使用 {1} 添加 {0}
ts.add.import.statement.dialog.title=添加 import 语句
ts.change.import.action.command=更改导入
ts.change.import.action.dialog.title=导入自…
ts.change.import.action.family.name=更改 ES6 导入路径
ts.change.import.action.many.title=更改导入…
ts.change.import.action.one.title=更改为 {0}
ts.convert.alias.to.enum.action.family.name=将类型别名转换为枚举
ts.convert.alias.to.enum.action.title=将别名转换为枚举
ts.convert.alias.to.interface.action.family.name=将类型别名转换为接口
ts.convert.alias.to.interface.action.title=将别名转换为接口
ts.convert.field.to.parameter.property=将字段转换为形参属性
ts.convert.parameter.property.to.field=将形参属性转换为字段
ts.generate.reference.path.name=生成引用路径注释
ts.param.hints.blacklist.pattern.explanation=<b>弃用通知</b>\: <p style\="margin-left\: 5px">从 TypeScript 4.4 开始，<code>provideInlayHints</code> 服务方法用于呈现提示。该方法有自己的启发式方法；因此，不再使用此排除列表。
ts.param.hints.show.names.for.literal.args=字面量实参
ts.switch.to.jsx.inspection.name=更改文件扩展名为 .tsx
ts.unresolved.variable.inspection.name=未解析的 TypeScript 引用
type.annotations=类型注解
type.is.not.resolved=类型 ''{0}'' 未解析。\n是否继续?
typescipt.import.options.paths.help=此选项用于配置 import 语句中使用的路径样式。<br><br>选择“始终”时，IDE 会始终使用来自 tsconfig.json 配置的别名。<br><br>选择“仅在指定路径之外的文件中”时，IDE 会为已定义别名的文件之间的 import 使用相对路径。在所有其他文件中，将使用路径映射。<br><br>选择“从不”时，将从不使用别名。
typescript.abstract.class.constructor.can.be.made.protected=抽象类构造函数可以设为 protected
typescript.auto.import.options.add.imports=自动添加 TypeScript import
typescript.before.task.check.errors=检查错误
typescript.before.task.config.dialog.title=选择 tsconfig.json
typescript.before.task.config.path=配置文件\:
typescript.before.task.title=TypeScript 编译设置
typescript.code.style.tab.name=TypeScript
typescript.compiler.action.compile.all=全部编译
typescript.compiler.action.compile.all.compile.config=配置 {0} 的编译文件
typescript.compiler.action.compile.all.description=编译所有项目文件
typescript.compiler.action.compile.current=编译当前文件
typescript.compiler.action.compile.description=编译当前项目
typescript.compiler.action.compile.simple=编译 TypeScript
typescript.compiler.action.compile.toolbar=编译
typescript.compiler.action.compile.with.ellipsis=编译…
typescript.compiler.action.no.compile.message=文件未编译，因为没有从主文件引用
typescript.compiler.before.run=编译 TypeScript
typescript.compiler.configurable.name=TypeScript
typescript.compiler.configurable.options.command.line=选项\:
typescript.compiler.configurable.options.command.line.localeNotSupportedForBundled=捆绑的 TypeScript 不支持区域设置
typescript.compiler.configurable.options.info.tsGo.local=<div>要使用本地克隆的 <a href\='https\://github.com/Microsoft/typescript-go/'>TypeScript-Go</a>，请先根据<a href\='https\://github.com/microsoft/typescript-go?tab\=readme-ov-file\#how-to-build-and-run'>说明</a>进行构建。</div><div>或者，您可以尝试使用 <a href\='https\://github.com/microsoft/typescript-go?tab\=readme-ov-file\#preview'><code>@typescript/native-preview</code></a> 软件包。</div>
typescript.compiler.configurable.options.track.file.system=在更改时重新编译
typescript.compiler.configurable.options.tsGoFork.download.defaultFailedMessage=无法下载 TS-Go Fork
typescript.compiler.configurable.options.tsGoFork.downloading=正在下载 {0}…
typescript.compiler.configurable.options.tsGoFork.info=<div>TypeScript-Go 的实验性<a href\=''https\://github.com/JetBrains/typescript-go/''>复刻</a>，支持标准 LSP 服务(悬停、补全等)和服务驱动的类型。</div><div>这将下载 <a href\="{0}">{0}</a></div>
typescript.compiler.configurable.options.use.servicePoweredTypeEngine=启用服务驱动的类型引擎
typescript.compiler.configurable.options.use.servicePoweredTypeEngine.comment=一种混合机制，结合了内部 IDE 模型<br>和语言服务的强大功能，以提高性能和类型推断。<br>设置时需要启用语言服务。
typescript.compiler.configurable.options.use.types.from.server=使用服务器中的类型
typescript.compiler.configurable.options.use.types.from.server.description=启用基于 TypeScript 编译器的评估。
typescript.compiler.configurable.options.use.types.from.server.tsGoWarning=“启用服务驱动的类型引擎”将被忽略，因为其尚不支持 TypeScript-Go
typescript.compiler.configurable.options.use.types.from.server.versionWarning=“启用服务驱动的类型引擎”将被忽略，因为所选 TypeScript 版本低于 4.5
typescript.compiler.configurable.options.version=TypeScript\:
typescript.compiler.configurable.options.version.bundled=已捆绑
typescript.compiler.configurable.options.version.bundled.tsGoFork=TypeScript-Go JetBrains 复刻
typescript.compiler.loading.project=正在加载项目 {0}
typescript.compiler.starting=TypeScript 正在启动…
typescript.compiler.structure.tab.title=结构
typescript.config.inspection=不一致的 Tsconfig.json 属性
typescript.config.inspection.checkjs.info=属性 checkJs 需要 allowJs 属性
typescript.config.inspection.config.options.fix=向 tsconfig.json 中添加 ''{0}''
typescript.config.inspection.fix.pattern=添加 ''{0}'' 属性
typescript.config.inspection.libs=缺少全局库
typescript.config.inspection.libs.fix=在 tsconfig.json 中启用库 ''{0}''
typescript.config.inspection.missing.option=缺少 tsconfig.json 选项 
typescript.duplicate.typescript.union.inspection.name=重复的联合体或相交类型组件
typescript.explicit.member.type.inspection.name=显式类型
typescript.export.assignment.cannot.be.used.in.internal.modules=导出不能在内部模块中使用的赋值
typescript.field.can.be.made.readonly=可以为只读字段
typescript.fix.change.member.access=设为 ''{0}''
typescript.generics.should.not.be=类型 ''{0}'' 非泛型
typescript.go.bad.package=在 {0} 中找不到 TypeScript-Go 软件包
typescript.go.name=TypeScript-Go
typescript.go.type.evaluation.name=TS-Go 类型评估
typescript.import.options.exts.help=此选项用于配置 import 语句中的扩展名。<br><br>选择“自动”时，IDE 会始终向 vue 文件、来自在 tsconfig.json 中具有 "module"\: "node16" 或 "module"\: "nodenext" 和在 package.json 中具有 "type"\: "module" 的项目的文件，以及扩展名为 .mts 的文件的名称添加扩展名。<br><br>选择“始终”时，IDE 会始终向 TypeScript 文件名添加 .js 扩展名。<br><br>选择“从不”时，IDE 会始终使用不带扩展名的文件名。
typescript.import.options.paths=使用 tsconfig.json 的路径映射\:
typescript.import.options.use.config=使用相对于 tsconfig.json 的路径
typescript.include.js.sources.dialog.message=是否在此项目中包含 ''{0}'' 中的 JavaScript 文件?
typescript.include.js.sources.dialog.title=包括软件包 {0}
typescript.include.js.sources.element=搜索 JavaScript 声明
typescript.insert.cast.fix=插入类型断言
typescript.insert.type.guard.fix.family=插入类型 guard
typescript.insert.type.guard.nc=将限定符替换为 ''{0}''
typescript.insert.type.guard.nc.self=替换为 ''{0}''
typescript.insert.type.guard.postfix=使用 ''{0}'' 进行可选查询
typescript.insert.type.guard.prefix=前缀为 ''{0}''
typescript.insert.type.guard.surround=封闭在 ''{0}''中
typescript.inspection.group.name=TypeScript
typescript.intention.convert.import.require=将 import require 转换为 import from
typescript.intention.convert.import.require.text=转换为 {0}
typescript.language.service.clean=正在重置缓存…
typescript.language.service.compile.file=正在编译文件… {0}
typescript.language.service.compile.file.errors=正在计算错误… {0}
typescript.language.service.compile.project=正在编译项目… {0}
typescript.language.service.compile.project.errors=正在计算项目错误… {0}
typescript.language.service.compile.project.open.file=正在打开文件… {0}
typescript.language.service.name=TypeScript 服务
typescript.language.simple.name=TypeScript
typescript.make.constructor.protected=将构造函数设为 protected
typescript.make.field.readonly=将字段设为只读
typescript.missing.augmentation.import=缺少扩大导入
typescript.narrowed.to=范围缩小至 ''{0}''
typescript.private.field.modifiers.mix=使用不公开名称的字段不能具有 'public'、'private' 或 'protected' 访问修饰符
typescript.redundant.declaration=类型声明与推断的类型相匹配，因此可以移除
typescript.redundant.instanceof.guard=''instanceof'' 检查冗余\: ''{0}'' 具有类型 ''{1}'' 或 ''{1}'' 的子类型
typescript.redundant.instanceof.inheritor.guard=''instanceof'' 检查冗余\: ''{0}'' 具有类型 ''{1}'' 或 ''{1}'' 的继承者
typescript.redundant.typescript.type.argument.inspection.name=冗余类型实参
typescript.reference.to.umd.global=已引用的 UMD 全局变量
typescript.remove.type.declaration=移除类型声明
typescript.rename.dynamic.references=搜索动态引用 (&D)
typescript.rename.javascript.references=在 JavaScript 文件中搜索(&J)
typescript.service.no.config=文件未包括在任何 tsconfig.json 中
typescript.service.no.main.reference=文件未处理，因为没有从主文件引用
typescript.smart.cast=范围缩小的类型
typescript.smart.cast.hyperlink=设置字体和背景
typescript.specify.all.param.types.explicitly=显式指定所有形参类型
typescript.specify.type.explicitly=显式指定类型
typescript.suspicious.constructor.parameter.assignment=构造函数中的形参赋值可疑。您是否忘记了添加 'this.'?
typescript.suspicious.constructor.parameter.assignment.desc=已分配构造函数字段形参
typescript.suspicious.instanceof.guard=''instanceof'' 检查无效\: ''{0}'' 的类型与 ''{1}'' 无关
typescript.type.guard.name=变量类型缩小为类型 guard
typescript.type.guard.name.disable=禁用范围缩小的类型的着色
typescript.type.predicate.destructuring=类型谓词不能引用绑定模式中的元素。
typescript.type.predicate.incompatible.types=类型谓词不可分配给 {0}
typescript.type.predicate.not.match.name=找不到形参 {0}
typescript.type.predicate.not.return=仅函数和方法的返回值类型位置允许类型谓词
typescript.type.predicate.rest=类型谓词不能引用 rest 形参
typescript.type.this.predicate.not.return=仅类或接口成员、get 访问器或函数和方法的返回值类型位置允许基于 'this' 类型的谓词。
typescript.types.intersection=相交
typescript.types.key=键引用
typescript.types.mapped=映射
typescript.types.merged=已合并
typescript.types.merged.accessor=合并访问器
typescript.types.merged.parts=引用的属性\:
typescript.types.module.not.installed.warning=无法解析模块 ''{0}'' 的定义
typescript.types.type.member={0} 类型属性
typescript.types.union=联合体
typescript.validate.generic.types.fix.add=添加泛型实参
typescript.validate.generic.types.fix.delete=移除泛型实参
typescript.validate.generic.types.inspection.error.argument.number=泛型类型 ''{0}'' 需要 ''{1}'' 类型实参
typescript.validate.generic.types.inspection.error.argument.number.between=泛型类型 ''{0}'' 需要介于 {1} 和 {2} 之间的类型实参
typescript.validate.generic.types.inspection.error.not.empty.argument=类型实参列表不能为空
typescript.validate.generic.types.inspection.error.not.empty.parameter=类型形参列表不能为空
typescript.validate.generic.types.inspection.name=不正确的泛型实参
typescript.validate.optional.parameter.inspection.error=形参不能有问号和初始值设定项
typescript.validate.optional.parameter.inspection.fix.question=移除问号
typescript.validate.template.literal.types=模板类型 {1} 不可分配给约束类型 {0}
typescript.validation.async.incorrect.type.annotation=异步函数不能有 ''{0}'' 类型注解
typescript.validation.cannot.find.best.common.type=无法从用法推断类型实参
typescript.validation.class.extend.constructor.return.not.class=基类构造函数返回值类型 ''{0}'' 不是类或接口类型。
typescript.validation.class.extend.cycled.definition=循环类定义
typescript.validation.class.extend.many.constructors=基类构造函数必须具有相同的返回值类型
typescript.validation.class.extend.no.type.arguments.type=没有任何基类构造函数具有指定数量的类型实参
typescript.validation.class.extend.not.constructor.type=类型 ''{0}'' 不是构造函数类型
typescript.validation.dissatisfies.type.annotation=类型 ''{0}'' 不满足预期类型 ''{1}''
typescript.validation.expressionWithTypeArguments.compatibleSignatureNotFound=找不到兼容的签名
typescript.validation.generators.ambient=环境上下文中不允许使用生成器
typescript.validation.generators.async.no.yield=生成器隐式具有类型 'AsyncIterableIterator<any>'，因为它不产生任何值。请考虑提供返回值类型。
typescript.validation.generators.incorrect.type.annotation=发生器不能有 ''{0}'' 类型注解
typescript.validation.generators.incorrect.type.annotation.iterable=类型 ''{0}'' 不可分配给类型 ''{1}''。
typescript.validation.generators.no.yield=生成器隐式具有类型 'IterableIterator<any>'，因为它不产生任何值。请考虑提供返回值类型。
typescript.validation.generators.overload=重载签名无法被声明为生成器
typescript.validation.incorrect.rhs.in.private.brand=右侧必须是一个对象，实际为\: ''{0}''
typescript.validation.message.abstract.cannot.be.used=''{0}'' 修饰符不能与 ''abstract''修饰符一起使用
typescript.validation.message.abstract.cannot.have.body=方法不能具有实现，因为它被标记为 'abstract'
typescript.validation.message.abstract.class.be.created=无法创建抽象类 ''{0}'' 的实例
typescript.validation.message.abstract.class.should.be=abstract 方法只能出现在抽象类中
typescript.validation.message.abstract.member.access.super=无法通过 super 表达式访问 abstract 方法 ''{0}''。
typescript.validation.message.abstract.overload=重载签名必须全部为 abstract 或非 abstract。
typescript.validation.message.constructor.cannot.be.abstract=构造函数不能为 'abstract'
typescript.validation.message.duplicate.modifier=已看到修饰符 {0}
typescript.validation.message.duplicate.modifier2=已看到可访问性修饰符
typescript.validation.message.function.implementation.missing=缺少函数实现或此声明之后未紧随函数实现
typescript.validation.message.getter.and.setter.must.have.same.access.type=Getter 和 setter 必须具有相同的访问类型
typescript.validation.message.invalid.modifier.cannot.be.here=修饰符 {0} 不能出现在此处
typescript.validation.message.invalid.module.member.modifier=''{0}'' 不是模块成员的有效修饰符
typescript.validation.message.misordered.in.modifier='in' 修饰符必须在 'out' 修饰符之前。
typescript.validation.message.unexpected.type.for.rest.parameter=Rest 形参必须为数组类型或具有数组约束的泛型
typescript.validation.message.unexpected.type.for.rest.parameter.fix=替换为数组类型
typescript.validation.message.unique.symbol.mutable.non.static.field.declaration=类型为 'unique symbol' 类型的类的属性必须同时为 'static' 和 'readonly'
typescript.validation.message.unique.symbol.mutable.non.static.field.declaration.fix.add.static.readonly=添加 static 和 readonly 修饰符
typescript.validation.message.unique.symbol.mutable.property.signature=如果接口或类型字面量的类型是 'unique symbol' 类型，则其属性必须为 'readonly'
typescript.validation.message.unique.symbol.mutable.variable=类型为 'unique symbol' 类型的变量必须为 'const'
typescript.validation.message.unique.symbol.wrong.usage=此处不允许使用 'unique symbol' 类型
typescript.validation.module.reference.with.extension=外部模块引用不能以扩展结束
unnecessary.parentheses.display.name=不必要的圆括号
unnecessary.parentheses.problem.descriptor=<code>\#ref</code> 周围的圆括号不必要 \#loc
unresolved.project.interpreter.notification.content=要正常工作，{0} 需要 Node.js，但在您的计算机上找不到 Node.js。
unresolved.project.interpreter.notification.download.action.text=下载 Node.js
unresolved.project.interpreter.notification.download.action.url=https\://nodejs.org/en/download
unwrap.with.kind=解包 ''{0}…''
variables.and.fields=变量和字段
variables.and.fields.description=变量和字段
varible.name.column.title=名称
varible.value.column.title=值
visibility.level.details=详细信息
visibility.level.overview=概览
vitest.coverage.cannot.copy.lcov.info.notification.content=无法显示 Vitest 覆盖率\: 无法复制文件。
vitest.coverage.cannot.find.lcov.info.notification.content=无法显示 Vitest 覆盖率\: 找不到 {0}。
vitest.coverage.directory.not.found.notification.content=无法从 Vitest 配置中读取 coverageDirectory 选项
vitest.coverage.notification.title=Vitest 覆盖率
vitest.coverage.presentable.text=Vitest 覆盖率
vitest.rc.configurationFile.label=配置文件(&C)\:
vitest.rc.configurationFile.title=选择 Vitest 配置文件
vitest.rc.vitestOptions.emptyText=CLI 选项，例如 --watch 或 --ui
vitest.rc.vitestOptions.label=Vitest 选项\:
vitest.rc.vitestPackageField.label=Vitest 软件包(&V)\:
vitest.snapshot.update.rc.name=更新 {0} 的快照
web.bundler.analyzing.configs.progress=正在分析 Web 捆绑程序的配置文件
web.bundler.cannot.analyze=无法分析 {0}\: 编码辅助将忽略此文件中的模块解析规则。
web.bundler.error.details=错误详细信息\: {0}
web.bundler.failed.to.load=无法加载 {0}
web.bundler.possible.reasons=可能的原因\: 此文件不是有效的配置文件，或者 IDE 目前不支持其格式。
web.template.file-type.description={0} 模板
yarn.package_requires_yarn.dialog.message=软件包“{0}”要求 Yarn {1}。
yarn.pnp.library_name=来自 {0} 的依赖项
yarn.pnp.requires.yarn.package_manager.dialog.message=Yarn PnP 需要 Yarn <a href\="">软件包管理器</a>
{0}.visibility.will.break.methods.hierarchy=可见性为 {1} 的{0}无法参与层次结构

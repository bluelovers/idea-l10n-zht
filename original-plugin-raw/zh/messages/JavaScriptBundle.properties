# File Types
filetype.javascript.description=JavaScript
filetype.actionscript.description=ActionScript
filetype.typescript.description=TypeScript
filetype.typescript.jsx.description=TypeScript JSX
filetype.ecmascript6.description=ECMAScript 6
filetype.jsx.description=React JSX
filetype.jsx.display.name=React JSX
filetype.flow.description=Flow JS
filetype.flow.display.name=Flow JS
javascript.file=JavaScript 文件
typescript.file=TypeScript 文件
filetype.typescript.config.description=TypeScript 配置
filetype.typescript.config.display.name=TypeScript 配置

# Languages
javascript.language.simple.name=JavaScript
typescript.language.simple.name=TypeScript

# Language terms
javascript.language.term.function=函数
javascript.language.term.inner.function=内部函数
javascript.language.term.method=方法
javascript.language.term.constructor=构造函数
javascript.language.term.class=类
javascript.language.term.inner.class=内部类
javascript.language.term.interface=接口
javascript.language.term.inner.interface=内部接口
javascript.language.term.enum=枚举
javascript.language.term.type.alias=类型别名
javascript.language.term.definition=定义
javascript.language.term.namespace=命名空间
javascript.language.term.parameter=形参
javascript.language.term.property=属性
javascript.language.term.variable=变量
javascript.language.term.const=常量
javascript.language.term.const.field=常量字段
javascript.language.term.readonly.field=只读字段
javascript.language.term.local.variable=局部变量
javascript.language.term.local.const=局部常量
javascript.language.term.field=字段
javascript.language.term.tag=标记
javascript.language.term.label=标签
javascript.language.term.attribute=特性
javascript.language.term.decorator=装饰器
javascript.language.term.attribute.value=特性值
javascript.language.term.package=软件包
javascript.language.term.module=模块
javascript.language.term.external.module.reference=外部模块引用
javascript.language.term.import.specifier=导入说明符
javascript.language.term.export.specifier=导出说明符
javascript.language.term.entity.name=实体名称
javascript.language.term.jsdoc.tag=JSDoc 标签
javascript.language.term.imported.default.binding=已导入默认绑定
javascript.language.term.exported.default.binding=已导出默认绑定
javascript.language.term.namespace.import=命名空间导入
javascript.language.term.namespace.export=命名空间导出
javascript.language.term.import.statement=import 语句
javascript.language.term.type.parameter=类型形参
javascript.language.term.destructuring.property=析构属性
javascript.language.term.default.export=默认导出
javascript.language.term.file=文件
javascript.language.term.global=全局
javascript.language.term.xml.tag=xml 标签

# Parser error messages
javascript.parser.message.expected.expression=应为表达式
javascript.parser.message.expected.xml.element=应为 XML 元素
javascript.parser.property.expected=应为属性
javascript.parser.message.expected.lbrace=应为 {
javascript.parser.message.expected.at=应为 @
javascript.parser.message.expected.rbrace=应为 }
javascript.parser.message.expected.identifier.string.literal.or.numeric.literal=应为标识符、字符串文字或数字文字
javascript.parser.message.expected.colon=应为 :
javascript.parser.message.expected.colon.or.comma=应为 : 或 ,
javascript.parser.message.expected.semicolon=应为 ;
javascript.parser.message.expected.lbrace.or.semicolon=应为 { 或 ;
javascript.parser.message.expected.rbracket=应为 ]
javascript.parser.message.expected.lparen=应为 (
javascript.parser.message.expected.rparen=应为 )
javascript.parser.message.expected.name=应为名称
javascript.parser.message.expected.comma.or.rparen=应为 , 或 )
javascript.parser.message.expected.function.name=应为函数名称
javascript.parser.message.expected.formal.parameter.name=应为形参名称
javascript.parser.message.expected.statement=应为语句
javascript.parser.message.expected.parameter.name=应为形参名称
javascript.parser.message.expected.property.name=应为属性名称
javascript.parser.message.expected.case.or.default=应为 'case' 或 'default'
javascript.parser.message.expected.forloop.left.hand.side.expression.or.variable.declaration='in' 前面应为左侧表达式或变量声明
javascript.parser.message.expected.forloop.in.or.semicolon=应为 'in' 或 ;
javascript.parser.message.expected.while.keyword=应为 'while'
javascript.parser.message.expected.comma=应为 ,
javascript.parser.message.expected.comma.or.rbrace=应为 , 或 }
javascript.parser.message.expected.variable.name=应为变量名称
javascript.parser.message.expected.mult.or.lbrace=应为 * 或 {
javascript.parser.message.missing.rbrace=缺少 }
javascript.parser.message.missing.or_rbrace=缺少 |}
javascript.parser.message.missing.attribute.name=缺少特性名称
javascript.parser.message.unexpected.end.of.file=意外的文件结尾
javascript.parser.message.expected.type.name=应为类型名称
javascript.parser.message.unclosed.string.literal=未闭合的字符串文字
javascript.parser.message.unclosed.comment=未闭合注释
javascript.parser.message.are.not.supported.by.dialect=当前 JavaScript 版本不支持 {0}
javascript.parser.message.expected.from=应为 'from'
javascript.parser.message.expected.typename=应为类型名称
javascript.parser.message.expected.typename.or.*=* 应为 * 或类型名称
javascript.parser.message.expected.name.or.lbrace=应为软件包名称或 {
javascript.parser.message.expected.declaration=应为声明
javascript.parser.message.expected.namespace=应为 'namespace'
javascript.parser.message.expected.string.literal=应为字符串文字
javascript.parser.message.expected.xml=应为 XML 上下文关键字
javascript.parser.message.expected.equal=应为 =
javascript.parser.message.expected.identifier.lbrace.or.lbracket=应为标识符、{ 或 [
javascript.parser.message.expected.eqgt=应为 =>
javascript.parser.message.expected.identifier=应为标识符
javascript.parser.message.expected.instanceof=应为 'instanceof'
javascript.parser.message.expected.in=应为 'in'
javascript.parser.message.expected.value=应为值
javascript.parser.message.expected.identifier.or.value=应为标识符或值
javascript.parser.message.expected.as=应为 'as'
javascript.parser.message.expected.identifier.string.literal.or.lbrace=应为标识符、字符串文字或 {
javascript.parser.message.expected.import.value=应为导入绑定或说明符
javascript.parser.message.expected.import.specifier=应为导入说明符
javascript.parser.message.expected.heredoc.closing.identifier=应为 heredoc 结束标识符
javascript.parser.message.expected.type.member=应为类型成员
javascript.parser.message.expected.tuple.comma.or.rbracket=应为 , 或 ]
javascript.parser.message.expected.target=仅接受 'target' 作为要新建的元属性
javascript.parser.message.expected.meta=仅接受 'meta' 作为要导入的元属性
javascript.parser.message.expected.declare=应为 'declare'
javascript.parser.message.expected.exports=应为 'exports'
javascript.parser.message.expected.checks=应为 'checks'
javascript.parser.message.expected.type.keyword=应为 'type'
javascript.parser.message.expected.type=应为类型
javascript.parser.message.expected.question=应为 ?
javascript.parser.message.expected.class=应为 'class'

# Validation messages
javascript.validation.message.conflicting.definition.was.found.with.the.same.name=在命名空间 {1} 中发现冲突性的继承声明 {0}
javascript.validation.message.duplicate.declaration=重复声明
javascript.validation.message.duplicate.declaration.fix.remove=移除类型
javascript.validation.message.redundant.type=显式类型实参 {0} 可替换为 {1}
javascript.validation.message.redundant.type.remove=可以移除显式类型实参 {0}
javascript.validation.message.duplicate.export.declaration=导出声明与已导出的声明 ''{0}'' 相冲突
javascript.validation.message.duplicate.default.export.declaration=一个模块不能有多个默认导出
javascript.validation.message.duplicate.default.export.in.module=默认导出只能在 ECMAScript-style 模块中使用
javascript.validation.message.duplicate.declaration.fix.text=导航到上一个声明 ''{0}''
javascript.validation.message.duplicate.declaration.fix.text.no.name=导航到上一个声明
javascript.validation.message.redeclaration.of.block.scope=无法重新声明块范围变量
javascript.validation.message.redeclaration.of.block.scope.in.scope.of.var=块范围变量不能与同一块范围中的"var"变量或参数使用相同的名称
javascript.validation.message.redeclaration.of.var.in.scope.of.block.scope="var" 变量不能与其可见性范围内的块范围变量使用相同的名称
javascript.validation.message.assignment.to.const=尝试赋值给常量或只读变量
javascript.validation.message.assignment.to.const.fix.replace=替换为 let
javascript.validation.message.assignment.to.const.fix.remove.readonly=移除只读修饰符
javascript.validation.message.must.be.lvalue={0} 中的左侧无效
javascript.validation.message.const.variable.without.initializer='const' 变量不包含初始值设定项。以后无法赋予有意义的值。
javascript.validation.message.constructor.field.not.allowed=类可能没有名为 'constructor' 的非 static 字段
es6.validation.message.const.variable.without.initializer=不允许使用无初始值设定项的 'const' 变量
javascript.validation.message.continue.without.target=无法确定 'continue' 的目标
javascript.validation.message.break.without.target=无法确定 'break' 的目标
javascript.validation.message.continue.outside.loop='continue' 在循环语句外部
javascript.validation.message.return.outside.function.definition='return' 在函数定义外部
javascript.validation.message.duplicate.label=重复标签
javascript.validation.message.extend.multiple.classes=类不能扩展多个类
javascript.validation.message.extend.final.class=无法扩展 final 类 ''{0}''
javascript.validation.message.identifier.not.allowed.in.strict.mode=在严格模式下不能将 ''{0}'' 用作标识符
javascript.validation.message.for.await.top.level=使用了顶层 'for await'
javascript.validation.message.for.await.no.async.context='for await' 只能在 'async' 函数中使用
typescript.validation.message.invalid.modifier.cannot.be.here=修饰符 {0} 不能出现在此处
typescript.validation.message.duplicate.modifier=已看到修饰符 {0}
typescript.validation.message.duplicate.modifier2=已看到可访问性修饰符
typescript.validation.message.abstract.cannot.be.used=''{0}'' 修饰符不能与 ''abstract''修饰符结合使用
typescript.validation.message.abstract.class.be.created=无法创建 abstract 类 ''{0}'' 的实例
typescript.validation.message.abstract.member.access.super=无法通过 super 表达式访问 abstract 方法 ''{0}''。
typescript.validation.message.abstract.cannot.have.body=方法不能具有实现，因为它被标记为 'abstract'
typescript.validation.message.abstract.overload=重载签名必须全部为 abstract 或非 abstract。
typescript.validation.message.constructor.cannot.be.abstract=构造函数不能为 'abstract'
typescript.validation.message.function.implementation.missing=缺少函数实现或此声明之后未紧随函数实现
typescript.validation.message.abstract.class.should.be=abstract 方法只能出现在 abstract 类中
typescript.validation.module.reference.with.extension=外部模块引用不能以扩展结束
typescript.validation.class.extend.not.constructor.type=类型 ''{0}'' 不是构造函数类型
typescript.validation.class.extend.no.type.arguments.type=没有任何基类构造函数具有指定数量的类型实参
typescript.validation.class.extend.many.constructors=基类构造函数必须具有相同的返回类型
typescript.validation.class.extend.cycled.definition=循环类定义
typescript.validation.class.extend.constructor.return.not.class=基类构造函数返回类型 ''{0}'' 不是类或接口类型。
javascript.validation.generators.yield.not.iterable=表达式类型没有定义 [Symbol.iterator] 或 [Symbol.asyncIterator]
javascript.validation.generators.yield.not.assignable.to.return=类型 ''{1}'' 不可分配给类型 ''{0}''
typescript.validation.generators.incorrect.type.annotation=发生器不能有 ''{0}'' 类型注解
typescript.validation.async.incorrect.type.annotation=异步函数不能有 ''{0}'' 类型注解
typescript.validation.generators.incorrect.type.annotation.iterable=类型 ''{0}'' 不可分配给类型 ''{1}''。
typescript.validation.generators.overload=重载签名无法被声明为生成器
typescript.validation.generators.ambient=环境上下文中不允许使用生成器
typescript.validation.generators.no.yield=生成器隐式具有类型 'IterableIterator<any>'，因为它不产生任何值。请考虑提供返回类型。
typescript.validation.generators.async.no.yield=生成器隐式具有类型 'AsyncIterableIterator<any>'，因为它不产生任何值。请考虑提供返回类型。
typescript.validation.cannot.find.best.common.type=无法从用法推断类型实参


# Surround with names
javascript.surround.with.do.while=do / while
javascript.surround.with.for=for
javascript.surround.with.if=if
javascript.surround.with.if.else=if / else
javascript.surround.with.if.cond=if (cond)
javascript.surround.with.if.else.cond=if (cond) / else
javascript.surround.with.parenthesis=(expr)
javascript.surround.with.not.parenthesis=!(expr)
javascript.surround.with.cast=Type(expr)
javascript.surround.with.try.catch=try / catch
javascript.surround.with.try.finally=try / finally
javascript.surround.with.try.catch.finally=try / catch / finally
javascript.surround.with.while=while
javascript.surround.with.with=with
javascript.surround.with.function=函数
javascript.surround.with.function.expression=函数表达式
javascript.surround.with.object.literal=对象文字

# Introduce variable
javascript.introduce.variable.title=提取变量
javascript.introduce.variable.title.local=引入局部变量
javascript.introduce.variable.error.no.expression.selected=无法引入变量。\n选定内容不构成表达式。
javascript.introduce.variable.error.expression.has.void.type=无法引入变量。\n选定的表达式类型无效。
javascript.introduce.variable.name.prompt=名称(&N):
javascript.introduce.variable.replace.all.occurrences=替换所有匹配项(找到 {0} 个匹配项)(&A)
javascript.introduce.variable.invalid.name=请输入有效名称。
javascript.introduce.element.already.exists=范围中已存在同名的 {0}。
javascript.introduce.variable.arrow.function.parameter.referenced=无法引入。\n选定内容包含对箭头函数形参的引用
javascript.introduce.variable.arrow.await.referenced=无法引入。\n选定内容包含 await 表达式
javascript.introduce.variable.xml.embedded=无法在嵌入式表达式中引入变量
javascript.introduce.incorrect.context=无法引入变量。\n选定内容包含对"this"的引用
javascript.introduce.field.title=引入字段
javascript.introduce.field.error.no.expression.selected=无法引入字段。\n选定内容不构成表达式。
javascript.introduce.field.error.expression.has.void.type=无法引入变量。\n选定的表达式类型无效。
javascript.introduce.field.error.no.enclosing.class=无法引入字段。\n没有封闭类。
javascript.introduce.field.make.readonly=设为只读(&R)
javascript.introduce.field.initialize.in.scope=初始化在(&I):
javascript.introduce.field.visibility=可见性(&V):
javascript.introduce.field.keyboard.hint=按 {0} 用于键盘快捷键
javascript.introduce.field.before.super.call=无法引入字段。\n在"super"调用前无法访问"this"。
javascript.introduce.field.current.method=当前方法
javascript.introduce.field.field.declaration=字段声明
javascript.introduce.field.constructor=构造函数
javascript.introduce.constant.title=引入常量
javascript.introduce.constant.error.no.expression.selected=无法引入常量。\n选定内容不构成表达式。
javascript.introduce.constant.error.expression.has.void.type=无法引入常量。\n选定的表达式类型无效。
javascript.introduce.constant.error.not.constant.expression.selected=无法引入常量。\n选定内容不是常量表达式。
javascript.introduce.parameter.title=提取形参
javascript.introduce.parameter.error.no.expression.selected=无法引入形参。\n选定内容不构成表达式。
javascript.introduce.parameter.error.no.containing.function=无法引入形参。\n找不到要使用的包含函数。
javascript.introduce.parameter.error.expression.has.void.type=无法引入形参。\n选定的表达式类型无效。
javascript.introduce.parameter.error.not.async.context=无法为包含 'await' 的表达式引入形参。\n并非所有用法都包含在异步函数中
javascript.introduce.parameter.error.target.not.async=无法为包含 'await' 的表达式引入形参。\n目标函数不是异步函数
javascript.introduce.parameter.error.yield=无法为包含 'yield 的表达式引入形参。
javascript.introduce.parameter.generate.jsdoc=生成 JSDoc
javascript.introduce.parameter.optional.parameter=可选形参
javascript.introduce.throw.expressions.unsupported=无法调用重构。\n"Extract"重构中当前不支持 Throw 表达式。
javascript.introduce.breaks.operator.precedence=无法调用重构。\n通过引入将更改表达式中的运算符优先级。
javascript.introduce.constant.in.es5=无法调用重构。\n无法在 ECMAScript 3 或 ECMAScript 5 代码中引入常量。
javascript.introduce.in.embedded.expression=无法调用重构。\n无法在嵌入式表达式中引入
javascript.introduce.variable.make.constant=设为常量
list.item.class.field=类字段
list.item.global.or.module.constant=全局或模块常量
list.item.local.constant=局部常量

# Highlighting categories
javascript.keyword=关键字
javascript.string=字符串
javascript.number=数字
javascript.linecomment=行注释
javascript.doccomment=文档注释
javascript.blockcomment=块注释
javascript.regexp=正则表达式
javascript.operation=运算
javascript.parens=括号
javascript.brackets=中括号
javascript.braces=大括号
javascript.semicolon=分号
javascript.badcharacter=错误字符
jsdoc.text=JSDoc 文本
jsdoc.tag=JSDoc 标签
jsdoc.tag.value=JSDoc 标记值
jsdoc.type=JSDoc 类型
javascript.doctag=文档标签
javascript.doctagvalue=文档标记值
javascript.valid.string.escape=有效字符串转义
javascript.invalid.string.escape=无效字符串转义
javascript.comma=逗号
javascript.dot=点

# Errors with intentions
javascript.unresolved.function.name.message=未解析的函数或方法 {0}() #loc
javascript.unresolved.variable.name.message=未解析的变量 {0} #loc
javascript.unresolved.variable.null.qualifier.message=''{0}'' 的限定符可能为 null #loc
javascript.unresolved.variable.undefined.qualifier.message=''{0}'' 的限定符可能未定义 #loc
javascript.unresolved.variable.null.or.undefined.qualifier.message=''{0}'' 的限定符可能为 null 或 undefined #loc
javascript.unresolved.type.name.message=未解析的类型 {0} #loc
javascript.unresolved.circle.definition=导入的圆定义
javascript.missing.read.property=未解析的读取属性 #loc
javascript.missing.write.property=未解析的写入属性 #loc
javascript.unresolved.variable.or.type.name.message=未解析的变量或类型 {0} #loc
javascript.unresolved.variable.or.type.name.message2=未解析的变量或类型 {0}
javascript.unresolved.symbol.message=未解析的符号
javascript.unresolved.file=找不到文件 {0}
javascript.unknown.metadata.tag=未知元数据标签
javascript.unknown.metadata.attribute=未知元数据特性
javascript.undeclared.variable.name.message=隐式声明变量 {0} #loc
javascript.create.function.intention.name=创建函数 ''{0}''
javascript.create.variable.intention.name=创建变量 ''{0}''
javascript.create.constant.intention.name=创建常量 ''{0}''
javascript.declare.variable.intention.name=为 ''{1}'' 插入 {0} 声明
javascript.declare.variable.intention.family.name=插入 var 声明
javascript.declare.variable.in.previous.var.statement.intention.name=将 ''{0}'' 的 var 声明插入之前的 var 语句
javascript.declare.variable.in.previous.var.statement.intention.family=将 var 声明插入之前的 var 语句
javascript.create.field.intention.name=创建字段 ''{0}''
javascript.create.constant.field.intention.name=创建常量字段 ''{0}''
javascript.create.method.intention.name=创建方法 ''{0}''
javascript.create.property.intention.name=创建属性 ''{0}''
javascript.create.function.property.intention.name=创建函数属性 ''{0}''
javascript.create.constructor.intention.name=在 ''{0}'' 类中创建构造函数
javascript.create.get.property.intention.name=创建 ''get'' 属性 ''{0}''
javascript.create.set.property.intention.name=创建 ''set'' 属性 ''{0}''
javascript.create.function.intention.family=创建 JavaScript 函数或方法
javascript.create.variable.intention.family=创建 JavaScript 变量或属性
javascript.intention.create.getter.setter=为 ''{0}'' 创建 getter 和 setter
javascript.intention.create.getter.setter.desc=创建 getter 和 setter
javascript.intention.create.setter=为 ''{0}'' 创建 setter
javascript.intention.create.setter.desc=创建 setter
javascript.intention.create.getter=为 ''{0}'' 创建 getter
javascript.intention.create.getter.desc=创建 getter
create.mobile.view=创建视图 ''{0}''
javascript.rename.reference.intention.name=重命名引用
typescript.rename.javascript.references=在 JavaScript 文件中搜索(&J)
typescript.rename.dynamic.references=搜索动态引用 (&D)
js.usage.type.call=函数调用中的用法
js.anonymous.to.named.function=匿名函数转换为命名函数
js.convert.to.named.function=转换为命名函数
js.convert.to.named.function.to.class.method=转换为类方法
js.convert.to.arrow.function=转换为箭头函数
js.add.braces.to.arrow.function=向箭头函数中添加大括号
js.inspection.function.expression.is.used.instead.of.arrow=使用了函数表达式而不是箭头函数
js.arrow.function.braces.can.be.removed.key=箭头函数体周围的大括号冗余
js.arrow.function.braces.can.be.removed.problem.description=可以移除箭头函数体周围的大括号
js.arrow.function.braces.can.be.removed.fix.family.name=移除箭头函数体周围的大括号
js.convert.to.anonymous.function.family.name=箭头函数转换为匿名函数
js.convert.to.anonymous.function=转换为匿名函数
js.named.to.anonymous.family.name=转换为函数表达式
js.named.to.function.expression.text = 转换为包含变量的函数表达式
js.named.to.function.hoisting.conflict.text=函数在声明之前使用。转换为变量后，将中断使用
js.named.to.arrow.text = 转换为含有 {0} 的箭头函数
js.split.into.multiple.declarations=拆分为多个声明
js.remove.digit.separators=移除数字分隔符
js.copy.qualified.to.clipboard=将限定名称复制到剪贴板
js.iterate=使用 'for..of' 进行迭代
js.iterate.async=使用 'for await..of' 进行迭代
js.separate.digits=分隔数字
js.separate.nibbles=分隔半字节
js.separate.bytes=分隔字节
js.separate.words=分隔 16 位单词
js.separate.thousands=分隔千位数
js.separate.thousands.in.integer.part=将千位数分隔成整数
js.split.declarations=拆分声明
js.replace.string.with.es6.template=替换为模板字符串
js.replace.string.concatenation.with.es6.template.inspection.name=已使用字符串串联而不是模板文字
js.replace.string.concatenation.with.es6.template.fix.text=替换为模板字符串
js.string.template.line.separators.visible=转换为可见行分隔符
js.string.template.line.separators.multispan=转换为多行字符串模板
js.string.template.line.separators.visible.family.name=转换模板字符串以使用可见行分隔符
js.string.template.line.separators.multispan.family.name=转换为多行字符串模板
js.convert.var.to.let.text=转换为 let
js.convert.var.to.const.text=转换为 const
js.convert.var.to.let.or.const=转换为 let/const
js.convert.var.to.let.or.const.family.name=将 var 转换为 let/const
js.convert.var.to.let.or.const.inspection.text=已使用 'var' 而不是 'let' 或 'const'
js.convert.let.to.const.inspection.text=已使用 'let' 而不是 'const'
js.convert.var.to.let.or.const.inspection.conservative.option=使用“全部修复”操作保守地转换 var
js.convert.var.to.let.or.const.inspection.conservative.option.description=在第一次使用变量之前，声明可能会移至函数器顶部。\n要在使用“全部修复”操作时禁用此行为，请选中“保守转换 var”选项。
js.convert.require.into.es6.import.text=将 require() 转换为 import
js.convert.require.into.es6.import.family.name=将 require() 转换为 import
js.convert.require.into.es6.import.inspection.text=使用了 'require()' 而不是 'import'
js.convert.require.into.es6.import.inspection.withConditional.option=使用“全部修复”操作在内部范围内转换 require()
js.convert.require.into.es6.import.inspection.withConditional.option.description=在内部范围内转换 require()（例如 'if' 语句或内部函数）
js.convert.module.exports.into.es6.export.text=转换为 export
js.convert.module.exports.into.es6.export.family.name=转换为 export
js.convert.module.exports.into.es6.export.inspection.text=使用了 'module.exports' 而不是 'export'
js.convert.for.in.to.for.of.text=将 'for..in' 转换为 'for..of'
js.convert.for.in.to.for.of.family.name=将 'for..in' 转换为 'for..of'
js.convert.for.in.to.for.of.inspection.text=使用了 'for..in' 而不是 'for..of'
js.convert.indexed.for.to.for.of.text=将带索引的 'for' 转换为 'for..of'
js.convert.indexed.for.to.for.of.family.name=将带索引的 'for' 转换为 'for..of'
js.convert.indexed.for.to.for.of.inspection.text=已使用索引的 'for' 而不是 'for..of'
js.convert.for.each.to.for.of.intention.family=将 'forEach' 替换为 'for..of' 循环
js.convert.for.each.to.indexed.intention.family=将 'forEach' 替换为索引的 'for' 循环
js.convert.for.of.to.indexed.intention.family=将 'for..of' 替换为索引的 'for' 循环
js.convert.map.to.for.of.intention.family=将 'map' 数组调用替换为 'for..of' 循环
js.convert.indexed.for.to.foreach.intention.family=将索引的 'for' 转换为 'forEach' 调用
js.add.then.fix=添加 '.then()'
js.quote.unquote.intention.plural={0} 属性名称
js.quote.unquote.intention.singular={0} 属性名称
js.quote.unquote.intention.quote=引用
js.quote.unquote.intention.quote.family=使用引号包装属性名称
js.quote.unquote.intention.unquote=取消引用
js.quote.unquote.intention.unquote.family=移除属性名称中的引号
js.property.to.indexer.intention=替换为索引器访问
js.indexer.to.property.intention=替换为属性访问
js.join.vars.intention=加入后续变量声明
js.infer.parameter.types.intention=从用法中推断形参类型
js.infer.parameter.types.intention.jsdoc=从用法中推断 JSDoc 形参类型
js.infer.parameter.types.intention.failure.title=无法推断类型
js.infer.parameter.types.intention.progress.text=正在推断类型
js.infer.parameter.types.intention.failure.text=无法从用法中推断类型
js.infer.parameter.types.intention.failure.readonly.text=无法从用法中推断类型：为只读文件

# Move module members
es6.move.module.members.refactoring.name=移动模块成员
es6.move.module.members.table.title=要移动的成员
es6.move.module.members.refactoring.create.file=创建文件
es6.move.module.members.refactoring.file.does.not.exist=文件 {0} 不存在
es6.move.module.members.refactoring.create.file.message=文件 {0} 不存在。\n要创建吗?
es6.move.module.members.refactoring.dialog.error.no.script.tag=目标文件不包含脚本标签
es6.move.module.members.refactoring.dialog.error.invalid.file.name=目标文件名在此操作系统中无效
es6.move.module.members.refactoring.dialog.error.no.selected.items=没有要移动的选定成员
es6.move.module.members.refactoring.dialog.error.incorrect.module=目标模块不正确
es6.move.module.members.refactoring.dialog.error.modules.same=源模块和目标模块应不同
es6.move.module.members.refactoring.dialog.move.member.to=成员移动至
es6.move.module.members.refactoring.dialog.field.from=从:
es6.move.module.members.refactoring.dialog.field.to=到:
es6.move.module.members.references.unresolved.import.message=选择的 {0} 引用未解析导入 {1}
es6.move.module.members.references.local.message=选择的 {0} 引用非导出 {1}
es6.move.module.members.has.local.usage.message=文件 {1} 中使用未导出的 {0}
es6.move.module.members.non.es6.module.usage=在非 ES6 模块的文件 {1} 中使用 {0}
es6.move.module.members.destination.not.es6=目标文件 {0} 不是 ES6 模块
es6.move.module.members.cannot.detect.js.language=目标文件不是 JS 文件
es6.move.module.members.destination.contains.default.export=目标模块包含默认导出
es6.move.module.members.destination.does.not.support.jsx={0} 包含 JSX 标签，但目标语言不支持这些标签
es6.move.module.members.syntax.errors=移动 {0} 将引入语法错误，因为目标语言不同于源语言
es6.move.module.members.incompatible.language=目标模块具有不兼容的语言
dialog.title.move.members=移动成员

js.pull.up.will.be.made.abstract=非 abstract {0} 将被设为 abstract
es6.extract.super.destination.label=目标文件 (&D)：
es6.extract.super.members.in.interface=新接口中的成员
es6.extract.super.members.in.superclass=新超类中的成员
es6.extract.super.overload.declaration.without.implementation.conflict=类中不允许没有实现的重载声明 {0}
es6.extract.super.different.name.expected=应为不同名称

# Unit testing
js.testing.inspection.group.name=单元测试
js.testing.highlight.line=在测试代码中高亮显示失败的行
rc.environmentVariables.label=环境变量(&E)：
rc.testRunScope.all=所有测试(&L)
rc.testRunScope.testFile=测试文件 (&F)
rc.testRunScope.suite=套件
rc.testRunScope.test=测试(&T)
rc.nodeOptions.label=节点选项 (&O)：
rc.workingDirectory.label=工作目录(&W):
rc.workingDirectory.browseDialogTitle=选择工作目录
rc.testOrSuiteScope.suite.title=编辑套件名称
rc.testOrSuiteScope.suite.label=套件名称:
rc.testOrSuiteScope.test.title=编辑测试名称
rc.testOrSuiteScope.test.label=测试名称：
rc.testOrSuiteScope.emptyTest=空测试名称
rc.testRunScope.testFile.label=测试文件：
rc.testRunScope.testFile.browseTitle=选择测试文件

# Unit testing: Jest
jest.snapshot.update.rc.name=更新 {0} 的快照
jest.snapshot.update.single.test.text=<link>点击以更新 ''{0}'' 的快照</link>
jest.snapshot.update.test.file.text=<link>点击以更新 {0} 中失败的快照</link>
jest.snapshot.update.all.tests.text=<link>点击以更新所有失败的快照</link>
jest.rc.configurationFile.label=配置文件(&C):
jest.rc.configurationFile.title=选择 Jest 配置文件
jest.rc.jestPackageField.label=Jest 软件包(&J)：
jest.rc.jestOptions.label=Jest 选项：
jest.rc.jestOptions.emptyText=CLI 选项，例如 --watch 或 --env=jsdom
jest.coverage.notification.title=Jest 覆盖率
jest.coverage.directory.not.found.notification.content=无法从 Jest 配置中读取 coverageDirectory 选项
jest.coverage.cannot.find.lcov.info.notification.content=无法显示 Jest 覆盖率: 找不到 {0}。

# Unit testing: Protractor
protractor.rc.configurationFile.label=配置文件(&C):
protractor.rc.configurationFile.title=选择 Protractor 配置文件
protractor.rc.protractorPackage.label=Protractor 软件包(&P)：
protractor.rc.protractorOptions.label=Protractor 选项 (&O)：
protractor.rc.protractorOptions.emptyText=CLI 选项，例如 --browser 或 --rootElement

# Node.js
node.js.inspection.group.name=Node.js
node.js.missing.require=缺少 require() 语句
node.js.unresolved.api=未解析的 Node.js API
node.js.invalid.node=该项目使用了无效的 Node.js 路径。<br>它已更新为使用 {0} 中的 Node.js。
node.js.configure=配置 Node.js
node.js.downloading=正在下载 Node.js {0}
node.js.interpreters=Node.js 解释器
node.js.set.project.interpreter.action=设置为项目解释器
node.js.add.interpreter.action=添加{0}…
notification.title.cannot.enable.node.js.coding.assistance=无法启用 Node.js 编码辅助
notification.title.cannot.download.types.node=无法下载 @types/node
status.text.add.interpreter.with=使用 {0} 添加解释器
status.text.no.interpreters.added=未添加解释器
popup.content.cannot.edit.selected.node.js.interpreter=无法编辑选定的 Node.js 解释器
node.no.interpreter=无解释器
node.interpreter.not.found=找不到 {0}
no.executable.found.in.path=在 {0, choice, 0#%PATH%|1#$PATH} 中未找到可执行文件
merged.process.output.text={0}{2, choice, 0#\n\n标准错误:\n{1}|1#}{4, choice, 0#\n\n标准输出:\n{3}|1#}\n\n{5}
node.interpreter.download=下载 Node.js
node.interpreter.project_node.reference.name=项目
node.interpreter.node_from_path.reference.name=node

# Inspections
js.inspection.group.name=常规
typescript.inspection.group.name=TypeScript
js.inspection.bitwise.group.name=按位运算问题
js.code.style.issues.group.name=代码样式问题
js.probable.bugs.group.name=可能的错误
js.annotator.inspection.name=未遵循 ECMAScript 规范
js.inspection.convert.to.es6.group.name=ES2015 迁移协助
js.inspection.switch.group.name=切换语句问题
js.inspection.async.group.name=Async 代码和 promise
js.function.metrics.group.name=函数指标
js.validity.issues.group.name=有效性问题
js.imports.dependencies.group.name=导入和依赖关系
js.unused.symbols.group.name=未使用的符号
js.unwanted.symbols.group.name=可能不合需要的代码结构
js.assignment.issues.group.name=赋值问题
js.potentially.invalid.usage.of.this.inspection.name=从闭包对 'this' 的引用可能无效
js.potentially.invalid.usage.of.class.this.inspection.name=从闭包对类中 'this' 的引用可能无效
js.potentially.invalid.target.of.indexed.property.access.inspection.name=索引的属性访问的目标可能不正确
javascript.potentially.invalid.usage.of.this=This 的用法可能无效
javascript.potentially.invalid.usage.of.class.this=通过嵌套函数的 'this.' 对类字段的引用访问可能无效
javascript.potentially.invalid.target.of.indexed.property.access=索引的属性访问的目标可能无效
js.unfiltered.for.in.loop.inspection.name=未过滤 for..in 循环
javascript.unfiltered.for.in.loop=可能迭代意外(自定义/继承)成员，可能缺少 hasOwnProperty 检查
js.unfiltered.for.in.loop.skip.primitives=使用数组或对象初始值设定项跳过引用迭代
js.unfiltered.for.in.loop.skip.primitives.tooltip=在未修改 Object.prototype 和 Array.prototype 时启用它
js.referencing.mutable.variable.from.closure.inspection.name=从闭包中引用可变变量
javascript.mutable.variable.accessible.from.closure=可从闭包访问可变变量
js.unresolved.variable.inspection.name=未解析的 JavaScript 变量
ts.unresolved.variable.inspection.name=未解析的 TypeScript 变量
js.undeclared.variable.inspection.name=隐式声明的全局 JavaScript 变量
js.duplicate.declaration.inspection.name=重复声明
# WI-11522 only the first word should start with uppercase letter
js.linters.inspection.group.name=代码质量工具
js.linters.detect.automatically.caption=从最近的 package.json 检测软件包和配置文件
js.unused.local.symbol.inspection.name=未使用的局部符号
js.unused.es6.import.inspection.name=未使用的 import
js.unused.assignment.inspection.name=未使用的赋值
js.join.declaration.assignment.inspection.name=变量声明可与变量的第一个赋值合并
js.join.declaration.assignment.inspection.fix=联接变量声明和赋值
js.unused.global.symbol.inspection.name=未使用的全局符号
js.missing.await.symbol.inspection.name=异步函数调用缺少 await
js.missing.await.symbol.inspection.for.returns=始终对异步函数调用使用 'await' 以避免错误，并帮助进行 V8 异步堆栈跟踪
js.missing.await.symbol.inspection.for.generator.name=异步生成器应使用 for-await 循环进行迭代
jsx.missing.namespace.inspection.name=JSX 代码中缺少 'React' 命名空间导入
jsx.missing.namespace.inspection.text=在未导入 {0} 的情况下使用 JSX
tsx.missing.name.quick.fix.name="添加 {0} import 语句
js.destructuring.merge.inspection=正在析构具有相同键的属性
js.destructuring.merge.inspection.text=可以合并具有多个相同键的析构属性
js.destructuring.merge.inspection.fix=合并析构属性
js.nested.template.literal.inspection=模板文字中的冗余嵌套
js.nested.template.literal.fix=内联嵌套文字
js.redundant.await.inspection=冗余 'await' 表达式
js.await.promise.resolve.inspection=冗余 'await Promise.resolve()'
js.await.promise.reject.inspection=冗余 'await Promise.reject()'
js.await.promise.double.await.inspection=冗余 'await await'
js.await.promise.return.await.inspection=冗余 'return await'
js.await.promise.trivial.await.inspection=非 promise 类型的冗余 'await'
js.await.promise.resolve.fix=替换为 ''{0}''
js.top.level.await.expression.inspection= 顶层 'await' 表达式
js.top.level.await.expression.inspection.description= 使用了顶层 'await' 表达式
js.possibly.async.function.inspection=非异步函数中的 'await'
js.await.in.synchronous.function='await' 运算符只能在 'async' 函数中使用
js.possibly.async.function.quick.fix=令函数 {0} 为异步函数
js.possibly.async.function.quick.fix.family.name=将函数设为异步
js.property.can.be.replaced.with.shorthand=属性可替换为速记形式
js.property.can.be.replaced.with.shorthand.method=属性可替换为速记方法
js.replace.with.shorthand.property.quick.fix=替换为速记属性
js.replace.with.shorthand.method.quick.fix=替换为速记方法
js.expand.shorthand.property.quick.fix=展开速记属性
js.unresolved.function.inspection.name=未解析的 JavaScript 函数
ts.unresolved.function.inspection.name=未解析的 TypeScript 函数
js.unresolved.react.component.name=未解析的 React 组件
js.deprecated.symbols.inspection.name=已使用弃用的符号
js.suspicious.eq.plus.inspection.name=可疑的 '=+' 赋值
js.suspicious.eq.plus.inspection.desc=可疑的 '=+' 赋值：'+=' 可能拼写错误
js.suspicious.eq.plus.fix.name=替换为 '+='
js.suspicious.name.combination.inspection.name=可疑的变量/形参名称组合
js.bitwise.operator.usage.name=按位运算符用法
js.bitwise.operator.usage.popup=使用了按位运算符
js.bitwise.operator.usage.quickfix=替换为 {0}
js.potentially.invalid.constructor.usages.inspection.name=可能无效的构造函数用法
js.mismatched.update.collection.inspection.name=不匹配的集合查询和更新
js.mismatched.update.collection.update.method.names=更新方法名称
js.closure.compiler.syntax.inspection.name=JSDoc 标记不正确的用法
js.closure.compiler.syntax.implements.not.interface={0} 未用 @interface 进行注解
js.closure.compiler.syntax.cyclic.inheritance=涉及 {0} 的循环继承
js.closure.compiler.syntax.empty.type=空类型不可用
js.closure.compiler.syntax.invalid.type=类型语法无效
collection.updated.but.not.queried=更新了集合 <code>#ref</code> 的内容，但从未被查询
collection.queried.but.not.update=查询了集合 <code>#ref</code> 的内容，但从未写入
javascript.constructor.with.lower.case.name.used.message=构造函数名称通常以大写字母开头。拼写错误？
interface.function.declaration.should.have.no.body=接口函数声明不应有本体
javascript.ambient.declaration.should.have.no.body=环境声明不应有本体
javascript.ambient.declaration.should.have.no.initializer=环境声明不应有初始值设定项
javascript.ambient.declaration.const.should.be.primitive=环境上下文中的 'const' 初始值设定项必须是基元文字或文字枚举引用
javascript.deprecated.symbol.used.name.message=使用了弃用的符号，请查阅文档，以获取更好的替代性 #loc
javascript.deprecated.symbol.used.name.message2=自版本 {0} 符号被标记为弃用以来，使用 {1} 作为替换用 #loc
js.unused.symbol=未使用的 {0} #ref
js.unused.symbol.full=未使用的 {0}
js.unused.symbol.remove=移除未使用的 {0}
js.suspicious.name.assignment=''{0}'' 可能不应分配给 ''{1}''
js.suspicious.name.parameter=''{0}'' 可能不应作为参数 ''{1}'' 传递
js.suspicious.name.return=''{0}'' 可能不应从方法 ''{1}'' 返回
js.constructor.cant.have.return.type=构造函数不能有返回类型
invalid.identifier.value.0=无效标识符：''{0}''
js.suspicious.bind.with.arrow.function=箭头函数 'bind' 用法可疑
javascript.change.signature.invalid.parameter.declaration=无效参数：''{0}''
javascript.change.signature.invalid.function.name.0=无效函数名称：''{0}''
javascript.validation.generators.yield.not.in.generator=只允许在生成器本体中使用 'yield' 表达式。
javascript.validation.new.target.not.in.function=仅允许函数声明、函数表达式或构造函数的本体中有元属性 'new.target'
javascript.validation.message.this.referenced.from.static.context=在 static 上下文中引用了 'this'
javascript.validation.message.super.referenced.without.class.instance.context=在没有类实例上下文的情况下引用了'super'
javascript.validation.message.super.referenced.from.static.context=在 static 上下文中引用了 'super'
javascript.validation.message.function.override.without.override.modifier=方法重写了没有 override 关键字的超类 {0} 中的方法
javascript.validation.multiple.var.in.for.loop=''{0}'' 循环中只允许一个变量
javascript.validation.initialized.var.in.for.loop=''{0}'' 循环中不允许变量初始值设定项
javascript.fix.add.override.modifier=添加重写修饰符
javascript.fix.property.spelling.family=修复属性名称中可能的拼写错误
javascript.fix.property.spelling.text=将拼写调整为 ''{0}''
js.code.style.tab.name=JavaScript
js.code.style.file.name.relaxed.style=重用当前文件的 case
js.code.style.file.name.camel.style=驼峰命名法 (appComponent)
js.code.style.file.name.pascal.style=帕斯卡命名法 (AppComponent)
js.code.style.file.name.snake.style=蛇形命名法 (app_component)
js.code.style.file.name.lisp.style=中线命名法 (app-component)
js.code.style.file.name.mixed.style=带后缀的中线命名法 (my-app.component)
es6.code.style.path.mapping.always=始终
es6.code.style.path.mapping.never=从不
es6.code.style.path.mapping.different.paths=仅在指定路径以外的文件中
typescript.code.style.tab.name=TypeScript
jsx.code.style.attribute.default.value=为 JSX 特性添加：
jsx.code.style.attribute.default.value.braces=大括号
jsx.code.style.attribute.default.value.quotes=引号
jsx.code.style.attribute.default.value.none=无
jsx.code.style.attribute.default.value.typebased=基于类型
javascript.formatting.options.panel.naming.conventions=命名惯例
javascript.formatting.options.panel.comments=注释
js.convert.parameters.to.object.intention.name=将形参转换为对象
js.convert.parameters.to.object.with.interface.intention.name=将形参转换为对象并引入接口
js.convert.parameters.to.object.non.call.usage.will.not.be.updated=不更新非调用用法
js.convert.parameters.to.object.usage.will.not.be.updated.for.contextual.type=方法实现接口方法。不会更新基方法
js.convert.parameters.to.object.usage.will.not.be.updated.for.spread=不会更新使用非终端传播实参进行的调用
js.undefined.property.assignment.inspection.name=未定义的属性赋值
js.undefined.property.assignment.inspection.message=类型 {1} 中未定义属性 {0}
js.jquery.efficiency.inspection.name=可以优化 JQuery 选择器
js.jquery.efficiency.inspection.allow.attribute.and.pseudo.selectors=允许特性和伪选择器
js.jquery.efficiency.inspection.attribute.used.message=jQuery 特性选择器可能低效
js.jquery.efficiency.inspection.pseudoselector.used.message=jQuery 伪选择器可能低效
js.jquery.efficiency.inspection.duplicated.selector=重复的 jQuery 选择器
js.accessibility.check.inspection.name=已引用无法访问的 @private 和 @protected 成员
js.convert.to.foreach.intention.name=将 'for-in' 转换为 'forEach' 调用
js.consecutive.commas.in.array.literal.inspection.name=数组文字中的连续逗号
js.consecutive.commas.in.array.literal.inspection.message=数组文字中的连续逗号
js.consecutive.commas.in.array.literal.inspection.insert.undefined=插入 'undefined'
js.check.function.signature.guess.optionality=将非类型化形参视为必选
js.check.function.signature.guess.optionality.hint=如果禁用，则所有未键入的形参均视为可选形参
es6.redundant.await.report.for.promises=报告 promise
es6.redundant.await.report.for.promises.hint=总是报告 'return await' 为冗余，但这会破坏 V8 的异步堆栈跟踪功能
es6.missing.await.report.for.promises=报告 return 语句中的 promise
es6.missing.await.report.for.promises.hint=在异步函数调用前插入 'await' 有助于 V8 提供异步堆栈跟踪
js.file.references.inspection.name=未解析的文件引用
js.file.references.inspection.ignore.complex.cases=忽略复杂 case
js.inspection.es6.modules.dependencies.family.name=缺少 import 语句
js.inspection.amd.modules.dependencies.family.name=缺少 AMD 模块依赖关系
js.inspection.promise.ignored.display.name=返回 promise 的方法调用结果被忽略
js.inspection.promise.ignored.problem.descriptor=从 {0} 返回的 Promise 被忽略
js.inspection.promise.value.expected.problem.descriptor=应为值，但使用了从 {0} 返回的 Promise
js.flowjs.group.name=Flow 类型检查器
js.flowjs.config.inspection.name=缺少 .flowconfig
js.flowjs.config.inspection.message=无关联的 .flowconfig
js.flowjs.coverage.inspection.name=Flow 不涵盖代码
js.flowjs.coverage.inspection.error.text=Flow 不涵盖此元素
js.flowjs.config.inspection.to.project.path.name=向项目根中添加 .flowconfig
js.flowjs.config.inspection.to.module.path.name=向模块内容根中添加 .flowconfig
js.flowjs.config.inspection.to.current.path.name=向当前目录中添加 .flowconfig
js.flowjs.annotation.inspection.name=Flow 类型检查器
js.flowjs.flag.comment.placement.inspection.name=位置错误的 @flow 标记
js.flowjs.flag.comment.placement.inspection.error=Flow 标志注释不在文件起始处
js.flowjs.flag.comment.placement.inspection.fix=将 Flow 标志注释移至文件起始处
js.flowjs.flag.without.language.version=无 Flow 语言版本的 Flow 标志
js.extjs.unresolved.ext.xtype.inspection.name=未解析的 Ext JS xtype
js.frameworks.sencha.xtype.not.found=找不到 xtype ''{0}'' 的 Ext JS 类
javascript.equality.comparison.with.coercion.family.name=替换但不进行类型强制
javascript.equality.comparison.with.coercion.display.name=相等运算符可能导致类型强制
javascript.equality.comparison.with.coercion.error.string=比较 #ref 可能导致意外类型强制 #loc
javascript.equality.comparison.with.coercion.fix=替换为 ''{0}''
javascript.equality.comparison.with.coercion.options.label=高亮显示 '==' 和 '!=' 的用法：
javascript.equality.comparison.with.coercion.option.always=所有
javascript.equality.comparison.with.coercion.option.always.except.null=与 null 或 typeof 比较时除外
javascript.equality.comparison.with.coercion.option.only.suspicious=仅可疑表达式
js.strict.mode.inspection.name=使用了非严格模式
js.strict.mode.inspection.error={0} 不处于严格模式下
js.strict.mode.inspection.fix=添加“use strict”杂注
js.strict.mode.inspection.redundant.pragma="use strict"杂注冗余
js.strict.mode.remove.pragma=移除“use strict”杂注
js.class.member.initialization.inspection.name=在 static 初始值设定项中使用可能未分配的属性
js.class.member.initialization.inspection.text=字段 ''{1}'' 在 ''{0}'' 之后声明，并且可能尚未分配
js.class.member.initialization.inspection.text.id=字段 ''{0}'' 引用本身
js.assignment.used.as.condition.name=用作条件的赋值
js.assignment.used.as.condition.text=<code>#ref</code> 作为条件使用
js.assignment.used.as.condition.fix=将 ''='' 替换为 ''{0}''
js.missing.switch.branches.inspection.name='switch' 语句缺少分支
js.missing.switch.branches.inspection.desc=''switch'' 语句缺少 case：{0}
js.missing.switch.branches.ignore.with.default=忽略具有默认分支的 switch 语句
js.unreachable.switch.branches.inspection.name=不可到达 'switch' 语句的 'case' 分支
js.unreachable.switch.branches.inspection.desc=不可到达的 'case' 分支
js.unreachable.switch.branches.ignore.with.dynamic=不在动态类型的上下文中显示此警告
js.unreachable.switch.branches.remove=移除不可到达的 'case' 分支
js.redundant.switch.problems.inspection.name='switch' 语句冗余，可以替换
js.redundant.switch.problems.inspection.empty='switch' 语句为空
js.redundant.switch.problems.inspection.empty.remove=移除空的 'switch' 语句
js.redundant.switch.problems.inspection.default='switch' 语句仅包含一个 'default' 子句
js.redundant.switch.problems.inspection.default.unwrap=解开 'switch' 语句
js.redundant.switch.problems.inspection.side.effects=并提取副作用
js.redundant.switch.problems.inspection.single='switch' 语句仅包含一个非默认子句
js.redundant.switch.problems.inspection.single.replace=将 'switch' 替换为 'if'
js.switch.no.default='switch' 语句没有 'default' 分支
js.switch.no.default.add=创建缺少的默认分支
js.variable.problems.inspection.name=声明了变量并在不同的 'case' 子句中使用
js.variable.problems.inspection.desc=变量 ''{0}'' 在子句 ''{1}'' 中声明， 但在子句 ''{2}'' 中使用
js.variable.problems.inspection.desc.ref.error=访问时引用错误
js.variable.problems.ignore.desc=对可变变量忽略
js.inspection.package.json.dependencies=package.json 中的依赖关系不匹配
js.inspection.missing.amd.dependency=缺少 AMD 模块依赖关系
js.inspection.missing.import=缺少 import 语句
js.inspection.missing.module.dependency=缺少模块依赖关系
typescript.narrowed.to=范围缩小至 ''{0}''
label.exclude.methods.classes=排除类方法:
dialog.title.add.classes=添加类
typescript.suspicious.constructor.parameter.assignment=构造函数中的参数赋值可疑。您忘了添加  'this.' 吗？
typescript.suspicious.constructor.parameter.assignment.desc=已分配构造函数字段形参
typescript.abstract.class.constructor.can.be.made.protected=abstract 类构造函数可以设为 protected
typescript.make.constructor.protected=将构造函数设为 protected
typescript.private.field.modifiers.mix=使用私有名称的字段不能具有 'public'、'private' 或 'protected' 访问修饰符
javascript.validation.message.flowjs.path=Flow 路径不正确
javascript.validation.message.interface.members.cannot.have.access.modifiers=接口成员不能具有访问修饰符
javascript.validation.message.interface.members.cannot.have.namespace.attributes=接口成员不能具有命名空间特性
javascript.validation.message.interface.members.cannot.be.final.modifiers=接口成员不能为 final
javascript.validation.message.static.modifier.is.allowed.only.for.class.members=仅允许类成员使用 static 修饰符
javascript.validation.message.interface.cannot.be.final.modifiers=接口不能为最终
javascript.template.context.type=JavaSc&ript 和 TypeScript
interface.should.have.no.variable.declarations=接口不应有变量声明
javascript.validation.message.implements.for.interface.not.allowed=接口不允许有实现列表
javascript.validation.message.interface.name.expected.here=此处应为接口名称
javascript.validation.message.class.name.expected.here=此处应为类名
javascript.validation.message.circular.dependency=循环依赖关系
javascript.validation.message.index.no.type=索引签名参数必须具有类型注解
javascript.validation.message.index.wrong.type=索引签名形参类型必须可以分配给 'string | number | symbol'
javascript.fix.remove.circular.dependency=移除循环依赖关系
react.jsx.syntax.used.name=已使用 React JSX 语法
react.jsx.syntax.used.description=已使用 React JSX 语法
js.void.function.result.used.name=使用了 void 函数返回值
js.void.function.result.used.description=使用了 void 函数返回值

# JSDoc validation
javascript.validation.message.interface.method.not.implemented=未实现来自于接口 {1} 的方法 {0}
javascript.validation.message.abstract.method.not.implemented=未实现类 {1} 中的 abstract 方法 {0}
javascript.validation.message.abstract.get.accessor.not.implemented=未实现类 {1} 的 abstract get 访问器 {0}
javascript.validation.message.abstract.set.accessor.not.implemented=未实现类 {1} 的 abstract set 访问器 {0}
javascript.validation.message.interface.property.not.implemented=未实现接口 {1} 的属性 {0}
javascript.validation.message.interface.get.accessor.not.implemented=未实现接口 {1} 的属性 get 访问器 {0}
javascript.validation.message.interface.set.accessor.not.implemented=未实现接口 {1} 的属性 set 访问器 {0}

javascript.validation.message.class.method.incompatible= ''{1}'' 类中的方法 ''{0}'' 不可分配给基类 ''{2}'' 中的同一方法
javascript.validation.message.class.property.incompatible= ''{1}'' 类中的属性 ''{0}'' 不可分配给基类 ''{2}'' 中的同一属性
javascript.validation.message.class.method.not.implemented=未实现类 {1} 的方法 {0}
javascript.validation.message.class.property.not.implemented=未实现类 {1} 的属性 {0}
javascript.validation.message.interface.call.signature.not.implemented=未实现接口 {0} 的调用签名
javascript.validation.message.interface.index.signature.not.implemented=未实现接口 {0} 的索引签名
javascript.validation.message.class.setter.cannot.have.return.type='set' 访问器不能有返回类型
javascript.fix.remove.externally.visible.symbol=移除外部可见符号
javascript.fix.remove.abstract.keyword=移除 'abstract' 修饰符
javascript.fix.remove.modifier=移除修饰符
javascript.fix.implement.members=实现成员
javascript.fix.implement.methods=实现方法
javascript.implement.all.interfaces=实现所有成员
javascript.implement.required.interfaces=实现所需的所有成员
javascript.implement.members.abstract=实现 abstract 成员

# Symbols
javascript.parameter=形参
javascript.local.variable=局部变量
javascript.global.variable=全局变量
javascript.global.function=全局函数
javascript.local.function=局部函数
javascript.global.decorator=装饰器
javascript.static.member.function=static 成员函数
javascript.static.member.variable=static 成员变量
javascript.instance.member.variable=实例成员变量
javascript.instance.member.function=实例成员函数
javascript.create.class.intention.name=创建类 ''{0}''
javascript.create.interface.intention.name=创建接口 ‘’{0}''
choose.class.to.import.title=要导入的类
javascript.fix.remove.override.modifier=移除重写修饰符
javascript.fix.remove.virtual.modifier=移除虚拟修饰符
javascript.validation.message.attribute.was.specified.multiple.times=多次指定修饰符 {0}
javascript.fix.remove.dynamic.modifier=移除动态修饰符
javascript.validation.message.function.override.for.object.method=从 Object 继承的方法无需重写
javascript.validation.message.function.override.without.parent.method=方法不重写超类的方法
javascript.parser.message.expected.gt=应为 >
javascript.parser.message.expected.lbracket=应为 [
javascript.parser.message.expected.readonly=应为 'readonly'
javascript.module.name=模块名称
javascript.exported.variable=导出的变量
javascript.exported.function=导出的函数
javascript.exported.class=导出的类
javascript.fix.create.function.component.jsx.name=创建函数组件 ''{0}''
javascript.fix.create.function.component.jsx.family=创建函数组件
javascript.fix.create.class.component.jsx.name=创建类组件 ''{0}''
javascript.fix.create.class.component.jsx.family=创建类组件
typescript.module.name=模块名称
typescript.type.alias.name=类型别名
typescript.type.guard.name=变量类型缩小为类型防护
typescript.type.guard.name.disable=禁用范围缩小的类型的着色
typescript.primitive.types.name=基元类型
typescript.type.parameter=类型形参
typescript.remove.type.declaration=移除类型声明

generate.constructor.overloads.and.fields.chooser.title=选择要使用的重载和要初始化的字段
generate.to.string.chooser.title=选择要在 toString 函数中使用的字段
members.to.implement.chooser.title=选择要实现的成员
members.to.override.chooser.title=选择要重写的成员
no.candidates=无候选项
no.methods.to.implement=找不到要实现的方法
no.members.to.implement=找不到要实现的成员
implement.members.abstract=实现 abstract 成员
no.methods.to.override=找不到要重写的方法
no.members.to.override=找不到要重写的成员
no.variables.for.getter=找不到没有 getter 的字段
no.variables.for.setter=找不到没有 setter 的字段
no.variables.for.getter.setter=找不到没有 getter 和 setter 的字段
javascript.validation.unused.import=未使用的 import
javascript.validation.fqn.to.replace.with.import=限定名称可替换为 import 语句
javascript.fix.optimize.imports=优化 import
javascript.parser.message.expected.doc.tag.value=应为标记值
javascript.parser.message.expected.doc.tag.name=应为文档标签名称
javascript.invalid.number.of.parameters=实参数量无效，应为 {0} 个
javascript.expression.type.implicitly.coerced.to.unrelated.type=表达式类型 {1} 隐式强制为不相关类型 {0}
javascript.argument.type.mismatch=实参类型 {1} 不可分配给形参类型 {0}
javascript.initializer.type.mismatch=初始值设定项类型 {1} 不可分配给变量类型 {0}
javascript.incorrect.variable.type.mismatch=变量类型 {1} 不可分配给类型 {0}
javascript.term.does.not.evaluate.to.function=方法表达式不是函数类型
javascript.term.does.not.evaluate.to.function.nullable=方法表达式可以为 null 或 undefined
javascript.term.does.not.evaluate.to.function2=属性不能作为函数调用
javascript.term.does.not.evaluate.to.function.line.break=表达式不可调用。如果这不应是调用，请检查是否缺少分号
javascript.term.does.not.evaluate.to.function2.fix=移除实参列表
javascript.term.nullable.indexer.qualifier=索引的表达式可以为 null 或 undefined
javascript.unused.import.remove=移除未使用的 'import'
javascript.unused.import.remove.specifier=移除未使用的元素
javascript.assigned.expression.type.mismatch=分配的表达式类型 {1} 不可分配给类型 {0}
javascript.vector.literal.element.type.mismatch=矢量文字元素类型 {1} 不可分配给类型 {0}
javascript.type.is.not.assignable.to.type=类型 {1} 不可分配给类型 {0}
javascript.no.call.signatures=分配的类型不包含调用签名
javascript.known.props.only=对象文字只能指定已知属性，但以下为额外属性：{0}
javascript.returned.expression.type.mismatch=返回的表达式类型 {1} 不可分配给类型 {0}
javascript.insert.cast.fix=插入转换
javascript.insert.primitive.wrapper.fix.family.name=使用基元类型包装
javascript.insert.generic.wrapper.fix.family.name=使用泛型类型包装
javascript.insert.wrapper.fix.text=使用 ''{0}'' 包装
typescript.insert.cast.fix=插入类型断言
es6.insert.await.fix=插入 await
es6.change.to.default.fix=对 ''{0}'' 使用默认导入
es6.change.to.named.import.fix=对 ''{0}'' 使用命名导入
typescript.insert.type.guard.fix.family=插入类型防护
typescript.insert.type.guard.surround=封闭在 ''{0}''中
typescript.insert.type.guard.prefix=前缀为 ''{0}''
typescript.insert.type.guard.postfix=使用 ''{0}'' 进行可选查询
typescript.insert.type.guard.nc=将限定符替换为 ''{0}''
typescript.insert.type.guard.nc.self=替换为 ''{0}''
error.not.available.in.javascript.code={0} 在 JavaScript 代码中不可用
cannot.modify.library.code=无法修改库或 SDK 代码
javascript.extract.method.title=提取函数
javascript.validation.message.function.override.incompatible.signature.generic=不兼容重写
javascript.validation.message.function.override.incompatible.access.modifier=不兼容重写，应有 ''{0}'' 访问修饰符
javascript.validation.message.function.override.incompatible.signature=不兼容重写，应有签名 ''{0}''
javascript.validation.message.function.override.incompatible.signature2=不兼容重写，应有返回类型 ''{0}''
javascript.validation.message.function.override.incompatible.signature3=不兼容重写，应有种类 ''{0}''
javascript.validation.message.function.method.invalid.overridden.parameter.type=不兼容重写，应有类型 ''{0}''
javascript.validation.message.interface.method.invalid.access.modifier=不兼容实现，应有 'public' 访问修饰符
javascript.validation.message.interface.method.invalid.signature=不兼容实现，应有签名 ''{0}''
javascript.validation.message.interface.method.invalid.signature2=不兼容实现，应有返回类型 ''{0}''
javascript.validation.message.interface.method.invalid.signature3=不兼容实现，应有 get / set ''{0}''
javascript.validation.message.duplicate.catch.block=重复 catch 块 #loc
javascript.validation.message.duplicate.catch.block.fix=移除重复的 catch 块
javascript.validation.message.missing.catch.or.finally=缺少 catch 或 finally 子句
javascript.validation.message.return.value.of.type.is.required=必需具备类型 {0} 的返回值
javascript.validation.message.return.statement.required=非无效返回类型必需具备 return 语句
typescript.validation.message.invalid.module.member.modifier=''{0}'' 不是模块成员的有效修饰符
javascript.validation.message.unresolved.component=未解析的组件 {0}
javascript.validation.message.super.constructor.call.should.be.in.constructor=超类构造函数调用应位于构造函数本体中
javascript.fix.remove.constructor=移除构造函数
javascript.metadata=元数据
javascript.class=类
javascript.interface=接口
javascript.label=标签
javascript.function.arrow=箭头函数
javascript.validation.message.unneeded.comma=不需要的逗号
javascript.validation.message.remove.unneeded.comma.fix=移除不需要的逗号
javascript.validation.message.constructor.cannot.be.static=构造函数不能为 static
javascript.create.event.handler.intention.name=创建事件处理程序 ''{0}''
javascript.validation.message.missed.super.constructor.call=缺少超类构造函数调用
javascript.validation.message.this.before.super.call=超类构造函数调用前不允许有 'this'
javascript.validation.message.baseMethod.before.super.call=超类构造函数调用前不允许有 'super'
javascript.validation.message.base.constructor.in.not.derived=仅允许在派生构造函数中调用基类构造函数
typescript.validation.message.base.constructor.must.be.first.statement=如果类包含初始化属性或具有参数属性，则基类构造函数调用必须为构造函数中的第一条语句
javascript.fix.create.constructor.invoke.super=创建匹配 super 的构造函数
javascript.fix.create.invoke.super=插入超类构造函数调用
javascript.interface.can.not.be.instantiated.message=无法实例化接口
javascript.abstract.class.can.not.be.instantiated.message=无法实例化 abstract 类
javascript.validation.message.set.method.should.be.void.or.without.type=setter 定义的返回类型必须为未指定或无效
javascript.validation.message.set.method.should.have.one.parameter=setter 定义必须正好有一个参数
javascript.validation.message.get.method.should.have.no.parameter=getter 定义不得有参数
javascript.validation.message.get.method.should.be.valid.type=getter 定义的返回类型不应为 {0}
javascript.validation.message.use.namespace.reference.or.access.modifier=使用命名空间或访问修饰符
javascript.validation.message.one.visibility.modifier.allowed=只允许一个可见性修饰符(public、protected、internal、private)
javascript.validation.destructuring.without.initializer=析构声明必须有初始值设定项
javascript.fix.remove.access.modifier=移除访问修饰符
javascript.fix.remove.final.modifier=移除 final 修饰符
javascript.validation.message.final.modifier.allowed.only.for.methods=final 修饰符只能应用于类和类方法
javascript.fix.remove.namespace.reference=移除命名空间引用
javascript.fix.remove.visibility.modifier=移除可见性修饰符
javascript.incorrect.array.type.in.for-in=数组键类型应为字符串
javascript.validation.message.unexpected.type.for.rest.parameter=Rest 参数不应有类型
typescript.validation.message.unexpected.type.for.rest.parameter=Rest 参数必须为数组类型或具有数组约束的泛型
typescript.validation.message.unexpected.type.for.rest.parameter.fix=替换为数组类型
javascript.fix.remove.type.reference=移除类型引用
javascript.validation.message.parameter.is.not.allowed.after.rest.parameter=rest 参数后不允许有任何参数
javascript.validation.message.comma.is.not.allowed.after.rest.element=rest 元素后不允许有逗号
javascript.validation.message.comma.is.not.allowed.after.last.parameter=最后一个参数后不允许有逗号
javascript.fix.remove.comma=移除逗号
javascript.fix.remove.parameter=移除形参
javascript.fix.remove.parameters=移除形参
javascript.fix.remove.initializer=移除初始值设定项
javascript.validation.message.parameter.should.be.initialized=应初始化形参
javascript.validation.message.parameter.non.optional.after.optional=必选形参不能位于可选形参后
javascript.validation.message.parameter.rest.optional=rest 形参不能是可选形参
javascript.fix.initialize.parameter=初始化形参
javascript.validation.message.rest.parameter.should.not.be.initialized=不应初始化 Rest 参数
javascript.validation.message.nested.classes.are.not.allowed=不允许嵌套类
javascript.validation.message.implements.is.not.allowed=标准 ECMAScript 中不允许有实现子句
javascript.validation.message.arguments.with.rest.parameter=使用 rest 形参时，'arguments' 对象不可用
js.validate.types.inspection.name=类型不匹配
typescript.validate.optional.parameter.inspection.error=参数不能有问号和初始值设定项
typescript.validate.optional.parameter.inspection.fix.question=移除问号
typescript.validate.generic.types.inspection.name=不正确的泛型实参
typescript.redundant.typescript.type.argument.inspection.name=冗余类型实参
typescript.duplicate.typescript.union.inspection.name=联合或相交类型组件重复
typescript.validate.generic.types.fix.delete=移除泛型实参
typescript.validate.generic.types.fix.add=添加泛型实参
typescript.validate.generic.types.inspection.error.argument.number=泛型类型 ''{0}'' 需要 ''{1}'' 类型实参
typescript.validate.generic.types.inspection.error.argument.number.between=泛型类型 ''{0}'' 需要介于 {1} 和 {2} 之间的类型实参
typescript.validate.generic.types.inspection.error.not.empty.argument=类型实参列表不能为空
typescript.validate.generic.types.inspection.error.not.empty.parameter=类型形参列表不能为空
typescript.validate.types.any.inspection.name='any' 类型的类型不匹配
typescript.validate.template.literal.types=模板类型 {1} 不可分配给约束类型 {0}
js.incompatible.types.comparison.inspection.name=类型不兼容的表达式的比较
js.incompatible.types.comparison.message=条件始终为 {0, choice,0#false|1#true}，因为类型 ''{1}'' 和 ''{2}'' 没有重叠
javascript.validate.imports.name=未解析的已导入名称
es6.validate.import.error=无法解析符号 ''{0}''
es6.prefer.short.import.name=可以缩短导入
typescript.reference.to.umd.global=已引用的 UMD 全局变量
typescript.field.can.be.made.readonly=可以为只读字段
javascript.suspicious.type.guard.desc=类型防护检查不健全
javascript.object.null.or.undefined.desc=对象为 'null' 或 'undefined'
javascript.suspicious.typeof.guard=''typeof'' 检查无效：''{0}'' 不能具有类型 ''{1}''
javascript.redundant.typeof.guard=''typeof'' 检查冗余：''{0}'' 始终具有类型 ''{1}''
javascript.falsy.typeof.guard=''typeof'' 检查始终为 false：{0}'' 始终具有类型 ''{1}''
typescript.suspicious.instanceof.guard=''instanceof'' 检查无效：''{0}'' 的类型与 ''{1}'' 无关
typescript.redundant.instanceof.guard=''instanceof'' 检查冗余：''{0}'' 具有类型 ''{1}'' 或 ''{1}'' 的子类型
typescript.redundant.instanceof.inheritor.guard=''instanceof'' 检查冗余：''{0}'' 具有类型 ''{1}'' 或 ''{1}'' 的继承者
javascript.object.is.null={0} 为 null
javascript.object.is.possibly.null={0} 可能为 null
javascript.object.is.undefined={0} 未定义
javascript.object.is.possibly.undefined={0} 可能为 undefined
javascript.object.is.null.or.undefined={0} 为 null 或 undefined
javascript.object.is.possibly.null.or.undefined={0} 可能为 null 或 undefined
typescript.smart.cast=范围缩小的类型
typescript.smart.cast.hyperlink=设置字体和背景
typescript.missing.augmentation.import=缺少增强导入
typescript.explicit.member.type.inspection.name=显式类型
typescript.config.inspection=不一致的 Tsconfig.json 属性
typescript.config.inspection.libs=缺少全局库
typescript.config.inspection.missing.option=缺少 tsconfig.json 选项 
typescript.config.inspection.libs.fix=在 tsconfig.json 中启用库 ''{0}''
typescript.config.inspection.config.options.fix=向 tsconfig.json 中添加 ''{0}''
typescript.config.inspection.fix.pattern=添加 ''{0}'' 属性
typescript.config.inspection.path.mapping.info=路径映射需要 baseUrl 属性
typescript.config.inspection.checkjs.info=属性 checkJs 需要 allowJs 属性
typescript.redundant.declaration=类型声明与推断的类型相匹配，因此可以移除
unnecessary.parentheses.display.name=不必要的圆括号
unnecessary.parentheses.problem.descriptor=<code>#ref</code> 周围的圆括号不必要 #loc
remove.unnecessary.parentheses.fix.text=移除不必要的圆括号
typescript.specify.type.explicitly=显式指定类型
typescript.specify.type.explicitly.from.hint=添加显式类型注解
typescript.specify.all.param.types.explicitly=显式指定所有形参类型
typescript.specify.all.param.types.explicitly.from.hint=向所有参数中添加显式类型注解
typescript.make.field.readonly=将字段设为只读
es6.replace.import.action.name=替换为 {0}
es6.replace.import.family.name=替换为较短的路径
js.validate.signature.inspection.name=签名不匹配
find.usages.of.base.interface={1} 的方法 {0}\n实现 {2} 的方法。\n要{3}基方法吗?
find.usages.of.base.class={1} 的方法 {0}\n重写 {2} 的方法。\n要{3}基方法吗?
javascript.fix.visibility.family=修复可见性问题
javascript.fix.set.element.visibility=将 {0} 设为 {1}
javascript.fix.set.method.return.type=使 ''{0}'' 返回 ''{1}''
javascript.fix.generate.argument.stubs=生成实参存根
javascript.deprecated.symbol.replace.fix=将弃用的代码替换为 {0}
javascript.deprecated.symbol.replace.fix.family=将弃用的代码替换为建议的替换
javascript.label.visibility.public=public(&B)
javascript.label.visibility.package_local=internal(&I)
javascript.label.visibility.private=private(&V)
javascript.label.visibility.protected=protected(&O)
move.members.refactoring.name=移动成员
move.members.dialog.title=移动成员
class.0.cannot.be.created=无法创建目标类 {0}，因为存在同名的限定元素
# Used in JSFormatUtil.formatVisibility
javascript.visibility.public=public
javascript.visibility.internal=internal
javascript.visibility.private=private
javascript.visibility.protected=protected
entity.in.parent.description={0} ({1} 内)
package.description=软件包 {0}
0.with.1.visibility.in.the.target.class.is.not.accessible.from.2=目标类中可见性为 {1} 的 {0} 无法从 {2} 访问
0.with.1.visibility.is.not.accessible.from.2=可见性为 {1} 的 {0} 将无法从 {2} 访问

# Refactoring
javascript.refactoring.variable.used.as.lvalue=要内联的变量在赋值的左侧使用
javascript.refactoring.variable.value.is.changed.when.accessed.from.closure=从闭包访问时变量值被更改
javascript.refactoring.inline.variable.title=内联变量
javascript.refactoring.inline.function.title=内联函数
javascript.refactoring.cannot.find.usages.of.definition.to.inline=无法找到要内联的定义的用法.
javascript.refactoring.searching.usages=查找用法
javascript.refactoring.cannot.inline.not.initialized.variable=无法内联未初始化的变量
javascript.refactoring.cannot.inline.destructuring.variable.with.default=无法内联使用默认值的析构变量
javascript.refactoring.cannot.inline.destructuring.rest.variable=无法内联析构 rest 变量
javascript.inline.element.is.not.used={0} 从未使用
javascript.refactoring.inline.dialog.title=内联 {0}
javascript.refactoring.inline.all.message=内联所有引用并移除 {0} ({1}) (&A)
javascript.refactoring.inline.this.only=仅内联此引用并保留 {0}(&K)
javascript.refactoring.cannot.inline.function.defined.in.library=无法内联外部库中定义的函数
javascript.refactoring.cannot.inline.function.referencing.arguments=无法内联引用实参的函数
javascript.refactoring.cannot.inline.interface.method=无法内联接口方法
javascript.refactoring.cannot.inline.function.referencing.rest.parameter=无法内联函数引用的 rest 参数
javascript.refactoring.cannot.inline.overrided.or.overridden.method=无法内联参与层次结构的方法
javascript.refactoring.cannot.inline.recursive.function=无法内联递归函数
javascript.refactoring.cannot.inline.function.with.multiple.returns=无法内联有多个退出点的函数
javascript.refactoring.cannot.inline.complex.expression.evaluation=无法内联复杂表达式评估
javascript.refactoring.cannot.inline.constructor=无法内联构造函数
javascript.refactoring.cannot.inline.jsx.usage=无法内联 JSX 标签用法
javascript.refactoring.cannot.inline.ambient.function=无法内联没有实现的声明
javascript.refactoring.function.to.es6.class.command=将函数 {0} 转换为类
js.convert.to.es6.class=转换为类
js.convert.to.es6.class.family.name=将函数及其成员声明转换为类
js.move.type.to.file.family=移至名称匹配的文件
js.create.derived.type.family=创建派生类/实现接口
js.create.derived.type.class=创建派生类
js.create.switch.cases=创建缺少的 'switch' 分支
js.create.switch.cases.fix=创建缺少的分支：{0}
js.edit.object.literal=编辑对象文字属性的值
js.create.derived.type.interface=实现接口
js.create.derived.type.abstract.class=实现 abstract 类
js.rename.file.to.match.type.name.family=重命名文件以匹配类型名称
js.rename.file.to.match.type.name=将文件重命名为 {0} 以匹配 {1} 名称
js.move.type.to.file.text=将 {0} 移至文件 {1}
javascript.refactoring.function.to.es6.class.defineProperty.warning.text=警告：将使用“Object.defineProperty”、“Object.defineProperties”或“Object.create”创建的属性转换为 ES6 语法可能会影响其可枚举性和可配置性
rename.destructuring.property.title=重命名析构属性
rename.destructuring.property.description=析构属性引用多个成员。应重命名相关属性，否则可能导致代码不一致。
rename.type.members.title=重命名类型成员
rename.type.members.union.intersection.mapped.description=检测到联合、相交或映射类型用法。应重命名相关属性，否则可能导致代码不一致。
rename.type.members.destructuring.description=检测到析构属性中的用法。应重命名相关属性，否则可能导致代码不一致。
make.private=设为 private
choose.destination.scope=选择目标范围
list.item.function.to.be.converted.to.class=要转换为类的函数
list.item.declarations.function.members.to.be.converted.to.class.members=要转换为类成员的函数成员的声明
tab.title.convert.to.class=转换为类
tab.title.refactoring.preview=重构预览
list.item.function.converted.to.class=转换为类的函数
list.item.declarations.that.were.not.converted=未转换的声明
tab.title.refactoring.result=重构结果
extract.method.declare.static=声明 static(&S)
extract.function.declare.functional.expression=声明函数表达式(&F)
extract.function.return.type=返回类型(&T):
extract.function.parameters=形参
extract.function.signature.preview=签名预览
extract.function.function=函数
extract.function.name=名称(&N):
extract.constant.type=类型(&T):
introduce.constant.target.class=目标类(&A):
introduce.field.type=类型(&T):
introduce.field.initialize.in=初始化位置
introduce.field.declaration=字段声明(&D)
introduce.field.current.method=当前方法(&M)
introduce.field.class.constructor=类构造函数(&C)
introduce.parameter.type=类型(&T):
introduce.parameter.optional=可选形参(&O)
introduce.variable.declaration=变量声明
introduce.variable.const=const(&C)
introduce.variable.let=let(&L)
introduce.variable.var=var(&V)
introduce.variable.var.of.type=类型的变量(&T):
introduce.variable.make.constant=设为常量(&C)
custom.template.variables=自定义模板变量(&C):

# Destructuring
javascript.find.usages.destructuring.target.dialog=速记析构变量使用 {0} 初始化。\n您想查找哪些用法?
javascript.destructuring.initializer=初始值设定项 {0}
javascript.destructuring.variable.only=仅析构变量
javascript.rename.destructuring.target.dialog.title=速记析构变量使用 {0} 初始化
javascript.rename.choose.target.message=您要重命名哪一个？
javascript.rename.shorthand.target.dialog.title=速记属性使用 {0} 初始化
javascript.rename.shorthand.property.description=属性
javascript.rename.file.with.related.title=重命名文件
javascript.rename.containing.file.message=是否也想将文件及其用法重命名为 {0}?
javascript.rename.related.declaration.message=是否想将 {0} 及其用法重命名为 {1}?
dialog.message.some.usages.cannot.be.updated.properly=有些用法无法正常更新。\n导入和导出中的用法、字符串用法或动态引用无法替换为析构。
dialog.message.cannot.propagate.when.having.usages.declarations.in.different.files=用法和声明位于不同文件中时，无法传播
dialog.message.write.usages.cannot.be.updated.with.destructuring=写入用法无法通过重构进行更新
dialog.message.expression.indexed.by.non.numeric.value=表达式使用非数字值编制索引
dialog.message.incomplete.destructuring.pattern.encountered.in.code=在代码中遇到不完整的析构模式
dialog.message.unsupported.destructuring.container=不支持的析构容器: {0}
dialog.message.some.usages.cannot.be.updated.properly.wrong.access=有些用法无法正常更新。\n无法替换不按名称访问属性的用法或者不按索引访问元素的用法。
dialog.message.cannot.transform.object.array.destructuring.patterns.for.same.element=无法为相同的元素转换对象和数组析构模式
dialog.message.transforming.multiple.nested.patterns.not.supported=数组析构不支持转换多个嵌套模式

javascript.refactoring.asdoc.for.abstracts=摘要的 ASDoc
0.is.not.allowed.in.interface=接口中不允许使用 {0} 
javascript.fix.remove.static.modifier=移除 static 修饰符
javascript.validation.message.override.can.be.applied.to.method=重写只能应用于函数声明
javascript.validation.message.dynamic.can.be.applied.to.class=动态特性只能应用于类声明
javascript.illegal.variable.type.void=非法变量类型：'void'
javascript.cannot.return.expression.from.function.with.void.result.type=无法从结果类型为 void 的函数返回值
javascript.cannot.return.expression.from.function.with.void.result.type.fix=移除返回值
javascript.validation.message.function.override.for.interface=对 {0} 中的方法进行了不兼容的重写
javascript.validation.message.incompatible.override=对 {0} 中的成员进行了不兼容的重写
class.does.not.have.inheritors.in.current.project={0} 在当前项目中没有继承者
javascript.kind.unknown=未知元素
js.unnecessary.semicolon.inspection.name=不必要的分号
js.unnecessary.semicolon.problem=不必要的分号 #loc
js.unnecessary.semicolon.fix.name=移除不必要的分号
javascript.refactoring.extract.function.title=提取函数
javascript.refactoring.extract.function.bad.selection=所选块应代表一组语句或表达式
javascript.refactoring.extract.function.multiple.exit.points=所选代码段有多个退出点
javascript.refactoring.extract.function.yield.and.return=所选片段同时包含 yield 表达式和 return 语句
javascript.refactoring.extract.function.no.loop.for.continue=代码段内没有用于 continue 语句的相应循环
javascript.refactoring.extract.function.no.loop.for.break=代码段内没有用于 break 语句的相应循环
javascript.refactoring.extract.function.no.switch.for.break=代码段内没有用于 break 语句的相应 'switch'
javascript.refactoring.extract.function.function.used.before.declaring=选定内容包含在声明之前使用的函数
javascript.refactoring.extract.function.already.exists.in.this.scope=此范围中已存在 {0}
javascript.validation.message.constructor.cannot.have.custom.visibility=构造函数应为 public 或未指定可见性
javascript.validation.message.can.not.override.final.method=无法从{0}重写最终方法
top.level.package=顶层软件包
javascript.parser.message.expected.dot=应为 .
js.comparison.with.nan.inspection.name=与 NaN 比较
js.comparison.with.nan.inspection.problem=与 NaN 的相等比较始终评估为 false
js.comparison.with.nan.inspection.problem2=与 NaN 的不等比较始终评估为 true
js.comparison.with.nan.inspection.quickfix=替换为 {0}isNaN(...)
js.constructor.returns.primitive.inspection.name=构造函数返回基元值
js.constructor.returns.primitive.inspection.problem=使用 'new' 调用时从构造函数返回的基元值将丢失
js.constructor.returns.primitive.inspection.quickfix=返回类型显式设置为 {0}
js.comment.matches.signature.inspection.name=不匹配的 JSDoc 和函数签名
js.comment.matches.signature.inspection.problem1=JSDoc 中未描述参数 {0}
js.comment.matches.signature.inspection.problem2=JSDoc 中描述的参数 {0} 未出现在函数签名中
js.comment.matches.signature.inspection.quickfix=更新 JSDoc 注释

livetemplate.description.fori=创建迭代循环
livetemplate.description.iter=迭代 (for..of)
livetemplate.description.itera=迭代 (for await..of)
livetemplate.description.itin=迭代 (for..in)
livetemplate.description.itar=遍历数组元素
livetemplate.description.ritar=反序遍历数组元素
livetemplate.description.us=插入 'use strict' 语句
livetemplate.description.ref=插入引用路径注释
livetemplate.description.defi=插入 define() 表达式
livetemplate.description.flow=插入 @flow 注解
livetemplate.description.importfrom=import 语句 - 从 ''a'' 导入 {b}
livetemplate.description.importns=import 语句 - 从 'a' 导入 * as b
livetemplate.description.importdefault=import 语句 - 从 'a' 导入 b
livetemplate.description.exportall=导出语句 - 从 'a' 导出 *
livetemplate.description.exportfrom=导出语句 - 从 ''a'' 导出 {b} 
livetemplate.description.exportitems=导出语句 - export {b}
livetemplate.description.moduleexports=导出语句 - module.exports = a
livetemplate.description.arf=使用箭头函数环绕

livetemplate.description.console.log=console.log()
livetemplate.description.console.warn=console.warn()
livetemplate.description.console.error=console.error()
livetemplate.description.console.info=console.info()
livetemplate.description.console.trace=console.trace()
livetemplate.description.console.assert=console.assert()

postfix.template.provider.name=JavaScript 和 TypeScript
postfix.template.condition.non.void.name=非 Void
postfix.template.condition.array.name=数组

macro.js.component.type.of=jsComponentTypeOf(Array)
macro.js.suggest.default.variable.kind=jsSuggestDefaultVariableKind(Boolean)

# Line markers
linemarker.implements.invalid=<无效>
linemarker.implements.text=实现 {1} 中的 {0}
linemarker.overrides.text=重写 {1} 中的 {0}
linemarker.implements.several=实现多种接口方法
linemarker.overridden=重写
linemarker.implemented=已实现
linemarker.overriding=重写
linemarker.implementing=实现
linemarker.javascript.typescript=JavaScript/TypeScript 行标记

js.validate.jsdoc.inspection.name=JSDoc 中的语法错误和未解析的引用
javascript.expected.class.or.descendant=应为类 {0} 或后代
javascript.qualified.class.name.expected=应为限定的类名
javascript.validation.message.unknown.metadata.annotation.used=使用了未知的元数据特性
javascript.validation.message.set.method.type.is.different.from.getter=Set 访问器方法的类型与 get 访问器类型不兼容，应为 ''{0}''
javascript.validation.message.get.method.type.is.different.from.setter=Get 访问器方法的类型与 set 访问器类型不兼容，应为 ''{0}''
typescript.validation.message.getter.and.setter.must.have.same.access.type=Getter 和 setter 必须具有相同的访问类型
actionscript.validation.message.set.method.access.type.is.different.from.getter=Flash 编译器错误 174646：Set 访问器方法访问类型不同于 get 访问器访问类型，应为 ''{0}''
actionscript.validation.message.get.method.access.type.is.different.from.setter=Flash 编译器错误 174646：Get 访问器方法访问类型不同于 set 访问器访问类型，应为 ''{0}''
javascript.validation.message.static.method.cannot.be.final=静态方法不能为最终
javascript.assign.parameter.to.field.intention.name=分配形参 ''{0}'' 给字段
javascript.fix.create.parameter=创建形参 ''{0}''
javascript.introduce.parameter.introduced.variable.value=值(&V):
0.is.not.a.legal.name=''{0}'' 不是合法的类名
item.already.exists={0} {1} 已存在
directory.already.contains.file=目录 ''{0}'' 已包含文件 ''{1}''
extract.subclass.command.name=从 {1} 提取子类 {0}
extract.interface.command.name=提取接口
extract.type.alias.command.name=提取类型别名
new.actionscript.class.dialog.title=新建 ActionScript 类
new.actionscript.interface.dialog.title=新建 ActionScript 接口
class.template.title=类
class.with.supers.template.title=包含 Super 的类
interface.template.title=接口
extract.0.turn.refs=提取 {0} 并尽量使用 (&T)
superclass.cannot.be.extracted.from.mxml.component=无法从 MXML 组件中提取超类。
superclass.cannot.be.extracted.from.type.alias=无法从类型别名中提取超类
superclass.cannot.be.extracted.from.enum=无法从枚举中提取超类
interface.cannot.be.extracted.from.type.alias=无法从类型别名中提取接口
interface.cannot.be.extracted.from.enum=无法从枚举中提取接口
javascript.fix.message.change.parameters.to.expected=将这些参数更改为预期参数
javascript.fix.message.change.return.type.to.expected=将返回类型更改为预期类型
js.last.comma.in.array.literal.inspection.name=数组文字中的最后一个逗号多余
js.last.comma.in.object.literal.inspection.name=对象文字中的最后一个逗号多余
error.wrong.caret.position.method.name=文本光标应置于要重构的方法的名称处。
changeSignature.vararg.not.last=Rest 形参应当为方法签名中的最后一个形参
parameter.type.is.not.specified=形参 ''{0}'' 的类型未指定。\n是否继续？
return.type.is.not.resolved=返回类型 ''{0}'' 未解析。\n是否继续？
change.signature.column.name.initializer=初始值设定项
change.signature.column.name.default.parameter=默认形参
change.signature.column.name.call.value=调用中的值
change.signature.parameter.table.empty.message=使用  '+' 按钮添加新参数
required.parameters.are.not.permitted.after.optional.parameters=必选形参不能位于可选形参后
javascript.fix.remove.setter.parameter.initializer=移除形参默认值
javascript.validation.message.setter.parameter.cannot.have.initializer=Setter 定义不能具有可选形参
javascript.changeSignature.no.call.value=新的必选形参 ''{0}'' 已添加。\n指定要用于此方法的所有现有调用的默认值。
es6.changeSignature.no.call.value=新形参 ''{0}'' 已添加。\n指定要用于此方法的所有现有调用的默认值或值。
javascript.changeSignature.call.value.not.allowed=形参 ''{0}'' 不允许使用默认值。因为没有为前面的参数指定它。
es6.changeSignature.call.value.not.allowed=形参 ''{0}'' 不允许使用调用中的值。因为没有为前面的参数指定它。
change.signature.usage.view.declarations.header=要重构的方法
{0}.visibility.will.break.methods.hierarchy=可见性为 {1} 的{0}无法参与层次结构
generate.delegate.method.conflict.message=无法通过不同的属性为同名成员生成委托
generate.delegate.method.conflict.message.title=无法生成委托
invalid.return.type.expression=返回类型 ''{0}'' 无效
invalid.parameter.type.expression=形参类型 ''{0}'' 无效
type.is.not.resolved=类型 ''{0}'' 未解析。\n是否继续？
invalid.field.type.expression=无效字段类型：''{0}''
choose.field.type=选择字段类型
new.field.action.text=字段
new.field.action.description=在类中创建新字段
create.field.dialog.title=创建字段
field.initializer.is.not.specified=未指定字段初始值设定项
new.method.action.text=方法
new.method.action.description=在类中创建新方法
create.method.dialog.title=创建方法
create.button.text=创建(&C)
class.already.contains.method.warning=类 ''{0}''''已经 {1, choice, 1# 包含|2#继承] 方法 ''{2}()''。\n是否继续？
class.already.contains.field.warning=类 ''{0}'' 已包含字段 ''{1}''。\n是否继续？
declare.static=声明 static(&S)
new.constructor.action.text=构造函数
new.constructor.action.description=创建构造函数
create.constructor.dialog.title=创建构造函数
change.method.signature.fix.text=更改 {0} 签名
change.method.signature.and.update.delegating.call.fix.text=更改 {0} 签名以匹配 {1} 调用和更新调用
change.method.signature.and.update.delegating.call.noname.fix.text=更改签名以匹配 {0} 调用和更新调用
change.method.signature.delegating.default.text=委托
change.method.signature.fix.family.name=更改方法签名
change.method.signature.and.update.delegating.call.fix.family.name=更改方法签名并更新委托调用

# Settings
settings.javascript.root.configurable.name=JavaScript
settings.typescript.root.configurable.name=TypeScript
settings.javascript.linters.configurable.name=代码质量工具
settings.javascript.linters.autodetect.disabled=禁用 {0}(&D)
settings.javascript.linters.autodetect.configure.automatically=自动 {0} 配置 (&A)
settings.javascript.linters.autodetect.configure.automatically.help.text={0} 将使用 node_modules 目录中的 {1} 软件包，还会使用与当前文件或其任何父文件夹位于同一文件夹中的 {2} 配置文件。
settings.javascript.linters.autodetect.configure.manually=手动 {0} 配置 (&M)
settings.javascript.linters.jshint.configurable.name=JSHint
settings.javascript.only.type.based.completion=仅基于类型补全 (&C)
settings.javascript.opt.chain.completion=为可 null 类型建议包含可选链接的条目(&O)
settings.javascript.overrides.completion=在重写补全中展开方法体
settings.javascript.var.names.completion=建议变量和形参名称(&V)
settings.javascript.field.names.completion=为类字段建议名称 (&F)
settings.javascript.var.names.completion.desc=补全名称
settings.javascript.var.names.completion.types=为建议的形参名称添加类型注解(&T)
settings.javascript.var.names.completion.names.only=无类型
settings.javascript.var.names.completion.types.for.params=具有函数形参的类型
settings.javascript.var.names.completion.types.for.params.fields=具有形参和字段的类型
settings.javascript.var.names.completion.types.except.fields=随处都是类型，字段除外
settings.javascript.var.names.completion.types.everywhere=随处都是类型
settings.javascript.only.type.based.completion.tooltip=根据类型信息显示较少的补全建议。可能会显著提高性能。
settings.javascript.lang.templates.configurable.name=模板
es6.auto.import.options.completion.add.imports=在代码补全时添加 ES6 导入
es6.auto.import.options.title=TypeScript / JavaScript
typescript.auto.import.options.add.imports=自动添加 TypeScript 导入
typescript.auto.import.options.add.imports.on.the.fly=动态明确 import
typescript.auto.import.options.add.on.code.completion=代码补全
typescript.auto.import.options.show.popup=包含自动导入工具提示
js.import.options.merge.import=合并同一模块中成员的导入
js.import.options.use.node.resolution=在 index.js 可用时使用目录导入（节点样式模块解析）
js.import.options.use.explicit.js.extension=使用文件扩展名:
js.add.members.to.type.desc=将成员添加到类或接口
js.add.members.to.type=将成员 {0} 添加到 ''{1}''
js.import.options.sort.members=对导入的成员排序
js.import.options.sort.module.name=按模块对导入排序
es6.import.options.paths=使用路径别名：
es6.import.options.paths.help=此选项配置 import 语句中使用的路径样式。<br><br>选择“始终”时，IDE 在添加导入时始终使用来自 webpack、system.js 或 jsconfig.json 配置的别名。<br><br>选择“仅在指定路径之外的文件中”时，IDE 针对为之定义了别名的文件之间的导入使用相对路径。在所有其他文件中使用路径映射。<br><br>选择“从不”时，则不使用别名。
typescipt.import.options.paths.help=此选项配置 import 语句中使用的路径样式。<br><br>选择“始终”时，IDE 在添加导入时始终使用从 tsconfig.json 映射的路径。<br><br>选择“仅在指定路径之外的文件中”时，IDE 针对为之定义了映射的文件之间的导入使用相对路径。在所有其他文件中使用路径映射。<br><br>选择“从不”时，则不使用路径映射。
typescript.import.options.paths=使用 tsconfig.json 的路径映射：
typescript.import.options.use.config=使用相对于 tsconfig.json 的路径
javascript.import.options.use.resource.root=使用相对于项目、资源或源根目录的路径
typescript.import.options.blacklist.title=不要完全从此导入：
js.flow.settings.executable.label=Flow 软件包或可执行文件 (&F)：
js.flow.settings.executable.dialog.title=选择 Flow 软件包或可执行文件
js.flow.services.label=为之使用 Flow 服务器：
js.flow.enable.type.checking=类型检查
js.flow.enable.other.services=导航、代码补全和类型提示
js.flow.enable.flow.service.error=\ 不正确的 Flow 路径
js.flow.enable.flow.service.error.empty=Flow 可执行文件的路径为空
js.flow.enable.flow.service.error.on.checking=检查 Flow 路径时出错：{0}
js.flow.enable.flow.service.error.message={0}。禁用所有 Flow 服务或为可执行文件提供有效路径。
js.flow.settings.auto.save=自动保存所有修改的文件
js.flow.settings.auto.save.warning=只有保存其他所有修改过的文件时，Flow 才会检查当前文件。
js.flow.settings.auto.save.warning.lsp=这样 Flow 将始终显示最新的错误状态。
js.dialect.settings.dialog.title=JavaScript 语言版本
js.dialect.settings.caption=
js.dialect.settings.tableTitle=语言
js.dialect.settings.override.question=重写子目录和文件的语言版本？
js.dialect.settings.override.title=重写语言版本设置
js.dialect.settings.empty.text=使用 + 按钮添加目录，并选择 JavaScript 版本
js.dialects.customized.label=根据目录自定义
configure.code.completion.settings=配置代码补全设置

# Bower
settings.javascript.bower.configurable.name=Bower
bower.packages.view.dependencies=依赖项:
bower.package=Bower 软件包(&B):
bower.json=bower.json (&O)：
bower.correct.path=请更正 {0} 的路径
bower.package.name=Bower 软件包
bower.dialog.message.specify.package=指定正确的 bower 软件包: 未找到 "{0}" 文件
bower.required.version.notification.content=要查看 bower 软件包，您需要 bower@1.0.0 或更高版本
bower.no_description_available.text=无可用描述
dialog.message.command.timed.out=命令 ''{0}'' 超时
dialog.message.command.cancelled=命令 ''{0}'' 已取消
dialog.message.command.finished.with.exit.code=命令 ''{0}'' 已完成，退出代码为 {1}。Stdout:\n{2}\n\nstderr:\n{3}

# JS language version management
js.language.version.combo.es5=ECMAScript 5.1
js.language.version.combo.js185=JavaScript 1.8.5
js.language.version.combo.js185.description=已弃用特定于 Firefox 的 ECMAScript 实现。请考虑切换。
js.language.version.combo.es6=ECMAScript 6+
js.language.version.combo.es6.description=ECMAScript 2015+、一些提案和 JSX
js.language.version.combo.nashorn=Nashorn JS
js.language.version.combo.nashorn.description=Java 中的 JavaScript 实现
js.language.version.combo.flow=Flow
js.language.version.combo.flow.description=ECMAScript 6 中的 Flow 和 JSX
js.language.version.label=JavaScript 语言版本
js.switch.to.jsx.inspection.dismiss=关闭
ts.switch.to.jsx.inspection.name=更改文件扩展名为 .tsx
javascript.change.language.level.message=更改 JavaScript 语言版本为 {0}
javascript.change.language.level.family=更改 JavaScript 语言版本

# JS library management
js.library.attach.debug=附加调试版本(&D)…
js.library.attach.release=附加发布版本(&R)…
js.library.unresolved.url.inspection.name=HTTP 链接缺少本地存储的库
js.library.download.fix=下载库
js.library.downloading.library=正在下载库
js.library.documentation=文档
js.library.configurable.name=库
js.library.download.stubs.label=TypeScript 社区存根
js.library.successfully.downloaded=已成功下载 {0}

choose.super.method=<html><body>选择 <b>{0}</b> 的 Super 方法（找到 {1}）</body></html>
choose.super.function=<html><body>选择 <b>{0}</b> 的 Super 函数（找到 {1}）</body></html>
choose.super.field=<html><body>选择 <b>{0}</b> 的 Super 字段（找到 {1}）</body></html>
choose.super.classifier=<html><body>选择 <b>{0}</b> 的超类或接口（找到 {1}）</body></html>
choose.subclass=<html><body>选择 <b>{0}</b> 的子类（找到 {1}）</body></html>
choose.implementing.class=<html><body>选择 <b>{0}</b> 的实现（找到 {1}）</body></html>
choose.overridden.method=<html><body>选择 <b>{0}</b> 的重写方法（找到 {1}）</body></html>
choose.overridden.function=<html><body>选择 <b>{0}</b> 的重写函数（找到 {1}）</body></html>
choose.implementing.method=<html><body>选择 <b>{0}</b> 的实现(找到 {1} 个)</body></html>
javascript.parser.message.expected.newline.or.semicolon=应为换行符或分号
javascript.invalid.delete.target.message=删除运算符目标无效，应为字段引用
javascript.with.statement.is.not.allowed.in.strict.mode.message=严格模式下不允许使用 With 语句
javascript.validation.message.redefining.is.not.allowed=不允许重新定义 {0}
javascript.validation.message.referencing.arguments.caller.callee.is.not.allowed=不允许从实参中引用 'caller' 和 'callee'
javascript.validation.message.referencing.function.arguments.property.is.not.allowed=不允许引用 'arguments' 函数属性
javascript.validation.message.arguments.is.readonly='arguments' 只读
javascript.validation.message.eval.cannot.be.assigned=不能在严格模式下分配 'eval'
javascript.octal.literals.are.not.allowed.es6.message=不允许使用前缀为 '0' 的八进制文字。改用 '0o' 前缀
javascript.octal.literals.are.not.allowed.es5.message=前缀为 '0' 的八进制文字已过时，不建议使用
javascript.octal.sequences.are.not.allowed.message=不允许八进制转义序列
javascript.invalid.extended.unicode.escape=扩展的 Unicode 转义仅允许介于 0x0 和 0x10FFFF 之间的值
javascript.octal.literals.are.not.allowed.in.strict.mode=在严格模式下不允许八进制文字
javascript.octal.literals.warn.always=关于 ES5-代码中过时八进制文字的警告
javascript.validation.message.only.one.default.is.allowed=\ switch 中只允许一个默认子句
javascript.fix.remove.default=移除默认子句
javascript.validation.message.accessor.could.not.be.nested.under.other.function=访问器方法不能嵌套在其他函数中
javascript.validation.message.es5.function.declarations.allowed.on.top.level.or.function=禁止在程序或函数的顶层使用函数语句
class.chooser.not.available.in.dumb.mode=正在进行索引更新，选择器不可用。
choose.super.class.title=选择超类
choose.base.component.title=选择超类
choose.super.interface.title=选择 Super 接口
0.is.not.accessible.from.1=无法从 {1} 访问 {0}
javascript.constructor.call.without.new.message=没有 new 的构造函数调用
javascript.qualified.name.is.not.imported.message=未导入限定名称 #loc
javascript.element.is.not.accessible.message=元素不可访问 #loc
javascript.protected.member.is.not.accessible.message=protected 成员不可访问 #loc
javascript.protected.constructor.is.not.accessible.message=protected 构造函数不可访问 #loc
javascript.private.member.is.not.accessible.message=private 成员不可访问 #loc
javascript.export.only.member=元素仅导出
javascript.private.constructor.is.not.accessible.message=private 构造函数不可访问 #loc
javascript.jsdoc.protected.member.is.not.accessible.message=protected 成员不可访问 #loc
javascript.jsdoc.private.member.is.not.accessible.message=private 成员不可访问 #loc
javascript.static.member.is.not.accessible.message=static 成员不可访问 #loc
javascript.instance.member.is.not.accessible.message=实例成员不可访问 #loc
javascript.element.need.to.be.exported=未导出元素
javascript.element.need.to.be.imported=未导入元素
javascript.element.default.instead.named=使用了默认导入而不是命名导入
javascript.element.need.to.be.included.to.config=tsconfig.json 中不包含相应文件
javascript.argument.types.mismatch=实参类型与形参不匹配
javascript.member.from.unopened.namespace.message=未打开命名空间的成员 #loc
javascript.property.is.read.only.message=只读属性 #loc
javascript.property.is.write.only.message=只写属性 #loc
javascript.assume.uppercase.functions.to.be.constructors=假设只有大写的函数是构造函数
javascript.not.a.constructor.call.message=不是构造函数调用
cannot.refactor.anonymous.function=现有非调用用法阻止调用站点分析。
change.signature.method.references.arguments=函数引用实参，更改签名后代码可能会中断
change.signature.call.expression.contains.spreads=函数调用包含传播实参。用法将保持不变。
change.signature.tagged.template.issue=无法更新标记的模板调用。用法将保持不变。
change.signature.conflict.incompatible.override=重写 {0} 的参数个数与重构 {1} 的参数个数不同。重构期间将忽略 {2}。
change.signature.conflict.incompatible.implementation=实现 {0} 的参数个数与重构 {1} 的参数个数不同。重构期间将忽略 {2}。
change.signature.conflict.eliminating.parameter.property.breaks.usages=将参数-属性转换为简单的参数将中断 {0} 的字段用法
change.signature.conflict.readonly.parameter.property.write.usage=将 {0} 变为只读将中断非读取用法
javascript.missed.argument.for.parameter=形参 {0} 缺少实参

# Code folding settings
checkbox.collapse.object.literals=对象文字
checkbox.collapse.one.line.function.literals=JavaScript 和 TypeScript 中的单行函数
checkbox.collapse.array.literals=数组文字
checkbox.collapse.xml.literals=XML 文字
change.signature.value.column.title=值
change.signature.column.name.optional.flag=可选
change.signature.column.name.modifier=修饰符

# Flow general
javascript.flow.error.panel.all.errors=显示所有错误
js.flow.all.servers.action.restart=重启所有 Flow 服务器
js.flow.has.unsaved.files=由于修改了某些文件，因此没有执行高亮显示
js.flow.tool.window.name=Flow
flow.js.get.type=Flow JS:Get 类型
flow.show.error.details=显示错误详情
can.t.find.flow.executable=找不到 Flow 可执行文件
process.terminated=进程已终止
progress.text.modifying=正在修改 {0}
progress.text.initializing.opened.files=正在初始化打开的文件

# Code style settings
js.code.style.punctuation.tab.title=标点
space.before.name.value.separator=在属性名称-值分隔符 ':' 前面
space.after.name.value.separator=在属性名称-值分隔符 ':' 后面
space.before.function.left.parenth=在函数表达式中
actionscript.space.after.dots.in.rest.parameter=在 rest 参数中的 '...' 后面
space.after.dots.in.rest.spread=在 rest/spread 中的 '...' 后面
space.before.generator.mult=在生成器中的 '*' 前面 
space.after.generator.mult=在生成器中的 '*' 后面 
spaces.within.object.type.braces=对象文字类型大括号
space.before.type.colon=在类型引用冒号 ':' 前面
space.after.type.colon=在类型引用冒号 ':' 后面
space.before.class.lbrace=类的左大括号
space.before.class.interface.module.lbrace=类/接口/模块左大括号
spaces.within.object.literal.braces=对象文字大括号
spaces.within.import.braces=ES6 导入/导出大括号
spaces.within.indexer.brackets=索引访问中括号
spaces.within.array.initializer=数组中括号
spaces.within.union.and.intersection=联合和相交类型
spaces.within.type.assertion=类型断言
spaces.arrow.function=箭头函数(=>)
spaces.async.arrow.function=在异步箭头函数中
spaces.within.interpolation.expressions=插值表达式
spaces.within.unary.additive=一元加法运算符 (+,-,++,--)
spaces.after.unary.not=在 'not' (!) 和 '!!' 后面
spaces.before.unary.not=在 'not' (!) 和 '!!' 前面
js.blank.lines.around.method=环绕方法:
js.blank.lines.around.function=Around 函数：
js.spaces.in.flow.category=在 Flow 中
js.wrap.settings.import=ES6 导入/导出
js.align.properties.none=不对齐
js.align.properties.on.colon=冒号上
js.align.properties.on.value=值上
js.function.call.parentheses=函数调用括号
js.function.declaration.parentheses=函数声明括号
js.function.brace.style=在函数声明中
js.function.expression.brace.style=在函数表达式中
js.function.parameters.wrap=函数声明参数
js.function.call.wrap=函数调用实参
js.space.before.function.left.brace=函数左大括号
js.format.cstyle.comments=对齐多行
js.chained.call.dot.on.next.line='.' 在新行
js.generated.use.public.modifier=使用 'public' 修饰符
js.generated.use.as.cast=首选 'as' 类型转换
js.generated.types=类型
js.generated.types.settings.link=显式类型的代码样式设置
js.generated.explicit.types=此项的首选显式类型：
js.generated.explicit.var.types=变量和字段
js.generated.explicit.return.types=函数声明返回
js.generated.explicit.return.expression.types=函数表达式返回
js.trailing.comma.keep=保持
js.trailing.comma.remove=移除
js.trailing.comma.whenMultiline=多行时添加
js.extends.list.wrap=Extends 列表
js.align.multiline.extends.list=多行时对齐
js.extends.keyword.wrap=扩展关键字
js.wrap.settings.union.and.intersection.types=联合和相交类型
js.code.style.object.literals.category.name=对象
js.code.style.align.caption=对齐
js.code.style.align.from.clause.caption=对齐 'from' 子句
js.wrap.settings.var.group.name=变量声明
js.code.style.do.not.align.var.statement=不对齐
js.code.style.align.var.statements=当多行时
js.code.style.align.var.statements.and.assignments=分组时
js.code.style.array.group.name=数组
js.array.new.line.after.left.bracket=在 '[' 后换行
js.array.new.line.before.right.bracket=将 ']' 置于新行中

js.method.can.be.static=方法可以为 static
js.method.can.be.static.option=仅检查 'private' 方法
make.method.static=设为 'static'
typescript.fix.change.member.access=设为 ''{0}''
js.fix.change.member.access.to.sharp=使用 '#' 设为 private
declare.event.0=声明事件 ''{0}''
js.variable.might.not.been.initialized=变量可能尚未初始化 #loc
js.variable.initializer.is.redundant=变量初始值设定项冗余 #loc
js.value.assigned.is.never.used=从未使用过所赋之值 #loc
js.value.assigned.to.is.never.used=赋给 ''{0}'' 的值从未使用 #loc
javascript.fix.change.type=''{0}'' 类型更改为 ''{1}''
javascript.fix.change.parameter.type=形参 ''{0}'' 类型更改为 ''{1}''
javascript.change.jsdoc.type.family.name=更改 JSDoc 中元素的类型
change.signature.dialog.title=更改 {0} 的签名
javascript.fix.add.enum.values=添加枚举值
javascript.fix.add.string.enum.values=添加字符串枚举值
typescript.intention.convert.import.require=将 import require 转换为 import from
typescript.intention.convert.import.require.text=转换为 {0}
javascript.fix.create.implements=使 ''{0}'' 实现 ''{1}''
javascript.fix.create.inheritor.family=从 super 类型继承
javascript.fix.implement.family=在派生类中实现
javascript.fix.implement.chooser.title=从中实现成员
javascript.fix.implement.chooser.all=所有类
javascript.fix.implement=实现 {0}
javascript.fix.create.extends=使 ''{0}'' 扩展 ''{1}''
javascript.report.unused.properties=报告未使用的属性
javascript.report.unused.definitions=报告未使用的定义
javascript.check.global.definitions=检查全局范围内的赋值
javascript.strictly.check.global.vars=将未声明的全局变量报告为错误
javascript.strictly.check.object.properties=将未声明的属性报告为错误
javascript.strictly.check.global.functions=将未声明的全局函数报告为错误
change.signature.column.type=类型
change.signature.column.name=名称
javascript.invalid.invoker.target=无效调用目标
js.declarations.at.scope.start.inspection='var' 未在函数开头声明
js.make.single.var.statement=设为单变量语句
js.declaration.is.not.at.scope.start=var 语句不在范围开始
js.move.to.scope.start=将 var 语句移至范围开始
js.primitive.type.wrapper.usage.inspection=使用了基元类型对象包装器
js.replace.with.type.cast.to.primitive=替换为 {0} 的类型转换
js.assigning.to.primitive.type.property=赋给基元的值将丢失
js.primitive.type.improper.instantiation.inspection={0} 实例化可以简化
js.replace.with.literal=替换为 {0} 文字
non.ascii.identifiers.inspection.name=包含非 ASCII 符号的标识符
non.ascii.identifiers.only.ascii=仅允许 ASCII 名称
non.ascii.identifiers.non.ascii.found=<html>名称包含非 ASCII 符号：{0}</html>
non.ascii.identifiers.mixed.set=<html>名称同时包含 ASCII 和非 ASCII 符号：{0}</html>

element.name.anonymous=<anonymous>
element.name.default=<默认>
duplicate.parameter.name=重复的形参名称: {0}
rename.accessors.dialog.title=重命名字段
rename.accessors.dialog.text=是否将属性访问器也重命名为 ''{0}''？
insert.new.keyword.fix.name=插入新关键字
insert.this.keyword.fix.name=添加 this 限定符
insert.class.fix.name=添加类名限定符
replace.implements.keyword.fix.name=将 'implements' 更改为 'extends'
superclass.label.text=超类(&S):
varible.name.column.title=名称
varible.value.column.title=值
custom.variables.step.title.label.text=模板 ''{0}'' 中的自定义变量 (&C)：
create.class.ok.button.text=创建
create.class.name.label=名称(&N):
create.class.package.label=软件包:
create.class.template.label=模板(&T):
create.class.superclass.label=超类(&S):
create.class.interfaces.label=接口(&I):
action.structureview.show.object.inherited=从对象继承

# JSHint
jshint.option.edit.dialog.title=设置 ''{0}'' 选项
jshint.clear.field.to.disable=清除要禁用的字段
jshint.illegal.integer=非法整数
jshint.use.config.files=使用配置文件
jshint.version.label=版本(&V):
jshint.label.bundled.suffix=(捆绑)
jshint.tree.link.set=设置
jshint.label.no.version=无版本
jshint.exception.balloon.action.retry=<a href=''{0}''>重试</a>
jshint.exception.balloon.action.configure.proxy.or.retry=<a href=''{0}''>配置 HTTP 代理</a>或<a href=''{1}''>重试</a>
filetype.jshint.config.description=JSHint 配置
filetype.jshint.config.display.name=JSHint 配置
jshint.suppress.text.suppress.for.line=禁止行
jshint.options.tree.tooltip.set.a.new.value=设置新值
jshint.config.option.default.name=默认
jshint.config.default.description=<div style="padding-bottom:10px"><div><b>.jshintrc</b></div><div style="padding-left:10px; padding-top:4px;">对 JavaScript 文件进行 Linting 检查时，IDE 会从文件所在的文件夹开始查找 .jshintrc，然后上行到文件系统根目录。</div></div><div><div><b>package.json</b></div><div style="padding-left:10px; padding-top:4px;">将您的配置添加到项目的 package.json 文件中的 <code>jshintConfig</code> 属性下。</div></div>
jshint.config.option.custom.name=自定义配置文件
jshint.config.option.custom.browser.title=选择 JSHint 配置文件 （*.jshintrc）
jshint.config.failed.to.read=无法读取 JSHint 配置
jshint.config.extends.cyclically=JSHint 配置循环扩展
jshint.config.error.failed.to.read.property=无法从 package.json 读取 ''{0}'' 属性
jshint.config.error.cannot.locate.ext.config=JSHint: 无法定位扩展配置
jshint.config.error.cannot.parse.ext.config=JSHint: 无法解析扩展配置
jshint.latedef.false.text=不警告
jshint.latedef.true.text=禁止变量在未定义的情况下使用
jshint.latedef.nofunc.text=<html><body>禁止变量在未定义的情况下使用，<br>但允许函数声明。</body></html>
jshint.unused.false.text=不检查任何内容
jshint.unused.true.text=<html><body>检查所有变量和参数，但允许<br>使用的参数后存在未使用参数</body></html>
jshint.unused.vars.text=检查变量，而不是函数形参
jshint.unused.strict.text=检查所有变量和参数
jshint.progress.title.updating.jshint=正在将 JSHint 更新到 {0}
jshint.progress.title.downloading=正在下载 {0}
jshint.progress.title=JSHint {0}
jshint.quotmark.false.text=允许两种引号
jshint.quotmark.true.text=仅允许单引号或双引号
jshint.quotmark.single.text=仅允许单引号
jshint.quotmark.double.text=仅允许双引号
jshint.inspection.message.duplicate.options=重复 JSHint 选项: {0}，{1}。
jshint.inspection.message.unexpected.jshint.option.name=意外的 JSHint 选项名称
jshint.inspection.message.unexpected.value=意外值
jshint.inspection.message.expected.values.x.or.y=预期值: {0} 或 {1}
jshint.inspection.message.expected.value=预期值: {0}
jshint.inspection.message.object.or.array.expected=应为对象或数组
jshint.inspection.message.not.loaded=未加载 JSHint {0}
jshint.inspection.message.config.not.found=未找到 JSHint 配置
jshint.inspection.message.malformed.config=JSHint 配置格式错误
jshint.inspection.message.prefix=JSHint:

jshint.option.esversion.description.short=在与指定的 ECMAScript 版本不兼容时发出警告
jshint.option.latedef.description.short=当变量在未定义的情况下使用时发出警告
jshint.option.unused.description.short=存在未使用的变量时发出警告
jshint.option.indent.description.short=缩进
jshint.option.quotmark.description.short=引号
jshint.option.predef.details=指定全局变量及其可分配状态:\n<pre>DISQUS:true、jQuery:false</pre>\n<p/>此时，JSHint 允许您重写 DISQUS，但禁止重写 jQuery。
jshint.option.bitwise.description.short=有关使用逐位运算符的警告
jshint.option.camelcase.description.short=有关变量命名的警告
jshint.option.curly.description.short=块省略 <code>{}</code> 时发出警告
jshint.option.enforceall.description.short=代码未遵守最严格的配置时发出警告
jshint.option.eqeqeq.description.short=有关不安全比较的警告
jshint.option.es3.description.short=有关与 ES3 规范不兼容的警告
jshint.option.es5.description.short=有关与 ES5 规范不兼容的警告
jshint.option.forin.description.short=有关不安全 <code>for..in</code> 的警告
jshint.option.freeze.description.short=有关覆盖原生对象原型的警告
jshint.option.immed.description.short=有关未使用括号将函数括起来而直接调用函数的警告
jshint.option.newcap.description.short=有关使用非大写形式的构造函数的警告
jshint.option.noarg.description.short=有关 <code>arguments.caller</code> 和 <code>.callee</code> 的警告
jshint.option.nocomma.description.short=有关使用逗号运算符的警告
jshint.option.noempty.description.short=有关空块的警告
jshint.option.nonbsp.description.short=有关“不间断空格”字符的警告
jshint.option.nonew.description.short=有关副作用 <code>new</code> 用法的警告
jshint.option.plusplus.description.short=有关使用一元递增和递减运算符的警告
jshint.option.undef.description.short=未定义变量时发出警告
jshint.option.varstmt.description.short=有关使用 VariableStatements 的警告
jshint.option.strict.description.short=代码未采用严格模式时发出警告
jshint.option.trailing.description.short=有关尾随空格的警告
jshint.option.maxparams.description.short=函数中的最大形参数量
jshint.option.maxdepth.description.short=块的最大深度
jshint.option.maxstatements.description.short=函数中的最大语句数量
jshint.option.maxcomplexity.description.short=代码中的最大循环复杂度
jshint.option.maxlen.description.short=行的最大长度
jshint.option.asi.description.short=禁止缺少分号的警告
jshint.option.boss.description.short=禁止有关 <code>if/for/…</code> 内部赋值的警告
jshint.option.debug.description.short=禁止有关调试模式的警告
jshint.option.elision.description.short=禁止有关 ES3 数组省略元素的警告
jshint.option.eqnull.description.short=禁止有关 <code>== null</code> 的警告
jshint.option.esnext.description.short=EcmaScript.next
jshint.option.evil.description.short=禁止有关 <code>eval</code> 的警告
jshint.option.expr.description.short=禁止有关将表达式用作语句的警告
jshint.option.funcscope.description.short=禁止有关在已声明块外部使用变量的警告
jshint.option.futurehostile.description.short=有关使用在以后的 JavaScript 版本中定义的标识符的警告
jshint.option.gcl.description.short=将 JSHint 设为与 Google Closure Compiler 兼容
jshint.option.globalstrict.description.short=禁止有关使用全局严格模式的警告
jshint.option.iterator.description.short=禁止有关 <code>__iterator__</code> 属性的警告
jshint.option.lastsemic.description.short=禁止有关缺少分号的警告，但仅当单行块中的最后一条语句省略分号时才显示该警告
jshint.option.laxbreak.description.short=禁止有关不安全换行的警告
jshint.option.laxcomma.description.short=禁止有关编码样式以逗号开头的警告
jshint.option.loopfunc.description.short=禁止有关函数在循环内部的警告
jshint.option.moz.description.short=检查代码是否使用 Mozilla JavaScript 扩展
jshint.option.multistr.description.short=禁止有关多行字符串的警告
jshint.option.notypeof.description.short=禁止有关无效 <code>typeof</code> 运算符值的警告
jshint.option.proto.description.short=禁止有关 <code>__proto__</code> 属性的警告
jshint.option.scripturl.description.short=禁止有关使用以脚本为目标的 URL 的警告
jshint.option.smarttabs.description.short=在空格仅用于对齐时，禁止有关将制表符和空格混合使用的警告
jshint.option.shadow.description.short=禁止有关变量隐藏的警告
jshint.option.singlegroups.description.short=如果未严格要求使用分组运算符，禁止使用该运算符
jshint.option.sub.description.short=如果可以使用点符号表示 <code>[]</code> 符号，则禁止有关使用后者的警告
jshint.option.supernew.description.short=禁止有关“怪异”构造的警告
jshint.option.validthis.description.short=禁止有关可能违反严格要求的警告
jshint.option.withstmt.description.short=禁止有关使用 with 语句的警告
jshint.option.noyield.description.short=禁止在生成器函数中无 yield 语句时有关生成器函数的警告
jshint.option.browser.description.short=浏览器
jshint.option.devel.description.short=开发
jshint.option.nonstandard.description.short=转义和未转义
jshint.option.typed.description.short=输入的数组
jshint.option.worker.description.short=Web 工作线程
jshint.option.wsh.description.short=Windows Script Host
jshint.option.module.description.short=ECMAScript 6 模块
jshint.option.nomen.description.short=不允许使用 _ in 变量
jshint.option.onevar.description.short=每个函数一个变量语句
jshint.option.passfail.description.short=出现第一个错误时停止
jshint.option.white.description.short=不允许使用杂乱的空格
jshint.option.maxerr.description.short=最大错误数
jshint.option.predef.description.short=预定义(以 , 分隔)

#common linters
javascript.linter.import.error.timeout.processing.configuration.file=处理配置文件时超时
javascript.linter.import.error.generic=应用配置文件中的代码样式规则时出错，可能是配置文件无效。
javascript.linter.import.error.package.not.found=无法找到 ''{0}'' 软件包
javascript.linter.import.error.entry.point.not.found=无法在 ''{0}'' 软件包中找到入口点
javascript.linter.import.error.bin.file.not.found=无法 ''{1}'' 软件包下找到 ''{0}''
javascript.linter.import.notification={0}：项目代码样式和编辑器设置基于 ''{1}'' 更新。
javascript.linter.import.notification.edit=编辑 ''{0}''
javascript.linter.import.notification.rules.applied=应用了以下 {0}：{1}。
javascript.linter.import.notification.reset=重置
javascript.linter.import.notification.restored=默认代码样式和编辑器设置已恢复
javascript.linter.import.translate.config.title=应用 ESLint 代码样式规则
javascript.linter.import.translate.config.description=应用 ESLint 代码样式规则
javascript.linter.import.translate.config.progress.title=应用 {0} 代码样式规则
javascript.linter.import.translate.config.file.error=无法应用代码样式规则
javascript.linter.import.nothing.to.import={0}：已应用所有已知规则
javascript.linter.use.severity.from.config.label=使用配置文件中的规则严重性
javascript.linter.configuration.file.title=配置文件
javascript.linter.radio.button.configuration.file=配置文件(&C):
javascript.linter.error.empty.path=路径为空
javascript.linter.error.no.such.file=没有此类文件
javascript.linter.error.specify.correct.path.to=指定 {0} 的正确路径
javascript.linter.error.failed.to.lint=Lint {0} 失败
javascript.linter.error.can.not.find.psi.file=无法找到 {0} 的 PSI 文件
javascript.linter.error.can.not.find.document=无法找到 {0} 的文档
javascript.linter.error.notification.problem.with.reformatting=重新设置 {0} 的格式时出现问题:<br/>{1}
javascript.linter.error.no.path.to.package=指定 ''{0}'' 软件包的路径
javascript.linter.error.package.not.installed=安装 ''{0}'' 软件包
javascript.linter.error.invalid.path.to.package=指定 ''{0}'' 软件包的正确路径
dialog.message.please.specify.stylelint.package.correctly=正确指定 Stylelint 软件包: 找不到 Stylelint 二进制文件
stylelint.action.fix.problems.description=通过调用 'stylelint --fix' 修正 Stylelint 问题
stylelint.action.modal.title=Stylelint 修正
stylelint.action.background.title=正在运行 stylelint --fix…

javascript.linter.action.edit.config=编辑 {0}
javascript.linter.action.edit.property=编辑 {1} 中的 {0}
javascript.linter.action.edit.settings.text={0}设置…
javascript.linter.action.fix.prompt=使用 {0} 重新格式化选定的文件?
javascript.linter.action.fix.problems.file.text={0}：修复当前文件
javascript.linter.action.fix.problems.name=修复 {0} 问题
javascript.linter.action.fix.problems.name.start=已开始修复 {0} 问题
javascript.linter.action.fix.problems.name.finish=已结束修复 {0} 问题
javascript.linter.configurable.config.autoSearch.title=自动搜索 (&S)
javascript.linter.suppress.rules.for.line.family.name=对当前行禁止
javascript.linter.suppress.rule.for.line.description=禁止当前行的 ''{0}''
javascript.linter.suppress.all.rules.for.line.description=禁止当前行的所有 {0} 规则
javascript.linter.suppress.rules.for.file.family.name=对当前文件禁止
javascript.linter.suppress.rule.for.file.description=禁止当前文件的 ''{0}''
javascript.linter.suppress.all.rules.for.file.description=禁止当前文件的所有 {0} 规则
javascript.linter.progress.reformatting.with=正在使用 {0} 重新格式化…

javascript.linter.intention.name.details=详细信息
javascript.linter.intention.family.name.show.details={0}: 显示详细信息

# eslint
settings.javascript.linters.eslint.configurable.name=ESLint
eslint.configurable.eslintPackage.label=ESLint 软件包(&E)：
eslint.configurable.config.autoSearch.description.bodyInnerHtml=ESLint 将在要 lint 的文件的目录中以及连续的父目录中查找 .eslintrc.* 和 package.json 文件，直至查找到文件系统的根目录。<div style="padding-top:8px">要使用 package.json，请将您的配置添加到 <code>eslintConfig</code> 属性下。</div>
eslint.configurable.label.working.directories=工作目录(&W):
eslint.configurable.working.dir.field.empty.text=由最近的 .eslintrc 或 .eslintignore 检出
eslint.configurable.working.directories.comment=<html>路径或 <a href='https://github.com/isaacs/node-glob#glob-primer'>glob 模式</a>，以分号分隔。为自动检测留空。</html>
eslint.configurable.config.select.config.text=选择 ESLint 配置文件（*.eslintrc.*）
eslint.configurable.additionalRulesDir.label=其他规则目录 (&R)：
eslint.configurable.additionalRulesDir.browseDialogTitle=选择 ESLint 其他规则目录
eslint.configurable.extraOptions.label=额外 eslint 选项 (&O)：
eslint.run.for.files.label=为文件运行(&F):
eslint.files.pattern.comment=<html>使用 <a href=''https://github.com/isaacs/node-glob#glob-primer''>glob 模式</a>，例如，<code>{**/*,*}.{js,ts}</code></html>
eslint.run.on.save=保存时运行 eslint --fix(&U)
eslint.action.fix.problems.description=通过调用 'eslint --fix' 修正 ESLint 问题
eslint.fix.problems.text.with.error.code={0}: 修复 ''{1}''
eslint.fix.problems.text.current={0}: 修复当前错误
eslint.fix.problems.family.name={0}: 修复当前错误
eslint.error.package.directory.expected=应为软件包目录
eslint.code.style.apply.message=应用 ESLint 的代码样式?
eslint.code.style.dismiss.text=否
eslint.code.style.apply.text=是
eslint.version.0.is.not.supported.please.upgrade.eslint=ESLint 版本 {0} 不受支持。请升级 ESLint。
eslint.additional.rules.directory.field.name=其他规则目录
eslint.configuration.file.field.name=ESLint 配置文件
eslint.inspections.error.can.not.parse.message=无法解析消息，应为 JSON 对象，但实际为: {0}
eslint.inspections.error.messages.not.array=消息不是数组: {0}
eslint.inspections.error.unexpected.language.service.response=意外的语言服务响应: {0}
eslint.inspections.error.unknown.message.severity=未知的消息严重程度: {0}\n主体:\n{1}

#standardJS
standardjs.name=标准代码样式
standardjs.editor.notification.can.be.enabled.text=为此项目使用 JavaScript 标准代码样式？
standardjs.editor.notification.action=是
standardjs.editor.notification.do.not.show.text=否
standardjs.edit.settings.caption=ESlint/标准代码样式
standardjs.action.fix.problems.description=修正标准代码样式问题
standardjs.error.unsupported.package=不支持的软件包版本。请将 ''Standard'' 软件包升级到最低版本 {0}。
standardjs.codestyle.updated={0}: 项目代码样式设置已更新
standardjs.codestyle.updated.config.section={0}: 项目代码样式设置已根据 package.json 中的 ''standard'' 部分更新
standardjs.codestyle.updated.dependency={0}: 项目代码样式设置已根据 package.json 中的 ''standard'' 依赖项更新

# Actions
js.show.type.info.action.error=找不到表达式
javascript.ignore.unused.function.parameters=忽略未使用的形参:
javascript.ignore.unused.catch.parameters=忽略未使用的 catch 参数
complete.import.binding=完整的导入绑定
complete.import.name=完整的导入名称
remove.type.prefix=移除类型前缀
add.import.binding.to.import=将导入绑定添加到导入
add.import.specifier.to.import=将导入说明符添加到导入
create.js.file.description=从指定的模板创建 JavaScript 文件
create.ts.file.description=创建新的 TypeScript 文件
create.file.name=创建文件 ''{0}''
create.file.name.with=使用 {1} 创建文件 ''{0}''
create.file.name.with.and=使用 {1} 和 {2} 创建文件 ''{0}''
class.names={0,choice,1#类|2#类} {1}
function.names={1}{0,choice,1#函数|2#函数} 

# todo remove, has external usages
javascript.completion.several.definitions=（多个定义）

# File watchers
js.file.watcher.6to5.description=使用 Babel 将 ECMAScript 6 代码转成 ECMAScript 5
editor.notification.label.enable.babel.file.watcher.question=是否启用 File Watcher 以使用 Babel 将 ECMAScript 6 转换为 ECMAScript 5?

# Annotator
typescript.export.assignment.cannot.be.used.in.internal.modules=导出不能在内部模块中使用的赋值
typescript.type.predicate.not.return=仅函数和方法的返回类型位置允许类型谓词
typescript.type.this.predicate.not.return=仅类或接口成员、get 访问器或函数和方法的返回类型位置允许基于 'this' 类型的谓词。
typescript.type.predicate.not.match.name=找不到参数 {0}
typescript.type.predicate.rest=类型谓词不能引用 rest 参数
typescript.type.predicate.destructuring=类型谓词不能引用绑定模式中的元素。
typescript.type.predicate.incompatible.types=类型谓词不可分配给 {0}
typescript.generics.should.not.be=类型 ''{0}'' 非泛型
es6.default.export.not.declared=未在导入的模块中声明默认导出
js.annotator.assignment.pattern.rhs=赋值模式必须位于赋值的左侧
es6.generate.index.action=生成 index.js/index.ts
es6.generate.index.action.description=生成 index.js/index.ts
js.annotator.thin.arrow.used=使用了细箭头
js.annotator.newline.before.arrow=箭头前不允许换行符
js.annotator.replace.with.fat.arrow=替换为粗箭头
js.annotator.unary.operator.within.exponential=一元运算符 ''{0}'' 不允许直接位于指数表达式之前。建议添加括号以解决歧义问题。

# Live templates
jsx.html.context.type=JSX HTML
js.expression.context.type=表达式
js.statement.context.type=语句
js.top.level.statement.context.type=顶级语句
js.class.context.type=类/接口
ecmascript.6.or.higher=ECMAScript 6 或更高版本

# Gulp
gulp.rc.gulpfile.label=Gulpfile (&F)：
gulp.rc.gulpfile.browseDialogTitle=选择 gulpfile.js
gulp.rc.tasks.label=任务(&T):
gulp.rc.arguments.label=参数 (&R)：
gulp.rc.nodeInterpreter.label=节点解释器(&I):
gulp.rc.nodeOptions.label=节点选项(&O):
gulp.rc.gulpPackage.label=Gulp 软件包(&G)：
gulp.rc.environmentVariables.label=环境(&E):
gulp.task.title=Gulp 任务
gulp.before.run.task=运行 gulp 任务
gulp.before.run.task.descr=运行 gulp {0, choice,0#任务|1#任务 |2#任务 }{1} [{2}]
gulp.gulpfile.unspecified=未指定 Gulpfile
gulp.gulpfile.not.found=未找到 Gulpfile

# Grunt
grunt.rc.gruntfile.label=Gruntfile (&F)：
grunt.rc.gruntfile.browseDialogTitle=选择 Gruntfile
grunt.rc.tasks.label=任务(&T):
grunt.rc.arguments.label=参数 (&R)：
grunt.rc.nodeInterpreter.label=节点解释器(&I):
grunt.rc.nodeOptions.label=节点选项(&O):
grunt.rc.gruntCliPackage.label=软件包 grunt-cli (&P)：
grunt.rc.environmentVariables.label=环境(&E):
grunt.task.title=Grunt 任务
grunt.before.run.task=运行 Grunt 任务
grunt.before.run.task.descr=运行 Grunt {0, choice,0#任务|1#任务 |2#任务 }{1} [{2}]
grunt.unspecified.gruntfile=未指定 Gruntfile
grunt.gruntfile.not.found=未找到 Gruntfile

#node
settings.nodejs.name=Node.js
settings.nodejs.coding.assistance.label=Node.js 编码协助 (&A)：
settings.nodejs.coding.assistance.manage.scopes.label=管理范围…

node.interpreter.label=Node 解释器(&I):
node.interpreter.unspecified.error.text=指定 Node.js 解释器
node.package.manager.label=软件包管理器 (&M)：
node.package.empty.hint={0} 软件包目录路径
node.package.empty.hint.pkg1.or.pkg2={0} 或 {1}
node.package.selector.single.package.title=选择 {0} 软件包目录
node.package.selector.multiple.packages.title=选择软件包目录
node.package.selector.multiple.packages.description=选择 {0}
node.package.none=无软件包
node.package.dropDownList.select=选择…

node.js.modules.dependencies.missing.family.name=缺少 require() 调用
inspection.NodeCoreCodingAssistanceInspection.no.coding.assistance.message=Node.js 的编码辅助已禁用
action.ToggleNodeCoreCodingAssistanceAction.toggle.coding.assistance.for.node.js.text=切换 Node.js 的编码辅助

# npm
npm.rc.packageJson.label=package.json (&P)：
npm.rc.packageJson.browseDialogTitle=选择 package.json 文件
npm.rc.command.label=命令(&C):
npm.rc.scripts.label=脚本 (&T)：
npm.rc.scriptsArguments.label=参数 (&R)：
npm.rc.nodeInterpreter.label=节点解释器(&I):
npm.rc.nodeOptions.label=节点选项 (&O)：
npm.rc.environmentVariables.label=环境:
npm.task.title=NPM 脚本
npm.before.run.task=运行 npm 脚本
npm.before.run.task.descr=运行 npm {0, choice,0#脚本|1#脚本|2#脚本}{1} [{2}]
npm.dialog.message.cannot.resolve.package.manager=无法解析 ''{0}'' 软件包管理器
npm.no.scripts.found=未找到脚本
dialog.message.unspecified.package=未指定 {0} 软件包
dialog.message.invalid.package.file.specified.but.directory.with.package.json.expected={0} 软件包无效: 指定了一个文件，但应为包含 package.json 的目录
dialog.message.invalid.package.no.such.directory=无效的 {0} 软件包: 无此类目录
dialog.message.invalid.npx.command=无效的 npx 命令
dialog.message.package.yarn.installed.package.format.yarn.relative.path.to.package.json.package.name={0}软件包: Yarn 安装的软件包格式为 ''yarn:[package.json 的相对路径]:[软件包名称]''。
dialog.message.no.path.to.package.json.found=未找到 package.json 的路径。
dialog.message.unspecified.package.name=未指定软件包名称。
dialog.message.invalid.package.no.such.file=无效的 {0} 软件包: 无此类文件
enable.notifications.about.installing.dependencies.from.package.json=启用有关从 package.json 安装依赖项的通知
notification.content.notifications.are.enabled.for.current.package.json=为当前 package.json 启用通知
notification.content.notifications.are.enabled.for.all.package.json.files=为所有 package.json 文件启用通知
dialog.message.please.specify.npm.or.yarn.package.cannot.find.inside.directory=请指定 npm 或 yarn 软件包: 在“{1}”中找不到“{0}”
dialog.message.please.correct.path.to.npm.or.yarn.package.no.such.directory=请更正 npm 或 yarn 软件包的路径: 无此类目录“{0}”

# Build tools
buildTools.JsbtRunTaskAction.text=运行 Gulp/Grunt/npm 任务
buildTools.JsbtAddBuildfileAction.text=添加 {0}
buildTools.choose_buildfile.text=选择 {0}
buildTools.JsbtRemoveBuildfileAction.text=移除 {0}
buildTools.JsbtReloadTasksAction.text=重新加载任务
buildTools.JsbtReloadTasksAction.npm.text=重新加载脚本
buildTools.JsbtShowTasksAction.text=显示 {0} 任务
buildTools.JsbtShowTasksAction.npm.text=显示 npm 脚本
buildTools.searchEverywhere.text=运行 ''{0}'' 任务
buildTools.searchEverywhere.npm.text=运行 ''{0}'' npm 脚本
buildTools.ShowSettingsAction.text={0}设置…
buildTools.ShowSettingsAction.npm.text=编辑 npm 配置(&E)…
buildTools.EditRunSettingsAction.text=编辑 ''{0}'' 设置(&E)…
buildTools.tree.sortBy.text=排序方式
buildTools.tree.sortBy.definitionOrder.text=定义顺序
buildTools.tree.sortBy.name.text=名称
buildTools.no.tasks.found=未找到任务
buildTools.edit.run.configuration=编辑运行配置
buildTools.no.files.added=未添加文件
buildTools.add.with=使用 {1} 添加 {0}
buildTools.no.such.file=没有此类文件
buildTools.failed.to.list.tasks=无法列出任务
buildTools.failed.to.list.tasks.details.reference=详细信息
buildTools.tooltip.click.to.show.error.details=点击以显示错误详细信息

#npm modules
npm.modules.inspection.content.of.require.not.in.dependencies.warning=package.json 依赖关系中未列出模块
npm.modules.inspection.content.of.require.module.not.installed.warning=未安装模块
npm.modules.install.global.types.fix.name=安装 TypeScript 定义以提供更好的类型信息
package.json.install.types.fix.family.name=为软件包安装 @types
node.js.quickfix.install.node.module.with.dev.dependencies.text=安装 ''{0}'' 作为开发依赖关系
node.js.quickfix.install.node.module.text=安装 ‘’{0}''
node.js.quickfix.install.node.module.family.name=安装模块
node.js.quickfix.install.node.module.devDependencies.family.name=安装模块作为开发依赖关系
node.js.quickfix.install.node.module.update.modules.family.name=运行 'npm install'
node.js.quickfix.run.command=运行 ''{0}''
node.js.quickfix.install.node.module.error.prefix.text=无法安装 Node.js 模块：{0}
node.js.quickfix.install.node.module.error.no.interpreter.text=无法安装 Node.js 模块：请指定默认 Node.js 解释器。
node.js.quickfix.install.node.module.error.no.interpreter.title=安装 Node.js 模块
node.js.select.file=选择 {0} 文件
dialog.message.cannot.determine.package.json.directory=无法确定 package.json 目录
action.InstallNodeLocalDependencies.text=安装 Node.js 依赖项
action.InstallNodeLocalDependencies$Root.text=为 {1} 运行 ''{0}''

typescript.types.module.not.installed.warning=无法解析模块 ''{0}'' 的定义
npm.modules.install.global.types.directory.error=无法创建所需的目录
npm.modules.install.global.types.dialog.title=安装 TypeScript 定义

typescript.types.union=联合
typescript.types.intersection=相交
typescript.types.mapped=映射
typescript.types.key=键引用
typescript.types.merged=已合并
typescript.types.merged.accessor=合并访问器
typescript.types.type.member={0} 类型属性
typescript.types.merged.parts=引用的属性：

# Intentions
ts.generate.reference.path.name=生成引用路径注释
ts.add.import.statement.family.name=添加 import 语句
ts.add.import.statement.dialog.title=添加 import 语句
ts.add.import.all.family.name=添加所有明确的导入
ts.add.import.hint.text=使用 {1} 添加 {0}
ts.add.import.hint.multiple.text=使用  {1} 为 {0} 添加导入
ts.add.import.hint.all.part=或全部使用 {0} 导入
ts.change.import.action.one.title=更改为 {0}
ts.change.import.action.many.title=更改导入…
ts.change.import.action.command=更改导入
ts.change.import.action.family.name=更改 ES6 导入路径
ts.change.import.action.dialog.title=导入自…
ts.convert.alias.to.interface.action.title=将别名转换为接口
ts.convert.alias.to.interface.action.family.name=将类型别名转换为接口
ts.convert.alias.to.enum.action.title=将别名转换为枚举
ts.convert.alias.to.enum.action.family.name=将类型别名转换为枚举
ts.convert.parameter.property.to.field=将形参属性转换为字段
ts.convert.field.to.parameter.property=将字段转换为参数属性
anonymous.to.named.intention.function.name=函数名称：
initialize.fields.intention.visibility=可见性:
command.name.import=导入 {0}
please.specify.package.manager=指定<a href="">软件包管理器</a>。
intention.name.add.file.to.tsconfig=将文件 ''{0}'' 添加到 tsconfig.json
intention.name.import.augmentation=导入增强 {0}

# Language Service
javascript.language.service.default.empty.text=无错误
javascript.language.service.tracking.disabled=错误跟踪已禁用
javascript.language.service.tracking.is.not.started=服务未启动
javascript.language.service.default.project.errors=显示项目错误
javascript.service.node.error=节点解释器路径不正确。请检查解释器设置
javascript.starting.service=启动 {0} 服务
javascript.language.service.cannot.get.results=无法从语言服务获得结果
javascript.language.service.start.timeout=启动语言服务进程超时
javascript.language.service.cannot.start=无法启动语言服务进程
cannot.parse.service.initialization.answer.0=无法解析服务初始化回复 {0}\n
tab.title.errors=错误
tab.title.project.errors=项目错误
tab.title.compile.errors=编译错误
dialog.message.no.results.for.after={1} 之后没有 {0} 的结果
intention.name.loading.service.fixes=正在加载服务修正…

# TypeScript Compiler
typescript.compiler.notification.editor.configure=配置 TypeScript…
typescript.compiler.configurable.name=TypeScript
typescript.use.service.configurable.options.enable=TypeScript 语言服务
typescript.compiler.configurable.options.output.path=使用输出路径：
typescript.compiler.configurable.options.compile.main=仅编译主文件：
typescript.compiler.configurable.options.compile.main.error=主文件的路径不正确
typescript.compiler.configurable.options.version=TypeScript:
typescript.compiler.configurable.options.generate.source.map=生成源映射
typescript.compiler.configurable.options.enable.no.config=也针对没有 tsconfig.json 的项目
typescript.compiler.configurable.options.track.file.system=在更改时重新编译
typescript.compiler.configurable.options.scope=编译范围：
typescript.compiler.configurable.options.command.line=选项:
dialog.message.cannot.compile.typescript.config.file.incorrect=无法编译 TypeScript。配置文件不正确。
intention.family.name.suppress.with.ts.ignore=使用 @ts-ignore 禁止
typescript.compiler.structure.tab.title=结构
typescript.compiler.starting=TypeScript 正在启动…

typescript.service.no.config=文件未包括在任何 tsconfig.json 中
typescript.service.no.main.reference=文件未处理，因为没有从主文件引用


js.tool.window.limit=显示前 {0} 个错误。
js.tool.window.limit.all=查看所有 {0} 个错误
typescript.compiler.action.compile.all=全部编译
typescript.compiler.action.compile.toolbar=编译
typescript.compiler.action.compile.all.description=编译所有项目文件
typescript.service.action.restart=重启{0}
typescript.compiler.action.compile.all.compile.config=配置 {0} 的编译文件
typescript.compiler.action.compile.current=编译当前文件
typescript.compiler.action.compile.simple=编译 TypeScript
typescript.compiler.action.compile.description=编译当前项目
typescript.compiler.action.no.compile.message=文件未编译，因为没有从主文件引用
typescript.compiler.before.run=编译 TypeScript

typescript.language.service.clean=正在重置缓存…
typescript.language.service.compile.file=正在编译文件... {0}
typescript.language.service.compile.project=正在编译项目… {0}
typescript.language.service.compile.file.errors=正在计算错误... {0}
typescript.language.service.compile.project.errors=正在计算项目错误... {0}
typescript.language.service.compile.project.open.file=正在打开文件... {0}

typescript.before.task.check.errors=检查错误
typescript.before.task.config.path=配置文件：
typescript.before.task.title=TypeScript 编译设置
typescript.before.task.config.dialog.title=选择 tsconfig.json

# Documentation
js.documentation.fires=触发：
js.documentation.more.overload=其他 {0} 个重载
js.documentation.more.overloads=其他 {0} 个重载

node.js.remote.interpreters.plugin.missing=缺少 Node.js 远程解释器插件。请启用 {0} 中的插件

# Module Dependencies
javascript.module.dependencies.got.it.title=模块依赖关系图
javascript.module.dependencies.got.it.text=<div align='left'>此图显示所选文件或目录具有的模块依赖关系。<br/>要查看多个文件或目录的依赖关系，请在<i>项目视图</i><br/>中将其选定，然后从所选项目上下文菜单中选择<i>图 – 显示图</i>。</div>
javascript.module.dependencies.empty.got.it.text=<div align='left'>当前文件或文件夹没有任何依赖关系。<br/>请尝试使用其他文件或文件夹。</div>
modules.selected=选定

js.remove.redundant.initializer.fix=移除冗余的初始值设定项
js.remove.unused.assignment=移除未使用的赋值
js.inject.with.comment.intention.family.name=使用注释对注射做出注解
js.inject.dont.format.intention.text=禁用注入内容的格式设置

js.webpack.config.highlighting.name=Webpack 配置符合 JSON 架构

js.linter.guesser.linter.enabled.because.of.dependency=已启用 {0}：''{1}'' 列出在 package.json 中。
js.linter.guesser.linter.enabled.because.of.package.json.section=已启用 {0}：''{1}'' 位于 package.json 中。
js.linter.guesser.linter.enabled.because.of.config.file=已启用 {0}：配置文件位于项目中。
js.linter.guesser.linter.disabled={0} 已禁用。

# Breadcrumbs
js.breadcrumbs.callback.for=\ {0}() 回调

typescript.extract.type.alias.name=类型别名…
typescript.include.js.sources.element=搜索 JavaScript 声明
typescript.include.js.sources.dialog.title=包括软件包 {0}
typescript.include.js.sources.dialog.message=是否在此项目中包含 ''{0}'' 中的 JavaScript 文件?
start.template.string.interpolation.on.typing=键入 '$' 时启动模板字符串插值
typescript.include.js.sources.action=包括 JavaScript 文件
escape.pasted.text=在粘贴字符串文字时转义文本
jsx.convert.html.attributes.to.jsx=将 HTML 粘贴到 JSX 文件时转换特性

# Rename member
rename.prompt.do.you.want.to.rename.base.method=要重命名基方法吗?
js.rename.base.member=重命名基{0}
js.rename.current.member=重命名当前 {0}
js.rename.member.title={0} {1} {3} 的 {2}
js.rename.member.title.implements=实现
js.rename.member.title.overrides=重写

# Generate dialog
generate.filter.indexers=索引器
generate.filter.methods=方法
generate.filter.fields=字段和属性
generate.filter.button.tooltip=显示 {0}
generate.filter.button.description=在列表中显示 {0} 
codestyle.ui.field.prefix=字段前缀 (&F)：
codestyle.ui.property.prefix=属性前缀 (&P)：
codestyle.ui.file.name.style=文件命名惯例 (&N)：
codestyle.ui.generated.jsdoc.use.types.checkbox=在 JSDoc 中包括类型 (&T)
inline.type.used.in.reference.list=无法在''{0}'' 列表中内联用法
inline.cannot.inline.references.this.type=无法内联引用 'this' 类型的接口
inline.cannot.inline.has.supers=无法内联扩展其他类型的 {0} 
generation.bindable.event=可绑定事件(&B):
generation.event.constant=事件常量(&E):

refactoring.extract.react.component.component.for.refactor.this=提取组件…
refactoring.extract.react.component.title=提取组件
refactoring.extract.react.component.no.expression=所选内容不构成 JSX 表达式
refactoring.extract.react.component.no.scope=找不到用于放置所创建组件的范围
refactoring.create.react.component.title=创建组件
refactoring.react.function.to.class.refactoring.title=转换为类组件
refactoring.react.function.to.class.intention.title=转换为类组件
refactoring.react.function.to.class.used.in.new.conflict=\ ''new'' 表达式中使用了 {0}
refactoring.react.function.to.class.used.in.call.conflict=调用表达式中使用了 {0}
refactoring.react.class.to.function.conflict.used.with.ref={0} 与 ''ref'' 特性结合使用。无法为无状态函数组件提供 ref
refactoring.react.class.to.function.refactoring.title=转换为函数组件
refactoring.react.class.to.function.intention.title=转换为函数组件
refactoring.react.could.not.find.in.template=无法重构。找不到名称为 {0} 的元素。可能的代码模板 {1} 无效吗？
react.function.to.class.caret.at.function=文本光标应置于要转换的函数处
react.class.to.function.caret.at.class=文本光标应置于要转换的类处
react.class.component.type.class=类
react.class.component.type.function=函数

js.arrangement.group.arrow.fields.with.methods=使用包含方法的箭头函数初始化组字段
intellilang.tagged.literal.injection.name.label=模式:
intellilang.tagged.literal.expression.border.title=模板标签

refactoring.destructuring.vars.for.refactor.this=对象或数组析构…
refactoring.destructuring.vars.intention.name=引入对象或数组析构
refactoring.destructuring.vars.intention.name.object=引入对象析构
refactoring.destructuring.vars.intention.name.array=引入数组析构
refactoring.destructuring.vars.intention.replace.object=替换为对象析构
refactoring.destructuring.vars.intention.replace.array=替换为数组析构
refactoring.destructuring.vars.intention.replace.promise=替换为 'await Promise.all'
refactoring.destructuring.vars.intention.propagate=传播到析构声明
refactoring.destructuring.vars.intention.depropagate=将析构替换为属性和索引访问
refactoring.destructuring.vars.intention.deconstruct=生成析构模式
refactoring.destructuring.vars.intention.replace.shorthand=替换为析构和速记属性
refactoring.destructuring.vars.intention.const.to.var.warning=在转换期间，高亮显示的 const 变量将转换为 let 变量。\n要继续吗？
refactoring.destructuring.vars.intention.const.to.var.warning.title=变量关键字更改
refactoring.destructuring.vars.intention.guard.conflict=通过类型防护将表达式类型缩小为 ''{0}''，该类型防护在重构后将不起作用
javascript.intention.add.export.family.name=添加导出
javascript.intention.add.export.fix.text=将 {0} 导出在文件 {1} 中
javascript.intention.add.default.export.family.name=添加默认导出
javascript.intention.remove.export.family.name=移除导出
javascript.intention.remove.export.inaccessible.conflict.text={0} 在 {1} 中进行了使用
javascript.intention.promise.to.async.name=转换为异步功能
javascript.intention.code.optimizations.text=正在优化生成的代码
javascript.intention.add.template.argument=插入模板字符串实参
javascript.intention.call.chain.to.pipe=将嵌套调用替换为管道表达式
javascript.intention.pipe.to.call.chain=将管道表达式替换为嵌套调用
javascript.intention.opt.chain.family=使用可选链接或空值合并
javascript.intention.opt.chain.chain.only=使用可选链接
javascript.intention.opt.chain.coalesce.only=使用空值合并
javascript.intention.opt.chain.conditional.only=使用 '||'
javascript.intention.opt.chain.chain.and.coalesce=使用可选链接和空值合并
javascript.intention.expand.opt.chain.family=将可选链接或空值合并扩展到显式检查
javascript.intention.expand.opt.chain=展开可选链接
javascript.intention.expand.nullish.coalescing=展开空值合并
javascript.intention.expand.or.coalescing=使用 ?: 运算符
javascript.intention.expand.opt.chain.and.nullish.coalescing=展开可选链接和空值合并
javascript.intention.expand.opt.chain.and.or.coalescing=展开可选链接并使用 ?: 运算符
javascript.intention.explicit.fields=声明显式类字段
javascript.intention.explicit.fields.single=声明显式类字段
javascript.intention.explicit.fields.dialog.title=选择要显式声明的字段
javascript.intention.init.fields=从参数初始化新字段
javascript.intention.init.fields.dialog.title=选择参数以初始化字段

js.param.hints.show.names.for.all.args=对于非文字实参
js.param.hints.show.names.for.tagged=对于标记的模板实参
js.param.hints.show.names.for.pipes=对于管道运算符
js.param.hints.blacklist.pattern.explanation=<html>要禁用方法或函数提示，请使用下面的其中一种模式: <p style="margin-left: 5px"><code><b>(*info)</b></code> - 所有形参名称以 <em>info</em> 结尾的单形参方法<br><code><b>(key, value)</b></code> - 所有包含形参<em>键</em>和<em>值</em>的方法<br><code><b>*.put(key, value)</b></code>- 所有包含<em>键</em>和<em>值</em>形参的 <em>put</em> 方法<br><code><b>Console.log(*, *)</b></code> - 正好包含两个形参的 <em>Console</em> 类型的 <em>log</em> 方法</p><br><p>必须为所有形参(包括可选形参)提供名称或占位符。<br>限定方法名称必须包含类或接口名称或占位符。<br>在编辑代码时，请使用“不为当前方法显示提示”{0} 操作来添加模式。</p></html>

js.checkbox.make.readonly=设为只读(&R)

action.JavaScriptGenerateDictionaries.text=生成 JavaScript 拼写检查器字典
action.ReactClassToFunctionComponentAction.description=转换为函数组件
action.ReactFunctionToClassComponentAction.description=转换为类组件
action.ReactExtractComponentAction.description=提取组件
action.EslintImportCodeStyle.description=应用 ESLint 代码样式
action.TypeScriptExtractTypeAlias.description=提取类型别名
action.JS.TypeScript.Include.Generated.Declarations.text=包括 '.d.ts' 子文件
action.JS.TypeScript.Include.Generated.Declarations.description=在项目中包含 .d.ts 子文件
action.Generate.GetSetAccessor.JavaScript.text=Getter 和 Setter
action.Generate.SetAccessor.JavaScript.text=Setter
action.Generate.GetAccessor.JavaScript.text=Getter
action.Generate.Constructor.JavaScript.text=构造函数
action.Generate.Missing.Members.ES6.text=实现方法…
action.Generate.Missing.Members.TypeScript.text=实现成员…
group.Editor.JSLibrariesMenu.LibraryList.text=使用库
group.Editor.JSLibrariesMenu.LibraryList.description=设置使用的 JS 库
group.Editor.JSLibrariesMenu.text=使用 JavaScript 库
group.Editor.JSLibrariesMenu.description=选择要与当前文件一起使用的 JavaScript 库
configurable.JSTemplateLangConfigurable.display.name=模板
configurable.JSCodeCompletionConfigurable.display.name=JavaScript
configurable.JSSmartKeysConfigurable.display.name=JavaScript
configurable.MyConfigurable.display.name=JSX
import.options.find.more.configuration.options=从中查找更多配置选项 
import.options.find.more.configuration.options.code.style=代码样式
settings.code.style.indent.chained.methods=缩进链式方法
settings.code.style.indent.all.chained.calls.in.a.group=缩进组中的所有链式调用
settings.code.style.semicolon.to.terminate.statements=分号终止语句(&S)
settings.code.style.use=使用
settings.code.style.quotes=引号(&Q)
settings.code.style.Trailing.comma=尾随逗号(&T):
settings.code.style.single=单
settings.code.style.double=双
settings.code.style.in.new.code=(在新代码中)
settings.code.style.always=始终
settings.code.style.option.use=使用
settings.code.style.dont.use=不使用
checkbox.enable=启用
webpack.configuration.title=Webpack
webpack.configuration.detect.description=检测适合模块解析的 webpack 配置文件:
webpack.configuration.manual=手动
webpack.configuration.automatic=自动
webpack.configuration.disabled=已禁用
webpack.configuration.automatic.how.it.works=运作方式
webpack.configuration.automatic.hint={0} 将使用当前文件所在文件夹或其任意父文件夹中的 webpack 配置文件内的模块解析规则。
webpack.configuration.field=配置文件:
webpack.configuration.field.required.error=手动模式下需要配置文件路径
create.react.app.name=React
create.react.app.description=<a href="https://github.com/facebookincubator/create-react-app">创建 React 应用</a>是官方支持的一种创建单页 React 应用程序的新方法。它提供了没有配置的现代构建设置。
create.react.app.scripts.version=脚本版本 (&V)
create.react.app.typescript.checkbox=创建 TypeScript 项目 (&T)
dialog.title.new.javascript.file=新建 JavaScript 文件
list.item.javascript.file=JavaScript 文件
dialog.title.new.typescript.file=新建 TypeScript 文件
list.item.typescript.file=TypeScript 文件
list.item.typescript.jsx.file=TypeScript JSX 文件
dialog.kind.0.file={0} 文件
action.creates.new.file.description=创建新的 {0} 文件
build.event.title.failed.to.list.tasks=无法列出 {0} 任务
action.show.error.details.text=显示错误详细信息
dialog.title.grunt.settings=Grunt 设置
dialog.title.gulp.settings=Gulp 设置
dialog.title.error.details=错误详细信息
dialog.message.failed.to.download.0.1=下载 {0} 失败。{1}
dialog.title.download.error=下载错误
label.import.popup=自动导入工具提示:
label.namespace=命名空间:
dialog.message.cannot.infer.type.new.parameter=无法推断新参数的类型
dialog.title.cannot.introduce.new.interface=无法引入新接口
notification.title.coloring.types.narrowed.by.type.guard.was.disabled=按类型防护缩小类型着色被禁用
notification.content.html.href.settings.show.inspection.settings.or.href.undo.undo.html=<html><a href='settings'>显示检查设置</a>或<a href='undo'>撤消</a></html>
dialog.message.cannot.propagate.variable=无法传播变量: {0}
dialog.title.cannot.propagate=无法传播
dialog.message.usages.search.was.interrupted=用法搜索被中断
dialog.title.cannot.convert=无法转换
dialog.message.cannot.proceed.when.having.non.read.usages.in.embedded.expressions=嵌入式表达式中有非读取用法时，无法继续
dialog.message.variables.from.destructuring.pattern.have.no.usages=来自于析构模式的变量没有用法
button.continue=继续
button.abort=中止
action.don.t.use.library.description=不使用库
action.already.set.for.containing.folder.or.project.description=已针对包含的文件夹或项目进行设置。
action.use.library.description=使用库
text.cannot.download=无法下载 {0}。{1}
notification.content.show.details=显示详细信息
action.name.disable.category=禁用 {0}
progress.text.processing=正在处理 {0}{1}
label.path=路径(&P):
border.title.inspection.export.results.capitalized.location=位置
border.title.inspection.description.title=描述:
progress.title.install.npm.module=安装 npm 模块 ''{0}''
dialog.message.cannot.find.module.types=找不到模块 @types/{0}
action.jump.to.text=跳转到…
dialog.title.select.navigation.target=选择导航目标
dialog.title.select.targets.to.convert.to.class=选择要转换为类的目标
dialog.message.component.name=组件名称:
label.name=名称: 
label.type=类型: 
label.minimum.language.level=最低语言级别:
dialog.message.cannot.create.argument.stubs.invoked.method.function=无法创建实参存根: 调用的方法不是函数
action.show.structure.text=显示结构
status.text.no.errors.in.current.file=当前文件中没有错误。
status.text.javascript.language.service.default.project.errors=显示项目错误
progress.title.compiling.typescript.files=正在编译 TypeScript 文件
dialog.message.cannot.find.file=找不到文件 {0}
radio.set.options.manually=手动设置选项
radio.use.tsconfig.json=使用 tsconfig.json
separator.deprecated.settings=弃用的设置
dialog.title.main.file=主文件
label.choose.main.file=选择主文件
dialog.title.output.directory=输出目录
label.choose.output.directory=选择输出目录
dialog.message.incorrect.path.to.typescript.package=typescript 软件包的路径不正确
status.text.project.structure.isn.t.available=项目结构不可用
status.text.service.doesn.t.contain.open.projects=服务不包含开放项目
status.text.refresh.required=需要刷新
dialog.message.cannot.find.module.for.import=无法构建用于导入的模块路径
action.js.tagged.literal.injection.text=JS 标记文字注入
dialog.title.wsl.node.interpreter={0} WSL Node 解释器
dialog.title.wsl.node.interpreter.edit=编辑
dialog.title.wsl.node.interpreter.edit.add=添加
label.wsl.node.interpreter=WSL Node.js 解释器(&N):
dialog.message.please.select.distribution=请选择分发版
dialog.message.please.specify.wsl.path.to.node.js.interpreter=请指定 WSL 中安装的 Node.js 解释器的路径
status.text.running.which.node=正在运行 `which node`…
progress.title.configuring.node.js.coding.assistance=正在配置 Node.js 编码辅助…
action.PackageJsonNewFile.text={0}文件
action.PackageJsonNewFile.description=创建 {0} 文件
progress.title.install=安装 {0}
progress.subtitle.install=正在通过 {1} 安装 {0}…
inspection.message.package.installed=未安装 {0} 软件包
inspection.message.package.version.specified=未指定软件包版本
inspection.message.installed.version.doesn.t.match.version.range=安装的版本 {0} 与版本范围 {1} 不匹配
dialog.title.missing.dependencies=缺少依赖项
button.install.update=安装/更新
action.view.install.text=查看并安装…
action.don.t.ask.again.text=不再询问
dialog.title.configure.coding.assistance.for.node.js.api=配置 Node.js API 编码辅助
action.Anonymous.text.configure=配置
inspection.message.sm.test.runner.magnitude.assertion.failed.title=断言失败
text.html.front.end.template.a.href.http.html5boilerplate.com=<html>前端模板<a href='http://html5boilerplate.com'>http://html5boilerplate.com</a></html>
dialog.message.node.interpreter.unspecified.error.text=请指定 Node.js 解释器
text.html.sleek.intuitive.and.powerful.front.end.framework=<html>整洁、直观、强大的前端框架，更快、更轻松地进行 Web 开发 <a href='http://getbootstrap.com'>http://getbootstrap.com</a></html>
popup.title.target.function=目标函数
popup.title.select.destructuring.assignment.target=选择析构赋值目标
visibility.level.overview=概览
visibility.level.details=详细信息
js.module.uml.presentable.name=JavaScript 模块依赖项
intention.family.name.run.npm.install=运行 'npm install'
intention.name.run.npm=运行 ''{0}''
intention.family.name.navigate.to.package.json=导航到 package.json
intention.name.navigate.to.0.package.json=导航到 {0}/package.json
popup.advertisement.start.typing.package.name=开始输入软件包名称，以从 npm 官方公共注册表中获取更具体的结果
popup.advertisement.latest.available.versions.for.all.distribution.tags=所有发行版标签的最新可用版本
intention.family.name.select.in.test.tree=在测试树中选择
intention.family.name.introduce.parameter.properties.for.unused.parameters=转换为形参属性
dialog.title.select.parameters.to.convert.to.parameter.properties=选择要转换为参数-属性的参数
intention.family.name.add.required.property=添加所需的属性
intention.name.create.library.with.files.outside.project=使用项目外部的文件创建库
dialog.message.unspecified.suite.name=未指定的套件名称
dialog.message.unspecified.test.name=未指定的测试名称
dialog.message.unspecified=未指定的 {0}
dialog.message.no.such=没有此类{0}
dialog.message.please.specify.package.json=请指定 package.json
dialog.message.please.specify.package.json.correctly=请正确指定 package.json
dialog.message.please.specify.npm.scripts.to.run=请指定要运行的 npm 脚本
dialog.message.command.supported.by={1} 不支持命令 ''{0}''
dialog.message.no.npm.script=无 ''{0}'' npm 脚本
titled.separator.predefined=预定义
label.compiles.js.files=编译 .js 文件
label.compress.js.files=压缩 .js 文件
dialog.title.edit.run.debug.configuration=编辑运行/调试配置: ''{0}''
js.commandline.configure.language.version=为项目配置 JavaScript 语言版本
js.commandline.configure.nodejs=配置 NodeJS 解释器并为 package.json 文件安装软件包

# Language features
js.language.feature.xml.tags=XML 标记
js.language.feature.for.each.statements=针对每条语句
js.language.feature.for.of.loops=for..of 循环
js.language.feature.let.definitions=Let 定义
js.language.feature.const.definitions=Const 定义
js.language.feature.generators=生成器
js.language.feature.destructuring.assignments=析构赋值
js.language.feature.let.statements=Let 语句
js.language.feature.array.comprehensions=数组推导式
js.language.feature.top.level.yield.expressions=顶层 yield 表达式
js.language.feature.reference.namespace=引用命名空间
js.language.feature.default.parameter.values=默认形参值
js.language.feature.pipe.expressions=管道表达式
js.language.feature.decorator.declarations=装饰器声明
js.language.feature.throw.expressions=抛出表达式
js.language.feature.ecmascript.syntax.for.private.members=私有成员的 ECMAScript #- 语法
js.language.feature.class.member.visibility.modifiers=类成员可见性修饰符
js.language.feature.optional.chaining.operator=可选链接运算符
js.language.feature.arbitrary.precision.integers=任意精度整数
js.language.feature.trailing.commas.in.function.parameter.lists.and.calls=函数形参列表和调用中的尾随逗号
js.language.feature.unicode.escapes.with.braces=使用大括号的 Unicode 转义
js.language.feature.bind.expressions=绑定表达式
js.language.feature.optional.catch.bindings=可选 catch 绑定
js.language.feature.string.templates=字符串模板
js.language.feature.method.definition.shorthands=方法定义速记形式
js.language.feature.computed.property.names=计算的属性名称
js.language.feature.shorthand.property.names=速记属性名称
js.language.feature.binary.0b.and.new.octal.0o.literals=二进制(0b)和新的八进制(0o)文字
js.language.feature.async.await=async/await
js.language.feature.types=类型
js.language.feature.annotations=注解
js.language.feature.interfaces=接口
js.language.feature.classes=类
js.language.feature.es6.export.declarations=ES6 导出声明
js.language.feature.es6.import.declarations=ES6 导入声明
js.language.feature.generics=泛型
js.language.feature.rest.parameters=rest 参数
js.language.feature.arrow.functions=箭头函数
js.language.feature.getters.and.setters=getter 和 setter
js.language.feature.generator.expressions=生成器表达式
js.language.feature.expression.closures=表达式结束
js.language.feature.destructuring.parameters=析构形参

# Webpack
webpack.failed.to.load=无法加载 {0}
webpack.analyzing.configs.progress=正在分析 Webpack 配置
webpack.cannot.analyze=无法分析 {0}: 编码辅助将忽略此文件中的模块解析规则。\n可能的原因: 此文件不是有效的 webpack 配置文件，或者 IDE 目前不支持其格式。
file.name.masks.to.skip.from.analysis=要在分析中跳过的文件名掩码:
webpack.trusted.project.title=是否运行 Webpack 配置?
webpack.trusted.project.message=运行 Webpack 配置可以改善编码辅助，但可能会执行潜在的恶意代码。如果不信任此源，请跳过运行。
webpack.trusted.project.message.allow=信任项目并运行
webpack.trusted.project.message.skip=跳过

# Node
node.core.enable_coding_assistance_intention.name=启用 Node.js 的编码辅助
node.interpreter.unresolved_reference.error.message=未解析的解释器 ''{0}''
node.interpreter.invalid_interpreter.error.message=无效 ''{0}''
node.interpreter.no_local_interpreter.error.message=没有本地 Node.js 解释器
node.debug.cannot_connect_to_vm.error.message=无法连接到虚拟机 {0}
node.debug.cannot_get_localhost_IPv4.error.message=无法获取 127.0.0.1 IPv4
node.core.make.sure.javascript.debugger.plugin.enabled.dialog.message=确保已启用 'JavaScript Debugger' 插件
node.core.failed_to_fetch_node_core_modules.dialog.message=无法提取 Node 核心模块
node.core.core_modules_fetch_timed_out.dialog.message=无法提取核心模块: 已超时
node.core.not_ready_for_core_modules_configuration.dialog.message=未准备好进行核心模块配置
node.core.navigate_action_text.text=配置 Node.js…
node.core.failed_to_install.title.message=无法安装 {0}
node.interpreter.field.add.item.text=添加…
node.interpreter.field.unexpected_value.text=意外值 {0}
node.interpreter.unspecified_interpreter.dialog.message=指定 Node.js 解释器
node.interpreter.unspecified_local_interpreter.dialog.message=指定本地 Node.js 解释器
node.interpreter.specified_interpreter_correctly.dialog.message=正确指定 Node.js 解释器
configure.node.interpreter.path=配置 Node.js 路径…
node.interpreter.reference_not_found.text=未找到
node.interpreter.command_timed_out.dialog.message=''{0}'' 命令运行超时(>{1} ms)
node.package_documentation.installed_version.text=已安装版本: {0}
node.package_documentation.latest_version.text=最新版本: {0}
node.packages.cannot_find_working_directory.text=无法确定 {0} 的工作目录: {1}
node.package.field.not_found.text=未找到
node.npm.cannot_find_package_by_reference.dialog.message=找不到软件包管理器 ''{0}''
node.npm.specify_npm_or_yarn_package.dialog.message=指定 npm 或 yarn 软件包
node.npm.correct_path_to_npm_or_yarn_package.dialog.message=指定 npm 或 yarn 软件包的正确路径: 无此类目录 "{0}"
node.npm.invalid_package_manager.binary_file_not_found.dialog.message=指定有效的软件包管理器: 在 ''{0}'' 目录内部找不到二进制文件
node.npm.project_package_manager_disallowed_here.dialog.message=无法在此处引用项目 npm 软件包
node.npm.unspecified_package_manager.dialog.message=未指定软件包管理器
node.npm.cannot_resolve_package_manager.dialog.message=无法解析 ''{0}'' 软件包管理器
node.npm.no_bundled_npm_detected.dialog.message=未检测到 {0} 的捆绑 npm
package_json.install_dependencies.notification.title=安装依赖项
package_json.install_dependencies_multiple.notification.content=来自 {0} 和其他 {1} 个
package_json.install_dependencies.notification.content=来自 {0}
package_json.update_dependencies.notification.title=更新依赖项
package_json.notifications_are_disabled.notification.content=已禁用从 {0} 安装依赖项的通知。<p>使用 "{1}" 操作重新启用通知。
node.wsl.unavailable.dialog.message=WSL 不可用
node.wsl.unavailable_distribution.dialog.message=WSL {0} 不可用
node.npm.cannot_find_project_package_manager.dialog.message=找不到项目 Node.js 软件包管理器
node.npm.package_manager_link.text=软件包管理器
yarn.package_requires_yarn.dialog.message=软件包 "{0}" 要求 Yarn {1}。

# Jest
jest.package.placeholder.text=软件包目录的路径，可选择 jest、react-scripts 或 react-scripts 替代项
jest.snapshot.label=Jest 快照
filetype.jest.snapshot.description=Jest 快照
filetype.jest.snapshot.display.name=Jest 快照
jest.go.to.snapshot.text=转到 ''{0}'' 快照
jest.cannot.find.bin.file.for.package.dialog.message=找不到 ''{0}'' 软件包的 bin 文件

# Protractor
dialog.message.cannot.locate.wrapper.config.file=找不到包装器配置文件

# Style guides
list.item.google.javascript.style.guide=Google JavaScript 样式指南
list.item.javascript.standard.style=JavaScript 标准样式

# Inlay hints
method.return.types.in.call.chains=调用链中的方法返回类型
type.annotations=类型注解
parameters.in.parentheses=用括号括起来的参数
non.parenthesized.single.parameter=未使用括号括起来的单个参数
function.returns=函数返回
variables.and.fields=变量和字段
command.name.add.explicit.value=添加显式值 ''{0}''
numeric.enum.values=数值枚举值

# Libraries
progress.title.downloading.library=正在下载库
progress.title.downloading.documentation=正在下载文档
successfully.downloaded=已成功下载
failed.to.download=无法下载
progress.title.downloading.typings=正在下载 typings
notify.urls.more=… 和另外 {0,number} 个

# Structural Search
structural.search.anonymous.functions=匿名函数
structural.search.functions=函数
structural.search.variables=变量
structural.search.function.calls=函数调用
structural.search.while.loops=While 循环
structural.search.constants=常量
structural.search.classes=类
structural.search.empty.functions=空函数
structural.search.console.log.calls=调用 console.log()
structural.search.with.statements=With 语句
structural.search.var.statements=Var 语句
structural.search.functions.with.boolean.parameters=使用布尔参数的函数
structural.search.comparison.to.self=与自身比较

# Project Generators
copying.files=正在复制文件
project.generation=生成项目
notification.title.cannot.generate=无法生成 {0}
dialog.message.cannot.find.npx.bundled.with=找不到使用 {0} 捆绑的 npx
generating.0=正在生成 {0}

# Find Usages
js.show.dynamic.usages=显示动态用法

# Test Runners
action.JasmineGenerateNewSuiteAction.text=Jasmine Suite
action.JasmineGenerateNewSpecAction.text=Jasmine Spec
action.JasmineGenerateBeforeEachMethodAction.text=Jasmine beforeEach
action.JasmineGenerateAfterEachMethodAction.text=Jasmine afterEach
action.QUnitGenerateNewTestAction.text=QUnit Test
action.QUnitGenerateSetupAction.text=QUnit Setup
action.QUnitGenerateTearDownAction.text=QUnit TearDown

# Diagrams
diagram.element.not.found={0} (未找到)

# Web frameworks
web.template.file-type.description={0} 模板
web.inspection.message.attribute.does.not.accept.value={0} 不接受任何值

# Other
command.name.create.javascript.file=创建 JavaScript 文件 {0}
command.name.create.typescript.file=创建 TypeScript 文件 {0}
checkbox.move.simple.expressions.to.field.initializer=将简单表达式移动到字段初始值设定项
popup.title.choose.class=选择类
multiple.inheritance=多重继承
label.method.should.be.defined=方法应已定义
recursive.call=递归调用
command.name.extract.named.type=提取已命名类型
inspection.message.reference.includes.files.outside.project=引用包括项目范围之外的文件
progress.title.executing.performance.task.on.files=正在文件上执行性能任务
terminal.add_node_modules_bin_to_path.label=将 ''node_modules/.bin'' 从项目根添加到 {0}
label.name.injection=名称(&N):
reg.exp.tagged.template=''{1}'' 标记模板中的 {0}
unwrap.with.kind=解开 ''{0}…''
header.declarations.to.be.refactored=要重构的声明
filetype.yarn.lock.display.name=Yarn Lock
filetype.yarn.lock.description=Yarn lock



javascript.validation.message.jsdoc.types.are.used=JSDoc 类型只能在文档注释内部使用
eslint.run.on.save.checkbox.on.actions.on.save.page=运行 eslint --fix
javascript.parser.message.missing.back.quote=缺少 `
node.interpreter.unavailable.target=不可用的目标: {0}
rename.react.hook.variable.title=重命名状态变量
rename.react.hook.variable.description=将相关状态变量重命名为:
web.inspection.message.attribute.value.no.valid={0} 不是 {1} 的有效值。预期值: {2}
add.variable.to.require=添加 require 调用的变量
js.regex.flag.g=全局匹配 - 返回所有匹配项
js.regex.flag.i=忽略大小写 - 不区分大小写的匹配
js.regex.flag.m=多行 - ^ 和 $ 的每行匹配
js.regex.flag.s=dotAll - . 匹配换行符
js.regex.flag.u=unicode - 完整 unicode 支持
js.regex.flag.y=粘性 - 在确切的位置搜索
js.regex.flag.d=匹配索引 - 用于子字符串匹配的索引
node.execution.starting.process.progress.title=正在启动 ''{0}''…
node.wsl.network.connection.failure=无法建立从 WSL 到 Windows 主机的网络连接(可能被防火墙阻止)。\n要了解详细信息，请参阅: https://jb.gg/wsl-firewall
insert.parentheses.on.completion=完成时插入圆括号
intention.category.javascript=JavaScript
intention.category.typescript=TypeScript
intention.category.ecmascript6=JavaScript/ECMAScript 6
intention.category.react=React
js.annotator.rest.element.must.be.last=rest 元素必须位于最后
web.inspection.message.segment.missing=缺少 {0}
web.inspection.message.segment.unrecognized-identifier=无法识别的 {0}
web.inspection.message.segment.duplicated=重复的 {0}
web.inspection.message.segment.default-subject=名称
not.installed.package=未安装软件包
package.version.range.info={0, choice, 0#未安装|1#已安装: ?|2#已安装: {1}}，最新: {2, choice, 0#正在加载…|1#未找到|2#{3}}
package.version.range.hint={0, choice, 0#允许|1#允许次要更新:|2#允许补丁更新:} {1} \\&gt;= 版本 \\&lt; {2}
env.variable.undefined={0} 未定义
env.variable.empty={0} 为空
jquery.documentation.not.found=找不到 jQuery 文档
typescript.language.service.name=TypeScript 服务
eslint.run.on.save.link.enable.eslint=启用 ESLint…
js.annotator.yield.cannot.be.used.inside.generator='yield' 不能用作生成器内部的标识符
js.invalid.expression.result.type.inspection.name=表达式类型无效
linemarker.javascript.sources=JavaScript 源
linemarker.typescript.declaration=TypeScript 声明
choose.declaration.element=<html><body>选择 TypeScript 声明</body></html>
js.dot.property.access.context.type=点号属性访问
javascript.library.built.in=内置
inlay.parameters.js.only.show.names.for.all.args=文字和非文字实参、调用表达式、对象和数组初始值设定项。
inlay.parameters.js.only.show.names.for.tagged=<a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates'>标记模板中的实参。<a>
inlay.parameters.js.only.show.names.for.pipes=<a href='https://github.com/tc39/proposal-pipeline-operator'>管道运算符中的形参。</a>
inlay.parameters.js.param.hints.show.names.for.all.args=方法调用中的文字和命名对象形参。
inlay.parameters.js.param.hints.show.names.for.tagged=标记模板中的实参。
inlay.parameters.angular.show.names.for.all.args=Angular HTML 模板中的文字和命名对象形参。
inlay.parameters.angular.show.names.for.pipes=<a href='https://angular.io/guide/pipes'>Angular HTML 模板中的管道。</a>
inlay.parameters.vuejs.show.names.for.all.args=文字和命名对象。
inlay.parameters.vuejs.show.names.for.filters=<a href='https://vuejs.org/v2/guide/filters.html'>筛选器。</a>
js.url.import.usage.inspection.name=使用了 URL 导入
js.url.import.usage.inspection.download.module.quick.fix.name=下载模块
js.url.import.usage.inspection.download.module.0.quick.fix.failed=下载模块 ''{0}'' 失败
js.url.import.usage.inspection.download.module.0.quick.fix.warning=模块 ''{0}'' 已下载，但有错误
js.url.import.usage.inspection.download.module.0.quick.fix.warning.urls=失败的 URL:
js.url.import.usage.inspection.download.module.0.quick.fix.success=模块 ''{0}'' 已成功下载
js.url.import.usage.inspection.download.module.0.quick.fix.progress=正在下载模块 ''{0}''
js.inspection.package.json.update.dependency.to.latest.version=将 package.json 依赖项更新为最新版本
inspection.update.package_json.dependency.message=有可用的 ''{0}'' 新版本: {1}
inspection.update.package_json.dependency.action.text=将 ''{0}'' 更新到最新版本 {1}
react.native.config.name=React Native
react.native.project.generator.description=借助 <a href='https://facebook.github.io/react-native/'>React Native</a>，只需使用 JavaScript 即可构建移动应用。它使用的设计与 React 相同，让您可以通过声明性组件构建丰富的移动 UI。
react.native.project.generator.package.name=React Native:
react.native.project.generator.validation={0} 不是有效的项目名称。请使用由字母数字构成的项目名称。
escape.jsdoc.copy.pasted.text=在复制和粘贴时转义 JSDoc 前导星号
node.package.empty.error.message=项目名称为空
node.package.name.period.error.message=项目文件夹名称不应以句点开头
node.package.name.underscore.error.message=项目文件夹名称不应以下划线开头
node.package.name.leading.or.trailing.spaces.error.message=项目文件夹名称不应包含前导空格或尾随空格
node.package.name.forbidden.error.message=''{0}'' 不能用作项目名称
node.package.name.core.module.error.message=''{0}'' 不能用作项目名称，因为它是 Node.js 核心模块的名称
node.package.name.too.long.error.message=项目文件夹名称不应超过 214 个字符
node.package.name.capital.letters.error.message=项目文件夹名称不应包含大写字母
node.package.name.special.characters.error.message=项目文件夹名称不应包含特殊字符("~'!()*")
node.package.name.URL-friendly.characters.error.message=项目文件夹名称应仅包含适用于 URL 的字符
javascript.parser.message.expected.identifier.string.literal.or.rbrace=应为标识符、字符串文字或 }
js.import.options.use.explicit.js.extension.auto=自动
js.import.options.use.explicit.js.extension.yes=始终
js.import.options.use.explicit.js.extension.yes.ts=始终为 ".js"
js.import.options.use.explicit.js.extension.no=从不
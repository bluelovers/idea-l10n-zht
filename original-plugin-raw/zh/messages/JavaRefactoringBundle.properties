0.already.contains.field.1={0}已包含字段{1}.
0.already.contains.inner.class.named.1={0}已包含名为{1}的内部类.
0.already.has.parameter.named.1.use.this.name.anyway={0}已经有名为 ''{1}'' 的形参。\n\
仍然使用此名称?
0.contains.call.with.null.argument.for.parameter.1={0} 包含带有形参 {1} 的 null 实参的调用
0.implements.1={0}实现{1}。
0.is.1.and.will.not.be.accessible.from.2.in.the.target.class={0}是{1},不能从{2}访问.
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.parameters={0}方法是层次结构的一部分。您要删除多个形参吗？
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.type.parameters={0}方法是层级的一部分。要删除多个类型形参吗？
0.is.an.interface.method.implementation.will.be.added.to.all.directly.implementing.classes={0}是一个接口.方法的实现将被添加到所有直接实现类.继续进行吗?
0.is.an.interface.that.has.no.implementing.classes={0}是一个接口.没有实现类.
0.is.not.a.legal.java.identifier=''{0}''不是合法的java标识符
0.is.not.accessible.from.1.value.for.introduced.parameter.in.that.method.call.will.be.incorrect={0}不可以从{1}访问。该方法调用中引入形参的值将不正确。
0.is.not.initialized.in.declaration.such.fields.are.not.allowed.in.interfaces={0}在声明处未初始化。在接口中不允许这样的字段。
0.is.not.static.it.cannot.be.moved.to.the.interface={0}不是静态的.不能将它移动到该接口
0.is.used.for.writing.in.1={0}是用来写在{1}
0.refactoring.is.supported.only.for.final.fields=仅 final 字段支持{0}重构
0.upcasts.an.instance.of.1.to.2={0}向上转型实例的{1}{2}.
0.uses.1.of.an.instance.of.a.2={0}{1}的使用的一个实例{2}.
0.uses.1.which.needs.class.instance={0}用{1},这需要的类实例.
0.uses.a.package.local.1={0}使用 package-private {1}
0.uses.non.static.1.which.is.not.passed.as.a.parameter={0}使用非 static {1}，后者不作为形参传递
0.will.be.inaccessible.from.1={0}将无法从{1}
0.will.become.inaccessible.from.1={0}将变得无法从{1}.
0.will.hide.renamed.1={0}将隐藏更名为{1}
0.will.no.longer.override.1={0}将不再重写{1}
0.will.no.longer.be.record.component.accessor={0} 将不再是 {1} getter
0.will.no.longer.be.canonical.constructor=将不再是规范构造函数
0.will.not.be.accessible.from.1.after.inlining={0}不可以从{1}在内联
0.will.override.renamed.1={0}将覆盖更名为{1}
a.package.local.class.0.will.no.longer.be.accessible.from.1=Package-local 类 {0} 将不再可以从{1}访问
accept.signature.change=接受签名变更
add.object.as.a.parameter.to.constructors.with.name=将对象作为形参添加到具有以下名称的构造函数(&O):
add.parameters.for.fields=添加字段形参(&F):
add.parameters.for.fields.to.constructors=向构造函数添加字段形参(&F):
all.candidate.variables.have.types.not.in.project=所有候选变量(方法形参和所包含的类字段)的类型都不在项目中
all.candidate.variables.have.unknown.types=所有候选变量(方法形参和所包含的类字段)都具有未知类型
all.invocations.keep.the.method=内联所有引用并保留方法(&E)
all.references.and.remove.super.class=内联所有引用并移除类(&A)
all.references.and.remove.the.class=内联所有引用并移除类(&A)
all.references.and.remove.the.field=内联所有引用并删除字段 (&A)
all.references.keep.field=内联所有引用并保留字段(&E)
all.these.directories.will.be.moved.and.all.references.to.0.will.be.changed=所有这些目录将被移动，并且所有对 {0} 的引用将被更改。
analyze.and.replace.usages=分析和替换用法
analyze.module.conflicts=分析模块冲突…
annotate.field.as.nonnls.checkbox=注释字段作为 @NonNls (&F)
anonymous.class.text=匿名类
anonymous.to.inner.enum.constant.cannot.refactor.message=枚举常量无法转换为内部类
anonymousToInner.class.name.label.text=类名:
anonymousToInner.make.class.static.checkbox.text=将类设为 static(&S)
anonymousToInner.no.inner.class.name=需指定类名
anonymousToInner.parameters.panel.border.title=构造函数的形参
anonymousToInner.refactoring.name=转换匿名为内部
auto.rename.module.dialog.description=将具有以下名称的 Java 模块重命名为:
auto.rename.module.dialog.title=重命名 Java 模块
auto.rename.module.entity=Java 模块
boolean.method.result=布尔方法的结果
can.t.restore.context.for.method.extraction=无法为方法提取恢复上下文
cannot.find.or.create.destination.directory=无法找到或创建目标目录
cannot.introduce.field.in.interface=接口中不允许出现实例字段
cannot.introduce.field.in.record=记录中不允许出现实例字段
cannot.move=无法移动
cannot.move.inner.class.0.into.itself=不能移动内部类{0}到本身.
cannot.move.package.into.itself=无法将软件包移动到其自身
caret.position.warning.message=文本光标应置于要重构的字段、变量、方法或方法形参类型上
change.method.signature.action.name=更改方法签名
change.signature.default.value.missing.warning.message=缺少默认值。方法调用将包含空值，而不是新的形参值。
change.signature.use.any.checkbox=使用任意变量(&U)
changeClassSignature.bad.value=错误 {0} 值: ''{1}'' 形参 ''{2}''
changeClassSignature.class.label.text=更改{0}的签名
changeClassSignature.no.type.parameters=这个类不能有类型形参
changeClassSignature.parameters.panel.border.title=形参
changeClassSignature.refactoring.name=更改类签名
changeClassSignature.already.contains.type.parameter=''{0}'' 已包含类型形参 ''{1}''
changeClassSignature.Type.parameter.can.not.be.primitive=类型形参不能为基元
changeSignature.bound.value.column=绑定值:
changeSignature.cannot.resolve.return.type=无法解析返回类型''{0}''。\n\
是否继续?
changeSignature.default.value.column=默认值
changeSignature.exception.caller.chooser=选择要传递新异常的方法
changeSignature.exceptions.panel.border.title=异常
changeSignature.exceptions.wont.propagate=递归传播的异常的更改不会被执行
changeSignature.no.return.type=未指定返回类型
changeSignature.no.type.for.exception=指定一个类型给异常
changeSignature.no.type.for.parameter=指定形参 ''{1}'' 的 {0} 类型
changeSignature.not.throwable.type=错误的异常类型''{0}'',应继承java.lang.Throwable
changeSignature.propagate.exceptions.title=传递异常... (&X)
changeSignature.vararg.not.last=vararg 形参应当为方法签名中的最后一个形参
changeSignature.wrong.return.type=错误的返回类型:''{0}''
changeSignature.wrong.type.for.exception=类型错误: 异常的 ''{0}''
changeSignature.wrong.type.for.parameter=类型错误: 形参 ''{1}'' 的 ''{0}''
changeSignature.empty.caller.method.text=此处将显示高亮显示被调用方调用的调用方方法文本
changeSignature.empty.callee.method.text=此处将显示被调用方方法文本
changeSignature.contract.converter.external.annotations=不支持外部注解的自动更新
changeSignature.contract.converter.mutation.contract=注解包含突变协定
changeSignature.contract.converter.definition.error=约定定义出错: {0}
changeSignature.contract.converter.invalid.clause=约定子句 ''{0}'' 无效
changeSignature.contract.converter.parameter.removed=形参 ''{0}'' 已删除，但是约定子句 ''{1}'' 依赖于此
changeSignature.contract.converter.invalid.return.reference=返回值中的引用无效: {0}
changeSignature.contract.converter.return.parameter.removed=形参 ''{0}'' 已删除，但是约定子句 ''{1}'' 将其返回
changeSignature.contract.converter.can.not.update.annotation=@Contract 注解无法自动更新: {0}
changeSignature.contract.converter.inherited.annotation=注解继承自基方法
changeSignature.use.any.var=使用任意变量。
checking.conflicts=正在检查冲突…
choose.the.ones.you.want.to.be.deleted=选择您想要的被删除.
class.0.already.exists=类{0}已存在
class.0.is.not.accessible.from.target.1=类{0}是不可以从目标{1}
class.0.not.found=找不到类 {0}。
class.description=类{0}
class.does.not.exist.in.the.project=模块中不存在类。要创建吗?
class.does.not.have.base.classes.or.interfaces=类{0}没有基类或接口.
class.does.not.have.implicit.default.constructor=类{0}没有隐式的默认构造函数.
class.has.been.successfully.created=已成功创建类{0}.
class.is.abstract={0}为 abstract。
class.is.final.warning.message=类 {0} 为 final
class.is.interface={0}是一个接口.
class.is.never.used=类从未使用
class.name.prompt=类名(&N):
collect.overloads=收集重载…
comments.elements.header=在注释、字符串和非代码文件中发现匹配项 {0}
constructor.being.refactored.is.used.in.initializer.of.0=正在重构的构造函数在 {0} 的初始值设定项中使用。内部类 {1} 的非 static 工厂无法在此上下文中使用。生成的代码将不会编译。
constructor.description=构造函数{0}
constructor.with.builder.new.setter.prefix.dialog.message=新的 setter 前缀:
constructor.with.builder.parameters.to.pass.to.the.builder.title=要传递到构建器的形参
constructor.with.builder.rename.setters.prefix.action.name=重命名 Setter 前缀
convert.anonymous.to.inner.action.name=将匿名转换成内部…
convert.local.to.field.title=将局部转换为字段
convert.to.instance.method.title=转换为实例方法
convertToInstanceMethod.all.reference.type.parameters.are.not.in.project=找不到实例方法的目标类: 所有引用的类型均不在项目中。
convertToInstanceMethod.all.reference.type.parameters.have.unknown.types=找不到实例方法的目标类: 所有引用的类型均未知。
convertToInstanceMethod.method.is.not.static=无法执行重构\n\
方法 {0} 不为 static
convertToInstanceMethod.no.default.ctor=还包含没有默认构造函数的类。
convertToInstanceMethod.no.parameters.with.reference.type=不存在具有引用类型的形参。
convert.to.record.title=转换为记录类
copy.class.clone.0.1=克隆{0}{1}
copy.class.copy.0.1=复制{0}{1}
copy.handler.clone.class=克隆类
copy.handler.copy.class=复制类
copy.handler.copy.class.with.dialog=复制类…
copy.handler.copy.classes.with.dialog=复制类…
current.class=当前类
dataflow.to.here.expand.progress=正在展开所有节点…{0}
dataflow.to.here.group.by.leaf.action.description=确定 null 是否可以流入此表达式
dataflow.to.here.group.by.leaf.action.text=按叶表达式空值分组{0, choice, 1#|2# (正在分析)}
dataflow.to.here.variable.dereferenced.tooltip=已取消引用变量
declaration.s.to.be.generified=声明(s)是泛型{0}
declare.final=声明 final(&F)
declare.generated.annotations=生成注解(&G)
declare.static.checkbox=声明静态 (&S)
declare.static.pass.fields.checkbox=声明 static (作为形参传递字段)(&S)
declare.var.type=声明变量类型(&V)
declare.varargs.checkbox=声明 vararg(&A)
default.visibility.border.title=缺省可见
delete.variable.declaration=删除变量声明 (&D)
destination.directory.does.not.correspond.to.any.package=目标目录不对应于任何软件包
destination.package=目标软件包(&P):
different.name.expected=应为不同名称
directory.0.already.contains.1.named.2=目录已经包含了{0}{1}命名为"{2}"
directory.0.already.contains.a.file.named.1=目录{0}已经包含一个文件命名为"{1}"
do.not.replace=不要替换 (&N)
do.not.show.this.message.in.the.future=以后不再显示此消息 (&D)
do.you.want.to.process.overriding.methods.with.covariant.return.type=您想要使用协变返回类型处理覆盖方法?
edit.migration.entry.title=编辑类/软件包迁移规则
element.will.no.longer.be.accessible={0}将不再可以从{1}
encapsulate.fields..encapsulated.fields.visibility.border.title=封装字段的可见性
encapsulate.fields..package.local.radio=Package local(&C)
encapsulate.fields.accessors.visibility.border.title=访问器可见性
encapsulate.fields.command.name=封装字段在{0}
encapsulate.fields.encapsulate.border.title=封装
encapsulate.fields.existed.accessor.hidden={0} 已经存在，将被生成的访问器隐藏
encapsulate.fields.existed.accessor.hides.generated={0} 已经存在，将为 {1} 隐藏生成的访问器
encapsulate.fields.expression.type.is.used=使用结果类型时，无法继续使用后缀/前缀表达式
encapsulate.fields.field.column.name=字段
encapsulate.fields.fields.to.be.encapsulated=字段封装
encapsulate.fields.fields.to.encapsulate.border.title=字段来封装
encapsulate.fields.get.access.checkbox=获取访问权限 (&G)
encapsulate.fields.getter.column.name=Getter
encapsulate.fields.getter.exists=那已经是一个方法不同于{0}{1}的getter只返回类型.
encapsulate.fields.no.target=未找到要封装的内容
encapsulate.fields.nothing.todo.warning.message=类具有要封装的字段
encapsulate.fields.private.radio=私有(&I)
encapsulate.fields.protected.radio=protected(&T)
encapsulate.fields.refactoring.cannot.be.applied.to.interface=封装字段重构不能应用到接口
encapsulate.fields.set.access.checkbox=设置访问权限 (&S)
encapsulate.fields.setter.column.name=Setter
encapsulate.fields.setter.exists=那已经是一个方法{0},{1}有别于setter由返回类型只有.
encapsulate.fields.title=封装字段
encapsulate.fields.use.accessors.even.when.field.is.accessible.checkbox=使用访问器即使字段是可访问的
entity.name.constructor.parameter=形参
entity.name.inheritor=继承者
entity.name.test=测试
entity.name.variable=变量
entity.name.accessor=访问器
enum.description=枚举 {0}
error.cannot.resolve=无法解析 {0}
error.incorrect.data=不正确的数据
error.not.supported.for.jsp={0}重构不支持JSP
error.not.supported.for.local=局部类不支持 {0} 重构
error.not.supported.for.package.info={0}重构不支持 package-info.java
error.wrong.caret.position.anonymous=文本光标应置于要重构的匿名类内
error.wrong.caret.position.constructor=文本光标应置于要重构的构造函数内
error.wrong.caret.position.local.or.expression.name=文本光标应置于要重构的局部变量或表达式的名称处
error.wrong.caret.position.method=文本光标应置于要重构的方法内
error.wrong.name.input=错误的名称:{0}
expand.method.reference.warning=方法用于一个或多个方法引用。继续会将这些方法引用转换为 lambda 表达式。
expression.result=表达式结果
extract.chained.constructor.checkbox=提取链接构造函数 (&C)
extract.delegate.as.enum.checkbox=提取为枚举
extract.delegate.create.nested.checkbox=创建嵌套类
extract.delegate.generate.accessors.checkbox=生成访问器(&G)
extract.delegate.unable.create.warning.message=无法创建包含给定名称的类
extract.method.control.flow.analysis.failed=代码包含语法错误。无法执行必要的分析。
extract.method.error.prefix=无法提取方法。
extract.method.error.class.outside.used=局部类在所选块之外使用。
extract.method.error.class.outside.defined=局部类在所选块之外定义。
extract.method.error.many.outputs=有多个变量要返回。
extract.method.error.many.exits=有多个出口点。
extract.method.error.many.finals=存在对 final 字段的赋值。
extract.method.error.variable.in.expression=所选表达式内有一个要返回的变量。
extract.method.error.class.not.found=所选块应当是 java 类的一部分。
extract.method.error.invalid.name=无效方法名称
extract.method.error.method.conflict=具有相同签名的方法已存在
extract.method.object.anonymous.make.varargs.option=设为 vararg(&V)
extract.method.object.class.name=类名(&C):
extract.method.object.create.anonymous.class=创建匿名类(&A)
extract.method.object.create.inner.class=创建内部类(&I)
extract.method.object.inner.class.visibility=可见性:
extract.method.object.inner.make.static.option=设为 static(&S)
extract.method.object.inner.make.varargs.option=设为 vararg(&V)
extract.method.object.inner.visibility.package.local=package local(&K)
extract.method.object.inner.visibility.private=private(&V)
extract.method.object.inner.visibility.protected=protected(&O)
extract.method.object.inner.visibility.public=public(&B)
extract.method.object.method.name=方法名称(&M):
extract.method.object.parameters=形参
extract.method.object.signature.preview=签名预览
extract.method.object.suggestion=是否要提取方法对象?
extract.parameters.to.replace.duplicates=提取形参以替换重复项
extract.subclass.command=提取子类
extractSuper.rename.original.class.to=重命名原始类到: (&R)
extractSuperInterface.javadoc=JavaDoc
factory.method.name.label=工厂方法名称:
failed.to.re.run.refactoring=无法重新运行重构
field.0.is.already.defined.in.the.1=字段{0}已经定义在{1}.
field.0.is.never.used=字段{0}从未使用过
field.0.is.not.accessible=字段{0}是不可以从{1}
field.0.will.hide.field.1.of.the.base.class=字段{0}将隐藏基类 {2} 的字段{1}.
field.declaration.radio=字段声明 (&D)
field.description=字段{0}
field.name=字段名称 (&F):
fields.to.be.refactored.should.belong.to.the.same.class=重构的字段应该属于同一个类.
functional.interface.broken=函数表达式要求功能界面准确的一种方法
generate.getter.for.delegated.component=为委派成员生成getter (&G)
generate.module.descriptors.analysing.message=正在分析依赖关系
generate.module.descriptors.build.required.message=无法生成模块描述符，因为该项目尚未构建
generate.module.descriptors.collecting.message=正在收集依赖关系
generate.module.descriptors.command.title=生成 module-info 描述符
generate.module.descriptors.no.suitable.modules.message=未找到可能包含模块信息的模块
generate.module.descriptors.preparing.message=正在准备代码
generate.module.descriptors.rebuild.message=为了提高依赖关系计算的准确性，需要构建该项目。\n\
在生成模块信息描述符之前开始构建?
generate.module.descriptors.scanning.message=正在扫描编译器输出
generate.module.descriptors.title=生成模块描述符
generify.title=将原始类型转换为泛型
getter.and.setter.methods.found.for.the.field.0=Getter和setter方法发现的领域{0}.{1}它们吗?
getter.method.found.for.the.field.0=Getter方法发现田野{0}.{1}getter吗?
idea.has.not.found.any.code.that.can.be.replaced.with.method.call={0}没有发现任何副本
ignore.button=忽略
implicit.last.parameter.warning=隐式最后一个形参不应删除
infer.class.type.args.warning=无法推断类类型实参。继续时，将创建原始 {0}
information.title=信息
initializer.for.variable.cannot.be.a.constant.initializer=变量的 {0} 初始值设定项不能是常量初始值设定项
inline.action.name=内联
inline.anonymous.conflict.progress=正在搜索类 "{0}" 继承者…
inline.class.elements.header=类内联
inline.conflicts.progress=检查是否可以内联…
inline.constant.field.not.supported.for.enum.constants=枚举常量不支持 {0}
inline.element.unknown.header=未知元素
inline.field.action.name=内联字段…
inline.field.command=内联场{0}
inline.field.elements.header=场内联
inline.field.field.name.label=字段 {0}
inline.field.field.occurrences=字段 {0} 有 {1} {1, choice, 1#匹配项|2#匹配项}
inline.field.title=内联领域
inline.field.used.in.javadoc=已内联字段用于 javadoc
inline.field.used.in.reflection=已内联字段以反射形式使用
inline.field.initializer.is.not.accessible=字段初始值设定项引用无法在 {1} 中访问的 {0}
inline.local.unable.try.catch.warning.message=无法在 try/catch 语句外内联
inline.local.used.as.resource.cannot.refactor.message=变量用作资源引用
inline.local.variable.declared.outside.cannot.refactor.message=变量在代码块外声明
inline.method.calls.not.accessible.in=已内联方法调用将不会在 {1} 中访问的 {0}
inline.method.calls.not.accessible.on.qualifier=已内联方法调用在限定符 {1} 上将无法访问的 {0}
inline.method.checking.tail.calls.progress=检查尾调用用法
inline.method.elements.header=方法内联
inline.method.method.label=方法 {0}
inline.method.method.occurrences=方法 {0} 有 {1} {1, choice, 1#匹配项|2#匹配项}
inline.method.multiline.method.in.ctor.call=内联不能在构造函数调用中应用于多行方法
inline.method.multiline.method.in.loop.condition=内联不能在循环条件中应用于多行方法
inline.method.object.action.name=内联对象
inline.method.object.suggestion.message=要内联对象和后续调用吗?
inline.method.qualifier.usage.side.effect=已内联方法用于方法引用，限定符具有副作用
inline.method.used.in.javadoc=已内联方法用于 javadoc
inline.method.used.in.reflection=已内联方法以反射形式使用
inline.parameter.action.name=内联形参…
inline.parameter.cannot.find.initializer.warning.message=无法为形参找到常量初始值设定项
inline.parameter.confirmation=将形参 ''{0}'' 与初始值设定项 ''{1}'' 内联?
inline.parameter.error.hierarchy=内联形参不支持当方法是一个继承层次结构的一部分
inline.parameter.error.non.project.method=非项目方法不支持内联
inline.parameter.error.varargs=不支持内联 vararg 形参
inline.parameter.dependency.unavailable.in.static.method=形参初始值设定项依赖 {0}，其在 static 方法中不可用
inline.parameter.depends.on.caller.parameter=形参初始值设定项依赖调用方形参
inline.parameter.depends.on.non.static=形参初始值设定项依赖其他类的非 static 成员
inline.parameter.depends.on.non.static.class=形参初始值设定项依赖非 static 类，其在 static 方法中不可用
inline.parameter.depends.on.this.inside.static.method=形参初始值设定项依赖于此，其在 static 方法中不可用
inline.parameter.depends.on.unavailable.element.inside.method=形参初始值设定项依赖 {0}，其在方法内部不可用并且无法内联
inline.parameter.depends.on.unavailable.value=形参初始值设定项依赖方法内部不可用的值
inline.parameter.initializer.depends.on.inaccessible.value=形参初始值设定项依赖方法内部不可用且无法内联的值
inline.parameter.method.usages.progress=正在搜索方法用法
inline.parameter.no.usages.warning.message=方法没有用法
inline.parameter.not.accessible.warning.message=在方法体内无法访问常量初始值设定项
inline.parameter.refactoring=内联形参
inline.parameter.replace.with.local.checkbox=替换为局部变量(e)\r (&E)
inline.parameter.write.usages.warning.message=不支持具有写入用法的内联形参
inline.pattern.variable.title=内联模式变量
inline.super.class=内联超类
inline.super.class.action.name=内联超类…
inline.super.class.label=类{0}
inline.super.ctor.can.be.replaced=构造函数 {0} 可被替换为 {1} 的任意一个
inline.super.doc.panel.title=已内联成员的 JavaDoc
inline.super.expr.can.be.replaced={0} 可被替换为 {1} 的任意一个
inline.super.no.anonymous.class=无法内联到匿名类中。
inline.super.no.ctor=找不到构造函数匹配的 super
inline.super.no.inner.class=无法内联到内部类中。将 ''{0}'' 移动到上一级别
inline.super.no.substitution=找不到 {0} 的一致替换。应为 ''{1}''，但找到的为 ''{2}''。
inline.super.no.return.in.super.ctor=当 return 语句中断超级构造函数的执行流时，不支持重构
inline.super.non.project.class.warning.message=无法内联非项目类
inline.super.static.import.can.be.replaced=静态导入可被替换为 {0} 的任意一个
inline.super.target.instead.of.super.class=目标类型的实例被传递到期望超类的位置。
inline.super.type.element.can.be.replaced={0} 可被替换为 {1} 的任意一个
inline.super.type.params.differ=类型形参在 {0} 中不一致。应为 {1}，但找到的为 {2}
inline.super.unknown.type=类型未知
inline.to.anonymous.border.title=内联
inline.to.anonymous.command.name=内联类{0}
inline.to.anonymous.name.label=类 {0}
inline.to.anonymous.no.abstract=abstract 类不能被内联
inline.to.anonymous.no.ctor.calls=因为在主体内部对构造函数的调用，无法内联类
inline.to.anonymous.no.get.class.calls=getClass() 调用的结果将被更改
inline.to.anonymous.no.method.calls=因为在主体内部对成员的调用，无法内联类
inline.to.anonymous.no.multiple.interfaces=实现多个接口的类不能被内联
inline.to.anonymous.no.superclass.and.interface=有超类和实现了接口的类不能被内联
inline.to.anonymous.refactoring=内联到匿名类
inline.vars.elements.header=变量以内联
inlined.method.implements.method.from.0=内联方法实现方法从{0}
inlined.method.overrides.method.from.0=从{0}内联方法重写方法
inlined.method.will.be.transformed.to.single.return.form=内联方法将转换为单个返回形式
inner.class.0.is.already.defined.in.class.1=内部类 {0} 已在类 {1} 中定义。\n\
仍然继续?
inner.class.0.is.not.static=内部类 {0} 不为 static。\n\
仅 static 成员支持{1}重构。
inner.class.exists=名为''{0}''的内部类已经定义在类''{1}''中
inner.class.name=内部类名(&I):
instance.initializer.description=类 {0} 的实例初始值设定项
instances.casted.to.java.lang.object=实例转换为java.lang.Object
instances.of.0.upcasted.to.1.were.found=实例的{0},{1}向上转型被发现.如果您继续下去,他们将被显示在一个单独的找到选项卡.
instances.upcasted.to.java.lang.object.found=实例向上转型到java.lang.Object对象发现
instances.upcasted.to.object=向上转型实例对象
interface.0.does.not.have.inheritors=接口{0}没有继承者.
interface.description=接口 {0}
interface.does.not.have.base.interfaces=接口{0}没有基本接口.
interface.has.been.successfully.created=已成功创建接口{0}.
introduce.constant.enum.cb=提取为枚举常量 (&E)
introduce.constant.field.of.type=常量(static final 字段)的类型(&T):
introduce.constant.introduce.to.class=提取到类(完全限定名称)(&C):
introduce.constant.move.to.another.class.checkbox=移动到另一个类(&M)
introduce.constant.used.for.write.cannot.refactor.message=选定的表达式用于写入
introduce.field.field.of.type=类型的字段: (&T)
introduce.field.static.field.of.type=static 字段的类型(&T):
introduce.functional.variable.pass.fields.checkbox=将字段作为形参传递(&F)
introduce.local.variable.to.reassign.title=选择要重新分配的变量
introduce.parameter.command=正在将形参提取到{0}
introduce.parameter.convert.lambda=转换为 lambda (&C)
introduce.parameter.duplicates.progress=搜索方法重复项…
introduce.parameter.elements.header=正在将形参添加到方法
introduce.parameter.object.create.inner.class=创建内部类(&I)
introduce.parameter.object.create.new.class=创建新类(&C)
introduce.parameter.object.escalate.visibility.option=升级可见性(&E)
introduce.parameter.object.existing.class.name=名称(&N)
introduce.parameter.object.generate.accessors.option=生成访问器(&G)
introduce.parameter.object.inner.class.name=名称(&N)
introduce.parameter.object.new.class.name=名称(&N)
introduce.parameter.object.new.class.package.name=软件包名称(&P)
introduce.parameter.object.use.existing.class=使用现有类(&U)
introduce.parameter.super.method.checkbox=重构 super 方法(&U)
introduce.parameter.to.method=将形参提取到方法:
introduced.variable.will.conflict.with.0=引入的变量与{0}冲突
introducing.variable.may.break.code.logic=引入变量可能打破代码逻辑。
invalid.expression.context=无效的表达式上下文.
invalid.package.name=无效的软件包名称: {0}
invalid.target.package.name.specified=指定了无效的目标软件包名称
invert.boolean.foreach=Foreach 形参初始值设定不能反转
invert.boolean.wrong.type=该方法的返回类型或类型的变量是重构应该是布尔
invocations.to.be.inlined=调用内联{0}
is.modified.in.loop.body={0}是修改在循环体.
javadoc.for.abstracts=JavaDoc的摘要
keep.original.signature=保留原始签名
lambda.to.reference.side.effect.warning.message=方法引用限定符中可能存在副作用。\n\
引入局部变量?
local.variable.description=局部变量{0}
local.will.be.hidden.renamed.description=重命名的字段将隐藏 {0}
locate.caret.inside.a.method=将文本光标定位在成员内
locate.duplicates.action.name=定位重复项
make.0.static=将{0}设为 static
make.method.static.title=将方法设为 static
make.static.command=将 {0} 设为 static
make.static.description.label=将{0} {1}设为 static
make.static.elements.header=要设为 static 的{0}
make.static.method.references.progress=搜索方法引用
make.static.methods.to.propagate.dialog.title=选择要传递 static 的方法
members.to.form.interface.title=要构成接口的成员
members.to.form.superclass.title=要形成超类的成员
method.0.is.overridden.by.1=方法{0}被{1}重写。
method.0.will.hide.method.of.the.base.class=方法{0}将隐藏基类{1}的此方法。
method.0.will.implement.method.of.the.base.class=方法{0}将实现基类{1}的一个方法。
method.0.will.override.a.method.of.the.base.class=方法{0}将重写基类{1}的一个方法。
method.call.would.be.linked.to.0.after.rename=重命名后，方法调用将被链接到“{0}”
method.column=方法
method.description=方法 {0}
method.does.not.have.a.body=方法{0}没有方法体。
method.duplicates.found.message=已找到 {0, choice, 1#1 个代码段|2#{0,number} 个代码段}
method.has.an.empty.body=方法 {0} 具有空体。
method.is.not.a.constructor=方法是不是构造函数。
migration.class=类
migration.dialog.ok.button.text=运行
migration.dialog.title=软件包和类迁移
migration.entry.class=类
migration.entry.new.name=新名称:
migration.entry.old.name=旧名称:
migration.entry.package=软件包
migration.map.description.label=映射描述:
migration.map.name.prompt=地图的名字:
migration.new.name.column.header=新名字
migration.no.usages.found.in.the.project=项目中找不到任何用法
migration.old.name.column.header=旧名称
migration.package=软件包
migration.package.with.subpackages=软件包和子软件包
migration.title=迁移
migration.type.column.header=类型
move.class=移动类…
move.class.refactoring.cannot.be.applied.to.anonymous.classes=移动类重构不能应用于匿名类
move.class.to.inner.command.name=将 {0, choice, 1#类|2#类} 从 {1} 移动到 {2}
move.class.to.inner.move.to.self.error=不允许移动类到自身
move.class.to.inner.nonstatic.error=不允许将类移动到非 static 内部类
move.classes=移动类...
move.classes.and.packages=移动类和软件包…
move.classes.command=正在将 {0} 移到软件包 {1}
move.classes.destination.make.inner=使内部类(&M)
move.classes.destination.package.prompt=到软件包:
move.classes.destination.to.package=到软件包(&G)
move.classes.invalid.package.name.warning.message=无效的软件包名称
move.classes.or.packages.title=移动
move.classes.or.packages.different.modules.exports.conflict=将 {0} 从模块 {1} 移动到模块 {2} 可以隐藏对其的访问
move.classes.or.packages.new.module.exports.conflict=更改软件包 {0} 的 export/opens 语句将授予对同一软件包中其他类型及其成员的访问权限
move.classes.or.packages.unused.exports.notification.title=在模块 {0,choice, 1#描述符|2#描述符} 中<br>\n\
发现未使用的 export/open
move.classes.or.packages.unused.exports.action.name=删除未使用的 exports/opens
move.classes.or.packages.unused.exports.command.name=删除未使用的 exports/opens
move.enum.constant.cb=如果可能,移动为枚举常数 (&E)
move.files.regrouping.command.name=正在重新分组…
move.files.to.new.directory.prompt=到目录:
move.inner.class.action.name=移动内部类…
move.inner.class.command=移动内部类{0}
move.inner.class.to.another.class=移动内部类{0}到另一个类 (&M)
move.inner.class.to.be.moved=类移动
move.inner.class.to.upper.level=将内部类 {0} 移至上一级
move.inner.class.to.upper.level.action.name=将内部类移动到上一级别…
move.instance.method.delegate.title=移动实例方法…
move.instance.method.elements.header=移动实例方法
move.instance.method.handler.make.method.static=是否要将方法 ''{0}'' 设为 static 并随后移动?
move.members.action.name=移动成员…
move.method.enter.a.valid.name.for.parameter=请输入一个有效的形参名称
move.method.is.not.supported.for.0={0} 不支持移动实例方法
move.method.is.not.supported.for.constructors=构造函数不支持 Move 方法
move.method.is.not.supported.for.generic.classes=泛型类不支持 Move 方法
move.method.is.not.supported.for.non.project.methods=非项目方法不支持 Move 方法
move.method.this.parameter.label=为 ''{0}.this'' 形参选择一个名称
move.methods.panel.title=要移至已提取类的方法(&M)
move.methods.used.in.extracted.block.only=仅在提取块中使用的 Move 方法
move.nonstatic.class.from.jsp.not.supported=不支持从 JSP 页面移动非 static 类
move.package.or.directory=移动软件包或目录…
move.package.refactoring.cannot.be.applied.to.default.package=“移动软件包”重构不能用于默认软件包
move.packages.or.directories=移动软件包或目录…
move.single.class.or.package.name.label=移动 {0} {1}
move.specified.classes=移动指定的类
move.specified.packages=移动指定的软件包
move.to.inner.duplicate.inner.class=类{0}已包含一个名为{1}的内部类
moving.local.classes.is.not.supported=不支持移动局部类。
no.class.name.specified=未指定类名称
no.exact.method.duplicates.were.found=<html><b>未找到确切的方法重复项</b>，但如下所示，变更的方法中有 {0} 个{0,choice, 1#重复项|2#重复项}</html>
no.initializer.present.for.the.field=字段没有初始值设定项
no.parameter.name.specified=未指定形参名称
no.usages.can.be.replaced=没有用途的{0}可以替换用法{1}
occurrences.to.be.migrated=匹配项被迁移的{0}
ok.button=确定
only.fields.variables.of.methods.of.valid.type.can.be.considered=仅可以考虑有效类型的字段、变量、方法形参或方法。
package.description=软件包 {0}
package.does.not.exist=软件包 {0} 不存在。\n\
要创建吗?
package.does.not.exist.preview=软件包 {0} 不存在。\n\
重构稍后将为您创建该软件包。
package.name.prompt=软件包名称(&G):
parameter.description=形参 {0}
parameter.initializer.contains.0.but.not.all.calls.to.method.are.in.its.class=形参初始值设定项包含 {0}，但并非对方法的所有调用都位于其类中
parameter.name.prompt=形参名称(&M):
parameter.of.type=类型的形参(&T):
parameter.type.table.column.title=类型
parameter.used.in.method.body.warning={0} 用于方法体
pass.outer.class.instance.as.parameter=将外部类实例作为形参传递(&U)
please.enter.a.valid.target.package.name=请输入一个有效的目标软件包名称
press.the.do.migrate.button=按搜索结果面板\n\
底部的"迁移"按钮,使用迁移地图"{0}"\n\
进行迁移
preview.usages.to.be.changed=预览要改变的用法 (&P)
process.duplicates.change.signature.promt=要替换所有匹配项，需要更改方法签名。是否继续?
process.duplicates.title=处理重复项
process.methods.duplicates.title=过程方法复制的{2}({0},{1})
processing.progress.text=正在处理 {0}
project.files.have.been.changed=已更改项目文件。\n\
要重新运行重构吗?
push.down.delete.warning.text={0}向下推动成员会导致它们被删除。要继续吗?
push.down.enum.no.constants.warning.text=枚举 {0} 没有要内联到的常量。
push.down.no.inheritors.class.warning.text=类 {0} 没有继承者。
push.down.no.inheritors.final.class.warning.text=final 类 {0} 没有继承者。
re.run.refactoring=重新运行重构
refactoring.cannot.be.applied.no.sources.attached={0} 重构无法应用: 未附加任何源
refactoring.cannot.be.applied.to.abstract.methods={0}重构不能应用于 abstract 方法
refactoring.cannot.be.applied.to.inline.non.chaining.constructors={0}重构不能用于内联非链接构造函数
refactoring.cannot.be.applied.to.native.methods={0} 重构不能应用于原生方法
refactoring.cannot.be.applied.to.vararg.constructors={0}重构无法应用于 vararg 构造函数
refactoring.extract.method.dialog.duplicates.count={0,choice, 1#1|2#{0,number}} 个重复的代码{0,choice, 1#段|2#段}可被替换为提取的方法调用
refactoring.extract.method.dialog.duplicates.pending=正在搜索重复项…
refactoring.extract.method.dialog.duplicates.progress=正在搜索重复项
refactoring.extract.method.inner.class.defined=内部类 {0} 已在类 {1} 中定义。
refactoring.extract.method.preview.button.refactor=执行重构(&D)
refactoring.extract.method.preview.button.rerun=重新运行重构(&E)
refactoring.extract.method.preview.failed=无法提取方法
refactoring.extract.method.preview.group.duplicates=重复的代码段
refactoring.extract.method.preview.group.method=要提取的方法
refactoring.extract.method.preview.group.original=原始代码段
refactoring.extract.method.preview.preparing=正在准备差异
refactoring.extract.method.preview.updating=正在更新差异
refactoring.extract.method.reference.to.change=待变更引用
refactoring.introduce.variable.enum.in.label.message=无法提取 switch 标签中的枚举常量
refactoring.is.not.supported.for.jsp.classes=重构不支持JSP类.
refactoring.is.not.supported.for.local.and.jsp.classes=重构不支持局部和JSP类.
refactoring.is.not.supported.in.the.current.context={0}重构是不支持在当前上下文
references.in.code.to.elements.from.migration.map=在代码元素的引用从移民地图"{0}"{1}
references.to.0.to.be.replaced.with.references.to.1=对 ''{0}'' 的引用要替换为对 ''{1}''{2} 的引用
remove.parameter.0.no.longer.used=移除不再使用的形参 ''{0}''
rename.constructor.parameters.title=重命名构造函数形参
rename.constructor.parameters.with.the.following.names.to=将具有以下名称的形参重命名为:
rename.module.already.exists=模块 ''{0}'' 已经存在于项目中
rename.module.directory.command=将模块和目录重命名为 ''{0}''
rename.module.directory.title=重命名模块和目录(&A)
rename.overloads=重命名重载 (&O)
rename.overloads.dialog.title=重命名重载
rename.overloads.to.dialog.description=将重载重命名为:
rename.parameter.in.hierarchy.to.dialog.description=将层次结构中的形参重命名为:
rename.parameters.dialog.title=重命名形参
rename.tests=重命名测试 (&E)
rename.tests.title=重命名测试
rename.tests.with.the.following.names.to=重命名测试具有以下名称:
rename.variables=重命名变量 (&V)
rename.variables.title=重命名变量
rename.accessors=重命名访问器(&A)
rename.accessors.title=重命名 Getter/Setter
rename.accessors.with.the.following.names.to=重命名具有以下名称的访问器:
renamed.class.will.hide.0.in.1=重命名类将隐藏{0}在{1}
renaming.method.will.override.final.0=重命名方法将重写 final“{0}”
replace.all.fields=替换所有字段 (&R)
replace.all.occurrences.of.expression.0.occurrences=替换所有匹配项({0})(&A)
replace.constructor.0.with.a.factory.method=将构造函数 {0} 替换为工厂方法
replace.constructor.builder.create.new=创建新的(&C)
replace.constructor.builder.use.existing=使用现有项(&U)
replace.constructor.existing.builder.fqn=构建器类名 (完全限定)(&B)
replace.constructor.new.builder.class.name=构建器类名(&N)
replace.constructor.new.builder.package=新构建器的软件包(&P)
replace.constructor.with.factory.method=将构造函数替换为工厂方法
replace.constructor.with.factory.method.title=将构造函数替换为工厂方法
replace.constructor.with.factory.target.fq.name=在(完全限定名称):
replace.default.constructor.of.0.with.a.factory.method=将默认构造函数 {0} 替换为工厂方法
replace.default.constructor.with.factory.method=将默认构造函数替换为工厂方法
replace.fields.inaccessible.in.usage.context=替换上下文没有使用的字段 (&I)
replace.fields.used.in.expressions.with.their.getters=将表达式中使用的字段替换为其 getter (&U)
replace.inheritance.from=替换委派继承从(&R):
replace.inheritance.with.delegation.command=使用{0}中的委托替换继承
replace.inheritance.with.delegation.delegate.members.title=委派成员
replace.inheritance.with.delegation.elements.header=替换继承与代表团
replace.inheritance.with.delegation.invalid.field=''{0}'' 是委派的无效字段名称
replace.inheritance.with.delegation.invalid.inner.class=''{0}'' 是委派的无效字段名称
replace.inheritance.with.delegation.title=用委派替换继承
replace.instance.qualifiers.with.class.references=将实例限定符替换为类引用
replace.method.code.duplicates.title=替换重复代码
replace.method.duplicates.scope.chooser.message=分析范围
replace.method.duplicates.scope.chooser.title=指定{0}范围
replace.this.code.fragment.and.change.signature=方法的签名将被更改为{0}
replace.this.code.fragment.and.make.method.static=(方法将被设为 static)
replace.this.code.fragment.and.make.method.static.visible=(方法将被设为 static 和{0})
replace.this.code.fragment.and.make.method.visible=(方法将{0})
replace.with.method.call.does.not.work.for.constructors=替换为方法调用不工作为构造函数
replace.write.access.occurrences=替换白名单匹配项 (&L)
replacing.inheritance.with.delegation=替换继承与代表团
safe.delete.search.for.caller.method.usages.progress=搜索调用者方法用法…
safe.delete.select.members.to.propagate.dialog.title=选择要传播安全删除的成员
safe.delete.select.methods.to.propagate.delete.parameters.dialog.title=选择要传播形参删除的方法
safe.delete.parameter.usage.warning=形参 ''{0}'' 具有无法安全删除的用法
select.source.root.chooser.title=选择根源代码
selected.block.contains.invocation.of.another.class.constructor=所选块包含调用另一个类构造函数
selected.block.contains.statement.outside.of.class=所选块在类外部包含语句
selected.block.should.represent.an.expression=所选块应该代表一个表达式
selected.expression.cannot.be.a.constant.initializer=所选表达式不能是常量初始值设定项
selected.expression.has.void.type=选定的表达式有空隙类型.
selected.expression.introduces.pattern.variable=选定的表达式引入模式变量 ''{0}''
popup.title.choose.class.to.introduce.constant=选择要引入常量的类
popup.title.choose.class.to.introduce.field=选择要引入字段的类
setter.method.found.for.the.field.0=Setter方法发现田野{0}.{1}setter吗?
side.effects.detected.title=已检测到副作用
source.folder.0.has.package.prefix.1=源文件夹 {0} 具有软件包前缀 ''{1}''\n\
无法在该文件夹中创建软件包 ''{2}''。
static.initializer.description=类 {0} 的 static 初始值设定项
superclass.cannot.be.accessed.in.subclass=在子类中将无法访问的超类
superclass.cannot.be.extracted.from.an.enum=无法从枚举中提取超类
superclass.cannot.be.extracted.from.a.record=不能从一个记录中提取超类
synthetic.jsp.class.is.referenced.in.the.method=合成的jsp类是引用的方法
target.0.is.not.accessible.from.1=目标{0}是不可以从{1}
the.field.should.be.declared.in.a.class=应在类中声明该字段.
there.are.going.to.be.multiple.destination.files.with.the.same.name=有多个目标文件具有相同的名称。
there.are.multiple.exit.points.in.the.selected.code.fragment=选定的代码段有多个出口点。
there.are.multiple.output.values.for.the.selected.code.fragment=选定的代码段有多个输出值。
there.are.no.variables.that.have.reference.type=方法形参或所包含的类字段都没有引用类型
there.are.unused.methods.that.override.methods.you.delete=有未使用的方法,覆盖方法您删除.
there.is.already.a.0.in.1=已存在一个{0}在{1}中
there.is.already.a.0.it.will.conflict.with.an.introduced.parameter=已经有一个{0}。它将冲突与引入的形参冲突
there.is.already.a.0.it.will.conflict.with.the.renamed.1=已经有一个{0}.它将冲突与更名为{1}
there.is.already.type.parameter.in.0.with.name.1=名称为 {1} 的 {0} 中已存在类型形参
this.method=这种方法
this.reference.only.and.keep.super.class=这个仅供引用并保持内联的超类(&K)
this.reference.only.and.keep.the.class=内联这只引用和保持类(&K)
this.reference.only.and.keep.the.field=内联这只引用和保持字段(&K)
turn.refs.to.super.command=更换用法{0}和{1}
turnRefsToSuper.change.usages.to=更改{0}的使用到: (&C)
turnRefsToSuper.use.superclass.in.instanceof=使用接口/超类在实例 (&U)
type.cook.command=泛化
type.cook.drop.obsolete.casts=删除废弃转换 (&D)
type.cook.elements.header=Generify的范围
type.cook.generify.objects=Generify对象(&O)
type.cook.leave.object.parameterized.types.raw=离开对象形参化类型生(&L)
type.cook.perform.exhaustive.search=执行详尽的搜索(&E)
type.cook.preserve.raw.arrays=保存原始数组(&A)
type.cook.produce.wildcard.types=产生通配符类型(&W)
type.cook.ratio.generified={0,choice,-1#不计算|0#{0,number}/{1}}
type.cook.report=项目泛型: {0}, 转换已移除: {1}
type.migration.action.name=类型迁移
type.migration.choose.scope.title=选择可能出现变更签名的范围
type.migration.conflicts.found=找到的迁移冲突
type.migration.exclude.action.text=排除 (&E)
type.migration.include.action.text=包含(&I)
type.migration.label=将{0}“{1}”迁移到
type.migration.migrate.button.text=迁移 (&M)
type.migration.no.conflicts.found=未找到迁移冲突
type.migration.no.scope.warning.message=未选择范围
type.migration.preview.warning.text=已找到 10 多个要迁移的根。要预览吗?
type.migration.reasons.to.migrate=已找到要迁移的原因
type.migration.rerun.button.text=返回类型迁移 (&R)
type.migration.select.suggestion=选择根以查找迁移的原因
type.of.the.selected.expression.cannot.be.determined=类型的选定的表达式不能确定.
unable.to.start.type.migration=无法启动类型迁移
unknown.expression.type=未知的表达式类型.
unused.overriding.methods.title=未使用重写方法
usages.detected.title=检测到用法
use.interface.superclass.in.instanceof=使用接口/超类的实例
use.interface.where.possible.title=在可能处使用接口
use.super.references.prompt=在这个阶段{0}可以分析{1}的用法,并在可能的情况下换成使用{2}.是否要继续?
use.variable.initializer.to.initialize.parameter=使用变量初始值设定项初始化形参(&I)
variable.0.is.changed.before.last.access=变量 ''{0}'' 在上次访问变量 ''{1}'' 前已更改。
variable.does.not.have.an.initializer=变量 {0} 没有初始值设定项。
variable.is.accessed.for.writing=变量 ''{0}'' 被访问以进行写入
variable.is.never.used.before.modification=修改之前从未使用变量{0}
variable.of.type=类型的变量(&T):
would.you.like.to.replace.default.constructor.of.0.with.factory.method=要将默认构造函数 {0} 替换为工厂方法吗?
wrap.return.value.create.inner.class=创建内部类(&I)
wrap.return.value.create.new.class=创建新类(&C)
wrap.return.value.existing.class.name=名称
wrap.return.value.inner.class.name=名称(&M)
wrap.return.value.new.class.name=名称(&N)
wrap.return.value.new.class.package.name=软件包名称(&P)
wrap.return.value.use.existing.class=使用现有类(&U)
wrap.return.value.wrapper.field=包装器字段(&F)

replace.inside.current.lambda=在当前 lambda 内创建变量
replace.as.separate.operation=提取为 ''{0}'' 操作
replace.all.occurrences.changes.semantics=替换所有 {0} 匹配项(将更改语义!)
replace.all.read.and.write=替换读取和写入匹配项 (将更改语义!)
replace.all.and.extract=替换所有 {0} 匹配项并提取为 ''{1}'' 操作
replace.lambda.chain.detected=检测到 lambda 链
replace.occurrences.inside.statement=替换{2, choice, 1#|2#外部} ''{1}'' 块中的 {0} 个匹配项
extract.method.object=提取方法对象
replace.constructor.with.builder=将构造函数替换为构建器
type.migration.error.hint.title=类型迁移

extract.method.dialog.separator.parameters=形参(&P)
extract.method.conflict.parameter=冲突的形参名: {0}
extract.method.conflict.variable=名为 {0} 的变量已在选定范围中定义
extract.method.error.annotation.value=无法从注解值提取方法
extract.method.error.local.class.defined.outside=无法提取方法，因为选定代码段使用在片段之外定义的局部类
extract.method.error.local.class.used.outside=无法提取方法，因为选定代码段定义在片段之外使用的局部类
extract.method.error.local.class.variable.used.outside=无法提取方法，因为选定代码段定义在片段之外使用的局部类类型的变量
extract.method.error.make.static=无法设为 static
extract.method.preview.node.invalid.prefix=无效 
suggest.signature.preview.method.call.prefix=方法调用:
suggest.signature.preview.title.before=之前
suggest.signature.preview.after.title=之后
removing.redundant.imports.progress.title=正在移除冗余导入
introduce.parameter.object.error.class.does.not.exist=''{0}'' 不存在
introduce.parameter.object.error.invalid.qualified.parameter.class.name=''{0}'' 是无效的限定形参类名
introduce.parameter.object.error.invalid.parameter.class.package.name=''{0}'' 是无效的形参类软件包名称
introduce.parameter.object.error.invalid.parameter.class.name=''{0}'' 是无效的形参类名
introduce.parameter.object.error.inner.class.already.exist=名称为 ''{0}'' 的内部类已存在
introduce.parameter.object.error.invalid.inner.class.name=''{0}'' 是无效的内部类名
introduce.parameter.object.error.no.field.associated.found=找不到与 {0} 关联的字段
introduce.parameter.object.error.existing.class.misses.compatible.constructor=现有类中没有兼容的构造函数
introduce.parameter.object.error.created.class.wont.be.accessible=创建的类无法访问
introduce.parameter.object.error.file.already.exits=文件已存在: {0}
replace.constructor.builder.error.identifier.invalid=标识符 ''{0}'' 无效
replace.constructor.builder.optional.setter.table.title=可选 Setter
replace.constructor.builder.default.value.table.title=默认值
replace.constructor.builder.setter.name.table.title=Setter 名称
replace.constructor.builder.field.name.table.title=字段名称
replace.constructor.builder.parameter.table.title=形参
replace.constructor.builder.select.builder.class.chooser.title=选择构建器类
replace.constructor.builder.error.invalid.builder.qualified.class.name=''{0}'' 是无效的构建器限定类名
replace.constructor.builder.error.invalid.builder.package.name=''{0}'' 是无效的构建器软件包名称
replace.constructor.builder.error.invalid.builder.class.name=''{0}'' 是无效的构建器类名
replace.constructor.builder.error.invalid.setter.name=''{0}'' 不是有效的 setter 名称
replace.constructor.builder.error.invalid.field.name=''{0}'' 不是有效的字段名
replace.constructor.builder.error.no.constructors=当前类没有要替换为构建器的构造函数。
replace.constructor.builder.error.caret.position=文本光标应置于构造函数要替换为构建器的类中。
replace.constructor.builder.error.no.constructor.chain=找到的构造函数无法缩减为简单链
replace.constructor.builder.error.class.with.chosen.name.already.exist=具有所选名称的类已存在。
replace.constructor.builder.error.selected.class.was.not.found=未找到选定类。
replace.constructor.factory.error.invalid.factory.method.name=''{0}'' 不是有效的工厂方法名称
replace.constructor.factory.error.factory.method.already.exists=工厂方法 {0} 已存在，将用于替代新创建的工厂方法。
java.safe.delete.empty.callee.text=将在此处显示被调用方文本
java.safe.delete.caller.text=将在此处显示将被调用方高亮显示的调用方文本
# {0} = method; {1} = class; {2} = protected/package-private/private
push.up.super.class.signature.conflict=超类中的 {0} 与 {1} 中的方法 {2} 冲突
push.up.abstract.accessibility.in.subclass.conflict={0} 使用无法通过子类访问的 {1}。
push.up.abstract.accessible.from.the.subclass.conflict=无法将 {0} 设为抽象，因为无法通过子类对其进行访问。
push.down.unrelated.defaults.conflict={0} 将从 {1} 和 {2} 继承不相关的默认值
move.member.write.access.in.interface.conflict={0} 具有写入权限，但会移动至接口
refactor.only.current.method.choice=仅重构当前方法
refactor.base.method.choice=重构基{0, choice, 0#方法|1#方法}
automatic.parameter.renamer.entity.name=形参
automatic.overload.renamer.entity.name=重载
extract.method.checkbox.annotate=注解
extract.method.checkbox.make.static=设为 static
extract.method.checkbox.make.static.and.pass.fields=设为 static 并传递字段
extract.method.link.label.more.options=更多选项
dialog.message.field.doesnt.have.initializer=字段 {0} 没有初始值设定项
dialog.message.replace.duplicates.works.with.constants.only=替换重复项仅适用于常量
dialog.message.caret.should.be.inside.method.or.constant=文本光标应位于方法或常量内部
inline.object.command.name=内联对象
local.to.field.popup.title.choose.class.to.introduce.constant=选择要引入常量的类
local.to.field.popup.title.choose.class.to.introduce.field=选择要引入字段的类
extract.method.gotit.signature.header=更改方法签名
extract.method.gotit.signature.message=<html><p style=''margin-bottom:3px;''>1. 编辑签名</p><p style=''margin-bottom:3px;''>2. 更新用法: 点击间距中的图标或按 {0}</p><p><font color=gray>要对形参重新排序，请使用 {1} 或 {2}。</font></p></html>
extract.method.gotit.navigation.header=想要更改方法签名?
extract.method.gotit.navigation.message=转到方法声明执行操作: <br/>{0}方法名称或按 {1}。
introduce.variable.no.matching.occurrences=无匹配项
inline.super.no.inheritors.warning.message=无法内联没有继承者的类
inline.superclass.foreign.language.conflict.message=无法内联到 {0}
field.0.won.t.be.initialized.already.in.class.initializer=字段 ''{0}'' 不会在类初始值设定项内部初始化
replace.constructor.with.builder.text=将构造函数替换为构建器
rename.inheritors.with.the.following.names.to.title=将具有以下名称的继承者重命名为:
title.rename.variables.with.the.following.names.to=将具有以下名称的变量重命名为:
dialog.title.analyze.code.fragment.to.extract=分析代码以提取…
dialog.message.overriding.methods.with.weaken.visibility=要同时将重写方法的可见性降低到 ''{0}''?
edit.migration.map.title.new=新建迁移映射
edit.migration.map.title.existing=编辑迁移映射
edit.migration.map.ok.button=保存
migration.dialog.alert.name=删除迁移映射
migration.dialog.alert.text=删除 ''{0}'' 迁移?
migration.dialog.alert.delete=删除
migration.dialog.link.delete=删除
migration.dialog.link.duplicate=复制并编辑…
migration.dialog.link.edit=编辑…
migration.dialog.scope.label=范围:
migration.dialog.scope.whole.project=整个项目
migration.edit.duplicated.migration.name={0} 副本
migration.edit.existing.name=已经存在同名的迁移。
migration.edit.empty.name=迁移名称不能为空。
migration.edit.empty.table=迁移表不能为空。
migration.edit.copy.existing=复制现有
move.label.text=移动:
dialog.title.move.directory.to.source.root=将目录移至源根
copy.handler.is.dumb.during.indexing=在编制索引过程中复制类将导致只是复制包含的文件。您必须手动更改软件包和 import。仍要继续吗?
move.class.to.inner.find.target.class.progress=正在查找目标类…
changeSignature.validating.title=正在验证…
changeSignature.processing.changes.title=正在处理变更…
convert.to.record.field.more.accessible={0} 是 {1}。\n\
创建特定 {2} 记录访问器将使该字段更易于访问。
convert.to.record.accessor.more.accessible={0} 是 {1}。\n\
将方法转换为 {2} 记录访问器将使其更易于访问。
convert.to.record.ctor.more.accessible={0} 是 {1}。\n\
将其转换为 {2} 记录规范构造函数将使实例创建更易于访问。
0.already.contains.field.1={0} 已包含字段 {1}
0.already.contains.inner.class.named.1={0} 已包含名为 {1} 的内部类
0.already.has.parameter.named.1.use.this.name.anyway={0}已经有名为 ''{1}'' 的形参。\n仍然使用此名称?
0.contains.call.with.null.argument.for.parameter.1={0} 包含带有形参 {1} 的 null 实参的调用
0.implements.1={0}实现{1}。
0.is.1.and.will.not.be.accessible.from.2.in.the.target.class={0} 为 {1}，将无法从 {2} 访问。
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.parameters={0} 是方法层次结构的一部分。是否要删除多个形参?
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.type.parameters={0} 是方法层次结构的一部分。是否要删除多个类型形参?
0.is.an.interface.method.implementation.will.be.added.to.all.directly.implementing.classes={0} 是一个接口。\n方法实现将被添加到所有直接实现类。\n继续?
0.is.an.interface.that.has.no.implementing.classes={0} 是一个没有实现类的接口
0.is.not.a.legal.java.identifier=''{0}''不是合法的java标识符
0.is.not.accessible.from.1.value.for.introduced.parameter.in.that.method.call.will.be.incorrect={0}不可以从{1}访问。该方法调用中引入形参的值将不正确。
0.is.not.initialized.in.declaration.such.fields.are.not.allowed.in.interfaces={0}在声明处未初始化。在接口中不允许这样的字段。
0.is.not.static.it.cannot.be.moved.to.the.interface={0}不是静态的.不能将它移至该接口
0.is.not.visible.to.members.of.1={0} 对 {1} 的成员不可见
0.is.used.for.writing.in.1={0}是用来写在{1}
0.refactoring.is.supported.only.for.final.fields=仅 final 字段支持{0}重构
0.upcasts.an.instance.of.1.to.2={0} 将 {1} 的实例向上转换为 {2}。
0.uses.1.of.an.instance.of.a.2={0} 使用 {2} 的一个实例的 {1}
0.uses.1.which.needs.class.instance={0} 使用 {1}，这需要类实例
0.uses.a.package.local.1={0}使用 package-private {1}
0.uses.non.static.1.which.is.not.passed.as.a.parameter={0}使用非 static {1}，后者不作为形参传递
0.will.be.inaccessible.from.1={0}将无法从{1}
0.will.become.inaccessible.from.1={0}将变得无法从 {1} 访问
0.will.hide.renamed.1={0}将隐藏更名为{1}
0.will.no.longer.be.canonical.constructor=将不再是规范构造函数
0.will.no.longer.be.record.component.accessor={0} 将不再是 {1} getter
0.will.no.longer.override.1={0}将不再重写{1}
0.will.not.be.accessible.from.1.after.inlining={0}不可以从{1}在内联
0.will.override.renamed.1={0}将覆盖更名为{1}
a.package.local.class.0.will.no.longer.be.accessible.from.1=Package-local 类 {0} 将不再可以从{1}访问
accept.signature.change=接受签名更改
add.object.as.a.parameter.to.constructors.with.name=将对象作为形参添加到具有以下名称的构造函数(&O)\:
add.parameters.for.fields=添加字段形参(&F)\:
add.parameters.for.fields.to.constructors=向构造函数添加字段形参(&F)\:
all.candidate.variables.have.types.not.in.project=所有候选变量(方法形参和所包含的类字段)的类型都不在项目中
all.candidate.variables.have.unknown.types=所有候选变量(方法形参和所包含的类字段)都具有未知类型
all.invocations.and.remove.the.method=内联所有用法并移除方法(&A)
all.invocations.in.project=内联项目中的所有用法(&A)
all.invocations.keep.the.method=内联所有用法并保留方法(&E)
all.references.and.remove.super.class=内联所有引用并移除类(&A)
all.references.and.remove.the.class=内联所有引用并移除类(&A)
all.references.and.remove.the.field=内联所有引用并移除字段 (&A)
all.references.keep.field=内联所有引用并保留字段(&E)
all.these.directories.will.be.moved.and.all.references.to.0.will.be.changed=所有这些目录将被移动，并且所有对 {0} 的引用将被更改。
analyze.and.replace.usages=分析和替换用法
analyze.module.conflicts=分析模块冲突…
annotate.field.as.nonnls.checkbox=注释字段作为 @NonNls (&F)
anonymous.class.description=派生自 {0} 的匿名类
anonymous.class.text=匿名类
anonymous.to.inner.enum.constant.cannot.refactor.message=枚举常量无法转换为内部类
anonymousToInner.class.name.label.text=类名\:
anonymousToInner.make.class.static.checkbox.text=将类设为 static(&S)
anonymousToInner.no.inner.class.name=需指定类名
anonymousToInner.parameters.panel.border.title=构造函数的形参
anonymousToInner.refactoring.name=转换匿名为内部
auto.rename.module.dialog.description=将具有以下名称的 Java 模块重命名为\:
auto.rename.module.dialog.title=重命名 Java 模块
auto.rename.module.entity=Java 模块
automatic.overload.renamer.entity.name=重载
automatic.parameter.renamer.entity.name=形参
boolean.method.result=布尔方法的结果
can.t.restore.context.for.method.extraction=无法为方法提取还原上下文
cannot.find.or.create.destination.directory=找不到或创建目标目录
cannot.introduce.field.in.interface=接口中不允许使用非常量字段
cannot.move=无法移动
cannot.move.inner.class.0.into.itself=不能将内部类 {0} 移至自身
cannot.move.package.into.itself=无法将软件包移至其自身
caret.position.warning.message=文本光标应置于要重构的字段、变量、方法或方法形参类型上
change.method.signature.action.name=更改方法签名
change.signature.default.value.missing.warning.message=缺少默认值。方法调用将包含空值，而不是新的形参值。
change.signature.use.any.checkbox=使用任意变量(&U)
changeClassSignature.Type.parameter.can.not.be.primitive=类型形参不能为基元
changeClassSignature.already.contains.type.parameter=''{0}'' 已包含类型形参 ''{1}''
changeClassSignature.bad.value=错误 {0} 值\: ''{1}'' 形参 ''{2}''
changeClassSignature.class.label.text=更改 <code>{0}</code> 的签名。
changeClassSignature.no.type.parameters=这个类不能有类型形参
changeClassSignature.parameters.panel.border.title=参数：
changeClassSignature.refactoring.name=更改类签名
changeSignature.bound.value.column=绑定值
changeSignature.cannot.resolve.return.type=无法解析返回值类型''{0}''。\n是否继续?
changeSignature.contract.converter.can.not.update.annotation=@Contract 注解无法自动更新\: {0}
changeSignature.contract.converter.definition.error=约定定义出错\: {0}
changeSignature.contract.converter.external.annotations=不支持外部注解的自动更新
changeSignature.contract.converter.inherited.annotation=注解继承自基方法
changeSignature.contract.converter.invalid.clause=约定子句 ''{0}'' 无效
changeSignature.contract.converter.invalid.return.reference=返回值中的引用无效\: {0}
changeSignature.contract.converter.mutation.contract=注解包含变异协定
changeSignature.contract.converter.parameter.removed=形参 ''{0}'' 已删除，但是约定子句 ''{1}'' 依赖于此
changeSignature.contract.converter.return.parameter.removed=形参 ''{0}'' 已删除，但是约定子句 ''{1}'' 将其返回
changeSignature.default.value.column=默认值
changeSignature.empty.callee.method.text=此处将显示被调用方方法文本
changeSignature.empty.caller.method.text=此处将显示高亮显示被调用方调用的调用方方法文本
changeSignature.exception.caller.chooser=选择要传递新异常的方法
changeSignature.exceptions.panel.border.title=异常
changeSignature.exceptions.wont.propagate=递归传播的异常的更改不会被执行
changeSignature.no.return.type=未指定返回值类型
changeSignature.no.type.for.exception=指定一个类型给异常
changeSignature.no.type.for.parameter=指定形参 ''{1}'' 的 {0} 类型
changeSignature.not.throwable.type=错误的异常类型 ''{0}''，应扩展 java.lang.Throwable
changeSignature.processing.changes.title=正在处理更改…
changeSignature.propagate.exceptions.title=传播异常(&X)…
changeSignature.use.any.var=使用任意变量。
changeSignature.validating.title=正在验证…
changeSignature.vararg.not.last=vararg 形参应当为方法签名中的最后一个形参
changeSignature.wrong.return.type=错误的返回值类型\:''{0}''
changeSignature.wrong.type.for.exception=类型错误\: 异常的 ''{0}''
changeSignature.wrong.type.for.parameter=类型错误\: 形参 ''{1}'' 的 ''{0}''
checking.conflicts=正在检查冲突…
class.0.already.exists=类{0}已存在
class.0.is.not.accessible.from.target.1=类{0}是不可以从目标{1}
class.0.not.found=找不到类 {0}。
class.body.description={0} 的类主体
class.description={1, choice, 0\#|1\#局部}类 {0}
class.does.not.exist.in.the.project=模块中不存在类。是否要创建?
class.does.not.have.base.classes.or.interfaces=类 {0} 没有基类或基接口
class.does.not.have.implicit.default.constructor=类 {0} 没有隐式默认构造函数
class.has.been.successfully.created=已成功创建类 {0}。
class.initializer.description={0, choice, 0\#static |1\#实例}初始值设定项
class.is.abstract={0}为 abstract。
class.is.anonymous.warning.message=无法执行重构，因为匿名类不能有子类
class.is.final.warning.message=无法执行重构，因为该类为 final
class.is.interface={0}是一个接口。
class.is.never.used=类从未使用
class.name.prompt=类名(&N)\:
collect.overloads=收集重载…
comments.elements.header=在注释、字符串和非代码文件 {0} 中发现匹配项
constructor.being.refactored.is.used.in.initializer.of.0=正在重构的构造函数在 {0} 的初始值设定项中使用。内部类 {1} 的非 static 工厂无法在此上下文中使用。生成的代码将不会编译。
constructor.description=构造函数{0}
constructor.with.builder.new.setter.prefix.dialog.message=新的 setter 前缀\:
constructor.with.builder.parameters.to.pass.to.the.builder.title=要传递到构建器的形参
constructor.with.builder.rename.setters.prefix.action.name=重命名 Setter 前缀
convert.anonymous.or.local.to.inner.fix.name=将匿名类或局部类转换为内部类
convert.anonymous.to.inner.action.name=将匿名转换成内部…
convert.anonymous.to.inner.fix.name=将匿名转换成内部类
convert.local.to.field.title=将局部转换为字段
convert.local.to.inner.action.name=将局部转换为内部…
convert.local.to.inner.fix.name=将局部类转换为内部类
convert.to.instance.method.title=转换为实例方法
convert.to.record.accessor.more.accessible={0} 为 {1}。转换为记录将使相应的隐式访问器方法{2}。
convert.to.record.ctor.more.accessible={0} 为 {1}。转换为记录会将相应的隐式规范记录构造函数设为 {2}。
convert.to.record.title=转换为记录类
convertToInstanceMethod.all.reference.type.parameters.are.not.in.project=找不到实例方法的目标类\: 找不到引用项目中类的类型的方法形参。
convertToInstanceMethod.all.reference.type.parameters.have.unknown.types=找不到实例方法的目标类\: 方法形参类型未知。
convertToInstanceMethod.method.is.not.static=方法 {0} 不为 static
convertToInstanceMethod.no.default.ctor=此外，包含类没有默认构造函数。
convertToInstanceMethod.no.parameters.with.reference.type=不存在具有引用类型的形参。
copy.class.clone.0.1=克隆{0}{1}
copy.class.copy.0.1=复制{0}{1}
copy.handler.clone.class=克隆类
copy.handler.copy.class=复制类
copy.handler.copy.class.with.dialog=复制类…
copy.handler.copy.classes.with.dialog=复制类…
current.class=当前类
dataflow.to.here.expand.progress=正在展开所有节点… {0}
dataflow.to.here.group.by.leaf.action.description=确定 null 是否可以流入此表达式
dataflow.to.here.group.by.leaf.action.text=按叶表达式为 null 性分组{0, choice, 1\#|2\# (正在分析)}
dataflow.to.here.variable.dereferenced.tooltip=已解引用变量
declare.final=声明 final(&F)
declare.generated.annotations=生成注解(&G)
declare.static.checkbox=声明 static(&S)
declare.static.pass.fields.checkbox=声明 static (作为形参传递字段)(&S)
declare.var.type=声明变量类型(&V)
declare.varargs.checkbox=声明 vararg(&A)
default.visibility.border.title=缺省可见
delete.variable.declaration=删除变量声明 (&D)
destination.directory.does.not.correspond.to.any.package=目标目录不对应于任何软件包
destination.package=目标软件包(&P)\:
dialog.message.0.would.hide.which.1.used.by.moved.2={0}将隐藏被移动的{2}使用的{1}。
dialog.message.caret.should.be.inside.method.or.constant=文本光标应位于方法或常量内部
dialog.message.confirmation.to.process.only.implementation=找到 abstract 方法的实现\:<br><br><b>{0}</b><br><br>是否要内联此实现?
dialog.message.enum.constant.0.won.t.be.compilable.in.1=移动到{1}后{0}将无法编译。
dialog.message.field.doesnt.have.initializer=字段 {0} 没有初始值设定项
dialog.message.moving.directories.to=将目录移至 ''{0}''
dialog.message.non.constant.will.not.be.compilable.in.interface=移动到接口后，非常量{0}将无法编译。
dialog.message.overriding.methods.with.weaken.visibility=是否还要将重写方法的可见性降低到 ''{0}''?
dialog.message.replace.duplicates.works.with.constants.only=替换重复项仅适用于常量
dialog.message.static.class.initializers.are.not.allowed.in.interfaces=接口中不允许使用 static 类初始值设定项。
dialog.title.analyze.code.fragment.to.extract=分析代码以提取…
dialog.title.confirm.move=确认移动
dialog.title.move.directory.to.source.root=将目录移至源根
dialog.title.resolving.method.implementation=正在解析方法实现
different.name.expected=应为不同名称
directory.0.already.contains.1.named.2=目录 {0}\n已经包含一个名为 ''{2}'' 的{1}
directory.0.already.contains.a.file.named.1=目录 {0}\n已经包含一个名为 ''{1}'' 的文件
do.not.replace=不要替换 (&N)
do.not.show.this.message.in.the.future=以后不再显示此消息 (&D)
do.you.want.to.process.overriding.methods.with.covariant.return.type=是否要使用协变返回值类型处理重写方法?
edit.migration.entry.title=编辑类/软件包迁移规则
edit.migration.map.ok.button=保存
edit.migration.map.title.existing=编辑迁移映射
edit.migration.map.title.new=新建迁移映射
element.will.no.longer.be.accessible={0}将不再可以从{1}
encapsulate.fields..encapsulated.fields.visibility.border.title=封装字段的可见性
encapsulate.fields..package.local.radio=Package local(&C)
encapsulate.fields.accessors.visibility.border.title=访问器可见性
encapsulate.fields.command.name=封装字段在{0}
encapsulate.fields.encapsulate.border.title=封装
encapsulate.fields.existed.accessor.hidden={0} 已经存在，将被生成的访问器隐藏
encapsulate.fields.existed.accessor.hides.generated={0} 已经存在，将为 {1} 隐藏生成的访问器
encapsulate.fields.expression.type.is.used=使用结果类型时，无法继续使用后缀/前缀表达式
encapsulate.fields.field.column.name=字段
encapsulate.fields.fields.to.be.encapsulated=字段封装
encapsulate.fields.fields.to.encapsulate.border.title=字段来封装
encapsulate.fields.get.access.checkbox=获取访问权限 (&G)
encapsulate.fields.getter.column.name=Getter
encapsulate.fields.getter.exists=已经存在方法 {0}，它与 getter {1} 仅在返回值类型上不同
encapsulate.fields.no.target=未找到要封装的内容
encapsulate.fields.nothing.todo.warning.message=类具有要封装的字段
encapsulate.fields.private.radio=私有(&I)
encapsulate.fields.protected.radio=protected(&T)
encapsulate.fields.refactoring.cannot.be.applied.to.interface=封装字段重构不能应用到接口
encapsulate.fields.set.access.checkbox=设置访问权限 (&S)
encapsulate.fields.setter.column.name=Setter
encapsulate.fields.setter.exists=已经存在方法 {0}，它与 setter {1} 仅在返回值类型上不同
encapsulate.fields.title=封装字段
encapsulate.fields.use.accessors.even.when.field.is.accessible.checkbox=使用访问器即使字段是可访问的
entity.name.accessor=访问器
entity.name.constructor.parameter=形参
entity.name.inheritor=继承者
entity.name.test=测试
entity.name.variable=变量
enum.constant.description=枚举常量{0}
enum.description={1, choice, 0\#|1\#局部}枚举{0}
error.cannot.resolve=无法解析 {0}
error.incorrect.data=不正确的数据
error.not.supported.for.jsp={0}重构不支持JSP
error.not.supported.for.local=扩展局部类的类无法转换为内部类
error.not.supported.for.package.info={0}重构不支持 package-info.java
error.wrong.caret.position.anonymous=文本光标应置于要重构的匿名类或局部内部
error.wrong.caret.position.constructor=文本光标应置于要重构的构造函数内
error.wrong.caret.position.local.or.expression.name=文本光标应置于要重构的局部变量或表达式的名称处
error.wrong.caret.position.method=文本光标应置于要重构的方法内
error.wrong.name.input=错误的名称\:{0}
expand.method.reference.warning=方法用于一个或多个方法引用。继续会将这些方法引用转换为 lambda 表达式。
expression.result=表达式结果
extract.chained.constructor.checkbox=提取链接构造函数 (&C)
extract.delegate.as.enum.checkbox=提取为枚举
extract.delegate.create.nested.checkbox=创建嵌套类
extract.delegate.generate.accessors.checkbox=生成访问器(&G)
extract.delegate.unable.create.warning.message=无法创建包含给定名称的类
extract.method.checkbox.annotate=注解
extract.method.checkbox.make.static=设为 static
extract.method.checkbox.make.static.and.pass.fields=设为 static 并传递字段
extract.method.conflict.parameter=冲突的形参名\: {0}
extract.method.conflict.variable=名为 {0} 的变量已在选定作用域中定义
extract.method.control.flow.analysis.failed=代码包含语法错误。无法执行必要的分析。
extract.method.dialog.separator.parameters=形参(&P)
extract.method.error.annotation.value=无法从注解值提取方法
extract.method.error.class.not.found=所选块应当是 java 类的一部分。
extract.method.error.class.outside.defined=局部类在所选块之外定义。
extract.method.error.class.outside.used=局部类在所选块之外使用。
extract.method.error.exception=当抛出异常时，其行为会有所不同。
extract.method.error.local.class.defined.outside=无法提取方法，因为选定代码段使用在片段之外定义的局部类
extract.method.error.local.class.used.outside=无法提取方法，因为选定代码段定义在片段之外使用的局部类
extract.method.error.local.class.variable.used.outside=无法提取方法，因为选定代码段定义在片段之外使用的局部类类型的变量
extract.method.error.make.static=无法设为 static
extract.method.error.many.exits=有多个出口点。
extract.method.error.many.finals=存在对 final 字段的赋值。
extract.method.error.many.outputs=有多个变量要返回。
extract.method.error.method.conflict=具有相同签名的方法已存在
extract.method.error.prefix=无法提取方法。
extract.method.error.variable.in.expression=所选表达式内有一个要返回的变量。
extract.method.error.wrap.many.outputs=所选代码块中有多个输出变量。\n如果我们将它们折叠到 {0} 中，即可提取该方法。
extract.method.error.wrap.many.outputs.class=单个对象
extract.method.error.wrap.many.outputs.record=新记录
extract.method.link.label.more.options=更多选项
extract.method.object=提取方法对象
extract.method.object.anonymous.make.varargs.option=设为 vararg(&V)
extract.method.object.class.name=类名(&C)\:
extract.method.object.create.anonymous.class=创建匿名类(&A)
extract.method.object.create.inner.class=创建内部类(&I)
extract.method.object.inner.class.visibility=可见性\:
extract.method.object.inner.make.static.option=设为 static(&S)
extract.method.object.inner.make.varargs.option=设为 vararg(&V)
extract.method.object.inner.visibility.package.local=package local(&K)
extract.method.object.inner.visibility.private=private(&V)
extract.method.object.inner.visibility.protected=protected(&O)
extract.method.object.inner.visibility.public=public(&B)
extract.method.object.method.name=方法名称(&M)\:
extract.method.object.parameters=形参
extract.method.object.signature.preview=签名预览
extract.method.object.suggestion=是否要提取方法对象?
extract.method.preview.node.invalid.prefix=无效 
extract.method.progress.replace.duplicates=正在替换重复项
extract.method.progress.search.duplicates=搜索重复项
extract.parameters.to.replace.duplicates=提取形参以替换重复项
extract.subclass.command=提取子类
extractSuper.rename.original.class.to=重命名原始类到\: (&R)
extractSuperInterface.javadoc=JavaDoc
factory.method.name.label=工厂方法名称\:
failed.to.re.run.refactoring=无法重新运行重构
field.0.is.already.defined.in.the.1=字段 {0} 已经在 {1} 中定义
field.0.is.never.used=字段{0}从未使用过
field.0.is.not.accessible=字段{0}是不可以从{1}
field.0.will.hide.field.1.of.the.base.class=字段 {0} 将隐藏基{2}的字段 {1}
field.0.won.t.be.initialized.already.in.class.initializer=字段 ''{0}'' 不会在类初始值设定项内部初始化
field.declaration.radio=字段声明 (&D)
field.description=字段{0}
field.name=字段名称 (&F)\:
fields.to.be.refactored.should.belong.to.the.same.class=重构的字段应该属于同一个类
functional.interface.broken=函数表达式要求功能界面准确的一种方法
generate.getter.for.delegated.component=为委派成员生成getter (&G)
generate.module.descriptors.analysing.message=正在分析依赖关系
generate.module.descriptors.build.required.message=无法生成模块描述符，因为该项目尚未构建
generate.module.descriptors.collecting.message=正在收集依赖关系
generate.module.descriptors.command.title=生成 module-info 描述符
generate.module.descriptors.io.exceptions.message=读取模块 {0} 文件时出现问题
generate.module.descriptors.no.suitable.modules.message=未找到可能包含模块信息的模块
generate.module.descriptors.preparing.message=正在准备代码
generate.module.descriptors.rebuild.message=为了提高依赖关系计算的准确性，需要构建该项目。\n在生成模块信息描述符之前开始构建?
generate.module.descriptors.scanning.message=正在扫描编译器输出
generate.module.descriptors.title=生成模块描述符
getter.and.setter.methods.found.for.the.field.0=发现字段 {0} 的 getter和setter方法。是否将它们一起 {1}?
getter.method.found.for.the.field.0=发现字段 {0} 的 getter 方法。 是否将 getter 一起{1}?
idea.has.not.found.any.code.that.can.be.replaced.with.method.call={0}没有发现任何副本
ignore.button=忽略
implicit.last.parameter.warning=隐式最后一个形参不应删除
infer.class.type.args.warning=无法推断类类型实参。继续时，将创建原始 {0}
information.title=信息
initializer.for.variable.cannot.be.a.constant.initializer=变量的 {0} 初始值设定项不能是常量初始值设定项
inline.action.name=内联
inline.anonymous.conflict.progress=正在搜索类“{0}”继承者…
inline.class.elements.header=类内联
inline.conflicts.progress=检查是否可以内联…
inline.constant.field.not.supported.for.enum.constants=枚举常量不支持 {0}
inline.element.unknown.header=未知元素
inline.field.action.name=内联字段…
inline.field.command=内联字段 {0}
inline.field.elements.header=场内联
inline.field.field.name.label=内联字段 ''{0}''\:
inline.field.field.occurrences=内联具有 {1} 个{1, choice, 1\#用法|2\#用法}的字段 ''{0}''\:
inline.field.initializer.is.not.accessible=字段初始值设定项引用无法在 {1} 中访问的 {0}
inline.field.title=内联领域
inline.field.used.in.javadoc=已内联字段用于 javadoc
inline.field.used.in.reflection=已内联字段以反射形式使用
inline.local.unable.try.catch.warning.message=无法在 try/catch 语句外内联
inline.local.used.as.resource.cannot.refactor.message=变量用作资源引用
inline.local.variable.declared.outside.cannot.refactor.message=变量在代码块外声明
inline.method.calls.not.accessible.in=已内联方法调用将不会在 {1} 中访问的 {0}
inline.method.calls.not.accessible.on.qualifier=已内联方法调用在限定符 {1} 上将无法访问的 {0}
inline.method.checking.tail.calls.progress=检查尾调用用法
inline.method.elements.header=方法内联
inline.method.method.label=内联方法 ''{0}''\:
inline.method.method.occurrences=内联具有 {1} 个{1, choice, 1\#用法|2\#用法}的方法 ''{0}''\:
inline.method.multiline.method.in.ctor.call=内联不能在构造函数调用中应用于多行方法
inline.method.multiline.method.in.loop.condition=内联不能在循环条件中应用于多行方法
inline.method.object.action.name=内联对象
inline.method.object.suggestion.message=是否要内联对象和后续调用?
inline.method.qualifier.usage.side.effect=已内联方法用于方法引用，限定符具有副作用
inline.method.used.in.javadoc=已内联方法用于 javadoc
inline.method.used.in.reflection=已内联方法以反射形式使用
inline.object.command.name=内联对象
inline.parameter.action.name=内联形参…
inline.parameter.cannot.find.initializer.warning.message=无法为形参找到常量初始值设定项
inline.parameter.confirmation=将形参 ''{0}'' 与初始值设定项 ''{1}'' 内联?
inline.parameter.dependency.unavailable.in.parameter.method=形参初始值设定项依赖 {0}，后者在形参的方法中无法访问
inline.parameter.depends.on.caller.parameter=形参初始值设定项取决于调用方的 {0}
inline.parameter.depends.on.non.static=形参初始值设定项依赖于非 static {0}，并且形参的方法内没有可用实例
inline.parameter.depends.on.non.static.class=形参初始值设定项依赖于非 static {0}，后者在形参的方法内部无法访问
inline.parameter.error.hierarchy=内联形参不支持当方法是一个继承层次结构的一部分
inline.parameter.error.non.project.method=非项目方法不支持内联
inline.parameter.error.varargs=不支持内联 vararg 形参
inline.parameter.initializer.depends.on.inaccessible.value=无法内联对形参初始值设定项的写入权限
inline.parameter.method.usages.progress=正在搜索方法用法
inline.parameter.no.usages.warning.message=方法没有用法
inline.parameter.not.accessible.warning.message=在方法体内无法访问常量初始值设定项
inline.parameter.refactoring=内联形参
inline.parameter.replace.with.local.checkbox=替换为局部变量(e)\r (&E)
inline.parameter.write.usages.warning.message=不支持具有写入用法的内联形参
inline.pattern.variable.title=内联模式变量
inline.popup.highlight=高亮显示 {0} 个冲突的{0, choice, 1\#写入|2\#写入}
inline.popup.ignore.conflicts=忽略写入并继续
inline.super.class=内联超类
inline.super.class.action.name=内联超类…
inline.super.class.label=类{0}
inline.super.ctor.can.be.replaced=构造函数 {0} 可被替换为 {1} 的任意一个
inline.super.doc.panel.title=已内联成员的 JavaDoc
inline.super.expr.can.be.replaced={0} 可被替换为 {1} 的任意一个
inline.super.no.anonymous.class=无法内联到匿名类中。
inline.super.no.ctor=找不到构造函数匹配的 super
inline.super.no.inheritors.warning.message=无法内联没有继承者的类
inline.super.no.inner.class=无法内联到内部类中。将 ''{0}'' 移至上一级别
inline.super.no.return.in.super.ctor=当 return 语句中断超级构造函数的执行流时，不支持重构
inline.super.no.substitution=找不到 {0} 的一致替换。应为 ''{1}''，但找到的为 ''{2}''。
inline.super.non.project.class.warning.message=无法内联非项目类
inline.super.static.import.can.be.replaced=static import 可被替换为 {0} 的任意一个
inline.super.target.instead.of.super.class=目标类型的实例被传递到期望超类的位置。
inline.super.type.element.can.be.replaced={0} 可被替换为 {1} 的任意一个
inline.super.type.params.differ=类型形参在 {0} 中不一致。应为 {1}，但找到的为 {2}
inline.super.unknown.type=类型未知
inline.superclass.foreign.language.conflict.message=无法内联到 {0}
inline.to.anonymous.border.title=内联
inline.to.anonymous.command.name=内联类{0}
inline.to.anonymous.name.label=类 {0}
inline.to.anonymous.no.abstract=抽象类不能被内联
inline.to.anonymous.no.ctor.calls=类无法内联，因为它调用了自己的构造函数
inline.to.anonymous.no.get.class.calls=getClass() 调用的结果将被更改
inline.to.anonymous.no.method.calls=类无法内联，因为它在另一个实例上访问自己的成员
inline.to.anonymous.no.multiple.interfaces=实现多个接口的类不能被内联
inline.to.anonymous.no.superclass.and.interface=有超类和实现了接口的类不能被内联
inline.to.anonymous.refactoring=内联到匿名类
inline.vars.elements.header=变量以内联
inline.warning.variables.used.in.initializer.are.updated=不安全的内联\: 初始值设定项中使用的变量已更新
inlined.method.implements.method.from.0=内联方法实现方法从{0}
inlined.method.overrides.method.from.0=从{0}内联方法重写方法
inlined.method.will.be.transformed.to.single.return.form=内联方法将转换为单个返回形式
inner.class.0.is.already.defined.in.class.1=内部类 {0} 已在类 {1} 中定义。\n仍然继续?
inner.class.0.is.not.static=内部类 {0} 不为 static。\n仅 static 成员支持{1}重构。
inner.class.exists=名为''{0}''的内部类已经定义在类''{1}''中
inner.class.name=内部类名(&I)\:
instance.initializer.description={0} 的实例初始值设定项
instances.casted.to.java.lang.object=转换为 java.lang.Object 的实例
instances.of.0.upcasted.to.1.were.found=发现了 {0} 的实例被向上转换为 {1}。如果继续，它们将显示在单独的“查找”标签页中。
instances.upcasted.to.java.lang.object.found=找到向上转换为 java.lang.Object 的实例
instances.upcasted.to.object=向上转型实例对象
interface.0.does.not.have.inheritors=接口 {0} 没有继承者
interface.description={1, choice, 0\#|1\#局部}接口 {0}
interface.does.not.have.base.interfaces=接口 {0} 没有基接口
interface.has.been.successfully.created=已成功创建接口 {0}
introduce.constant.enum.cb=提取为枚举常量 (&E)
introduce.constant.field.of.type=常量(static final 字段)的类型(&T)\:
introduce.constant.introduce.to.class=提取到类(完全限定名称)(&C)\:
introduce.constant.move.to.another.class.checkbox=移至另一个类(&M)
introduce.field.field.of.type=类型的字段\: (&T)
introduce.field.static.field.of.type=static 字段的类型(&T)\:
introduce.functional.variable.pass.fields.checkbox=将字段作为形参传递(&F)
introduce.local.variable.to.reassign.title=选择要重新分配的变量
introduce.parameter.command=正在将形参提取到{0}
introduce.parameter.convert.lambda=转换为 lambda (&C)
introduce.parameter.duplicates.progress=搜索方法重复项…
introduce.parameter.elements.header=正在将形参添加到方法
introduce.parameter.object.create.inner.class=创建内部类(&I)
introduce.parameter.object.create.new.class=创建新类(&C)
introduce.parameter.object.error.class.does.not.exist=''{0}'' 不存在
introduce.parameter.object.error.created.class.wont.be.accessible=创建的类无法访问
introduce.parameter.object.error.existing.class.misses.compatible.constructor=现有类中没有兼容的构造函数
introduce.parameter.object.error.file.already.exits=文件已存在\: {0}
introduce.parameter.object.error.inner.class.already.exist=名称为 ''{0}'' 的内部类已存在
introduce.parameter.object.error.invalid.inner.class.name=''{0}'' 是无效的内部类名
introduce.parameter.object.error.invalid.parameter.class.name=''{0}'' 是无效的形参类名
introduce.parameter.object.error.invalid.parameter.class.package.name=''{0}'' 是无效的形参类软件包名称
introduce.parameter.object.error.invalid.qualified.parameter.class.name=''{0}'' 是无效的限定形参类名
introduce.parameter.object.error.no.field.associated.found=找不到与 {0} 关联的字段
introduce.parameter.object.escalate.visibility.option=升级可见性(&E)
introduce.parameter.object.existing.class.name=名称(&N)
introduce.parameter.object.generate.accessors.option=生成访问器(&G)
introduce.parameter.object.inner.class.name=名称(&N)
introduce.parameter.object.new.class.name=名称(&N)
introduce.parameter.object.new.class.package.name=软件包名称(&P)
introduce.parameter.object.use.existing.class=使用现有类(&U)
introduce.parameter.super.method.checkbox=重构 super 方法(&U)
introduce.variable.message.cannot.extract.in.implicit.class=无法在压缩源文件中提取。
introduce.variable.message.cannot.extract.variable.in.interface=无法在接口中提取变量。
introduce.variable.message.change.semantics.warning=提取所选表达式会改变周围表达式的语义。
introduce.variable.message.expression.refers.to.pattern.variable.declared.outside=所选表达式会引用模式变量 ''{0}''，这将超出作用域。
introduce.variable.no.matching.occurrences=无匹配项
introduced.variable.will.conflict.with.0=引入的变量与{0}冲突
introducing.variable.may.break.code.logic=引入变量可能打破代码逻辑。
invalid.expression.context=无效的表达式上下文。
invalid.package.name=无效的软件包名称\: {0}
invalid.target.package.name.specified=指定了无效的目标软件包名称
invert.boolean.foreach=Foreach 形参初始值设定不能反转
invert.boolean.wrong.type=该方法的返回值类型或类型的变量是重构应该是布尔
invocations.to.be.inlined=调用内联{0}
is.modified.in.loop.body={0} 在循环体中被修改
java.safe.delete.caller.text=将在此处显示将被调用方高亮显示的调用方文本
java.safe.delete.empty.callee.text=将在此处显示被调用方文本
javadoc.for.abstracts=JavaDoc的摘要
keep.original.signature=保留原始签名
local.variable.description=局部变量{0}
local.will.be.hidden.renamed.description=重命名的字段将隐藏 {0}
localToInner.refactoring.name=将本地类转换为内部类
locate.caret.inside.a.method=将文本光标定位在成员内
locate.duplicates.action.name=定位重复项
make.0.static=将{0}设为 static
make.method.static.title=将方法设为 static
make.static.command=将 {0} 设为 static
make.static.description.label=将{0} {1}设为 static
make.static.elements.header=要设为 static 的{0}
make.static.method.references.progress=搜索方法引用
make.static.methods.to.propagate.dialog.title=选择要传递 static 的方法
members.to.form.interface.title=要构成接口的成员
members.to.form.superclass.title=要形成超类的成员
method.0.is.overridden.by.1=方法{0}被{1}重写。
method.0.will.hide.method.of.the.base.class=方法将隐藏 super {1} 的 {0}
method.0.will.implement.method.of.the.base.class=方法将实现 super {1} 的 {0}
method.0.will.override.a.method.of.the.base.class=方法将重写 super {1} 的 {0}
method.call.would.be.linked.to.0.after.rename=重命名后将调用不同的 {0}
method.column=方法
method.description=方法 {0}
method.does.not.have.a.body=方法{0}没有方法体。
method.duplicates.found.message=找到 {0, choice, 1\#1 个代码段|2\#{0,number} 个代码段}
method.has.an.empty.body=方法 {0} 具有空体。
method.is.not.a.constructor=方法是不是构造函数。
method.reference.will.be.converted.to.lambda.expression.warning=方法引用将转换为 lambda 表达式
method.with.the.same.erasure=具有同样擦除的方法
migration.class=类
migration.dialog.alert.delete=删除
migration.dialog.alert.name=删除迁移映射
migration.dialog.alert.text=删除 ''{0}'' 迁移?
migration.dialog.link.delete=删除
migration.dialog.link.duplicate=复制和编辑…
migration.dialog.link.edit=编辑…
migration.dialog.ok.button.text=运行
migration.dialog.scope.label=作用域\:
migration.dialog.scope.whole.project=整个项目
migration.dialog.title=软件包和类迁移
migration.edit.copy.existing=复制现有
migration.edit.duplicated.migration.name={0} 副本
migration.edit.empty.name=迁移名称不能为空。
migration.edit.empty.table=迁移表不能为空。
migration.edit.existing.name=已经存在同名的迁移。
migration.entry.class=类
migration.entry.new.name=新名称\:
migration.entry.old.name=旧名称\:
migration.entry.package=软件包
migration.map.description.label=映射描述\:
migration.map.name.prompt=地图的名字\:
migration.new.name.column.header=新名字
migration.no.usages.found.in.the.project=项目中找不到任何用法
migration.old.name.column.header=旧名称
migration.package=软件包
migration.package.with.subpackages=软件包和子软件包
migration.title=迁移
migration.type.column.header=类型
move.class=移动类…
move.class.or.package.build.directories=正在构建目录列表
move.class.refactoring.cannot.be.applied.to.anonymous.classes=移动类重构不能应用于匿名类
move.class.to.inner.command.name=将{0, choice, 1\#类|2\#类} 从 {1} 移至 {2}
move.class.to.inner.find.target.class.progress=正在查找目标类…
move.class.to.inner.move.to.self.error=不允许移动类到自身
move.class.to.inner.nonstatic.error=不允许将类移至非 static 内部类
move.class.to.new.file.or.make.inner.class.preview=将类 ''{0}'' 移动到您选择的软件包中的新文件，或将其转换为现有类的内部类。
move.classes=移动类…
move.classes.and.packages=移动类和软件包…
move.classes.command=正在将 {0} 移到软件包 {1}
move.classes.destination.make.inner=使内部类(&M)
move.classes.destination.package.prompt=到软件包\:
move.classes.destination.to.package=到软件包(&G)
move.classes.invalid.package.name.warning.message=无效的软件包名称
move.classes.or.packages.different.modules.exports.conflict=将 {0} 从模块 {1} 移至模块 {2} 可以隐藏对其的访问
move.classes.or.packages.new.module.exports.conflict=更改软件包 {0} 的 export/opens 语句将授予对同一软件包中其他类型及其成员的访问权限
move.classes.or.packages.title=移动
move.classes.or.packages.unused.exports.action.name=删除未使用的 exports/opens
move.classes.or.packages.unused.exports.command.name=删除未使用的 exports/opens
move.classes.or.packages.unused.exports.notification.title=在模块 {0,choice, 1\#描述符|2\#描述符} 中<br>\n发现未使用的 export/open
move.enum.constant.cb=如果可能，作为枚举常数移动(&E)
move.files.regrouping.command.name=正在重新分组…
move.files.to.new.directory.prompt=到目录\:
move.inner.class.action.name=移动内部类…
move.inner.class.command=移动内部类{0}
move.inner.class.to.another.class=移动内部类{0}到另一个类 (&M)
move.inner.class.to.be.moved=类移动
move.inner.class.to.upper.level=将内部类 {0} 移至上一级
move.inner.class.to.upper.level.action.name=将内部类移至上一级别…
move.inner.class.to.upper.level.or.another.class.preview=将内部类 ''{0}'' 移动到您选择的软件包的顶层或另一个类。
move.inner.class.to.upper.level.preview=将内部类 ''{0}'' 移动到您选择的软件包的顶层。
move.instance.method.delegate.title=移动实例方法…
move.instance.method.elements.header=移动实例方法
move.instance.method.handler.make.method.static=是否要将方法 ''{0}'' 设为 static 并随后移动?
move.label.text=移动\:
move.member.write.access.in.interface.conflict=向 {0} 写入，但接口仅允许包含常量。
move.members.action.name=移动成员…
move.method.enter.a.valid.name.for.parameter=请输入一个有效的形参名称
move.method.is.not.supported.for.0={0} 不支持移动实例方法
move.method.is.not.supported.for.constructors=构造函数不支持 Move 方法
move.method.is.not.supported.for.generic.classes=泛型类不支持 Move 方法
move.method.is.not.supported.for.non.project.methods=非项目方法不支持 Move 方法
move.method.this.parameter.label=为 ''{0}.this'' 形参选择一个名称
move.methods.panel.title=要移至已提取类的方法(&M)
move.methods.used.in.extracted.block.only=仅在提取块中使用的 Move 方法
move.nonstatic.class.from.jsp.not.supported=不支持从 JSP 页面移动非 static 类
move.package.or.directory=移动软件包或目录…
move.package.refactoring.cannot.be.applied.to.default.package=“移动软件包”重构不能用于默认软件包
move.packages.or.directories=移动软件包或目录…
move.single.class.or.package.name.label=移动 {0} {1}
move.specified.classes=移动指定的类
move.specified.packages=移动指定的软件包
move.to.inner.duplicate.inner.class=类{0}已包含一个名为{1}的内部类
moving.local.classes.is.not.supported=不支持移动局部类。
no.class.name.specified=未指定类名
no.exact.method.duplicates.were.found=<html><b>找到了 {0,choice, 0\#0|1\#1|2\#{0}} 个确切的方法{0,choice, 0\#重复项|1\#重复项|2\#重复项}</b>，但如下所示，被更改的方法中还有 {1} 个{1,choice, 1\#重复项|2\#重复项}</html>
no.initializer.present.for.the.field=字段没有初始值设定项
no.parameter.name.specified=未指定形参名称
no.usages.can.be.replaced=没有用途的{0}可以替换用法{1}
occurrences.to.be.migrated=要迁移的匹配项 {0}
ok.button=确定
only.fields.variables.of.methods.of.valid.type.can.be.considered=仅可以考虑有效类型的字段、变量、方法形参或方法。
package.description=软件包 {0}
package.does.not.exist=软件包 {0} 不存在。\n是否要创建?
package.does.not.exist.preview=软件包 {0} 不存在。\n重构稍后将为您创建该软件包。
package.name.prompt=软件包名称(&G)\:
parameter.description=形参 {0}
parameter.initializer.contains.0.but.not.all.calls.to.method.are.in.its.class=形参初始值设定项包含 {0}，但并非对方法的所有调用都位于其类中
parameter.name.prompt=形参名称(&M)\:
parameter.of.type=类型的形参(&T)\:
parameter.type.table.column.title=类型
parameter.used.in.method.body.warning={0} 用于方法体
pass.outer.class.instance.as.parameter=将外部类实例作为形参传递(&U)
pattern.variable.description=模式变量 {0}
please.enter.a.valid.target.package.name=请输入一个有效的目标软件包名称
popup.title.choose.class.to.introduce.constant=选择要引入常量的类
popup.title.choose.class.to.introduce.field=选择要引入字段的类
press.the.do.migrate.button=按搜索结果面板底部的“”迁移按钮，\n使用迁移映射“{0}”进行迁移
preview.usages.to.be.changed=预览要改变的用法 (&P)
process.duplicates.change.signature.promt=要替换所有匹配项，需要更改方法签名。是否继续?
process.duplicates.title=处理重复项
process.methods.duplicates.title=过程方法 {2} 重复({0}/{1})
processing.progress.text=正在处理 {0}
progress.title.collect.hierarchy=收集 ''{0}'' 层次结构
project.files.have.been.changed=已更改项目文件。\n要重新运行重构吗?
push.down.delete.warning.text={0}向下推动成员会导致它们被删除。要继续吗?
push.down.enum.no.constants.warning.text=枚举 {0} 没有要内联到的常量。
push.down.no.inheritors.class.warning.text=类 {0} 没有继承者。
push.down.no.inheritors.final.class.warning.text=final 类 {0} 没有继承者。
push.down.unrelated.defaults.conflict={0} 将从 {1} 和 {2} 继承不相关的默认值
push.up.abstract.accessibility.in.subclass.conflict={0} 使用无法通过子类访问的 {1}。
push.up.abstract.accessible.from.the.subclass.conflict=无法将 {0} 设为抽象，因为无法通过子类对其进行访问。
push.up.super.class.signature.conflict=超类中的 {0} 与 {1} 中的方法 {2} 冲突
re.run.refactoring=重新运行重构
record.component.used.in.method.body.warning=记录组件 ''{0}'' 已使用
record.description={1, choice, 0\#|1\#局部}记录 {0}
refactor.base.method.choice=重构基{0, choice, 0\#方法|1\#方法}
refactor.only.current.method.choice=仅重构当前方法
refactoring.cannot.be.applied.no.sources.attached=“{0}”重构无法应用\: 未附加任何源
refactoring.cannot.be.applied.to.abstract.methods={0} 重构无法内联 abstract 方法
refactoring.cannot.be.applied.to.inline.non.chaining.constructors={0} 重构无法内联非链式构造函数
refactoring.cannot.be.applied.to.native.methods={0} 重构无法内联原生方法
refactoring.extract.method.dialog.duplicates.count={0,choice, 1\#1|2\#{0,number}} 个重复的代码{0,choice, 1\#段|2\#段}可被替换为提取的方法调用
refactoring.extract.method.dialog.duplicates.pending=正在搜索重复项…
refactoring.extract.method.dialog.duplicates.progress=正在搜索重复项
refactoring.extract.method.inner.class.defined=内部类 {0} 已在类 {1} 中定义。
refactoring.extract.method.preview.button.refactor=重构(&R)
refactoring.extract.method.preview.button.rerun=重新运行重构(&E)
refactoring.extract.method.preview.failed=无法提取方法
refactoring.extract.method.preview.group.duplicates=重复的代码段
refactoring.extract.method.preview.group.method=要提取的方法
refactoring.extract.method.preview.group.original=原始代码段
refactoring.extract.method.preview.preparing=正在准备差异
refactoring.extract.method.preview.updating=正在更新差异
refactoring.extract.method.reference.to.change=待更改引用
refactoring.introduce.variable.enum.in.label.message=无法提取 switch 标签中的枚举常量
refactoring.is.not.supported.for.jsp.classes=JSP 类不支持重构
refactoring.is.not.supported.in.the.current.context={0}重构是不支持在当前上下文
references.in.code.to.elements.from.migration.map=在代码中引用来自迁移映射“{0}”{1} 的元素
references.to.0.to.be.replaced.with.references.to.1=对 ''{0}'' 的引用要替换为对 ''{1}''{2} 的引用
remove.parameter.0.no.longer.used=移除不再使用的形参 ''{0}''
removing.redundant.imports.progress.title=正在移除冗余导入
rename.accessors=重命名访问器(&A)
rename.accessors.title=重命名 Getter/Setter
rename.accessors.with.the.following.names.to=将具有以下名称的访问器重命名为\:
rename.constructor.parameters.title=重命名构造函数形参
rename.constructor.parameters.with.the.following.names.to=将具有以下名称的形参重命名为\:
rename.inheritors.with.the.following.names.to.title=将具有以下名称的继承者重命名为\:
rename.module.already.exists=模块 ''{0}'' 已经存在于项目中
rename.module.directory.command=将模块和目录重命名为 ''{0}''
rename.module.directory.title=重命名模块和目录(&A)
rename.overloads=重命名重载 (&O)
rename.overloads.dialog.title=重命名重载
rename.overloads.to.dialog.description=将重载重命名为\:
rename.parameter.in.hierarchy.to.dialog.description=将层次结构中的形参重命名为\:
rename.parameters.dialog.title=重命名形参
rename.test.method=重命名测试方法
rename.test.method.description=将具有以下名称的测试方法重命名为\:
rename.test.method.entity.name=测试方法
rename.test.method.title=重命名测试方法
rename.tests=重命名测试 (&E)
rename.tests.title=重命名测试
rename.tests.with.the.following.names.to=将具有以下名称的测试重命名为\:
rename.variables=重命名变量 (&V)
rename.variables.title=重命名变量
renamed.class.will.hide.0.in.1=重命名类将隐藏{0}在{1}
renaming.method.will.override.final.0=方法将重写 super {1} 的 final {0}
replace.all.and.extract=替换所有 {0} 匹配项并提取为 ''{1}'' 操作
replace.all.fields=替换所有字段 (&R)
replace.all.occurrences.changes.semantics=替换所有 {0} 匹配项(将更改语义\!)
replace.all.occurrences.of.expression.0.occurrences=替换所有匹配项({0})(&A)
replace.all.read.and.write=替换读取和写入匹配项 (将更改语义\!)
replace.as.separate.operation=提取为 ''{0}'' 操作
replace.constructor.0.with.a.factory.method=将构造函数 {0} 替换为工厂方法
replace.constructor.builder.create.new=创建新的(&C)
replace.constructor.builder.default.value.table.title=默认值
replace.constructor.builder.error.builder.class.cannot.be.the.same=类 {0} 不能是其自己的构建器类。
replace.constructor.builder.error.caret.position=文本光标应置于构造函数要替换为构建器的类中。
replace.constructor.builder.error.class.with.chosen.name.already.exist=类 {0} 在软件包 {1} 中已存在。
replace.constructor.builder.error.identifier.invalid=标识符 ''{0}'' 无效
replace.constructor.builder.error.invalid.builder.class.name=''{0}'' 不是有效的类名
replace.constructor.builder.error.invalid.builder.package.name=''{0}'' 不是有效的软件包名称
replace.constructor.builder.error.invalid.builder.qualified.class.name=''{0}'' 不是有效的完全限定类名
replace.constructor.builder.error.invalid.field.name=''{0}'' 不是有效的字段名
replace.constructor.builder.error.invalid.setter.name=''{0}'' 不是有效的 setter 名称
replace.constructor.builder.error.no.constructor.chain={0} 的构造函数不形成简单链。
replace.constructor.builder.error.no.constructors=当前类没有要替换为构建器的构造函数。
replace.constructor.builder.error.selected.class.was.not.found=找不到现有的构建器类 {0}。
replace.constructor.builder.field.name.table.title=字段名称
replace.constructor.builder.optional.setter.table.title=可选 Setter
replace.constructor.builder.parameter.table.title=形参
replace.constructor.builder.select.builder.class.chooser.title=选择构建器类
replace.constructor.builder.setter.name.table.title=Setter 名称
replace.constructor.builder.use.existing=使用现有项(&U)
replace.constructor.existing.builder.fqn=构建器类名 (完全限定)(&B)
replace.constructor.factory.error.factory.method.already.exists=工厂方法 {0} 已存在，将用于替代新创建的工厂方法。
replace.constructor.factory.error.invalid.factory.method.name=''{0}'' 不是有效的工厂方法名称
replace.constructor.new.builder.class.name=构建器类名(&N)
replace.constructor.new.builder.package=新构建器的软件包(&P)
replace.constructor.with.builder=将构造函数替换为构建器
replace.constructor.with.builder.text=将构造函数替换为构建器
replace.constructor.with.factory.method=将构造函数替换为工厂方法
replace.constructor.with.factory.method.title=将构造函数替换为工厂方法
replace.constructor.with.factory.target.fq.name=在(完全限定名称)\:
replace.default.constructor.of.0.with.a.factory.method=将默认构造函数 {0} 替换为工厂方法
replace.default.constructor.with.factory.method=将默认构造函数替换为工厂方法
replace.fields.inaccessible.in.usage.context=替换上下文没有使用的字段 (&I)
replace.fields.used.in.expressions.with.their.getters=将表达式中使用的字段替换为其 getter (&U)
replace.inheritance.from=替换委派继承从(&R)\:
replace.inheritance.with.delegation.command=使用{0}中的委托替换继承
replace.inheritance.with.delegation.delegate.members.title=委派成员
replace.inheritance.with.delegation.elements.header=替换继承与代表团
replace.inheritance.with.delegation.invalid.field=''{0}'' 是委派的无效字段名称
replace.inheritance.with.delegation.invalid.inner.class=''{0}'' 是委派的无效字段名称
replace.inheritance.with.delegation.title=用委派替换继承
replace.inside.current.lambda=在当前 lambda 内创建变量
replace.instance.qualifiers.with.class.references=将实例限定符替换为类引用
replace.lambda.chain.detected=检测到 lambda 链
replace.method.code.duplicates.title=替换重复代码
replace.method.duplicates.scope.chooser.message=分析作用域
replace.method.duplicates.scope.chooser.title=指定{0}作用域
replace.occurrences.inside.statement=替换{2, choice, 1\#|2\#外部} ''{1}'' 块中的 {0} 个匹配项
replace.this.code.fragment.and.change.signature=方法的签名将被更改为{0}
replace.this.code.fragment.and.make.method.static=(方法将被设为 static)
replace.this.code.fragment.and.make.method.static.visible=(方法将被设为 static 和{0})
replace.this.code.fragment.and.make.method.visible=(方法将{0})
replace.with.method.call.does.not.work.for.constructors=替换为方法调用不工作为构造函数
replace.write.access.occurrences=替换白名单匹配项 (&L)
replacing.inheritance.with.delegation=替换继承与代表团
safe.delete.parameter.usage.warning={0} 具有无法安全删除的调用端用法。
safe.delete.search.for.caller.method.usages.progress=搜索调用者方法用法…
safe.delete.select.members.to.propagate.dialog.title=选择要传播安全删除的成员
safe.delete.select.methods.to.propagate.delete.parameters.dialog.title=选择要传播形参删除的方法
select.source.root.chooser.title=选择根源代码
selected.block.contains.invocation.of.another.class.constructor=所选块包含调用另一个类构造函数
selected.block.contains.statement.outside.of.class=所选块在类外部包含语句
selected.block.should.represent.an.expression=所选块应该表示一个表达式
selected.expression.cannot.be.a.constant.initializer=所选表达式不能是常量初始值设定项
selected.expression.cannot.be.extracted=无法提取所选表达式
selected.expression.has.void.type=所选表达式具有类型 'void'
selected.expression.introduces.pattern.variable=选定的表达式引入模式变量 ''{0}''
setter.method.found.for.the.field.0=发现字段 {0} 的 setter 方法。 是否将 setter 一起{1}?
source.folder.0.has.package.prefix.1=源文件夹 {0} 具有软件包前缀 ''{1}''\n无法在该文件夹中创建软件包 ''{2}''。
static.initializer.description={0} 的 static 初始值设定项
suggest.signature.preview.after.title=之后
suggest.signature.preview.method.call.prefix=方法调用\:
suggest.signature.preview.title.before=之前
superclass.cannot.be.accessed.in.subclass=在子类中将无法访问的超类
superclass.cannot.be.extracted.from.a.record=不能从一个记录中提取超类
superclass.cannot.be.extracted.from.an.enum=无法从枚举中提取超类
synthetic.jsp.class.is.referenced.in.the.method=合成的jsp类是引用的方法
target.0.is.not.accessible.from.1=目标{0}是不可以从{1}
template.error.class.already.defined=作用域内已定义名为 ''{0}'' 的类
template.error.invalid.identifier.name=标识符名称无效
template.error.variable.already.defined=已定义具有此名称的变量
there.are.going.to.be.multiple.destination.files.with.the.same.name=有多个目标文件具有相同的名称。
there.are.multiple.exit.points.in.the.selected.code.fragment=选定的代码段有多个出口点。
there.are.multiple.output.values.for.the.selected.code.fragment=选定的代码段有多个输出值。
there.are.no.variables.that.have.reference.type=方法形参或所包含的类字段都没有引用类型
there.are.unused.methods.that.override.methods.you.delete=<html>有未使用的方法会重写要删除的方法。请同时选择要删除的未使用的重写方法\:</html>
there.is.already.a.0.in.1=已存在一个{0}在{1}中
there.is.already.a.0.it.will.conflict.with.an.introduced.parameter=已经有一个{0}。它将冲突与引入的形参冲突
there.is.already.a.0.it.will.conflict.with.the.renamed.1=现有的{0}具有相同的名称
there.is.already.a.0.it.will.conflict.with.the.renamed.short=变量 ''{0}'' 已存在
there.is.already.type.parameter.in.0.with.name.1=名称为 {1} 的 {0} 中已存在类型形参
this.invocation.only.and.keep.the.method=仅内联此用法并保留方法(&K)
this.method=这种方法
this.reference.only.and.keep.super.class=这个仅供引用并保持内联的超类(&K)
this.reference.only.and.keep.the.class=内联这只引用和保持类(&K)
this.reference.only.and.keep.the.field=仅内联此用法并保留字段(&K)
title.rename.variables.with.the.following.names.to=将具有以下名称的变量重命名为\:
tooltip.cannot.inline.pattern.variable=无法内联模式变量
turn.refs.to.super.command=将{0}的用法替换为{1}
turnRefsToSuper.change.usages.to=更改{0}的使用到\: (&C)
turnRefsToSuper.use.superclass.in.instanceof=使用接口/超类在实例 (&U)
type.migration.action.name=类型迁移
type.migration.choose.scope.title=选择可能出现更改签名的作用域
type.migration.class.type.argument.label=将类类型实参 {0} 迁移到
type.migration.conflicts.found=找到的迁移冲突
type.migration.error.hint.title=类型迁移
type.migration.exclude.action.text=排除 (&E)
type.migration.include.action.text=包含(&I)
type.migration.migrate.button.text=迁移 (&M)
type.migration.no.conflicts.found=未找到迁移冲突
type.migration.no.scope.warning.message=未选择作用域
type.migration.reasons.to.migrate=已找到要迁移的原因
type.migration.rerun.button.text=重新运行类型迁移(&R)
type.migration.return.type.of.method.label=将方法 {1} 的返回值类型 {0} 迁移到
type.migration.select.suggestion=选择根以查找迁移的原因
type.migration.type.of.field.label=将字段 {1} 的类型 {0} 迁移到
type.migration.type.of.parameter.label=将形参 {1} 的类型 {0} 迁移到
type.migration.type.of.pattern.variable.label=将模式变量 {1} 的类型 {0} 迁移到
type.migration.type.of.record.component.label=将记录组件 {1} 的类型 {0} 迁移到
type.migration.type.of.variable.label=将变量 {1} 的类型 {0} 迁移到
type.of.the.selected.expression.cannot.be.determined=所选表达式的类型不能确定。
unable.to.start.type.migration=无法启动类型迁移
unknown.expression.type=未知的表达式类型。
unused.overriding.methods.title=未使用重写方法
use.interface.where.possible.title=在可能处使用接口
use.super.references.prompt=在这个阶段，{0} 可以分析 {1} 的用法，并在可能的情况下将其替换为 {2} 的用法。\n是否要继续?
use.variable.initializer.to.initialize.parameter=使用变量初始值设定项初始化形参(&I)
variable.0.is.changed.before.last.access=变量 ''{0}'' 在上次访问变量 ''{1}'' 前已更改。
variable.does.not.have.an.initializer=变量 {0} 没有初始值设定项。
variable.is.accessed.for.writing=变量 ''{0}'' 被访问以进行写入
variable.is.never.used.before.modification=修改之前从未使用变量{0}
variable.of.type=类型的变量(&T)\:
variable.type.unknown=变量类型未知
would.you.like.to.replace.default.constructor.of.0.with.factory.method=要将默认构造函数 {0} 替换为工厂方法吗?
wrap.return.value.create.inner.class=创建内部类(&I)
wrap.return.value.create.new.class=创建新类(&C)
wrap.return.value.existing.class.name=名称
wrap.return.value.inner.class.name=名称(&M)
wrap.return.value.new.class.name=名称(&N)
wrap.return.value.new.class.package.name=软件包名称(&P)
wrap.return.value.use.existing.class=使用现有类(&U)
wrap.return.value.wrapper.field=包装器字段(&F)

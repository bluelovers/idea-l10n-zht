language.groovy=Groovy
filetype.groovy.description=Groovy
filetype.dgm.description=Groovy 扩展模块描述符文件
filetype.dgm.display.name=DGM
filetype.logback.description=Groovy Logback DSL 配置
filetype.logback.display.name=Groovy Logback DSL
filetype.gdsl.description=IntelliJ Groovy DSL 配置
filetype.gdsl.display.name=Groovy DSL
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.text=propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.description=操作生成 propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.text=methodMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.description=操作生成 propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.text=equals() 和 hashCode()
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.description=现在操作生成 equals 和 hashCode
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.text=getter 和 setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.description=生成 getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.text=Setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.description=生成 setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.text=Getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.description=生成 getter
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.text=构造函数
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.description=生成构造函数
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.text=to_String()
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.description=生成 toString() 方法
action.ExcludeFromStubGeneration.text=从存根生成中排除
action.ExcludeFromStubGeneration.description=不要在编译时为该 Groovy 文件生成 Java 存根
action.DumpGroovyControlFlowAction.text=转储 Groovy 控制流
action.ConvertToCompileStatic.text=转换为 @CompileStatic
action.ConvertToCompileStatic.description=将 Groovy 文件转换为 @CompileStatic
action.ConvertGroovyToJava.text=转换为 Java
action.ConvertGroovyToJava.description=将 Groovy 文件转换为 Java
action.Groovy.NewScript.text=Groovy 脚本
action.Groovy.NewScript.description=创建新的 Groovy 脚本
action.Groovy.NewClass.text=Groovy 类
action.Groovy.NewClass.description=创建新的 Groovy 类
action.Groovy.CheckResources.Rebuild.text=重新构建资源 (_R)
action.Groovy.CheckResources.Rebuild.description=为资源根中的所有 Groovy 文件运行编译器，以检查编译问题
action.Groovy.CheckResources.Make.text=构建资源(_B)
action.Groovy.CheckResources.Make.description=为资源根中所有 Groovy 文件运行增量编译器，以检查编译问题
group.Groovy.CheckResources.text=Groovy 资源(_O)
group.Groovy.CheckResources.description=为资源根中的 Groovy 文件运行编译器，以检查编译问题
file.template.group.title.groovy=Groovy
groovy.term.class=类
groovy.term.interface=接口
groovy.term.trait=特征
groovy.term.enum=枚举
groovy.term.annotation=注解
groovy.term.method=方法
groovy.term.field=字段
groovy.term.property=属性
groovy.term.parameter=形参
groovy.term.variable=局部变量
groovy.term.binding=脚本绑定变量
groovy.term.label=标签
groovy.term.closure=闭包
groovy.term.expression=表达式
new.class.action.text=Groovy 类
new.class.action.description=创建新的 Groovy 类
new.class.dialog.title=新建 Groovy 类
new.class.list.item.class=类
new.class.list.item.interface=接口
new.class.list.item.trait=特征
new.class.list.item.enum=枚举
new.class.list.item.annotation=注解
invalid.qualified.name=这不是有效的 Groovy 限定名称
new.script.action.text=Groovy 脚本
new.script.action.description=创建新的 Groovy 脚本
new.script.dialog.title=为新的 Groovy 脚本输入名称
new.script.list.item.script=Groovy 脚本
new.script.list.item.script.dsl=GroovyDSL 脚本
new.gant.script.dialog.title=新建 Gant 脚本
new.gant.script.dialog.message=为新的 Gant 脚本输入名称
debug.option=启用调试堆栈跟踪(&D)
groovy.debug.disable.specific.methods=不单步进入特定的 Groovy 类(&I)
groovy.debug.caption=Groovy
########################################################################################################################
# Parser error messages
########################################################################################################################
identifier.expected=应为标识符
identifier.or.block.expected=应为标识符或代码块
string.end.expected=应为字符串结尾
try.without.catch.finally='try' 没有 'catch' 或 'finally'
expression.expected=应为表达式
duplicate.modifier=重复的修饰符 ''{0}''
########################################################################################################################
# Intentions & error messages
########################################################################################################################
cannot.resolve=无法解析符号''{0}''
cannot.access=对 ''{0}'' 的访问超出了其访问权限
cannot.reference.non.static=无法从 static 上下文引用非静态符号 ''{0}''
cannot.return.from.constructor=无法从构造函数返回对象
cannot.return.from.void.method=无法从返回 'void' 的方法返回对象
cannot.return.type=无法从返回 ''{1}'' 的方法返回 ''{0}''
cannot.apply.method.or.closure=''{0}'' 无法应用于 ''{1}''
cannot.apply.method1=''{1}'' 中的 ''{0}'' 无法应用于 ''{2}''
cannot.apply.constructor=''{1}'' 中的构造函数 ''{0}'' 不能应用于 ''{2}''
cannot.apply.default.constructor=无法将默认构造函数应用于类 ''{0}''
cannot.instantiate.abstract.class=无法实例化 abstract 类 ''{0}''
cannot.instantiate.interface=无法实例化接口 ''{0}''
missing.required.named.parameter=缺少必需的命名形参 ''{0}''
loss.of.precision=从 ''{0}'' 到 ''{1}'' 的精度可能会损失
cannot.assign=无法将 ''{0}'' 分配给 ''{1}''
cannot.cast=不能将 ''{0}'' 转换为 ''{1}''
multiple.assignments.without.list.expr=在静态类型检查模式下，不支持右侧没有列表表达式的多个赋值
spread.operator.is.not.available=该展开运算符在进行静态类型检查时不能用作实参
replace.with.list.literal=替换为列表文字
replace.with.get.at=替换为索引访问
incorrect.number.of.values=值的数量不正确。应为: {0}，实际为: {1}
invalid.lvalue=要赋予的值无效
duplicate.class=类 ''{0}'' 在 ''{1}'' 中已存在
duplicate.inner.class=重复的类: ''{0}''
script.generated.with.same.name=为脚本代码生成了一个合成类 ''{0}''
variable.already.defined=变量 ''{0}'' 已定义
field.already.defined=字段 ''{0}'' 已定义
create.class.family.name=创建类
create.class.text=创建类 {0}
create.interface.text=创建接口 {0}
create.annotation.text=创建注解 {0}
constructors.are.not.allowed.in.anonymous.class=匿名类中不允许使用构造函数
no.such.property=属性 ''{0}'' 不存在
change.modifier=将 ''{0}'' 设为{1}
change.modifier.not=将 ''{0}'' 设为非{1}
change.modifier.family.name=更改修饰符
parameter.cast.fix=将第 {0,number,ordinal} 个形参转换为 {1}
action.convert.lambda.to.closure=将 lambda 转换为闭包
add.parenthesis.to.lambda.parameter.list=将圆括号添加到形参列表
# suppress inspection "UnusedProperty"
packageLocal.visibility.presentation=默认可见
# suppress inspection "UnusedProperty"
protected.visibility.presentation=protected
# suppress inspection "UnusedProperty"
private.visibility.presentation=private
# suppress inspection "UnusedProperty"
public.visibility.presentation=public
# suppress inspection "UnusedProperty"
abstract.visibility.presentation=abstract
# suppress inspection "UnusedProperty"
static.visibility.presentation=static
# suppress inspection "UnusedProperty"
final.visibility.presentation=final
# suppress inspection "UnusedProperty"
native.visibility.presentation=原生
# suppress inspection "UnusedProperty"
synchronized.visibility.presentation=synchronized
# suppress inspection "UnusedProperty"
strictfp.visibility.presentation=strictfp
# suppress inspection "UnusedProperty"
transient.visibility.presentation=transient
# suppress inspection "UnusedProperty"
volatile.visibility.presentation=volatile
# suppress inspection "UnusedProperty"
def.visibility.presentation=def
intention.family.name.convert.conditional.expression.to.elvis=条件表达式转换为 Elvis
intention.family.name.replace.with.keyed.access=替换为键控访问
intention.family.name.fix.range.class=修正范围类
intention.family.name.make.return.implicit=设为隐式返回
intention.family.name.simplify=简化
intention.family.name.remove.unnecessary.continue=移除不必要的 continue
intention.family.name.remove.unnecessary.return=移除不必要的 return
intention.family.name.add.parameter.cast=添加形参转换
intention.family.name.replace.for.each.operator=替换 'for-each' 运算符
intention.family.name.add.cast=添加转换
intention.family.name.change.variable.type=更改变量类型
intention.family.name.replace.with.conditional.call=替换为条件调用
intention.family.name.collapse.conditional.expressions=收起条件表达式
intention.family.name.remove.double.negation=移除双重求反
intention.family.name.activate.dsl.descriptor=激活 DSL 描述符
intention.family.name.collapse.if.statement=收起 'if' 语句
intention.family.name.replace.with.short.circuit.expression=替换为短路表达式
intention.family.name.replace.something.with=将 ''{0}'' 替换为 ''{1}''
intention.family.name.add.attributes.to.annotation=将特性添加到注解
intention.family.name.fix.quotation=修正引用
illegal.combination.of.modifiers=修饰符的组合非法
illegal.combination.of.modifiers.abstract.and.final=修饰符 'abstract' 和 'final' 的组合非法
modifier.volatile.not.allowed.here=此处不允许使用修饰符 'volatile'
modifier.transient.not.allowed.here=此处不允许使用修饰符 'transient'
modifier.0.not.allowed=此处不允许使用修饰符 ''{0}''
interface.cannot.have.modifier.final=接口不能具有修饰符 'final'
script.method.cannot.have.modifier.abstract=脚本方法不能具有修饰符 'abstract'
script.cannot.have.modifier.native=脚本不能具有修饰符 'native'
interface.must.have.no.static.method=接口不得有 static 方法
only.abstract.class.can.have.abstract.method=只有 abstract 类可以具有 abstract 方法
anonymous.class.cannot.have.abstract.method=匿名类不能具有 abstract 方法
illegal.combination.of.modifiers.volatile.and.final=修饰符 'volatile' 和 'final' 的组合非法
variable.cannot.be=变量不能具有修饰符 ''{0}''
remove.modifier=移除 ''{0}''
not.abstract.method.should.have.body=abstract 方法不应有主体
cannot.create.class.error.text=无法创建类 ''{0}'': {1}
cannot.create.class.error.title=无法创建类
no.class.in.file.template=文件模板中未找到类
Inner.methods.are.not.supported=不支持内部方法
final.class.cannot.be.extended=无法扩展 final 类
# Groovy 1.7 checks
unsupported.inner.class.0=Groovy {0} 中不支持内部类
unsupported.anonymous.class.0=Groovy {0} 中不支持匿名类
# Groovy 1.8 checks
unsupported.diamonds.0=Groovy {0} 中不支持 diamond
unsupported.command.syntax.0=Groovy {0} 中不支持命令表达式语法
unsupported.dollar.slashy.string.0=Groovy {0} 中不支持 $/ 字符串
unsupported.multiline.slashy.string.0=Groovy {0} 中不支持多行 / 字符串
#Groovy 2.3 checks
unsupported.traits.0=Groovy {0} 中不支持特征
#Groovy 2.5 checks
duplicating.named.parameter=形参中出现重复的命名形参 ''{0}'': {1}
field.should.be.immutable=字段 ''{0}'' 应具有不可变的类型，或者应使用 @ImmutableOptions 声明
immutable.options.property.not.exist=属性 ''{0}'' 不存在
explicit.includes.and.excludes=应只提供 'includes' 和 'excludes' 之一
require.closure.as.attribute.value=预期闭包为特性值
initializers.are.forbidden.with.defaults=通过在 @TupleConstructor 中禁用 'defaults' 来禁用默认值
super.is.not.allowed.in.pre.with.call.super=在启用 'callSuper' 的情况下， 不允许在 'pre' 中调用 super
#Groovy 3.0 checks
illegal.default.modifier=修饰符 'default' 仅在接口的方法中有意义
illegal.default.modifier.fix=移除 'default' 修饰符
default.modifier.in.old.versions=修饰符 'default' 在 Groovy 3.0 或更高版本中可用
unsupported.do.while.statement=当前版本中不支持 'do while'
unsupported.tuple.declaration.in.for=当前版本不支持 'for' 初始化中的元组声明
unsupported.multiple.variables.in.for=当前版本不支持 'for' 初始化中的多个变量
unsupported.expression.list.in.for.update=当前版本不支持 'for' 更新中的多个表达式
unsupported.resource.list=当前版本不支持 'try-with-resources'
unsupported.array.initializers=当前版本不支持数组初始值设定项
operator.is.not.supported.in=当前版本不支持运算符 ''{0}''
unsupported.negated.in=当前版本不支持否定 'in'
unsupported.negated.instanceof=当前版本不支持否定 'instanceof'
unsupported.elvis.assignment=当前版本不支持 Elvis 赋值
unsupported.safe.index.access=当前版本不支持安全索引访问
unsupported.lambda=当前版本不支持 lambda
unsupported.type.annotations=当前版本不支持类型注解
unsupported.tuple.application.initializer=当前版本不支持应用程序初始值设定项
illegal.single.argument.lambda=lambda 的单实参形式仅可用作赋值表达式的右侧部分或方法调用内的实参
method.is.not.implemented=方法 ''{0}'' 未实现
change.implements.and.extends.classes=标准化 extends 和 implements 列表
fix.package.name=修正软件包名称
checkbox.delegate.via.overloading.method=通过重载方法委托
checkbox.ignore.conditional.operators=忽略条件运算符
checkbox.ignore.obscure.operators=忽略模糊运算符
checkbox.ignore.double.checked.locking.on.volatile.fields=忽略对 volatile 字段的双重检查锁定
checkbox.inspect.anonymous.closures=检查匿名闭包
checkbox.only.warn.if.loop.empty=仅当循环为空时才发出警告
add.dynamic.property=添加动态属性 ''{0}''
duplicate.element.in.the.map=映射中存在重复的元素 ''{0}''
dynamic.tool.window.id=动态成员
create.field.from.usage.family.name=从用法创建字段
create.field.from.usage=创建字段 ''{0}''
create.method.from.usage.family.name=从用法创建方法
create.method.from.usage=创建方法 ''{0}''
create.variable.from.usage.family.name=从用法创建变量
create.variable.from.usage=创建变量 ''{0}''
create.parameter.from.usage.family.name=从用法创建形参
create.parameter.from.usage=创建形参 ''{0}''
add.dynamic.element=添加动态元素
add.dynamic.method=添加动态方法
add.dynamic.method.0=添加动态方法 ''{0}''
dynamic.type=类型
dynamic.name=名称
dynamic.properties.table.name=方法实参
dynamic.method.return.type=返回类型(&T):
dynamic.method.property.type=属性类型(&T):
are.you.sure.to.delete.dynamic.property=确定要删除 ''{0}'' 吗''?
dynamic.property.deletion=删除动态属性
are.you.sure.to.delete.elements=确定要删除 ''{0}'' 个元素吗''?
dynamic.element.deletion=动态元素删除
tuple.cant.be.placed.in.class=不允许对字段多次赋值
is.not.enclosing.class=''{0}'' 不是封闭类
package.definition.cannot.have.modifiers=软件包定义不能具有修饰符
import.statement.cannot.have.modifiers=import 语句不能具有修饰符
undefined.label=未定义标签 ''{0}''
continue.outside.loop=仅允许在循环内部使用 continue 语句
break.outside.loop.or.switch=仅允许在循环或冒号样式的 switch 语句中使用 'break' 语句
label.already.used=标签 ''{0}'' 已在使用中
break.outside.loop=仅允许在循环内使用具有命名标签的 break 语句
Constructor=构造函数
Getter=Getter
Setter=Setter
not.allowed.modifier.in.for.in=此处不允许使用修饰符 ''{0}''
property.name.expected=应为属性名称
wildcards.are.not.allowed.in.extends.list=super 类型可能未指定通配符类型
method.does.not.override.super=方法不重写其超类的方法
method.duplicate=具有签名 {0} 的方法已在类 ''{1}'' 中定义
ambiguous.code.block=不明确的代码块
cyclic.inheritance.involving.0=涉及 ''{0}'' 的循环继承
there.is.no.default.constructor.available.in.class.0=类 ''{0}'' 中没有可用的默认构造函数
groovy.library.is.not.configured.for.module=没有为模块 ''{0}'' 配置 Groovy SDK
configure.groovy.library=配置 Groovy SDK…
create.instance.of.built-in.type=内置类型的实例化
incorrect.variable.name=变量名称不正确
no.interface.expected.here=此处不应为接口
no.class.expected.here=此处不应为类
invoke.completion.second.time.to.show.skipped.methods=第二次调用补全以显示跳过的方法
groovy.file.extension.is.not.mapped.to.groovy.file.type=*.groovy 文件已映射到 ''{0}''。\n您可以在“设置 | 文件类型”中将它们映射到 Groovy
class.is.not.annotation=''{0}'' 不是一个注解
method.call.is.ambiguous=方法调用不明确
operator.call.is.ambiguous=运算符调用不明确
duplicated.named.parameter=已找到重复的命名形参 ''{0}''
no.super.classes.found=未找到超类
no.super.method.found=未找到 super 方法
cannot.assign.string.to.enum.0=无法将字符串分配给枚举 ''{0}''
cannot.find.enum.constant.0.in.enum.1=无法在枚举 ''{1}'' 中找到枚举常量 ''{0}''
recursive.constructor.invocation=递归构造函数调用
the.usage.of.a.map.entry.expression.to.initialize.an.enum.is.currently.not.supported=当前不支持使用映射项表达式来初始化枚举
class.definition.is.not.expected.here=不应在此处使用类定义
move.class.0.from.method=将 ''{0}'' 移至正确位置
move.class.from.method.family.name=移至正确位置快速修复
cannot.infer.argument.types=无法推断实参类型
Equals=等号
default.initializers.are.not.allowed.in.abstract.method=abstract 方法中不允许使用默认初始值设定项
groovy.does.not.support.constructor.type.arguments=Groovy 不支持构造函数类型实参
illegal.escape.character.in.string.literal=字符串文字中的非法转义字符
method.with.type.parameters.should.have.return.type=具有类型形参的方法应具有返回类型
primitive.type.parameters.are.not.allowed=类型形参列表中不允许使用基元类型形参
primitive.bound.types.are.not.allowed=不允许使用基元限定类型
ellipsis.type.is.not.allowed.here=此处不允许使用 ellipsis 类型
method.0.is.too.complex.too.analyze=方法 ''{0}'' 过于复杂而无法分析。\n无法推断局部变量的类型。
closure.is.too.complex.to.analyze=闭包分析起来很复杂。\n无法推断局部变量的类型。
0.is.deprecated=''{0}'' 已被弃用
wrong.number.of.type.arguments=类型实参的数量错误: {0}；要求 {1} 个
type.argument.0.is.not.in.its.bound.should.extend.1=类型形参 ''{0}'' 不在其界限内；应扩展 ''{1}''
catch.statement.parameter.type.should.be.a.subclass.of.throwable=catch 语句形参类型应当是 Throwable 的子类
exception.0.has.already.been.caught=已捕捉到异常 ''{0}''
unnecessary.type=不必要的异常 ''{0}''。''{1}'' 已声明
create.enum=创建枚举 {0}
create.trait=创建特征 {0}
annotation.field.can.only.be.used.within.a.script.body=注解 @Field 只能在脚本主体内使用
annotation.field.can.only.be.used.within.a.script=注解 @Field 只能在脚本内使用
return.type.is.incompatible={1} 中 {0} 的返回类型与 {3} 中的 {2} 不兼容
anonymous.class.derived.from.0=派生自 {0} 的匿名类
throws.clause.is.not.allowed.in.at.interface=@interface 成员中不允许使用 'throws' 子句
at.interface.0.does.not.contain.attribute=@interface ''{0}'' 不包含特性 ''{1}''
duplicate.attribute=重复特性
missed.attributes=缺少特性: {0}
unexpected.attribute.type.0=意外的特性类型: ''{0}''
annotation.field.should.have.type.declaration=注解中的字段应具有类型声明
interface.members.are.not.allowed.to.be=接口成员不允许为 {0}
abstract.methods.must.not.have.body=abstract 方法不得有主体
method.has.incorrect.modifier.volatile=方法具有不正确的修饰符 'volatile'
native.methods.cannot.have.body=原生方法不能有主体
top.level.class.may.not.have.private.modifier=顶层类不能具有 'private' 修饰符
top.level.class.may.not.have.protected.modifier=顶层类不能具有 'protected' 修饰符
property.missing=propertyMissing
attribute.name.expected=应为特性名称
java.style.for.each.statement.requires.a.type.declaration=Java 样式的 for-each 语句需要类型声明
super.cannot.be.used.in.static.context='super' 不能在 static 上下文中使用
qualified.0.is.allowed.only.in.nested.or.inner.classes=仅允许在嵌套/内部类中使用限定的 {0}
groovy.file.0=Groovy 文件 ''{0}''
type.argument.list.is.not.allowed.here=此处不允许使用类型实参列表
initializers.are.not.allowed.in.interface=接口中不允许使用初始值设定项
initializer.cannot.have.annotations=初始值设定项不能有注解
initializer.cannot.be.0=初始值设定项不能为 {0}
constructors.are.not.allowed.in.interface=接口中不允许使用构造函数
type.parameters.are.unexpected=存在意外的类型形参
constructors.cannot.have.return.type=构造函数中不允许使用返回类型元素
constructor.cannot.have.static.modifier=构造函数可能不为 static
annotation.types.may.not.have.extends.clause=注解类型不能具有 'extends' 子句
annotation.types.may.not.have.implements.clause=注解类型不能具有 'implements' 子句
no.implements.clause.allowed.for.interface=接口不能具有 'implements' 子句
enums.may.not.have.extends.clause=枚举不能具有 'extends' 子句
method.0.cannot.override.method.1.in.2.overridden.method.is.final=方法 ''{0}'' 无法重写 ''{2}'' 中的方法 ''{1}''；重写的方法为 final
method.0.cannot.have.weaker.access.privileges.1.than.2.in.3.4=方法 ''{0}'' 的访问权限(''{1}'')不能比 ''{3}'' (''{4}'')中的 ''{2}'' 弱
tuple.declaration.should.end.with.def.modifier=元组声明应以 'def' 修饰符结尾
injection.should.not.contain.line.feeds=GString 注入不得包含换行
collection.literal.contains.named.argument.and.expression.items=集合文字同时包含命名实参和表达式实参
annotation.collector.cannot.have.attributes=使用 @AnnotationCollector 注解的注解类型不能具有特性
annotation.type.cannot.be.inner=注解类型不能是内部类型
named.arguments.are.not.allowed.inside.index.operations=索引操作内不允许使用命名实参
expected.0.to.be.inline.constant=''{0}'' 应是一个内联常量
cannot.assign.a.value.to.final.field.0=无法将值赋给 final 字段 ''{0}''
cannot.assign.a.value.to.final.parameter.0=无法将值赋给 final 形参 ''{0}''
variable.0.might.not.have.been.initialized=变量 ''{0}'' 可能尚未初始化
doc.end.expected=应为 '*/'
mixing.private.and.public.protected.methods.of.the.same.name=将具有相同名称的 private 和 public/protected 方法混合
explicit.constructors.are.not.allowed.in.immutable.class=@Immutable 类不允许使用显式构造函数
repetitive.method.name.0=重复的方法名称 ''{0}''
declared.type.0.have.to.extend.script=声明的类型 ''{0}'' 不扩展 ''groovy.lang.Script'' 类
base.script.annotation.is.allowed.only.inside.scripts=注解 @BaseScript 只能在脚本内使用
delegate.annotation.is.only.for.methods.without.arguments=注解 @Delegate 无法应用于带有实参的方法
builder.annotation.not.support.super.for.simple.strategy=groovy.transform.builder.SimpleStrategy 不支持注解特性 'includeSuperProperties'
0.expressions.on.trait.fields.properties.are.not.supported.in.traits=特征中不支持特征字段/属性上的 {0} 个表达式
only.traits.expected.here=此处应仅有特征
anonymous.classes.cannot.be.created.from.traits=从 Groovy 2.5.2 起可以使用特征中的匿名类
trait.method.cannot.be.protected=不允许 protected 特征方法
non.static.classes.not.allowed=特征中不允许使用非 static 内部类
selfType.class.does.not.inherit=@SelfType: 类 ''{0}'' 不继承 ''{1}''
illegal.type.void=非法类型: 'void'
illegal.method.name=方法名称包含非法字符: {0}
indexed.property.is.applicable.to.properties.only=@IndexedProperty 仅适用于属性
listener.list.field.must.have.a.generic.collection.type=@ListenerList 字段必须具有泛型集合类型
listener.list.field.with.generic.wildcards.not.supported=不支持包含泛型通配符的 @ListenerList 字段
synchronized.not.allowed.on.abstract.method=抽象方法不允许 @Synchronized
lock.field.0.must.be.static=锁定字段 ''{0}'' 必须为 static
lock.field.0.must.not.be.static=锁定字段 ''{0}'' 不得为 static
lock.field.0.not.found=未找到锁定字段 ''{0}''
select.module.action.text=选择模块…
select.module.action.description=选择要使用类路径的模块
select.module.popup.title=使用模块的类路径
### Inspection groups ###
inspection.annotations=注解
inspection.assignments=赋值问题
inspection.bugs=可能的错误
inspection.confusing=可能引起混淆的代码结构
inspection.control.flow=控制流问题
inspection.data.flow=数据流
inspection.error.handling=错误处理
inspection.gpath=GPath
inspection.naming=命名惯例
inspection.method.metrics=方法指标
inspection.redundancy=声明冗余
inspection.threading=线程问题
inspection.validity=有效性问题
inspection.style=样式
inspection.other=其他
### Inspections ###
inspection.display.name.result.of.assignment.used=使用的赋值的结果
inspection.display.name.assignment.can.be.operator.assignment=赋值可替换为运算符赋值
inspection.display.name.delegates.to=@DelegatesTo
inspection.display.name.unresolved.access=未解析的引用表达式
inspection.display.name.untyped.access=无类型引用表达式
inspection.display.name.list.set.can.be.keyed.access=对 List.set 的调用可以是键控访问
inspection.display.name.list.get.can.be.keyed.access=对 List.get 的调用可以是键控访问
inspection.display.name.map.put.can.be.keyed.access=对 Map.put 的调用可以是键控访问
inspection.display.name.map.get.can.be.keyed.access=对 Map.get 的调用可以是键控访问
inspection.display.name.parameter.naming.convention=方法形参命名惯例
inspection.display.name.constant.naming.convention=常量命名惯例
inspection.display.name.instance.variable.naming.convention=实例变量命名惯例
inspection.display.name.instance.method.naming.convention=实例方法命名惯例
inspection.display.name.static.variable.naming.convention=static 变量命名惯例
inspection.display.name.static.method.naming.convention=static 方法命名惯例
inspection.display.name.local.variable.naming.convention=局部变量命名惯例
inspection.display.name.class.naming.convention=类命名惯例
inspection.display.name.groovydoc.check=未解析的 GroovyDoc 引用
inspection.display.name.constructor.named.arguments=构造函数调用的命名实参
inspection.display.name.result.of.object.allocation.ignored=被忽略的对象分配结果
inspection.display.name.divide.by.zero=除以零
inspection.display.name.infinite.recursion=无限递归
inspection.display.name.infinite.loop.statement=无限循环语句
inspection.display.name.non.short.circuit.boolean=非短路布尔
inspection.display.name.duplicate.switch.branch=重复 switch case
inspection.display.name.gstring.key=GString 映射键
inspection.display.name.octal.integer=八进制整数
inspection.display.name.overly.complex.boolean.expression=过于复杂的布尔表达式
inspection.display.name.clashing.trait.methods=冲突的特征方法
inspection.display.name.overly.complex.arithmetic.expression=过于复杂的算术表达式
inspection.display.name.double.negation=双重求反
inspection.display.name.pointless.arithmetic=无意义的算术表达式
inspection.display.name.empty.statement.body=带空体的语句
inspection.display.name.reassigned.in.closure.local.var=在闭包类或匿名类中重新分配局部变量
inspection.display.name.result.of.increment.or.decrement.used=使用增量或减量的结果
inspection.display.name.negated.if=否定 if 条件表达式
inspection.display.name.in.argument.check=不兼容的 'in' 实参类型
inspection.display.name.negated.conditional=否定条件表达式
inspection.display.name.nested.conditional=嵌套条件表达式
inspection.display.name.conditional=三元表达式
inspection.display.name.nested.switch=嵌套 switch 语句
inspection.display.name.multiple.return.points.per.method=具有多个返回点的方法
inspection.display.name.method.with.more.than.three.negations=具有三个以上否定的方法
inspection.display.name.overly.nested.method=过度嵌套的方法
inspection.display.name.overly.long.method=过长的方法
inspection.display.name.overly.complex.method=过于复杂的方法
inspection.display.name.method.parameter.count=形参过多的方法
inspection.display.name.while.loop.spins.on.field=While 循环在字段上自旋
inspection.display.name.unsynchronized.method.overrides.synchronized.method=未同步方法重写 synchronized 方法
inspection.display.name.synchronization.on.variable.initialized.with.literal=在使用文字初始化的变量上同步
inspection.display.name.synchronization.on.non.final.field=在非 final 字段上同步
inspection.display.name.wait.while.not.synchronized=未同步时使用 'wait()'
inspection.display.name.wait.call.not.in.loop='wait()' 不在循环中
inspection.display.name.notify.while.not.synchronized=未同步时使用 'notify()' 或 'notifyAll()'
inspection.display.name.system.run.finalizers.on.exit=System.runFinalizersOnExit() 调用
inspection.display.name.thread.stop.suspend.resume=Thread.stop()、Thread.suspend() 或 Thread.resume() 调用
inspection.display.name.nested.synchronized.statement=嵌套 'synchronized' 语句
inspection.display.name.synchronized.method=synchronized 方法
inspection.display.name.synchronization.on.this=在 'this' 上同步
inspection.display.name.empty.sync.block=空 'synchronized' 块
inspection.display.name.busy.wait=繁忙等待
inspection.display.name.public.field.accessed.in.synchronized.context=在同步上下文中访问的非 private 字段
inspection.display.name.unconditional.wait=无条件的 'wait' 调用
inspection.display.name.double.checked.locking=双重检查锁定
inspection.display.name.access.to.static.field.locked.on.instance=访问实例数据上锁定的 static 字段
inspection.display.name.change.to.method=运算符调用可替换为方法调用
inspection.display.name.change.to.operator=方法调用可替换为运算符调用
inspection.display.name.unnecessary.alias=不必要的导入别名
inspection.display.name.unnecessary.semicolon=不必要的分号
inspection.display.name.unnecessary.public.modifier=不必要的 'public'
inspection.display.name.unnecessary.def.modifier=不必要的 'def'
inspection.display.name.java.style.properties.invocation=Java 风格的属性访问
inspection.display.name.trivial.if=冗余的 'if' 语句
inspection.display.name.constant.if.statement=常量 if 语句
inspection.display.name.constant.conditional=恒定条件表达式
inspection.display.name.trivial.conditional=冗余条件表达式
inspection.display.name.return.from.closure.can.be.implicit='return' 语句可以是隐式语句
inspection.display.name.switch.statement.with.no.default=没有 default case 的 switch 语句
inspection.display.name.final.variable.access=final 变量访问
inspection.display.name.unnecessary.return=不必要的 'return' 语句
inspection.display.name.unnecessary.continue=不必要的 'continue' 语句
inspection.display.name.fallthrough='switch' 语句中的直落
inspection.display.name.if.statement.with.too.many.branches=具有过多分支的 if 语句
inspection.display.name.if.statement.with.identical.branches=具有相同分支的 if 语句
inspection.display.name.conditional.can.be.conditional.call=三元表达式可替换为安全调用
inspection.display.name.conditional.can.be.elvis=三元表达式可替换为 elvis 表达式
inspection.display.name.conditional.with.identical.branches=分支相同的三元表达式
inspection.display.name.loop.statement.that.doesnt.loop=不循环的循环语句
inspection.display.name.unreachable.statement=不可到达的语句
inspection.display.name.continue='continue' 语句
inspection.display.name.break='break' 语句
inspection.display.name.unused.catch.parameter=未使用的 'catch' 形参
inspection.display.name.empty.try.block=空 'try' 块
inspection.display.name.annotation.references.unknown.identifier=@TupleConstructor 和 @MapConstructor
inspection.display.name.unresolved.labels.in.named.variant=@NamedVariant/@NamedParam/@NamedDelegate 未解析标签
inspection.display.name.empty.finally.block=空 'finally' 块
inspection.display.name.empty.catch.block=空 'catch' 块
inspection.display.name.throw.from.finally.block='throw' 位于 'finally' 块内
inspection.display.name.return.from.finally.block='return' 位于 'finally' 块内
inspection.display.name.method.may.be.static=方法可以为 'static'
inspection.display.name.continue.or.break.from.finally.block='finally' 块中的 'continue' 或 'break'
inspection.display.name.unchecked.assignment.of.member.of.raw.type=原始类型成员中的未检查的赋值
inspection.display.name.silly.assignment=不实用的赋值
inspection.display.name.nested.assignment=嵌套赋值
inspection.display.name.assignment.to.method.parameter=赋值给方法形参
inspection.display.name.assignment.to.for.loop.parameter=赋值给 'for' 循环形参
inspection.display.name.assignability.check=不兼容的类型赋值
inspection.display.name.type.customizer=类型自定义工具检查
inspection.display.name.unused.declaration=未使用的声明
inspection.display.name.second.unsafe.call=第二次不安全的调用
inspection.display.name.unused.assignment=未使用的赋值
inspection.display.name.unused.inc.dec=未使用的递增或递减
inspection.display.name.unassigned.access=未分配变量
inspection.display.name.no.return=缺少 return 语句
inspection.display.name.clashing.getters=冲突的 getter
inspection.display.name.package.mismatch=软件包不匹配
inspection.display.name.deprecated.api.usage=弃用的 API 用法
inspection.display.name.unnecessary.qualified.reference=不必要的限定参考
inspection.display.name.pointless.boolean=无意义的布尔表达式
inspection.display.name.access.to.inaccessible.element=不可访问的元素
inspection.display.name.incorrect.range.argument=不正确的范围实参
inspection.display.name.new.instance.of.singleton=使用 @groovy.lang.Singleton 注解的类的新实例
inspection.display.name.check.labeled.statement=标签化语句检查
inspection.display.name.variable.can.be.final=变量可以为 final
inspection.display.name.equals.between.inconvertible.types='equals()' 位于不可转换类型的对象之间
inspection.display.name.singleton.constructor=@Singleton 构造函数
inspection.display.name.implicit.null.argument=隐式 null 实参
inspection.display.name.string.style.violation=字符串样式违规
inspection.message.access.to.static.field.locked.on.instance.data=访问实例数据中锁定的 static 字段 <code>#ref</code> #loc
inspection.message.assignment.replaceable.with.operator.assignment=<code>#ref</code> 可以简化为 ''{0}'' #loc
inspection.message.assignment.to.for.loop.parameter=赋值给 for 循环形参 '#ref' #loc
inspection.message.assignment.to.method.parameter=赋值给方法形参 '#ref' #loc
inspection.message.ref.statement=#ref 语句 #loc
inspection.message.call.to.thread.ref.in.a.loop=在循环中调用 <code>Thread.#ref()</code>，可能处于繁忙等待状态 #loc
inspection.message.conditional.expression.can.be.call=条件表达式可以是调用 #loc
inspection.message.conditional.expression.can.be.elvis=条件表达式可以是 elvis #loc
inspection.message.conditional.expression=条件表达式 #loc
inspection.message.conditional.expression.with.identical.branches=具有相同分支的条件表达式 #loc
inspection.message.ref.can.be.simplified='#ref' 可以简化 #loc
inspection.message.ref.statement.can.be.simplified=#ref 语句可以简化 #loc
inspection.message.constant.name.ref.too.short=常量名称 '#ref' 过短
inspection.message.constant.name.ref.too.long=常量名称 '#ref' 过长
inspection.message.constant.name.ref.doesnt.match.regex=常量名称 ''#ref'' 与正则表达式 ''{0}'' 不匹配 #loc
inspection.message.ref.inside.finally.block='finally' 块内的 '#ref' #loc
inspection.message.divide.by.zero=除以零 #loc
inspection.message.double.checked.locking=双重检查锁定 #loc
inspection.message.double.negation.ref=双重求反 #ref #loc
inspection.message.duplicate.switch.case.ref=重复 switch case '#ref' #loc
inspection.message.empty.ref.block=空 '#ref' 块 #loc
inspection.message.ref.statement.has.empty.branch='#ref' 语句具有空分支
inspection.message.ref.statement.has.empty.body='#ref' 语句具有空体
inspection.message.fallthrough.in.switch.statement='switch' 语句存在直落 #loc
inspection.message.gstring.used.as.maps.key=GString 用作映射的键 #loc
inspection.message.ref.statement.cannot.complete.without.throwing.exception=<code>#ref</code> 语句不能在未抛出异常的情况下完成 #loc
inspection.message.code.ref.code.recurses.infinitely.can.only.complete.by.throwing.exception=<code>#ref</code> 无限递归，只能以抛出异常完成 #loc
inspection.message.instance.method.name.ref.too.short=实例方法名称 '#ref' 过短
inspection.message.instance.method.name.ref.too.long=实例方法名称 '#ref' 过长
inspection.message.instance.method.name.ref.doesnt.match.regex=实例方法名称 ''#ref'' 与正则表达式 ''{0}'' 不匹配 #loc
inspection.message.instance.variable.name.ref.too.short=实例变量名称 '#ref' 过短
inspection.message.instance.variable.name.ref.too.long=实例变量名称 '#ref' 过长
inspection.message.couldnt.find.property.field.with.this.name=找不到使用此名称的属性或字段 #loc
inspection.message.instance.variable.name.ref.doesn.t.match.regex=实例变量名称 ''#ref'' 与正则表达式 ''{0}'' 不匹配 #loc
inspection.message.call.to.ref.can.be.keyed.access=对 '#ref' 的调用可以是键控访问 #loc
inspection.message.ref.statement.with.identical.branches=具有相同分支的 '#ref' 语句 #loc
inspection.message.ref.statement.with.too.many.branches=具有过多分支({0})的 ''#ref'' 语句 #loc
inspection.message.local.variable.name.ref.too.short=局部变量名称 '#ref' 过短
inspection.message.local.variable.name.ref.too.long=局部变量名称 '#ref' 过长
inspection.message.local.variable.name.ref.doesnt.match.regex=局部变量名称 ''#ref'' 与正则表达式 ''{0}'' 不匹配 #loc
inspection.message.code.ref.code.statement.doesnt.loop=<code>#ref</code> 语句不循环 #loc
inspection.message.method.ref.contains.too.many.parameters.0.1=方法 ''#ref'' 包含过多形参({0}>{1})
inspection.message.method.ref.has.too.many.negations=方法 ''#ref'' 包含过多否定({0} > 3)
inspection.message.ref.has.0.return.points=<code>#ref</code> 具有 {0} 个返回点 #loc
inspection.message.negated.conditional.expression=否定的条件表达式 #loc
inspection.message.negated.if.condition.expression=否定的 if 条件表达式 #loc
inspection.message.nested.assignment.expression=嵌套赋值表达式 #loc
inspection.message.nested.conditional.expression=嵌套条件表达式 #loc
inspection.message.nested.ref.statement=嵌套 '#ref' 语句 #loc
inspection.message.non.short.circuit.boolean.expression=非短路布尔表达式 #loc
inspection.message.call.to.ref.outside.synchronized.context=在同步上下文之外调用 '#ref' #loc
inspection.message.octal.integer.ref=八进制整数 #ref #loc
inspection.message.overly.complex.arithmetic.expression=过于复杂的算术表达式 #loc
inspection.message.overly.complex.boolean.expression=过于复杂的布尔表达式 #loc
inspection.message.method.ref.overly.complex.cyclomatic.complexity=方法 ''#ref'' 过于复杂(循环复杂度 = {0}>{1})
inspection.message.method.ref.too.long.statement.count=方法 ''#ref'' 过长(语句计数 = {0}>{1})
inspection.message.method.ref.overly.nested.nesting.depth=方法 ''#ref'' 过度嵌套(嵌套深度 = {0}>{1})
inspection.message.method.parameter.name.ref.too.short=方法形参名称 '#ref' 过短
inspection.message.method.parameter.name.ref.too.long=方法形参名称 '#ref' 过长
inspection.message.method.parameter.name.ref.doesnt.match.regex=方法形参名称 ''#ref'' 与正则表达式 ''{0}'' 不匹配 #loc
inspection.message.non.private.field.accessed.in.synchronized.context=在同步上下文中访问了非 private 字段 '#ref' #loc
inspection.message.nested.assignment=使用赋值表达式结果 #loc
inspection.message.result.increment.or.decrement.expression.used=使用递增或递减结果 #loc
inspection.message.result.of.new.ref.is.ignored=''new #ref{0}'' 的结果被忽略 #loc
inspection.message.ref.statement.at.end.closure.can.be.made.implicit=闭包结尾存在显式返回 #loc
inspection.message.silly.assignment=不实用的赋值 #loc
inspection.message.static.method.name.ref.too.short=static 方法名称 '#ref' 过短
inspection.message.static.method.name.ref.too.long=static 方法名称 '#ref' 过长
inspection.message.static.method.name.ref.doesnt.match.regex=static 方法名称 ''#ref'' 与正则表达式 ''{0}'' 不匹配 #loc
inspection.message.static.variable.name.ref.too.short=static 变量名称 '#ref' 过短
inspection.message.label.name.ref.not.supported.by.0={0} 不支持标签名称 ''#ref''
inspection.message.static.variable.name.ref.too.long=static 变量名称 '#ref' 过长
inspection.message.static.variable.name.ref.doesnt.match.regex=static 变量名称 ''#ref'' 与正则表达式 ''{0}'' 不匹配 #loc
inspection.message.property.0.is.final=属性 ''{0}'' 为 final #loc
inspection.message.ref.statement.with.no.default.branch=没有 'default' 分支的 #ref 语句 #loc
inspection.message.synchronization.on.non.final.field.ref=在非 final 字段 '#ref' 上同步 #loc
inspection.message.synchronization.on.ref=在 '#ref' 上同步 #loc
inspection.message.synchronization.on.variable.ref.which.was.initialized.with.literal=在使用文字初始化的 '#ref' 上同步 #loc
inspection.message.synchronized.method.ref=synchronized 方法 '#ref' #loc
inspection.message.call.to.system.ref=调用 'System.#ref' #loc
inspection.message.call.to.thread.ref=调用 'Thread.#ref' #loc
inspection.message.trivial.conditional.expression=普通条件表达式 #loc
inspection.message.property.0.is.ignored.by.map.constructor=属性 ''{0}'' 被 @MapConstructor 忽略 #loc
inspection.message.unconditional.call.to.ref=无条件调用 <code>#ref()</code> #loc
inspection.message.ref.is.unnecessary.as.last.statement.in.loop=#ref 不必要，因为是循环中的最后一条语句 #loc
inspection.message.ref.is.unnecessary.as.last.statement.in.method.with.no.return.value=#ref 不必要，因为它是没有返回值的方法中的最后一条语句 #loc
inspection.message.unreachable.statement=不可到达的语句 #loc
inspection.message.unsynchronized.method.ref.overrides.synchronized.method=非同步方法 '#ref' 重写了一个 synchronized 方法 #loc
inspection.message.cannot.determine.type.ref=无法确定 '#ref' 的类型
inspection.message.call.to.ref.outside.of.loop=在循环外部调用 '#ref' #loc
inspection.message.call.to.ref.outside.of.synchronized.context=在同步的上下文外部调用 '#ref' #loc
inspection.message.ref.loop.spins.on.field=<code>#ref</code> 循环在字段上自旋 #loc
inspection.message.package.name.mismatch=软件包名称不匹配
inspection.message.dsl.descriptor.file.has.been.changed.and.isnt.currently.executed=DSL 描述符文件已更改，当前未被执行
inspection.message.dsl.descriptor.file.has.been.disabled.due.to.processing.error=由于处理错误，DSL 描述符文件已被禁用
inspection.message.traits.0.contain.clashing.methods.with.signature.1=特征 {0} 包含带签名 {1} 的冲突方法
inspection.message.unused.catch.parameter.ref=未使用的 catch 形参 '#ref' #loc
inspection.message.package.name.mismatch.actual.0.expected.1=软件包名称不匹配。实际: ''{0}''，预期: ''{1}''
inspection.message.property.not.indexable.type.must.be.array.or.list.but.found.0=属性不可索引。类型必须为数组或列表，但实际为 {0}
inspection.message.type.argument.0.can.not.be.1=实参 ''{0}'' 的类型不能为 ''{1}''
inspection.message.method.called.with.implicit.null.argument=用隐式 null 实参调用方法
inspection.message.plain.string.should.be.double.quoted=普通字符串应当使用双引号引用
inspection.message.plain.string.should.be.single.quoted=普通字符串应当使用单引号引用
inspection.message.plain.string.should.be.slashy.quoted=普通字符串应当使用 / 引用
inspection.message.plain.string.should.be.dollar.slashy.quoted=普通字符串应当使用 $/ 引用
inspection.message.plain.string.should.be.quoted.with.triple.quotes=普通字符串应当使用 '''' 引用
inspection.message.plain.string.should.be.quoted.with.triple.double.quotes=普通字符串应当使用 """ 引用
inspection.message.multiline.string.should.be.quoted.with.triple.quotes=多行字符串应当使用 '''' 引用
inspection.message.multiline.string.should.be.quoted.with.triple.double.quotes=多行字符串应当使用 """ 引用
inspection.message.multiline.string.should.be.slashy.quoted=多行字符串应当使用 / 引用
inspection.message.multiline.string.should.be.dollar.slashy.quoted=多行字符串应当使用 $/ 引用
inspection.message.string.escaping.could.be.minimized=转义可以最小化
inspection.message.interpolated.string.should.be.double.quoted=插值字符串应当使用双引号引用
inspection.message.interpolated.string.should.be.dollar.slashy.quoted=插值字符串应当使用 $/ 引用
inspection.message.interpolated.string.should.be.slashy.quoted=插值字符串应当使用 / 引用
inspection.message.interpolated.string.should.be.quoted.with.triple.double.quotes=插值字符串应当使用 """ 引用
text.class.0.is.unused=类 {0} 未使用
text.constructor.0.is.unused=构造函数 {0} 未使用
text.method.0.is.unused=方法 {0} 未使用
text.property.0.is.unused=属性 ''{0}'' 未使用
text.parameter.0.is.unused=形参 {0} 未使用
### Intention groups ###
intention.category.groovy=Groovy
intention.category.conversions=Groovy/表达式转换
intention.category.closures=Groovy/闭包
intention.category.comments=Groovy/注释
intention.category.groovy.style=Groovy/Groovy 样式
intention.category.control.flow=Groovy/控制流
intention.category.groovy.declaration=Groovy/声明
intention.category.groovy.other=Groovy/其他
configurable.GroovyCompilerConfigurable.display.name=Groovy 编译器
configurable.GantConfigurable.display.name=Gant
settings.compiler.alternative=另外，您也可以在 <a href=\"#\">Java 编译器页面</a> 中指定 Groovy-Eclipse 编译器
settings.compiler.select.path.to.groovy.compiler.configscript=选择 Groovy 编译器配置脚本的路径
settings.compiler.path.to.configscript=配置脚本的路径(&C):
settings.compiler.invoke.dynamic.support=调用动态支持(&D)
settings.compiler.exclude.from.stub.generation=从存根生成中排除:
settings.code.style.label.indent.style=标签缩进样式:
settings.code.style.label.indent.size=标签缩进大小
settings.code.style.indent.statements.after.label=缩进标签后的语句
settings.code.style.absolute=绝对
settings.code.style.indent.labels=缩进标签
settings.inlay.parameter.types=形参类型
settings.inlay.inferred.parameter.types=推断的形参类型
settings.inlay.type.parameter.list=类型形参列表
settings.inlay.show.type.hints.for=显示类型提示:
intention.name.replace.with.in=将 ':' 替换为 'in'
intention.name.activate.back=重新激活
intention.name.cast.to.0=转换为 {0}
intention.name.replace.eq.with.0.eq=将 ''='' 替换为 ''{0}=''
intention.name.cast.operand.to.0=将操作数转换为 {0}
intention.name.add.required.attributes.to.map.constructor=将必要特性添加到 @MapConstructor
intention.name.convert.to.single.quoted.string=转换为带单引号的字符串
intention.name.change.quotes.to.triple.single.quotes=将引号更改为 ''''
intention.name.convert.to.double.quoted.string=转换为带双引号的字符串
intention.name.change.quotes.to.triple.double.quotes=将引号更改为 """
intention.name.convert.to.slashy.string=转换为 / 字符串
intention.name.convert.to.dollar.slashy.string=转换为 $/ 字符串
intention.family.name.create.field=创建字段
action.remove.dynamic.member.text=移除
action.remove.dynamic.member.description=移除动态成员
action.collapse.all.text=全部收起
action.collapse.all.description=全部收起
action.expand.all.text=全部展开
action.expand.all.description=全部展开
dynamic.members.column.name.element=动态元素
dynamic.members.column.name.type=类型
command.name.add.dynamic.member=添加动态成员
popup.content.navigation.to.overriding.classes.unavailable=索引更新时无法导航到重写类
overriding.methods.of.0=''{0}'' 的重写方法
expression.type.no.expression=找不到表达式
expression.type.unknown=<unknown>
add.class.to.extends.family.name=实现
intention.family.name.rename=重命名
generated.stub.message=此存根为 Groovy 类生成，目的是实现 Groovy-Java 交叉编译
generated.stub.navigate.link.label=转到 Groovy 类
generated.stub.exclude.link.label=从存根生成中排除
module.with.groovy=附加了 Groovy 库的简单模块
action.build.restart.text=构建并重启
action.build.module.restart.description=构建模块 ''{0}'' 并重启
gdsl.investigate.link.label=点击此处进行调查
gdsl.error.notification.title=DSL 脚本执行错误
dialog.message.gant.not.configured=未配置 Gant
investigate.gdsl.error.intention.name=查看详细信息
investigate.gdsl.error.family.name=调查 DSL 描述符处理错误
grab.intention.name=Grab 工件
grab.family.name=Grab
grab.progress.title=处理 @Grab 注解
grab.result.title=添加了 {0} 个 Grape 依赖项 {0, choice, 0#jar|1#jar|2#jar}
grab.jar.count=<b>{0}</b>: {1} 个 {1, choice, 0#jar|1#jar|2#jar}
grab.error.ivy.missing.title=缺少 Ivy
grab.error.ivy.missing.message=抱歉，如果没有 Apache Ivy，IDEA 无法 @Grab 依赖项。请将 Apache Ivy 添加到您的模块依赖项中，然后重新运行这项操作。
grab.error.0.title=无法运行 @Grab: {0}
this.super.completion.advertisement=不使用类限定符，按 {0} 两次会显示所有可访问的 static 方法
optimize.imports.progress.title=正在优化 Groovy 文件中的导入…
groovy.library.label=Groovy 库
replace.all.occurrences.and.remove.variable.0=替换所有匹配项并移除变量 ''{0}''
introduce.variable.declare.final.label=声明 final(&F)
introduce.variable.replace.all.occurrences=替换所有匹配项(&A)
introduce.variable.replace.all.0.occurrences=替换所有匹配项({0} 个匹配项)(&A)
introduce.parameter.delegate.via.overload=通过重载方法委托(&L)
introduce.parameter.replace.fields.border.title=将表达式中使用的字段替换为其 Getter
introduce.parameter.do.not.replace.option.label=不替换(&O)
introduce.parameter.replace.inaccessible.fields.option.label=替换用法上下文中不可访问的字段(&I)
introduce.parameter.replace.all.fields.option.label=替换所有字段(&R)
introduce.variable.type.label=类型(&T):
introduce.variable.name.label=名称(&N):
introduce.parameter.explicit.return.statement.option.label=使用显式 return 语句(&X)
introduce.parameter.delegating.unavailable.tooltip=闭包上下文中不允许委托
introduce.variable.change.type.advertisement=按 {0} 更改类型
framework.0.home.label={0} 主目录:
select.framework.0.home.title=选择 {0} 主目录
framework.0.sdk.chooser.title={0} SDK
framework.0.sdk.chooser.description=选择包含 {0} 分发版的目录
framework.0.sdk.chooser.error.message=指定路径中的 {0} 分发版似乎已损坏。无法确定版本。
framework.0.sdk.chooser.error.title=无法创建库
framework.0.library={0} 库
framework.0.library.version.1=版本 {1} 的 {0} 库
framework.gant=Gant
script.runner.display.name=Groovy
script.runner.description=Groovy 类或脚本
script.runner.chooser.title=脚本路径
script.runner.chooser.description=指定脚本路径
script.runner.module.not.specified.message=未指定模块
script.runner.no.groovy.for.module=没有为模块 ''{0}'' 配置 Groovy
script.runner.cant.find.script=找不到脚本 ''{0}''
script.runner.unknown.script.type=未知脚本类型 ''{0}''
script.runner.file.is.not.groovy.file=脚本文件不是 Groovy 文件
script.runner.class.does.not.exist=类不存在
script.runner.class.cannot.be.executed=类无法执行
dialog.title.refactoring.unavailable.in.current.scope=重构在当前范围中不可用
parameter.list.owner.chooser.title=将形参引入
extract.closure.command.name=提取闭包
introduce.constant.title=引入常量
undefined.library.version=未定义
method.parameters.count.max.parameters.option=最大形参数量:
method.returns.max.returns.option=返回点限制:
overly.complex.method.complexity.limit.option=方法复杂度限制:
overly.long.method.statements.limit.option=每个方法的最大语句数:
overly.nested.method.nesting.limit.option=最大嵌套深度:
add.method.family=添加方法
change.base.method.label=更改基方法
change.usages.label=更改用法
convert.parameter.to.map.entry.title=将形参转换为映射条目
live.template.context.declaration=声明
live.template.context.expression=表达式
live.template.context.statement=语句
find.usages.method.0.of.class.1={1} 的 {0}
change.signature.type.column=类型
change.signature.default.initializer.column=默认初始值设定项
static.import.method.fix=static 导入方法…
static.import.method.0.fix=static 导入方法 ''{0}''
groovy.consoles.type=Groovy 控制台
getter.kind.gdk.method.0=GDK 方法 {0}
getter.kind.method.0=方法 {0}
getter.kind.getter.0=Getter {0}
parameter.hint.number.of.arguments={0, choice, 0#|1#{0} 个实参|2#{0} 个实参}
surround.with.for=for
surround.with.if=if
surround.with.if.else=if / else
surround.with.if.expr=if (expr)
surround.with.if.else.expr=if (expr) / else
surround.with.parentheses=(expr)
surround.with.closure={ -> ... }.call()
surround.with.try=try
surround.with.try.catch=try / catch
surround.with.try.finally=try / finally
surround.with.try.catch.finally=try / catch / finally
surround.with.while=while
surround.with.while.expr=while (expr)
surround.with.cast=((Type) expr)
surround.with.with=with () {...}
surround.with.with.expr=with (expr)
surround.with.shouldFail=shouldFail () {...}
code.style.group.list.map.literals=列表和映射文字
code.style.option.align.when.multiple=多行时对齐
code.style.option.wrap.after.dot=在点后换行
code.style.option.align.multiline.named.arguments=对齐多行命名实参
code.style.option.use.flying.geese.braces=使用雁形大括号
code.style.option.import.annotations=导入注解
code.style.option.simple.lambdas.closures.in.one.line=简单的 lambda/闭包位于一行中
code.style.option.relational.operators=关系运算符 (<, >, <=, >=, <=>)
code.style.option.unary.operators=一元运算符 (!, -, +, ++, --, *)
code.style.option.in.named.argument.before.colon=在 ':' 之前的命名实参中
code.style.option.in.named.argument.after.colon=在 ':' 之后的命名实参中
code.style.option.list.maps.literals=列表和映射文字
code.style.option.closure.left.brace.in.method.calls=方法调用中有结束左大括号
code.style.option.gstring.injection.braces=GString 注入大括号
code.style.option.tuple.assignment.expression=元组赋值表达式
code.style.option.regexp.expression=正则表达式 (==~, =~)
code.style.option.before.assert.separator=在 'assert' 分隔符前面
code.style.option.after.assert.separator=在 'assert' 分隔符后面
# @Singleton
singleton.constructor.found=@Singleton 类不应有构造函数
singleton.constructor.remove=移除构造函数
singleton.constructor.makeNonStrict=使 @Singleton 非 strict
########################################################################################################################
# Unused imports
########################################################################################################################
unused.import=未使用的 import
optimize.imports=优化 import
optimize.all.imports=优化未使用的 import 语句
########################################################################################################################
# Create class fix
########################################################################################################################
dialog.create.class.package.chooser.title=选择目标软件包
create.directory.command=创建目录
destination.package=目标软件包:
second.unsafe.call=第二次不安全的调用
call.can.throw.npe=调用链可能抛出 NullPointerException
unused.default.parameter.message=未使用默认形参
unused.default.parameter.fix=移除初始值设定项
unused.assignment.tooltip=未使用赋值
unused.variable=未使用变量
variable.can.be.final.tooltip=变量 ''{0}'' 可以为 final
parameter.can.be.final.tooltip=形参 ''{0}'' 可以为 final
equals.between.inconvertible.types.tooltip=<code>{0}</code> 位于不可转换的 ''{1}'' 和 ''{2}'' 类型的对象之间
replace.with.operator.message=''{0}'' 可替换为运算符
replace.with.operator.fix=将 ''{0}'' 替换为运算符
replace.with.operator.double.negation.option=使用双重求反(即 !!)
replace.with.operator.compareTo.equality.option=将 'compareTo' 等式替换为等号(即 ==)
replace.with.operator.parentheses=如果需要附加圆括号，则不建议替换为运算符
replace.with.method.message=可替换为 ''{0}'' 方法调用
replace.with.method.fix=替换为 ''{0}'' 方法
unassigned.access.tooltip=变量 ''{0}'' 可能未被赋值
no.return.message=并非所有执行路径都返回值
unresolved.type.status=类型 ''{0}'' 未解析
no.type.specified=未指定类型
dynamic.element=动态元素
pointless.boolean.problem.descriptor=冗余布尔运算 #loc
pointless.arithmetic.error.message=冗余算术运算 #loc
pointless.boolean.quickfix=简化
Cannot.perform.undo.operation=无法执行撤消操作
Undo.disable=撤消已禁用
type.doesnt.contain.method=类型 ''{0}'' 不能在范围内进行迭代，因为它没有方法 ''{1}''
type.doesnt.implement.comparable=类型 ''{0}'' 未实现 Comparable
add.method=将方法 ''{0}()'' 添加到类 ''{1}''
implement.class=实现 {0}
fix.class=修正类 {0}
rtype.cannot.contain.ltype=''{1}'' 不能包含 ''{0}''
new.instance.of.singleton=使用 @groovy.lang.Singleton 注解的类的新实例
replace.new.expression.with.instance.access=替换为实例访问
getter.0.clashes.with.getter.1=发生冲突: ''{0}'' 和 ''{1}''
unused.0=未使用的{0}
remove.0=移除 {0}
replace.postfix.0.with.prefix.0=将后缀 {0} 替换为前缀 {0}
replace.0.with.1=将 {0} 替换为二进制 {1}
local.var.0.is.reassigned=局部变量 ''{0}'' 已重新赋值
anonymous.class=匿名类
closure=闭包
other.scope=其他范围
method.may.be.static=方法可能为 static
method.may.be.static.option.ignore.trait.methods=忽略特征方法
method.may.be.static.only.private.or.final.option=仅检查 final 或 private 方法
method.may.be.static.ignore.empty.method.option=忽略空方法
ignore.boolean.expressions=在布尔检查中忽略未被赋值的变量
highlight.if.groovy.object.methods.overridden=高亮显示来自重写 invokeMethod()、getProperty() 或 setProperty() 的类的引用
highlight.if.missing.methods.declared=高亮显示来自声明 missingMethod() 或 missingProperty() 的类的引用
gr.package.inspection.check.scripts=检查脚本
java.style.property.access=Java 样式访问器调用
type.customizer.is.not.marked.as.a.resource.file=类型定制器脚本未被标记为编译器资源
add.to.resources=添加到资源
add.type.customizer.to.resources=将类型定制器脚本添加到资源
target.0.does.not.exist=目标 ''{0}'' 不存在
target.annotation.is.unused=@Target 未使用
change.lvalue.type=将变量 ''{0}'' 类型更改为 ''{1}''
replace.qualified.name.with.import=将限定名称替换为导入
comments.count.as.content=注释计为内容
ignore.when.catch.parameter.is.named.ignore.or.ignored=当 catch 形参被命名为 ignore 或 ignored 时忽略
no.applicable.signature.found=未找到适用的签名
expected.type.0=应为 ''{0}''，但实际为 ''{1}''
declare.explicit.implementations.of.trait=声明特征的显式实现
unnecessary.modifier.description=修饰符 ''{0}'' 不必要
unnecessary.modifier.remove=移除不必要的 ''{0}''
unnecessary.def.explicitly.typed.only=仅在显式类型声明中报告
unnecessary.alias.fix=移除不必要的别名
unnecessary.alias.description=别名不必要
unnecessary.semicolon.description=分号不必要
unnecessary.semicolon.fix=移除分号
dynamic.dialog.class.label=类(&C):
dynamic.dialog.type.label=类型(&T):
dynamic.dialog.static.checkbox=static(&S)
find.method.ro.method.usages=正在项目文件中搜索封闭方法的用法
find.method.ro.closure.usages=正在项目文件中搜索封闭闭包的用法
conversion.method.not.allowed.in.non.groovy.files=不允许重构在非 Groovy 文件中具有匹配项的方法:
conversion.closure.not.allowed.in.non.groovy.files=不允许重构在非 Groovy 文件中具有匹配项的闭包:
wrong.method.first.parameter.type=方法 ''{0}'' 与命名实参一起使用，但它的第一个形参 ''{1}'' 不符合 Map 类型。
wrong.closure.first.parameter.type=闭包 ''{0}'' 与命名实参一起使用，但它的第一个形参 ''{1}'' 不符合 Map 类型。
map.parameter.dialog.create.new.checkbox=为命名实参创建新形参(&C)
map.parameter.dialog.explicit.type.checkbox=显式指定类型
convert.cannot.itself=重构不适用于映射形参本身
map.param.name=映射形参名称(&N):
convert.param.to.map.entry=将形参转换为映射条目
closure.used.as.variable=闭包作为实参传递。重构会破坏语义。
do.you.want.to.change.method.return.type=是否要更改 ''{0}'' 方法的返回类型
do.you.want.to.change.variable.type=是否要更改 ''{0}'' 的类型
closure.is.accessed.outside.of.groovy=在 Groovy 外部访问字段 <b>{0}</b>
write.access.to.closure.variable=字段 <b>{0}</b> 的写入访问权限
field.is.used.in.argument.label=在实参标签中使用字段 <b>{0}</b>
method.with.signature.already.exists=具有签名 {0} 的方法已存在
field.already.exists=字段 <b>{0}</b> 已存在
method.is.used.outside.of.groovy=在 Groovy 外部使用方法
do.you.want.to.change.type.of.parameter.in.method=是否要更改方法 ''{1}'' 中形参 ''{0}'' 的类型
file.exists=文件 ''{0}'' 在目录 ''{1}'' 中已存在
move.to.correct.dir.family.name=将文件移至正确的软件包
move.to.correct.dir=移至 ''{0}''
add.return.type=添加返回类型
add.return.type.to.method.declaration=将返回类型添加到方法声明
infer.method.parameters.types=向形参中添加显式类型
infer.method.parameters.types.for.method.declaration=为方法声明中的所有形参添加显式类型
replace.with.wrapper=替换为 {0}
replace.primitive.type.with.wrapper=将基元类型替换为包装器
remove.parameter.0=移除形参 ''{0}''
remove.unused.parameter=移除未使用的形参
remove.exception=移除异常
remove.catch.block=移除 catch 块
try.catch.fix=Try-catch 修正
cannot.create.class=无法创建类
rename.file.to.0=将文件重命名为 ''{0}''
java.style.properties.invocation.intention.family.name=将 Java 样式访问器调用更改为 Groovy 样式属性引用
java.style.properties.invocation.intention.name=更改为 Groovy 样式属性引用
generate.equals.and.hashcode.already.defined.warning.anonymous=equals() 和 hashCode() 已定义
generate.equals.and.hashcode.already.defined.warning=equals() 和 hashCode() 已定义
generate.equals.and.hashcode.already.defined.title=equals() 和 hashCode() 已定义
generate.equals.compare.nested.arrays.comment= //比较嵌套数组 - 此处 {0} 的值
generate.equals.compare.arrays.comment= //可能不正确 - 使用 Arrays.equals 比较 Object[] 数组
generate.property.missing.already.defined.warning=propertyMissing() 已定义
generate.property.missing.already.defined.title=propertyMissing() 已定义
generate.method.missing.already.defined.warning=methodMissing() 已定义
generate.method.missing.already.defined.title=methodMissing() 已定义
action.Gant.NewScript.text=Gant 脚本
action.Gant.NewScript.description=创建新的 Gant 脚本
action.Groovy.Console.text=Groovy 控制台
action.Groovy.Console.description=启动 Groovy 控制台
module.name.0.and.groovy.version.1={0} ({1})
groovy.version.0=Groovy {0}
groovy.version.bundled.0=捆绑的 Groovy {0}
configurable.greclipse.border.title=Groovy-Eclipse 选项
configurable.greclipse.path.label=Groovy-eclipse-batch jar 路径:
configurable.greclipse.path.chooser.description=选择版本与您的 Groovy 分发版相匹配的 groovy-eclipse-batch-*.jar 的路径
configurable.greclipse.command.line.params.label=附加命令行形参:
configurable.greclipse.debug.checkbox=生成调试信息
configurable.hotswap.checkbox=为 Groovy 代码启用热交换代理
configurable.hotswap.checkbox.description=可能在已调试的应用程序中导致序列化问题
run.configuration.script.path.label=脚本路径:
run.configuration.module.chooser.label=模块(&M):
run.configuration.module.classpath.checkbox=向运行程序中添加模块类路径(&C)
pull.up.wont.be.accessible.from=无法从 {1} 访问 {0}
pull.up.wont.be.accessible.from.the.subclass={0} 使用 {1}，后者无法从子类访问。
pull.up.abstract.wont.be.accessible.from=无法将 {0} 设为 abstract，因为无法通过子类对其进行访问。
settings.inlay.implicit.null.argument=隐式 null 实参
settings.inlay.show.hints.for.implicit.null.argument=显示有关隐式 null 实参的提示
header.extract.closure=提取闭包
string.sort.default=默认
string.sort.strings.with.escaping=包含转义的字符串
string.sort.strings.with.interpolation=包含插值的字符串
string.sort.multiline.string=多行字符串
separator.preferable.string.kind=首选种类
separator.domain.of.inspection.usage=用法域
checkbox.inspect.gradle.files=检查 Gradle 文件
string.option.do.not.handle.specifically=不做特别处理
string.option.double.quoted.string=带双引号的字符串
string.option.single.quoted.string=带单引号的字符串
string.option.slashy.string=/ 字符串
string.option.triple.quoted.string=带三引号的字符串
string.option.triple.double.quoted.string=带三个双引号的字符串
string.option.dollar.slashy.string=$/ 字符串
gdsl.trusted.project.message=此项目包含 Groovy DSL (GDSL)脚本，这些脚本可以提升在编辑 Groovy 代码时的代码洞察体验。GDSL 脚本可能包含潜在的恶意代码，这些代码将在 IDE 中执行。要运行吗?
gdsl.trusted.project.answer.trust=是
gdsl.trusted.project.answer.dont.trust=否
local.variable.types=局部变量类型
settings.inlay.show.variable.type.hints=显示局部变量类型提示
settings.inlay.put.type.hint.before.identifier=将类型提示放在标识符前面

dialog.title.select.groovy.sdk=选择 Groovy SDK
label.groovy.sdk=Groovy SDK:
groovy.term.type.parameter=类型形参
documentation.cannot.infer.type.label=无法推断类型
documentation.inferred.type.label=推断类型
documentation.gdk.label=GDK
inspection.message.modifier.sealed.available.with.groovy.or.later=修饰符 'sealed' 在 Groovy 4.0 或更高版本中可用
illegal.sealed.modifier.fix=移除 'sealed' 修饰符
inspection.message.modifier.nonsealed.available.with.groovy.or.later=修饰符 'non-sealed' 在 Groovy 4.0 或更高版本中可用
illegal.nonsealed.modifier.fix=移除 'non-sealed' 修饰符
inspection.message.permits.available.with.groovy.4.or.later='permits' 在 Groovy 4.0 或更高版本中可用
inspection.message.only.one.final.sealed.non.sealed.should.be.applied.to.class=仅应将 'final'、'sealed'、'non-sealed'、@Sealed 或 @NonSealed 中的一个应用到类
inspection.message.modifier.sealed.cannot.be.applied.to.enum.class=修饰符 'sealed' 无法应用到枚举类
inspection.message.modifier.non.sealed.cannot.be.applied.to.enum.class=修饰符 'non-sealed' 无法应用到枚举类
inspection.message.invalid.permits.clause.must.be.sealed=无效的 ''permits'' 子句: ''{0}'' 必须为 ''sealed''
inspection.message.invalid.permits.clause.must.directly.extend=无效的 ''permit '' 子句: ''{0}'' 必须直接扩展 ''{1}''
inspection.message.modifier.non.sealed.redundant=修饰符 'non-sealed' 冗余
inspection.message.not.allowed.in.sealed.hierarchy=密封层次结构中不允许使用 ''{0}''
inspection.display.name.unnecessary.sealed.modifier=不必要的 'sealed' 修饰符
inspection.display.name.unnecessary.non.sealed.modifier=不必要的 'non-sealed' 修饰符
inspection.message.interface.has.no.explicit.or.implicit.implementors=接口 ''{0}'' 没有显式或隐式允许的实现者
inspection.message.class.has.no.explicit.or.implicit.subclasses=类 ''{0}'' 没有显式或隐式允许的子类
inspection.display.name.non.extending.permitted.subclasses=不可扩展的允许的子类
sealed.visibility.presentation=sealed
non.sealed.visibility.presentation=non-sealed
intention.family.name.add.class.to.clause=将类添加到子句
intention.name.add.to.implements.clause=将 ''{0}'' 添加到 implements 子句
intention.name.add.to.extends.clause=将 ''{0}'' 添加到 extends 子句
intention.name.add.to.permits.clause=将 ''{0}'' 添加到 permits 子句
inspection.message.interface.cannot.be.non.sealed.without.sealed.parent=接口 ''{0}'' 无密封父级时不能为 non-sealed
inspection.message.class.cannot.be.non.sealed.without.sealed.parent=类 ''{0}'' 无密封父级时不能为 non-sealed
inspection.message.annotation.sealed.cannot.be.applied.to.enum.class=注解 '@Sealed' 无法应用到枚举类
inspection.message.annotation.non.sealed.cannot.be.applied.to.enum.class=注解 '@NonSealed' 无法应用到枚举类
dialog.title.specify.groovy.sdk=指定 Groovy SDK 主目录
dialog.title.no.jdk.specified.error=未指定 Groovy SDK
dialog.title.no.jdk.specified.title=未指定 Groovy SDK
dialog.title.no.jdk.specified.prompt=要创建未分配 SDK 的项目吗?
inspection.message.switch.expressions.are.available.with.groovy.4.or.later=切换表达式在 Groovy 4.0 或更高版本中可用
inspection.message.arrows.in.case.expressions.are.available.with.groovy.4.or.later=case 表达式中的箭头在 Groovy 4.0 或更高版本中可用
inspection.message.multiple.expressions.in.case.section.are.available.with.groovy.4.or.later=case 标签中的多个表达式在 Groovy 4.0 或更高版本中可用
inspection.message.keyword.yield.available.with.groovy.4.or.later=关键字 'yield' 在 Groovy 4.0 或更高版本中可用
inspection.message.mixing.arrows.colons.not.allowed=不允许混合使用箭头和冒号
inspection.message.yield.or.throw.expected.in.case.section='yield' 或 'throw' 应出现在 case 部分中
inspection.message.switch.expressions.do.not.support.return=switch 表达式不支持 'return'
intention.name.replace.return.with.yield=将 'return' 替换为 'yield'
intention.family.name.replace.keywords=替换关键字
inspection.message.case.or.default.branches.are.expected=应为 'case' 或 'default' 分支
inspection.display.name.switch.exhaustiveness.check=switch 表达式的详尽性检查
inspection.message.switch.expression.does.not.cover.all.possible.outcomes=switch 表达式未涵盖所有可能的结果
intention.family.name.add.missing.case.branches=添加缺少的 case 分支
intention.name.insert.default.branch=插入 'default' 分支
intention.name.insert.case.0=插入 ''case {0}''
intention.name.insert.case.0.case.1=插入 ''case {0}''、''case {1}''
intention.name.insert.missing.branches=插入缺少的分支
checkbox.report.unmatched.null=报告不匹配的 'null'
inspection.message.left.open.ranges.are.available.in.groovy.4.or.later=左开右闭范围在 Groovy 4.0 或更高版本中可用
inspection.message.both.open.ranges.are.available.in.groovy.4.or.later=两端开放范围在 Groovy 4.0 或更高版本中可用
inspection.message.fraction.literals.without.leading.zero.are.available.in.groovy.or.later=不带前导零的分数文字在 Groovy 4.0 或更高版本中可用
inspection.message.cannot.resolve.method.call=无法解析方法 'call'
intention.family.name.replace.modifiers=替换修饰符
leave.only.modifier.or.annotation.0=只保留 ''{0}''
add.modifier.sealed=添加修饰符 'sealed'
inlay.groovy.implicit.null.argument.hint.description=不向接受一个实参的方法传递实参的调用，这意味着隐式 null 将作为实参传递。
inlay.groovy.parameters.hints.inferred.parameter.types=方法中的推断形参类型。
inlay.groovy.parameters.hints.type.parameter.list=Methods with one or more inferred type parameters. Requires the <b>Inferred parameter types<b/> hint.
inspection.display.name.pojo.without.compile.static=无 @CompileStatic 的 @POJO
inspection.message.pojo.has.effect.only.with.compilestatic=@POJO 仅对 @CompileStatic 有效
add.compilestatic=添加 @CompileStatic
groovy.term.record=记录
code.style.option.before.record.parameter.list=记录形参列表前
inspection.message.records.are.available.in.groovy.4.or.later=记录在 Groovy 4.0.0-beta-2 或更高版本中可用
inspection.display.name.unnecessary.final.modifier=不必要的 'final'
inspection.message.0.not.allowed.for.record=记录不允许 ''{0}''
intention.name.remove.wrong.modifiers.for.record=移除记录的错误修饰符
inspection.message.compact.constructor.should.have.explicit.visibility.modifier=紧凑构造函数必须具有显式的可见性修饰符
intention.name.make.compact.constructor.public=将紧凑构造函数设为 'public'
inspection.message.record.parameter.should.be.immutable=记录形参 ''{0}'' 应具有不可变类型或使用 @ImmutableOptions 声明为不可变类型
dialog.title.validation.path.should.not.be.empty=路径不应为空
dialog.title.validation.path.does.not.contain.groovy.sdk=路径不包含 Groovy SDK
dialog.title.validation.invalid.sdk.specified.title=指定的 Groovy SDK 无效
dialog.title.validation.invalid.sdk.specified.error=指定的 Groovy SDK 无效
dialog.title.validation.directory.you.specified.does.not.contain.groovy.sdk.do.you.want.to.create.project.with.this.configuration=您指定了一个不包含 Groovy SDK 的目录。要使用此配置创建项目吗?
inspection.separator.disable.in.file.types=在文件类型中启用:
postfix.template.provider.name=Groovy
new.project.wizard.groovy.retrieving.has.failed=无法检索 Groovy 版本
new.project.wizard.groovy.creating.main.file=正在创建 Groovy 主文件…
cannot.assign.a.value.to.final.variable.0=无法将值赋给 final 变量 ''{0}''
new.class.list.item.record=记录
create.record.text=创建记录 {0}
code.style.groovydoc.tab.name=GroovyDoc
notification.group.groovy.dsl=Groovy DSL 错误
notification.group.grape=Groovy @Grab 注解已处理
inlay.groovy.variable.type.hints.description=显示局部变量类型提示
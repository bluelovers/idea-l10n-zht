0=\ ({0})
0.1={0}，{1}
0.1.choice.0.extends.1.implements.2={0}{1, choice, 0\# 扩展 |1\# 执行 }{2}
0.12={0}\:{1}
0.and.1.define.the.same.property.2=''{0}'' 和 ''{1}'' 定义相同的属性 ''{2}''
0.by.remote.interpreter=通过远程解释器{0}
0.completion.shortcut=使用{1}进行{0}补全
0.extends.1={0} 扩展 {1}
0.for.1.run.configuration={1} 运行配置的 {0}
0.local={0}本地
0.location={0} 位置
0.path={0} 路径\:
0.pushing.members.down.will.result.in.them.being.deleted={0}\n向下推送成员将导致它们被删除
0.should.not.extend.itself={0} 不应自行扩展
0.with.same.name.already.defined.in.this.class=此类中已经定义了具有相同名称的{0}
02={0}\:\:
03=({0})
04={0}\:
12.hour.format.of.an.hour.with.leading.zeros=带前导零的 12 小时格式小时(01 到 12)
12.hour.format.of.an.hour.without.leading.zeros=不带前导零的 12 小时格式小时(1 到 12)
24.hour.format.of.an.hour.with.leading.zeros=带前导零的 24 小时格式小时(00 到 23)
24.hour.format.of.an.hour.without.leading.zeros=不带前导零的 24 小时格式小时(0 到 23)
DBGPProxyConfigurable.display.name=DBGp 代理
DBGPProxyConfigurable.host=主机\:
DBGPProxyConfigurable.ide.key=IDE 键\:
DBGPProxyConfigurable.port=端口\:
PhpBuiltInWebServerRunConfigurationEditor.configuration.description=PHP 内置 Web 服务器配置
PhpBuiltInWebServerRunConfigurationEditor.configuration.display.name=PHP 内置 Web 服务器
PhpBuiltInWebServerRunConfigurationEditor.document.root=文档根\:
PhpBuiltInWebServerRunConfigurationEditor.host=主机\:
PhpBuiltInWebServerRunConfigurationEditor.port=端口\:
PhpBuiltInWebServerRunConfigurationEditor.title=服务器配置
PhpBuiltInWebServerRunConfigurationEditor.use.router.script=使用 router 脚本\:
PhpCommandLineConfigurationEditor.command.line=命令行
PhpCommandLineConfigurationEditor.field.custom.working.directory=自定义工作目录\:
PhpCommandLineConfigurationEditor.field.environment.variables=环境变量\:
PhpCommandLineConfigurationEditor.field.interpreter.options=解释器选项\:
PhpCommandLineConfigurationEditor.interpreter.options.editor.dialog.caption=解释器选项
PhpDebugConfigurable.advanced.settings=高级设置
PhpDebugConfigurable.break.at.first.line=在 PHP 脚本中的第一行中断
PhpDebugConfigurable.detect.path.mappings.from.deployment=检测部署配置的路径映射
PhpDebugConfigurable.evaluation=评估
PhpDebugConfigurable.external.connections=外部连接
PhpDebugConfigurable.ignore.external.connections.through.unregistered.server.configurations.label=通过未注册的服务器配置忽略外部连接
PhpDebugConfigurable.import.use.statements=从求值上下文导入命名空间和 'use' 语句
PhpDebugConfigurable.notify.resolved.breakpoint=通知是否将断点解析为另一行(Xdebug 2.8+)
PhpDebugConfigurable.notify.session.stopped.without.pause=在调试会话完成而不暂停时通知
PhpDebugConfigurable.pass.required.configuration.options=通过命令行传递所需配置选项(仍需要手动启用调试扩展)
PhpDebugConfigurable.remote.debug.listen.for.connections=3. 启动“PHP 远程调试”运行配置。
PhpDebugConfigurable.safe.evaluation.mode=值提示和监视框架下的安全求值模式
PhpDebugConfigurable.show.array.children.in.repl=在调试控制台中显示数组和对象子级
PhpDebugConfigurable.web.page.listen.for.connections=2. 启动“PHP 网页”运行配置。
PhpDebugConfigurable.web.page.pre.config.title=调试预配置
PhpDebugConfigurable.xdebug=Xdebug
PhpDebugConfigurable.xdebug.debug.port=Xdebug 调试端口
PhpDebugConfigurable.xdebug.force.break.no.path.mapping=未指定路径映射时，在第一行强制中断
PhpDebugConfigurable.xdebug.force.break.when.outside.project=当脚本在项目外部时，在第一行强制中断
PhpDebugConfigurable.xdebug.resolve.breakpoints=如果断点在当前行不可用，则解析断点(Xdebug 2.8+)
PhpDebugConfigurable.zend.debug.port=Zend Debugger 调试端口
PhpDebugConfigurable.zend.debugger=Zend 调试器
PhpDebugConfigurable.zend.settings.broadcasting.port=Zend Debugger 设置广播端口
PhpDebugConfigurable.zend.settings.ide.hosts=Zend Debugger IDE 主机
PhpDebugConfigurable.zend.settings.ide.hosts.detect=正在检测…
PhpDebugConfigurable.zend.settings.ide.hosts.detect.progress=正在检测 Zend Debugger 的 IP…
PhpDebugConfigurable.zero.configuration=预配置
PhpDebugConfigurable.zero.configuration.install.debugger.php.instruction=1. 安装
PhpDebugConfigurable.zero.configuration.install.php.instruction=或
PhpDebugConfigurable.zero.configuration.install.php.validate=Web 服务器上的调试器配置。
PhpDebugConfigurable.zero.configuration.install.php.validate.action=验证
PhpDebugConfigurable.zero.configuration.install.toolbar.instruction=浏览器工具栏或小书签。
PhpDebugConfigurable.zero.configuration.install.toolbar.instruction.label=2. 安装
PhpDebugConfigurable.zero.configuration.install.xdebug.php.instruction=Xdebug
PhpDebugConfigurable.zero.configuration.install.zend.debugger.php.action=Zend 调试器
PhpDebugConfigurable.zero.configuration.install.zend.debugger.php.instruction=在 Web 服务器上。
PhpDebugConfigurable.zero.configuration.listen.for.connections=3. 启用 PHP 调试连接侦听\:
PhpDebugConfigurable.zero.configuration.listen.for.connections.action=开始侦听
PhpDebugConfigurable.zero.configuration.start.session=4. 使用工具栏或小书签在浏览器中启动调试会话。
PhpDebugConfigurable.zero.configuration.stop.listen.for.connections.action=停止侦听
PhpDebugConfigurable.zero.configuration.tutorial=有关更多信息，请参见
PhpDebugConfigurable.zero.configuration.tutorial.action=“零配置调试”教程
PhpDebugSkippedPathsConfigurable.column.title=跳过的路径
PhpDebugSkippedPathsConfigurable.display.name=跳过的路径
PhpDebugSkippedPathsConfigurable.notify.about.skipped.files=通知跳过的文件
PhpExtractMethodDialog.declare.static=声明 static(&S)
PhpExtractMethodDialog.duplicates.count=检查并替换重复项(找到 {0} 个)
PhpExtractMethodDialog.duplicates.pending=正在搜索重复项…
PhpExtractMethodDialog.extract.function=提取函数
PhpExtractMethodDialog.extract.method=提取方法
PhpExtractMethodDialog.function=函数\:
PhpExtractMethodDialog.generate.php.doc=生成 PhpDoc(&G)
PhpExtractMethodDialog.generate.php.doc.inplace=生成 PHPDoc
PhpExtractMethodDialog.method=方法\:
PhpExtractMethodDialog.name=名称(&A)\:
PhpExtractMethodDialog.output.variables=输出变量
PhpExtractMethodDialog.parameters=形参
PhpExtractMethodDialog.private=private(&V)
PhpExtractMethodDialog.protected=protected(&T)
PhpExtractMethodDialog.public=public(&B)
PhpExtractMethodDialog.replace.tail.break.continue.with.return=将尾“break/continue”语句替换为“return”语句(&T)
PhpExtractMethodDialog.return.output.through=通过以下方式返回输出变量\:
PhpExtractMethodDialog.return.output.through.ref.parameters=通过引用传递的形参(&P)
PhpExtractMethodDialog.return.output.through.return=return 语句(&E)
PhpExtractMethodDialog.signature.preview=签名预览
PhpExtractMethodDialog.transformation.options=转换选项
PhpExtractMethodDialog.visibility=可见性\:
PhpFrameworksCommonConfigurable.display.name=框架
PhpHttpRequestRunConfiguration.configuration.description=HTTP 请求配置
PhpHttpRequestRunConfiguration.configuration.display.name=PHP HTTP 请求
PhpHttpRequestRunConfiguration.error.fetch.result=响应正文不可用
PhpHttpRequestRunConfiguration.error.host.is.not.specified=服务器 ''{0}'' 的主机未指定或无效
PhpHttpRequestRunConfiguration.error.server.configuration=无法执行 HTTP 请求\: ''{0}''。请在“PHP|服务器”下检查服务器配置。
PhpHttpRequestRunConfiguration.error.server.is.not.specified=找不到名称为 ''{0}'' 的远程服务器
PhpHttpRequestRunConfiguration.error.url.is.not.specified=URL 未指定或无效\: ''{0}''。
PhpIncomingConnectionDialog.file.path.on.server=服务器上的文件路径\:
PhpIncomingConnectionDialog.request.uri=请求 URI\:
PhpIncomingConnectionDialog.server.name=服务器名称\:
PhpIncomingConnectionDialog.server.port=服务器端口\:
PhpIncomingLocalConnectionDialog.file.path=文件路径\:
PhpInterpreter.configuration.duplicate.interpreter.name=找到了具有非唯一名称 ''{0}'' 的 PHP 解释器。
PhpInterpreter.configuration.in.project.settings.message=无法将 PHP 解释器指定为默认 SDK。您可以在“设置| PHP”中为当前项目配置
PhpInterpreter.configuration.in.project.settings.title=PHP 解释器配置
PhpInterpreter.configuration.interpreter.is.invalid=启用“PHP Remote Interpreters”插件以编辑解释器。
PhpInterpreter.configuration.selection.list.title=选择 CLI 解释器
PhpInterpreter.php.debugger.label=调试器\:
PhpInterpreter.php.dependent.configuration.exists=所选 PHP 解释器有{0}配置。确定要删除此解释器吗?
PhpInterpreter.php.dependent.configuration.exists.title=PHP 解释器依赖配置
PhpInterpreter.php.general.title=常规
PhpInterpreter.php.home.path.label=PHP 可执行文件\:
PhpInterpreter.php.interpreter.name.conflict=发现项目级和应用程序级解释程序名称存在冲突。为解决该问题，以下项目级解释器被重命名\:
PhpInterpreter.php.interpreter.name.conflict.title=解释器名称冲突
PhpInterpreter.php.sdk.type=PHP 解释器
PhpInterpreterConfigurable.can.not.updated.phpinfo=无法更新 phpinfo
PhpInterpreterConfigurable.configuration.default.project.tooltip=无法仅为默认项目保存解释器。
PhpInterpreterConfigurable.configuration.file.can.not.find=无法通过路径找到文件\: ''{0}''
PhpInterpreterConfigurable.configuration.file.can.not.find.title=找不到配置文件
PhpInterpreterConfigurable.configuration.file.evaluate.dir=正在评估配置文件目录…
PhpInterpreterConfigurable.configuration.file.fix=在 {0} 目录中创建 php.ini 文件，<br><br>配置文件模板可在 php 根文件夹中找到\:<br>“php.ini-development”- 默认设置<br>“php.ini-production”- 推荐设置。<br>
PhpInterpreterConfigurable.configuration.file.fix.failed.to.detect=使用“{0} --ini”命令确定配置文件目录。<br>
PhpInterpreterConfigurable.configuration.file.fix.link=<br>点击此<a href\="http\://php.net/manual/en/configuration.file.php">链接</a>获取更多信息。
PhpInterpreterConfigurable.configuration.file.fix.title=配置 php.ini 文件不存在
PhpInterpreterConfigurable.configuration.file.hhvm.fix=在 <b>/etc/hhvm</b> 目录中创建 php.ini 文件，<br><br>点击此<a href\="http\://docs.hhvm.com/manual/en/configuration.file.php">>链接</a>获取更多信息。
PhpInterpreterConfigurable.configuration.file.path=配置文件\: {0}
PhpInterpreterConfigurable.configuration.file.path.not.found=配置 php.ini 文件不存在
PhpInterpreterConfigurable.configuration.options.description=这些选项将使用 '-d' 命令行选项传递
PhpInterpreterConfigurable.configuration.options.dialog.caption=配置选项
PhpInterpreterConfigurable.configuration.options.label=配置选项\:
PhpInterpreterConfigurable.configuration.options.table.empty.text=为 php.ini 中允许的任何配置指令设置自定义值
PhpInterpreterConfigurable.configuration.options.table.name=配置指令
PhpInterpreterConfigurable.configuration.options.table.value=值
PhpInterpreterConfigurable.configuration.options.with.empty.name.are.not.allowed=不允许名称为空的配置选项
PhpInterpreterConfigurable.configuration.project.level=仅对此项目可见
PhpInterpreterConfigurable.configuration.project.tooltip=检查是否不想在项目之间共享解释器
PhpInterpreterConfigurable.configuration.title=其他
PhpInterpreterConfigurable.debugger.extension.description=将仅为从 CLI 运行配置启动的调试会话加载调试器扩展
PhpInterpreterConfigurable.debugger.extension.label=调试器扩展\:
PhpInterpreterConfigurable.debugger.extension.title=选择调试器扩展路径
PhpInterpreterConfigurable.download.xdebug.extension=下载 Xdebug 扩展程序
PhpInterpreterConfigurable.generate.xdebug.extension=生成安装脚本
PhpInterpreterConfigurable.install.xdebug.extension=下载并安装 Xdebug 扩展程序
PhpInterpreterConfigurable.not.installed=未安装
PhpInterpreterConfigurable.php.ini.title=选择配置文件或目录
PhpInterpreterConfigurable.php.version=PHP 版本\: {0}
PhpInterpreterConfigurable.reload.phpinfo=重新加载 phpinfo
PhpInterpreterConfigurable.show.phpinfo=显示 phpinfo
PhpInterpreterConfigurable.update.helpers.title=正在更新帮助程序目录…
PhpInterpreterConfigurable.updated.phpinfo=已成功更新 phpinfo
PhpInterpreterConfigurable.xdebug.was.not.installed=Xdebug 安装失败
PhpInterpreterConfigurable.xdebug.was.successfully.installed=Xdebug 已成功安装
PhpPathMappingsConfigurable.use.path.mappings.label=使用路径映射(选择服务器是远程服务器还是使用符号链接)
PhpProjectConfigurable.advanced.settings=高级设置(&V)
PhpProjectConfigurable.analysis=分析
PhpProjectConfigurable.analysis.custom.format.functions=自定义格式函数
PhpProjectConfigurable.default.stubs.path=默认存根路径(&D)\:
PhpProjectConfigurable.docker.default.project.error.tooltip=打开或创建项目以配置 Docker 容器
PhpProjectConfigurable.exception.analysis=异常分析
PhpProjectConfigurable.exception.analysis.depth=调用树分析路径\:
PhpProjectConfigurable.exception.analysis.unchecked.exceptions=未检查的异常\:
PhpProjectConfigurable.include.analysis=Include 分析
PhpProjectConfigurable.include.path=Include 路径
PhpProjectConfigurable.interpreter=CLI 解释器\:
PhpProjectConfigurable.language.level=PHP 语言级别(&P)\:
PhpProjectConfigurable.php.runtime=PHP 运行时
PhpProjectConfigurable.select.default.stubs.path.description=选择默认存根路径
PhpProjectConfigurable.select.default.stubs.path.title=选择默认存根路径
PhpProjectConfigurable.select.document.root.path.description=选择 $_SERVER['DOCUMENT_ROOT'] 路径
PhpProjectConfigurable.select.document.root.path.title=选择 $_SERVER['DOCUMENT_ROOT'] 路径
PhpRemoteDebugRunConfigurationEditor.auto.config=通过 IDE 键筛选调试连接
PhpRemoteDebugRunConfigurationEditor.configuration.description=PHP 调试配置
PhpRemoteDebugRunConfigurationEditor.configuration.display.name=PHP 远程调试
PhpRemoteDebugRunConfigurationEditor.filter.connections.help=适用于复杂服务器设置，例如同一主机端口上有多个应用程序。<p/>保持未选中状态以自动检测配置，或使用<i>“侦听调试连接”</i>操作。
PhpRemoteDebugRunConfigurationEditor.filter.connections.help.link=阅读更多信息
PhpRemoteDebugRunConfigurationEditor.filter.connections.help.title=高级选项
PhpRemoteDebugRunConfigurationEditor.server.label=服务器(&E)\:
PhpRemoteDebugRunConfigurationEditor.session.id.cannot.be.empty=IDE 键(会话 ID)不能为空
PhpRemoteDebugRunConfigurationEditor.session.id.label=IDE 键(会话 ID)(&K)\:
PhpRemoteDebugRunConfigurationEditor.stop.zero.configuration=PhpStorm 已停止侦听传入调试连接。
PhpRemoteDebugRunConfigurationEditor.stop.zero.configuration.title=已停止侦听传入 PHP 调试连接
PhpRemoteDebugRunConfigurationEditor.zero.configuration.is.already.used=“侦听传入调试连接”已启用，不会发生任何变化。<br/>查看<a href\="zero_config">零配置调试</a>获取更多信息。<br/><br/>要停止侦听调试连接，请使用<a href\="stop">运行|停止侦听 PHP 调试连接</a>。
PhpRemoteDebugRunConfigurationEditor.zero.configuration.used=没有为 <i>''{0}''</i> 运行配置指定<i>服务器</i>，因此 PhpStorm 将侦听所有传入调试连接。<br/>查看<a href\="zero_config">零配置调试</a>获取更多信息。<br/><br/>要停止侦听调试连接，请使用<a href\="stop">运行|停止侦听 PHP 调试连接</a>。
PhpRemoteDebugRunConfigurationEditor.zero.configuration.used.title=已开始侦听传入 PHP 调试连接
PhpScripRunConfigurationEditor.arguments=实参\:
PhpScripRunConfigurationEditor.arguments.caption=实参
PhpScripRunConfigurationEditor.configuration.description=PHP 脚本配置
PhpScripRunConfigurationEditor.configuration.display.name=PHP 脚本
PhpScripRunConfigurationEditor.file=文件\:
PhpServerConfigurable.debugger.label=调试器(&D)
PhpServerConfigurable.host=主机
PhpServerConfigurable.host.label=主机(&H)\:
PhpServerConfigurable.port=端口
PhpServerConfigurable.port.label=端口(&P)
PhpServerConfigurable.shared=共享(&S)
PhpStepFilters.log.frame=框架已被跳过。函数名称\: {0}。远程文件 URL\: {1}
PhpStepFiltersConfigurable.add.method=添加方法
PhpStepFiltersConfigurable.display.name=步进筛选器
PhpStepFiltersConfigurable.skip.constructors=跳过构造函数
PhpStepFiltersConfigurable.skip.magic.methods=跳过魔术方法
PhpStepFiltersConfigurable.skipped.files=跳过的文件
PhpStepFiltersConfigurable.skipped.methods=跳过的方法
PhpStepFiltersConfigurable.specify.method.name=指定方法名称
PhpStepFiltersConfigurable.title.files=文件
PhpStepFiltersConfigurable.title.methods=方法
PhpUnitConfigurableForm.can.not.find.custom.loader=在 ''{0}'' 下找不到自动加载器脚本
PhpUnitConfigurableForm.can.not.find.paratest=在 ''{0}'' 下找不到 ParaTest
PhpUnitConfigurableForm.can.not.find.phpunit.phar=在 ''{0}'' 下找不到 phpunit.phar
PhpUnitConfigurableForm.custom.loader.is.directory=自动加载器不应为目录，对于默认 Composer 配置，将路径设置为“vendor/autoload.php”
PhpUnitConfigurableForm.custom.loader.is.empty=自动加载器文件的路径为空
PhpUnitConfigurableForm.default.paratest.binary=默认 ParaTest 二进制文件\:
PhpUnitConfigurableForm.download.phpunit.phar.link.text=从 {0} 下载 phpunit.phar
PhpUnitConfigurableForm.paratest.path=默认 ParaTest 二进制文件
PhpUnitConfigurableForm.path.to.phpunit.phar=phpunit.phar 路径
PhpUnitConfigurableForm.path.to.script=脚本路径\:
PhpUnitConfigurableForm.phpunit.library=PHPUnit 库
PhpUnitConfigurableForm.phpunit.paratest.is.empty=ParaTest 的路径为空
PhpUnitConfigurableForm.phpunit.phar.is.empty=phpunit.phar 路径为空
PhpUnitConfigurableForm.specified.wrong.paratest.binary=指定了错误的 ParaTest 二进制文件，请改用 'paratest_for_phpstorm'
PhpUnitConfigurableForm.test.runner=测试运行程序
PhpUnitConfigurableForm.unsupported.paratest.version=<html>安装的 ParaTest 版本不支持与 PHPStorm 集成。<br>请将 ParaTest 更新到 6.5.0 或更高版本。</html>
PhpUnitConfigurableForm.use.bootstrap.file=默认启动文件\:
PhpUnitConfigurableForm.use.bootstrap.file.validation.warning=为 ''{0}'' 提供启动文件的路径，或禁用“默认启动文件”选项
PhpUnitConfigurableForm.use.configuration.file=默认配置文件\:
PhpUnitConfigurableForm.use.configuration.file.validation.warning=为 ''{0}'' 提供配置文件的路径，或禁用“默认配置文件”选项
PhpUnitConfigurableForm.use.custom.loader=使用 Composer 自动加载器
PhpUnitConfigurableForm.use.paratest=使用 ParaTest\:
PhpUnitConfiguration.interpreter.conflict=发现应用程序级 PHPUnit 配置冲突。为解决该问题，创建了以下配置的项目级副本\:
PhpUnitConfiguration.interpreter.conflict.title=PHPUnit 配置冲突
PhpUnitTestRunnerConfigurationEditor.dialog.caption.test.runner.options=测试运行程序选项
PhpUnitTestRunnerConfigurationEditor.field.class=类\:
PhpUnitTestRunnerConfigurationEditor.field.directory=目录\:
PhpUnitTestRunnerConfigurationEditor.field.file=文件\:
PhpUnitTestRunnerConfigurationEditor.field.method=方法\:
PhpUnitTestRunnerConfigurationEditor.field.test.runner.coverage.engine=首选覆盖率引擎\:
PhpUnitTestRunnerConfigurationEditor.field.test.runner.options=测试运行程序选项(&O)\:
PhpUnitTestRunnerConfigurationEditor.scope=测试作用域\:
PhpUnitTestRunnerConfigurationEditor.scope.class=类
PhpUnitTestRunnerConfigurationEditor.scope.directory=目录
PhpUnitTestRunnerConfigurationEditor.scope.method=方法
PhpUnitTestRunnerConfigurationEditor.scope.xml=在配置文件中定义
PhpUnitTestRunnerConfigurationEditor.test.runner=测试运行程序
PhpUnitTestRunnerConfigurationEditor.use.alt.bootstrap.file=使用替代启动文件(&U)\:
PhpUnitTestRunnerConfigurationEditor.use.alt.configuration.file=使用替代配置文件(&U)\:
PhpUserDefinedConstantsGroup.name=常量
PhpWebAppRunConfigurationEditor.browser=浏览器(&B)\:
PhpWebAppRunConfigurationEditor.configuration.description=PHP 网页配置
PhpWebAppRunConfigurationEditor.configuration.display.name=PHP 网页
PhpWebAppRunConfigurationEditor.malformed.start.url=起始 URL 的格式错误 - {0}
PhpWebAppRunConfigurationEditor.startUrl=起始 URL(&U)\:
RunConfigurationEditor.configuration=配置
RunConfigurationEditor.error.server.is.not.exist=名称为 ''{0}'' 的服务器不存在
RunConfigurationEditor.error.server.is.not.selected=未选择服务器
RunConfigurationEditor.server=服务器(&S)\:
XdebugCloudConfigurable.base.host=Cloud 主机\:
XdebugCloudConfigurable.cloud.id=Cloud ID\:
XdebugCloudConfigurable.connect.via.xdebug.cloud=连接到 Xdebug Cloud
XdebugCloudConfigurable.custom.server=连接到预置 Xdebug Cloud
XdebugCloudConfigurable.display.name=Xdebug Cloud
XdebugCloudConfigurable.port=Cloud 端口\:
a.class.constant.must.not.be.called.class.it.is.reserved.for.class.name.fetching=类常量不得被称为 'class'；后者被保留用于类名提取
a.full.numeric.representation.of.a.year.at.least.4.digits.with.for.years.bce=年份的完整数字表示，至少 4 位数，使用 - 表示公元前的年份(2022 年)
a.full.textual.representation.of.a.month.such.as.january.or.march=月份的完整文本表示，英语(January 到 December)
a.full.textual.representation.of.the.day.of.the.week=星期几的完整文本表示(Sunday 到 Saturday)
a.short.textual.representation.of.a.month.three.letters=月份的短文本表示，三个英语字母(Jan 到 Dec)
a.textual.representation.of.a.day.three.letters=星期几的文本表示，三个英语字母(Mon 到 Sun)
a.trait.cannot.extend.a.class=特征无法扩展类
a.trait.cannot.implement.an.interface=特征无法实现接口
a.two.digit.representation.of.a.year=年份的两位数表示(22)
absolute.reference.is.not.allowed=不允许绝对引用
abstract.modifier.is.not.allowed.here=此处不允许使用 'Abstract' 修饰符
access.level.to.0.1.must.be.2.as.in.class.3.or.weaker=''{0}\:\:${1}'' 的访问级别必须为 {2} (与类 {3} 中一样)或更低
access.level.to.0.1.must.be.2.as.in.class.3.or.weaker2=''{0}\:\:{1}'' 的访问级别必须为 {2} (与类 {3} 中一样)或更低
access.must.be.public=访问必须为 public
access.type.for.interface.member.must.be.omitted=接口成员的访问类型必须省略
action.ChangePHPInterpreter.description=更改项目 PHP 解释器
action.ChangePHPInterpreter.text=更改 PHP 解释器
action.ComposerAddDependencyAction.description=管理 Composer 依赖项
action.ComposerAddDependencyAction.text=管理依赖项…
action.ComposerClearCacheAction.description=删除 Composer 缓存目录中的所有内容
action.ComposerClearCacheAction.text=清除缓存
action.ComposerDiagnoseAction.description=检查常见的 Composer 问题
action.ComposerDiagnoseAction.text=诊断
action.ComposerDryRunUpdate.description=模拟更新，但不实际更新
action.ComposerDryRunUpdate.text=模拟更新
action.ComposerDumpAutoloadAction.description=重新生成自动加载类的列表
action.ComposerDumpAutoloadAction.text=转储自动加载器…
action.ComposerInstallAction.description=考虑到 composer.lock，安装 composer.json 中的软件包
action.ComposerInstallAction.text=安装
action.ComposerLicensesAction.description=列出安装的每个软件包的名称、版本和许可证
action.ComposerLicensesAction.text=列出许可证
action.ComposerSelfUpdateAction.description=将 Composer 本身更新到最新版本
action.ComposerSelfUpdateAction.text=自我更新
action.ComposerShowLogAction.description=显示包含此 composer.json 的 Composer 操作日志
action.ComposerShowLogAction.text=显示日志
action.ComposerStatusAction.description=检查任何依赖项中有无本地更改
action.ComposerStatusAction.text=检查依赖项中的更改
action.ComposerUpdateAction.description=从 Composer.json 安装最新适当版本的软件包
action.ComposerUpdateAction.text=更新
action.ComposerValidateAction.description=检查 composer.json 是否有效
action.ComposerValidateAction.text=验证…
action.DBGPProxy.Configuration.description=代理配置
action.DBGPProxy.Configuration.text=配置…
action.DBGPProxy.Init.description=代理初始化
action.DBGPProxy.Init.text=注册 IDE
action.DBGPProxy.Stop.description=代理停止
action.DBGPProxy.Stop.text=取消 IDE 注册
action.DisableXdebugDfaAssist.description=永久关闭数据流辅助调试
action.DisableXdebugDfaAssist.text=永久关闭数据流助手
action.IgnorePharAction.text=在项目中包含或排除 phar
action.MessDetectorAddToIgnored.description=添加到 PHP Mess Detector 忽略列表
action.MessDetectorAddToIgnored.text=添加到 PHPMD 忽略列表
action.NewComposerJsonFile.description=创建 composer.json 文件
action.NewComposerJsonFile.text=composer.json 文件
action.PhpCSAddToIgnored.description=添加到 PHP_CodeSniffer 忽略列表
action.PhpCSAddToIgnored.text=添加到 PHPCS 忽略列表
action.PhpCSFixerAddToIgnored.description=添加到 PHP CS Fixer 忽略列表
action.PhpCSFixerAddToIgnored.text=添加到 PHP CS Fixer 忽略列表
action.PhpDebugBreakAtFirstLine.text=在 PHP 脚本中的第一行中断
action.PhpDebugHideEmptySuperGlobals.text=显示空的超全局变量
action.PhpDebuggerCopyType.text=复制类型
action.PhpDetectPsroRoots.description=将检测源代码命名空间根
action.PhpDetectPsroRoots.text=检测 PSR-0 命名空间根
action.PhpExtractClassAction.description=将元素提取到单独的类
action.PhpExtractClassAction.text=提取类…
action.PhpGenerateConstructor.description=创建构造函数。
action.PhpGenerateConstructor.text=构造函数…
action.PhpGenerateGetters.description=为 private 类字段创建 getter。
action.PhpGenerateGetters.text=getter…
action.PhpGenerateGettersAndSetters.description=为 private 类字段创建 getter 和 setter。
action.PhpGenerateGettersAndSetters.text=getter 和 setter…
action.PhpGeneratePhpDocBlocks.description=为函数、类和字段添加 PHPDoc 块。
action.PhpGeneratePhpDocBlocks.text=PHPDoc 块…
action.PhpGeneratePropertyHooks.description=为非 abstract 类字段创建属性挂钩。
action.PhpGeneratePropertyHooks.text=属性挂钩…
action.PhpGenerateSetters.description=为 private 类字段创建 setter。
action.PhpGenerateSetters.text=setter…
action.PhpListenDebugAction.description=侦听调试连接
action.PhpListenDebugAction.text=侦听调试连接
action.PhpMakeStaticAction.description=将类方法设为 static
action.PhpMakeStaticAction.text=设为 static
action.PhpNewClass.description=创建新的 PHP 类
action.PhpNewClass.text=PHP 类
action.PhpNewFile.description=创建新的 PHP 文件
action.PhpNewFile.text=PHP 文件
action.PhpNewTest.description=创建新的 PHP 测试
action.PhpNewTest.text=PHP 测试
action.PhpResetTestFrameworkSyncAction.text=重置与 Composer 同步的测试框架配置
action.PhpSimpleNewFile.description=创建新的 PHP 文件
action.PhpSimpleNewFile.text=PHP 文件
action.PhpStanAddToIgnored.description=添加到 PHPStan 忽略列表
action.PhpStanAddToIgnored.text=添加到 PHPStan 忽略列表
action.PhpStormMigrationGuide.text=PhpStorm 迁移指南
action.PhpUnitGenerateSetUpMethod.description=创建 PHPUnit setUp 方法
action.PhpUnitGenerateSetUpMethod.text=SetUp 方法
action.PhpUnitGenerateTearDownMethod.description=创建 PHPUnit tearDown 方法
action.PhpUnitGenerateTearDownMethod.text=TearDown 方法
action.PhpUnitGenerateTestMethod.description=创建 PHPUnit 测试方法
action.PhpUnitGenerateTestMethod.text=测试方法
action.ProfilerJumpToSource.description=跳转到源
action.ProfilerJumpToSource.text=跳转到源
action.ProjectFromVersionControl.ProjectWidgetPopup.text=克隆仓库…
action.ProjectFromVersionControl.text=从版本控制新建项目…
action.XDebugger.CopyPath.text=复制路径
action.XdebugAddMethodToSkipListAction.text=将方法添加到跳过列表
action.XdebugAnalyzeProfilerSnapshotAction.text=分析 Xdebug 分析器快照…
action.XdebugDetachFromSessionAction.text=从会话中分离
action.XdebugShowUserDefinedConstants.description=将其禁用会停止获取用户定义的常量信息并提高调试器性能
action.XdebugShowUserDefinedConstants.text=显示用户定义的常量
action.add.file.s.to.list.text=向列表中添加文件
action.com.jetbrains.php.composer.ComposerInitSupportAction.description=初始化 Composer
action.com.jetbrains.php.composer.ComposerInitSupportAction.text=初始化 Composer…
action.com.jetbrains.php.internal.PhpCreateYoutrackIssueFromFileAction.text=在 WI (PhpStorm) 项目中根据文件内容创建 YouTrack 问题
action.com.jetbrains.php.internal.PhpCreateYoutrackIssueFromSelectionAction.text=在 WI (PhpStorm) 项目中根据所选内容创建 YouTrack 问题
action.com.jetbrains.php.internal.PhpShowFQNInternalAction.text=显示 PHP FQN
action.com.jetbrains.php.internal.PhpViewControlFlowAction.text=当前文件的 PHP 控制流
action.configure.php.runtime.text=配置 PHP 运行时…
action.configure.project.directories.text=配置项目目录
action.copy.3v4l.link.text=将 3v4l 链接复制到剪贴板
action.copy.port.to.clipboard.text=将端口值复制到剪贴板
action.copy.to.clipboard.text=复制到剪贴板
action.detect.composer.json.not.found=在路径 {0} 下找不到 composer.json
action.detect.composer.json.not.found.title=找不到 composer.json
action.detect.composer.json.open=在编辑器中打开
action.detect.settings.sync.turned.on=PHP 语言级别已与 composer.json 同步
action.detect.settings.sync.turned.on.title=已与 composer.json 同步
action.detect.user.settings.state.overwritten=如果打开同步，IDE 设置(PHP 语言级别，PSR-0/PSR-4 根)可能会被覆盖
action.detect.user.settings.state.overwritten.short=设置可能会被覆盖\: PSR-0/PSR-4 根和 PHP 语言级别。
action.detect.user.settings.state.supported=支持 PSR-0/PSR-4 根和 PHP 语言级别的同步
action.enable.plugin.text=启用 ''{0}'' 插件
action.migrate.text=是
action.open.3v4l.link.in.browser.text=在浏览器中打开 3v4l 链接
action.quality.tools.provider=质量工具
action.quality.tools.provider.description=文件被排除在外部质量工具分析和格式化程序外
action.retry.text=重试
action.revert.back.to.text=还原为 {0}
action.run.composer.install.text=运行 'composer install'
action.run.on.3v4l.org.promotion.tooltip=您现在可以在 3v4l.org 上运行不同 PHP 版本的临时文件
action.run.on.3v4l.org.text=在 3v4l.org 上运行
action.show.in.log.text=在日志中显示
action.submits.code.to.3v4l.org.show.result.in.preview.editor.description=将代码提交到 3v4l.org，并在预览编辑器中显示结果
action.synonym.listening=侦听
action.synonym.start.listening=开始侦听 PHP Xdebug 连接
action.synonym.stop.listening=停止侦听 PHP Xdebug 连接
action.use.possibly.outdated.defaults.text=使用默认版本(可能已过时)
actions.detect.common.setting.from.composer.disable=不同步
actions.detect.common.setting.from.composer.enable=启用同步
actions.detect.common.setting.from.composer.show.settings=显示设置
actions.detect.common.setting.from.composer.suggest.title=将设置与 Composer 同步?
actions.detect.common.settings.composer.sync.state.title=与 composer.json 的同步{0}
actions.detect.common.settings.updated.from.composer.title={0} 设置已更新
actions.detect.language.level.loaded.from.composer.idea.title=语言级别
actions.detect.language.level.loaded.from.composer.title=PHP 语言级别
actions.detect.namespace.roots.finished=已完成 PSR-0 命名空间根检测。
actions.detect.namespace.roots.from.composer.idea.title=源根
actions.detect.namespace.roots.from.composer.title=PSR-0/PSR-4 根
actions.detect.namespace.roots.idea.view.configuration=您可以在 '项目结构 | 模块' 中修改设置。
actions.detect.namespace.roots.manual.configuration=手动配置
actions.detect.namespace.roots.no.new.roots.detected=未检测到新的 PSR-0 命名空间根。
actions.detect.namespace.roots.notification.id=PHP PSR-0 命名空间根检测已完成
actions.detect.namespace.roots.notification.title=检测 PSR-0 命名空间根
actions.detect.namespace.roots.progress.title=正在检测 PSR-0 命名空间根…
actions.detect.namespace.roots.view.configuration=视图配置
actions.mark.directory.as.psr.0.root=<i>{0}</i>
actions.mark.directory.as.psr.0.root.mark.psr=标记为 {0} 根
actions.mark.directory.as.psr.0.root.title=是否要将文件夹标记为 {0} 根?
actions.mark.directory.as.psr.0.root.with.prefix=<i>{0}</i>为前缀“{1}”?
actions.new.php.base.arrows.extension.tooltip=在编辑器中按向上或向下箭头可更改文件扩展名
actions.new.php.base.arrows.template.tooltip=在编辑器中按向上或向下箭头可更改模板
actions.new.php.base.dialog.label.extension=文件扩展名\:
actions.new.php.base.dialog.label.file.name=文件名\:
actions.new.php.class.dialog.border.title.class=类
actions.new.php.class.dialog.label.class.name=名称\:
actions.new.php.class.dialog.label.directory=目录\:
actions.new.php.class.dialog.label.namespace=命名空间\:
actions.new.php.class.dialog.label.superclasses.container=父类
actions.new.php.class.dialog.label.superclasses.super.fqn=扩展\:
actions.new.php.class.dialog.label.superinterfaces.add.interface=添加接口…
actions.new.php.class.dialog.label.superinterfaces.to.extend.empty=选择要扩展的接口
actions.new.php.class.dialog.label.superinterfaces.to.implement=实现\:
actions.new.php.class.dialog.label.superinterfaces.to.implement.empty=选择要实现的接口
actions.new.php.class.dialog.label.template=模板\:
actions.new.php.class.dialog.title=创建新的 PHP 类
actions.new.php.file.dialog.title=创建新的 PHP 文件
actions.new.phpunit.class.action.description=创建新的 PHPUnit 测试
actions.new.phpunit.class.action.name=PHPUnit 测试
actions.new.test.class.action.description=创建新的 PHP 测试
actions.new.test.class.action.name=新建 PHP 测试
actions.new.test.class.dialog.arrows.libraries.hint=在编辑器中按向上或向下箭头可更改测试库
actions.new.test.class.dialog.border.title.class.to.test=要测试的类(可选)
actions.new.test.class.dialog.border.title.target.class.file.path=文件路径\:
actions.new.test.class.dialog.border.title.test.class=测试类
actions.new.test.class.dialog.label.directory=目录\:
actions.new.test.class.dialog.label.fqn=完全限定名称\:
actions.new.test.class.dialog.label.name=名称\:
actions.new.test.class.dialog.label.namespace=命名空间\:
actions.new.test.class.dialog.select.methods.show.inherited.methods=显示继承的方法(&I)
actions.new.test.class.dialog.title=创建新的 PHP 测试
actions.new.test.class.dialog.title.named=为 {0} 创建新的 PHP 测试
add=添加
add.catch.clause.quick.fix=添加 'catch' 从句
add.clarifying.parentheses=添加澄清括号
add.class=添加类…
add.class1=添加类
add.constant.0.to.class.1.and.opens.containing.file.in.editor=将常量 ''{0}'' 添加到类 ''{1}'' 并在编辑器中打开包含的文件
add.constant.declaration.quick.fix.text=添加常量
add.custom.format.function=添加自定义格式函数…
add.custom.format.function1=添加自定义格式函数
add.enum.declaration.quick.fix.text=添加枚举 case
add.fluent.setter=添加 fluent setter
add.global.variable.quick.fix.family.name=添加全局变量
add.global.variable.quick.fix.text=添加 ''global ${0}''
add.phpunit.test.pattern=添加 PHPUnit 测试模式
add.port.in.ide.settings=将端口 {0} 添加到设置
add.property=添加 @property
add.property.hooks=添加属性挂钩
add.remote.interpreter=添加远程解释器
add.return.type=添加返回值类型
add.rule=添加规则
add.serialize.magic.method=添加{0}方法
add.serialize.magic.methods=添加{0}方法
add.setter=添加 setter
add.slash.to.the.start=在开头添加 '/'
add.test.class.method=添加测试类/方法…
add.throw.before.exception=在表达式前面添加 'throw'
add.to.composer.json.quick.fix=向 composer.json 中添加 ''{0}''
add.to.excluded.files.action=将 `{0}` 添加到忽略的文件
advanced.setting.php.code.vision.hierarchy.limit=Code Vision\: 要处理的最大继承实体数
advanced.setting.php.code.vision.usages.limit=Code Vision\: 要搜索的最大用法数
advanced.setting.php.max.chain.resolve.depth=解析成员引用的最大深度
advanced.setting.php.sql.completion.recursive.jumps.limit=补全\: 查找 SQL 查询时要解析的最大元素数量
advanced.setting.php.type.completion.complexity.limit=类型补全复杂度限制
advanced.setting.php.type.inference.complexity.limit=形参类型推断复杂度限制
advanced.setting.php.use.internal.formatter=在外部格式化程序之前运行内置格式化程序
alias=别名
align.composer.log.console=对齐 Composer 日志控制台
all.0=所有({0})
all.cases.of.backed.enum.must.have.a.value=后备枚举的所有 case 必须包含值
all.exceptions.considered.checked=所有异常均被视为已检查
all.scripts=<All scripts>
all.values=所有变量
all.versions=所有版本
always.show.pass.by.reference=始终显示引用传递
an.alias.was.defined.for.method.0.which.exists.in.1=已为 {1} 中的方法 {0}() 定义别名
an.expanded.full.numeric.representation.if.requried.or.a.full.numeral.representation.like.y=扩展的完整数字表示(如果需要)，或完整数字表示(2022)
an.expanded.full.numeric.representation.of.a.year.at.least.4.digits.with.or=年份的扩展完整数字表示，至少 4 位数，带 - 或 + (+2022)
an.object.s.clone.method.cannot.be.called.directly=无法直接调用对象的 '__clone()' 方法
analyzing.php.sdk=正在检查 PHP 安装…
and=和
annotation.expression.is.not.allowed.as.class.constant.value=表达式不允许为类常量值
annotation.new.expression.abstract=无法实例化抽象类 ''{0}''
annotation.new.expression.enum=无法实例化枚举 ''{0}''
annotation.new.expression.interface=无法实例化接口 ''{0}''
annotation.new.expression.trait=无法实例化特征 ''{0}''
annotation.variable.variable=可变变量
annotator.cannot.break.continue=无法中断/继续{0}级别
annotator.duplicate.default.match.condition=match 表达式只能包含一个 'default' 分支
annotator.duplicate.use.statement=无法使用 ''{0}''，因为该名称已被使用
annotator.fix.remove=移除 ''{0}''
annotator.invalid.class.name=''{0}'' 是无效的类名
annotator.jump.out.of.finally=不允许跳出 finally 块
annotator.only.default.condition.allowed='default' arm 中仅允许单个 'default' 条件
annotator.reserved.class.name=无法使用 ''{0}'' 作为类名，因为该名称已被保留
annotator.special.class.name=无法将 {0} 用作 {1}，因为 ''{1}'' 是一个特殊的类名
annotator.unhandled.match.argument=未处理的 'match' 实参
anonymous.0=匿名{0}
anonymous.class=匿名类
anonymous.function=匿名函数
anonymous.function.expected=应为匿名函数
another.definition.with.same.name.exists.in.this.file=此文件中存在另一个具有相同名称的定义
argument.passed.must.be.of.the.type.0.1.given=传递的实参必须为 {0} 类型，给定的为 {1}
array.callback.must.have.exactly.two.elements=数组回调必须正好有两个元素
array.can.t.be.used.for.array.destructuring.assignment='array()' 不能用于数组析构赋值
array.index=数组索引
array.only.updated.but.never.queried=数组仅被更新，但从未被查询
arrays.are.not.supported.as.operands.for.0=不支持将数组用作 ''{0}'' 的操作数
arrow.expressions.are.not.allowed.as.static.parameter.default.value=箭头表达式不允许用作 static 形参默认值
attribute.can.be.added.to.overridden.method=可以将特性添加到重写方法
attribute.can.be.added.to.overridden.parameter=可以将特性添加到重写形参
attribute.must.be.first.child.of.parent.element=特性必须是父元素的第一个子项
auto.import.from.global.space=处理来自全局空间的符号
auto.import.from.global.space.class=类\:
auto.import.from.global.space.constant=常量\:
auto.import.from.global.space.function=函数\:
auto.import.from.global.space.prefer.fallback=回退优先
auto.import.from.global.space.prefer.fqn=FQN 优先
auto.import.from.global.space.prefer.import=导入优先
auto.import.in.file.scope=在文件作用域内启用自动导入
auto.import.in.namespace.scope=在命名空间作用域内启用自动导入
background.task.detect.namespace.roots.progress.title=正在检测命名空间根…
bit.shift.by.negative.number=按负数进行移位
border.title.additional.dependencies=其他依赖项
border.title.constant.syntax=常量语法
border.title.include.analysis=Include 分析
border.title.initialize.in=初始化位置
border.title.introduce.field=引入属性
border.title.introduce.variable=引入变量
border.title.options=选项
border.title.php=PHP
border.title.require.dependencies='require' 依赖项
border.title.require.dev.dependencies='require-dev' 依赖项
border.title.visibility=可见性
build.control.flow=构建控制流(&B)
build.control.flow.with.exit.points=使用出口点构建控制流(&E)
button.sync.extensions.with.interpreter=将扩展与解释器同步
button.turn.off.listening=禁用调试侦听
button.turn.off.listening.descr=为所选项目禁用调试侦听
cache.creating=正在创建 psalm 缓存…
call.to.0.1.construct.from.invalid.context=从无效上下文调用 ''{0} {1}\:\:__construct()''
call.to.method.clone.from.invalid.context=从无效上下文调用方法 '__clone'
call.tree=调用树
callees=被调用方
callers=调用方
can.not.correctly.run.the.tool.with.parameters=无法使用形参正确运行该工具\:
can.not.delete.temporary.file.because.it.was.not.created=无法删除临时文件，因为未创建该文件
can.not.execute.tests=无法执行测试
can.not.execute.transfer.task.project.is.already.disposed=无法执行传输任务\: 项目已被处置
can.not.find.0.helper.script=找不到 ''{0}'' 帮助程序脚本
can.not.find.specified.interpreter=找不到指定的解释器
can.not.parse.phpunit.version.output.0=无法解析 PHPUnit 版本输出\: {0}
can.not.run.command.composer.execution.plugin.was.unloaded=无法运行命令\: Composer 执行插件已卸载
can.only.be.used.as.standalone.type={0} 仅可用作独立类型
can.t.use.nullsafe.operator.in.write.context=在写入上下文中不能使用 nullsafe 运算符
cancel=取消
cannot.apply.0.to.constructor=无法将 {0} 应用于构造函数
cannot.apply.0.to.interface=无法将 {0} 应用于接口
cannot.apply.0.to.property.hook=无法将 {0} 应用于属性挂钩
cannot.apply.0.to.readonly.class=无法将 {0} 应用于 ''readonly'' 类
cannot.apply.0.to.trait=无法将 {0} 应用于特征
cannot.apply.no.discard.to.0.returning.function=返回 {0} 的函数不返回值，但 \#[NoDiscard] 需要返回值
cannot.call.abstract.method.0.1=无法调用 abstract 方法 ''{0}\:\:{1}''
cannot.combine.nullsafe.operator.with.closure.creation=无法将 nullsafe 运算符与 'Closure' 创建组合
cannot.create.closure.for.new.expression=无法为 'new' 表达式创建 'Closure'
cannot.declare.dynamic.properties.in.readonly.class=不能在 'readonly' 类中声明动态属性
cannot.declare.promoted.property.in.an.abstract.constructor=无法在 abstract 构造函数中声明提升的属性
cannot.declare.promoted.property.outside.a.constructor=无法在构造函数外部声明提升的属性
cannot.declare.self.referencing.constant=无法声明自引用常量
cannot.declare.static.properties.in.readonly.class=不能在 'readonly' 类中声明 'static' 属性
cannot.declare.variadic.promoted.property=无法声明可变提升属性
cannot.implement.interface.0=无法实现接口 ''{0}''
cannot.implement.interface.0.directly=无法直接实现接口 ''{0}''
cannot.inherit.previously.inherited.or.override.constant.0.from.interface.1=无法从接口 ''{1}'' 继承先前继承的常量 ''{0}'' 或将其重写
cannot.make.interface.method.non.static=无法将接口方法设为非 static
cannot.make.interface.method.static=无法将接口方法设为 static
cannot.mix.amp.and.pipe.in.type.declaration=类型声明中不能混用 '\\&' 和 '|'
cannot.mix.and.list=不能混合 [] 与 list()
cannot.mix.keyed.and.unkeyed.array.entries.in.assignments=在赋值中不能混合键控和非键控数组条目
cannot.override.final.constant=无法从 ''{1}'' 重写 final 常量 ''{0}''
cannot.redeclare.constant.0=无法重新声明常量 ''{0}''
cannot.redeclare.methods.from.enum.implicit.interfaces=无法从枚举隐式接口重新声明方法
cannot.redeclare.non.static.0.1.as.static.2.3=无法将非 static ''{0}\:\:${1}'' 重新声明为 static ''{2}\:\:${3}''
cannot.redeclare.static.0.1.as.non.static.2.3=无法将 static ''{0}\:\:${1}'' 重新声明为非 static ''{2}\:\:${3}''
cannot.register.handler=无法注册处理程序
cannot.use.0.as.lexical.variable=无法将 ''${0}'' 用作词法变量
cannot.use.class.on.primitive.type=只允许在对象上使用 '\:\:class'
cannot.use.empty.array.elements.in.arrays=无法在数组中使用空数组元素
cannot.use.empty.array.entries.in.keyed.array.assignment=在键控数组赋值中不能使用空数组条目
cannot.use.empty.list=无法使用空列表
cannot.use.for.reading=无法使用 '[]' 进行读取
cannot.use.match.as.identifier=无法将 'match' 用作标识符，自 PHP 8.0 起作为预留关键字
cannot.use.positional.argument.after.argument.unpacking=无法在实参解包后使用位置实参
cannot.use.positional.argument.after.argument.unpacking.named.argument.81=实参解包后的位置实参从 PHP 8.1 起才可用
cannot.use.positional.argument.after.named.argument=无法在命名实参后面使用位置实参
cannot.use.readonly.as.identifier=无法将 'readonly' 用作标识符。自 PHP 8.1 起作为预留关键字
cannot.use.static.as.function.return.type.declaration=不允许 'static' 作为类作用域外部的返回值类型声明
cannot.use.this.as.parameter=不能将 $this 用作形参
cannot.use.traits.inside.of.interfaces=无法在接口内部使用特征
cannot.use.unpacking.in.attribute.argument.list=无法在特性实参列表中使用解包
cannot.use.yield.from.inside.a.by.reference.generator=不能在引用传递生成器中使用 'yield from'
cant.save.interpreter=无法保存 ''{0}''\: {1}
cant.use.temporary.expression.in.write.context=在写上下文中不能使用临时表达式
case.of.non.backed.enum.must.not.have.a.value=非后备枚举的 case 不得包含值
caused.by.0=原因是\:“{0}”
change.member.access=更改成员访问
change.method.modifiers.to.0=将方法修饰符更改为 ''{0}''
change.php.language.level=更改 PHP 语言级别
change.signature.arg.type.incompatible=应为 ''{0}'' 类型的形参，提供的是 ''{1}''
change.signature.arg.type.miss.argument=应为 ''{0}'' 类型的形参
change.signature.column.name.parameter=形参\:
change.signature.column.type.parameter=类型\:
change.signature.error.wrong.caret.position=文本光标应置于要重构的函数的名称处。
change.signature.find.usages.of.base.class=类 {1} 的方法 {0}\n重写了类 {2} 的方法。\n要{3}基方法吗?
change.signature.find.usages.of.base.interface=类 {1} 的方法 {0}\n实现了接口 {2} 的方法。\n要{3}基方法吗?
change.signature.initialize.new.parameters=创建并初始化类属性(&I)
change.signature.parameter.may.have.side.effect=用作形参“{1}”的表达式“{0}”可能会有副作用
change.signature.tooltip.default.value=要在此方法的所有现有调用中使用的值
change.signature.tooltip.parameter=$name \= 'init' 或 &...$array \= 'init'
change.signature.usage.view.declarations.header=要重构的函数
change.signature.visibility.not.accessible=可见性为 {1} 的{0}将无法从{2}访问
checkbox.add.override=添加 \#[Override]
checkbox.add.packages.as.libraries=作为库添加软件包(&A)
checkbox.add.phpdoc=添加 PHPDoc(&D)\:
checkbox.always.enable.blade.template.highlighting=始终启用 Blade 模板高亮显示
checkbox.always.enable.php.code.background.highlighting=始终启用 PHP 代码后台高亮显示
checkbox.anonymous.classes=匿名类
checkbox.check.clone.method=检查 '__clone' 方法
checkbox.check.destruct.method=检查 '__destruct' 方法
checkbox.check.sleep.method=检查 '__sleep' 方法
checkbox.check.wakeup.method=检查 '__wakeup' 方法
checkbox.ignore.empty.functions=忽略空函数
checkbox.ignore.test.methods=忽略测试方法
checkbox.lambdas=Lambda
checkbox.move.to.another.class=移至另一个类(&M)
checkbox.rename.only.nearest.scope=仅重命名最近作用域中的变量
checkbox.show.class.namespace.separators=显示 PHP 类和命名空间分隔符
checkbox.static=static
checkbox.use.as.a.default.template=用作默认模板
checkbox.use.composer=添加 'composer.json'
checkbox.use.fully.qualified.class.names=使用完全限定类名
checking.for.changes.in.code.of.dependencies=正在检查依赖项代码中的更改
choose.a.valid.0.launcher=选择有效的 {0} 启动器
choose.an.alias.to.use=选择要使用的别名
choose.class=选择类
choose.elements.to.generate.phpdoc.for=选择要为其生成 PHPDoc 的元素
choose.executable.class.to.run.0=选择用于运行 {0} 的可执行类
choose.methods.to.implement=选择要实现的方法
choose.methods.to.implement1=选择要实现的方法
choose.methods.to.override=选择要重写的方法
choose.php.home=选择 PHP 可执行文件
choose.properties=选择属性
choose.super.class.or.interface=选择超类或接口
choose.super.method=选择 super 方法
choose.test.method.to.run.dataset.0=选择测试方法以运行数据集 {0}
class=类
class.cannot.extend.from.trait=类无法从特征扩展
class.cannot.implement.previously.implemented.interface=类无法实现先前实现的接口
class.constant=类常量
class.constant.reference.fetch.with.non.string.type=只有 'string' 类型的元素才能用于类常量查找
class.constant1=类常量
class.constructor=类构造函数
class.declarations.may.not.be.nested=类声明不能被嵌套
class.implements.solely.traversable=类 ''{0}'' 必须将接口 Traversable 作为 Iterator 或 IteratorAggregate 的一部分来实现
class.implements.the.serializable.interface.which.is.deprecated=在不使用 '__serialize()'/'__unserialize()' 方法的情况下实现 'Serializable' 接口已弃用
class.name=类名
class.ref.is.deprecated=类 '\#ref' 已弃用
class.reference=类引用
class.should.not.implement.itself=类不应自行实现
class1=类
class2=类
classes.can.not.have.backed.type=类不能有后备类型
classes.named.never.is.forbidden.in.php.8.1=PHP 8.1 中禁止名为 'never' 的类
classes.named.object.are.forbidden.in.php.7.2=PHP 7.2 中禁止名为 'object' 的类
classes.named.void.and.iterable.are.forbidden.in.php.7.1=PHP 7.1 中禁止名为 'void' 和 'iterable' 的类
classes.without.member=层次结构中不带 ''{0}'' 的类
cleaning.up=正在清理…
clear.log=清除日志
clearing.cache=正在清除缓存
cli.interpreters.name=CLI 解释器
close=关闭(&C)
closest.scope=最近作用域中的变量
closures.as.default.values.must.be.static=闭包值的默认值必须声明为 static
closures.in.constant.expressions.do.not.suport.use.directive=常量表达式中的闭包不支持 'use' 指令
code.fully.qualified.classname.methodname.key.value.code.example.precise.match={0} 是一个精确排除的示例。
code.global.code.matches.function.with.two.parameters={0} 匹配带有两个形参的函数。
code.info.code.matches.all.single.parameter.methods.where.the.parameter.name.ends.with.em.info.em={0} 匹配形参名以 {1} 结尾的所有单形参方法。
code.key.value.code.matches.all.methods.with.parameters.em.key.em.and.em.value.em={0} 匹配所有具有形参 {1} 和 {2} 的方法。
code.size.rules=代码大小规则
code.vision.implementations.hint={0, choice, 1\#1 个实现|2\#{0,number}'{1,choice, |1\#+}' 实现}
code.vision.inheritors.hint={0, choice, 1\#1 个继承者|2\#{0,number}'{1,choice, |1\#+}' 继承者}
code.vision.overrides.hint={0, choice, 1\#1 个重写|2\#{0,number}'{1,choice, |1\#+}' 重写}
code.vision.used.in.hint=由 {0}{1, choice, |1\#+} 使用
column.name.annotation.name=注解名称
column.name.file.directory=文件/目录
column.name.parameter=形参
command.name.create.php.file=创建 PHP 文件 {0}
command.name.disable.synchronisation.with.composer=禁用与 composer.json 同步
command.name.make.method.static=将方法设为 static
command.name.new.file=新建文件
completion.press.again.to.see.all.classes=再次按 {0} 以查看所有类
completion.press.again.to.see.global.variants=再次按 {0} 以查看全局变体
completion.press.again.to.see.more.variants=再次按 {0} 以查看更多变体
composer=composer
composer.autoloader.generation.settings.name=自动加载器生成设置
composer.border.title.execution=执行
composer.border.title.package=软件包
composer.change.setting.action.name=更改设置
composer.checkbox.allow.unbound.version.constraints=允许未绑定的版本约束
composer.checkbox.autoload.classes.from.the.classmap.only=仅从类映射自动加载类
composer.checkbox.check.if.composer.lock.is.up.to.date=检查 composer.lock 是否为最新
composer.checkbox.check.if.the.package.is.packagist.ready=检查软件包是否为 Packagist 就绪
composer.checkbox.disable.autoload.dev.dependencies=禁用 autoload-dev 依赖项
composer.checkbox.download.composer.phar.from.getcomposer.org=从 getcomposer.org 下载 composer-stable.phar
composer.checkbox.optimize.autoloader.convert.psr.0.4.rules.to.a.classmap=优化自动加载器(将 PSR-0/4 规则转换为类映射)
composer.checkbox.skip.scripts.execution=跳过脚本执行
composer.checkbox.synchronize.ide.settings.with.composer.json=将 IDE 设置与 composer.json 同步(&S)
composer.checkbox.use.apcu.to.cache.found.not.found.classes=使用 APCu 缓存找到/未找到的类
composer.checkbox.validate.package.dependencies=验证软件包依赖项
composer.checking.for.changes.in.code.of.dependencies.task.title=检查依赖项代码中的更改
composer.clearing.cache.action.name=清除缓存
composer.diagnose.task.title=诊断
composer.executable='composer' 可执行文件
composer.generate.list.popup.title=生成
composer.generating.autoloader.task.title=生成自动加载器
composer.json.custom.invalid.json=json 无效
composer.json.custom.packages.done=自定义仓库已加载
composer.json.custom.packages.empty=找不到软件包。请检查您的仓库
composer.json.exec.not.configured=自定义仓库无法加载。未配置 Composer 可执行文件路径
composer.json.open.tool.settings.intention=打开工具设置
composer.json.packages.loading.error=软件包未重新加载
composer.json.packages.refresh=软件包正在刷新
composer.json.packagist.packages.done=仅加载了 packagist 仓库
composer.json.packagist.packages.reused=正在重用软件包列表而不更新
composer.json.path.not.configured=自定义仓库无法加载。未配置 composer.json 路径
composer.label.can.be.time.consuming=可能较为耗时
composer.label.executable='composer' 可执行文件
composer.label.filter.packages=筛选软件包(&F)\:
composer.label.label=标签
composer.label.package=软件包\:
composer.label.path.to.composer.json=composer.json 路径(&C)\:
composer.label.phar=composer.phar
composer.label.the.settings.php.language.level.directories.may.be.updated=设置(Php 语言级别，目录)可能已更新
composer.label.version.to.install=要安装的版本\:
composer.listing.licenses.task.title=列出许可证
composer.packages.versions=Composer 软件包版本
composer.remove.action.name=移除(&R)
composer.require.package.task.title=需要 Composer 软件包
composer.revert.action.name=还原
composer.simulating.update.task.title=模拟更新
composer.update.composer.packages.task.title=更新 Composer 软件包
composer.update.composer.task.title=更新 Composer
composer.validate.dialog.action.button.title=验证
composer.validating.task.title=验证
composer.validation.settings.name=验证设置
composer.version.update.hint=已安装软件包的当前版本和可用更新。
composite.test.patterns=复合测试模式
config.file.doesnt.exist=配置文件不存在
configurable.PhpDebugConfigurable.display.name=调试
configurable.PhpProjectConfigurable.display.name=PHP
configurable.PhpServerConfigurable.display.name=服务器
configurable.PhpServersConfigurable.display.name=服务器
configurable.PhpSmartKeysConfigurable.display.name=PHP
configurable.PhpTemplatesCommonConfigurable.display.name=模板
configurable.PhpTestFrameworksConfigurable.display.name=测试框架
configurable.QualityToolCommonConfigurable.display.name=质量工具
configurable.name.php.servers=PHP 服务器
configurable.quality.tool.laravel.pint=Laravel Pint
configurable.quality.tool.mess.detector=Mess Detector
configurable.quality.tool.php.code.sniffer=PHP_CodeSniffer
configurable.quality.tool.php.cs.fixer=PHP CS Fixer
configure=配置
configure.php.include.paths=配置 PHP Include 路径(&O)…
configure.suppressed.annotations=配置禁止的注解
configured.is.incorrect=配置的 {0} 不正确
conflict.class.constant.with.same.name.already.exists=此类中已经定义了具有相同名称的常量
conflict.class.with.same.name.already.exists=已经定义了具有相同名称的类
conflict.constant.with.same.name.already.exists=已经定义了具有相同名称的常量
conflict.field.with.same.name.already.exists=此类中已经定义了具有相同名称的属性
conflict.function.with.same.name.already.exists=已经定义了具有相同名称的函数
conflict.method.with.same.name.already.exists=此类中已经定义了具有相同名称的方法
conflict.parameter.with.same.name.already.exists=已经定义了具有相同名称的形参
conflict.tag.name.contains.close.tag=文本包含“{0}”
conflict.template.parameter.with.same.name.already.exists=已存在同名的模板形参
conflict.use.with.same.name.already.exists=已经定义名称相同的 'Use' 语句
conflict.variable.with.same.name.already.exists=已经定义了具有相同名称的变量
connection.failed.message=连接失败。请检查您的网络连接并重试。
connection.port.is.busy=端口 {0} 繁忙
constant=常量
constant.0=常量 {0}
constant.expression.contains.invalid.operations=常量表达式包含无效运算
constant.ref.is.deprecated=常量 '\#ref' 已弃用
constant.ref.is.deprecated1=常量 '\#ref' 已弃用
constant.ref.not.found.in=在 {0} 中未找到常量 ''\#ref''
constant.with.same.name.already.exists.in.0={0} 中已经存在名称相同的常量
constant1=常量
constants.defined.using.the.const.keyword.must.be.declared.at.the.top.level.scope=使用 'const' 关键字定义的常量必须在顶层作用域声明
constants.may.only.evaluate.to.scalar.values.arrays.or.resources=常量的求值结果只能为标量值、数组或资源
constructor.already.exists=构造函数已存在
constructor.field=构造函数字段
constructors=构造函数
controversial.rules=有争议的规则
convert.closure.to.arrow.function=将闭包转换为箭头函数
convert.concatenation.to.sprintf.call=将串联转换为 'sprintf()' 调用
convert.function.into.static.expression=将函数声明转换为 static 表达式
convert.string.interpolation.to.concatenation=将字符串内插转换为串联
convert.string.interpolation.to.sprintf.call=将字符串内插转换为 'sprintf()' 调用
convert.the.arrow.function.to.a.traditional.closure=将箭头函数转换为传统闭包
copy=复制
copy.concatenated.string.to.clipboard=将串联的字符串复制到剪贴板
copy.handler.is.dumb.during.indexing=在项目分析进行期间复制类只会复制包含这些类的文件。您将必须手动更改命名空间和导入。是否仍要继续?
copy.switch.branch=复制 'switch' 分支
copy.to.namespace=目标命名空间\:
couldnt.update.php.ini=''zend_extension\=xdebug'' 未添加到 {0}。访问被拒绝。
coverage.is.not.supported.for.selected.run.profile=代码覆盖率与所选运行配置文件不兼容
create.missing.target.method.fix=创建缺少的目标方法修复
create.new.class.quickfix=创建一个新类
create.new.field.dialog.title=创建新字段
create.target.class.quick.fix=创建目标类快速修复
creates.new.class.0.in.a.separate.file=在单独的文件中创建名为 ''{0}'' 的新类
creates.new.class.method.0.in.a.separate.file=在单独的文件中使用方法 ''{1}'' 创建名为 ''{0}'' 的新类
custom.format.functions.dialog.class.placeholder=留空以添加纯函数
custom.format.functions.dialog.format.index.title=格式字符串模板的索引
custom.format.functions.dialog.validation.class.not.found=找不到类 {0}
custom.format.functions.dialog.validation.format.index=索引必须为非负数
custom.format.functions.dialog.validation.function.not.found=找不到函数 {0}
custom.format.functions.dialog.validation.method.not.found=在 {1} 中找不到方法 {0}
day.of.the.month.2.digits.with.leading.zeros=月中几号，2 位数，带前导零(01到 31)
day.of.the.month.without.leading.zeros=月中几号，不带前导零(1 到 31)
days.numeric=天，数字(1、3、31)
days.numeric.at.least.2.digits.with.leading.0=天，数字，至少 2 位数，带前导 0 (01、03、31)
dbgp.invalid.packet=无效数据包
dbgp.proxy=Xdebug 代理
dbgp.proxy.cannot.connect.to.host=无法连接到主机 ''{0}''
dbgp.proxy.cannot.connect.to.xdebug.proxy=无法连接到 ''{0}\:{1}'' 上的 Xdebug 代理
dbgp.proxy.host=代理主机
dbgp.proxy.ide.key=IDE 键
dbgp.proxy.ide.register.error=无法使用 IDE 键 ''{0}'' 注册 IDE
dbgp.proxy.ide.register.success=IDE 已成功使用 IDE 键 ''{0}'' 注册
dbgp.proxy.ide.unregister.success=IDE 已成功注销
dbgp.proxy.port=代理端口
dbgp.proxy.sending.request.to.xdebug.proxy=正在将请求发送到 Xdebug 代理…
dead.code.commented.out=注释掉
dead.code.deleted=已删除
debug.accept.connection=接受
debug.action.copy.as.title=将变量复制为 ''{0}''
debug.action.copy.as.was.fail.can.not.get.full.name=无法将变量复制为 ''{0}''，无法对完整的变量名求值
debug.breakpoint.move.disabled=断点移动到解析的位置已被禁用，从下一个调试会话开始将不会移动断点。您可以稍后在 <a href\="open">PHP|调试</a>下将其启用。
debug.breakpoint.resolved.disabled=断点解析已被禁用，从下一个调试会话开始将不会解析断点。 您可以稍后在 <a href\="open">PHP|调试</a>下将其启用。
debug.breakpoint.resolved.notify.disabled=断点解析通知已被禁用。您可以在 <a href\="open">PHP|调试|高级设置</a>下将其启用。
debug.breakpoint.was.moved=<br/>断点也已移至此行。
debug.breakpoint.was.resolved=此处的调试会话已暂停，因为 ''{0}'' 处的断点已被解析到此行。<br/>您可以<a href\="disable">禁用</a>断点解析或<a href\="more">了解详情</a>。<a href\="dontshow">不再显示</a>
debug.cannot.find.port=找不到可用端口
debug.cannot.map.local.file=文件路径未映射到服务器上的任何文件路径。编辑路径映射以解决此问题。
debug.cannot.start=无法启动 ''{0}''
debug.cannot.start.listening.for.connections.from.0=无法开始侦听来自 ''{0}'' 的连接
debug.check.firewall=请检查您的防火墙设置
debug.checkbox.can.accept.external.connections=可以接受外部连接
debug.checkbox.ignore.z.ray.system.requests=忽略 Z-Ray 系统请求
debug.composite.value.presentation=[{0}]
debug.configure.servers=配置服务器
debug.debug.port=调试端口\:
debug.edit.ignored.paths.list=<a href\="\#a">编辑</a>跳过的路径。
debug.edit.path.mappings=点击以设置路径映射
debug.error=错误
debug.error.cannot.evaluate.expression=无法对表达式求值
debug.error.cannot.evaluate.expression0=无法对表达式 ''{0}'' 求值
debug.error.cannot.evaluate.variables=无法对变量求值
debug.error.cannot.modify.value=无法修改值
debug.error.cannot.parse.server.name=要修复，请在远程服务器上创建环境变量 <i><b>PHP_IDE_CONFIG</b></i>。<br/><br/><i>Windows\:</i> 设置 PHP_IDE_CONFIG\="serverName\=SomeName"<br/> <i>Linux / Mac OS X\:</i> 导出 PHP_IDE_CONFIG\="serverName\=SomeName"。
debug.error.cannot.parse.server.name.for.external.connection=无法为外部 {0} 连接解析服务器名称。
debug.error.cannot.parse.ssh.connection=无法从 $_SERVER[''SSH_CONNECTION''] 解析端口\: ''{0}''
debug.error.server.name.is.empty=<i><b>$_SERVER["SERVER_NAME"]</i></b> 为空，这可能是 Web 服务器配置错误所致。<br/><br/><i>Nginx\:</i> 将 fastcgi 形参添加至 nginx 配置，<a href\="http\://wiki.nginx.org/PHPFcgiExample">更多</a><br/><i>Apache\:</i> 为当前 VirtualHost 配置 ServerName，<a href\="https\://httpd.apache.org/docs/2.4/vhosts/name-based.html">更多</a>
debug.error.title.cannot.accept.external.0.connection=无法接受外部 {0} 连接
debug.error.unknown.debugger.id=未检测到调试器扩展
debug.error.wrong.debugger.id=不支持 {0}
debug.expression.evaluation.fail=由于返回值未知，无法对表达式求值
debug.file.is.ignored=文件 ''{0}'' 被跳过。
debug.function.was.added.to.skip.list=''{0}'' 已添加到跳过列表。
debug.ignore.connection=忽略
debug.incoming.connection.title.0=来自 {0} 的传入连接
debug.label.file.path.in.project=项目中的文件路径\:
debug.label.file.path.on.server=服务器上的文件路径\:
debug.label.max.simultaneous.connections=最大同时连接数\:
debug.label.select.a.project.or.a.file.to.debug=选择一个项目或文件进行调试
debug.label.select.a.project.to.debug=选择一个项目进行调试
debug.log.cant.register.breakpoint.no.remote=无法注册断点。没有本地路径 ''{0}'' 的路径映射
debug.log.cant.register.breakpoint.no.template.mapping=无法注册断点。没有到 PHP 行 ''{0}'' 的映射
debug.log.connection.was.terminated=调试连接在 ''{0}''\:''{1}'' 上意外终止
debug.log.exception.break=异常中断\: {0} ({1})
debug.log.invalid.xdebug.message=由于 Xdebug 消息无效，无法在断点处停止。\n要解决此问题，请切换到稳定版本的 Xdebug 或使用 'xdebug.remote_log' 选项收集日志并创建错误报告。 
debug.log.path.mapping.remote.extracted=远程\: ''{0}'' <-> 提取\: ''{1}''
debug.log.path.mapping.remote.local=远程\: ''{0}'' <-> 本地\: ''{1}''
debug.log.stack.frame=框架\: {0}\:{1}，{2}
debug.log.stop=停止于 (''{0}''\:{1})
debug.mapping.resolve.dialog.stop.debugger=停止调试器
debug.not.installed=<未安装>
debug.output=输出
debug.path.on.server=服务器上的绝对路径
debug.php.breakpoint.failed.to.register=无法注册断点，请尝试将其禁用并重新启用。
debug.php.exception.breakpoint.dialog.title=添加异常断点
debug.php.exception.breakpoint.exception.name=异常名称\:
debug.php.exception.breakpoint.not.supported=加载的调试扩展不支持异常断点
debug.php.exception.breakpoint.title=PHP 异常断点
debug.php.exception.breakpoint.zend.not.supported=Zend Debugger 不支持异常断点
debug.php.external.connection.finished.break.at.first.line=<b><i>'在第一行中断'</i></b> 选项已启用
debug.php.external.connection.finished.break.at.first.line.title=PHP 调试配置
debug.php.external.connection.finished.warning=这可能是由于路径映射配置错误或本地和远程项目未同步。<br/><br/>要找出问题，请在 <b><i><a href\="servers">PHP|服务器</a></i></b>下检查 ''{0}'' 服务器的路径映射配置，或启用 <b><i><a href\="break">''在 PHP 脚本中的第一行中断''</a></i></b> 选项(位于<i>运行</i>菜单下)。<br/><a href\="ignore">不再显示</a>
debug.php.external.connection.finished.warning.title=调试会话已完成且未暂停
debug.php.line.breakpoint.title=PHP 行断点
debug.php.method.breakpoint.dialog.title=添加方法断点
debug.php.method.breakpoint.title=PHP 方法断点
debug.php.method.breakpoint.zend.not.supported=Zend Debugger 不支持方法断点
debug.port.is.updated=设置中指定的端口 {0} 正在使用中。端口 {1} 可用，可由 Xdebug 使用。请使用 {2} 更新 php.ini
debug.port.is.updated.descr=设置中指定的端口 {0} 正在使用中。端口 {1} 可用，可由 Xdebug 使用。
debug.ports.is.updated=设置中指定的所有端口都在使用中。端口 {0} 可用，可由 Xdebug 使用。请使用 {1} 更新 php.ini
debug.process.cannot.find.file=在本地找不到文件 ''{0}''。\n要修复，请通过环境变量 PHP_IDE_CONFIG 设置服务器名称，然后重启调试会话。
debug.process.cannot.find.file.in.project=在项目中找不到路径为 ''{0}'' 的文件
debug.process.cannot.find.file.link=更多信息
debug.process.cannot.find.local.file=在服务器 {0} 上找不到文件的本地副本\n本地路径为 {1}
debug.process.cannot.find.path.mapping=远程文件路径 ''{0}'' 未映射到项目中的任何文件路径
debug.process.cannot.find.remote.copy.local.file=项目 ''{0}'' 中的文件路径未映射到服务器上的任何文件路径
debug.process.cannot.find.server.name=找不到源位置。名称为 ''{0}'' 的服务器不存在。
debug.process.cant.compute.source.position=无法计算源位置。脚本 ''{0}'' 未与任何文本文件类型关联。
debug.process.console.error.format={0}\: {1}，{2} 中的第 {3} 行\n
debug.process.script.outside.project=脚本 ''{0}'' 在项目外部。
debug.process.smart.step.into.function.evaluation.error=无法对目标函数求值。将执行“单步跳入”。
debug.process.smart.step.into.function.was.not.executed=尚未调用所选函数。
debug.process.smart.step.into.popup=步入函数
debug.process.status.connected=已连接
debug.process.status.disconnected=已断开连接
debug.process.status.wait=正在等待与{0} ''{1}'' 的传入连接
debug.resolve.mapping.problem=解决路径映射问题
debug.rest.client.error.cannot.evaluate.server.name=无法评估 '$_SERVER['SERVER_NAME']'。请确保为您的 Web 服务器配置了正确的服务器名称。<br>点击此<a href\="help">链接</a>获取更多信息。
debug.rest.client.error.cannot.evaluate.server.name.title=无法通过服务器名称找到对应的“PHP|服务器”
debug.server.can.not.detect.path.mappings.from.deployment=无法评估路径映射\: 未选择目标部署服务器
debug.server.detect.path.mappings.from.deployment=正在检测现有路径映射…
debug.server.detect.path.mappings.from.deployment.progress=正在为 ''{0}'' 项目分析路径映射
debug.server.import.configuration.deployment=部署(&D)\:
debug.server.import.configuration.dialog.title=从部署配置导入
debug.server.import.configuration.local=本地(&L)
debug.server.import.configuration.local.file.path=本地文件路径\:
debug.server.import.configuration.mounted=已挂载(&M)
debug.server.import.configuration.path.to.remote.root=部署根的绝对路径(&R)\:
debug.server.import.configuration.path.to.remote.root.mounted=本地\: ''{0}'' -> 远程\: ''{1}''
debug.server.import.configuration.path.to.remote.root.mounted.label=已挂载文件夹的远程路径(&R)\:
debug.server.import.configuration.path.to.remote.root.mounted.tooltip=远程文件的绝对路径\:<br>"已挂载文件夹的远程路径" . "服务器上的相对部署路径" (来自部署路径映射)
debug.server.import.configuration.path.to.remote.root.sftp=绝对远程根\: ''{0}''
debug.server.import.configuration.path.to.remote.root.sftp.tooltip=远程文件的绝对路径\:<br>"远程根的绝对路径" . "根路径" (来自部署设置) . "服务器上的相对部署路径" (来自部署路径映射)
debug.server.import.configuration.preview.border.title=预览
debug.server.import.configuration.project=项目(&P)\:
debug.server.import.from.deployment.deployment.configurations.message=找到具有相关路径映射的部署配置。
debug.server.import.from.deployment.deployment.root.label=部署根(&R)\:
debug.server.import.from.deployment.no.deployment.configurations.message=找不到合适的部署配置
debug.server.import.from.deployment.no.deployment.configurations.tooltip=配置部署根(如果不为空)
debug.server.import.from.deployment.radio=从部署导入映射(&I)
debug.server.manually.select.file.message=选择一个项目或文件进行调试
debug.server.manually.select.file.or.project=手动选择本地文件或项目(&M)
debug.server.select.file.mapping=配置本地文件路径
debug.settings.auto.detect.ide.host=自动检测 IDE IP\:
debug.settings.broadcasting.port=设置广播端口\:
debug.start.listen.debug.connections=开始侦听 PHP 调试连接
debug.stop.listen.debug.connections=停止侦听 PHP 调试连接
debug.type.float=浮点
debug.type.int=int
debug.type.resource=资源
debug.xdebug=Xdebug
debug.xdebug.error.unsupported.protocol.version=不支持的 Xdebug 协议版本
debug.zend.cannot.accept.incoming.connection=无法接受来自 Zend Debugger 的传入连接
debug.zend.debugger=Zend 调试器
debug.zend.debugger.settings.broadcasting=Zend Debugger 设置广播
debug.zend.error.title.cannot.accept.external.xdebug.connection=无法接受外部 Xdebug 连接
debug.zend.required.protocol.version.0.or.higher=所需协议版本为 ''{0}'' 或更高版本
debugger.method=方法
declaration.in.parent.class.is.incompatible.with.interface=父类中的声明与接口不兼容
declaration.must.be.compatible.with.0=声明必须与 {0} 兼容
declaration.must.be.compatible.with.super=声明必须与父级兼容
default=默认\:
default.value=默认值
delete.assignment=删除赋值
delete.case=删除 'case'
delete.catch.statement=删除 'catch' 语句
delete.elseif=删除 'elseif'
delete.if=删除 'if'
delete.redundant.method.override=移除方法
delete.redundant.switch.branch=删除冗余 'switch' 分支
delete.unused.element=删除未使用的元素
delete.void.return.type=删除 'void' 返回值类型
deprecated.form.of.callables=已弃用的可调用对象形式
design.rules=设计规则
diagnosing=正在诊断
dialog.error.title.php.extract.class=PHP 提取类
dialog.message.cannot.create.file.because.project.already.disposed=由于项目已被处置，无法创建文件
dialog.message.could.not.find.network.interface=找不到 {0} 网络接口
dialog.message.do.you.want.to.upload.content.scratch.file.to.3v4l.org.make.it.public=是否要将临时文件的内容上传到 3v4l.org 并将其公开?
dialog.message.docker.account.not.found=找不到 Docker 帐户
dialog.message.docker.account.not.specified=未指定 Docker 帐户
dialog.message.execution.quality.tools.in.untrusted.project.prohibited=禁止在不受信任的项目中执行质量工具
dialog.message.no.interface.addresses.for.network.interface=没有 {0} 网络接口的接口地址
dialog.message.port.cannot.be.negative.number=端口号不能为负
dialog.message.query.string.cannot.start.with=查询字符串不能以 '?' 开头
dialog.message.server.host.cannot.be.empty=服务器主机不能为空
dialog.message.unable.to.create.configurations.with.same.executable.path=同一 Composer 项目的同一解释器的配置发生冲突\: {0}
dialog.title.configure.code.patterns=配置代码模式…
dialog.title.edit.phpunit.test.pattern=编辑 PHPUnit 测试模式
dialog.title.enter.tag.name=输入标记名称
dialog.title.inline.variable=内联变量
dialog.title.new.php.file=新建 PHP 文件
dialog.title.select.methods.to.propagate.safe.delete=选择要传播安全删除的方法
dialog.title.select.parameters.to.propagate.safe.delete=选择要传播安全删除的形参
dialog.title.select.properties.to.initialize=选择要初始化的属性
difference.to.greenwich.time.gmt.with.colon.between.hours.and.minutes=与格林威治时间(GMT)的差值，小时和分钟之间有冒号(+02\:00)
difference.to.greenwich.time.gmt.without.colon.between.hours.and.minutes=与格林威治时间(GMT)的差值，小时和分钟之间没有冒号(+0200)
directories=目录
display.name.directory.0=目录 ''{0}''
do.not.ask.again=不再询问
do.not.override=不重写
docker.compose.border.title.lifecycle=生存期
docker.compose.coverage.file.failed.to.copy=无法从 Docker 容器复制覆盖率结果
docker.compose.coverage.file.failed.to.extract=无法提取覆盖率结果
docker.compose.coverage.file.is.not.found=找不到覆盖率文件
docker.compose.failed.to.start.container=启动 docker-compose 服务失败，请在命令行中启动并重试
docker.compose.radio.button.always.start.a.new.container.docker.compose.run=始终启动一个新容器('Docker-compose run')
docker.compose.radio.button.connect.to.existing.container.docker.compose.exec=连接到现有容器('Docker-compose exec')
docker.host.name.error=主机名与 <i>host.docker.internal</i> 不同
docker.host.name.error.descr=<i>host.docker.internal</i> 解析为主机使用的内部 IP 地址
doctrine.query.builder.completion.ascending.order.description=从最小到最大
doctrine.query.builder.completion.descending.order.description=从最大到最小
doctrine.query.builder.parameter.name=DQL 形参
doctrine.query.builder.table.name=DQL 表名称
download.validation.script=下载 Xdebug 验证脚本
duplicate.value.in.enum.for.cases.0.and.1=case ''{0}'' 和 ''{1}'' 的枚举中的重复值
duplicate.variable.0=重复的变量 ''{0}''
dynamically.declared.field=动态声明的字段
edit.custom.format.function=编辑自定义格式函数
edit.template=编辑模板
empty.extends.list=空 extends 列表
empty.implements.list=空实现列表
empty.pattern=空模式
empty.type=空类型
enable=启用
enable.navigate.links.for.class.and.member.references=为类和成员引用启用“… 导航”链接
enable.return.function.value.debugging.xdebug.3.2=启用返回函数值调试 (Xdebug 3.2+)
enable.support=启用支持
enable.the.following.extension=在 PHP 运行时选项中启用以下扩展存根\:
enable.tostring.object.view=启用 '__toString' 对象视图
enables.inspection.0=启用检查 ''{0}''
english.ordinal.suffix.for.the.day.of.the.month.2.characters=月中几号的英语序数后缀，2 个字符(st、nd、rd、th)
enter.annotation=输入注解
entry.points=入口点
entry.points.tab=入口点
enum=枚举
enum.backing.type.must.be.int.or.string=枚举支持类型必须为 'int' 或 'string'
enum.backing.type.must.be.int.or.string.0.given=在给出 ''{0}'' 的情况下，枚举支持类型必须为 ''int'' 或 ''string''
enum.case=枚举 case
enum.case.should.be.located.only.inside.enum.classes=枚举 case 只应位于枚举类内部
enum.case.type.0.does.not.match.enum.backing.type.1=枚举 case 类型 ''{0}'' 与枚举支持类型 ''{1}'' 不匹配
enum.case.value.must.be.constant=枚举 case 值必须为常量
enum.may.not.include.0=枚举不得包含 ''{0}''
enum.may.not.include.extend=枚举不得扩展其他类
enum.properties.are.immutable=枚举属性不可变
enum.value.cannot.referer.to.enum.cases=枚举值不能引用枚举 case
enums.may.not.be.cloned=不得克隆枚举
enums.may.not.implement.the.serializable.interface=枚举可能不会实现 'Serializable' 接口
enums.may.not.include.properties=枚举不得包含属性
environment.key.description.run.composer.install=定义找不到 'vendor' 目录时是否运行 'composer install'\n值\: 'false' (默认值)或 'true'
error.cannot.connect.to.0=无法连接到 ''{0}''
error.cannot.connect.to.0.1=无法连接到 ''{0}''\: {1}
error.cant.create.edge=无法创建关系链接
error.during.access.to.3v4l.org=访问 3v4l.org 时出错
error.file.unable.create.selected.directory=无法在所选目录中创建文件 {0}
error.template.unable.create.from.internal.template=无法从内部模板 {0} 创建文件
error.template.unable.parse.internal.template=无法解析内部模板 {0}
exception.analysis.settings.path=PHP/分析
exception.class=异常类
exclude.0.from.1.analysis.a=从{1}分析中排除{0}。
executable.0.was.not.found.in.path.please.make.sure.it.s.there.possible.solutions=在 %PATH% 中找不到可执行文件 ''{0}''。请确保已指定有效路径。可能的解决方案\:
executable.0.was.not.found.in.path.please.make.sure.it.s.there.possible.solutions1=在 $PATH 中找不到可执行文件 ''{0}''。请确保已指定有效路径。可能的解决方案\:
execution.result.is.null=执行结果为 null
execution.statistics=执行统计
expected.class.reference=应为\: 类引用
expected.expression.after.spread.operator=应为\: 展开运算符后的表达式
expected.property=属性
explore.migration.guides=探索迁移指南
expression=表达式
expression.0=表达式 {0}
expression.is.not.allowed.as.constant.value=表达式不允许作为常量值
expression.is.not.allowed.as.field.default.value=表达式不允许为字段默认值
expression.is.not.allowed.as.parameter.default.value=表达式不允许为形参默认值
expression.is.not.allowed.as.static.initializer=表达式不允许为 static 初始值设定项
expression.is.not.assignable=表达式不可赋值
expression1=表达式
expressions=表达式
extends=扩展
extends.implements.overrides=扩展/实现/重写
extends.or.implements=扩展或实现
external.formatter.after=启用外部格式化程序会禁用 IDE 的内置格式化程序
external.formatter.couldnt.run.tool={0} 无法启动。请检查您的配置。
external.formatter.phpcbf=PHP Code Beautifier and Fixer
external.formatter.phpcsfixer=PHP CS Fixer
extract.condition=提取条件
extract.method.link.label.more.options=更多选项
extract.method.parameter.name.column.title=形参
extract.method.selector.title=要提取的代码
extract.selected.string.part.as.concatenation.operand=将所选字符串部分作为串联操作数提取
extract.selected.string.part.as.format.function.argument=将所选字符串部分作为格式函数实参提取
extract.side.effect=提取副作用
failed.to.find.interpreter=无法查找解释器
failed.to.find.valid.interpreter.path=无法查找有效的解释器路径
failed.to.parse.php.ini.output.0=无法解析 php --ini 输出\: {0}
failed.to.retrieve.php.versions.from.3v4l.org=无法从 3v4l.org 检索 PHP 版本信息
failed.to.run.interpreter=无法运行解释器
field=字段
field.name=字段名称
field.ref.is.deprecated=字段 '\#ref' 已弃用
field.ref.not.found=找不到字段 '\#ref'
field1=字段
fields.cannot.be.declared.abstract=属性不能声明为 abstract
fields.cannot.be.declared.final=属性不能声明为 final
fields.default.visibility.private=private
file=文件
file.0.does.not.exist=文件 {0} 不存在
file.0.does.not.exists=文件 {0} 不存在
files.in.the.directory.should.be.accessible.by.0.request=目录中的文件应当可通过 {0} 请求进行访问。
files.in.the.remote.directory.should.be.accessible.by.0.request=远程目录中的文件应当可通过 {0} 请求进行访问。
filetype.composer.log.description=Composer 日志
filetype.doctrine.query.description=Doctrine 查询语言
filetype.phar.description=Php Phar
filetype.phar.display.name=Php Phar
filetype.php.description=PHP
filetype.profiler.snapshot.description=分析器快照
final=final
final.class.cant.be.inherited=类 {0} 为 final
final.modifier.is.not.allowed.here=此处不允许使用 'final' 修饰符
find.cause=查找原因
find.classes.without.member=查找没有成员的类
find.exception.cause.table.title=异常原因
find.field.accessors.text=是否要搜索 ''{0}'' 的访问器?
find.field.accessors.title=搜索访问器
find.options.include.child.methods.checkbox=包括重写/实现方法(&V)
find.usages.button.base.method=基方法
find.usages.button.current.method=当前方法
find.usages.prompt.dialog.implements=类 ''{1}'' 的方法 ''{0}()'' 在 ''{2}'' 中实现了{3,choice,0\#方法|1\#方法}\n是否要查找基{3,choice,0\#方法|1\#方法}的用法?
find.usages.prompt.dialog.overrides=类 ''{1}'' 的方法 ''{0}()'' 在 ''{2}'' 中重写了{3,choice,0\#方法|1\#方法}\n是否要查找基{3,choice,0\#方法|1\#方法}的用法?
fix.not.available=修复不可用
fix.package.text=将命名空间 ''{0}'' 替换为 ''{1}''
fix.package.text.family=修复命名空间 
flip.key.value.intention.family.name=翻转键和值
flip.key.value.intention.message.all.in.array=翻转数组中的所有键和值
flip.key.value.intention.message.single=翻转键和值
fluent.setters=Fluent setter
folding.checkbox.collapse.attribute=特性
folding.checkbox.collapse.attribute.list=特性列表
folding.checkbox.collapse.classes=类主体
folding.checkbox.collapse.function.body=函数体
folding.checkbox.collapse.heredocs.and.nowdocs=heredoc/nowdoc
folding.checkbox.collapse.imports=Import
folding.checkbox.collapse.method.body=方法体
folding.checkbox.collapse.php.tags=标记
follow.this.0.for.more.information.about.deployment=有关部署的详细信息，请参阅此{0}。
follow.this.0.for.more.information.about.path.mappings=有关路径映射的详细信息，请参阅{0}。
follow.this.links.to.install.and.configure.0.or.1=点击这些链接以安装并配置 {0} 或 {1}。
for=for
foreach=foreach
found.roots.configured=检测到并配置了 PSR-0 根
framework.composer=Composer
framework.composer.0.1.version.2={0} {1}，版本 {2}
framework.composer.add.composer.dependency.title=管理 Composer 依赖项
framework.composer.add.dependency.available.packages.label=可用软件包
framework.composer.add.dependency.close.button=关闭(&C)
framework.composer.add.dependency.hide.tooltip=隐藏
framework.composer.add.dependency.install.button=安装
framework.composer.add.dependency.no.new.version.found.for.0=找不到 {0} 的新版本。
framework.composer.add.dependency.no.package.selected=未选择软件包
framework.composer.add.dependency.no.such.package=packagist 上无此类软件包
framework.composer.add.dependency.no.version.selected=未选择版本
framework.composer.add.dependency.running=正在运行
framework.composer.add.dependency.settings.cl.dialog.title=形参
framework.composer.add.dependency.settings.cl.label=命令行形参(&P)\:
framework.composer.add.dependency.settings.interpreter.label=PHP 解释器\:
framework.composer.add.dependency.settings.title=设置(&S)
framework.composer.add.dependency.show.output=显示输出
framework.composer.add.dependency.successfully.installed.0.version.1=已成功安装 {0}，版本 {1}。
framework.composer.add.dependency.successfully.removed.0=已成功移除 {0}。
framework.composer.add.dependency.successfully.updated.0=已成功更新 {0}。
framework.composer.add.dependency.task.title=添加依赖项
framework.composer.add.dependency.update.button=更新
framework.composer.available.version=可用版本\:
framework.composer.checking.for.update=正在检查更新…
framework.composer.configurable.title=Composer
framework.composer.create.project.from=自以下创建项目
framework.composer.create.project.progress.title=创建项目
framework.composer.default.composer.interpreter.name=Composer 的解释器
framework.composer.default.interpreter.for.this.project.is.remote=此项目的默认解释器是远程解释器，无法使用。
framework.composer.default.interpreter.is.not.configured=尚未为此项目配置默认解释器。
framework.composer.default.project.interpreter=默认项目解释器
framework.composer.empty.package.name.in.0={0} 中的软件包名称为空
framework.composer.empty.path.to.0={0} 的路径为空
framework.composer.expected.name.0.versions.0.description.got.1=应为 <name> {0} <versions> {0} <description>，获得的是 {1}
framework.composer.failed.check.for.update=无法运行 'update --dry-run' 命令。
framework.composer.failed.to.0=无法{0}。
framework.composer.failed.to.0.1.script.was.cancelled=无法{0} {1}。脚本已被取消。
framework.composer.failed.to.download.composer.phar=无法下载 composer-stable.phar
framework.composer.failed.to.load.package.names=无法加载软件包名称。
framework.composer.failed.to.parse.package.description=无法解析软件包描述。
framework.composer.failed.to.parse.package.names=无法解析软件包名称。
framework.composer.file.0.is.not.found=找不到文件 ''{0}''。
framework.composer.file.0.set.as.composer.config.change.setting.a.href.here.a=文件 ''{0}'' 设置为 Composer 配置。
framework.composer.init.dialog.title.composer.settings=Composer 设置
framework.composer.initialize.popup=找到了 Composer 配置文件 {0}。项目设置与其同步。
framework.composer.initialize.popup.multi.composer=找到 {0} 个 composer 配置文件。项目设置已与其同步。
framework.composer.install.action.name=安装
framework.composer.install.task.title=正在安装软件包
framework.composer.interpreters.combo.default.interpreter=< 默认解释器 >
framework.composer.interpreters.combo.default.interpreter.no.php.path=默认解释器未提供 PHP 路径
framework.composer.interpreters.combo.default.project.interpreter=< 默认项目解释器 >
framework.composer.interpreters.combo.no.default.interpreter=默认设置中没有默认解释器
framework.composer.interpreters.combo.no.default.interpreter.in.project=此项目中没有默认解释器
framework.composer.label.installed.version=已安装的版本\:
framework.composer.label.version.to.install=要安装的版本(&V)\:
framework.composer.load.update.availability=检查可用软件包更新
framework.composer.loading.package.description=正在加载软件包描述
framework.composer.loading.packages=正在加载 Composer 软件包
framework.composer.loading.update.availability=正在检查 Composer 软件包更新
framework.composer.name.composer=Composer
framework.composer.no.description.available=无可用描述。
framework.composer.no.package.versions.in.0={0} 中没有软件包版本
framework.composer.notification.title.init.composer=初始化 Composer
framework.composer.notify.about.missing.vendor=缺少 'vendor' 目录时通知
framework.composer.package.default.version=<默认>
framework.composer.package.version.available.0={0}的更新
framework.composer.packages.were.added.0.excluded.folders.popup=Composer 软件包已被添加到排除的文件夹中。
framework.composer.packages.were.added.0.php.include.paths.popup=Composer 软件包已被添加到 PHP include 路径中。
framework.composer.packages.were.changed.0.excluded.folders.popup=Composer 软件包已更改，因此更新了排除的文件夹。
framework.composer.packages.were.changed.0.php.include.paths.popup=Composer 软件包已更改，因此更新了 PHP include 路径。
framework.composer.packages.were.changed.0.test.config.popup={0} 配置已根据 composer.json 更新
framework.composer.packages.were.changed.0.test.config.title=Composer 软件包已被更改
framework.composer.packages.were.moved.to.0.php.include.paths.popup=Composer 软件包已从 Composer 外部库移至 PHP include 路径。
framework.composer.packages.were.removed.0.excluded.folders.popup=Composer 软件包已从排除的文件夹中移除。
framework.composer.packages.were.removed.0.php.include.paths.popup=Composer 软件包已从 PHP include 路径中移除。
framework.composer.path.dialog.path.to.composer=Composer 路径
framework.composer.path.dialog.path.to.composer.json=composer.json 路径
framework.composer.path.dialog.specify.composer.executable=指定 Composer 可执行文件\:
framework.composer.path.dialog.specify.composer.json=指定 composer.json\:
framework.composer.path.dialog.specify.composer.phar=指定 Composer phar\:
framework.composer.path.form.empty.path.to.composer.executable=Composer 可执行文件路径为空
framework.composer.path.form.empty.path.to.composer.json=composer.json 路径为空
framework.composer.path.form.empty.path.to.composer.phar=composer.phar 路径为空
framework.composer.path.form.execution.validation.wrapper=<html>执行未设置。<br/>{0}</html>
framework.composer.path.to.php.executable.titled=PHP 可执行文件的路径
framework.composer.path.validation.0.is.a.directory={0} 是目录
framework.composer.project.generation.error.title=无法创建 Composer 项目
framework.composer.project.generator.description=通过 Composer 命令创建项目。
framework.composer.project.generator.failed.to.copy.temp.directory.0.content.to.project.root=无法将临时目录 ''{0}'' 内容复制到项目根
framework.composer.project.generator.name=Composer 软件包项目
framework.composer.project.generator.notification.content.failed.to.find=找不到 {0}
framework.composer.project.generator.notification.content.failed.to.find.composer.json=无法在项目根中找到 composer.json
framework.composer.remove.action.name=移除
framework.composer.removing.package.task.title=移除软件包
framework.composer.require.action.name=需要
framework.composer.require.task.title=正在安装软件包 {0}
framework.composer.run.path.to.composer.json=composer.json 路径\:
framework.composer.run.script=脚本\:
framework.composer.run.script.missing=未指定 Composer 脚本
framework.composer.script.run.configuration.description=Composer 脚本运行配置
framework.composer.script.run.configuration.name=Composer 脚本
framework.composer.selected.file.is.not.composer.json=所选文件不是 composer.json
framework.composer.self.update.action.name=自我更新
framework.composer.self.update.task.title=更新 Composer
framework.composer.specify.php.executable.0=指定 PHP 可执行文件 {0}
framework.composer.update.action.name=更新
framework.composer.update.task.title=正在更新软件包
framework.composer.updating.package.task.title=更新软件包
framework.composer.vendors.library.name=Composer 供应商
frameworks.composer.could.not.get.package.info=无法获取软件包信息。
frameworks.composer.could.not.get.packages.info.0=无法获取软件包信息。{0}
frameworks.settings.none.installed=没有可用的框架设置提供程序。<br/>考虑安装 Drupal Support、Joomla\! Support 或 WordPress Support 插件。
frameworl.composer.show.quick.actions=显示具有快速操作的 composer.json 顶部面板
function=函数
function.call=函数调用
function.call.is.not.allowed.here=此处不允许使用函数调用
function.call.is.not.compatible.with.advance.callable.declaration=函数调用与 'callable' 声明不兼容
function.fqn=函数 FQN
function.has.parameter.with.incompatible.default.value.type=函数有一个默认值与其声明的类型不兼容的形参
function.name.must.be.callable.a.string.closure.or.class.implementing.invoke.currently.0=函数名称必须可调用 - 字符串、闭包或实现 ''__invoke'' 的类，当前为 ''{0}''
function.ref.is.deprecated=函数 '\#ref' 已弃用
function2=函数
functions.to.be.extracted=要提取的函数
generating.autoloader=正在生成自动加载器
getters.setters.configure=配置…
getting.installed.standards=正在获取已安装的标准…
global.code.should.be.enclosed.in.global.namespace.declaration=全局代码应包含在全局命名空间声明中
global.namespace.should.use.braced.syntax=全局命名空间应使用带大括号的语法
global.this.is.deprecated=不能将 $this 用作全局变量，它已在 PHP 7.1 中弃用
global.variable.from.globals.array.assignment=来自 $GLOBALS 数组赋值的全局变量
globals.can.only.be.modified.using.the.globals.name.value.syntax='$GLOBALS' 只能使用 '$GLOBALS[$name] \= $value' 语法进行修改
group.ComposerGroup.text=Composer
group.ComposerToolsGroup.text=Composer
group.DBGPProxyGroup.text=DBGp 代理
group.PHPQualityToolsAddToIgnoredList.text=添加到忽略列表…
group.PhpDebuggerCopyAsGroup.text=将值复制为…
group.PhpNewTestGroup.text=PHP 测试
group.advanced.settings.php=PHP
group.methods.by.type=按类型对方法分组
group.use.statements.by.selected.prefix=按所选前缀将 'use' 语句分组
guality.tool.configuration.show.ignored.files=显示忽略的文件
gutter.overriden.select.implementation.title=选择 {0} 的实现
gutter.overriden.select.subclass.title=选择 {0} 的子类
gutter.overriding.select.title=选择要导航的父方法
gutter.pin.overriden.select.implementation.title={0} 的实现
gutter.pin.overriden.select.subclass.title={0} 的实现
gutter.pin.overriding.select.title={0} 的父项
guzzle.http.request.gutter.name=Guzzle HTTP 请求
guzzle.invalid.http.request.file=文件 ''{0}'' 是无效的 HTTP 请求文件
guzzle.name=Guzzle
guzzle.open.http.request=在 HTTP 请求编辑器中打开
guzzle.unable.to.add.new.request.to.file=无法向 ''{0}'' 文件添加新请求
guzzle.unable.to.extract.request.parameters=无法提取请求形参
halt.compiler.can.only.be.used.from.the.outermost.scope=仅可从最外侧作用域使用 '__halt_compiler()'
handler.with.the.same.session.id.is.already.registered=已注册使用相同会话 ID 的处理程序
hint.evaluation.fully.contains=求值结果完全覆盖 ''{0}'' 的可能结果
hint.evaluation.makes.array.always.empty=求值使得数组始终为空
hint.evaluation.makes.subsequent.condition.always.true=求值使后续条件始终为 ''{0,choice,0\#false|1\#true}'
hint.text.can.not.find.target.class.for.modification=找不到要修改的目标类。
hint.text.element.doesn.t.have.fqn=元素没有 FQN
hint.text.installed.version=已安装的版本
hint.text.target.class.does.not.belong.to.project.can.not.be.modified=目标类 {0} 不属于该项目\n并且无法修改。
hint.text.target.class.not.writable=目标类 {0} 不可写。
hint.text.use.statement.choice.s.removed={0} ''use'' 语句{1, choice, 0\#|1\#}已移除
hint.text.use.statements.checked.nothing.was.removed=已检查 {0} ''use'' 语句，未移除任何内容
host.name.eg.localhost.example.com=主机名。例如，localhost.example.com
hours.numeric=小时，数字(1、3、23)
hours.numeric.at.least.2.digits.with.leading.0=小时，数字，至少 2 位数，带前导 0 (01、03、23)
how.to.fix=修正方法
html.note.core.extensions.are.part.of.the.php.core.and.cannot.be.left.out.of.a.php.binary.with.compilation.options.html=<html>注\: 核心扩展是 PHP 核心的一部分，不能放在包含编译选项的 PHP 二进制文件外部。</html>
http.client.request.init.debug.connection.title=正在初始化调试连接
identifier=标识符
if.with.common.parts=具有通用部分的 'if'
if.you.have.already.configured.debug.extension.in.php.ini.file.check.possible.reasons.why.it.was.not.loaded=如果已在 php.ini 文件中配置调试扩展，请检查未加载该扩展的可能原因\:
if.you.ve.changed.the.path.recently.restart.the.ide=如果最近更改了 %PATH%，请重启 IDE。
if.you.ve.changed.the.path.recently.restart.the.ide1=如果最近更改了 $PATH，请重启 IDE。
ignore.imports.and.formatting=忽略导入和格式设置
implement.method=实现方法
import=导入
import.from.deployment.configuration=从部署配置导入
import.references.on.paste.dialog.message=<html>粘贴的代码段使用 {0}，后者在目标作用域中不能通过导入访问。<br/>选择您想要导入到作用域中的{0}。</html>
import.references.on.paste.dialog.title=选择要导入的{0}
in=位置\:
in.0=\ ({0} 中)
include.eol.slow=包括 eol (慢)
include.path=Include 路径
include.path.column.info=路径
incorrect.null.safe.operator=错误的 nullsafe 运算符
info=信息
information=信息
init.cache=初始化缓存
initialize.var.quick.fix.family.name=使用值初始化
initializer=初始值设定项
inject.language.using.phpdoc=使用 PHPDoc 注入语言
inlay.hints.usages.text={0,choice, 0\#无用法|1\#1 个用法|2\#{0,number}'{1,choice, |1\#+}' 用法}
insert.default.branch=插入 'default' 分支
inspection.add.override.attribute=使用 \#[Override] 标记重写的方法
inspection.array.access.can.be.replaced.with.foreach.value=数组访问可被替换为 'foreach' 值
inspection.array.modification.will.not.have.any.effect=按值修改从函数返回的数组不会有任何影响
inspection.array.to.string.conversion=数组到字符串的转换
inspection.arrayall.can.be.converted.to.loop='array_all()' 调用可以转换为循环
inspection.arrayany.can.be.converted.to.loop='array_any()' 调用可以转换为循环
inspection.arrayfill.can.be.converted.to.loop='array_fill()' 调用可以转换为循环
inspection.arrayfilter.can.be.converted.to.loop='array_filter()' 调用可以转换为循环
inspection.arrayfind.can.be.converted.to.loop='array_find()' 调用可以转换为循环
inspection.arrayfindkey.can.be.converted.to.loop='array_find_key()' 调用可以转换为循环
inspection.arraymap.can.be.converted.to.loop='array_map()' 调用可以转换为循环
inspection.assignment.in.condition=条件中的赋值
inspection.assignment.in.condition.move.assignment.out.of.condition.fix.name=从条件中移出赋值
inspection.assignment.replaceable.with=<code>\#ref</code> 可被替换为 ''{0}'' \#loc
inspection.cannot.indirectly.modify.property.outside.of.scope=无法间接修改 ''set'' 可见性作用域之外的 ''{0}'' 属性
inspection.cannot.modify.property.outside.of.scope=无法修改 ''set'' 可见性作用域之外的 ''{0}'' 属性
inspection.cannot.modify.property.with.limited.set.visibility.from.global.scope=无法修改 'set' 可见性作用域之外的属性
inspection.cannot.unset.property.outside.of.scope=无法在 ''set'' 可见性作用域之外取消设置 ''{0}'' 属性
inspection.closure.can.be.converted.to.arrow.function=闭包可以转换为箭头函数
inspection.closure.can.be.converted.to.first.class.callable='Closure\:\:fromCallable()' 可以转换为一级可调用语法
inspection.code.patterns.panel.description.label=如果 fqn 名称匹配，则将代码标记为入口点
inspection.code.patterns.panel.description.text=将方法留空以表示构造函数 \n 任何 * 都将与 fqn 名称中的一个或多个字符匹配
inspection.code.patterns.panel.errors.class=模式必须是有效的 php fqn，仅接受 '*' 作为占位符
inspection.code.patterns.panel.errors.member=方法模式 {0} 必须是有效的 php 标识符，仅接受 ''*'' 作为占位符
inspection.codeSmell.class.call.is.not.casesensitive=类用法中的大小写与声明中的大小写不匹配
inspection.codeSmell.function.call.is.not.casesensitive=函数/方法调用中的大小写与声明中的大小写不匹配
inspection.codeSmell.namespace.reference.is.not.casesensitive=命名空间引用中的大小写与声明中的大小写不匹配
inspection.codeSmell.overriding.method.visibility.description=方法可见性不应被重写
inspection.composer.file.reference.problem=路径 ''{0}'' 未找到
inspection.composer.json.file.references.inspection.display.name=未解析的文件引用
inspection.constructor.style=旧式构造函数
inspection.convert.to.json.validate='json_decode()' 和 'json_last_error()' 可以转换为 'json_validate()'
inspection.curly.braces.access.syntax.usage=大括号访问语法自 PHP 7.4 已弃用
inspection.dead.code.problem.class.abstract.several.implementations={0} 具有{1, choice, 1\#直接或间接实现|2\# {1,number} 个直接或间接实现}，但<ul><li>其从未实例化或</li><li>不存在可从入口点到达的实例化。</li></ul>
inspection.dead.code.problem.class.nousages.synopsis=类从未使用。
inspection.dead.code.problem.empty.constant.synopsis=常量从未使用。
inspection.dead.code.problem.empty.function.synopsis=函数从未使用。
inspection.dead.code.problem.multiple.constant.synopsis=常量有 {0, choice, 1\#1 个用法|2\#{0,number} 个用法}，但无法从入口点到达。
inspection.dead.code.problem.recursive.suspicious.function.synopsis=所有函数用法均属于不存在可从入口点到达的成员的调用链。
inspection.dead.code.problem.single.constant.synopsis=常量有一个用法，但无法到达。
inspection.dead.code.problem.suspicious.function.synopsis=函数无法从入口点到达。
inspection.dead.code.problem.trait.additional.reachable=特征具有可到达用法。
inspection.dead.code.problem.trait.additional.unreachable=特征没有可到达用法。
inspection.dead.code.problem.trait.synopsis=特征从未使用。
inspection.deprecated.cast={0} 转换自 PHP {1} 已弃用
inspection.deprecated.implode.usage=带实参(数组，字符串)调用的 {0} 自 PHP 7.4 已弃用
inspection.disabled.quality.tool.inspection={0} 检查已禁用
inspection.disabled.quality.tool.inspection.fix=启用检查
inspection.disabled.quality.tool.inspection.open.fix=打开检查设置
inspection.division.by.zero=除以零
inspection.doc.field.type.mismatch={0, choice, 0\#属性|1\#类常量}类型不匹配
inspection.doc.missing.return.tag.problem=函数/方法 PHPDoc 注释中缺少 @return 标记
inspection.doc.throws.option.skip.on.empty.phpdoc=忽略没有 @param/@return 的 PHPDoc
inspection.doc.throws.problem=PHPDoc 注释不包含所有必需的 @throws 标记
inspection.duplicate.array.keys.display.name=重复的数组键
inspection.duplicate.array.keys.problem=重复的数组键
inspection.duplicate.array.keys.problem.0=值为 ''{0}'' 的重复数组键
inspection.duplicate.match.arm.body=''match'' arm 是 ''{0}'' arm 的重复项
inspection.duplicate.match.condition.message=重复条件
inspection.duplicate.phpdoc.type.fix=从标记中移除重复类型
inspection.duplicate.phpdoc.type.problem=重复的类型 ''{0}''
inspection.duplicate.switch.case.body=''switch'' 中的分支是 ''{0}'' 分支的重复项
inspection.dynamic.method.called.as.static.problem=非 static 方法 '\#ref' 不应被静态调用
inspection.dynamic.method.called.as.static.problem.magic=非 static 方法 '\#ref' 不应被静态调用，但类具有 '__magic' 方法。
inspection.export.results.back.traces=反向跟踪
inspection.export.results.const=常量
inspection.expression.have.same.operands=表达式有相同操作数
inspection.expression.result.unused.no.discard.attribute.problem=函数的返回值应被使用，或通过将其转换为 (void) 来有意忽略
inspection.expression.result.unused.problem=表达式结果未在任何位置使用
inspection.ext.is.specified.in.require.dev.but.used.outside.tests=''{0}'' 在 ''require-dev'' 部分中指定，但在测试外部使用
inspection.ext.is.specified.in.suggest=''{0}'' 在 ''suggest'' 中指定，可能不可用
inspection.family.name.replace.implicit.octal.literal.with.explicit.one=将隐式八进制字面量替换为显式八进制字面量
inspection.field.assignment.type.mismatch=类型不兼容\: 应为 ''{0}'' 类型的属性，提供的是 ''{1}''
inspection.field.assignment.type.mismatch.multi.resolve=赋值的类型 ''{0}'' 与属性的声明类型不兼容
inspection.field.can.be.promoted=可以提升属性
inspection.foreach.array.is.used.as.value.problem=变量 ''{0}'' 已被用作 ''array expression''
inspection.format.function.parameters.mismatch.conversion.specification=转换规范未映射到任何形参
inspection.format.function.parameters.mismatch.parameter=形参未映射到任何转换规范
inspection.fully.qualified.name.usage=限定符可被替换为导入
inspection.fully.qualified.name.usage.name.option.ignore.global.namespace=忽略全局命名空间
inspection.fully.qualified.name.usage.option.enable.file.scope=在文件作用域内启用
inspection.group=PHP
inspection.group.code.smell=代码异味
inspection.group.code.style=代码样式
inspection.group.control.flow=控制流
inspection.group.general=常规
inspection.group.naming.convention=命名约定
inspection.group.php.doc=PHPDoc
inspection.group.probably.bug=可能的 bug
inspection.group.type.compatibility=类型兼容性
inspection.group.undefined=未定义
inspection.group.unused=未使用
inspection.group.unused.quickfix.label=未使用的元素
inspection.group.unused.quickfix.message=未使用的元素\: ''{0}''
inspection.hierarchyChecks=类层次结构检查
inspection.hierarchyChecks.descr=类必须被声明为 abstract 或实现 {0}
inspection.hierarchyChecks.field.type.redeclaration.match.super.type=类型必须为 ''{0}''(如基类 ''{1}'' 中)
inspection.hierarchyChecks.field.type.redeclaration.must.not.be.defined=类型不得定义(如基类 ''{0}'' 中)
inspection.hierarchyChecks.should.implement=类必须实现 {0}
inspection.ignored.class.alias.declaration=忽略了类别名声明
inspection.illegal.array.key.type.problem=非法数组键类型
inspection.illegal.psr.class.path.class.is.not.matched.to.psr0={0}名称与包含文件名不匹配
inspection.illegal.psr.class.path.namespace.name.is.not.matched.to.psr0=命名空间名称与 PSR-0/PSR-4 项目结构不匹配
inspection.illegal.string.offset.problem=非法字符串偏移 {0}
inspection.incompatible.return.type=返回值应为 ''{0}''，返回的是 ''{1}''
inspection.incompatible.return.type.batch=返回值类型与声明不兼容
inspection.incompatible.return.type.strict.type.checking=严格类型检查
inspection.inconsistent.return.points.option.treat.return=在 'void' 函数/方法中以相同方式对待 'return null' 和 'return'
inspection.inconsistent.return.points.problem1=缺少 'return' 语句
inspection.inconsistent.return.points.problem1.yield=缺少 'yield' 语句
inspection.inconsistent.return.points.problem2=缺少返回实参
inspection.invalid.function.result.used.problem=使用了 ''{0}'' {1} ''{2}'' 结果
inspection.invalid.function.result.used.problem.function=函数
inspection.invalid.function.result.used.problem.method=方法
inspection.json.all.not.installed.packages=未安装软件包
inspection.json.duplicated.packages.0=require 和 require-dev 中存在重复的 ''{0}'' 条目
inspection.json.duplicated.packages.fix=从 require-dev 中移除重复项
inspection.json.not.installed.package.update.fix=更新软件包
inspection.json.not.installed.packages=未安装软件包
inspection.json.not.installed.packages.install.fix=安装软件包
inspection.json.not.installed.packages.update.fix=更新所有软件包
inspection.key.getter.setter.can.be.replaced.property.hooks=getter 和 setter 可被替换为 get 和 set 属性挂钩
inspection.language.level.quick.fix.switch.language.level.in.composer.0=切换到 composer.json 中的 PHP {0} 语言级别
inspection.language.level.quick.fix.switch.language.level.in.composer.manually.0=手动切换到 composer.json 中的 PHP {0} 语言级别
inspection.language.level.quick.fix.switch.language.level.name.0=切换到 PHP {0} 语言级别
inspection.loop.can.be.converted.to.arrayall=循环可以转换为 array_all()' 调用
inspection.loop.can.be.converted.to.arrayany=循环可以转换为 array_any()' 调用
inspection.loop.can.be.converted.to.arrayfill=循环可以转换为 'array_fill()' 调用
inspection.loop.can.be.converted.to.arrayfilter=循环可以转换为 'array_filter()' 调用
inspection.loop.can.be.converted.to.arrayfind=循环可以转换为 'array_find()' 调用
inspection.loop.can.be.converted.to.arrayfindkey=循环可以转换为 'array_find_key()' 调用
inspection.loop.can.be.converted.to.arraymap=循环可以转换为 'array_map()' 调用
inspection.magic.method.visibility.cannot.be.static=魔术方法 ''{0}'' 不能为 static
inspection.magic.method.visibility.must.be.public=魔术方法 ''{0}'' 必须为 public
inspection.magic.method.visibility.must.be.static=魔术方法 ''{0}'' 必须为 static
inspection.mess.detector.validation.inspection.display.name=PHP Mess Detector 验证
inspection.message.0.extends.class.with.final.tag=''{0}'' 会扩展带有 @final 标记的类
inspection.message.0.overrides.method.with.final.tag=''{0}'' 会重写带有 @final 标记的方法
inspection.message.absolute.method.reference.should.be.specified.for.insteadof.trait.use.rule=应为 'insteadof' 特征 use 规则指定绝对方法引用
inspection.message.always.true=条件始终为 ''{0,choice,0\#false|1\#true}'
inspection.message.always.true.because=条件始终为 ''{0, choice, 0\#false|1\#true}''，因为此时 ''{1}'' 已经为 ''{2, choice, 0\#false|1\#true}''
inspection.message.always.true.because.evaluated=条件始终为 ''{0,choice,0\#false|1\#true}''，因为此时对 ''{1}'' 求值
inspection.message.argument.with.type.deprecated.for.this.call=类型为 ''{0}'' 的实参对此调用已弃用
inspection.message.argument.without.name.identifier=无名称标识符的实参
inspection.message.array.always.empty.at.this.point=数组在此点始终为空
inspection.message.array.index.immediately.rewritten.before.accessing=数组索引在访问之前会被立即覆盖
inspection.message.array.key.unused=数组密钥未使用
inspection.message.array.push.with.single.element=只有一个元素的 'array_push'
inspection.message.array.to.string.conversion=数组到字符串的转换
inspection.message.array.traversable.can.be.replaced.with.iterable=类型提示 'array|Traversable' 可被替换为 'iterable'
inspection.message.array.values.call.redundant='array_values' 调用冗余
inspection.message.array.write.access.unused=未使用数组写入访问
inspection.message.arrayshape.can.be.added=ArrayShape 可以添加
inspection.message.assert.always.will.be.false=实参类型不兼容，因为 'assertTrue()' 执行与 'true' 的严格比较
inspection.message.assertion.always.true=断言始终为 ''{0,choice,0\#false|1\#true}'
inspection.message.assertion.always.true.because=断言始终为 ''{0, choice, 0\#false|1\#true}''，因为此时 ''{1}'' 已经为 ''{2, choice, 0\#false|1\#true}''
inspection.message.assertion.always.true.because.evaluated=断言始终为 ''{0,choice,0\#false|1\#true}''，因为此时 ''{1}'' 已求值
inspection.message.attribute.can.t.be.applied.to.because.it.doest.contains=特性不能应用于 {0}，因为它不包含 ''{1}'' 标志
inspection.message.attribute.is.not.repeatable=特性不可重复，因为它不包含 'Attribute\:\:IS_REPEATABLE' 标志
inspection.message.behavior.unparenthesized.expressions.containing.both.will.change.in.php=同时包含 ''.'' 和 ''{0}'' 的无括号表达式可能会产生意外结果
inspection.message.branch.is.unused=从不执行 'switch' 分支
inspection.message.call.chain.too.long.to.analyse.break.it.into.fragments.up.to.calls=调用链过长，无法进行分析。请将其拆分为最多包含 {0} 个调用的片段
inspection.message.call.with.negative.width.deprecated=带有负 'width' 实参的 'mb_strimwidth' 调用已弃用
inspection.message.call.with.two.arguments.deprecated=带两个实参的 ''{0}'' 调用已弃用
inspection.message.call.without.arguments.deprecated=不带实参的 ''{0}'' 调用已弃用
inspection.message.calling.static.trait.member=直接调用 static 特征成员已弃用。只应在使用特征的类上访问。
inspection.message.can.be.final=可以为 'final'
inspection.message.can.be.merged.with=可以与 ''{0}'' 合并
inspection.message.can.be.removed=可以移除 ''{0}''
inspection.message.can.be.replaced.with=可被替换为 ''{0}''
inspection.message.can.be.replaced.with.assert.false=可被替换为 'assertFalse'
inspection.message.can.be.replaced.with.assert.true=可被替换为 'assertTrue'
inspection.message.can.be.replaced.with.const.syntax=可被替换为 'const' 语法
inspection.message.can.be.replaced.with.direct.parameter.access='func_get_arg' 可被替换为直接形参访问
inspection.message.can.be.replaced.with.fail=可被替换为 ''{0}''
inspection.message.can.be.replaced.with.in.array.call=可被替换为 ''{0}'' 调用
inspection.message.can.be.replaced.with.match.expression='if' 语句可被替换为 'match' 表达式
inspection.message.can.be.replaced.with.min.max.call=可被替换为 ''{0}'' 调用
inspection.message.can.be.replaced.with.named.argument=可被替换为命名实参
inspection.message.can.be.replaced.with.operator=可被替换为 '?->' 运算符
inspection.message.can.be.replaced.with.str.function=可被替换为 ''{0}''
inspection.message.can.be.replaced.with.version=表达式可被替换为 '??' 版本
inspection.message.cannot.assign.empty.string.to.string.offset=无法将空字符串分配给字符串偏移
inspection.message.cannot.create.references.to.from.string.offsets=无法创建到/从字符串偏移的引用
inspection.message.cannot.increment.decrement.string.offsets=无法递增/递减字符串偏移
inspection.message.cannot.make.method=无法将 {0} 方法设为 {1} {2}
inspection.message.cannot.make.method.visibility.lower.than.super.s=无法将方法的可见性设为低于父级的可见性
inspection.message.cannot.make.non.abstract.method.abstract=无法将非 abstract 方法设为 abstract
inspection.message.cannot.make.non.abstract.method.abstract.1=无法将非 abstract 方法 {0} 设为 abstract
inspection.message.cannot.make.non.static.method.static=无法将非 static 方法 {0} 设为 static
inspection.message.cannot.make.static.method.non.static=无法将 static 方法 {0} 设为非 static
inspection.message.cannot.override.final.method=无法重写 final 方法
inspection.message.cannot.override.final.method.1=无法重写 final 方法 {0}
inspection.message.cannot.override.final.property=无法重写 final 属性
inspection.message.cannot.override.final.property.1=无法重写 final 属性 ''{0}\:\:${1}''
inspection.message.cannot.override.final.property.hook=无法重写 final 属性挂钩
inspection.message.cannot.override.final.property.hook.1=无法重写 final 属性挂钩 {0}
inspection.message.cannot.stub.or.mock.using.method.list.that.contains.duplicates=不能使用包含重复项的方法列表进行存根或模拟
inspection.message.cannot.unset.string.offsets=无法取消设置字符串偏移
inspection.message.cannot.use.assign.op.operators.with.string.offsets=无法将组合运算符赋值与字符串偏移一起使用
inspection.message.cannot.use.string.offset.as.array=无法将字符串偏移用作数组
inspection.message.cannot.use.string.offset.as.object=无法将字符串偏移用作对象
inspection.message.cast.evaluable=转换可被替换为 ''{0}''
inspection.message.cast.redundant=类型转换冗余
inspection.message.class.can.be.readonly=类可以为 'readonly'
inspection.message.class.does.not.have.attribute=类 ''{0}'' 未使用 ''Attribute'' 注解
inspection.message.class.may.inherit.from.final.class=类可能无法继承 final 类
inspection.message.class.ref.marked.as.internal=类 '\#ref' 已标记为 @internal
inspection.message.classes.cannot.be.doubled=''{0}'' 类无法重复
inspection.message.clone.method.cannot.be.static='Clone' 方法不能为 static
inspection.message.code.fragment.too.complex.to.parse.this.piece.code.will.be.treated.as.plain.text=代码段过于复杂，无法解析，因此将作为纯文本处理
inspection.message.comment.can.be.replaced.with.named.argument=注释可被替换为命名实参
inspection.message.comment.will.be.parsed.as.attribute.starting.with.php=从 PHP 8.0 起注释被解析为特性
inspection.message.concatenation.can.be.merged.with.assignment.empty.string.literal=串联可以与空字符串字面量赋值合并
inspection.message.condition.is.never.matched=条件从未匹配
inspection.message.constant.from.base.class.referenced.via.child.class=通过子类引用的基类 ''{0}'' 中的常量
inspection.message.constant.reassignment=常量重新赋值
inspection.message.constant.ref.marked.as.internal=常量 '\#ref' 已标记为 @internal
inspection.message.constant.ref.not.found=未找到常量 '\#ref'
inspection.message.constructor.cannot.be.static=构造函数不能为 static
inspection.message.continue.targeting.switch.equivalent.to.break=针对 'switch' 的 'continue' 相当于 'break'
inspection.message.control.flow.too.big.to.analyze=控制流太大，无法分析
inspection.message.count.used.as.array.index.to.append.element='count' 用作数组索引以追加元素
inspection.message.dangerous.array.initialization=危险的数组初始化
inspection.message.data.provider.method.should.be=数据提供程序方法应为 {0}
inspection.message.data.provider.method.should.not.require.arguments=数据提供程序方法不应需要实参
inspection.message.declaration.should.be.compatible.with=声明应该与 {0} 兼容
inspection.message.declaration.should.be.compatible.with.super=声明应与父级兼容
inspection.message.defining.custom.assert.function.deprecated=定义自定义 'assert()' 函数已弃用
inspection.message.defining.custom.assert.function.forbidden=禁止定义自定义 'assert()' 函数
inspection.message.deprecated.autoload.declaration='__autoload()' 声明已弃用
inspection.message.destructor.cannot.be.static=析构函数不能为 static
inspection.message.doc.tag.without.variable.name.doesn.t.provide.type.information.for.any.expression=没有变量名称的 Doc 标记不提供任何表达式的类型信息
inspection.message.double.quotes.are.unnecessary=双引号不必要
inspection.message.duplicate.case.expression=重复 case 表达式
inspection.message.duplicate.case.expression.ref=重复 case 表达式\: \#ref
inspection.message.duplicate.character=重复字符
inspection.message.duplicates.catch.statement=重复 ''{0}'' 语句
inspection.message.element.already.covered.by=''{0}'' 已被 ''{1}'' 覆盖
inspection.message.enum.field.reference.in.constant.expression.allowed.only.from.php=从 PHP 8.2 起才允许在常量表达式中引用枚举字段
inspection.message.exception.immediately.rethrown=立即重新抛出异常
inspection.message.exception.never.thrown.in.corresponding.try.block=相应的 ''try'' 块中从未抛出异常 ''{0}''
inspection.message.existing.overriding.private.method.may.be.inaccessible=现有的重写 private 方法可能无法访问
inspection.message.existing.overriding.private.method.may.be.inaccessible.method=重写 private 方法 ''{0}'' 可能无法访问
inspection.message.exitpoint.attribute.can.be.added=可以添加 \#[NoReturn] 特性
inspection.message.expression.always.choice=表达式始终为 ''{0}''
inspection.message.expression.have.duplicate.operand=表达式有重复的操作数 {0}
inspection.message.expression.not.changed.after.applying=应用 ''{0}'' 后，表达式不会改变
inspection.message.expression.without.parentheses=表达式没有括号
inspection.message.extends.class.with.final.tag=扩展带有 @final 标记的类
inspection.message.field.assignment.can.be.converted.to.promoted.field=可以提升属性
inspection.message.field.immediately.rewritten.before.accessing=属性在访问之前会被立即覆盖
inspection.message.field.ref.marked.as.internal=字段 '\#ref' 已标记为 @internal
inspection.message.for.loop.can.be.replaced.with.implode='foreach' 循环可被替换为 'implode()'
inspection.message.for.loop.can.be.replaced.with.str.repeat='for' 循环可被替换为 'str_repeat'
inspection.message.foreach.over.array.literal.with.single.element=对只有一个元素的数组字面量执行 'foreach'
inspection.message.from.php.this.allowed={0}。从 PHP {1} 起才允许这样。
inspection.message.function.deprecated.will.be.removed.in.phpunit=方法已弃用并已在 PHPUnit 10 中移除
inspection.message.function.deprecated.will.be.removed.in.phpunit.11=方法已弃用并已在 PHPUnit 11 中移除
inspection.message.function.may.produce.side.effects=函数可能会产生副作用
inspection.message.function.ref.marked.as.internal=函数 '\#ref' 已标记为 @internal
inspection.message.generators.may.only.declare.return.type.generator.iterator.or.traversable.or.iterable.permitted=生成器只能声明 ''Generator''、''Iterator''、''Traversable'' 或 ''iterable'' 的返回值类型，不允许 {0}
inspection.message.get.class.call.can.be.replaced.with.class.name.literal='get_class()' 调用可被替换为 '\:\:class'
inspection.message.getter.setter.can.be.replaced.property.hooks={0} 可被替换为 {1}
inspection.message.goto.labels.inside.loops.or.switch.statements.are.not.allowed=不允许在循环或 switch 语句中使用 'goto' 标签
inspection.message.if.can.be.replaced.with.version='if' 可被替换为 '??' 版本
inspection.message.if.statement.with.common.parts=包含通用部分的 ''{0}'' 语句
inspection.message.illegal.array.offset.access=尝试访问类型为 ''{0}'' 的值的数组偏移
inspection.message.immutable.property.write.scope.does.not.allow.write.access.here=无效的不可变属性写入\: 作用域 ''{0}'' 不允许在此处进行写入访问
inspection.message.instanceof.checks.in.catch.can.be.replaced.with.specific.catches='catch' 块中的 'instanceof' 检查可被替换为特定的 catch
inspection.message.interpolated.string.dereferencing.available.in.php.only=从 PHP 8.0 起才允许插值字符串解引用
inspection.message.key.element.cannot.be.reference=键元素不能为引用
inspection.message.leading.slash.in.constant.fqn.will.not.be.trimmed.by.php=PHP 不会修剪常量 FQN 中的前导斜杠
inspection.message.local.object.used.only.for.writing.properties=局部对象仅用于写入属性
inspection.message.loop.can.be.replaced.with.0=循环可被替换为 ''{0}()''
inspection.message.magic.constant.dereferencing.available.in.php.only=从 PHP 8.0 起才允许魔术常量解引用
inspection.message.match.can.be.replaced.with.switch='match' 表达式可转换为 'switch' 语句。
inspection.message.match.can.be.replaced.with.switch.changing.semantics='match' 表达式可以转换为 'switch' 语句。请注意，'switch' 语句依赖于松散比较，这可能会改变表达式语义。
inspection.message.match.can.be.replaced.with.ternary='match' 表达式可被替换为三元表达式
inspection.message.max.must.be.greater.than.or.equal.to.argument.min='max' 实参必须大于或等于 'min'
inspection.message.method.may.produce.side.effects=方法可能会产生副作用
inspection.message.method.ref.marked.as.internal=方法 '\#ref' 已标记为 @internal
inspection.message.method.reference.resolves.to.method.with.containing.class=''Use'' 规则解析为包含类 ''{0}'' 中的方法
inspection.message.methods.cannot.be.mocked=''{0}'' 方法无法模拟
inspection.message.multiple.isset.calls.can.be.combined.into.one=可将多个 'isset' 调用合并为一个
inspection.message.name.parameter.may.be.different.depending.on.instance.class=在 ''{0}.{1}'' 中可能未解析命名实参
inspection.message.named.argument.usage=命名实参用法
inspection.message.nested.call.can.be.unwrapped=嵌套的 ''{0}'' 调用可以解包
inspection.message.never.returning.function.must.not.return='never' 返回函数不得返回
inspection.message.non.readonly.class.cannot.extend.readonly.class=非 ''readonly'' 类不能扩展 ''readonly'' 类 ''{0}''
inspection.message.non.readonly.property.readonly=无法将非 'readonly' 属性重新声明为 'readonly'
inspection.message.not.valid.backing.value.for.enum={0} 不是枚举的有效支持值
inspection.message.only.first.byte.will.be.assigned.to.string.offset=只有第一个字节将被分配给字符串偏移
inspection.message.only.variables.can.be.passed.by.reference=仅可通过引用传递变量
inspection.message.operands.have.incompatible.types=操作数具有不兼容的类型
inspection.message.overrides.method.with.final.tag=重写带有 @final 标记的方法
inspection.message.parameter.name.changed.from.to=形参名称由 ''{0}'' 更改为 ''{1}''
inspection.message.parentheses.are.unnecessary=圆括号不必要
inspection.message.pointless.boolean.expression=可以简化布尔表达式
inspection.message.primitive.types.can.t.be.used.as.instanceof.argument=仅对象或字符串应用作 ''instanceof'' 实参，当前\: ''{0}''
inspection.message.prohibited.autoload.declaration=禁止使用 '__autoload()' 声明
inspection.message.promoted.field.usage=提升的属性用法
inspection.message.property.can.be.readonly=属性可以为 'readonly'
inspection.message.property.only.read.but.never.written=属性只读取，但从未写入
inspection.message.property.only.written.but.never.read=属性仅写入，但从未读取
inspection.message.psr.compound.namespace.with.depth.more.than.two.levels=PSR-12\: 复合命名空间的深度超过两级
inspection.message.psr.missing.parameter.list=PSR-12\: 缺少形参列表
inspection.message.psr.missing.visibility.definition=PSR-12\: 缺少可见性定义
inspection.message.psr.order.modifiers.incorrect=PSR-12\: 修饰符的顺序不正确
inspection.message.psr.short.form.type.keywords.should.be.used=PSR-12\: 应当使用类型关键字的缩写
inspection.message.psr.traits.must.be.included.one.per.line=PSR-12\: 必须以每行一个的形式添加特征
inspection.message.psr.usage.else.if.construct=PSR-12\: 使用 'else if' 结构
inspection.message.psr.usage.var=PSR-12\: 'var' 的用法
inspection.message.pure.can.be.added=可以添加 ''{0}''
inspection.message.qualified.name.can.t.contain.whitespaces=限定名称不能包含空格
inspection.message.readonly.class.cannot.extend.non.readonly.class=''readonly'' 类不能扩展非 ''readonly'' 类 ''{0}''
inspection.message.readonly.modifier.redundant='readonly' 修饰符冗余
inspection.message.readonly.property.non.readonly=无法将 'readonly' 属性重新声明为非 'readonly'
inspection.message.redundant.argument={0, choice, 0\#实参|1\#实参}{0,choice,0\#匹配|1\#匹配}{0, choice, 0\#形参的|1\#形参的}默认{0, choice, 0\#值|1\#值}
inspection.message.redundant.assignment=冗余的提升属性赋值
inspection.message.redundant.expression=冗余表达式
inspection.message.redundant.method.override=方法重写冗余
inspection.message.redundant.parenthesis=冗余圆括号
inspection.message.redundant.static.in.final.class=final 类中有冗余的 'static'
inspection.message.remove.final.tag=移除 '@final' 标记
inspection.message.remove.final.tag.from.0=从 ''{0}'' PHPDoc 注释中移除 ''@final'' 标记
inspection.message.replace.implicit.octal.literal.with.explicit.one=隐式八进制字面量可被替换为显式八进制字面量
inspection.message.results.postfix.expression.unused=未使用后缀表达式的结果
inspection.message.return.type.declaration.must.be.compatible.with=返回值类型声明必须与 {0} 兼容\: {1}
inspection.message.return.value.method.never.used=方法的返回值从未使用
inspection.message.returning.by.reference.from.void.function.deprecated=从 void 函数通过引用返回已弃用
inspection.message.second.write.to.readonly.property=无法修改 'readonly' 属性
inspection.message.set.access.level.must.be.omitted=需要 'set' 的属性不能是 'readonly'
inspection.message.should.be.one=值应为以下选项之一\: {0}
inspection.message.should.probably.not.be.assigned=''{0}'' 可能不应分配给 ''{1}''
inspection.message.should.probably.not.be.passed.as.parameter=''{0}'' 可能不应作为形参 ''{1}'' 传递
inspection.message.spread.operator.can.be.unwrapped=展开运算符可以解包
inspection.message.spread.operator.over.literal.unnecessary.for.arguments.resolved.to.variadic.parameter=对于解析为可变形参的实参，字面量上的展开运算符不必要
inspection.message.statement.can.be.collapsed.into.parameter.default.value=语句可以收起到形参的默认值中
inspection.message.switch.can.be.replaced.with.match='switch' 语句无法转换为 'match' 表达式
inspection.message.switch.has.only.default.case=switch 只有 'default' case
inspection.message.switch.has.only.single.case=switch 只有一个 case
inspection.message.too.many.messages.per.file.only.first.errors.warnings.are.shown=每个文件中的消息过多。仅显示前 {0} 条。
inspection.message.too.many.messages.per.line=每行的消息过多
inspection.message.tostring.method.must.return.string='__toString' 方法必须返回字符串
inspection.message.trait.usage=不允许特征用法
inspection.message.type.can.be.reduced.to=类型范围可以缩小为 ''{0}''
inspection.message.type.mismatch.should.be.conditional.expression=类型不匹配\: 应为条件表达式
inspection.message.uncovered.enum.cases='match' 表达式具有未被覆盖的 enum case
inspection.message.uncovered.enum.cases.switch='switch' 语句有未被覆盖的枚举 case
inspection.message.undefined.goto.label.ref=未定义的 goto 标签 '\#ref'
inspection.message.unnecessary.cast.to.string=不必要地转换为 ''{0}''
inspection.message.unnecessary.curly.braces=不必要的大括号
inspection.message.unnecessary.else=不必要的 'else'
inspection.message.unnecessary.leading.slash=不必要的前导 ''
inspection.message.unused.private.property.ref=未使用的 private 属性 '\#ref'
inspection.message.use.statement.with.non.compound.name.ref.has.no.effect=包含非复合名称 '\#ref' 的 'use' 语句没有任何作用
inspection.message.using.in.strings.deprecated.use.instead=在字符串中使用 {0} 已弃用，请改用 {1}
inspection.message.using.variable.variables.in.strings.deprecated.use.instead=在字符串中使用 {0} (可变变量)已弃用，请改用 {1}
inspection.message.value.parameter.always=形参值始终为 ''{0}''
inspection.message.value.ranges.mismatch.expected.actual=值范围不匹配。应为\: {0}，实际为\: {1}
inspection.message.var.export.with.return.argument.equals.false.always.returns.null=带等于 ''false'' 的 ''return'' 实参的 ''{0}'' 始终返回 ''{1}''
inspection.message.var.export.without.return.argument.always.returns.null=不带 ''return'' 实参的 ''{0}'' 始终返回 ''{1}''
inspection.message.variable.already.equal.to.assigned.value=变量已等于赋值
inspection.message.will.be.covered.by=非必要条件，因为它由 ''{0}'' 检查
inspection.message.with.single.string.argument=带单个字符串实参的 ''{0}''
inspection.message.write.access.to.readonly.property.outside.declaration.scope=无法写入声明作用域之外的 'readonly' 属性
inspection.message.write.access.to.readonly.property.outside.declaration.scope.ret.by.ref='readonly' 属性通过引用返回，可能会泄漏到声明作用域之外
inspection.message.write.access.to.variable.that.still.references.array.value=对仍引用 'foreach' 中先前所用数组值的变量的写入权限
inspection.method.does.not.override.super=方法未从其超类重写方法
inspection.method.may.be.static=方法可以为 'static'
inspection.method.parameters.count.mismatch=为方法调用提供了 {0} 个形参，但方法签名使用了 {1} 个形参
inspection.method.parameters.count.mismatch.option.ignore.func.get.arg=忽略带有 func_get_arg/func_get_args 调用的函数/方法
inspection.method.parameters.count.mismatch.option.ignore.underscore=忽略最后一个形参为 $_ 的函数/方法
inspection.method.to.string.is.not.implemented=没有为类 ''{0}'' 实现方法 ''__toString''
inspection.method.to.string.is.not.implemented.strict.mode=检查每种表达式类型是否存在 __toString
inspection.missing.break.statement.problem=缺少 'break' 语句
inspection.missing.class.constant.type=缺少类常量类型
inspection.missing.doc.comment.options.panel.class=类(&C)
inspection.missing.doc.comment.options.panel.class.constant=类常量(&A)
inspection.missing.doc.comment.options.panel.constant=常量(&O)
inspection.missing.doc.comment.options.panel.field=属性(&P)
inspection.missing.doc.comment.options.panel.function=函数(&F)
inspection.missing.doc.comment.options.panel.ignore.private.members=忽略 private 成员
inspection.missing.doc.comment.options.panel.method=方法(&M)
inspection.missing.doc.comment.problem=缺少 PHPDoc 注释
inspection.missing.doc.comment.problem.batch={0} 缺少 PHPDoc 注释
inspection.missing.ext.composer.json=composer.json 中缺少 ''{0}''
inspection.missing.ext.require.bundled=需要 PHP 捆绑的扩展
inspection.missing.field.type=缺少属性的类型声明
inspection.missing.parent.call.message=缺少父方法调用
inspection.missing.parent.constructor.call.message=缺少父构造函数调用
inspection.missing.strict.types.declaration=缺少严格类型声明
inspection.missing.strict.types.declaration.add.declaration=添加严格类型声明
inspection.missing_param=缺少所需形参 ''{0}''
inspection.mockery.protected.method.cannot.be.mocked=在不调用 'Mock.shouldAllowMockingProtectedMethods' 的情况下，无法对 'protected' 方法进行模拟
inspection.multiple.classes.declarations.in.one.file=在此文件中声明了另一个类
inspection.naming.convention.element.description.class=类
inspection.naming.convention.element.description.constant=常量
inspection.naming.convention.element.description.function=函数
inspection.naming.convention.element.description.method=方法
inspection.naming.convention.element.description.property=属性
inspection.naming.convention.element.description.variable=变量
inspection.naming.convention.element.descriptor.regexp={0} 名称 <code>\#ref</code> 不匹配正则表达式 ''{1}'' \#loc
inspection.naming.convention.problem.descriptor.long={0} 名称 <code>\#ref</code> 过长({1} > {2}) \#loc
inspection.naming.convention.problem.descriptor.short={0} 名称 <code>\#ref</code> 过短({1} < {2}) \#loc
inspection.nested.ternary.expression=嵌套三元表达式自 PHP 7.4 已弃用
inspection.nested.vs.outer.foreach.variables.conflict.problem1=变量 ''{0}'' 作为键用于内部和外部 ''foreach'' 循环
inspection.nested.vs.outer.foreach.variables.conflict.problem2=变量 ''{0}'' 作为值用于内部和外部 ''foreach'' 循环
inspection.never.function.result.used.problem.type=从未
inspection.non.strict.object.equality=非严格对象相等比较
inspection.nullsafe.deref.unnecessary.because=Nullsafe 运算符{0,choice,0\#将始终产生 ''null''|1\#不必要}，因为此时 ''{1}'' 已经为 ''{2,choice,0\#false|1\#true}''
inspection.nullsafe.deref.unnecessary.because.evaluated=Nullsafe 运算符 ''{0,choice,0\#将始终产生 ''null''|1\#不必要}''，因为此时对 ''{1}'' 求值
inspection.option.label.php.severity=PHP {0} 严重性\:
inspection.option.label.php73.severity=PHP 7.3 严重性\:
inspection.option.label.php8.severity=PHP 8 严重性\:
inspection.optional.before.required=可选形参在需要前提供
inspection.parentheses.around.new.call.can.be.omitted=可以省略 'new' 调用周围的圆括号
inspection.php.CS.fixer.validation.inspection.display.name=PHP CS Fixer 验证
inspection.php.CS.validation.inspection.display.name=PHP_CodeSniffer 验证
inspection.php.abstract.static.method.description=PHP 严格标准\: static 方法 '\#ref' 不应为 abstract
inspection.php.abstract.static.method.inspection.display.name=static 函数不应为 abstract
inspection.php.accessed.array.is.always.empty=数组在访问点始终为空
inspection.php.acessing.static.trait.members=正在访问 static 特征成员
inspection.php.add.line.break.after.trailing.comma=在尾随逗号后添加换行符
inspection.php.annotation.can.be.replaced.with.attribute={0} 注解可被替换为特性
inspection.php.annotation.must.be.replaced.with.attribute={0} 注解必须替换为特性
inspection.php.arg.trigger.error.is.deprecated=自 PHP 8.4 起，将 'E_USER_ERROR' 传递给 'trigger_error()' 已被弃用
inspection.php.argument.without.name.identifier=无名称标识符的实参
inspection.php.arithmetic.type.check=带有不支持操作数的算术运算
inspection.php.array.access.on.illegal.type.display.name=非法类型的数组偏移访问
inspection.php.array.append.using.count=使用 'count()' 作为索引将值追加到数组
inspection.php.array.fill.can.be.converted.to.loop.inspection.display.name='array_fill' 可以转换为循环
inspection.php.array.filter.can.be.converted.to.loop.inspection.display.name='array_filter()' 调用可以转换为循环
inspection.php.array.index.immediately.rewritten=数组索引会被立即重写
inspection.php.array.key.does.not.match.array.shape=数组键与数组形状不匹配 
inspection.php.array.map.can.be.converted.to.loop.inspection.display.name='array_map()' 调用可以转换为循环
inspection.php.array.push.with.single.element=只有一个元素的 'array_push()'
inspection.php.array.search.can.be.replaced.with.in.array='array_search()' 可被替换为 'in_array()' 调用
inspection.php.array.traversable.can.be.replaced.with.iterable=类型提示 'array|Traversable' 可被替换为 'iterable'
inspection.php.array.used.only.for.write.inspection.display.name=数组仅用于写访问
inspection.php.array.write.access.is.not.used=未使用数组写入访问
inspection.php.assert.declaration.is.deprecated=已弃用的 'assert()' 函数声明
inspection.php.assignment.in.condition.inspection.display.name=条件中的赋值
inspection.php.assignment.replaceable.with.operator.assignment.inspection.display.name=赋值可被替换为运算符赋值
inspection.php.assignment.replaceable.with.prefix.expression.inspection.display.name=赋值可被替换为增量或减量
inspection.php.attribute.array.shape.can.be.added=可以添加 '\#[ArrayShape]' 特性
inspection.php.attribute.can.be.overridden=可以将特性添加到重写成员
inspection.php.attribute.is.not.repeatable=不可重复的特性
inspection.php.attribute.no.return.can.be.added=可以添加 NoReturn 特性
inspection.php.autoload.declaration.is.deprecated=已弃用的 '__autoload()' 函数声明
inspection.php.autovivification.on.false.values='false' 到数组的自动转换已弃用
inspection.php.autovivification.on.false.values.possible=可能会导致将 'false' 转换为数组，这一转换已弃用
inspection.php.backed.property.with.set.hook.cant.be.accessed.by.ref.key=带有 'set' 挂钩的后备属性无法通过引用访问
inspection.php.boolean.expression.can.be.simplified=可以简化布尔表达式
inspection.php.cannot.apply.to.multiple.constants=无法同时将特性应用于多个常量
inspection.php.cannot.define.the.same.hooked.property={0} 和 {1} 在组合中定义相同的挂钩属性。目前不支持挂钩属性之间的冲突解决。
inspection.php.cast.is.evaluable=对标量值进行类型转换
inspection.php.cast.is.unnecessary=类型转换不必要
inspection.php.class.cant.be.used.as.attribute=类不能用作特性
inspection.php.class.constant.accessed.via.child.class=通过子类引用的类常量
inspection.php.class.constant.can.be.final=类常量可以为 'final'
inspection.php.class.implements.solely.traversable.inspection.display.name=类无法直接实现 Traversable
inspection.php.class.naming.convention.inspection.display.name=类名未遵循编码约定
inspection.php.class.static.member.accessed.via.instance.inspection.display.name=通过实例访问的类 static 成员
inspection.php.clone.can.be.replaced.with.clone.with='clone' 可以替换为 'clone with'
inspection.php.closure.can.be.converted.to.first.class.callable.inspection.display.name='Closure\:\:fromCallable()' 可以转换为一级可调用语法
inspection.php.closure.can.be.converted.to.short.arrow.function.inspection.display.name=闭包可以转换为箭头函数
inspection.php.comment.will.be.parsed.as.attribute=在 PHP 8.0 中注释被解析为特性
inspection.php.composer.duplicated.requirement.inspection.display.name=composer.json 中存在重复的软件包条目
inspection.php.composer.extension.stubs.inspection.display.name=composer.json 中缺少扩展
inspection.php.compound.namespace.depth.inspection.display.name=复合命名空间深度大于 2
inspection.php.concatenation.with.arithmetic.usage=具有算术用法的串联
inspection.php.concatenation.with.empty.string.can.be.merged=空字符串的串联可以与赋值合并
inspection.php.condition.always.evaluates.to.constant=条件的求值结果始终为 'true/false'
inspection.php.condition.can.be.replaced.with.min.max.call=条件可被替换为 'min()'/'max()' 调用
inspection.php.condition.checked.by.next.condition=逻辑表达式内部的条件由后续条件检查
inspection.php.constant.naming.convention.inspection.display.name=常量名称未遵循编码约定
inspection.php.constant.reassignment.inspection.display.name=常量重新赋值
inspection.php.constructor.style.inspection.display.name=旧式构造函数
inspection.php.continue.targeting.switch='continue' 针对 'switch' 语句
inspection.php.covered.element.in.class=类中的元素已被覆盖
inspection.php.curly.brace.access.syntax.usage.inspection.display.name=使用了大括号访问语法
inspection.php.declaration.must.be.compatible.with.parent=声明必须与父级兼容并通过引用返回
inspection.php.define.constant.can.be.replaced.with.const.syntax=define 常量名称可被替换为 'const' 语法
inspection.php.define.constant.name.with.leading.slash=使用前导斜杠定义的常量名称
inspection.php.delete.redundant.isset.calls=删除冗余的 'isset' 调用
inspection.php.deprecated.cast.inspection.display.name=弃用的转换
inspection.php.deprecated.dollar.brace.string.interpolation=已弃用的 '${' 字符串内插
inspection.php.deprecated.implode.usage.inspection.display.name=弃用的 'implode/join' 用法
inspection.php.deprecated.modifier=自 PHP {1} 起修饰符 ''{0}'' 已弃用
inspection.php.deprecated.partially.supported.callables.display.name=已弃用的部分支持可调用对象
inspection.php.deprecated.serializable.interface.usage.inspection.display.name=已弃用的 'Serializable' 接口用法
inspection.php.deprecated.stdlib.call=已弃用的标准库调用
inspection.php.deprecation.inspection.display.name=已弃用
inspection.php.disabled.extension.stubs.description=已禁用的 ''{0}'' 扩展存根
inspection.php.disabled.extension.stubs.inspection.display.name=已禁用的扩展存根
inspection.php.disabled.quality.tool.composer.inspection.display.name=质量工具检查已禁用
inspection.php.division.by.zero.inspection.display.name=除以零
inspection.php.doc.duplicate.type.inspection.display.name=类型已存在于 PHPDoc 标记中
inspection.php.doc.field.type.mismatch.inspection.display.name=类型与属性的声明类型不匹配
inspection.php.doc.is.not.complete.inspection.display.name=PHPDoc 注释签名不完整
inspection.php.doc.missing.throws.inspection.display.name=缺少 @throws 标记
inspection.php.doc.redundant.throws.inspection.display.name=冗余 @throws 标记
inspection.php.doc.signature.description=重复的实参 PHPDoc
inspection.php.doc.signature.description2=返回值类型与声明的不匹配
inspection.php.doc.signature.description3=不存在实参的 PHPDoc
inspection.php.doc.signature.description5=实参类型与声明的不匹配
inspection.php.doc.signature.inspection.display.name=PHPDoc 注释匹配函数/方法签名
inspection.php.doctrine.annotation.can.be.replaced.with.attribute=Doctrine 注解可被替换为特性
inspection.php.dql.builder.unknown.model=无法推断 DQL 模型类以启用补全
inspection.php.dql.builder.unknown.model.quickfix.family.name=添加带有模型类类型的 PHPDoc
inspection.php.dql.builder.unknown.model.quickfix.name=添加带有模型类类型的 PHPDoc
inspection.php.duplicate.case.inspection.display.name=switch 语句中存在重复的 case
inspection.php.duplicate.character.in.str.function.call=函数调用中的重复字符
inspection.php.duplicate.match.arm.body.inspection.display.name='match' 表达式中的重复 arm
inspection.php.duplicate.match.condition.inspection.display.name=重复条件
inspection.php.duplicate.operand.in.comparison=比较中的重复操作数
inspection.php.duplicate.switch.case.body.inspection.display.name=switch 语句中存在重复分支
inspection.php.duplicate.switch.catch.body.inspection.display.name='catch' 语句中的重复分支
inspection.php.dynamic.as.static.method.call.inspection.display.name=动态方法被调用为 static
inspection.php.dynamic.field.declaration=动态属性声明
inspection.php.element.is.not.available.in.current.php.version.inspection.display.name=元素在配置的 PHP 版本中不可用
inspection.php.empty.index.operator.not.supported.for.strings=字符串不支持 '[]' 运算符
inspection.php.empty.index.operator.not.supported.for.strings.display.name=字符串不支持的空索引运算符
inspection.php.enforce.doc.comment.inspection.display.name=强制执行 PHPDoc 注释
inspection.php.enum.case.with.value.not.found=枚举中找不到包含指定值的 case
inspection.php.exception.is.immediately.rethrown=立即重新抛出异常
inspection.php.expected.values.should.be.used=应使用预期值
inspection.php.expression.always.constant.inspection.display.name=到达时，变量始终为 true/false
inspection.php.expression.always.null.description='\#ref' 始终为 'null'
inspection.php.expression.always.null.inspection.display.name=表达式始终为 'null'
inspection.php.expression.result.unused.inspection.display.name=未使用表达式结果
inspection.php.expression.with.same.operands.inspection.display.name=逻辑表达式有相同操作数
inspection.php.expression.without.clarifying.parentheses.inspection.display.name=表达式不带澄清括号
inspection.php.field.assignment.type.mismatch.inspection.display.name=属性赋值中的类型不匹配
inspection.php.field.immediately.rewritten=属性会被立即重写
inspection.php.field.reference.does.not.match.object.shape=字段引用与对象形状不匹配
inspection.php.foreach.array.is.used.as.value.inspection.display.name=Foreach 数组用作值
inspection.php.foreach.nested.outer.key.value.variables.conflict.inspection.display.name=嵌套与外部 'foreach' 变量冲突
inspection.php.foreach.over.single.element=对只有一个元素的数组字面量执行 Foreach
inspection.php.foreach.variable.overwrite.already.defined.variable='foreach' 变量重写已定义的变量
inspection.php.format.function.call.with.single.argument=使用单个实参格式化函数调用
inspection.php.format.function.parameters.mismatch.inspection.display.name=格式函数形参不匹配
inspection.php.fully.qualified.name.usage.inspection.display.name=使用了完全限定名称
inspection.php.func.get.arg.can.be.replaced.with.parameter.access='func_get_arg()' 调用可被替换为形参访问
inspection.php.function.naming.convention.inspection.display.name=函数名称未遵循编码约定
inspection.php.get.class.can.be.replaced.with.class.name.literal.inspection.display.name='get_class()' 调用可被替换为 '\:\:class'
inspection.php.get.hook.of.backed.property.with.set.hook.may.not.return.by.reference=如果定义了 'set' 挂钩，无法通过 '\\&get' 返回后备属性
inspection.php.goto.into.loop.inspection.display.name=Goto 转入循环语句
inspection.php.group.attributes=特性
inspection.php.group.code.smell=代码异味
inspection.php.group.code.style=代码样式
inspection.php.group.composer=Composer
inspection.php.group.control.flow=控制流
inspection.php.group.error.handling=错误处理
inspection.php.group.general=常规
inspection.php.group.naming.conventions=命名约定
inspection.php.group.phpdoc=PHPDoc
inspection.php.group.phpunit=PHPUnit
inspection.php.group.probable.bugs=可能的 bug
inspection.php.group.psr.12=PSR-12
inspection.php.group.quality.tools=质量工具
inspection.php.group.regexp=正则表达式
inspection.php.group.replacable.assignments=可替换赋值
inspection.php.group.strict.standards=PHP 严格标准
inspection.php.group.type.compatibility=类型兼容性
inspection.php.group.undefined=未定义的符号
inspection.php.group.unused=未使用的符号
inspection.php.highlight.only.closures.with.multiple.statements.option=仅高亮显示包含多条语句的闭包
inspection.php.hooked.property.cant.be.unset=挂钩属性不能取消设置
inspection.php.idempotent.operation=二元表达式中的幂等运算
inspection.php.if.can.be.merged.with.sequential.condition='if' 可以与后续条件合并
inspection.php.if.can.be.replaced.with.match.expression='if' 可被替换为 'match' 表达式
inspection.php.ignored.class.alias.declaration.display.name=忽略的类别名声明
inspection.php.illegal.array.key.type.description={0} {1}
inspection.php.illegal.array.key.type.inspection.display.name=非法数组键类型
inspection.php.illegal.psr.class.path.inspection.display.name=类路径与项目结构不匹配
inspection.php.illegal.string.offset.inspection.display.name=非法字符串偏移
inspection.php.immutable.property.is.written.in.invalid.scope=在无效的作用域中写入不可变属性
inspection.php.implicit.octal.literal.can.be.replaced.with.explicit.one=隐式八进制字面量可被替换为显式八进制字面量
inspection.php.implicitly.marking.parameter.as.nullable.is.deprecated=将形参隐式标记为可为 null 已被弃用
inspection.php.in.array.can.be.replaced.with.comparison='in_array' 可被替换为比较
inspection.php.inapplicable.attribute.target.declaration=不适用的特性目标声明
inspection.php.inappropriate.inherit.doc.usage.class.description=@inheritDoc 用于没有带 doc 注释的父类的类
inspection.php.inappropriate.inherit.doc.usage.description=@inheritDoc 用于没有父级成员但含有 doc 注释的成员
inspection.php.inappropriate.inherit.doc.usage.description2=@inheritDoc 应仅用于类成员
inspection.php.inappropriate.inherit.doc.usage.inspection.display.name=使用了不当的 @inheritDoc
inspection.php.include.description=无法解析表达式 ''{0}'' 的目标
inspection.php.include.description2=未找到路径 ''{0}''
inspection.php.include.inspection.display.name=未解析的 include
inspection.php.incompatible.return.type.inspection.display.name=返回值类型不兼容
inspection.php.incomplete.array.shape.implementation=根据形状声明，数组不完整。缺少键\: {0}
inspection.php.inconsistent.return.points.inspection.display.name=不一致的返回点
inspection.php.incorrect.magic.method.signature.inspection.display.name=魔术方法签名不正确
inspection.php.indirect.modification.on.property.is.not.allowed=不允许间接修改属性
inspection.php.indirect.modification.on.property.potential=潜在禁止的间接属性修改
inspection.php.instanceof.checks.in.catch.can.be.replaced.with.specific.catches='catch' 块中的 'instanceof' 检查可被替换为特定的 catch
inspection.php.instanceof.is.always.true='instanceof' 的结果始终为 'true'
inspection.php.int.ranges.mismatch=数字范围不匹配
inspection.php.internal.array.index.reset.is.unnecessary=无需数组内部指针重置
inspection.php.internal.array.index.reset.is.unnecessary.navigate.to.function=导航到重置数组内部指针的函数
inspection.php.internal.entity.used.inspection.display.name=使用了内部实体
inspection.php.invalid.delimiter.key=无效分隔符
inspection.php.invalid.function.result.used.inspection.display.name=使用了无效的函数结果
inspection.php.invalid.instanceof.argument.type='instanceof' 的实参只应是对象或字符串
inspection.php.invalid.magic.method.modifiers.inspection.display.name=魔术方法修饰符无效
inspection.php.invalid.string.offset.usage=字符串偏移用法无效
inspection.php.isset.can.be.replaced.with.coalesce='isset' 可被替换为合并
inspection.php.isset.can.check.nested.access.directly='isset' 可以直接检查嵌套访问
inspection.php.isset.can.check.nested.array.access.subproperties.directly='isset' 可以直接检查嵌套数组访问和子属性
inspection.php.language.level.description='fn' 是 PHP 7.4 中的保留关键字
inspection.php.language.level.inspection.display.name=语言级别
inspection.php.laravel.pint.inspection.display.name=Laravel Pint 验证
inspection.php.long.type.form.inspection.display.name=类型关键字的缩写
inspection.php.loop.can.be.converted.to.array.fill.inspection.display.name=循环可以转换为 'array_fill()' 调用
inspection.php.loop.can.be.converted.to.array.filter.inspection.display.name=循环可以转换为 'array_filter()' 调用
inspection.php.loop.can.be.converted.to.array.map.inspection.display.name=循环可以转换为 'array_map()' 调用
inspection.php.loop.can.be.replaced.with.implode=循环可被替换为 'implode()'
inspection.php.loop.can.be.replaced.with.in.array=循环可被替换为 'in_array()' 或 'array_key_exists()' 调用
inspection.php.loop.can.be.replaced.with.str.repeat=循环可被替换为 'str_repeat'
inspection.php.loop.never.iterates=''{0}'' 语句不循环
inspection.php.loop.never.iterates.name=循环未迭代
inspection.php.match.can.be.replaced.with.switch.statement='match' 可被替换为 'switch' 语句
inspection.php.match.expression.can.be.replaced.with.ternary='match' 表达式可被替换为三元表达式
inspection.php.method.may.be.static.inspection.display.name=方法可以为 'static'
inspection.php.method.naming.convention.inspection.display.name=方法名称未遵循编码约定
inspection.php.method.or.class.call.is.not.case.sensitive.inspection.display.name=方法调用或类用法中的大小写不匹配
inspection.php.method.parameters.count.mismatch.inspection.display.name=形参数量与声明不匹配
inspection.php.method.return.value.is.never.used=方法的返回值从未使用
inspection.php.missing.break.statement.inspection.display.name=缺少 'break' 语句
inspection.php.missing.doc.comment.inspection.display.name=缺少 PHPDoc 注释
inspection.php.missing.field.type.inspection.display.name=缺少属性的类型声明
inspection.php.missing.param.type.description=缺少形参的类型声明
inspection.php.missing.parameter.type.inspection.display.name=缺少形参的类型声明
inspection.php.missing.parent.call.common.inspection.display.name=方法缺少父调用
inspection.php.missing.parent.call.magic.inspection.display.name=魔术方法缺少父调用
inspection.php.missing.parent.constructor.inspection.display.name=构造函数缺少父调用
inspection.php.missing.return.type.description=缺少函数的返回值类型声明
inspection.php.missing.return.type.inspection.display.name=缺少返回值类型声明
inspection.php.missing.strict.types.declaration.inspection.display.name=缺少严格类型声明
inspection.php.missing.visibility.inspection.display.name=缺少可见性
inspection.php.mixed.return.type.can.be.reduced=可以缩小 'mixed' 返回值类型的范围
inspection.php.mockery.invalid.mocking.target=无效的 Mockery 模拟目标
inspection.php.modifier.order.inspection.display.name=修饰符顺序
inspection.php.modulo.operation.with.one=以 '1' 为操作数的取模运算
inspection.php.move.variable.inside.closure=在闭包内移动变量赋值
inspection.php.multiple.class.declarations.inspection.display.name=多个类声明
inspection.php.multiple.classes.declarations.in.one.file.display.name=一个文件中有多个类声明
inspection.php.multiple.isset.calls.can.be.replaced.with.one=可将多个 'isset' 调用替换为一个
inspection.php.name.variable.is.used.only.inside.closure=变量仅在闭包内使用
inspection.php.named.argument.may.be.unresolved=命名实参可能未解析
inspection.php.named.argument.usage=有名称标识符的实参
inspection.php.named.arguments.with.changed.order=命名实参顺序与形参顺序不匹配
inspection.php.navigate.to.variable.assignment=导航到变量赋值
inspection.php.nested.dirname.call.can.be.replaced.with.levels.usage=嵌套的 'dirname()' 调用可被替换为 'levels' 形参用法
inspection.php.nested.min.max.call=嵌套的 'min/max' 调用
inspection.php.nested.ternary.expression.usage.inspection.display.name=使用了嵌套的三元运算符
inspection.php.never.typed.function.returning.value='never' 类型的函数返回一个值
inspection.php.new.class.missing.parameter.list.inspection.display.name=缺少形参列表
inspection.php.non.canonical.elements.order.description=变量及其类型以非规范顺序列出
inspection.php.non.canonical.elements.order.inspection.display.name=元素的非规范顺序
inspection.php.non.compound.use.inspection.display.name=不必要的语句使用
inspection.php.non.strict.object.equality.inspection.display.name=非严格对象相等
inspection.php.not.installed.packages.inspection.display.name=未安装的 Composer 软件包
inspection.php.null.is.not.compatible.with.parameter='null' 与形参的声明类型不兼容
inspection.php.null.safe.operator.can.be.used=可以使用 Nullsafe 运算符 '?->'
inspection.php.object.fields.are.only.written=局部对象仅用于写入属性
inspection.php.object.shape.can.be.added=ObjectShape 可以添加
inspection.php.open.echo.tag.inspection.display.name=打开 'echo' 标记用法
inspection.php.optional.before.required.parameters.inspection.display.name=可选形参在必选形参之前
inspection.php.overriding.method.extending.class.marked.as.final=被标记为 '@final' 的重写方法/扩展类
inspection.php.overriding.method.visibility.inspection.display.name=方法可见性不应被重写
inspection.php.parameter.always.have.same.value=形参值始终相同
inspection.php.parameter.by.ref.is.not.used.as.reference.inspection.display.name=不必要的通过引用传递
inspection.php.parameter.name.chaged.during.inhertiance=在继承期间更改了形参名称
inspection.php.params.inspection.display.name=形参类型
inspection.php.pass.by.ref.description=仅变量可通过引用返回
inspection.php.pass.by.ref.inspection.display.name=通过引用传递形参
inspection.php.passing.0.dba.key.split.is.deprecated=自 PHP 8.4 起，将 ''{0}'' 传递给 ''dba_key_split()'' 已被弃用
inspection.php.passing.0.type.1.is.deprecated=自 PHP 8.4 起，传递除 ''{1}'' 之外的其他类型的 ''{0}'' 已被弃用
inspection.php.passing.non.callable.string.is.deprecated=自 PHP 8.4 版起，将不可调用字符串传递给 'xml_set_*_handler()' 函数已被弃用
inspection.php.passing.non.empty.enclosure.to.csv.function.is.deprecated=自 PHP 8.4 起，为 '$escape' 形参传递非空字符串已被弃用
inspection.php.passing.null.or.false.dba.key.split.is.deprecated=自 PHP 8.4 起，将 'null' 或 'false' 传递给 'dba_key_split()' 已被弃用
inspection.php.passing.option.type.is.deprecated=自 PHP 8.4 起，传递错误类型的选项已被弃用
inspection.php.plural.mixed.can.be.replaced.with.array='mixed' 类型可被替换为 'array'
inspection.php.pointless.boolean.expression='if' 条件内的无意义布尔表达式
inspection.php.possible.polymorphic.invocation.inspection.display.name=可能的多态调用
inspection.php.pow.call.can.be.replace.with.pow.operator='pow()' 调用可被替换为 '**' 运算符
inspection.php.preg.match.can.be.replaced.with.comparison='preg_match()' 可被替换为比较
inspection.php.preg.match.redundant.closure=冗余闭包 '.*'
inspection.php.preg.match.without.regular.expression='preg_match' 可被替换为 'str_contains'
inspection.php.preg.replace.with.empty.replacement.name='preg_replace()' 可被替换为 '(l|r)trim' 调用
inspection.php.preg.split.can.be.replaced.with.explode='preg_split' 可被替换为 'explode'
inspection.php.private.field.can.be.local.variable.description=属性可被替换为局部变量
inspection.php.private.field.can.be.local.variable.inspection.display.name=private 属性可为局部
inspection.php.private.method.may.be.inaccessible.in.late.static.binding.call=在延迟 static 绑定调用期间可能无法访问 private 方法
inspection.php.promoted.field.usage=提升的属性用法
inspection.php.property.can.be.promoted.with.private.set.modifier=可以使用 'private(set)' 可见性修饰符提升属性
inspection.php.property.can.be.readonly=属性可以为 'readonly'
inspection.php.property.can.be.replaced.with.private.set.modifier=属性可以替换为 'private(set)' 可见性修饰符
inspection.php.property.naming.convention.inspection.display.name=属性名称未遵循编码约定
inspection.php.property.only.written=属性用法具有相同的访问权限
inspection.php.property.without.set.hook.can.be.replaced.with.private.set.visibility.modifier=没有 'set' 挂钩的属性可以替换为 'private(set)' 可见性修饰符
inspection.php.psalm=Psalm
inspection.php.pure.contract.attribute.can.be.added=可以添加 '\#[Pure]' 特性
inspection.php.pure.function.may.produce.side.effect=纯函数可能会产生副作用
inspection.php.raising.zero.to.the.power.of.negative.number.is.deprecated=自 PHP 8.4 起，0 的负数次幂已被弃用。
inspection.php.rand.arguments.in.revers.order=顺序错误的 'rand' 函数实参
inspection.php.ranges.in.class.can.re.merged=类中的范围可以合并
inspection.php.redeclaration.stdlib.function=标准库函数的重复声明
inspection.php.redeclaration.stdlib.function.description=不能重复声明标准库函数 ''{0}''
inspection.php.redundant.array.call.in.foreach.iterated.value=对 'foreach' 中迭代的值的冗余 'array_values' 调用
inspection.php.redundant.assignment.to.promoted.field=冗余的提升属性赋值
inspection.php.redundant.attribute.parenthesis=特性中的冗余圆括号
inspection.php.redundant.catch.clause.inspection.display.name=冗余 catch 子句
inspection.php.redundant.closing.tag.inspection.display.name=冗余结束标记
inspection.php.redundant.continue.break.argument=冗余的 'continue/break' 实参
inspection.php.redundant.doc.comment.inspection.display.name=冗余 PHPDoc 注释
inspection.php.redundant.match.expression='match' 表达式只有 default arm，应当进行简化
inspection.php.redundant.method.override=冗余方法重写
inspection.php.redundant.modifier=冗余的 ''{0}'' 修饰符
inspection.php.redundant.modifier.key=冗余修饰符
inspection.php.redundant.optional.argument=冗余的可选实参
inspection.php.redundant.type.in.union.type=类型声明冗余，可以简化
inspection.php.redundant.type.in.union.type.fix.name=简化冗余类型
inspection.php.redundant.type.in.union.type.template=类型声明可以简化为 ''{0}''
inspection.php.redundant.variable.doc.type.description=@var 标记指定了已从源代码推断出的类型
inspection.php.redundant.variable.doc.type.inspection.display.name=冗余 @var 标记
inspection.php.regexp.delimiter.is.alphanumeric.or.backslash=分隔符是字母数字或反斜杠
inspection.php.regexp.delimiter.is.used.in.reg.exp=在正则表达式中使用了分隔符
inspection.php.regexp.n.modifier.can.be.replaced.with.non.capturing.groups='n' 修饰符可被替换为非捕获组
inspection.php.regexp.replace.n.modifier.with.non.capturing.groups=将 'n' 修饰符替换为非捕获组
inspection.php.regexp.replace.with.valid.delimiter=替换为有效分隔符
inspection.php.remove.modifier=移除修饰符 ''{0}''
inspection.php.remove.useless.trailing.comma=移除无用的尾随逗号
inspection.php.replace.annotation.with.attribute=将注解替换为特性
inspection.php.return.doc.type.mismatch=PHPDoc 中的返回值类型与实际返回值类型不匹配
inspection.php.return.doc.type.mismatch.inspection.display.name=PHPDoc 注释中的返回值类型与实际返回值类型不匹配
inspection.php.second.write.to.readonly.property=第二次写入 'readonly' 属性
inspection.php.separate.else.if.inspection.display.name=Else if
inspection.php.short.echo.open.tag.description=短 echo 起始标记用法
inspection.php.short.open.echo.tag.inspection.display.name=短起始 'echo' 标记用法
inspection.php.short.open.tag.description=使用了短起始标记
inspection.php.short.open.tag.inspection.display.name=使用了短起始标记
inspection.php.signature.mismatch.during.inheritance.inspection.display.name=重写方法的声明应与父类兼容
inspection.php.silly.assignment.inspection.display.name=冗余赋值
inspection.php.single.statement.with.braces.inspection.display.name=单语句主体带大括号
inspection.php.statement.has.empty.body.description=语句具有空体
inspection.php.statement.has.empty.body.inspection.display.name=语句具有空体
inspection.php.statement.without.braces.inspection.display.name=控制语句主体无大括号
inspection.php.static.as.dynamic.method.call.inspection.display.name=static 方法被调用为动态
inspection.php.str.functions.inspection.display.name='str*()' 调用可被替换为 PHP 8 'str_*()' 调用
inspection.php.strict.comparison.of.operands.with.different.types=严格比较类型不兼容的操作数
inspection.php.strict.type.checking.inspection.display.name=严格类型检查规则违反
inspection.php.super.class.incompatible.with.interface.inspection.display.name=父类的方法声明与实现的接口不兼容
inspection.php.suspicious.name.combination.inspection.name=可疑名称组合
inspection.php.switch.can.be.replaced.with.match.expression='switch' 可被替换为 'match' 表达式
inspection.php.switch.case.without.default.branch.inspection.display.name=switch 语句没有 default 分支
inspection.php.symfony.annotation.can.be.replaced.with.attribute=Symfony 注解可被替换为特性
inspection.php.ternary.expression.can.be.replaced.with.condition.inspection.display.name=三元表达式可被替换为条件
inspection.php.ternary.expression.can.be.replaced.with.short.version=三元表达式可被替换为短版本
inspection.php.throwable.not.thrown.inspection.display.name=未抛出 Throwable
inspection.php.to.string.implementation.inspection.display.name=方法 '__toString' 实现
inspection.php.to.string.may.produce.exception='__toString' 可能会抛出异常
inspection.php.to.string.return.inspection.display.name=方法 '__toString' 返回值类型
inspection.php.too.long.member.reference.chain=成员引用链过长，无法分析
inspection.php.too.many.parameters.inspection.display.name=函数声明中的形参过多
inspection.php.traditional.syntax.array.literal.inspection.display.name=检测到传统语法数组字面量
inspection.php.trait.method.use.is.located.inside.different.target.class=特征 use 规则已解析为使用不同包含类的方法 
inspection.php.trait.usage=不允许特征用法
inspection.php.traits.use.list.inspection.display.name=每行一个特征 use
inspection.php.tried.to.read.from.virtual.property.without.getter=无法从未定义 getter 的 virtual 属性中读取
inspection.php.tried.to.write.to.virtual.property.without.setter=无法向未定义 setter 的 virtual 属性写入
inspection.php.type.tag.without.variable.name=不带变量名称的类型标记
inspection.php.typed.property.might.be.uninitialized.inspection.display.name=类型化属性可能未初始化
inspection.php.typed.property.might.be.uninitialized.inspection.problem=类型化属性 ''{0}'' 可能未初始化
inspection.php.uncovered.enum.cases=某些 enum case 未被覆盖
inspection.php.undefined.callback.inspection.display.name=未定义的回调
inspection.php.undefined.class.constant.inspection.display.name=未定义的类常量
inspection.php.undefined.class.description=类 '\#ref' 存在多个定义
inspection.php.undefined.class.description2=未定义的类 '\#ref'
inspection.php.undefined.class.description5=存在类 '\#ref' 的其他声明
inspection.php.undefined.class.inspection.display.name=未定义的类
inspection.php.undefined.class.other.declaration.exists={0} 处存在类 ''\#ref'' 的其他声明
inspection.php.undefined.class.other.declaration.exists.and={0} 和另 {1} 处存在类 ''\#ref'' 的其他声明
inspection.php.undefined.constant.inspection.display.name=未定义的常量
inspection.php.undefined.field.inspection.display.name=未定义的属性
inspection.php.undefined.function.inspection.display.name=未定义的函数
inspection.php.undefined.goto.label.inspection.display.name=未定义的 goto 标签
inspection.php.undefined.method.inspection.display.name=未定义的方法
inspection.php.undefined.namespace.description=未定义的命名空间 '\#ref'
inspection.php.undefined.namespace.inspection.display.name=未定义的命名空间
inspection.php.undefined.variable.inspection.display.name=未定义的变量
inspection.php.underscore.as.class.name.is.deprecated=自 PHP 8.4 起，使用单下划线 '_' 作为类名已被弃用
inspection.php.unhandled.exception.inspection.display.name=未处理的异常
inspection.php.unit.annotation.can.be.replaced.with.attribute=PHPUnit 注解在 PHPUnit 11 中已弃用，可被替换为特性
inspection.php.unit.assert.always.execute.to.same.result=实参类型不兼容的 'assertTrue()'
inspection.php.unit.assert.array.has.key.inspection.display.name=可以改用方法 'assertArrayHasKey/assertArrayNotHasKey'
inspection.php.unit.assert.can.be.replaced.with.assert.true.false=断言可被替换为 'assertTrue/assertFalse'
inspection.php.unit.assert.can.be.replaced.with.fail=断言可被替换为 'fail'
inspection.php.unit.assert.contains.inspection.display.name=弃用的 'assertContains/assertNotContains' 用法
inspection.php.unit.assert.count.inspection.display.name=使用了 'assertCount/assertSameSize' 方法而非 assertEquals
inspection.php.unit.assert.empty.inspection.display.name=断言可被替换为 'assertEmpty/assertNotEmpty'
inspection.php.unit.assert.equals.inspection.display.name=弃用的 'assertEquals/assertNotEquals' 用法
inspection.php.unit.assert.file.equals.inspection.display.name=弃用的 'assertFileEquals/assertStringEqualsFile' 用法
inspection.php.unit.covers.by.access.modifier.is.deprecated.inspection.display.name=弃用的通过修饰符注解进行的 @covers/@uses
inspection.php.unit.covers.function.without.scope.resolution.operator.inspection.display.name=提供的覆盖函数引用没有 '\:\:'
inspection.php.unit.deprecated.call.in.phpunit.10=方法在 PHPUnit 10 中已弃用
inspection.php.unit.deprecated.call.in.phpunit.11=方法在 PHPUnit 11 中已弃用
inspection.php.unit.deprecated.data.provider.signature.inspection.display.name=自 PHPUnit 10 以来，已弃用数据提供程序
inspection.php.unit.deprecated.expect.exception.inspection.display.name=使用了弃用的 expectException
inspection.php.unit.expected.exception.doc.tag.is.deprecated.inspection.display.name=弃用的通过文档标记进行的异常处理
inspection.php.unit.failed.line=测试中失败的行
inspection.php.unit.invalid.mocking.target=无效的 PHPUnit 模拟目标
inspection.php.unit.misordered.assert.equals.arguments.inspection.display.name=顺序错误的 PHPUnit 等式断言方法实参
inspection.php.unit.missing.target.for.test.inspection.display.name=PHPUnit 测试缺少目标元素
inspection.php.unit.undefined.data.provider.inspection.display.name=未定义的 PHPUnit 数据提供程序
inspection.php.unknown.modifier=未知修饰符 ''{0}''
inspection.php.unnecessary.continue='continue' 不必要，因为是循环中的最后一条语句
inspection.php.unnecessary.curly.variable.syntax=变量的不必要大括号语法
inspection.php.unnecessary.double.quotes.display.name=不必要的双引号
inspection.php.unnecessary.else.inspection.display.name=不必要的 'else' 分支
inspection.php.unnecessary.fully.qualified.name.inspection.display.name=不必要的完全限定名称
inspection.php.unnecessary.leading.backslash.in.use.statement='use' 语句中有不必要的前导 ''
inspection.php.unnecessary.local.variable.inspection.display.name=不必要的局部变量
inspection.php.unnecessary.parentheses.inspection.display.name=不必要的圆括号
inspection.php.unnecessary.return.function='return' 不必要，因为是函数中的最后一条语句
inspection.php.unnecessary.return.inspection.display.name=不必要的 'return/continue' 语句
inspection.php.unnecessary.return.method='return' 不必要，因为是方法中的最后一条语句
inspection.php.unnecessary.semicolon.description=不必要的 ;
inspection.php.unnecessary.semicolon.inspection.display.name=不必要的分号
inspection.php.unnecessary.spread.operator.for.function.call.argument=函数调用实参的不必要展开运算符
inspection.php.unpacked.argument.type.mismatch.inspection.display.name=无效类型的解包实参
inspection.php.unpacking.arrays.with.string.keys.inspection=对于 PHP 8.1 之前的版本，禁止使用字符串键解包数组
inspection.php.unsupported.modifier=自 PHP {1} 起不支持修饰符 ''{0}''
inspection.php.unsupported.modifier.key=不支持的修饰符
inspection.php.unused.alias.description=导入 '\#ref' 不必要
inspection.php.unused.alias.description2=导入 '\#ref' 从未使用
inspection.php.unused.alias.inspection.display.name=未使用的 import
inspection.php.unused.display.name=未使用的声明
inspection.php.unused.field.default.value.description=属性初始值设定项冗余
inspection.php.unused.field.default.value.inspection.display.name=冗余属性初始值设定项
inspection.php.unused.local.variable.inspection.display.name=未使用的局部变量
inspection.php.unused.match.arm.condition.inspection.display.name=未使用的 'match' 条件
inspection.php.unused.parameter.inspection.display.name=未使用的形参
inspection.php.unused.private.field.inspection.display.name=未使用的 private 属性
inspection.php.unused.private.method.inspection.display.name=未使用的 private 方法
inspection.php.unused.switch.case.inspection.display.name=未使用的 'switch' 分支
inspection.php.usage.of.silence.operator.inspection.display.name=使用了静默运算符
inspection.php.useless.trailing.comma.inspection.desc=无用的尾随逗号
inspection.php.useless.trailing.comma.inspection.display.name=无用的尾随逗号
inspection.php.var.export.used.without.return.argument=使用 'var_export' 或 'print_r' 调用时不带 'return' 实参
inspection.php.var.usage.inspection.display.name=使用了 var
inspection.php.variable.naming.convention.inspection.display.name=变量名称未遵循编码约定
inspection.php.variable.variable.inspection.display.name=使用了可变变量
inspection.php.void.function.result.used.inspection.display.name=使用了 void 函数结果
inspection.php.write.access.to.readonly.property.outside.declaration.scope=对声明作用域之外的 'readonly' 属性的写入权限
inspection.php.write.access.to.referenced.array.value.without.unset=对无 'unset' 的引用数组值的写入权限
inspection.php.wrong.catch.clauses.order.inspection.display.name=catch 子句顺序错误
inspection.php.wrong.foreach.argument.type.inspection.display.name=为 'foreach()' 提供的无效实参
inspection.php.wrong.string.concatenation.inspection.display.name=字符串串联错误
inspection.phpunit.asserts.array.has.key.can.be.used.instead=可以改用方法 ''{0}''
inspection.phpunit.asserts.assert.with.count.function=可以使用方法 {0} 代替 {1}
inspection.phpunit.asserts.assertEquals.misordered.arguments=顺序错误的 ''{0}()'' 实参
inspection.phpunit.asserts.assertEquals.parameters.empty=带有此类形参的调用已弃用
inspection.phpunit.asserts.assertEquals.parameters.many=可选的 {0} 个形参已弃用
inspection.phpunit.asserts.assertEquals.parameters.single=可选的 {0} 个形参已弃用
inspection.phpunit.covers.function.without.scope.resolution.operator=提供的覆盖{0}引用没有 ''\:\:''
inspection.phpunit.expectException=对将 expectException() 用于 {0} 的支持已弃用，将在 PHPUnit 10 中移除。请改用 {1}()。
inspection.phpunit.missing.target.element.ref=未找到 '\#ref' 的测试目标元素
inspection.phpunit.will.deprecation=对使用 {0}() 的支持已弃用，将在 PHPUnit 12 中移除。请改用 {1}()。
inspection.probably.undefined.property=属性 '\#ref' 已动态声明，可能未定义
inspection.property.declared.dynamically=动态声明的属性
inspection.property.declared.dynamically.deprecated=动态声明的属性，从 PHP 8.2 开始已弃用。
inspection.property.hook.can.be.can.be.shortened=属性挂钩可以缩短
inspection.redundant.closing.tag.fix.remove=移除结束标记
inspection.redundant.closing.tag.problem=冗余结束标记
inspection.redundant.intersection.type=冗余的交叉类型
inspection.redundant.intersection.type.fix=交叉类型可以简化为 ''{0}''
inspection.redundant.intersection.type.fix.name=简化交叉类型
inspection.redundant.phpdoc=冗余 PHPDoc 注释
inspection.redundant.phpdoc.tag=冗余的 PHPDoc 标记
inspection.set.visibility.can.be.removed=可以移除 'set' 可见性
inspection.severity.with.magic=当 __magic 存在时显示
inspection.silly.assignment.problem=赋值左右两侧相等
inspection.single.statement.with.braces=单语句主体带大括号
inspection.single.statement.with.braces.fix.name=从 ''{0}'' 语句中移除大括号
inspection.statement.has.empty.body.comments.count.as.content=注释计为内容
inspection.statement.has.empty.body.ignore.empty.for=忽略无主体的 'for' 循环
inspection.statement.has.empty.body.ignore.empty.while=忽略无主体的 'while' 循环
inspection.statement.without.braces=控制语句主体无大括号
inspection.statement.without.braces.fix.name=将大括号添加到 ''{0}'' 语句
inspection.static.member.accessed.via.instance.reference=通过实例引用访问 static 成员 ''{0}''
inspection.static.method.called.as.dynamic.problem=static 方法 '\#ref' 不应被动态调用
inspection.static.method.called.as.dynamic.problem.magic=static 方法 '\#ref' 不应被动态调用，但类具有 '__magic' 方法。
inspection.str.functions.strpos.call.can.be.converted.to.strcontains='strpos()' 调用可以转换为 'str_contains()'
inspection.str.functions.strpos.call.can.be.converted.to.strstartswith='strpos()' 调用可以转换为 'str_starts_with()'
inspection.str.functions.substr.call.can.be.converted.to.strendswith='substr()' 调用可以转换为 'str_ends_with()'
inspection.str.functions.substr.call.can.be.converted.to.strstartswith='substr()' 调用可以转换为 'str_starts_with()'
inspection.strict.type.checking.field.assignment=属性必须为 ''{0}'' 类型，提供的是 ''{1}''
inspection.strict.type.checking.field.assignment.multi.resolve=赋值的类型 ''{0}'' 与属性的声明类型不兼容
inspection.strict.type.checking.option=为所有文件启用
inspection.strict.type.checking.parameter=应为 ''{0}'' 类型的形参，提供的是 ''{1}''
inspection.strict.type.checking.parameter.batch=形参 '\#ref' 类型与声明不兼容
inspection.strict.type.checking.return=返回值必须为 ''{0}'' 类型，返回的是 ''{1}''
inspection.strict.type.checking.return.batch=返回值类型与声明不兼容
inspection.super.incompatible.with.interface.declaration.must.be.compatible=''{0}'' 的声明必须与 ''{1}'' 兼容
inspection.switch.with.single.case=只有一个 'case' 的 'switch'
inspection.switch.without.default.case='Switch' 没有默认分支
inspection.too.many.parameters=形参数量超出指定限值
inspection.too.many.parameters.ignore.constructors=忽略构造函数
inspection.too.many.parameters.max.number.of.parameters=最大形参数量
inspection.traditional.syntax.array.literal.detected=使用了传统语法数组字面量
inspection.undefined.callback.class=未定义的类 ''{0}''
inspection.undefined.callback.dont.report.ambiguity.checkbox=不明确时不报告
inspection.undefined.callback.dont.report.exist.checkbox=忽略来自 '*_exists' 和 'is_callable' 函数的回调
inspection.undefined.callback.field=在类 ''{1}'' 中未找到属性 ''{0}''
inspection.undefined.callback.function=未定义的函数 ''{0}''
inspection.undefined.callback.method=在类 ''{1}'' 中未找到方法 ''{0}''
inspection.undefined.class.ignore.phpdoc=忽略 PHPDoc
inspection.undefined.constant.problem1=未定义的常量 '\#ref'
inspection.undefined.constant.problem2=常量 '\#ref' 可能未定义
inspection.undefined.field.notify.access.magic.method=通过魔术方法访问属性的通知
inspection.undefined.field.notify.dynamic.declaration=动态属性声明的通知
inspection.undefined.field.notify.dynamic.read=通知对动态属性的读取权限
inspection.undefined.field.problem1=通过魔术方法访问的属性
inspection.undefined.function.problem1=未定义的函数 '\#ref'
inspection.undefined.function.problem2=函数 '\#ref' 可能未定义
inspection.undefined.member.downgrade=如果类中存在 __magic 方法则降级严重性(&D)
inspection.undefined.member.warnOnMixed=出现混合、对象、stdClass、未定义类型、null 的访问成员时通知
inspection.undefined.phpunit.provider=未定义的 PHPUnit 数据提供程序 ''{0}''
inspection.undefined.variable.option.description.enable.in.file.scope=在全局空间中启用检查
inspection.undefined.variable.option.description.ignore.include=在当前文件外搜索变量定义
inspection.undefined.variable.option.description.report.can.be.undefined=报告变量可能未定义
inspection.undefined.variable.problem1=未定义的变量 '\#ref'
inspection.undefined.variable.problem2=变量 '\#ref' 可能未定义
inspection.unnecessary.bool.cast=冗余转换为布尔值
inspection.unnecessary.fully.qualified.name.option.enable.file.scope=在文件作用域中启用
inspection.unnecessary.fully.qualified.name.option.ignore.global.namespace=忽略全局命名空间
inspection.unnecessary.qualifier.already.imported.message=限定符不必要，可以移除
inspection.unnecessary.static.reference=final 类中有冗余的 'static'
inspection.unnecessary.string.cast=冗余转换为字符串
inspection.unpacked.argument.type.mismatch=仅可解包数组和 Traversable，获得的是{0}
inspection.unreachable.statement=不可到达的语句
inspection.unreachable.statement.problem=不可到达的语句
inspection.unused.declaration.option.show.unused_from_entries=显示所有声明
inspection.unused.declaration.option.show_strictly_unused=仅显示未使用项
inspection.unused.declaration.option.test.entry_points=假定测试声明为入口点
inspection.unused.declaration.option.test.suppressGettersAndSetters=禁止 getter/setter
inspection.unused.description.code.suppressed.annotations=已禁止的注解
inspection.unused.local.variable.option.description.file.scope=在全局空间中启用检查
inspection.unused.local.variable.option.description.foreach=在 'list()' 中或存在 'foreach' 键时忽略 foreach 值
inspection.unused.local.variable.option.description.include=忽略 'include' 之前的变量
inspection.unused.local.variable.option.description.list=忽略 'list()' 中的变量
inspection.unused.local.variable.option.description.null=忽略 'null' 的赋值
inspection.unused.local.variable.option.indirect.access=忽略通过 'get_defined_vars()' 访问的变量
inspection.unused.local.variable.problem=未使用的局部变量 ''{0}''。{1}
inspection.unused.local.variable.problem.batch=局部变量 '\#ref' 未在任何位置使用
inspection.unused.local.variable.problem.case1=变量的值未在任何位置使用。
inspection.unused.local.variable.problem.case2=变量的值被立即覆盖。
inspection.unused.local.variable.problem.case3=变量中存储的引用未在任何位置使用。
inspection.unused.local.variable.problem.case4=变量中存储的引用被立即覆盖。
inspection.unused.local.variable.problem.fix.side.effects.found.dialog.message=分配给 ''{0}'' 的表达式可能含有副作用。\n您可以\:\n- 完全<b>移除</b>变量赋值\n- 将分配的表达式<b>转换</b>成单独的语句
inspection.unused.local.variable.problem.fix.side.effects.found.dialog.title=发现副作用
inspection.unused.parameter.option.description.empty.abstract=忽略抽象类方法的形参
inspection.unused.parameter.option.description.empty.anonymous=忽略匿名函数的形参
inspection.unused.parameter.option.description.empty.body=忽略带有空体的方法/函数的形参
inspection.unused.parameter.option.description.empty.override=忽略重写方法的形参
inspection.unused.parameter.option.description.parameter.count=不报告通过 'func_num_args()' 访问的形参
inspection.unused.parameter.option.description.property.hook.param.type=当属性挂钩形参等于属性类型时不报告
inspection.unused.parameter.problem=未使用的形参 ''{0}''。{1}
inspection.unused.parameter.problem.case1=形参值未在任何位置使用。
inspection.unused.parameter.problem.case2=形参值被立即覆盖。
inspection.unused.parameter.problem.case3=形参中存储的引用未在任何位置使用。
inspection.unused.parameter.problem.case4=形参中存储的引用被立即覆盖。
inspection.unused.parameter.problem.case5=形参类型等于属性类型。
inspection.unused.private.method.option.ignore.clone=忽略方法 '__clone' 用法
inspection.unused.private.method.option.ignore.constructor=忽略方法 '__construct' 用法
inspection.unused.private.method.problem.batch=未使用的 private 方法 '\#ref'
inspection.unused.symbol.check.anonymous_classes=匿名
inspection.unused.symbol.check.classes=类
inspection.unused.symbol.check.constants=常量
inspection.unused.symbol.check.fields=属性
inspection.unused.symbol.check.functions=函数
inspection.unused.symbol.check.magic_method=魔术方法
inspection.unused.symbol.check.methods=方法
inspection.unused.symbol.export.abstract=abstract
inspection.unused.symbol.export.call=调用
inspection.unused.symbol.export.calls=调用
inspection.unused.symbol.export.closure=结束
inspection.unused.symbol.export.entry=入口点
inspection.unused.symbol.export.label=标签
inspection.unused.symbol.export.reachable_element=可到达
inspection.unused.symbol.export.test_method=测试
inspection.unusedd.description.code.patterns.button.label=代码模式
inspection.usage.of.silence.operator.problem=使用了沉默运算符
inspection.variable.variable=使用了可变变量
inspection.visibility.modifier.can.be.removed=可以移除可见性修饰符
inspection.void.function.result.used.problem.type=void
inspection.void.never.function.result.used.problem.type=void/never
inspection.wrong.exception.order.fix.move.display.name=将 ''catch'' 子句移至 ''{0}'' 前
inspection.wrong.exception.order.fix.move.family.name=移动 'catch' 子句
inspection.wrong.exception.order.problem.batch=已捕获异常 '\#ref'
inspection.wrong.exception.order.problem.same=已捕获异常 ''{0}''
inspection.wrong.exception.order.problem.super=已捕获异常类 ''{1}'' 的超类 ''{0}''
inspection.wrong.exception.type.problem.catch=无法捕获非派生自 'Exception' 或 'Throwable' 基类的对象
inspection.wrong.exception.type.problem.throw=已抛出对象必须为 'Exception' 或 'Throwable' 的实例
inspection.wrong.foreach.argument.type.problem=提供给 ''foreach'' 的实参无效。预期类型\: ''array'' 或 ''object''，提供的是 ''{0}''。
inspection.wrong.foreach.argument.type.problem.batch=提供给 'foreach' 的无效实参
inspection.wrong.string.concatenation.operator.option.ignore.magic=忽略通过魔术方法访问的属性
inspection.wrong.string.concatenation.operator.problem=字符串串联运算符错误
inspection.wrong.string.concatenation.operator.problem.batch=字符串串联运算符错误
inspection.wrong_param_type=应为 ''{1}'' 类型的形参，提供的是 ''{0}''
install.composer.packages.task.title=安装 Composer 软件包
instanceof.is.always.true={0} 已位于 {1} 的层次结构中
intention.add.constructor.parameters=添加构造函数形参
intention.add.constructor.parameters.fields.chooser.dialog.title=选择要在构造函数中初始化的属性
intention.can.not.find.statement.to.surround=找不到要包围的目标语句。
intention.convert.to.short.syntax=将数组转换为短语法
intention.convert.to.short.syntax.list=将列表转换为短语法
intention.convert.to.traditional.syntax=将数组转换为传统语法
intention.convert.to.traditional.syntax.list=将列表转换为传统语法
intention.declare.missing.field=声明属性
intention.declare.missing.property=添加 @property
intention.family.inline.value.for.parameter=内联形参值
intention.family.name.add=添加 ''${0}''
intention.family.name.add.arrayshape.attribute=添加 '\#[ArrayShape]' 特性
intention.family.name.add.arrayshape.to.doc=将 ArrayShape 添加到 PHPDoc
intention.family.name.add.attribute=添加 ''\#[{0}]''
intention.family.name.add.attribute.attribute=使用 'Attribute' 注解
intention.family.name.add.attribute.to=将 ''\#[{0}]'' 添加到 ''{1}''
intention.family.name.add.attribute.to.overridden.method=将特性添加到重写方法
intention.family.name.add.attribute.to.overridden.method.of.abstract.method=将特性添加到抽象方法的重写方法
intention.family.name.add.attribute.to.overridden.parameter=将特性添加到重写形参
intention.family.name.add.break.as.last.statement=将 'break' 作为最后一条语句添加
intention.family.name.add.default.match.arm=添加 'default' 'match' arm
intention.family.name.add.doc.tag.with.throws.tags=使用 @throws 标记添加 PHPDoc 注释
intention.family.name.add.getter=添加 getter
intention.family.name.add.getter.setter=添加 getter 和 setter
intention.family.name.add.missing.array.key=添加缺失的数组键 ''{0}''
intention.family.name.add.missing.parameters=添加缺少的形参
intention.family.name.add.name.identifiers.to.all.arguments.starting.from.current=从当前位置开始将名称标识符添加到所有实参
intention.family.name.add.number.separators=添加数字分隔符
intention.family.name.add.readonly.modifier=添加 'readonly' 修饰符
intention.family.name.add.remaining.enum.cases=添加剩余 enum case
intention.family.name.add.should.allow.mocking.protected.methods.call=添加 'shouldAllowMockingProtectedMethods' 调用
intention.family.name.add.to.containing.enum=将 '' \: {0}'' 添加到包含枚举
intention.family.name.add.to.parameter=将 '\\&' 添加到形参
intention.family.name.add.trait.to.use.list=将特征添加到 use 列表
intention.family.name.add.true.argument.to.var.export.call=将 'true' 实参添加到 'var_export' 调用
intention.family.name.add.variable.name=添加变量名称
intention.family.name.append=追加 ''{0}''
intention.family.name.append.absolute.trait=追加 ''{0}\:\:''
intention.family.name.can.be.merged.with.sequential=''if'' 可以与后续 ''{0}'' 合并
intention.family.name.change.to.mixed=将类型更改为 'mixed'
intention.family.name.collapse.if.statement=收起 ''{0}'' 语句
intention.family.name.collapse.statement.into.parameter.default.value=将语句收起到形参的默认值中
intention.family.name.collapse.whitespaces=收起空格
intention.family.name.combine.multiple.isset.calls.into.one=将多个 'isset' 调用合并为一个
intention.family.name.convert.heredoc.nowdoc.to.string.literal=将 heredoc/nowdoc 转换为字符串字面量
intention.family.name.convert.heredoc.to.string.literal=将 heredoc 转换为字符串字面量
intention.family.name.convert.nowdoc.to.string.literal=将 nowdoc 转换为字符串字面量
intention.family.name.convert.string.literal.to.heredoc.nowdoc=将字符串字面量转换为 heredoc/nowdoc
intention.family.name.convert.to.promoted.field=转换为提升的属性
intention.family.name.convert.to.promoted.field.remove.doc.comment=转换为提升的属性并移除属性 PHPDoc 注释
intention.family.name.copy.phpdoc.from.parent=从父项复制 PHPDoc
intention.family.name.count.comments.as.content=将注释计为内容
intention.family.name.delete.covered.element=删除已覆盖的元素
intention.family.name.delete.field=删除属性
intention.family.name.delete.initializer=删除初始值设定项
intention.family.name.delete.readonly=删除 'readonly'
intention.family.name.evaluate.cast=替换为 ''{0}''
intention.family.name.extract.attribute.into.separate.list=将特性提取到单独的列表
intention.family.name.extract.common.parts=提取通用部分
intention.family.name.extract.common.parts.with.removing.branch=提取通用部分，并移除分支
intention.family.name.flip=翻转 '?\:'
intention.family.name.flip.attributes.lists=翻转特性列表
intention.family.name.force.fqcn.for.references.in.phpdoc=对 PHPDoc 中的引用强制 FQCN
intention.family.name.generate.phpdoc.comment=生成 PHPDoc 注释
intention.family.name.group.intersection.types=对交叉类型分组
intention.family.name.initialize.properties=初始化属性
intention.family.name.initialize.property.in.constructor=初始化构造函数中的属性
intention.family.name.insert.space.after=在 '\#' 后面插入一个空格
intention.family.name.insert.unset.before=在前面插入 ''unset(${0});''
intention.family.name.invert.if.statement=反转 'if' 语句
intention.family.name.make.class.readonly=将类设置为 'readonly'
intention.family.name.make.containing.class.enum=将包含类设为枚举
intention.family.name.make.data.provider.method.public.static=将数据提供程序方法设置为 'public' 和 'static'
intention.family.name.make.final=设为 'final'
intention.family.name.make.function.return.by.reference=使函数按引用返回
intention.family.name.make.method.void=将方法设为 'void'
intention.family.name.mark.missing.array.key.as.optional=将缺失的数组键 ''{0}'' 标记为可选
intention.family.name.merge.with.adjustment.range=与调整后的范围合并
intention.family.name.merge.with.assignment=与赋值合并
intention.family.name.merge.with.duplicated.catch.statement=与重复的 'catch' 语句合并
intention.family.name.merge.with.duplicated.match.arm=与重复的 'match' arm 合并
intention.family.name.merge.with.following.attribute.list=将特性列表与以下内容合并
intention.family.name.merge.with.sequential=与后续 ''{0}'' 合并
intention.family.name.move.attribute.to.start.element=将特性移至元素开头
intention.family.name.move.from.to.composer.json.section=将 ''{0}'' 从 ''{1}'' 移至 ''{2}'' composer.json 部分
intention.family.name.move.trait.use.rule.to.resolved.class.use.list=将特征 'use' 规则移至解析的类 'use' 列表
intention.family.name.navigate.to.cause=导航到原因
intention.family.name.navigate.to.duplicate.method.name=导航到重复的方法
intention.family.name.navigate.to.possibly.inaccessible.methods=导航到可能无法访问的方法
intention.family.name.navigate.to.rewrite.expression=导航到重写表达式
intention.family.name.remove=移除 {0}
intention.family.name.remove.argument.name=移除实参名称
intention.family.name.remove.attribute=移除 ''\#[{0}]''
intention.family.name.remove.backed.type.from.containing.enum=从包含枚举中移除后备类型
intention.family.name.remove.duplicate.operand=移除重复操作数
intention.family.name.remove.empty.index.operator=移除 '[]' 运算符
intention.family.name.remove.leading=移除前导 ''
intention.family.name.remove.parenthesis=移除圆括号
intention.family.name.remove.readonly.modifier=移除 'readonly' 修饰符
intention.family.name.remove.redundant.arguments=移除冗余{0, choice, 0\#实参|1\#实参}
intention.family.name.remove.unused.postfix.operation=移除未使用的后缀运算
intention.family.name.remove.unused.property=移除未使用的属性
intention.family.name.rename.parameter.to.match.super=重命名形参以匹配父级
intention.family.name.replace.array.traversable.with.iterable=将 'array|Traversable '替换为'iterable'
intention.family.name.replace.elseif.with.else=将 'elseif' 替换为 'else'
intention.family.name.replace.if.with.match.expression=将 'if' 替换为 'match' 表达式
intention.family.name.replace.if.with.version=将 'if' 替换为 '??' 版本
intention.family.name.replace.in.array.with.disjunction=将 'in_array()' 替换为 '||'
intention.family.name.replace.instanceof.checks.in.catch.with.specific.catches=将 'catch' 块中的 'instanceof' 检查替换为特定的 catch
intention.family.name.replace.match.with.switch.statement=将 'match' 替换为 'switch' 语句
intention.family.name.replace.match.with.switch.statement.changing.semantics=将 'match' 替换为 'switch' 语句(可能会改变比较语义)
intention.family.name.replace.match.with.ternary=替换为三元表达式
intention.family.name.replace.readonly.with.public=将 'readonly' 替换为 'public'
intention.family.name.replace.switch.with.if=将 'switch' 替换为 'if'
intention.family.name.replace.switch.with.match.expression=将 'switch' 替换为 'match' 表达式
intention.family.name.replace.ternary.expression.with.true.branch=将三元表达式替换为 ''{0}'' 分支
intention.family.name.replace.true.argument.with.false=将 'true' 实参替换为 'false'
intention.family.name.replace.with=替换为 ''{0}''
intention.family.name.replace.with.argument=替换为实参
intention.family.name.replace.with.array=替换为数组
intention.family.name.replace.with.array.assignment=替换为数组赋值
intention.family.name.replace.with.array.merge.expression=替换为 'array_merge' 表达式
intention.family.name.replace.with.check=替换为 '\!\=\=' 检查
intention.family.name.replace.with.class.constant=替换为类常量
intention.family.name.replace.with.class.name.literal=替换为 '\:\:class'
intention.family.name.replace.with.class.reference.with.base.class=替换为对基类的类引用
intention.family.name.replace.with.closure.fromCallable=替换为 'Closure\:\:fromCallable(...)'
intention.family.name.replace.with.comparison=替换为比较
intention.family.name.replace.with.compile.time.result=替换为编译时结果
intention.family.name.replace.with.concatenation=替换为串联
intention.family.name.replace.with.const.syntax=替换为 'const' 语法
intention.family.name.replace.with.define.call=替换为 'define()' 调用
intention.family.name.replace.with.dirname.call=替换为 'dirname()' 调用
intention.family.name.replace.with.dnf=替换为 DNF 类型声明
intention.family.name.replace.with.get.class.call=替换为 'get_class()' 调用
intention.family.name.replace.with.if=替换为 'if'
intention.family.name.replace.with.implicit.octal.notation=替换为隐式八进制表示法
intention.family.name.replace.with.implode.call=替换为 'implode()' 调用
intention.family.name.replace.with.in.array.call=替换为 'in_array()' 调用
intention.family.name.replace.with.interpolation=替换为 '{$' 插值
intention.family.name.replace.with.list=替换为 'list'
intention.family.name.replace.with.min.max.call=替换为 'min()'/'max()' 调用
intention.family.name.replace.with.named.argument=替换为命名实参
intention.family.name.replace.with.operator=替换为 '?->' 运算符
intention.family.name.replace.with.parameter.access=替换为形参访问
intention.family.name.replace.with.public=替换为 'public'
intention.family.name.replace.with.self.access=替换为 'self\:\:' 访问
intention.family.name.replace.with.spl.autoload.register.call=替换为 'spl_autoload_register()' 调用
intention.family.name.replace.with.str.function.call=替换为 ''{0}'' 调用
intention.family.name.replace.with.str.repeat.call=替换为 'str_repeat()' 调用
intention.family.name.replace.with.suggested.call.in.phpunit=替换为 PHPUnit 10 中建议的调用
intention.family.name.replace.with.suggested.call.in.phpunit.11=替换为 PHPUnit 11 中建议的调用
intention.family.name.replace.with.ternary.expression=替换为三元表达式
intention.family.name.replace.with.traditional.property.declaration=替换为传统属性声明
intention.family.name.replace.with.union.type=替换为联合体类型
intention.family.name.replace.with.version=替换为 '??' 版本
intention.family.name.replace.with.zero=替换为 ''{0}''
intention.family.name.show.example.date.time.output=显示示例日期时间输出
intention.family.name.simplify.expression=简化表达式
intention.family.name.simplify.ternary.expression=简化 '?\:'
intention.family.name.sort.arguments=对实参排序
intention.family.name.split.into.multiple.catch.statements=拆分为多个 'catch' 语句
intention.family.name.split.into.multiple.enum.cases=拆分为多个枚举 case
intention.family.name.split.into.separate.case.statements=拆分为独立的 'case' 语句
intention.family.name.split.into.two.separate.match.arms=将条件提取到单独的 'match' arm
intention.family.name.unwrap.call=解包调用
intention.family.name.unwrap.cast=解包转换
intention.family.name.unwrap.curly.braces=解包大括号
intention.family.name.unwrap.else=解包 'else'
intention.family.name.unwrap.foreach=解包 'foreach'
intention.family.name.unwrap.function.call=解包函数调用
intention.family.name.unwrap.intersection.type=解包交叉类型
intention.family.name.unwrap.spread.operator=解包展开运算符
intention.family.name.unwrap.type=解包类型
intention.flip.binary.expression.family.name=翻转二元表达式
intention.flip.binary.expression.text1=翻转 ''{0}''
intention.flip.binary.expression.text2=翻转 ''{0}'' (可能更改语义)
intention.flip.binary.expression.text3=翻转 ''{0}'' (更改语义)
intention.generate.phpdoc=生成 PHPDoc
intention.implement.interface=实现接口
intention.import.class=作为别名导入类
intention.import.class.alias.already.exists=已导入具有相同别名的类
intention.import.class.alias.name=别名\:
intention.inline.alias=内联别名
intention.inline.method.family.name=内联方法
intention.join.comma.separated.values=将逗号分隔的值合并为一行
intention.line.split=在两个字符串和串联中拆分字符串
intention.merge.condition.with.outer=与外部条件合并
intention.message.replace.in.array.with.disjunction=将 ''in_array()'' 替换为 ''{0}''
intention.name.add.as.function.s.return.type=将 ''{0}'' 作为函数返回值类型添加
intention.name.add.enum.case.with.value=添加具有 ''{0}'' 值的枚举 case
intention.name.add.method.stubs=添加方法存根
intention.name.add.name.identifier=添加名称标识符 ''{0}''
intention.name.add.to.parameter=将 ''\\&'' 添加到形参 ''{0}''
intention.name.add.trait.to.use.list=将特征 ''{0}'' 添加到 use 列表
intention.name.cast.to=将{0}转换为{1}
intention.name.change.cast.to=将 {0} 转换更改为 {1}
intention.name.change.method.to=将方法 ''{0}'' 更改为 {1}
intention.name.change.signature=更改 {0}({1}) 的签名
intention.name.convert.array.syntax.to.short=将数组转换为短语法
intention.name.convert.concatenation.to.scalar.value=将串联转换为标量值
intention.name.convert.concatenation.to.string.interpolation=将串联转换为字符串内插
intention.name.convert.sprintf.call.to.concatenation=将 'sprintf()' 调用转换为串联
intention.name.convert.sprintf.call.to.scalar.value=将 'sprintf()' 调用转换为标量值
intention.name.convert.sprintf.call.to.string.interpolation=将 'sprintf()' 调用转换为字符串内插
intention.name.convert.string.literal.to.heredoc=将字符串字面量转换为 heredoc
intention.name.convert.string.literal.to.nowdoc=将字符串字面量转换为 nowdoc
intention.name.evaluate.cast=对转换求值
intention.name.extract.if=提取 if ({0})
intention.name.flip=翻转 {0} 和 {1}
intention.name.inline.value=内联值 ''{0}''
intention.name.make.abstract=将{0}设为 abstract
intention.name.make.non.final=将 ''{0}'' 设为非 final
intention.name.merge.with=与 ''{0}'' 合并
intention.name.merge.with.match.arm=与 ''{0}'' arm 合并
intention.name.move.trait.use.rule.to.use.list=将特征 ''use'' 规则移至 ''{0}'' ''use'' 列表
intention.name.prepend.default.case=预置 'default'
intention.name.remove=移除 {0}
intention.name.remove.argument.names.from.all.arguments.up.to.current=从截止到当前位置的所有实参中移除实参名称
intention.name.remove.brackets=删除中括号
intention.name.remove.duplicated.type=移除重复类型
intention.name.rename.to=重命名为 ''{0}''
intention.name.replace.brackets.with.types=替换为 'array'
intention.name.replace.coalesce.expression.with=将合并表达式替换为 ''{0}''
intention.name.replace.coalesce.expression.with.operand=将合并表达式替换为操作数
intention.name.replace.null.as.part.union.type.with.nullable.notation=将 '|null' 作为联合体类型的一部分替换为 '?'
intention.name.replace.nullable.notation.with.null.as.part.union.type=用 '|null' 替换 '?' 作为联合体类型的一部分
intention.name.replace.with=将 ''{0}'' 替换为 ''{1}''
intention.name.replace.with.min.max.call=替换为 ''{0}'' 调用
intention.name.suppress.for.statement=对语句禁止
intention.name.wrap.left.operand.in.parentheses=使用圆括号包装左操作数
intention.name.wrap.right.operand.in.parentheses=使用圆括号包装右操作数
intention.namespace.bracing=将命名空间转换为带大括号
intention.php.add.object.shape.attribute=添加 '\#[ObjectShape]' 特性
intention.php.doc.add.object.shape=将 ObjectShape 添加到 PHPDoc
intention.php.replace.class.with.enum=将类替换为枚举
intention.php.replace.class.with.enum.error.message=由于构造函数调用，无法将类替换为枚举
intention.php.replace.class.with.enum.title=将类替换为枚举
intention.replace.class.with.alias=替换为别名
intention.replace.if.with.ternaryExpression=简化 'if'
intention.replace.quotes=无法替换引号 - 转义符号无效且\\r 不受支持
intention.replace.ternary.expression.with.if=将 '?\:' 替换为 if
intention.replace.with.method.call=替换为对现有方法的调用
intention.split.comma.separated.values=将逗号分隔的值拆分为多行
intention.statement.to.surround.failed.message=无法使用 ''{0}'' 包围语句。
intention.swap.call.arguments.family.name=交换调用实参
intention.swap.call.arguments.text1=交换 ''{0}'' 和 ''{1}''
intention.variable.add.phpdoc.comment.family.name=添加 PHPDoc 注释
interface=接口
interface.cannot.extend.previously.extended.interface=接口无法扩展先前扩展的接口
interface.method.can.t.have.body=接口方法不能有主体
interface.name=接口名称
interfaces.may.not.include.member.variables=接口可能不包括成员变量
interpreter=解释器
intersection.types.and.the.nullable.type.notation.cannot.be.mixed=交叉类型和可 null 类型表示法不能混用
introduce.named.constant.for.value.0=为值 ''{0}'' 引入命名常量
introduce.variable.fix=引入变量
invalid.class.name=无效类名
invalid.condition.to.body.separator.should.be.used=条件与主体之间的分隔符无效\: 应改用 '\=>'
invalid.octal.literal.won.t.be.reported.by.php.but.will.work.incorrectly=无效的八进制字面量\: 不会由 PHP 报告，但无法正常工作
invalid.syntax.for.multiple.case.expressions=多个 'case' 表达式的语法无效
is.duplicated.by.0=类型被 ''{0}'' 重复
iso.8601.date=ISO 8601 日期({0})
iso.8601.numeric.representation.of.the.day.of.the.week=ISO 8601 星期几的数字表示(1 到 7)
iso.8601.week.number.of.year.weeks.starting.on.monday=ISO 8601 一年中的第几周，周从星期一开始(42)
iso.8601.week.numbering.year=ISO 8601 周编号年份(2022)
isset.only.works.with.variables.and.arrays=isset 仅适用于变量和数组
it.s.not.possible.to.unpack.array.argument.by.reference=无法通过引用对数组实参解包
it.s.not.possible.to.unpack.array.key=无法解包数组键
it.s.not.possible.to.unpack.array.value.with.associated.key=无法使用关联键解包数组值
jump.into.a.finally.block.is.disallowed=不允许跳入 'finally' 块
key=键
label=标签
label.authentication.data.not.specified=未指定身份验证数据
label.can.be.configured.as.external.formatter=可配置为 {0}
label.class.fqn=类 FQN
label.configured.as.external.formatter=已配置为 {0}
label.constant.syntax=常量语法(&C)
label.docker.container=Docker 容器\:
label.failed=已失败
label.global.namespace=<全局命名空间>
label.highlight.target.parameter.attributes.applied.to.promoted.property=仅允许具有提升属性的 'TARGET_PARAMETER|TARGET_PROPERTY' 特性
label.initialize.in=初始化位置(&I)
label.insert.imports.on.paste=粘贴时插入 import\:
label.interpreter=解释器\: {0}
label.lt.no.server=<no server>
label.method.name=方法名称
label.name=名称\:
label.new.name=新名称\:
label.predecessors=前驱
label.server.document.root=$_SERVER['DOCUMENT_ROOT']
label.successors=后继
label.system.php=系统 PHP
label.visibility=可见性(&V)
label.visibility2=可见性\:
label.with.same.name.already.defined.in.current.scope=当前作用域中已定义具有相同名称的标签
label1=标签
lambda=Lambda
languages.frameworks.php.php.runtime=PHP / PHP 运行时
line.separator=行分隔符
link=链接
link.label.builtin.formatter=强制启用内置格式化程序
link.label.go.to.documentation=转到文档
link.label.inspection={0} 检查
link.label.languages.frameworks.php=PHP
list.is.not.allowed.as.class.reference=不允许将列表作为类引用
list.item.php.file=PHP 文件
list.item.update.phpdoc.comment=更新 PHPDoc 注释
list.of.causes.0=// 可能抛出异常的位置列表\:\n{0}
listing.licenses=正在列出许可证
literal.%=字面量 % (%)
live.template.class.member=类成员
live.template.interface.member=接口成员
live.template.name.comment=注释
live.template.name.empty.file=空 PHP 文件
live.template.name.expression=表达式
live.template.name.method.expression=类成员中的表达式
live.template.name.method.statement=类成员中的声明
live.template.name.statement=语句
live.template.name.string.literal=字符串字面量
live.template.trait.member=特征成员
local=本地
lowercase.ante.meridiem.and.post.meridiem.am.pm=小写上午和下午(am/pm)
machine.type.eg.i386=机器类型。例如，i386
make.0.1=将 ''{0}'' 设为{1}
make.01=设为 ''{0}''
make.call.dynamic.quick.fix.family.name=使调用为动态
make.non.nullable=设为不可为 null
member.has.0.access=成员具备 {0} 可见性
member.has.0.access.but.class.has.magic.method.1=成员具备 {0} 可见性，但可以通过 ''{1}'' 魔术方法访问
members.to.report=要报告的成员
merge.into.elseif=合并到 'elseif' 中
merge.nested.conditions=合并嵌套的条件
merge.with.0.branch=与 ''{0}'' 分支合并
meta.declaration.exists=''{1}'' 存在元声明 ''{0}''
meta.declaration.line.marker.name=存在元声明
meta.multiple.declaration.exists=''{0}'' 存在多个元声明
method=方法
method.0.can.t.be.overridden.with.same.trait.1=无法使用相同的特征 ''{1}'' 重写方法 ''{0}''
method.0.clone.cannot.accept.any.arguments=方法 ''{0}\:\:__clone()'' 不能接受任何实参
method.call=方法调用
method.is.undefined=方法 '\#ref' {0,choice,0\#未定义|1\#可能未定义}
method.is.undefined.in.class=方法 ''\#ref'' 在 {0} 中{1,choice,0\#未找到|1\#可能未定义}
method.name=方法名称
method.ref.is.deprecated=方法 '\#ref' 已弃用
method.ref.not.found=找不到方法 '\#ref'
method.should.either.have.body.or.be.abstract=方法应具有主体或为 abstract
method.should.not.be.finished.with=方法不应以 ';' 结束
method.template.parameter.shadows.class.template.parameter=方法模板形参 ''{0}'' 会隐藏类模板形参
method.with.same.name.already.defined.in.this.class=此类中已经定义了具有相同名称的方法
method1=方法
microseconds=微秒(654321)
microseconds.numeric=微秒，数字(007701、052738、428291)
microseconds.numeric.at.least.6.digits.with.leading.0=微秒，数字，至少 6 位数，带前导 0 (007701、052738、428291)
milliseconds=毫秒(654)
minutes.numeric=分钟，数字(1、3、59)
minutes.numeric.at.least.2.digits.with.leading.0=分钟，数字，至少 2 位数，带前导 0 (01、03、59)
minutes.with.leading.zeros=带前导零的分钟(00 到 59)
modifier=修饰符
months.numeric=月份，数字(1、3、12)
months.numeric.at.least.2.digits.with.leading.0=月份，数字，至少 2 位数，带前导 0 (01、03、12)
more.actions=更多操作…
move.class.to.separate.file.text.family=将类移至单独的文件
move.from.another.ide.or.code.editor=从另一个 IDE 或代码编辑器迁移
move.xdebug.file.to.the.extensions.directory.and.update.configuration.file=将 'xdebug.so' 文件移动到 PHP 扩展程序目录并更新配置文件
multiple.enum.identifiers.should.be.stated.in.different.cases=多个枚举标识符应在不同的 case 中声明
multiple.modifiers.are.not.allowed=不允许多个修饰符
multiple.namespaces.in.a.file.should.use.same.preferably.braced.syntax=文件中的多个命名空间应使用相同的(最好带大括号)语法
multiple.subsequent.underscores.in.a.numeric.literal.are.not.allowed=不允许在数字字面量中使用多个后续下划线
mute.until.restart=重启前静音
name=名称
named.parameter.overwrites.previous.argument=命名形参重写以前的实参
namespace=命名空间
namespace.cannot.start.with.namespace.due.to.conflict.with.ns.relative.names=由于与 ns 相关名称冲突，命名空间不能以 "namespace" 开头
namespace.declarations.cannot.be.nested=命名空间声明不能被嵌套
naming.rules=命名规则
navigate=… 导航
navigate.to.composer.json=导航到 composer.json
navigate.to.meta.declaration=导航到 ''{0}''
navigation.goto.super.method.is.not.available=索引更新期间无法在此处导航
negate.boolean.expression=布尔表达式求反
nested.type.groups.are.not.allowed=不允许嵌套类型组
never.can.only.be.used.as.return.type='never' 只能用作返回值类型
newUiOnboarding.php.connections.header=正在侦听 PHP 调试连接
newUiOnboarding.php.connections.link=使用 PhpStorm 进行调试\: 终极指南
newUiOnboarding.php.connections.step.text=点击以开始/停止侦听传入的 PHP 调试连接。有关详情，请参阅{0}
no.candidate.methods.to.implement=没有要实现的候选方法
no.candidate.methods.to.override=没有要重写的候选方法
no.content.allowed.before.namespace.declaration=命名空间声明之前不允许任何内容
no.elements.to.generate.phpdoc.for=没有任何可为其生成 PHPDoc 的元素
no.expression.found=找不到表达式
no.external.formatter=无外部格式化程序
no.fields.to.generate.property.hooks.for=没有要为其生成属性挂钩的字段
no.in.line.parameter.name.hints.will.be.shown.for.methods.matching.any.of.these.patterns=对于匹配其中任一模式的方法，都不会显示任何嵌入形参名称提示。
no.interpreter=<无解释器>
no.item=没有项
no.members.to.pull.up.found=未找到要向上拉取的成员
no.members.to.push.down.found=未找到要向下推送的成员
no.name=无名称
no.private.fields.to.generate.both.getters.and.setters.for=没有要为之同时生成 getter 和 setter 的 private 字段
no.private.fields.to.generate.getters.for=没有要为之生成 getter 的 private 字段
no.private.fields.to.generate.setters.for=没有要为之生成 setter 的 private 字段
no.response.from.0.after.1.ms={1} 毫秒后 {0} 未响应
no.type=NO_TYPE
node.is.interface=接口只能扩展一个接口
non.backed.enum.cannot.implement.interface.backedenum=非后备枚举无法实现接口 'BackedEnum'
non.enum.class.cannot.implement.interface=非枚举类无法实现接口 ''{0}''
notication.group.php.debugger=PHP 调试器
notification.content.composer.executable.was.automatically.set.to.global.composer=Composer 可执行文件已被自动设置为全局 'composer'
notification.content.configure.manually=手动配置
notification.content.disable.breakpoint.move.to.resolved.position=禁用断点移动到已解析的位置
notification.content.disable.paratest=禁用 ParaTest
notification.content.formatter.couldn.t.apply.result.external.tool=格式化程序无法应用外部工具的结果
notification.content.language.level.synchronisation.with.composer.was.disabled=已禁用与 composer.json 的语言级同步
notification.content.language.level.was.changed.to.based.on.project.usage=语言级别已根据项目中使用的功能设置为 {0}
notification.content.link.copied.to.clipboard=链接 {0} 已复制到剪贴板
notification.content.phpunit.xml.configuration.file.was.migrated=PHPUnit XML 配置文件已迁移
notification.content.process.exited.with.non.zero.code=进程以非零代码退出
notification.content.should.be.migrated=PHPUnit XML 配置使用了已弃用的架构。是否要使用 "--migrate-configuration" 迁移 XML 配置?
notification.content.tests.have.been.run.without.paratest=测试在没有 ParaTest 的情况下运行
notification.content.timeout.while.fetching.data.from=从 {0} 提取数据时超时
notification.content.usage.found.in.project=在项目中找到了 {0} 用法
notification.content.vendor.directory.not.found=未找到 'vendor' 目录
notification.content.xdebug.extension.not.installed=未安装 Xdebug 扩展程序
notification.group.composer.install=建议使用 Composer 'install' 命令
notification.group.composer.language.level=已禁用 Composer 语言级别同步
notification.group.dbgp.proxy=PHP 调试器代理
notification.group.debug.listener=PHP 调试侦听器
notification.group.default.stubs=PHP 默认存根路径不正确
notification.group.php=PHP
notification.group.php.3v4l=PHP 3v4l 集成
notification.group.php.birthday.discount=PHP 诞生 29 周年
notification.group.php.cgi=PHP-CGI 服务器
notification.group.php.code.style=建议进行 PHP 代码样式检查
notification.group.php.interpreters=PHP 解释器问题
notification.group.php.plugin.suggestion=PHP 插件建议
notification.group.php.profiler=PHP 分析器问题
notification.group.phpunit=PHPUnit
notification.group.quality.tools=PHP 外部质量工具
notification.paratest.mute=忽略
notification.title.cannot.read.snapshot=无法读取快照
notification.title.incorrect.profiler.snapshot.format=分析器快照格式不正确
notification.title.paratest.doesn.t.support.filter.option=ParaTest 不支持 --filter 选项
notification.title.phpunit=PHPUnit
null.cannot.be.marked.as.nullable='null' 不能被标记为可以为 null
number.of.days.in.the.given.month=给定月份中的天数(28 到 31)
numeric.representation.of.a.month.with.leading.zeros=月份的数字表示，带前导零(01 到 12)
numeric.representation.of.a.month.without.leading.zeros=月份的数字表示，不带前导零(1 到 12)
numeric.representation.of.the.day.of.the.week=星期几的数字表示(0 到 6)
object.property=对象属性
older=较旧…
only.final.and.visibility.modifiers.can.be.applied.to.promoted.property=只有 'final' 和可见性修饰符可以应用于提升的属性
only.intersection.type.can.be.used.for.grouping=只能使用交叉类型进行分组
only.intersection.type.can.be.used.for.grouping1=只能使用交叉类型进行分组
only.simple.expressions.are.allowed=只允许简单表达式
only.the.last.parameter.can.be.variadic=只有最后一个形参可以是可变形参
open.in.editor=在编辑器中打开
open.inspection.settings=打开 {0} 检查设置
open.tool.settings=打开 {0} 设置
opens.composer.json.to.change.php.property=打开 'composer.json' 以更改 'php' 属性
opens.inspection.0.setting=打开检查 ''{0}'' 设置
operating.system.name.eg.freebsd=操作系统名称。例如，FreeBSD
or.disable.inspection=或
output.phpinfo=输出 phpinfo()\:
output.phpinfo.title=输出 phpinfo() 
override=重写
overriding.implementing.methods=重写/实现方法
overriding.private.methods=重写 private 方法
parameter=形参
parameter.is.deprecated=形参 ''{0}'' 已弃用
parameter.ref.type.is.not.compatible.with.declaration=形参 '\#ref' 类型与声明不兼容
parameter.type.is.not.compatible.with.declaration=形参类型 ''{0}'' 与 ''{1}'' 不兼容
parameter.type.is.not.convertible.from.null=形参类型不可从 'null' 转换
parameter1=形参
paratest=ParaTest
paratest.is.not.supported.for.selected.run.profile=ParaTest 与所选运行配置文件不兼容
paratest.runner.description=使用 ParaTest 运行所选配置
pass.by.ref.is.not.effectively.used.inside.body=引用没有必要，因为实参既不通过引用赋值，也不通过引用进一步传递
path.0.is.invalid=路径 ''{0}'' 无效
path.to.php=<php 路径>
patterns.are.matched.on.fully.qualified.name.parameter.count.and.parameter.names=模式会通过完全限定名称、形参计数和形参名称进行匹配。
percentage.lines={0}% 行
phar.exclude.from.project.action.title=从项目中排除 phar
phar.failed.to.parse=无法解析
phar.include.into.project.action.title=将 phar 包含到项目中
php=PHP
php.5.6.is.not.supported=不支持下载 PHP 5.6 版本的 Xdebug 扩展程序
php.add.exception=将 ''{0}'' 添加到现有 @throws 标记
php.add.field.declaration.quick.fix.text=添加属性
php.add.method.declaration.quick.fix.text=添加方法
php.add.tag.base.quick.fix.family.name=添加 {0} 标记
php.annotator.abstract.property.hook.cannot.have.a.body=abstract 属性挂钩不能有主体
php.annotator.abstract.property.must.specify.at.least.one.hook=abstract 属性必须至少指定一个 abstract 挂钩
php.annotator.cannot.declare.hooks.for.static.property=无法为 static 属性声明挂钩
php.annotator.cannot.redeclare.property.hook.0=无法重新声明属性挂钩 {0}
php.annotator.cannot.specify.default.value.for.virtual.hooked.property=无法为 virtual 挂钩属性指定默认值
php.annotator.cannot.use.the.0.modifier.on.a.property.hook=无法在属性挂钩上使用 {0} 修饰符
php.annotator.clone.as.callable='clone' 仅在 PHP 8.5 或更高版本中才可用作 callable
php.annotator.clone.expects.two.args='clone' 最多需要 2 个实参
php.annotator.exchange.extends.implements.keyword=将 ''{0} {2}'' 更改为 ''{1} {2}''
php.annotator.exit.or.die.as.callables='exit' 和 'die' 仅在 PHP 8.4 或更高版本中才可用作可调用对象
php.annotator.expecting.class=应为类引用
php.annotator.expecting.interface=应为接口引用
php.annotator.get.hook.must.not.have.parameter.list='get' 挂钩不能有形参列表
php.annotator.hooked.properties.cannot.be.readonly=挂钩属性不能为 'readonly'
php.annotator.interfaces.may.only.include.hooked.properties=接口只能包含挂钩属性
php.annotator.must.not.call.0.in.different.property=无法在另一个属性(''{1}'')内调用 ''{0}'' 属性的挂钩
php.annotator.must.not.call.0.in.hook.1=无法从 ''{1}'' 属性挂钩调用 ''{0}'' 挂钩
php.annotator.non.abstract.property.hook.must.have.a.body=非 abstract 属性挂钩必须有一个主体
php.annotator.only.hooked.properties.may.be.declared.abstract=只有挂钩属性才可以声明为 abstract
php.annotator.parameter.of.set.hook.must.not.be.pass.by.ref='set' 挂钩形参不能通过引用传递
php.annotator.parameter.of.set.hook.must.not.be.variadic='set' 挂钩形参不能是可变的
php.annotator.parameter.of.set.hook.must.not.have.default.value='set' 挂钩形参不能具有默认值
php.annotator.pipe.expression.arrow.functions.must.be.parenthesized=竖线表达式中的箭头函数必须用圆括号括起
php.annotator.pipe.expression.callable.function.missing.parameters=可调用函数/方法缺少形参
php.annotator.pipe.expression.functions.cant.have.pass.by.ref.parameters=竖线表达式中不允许使用带有 pass-by-ref 形参的函数/方法
php.annotator.pipe.expression.functions.cant.require.more.than.one.parameter=竖线表达式中不允许使用具有多个必需形参的函数/方法
php.annotator.pipe.expression.incompatible.types=类型不兼容\: 实参类型应为 ''{0}''，实际为 ''{1}''
php.annotator.pipe.expression.not.valid.callable=''{0}'' 不是有效的可调用对象
php.annotator.pipe.expression.object.cant.be.used.as.callable=对象 ''{0}'' 不能用作可调用对象
php.annotator.pipe.expression.value.of.type.is.not.valid.callable=类型为 ''{0}'' 的值不是有效的可调用对象。
php.annotator.property.cannot.be.both.abstract.and.private=属性不能同时为 abstract 和 private
php.annotator.property.cannot.be.both.final.and.private=属性不能同时为 final 和 private
php.annotator.property.hook.cannot.be.both.abstract.and.final=属性挂钩不能同时为 abstract 和 final
php.annotator.property.hook.cannot.be.both.final.and.private=属性挂钩不能同时为 final 和 private
php.annotator.property.in.interface.cannot.be.explicitly.abstract=接口属性不能为显式 abstract。所有接口成员都是隐式 abstract
php.annotator.property.in.interface.cannot.be.final=接口中的属性不能为 final
php.annotator.property.with.asymmetric.visibility.must.have.type=具有不对称可见性的属性必须指定类型
php.annotator.read.only.virtual.property.must.not.specify.asymmetric.visibility=无法为只读 virtual 属性指定非对称可见性
php.annotator.return.type.make.nullable.fix=使返回值类型可为 null
php.annotator.return.type.non.nullable.null.returned=无法返回 'null'\: 返回值类型不可为 null
php.annotator.set.access.level.must.be.omitted=''{0}\:\:${1}'' 的 ''set'' 访问级别必须省略(与类 ''{2}'' 中一样)
php.annotator.set.hook.must.accept.exactly.one.parameter='set' 挂钩必须只接受一个形参
php.annotator.set.hook.type.parameter.must.compatible.property.type=形参类型必须与属性类型兼容
php.annotator.static.property.may.not.have.asymmetric.visibility=static 属性不能具有不对称可见性
php.annotator.strict.types.block.mode='strict_types' 声明不能使用块模式
php.annotator.strict.types.first.statement='strict_types' 声明必须是脚本中的第一条语句
php.annotator.typed.class.constant.callable.is.illegal=类常量不能具有 'callable' 类型
php.annotator.typed.parameter.type.mismatch.fix.change=将形参类型更改为 ''{0}''
php.annotator.typed.parameter.type.mismatch.fix.family=更改形参类型以匹配默认值的类型
php.annotator.typed.parameter.type.mismatch.fix.nullable=使形参类型可为 null
php.annotator.typed.property.callable.is.illegal={0, choice, 0\#属性|1\#类常量}不能具有类型 'callable'
php.annotator.typed.property.illegal.value=类型 ''{1}'' 的{0, choice, 0\#属性|1\#类常量}可能没有默认值
php.annotator.typed.property.type.mismatch=默认值只能是 ''{0}'' 类型
php.annotator.typed.property.type.mismatch.fix.change=将{0, choice, 0\#属性|1\#类常量}类型更改为 ''{1}''
php.annotator.typed.property.type.mismatch.fix.family=更改{0, choice, 0\#属性|1\#类常量}类型以匹配默认值的类型
php.annotator.typed.property.type.mismatch.fix.nullable=使{0, choice, 0\#属性|1\#类常量}类型可为 null
php.annotator.visibility.of.property.must.not.be.weaker.than.set.visibility=属性可见性不能比 'set' 可见性弱
php.annotator.void.function.must.not.return.value=void 函数不得返回值
php.annotator.with.properties.type=实参 '$withProperties' 必须是 'array' 类型
php.annotator.write.only.virtual.property.must.not.specify.asymmetric.visibility=无法为只写 virtual 属性指定不对称可见性
php.append.doc.static.fix.family.name=在函数引用前追加 '\:\:'
php.birthday.button.buy=购买 PhpStorm
php.birthday.button.save=立即保存
php.birthday.notification.1.content=为了庆祝 PHP 29 周年，新用户可以享受特殊优惠。有效期至 2024 年 6 月 8 日。
php.birthday.notification.1.title=PhpStorm 可享受 29% 优惠
php.birthday.notification.2.content=PHP 29 周年庆，PhpStorm 优惠同步进行\! 有效期至 2024 年 6 月 8 日。
php.birthday.notification.2.title=购买 PhpStorm 可节省 29%
php.cgi.not.found=请确保<a href\="">配置的 PHP 解释器</a>作为 CGI 程序构建(指定了 --enable-fastcgi)
php.cgi.not.found.title=找不到 {0}
php.change.cast.operation.quick.fix.family.name=将转换更改为{0}
php.change.function.signature.from.usage.quick.fix.family.name=从用法改变函数签名
php.change.function.signature.manually.quick.fix.family.name=手动更改签名
php.change.method.modifiers.quick.fix.family.name=更改修饰符
php.change.method.modifiers.quick.fix.text=移除修饰符
php.change.signature.conflict.with.local.var=形参 ''{0}'' 与函数 ''{1}'' 内的局部变量冲突
php.change.signature.conflict.with.local.var.method=形参 ''{0}'' 与来自 ''{2}'' 的方法 ''{1}'' 内的局部变量冲突
php.check.validity.reg.exp=在专用对话框中检查正则表达式的有效性
php.class=类
php.codestyle.per.2.title=PER-CS 2.0.0
php.commit.checkin.configure.external.formatter=配置
php.commit.checkin.could.not.run.external.formatter=无法运行外部格式化程序
php.commit.checkin.progress.text.reformatting.code.with.external.formatter=正在使用外部格式化程序重新设置代码格式…
php.commit.checkin.run.external.formatter=运行外部格式化程序
php.configure.extensions.quick.fix.family.name=配置扩展存根
php.console=PHP 控制台
php.control.flow.viewer=PHP 控制流查看器
php.control.flow.viewer.0=PHP 控制流查看器\: {0}
php.create.data.provider.quick.fix.family.name=创建数据提供程序
php.dead.code.entries=PHP 死码条目
php.debug.action.include.return.value.breakpoint.step.description=启用额外的“从函数返回”调试步骤
php.debug.action.watches.method.return.value.enable=启用函数返回值调试
php.debug.action.watches.method.return.value.unavailable.reason=从 Xdebug 3.2 起才支持返回值调试
php.debug.state.widget=停止/启动调试侦听
php.debug.validate.got.it=调试验证
php.debug.validate.got.it.descr=您可以使用调试验证对话框验证设置
php.delete.catch.clause.quick.fix=删除 'catch' 子句
php.delete.exception.quick.fix=删除异常
php.element.is.available.starting.with.php.version=''{0}'' 从 PHP 版本 {1} 开始可用
php.element.was.removed.in.php.version=''{0}'' 已在 PHP {1} 版本中被移除
php.embedded.stubs.incorrect.path.warning.message=配置的默认存根路径 ''{0}'' 不存在，改为使用嵌入式存根。
php.embedded.stubs.incorrect.path.warning.title=默认存根路径不正确
php.embedded.stubs.notification.provider.clone=在 GitHub 上克隆
php.embedded.stubs.notification.provider.do.not.show.again=不再显示
php.embedded.stubs.notification.provider.notification=您正在查看不可变的嵌入式存根。为了能够编辑这些存根，您需要克隆一个存根项目，然后通过“PHP / PHP 运行时 / 高级设置”提供默认存根路径。
php.embedded.stubs.notification.provider.provide=提供默认存根路径
php.empty.project.generator.description=为 PHP 创建空项目
php.empty.project.generator.name=PHP 空项目
php.enable.extension.quick.fix.family.name=启用扩展存根
php.enable.extension.quick.fix.text=启用 ''{0}'' 扩展存根
php.enum=枚举
php.exception.is.never.thrown=函数中从未抛出异常 ''{0}''
php.executable.macro.description=项目设置中配置的 Php 可执行文件
php.external.formatter=PHP 外部格式化程序
php.external.formatter.title=外部格式化程序
php.extract.class=PHP 提取类
php.find.clause.throws=可能抛出\: {0}
php.flip.arguments.quick.fix.family.name=翻转第一和第二个实参
php.flip.variable.and.type.quick.fix.family.name=翻转变量和类型
php.framework.enable.plugin=启用插件
php.framework.install.plugin=安装插件
php.framework.laravel.plugin=Laravel Idea
php.framework.settings.page=设置
php.framework.symfony.plugin=Symfony
php.generation.code.style.title=代码生成
php.include.path.action.add.text=添加 Include 路径
php.include.path.action.exclude.description=在此路径下添加排除项以防止被编入索引
php.include.path.action.exclude.text=排除此路径下的内容
php.include.path.excluded.file.description=从项目分析中排除
php.include.path.library.file.description=包含在项目分析中
php.info.parse.exception=无法解析 php 信息\: {0} 是空的
php.information.dialog.title=PHP 信息
php.inline.variable.quick.fix.family.name=内联变量
php.inspection.redundant.final.modifier='final' 修饰符冗余，具有 private 'set' 可见性的属性为隐式 final
php.intention.category=PHP
php.interface=接口
php.interpreter.base.configuration.fix.interpreter={0}。要修复，请<a href\=''{1}''>更改</a>项目解释器或<a href\=''{2}''>检查</a>设置。
php.interpreter.base.configuration.interpreter.is.invalid=无法运行 {0}，因为{1}配置的解释器无效。
php.interpreter.base.configuration.is.not.provided.or.empty={1} 的 {0} 路径未配置。您可以在“PHP|{0}”下进行修复
php.interpreter.base.configuration.working.directory=无法检测工作目录，请在运行配置中进行配置。
php.interpreter.configurable.description.laravel.herd=Herd
php.interpreter.configurable.description.main.laravel.herd=主要 Herd
php.interpreter.custom.ini.label=配置文件\:
php.interpreter.info.failed.to.parse.validation.script=无法解析验证脚本输出
php.interpreter.is.remote.message=请<a href\="">选择本地 PHP 解释器</a>以使用内置 Web 服务器
php.interpreter.is.remote.title=已配置远程 PHP 解释器
php.interpreter.label.label=标签
php.interpreter.not.configured=请<a href\="">配置 PHP 解释器</a>以使用内置 Web 服务器
php.interpreter.not.configured.title=未配置 PHP 解释器
php.interpreters.configurable.group.name.laravel.herd.interpreters=Laravel Herd 解释器
php.language.level.widget=PHP 语言级别
php.llm.smart.chat.searching.for.bundles=正在搜索捆绑包…
php.llm.smart.chat.searching.for.controller=正在搜索控制器…
php.llm.smart.chat.searching.for.entity=正在搜索实体…
php.llm.smart.chat.searching.for.events=正在搜索事件…
php.llm.smart.chat.searching.for.middlewares=正在搜索中间件…
php.llm.smart.chat.searching.for.model=正在搜索模型…
php.make.class.abstract.quick.fix.family.name=将类设为 abstract
php.make.class.non.final.quick.fix.family.name=将类设为非 final
php.make.field.non.final.quick.fix.family.name=将字段设为非 final
php.make.method.non.abstract.quick.fix.family.name=将方法设为非 abstract
php.make.method.non.final.quick.fix.family.name=将方法设为非 final
php.make.method.non.static.quick.fix.family.name=将方法设为非 static
php.make.property.hook.non.final.quick.fix.family.name=将属性挂钩设为非 final
php.method.name.empty=未指定测试方法
php.method.not.found=在类 ''{1}'' 中未找到方法 ''{0}''
php.non.strict.object.equality.quick.fix.text=替换为身份比较
php.not.test.method=类 ''{1}'' 中的方法 ''{0}'' 不是测试方法
php.path.was.updated={0} 自定义
php.path.was.updated.text=项目默认解释器已被添加到 {0}
php.prefdefined.codestyle.psr12.chosen.message=您可以启用其他 PSR-12 检查，这些检查当前已禁用。
php.prefdefined.codestyle.psr12.chosen.title=PSR-12 代码样式
php.prefdefined.codestyle.psr12.enabled.message=PSR-12 检查已启用。
php.project.configurable.composer.configs.tab.name=Composer 文件
php.project.configurable.composer.duplicate.configurations=已经存在具有相同 composer.json 的配置
php.project.configurable.composer.main=主
php.property.hooks.search.setter.getter.usages=正在搜索 getter 和 setter 用法…
php.quick.documentation.namespace.classes=命名空间类\:
php.quick.fix.add.property.hooks=添加属性挂钩
php.quick.fix.change.append.field.declared.type=将形参类型更改为 {0}
php.quick.fix.leave.one.hook.parameter.family.name=只保留一个形参
php.quick.fix.pipe.expression.convert.function.call.to.first.class.callable=将函数/方法调用转换为一级可调用语法
php.quick.fix.remove.default.value=移除默认值
php.quick.fix.remove.parameter.list=移除参数列表
php.remote.debug.name=PHP 远程调试
php.remote.interpreter.plugin.is.not.installed=PHP Remote Interpreter 插件未安装
php.remove.all.unused.parameters.quick.fix.text=移除所有未使用的形参
php.remove.doc.tag.quick.fix.family.name=移除 {0}
php.remove.exception.from.throws=从 @throws 标记中移除 ''{0}''
php.remove.parameters.quick.fix.text=移除未使用的形参
php.remove.pass.by.ref.from.parameter.quick.fix.family.name=从形参中移除 '&'
php.remove.ref.from.assignment.quick.fix.family.name=将 '\=\\&' 替换为 '\='
php.remove.ref.from.function.declaration.quick.fix.family.name=从函数声明中移除 '&'
php.remove.statement.fix.family.name=移除
php.remove.throws.tag=从 @throws 标记移除
php.remove.unused.local.variable.without.successor.quick.fix.family.name=移除变量 ''{0}''
php.rename.wrong.reference.quick.fix.family.name=重命名引用
php.replace.argument.with.cast.quick.fix.family.name=将实参转换为{0}
php.replace.try.from.with.null.quick.fix.family.name=将 'tryFrom()' 调用替换为 'null'
php.replace.with=替换为 ''{0}''
php.replace.with.float.cast.quick.fix.family.name=替换为 '(float)' 转换
php.replace.with.interface.quick.fix.family.name=替换为 {0}
php.replace.with.local.variable.quick.fix.family.name=将属性替换为局部变量
php.replace.with.null.quick.fix.family.name=替换为 'null'
php.run.check.reg.exp=运行检查 RegExp 意图 {0}
php.run.http.border.title.configuration=配置
php.run.label.https=HTTPS\:
php.run.label.interpreter=解释器\:
php.run.label.query.string=查询字符串\:
php.run.label.request.body=请求正文\:
php.run.label.request.method=请求方法\:
php.run.label.send.request.body.as=将请求正文发送为\:
php.run.label.server=服务器\:
php.run.label.url=URL\:
php.run.radio.button.key.value=键值
php.run.radio.button.text=文本
php.structure.view.dumb.mode.resolving=正在解决…
php.surround.with.if=if
php.surround.with.try.catch.quick.fix=使用 'try-catch' 包围
php.tag.is.deprecated={0} 已弃用，将在 PHPUnit 9 中移除
php.terminal.artisan.command.description=Laravel Artisan
php.terminal.composer.command.description=PHP 的依赖项管理器
php.terminal.file.path.argument.description=用于运行分析的源代码路径
php.terminal.php.command.description=运行 PHP 解释器
php.terminal.phpstan.command.description=PHPStan
php.terminal.psalm.command.description=Psalm
php.terminal.sail.command.description=Laravel Sail
php.terminal.symfony.command.description=Symfony 控制台
php.terminal.word.press.command.description=通过命令行管理 WordPress
php.terminal.word.press.info.option=打印有关 WP-CLI 环境的各种详细信息
php.test.framework.by.sdk.dialog.label=解释器(&I)\:
php.test.framework.by.sdk.new.settings.dialog.title=通过远程解释器{0}
php.test.framework.by.sdk.settings.already.exist=所选解释器的 {0} 设置已存在
php.test.framework.by.sdk.settings.remote.path.title=选择服务器上的路径
php.test.framework.by.sdk.settings.select.server=选择远程解释器以配置远程{0}
php.test.framework.configuration.can.not.update=无法更新 {0} 版本
php.test.framework.configuration.ui.library={0} 库
php.test.framework.configuration.ui.not.installed=未安装
php.test.framework.configuration.ui.path.to.exe={0} 可执行文件路径\:
php.test.framework.configuration.ui.select.interpreter=请选择 PHP 解释器以加载 {0} 版本
php.test.framework.configuration.ui.select.local.interpreter=请选择本地 PHP 解释器以加载 {0} 版本
php.test.framework.configuration.ui.test.runner=测试运行程序
php.test.framework.configuration.ui.use.configuration.file=默认配置文件\:
php.test.framework.configuration.ui.version={0} 版本\: {1}
php.test.framework.configuration.updated.version=已成功更新 {0} 版本
php.test.framework.default.interpreter.is.not.local=无法检测到 {0} 版本。默认 PHP 解释器不是本地解释器
php.test.framework.download.hyperlink={0} 版本\: <a href\={1}>{1}</a>
php.test.framework.field.test.runner.options=测试运行程序选项(&O)\:
php.test.framework.interpreter.conflict=发现应用程序级 {0} 配置冲突。为解决该问题，创建了以下配置的项目级副本\:
php.test.framework.interpreter.conflict.title={0} 配置冲突
php.test.framework.no.configuration.types.are.available=没有可用的其他配置类型
php.test.framework.project.level=(当前项目)
php.test.framework.run.configuration.ui.alternative.configuration.file=使用替代配置文件(&U)\:
php.test.framework.run.configuration.ui.alternative.custom.file=使用替代 {0}(&U)
php.test.framework.run.configuration.ui.configuration.radio.button=在配置文件中定义(&C)
php.test.framework.run.configuration.ui.custom.file.radio.button=在 {0} 中定义
php.test.framework.run.configuration.ui.directory.radio.button=目录 (&D)
php.test.framework.run.configuration.ui.directory.text.field=目录\:
php.test.framework.run.configuration.ui.file.radio.button=文件(&F)
php.test.framework.run.configuration.ui.file.text.field=文件\:
php.test.framework.run.configuration.ui.scenario.radio.button=方法(&M)
php.test.framework.run.configuration.ui.scenario.text.field=方法\:
php.test.framework.run.configuration.ui.scope=测试作用域\:
php.test.framework.run.configuration.ui.type.combo.box=类型\:
php.test.framework.run.configuration.ui.type.radio.button=类型(&T)
php.test.framework.run.confuguration.ui.dialog.caption.test.runner.options=测试运行程序选项
php.test.framework.select.type.of.settings.popup.title=选择配置类型
php.test.framework.settings.is.not.provided.or.empty={1} 的 {0} 路径未配置。按“修复”以编辑您的 {0} 配置。
php.test.framework.undefined.interpreter=未定义
php.test.framework.untrusted.reload=在安全模式下禁止刷新测试框架的版本
php.test.framework.validation.run.configuration.file.working.directory=文件应该是工作目录的子项\: ''{0}''
php.test.framework.validation.run.configuration.method=在 ''{1}'' 中找不到 ''{0}''
php.test.framework.validation.run.configuration.no.type=如果未选择类型则无法运行测试。
php.test.framework.validation.run.configuration.unsupported.type=无法通过 ''{0}'' 命令运行测试。
php.test.framework.validation.run.configuration.working.directory=目录应该是工作目录的子文件夹\: ''{0}''
php.test.framework.version.configuration.ui.can.not.parse.version=无法解析版本命令输出。\n{0}
php.test.framework.version.detector.empty.output=''{0}'' 命令输出为空。
php.test.framework.version.getting.version.title=正在获取 {0} 版本…
php.test.framework.version.path.to.exe.is.invalid={0} 可执行文件的路径为空或无效。
php.test.frameworks.form.application=\ (应用程序)
php.testframework.local.interpreter=本地解释器
php.testframework.local.interpreter.version=本地 PHP {0}
php.testframework.remote.interpreter=远程 {0}
php.title.docker.compose.settings=Docker Compose 设置
php.trait=特征
php.turn.off.path.modification=关闭 {0} 自定义
php.uml.provider.presentable.name=PHP 类图
php.unit.checkbox.use.alternative.patterns.base.path=使用替代模式基路径\:
php.unit.create.target.class.quick.fix.family.name=创建缺少的目标类
php.unit.create.target.method.quick.fix.family.name=创建缺少的目标方法
php.unit.label.test.file.template=测试文件模板(&T)\:
php.unit.local.run.description=PHPUnit
php.unit.local.run.display.name=PHPUnit
php.unit.optional=可选
php.unit.radio.button.composite=复合
php.unit.test.runner.options=测试运行程序选项
php.web.application.name=PHP Web 应用程序
php.web.server.validation.action.text=Web 服务器调试验证
php.web.server.validation.additional.configuration.files=<b>已解析的其他 .ini 文件\:</b> {0}
php.web.server.validation.chose.path.to.script=选择验证脚本的路径
php.web.server.validation.chose.path.to.script.description=选择本地文件夹以创建验证脚本
php.web.server.validation.client.host.is.reachable=<b>调试客户端主机</b>\: 可以访问
php.web.server.validation.client.host.is.unreachable=<b>调试客户端主机</b>\: 无法访问
php.web.server.validation.client.host.is.unreachable.descr=请确保已正确配置 <i>xdebug.remote_host</i> (适用于 Xdebug 2)、<i>xdebug.client_host</i> (适用于 Xdebug 3)或 zend_debugger。值可以是运行 PhpStorm 的机器的主机名(例如，localhost)或 IP 地址，并且必须可以从服务器 ping 通。使用 Xdebug 时，<i>xdebug.remote_connect_back</i> (适用于 Xdebug 2)或 <i>xdebug.discover_client_host</i> (适用于 Xdebug 3)可用于故障排除。
php.web.server.validation.client.phpstorm.is.reachable=<b>PhpStorm\:</b> 准备接收 Xdebug 连接
php.web.server.validation.client.phpstorm.is.unreachable=<b>PhpStorm\:</b> 无法接收 Xdebug 连接
php.web.server.validation.client.phpstorm.is.unreachable.descr=侦听传入调试连接可能被禁用，或者可能在设置中为传入连接指定了错误的端口
php.web.server.validation.configuration.files=<b>已加载的 php.ini\:</b> {0}
php.web.server.validation.configure.local=指定文档根下的目录路径及其对应的 URL
php.web.server.validation.configure.phpinfo=请粘贴 <i>phpinfo()</i> 的完整输出
php.web.server.validation.configure.phpinfo.desc=复制并粘贴 HTML 版本、HTML 源代码或 <i>php -i</i> 输出
php.web.server.validation.configure.remote=指定目录路径并选择部署服务器
php.web.server.validation.configure.validation.script=复制下载脚本命令，在正在运行的 Web 服务器上执行，并检查 URL 的输出
php.web.server.validation.deployment.server=部署服务器(&D)\:
php.web.server.validation.deployment.server.tooltip=所选服务器会用于将验证脚本部署到远程服务器
php.web.server.validation.dialog.validate.button=验证(&V)
php.web.server.validation.docker=<b>在 Docker 容器中</b>\: {0}
php.web.server.validation.failed.to.deploy.validation.script=无法将验证脚本部署到服务器
php.web.server.validation.failed.to.execute.script=指定的 URL 不可到达，原因是\: ''{0}''
php.web.server.validation.failed.to.fetch.script.result=无法提取验证脚本的结果
php.web.server.validation.failed.to.find.deployment.settings=找不到服务器的部署设置
php.web.server.validation.failed.to.find.web.path=请配置验证脚本的 Web 路径
php.web.server.validation.failed.to.map.deployment.folder=请为验证目录配置远程路径映射
php.web.server.validation.failed.to.map.deployment.folder.to.web=请为验证目录配置 Web 路径映射
php.web.server.validation.failed.to.unzip=无法从 {0} 提取数据
php.web.server.validation.invalid.path.to.script=验证目录的路径无效
php.web.server.validation.loaded.debugger.extension=<b>调试器扩展\:</b> {0}
php.web.server.validation.local.path.to.script=放置验证脚本的目录(&D)\:
php.web.server.validation.local.path.to.script.tooltip=所选路径应可通过 Web 服务器访问
php.web.server.validation.local.web.server.radio=本地 Web 服务器或共享文件夹(&L)
php.web.server.validation.multi.debugger.extension=Xdebug 和 Zend Debugger 扩展均已加载
php.web.server.validation.multi.debugger.extension.description=只有一个调试器扩展可在 php.ini 中加载。
php.web.server.validation.no.configuration.files=找不到 php.ini 文件
php.web.server.validation.no.debugger.extension=未加载调试扩展
php.web.server.validation.os=<b>客户端主机操作系统</b>\: {0}
php.web.server.validation.os.server=<b>服务器主机操作系统</b>\: {0}
php.web.server.validation.process.title=验证 Web 服务器
php.web.server.validation.reference.to.documentation=请参阅<a href\="{0}">{0}</a>获取更多信息。
php.web.server.validation.remote.web.server.radio=远程 Web 服务器(&R)
php.web.server.validation.script.local.result.path.mapping.check=请检查是否为 <b>''{0}''</b> 目录正确配置了验证脚本的 Web 路径
php.web.server.validation.script.result.is.empty=验证脚本的结果为空
php.web.server.validation.script.result.path.mapping.check=请检查是否在部署设置中为 <b>''{0}''</b> 目录正确配置了远程和 Web 路径映射
php.web.server.validation.script.result.wrong.format=验证脚本的结果具有意外格式
php.web.server.validation.server.name=<b>服务器名称\:</b> {0}
php.web.server.validation.server.name.is.empty=服务器名称为空
php.web.server.validation.server.name.is.empty.description=PhpStorm 内部需要使用服务器名称进行识别。<br> 在 Web 服务器配置文件中配置服务器名称。
php.web.server.validation.synonym=验证调试
php.web.server.validation.synonym2=验证 Xdebug
php.web.server.validation.title=验证 Web 服务器上的调试器配置
php.web.server.validation.uploading.validation.script=正在将验证脚本上传至 {0}
php.web.server.validation.url.to.validation.script=指向包含脚本的目录的 URL(&U)\:
php.web.server.validation.url.to.validation.script.tooltip=所选 Web 路径将用于运行验证脚本
php.web.server.validation.xdebug.debugger.host=<b>远程主机\:</b> {0}
php.web.server.validation.xdebug.debugger.host.description=正在运行调试器<b>客户端</b>的主机。
php.web.server.validation.xdebug.debugger.host.remote.addr=<br/><br/>在 php.ini 文件中，将 <b>''{0}''</b> 设为 <i>''{1}''</i> 或自 Web 服务器可见的本地机器 IP 地址。
php.web.server.validation.xdebug.debugger.localhost=尽管服务器主机可能不在本地，但远程主机仍配置为 ''{0}''
php.web.server.validation.xdebug.mode.is.not.supported=不支持远程模式 ''{0}''
php.web.server.validation.xdebug.option.is.enabled=<b>{0}\:</b> 选项已启用
php.web.server.validation.xdebug.option.is.ignored.description=<b>{0}\:</b> 选项将被忽略。
php.web.server.validation.xdebug.option.is.not.enabled.description=<b>{0}\:</b> 选项未启用
php.web.server.validation.xdebug.port=<b>远程端口\:</b> {0}
php.web.server.validation.xdebug.port.require.sudo=<b>远程端口\:</b> {0}，需要根权限才能使用
php.web.server.validation.xdebug.port.require.sudo.description=要在 Linux 和 Mac 上使用小于 1024 的端口，必须具有根权限。
php.web.server.validation.xdebug.protocol.is.not.supported=不支持调试协议 ''{0}''
php.web.server.validation.xdebug.remote.autostart.description=调试会话将尝试为每个请求启动。
php.web.server.validation.xdebug.remote.is.not.enable=远程调试未启用
php.web.server.validation.xdebug.remote.is.not.enable.description=将 <b>''{0}''</b> 行添加到 php.ini 文件。
php.web.server.validation.xdebug.remote.log=<b>{0}\:</b> {1}
php.web.server.validation.xdebug.remote.mode.jit=<b>远程模式\:</b> 'jit'
php.web.server.validation.xdebug.remote.mode.jit.description=调试会话将仅在出现错误后初始化。
php.web.server.validation.xdebug.remote.mode.req=<b>远程模式\:</b> 'req'
php.web.server.validation.xdebug.remote.mode.req.description=调试会话将在脚本启动时初始化。
php.web.server.validation.xdebug.wrong.port=Xdebug 端口(''{0}'')与“PHP->调试 IDE”设置(''{1}'')不同
php.web.server.validation.xdebug.wrong.port.description=来自 php.ini (<b>{0}</b>)的 Xdebug 端口应与在 IDE 内(在 <b>PHP->调试</b>下)配置的端口相同。
php.web.server.validation.xdebug.wrong.port.format=<b>Xdebug 端口无效\:</b> ''{0}''
php.web.server.validation.xdebug.zend.extension.load=Xdebug 必须通过 'zend_extension' 而不是 'extension' 加载
php.web.server.validation.xdebug.zend.extension.load.description=在 php.ini 文件中使用 <b>'zend_extension\=path_to_xdebug.so'</b> 行以加载 Xdebug 扩展。
php.web.server.validation.xdebug3.cloud.php.ini.xdebug.disabled.message=<b>Php.ini 云调试\:</b> 已禁用。
php.web.server.validation.xdebug3.cloud.xdebug.correct.cloud.id.message=<b>IDE 中的云 ID\:</b> 与服务器上的云 ID 相同
php.web.server.validation.xdebug3.cloud.xdebug.disabled.message=<b>通过 Xdebug Cloud 连接</b>\: 已禁用。在 IDE 设置中启用\: <b>PHP->调试->XDebug Cloud</b>
php.web.server.validation.xdebug3.cloud.xdebug.doesnt.accept.connections.message=Xdebug 现在不接受外部连接
php.web.server.validation.xdebug3.cloud.xdebug.wrong.cloud.id.description=<b>IDE 中的云 ID\:</b> {0}<br><b>服务器上的云 ID\:</b> {1}
php.web.server.validation.xdebug3.cloud.xdebug.wrong.cloud.id.message=<b>IDE 中的云 ID\:</b> 与服务器上的云 ID 不同
php.web.server.validation.xdebug3.discover.client=该设置默认处于禁用状态。如果启用，Xdebug 会尝试自动连接到发出 HTTP 请求的调试客户端。
php.web.server.validation.xdebug3.discover.client.message=<b>发现客户端主机</b>\: Xdebug 将尝试自动提取客户端主机。
php.web.server.validation.xdebug3.discover.client.no=<b>发现客户端主机</b>\: 关闭
php.web.server.validation.xdebug3.discover.client.with.discover.header=根据 <b>$_SERVER[''{0}'']</b> 中的值，Xdebug 将尝试自动连接到客户端。若失败，则以空的 <b>''xdebug.client_discovery_header''</b> 回到 <b>''xdebug.discover_client_host''</b>。
php.web.server.validation.xdebug3.option.in.invalid.mode=''{0}'' 选项设置为 ''{1}''，这对于 xdebug3 是无效模式。
php.web.server.validation.xdebug3.option.is.enabled.message=<b>{0}</b>\: 选项被设置为 ''{1}''。
php.web.server.validation.xdebug3.remote.mode.emulation.description=调试会话将在脚本启动时初始化，与 xdebug2 的 <b>remote_mode\=''{0}''</b> 相同。
php.web.server.validation.xdebug3.remote.mode.emulation.message=<b>远程模式\:</b> xdebug2 的 ''{0}'' 已模拟。 
php.web.server.validation.xdebug3.start.upon.error.description=调试会话将尝试根据相应配置在错误时自动启动。
php.web.server.validation.xdebug3.start.with.request.description=调试会话将尝试根据相应配置自动启动。
php.web.server.validation.zend.debugger.deny.host=<b>拒绝主机\:</b> {0}
php.web.server.validation.zend.debugger.deny.host.description=无法使用拒绝主机从客户端进行调试。
php.web.server.validation.zend.debugger.host=<b>远程主机\:</b> {0}
php.web.server.validation.zend.debugger.localhost=尽管服务器不在本地，但调试会话仅适用于本地主机。
php.web.server.validation.zend.debugger.localhost.description=将正在运行调试器<b>客户端</b>的主机添加至 <b>'zend_debugger.allow_hosts'</b> 选项。
php.web.server.validation.zend.expose.remotely=<b>属性 ''expose_remotely''</b> 设为 ''{0}''
php.web.server.validation.zend.expose.remotely.allowed.hosts.description=调试器会话将尝试从 <b>'zend_debugger.allow_hosts'</b> 选项为主机启动。
php.web.server.validation.zend.expose.remotely.always.description=调试器会话将尝试为每个客户端启动。
php.web.server.validation.zend.expose.remotely.never.description=调试器会话将不会进行初始化，<b>'zend_debugger.allow_hosts'</b> 选项将被忽略。<br>将选项 <b>'zend_debugger.expose_remotely'</b> 设置为 'allowed_hosts' 或 'always' 以启用 Web 服务器调试。
php.web/server.validation.validation.script=调试验证脚本
php.xdebug.enable.dfa.assist=预测分析程序数据流的未来条件值
php.xdebug.enable.dfa.assist.gray.mode=将预计不可到达的代码块变灰
php.xdebug.move.to.resolve.breakpoint=如果断点与源不同，则将断点移动到已解析的位置
phpdoc.code.style.throws.analysis.depth.performance.note.message=不建议深入分析多个级别，因为这可能会影响 IDE 性能。要继续吗?
phpdoc.code.style.throws.analysis.depth.performance.note.title=性能注释
phpunit.10.won.t.support.classname.annotations=PHPUnit 10 将不支持 ClassName\:\:<*> 注解
phpunit.can.not.rerun.failed.tests.title=无法执行失败的 PHPUnit 测试。
phpunit.config.directory.label=目录\:
phpunit.config.empty.pattern=空模式
phpunit.config.label=测试根
phpunit.getting.phpunit.version=正在更新 PhpUnit 版本…
phpunit.label.data.set=数据集\:
phpunit.not.tests.was.executed.message=要修复，为 <i>{0}</i> <a href\="config">配置</a>自动加载文件或 PHPUnit phar 路径。
phpunit.not.tests.was.executed.title=未配置 PHPUnit
platform.reqs.are.missing=缺少平台要求。
plural.types.are.not.allowed.in.real.types=仅在 doc 类型中允许复数类型
popup.content.configuration.remains.unchanged=当前配置与解释器同步
popup.content.enabled.disabled.extensions=已启用{0}和已禁用{1}扩展
popup.select.target.code.block.closure=箭头函数体(转换为闭包)
popup.select.target.code.block.containing.block=包含块
popup.title.multiple.write.scopes.found=找到多个写入作用域
popup.title.select.reference.to.remove=选择要移除的类型
popup.title.select.target.code.block=选择目标代码块
possible.tool.process.hangup.after.0.sec={0} 秒后可能工具过程挂起。
postfix.template.provider.display.name=PHP
potentially.polymorphic.call.multiple.subclasses=潜在的多态调用。该代码可能无法操作，具体取决于作为实参传递的实际类实例。
potentially.polymorphic.call.single.subclass=潜在的多态调用。{0} 的层次结构中没有成员
primitive.hints.name.are.forbidden.in.php.7=PHP 7 中禁止名为 'int'、'string'、'float'、'bool'、'true'、'false' 和 'null' 的类
private.constant.cannot.be.final='private' 常量不能为 'final'，因为它对其他类不可见
private.methods.cannot.be.final=private 方法不能是 final，因为它们从不会被其他类重写
proceed=继续
profiler.button.refresh=刷新
profiler.column.invocation.callable=可调用
profiler.column.invocation.count.title=调用
profiler.column.memory.title=内存(B)
profiler.column.own.memory.title=自身内存(B)
profiler.column.own.time.title=自用时间
profiler.column.script=脚本
profiler.column.time.title=时间
profiler.label.time=时间\:
profiler.measurement.unit.microsecond=微秒
profiler.measurement.unit.microsecond.short=µs
profiler.measurement.unit.millisecond=毫秒
profiler.measurement.unit.millisecond.short=毫秒
profiler.measurement.unit.second=秒
profiler.measurement.unit.second.short=秒
profiler.view.call.tree.title=调用树
profiler.view.callees.title=被调用方
profiler.view.callers.title=调用方
profiler.view.execution.statistics.title=执行统计
profiler.xdebug.file.chooser.title=选择 Xdebug 分析器快照
profiler.xdebug.task.parsing=正在解析 ''{0}''
profiler.xdebug.task.title=分析 Xdebug 分析器快照
progress.text.fetching.result.from=正在从 {0} 提取结果
progress.text.submitting.code.to.3v4l.org=正在将代码提交到 3v4l.org
progress.title.executing.3v4l.org=正在 3v4l.org 上执行代码
progress.title.initializing.git.repository=正在初始化 Git 仓库
project.files=项目文件
project.is.already.disposed=项目已被处置
promoted.property=提升属性
property=属性
property.declaration=属性声明
property.is.undefined=属性 '\#ref' {0,choice,0\#未定义|1\#可能未定义}
property.is.undefined.in.class=属性 ''\#ref'' 在 {0} 中{1,choice,0\#未找到|1\#可能未定义}
property.or.function=属性或函数
property.read=@property-read
property.write=@property-write
provide.the.full.path.to.executable=提供可执行文件的完整路径。
psr.12.add.missing.parameter.list=PSR-12\: 添加缺少的形参列表
psr.12.add.public.visibility=PSR-12\: 添加 'public' 可见性
psr.12.convert.to.short.form=PSR-12\: 转换为缩写
psr.12.extract.namespace=PSR-12\: 提取命名空间
psr.12.fix.modifiers.order=PSR-12\: 修复修饰符顺序
psr.12.replace.var.with.public=PSR-12\: 将 'var' 替换为 'public'
psr.12.split.to.several.use.statements=PSR-12\: 拆分为多个 'use' 语句
psr.roots.revert=还原
public.and.static='public' 和 'static'
quality.inspection.button.tooltip=该按钮显示相应的检查是否打开
quality.tool.action.clean.list.text=清除列表
quality.tool.action.remove.file.s.from.list.text=从列表中移除文件
quality.tool.border.title.ignored.files=已忽略的文件
quality.tool.button.validate=验证
quality.tool.can.not.create.temporary.file=PhpStorm 无法创建临时文件
quality.tool.can.not.determine.version=无法确定工具版本，得到 ''{0}''
quality.tool.can.not.retrieve.standards=无法检索可用规则集，请检查 PHP CS Fixer 工具配置。
quality.tool.checkbox.installed.standard.paths=已安装的标准路径\:
quality.tool.checkbox.show.sniff.name=显示 sniff 名称
quality.tool.checkbox.show.warning.as=将警告显示为\:
quality.tool.coding.stardards.has.been.updated=已安装的编码标准列表已更新。
quality.tool.configuration.can.not.find.configuration.by.id=按 ID 找不到 {0} 配置\: ''{1}''
quality.tool.configuration.default.interpreter.is.not.found=默认选择 {0} 配置解释器，但未指定解释器
quality.tool.configuration.for.interpreter.is.not.found=找不到解释器的 {0} 配置\: ''{1}''
quality.tool.configuration.interpreter.is.undefined={0} 配置的解释器未指定或无效
quality.tool.configuration.tool.path.is.empty=所选配置的 {0} 路径为空
quality.tool.cs.fixer.allow.risky.rules=允许为内置规则集设置有风险的规则
quality.tool.cs.fixer.custom.rules.warning=选择 'Custom' 类型以选择您的配置。
quality.tool.cs.fixer.reformat.action=PHP CS Fixer\: 修复整个文件
quality.tool.cs.fixer.ruleset=规则集\:
quality.tool.empty.path.phpcs={0} 的路径为空
quality.tool.file.not.found=找不到文件。
quality.tool.ignored.files={0} 忽略的文件
quality.tool.label.check.files.with.extensions=检查带扩展名的文件\:
quality.tool.label.coding.standard=编码标准\:
quality.tool.label.configuration=配置\:
quality.tool.label.custom.rulesets=自定义规则集\:
quality.tool.label.label=标签
quality.tool.label.tool.path=工具路径\:
quality.tool.label.tool.process.timeout=工具处理超时，[1...60] 秒\:
quality.tool.label.validation.label=验证标签
quality.tool.laravel.pint=Laravel Pint
quality.tool.laravel.pint.json.path=pint.json 的路径\:
quality.tool.laravel.pint.quick.fix.text=Laravel Pint\: 修正整个文件
quality.tool.laravel.pint.reformat.only.uncommitted.files=仅重新设置未提交文件的格式
quality.tool.laravel.pint.ruleset=规则集\:
quality.tool.laravel.pint.should.be.json.file=选择 .json 文件
quality.tool.path.must.not.be.empty=路径不得为空。
quality.tool.php.cs.fixer.required.phpcs.version=支持的 PHP CS Fixer 版本为 2.8.0 或更高，找到的是 {0}
quality.tool.php.dir.does.not.contain=该目录不包含{0}
quality.tool.php_cs.custom.rules.validation.not.php_cs=PHP CS Fixer 不支持所选规则集
quality.tool.php_cs.dir.does.not.contain.custom=此目录不包含任何受支持的文件\: {0}
quality.tool.phpcbf.location=PHPCBF 位置
quality.tool.phpcbf.location.descr=选择有效的 phpcbf 启动器
quality.tool.phpcbf.name=PHP Code Beautifier and Fixer
quality.tool.phpcbf.path=phpcbf 路径\:
quality.tool.phpcbf.reformat.action=PHP Code Beautifier and Fixer\: 修复整个文件
quality.tool.phpcbf.settings=PHP Code Beautifier and Fixer 设置
quality.tool.phpcs.can.not.retrieve.standards=无法检索可用标准，请检查 PHP_CodeSniffer 工具配置。
quality.tool.phpcs.custom.rules.validation.not.xml=所选规则集不是 XML
quality.tool.phpcs.custom.rules.warning=选择 'Custom' 编码标准类型以选择自定义规则集。
quality.tool.phpcs.installed.paths=已安装的标准路径
quality.tool.phpcs.label.path.to.ruleset=规则集路径\:
quality.tool.phpcs.required.phpcs.version=所需的 PHP_CodeSniffer 版本为 1.5.0 或更高，找到的是 {0}
quality.tool.selected.file.is.not.phpcbf=所选文件不是 phpcbf 可执行文件
quality.tool.settings.link.inspection={0} 检查\:
quality.tool.stardards.has.been.updated=已安装的规则集列表已更新。
quality.tools.0.added.to.ignored.files.list={0}已添加到忽略的文件列表。
quality.tools.custom.coding.standard=自定义编码标准
quality.tools.label.by.default.project.interpreter=默认为项目解释器
quality.tools.provider.tooltip=此文件被排除在外部质量工具分析和格式设置外。您可以从忽略的文件列表中移除该文件。
quick.fix.change.field.type.to.match.get.hook.return.type=更改字段类型以匹配 'get' 挂钩返回类型
quick.fix.change.set.hook.parameter.type.to.match.field.type=将 ''set'' 挂钩的形参更改为 {0}
quick.fix.delete=删除 ''{0}''
quick.fix.error=快速修复错误
quick.fix.missing.class.constant.type=作为常量类型添加 ''{0}''
quick.fix.promote.property.with.private.set.visibility.modifier=使用 'private(set)' 可见性修饰符提升属性
quick.fix.replace.clone.with.clone.with=将 'clone' 替换为 'clone with'
quick.fix.replace.getter.setter.with.hooks=将 {0} 替换为 {1}
quick.fix.replace.property.with.private.set.visibility.modifier=将属性替换为 'private(set)' 可见性修饰符
quickfix.access.static.via.class.reference=替换为 ''{0}''
quickfix.add.parentheses.around.new.call=在 'new' 调用周围添加圆括号
quickfix.add.to.use=添加到闭包 'use' 构造
quickfix.can.not.find.class.reference.name=无法按名称查找类
quickfix.can.not.find.dynamic.method.reference=找不到动态方法引用
quickfix.can.not.find.static.method.reference=找不到 static 方法引用
quickfix.cannot.find.class.reference=找不到要解析的类引用
quickfix.cannot.find.target.class=无法从引用 ''{0}'' 解析类
quickfix.case.sensitive.name=更改 {0} 的大小写以匹配其声明
quickfix.change.field.type.add.inferred.type.error.non.project=无法修改非项目文件 ''{0}''
quickfix.change.field.type.add.inferred.type.error.read.only=无法修改只读文件 ''{0}''
quickfix.change.field.type.add.inferred.type.family.name=作为属性的类型添加推断的类型
quickfix.change.field.type.add.inferred.type.name=作为属性的类型添加 ''{0}''
quickfix.change.field.type.to.match.super=更改类型以匹配父项
quickfix.change.field.type.to.match.super.0=将类型更改为 ''{0}'' 以匹配父项
quickfix.change.field.type.to.match.super.remove=移除类型声明以匹配父项
quickfix.change.type=更改为 ''{0}''
quickfix.change.type.declaration.family=更改类型
quickfix.convert.arrayall.to.loop=将 'array_all()' 调用转换为循环
quickfix.convert.arrayany.to.loop=将 'array_any()' 调用转换为循环
quickfix.convert.arrayfill.to.loop=将 'array_fill()' 调用转换为循环
quickfix.convert.arrayfilter.to.loop=将 'array_filter()' 调用转换为循环
quickfix.convert.arrayfind.to.loop=将 'array_find()' 调用转换为循环
quickfix.convert.arrayfindkey.to.loop=将 'array_find_key()' 调用转换为循环
quickfix.convert.arraymap.to.loop=将 'array_map()' 调用转换为循环
quickfix.convert.loop.to.arrayall=将循环转换为 'array_all()' 调用
quickfix.convert.loop.to.arrayany=将循环转换为 'array_any()' 调用
quickfix.convert.loop.to.arrayfilll=将循环转换为 'array_fill()' 调用
quickfix.convert.loop.to.arrayfilter=将循环转换为 'array_filter()' 调用
quickfix.convert.loop.to.arrayfind=将循环转换为 'array_find()' 调用
quickfix.convert.loop.to.arrayfindkey=将循环转换为 'array_find_key()' 调用
quickfix.convert.loop.to.arraymap=将循环转换为 'array_map()' 调用
quickfix.convert.to.json.validate=转换为 'json_validate()'
quickfix.convert.to.new.style.constructor=将构造函数转换为新样式
quickfix.create.class=创建类
quickfix.create.field.from.callback.invalid.element=无法从回调提取属性名称
quickfix.create.field.from.callback.name=从回调创建属性
quickfix.create.field.from.callback.unresolved.class.ref=无法从回调创建属性。无法解析目标类引用。
quickfix.create.function.from.callback.family.name=从回调创建函数
quickfix.create.function.from.callback.name=添加函数
quickfix.create.method.from.callback.name=从回调创建方法
quickfix.create.parameter=创建形参
quickfix.delete.return.argument=删除返回实参
quickfix.disable.inspection.for.global.namespace=为全局命名空间禁用检查
quickfix.failed.to.create.class=无法创建类 ''{0}''
quickfix.import.base.no.candidates=找不到要导入的候选项
quickfix.import.class.name=导入类
quickfix.import.class.popup.title=要导入的类
quickfix.import.constant.name=导入常量
quickfix.import.constant.popup.title=要导入的常量
quickfix.import.function.name=导入函数
quickfix.import.function.popup.title=要导入的函数
quickfix.is.not.available.in.dump.mode=项目分析期间无法进行 ''{0}'' 快速修复
quickfix.make.call.static.name=将调用设为 static
quickfix.make.method.static=设为 'static'
quickfix.move.class.to.corresponding.directory=移至目录 ''{0}''
quickfix.move.class.to.corresponding.directory.error.file.exists=文件 {0} 已存在
quickfix.move.class.to.corresponding.directory.error.unable.create.directories=无法创建缺少的目录\: ''{0}''
quickfix.move.class.to.corresponding.directory.error.unable.move.file=无法将文件移至目录 ''{0}''
quickfix.multiple.target.class.resolve=类 ''{0}'' 有多个声明
quickfix.navigate.to.duplicate.array.key=导航到重复键
quickfix.navigate.to.duplicate.case.value=导航到重复的 case 值
quickfix.navigate.to.duplicate.condition=导航到重复条件
quickfix.non.strict.object.equality=非严格对象相等比较
quickfix.omit.parentheses.around.new.call=省略 'new' 调用周围的圆括号
quickfix.overriding.method.visibility=移除可见性重写
quickfix.php.missing.param.type.batch.description=作为属性类型添加推断的类型
quickfix.php.missing.param.type.description=作为形参类型添加 ''{0}''
quickfix.phpdoc.update.field.type=将{0, choice, 0\#属性|1\#类常量}类型更改为 ''{1}'' 以匹配 PHPDoc 注释
quickfix.phpdoc.update.type=更新 PHPDoc 类型
quickfix.phpunit.assert.equals.flip.compared.arguments=翻转比较实参
quickfix.phpunit.create.target.class.error.filename.exists=存在文件 {0}
quickfix.phpunit.drop.redundant.optional.parameters=删除冗余的可选形参
quickfix.phpunit.replace.current.method.with.alternative=替换为 ''{0}''
quickfix.remove.condition.from.default.arm=从 'default' arm 中移除非 'default' 条件
quickfix.remove.default.arm=移除重复的 'default' match arm
quickfix.remove.duplicate.condition=移除重复条件
quickfix.remove.match.arm=移除 'match' arm
quickfix.remove.override.attribute=移除 '\#[Override]'
quickfix.remove.phpdoc=移除冗余 PHPDoc 注释
quickfix.remove.phpdoc.param.tag=移除 @param 标记
quickfix.remove.phpdoc.return.tag=移除 @return 标记
quickfix.remove.phpdoc.signature.tags=移除不必要的 @param 和 @return 标记
quickfix.remove.redundant.phpdoc.tags=移除所有冗余的 PHPDoc 标记
quickfix.remove.type=移除类型 ''{0}''
quickfix.remove.unnecessary.qualifier=移除不必要的限定符
quickfix.remove.unnecessary.qualifier.on.class.name=简化 FQN
quickfix.remove.unused.condition=移除未使用的条件
quickfix.replace.assignment.operator.with.prefix.expression.family.name=将赋值运算符替换为前缀表达式
quickfix.replace.assignment.with.operator.assignment.family.name=将赋值替换为运算符赋值
quickfix.replace.assignment.with.operator.assignment.name=将 ''\='' 替换为 ''{0}\=''
quickfix.replace.assignment.with.prefix.expression.family.name=将赋值替换为前缀表达式
quickfix.replace.curly.braces.with.brackets=将大括号替换为中括号
quickfix.replace.nested.ternary.expression=将三元表达式替换为 {0} 关联版本
quickfix.replace.one.operator.with.another=将 ''{0}'' 替换为 ''{1}''
quickfix.set.inheritance.between.classes=使{0} {1} {2}
quickfix.strict.type.checking.change.parameter.type.family=更改形参类型
quickfix.strict.type.checking.change.parameter.type.name=将{0, choice, 1\#第 1 个|2\#第 2 个|3\#第 3 个|4\#第 {0,number} 个}形参的类型从 ''{1}'' 更改为 ''{2}''
quickfix.strict.type.checking.change.return.type.family=更改返回值类型
quickfix.strict.type.checking.change.return.type.name=将返回值类型从 ''{0}'' 更改为 ''{1}''
quickfix.strict.type.checking.extend.return.type.family=扩展返回值类型
quickfix.strict.type.checking.extend.return.type.name=将返回值类型从 ''{0}'' 扩展为 ''{1}''
quickfix.undefined.function.add.function=添加函数
radio.button.by.concatenation=通过串联(&C)
radio.button.by.embeding=通过嵌入(&E)
radio.button.class.constructor=类构造函数(&S)
radio.button.const=const(&C)
radio.button.copy.from.base.class=从基类复制(&P)
radio.button.current.method=当前方法(&T)
radio.button.default=默认(&F)
radio.button.default.empty.template=默认/空模板(&E)
radio.button.define=定义(&D)
radio.button.field.declaration=属性声明(&D)
radio.button.private=private(&I)
radio.button.protected=protected(&O)
radio.button.public=public(&U)
radio.button.setup=设置(&U)
radio.button.with.inheritdoc.tag=带有 @inheritDoc 标记(&I)
radio.for.all.properties=适用于所有方法
radio.only.for.properties.without.declared.type=适用于没有声明类型的方法
reading.and.writing.creates.files.if.not.exists.fails.otherwise=读/写。如果文件不存在则创建文件，如果找到文件则失败。
reading.and.writing.start.at.the.beginning.of.the.file=读/写。从文件开头开始。
reading.and.writing.start.at.the.beginning.of.the.file.and.truncate.the.file.to.zero.length.creates.files.if.not.exists=读/写。从文件开头开始，将其截断为零长度。如果文件不存在则创建文件。
reading.and.writing.start.at.the.the.end.of.the.file.creates.files.if.not.exists=读/写。从文件末尾开始。如果文件不存在则创建文件。
reading.and.writing.starts.at.the.beginning.of.the.file.creates.files.if.not.exists=读/写。从文件开头开始。如果文件不存在则创建文件。
reading.only.start.at.the.beginning.of.the.file=只读。从文件开头开始。
readonly.property.cannot.have.default.value='readonly' 属性不能具有默认值
readonly.property.must.have.type='readonly' 属性必须指定类型
recursive.call=递归调用
redefinition.of.parameters.is.not.allowed=不允许形参重新定义
refactoring.common.fail.to.extract.expression=无法从所选代码段中提取表达式
refactoring.common.not.extractable.expression=不支持此类表达式
refactoring.common.not.supported.context=当前上下文不支持{0}
refactoring.common.not.supported.expression.in.scope=当前作用域不支持此类表达式的{0}
refactoring.common.ui.target.directory.edit=按 F2 编辑目标目录
refactoring.common.ui.target.directory.label=目标目录(&D)\:
refactoring.common.ui.target.namespace.label=命名空间(&N)\:
refactoring.common.validation.class.psi=无法执行重构\: 目标类“{0}”无效
refactoring.common.validation.namespace.name=“{0}”不是有效的命名空间名称
refactoring.common.validation.target.directory.is.not.valid=目录“{0}”的路径无效
refactoring.common.validation.target.directory.not.inside.project=目录“{0}”不在项目内部
refactoring.copy.class.name=复制类
refactoring.extract.base.dialog.replace.all.occurrences=替换所有匹配项(找到 {0} 个匹配项)(&A)
refactoring.extract.base.handler.no.expression.selected=选择不构成正确的表达式
refactoring.extract.base.handler.not.supported.expression=此类表达式不支持{0}
refactoring.extract.base.handler.not.supported.scope=当前作用域不支持{0}
refactoring.extract.base.validator.not.valid.identifier=“{0}”不是有效的 PHP 标识符。
refactoring.extract.base.validator.reserved.keyword=“{0}”是保留的 PHP 关键字。
refactoring.extract.class.conflicts.extract.class.refactoring.is.not.supported.for.dynamically.declared.properties.usages=动态声明属性用法不支持“提取类”重构
refactoring.extract.class.conflicts.method.0.depends.on.1.constant.2=方法“{0}”依赖于 {1} 常量“{2}”
refactoring.extract.class.conflicts.method.0.depends.on.1.method.2=方法“{0}”依赖于 {1} 方法“{2}”
refactoring.extract.class.conflicts.method.0.depends.on.property.1.which.needs.getters.in.2=方法“{0}”依赖于属性 "${1}"，需要“{2}”中的 getter
refactoring.extract.class.conflicts.method.0.depends.on.property.1.which.needs.setters.in.2=方法“{0}”依赖于属性 "${1}"，需要“{2}”中的 setter
refactoring.extract.class.conflicts.unable.to.add.delegate.property.initialization.to.constructor=无法将委托的属性初始化添加到类构造函数
refactoring.extract.class.conflicts.unable.to.add.delegate.property.initialization.to.constructor.trait.constructor.will.be.overridden=无法将委托的属性初始化添加到类构造函数\: 特征构造函数将被重写
refactoring.extract.class.conflicts.using.write.access.for.non.public.properties.in.array.destructuring.expressions.is.not.supported.in.extract.class.refactoring=“提取类”重构不支持将写入权限用于数组析构表达式中的非 public 属性
refactoring.extract.class.conflicts.using.write.access.for.non.public.properties.in.multiple.assignment.expressions.in.extract.class.refactoring=“提取类”重构不支持将写入权限用于多个赋值表达式中的非 public 属性
refactoring.extract.class.dialog.class=类名\:
refactoring.extract.class.dialog.generate.accessors=生成访问器(&G)
refactoring.extract.class.dialog.members.to.be.extracted=要提取的成员
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.abstract.methods=抽象方法不支持 Extract Class 重构
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.anonymous.classes=匿名类不支持 Extract Class 重构
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.anonymous.functions=匿名函数不支持 Extract Class 重构
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.doc.methods=通过 PHPDoc 定义的魔术方法不支持 Extract Class 重构
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.doc.properties=通过 PHPDoc 定义的魔术属性不支持 Extract Class 重构
refactoring.extract.class.error.failed.to.create.file=无法创建文件
refactoring.extract.class.error.the.selected.function.should.belong.to.project.sources=所选函数必须属于项目源
refactoring.extract.class.extract.to.class=提取到类
refactoring.extract.class.extracting.from.class=正在从类提取\:
refactoring.extract.class.extracting.from.file=正在从文件提取\:
refactoring.extract.constant.conflict.already.exists=作用域中已经存在名称为“{0}”的常量。
refactoring.extract.constant.conflict.cannot.override.interface.constant=无法重写接口“{1}”的常量“{0}”
refactoring.extract.constant.conflict.exists.in.subclass=“{0}\:\:{1}”将被此常量重写
refactoring.extract.constant.conflict.exists.in.subclass.with.weaker.access=“{0}”的访问级别必须为“{1}”(如在类“{2}”中)或更弱
refactoring.extract.constant.name=提取常量
refactoring.extract.constant.unable.to.add.constant.declaration="无法添加常量声明"
refactoring.extract.field.conflict.already.exists=该类中已经存在名称为“{0}”的属性。
refactoring.extract.field.name=提取属性
refactoring.extract.field.validator.reserved.field.name=“{0}”是保留的属性名称
refactoring.extract.field.visibility=可见性
refactoring.extract.field.visibility.private=private(&I)
refactoring.extract.field.visibility.protected=protected(&O)
refactoring.extract.field.visibility.public=public(&U)
refactoring.extract.interface.fail.to.create.file=无法创建文件 ''{0}''。
refactoring.extract.interface.field=接口名称(&I)\:
refactoring.extract.interface.invalid.caret.location=文本光标应置于要重构的类名处。
refactoring.extract.interface.invalide.extract.from.trait=无法从特征提取接口。
refactoring.extract.interface.members.title=要构成接口的成员(&B)
refactoring.extract.interface.name=提取接口
refactoring.extract.interface.no.methods=没有要提取到接口的方法。
refactoring.extract.interface.phpdoc.copy=复制(&C)
refactoring.extract.interface.phpdoc.do.nothing=保留原样(&A)
refactoring.extract.interface.phpdoc.move=移动(&M)
refactoring.extract.interface.phpdoc.title=PhpDoc
refactoring.extract.interface.title=从类 ''{0}'' 提取接口
refactoring.extract.interface.validation.members.modifier=对于每个提取的方法，修饰符将更改为 public。
refactoring.extract.method.error.a.set.of.statements.should.be.from.the.same.code.block=一组语句应来自同一代码块。
refactoring.extract.method.error.inconsistent.return.points.in.selected.code.fragment=所选代码段中的返回点不一致。
refactoring.extract.method.error.selected.block.should.represent.a.set.of.statement.or.an.expression=所选块应代表一组语句或表达式。
refactoring.extract.method.error.there.are.break.continue.operators.which.can.interrupt.execution=存在会中断执行的 break/continue 运算符。
refactoring.extract.method.from.duplicate.code=从重复的代码中提取方法
refactoring.extract.method.name=提取函数/方法
refactoring.extract.method.tooltip=输入 $name \= 'init'
refactoring.extract.parameter.name=提取形参
refactoring.extract.replace.class.reference=尽可能将类引用替换为接口(&F)
refactoring.extract.variable.conflict.already.exists=作用域中已经存在名称为“{0}”的变量。
refactoring.extract.variable.name=提取变量
refactoring.inline.cannot.find.variable.to.inline=找不到要内联的变量
refactoring.inline.constant.all.references.and.keep=全部内联并保留常量
refactoring.inline.constant.all.references.and.remove=全部内联并移除常量
refactoring.inline.constant.cannot.extract.value=无法提取常量的值
refactoring.inline.constant.command=内联常量
refactoring.inline.constant.is.never.used=常量 {0} 从未使用
refactoring.inline.constant.multiple.declarations=还有其他具有相同名称的常量声明。
refactoring.inline.constant.name=内联常量
refactoring.inline.constant.this.reference.only=仅内联此引用并保留常量
refactoring.inline.function.all.invocations.and.remove.the.method=全部内联并移除{0}(&A)
refactoring.inline.function.all.invocations.keep.the.method=全部内联并保留{0}(&E)
refactoring.inline.function.cannot.find.function.declaration=找不到函数声明
refactoring.inline.function.cannot.inline.constructor=无法内联构造函数
refactoring.inline.function.cannot.inline.first.class.callable.declaration=无法内联一级可调用声明
refactoring.inline.function.cannot.inline.function.with.global.usage=无法内联{0}和 <code>global</code> 用法
refactoring.inline.function.cannot.inline.library.function=无法内联库函数
refactoring.inline.function.cannot.inline.magic.method=无法内联魔术方法
refactoring.inline.function.cannot.inline.overridden.method=无法内联被重写的方法
refactoring.inline.function.cannot.parse.function.body=无法解析函数体
refactoring.inline.function.command=正在内联{0}
refactoring.inline.function.inline.function.refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow=当 return 语句中断执行流程时，不支持内联函数重构
refactoring.inline.function.not.accessible.from.caller.site=无法从调用者站点访问成员引用 <code>{0}</code>
refactoring.inline.function.only.static.method.is.supported=仅支持 static 方法
refactoring.inline.function.parent.reference.unresolved=<code>parent</code> 类引用在 {0} 中未解析
refactoring.inline.function.reference.is.recursive=不支持递归调用
refactoring.inline.function.this.invocation.only.and.keep.the.method=仅内联此调用并保留{0}(&K)
refactoring.inline.function.title=内联{0}重构
refactoring.inline.function.yield.found.in.function.body=在函数体中找到 <code>yield</code> 用法
refactoring.inline.variable.cannot.extract.value=无法提取变量 ''${0}'' 的值
refactoring.inline.variable.no.occurrences=没有匹配项可以被安全地内联
refactoring.inline.variable.unary.operation=无法内联到递减或递增运算
refactoring.inplace.extract.method.name=就地提取函数/方法
refactoring.make.method.static=将方法设为 static
refactoring.make.method.static.add.parameters.for.fields=添加属性形参(&P)\:
refactoring.make.method.static.doc.method.is.not.supported=不支持文档方法
refactoring.make.method.static.dynamic.method.call.found=实例对象应作为形参传递，找到动态方法调用\: {0}
refactoring.make.method.static.magic.method=魔术方法不能设为 static
refactoring.make.method.static.method.calls.found.in.static.context=在 static 上下文中找到方法调用
refactoring.make.method.static.method.converts.method.to.static=将方法转换为 static
refactoring.make.method.static.method.is.overridden=方法 {0} 被重写
refactoring.make.method.static.object.is.needed=方法 {0} 使用未作为形参传递的属性 {1}
refactoring.make.method.static.private.field.is.not.accessible=private 属性 {0} 无法从类外部访问
refactoring.make.method.static.protected.field.is.not.accessible=protected 属性 {0} 无法从类及其继承者外部访问
refactoring.make.method.static.references.to.be.changed=待更改引用 {0}
refactoring.make.method.static.this.found=实例对象应作为形参传递，找到 $this
refactoring.make.method.static.writeAccess=检测到 {0} 写入访问，实例对象应作为形参传递。
refactoring.make.static.then.move.method.message=方法 ''{0}'' 将被设为 ''public static''
refactoring.make.static.then.move.method.select=将方法 ''{0}'' 移至类
refactoring.move.class.action.name=移动类…
refactoring.move.class.cannot.move.anonymous.class=无法移动匿名类
refactoring.move.class.in.non.code.message=注释和字符串中的类引用
refactoring.move.class.name=移动类
refactoring.move.class.new.file=将类提取到单独的文件(&E)
refactoring.move.class.title=将类 {0} 移至命名空间(&C)\:
refactoring.move.classes.dnd.files.with.the.same.name.error=单个目标中不允许有多个同名文件。
refactoring.move.classes.dnd.name=移动类
refactoring.move.classes.dnd.title=将所选{0,choice,0\#类|1\#命名空间|2\#类和命名空间}移至命名空间\:
refactoring.move.constant.action.name=移动常量…
refactoring.move.constant.class.already.contains.constant=类 {0} 已包含常量 {1}
refactoring.move.constant.class.already.contains.method=类 {0} 已包含方法 {1}
refactoring.move.constant.label.text.field=将常量 {0} 移至类(&C)
refactoring.move.constant.title=移动常量
refactoring.move.constant.unable.to.resolve=无法解析 {0}
refactoring.move.function.action.name=移动函数…
refactoring.move.function.interface.cant.contain.method=接口中不允许带有主体的方法
refactoring.move.function.label.text.field=将函数 {0} 移至类(&C)
refactoring.move.function.title=移动函数
refactoring.move.instance.method=移动实例方法
refactoring.move.instance.method.action.name=移动实例方法…
refactoring.move.instance.method.preview.header=要移至另一个类的方法
refactoring.move.instance.method.this.parameter.label=将替换类 {0} 的 $this 引用的形参名称
refactoring.move.instance.method.usage.will.not.be.accessible=用法 {0} 将无法访问。应提高方法可见性
refactoring.move.member.action.name=移动成员…
refactoring.move.member.method.is.overridden.in.a.sublclass={0} 在子类 {1} 中被重写
refactoring.move.member.title=移动 static 成员
refactoring.move.members.0.will.be.hidden.in.1=成员 {0} 将在 {1} 中被隐藏
refactoring.move.members.cannot.find.target.class=找不到类 {0}
refactoring.move.members.class.0.does.not.exist=类 {0} 不存在。\n是否要创建?
refactoring.move.members.enum.0.already.contains.case.with.name.0=枚举 {0} 已经包含名称为 ''{1}'' 的 case
refactoring.move.members.enum.0.already.contains.case.with.value.1=枚举 {0} 已经包含值为 ''{1}'' 的 case
refactoring.move.members.is.not.a.valid.class.name=“{0}”不是有效的类名
refactoring.move.members.is.not.accessible={0} 在 {1} 中无法访问
refactoring.move.members.late.static.binding.detected=检测到延迟 static 绑定\: {0}
refactoring.move.members.late.static.binding.detected.in.doc=在文档中检测到延迟 static 绑定
refactoring.move.members.member.will.change.visibility.to.public=成员 {0} 会将可见性更改为 public
refactoring.move.members.method.implements.abstract.method={0} 在 {1} 中实现 abstract 方法
refactoring.move.members.method.implements.method.in={0} 在 {1} 中实现方法
refactoring.move.members.move.as.enum.cases=作为枚举 case 移动
refactoring.move.members.no.members.are.selected=未选择成员
refactoring.move.members.only.constants.can.be.moved.to.interface=只有常量可以移至接口
refactoring.move.members.preview.header=要移至另一个类的成员
refactoring.move.members.properties.can.not.be.moved.to.enum=属性不能移动到枚举
refactoring.move.members.self.from.anonymous.class=无法处理对匿名类的自引用
refactoring.move.members.there.are.several.classes.with.specified.name=存在多个具有指定名称 {0} 的类
refactoring.move.members.to.be.moved=要移至另一个类的成员(&B)
refactoring.move.members.unable.to.resolve.usage.callback.found=无法解析用法\: 发现回调\: {0}
refactoring.move.members.unable.to.resolve.usage.late.static.binding.detected=无法解析用法\: 检测到延迟 static 绑定\: {0}
refactoring.move.method.cannot.move.constructor=无法移动构造函数
refactoring.move.method.cannot.move.magic.method=无法移动魔术方法
refactoring.move.method.label.text.field=将成员移至类(&C)
refactoring.move.multiple.constant.label.text.field=将 {0} 个常量移至类(&C)
refactoring.move.multiple.functions.label.text.field=将 {0} 个函数移至类(&C)
refactoring.move.namespace.action.name=移动命名空间…
refactoring.move.namespace.header.message=移动命名空间
refactoring.move.namespace.in.non.code.message=注释和字符串中的命名空间引用
refactoring.move.namespace.message=要移动的命名空间
refactoring.move.namespace.name=移动命名空间
refactoring.move.namespace.new.namespace=新命名空间名称(&N)\:
refactoring.move.namespace.title=移动命名空间 {0}
refactoring.move.related.namespace.collect.title=收集子命名空间
refactoring.move.related.namespace.description=将具有相关命名空间的文件移至新目录\:
refactoring.move.related.namespace.directory.column=新建目录
refactoring.move.related.namespace.name.column=新命名空间名称
refactoring.move.related.namespace.title=移动具有相关命名空间的文件
refactoring.parameter.reserved.name=形参名称“{0}”已保留
refactoring.parameter.validation=形参 {0} 无效
refactoring.parameter.validation.default.value=默认值表达式 ''{0}'' 无效
refactoring.parameter.validation.duplicate.parameter=重复的形参名称\: {0}
refactoring.parameter.validation.initializer=初始值设定项 ''{0}'' 无效
refactoring.parameter.validation.initializer.last=必选形参不能位于可选形参后
refactoring.parameter.validation.initializer.type=具有类类型提示的形参的默认值只能为 NULL
refactoring.parameter.validation.name.collision.with.use.list=形参名称 ''{0}'' 无效。''{0}'' 已导入 use 列表
refactoring.parameter.validation.no.default.value=应该为形参 ''{0}'' 提供初始值设定项或默认值
refactoring.parameter.validation.pass.by.reference=仅变量可通过引用传递
refactoring.parameter.validation.type=形参类型 ''{0}'' 无效
refactoring.parameter.validation.variadic.can.have.default.value=可变形参不能具有默认值
refactoring.parameter.validation.variadic.last=只有最后一个形参可以是可变形参
refactoring.php.cannot.create.class=无法在预览中创建新类
refactoring.php.create.class=创建新类
refactoring.php.extract.enum=提取枚举
refactoring.pull.up.abstract.method=类 {0} 将被标记为 abstract
refactoring.pull.up.class.does.not.have.base.classes.interfaces.in.project.files={0}在项目文件中没有基类/接口
refactoring.pull.up.conflict.duplicate.constant={0} 将与 {1} 中的常量冲突。
refactoring.pull.up.implement.method=在实现接口的类中创建方法存根(&S)
refactoring.pull.up.is.1.and.will.not.be.accessible.in.the.target.class={0} 为 private，在目标类中将无法访问。
refactoring.pull.up.may.not.be.accessible.in.the.target.class={0} 在目标类中可能无法访问。
refactoring.pull.up.private.access={0} 访问权限将更改为 {1}
refactoring.pull.up.static.reference.is.not.accessible.in.the.target.class=非 static 方法 {0} 不应在外部类中静态调用
refactoring.pull.up.validation.field.into.interface=无法将属性拉入接口
refactoring.pull.up.validation.static.method.into.interface={0} 为 static，不能为 abstract。
refactoring.pull.up.will.not.be.accessible.in.the.target.class={0} 在目标类中将无法访问。
refactoring.push.down.method.implemented.in.interface={0} 必须被声明为 abstract 或实现 {1}
refactoring.push.down.validation.magic.method=移动魔术方法会产生副作用
refactoring.rename.automatic.renamer.accessors.name=重命名访问器(&C)
refactoring.rename.automatic.renamer.class.dialog.description=将具有以下名称的类重命名为\:
refactoring.rename.automatic.renamer.class.dialog.title=重命名类
refactoring.rename.automatic.renamer.class.entity.name=类
refactoring.rename.automatic.renamer.class.name=重命名类(&C)
refactoring.rename.automatic.renamer.field.accessors.dialog.description=将具有以下名称的属性访问器重命名为\:
refactoring.rename.automatic.renamer.field.accessors.dialog.title=重命名访问器
refactoring.rename.automatic.renamer.field.accessors.entity.name=访问器
refactoring.rename.entity.name.inheritor=继承者/文件
refactoring.rename.inheritors.and.related.files.with.the.following.names.to=将具有以下名称的继承者和相关文件重命名为\:
refactoring.rename.search.in.global.scope=在全局作用域中搜索
refactoring.returnType.validation.type=返回值类型 ''{0}'' 无效
refactoring.validation.class.error.property.with.name.0.is.already.exists=已存在名称为“{0}”的属性
reference=引用
referenced.calls=引用的调用
reformats.file.with.0=使用 ''{0}'' 重新设置文件格式
relationship.already.exists={0} 与 {1} 之间的关系已存在
release.name.eg.5.1.2.release=发布名称。例如，5.1.2-RELEASE
remote.connection.settings.default.remote.interpreter=默认远程解释器
remote.connection.settings.interpreter.is.not.remote=当前项目解释器非远程解释器
remote.interpreter.browse.action.is.not.supported.for.docker=基于 Docker 的远程解释器不支持浏览操作
remote.interpreter.can.t.be.executed.please.enable.the.php.remote.interpreter.plugin=无法执行远程解释器。启用 PHP Remote Interpreter 插件。
remote.interpreter.path.mappings.validation.message=请检查映射是否在 {0} 下正确配置。
remote.interpreter.path.mappings.validation.php.section=<b><i><a href\="php_mappings">设置|PHP</a></i></b>
remote.interpreter.path.mappings.validation.title=没有为所选解释器配置路径映射。
remove=移除
remove.assignment=移除赋值
remove.else=移除 else…
remove.from.function.0.declaration=从函数 ''{0}'' 声明中移除 ''\\&''
remove.from.ignored.list=移除
remove.from.the.parameter.0=从形参 ''{0}'' 中移除 ''\\&''
remove.link.between.0.and.1=移除 {0} 与 {1} 之间的链接
remove.numeric.literals.separators=移除数字字面量分隔符
remove.pass.by.ref=移除 '\\&'
remove.pass.by.ref.sign=移除 '\\&'
remove.redundant.initializer=移除冗余的初始值设定项
remove.redundant.suppression.quick.fix.family.name=移除 ''{0}'' 禁止
remove.relationship.link=移除关系链接
remove.rule=移除规则
remove.unnecessary.parentheses=移除不必要的圆括号
remove.unnecessary.reset=移除不必要的 'reset'
remove.unnecessary.semicolon=移除不必要的分号
remove.variable=移除变量
rename=重命名
rename.constructor=重命名构造函数
rename.filename.quick.fix=将文件 ''{0}'' 重命名为 ''{1}''
rename.parameter.dialog.description=将层次结构中的形参重命名为\:
rename.parameters.dialog.title=重命名形参
rename.psi.element.quick.fix=将{0} ''{1}'' 重命名为 ''{2}''
replace.all.occurrences.with.php=将所有匹配项替换为 '<?php'
replace.all.occurrences.with.php.echo=将所有匹配项替换为 '<?php echo'
replace.all.occurrences.with.short.php.echo=将所有匹配项替换为 '<?\='
replace.all.occurrences.without.side.effects=替换所有无副作用的匹配项
replace.deprecated.from.of.callable=替换已弃用的可调用对象形式
replace.extends.implements=替换 'extends'/'implements'
replace.if.clause.with.ternary.expression=将 if 子句替换为三元表达式
replace.if.with.switch=将 'if' 替换为 'switch'
replace.plus.asgn.to.concat.asgn.quick.fix.family.name=将 '+\=' 替换为 '.\='
replace.plus.to.concat.quick.fix.family.name=将 '+' 替换为 '.'
replace.qualifier.with.an.import=将限定符替换为导入
replace.quotes=替换引号
replace.ternary.expression.with.if.clause=将三元表达式替换为 if 子句
replace.unnecessary.double.quotes=替换不必要的双引号
replace.variable.assignment.with.named.argument=将变量赋值替换为命名实参
replace.with.0=替换为 {0}
replace.with.01=替换为 {0}
replace.with.absolute.reference=替换为绝对引用
replace.with.alias=替换为别名
replace.with.alias.from.target.scope=替换为目标作用域中的别名
replace.with.anonymous.function=替换为匿名函数
replace.with.array=替换为直接赋值 '$array \= array($value)'
replace.with.array.short.syntax=替换为直接赋值 '$array \= [$value]'
replace.with.arrow.function=替换为箭头函数
replace.with.coalesce.operator=替换为合并运算符
replace.with.first.class.callable.family.name=替换为一级可调用语法
replace.with.pow.operator=替换为 '**' 运算符
replace.with.quest=替换为 '?'
require='必需'
required.parameters.missing=缺少所需形参 ''{0}''
required.trait.0.wasn.t.added.to.1=必需特征 ''{0}'' 未添加到 ''{1}''
rerun.with.ignore.platform.reqs=使用 --ignore-platform-reqs 重新运行
retrieving.php.version.data.from.3v4l.org=正在从 3v4l.org 检索 PHP 版本信息
return.type=返回值类型
return.type.declaration.is.not.allowed=不允许返回值类型声明
return.type.declaration.must.be.compatible.with.super=返回值类型声明必须与父级兼容
returned.by.iterator.aggregate.should.be.traversable=\\IteratorAggregate\:\:getIterator() 返回的对象必须为 Traversable 或实现接口 Iterator
rfc.2822.rfc.5322.formatted.date=RFC 2822/RFC 5322 格式的日期({0})
run.install.update.with.platform.reqs=使用 --ignore-platform-reqs 运行安装/更新(&R)
run.with.paratest=使用 ParaTest 运行
run.with.paratest.mnemonic=使用 ParaTest 运行 %s
searching.for.usages=正在搜索用法…
seconds.numeric=秒，数字(1、3、57)
seconds.numeric.at.least.2.digits.with.leading.0=秒，数字，至少 2 位数，带前导 0 (01、03、57)
seconds.since.the.unix.epoch.january.1.1970.00.00.00.gmt=自 Unix 时间戳 1970 年 1 月 1 日 00\:00\:00 GMT 以来的秒数({0})
seconds.with.leading.zeros=带前导零的秒(00 到 59)
select.composer.phar.and.provide.the.full.path.to.it.or.select.download.composer.stable.phar.from.getcomposer.org=选择 'composer.phar' 并提供其完整路径，或者选择“从 getcomposer.org 下载 composer-stable.phar”。
select.composer.phar.and.provide.the.full.path.to.it.or.select.download.composer.stable.phar.from.getcomposer.org1=选择 'composer.phar' 并提供其完整路径，或者选择“从 getcomposer.org 下载 composer-stable.phar”。
server=服务器
set=设置
set.access.level.to.0.1.must.be.2.as.in.class.3.or.weaker=''{0}\:\:${1}'' 的 ''set'' 访问级别必须为 {2} (与类 ''{3}'' 中一样)或更低
set.close.on.exec.flag.on.the.opened.file.descriptor.only.available.in.php.compiled.on.posix.1.2008.conform.systems=在文件描述符上设置 close-on-exec 标志。仅适用于符合 POSIX.1-2008 标准的系统。
set.the.following.option=设置以下选项\:
settings.smart.keys.auto.insert.closing.html.tag.in.php.doc=在 PHPDoc 块中自动插入 HTML 结束标记
settings.smart.keys.auto.insert.semicolon=在函数调用内部键入时自动插入分号 
settings.smart.keys.auto.insert.tag.after.typing=输入 '<?' 后自动插入 '<?php' 标记
settings.smart.keys.enable.smart.function.parameters.completion=启用智能函数形参补全
settings.smart.keys.escape.symbols.on.paste.in.string.literals=在字符串字面量中粘贴时转义符号
settings.smart.keys.find.usages.of.base.method.prompt=搜索方法用法时显示其他选项
settings.smart.keys.remove.php.open.close.tags.while.pasting.in.php.context=在 PHP 上下文中粘贴时移除 PHP 开始/结束标记
settings.smart.keys.replace.unnecessary.double.quotes.on.paste=粘贴时替换不必要的双引号
settings.smart.keys.select.variable.name.without.dollar.sign.on.double.click=在双击时选择不带 '$' 符号的变量名
settings.smart.keys.title=PHP
short.arrow.function.cannot.return.void=箭头函数不能有 'void' 返回值类型
shorten.property.hook=缩短属性挂钩
show.0.settings.window=显示 ''{0}'' 设置窗口
show.composer.settings.action.name=显示 Composer 设置
show.constants=显示常量
show.implementations.for.0={0} 的实现
show.includes=显示 Include
show.log=显示日志
show.log.of.composer.related.actions=显示 Composer 相关操作的日志
show.name.for.all.arguments=显示所有实参的名称
show.private.members=显示 private 成员
show.properties=显示属性
show.protected.members=显示 protected 成员
show.settings=显示设置
show.super.types.for.0=显示 {0} 的父类型
show.validation.dialog=显示“验证调试器”对话框
shows.0.dialog=显示 ''{0}'' 对话框
shows.dialog.with.methods.from.implemented.interface.selected.methods.will.be.inserted.into.the.class.after.dialog.confirmation=显示包含已实现接口中方法的对话框。对话框确认后，所选方法将被插入到类中。
shows.list.of.child.classes.with.inaccessible.methods=显示具有不可访问方法的子类列表
shows.list.of.child.classes.without.without.resolved.member=显示没有已解析成员的子类列表
sign.minus.when.negative.empty.when.positive=负数时标记为 "-"，正数时留空(-、 )
sign.minus.when.negative.plus.when.positive=负数时标记为 "-"，正数时标记为 "+" (-、+)
simulating.update=正在模拟更新
skip.constant.params=跳过使用常量形参的调用
smarty=Smarty
smarty.configurable.title=Smarty
sort.by.visibility=按可见性排序
sort.the.elements.by.visibility.public.protected.private=按可见性对元素排序\: public、protected、private
split.elseif=拆分 'elseif'
split.selected.group.use.statement=拆分所选 'use' 语句组
spread.operator.on.named.arguments.is.forbidden=禁止对命名实参使用展开运算符
spread.operators.in.arrays.are.not.supported.for.multiassignments.variables=多赋值变量不支持在数组中使用展开运算符
squash.repetitive.underscores=压缩重复下划线
static.is.not.allowed.in.compile.time.constants=编译时常量中不允许使用 'static\:\:'
static.is.not.allowed.in.parameter.type.declaration=形参类型声明中不允许 'static'
static.modifier.is.not.allowed.here=此处不允许使用 'Static' 修饰符
static.property.cannot.be.readonly='static' 属性不能为 'readonly'
static.property.cannot.be.unset=static 属性不能取消设置
static.value=static 值
static.variable.with.same.name.already.defined.in.current.scope=static 变量 ''{0}'' 的声明重复
status.text.no.dependencies=无依赖项
strict.type.declaration.is.available.in.php.7.only=从 PHP 7.0 起才允许使用严格类型声明
strict.types.declaration.must.have.0.or.1.as.its.value='strict_types' 声明的值必须为 0 或 1
summary=摘要
suppress.all.for.file=对文件全部禁止
suppress.for.field=对字段禁止
suppress.for.file=对文件禁止
suppress.for.function=对函数禁止
suppress.for.method=对方法禁止
suppress.for.phpdoc.comment=对 PhpDoc 注释禁止
suppress.if.annotated.by.tag=如果用 ''{0}'' 注解，则禁止
suppress.unused.preview=对使用 ''{0}'' 注解的实体禁止“未使用的声明”检查
suppressed.annotation.title=已禁止的注解
surround.with.0=使用 ''{0}'' 包围
surround.with.if.0.1=使用 ''if({0}({1}))'{'...'}''' 包围
swatch.internet.time=Swatch 互联网时间(000 到 999)
switch.statements.may.only.contain.one.default.clause.in.php.7=在 PHP 7 中，switch 语句只能包含一个 'default' 子句
switch.with.common.parts=包含通用部分的 'switch'
switching.from.another.vs.code.sublime.text.or.another.ide.check.out.our.migration.guides.to.get.started.faster=从 VS Code、Sublime Text 或其他 IDE 切换而来? 请查看我们的迁移指南以更快地开始使用。
target=目标
target.class=目标类\:
target.directory.for.validation.script.is.not.public=验证脚本的目标目录不是 public。
target.trait.should.be.specified=应指定目标特征
template.debug.cache.dir.is.incorrect=模板调试\: 在设置中指定的缓存目录路径无效
template.debug.cache.dir.is.not.specified=模板调试\: 未在设置中指定缓存目录路径
template.debug.cache.path=缓存路径\:
template.debug.path.to.output.folder=缓存目录路径
template.debug.path.to.output.folder.descr=指定缓存目录路径
template.debug.php.file.not.found=模板调试\: 未找到 {0} 的相应 PHP 文件
template.parameter=模板形参
template.smart.completion.function.parameters.description=智能函数形参补全
terminal.add.interpreter.to.path=将默认项目 PHP 解释器添加到 {0}
ternary.condition.can.be.replaced.with.condition.expression=表达式可以安全地替换为 ''{0}''
test.not.tests.was.executed.title=未配置 {0}。按 ''修正'' 安装 composer 软件包。
text.plain=文本/纯
the.button.shows.whether.inspection.is.on.or.off=该按钮显示检查是开启还是关闭
the.day.of.the.year.starting.from.0=一年中的第几天(0 至 365)
the.original.class.0.does.not.belong.to.the.project.and.cannot.be.modified=原始类 {0} 不属于该项目\n并且无法修改。
the.remote.hosts.access.plugin.is.missing.please.enable.the.plugin.in.0.plugins=缺少 ''FTP/SFTP/WebDAV Connectivity'' 和 ''Terminal'' 插件中的一个或两个。请在“{0} | 插件”中启用插件。
the.result.of.validation.will.be.fetched.by.http.request=验证输出由 HTTP 请求提取。
the.same.as.p.but.returns.z.instead.of.00.00.available.as.of.php.8.0=与 P 相同，但返回 Z 而不是 +00\:00，从 PHP 8.0 起可用(+02\:00)
the.use.keyword.must.be.declared.in.the.outermost.scope.of.a.file.the.global.scope.or.inside.namespace.declarations=必须在文件的最外侧作用域(全局作用域)或命名空间声明内部声明 'use' 关键字
the.yield.expression.can.only.be.used.inside.a.function='yield' 表达式只能在函数中使用
there.are.errors.on.attempt.to.load.debug.extension.e.g.version.incompatibility=尝试加载调试扩展时出错，例如版本不兼容。
this.is.the.default.contains.all.modes.in.the.sequence.s.n.r.v.m=这是默认值。包含序列 "s n r v m" 中的所有模式
this.reassignment.is.not.allowed=不能重新分配 $this
this.will.remove.relationship.link.between.classes=这将移除类之间的关系链接并修改类 {0}。继续?
timezone.abbreviation.if.known.otherwise.the.gmt.offset=时区缩写(如果已知)，否则为 GMT 偏移量(EST、MDT、+05)
timezone.identifier=时区标识符(UTC、GMT、大西洋/亚速尔群岛)
timezone.offset.in.seconds=以秒为单位的时区偏移量(-43200 到 50400)
tooltip.configured.php.language.level.widget=已配置的 PHP 语言级别
tooltip.configured.php.language.level.widget.composer=通过 Composer 配置的 PHP 语言级别
tooltip.defaults.to.project.folder=默认为项目文件夹
tooltip.from=来自{0}\:
tooltip.from.volumes=来自{0}卷\:
tooltip.update=更新 {0}
tooltip.wsl2.mappings=WSL2 映射
total.number.of.days.as.a.result.of.a.datetime.diff.or.unknown.otherwise=由 DateTime\:\:diff() 或(未知)方法得出的总天数(4、8、8123)
trailing.comma.is.not.allowed=不允许尾随逗号
trait.already.contains.method=特征 {0} 已包含方法 {1}
trait.expected.class.found=应为特征，发现类
trait.method.0.will.not.be.applied.because.it.collides.with.1=由于与 ''{1}'' 冲突，因此不会应用特征方法 ''{0}''
trait.use.rule.type.name=特征 use 规则方法
transform=转换
turn.off.external.formatter=关闭外部格式化程序
turn.off.inspection.tool=关闭 {0} 检查
type=类型
type.0.cannot.be.part.of.an.intersection.type=类型 ''{0}'' 不能是交叉类型的一部分
type.0.is.redundant.as.it.is.more.restrictive.than.type.1=类型 ''{0}'' 冗余，因为它比类型 ''{1}'' 更加严格
type.contains.both.true.and.false.bool.should.be.used.instead=类型同时包含 true 和 false，应改用布尔
type.primitive.false.null.hints.names.are.forbidden=从 PHP 8.0 起才允许使用名为 'false' 和 'null' 的类型提示
type.primitive.true.hints.names.are.forbidden=从 PHP 8.2 起才允许使用名为 'true' 的类型提示
types.not.supported.as.operands.for.0.1.2=''{1} {0} {2}'' 中不受支持的操作数类型将导致 PHP 8 TypeError
uml.0.already.exists.in.class.1=类 {1} 中已经存在 ''{0}''
uml.wrong.name=错误的名称
undefined.interpreter=未定义的解释器
unhandled.0=未处理的{0}
unhandled.exceptions=未处理的异常
union.types.and.the.nullable.type.notation.cannot.be.mixed=联合体类型和可为 null 类型表示法不能混合
union.types.mixed.cannot.be.nullable=混合类型不能为可 null，'null' 已是混合类型的一部分
unknown=未知
unknown.debugger.type=未知调试器类型
unknown.named.parameter=未知命名形参 ''{0}''
unnamed.variable=(未命名)
unnecessary.local.variable=不必要的局部变量
unsupported.declare.0=不支持的声明 ''{0}''
untrusted.composer.dialog.text=正在安装或更新依赖项，或者运行 Composer 命令可能会执行潜在的恶意代码。\n\n如果不信任此源，请继续使用安全模式。
unused.code.rules=未使用的代码规则
unwrap.dowhile=解包 do-while…
unwrap.else=解包 else…
unwrap.elseif=解包 elseif…
unwrap.for=解包 for…
unwrap.foreach=解包 foreach…
unwrap.if=解包 if…
unwrap.method=解包 ''{0}''
unwrap.switch=解包 switch…
unwrap.try=解包 try…
unwrap.while=解包 while…
update.php.doc.type.comment=替换为 ''{0}''
update.php.doc.type.family.name=更新 PHPDoc 类型
update.signature.to.match.phpdoc.comment=更新签名以匹配 PHPDoc 注释
uppercase.ante.meridiem.and.post.meridiem.am.pm=大写上午和下午(AM/PM)
url.to.validation.script='验证脚本的 URL'
usage.in.extends.clause=etends 子句中的用法
usage.in.implements.clause=implements 子句中的用法
usage.in.import.statement=import 语句中的用法
usage.in.return.type=返回值类型中的用法
usage.in.type.hinting=类型提示中的用法
usage.of.intersection.types.grouping.is.allowed.only.as.part.of.union.type=交叉类型分组仅允许作为联合体类型的一部分使用
usages.show.this.self.references=显示 $this/自引用
use.0.in.callables.is.deprecated=在可调用对象中使用 ''{0}'' 已弃用
using.this.when.not.in.object.context=不在对象上下文中时使用 '$this'
validated.web.server.is.not.running=验证的 Web 服务器未运行。
validating=正在验证
validating1=正在验证…
validation.0.extension.is.installed.check.configuration.options=已安装 ''{0}'' 扩展。检查配置选项。
validation.0.extension.is.not.installed=未安装 ''{0}'' 扩展
validation.0.is.not.a.directory=''{0}'' 不是目录
validation.0.not.found.at.1=在 ''{1}'' 中找不到 ''{0}''
validation.cannot.parse.value.of.0=无法解析 ''{0}'' 的值
validation.class.already.exists={0}中已经存在具有相同名称的类
validation.class.cannot.be.overridden=类“{0}”不能被重写
validation.class.not.valid.name=“{0}”不是有效的类名
validation.connection.was.not.established=未建立连接。
validation.connection.was.not.established.0=无法使用 ''{0}'' 启动调试器会话
validation.connection.was.not.established.no.debug=未安装调试扩展
validation.connection.was.not.established.update.info=更新解释器信息
validation.connection.was.not.established.validate.installation=验证安装
validation.debug.extension.is.updated=调试扩展设置已更新。请重新运行当前配置以使用新值。
validation.file.already.exists=文件“{0}”已存在
validation.file.already.exists.in.dir=名称为“{0}”的文件已存在于“{1}”中
validation.file.not.valid.name=“{0}”不是有效的文件名
validation.function.already.exists=当前命名空间中已定义具有相同名称的函数
validation.interface.cannot.be.overridden=无法实现接口“{0}”
validation.invalid.alias=“{0}”不是有效的别名
validation.invalid.identifier=“{0}”不是有效的标识符
validation.invalid.identifier.with.no.identifier=插入的标识符无效
validation.namespace.already.exists={1}中已定义名称为 ''{0}'' 的命名空间
validation.namespace.not.valid.name=“{0}”不是有效的命名空间名称
validation.no.debug.extension.is.installed=未安装调试扩展。
validation.press.fix.to.edit.project.configuration=按“修复”编辑您的项目配置。
validation.script.was.created.but.it.cannot.be.executed.check.possible.reasons=验证脚本已创建，但无法执行。可能的原因\:
validation.script.will.be.created.in.0.directory=验证脚本将在 {0} 目录中创建。
validation.script.will.be.created.in.0.directory.and.deployed.to.the.1.server=验证脚本将在 {0} 目录中创建并部署到 {1} 服务器。
validation.script.will.be.created.locally.and.deployed.to.the.remote.server=IDE 会在本地创建临时验证脚本并将其部署到远程服务器。
validation.script.will.be.created.locally.and.the.result.will.be.fetched.by.http.request=IDE 会在指定目录中创建一个临时验证脚本，然后从 Web 服务器 URL 提取并解析此脚本生成的 XML 输出。之后，脚本将被移除。
validation.ssh.remote.code.coverage.support={0} 扩展不支持通过 ssh 进行代码覆盖
validation.ssh.remote.debug.support=''{0}'' 扩展不支持通过 ssh 进行远程调试。
validation.test.no.test.patterns=未添加任何模式
validation.value.is.invalid={0} 无效
validation.value.is.not.specified.or.invalid={0} 未指定或无效。
validation.value.is.not.specified.or.invalid.press.fix.project.configuration={0} 未指定或无效。按“修复”编辑您的项目配置。
validation.value.is.not.specified.press.fix.project.configuration={1} 配置中未指定 {0}。按“修复”以编辑 {1} 配置。
validation.value.path.to.value.is.invalid=无法通过 {1} 中提供的路径找到 {0}
validation.value.path.to.value.is.invalid.press.fix.project.configuration=无法通过 {1} 中提供的路径找到 {0}。按“修复”以编辑 {2} 配置。
validation.value.path.to.value.should.be.specified={0} 的路径应在 {1} 中指定
validation.vendor.doesnt.exit=供应商目录不存在
value=值
variable=变量
variable.always.have.value.0=到达时变量始终为 ''{0,choice,0\#false|1\#true}'
variable.dereferenced=已解引用变量
variable1=变量
variadic.parameter.cannot.have.a.default.value=可变形参不能具有默认值
version.information.varies.a.lot.between.operating.systems=版本信息。不同操作系统之间差异很大
void.can.only.be.used.as.return.type=Void 只能用作返回值类型
void.type.cannot.be.nullable=void 类型不能是可为 null
waiting.for.3v4l.org.response=正在等待 3v4l.org 响应…
whether.it.s.a.leap.year.1.or.0=是否为闰年(1 或 0)
whether.or.not.the.date.is.in.daylight.saving.time.1.or.0=日期是否为夏令时(1 或 0)
while=while
with.data.set.0=使用数据集 {1} 的 {0}
working.directory.invalid=找不到工作文件夹 ''{0}''
writing.only.creates.files.if.not.exists.fails.otherwise=只写。如果文件不存在则创建文件，如果找到文件则失败。
writing.only.start.at.the.beginning.of.the.file.and.truncate.the.file.to.zero.length.creates.files.if.not.exists=只写。从文件开头开始，将其截断为零长度。如果文件不存在则创建文件。
writing.only.start.at.the.the.end.of.the.file.creates.files.if.not.exists=只写。从文件末尾开始。如果文件不存在则创建文件。
writing.only.starts.at.the.beginning.of.the.file.creates.files.if.not.exists=只写。从文件开头开始。如果文件不存在则创建文件。
xdebug.cloud.cannot.connect=无法连接到 Xdebug Cloud
xdebug.cloud.cannot.connect.unknown.host=Xdebug Cloud 无法访问\: {0}
xdebug.cloud.cannot.open.new.debug.connection=打不开新的调试连接
xdebug.cloud.cannot.register.cloud.id=无法在 Xdebug Cloud 上注册 Cloud ID
xdebug.cloud.cannot.register.cloud.id.unexpected.response=由于意外响应，无法注册 Cloud ID
xdebug.cloud.validation.cloud.id.not.defined=Cloud ID 未定义
xdebug.cloud.validation.host.not.defined=未定义本地部署 Xdebug Cloud 主机
xdebug.cloud.validation.port.invalid=本地部署 Xdebug Cloud 端口无效
xdebug.compile.task=编译 Xdebug 扩展程序
xdebug.initializing.connection.debugger=调试器
xdebug.initializing.connection.failed.with.timeout=无法连接到 {0}\: 超时
xdebug.initializing.connection.xdebug.cloud=Xdebug Cloud
xdebug.initializing.debugger.connection=正在连接到 {0}…
xdebug.validation.download.script.label=下载脚本命令\:
xdebug.validation.ip.not.found=在自动检测到的 IDE IP 中找不到 {0}
xdebug.validation.ip.not.found.descr=自动检测的 IDE IP\: {0}
years.numeric=年份，数字(1、3)
years.numeric.at.least.2.digits.with.leading.0=年份，数字，至少 2 位数，带前导 0 (01、03)
you.are.configuring.debug.extension.in.the.wrong.php.ini.see.the.loaded.php.ini.files.below=您正在错误的 php.ini 中配置调试扩展(请参见下方已加载的 php.ini 文件)。
you.can.always.add.a.precise.exclusion.via.alt.enter.and.then.edit.it.to.broaden.as.needed=您始终可以通过 Alt-Enter 组合键添加精确排除，然后根据需要对其进行编辑以扩大范围。
you.did.not.reload.web.server.after.changes.in.php.ini.file=在 php.ini 文件中进行更改后，未重新加载 Web 服务器。
zend.debugger.settings.broadcasting.is.already.launched=Zend Debugger 设置广播已启动

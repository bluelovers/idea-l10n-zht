action.ChangePHPInterpreter.text=更改 PHP 解释器
action.ChangePHPInterpreter.description=更改项目 PHP 解释器
action.MessDetectorAddToIgnored.text=添加到 PHPMD 忽略列表
action.MessDetectorAddToIgnored.description=添加到 PHP Mess Detector 忽略列表
action.PhpCSFixerAddToIgnored.text=添加到 PHP CS Fixer 忽略列表
action.PhpCSFixerAddToIgnored.description=添加到 PHP CS Fixer 忽略列表
action.PhpCSAddToIgnored.text=添加到 PHPCS 忽略列表
action.PhpCSAddToIgnored.description=添加到 PHP_CodeSniffer 忽略列表
group.PHPQualityToolsAddToIgnoredList.text=添加到忽略列表…
action.ComposerShowLogAction.text=显示日志
action.ComposerShowLogAction.description=显示包含此 composer.json 的 Composer 操作日志
action.ComposerClearCacheAction.text=清除缓存
action.ComposerClearCacheAction.description=删除 Composer 缓存目录中的所有内容
action.ComposerSelfUpdateAction.text=自我更新
action.ComposerSelfUpdateAction.description=将 Composer 本身更新到最新版本
group.ComposerToolsGroup.text=Composer
action.com.jetbrains.php.composer.ComposerInitSupportAction.text=初始化 Composer…
action.com.jetbrains.php.composer.ComposerInitSupportAction.description=初始化 Composer
group.ComposerGroup.text=Composer
action.ComposerDiagnoseAction.text=诊断
action.ComposerDiagnoseAction.description=检查常见的 Composer 问题
action.ComposerLicensesAction.text=列出许可证
action.ComposerLicensesAction.description=列出安装的每个软件包的名称、版本和许可证
action.ComposerStatusAction.text=检查依赖项中的变更
action.ComposerStatusAction.description=检查任何依赖项中有无本地变更
action.ComposerDryRunUpdate.text=模拟更新
action.ComposerDryRunUpdate.description=模拟更新，但不实际更新
action.ComposerDumpAutoloadAction.text=转储自动加载器…
action.ComposerDumpAutoloadAction.description=重新生成自动加载类的列表
action.ComposerValidateAction.text=验证…
action.ComposerValidateAction.description=检查 composer.json 是否有效
action.ComposerAddDependencyAction.text=管理依赖项…
action.ComposerAddDependencyAction.description=管理 Composer 依赖项
action.ComposerUpdateAction.text=更新
action.ComposerUpdateAction.description=从 Composer.json 安装最新适当版本的软件包
action.ComposerInstallAction.text=安装
action.ComposerInstallAction.description=考虑到 composer.lock，安装 composer.json 中的软件包
action.com.jetbrains.php.internal.PhpViewControlFlowAction.text=当前文件的 PHP 控制流
action.com.jetbrains.php.internal.PhpShowFQNInternalAction.text=显示 PHP FQN
action.ProfilerJumpToSource.text=跳转到源
action.ProfilerJumpToSource.description=跳转到源
action.XdebugAnalyzeProfilerSnapshotAction.text=分析 Xdebug 分析器快照…
group.DBGPProxyGroup.text=DBGp 代理
action.PhpDebuggerCopyType.text=复制类型
action.XDebugger.CopyPath.text=复制路径
action.PhpDetectPsroRoots.text=检测 PSR-0 命名空间根
action.PhpDetectPsroRoots.description=将检测源代码命名空间根
action.PhpListenDebugAction.text=侦听调试连接
action.PhpListenDebugAction.description=侦听调试连接
action.PhpMakeStaticAction.text=设为 static
action.PhpMakeStaticAction.description=将类方法设为 static
action.PhpExtractClassAction.text=提取类…
action.PhpExtractClassAction.description=将元素提取到单独的类

action.PhpNewTest.text=PHP 测试
action.PhpNewTest.description=创建新的 PHP 测试
group.PhpNewTestGroup.text=PHP 测试
action.PhpUnitGenerateTearDownMethod.text=TearDown 方法
action.PhpUnitGenerateTearDownMethod.description=创建 PHPUnit tearDown 方法
action.PhpUnitGenerateSetUpMethod.text=SetUp 方法
action.PhpUnitGenerateSetUpMethod.description=创建 PHPUnit setUp 方法
action.PhpUnitGenerateTestMethod.text=测试方法
action.PhpUnitGenerateTestMethod.description=创建 PHPUnit 测试方法
action.PhpGeneratePhpDocBlocks.text=PHPDoc 块…
action.PhpGeneratePhpDocBlocks.description=为函数、类和字段添加 PHPDoc 块。
action.PhpGenerateSetters.text=Setter…
action.PhpGenerateSetters.description=为 private 类字段创建 setter。
action.PhpGenerateGettersAndSetters.text=Getter 和 Setter…
action.PhpGenerateGettersAndSetters.description=为 private 类字段创建 getter 和 setter。
action.PhpGenerateGetters.text=Getter…
action.PhpGenerateGetters.description=为 private 类字段创建 getter。
action.PhpGenerateConstructor.text=构造函数…
action.PhpGenerateConstructor.description=创建构造函数。

# php colors page elements
color.settings.name=PHP
color.settings.php.scripting=PHP 代码//后台
color.settings.php.tags=PHP 代码//标记
color.settings.keyword=关键字
color.settings.comment=注释
color.settings.number=数字
color.settings.string=字符串//字符
color.settings.escape_sequence=字符串//转义序列
color.settings.operation=大括号和运算符//运算符
color.settings.brackets=大括号和运算符//中括号
color.settings.parentheses=大括号和运算符//圆括号
color.settings.braces=大括号和运算符//大括号
color.settings.bad_character=未知字符
color.settings.comma=大括号和运算符//逗号
color.settings.semicolon=大括号和运算符//分号
color.settings.heredoc_id=Heredoc//Heredoc ID
color.settings.heredoc_content=Heredoc//Heredoc 内容
color.settings.var=标识符//变量
color.settings.var_var=标识符//可变变量
color.settings.this.var=标识符//'$this' 变量
color.settings.identifier=标识符//默认
color.settings.constant=标识符//常量
color.settings.function=函数和方法//声明
color.settings.parameter=函数和方法//形参
color.settings.function.call=函数和方法//函数调用
color.settings.instance.method=函数和方法//实例方法调用
color.settings.instance.protected.method=函数和方法//protected 实例方法调用
color.settings.instance.private.method=函数和方法//private 实例方法调用
color.settings.static.method=函数和方法//static 方法调用
color.settings.magic.member=标识符//魔幻成员访问
color.settings.class=类和属性//类
color.settings.interface=类和属性//接口
color.settings.static.field=类和属性//static 属性
color.settings.instance.field=类和属性//实例属性
color.settings.instance.protected.field=类和属性//protected 实例属性
color.settings.instance.private.field=类和属性//private 实例属性
color.settings.doccomment=PHPDoc//文本
color.settings.doctag=PHPDoc//标记
color.settings.docmarkup=PHPDoc//标记
color.settings.doc.identifier=PHPDoc//标识符
color.settings.doc.parameter=PHPDoc//形参
color.settings.doc.var=PHPDoc//变量
color.settings.doc.method.identifier=PHPDoc//方法声明
color.settings.doc.property.identifier=PHPDoc//属性
color.settings.exec_command=Shell 命令
color.settings.concatenation=字符串//串联
color.settings.predefined.symbols=标识符//预定义符号
color.settings.goto.label=标识符//转到标签
color.settings.alias.reference=标识符//别名引用
color.settings.alias.primitive.type.hint=标识符//基元类型提示
color.settings.named.arguments=命名实参
color.settings.attributes=特性

# annotations
annotation.variable.variable=可变变量
annotation.new.expression.interface=无法实例化接口 ''{0}''
annotation.new.expression.trait=无法实例化特征 ''{0}''
annotation.new.expression.abstract=无法实例化 abstract 类 ''{0}''
annotation.expression.is.not.allowed.as.class.constant.value=表达式不允许为类常量值

#folding
folding.checkbox.collapse.imports=Import
folding.checkbox.collapse.method.body=方法体
folding.checkbox.collapse.function.body=函数体
folding.checkbox.collapse.php.tags=标记
folding.checkbox.collapse.heredocs.and.nowdocs=HEREDOC\\NOWDOC
folding.checkbox.collapse.classes=类主体

#gutter
gutter.overriding.select.title=选择要导航的父方法
gutter.overriden.select.subclass.title=选择 {0} 的子类
gutter.overriden.select.implementation.title=选择 {0} 的实现
#gutter-pinned
gutter.pin.overriding.select.title={0} 的父项
gutter.pin.overriden.select.subclass.title={0} 的实现
gutter.pin.overriden.select.implementation.title={0} 的实现

# inspections
inspection.group=PHP
inspection.group.general=常规
inspection.group.unused=未使用
inspection.group.unused.quickfix.label=未使用的元素
inspection.group.unused.quickfix.message=未使用的元素: ''{0}''
inspection.group.undefined=未定义
inspection.group.control.flow=控制流
inspection.group.php.doc=PHPDoc
inspection.group.probably.bug=可能的错误
inspection.group.type.compatibility=类型兼容性
inspection.group.code.style=代码样式
inspection.group.code.smell=代码异味
inspection.group.naming.convention=命名惯例


inspection.dead.code.problem.empty.constant.synopsis=常量从未使用。
inspection.dead.code.problem.single.constant.synopsis=常量有一个用法，但无法到达。
inspection.dead.code.problem.multiple.constant.synopsis=常量有 {0, choice, 1#1 个用法|2#{0,number} 个用法}，但无法从入口点到达。
inspection.dead.code.problem.empty.function.synopsis=函数从未使用。
inspection.dead.code.problem.recursive.suspicious.function.synopsis=所有函数用法均属于不存在可从入口点到达的成员的调用链。
inspection.dead.code.problem.suspicious.function.synopsis=函数无法从入口点到达。
inspection.dead.code.problem.trait.synopsis=特征从未使用。
inspection.dead.code.problem.class.nousages.synopsis=类从未使用。
inspection.dead.code.problem.trait.additional.unreachable=特征没有可到达用法。
inspection.dead.code.problem.trait.additional.reachable=特征具有可到达用法。
inspection.dead.code.problem.class.abstract.several.implementations={0} 具有{1, choice, 1#直接或间接实现|2# {1,number} 个直接或间接实现}，但<ul><li>其从未实例化或</li><li>不存在可从入口点到达的实例化。</li></ul>

inspection.hierarchyChecks=类层次结构检查
inspection.hierarchyChecks.descr=类必须被声明为 abstract 或实现 {0}
inspection.hierarchyChecks.should.implement=类必须实现 {0}
inspection.hierarchyChecks.field.type.redeclaration.must.not.be.defined=类型不得定义(如基类 ''{0}'' 中)
inspection.hierarchyChecks.field.type.redeclaration.match.super.type=类型必须为 ''{0}''(如基类 ''{1}'' 中)
inspection.wrong_param_type=应为 ''{1}'' 类型的形参，提供的是 ''{0}''
inspection.missing_param=缺少所需形参 ''{0}''
inspection.optional.before.required=可选形参在需要前提供
#inspection -> Super class incompatible with interface
inspection.super.incompatible.with.interface.declaration.must.be.compatible=''{0}'' 的声明必须与 ''{1}'' 兼容

#inspection -> Wrong Exception order
inspection.wrong.exception.order.problem.batch=已捕获异常 '#ref'
inspection.wrong.exception.order.problem.same=已捕获异常 ''{0}''
inspection.wrong.exception.order.problem.super=已捕获异常类 ''{1}'' 的超类 ''{0}''

inspection.wrong.exception.order.fix.move.display.name=将 ''catch'' 子句移动到 ''{0}'' 前
inspection.wrong.exception.order.fix.move.family.name=移动 'catch' 子句
#inspection -> Wrong Exception class
inspection.wrong.exception.type.problem.throw = 已抛出对象必须为 'Exception' 或 'Throwable' 的实例
inspection.wrong.exception.type.problem.catch = 无法捕获非派生自 'Exception' 或 'Throwable' 基类的对象

#inspection -> Assigned value never used
#inspection -> Wrong foreach argument
inspection.wrong.foreach.argument.type.problem.batch=提供给 'foreach' 的无效实参
inspection.wrong.foreach.argument.type.problem=提供给 ''foreach'' 的实参无效。预期类型: ''array'' 或 ''object''，提供的是 ''{0}''。

#inspection -> Redundant PHPDoc
inspection.redundant.phpdoc=冗余 PHPDoc 注释

#inspection -> Unused local variable
inspection.unused.local.variable.problem=未使用的局部变量 ''{0}''。{1}
inspection.unused.local.variable.problem.batch=局部变量 '#ref' 未在任何位置使用
inspection.unused.local.variable.problem.case1=变量的值未在任何位置使用。
inspection.unused.local.variable.problem.case2=变量的值被立即覆盖。
inspection.unused.local.variable.problem.case3=变量中存储的引用未在任何位置使用。
inspection.unused.local.variable.problem.case4=变量中存储的引用被立即覆盖。
inspection.unused.local.variable.option.description.foreach=在 'list()' 中或存在 'foreach' 键时忽略 foreach 值
inspection.unused.local.variable.option.description.list=忽略 'list()' 中的变量
inspection.unused.local.variable.option.description.file.scope=在全局空间中启用检查
inspection.unused.local.variable.option.description.null=忽略 'null' 的赋值
inspection.unused.local.variable.option.indirect.access=忽略通过 'get_defined_vars()' 访问的变量
inspection.unused.local.variable.problem.fix.side.effects.found.dialog.title=发现副作用
inspection.unused.local.variable.problem.fix.side.effects.found.dialog.message=分配给 ''{0}'' 的表达式可能含有副作用。\n\
您可以:\n\
- 完全<b>移除</b>变量赋值\n\
- 将分配的表达式<b>转换</b>成单独的语句

#inspection -> Unused parameter
inspection.unused.parameter.problem=未使用的形参 ''{0}''。{1}
inspection.unused.parameter.problem.case1=形参值未在任何位置使用。
inspection.unused.parameter.problem.case2=形参值被立即覆盖。
inspection.unused.parameter.problem.case3=形参中存储的引用未在任何位置使用。
inspection.unused.parameter.problem.case4=形参中存储的引用被立即覆盖。
inspection.unused.parameter.option.description.empty.body=忽略带有空体的方法/函数的形参
inspection.unused.parameter.option.description.empty.abstract=忽略 abstract 类方法的形参
inspection.unused.parameter.option.description.empty.override=忽略重写方法的形参
inspection.unused.parameter.option.description.empty.anonymous=忽略匿名函数的形参
inspection.unused.parameter.option.description.parameter.count=不报告通过 'func_num_args()' 访问的形参

#inspection -> Unused private method
inspection.unused.private.method.problem.batch=未使用的 private 方法 '#ref'
inspection.unused.private.method.option.ignore.constructor=忽略方法 '__construct' 用法
inspection.unused.private.method.option.ignore.clone=忽略方法 '__clone' 用法

#inspection -> Undefined callback
inspection.undefined.callback.method=在类 ''{1}'' 中未找到方法 ''{0}''
inspection.undefined.callback.field=在类 ''{1}'' 中未找到属性 ''{0}''
inspection.undefined.callback.class=未定义的类 ''{0}''
inspection.undefined.callback.function=未定义的函数 ''{0}''
inspection.undefined.callback.dont.report.exist.checkbox=忽略来自 '*_exists' 和 'is_callable' 函数的回调
inspection.undefined.callback.dont.report.ambiguity.checkbox=不明确时不报告

#inspection -> Missing parent call
inspection.missing.parent.call.message=缺少父方法调用

#inspection -> Missing parent constructor call
inspection.missing.parent.constructor.call.message=缺少父构造函数调用

#inspection - > Undefined variable
inspection.undefined.variable.problem1=未定义的变量 '#ref'
inspection.undefined.variable.problem2=变量 '#ref' 可能未定义
inspection.undefined.variable.option.description.enable.in.file.scope=在全局空间中启用检查
inspection.undefined.variable.option.description.report.can.be.undefined=报告变量可能未定义
inspection.undefined.variable.option.description.ignore.include=在当前文件外搜索变量定义

#inspection -> Wrong String concatenation operator
inspection.wrong.string.concatenation.operator.problem=字符串串联运算符错误
inspection.wrong.string.concatenation.operator.problem.batch=字符串串联运算符错误
inspection.wrong.string.concatenation.operator.option.ignore.magic=忽略通过魔术方法访问的属性

#inspection -> Dynamic method called as static
inspection.dynamic.method.called.as.static.problem=非 static 方法 '#ref' 不应被静态调用
inspection.dynamic.method.called.as.static.problem.magic=非 static 方法 '#ref' 不应被静态调用，但类具有 '__magic' 方法。

#inspection -> Static method called as dynamic
inspection.static.method.called.as.dynamic.problem=static 方法 '#ref' 不应被动态调用
inspection.static.method.called.as.dynamic.problem.magic=static 方法 '#ref' 不应被动态调用，但类具有 '__magic' 方法。

#inspection -> Assignment in condition
inspection.assignment.in.condition=条件中的赋值
inspection.assignment.in.condition.move.assignment.out.of.condition.fix.name=从条件中移出赋值

#inspection -> Division by zero
inspection.division.by.zero=除以零

#inspection -> Dynamic namepsace
#inspection -> Unreachable Statement
inspection.unreachable.statement=不可到达的语句
inspection.unreachable.statement.problem=不可到达的语句

#inspection -> Missing doc comment
inspection.missing.doc.comment.problem=缺少 PHPDoc 注释
inspection.missing.doc.comment.problem.batch={0} 缺少 PHPDoc 注释
inspection.missing.doc.comment.options.panel.constant=常量(&O)
inspection.missing.doc.comment.options.panel.function=函数(&F)
inspection.missing.doc.comment.options.panel.class=类(&C)
inspection.missing.doc.comment.options.panel.method=方法(&M)
inspection.missing.doc.comment.options.panel.field=属性(&P)
inspection.missing.doc.comment.options.panel.class.constant=类常量(&A)

#inspection -> Silly assignment
inspection.silly.assignment.problem=赋值左右两侧相等

#inspection -> Illegal array key type
inspection.illegal.array.key.type.problem=非法数组键类型

#inspection -> Illegal string offset
inspection.illegal.string.offset.problem=非法字符串偏移 {0}

#inspection -> Missing @return tag
inspection.doc.missing.return.tag.problem=函数/方法 PHPDoc 注释中缺少 @return 标记

#inspection -> Doc signature inspection

#inspection -> Missing @throws tag
inspection.doc.throws.problem=PHPDoc 注释不包含所有必需的 @throws 标记
inspection.doc.throws.option.skip.on.empty.phpdoc=忽略没有 @param/@return 的 PHPDoc

#inspection -> Inconsistent return points
inspection.inconsistent.return.points.problem1=缺少 'return' 语句
inspection.inconsistent.return.points.problem1.yield=缺少 'yield' 语句
inspection.inconsistent.return.points.problem2=缺少返回实参
inspection.inconsistent.return.points.option.treat.return=在 'void' 函数/方法中以相同方式对待 'return null' 和 'return'

#inspection -> Redundant closing tag
inspection.redundant.closing.tag.problem=冗余结束标记
inspection.redundant.closing.tag.fix.remove=移除结束标记

#inspection -> Void function result used
inspection.void.function.result.used.problem1=使用了 ''void'' 函数 ''{0}'' 结果
inspection.void.function.result.used.problem2=使用了 ''void'' 方法 ''{0}'' 结果

#inspection -> Expression result unused
inspection.expression.result.unused.problem=表达式结果未在任何位置使用

#inspection -> Missing 'break' statement
inspection.missing.break.statement.problem=缺少 'break' 语句

#inspection -> Nested vs outer 'foreach' variables conflict
inspection.nested.vs.outer.foreach.variables.conflict.problem1=变量 ''{0}'' 作为键用于内部和外部 ''foreach'' 循环
inspection.nested.vs.outer.foreach.variables.conflict.problem2=变量 ''{0}'' 作为值用于内部和外部 ''foreach'' 循环

#inspection -> Foreach array is used as value
inspection.foreach.array.is.used.as.value.problem=变量 ''{0}'' 已用作 ''array expression''

#inspection -> Usage of a silence operator
inspection.usage.of.silence.operator.problem=使用了沉默运算符

#inspection -> Language level
#switch language level quick fix
inspection.language.level.quick.fix.switch.language.level.name.0=切换到 PHP {0} 语言级别

#switch language level in composer file manually quick fix
inspection.language.level.quick.fix.switch.language.level.in.composer.manually.0=手动切换到 composer.json 中的 PHP {0} 语言级别
inspection.language.level.quick.fix.switch.language.level.in.composer.0=切换到 composer.json 中的 PHP {0} 语言级别


inspection.disabled.quality.tool.inspection.fix=启用检查
inspection.disabled.quality.tool.inspection.open.fix=打开检查设置

inspection.disabled.quality.tool.inspection= {0} 检查已禁用

inspection.json.not.installed.packages=未安装软件包
inspection.json.all.not.installed.packages=未安装软件包
inspection.json.not.installed.packages.update.fix=更新所有软件包
inspection.json.not.installed.package.update.fix=更新软件包
inspection.json.not.installed.packages.install.fix=安装软件包
inspection.json.duplicated.packages.0=require 和 require-dev 中存在重复的 ''{0}'' 条目
inspection.json.duplicated.packages.fix=从 require-dev 中移除重复项

#inspection -> Duplicate array keys
inspection.duplicate.array.keys.display.name=重复的数组键
inspection.duplicate.array.keys.problem=重复的数组键
inspection.duplicate.array.keys.problem.0=值为 ''{0}'' 的重复数组键

#inspection -> Duplicate PhpDoc type
inspection.duplicate.phpdoc.type.problem=重复的类型 ''{0}''
inspection.duplicate.phpdoc.type.fix=从标记中移除重复类型

#inspection -> Undefined constant
inspection.undefined.constant.problem1=未定义的常量 '#ref'
inspection.undefined.constant.problem2=常量 '#ref' 可能未定义

#inspection -> Undefined function
inspection.undefined.function.problem1=未定义的函数 '#ref'
inspection.undefined.function.problem2=函数 '#ref' 可能未定义

#inspection -> Undefined property
inspection.undefined.field.problem1=通过魔术方法访问的属性
inspection.undefined.field.problem2=属性动态声明
inspection.undefined.field.notify.access.magic.method=通过魔术方法访问属性的通知
inspection.undefined.field.notify.dynamic.declaration=动态属性声明的通知

#inspection -> Undefined provider
inspection.undefined.phpunit.provider=未定义的 PHPUnit 数据提供程序 ''{0}''

#inspection -> PHPUnit missing target for test
inspection.phpunit.missing.target.element.ref=未找到 '#ref' 的测试目标元素

#inspection -> Covered function reference is provided without '::'
inspection.phpunit.covers.function.without.scope.resolution.operator=提供的覆盖{0}引用没有 ''::''

#inspection -> Deprecated assertEquals/assertNotEquals usage
inspection.phpunit.asserts.assertEquals.parameters.many=可选的 {0} 个形参已弃用
inspection.phpunit.asserts.assertEquals.parameters.single=可选的 {0} 个形参已弃用
inspection.phpunit.asserts.assertEquals.parameters.empty=带有此类形参的调用已弃用

#inspection -> Usage assertCount/assertSameSize methods instead of assertEquals
inspection.phpunit.asserts.assert.with.count.function=可以使用方法 {0} 代替 {1}

#inspection -> Misordered assertEquals/assertNotEquals arguments
inspection.phpunit.asserts.assertEquals.misordered.arguments=顺序错误的 ''{0}()'' 实参

#inspection -> Method assertArrayHasKey/assertArrayNotHasKey can be used instead
inspection.phpunit.asserts.array.has.key.can.be.used.instead=可以改用方法 ''{0}''

#inspection -> Deprecated expectException usage
inspection.phpunit.expectException=对将 expectException() 用于 {0} 的支持已弃用，将在 PHPUnit 10 中移除。请改用 {1}()。

#inspection -> Unnecessary fully qualified name
inspection.unnecessary.qualifier.already.imported.message=限定符不必要，可以移除
inspection.unnecessary.fully.qualified.name.option.enable.file.scope=在文件范围中启用
inspection.unnecessary.fully.qualified.name.option.ignore.global.namespace=忽略全局命名空间

#inspection -> Fully qualified name usage
inspection.fully.qualified.name.usage=限定符可替换为导入
inspection.fully.qualified.name.usage.option.enable.file.scope=在文件范围内启用
inspection.fully.qualified.name.usage.name.option.ignore.global.namespace=忽略全局命名空间

#inspection -> Multiple classes declaration in one file
inspection.multiple.classes.declarations.in.one.file=在此文件中声明了另一个类
#inspection -> Namespace name is not matched with project structure
inspection.illegal.psr.class.path.namespace.name.is.not.matched.to.psr0=命名空间名称与 PSR-0/PSR-4 项目结构不匹配
inspection.illegal.psr.class.path.class.is.not.matched.to.psr0={0}名称与包含文件名不匹配

#inspection -> Traditional Syntax Array Declaration Inspection
inspection.traditional.syntax.array.literal.detected=使用了传统语法数组文字

#inspection -> Too Many Parameters
inspection.too.many.parameters=形参数量超出指定限值
inspection.too.many.parameters.max.number.of.parameters=最大形参数量
inspection.too.many.parameters.ignore.constructors=忽略构造函数

#inspection -> Parameters count mismatch
inspection.method.parameters.count.mismatch=为方法调用提供了 {0} 个形参，但方法签名使用了 {1} 个形参
inspection.method.parameters.count.mismatch.option.ignore.underscore=忽略最后一个形参为 $_ 的函数/方法
inspection.method.parameters.count.mismatch.option.ignore.func.get.arg=忽略带有 func_get_arg/func_get_args 调用的函数/方法

#inspection -> Method __toString is not implemented
inspection.method.to.string.is.not.implemented.strict.mode=检查每种表达式类型是否存在 __toString
inspection.method.to.string.is.not.implemented=没有为类 ''{0}'' 实现方法 ''__toString''

#inspection -> Method or class is not case sensitive
inspection.codeSmell.function.call.is.not.casesensitive=函数/方法调用中的大小写与声明中的大小写不匹配
inspection.codeSmell.class.call.is.not.casesensitive=类用法中的大小写与声明中的大小写不匹配
inspection.codeSmell.namespace.reference.is.not.casesensitive=命名空间引用中的大小写与声明中的大小写不匹配

#inspection -> Method visibility shouldn't be overridden
inspection.codeSmell.overriding.method.visibility.description=方法可见性不应被重写

#inspection -> Usage of a variable variable
inspection.variable.variable=使用了可变变量

#inspection -> Strict type checking rules violation
inspection.strict.type.checking.parameter=应为 ''{0}'' 类型的形参，提供的是 ''{1}''
inspection.strict.type.checking.parameter.batch=形参 '#ref' 类型与声明不兼容
inspection.strict.type.checking.return=返回值必须为 ''{0}'' 类型，返回的是 ''{1}''
inspection.strict.type.checking.return.batch=返回值类型与声明不兼容
inspection.strict.type.checking.option=为所有文件启用
inspection.strict.type.checking.field.assignment=属性必须为 ''{0}'' 类型，提供的是 ''{1}''
inspection.strict.type.checking.field.assignment.multi.resolve=赋值的类型 ''{0}'' 与属性的声明类型不兼容

#inspection -> Incompatible return type
inspection.incompatible.return.type=返回值应为 ''{0}''，返回的是 ''{1}''
inspection.incompatible.return.type.batch=返回值类型与声明不兼容
inspection.incompatible.return.type.strict.type.checking=严格类型检查
#inspection -> Missing strict types declaration
inspection.missing.strict.types.declaration=缺少严格类型声明
inspection.missing.strict.types.declaration.add.declaration=添加严格类型声明

#inspection -> Magic method visibility
inspection.magic.method.visibility.must.be.public=魔术方法 ''{0}'' 必须为 public
inspection.magic.method.visibility.must.be.static=魔术方法 ''{0}'' 必须为 static
inspection.magic.method.visibility.cannot.be.static=魔术方法 ''{0}'' 不能为 static

#inspection -> Naming convention
inspection.naming.convention.problem.descriptor.short={0} 名称 <code>#ref</code> 过短({1} < {2}) #loc
inspection.naming.convention.problem.descriptor.long={0} 名称 <code>#ref</code> 过长({1} > {2}) #loc
inspection.naming.convention.element.descriptor.regexp={0} 名称 <code>#ref</code> 不匹配正则表达式 ''{1}'' #loc
inspection.naming.convention.element.description.class=类
inspection.naming.convention.element.description.method=方法
inspection.naming.convention.element.description.property=属性
inspection.naming.convention.element.description.variable=变量
inspection.naming.convention.element.description.function=函数
inspection.naming.convention.element.description.constant=常量

#inspection -> Replaceable assignment
inspection.assignment.replaceable.with=<code>#ref</code> 可替换为 ''{0}'' #loc

#inspection -> Constructor style
inspection.constructor.style=旧式构造函数

#inspection -> Statement has empty body
inspection.statement.has.empty.body.comments.count.as.content=注释计为内容
inspection.statement.has.empty.body.ignore.empty.while=忽略无主体的 'while' 循环
inspection.statement.has.empty.body.ignore.empty.for=忽略无主体的 'for' 循环

#inspection -> Convert loop to array_map
inspection.loop.can.be.converted.to.arraymap=循环可以转换为 'array_map()' 调用

#inspection -> Convert loop to array_filter
inspection.loop.can.be.converted.to.arrayfilter=循环可以转换为 'array_filter()' 调用

#inspection -> Convert loop to array_fill
inspection.loop.can.be.converted.to.arrayfill=循环可以转换为 'array_fill()' 调用

#inspection -> Convert str_pos to str_contains
inspection.str.functions.strpos.call.can.be.converted.to.strcontains='strpos()' 调用可以转换为 'str_contains()'
inspection.str.functions.substr.call.can.be.converted.to.strstartswith='substr()' 调用可以转换为 'str_starts_with()'
inspection.str.functions.strpos.call.can.be.converted.to.strstartswith='strpos()' 调用可以转换为 'str_starts_with()'
inspection.str.functions.substr.call.can.be.converted.to.strendswith='substr()' 调用可以转换为 'str_ends_with()'
#inspection -> Convert array_map to loop
inspection.arraymap.can.be.converted.to.loop='array_map()' 调用可以转换为循环

#inspection -> Convert array_filter to loop
inspection.arrayfilter.can.be.converted.to.loop='array_filter()' 调用可以转换为循环

#inspection -> Convert array_fill to loop
inspection.arrayfill.can.be.converted.to.loop='array_fill()' 调用可以转换为循环

#inspection -> Ignored class alias declaration
inspection.ignored.class.alias.declaration=忽略了类别名声明

#inspection -> Format function parameters mismatch
inspection.format.function.parameters.mismatch.parameter=形参未映射到任何转换规范
inspection.format.function.parameters.mismatch.conversion.specification=转换规范未映射到任何形参

inspection.export.results.const=常量
inspection.export.results.back.traces=反向跟踪

inspection.unused.symbol.check.fields=属性
inspection.unused.symbol.check.methods=方法
inspection.unused.symbol.check.classes=类
inspection.unused.symbol.check.constants=常量
inspection.unused.symbol.check.anonymous_classes=匿名
inspection.unused.symbol.check.functions=函数
inspection.unused.symbol.check.magic_method=魔术方法
inspection.unused.symbol.export.calls=调用
inspection.unused.symbol.export.call=调用
inspection.unused.symbol.export.label=标签
inspection.unused.symbol.export.reachable_element=可到达
inspection.unused.symbol.export.entry=入口点
inspection.unused.symbol.export.abstract=abstract
inspection.unused.symbol.export.closure=结束
inspection.unused.symbol.export.test_method=测试

inspection.composer.file.reference.problem=路径 ''{0}'' 未找到

#inspection -> Method may be static
inspection.method.may.be.static=方法可以为 'static'

#inspection -> Missing field type
inspection.missing.field.type=缺少属性的类型声明

inspection.unpacked.argument.type.mismatch=仅可解包数组和 Traversable，获得的是{0}

inspection.closure.can.be.converted.to.arrow.function=闭包可以转换为箭头函数

inspection.field.assignment.type.mismatch=类型不兼容: 应为 ''{0}'' 类型的属性，提供的是 ''{1}''
inspection.field.assignment.type.mismatch.multi.resolve=赋值的类型 ''{0}'' 与属性的声明类型不兼容

inspection.duplicate.switch.case.body=''switch'' 中的分支是 ''{0}'' 分支的重复项

inspection.duplicate.match.arm.body=''match'' arm 是 ''{0}'' arm 的重复项

inspection.switch.without.default.case='Switch' 没有默认分支

inspection.doc.field.type.mismatch=属性类型不匹配

inspection.nested.ternary.expression=嵌套三元表达式自 PHP 7.4 已弃用

inspection.statement.without.braces=控制语句主体无大括号
inspection.statement.without.braces.fix.name=将大括号添加到 ''{0}'' 语句

inspection.single.statement.with.braces=单语句主体带大括号
inspection.single.statement.with.braces.fix.name=从 ''{0}'' 语句中移除大括号

inspection.curly.braces.access.syntax.usage=大括号访问语法自 PHP 7.4 已弃用

inspection.expression.have.same.operands=表达式有相同操作数

inspection.deprecated.cast={0} 转换自 PHP {1} 已弃用
inspection.deprecated.implode.usage=带实参(数组，字符串)调用的 {0} 自 PHP 7.4 已弃用

quickfix.replace.curly.braces.with.brackets=将大括号替换为中括号

#quickfix
quickfix.is.not.available.in.dump.mode=在索引更新期间，''{0}'' 快速修复不可用
quickfix.cannot.find.class.reference=无法找到要解析的类引用
quickfix.cannot.find.target.class=无法从引用 ''{0}'' 解析类
quickfix.multiple.target.class.resolve=类 ''{0}'' 有多个声明
quickfix.import.base.no.candidates=无法找到要导入的候选项

#quickfix -> PhpCaseSensitiveQuickFix
quickfix.overriding.method.visibility=移除可见性重写

#quickfix -> PhpMoveClassToCorrespondingDirectoryQuickFix
quickfix.move.class.to.corresponding.directory=移至目录 ''{0}''
quickfix.move.class.to.corresponding.directory.error.file.exists=文件 {0} 已存在
quickfix.move.class.to.corresponding.directory.error.unable.create.directories=无法创建缺少的目录: ''{0}''
quickfix.move.class.to.corresponding.directory.error.unable.move.file=无法将文件移动到目录 ''{0}''

#quick fix for:
quickfix.create.class=创建类
quickfix.failed.to.create.class=无法创建类 ''{0}''

#quic fix for:{PhpConstructorStyleInspection} -> Convert constructor to new style
quickfix.convert.to.new.style.constructor=将构造函数转换为新样式

#quick fix for: {PhpUnderfinedVariableInspection} -> Create parameter
quickfix.create.parameter=创建形参
#quick fix for: {PhpUnderfinedVariableInspection} -> Add to use
quickfix.add.to.use=添加到闭包 'use' 结构

#quickfix -> PhpImportClassQuickFix
quickfix.import.class.name=导入类
quickfix.import.class.popup.title=要导入的类

#quickfix -> PhpImportConstantQuickFix
quickfix.import.constant.name=导入常量
quickfix.import.constant.popup.title=要导入的常量

#quickfix -> PhpImportFunctionQuickFix
quickfix.import.function.name=导入函数
quickfix.import.function.popup.title=要导入的函数

#quickfix -> PhpAddFieldDeclarationQuickFix
#quickfix -> PhpAddMethodDeclarationQuickFix
#quickfix -> MakeCallDynamicQuickFix
quickfix.can.not.find.static.method.reference=无法找到 static 方法引用

#quickfix -> MakeCallStaticQuickFix
quickfix.make.call.static.name=将调用设为 static
quickfix.can.not.find.dynamic.method.reference=无法找到动态方法引用

#quickfix -> PhpAddFunctionFromCallback/PhpAddMethodFromCallback/PhpAddFieldFromCallback
quickfix.create.field.from.callback.name=从回调创建属性
quickfix.create.field.from.callback.invalid.element=无法从回调提取属性名称
quickfix.create.field.from.callback.unresolved.class.ref=无法从回调创建属性。无法解析目标类引用。
quickfix.create.field.from.callback.ambiguity.class.ref=无法从回调创建属性。解析的类引用不明确。
quickfix.create.method.from.callback.name=从回调创建方法
quickfix.create.method.from.callback.invalid.element=无法从回调提取方法名称
quickfix.create.method.from.callback.unresolved.class.ref=无法从回调创建方法。无法解析目标类引用。
quickfix.create.method.from.callback.ambiguity.class.ref=无法从回调创建方法。解析的类引用不明确。
quickfix.create.function.from.callback.family.name=从回调创建函数
quickfix.create.function.from.callback.name=添加函数
quickfix.create.function.from.callback.invalid.element=无法从函数回调提取 FQN
quickfix.create.function.from.callback.another.namespace=无法在 ''{0}'' 命名空间中创建函数

#quickfix -> PhpChangeParameterTypeQuickFix/PhpChangeReturnTypeQuickFix/PhpExtendReturnTypeQuickFix
quickfix.strict.type.checking.change.parameter.type.name=将{0, choice, 1#第 1 个|2#第 2 个|3#第 3 个|4#第 {0,number} 个}形参的类型从 ''{1}'' 更改为 ''{2}''
quickfix.strict.type.checking.change.parameter.type.family=更改形参类型
quickfix.strict.type.checking.change.return.type.name=将返回类型从 ''{0}'' 更改为 ''{1}''
quickfix.strict.type.checking.change.return.type.family=更改返回类型
quickfix.strict.type.checking.extend.return.type.name=将返回类型从 ''{0}'' 扩展为 ''{1}''
quickfix.strict.type.checking.extend.return.type.family=扩展返回类型

#quickfix -> PhpChangeTypeDeclarationQuickFix
quickfix.change.type=更改为 ''{0}''
quickfix.remove.type=移除类型 ''{0}''
quickfix.change.type.declaration.family=更改类型

#quickfix -> PhpCaseSensitiveQuickFix
quickfix.case.sensitive.name=更改 {0} 的大小写以匹配其声明

#quickfix -> Replace assignment with operator assignment
quickfix.replace.assignment.with.operator.assignment.family.name=将赋值替换为运算符赋值
quickfix.replace.assignment.with.operator.assignment.name=将 ''='' 替换为 ''{0}=''

#quickfix -> Replace assignment with prefix expression
quickfix.replace.assignment.with.prefix.expression.family.name=将赋值替换为前缀表达式
quickfix.replace.assignment.operator.with.prefix.expression.family.name=将赋值运算符替换为前缀表达式

quickfix.replace.one.operator.with.another=将 ''{0}'' 替换为 ''{1}''

#quickfix -> Convert loop to array_map
quickfix.convert.loop.to.arraymap=将循环转换为 'array_map()' 调用

#quickfix -> Convert loop to array_filter
quickfix.convert.loop.to.arrayfilter=将循环转换为 'array_filter()' 调用

#quickfix -> Convert loop to array_fill
quickfix.convert.loop.to.arrayfilll=将循环转换为 'array_fill()' 调用

#quickfix -> Convert array_map to loop
quickfix.convert.arraymap.to.loop=将 'array_map()' 调用转换为循环

#quickfix -> Convert array_filter to loop
quickfix.convert.arrayfilter.to.loop=将 'array_filter()' 调用转换为循环

#quickfix -> Convert array_fill to loop
quickfix.convert.arrayfill.to.loop=将 'array_fill()' 调用转换为循环

#quickfix -> PHPUnit create missing target class
quickfix.phpunit.create.target.class.error.filename.exists=存在文件 {0}

#quickfix -> Replace current method with alternative 
quickfix.phpunit.replace.current.method.with.alternative=替换为 ''{0}''

#quickfix -> Drop redundant optional parameters
quickfix.phpunit.drop.redundant.optional.parameters=删除冗余的可选形参

#quickfix -> Flip misordered assertEquals/assertNotEquals arguments
quickfix.phpunit.assert.equals.flip.compared.arguments=翻转比较实参

#quickfix -> Unnecessary qualifier
quickfix.remove.unnecessary.qualifier=移除不必要的限定符
quickfix.remove.unnecessary.qualifier.on.class.name=简化 FQN

#quickfix -> Disable for global namespace
quickfix.disable.inspection.for.global.namespace=为全局命名空间禁用检查

#quickfix -> Make method static
quickfix.make.method.static=设为 'static'

#quickfix -> Change field type
quickfix.change.field.type.to.match.super=更改类型以匹配父项
quickfix.change.field.type.add.inferred.type.family.name=作为属性的类型添加推断的类型
quickfix.change.field.type.add.inferred.type.name=作为属性的类型添加 ''{0}''
quickfix.change.field.type.add.inferred.type.error.read.only=无法修改只读文件 ''{0}''
quickfix.change.field.type.add.inferred.type.error.non.project=无法修改非项目文件 ''{0}''

#quickfix -> Remove redundant PHPDoc
quickfix.remove.phpdoc=移除冗余 PHPDoc 注释

quickfix.remove.phpdoc.signature.tags=移除不必要的 @param 和 @return 标记
quickfix.remove.phpdoc.param.tag=移除 @param 标记
quickfix.remove.phpdoc.return.tag=移除 @return 标记

quickfix.phpdoc.update.type=更新 PHPDoc 类型
quickfix.phpdoc.update.field.type=将属性类型更改为 ''{0}'' 以匹配 PHPDoc 注释

quickfix.replace.nested.ternary.expression=将三元表达式替换为 {0} 关联版本

quickfix.set.inheritance.between.classes=使{0} {1} {2}

quickfix.navigate.to.duplicate.array.key=导航到重复键
quickfix.navigate.to.duplicate.condition=导航到重复条件

#quickfix -> Delete return argument
quickfix.delete.return.argument=删除返回实参

quickfix.remove.default.arm=移除重复的 'default' match arm
#intentions

#intentions Replace ?: expression with If
intention.replace.ternary.expression.with.if=将 '?:' 替换为 if

#intentions Replace If with ?: expression
intention.replace.if.with.ternaryExpression=简化 'if'

#intentions -> Convert To Short Syntax
intention.convert.to.short.syntax=将数组转换为短语法
intention.convert.to.traditional.syntax=将数组转换为传统语法

#intentions -> Convert To Short Syntax (list)
intention.convert.to.short.syntax.list=将列表转换为短语法
intention.convert.to.traditional.syntax.list=将列表转换为传统语法

#intentions -> Declare Field
intention.declare.missing.field=声明属性

#intentions -> Declare Property
intention.declare.missing.property=添加 @property

#intentions -> Flip Binary Expression
intention.flip.binary.expression.family.name=翻转二进制表达式
intention.flip.binary.expression.text1=翻转 ''{0}''
intention.flip.binary.expression.text2=翻转 ''{0}'' (可能更改语义)
intention.flip.binary.expression.text3=翻转 ''{0}'' (更改语义)

#intentions -> Namespace Bracing
intention.namespace.bracing=将命名空间转换为带大括号

#intentions -> Smart Line Split
intention.line.split=在两个字符串和串联中拆分字符串

#intentions -> Split comma-separated values
intention.split.comma.separated.values=将逗号分隔的值拆分为多行
intention.join.comma.separated.values=将逗号分隔的值合并为一行

#intentions -> Swap Call Arguments
intention.swap.call.arguments.family.name=交换调用实参
intention.swap.call.arguments.text1=交换 ''{0}'' 和 ''{1}''

#intention -> Add variable PHPDoc comment
intention.variable.add.phpdoc.comment.family.name=添加 PHPDoc 注释

#intention -> Import class
intention.import.class=作为别名导入类
intention.import.class.alias.name=别名:
intention.import.class.alias.already.exists=已导入具有相同别名的类

#intention -> Simplify FQN
#intention -> Generate PHPDoc
intention.generate.phpdoc=生成 PHPDoc

#intention -> Surround With Call
intention.can.not.find.statement.to.surround=无法找到要环绕的目标语句。
intention.statement.to.surround.failed.message=无法用 ''{0}'' 环绕语句。

#intention -> Replace quotes
intention.replace.quotes=无法替换引号 - 转义符号无效且\\r 不受支持

#intention -> Replace with alias
intention.replace.class.with.alias=替换为别名

#intention -> Inline alias
intention.inline.alias=内联别名

#intention -> Add constructor parameters
intention.add.constructor.parameters=添加构造函数形参
intention.add.constructor.parameters.fields.chooser.dialog.title=选择要在构造函数中初始化的属性

#intention -> Implement the interface
intention.implement.interface=实现接口

intention.merge.condition.with.outer=与外部条件合并

#navigation -> Goto Super Method
navigation.goto.super.method.is.not.available=索引更新期间无法在此处导航

#run and debug
#dbgp debugging protocol
dbgp.invalid.packet=无效数据包

#annotator
annotator.duplicate.use.statement=无法使用 ''{0}''，因为该名称已被使用
annotator.duplicate.default.match.condition=match 表达式只能包含一个 'default' 分支
annotator.unhandled.match.argument=未处理的 'match' 实参
annotator.reserved.class.name=无法使用 ''{0}'' 作为类名，因为该名称已被保留
annotator.invalid.class.name=''{0}'' 是无效的类名
annotator.special.class.name=无法将 {0} 用作 {1}，因为 ''{1}'' 是一个特殊的类名
annotator.cannot.break.continue=无法中断/继续{0}级别
annotator.jump.out.of.finally=不允许跳出 finally 块
php.annotator.expecting.interface=应为接口引用
php.annotator.expecting.class=应为类引用
php.annotator.exchange.extends.implements.keyword=将 ''{0} {2}'' 更改为 ''{1} {2}''
php.annotator.strict.types.first.statement='strict_types' 声明必须是脚本中的第一条语句
php.annotator.strict.types.block.mode='strict_types' 声明不能使用块模式
php.annotator.heredoc.indent.validation.mixed.space.and.tab.characters=结束标识符缩进中混用了空格和制表符字符
php.annotator.heredoc.indent.validation.wrong.content.indent=缩进错误:应与结束标记缩进相同
php.annotator.typed.property.illegal.value=''{0}'' 类型的属性可能没有默认值
php.annotator.typed.property.type.mismatch=默认值只能是 ''{0}'' 类型
php.annotator.typed.property.type.mismatch.fix.nullable=使属性类型可为 null
php.annotator.typed.parameter.type.mismatch.fix.nullable=使形参类型可为 null
php.annotator.typed.property.type.mismatch.fix.change=将属性类型更改为 ''{0}''
php.annotator.typed.parameter.type.mismatch.fix.change=将形参类型更改为 ''{0}''
php.annotator.typed.property.type.mismatch.fix.family=更改属性类型以匹配默认值的类型
php.annotator.typed.parameter.type.mismatch.fix.family=更改形参类型以匹配默认值的类型
php.annotator.typed.property.callable.is.illegal=属性不能有 'callable' 类型
php.annotator.return.type.non.nullable.null.returned=无法返回 'null': 返回类型不可为 null
php.annotator.return.type.make.nullable.fix=使返回类型可为 null
php.annotator.void.function.must.not.return.value=void 函数不得返回值
php.surround.with.if=if

#quality tool
quality.tool.configuration.tool.path.is.empty=所选配置的 {0} 路径为空
quality.tool.configuration.can.not.find.configuration.by.id=按 ID 无法找到 {0} 配置: ''{1}''
quality.tool.configuration.default.interpreter.is.not.found=默认选择 {0} 配置解释器，但未指定解释器
quality.tool.configuration.for.interpreter.is.not.found=找不到解释器的 {0} 配置: ''{1}''
quality.tool.configuration.interpreter.is.undefined={0} 配置的解释器未指定或无效
quality.tool.phpcs.custom.rules.warning=选择 'Custom' 编码标准类型以选择自定义规则集。
quality.tool.phpcs.custom.rules.validation.not.xml=所选规则集不是 XML
guality.tool.configuration.show.ignored.files=显示忽略的文件
quality.tool.phpcs.installed.paths=已安装的标准路径
quality.tool.empty.path.phpcs={0} 的路径为空
quality.tool.phpcbf.location=PHPCBF 位置
quality.tool.phpcbf.location.descr=选择有效的 phpcbf 启动器
quality.tool.phpcbf.settings=PHP Code Beautifier and Fixer 设置
quality.tool.phpcbf.path=phpcbf 路径:
quality.tool.phpcbf.reformat.action=PHP Code Beautifier and Fixer: 修复整个文件
quality.tool.phpcbf.name=PHP Code Beautifier and Fixer
quality.tool.selected.file.is.not.phpcbf=所选文件不是 phpcbf 可执行文件
quality.tool.cs.fixer.custom.rules.warning=选择 'Custom' 类型以选择您的配置。
quality.tool.php_cs.custom.rules.validation.not.php_cs=PHP CS Fixer 不支持所选规则集
quality.tool.php_cs.dir.does.not.contain.custom=此目录不包含任何受支持的文件: {0}
quality.tool.php.dir.does.not.contain=该目录不包含{0}
quality.tool.can.not.determine.version=无法确定工具版本，得到 ‘{0}’
quality.tool.file.not.found=找不到文件。
quality.tool.path.must.not.be.empty=路径不能为空。
quality.tool.can.not.retrieve.standards=无法检索可用规则集，请检查 PHP CS Fixer 工具配置。
quality.tool.phpcs.can.not.retrieve.standards=无法检索可用标准，请检查 PHP_CodeSniffer 工具配置。
quality.tool.stardards.has.been.updated=已安装的规则集列表已更新。
quality.tool.coding.stardards.has.been.updated=已安装的编码标准列表已更新。
quality.tool.cs.fixer.allow.risky.rules=允许为内置规则集设置有风险的规则
quality.tool.cs.fixer.reformat.action=PHP CS Fixer: 修复整个文件
quality.tool.cs.fixer.ruleset=规则集:

quality.tool.phpcs.required.phpcs.version=所需的 PHP_CodeSniffer 版本为 1.5.0 或更高，找到的是 {0}
quality.tool.php.cs.fixer.required.phpcs.version=支持的 PHP CS Fixer 版本为 2.8.0 或更高，找到的是 {0}

quality.tool.label.check.files.with.extensions=检查带扩展名的文件:
quality.tool.label.coding.standard=编码标准:
quality.tool.checkbox.installed.standard.paths=已安装的标准路径:
quality.tool.checkbox.show.sniff.name=显示 sniff 名称
quality.tool.checkbox.show.warning.as=将警告显示为:
quality.tool.label.tool.path=工具路径:
quality.tool.label.tool.process.timeout=工具处理超时，[1...60] 秒:
quality.tool.button.validate=验证
quality.tool.label.validation.label=验证标签
quality.tool.label.custom.rulesets=自定义规则集:
quality.tool.phpcs.label.path.to.ruleset=规则集路径:
quality.tool.label.label=标签
quality.tool.label.configuration=配置:

#phpunit messages
php.unit.local.run.display.name=PHPUnit
php.unit.local.run.description=PHPUnit
php.not.test.method=类 ''{1}'' 中的方法 ''{0}'' 不是测试方法
php.method.not.found=在类 ''{1}'' 中未找到方法 ''{0}''
php.method.name.empty=未指定测试方法
php.unit.radio.button.composite=复合
php.unit.test.runner.options=测试运行程序选项
php.unit.checkbox.use.alternative.patterns.base.path=使用替代模式基路径:
php.unit.optional=可选
php.unit.label.test.file.template=测试文件模板(&T):

choose.php.home=选择 PHP 可执行文件
cleaning.up=正在清理…
this.reassignment.is.not.allowed=不能重新分配 $this
cant.use.temporary.expression.in.write.context=在写上下文中不能使用临时表达式
parsing.error.statement.expected=应为语句
smarty.configurable.title=Smarty
analyzing.php.sdk=正在检查 PHP 安装…
include.path.column.info=路径
working.directory.invalid=找不到工作文件夹 ''{0}''
#control flow
#validation common
validation.file.already.exists.in.dir=名称为“{0}”的文件已存在于“{1}”中
validation.file.already.exists=文件 "{0}" 已存在
validation.file.not.valid.name=“{0}”不是有效的文件名
validation.class.not.valid.name="{0}" 不是有效的类名
validation.namespace.not.valid.name=“{0}”不是有效的命名空间名称
validation.invalid.identifier=“{0}”不是有效的标识符
validation.invalid.identifier.with.no.identifier=插入的标识符无效
validation.invalid.alias=“{0}”不是有效的别名
validation.value.is.not.specified.or.invalid={0} 未指定或无效。
validation.value.path.to.value.should.be.specified={0} 的路径应在 {1} 中指定
validation.value.path.to.value.is.invalid=无法通过 {1} 中提供的路径找到 {0}
validation.value.path.to.value.is.invalid.press.fix.project.configuration=无法通过 {1} 中提供的路径找到 {0}。按“修复”以编辑 {2} 配置。
validation.value.is.not.specified.or.invalid.press.fix.project.configuration={0} 未指定或无效。按“修复”编辑您的项目配置。
validation.value.is.not.specified.press.fix.project.configuration={1} 配置中未指定 {0}。按“修复”以编辑 {1} 配置。
validation.press.fix.to.edit.project.configuration=按“修复”编辑您的项目配置。
validation.value.is.invalid={0} 无效
validation.0.not.found.at.1=在 ''{1}'' 中找不到 ''{0}''
validation.0.is.not.a.directory=''{0}'' 不是目录
validation.0.extension.is.not.installed=未安装 ''{0}'' 扩展
validation.debug.extension.is.updated=调试扩展设置已更新。请重新运行当前配置以使用新值。
validation.0.extension.is.installed.check.configuration.options=已安装 ''{0}'' 扩展。检查配置选项。
validation.no.debug.extension.is.installed=未安装调试扩展。
validation.cannot.parse.value.of.0=无法解析 ''{0}'' 的值
validation.connection.was.not.established=未建立连接。
validation.connection.was.not.established.0=无法使用 ''{0}'' 启动调试器会话
validation.connection.was.not.established.no.debug=未安装调试扩展
validation.connection.was.not.established.update.info=更新解释器信息
validation.connection.was.not.established.validate.installation=验证安装
validation.function.already.exists = 当前命名空间中已定义具有相同名称的函数
validation.namespace.already.exists = {1}中已定义名称为 ''{0}'' 的命名空间
validation.class.already.exists = {0}中已经存在具有相同名称的类
validation.class.cannot.be.overridden = 类“{0}”不能被重写
validation.interface.cannot.be.overridden = 无法实现接口“{0}”
validation.test.no.test.patterns = 未添加任何模式

validation.ssh.remote.debug.support=''{0}'' 扩展不支持通过 ssh 进行远程调试。
validation.ssh.remote.code.coverage.support={0} 扩展不支持通过 ssh 进行代码覆盖
remote.interpreter.path.mappings.validation.title=没有为所选解释器配置路径映射。
remote.interpreter.path.mappings.validation.message=请检查映射是否在 {0} 下正确配置。
remote.interpreter.path.mappings.validation.php.section=<b><i><a href="php_mappings">设置|PHP</a></i></b>
docker.compose.coverage.file.is.not.found=找不到覆盖率文件
docker.compose.coverage.file.failed.to.copy=无法从 Docker 容器复制覆盖率结果
docker.compose.coverage.file.failed.to.extract=无法提取覆盖率结果
docker.compose.radio.button.always.start.a.new.container.docker.compose.run=始终启动一个新容器('Docker-compose run')
docker.compose.radio.button.connect.to.existing.container.docker.compose.exec=连接到现有容器('Docker-compose exec')
docker.compose.failed.to.start.container=启动 docker-compose 服务失败，请在命令行中启动并重试

#errors common
error.template.unable.parse.internal.template=无法解析内部模板 {0}
error.template.unable.create.from.internal.template=无法从内部模板 {0} 创建文件
error.file.unable.create.selected.directory=无法在所选目录中创建文件 {0}
error.cannot.connect.to.0.1=无法连接到 ''{0}'': {1}
error.cannot.connect.to.0=无法连接到 ''{0}''

#messages common
0.completion.shortcut=使用{1}进行{0}补全

#completion
completion.press.again.to.see.more.variants=再次按 {0} 以查看更多变体
completion.press.again.to.see.global.variants=再次按 {0} 以查看全局变体
completion.press.again.to.see.all.classes=再次按 {0} 以查看所有类

#unwrap
unwrap.if=解开 if…
unwrap.while=解开 while...
unwrap.for=解开 for...
unwrap.try=解开 try...
unwrap.else=解开 else...
unwrap.elseif=解开 elseif…
unwrap.dowhile=解开 do-while…
unwrap.foreach=解开 foreach…
unwrap.method=解开 ''{0}''
remove.else=移除 else...


#refactoring
refactoring.common.not.supported.expression.in.scope=当前范围不支持此类表达式的{0}
refactoring.common.not.supported.context=当前上下文不支持{0}
refactoring.common.not.extractable.expression=不支持此类表达式
refactoring.common.fail.to.extract.expression=无法从所选代码段中提取表达式

refactoring.common.ui.target.namespace.label=命名空间(&N):
refactoring.common.ui.target.directory.label=目标目录(&D):
refactoring.common.ui.target.directory.edit = 按 F2 编辑目标目录

refactoring.common.validation.namespace.name=“{0}”不是有效的命名空间名称
refactoring.common.validation.class.psi=无法执行重构: 目标类“{0}”无效
refactoring.common.validation.target.directory.is.not.valid=目录“{0}”的路径无效
refactoring.common.validation.target.directory.not.inside.project=目录“{0}”不在项目内部

refactoring.parameter.reserved.name = 形参名称“{0}”已保留
refactoring.parameter.validation = 形参 {0} 无效
refactoring.parameter.validation.duplicate.parameter=重复的形参名称: {0}
refactoring.parameter.validation.initializer.last=必选形参不能位于可选形参后
refactoring.parameter.validation.variadic.last=只有最后一个形参可以是可变形参
refactoring.parameter.validation.variadic.can.have.default.value=可变形参不能具有默认值
refactoring.parameter.validation.initializer.type=具有类类型提示的形参的默认值只能为 NULL
refactoring.parameter.validation.pass.by.reference=仅变量可通过引用传递
refactoring.parameter.validation.type=形参类型 ''{0}'' 无效
refactoring.parameter.validation.default.value=默认值表达式 ''{0}'' 无效
refactoring.parameter.validation.initializer=初始值设定项 ''{0}'' 无效
refactoring.parameter.validation.no.default.value=应该为形参 ''{0}'' 提供初始值设定项或默认值
refactoring.parameter.validation.name.collision.with.use.list=形参名称 ''{0}'' 无效。''{0}'' 已导入 use 列表
refactoring.returnType.validation.type=返回类型 ''{0}'' 无效

#refactoring - > extract base
refactoring.extract.base.validator.not.valid.identifier=“{0}”不是有效的 PHP 标识符。
refactoring.extract.base.validator.reserved.keyword=“{0}”是保留的 PHP 关键字。
refactoring.extract.base.handler.no.expression.selected=选择不构成正确的表达式
refactoring.extract.base.handler.not.supported.expression=此类表达式不支持{0}
refactoring.extract.base.handler.not.supported.scope=当前范围不支持{0}
refactoring.extract.base.dialog.replace.all.occurrences=替换所有匹配项(找到 {0} 个匹配项)(&A)
#refactoring -> extract class
refactoring.extract.class.extract.to.class=提取到类
refactoring.extract.class.extracting.from.file=正在从文件提取:
refactoring.extract.class.extracting.from.class=正在从类提取:
refactoring.extract.class.dialog.class=类名:
refactoring.extract.class.dialog.generate.accessors=生成访问器
refactoring.extract.class.dialog.members.to.be.extracted=要提取的成员
refactoring.extract.class.error.failed.to.create.file=无法创建文件
refactoring.extract.class.preview=已提取的类预览
refactoring.extract.class.conflicts.extract.class.refactoring.is.not.supported.for.dynamically.declared.properties.usages=动态声明属性用法不支持“提取类”重构
refactoring.extract.class.conflicts.method.0.depends.on.property.1.which.needs.getters.in.2=方法 "{0}" 依赖于属性 "${1}"，需要 "{2}" 中的 getter
refactoring.extract.class.conflicts.method.0.depends.on.property.1.which.needs.setters.in.2=方法 "{0}" 依赖于属性 "${1}"，需要 "{2}" 中的 setter
refactoring.extract.class.conflicts.method.0.depends.on.1.method.2=方法 "{0}" 依赖于 {1} 方法 "{2}"
refactoring.extract.class.conflicts.method.0.depends.on.1.constant.2=方法 "{0}" 依赖于 {1} 常量 "{2}"
refactoring.extract.class.conflicts.unable.to.add.delegate.property.initialization.to.constructor=无法将委托的属性初始化添加到类构造函数
refactoring.extract.class.conflicts.unable.to.add.delegate.property.initialization.to.constructor.trait.constructor.will.be.overridden=无法将委托的属性初始化添加到类构造函数: 特征构造函数将被重写
refactoring.extract.class.conflicts.using.write.access.for.non.public.properties.in.array.destructuring.expressions.is.not.supported.in.extract.class.refactoring=“提取类”重构不支持将写入权限用于数组析构表达式中的非 public 属性
refactoring.extract.class.conflicts.using.write.access.for.non.public.properties.in.multiple.assignment.expressions.in.extract.class.refactoring=“提取类”重构不支持将写入权限用于多个赋值表达式中的非 public 属性
refactoring.extract.class.error.the.selected.function.should.belong.to.project.sources=所选函数必须属于项目源
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.anonymous.functions=匿名函数不支持 Extract Class 重构
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.anonymous.classes=匿名类不支持 Extract Class 重构
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.abstract.methods=抽象方法不支持 Extract Class 重构
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.doc.methods=通过 PHPDoc 定义的魔术方法不支持 Extract Class 重构
refactoring.extract.class.error.extract.class.refactoring.is.not.supported.for.doc.properties=通过 PHPDoc 定义的魔术属性不支持 Extract Class 重构
refactoring.validation.class.error.property.with.name.0.is.already.exists=已存在名称为 "{0}" 的属性

#refactoring -> extract variable
refactoring.extract.variable.name=提取变量
refactoring.extract.variable.conflict.already.exists=范围中已经存在名称为“{0}”的变量。
#refactoring -> extract constant
refactoring.extract.constant.name=提取常量
refactoring.extract.constant.conflict.already.exists=范围中已经存在名称为“{0}”的常量。
refactoring.extract.constant.conflict.exists.in.subclass.with.weaker.access=“{0}”的访问级别必须为“{1}”(如在类“{2}”中)或更弱
refactoring.extract.constant.conflict.exists.in.subclass=“{0}::{1}”将被此常量重写
refactoring.extract.constant.conflict.cannot.override.interface.constant=无法重写接口“{1}”的常量“{0}”
refactoring.extract.constant.unable.to.add.constant.declaration="无法添加常量声明"

#refactoring -> extract field
refactoring.extract.field.name=提取属性
refactoring.extract.field.validator.reserved.field.name=“{0}”是保留的属性名称
refactoring.extract.field.conflict.already.exists=该类中已经存在名称为“{0}”的属性。
refactoring.extract.field.visibility=可见性
refactoring.extract.field.visibility.public=public(&U)
refactoring.extract.field.visibility.protected=protected(&O)
refactoring.extract.field.visibility.private=private(&I)

#refactoring -> extract parameter
refactoring.extract.parameter.name=提取形参

#refactoring -> rename - > element processor
conflict.method.with.same.name.already.exists=此类中已经定义了具有相同名称的方法
conflict.field.with.same.name.already.exists=此类中已经定义了具有相同名称的属性
conflict.class.constant.with.same.name.already.exists=此类中已经定义了具有相同名称的常量
conflict.variable.with.same.name.already.exists=已经定义了具有相同名称的变量
conflict.parameter.with.same.name.already.exists=已经定义了具有相同名称的形参
conflict.tag.name.contains.close.tag=文本包含“{0}”
conflict.use.with.same.name.already.exists=已经定义名称相同的 'Use' 语句
conflict.class.with.same.name.already.exists=已经定义了具有相同名称的类
conflict.function.with.same.name.already.exists=已经定义了具有相同名称的函数
conflict.constant.with.same.name.already.exists=已经定义了具有相同名称的常量
refactoring.rename.search.in.global.scope=在全局范围中搜索

#refactoring -> rename - > automatic renamers
refactoring.rename.automatic.renamer.accessors.name=重命名访问器(&C)
refactoring.rename.automatic.renamer.field.accessors.dialog.title=重命名访问器
refactoring.rename.automatic.renamer.field.accessors.dialog.description=将具有以下名称的属性访问器重命名为:
refactoring.rename.automatic.renamer.field.accessors.entity.name=访问器


refactoring.rename.automatic.renamer.class.name=重命名类(&C)
refactoring.rename.automatic.renamer.class.dialog.title=重命名类
refactoring.rename.automatic.renamer.class.dialog.description=将具有以下名称的类重命名为:
refactoring.rename.automatic.renamer.class.entity.name=类

refactoring.rename.entity.name.inheritor=继承者/文件
refactoring.rename.inheritors.and.related.files.with.the.following.names.to=将具有以下名称的继承者和相关文件重命名为:


#refactoring->inline variable
refactoring.inline.variable.cannot.extract.value=无法提取变量 ''${0}'' 的值
refactoring.inline.cannot.find.variable.to.inline=无法找到要内联的变量
refactoring.inline.variable.no.occurrences=没有匹配项可以被安全地内联

#refactoring->inline function
refactoring.inline.function.title=内联{0}重构
refactoring.inline.function.all.invocations.and.remove.the.method=全部内联并移除{0}(&A)
refactoring.inline.function.all.invocations.keep.the.method=全部内联并保留{0}(&E)
refactoring.inline.function.this.invocation.only.and.keep.the.method=仅内联此调用并保留{0}(&K)
refactoring.inline.function.command=正在内联{0}
refactoring.inline.function.cannot.inline.function.with.global.usage=无法内联{0}和 <code>global</code> 用法
refactoring.inline.function.not.accessible.from.caller.site=无法从调用者站点访问成员引用 <code>{0}</code>
refactoring.inline.function.cannot.parse.function.body=无法解析函数体
refactoring.inline.function.cannot.inline.library.function=无法内联库函数
refactoring.inline.function.only.static.method.is.supported=仅支持 static 方法
refactoring.inline.function.reference.is.recursive=不支持递归调用
refactoring.inline.function.inline.function.refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow=当 return 语句中断执行流程时，不支持内联函数重构
refactoring.inline.function.parent.reference.unresolved=<code>parent</code> 类引用在 {0} 中未解析
refactoring.inline.function.yield.found.in.function.body=在函数体中找到 <code>yield</code> 用法

#refactoring->inline constant
refactoring.inline.constant.name=内联常量
refactoring.inline.constant.command=内联常量
refactoring.inline.constant.this.reference.only=仅内联此引用并保留常量
refactoring.inline.constant.all.references.and.remove=全部内联并移除常量
refactoring.inline.constant.all.references.and.keep=全部内联并保留常量
refactoring.inline.constant.cannot.extract.value=无法提取常量的值
refactoring.inline.constant.is.never.used=常量 {0} 从未使用
refactoring.inline.constant.multiple.declarations=还有其他具有相同名称的常量声明。

#refactoring -> extact method/function
refactoring.extract.method.name=提取函数/方法
refactoring.extract.method.error.selected.block.should.represent.a.set.of.statement.or.an.expression=所选块应代表一组语句或表达式。
refactoring.extract.method.error.a.set.of.statements.should.be.from.the.same.code.block=一组语句应来自同一代码块。
refactoring.extract.method.error.there.are.break.continue.operators.which.can.interrupt.execution=存在会中断执行的 break/continue 运算符。
refactoring.extract.method.error.inconsistent.return.points.in.selected.code.fragment=所选代码段中的返回点不一致。
refactoring.extract.method.tooltip=输入 $name = 'init'
PhpExtractMethodDialog.extract.method=提取方法
PhpExtractMethodDialog.extract.function=提取函数
PhpExtractMethodDialog.visibility=可见性:
PhpExtractMethodDialog.public=public(&B)
PhpExtractMethodDialog.protected=protected(&T)
PhpExtractMethodDialog.private=private(&V)
PhpExtractMethodDialog.method=方法:
PhpExtractMethodDialog.function=函数:
PhpExtractMethodDialog.name=名称(&A):
PhpExtractMethodDialog.declare.static=声明 static(&S)
PhpExtractMethodDialog.generate.php.doc=生成 PhpDoc(&G)
PhpExtractMethodDialog.parameters=形参
PhpExtractMethodDialog.signature.preview=签名预览
PhpExtractMethodDialog.replace.tail.break.continue.with.return=将尾“break/continue”语句替换为“return”语句(&T)
PhpExtractMethodDialog.return.output.through=通过以下方式返回输出变量:
PhpExtractMethodDialog.return.output.through.return=return 语句(&E)
PhpExtractMethodDialog.return.output.through.ref.parameters=通过引用传递的形参(&P)
PhpExtractMethodDialog.transformation.options=转换选项
PhpExtractMethodDialog.output.variables=输出变量
PhpExtractMethodDialog.duplicates.count=检查并替换重复项(找到 {0} 个)
PhpExtractMethodDialog.duplicates.pending=正在搜索重复项…
refactoring.extract.method.from.duplicate.code=从重复的代码中提取方法

#find usages
find.options.include.child.methods.checkbox=包括重写/实现方法(&V)
find.field.accessors.title=搜索访问器
find.field.accessors.text=要搜索 ''{0}'' 的访问器吗?
usages.show.this.self.references=显示 $this/自引用

#refactoring -> change signature
change.signature.find.usages.of.base.interface=类 {1} 的方法 {0}\n\
实现了接口 {2} 的方法。\n\
要{3}基方法吗?
change.signature.find.usages.of.base.class=类 {1} 的方法 {0}\n\
重写了类 {2} 的方法。\n\
要{3}基方法吗?
change.signature.tooltip.parameter=$name = 'init' 或 &...$array = 'init'
change.signature.tooltip.default.value=要在此方法的所有现有调用中使用的值
change.signature.error.wrong.caret.position=文本光标应置于要重构的函数的名称处。
change.signature.usage.view.declarations.header=要重构的函数
change.signature.column.name.parameter=形参:
change.signature.column.type.parameter=类型:
change.signature.initialize.new.parameters=创建并初始化类属性(&I)
change.signature.parameter.may.have.side.effect=用作形参“{1}”的表达式“{0}”可能会有副作用
change.signature.arg.type.miss.argument=应为 ''{0}'' 类型的形参
change.signature.arg.type.incompatible=应为 ''{0}'' 类型的形参，提供的是 ''{1}''
change.signature.visibility.not.accessible=可见性为 {1} 的{0}将无法从{2}访问

#refactoring -> pull up/push down
refactoring.pull.up.class.does.not.have.base.classes.interfaces.in.project.files={0}在项目文件中没有基类/接口
refactoring.pull.up.implement.method = 在实现接口的类中创建方法存根(&S)
refactoring.pull.up.validation.field.into.interface = 无法将属性拉入接口
refactoring.pull.up.validation.static.method.into.interface = {0} 为 static，不能为 abstract。
refactoring.pull.up.private.access = {0} 访问权限将更改为 {1}
refactoring.pull.up.abstract.method = 类 {0} 将被标记为 abstract
refactoring.pull.up.conflict.duplicate.constant = {0} 将与 {1} 中的常量冲突。
refactoring.pull.up.will.not.be.accessible.in.the.target.class={0} 在目标类中将无法访问。
refactoring.pull.up.static.reference.is.not.accessible.in.the.target.class=非 static 方法 {0} 不应在外部类中静态调用
refactoring.pull.up.may.not.be.accessible.in.the.target.class={0} 在目标类中可能无法访问。
refactoring.pull.up.is.1.and.will.not.be.accessible.in.the.target.class={0} 为 private，在目标类中将无法访问。
refactoring.push.down.method.implemented.in.interface={0} 必须被声明为 abstract 或实现 {1}
refactoring.push.down.validation.magic.method=移动魔术方法会产生副作用

#refactoring -> move class
refactoring.move.class.name = 移动类
refactoring.move.class.title = 将类 {0} 移至命名空间(&C):
refactoring.move.class.new.file = 将类提取到单独的文件(&E)
refactoring.move.class.in.non.code.message=注释和字符串中的类引用
refactoring.move.class.cannot.move.anonymous.class=无法移动匿名类

#refactoring -> move namespace
refactoring.move.namespace.name=移动命名空间
refactoring.move.namespace.title=移动命名空间 {0}
refactoring.move.namespace.new.namespace=新命名空间名称(&N):
refactoring.move.related.namespace.description=将具有相关命名空间的文件移至新目录:
refactoring.move.related.namespace.title=移动具有相关命名空间的文件
refactoring.move.related.namespace.name.column=新命名空间名称
refactoring.move.related.namespace.directory.column=新建目录
refactoring.move.related.namespace.collect.title=收集子命名空间
refactoring.move.namespace.header.message=移动命名空间
refactoring.move.namespace.message=要移动的命名空间
refactoring.move.namespace.in.non.code.message=注释和字符串中的命名空间引用

#refactoring -> move member
refactoring.move.method.label.text.field=将成员移至类(&C)
refactoring.move.member.method.is.overridden.in.a.sublclass={0} 在子类 {1} 中被重写
refactoring.move.members.there.are.several.classes.with.specified.name=存在多个具有指定名称 {0} 的类
refactoring.move.members.is.not.a.valid.class.name="{0}" 不是有效的类名
refactoring.move.member.title=移动 static 成员
refactoring.move.member.action.name=移动成员…
refactoring.move.members.to.be.moved=要移至另一个类的成员(&B)
refactoring.move.members.preview.header=要移至另一个类的成员
refactoring.move.members.unable.to.resolve.usage.callback.found=无法解析用法: 发现回调: {0}
refactoring.move.members.unable.to.resolve.usage.late.static.binding.detected=无法解析用法: 检测到延迟 static 绑定: {0}
refactoring.move.members.late.static.binding.detected=检测到延迟 static 绑定: {0}
refactoring.move.members.self.from.anonymous.class=无法处理对匿名类的自引用
refactoring.move.members.late.static.binding.detected.in.doc=在文档中检测到延迟 static 绑定
refactoring.move.members.is.not.accessible={0} 在 {1} 中无法访问
refactoring.move.members.cannot.find.target.class=找不到类 {0}
refactoring.move.members.member.will.change.visibility.to.public=成员 {0} 会将可见性更改为 public
refactoring.move.members.method.implements.abstract.method={0} 在 {1} 中实现 abstract 方法
refactoring.move.members.method.implements.method.in={0} 在 {1} 中实现方法
refactoring.move.members.0.will.be.hidden.in.1=成员 {0} 将在 {1} 中被隐藏
refactoring.move.members.only.constants.can.be.moved.to.interface = 只有常量可以移至接口

#refactoring -> move file constant
refactoring.move.constant.title=移动常量
refactoring.move.constant.label.text.field=将常量 {0} 移至类(&C)
refactoring.move.multiple.constant.label.text.field=将 {0} 个常量移至类(&C)
refactoring.move.constant.unable.to.resolve=无法解析 {0}
refactoring.move.constant.class.already.contains.constant=类 {0} 已包含常量 {1}

#refactoring -> move function
refactoring.move.function.title=移动函数
refactoring.move.function.label.text.field=将函数 {0} 移至类(&C)
refactoring.move.multiple.functions.label.text.field=将 {0} 个函数移至类(&C)
refactoring.move.constant.class.already.contains.method=类 {0} 已包含方法 {1}
refactoring.move.function.interface.cant.contain.method=接口中不允许带有主体的方法

#refactoring -> move instance
refactoring.move.method.cannot.move.constructor=无法移动构造函数
refactoring.move.method.cannot.move.magic.method=无法移动魔术方法
refactoring.move.instance.method=移动实例方法
refactoring.move.instance.method.action.name=移动实例方法…
refactoring.move.instance.method.preview.header=要移至另一个类的方法
refactoring.move.instance.method.this.parameter.label=将替换类 {0} 的 $this 引用的形参名称
refactoring.move.instance.method.usage.will.not.be.accessible=用法 {0} 将无法访问。应提高方法可见性

#refactoring -> make static then move method
refactoring.make.static.then.move.method.select=将方法 ''{0}'' 移至类
refactoring.make.static.then.move.method.message=方法 ''{0}'' 将被设为 ''public static''

#refactoring -> extract interface
refactoring.extract.interface.name=提取接口
refactoring.extract.interface.title=从类 ''{0}'' 提取接口
refactoring.extract.interface.invalid.caret.location=文本光标应置于要重构的类名处。
refactoring.extract.interface.invalide.extract.from.trait=无法从特征提取接口。
refactoring.extract.interface.no.methods=没有要提取到接口的方法。
refactoring.extract.interface.field=接口名称(&I):
refactoring.extract.replace.class.reference=尽可能将类引用替换为接口(&F)
refactoring.extract.interface.members.title=要构成接口的成员(&B)
refactoring.extract.interface.phpdoc.title=PhpDoc
refactoring.extract.interface.phpdoc.do.nothing=保留原样(&A)
refactoring.extract.interface.phpdoc.copy=复制(&C)
refactoring.extract.interface.phpdoc.move=移动(&M)
refactoring.extract.interface.validation.members.modifier=对于每个提取的方法，修饰符将更改为 public。
refactoring.extract.interface.fail.to.create.file=无法创建文件 ''{0}''。

#refactoring -> make method static
refactoring.make.method.static=将方法设为 static
refactoring.make.method.static.method.calls.found.in.static.context=在 static 上下文中找到方法调用
refactoring.make.method.static.method.converts.method.to.static=将方法转换为 static
refactoring.make.method.static.dynamic.method.call.found=实例对象应作为形参传递，找到动态方法调用: {0}
refactoring.make.method.static.this.found=实例对象应作为形参传递，找到 $this
refactoring.make.method.static.references.to.be.changed=待变更引用 {0}
refactoring.make.method.static.doc.method.is.not.supported=不支持文档方法
refactoring.make.method.static.method.is.overridden=方法 {0} 被重写
refactoring.make.method.static.object.is.needed=方法 {0} 使用未作为形参传递的属性 {1}
refactoring.make.method.static.private.field.is.not.accessible=private 属性 {0} 无法从类外部访问
refactoring.make.method.static.protected.field.is.not.accessible=protected 属性 {0} 无法从类及其继承者外部访问
refactoring.make.method.static.writeAccess=检测到 {0} 写入访问，实例对象应作为形参传递。
refactoring.make.method.static.magic.method=魔术方法不能设为 static
refactoring.make.method.static.add.parameters.for.fields=添加属性形参(&P):

#actions
#action -> detect namespace roots
actions.detect.namespace.roots.notification.id=PHP PSR-0 命名空间根检测
actions.detect.namespace.roots.notification.title=检测 PSR-0 命名空间根
actions.detect.namespace.roots.title=正在检测 PSR-0 命名空间根…
actions.detect.namespace.roots.finished=已完成 PSR-0 命名空间根检测。
actions.detect.namespace.roots.no.new.roots.detected=未检测到新的 PSR-0 命名空间根。
actions.detect.namespace.roots.view.configuration=视图配置
actions.detect.namespace.roots.manual.configuration=手动配置
actions.detect.namespace.roots.idea.view.configuration=您可以在 '项目结构 | 模块' 中修改设置。
actions.detect.namespace.roots.from.composer.title=PSR-0/PSR-4 根
actions.detect.namespace.roots.from.composer.idea.title=源根

#action -> detect language level
actions.detect.language.level.loaded.from.composer.title=PHP 语言级别
actions.detect.language.level.loaded.from.composer.idea.title=语言级别

#action --> common settings
actions.detect.common.setting.from.composer.suggest.title=将设置与 Composer 同步?
actions.detect.common.setting.from.composer.enable=启用同步
actions.detect.common.setting.from.composer.disable=不同步
actions.detect.common.settings.updated.from.composer.title={0} 设置已更新
actions.detect.common.settings.composer.sync.state.title=与 composer.json 的同步{0}
actions.detect.common.setting.from.composer.show.settings=显示设置

action.detect.user.settings.state.overwritten=如果打开同步，IDE 设置(PHP 语言级别，PSR-0/PSR-4 根)可能会被覆盖
action.detect.user.settings.state.supported=支持 PSR-0/PSR-4 根和 PHP 语言级别的同步
action.detect.user.settings.state.overwritten.short=设置可能会被覆盖: PSR-0/PSR-4 根和 PHP 语言级别。
action.detect.settings.sync.turned.on.title=已与 composer.json 同步
action.detect.settings.sync.turned.on=PHP 语言级别已与 composer.json 同步
action.detect.composer.json.not.found.title=找不到 composer.json
action.detect.composer.json.not.found=在路径 {0} 下找不到 composer.json
action.detect.composer.json.open=在编辑器中打开

#action -> mark directory as namespace root
actions.mark.directory.as.psr.0.root.title=要将文件夹标记为 {0} 根吗?
actions.mark.directory.as.psr.0.root=<i>{0}</i>
actions.mark.directory.as.psr.0.root.with.prefix=<i>{0}</i>为前缀“{1}”?
actions.mark.directory.as.psr.0.root.mark.psr=标记为 {0} 根

#action - > new php base
actions.new.php.base.dialog.label.file.name=文件名:
actions.new.php.base.dialog.label.extension=文件扩展名:
actions.new.php.base.arrows.extension.tooltip=在编辑器中按向上或向下箭头可更改文件扩展名
actions.new.php.base.arrows.template.tooltip=在编辑器中按向上或向下箭头可更改模板

#action -> new php file
actions.new.php.file.action.name=PHP 文件
actions.new.php.file.action.description=创建新的 PHP 文件
actions.new.php.file.dialog.title=创建新的 PHP 文件

#action -> new php class
actions.new.php.class.action.name=PHP 类
actions.new.php.class.action.description=创建新的 PHP 类
actions.new.php.class.dialog.title=创建新的 PHP 类
actions.new.php.class.dialog.label.class.name=名称:
actions.new.php.class.dialog.label.namespace=命名空间:
actions.new.php.class.dialog.label.directory=目录:
actions.new.php.class.dialog.label.template=模板:
actions.new.php.class.dialog.label.superclasses.container=父类
actions.new.php.class.dialog.label.superclasses.super.fqn=扩展:
actions.new.php.class.dialog.label.superinterfaces.add.interface=添加接口…
actions.new.php.class.dialog.label.superinterfaces.to.implement=实现:
actions.new.php.class.dialog.label.superinterfaces.to.implement.empty=选择要实现的接口
actions.new.php.class.dialog.label.superinterfaces.to.extend.empty=选择要扩展的接口
actions.new.php.class.dialog.border.title.class=类

#action -> new php test
actions.new.test.class.action.name=新建 PHP 测试
actions.new.test.class.action.description=创建新的 PHP 测试
actions.new.test.class.dialog.title=创建新的 PHP 测试
actions.new.test.class.dialog.title.named=为 {0} 创建新的 PHP 测试
actions.new.test.class.dialog.label.name=名称:
actions.new.test.class.dialog.label.namespace=命名空间:
actions.new.test.class.dialog.label.directory=目录:
actions.new.test.class.dialog.label.fqn=完全限定名称:
actions.new.test.class.dialog.border.title.class.to.test=要测试的类(可选)
actions.new.test.class.dialog.border.title.test.class=测试类
actions.new.test.class.dialog.border.title.target.class.file.path=文件路径:
actions.new.test.class.dialog.arrows.libraries.hint=在编辑器中按向上或向下箭头可更改测试库
actions.new.test.class.dialog.select.methods.show.inherited.methods=显示继承的方法(&I)

#action -> new PHPUnit test
actions.new.phpunit.class.action.name=PHPUnit 测试
actions.new.phpunit.class.action.description=创建新的 PHPUnit 测试

#action -> generate php doc
actions.generate.php.doc.is.not.available=PHPDoc 生成在索引更新期间不可用

unnamed.variable=(未命名)
server=服务器
#Connection -> Server Connection
connection.port.is.busy=端口 {0} 繁忙

#Server configuration
debug.server.import.configuration.dialog.title=从部署配置导入
debug.server.import.configuration.preview.border.title=预览
debug.server.import.configuration.path.to.remote.root=部署根的绝对路径(&R):
debug.server.import.configuration.path.to.remote.root.sftp=绝对远程根: ''{0}''
debug.server.import.configuration.path.to.remote.root.sftp.tooltip=远程文件的绝对路径:<br>"远程根的绝对路径" . "根路径" (来自部署设置) . "服务器上的相对部署路径" (来自部署路径映射)
debug.server.import.configuration.path.to.remote.root.mounted=本地: ''{0}'' -> 远程: ''{1}''
debug.server.import.configuration.path.to.remote.root.mounted.label=已挂载文件夹的远程路径(&R):
debug.server.import.configuration.path.to.remote.root.mounted.tooltip=远程文件的绝对路径:<br>"已挂载文件夹的远程路径" . "服务器上的相对部署路径" (来自部署路径映射)
debug.server.import.configuration.deployment=部署(&D):
debug.server.import.configuration.local=本地(&L)
debug.server.import.configuration.mounted=已挂载(&M)

debug.server.import.configuration.local.file.path=本地文件路径:
debug.server.import.configuration.project=项目(&P):
debug.server.import.from.deployment.deployment.configurations.message=找到具有相关路径映射的部署配置。
debug.server.import.from.deployment.no.deployment.configurations.message=找不到合适的部署配置
debug.server.import.from.deployment.no.deployment.configurations.tooltip=配置部署根(如果不为空)
debug.server.import.from.deployment.deployment.root.label=部署根(&R):
debug.server.import.from.deployment.radio=从部署导入映射(&I)
debug.server.manually.select.file.or.project=手动选择本地文件或项目(&M)
debug.server.manually.select.file.message=选择一个项目或文件进行调试
debug.server.select.file.mapping=配置本地文件路径
debug.server.detect.path.mappings.from.deployment.progress=正在为 ''{0}'' 项目分析路径映射
debug.server.detect.path.mappings.from.deployment=正在检测现有路径映射…
debug.server.can.not.detect.path.mappings.from.deployment=无法评估路径映射: 未选择目标部署服务器

#Debug
debug.accept.connection=接受
debug.ignore.connection=忽略
debug.incoming.connection.title.0=来自 {0} 的传入连接
debug.path.on.server=服务器上的绝对路径
debug.error.cannot.modify.value=无法修改值
debug.error.cannot.evaluate.variables=无法评估变量
debug.error.cannot.evaluate.expression0=无法评估表达式 ''{0}''
debug.error.cannot.evaluate.expression=无法评估表达式
debug.process.cannot.find.file.in.project=在项目中找不到路径为 ''{0}'' 的文件
debug.process.cannot.find.server.name=找不到源位置。名称为 ''{0}'' 的服务器不存在。
debug.process.status.disconnected=已断开连接
debug.process.status.wait=正在等待与{0} ''{1}'' 的传入连接
debug.process.status.connected=已连接
debug.process.console.error.format={0}: {1}，{2} 中的第 {3} 行\n\

debug.mapping.resolve.dialog.stop.debugger=停止调试器
debug.zend.error.title.cannot.accept.external.xdebug.connection=无法接受外部 Xdebug 连接
debug.zend.required.protocol.version.0.or.higher=所需协议版本为 ''{0}'' 或更高版本
debug.error.title.cannot.accept.external.0.connection=无法接受外部 {0} 连接
debug.zend.cannot.accept.incoming.connection=无法接受来自 Zend Debugger 的传入连接
debug.zend.debugger.settings.broadcasting=Zend Debugger 设置广播
debug.zend.debugger=Zend 调试器
debug.xdebug=Xdebug
debug.not.installed=<未安装>
debug.process.cannot.find.file.link=更多信息
debug.process.cannot.find.file=在本地找不到文件 ''{0}''。\n\
要修复，请通过环境变量 PHP_IDE_CONFIG 设置服务器名称，然后重新启动调试会话。
debug.process.cannot.find.local.file=在服务器 {0} 上找不到文件的本地副本\n\
本地路径为 {1}
debug.process.cannot.find.path.mapping=远程文件路径 ''{0}'' 未映射到项目中的任何文件路径
debug.process.script.outside.project=脚本 ''{0}'' 在项目外部。
debug.process.cant.compute.source.position=无法计算源位置。脚本 ''{0}'' 未与任何文本文件类型关联。
debug.edit.path.mappings=点击以设置路径映射
debug.configure.servers=配置服务器
debug.settings.broadcasting.port=设置广播端口:
debug.settings.auto.detect.ide.host=自动检测 IDE IP:
debug.debug.port=调试端口:
debug.error=错误
debug.process.cannot.find.remote.copy.local.file=项目 ''{0}'' 中的文件路径未映射到服务器上的任何文件路径
debug.cannot.map.local.file=文件路径未映射到服务器上的任何文件路径。编辑路径映射以解决此问题。
debug.resolve.mapping.problem=解决路径映射问题
debug.cannot.start.listening.for.connections.from.0=无法开始侦听来自 ''{0}'' 的连接
debug.cannot.start=无法启动 ''{0}''
debug.stop.listen.debug.connections=停止侦听 PHP 调试连接
debug.start.listen.debug.connections=开始侦听 PHP 调试连接
debug.breakpoint.was.resolved=此处的调试会话已暂停，因为 ''{0}'' 处的断点已被解析到此位置。<br/>您可以<a href="disable">禁用</a>断点解析或<a href="more">了解详情</a>。<a href="dontshow">不再显示</a>
debug.breakpoint.resolved.disabled=断点解析已被禁用，从下一个调试会话开始将不会解析断点。 您可以稍后在 <a href="open">PHP|调试</a>下将其启用。
debug.breakpoint.resolved.notify.disabled=断点解析通知已被禁用。您可以在 <a href="open">PHP|调试|高级设置</a>下将其启用。
debug.log.invalid.xdebug.message=由于 Xdebug 消息无效，无法在断点处停止。\n\
要解决此问题，请切换到稳定版本的 Xdebug 或使用 'xdebug.remote_log' 选项收集日志并创建错误报告。 
debug.log.stop=停止于 (''{0}'':{1})
debug.log.path.mapping.remote.local=远程: ''{0}'' <-> 本地: ''{1}''
debug.log.path.mapping.remote.extracted=远程: ''{0}'' <-> 提取: ''{1}''
debug.log.stack.frame=框架: {0}:{1}，{2}
debug.log.connection.was.terminated=调试连接在 ''{0}'':''{1}'' 上意外终止
debug.log.cant.register.breakpoint.no.remote=无法注册断点。没有本地路径 ''{0}'' 的路径映射
debug.log.cant.register.breakpoint.no.template.mapping=无法注册断点。没有到 PHP 行 ''{0}'' 的映射
debug.log.exception.break=异常中断: {0} ({1})
debug.file.is.ignored=文件 ''{0}'' 被跳过。
debug.edit.ignored.paths.list=<a href="#a">编辑</a>跳过的路径。
debug.composite.value.presentation=[{0}]
debug.error.unknown.debugger.id=未检测到调试器扩展
debug.error.wrong.debugger.id=不支持 {0}
debug.type.array=数组
debug.type.resource=资源
debug.type.int=int
debug.type.float=浮点
debug.xdebug.error.unsupported.protocol.version=不支持的 Xdebug 协议版本
debug.php.line.breakpoint.title=PHP 行断点
debug.php.exception.breakpoint.title=PHP 异常断点
debug.php.exception.breakpoint.not.supported=加载的调试扩展不支持异常断点
debug.php.exception.breakpoint.zend.not.supported=Zend Debugger 不支持异常断点
debug.php.exception.breakpoint.dialog.title=添加异常断点
debug.php.exception.breakpoint.exception.name=异常名称:
debug.php.method.breakpoint.title=PHP 方法断点
debug.php.method.breakpoint.dialog.title=添加方法断点
debug.php.method.breakpoint.zend.not.supported=Zend Debugger 不支持方法断点
debug.php.breakpoint.failed.to.register=无法注册断点，请尝试将其禁用并重新启用。
debug.error.cannot.parse.ssh.connection=无法从 $_SERVER[''SSH_CONNECTION''] 解析端口: ''{0}''
debug.error.cannot.parse.server.name.for.external.connection=无法为外部 {0} 连接解析服务器名称。
debug.error.cannot.parse.server.name=要修复，请在远程服务器上创建环境变量 <i><b>PHP_IDE_CONFIG</b></i>。<br/><br/><i>Windows:</i> 设置 PHP_IDE_CONFIG="serverName=SomeName"<br/> <i>Linux / Mac OS X:</i> 导出 PHP_IDE_CONFIG="serverName=SomeName"。
debug.error.server.name.is.empty=<i><b>$_SERVER["SERVER_NAME"]</i></b> 为空，这可能是 Web 服务器配置错误所致。<br/><br/><i>Nginx:</i> 将 fastcgi 形参添加至 nginx 配置，<a href="http://wiki.nginx.org/PHPFcgiExample">更多</a><br/><i>Apache:</i> 为当前 VirtualHost 配置 ServerName，<a href="https://httpd.apache.org/docs/2.4/vhosts/name-based.html">更多</a>

debug.php.external.connection.finished.warning.title=调试会话已完成且未暂停
debug.php.external.connection.finished.warning=这可能是由于路径映射配置错误或本地和远程项目未同步。<br/><br/>要找出问题，请在 <b><i><a href="servers">PHP|服务器</a></i></b>下检查 ''{0}'' 服务器的路径映射配置，或启用 <b><i><a href="break">''在 PHP 脚本中的第一行中断''</a></i></b> 选项(位于<i>运行</i>菜单下)。<br/><a href="ignore">不再显示</a>
debug.php.external.connection.finished.break.at.first.line.title=PHP 调试配置
debug.php.external.connection.finished.break.at.first.line=<b><i>'在第一行中断'</i></b> 选项已启用

debug.process.smart.step.into.popup=单步进入函数
debug.process.smart.step.into.function.evaluation.error =无法评估目标函数。将执行“单步跳入”。
debug.process.smart.step.into.function.was.not.executed=尚未调用所选函数。

#rest client
debug.rest.client.error.cannot.evaluate.server.name.title=无法通过服务器名称找到对应的“PHP|服务器”
debug.rest.client.error.cannot.evaluate.server.name=无法评估 '$_SERVER['SERVER_NAME']'。请确保为您的 Web 服务器配置了正确的服务器名称。<br>点击此<a href="help">链接</a>获取更多信息。

# custom actions
debug.function.was.added.to.skip.list=''{0}'' 已添加到跳过列表。
debug.action.copy.as.title=将变量复制为 ''{0}''
debug.action.copy.as.was.fail.can.not.get.full.name=无法将变量复制为 ''{0}''，无法评估完整的变量名
debug.action.copy.value.as.text=将值复制为…

debug.label.select.a.project.or.a.file.to.debug=选择一个项目或文件进行调试
debug.label.select.a.project.to.debug=选择一个项目进行调试
debug.label.file.path.on.server=服务器上的文件路径:
debug.label.file.path.in.project=项目中的文件路径:
debug.checkbox.can.accept.external.connections=可以接受外部连接
debug.checkbox.ignore.z.ray.system.requests=忽略 Z-Ray 系统请求
debug.label.max.simultaneous.connections=最大同时连接数:

# templates
template.debug.path.to.output.folder.descr=指定缓存目录路径
template.debug.path.to.output.folder=缓存目录路径
template.debug.cache.path=缓存路径:
template.debug.cache.dir.is.incorrect=模板调试: 在设置中指定的缓存目录路径无效
template.debug.cache.dir.is.not.specified=模板调试: 未在设置中指定缓存目录路径
template.debug.php.file.not.found=模板调试: 未找到 {0} 的相应 PHP 文件

postfix.template.provider.display.name=PHP

template.smart.completion.function.parameters.description=智能函数形参补全

debug.expression.evaluation.fail=由于返回值未知，无法评估表达式

dbgp.proxy=Xdebug 代理
dbgp.proxy.port=代理端口
dbgp.proxy.host=代理主机
dbgp.proxy.ide.key=IDE 键
dbgp.proxy.ide.register.success=IDE 已成功使用 IDE 键 ''{0}'' 注册
dbgp.proxy.ide.unregister.success=IDE 已成功注销
dbgp.proxy.ide.register.error=无法使用 IDE 键 ''{0}'' 注册 IDE
dbgp.proxy.cannot.connect.to.host=无法连接到主机 ''{0}''
dbgp.proxy.cannot.connect.to.xdebug.proxy=无法连接到 ''{0}:{1}'' 上的 Xdebug 代理
dbgp.proxy.sending.request.to.xdebug.proxy=正在将请求发送到 Xdebug 代理…

profiler.xdebug.task.title=分析 Xdebug 分析器快照
profiler.xdebug.task.parsing=正在解析 ''{0}''
profiler.xdebug.file.chooser.title=选择 Xdebug 分析器快照

profiler.view.execution.statistics.title=执行统计
profiler.view.call.tree.title=调用树
profiler.view.callees.title=被调用方
profiler.view.callers.title=调用方
profiler.column.time.title=时间
profiler.column.memory.title=内存(B)
profiler.column.own.memory.title=自身内存(B)
profiler.column.own.time.title=自用时间
profiler.column.invocation.count.title=调用
profiler.column.invocation.callable=可调用
profiler.column.script=脚本

profiler.measurement.unit.second=秒
profiler.measurement.unit.second.short=秒
profiler.measurement.unit.millisecond=毫秒
profiler.measurement.unit.millisecond.short=毫秒
profiler.measurement.unit.microsecond=微秒
profiler.measurement.unit.microsecond.short=µs
profiler.button.refresh=刷新
profiler.label.time=时间:

#phpunit
php.uml.provider.presentable.name=PHP 类图

#coverage
coverage.is.not.supported.for.selected.run.profile=代码覆盖率与所选运行配置文件不兼容

#UI

#run configurations -> components -> command line
PhpCommandLineConfigurationEditor.interpreter.options.editor.dialog.caption=解释器选项
PhpCommandLineConfigurationEditor.command.line=命令行
PhpCommandLineConfigurationEditor.field.interpreter.options=解释器选项:
PhpCommandLineConfigurationEditor.field.custom.working.directory=自定义工作目录:
PhpCommandLineConfigurationEditor.field.environment.variables=环境变量:

#run configurations -> components -> test runner
PhpUnitTestRunnerConfigurationEditor.test.runner=测试运行程序
PhpUnitTestRunnerConfigurationEditor.scope=测试范围:
PhpUnitTestRunnerConfigurationEditor.scope.directory=目录
PhpUnitTestRunnerConfigurationEditor.scope.class=类
PhpUnitTestRunnerConfigurationEditor.scope.method=方法
PhpUnitTestRunnerConfigurationEditor.scope.xml=在配置文件中定义
PhpUnitTestRunnerConfigurationEditor.field.directory=目录:
PhpUnitTestRunnerConfigurationEditor.field.method=方法:
PhpUnitTestRunnerConfigurationEditor.field.class=类:
PhpUnitTestRunnerConfigurationEditor.field.file=文件:
PhpUnitTestRunnerConfigurationEditor.use.alt.configuration.file=使用替代配置文件(&U):
PhpUnitTestRunnerConfigurationEditor.use.alt.bootstrap.file=使用替代启动文件(&U):
PhpUnitTestRunnerConfigurationEditor.field.test.runner.options=测试运行程序选项(&O):
PhpUnitTestRunnerConfigurationEditor.field.test.runner.coverage.engine=首选覆盖率引擎:
PhpUnitTestRunnerConfigurationEditor.dialog.caption.test.runner.options=测试运行程序选项

# run configurations
PhpScripRunConfigurationEditor.configuration.display.name=PHP 脚本
PhpScripRunConfigurationEditor.configuration.description=PHP 脚本配置
PhpScripRunConfigurationEditor.file=文件:
PhpScripRunConfigurationEditor.arguments=实参:
PhpScripRunConfigurationEditor.arguments.caption=实参

PhpHttpRequestRunConfiguration.configuration.display.name=PHP HTTP 请求
PhpHttpRequestRunConfiguration.configuration.description=HTTP 请求配置
PhpHttpRequestRunConfiguration.error.fetch.result=响应正文不可用
PhpHttpRequestRunConfiguration.error.server.is.not.specified=找不到名称为 ''{0}'' 的远程服务器
PhpHttpRequestRunConfiguration.error.host.is.not.specified=服务器 ''{0}'' 的主机未指定或无效
PhpHttpRequestRunConfiguration.error.url.is.not.specified=URL 未指定或无效: ''{0}''。
PhpHttpRequestRunConfiguration.error.server.configuration=无法执行 HTTP 请求: ''{0}''。请在“PHP|服务器”下检查服务器配置。

RunConfigurationEditor.configuration=配置
RunConfigurationEditor.server=服务器(&S):
RunConfigurationEditor.error.server.is.not.selected=未选择服务器
RunConfigurationEditor.error.server.is.not.exist=名称为 ''{0}'' 的服务器不存在

PhpWebAppRunConfigurationEditor.configuration.display.name=PHP Web 页面
PhpWebAppRunConfigurationEditor.configuration.description=PHP Web 页面配置
PhpWebAppRunConfigurationEditor.startUrl=起始 URL(&U):
PhpWebAppRunConfigurationEditor.browser=浏览器(&B):
PhpWebAppRunConfigurationEditor.malformed.start.url=起始 URL 的格式错误 - {0}

PhpRemoteDebugRunConfigurationEditor.configuration.display.name=PHP 远程调试
PhpRemoteDebugRunConfigurationEditor.configuration.description=PHP 调试配置
PhpRemoteDebugRunConfigurationEditor.server.label=服务器(&E)：
PhpRemoteDebugRunConfigurationEditor.session.id.label=IDE 键(会话 ID)(&K):
PhpRemoteDebugRunConfigurationEditor.auto.config=通过 IDE 键筛选调试连接
PhpRemoteDebugRunConfigurationEditor.session.id.cannot.be.empty=IDE 键(会话 ID)不能为空
PhpRemoteDebugRunConfigurationEditor.zero.configuration.used.title=已开始侦听传入 PHP 调试连接
PhpRemoteDebugRunConfigurationEditor.filter.connections.help.title=高级选项
PhpRemoteDebugRunConfigurationEditor.filter.connections.help=适用于复杂服务器设置，例如同一主机端口上有多个应用程序。<p/>保持未选中状态以自动检测配置，或使用<i>“侦听调试连接”</i>操作。
PhpRemoteDebugRunConfigurationEditor.filter.connections.help.link=阅读更多信息
PhpRemoteDebugRunConfigurationEditor.zero.configuration.used=没有为 <i>''{0}''</i> 运行配置指定<i>服务器</i>，因此 PhpStorm 将侦听所有传入调试连接。<br/>查看<a href="zero_config">零配置调试</a>获取更多信息。<br/><br/>要停止侦听调试连接，请使用<a href="stop">运行|停止侦听 PHP 调试连接</a>。
PhpRemoteDebugRunConfigurationEditor.zero.configuration.is.already.used=“侦听传入调试连接”已启用，不会发生任何变化。<br/>查看<a href="zero_config">零配置调试</a>获取更多信息。<br/><br/>要停止侦听调试连接，请使用<a href="stop">运行|停止侦听 PHP 调试连接</a>。
PhpRemoteDebugRunConfigurationEditor.stop.zero.configuration.title=已停止侦听传入 PHP 调试连接
PhpRemoteDebugRunConfigurationEditor.stop.zero.configuration=PhpStorm 已停止侦听传入调试连接。

PhpBuiltInWebServerRunConfigurationEditor.configuration.display.name=PHP 内置 Web 服务器
PhpBuiltInWebServerRunConfigurationEditor.configuration.description=PHP 内置 Web 服务器配置
PhpBuiltInWebServerRunConfigurationEditor.title=服务器配置
PhpBuiltInWebServerRunConfigurationEditor.host=主机:
PhpBuiltInWebServerRunConfigurationEditor.port=端口:
PhpBuiltInWebServerRunConfigurationEditor.document.root=文档根:
PhpBuiltInWebServerRunConfigurationEditor.use.router.script=使用 router 脚本:

PhpDebugConfigurable.ignore.external.connections.through.unregistered.server.configurations.label=通过未注册的服务器配置忽略外部连接
PhpDebugConfigurable.xdebug.resolve.breakpoints=如果断点在当前行不可用，则解析断点(Xdebug 2.8+)
PhpDebugConfigurable.xdebug.force.break.no.path.mapping=未指定路径映射时，在第一行强制中断
PhpDebugConfigurable.xdebug.force.break.when.outside.project=当脚本在项目外部时，在第一行强制中断
PhpDebugConfigurable.xdebug.debug.port=Xdebug 调试端口
PhpDebugConfigurable.zend.debug.port=Zend Debugger 调试端口
PhpDebugConfigurable.zend.settings.broadcasting.port=Zend Debugger 设置广播端口
PhpDebugConfigurable.zend.settings.ide.hosts=Zend Debugger IDE 主机
PhpDebugConfigurable.zend.settings.ide.hosts.detect=正在检测…
PhpDebugConfigurable.zend.settings.ide.hosts.detect.progress=正在检测 Zend Debugger 的 IP…
PhpDebugConfigurable.xdebug=Xdebug
PhpDebugConfigurable.zend.debugger=Zend 调试器
PhpDebugConfigurable.safe.evaluation.mode=值提示和监视框架下的安全评估模式
PhpDebugConfigurable.import.use.statements=从评估上下文导入命名空间和 'use' 语句
PhpDebugConfigurable.show.array.children.in.repl=在调试控制台中显示数组和对象子级
PhpDebugConfigurable.external.connections=外部连接
PhpDebugConfigurable.pass.required.configuration.options=通过命令行传递所需配置选项(仍需要手动启用调试扩展)
PhpDebugConfigurable.advanced.settings=高级设置
PhpDebugConfigurable.notify.session.stopped.without.pause=在调试会话完成而不暂停时通知
PhpDebugConfigurable.notify.resolved.breakpoint=通知是否将断点解析为另一行(Xdebug 2.8+)
PhpDebugConfigurable.detect.path.mappings.from.deployment=检测部署配置的路径映射
PhpDebugConfigurable.break.at.first.line=在 PHP 脚本中的第一行中断
PhpDebugConfigurable.evaluation=评估
PhpDebugConfigurable.zero.configuration=预配置
PhpDebugConfigurable.zero.configuration.install.debugger.php.instruction=1. 安装
PhpDebugConfigurable.zero.configuration.install.xdebug.php.instruction=Xdebug
PhpDebugConfigurable.zero.configuration.install.php.instruction=或
PhpDebugConfigurable.zero.configuration.install.zend.debugger.php.action=Zend 调试器
PhpDebugConfigurable.zero.configuration.install.zend.debugger.php.instruction=在 Web 服务器上。
PhpDebugConfigurable.zero.configuration.install.php.validate.action=验证
PhpDebugConfigurable.zero.configuration.install.php.validate=Web 服务器上的调试器配置。
PhpDebugConfigurable.zero.configuration.install.toolbar.instruction.label=2. 安装
PhpDebugConfigurable.zero.configuration.install.toolbar.instruction=浏览器工具栏或小书签。
PhpDebugConfigurable.zero.configuration.listen.for.connections=3. 启用 PHP 调试连接侦听:
PhpDebugConfigurable.zero.configuration.start.session=4. 使用工具栏或小书签在浏览器中启动调试会话。
PhpDebugConfigurable.zero.configuration.tutorial=有关更多信息，请参见
PhpDebugConfigurable.zero.configuration.tutorial.action=“零配置调试”教程

PhpDebugConfigurable.zero.configuration.listen.for.connections.action=开始侦听
PhpDebugConfigurable.zero.configuration.stop.listen.for.connections.action=停止侦听
PhpDebugConfigurable.remote.debug.listen.for.connections=3. 启动“PHP 远程调试”运行配置。
PhpDebugConfigurable.web.page.pre.config.title=调试预配置
PhpDebugConfigurable.web.page.listen.for.connections=2. 启动“PHP Web 页面”运行配置。

PhpDebugSkippedPathsConfigurable.display.name=跳过的路径
PhpDebugSkippedPathsConfigurable.notify.about.skipped.files=通知跳过的文件
PhpDebugSkippedPathsConfigurable.column.title=跳过的路径

PhpFrameworksCommonConfigurable.display.name=框架

PhpStepFiltersConfigurable.title.methods=方法
PhpStepFiltersConfigurable.specify.method.name=指定方法名称
PhpStepFiltersConfigurable.add.method=添加方法
PhpStepFiltersConfigurable.skip.magic.methods=跳过魔术方法
PhpStepFiltersConfigurable.skip.constructors=跳过构造函数
PhpStepFiltersConfigurable.skipped.methods=跳过的方法
PhpStepFiltersConfigurable.title.files=文件
PhpStepFiltersConfigurable.skipped.files=跳过的文件
PhpStepFilters.log.frame=框架已被跳过。函数名称: {0}。远程文件 URL: {1}

PhpServerConfigurable.shared=共享(&S)
PhpServerConfigurable.host=主机
PhpServerConfigurable.host.label=主机(&H):
PhpServerConfigurable.port=端口
PhpServerConfigurable.port.label=端口(&P)
PhpServerConfigurable.debugger.label=调试器(&D)

# web server validation for debug
php.web.server.validation.title=验证 Web 服务器上的调试器配置
php.web.server.validation.action.text=Web 服务器调试验证
php.web.server.validation.local.web.server.radio=本地 Web 服务器或共享文件夹(&L)
php.web.server.validation.remote.web.server.radio=远程 Web 服务器(&R)
php.web.server.validation.local.path.to.script=创建验证脚本的路径(&P):
php.web.server.validation.local.path.to.script.tooltip=所选路径应可通过 Web 服务器访问
php.web.server.validation.url.to.validation.script=验证脚本的 URL(&U):
php.web.server.validation.url.to.validation.script.tooltip=所选 Web 路径将用于运行验证脚本
php.web.server.validation.deployment.server=部署服务器(&D):
php.web.server.validation.deployment.server.tooltip=所选服务器会用于将验证脚本部署到远程服务器
php.web.server.validation.process.title=验证 Web 服务器
php.web.server.validation.dialog.validate.button=验证(&V)
php.web.server.validation.chose.path.to.script=选择验证脚本的路径
php.web.server.validation.chose.path.to.script.description=选择本地文件夹以创建验证脚本
php.web.server.validation.invalid.path.to.script=验证目录的路径无效
php.web.server.validation.configure.local=请配置验证脚本的本地和 Web 路径
php.web.server.validation.configure.remote=请配置验证脚本的路径并选择部署服务器
php.web.server.validation.failed.to.find.web.path=请配置验证脚本的 Web 路径
php.web.server.validation.failed.to.find.deployment.settings=无法找到服务器的部署设置
php.web.server.validation.failed.to.map.deployment.folder=请为验证目录配置远程路径映射
php.web.server.validation.failed.to.map.deployment.folder.to.web=请为验证目录配置 Web 路径映射
php.web.server.validation.uploading.validation.script=正在将验证脚本上传至 {0}
php.web.server.validation.failed.to.deploy.validation.script=无法将验证脚本部署到服务器
php.web.server.validation.failed.to.fetch.script.result=无法提取验证脚本的结果
php.web.server.validation.script.result.is.empty=验证脚本的结果为空
php.web.server.validation.script.result.wrong.format=验证脚本的结果具有意外格式
php.web.server.validation.script.local.result.path.mapping.check=请检查是否为 <b>''{0}''</b> 目录正确配置了验证脚本的 Web 路径
php.web.server.validation.script.result.path.mapping.check=请检查是否在部署设置中为 <b>''{0}''</b> 目录正确配置了远程和 Web 路径映射
php.web.server.validation.failed.to.execute.script=指定的 URL 不可到达，原因是: ''{0}''
php.web.server.validation.configuration.files=<b>已加载的 php.ini:</b> {0}
php.web.server.validation.additional.configuration.files=<b>已解析的其他 .ini 文件:</b> {0}
php.web.server.validation.no.configuration.files=找不到 php.ini 文件
php.web.server.validation.server.name=<b>服务器名称:</b> {0}
php.web.server.validation.server.name.is.empty=服务器名称为空
php.web.server.validation.server.name.is.empty.description=服务器名称对于 PhpStorm 中的标识是必要的。<br>请在 Web 服务器配置文件中进行配置。
php.web.server.validation.no.debugger.extension=未加载调试扩展
php.web.server.validation.multi.debugger.extension=Xdebug 和 Zend Debugger 扩展均已加载
php.web.server.validation.multi.debugger.extension.description=只有一个调试器扩展可在 php.ini 中加载。
php.web.server.validation.loaded.debugger.extension=<b>调试器扩展:</b> {0}
php.web.server.validation.xdebug.debugger.host=<b>远程主机:</b> {0}
php.web.server.validation.xdebug.debugger.localhost=尽管服务器主机可能不在本地，但远程主机仍配置为 ''{0}''
php.web.server.validation.xdebug.debugger.host.remote.addr=<br/><br/>在 php.ini 文件中，将 <b>''{0}''</b> 设为 <i>''{1}''</i> 或自 Web 服务器可见的本地机器 IP 地址。
php.web.server.validation.xdebug.debugger.host.description=正在运行调试器<b>客户端</b>的主机。
php.web.server.validation.xdebug.zend.extension.load=Xdebug 必须通过 'zend_extension' 而不是 'extension' 加载
php.web.server.validation.xdebug.zend.extension.load.description=在 php.ini 文件中使用 <b>'zend_extension=path_to_xdebug.so'</b> 行以加载 Xdebug 扩展。
php.web.server.validation.xdebug.port=<b>远程端口:</b> {0}
php.web.server.validation.xdebug.port.require.sudo=<b>远程端口:</b> {0}，需要根权限才能使用
php.web.server.validation.xdebug.port.require.sudo.description=要在 Linux 和 Mac 上使用小于 1024 的端口，必须具有根权限。
php.web.server.validation.xdebug.wrong.port.format=<b>Xdebug 端口无效:</b> ''{0}''
php.web.server.validation.xdebug.wrong.port=Xdebug 端口(''{0}'')与“PHP->调试 IDE”设置(''{1}'')不同
php.web.server.validation.xdebug.wrong.port.description=来自 php.ini (<b>{0}</b>)的 Xdebug 端口应与在 IDE 内(在 <b>PHP->调试</b>下)配置的端口相同。
php.web.server.validation.xdebug.remote.is.not.enable=远程调试未启用
php.web.server.validation.xdebug.remote.is.not.enable.description=将 <b>''{0}''</b> 行添加到 php.ini 文件。
php.web.server.validation.xdebug3.option.in.invalid.mode=''{0}'' 选项设置为 ''{1}''，这对于 xdebug3 是无效模式。
php.web.server.validation.xdebug.remote.autostart.description=调试会话将尝试为每个请求启动。
php.web.server.validation.xdebug3.start.with.request.description=调试会话将尝试根据相应配置自动启动。
php.web.server.validation.xdebug3.option.is.enabled.message=<b>{0}:</b> 选项设置为 ''{1}''。
php.web.server.validation.xdebug.option.is.not.enabled.description=<b>{0}:</b> 选项未启用
php.web.server.validation.xdebug3.start.upon.error.description=调试会话将尝试根据相应配置在错误时自动启动。
php.web.server.validation.xdebug.option.is.enabled=<b>{0}:</b> 选项已启用
php.web.server.validation.xdebug3.discover.client.with.discover.header=根据 <b>$_SERVER[''{0}'']</b> 中的值，Xdebug 将尝试自动连接到客户端。若失败，则以空的 <b>''xdebug.client_discovery_header''</b> 回到 <b>''xdebug.discover_client_host''</b>。
php.web.server.validation.xdebug3.discover.client=根据 <b>$_SERVER['HTTP_X_FORWARDED_FOR']</b> 和 <b>$_SERVER['REMOTE_ADDR']</b> 中的值，Xdebug 将尝试自动连接到客户端。若失败，则回到 <b>'xdebug.client_host'</b>。
php.web.server.validation.xdebug3.discover.client.message=<b>发现客户端主机:</b> xdebug 将尝试自动提取客户端主机。
php.web.server.validation.xdebug.option.is.ignored.description=<b>{0}:</b> 选项将被忽略。
php.web.server.validation.xdebug.remote.mode.jit=<b>远程模式:</b> 'jit'
php.web.server.validation.xdebug.remote.mode.jit.description=调试会话将仅在出现错误后初始化。
php.web.server.validation.xdebug.remote.mode.req=<b>远程模式:</b> 'req'
php.web.server.validation.xdebug.remote.mode.req.description=调试会话将在脚本启动时初始化。
php.web.server.validation.xdebug3.remote.mode.emulation.description=调试会话将在脚本启动时初始化，与 xdebug2 的 <b>remote_mode=''{0}''</b> 相同。
php.web.server.validation.xdebug3.remote.mode.emulation.message=<b>远程模式:</b> xdebug2 的 ''{0}'' 已模拟。 
php.web.server.validation.xdebug3.cloud.xdebug.doesnt.accept.connections.message=Xdebug 现在不接受外部连接
php.web.server.validation.xdebug3.cloud.xdebug.wrong.cloud.id.message=<b>IDE 中的云 ID:</b> 与服务器上的云 ID 不同
php.web.server.validation.xdebug3.cloud.xdebug.wrong.cloud.id.description=<b>IDE 中的云 ID:</b> {0}<br><b>服务器上的云 ID:</b> {1}
php.web.server.validation.xdebug3.cloud.xdebug.disabled.message=<b>通过 Xdebug Cloud 连接:</b> 已禁用。请在 IDE 设置中进行启用: <b>PHP->调试->XDebug Cloud</b>
php.web.server.validation.xdebug3.cloud.php.ini.xdebug.disabled.message=<b>Php.ini 云调试:</b> 已禁用。
php.web.server.validation.xdebug3.cloud.xdebug.correct.cloud.id.message=<b>IDE 中的云 ID:</b> 与服务器上的云 ID 相同
php.web.server.validation.xdebug.mode.is.not.supported=不支持远程模式 ''{0}''
php.web.server.validation.xdebug.remote.log=<b>{0}:</b> {1}
php.web.server.validation.xdebug.protocol.is.not.supported=不支持调试协议 ''{0}''
php.web.server.validation.zend.debugger.host=<b>远程主机:</b> {0}
php.web.server.validation.zend.debugger.localhost=尽管服务器不在本地，但调试会话仅适用于本地主机。
php.web.server.validation.zend.debugger.localhost.description=将正在运行调试器<b>客户端</b>的主机添加至 <b>'zend_debugger.allow_hosts'</b> 选项。
php.web.server.validation.zend.debugger.deny.host=<b>拒绝主机:</b> {0}
php.web.server.validation.zend.debugger.deny.host.description=无法使用拒绝主机从客户端进行调试。
php.web.server.validation.zend.expose.remotely=<b>属性 ''expose_remotely''</b> 设为 ''{0}''
php.web.server.validation.zend.expose.remotely.allowed.hosts.description=调试器会话将尝试从 <b>'zend_debugger.allow_hosts'</b> 选项为主机启动。
php.web.server.validation.zend.expose.remotely.always.description=调试器会话将尝试为每个客户端启动。
php.web.server.validation.zend.expose.remotely.never.description=调试器会话将不会进行初始化，<b>'zend_debugger.allow_hosts'</b> 选项将被忽略。<br>将选项 <b>'zend_debugger.expose_remotely'</b> 设置为 'allowed_hosts' 或 'always' 以启用 Web 服务器调试。
php.web.server.validation.reference.to.documentation=请参阅<a href="{0}">{0}</a>获取更多信息。

PhpPathMappingsConfigurable.use.path.mappings.label=使用路径映射(选择服务器是远程服务器还是使用符号链接)

PhpMappingSimpleResolveDialog.title=为服务器上的文件路径选择本地文件

DBGPProxyConfigurable.display.name=DBGp 代理
DBGPProxyConfigurable.ide.key=IDE 键:
DBGPProxyConfigurable.host=主机:
DBGPProxyConfigurable.port=端口:

xdebug.initializing.debugger.connection=正在连接到 {0}…
xdebug.initializing.connection.failed.with.timeout=无法连接到 {0}: 超时
xdebug.initializing.connection.debugger=调试器
xdebug.initializing.connection.xdebug.cloud=Xdebug Cloud

XdebugCloudConfigurable.display.name=Xdebug Cloud
XdebugCloudConfigurable.connect.via.xdebug.cloud=连接到 Xdebug Cloud
XdebugCloudConfigurable.cloud.id=Cloud ID:
XdebugCloudConfigurable.custom.server=连接到本地部署 Xdebug Cloud
XdebugCloudConfigurable.base.host=Cloud 主机:
XdebugCloudConfigurable.port=Cloud 端口:

xdebug.cloud.validation.cloud.id.not.defined=Cloud ID 未定义
xdebug.cloud.validation.host.not.defined=未定义本地部署 Xdebug Cloud 主机
xdebug.cloud.validation.port.invalid=本地部署 Xdebug Cloud 端口无效

xdebug.cloud.cannot.connect=无法连接到 Xdebug Cloud
xdebug.cloud.cannot.connect.unknown.host=Xdebug Cloud 无法访问: {0}
xdebug.cloud.cannot.register.cloud.id=无法在 Xdebug Cloud 上注册 Cloud ID
xdebug.cloud.cannot.register.cloud.id.unexpected.response=由于意外响应，无法注册 Cloud ID
xdebug.cloud.cannot.open.new.debug.connection=打不开新的调试连接

PhpIncomingLocalConnectionDialog.file.path=文件路径:

PhpIncomingConnectionDialog.server.name=服务器名称:
PhpIncomingConnectionDialog.server.port=服务器端口:
PhpIncomingConnectionDialog.request.uri=请求 URI:
PhpIncomingConnectionDialog.file.path.on.server=服务器上的文件路径:

PhpInterpreter.php.sdk.type=PHP 解释器
PhpInterpreter.php.dependent.configuration.exists.title=PHP 解释器依赖配置
PhpInterpreter.php.dependent.configuration.exists=所选 PHP 解释器有{0}配置。确定要删除此解释器吗?
PhpInterpreter.php.home.path.label=PHP 可执行文件:
PhpInterpreter.php.debugger.label=调试器:
PhpInterpreter.php.general.title=常规
PhpInterpreter.configuration.in.project.settings.title=PHP 解释器配置
PhpInterpreter.configuration.in.project.settings.message=无法将 PHP 解释器指定为默认 SDK。您可以在“设置| PHP”中为当前项目配置
PhpInterpreter.configuration.duplicate.interpreter.name=找到了具有非唯一名称 ''{0}'' 的 PHP 解释器。
PhpInterpreter.configuration.selection.list.title=选择 CLI 解释器
PhpInterpreter.configuration.interpreter.is.invalid=启用“PHP Remote Interpreters”插件以编辑解释器。
PhpInterpreterConfigurable.configuration.title=其他
PhpInterpreterConfigurable.reload.phpinfo=重新加载 phpinfo
PhpInterpreterConfigurable.show.phpinfo=显示 phpinfo
PhpInterpreterConfigurable.updated.phpinfo=已成功更新 phpinfo
PhpInterpreterConfigurable.can.not.updated.phpinfo=无法更新 phpinfo
PhpInterpreterConfigurable.php.version=PHP 版本: {0}
PhpInterpreterConfigurable.not.installed=未安装
PhpInterpreterConfigurable.configuration.project.level=仅对此项目可见
PhpInterpreterConfigurable.configuration.project.tooltip=检查是否不想在项目之间共享解释器
PhpInterpreterConfigurable.configuration.default.project.tooltip=无法仅为默认项目保存解释器。
PhpInterpreterConfigurable.debugger.extension.label=调试器扩展:
PhpInterpreterConfigurable.debugger.extension.title=选择调试器扩展路径
PhpInterpreterConfigurable.debugger.extension.description=将仅为从 CLI 运行配置启动的调试会话加载调试器扩展
PhpInterpreterConfigurable.configuration.options.table.empty.text=为 php.ini 中允许的任何配置指令设置自定义值
PhpInterpreterConfigurable.configuration.options.with.empty.name.are.not.allowed=不允许名称为空的配置选项
PhpInterpreterConfigurable.configuration.options.dialog.caption=配置选项
PhpInterpreterConfigurable.configuration.options.label=配置选项:
PhpInterpreterConfigurable.configuration.options.table.name=配置指令
PhpInterpreterConfigurable.configuration.options.table.value=值
PhpInterpreterConfigurable.configuration.options.description=这些选项将使用 '-d' 命令行选项传递
PhpInterpreterConfigurable.configuration.file.path=配置文件: {0}
PhpInterpreterConfigurable.configuration.file.path.not.found=配置 php.ini 文件不存在
PhpInterpreterConfigurable.configuration.file.evaluate.dir=正在评估配置文件目录…
PhpInterpreterConfigurable.configuration.file.fix.title=配置 php.ini 文件不存在
PhpInterpreterConfigurable.configuration.file.hhvm.fix=在 <b>/etc/hhvm</b> 目录中创建 php.ini 文件，<br><br>点击此<a href="http://docs.hhvm.com/manual/en/configuration.file.php">>链接</a>获取更多信息。
PhpInterpreterConfigurable.configuration.file.fix=在 {0} 目录中创建 php.ini 文件，<br><br>配置文件模板可在 php 根文件夹中找到:<br>“php.ini-development”- 默认设置<br>“php.ini-production”- 推荐设置。<br>
PhpInterpreterConfigurable.configuration.file.fix.failed.to.detect=使用“{0} --ini”命令确定配置文件目录。<br>
PhpInterpreterConfigurable.configuration.file.fix.link=<br>点击此<a href="http://php.net/manual/en/configuration.file.php">链接</a>获取更多信息。
PhpInterpreterConfigurable.configuration.file.can.not.find.title=无法找到配置文件
PhpInterpreterConfigurable.configuration.file.can.not.find=无法通过路径找到文件: ''{0}''
php.info.parse.exception=无法解析 php 信息: {0} 是空的
PhpInterpreterConfigurable.update.helpers.title=正在更新帮助程序目录…
PhpInterpreter.php.interpreter.name.conflict.title=解释器名称冲突
PhpInterpreter.php.interpreter.name.conflict=发现项目级和应用程序级解释程序名称存在冲突。为解决该问题，以下项目级解释器被重命名:
remote.interpreter.browse.action.is.not.supported.for.docker=基于 Docker 的远程解释器不支持浏览操作
php.interpreter.info.failed.to.parse.validation.script=无法解析验证脚本输出

php.interpreter.base.configuration.interpreter.is.invalid=无法运行 {0}，因为 {1} 配置的解释器无效。
php.interpreter.base.configuration.is.not.provided.or.empty={1} 的 {0} 路径未配置。您可以在“PHP|{0}”下进行修复
php.interpreter.base.configuration.working.directory=无法检测工作目录，请在运行配置中进行配置。
php.interpreter.base.configuration.fix.interpreter={0}。要修复，请<a href=''{1}''>更改</a>项目解释器或<a href=''{2}''>检查</a>设置。

PhpProjectConfigurable.language.level=PHP 语言级别:
PhpProjectConfigurable.interpreter=CLI 解释器:
PhpProjectConfigurable.include.path=Include 路径
PhpProjectConfigurable.0.interpreter.include.path=''{0}'' 解释器 include 路径
PhpProjectConfigurable.specify.other=指定其他…
PhpProjectConfigurable.all=所有
PhpProjectConfigurable.provide.include.path=提供 include 路径
PhpProjectConfigurable.docker.default.project.error.tooltip=打开或创建项目以配置 Docker 容器
PhpProjectConfigurable.php.runtime=PHP 运行时
PhpProjectConfigurable.advanced.settings=高级设置(&V)
PhpProjectConfigurable.default.stubs.path=默认存根路径(&D):
PhpProjectConfigurable.select.default.stubs.path.title=选择默认存根路径
PhpProjectConfigurable.select.default.stubs.path.description=选择默认存根路径
PhpProjectConfigurable.analysis=分析
PhpProjectConfigurable.exception.analysis=异常分析
PhpProjectConfigurable.exception.analysis.depth=调用树分析路径:
PhpProjectConfigurable.exception.analysis.unchecked.exceptions=未检查的异常
PhpProjectConfigurable.analysis.custom.format.functions=自定义格式函数
PhpProjectConfigurable.include.analysis=Include 分析
PhpProjectConfigurable.select.document.root.path.title=选择 $_SERVER['DOCUMENT_ROOT'] 路径
PhpProjectConfigurable.select.document.root.path.description=选择 $_SERVER['DOCUMENT_ROOT'] 路径

custom.format.functions.dialog.validation.class.not.found=找不到类 {0}
custom.format.functions.dialog.validation.function.not.found=找不到函数 {0}
custom.format.functions.dialog.validation.method.not.found=在 {1} 中找不到方法 {0}
custom.format.functions.dialog.validation.format.index=索引必须为非负数
custom.format.functions.dialog.format.index.title=格式字符串模板的索引
custom.format.functions.dialog.class.placeholder=留空以添加纯函数

PhpUnitConfigurableForm.phpunit.library=PHPUnit 库
PhpUnitConfigurableForm.use.custom.loader=使用 Composer 自动加载器
PhpUnitConfigurableForm.custom.loader.is.empty=自动加载器文件的路径为空
PhpUnitConfigurableForm.can.not.find.custom.loader=在 ''{0}'' 下找不到自动加载器脚本
PhpUnitConfigurableForm.phpunit.phar.is.empty=phpunit.phar 路径为空
PhpUnitConfigurableForm.can.not.find.phpunit.phar=在 ''{0}'' 下找不到 phpunit.phar
PhpUnitConfigurableForm.custom.loader.is.directory=自动加载器不应为目录，对于默认 Composer 配置，将路径设置为“vendor/autoload.php”
PhpUnitConfigurableForm.download.phpunit.phar.link.text=从 {0} 下载 phpunit.phar
PhpUnitConfigurableForm.path.to.script=脚本路径:
PhpUnitConfigurableForm.path.to.phpunit.phar=phpunit.phar 路径
PhpUnitConfigurableForm.test.runner=测试运行程序
PhpUnitConfigurableForm.use.configuration.file=默认配置文件:
PhpUnitConfigurableForm.use.bootstrap.file=默认启动文件:
PhpUnitConfigurableForm.use.configuration.file.validation.warning=为 ''{0}'' 提供配置文件的路径，或禁用“默认配置文件”选项
PhpUnitConfigurableForm.use.bootstrap.file.validation.warning=为 ''{0}'' 提供启动文件的路径，或禁用“默认启动文件”选项

phpunit.config.label=测试根
phpunit.config.directory.label=目录:
phpunit.config.empty.pattern=空模式
phpunit.getting.phpunit.version=正在更新 PhpUnit 版本…
phpunit.not.tests.was.executed.title=未配置 PHPUnit
phpunit.not.tests.was.executed.message=要修复，为 <i>{0}</i> <a href="config">配置</a>自动加载文件或 PHPUnit phar 路径。
phpunit.can.not.rerun.failed.tests.title=无法执行失败的 PHPUnit 测试。
frameworks.settings.none.installed=<html>没有可用的框架设置提供程序。<br/>考虑安装 Drupal Support、Joomla! Support 或 WordPress Support 插件。</html>
framework.composer.packages.were.changed.0.test.config.title=Composer 软件包已被更改
framework.composer.packages.were.changed.0.test.config.popup={0} 配置已根据 composer.json 更新

PhpUnitConfiguration.interpreter.conflict=发现应用程序级 PHPUnit 配置冲突。为解决该问题，创建了以下配置的项目级副本:
PhpUnitConfiguration.interpreter.conflict.title=PHPUnit 配置冲突

# php test framework
php.test.framework.select.type.of.settings.popup.title=选择配置类型
php.test.framework.configuration.ui.library={0} 库
php.test.framework.configuration.ui.test.runner=测试运行程序
php.test.framework.configuration.ui.path.to.exe={0} 可执行文件路径:
php.test.framework.configuration.ui.use.configuration.file=默认配置文件:
php.test.framework.download.hyperlink={0} 版本: <a href={1}>{1}</a>
php.test.framework.configuration.ui.version={0} 版本: {1}
php.test.framework.configuration.ui.not.installed=未安装
php.test.framework.configuration.ui.select.interpreter=请选择 PHP 解释器以加载 {0} 版本
php.test.framework.configuration.ui.select.local.interpreter=请选择本地 PHP 解释器以加载 {0} 版本
php.test.framework.configuration.updated.version=已成功更新 {0} 版本
php.test.framework.configuration.can.not.update=无法更新 {0} 版本
php.test.framework.default.interpreter.is.not.local=无法检测到 {0} 版本。默认 PHP 解释器不是本地解释器

php.test.framework.version.getting.version.title=正在获取 {0} 版本…
php.test.framework.version.path.to.exe.is.invalid={0} 可执行文件的路径为空或无效。
php.test.framework.version.detector.empty.output=''{0}'' 命令输出为空。
php.test.framework.version.configuration.ui.can.not.parse.version=无法解析版本命令输出。\n\
{0}

php.test.framework.by.sdk.new.settings.dialog.title=通过远程解释器{0}
php.test.framework.by.sdk.dialog.label=解释器(&I):
php.test.framework.by.sdk.settings.select.server=选择远程解释器以配置远程{0}
php.test.framework.by.sdk.settings.already.exist=所选解释器的 {0} 设置已存在
php.test.framework.by.sdk.settings.remote.path.title=选择服务器上的路径

php.test.framework.run.configuration.ui.scope=测试范围:
php.test.framework.run.configuration.ui.type.radio.button=类型(&T)
php.test.framework.run.configuration.ui.directory.radio.button=目录 (&D)
php.test.framework.run.configuration.ui.file.radio.button=文件(&F)
php.test.framework.run.configuration.ui.scenario.radio.button=方法(&M)
php.test.framework.run.configuration.ui.configuration.radio.button=在配置文件中定义(&C)
php.test.framework.run.configuration.ui.type.combo.box=类型:
php.test.framework.run.configuration.ui.directory.text.field=目录:
php.test.framework.run.configuration.ui.file.text.field=文件:
php.test.framework.run.configuration.ui.scenario.text.field=方法:
php.test.framework.run.configuration.ui.alternative.configuration.file=使用替代配置文件(&U):
php.test.framework.run.confuguration.ui.dialog.caption.test.runner.options=测试运行程序选项
php.test.framework.field.test.runner.options=测试运行程序选项(&O):
php.test.framework.run.configuration.ui.custom.file.radio.button=在 {0} 中定义
php.test.framework.run.configuration.ui.alternative.custom.file=使用替代 {0}(&U)
php.test.framework.settings.is.not.provided.or.empty={1} 的 {0} 路径未配置。按“修复”以编辑您的 {0} 配置。

php.test.framework.interpreter.conflict=发现应用程序级 {0} 配置冲突。为解决该问题，创建了以下配置的项目级副本:
php.test.framework.interpreter.conflict.title={0} 配置冲突
php.test.framework.project.level=(当前项目)
php.test.framework.no.configuration.types.are.available=没有可用的其他配置类型

# validation
php.test.framework.validation.run.configuration.no.type=如果未选择类型则无法运行测试。
php.test.framework.validation.run.configuration.unsupported.type=无法通过 ''{0}'' 命令运行测试。
php.test.framework.validation.run.configuration.working.directory=目录应该是工作目录的子文件夹: ''{0}''
php.test.framework.validation.run.configuration.file.working.directory=文件应该是工作目录的子项: ''{0}''
php.test.framework.validation.run.configuration.method=在 ''{1}'' 中找不到 ''{0}''

php.executable.macro.description=项目设置中配置的 Php 可执行文件
inspection.undefined.class.ignore.phpdoc=忽略 PHPDoc

inspection.missing.ext.composer.json=composer.json 中缺少 ''{0}''
inspection.ext.is.specified.in.require.dev.but.used.outside.tests=''{0}'' 在 ''require-dev'' 部分中指定，但在测试外部使用
inspection.ext.is.specified.in.suggest=''{0}'' 在 ''suggest'' 中指定，可能不可用
inspection.missing.ext.require.bundled=需要 PHP 捆绑的扩展
add.to.composer.json.quick.fix=向 composer.json 中添加 ''{0}''

configure.php.include.paths=配置 PHP Include 路径(&O)…

interpreter=解释器

XdebugShowUserDefinedConstantsToggleAction.text=显示用户定义的常量
XdebugShowUserDefinedConstantsToggleAction.description=将其禁用会停止获取用户定义的常量信息并提高调试器性能
XdebugAddMethodToSkipListToggleAction.text=将方法添加到跳过列表
PhpDebugHideEmptySuperGlobalsToggleAction.text=显示空的超全局变量
PhpDebugBreakAtFirstLineToggleAction.text=在 PHP 脚本中的第一行中断
PhpUserDefinedConstantsGroup.name=常量

PhpLanguageLevel.5.3.0.presentable.name=5.3
PhpLanguageLevel.5.3.0.short.description=命名空间，闭包
PhpLanguageLevel.5.4.0.presentable.name=5.4
PhpLanguageLevel.5.4.0.short.description=特征，短数组语法
PhpLanguageLevel.5.5.0.presentable.name=5.5
PhpLanguageLevel.5.5.0.short.description=finally，生成器
PhpLanguageLevel.5.6.0.presentable.name=5.6
PhpLanguageLevel.5.6.0.short.description=可变函数，实参解包
PhpLanguageLevel.7.0.0.presentable.name=7.0
PhpLanguageLevel.7.0.0.short.description=返回类型，标量类型提示
PhpLanguageLevel.7.1.0.presentable.name=7.1
PhpLanguageLevel.7.1.0.short.description=常量可见性，可为 null，多个异常
PhpLanguageLevel.7.2.0.presentable.name=7.2
PhpLanguageLevel.7.2.0.short.description=对象类型提示，abstract 函数重写
PhpLanguageLevel.7.3.0.presentable.name=7.3
PhpLanguageLevel.7.3.0.short.description=列表赋值中的引用，灵活的 heredoc
PhpLanguageLevel.7.4.0.presentable.name=7.4
PhpLanguageLevel.7.4.0.short.description=类型属性，短闭包，null 合并运算符
PhpLanguageLevel.8.0.0.presentable.name=8.0
PhpLanguageLevel.8.0.0.short.description=联合类型，命名实参，特性，match 表达式

PhpLanguageFeature.traits.not.supported=从 PHP 5.4 起才允许使用特征
PhpLanguageFeature.short.array.syntax.not.supported=从 PHP 5.4 起才允许使用短数组语法
PhpLanguageFeature.array.dereferencing.not.supported=从 PHP 5.4 起才允许对调用进行数组解引用
PhpLanguageFeature.class.member.access.on.instantiation.not.supported=从 PHP 5.4 起才允许对实例化进行类成员访问
PhpLanguageFeature.this.in.closure.not.supported=从 PHP 5.4 起才允许在闭包中使用 $this
PhpLanguageFeature.self.in.closure.not.supported=从 PHP 5.4 起才允许在闭包中使用 self
PhpLanguageFeature.parent.in.closure.not.supported=从 PHP 5.4 起才允许在闭包中使用 parent
PhpLanguageFeature.static.in.closure.not.supported=从 PHP 5.4 起才允许在闭包中使用 static
PhpLanguageFeature.binary.literal.not.supported=从 PHP 5.4 起才允许使用二进制文字
PhpLanguageFeature.literal.in.static.call.not.supported=从 PHP 5.4 起才允许在 static 调用中使用文字
PhpLanguageFeature.built.in.web.server=内置 Web 服务器仅自 PHP 5.4 起可用
PhpLanguageFeature.var.break.argument.not.supported=PHP 5.4 不再支持具有非常量操作数的 'break' 运算符
PhpLanguageFeature.var.break.zero.argument.not.supported=自 PHP 5.4 起，'break' 运算符仅接受正数
PhpLanguageFeature.var.continue.not.supported=PHP 5.4 不再支持具有非常量操作数的 'continue' 运算符
PhpLanguageFeature.var.continue.zero.not.supported=自 PHP 5.4 起，'continue' 运算符仅接受正数
PhpLanguageFeature.call.time.pass.by.reference.not.supported=调用时通过引用传递在 PHP 5.4 中已被移除

PhpLanguageFeature.finally.not.supported=从 PHP 5.5 起才允许使用 'Finally' 子句
PhpLanguageFeature.generators.not.supported=从 PHP 5.5 起才允许使用生成器
PhpLanguageFeature.foreach.list.not.supported=从 PHP 5.5 起才允许在 foreach 中使用列表
PhpLanguageFeature.empty.any.expression.not.supported=从 PHP 5.5 起才允许在 'empty' 中使用任意表达式
PhpLanguageFeature.immediate.dereferencing.not.supported=从 PHP 5.5 起才允许直接解引用
PhpLanguageFeature.class.name.const.not.supported=从 PHP 5.5 起才允许使用类名常量

PhpLanguageFeature.constant.scalar.expressions=从 PHP 5.6 起才允许使用常量标量表达式
PhpLanguageFeature.variadic.functions=从 PHP 5.6 起才允许使用可变函数
PhpLanguageFeature.argument.unpacking=从 PHP 5.6 起才允许使用实参解包
PhpLanguageFeature.exponentiation=从 PHP 5.6 起才允许使用求幂
PhpLanguageFeature.use.function.and.const=从 PHP 5.6 起才允许 use function 和 use const

PhpLanguageFeature.return.types=从 PHP 7.0 起才允许使用返回类型声明
PhpLanguageFeature.scalar.type.hints=从 PHP 7.0 起才允许使用标量类型提示
PhpLanguageFeature.spaceship.operator=从 PHP 7.0 起才允许使用宇宙飞船运算符
PhpLanguageFeature.coalesce.operator=从 PHP 7.0 起才允许使用合并运算符
PhpLanguageFeature.grouped.use=从 PHP 7.0 起才允许分组 use 声明
PhpLanguageFeature.keyword.names=在 PHP 7.0 中关键字可用作名称
PhpLanguageFeature.uniform.variable.syntax=从 PHP 7.0 起才允许统一变量语法
PhpLanguageFeature.anonymous.classes=从 PHP 7.0 起才允许使用匿名类

PhpLanguageFeature.return.void=从 PHP 7.1 起才允许使用返回类型 'void'
PhpLanguageFeature.nullables=从 PHP 7.1 起才允许可为 null
PhpLanguageFeature.iterable.type.hint=从 PHP 7.1 起才允许迭代类型提示
PhpLanguageFeature.catch.multiple=从 PHP 7.1 起才允许捕获多条语句
PhpLanguageFeature.class.constant.visibility=从 PHP 7.1 起才允许类常量可见性
PhpLanguageFeature.list.keys=从 PHP 7.1 起才允许列表解包中的密钥
PhpLanguageFeature.list.assign=从 PHP 7.1 起才允许列表解包中的 []
PhpLanguageFeature.negative.numeric.indices=从 PHP 7.1 起才允许负数值索引

PhpLanguageFeature.object.type.hint=从 PHP 7.2 起才允许对象类型提示
PhpLanguageFeature.abstract.function.override=从 PHP 7.2 起才允许抽象函数重写

PhpLanguageFeature.literal.in.instanceof=从 PHP 7.3 起才允许将文字作为第一个操作数
PhpLanguageFeature.references.in.list=从 PHP 7.3 起才允许在 [] 和 list() 赋值中使用引用
PhpLanguageFeature.trailing.comma.in.function.calls=从 PHP 7.3 起才允许在函数调用中使用尾随逗号
PhpLanguageFeature.trailing.comma.in.parameter.list=从 PHP 8.0 起才允许在形参列表中使用尾随逗号
PhpLanguageFeature.trailing.comma.in.closure.use.list=只有 PHP 8.0 支持在闭包 use 列表中使用尾随逗号
PhpLanguageFeature.flexible.heredocs=灵活的 heredoc/nowdoc 语法

PhpLanguageFeature.typed.properties=从 PHP 7.4 起才允许使用类型化属性
PhpLanguageFeature.spread.operator.in.array=从 PHP 7.4 起才允许在数组中使用展开运算符
PhpLanguageFeature.coalesce.assign=从 PHP 7.4 起才允许使用 '??='
PhpLanguageFeature.arrow.function=从 PHP 7.4 起才允许箭头函数语法
PhpLanguageFeature.numeric.literals.separators=从 PHP 7.4 起才允许使用数值文字分隔符
PhpLanguageFeature.exception.throw.from.toString=从 PHP 7.4 起才允许从 ''__toString'' 抛出异常，''{0}.__toString'' 可能会抛出异常

PhpLanguageFeature.union.types=从 PHP 8.0 起才允许联合类型
PhpLanguageFeature.namespaced.name.as.single.token=从 PHP 8.0 起才允许关键字作为命名空间的一部分
PhpLanguageFeature.nullsafe.dereferencing=从 PHP 8.0 起才允许 Nullsafe 运算符
PhpLanguageFeature.abstract.private.trait.methods=从 PHP 8.0 起才允许使用 abstract private 特征方法
PhpLanguageFeature.mixed.type.hint=从 PHP 8.0 起才允许 'mixed' 类型提示
PhpLanguageFeature.static.type.hint=从 PHP 8.0 起才允许 'static' 返回类型声明
PhpLanguageFeature.named.arguments=从 PHP 8.0 起才允许使用命名实参
PhpLanguageFeature.match.expression=从 PHP 8.0 起才允许匹配表达式
PhpLanguageFeature.throw.expression=从 PHP 8.0 起才允许使用 throw 表达式
PhpLanguageFeature.non.capturing.catches=从 PHP 8.0 起才允许捕捉异常而又不将异常捕获到变量中
PhpLanguageFeature.class.name.literal.on.object=从 PHP 8.0 起才允许在对象上使用 '::class'
PhpLanguageFeature.attributes=从 PHP 8.0 起才允许使用特性
PhpLanguageFeature.property.promotion=从 PHP 8.0 起才允许构造函数属性提升

#Empty project generation
php.empty.project.generator.name=PHP 空项目
php.empty.project.generator.description=为 PHP 创建空项目

#UML
error.cant.create.edge=无法创建关系链接
relationship.already.exists={0}和{1}之间的关系已存在
this.will.remove.relationship.link.between.classes=这将移除类之间的关系链接并修改类 {0}。继续？
remove.relationship.link=移除关系链接
final.class.cant.be.inherited=类 {0} 为 final
node.is.interface=接口只能继承一个接口
inspection.undefined.member.downgrade=如果类中存在 __magic 方法则降级严重性(&D)

#Phar
phar.include.into.project.action.title=将 phar 包含到项目中
phar.exclude.from.project.action.title=从项目中排除 phar
phar.exclude.or.include.into.project.action.title=在项目中包含或排除 Phar
phar.failed.to.parse=无法解析
filetype.phar.description=Php Phar
filetype.phar.display.name=Php Phar

#Composer

framework.composer.name.composer=Composer
framework.composer.path.dialog.path.to.composer=Composer 路径
framework.composer.path.dialog.path.to.composer.json=composer.json 路径
framework.composer.path.dialog.specify.composer.phar=指定 Composer phar:
framework.composer.path.dialog.specify.composer.executable=指定 Composer 可执行文件:
framework.composer.path.dialog.specify.composer.json=指定 composer.json:
framework.composer.configurable.title=Composer
framework.composer.init.dialog.title.composer.settings=Composer 设置
framework.composer.file.0.is.not.found=找不到文件 ''{0}''。

framework.composer.add.dependency.task.title=添加依赖项
framework.composer.add.dependency.install.button=安装
framework.composer.add.dependency.update.button=更新
framework.composer.add.dependency.close.button=关闭(&C)
framework.composer.failed.to.0=无法{0}。
framework.composer.0.1.version.2={0} {1}，版本 {2}
framework.composer.add.dependency.show.output=显示输出
framework.composer.add.dependency.hide.tooltip=隐藏
framework.composer.add.dependency.successfully.installed.0.version.1=已成功安装 {0}，版本 {1}。
framework.composer.add.dependency.running=正在运行
framework.composer.add.composer.dependency.title=管理 Composer 依赖项
frameworks.composer.could.not.get.packages.info.0=无法获取软件包信息。{0}
frameworks.composer.could.not.get.package.info=无法获取软件包信息。
framework.composer.label.version.to.install=要安装的版本(&V):
framework.composer.empty.package.name.in.0={0} 中的软件包名称为空
framework.composer.no.package.versions.in.0={0} 中没有软件包版本
framework.composer.expected.name.0.versions.0.description.got.1=应为 <name> {0} <versions> {0} <description>，获得的是 {1}
framework.composer.add.dependency.available.packages.label=可用软件包
framework.composer.package.default.version=<默认>
framework.composer.add.dependency.no.package.selected=未选择软件包
framework.composer.add.dependency.no.such.package=packagist 上无此类软件包
framework.composer.path.form.execution.validation.wrapper=<html>执行未设置。<br/>{0}</html>
framework.composer.path.form.empty.path.to.composer.phar=composer.phar 路径为空
framework.composer.path.form.empty.path.to.composer.executable=Composer 可执行文件路径为空
framework.composer.project.generator.name=Composer 软件包项目
framework.composer.project.generator.description=通过 Composer 命令创建项目。
framework.composer.failed.to.download.composer.phar=无法下载 composer-stable.phar
framework.composer.project.generator.failed.to.copy.temp.directory.0.content.to.project.root=无法将临时目录 ''{0}'' 内容复制到项目根
framework.composer.project.generation.error.title=无法创建 Composer 项目
framework.composer.project.generator.notification.content.failed.to.find=无法找到 {0}
framework.composer.project.generator.notification.content.failed.to.find.composer.json=无法在项目根中找到 composer.json
framework.composer=Composer
framework.composer.create.project.progress.title=创建项目
framework.composer.create.project.from=自以下创建项目
framework.composer.install.action.name=安装
framework.composer.path.validation.0.is.a.directory={0} 是目录
framework.composer.path.form.empty.path.to.composer.json=composer.json 路径为空
framework.composer.vendors.library.name=Composer 供应商
framework.composer.selected.file.is.not.composer.json=所选文件不是 composer.json
framework.composer.notification.title.init.composer=初始化 Composer
framework.composer.file.0.set.as.composer.config.change.setting.a.href.here.a=文件 ''{0}'' 设置为 Composer 配置。
framework.composer.failed.to.parse.package.names=无法解析软件包名称。
framework.composer.failed.to.load.package.names=无法加载软件包名称。
framework.composer.failed.to.parse.package.description=无法解析软件包描述。
framework.composer.add.dependency.no.version.selected=未选择版本
framework.composer.add.dependency.settings.cl.dialog.title=形参
framework.composer.add.dependency.settings.cl.label=命令行形参(&P):
framework.composer.add.dependency.settings.interpreter.label=PHP 解释器:
framework.composer.add.dependency.settings.title=设置(&S)
framework.composer.no.description.available=无可用描述。
framework.composer.packages.were.moved.to.0.php.include.paths.popup=Composer 软件包已从 Composer 外部库移至 PHP include 路径。
framework.composer.packages.were.changed.0.excluded.folders.popup=Composer 软件包已更改，因此更新了排除的文件夹。
framework.composer.packages.were.changed.0.php.include.paths.popup=Composer 软件包已更改，因此更新了 PHP include 路径。
framework.composer.packages.were.removed.0.excluded.folders.popup=Composer 软件包已从排除的文件夹中移除。
framework.composer.packages.were.removed.0.php.include.paths.popup=Composer 软件包已从 PHP include 路径中移除。
framework.composer.packages.were.added.0.excluded.folders.popup=Composer 软件包已被添加到排除的文件夹中。
framework.composer.packages.were.added.0.php.include.paths.popup=Composer 软件包已被添加到 PHP include 路径中。
framework.composer.failed.to.0.1.script.was.cancelled=无法{0} {1}。脚本已被取消。
framework.composer.add.dependency.successfully.updated.0=已成功更新 {0}。
framework.composer.add.dependency.no.new.version.found.for.0=找不到 {0} 的新版本。
framework.composer.add.dependency.successfully.removed.0=已成功移除 {0}。
framework.composer.updating.package.task.title=更新软件包
framework.composer.removing.package.task.title=移除软件包
framework.composer.update.action.name=更新
framework.composer.remove.action.name=移除
framework.composer.self.update.action.name=自我更新
framework.composer.label.installed.version=已安装的版本:
framework.composer.path.to.php.executable.titled=PHP 可执行文件的路径
framework.composer.specify.php.executable.0=指定 PHP 可执行文件 {0}
framework.composer.empty.path.to.0={0} 的路径为空
framework.composer.default.project.interpreter=默认项目解释器
framework.composer.default.interpreter.is.not.configured=尚未为此项目配置默认解释器。
framework.composer.default.interpreter.for.this.project.is.remote=此项目的默认解释器是远程解释器，无法使用。
framework.composer.default.composer.interpreter.name=Composer 的解释器
framework.composer.interpreters.combo.default.interpreter=< 默认解释器 >
framework.composer.interpreters.combo.default.project.interpreter=< 默认项目解释器 >
framework.composer.interpreters.combo.no.default.interpreter=默认设置中没有默认解释器
framework.composer.interpreters.combo.no.default.interpreter.in.project=此项目中没有默认解释器
framework.composer.interpreters.combo.default.interpreter.no.php.path=默认解释器未提供 PHP 路径
framework.composer.initialize.popup=找到了 Composer 配置文件 {0}。项目设置与其同步。
framework.composer.install.task.title=正在安装软件包
framework.composer.update.task.title=更新软件包
framework.composer.self.update.task.title=更新 Composer
framework.composer.script.run.configuration.name=Composer 脚本
framework.composer.script.run.configuration.description=Composer 脚本运行配置
framework.composer.run.path.to.composer.json=composer.json 路径:
framework.composer.run.script=脚本:
framework.composer.run.script.missing=未指定 Composer 脚本
framework.composer.available.version=可用版本:
framework.composer.package.version.available.0={0}的更新
framework.composer.failed.check.for.update=无法运行 'update --dry-run' 命令。
framework.composer.checking.for.update=正在检查更新…
framework.composer.loading.packages=正在加载 Composer 软件包
framework.composer.loading.package.description=正在加载软件包描述
framework.composer.load.update.availability=检查可用软件包更新
framework.composer.loading.update.availability=正在检查 Composer 软件包更新

# Guzzle
guzzle.name=Guzzle
guzzle.http.request.gutter.name=Guzzle HTTP 请求
guzzle.open.http.request=在 HTTP 请求编辑器中打开
guzzle.unable.to.add.new.request.to.file=无法向 ''{0}'' 文件添加新请求
guzzle.invalid.http.request.file=文件 ''{0}'' 是无效的 HTTP 请求文件
guzzle.unable.to.extract.request.parameters=无法提取请求形参
http.client.request.init.debug.connection.title=正在初始化调试连接

php.interpreter.not.configured.title=未配置 PHP 解释器
php.interpreter.not.configured=请<a href="">配置 PHP 解释器</a>以使用内置 Web 服务器
php.interpreter.is.remote.title=已配置远程 PHP 解释器
php.interpreter.is.remote.message=请<a href="">选择本地 PHP 解释器</a>以使用内置 Web 服务器

php.cgi.not.found.title=找不到 {0}
php.cgi.not.found=请确保<a href="">配置的 PHP 解释器</a>作为 CGI 程序构建(指定了 --enable-fastcgi)

php.smart.indent.codestyle.indent.in.php=缩进 PHP 标记中的代码

phpdoc.code.style.title=PHPDoc

phpdoc.code.style.generated.doc.blocks=生成的 PHPDoc 标记
phpdoc.code.style.sort.doc.blocks=PHPDoc 标签顺序

phpdoc.code.style.force.null.position=将 ‘null’ 置于以下类型中:
phpdoc.code.style.in.beginning.position=在开头
phpdoc.code.style.in.end.position=在末尾

phpdoc.code.style.convert.true.false.to=将 True/False 常量转换为:
phpdoc.code.style.convert.null.to=将 Null 常量转换为：
php.code.style.convert.keyword.to.lowercase=将关键字转换为小写
php.code.style.convert.lower.case=小写
php.code.style.convert.upper.case=大写
php.code.style.sort.use.stmt=对 'use' 语句排序:
php.code.style.sort.alphabetically=按字母顺序
php.code.style.sort.by.length=按长度

phpdoc.code.style.convert.else.if.to=将 else if/elseif 转换为:
phpdoc.code.style.convert.else.if.separate=else if
phpdoc.code.style.convert.else.if.combine=elseif

phpdoc.code.style.throws.analysis.depth.performance.note.title=性能注释
phpdoc.code.style.throws.analysis.depth.performance.note.message=不建议深入分析多个级别，因为这可能会影响 IDE 性能。要继续吗?

phpdoc.code.style.param.spaces.panel=PHPDoc '@param' 空间
phpdoc.code.style.param.spaces.between.tag.and.type=在标签和类型之间：
phpdoc.code.style.param.spaces.between.type.and.name=类型和名称之间：
phpdoc.code.style.param.spaces.between.name.and.description=在名称和描述之间：

php.conversion.code.style.title=代码转换

php.generation.code.style.title=代码生成

array.declaration.style=数组/列表声明样式

variable.naming.style.panel=变量命名样式
variable.naming.style.mixed=混合
variable.naming.style.camel.case=骆驼拼写法
variable.naming.style.snake.case=snake_case

php.prefdefined.codestyle.psr12.chosen.title=PSR-12 代码样式
php.prefdefined.codestyle.psr12.chosen.message=您可以启用其他 PSR-12 检查，这些检查当前已禁用。
php.prefdefined.codestyle.psr12.enabled.message=PSR-12 检查已启用。

fields.default.visibility.panel=属性默认可见性
fields.default.visibility.private=private
fields.default.visibility.protected=protected
fields.default.visibility.public=public

getters.setters.style=Getter/Setter 样式
getters.setters.order=Getter/Setter 顺序:
getters.setters.getters.first=getter 优先
getters.setters.setters.first=setter 优先
getters.setters.naming.style=命名样式:
getters.setters.configure=配置…

php.embedded.stubs.incorrect.path.warning.title=默认存根路径不正确
php.embedded.stubs.incorrect.path.warning.message=配置的默认存根路径 ''{0}'' 不存在，改为使用嵌入式存根。
php.embedded.stubs.notification.provider.notification=您正在查看不可变的嵌入式存根。为了能够编辑这些存根，您需要克隆一个存根项目，然后通过“PHP / PHP 运行时 / 高级设置”提供默认存根路径。
php.embedded.stubs.notification.provider.clone=在 GitHub 上克隆
php.embedded.stubs.notification.provider.provide=提供默认存根路径
php.embedded.stubs.notification.provider.do.not.show.again=不再显示

auto.import.in.file.scope=在文件范围内启用自动导入
auto.import.in.namespace.scope=在命名空间范围内启用自动导入
auto.import.from.global.space=处理来自全局空间的符号
auto.import.from.global.space.class=类:
auto.import.from.global.space.function=函数:
auto.import.from.global.space.constant=常量:
auto.import.from.global.space.prefer.fallback=回退优先
auto.import.from.global.space.prefer.import=导入优先
auto.import.from.global.space.prefer.fqn=FQN 优先
# non-strict
quickfix.non.strict.object.equality=非严格对象相等比较
inspection.non.strict.object.equality=非严格对象相等比较

exception.analysis.settings.path=PHP/分析
inspection.severity.with.magic=当 __magic 存在时显示

import.references.on.paste.dialog.title=选择要导入的{0}
import.references.on.paste.dialog.message=<html>粘贴的代码段使用 {0}，后者在目标范围中不能通过导入访问。<br/>选择您想要导入到范围中的{0}。</html>
skip.constant.params=使用常量形参跳过调用
inspection.unused.declaration.option.test.entry_points=假定测试声明为入口点
inspection.unused.declaration.option.show.unused_from_entries=显示所有声明
inspection.unused.declaration.option.show_strictly_unused=仅显示未使用项
inspection.unused.declaration.option.test.suppressGettersAndSetters=禁止 getter/setter
inspection.code.patterns.panel.errors.class = 模式必须是有效的 php fqn，仅接受 '*' 作为占位符
inspection.code.patterns.panel.errors.member = 方法模式 {0} 必须是有效的 php 标识符，仅接受 ''*'' 作为占位符
inspection.code.patterns.panel.description.label = 如果 fqn 名称匹配，则将代码标记为入口点
inspection.code.patterns.panel.description.text = 将方法留空以表示构造函数 \n\
 任何 * 都将与 fqn 名称中的一个或多个字符匹配
inspection.unusedd.description.code.patterns.button.label=代码模式
inspection.unused.description.code.suppressed.annotations=已禁止的注解
inspection.undefined.member.warnOnMixed=出现混合、对象、stdClass、未定义类型、null 的访问成员时通知
configurable.PhpServerConfigurable.display.name=服务器
configurable.PhpDebugConfigurable.display.name=调试
configurable.PhpProjectConfigurable.display.name=PHP
configurable.PhpSmartKeysConfigurable.display.name=PHP
configurable.QualityToolCommonConfigurable.display.name=质量工具
class.implements.solely.traversable=类 ''{0}'' 必须将接口 Traversable 作为 Iterator 或 IteratorAggregate 的一部分来实现
configurable.PhpServersConfigurable.display.name=服务器
configurable.PhpTestFrameworksConfigurable.display.name=测试框架
configurable.PhpTemplatesCommonConfigurable.display.name=模板
PhpStepFiltersConfigurable.display.name=步进筛选器
remote.connection.settings.interpreter.is.not.remote=当前项目解释器非远程解释器
remote.connection.settings.default.remote.interpreter=默认远程解释器
php.element.is.available.starting.with.php.version=''{0}'' 从 PHP 版本 {1} 开始可用
php.element.was.removed.in.php.version=''{0}'' 已在 PHP {1} 版本中被移除
settings.smart.keys.title=PHP
settings.smart.keys.enable.smart.function.parameters.completion=启用智能函数形参补全
settings.smart.keys.select.variable.name.without.dollar.sign.on.double.click=双击时选择不含 '$' 符号的变量名称
settings.smart.keys.remove.php.open.close.tags.while.pasting.in.php.context=在 PHP 上下文中粘贴时移除 PHP 开始/结束标记
settings.smart.keys.escape.symbols.on.paste.in.string.literals=在字符串文字中粘贴时转义符号
settings.smart.keys.auto.insert.tag.after.typing=输入 '<?' 后自动插入 '<?php' 标记
settings.smart.keys.find.usages.of.base.method.prompt=搜索方法用法时显示其他选项
settings.smart.keys.replace.unnecessary.double.quotes.on.paste=粘贴时替换不必要的双引号
php.exception.is.never.thrown=函数中从未抛出异常 ''{0}''
php.remove.exception.from.throws=从 @throws 标记中移除 ''{0}''
php.remove.throws.tag=从 @throws 标记移除
php.add.exception=将 ''{0}'' 添加到现有 @throws 标记
ternary.condition.can.be.replaced.with.condition.expression=表达式可以安全地替换为 ''{0}''
php.replace.with=替换为 ''{0}''
php.tag.is.deprecated={0} 已弃用，将在 PHPUnit 9 中移除
potentially.polymorphic.call.multiple.subclasses=潜在的多态调用。该代码可能无法操作，具体取决于作为实参传递的实际类实例。
trait.already.contains.method=特征 {0} 已包含方法 {1}
potentially.polymorphic.call.single.subclass=潜在的多态调用。{0} 的层次结构中没有成员
navigate.to.meta.declaration=导航到 ''{0}''
meta.declaration.exists=''{1}'' 存在元声明 ''{0}''
meta.multiple.declaration.exists=''{0}'' 存在多个元声明
meta.declaration.line.marker.name=存在元声明
unnecessary.local.variable=不必要的局部变量
phpunit.10.won.t.support.classname.annotations=PHPUnit 10 将不支持 ClassName::<*> 注解
returned.by.iterator.aggregate.should.be.traversable=\\IteratorAggregate::getIterator() 返回的对象必须为 Traversable 或实现接口 Iterator
inspection.probably.undefined.property=属性 '#ref' 已动态声明，可能未定义
find.classes.without.member=查找没有成员的类
classes.without.member=层次结构中不带 ''{0}'' 的类
remove.pass.by.ref=移除 '\\&'
pass.by.ref.is.not.effectively.used.inside.body=引用没有必要，因为实参既不通过引用赋值，也不通过引用进一步传递
suppress.if.annotated.by.tag=如果用 ''{0}'' 注解，则禁止
configure.suppressed.annotations=配置禁止的注解
enter.annotation=输入注解
suppressed.annotation.title=已禁止的注解
move.class.to.separate.file.text.family=将类移至单独的文件
type.primitive.hints.names.are.forbidden=禁止名为 'true'、'false' 和 'null' 的类型提示
primitive.hints.name.are.forbidden.in.php.7=PHP 7 中禁止名为 'int'、'string'、'float'、'bool'、'true'、'false' 和 'null' 的类
classes.named.void.and.iterable.are.forbidden.in.php.7.1=PHP 7.1 中禁止名为 'void' 和 'iterable' 的类
classes.named.object.are.forbidden.in.php.7.2=PHP 7.2 中禁止名为 'object' 的类
switch.statements.may.only.contain.one.default.clause.in.php.7=在 PHP 7 中，switch 语句只能包含一个 'default' 子句
show.composer.settings.action.name=显示 Composer 设置
composer.change.setting.action.name=更改设置
composer.diagnose.task.title=诊断
composer.simulating.update.task.title=模拟更新
composer.generating.autoloader.task.title=生成自动加载器
composer.autoloader.generation.settings.name=自动加载器生成设置
composer.generate.list.popup.title=生成
install.composer.packages.task.title=安装 Composer 软件包
composer.listing.licenses.task.title=列出许可证
composer.update.composer.task.title=更新 Composer
composer.checking.for.changes.in.code.of.dependencies.task.title=检查依赖项代码中的变更
composer.update.composer.packages.task.title=更新 Composer 软件包
composer.validating.task.title=验证
composer.validation.settings.name=验证设置
composer.validate.dialog.action.button.title=验证
composer.revert.action.name=还原
composer.clearing.cache.action.name=清除缓存
composer.remove.action.name=移除(&R)
composer.checkbox.download.composer.phar.from.getcomposer.org=从 getcomposer.org 下载 composer-stable.phar
composer.label.phar=composer.phar
composer.label.executable='composer' 可执行文件
composer.checkbox.check.if.composer.lock.is.up.to.date=检查 composer.lock 是否为最新
composer.checkbox.autoload.classes.from.the.classmap.only=仅从类映射自动加载类
composer.label.can.be.time.consuming=可能较为耗时
composer.checkbox.disable.autoload.dev.dependencies=禁用 autoload-dev 依赖项
composer.checkbox.optimize.autoloader.convert.psr.0.4.rules.to.a.classmap=优化自动加载器(将 PSR-0/4 规则转换为类映射)
composer.checkbox.skip.scripts.execution=跳过脚本执行
composer.checkbox.use.apcu.to.cache.found.not.found.classes=使用 APCu 缓存找到/未找到的类
composer.checkbox.allow.unbound.version.constraints=允许未绑定的版本约束
composer.checkbox.check.if.the.package.is.packagist.ready=检查软件包是否为 Packagist 就绪
composer.checkbox.validate.package.dependencies=验证软件包依赖项
composer.checkbox.synchronize.ide.settings.with.composer.json=将 IDE 设置与 composer.json 同步(&S)
composer.label.path.to.composer.json=composer.json 路径(&C):
composer.label.the.settings.php.language.level.directories.may.be.updated=设置(Php 语言级别，目录)可能已更新
composer.border.title.package=软件包
composer.label.package=软件包:
composer.label.version.to.install=要安装的版本:
composer.label.filter.packages=筛选软件包(&F):
composer.label.label=标签
composer.border.title.execution=执行
php.run.label.server=服务器:
php.run.label.https=HTTPS:
php.run.label.url=URL:
php.run.label.query.string=查询字符串:
php.run.label.request.body=请求正文:
php.run.label.request.method=请求方法:
php.run.label.send.request.body.as=将请求正文发送为:
php.run.radio.button.key.value=键值
php.run.http.border.title.configuration=配置
php.run.label.interpreter=解释器:
php.run.radio.button.text=文本
replace.with.alias.from.target.scope=替换为目标范围中的别名
php.information.dialog.title=PHP 信息
extract.method.parameter.name.column.title=形参
constant.with.same.name.already.exists.in.0={0} 中已经存在名称相同的常量
path.0.is.invalid=路径 ''{0}'' 无效
rename.parameters.dialog.title=重命名形参
rename.parameter.dialog.description=将层次结构中的形参重命名为:
quality.tools.custom.coding.standard=自定义编码标准
quality.tools.0.added.to.ignored.files.list={0}已添加到忽略的文件列表。
exclude.0.from.1.analysis.a=从{1}分析中排除{0}。
create.new.field.dialog.title=创建新字段
uml.wrong.name=错误的名称
uml.0.already.exists.in.class.1=类 {1} 中已经存在 ''{0}''
rename.filename.quick.fix=将文件 ''{0}'' 重命名为 ''{1}''
rename.psi.element.quick.fix=将{0} ''{1}'' 重命名为 ''{2}''
fix.package.text=将命名空间 ''{0}'' 替换为 ''{1}''
fix.package.text.family=修复命名空间 
variable.always.have.value.0=到达时变量始终为 '{0,choice,0#false|1#true}'
introduce.named.constant.for.value.0=为值 ''{0}'' 引入命名常量


checkbox.add.packages.as.libraries=作为库添加软件包(&A)
phpunit.label.data.set=数据集:
label.insert.imports.on.paste=粘贴时插入导入:
border.title.php=PHP
label.class.fqn=类 FQN
label.method.name=方法名称
checkbox.move.to.another.class=移动到另一个类(&M)
label.visibility=可见性(&V)
label.initialize.in=初始化在(&I)
radio.button.const=const(&C)
radio.button.define=定义(&D)
border.title.constant.syntax=常量语法
border.title.visibility=可见性
radio.button.default=默认(&F)
radio.button.public=public(&U)
radio.button.private=private(&I)
radio.button.protected=protected(&O)
radio.button.by.concatenation=通过串联(&C)
radio.button.by.embeding=通过嵌入(&E)
radio.button.class.constructor=类构造函数(&S)
radio.button.current.method=当前方法(&T)
radio.button.field.declaration=属性声明(&D)
border.title.initialize.in=初始化位置
border.title.introduce.field=引入属性
radio.button.setup=设置(&U)
border.title.introduce.variable=引入变量
label.name=名称:
label.visibility2=可见性:
checkbox.static=static
checkbox.check.clone.method=检查 '__clone' 方法
checkbox.check.destruct.method=检查 '__destruct' 方法
checkbox.check.sleep.method=检查 '__sleep' 方法
checkbox.check.wakeup.method=检查 '__wakeup' 方法
checkbox.align.parameter.property.names=对齐形参/属性名称
checkbox.align.tag.comments=对齐标记注释
checkbox.blank.line.before.the.first.tag=在第一个标记前使用空行
checkbox.blank.lines.around.parameters=在形参周围使用空行
checkbox.keep.blank.lines=保留空行
checkbox.sort.phpdoc.tags=对 PHPDoc 标记排序
checkbox.use.fully.qualified.class.names=使用完全限定类名
checkbox.wrap.long.lines=长行换行
checkbox.use.as.a.default.template=用作默认模板
label.server.document.root=$_SERVER['DOCUMENT_ROOT']
tooltip.defaults.to.project.folder=默认为项目文件夹
border.title.include.analysis=Include 分析
button.sync.extensions.with.interpreter=将扩展与解释器同步
checkbox.add.a.comma.after.last.element.in.multiline.array=在多行数组中的最后一个元素之后添加逗号
checkbox.force.short.declaration.style=强制短声明样式
checkbox.add.phpdoc=添加 PHPDoc(&D):
radio.button.copy.from.base.class=从基类复制(&P)
radio.button.default.empty.template=默认/空模板(&E)
radio.button.with.inheritdoc.tag=带有 @inheritDoc 标记(&I)
label.constant.syntax=常量语法(&C)
php.interpreter.label.label=标签
no.expression.found=找不到表达式
empty.type=空类型
add.catch.clause.quick.fix=添加 'catch' 从句
php.delete.catch.clause.quick.fix=删除 'catch' 子句
php.delete.exception.quick.fix=删除异常
php.surround.with.try.catch.quick.fix=使用 'try-catch' 环绕
trait.use.rule.type.name=特征 use 规则方法
member.has.0.access.but.class.has.magic.method.1=成员具备 {0} 可见性，但可以通过 ''{1}'' 魔术方法访问
member.has.0.access=成员具备 {0} 可见性
declaration.must.be.compatible.with.0=声明必须与 {0} 兼容
declaration.must.be.compatible.with.super=声明必须与父级兼容
return.type.declaration.must.be.compatible.with.super=返回类型声明必须与父级兼容
array.only.updated.but.never.queried=数组仅被更新，但从未被查询
composer.json.open.tool.settings.intention=打开工具设置
composer.json.path.not.configured=自定义仓库无法加载。未配置 composer.json 路径
composer.json.exec.not.configured=自定义仓库无法加载。未配置 Composer 可执行文件路径
composer.json.custom.packages.done=自定义仓库已加载
composer.json.custom.packages.empty=找不到软件包。请检查您的仓库
composer.json.custom.invalid.json=json 无效
composer.json.packagist.packages.done=仅加载了 packagist 仓库
composer.json.packages.loading.error=软件包未重新加载
composer.json.packages.refresh=软件包正在刷新
cant.save.interpreter=无法保存 ''{0}'': {1}
method.is.undefined.in.class=方法 ''#ref'' 在 {0} 中{1,choice,0#未找到|1#可能未定义}
method.is.undefined=方法 '#ref' {0,choice,0#未定义|1#可能未定义}
property.is.undefined.in.class=属性 ''#ref'' 在 {0} 中{1,choice,0#未找到|1#可能未定义}
property.is.undefined=属性 '#ref' {0,choice,0#未定义|1#可能未定义}
find.cause=查找原因
find.exception.cause.table.title=异常原因
php.find.clause.throws=可能抛出: {0}
action.PhpStanAddToIgnored.text=添加到 PHPStan 忽略列表
action.PhpStanAddToIgnored.description=添加到 PHPStan 忽略列表
inspection.php.unused.display.name=未使用的声明
inspection.php.expression.always.constant.inspection.display.name=到达时，变量始终为 true/false
inspection.composer.json.file.references.inspection.display.name=未解析的文件引用
inspection.php.doc.duplicate.type.inspection.display.name=类型已存在于 PHPDoc 标记中
inspection.php.class.implements.solely.traversable.inspection.display.name=类无法直接实现 Traversable
inspection.php.array.used.only.for.write.inspection.display.name=数组仅用于写访问
inspection.php.private.field.can.be.local.variable.inspection.display.name=private 属性可为局部
inspection.php.foreach.variable.overwrite.already.defined.variable='foreach' 变量重写已定义的变量
inspection.php.inappropriate.inherit.doc.usage.inspection.display.name=使用了不当的 @inheritDoc
inspection.php.expression.with.same.operands.inspection.display.name=逻辑表达式有相同操作数
inspection.php.traits.use.list.inspection.display.name=每行一个特征 use
inspection.php.long.type.form.inspection.display.name=类型关键字的缩写
inspection.php.compound.namespace.depth.inspection.display.name=复合命名空间深度大于 2
inspection.php.separate.else.if.inspection.display.name=Else if
inspection.php.new.class.missing.parameter.list.inspection.display.name=缺少形参列表
inspection.php.var.usage.inspection.display.name=使用了 var
inspection.php.modifier.order.inspection.display.name=修饰符顺序
inspection.php.missing.visibility.inspection.display.name=缺少可见性
inspection.php.parameter.by.ref.is.not.used.as.reference.inspection.display.name=不必要的通过引用传递
inspection.php.accessed.array.is.always.empty=数组在访问点始终为空
inspection.php.if.can.be.merged.with.sequential.condition='if' 可以与后续条件合并
inspection.php.instanceof.is.always.true='instanceof' 的结果始终为 'true'
inspection.php.in.array.can.be.replaced.with.comparison='in_array' 可替换为比较
inspection.php.func.get.arg.can.be.replaced.with.parameter.access='func_get_arg()' 调用可替换为形参访问
inspection.php.format.function.call.with.single.argument=使用单个实参格式化函数调用
inspection.php.invalid.instanceof.argument.type='instanceof' 的实参只应是对象或字符串
inspection.php.condition.always.evaluates.to.constant=条件始终评估为 'true/false'
inspection.php.condition.checked.by.next.condition=逻辑表达式内部的条件由后续条件检查
inspection.php.array.write.access.is.not.used=未使用数组写入访问
inspection.php.redundant.optional.argument=冗余的可选实参
inspection.php.property.only.written=属性用法具有相同的访问权限
inspection.php.to.string.may.produce.exception='__toString' 可能会抛出异常
inspection.php.loop.never.iterates.name=循环未迭代
inspection.php.loop.never.iterates=''{0}'' 语句不循环
inspection.php.ternary.expression.can.be.replaced.with.condition.inspection.display.name=三元表达式可替换为条件
inspection.php.ternary.expression.can.be.replaced.with.short.version=三元表达式可替换为短版本
inspection.php.unnecessary.local.variable.inspection.display.name=不必要的局部变量
inspection.php.unnecessary.semicolon.inspection.display.name=不必要的分号
inspection.php.curly.brace.access.syntax.usage.inspection.display.name=使用了大括号访问语法
inspection.php.single.statement.with.braces.inspection.display.name=单语句主体带大括号
inspection.php.statement.without.braces.inspection.display.name=控制语句主体无大括号
inspection.php.str.functions.inspection.display.name='str*()' 调用可替换为 PHP 8 'str_*()' 调用
inspection.php.nested.ternary.expression.usage.inspection.display.name=使用了嵌套的三元运算符
inspection.php.doc.field.type.mismatch.inspection.display.name=类型与属性的声明类型不匹配
inspection.php.switch.case.without.default.branch.inspection.display.name=switch 语句没有 default 分支
inspection.php.strict.comparison.of.operands.with.different.types=严格比较类型不兼容的操作数
inspection.php.suspicious.name.combination.inspection.name=可疑名称组合
inspection.php.duplicate.switch.case.body.inspection.display.name=switch 语句中存在重复分支
inspection.php.duplicate.switch.catch.body.inspection.display.name='catch' 语句中的重复分支
inspection.php.exception.is.immediately.rethrown=立即重新抛出异常
inspection.php.continue.targeting.switch='continue' 针对 'switch' 语句
inspection.php.redundant.continue.break.argument=冗余的 'continue/break' 实参
inspection.php.duplicate.match.arm.body.inspection.display.name='match' 表达式中的重复 arm
inspection.php.field.assignment.type.mismatch.inspection.display.name=属性赋值中的类型不匹配
inspection.php.closure.can.be.converted.to.short.arrow.function.inspection.display.name=闭包可以转换为箭头函数
inspection.php.concatenation.with.arithmetic.usage=具有算术用法的串联
inspection.php.parameter.always.have.same.value=形参值始终相同
inspection.php.method.return.value.is.never.used=方法的返回值从未使用
inspection.php.isset.can.be.replaced.with.coalesce='isset' 可替换为合并
inspection.php.cast.is.unnecessary=类型转换不必要
inspection.php.unnecessary.curly.variable.syntax=变量的不必要大括号语法
inspection.php.unpacked.argument.type.mismatch.inspection.display.name=无效类型的解包实参
inspection.php.missing.return.type.inspection.display.name=缺少返回类型声明
inspection.php.missing.parameter.type.inspection.display.name=缺少形参的类型声明
inspection.php.missing.field.type.inspection.display.name=缺少属性的类型声明
inspection.php.expression.without.clarifying.parentheses.inspection.display.name=表达式不带澄清括号
inspection.php.unnecessary.parentheses.inspection.display.name=不必要的圆括号
inspection.php.method.may.be.static.inspection.display.name=方法可以为 'static'
inspection.php.format.function.parameters.mismatch.inspection.display.name=格式函数形参不匹配
inspection.php.ignored.class.alias.declaration.display.name=忽略的类别名声明
inspection.php.composer.duplicated.requirement.inspection.display.name=composer.json 中存在重复的软件包条目
inspection.php.not.installed.packages.inspection.display.name=未安装的 Composer 软件包
inspection.php.disabled.quality.tool.composer.inspection.display.name=质量工具检查已禁用
inspection.php.composer.extension.stubs.inspection.display.name=composer.json 中缺少扩展
inspection.php.disabled.extension.stubs.inspection.display.name=已禁用的扩展存根
inspection.php.array.fill.can.be.converted.to.loop.inspection.display.name='array_fill' 可以转换为循环
inspection.php.loop.can.be.converted.to.array.fill.inspection.display.name=循环可以转换为 'array_fill()' 调用
inspection.php.get.class.can.be.replaced.with.class.name.literal.inspection.display.name='get_class()' 调用可替换为 '::class'
inspection.php.array.filter.can.be.converted.to.loop.inspection.display.name='array_filter()' 调用可以转换为循环
inspection.php.loop.can.be.converted.to.array.filter.inspection.display.name=循环可以转换为 'array_filter()' 调用
inspection.php.loop.can.be.converted.to.array.map.inspection.display.name=循环可以转换为 'array_map()' 调用
inspection.php.array.map.can.be.converted.to.loop.inspection.display.name='array_map()' 调用可以转换为循环
inspection.php.short.open.tag.inspection.display.name=使用了短起始标记
inspection.php.constructor.style.inspection.display.name=旧式构造函数
inspection.php.assignment.replaceable.with.prefix.expression.inspection.display.name=赋值可替换为增量或减量
inspection.php.assignment.replaceable.with.operator.assignment.inspection.display.name=赋值可替换为运算符赋值
inspection.php.invalid.magic.method.modifiers.inspection.display.name=魔术方法修饰符无效
inspection.php.incorrect.magic.method.signature.inspection.display.name=魔术方法签名不正确
inspection.php.array.access.on.illegal.type.display.name=非法类型的数组偏移访问
inspection.php.parameter.name.chaged.during.inhertiance=在继承期间更改了形参名称
inspection.php.named.argument.may.be.unresolved=命名实参可能未解析
inspection.php.argument.without.name.identifier=无名称标识符的实参
inspection.php.named.argument.usage=有名称标识符的实参
inspection.php.named.arguments.with.changed.order=命名实参顺序与形参顺序不匹配
inspection.php.mixed.return.type.can.be.reduced=可以缩小 'mixed' 返回类型的范围
inspection.php.null.is.not.compatible.with.parameter='null' 与形参的声明类型不兼容
inspection.php.nested.dirname.call.can.be.replaced.with.levels.usage=嵌套的 'dirname()' 调用可替换为 'levels' 形参用法
inspection.php.trait.method.use.is.located.inside.different.target.class=特征 use 规则已解析为使用不同包含类的方法 
inspection.php.trait.usage=不允许特征用法
inspection.php.class.cant.be.used.as.attribute=类不能用作特性
inspection.php.redundant.match.expression='match' 表达式只有 default arm，应当进行简化
inspection.php.loop.can.be.replaced.with.str.repeat=循环可替换为 'str_repeat'
inspection.php.concatenation.with.empty.string.can.be.merged=空字符串的串联可以与赋值合并
inspection.php.match.expression.can.be.replaced.with.ternary='match' 表达式可替换为三元表达式
inspection.php.switch.can.be.replaced.with.match.expression='switch' 可替换为 'match' 表达式
inspection.php.inapplicable.attribute.target.declaration=不适用的特性目标声明
inspection.php.expected.values.should.be.used=应使用预期值
inspection.php.immutable.property.is.written.in.invalid.scope=在无效的作用域中写入不可变属性
inspection.php.attribute.is.not.repeatable=不可重复的特性
inspection.php.attribute.no.return.can.be.added=可以添加 NoReturn 特性
inspection.php.pure.contract.attribute.can.be.added=可以添加 '#[Pure]' 特性
inspection.php.pure.function.may.produce.side.effect=纯函数可能会产生副作用
inspection.php.attribute.array.shape.can.be.added=可以添加 '#[ArrayShape]' 特性
inspection.php.attribute.can.be.overridden=可以将特性添加到重写成员
inspection.php.array.key.does.not.match.array.shape=数组键与数组形状不匹配 
inspection.php.missing.strict.types.declaration.inspection.display.name=缺少严格类型声明
inspection.php.incompatible.return.type.inspection.display.name=返回类型不兼容
inspection.php.strict.type.checking.inspection.display.name=严格类型检查规则违反
inspection.php.non.canonical.elements.order.inspection.display.name=元素的非规范顺序
inspection.php.null.safe.operator.can.be.used=可以使用 Nullsafe 运算符 '?->'
inspection.php.variable.variable.inspection.display.name=使用了可变变量
inspection.php.traditional.syntax.array.literal.inspection.display.name=检测到传统语法数组文字
inspection.php.illegal.psr.class.path.inspection.display.name=类路径与项目结构不匹配
inspection.php.multiple.classes.declarations.in.one.file.display.name=一个文件中有多个类声明
inspection.php.redundant.catch.clause.inspection.display.name=冗余 catch 子句
inspection.php.unhandled.exception.inspection.display.name=未处理的异常
inspection.php.non.strict.object.equality.inspection.display.name=非严格对象相等
inspection.php.duplicate.case.inspection.display.name=switch 语句中存在重复的 case
inspection.php.duplicate.match.condition.inspection.display.name=重复条件
inspection.php.unused.match.arm.condition.inspection.display.name=未使用的 'match' 条件
inspection.php.comment.will.be.parsed.as.attribute=在 PHP 8.0 中注释被解析为特性
inspection.php.redundant.attribute.parenthesis=特性中的冗余圆括号
inspection.php.fully.qualified.name.usage.inspection.display.name=使用了完全限定名称
inspection.php.unnecessary.fully.qualified.name.inspection.display.name=不必要的完全限定名称
inspection.mess.detector.validation.inspection.display.name=PHP Mess Detector 验证
inspection.php.CS.fixer.validation.inspection.display.name=PHP CS Fixer 验证
inspection.php.CS.validation.inspection.display.name=PHP_CodeSniffer 验证
inspection.php.usage.of.silence.operator.inspection.display.name=使用了静默运算符
inspection.php.useless.trailing.comma.inspection.display.name=无用的尾随逗号
inspection.php.useless.trailing.comma.inspection.desc=无用的尾随逗号
inspection.php.remove.useless.trailing.comma=移除无用的尾随逗号
inspection.php.add.line.break.after.trailing.comma=在尾随逗号后添加换行符
inspection.php.foreach.array.is.used.as.value.inspection.display.name=Foreach 数组用作值
inspection.php.foreach.nested.outer.key.value.variables.conflict.inspection.display.name=嵌套与外部 'foreach' 变量冲突
inspection.php.missing.break.statement.inspection.display.name=缺少 'break' 语句
inspection.php.unit.covers.by.access.modifier.is.deprecated.inspection.display.name=弃用的通过修饰符注解进行的 @covers/@uses
inspection.php.unit.expected.exception.doc.tag.is.deprecated.inspection.display.name=弃用的通过文档标记进行的异常处理
inspection.php.unit.deprecated.expect.exception.inspection.display.name=使用了弃用的 expectException
inspection.php.unit.assert.array.has.key.inspection.display.name=可以改用方法 'assertArrayHasKey/assertArrayNotHasKey'
inspection.php.unit.misordered.assert.equals.arguments.inspection.display.name=顺序错误的 PHPUnit 等式断言方法实参
inspection.php.unit.assert.count.inspection.display.name=使用了 'assertCount/assertSameSize' 方法而非 assertEquals
inspection.php.unit.assert.contains.inspection.display.name=弃用的 'assertContains/assertNotContains' 用法
inspection.php.unit.assert.can.be.replaced.with.fail=断言可替换为 'fail'
inspection.php.unit.assert.empty.inspection.display.name=断言可替换为 'assertEmpty/assertNotEmpty'
inspection.php.unit.assert.file.equals.inspection.display.name=弃用的 'assertFileEquals/assertStringEqualsFile' 用法
inspection.php.unit.assert.equals.inspection.display.name=弃用的 'assertEquals/assertNotEquals' 用法
inspection.php.unit.covers.function.without.scope.resolution.operator.inspection.display.name=提供的覆盖函数引用没有 ‘::’
inspection.php.unit.undefined.data.provider.inspection.display.name=未定义的 PHPUnit 数据提供程序
inspection.php.unit.missing.target.for.test.inspection.display.name=PHPUnit 测试缺少目标元素
inspection.php.constant.naming.convention.inspection.display.name=常量名称未遵循编码惯例
inspection.php.variable.naming.convention.inspection.display.name=变量名称未遵循编码惯例
inspection.php.property.naming.convention.inspection.display.name=属性名称未遵循编码惯例
inspection.php.method.naming.convention.inspection.display.name=方法名称未遵循编码惯例
inspection.php.function.naming.convention.inspection.display.name=函数名称未遵循编码惯例
inspection.php.class.naming.convention.inspection.display.name=类名未遵循编码惯例
inspection.php.overriding.method.visibility.inspection.display.name=方法可见性不应被重写
inspection.php.method.or.class.call.is.not.case.sensitive.inspection.display.name=方法调用或类用法中的大小写不匹配
inspection.php.expression.result.unused.inspection.display.name=未使用表达式结果
inspection.php.throwable.not.thrown.inspection.display.name=未抛出 Throwable
inspection.php.void.function.result.used.inspection.display.name=使用了 void 函数结果
inspection.php.redundant.closing.tag.inspection.display.name=冗余结束标记
inspection.php.too.many.parameters.inspection.display.name=函数声明中的形参过多
inspection.php.method.parameters.count.mismatch.inspection.display.name=形参数量与声明不匹配
inspection.php.inconsistent.return.points.inspection.display.name=不一致的返回点
inspection.php.redundant.variable.doc.type.inspection.display.name=冗余 @var 标记
inspection.php.doc.redundant.throws.inspection.display.name=冗余 @throws 标记
inspection.php.doc.missing.throws.inspection.display.name=缺少 @throws 标记
inspection.php.redundant.doc.comment.inspection.display.name=冗余 PHPDoc 注释
inspection.php.doc.signature.inspection.display.name=PHPDoc 注释匹配函数/方法签名
inspection.php.doc.is.not.complete.inspection.display.name=PHPDoc 注释签名不完整
inspection.php.return.doc.type.mismatch.inspection.display.name=PHPDoc 注释中的返回类型与实际返回类型不匹配
inspection.php.illegal.string.offset.inspection.display.name=非法字符串偏移
inspection.php.illegal.array.key.type.inspection.display.name=非法数组键类型
inspection.php.silly.assignment.inspection.display.name=冗余赋值
inspection.php.missing.doc.comment.inspection.display.name=缺少 PHPDoc 注释
inspection.php.unused.parameter.inspection.display.name=未使用的形参
inspection.php.wrong.foreach.argument.type.inspection.display.name=为 'foreach()' 提供的无效实参
inspection.php.division.by.zero.inspection.display.name=除以零
inspection.php.assignment.in.condition.inspection.display.name=条件中的赋值
inspection.php.wrong.catch.clauses.order.inspection.display.name=catch 子句顺序错误
inspection.php.wrong.string.concatenation.inspection.display.name=字符串串联错误
inspection.php.constant.reassignment.inspection.display.name=常量重新赋值
inspection.php.non.compound.use.inspection.display.name=不必要的语句使用
inspection.php.to.string.implementation.inspection.display.name=方法 '__toString' 实现
inspection.php.to.string.return.inspection.display.name=方法 '__toString' 返回类型
inspection.php.internal.entity.used.inspection.display.name=使用了内部实体
inspection.php.deprecated.implode.usage.inspection.display.name=弃用的 'implode/join' 用法
inspection.php.expression.always.null.inspection.display.name=表达式始终为 'null'
inspection.php.deprecated.cast.inspection.display.name=弃用的转换
inspection.php.define.constant.name.with.leading.slash=使用前导斜杠定义的常量名称
inspection.php.define.constant.can.be.replaced.with.const.syntax=define 常量名称可替换为 'const' 语法
inspection.php.element.is.not.available.in.current.php.version.inspection.display.name=元素在配置的 PHP 版本中不可用
inspection.php.deprecation.inspection.display.name=已弃用
inspection.php.plural.mixed.can.be.replaced.with.array='mixed' 类型可替换为 'array'
inspection.php.language.level.inspection.display.name=语言级别
inspection.php.unused.field.default.value.inspection.display.name=冗余属性初始值设定项
inspection.php.unused.alias.inspection.display.name=未使用的 import
inspection.php.unused.local.variable.inspection.display.name=未使用的局部变量
inspection.php.write.access.to.referenced.array.value.without.unset=对无 'unset' 的引用数组值的写入权限
inspection.php.boolean.expression.can.be.simplified=可以简化布尔表达式
inspection.array.access.can.be.replaced.with.foreach.value=数组访问可替换为 'foreach' 值
inspection.php.unused.private.field.inspection.display.name=未使用的 private 属性
inspection.php.unused.private.method.inspection.display.name=未使用的 private 方法
inspection.php.goto.into.loop.inspection.display.name=Goto 转入循环语句
inspection.php.pass.by.ref.inspection.display.name=通过引用传递形参
inspection.php.optional.before.required.parameters.inspection.display.name=可选形参在必选形参之前
inspection.php.params.inspection.display.name=形参类型
inspection.php.include.inspection.display.name=未解析的 include
inspection.php.undefined.constant.inspection.display.name=未定义的常量
inspection.php.undefined.field.inspection.display.name=未定义的属性
inspection.php.statement.has.empty.body.inspection.display.name=语句具有空体
inspection.php.missing.parent.call.magic.inspection.display.name=魔术方法缺少父调用
inspection.php.missing.parent.call.common.inspection.display.name=方法缺少父调用
inspection.php.missing.parent.constructor.inspection.display.name=构造函数缺少父调用
inspection.php.undefined.class.constant.inspection.display.name=未定义的类常量
inspection.php.super.class.incompatible.with.interface.inspection.display.name=父类的方法声明与实现的接口不兼容
inspection.php.signature.mismatch.during.inheritance.inspection.display.name=重写方法的声明应与父类兼容
inspection.php.abstract.static.method.inspection.display.name=static 函数不应为 abstract
inspection.php.static.as.dynamic.method.call.inspection.display.name=static 方法被调用为动态
inspection.php.dynamic.as.static.method.call.inspection.display.name=动态方法被调用为 static
inspection.php.possible.polymorphic.invocation.inspection.display.name=可能的多态调用
inspection.php.promoted.field.usage=提升的属性用法
inspection.field.can.be.promoted=可以提升属性
inspection.php.redundant.assignment.to.promoted.field=冗余的提升属性赋值
inspection.php.undefined.callback.inspection.display.name=未定义的回调
inspection.php.undefined.function.inspection.display.name=未定义的函数
inspection.php.undefined.class.inspection.display.name=未定义的类
inspection.php.multiple.class.declarations.inspection.display.name=多个类声明
inspection.php.undefined.namespace.inspection.display.name=未定义的命名空间
inspection.php.undefined.method.inspection.display.name=未定义的方法
inspection.php.undefined.variable.inspection.display.name=未定义的变量
inspection.php.undefined.goto.label.inspection.display.name=未定义的 goto 标签
inspection.php.group.undefined=未定义的符号
inspection.php.group.probable.bugs=可能的错误
inspection.php.group.general=常规
inspection.php.group.strict.standards=PHP 严格标准
inspection.php.group.type.compatibility=类型兼容性
inspection.php.group.control.flow=控制流
inspection.php.group.code.smell=代码异味
inspection.php.group.psr.12=PSR-12
inspection.php.group.phpdoc=PHPDoc
inspection.php.group.code.style=代码样式
inspection.php.group.composer=Composer
inspection.php.group.unused=未使用的符号
inspection.php.group.naming.conventions=命名惯例
inspection.php.group.phpunit=PHPUnit
inspection.php.group.quality.tools=质量工具
inspection.php.group.replacable.assignments=可替换赋值
inspection.php.group.error.handling=错误处理
inspection.php.group.attributes=特性
list.item.update.phpdoc.comment=更新 PHPDoc 注释
inspection.php.unnecessary.return.inspection.display.name=不必要的 'return/continue' 语句
inspection.php.unnecessary.else.inspection.display.name=不必要的 'else' 分支
inspection.php.unnecessary.return.function='return' 不必要，因为是函数中的最后一条语句
inspection.php.unnecessary.return.method='return' 不必要，因为是方法中的最后一条语句
inspection.php.unnecessary.continue='continue' 不必要，因为是循环中的最后一条语句
php.unit.create.target.method.quick.fix.family.name=创建缺少的目标方法
inspection.php.missing.return.type.description=缺少函数的返回类型声明
inspection.php.missing.param.type.description=缺少形参的类型声明
quickfix.php.missing.param.type.description=作为形参类型添加 ''{0}''
quickfix.php.missing.param.type.batch.description=作为属性类型添加推断的类型
php.add.method.declaration.quick.fix.text=添加方法
php.add.tag.base.quick.fix.family.name=添加 {0} 标记
inspection.php.unused.field.default.value.description=属性初始值设定项冗余
php.change.function.signature.manually.quick.fix.family.name=手动更改签名
php.change.function.signature.from.usage.quick.fix.family.name=从用法改变函数签名
searching.for.usages=正在搜索用法…
php.replace.with.local.variable.quick.fix.family.name=将属性替换为局部变量
inspection.php.private.field.can.be.local.variable.description=属性可替换为局部变量
inspection.php.abstract.static.method.description=PHP 严格标准: static 方法 '#ref' 不应为 abstract
php.replace.argument.with.cast.quick.fix.family.name=将实参转换为{0}
php.change.cast.operation.quick.fix.family.name=将转换更改为{0}
php.replace.with.null.quick.fix.family.name=替换为 'null'
inspection.php.expression.always.null.description='#ref' 始终为 'null'
inspection.unnecessary.static.reference=final 类中有冗余的 'static'
inspection.unnecessary.string.cast=冗余转换为字符串
inspection.unnecessary.bool.cast=冗余转换为布尔值
php.configure.extensions.quick.fix.family.name=配置扩展存根
php.enable.extension.quick.fix.family.name=启用扩展存根
php.enable.extension.quick.fix.text=启用 ''{0}'' 扩展存根
inspection.php.disabled.extension.stubs.description=已禁用的 ''{0}'' 扩展存根
inspection.php.unnecessary.semicolon.description=不必要的 ;
inspection.php.inappropriate.inherit.doc.usage.description=@inheritDoc 用于没有父级成员但含有 doc 注释的成员
inspection.php.inappropriate.inherit.doc.usage.description2=@inheritDoc 应仅用于类成员
php.inline.variable.quick.fix.family.name=内联变量
update.php.doc.type.family.name=更新 PHPDoc 类型
update.php.doc.type.comment=替换为 ''{0}''
inspection.php.return.doc.type.mismatch=PHPDoc 中的返回类型与实际返回类型不匹配
inspection.php.doc.signature.description=重复的实参 PHPDoc
inspection.php.doc.signature.description2=返回类型与声明的不匹配
inspection.php.doc.signature.description3=不存在实参的 PHPDoc
inspection.php.doc.signature.description5=实参类型与声明的不匹配
php.flip.variable.and.type.quick.fix.family.name=翻转变量和类型
inspection.php.non.canonical.elements.order.description=变量及其类型以非规范顺序列出
php.make.class.abstract.quick.fix.family.name=将类设为 abstract
php.remove.doc.tag.quick.fix.family.name=移除 {0}
php.make.method.non.final.quick.fix.family.name=将方法设为非 final
inspection.php.short.open.tag.description=使用了短起始标记
php.make.method.non.static.quick.fix.family.name=将方法设为非 static
php.flip.arguments.quick.fix.family.name=翻转第一和第二个实参
inspection.php.unused.alias.description=导入 '#ref' 不必要
inspection.php.unused.alias.description2=导入 '#ref' 从未使用
php.rename.wrong.reference.quick.fix.family.name=重命名引用
php.append.doc.static.fix.family.name=在函数引用前追加 '::'
inspection.php.include.description=无法解析表达式 ''{0}'' 的目标
inspection.php.include.description2=未找到路径 ''{0}''
make.call.dynamic.quick.fix.family.name=使调用为动态
inspection.php.undefined.class.description=类 '#ref' 存在多个定义
inspection.php.undefined.class.description2=未定义的类 '#ref'
inspection.php.undefined.class.description5=存在类 '#ref' 的其他声明
php.dead.code.entries=PHP 死码条目
inspection.php.redundant.variable.doc.type.description=@var 标记指定了已从源代码推断出的类型
php.remove.all.unused.parameters.quick.fix.text=移除所有未使用的形参
transform=转换
remove=移除
php.remove.unused.local.variable.without.successor.quick.fix.family.name=移除变量 ''{0}''
php.replace.with.float.cast.quick.fix.family.name=替换为 '(float)' 转换
php.create.data.provider.quick.fix.family.name=创建数据提供程序
inspection.php.undefined.namespace.description=未定义的命名空间 '#ref'
fix.not.available=修复不可用
php.unit.create.target.class.quick.fix.family.name=创建缺少的目标类
initialize.var.quick.fix.family.name=使用值初始化
inspection.php.statement.has.empty.body.description=语句具有空体
php.replace.with.interface.quick.fix.family.name=替换为 {0}
remove.redundant.suppression.quick.fix.family.name=移除 ''{0}'' 禁止
php.change.method.modifiers.quick.fix.family.name=更改修饰符
php.change.method.modifiers.quick.fix.text=移除修饰符
php.remove.statement.fix.family.name=移除
php.make.method.non.abstract.quick.fix.family.name=将方法设为非 abstract
replace.plus.asgn.to.concat.asgn.quick.fix.family.name=将 '+=' 替换为 '.='
replace.plus.to.concat.quick.fix.family.name=将 '+' 替换为 '.'
replace.with.0=替换为 {0}
php.remove.ref.from.function.declaration.quick.fix.family.name=从函数声明中移除 '&'
php.remove.ref.from.assignment.quick.fix.family.name=将 '=\\&' 替换为 '='
php.remove.pass.by.ref.from.parameter.quick.fix.family.name=从形参中移除 '&'
inspection.php.pass.by.ref.description=仅变量可通过引用返回
php.non.strict.object.equality.quick.fix.text=替换为身份比较
php.add.field.declaration.quick.fix.text=添加属性
quick.fix.error=快速修复错误
the.original.class.0.does.not.belong.to.the.project.and.cannot.be.modified=原始类 {0} 不属于该项目\n\
并且无法修改。
add.constant.declaration.quick.fix.text=添加常量
constant.ref.not.found.in=在 {0} 中未找到常量 ''#ref''
php.remove.parameters.quick.fix.text=移除未使用的形参
replace.extends.implements=替换 'extends'/'implements'
inspection.php.undefined.class.other.declaration.exists={0} 处存在类 ''#ref'' 的其他声明
inspection.php.undefined.class.other.declaration.exists.and={0} 和另 {1} 处存在类 ''#ref'' 的其他声明
show.implementations.for.0={0} 的实现
show.super.types.for.0=显示 {0} 的父类型
display.name.directory.0=目录 ''{0}''
hint.text.element.doesn.t.have.fqn=元素没有 FQN
instanceof.is.always.true={0} 已位于 {1} 的层次结构中
dialog.message.server.host.cannot.be.empty=服务器主机不能为空
dialog.message.port.cannot.be.negative.number=端口号不能为负
dialog.message.query.string.cannot.start.with=查询字符串不能以 '?' 开头
inspection.message.code.fragment.too.complex.to.parse.this.piece.code.will.be.treated.as.plain.text=代码段过于复杂，无法解析，因此将作为纯文本处理
inspection.message.control.flow.too.big.to.analyze=控制流太大，无法分析
remove.variable=移除变量
annotator.fix.remove=移除 ''{0}''
inspection.message.class.may.inherit.from.final.class=类可能无法继承 final 类
inspection.message.key.element.cannot.be.reference=键元素不能为引用
inspection.message.absolute.method.reference.should.be.specified.for.insteadof.trait.use.rule=应为 'insteadof' 特征 use 规则指定绝对方法引用
inspection.message.generators.may.only.declare.return.type.generator.iterator.or.traversable.or.iterable.permitted=生成器只能声明 ''Generator''、''Iterator''、''Traversable'' 或 ''iterable'' 的返回类型，不允许 {0}
find.usages.button.base.method=基方法
find.usages.button.current.method=当前方法
find.usages.prompt.dialog.implements=类 ''{1}'' 的方法 ''{0}()'' 在 ''{2}'' 中实现了{3,choice,0#方法|1#方法}\n\
要查找基{3,choice,0#方法|1#方法}的用法吗?
find.usages.prompt.dialog.overrides=类 ''{1}'' 的方法 ''{0}()'' 在 ''{2}'' 中重写了{3,choice,0#方法|1#方法}\n\
要查找基{3,choice,0#方法|1#方法}的用法吗?
more.actions=更多操作…
show.log.of.composer.related.actions=显示 Composer 相关操作的日志
show.log=显示日志
members.to.report=要报告的成员
entry.points=入口点
constructors=构造函数
inspection.message.type.mismatch.should.be.conditional.expression=类型不匹配: 应为条件表达式
filetype.doctrine.query.description=Doctrine 查询语言
inspection.php.typed.property.might.be.uninitialized.inspection.display.name=类型化属性可能未初始化
inspection.php.typed.property.might.be.uninitialized.inspection.problem=类型化属性 ''{0}'' 可能未初始化
inspection.message.primitive.types.can.t.be.used.as.instanceof.argument=仅对象或字符串应用作 ''instanceof'' 实参，当前: ''{0}''
another.definition.with.same.name.exists.in.this.file=此文件中存在另一个具有相同名称的定义
method.with.same.name.already.defined.in.this.class=此类中已经定义了具有相同名称的方法
global.code.should.be.enclosed.in.global.namespace.declaration=全局代码应包含在全局命名空间声明中
static.property.cannot.be.unset=static 属性不能取消设置
the.yield.expression.can.only.be.used.inside.a.function='yield' 表达式只能在函数中使用
multiple.modifiers.are.not.allowed=不允许多个修饰符
access.type.for.interface.member.must.be.omitted=接口成员的访问类型必须省略
final.modifier.is.not.allowed.here=此处不允许使用 'final' 修饰符
fields.cannot.be.declared.final=属性不能声明为 final
abstract.modifier.is.not.allowed.here=此处不允许使用 'Abstract' 修饰符
fields.cannot.be.declared.abstract=属性不能声明为 abstract
static.modifier.is.not.allowed.here=此处不允许使用 'Static' 修饰符
jump.into.a.finally.block.is.disallowed=不允许跳入 'finally' 块
cannot.use.static.as.function.return.type.declaration=不允许 'static' 作为类范围外部的返回类型声明
void.type.cannot.be.nullable=void 类型不能是可为 null
can.only.be.used.as.standalone.type={0} 仅可用作独立类型
void.can.only.be.used.as.return.type=Void 只能用作返回类型
static.is.not.allowed.in.parameter.type.declaration=形参类型声明中不允许 'static'
cannot.use.this.as.parameter=不能将 $this 用作形参
only.the.last.parameter.can.be.variadic=只有最后一个形参可以是可变形参
expression.is.not.allowed.as.parameter.default.value=表达式不允许为形参默认值
argument.passed.must.be.of.the.type.0.1.given=传递的实参必须为 {0} 类型，给定的为 {1}
variadic.parameter.cannot.have.a.default.value=可变形参不能具有默认值
only.simple.expressions.are.allowed=只允许简单表达式
target.trait.should.be.specified=应指定目标特征
call.to.0.1.construct.from.invalid.context=从无效上下文调用 ''{0} {1}::__construct()''
constants.defined.using.the.const.keyword.must.be.declared.at.the.top.level.scope=使用 'const' 关键字定义的常量必须在顶层范围声明
expression.is.not.allowed.as.constant.value=表达式不允许作为常量值
cannot.redeclare.constant.0=无法重新声明常量 ''{0}''
expression.is.not.allowed.as.field.default.value=表达式不允许为字段默认值
cannot.declare.self.referencing.constant=无法声明自引用常量
a.class.constant.must.not.be.called.class.it.is.reserved.for.class.name.fetching=类常量不得被称为 'class'；后者被保留用于类名提取
traits.cannot.have.constants=特征不能有常量
redefinition.of.parameters.is.not.allowed=不允许形参重新定义
method.0.clone.cannot.accept.any.arguments=方法 ''{0}::__clone()'' 不能接受任何实参
return.type.declaration.is.not.allowed=不允许返回类型声明
method.should.not.be.finished.with=方法不应以 ';' 结束
method.should.either.have.body.or.be.abstract=方法应具有主体或为 abstract
interface.method.can.t.have.body=接口方法不能有主体
anonymous.function.expected=应为匿名函数
label.with.same.name.already.defined.in.current.scope=当前范围中已定义具有相同名称的标签
interfaces.may.not.include.member.variables=接口可能不包括成员变量
0.with.same.name.already.defined.in.this.class=此类中已经定义了具有相同名称的{0}
field=字段
cannot.redeclare.static.0.1.as.non.static.2.3=无法将 static ''{0}::${1}'' 重新声明为非 static ''{2}::${3}''
cannot.redeclare.non.static.0.1.as.static.2.3=无法将非 static ''{0}::${1}'' 重新声明为 static ''{2}::${3}''
0.and.1.define.the.same.property.2=''{0}'' 和 ''{1}'' 定义相同的属性 ''{2}''
access.level.to.0.1.must.be.2.as.in.class.3.or.weaker=''{0}::${1}'' 的访问级别必须为 {2} (与类 {3} 中一样)或更低
access.level.to.0.1.must.be.2.as.in.class.3.or.weaker2=''{0}::{1}'' 的访问级别必须为 {2} (与类 {3} 中一样)或更低
cannot.inherit.previously.inherited.or.override.constant.0.from.interface.1=无法从接口 ''{1}'' 继承先前继承的常量 ''{0}'' 或将其重写
empty.implements.list=空实现列表
a.trait.cannot.implement.an.interface=特征无法实现接口
class.cannot.implement.previously.implemented.interface=类无法实现先前实现的接口
class.should.not.implement.itself=类不应自行实现
empty.extends.list=空 extends 列表
a.trait.cannot.extend.a.class=特征无法扩展类
interface.cannot.extend.previously.extended.interface=接口无法扩展先前扩展的接口
class.cannot.extend.from.trait=类无法从特征扩展
0.should.not.extend.itself={0} 不应自行扩展
class=类
class.declarations.may.not.be.nested=类声明不能被嵌套
cannot.use.traits.inside.of.interfaces=无法在接口内部使用特征
trait.expected.class.found=应为特征，发现类
absolute.reference.is.not.allowed=不允许绝对引用
cannot.use.0.as.lexical.variable=无法将 ''${0}'' 用作词法变量
duplicate.variable.0=重复的变量 ''{0}''
trailing.comma.is.not.allowed=不允许尾随逗号
the.use.keyword.must.be.declared.in.the.outermost.scope.of.a.file.the.global.scope.or.inside.namespace.declarations=必须在文件的最外侧范围(全局范围)或命名空间声明内部声明 'use' 关键字
static.is.not.allowed.in.compile.time.constants=编译时常量中不允许使用 'static::'
multiple.namespaces.in.a.file.should.use.same.preferably.braced.syntax=文件中的多个命名空间应使用相同的(最好带大括号)语法
no.content.allowed.before.namespace.declaration=命名空间声明之前不允许任何内容
an.object.s.clone.method.cannot.be.called.directly=无法直接调用对象的 '__clone()' 方法
property.write=@property-write
property.read=@property-read
isset.only.works.with.variables.and.arrays=isset 仅适用于变量和数组
cannot.use.positional.argument.after.argument.unpacking=无法在实参解包后使用位置实参
function.name.must.be.callable.a.string.closure.or.class.implementing.invoke.currently.0=函数名称必须可调用 - 字符串、闭包或实现 ''__invoke'' 的类，当前为 ''{0}''
using.this.when.not.in.object.context=不在对象上下文中时使用 '$this'
array.can.t.be.used.for.array.destructuring.assignment='array()' 不能用于数组析构赋值
function.call.is.not.allowed.here=此处不允许使用函数调用
expression.is.not.assignable=表达式不可赋值
call.to.method.clone.from.invalid.context=从无效上下文调用方法 '__clone'
cannot.use.for.reading=无法使用 '[]' 进行读取
it.s.not.possible.to.unpack.array.argument.by.reference=无法通过引用对数组实参解包
spread.operators.in.arrays.are.not.supported.for.multiassignments.variables=多赋值变量不支持在数组中使用展开运算符
it.s.not.possible.to.unpack.array.value.with.associated.key=无法使用关联键解包数组值
it.s.not.possible.to.unpack.array.key=无法解包数组键
cannot.use.empty.array.elements.in.arrays=无法在数组中使用空数组元素
invalid.octal.literal.won.t.be.reported.by.php.but.will.work.incorrectly=无效的八进制文字: 不会由 PHP 报告，但无法正常工作
multiple.subsequent.underscores.in.a.numeric.literal.are.not.allowed=不允许在数字文字中使用多个后续下划线
expression.is.not.allowed.as.static.initializer=表达式不允许为 static 初始值设定项
namespace.declarations.cannot.be.nested=命名空间声明不能被嵌套
global.namespace.should.use.braced.syntax=全局命名空间应使用带大括号的语法
halt.compiler.can.only.be.used.from.the.outermost.scope=仅可从最外侧范围使用 '__halt_compiler()'
cannot.use.match.as.identifier=无法将 'match' 用作标识符，自 PHP 8.0 起作为预留关键字
cannot.use.class.on.primitive.type=只允许在对象上使用 '::class'
intention.name.replace.nullable.notation.with.null.as.part.union.type=用 '|null' 替换 '?' 作为联合类型的一部分
intention.name.replace.null.as.part.union.type.with.nullable.notation=将 '|null' 作为联合类型的一部分替换为 '?'
union.types.and.the.nullable.type.notation.cannot.be.mixed=联合类型和可为 null 类型表示法不能混合
union.types.mixed.cannot.be.nullable=混合类型不能为可 null，'null' 已是混合类型的一部分
quick.fix.delete=删除 ''{0}''
type.null.and.false.cannot.be.used.as.as.standalone.type='null' 和 'false' 不可用作独立类型
is.duplicated.by.0=类型被 ''{0}'' 重复
intention.name.remove.duplicated.type=移除重复类型
popup.title.select.reference.to.remove=选择要移除的类型
intention.family.name.append=追加 ''{0}''
intention.family.name.change.to.mixed=将类型更改为 'mixed'
inspection.php.redundant.type.in.union.type=类型声明冗余，可以简化
inspection.php.redundant.type.in.union.type.template=类型声明可以简化为 ''{0}''
inspection.php.redundant.type.in.union.type.fix.name=简化冗余类型

inspection.message.always.true.because=条件始终为 ''{0, choice, 0#false|1#true}''，因为此时 ''{1}'' 已经为 ''{2, choice, 0#false|1#true}''
inspection.nullsafe.deref.unnecessary.because=Nullsafe 运算符{0,choice,0#将始终产生 ''null''|1#不必要}，因为此时 ''{1}'' 已经为 ''{2,choice,0#false|1#true}''
inspection.nullsafe.deref.unnecessary.because.evaluated=Nullsafe 运算符 ''{0,choice,0#将始终产生 ''null''|1#不必要}''，因为此时已评估 ''{1}''
inspection.message.always.true.because.evaluated=条件始终为 ''{0,choice,0#false|1#true}''，因为此时已评估 ''{1}''
hint.evaluation.makes.subsequent.condition.always.true=评估使后续条件始终为 'true'
hint.evaluation.fully.contains=评估结果完全覆盖 ''{0}'' 的可能结果
hint.evaluation.makes.array.always.empty=评估使得数组始终为空
intention.family.name.navigate.to.cause=导航到原因
intention.family.name.replace.ternary.expression.with.true.branch=将三元表达式替换为 ''{0}'' 分支
intention.family.name.replace.elseif.with.else=将 'elseif' 替换为 'else'
extract.condition=提取条件
delete.if=删除 'if'
delete.elseif=删除 'elseif'
action.show.in.log.text=在日志中显示
action.add.file.s.to.list.text=向列表中添加文件
quality.tool.action.remove.file.s.from.list.text=从列表中移除文件
quality.tool.action.clean.list.text=清除列表
quality.tool.border.title.ignored.files=已忽略的文件
quality.tool.ignored.files={0} 忽略的文件
intention.family.name.remove.redundant.arguments=移除冗余的 {0, choice, 0#实参|1#实参}
inspection.message.redundant.argument={0, choice, 0#实参|1#实参}{0,choice,0#匹配|1#匹配}{0, choice, 0#形参的|1#形参的}默认{0, choice, 0#值|1#值}
plural.types.are.not.allowed.in.real.types=仅在 doc 类型中允许复数类型
intention.name.remove.brackets=删除中括号
intention.name.replace.brackets.with.types=替换为 'array'
inspection.message.only.variables.can.be.passed.by.reference=仅可通过引用传递变量
expression.0=表达式 {0}
expression=表达式
notification.content.language.level.was.changed.to.based.on.project.usage=语言级别已根据项目中使用的功能设置为 {0}
action.revert.back.to.text=还原为 {0}
expected.class.reference=应为: 类引用
expected.expression=应为: 表达式
parser.unexpected=意外: {0}
parser.expected=应为: {0}
namespace.cannot.start.with.namespace.due.to.conflict.with.ns.relative.names=由于与 ns 相关名称冲突，命名空间不能以 "namespace" 开头
inspection.php.language.level.description='fn' 是 PHP 7.4 中的保留关键字
incorrect.null.safe.operator=错误的 nullsafe 运算符
replace.with.quest=替换为 '?'
required.parameters.missing=缺少所需形参 ''{0}''
parameter.ref.type.is.not.compatible.with.declaration=形参 '#ref' 类型与声明不兼容
add.remote.interpreter=添加远程解释器
the.remote.hosts.access.plugin.is.missing.please.enable.the.plugin.in.0.plugins=缺少 Remote Hosts Access 插件。请在“{0} | 插件”中启用此插件。
extract.side.effect=提取副作用
delete.unused.element=删除未使用的元素
suppress.all.for.file=对文件全部禁止
callers=调用方
callees=被调用方
call.tree=调用树
execution.statistics=执行统计
suppress.for.method=对方法禁止
suppress.for.function=对函数禁止
delete.redundant.switch.branch=删除冗余 'switch' 分支
suppress.for.phpdoc.comment=对 PhpDoc 注释禁止
dynamically.declared.field=动态声明的字段
convert.closure.to.arrow.function=将闭包转换为箭头函数
suppress.for.file=对文件禁止
choose.a.valid.0.launcher=选择有效的 {0} 启动器
0.location={0} 位置
0.path={0} 路径:
configure=配置
file.0.does.not.exists=文件 {0} 不存在
expressions=表达式
target=目标
creates.a.composer.json.file=创建 composer.json 文件
composer.json.file=composer.json 文件
implement.method=实现方法
split.elseif=拆分 'elseif'
add.setter=添加 setter
php=PHP
filetype.php.description=PHP
remove.redundant.initializer=移除冗余的初始值设定项
delete.assignment=删除赋值
in.0=\ ({0} 中)
merge.nested.conditions=合并嵌套的条件
replace.quotes=替换引号
variable.dereferenced=已取消引用变量
0.1={0}，{1}
declaration.in.parent.class.is.incompatible.with.interface=父类中的声明与接口不兼容
copy.switch.branch=复制 'switch' 分支
default=默认:
replace.if.with.switch=将 'if' 替换为 'switch'
choose.an.alias.to.use=选择要使用的别名
update.signature.to.match.phpdoc.comment=更新签名以匹配 PHPDoc 注释
no.members.to.pull.up.found=未找到要向上拉取的成员
inject.language.using.phpdoc=使用 PHPDoc 注入语言
negate.boolean.expression=布尔表达式求反
no.members.to.push.down.found=未找到要向下推送的成员
replace.if.clause.with.ternary.expression=将 if 子句替换为三元表达式
0.pushing.members.down.will.result.in.them.being.deleted={0}\n\
向下推送成员将导致它们被删除
remove.pass.by.ref.sign=移除 '\\&'
make.non.nullable=设为不可 null
reference=引用
function=函数
foreach=foreach
while=while
0=\ ({0})
for=for
filetype.composer.log.description=Composer 日志
clear.log=清除日志
align.composer.log.console=对齐 Composer 日志控制台
all.0=所有({0})
choose.executable.class.to.run.0=选择用于运行 {0} 的可执行类
show.settings=显示设置
enable=启用
composite.test.patterns=复合测试模式
add.test.class.method=添加测试类/方法…
empty.pattern=空模式
ignore.imports.and.formatting=忽略导入和格式设置
sort.the.elements.by.visibility.public.protected.private=按可见性对元素排序: public、protected、private
sort.by.visibility=按可见性排序
copy=复制
add=添加
replace.ternary.expression.with.if.clause=将三元表达式替换为 if 子句
information=信息
always.show.pass.by.reference=始终显示引用传递
show.name.for.all.arguments=显示所有实参的名称
composer.packages.versions=Composer 软件包版本
constructor.field=构造函数字段
inspection.php.illegal.array.key.type.description={0} {1}
edit.template=编辑模板
remove.rule=移除规则
add.rule=添加规则
choose.super.class.or.interface=选择超类或接口
choose.super.method=选择 super 方法
extends.implements.overrides=扩展/实现/重写
remove.unnecessary.semicolon=移除不必要的分号
choose.properties=选择属性
composer=composer
composer.executable='composer' 可执行文件
0.12={0}:{1}
label=标签
namespace=命名空间
alias=别名
constant=常量
field1=字段
class.constant=类常量
function2=函数
method=方法
class1=类
interface=接口
parameter=形参
variable=变量
cancel=取消
do.not.override=不重写
override=重写
method.name=方法名称
proceed=继续
add.custom.format.function=添加自定义格式函数…
02={0}::
add.class=添加类…
all.exceptions.considered.checked=所有异常均被视为已检查
html.note.core.extensions.are.part.of.the.php.core.and.cannot.be.left.out.of.a.php.binary.with.compilation.options.html=<html>注: 核心扩展是 PHP 核心的一部分，不能放在包含编译选项的 PHP 二进制文件外部。</html>
choose.elements.to.generate.phpdoc.for=选择要为其生成 PHPDoc 的元素
no.elements.to.generate.phpdoc.for=没有任何可为其生成 PHPDoc 的元素
invalid.class.name=无效类名
target.class=目标类:
03=({0})
constant.0=常量 {0}
usage.in.return.type=返回类型中的用法
usage.in.import.statement=import 语句中的用法
overriding.implementing.methods=重写/实现方法
usage.in.type.hinting=类型提示中的用法
usage.in.implements.clause=implements 子句中的用法
usage.in.extends.clause=etends 子句中的用法
method.call=方法调用
function.call=函数调用
04={0}:
field.ref.not.found=找不到字段 '#ref'
method.ref.not.found=找不到方法 '#ref'
0.extends.1={0} 扩展 {1}
0.1.choice.0.extends.1.implements.2={0}{1, choice, 0# 扩展 |1# 执行 }{2}
remove.link.between.0.and.1=移除 {0} 与 {1} 之间的链接
import.from.deployment.configuration=从部署配置导入
import=导入
php.control.flow.viewer.0=PHP 控制流查看器: {0}
php.control.flow.viewer=PHP 控制流查看器
close=关闭(&C)
build.control.flow=构建控制流(&B)
change.member.access=更改成员访问
php.make.class.non.final.quick.fix.family.name=将类设为非 final
squash.repetitive.underscores=压缩重复下划线
replace.with.01=替换为 {0}
filetype.profiler.snapshot.description=分析器快照
proxy.configuration=代理配置
surround.with.0=使用 ''{0}'' 环绕
rename.constructor=重命名构造函数
rename=重命名
replace.with.alias=替换为别名
strict.type.declaration.is.available.in.php.7.only=从 PHP 7.0 起才允许使用严格类型声明
recursive.call=递归调用
smarty=Smarty
add.property=添加 @property
all.scripts=<All scripts>
summary=摘要
can.t.use.nullsafe.operator.in.write.context=在写入上下文中不能使用 nullsafe 运算符
intention.family.name.collapse.whitespaces=收起空格
inspection.message.qualified.name.can.t.contain.whitespaces=限定名称不能包含空格
php.language.level.widget=PHP 语言级别
tooltip.configured.php.language.level.widget=已配置的 PHP 语言级别
tooltip.configured.php.language.level.widget.composer=通过 Composer 配置的 PHP 语言级别
change.php.language.level=更改 PHP 语言级别
function.fqn=函数 FQN
choose.class=选择类
older=较旧的…
intention.family.name.replace.with=替换为 ''{0}''
inspection.message.redundant.static.in.final.class=final 类中有冗余的 'static'
link.label.inspection={0} 检查
intention.name.add.as.function.s.return.type=将 ''{0}'' 作为函数返回类型添加
add.return.type=添加返回类型
php.class=类
php.interface=接口
php.trait=特征
clearing.cache=清除缓存
diagnosing=诊断
simulating.update=模拟更新
generating.autoloader=生成自动加载器
listing.licenses=列出许可证
checking.for.changes.in.code.of.dependencies=检查依赖项代码中的变更
validating=验证
add.custom.format.function1=添加自定义格式函数
edit.custom.format.function=编辑自定义格式函数
no.item=没有项
no.interpreter=<无解释器>
open.in.editor=在编辑器中打开
how.to.fix=修正方法
path.to.php=<php 路径>
constructor.already.exists=构造函数已存在
fluent.setters=Fluent setter
no.private.fields.to.generate.getters.for=没有要为之生成 getter 的 private 字段
no.private.fields.to.generate.both.getters.and.setters.for=没有要为之同时生成 getter 和 setter 的 private 字段
no.private.fields.to.generate.setters.for=没有要为之生成 setter 的 private 字段
choose.methods.to.implement=选择要实现的方法
make.0.1=将 ''{0}'' 设为{1}
arrays.are.not.supported.as.operands.for.0=不支持将数组用作 ''{0}'' 的操作数
types.not.supported.as.operands.for.0.1.2=''{1} {0} {2}'' 中不受支持的操作数类型将导致 PHP 8 TypeError
trait.method.0.will.not.be.applied.because.it.collides.with.1=由于与 ''{1}'' 冲突，因此不会应用特征方法 ''{0}''
method.0.can.t.be.overridden.with.same.trait.1=无法使用相同的特征 ''{1}'' 重写方法 ''{0}''
intention.name.make.non.final=将{0}设为非 final
replace.with.absolute.reference=替换为绝对引用
debug.output=输出
no.candidate.methods.to.implement=没有要实现的候选方法
choose.methods.to.implement1=选择要实现的方法
choose.methods.to.override=选择要重写的方法
no.candidate.methods.to.override=没有要重写的候选方法
cannot.call.abstract.method.0.1=无法调用 abstract 方法 ''{0}::{1}''
intention.name.flip=翻转 {0} 和 {1}
method.ref.is.deprecated=方法 '#ref' 已弃用
parameter.is.deprecated=形参 ''{0}'' 已弃用
function.ref.is.deprecated=函数 '#ref' 已弃用
class.ref.is.deprecated=类 '#ref' 已弃用
constant.ref.is.deprecated=常量 '#ref' 已弃用
field.ref.is.deprecated=字段 '#ref' 已弃用
constant.ref.is.deprecated1=常量 '#ref' 已弃用
inspection.message.duplicate.case.expression=重复 case 表达式
inspection.message.duplicate.case.expression.ref=重复 case 表达式: #ref
replace.qualifier.with.an.import=将限定符替换为导入
inspection.message.method.ref.marked.as.internal=方法 '#ref' 已标记为 @internal
inspection.message.function.ref.marked.as.internal=函数 '#ref' 已标记为 @internal
inspection.message.class.ref.marked.as.internal=类 '#ref' 已标记为 @internal
inspection.message.constant.ref.marked.as.internal=常量 '#ref' 已标记为 @internal
inspection.message.field.ref.marked.as.internal=字段 '#ref' 已标记为 @internal
remove.from.the.parameter.0=从形参 ''{0}'' 中移除 ''\\&''
remove.from.function.0.declaration=从函数 ''{0}'' 声明中移除 ''\\&''
remove.numeric.literals.separators=移除数字文字分隔符
intention.name.remove=移除 {0}
intention.name.convert.array.syntax.to.short=将数组转换为短语法
inspection.message.call.chain.too.long.to.analyse.break.it.into.fragments.up.to.calls=调用链过长，无法进行分析。请将其拆分为最多包含 {0} 个调用的片段
inspection.message.undefined.goto.label.ref=未定义的 goto 标签 '#ref'
inspection.message.unused.private.property.ref=未使用的 private 属性 '#ref'
intention.name.add.method.stubs=添加方法存根
inspection.message.from.php.this.allowed={0}。从 PHP {1} 起才允许这样。
intention.name.make.abstract=将{0}设为 abstract
inspection.message.expression.without.parentheses=表达式没有括号
add.clarifying.parentheses=添加澄清括号
replace.all.occurrences.with.php=将所有匹配项替换为 '<?php'
inspection.message.parentheses.are.unnecessary=圆括号不必要
remove.unnecessary.parentheses=移除不必要的圆括号
inspection.message.goto.labels.inside.loops.or.switch.statements.are.not.allowed=不允许在循环或 switch 语句中使用 'goto' 标签
dialog.title.configure.code.patterns=配置代码模式…
intention.family.name.generate.phpdoc.comment=生成 PHPDoc 注释
intention.family.name.copy.phpdoc.from.parent=从父项复制 PHPDoc
inspection.message.constant.reassignment=常量重新赋值
merge.with.0.branch=与 ''{0}'' 分支合并
inspection.message.use.statement.with.non.compound.name.ref.has.no.effect=包含非复合名称 '#ref' 的 'use' 语句没有任何作用
insert.default.branch=插入 'default' 分支
inspection.message.tostring.method.must.return.string='__toString' 方法必须返回字符串
inspection.message.psr.compound.namespace.with.depth.more.than.two.levels=PSR-12: 复合命名空间的深度超过两级
psr.12.extract.namespace=PSR-12: 提取命名空间
inspection.message.psr.short.form.type.keywords.should.be.used=PSR-12: 应当使用类型关键字的缩写
psr.12.convert.to.short.form=PSR-12: 转换为缩写
inspection.message.psr.missing.visibility.definition=PSR-12: 缺少可见性定义
psr.12.add.public.visibility=PSR-12: 添加 'public' 可见性
inspection.message.psr.order.modifiers.incorrect=PSR-12: 修饰符的顺序不正确
psr.12.fix.modifiers.order=PSR-12: 修复修饰符顺序
inspection.message.psr.missing.parameter.list=PSR-12: 缺少形参列表
psr.12.add.missing.parameter.list=PSR-12: 添加缺少的形参列表
inspection.message.psr.usage.else.if.construct=PSR-12: 使用 'else if' 结构
inspection.message.psr.traits.must.be.included.one.per.line=PSR-12: 必须以每行一个的形式添加特征
psr.12.split.to.several.use.statements=PSR-12: 拆分为多个 'use' 语句
inspection.message.psr.usage.var=PSR-12: 'var' 的用法
psr.12.replace.var.with.public=PSR-12: 将 'var' 替换为 'public'
change.method.modifiers.to.0=将方法修饰符更改为 ''{0}''
intention.family.name.remove=移除 {0}
create.new.class.quickfix=创建新类
add.class1=添加类
intention.name.suppress.for.statement=对语句禁止
intention.name.change.cast.to=将 {0} 转换更改为 {1}
intention.name.cast.to=将 {0} 转换为 {1}
add.fluent.setter=添加 fluent setter
intention.family.name.add.getter.setter=添加 getter 和 setter
intention.family.name.add.getter=添加 getter
intention.family.name.add.number.separators=添加数字分隔符
convert.the.arrow.function.to.a.traditional.closure=将箭头函数转换为传统闭包
intention.name.extract.if=提取 if ({0})
intention.family.name.initialize.properties=初始化属性
merge.into.elseif=合并到 'elseif' 中
intention.family.name.replace.switch.with.if=将 'switch' 替换为 'if'
make.01=设为 ''{0}''
group.use.statements.by.selected.prefix=按所选前缀将 'use' 语句分组
intention.family.name.convert.heredoc.nowdoc.to.string.literal=将 HEREDOC/NOWDOC 转换为字符串文字
intention.family.name.convert.heredoc.to.string.literal=将 HEREDOC 转换为字符串文字
intention.family.name.convert.nowdoc.to.string.literal=将 NOWDOC 转换为字符串文字
convert.concatenation.to.sprintf.call=将串联转换为 'sprintf()' 调用
convert.string.interpolation.to.concatenation=将字符串插值转换为串联
convert.string.interpolation.to.sprintf.call=将字符串插值转换为 'sprintf()' 调用
intention.name.convert.sprintf.call.to.concatenation=将 'sprintf()' 调用转换为串联
copy.concatenated.string.to.clipboard=将串联的字符串复制到剪贴板
extract.selected.string.part.as.concatenation.operand=将所选字符串部分作为串联操作数提取
extract.selected.string.part.as.format.function.argument=将所选字符串部分作为格式函数实参提取
surround.with.if.0.1=使用 ''if({0}({1}))'{'...'}''' 环绕
command.name.new.file=新建文件
dialog.title.inline.variable=内联变量
property.declaration=属性声明
class.constructor=类构造函数
label.global.namespace=<全局命名空间>
cannot.use.positional.argument.after.named.argument=无法在命名实参后面使用位置实参
named.parameter.overwrites.previous.argument=命名形参重写以前的实参
unknown.named.parameter=未知命名形参 ''{0}''
docker.compose.border.title.lifecycle=生命周期
action.configuration.text=配置…
inspection.message.constructor.cannot.be.static=构造函数不能为 static
inspection.message.destructor.cannot.be.static=析构函数不能为 static
inspection.message.clone.method.cannot.be.static='Clone' 方法不能为 static
inspection.message.cannot.make.non.abstract.method.abstract=无法将非 abstract 方法设为 abstract
inspection.message.cannot.override.final.method=无法重写 final 方法
inspection.message.cannot.make.method.visibility.lower.than.super.s=无法将方法的可见性设为低于父级的可见性
parsing.error.not.allowed=不允许使用 ''{0}''
parsing.error.unexpected.token=意外的标记: {0}
parsing.error.expression.not.assignable=表达式不可赋值
live.template.name.comment=注释
php.remote.debug.name=PHP 远程调试
php.web.application.name=PHP Web 应用程序
live.template.name.statement=语句
live.template.name.string.literal=字符串文字
live.template.name.expression=表达式
cli.interpreters.name=CLI 解释器
code.style.option.group.use=将 'use' 分组
code.style.option.attributes=特性
code.style.option.parameter.attributes=形参特性
code.style.option.in.namespace=在命名空间中
code.style.option.php.opening.tag=PHP 起始标记
code.style.option.new.line.after.php.tag=在 '<?php' 标记后换行
code.style.option.align.inline.comments=对齐内联注释
code.style.option.function.return.type=函数返回类型
code.style.option.return.type.on.new.line=返回类型位于新行中
code.style.option.align.key.value.pairs=对齐键值对
code.style.option.match.expression='match' 表达式
code.style.option.match.expression.align.match.arm.bodies=对齐 'match' arm 主体
code.style.option.place.on.new.line=将 ';' 置于新行中
code.style.option.class.field.constant.groups=类属性/常量组
code.style.option.align.properties.in.columns=对齐列中属性
code.style.option.align.constants=对齐常量
code.style.option.align.consecutive.assignments=对齐连续赋值
code.style.option.keep.and.on.one.line=将 ')' 和 '{' 保持在同一行
code.style.option.for.foreach.statements=for()/foreach() 语句
code.style.option.place.for.constructor=放置构造函数的 '()'
code.style.option.in.anonymous.class.declaration=在匿名类声明中
code.style.option.function.constructor.call.arguments=函数/构造函数调用实参
code.style.option.function.declaration.parameters=函数声明形参
code.style.option.in.closure.declaration=在闭包声明中
code.style.option.in.function.declaration=在函数声明中
code.style.option.place.on.new.line2=在最后一个元素后换行
code.style.option.new.line.after=在第一个元素后换行
code.style.option.after='{' 之后:
code.style.option.before.return.statement=在 'return' 语句前:
code.style.option.after.function=函数之后:
code.style.option.after.opening.tag=起始标记之后:
code.style.option.between.group.use.statements=在 'Use' 语句组之间:
code.style.option.around.class.constants=环绕类常量:
code.style.option.after.class.body=类主体之后:
code.style.option.before.class.body=类主体之前:
code.style.option.after.use.statements=在 'Use' 语句后:
code.style.option.before.use.statements=在 'Use' 语句前:
code.style.option.after.namespace=命名空间之后:
code.style.option.before.namespace=命名空间之前:
code.style.option.around.property=环绕属性:
code.style.option.multiplicative.operators=乘法运算符(*, /, %, **)
code.style.option.arrow.function.parentheses=箭头函数括号
code.style.option.anonymous.function.parentheses=匿名函数括号
code.style.option.shift.operators=移位运算符(<<,>>)
code.style.option.and=<?= 和 ?>
code.style.option.brackets.around.variable.expression=使用中括号将变量/表达式括起来
code.style.option.between.and='?' 与 ':' 之间
code.style.option.unary.additive.operators=一元加法运算符(+,-,++,--)
code.style.option.after.unary.not=一元非(!)之后
code.style.option.before.unary.not=一元非(!)之前
code.style.option.array.initializer.parentheses=数组初始值设定项圆括号
code.style.option.function.left.brace=函数左大括号
code.style.option.function.declaration.parentheses=函数声明括号
code.style.option.function.call.parentheses=函数调用括号
code.style.option.after.colon.in.return.type=返回类型中的冒号之后
code.style.option.space.around.pipe.in.union.types=联合类型的 | 周围
code.style.option.before.colon.in.return.type=返回类型中的冒号之前
code.style.option.before.colon.in.named.argument=命名实参中的冒号之前
code.style.option.after.colon.in.named.argument=命名实参中的冒号之后
code.style.option.assignment.in.declare.statement=在 declare 语句中赋值
code.style.option.null.coalescing.operator=null 合并运算符(??)
code.style.option.object.access.operator=对象访问运算符(->)
code.style.option.concatenation=串联(.)
code.style.option.relational.operators=关系运算符(<, >, <=, >=, <=>)
link.label.languages.frameworks.php=PHP
inspection.message.cannot.make.static.method.non.static=无法将 static 方法 {0} 设为非 static
inspection.message.cannot.make.non.static.method.static=无法将非 static 方法 {0} 设为 static
dialog.title.select.properties.to.initialize=选择要初始化的属性
split.selected.group.use.statement=拆分所选 'use' 语句组
intention.family.name.convert.string.literal.to.heredoc.nowdoc=将字符串文字转换为 HEREDOC/NOWDOC
intention.name.convert.string.literal.to.heredoc=将字符串文字转换为 HEREDOC
intention.name.convert.string.literal.to.nowdoc=将字符串文字转换为 NOWDOC
intention.name.convert.concatenation.to.string.interpolation=将串联转换为字符串插值
intention.name.convert.concatenation.to.scalar.value=将串联转换为标量值
intention.name.convert.sprintf.call.to.string.interpolation=将 'sprintf()' 调用转换为字符串插值
intention.name.convert.sprintf.call.to.scalar.value=将 'sprintf()' 调用转换为标量值
parsing.error,at.expected=应为 '@'
parsing.error.method.label.expected=应为方法标签
live.template.class.member=类成员
live.template.interface.member=接口成员
live.template.trait.member=特征成员
dialog.error.title.php.extract.class=PHP 提取类
quality.tools.label.by.default.project.interpreter=默认为项目解释器
file.0.does.not.exist=文件 {0} 不存在
languages.frameworks.php.php.runtime=PHP / PHP 运行时
do.not.ask.again=不再询问
enable.support=启用支持
validating1=正在验证…
cache.creating=正在创建 psalm 缓存…
can.not.parse.phpunit.version.output.0=无法解析 PHPUnit 版本输出: {0}
zend.debugger.settings.broadcasting.is.already.launched=Zend Debugger 设置广播已启动
directories=目录
can.not.run.command.composer.execution.plugin.was.unloaded=无法运行命令: Composer 执行插件已卸载
can.not.find.specified.interpreter=找不到指定的解释器
no.response.from.0.after.1.ms={1} ms 后 {0} 未响应
cannot.register.handler=无法注册处理程序
handler.with.the.same.session.id.is.already.registered=已注册使用相同会话 ID 的处理程序
unknown.debugger.type=未知调试器类型
functions.to.be.extracted=要提取的函数
failed.to.parse.php.ini.output.0=无法解析 php --ini 输出: {0}
can.not.find.0.helper.script=找不到 ''{0}'' 帮助程序脚本
can.not.execute.tests=无法执行测试
failed.to.run.interpreter=无法运行解释器
failed.to.find.interpreter=无法查找解释器
set=设置
proxy.init=代理初始化
register.ide=注册 IDE
0.for.1.run.configuration={1} 运行配置的 {0}
project.is.already.disposed=项目已处置
can.not.execute.transfer.task.project.is.already.disposed=无法执行传输任务: 项目已处置
proxy.stop=代理停止
cancel.ide.registration=取消 IDE 注册
getting.installed.standards=正在获取已安装的标准…
php.remote.interpreter.plugin.is.not.installed=PHP Remote Interpreter 插件未安装
execution.result.is.null=执行结果为 null
can.not.delete.temporary.file.because.it.was.not.created=无法删除临时文件，因为未创建该文件
0.inspection={0} 检查
failed.to.find.valid.interpreter.path=无法查找有效的解释器路径
with.data.set.0=使用数据集 {1} 的 {0}
add.phpunit.test.pattern=添加 PHPUnit 测试模式
unused.code.rules=未使用的代码规则
naming.rules=命名规则
design.rules=设计规则
controversial.rules=有争议的规则
code.size.rules=代码大小规则
remote.interpreter.can.t.be.executed.please.enable.the.php.remote.interpreter.plugin=无法执行远程解释器。启用 PHP Remote Interpreter 插件。
create.target.class.quick.fix=创建目标类快速修复
create.missing.target.method.fix=创建缺少的目标方法修复
php.extract.class=PHP 提取类
local=本地
project.files=项目文件
include.path=include 路径
inspection.message.parameter.name.changed.from.to=形参名称由 ''{0}'' 更改为 ''{1}''
intention.family.name.rename.parameter.to.match.super=重命名形参以匹配父级
intention.name.rename.to=重命名为 ''{0}''
inspection.message.name.parameter.may.be.different.depending.on.instance.class=在 ''{0}.{1}'' 中可能未解析命名实参
tooltip.update=更新 {0}
inspection.message.constant.ref.not.found=未找到常量 '#ref'
hint.text.can.not.find.target.class.for.modification=找不到要修改的目标类。
hint.text.target.class.not.writable=目标类 {0} 不可写。
hint.text.target.class.does.not.belong.to.project.can.not.be.modified=目标类 {0} 不属于该项目\n\
并且无法修改。
inspection.message.cannot.make.non.abstract.method.abstract.1=无法将非 abstract 方法 {0} 设为 abstract
inspection.message.cannot.override.final.method.1=无法重写 final 方法 {0}
inspection.message.return.type.declaration.must.be.compatible.with=返回类型声明必须与 {0} 兼容: {1}
inspection.message.cannot.make.method=无法将 {0} 方法设为 {1} {2}
inspection.message.declaration.should.be.compatible.with=声明应该与 {0} 兼容
inspection.message.declaration.should.be.compatible.with.super=声明应与父级兼容
command.name.make.method.static=将方法设为 static
show.constants=显示常量
show.properties=显示属性
show.includes=显示 include
show.private.members=显示 private 成员
show.protected.members=显示 protected 成员
undefined.interpreter=未定义的解释器
column.name.annotation.name=注解名称
inspection.message.exception.never.thrown.in.corresponding.try.block=相应的 ''try'' 块中从未抛出异常 ''{0}''
dialog.title.edit.phpunit.test.pattern=编辑 PHPUnit 测试模式
notification.title.incorrect.profiler.snapshot.format=分析器快照格式不正确
notification.title.cannot.read.snapshot=无法读取快照
label.lt.no.server=<no server>
executable.0.was.not.found.in.path.please.make.sure.it.s.there.possible.solutions=在 %PATH% 中找不到可执行文件 ''{0}''。请确保已指定有效路径。可能的解决方案:
if.you.ve.changed.the.path.recently.restart.the.ide=如果最近更改了 %PATH%，请重启 IDE。
provide.the.full.path.to.executable=提供可执行文件的完整路径。
select.composer.phar.and.provide.the.full.path.to.it.or.select.download.composer.stable.phar.from.getcomposer.org=选择 'composer.phar' 并提供其完整路径，或者选择“从 getcomposer.org 下载 composer-stable.phar”。
executable.0.was.not.found.in.path.please.make.sure.it.s.there.possible.solutions1=在 $PATH 中找不到可执行文件 ''{0}''。请确保已指定有效路径。可能的解决方案:
if.you.ve.changed.the.path.recently.restart.the.ide1=如果最近更改了 $PATH，请重启 IDE。
select.composer.phar.and.provide.the.full.path.to.it.or.select.download.composer.stable.phar.from.getcomposer.org1=选择 'composer.phar' 并提供其完整路径，或者选择“从 getcomposer.org 下载 composer-stable.phar”。
label.authentication.data.not.specified=未指定身份验证数据
configured.is.incorrect=配置的 {0} 不正确
validation.script.was.created.but.it.cannot.be.executed.check.possible.reasons=验证脚本已创建，但无法执行。可能的原因:
validated.web.server.is.not.running=验证的 Web 服务器未运行。
target.directory.for.validation.script.is.not.public=验证脚本的目标目录不是 public。
url.to.validation.script='验证脚本的 URL'
follow.this.links.to.install.and.configure.0.or.1=点击这些链接以安装并配置 {0} 或 {1}。
if.you.have.already.configured.debug.extension.in.php.ini.file.check.possible.reasons.why.it.was.not.loaded=如果已在 php.ini 文件中配置调试扩展，请检查未加载该扩展的可能原因:
you.did.not.reload.web.server.after.changes.in.php.ini.file=在 php.ini 文件中进行更改后，未重新加载 Web 服务器。
you.are.configuring.debug.extension.in.the.wrong.php.ini.see.the.loaded.php.ini.files.below=您正在错误的 php.ini 中配置调试扩展(请参见下方已加载的 php.ini 文件)。
there.are.errors.on.attempt.to.load.debug.extension.e.g.version.incompatibility=尝试加载调试扩展时出错，例如版本不兼容。
intention.name.change.signature=更改 {0}({1}) 的签名
dialog.title.enter.tag.name=输入标记名称
method1=方法
open.inspection.settings=打开 {0} 检查设置
popup.content.enabled.disabled.extensions=已启用{0}和已禁用{1}扩展
popup.content.configuration.remains.unchanged=当前配置与解释器同步
unhandled.0=未处理的{0}
unhandled.exceptions=未处理的异常
label.docker.container=Docker 容器:
dialog.message.docker.account.not.specified=未指定 Docker 帐户
dialog.message.docker.account.not.found=找不到 Docker 帐户
dialog.message.could.not.find.network.interface=找不到 {0} 网络接口
dialog.message.no.interface.addresses.for.network.interface=没有 {0} 网络接口的接口地址
validation.script.will.be.created.in.0.directory=验证脚本将在 {0} 目录中创建。
files.in.the.directory.should.be.accessible.by.0.request=目录中的文件应当可通过 {0} 请求进行访问。
caused.by.0=原因是:“{0}”
validation.script.will.be.created.in.0.directory.and.deployed.to.the.1.server=验证脚本将在 {0} 目录中创建并部署到 {1} 服务器。
files.in.the.remote.directory.should.be.accessible.by.0.request=远程目录中的文件应当可通过 {0} 请求进行访问。
follow.this.0.for.more.information.about.path.mappings=有关路径映射的详细信息，请参阅{0}。
validation.script.will.be.created.locally.and.the.result.will.be.fetched.by.http.request=验证脚本将在本地创建，其结果将通过 http 请求提取。
validation.script.will.be.created.locally.and.deployed.to.the.remote.server=验证脚本将在本地创建并部署到远程服务器。
the.result.of.validation.will.be.fetched.by.http.request=验证结果将通过 http 请求提取。
follow.this.0.for.more.information.about.deployment=有关部署的详细信息，请参阅此{0}。
link=链接
no.type=NO_TYPE
in=位于
action.configure.php.runtime.text=配置 PHP 运行时…
action.configure.project.directories.text=配置项目目录
inspection.message.interpolated.string.dereferencing.available.in.php.only=从 PHP 8.0 起才允许插值字符串解引用
inspection.message.magic.constant.dereferencing.available.in.php.only=从 PHP 8.0 起才允许魔术常量解引用
intention.family.name.add.name.identifiers.to.all.arguments.starting.from.current=从当前位置开始将名称标识符添加到所有实参
intention.name.add.name.identifier=添加名称标识符 ''{0}''
inspection.message.argument.without.name.identifier=无名称标识符的实参
tooltip.wsl2.mappings=WSL2 映射
name=名称
file=文件
tooltip.from=来自{0}:
tooltip.from.volumes=来自{0}卷:
intention.family.name.sort.arguments=对实参排序
open.tool.settings=打开 {0} 设置
init.cache=初始化缓存
or.disable.inspection=或
inspection.message.type.can.be.reduced.to=类型范围可以缩小为 ''{0}''
an.alias.was.defined.for.method.0.which.exists.in.1=已为 {1} 中的方法 {0}() 定义别名
intention.family.name.append.absolute.trait=追加 ''{0}::''
intention.family.name.remove.argument.name=移除实参名称
intention.name.remove.argument.names.from.all.arguments.up.to.current=从截止到当前位置的所有实参中移除实参名称
frameworl.composer.show.quick.actions=显示具有快速操作的 composer.json 顶部面板
framework.composer.notify.about.missing.vendor=缺少 'vendor' 目录时通知
cannot.make.interface.method.non.static=无法将接口方法设为非 static
cannot.make.interface.method.static=无法将接口方法设为 static
access.must.be.public=访问必须为 public
inspection.message.method.reference.resolves.to.method.with.containing.class=''Use'' 规则解析为包含类 ''{0}'' 中的方法
intention.name.move.trait.use.rule.to.use.list=将特征 ''use'' 规则移动到 ''{0}'' ''use'' 列表
intention.family.name.move.trait.use.rule.to.resolved.class.use.list=将特征 'use' 规则移动到解析的类 'use' 列表
required.trait.0.wasn.t.added.to.1=所需特征 ''{0}'' 未添加到 ''{1}''
intention.family.name.add.trait.to.use.list=将特征添加到 use 列表
intention.name.add.trait.to.use.list=将特征 ''{0}'' 添加到 use 列表
intention.family.name.add.break.as.last.statement=将 'break' 作为最后一条语句添加
inspection.message.class.does.not.have.attribute=类 ''{0}'' 未使用 ''Attribute'' 注解
intention.family.name.add.attribute.attribute=使用 'Attribute' 注解
constant.expression.contains.invalid.operations=常量表达式包含无效运算
attribute.must.be.first.child.of.parent.element=特性必须是父元素的第一个子项
intention.family.name.move.attribute.to.start.element=将特性移动到元素开头
quickfix.remove.match.arm=移除 'match' arm
quickfix.remove.duplicate.condition=移除重复条件
quickfix.remove.unused.condition=移除未使用的条件
inspection.duplicate.match.condition.message=重复条件
inspection.message.attribute.can.t.be.applied.to.because.it.doest.contains=特性不能应用于 {0}，因为它不包含 ''{1}'' 标志
inspection.message.attribute.is.not.repeatable=特性不可重复，因为它不包含 'Attribute::IS_REPEATABLE' 标志
class2=类
class.constant1=类常量
property=属性
parameter1=形参
inspection.message.comment.will.be.parsed.as.attribute.starting.with.php=从 PHP 8.0 起注释被解析为特性
intention.family.name.insert.space.after=在 '#' 后面插入一个空格
inspection.message.condition.is.never.matched=条件从未匹配
inspection.php.arithmetic.type.check=带有不支持操作数的算术运算
introduce.variable.fix=引入变量
hint.text.use.statement.choice.s.removed={0} ''use'' 语句{1, choice, 0#|1#}已移除
hint.text.use.statements.checked.nothing.was.removed=已检查 {0} ''use'' 语句，未移除任何内容
no.name=无名称
debugger.method=方法
inspection.message.named.argument.usage=命名实参用法
percentage.lines={0}% 行
column.name.parameter=形参
column.name.file.directory=文件/目录
unknown=未知
intention.family.name.replace.with.get.class.call=替换为 'get_class()' 调用
intention.family.name.replace.with.class.name.literal=替换为 '::class'
inspection.message.get.class.call.can.be.replaced.with.class.name.literal='get_class()' 调用可替换为 '::class'
intention.family.name.remove.parenthesis=移除圆括号
inspection.message.redundant.parenthesis=冗余圆括号
intention.family.name.simplify.expression=简化表达式
intention.family.name.replace.match.with.ternary=替换为三元表达式
attribute.can.be.added.to.overridden.method=可以将特性添加到重写方法
attribute.can.be.added.to.overridden.parameter=可以将特性添加到重写形参
intention.family.name.add.attribute.to.overridden.method=将特性添加到重写方法
intention.family.name.add.attribute.to.overridden.method.of.abstract.method=将特性添加到抽象方法的重写方法
intention.family.name.add.attribute.to.overridden.parameter=将特性添加到重写形参
inspection.message.match.can.be.replaced.with.ternary='match' 表达式可替换为三元表达式
intention.family.name.replace.with.traditional.property.declaration=替换为传统属性声明
cannot.declare.promoted.property.outside.a.constructor=无法在构造函数外部声明提升的属性
only.visibility.modifiers.can.be.applied.to.promoted.property=只能将可见性修饰符应用到提升的属性
intention.family.name.replace.with.public=替换为 'public'
cannot.declare.variadic.promoted.property=无法声明可变提升属性
cannot.declare.promoted.property.in.an.abstract.constructor=无法在 abstract 构造函数中声明提升的属性
inspection.message.promoted.field.usage=提升的属性用法
inspection.message.redundant.assignment=冗余的提升属性赋值
remove.assignment=移除赋值
inspection.message.switch.can.be.replaced.with.match='switch' 语句无法转换为 'match' 表达式
intention.family.name.replace.switch.with.match.expression=将 'switch' 替换为 'match' 表达式
intention.family.name.split.into.multiple.catch.statements=拆分为多个 'catch' 语句
exception.class=异常类
variable1=变量
identifier=标识符
field.name=字段名称
object.property=对象属性
class.reference=类引用
array.index=数组索引
line.separator=行分隔符
initializer=初始值设定项
label1=标签
expression1=表达式
type=类型
static.value=static 值
property.or.function=属性或函数
default.value=默认值
extends=扩展
interface.name=接口名称
extends.or.implements=扩展或实现
class.name=类名
modifier=修饰符
return.type=返回类型
inspection.message.duplicates.catch.statement=重复 ''{0}'' 语句
intention.name.merge.with=与 ''{0}'' 合并
intention.family.name.merge.with.duplicated.catch.statement=与重复的 'catch' 语句合并
intention.name.merge.with.match.arm=与 ''{0}'' arm 合并
intention.family.name.merge.with.duplicated.match.arm=与重复的 'match' arm 合并
intention.family.name.add.default.match.arm=添加 'default' 'match' arm
intention.family.name.add.attribute=添加 ''#[{0}]''
inspection.message.exitpoint.attribute.can.be.added=可以添加 #[NoReturn] 特性
intention.family.name.convert.to.promoted.field=转换为提升的属性
intention.family.name.convert.to.promoted.field.remove.doc.comment=转换为提升的属性并移除属性 PHPDoc 注释
inspection.message.field.assignment.can.be.converted.to.promoted.field=可以提升属性
cannot.use.unpacking.in.attribute.argument.list=无法在特性实参列表中使用解包
spread.operator.on.named.arguments.is.forbidden=禁止对命名实参使用展开运算符
inspection.message.should.be.one=值应为以下选项之一: {0}
0.by.remote.interpreter=通过远程解释器{0}
0.local={0}本地
inspection.message.double.quotes.are.unnecessary=双引号不必要
inspection.php.unnecessary.double.quotes.display.name=不必要的双引号
inspection.php.unnecessary.leading.backslash.in.use.statement='use' 语句中有不必要的前导 '\'
replace.unnecessary.double.quotes=替换不必要的双引号
quality.tool.can.not.create.temporary.file=PhpStorm 无法创建临时文件
dialog.message.cannot.create.file.because.project.already.disposed=由于项目已处置，无法创建文件
dead.code.commented.out=注释掉
dead.code.deleted=已删除
intention.family.name.add.arrayshape.attribute=添加 '#[ArrayShape]' 特性
inspection.message.arrayshape.can.be.added=可以添加 '#[ArrayShape]'
inspection.option.label.php8.severity=PHP 8 严重性:
inspection.message.pure.can.be.added=可以添加 ''{0}''
intention.name.add.to.parameter=将 ''\\&'' 添加到形参 ''{0}''
intention.family.name.add.to.parameter=将 '\\&' 添加到形参
inspection.message.array.write.access.unused=未使用数组写入访问
intention.family.name.remove.pure=移除 '#[Pure]'
inspection.message.function.may.produce.side.effects=函数可能会产生副作用
inspection.message.method.may.produce.side.effects=方法可能会产生副作用
inspection.message.immutable.property.write.scope.does.not.allow.write.access.here=无效的不可变属性写入: 作用域 ''{0}'' 不允许在此处进行写入访问
php.console=PHP 控制台
inspection.message.illegal.array.offset.access=尝试访问类型为 ''{0}'' 的值的数组偏移
attributes.are.inapplicable.for.constants=特性不适用于常量
intention.family.name.replace.with.define.call=替换为 'define()' 调用
inspection.message.leading.slash.in.constant.fqn.will.not.be.trimmed.by.php=PHP 不会修剪常量 FQN 中的前导斜杠
intention.family.name.remove.leading=移除前导 '\'
intention.family.name.replace.with.const.syntax=替换为 'const' 语法
inspection.message.can.be.replaced.with.const.syntax=可替换为 'const' 语法
intention.family.name.force.fqcn.for.references.in.phpdoc=对 PHPDoc 中的引用强制 FQCN
constants.may.only.evaluate.to.scalar.values.arrays.or.resources=常量只能计算为标量值、数组或资源
intention.family.name.merge.with.following.attribute.list=将特性列表与以下内容合并
intention.family.name.extract.attribute.into.separate.list=将特性提取到单独的列表
intention.family.name.flip.attributes.lists=翻转特性列表
inspection.message.too.many.messages.per.line=每行的消息过多
inspection.message.too.many.messages.per.file.only.first.errors.warnings.are.shown=每个文件中的消息过多。仅显示前 {0} 条。
can.not.correctly.run.the.tool.with.parameters=无法使用形参正确运行该工具:
possible.tool.process.hangup.after.0.sec={0} 秒后可能工具过程挂起。
inspection.message.write.access.to.variable.that.still.references.array.value=对仍引用 'foreach' 中先前所用数组值的变量的写入权限
if.with.common.parts=具有通用部分的 'if'
switch.with.common.parts=包含通用部分的 'switch'
intention.family.name.insert.unset.before=在前面插入 ''unset(${0});''
intention.family.name.collapse.if.statement=收起 ''{0}'' 语句
intention.family.name.extract.common.parts.with.removing.branch=提取通用部分，并移除分支
intention.family.name.extract.common.parts=提取通用部分
inspection.message.if.statement.with.common.parts=包含通用部分的 ''{0}'' 语句
intention.name.replace.with=将 ''{0}'' 替换为 ''{1}''
inspection.message.property.only.written.but.never.read=属性仅写入，但从未读取
inspection.message.property.only.read.but.never.written=属性只读取，但从未写入
intention.family.name.delete.field=删除属性
intention.family.name.replace.with.class.constant=替换为类常量
invalid.condition.to.body.separator.should.be.used=条件与主体之间的分隔符无效: 应改用 '=>'
intention.family.name.invert.if.statement=反转 'if' 语句
intention.family.name.unwrap.else=解开 'else'
inspection.message.unnecessary.else=不必要的 'else'
inspection.message.array.always.empty.at.this.point=数组在此点始终为空
intention.family.name.can.be.merged.with.sequential=''if'' 可以与后续 ''{0}'' 合并
intention.family.name.merge.with.sequential=与后续 ''{0}'' 合并
inspection.message.behavior.unparenthesized.expressions.containing.both.will.change.in.php=同时包含 ''.'' 和 ''{0}'' 的无括号表达式可能会产生意外结果
intention.name.wrap.left.operand.in.parentheses=在圆括号中包装左操作数
intention.name.wrap.right.operand.in.parentheses=在圆括号中包装右操作数
parameter.type.is.not.convertible.from.null=形参类型不可从 'null' 转换
inspection.message.value.parameter.always=形参值始终为 ''{0}''
intention.family.inline.value.for.parameter=内联形参值
intention.name.inline.value=内联值 ''{0}''
inspection.message.can.be.replaced.with.version=表达式可替换为 '??' 版本
inspection.message.if.can.be.replaced.with.version='if' 可替换为 '??' 版本
intention.family.name.replace.with.version=替换为 '??' 版本
intention.family.name.replace.with.ternary.expression=替换为三元表达式
popup.title.multiple.write.scopes.found=找到多个写入范围
closest.scope=最近范围中的变量
all.values=所有变量
checkbox.rename.only.nearest.scope=仅重命名最近范围中的变量
intention.family.name.make.method.void=将方法设为 'void'
inspection.message.return.value.method.never.used=方法的返回值从未使用
inspection.message.unnecessary.leading.slash=不必要的前导 '\'
inspection.message.cast.redundant=类型转换冗余
inspection.message.unnecessary.curly.braces=不必要的大括号
intention.family.name.unwrap.curly.braces=解开大括号
command.name.disable.synchronisation.with.composer=禁用与 composer.json 同步
navigate.to.composer.json=导航到 composer.json
notification.content.language.level.synchronisation.with.composer.was.disabled=已禁用与 composer.json 的语言级同步
inspection.message.can.be.replaced.with.direct.parameter.access='func_get_arg' 可替换为直接形参访问
intention.family.name.replace.with.parameter.access=替换为形参访问
intention.family.name.unwrap.function.call=解开函数调用
inspection.message.with.single.string.argument=带单个字符串实参的 ''{0}''
inspection.message.for.loop.can.be.replaced.with.str.repeat='for' 循环可替换为 'str_repeat'
intention.family.name.replace.with.str.repeat.call=替换为 'str_repeat()' 调用
inspection.message.for.loop.can.be.replaced.with.implode='foreach' 循环可替换为 'implode()'
intention.family.name.replace.with.implode.call=替换为 'implode()' 调用
intention.family.name.unwrap.cast=解开转换
inspection.message.unnecessary.cast.to.string=不必要地转换为 ''{0}''
intention.family.name.merge.with.assignment=与赋值合并
inspection.message.concatenation.can.be.merged.with.assignment.empty.string.literal=串联可以与空字符串文字赋值合并
inspection.message.operands.have.incompatible.types=操作数具有不兼容的类型
short.arrow.function.cannot.return.void=箭头函数不能有 'void' 返回类型
delete.void.return.type=删除 'void' 返回类型
array.callback.must.have.exactly.two.elements=数组回调必须正好有两个元素
intention.family.name.split.into.separate.case.statements=拆分为独立的 'case' 语句
invalid.syntax.for.multiple.case.expressions=多个 'case' 表达式的语法无效
cannot.mix.keyed.and.unkeyed.array.entries.in.assignments=在赋值中不能混合键控和非键控数组条目
cannot.use.empty.array.entries.in.keyed.array.assignment=在键控数组赋值中不能使用空数组条目
cannot.use.empty.list=无法使用空列表
unsupported.declare.0=不支持的声明 ''{0}''
inspection.message.continue.targeting.switch.equivalent.to.break=针对 'switch' 的 'continue' 相当于 'break'
inspection.message.redundant.expression=冗余表达式
strict.types.declaration.must.have.0.or.1.as.its.value='strict_types' 声明的值必须为 0 或 1
private.methods.cannot.be.final=private 方法不能是 final，因为它们从不会被其他类重写
cannot.use.yield.from.inside.a.by.reference.generator=不能在引用传递生成器中使用 'yield from'
intention.family.name.replace.with.check=替换为 '!==' 检查
dialog.title.select.methods.to.propagate.safe.delete=选择要传播安全删除的方法
dialog.title.select.parameters.to.propagate.safe.delete=选择要传播安全删除的形参
referenced.calls=引用的调用
cannot.mix.and.list=不能混合 [] 与 list()
intention.family.name.replace.with.array=替换为数组
intention.family.name.replace.with.list=替换为 'list'
inspection.message.can.be.replaced.with=可替换为 ''{0}''
intention.family.name.remove.unused.postfix.operation=移除未使用的后缀运算
inspection.message.results.postfix.expression.unused=未使用后缀表达式的结果
intention.family.name.add.doc.tag.with.throws.tags=使用 @throws 标记添加 PHPDoc 注释
replace.variable.assignment.with.named.argument=将变量赋值替换为命名实参
action.run.composer.install.text=运行 'composer install'
notification.content.vendor.directory.not.found=未找到 'vendor' 目录
intention.family.name.move.from.to.composer.json.section=将 ''{0}'' 从 ''{1}'' 移至 ''{2}'' composer.json 部分
intention.family.name.flip=翻转 '?:'
inspection.message.can.be.removed=可以移除 ''{0}''
intention.family.name.remove.unused.property=移除未使用的属性
intention.family.name.simplify.ternary.expression=简化 '?:'
inspection.message.should.probably.not.be.passed.as.parameter=''{0}'' 可能不应作为参数 ''{1}'' 传递
inspection.message.should.probably.not.be.assigned=''{0}'' 可能不应分配给 ''{1}''
extract.method.selector.title=要提取的代码
intention.family.name.replace.with.operator=替换为 '?->' 运算符
inspection.message.can.be.replaced.with.operator=可替换为 '?->' 运算符
add.throw.before.exception=在表达式前面添加 'throw'
intention.family.name.replace.with.dirname.call=替换为 'dirname()' 调用
inspection.php.redundant.method.override=冗余方法重写
inspection.php.loop.can.be.replaced.with.implode=循环可替换为 'implode()'
inspection.message.redundant.method.override=方法重写冗余
delete.redundant.method.override=移除方法
intention.family.name.replace.if.with.version=将 'if' 替换为 '??' 版本
anonymous.class=匿名类
anonymous.0=匿名{0}
lambda=Lambda
checkbox.anonymous.classes=匿名类
checkbox.lambdas=Lambda
inspection.message.trait.usage=不允许特征用法
inspection.message.will.be.covered.by=非必要条件，因为它由 ''{0}'' 检查
inspection.message.can.be.replaced.with.fail=可替换为 ''{0}''
intention.name.replace.coalesce.expression.with.operand=将合并表达式替换为操作数
intention.name.replace.coalesce.expression.with=将合并表达式替换为 ''{0}''
label.align.named.arguments=对齐命名实参
delete.catch.statement=删除 'catch' 语句
inspection.message.exception.immediately.rethrown=立即重新抛出异常
inspection.message.dangerous.array.initialization=危险的数组初始化
replace.with.array=替换为直接赋值 '$array = array($value)'
intention.family.name.replace.with.comparison=替换为比较
quickfix.undefined.function.add.function=添加函数
PhpLanguageLevel.8.1.0.presentable.name=8.1
PhpLanguageLevel.8.1.0.short.description=枚举、'never' 返回类型、交叉类型、'readonly' 属性
PhpLanguageFeature.enum.classes=从 PHP 8.1 起才允许使用枚举
annotation.new.expression.enum=无法实例化枚举 ''{0}''
enum.may.not.include.0=枚举不得包含 ''{0}''
enum.may.not.include.extend=枚举不得扩展其他类
enums.may.not.include.properties=枚举不得包含属性
enums.may.not.be.cloned=不得克隆枚举
intention.family.name.make.containing.class.enum=将包含类设为枚举
enum.properties.are.immutable=枚举属性不可变
enum.backing.type.must.be.int.or.string=枚举支持类型必须为 'int' 或 'string'
enum.case.type.0.does.not.match.enum.backing.type.1=枚举 case 类型 ''{0}'' 与枚举支持类型 ''{1}'' 不匹配
all.cases.of.backed.enum.must.have.a.value=后备枚举的所有 case 必须包含值
case.of.non.backed.enum.must.not.have.a.value=非后备枚举的 case 不得包含值
intention.family.name.delete.initializer=删除初始值设定项
intention.family.name.add.to.containing.enum=将 '' : {0}'' 添加到包含枚举
intention.family.name.remove.backed.type.from.containing.enum=从包含枚举中移除后备类型
enum.case.should.be.located.only.inside.enum.classes=枚举 case 只应位于枚举类内部
enum.case.value.must.be.constant=枚举 case 值必须为常量
enum.backing.type.must.be.int.or.string.0.given=在给出 ''{0}'' 的情况下，枚举支持类型必须为 ''int'' 或 ''string''
code.style.option.before.colon.in.enum.backed.type=在后备枚举中类型声明旁边的冒号前面
code.style.option.after.colon.in.enum.backed.type=在后备枚举中类型声明旁边的冒号后面
enum.case=枚举 case
enums.may.not.implement.the.serializable.interface=枚举可能不会实现 'Serializable' 接口
cannot.redeclare.methods.from.enum.implicit.interfaces=无法从枚举隐式接口重新声明方法
cannot.implement.interface.0=无法实现接口 ''{0}''
cannot.implement.interface.0.directly=无法直接实现接口 ''{0}''
non.enum.class.cannot.implement.interface=非枚举类无法实现接口 ''{0}''
non.backed.enum.cannot.implement.interface.backedenum=非后备枚举无法实现接口 'BackedEnum'
intention.family.name.count.comments.as.content=将注释计为内容
inspection.php.class.constant.accessed.via.child.class=通过子类引用的类常量
inspection.message.constant.from.base.class.referenced.via.child.class=通过子类引用的基类 ''{0}'' 中的常量
intention.family.name.replace.with.class.reference.with.base.class=替换为对基类的类引用
intention.replace.with.method.call=替换为对现有方法的调用
inspection.php.uncovered.enum.cases=某些 enum case 未被覆盖
inspection.message.uncovered.enum.cases='match' 表达式具有未被覆盖的 enum case
intention.family.name.add.remaining.enum.cases=添加剩余 enum case
add.enum.declaration.quick.fix.text=添加枚举 case
intention.family.name.split.into.two.separate.match.arms=将条件提取到单独的 'match' arm
multiple.enum.identifiers.should.be.stated.in.different.cases=多个枚举标识符应在不同的 case 中声明
replace.with.array.short.syntax=替换为直接赋值 '$array = [$value]'
intention.family.name.split.into.multiple.enum.cases=拆分为多个枚举 case
inspection.message.uncovered.enum.cases.switch='switch' 语句有未被覆盖的枚举 case
inspection.php.unused.switch.case.inspection.display.name=未使用的 'switch' 分支
inspection.message.branch.is.unused=从不执行 'switch' 分支
inspection.missing.doc.comment.options.panel.ignore.private.members=忽略 private 成员
code.style.option.place.braces.for.constructor.as.is=保留原样
code.style.option.place.braces.for.constructor.always=始终
code.style.option.place.braces.for.constructor.never=从不
settings.smart.keys.auto.insert.semicolon=在函数调用内部键入时自动插入分号 
inspection.php.foreach.over.single.element=对只有一个元素的数组文字执行 Foreach
intention.family.name.unwrap.foreach=解开 'foreach'
inspection.message.foreach.over.array.literal.with.single.element=对只有一个元素的数组文字执行 ‘foreach’
inspection.php.condition.can.be.replaced.with.min.max.call=条件可替换为 'min()'/'max()' 调用
inspection.message.can.be.replaced.with.min.max.call=可替换为 ''{0}'' 调用
intention.family.name.replace.with.min.max.call=替换为 'min()'/'max()' 调用
intention.name.replace.with.min.max.call=替换为 ''{0}'' 调用
quickfix.navigate.to.duplicate.case.value=导航到重复的 case 值
duplicate.value.in.enum.for.cases.0.and.1=case ''{0}'' 和 ''{1}'' 的枚举中的重复值
inspection.php.idempotent.operation=二进制表达式中的幂等运算
inspection.message.expression.not.changed.after.applying=应用 ''{0}'' 后，表达式不会改变
inspection.php.array.push.with.single.element=只有一个元素的 'array_push()'
inspection.message.array.push.with.single.element=只有一个元素的 'array_push'
unwrap.switch=解开 switch…
inspection.switch.with.single.case=只有一个 'case' 的 'switch'
inspection.message.switch.has.only.default.case=switch 只有 'default' case
inspection.message.switch.has.only.single.case=switch 只有一个 case
intention.family.name.replace.with.if=替换为 'if'
PhpLanguageFeature.return.never=自 PHP 8.1 起才允许使用返回类型 'never'
classes.named.never.is.forbidden.in.php.8.1=PHP 8.1 中禁止名为 'never' 的类
inspection.php.never.typed.function.returning.value='never' 类型的函数返回一个值
never.can.only.be.used.as.return.type='never' 只能用作返回类型
inspection.message.never.returning.function.must.not.return='never' 返回函数不得返回
delete.case=删除 'case'
inspection.php.internal.array.index.reset.is.unnecessary=无需数组内部指针重置
inspection.php.enforce.doc.comment.inspection.display.name=强制执行 PHPDoc 注释
remove.unnecessary.reset=移除不必要的 'reset'
refactoring.inline.function.cannot.inline.overridden.method=无法内联被重写的方法
intention.family.name.replace.with.array.assignment=替换为数组赋值
inspection.php.empty.index.operator.not.supported.for.strings=字符串不支持 '[]' 运算符
inspection.php.array.search.can.be.replaced.with.in.array='array_search()' 可替换为 'in_array()' 调用
intention.family.name.replace.with.in.array.call=替换为 'in_array()' 调用
inspection.message.can.be.replaced.with.in.array.call=可替换为 ''{0}'' 调用
inspection.php.preg.match.without.regular.expression='preg_match' 可替换为 'str_contains'
inspection.message.can.be.replaced.with.str.function=可替换为 ''{0}''
intention.family.name.replace.with.str.function.call=替换为 ''{0}'' 调用
inspection.php.group.regexp=正则表达式
PhpLanguageFeature.final.class.constants=自 PHP 8.1 起只允许使用 'final' 类常量
intention.family.name.replace.in.array.with.disjunction=将 'in_array()' 替换为 '||'
intention.message.replace.in.array.with.disjunction=将 ''in_array()'' 替换为 ''{0}''
intersection.types.and.the.nullable.type.notation.cannot.be.mixed=交叉类型和可 null 类型表示法不能混用
cannot.mix.amp.and.pipe.in.type.declaration=类型声明中不能混用 '\\&' 和 '|'
PhpLanguageFeature.intersection.types=从 PHP 8.1 起才允许交叉类型
intention.family.name.evaluate.cast=替换为 ''{0}''
intention.name.evaluate.cast=评估转换
inspection.message.cast.evaluable=转换可替换为 ''{0}''
inspection.php.cast.is.evaluable=对标量值进行类型转换
cannot.use.readonly.as.identifier=无法将 'readonly' 用作标识符。自 PHP 8.1 起作为预留关键字
PhpLanguageFeature.readonly.properties=从 PHP 8.1 起才允许使用 'readonly' 属性
PhpLanguageFeature.new.in.init=从 PHP 8.1 起才允许在初始值设定项中使用 'new'
globals.can.only.be.modified.using.the.globals.name.value.syntax='$GLOBALS' 只能使用 '$GLOBALS[$name] = $value' 语法进行修改
inspection.php.match.can.be.replaced.with.switch.statement='match' 可替换为 'switch' 语句
inspection.message.match.can.be.replaced.with.switch='match' 表达式可转换为 'switch' 语句。
intention.family.name.replace.match.with.switch.statement=将 'match' 替换为 'switch' 语句
intention.family.name.replace.match.with.switch.statement.changing.semantics=将 'match' 替换为 'switch' 语句(可能会改变比较语义)
PhpLanguageFeature.explicit.octal.literal=自 PHP 8.1 起只允许显式八进制文字
inspection.php.acessing.static.trait.members=正在访问 static 特征成员
inspection.message.calling.static.trait.member=直接调用 static 特征成员已弃用。只应在使用特征的类上访问。
intention.family.name.replace.with.self.access=替换为 'self::' 访问
inspection.message.returning.by.reference.from.void.function.deprecated=从 void 函数通过引用返回已弃用
intention.family.name.collapse.statement.into.parameter.default.value=将语句收起到形参的默认值中
inspection.message.statement.can.be.collapsed.into.parameter.default.value=语句可以收起到形参的默认值中
label.successors=后继
label.predecessors=前驱
inspection.php.covered.element.in.class=类中的元素已被覆盖
inspection.message.element.already.covered.by=''{0}'' 已被 ''{1}'' 覆盖
intention.family.name.delete.covered.element=删除已覆盖的元素
inspection.php.ranges.in.class.can.re.merged=类中的范围可以合并
inspection.message.can.be.merged.with=可以与 ''{0}'' 合并
intention.family.name.merge.with.adjustment.range=与调整后的范围合并
intention.name.prepend.default.case=预置 'default'
popup.title.select.target.code.block=选择目标代码块
popup.select.target.code.block.closure=箭头函数体(转换为闭包)
popup.select.target.code.block.containing.block=包含块
refactoring.inline.function.cannot.find.function.declaration=找不到函数声明
private.constant.cannot.be.final='private' 常量不能为 'final'，因为它对其他类不可见
cannot.override.final.constant=无法从 ''{1}'' 重写 final 常量 ''{0}''
intention.family.name.replace.with.implicit.octal.notation=替换为隐式八进制表示法
inspection.message.match.can.be.replaced.with.switch.changing.semantics='match' 表达式可以转换为 'switch' 语句。请注意，'switch' 语句依赖于松散比较，这可能会改变表达式语义。
php.intention.category=PHP
inspection.php.deprecated.stdlib.call=已弃用的标准库调用
inspection.message.argument.with.type.deprecated.for.this.call=类型为 ''{0}'' 的实参对此调用已弃用
inspection.message.call.without.arguments.deprecated=不带实参的 ''{0}'' 调用已弃用
inspection.php.array.index.immediately.rewritten=数组索引会被立即重写
intention.family.name.navigate.to.rewrite.expression=导航到重写表达式
inspection.message.array.index.immediately.rewritten.before.accessing=数组索引在访问之前会被立即覆盖
inspection.php.implicit.octal.literal.can.be.replaced.with.explicit.one=隐式八进制文字可替换为显式八进制文字
inspection.message.replace.implicit.octal.literal.with.explicit.one=隐式八进制文字可替换为显式八进制文字
inspection.family.name.replace.implicit.octal.literal.with.explicit.one=将隐式八进制文字替换为显式八进制文字
inspection.php.object.fields.are.only.written=局部对象仅用于写入属性
inspection.message.local.object.used.only.for.writing.properties=局部对象仅用于写入属性
inspection.php.redundant.array.call.in.foreach.iterated.value=对 'foreach' 中迭代的值的冗余 'array_values' 调用
intention.family.name.replace.with.argument=替换为实参
inspection.message.array.values.call.redundant='array_values' 调用冗余
readonly.property.must.have.type=只读属性必须指定类型
inspection.php.unit.assert.always.execute.to.same.result=实参类型不兼容的 'assertTrue()'
inspection.message.assert.always.will.be.false=实参类型不兼容，因为 'assertTrue()' 执行与 'true' 的严格比较
expected.property=属性
inspection.array.to.string.conversion=数组到字符串的转换
inspection.message.array.to.string.conversion=数组到字符串的转换
inspection.php.invalid.string.offset.usage=字符串偏移用法无效
inspection.message.cannot.use.string.offset.as.object=无法将字符串偏移用作对象
inspection.message.cannot.use.assign.op.operators.with.string.offsets=无法将组合运算符赋值与字符串偏移一起使用
inspection.message.cannot.unset.string.offsets=无法取消设置字符串偏移
inspection.message.cannot.increment.decrement.string.offsets=无法递增/递减字符串偏移
inspection.message.cannot.create.references.to.from.string.offsets=无法创建到/从字符串偏移的引用
inspection.message.cannot.use.string.offset.as.array=无法将字符串偏移用作数组
intention.inline.method.family.name=内联方法
inspection.message.cannot.assign.empty.string.to.string.offset=无法将空字符串分配给字符串偏移
inspection.message.only.first.byte.will.be.assigned.to.string.offset=只有第一个字节将被分配给字符串偏移
static.property.cannot.be.readonly='static' 属性不能为 'readonly'
inspection.message.second.write.to.readonly.property=无法修改 'readonly' 属性
inspection.php.second.write.to.readonly.property=第二次写入 'readonly' 属性
inspection.php.unnecessary.spread.operator.for.function.call.argument=函数调用实参的不必要展开运算符
inspection.message.spread.operator.can.be.unwrapped=展开运算符可以解开
inspection.message.spread.operator.over.literal.unnecessary.for.arguments.resolved.to.variadic.parameter=对于解析为可变形参的实参，文字上的展开运算符不必要
intention.family.name.unwrap.spread.operator=解开展开运算符
inspection.message.write.access.to.readonly.property.outside.declaration.scope=无法写入声明范围之外的 'readonly' 属性
inspection.php.write.access.to.readonly.property.outside.declaration.scope=对声明范围之外的 'readonly' 属性的写入权限
build.control.flow.with.exit.points=使用出口点构建控制流(&E)
inspection.message.comment.can.be.replaced.with.named.argument=注释可替换为命名实参
intention.family.name.replace.with.named.argument=替换为命名实参
inspection.message.can.be.replaced.with.named.argument=可替换为命名实参
PhpLanguageFeature.first.class.callable.syntax=从 PHP 8.1 起才允许一级可调用语法
intention.family.name.replace.with.closure.fromCallable=替换为 'Closure::fromCallable(...)'
cannot.create.closure.for.new.expression=无法为 'new' 表达式创建 'Closure'
replace.with.arrow.function=替换为箭头函数
replace.with.anonymous.function=替换为匿名函数
label.interpreter=解释器: {0}
cannot.combine.nullsafe.operator.with.closure.creation=无法将 nullsafe 运算符与 'Closure' 创建组合
replace.with.coalesce.operator=替换为合并运算符
intention.family.name.initialize.property.in.constructor=初始化构造函数中的属性
inspection.php.field.immediately.rewritten=属性会被立即重写
inspection.message.field.immediately.rewritten.before.accessing=属性在访问之前会被立即覆盖
inspection.redundant.intersection.type=冗余的交叉点类型
inspection.redundant.intersection.type.fix=交叉点类型可以简化为 ''{0}''
inspection.redundant.intersection.type.fix.name=简化交叉点类型
anonymous.function=匿名函数
expected.expression.after.spread.operator=应为: 展开运算符后的表达式
action.com.jetbrains.php.internal.PhpCreateYoutrackIssueFromFileAction.text=在 WI (PhpStorm) 项目中根据文件内容创建 YouTrack 问题
action.com.jetbrains.php.internal.PhpCreateYoutrackIssueFromSelectionAction.text=在 WI (PhpStorm) 项目中根据所选内容创建 YouTrack 问题
inspection.php.nested.min.max.call=嵌套的 'min/max' 调用
inspection.message.nested.call.can.be.unwrapped=嵌套的 ''{0}'' 调用可以解开
intention.family.name.unwrap.call=解开调用
type.0.cannot.be.part.of.an.intersection.type=类型 ''{0}'' 不能是交叉点类型的一部分
inspection.php.duplicate.character.in.str.function.call=函数调用中的重复字符
inspection.message.duplicate.character=重复字符
inspection.php.autovivification.on.false.values='false' 到数组的自动转换已弃用
inspection.message.write.access.to.readonly.property.outside.declaration.scope.ret.by.ref='readonly' 属性通过引用返回，可能会泄漏到声明范围之外
inspection.message.array.key.unused=数组密钥未使用
refactoring.inline.variable.unary.operation=无法内联到递减或递增运算
inspection.message.variable.already.equal.to.assigned.value=变量已等于赋值
inspection.php.modulo.operation.with.one=以 '1' 为操作数的取模运算
intention.family.name.replace.with.zero=替换为 ''{0}''
inspection.message.expression.always.choice=表达式始终为 ''{0}''
intention.family.name.replace.with.compile.time.result=替换为编译时结果
inspection.php.deprecated.serializable.interface.usage.inspection.display.name=已弃用的 'Serializable' 接口用法
class.implements.the.serializable.interface.which.is.deprecated=在不使用 '__serialize()'/'__unserialize()' 方法的情况下实现 'Serializable' 接口已弃用
add.serialize.magic.methods=添加{0}方法
add.serialize.magic.method=添加{0}方法
refactoring.move.classes.dnd.name=移动类
refactoring.move.classes.dnd.title=将所选{0,choice,0#类|1#命名空间|2#类和命名空间}移动到命名空间:
group.advanced.settings.php=PHP
advanced.setting.php.max.chain.resolve.depth=解析成员引用的最大深度
function.has.parameter.with.incompatible.default.value.type=函数有一个默认值与其声明的类型不兼容的形参
inspection.php.unit.deprecated.call.in.phpunit.10=方法在 PHPUnit 10 中已弃用
intention.family.name.replace.with.suggested.call.in.phpunit=替换为 PHPUnit 10 中建议的调用
inspection.message.function.deprecated.will.be.removed.in.phpunit=方法已弃用并已在 PHPUnit 10 中移除
code.style.option.force.empty.functions.braces.in.one.line=将空函数/方法的大括号放在一行
inspection.php.autovivification.on.false.values.possible=可能会导致将 'false' 转换为数组，这一转换已弃用
php.change.signature.conflict.with.local.var=形参 ''{0}'' 与函数 ''{1}'' 内的局部变量冲突
php.change.signature.conflict.with.local.var.method=形参 ''{0}'' 与来自 ''{2}'' 的方法 ''{1}'' 内的局部变量冲突
refactoring.move.classes.dnd.files.with.the.same.name.error=单个目标中不允许有多个同名文件。
dialog.message.execution.quality.tools.in.untrusted.project.prohibited=禁止在不受信任的项目中执行质量工具
untrusted.composer.dialog.text=正在安装或更新依赖项，或者运行 Composer 命令可能会执行潜在的恶意代码。\n\
\n\
如果不信任此源，请继续使用安全模式。
inspection.undefined.field.notify.dynamic.read=通知对动态属性的读取权限
inspection.php.too.long.member.reference.chain=成员引用链过长，无法分析
php.test.framework.untrusted.reload=在安全模式下禁止刷新测试框架的版本
inspection.message.instanceof.checks.in.catch.can.be.replaced.with.specific.catches='catch' 块中的 'instanceof' 检查可替换为特定的 catch
inspection.php.instanceof.checks.in.catch.can.be.replaced.with.specific.catches='catch' 块中的 'instanceof' 检查可替换为特定的 catch
intention.family.name.replace.instanceof.checks.in.catch.with.specific.catches=将 'catch' 块中的 'instanceof' 检查替换为特定的 catch
no.in.line.parameter.name.hints.will.be.shown.for.methods.matching.any.of.these.patterns=对于匹配其中任一模式的方法，都不会显示任何嵌入形参名称提示。
patterns.are.matched.on.fully.qualified.name.parameter.count.and.parameter.names=模式会通过完全限定名称、形参计数和形参名称进行匹配。
you.can.always.add.a.precise.exclusion.via.alt.enter.and.then.edit.it.to.broaden.as.needed=您始终可以通过 Alt-Enter 组合键添加精确排除，然后根据需要对其进行编辑以扩大范围。
code.global.code.matches.function.with.two.parameters={0} 匹配带有两个形参的函数。
code.info.code.matches.all.single.parameter.methods.where.the.parameter.name.ends.with.em.info.em={0} 匹配形参名以 {1} 结尾的所有单形参方法。
code.key.value.code.matches.all.methods.with.parameters.em.key.em.and.em.value.em={0} 匹配所有具有形参 {1} 和 {2} 的方法。
code.fully.qualified.classname.methodname.key.value.code.example.precise.match={0} 是一个精确排除的示例。
key=键
value=值
inspection.php.if.can.be.replaced.with.match.expression='if' 可替换为 'match' 表达式
intention.family.name.replace.if.with.match.expression=将 'if' 替换为 'match' 表达式
inspection.message.can.be.replaced.with.match.expression='if' 语句可替换为 'match' 表达式
inspection.php.duplicate.operand.in.comparison=比较中的重复操作数
intention.family.name.remove.duplicate.operand=移除重复操作数
inspection.message.expression.have.duplicate.operand=表达式有重复的操作数 {0}
refactoring.inline.function.cannot.inline.first.class.callable.declaration=无法内联一级可调用声明
php.replace.try.from.with.null.quick.fix.family.name=将 'tryFrom()' 调用替换为 'null'
inspection.php.array.append.using.count=使用 'count()' 作为索引将值追加到数组
inspection.message.count.used.as.array.index.to.append.element='count' 用作数组索引以追加元素
info=信息
quickfix.change.field.type.to.match.super.0=将类型更改为 ''{0}'' 以匹配父项
quickfix.change.field.type.to.match.super.remove=移除类型声明以匹配父项
inspection.message.readonly.property.non.readonly=无法将 'readonly' 属性重新声明为非 'readonly'
inspection.message.non.readonly.property.readonly=无法将非 'readonly' 属性重新声明为 'readonly'
intention.family.name.remove.readonly.modifier=移除 'readonly' 修饰符
intention.family.name.add.readonly.modifier=添加 'readonly' 修饰符
inspection.php.unit.invalid.mocking.target=无效的模拟目标
inspection.message.methods.cannot.be.mocked=''{0}'' 方法无法模拟
final=final
enum=枚举
inspection.message.classes.cannot.be.doubled=''{0}'' 类无法重复
inspection.message.cannot.stub.or.mock.using.method.list.that.contains.duplicates=不能使用包含重复项的方法列表进行存根或模拟
intention.family.name.navigate.to.duplicate.method.name=导航到重复的方法
inspection.php.property.can.be.readonly=属性可以为 'readonly'
inspection.message.property.can.be.readonly=属性可以为 'readonly'
text.plain=文本/纯
enum.value.cannot.referer.to.enum.cases=枚举值不能引用枚举 case
inspection.php.internal.array.index.reset.is.unnecessary.navigate.to.function=导航到重置数组内部指针的函数
inspection.php.pow.call.can.be.replace.with.pow.operator='pow()' 调用可替换为 '**' 运算符
replace.with.pow.operator=替换为 '**' 运算符
group.methods.by.type=按类型对方法分组
inspection.php.private.method.may.be.inaccessible.in.late.static.binding.call=在延迟 static 绑定调用期间可能无法访问 private 方法
inspection.message.existing.overriding.private.method.may.be.inaccessible=现有的重写 private 方法可能无法访问
inspection.message.existing.overriding.private.method.may.be.inaccessible.method=重写 private 方法 ''{0}'' 可能无法访问
intention.family.name.navigate.to.possibly.inaccessible.methods=导航到可能无法访问的方法
overriding.private.methods=重写 private 方法
refactoring.inplace.extract.method.name=就地提取函数/方法
PhpExtractMethodDialog.generate.php.doc.inplace=生成 PHPDoc
extract.method.link.label.more.options=更多选项
inspection.php.short.echo.open.tag.description=短 echo 起始标记用法
replace.all.occurrences.with.php.echo=将所有匹配项替换为 '<?php echo'
inspection.php.short.open.echo.tag.inspection.display.name=短起始 'echo' 标记用法
inspection.php.autoload.declaration.is.deprecated=已弃用的 '__autoload()' 函数声明
intention.family.name.replace.with.spl.autoload.register.call=替换为 'spl_autoload_register()' 调用
inspection.message.deprecated.autoload.declaration='__autoload()' 声明已弃用
inspection.message.prohibited.autoload.declaration=禁止使用 '__autoload()' 声明
inspection.option.label.php73.severity=PHP 7.3 严重性:
inspection.php.assert.declaration.is.deprecated=已弃用的 'assert()' 函数声明
inspection.message.defining.custom.assert.function.forbidden=禁止定义自定义 'assert()' 函数
inspection.message.defining.custom.assert.function.deprecated=定义自定义 'assert()' 函数已弃用
checkbox.use.composer=添加 'composer.json'
border.title.require.dependencies='require' 依赖项
border.title.require.dev.dependencies='require-dev' 依赖项
require='需要'
status.text.no.dependencies=无依赖项
border.title.additional.dependencies=其他依赖项
inspection.php.unknown.modifier=Unknown modifier ''{0}''
inspection.php.preg.match.can.be.replaced.with.comparison='preg_match()' can be replaced with comparison
inspection.php.deprecated.modifier=Modifier ''{0}'' is deprecated since PHP {1}
composer.version.update.hint=The current version and available updates for installed packages.
inspection.php.inappropriate.inherit.doc.usage.class.description=@inheritDoc used for class without parent class with doc comments
code.style.option.multiline.arrays.lambdas=Treat multiline arrays/anonymous functions as multiline arguments
ActivateSpringProfileIntentionAction.activate.profile=激活配置文件 ''{0}''
ActivateSpringProfileIntentionAction.activate.profile.family.name=激活配置文件
ActivateSpringProfileIntentionAction.deactivate.profile=停用配置文件 ''{0}''
ActivateSpringProfileIntentionAction.deactivate.profile.family.name=停用配置文件
AsyncMethodInspection.incorrect.signature=使用 @Async 注解的方法应返回 'void' 或 "Future-like" 类型
AsyncMethodInspection.inspection.display.name=不正确的 @Async 方法签名
AutowireBeanGenerateAction.popup.beans.title=自动装配 Bean
AutowireBeanGenerateAction.search.beans.progress.title=正在搜索 Bean…
ChangeActiveProfileDialogUi.radio.button.comment=逗号分隔的配置文件列表
ChangeActiveProfileDialogUi.radio.button.context=上下文
ChangeActiveProfileDialogUi.radio.button.module=模块
ChangeActiveProfileDialogUi.radio.button.profiles=配置文件\:
ChangeActiveProfileDialogUi.radio.button.project=项目
ChangeActiveProfileDialogUi.radio.button.scope=作用域\:
ContextComponentScanInconsistencyInspection.annotation.is.expected.here=此处应为注解
ContextJavaBeanUnresolvedMethodsInspection.cannot.resolve.method=无法解析方法
ContextJavaBeanUnresolvedMethodsInspection.display.name=@Bean 注解中未知的 init/destroy 方法
GenerateEventListenerMethodAction.command.title=生成事件侦听器方法
GenerateEventListenerMethodAction.popup.context.events=上下文
GenerateEventListenerMethodAction.popup.lifecycle.events=生存期
GenerateEventListenerMethodAction.popup.other.events=其他
GenerateEventListenerMethodAction.popup.project.events=项目
GenerateEventListenerMethodAction.popup.title=选择事件
GenerateEventListenerMethodAction.search.events.progress.title=正在搜索事件…
ImplicitSubclassInspection.display.bean.in.configuration=@Configuration 中的 @Bean 方法必须可重写
ImplicitSubclassInspection.display.forClass.annotated=使用 ''@{0}'' 注解的类可以隐式子类化且不得为 final
ImplicitSubclassInspection.display.forMethod.annotated=使用 ''@{0}'' 注解的方法必须可重写
ScheduledMethodInspection.incorrect.signature=@Scheduled 方法不得包含任何实参，也不应返回任何内容
ScheduledMethodInspection.inspection.display.name=不正确的 @Scheduled 方法签名
SpringAutowiredFieldsWarningInspection.inspection.display.name=不推荐的字段注入
SpringAutowiringInspection.add.qualifier.fix=添加限定符
SpringBeanMoveHandler.choose.file=选择文件
SpringBeanMoveHandler.no.other.files.found=未找到其他 Spring 文件
SpringContextConfigurationInspection.cannot.find.default.app.context=找不到默认应用程序上下文文件 {0}
SpringContextConfigurationInspection.create.nested.configuration.class=创建嵌套 'ContextConfiguration' 类
SpringEventListenerInspection.inspection.display.name=错误配置的 @EventListener 方法
SpringInactiveProfilesHighlightingPass.inactive.profile=停用配置文件
SpringIncorrectResourceTypeInspection.expected.resource.types=资源类型不正确。预期类型\: {0}
SpringIncorrectResourceTypeInspection.incorrect.resource.type=不正确的资源类型
SpringSpiRegistrationAnnotator.choose.registration=选择注册
SpringSpiRegistrationAnnotator.spring.factories.registration=spring.factories 注册
SpringSpiRegistrationAnnotator.tooltip=导航到 'spring.factories' 中的注册
SpringStaticMembersAutowiringInspection.display.name=对 static 类成员不正确的 Spring 组件自动装配或注入
SpringUpdateSchemaIntention.schema.update.failed.for.invalid.file=针对无效文件 {0} 的架构更新失败
SpringUpdateSchemaIntention.spring.schema.update=Spring 架构更新
UnparsedCustomBeanInspection.unsupported.tag=命名空间 ''{1}'' 不支持标记 ''{0}''，请提交问题(帮助|{2})
abstract.class.not.allowed=抽象类不允许用于非 abstract Bean
action.DumpSpringConfiguration.text=转储 Spring  配置
action.Spring.Beans.Generate.Autowiring.Action.text=自动装配 Bean…
action.Spring.Beans.Generate.Autowiring.Filter.Separator.text=筛选
action.Spring.Beans.Generate.Autowiring.SearchInLibraries.Action.text=显示库中的内容
action.Spring.Beans.Generate.Autowiring.ShowBeanImplAction.Action.text=显示 Bean 实现类
action.Spring.Beans.Generate.Autowiring.ShowPackagesAction.Action.text=显示软件包
action.Spring.Beans.Generate.Autowiring.ShowProjectBeans.Action.text=显示项目 Bean
action.Spring.Beans.Generate.Autowiring.ShowRepositoryBeans.Action.text=显示仓库
action.Spring.Beans.Generate.Autowiring.ShowServices.Action.text=显示服务
action.Spring.Beans.Generate.Autowiring.UseGroupsAction.Action.text=使用组
action.Spring.Beans.Generate.Autowiring.View.Separator.text=视图
action.Spring.Beans.Generate.Autowiring.ViewSuperClassesAction.Action.text=按基类分组
action.Spring.Beans.Generate.Constructor.Dependency.Action.text=Spring 构造函数依赖项…
action.Spring.Beans.Generate.Setter.Dependency.Action.text=Spring Setter 依赖项…
action.Spring.Beans.View.Configuration.Implicit.text=显示隐式 Bean
action.Spring.Beans.View.Configuration.Infrastructure.text=显示 XML 架构 Bean
action.Spring.Create.Component.Generate.description=创建一个新的 Spring 组件
action.Spring.Create.Component.Generate.text=Spring 组件…
action.Spring.Create.Component.Java.description=创建一个新的 Java Spring 组件
action.Spring.Create.Component.Java.text=Spring 组件 (Java)
action.Spring.Create.Component.Kotlin.description=创建一个新的 Kotlin Spring 组件
action.Spring.Create.Component.Kotlin.text=Spring 组件 (Kotlin)
action.Spring.Create.Component.dialog.title=新建 Spring 组件
action.Spring.Create.Context.File.text=Spring 配置
action.Spring.Events.Generate.Listener.text=事件侦听器…
action.SpringChangeActiveProfiles.text=更改有效 Spring 配置文件…
action.SpringConfigurationCheckAction.text=检查 Spring 配置
action.generate.autowired.dependencies.action.text=@Autowired 依赖项…
application.context.configuration=应用程序上下文配置
autowired.dependencies.goto.related.item.group.name=自动装配的依赖项
bean.autowiring.by.type=无法自动装配。存在多个 ''{0}'' 类型的 Bean。Bean\: {1}。属性\: ''{2}''
bean.autowiring.by.type.no.beans=无法自动装配。找不到 ''{0}'' 或 ''{1}'' 类型的 Bean。
bean.autowiring.by.type.no.parameter.for.autowired.method=无形参的自动装配 {0}
bean.autowiring.by.type.none=无法自动装配。找不到 ''{0}'' 类型的 Bean。
bean.bad.property.type=''{0}'' 类型的属性不能由 ''{1}'' 注入
bean.class.autowired.by.type=无法自动装配。存在多个 ''{0}'' 类型的 Bean。
bean.class.autowired.incorrect.qualifier.type=无法自动装配。限定 Bean 必须为 ''{0}'' 类型。
bean.class.unknown.qualifier.bean=找不到具有限定符 ''{0}'' 的 Bean
bean.method.called.from.configuration.without.proxy=使用 @Bean 注解的方法直接在 proxyBeanMethods 设置为 false 的 @Configuration 中调用。将 proxyBeanMethods 设置为 true 或使用依赖项注入。
bean.method.called.without.proxy=直接调用使用 @Bean 注解的方法。请改用依赖项注入。
bean.property.extract.name=将属性值提取到配置文件
cacheable.and.cache.put.on.the.same.method=Spring 不建议在同一方法上使用 @CachePut 和 @Cacheable 注解
cacheable.annotations.should.be.defined.on.public.methods=应在 public 方法上定义缓存注解
cacheable.no.cache.could.be.resolved.for.cache.operation=必须为每个缓存操作至少提供一个非空缓存名称。
cacheable.should.be.defined.on.concrete.method=Spring 不建议使用 @Cache* 注解对接口方法进行注解
cannot.autowire.bean.of.type=无法自动装配。Bean 必须为 ''{0}'' 类型
cannot.find.bean.constructor.with.parameters.count=在类 ''{0}'' 中未找到匹配的构造函数
cannot.find.bean.qualified.by=找不到使用 {0} 限定的 Bean
cannot.find.constructor.arg.index=找不到实参索引为 {0} 的构造函数
cannot.find.constructor.arg.index.in.class=在类 {1} 中找不到实参索引为 {0} 的构造函数
cannot.find.factory.method.index=在类 {1} 中找不到实参索引为 {0} 的工厂方法
cannot.find.factory.method.with.parameters.count=在类中未找到匹配的工厂方法
change.active.profile.dialog.context=上下文 ''{0}''
change.active.profile.dialog.module=模块 ''{0}''
change.active.profile.dialog.spring.profiles=更改有效 Spring 配置文件
checkbox.remember.my.choice=记住我的选择
checking.spring.configuration=检查模块 ''{0}'' 中的 Spring 配置
class.is.not.spring.bean.autowired=必须在有效 Spring Bean 中定义自动装配成员(@Component|@Service|…)
class.without.matching.constructor.for.autowiring=类不包含用于自动装配的匹配构造函数
component.scan.setup.inspection.key=@ComponentScan 或其元注解中无效的软件包
config.detecting.contexts=正在检测应用程序上下文…
config.display.name=配置
config.file.is.not.spring=该文件未被识别为 Spring 配置
config.file.not.found=找不到文件
config.files.not.found=未找到文件
config.new.file=Spring 配置
config.no.contexts.defined=未定义应用程序上下文
config.unmapped.configs.popup.title={0} 中未映射的 Spring 配置文件
configuration.tab.additional.settings=附加设置
constructor.arg.incorrect.value.type=注入值类型必须对应于构造函数实参类型
context.schema.inspection.name=基于 XML 的组件扫描中无效的筛选器定义
create.component.action.this.already.exists=文件 {0} 已存在
create.component.fix.text=创建 ''{0}'' 组件…
create.component.rename.reference=重命名类引用
create.missing.mappings=为 ''{0}'' 创建缺少的映射
create.missing.mappings.family.name=创建缺少的映射
create.missing.properties=创建缺少的属性
create.new.spring.configuration.file=创建新的 Spring 配置文件
custom.bean.no.id=IntelliJ IDEA 在配置文件中找不到此 Bean 的 ID。重命名可能会生成错误的代码。是否要继续?
custom.bean.no.id.title=警告
custom.namespace.quick.fixes.create.custom.namespace.bean=创建自定义命名空间 Bean ({0} 个变体)…
custom.namespace.quick.fixes.create.custom.namespace.bean.with.id=创建自定义命名空间 Bean {0}
custom.namespace.quick.fixes.create.name=创建 {0}
custom.namespace.quick.fixes.family.name=创建自定义命名空间 Bean
custom.namespace.quick.fixes.popup.title=创建自定义命名空间 Bean
custom.namespace.registration.inspection.key='spring.handlers' 或 'spring.schemas' 文件中未解析的文件或类引用
dependency.node.in.module.tail=(在模块 {0} 中)
do.you.want.to.move.bean.to.the.top.level=是否要将该 Bean 移至顶层?
duplicated.bean.name.inspection.name.view.duplicates=查看重复项
duplicated.bean.quick.fix.description=导航到重复项
duplicated.bean.quick.fix.popup.title=查看重复项
editor.panel.profiles.tooltip=有效配置文件
editor.panel.profiles.tooltip.action.name=更改配置文件…
event.listener.method.parameters.count=方法必须最多只有一个形参
event.listener.method.visibility.nonstatic=使用 @EventListener 注释的方法必须为非 static
facet.context.autodetected.suffix=(自动检测)
facet.context.code.files=基于代码的配置
facet.context.default.name=Spring 应用程序上下文
facet.context.edit.add.file.choose.type=选择类型
facet.context.edit.name.label=名称(&N)\:
facet.context.edit.name.validation.already.exists=具有此名称的上下文已存在。如果已删除具有此名称的现有上下文，则必须首先使用“应用”。
facet.context.edit.name.validation.not.empty=名称不得为空
facet.context.edit.parent.label=父上下文(&P)\:
facet.context.edit.parent.none.selected=<none>
facet.context.edit.title=编辑应用程序上下文 ''{0}''
facet.context.new.title=新建应用程序上下文
facet.context.other.files=其他文件
facet.context.properties.files=附加属性文件
facet.context.remove.message=确实要移除应用程序上下文“{0}”吗? (不会删除任何文件)
facet.context.remove.title=移除
facet.context.xml.files=基于 XML 的配置
field.injection.add.parameter.family.warning=更改字段注入。向构造函数添加形参
field.injection.add.parameters=<html>向构造函数添加形参\: {0}</html>
field.injection.create.constructor.family.warning=更改字段注入。创建构造函数
field.injection.create.constructor.injection=<html>创建构造函数\: {0}</html>
field.injection.is.not.recommended=不建议使用字段注入
fileset.circular.dependencies=上下文之间的循环依赖关系\:<br/>{0}<br/>{1}
fileset.contains.testing.configs.full=用于测试的{0, choice, 1\#配置文件|1< {0, number} 个配置文件}<em>不得</em>添加到上下文\:<br/>{1}
fileset.contains.testing.configs.short=用于测试的{0, choice, 1\#配置文件|1< {0, number} 个配置文件}<em>不得</em>添加到上下文
fileset.editor.help.label=<html>通过 <b>\\&lt;import …/\\&gt;</b> 或 <b>@Import</b> 引用的配置文件将隐式添加。<br/>用于测试的配置文件<em>不得</em>添加到上下文。</html>
group.Internal.Spring.text=Spring
group.Spring.Beans.Generate.Action.text=Spring Bean
group.spring.components=组件
group.spring.config=配置
gutter.choose.autowired.candidates.title=选择自动装配的候选项
gutter.choose.bean.factory.calls.title=选择 BeanFactory.getBean(…) 用法
gutter.navigate.no.bean.factory.calls=未找到匹配的 BeanFactory 用法
gutter.navigate.no.matching.autowired.candidates=未找到匹配的自动装配候选项
gutter.navigate.no.matching.beans=未找到匹配的 Bean
gutter.navigate.to.autowired.candidates.title=导航到自动装配的候选项
gutter.navigate.to.bean.factory.calls.title=导航到 BeanFactory.getBean(…) 用法
idref.cannot.be.added.in.collection=无法添加到 ''{0}'' 类型的集合中
incorrect.constructor.arg.index.not.unique=索引必须唯一
injection.lookup.defaultMethodCommentText=此方法将被 Spring 重写并返回 {0} 的新实例
inspection.group.code=代码
inspection.group.xml=XML
interface.not.allowed=非抽象 Bean 不允许接口
internal.error.parsing.bean=解析 Bean 时出现内部错误;输出\:\n{0}
introduce.bean.intention=引入 Bean
live.template.bean.description=Spring '@Bean' 模板
live.template.component.description=Spring '@Component' 模板
live.template.configuration.description=Spring '@Configuration' 模板
live.template.service.description=Spring '@Service' 模板
logical.spring.bean.autowired.in=自动装配到
logical.spring.bean.autowires=自动装配
logical.spring.bean.implementations=实现
logical.spring.bean.requires=要求
logical.spring.configuration.imports=导入
logical.spring.event.listeners=侦听器
logical.spring.event.publishers=发布程序
logical.spring.scanned.components=已扫描的组件
logical.spring.service.methods=方法
mark.bean.as.abstract=将 Bean 标记为 abstract
message.navigation.available.during.indexing=索引编制期间导航不可用
method.cannot.instantiate.bean=工厂方法  ''{0}'' 无法实例化 Bean
method.must.be.public=工厂方法 ''{0}'' 应为 public
method.must.be.static=工厂方法 ''{0}'' 必须为 static
method.must.not.be.static=工厂方法 ''{0}'' 不得为 static
method.parameters.removing.fix.family.name=移除方法形参
method.parameters.removing.fix.text=将 ''{0}'' 更改为无实参
method.return.type.make.async.family.name=更改方法以返回 "Future-like" 值
method.return.type.make.async.fix.text=更改方法以返回 ''{0}''
model.add.constructor.args.for.method.quickfix.description=生成缺失的 'constructor-arg' 标记
model.add.constructor.args.for.method.quickfix.message=为 ''{0}'' 添加 <constructor-arg>
model.add.constructor.args.for.method.quickfix.message.family.name=添加 <constructor-arg>
model.bean.not.found.error.message=找不到名称为 ''{0}'' 的 Bean
model.bean.quickfix.message=创建新 Bean ''{0}''
model.bean.quickfix.message.family.name=创建新 Bean
model.goto.related.item.group.application.context=Spring 应用程序上下文
model.goto.related.item.group.context=Spring 上下文\:“{0}”
model.goto.related.item.group.test.context=Spring 测试上下文
model.inspection.bean.autowiring=不正确的 XML Spring Bean 自动装配
model.inspection.bean.constructor.arg=XML Spring Bean 中不正确的构造函数注入
model.inspection.bean.factory.method=在 "factory-method" 特性中引用的错误定义的方法
model.inspection.bean.property.value=XML 应用程序上下文中不可分配的注入点类型
model.inspection.bean.public.factory.method=在 "factory-method" 特性中引用的不正确的非 public 方法
model.inspection.display.bean.name.convention=Spring Bean 名称违反约定
model.inspection.display.name=不正确的 Spring Core 基于 XML 的应用程序上下文
model.inspection.inactive.profile=停用配置文件高亮显示
model.inspection.injection.value.add.array=添加 <array> 标记
model.inspection.injection.value.add.list=添加 <list> 标记
model.inspection.injection.value.add.map=添加 <map> 标记
model.inspection.injection.value.add.ref=添加 "ref" 特性
model.inspection.injection.value.add.set=添加 <set> 标记
model.inspection.injection.value.consistency=XML 应用程序上下文中不一致的注入值
model.inspection.injection.value.entry.key=映射条目必须指定键
model.inspection.injection.value.message={0} 必须指定一个 ref 或 value
model.inspection.injection.value.style=XML 应用程序上下文中的注入值违反约定
model.inspection.injection.value.style.message=使用了显式 <value> 元素
model.inspection.injection.value.style.ref.fix=将 <ref> 元素替换为“{0}”特性
model.inspection.injection.value.style.ref.fix.family.name=将 <ref> 元素替换为特性
model.inspection.injection.value.style.ref.message=使用了显式 <ref> 元素
model.inspection.injection.value.style.value.fix=将 <value> 元素替换为“{0}”特性
model.inspection.injection.value.style.value.fix.family.name=将 <value> 元素替换为特性
model.inspection.invalid.identifier.message=''{0}'' 未遵循 Bean 命名约定
model.inspection.invalid.lowercase.name.message=''{0}'' 应以小写字母开头
model.inspection.validator.progress.text=正在验证 Spring 模型…
model.method.choose.method=选择方法
model.method.resolve.class.error.message=无法解析类 ''{0}''
model.method.signature.parse.error.message=无法解析签名 ''{0}''
model.property.error.message=无法解析属性 ''{0}''
model.qualifiers.in.class.inspection.display.name=Spring Bean 组件中不正确的自动装配
move.bean=移动 Bean
move.bean.to.the.top.level=将 Bean 移至顶层
multiple.autowiring.constructor=只有一个构造函数可以具有 @Autowired 注解
multiple.context.description.in.module.text=<html><body> 在模块 <b>{0}</b> 中。</body></html>
multiple.context.description.in.modules.label.text=<html><body>文件包含在 <b>{1}</b> 个模块的 <b>{0} 个上下文</b>中。</body></html>
multiple.context.description.label.text=<html><body>文件包含在 <b>{0} 个上下文</b>中。</body></html>
multiple.context.tooltip.text=有效上下文
navigate.to.autowired.dependencies=导航到自动装配的依赖项
navigate.to.by.name.autowired.dependencies=导航到 'byName' 自动装配的依赖项
navigate.to.fileset.configuration=导航到应用程序上下文配置
notification.group.spring.beans=Spring 自定义 Bean 解析失败
notification.group.spring.configuration=检测到 Spring 配置问题
parse.custom.bean.error=解析自定义 Bean 时出错
parse.custom.bean.intention=解析自定义 Bean
parse.custom.bean.success=自定义处理程序已成功完成
parse.no.custom.beans=解析器未生成 Bean
parse.no.namespace.handler=找不到命名空间 ''{0}'' 的自定义处理程序
parse.only.infrastructure.beans=解析器仅生成架构 Bean
parse.these.beans=自定义命名空间处理程序已生成以下 Bean 定义\:\n{0}
parse.these.beans.induct=自定义命名空间处理程序生成以下 Bean 定义\:\n{0}\n\n是否要假设名称空间 ''{1}'' 中\n本地名称为 ''{2}'' 的所有 Bean 具有\n相同的类并且从 ''{3}'' 特性获得 ID?
parse.these.beans.induct.all.beans=所有 Bean
parse.these.beans.induct.only.this=此 Bean
parsing.custom.bean=正在运行自定义 Spring Bean 处理程序…
placeholders.inspection.display.name=Spring XML 应用程序上下文中配置的未解析的占位符
popup.title.select.injection.type=选择注入类型
popup.title.select.prototypeInjection.type=选择原型注入类型
process.explicitly.annotated.beans=处理显式注解的 Bean
process.unexpectedly.terminated=进程意外终止{0}
progress.creating.component=正在创建 Spring 组件 {0}
reference.injector.spring.bean.name=Spring Bean 名称
reference.injector.spring.placeholder=Spring 占位符
reference.injector.spring.resource.path=Spring 资源路径
required.properties.inspection=@Required Spring Bean 属性未注入
required.properties.missed=缺少必需属性\: ''{0}''
required.property.not.mapped=未注入必需属性 ''{0}''
required.spring.bean.type.inspection=不正确的注入 Bean 类型
scopes.inspection.display.name=未知 <bean> 作用域
searching.for.implicit.usages=正在搜索隐式用法…
searching.for.stereotype.usages=正在搜索构造型用法…
spring=Spring
spring.add.bean.dependency.fix.family.name=添加对 Bean 的依赖关系
spring.add.bean.dependency.fix.text=添加名称与 ''{0}'' 匹配的依赖项
spring.aliases=别名
spring.app.context.navigate.tooltip=导航到应用程序上下文
spring.app.context.to.navigate=选择应用程序上下文
spring.application.auto.configuration=自动配置
spring.bean=Spring Bean
spring.bean.abstract.bean.references.inspection=对抽象 Bean 不正确的引用
spring.bean.already.exists={1} 中已存在名为 ''{0}'' 的 Spring Bean
spring.bean.attributes.inspection.key=Spring Bean 特性冲突
spring.bean.autowire.escape=将自动装配的依赖项设为显式
spring.bean.autowire.escape.inspection.name=XML 应用程序上下文中不必要的自动装配的依赖项
spring.bean.class.navigate.choose.class.title=选择 Bean
spring.bean.class.tooltip.navigate.declaration=导航到 Spring Bean 声明
spring.bean.class.tooltip.show.in.description=在 Spring 视图中选择
spring.bean.constructor.arg=构造函数实参
spring.bean.constructor.navigate.choose.class.title=选择包含构造函数的 Bean
spring.bean.constructor.tooltip.navigate.declaration=导航到 Spring Bean
spring.bean.dependencies.chooser.title=选择 Bean
spring.bean.duplicate.bean.name=Bean 名称重复
spring.bean.duplicated.bean.name.inspection=基于 XML 的应用程序上下文中重复的 Bean 名称
spring.bean.filter.tooltip=开始输入以筛选元素
spring.bean.idref.attributes.inconsistency=<idref> 标记只能包含 "bean" 特性或 "local" 特性
spring.bean.idref.attributes.must.specify=<idref> 标记必须指定 Bean
spring.bean.instantiation.by.factory=Spring Bean (已由工厂 Bean 实例化)
spring.bean.instantiation.inspection=无效的非抽象 Bean 实例化
spring.bean.instantiation.using.factory.method=Spring Bean (由 static 工厂方法实例化)
spring.bean.lookup.method.bean.has.no.class=''{0}'' Bean 没有类
spring.bean.lookup.method.constructor.not.allowed=此处不允许使用构造函数
spring.bean.lookup.method.incorrect.return.type=不正确的查找方法返回值类型
spring.bean.lookup.method.inspection=不正确的 XML Bean 查找方法配置
spring.bean.lookup.method.must.be.not.static=此处不允许使用 static 方法
spring.bean.lookup.method.must.be.public.or.protected=方法必须为 public 或 protected
spring.bean.lookup.method.must.have.no.parameters=方法不得有形参
spring.bean.lookup.method.return.type.mismatch=Lookup 方法返回值类型与 ''{0}'' Bean 类不匹配
spring.bean.map.entry=映射条目
spring.bean.method.tooltip.navigate.declaration=导航到 Spring Bean {0} 方法声明
spring.bean.methods.tooltip.navigate.declaration=导航到 Spring Bean 方法声明
spring.bean.properties.chooser.title=选择属性
spring.bean.property=属性
spring.bean.property.navigate.choose.class.title=选择包含属性的 Bean
spring.bean.property.tooltip.navigate.declaration=导航到 Spring Bean 属性
spring.bean.property.value.inconsistency.key=映射条目只能包含 "key" 特性或 "key-ref" 特性或 <key> 子元素
spring.bean.property.value.inconsistency.more.one.sub.element={0} 不得包含多个子元素
spring.bean.property.value.inconsistency.ref.or.value.sub.element.must.defined={0} 只能包含 "ref" 特性或 "value" 特性或子元素
spring.bean.ref.attributes.inconsistency=<ref> 标记只能包含 "bean" 特性或 "local" 特性或 "parent" 特性
spring.bean.ref.attributes.must.specify=<ref> 标记必须指定 Bean
spring.bean.referenced.by.abstract.bean=此处无法使用 abstract Bean
spring.bean.show.beans.candidates.title=Bean 候选项
spring.bean.use.autowire=不必要的自动装配的依赖项
spring.beans=已生成的 Bean
spring.beans.chooser.all.context.files=所有 Bean
spring.beans.chooser.show.context.files=显示上下文文件
spring.cacheable.and.cache.put.on.the.same.method.display.name=对同一方法不正确地使用 @CachePut 和 @Cacheable
spring.cacheable.annotations.inspection.display.name=配置不正确的 'caching' 注解
spring.cacheable.annotations.on.interfaces=在接口/接口方法上定义的 Cache* 注解
spring.cacheable.element.choose.title=选择可缓存操作
spring.cacheable.element.tooltip.text=转到同名的可缓存操作
spring.cacheable.method.calls.inspection.display.name=@Cacheable 自调用方法调用
spring.cacheable.names.inspection.display.name=不正确的所需缓存名称定义
spring.cacheable.self.method.calls=@Cacheable 自调用(实际上是目标对象内的方法调用目标对象的另一个方法)。在运行时会忽略缓存注解
spring.choose.bean.templates.dialog.beans=Bean
spring.choose.bean.templates.dialog.title=添加 {0} Bean
spring.component.container.current.file=当前文件
spring.component.container.custom.package=自定义软件包…
spring.component.container.custom.package.dialog.package=包\:
spring.component.container.custom.package.dialog.select.package=选择软件包
spring.component.container.custom.package.dialog.source.root=源根\:
spring.component.container.custom.package.dialog.title=选择源根和软件包
spring.component.template.application=应用程序
spring.component.template.bean=Bean
spring.component.template.boot.test=Spring Boot 测试
spring.component.template.component=组件
spring.component.template.configuration=配置
spring.component.template.configuration.properties=配置属性
spring.component.template.service=服务
spring.configurable.create.bean.tab.title=要接受建议，请按 Tab。
spring.configuration.check=Spring 配置检查
spring.configuration.proxy.methods.display.name=@Configuration proxyMethods 用法警告
spring.context.configuration.inspection.display.name=无效的 @ContextConfiguration
spring.core.autowired.annotator.name=自动装配
spring.core.bean.annotator.name=Bean
spring.core.cacheable.annotator.name=同名的可缓存操作
spring.core.dom.annotator.name=配置(XML)
spring.core.event.listener.annotator.name=应用程序事件
spring.core.properties.annotator.name=属性
spring.core.test.configuration.annotator.name=测试配置
spring.core.testing.annotator.navigate.to.overridden=导航到被重写的 Bean
spring.core.testing.inject.annotator.name=测试 Bean
spring.create.bean.command.text=创建并自动装配新的 {0}
spring.create.bean.dependency.default.name=Spring 组件
spring.create.bean.dependency.fix.family.name=创建新 Bean
spring.create.bean.dependency.fix.text=创建并自动装配新的 {1} ''{0}''
spring.depends.on.inspection.display.name=@DependsOn 注解中不正确引用的 Bean
spring.dom.component.scan.stereotypes=选择构造型
spring.dom.component.scan.stereotypes.title=导航到组件
spring.event.listener.choose.title=选择事件侦听器
spring.event.listener.empty.tooltip.text=未找到事件侦听器
spring.event.listener.tooltip.text=转到事件侦听器
spring.event.publisher.choose.title=选择事件发布器
spring.event.publisher.empty.tooltip.text=未找到事件发布器
spring.event.publisher.tooltip.text=转到事件发布器
spring.facet.config.detection=Spring 配置检测
spring.facet.detection.disable.detection=禁用检测
spring.facet.detection.will.be.disabled.for.whole.project=将为整个项目禁用检测。\n请注意，如果不执行 Spring facet 配置，将无法使用大多数 Spring 相关功能。\n\n“项目结构 | Facet | 检测”\n可用于仅排除以及重新启用特定文件/文件夹。
spring.facet.validation.disable.action=禁用…
spring.facet.validation.help.action=显示帮助
spring.factories.file.type=Spring 工厂
spring.generate.constructor.dependencies=构造函数依赖项…
spring.generate.properties=属性…
spring.generate.setter.dependencies=Setter 依赖项…
spring.import.resource.error.message.trailing.space=''{0}'' 中的尾随空格
spring.import.resource.inspection.display.name=@ImportResource 位置中未解析的文件引用
spring.incorrect.resource.type.inspection=不正确的资源类型
spring.injection.autowiring.code.style=自动装配代码样式
spring.injection.default.beans.inject.strategy=默认 Bean 注入器策略\:
spring.injection.group.libraries=库
spring.injection.group.project=项目
spring.injection.group.repository=仓库
spring.injection.group.service=服务
spring.injection.injectToBeanMethodSignature=对 @Bean 方法使用方法形参注入
spring.injection.variants.collection=集合
spring.injection.variants.default=默认
spring.injection.variants.primary=主要
spring.injection.variants.qualifier={0}
spring.intention.category=Spring
spring.lookup.inspection.display.name=Spring 组件的 @Lookup 注解中不正确引用的 Bean
spring.model.actions.dump.model.gathering.spring.models=正在收集 Spring 模型…
spring.model.actions.dump.model.generating.json=正在生成 JSON…
spring.model.actions.dump.model.scanning.spring.models=正在扫描 Spring 模型…
spring.model.actions.generate.beans=创建 Spring Bean
spring.parent.bean.tooltip=导航到子声明
spring.profile=分析
spring.profile.expression.empty=配置文件表达式必须包含文本
spring.profile.expression.inspection=配置不正确的 @Profile 表达式
spring.profile.expression.malformed=格式不正确的配置文件表达式
spring.profile.unresolved.message=未知配置文件
spring.property.source.inspection.display.name=@PropertySource 和 @TestPropertySource 位置中未解析的文件引用
spring.required.property.inspection=Spring XML Bean 声明中缺少 @Required 属性注入
spring.scheduled.inspection.display.name=@Scheduled 注解中不正确引用的 Bean
spring.scheduled.method=触发 @Scheduled 方法
spring.scheduled.tasks=计划的任务
spring.scope=作用域
spring.settings.configuration.completion=补全
spring.settings.configuration.file.editor=配置文件编辑器
spring.settings.multiple.context.panel=显示多个上下文面板(&M)
spring.settings.multiple.context.panel.tooltip=如果文件在多个上下文中使用，则允许选择有效上下文
spring.settings.profiles.panel=显示配置文件面板(&P)
spring.settings.profiles.panel.tooltip=允许选择有效配置文件
spring.settings.smartCompletionAvailability=智能 Bean 补全
spring.stereotype.bean=Bean
spring.stereotype.component=组件
spring.stereotype.configuration=配置
spring.stereotype.service=服务
spring.template.context.type=Spring
spring.test.override.bean.resolve.inspection.cannot.find.factory.method=找不到 static 工厂方法
spring.test.override.bean.resolve.inspection.display.name=@MockitoBean、@MockitoSpyBean 和 @TestBean 注解中不正确引用的 Bean
spring.testing.context.dirties.inspection.display.name=无效的 @DirtiesContext 'mode' 配置
spring.testing.model.dirties.class.mode.error.message=在带注解的测试方法上设置类模式没有任何意义。对于方法级控制，请改用 methodMode。
spring.testing.model.dirties.hierarchy.mode.error.message=当通过 @ContextHierarchy 将上下文配置为层次结构的一部分时，必须使用 hierarchyMode
spring.testing.model.dirties.method.mode.error.message=在注解的测试类上设置方法模式没有意义。对于类级别控制，请改用 classMode。
spring.testing.sql.inspection.display.name=无效的 @Sql 和 @SqlGroup 配置
spring.testing.transactional.inspection.display.name=无效的事务生存期方法声明
spring.testing.transactional.void.method.return.type.error.message=方法返回值类型应为 'void'
spring.testing.transactional.wrong.number.of.arguments.error.message=实参数量错误
spring.transaction.inspection.display.name=@Transactional 组件中无效的 'PlatformTransactionManager' 声明
spring.transactional.method.calls.inspection.display.name=@Transactional 自调用方法调用
spring.transactional.self.method.calls=@Transactional 自调用(实际上是目标对象内的方法调用目标对象的另一个方法)在运行时不会导致实际的事务
static.members.autowiring=不自动装配 static 成员
timeout.parsing.bean=自定义 Bean 解析时间过长
try.parsing.custom.beans=尝试解析自定义 Bean
unmapped.configuration.autodetected.context.found.for=已找到 {0} 的自动检测上下文。\n请检查并设置其他手动上下文(如果需要)。
unmapped.configuration.configure.facet=请配置 Spring facet。
unmapped.configuration.create.default.context=创建默认上下文
unmapped.configuration.files.count={0, choice, 1\#1 文件|1<{0, number} 文件}
unmapped.configuration.files.found=找到未映射的 Spring 配置文件。
unmapped.configuration.files.full={0, choice, 1\#未映射的 Spring 配置文件|1<{0, number} 个未映射的 Spring 配置文件}\:<br/>{1}
unmapped.configuration.files.not.found=找不到未映射的 Spring 配置文件。
unmapped.configuration.files.short={0, choice, 1\#未映射的 Spring 配置文件|1<{0, number} 个未映射的 Spring 配置文件}
unmapped.configuration.fix.instruction=请配置 Spring facet 或使用 ''{0}'' 添加一个包括所有未映射文件的 facet。
unmapped.configuration.is.not.available.during.index.update=索引更新期间 ''{0}'' 不可用
unmapped.configuration.open.facet.configuration=打开 Facet 配置
unmapped.configuration.spring.configuration=Spring 配置
unparsed.custom.bean.inspection=未解析的自定义 Spring Bean
unparsed.custom.bean.message=此自定义 Spring Bean 尚未解析
update.schema.intention=转换为 Spring XML 架构
use.existing.quick.fixes.add.dependency.to.context=将依赖关系添加到上下文 ''{0}''
use.existing.quick.fixes.add.import.action=为 ''{0}'' 添加 <import>
use.existing.quick.fixes.add.spring.xml.to.fileset.action=将 ''{0}'' 添加到上下文 ''{1}''
use.existing.quick.fixes.choose.fix.for=为 ''{0}'' 选择修正
use.existing.quick.fixes.open.spring.facet.settings=打开 Spring facet 设置…
use.existing.quick.fixes.use.existing.bean.family.name=使用现有 Bean
use.existing.quick.fixes.use.existing.bean.from.context=使用上下文 ''{0}'' 中的现有 Bean…
use.p.namespace=转换为 p-namespace
util.required.class.message=类必须为 ''{0}'' 的继承者
util.schema.inspection.name=XML 应用程序上下文中定义的配置不正确的 'util' 架构 Bean
xml.schema.update.is.required=需要更新 XML 架构
xml.schema.will.be.updated=XML 架构将更新为 spring-beans.xsd。\n是否要继续?

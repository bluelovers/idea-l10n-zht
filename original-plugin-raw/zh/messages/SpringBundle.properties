model.property.error.message=无法解析属性 ''{0}''
model.create.factory.method.quickfix.message=创建工厂方法 ''{0}''
model.create.factory.method.quickfix.family.name=创建工厂方法
model.add.constructor.args.for.method.quickfix.message=为 ''{0}'' 添加 <constructor-arg>
model.add.constructor.args.for.method.quickfix.message.family.name=添加 <constructor-arg>
model.method.signature.parse.error.message=无法解析签名 ''{0}''
model.method.resolve.class.error.message=无法解析类 ''{0}''
model.bean.not.found.error.message=找不到名称为 ''{0}'' 的 Bean
model.method.choose.method=选择方法

model.bean.quickfix.message=创建新 Bean ''{0}''
model.bean.quickfix.message.family.name=创建新 Bean

model.inspection.display.name=不正确的 Spring Core 基于 XML 的应用程序上下文
model.inspection.display.bean.name.convention=Spring Bean 名称违反惯例
model.inspection.bean.property.value=XML 应用程序上下文中不可分配的注入点类型
model.inspection.bean.constructor.arg=XML Spring Bean 中不正确的构造函数注入
model.inspection.bean.autowiring=不正确的 XML Spring Bean 自动装配
model.inspection.validator.progress.text=正在验证 Spring 模型…

model.goto.related.item.group.context=Spring 上下文:“{0}”
model.goto.related.item.group.application.context=Spring 应用程序上下文
model.goto.related.item.group.test.context=Spring 测试上下文


scopes.inspection.display.name=未知 <bean> 范围

inspection.group.code=代码
inspection.group.setup=设置
inspection.group.xml=XML

model.inspection.invalid.identifier.message=''{0}'' 未遵循 Bean 命名惯例
model.inspection.invalid.lowercase.name.message=''{0}'' 应以小写字母开头

model.inspection.bean.factory.method=在 "factory-method" 特性中引用的错误定义的方法
model.inspection.bean.public.factory.method=在 "factory-method" 特性中引用的不正确的非 public 方法
method.must.be.static=工厂方法 ''{0}'' 必须为 static
method.must.not.be.static=工厂方法 ''{0}'' 不得为 static
method.must.be.public=工厂方法 ''{0}'' 应为 public
method.cannot.instantiate.bean=工厂方法  ''{0}'' 无法实例化 Bean


bean.autowiring.by.type.none=无法自动装配。找不到 ''{0}'' 类型的 Bean。
bean.autowiring.by.type.no.beans=无法自动装配。找不到 ''{0}'' 或 ''{1}'' 类型的 Bean。
bean.autowiring.by.type=无法自动装配。存在多个 ''{0}'' 类型的 Bean。Bean: {1}。属性: ''{2}''
bean.class.autowired.by.type=无法自动装配。存在多个 ''{0}'' 类型的 Bean。
bean.autowiring.by.type.no.parameter.for.autowired.method= 无参数的自动装配 {0}
bean.class.autowired.incorrect.qualifier.type=无法自动装配。限定 Bean 必须为 ''{0}'' 类型。
bean.class.unknown.qualifier.bean=找不到具有限定符 ''{0}'' 的 Bean

bean.bad.property.type=''{0}'' 类型的属性不能由 ''{1}'' 注入
idref.cannot.be.added.in.collection=无法添加到 ''{0}'' 类型的集合中
timeout.parsing.bean=自定义 Bean 解析时间过长
process.unexpectedly.terminated=进程意外终止{0}
try.parsing.custom.beans=尝试解析自定义 Bean
internal.error.parsing.bean=解析 Bean 时出现内部错误;输出:\n\
{0}

cannot.find.bean.constructor.with.parameters.count=在类 ''{0}'' 中未找到匹配的构造函数
cannot.find.factory.method.with.parameters.count=在类中未找到匹配的工厂方法

cannot.find.constructor.arg.index=找不到实参索引为 {0} 的构造函数
cannot.find.constructor.arg.index.in.class=在类 {1} 中找不到实参索引为 {0} 的构造函数
cannot.find.factory.method.index=在类 {1} 中找不到参数索引为 {0} 的工厂方法

incorrect.constructor.arg.index.not.unique=索引必须唯一
constructor.arg.incorrect.value.type=注入值类型必须对应于构造函数实参类型

spring.bean=Spring Bean
spring=Spring

config.display.name=配置
config.no.contexts.defined=未定义应用程序上下文

spring.bean.class.tooltip.navigate.declaration=导航到 Spring Bean 声明
navigate.to.autowired.dependencies=导航到自动装配的依赖项
navigate.to.by.name.autowired.dependencies=导航到 'byName' 自动装配的依赖项
autowired.dependencies.goto.related.item.group.name=自动装配的依赖项

spring.bean.show.beans.candidates.title=Bean 候选项

gutter.navigate.no.matching.beans=未找到匹配的 Bean
spring.bean.class.navigate.choose.class.title=选择 Bean
spring.bean.property.tooltip.navigate.declaration=导航到 Spring Bean 属性
spring.bean.property.navigate.choose.class.title=选择包含属性的 Bean
spring.bean.constructor.tooltip.navigate.declaration=导航到 Spring Bean
spring.bean.constructor.navigate.choose.class.title=选择包含构造函数的 Bean
spring.bean.methods.tooltip.navigate.declaration=导航到 Spring Bean 方法声明
spring.bean.method.tooltip.navigate.declaration=导航到 Spring Bean {0} 方法声明
spring.bean.filter.tooltip=开始输入以筛选元素

config.file.not.found=找不到文件
config.files.not.found=未找到文件
config.file.is.not.spring=该文件未被识别为 Spring 配置
config.unmapped.configs.popup.title={0} 中未映射的 Spring 配置文件
spring.bean.lookup.method.inspection=不正确的 XML Bean 查找方法配置
spring.bean.lookup.method.incorrect.return.type=不正确的查找方法返回类型
spring.bean.lookup.method.constructor.not.allowed=此处不允许使用构造函数
spring.bean.lookup.method.return.type.mismatch=Lookup 方法返回类型与 ''{0}'' Bean 类不匹配
spring.bean.lookup.method.bean.has.no.class=''{0}'' Bean 没有类
spring.bean.lookup.method.must.be.public.or.protected=方法必须为 public 或 protected
spring.bean.lookup.method.must.have.no.parameters=方法不得有参数
spring.bean.lookup.method.must.be.not.static=此处不允许使用 static 方法

model.inspection.injection.value.style=XML 应用程序上下文中的注入值违反惯例
model.inspection.injection.value.style.message=使用了显式 <value> 元素
model.inspection.injection.value.style.value.fix=将 <value> 元素替换为 "{0}" 特性
model.inspection.injection.value.style.value.fix.family.name=将 <value> 元素替换为特性
model.inspection.injection.value.style.ref.fix=将 <ref> 元素替换为 "{0}" 特性
model.inspection.injection.value.style.ref.fix.family.name=将 <ref> 元素替换为特性
model.inspection.injection.value.style.ref.message=使用了显式 <ref> 元素

spring.bean.property=属性
spring.bean.constructor.arg=构造函数实参
spring.bean.map.entry=映射条目

model.inspection.injection.value.consistency=XML 应用程序上下文中不一致的注入值
model.inspection.injection.value.message={0} 必须指定一个 ref 或 value
spring.bean.property.value.inconsistency.ref.or.value.sub.element.must.defined={0} 只能包含 "ref" 特性或 "value" 特性或子元素
spring.bean.property.value.inconsistency.more.one.sub.element ={0} 不得包含多个子元素
spring.bean.ref.attributes.inconsistency=<ref> 标记只能包含 "bean" 特性或 "local" 特性或 "parent" 特性
spring.bean.ref.attributes.must.specify=<ref> 标记必须指定 Bean
spring.bean.idref.attributes.inconsistency=<idref> 标记只能包含 "bean" 特性或 "local" 特性
spring.bean.idref.attributes.must.specify=<idref> 标记必须指定 Bean
model.inspection.injection.value.entry.key=映射条目必须指定键
spring.bean.property.value.inconsistency.key=映射条目只能包含 "key" 特性或 "key-ref" 特性或 <key> 子元素

model.inspection.injection.value.add.ref=添加 "ref" 特性
model.inspection.injection.value.add.list=添加 <list> 标记
model.inspection.injection.value.add.set=添加 <set> 标记
model.inspection.injection.value.add.array=添加 <array> 标记
model.inspection.injection.value.add.map=添加 <map> 标记


spring.bean.abstract.bean.references.inspection=对抽象 Bean 不正确的引用
spring.bean.referenced.by.abstract.bean=此处无法使用 abstract Bean

spring.bean.autowire.escape.inspection.name=XML 应用程序上下文中不必要的自动装配的依赖项
spring.bean.use.autowire=不必要的自动装配的依赖项
spring.bean.autowire.escape=将自动装配的依赖项设为显式

spring.bean.duplicated.bean.name.inspection=基于 XML 的应用程序上下文中重复的 Bean 名称
spring.bean.duplicate.bean.name=Bean 名称重复

spring.bean.instantiation.by.factory=Spring Bean (已由工厂 Bean 实例化)
spring.bean.instantiation.using.factory.method=Spring Bean (由 static 工厂方法实例化)
spring.generate.properties=属性…
spring.generate.setter.dependencies=Setter 依赖项…
spring.generate.constructor.dependencies=构造函数依赖项…
action.Spring.Beans.Generate.Setter.Dependency.Action.text=Spring Setter 依赖项…
action.Spring.Beans.Generate.Constructor.Dependency.Action.text=Spring 构造函数依赖项…
spring.bean.properties.chooser.title=选择属性
spring.bean.dependencies.chooser.title=选择 Bean
spring.beans.chooser.show.context.files=显示上下文文件
spring.beans.chooser.all.context.files=所有 Bean
spring.beans=Bean
util.schema.inspection.name=XML 应用程序上下文中定义的配置不正确的 'util' 架构 Bean
util.required.class.message=类必须为 ''{0}'' 的继承者

spring.bean.instantiation.inspection=无效的非抽象 Bean 实例化
mark.bean.as.abstract=将 Bean 标记为 abstract
abstract.class.not.allowed=abstract 类不允许用于非 abstract Bean
interface.not.allowed=非抽象 Bean 不允许接口

spring.parent.bean.tooltip=导航到子声明











spring.choose.bean.templates.dialog.title=添加 {0} Bean
spring.choose.bean.templates.dialog.beans=Bean

facet.context.default.name=Spring 应用程序上下文

facet.context.xml.files=基于 XML 的配置
facet.context.code.files=基于代码的配置
facet.context.properties.files=附加属性文件
facet.context.other.files=其他文件
facet.context.autodetected.suffix= (自动检测)
facet.context.autoconfigured.suffix= (自动配置)

facet.context.new.title=新建应用程序上下文
facet.context.edit.title=编辑应用程序上下文 ''{0}''
facet.context.edit.name.label=名称(&N):
facet.context.edit.parent.label=父上下文(&P):
facet.context.edit.parent.none.selected=<none>
facet.context.edit.name.validation.not.empty=名称不得为空
facet.context.edit.name.validation.already.exists=具有此名称的上下文已存在。如果已删除具有此名称的现有上下文，则必须首先使用“应用”。
facet.context.edit.add.file.choose.type=选择类型

facet.context.remove.title=移除
facet.context.remove.message=确实要移除应用程序上下文 "{0}" 吗? (不会删除任何文件)

config.new.file=Spring 配置
create.new.spring.configuration.file=创建新的 Spring 配置文件



framework.title.spring=Spring(&S)

spring.facet.inspection=Spring facet 中不正确的 XML 应用程序上下文设置
spring.facet.code.inspection=Spring facet 中不正确的 @Configuration 类设置
spring.facet.programmatic.inspection=Spring facet 编程配置

spring.facet.inspection.create.facet=创建 Spring facet
spring.facet.inspection.context.choose=选择应用程序上下文
spring.facet.inspection.context.create=创建新的应用程序上下文…
spring.facet.inspection.context.not.configured.for.file=没有为此文件配置应用程序上下文
spring.facet.inspection.configure.context.for.file=配置应用程序上下文
spring.facet.inspection.check.test.files=检查测试文件

introduce.bean.intention=引入 Bean

parse.custom.bean.intention=解析自定义 Bean
parsing.custom.bean=正在运行自定义 Spring Bean 处理程序…
parse.custom.bean.error=解析自定义 Bean 时出错
parse.custom.bean.success=自定义处理程序已成功完成
parse.no.custom.beans=解析器未生成 Bean
parse.only.infrastructure.beans=解析器仅生成架构 Bean
parse.these.beans=自定义命名空间处理程序已生成以下 Bean 定义:\n\
{0}
parse.these.beans.induct=自定义命名空间处理程序生成以下 Bean 定义:\n\
{0}\n\
\n\
要假设名称空间 ''{1}'' 中 \n\
本地名称为 ''{2}'' 的所有 Bean 具有\n\
相同的类并且从 ''{3}'' 特性获得 ID 吗?
parse.these.beans.induct.only.this=此 Bean
parse.these.beans.induct.all.beans=所有 Bean
parse.no.namespace.handler=找不到命名空间 ''{0}'' 的自定义处理程序
unparsed.custom.bean.inspection=未解析的自定义 Spring Bean
unparsed.custom.bean.message=此自定义 Spring Bean 尚未解析
custom.bean.no.id=IntelliJ IDEA 在配置文件中找不到此 Bean 的 ID。重命名可能会生成错误的代码。要继续吗?
custom.bean.no.id.title=警告

do.you.want.to.move.bean.to.the.top.level=要将该 Bean 移动到顶层吗?
move.bean.to.the.top.level=将 Bean 移动到顶层
move.bean=移动 Bean
update.schema.intention=转换为 Spring XML 架构
use.p.namespace=转换为 p-namespace
xml.schema.will.be.updated=XML 架构将更新为 spring-beans.xsd。\n\
要继续吗?
xml.schema.update.is.required=需要更新 XML 架构

model.qualifiers.in.class.inspection.display.name=Spring Bean 组件中不正确的注入点自动装配
java.class.constructor.autowiring.inspection.display.name=Spring Bean 类构造函数中的自动装配问题
required.properties.inspection=@Required Spring Bean 属性未注入
required.property.not.mapped=未注入必需属性 ''{0}''
create.missing.mappings=为 ''{0}'' 创建缺少的映射
create.missing.mappings.family.name=创建缺少的映射

spring.required.property.inspection=Spring Xml Bean 声明中缺少 @Required 属性注入
required.properties.missed=缺少必需属性: ''{0}''
create.missing.properties=创建缺少的属性
cannot.find.bean.qualified.by=找不到使用 {0} 限定的 Bean
cannot.autowire.bean.of.type=无法自动装配。Bean 必须为 ''{0}'' 类型
required.spring.bean.type.inspection=不正确的注入 Bean 类型
placeholders.inspection.display.name=Spring XML 应用程序上下文中配置的未解析的占位符
bean.property.extract.name=将属性值提取到配置文件

spring.incorrect.resource.type.inspection=不正确的资源类型
SpringIncorrectResourceTypeInspection.incorrect.resource.type=不正确的资源类型
SpringIncorrectResourceTypeInspection.expected.resource.types=资源类型不正确。预期类型: {0}
spring.import.resource.inspection.display.name=@ImportResource 位置中未解析的文件引用
spring.property.source.inspection.display.name=@PropertySource 和 @TestPropertySource 位置中未解析的文件引用
spring.configuration.proxy.methods.display.name=@Configuration proxyMethods 用法警告
spring.context.configuration.inspection.display.name=无效的 @ContextConfiguration
spring.testing.sql.inspection.display.name=无效的 @Sql 和 @SqlGroup 配置
spring.transaction.inspection.display.name=@Transactional 组件中无效的 'PlatformTransactionManager' 声明
spring.lookup.inspection.display.name=Spring 组件的 @Lookup 注解中错误引用的 Bean
SpringContextConfigurationInspection.cannot.find.default.app.context=找不到默认应用程序上下文文件 {0}
SpringContextConfigurationInspection.create.nested.configuration.class=创建嵌套 ContextConfiguration 类
action.generate.autowired.dependencies.action.text=@Autowired 依赖项…
SpringAutowiringInspection.add.qualifier.fix=添加限定符
context.schema.inspection.name=基于 XML 的组件扫描中无效的筛选器定义
ContextComponentScanInconsistencyInspection.annotation.is.expected.here=此处应为注解
spring.import.resource.error.message.trailing.space=''{0}'' 中的尾随空格

spring.profile.expression.inspection=配置不正确的 @Profile 表达式
spring.profile.expression.empty=配置文件表达式必须包含文本
spring.profile.expression.malformed=格式不正确的配置文件表达式
spring.profile.unresolved.message=未知配置文件

editor.panel.profiles.tooltip=有效配置文件
editor.panel.profiles.tooltip.action.name=更改配置文件…

SpringInactiveProfilesHighlightingPass.inactive.profile=停用配置文件
spring.dom.component.scan.stereotypes=选择构造型
spring.dom.component.scan.stereotypes.title=导航到组件
ContextJavaBeanUnresolvedMethodsInspection.display.name=@Bean 注解中未知的 init/destroy 方法
ContextJavaBeanUnresolvedMethodsInspection.cannot.resolve.method=无法解析方法

ActivateSpringProfileIntentionAction.activate.profile=激活配置文件 ''{0}''
ActivateSpringProfileIntentionAction.activate.profile.family.name=激活配置文件
ActivateSpringProfileIntentionAction.deactivate.profile=停用配置文件 ''{0}''
ActivateSpringProfileIntentionAction.deactivate.profile.family.name=停用配置文件

spring.app.context.to.navigate=选择应用程序上下文
spring.app.context.navigate.tooltip=导航到应用程序上下文

SpringStaticMembersAutowiringInspection.display.name=对 static 类成员不正确的 Spring 组件自动装配或注入
static.members.autowiring=不自动装配 static 成员

gutter.choose.autowired.candidates.title=选择自动装配的候选项
gutter.navigate.to.autowired.candidates.title=导航到自动装配的候选项
gutter.navigate.no.matching.autowired.candidates=未找到匹配的自动装配候选项
process.explicitly.annotated.beans=处理显式注解的 Bean
configuration.tab.additional.settings=附加设置

gutter.choose.bean.factory.calls.title=选择 BeanFactory.getBean(...) 用法
gutter.navigate.no.bean.factory.calls=未找到匹配的 BeanFactory 用法
gutter.navigate.to.bean.factory.calls.title=导航到 BeanFactory.getBean(...) 用法

multiple.context.tooltip.text=有效上下文
multiple.context.description.in.module.text=<html><body> 在模块 <b>{0}</b> 中。</body></html>
multiple.context.description.label.text=<html><body>文件包含在 <b>{0} 个上下文</b>中。</body></html>
multiple.context.description.in.modules.label.text=<html><body>文件包含在 <b>{1}</b> 个模块的 <b>{0} 个上下文</b>中。</body></html>
class.without.matching.constructor.for.autowiring=类不包含用于自动装配的匹配构造函数
multiple.autowiring.constructor=只有一个构造函数可以具有 @Autowired 注解
springAutowiredMembersInspection.inspection=非 Spring 组件中不正确的 @Autowired 成员
class.is.not.spring.bean.autowired=必须在有效 Spring Bean 中定义自动装配成员(@Component|@Service|…)

model.inspection.inactive.profile=停用配置文件高亮显示
spring.bean.attributes.inspection.key=Spring Bean 特性冲突
component.scan.setup.inspection.key=@ComponentScan 或其元注解中无效的软件包
custom.namespace.registration.inspection.key=spring.handlers 或 spring.schemas 文件中未解析的文件或类引用


spring.event.publisher.choose.title=选择事件发布器
spring.event.publisher.tooltip.text=转到事件发布器
spring.event.publisher.empty.tooltip.text=未找到事件发布器

spring.event.listener.choose.title=选择事件侦听器
spring.event.listener.tooltip.text=转到事件侦听器
spring.event.listener.empty.tooltip.text=未找到事件侦听器
spring.cacheable.annotations.inspection.display.name=配置不正确的 'caching' 注解
spring.cacheable.names.inspection.display.name=不正确的所需缓存名称定义
spring.cacheable.and.cache.put.on.the.same.method.display.name=对同一方法不正确地使用 @CachePut 和 @Cacheable

spring.cacheable.annotations.on.interfaces=在接口/接口方法上定义的 Cache* 注解
cacheable.annotations.should.be.defined.on.public.methods=应在 public 方法上定义缓存注解
cacheable.no.cache.could.be.resolved.for.cache.operation=必须为每个缓存操作至少提供一个非空缓存名称。
cacheable.should.be.defined.on.concrete.method=Spring 不建议使用 @Cache* 注解对接口方法进行注解
cacheable.and.cache.put.on.the.same.method=Spring 不建议在同一方法上使用 @CachePut 和 @Cacheable 注解
event.listener.method.parameters.count=方法必须最多只有一个参数
event.listener.method.visibility.public=使用 @EventListener 注解的方法必须为 public
event.listener.method.visibility.nonstatic=使用 @EventListener 注释的方法必须为非 static

spring.cacheable.element.choose.title=选择可缓存操作
spring.cacheable.element.tooltip.text=转到同名的可缓存操作

SpringAutowiredFieldsWarningInspection.inspection.display.name=非建议的 'field' 注入
field.injection.is.not.recommended=不建议使用字段注入
field.injection.create.constructor.family.warning=更改字段注入。创建构造函数
field.injection.add.parameter.family.warning=更改字段注入。向构造函数添加形参
field.injection.create.constructor.injection=<html>创建构造函数: {0}</html>
field.injection.add.parameters=<html>向构造函数添加形参: {0}</html>
spring.testing.context.dirties.inspection.display.name=无效的 @DirtiesContext 'mode' 配置
spring.testing.transactional.inspection.display.name=无效的事务生命周期方法声明
spring.testing.model.dirties.method.mode.error.message=在注解的测试类上设置方法模式没有意义。对于类级别控制，请改用 classMode。
spring.testing.model.dirties.class.mode.error.message=在注解的测试方法上设置类模式没有意义。 对于方法级别控制，请改用 methodMode。
spring.testing.model.dirties.hierarchy.mode.error.message=当通过 @ContextHierarchy 将上下文配置为层次结构的一部分时，必须使用 hierarchyMode
spring.testing.transactional.wrong.number.of.arguments.error.message=参数数量错误
spring.testing.transactional.void.method.return.type.error.message=方法返回类型应为 'void'
ScheduledMethodInspection.inspection.display.name=不正确的 @Scheduled 方法签名
ScheduledMethodInspection.incorrect.signature=@Scheduled 方法不得包含任何实参，也不应返回任何内容
method.parameters.removing.fix.family.name=移除方法形参
method.parameters.removing.fix.text=将 ''{0}'' 更改为无实参
AsyncMethodInspection.inspection.display.name=不正确的 @Async 方法签名
AsyncMethodInspection.incorrect.signature=使用 @Async 注解的方法应返回 'void' 或 "Future-like" 类型
SpringEventListenerInspection.inspection.display.name=错误配置的 @EventListener 方法
# suppress inspection "UnusedProperty"
method.return.type.make.async.family.name=更改方法以返回 "Future-like" 值
method.return.type.make.async.fix.text=更改方法以返回 ''{0}''
ImplicitSubclassInspection.display.forClass.annotated=使用 ''@{0}'' 注解的类可以隐式子类化且不得为 final
ImplicitSubclassInspection.display.forMethod.annotated=使用 ''@{0}'' 注解的方法必须可重写
ImplicitSubclassInspection.display.bean.in.configuration=@Configuration 中的 @Bean 方法必须可重写
navigate.to.fileset.configuration=导航到应用程序上下文配置

bean.method.called.from.configuration.without.proxy=使用 @Bean 注解的方法直接在 proxyBeanMethods 设置为 false 的 @Configuration 中调用。将 proxyBeanMethods 设置为 true 或使用依赖项注入。
bean.method.called.without.proxy=直接调用使用 @Bean 注解的方法。请改用依赖项注入。

action.DumpSpringConfiguration.text=转储 Spring  配置
group.Internal.Spring.text=Spring
action.SpringChangeActiveProfiles.text=更改有效 Spring 配置文件…
action.Spring.Create.Context.File.text=Spring 配置
action.Spring.Beans.Generate.Action.text=Spring Bean


spring.settings.common=通用
spring.settings.auto.configure=允许自动配置应用程序上下文
spring.settings.configuration.file.editor=配置文件编辑器
spring.settings.profiles.panel=显示配置文件面板(&P)
spring.settings.profiles.panel.tooltip=允许选择有效配置文件
spring.settings.multiple.context.panel=显示多个上下文面板(&M)
spring.settings.multiple.context.panel.tooltip=如果在多个上下文中使用文件，则允许选择有效上下文


framework.support.provider.create.empty.spring.config=创建空 {0}
fileset.editor.help.label=<html>通过 <b>\\&lt;import …/\\&gt;</b> 或 <b>@Import</b> 引用的配置文件将隐式添加。<br/>用于测试的配置文件<em>不得</em>添加到上下文。</html>
fileset.circular.dependencies=上下文之间的循环依赖关系:<br/>{0}<br/>{1}
fileset.contains.testing.configs.short=用于测试的 {0, choice, 1#配置文件|1<{0, number} 配置文件}<em>不得</em>添加到上下文
fileset.contains.testing.configs.full=用于测试的 {0, choice, 1#配置文件|1<{0, number} 配置文件}<em>不得</em>添加到上下文:<br/>{1}
spring.facet.validation.help.action=显示帮助
spring.facet.validation.disable.action=禁用…
spring.facet.detection.will.be.disabled.for.whole.project=将为整个项目禁用检测。\n\
请注意，如果不执行 Spring facet 配置，将无法使用大多数 Spring 相关功能。\n\
\n\
“项目结构 | Facet | 检测”\n\
可用于仅排除以及重新启用特定文件/文件夹。
spring.facet.config.detection=Spring 配置检测
spring.facet/detection.disable.detection=禁用检测
spring.configuration.check=Spring 配置检查
unmapped.configuration.fix.instruction=请配置 Spring facet 或使用 ''{0}'' 添加一个包括所有未映射文件的 facet。
unmapped.configuration.configure.facet=请配置 Spring facet。
unmapped.configuration.create.default.context=创建默认上下文
unmapped.configuration.files.count={0, choice, 1#1 文件|1<{0, number} 文件}
unmapped.configuration.files.found=找到未映射的 Spring 配置文件。
unmapped.configuration.programmatic.contexts.found=找到编程上下文:
unmapped.configuration.files.short={0, choice, 1#未映射的 Spring 配置文件|1<{0, number} 未映射的 Spring 配置文件}
unmapped.configuration.files.full={0, choice, 1#未映射的 Spring 配置文件|1<{0, number} 未映射的 Spring 配置文件}:<br/>{1}
unmapped.configuration.is.not.available.during.index.update= 索引更新期间 ''{0}'' 不可用
unmapped.configuration.open.facet.configuration=打开 Facet 配置
unmapped.configuration.spring.configuration=Spring 配置
unmapped.configuration.autodetected.context.found.for=已找到 {0} 的自动检测上下文。\n\
请检查并设置其他手动上下文(如果需要)。
scanning.for.programmatic.contexts=正在扫描编程上下文…
checking.spring.configuration=检查模块 ''{0}'' 中的 Spring 配置
searching.for.stereotype.usages=正在搜索构造型用法…
searching.for.implicit.usages=正在搜索隐式用法…

spring.core.autowired.annotator.name=自动装配
spring.core.bean.annotator.name=Bean
spring.core.component.scan.annotator.name=组件扫描
spring.core.dom.annotator.name=配置(XML)
spring.core.properties.annotator.name=属性
spring.core.test.configuration.annotator.name=测试配置
spring.core.cacheable.annotator.name=同名的可缓存操作
spring.core.event.listener.annotator.name=应用程序事件

spring.model.actions.dump.model.gathering.spring.models=正在收集 Spring 模型…
spring.model.actions.dump.model.scanning.spring.models=正在扫描 Spring 模型…
spring.model.actions.dump.model.generating.json=正在生成 JSON…
spring.model.actions.generate.beans=创建 Spring Bean
custom.namespace.quick.fixes.family.name=创建自定义命名空间 Bean
custom.namespace.quick.fixes.create.custom.namespace.bean=创建自定义命名空间 Bean ({0} 个变体)…
custom.namespace.quick.fixes.create.custom.namespace.bean.with.id=创建自定义命名空间 Bean {0}
custom.namespace.quick.fixes.create.name=创建 {0}
custom.namespace.quick.fixes.popup.title=创建自定义命名空间 Bean

use.existing.quick.fixes.use.existing.bean.family.name=使用现有 Bean
use.existing.quick.fixes.use.existing.bean.from.context=使用上下文 ''{0}'' 中的现有 Bean…
use.existing.quick.fixes.choose.fix.for=为 ''{0}'' 选择修正
use.existing.quick.fixes.add.dependency.to.context=将依赖关系添加到上下文 ''{0}''
use.existing.quick.fixes.add.spring.xml.to.fileset.action=将 ''{0}'' 添加到上下文 ''{1}''
use.existing.quick.fixes.add.import.action=为 ''{0}'' 添加 <import>
use.existing.quick.fixes.open.spring.facet.settings=打开 Spring facet 设置…

setup.programmatic.context.quick.fix.setup.spring.context=设置 Spring 上下文…
setup.programmatic.context.quick.fix.settings.displayName=Spring
setup.programmatic.context.quick.fix.context.with.name=已创建 ''{0}'' 上下文。\n\
禁止此检查以禁用高亮显示。\n\
\n\
要重新创建上下文，请在 Spring facet 中将其删除并禁用禁止检查。\n\
\n\
要打开 Spring facet 吗?
spring.facet.programmatic.inspection.spring.context=编程 Spring 上下文
duplicated.bean.name.inspection.name.view.duplicates=查看重复项
duplicated.bean.quick.fix.popup.title=查看重复项
UnparsedCustomBeanInspection.unsupported.tag=命名空间 ''{1}'' 不支持标记 ''{0}''，请提交问题(帮助|{2})
change.active.profile.dialog.spring.profiles=更改有效 Spring 配置文件
change.active.profile.dialog.module=模块 ''{0}''
change.active.profile.dialog.context=上下文 ''{0}''
SpringUpdateSchemaIntention.spring.schema.update=Spring 架构更新
SpringUpdateSchemaIntention.schema.update.failed.for.invalid.file=针对无效文件 {0} 的架构更新失败
reference.injector.spring.resource.path=Spring 资源路径
reference.injector.spring.bean.name=Spring Bean 名称
reference.injector.spring.placeholder=Spring 占位符
SpringSpiRegistrationAnnotator.choose.registration=选择注册
SpringSpiRegistrationAnnotator.tooltip=导航到 spring.factories 中的注册
SpringSpiRegistrationAnnotator.spring.factories.registration=spring.factories 注册
SpringBeansView.show.implicit.beans=显示隐式 Bean
SpringBeansView.show.infrastructure.beans=显示架构 Bean
SpringBeansView.show.modules=显示模块
SpringBeansView.show.application.contexts=显示应用程序上下文
SpringBeansView.config.no.contexts.defined=未定义应用程序上下文

application.context.configuration=应用程序上下文配置
ChangeActiveProfileDialogUi.radio.button.project=项目
ChangeActiveProfileDialogUi.radio.button.module=模块
ChangeActiveProfileDialogUi.radio.button.context=上下文
ChangeActiveProfileDialogUi.radio.button.comment=逗号分隔的配置文件列表
ChangeActiveProfileDialogUi.radio.button.profiles=配置文件:
ChangeActiveProfileDialogUi.radio.button.scope=范围:

SpringBeanMoveHandler.no.other.files.found=未找到其他 Spring 文件
SpringBeanMoveHandler.choose.file=选择文件

message.navigation.available.during.indexing=索引编制期间导航不可用
dependency.node.in.module.tail=(在模块 {0} 中)

spring.el.inspection.key=不正确的 Spring Expression Language (SpEl) 语法 
spring.bean.already.exists={1} 中已存在名为 ''{0}'' 的 Spring Bean

spring.bean.pointer.invalid=<无效>
spring.bean.pointer.unknown=<未知>

spring.beans.tab.title=Bean
spring.beans.select.in.target=Spring Bean
spring.intention.category=Spring
spring.factories.file.type=Spring 工厂
spring.aliases=别名
spring.profile=分析
spring.scope=范围
spring.depends.on.inspection.display.name=@DependsOn 注解中不正确引用的 Bean
config.detecting.contexts=正在检测应用程序上下文…
spring.scheduled.tasks=计划的任务
spring.scheduled.method=计划的方法
spring.el.static.field.inspection.key=在 static 字段中不正确地注入 SpEL
notification.group.spring.beans=Spring 自定义 Bean 解析失败
notification.group.spring.configuration=检测到 Spring 配置问题
action.SpringConfigurationCheckAction.text=检查 Spring 配置
spring.el.static.field.inpsection.key=在 static 字段中不正确地注入 SpEL
action.DlvDumpAction.text=转储 Goroutine
action.DlvEnableStringViewAction.text=启用 String() 视图
action.DlvFilterGoroutinesAction.description=仅显示包含特定字符串的堆栈
action.DlvFilterGoroutinesAction.task.name=筛选堆栈
action.DlvFilterGoroutinesAction.text=筛选
action.DlvResetHiddenGoroutinesAction.description=重置隐藏的 goroutine
action.DlvResetHiddenGoroutinesAction.text=重置隐藏的 Goroutine
action.DlvRewindAction.description=向后执行程序，直到到达上一个断点
action.DlvRewindAction.text=后退
action.DlvShowPointerAddressesToggleAction.text=显示指针地址
action.DlvShowTypesToggleAction.text=显示类型
action.DlvShowUnreadableVariablesAction.text=显示不可读的变量
action.DlvToggleThreadsAction.description=显示线程
action.DlvToggleThreadsAction.text=显示线程
action.Go.NewGoFile.description=创建新 Go 文件
action.Go.NewGoFile.text=Go 文件
action.GoAddContentRootFromGopath.description=将所选目录添加到当前项目
action.GoAddContentRootFromGopath.text=将目录添加到当前项目中
action.GoAddMethodToInterfaceAction.description=将方法添加到接口及其所有实现
action.GoAddMethodToInterfaceAction.text=添加方法…
action.GoCallHierarchyPopupMenu.BaseOnThisDeclaration.text=基于此声明
action.GoCoreDumpAction.text=打开核心转储…
action.GoEditActionsOnSaveAction.description=您可以在保存时运行的编辑操作
action.GoEditActionsOnSaveAction.text=保存时的操作…
action.GoEditSettingsAction.description=编辑 Go 特定设置
action.GoEditSettingsAction.description.os.specific=编辑 Go 特定的 {0}
action.GoEditSettingsAction.text=Go 设置…
action.GoEditSettingsAction.text.os.specific=Go {0}…
action.GoEditSettingsAction.text.synonym=Go 偏好设置…
action.GoFmtFileAction.description=使用 go fmt 工具格式化所选文件
action.GoFmtFileAction.text=Go Fmt 文件
action.GoFmtProjectAction.description=使用 go fmt 工具格式化项目
action.GoFmtProjectAction.text=Go Fmt 项目
action.GoGenerateConstructorAction.description=为结构体生成构造函数
action.GoGenerateConstructorAction.text=构造函数
action.GoGenerateFileAction.description=在所选文件上运行 go generate
action.GoGenerateFileAction.text=Go Generate 文件
action.GoGenerateGetterAction.description=为字段生成 getter 方法
action.GoGenerateGetterAction.text=Getter
action.GoGenerateGetterSetterAction.description=为字段生成 getter 和 setter 方法
action.GoGenerateGetterSetterAction.text=Getter 和 Setter
action.GoGenerateMethodAction.text=方法
action.GoGenerateSetterAction.description=为字段生成 setter 方法
action.GoGenerateSetterAction.text=Setter
action.GoGenerateStructFieldsFromJsonAction.description=从 JSON 生成结构体字段
action.GoGenerateStructFieldsFromJsonAction.text=JSON 中的结构体字段
action.GoGenerateTypeFromJsonAction.description=从 JSON 生成类型
action.GoGenerateTypeFromJsonAction.text=JSON 中的类型
action.GoIdeNewEmptyProjectAction.text=空项目…
action.GoIdeNewProjectAction.text=项目…
action.GoImportsFileAction.description=使用 goimports 工具优化所选文件的导入
action.GoImportsFileAction.text=Goimports 文件
action.GoIntroduceTypeAction.text=引入类型…
action.GoOpenInPlaygroundAction.description=在 Go Playground 中打开代码
action.GoOpenInPlaygroundAction.text=Playground
action.GoOpenProjectFromGopath.description=作为项目打开所选目录
action.GoOpenProjectFromGopath.text=作为项目打开目录
action.GoOpenSettings.description=打开项目的 Go 设置
action.GoOpenSettings.text=打开 Go 设置
action.GoRemoveContentRootAction.description=从当前项目中移除所选内容根目录
action.GoRemoveContentRootAction.text=分离目录…
action.GoReplayTraceAction.text=调试保存的跟踪…
action.GoShareInPlaygroundAction.confirmation=是否要将 {0} 上传到 Go Playground 并使之公开?
action.GoShareInPlaygroundAction.description=在 Go Playground 中共享当前文件
action.GoShareInPlaygroundAction.empty.id=Playground 返回空 ID
action.GoShareInPlaygroundAction.error=无法在 Go Playground 中共享文件\: {0}
action.GoShareInPlaygroundAction.notification.copyUrl=将 URL 复制到剪贴板
action.GoShareInPlaygroundAction.notification.text=Go Playground 中共享的文件\: <a href\="{0}">{0}</a>
action.GoShareInPlaygroundAction.text=在 Playground 中共享
action.GoToggleCachingAction.cachingDisabled=Go 插件缓存已禁用
action.GoToggleCachingAction.cachingEnabled=Go 插件缓存已启用
action.GoToggleCachingAction.description=切换 Go 插件中的缓存
action.GoToggleCachingAction.disableCaching=禁用 Go 插件缓存
action.GoToggleCachingAction.enableCaching=启用 Go 插件缓存
action.GoToggleCachingAction.text=切换 Go 插件缓存
action.GoVetFileAction.description=使用 go vet 工具对所选文件或目录执行 Lint 操作
action.GoVetFileAction.text=Go Vet 文件
action.HideGoroutine=隐藏 goroutine
action.HideSimilarGoroutines=隐藏具有相同堆栈的所有 goroutine
action.MergeIdenticalStacktraces.text=合并相同的堆栈跟踪
action.Vgo.NewGoModFile.description=创建 Go 模块文件
action.Vgo.NewGoModFile.text=Go 模块文件
action.Vgo.NewGoWorkFile.description=创建 Go 工作区文件
action.Vgo.NewGoWorkFile.text=Go 工作区文件
action.com.goide.vgo.actions.VgoSyncAction.description=同步 go 模块
action.com.goide.vgo.actions.VgoSyncAction.text=同步 Go 模块
action.com.goide.vgo.actions.VgoTidyAction.description=在模块中运行 `go mod tidy`
action.com.goide.vgo.actions.VgoTidyAction.text=Go Mod Tidy
action.com.goide.vgo.actions.VgoVendorAction.description=在模块中运行 'go mod vendor'
action.com.goide.vgo.actions.VgoVendorAction.text=Go Mod Vendor
action.go.exclude.package.from.import.and.completion=从导入和补全中排除 ''{0}''
action.go.fill.paragraph=填充段落
actions.on.save.gofmt.configure.action.link=配置 gofmt…
actions.on.save.gofmt.disabled.because.of.conflict.hint.label=仅应用 GoLand 格式设置；<br>由于与“{0}”File Watcher 冲突，<code>gofmt</code> 被禁用
actions.on.save.gofmt.disabled.hint.label=仅应用 GoLand 格式设置；<code>gofmt</code> 已禁用
actions.on.save.gofmt.enabled.hint.label=同时应用 GoLand 和 <code>gofmt</code> 格式设置
actions.on.save.imports.configure.action.link=配置 import 样式…
actions.on.save.imports.gofmt.order.hint.label=import 按 <code>gofmt</code> 顺序排序
actions.on.save.imports.goimports.order.hint.label=import 按 <code>goimports</code> 顺序排序
actions.on.save.imports.not.sorted.hint.label=import 未排序
advanced.setting.go.automatic.goproxy.switch=建议最佳的区域 GOPROXY
advanced.setting.go.automatic.goproxy.switch.description=需要时为您所在区域建议最佳 GOPROXY。这可能会提高 Go 模块依赖项的下载速度。
advanced.setting.go.modules.go.list.in.parallel=优化 'go list' 性能
advanced.setting.go.modules.go.list.in.parallel.description=同时执行 'go list'
advanced.setting.go.non.modal.welcome.screen.enabled=以非阻塞模式显示欢迎屏幕
advanced.setting.go.non.modal.welcome.screen.enabled.description=如果清除该复选框，则保留旧行为并将欢迎屏幕显示为单独的模态对话框。
advanced.setting.go.non.modal.welcome.screen.right.tab.enabled=显示非阻塞欢迎屏幕的右侧标签页
advanced.settings.go=Go
code.vision.add.method.to.interface.description=将方法添加到所有接口实现
code.vision.add.method.to.interface.name=将方法添加到实现
code.vision.implement.interface.description=在所选结构上实现特定接口
code.vision.implement.interface.name=实现接口
code.vision.update.all.dependencies.name=更新所有依赖项
code.vision.update.dependencies.description=更新 go.mod 文件中的依赖项
code.vision.update.dependencies.name=更新依赖项
code.vision.update.direct.dependencies.name=更新直接依赖项
exportable.GoSdkList.presentable.name=已知的 Go SDK 路径列表
exportable.vgo.presentable.name=已知的 Go 相关环境变量列表
filetype.go.build.description=Go\:build 约束
filetype.go.cgo.description=Cgo 文件
filetype.go.debug.description=Go\:debug 指令
filetype.go.description=Go 文件
filetype.go.plus.build.description=Go +build 约束
filetype.go.settings.modules.dependency.description=Go 模块依赖关系文件
filetype.go.tag.description=Go 标记
filetype.go.time.description=Go 时间
go.action.playground.connection.failed=连接到服务器失败
go.add.import.command.name=添加导入
go.add.import.with.alias.presentation={0} 作为 {1}
go.app.engine.not.gae.sdk.validation.message=App Engine 仅支持 Go 1.11 及更高版本
go.app.engine.wizard.description=创建 Go App Engine 项目以开发使用 Google App Engine 的 Go 应用程序。<br/>新模块包括 Go 中的默认配置设置和基本处理程序。
go.app.engine.wizard.name=App Engine
go.attach.directory.action.text=附加目录“{0}”
go.auto.import.and.completion.add.exclude.label=输入要从自动导入和补全中排除的导入路径\:
go.auto.import.and.completion.title=自动导入和补全
go.background.task.compiling.title=正在编译…
go.background.task.running.title=正在运行…
go.before.check.in.show.fmt.error.button=详细信息(&D)…
go.call.hierarchy.respect.interface.calls.action.name=遵循接口调用
go.call.hierarchy.respect.interface.calls.description=遵循接口调用
go.cannot.be.represented.by.type={0} 不能由类型 {1} 表示
go.checkin.factory.fmt.commit.anyway.question=仍要提交吗?
go.checkin.factory.fmt.failed.message=GoFmt 在某些文件上返回了非零代码。
go.checkin.factory.fmt.not.started.message=无法运行 gofmt。{0}
go.code.smells.commit.local.paths=提交本地路径可能无法移植
go.code.vision.implementations={0, choice, 1\#1 个实现|2\#{0,number} 个实现}
go.code.vision.usages={0,choice, 0\#无用法|1\#1 个用法|2\#{0,number} 个用法}
go.codeLens.inheritors.description=接口具有的后代数量。点击提示可导航到从此接口继承的代码。
go.codeLens.references.description=项目中顶层声明的使用次数。点击提示可导航到用法。
go.codeLens.vcs.code.vision.description=为类型、方法或任何其他代码元素编写代码的人员名称。该名称取自 VCS。
go.colors.and.fonts.bad.character=错误字符
go.colors.and.fonts.braces.and.operators=大括号和运算符
go.colors.and.fonts.braces.and.operators.braces=大括号
go.colors.and.fonts.braces.and.operators.brackets=中括号
go.colors.and.fonts.braces.and.operators.colon=冒号
go.colors.and.fonts.braces.and.operators.comma=逗号
go.colors.and.fonts.braces.and.operators.dot=点
go.colors.and.fonts.braces.and.operators.operator=运算符
go.colors.and.fonts.braces.and.operators.parentheses=括号
go.colors.and.fonts.braces.and.operators.semicolon=分号
go.colors.and.fonts.comments=注释
go.colors.and.fonts.comments.block.comment=块注释
go.colors.and.fonts.comments.build.constraints=构建约束
go.colors.and.fonts.comments.build.constraints.operators=运算符
go.colors.and.fonts.comments.build.constraints.parens=圆括号
go.colors.and.fonts.comments.build.constraints.tag=标记
go.colors.and.fonts.comments.comment.keyword=注释关键字
go.colors.and.fonts.comments.comment.reference=注释引用
go.colors.and.fonts.comments.line.comment=行注释
go.colors.and.fonts.declarations=声明
go.colors.and.fonts.declarations.constants=常量
go.colors.and.fonts.declarations.constants.builtin.constant=内置常量
go.colors.and.fonts.declarations.constants.local.constant=局部常量
go.colors.and.fonts.declarations.constants.package.exported.constant=软件包导出的常量
go.colors.and.fonts.declarations.constants.package.local.constant=软件包局部常量
go.colors.and.fonts.declarations.function.parameter=函数形参
go.colors.and.fonts.declarations.functions=函数
go.colors.and.fonts.declarations.functions.builtin.function=内置函数
go.colors.and.fonts.declarations.functions.exported.function=导出的函数
go.colors.and.fonts.declarations.functions.package.local.function=软件包局部函数
go.colors.and.fonts.declarations.label=标签
go.colors.and.fonts.declarations.method.receiver=方法接收器
go.colors.and.fonts.declarations.package=软件包
go.colors.and.fonts.declarations.struct.tags=结构体标记
go.colors.and.fonts.declarations.struct.tags.arbitraryText=任意文本
go.colors.and.fonts.declarations.struct.tags.colon=冒号
go.colors.and.fonts.declarations.struct.tags.key=键
go.colors.and.fonts.declarations.struct.tags.value=值
go.colors.and.fonts.declarations.types=类型
go.colors.and.fonts.declarations.types.package.exported.interface=软件包导出的接口
go.colors.and.fonts.declarations.types.package.exported.struct=软件包导出的结构体
go.colors.and.fonts.declarations.types.package.local.interface=软件包本地接口
go.colors.and.fonts.declarations.types.package.local.struct=软件包局部结构体
go.colors.and.fonts.declarations.types.type.specification=类型规范
go.colors.and.fonts.declarations.variables=变量
go.colors.and.fonts.declarations.variables.builtin.variable=内置变量
go.colors.and.fonts.declarations.variables.local.variable=局部变量
go.colors.and.fonts.declarations.variables.package.exported.variable=软件包导出的变量
go.colors.and.fonts.declarations.variables.package.local.variable=软件包局部变量
go.colors.and.fonts.declarations.variables.reassignment.in.short.variable.declaration=短变量声明中的重新赋值
go.colors.and.fonts.declarations.variables.scope.declared.variable=作用域声明变量
go.colors.and.fonts.declarations.variables.shadowing.variable=阴影变量
go.colors.and.fonts.declarations.variables.struct.exported.member=结构体导出的成员
go.colors.and.fonts.declarations.variables.struct.local.member=结构体局部成员
go.colors.and.fonts.identifier=标识符
go.colors.and.fonts.keyword=关键字
go.colors.and.fonts.number=数字
go.colors.and.fonts.references=引用
go.colors.and.fonts.references.function.calls=函数调用
go.colors.and.fonts.references.function.calls.builtin.function.call=内置函数调用
go.colors.and.fonts.references.function.calls.exported.function.call=导出的函数调用
go.colors.and.fonts.references.function.calls.local.function.call=局部函数调用
go.colors.and.fonts.references.type.references=类型引用
go.colors.and.fonts.references.type.references.builtin.type.reference=内置类型引用
go.colors.and.fonts.references.type.references.package.exported.interface=软件包导出的接口
go.colors.and.fonts.references.type.references.package.exported.struct=软件包导出的结构体
go.colors.and.fonts.references.type.references.package.local.interface=软件包本地接口
go.colors.and.fonts.references.type.references.package.local.struct=软件包局部结构体
go.colors.and.fonts.references.type.references.type.specification=类型规范
go.colors.and.fonts.references.variable.calls=变量调用
go.colors.and.fonts.references.variable.calls.exported.variable.call=导出的变量调用
go.colors.and.fonts.references.variable.calls.local.variable.call=局部变量调用
go.colors.and.fonts.references.variable.calls.package.local.variable.call=软件包局部变量调用
go.colors.and.fonts.references.variable.calls.struct.exported.member.call=结构体导出的成员调用
go.colors.and.fonts.references.variable.calls.struct.local.member.call=结构体局部成员调用
go.colors.and.fonts.string=字符串
go.colors.and.fonts.string.invalid.escape=无效的转义
go.colors.and.fonts.string.text=文本
go.colors.and.fonts.string.valid.escape=有效的转义
go.command.line.inspection.project.configurator.description=配置 Go 项目
go.command.line.inspection.project.configurator.download.dependencies=正在下载 Go 模块依赖项…
go.completion.add.tag.key.to.all.fields=向所有字段添加标记键…
go.completion.fill.all.fields.lookup.string=填充所有字段…
go.completion.fill.selected.fields.lookup.string=填充所选字段…
go.completion.generate.struct.fields.from.json=从 JSON 生成结构体字段…
go.completion.insert.case.clause=插入 case {0,choice,0\#子句|1\#子句|2\#子句}
go.completion.insert.if.not.nil.statement.command.name=插入 'if value \!\= nil {...}' 语句
go.completion.insert.literal.command.name=插入 Go 字面量
go.completion.insert.type.name.command.name=插入类型名称
go.completion.method.like.completion.advertisement=按 {0} 查看将表达式作为第一个实参的函数
go.completion.method.like.completion.command.name=函数的方法式补全
go.configuration.activity.name=Golang
go.converter.build.run.configuration.description='Go Build' 运行配置已更改。需要转换现有配置。
go.converter.build.tags.description=Go 项目设置存储机制已更改，需要更新项目及其模块。
go.converter.project.model.description=Go 项目模型已更改，请更新项目及其模块
go.converter.sdk.description=Go 项目模型已更改，请更新项目及其模块
go.converter.single.file.run.configuration.description='Run single Go file' 运行配置已移除。需要转换现有配置。
go.core.dump.dialog.dump.path.label=核心转储(&C)\:
go.core.dump.dialog.executable.label=可执行文件(&E)\:
go.core.dump.dialog.invalid.core.dump.validation.message=该文件不是有效的核心转储
go.core.dump.dialog.invalid.executable.validation.message=该文件不是可执行文件
go.core.dump.dialog.specify.core.dump.validation.message=指定核心转储
go.core.dump.dialog.specify.executable.validation.message=指定可执行文件
go.core.dump.failed.to.start.error.message=无法为核心转储 {0} 启动调试器\: {1}
go.core.dump.session.name=核心转储 {0}
go.create.intermediate.variable.declaration.fix.name=创建中间变量
go.create.new.file.action.command.name=创建 Go 文件 {0}
go.create.new.file.dialog.title=新建 Go 文件
go.create.new.file.empty.file.kind.name=空文件
go.create.new.file.simple.application.kind.name=简单应用程序
go.debug.show.goroutines.action.name=显示 Goroutine
go.debug.show.threads.action.name=显示线程
go.debugger.and.n.more=和其他 {0} 个
go.debugger.another.command.is.in.progress=正在执行另一条命令
go.debugger.async.stacktrace.caption=异步堆栈跟踪
go.debugger.breakpoint.title=Go 断点
go.debugger.cannot.calculate.string.presentation=无法计算字符串表示\: {0}
go.debugger.cannot.calculate.value=无法计算值
go.debugger.cannot.connect.non.remote=Delve 进程无法连接，因为它未使用远程连接
go.debugger.cannot.connect.twice=Delve 进程不能连接两次
go.debugger.cannot.evaluate.call=无法对调用求值\: {0}
go.debugger.cannot.evaluate.expression=无法对表达式 ''{0}'' 求值\: {1}
go.debugger.cannot.find.debugger.path=找不到 {0} 的调试器路径
go.debugger.cannot.find.file=找不到文件 {0}
go.debugger.cannot.find.free.port=无法为调试器找到可用 TCP 端口
go.debugger.cannot.get.current.goroutine=无法获取当前 goroutine
go.debugger.cannot.get.current.stack=无法获取当前堆栈
go.debugger.cannot.load.remaining.call.result.children=无法加载调用结果的剩余子级
go.debugger.cannot.pause=无法暂停
go.debugger.cannot.resolve.localhost=无法解析本地主机地址
go.debugger.cannot.retrieve.go.processes=无法检索 Go 进程
go.debugger.cannot.retrieve.interface.value.type=无法检索接口值的类型
go.debugger.connecting.to.address.message=正在连接到 {0}…
go.debugger.connecting.to.unknown.address.message=正在连接到远程地址…
go.debugger.connection.failed.generic.message=连接到 {0} 失败
go.debugger.create.dump.background.task.progress.text=正在转储堆栈({0})…
go.debugger.create.dump.background.task.title=正在转储堆栈…
go.debugger.custom.delve.extended.notification=正在使用自定义 Delve 进行调试\: {0}。删除 ''dlv.path'' <a href\=''customProperties''>自定义属性</a>并重启 IDE 以使用捆绑的 Delve。
go.debugger.custom.delve.notification=正在使用自定义 Delve 进行调试\: {0}
go.debugger.disconnected.unexpectedly=调试器意外断开连接
go.debugger.error.breakpoint.display.text=致命错误
go.debugger.error.breakpoint.title=Go 错误断点
go.debugger.expression.is.nil=''{0}'' 为零
go.debugger.expression.is.not.a.function=''{0}'' 不是函数
go.debugger.failed.to.compute.node.presentation=无法计算节点表示
go.debugger.failed.to.create.breakpoint=无法创建断点
go.debugger.failed.to.run.to.position=无法运行到位置
go.debugger.failed.to.stop.mozilla.rr.recording=无法停止 mozilla rr 记录
go.debugger.failed.to.stop.mozilla.rr.recording.details=无法停止 mozilla rr 记录\: {0}
go.debugger.fmt.sprintf.cannot.format.value=(无法设置值格式)
go.debugger.fmt.sprintf.unsupported.format=(不支持的格式)
go.debugger.fmt.sprintf.unsupported.verb=(不支持的动词)
go.debugger.go.version.is.not.officially.supported=Go {0} 不受该调试器的官方支持，某些功能可能无法正常使用。请更新到 Go {1} 或更高版本。
go.debugger.go.version.is.not.supported=Go {0} 不受该调试器的支持。请更新到 Go {1} 或更高版本。
go.debugger.goroutine=Goroutine
go.debugger.hidden.group.name=已隐藏({0})
go.debugger.install.gops.to.attach.to.go.processes=安装 {0} 以附加到 Go 进程
go.debugger.internal.messaging.error=内部消息传递错误
go.debugger.kill.existing.process.message=是否要终止调试器所连接的远程进程?
go.debugger.kill.existing.process.title=终止远程进程
go.debugger.local.attach.group.name=Go
go.debugger.missing.current.function=缺少当前函数
go.debugger.missing.function.name=<缺少>
go.debugger.no.debug.information.for.file=可执行文件不包含 {0} 的调试信息
go.debugger.non.top.frame.selected=已选择非顶部框架
go.debugger.obsolete.value=<过时>
go.debugger.only.first.goroutines.are.shown=仅显示第一个 {0} goroutines
go.debugger.process.terminated.stop.remote.delve.message=远程进程已终止。是否也要停止远程 Delve 实例?
go.debugger.record.and.debug.action.name=录制并调试
go.debugger.record.and.debug.cannot.find.rr.message=<html>找不到 <a href\="https\://rr-project.org">mozilla rr</a> 可执行文件。请安装并将其添加到 PATH 中。</html>
go.debugger.record.and.debug.description=录制并调试
go.debugger.record.and.debug.start.action.text=录制并调试
go.debugger.recording.in.progress=正在记录程序执行。要调试记录，请等待程序终止或<a href\=''{0}''>停止记录</a>。
go.debugger.renderers.binary.name=二进制
go.debugger.renderers.decimal.name=十进制
go.debugger.renderers.hex.name=十六进制
go.debugger.smart.step.into.failed=智能步入失败\: {0}
go.debugger.smart.step.into.popup.title=步入函数
go.debugger.stop.remote.delve.message=是否要停止远程 Delve 实例?
go.debugger.stop.remote.delve.title=停止远程 Delve
go.debugger.thread=线程
go.debugger.thread.dump.display.name=转储 {0}
go.debugger.thread.dump.error=无法获取线程转储\: {0}
go.debugger.thread.dump.incomplete.display.name=转储 {0} 不完整
go.debugger.thread.dump.is.in.progress=正在进行线程转储
go.debugger.thread.dump.n.goroutines={0} {0,choice,0\#goroutines|1\#goroutine|2\#goroutine}
go.debugger.thread.dump.n.goroutines.matched.by.filter={0} 个 {0, choice, 0\#goroutine|1\#goroutine|2\#goroutine} 通过筛选器匹配
go.debugger.thread.dump.n.hidden.goroutines={0} 隐藏的 {0,choice,0\#goroutines|1\#goroutine|2\#goroutines}
go.debugger.thread.dump.n.unique.stacks={0} 个唯一{0,choice,0\#堆栈|1\#堆栈|2\#堆栈}
go.debugger.unknown.function.name=<未知>
go.debugger.unreadable.error=\ 不可读\: {0}
go.debugger.unsupported.architecture.error=仅 64 位系统和 32 位 Linux 系统支持调试
go.debugger.unsupported.go.arch.on.darwin.arm64.error=不支持调试使用 {0} 编译的程序。对 darwin/arm64 使用 go sdk。
go.debugger.unsupported.go.version.on.darwin.arm64.error=在 darwin/arm64 上调试要求 Go 1.16
go.debugger.unsupported.type=<不支持的类型\: {0}>
go.debugger.unsupported.wsl1=不支持在 WSL1 上调试，请使用 WSL2
go.debugger.unused.functions.are.not.included.message=" (未使用的函数未包含在可执行文件中)"
go.debugger.unused.methods.are.not.included.message=" (未使用的方法未包含在可执行文件中)"
go.declarations.intentions.category=Go/声明
go.detach.directory.action.text=分离目录“{0}”
go.dfa.global.explain.dereference.problems.view.panel.name=数据流分析
go.dfa.global.explain.dereference.trace.tab.close.text=关闭
go.dfa.global.ui.show.trace.action.marker.invalidation=不再有效
go.dfa.global.ui.show.trace.panel.node.sink.label=Nil 解引用
go.dfa.global.ui.show.trace.panel.node.source.label=Nil 源
go.dfa.global.ui.show.trace.panel.node.step.description=步骤描述
go.dfa.global.ui.show.trace.panel.node.step.label=第 {0} 步
go.dfa.quickdoc.parameter.of.type.must.be.non.nil={0} {1}}必须为{2}
go.dfa.quickdoc.result.of.type.is.always.non.nil=结果 {0} 始终为 {1}
go.dfa.quickdoc.result.of.type.may.be.nil=结果 {0} 可能为 {1}
go.dfa.quickdoc.section.nilability.info.name=为 nil 性信息
go.edit.auto.import.settings.action.name=编辑自动导入设置
go.element.is.not.go.expression.error.hint=选区不包含 Go 表达式
go.empty.element.text=<空>
go.empty.project.wizard.name=空项目
go.enable.template.plugin.action.text=启用插件
go.enable.template.plugin.notification.text=启用 Go 模板以增强 html/templates 软件包中的突出显示、补全和导航功能
go.error.annotator.anonymous.interface.cycle=无效的递归类型\: 匿名接口引用其自身
go.error.annotator.argument.is.not.a.type={0} 不是类型
go.error.annotator.array.bound.must.be.a.constant.expression=无效的数组绑定 ''{0}''，必须是一个常量表达式
go.error.annotator.array.bound.must.be.non.negative=无效的数组绑定 ''{0}''，必须为非负
go.error.annotator.array.bound.must.be.representable.by.int.type=无效的数组绑定 ''{0}''，该值必须可以通过 ''int'' 类型表示
go.error.annotator.assignment.count.mismatch=赋值计数不匹配\: {0} \= {1}
go.error.annotator.bad.octal.escape=八进制转义必须包含三个八进制数字，第一个数字必须小于或等于 3
go.error.annotator.binary.digits.are.not.supported=从 Go 1.13 开始支持二进制数字
go.error.annotator.break.statement.not.inside.a.for.loop.select.or.switch='break' 语句在 'for'、'select' 或 'switch' 语句外部
go.error.annotator.call.used.as.value.but.it.returns.nothing={0} 用作值，但它不返回任何内容
go.error.annotator.can.only.use.triple.dot.as.final.argument=只能将 '...' 用作列表中的最后一个实参
go.error.annotator.cannot.assign.to.expression=无法分配给 {0}
go.error.annotator.cannot.call.pointer.method=无法在 ''{0}'' 中调用指针方法
go.error.annotator.cannot.declare.in.post.statement.of.for.loop=无法在 for 循环的 post 语句中声明变量
go.error.annotator.cannot.declare.init.must.be.a.function=无法声明 init，必须为函数
go.error.annotator.cannot.embed.type.parameter=无法嵌入类型形参
go.error.annotator.cannot.fallthrough.final.case.in.switch=不能在 'switch' 语句的 final case 中使用 'fallthrough'
go.error.annotator.cannot.fallthrough.in.type.switch=无法在类型 switch 中使用 'fallthrough'
go.error.annotator.cannot.infer.types=无法推断{0}
go.error.annotator.cannot.make.type=无法生成 {0}
go.error.annotator.cannot.make.type.no.single.underlying.type=无法设为 {0}；类型集没有单个基础类型
go.error.annotator.cannot.reassign.a.constant=不能重新分配常量
go.error.annotator.cannot.use.comparable.in.union=不能在 union 中使用 comparable
go.error.annotator.cannot.use.generic.function.without.instantiation=未经不实例化就不能使用泛型函数
go.error.annotator.cannot.use.interface.with.methods.in.union=在 union 中不能将接口与方法结合使用
go.error.annotator.cannot.use.triple.dot.for.output.arguments=无法在输出实参列表中使用 '...'
go.error.annotator.cannot.use.type.assertion.on.type.parameter=无法对类型形参值 {0} 使用类型断言
go.error.annotator.cannot.use.type.embedding.comparable.in.union=不能在 union 中使用 ''{0}'' (''{0}'' 会嵌入 comparable)
go.error.annotator.cannot.use.type.parameter.as.constraint=不能将类型形参用作约束
go.error.annotator.cannot.use.type.parameter.as.rhs.in.type.declaration=不能在类型声明中将类型形参用作 RHS
go.error.annotator.cannot.use.type.switch.on.type.parameter=无法对类型形参值 {0} 使用类型切换
go.error.annotator.closing.single.quote.expected=应为右 '
go.error.annotator.comparable.outside.of.type.parameter=不能在类型约束之外使用类型 comparable \: 接口(或嵌入)为 comparable
go.error.annotator.const.initializer.is.not.a.constant=常量初始值设定项 ''{0}'' 不是常量
go.error.annotator.constraint.elements.outside.of.type.parameter=接口包含约束{0,choice,1\#元素|2\#元素} {1}，只能在类型形参中使用
go.error.annotator.constraint.outside.of.type.parameter=接口包括约束元素，只能在类型形参中使用
go.error.annotator.constraint.term.on.interface=~ 的使用无效(''{0}'' 为接口)
go.error.annotator.constraint.term.underlying.type.is.not.self=~ 的使用无效(''{0}'' 的基础类型不是 ''{0}'')
go.error.annotator.continue.statement.not.inside.a.for.loop='continue' 语句在 'for' 循环外部
go.error.annotator.conversion.in.defer.or.go={0} 需要函数调用，而不是转换
go.error.annotator.cyclic.definition.detected=检测到循环定义
go.error.annotator.defer.or.go.requires.function.call={0} 中的表达式必须为函数调用
go.error.annotator.digit.separator.is.not.supported=从 Go 1.13 开始支持数字分隔符
go.error.annotator.embedded.type.cannot.be.a.pointer=嵌入类型不能是指针
go.error.annotator.embedded.type.cannot.be.a.pointer.to.a.type.parameter=嵌入的类型不能是指向类型形参的指针
go.error.annotator.embedded.type.cannot.be.a.pointer.to.interface=嵌入类型不能是指向接口的指针
go.error.annotator.embedded.type.cannot.be.a.type.parameter=嵌入的类型不能是类型形参
go.error.annotator.empty.rune.literal=空卢恩字面量
go.error.annotator.end.of.file.in.comment=文件结尾位于注释中
go.error.annotator.evaluated.but.not.used={0} 已求值但未使用
go.error.annotator.extra.expression.in.const.declaration=常量声明中有额外表达式
go.error.annotator.fallthrough.statement.out.of.place='fallthrough' 语句位置不当
go.error.annotator.func.literal.cannot.have.type.parameters=函数字面量不能有类型形参
go.error.annotator.function.not.permitted.in.defer.or.go=无法在 {0} 语句中调用此函数
go.error.annotator.function.type.cannot.have.type.parameters=函数类型不能有类型形参
go.error.annotator.generic.type.cannot.be.alias=泛型不能是别名
go.error.annotator.got.n.arguments.but.m.type.parameters=已获得 {0} 个实参，但有 {1} 个类型形参
go.error.annotator.hex.floats.are.not.supported=从 Go 1.13 开始支持十六进制浮点
go.error.annotator.interface.method.must.have.no.type.parameters=接口方法不能有类型形参
go.error.annotator.invalid.argument.for.cap=cap 函数的实参无效
go.error.annotator.invalid.argument.for.len=len 函数的实参无效
go.error.annotator.invalid.constant.type=无效的常量类型
go.error.annotator.invalid.embedded.type=无效的类型 {0}\: 必须为 typeName 或 *typeName
go.error.annotator.invalid.escape.sequence=无效转义序列
go.error.annotator.invalid.hex.escape.sequence.syntax=\\x 必须后跟两个十六进制数字
go.error.annotator.invalid.index.or.slice.operation=无效的操作 {0} (字符串的 3 索引切片)
go.error.annotator.invalid.long.unicode.escape.sequence.syntax=\\U 必须后跟八个十六进制数字
go.error.annotator.invalid.method.expression=无效的方法表达式(需要指针接收器)
go.error.annotator.invalid.package.name=无效的软件包名称
go.error.annotator.invalid.select.assignment=select 赋值的右侧必须有接收运算
go.error.annotator.invalid.select.case=Select case 必须具有接收运算、发送运算、赋值或短变量声明
go.error.annotator.invalid.type.assertion=无效的类型断言\: {0} (左侧为非接口类型 {1})
go.error.annotator.invalid.type.switch.guard=无效的类型 switch guard\: {0} (左侧为非接口类型 {1})
go.error.annotator.invalid.unicode.code.point=无效的 Unicode 代码点
go.error.annotator.invalid.unicode.escape.sequence.syntax=\\u 必须后跟四个十六进制数字
go.error.annotator.is.not.a.generic.type={0} 不是泛型类型
go.error.annotator.list.of.type.arguments.must.not.be.empty=类型实参列表不得为空
go.error.annotator.list.of.type.parameters.must.not.be.empty=类型形参列表不得为空
go.error.annotator.main.or.init.has.invalid.signature={0} 函数不得有实参和返回值
go.error.annotator.map.key.type.is.not.comparable=无效的映射键类型\: 必须为键类型完全定义比较运算符 \=\= 和 \!\=
go.error.annotator.method.cannot.have.type.parameters=方法不能有类型形参
go.error.annotator.method.name.in.interface.cannot.be.blank=接口中的方法名称不能为空
go.error.annotator.min.max.clear.call.requires.go.1.21={0} 需要 Go 1.21 或更高版本
go.error.annotator.missing.argument.to.make=缺少要生成的实参
go.error.annotator.missing.condition.in.if.statement='if' 语句中缺少条件
go.error.annotator.missing.function.body=缺少{0}正文
go.error.annotator.missing.key.in.map.literal=映射字面量中缺少键
go.error.annotator.missing.len.argument.to.make=make 函数中缺少 len 实参
go.error.annotator.missing.value.in.const.declaration=常量声明中缺少值
go.error.annotator.multiple.defaults={0} 中存在多个默认值
go.error.annotator.multiple.value.in.single.value.context=单值上下文中存在多值 {0}
go.error.annotator.named.and.unnamed.parameters={0} 同时具有命名形参和未命名形参 ''{1}''
go.error.annotator.named.and.unnamed.return.parameters={0} 同时具有命名和未命名的返回形参 ''{1}''
go.error.annotator.needs.experiment.for.generic.type.aliases=无法使用泛型类型别名，因为未启用 'aliastypeparams' Go 实验。
go.error.annotator.needs.experiment.for.range.over.func=无法使用 range-over-function 子句，因为未启用 'rangefunc' Go 实验。
go.error.annotator.needs.update.for.generic.type.aliases=无法使用泛型类型别名，请使用 Go 1.23 及更高版本。
go.error.annotator.needs.update.for.range.over.func=无法使用 range-over-function 子句，请使用 Go 1.22 及更高版本。
go.error.annotator.needs.update.for.range.over.int=无法使用 range-over-integer 子句，请使用 Go 1.22 及更高版本。
go.error.annotator.new.line.in.string=字符串中出现新行
go.error.annotator.no.new.variables='\:\=' 的左侧没有新变量
go.error.annotator.no.variables.allowed.in.range.over.func=''{0}'' 上的 ''range'' 子句不允许任何迭代变量
go.error.annotator.non.integer.capacity.argument.to.make=make 函数中存在非整数容量实参
go.error.annotator.non.integer.size.argument.to.make=make 函数中存在非整数大小实参
go.error.annotator.octal.prefix.is.not.supported=从 Go 1.13 开始支持八进制前缀
go.error.annotator.parenthesized.expression.in.defer.or.go={0} 中的表达式不得使用括号
go.error.annotator.problem.capacity.less.than.size.to.make=容量不得小于大小
go.error.annotator.problem.negative.capacity.to.make=make 函数中存在负容量实参
go.error.annotator.problem.negative.size.to.make=make 函数中存在负大小实参
go.error.annotator.problem.redundant.capacity.hint.to.make=冗余容量提示
go.error.annotator.problem.redundant.size.hint.to.make=冗余大小提示
go.error.annotator.reference.is.not.a.type={0} 不是类型
go.error.annotator.semicolon.is.missing=缺少 ;
go.error.annotator.shadowed.receiver.is.not.a.generic.type={0} 不是泛型类型(接收器由类型形参隐藏)
go.error.annotator.too.many.arguments.to.make=make 函数中的实参过多
go.error.annotator.too.many.arguments.to.new=实参过多，无法添加新实参
go.error.annotator.too.many.characters.in.rune.literal=rune 字面量中的字符数过多
go.error.annotator.too.many.variables.in.range.over.array=数组上的 'range' 子句最多需要两个迭代变量
go.error.annotator.too.many.variables.in.range.over.chan=通道上的 'range' 子句最多需要一个迭代变量
go.error.annotator.too.many.variables.in.range.over.func=''{0}'' 上的 ''range'' 子句最多需要 {1} 个迭代{1,choice,0\#变量|1\#变量|2\#变量}
go.error.annotator.too.many.variables.in.range.over.int=整数上的 'range' 子句最多需要一个迭代变量
go.error.annotator.too.many.variables.in.range.over.map=映射上的 'range' 子句最多需要两个迭代变量
go.error.annotator.too.many.variables.in.range.over.slice=切片上的 'range' 子句最多需要两个迭代变量
go.error.annotator.too.many.variables.in.range.over.string=字符串上的 'range' 子句最多需要两个迭代变量
go.error.annotator.type.aliases.are.available.since.go.1.9=类型声明中存在意外的 '\='；类型别名自 Go 1.9 以后可用
go.error.annotator.type.cannot.be.declared.in.generic.function=Go SDK {0} 不支持泛型函数中的类型声明，请使用 Go SDK 1.20 或更高版本
go.error.annotator.type.cannot.be.declared.in.generic.method=Go SDK {0} 不支持泛型方法中的类型声明，请使用 Go SDK 1.20 或更高版本
go.error.annotator.type.constraint.is.missing=缺少类型约束
go.error.annotator.type.is.not.an.expression=类型 ''{0}'' 不是表达式
go.error.annotator.type.parameters.are.not.supported=从 Go 1.18 开始支持泛型
go.error.annotator.unexpected.assign.operator=意外的 {0}，应为 ''\:\=''、''\='' 或 '',''
go.error.annotator.unexpected.end.of.statement=语法错误\: 语句意外结束，应为 '\:\='、'\=' 或 ','
go.error.annotator.unexpected.newline.after.if=意外换行，在 'if' 子句后应为 '{'
go.error.annotator.unexported.reference.usage=无法在当前软件包中使用未导出的{0} ''{1}''
go.error.annotator.use.of.generic.type.without.instantiation=在不实例化的情况下使用泛型
go.error.annotator.use.of.package.without.selector=使用无选择器的软件包 ''{0}''
go.error.annotator.use.of.type.outside.type.switch=在类型 switch 外部使用 .(type)
go.error.go.build.after.package=go\:build 指令必须位于 package 子句前面
go.error.go.build.and.plus.build.lines.dont.match=//+build 行不匹配 //go\:build 条件
go.error.go.build.expression.is.too.complex=表达式对于 //+build 行过于复杂
go.error.go.build.non.first.element=go\:build 指令必须为代码行的第一个元素
go.error.go.build.only.one.allowed=一个文件中只允许使用一条 //go\:build 指令
go.error.go.build.without.plus.build=//go\:build 注释没有 //+build 注释
go.error.go.embed.all.prefix.not.supported=路径模式无效，'all\:' 前缀需要 Go 1.18
go.error.go.embed.empty.directory=无法嵌入空目录
go.error.go.embed.file.must.import.embed=包含 go\:embed 的 Go 文件必须导入 "embed" 软件包
go.error.go.embed.invalid.path.elements=路径不得包含 '.' 或 '..' 路径元素，也不得以前导斜杠开头
go.error.go.embed.invalid.path.pattern=路径模式无效
go.error.go.embed.invalid.syntax.of.paths=路径模式语法无效
go.error.go.embed.must.be.above.var.declaration=go\:embed 必须位于单个全局变量声明的上方
go.error.go.embed.no.path.arguments=go\:embed 后面应为路径模式
go.error.go.embed.not.supported=自 Go 1.16 起支持 go\:embed
go.error.go.embed.path.must.resolve.to.file='string' 和 '[]byte' 类型的变量只能嵌入一个文件
go.error.go.embed.single.path.expected='string' 和 '[]byte' 类型的变量只能有一个路径模式
go.error.go.embed.unresolved.path=未解析路径
go.error.go.embed.var.has.wrong.type=go\:embed's 变量必须为 'string'、'[]byte' 或 'embed.FS' 类型
go.error.go.plus.build.can.be.converted.to.go.build=//+build 注释可以转换为 //go\:build 指令
go.error.go.plus.build.can.be.removed=可以移除 //+build 注释
go.error.invalid.double.negation=双重求反无效
go.error.invalid.non.alphanumeric.character=非字母数字字符无效
go.error.parser.expected=应为 ''{0}''
go.error.parser.expected.got=应为 ''{0}''，但得到的是 ''{1}''
go.error.parser.expected.or=应为 ''{0}'' 或 ''{1}''
go.error.parser.expected.or.got=应为 ''{0}'' 或 ''{1}''，但得到的是 ''{2}''
go.error.parser.godebug.expected.key=缺少 'go\:debug' 键
go.error.parser.godebug.expected.value=缺少 'go\:debug' 值
go.error.parser.missing.slice.expr.index=切片表达式中缺少{0,choice,2\#第二个|3\#第三个}索引
go.error.parser.unexpected=意外的''{0}''
go.error.windows.project.wsl.sdk=无法使用 WSL SDK 编译 Windows 项目
go.error.wsl.project.requires.wsl.sdk=WSL 中的项目需要 WSL 中的 Go SDK
go.error.wsl.project.requires.wsl.sdk.from.same.instance=WSL 中的项目需要来自同一个 WSL 实例的 Go SDK
go.error.wsl.project.windows.sdk=无法使用 Windows SDK 编译 WSL 项目
go.error.wsl.sdk.cannot.be.used.for.windows.project=WSL 中的 Go SDK 不能用于 Windows 项目
go.exclude.fmt.function.dialog.checkbox=非项目(&N)
go.exclude.fmt.function.dialog.title=选择格式设置函数
go.exclude.import.path.dialog.empty.path.validation.message=导入路径不能为空
go.exclude.import.path.dialog.title=排除导入路径
go.exclude.import.path.from.completion.action.name=排除 ''{0}''
go.execution.application.process.name=进程
go.execution.application.run.configuration.description=Go 构建运行配置
go.execution.application.run.configuration.display.name=Go 构建
go.execution.before.run.task.command.should.not.start.with.go.error=Go 命令不应以 'go' 开头
go.execution.before.run.task.description=运行 ''{0}''
go.execution.before.run.task.edit.go.command.dialog.title=编辑 Go 命令任务
go.execution.before.run.task.empty.command.error=不允许空 Go 命令
go.execution.before.run.task.error.dialog.title=Go 命令任务
go.execution.before.run.task.executing.presentable.name=正在执行 ''{0}''
go.execution.before.run.task.name=运行 Go 命令
go.execution.before.run.task.supports.only.go.modules.error=Go 命令任务仅支持启用了 Go 集成的模块
go.execution.before.run.task.supports.only.go.run.configurations.error=Go 命令任务仅支持 Go 运行配置
go.execution.can.not.run.go.local.process.error=无法运行 Go 本地进程
go.execution.cannot.create.output.file.error=无法创建输出文件 {0}
go.execution.cannot.create.output.file.in.error=无法在 {0} 中创建输出文件
go.execution.cannot.create.temp.output.file.error=无法创建临时输出文件
go.execution.cannot.find.directory.error=找不到目录 <code>{0}</code>
go.execution.cannot.find.input.file.error=找不到输入文件 <code>{0}</code>
go.execution.cannot.find.package.error=找不到软件包 <code>{0}</code>
go.execution.cannot.find.target.error=找不到目标 {0}
go.execution.cannot.find.target.to.compile.error=找不到要编译的目标
go.execution.cannot.find.working.directory.error=找不到工作目录 <code>{0}</code>
go.execution.cannot.make.temporary.file.executable.error=无法使临时文件成为可执行文件 {0}
go.execution.cannot.resolve.test.function=无法确定测试执行的构建标记\: 找不到函数 <code>{0}</code>。请确保索引编制过程已完成。
go.execution.change.goroot.action.name=更改 GOROOT
go.execution.compilation.failed.notification.title=编译失败
go.execution.compilation.finished.with.exit.code=编译完成，并显示退出代码 $EXIT_CODE$
go.execution.compiled.binary.cannot.be.executed=无法执行已编译的二进制文件
go.execution.could.not.bind.remote.debugging.port.error=无法绑定远程调试端口
go.execution.coverage.cannot.run.coverage.on.directory.kind.run.configurations.error=无法在目录种类运行配置上运行覆盖率分析
go.execution.coverage.covered=已覆盖
go.execution.coverage.downloading.coverage.report.progress.title=正在处理覆盖率报告…
go.execution.coverage.engine.name=Go 覆盖率
go.execution.coverage.failed.to.create.or.clear.coverage.dir=无法创建或清理覆盖率目录 ''{0}''
go.execution.coverage.loading.coverage.data=正在加载覆盖率数据…
go.execution.coverage.percent.files=% 文件
go.execution.coverage.percent.statements=% 语句
go.execution.coverage.runner.name=Go
go.execution.debugger.process.name=调试器
go.execution.directory.is.not.specified.error=未指定目录
go.execution.dlv.not.found.for=找不到 {0}/{1} 的 Delve 可执行文件。通过在 ''帮助 | 编辑自定义属性'' 中添加 ''dlv.path\=/path/to/delve'' 来指定 Delve 位置。
go.execution.dlv.not.found.for.target.platform=找不到目标平台的 Delve 可执行文件。通过在 '帮助 | 编辑自定义属性' 中添加 'dlv.path\=/path/to/delve' 来指定 Delve 位置。
go.execution.duplicate.file.error=文件已在列表中\: {0}
go.execution.enter.sudo=输入您的 sudo 密码\:
go.execution.failed.to.prepare.remote.environment.error=无法准备远程环境\: {0}
go.execution.file.is.not.specified.error=未指定文件
go.execution.file.not.found.error=找不到文件\: <code>{0}</code>
go.execution.files.must.be.in.one.directory.error=命名文件必须全部位于一个目录中
go.execution.go.is.not.configured.error=没有为此运行配置配置 Go\: {0}
go.execution.go.sdk.is.not.downloaded.yet=Go SDK 尚未下载
go.execution.go.setup.folding.placeholder=<{0} go 设置{0,choice,1\#调用|2\#调用}>
go.execution.input.file.is.not.specified.error=未指定输入文件
go.execution.install.lldb.notification.text=使用 xcode-select --install 安装 lldb
go.execution.module.does.not.exist.error=模块 <code>{0}</code> 在项目中不存在
go.execution.not.go.file.error=文件不是 Go 文件\: {0}
go.execution.outdated.go.notification.text=要完全支持所有调试功能，请更新 Go 版本。
go.execution.outdated.go.notification.title=您的 Go 版本已过时
go.execution.package.contains.several.mains.error=软件包 <code>{0}</code> 包含多个 <code>main</code> 函数<br>请考虑改用文件种类
go.execution.package.is.not.specified.error=未指定软件包
go.execution.process.cancelled=已取消
go.execution.process.failed.to.run=运行失败
go.execution.process.finished.successfully=成功完成
go.execution.process.finished.with.exit.code={0} 已完成，退出代码为 {1}
go.execution.process.interrupted=已中断
go.execution.remote.run.configuration.description=Go Remote
go.execution.remote.run.configuration.display.name=Go Remote
go.execution.remote.run.configuration.host.label=主机(&H)\:
go.execution.remote.run.configuration.port.label=端口(&P)\:
go.execution.remote.run.configuration.start.delve.text=在运行此配置之前，请按以下说明启动您的应用程序和 Delve。<br> <br>允许 Delve 编译您的应用程序\: <br><pre>dlv debug --headless --listen\=\:{0} --api-version\=2 --accept-multiclient</pre><br>或使用 Go {3} 或更高版本编译应用程序\: <br><pre>go build -gcflags "all\=-N -l" github.com/app/demo</pre><br>，然后使用以下命令在 Delve 中运行\: <br><pre>dlv --listen\=\:{1} --headless\=true --api-version\=2 --accept-multiclient exec ./{2}</pre>
go.execution.run.after.build.is.not.possible.incompatible.os.error=无法在构建后运行<br>结果二进制文件将与操作系统不兼容
go.execution.run.after.build.is.not.possible.main.not.found.many.files.error=无法在构建后运行<br>所选文件都没有 'main' 软件包和 'main' 函数
go.execution.run.after.build.is.not.possible.main.not.found.single.file.error=无法在构建后运行<br>'main' 文件具有非 main 软件包或不包含 'main' 函数
go.execution.run.application.tooltip=运行应用程序
go.execution.scratch.runconfig.extension.different.contexts.notification=''{0}'' 运行配置针对为上下文使用不同模块的临时文件。请针对为上下文使用同一个模块的临时文件。
go.execution.scratch.runconfig.extension.edit.notification.action=编辑运行配置
go.execution.scratch.runconfig.extension.edit.notification.title=运行配置的目标无效
go.execution.scratch.runconfig.extension.wrong.kind.notification=''{0}'' 运行配置使用{1}运行种类。请在临时文件的运行配置中使用“文件”运行种类。
go.execution.sdk.is.not.specified.error=没有为模块 <code>{0}</code> 指定 Go SDK
go.execution.sdk.not.set.or.sdk.home.path.empty.for.module.error=未设置 SDK 或此模块的 SDK 主路径为空
go.execution.test.collecting.build.tags.progress.title=正在收集构建标记…
go.execution.unknown.error=未知错误，详情参见日志
go.execution.unknown.target.delve.socket.error=无法运行 Delve。目标套接字未知。RunState\: {0}
go.execution.working.directory.is.not.specified.error=未指定工作目录
go.external.system.auto.import.is.disabled=由于设置了 'external.system.auto.import.disabled' 注册表项，IDE 无法正常运行。请禁用此设置并重启 IDE。
go.file.watcher.gofumpt.description=在当前 Go 文件目录中运行 'gofumpt'
go.file.watcher.golangci.description=在当前 Go 文件目录中运行 'golangci-lint'
go.find.usages.of.interface.methods.dialog.base.methods.checkbox=基方法(&B)
go.find.usages.of.interface.methods.dialog.message=类型 ''{0}'' 实现接口，方法 ''{1}'' 重写方法。是否要查找接口方法的用法?
go.find.usages.of.interface.methods.dialog.title=查找接口方法的用法?
go.find.usages.of.interface.methods.notification.show.options.text=显示选项 {0}
go.find.usages.of.interface.methods.notification.title=正在查找接口方法的用法
go.find.usages.show.usages.in.comments.description=在注释中显示元素用法
go.find.usages.show.usages.in.comments.text=在注释中显示用法
go.fix.add.comma.name=添加逗号
go.fix.add.comment.name=添加注释
go.fix.add.explicit.dereference.name=添加显式解引用
go.fix.add.function.block.name=添加正文
go.fix.add.function.call.name=添加函数调用
go.fix.add.import.for.side.effects.name=副作用导入
go.fix.add.keys.to.struct.literal.value.name=添加键并删除零值
go.fix.add.local.var.for.expression.name=引入局部变量
go.fix.add.missing.new.line.name=添加缺少的新行
go.fix.add.missing.return.value.name=添加缺少的返回值
go.fix.add.plus.build.comments=添加 //+build 注释
go.fix.add.pointer.name=添加指针
go.fix.add.prefix.to.comment.name=向注释中添加 ''{0}'' 前缀
go.fix.add.return.statement.name=添加 return 语句
go.fix.add.square.brackets=添加中括号
go.fix.add.whitespace.name=添加空格
go.fix.always.false.for.name=移除 'for' 循环
go.fix.always.false.if.name=移除 'if' 分支
go.fix.always.true.for.name=移除冗余条件
go.fix.always.true.if.name=移除其他分支并简化当前的 'if'
go.fix.call.receiver.is.not.an.expression=意外的调用接收器，不是表达式
go.fix.change.array.size.to=将数组大小更改为 {0}
go.fix.change.array.size.to.family.name=更改数组大小
go.fix.change.import.sorting.settings.name=更改导入排序设置
go.fix.change.parameters.name=更改形参
go.fix.change.parameters.parameter={0,choice,0\#形参|1\#形参|2\#形参}
go.fix.change.result.parameters.in.assignment.name=更改赋值中的结果形参
go.fix.change.result.parameters.in.call.name=更改调用中的结果形参
go.fix.change.result.parameters.in.return.name=更改返回中的结果形参
go.fix.change.result.parameters.in.variable.specification.name=更改变量规范中的结果形参
go.fix.change.result.parameters.name=更改结果形参
go.fix.change.result.parameters.result.parameter={0,choice,0\#结果形参|1\#结果形参|2\#结果形参}
go.fix.change.signature.from.function.type.name=从函数类型更改签名
go.fix.change.signature.from.function.type.text=将{0} ''{1}'' 的签名更改为 ({2}) ({3})
go.fix.change.signature.from.usage.add=将 ''{0}'' 作为第 {1,number,ordinal} 个{2}添加到{3} ''{4}'' 中
go.fix.change.signature.from.usage.change=将{2} ''{3}'' 的第 {0,number,ordinal} 个{1}从 ''{4}'' 更改为 ''{5}''
go.fix.change.signature.from.usage.mix=将{1} ''{2}'' 的{0}更改为 ({3})
go.fix.change.signature.from.usage.remove=从{2} ''{3}'' 中移除第 {0,number,ordinal} 个{1}
go.fix.change.signature.from.usage.text=从用法更改签名
go.fix.change.signature.to.expected.name=对预期签名的更改
go.fix.choose.package.name=选择软件包名称
go.fix.configure.go.sdk.text=配置 Go SDK
go.fix.convert.double.quoted.string.to.raw.string=将带双引号的字符串转换为原始字符串
go.fix.convert.int.to.rune=将整数转换为 rune
go.fix.convert.int.to.string.using.conversion.call=使用 {0} 调用将整数转换为字符串
go.fix.convert.plus.build.comments.to.go.build.directive=将 //+build 注释转换为 //go\:build 指令
go.fix.convert.raw.string.to.double.quoted.string=将原始字符串转换为带双引号的字符串
go.fix.convert.string.to.byte.name=将字符串转换为字节
go.fix.convert.to.expected.type.name=转换为
go.fix.convert.to.expected.type.text=转换为 ''{0}''
go.fix.convert.to.format.function.name=更改为格式设置函数
go.fix.convert.to.format.function.text=更改 ''{0}'' 为格式设置函数
go.fix.convert.to.is.equal.name=转换为 '\=\='
go.fix.create.directory.text=在 {1} 处创建目录{0}
go.fix.create.wrapper.type.name=创建类型
go.fix.delete.all.unused.parameters.name=删除所有未使用的形参
go.fix.delete.ampersand.and.type.in.composite.lit.name=删除冗余类型
go.fix.delete.blank.argument.name=删除空白实参
go.fix.delete.conversion.name=删除转换
go.fix.delete.conversion.with.side.effects.name=删除转换(可能改变语义)
go.fix.delete.extra.expressions.name=删除多余的表达式
go.fix.delete.import.name=删除导入
go.fix.delete.name=删除 {0}
go.fix.delete.parameter.names.name=删除形参名称
go.fix.delete.range.name=删除元素
go.fix.delete.redundant.capacity.hint.to.make=删除容量实参
go.fix.delete.redundant.index.name=删除冗余索引
go.fix.delete.redundant.size.hint.to.make=删除大小实参
go.fix.delete.text=删除{0} ''{1}''
go.fix.delete.third.index.name=删除第三索引
go.fix.delete.type.arguments.in.index.or.slice.expr=删除类型实参
go.fix.delete.type.arguments.name=删除类型实参
go.fix.delete.type.parameters.name=删除类型形参
go.fix.delete.unused.parameter.name=删除未使用的形参
go.fix.dfa.exclude.from.error.may.be.not.nil.inspection.name=从 nil 错误检查中排除函数
go.fix.dfa.exclude.from.error.may.be.not.nil.inspection.text=从 nil 错误检查中排除函数 ''{0}''
go.fix.drop.suffix.name=删除特定于单元的后缀
go.fix.drop.suffix.text=删除特定于单元的后缀 ''{0}''
go.fix.empty.signature.name=修复签名
go.fix.enable.go.experiment=启用 ''{0}'' Go 实验
go.fix.enable.gopath.indexing.name=启用 GOPATH 索引
go.fix.error.string.format=修正错误字符串格式
go.fix.exclude.from.unhandled.inspection.name=不再报告此方法/函数
go.fix.export.field.name=导出字段
go.fix.export.name=导出
go.fix.export.text=导出 {0}
go.fix.extract.empty.slice.to.var.declaration.name=替换为零切片声明(更改语义)
go.fix.extract.to.own.declaration.name=提取到自己的声明
go.fix.failed.to.handle.error=无法处理错误
go.fix.failed.to.introduce.variables.from.call=无法从调用引入变量
go.fix.failed.to.resolve.called.function.signature=无法从调用解析签名
go.fix.failed.to.simplify.if.statement=无法简化 'if' 语句
go.fix.field.repeats.tag.with.value=字段 ''{0}'' 重复 ''{3}'' 字段中值为 ''{2}'' 的 ''{1}'' 标签
go.fix.field.with.the.same.tag=包含相同 ''{1}'' 标签的字段 ''{0}''
go.fix.finish.call.name=完成调用表达式
go.fix.handle.error.name=处理错误
go.fix.ignore.explicitly.name=显式忽略
go.fix.ignore.explicitly.using.closure.name=使用闭包显式忽略
go.fix.ignore.unused.call.result.name=忽略未使用的调用结果
go.fix.implement.missing.methods.name=实现缺少的方法
go.fix.import.embed.package=导入 "embed"
go.fix.insert.blank.identifiers.name=将空白标识符插入赋值语句的左侧
go.fix.introduce.function.dot.import.conflict.message=函数 {0} 与同名的点导入 {1} 冲突
go.fix.introduce.function.field=函数名称\:
go.fix.introduce.function.in.directory.label=在目录中\:
go.fix.introduce.function.in.file.label=在文件中\:
go.fix.introduce.function.name=创建函数
go.fix.introduce.function.ok.button.text=创建
go.fix.introduce.function.test.name.conflict.message=函数 {0} 与同名的测试 {1} 冲突
go.fix.introduce.function.text=创建函数 ''{0}''
go.fix.introduce.function.title=在软件包中创建函数
go.fix.introduce.local.variable.for.expression=引入 ''{0}'' 的局部变量
go.fix.introduce.method.name=创建方法
go.fix.introduce.method.text=创建方法 ''{0}''
go.fix.multiple.packages.command.name=将软件包重命名为 {0}
go.fix.multiple.packages.name=重命名软件包
go.fix.multiple.packages.text=将软件包重命名为 {0}
go.fix.navigate.to.name=导航到
go.fix.navigate.to.text=导航到 {0}
go.fix.optimize.imports.name=优化 import
go.fix.place.build.tag.before.package.name=在软件包前面放置构建标记
go.fix.place.directive.before.package=将 {0} 放在 package 前面
go.fix.remove.leading.whitespace.go.directive=移除 Go 指令前的前导空格
go.fix.remove.plus.build.comments=移除 //+build 注释
go.fix.remove.redundant.bool.literal.name=简化为
go.fix.rename.all.receivers.name=重命名所有接收器
go.fix.rename.all.receivers.text=重命名所有接收器为 ''{0}'' 
go.fix.rename.to.blank=重命名为 _
go.fix.rename.to.name=重命名为
go.fix.rename.to.text=重命名为 ''{0}''
go.fix.replace.and.return=替换为 ''{0}'' 和 ''return''
go.fix.replace.assign.with.equals.name=将 '\:\=' 替换为 '\='
go.fix.replace.equality.check.with.errors.is=将相等检查替换为 'errors.Is'
go.fix.replace.equals.with.assign.name=替换为 '\:\='
go.fix.replace.expression.name=预置 '\\&'
go.fix.replace.field.type.with.pointer=将{0,choice,0\#字段|1\#字段|2\#字段} ''{1}'' 类型替换为指针
go.fix.replace.switch.on.errors.with.errors.is=更新 switch 语句以使用 'errors.Is'
go.fix.replace.switch.on.types.with.errors.as=更新类型 switch 以使用 'errors.As'
go.fix.replace.tilda.with.hat.name=将 '~' 替换为 '^'
go.fix.replace.type.assertion.with.errors.as=将类型断言替换为 'errors.As'
go.fix.replace.with.correct.defer.name=替换为正确的 defer 结构
go.fix.replace.with.name=替换为
go.fix.replace.with.nil.with.side.effects.name=替换为 nil (更改语义)
go.fix.replace.with.text=替换为 ''{0}''
go.fix.searching.for.usages.progress.title=正在搜索用法…
go.fix.signature.name=修复签名
go.fix.simplify.bool.expr.name=简化表达式
go.fix.simplify.expression.to.boolean.literal.name=简化条件
go.fix.simplify.something.to.text=将 ''{0}'' 简化为 ''{1}''
go.fix.simplify.to.text=简化为 ''{0}''
go.fix.sort.imports=对 import 排序
go.fix.suppress.all.inspections.for.text=禁止{0}的所有检查
go.fix.suppress.inspection.for.text=对{0}禁止
go.fix.unpack.slice.name=解压缩切片
go.fix.unwrap.parens.name=取消换行括号
go.fix.update.plus.build.comments=更新 //+build 注释
go.fix.uppercase.type.parameter.name=为类型形参使用大写
go.fix.uppercase.type.parameter.text=为类型形参 ''{0}'' 使用大写
go.fix.view.all.duplicates.name=查看重复的名称
go.fix.view.all.duplicates.targets.code.usages.string=已找到重复项
go.fix.view.all.duplicates.targets.tab.text=''{0}'' 的重复项
go.fix.view.all.duplicates.targets.tool.window.title={1} 中的 {0}
go.fix.view.all.duplicates.text=查看 ''{0}'' 的重复名称
go.fix.wrap.error.handling.in.closure=在闭包内部封装错误处理
go.fix.wrap.receiver.with.pointer=将方法接收器更改为指针
go.fmt.add.leading.space.to.comments=向注释添加前导空格
go.fmt.add.parentheses.for.single.import=为单个导入添加括号
go.fmt.create.local.group.label=组
go.fmt.fill.paragraph.width.label=填充段落的列宽\:
go.fmt.for.current.project.packages=当前项目软件包
go.fmt.for.imports.starting.with.prefix=导入开头\:
go.fmt.for.imports.starting.with.prefix.comment=逗号分隔的前缀列表，与 'goimports -local' 相同
go.fmt.formatting.service.error.title=无法在 {0} 上运行 gofmt
go.fmt.group.stdlib.imports=将 Go SDK 中的软件包分组
go.fmt.import.sorting.type=排序类型
go.fmt.imports.prefix.error.empty.message=导入前缀不能为空
go.fmt.imports.prefix.error.title=导入前缀错误
go.fmt.imports.tab.title=导入
go.fmt.move.all.imports.in.single.declaration=将所有 import 移至一个声明中
go.fmt.move.all.stdlib.imports.in.single.group=将所有软件包移至一个组中
go.fmt.remove.redundant.import.aliases=移除冗余导入别名
go.fmt.run.gofmt.on.code.reformat.label=执行“重新设置代码格式”操作时(&R)
go.fmt.run.gofmt.panel.border.title=运行 gofmt
go.fmt.use.back.quotes.for.imports=为 import 使用反引号
go.format.playground.could.not.format.message=无法设置代码格式
go.generate.type.from.json.dialog.json.label=将 JSON 放置在此处\:
go.generate.type.from.json.dialog.ok.label=生成
go.generate.type.from.json.dialog.title=从 JSON 生成 Go 类型
go.generate.type.from.json.error.invalid.json=无法从无效的 JSON 生成 go 类型
go.generate.type.from.json.error.no.top.value=JSON 应有一个顶层值
go.generate.type.from.json.on.paste.dialog.title=从 JSON 生成 Go 类型
go.generate.type.from.json.on.paste.struct.fields.message=插入的文本似乎是 JSON。是否要从它生成结构体字段?
go.generate.type.from.json.on.paste.type.message=插入的文本似乎是 JSON。是否要从它生成 Go 类型?
go.generate.type.from.json.properties.on.paste.struct.fields.message=插入的文本似乎是一系列 JSON 属性。是否要从它生成结构体字段?
go.generate.type.from.json.properties.on.paste.type.message=插入的文本似乎是一系列 JSON 属性。是否要从它生成 Go 类型?
go.get.package.fix.family.name=运行 'go get'
go.go.inspection.problem.replace.can.be.migrated=可以迁移到 Go 工作区
go.go.mod.error.annotator.directive.not.supported=从 Go {1} 版本开始支持 ''{0}'' 指令
go.go.mod.error.annotator.missing.dependency=缺少依赖关系
go.go.mod.error.annotator.multiple.module.statements=文件中存在多个模块语句
go.go.mod.error.annotator.multiple.version.statements=文件中存在多个 go 版本的语句
go.go.mod.error.annotator.no.module.statement=文件中没有模块语句
go.go.mod.error.annotator.unresolved.dependency=未解析的依赖项
go.go.mod.error.module.version.expected=应为模块版本
go.go.mod.error.no.whitespace.expected=此处不允许有空格
go.go.mod.error.prohibited.directive=go.mod 文件中不允许使用指令
go.go.mod.multiple.require.directives=多个 'require' 指令可以按依赖项类型分组合并
go.go.mod.retract.wrong.range.format=版本范围必须采用以下格式\: '[start, end]'
go.go.mod.toolchain.not.supported=自 Go 1.21 起开始支持 'toolchain'
go.go.work.error.prohibited.directive=go.work 文件中不允许使用指令
go.go.work.error.unresolved.path=未解析的路径
go.go.work.multiple.use.directives=可以将多个 'use' 指令合并为一个
go.ignore.template.plugin.action.text=忽略此项目的插件
go.import.optimizer.removed.aliases=移除的 {0} 个{0,choice,1\#别名|2\#别名}
go.import.optimizer.removed.imports=移除的 {0} 个{0,choice,1\#导入|2\#导入}
go.import.optimizer.removed.imports.and.aliases=已移除 {0} 条 {0,choice,1\#import|2\#import} 和 {1} 个{1,choice,1\#别名|2\#别名}
go.import.package.cannot.invoke.fix.with.ambiguous.imports.error=无法在编辑器 {0} 中对不明确的导入调用修正。软件包\: {1}
go.import.package.fix.family.name=导入软件包
go.import.package.fix.text=导入软件包
go.import.package.fix.text.many.variants=导入 {0} (多个选择…)
go.import.package.fix.text.no.variants=导入软件包
go.import.package.fix.text.single.variant=导入 {0}
go.import.package.popup.title=要导入的软件包
go.index.entire.gopath.checkbox=为整个 GOPATH 编制索引
go.index.entire.gopath.tooltip=禁用时，将仅对项目和 vendor 软件包编制索引。<br/>这样可以提升整体性能，但无法使用 GOPATH 中的包。
go.init.with.zero.value=使用零值初始化
go.inlays.display.constant.definition=显示常量定义的值
go.inlays.show.return.parameters.option=显示返回形参
go.inlays.show.unnamed.fields.in.structure.values.option=在结构值中显示未命名字段
go.inspection.ambiguous.reference.message=不明确的引用 {0}
go.inspection.argument.must.be.non.nil.explanation.argument.passing=<code>{0}</code> 被传递给 <code>{1}</code>
go.inspection.argument.must.be.non.nil.with.explanation=<html>将 <code>{0}<code> 传递给 <code>{1}<code> 时，存在潜在的 nil 解引用<br>{2}</html>
go.inspection.argument.must.be.non.nil.without.explanation=将 <code>{0}<code> 传递给 <code>{1}<code> 时，存在潜在的 nil 解引用
go.inspection.assignment.nil.without.explicit.type.message=如果没有显式类型，则无法分配 nil
go.inspection.assignment.to.receiver.display.name=赋值给接收器
go.inspection.bool.condition.display.name=布尔型条件
go.inspection.change.context.todo=考虑使用定义明确的上下文
go.inspection.comment.has.no.leading.space.display.name=注释没有前导空格
go.inspection.comment.of.exported.element.starts.with.incorrect.name.display.name=导出的元素的注释以不正确的名称开头
go.inspection.comment.should.be.meaningful.message=注释应有意义，否则应当移除
go.inspection.comment.should.be.without.article.message=注释格式应为 ''{0} ...'' (有可选的前导条目)
go.inspection.comment.should.have.package.prefix.message=软件包注释应采用 ''Package {0} ...'' 的形式
go.inspection.convert.string.literals.display.name=转换字符串字面量
go.inspection.cyclic.imports.name=循环 import
go.inspection.defer.go.statement.calls.recover.or.panic.directly.display.name=Defer/go 语句直接调用 'recover' 或 'panic'
go.inspection.defer.in.loop.display.name=循环中的 'defer'
go.inspection.defer.or.go.should.not.call.function.message={0} 不应直接调用 {1}
go.inspection.deprecated.element.display.name=弃用的元素
go.inspection.detect.set.finalizer.usages.message=<html><a href\="https\://pkg.go.dev/runtime\#SetFinalizer">runtime.SetFinalizer</a> 可能会导致错误，请改用 <a href\="https\://pkg.go.dev/runtime\#AddCleanup">runtime.AddCleanup</a>。</html>
go.inspection.detect.set.finalizer.usages.name=检测 runtime.SetFinalizer 的用法
go.inspection.dfa.constant.conditions.name=恒定条件
go.inspection.dfa.error.may.be.not.nil.name=错误可能不为 nil
go.inspection.dfa.explain.nil.dereference=解释潜在的 nil 解引用
go.inspection.dfa.group.name=数据流分析
go.inspection.dfa.name=数据流分析
go.inspection.dfa.potential.nil.dereference.interprocedural.name=过程间潜在的 nil 解引用
go.inspection.dfa.potential.nil.dereference.name=潜在的 nil 解引用
go.inspection.direct.comparison.of.errors.display.name=直接比较错误
go.inspection.discarded.context.cancel.function=应该调用取消函数，而不是将其舍弃，以避免上下文泄漏
go.inspection.division.by.zero.display.name=除以零
go.inspection.empty.declaration.display.name=空声明
go.inspection.empty.declaration.message=声明 {0} 为空
go.inspection.empty.slice.declared.via.literal.display.name=使用字面量声明的空切片
go.inspection.error.string.should.not.be.capitalized.or.end.with.punctuation.display.name=错误字符串不应大写或以标点结尾
go.inspection.exceeded.shift.expression.display.name=已超出 shift 表达式
go.inspection.execution.ends.without.context.cancel.function.after.instruction=执行可能在此指令后结束而不调用 ''{0}'' 函数，从而导致上下文泄漏
go.inspection.execution.ends.without.context.cancel.function.after.statement=执行可能在此 ''{0}'' 语句后结束而不调用 ''{1}'' 函数，从而导致上下文泄漏
go.inspection.expected.colon.after.key=键后面应为 '\:'
go.inspection.expected.opening.double.quote.character.after.colon='\:' 后面应为左双引号字符
go.inspection.explicit.dereference.accessing.field.message=访问 {1}(类型为 {2})的字段 {0} 需要显式解引用
go.inspection.explicit.dereference.calling.method.with.receiver.message=包含接收器 {1}(类型为 {2})的调用方法 {0} 需要显式解引用
go.inspection.exported.element.should.have.comment.display.name=导出的元素应有注释
go.inspection.exported.element.should.have.its.own.declaration.display.name=导出的元素应有自己的声明
go.inspection.extended.method.expression.syntax.before.go.1.10.message=意外的接收器类型，自 Go 1.10 起可以使用扩展的方法表达式语法
go.inspection.fail.now.called.from.non.test.goroutine=必须从运行测试或基准测试的 goroutine 调用此方法
go.inspection.fail.now.in.non.test.goroutine=非测试 goroutine 中的 'FailNow'
go.inspection.function.returns.without.calling.context.cancel.function=有一个执行路径没有调用此取消函数，从而导致上下文泄漏
go.inspection.go.debug.after.package='go\:debug' 指令必须放在 package 子句之前
go.inspection.go.debug.min.go.sdk=Go 1.21 之前的版本会忽略 'go\:debug' 指令
go.inspection.go.debug.not.in.main.or.test.package='go\:debug' 指令只能在 'main' 或 '_test' 软件包中定义
go.inspection.imported.package.name.as.name.identifier.display.name=软件包名称作为名称标识符导入
go.inspection.impossible.interface.type.assertion=不可能的接口类型断言
go.inspection.incorrect.call.to.unmarshal.display.name=使用错误的实参调用了 'Unmarshal'
go.inspection.incorrect.strings.replace.count.argument.display.name=不正确的 'strings.Replace' 计数实参
go.inspection.incorrect.usage.of.printf.display.name=不正确的 'fmt.Printf' 和 'fmt.Println' 函数用法
go.inspection.incorrect.usage.of.the.errors.as.function.display.name=不正确的 'errors.As' 函数用法
go.inspection.incorrect.usage.of.the.sync.atomic.display.name=不正确的 'sync/atomic' 软件包用法
go.inspection.infinite.for.loop.display.name=无限的 'for' 循环
go.inspection.int.to.string.conversion=整数转换为字符串类型
go.inspection.invalid.conversions.of.uintptr.to.unsafe.Pointer=无效的 'uintptr' 到 'unsafe.Pointer' 转换
go.inspection.key.is.empty.or.starts.from.incorrect.symbol=键为空或者以不正确的符号开头
go.inspection.key.is.not.separated.by.space.from.previous.pair=键与上一对没有用空格分隔
go.inspection.leading.whitespace.in.directive.comment=指令注释中的前导空格
go.inspection.locks.mistakenly.passed.by.value=锁通过值错误传递
go.inspection.loop.closure.display.name=函数字面量捕获的循环变量
go.inspection.loop.closure.message=由 <code>{0}</code> 语句中的 <code>func</code> 字面量捕获的循环变量可能有意外值
go.inspection.lost.cancel='context.CancelFunc' 未被调用
go.inspection.malformed.build.tag.display.name=构建标记的格式错误
go.inspection.malformed.struct.tag.display.name=格式错误的结构体标记
go.inspection.missing.closing.double.quote.character.in.value=值中缺少右双引号字符
go.inspection.missing.trailing.comma.before.newline.in.composite.literal.display.name=复合字面量中的换行符前缺少尾随逗号
go.inspection.mixed.receiver.types=结构体 {0} 在值接收器和指针接收器上都有方法。Go 文档不推荐使用此类用法。
go.inspection.mixed.receiver.types.display.name=混合值和指针接收器
go.inspection.name.starts.with.package.name.display.name=名称以软件包名称开头
go.inspection.nilness.analyzer.display.name=为零性分析器
go.inspection.non-standard.signature.for.well.known.function.names.display.name=已知函数名称采用非标准签名
go.inspection.options.panel.exclude=排除\:
go.inspection.options.panel.function.name=函数名称
go.inspection.options.panel.import.path=导入路径
go.inspection.options.panel.method.name=方法名称
go.inspection.options.panel.receiver=接收器
go.inspection.options.panel.reported.functions=报告的函数/方法\: 
go.inspection.options.panel.string.methods=字符串方法\:
go.inspection.possible.misuse.of.unsafe.pointer=可能滥用 {0}
go.inspection.problem.accessing.field.may.lead.to.nil.pointer.dereference=访问字段 {0} 可能导致 nil 指针解引用
go.inspection.problem.argument.causes.recursive.call.to.string.method=实参 {0} 导致对 {1} 方法的递归调用
go.inspection.problem.argument.is.not.a.function.call=实参 {0} 不是函数调用
go.inspection.problem.assignment.copies.lock.value=赋值将锁定值复制到 {0}\: {1}
go.inspection.problem.assignment.to.entry.may.panic.because.of.nil.map=由于 {0} 映射，赋值给某个条目可能会出现 panic
go.inspection.problem.assignment.to.method.receiver.doesnt.propagate=对方法接收器的赋值不传播到其他调用
go.inspection.problem.assignment.to.method.receiver.propagates.only.to.callees=对方法接收器的赋值仅传播到被调用方，不传播到调用方
go.inspection.problem.assignment.used.as.value={0} 作为值使用
go.inspection.problem.at.is.not.allowed.in.import.paths=导入路径中不允许 @
go.inspection.problem.bad.count.argument.of.strings.replace={0} 的计数实参不应为 {1}
go.inspection.problem.bad.error.string=错误字符串不应大写或以标点结尾
go.inspection.problem.build.constraints.exclude.all.go.files=构建约束排除 {0} 中所有的 Go 文件
go.inspection.problem.call.copies.lock.value=调用 {0} 将复制锁定值\: {1}
go.inspection.problem.cannot.assign.in.multiple.assignment=无法在多个赋值中将 {0} 赋给 {1}
go.inspection.problem.cannot.assign.value.to.blank.field=无法将值赋给空字段
go.inspection.problem.cannot.assign.value.to.unexported.field=无法将值赋给未导出的字段 {0}
go.inspection.problem.cannot.call.non.function=无法调用类型为 {1} 的非函数 {0}
go.inspection.problem.cannot.convert.constant=无效运算\: {0} (无法将常量 {1} 转换为类型 {2})
go.inspection.problem.cannot.convert.expression=无法将类型 {0} 的表达式转换为类型 {1}
go.inspection.problem.cannot.convert.known.value.to.type=无法将{0}转换为{1}
go.inspection.problem.cannot.convert.nil=无法将 ''nil'' 转换为类型 {0}
go.inspection.problem.cannot.convert.nil.to.type=无法将 {0} 转换为类型 {1}
go.inspection.problem.cannot.convert.value.to.type=无法将值转换为 {0}
go.inspection.problem.cannot.import=无法导入 {0}
go.inspection.problem.cannot.import.absolute.path=无法导入绝对路径
go.inspection.problem.cannot.import.builtin.package=无法导入 'builtin' 软件包
go.inspection.problem.cannot.range=范围不能超过 {0}
go.inspection.problem.cannot.rename.import.c=无法重命名 import 'C'
go.inspection.problem.cannot.slice=无法切片 {0} (类型 {1})
go.inspection.problem.cannot.take.address=无法提取 {0} 的地址
go.inspection.problem.cannot.take.address.of.non.addressable.operand=无法获取不可寻址操作数的地址
go.inspection.problem.cannot.use.underscore.as.value=无法将 {0} 用作值
go.inspection.problem.comment.should.start.with.whitespace=注释应以空白开头
go.inspection.problem.comparison.with.errors.using.equality.fails.on.wrapped.errors=使用相等运算符与错误进行比较在包装的错误上失败
go.inspection.problem.condition.is.always.true.or.false=条件 {0} 始终为 {1}
go.inspection.problem.condition.is.always.true.or.false.because.of.nil=条件始终为 {0}，因为 {1} 始终是 {2}
go.inspection.problem.condition.is.always.true.or.false.because.of.not.nil=条件始终为 {0}，因为 {1} 始终不是 {2}
go.inspection.problem.condition.is.always.true.or.false.without.condition=条件始终为 {0}
go.inspection.problem.contains=包含
go.inspection.problem.conversion.from.int.to.string=从 {0} 到 {1} 的转换将整数值解释为代码点
go.inspection.problem.convert.string.literals=转换字符串字面量
go.inspection.problem.corresponding.error.may.be.not.nil={0} 可能有 {1} 或其他非预期值，因为它相应的错误变量可能不是 {2}
go.inspection.problem.corresponding.error.may.be.not.nil.with.explanation={0} 可能有 {1} 或其他非预期值，因为它相应的错误 {2} {3} 可能不是 {4}
go.inspection.problem.cyclic.imports.not.allowed=<html><body>不允许循环导入\:<br><br>{0}</body></html>
go.inspection.problem.cyclic.imports.pkg.in.file.imports={0} (在文件 {1} 中) ->
go.inspection.problem.declaration.shadows.declaration={0} 的声明隐藏声明
go.inspection.problem.declaration.shadows.declaration.at={0} 的声明隐藏 {1} 处的声明
go.inspection.problem.defer.is.called.in.a.for.loop=可能发生资源泄漏，在 {1} 循环中调用 {0}
go.inspection.problem.deprecated.is.still.used=被弃用的 {0} 仍在使用
go.inspection.problem.direct.assignment.to.atomic.value=直接赋值给原子值
go.inspection.problem.division.by.zero=除以零
go.inspection.problem.duplicate.argument=实参 {0} 重复
go.inspection.problem.duplicate.case=case {0} 重复
go.inspection.problem.duplicate.field=重复字段 {0} 
go.inspection.problem.duplicate.index=重复的索引\: {0}
go.inspection.problem.duplicate.key.in.map.literal=映射字面量中的键 {0} 重复
go.inspection.problem.duplicate.method=方法 {0} 重复
go.inspection.problem.duplicate.type.param=重复的类型形参 {0}
go.inspection.problem.eliminate.snake.case=消除蛇形拼写法
go.inspection.problem.empty.interface.usage='interface{}' 作为类型的用法
go.inspection.problem.empty.slice.declaration.via.literal=使用字面量的空切片声明
go.inspection.problem.example.for.unknown.field.or.method=示例引用未知字段或方法\:{0}。{1}
go.inspection.problem.example.for.unknown.identifier=示例引用未知标识符\: {0}
go.inspection.problem.exported.const.should.have.its.own.declaration=导出的常量 {0} 应有自己的声明
go.inspection.problem.exported.element.should.have.comment=导出的 {0} {1} 应有注释，否则就是未导出
go.inspection.problem.exported.function.with.unexported.return.type=导出的 {0} 具有未导出的返回值类型
go.inspection.problem.exported.var.should.have.its.own.declaration=导出的变量 {0} 应有自己的声明
go.inspection.problem.expression.can.be.simplified=可以简化表达式
go.inspection.problem.expression.can.be.simplified.to.other={0} 可以简化为 {1}
go.inspection.problem.expression.is.always.true.or.false=表达式 {0} 始终为 {1}
go.inspection.problem.expression.is.too.small.for.shift={0} ({1} 位)对于 {2} 的移位太小
go.inspection.problem.expression.with.type={0} (类型 {1})
go.inspection.problem.fields.are.assigned.without.explicit.names=字段分配时没有显式名称
go.inspection.problem.fmt.parameter.with.non.integer.expression=使用非整型表达式 {1}{2} 指定了{0, choice, 0\#宽度|1\#精度|2\#谓词}
go.inspection.problem.found.several.packages=在 {1} 中找到多个软件包 [{0}]
go.inspection.problem.function.call.may.lead.to.nil.pointer.dereference=函数调用 {0} 可能导致 nil 指针解引用
go.inspection.problem.function.does.not.take.writer=\n函数不使用 {0}，但第一个实参是 {1}
go.inspection.problem.function.passes.lock.by.value={0} 通过此值传递锁定\: {1}
go.inspection.problem.fuzzing.is.not.supported=从 Go 1.18 开始支持模糊处理
go.inspection.problem.go.plus.build.empty.tag='+build' 注释包含一个等效于 'ignore' 标记的空标记
go.inspection.problem.imports.are.not.sorted=import 未排序
go.inspection.problem.impossible.interface.assertion=从 {0} 到 {1} 的接口声明无效。模糊\: {2}
go.inspection.problem.impossible.type.assertion=不可能的类型断言\: {0} 未实现 {1}
go.inspection.problem.impossible.type.switch.case=不可能的类型 swich case\: {0} 未实现 {1}
go.inspection.problem.incompatible.empty.type.set=类型未实现约束 {0}，因为<b color\={1}>约束类型集为空</b>
go.inspection.problem.incompatible.method.has.pointer.receiver=类型未实现 {0}，因为 <b color\={1}>{2} 方法有指针接收器</b>
go.inspection.problem.incompatible.need.method.have.method=类型未实现 {0}<br/><b color\={1}> 需要方法\: {2}<br/>具有方法\: {3}</b>
go.inspection.problem.incompatible.not.comparable=类型未实现约束 {0}，因为<b color\={1}>类型不可比较</b>
go.inspection.problem.incompatible.not.in.type.set=类型未实现约束 {0}，因为<b color\={1}>类型未包括在类型集({2})中</b>
go.inspection.problem.incompatible.types=无法将 {0} 用作类型 {1}
go.inspection.problem.incompatible.types.ambiguous.methods=类型未实现 {0}，因为 <b color\={1}>{2} 不明确</b>
go.inspection.problem.incompatible.types.in.switch=switch {1} 中的 case {0} 无效
go.inspection.problem.incompatible.types.in.switch.on.expression={1} {2} 的 switch 中的 case {0} 无效
go.inspection.problem.incompatible.types.some.methods.are.missing=类型未实现 {0}，因为<b color\={1}>缺少某些方法\: <br/>{2}</b>
go.inspection.problem.incompatible.unexported.method=类型无法实现 {0}，因为<b color\={1}>类型有未导出的方法，并且是在不同的软件包中定义</b>
go.inspection.problem.index.must.be.a.non.negative.integer.constant=索引 {0} 必须是非负整数常量
go.inspection.problem.index.out.of.bounds=索引超出界限\: {0}
go.inspection.problem.index.zero.is.illegal=索引值 [0] 为非法的 {0}
go.inspection.problem.indexing.may.panic.because.of.nil.slice=由于切片 {0}，索引可能会出现 panic
go.inspection.problem.infinite.for.loop=无限的 {0} 循环
go.inspection.problem.invalid.argument.must.be.complex.type=必须为复杂类型
go.inspection.problem.invalid.argument.must.be.send.channel.type=必须为双向或仅发送通道
go.inspection.problem.invalid.composite.literal.type=无效的复合字面量类型\: {0}
go.inspection.problem.invalid.conversion=无效转换
go.inspection.problem.invalid.conversion.type.comparable=不能在转换中使用 comparable 接口
go.inspection.problem.invalid.conversion.type.with.constraints=不能在转换中使用带有类型约束的接口
go.inspection.problem.invalid.field.name=字段名无效
go.inspection.problem.invalid.inc.dec.operation=无效运算\: {0}(非数值类型 {1})
go.inspection.problem.invalid.indirect={0} (类型 {1})的间接引用无效
go.inspection.problem.invalid.iterable.index=无效的 {0} 索引 {1} ({2})
go.inspection.problem.invalid.low.high.indices=无效索引值，必须低值 <\= 高值
go.inspection.problem.invalid.low.high.max.indices=无效索引值，必须为低值 <\= 高值 <\= 最大值
go.inspection.problem.invalid.operation.mismatched.types=无效运算\: {0}(类型 {1} 和 {2} 不匹配)
go.inspection.problem.invalid.receiver.interface.type=接口类型
go.inspection.problem.invalid.receiver.nonlocal.type=非本地类型
go.inspection.problem.invalid.receiver.pointer.type=指针类型
go.inspection.problem.invalid.receiver.type=无效接收器类型{0} ({1} 为 {2})
go.inspection.problem.invalid.receiver.unnamed.type=未命名类型
go.inspection.problem.invalid.recursive.type=无效递归 {0} {1}{2}
go.inspection.problem.invalid.second.argument.to.errors.as={0} 的第二个实参必须是一个指针，该指针指向接口或指向实现错误接口的类型
go.inspection.problem.invalid.slice.index=无效的切片索引 {0} ({1})
go.inspection.problem.invalid.unary.operation=无效运算\: {0}
go.inspection.problem.invalid.use.of.triple.dot=无效使用 '...'，对应形参是非可变形参
go.inspection.problem.irregular.iota.usage='iota' 的非常规用法
go.inspection.problem.label.already.defined=已定义标签 {0}
go.inspection.problem.last.argument.ends.with.redundant.newline={0} 的最后一个实参以冗余的换行符结尾
go.inspection.problem.leading.whitespace.in.directive.comment=Go 指令必须紧跟在 // 之后，中间不能有任何空格(例如，//go\:embed)
go.inspection.problem.literal.copies.lock.value=字面量从 {0} 复制锁定值\: {1}
go.inspection.problem.malformed.benchmark.name=基准名称格式错误\: 'Benchmark' 后面的首个字母不得为小写
go.inspection.problem.malformed.example.suffix=示例名称格式错误\: 后缀 {0} 必须以小写字母开头
go.inspection.problem.malformed.test.name=测试名称格式错误\: 'Test' 后面的首个字母不得为小写
go.inspection.problem.method.call.may.lead.to.nil.pointer.dereference=方法调用 {0} 可能导致 nil 指针解引用
go.inspection.problem.method.has.non.standard.signature=方法 {0} 应包含签名 {1}
go.inspection.problem.method.has.non.standard.signature.unwrap=方法 {0} 应具有签名 <code>Unwrap() error</code> 或 <code>Unwrap() []error</code>
go.inspection.problem.method.redeclared=方法重新声明 {0}
go.inspection.problem.might.be.nil.explanation.assignment=<code>{0}</code> 被设置为 <code>{1}</code>
go.inspection.problem.might.be.nil.explanation.call=<code>{0}</code> 被调用
go.inspection.problem.might.be.nil.explanation.default.initialization.nil=<code>{0}</code> 被默认初始化为 <code>nil</code>
go.inspection.problem.might.be.nil.explanation.dereference=<code>{0}</code> 被解引用
go.inspection.problem.might.be.nil.explanation.explicit.nil=<code>{0}</code> 被设置为 <code>nil<code>
go.inspection.problem.might.be.nil.explanation.line=<a href\="\#navigation/{0}\:{1}">第 {2} 行</a>\: {3}
go.inspection.problem.might.be.nil.explanation.nil.comparison=<code>{0}</code> 被假定等于 <code>nil</code>
go.inspection.problem.might.be.nil.with.explanation=<html>潜在的 nil 解引用<br>{0}</html>
go.inspection.problem.might.be.nil.without.explanation=潜在的 nil 解引用
go.inspection.problem.mismatched.types=(类型 {0} 和 {1} 不匹配)
go.inspection.problem.mismatched.types.byte.and.string=不匹配的类型\: 字节和字符串
go.inspection.problem.missing.argument.to.conversion=缺少要转换为 {0} 的实参\: {1}
go.inspection.problem.missing.expression=缺少表达式
go.inspection.problem.missing.key.in.map.literal=映射字面量中缺少键
go.inspection.problem.missing.return=函数末尾缺少 'return' 语句
go.inspection.problem.missing.type.in.composite.literal=复合字面量中缺少类型
go.inspection.problem.mixture.of.field=混合字段\: 值和初始值设定项
go.inspection.problem.multiple.packages.in.directory=目录中有多个软件包\: {0}
go.inspection.problem.must.be.imported.as=必须作为 {0} 导入
go.inspection.problem.must.be.non.negative=必须为非整型
go.inspection.problem.must.be.of.integer.type=必须为整型
go.inspection.problem.must.be.representable.by.int=值必须可由 'int' 类型表示
go.inspection.problem.name.collides.with.builtin={0} {1} 与 ''builtin'' {2} 冲突
go.inspection.problem.name.collides.with.imported.package={0} {1} 与导入的软件包名称冲突
go.inspection.problem.name.collides.with.name.declared.in.this.package={0} 与此软件包中声明的名称冲突
go.inspection.problem.name.redeclared.as.imported.package={0} 被重新声明为导入的软件包名称
go.inspection.problem.name.redeclared.in.this.block=此块中重新声明了 {0}
go.inspection.problem.name.redeclared.in.this.function=此函数中重新声明了 {0}
go.inspection.problem.name.redeclared.in.this.package=此包中重新声明的 {0}
go.inspection.problem.name.starts.with.package.name=名称以软件包名称开头
go.inspection.problem.need.trailing.comma.in.argument.list=实参列表中的换行符前面需要有尾随逗号
go.inspection.problem.need.trailing.comma.in.composite.literal=复合字面量中的换行符前需要尾随逗号
go.inspection.problem.need.trailing.comma.in.index.expression=索引表达式中的换行符前面需要有尾随逗号
go.inspection.problem.need.trailing.comma.in.parameter.list=形参列表中的换行符前面需要有尾随逗号
go.inspection.problem.need.trailing.comma.in.type.arguments.list=类型实参列表中的换行符前面需要有尾随逗号
go.inspection.problem.need.trailing.comma.in.type.parameters.list=类型形参列表中的换行符前面需要有尾随逗号
go.inspection.problem.negative.index=负索引\: {0}
go.inspection.problem.negative.shift.count=无效运算\: {0} (负移位计数)
go.inspection.problem.nil.is.not.allowed=不允许 {0}。必须为 {1}
go.inspection.problem.nil.loop.is.always.skipped=总是跳过循环，因为 {0} 总是 {1}
go.inspection.problem.no.argument.for.placeholder.part=没有{0, choice, 0\#宽度|1\#精度|2\#动词}的实参\: 实参索引 \= {1}，实参计数 \= {2}{3}
go.inspection.problem.no.core.type.in.range.expression=范围表达式必须具有<a href\="https\://go.dev/ref/spec\#Core_types">核心类型</a>
go.inspection.problem.no.non.test.go.files=软件包仅包含测试 Go 文件\: {0}
go.inspection.problem.no.placeholders.in.format.string=格式字符串中没有占位符
go.inspection.problem.non.bool.used.as.condition=非布尔值 {0} 用作条件
go.inspection.problem.non.canonical.import.path=非规范的导入路径\: {0} 应为 {1}
go.inspection.problem.non.enabled.rangefunc.exclude.iter.package.files=由于未启用 'rangefunc' 实验，'iter' 软件包中的所有文件都被排除在构建过程之外。
go.inspection.problem.non.strict.comparability.not.supported=从 Go 1.20 开始，基本接口满足 'comparable' 类型检查规则
go.inspection.problem.not.enough.arguments.in.call={0} 调用中的实参不足
go.inspection.problem.not.enough.arguments.to.return=要返回的实参不足
go.inspection.problem.operator.not.defined=无效运算\: {0} (在 {2} 中未定义运算符 {1})
go.inspection.problem.out.of.bounds.for.array={0} 元素的数组超出界限
go.inspection.problem.out.of.bounds.for.string={0} 字节的字符串超出界限
go.inspection.problem.path.imports.package.that.expects.canonical.import={0} 导入需要导入“{1}”的软件包
go.inspection.problem.path.imports.package.with.invalid.import.comment={0} 导入包含无效导入注释的软件包
go.inspection.problem.path.is.a.program.not.an.importable.package={0} 是程序，不是可导入的软件包
go.inspection.problem.placeholder.argument.causes.recursive.call.to.string=占位符实参导致对 {0} 方法 {1} 的递归调用
go.inspection.problem.placeholder.argument.has.wrong.type=占位符实参 {0} 具有错误的类型 {1}{2}
go.inspection.problem.placeholder.argument.is.not.a.function.call=占位符实参不是函数调用 {0}
go.inspection.problem.placeholder.syntax.error=占位符语法错误 {0}
go.inspection.problem.possible.formatting.directive={0} 中可能的格式指令
go.inspection.problem.possible.malformed.build.comment='+build' 注释的格式可能不正确
go.inspection.problem.possibly.redundant.type.conversion=类型转换可能冗余
go.inspection.problem.possibly.unused.dependency=可能未使用的依赖项
go.inspection.problem.potential.nil.pointer.dereference=可能发生 nil 指针解引用
go.inspection.problem.range.var.copies.lock=范围变量 {0} 复制锁定\: {1}
go.inspection.problem.receive.from.non.chan.type=无效运算\: {0} (从非 chan 类型 {1} 接收)
go.inspection.problem.receive.from.send.only.type=无效运算\: {0} (从仅发送类型 {1} 接收)
go.inspection.problem.receive.may.block.because.of.nil.channel=由于 {0} 通道，接收运算可能会阻止 goroutine
go.inspection.problem.receive.no.core.type=无效运算\: {0} (类型为 {2} 的表达式 {1} 没有核心类型)
go.inspection.problem.receiver.has.generic.name=接收器具有泛型名称
go.inspection.problem.receiver.may.be.nil.in.call=接收器 {0} 在调用中可能是 {1}
go.inspection.problem.receiver.names.are.different=接收器名称不同
go.inspection.problem.redundant.alias=冗余别名
go.inspection.problem.redundant.blank.expression=冗余 {0} 表达式
go.inspection.problem.redundant.comma=冗余逗号
go.inspection.problem.redundant.else.for.if.condition=冗余的 'else' 分支
go.inspection.problem.redundant.for.condition=条件冗余
go.inspection.problem.redundant.index=冗余索引 {0}
go.inspection.problem.redundant.parentheses=冗余括号
go.inspection.problem.redundant.semicolon=冗余分号
go.inspection.problem.redundant.type=冗余类型
go.inspection.problem.redundant.type.conversion=冗余类型转换
go.inspection.problem.reference.is.deprecated=已弃用 {0}
go.inspection.problem.reference.jumps.over.declaration={0} 跳过 {1} 的声明
go.inspection.problem.return.copies.lock.value=返回复制锁定值\: {0}
go.inspection.problem.return.value.has.a.function.type=返回值 {0} 具有函数类型
go.inspection.problem.return.value.of.placeholder.argument.has.a.function.type=占位符实参的返回值具有函数类型 {0}
go.inspection.problem.self.import.is.not.allowed=不允许自我导入
go.inspection.problem.send.may.block.because.of.nil.channel=由于 {0} 通道，发送运算可能会阻止 goroutine
go.inspection.problem.send.to.non.chan.type=无效运算\: {0} (发送到非 chan 类型 {1})
go.inspection.problem.send.to.receive.only.type=无效运算\: {0} (发送到仅接收类型 {1})
go.inspection.problem.shift.count.must.be.integer=无效运算\: {0} (移位计数类型 {1}，必须为整数)
go.inspection.problem.shift.count.must.be.unsigned.integer=无效运算\: {0} (移位计数类型 {1}，必须为无符号整数)
go.inspection.problem.switch.on.error.fails.on.wrapped.errors=与 switch 语句中的错误进行比较在包装的错误上失败
go.inspection.problem.this.verb.can.be.used.only.in.fmt.errorf=此动词只能在 {0} 个调用 {1} 中使用
go.inspection.problem.this.verb.can.be.used.only.once.in.a.format.string=此动词只能在格式字符串 {0} 中使用一次
go.inspection.problem.too.few.values=值太少
go.inspection.problem.too.many.arguments.for.format.string=格式字符串的实参过多\: 应为 {0}，实际为 {1}
go.inspection.problem.too.many.arguments.in.call={0} 调用中的实参过多
go.inspection.problem.too.many.arguments.to.conversion=要转换为 {0} 的实参过多\: {1}
go.inspection.problem.too.many.arguments.to.return=要返回的实参太多
go.inspection.problem.too.many.values=值太多
go.inspection.problem.type.assertion.on.errors.fails.on.wrapped.errors=错误的类型断言在包装的错误上失败
go.inspection.problem.type.does.not.support.indexing=无效运算\: {0} (类型 {1} 不支持索引)
go.inspection.problem.type.has.both.field.and.method.with.name=\n类型 {0} 的字段和方法均命名为 {1}
go.inspection.problem.type.has.same.named.field.and.method=\n类型 {0} 的字段和方法均命名为 {1}
go.inspection.problem.type.is.sync.locker=类型 %s 为 <code>sync.Locker</code>
go.inspection.problem.type.or.type={0} 或 {1}
go.inspection.problem.type.parameters.are.not.supported=不支持类型形参
go.inspection.problem.type.switch.on.errors.fails.on.wrapped.errors=错误的类型 switch 在包装的错误上失败
go.inspection.problem.type.which.is.sync.locker=类型 %s，它是 <code>sync.Locker</code>
go.inspection.problem.unhandled.error=未处理错误
go.inspection.problem.unit.specific.suffix=特定于单元的后缀 {0}
go.inspection.problem.unknown.verb=未知动词 {0}{1}
go.inspection.problem.unmarshal.argument.must.be.a.pointer=此实参必须为指针类型
go.inspection.problem.unnecessarily.exported.element=不必要地导出了 {0} {1}
go.inspection.problem.unreachable.code=不可到达的代码
go.inspection.problem.unresolved.ignore.path='ignore' 指令中未解析的路径
go.inspection.problem.unused.dependency=未使用的依赖项
go.inspection.problem.unused.import=未使用的 import
go.inspection.problem.unused.result=未使用的结果\: {0}
go.inspection.problem.usage.of.cgo.in.tests=不支持在测试中使用 cgo
go.inspection.problem.use.camelcase.instead.of.snake.case=使用驼峰拼写法，不使用蛇形拼写法
go.inspection.problem.use.of.internal.package.is.not.allowed=不允许使用内部软件包
go.inspection.problem.use.of.vendored.package.is.not.allowed=不允许使用供应商提供的软件包
go.inspection.problem.value.is.assigned.to.itself={0} 的值被赋予本身
go.inspection.problem.variable.declaration.copies.lock.value=变量声明将锁定值复制到 {0}\: {1}
go.inspection.problem.variable.repeated.on.left.side={0} 在 \:\= 的左侧重复
go.inspection.problem.verb.will.ignore.flag=动词将忽略 {0} 标志 {1}
go.inspection.problem.verb.will.ignore.flags=动词将忽略 {0} 标志 {1}
go.inspection.problem.wrong.example.signature=示例签名错误
go.inspection.problem.wrong.location.of.build.comment='build' 注释必须出现在软件包子句前面，后面跟随一个空白行
go.inspection.problem.wrong.test.signature=测试签名错误
go.inspection.problematic.execution.path.end=有问题的执行路径的结束
go.inspection.receiver.has.generic.name.display.name=接收器具有泛型名称
go.inspection.redundant.blank.argument.in.range.display.name=范围中存在冗余空白实参
go.inspection.redundant.comma.display.name=冗余逗号
go.inspection.redundant.else.in.if.inspection.display.name='if' 中冗余的 'else'
go.inspection.redundant.import.alias.display.name=冗余导入别名
go.inspection.redundant.parentheses.display.name=冗余括号
go.inspection.redundant.second.index.in.slices.display.name=切片中存在冗余的第二个索引
go.inspection.redundant.semicolon.display.name=冗余分号
go.inspection.redundant.true.in.for.loop.display.name=for 循环条件中存在冗余的 'true'
go.inspection.redundant.type.conversion.display.name=冗余类型转换
go.inspection.redundant.types.in.composite.literals.display.name=复合字面量中存在冗余类型
go.inspection.reserved.word.used.as.name.display.name=保留词用作名称
go.inspection.self.assignment.display.name=自赋值
go.inspection.shadowing.variable.display.name=阴影变量
go.inspection.struct.field.has.tag.but.is.not.exported=结构体字段 ''{0}'' 具有 ''{1}'' 标记，但未被导出
go.inspection.struct.initialization.settings.report.for.literals.without.type.checkbox=报告无类型的结构体字面量
go.inspection.struct.initialization.settings.report.for.local.type.checkbox=报告当前软件包中定义的类型
go.inspection.struct.initialization.without.field.names.display.name=结构体初始化没有字段名称
go.inspection.struct.tag.value.consists.only.of.spaces=结构体标签值仅包含空格
go.inspection.suspicious.extra.space.in.struct.tag.value=结构体标记值中的可疑额外空格
go.inspection.suspicious.space.in.struct.tag.value=结构体标记值中的可疑空格
go.inspection.suspicious.space.in.the.beginning.of.the.struct.tag.value=结构体标记值开头的可疑空格
go.inspection.suspicious.space.in.the.end.of.the.struct.tag.value=结构体标记值末尾的可疑空格
go.inspection.switch.missing.cases.family='switch' 中缺少 'case' 语句
go.inspection.switch.missing.iota.const.cases='switch' 中缺少 'iota' 常量的 'case' 语句
go.inspection.switch.missing.iota.const.cases.create.cases.fix=创建缺失的 iota {0,choice,0\#子句|1\#子句|2\#子句}
go.inspection.switch.missing.iota.const.cases.insert.default.fix=创建 'default' 子句
go.inspection.test.name.display.name=格式错误的测试函数名称
go.inspection.type.can.be.omitted.display.name=类型可以省略
go.inspection.type.can.be.omitted.message=类型可以省略
go.inspection.type.parameter.declared.in.lower.case.display.name=类型形参以小写声明
go.inspection.type.parameter.declared.in.lower.case.message=类型形参 ''{0}'' 以小写声明
go.inspection.unexported.return.type.of.exported.function.display.name=导出函数的未导出返回值类型
go.inspection.unhandled.error.display.name=未处理错误
go.inspection.unit.specific.suffix.for.time.duration.display.name=为 'time.Duration' 使用单位特定的后缀
go.inspection.unknown.field.message=结构体字面量中的字段 {0} 未知
go.inspection.unnecessarily.exported.identifier.display.name=不必要地导出了标识符
go.inspection.unreachable.code.display.name=不可到达的代码
go.inspection.unresolved.disabled.gopath.indexing.display.name=已禁用 GOPATH 索引
go.inspection.unresolved.disabled.gopath.indexing.message=禁用 GOPATH 索引可能会阻止正确进行引用解析
go.inspection.unresolved.label.message=未解析的标签 {0}
go.inspection.unresolved.reference.message=未解析的引用 {0}
go.inspection.unresolved.type.message=未解析的类型 {0}
go.inspection.unsorted.imports.display.name=未排序的 import
go.inspection.unused.constant.display.name=未使用的常量
go.inspection.unused.constant.message=未使用的常量 {0}
go.inspection.unused.exported.function.display.name=未使用的导出函数
go.inspection.unused.exported.type.display.name=未使用的导出类型
go.inspection.unused.function.display.name=未使用的函数
go.inspection.unused.function.message=未使用的函数 {0}
go.inspection.unused.function.or.method.call.result.display.name=未使用的函数或方法调用结果
go.inspection.unused.global.variable.display.name=未使用的全局变量
go.inspection.unused.label.message=未使用的标签 {0}
go.inspection.unused.parameter.display.name=未使用的形参
go.inspection.unused.parameter.message=未使用的形参 {0}
go.inspection.unused.type.display.name=未使用的类型
go.inspection.unused.type.message=未使用的类型 {0}
go.inspection.unused.type.parameter.display.name=未使用的类型形参
go.inspection.unused.type.parameter.message=未使用的类型形参 {0}
go.inspection.unused.variable.message=未使用的变量 {0}
go.inspection.usage.of.context.todo=context.TODO() 的用法
go.inspection.usage.of.snake.case.display.name=使用了 Snake_Case(_C)
go.install.template.plugin.action.text=安装插件
go.install.template.plugin.notification.text=安装 Go 模板以增强 html/templates 软件包中的突出显示、补全和导航功能
go.intention.add.declaration.parens.name=向声明添加圆括号
go.intention.add.dot.import.alias.name=添加点导入别名
go.intention.add.fmt.string.argument.name=添加格式字符串实参
go.intention.add.import.alias.name=添加导入别名
go.intention.add.method.to.implementations.template.add.to.interface.inlay.suffix=以将方法添加到接口
go.intention.add.method.to.implementations.template.next.field.inlay.suffix=以移至下一个方法模板字段
go.intention.add.method.to.implementations.title=将方法 {0} 添加到接口实现
go.intention.add.method.to.interface=将方法添加到接口及其所有实现
go.intention.add.method.to.interface.error.hint.message=方法 {0} 已存在
go.intention.add.method.to.interface.error.hint.title=无法将方法添加到接口
go.intention.add.tag.key=向标记添加键
go.intention.change.field.name.style.command=更改标记中的字段名称样式
go.intention.change.field.name.style.in.tags=更改标记中的字段名称样式
go.intention.change.field.name.style.select.style=选择字段名称样式\:
go.intention.chop.arguments=将实参放在单独的行中
go.intention.chop.composite.literal.elements=将元素放在单独的行中
go.intention.chop.parameters=将形参放在单独的行中
go.intention.convert.to.short.var.declaration.name=转换为短变量声明
go.intention.convert.to.var.declaration.name=转换为变量声明
go.intention.create.field.getter.and.setter.command.name=创建字段访问器
go.intention.create.field.getter.and.setter.name=生成 getter 和 setter
go.intention.create.field.getter.name=创建 Getter
go.intention.create.field.setter.name=创建 Setter
go.intention.download.all.missing.modules.fix.text=将所有模块下载到模块缓存
go.intention.download.single.missing.module.fix.family.name=将模块下载到模块缓存
go.intention.download.single.missing.module.fix.from.replacement.text=将 {0} 从 {1} 下载到模块缓存
go.intention.download.single.missing.module.fix.text=将{0}下载到模块缓存
go.intention.exclude.fmt.function.name=排除字符串格式设置函数
go.intention.expand.signature.types.name=展开签名类型
go.intention.export.name=导出
go.intention.fill.all.fields.command.name=填充结构体
go.intention.fill.all.fields.enforce.multiline.checkbox=执行多行
go.intention.fill.all.fields.name=填充所有字段
go.intention.fill.all.fields.recursively.checkbox=递归
go.intention.fill.all.fields.recursively.name=递归填充所有字段
go.intention.fill.fields.name=填充字段…
go.intention.flip.binary.operator.changes.operator.text=将 ''{0}'' 翻转为 ''{1}''
go.intention.flip.binary.operator.changes.semantics.text=翻转 ''{0}'' (更改语义)
go.intention.flip.binary.operator.name=翻转二元运算符
go.intention.flip.binary.operator.text=翻转 ''{0}''
go.intention.fmt.string.argument.bad.position.error.message=位置错误
go.intention.fmt.string.argument.explicit.indices.error.message=字符串具有显式索引
go.intention.fmt.string.argument.percent.with.args.error.message=字符串具有带实参的 %%
go.intention.fmt.string.argument.syntax.error.message=字符串有语法错误
go.intention.fmt.string.argument.too.few.arguments.error.message=字符串的实参太少
go.intention.fmt.string.argument.variadic.arg.error.message=字符串具有 ... 实参
go.intention.fmt.string.title.error.message=无法添加 Fmt 字符串实参
go.intention.generate.constructor.name=创建构造函数
go.intention.generate.method.name=生成方法
go.intention.generate.struct.fields.from.json=从 JSON 生成结构体字段
go.intention.generate.struct.fields.from.json.error=JSON 顶层值应当是对象或对象数组
go.intention.generate.type.from.json=从 JSON 生成类型
go.intention.go.to.implementation.name=转到实现
go.intention.go.to.implementation.text=转到实现…
go.intention.go.to.super.name=转到接口
go.intention.go.to.super.text=转到接口…
go.intention.implement.interface.name=实现接口
go.intention.implement.interface.text=实现接口…
go.intention.include.fmt.function.name=标记为字符串格式设置函数
go.intention.invert.if.name=反转 if
go.intention.join.arguments=将实参放在同一行中
go.intention.join.composite.literal.elements=将元素放在同一行中
go.intention.join.parameters=将形参放在同一行中
go.intention.merge.all.declarations.name=合并所有声明
go.intention.merge.declaration.up.name=向上合并声明
go.intention.merge.declarations.by.comma.name=通过逗号向上合并声明
go.intention.migrate.function.parameter.to.method.receiver=将函数形参迁移到方法接收器
go.intention.migrate.function.parameter.to.method.receiver.error.hint.invalid.receiver.type=结果接收器类型 {0} 将无效({1} 为 {2})。
go.intention.migrate.function.parameter.to.method.receiver.error.hint.message=无法将函数形参迁移至方法接收器。\n{0}
go.intention.migrate.function.parameter.to.method.receiver.error.hint.method.with.type.parameter=生成的方法将无效，因为方法必须没有类型形参。
go.intention.migrate.function.parameter.to.method.receiver.error.hint.title=将函数形参迁移至方法接收器失败
go.intention.migrate.function.parameter.to.method.receiver.name=将函数形参迁移到方法接收器
go.intention.migrate.method.receiver.to.function.parameter=将方法接收者迁移到函数形参
go.intention.move.to.struct.initialization.name=将字段赋值移至结构体初始化
go.intention.negate.boolean.expression.name=求反表达式
go.intention.negate.boolean.expression.name.recursively.suffix=递归
go.intention.negate.boolean.expression.text=将 ''{0}'' 求反为 ''{1}''
go.intention.negate.boolean.topmost.expression.name=求反最顶端的表达式
go.intention.negate.boolean.topmost.expression.text=将最顶端的 ''{0}'' 求反为 ''{1}''
go.intention.remove.declaration.parens.name=从声明中移除圆括号
go.intention.remove.dot.import.alias.name=移除点导入别名
go.intention.remove.keys.from.struct.literal.value.name=从结构体字面量中移除键
go.intention.remove.method.from.interface=从接口移除方法及其所有实现
go.intention.remove.method.from.interface.conflict.message=方法已调用
go.intention.replace.if.with.switch=将 'if' 替换为 'switch'
go.intention.reuse.signature.types.name=重用签名类型
go.intention.run.go.generate.name=在注释上运行 go generate
go.intention.run.go.generate.on.file.name=在文件上运行 go generate
go.intention.run.go.generate.on.package.name=在软件包上运行 go generate
go.intention.run.go.generate.text=Go generate ''{0}''
go.intention.select.fields.dialog.title=选择字段
go.intention.specify.type.name=明确地指定类型
go.intention.split.all.declarations.name=拆分所有声明
go.intention.split.declarations.by.comma.name=通过逗号拆分声明
go.intention.split.declarations.name=将声明拆分为两个组
go.intention.update.value.in.tags=更新标记中的键值
go.intentions.category=Go
go.intentions.datasource-from-db-connection.name=从数据库连接创建数据源
go.libraries.configurable.path.source.prefix.default=[默认]
go.libraries.configurable.path.source.prefix.gopath=[GOPATH]
go.live.template.context.type.block.presentable.name=块
go.live.template.context.type.expression.presentable.name=表达式
go.live.template.context.type.file.presentable.name=文件
go.live.template.context.type.function.anonymous.name=匿名函数
go.live.template.context.type.statement.presentable.name=语句
go.live.template.context.type.tag.literal.presentable.name=标记字面量
go.live.template.context.type.tag.presentable.name=标记
go.live.template.context.type.type.presentable.name=类型
go.load.file.dialog.invalid.file=文件路径无效
go.load.file.dialog.invalid.url=请使用以 https\://go.dev/ 开头的 URL
go.load.file.dialog.radio.file=文件
go.load.file.dialog.radio.url=URL
go.load.file.dialog.title=选择要从中将代码导入临时文件的源\:
go.load.file.dialog.url.comment=使用以 https\://go.dev/ 开头的 URL
go.load.to.playground.could.not.load.message=//无法加载共享代码
go.load.to.playground.dialog.title=导入到临时文件
go.macro.bin.dirs.description=包含 Go 工具的 bin 目录路径
go.macro.executable.path.description=Go 可执行文件路径
go.macro.file.go.path.description=GOPATH 值
go.macro.file.go.root.description=项目 SDK 路径
go.macro.file.import.path.description=导入当前文件的路径
go.microservices.endpoints.group-by-module-title.full=按模块对端点分组
go.microservices.endpoints.group-by-module-title.short=按模块分组
go.microservices.endpoints.module-display-name=模块
go.microservices.endpoints.select-modules-title=选择模块
go.microservices.http.server.endpoint.title=Go HTTP 服务器
go.module=模块
go.modules.automatic.dependencies.download.task.text=正在 {0} 中执行 ''go mod download'' ({1}/{2})
go.modules.background.task.updating.dependencies.text=正在 {0} 个 ''go.mod'' {0,choice,0\#文件|1\#文件|2\#文件} 上执行 ''go list''…
go.modules.background.task.updating.dependencies.title=正在更新 Go 模块依赖项
go.modules.dependency.diagram=Go 模块依赖关系图
go.modules.scratch.file.notification.text=使用模块上下文
go.modules.tree.structure.replaced=(已替换)
go.modules.tree.structure.replacement=替换\: {0}
go.modules.unknown.dependencies.notification.retry=重新运行 ''{0}''
go.modules.unknown.dependencies.notification.text=完整的模块依赖项集合未知，某些特定于 Go 模块的功能可能不可用。
go.modules.unknown.dependencies.notification.tooltip=可能是由网络连接问题或显式 GOPROXY\=off 导致。
go.modules.unsupported.workspace.mode=Go SDK {0} 不支持 ''go.work'' 文件，请使用 Go 1.18 或更高版本
go.modules.wizard.description=创建 Go 模块项目，以开发使用 Go 模块进行依赖项管理的 Go 应用程序和库
go.modules.wizard.name=Go
go.mozilla.rr.dialog.specify.trace.directory.validation.message=指定跟踪目录
go.mozilla.rr.dialog.trace.directory.label=跟踪目录(&T)\:
go.mozilla.rr.failed.to.start.error.message=无法为 rr 跟踪 {0} 启动调试器\: {1}
go.mozilla.rr.session.name=跟踪 {0}
go.navigation.go.to.implementation=转到实现
go.navigation.go.to.implementation.find.usages.title={0} 的实现
go.navigation.go.to.method.implementation.popup.title={1} {1, choice, 0\#类型|1\#类型|2\#类型}中实现的方法 {0}
go.navigation.go.to.shadowed.method=转到阴影方法
go.navigation.go.to.shadowed.method.popup.title=方法 {0} 隐藏了 {1} 个{1,choice,0\#类型|1\#类型|2\#类型}的方法
go.navigation.go.to.shadowing.method=转到隐藏方法
go.navigation.go.to.shadowing.method.find.usages.title={0} 的隐藏方法
go.navigation.go.to.shadowing.method.popup.title={1} {1, choice, 0\#类型|1\#类型|2\#类型}中隐藏的方法 {0}
go.navigation.go.to.super=转到接口
go.navigation.go.to.super.find.usages.title={0} 已实现的接口
go.navigation.go.to.super.method=转到方法规范
go.navigation.go.to.super.method.find.usages.title.kind={0} 已实现的方法规范
go.navigation.go.to.super.method.popup.title=方法 {0} 实现了 {1} 个{1,choice,0\#接口|1\#接口|2\#接口}中的方法
go.navigation.go.to.super.popup.title=类型 {0} 实现了 {1} 个{1,choice,0\#接口|1\#接口|2\#接口}
go.navigation.go.to.type.implementation.popup.title={1} {1, choice, 0\#类型|1\#类型|2\#类型}中实现的类型 {0}
go.navigation.progress.title=正在搜索 {0}…
go.navigation.recursive.call=递归调用
go.navigation.shadowed.method.usages.title={0} 的隐藏方法
go.new.project.step.other.group.name=其他
go.new.project.step.web.group.name=Web
go.non.modal.welcome.screen.action.clone=克隆…
go.non.modal.welcome.screen.action.new=新建…
go.non.modal.welcome.screen.action.open=打开…
go.non.modal.welcome.screen.action.remote.development=远程开发…
go.non.modal.welcome.screen.create.file.dialog.title.dockerfile=新建 Dockerfile
go.non.modal.welcome.screen.create.file.dialog.title.file=新文件
go.non.modal.welcome.screen.create.file.dialog.title.http.request=新建 HTTP 请求
go.non.modal.welcome.screen.create.file.dialog.title.k8s.resource=新建 Kubernetes 资源
go.non.modal.welcome.screen.create.file.dockerfile=Dockerfile
go.non.modal.welcome.screen.create.file.empty=文件
go.non.modal.welcome.screen.create.file.http.request=HTTP 请求
go.non.modal.welcome.screen.create.file.kubernetes.resource=Kubernetes 资源
go.non.modal.welcome.screen.editor.name=新建项目
go.non.modal.welcome.screen.error.dialog.message.cannot.create.file=无法创建文件 {0}\: {1}
go.non.modal.welcome.screen.error.dialog.title.cannot.create.file=创建文件时出错
go.non.modal.welcome.screen.no.recent.projects=无最近项目
go.non.modal.welcome.screen.notification.open.file.in.folder.button=打开文件夹
go.non.modal.welcome.screen.notification.open.file.in.folder.text=要在 "{0}" 文件夹中打开此文件吗?
go.non.modal.welcome.screen.notification.open.file.in.project.button=打开项目
go.non.modal.welcome.screen.notification.open.file.in.project.text=您要在 "{0}" 项目中打开此文件吗?
go.non.modal.welcome.screen.project.view.title=项目和文件
go.non.modal.welcome.screen.right.tab.always.show.on.startup=启动时始终显示此页面
go.non.modal.welcome.screen.right.tab.feature.database=数据库
go.non.modal.welcome.screen.right.tab.feature.docker=Docker
go.non.modal.welcome.screen.right.tab.feature.http.client=HTTP 客户端
go.non.modal.welcome.screen.right.tab.feature.kubernetes=Kubernetes
go.non.modal.welcome.screen.right.tab.feature.plugins=插件
go.non.modal.welcome.screen.right.tab.feature.terminal=终端
go.non.modal.welcome.screen.right.tab.header=欢迎使用 GoLand
go.non.modal.welcome.screen.right.tab.keymap.switch.prefix=按键映射\: 
go.non.modal.welcome.screen.right.tab.secondary.header=直接在 IDE 中使用最流行的工具
go.non.modal.welcome.screen.right.tab.theme.switch.prefix=主题\: 
go.non.modal.welcome.screen.virtual.file.type.description=欢迎使用 GoLand
go.notification.add.to.gopath.action.text=添加到 GOPATH
go.notification.add.to.module.action.text=添加到模块
go.notification.add.vendored.package.to.project.action.text=向项目中添加 ''{0}''
go.notification.cgo.optimizations.are.not.disabled=CGO_CFLAGS 未设置为 '-O0 -g'，无法优化 cgo 代码。
go.notification.code.insight.disabled.for.vendored.files.text=库中供应文件的编辑代码洞察功能已禁用
go.notification.code.insight.features.are.disabled.text=代码洞察功能不可用
go.notification.create.go.mod.file.action.text=创建 'go.mod' 文件
go.notification.disable.cgo.support.action.text=禁用 cgo 支持
go.notification.disable.go.modules.integration.action.text=禁用 Go 模块集成
go.notification.do.not.show.action.text=不再显示
go.notification.download.missing.module.successfully.done=已成功处理 {0} 个{0,choice,0\#模块|1\#模块|2\#模块}
go.notification.enable.cgo.support.action.text=启用 cgo 支持
go.notification.file.does.not.match.target.system.text=''{0}'' 与目标系统不匹配。文件将被构建工具忽略。
go.notification.file.exceeds.size.limit.text=文件大小({0})超出了配置的限制({1})。{2}
go.notification.file.ignore.navigate.to.build.constraints.action.text=导航到构建约束
go.notification.file.ignore.navigate.to.cgo.import.action.text=导航到 cgo import
go.notification.file.is.ignored.because.arch.mismatch.text=由于架构不匹配，''{0}'' 被构建工具忽略
go.notification.file.is.ignored.because.bad.syntax.text=由于语法错误，''{0}'' 被构建工具忽略
go.notification.file.is.ignored.because.cgo.mismatch.text=由于 cgo 支持不匹配，''{0}'' 被构建工具忽略
go.notification.file.is.ignored.because.compiler.mismatch.text=由于编译器不匹配，''{0}'' 被构建工具忽略
go.notification.file.is.ignored.because.custom.flag.text=由于自定义标志，''{0}'' 被构建工具忽略
go.notification.file.is.ignored.because.missing.experiment.text=由于 Go 实验设置，构建工具会忽略 ''{0}''
go.notification.file.is.ignored.because.non.go.file.text=由于不是 Go 文件，''{0}'' 被构建工具忽略
go.notification.file.is.ignored.because.os.mismatch.text=由于 OS 不匹配，''{0}'' 被构建工具忽略
go.notification.file.is.ignored.because.version.mismatch.text=由于 Go 版本不匹配，''{0}'' 被构建工具忽略
go.notification.file.starts.with.dot.text=由于名称以 ''.'' 开头，''{0}'' 被构建工具忽略
go.notification.file.starts.with.underscore.text=由于名称以 ''_'' 开头，''{0}'' 被构建工具忽略
go.notification.go.edit.project.settings.action.text=编辑设置
go.notification.go.root.is.incorrect.text=GOROOT 不正确
go.notification.go.root.is.not.defined.text=未定义 GOROOT
go.notification.go.setup.action.text=设置 GOROOT
go.notification.go.support.enable.action.text=启用 Go 支持
go.notification.go.support.is.disabled.in.module.text=''{0}'' 中禁用 Go 支持
go.notification.go.tool.is.missing.run.go.get.invoke.go.get.action.text=调用 ''go get {0}''
go.notification.go.tool.is.missing.run.go.get.text=无法在 GOPATH 中找到 ''{0}''。
go.notification.go.tool.is.missing.text=GOPATH 中缺少可执行文件 ''{0}''。是否安装(go install {1})?
go.notification.gopath.configure.action.text=配置 GOPATH
go.notification.gopath.detected.configure.gopath.action.text=配置 GOPATH
go.notification.gopath.detected.text=我们从您的 GOPATH 中检测到一些库。您可能需要在 GOPATH 配置中添加额外的库。
go.notification.gopath.detected.title=检测到 GOPATH
go.notification.gopath.is.empty.text=GOPATH 为空
go.notification.inspections.are.disabled.enabled.action.text=启用检查
go.notification.inspections.are.disabled.text=已禁用对此文件进行检查
go.notification.install.as.tool.action.text=作为命令行工具安装
go.notification.install.go.tool.action.text=安装 Go 工具
go.notification.install.package.action.text=安装 {0}
go.notification.modules.file.is.absent.title='go.mod' 文件不存在
go.notification.obsolete.imports.code.style.detected.title=检测到过时的导入代码样式设置
go.notification.open.imports.settings=打开导入设置
go.notification.package.was.excluded=从导入中排除 {0}
go.notification.rename.file.action.text=重命名文件
go.notification.review.code.style.settings.action.text=查看代码样式设置
go.playground.actions.format.description=使用 Go Playround API 设置代码格式
go.playground.actions.format.text=设置格式
go.playground.actions.go.context.description.prefix=所选上下文\:
go.playground.actions.go.version.description.prefix=所选版本\:
go.playground.actions.go.version.label=Go 版本
go.playground.actions.load.description=将代码从提供的 URL 或文件加载到给定的 Playground 文件中
go.playground.actions.load.text=加载
go.playground.actions.run.description=在 Go Playground 中运行文件
go.playground.actions.run.locally.text=在本地运行
go.playground.actions.run.text=运行
go.playground.actions.share.description=通过提供可共享的链接在 Go Playground 中共享文件代码
go.playground.actions.share.text=共享
go.profiler.allocated.objects.metric.name=已分配的对象
go.profiler.allocated.space.metric.name=已分配的空间
go.profiler.application.configurable.name=Go 分析器
go.profiler.blocking.profile.prefix=阻塞分析
go.profiler.blocking.profiler.name=阻塞分析器
go.profiler.cpu.profile.prefix=CPU 分析
go.profiler.cpu.profiler.name=CPU 分析器
go.profiler.cpu.time.metric.name=CPU 时间
go.profiler.downloading.profiler.dump.progress.title=正在下载分析器转储…
go.profiler.in.use.objects.metric.name=使用中的对象
go.profiler.in.use.space.metric.name=使用中的空间
go.profiler.memory.profile.prefix=内存分析
go.profiler.memory.profiler.name=内存分析器
go.profiler.mutex.profile.prefix=Mutex 分析
go.profiler.mutex.profiler.name=Mutex 分析器
go.profiler.not.a.pprof.profile.error=不是 pprof 配置文件
go.profiler.parse.error=解析配置文件时出错\: {0}
go.profiler.parse.error.empty=配置文件为空
go.profiler.parse.error.eof=意外的文件结尾
go.profiler.profile.fraction.comment.text=控制配置文件中报告的互斥争用事件的分数。平均而言，报告 1/分数个事件。留空将使用默认分数 1。
go.profiler.profile.fraction.label.text=配置文件分数\:
go.profiler.profile.illegal.profile.fraction.validation.message=非法分析分数\: {0}
go.profiler.profile.illegal.rate.validation.message=非法分析速率\: {0}
go.profiler.profile.rate.cpu.comment.text=控制配置文件中报告的 goroutine 阻塞事件的分数。平均而言，分析器的目标是在程序被阻塞的每个周期对一个阻塞事件采样。周期以纳秒为单位进行设置。要在配置文件中包含每个阻塞事件，请将值设置为 1。留空将使用默认分析器速率 1。
go.profiler.profile.rate.label.text=配置文件速率\:
go.profiler.profile.rate.memory.comment.text=控制配置文件中记录和报告的内存分配分数。平均而言，分析器的目标是根据分配的每个字节数对一次分配进行采样。要在配置文件中包含分配的每个块，请将速率设置为 1。留空将使用 512 KB 的默认速率。
go.project.configurable.name=Go
go.quick.doc.assign.iota=为 'iota' 赋值不等于重置 'builtin.iota' 的计数器。相反，赋值会定义一个新的隐藏 'builtin.iota' 的常量 'iota'。
go.quick.doc.blank.identifier.hint=空白标识符 ('_') 可以赋给任何类型的任何值或用任何类型的值声明。空白标识符会被舍弃，不会被编译器使用。例如，当您想要捕获返回值但不打算在以后使用此值时，可以考虑使用空白标识符。
go.quick.doc.channel.direction.label=通道方向\:
go.quick.doc.channel.receive.label=从通道接收
go.quick.doc.channel.send.label=发送到通道
go.quick.doc.composite.literal.hint=此复合字面量会使用给定值分配新的 {0} 实例。
go.quick.doc.empty.interface.hint=空接口 'interface{}' 代表所有类型的集合。空接口类型的变量可以存储任何类型的值。
go.quick.doc.iota.example=例如，'const (C0 \= iota; C1; C2)' 将打印 '0'、'1' 和 '2'。每次在代码中使用 'const' 时，计数都会重置为 '0'。要查看 'iota' 分配的常量的值，请将鼠标指针悬停在常量规范上。
go.quick.doc.keyword.resource.effective.go.label=Effective Go
go.quick.doc.keyword.resource.go.blog.label=Go 博客
go.quick.doc.keyword.resource.language.spec.label=Go 语言规范
go.quick.doc.keyword.type.switch=类型 switch 匹配接口值 'x' 的动态类型。动态类型与 'switch' case 中的类型匹配。如果使用形式为 'v \:\= x.(type)' 的短变量赋值作为 switch guard，并且 switch case 仅用于单一类型，则 'v' 将具有匹配的 switch case 中指定的类型。
go.quick.doc.methods.on.label=方法对象\:
go.quick.doc.package.label=软件包\:
go.quick.doc.resolved.value.label=已解析的值\: 
go.quick.doc.struct.literal.hint=您可以按顺序指定字段值，也可以使用其名称。
go.quick.doc.substitution.label=替换\:
go.quick.doc.too.large.to.render=太大，无法呈现
go.quick.doc.type.alias.and.definition.hint.link.text=Go 规范\: 类型标识
go.quick.doc.type.alias.hint=类型{0}是类型{1}的别名。这些类型完全相同。有关详细信息，请参阅{2}
go.quick.doc.type.assertions.hint=类型断言用于检查变量是否为某种类型，并返回基础接口值。类型断言仅适用于接口。例如，在下面的代码中\: 'var x interface{} \= 42 t \:\= x.(int)'，'x' 具有带基础 int 值  ('42') 的 'interface{}' 类型，'int' 是我们要检查的具体类型。如果我们打印 't'，输出将为 '42'。将具体类型更改为 'string' ('t \:\= x.(string)') 将导致运行时宕机。类型断言可以返回两个值。例如，表达式 't, ok \:\= x.(int)' 具有布尔值 'ok'，如果断言正确，则返回 'true'。如果 'ok' 为 'false'，则会将 't' 设置为零值，并且不会发生宕机。
go.quick.doc.type.definition.hint=类型{0}是基础类型为{1}的新类型。这些类型是不同的。有关详细信息，请参阅{2}
go.quick.doc.type.parameter.hint={0} 声明用于声明类型形参。这些类型形参会将 {0} 变为泛型。泛型 {0} 可以处理多种类型。可能的类型集由类型形参的约束控制。有关泛型的详细信息，请参阅 {1}
go.quick.doc.type.parameter.hint.hyperlink.text=教程\: go.dev 泛型入门
go.quick.doc.type.parameter.in.method.hint=该方法为泛型，因为接收器的基类型为泛型类型。方法规范必须声明与接收器基本类型的类型形参相对应的类型形参。方法类型实参必须使用接收器基类型中使用的类型约束。有关泛型的详细信息，请参阅 {0}
go.refactoring.change.signature.current.method.option=仅{0}当前方法
go.refactoring.change.signature.function.will.not.perform.initialization.validation.message=函数 {0} 将不再执行初始化
go.refactoring.change.signature.function.will.not.start.application.validation.message=函数 {0} 将不再启动应用程序
go.refactoring.change.signature.method.specification.and.implementations.option={0}方法规范和所有实现
go.refactoring.change.signature.named.and.unnamed.parameters.validation.message=无法同时使用命名形参和未命名形参。
go.refactoring.change.signature.new.parameter.validation.message.part=新形参
go.refactoring.change.signature.not.legal.identifier.validation.message=''{0}'' 不是合法标识符。
go.refactoring.change.signature.parameter.without.type.validation.message=第 {0,number,ordinal} 个形参应具有类型。
go.refactoring.change.signature.remove.parameter.generic.message=新函数类型可能会导致类型错误
go.refactoring.change.signature.remove.parameter.used.as.call.argument.message=对 {0} 的调用将传递不同类型的{1,choice,1\#实参|2\#实参}
go.refactoring.change.signature.remove.parameter.used.as.var.value.message=变量 {0} 的类型将会更改
go.refactoring.change.signature.remove.parameter.used.in.assignment.message=赋值给 {0} 可能会导致类型错误
go.refactoring.change.signature.renamed.parameter.validation.message.part=重命名的形参
go.refactoring.change.signature.result.parameters.tab.title=结果形参
go.refactoring.change.signature.reuse.types.checkbox=重用类型
go.refactoring.change.signature.target.not.found.error.message=文本光标必须位于要重构的函数或方法的名称处
go.refactoring.change.signature.used.multiple.times.validation.message=''{0}'' 被多次使用。
go.refactoring.change.signature.variadic.is.not.last.validation.message=可变形参应始终是最后一个形参。
go.refactoring.change.signature.variadic.parameter.in.result.validation.message=结果中不允许使用可变形参。
go.refactoring.declarations.separator=声明
go.refactoring.different.package.name.validation.message=现有文件的软件包名称不应不同。
go.refactoring.empty.target.directory.path.validation.message=目标目录路径不应为空。
go.refactoring.empty.target.file.name.validation.message=目标文件名不应为空。
go.refactoring.empty.target.package.validation.message=目标软件包名称不应为空。
go.refactoring.exported.column.name=已导出
go.refactoring.extract.interface.caret.should.be.inside.type.error.message=文本光标应置于要重构的类型内
go.refactoring.extract.interface.empty.type.name.validation.message=类型名称不应为空。
go.refactoring.extract.interface.incorrect.type.name.validation.message=类型名称不正确。
go.refactoring.extract.interface.rename.type.and.use.interface.radio.button=重命名原始类型并在可能的情况下使用接口(&E)
go.refactoring.extract.interface.rename.type.spec.label=将类型规范重命名为\:
go.refactoring.extract.interface.unexported.method.specification.validation.message={0} {1} 不会实现未导出的方法规范
go.refactoring.extract.interface.unexported.not.be.accessible.validation.message=未导出的{0}将无法从{1}访问
go.refactoring.failed.to.create.directory.error.message=找不到或创建目录 ''{0}''
go.refactoring.failed.to.create.file.for.package.error.message=无法为软件包 ''{1}'' 找到或创建文件 ''{0}''
go.refactoring.file.chooser.dialog.title=选择目标目录或文件
go.refactoring.file.label=目标文件\:
go.refactoring.implement.methods.checkbox=非项目(&N)
go.refactoring.implement.methods.command=实现{0}
go.refactoring.implement.methods.create.type.name=创建类型…
go.refactoring.implement.methods.dummy.background.updater.task.title=正在搜索类型…
go.refactoring.implement.methods.preparing.template.progress.title=正在准备模板…
go.refactoring.implement.methods.prompt=选择要实现的接口\:
go.refactoring.incorrect.file.name.validation.message=目标文件名不正确。
go.refactoring.incorrect.package.name.validation.message=目标软件包名称不正确。
go.refactoring.inline.cannot.inline.call.from.defer=无法将内联重构应用于来自 'defer' 语句的调用
go.refactoring.inline.cannot.inline.call.from.go=无法将内联重构应用于来自 'go' 语句的调用
go.refactoring.inline.cannot.inline.in.loop.condition=无法将内联重构应用于循环条件中的多行函数或软件包级别的 'var' 或 'const' 声明
go.refactoring.inline.cannot.inline.many.returns=无法将内联重构应用于具有多个返回的函数
go.refactoring.inline.cannot.inline.no.body=无法将内联重构应用于没有主体的函数
go.refactoring.inline.cannot.inline.recursive.functions=无法将内联重构应用于递归函数
go.refactoring.inline.cannot.inline.variadic.parameter=不支持内联可变形参
go.refactoring.inline.command.name=内联函数/方法
go.refactoring.inline.defer.statements=该函数包含将在周围函数调用后执行的 defer 语句
go.refactoring.inline.defined.in.goroot.error.message={0} {1} 在 GOROOT 中定义
go.refactoring.inline.defined.in.multi.value.context.error.message={0} {1} 在多值上下文中定义
go.refactoring.inline.found.usages.in.goroot.message=已在 GOROOT 中找到 ''{1}'' 的 {0, choice, 1\#1 个用法|2\#{0} 个用法}。
go.refactoring.inline.kept.definition.and.inlined.message=已保留定义{0, choice, 0\#|1\#和项目与 GOPATH 中的 1 个内联用例|2\#和项目与 GOPATH 中的 {0} 个内联用例}。
go.refactoring.inline.no.initializer.error.message={0} {1} 没有初始值设定项
go.refactoring.inline.no.parameter.value.error.message=找不到形参 {0} 的值
go.refactoring.inline.options.dialog.all.keep=内联所有调用并保留声明(&K)
go.refactoring.inline.options.dialog.all.remove=内联所有调用并移除声明(&A)
go.refactoring.inline.options.dialog.name.label=如何执行内联重构?
go.refactoring.inline.options.dialog.this.keep=仅内联此调用并保留声明(&T)
go.refactoring.inline.reassigned.error.message=已重新分配 {0}
go.refactoring.introduce.analyzing.before.extraction=正在对代码进行提取前的分析…
go.refactoring.introduce.collecting.free.vars=正在收集自由变量…
go.refactoring.introduce.continue.statement.interrupts.execution.flow.error.message=当 continue 语句中断执行流时，不支持重构
go.refactoring.introduce.does.not.return.value.error.message=表达 {0} 不返回值。
go.refactoring.introduce.extract.function.command=提取函数
go.refactoring.introduce.extract.function.title=提取函数
go.refactoring.introduce.extract.method.command=提取方法
go.refactoring.introduce.extract.method.or.function.title=提取方法或函数
go.refactoring.introduce.extract.title=提取
go.refactoring.introduce.extract.variable.command=提取变量
go.refactoring.introduce.generating.code.template=正在生成代码模板…
go.refactoring.introduce.label.definition.selected.with.all.references.error.message=只有选择标签定义及其所有引用时，才支持重构
go.refactoring.introduce.label.reference.interrupts.execution.flow.error.message=当标签引用中断执行流时，不支持重构
go.refactoring.introduce.method.with.receiver.renderer=包含 {0} 接收器的方法
go.refactoring.introduce.not.constant.value.error.message=表达式 {0} 不是常量值。
go.refactoring.introduce.range.contains.defer.message=所选范围包含 'defer' 语句，该语句可能会在提取期间重新排序
go.refactoring.introduce.receiver.without.name.error.message=接收器应有名称
go.refactoring.introduce.type.chooser.title=选择类型
go.refactoring.introduce.type.command=引入类型
go.refactoring.introduce.type.dialog.title=引入类型
go.refactoring.less.than.one.declaration.validation.message=应至少选择一个声明。
go.refactoring.merge.declarations.action.text=合并声明
go.refactoring.merge.declarations.with.iota.warning=由于 'iota'，声明初始值设定项合并后会有不同的值
go.refactoring.move.affect.initialization.order.validation.message=移动函数 {0} 可能会影响该应用程序的初始化顺序
go.refactoring.move.break.initialization.validation.message=移动变量 {0} 将中断变量 {1} 的初始化
go.refactoring.move.exported.function.will.not.perform.initialization.validation.message=导出的函数 {0} 将不再执行初始化
go.refactoring.move.exported.function.will.not.start.application.validation.message=导出的函数 {0} 将不再启动应用程序
go.refactoring.move.file.should.differ.validation.message=目标文件应与源文件不同
go.refactoring.move.function.will.not.start.application.validation.message=软件包 {1} 外部的函数 {0} 将不再启动此应用程序
go.refactoring.move.required.by.validation.message={0}需要
go.refactoring.move.type.will.become.non.local.for.method.validation.message=类型 {0} 将成为方法 {1} 的非局部类型
go.refactoring.move.type.will.not.implement.interface.validation.message=类型 {0} 将不再实现接口 {1}
go.refactoring.move.value.will.change.validation.message=常量 {0} 的值将更改，因为它使用 {1} 进行声明
go.refactoring.non.go.file.validation.message=目标文件应为 Go 文件。
go.refactoring.non.writable.directory.validation.message=目标目录不可写。
go.refactoring.non.writeable.file.validation.message=目标文件不可写。
go.refactoring.redeclare.validation.message={0} 将重新声明相同名称的 {1}
go.refactoring.refactor.action=重构
go.refactoring.rename.action=重命名
go.refactoring.rename.all.receivers.option=重命名所有接收器
go.refactoring.rename.current.receiver.option=仅重命名当前接收器
go.refactoring.rename.directory.message=同时重命名软件包目录 ''{0}''?
go.refactoring.rename.looking.for.anonymous.field.usages.progress.title=正在查找匿名字段用法
go.refactoring.rename.looking.for.method.usages.progress.title=正在查找方法用法
go.refactoring.rename.package.title=同时将软件包 ''{0}'' 重命名为 ''{1}''?
go.refactoring.rename.production.file.title=同时重命名生产文件 ''{0}''?
go.refactoring.rename.test.file.title=同时重命名测试文件 ''{0}''?
go.refactoring.rename.type.parameter.option.all=在类型定义和所有接收器中重命名
go.refactoring.rename.type.parameter.option.current.only=仅重命名此类型形参
go.refactoring.split.declarations.action.text=拆分声明
go.refactoring.split.declarations.with.iota.warning=由于 'iota'，声明初始值设定项拆分后会有不同的值
go.refactoring.unexported.validation.message=未导出的{0}将不再可以从{1}访问
go.remote.debug.disconnect.delve.label=断开连接时\:
go.remote.debug.disconnect.delve.option.ask=询问
go.remote.debug.disconnect.delve.option.leave=保持运行
go.remote.debug.disconnect.delve.option.stop=停止远程 Delve 进程
go.remove.else=移除 else
go.replace.field.type.with.pointer.family.name=将字段类型替换为指针
go.run.configuration.add.go.tool.argument.label=添加
go.run.configuration.build.on.remote.target.checkbox=在远程目标上构建(&B)
go.run.configuration.emulate.terminal.in.output.console=在输出控制台中模拟终端(&E)
go.run.configuration.environment.label=环境(&V)\:
go.run.configuration.go.tool.arguments.label=Go 工具实参(&G)\:
go.run.configuration.kind.directory=目录
go.run.configuration.kind.file=文件
go.run.configuration.kind.package=软件包
go.run.configuration.module.label=模块(&M)\:
go.run.configuration.output.directory.label=输出目录(&O)\:
go.run.configuration.program.arguments.label=程序实参(&P)\:
go.run.configuration.run.after.build.checkbox=构建后运行(&R)
go.run.configuration.run.kind.label=运行种类(&K)\:
go.run.configuration.run.with.sudo.label=通过 sudo 运行(&I)
go.run.configuration.run.with.sudo.mnemonic=使用提升的权限运行(&I)
go.run.configuration.run.with.sudo.tooltip=使用超级用户权限运行配置
go.run.configuration.target.directory.label=目录(&D)
go.run.configuration.target.files.label=文件(&F)\:
go.run.configuration.target.package.label=软件包路径(&E)\:
go.run.configuration.test.framework=测试框架(&R)\:
go.run.configuration.test.kind.label=测试种类(&K)\:
go.run.configuration.test.pattern.label=模式(&T)\:
go.run.configuration.use.all.custom.build.tags.label=使用所有自定义构建标记(&L)
go.run.configuration.use.all.custom.build.tags.tooltip=您的设置中的所有自定义构建标记都是在构建过程中添加的(请参阅“Go | 构建标记”)
go.run.playground.could.not.run.message=无法运行代码
go.run.target.compiled.executables.description=目标上经过编译的可执行文件的输出路径
go.run.target.compiled.executables.directory.browsing.title=经过编译的可执行文件
go.run.target.compiled.executables.directory.label=经过编译的可执行文件目录\:
go.run.target.configure.label=Go 配置
go.run.target.executable.path.label=Go 可执行文件\: 
go.run.target.executable.path.title=Go 可执行文件
go.run.target.gopath.label=GOPATH\: 
go.run.target.gopath.title=GOPATH
go.run.target.project.sources.description=目标上项目源的输出路径
go.run.target.project.sources.directory.browsing.title=项目源
go.run.target.project.sources.directory.label=项目源目录\:
go.run.target.run.label=运行 Go 应用程序
go.run.target.version.label=版本\:
go.sdk.no.version.text=<无版本>
go.settings.build.tags.any.sdk.value=任意
go.settings.build.tags.arch.label=Arch
go.settings.build.tags.cgo.support.label=cgo 支持
go.settings.build.tags.compiler.label=编译器
go.settings.build.tags.custom.tags.hint=<html><body><p>以空格分隔的附加标记列表。<a href\="https\://www.jetbrains.com/help/go/configuring-build-constraints-and-vendoring.html\#configure-build-constraints-for-your-project">可以用于 </a>'go build' 命令。</p></body></html>
go.settings.build.tags.custom.tags.label=自定义标记
go.settings.build.tags.description=<html><body><p>以下选项描述编辑器的目标系统。IDE 使用这些值定义在验证、解析和代码补全中使用的文件。有关这些选项的详细信息，请参阅 <a href\="https\://golang.org/pkg/go/build/\#hdr-Build_Constraints">Go 约束文档</a>。</p></body></html>
go.settings.build.tags.display.name=构建标记
go.settings.build.tags.experiments.hint=<html><body><p>以逗号分隔列表的形式输入 Go 实验标签(例如，'rangefunc,loopvar')。</p></body></html>
go.settings.build.tags.experiments.label=实验
go.settings.build.tags.group.name=编辑器约束
go.settings.build.tags.os.label=OS
go.settings.build.tags.version.label=Go 版本
go.settings.common.ask.for.confirmation.in.playground.checkbox=在 Go Playground 中共享之前询问
go.settings.common.confirmation.show.options.option=显示选项
go.settings.common.convert.json.on.paste.convert.option=将 JSON 转换为 Go 类型
go.settings.common.convert.json.on.paste.insert.as.is.option=照原样插入 JSON
go.settings.common.convert.json.on.paste.option=粘贴 JSON 时
go.settings.common.detect.go.packages.from.clipboard.checkbox=从剪贴板检测 go 软件包
go.settings.common.directory.rename.do.not.rename.package.option=不重命名软件包
go.settings.common.directory.rename.option=重命名目录时
go.settings.common.directory.rename.rename.package.option=重命名软件包
go.settings.common.indent.on.enter.in.raw.strings.checkbox=在输入原始字符串时缩进
go.settings.common.package.rename.do.not.rename.directory.option=不重命名目录
go.settings.common.package.rename.option=重命名软件包时
go.settings.common.package.rename.rename.directory.option=重命名目录
go.settings.common.show.auto.import.in.completion.popup.checkbox=在键入时建议需要附加导入的变体
go.settings.common.show.documentation.in.parameter.info.checkbox=在形参信息中显示文档
go.settings.common.suggest.parameter.names.checkbox=在补全时建议形参名称
go.settings.common.test.do.not.rename.corresponding.file.option=不重命名相应的测试或生产文件
go.settings.common.test.rename.corresponding.file.option=重命名相应的测试或生产文件
go.settings.common.test.rename.option=重命名文件时
go.settings.completion.ml.display.name=Go
go.settings.debugger.dataViews.section.name=Go
go.settings.debugger.default.integer.format.label=默认整数格式\:
go.settings.debugger.enable.string.view=启用 String() 视图
go.settings.debugger.general.section.name=Go
go.settings.debugger.goroutines.limit.name=Goroutines 限制
go.settings.debugger.max.array.values=从数组、切片或映射读取的最大元素数
go.settings.debugger.max.string.len=从字符串读取的最大字节数
go.settings.debugger.max.string.len.in.call=从字符串读取用于函数调用结果的最大字节数
go.settings.debugger.max.struct.fields=从结构体读取的最大字段数(-1 表示读取所有字段)
go.settings.debugger.rebuild.transitive.packages.checkbox=重新构建过渡软件包(&R)
go.settings.debugger.rebuild.transitive.packages.description=为了获得更好的调试体验，Delve 需要在 $GOROOT/pkg 中重新编译优化的模块。
go.settings.debugger.show.pointer.addresses=显示指针地址
go.settings.debugger.show.types=显示类型
go.settings.debugger.show.unreadable.variables=显示不可读的变量
go.settings.debugger.stack.depth.name=堆栈深度
go.settings.debugger.use.custom.delve.settings=配置 Delve 调试设置
go.settings.default.value=默认 ({0})
go.settings.diff.ignore.imports.and.formatting.description=忽略导入和格式设置
go.settings.disabled=禁用
go.settings.enabled=启用
go.settings.excluded.fmt.functions.display.name=排除的格式设置函数
go.settings.fmt.functions.display.name=格式设置函数
go.settings.folding.empty.functions.checkbox=空函数
go.settings.folding.empty.struct.or.interface.type.defs.checkbox=空结构体或接口类型定义
go.settings.folding.format.strings.checkbox=格式化字符串
go.settings.folding.one.line.case.clauses.checkbox=单行 case 子句
go.settings.folding.one.line.error.handling.blocks.checkbox=用于错误处理的单行 'if' 块
go.settings.folding.one.line.panics.checkbox=具有单个 'panic' 的单行 'if' 块
go.settings.folding.one.line.return.checkbox=具有单个 'return' 的单行 'if' 块
go.settings.folding.one.line.return.functions.checkbox=具有单个 'return' 的单行函数
go.settings.formatter.add.space.except.for.comments.label=以此开头的注释除外\: 
go.settings.formatter.comment.prefix.cannot.be.empty.validation.message=注释前缀不能为空
go.settings.formatter.comment.prefix.dialog.title=注释前缀
go.settings.formatter.no.exceptions.empty.text=无异常
go.settings.formatter.wrap.call.arguments=函数调用实参
go.settings.formatter.wrap.comp.lit=复合字面量
go.settings.formatter.wrap.func.params=函数形参
go.settings.formatter.wrap.func.result=函数结果形参
go.settings.global.gopath.group.name=全局 GOPATH
go.settings.imports.display.name=导入
go.settings.invalid.build.tag.error=构建标记无效\: ''{0}''
go.settings.module.gopath.group.name=模块 GOPATH
go.settings.modules.add.other.environment.variable=其他
go.settings.modules.automatic.dependencies.download.checkbox.link=转到“构建工具”页面
go.settings.modules.automatic.dependencies.download.checkbox.tooltip=<p>在项目打开和依赖项更改时自动运行 'go mod download'。如果您的网络连接有限，请禁用此选项。</p><p>在“构建、执行、部署 | 构建工具”页面上配置对 Go 模块中更改的监测</p>
go.settings.modules.automatic.dependencies.download.disable.for.all=为所有项目禁用
go.settings.modules.automatic.dependencies.download.disable.for.current.project=为当前项目禁用，为其他项目启用
go.settings.modules.automatic.dependencies.download.enable.for.all=为所有项目启用
go.settings.modules.automatic.dependencies.download.enable.for.current.project=为当前项目启用，为其他项目禁用
go.settings.modules.automatic.dependencies.download.label=下载 Go 模块依赖项\:
go.settings.modules.choose.module.dialog.title=选择 Go 模块
go.settings.modules.choose.module.validation.message=选择至少一个模块
go.settings.modules.display.title=Go 模块
go.settings.modules.do.not.set.goexperiment=在 'Build Tags' 设置中为 GOEXPERIMENT 使用 'Experiments' 字段
go.settings.modules.enable.integration.checkbox=启用 Go 模块集成
go.settings.modules.environment.context.goproxy=除非明确设置，否则会根据您所在区域自动选择 GOPROXY
go.settings.modules.environment.context.help=GOPROXY、GOPRIVATE 和其他环境变量
go.settings.modules.environment.label=环境\:
go.settings.modules.explain.environment.variable=解释变量
go.settings.modules.gomodcache.description=GOMODCACHE 设置模块缓存位置。
go.settings.modules.gomodcache.documentation.link.title=Go 1.15 发行说明
go.settings.modules.gonoproxy.description=GONOPROXY 列出了被视为 private 的软件包。下载这些软件包时，go 命令不会使用代理。覆盖 GOPRIVATE。
go.settings.modules.gonosumdb.description=GONOSUMDB 列出了被视为 private 的软件包。验证这些软件包时，go 命令不会使用校验和数据库。覆盖 GOPRIVATE。
go.settings.modules.goprivate.description=GOPRIVATE 列出了被视为 private 的软件包。在下载和验证这些软件包时，go 命令不会使用代理或校验和数据库。
go.settings.modules.goprivate.documentation.link.title=非 public 模块的模块配置
go.settings.modules.goproxy.documentation.link.title=模块下载和验证
go.settings.modules.goproxy.tooltip=GOPROXY 指示 go 命令在下载依赖项时使用特定的代理服务器。
go.settings.modules.gosumdb.description=GOSUMDB 可以识别校验和数据库的名称。go 命令使用它来确保下载的依赖项的校验和没有更改。
go.settings.modules.gosumdb.documentation.link.title=模块身份验证失败
go.settings.modules.gotoolchain.description=GOTOOLCHAIN 会设置要使用的 Go SDK 版本。
go.settings.modules.gotoolchain.documentation.link.title=Go 工具链
go.settings.modules.sync.dependencies.fix.family.name=同步依赖关系
go.settings.modules.sync.dependencies.fix.text=修正缺失的依赖项({0})
go.settings.modules.vendoring.checkbox=自动启用供应支持
go.settings.modules.vendoring.checkbox.tooltip=当模块包含 'vendor' 目录时，启用 vendoring 支持。如果 'vendor' 目录不是由 Go 语言创建的，并且不包含 Go 依赖项，请清除此复选框。当此选项关闭时，使用 '-mod\=mod' 或 '-mod\=readonly' 调用 'go' 工具。
go.settings.modules.vendoring.documentation.link.title=如何为模块使用 vendoring
go.settings.postfix.choose.type.action.name=选择类型…
go.settings.postfix.choose.type.prompt.text=选择类型
go.settings.postfix.enter.type.action.name=输入类型名称…
go.settings.postfix.enter.type.empty.type.validation.message=指定类型名称
go.settings.postfix.enter.type.import.path.label=导入路径(&I)\:
go.settings.postfix.enter.type.name.label=类型名称(&T)\:
go.settings.project.gopath.group.name=项目 GOPATH
go.settings.project.sdk.value=项目 SDK ({0})
go.settings.sdk.add.action.name=本地…
go.settings.sdk.add.button=添加 SDK…
go.settings.sdk.add.button.tooltip=添加 SDK ({0})
go.settings.sdk.add.local.title=为 Go SDK 选择主目录
go.settings.sdk.combo.tooltip=添加 SDK…
go.settings.sdk.detected.notification.configure.go.sdk.action.text=配置 Go SDK
go.settings.sdk.detected.notification.text=<b>{0}</b> 被自动设置为项目 SDK。您可以在 GOROOT 配置中进行更改。
go.settings.sdk.detected.notification.title=检测到 GOROOT
go.settings.sdk.discovering.go.sdks.progress.title=正在发现 Go SDK…
go.settings.sdk.download.action.name=下载…
go.settings.sdk.download.checksum.of.downloaded.file.mismatched.error=下载的文件的校验和不匹配
go.settings.sdk.download.could.not.copy.unpacked.sdk.error=无法复制解压缩的 SDK
go.settings.sdk.download.could.not.find.go.directory.in.downloaded.file.error=无法在下载的文件中找到 go 目录
go.settings.sdk.download.could.not.get.checksum.error=无法获取校验和\: {0}
go.settings.sdk.download.could.not.unpack.downloaded.file.error=无法解压缩下载的文件
go.settings.sdk.download.dialog.cannot.create.directory.validation.message=无法在给定路径中创建目录。
go.settings.sdk.download.dialog.cannot.load.go.versions.validation.message=无法加载 SDK 版本。{0}
go.settings.sdk.download.dialog.location.is.not.specified.validation.message=指定目标目录。
go.settings.sdk.download.dialog.location.label=位置\:
go.settings.sdk.download.dialog.progress.versions.status=Go SDK 版本
go.settings.sdk.download.dialog.recommended.label=全部显示
go.settings.sdk.download.dialog.recommended.tooltip=在版本列表中包括已归档版本和不稳定版本。
go.settings.sdk.download.dialog.reload.versions.action.name=重新加载
go.settings.sdk.download.dialog.title=下载 Go SDK
go.settings.sdk.download.dialog.version.is.not.specified.validation.message=指定版本。
go.settings.sdk.download.dialog.version.label=版本\:
go.settings.sdk.download.failed.to.download.notification.title=下载 SDK 失败
go.settings.sdk.download.installed.notification.title=已安装 {0} {1}
go.settings.sdk.download.progress.copying.detailed.status=正在复制 {0}…
go.settings.sdk.download.progress.copying.status=正在复制 SDK…
go.settings.sdk.download.progress.downloading.status=正在下载 {0} {1}
go.settings.sdk.download.progress.unpacking.status=正在解压缩 SDK…
go.settings.sdk.download.progress.verifying.status=正在验证下载的归档…
go.settings.sdk.download.unpacked.sdk.is.corrupted.error=解压缩的 SDK 损坏
go.settings.sdk.enable.integration.label=在模块中启用 Go 支持\: 
go.ssr.category.comment=Go/注释
go.ssr.category.declaration=Go/声明
go.ssr.category.expression=Go/表达式
go.ssr.category.interesting=Go/有趣
go.ssr.category.interface=Go/接口
go.ssr.category.statement=Go/语句
go.ssr.category.struct=Go/结构
go.ssr.predefined.configuration.array.access=数组访问
go.ssr.predefined.configuration.channel.close=通道关闭
go.ssr.predefined.configuration.channel.operation=通道操作
go.ssr.predefined.configuration.channel.receive=通道接收
go.ssr.predefined.configuration.comments.containing.word=包含单词的注释
go.ssr.predefined.configuration.constant.declaration=常量声明
go.ssr.predefined.configuration.defer.statement=Defer 语句
go.ssr.predefined.configuration.doc.comment=文档注释
go.ssr.predefined.configuration.empty.interface=空接口
go.ssr.predefined.configuration.error.handling=错误处理
go.ssr.predefined.configuration.error.return=错误返回
go.ssr.predefined.configuration.for.loop=For 循环
go.ssr.predefined.configuration.function.call=函数调用
go.ssr.predefined.configuration.function.declaration=函数声明
go.ssr.predefined.configuration.function.multiple.returns=具有多个返回值的函数
go.ssr.predefined.configuration.function.multiple.returns.shorthand=具有多个返回值且使用类型速记形式的函数
go.ssr.predefined.configuration.function.named.returns=具有命名返回值的函数
go.ssr.predefined.configuration.goroutine=Goroutine
go.ssr.predefined.configuration.if.statement=If 语句
go.ssr.predefined.configuration.infinite.loop=无限循环
go.ssr.predefined.configuration.interface.declaration=接口声明
go.ssr.predefined.configuration.interface.method=接口方法
go.ssr.predefined.configuration.interface.with.embedded=具有嵌入式接口的接口
go.ssr.predefined.configuration.method.call=方法调用
go.ssr.predefined.configuration.method.declaration=方法声明
go.ssr.predefined.configuration.multiple.constants=多个常量
go.ssr.predefined.configuration.range.loop=范围循环
go.ssr.predefined.configuration.select.statement=选择语句
go.ssr.predefined.configuration.slice.expression=切片表达式
go.ssr.predefined.configuration.string.literals=字符串字面量
go.ssr.predefined.configuration.struct.declaration=结构体声明
go.ssr.predefined.configuration.switch.statement=Switch 语句
go.ssr.predefined.configuration.type.assertion=类型断言
go.ssr.predefined.configuration.type.declaration=类型声明
go.ssr.predefined.configuration.type.switch=类型 Switch
go.ssr.predefined.configuration.variable.declaration=变量声明
go.ssr.predefined.configuration.variadic.function=可变函数
go.ssr.unsupported.search.template=搜索模板包含不受支持的元素
go.structure.view.exportability.sorter.text=按可导出性
go.structure.view.method.location=在 {0} 中
go.structure.view.private.members.filter.text=显示 private 成员
go.structure.view.show.package.structure.action.text=显示软件包结构
go.structure.view.show.package.structure.checkbox.text=显示软件包结构
go.sum.generated.sources.filter.notification.text=不应编辑该文件，因为该文件仅供 Go 工具使用。更改可能会导致构建进程中断。
go.survey.promoter.action.later=稍后提醒我
go.survey.promoter.action.never=不再询问
go.survey.promoter.action.yes=是
go.survey.promoter.content=帮助塑造 Go 的未来\! 您是否希望通过在 {0} 之前参与这项耗时为 10 分钟的 Go 开发者调查来帮助确保 Go 满足您的需求?
go.survey.promoter.title=Go 开发者调查
go.template.intention.add.type.hint.name=指定点类型
go.template.intention.associate.file.extension.with.go.template=将文件扩展名与 Go 模板关联
go.template.intention.extension.associated.with.template=''{0}'' 扩展名已与 Go 模板关联
go.template.intention.open.file.type.settings=打开 Go 模板文件类型设置
go.template.intention.undo=撤消
go.terms.anonymous.field=匿名字段
go.terms.array=数组
go.terms.case=case
go.terms.chan=chan
go.terms.closure=结束
go.terms.comma=逗号
go.terms.comment=注释
go.terms.constant=常量
go.terms.declaration=声明
go.terms.duplicate=重复
go.terms.duplicated.case=重复的 case
go.terms.duplicated.default=重复的默认值
go.terms.empty.declaration=空声明
go.terms.field=字段
go.terms.function=函数
go.terms.global.constant=全局常量
go.terms.global.variable=全局变量
go.terms.go.statement=go 语句
go.terms.import=导入
go.terms.import.alias=导入别名
go.terms.interface=接口
go.terms.label=标签
go.terms.map=映射
go.terms.method=方法
go.terms.method.specification=方法规范
go.terms.module.statement=模块语句
go.terms.package=软件包
go.terms.package.capitalized=软件包
go.terms.package.statement=\ package 语句
go.terms.parameter=形参
go.terms.pointer=指针
go.terms.receiver=接收器
go.terms.semicolon=分号
go.terms.shadowed.declaration=隐藏的声明
go.terms.slice=切片
go.terms.statement=语句
go.terms.string=字符串
go.terms.struct=struct
go.terms.type=类型
go.terms.type.alias=类型别名
go.terms.type.parameters=类型形参
go.terms.type.pluralized=类型
go.terms.variable=变量
go.terms.version.statement=版本语句
go.test.cannot.find.files.compatible.with.framework.error=无法在与 <code>{1}</code> 框架兼容的 <code>{0}</code> 中找到 Go 测试文件
go.test.cannot.run.compiling.on.directory.kind.run.configurations.error=无法在类似目录的运行配置中调试测试。您可以使用<a href\="edit">测试种类\: 软件包</a>调试每个软件包的测试
go.test.creator.cannot.find.field.type=找不到 {0} 的字段类型
go.test.creator.cannot.find.function.signature=找不到函数签名
go.test.creator.cannot.find.method.receiver=找不到 {0} 的方法接收器
go.test.creator.cannot.find.method.receiver.type=找不到 {0} 的方法接收器类型
go.test.creator.cannot.find.test.import.path=找不到测试导入路径
go.test.creator.cannot.find.test.package.name=找不到测试软件包名称
go.test.creator.empty.test.file.name=空测试文件
go.test.creator.gotests.failed.to.create.test.file=无法创建测试文件 {0}
go.test.creator.gotests.generation.failed.notification.title=测试生成失败
go.test.creator.gotests.generation.name=测试生成
go.test.creator.gotests.no.tests.generated=未生成测试
go.test.creator.progress.title.searching.for.functions.for.test=正在搜索测试的函数…
go.test.creator.progress.title.searching.for.tests.for.function=正在搜索函数的测试…
go.test.creator.test.for.file.name=文件测试
go.test.creator.test.for.function.name=函数测试
go.test.creator.test.for.package.name=软件包测试
go.test.creator.test.for.selection.name=选区测试
go.test.file.does.not.exist.error=文件不存在\: {0}
go.test.framework.is.not.available.on.files.error=框架 <code>{0}</code> 在任何文件 <code>{1}</code> 上都不可用
go.test.framework.not.available.in.module.error=框架 <code>{0}</code> 在所选模块中不可用
go.test.fuzzing.duplicate.header=重复的头
go.test.fuzzing.header.expected=应为 'go test fuzz v1' 头
go.test.fuzzing.incorrect.header.position=标头必须在文件开头
go.test.fuzzing.label.corpus.label=Go fuzz 种子语料库
go.test.fuzzing.value.expected=应为至少一个值
go.test.generate.benchmark.text=基准
go.test.generate.example.text=示例
go.test.generate.function.description=生成 {0} 函数
go.test.generate.fuzz.text=模糊处理
go.test.generate.table.benchmark.description=生成表基准函数
go.test.generate.table.benchmark.text=表基准
go.test.generate.table.test.description=生成表测试函数
go.test.generate.table.test.text=表测试
go.test.generate.test.main.text=Test_main
go.test.generate.test.text=测试
go.test.no.tests.were.run=未运行任何测试
go.test.non.a.package.error=<code>{0}</code> 不是软件包。<br>使用目录类型运行配置，以在目录上递归运行测试。
go.test.not.go.file.error=文件 ''{0}'' 不是 Go 文件
go.test.run.configuration.description=Go 测试运行配置
go.test.run.configuration.name=Go 测试
go.test.run.fuzzing.tooltip=运行模糊处理
go.test.run.test.tooltip=运行测试
go.test.suggested.run.configuration.name={1} 中的 {0}
go.test.template.run.configuration.name=Go 测试
go.test.testify.run.configuration.name={1} 中的 {0}
go.test.testify.unknown.target.name=未知
go.test.testing.directory.does.not.exist.error=测试目录不存在
go.test.working.directory.should.be.ancestor.of.testing.directory.error=工作目录应当是该测试目录的上级
go.unknown.type.information.hint=<未知>
go.unwrap.argument=解包实参
go.unwrap.argument.description=解包 {0}
go.unwrap.else=解包 else
go.unwrap.for=解包 for
go.unwrap.if=解包 if
go.usage.type.call=调用
go.usage.type.const.declaration=常量声明
go.usage.type.field.declaration=字段声明
go.usage.type.function.argument=函数实参
go.usage.type.import=导入
go.usage.type.parameter.declaration=形参声明
go.usage.type.receiver=接收器
go.usage.type.return.type=返回值类型
go.usage.type.struct.initialization=结构体初始化
go.usage.type.type.alias=类型别名
go.usage.type.type.assertion=类型断言
go.usage.type.type.constraint=类型约束
go.usage.type.type.conversion=类型转换
go.usage.type.type.instantiation=类型实例化
go.usage.type.type.parameter.declaration=类型形参声明
go.usage.type.variable.declaration=变量声明
go.use.gopath.from.system.environment.checkbox=使用系统环境中定义的 GOPATH
go.value.cannot.be.represented.by.type={0} 的值不能由类型 {1} 表示
go.vim.plugin.suggestion.reason=建议使用此插件，因为您拥有 {0} 配置
go.wizard.description=创建 Go 项目以在 GOPATH 下开发应用程序或库
go.wizard.name=Go (GOPATH)
go.wsl.attach.host.group.name=WSL
go.wsl.resolving.user.home=正在 WSL 中解析用户主目录
go.wsl.sdk.unpack.error=解包命令失败，退出代码为 {0}
gofmt.conflict.notification.action.review.actions.on.save=保存时检查操作
gofmt.conflict.notification.content.gofmt.on.format.disabled.because.of.file.watcher=<code>gofmt</code> 工具将不会在<b>重新设置代码格式</b>操作期间运行，因为 <b>gofmt</b> File Watcher 处于有效状态。
group.DlvDebugger.ViewAsGroup.text=查看方式
group.GoTools.description=Go 外部工具
group.GoTools.text=Go 工具
inlay.go.inlays.display.constant.definition.description=解析常量定义的值。
inlay.parameters.go.return.parameters=在 return 语句中显示形参名称。
inlay.parameters.go.struct.unnamed.struct.fields=显示匿名字段的名称。
notification.group.build=Go 构建
notification.group.debug=Go 调试
notification.group.execution=Go 执行
notification.group.general=Go
notification.group.tools=Go 工具集成
notification.group.tools.sticky=Go 工具集成(重要)
postfix.template.condition.array.name=数组
postfix.template.condition.assignable.slice.name=可分配的切片
postfix.template.condition.boolean.name=布尔
postfix.template.condition.builtin.append.applicable.name=适用内置 append
postfix.template.condition.builtin.cap.applicable.name=适用内置 cap
postfix.template.condition.builtin.len.applicable.name=适用内置 len
postfix.template.condition.channel.name=通道
postfix.template.condition.comparable.to.nil.name=与 nil 相当
postfix.template.condition.error.expr.result.name=表达式包含错误结果
postfix.template.condition.error.name=错误
postfix.template.condition.expr.in.if.with.missing.block.name=缺少块的 if 条件中的表达式
postfix.template.condition.floats.slice.name=float64s 的切片
postfix.template.condition.interface.impls.slice.name=排序接口实现的切片
postfix.template.condition.ints.slice.name=int 的切片
postfix.template.condition.map.name=映射
postfix.template.condition.non.void.name=非 void
postfix.template.condition.number.name=数字
postfix.template.condition.slice.name=切片
postfix.template.condition.slice.with.no.sort.name=没有专用排序函数的切片
postfix.template.condition.string.name=字符串
postfix.template.condition.strings.slice.name=字符串切片
postfix.template.provider.name=Go
project.files.and.vendor.scope.name=项目文件和供应商
vgo.edit.system.go.environment.dialog.title=全局 Go 环境
vgo.fix.delete.replacement=删除替换
vgo.fix.dependency-deprecated.family-name=显示弃用通知
vgo.fix.dependency-deprecated.message=显示 {0} 弃用通知
vgo.fix.dependency-update.family-name=更新依赖项版本
vgo.fix.dependency-update.single.message=更新到最新版本 {0}
vgo.fix.dependency-version-retracted.family-name=显示撤回通知
vgo.fix.dependency-version-retracted.message=显示 {0} 撤回通知
vgo.fix.merge.require.directives.family.name=按依赖项类型合并 'require' 指令
vgo.inspection.dependency-deprecated-retracted.option.deprecation-notice=弃用通知
vgo.inspection.dependency-deprecated-retracted.option.retraction-notice=撤回通知
vgo.inspection.dependency-deprecated-retracted.tooltip-template=<html><body>{0}。<p><span style\="color\:{3}">{1}\:</span> {2}</body></html>
vgo.inspection.dependency-deprecated.display-name=已弃用的依赖项
vgo.inspection.dependency-deprecated.message=已弃用的模块 {0}
vgo.inspection.dependency-update.display-name=有可用的依赖项更新
vgo.inspection.dependency-update.message={0}@{1} 有可用的新版本\: {2}
vgo.inspection.dependency-update.tooltip=有可用的新版本\: {0}
vgo.inspection.dependency-version-retracted.display-name=已撤回的依赖项版本
vgo.inspection.dependency-version-retracted.message=撤回的模块版本 {0}@{1}
vgo.inspection.dependency-version-retracted.tooltip=撤回的模块版本 {0}
vgo.inspection.go-list.group.name=依赖项问题(go list -m -u)
vgo.inspection.problem.multiple.require.directives.can.be.merged=多个 'require' 指令可以按依赖项类型分组合并
vgo.intention.add.all.replaced.modules.to.workspace.fix.text=将所有本地替换的模块添加到工作区
vgo.intention.add.module.to.workspace.fix.family.name=将模块添加到工作区
vgo.intention.add.module.to.workspace.fix.text=将 ''{0}'' 模块添加到工作区
vgo.intention.add.or.update.go.version.fix.family.name=在 'go.mod' 中添加或更新 Go 版本
vgo.intention.add.or.update.go.version.fix.text=在 ''go.mod'' 中将 Go 版本设置为 {0}
vgo.intention.dependency-update.aggregated.message=更新依赖项…
vgo.intention.dependency-update.aggregated.popup.title=更新依赖项…
vgo.intention.dependency-update.all.message=将所有依赖项更新为{0}版本
vgo.intention.dependency-update.direct.message=将直接依赖项更新为{0}版本
vgo.intention.dependency-update.option.latest=最新
vgo.intention.dependency-update.option.latest-patch=最新补丁
vgo.intention.merge.all.directives.name=合并所有指令
vgo.intention.merge.directive.up.name=合并指令
vgo.intention.merge.group.of.directives.name=合并一组指令
vgo.intention.merge.use.directives.family.name=将多个 'use' 指令合并为一个
vgo.intention.run.why.command.fix.family.name=运行 'go mod why -m'
vgo.intentions.category=Go 模块
vgo.intentions.create-datasource-from-go-package.tooltip=创建一个新数据源
vgo.intentions.datasource-from-go-package.name=从 Go 软件包创建数据源
vgo.intentions.existing-datasource-from-go-package.tooltip=导航到现有数据源
vgo.notification.goproxy.dismiss.action.text=关闭
vgo.notification.goproxy.is.needed.text=您所在区域可能需要 GOPROXY 才能正确集成 Go 模块
vgo.notification.goproxy.set.goproxy.cn.action.text=在全局范围内设置 goproxy.cn
vgo.notification.goproxy.setup.action.text=编辑 Go 环境
vgo.toolchain.checking.go.sdk.in.use.progress.title=正在检查使用中的 Go SDK
vgo.toolchain.edit.environment.variables.action=编辑环境变量
vgo.toolchain.open.mod.file.action=打开 'go.mod' 文件
vgo.toolchain.open.tool.versions.file.action=打开 '.tool-versions' 文件
vgo.toolchain.sdk.was.upgraded=Go SDK 已升级为 {0}
vgo.toolchain.upgrade.requested.by.go.mod='go.mod' 文件请求升级
vgo.toolchain.upgrade.requested.by.tool.versions='.tool-versions' 文件请求升级
vgo.toolchain.upgrade.requested.by.toolchain.variable=GOTOOLCHAIN 变量请求升级
vgo.traffic-light.go-list.progress=正在提取依赖项更新
vgo.update-service.command-presentation-name=正在提取 {0} 的依赖项更新
welcome.screen.files.scope.name=欢迎屏幕文件

action.DlvDebugger.ViewAsGroup.text=查看方式
action.DlvRewindAction.description=向后执行程序，直到到达上一个断点
action.DlvRewindAction.text=后退
action.DlvToggleThreadsAction.description=显示线程
action.DlvToggleThreadsAction.text=显示线程
action.DlvDumpAction.text=转储 Goroutine
action.MergeIdenticalStacktraces.text=合并相同的堆栈跟踪
action.HideGoroutine=隐藏 goroutine
action.HideSimilarGoroutines=隐藏具有相同堆栈的所有 goroutine
action.ResetHiddenAction.text=重置隐藏的 Goroutine
action.ResetHiddenAction.description=重置隐藏的 goroutine
action.FilterStacktraces.description=仅显示包含特定字符串的堆栈
action.FilterStacktraces.task.name=筛选堆栈
action.Go.NewGoFile.description=创建新 Go 文件
action.Go.NewGoFile.text=Go 文件
action.GoAddContentRootFromGopath.description=将所选目录添加到当前项目
action.GoAddContentRootFromGopath.text=将目录添加到当前项目中
action.GoCallHierarchyPopupMenu.BaseOnThisDeclaration.text=基于此声明
action.GoCoreDumpAction.text=打开核心转储…
action.GoFmtFileAction.description=使用 go fmt 工具格式化所选文件
action.GoFmtFileAction.text=Go Fmt 文件
action.GoFmtProjectAction.description=使用 go fmt 工具格式化项目
action.GoFmtProjectAction.text=Go Fmt 项目
action.GoGenerateConstructorAction.description=为结构生成构造函数
action.GoGenerateConstructorAction.text=构造函数
action.GoGenerateStructFieldsFromJsonAction.description=从 JSON 生成结构字段
action.GoGenerateStructFieldsFromJsonAction.text=JSON 中的结构字段
action.GoGenerateTypeFromJsonAction.description=从 JSON 生成类型
action.GoGenerateTypeFromJsonAction.text=JSON 中的类型
action.GoGenerateFileAction.description=在所选文件上运行 go generate
action.GoGenerateFileAction.text=Go Generate 文件
action.GoGenerateGetterAction.description=为字段生成 getter 方法
action.GoGenerateGetterAction.text=Getter
action.GoGenerateGetterSetterAction.description=为字段生成 getter 和 setter 方法
action.GoGenerateGetterSetterAction.text=Getter 和 Setter
action.GoGenerateSetterAction.description=为字段生成 setter 方法
action.GoGenerateSetterAction.text=Setter
action.GoIdeNewProjectAction.text=项目…
action.GoImportsFileAction.description=使用 goimports 工具优化所选文件的导入
action.GoImportsFileAction.text=Goimports 文件
action.GoOpenProjectFromGopath.description=作为项目打开所选目录
action.GoOpenProjectFromGopath.text=作为项目打开目录
action.GoRemoveContentRootAction.description=从当前项目中移除所选内容根目录
action.GoRemoveContentRootAction.text=分离目录…
action.GoReplayTraceAction.text=调试保存的跟踪…
action.GoVetFileAction.description=使用 go vet 工具对所选文件或目录执行 Lint 操作
action.GoVetFileAction.text=Go Vet 文件
action.Vgo.NewVgoFile.description=创建 Go 模块文件
action.Vgo.NewVgoFile.text=Go 模块文件
action.WelcomeScreen.CreateDirectoryProject.text=新建项目
action.com.goide.vgo.actions.VgoSyncAction.description=同步 go 模块
action.com.goide.vgo.actions.VgoSyncAction.text=同步 Go 模块
action.com.goide.vgo.actions.VgoTidyAction.description=在模块中运行 `go mod tidy`
action.com.goide.vgo.actions.VgoTidyAction.text=Go Mod Tidy
action.go.fill.paragraph=填充段落
action.GoShareInPlaygroundAction.text=在 Playground 中共享
action.GoShareInPlaygroundAction.description=在 Go Playground 中共享当前文件
action.GoShareInPlaygroundAction.error=无法在 Go Playground 中共享文件: {0}
action.GoShareInPlaygroundAction.empty.id=Playground 返回空 ID
action.GoShareInPlaygroundAction.confirmation=您是否希望将 {0} 上传到 Go Playground 并使之公开?
action.GoShareInPlaygroundAction.notification.text=Go Playground 中共享的文件: <a href="{0}">{0}</a>
action.GoShareInPlaygroundAction.notification.copyUrl=将 URL 复制到剪贴板
action.go.exclude.package.from.import.and.completion=从导入和补全中排除 ''{0}''
action.GoIntroduceTypeAction.text=引入类型…
go.app.engine.not.gae.sdk.validation.message=App Engine 仅支持 Go 1.11 及更高版本
go.app.engine.wizard.description=创建 Go App Engine 项目以开发使用 Google App Engine 的 Go 应用程序。<br/>新模块包括 Go 中的默认配置设置和基本处理程序。
go.app.engine.wizard.name=App Engine
go.modules.wizard.description=创建 Go 模块项目，以开发使用 Go 模块进行依赖项管理的 Go 应用程序和库
go.wizard.description=创建 Go 项目以在 GOPATH 下开发应用程序或库
go.dep.wizard.description=创建 Dep 项目，以开发使用 Dep 作为依赖项管理工具的 Go 应用程序
go.background.task.running.title=正在运行…
go.background.task.compiling.title=正在编译…
filetype.go.cgo.description=Cgo 文件
go.checkin.factory.fmt.commit.anyway.question=仍要提交吗?
go.checkin.factory.fmt.failed.message=GoFmt 在某些文件上返回了非零代码。
go.checkin.factory.fmt.not.started.message=无法运行 gofmt。{0}
go.colors.and.fonts.bad.character=错误字符
go.colors.and.fonts.braces.and.operators.braces=大括号
go.colors.and.fonts.braces.and.operators.brackets=中括号
go.colors.and.fonts.braces.and.operators.colon=冒号
go.colors.and.fonts.braces.and.operators.comma=逗号
go.colors.and.fonts.braces.and.operators.dot=点
go.colors.and.fonts.braces.and.operators.operator=运算符
go.colors.and.fonts.braces.and.operators.parentheses=括号
go.colors.and.fonts.braces.and.operators.semicolon=分号
go.colors.and.fonts.braces.and.operators=大括号和运算符
go.colors.and.fonts.comments.block.comment=块注释
go.colors.and.fonts.comments.comment.keyword=注释关键字
go.colors.and.fonts.comments.comment.reference=注释引用
go.colors.and.fonts.comments.line.comment=行注释
go.colors.and.fonts.comments=注释
go.colors.and.fonts.comments.build.constraints=构建约束
go.colors.and.fonts.comments.build.constraints.tag=标记
go.colors.and.fonts.comments.build.constraints.parens=圆括号
go.colors.and.fonts.comments.build.constraints.operators=运算符
go.colors.and.fonts.declarations.constants.builtin.constant=内置常量
go.colors.and.fonts.declarations.constants.local.constant=局部常量
go.colors.and.fonts.declarations.constants.package.exported.constant=软件包导出的常量
go.colors.and.fonts.declarations.constants.package.local.constant=软件包局部常量
go.colors.and.fonts.declarations.constants=常量
go.colors.and.fonts.declarations.function.parameter=函数形参
go.colors.and.fonts.declarations.functions.builtin.function=内置函数
go.colors.and.fonts.declarations.functions.exported.function=导出的函数
go.colors.and.fonts.declarations.functions.package.local.function=软件包本地函数
go.colors.and.fonts.declarations.functions=函数
go.colors.and.fonts.declarations.label=标签
go.colors.and.fonts.declarations.method.receiver=方法接收器
go.colors.and.fonts.declarations.package=软件包
go.colors.and.fonts.declarations.types.package.exported.interface=软件包导出的接口
go.colors.and.fonts.declarations.types.package.exported.struct=软件包导出的结构
go.colors.and.fonts.declarations.types.package.local.interface=软件包本地接口
go.colors.and.fonts.declarations.types.package.local.struct=软件包本地结构
go.colors.and.fonts.declarations.types.type.specification=类型规范
go.colors.and.fonts.declarations.types=类型
go.colors.and.fonts.declarations.variables.builtin.variable=内置变量
go.colors.and.fonts.declarations.variables.local.variable=局部变量
go.colors.and.fonts.declarations.variables.package.exported.variable=软件包导出的变量
go.colors.and.fonts.declarations.variables.package.local.variable=软件包局部变量
go.colors.and.fonts.declarations.variables.reassignment.in.short.variable.declaration=短变量声明中的重新赋值
go.colors.and.fonts.declarations.variables.scope.declared.variable=范围声明变量
go.colors.and.fonts.declarations.variables.shadowing.variable=阴影变量
go.colors.and.fonts.declarations.variables.struct.exported.member=结构导出的成员
go.colors.and.fonts.declarations.variables.struct.local.member=结构本地成员
go.colors.and.fonts.declarations.variables=变量
go.colors.and.fonts.declarations=声明
go.colors.and.fonts.identifier=标识符
go.colors.and.fonts.keyword=关键字
go.colors.and.fonts.number=数字
go.colors.and.fonts.references.function.calls.builtin.function.call=内置函数调用
go.colors.and.fonts.references.function.calls.exported.function.call=导出的函数调用
go.colors.and.fonts.references.function.calls.local.function.call=局部函数调用
go.colors.and.fonts.references.function.calls=函数调用
go.colors.and.fonts.references.type.references.builtin.type.reference=内置类型引用
go.colors.and.fonts.references.type.references.package.exported.interface=软件包导出的接口
go.colors.and.fonts.references.type.references.package.exported.struct=软件包导出的结构
go.colors.and.fonts.references.type.references.package.local.interface=软件包本地接口
go.colors.and.fonts.references.type.references.package.local.struct=软件包本地结构
go.colors.and.fonts.references.type.references.type.specification=类型规范
go.colors.and.fonts.references.type.references=类型引用
go.colors.and.fonts.references.variable.calls.exported.variable.call=导出的变量调用
go.colors.and.fonts.references.variable.calls.local.variable.call=局部变量调用
go.colors.and.fonts.references.variable.calls.package.local.variable.call=软件包局部变量调用
go.colors.and.fonts.references.variable.calls.struct.exported.member.call=结构导出的成员调用
go.colors.and.fonts.references.variable.calls.struct.local.member.call=结构本地成员调用
go.colors.and.fonts.references.variable.calls=变量调用
go.colors.and.fonts.references=引用
go.colors.and.fonts.string.invalid.escape=无效的转义
go.colors.and.fonts.string.text=文本
go.colors.and.fonts.string.valid.escape=有效的转义
go.colors.and.fonts.string=字符串
go.colors.and.fonts.declarations.struct.tags=结构标记
go.colors.and.fonts.declarations.struct.tags.key=键
go.colors.and.fonts.declarations.struct.tags.colon=冒号
go.colors.and.fonts.declarations.struct.tags.value=值
go.colors.and.fonts.declarations.struct.tags.arbitraryText=任意文本
go.completion.insert.if.not.nil.statement.command.name=插入 ''if value != nil {...}'' 语句
go.completion.insert.literal.command.name=插入 Go 文字
go.completion.insert.type.name.command.name=插入类型名称
go.completion.method.like.completion.advertisement=按 {0} 查看将表达式作为第一个实参的函数
go.completion.method.like.completion.command.name=函数的方法式补全
go.core.dump.dialog.dump.path.label=核心转储(&C):
go.core.dump.dialog.executable.label=可执行文件(&E):
go.core.dump.dialog.invalid.core.dump.validation.message=该文件不是有效的核心转储
go.core.dump.dialog.invalid.executable.validation.message=该文件不是可执行文件
go.core.dump.dialog.specify.core.dump.validation.message=指定核心转储
go.core.dump.dialog.specify.executable.validation.message=指定可执行文件
go.core.dump.failed.to.start.error.message=无法为核心转储 {0} 启动调试器: {1}
go.core.dump.session.name=核心转储 {0}
go.create.new.file.action.command.name=创建 Go 文件 {0}
go.create.new.file.action.name=Go 文件
go.create.new.file.dialog.title=新建 Go 文件
go.create.new.file.empty.file.kind.name=空文件
go.create.new.file.simple.application.kind.name=简单应用程序
go.debug.show.goroutines.action.name=显示 Goroutine
go.debug.show.threads.action.name=显示线程
go.declarations.intentions.category=Go/声明
go.dep.checking.dep.projects.task.name=检查 Dep 项目
go.dep.enable.integration.checkbox=启用 dep 集成
go.edit.auto.import.settings.action.name=编辑自动导入设置
go.auto.import.and.completion.title=自动导入和补全
go.auto.import.and.completion.add.exclude.label=输入要从自动导入和补全中排除的导入路径:
go.element.is.not.go.expression.error.hint=选区不包含 Go 表达式
go.exclude.import.path.dialog.empty.path.validation.message=导入路径不能为空
go.exclude.import.path.dialog.title=排除导入路径
go.exclude.import.path.from.completion.action.name=排除 ''{0}''
filetype.go.description=Go 文件
go.fix.searching.for.usages.progress.title=正在搜索用法…
go.fix.change.parameters.parameter={0,choice,0#形参|1#形参|2#形参}
go.fix.add.missing.new.line.name=添加缺少的新行
go.fix.add.comma.name=添加逗号
go.fix.add.whitespace.name=添加空格
go.fix.add.import.for.side.effects.name=副作用导入
go.fix.add.prefix.to.comment.name=向注释中添加 ''{0}'' 前缀
go.fix.add.return.statement.name=添加 return 语句
go.fix.change.import.sorting.settings.name=更改导入排序设置
go.fix.change.result.parameters.result.parameter={0,choice,0#结果形参|1#结果形参|2#结果形参}
go.fix.create.directory.text=在 {1} 处创建目录{0}
go.fix.change.parameters.name=更改形参
go.fix.change.result.parameters.in.assignment.name=更改赋值中的结果形参
go.fix.change.result.parameters.in.call.name=更改调用中的结果形参
go.fix.change.result.parameters.in.return.name=更改返回中的结果形参
go.fix.change.result.parameters.in.variable.specification.name=更改变量规范中的结果形参
go.fix.change.result.parameters.name=更改结果形参
go.fix.change.signature.from.function.type.name=从函数类型更改签名
go.fix.change.signature.from.usage.text=从用法更改签名
go.fix.change.signature.from.function.type.text=将{0} ''{1}'' 的签名更改为 ({2}) ({3})
go.fix.change.signature.from.usage.add=将 ''{0}'' 作为第 {1,number,ordinal} 个{2}添加到{3} ''{4}'' 中
go.fix.change.signature.from.usage.remove=从{2} ''{3}'' 中移除第 {0,number,ordinal} 个{1}
go.fix.change.signature.from.usage.change=将{2} ''{3}'' 的第 {0,number,ordinal} 个{1}从 ''{4}'' 更改为 ''{5}''
go.fix.change.signature.from.usage.mix=将{1} ''{2}'' 的{0}更改为 ({3})
go.fix.convert.to.is.equal.name=转换为 '=='
go.fix.delete.name=删除 {0}
go.fix.delete.text=删除{0} ''{1}''
go.fix.delete.range.name=删除元素
go.fix.delete.third.index.name=删除第三索引
go.fix.delete.blank.argument.name=删除空白实参
go.fix.export.name=导出
go.fix.export.field.name=导出字段
go.fix.replace.tilda.with.hat.name=将 '~' 替换为 '^'
go.fix.replace.assign.with.equals.name=将 ':=' 替换为 '='
go.fix.replace.equals.with.assign.name=替换为 ':='
go.fix.replace.with.nil.with.side.effects.name=替换为 nil (更改语义)
go.fix.replace.with.correct.defer.name=替换为正确的 defer 结构
go.fix.add.function.call.name=添加函数调用
go.fix.delete.redundant.index.name=删除冗余索引
go.fix.delete.conversion.name=删除转换
go.fix.delete.conversion.with.side.effects.name=删除转换(可能改变语义)
go.fix.disable.vendoring.in.module.text=在模块 ''{0}'' 中禁用 vendoring 试验支持
go.fix.disable.vendoring.in.module.name=在模块中禁用 vendoring 试验支持
go.fix.drop.suffix.text=删除特定于单元的后缀 ''{0}''
go.fix.drop.suffix.name=删除特定于单元的后缀
go.fix.multiple.packages.name=重命名软件包
go.fix.multiple.packages.text=将软件包重命名为 {0}
go.fix.choose.package.name=选择软件包名称
go.fix.simplify.bool.expr.name=简化表达式
go.fix.failed.to.simplify.if.statement=无法简化 'if' 语句
go.fix.view.all.duplicates.name=查看重复的名称
go.fix.view.all.duplicates.text=查看 ''{0}'' 的重复名称
go.fix.view.all.duplicates.targets.tab.text=''{0}'' 的重复项
go.fix.view.all.duplicates.targets.tool.window.title={1} 中的 {0}
go.fix.view.all.duplicates.targets.code.usages.string=已找到重复项
go.fix.add.function.block.name=添加正文
go.fix.add.keys.to.struct.literal.value.name=添加键并删除零值
go.fix.add.local.var.for.expression.name=引入局部变量
go.fix.add.missing.return.value.name=添加缺少的返回值
go.fix.add.pointer.name=添加指针
go.fix.add.explicit.dereference.name=添加显式取消引用
go.fix.always.false.if.name=移除 'if' 分支
go.fix.always.true.if.name=移除其他分支并简化当前的 'if'
go.fix.convert.int.to.string.using.conversion.call=使用 {0} 调用将整数转换为字符串
go.fix.convert.string.to.byte.name=将字符串转换为字节
go.fix.convert.to.expected.type.name=转换为
go.fix.convert.to.expected.type.text=转换为 ''{0}''
go.fix.create.wrapper.type.name=创建类型
go.fix.delete.all.unused.parameters.name=删除所有未使用的形参
go.fix.delete.ampersand.and.type.in.composite.lit.name=删除冗余类型
go.fix.delete.extra.expressions.name=删除多余的表达式
go.fix.delete.import.name=删除导入
go.fix.delete.parameter.names.name=删除形参名称
go.fix.delete.unused.parameter.name=删除未使用的形参
go.fix.empty.signature.name=修复签名
go.fix.exclude.from.unhandled.inspection.name=不再报告此方法/函数
go.fix.extract.empty.slice.to.var.declaration.name=替换为零切片声明(更改语义)
go.fix.extract.to.own.declaration.name=提取到自己的声明
go.fix.finish.call.name=完成调用表达式
go.fix.ignore.explicitly.name=显式忽略
go.fix.ignore.explicitly.using.closure.name=使用闭包显式忽略
go.fix.handle.error.name=处理错误
go.fix.ignore.unused.call.result.name=忽略未使用的调用结果
go.fix.implement.missing.methods.name=实现缺少的方法
go.fix.insert.blank.identifiers.name=将空白标识符插入赋值语句的左侧
go.fix.navigate.to.name=导航到
go.fix.navigate.to.text=导航到 {0}
go.fix.optimize.imports.name=优化 import
go.fix.place.build.tag.before.package.name=在软件包前面放置构建标记
go.fix.remove.redundant.bool.literal.name=简化为
go.fix.replace.with.name=替换为
go.fix.replace.with.text=替换为 ''{0}''
go.fix.rename.to.name=重命名为
go.fix.rename.to.text=重命名为 ''{0}''
go.fix.rename.all.receivers.name=重命名所有接收器
go.fix.rename.all.receivers.text=重命名所有接收器为 ''{0}'' 
go.fix.replace.expression.name=预置 '\\&'
go.fix.signature.name=修复签名
go.fix.sort.imports=import 排序
go.fix.simplify.expression.to.boolean.literal.name=简化条件
go.fix.simplify.to.text=简化为 ''{0}''
go.fix.simplify.something.to.text=将 ''{0}'' 简化为 ''{1}''
go.fix.suppress.inspection.for.text=对{0}禁止
go.fix.suppress.all.inspections.for.text=禁止{0}的所有检查
go.fix.unwrap.parens.name=取消换行括号
go.fix.convert.to.format.function.name=更改为格式设置函数
go.fix.convert.to.format.function.text=更改 ''{0}'' 为格式设置函数
go.fix.introduce.local.variable.for.expression=引入 ''{0}'' 的局部变量
go.fix.introduce.method.name=创建方法
go.fix.introduce.method.text=创建方法 ''{0}''
go.fix.introduce.function.name=创建函数
go.fix.introduce.function.text=创建函数 ''{0}''
go.fix.field.with.the.same.tag=包含相同 ''{1}'' 标签的字段 ''{0}''
go.fix.field.repeats.tag.with.value=字段 ''{0}'' 重复 ''{3}'' 字段中值为 ''{2}'' 的 ''{1}'' 标签
go.fix.convert.int.to.rune=将整数转换为 rune
go.fix.unpack.slice.name=解压缩切片
go.fix.enable.gopath.indexing.name=启用 GOPATH 索引
go.get.package.fix.family.name=运行 'go get'
go.use.gopath.from.system.environment.checkbox=使用系统环境中定义的 GOPATH
go.index.entire.gopath.checkbox=为整个 GOPATH 编制索引
go.index.entire.gopath.tooltip=禁用时，将仅对项目和 vendor 软件包编制索引。<br/>这样可以提升整体性能，但无法使用 GOPATH 中的包。
go.libraries.configurable.path.source.prefix.default=[默认]
go.libraries.configurable.path.source.prefix.gopath=[GOPATH]
go.inspection.assignment.nil.without.explicit.type.message=如果没有显式类型，则无法分配 nil
go.inspection.assignment.to.receiver.display.name=赋值给接收器
go.inspection.bool.condition.display.name=布尔型条件
go.inspection.comment.has.no.leading.space.display.name=注释没有前导空格
go.inspection.comment.of.exported.element.starts.with.incorrect.name.display.name=导出的元素的注释以不正确的名称开头
go.inspection.comment.should.have.package.prefix.message=软件包注释应采用 ''Package {0} ...'' 的形式
go.inspection.comment.should.be.without.article.message=注释格式应为 ''{0} ...'' (有可选的前导条目)
go.inspection.comment.should.be.meaningful.message=注释应有意义，否则应当移除
go.inspection.defer.go.statement.calls.recover.or.panic.directly.display.name=Defer/go 语句直接调用 'recover' 或 'panic'
go.inspection.defer.or.go.should.not.call.function.message={0} 不应直接调用 {1}
go.inspection.defer.in.loop.display.name=循环中的 'defer'
go.inspection.deprecated.element.display.name=弃用的元素
go.inspection.division.by.zero.display.name=除以零
go.inspection.empty.declaration.display.name=空声明
go.inspection.empty.declaration.message=声明 {0} 为空
go.inspection.empty.slice.declared.via.literal.display.name=使用文字声明的空切片
go.inspection.error.string.should.not.be.capitalized.or.end.with.punctuation.display.name=错误字符串不应大写或以标点结尾
go.inspection.exceeded.shift.expression.display.name=已超出 shift 表达式
go.inspection.explicit.dereference.calling.method.with.receiver.message=包含接收器 {1}(类型为 {2})的调用方法 {0} 需要显式取消引用
go.inspection.explicit.dereference.accessing.field.message=访问 {1}(类型为 {2})的字段 {0} 需要显式取消引用
go.inspection.exported.element.should.have.comment.display.name=导出的元素应有注释
go.inspection.exported.element.should.have.its.own.declaration.display.name=导出的元素应有自己的声明
go.inspection.extended.method.expression.syntax.before.go.1.10.message=意外的接收器类型，自 Go 1.10 起可以使用扩展的方法表达式语法
go.inspection.imported.package.name.as.name.identifier.display.name=软件包名称作为名称标识符导入
go.inspection.impossible.interface.type.assertion=不可能的接口类型断言
go.inspection.incorrect.strings.replace.count.argument.display.name=不正确的 'strings.Replace' 计数实参
go.inspection.incorrect.usage.of.printf.display.name=不正确的 'fmt.Printf' 和 'fmt.Println' 函数用法
go.inspection.incorrect.usage.of.the.errors.as.function.display.name=不正确的 'errors.As' 函数用法
go.inspection.incorrect.usage.of.the.sync.atomic.display.name=不正确的 'sync/atomic' 软件包用法
go.inspection.locks.mistakenly.passed.by.value=锁通过值错误传递
go.inspection.possible.misuse.of.unsafe.pointer=可能滥用 {0}
go.inspection.invalid.conversions.of.uintptr.to.unsafe.Pointer=无效的 'uintptr' 到 'unsafe.Pointer' 转换
go.inspection.infinite.for.loop.display.name=无限的 'for' 循环
go.inspection.problem.cannot.take.address=无法提取 {0} 的地址
go.inspection.problem.invalid.indirect={0} (类型 {1})的间接引用无效
go.inspection.int.to.string.conversion=整数转换为字符串类型
go.inspection.lost.cancel='context.CancelFunc' 未被调用
go.inspection.loop.closure.display.name=函数文字捕获的循环变量
go.inspection.loop.closure.message=由 <code>{0}</code> 语句中的 <code>func</code> 文字捕获的循环变量可能有意外值
go.inspection.malformed.build.tag.display.name=构建标记的格式错误
go.inspection.malformed.struct.tag.display.name=结构标记的格式错误
go.inspection.missing.trailing.comma.before.newline.in.composite.literal.display.name=复合文字中的换行符前缺少尾随逗号
go.inspection.name.starts.with.package.name.display.name=名称以软件包名称开头
go.inspection.nilness.analyzer.display.name=为零性分析器
go.inspection.non-standard.signature.for.well.known.function.names.display.name=已知函数名称采用非标准签名
go.inspection.receiver.has.generic.name.display.name=接收器具有泛型名称
go.inspection.redundant.blank.argument.in.range.display.name=范围中存在冗余空白实参
go.inspection.redundant.comma.display.name=冗余逗号
go.inspection.redundant.import.alias.display.name=冗余导入别名
go.inspection.redundant.parentheses.display.name=冗余括号
go.inspection.redundant.second.index.in.slices.display.name=切片中存在冗余的第二个索引
go.inspection.redundant.semicolon.display.name=冗余分号
go.inspection.redundant.type.conversion.display.name=冗余类型转换
go.inspection.redundant.types.in.composite.literals.display.name=复合文字中存在冗余类型
go.inspection.reserved.word.used.as.name.display.name=保留词用作名称
go.inspection.self.assignment.display.name=自赋值
go.inspection.shadowing.variable.display.name=阴影变量
go.inspection.struct.initialization.without.field.names.display.name=结构初始化没有字段名称
go.inspection.struct.initialization.settings.report.for.local.type.checkbox=报告当前软件包中定义的类型
go.inspection.struct.initialization.settings.report.for.literals.without.type.checkbox=报告无类型的结构文字
go.inspection.struct.field.has.tag.but.is.not.exported=结构字段 ''{0}'' 具有 ''{1}'' 标记，但未被导出
go.inspection.type.can.be.omitted.display.name=类型可以省略
go.inspection.type.can.be.omitted.message=类型可以省略
go.inspection.unexported.return.type.of.exported.function.display.name=导出函数的未导出返回类型
go.inspection.unhandled.error.display.name=未处理错误
go.inspection.unit.specific.suffix.for.time.duration.display.name=为 'time.Duration' 使用单位特定的后缀
go.inspection.unnecessarily.exported.identifier.display.name=不必要地导出了标识符
go.inspection.unreachable.code.display.name=不可到达的代码
go.inspection.unknown.field.message=结构文字中的字段 {0} 未知
go.inspection.ambiguous.reference.message=不明确的引用 {0}
go.inspection.unresolved.reference.message=未解析的引用 {0}
go.inspection.unresolved.type.message=未解析的类型 {0}
go.inspection.unresolved.label.message=未解析的标签 {0}
go.inspection.unresolved.disabled.gopath.indexing.display.name=已禁用 GOPATH 索引
go.inspection.unresolved.disabled.gopath.indexing.message=禁用 GOPATH 索引可能会阻止正确进行引用解析
go.inspection.unsorted.imports.display.name=未排序的导入
go.inspection.unused.constant.display.name=未使用的常量
go.inspection.unused.constant.message=未使用的常量 {0}
go.inspection.unused.exported.function.display.name=未使用的导出函数
go.inspection.unused.function.message=未使用的函数 {0}
go.inspection.unused.label.message=未使用的标签 {0}
go.inspection.unused.exported.type.display.name=未使用的导出类型
go.inspection.unused.function.display.name=未使用的函数
go.inspection.unused.function.or.method.call.result.display.name=未使用的函数或方法调用结果
go.inspection.unused.global.variable.display.name=未使用的全局变量
go.inspection.unused.parameter.display.name=未使用的形参
go.inspection.unused.parameter.message=未使用的形参 {0}
go.inspection.unused.type.display.name=未使用的类型
go.inspection.unused.type.message=未使用的类型 {0}
go.inspection.unused.variable.message=未使用的变量 {0}
go.inspection.usage.of.snake.case.display.name=使用了 Snake_Case(_C)
go.inspection.incorrect.call.to.unmarshal.display.name=使用错误的实参调用了 'Unmarshal'
go.inspection.struct.tag.value.consists.only.of.spaces=结构标签值仅包含空格
go.inspection.suspicious.space.in.the.beginning.of.the.struct.tag.value=结构标签值开头有可疑的空格
go.inspection.suspicious.space.in.the.end.of.the.struct.tag.value=结构标记值末尾的可疑空格
go.inspection.suspicious.extra.space.in.struct.tag.value=结构标记值中的可疑额外空格
go.inspection.suspicious.space.in.struct.tag.value=结构标记值中的可疑空格
go.inspection.missing.closing.double.quote.character.in.value=值中缺少右双引号字符
go.inspection.expected.opening.double.quote.character.after.colon=':' 后面应为左双引号字符
go.inspection.expected.colon.after.key=键后面应为 ':'
go.inspection.key.is.empty.or.starts.from.incorrect.symbol=键为空或者以不正确的符号开头
go.inspection.key.is.not.separated.by.space.from.previous.pair=键与上一对没有用空格分隔
go.inspection.test.name.display.name=格式错误的测试函数名称
go.inspection.problem.malformed.test.name=测试名称格式错误: 'Test' 后面的首个字母不得为小写
go.inspection.problem.malformed.benchmark.name=基准名称格式错误: 'Benchmark' 后面的首个字母不得为小写
go.inspection.problem.malformed.example.suffix=示例名称格式错误: 后缀 {0} 必须以小写字母开头
go.inspection.problem.example.for.unknown.identifier=示例引用未知标识符: {0}
go.inspection.problem.example.for.unknown.field.or.method=示例引用未知字段或方法:{0}。{1}
go.intention.add.declaration.parens.name=向声明添加圆括号
go.intention.add.dot.import.alias.name=添加点导入别名
go.intention.add.fmt.string.argument.name=添加格式字符串实参
go.intention.add.import.alias.name=添加导入别名
go.intention.convert.to.short.var.declaration.name=转换为短变量声明
go.intention.convert.to.var.declaration.name=转换为变量声明
go.intention.create.field.getter.and.setter.name=生成 getter 和 setter
go.intention.create.field.getter.and.setter.command.name=创建字段访问器
go.intention.create.field.getter.name=创建 Getter
go.intention.create.field.setter.name=创建 Setter
go.intention.expand.signature.types.name=展开签名类型
go.intention.export.name=导出
go.intention.fill.all.fields.name=填充所有字段
go.intention.fill.all.fields.recursively.checkbox=递归
go.intention.fill.all.fields.enforce.multiline.checkbox=执行多行
go.intention.fill.all.fields.command.name=填充结构
go.intention.fill.all.fields.recursively.name=递归填充所有字段
go.intention.fill.fields.name=填充字段…
go.intention.flip.binary.operator.changes.operator.text=将 ''{0}'' 翻转为 ''{1}''
go.intention.flip.binary.operator.changes.semantics.text=翻转 ''{0}'' (更改语义)
go.intention.flip.binary.operator.name=翻转二元运算符
go.intention.flip.binary.operator.text=翻转 ''{0}''
go.intention.fmt.string.argument.bad.position.error.message=位置错误
go.intention.fmt.string.argument.explicit.indices.error.message=字符串具有显式索引
go.intention.fmt.string.argument.percent.with.args.error.message=字符串具有带实参的 %%
go.intention.fmt.string.argument.syntax.error.message=字符串有语法错误
go.intention.fmt.string.argument.too.few.arguments.error.message=字符串的实参太少
go.intention.fmt.string.argument.variadic.arg.error.message=字符串具有 ... 实参
go.intention.fmt.string.title.error.message=无法添加 Fmt 字符串实参
go.intention.generate.constructor.name=创建构造函数
go.intention.go.to.implementation.name=转到实现
go.intention.go.to.implementation.text=转到实现…
go.intention.go.to.super.name=转到接口
go.intention.go.to.super.text=转到接口…
go.intention.implement.interface.name=实现接口
go.intention.implement.interface.text=实现接口…
go.intention.invert.if.name=反转 if
go.intention.merge.all.declarations.name=合并所有声明
go.intention.merge.declaration.up.name=向上合并声明
go.intention.merge.declarations.by.comma.name=通过逗号向上合并声明
go.intention.move.to.struct.initialization.name=将字段赋值移动到结构初始化
go.intention.negate.boolean.expression.name.recursively.suffix=递归
go.intention.negate.boolean.expression.name=求反表达式
go.intention.negate.boolean.expression.text=将 ''{0}'' 求反为 ''{1}''
go.intention.negate.boolean.topmost.expression.name=求反最顶端的表达式
go.intention.negate.boolean.topmost.expression.text=将最顶端的 ''{0}'' 求反为 ''{1}''
go.intention.remove.declaration.parens.name=从声明中移除圆括号
go.intention.remove.dot.import.alias.name=移除点导入别名
go.intention.remove.keys.from.struct.literal.value.name=从结构文本中移除键
go.intention.reuse.signature.types.name=重用签名类型
go.intention.run.go.generate.name=在注释上运行 go generate
go.intention.run.go.generate.on.file.name=在文件上运行 go generate
go.intention.run.go.generate.on.package.name=在软件包上运行 go generate
go.intention.run.go.generate.text=Go generate ''{0}''
go.intention.select.fields.dialog.title=选择字段
go.intention.specify.type.name=明确地指定类型
go.intention.split.all.declarations.name=拆分所有声明
go.intention.split.declarations.by.comma.name=通过逗号拆分声明
go.intention.split.declarations.name=将声明拆分为两个组
go.intention.chop.arguments=将实参放在单独的行中
go.intention.chop.parameters=将形参放在单独的行中
go.intention.chop.composite.literal.elements=将元素放在单独的行中
go.intention.join.arguments=将实参放在同一行中
go.intention.join.parameters=将形参放在同一行中
go.intention.join.composite.literal.elements=将元素放在同一行中
go.intention.add.tag.key=向标记添加键
go.intention.change.field.name.style.in.tags=更改标记中的字段名称样式
go.intention.change.field.name.style.select.style=选择字段名称样式:
go.intention.change.field.name.style.command=更改标记中的字段名称样式
go.intention.update.value.in.tags=更新标记中的键值
go.intention.generate.type.from.json=从 JSON 生成类型
go.intention.generate.struct.fields.from.json=从 JSON 生成结构字段
go.intention.generate.struct.fields.from.json.error=JSON 顶层值应当是对象或对象数组
go.intention.download.all.missing.modules.fix.text=将所有模块下载到模块缓存
go.intention.download.single.missing.module.fix.family.name=将模块下载到模块缓存
go.intention.download.single.missing.module.fix.text=将{0}下载到模块缓存
go.intention.download.single.missing.module.fix.from.replacement.text=将 {0} 从 {1} 下载到模块缓存
go.generate.type.from.json.dialog.title=从 JSON 生成 Go 类型
go.generate.type.from.json.dialog.json.label=将 JSON 放置在此处:
go.generate.type.from.json.dialog.ok.label=生成
go.generate.type.from.json.error.invalid.json=无法从无效的 JSON 生成 go 类型
go.generate.type.from.json.error.no.top.value=JSON 应有一个顶层值
go.generate.type.from.json.on.paste.dialog.title=从 JSON 生成 Go 类型
go.generate.type.from.json.on.paste.type.message=插入的文本似乎是 JSON。您是否希望从它生成 Go 类型?
go.generate.type.from.json.properties.on.paste.type.message=插入的文本似乎是一系列 JSON 属性。您是否希望从它生成 Go 类型?
go.generate.type.from.json.on.paste.struct.fields.message=插入的文本似乎是 JSON。您是否希望从它生成结构字段?
go.generate.type.from.json.properties.on.paste.struct.fields.message=插入的文本似乎是一系列 JSON 属性。您是否希望从它生成结构字段?
go.completion.generate.struct.fields.from.json=从 JSON 生成结构字段…
go.completion.add.tag.key.to.all.fields=向所有字段添加标记键…
go.intentions.category=Go
go.macro.bin.dirs.description=包含 Go 工具的 bin 目录路径
go.macro.executable.path.description=Go 可执行文件路径
go.macro.file.import.path.description=导入当前文件的路径
go.macro.file.go.path.description=GOPATH 值
go.macro.file.go.root.description=项目 SDK 路径
go.mozilla.rr.dialog.specify.trace.directory.validation.message=指定跟踪目录
go.mozilla.rr.dialog.trace.directory.label=跟踪目录(&T):
go.mozilla.rr.failed.to.start.error.message=无法为 rr 跟踪 {0} 启动调试器: {1}
go.mozilla.rr.session.name=跟踪 {0}
go.navigation.progress.title=正在搜索 {0}…
go.navigation.shadowed.method.usages.title={0} 的隐藏方法
go.navigation.go.to.shadowed.method.popup.title=方法 {0} 隐藏了 {1} 个{1,choice,0#类型|1#类型|2#类型}的方法
go.navigation.go.to.shadowed.method=转到阴影方法
go.navigation.go.to.super.method.popup.title=方法 {0} 实现了 {1} 个{1,choice,0#接口|1#接口|2#接口}中的方法
go.navigation.go.to.super.method.find.usages.title.kind={0} 已实现的方法规范
go.navigation.go.to.super.method=转到方法规范
go.navigation.go.to.super.popup.title=类型 {0} 实现了 {1} 个{1,choice,0#接口|1#接口|2#接口}
go.navigation.go.to.super.find.usages.title={0} 已实现的接口
go.navigation.go.to.super=转到接口
go.navigation.go.to.type.implementation.popup.title={1} {1, choice, 0#类型|1#类型|2#类型}中实现的类型 {0}
go.navigation.go.to.method.implementation.popup.title={1} {1, choice, 0#类型|1#类型|2#类型}中实现的方法 {0}
go.navigation.go.to.implementation.find.usages.title={0} 的实现
go.navigation.go.to.implementation=转到实现
go.navigation.go.to.shadowing.method.popup.title={1} {1, choice, 0#类型|1#类型|2#类型}中隐藏的方法 {0}
go.navigation.go.to.shadowing.method.find.usages.title={0} 的隐藏方法
go.navigation.go.to.shadowing.method=转到隐藏方法
go.navigation.recursive.call=递归调用
go.notification.dep.project.out.of.sync.text=Dep 项目 {0} 不同步。
go.notification.gokpg.toml.modified.text=修改了 {0} 的 Gopkg.toml。
go.notification.go.edit.project.settings.action.text=编辑设置
go.notification.go.support.is.disabled.in.module.text=''{0}'' 中禁用 Go 支持
go.notification.go.support.enable.action.text=启用 Go 支持
go.notification.go.setup.action.text=设置 GOROOT
go.notification.gopath.is.empty.text=GOPATH 为空
go.notification.gopath.configure.action.text=配置 GOPATH
go.notification.gopath.detected.title=检测到 GOPATH
go.notification.gopath.detected.text=我们从您的 GOPATH 中检测到一些库。您可能需要在 GOPATH 配置中添加额外的库。
go.notification.gopath.detected.configure.gopath.action.text=配置 GOPATH
go.notification.vendoring.detected.title=检测到 Vendoring 用法
go.notification.vendoring.detected.text=<strong>vendor</strong> 目录通常意味着项目使用 Go Vendor Experiment。选定的 Go SDK 版本支持 vendoring，但默认为禁用。您可以在项目设置中显式启用 Go Vendor Experiment。
go.notification.vendoring.detected.configure.go.vendor.experiment.action.text=配置 Go Vendor Experiment
go.notification.go.tool.is.missing.text=GOPATH 中缺少可执行文件 ''{0}''。您要安装吗?
go.notification.go.tool.is.missing.run.go.get.text=无法在 GOPATH 中找到 ''{0}''。
go.notification.go.tool.is.missing.run.go.get.invoke.go.get.action.text=调用 ''go get {0}''
go.notification.install.go.tool.action.text=安装 Go 工具
go.notification.add.to.gopath.action.text=添加到 GOPATH
go.notification.add.to.module.action.text=添加到模块
go.notification.create.go.mod.file.action.text=创建 'go.mod' 文件
go.notification.dep.integration.title=Dep 集成
go.notification.dep.init.failed.title=Dep init 失败
go.notification.dep.init.failed.configure.dep.action.text=配置 Dep
go.notification.disable.go.modules.integration.action.text=禁用 Go 模块集成
go.notification.do.not.show.action.text=不再显示
go.notification.cgo.optimizations.are.not.disabled=CGO_CFLAGS 未设置为 '-O0 -g'，无法优化 cgo 代码。
go.notification.install.package.action.text=安装 {0}
go.notification.modules.file.is.absent.title='go.mod' 文件不存在
go.notification.obsolete.imports.code.style.detected.title=检测到过时的导入代码样式设置
go.notification.review.code.style.settings.action.text=查看代码样式设置
go.notification.run.dep.ensure.action.text=运行 dep ensure
go.notification.file.starts.with.underscore.text=由于名称以 ''_'' 开头，''{0}'' 被构建工具忽略
go.notification.file.does.not.match.target.system.text=''{0}'' 与目标系统不匹配。文件将被构建工具忽略。
go.notification.inspections.are.disabled.text=已禁用对此文件进行检查
go.notification.inspections.are.disabled.enabled.action.text=启用检查
go.notification.code.insight.features.are.disabled.text=代码洞察功能不可用
go.notification.file.exceeds.size.limit.text=文件大小({0})超出了配置的限制({1})。{2}
go.notification.code.insight.disabled.for.vendored.files.text=库中供应文件的编辑代码洞察功能已禁用
go.notification.add.vendored.package.to.project.action.text=向项目中添加 ''{0}''
go.notification.package.was.excluded=从导入中排除 {0}
go.notification.open.imports.settings=打开导入设置
go.notification.download.missing.module.successfully.done=已成功处理 {0} 个{0,choice,0#模块|1#模块|2#模块}
go.profiler.application.configurable.name=Go 分析器
go.profiler.profile.fraction.comment.text=控制配置文件中报告的互斥争用事件的分数。平均而言，报告 1/分数个事件。留空将使用默认分数 1。
go.profiler.profile.fraction.label.text=配置文件分数:
go.profiler.profile.rate.cpu.comment.text=控制配置文件中报告的 goroutine 阻止事件的分数。平均而言，分析器的目标是在程序被阻止的每个周期对一个阻止事件采样。周期以纳秒为单位进行设置。要在配置文件中包含每个阻止事件，请将值设置为 1。留空将使用默认分析器速率 1。
go.profiler.profile.rate.label.text=配置文件速率:
go.profiler.profile.illegal.rate.validation.message=非法分析速率: {0}
go.profiler.profile.illegal.profile.fraction.validation.message=非法分析分数: {0}
go.profiler.profile.rate.memory.comment.text=控制配置文件中记录和报告的内存分配分数。平均而言，分析器的目标是根据分配的每个字节数对一次分配进行采样。要在配置文件中包含分配的每个块，请将速率设置为 1。留空将使用 512 KB 的默认速率。
go.profiler.blocking.profiler.name=阻止分析器
go.profiler.blocking.profile.prefix=阻止分析
go.profiler.cpu.profiler.name=CPU 分析器
go.profiler.cpu.profile.prefix=CPU 分析
go.profiler.memory.profiler.name=内存分析器
go.profiler.memory.profile.prefix=内存分析
go.profiler.mutex.profiler.name=Mutex 分析器
go.profiler.mutex.profile.prefix=Mutex 分析
go.profiler.not.a.pprof.profile.error=不是 pprof 配置文件
go.profiler.cpu.time.metric.name=CPU 时间
go.profiler.parse.error=解析配置文件时出错: {0}
go.profiler.parse.error.eof=意外的文件结尾
go.profiler.parse.error.empty=配置文件为空
go.profiler.allocated.objects.metric.name=已分配的对象
go.profiler.allocated.space.metric.name=已分配的空间
go.profiler.in.use.objects.metric.name=使用中的对象
go.profiler.in.use.space.metric.name=使用中的空间
go.profiler.downloading.profiler.dump.progress.title=正在下载分析器转储…
go.run.configuration.environment.label=环境(&V):
go.run.configuration.go.tool.arguments.label=Go 工具实参(&G):
go.run.configuration.module.label=模块(&M):
go.run.configuration.output.directory.label=输出目录(&O):
go.run.configuration.program.arguments.label=程序实参(&P):
go.run.configuration.run.after.build.checkbox=构建后运行(&R)
go.run.configuration.build.on.remote.target.checkbox=在远程目标上构建(&B)
go.run.configuration.run.kind.label=运行种类(&K):
go.run.configuration.run.with.sudo.label=通过 sudo 运行(&I)
go.run.configuration.run.with.sudo.tooltip=使用超级用户权限运行配置
go.run.configuration.run.with.sudo.mnemonic=使用提升的权限运行(&I)
go.run.configuration.add.go.tool.argument.label=添加
go.run.configuration.target.directory.label=目录(&D)
go.run.configuration.target.files.label=文件(&F):
go.run.configuration.target.package.label=软件包路径(&E):
go.run.configuration.test.framework=测试框架(&R):
go.run.configuration.test.kind.label=测试种类(&K):
go.run.configuration.kind.directory=目录
go.run.configuration.kind.package=软件包
go.run.configuration.kind.file=文件
go.run.configuration.test.pattern.label=模式(&T):
go.run.configuration.use.all.custom.build.tags.label=使用所有自定义构建标记(&L)
go.run.configuration.use.all.custom.build.tags.tooltip=您的设置中的所有自定义构建标记都是在构建过程中添加的(请参阅“Go | 构建标记与 Vendoring”)
go.settings.build.tags.arch.label=Arch
go.settings.build.tags.cgo.support.label=cgo 支持
go.settings.build.tags.compiler.label=编译器
go.settings.build.tags.custom.tags.hint=<html><body><p>Space-separated list of additional tags. <a href="https://www.jetbrains.com/help/go/configuring-build-constraints-and-vendoring.html">Can be used</a> in the 'go build' command.</p></body></html>
go.settings.build.tags.custom.tags.label=自定义标记
go.settings.build.tags.description=<html><body><p>以下选项描述编辑器的目标系统。IDE 使用这些值定义在验证、解析和代码补全中使用的文件。有关这些选项的详细信息，请参阅 <a href="https://golang.org/pkg/go/build/#hdr-Build_Constraints">Go 约束文档</a>。</p></body></html>
go.settings.build.tags.display.name=构建标记 \\& Vendoring
go.settings.build.tags.group.name=编辑器约束
go.settings.build.tags.os.label=OS
go.settings.build.tags.version.label=Go 版本
go.settings.build.tags.any.sdk.value=任意
go.settings.invalid.build.tag.error=构建标记无效: ''{0}''
go.settings.default.value=默认 ({0})
go.settings.project.sdk.value=项目 SDK ({0})
go.settings.default.for.project.sdk.value=SDK ({0}) 的默认值
go.settings.enabled=启用
go.settings.disabled=禁用
go.settings.common.suggest.parameter.names.checkbox=在补全时建议形参名称
go.settings.common.show.auto.import.in.completion.popup.checkbox=在键入时建议需要附加导入的变体
go.settings.common.indent.on.enter.in.raw.strings.checkbox=在输入原始字符串时缩进
go.settings.common.show.documentation.in.parameter.info.checkbox=在形参信息中显示文档
go.settings.common.detect.go.packages.from.clipboard.checkbox=从剪贴板检测 go 软件包
go.settings.common.confirmation.show.options.option=显示选项
go.settings.common.package.rename.rename.directory.option=重命名目录
go.settings.common.package.rename.do.not.rename.directory.option=不重命名目录
go.settings.common.directory.rename.rename.package.option=重命名软件包
go.settings.common.directory.rename.do.not.rename.package.option=不重命名软件包
go.settings.common.test.rename.corresponding.file.option=重命名相应的测试或生产文件
go.settings.common.test.do.not.rename.corresponding.file.option=不重命名相应的测试或生产文件
go.settings.common.directory.rename.option=重命名目录时
go.settings.common.package.rename.option=重命名软件包时
go.settings.common.test.rename.option=重命名文件时
go.settings.common.convert.json.on.paste.option=粘贴 JSON 时
go.settings.common.convert.json.on.paste.convert.option=将 JSON 转换为 Go 类型
go.settings.common.convert.json.on.paste.insert.as.is.option=照原样插入 JSON
go.settings.completion.ml.display.name=Go
go.settings.debugger.stack.depth.name=堆栈深度
go.settings.debugger.goroutines.limit.name=Goroutines 限制
go.settings.debugger.rebuild.transitive.packages.checkbox=重新构建过渡软件包(&R)
go.settings.debugger.rebuild.transitive.packages.description=为了获得更好的调试体验，Delve 需要在 $GOROOT/pkg 中重新编译优化的模块。
go.settings.imports.display.name=导入
go.settings.modules.display.title=Go 模块
go.settings.sdk.detected.notification.title=检测到 GOROOT
go.settings.sdk.detected.notification.text=<b>{0}</b> 被自动设置为项目 SDK。您可以在 GOROOT 配置中进行更改。
go.settings.sdk.detected.notification.configure.go.sdk.action.text=配置 Go SDK
go.settings.sdk.enable.integration.label=在模块中启用 Go 支持: 
go.settings.sdk.combo.tooltip=添加 SDK…
go.settings.sdk.add.button=添加 SDK…
go.settings.sdk.add.action.name=本地…
go.settings.sdk.add.local.title=为 Go SDK 选择主目录
go.settings.sdk.add.button.tooltip=添加 SDK ({0})
go.settings.sdk.download.action.name=下载…
go.settings.sdk.download.dialog.title=下载 Go SDK
go.settings.sdk.download.dialog.version.label=版本:
go.settings.sdk.download.dialog.location.label=位置:
go.settings.sdk.download.dialog.reload.versions.action.name=重新加载
go.settings.sdk.download.dialog.progress.versions.status=Go SDK 版本
go.settings.sdk.download.dialog.cannot.load.go.versions.validation.message=无法加载 SDK 版本。{0}
go.settings.sdk.download.dialog.version.is.not.specified.validation.message=指定版本。
go.settings.sdk.download.dialog.location.is.not.specified.validation.message=指定目标目录。
go.settings.sdk.download.dialog.cannot.create.directory.validation.message=无法在给定路径中创建目录。
go.settings.sdk.download.progress.downloading.status=正在下载 {0} {1}
go.settings.sdk.download.progress.verifying.status=正在验证下载的归档…
go.settings.sdk.download.progress.unpacking.status=正在解压缩 SDK…
go.settings.sdk.download.unpacked.sdk.is.corrupted.error=解压缩的 SDK 损坏
go.settings.sdk.download.checksum.of.downloaded.file.mismatched.error=下载的文件的校验和不匹配
go.settings.sdk.download.could.not.get.checksum.error=无法获取校验和: {0}
go.settings.sdk.download.could.not.find.go.directory.in.downloaded.file.error=无法在下载的文件中找到 go 目录
go.settings.sdk.download.could.not.unpack.downloaded.file.error=无法解压缩下载的文件
go.settings.sdk.download.could.not.copy.unpacked.sdk.error=无法复制解压缩的 SDK
go.settings.sdk.download.installed.notification.title=已安装 {0} {1}
go.settings.sdk.download.failed.to.download.notification.title=下载 SDK 失败
go.settings.modules.enable.integration.checkbox=启用 Go 模块集成
go.settings.modules.choose.module.dialog.title=选择 Go 模块
go.settings.modules.choose.module.validation.message=选择至少一个模块
filetype.go.settings.modules.dependency.description=Go 模块依赖关系文件
go.settings.modules.goproxy.documentation.link.title=模块下载和验证
go.settings.modules.goproxy.tooltip=GOPROXY 指示 go 命令在下载依赖项时使用特定的代理服务器。
go.settings.modules.environment.label=环境:
go.settings.modules.environment.context.help=GOPROXY、GOPRIVATE 和其他环境变量
go.settings.modules.sync.dependencies.fix.family.name=同步依赖关系
go.settings.modules.sync.dependencies.fix.text=同步 {0} 的依赖关系
go.settings.modules.vendoring.checkbox=自动启用供应支持
go.settings.modules.vendoring.checkbox.tooltip=自 Go 1.14 以来被忽略。<br>在 Go 1.14 之前，每当模块包含 vendor 目录时，都会启用 vendoring 支持。特别是，IDE 使用 '-mod=vendor' 标志运行 go 工具。
go.settings.modules.vendoring.documentation.link.title=如何为模块使用 vendoring
go.settings.run.configuration.invalid.env.name=非法的环境变量名称: ''{0}''
go.settings.run.configuration.invalid.env.value=环境变量值 ''{0}'' 非法: ''{1}''
go.settings.modules.explain.environment.variable=解释变量
go.settings.modules.add.other.environment.variable=其他
go.settings.modules.gosumdb.description=GOSUMDB 可以识别校验和数据库的名称。go 命令使用它来确保下载的依赖项的校验和没有更改。
go.settings.modules.gosumdb.documentation.link.title=模块身份验证失败
go.settings.modules.goprivate.description=GOPRIVATE 列出了被视为 private 的软件包。在下载和验证这些软件包时，go 命令不会使用代理或校验和数据库。
go.settings.modules.goprivate.documentation.link.title=非 public 模块的模块配置
go.settings.modules.gonoproxy.description=GONOPROXY 列出了被视为 private 的软件包。下载这些软件包时，go 命令不会使用代理。覆盖 GOPRIVATE。
go.settings.modules.gonosumdb.description=GONOSUMDB 列出了被视为 private 的软件包。验证这些软件包时，go 命令不会使用校验和数据库。覆盖 GOPRIVATE。
go.settings.modules.gomodcache.description=GOMODCACHE 设置模块缓存位置。
go.settings.modules.gomodcache.documentation.link.title=Go 1.15 发行说明
go.settings.postfix.enter.type.import.path.label=导入路径(&I):
go.settings.postfix.enter.type.name.label=类型名称(&T):
go.settings.postfix.enter.type.empty.type.validation.message=指定类型名称
go.settings.postfix.enter.type.action.name=输入类型名称…
go.settings.postfix.choose.type.action.name=选择类型…
go.settings.postfix.choose.type.prompt.text=选择类型
go.settings.vendoring.cannot.be.disabled.error.message=无法在 Go {0} 中禁用 Go Vendor Experiment
go.settings.vendoring.description=<html>\n\
  <head>\n\
    \n\
  </head>\n\
  <body>\n\
    <p>\n\
      启用此选项后，IDE 将根据 <a href="https://golang.org/s/go15vendor">Go Vendor Experiment 提案</a>解析和补全符号。\n\
    </p>\n\
    <p>\n\
      此外，还将为 IDE 中的所有 go 执行设置 <strong>GO15VENDOREXPERIMENT</strong> 环境变量的相应值。\n\
    </p>\n\
  </body>\n\
</html>
go.settings.vendoring.enable.vendoring.checkbox=启用 vendoring
go.settings.vendoring.group.name=供应商实验
go.settings.vendoring.is.not.supported.error.message=Go {0} 不支持 Go Vendor Experiment
go.template.intention.add.type.hint.name=指定点类型
go.template.intention.associate.file.extension.with.go.template=将文件扩展名与 Go 模板关联
go.template.intention.extension.associated.with.template=''{0}'' 扩展名已与 Go 模板关联
go.template.intention.open.file.type.settings=打开 Go 模板文件类型设置
go.template.intention.undo=撤消
go.unknown.type.information.hint=<未知>
group.GoTools.description=Go 外部工具
group.GoTools.text=Go 工具
go.call.hierarchy.respect.interface.calls.action.name=遵循接口调用
go.call.hierarchy.respect.interface.calls.description=遵循接口调用
go.settings.formatter.no.exceptions.empty.text=无异常
go.settings.formatter.comment.prefix.dialog.title=注释前缀
go.settings.formatter.wrap.call.arguments=函数调用实参
go.settings.formatter.wrap.comp.lit=复合文字
go.settings.formatter.wrap.func.params=函数形参
go.settings.formatter.wrap.func.result=函数结果形参
go.settings.diff.ignore.imports.and.formatting.description=忽略导入和格式化
go.settings.debugger.default.integer.format.label=默认整数格式:
go.executable.file.chooser.title=选择 {0}
go.executable.file.process.icon.tooltip=正在发现 {0}
go.executable.file.invalid.path.text=无效路径
go.executable.file.cannot.retrieve.version=无法检索版本
go.executable.file.empty.value=<Empty>
go.fmt.add.leading.space.to.comments=向注释添加前导空格
go.fmt.add.parentheses.for.single.import=为单个导入添加括号
go.fmt.group.stdlib.imports=组合 stdlib 导入
go.fmt.imports.tab.title=导入
go.fmt.move.all.imports.in.single.declaration=将所有导入移动到一个声明中
go.fmt.move.all.stdlib.imports.in.single.group=将所有 stdlib 导入移动到一个组中
go.fmt.remove.redundant.import.aliases=移除冗余导入别名
go.fmt.import.sorting.type=排序类型
go.fmt.use.back.quotes.for.imports=为导入使用左引号
go.fmt.fill.paragraph.width.label=填充段落宽度: 
go.fmt.create.local.group.label=组
go.fmt.for.current.project.packages=当前项目软件包
go.fmt.for.imports.starting.with.prefix=导入开头:
go.fmt.for.imports.starting.with.prefix.comment=逗号分隔的前缀列表，与 'goimports -local' 相同
go.fmt.imports.prefix.error.title=导入前缀错误
go.fmt.imports.prefix.error.empty.message=导入前缀不能为空
go.fmt.run.gofmt.panel.border.title=运行 gofmt
go.fmt.run.gofmt.on.code.reformat.label=代码重新格式化时(&R)
go.debugger.disconnected.unexpectedly=调试器意外断开连接
go.debugger.failed.to.compute.node.presentation=无法计算节点表示
go.debugger.connection.failed.generic.message=连接到 {0} 失败
go.debugger.connecting.to.address.message=正在连接到 {0}…
go.debugger.connecting.to.unknown.address.message=正在连接到远程地址…
go.debugger.cannot.retrieve.go.processes=无法检索 Go 进程
go.debugger.install.gops.to.attach.to.go.processes=安装 {0} 以附加到 Go 进程
go.debugger.local.attach.group.name=Go
go.debugger.breakpoint.title=Go 断点
go.debugger.error.breakpoint.title=Go 错误断点
go.debugger.error.breakpoint.display.text=致命错误
go.debugger.missing.function.name=<缺少>
go.debugger.record.and.debug.action.name=录制并调试
go.debugger.record.and.debug.description=录制并调试
go.debugger.record.and.debug.start.action.text=录制并调试
go.debugger.record.and.debug.cannot.find.rr.message=<html>无法找到 <a href="https://rr-project.org">mozilla rr</a> 可执行文件。请安装并将其添加到 PATH 中。</html>
go.debugger.internal.messaging.error=内部消息传递错误
go.debugger.cannot.connect.twice=Delve 进程不能连接两次
go.debugger.cannot.connect.non.remote=Delve 进程无法连接，因为它未使用远程连接
go.debugger.cannot.evaluate.expression=无法评估表达式 ''{0}'': {1}
go.debugger.cannot.get.current.goroutine=无法获取当前 goroutine
go.debugger.go.version.is.not.officially.supported=Go {0} 不受该调试器的官方支持，某些功能可能无法正常使用。请升级到 Go {1} 或更高版本。
go.debugger.go.version.is.not.supported=Go {0} 不受该调试器的支持。请升级到 Go {1} 或更高版本。
go.debugger.no.debug.information.for.file=可执行文件不包含 {0} 的调试信息
go.debugger.cannot.find.debugger.path=无法找到 {0} 的调试器路径
go.debugger.cannot.pause=无法暂停
go.debugger.recording.in.progress=正在记录程序执行。要调试记录，请等待程序终止或<a href=''{0}''>停止记录</a>。
go.debugger.failed.to.stop.mozilla.rr.recording=无法停止 mozilla rr 记录
go.debugger.failed.to.stop.mozilla.rr.recording.details=无法停止 mozilla rr 记录: {0}
go.debugger.cannot.evaluate.call=无法评估调用: {0}
go.debugger.non.top.frame.selected=已选择非顶部框架
go.debugger.missing.current.function=缺少当前函数
go.debugger.unused.functions.are.not.included.message=" (未使用的函数未包含在可执行文件中)"
go.debugger.unused.methods.are.not.included.message=" (未使用的方法未包含在可执行文件中)"
go.debugger.smart.step.into.failed=智能单步进入失败: {0}
go.debugger.expression.is.not.a.function=''{0}'' 不是函数
go.debugger.expression.is.nil=''{0}'' 为零
go.debugger.cannot.retrieve.interface.value.type=无法检索接口值的类型
go.debugger.cannot.get.current.stack=无法获取当前堆栈
go.debugger.smart.step.into.popup.title=单步进入函数
go.debugger.renderers.binary.name=二进制
go.debugger.renderers.decimal.name=十进制
go.debugger.renderers.hex.name=十六进制
go.debugger.computing.full.value.of.call.results.is.not.supported=不支持计算调用结果的完整值
go.debugger.cannot.calculate.value=无法计算值
go.debugger.obsolete.value=<过时>
go.debugger.cannot.calculate.string.presentation=无法计算字符串表示: {0}
go.debugger.unsupported.type=<不支持的类型: {0}>
go.debugger.cannot.load.remaining.call.result.children=无法加载调用结果的剩余子级
go.debugger.unreadable.error=\ 不可读: {0}
go.debugger.fmt.sprintf.unsupported.format=(不支持的格式)
go.debugger.fmt.sprintf.unsupported.verb=(不支持的动词)
go.debugger.fmt.sprintf.cannot.format.value=(无法格式化值)
go.debugger.async.stacktrace.caption=异步堆栈跟踪
go.debugger.thread=线程
go.debugger.goroutine=Goroutine
go.debugger.unsupported.architecture.error=仅 64 位系统和 32 位 Linux 系统支持调试
go.debugger.unsupported.go.version.on.darwin.arm64.error=在 darwin/arm64 上调试要求 Go 1.16
go.debugger.unsupported.go.arch.on.darwin.arm64.error=不支持调试使用 {0} 编译的程序。对 darwin/arm64 使用 go sdk。
go.debugger.only.first.goroutines.are.shown=仅显示第一个 {0} goroutines
go.debugger.thread.dump.error=无法获取线程转储: {0}
go.debugger.thread.dump.display.name=转储 {0}
go.debugger.thread.dump.incomplete.display.name=转储 {0} 不完整
go.debugger.cannot.find.file=找不到文件 {0}
go.debugger.unknown.function.name=<未知>
go.debugger.create.dump.background.task.title=正在转储堆栈…
go.debugger.create.dump.background.task.progress.text=正在转储堆栈({0})…
go.debugger.thread.dump.n.goroutines={0} {0,choice,0#goroutines|1#goroutine|2#goroutine}
go.debugger.thread.dump.n.unique.stacks={0} 唯一 {0,choice,0#堆栈|1#个堆栈|2#个stacks}
go.debugger.thread.dump.n.hidden.goroutines={0} 隐藏的 {0,choice,0#goroutines|1#goroutine|2#goroutines}
go.debugger.thread.dump.n.goroutines.matched.by.filter={0} 个 {0, choice, 0#goroutine|1#goroutine|2#goroutine} 通过筛选器匹配
go.debugger.another.command.is.in.progress=正在执行另一条命令
go.debugger.thread.dump.is.in.progress=正在进行线程转储
go.debugger.and.n.more=和其他 {0} 个
go.debugger.hidden.group.name=已隐藏({0})
go.debugger.stop.remote.delve.title=停止远程 Delve
go.debugger.stop.remote.delve.message=是否要停止远程 Delve 实例?
go.debugger.process.terminated.stop.remote.delve.message=远程进程已终止。是否也要停止远程 Delve 实例?
go.debugger.kill.existing.process.title=终止远程进程
go.debugger.kill.existing.process.message=是否要终止调试器所连接的远程进程?
go.remote.debug.disconnect.delve.label=断开连接时:
go.remote.debug.disconnect.delve.option.ask=询问
go.remote.debug.disconnect.delve.option.leave=保持运行
go.remote.debug.disconnect.delve.option.stop=停止远程 Delve 进程
go.settings.debugger.general.section.name=Go
go.settings.debugger.dataViews.section.name=Go
go.execution.package.is.not.specified.error=未指定软件包
go.execution.directory.is.not.specified.error=未指定目录
go.execution.file.is.not.specified.error=未指定文件
go.execution.cannot.find.package.error=找不到软件包 <code>{0}</code>
go.execution.package.contains.several.mains.error=软件包 <code>{0}</code> 包含多个 <code>main</code> 函数<br>请考虑改用文件种类
go.execution.cannot.find.directory.error=无法找到目录 <code>{0}</code>
go.execution.run.after.build.is.not.possible.incompatible.os.error=无法在构建后运行<br>结果二进制文件将与操作系统不兼容
go.execution.run.after.build.is.not.possible.main.not.found.single.file.error=无法在构建后运行<br>'main' 文件具有非 main 软件包或不包含 'main' 函数
go.execution.run.after.build.is.not.possible.main.not.found.many.files.error=无法在构建后运行<br>所选文件都没有 'main' 软件包和 'main' 函数
go.execution.file.not.found.error=找不到文件: <code>{0}</code>
go.execution.files.must.be.in.one.directory.error=命名文件必须全部位于一个目录中
go.execution.not.go.file.error=文件不是 Go 文件: {0}
go.execution.application.run.configuration.display.name=Go 构建
go.execution.application.run.configuration.description=Go 构建运行配置
go.execution.before.run.task.name=运行 Go 命令
go.execution.before.run.task.description=运行 ''{0}''
go.execution.before.run.task.supports.only.go.run.configurations.error=Go 命令任务仅支持 Go 运行配置
go.execution.before.run.task.supports.only.go.modules.error=Go 命令任务仅支持启用了 Go 集成的模块
go.execution.before.run.task.executing.presentable.name=Executing ''{0}''
go.execution.before.run.task.error.dialog.title=Go 命令任务
go.execution.before.run.task.edit.go.command.dialog.title=编辑 Go 命令任务
go.execution.before.run.task.empty.command.error=不允许空 Go 命令
go.execution.before.run.task.command.should.not.start.with.go.error=Go 命令不应以 'go' 开头
go.execution.coverage.percent.statements=% 语句
go.execution.coverage.percent.files=% 文件
go.execution.coverage.covered=已覆盖
go.execution.coverage.engine.name=Go 覆盖率
go.execution.coverage.cannot.run.coverage.on.directory.kind.run.configurations.error=无法在目录种类运行配置上运行覆盖率分析
go.execution.coverage.loading.coverage.data=正在加载覆盖率数据…
go.execution.coverage.runner.name=Go
go.execution.coverage.downloading.coverage.report.progress.title=正在下载覆盖率报告…
go.test.creator.empty.test.file.name=空测试文件
go.test.creator.test.for.function.name=函数测试
go.test.creator.test.for.file.name=文件测试
go.test.creator.test.for.package.name=软件包测试
go.test.creator.test.for.selection.name=选择范围测试
go.test.creator.gotests.generation.name=测试生成
go.test.creator.gotests.no.tests.generated=未生成测试
go.test.creator.gotests.failed.to.create.test.file=无法创建测试文件 {0}
go.test.creator.gotests.generation.failed.notification.title=测试生成失败
go.test.creator.cannot.find.test.package.name=无法找到测试软件包名称
go.test.creator.cannot.find.test.import.path=无法找到测试导入路径
go.test.creator.cannot.find.function.signature=无法找到函数签名
go.test.creator.cannot.find.method.receiver=无法找到 {0} 的方法接收器
go.test.creator.cannot.find.method.receiver.type=无法找到 {0} 的方法接收器类型
go.test.creator.cannot.find.field.type=无法找到 {0} 的字段类型
go.test.generate.table.benchmark.text=表基准
go.test.generate.table.benchmark.description=生成表基准函数
go.test.generate.table.test.text=表测试
go.test.generate.table.test.description=生成表测试函数
go.test.generate.function.description=生成 {0} 函数
go.test.generate.test.text=测试
go.test.generate.test.main.text=Test_main
go.test.generate.benchmark.text=基准
go.test.generate.example.text=示例
go.test.testify.run.configuration.name={1} 中的 {0}
go.test.testify.unknown.target.name=未知
go.test.framework.not.available.in.module.error=框架 <code>{0}</code> 在所选模块中不可用
go.test.working.directory.should.be.ancestor.of.testing.directory.error=工作目录应当是该测试目录的上级
go.test.testing.directory.does.not.exist.error=测试目录不存在
go.test.non.a.package.error=<code>{0}</code> 不是软件包。<br>使用目录类型运行配置，以在目录上递归运行测试。
go.test.cannot.find.files.compatible.with.framework.error=无法在与 <code>{1}</code> 框架兼容的 <code>{0}</code> 中找到 Go 测试文件
go.test.file.does.not.exist.error=文件不存在: {0}
go.test.not.go.file.error=文件 ''{0}'' 不是 Go 文件
go.test.framework.is.not.available.on.files.error=框架 <code>{0}</code> 在任何文件 <code>{1}</code> 上都不可用
go.test.suggested.run.configuration.name={1} 中的 {0}
go.test.run.configuration.name=Go 测试
go.test.run.configuration.description=Go 测试运行配置
go.test.template.run.configuration.name=Go 测试
go.test.run.test.tooltip=运行测试
go.test.no.tests.were.run=未运行任何测试
go.test.cannot.run.compiling.on.directory.kind.run.configurations.error=无法在类似目录的运行配置中调试测试。您可以使用<a href="edit">测试种类: 软件包</a>调试每个软件包的测试
go.execution.cannot.find.target.to.compile.error=无法找到要编译的目标
go.execution.cannot.create.temp.output.file.error=无法创建临时输出文件
go.execution.cannot.create.output.file.error=无法创建输出文件 {0}
go.execution.cannot.create.output.file.in.error=无法在 {0} 中创建输出文件
go.execution.cannot.make.temporary.file.executable.error=无法使临时文件成为可执行文件 {0}
go.execution.could.not.bind.remote.debugging.port.error=无法绑定远程调试端口
go.execution.cannot.find.target.error=无法找到目标 {0}
go.execution.sdk.not.set.or.sdk.home.path.empty.for.module.error=未设置 SDK 或此模块的 SDK 主路径为空
go.execution.can.not.run.go.local.process.error=无法运行 Go 本地进程
go.execution.failed.to.prepare.remote.environment.error=无法准备远程环境: {0}
go.execution.outdated.go.notification.title=您的 Go 版本已过时
go.execution.outdated.go.notification.text=要完全支持所有调试功能，请更新 Go 版本。
go.execution.change.goroot.action.name=更改 GOROOT
go.execution.compilation.finished.with.exit.code=编译完成，并显示退出代码 $EXIT_CODE$
go.execution.compiled.binary.cannot.be.executed=无法执行已编译的二进制文件
go.execution.compilation.failed.notification.title=编译失败
go.execution.install.lldb.notification.text=使用 xcode-select --install 安装 lldb
go.execution.go.setup.folding.placeholder=<{0} go 设置{0,choice,1#调用|2#调用}>
go.execution.remote.run.configuration.display.name=Go Remote
go.execution.remote.run.configuration.description=Go Remote
go.execution.remote.run.configuration.start.delve.text=在运行此配置之前，请按以下说明启动您的应用程序和 Delve。<br> <br>允许 Delve 编译您的应用程序: <br><pre>dlv debug --headless --listen=:{0} --api-version=2 --accept-multiclient</pre><br>或使用 Go {3} 或更高版本编译该应用程序: <br><pre>go build -gcflags \"all=-N -l\" github.com/app/demo</pre><br>，然后使用以下命令在 Delve 中运行: <br><pre>dlv --listen=:{1} --headless=true --api-version=2 --accept-multiclient exec ./{2}</pre>
go.execution.remote.run.configuration.host.label=主机(&H):
go.execution.remote.run.configuration.port.label=端口(&P):
go.execution.sdk.is.not.specified.error=没有为模块 <code>{0}</code> 指定 Go SDK
go.execution.module.does.not.exist.error=模块 <code>{0}</code> 在项目中不存在
go.execution.working.directory.is.not.specified.error=未指定工作目录
go.execution.cannot.find.working.directory.error=无法找到工作目录 <code>{0}</code>
go.execution.input.file.is.not.specified.error=未指定输入文件
go.execution.cannot.find.input.file.error=找不到输入文件 <code>{0}</code>
go.execution.go.is.not.configured.error=没有为此运行配置配置 Go: {0}
go.execution.run.application.tooltip=运行应用程序
go.execution.process.finished.with.exit.code={0} 已完成，退出代码为 {1}
go.execution.application.process.name=进程
go.execution.debugger.process.name=调试器
go.execution.unknown.target.delve.socket.error=无法运行 Delve。目标套接字未知。RunState: {0}
go.execution.process.interrupted=已中断
go.execution.process.cancelled=已取消
go.execution.go.sdk.is.not.downloaded.yet=Go SDK 尚未下载
go.execution.process.finished.successfully=成功完成
go.execution.process.failed.to.run=运行失败
go.execution.unknown.error=未知错误，详情参见日志
go.execution.enter.sudo=输入您的 sudo 密码:
go.import.optimizer.removed.imports=移除的 {0} 个{0,choice,1#导入|2#导入}
go.import.optimizer.removed.aliases=移除的 {0} 个{0,choice,1#别名|2#别名}
go.import.optimizer.removed.imports.and.aliases=移除的 {0} 个{0,choice,1#导入|2#导入}和 {1} 个{1,choice,1#别名|2#别名}
go.import.package.fix.family.name=导入软件包
go.import.package.fix.text=导入软件包
go.import.package.fix.text.no.variants=导入软件包?
go.import.package.fix.text.single.variant=导入{0}?
go.import.package.fix.text.many.variants=导入{0}? (多个选择…)
go.import.package.popup.title=要导入的软件包
go.import.package.cannot.invoke.fix.with.ambiguous.imports.error=无法在编辑器 {0} 中对不明确的导入调用修正。软件包: {1}
go.create.intermediate.variable.declaration.fix.name=创建中间变量
go.add.import.command.name=添加导入
go.add.import.with.alias.presentation={0} 作为 {1}
go.error.parser.expected=应为 ''{0}''
go.error.parser.expected.got=应为 ''{0}''，但得到的是 ''{1}''
go.error.parser.expected.or.got=应为 ''{0}'' 或 ''{1}''，但得到的是 ''{2}''
go.error.parser.unexpected=意外的''{0}''
go.error.annotator.invalid.package.name=无效的软件包名称
go.error.annotator.continue.statement.not.inside.a.for.loop='continue' 语句在 'for' 循环外部
go.error.annotator.break.statement.not.inside.a.for.loop.select.or.switch='break' 语句在 'for'、'select' 或 'switch' 语句外部
go.error.annotator.unexported.reference.usage=使用了未导出的{0} ''{1}'' 
go.error.annotator.type.is.not.an.expression=类型 ''{0}'' 不是表达式
go.error.annotator.unexported.type.usage=使用未导出类型 ''{0}''
go.error.annotator.reference.is.not.a.type={0} 不是类型
go.error.annotator.missing.key.in.map.literal=映射文字中缺少键
go.error.annotator.use.of.type.outside.type.switch=在类型 switch 外部使用 .(type)
go.error.annotator.invalid.type.assertion=无效的类型断言: {0} (左侧为非接口类型 {1})
go.error.annotator.invalid.type.switch.guard=无效的类型 switch 临界: {0} (左侧为非接口类型 {1})
go.error.annotator.map.key.type.is.not.comparable=无效的映射键类型: 必须为键类型完全定义比较运算符 == 和 !=
go.error.annotator.call.used.as.value.but.it.returns.nothing={0} 用作值，但它不返回任何内容
go.error.annotator.multiple.value.in.single.value.context=单值上下文中存在多值 {0}
go.error.annotator.type.aliases.are.available.since.go.1.9=类型声明中存在意外的 '='；类型别名自 Go 1.9 以后可用
go.error.annotator.missing.function.body=缺少{0}正文
go.error.annotator.main.or.init.has.invalid.signature={0} 函数不得有实参和返回值
go.error.annotator.invalid.index.or.slice.operation=无效的操作 {0} (字符串的 3 索引切片)
go.error.annotator.unexpected.end.of.statement=语法错误: 语句意外结束，应为 ':='、'=' 或 ','
go.error.annotator.unexpected.newline.after.if=意外换行，在 'if' 子句后应为 '{'
go.error.annotator.missing.condition.in.if.statement='if' 语句中缺少条件
go.error.annotator.semicolon.is.missing=缺少 ;
go.error.annotator.fallthrough.statement.out.of.place='fallthrough' 语句位置不当
go.error.annotator.cannot.fallthrough.final.case.in.switch=不能在 'switch' 语句的 final case 中使用 'fallthrough'
go.error.annotator.cannot.fallthrough.in.type.switch=无法在类型 switch 中使用 'fallthrough'
go.error.annotator.end.of.file.in.comment=文件结尾位于注释中
go.error.annotator.array.bound.must.be.a.constant.expression=无效的数组绑定 ''{0}''，必须是一个常量表达式
go.error.annotator.array.bound.must.be.non.negative=无效的数组绑定 ''{0}''，必须为非负
go.error.annotator.array.bound.must.be.representable.by.int.type=无效的数组绑定 ''{0}''，该值必须可以通过 ''int'' 类型表示
go.error.annotator.invalid.argument.for.len=len 函数的实参无效
go.error.annotator.invalid.argument.for.cap=cap 函数的实参无效
go.error.annotator.cannot.declare.init.must.be.a.function=无法声明 init，必须为函数
go.error.annotator.too.many.arguments.to.new=实参过多，无法添加新实参
go.error.annotator.cannot.make.type=无法生成 {0}
go.error.annotator.argument.is.not.a.type={0} 不是类型
go.error.annotator.missing.argument.to.make=缺少要生成的实参
go.error.annotator.non.integer.size.argument.to.make=make 函数中存在非整数大小实参
go.error.annotator.non.integer.capacity.argument.to.make=make 函数中存在非整数容量实参
go.error.annotator.missing.len.argument.to.make=make 函数中缺少 len 实参
go.error.annotator.too.many.arguments.to.make=make 函数中的实参过多
go.error.annotator.cyclic.definition.detected=检测到循环定义
go.error.annotator.use.of.package.without.selector=使用无选择器的软件包 ''{0}''
go.error.annotator.unexpected.assign.operator=意外的 {0}，应为 '':=''、''='' 或 '',''
go.error.annotator.invalid.constant.type=无效的常量类型
go.error.annotator.const.initializer.is.not.a.constant=常量初始值设定项 ''{0}'' 不是常量
go.error.annotator.missing.value.in.const.declaration=常量声明中缺少值
go.error.annotator.extra.expression.in.const.declaration=常量声明中有额外表达式
go.error.annotator.conversion.in.defer.or.go={0} 需要函数调用，而不是转换
go.error.annotator.function.not.permitted.in.defer.or.go=无法在 {0} 语句中调用此函数
go.error.annotator.parenthesized.expression.in.defer.or.go={0} 中的表达式不得使用括号
go.error.annotator.defer.or.go.requires.function.call={0} 中的表达式必须为函数调用
go.error.annotator.evaluated.but.not.used={0} 已评估但未使用
go.error.annotator.cannot.declare.in.post.statement.of.for.loop=无法在 for 循环的 post 语句中声明变量
go.error.annotator.too.many.variables.in.range=范围中的变量过多
go.error.annotator.named.and.unnamed.parameters={0} 同时具有命名形参和未命名形参 ''{1}''
go.error.annotator.named.and.unnamed.return.parameters={0} 同时具有命名和未命名的返回形参 ''{1}''
go.error.annotator.can.only.use.triple.dot.as.final.argument=只能将 '...' 用作列表中的最后一个实参
go.error.annotator.cannot.use.triple.dot.for.output.arguments=无法在输出实参列表中使用 '...'
go.error.annotator.method.name.in.interface.cannot.be.blank=接口中的方法名称不能为空
go.error.annotator.digit.separator.is.not.supported=从 Go 1.13 开始支持数字分隔符
go.error.annotator.binary.digits.are.not.supported=从 Go 1.13 开始支持二进制数字
go.error.annotator.octal.prefix.is.not.supported=从 Go 1.13 开始支持八进制前缀
go.error.annotator.hex.floats.are.not.supported=从 Go 1.13 开始支持十六进制浮点
go.error.annotator.closing.single.quote.expected=应为右 '
go.error.annotator.empty.rune.literal=空卢恩文字
go.error.annotator.too.many.characters.in.rune.literal=rune 文字中的字符数过多
go.error.annotator.invalid.select.assignment=select 赋值的右侧必须有接收运算
go.error.annotator.invalid.select.case=Select case 必须具有接收运算、发送运算、赋值或短变量声明
go.error.annotator.cannot.reassign.a.constant=不能重新分配常量
go.error.annotator.no.new.variables=':=' 的左侧没有新变量
go.error.annotator.assignment.count.mismatch=赋值计数不匹配: {0} = {1}
go.error.annotator.cannot.assign.to.expression=无法分配给 {0}
go.error.annotator.multiple.defaults={0} 中存在多个默认值
go.error.annotator.new.line.in.string=字符串中出现新行
go.error.annotator.bad.octal.escape=八进制转义必须包含三个八进制数字，第一个数字必须小于或等于 3
go.error.annotator.invalid.hex.escape.sequence.syntax=\\x 必须后跟两个十六进制数字
go.error.annotator.invalid.unicode.escape.sequence.syntax=\\u 必须后跟四个十六进制数字
go.error.annotator.invalid.long.unicode.escape.sequence.syntax=\\U 必须后跟八个十六进制数字
go.error.annotator.invalid.escape.sequence=无效的转义序列
go.error.annotator.invalid.unicode.code.point=无效的 Unicode 代码点
go.error.annotator.invalid.embedded.type=无效的类型 {0}: 必须为 typeName 或 *typeName
go.error.annotator.embedded.type.cannot.be.a.pointer=嵌入类型不能是指针
go.error.annotator.embedded.type.cannot.be.a.pointer.to.interface=嵌入类型不能是指向接口的指针
go.error.annotator.cannot.call.pointer.method=无法在 ''{0}'' 中调用指针方法
go.error.annotator.type.parameters.are.not.supported=从 Go 1.18 开始支持泛型
go.go.mod.error.annotator.no.module.statement=文件中没有模块语句
go.go.mod.error.annotator.multiple.module.statements=文件中存在多个模块语句
go.go.mod.error.annotator.multiple.version.statements=文件中存在多个 go 版本的语句
go.go.mod.error.annotator.missing.dependency=缺少依赖关系
go.go.mod.error.annotator.unresolved.dependency=未解析的依赖项
go.go.mod.error.module.version.expected=应为模块版本
go.terms.duplicate=重复
go.terms.duplicated.case=重复的 case
go.terms.duplicated.default=重复的默认值
go.terms.version.statement=版本语句
go.terms.module.statement=模块语句
go.terms.empty.declaration=空声明
go.terms.shadowed.declaration=隐藏的声明
go.terms.comment=注释
go.terms.variable=变量
go.terms.method=方法
go.terms.closure=结束
go.terms.import=导入
go.terms.parameter=形参
go.terms.receiver=接收器
go.terms.import.alias=导入别名
go.terms.label=标签
go.terms.package=软件包
go.terms.package.statement=\ package 语句
go.terms.package.capitalized=软件包
go.terms.map=映射
go.terms.chan=chan
go.terms.string=字符串
go.terms.array=数组
go.terms.declaration=声明
go.terms.statement=语句
go.terms.semicolon=分号
go.terms.comma=逗号
go.terms.go.statement=go 语句
go.terms.case=case
go.terms.slice=切片
go.terms.pointer=指针
go.terms.struct=struct
go.terms.anonymous.field=匿名字段
go.terms.type.alias=类型别名
go.terms.global.variable=全局变量
go.terms.constant=常量
go.terms.global.constant=全局常量
go.terms.field=字段
go.terms.type=类型
go.terms.type.pluralized=类型
go.terms.interface=接口
go.terms.function=函数
go.terms.method.specification=方法规范
go.refactoring.implement.methods.command=实现{0}
go.refactoring.implement.methods.prompt=选择要实现的接口:
go.refactoring.implement.methods.checkbox=非项目(&N)
go.refactoring.implement.methods.dummy.background.updater.task.title=正在搜索类型…
go.refactoring.implement.methods.create.type.name=创建类型…
go.refactoring.declarations.separator=声明
go.refactoring.exported.column.name=已导出
go.refactoring.extract.interface.caret.should.be.inside.type.error.message=文本光标应置于要重构的类型内
go.refactoring.unexported.validation.message=未导出的{0}将不再可以从{1}访问
go.refactoring.redeclare.validation.message={0} 将重新声明相同名称的 {1}
go.refactoring.less.than.one.declaration.validation.message=应至少选择一个声明。
go.refactoring.empty.target.directory.path.validation.message=目标目录路径不应为空。
go.refactoring.empty.target.file.name.validation.message=目标文件名不应为空。
go.refactoring.incorrect.file.name.validation.message=目标文件名不正确。
go.refactoring.empty.target.package.validation.message=目标软件包名称不应为空。
go.refactoring.incorrect.package.name.validation.message=目标软件包名称不正确。
go.refactoring.non.writable.directory.validation.message=目标目录不可写。
go.refactoring.non.writeable.file.validation.message=目标文件不可写。
go.refactoring.different.package.name.validation.message=现有文件的软件包名称不应不同。
go.refactoring.non.go.file.validation.message=目标文件应为 Go 文件。
go.refactoring.file.chooser.dialog.title=选择目标目录或文件
go.refactoring.file.label=目标文件:
go.refactoring.failed.to.create.directory.error.message=无法找到或创建目录 ''{0}''
go.refactoring.failed.to.create.file.for.package.error.message=无法为软件包 ''{1}'' 找到或创建文件 ''{0}''
go.refactoring.refactor.action=重构
go.refactoring.rename.action=收藏列表的新名称
go.refactoring.inline.defined.in.goroot.error.message={0} {1} 在 GOROOT 中定义
go.refactoring.inline.no.initializer.error.message={0} {1} 没有初始值设定项
go.refactoring.inline.no.parameter.value.error.message=无法找到形参 {0} 的值
go.refactoring.inline.defined.in.multi.value.context.error.message={0} {1} 在多值上下文中定义
go.refactoring.inline.reassigned.error.message=已重新分配 {0}
go.refactoring.inline.found.usages.in.goroot.message=已在 GOROOT 中找到 ''{1}'' 的 {0, choice, 1#1 个用法|2#{0} 个用法}。
go.refactoring.inline.kept.definition.and.inlined.message=已保留定义{0, choice, 0#|1#和项目与 GOPATH 中的 1 个内联用例|2#和项目与 GOPATH 中的 {0} 个内联用例}。
go.refactoring.inline.cannot.inline.variadic.parameter=不支持内联可变形参
go.refactoring.change.signature.reuse.types.checkbox=重用类型
go.refactoring.change.signature.result.parameters.tab.title=结果形参
go.refactoring.change.signature.not.legal.identifier.validation.message=''{0}'' 不是合法标识符。
go.refactoring.change.signature.named.and.unnamed.parameters.validation.message=无法同时使用命名形参和未命名形参。
go.refactoring.change.signature.parameter.without.type.validation.message=第 {0,number,ordinal} 个形参应具有类型。
go.refactoring.change.signature.used.multiple.times.validation.message=''{0}'' 被多次使用。
go.refactoring.change.signature.variadic.parameter.in.result.validation.message=结果中不允许使用可变形参。
go.refactoring.change.signature.variadic.is.not.last.validation.message=可变形参应始终是最后一个形参。
go.refactoring.change.signature.method.specification.and.implementations.option={0}方法规范和所有实现
go.refactoring.change.signature.current.method.option=仅{0}当前方法
go.refactoring.change.signature.target.not.found.error.message=文本光标必须位于要重构的函数或方法的名称处
go.refactoring.change.signature.function.will.not.start.application.validation.message=函数 {0} 将不再启动应用程序
go.refactoring.change.signature.function.will.not.perform.initialization.validation.message=函数 {0} 将不再执行初始化
go.refactoring.change.signature.renamed.parameter.validation.message.part=重命名的形参
go.refactoring.change.signature.new.parameter.validation.message.part=新形参
go.refactoring.extract.interface.rename.type.and.use.interface.radio.button=重命名原始类型并在可能的情况下使用接口(&E)
go.refactoring.extract.interface.rename.type.spec.label=将类型规范重命名为:
go.refactoring.extract.interface.unexported.method.specification.validation.message={0} {1} 不会实现未导出的方法规范
go.refactoring.extract.interface.unexported.not.be.accessible.validation.message=未导出的{0}将无法从{1}访问
go.refactoring.extract.interface.empty.type.name.validation.message=类型名称不应为空。
go.refactoring.extract.interface.incorrect.type.name.validation.message=类型名称不正确。
go.refactoring.introduce.extract.title=提取
go.refactoring.introduce.extract.function.title=提取函数
go.refactoring.introduce.extract.function.command=提取函数
go.refactoring.introduce.extract.method.command=提取方法
go.refactoring.introduce.extract.variable.command=提取变量
go.refactoring.introduce.extract.method.or.function.title=提取方法或函数
go.refactoring.introduce.range.contains.defer.message=所选范围包含 'defer' 语句，该语句可能会在提取期间重新排序
go.refactoring.introduce.receiver.without.name.error.message=接收器应有名称
go.refactoring.introduce.continue.statement.interrupts.execution.flow.error.message=当 continue 语句中断执行流时，不支持重构
go.refactoring.introduce.label.reference.interrupts.execution.flow.error.message=当标签引用中断执行流时，不支持重构
go.refactoring.introduce.label.definition.selected.with.all.references.error.message=只有选择标签定义及其所有引用时，才支持重构
go.refactoring.introduce.does.not.return.value.error.message=表达 {0} 不返回值。
go.refactoring.introduce.not.constant.value.error.message=表达式 {0} 不是常量值。
go.refactoring.introduce.method.with.receiver.renderer=包含 {0} 接收器的方法
go.refactoring.introduce.type.dialog.title=引入类型
go.refactoring.introduce.type.command=引入类型
go.refactoring.introduce.type.chooser.title=选择类型
go.refactoring.move.affect.initialization.order.validation.message=移动函数 {0} 可能会影响该应用程序的初始化顺序
go.refactoring.move.break.initialization.validation.message=移动变量 {0} 将中断变量 {1} 的初始化
go.refactoring.move.value.will.change.validation.message=常量 {0} 的值将更改，因为它使用 {1} 进行声明
go.refactoring.move.function.will.not.start.application.validation.message=软件包 {1} 外部的函数 {0} 将不再启动此应用程序
go.refactoring.move.type.will.not.implement.interface.validation.message=类型 {0} 将不再实现接口 {1}
go.refactoring.move.exported.function.will.not.start.application.validation.message=导出的函数 {0} 将不再启动应用程序
go.refactoring.move.exported.function.will.not.perform.initialization.validation.message=导出的函数 {0} 将不再执行初始化
go.refactoring.move.type.will.become.non.local.for.method.validation.message=类型 {0} 将成为方法 {1} 的非局部类型
go.refactoring.move.required.by.validation.message={0}需要
go.refactoring.move.file.should.differ.validation.message=目标文件应与源文件不同
go.refactoring.rename.looking.for.anonymous.field.usages.progress.title=正在查找匿名字段用法
go.refactoring.rename.looking.for.method.usages.progress.title=正在查找方法用法
go.refactoring.rename.package.title=同时将软件包 ''{0}'' 重命名为 ''{1}''?
go.refactoring.rename.test.file.title=同时重命名测试文件 ''{0}''?
go.refactoring.rename.production.file.title=同时重命名生产文件 ''{0}''?
go.refactoring.rename.directory.message=同时重命名软件包目录 ''{0}''?
go.refactoring.rename.current.receiver.option=仅重命名当前接收器
go.refactoring.rename.all.receivers.option=重命名所有接收器
go.find.usages.of.interface.methods.dialog.base.methods.checkbox=基方法(&B)
go.find.usages.of.interface.methods.dialog.title=查找接口方法的用法?
go.find.usages.of.interface.methods.dialog.message=类型 ''{0}'' 实现接口，方法 ''{1}'' 重写方法。您是否希望查找接口方法的用法?
go.find.usages.of.interface.methods.notification.title=正在查找接口方法的用法
go.find.usages.of.interface.methods.notification.show.options.text=显示选项 {0}
go.find.usages.show.usages.in.comments.text=在注释中显示用法
go.find.usages.show.usages.in.comments.description=在注释中显示元素用法
go.code.smells.commit.local.paths=提交本地路径可能无法移植
go.init.with.zero.value=使用零值初始化
go.usage.type.return.type=返回类型
go.usage.type.parameter.declaration=形参声明
go.usage.type.struct.initialization=结构初始化
go.usage.type.import=导入
go.usage.type.variable.declaration=变量声明
go.usage.type.field.declaration=字段声明
go.usage.type.const.declaration=常量声明
go.usage.type.receiver=接收器
go.usage.type.type.assertion=类型断言
go.usage.type.type.alias=类型别名
go.usage.type.type.conversion=类型转换
go.inspection.problem.unmarshal.argument.must.be.a.pointer=此实参必须为指针类型
go.enable.template.plugin.notification.text=启用 Go 模板以增强 html/templates 软件包中的突出显示、补全和导航功能
go.enable.template.plugin.action.text=启用插件
go.install.template.plugin.notification.text=安装 Go 模板以增强 html/templates 软件包中的突出显示、补全和导航功能
go.install.template.plugin.action.text=安装插件
go.ignore.template.plugin.action.text=忽略此项目的插件
go.inspection.problem.range.var.copies.lock=范围变量 {0} 复制锁定: {1}
go.inspection.problem.function.passes.lock.by.value={0} 通过此值传递锁定: {1}
go.inspection.problem.return.copies.lock.value=返回复制锁定值: {0}
go.inspection.problem.call.copies.lock.value=调用 {0} 将复制锁定值: {1}
go.inspection.problem.literal.copies.lock.value=文字从 {0} 复制锁定值: {1}
go.inspection.problem.assignment.copies.lock.value=赋值将锁定值复制到 {0}: {1}
go.inspection.problem.variable.declaration.copies.lock.value=变量声明将锁定值复制到 {0}: {1}
go.inspection.problem.invalid.second.argument.to.errors.as={0} 的第二个实参必须是一个指针，该指针指向接口或指向实现错误接口的类型
go.inspection.problem.expression.is.too.small.for.shift={0} ({1} 位)对于 {2} 的移位太小
go.inspection.problem.method.has.non.standard.signature=方法 {0} 应包含签名 {1}
go.inspection.problem.direct.assignment.to.atomic.value=直接赋值给原子值
go.inspection.problem.cannot.take.address.of.non.addressable.operand=无法获取不可寻址操作数的地址
go.inspection.problem.assignment.to.method.receiver.propagates.only.to.callees=对方法接收器的赋值仅传播到被调用方，不传播到调用方
go.inspection.problem.assignment.to.method.receiver.doesnt.propagate=对方法接收器的赋值不传播到其他调用
go.inspection.problem.expression.can.be.simplified.to.other={0} 可以简化为 {1}
go.inspection.problem.condition.is.always.true.or.false=条件 {0} 始终为 {1}
go.inspection.problem.conversion.from.int.to.string=从 {0} 到 {1} 的转换将整数值解释为代码点
go.inspection.problem.expression.is.always.true.or.false=表达式 {0} 始终为 {1}
go.inspection.problem.expression.can.be.simplified=可以简化表达式
go.inspection.problem.possible.malformed.build.comment='+build' 注释的格式可能不正确
go.inspection.problem.wrong.location.of.build.comment='build' 注释必须出现在软件包子句前面，后面跟随一个空白行
go.inspection.problem.usage.of.cgo.in.tests=不支持在测试中使用 cgo
go.inspection.problem.comment.should.start.with.whitespace=注释应以空白开头
go.inspection.problem.defer.is.called.in.a.for.loop=可能发生资源泄漏，在 {1} 循环中调用 {0}
go.inspection.problem.deprecated.is.still.used=被弃用的 {0} 仍在使用
go.inspection.problem.reference.is.deprecated=已弃用 {0}
go.inspection.problem.division.by.zero=除以零
go.inspection.problem.duplicate.case=case {0} 重复
go.inspection.problem.variable.repeated.on.left.side={0} 在 := 的左侧重复
go.inspection.problem.name.redeclared.as.imported.package={0} 被重新声明为导入的软件包名称
go.inspection.problem.name.collides.with.name.declared.in.this.package={0} 与此软件包中声明的名称冲突
go.inspection.problem.label.already.defined=已定义标签 {0}
go.inspection.problem.duplicate.argument=实参 {0} 重复
go.inspection.problem.name.redeclared.in.this.function=此函数中重新声明了 {0}
go.inspection.problem.duplicate.field=重复字段 {0} 
go.inspection.problem.type.has.same.named.field.and.method=\n\
类型 {0} 的字段和方法均命名为 {1}
go.inspection.problem.method.redeclared=方法重新声明 {0}
go.inspection.problem.type.has.both.field.and.method.with.name=\n\
类型 {0} 的字段和方法均命名为 {1}
go.inspection.problem.duplicate.method=方法 {0} 重复
go.inspection.problem.name.redeclared.in.this.package=此包中重新声明的 {0}
go.inspection.problem.name.redeclared.in.this.block=此块中重新声明了 {0}
go.inspection.problem.bad.error.string=错误字符串不应大写或以标点结尾
go.inspection.problem.exported.element.should.have.comment=导出的 {0} {1} 应有注释，否则就是未导出
go.inspection.problem.exported.function.with.unexported.return.type=导出的 {0} 具有未导出的返回类型
go.inspection.problem.exported.var.should.have.its.own.declaration=导出的变量 {0} 应有自己的声明
go.inspection.problem.exported.const.should.have.its.own.declaration=导出的常量 {0} 应有自己的声明
go.inspection.problem.missing.argument.to.conversion=缺少要转换为 {0} 的实参: {1}
go.inspection.problem.too.many.arguments.to.conversion=要转换为 {0} 的实参过多: {1}
go.inspection.problem.too.many.arguments.in.call={0} 调用中的实参过多
go.inspection.problem.not.enough.arguments.in.call={0} 调用中的实参不足
go.inspection.problem.name.collides.with.imported.package={0} {1} 与导入的软件包名称冲突
go.inspection.problem.impossible.type.assertion=不可能的类型断言: {0} 未实现 {1}
go.inspection.problem.impossible.interface.assertion=从 {0} 到 {1} 的接口声明无效。模糊: {2}
go.inspection.problem.impossible.type.switch.case=不可能的类型 swich case: {0} 未实现 {1}
go.inspection.problem.infinite.for.loop=无限的 {0} 循环
go.inspection.problem.cannot.convert.expression=无法将类型 {0} 的表达式转换为类型 {1}
go.inspection.problem.cannot.convert.nil=无法将 ''nil'' 转换为类型 {0}
go.inspection.problem.invalid.conversion=无效转换
go.inspection.problem.cannot.slice=无法切片 {0} (类型 {1})
go.inspection.problem.type.does.not.support.indexing=无效运算: {0} (类型 {1} 不支持索引)
go.inspection.problem.invalid.low.high.indices=无效索引值，必须低值 <= 高值
go.inspection.problem.invalid.low.high.max.indices=无效索引值，必须为低值 <= 高值 <= 最大值
# 0 - index value, i.e. "-1", 1 - additional information
go.inspection.problem.invalid.slice.index=无效的切片索引 {0} ({1})
# 0 - index value, i.e. "-1", 1 - indexed container type, i.e. "array" or "string", 2 - additional information
go.inspection.problem.invalid.iterable.index=无效的 {0} 索引 {1} ({2})
go.inspection.problem.must.be.representable.by.int=值必须可由 'int' 类型表示
go.inspection.problem.must.be.of.integer.type=必须为整型
go.inspection.problem.must.be.non.negative=必须为非整型
go.inspection.problem.out.of.bounds.for.string={0} 字节的字符串超出界限
go.inspection.problem.out.of.bounds.for.array={0} 元素的数组超出界限
go.inspection.problem.invalid.receiver.type=无效接收器类型{0} ({1} 为 {2})
go.inspection.problem.invalid.receiver.unnamed.type=未命名类型
go.inspection.problem.invalid.receiver.interface.type=接口类型
go.inspection.problem.invalid.receiver.pointer.type=指针类型
go.inspection.problem.cannot.define.new.methods.on.non.local.type=无法在非局部类型 {0} 上定义新方法
go.inspection.problem.use.of.internal.package.is.not.allowed=不允许使用内部软件包
go.inspection.problem.use.of.vendored.package.is.not.allowed=不允许使用供应商提供的软件包
go.inspection.problem.must.be.imported.as=必须作为 {0} 导入
go.inspection.problem.at.is.not.allowed.in.import.paths=导入路径中不允许 @
go.inspection.problem.cannot.import.absolute.path=无法导入绝对路径
go.inspection.problem.cannot.import.builtin.package=无法导入 'builtin' 软件包
go.inspection.problem.non.canonical.import.path=非规范的导入路径: {0} 应为 {1}
go.inspection.problem.build.constraints.exclude.all.go.files=构建约束排除 {0} 中所有的 Go 文件
go.inspection.problem.path.is.a.program.not.an.importable.package={0} 是程序，不是可导入的软件包
go.inspection.problem.found.several.packages=在 {1} 中找到多个软件包 [{0}]
go.inspection.problem.no.non.test.go.files=软件包仅包含测试 Go 文件: {0}
go.inspection.problem.cannot.import=无法导入 {0}
go.inspection.problem.cannot.rename.import.c=无法重命名 import 'C'
go.inspection.problem.path.imports.package.with.invalid.import.comment={0} 导入包含无效导入注释的软件包
go.inspection.problem.path.imports.package.that.expects.canonical.import={0} 导入需要导入 "{1}" 的软件包
go.inspection.problem.invalid.composite.literal.type=无效的复合文字类型: {0}
go.inspection.problem.too.few.values=值太少
go.inspection.problem.too.many.values=值太多
go.inspection.problem.cannot.assign.value.to.blank.field=无法将值赋给空字段
go.inspection.problem.cannot.assign.value.to.unexported.field=无法将值赋给未导出的字段 {0}
go.inspection.problem.missing.type.in.composite.literal=复合文字中缺少类型
go.inspection.problem.mixture.of.field=混合字段: 值和初始值设定项
go.inspection.problem.invalid.field.name=字段名无效
go.inspection.problem.missing.expression=缺少表达式
go.inspection.problem.missing.key.in.map.literal=映射文字中缺少键
go.inspection.problem.duplicate.key.in.map.literal=映射文字中的键 {0} 重复
go.inspection.problem.cannot.convert.known.value.to.type=无法将 {0} 转换为 {1}
go.inspection.problem.cannot.convert.value.to.type=无法将值转换为 {0}
go.inspection.problem.index.must.be.a.non.negative.integer.constant=索引 {0} 必须是非负整数常量
go.inspection.problem.negative.index=负索引: {0}
go.inspection.problem.index.out.of.bounds=索引超出界限: {0}
go.inspection.problem.duplicate.index=重复的索引: {0}
go.inspection.problem.reference.jumps.over.declaration={0} 跳过 {1} 的声明
go.inspection.problem.missing.return=函数末尾缺少 'return' 语句
go.inspection.problem.need.trailing.comma.in.composite.literal=复合文字中的换行符前需要尾随逗号
go.inspection.problem.need.trailing.comma.in.parameter.list=形参列表中的换行符前面需要有尾随逗号
go.inspection.problem.need.trailing.comma.in.argument.list=实参列表中的换行符前面需要有尾随逗号
go.inspection.problem.multiple.packages.in.directory=目录中有多个软件包: {0}
go.inspection.problem.name.starts.with.package.name=名称以软件包名称开头
go.inspection.problem.cannot.call.non.function=无法调用类型为 {1} 的非函数 {0}
go.inspection.problem.empty.slice.declaration.via.literal=使用文字的空切片声明
go.inspection.problem.function.does.not.take.writer=\n\
函数不使用 {0}，但第一个实参是 {1}
go.inspection.problem.possible.formatting.directive={0} 中可能的格式指令
go.inspection.problem.last.argument.ends.with.redundant.newline={0} 的最后一个实参以冗余的换行符结尾
go.inspection.problem.return.value.has.a.function.type=返回值 {0} 具有函数类型
go.inspection.problem.argument.is.not.a.function.call=实参 {0} 不是函数调用
go.inspection.problem.argument.causes.recursive.call.to.string.method=实参 {0} 导致对 {1} 方法的递归调用
go.inspection.problem.receiver.has.generic.name=接收器具有泛型名称
go.inspection.problem.receiver.names.are.different=接收器名称不同
go.inspection.problem.invalid.recursive.type=无效递归 {0} {1}{2}
go.inspection.problem.redundant.blank.expression=冗余 {0} 表达式
go.inspection.problem.redundant.comma=冗余逗号
go.inspection.problem.possibly.redundant.type.conversion=类型转换可能冗余
go.inspection.problem.redundant.type.conversion=冗余类型转换
go.inspection.problem.redundant.alias=冗余别名
go.inspection.problem.redundant.parentheses=冗余括号
go.inspection.problem.redundant.index=冗余索引 {0}
go.inspection.problem.redundant.semicolon=冗余分号
go.inspection.problem.redundant.type=冗余类型
go.inspection.problem.name.collides.with.builtin={0} {1} 与 ''builtin'' {2} 冲突
go.inspection.problem.value.is.assigned.to.itself={0} 的值被赋予本身
go.inspection.problem.self.import.is.not.allowed=不允许自我导入
go.inspection.problem.declaration.shadows.declaration={0} 的声明隐藏声明
go.inspection.problem.declaration.shadows.declaration.at={0} 的声明隐藏 {1} 处的声明
go.inspection.problem.eliminate.snake.case=消除蛇形拼写法
go.inspection.problem.use.camelcase.instead.of.snake.case=使用驼峰拼写法，不使用蛇形拼写法
go.inspection.problem.mismatched.types.byte.and.string=不匹配的类型: 字节和字符串
go.inspection.problem.bad.count.argument.of.strings.replace={0} 的计数实参不应为 {1}
go.inspection.problem.fields.are.assigned.without.explicit.names=字段分配时没有显式名称
go.inspection.problem.wrong.example.signature=示例签名错误
go.inspection.problem.wrong.test.signature=测试签名错误
go.inspection.problem.cannot.use.underscore.as.value=无法将 {0} 用作值
go.inspection.problem.unhandled.error=未处理错误
go.inspection.problem.unit.specific.suffix=特定于单元的后缀 {0}
go.inspection.problem.unnecessarily.exported.element=不必要地导出了 {0} {1}
go.inspection.problem.unreachable.code=不可到达的代码
go.inspection.problem.imports.are.not.sorted=import 未排序
go.inspection.problem.unused.result=未使用的结果: {0}
go.inspection.problem.unused.import=未使用的 import
go.inspection.problem.assignment.used.as.value={0} 作为值使用
go.inspection.problem.no.placeholders.in.format.string=格式字符串中没有占位符
go.inspection.problem.too.many.arguments.for.format.string=格式字符串的实参过多: 应为 {0}，实际为 {1}
go.inspection.problem.verb.will.ignore.flag=动词将忽略 {0} 标志 {1}
go.inspection.problem.verb.will.ignore.flags=动词将忽略 {0} 标志 {1}
go.inspection.problem.placeholder.syntax.error=占位符语法错误 {0}
go.inspection.problem.this.verb.can.be.used.only.in.fmt.errorf=此动词只能在 {0} 个调用 {1} 中使用
go.inspection.problem.this.verb.can.be.used.only.once.in.a.format.string=此动词只能在格式字符串 {0} 中使用一次
go.inspection.problem.fmt.parameter.with.non.integer.expression=使用非整型表达式 {1}{2} 指定了{0, choice, 0#宽度|1#精度|2#谓词}
go.inspection.problem.no.argument.for.placeholder.part=没有{0, choice, 0#宽度|1#精度|2#动词}的实参: 实参索引 = {1}，实参计数 = {2}{3}
go.inspection.problem.unknown.verb=未知动词 {0}{1}
go.inspection.problem.return.value.of.placeholder.argument.has.a.function.type=占位符实参的返回值具有函数类型 {0}
go.inspection.problem.placeholder.argument.is.not.a.function.call=占位符实参不是函数调用 {0}
go.inspection.problem.placeholder.argument.has.wrong.type=占位符实参 {0} 具有错误的类型 {1}{2}
go.inspection.problem.placeholder.argument.causes.recursive.call.to.string=占位符实参导致对 {0} 方法 {1} 的递归调用
go.inspection.problem.index.zero.is.illegal=索引值 [0] 为非法的 {0}
go.inspection.problem.invalid.use.of.triple.dot=无效使用 '...'，对应形参是非可变形参
go.inspection.problem.too.many.arguments.to.return=要返回的实参太多
go.inspection.problem.not.enough.arguments.to.return=要返回的实参不足
go.inspection.problem.invalid.argument.must.be.complex.type=必须为复杂类型
go.inspection.problem.expression.with.type={0} (类型 {1})
go.inspection.problem.non.bool.used.as.condition=非布尔值 {0} 用作条件
go.inspection.problem.cannot.range=范围不能超过 {0}
go.inspection.problem.type.or.type={0} 或 {1}
go.inspection.problem.nil.is.not.allowed=不允许 {0}。必须为 {1}
go.inspection.problem.incompatible.types=无法将 {0} 用作类型 {1}
go.inspection.problem.incompatible.types.in.switch=switch {1} 中的 case {0} 无效
go.inspection.problem.incompatible.types.in.switch.on.expression={1} {2} 的 switch 中的 case {0} 无效
go.inspection.problem.mismatched.types=(类型 {0} 和 {1} 不匹配)
go.inspection.problem.incompatible.types.some.methods.are.missing=类型未实现 {0}，因为<b color={1}>缺少某些方法: <br/>{2}</b>
go.inspection.problem.incompatible.types.ambiguous.methods=类型未实现 {0}，因为 <b color={1}>{2} 不明确</b>
go.inspection.problem.incompatible.method.has.pointer.receiver=类型未实现 {0}，因为 <b color={1}>{2} 方法有指针接收器</b>
go.inspection.problem.incompatible.need.method.have.method=类型未实现 {0}<br/><b color={1}> 需要方法: {2}<br/>具有方法: {3}</b>
go.inspection.problem.incompatible.unexported.method=类型无法实现 {0}，因为<b color={1}>类型有未导出的方法，并且是在不同的软件包中定义</b>
go.inspection.problem.invalid.inc.dec.operation=无效运算: {0}(非数值类型 {1})
go.inspection.problem.cannot.assign.in.multiple.assignment=无法在多个赋值中将 {0} 赋给 {1}
go.inspection.problem.cannot.convert.nil.to.type=无法将 {0} 转换为类型 {1}
go.inspection.problem.invalid.unary.operation=无效运算: {0}
go.inspection.problem.cannot.convert.constant=无效运算: {0} (无法将常量 {1} 转换为类型 {2})
go.inspection.problem.operator.not.defined=无效运算: {0} (在 {2} 中未定义运算符 {1})
go.inspection.problem.receive.from.send.only.type=无效运算: {0} (从仅发送类型 {1} 接收)
go.inspection.problem.receive.from.non.chan.type=无效运算: {0} (从非 chan 类型 {1} 接收)
go.inspection.problem.send.to.non.chan.type=无效运算: {0} (发送到非 chan 类型 {1})
go.inspection.problem.send.to.receive.only.type=无效运算: {0} (发送到仅接收类型 {1})
go.inspection.problem.invalid.operation.mismatched.types=无效运算: {0}(类型 {1} 和 {2} 不匹配)
go.inspection.problem.shift.count.must.be.unsigned.integer=无效运算: {0} (移位计数类型 {1}，必须为无符号整数)
go.inspection.problem.shift.count.must.be.integer=无效运算: {0} (移位计数类型 {1}，必须为整数)
go.inspection.problem.negative.shift.count=无效运算: {0} (负移位计数)
go.inspection.problem.receiver.may.be.nil.in.call=接收器 {0} 在调用中可能是 {1}
go.inspection.problem.method.call.may.lead.to.nil.pointer.dereference=方法调用 {0} 可能导致 nil 指针取消引用
go.inspection.problem.function.call.may.lead.to.nil.pointer.dereference=函数调用 {0} 可能导致 nil 指针取消引用
go.inspection.problem.accessing.field.may.lead.to.nil.pointer.dereference=访问字段 {0} 可能导致 nil 指针取消引用
go.inspection.problem.send.may.block.because.of.nil.channel=由于 {0} 通道，发送运算可能会阻止 goroutine
go.inspection.problem.receive.may.block.because.of.nil.channel=由于 {0} 通道，接收运算可能会阻止 goroutine
go.inspection.problem.potential.nil.pointer.dereference=可能发生 nil 指针取消引用
go.inspection.problem.assignment.to.entry.may.panic.because.of.nil.map=由于 {0} 映射，赋值给某个条目可能会出现 panic
go.inspection.problem.indexing.may.panic.because.of.nil.slice=由于切片 {0}，索引可能会出现 panic
go.inspection.problem.nil.loop.is.always.skipped=总是跳过循环，因为 {0} 总是 {1}
go.inspection.problem.corresponding.error.may.be.not.nil={0} 可能有 {1} 或其他非预期值，因为它相应的错误变量可能不是 {2}
go.inspection.problem.condition.is.always.true.or.false.because.of.nil=条件始终为 {0}，因为 {1} 始终是 {2}
go.inspection.problem.condition.is.always.true.or.false.because.of.not.nil=条件始终为 {0}，因为 {1} 始终不是 {2}
go.inspection.problem.unused.dependency=未使用的依赖项
go.inspection.problem.contains=包含
go.inspection.problem.type.which.is.sync.locker=类型 %s，它是 <code>sync.Locker</code>
go.inspection.problem.type.is.sync.locker=类型 %s 为 <code>sync.Locker</code>
go.module=模块
go.modules.scratch.file.notification.text=使用模块上下文
go.run.target.executable.path.label=Go 可执行文件: 
go.run.target.gopath.label=GOPATH: 
go.run.target.version.label=版本:
go.run.target.configure.label=Go 配置
go.run.target.run.label=运行 Go 应用程序
go.attach.directory.action.text=附加目录 "{0}"
go.detach.directory.action.text=分离目录 "{0}"
go.remove.else=移除 else
go.unwrap.else=解开 else
go.unwrap.for=解开 for
go.unwrap.argument=解开实参
go.unwrap.argument.description=解开 {0}
go.unwrap.if=解开 if
go.settings.global.gopath.group.name=全局 GOPATH
go.settings.project.gopath.group.name=项目 GOPATH
go.settings.module.gopath.group.name=模块 GOPATH
go.dep.executable.path.label=Dep 可执行文件
go.quick.doc.package.label=软件包:
go.quick.doc.resolved.value.label=已解析的值: 
go.settings.folding.one.line.return.checkbox=一行返回
go.settings.folding.one.line.panics.checkbox=1 行 panic
go.settings.folding.format.strings.checkbox=格式字符串
go.settings.formatter.add.space.except.for.comments.label=以此开头的注释除外: 
go.settings.formatter.comment.prefix.cannot.be.empty.validation.message=注释前缀不能为空
go.notification.go.root.is.not.defined.text=未定义 GOROOT
go.notification.go.root.is.incorrect.text=GOROOT 不正确
go.refactoring.split.declarations.action.text=拆分声明
go.refactoring.split.declarations.with.iota.warning=Declaration initializers will have different values after split because of 'iota'
go.refactoring.merge.declarations.action.text=合并声明
go.refactoring.merge.declarations.with.iota.warning=Declaration initializers will have different values after merge because of 'iota'
go.inlays.show.unnamed.fields.in.structure.values.option=在结构值中显示未命名字段
go.inlays.show.return.parameters.option=显示返回形参
go.file.watcher.go.imports.description=对 Go 文件运行 'goimports'
go.file.watcher.go.fmt.description=对 Go 文件运行 'go fmt'
go.file.watcher.golangci.description=在当前 Go 文件目录中运行 'golangci-lint'
go.before.check.in.show.fmt.error.button=详细信息(&D)…
go.completion.fill.all.fields.lookup.string=填充所有字段…
go.completion.fill.selected.fields.lookup.string=填充所选字段…
go.modules.dependency.diagram=Go 模块依赖关系图
go.converter.build.run.configuration.description='Go Build' 运行配置已更改。需要转换现有配置。
go.converter.single.file.run.configuration.description='Run single Go file' 运行配置已移除。需要转换现有配置。
go.converter.build.tags.description=Go 项目设置存储机制已更改，需要更新项目及其模块。
go.converter.sdk.description=Go 项目模型已更改，请更新项目及其模块
go.converter.project.model.description=Go 项目模型已更改，请更新项目及其模块
go.inspection.options.panel.import.path=导入路径
go.inspection.options.panel.function.name=函数名称
go.inspection.options.panel.string.methods=字符串方法
go.inspection.options.panel.reported.functions=报告的函数/方法: 
go.inspection.options.panel.receiver=接收器
go.inspection.options.panel.method.name=方法名称
go.inspection.options.panel.exclude=排除:
go.structure.view.show.package.structure.action.text=显示软件包结构
go.structure.view.private.members.filter.text=显示 private 成员
go.structure.view.exportability.sorter.text=按导出性排序
go.structure.view.method.location=在 {0} 中
go.sum.generated.sources.filter.notification.text=不应编辑该文件，因为该文件仅供 Go 工具使用。变更可能会导致构建进程中断。
go.modules.background.task.updating.dependencies.title=正在更新 Go 模块依赖项
go.modules.background.task.updating.dependencies.text=正在 {0} 个 ''go.mod'' {0,choice,0#文件|1#文件|2#文件} 上执行 ''go list''…
go.modules.unknown.dependencies.notification.text=完整的模块依赖项集合未知，某些特定于 Go 模块的功能可能不可用。
go.modules.unknown.dependencies.notification.tooltip=可能是由网络连接问题或显式 GOPROXY=off 导致。
go.modules.unknown.dependencies.notification.retry=重新运行 ''{0}''
go.modules.tree.structure.replaced=(已替换)
go.modules.tree.structure.replacement=替换: {0}
go.live.template.context.type.file.presentable.name=文件
go.live.template.context.type.type.presentable.name=类型
go.live.template.context.type.block.presentable.name=块
go.live.template.context.type.expression.presentable.name=表达式
go.live.template.context.type.tag.presentable.name=标记
go.live.template.context.type.tag.literal.presentable.name=标记文字
go.live.template.context.type.statement.presentable.name=语句
go.sdk.no.version.text=<无版本>
go.edit.settings.action.description=编辑 Go 特定的 {0}
go.new.project.step.web.group.name=Web
go.new.project.step.other.group.name=其他
project.files.and.vendor.scope.name=项目文件和供应商
go.project.configurable.name=Go
go.inspection.discarded.context.cancel.function=应该调用取消函数，而不是将其丢弃，以避免上下文泄漏
go.inspection.function.returns.without.calling.context.cancel.function=有一个执行路径没有调用此取消函数，从而导致上下文泄漏
go.inspection.execution.ends.without.context.cancel.function.after.instruction=执行可能在此指令后结束而不调用 ''{0}'' 函数，从而导致上下文泄漏
go.inspection.execution.ends.without.context.cancel.function.after.statement=执行可能在此 ''{0}'' 语句后结束而不调用 ''{1}'' 函数，从而导致上下文泄漏
go.inspection.problematic.execution.path.end=有问题的执行路径的结束
postfix.template.provider.name=Go
postfix.template.condition.error.name=错误
postfix.template.condition.error.expr.result.name=表达式包含错误结果
postfix.template.condition.array.name=数组
postfix.template.condition.slice.name=切片
postfix.template.condition.assignable.slice.name=可分配的切片
postfix.template.condition.map.name=映射
postfix.template.condition.channel.name=通道
postfix.template.condition.builtin.len.applicable.name=适用内置 len
postfix.template.condition.builtin.cap.applicable.name=适用内置 cap
postfix.template.condition.builtin.append.applicable.name=适用内置 append
postfix.template.condition.non.void.name=非 void
postfix.template.condition.comparable.to.nil.name=与 nil 相当
postfix.template.condition.number.name=数字
postfix.template.condition.boolean.name=布尔
postfix.template.condition.string.name=字符串
postfix.template.condition.floats.slice.name=float64s 的切片
postfix.template.condition.ints.slice.name=int 的切片
postfix.template.condition.strings.slice.name=字符串切片
postfix.template.condition.interface.impls.slice.name=排序接口实现的切片
postfix.template.condition.expr.in.if.with.missing.block.name=缺少块的 if 条件中的表达式
postfix.template.condition.slice.with.no.sort.name=没有专用排序函数的切片
filetype.go.time.description=Go 时间
filetype.go.tag.description=Go 标记
go.cannot.be.represented.by.type={0} 不能由类型 {1} 表示
go.value.cannot.be.represented.by.type={0} 的值不能由类型 {1} 表示
go.go.mod.retract.not.supported=自 Go 1.16 起开始支持 'retract'
go.error.go.embed.not.supported=自 Go 1.16 起支持 go:embed
go.error.go.embed.invalid.syntax.of.paths=路径模式语法无效
go.error.go.embed.must.be.above.var.declaration=go:embed 必须位于单个全局变量声明的上方
go.error.go.embed.var.has.wrong.type=go:embed's 变量必须为 'string'、'[]byte' 或 'embed.FS' 类型
go.error.go.embed.invalid.path.elements=路径不得包含 '.' 或 '..' 路径元素，也不得以前导斜杠开头
go.error.go.embed.unresolved.path=未解析路径
go.error.go.embed.empty.directory=无法嵌入空目录
go.error.go.embed.single.path.expected='string' 和 '[]byte' 类型的变量只能有一个路径模式
go.error.go.embed.path.must.resolve.to.file='string' 和 '[]byte' 类型的变量只能嵌入一个文件
go.error.go.embed.no.path.arguments=go:embed 后面应为路径模式
go.error.go.embed.file.must.import.embed=包含 go:embed 的 Go 文件必须导入 "embed" 软件包
go.error.go.embed.invalid.path.pattern=路径模式无效
go.fix.import.embed.package=导入 "embed"
go.fix.wrap.error.handling.in.closure=在闭包内部封装错误处理
go.fix.failed.to.handle.error=无法处理错误
go.fix.failed.to.introduce.variables.from.call=无法从调用引入变量
go.fix.failed.to.resolve.called.function.signature=无法从调用解析签名
go.fix.call.receiver.is.not.an.expression=意外的调用接收器，不是表达式
go.inspection.fail.now.in.non.test.goroutine=非测试 goroutine 中的 'FailNow'
go.inspection.fail.now.called.from.non.test.goroutine=必须从运行测试或基准测试的 goroutine 调用此方法
go.fix.replace.and.return=替换为 ''{0}'' 和 ''return''
filetype.go.plus.build.description=Go +build 约束
filetype.go.build.description=Go:build 约束
go.error.go.build.after.package=go:build 指令必须位于 package 子句前面
go.error.go.build.non.first.element=go:build 指令必须为代码行的第一个元素
go.error.go.build.without.plus.build=//go:build 注释没有 //+build 注释
go.error.go.build.and.plus.build.lines.dont.match=//+build 行不匹配 //go:build 条件
go.error.go.build.only.one.allowed=一个文件中只允许使用一条 //go:build 指令
go.error.go.build.expression.is.too.complex=表达式对于 //+build 行过于复杂
go.error.go.plus.build.can.be.removed=可以移除 //+build 注释
go.error.go.plus.build.can.be.converted.to.go.build=//+build 注释可以转换为 //go:build 指令
go.error.invalid.double.negation=双重求反无效
go.error.invalid.non.alphanumeric.character=非字母数字字符无效
go.fix.place.go.build.before.package=将 go:build 放在 package 前面
go.fix.add.plus.build.comments=添加 //+build 注释
go.fix.update.plus.build.comments=更新 //+build 注释
go.fix.remove.plus.build.comments=移除 //+build 注释
go.fix.convert.plus.build.comments.to.go.build.directive=将 //+build 注释转换为 //go:build 指令
go.fmt.formatting.service.error.title=无法在 {0} 上运行 gofmt

go.notification.file.is.ignored.because.cgo.mismatch.text=由于 cgo 支持不匹配，''{0}'' 被构建工具忽略
go.notification.file.is.ignored.because.os.mismatch.text=由于 OS 不匹配，''{0}'' 被构建工具忽略
go.notification.file.is.ignored.because.arch.mismatch.text=由于架构不匹配，''{0}'' 被构建工具忽略
go.notification.file.is.ignored.because.compiler.mismatch.text=由于编译器不匹配，''{0}'' 被构建工具忽略
go.notification.file.is.ignored.because.version.mismatch.text=由于 Go 版本不匹配，''{0}'' 被构建工具忽略
go.notification.file.is.ignored.because.custom.flag.text=由于自定义标志，''{0}'' 被构建工具忽略
go.notification.file.is.ignored.because.bad.syntax.text=由于语法错误，''{0}'' 被构建工具忽略
go.notification.file.is.ignored.because.non.go.file.text=由于不是 Go 文件，''{0}'' 被构建工具忽略
go.notification.enable.cgo.support.action.text=启用 cgo 支持
go.notification.disable.cgo.support.action.text=禁用 cgo 支持
go.notification.file.starts.with.dot.text=由于名称以 ''.'' 开头，''{0}'' 被构建工具忽略
go.notification.file.ignore.navigate.to.build.constraints.action.text=导航到构建约束
go.notification.file.ignore.navigate.to.cgo.import.action.text=导航到 cgo import
go.notification.rename.file.action.text=重命名文件
vgo.intention.add.or.update.go.version.fix.text=在 ''go.mod'' 中将 Go 版本设置为 {0}
vgo.intention.add.or.update.go.version.fix.family.name=在 'go.mod' 中添加或更新 Go 版本
go.external.system.auto.import.is.disabled=由于设置了 'external.system.auto.import.disabled' 注册表项，IDE 无法正常运行。请禁用此设置并重启 IDE。
go.modules.wizard.name=Go
go.wizard.name=Go (GOPATH)
go.settings.sdk.download.progress.copying.status=正在复制 SDK…
go.settings.sdk.download.progress.copying.detailed.status=正在复制 {0}…
go.debugger.custom.delve.notification=正在使用自定义 Delve 进行调试: {0}
go.debugger.custom.delve.extended.notification=正在使用自定义 Delve 进行调试: {0}。删除 ''dlv.path'' <a href=''customProperties''>自定义属性</a>并重启 IDE 以使用捆绑的 Delve。
go.execution.test.collecting.build.tags.progress.title=正在收集构建标记…
go.inspection.problem.possibly.unused.dependency=可能未使用的依赖项
go.refactoring.introduce.generating.code.template=正在生成代码模板…
go.empty.element.text=<空>
vgo.intention.run.why.command.fix.family.name=运行 'go mod why -m'
action.com.goide.vgo.actions.VgoVendorAction.description=在模块中运行 'go mod vendor'
action.com.goide.vgo.actions.VgoVendorAction.text=Go Mod Vendor
go.test.generate.fuzz.text=模糊处理
exportable.GoSdkList.presentable.name=已知的 Go SDK 路径列表
exportable.vgo.presentable.name=已知的 Go 相关环境变量列表
go.error.wsl.project.windows.sdk=无法使用 Windows SDK 编译 WSL 项目
go.error.windows.project.wsl.sdk=无法使用 WSL SDK 编译 Windows 项目
go.wsl.attach.host.group.name=WSL
go.wsl.resolving.user.home=正在 WSL 中解析用户主目录
go.wsl.sdk.unpack.error=解包命令失败，退出代码为 {0}
go.error.wsl.project.requires.wsl.sdk=WSL 中的项目需要 WSL 中的 Go SDK
go.error.wsl.sdk.cannot.be.used.for.windows.project=WSL 中的 Go SDK 不能用于 Windows 项目
go.error.wsl.project.requires.wsl.sdk.from.same.instance=WSL 中的项目需要来自同一个 WSL 实例的 Go SDK
action.DlvShowPointerAddressesToggleAction.text=显示指针地址
go.settings.debugger.show.pointer.addresses=显示指针地址
action.DlvShowTypesToggleAction.text=显示类型
go.settings.debugger.show.types=显示类型
go.fix.error.string.format=修正错误字符串格式
vgo.fix.delete.replacement=删除替换
go.fix.export.text=导出 {0}
go.fix.add.comment.name=添加注释
go.inspection.change.context.todo=考虑使用定义明确的上下文
go.inspection.usage.of.context.todo=context.TODO() 的用法
go.refactoring.implement.methods.preparing.template.progress.title=正在准备模板…
go.go.mod.retract.wrong.range.format=版本范围必须采用以下格式: '[start, end]'
go.fix.change.signature.to.expected.name=对预期签名的更改
go.run.target.project.sources.directory.label=项目源目录:
go.run.target.project.sources.directory.browsing.title=项目源
go.run.target.project.sources.description=目标上项目源的输出路径
go.debugger.failed.to.create.breakpoint=无法创建断点
go.debugger.failed.to.run.to.position=无法运行到位置
inlay.parameters.go.struct.unnamed.struct.fields=显示匿名字段的名称。
inlay.parameters.go.return.parameters=在 return 语句中显示形参名称。
go.run.target.compiled.executables.directory.label=经过编译的可执行文件目录:
go.run.target.compiled.executables.directory.browsing.title=经过编译的可执行文件
go.run.target.compiled.executables.description=目标上经过编译的可执行文件的输出路径
go.run.target.executable.path.title=Go 可执行文件
go.run.target.gopath.title=GOPATH
go.execution.dlv.not.found.for=找不到 {0}/{1} 的 Delve 可执行文件。通过在 ''帮助 | 编辑自定义属性'' 中添加 ''dlv.path=/path/to/delve'' 来指定 Delve 位置。
go.execution.dlv.not.found.for.target.platform=找不到目标平台的 Delve 可执行文件。通过在 '帮助 | 编辑自定义属性' 中添加 'dlv.path=/path/to/delve' 来指定 Delve 位置。
go.format.on.save.advertiser.notification.title=现在 Go 代码会在保存时进行格式化
go.format.on.save.advertiser.notification.content=每次保存 Go 文件时，IDE 都会自动对其进行格式化。您可以在设置中更改此行为。
go.format.on.save.advertiser.for.watchers.notification.content=每次保存 Go 文件时，IDE 都会自动对其进行格式化。此行为可能与某个已配置的 File Watcher 冲突。您可以在设置中进行更改。
go.format.on.save.advertiser.edit.actions.on.save.action.text=保存时编辑操作
go.format.on.save.advertiser.edit.file.watchers.action.text=编辑 File Watcher
go.edit.actions.on.save.action.text=保存时的操作…
go.edit.actions.on.save.action.description=您可以在保存时运行的编辑操作
go.refactoring.inline.options.dialog.name.label=如何执行内联重构？
go.refactoring.inline.options.dialog.all.remove=内联所有调用并移除声明(&A)
go.refactoring.inline.options.dialog.all.keep=内联所有调用并保留声明(&K)
go.refactoring.inline.options.dialog.this.keep=仅内联此调用并保留声明(&T)
go.refactoring.inline.command.name=内联函数/方法
go.refactoring.inline.cannot.inline.in.loop.condition=无法将内联重构应用于循环条件中的多行函数或软件包级别的 'var' 或 'const' 声明
go.refactoring.inline.cannot.inline.call.from.defer=无法将内联重构应用于来自 'defer' 语句的调用
go.refactoring.inline.cannot.inline.call.from.go=无法将内联重构应用于来自 'go' 语句的调用
go.refactoring.inline.cannot.inline.recursive.functions=无法将内联重构应用于递归函数
go.refactoring.inline.cannot.inline.many.returns=无法将内联重构应用于具有多个返回的函数
go.refactoring.inline.cannot.inline.no.body=无法将内联重构应用于没有主体的函数
go.refactoring.inline.defer.statements=该函数包含将在周围函数调用后执行的 defer 语句
go.notification.install.as.tool.action.text=作为命令行工具安装
go.error.annotator.method.cannot.have.type.parameters=方法不能有类型形参
go.terms.type.parameters=类型形参
go.error.annotator.constraint.outside.of.type.parameter=接口包括约束元素，只能在类型形参中使用
go.refactoring.introduce.collecting.free.vars=正在收集自由变量…
go.refactoring.introduce.analyzing.before.extraction=正在对代码进行提取前的分析…
go.error.annotator.constraint.elements.outside.of.type.parameter=接口包含约束{0,choice,1#元素|2#元素} {1}，只能在类型形参中使用
go.error.annotator.constraint.term.on.interface=~ 的使用无效（''{0}'' 为接口）
go.error.annotator.constraint.term.underlying.type.is.not.self=~ 的使用无效（''{0}'' 的基础类型不是 ''{0}''）
go.inspection.problem.duplicate.type.param=重复的类型形参 {0}
go.inspection.problem.incompatible.empty.type.set=类型未实现约束 {0}，因为<b color={1}>约束类型集为空</b>
go.inspection.problem.incompatible.not.comparable=类型未实现约束 {0}，因为<b color={1}>类型不可比较</b>
go.inspection.problem.incompatible.not.in.type.set=类型未实现约束 {0}，因为<b color={1}>类型未包括在类型集({2})中</b>
go.error.annotator.cannot.make.type.no.single.underlying.type=无法设为 {0}；类型集没有单个基础类型
action.GoToggleCachingAction.description=切换 Go 插件中的缓存
action.GoToggleCachingAction.text=切换 Go 插件缓存
action.GoToggleCachingAction.enableCaching=启用 Go 插件缓存
action.GoToggleCachingAction.disableCaching=禁用 Go 插件缓存
action.GoToggleCachingAction.cachingEnabled=Go 插件缓存已启用
action.GoToggleCachingAction.cachingDisabled=Go 插件缓存已禁用
go.error.annotator.list.of.type.arguments.must.not.be.empty=类型实参列表不得为空
go.execution.duplicate.file.error=文件已在列表中: {0}
go.inspection.problem.need.trailing.comma.in.type.parameters.list=类型形参列表中的换行符前面需要有尾随逗号
go.inspection.problem.need.trailing.comma.in.type.arguments.list=类型实参列表中的换行符前面需要有尾随逗号
go.microservices.http.server.endpoint.title=Go HTTP 服务器
go.inspection.problem.need.trailing.comma.in.index.expression=索引表达式中的换行符前面需要有尾随逗号
go.inspection.problem.type.parameters.are.not.supported=不支持类型形参
go.inspection.problem.invalid.argument.must.be.send.channel.type=必须为双向或仅发送通道
go.fix.delete.type.parameters.name=删除类型形参
go.error.annotator.function.type.cannot.have.type.parameters=函数类型不能有类型形参
go.error.annotator.cannot.use.generic.function.without.instantiation=未经不实例化就不能使用泛型函数
go.modules.unsupported.workspace.mode=Go SDK {0} 不支持 ''go.work'' 文件，请使用 Go 1.18 或更高版本
go.fix.add.square.brackets=添加方括号
go.error.annotator.use.of.generic.type.without.instantiation=在不实例化的情况下使用泛型
go.error.annotator.cannot.use.type.parameter.as.rhs.in.type.declaration=不能在类型声明中将类型形参用作 RHS
go.error.annotator.got.n.arguments.but.m.type.parameters=已获得 {0} 个实参，但有 {1} 个类型形参
go.go.mod.error.prohibited.directive=go.mod 文件中不允许使用指令
go.go.work.error.prohibited.directive=go.work 文件中不允许使用指令
go.error.go.embed.all.prefix.not.supported=路径模式无效，'all:' 前缀需要 Go 1.18
go.fix.configure.go.sdk.text=配置 Go SDK
go.quick.doc.keyword.resource.language.spec.label=Go 语言规范
go.quick.doc.keyword.resource.effective.go.label=Effective Go
go.quick.doc.keyword.resource.go.blog.label=Go 博客
go.error.annotator.generic.type.cannot.be.alias=泛型不能是别名
go.error.annotator.interface.method.must.have.no.type.parameters=接口方法不能有类型形参
go.quick.doc.channel.direction.label=通道方向:
go.quick.doc.channel.send.label=发送到通道
go.quick.doc.channel.receive.label=从通道接收
go.go.work.error.unresolved.path=未解析路径
go.fix.delete.type.arguments.name=删除类型实参
go.error.annotator.is.not.a.generic.type={0} 不是泛型类型
go.error.annotator.list.of.type.parameters.must.not.be.empty=类型形参列表不能为空
go.error.annotator.type.constraint.is.missing=缺少类型约束
go.error.annotator.func.literal.cannot.have.type.parameters=函数文字不能有类型形参
go.error.annotator.cannot.use.type.assertion.on.type.parameter=无法对类型形参值 {0} 使用类型断言
go.error.annotator.cannot.use.type.switch.on.type.parameter=无法对类型形参值 {0} 使用类型切换
go.error.annotator.type.cannot.be.declared.in.generic.function=无法在泛型函数中声明类型
go.error.annotator.type.cannot.be.declared.in.generic.method=无法在泛型方法中声明类型
go.error.parser.expected.or=应为 ''{0}'' 或 ''{1}''
go.inspection.problem.irregular.iota.usage=Irregular usage of 'iota'
go.quick.doc.methods.on.label=方法对象:
go.quick.doc.iota.example=例如，'const (C0 = iota; C1; C2)' 将打印 '0'、'1' 和 '2'。每次在代码中使用 'const' 时，计数都会重置为 '0'。要查看 'iota' 分配的常量的值，请将鼠标指针悬停在常量规范上。
go.inspection.unused.type.parameter.display.name=未使用的类型形参
go.inspection.unused.type.parameter.message=未使用的类型形参 {0}
go.error.annotator.cannot.embed.type.parameter=无法嵌入类型形参
go.error.annotator.embedded.type.cannot.be.a.type.parameter=嵌入的类型不能是类型形参
go.error.annotator.embedded.type.cannot.be.a.pointer.to.a.type.parameter=嵌入的类型不能是指向类型形参的指针
go.error.annotator.cannot.use.comparable.in.union=不能在联合中使用 comparable
go.error.annotator.cannot.use.type.embedding.comparable.in.union=不能在联合中使用 ''{0}'' (''{0}'' 会嵌入 comparable)
go.quick.doc.blank.identifier.hint=空白标识符 ('_') 可以赋给任何类型的任何值或用任何类型的值声明。空白标识符会被丢弃，不会被编译器使用。例如，当您想要捕获返回值但不打算在以后使用此值时，可以考虑使用空白标识符。
go.quick.doc.type.assertions.hint=类型断言用于检查变量是否为某种类型，并返回基础接口值。类型断言仅适用于接口。例如，在下面的代码中: 'var x interface{} = 42 t := x.(int)'，'x' 具有带基础 int 值  ('42') 的 'interface{}' 类型，'int' 是我们要检查的具体类型。如果我们打印 't'，输出将为 '42'。将具体类型更改为 'string' ('t := x.(string)') 将导致运行时宕机。类型断言可以返回两个值。例如，表达式 't, ok := x.(int)' 具有布尔值 'ok'，如果断言正确，则返回 'true'。如果 'ok' 为 'false'，则会将 't' 设置为零值，并且不会发生宕机。
go.quick.doc.composite.literal.hint=此复合文字会使用给定值分配新的 {0} 实例。
go.quick.doc.struct.literal.hint=您可以按顺序指定字段值，也可以使用其名称。
go.inspection.problem.invalid.conversion.type.comparable=不能在转换中使用 comparable 接口
go.inspection.problem.invalid.conversion.type.with.constraints=不能在转换中使用带有类型约束的接口
go.quick.doc.type.parameter.hint={0} 声明用于声明类型形参。这些类型形参会将 {0} 变为泛型。泛型 {0} 可以处理多种类型。可能的类型集由类型形参的约束控制。有关泛型的详细信息，请参阅 {1}
go.quick.doc.type.parameter.hint.hyperlink.text=教程: go.dev 泛型入门
go.quick.doc.type.parameter.in.method.hint=该方法为泛型，因为接收器的基类型为泛型类型。方法规范必须声明与接收器基本类型的类型形参相对应的类型形参。方法类型实参必须使用接收器基类型中使用的类型约束。有关泛型的详细信息，请参阅 {0}
go.usage.type.type.parameter.declaration=类型形参声明
go.go.work.multiple.use.directives=可以将多个 'use' 指令合并为一个
vgo.intention.merge.use.directives.family.name=将多个 'use' 指令合并为一个
go.quick.doc.empty.interface.hint=An empty interface 'interface{}' stands for a set of all types. A variable of the empty interface type can store a value of any type.
go.quick.doc.type.alias.hint=Type {0} is an alias of type {1}. These types are identical. For more information, see {2}
go.quick.doc.type.definition.hint=Type {0} is a new type with the underlying type {1}. These types are different. For more information, see {2}
go.quick.doc.type.alias.and.definition.hint.link.text=Go Spec: Type identity
go.app.engine.choose.file.action.text=选择文件…
go.quick.settings.file.watchers.text=保存时的操作…
go.inspection.problem.fuzzing.is.not.supported=Fuzzing is supported starting with Go 1.18
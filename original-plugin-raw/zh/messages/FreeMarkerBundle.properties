number=数字
identifier=标识符
filetype.ftl.description=FreeMarker 模板
directive.name.expected=应为指令名称
unmatched.directive.end=指令结尾不匹配
expression.expected=应为表达式
attribute.name.expected=应为特性名称
comment.end.expected=应为右侧 '#comment' 标签
closing.directive.expected.0=应为右侧 {0} 指令
variable.name.expected=应为变量名称
setting.name.expected=应为有效的设置名称
no.matching.0.directive=没有匹配的 {0} 指令
wellformedness.inspection.as.loop.variable.name.missing=缺少 'as' (循环变量名称)
wellformedness.inspection.parent.list.of.the.items.must.not.have.as=#items 的父级 #list 不得包含 "as {0}" 形参

freemarker.inspections.group=FreeMarker
ftl.wellformedness.inspection=指令格式不正确
ftl.references.inspection=未解析的引用
ftl.calls.inspection=无效的调用指令
ftl.import.calls.inspection=未解析的外部调用
ftl.deprecated.builtins.inspection=内置已弃用
ftl.types.inspection=不正确的表达式类型
ftl.file.references.inspection=未解析的文件引用
else.should.finish.if=else 指令应当为 if 指令中的最后一项
namespace.expected=应为命名空间
error.cannot.resolve.variable.0=无法解析变量 ''{0}''
error.cannot.resolve.function.0=无法解析函数 ''{0}''
error.cannot.resolve.parameter.0.of.macro.1=无法解析宏 ''{1}'' 的形参 ''{0}''
error.cannot.resolve.field.of=无法解析类 ''{1}'' 的字段或属性 ''{0}''
error.cannot.resolve.field=无法解析字段或属性 ''{0}''
error.cannot.resolve.method.of=无法解析类 ''{1}'' 的方法 ''{0}''
error.cannot.resolve.method=无法解析方法 ''{0}''
error.cannot.resolve.macro=无法解析宏 ''{0}''
expression.should.have.numeric.type=表达式应为数值类型，实际为 ''{0}''
expression.unexpected.type=意外类型: ''{0}''
expression.should.have.scalar.type=表达式应为标量类型，实际为 ''{0}''
expression.should.have.array.or.collection.type=表达式应为数组或集合类型，实际为 ''{0}''
expression.should.have.hash.type=表达式应为哈希或 ''Map'' 类型，实际为 ''{0}''
expression.should.have.namespace.type=应为命名空间，实际为 ''{0}''
expression.should.have.node.type=应为节点类型，实际为 ''{0}''
expression.should.have.macro.type=应为宏类型，实际为 ''{0}''
expression.should.have.boolean.type=应为布尔类型，实际为 ''{0}''

invalid.ftl.file=不是 FreeMarker 文件
invalid.relative.path=相对路径无效
absolute.refs.not.allowed=此处不允许绝对路径引用
directory.expected=应为目录

error.no.applicable.method={1} 中没有适用于 {2} 的方法 ''{0}''
error.static.member.expected=应为 static 成员
quickfix.convert.to.instance.family=转换为实例类型
quickfix.convert.to.instance=将 {0} 类型转换为实例一
error.multiple.overloaded.methods=多个重载方法 {0}
ftl.should.start.file=#ftl 指令应出现在模板最开头
default.value.should.occur.at.the.end=具有默认值的形参应出现在形参列表的末尾，应为 =
macro.function.nesting=#macro 和 #function 指令不应嵌套
unclosed.directive=未封闭指令
can.only.occur.inside=#{0} 只能出现在 #{1} 内部
can.only.occur.inside.or=#{0} 只能出现在 #{1} 或 #{2} 内部
wrong.closing.directive.name=闭合指令名称错误
recover.once=#recover 指令只能出现一次
recover.inside.attempt=#recover 指令只能在 #attempt 内部发生
recover.expected=#attempt 内部应为 #recover 指令

add.implicit.variable.fix.name=在注释中定义隐式变量
add.implicit.variable.fix.name.local=定义隐式变量(在当前文件中的注释中)
add.implicit.variable.fix.name.module.wide=在外部定义隐式变量(全局)
add.implicit.variable.fix.name.external=在外部定义隐式变量(仅此文件)
add.implicit.toplevel.variable.fix.name=指定要从中提取顶层属性和方法的类
add.implicit.toplevel.variable.fix.name.local=指定要从中获取顶层属性和方法的类(在当前文件中的注释中)
add.implicit.toplevel.variable.fix.name.external=指定要从中提取顶层属性和方法的类(外部)
choose.external.definitions.file=选择外部隐式定义文件

create.macro.or.function.from.usage=根据用法创建宏或函数
create.macro.from.usage=根据用法创建宏 ''{0}''
define.implicit.macro.from.usage=定义隐式宏 ''{0}''
create.function.from.usage=根据用法创建函数 ''{0}''
define.implicit.function.from.usage=定义隐式函数 ''{0}''

create.dynamic.method.or.property=创建动态方法或属性
create.dynamic.method=创建动态方法 ''{0}''

define.template.root.fix.name=定义模板根
define.template.root.fix.name.local=在当前文件的注释中定义模板根
define.template.root.fix.name.module.wide=在注释中定义模板根(全局)

variable.may.be.undefined=变量 ''{0}'' 可能未定义
undefined.mandatory.parameters=缺少必填形参: {0}
too.many.parameters=形参过多
type.mismatch=应为 ''{0}'' 类型，发现为 ''{0}''

change.macro.call.style.family=更改宏调用样式
change.macro.call.style.to.named=将宏调用更改为命名样式
change.macro.call.style.to.positinal=将宏调用更改为位置样式

type.name.variable=变量
type.name.parameter=形参
type.name.macro=宏
type.name.function=函数
type.name.template=导入的模板

builtin.not.applicable=类型不匹配: 内置 ''{0}'' 不适用于 ''{1}''
unknown.builtin=未知的内置 ''{0}''
wrong.builtin.parameter.types=内置形参类型错误
builtin.should.have.params=内置 ''{0}'' 应具有形参
builtin.should.not.have.params=内置 ''{0}'' 不应具有形参
deprecated.builtin.usage=内置 ''{0}'' 已弃用
replace.with.0=替换为 {0}
smart.completion.inference.hint=按 {0} 可尝试从用法中推断类型
smart.completion.roots.hint=按 {0} 可从现有 includes/imports 中推断根
global.completion.all.ftl.files.hint=再次按 {0} 可查看所有 FreeMarker 文件

fix.import.or.include.file=导入或包含 FreeMarker 文件
fix.include.file=包含 ''{0}''
fix.import.file=导入 ''{0}''
choose.declaration.type=选择声明类型
choose.declaration.type.implicit.or.explicit=要添加显式声明(在当前文件中)还是隐式声明(在由 IntelliJ IDEA 自动导入的特殊文件中)?
implicit=隐式(&I)
explicit=显式(&E)

error.format.string.syntax=格式字符串应使用语法 mminMmax，例如 m1M42
error.mixing.camelcase.lowercase=不允许在一个模板中混用驼峰拼写法和小写标识符

reference.inspection.cb.public.fields.are.exposed=public 字段被公开
suppress.inspection.quick.fix.name=禁止检查
reference.inspection.unknown.enum.constant.ref=类 {0} 中的未知枚举常量 ''#ref''
reference.inspection.accessing.non.public.class=访问非 public 类 ''{0}''

validator.description=FreeMarker
validator.progress.text=正在检查 FreeMarker 文件…
parsing.error.format.name.string.literal.expected=应为格式名称字符串文字


freemarker.intentions.category=FreeMarker
loop.variable=循环变量
composite.type.unknown=未知
hash.type=哈希
namespace.type=命名空间
component.sequence.type={0} 序列
sequence.type=序列
date.type=日期
markup.output.type=标记输出
node.type=节点
absolute.refs.not.allowed=此处不允许绝对路径引用
add.implicit.toplevel.variable.fix.name=指定要从中提取顶层属性和方法的类
add.implicit.toplevel.variable.fix.name.external=指定要从中提取顶层属性和方法的类(外部)
add.implicit.toplevel.variable.fix.name.local=指定要从中获取顶层属性和方法的类(在当前文件中的注释中)
add.implicit.variable.fix.name=在注释中定义隐式变量
add.implicit.variable.fix.name.external=在外部定义隐式变量(仅此文件)
add.implicit.variable.fix.name.local=定义隐式变量(在当前文件中的注释中)
add.implicit.variable.fix.name.module.wide=在外部定义隐式变量(全局)
attribute.name.expected=应为特性名称
builtin.not.applicable=类型不匹配\: 内置 ''{0}'' 不适用于 ''{1}''
builtin.should.have.params=内置 ''{0}'' 应具有形参
builtin.should.not.have.params=内置 ''{0}'' 不应具有形参
can.only.occur.inside=\#{0} 只能出现在 \#{1} 内部
can.only.occur.inside.or=\#{0} 只能出现在 \#{1} 或 \#{2} 内部
change.macro.call.style.family=更改宏调用样式
change.macro.call.style.to.named=将宏调用更改为命名样式
change.macro.call.style.to.positinal=将宏调用更改为位置样式
choose.declaration.type=选择声明类型
choose.declaration.type.implicit.or.explicit=要添加显式声明(在当前文件中)还是隐式声明(在由 IntelliJ IDEA 自动导入的特殊文件中)?
choose.external.definitions.file=选择外部隐式定义文件
closing.directive.expected.0=应为右侧 {0} 指令
color.settings.braces=大括号
color.settings.brackets=中括号
color.settings.comma=逗号
color.settings.comment=评论
color.settings.directive=指令
color.settings.dot=点
color.settings.escape=转义
color.settings.keyword=关键字
color.settings.number=数值
color.settings.operation.sign=运算符号
color.settings.parentheses=圆括号
color.settings.reference=引用
color.settings.semicolon=分号
color.settings.string=字符串
comment.end.expected=应为右侧 '\#comment' 标签
component.sequence.type={0} 序列
composite.type.unknown=未知
create.dynamic.method=创建动态方法 ''{0}''
create.dynamic.method.or.property=创建动态方法或属性
create.function.from.usage=根据用法创建函数 ''{0}''
create.macro.from.usage=根据用法创建宏 ''{0}''
create.macro.or.function.from.usage=根据用法创建宏或函数
date.type=日期
default.value.should.occur.at.the.end=具有默认值的形参应出现在形参列表的末尾，应为 \=
define.implicit.function.from.usage=定义隐式函数 ''{0}''
define.implicit.macro.from.usage=定义隐式宏 ''{0}''
define.template.root.fix.name=定义模板根
define.template.root.fix.name.local=在当前文件的注释中定义模板根
define.template.root.fix.name.module.wide=在注释中定义模板根(全局)
deprecated.builtin.usage=内置 ''{0}'' 已弃用
directive.name.expected=应为指令名称
directory.expected=应为目录
else.should.finish.if=else 指令应当为 if 指令中的最后一项
empty.name=null
error.cannot.resolve.field=无法解析字段或属性 ''{0}''
error.cannot.resolve.field.of=无法解析类 ''{1}'' 的字段或属性 ''{0}''
error.cannot.resolve.function.0=无法解析函数 ''{0}''
error.cannot.resolve.macro=无法解析宏 ''{0}''
error.cannot.resolve.method=无法解析方法 ''{0}''
error.cannot.resolve.method.of=无法解析类 ''{1}'' 的方法 ''{0}''
error.cannot.resolve.parameter.0.of.macro.1=无法解析宏 ''{1}'' 的形参 ''{0}''
error.cannot.resolve.variable.0=无法解析变量 ''{0}''
error.format.string.syntax=格式字符串应使用语法 mminMmax，例如 m1M42
error.mixing.camelcase.lowercase=不允许在一个模板中混用驼峰拼写法和小写标识符
error.multiple.overloaded.methods=多个重载方法 {0}
error.no.applicable.method={1} 中没有适用于 {2} 的方法 ''{0}''
error.static.member.expected=应为 static 成员
explicit=显式(&E)
expression.expected=应为表达式
expression.should.have.array.or.collection.type=表达式应为数组或集合类型，实际为 ''{0}''
expression.should.have.boolean.type=应为布尔类型，实际为 ''{0}''
expression.should.have.hash.type=表达式应为哈希或 ''Map'' 类型，实际为 ''{0}''
expression.should.have.macro.type=应为宏类型，实际为 ''{0}''
expression.should.have.namespace.type=应为命名空间，实际为 ''{0}''
expression.should.have.node.type=应为节点类型，实际为 ''{0}''
expression.should.have.numeric.type=表达式应为数值类型，实际为 ''{0}''
expression.should.have.scalar.type=表达式应为标量类型，实际为 ''{0}''
expression.unexpected.type=意外类型\: ''{0}''
filetype.ftl.description=FreeMarker 模板
fix.import.file=导入 ''{0}''
fix.import.or.include.file=导入或包含 FreeMarker 文件
fix.include.file=包含 ''{0}''
freemarker.inspections.group=FreeMarker
freemarker.intentions.category=FreeMarker
ftl.calls.inspection=无效的调用指令
ftl.deprecated.builtins.inspection=内置已弃用
ftl.file.references.inspection=未解析的文件引用
ftl.import.calls.inspection=未解析的外部调用
ftl.language.inspection=内置错误
ftl.references.inspection=未解析的引用
ftl.should.start.file=\#ftl 指令应出现在模板最开头
ftl.types.inspection=不正确的表达式类型
ftl.wellformedness.inspection=指令格式不正确
global.completion.all.ftl.files.hint=再次按 {0} 可查看所有 FreeMarker 文件
hash.type=哈希
identifier=标识符
implicit=隐式(&I)
invalid.ftl.file=不是 FreeMarker 文件
invalid.relative.path=相对路径无效
loop.variable=循环变量
macro.function.nesting=\#macro 和 \#function 指令不应嵌套
markup.output.type=标记输出
namespace.expected=应为命名空间
namespace.type=命名空间
no.matching.0.directive=没有匹配的 {0} 指令
node.type=节点
number=数字
parsing.error.format.name.string.literal.expected=应为格式名称字符串字面量
quickfix.convert.to.instance=将类型转换为实例类型
quickfix.convert.to.instance.family=转换为实例类型
recover.expected=\#attempt 内部应为 \#recover 指令
recover.inside.attempt=\#recover 指令只能在 \#attempt 内部发生
recover.once=\#recover 指令只能出现一次
reference.inspection.accessing.non.public.class=访问非 public 类 ''{0}''
reference.inspection.cb.public.fields.are.exposed=public 字段被公开
reference.inspection.unknown.enum.constant.ref=类 {0} 中的未知枚举常量 ''\#ref''
replace.with.0=替换为 {0}
sequence.type=序列
setting.name.expected=应为有效的设置名称
smart.completion.inference.hint=按 {0} 可尝试从用法中推断类型
smart.completion.roots.hint=按 {0} 可从现有 include/import 中推断根
suppress.inspection.quick.fix.name=禁止检查
too.many.parameters=形参过多
type.mismatch=应为 ''{0}'' 类型，实际为 ''{1}''
type.name.function=函数
type.name.macro=宏
type.name.parameter=形参
type.name.template=导入的模板
type.name.variable=变量
unclosed.directive=未闭合的指令
undefined.mandatory.parameters=缺少必填形参\: {0}
unknown.builtin=未知的内置 ''{0}''
unmatched.directive.end=指令结尾不匹配
validator.description=FreeMarker
validator.progress.text=正在检查 FreeMarker 文件…
variable.may.be.undefined=变量 ''{0}'' 可能未定义
variable.name.expected=应为变量名称
wellformedness.inspection.as.loop.variable.name.missing=缺少 'as' (循环变量名称)
wellformedness.inspection.parent.list.of.the.items.must.not.have.as=\#items 的父级 \#list 不得包含 "as {0}" 形参
wrong.builtin.parameter.types=内置形参类型错误
wrong.closing.directive.name=闭合指令名称错误

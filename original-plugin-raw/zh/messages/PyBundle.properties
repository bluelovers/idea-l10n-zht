### Quick fixes ###
QFIX.add.import.add.import=添加 "''{0}''"

#PyImplementMethodsQuickFix
QFIX.NAME.implement.methods=实现 abstract 方法

QFIX.NAME.change.signature=Change signature
QFIX.change.signature.of=更改 {0} 的签名

QFIX.FAMILY.NAME.rename.element=重命名元素
QFIX.NAME.rename.element=重命名该元素

QFIX.ignore.unresolved.reference=忽略未解析的引用
QFIX.ignore.unresolved.reference.0=忽略未解析的引用 ''{0}''
QFIX.mark.all.unresolved.attributes.of.0.as.ignored=将 ''{0}'' 所有未解析的特性标记为已忽略
QFIX.fill.paragraph=填充段落
QFIX.remove.trailing.blank.lines=移除尾随的空白行
QFIX.generating.skeletons.for.binary.module=正在为二进制模块生成框架
QFIX.generate.binary.stubs=生成二进制存根
QFIX.reformat.file=重新格式化该文件
QFIX.bold.html.text=<b>{0}</b>

# Namespace packages
QFIX.mark.as.namespace.package=将目录 ''{0}'' 标记为命名空间软件包
QFIX.change.to.same.directory.import=更改为同一目录导入

# Intentions: INTN

# Conflict checker
CONFLICT.name.obscured.by.local.definitions=名称 ''{0}'' 被局部定义掩盖
CONFLICT.name.obscured.cannot.convert=名称 ''{0}'' 被掩盖。无法转换。
CONFLICT.occurrence.pl=匹配项

##########################################################################################################################
# Unwrap
##########################################################################################################################
unwrap.if=解开 if…
unwrap.while=解开 while…
unwrap.for=解开 for…
unwrap.with=解开 with…
unwrap.try=解开 try…
unwrap.else=解开 else…
unwrap.elif=解开 elif…
remove.else=移除 else…
remove.elif=移除 elif…

INSP.GROUP.python=Python

# Refactoring
refactoring.will.not.be.accessible=您在尝试移动的成员依赖于在此重构后无法访问的 ''{0}''
refactoring.error.file.exists=文件"{0}" 已存在
refactoring.error.directory.exists=目录 "{0}" 已存在

# introduce
refactoring.introduce.name.error=错误的名称
refactoring.introduce.selection.error=无法使用所选元素执行重构

# introduce variable
refactoring.introduce.variable.dialog.title=提取变量
refactoring.introduce.variable.scope.error=该名称与现有变量或形参冲突

# introduce constant
refactoring.introduce.constant.dialog.title=提取常量
refactoring.introduce.constant.scope.error=已在范围中声明该名称

# introduce parameter
refactoring.extract.parameter.dialog.title=提取形参
refactoring.introduce.parameter.dialog.title=引入形参

# pull up
refactoring.pull.up.dialog.title=向上拉取成员至
refactoring.pull.up.dialog.move.members.to.class=将成员移至类
refactoring.pull.up.dialog.members.to.be.moved=将移动以下成员
refactoring.pull.up.error.cannot.perform.refactoring.not.inside.class=无法执行向上拉取成员：不在此类中
refactoring.pull.up.error.cannot.perform.refactoring.no.base.classes=类 {0} 没有超类，或者所有超类都不能用于重构

# inline
refactoring.inline.local.multiassignment=使用多个赋值定义

# inline function
refactoring.inline.function.title=内联函数
refactoring.inline.this.only=仅内联此调用并保留声明
refactoring.inline.function=内联函数 {0}
refactoring.inline.method=内联方法 {0}
refactoring.inline.all.keep.declaration=内联所有调用并保留声明
refactoring.inline.all.remove.declaration=内联所有调用并移除声明
refactoring.inline.all.border.title=内联
refactoring.inline.label.function=函数 {0}
refactoring.inline.label.method=方法 {0}
refactoring.name.label.text={0} 有 {1} 个匹配项{2, choice, 0#|1#}
refactoring.inline.function.command.name=正在内联 {0}
refactoring.inline.function.function.to.inline=要内联的函数
refactoring.inline.function.invocations.to.be.inlined=要在 {0} 文件中内联的调用
refactoring.inline.function.is.decorator=函数 {0} 用作装饰器，无法内联。不会移除函数定义
refactoring.inline.function.is.reference=函数 {0} 用作引用，无法内联。不会移除函数定义
refactoring.inline.function.uses.unpacking=函数 {0} 使用实参解包，无法内联。不会移除函数定义
refactoring.inline.function.generator=无法内联生成器
refactoring.inline.function.async=无法内联异步函数
refactoring.inline.function.constructor=无法内联构造函数调用
refactoring.inline.function.builtin=无法内联内置函数
refactoring.inline.function.special.method=无法内联特殊方法
refactoring.inline.function.skeleton.only=无法内联二进制模块中的函数
refactoring.inline.function.decorator=无法内联包含装饰器的函数
refactoring.inline.function.self.referrent=无法内联引用自身的函数
refactoring.inline.function.star=无法内联包含 * 实参的函数
refactoring.inline.function.overrides.method=无法内联覆盖其他方法的方法
refactoring.inline.function.is.overridden=无法内联被覆盖的方法
refactoring.inline.function.global=无法内联包含全局变量的函数
refactoring.inline.function.nonlocal=无法内联包含非局部变量的函数
refactoring.inline.function.nested=无法内联包含其他函数声明的函数
refactoring.inline.function.interrupts.flow=无法内联中断控制流的函数

# extract method
refactoring.extract.method=提取方法
refactoring.extract.method.error.bad.selection=无法使用所选元素执行提取方法
refactoring.extract.method.error.name.clash=该方法名称与现有名称冲突
refactoring.extract.method.error.returns=无法提取代码段内包含返回指令的方法
refactoring.extract.method.error.local.variable.modifications=无法从代码段内包含局部变量修改的表达式执行重构
refactoring.extract.method.error.local.variable.modifications.and.returns=无法从代码段内包含局部变量修改和返回指令的表达式执行重构
refactoring.extract.method.error.empty.fragment=无法从空代码段执行重构

refactoring.extract.method.error.class.level=无法在类级别执行重构

# extract superclass
refactoring.extract.super.target.path.outside.roots=该目标目录在项目外部。必须在内容根内
refactoring.extract.super.target.class.already.exists=此模块中已存在类 ''{0}''
refactoring.extract.super.name.0.must.be.ident=名称 ''{0}'' 无效。必须为有效的 Python 标识符
refactoring.extract.super.class.no.members.allowed=无法提取任何成员

# move
refactoring.move.choose.destination.file.title=选择目标文件
refactoring.move.error.destination.file.contains.class=目标文件已包含名称为 ''{0}'' 的类
refactoring.move.error.destination.file.contains.function=目标文件已包含名称为 ''{0}'' 的函数
refactoring.move.error.destination.file.contains.global.variable=目标文件已包含名称为 ''{0}'' 的全局变量
refactoring.move.error.cannot.use.module.name=不能在导入中使用模块名称 ''{0}''


# move module members (top-level)
refactoring.move.module.members=移动模块成员
refactoring.move.module.members.dialog.title=移动模块成员
refactoring.move.module.members.dialog.table.title=批量移动(&M)
refactoring.move.module.members.dialog.description.class=移动类 {0}
refactoring.move.module.members.dialog.description.function=移动函数 {0}
refactoring.move.module.members.dialog.description.variable=移动全局变量 {0}
refactoring.move.module.members.dialog.description.selection=移动所选元素
refactoring.move.module.members.error.cannot.place.elements.into.nonpython.file=无法将元素放入非 Python 文件中
refactoring.move.module.members.error.selection=无法使用所选元素执行重构

# Make function top-level
refactoring.make.method.top.level.dialog.title=使之为顶层方法
refactoring.make.method.top.level.dialog.description=将方法 {0} 移至顶层

refactoring.make.local.function.top.level.dialog.title=使之为顶层局部函数
refactoring.make.local.function.top.level.dialog.description=将局部函数 {0} 移至顶层

refactoring.make.function.top.level.error.nonlocal.writes=无法移动包含非局部写入的函数
refactoring.make.function.top.level.error.self.reads=无法移动外部范围中包含 "self" 形参用法的函数
refactoring.make.function.top.level.error.outer.scope.reads=无法移动引用外部范围中的名称的方法
refactoring.make.function.top.level.error.private.attributes=无法移动引用私有实例特性的方法
refactoring.make.function.top.level.error.attribute.writes=无法移动写入实例特性的方法
refactoring.make.function.top.level.error.method.calls=无法移动调用该类其他方法的方法
refactoring.make.function.top.level.error.special.usage.of.self=无法移动包含 "self" 形参特殊用法的方法



#change signature
refactoring.change.signature.usage.view.declarations.header=要重构的函数
refactoring.change.signature.dialog.validation.name.defined=名称已在范围中定义
refactoring.change.signature.dialog.validation.function.name=函数名称不正确
refactoring.change.signature.dialog.validation.parameter.name=形参名称不正确
refactoring.change.signature.dialog.validation.multiple.star=不允许多个 * 实参
refactoring.change.signature.dialog.validation.multiple.double.star=不允许多个 ** 实参
refactoring.change.signature.dialog.validation.default.missing=缺少默认值
refactoring.change.signature.dialog.validation.parameter.missing=缺少形参名称
refactoring.change.signature.dialog.default.value.checkbox=在签名中使用默认值：
refactoring.change.signature.dialog.name.label=名称:
refactoring.change.signature.find.usages.of.base.class=类 {1} 的方法 {0}\n\
重写类 {2} 的方法。\n\
要重构基方法吗?
refactoring.change.signature.error.wrong.caret.position.method.name=文本光标应置于要重构的方法的名称处
refactoring.change.signature.error.lambda.call=文本光标位于 lambda 调用上
refactoring.change.signature.error.tuple.parameters=该函数包含元组形参
refactoring.change.signature.error.not.under.source.root=该函数不在源根下
refactoring.change.signature.suggested.callSite.value=调用点的值
refactoring.change.signature.suggested.callSite.value.optional=调用点的可选值

refactoring.convert.package.to.module.error.not.empty.package=软件包 "{0}" 不为空

refactoring.occurrences.count={0}（{1} 个匹配项）
refactoring.introduce.field.setup.method=setUp() 方法
refactoring.introduce.field.cannot.be.used.in.static.methods=static 方法中不能使用引入字段重构
refactoring.introduce.field.not.in.class=无法引入该字段: 不在类中
refactoring.rename.containing.file.with.the.following.name.to=将具有以下名称的包含文件重命名为:
refactoring.rename.containing.file.title=重命名包含文件
refactoring.rename.containing.file=重命名包含文件
refactoring.rename.containing.file.entity.name=包含文件
refactoring.rename.parameter.in.hierarchy.to=将层次结构中的形参重命名为:
refactoring.rename.parameter.entity.name=形参
refactoring.rename.parameters.title=重命名形参
refactoring.rename.parameters.in.hierarchy=重命名层次结构中的形参
refactoring.rename=重命名
refactoring.rename.not.valid.identifier=名称 ''{0}'' 不是有效的 Python 标识符。无法更新 ''{1}'' 中的 import 语句
refactoring.rename.inheritor.classes.with.the.following.names.to=将具有以下名称的继承者类重命名为：
refactoring.rename.inheritors.title=重命名继承者
refactoring.rename.inheritors=重命名继承者
refactoring.rename.inheritor.class.entity.name=继承者类

python.run.select.script=选择脚本
python.run.configuration=Python 运行配置
python.run.python=Python

python.testing.target.not.provided=未提供该目标
python.testing.provide.qualified.name=提供函数、类或模块的限定名称
python.testing.pattern.can.only.be.used=模式只能用于匹配一个文件夹中的多个文件。无法对一个文件使用模式。
python.testing.cant.resolve=无法解析 {0}。尝试移除配置并再次生成
python.testing.cant.find.where.declared=在声明 {0} 的位置找不到文件。确保它存在于项目根中
python.testing.cant.get.importable.name=无法获得 {0} 的可导入名称。它是项目中的 Python 文件吗?

runcfg.tests.cant_rerun=无法重新运行测试，因为无法解析测试 ID。尝试删除运行配置，然后点击右键以创建新配置。
runcfg.tests.empty_suite=空套件

### doctest run conf
runcfg.doctest.display_name=Doctest
runcfg.python_tests.config.additionalArguments=其他实参
runcfg.python_tests.config.target=目标
runcfg.python_tests.config.targetType=目标类型

### nosetests run conf
runcfg.nosetests.display_name=Nosetest
runcfg.nosetests.config.regexPattern=正则表达式模式

### pytest run conf
runcfg.pytest.display_name=pytest

# deprecated start
# deprecated end

runcfg.pytest.config.keywords=关键字
runcfg.pytest.config.parameters=形参

group.advanced.settings.python=Python
advanced.setting.python.pytest.swapdiff=Pytest: 在差异中交换实际/预期值
advanced.setting.python.pytest.show_summary=Pytest: 不添加 "--no-header --no-summary -q"


runcfg.autodetect.display_name=自动检测

### trial run conf
runcfg.trial.display_name=Twisted Trial

### test run configuration
runcfg.test.display_name=Python 测试
runcfg.test.description=PyCharm 支持 Python 框架
runcfg.test.suggest.name.in.path={0} ({1} 内)
runcfg.test.suggest.name.in.python={1} 的 {0}


### tox
runcfg.tox.runner=tox 运行程序
runcfg.tox=tox

### unittest run configuration
runcfg.unittest.config.pattern=模式

runcfg.unittest.display_name=Unittest
runcfg.unittest.no_script_name=请指定脚本名称
runcfg.unittest.no_module_name=请指定模块的限定名称
runcfg.unittest.no_class_name=请指定类名
runcfg.unittest.no_method_name=请指定方法名称
runcfg.unittest.no_folder_name=请指定包含测试的文件夹
runcfg.unittest.dlg.test_script_label=脚本:
runcfg.unittest.dlg.class_label=类:
runcfg.unittest.dlg.method_label=方法:
runcfg.unittest.dlg.function_label=函数:
runcfg.unittest.dlg.folder_path=文件夹：
runcfg.unittest.dlg.test_type_title=测试:
runcfg.unittest.dlg.all_in_folder_title=文件夹中的所有
runcfg.unittest.dlg.all_in_script_title=脚本
runcfg.unittest.dlg.test_class_title=类
runcfg.unittest.dlg.test_method_title=方法
runcfg.unittest.no_valid_sdk=请选择有效的 Python 解释器
runcfg.unittest.no_module_sdk=请选择包含有效 Python SDK 的模块
runcfg.unittest.no_sdk=请指定 Python SDK
runcfg.unittest.dlg.select.folder.path=选择文件夹路径：
runcfg.unittest.dlg.select.script.path=选择脚本路径：
runcfg.unittest.dlg.interpreter_options_title=解释器选项：
runcfg.unittest.suggest.name.in.class={0} ({1} 内)
runcfg.unittest.suggest.name.in.script={0} ({1} 内)
runcfg.unittest.suggest.name.in.folder={0} ({1} 内)
runcfg.labels.script_parameters=形参(&P):
runcfg.labels.environment_variables=环境变量(&E)：
runcfg.labels.interpreter=使用指定的解释器(&U)：
runcfg.labels.use.sdk.of.module=使用模块 SDK：
runcfg.labels.interpreter_options=解释器选项(&O)：
runcfg.labels.working_directory=工作目录(&W):
runcfg.captions.script_parameters_dialog=输入脚本形参
runcfg.captions.interpreter_options_dialog=输入解释器选项
runcfg.labels.python.interpreter=Python 解释器(&P)：
runcfg.labels.add.content.roots.to.pythonpath=将内容根添加到 PYTHONPATH
runcfg.labels.add.source.roots.to.pythonpath=将源根添加到 PYTHONPATH
runcfg.labels.path.mappings=路径映射
runcfg.labels.project=项目(&J):
runcfg.labels.script.path=脚本路径
runcfg.labels.module.name=模块名称
runcfg.labels.custom.name=自定义
runcfg.labels.execution=执行
python.sdk.error.invalid.interpreter.name=Python 解释器名称 ''{0}'' 无效!
sdk.select.path=选择 Python 解释器
runcfg.unittest.dlg.pattern=模式:

runcfg.testing.no.test.framework=在所选解释器中未找到 {0} 运行程序

runcfg.error.message.failed.to.find.free.socket.port=找不到可用的套接字端口
runcfg.error.message.cannot.find.python.interpreter=找不到此运行配置的 Python 解释器

# Consoles messages
python.console=Python 控制台
python.console.history.root=Python 控制台
python.console.run.anything.provider=运行 Python 控制台
python.console.not.supported=不支持 {0} 解释器的 Python 控制台

#Buildout
buildout=Buildout
buildout.unresolved.part.inspection=Buildout 配置未解析的部分
buildout.unresolved.part.inspection.msg=未解析的元件引用
buildout.configurable.enable.buildout.support.checkbox.text=启用 buildout 支持 (&E)
runcfg.unittest.dlg.test_function_title=函数
run.configuration.remote.debug.name=Python 远程调试
run.configuration.remote.debug.visible.name=Python 调试服务器
run.configuration.type.description=启动服务器进行远程调试
run.configuration.show.command.line.action.name=显示调试控制台

unable.to.stop=无法停止当前正在运行的进程。先手动终止此进程。

#Debug

debug.popup.title.step.into.function=单步进入函数

debug.notification.group=Python 调试器
debug.notification.title.connection.failed=连接 Python 调试器失败

remote.debug.server.hint=启动此调试配置以启动调试服务器。
remote.debug.server.hint1.5=更新脚本：
remote.debug.server.hint2=1. 将 pydevd-pycharm.egg 从 PyCharm 安装目录添加到 Python 路径或执行：
remote.debug.server.hint3=pip 安装 pydevd-pycharm
remote.debug.server.hint4=2. 添加以下命令以连接至调试服务器：
remote.debug.port=端口:
remote.debug.local.host=IDE 主机名：
remote.debug.redirect.output=将输出重定向到控制台
remote.debug.suspend.on.connect=连接后挂起

# Debug VFS

python.debug.remote.name=PyRemoteDebug
filetype.python.debug.remote.description=远程调试

python.sdk.getting.remote.interpreter.version=正在获取远程解释器版本
python.sdk.directory.macro.description=此目录包含为项目选择的 Python 解释器
python.sdk.scanning.installed.packages=正在扫描已安装的软件包…
python.sdk.updater.notifications.group.title=Python SDK 更新程序
python.sdk.updating.skeletons=正在更新框架…
python.sdk.unpacking.pre.generated.skeletons=正在解压缩预生成的框架…
python.sdk.popup.interpreter.settings=解释器设置…
python.sdk.popup.add.interpreter=添加解释器…
python.sdk.switch.to=切换到 {0}
python.sdk.installing=正在安装 {0}
python.sdk.downloading=下载中{0}
python.sdk.running=正在运行 {0}
python.sdk.installing.windows.warning=Windows 可能需要您批准后才能安装 Python。请检查任务栏。
python.sdk.select.conda.path.title=选择 Conda 可执行文件路径
python.sdk.conda.path=Conda 可执行文件：
python.sdk.select.location.for.conda.title=选择 Conda 环境的位置
python.sdk.environment.yml.chooser=选择 environment.yml
python.sdk.environment.yml.label=environment.yml
python.sdk.creating.conda.environment.sentence=创建 Conda 环境
python.sdk.creating.conda.environment.title=正在创建 Conda 环境
python.sdk.add.python.interpreter.title=添加 Python 解释器
python.sdk.python.interpreter.title.0=Python 解释器: {0}
python.sdk.new.environment.kind=新 {0} 环境
python.sdk.next=下一个
python.sdk.previous=上一个
python.sdk.finish=完成
python.sdk.setting.up.pipenv.sentence=正在设置 pipenv 环境
python.sdk.setting.up.pipenv.title=正在设置 Pipenv 环境
python.sdk.install.requirements.from.pipenv.lock=Pipfile.lock 中的安装要求
python.sdk.pipenv.executable.not.found=找不到 Pipenv 可执行文件
python.sdk.pipenv.executable=Pipenv 可执行文件：
python.sdk.pipenv.select.executable.title=选择 Pipenv 可执行文件的路径
python.sdk.pipenv.associated.project=关联项目:
python.sdk.pipenv.associated.module=关联模块:
python.sdk.pipenv.execution.exception.no.project.message=无法找到与此 Pipenv 环境关联的项目
python.sdk.pipenv.execution.exception.no.pipenv.message=无法找到 Pipenv
python.sdk.pipenv.execution.exception.error.running.pipenv.message=运行 Pipenv 时出错
python.sdk.pipenv.quickfix.fix.pipenv.name=修复 Pipenv 解释器
python.sdk.pipenv.quickfix.use.pipenv.name=使用 Pipenv 解释器
python.sdk.pipenv.pip.file.lock.not.found=找不到 Pipfile.lock
python.sdk.pipenv.pip.file.lock.out.of.date=Pipfile.lock 过期
python.sdk.pipenv.pip.file.notification.content=运行 <a href='#lock'>pipenv lock</a> 或 <a href='#update'>pipenv update</a>
python.sdk.pipenv.pip.file.notification.locking=正在锁定 Pipfile
python.sdk.pipenv.pip.file.notification.updating=正在更新 Pipenv 环境
python.sdk.pipenv.pip.file.watcher=Pipfile 观察程序

python.sdk.file.not.found=找不到文件 {0}
python.sdk.cannot.execute=无法执行 {0}
python.sdk.pipenv.has.been.selected=已添加 Pipenv 解释器，选择解释器列表中的 ''{0}''
python.sdk.there.is.no.interpreter=无解释器
python.sdk.no.interpreter.configured.warning=未为此项目配置 Python 解释器
python.sdk.no.interpreter.selection=未选择 Python 解释器
python.sdk.choose.valid.interpreter=选择有效的 Python 解释器
python.sdk.common.options.environment=环境
python.sdk.rendering.project.default=项目默认设置
python.sdk.rendering.project.default.0=项目默认值 ({0})
python.sdk.failed.to.install.title=无法安装 {0}
python.sdk.installation.has.been.cancelled.title={0} 安装已被取消
python.sdk.directory.not.found=找不到目录 {0}
python.sdk.failed.to.create.interpreter.title=无法创建解释器
python.sdk.can.t.obtain.python.version=无法获取 Python 版本
python.sdk.executable.not.found.header=找不到 Python 可执行文件。选择以下选项之一:
python.sdk.executable.not.found.option.specify.path=点击 {0} 以指定 python.exe 在文件系统中的路径
python.sdk.executable.not.found.option.download.and.install=点击 {0} 从 python.org 下载并安装 Python ({1})
python.sdk.admin.permissions.needed.consider.creating.venv=<html><strong>注</strong>: 您需要具备管理员权限才能为此解释器安装软件包。不妨改为按项目创建虚拟环境。</html>
python.sdk.try.to.install.python.manually=尝试从 https://www.python.org 手动安装 Python。
python.sdk.consider.installing.python.manually=不妨从 https://www.python.org 手动安装 Python。
python.sdk.some.installed.python.components.might.get.inconsistent.after.cancellation=取消后，某些已安装的 Python 组件可能会变得不一致。
python.sdk.failed.to.install.timed.out=已超时
python.sdk.failed.to.install.exit.code=退出代码 {0}
python.sdk.invalid.python.sdk=无效的 Python SDK
python.sdk.cannot.setup.sdk=无法\n\
在 {0} 设置 python SDK。\n\
此 SDK 似乎无效。

# SDK / skeletons
sdk.some.skeletons.failed=无法生成某些框架
sdk.gen.cleaning.up=正在清理框架…
sdk.gen.launching.generator=正在启动框架生成器…
sdk.gen.reloading=正在重新加载生成的框架…
sdk.gen.unpacking.prebuilt=正在解压缩预构建框架…
sdk.gen.updating.interpreter=正在更新 Python 解释器
sdk.scanning.installed.packages=正在扫描已安装的软件包
sdk.gen.stubs.for.binary.modules=生成二进制模块 {0} 的存根
sdk.gen.failed.notification.title=无法刷新远程解释器的框架
sdk.gen.cannot.create.skeleton.dir=无法创建框架目录 {0}
sdk.updating.interpreter.paths=正在更新解释器路径…
sdk.updating.interpreter.version=正在更新解释器版本…

# Active SDK configurable and related dialogs
active.sdk.dialog.show.all.item=全部显示…
active.sdk.dialog.project.interpreter=Python 解释器：
active.sdk.dialog.project.interpreter.path.mappings=路径映射：
active.sdk.dialog.project.interpreter.path.mappings.default.project.error=打开或创建项目以配置映射

sdk.details.step.add=添加…
sdk.details.step.show.all=全部显示…

sdk.details.dialog.title=Python 解释器
sdk.details.dialog.hide.all.virtual.envs=隐藏与其他项目关联的虚拟环境
sdk.details.dialog.show.interpreter.paths=显示所选解释器的路径
sdk.details.dialog.error.duplicate.name=为解释器指定唯一名称

sdk.edit.dialog.title=编辑 Python 解释器
sdk.edit.dialog.associate.virtual.env.with.path=关联此虚拟环境与 {0}
sdk.edit.dialog.associate.virtual.env.current.project=关联此环境与当前项目
sdk.edit.dialog.specify.interpreter.path=指定解释器路径

sdk.paths.dialog.title=解释器路径
sdk.paths.dialog.reload.paths=重新加载路径列表
sdk.paths.dialog.added.by.user.suffix=（用户已添加）
sdk.paths.dialog.removed.by.user.suffix=（用户已移除）

sdk.create.venv.dependencies.label=依赖项:
sdk.create.venv.dependencies.chooser=选择 requirements.txt 或 setup.py

sdk.create.venv.dialog.label.inherit.global.site.packages=继承全局站点软件包
sdk.create.venv.conda.dialog.label.location=位置:
sdk.create.venv.conda.dialog.label.python.version=Python 版本:

# remote interpreters
remote.interpreter.configure.title=配置远程 Python 解释器
remote.interpreter.configure.path.title=选择 Python 解释器
remote.interpreter.configure.temp.files.path.title=为 PyCharm 帮助程序选择文件夹
remote.interpreter.default.interpreter.path=/usr/bin/python
remote.interpreter.wsl.default.interpreter.path=/usr/bin/python
remote.interpreter.docker.default.interpreter.path=python
remote.interpreter.unspecified.interpreter.path=指定 Python 解释器路径
remote.interpreter.unspecified.temp.files.path=为 PyCharm 帮助程序指定路径
remote.interpreter.configure.path.label=Python 解释器路径：
remote.interpreter.configure.temp.files.path.label=PyCharm 帮助程序路径：
remote.interpreter.configure.ssh.run_as_root_via_sudo.checkbox=使用此解释器通过 sudo 以根权限执行代码
remote.interpreter.configure.ssh.run_as_root_via_sudo.help=仅在通过 SSH 连接启动远程解释器时才调用 Sudo。这些文件将通过用户权限被复制到远程服务器。
remote.interpreter.unsupported.python.sdk.type=不受支持的 Python SDK 类型
remote.interpreter.support.is.not.available={0} 支持不可用。\n\
请检查相应插件。
remote.interpreter.remote.server.permissions=无法浏览远程服务器。确保您具备权限。
remote.interpreter.accessing.remote.interpreter.progress.title=正在访问远程解释器

# CommandLine
commandLine.inspection.name=不正确的 CLI 语法
commandLine.inspection.badCommand=命令错误或未知。确保存在此命令。
commandLine.inspection.badOption=选项错误或未知。确保存在此选项。
commandLine.inspection.badArgument=实参不能具有此值。使用自动补全检查可能的值的列表。
commandLine.inspection.excessArgument=实参过多或此处无法使用实参
# What to display of user entered junk
commandLine.commandNotFound={0}：找不到命令

# Window with actions
# "X" button title
windowWithActions.closeWindow=关闭窗口
# "Stop" button title
windowWithActions.stopProcess=停止当前运行的进程

formatter.imports.panel.title=导入
formatter.imports.panel.optimize.imports=优化 import
formatter.imports.panel.sort.imports=对 import 语句排序
formatter.imports.panel.sort.names.in.from.imports=对 "from" 导入中的导入名称排序
formatter.imports.panel.from.imports.structure.title="from" 导入结构
formatter.imports.panel.from.imports.leave.as.is=保持原样
formatter.imports.panel.from.imports.join.with.same.source=使用相同的源联接导入
formatter.imports.panel.from.imports.always.split=始终拆分导入
formatter.imports.panel.sort.by.type=在组中分别对 plain 导入和 "from" 导入进行排序
formatter.imports.panel.sort.case.insensitively=不区分大小写排序

formatter.panel.dict.alignment.label=字典对齐：
formatter.panel.add.trailing.line.feed=在文件末尾添加换行

formatter.panel.use.continuation.indent.for.title=为此内容使用继续缩进
formatter.panel.use.continuation.indent.for.parameters=方法声明参数
formatter.panel.use.continuation.indent.for.arguments=方法调用实参
formatter.panel.use.continuation.indent.for.collection.literals=集合和推导

formatter.left.bracket = 左中括号
formatter.around.eq.in.named.parameter = 在命名形参中的 = 周围
formatter.around.eq.in.keyword.argument = 在关键字实参中的 = 周围
formatter.braces = 大括号
formatter.before.backslash = '\' 之前
formatter.before.hash = '#' 之前
formatter.after.hash = '#' 之后
formatter.around.top.level.imports = 在顶层导入后：
formatter.after.local.imports=在本地导入后面：
formatter.before.first.method=在第一个方法前面：
formatter.around.top.level.classes.and.function=围绕顶层类和函数：
formatter.around.multiplicative.operators=乘法运算符 (*, @, /, %)
formatter.around.power.operator=幂运算符 (**)
formatter.single.clause.statements=单子句语句
formatter.multi.clause.statements=多子句语句
formatter.force.new.line.after.colon=在冒号后强制换行
formatter.align.when.multiline=多行时对齐
formatter.collections.and.comprehensions=集合和推导
formatter.from.import.statements="From" Import 语句
formatter.from.import.statements.force.parentheses.if.multiline=如有多行，强制使用括号
formatter.from.import.statements.force.comma.if.multline=如有多行，强制使用尾随逗号
formatter.dictionary.literals=字典文字
formatter.hang.closing.brackets=挂起右中括号

smartKeys.insert.backslash.in.statement.on.enter=在语句内按 Enter 时插入反斜杠
smartKeys.insert.self.in.method=定义方法时插入 'self'
smartKeys.insert.type.placeholder.in.docstring.stub=在文档注释存根中插入类型占位符

show.expression.type.no.expression.found=找不到表达式
remote.interpreter.failed.to.obtain.credentials=无法获取 Python SDK {0} 的连接凭据

action.SetNextStatement.text=跳转到光标(&J)
action.SetNextStatement.description=跳转到文本光标所在的行
action.StepIntoMyCode.text=单步执行我的代码
action.StepIntoMyCode.description=跳到已执行的下一行，并忽略库
action.PyConvertPackageToModuleAction.text=转换为 Python 模块
action.PyConvertPackageToModuleAction.description=创建同名模块，并将 __init__.py 的内容移至该模块
action.PyConvertModuleToPackage.text=转换为 Python 软件包
action.PyConvertModuleToPackage.description=创建同名的软件包，并将模块内容移至其 __init__.py
action.PyDebugger.ViewAsGroup.text=作为...查看
action.PyDebugger.ViewArray.text=作为数组查看
action.PythonGenerateDictionaries.text=生成 Python 拼写检查器字典
group.PyPackagingMenu.text=打包
action.CleanPyc.text=清除 Python 编译文件
action.CleanPyc.description=删除所选目录及其子目录中已编译的字节码文件
action.CleanPyc.status.bar.text.deleted.bytecode.files=已删除 {0} 个字节码{0, choice, 0#文件|1#文件|2#文件}
action.CleanPyc.progress.title.cleaning.up.pyc.files=正在清理 .pyc 文件…
action.PySyncPythonRequirements.text=同步 Python 要求…
action.PySyncPythonRequirements.description=同步 Python 要求文件与项目中使用的软件包
action.CompuleQrc.text=编译 .qrc 文件
action.NewPythonPackage.text=Python 软件包
action.NewPythonPackage.description=在其中创建新目录和 __init__.py
action.PyConsoleRenameAction.text=重命名控制台
action.ExecuteInPyConsoleAction.text=在控制台中执行所选内容
action.ExecuteInPyConsoleAction.description=在 Python/Django 控制台中执行选定的代码段
action.com.jetbrains.python.console.RunPythonOrDebugConsoleAction.text=Python 或调试控制台
action.com.jetbrains.python.console.RunPythonOrDebugConsoleAction.description=允许在运行调试会话时快速运行 Python 控制台或调试控制台
action.ForceStepInto.text=强制单步执行 (_R)
action.ForceStepInto.description=步入，忽略库、构造函数等步进筛选器。
configurable.Tab.display.name=Buildout
configurable.PyConsoleOptionsConfigurable.display.name=控制台
configurable.PyConsoleOptionsConfigurable.child.display.name=Python 控制台
configurable.BuildoutConfigurable.display.name=Buildout
configurable.BuildoutModulesConfigurable.display.name=Buildout 支持
configurable.PySmartKeysOptions.display.name=Python
configurable.PyContentEntriesModuleConfigurable.display.name=项目结构
configurable.PythonContentEntriesConfigurable.display.name=项目结构
configurable.PyDependenciesConfigurable.display.name=项目依赖项
configurable.PyIntegratedToolsConfigurable.display.name=Python 集成工具
configurable.PyIntegratedToolsModulesConfigurable.display.name=Python 集成工具
configurable.PythonSdkEditorTab.display.name=Python SDK
configurable.PyDebuggerConfigurable.display.name=Python 调试器
configurable.PyActiveSdkModuleConfigurable.python.interpreter.display.name=Python 解释器
configurable.PyLanguageCodeStyleSettingsProvider.display.name=Python
flask.name=Flask
settings.default.remote.interpreter=默认 Python 远程解释器
action.DumbAware.PydevConsoleRunnerImpl.text.stop.console=停止控制台
action.DumbAware.PydevConsoleRunnerImpl.description.stop.python.console=停止 Python 控制台
action.DumbAware.ConcurrencyToolWindowPanel.text.stop.process=停止进程
action.DumbAware.ConcurrencyToolWindowPanel.description.stop.process=停止进程
action.AnActionButton.text.use.conda.package.manager=使用 Conda 软件包管理器
action.AnActionButton.text.show.early.releases=显示早期版本
action.PyManagePackages.text=管理 Python 软件包…
action.RunPythonToolwindowAction.text=Python 控制台

# qt actions
qt.error.failed.run.qt.designer=无法运行 Qt 设计器：{0}
qt.qrc.compiler.select.output.path=选择输出目录:
qt.qrc.compile.files=编译 {0} .qrc 文件
qt.qrc.compile=编译 {0}
qt.compile.qrc.file=编译 .qrc 文件
qt.run.tab.title.compile.qrc=编译 .qrc
qt.run.error=运行 {0} 出错：{1}
qt.cannot.find.pyrcc4.or.pysidercc=找不到所选 Python 解释器的 pyrcc4 或 pyside-rcc
qt.run.designer.error=错误
qt.ui.designer.form.filetype.description=Qt UI Designer 窗体
qt.ui.designer.form.filetype.display.name=Qt UI Designer 窗体

python.module.name=Python 模块
python.module.description=Python 模块用于开发 <b>Python</b> 应用程序。
python.module.description.extended=支持的技术包括 <b>Django、Google App Engine、Mako、Jinja2</b> 等等。

action.create.python.file.title=Python 文件
action.create.python.file.description=从指定的模板创建 Python 文件
acton.run.file.in.python.console.title=运行 Python 控制台中的文件
action.run.file.in.python.console.description=运行 Python 控制台中的当前文件

buildout.facet.title=Buildout 支持
buildout.configurable.choose.a.buildout.script=选择 Buildout 脚本
buildout.configurable.select.the.target.script=选择将调用代码的目标脚本
buildout.color.comment=注释
buildout.color.key.value.separator=键/值分隔符
buildout.color.value=值
buildout.color.key=键
buildout.color.section.name=节名
buildout.config=Buildout 配置
buildout.config.language=Buildout 配置
buildout.config.script.name.validation.error.message=请指定 Buildout 脚本
buildout.config.script.file.invalid.message=无效脚本文件 ''{0}''

code.insight.goto.superclass.attribute.chooser.title=选择超类特性

code.insight.select.methods.to.override=选择要重写的方法
code.insight.select.methods.to.implement=选择实现的方法
code.insight.stub.package.advertiser.notifications.group.title=Python 存根软件包广播程序
code.insight.create.test=创建测试
code.insight.select.target.directory=选择目标目录
code.insight.encoding.comment.format=编码注释格式：
code.insight.select.default.encoding=选择默认编码： 
code.insight.stub.forced.packages.are.not.installed.message=存根{0,choice,1#软件包|2#软件包} {1} {0,choice,1#未|2#未}安装。{0,choice,1#它|2#它们}{0,choice,1#包含|2#包含}提升代码洞察所需的类型提示。
code.insight.stub.checked.packages.are.not.installed.message=存根{0,choice,1#软件包|2#软件包} {1} {0,choice,1#未|2#未}安装。
code.insight.stub.packages.ignored.notification.content=建议的 {0} {1,choice,1#与|2#与}您的当前环境不兼容。\n\
{1,choice,1#此|2#这些}存根{1,choice,1#软件包|2#软件包}将被移除和忽略，直到新版本发布。
code.insight.stub.packages.install.requirements.fix.name=安装存根{0,choice,1#软件包|2#软件包}
code.insight.type.hints.are.not.installed=未安装类型提示
code.insight.install.type.hints.content=它们可以使代码洞察更出色。
code.insight.install.type.hints.action=安装存根软件包
code.insight.ignore.type.hints=忽略
code.insight.ignore.packages.qfix=忽略 {0,choice, 1#软件包|2#软件包}
configurable.pipenv.auto.detected=已自动检测：{0}
configurable.choose.path.to.the.package.requirements.file=选择软件包要求文件的路径:
configurable.choose.working.directory=选择工作目录:
configurable.select.working.directory=选择工作目录

console.waiting.execution.result=正在等待执行结果
console.getting.from.runtime=正在从 Python 运行时获取{0}
console.getting.completion=补全
console.getting.documentation=文档
console.getting.frame.variables=框架变量
console.getting.variable.value=变量值
console.getting.array=数组
console.getting.table.data=表数据
console.evaluating.expression.in.console=正在控制台中评估表达式
console.connecting.to.debugger=正在连接到调试器
console.changing.variable=正在更改变量
console.interrupting.execution=正在中断执行
console.close.console.communication=关闭控制台通信
console.executing.code.in.console=正在执行控制台中的代码…
console.new.console.description=创建新的 python 控制台
console.new.console=新建控制台
console.error.connecting.debugger=连接调试器出错
console.cannot.connect.to.debugger=无法连接到调试器
console.attach.debugger.description=对控制台中执行的代码启用追踪
console.attach.debugger=附加调试器
console.restarting.console=正在重启控制台
console.stopping.console=正在停止控制台
connecting.to.console.progress=正在连接到控制台…
connecting.to.console.title=连接控制台
console.show.variables.title=显示变量
console.show.variables.description=显示活动控制台变量
console.executing.dataviewer.command="正在执行 DataViewer 命令"
console.table.failed.to.load=无法加载:

form.debugger.save.call.signatures=保存调用签名

compile.cython.extensions.title=编译 Cython 扩展
compile.cython.extensions.help=运作方式
compile.cython.extensions.install=安装
compile.cython.extensions.notification=Python 调试器扩展可用
compile.cython.extensions.error=编译 Cython 扩展错误

create.python.file.action.new.python.file=新建 Python 文件
create.python.file.action.python.file=Python 文件
create.python.file.action.python.unit.test=Python 单元测试
create.python.file.action.python.stub=Python 存根
create.python.file.script.action=创建 Python 脚本 {0}

debugger.attach.to.process.filter.names=<html>为<b>附加到进程</b>显示名称中包含这些内容的进程：</html>
debugger.attach.to.process.failed.to.find.free.socket.port=找不到可用的套接字端口
debugger.watch.return.values.description=启用监视，以查看所执行函数返回的值
debugger.exception.breakpoint.ignore.library.files=忽略库文件
debugger.exception.breakpoint.on.raise=引发时
debugger.exception.breakpoint.on.termination=终止时
debugger.exception.breakpoint.type=Python 异常断点
debugger.exception.breakpoint.activation.policy=激活策略
debugger.exception.breakpoint.any.exception=任何异常
debugger.line.breakpoint.type=Python 行断点
debugger.delete.signature.cache=删除缓存
debugger.simplified.view.description=禁用监视类、函数和模块对象
debugger.simplified.view.text=简化变量视图
debugger.data.view.colored=已着色
debugger.data.view.close.selected.viewer=关闭所选查看器
debugger.data.view.close.viewer=关闭查看器
debugger.data.view.open.new.container.viewer=打开新容器查看器
debugger.data.view.view.new.container=查看新容器
debugger.data.view.data=数据
debugger.data.view.close=关闭
debugger.data.view.resize.automatically=自动调整大小
debugger.data.view.colored.cells=已着色单元
debugger.data.view.failed.to.evaluate.expression=无法评估表达式 {0}
debugger.data.view.type.is.not.supported=不支持 {0}
debugger.data.view.empty.tab=空
debugger.numeric.view.as.dataframe=作为 DataFrame 查看
debugger.numeric.view.as.array=作为数组查看
debugger.numeric.view.as.series=作为系列查看
debugger.stepping.filter=步进筛选器
debugger.stepping.filter.specify.pattern=指定 glob 模式（允许使用 '*'、'?' 和 '[seq]'，分号 ';' 用作名称分隔符）：
debugger.stepping.no.script.filters=未配置脚本筛选器
debugger.sending.close.message=正在向 Python 控制台发送关闭消息…
debugger.waiting.to.finish=正在等待 Python 控制台进程结束…
debugger.variables.loading.policy=变量加载策略
debugger.variables.loading.synchronously.text=同步
debugger.variables.loading.synchronously.description=同步加载变量值
debugger.variables.loading.asynchronously.text=异步
debugger.variables.loading.asynchronously.description=异步加载变量值
debugger.variables.loading.on.demand.text=按需
debugger.variables.loading.on.demand.description=按需加载变量值
debugger.variables.view.loading.timed.out=加载超时
debugger.variables.view.switch.to.loading.on.demand=切换为按需加载
debugger.variables.view.warning.message=无法加载多个变量的值  
debugger.exception.breakpoint.select.exception.class=选择异常类
debugger.watch.show.return.values=显示返回值
debugger.data.view.connected.to.python.console=已连接到 Python 控制台
debugger.data.view.connected.to.debug.session=已连接到调试会话 ''{0}''
debugger.data.view.empty.text=运行 Python 控制台或调试器以查看可用数据
debugger.stack.frame.special.variables=特殊变量
debugger.stack.frame.return.values=返回值
debugger.stack.frame.frame.not.available=<框架不可用>
debugger.stack.frame.unable.to.display.frame.variables=无法显示框架变量
debugger.stack.frames.not.available.in.non.suspended.state=框架在未挂起的状态下不可用
debugger.test.failed.caption=测试失败
debugger.error.in.test.setup.or.teardown.caption=设置或删除测试时出错
debugger.remote.port.out.of.boundaries=端口号超出界限

debugger.dataviewer.action.export.name=导出…
debugger.dataviewer.action.export.dialog.description=保存到
debugger.dataviewer.export.error.title=表导出失败
debugger.dataviewer.export.error.invalid.filepath=无效文件路径
debugger.dataviewer.export.error.invalid.filepath.content=文件路径 ''{0}'' 无效
debugger.dataviewer.export.error.unhandled=未处理的错误
debugger.dataviewer.export.error.unhandled.content=无法导出到 ''{0}'':\n\
{1}
debugger.dataviewer.notification.group.title=数据查看器错误
debugger.dataviewer.action.copy.name=复制
debugger.dataviewer.action.set.filter.name=设置筛选器…
debugger.dataviewer.action.set.filter.description=筛选列 ''{0}''
debugger.dataviewer.action.set.filter.use.regex=使用正则表达式
debugger.dataviewer.action.set.filter.button.set=设置
debugger.dataviewer.action.set.filter.item.expression=表达式
debugger.dataviewer.action.set.filter.item.substring=子字符串
debugger.dataviewer.action.set.filter.help.expression=<html>使用 <b>{0}</b> 作为 lambda 函数的变量</html>
debugger.dataviewer.action.set.filter.ad.controls=按 Enter 键应用
debugger.dataviewer.action.goto.dialog.title=转到
debugger.dataviewer.action.goto.dialog.label=行:列
debugger.dataviewer.action.copy.properties.name=复制到剪贴板设置
debugger.dataviewer.action.copy.properties.dialog.title=复制到剪贴板设置
debugger.dataviewer.action.copy.properties.include.header=包含标头
debugger.dataviewer.action.copy.properties.include.indices=包含索引
debugger.dataviewer.action.copy.properties.separator=分隔符:
debugger.dataviewer.action.copy.update.message=复制到剪贴板
debugger.dataviewer.action.remove.filter.name=移除筛选器
debugger.dataviewer.action.open.in.editor.name=在编辑器选项卡中打开
debugger.dataviewer.modifier.error=修饰符错误: {0}
debugger.dataviewer.header.filter.hint={0}: {1}
debugger.dataviewer.header.filter.hint.mode.expression=表达式
debugger.dataviewer.header.filter.hint.mode.regex=正则表达式
debugger.dataviewer.header.filter.hint.mode.substring=子字符串

debugger.remote.waiting.for.process.connection=正在等待进程连接…
debugger.remote.waiting.for.connection=正在等待连接
debugger.cython.python.run.configuration.should.be.selected=应选择 Python 运行配置
debugger.cython.extension.speeds.up.python.debugging=Cython 扩展加速 Python 调试
debugger.cython.extension.permission.denied=权限被拒绝
debugger.cython.extension.non.zero.exit.code=非零退出代码 ({0}):\n\
{1}
debugger.cython.please.enter.your.password.to.compile.cython.extensions=请输入密码以编译 cython 扩展:
debugger.warning.message=此选项可能会减慢调试器的速度
debugger.connected.to.pydev.debugger.build=已连接到 pydev 调试器(内部版本号 {0})
debugger.warning.wrong.debugger.version=警告: 调试器版本错误。使用 PyCharm 安装文件夹中的 pycharm-debugger.egg\n\
或执行: ''pip install pydevd-pycharm~=%{0}''
debugger.pydev.console.pause.the.process.to.use.command.line=暂停进程以使用命令行。
debugger.debug.process.disconnected=已断开连接
debugger.debug.process.running=进程正在运行
debugger.remote.starting.debug.server.at.port=正在端口 {0} 上启动调试服务器
debugger.use.the.following.code.to.connect.to.the.debugger=使用以下代码连接到调试器: 

python.local.attach.group.name=Python

pydev.console.runner.settings=设置
pydev.console.runner.error.running.console=运行控制台出错
pydev.console.runner.python.console.debugger=Python 控制台调试器
pydev.console.runner.unknown.error=未知错误
pydev.console.console.process.terminated.with.error=控制台进程因错误而终止：\n\
{0}{1}
pydev.console.console.process.terminated.with.exit.code=控制台进程终止，退出代码为 {0}，输出：{1}
pydev.console.couldnt.connect.to.console.process=无法连接到控制台进程。
pydev.console.debugger.connected=\n\
调试器已连接。\n\

pydev.console.couldnt.read.integer.value.from.stream=无法读取流中的整数值
pydev.console.python.interpreter.is.not.selected=未选择 Python 解释器。请先安装 Python 解释器。

external.documentation.python.plugin=Python 外部文档
external.documentation.pycharm=外部文档
external.documentation.edit.documentation.url=编辑文档 URL
external.documentation.title=Python 外部文档
external.documentation.configure.description=模块 {0} 未配置外部文档 URL。\n\
要立即配置吗?
external.documentation.column.name.module=模块名称
external.documentation.column.name.url.path.pattern=URL/路径模式


python.colors.python=Python
python.colors.type.annotation=类型注解
python.colors.class.definition=类定义
python.colors.decorator=装饰器
python.colors.built.in.name=内置名称
python.colors.special.names.usage=特殊名称//用法
python.colors.special.names.definition=特殊名称//定义
python.colors.keyword.argument=关键字实参
python.colors.parameters.self.parameter=形参//'self' 形参
python.colors.parameters.parameter=形参//形参
python.colors.functions.method.call=函数//方法调用
python.colors.functions.nested.function.definition=函数//嵌套函数定义
python.colors.functions.function.call=函数//函数调用
python.colors.functions.function.definition=函数//函数定义
python.colors.braces.and.operators.dot=大括号和运算符//点
python.colors.braces.and.operators.comma=大括号和运算符//逗号
python.colors.braces.and.operators.braces=大括号和运算符//大括号
python.colors.braces.and.operators.brackets=大括号和运算符//中括号
python.colors.braces.and.operators.parentheses=大括号和运算符//圆括号
python.colors.braces.and.operators.operation.sign=大括号和运算符//运算符号
python.colors.docstring.tag=Docstring//标签
python.colors.docstring.text=Docstring//文本
python.colors.string.f.string.format.specifier.start=字符串//格式化字符串//格式说明符开始
python.colors.string.f.string.type.conversion=字符串//格式化字符串///类型转换
python.colors.string.f.string.expression.braces=字符串//格式化字符串///表达式大括号
python.colors.string.escape.sequence.invalid=字符串//转义序列//无效
python.colors.string.escape.sequence.valid=字符串//转义序列//有效
python.colors.string.text.unicode=字符串//文本 (unicode)
python.colors.string.binary.bytes=字符串//二进制（字节）
python.colors.line.comment=行注释
python.colors.keyword=关键字
python.colors.number=数字

python.new.project.synchronization.not.configured.dialog.title=未配置同步
python.new.project.synchronization.not.configured.dialog.message=本地/远程同步配置不正确。\n\
{0}\n\
您可能需要手动同步本地项目和远程项目。\n\
\n\
是否继续?\n\
\n\
选择 ''是'' 将保留配置不当的映射，选择 ''否'' 将开始手动配置过程。

python.new.project.remote.path.not.provided=未提供远程路径
python.new.project.more.settings=更多设置(&E)
python.new.project.install.failed.title=安装 {0} 失败
python.new.project.error.solution.another.sdk=选择另一个 SDK

python.project.view.remote.libraries=远程库
python.project.view.py.skeletons=二进制框架
python.project.view.typeshed.stubs=Typeshed 存根
python.project.view.user.skeletons.node=扩展定义

python.packaging.installing.packaging.tools=正在安装打包工具…
python.packaging.installing.packages=正在安装软件包…
python.packaging.warning=警告
python.packaging.create.setup.py=创建 setup.py
python.packaging.failed.to.run.task=无法运行任务：{0}
python.packaging.run.setup.py.task=运行 setup.py 任务…
python.packaging.expand.options=展开选项 >>
python.packaging.collapse.options=<< 折叠选项
python.packaging.run.setup.task.0=运行安装任务 {0}
python.packaging.enter.setup.py.task=输入 setup.py 任务名称
python.packaging.no.tasks.found=找不到任务
python.packaging.command.line=命令行
python.packaging.install=安装
python.packaging.choose.packages.to.install=选择要安装的软件包
python.packaging.removing.conda.channel=移除 Conda 通道
python.packaging.adding.conda.channel=添加 Conda 通道
python.packaging.failed.to.install.packaging.tools.title=无法安装 Python 打包工具
python.packaging.install.packaging.tools=安装打包工具

# Example of produced message:
#    You are attempting to uninstall MarkupSafe package which is required for Jinja2 package
#
#    Do you want to proceed?
python.packaging.dialog.description.attempt.to.uninstall.for.one.dependent.package.single.package.description={1} 需要 {0} 软件包
python.packaging.dialog.description.attempt.to.uninstall.for.one.dependent.package=您将要卸载 {0} {1, choice, 1#软件包|2#软件包}\n\
\n\
是否继续?

# Example of produced message:
#    You are attempting to uninstall packages which are required for another packages.
#
#    Jinja2 -> Flask
#    muffin -> muffin-jinja2
#
#    Do you want to proceed?
python.packaging.dialog.description.attempt.to.uninstall.for.several.dependent.packages.single.package.description={0} -> {1}
python.packaging.dialog.description.attempt.to.uninstall.for.several.dependent.packages=您将要卸载其他软件包所需的软件包。\n\
\n\
{0}\n\
\n\
是否继续?

python.packaging.notification.description.details.link=详细信息…
python.packaging.notification.description.installed.all.requirements=已安装所有要求
python.packaging.notification.description.installed.packages=已安装软件包: {0}
python.packaging.notification.description.installed.python.packaging.tools=已安装 Python 打包工具
python.packaging.notification.description.uninstalled.packages=已卸载软件包: {0}
python.packaging.notification.title.error.occurred={0}: 发生错误。
python.packaging.notification.title.install.packages.failed=安装软件包失败
python.packaging.notification.title.packages.installed.successfully=已成功安装软件包
python.packaging.notification.title.packages.uninstalled.successfully=已成功卸载软件包
python.packaging.notification.title.uninstall.packages.failed=卸载软件包失败
python.packaging.progress.text.installing.specific.package=正在安装软件包 ''{0}''…
python.packaging.progress.title.installing.packages=正在安装软件包
python.packaging.progress.title.uninstalling.packages=正在卸载软件包
python.packaging.failed.to.install.packages.title=无法安装软件包

python.unresolved.reference.inspection.install.package=安装软件包 {0}

# UI forms

form.qt.compile.qrc.output.file=输出文件：
form.buildout.config.use.paths.from.script=使用脚本中的路径(&S): 
form.auto.import.from.module.import.name=从 <module> 导入 <name>
form.auto.import.import.module.name=导入 <module>.<name>
form.auto.import.preferred.import.style=首选的导入样式：
form.auto.import.python=Python
form.auto.import.auto.import.show.popup=显示自动导入工具提示
form.create.test.target.directory=目标目录
form.create.test.test.class.name=测试类名
form.create.test.test.file.name=测试文件名
form.edit.sdk.associate.this.virtual.environment.with.current.project=将此虚拟环境与当前项目关联(&A)
form.edit.sdk.interpreter.path=解释器路径(&I):
form.edit.sdk.label.create.connection.pool.options.name=名称(&N):
form.edit.sdk.html.href.remove.association=<html><a href=\"#\">移除关联</a>
form.edit.smart.indent.pasted.lines=智能缩进粘贴行
form.integrated.tools.analyze.python.code.in.docstrings=分析 docstring 中的 Python 代码
form.integrated.tools.default.test.runner=默认测试运行程序：
form.integrated.tools.docstring.format=Docstring 格式：
form.integrated.tools.package.requirements.file=软件包要求文件：
form.integrated.tools.path.to.pipenv.executable=Pipenv 可执行文件路径：
form.integrated.tools.render.external.documentation.for.stdlib=渲染 stdlib 的外部文档
form.integrated.tools.sphinx.working.directory=Sphinx 工作目录：
form.integrated.tools.treat.txt.files.as.restructuredtext=将 *.txt 文件视为 reStructuredText
form.console.options.always.show.debug.console=始终显示调试控制台
form.console.options.settings.title.system.settings=常规设置
form.console.options.show.console.variables.by.default=默认显示控制台变量
form.console.options.use.existing.console.for.run.with.python.console=为“通过 Python 控制台运行”使用现有控制台
form.console.options.use.ipython.if.available=使用 IPython（如有）
form.console.specific.options.starting.script=正在启动脚本
form.debugger.for.attach.to.process.show.processes.with.names.containing=为“附加到进程”显示名称中包含这些内容的进程：
form.debugger.attach.to.subprocess.automatically.while.debugging=调试时自动附加到子进程
form.debugger.clear.caches=清除缓存
form.debugger.clear.caches.action=清除缓存
form.debugger.collect.run.time.types.information.for.code.insight=收集运行时类型信息以获取代码洞察
form.debugger.gevent.compatible=Gevent 兼容
form.debugger.drop.into.debugger.on.failed.tests=在失败的测试中放入调试器
form.debugger.pyqt.compatible=PyQt 兼容
form.debugger.remote.interpreter.docker.default.interpreter.path=python
form.data.viewer.current.slice=当前切片
form.data.viewer.dialog.show.svn.map.table.header.column.format.title=格式
form.data.viewer.format=格式:
form.debugger.stepping.checkbox.text.do.not.step.into.library.scripts=不要单步执行库脚本
form.debugger.stepping.do.not.step.into.scripts=不单步执行脚本:
form.debugger.stepping.always.do.smart.step.into=始终进行智能单步执行
form.documentation.entry.insert=插入(&I)
form.documentation.entry.module.name=模块名称 (&M)：
form.documentation.entry.url.path.pattern=URL/路径模式 (U)：
form.documentation.entry.available.macros=可用的宏
form.remote.path.remote.project.location=远程项目位置：
form.introduce.name=名称(&N):
form.introduce.field.initialize.in=初始化在(&I)
form.move.module.members.from=从:
form.move.module.members.to=到:
form.python.run.configuration.emulate.terminal.in.output.console=模拟输出控制台中的终端
form.python.run.configuration.redirect.input.from=重定向输入自:
form.python.run.configuration.run.with.python.console=使用 Python 控制台运行
form.test.shared.target=目标:
form.test.shared.test=测试
form.test.run.configuration.params=形参:
form.test.run.configuration.specify.nosetests.command.line.options=指定 nosetest 命令行选项
form.test.run.configuration.unittest=Unittest
form.tox.configuration.arguments=实参
form.tox.configuration.run.only.environment=仅运行环境
form.tox.configuration.runcfg.tox=tox
py.module.dependencies.configurable.list.title=项目取决于这些项目：
py.sdk.editor.python.interpreter.label.text=Python 解释器：
# Python reStructuredText forms
rest.configuration.editor.open.output.file.in.browser.label.text=在浏览器中打开输出文件
sphinx.ask.for.working.directory.label.text=Sphinx 工作目录



pure.python.project=纯 Python
project.cannot.be.generated=无法生成项目
error.in.project.generation=项目生成出错

sdk.has.been.configured.as.the.project.interpreter={0} 已被配置为项目解释器
sdk.has.been.configured.notification.name=已配置的 Python 解释器
configuring.interpreters.link=<html><a href="#">配置解释器
looking.for.previous.interpreter=正在查找以前用过的解释器
looking.for.related.venv=正在查找与项目相关的虚拟环境
install.packages.from.pipfile=从 Pipfile 安装软件包
looking.for.default.interpreter=正在查找新项目的默认解释器设置
looking.for.previous.system.interpreter=正在查找以前用过的系统级解释器
looking.for.system.interpreter=正在查找系统级解释器
looking.for.shared.conda.environment=正在查找共享的 Conda 环境
current.interpreter=当前解释器：{0}
switch.python.interpreter=切换 Python 解释器
python.facet.name=Python
choose.packages.to.install=选择要安装的软件包：
manage.python.packages=管理 Python 软件包
available.to.all.projects=可用于所有项目


framework.support.python.sdk.combobox.label=Python SDK:
integrated.tools.configurable.docstrings=Docstring
integrated.tools.configurable.restructuredtext=reStructuredText
integrated.tools.configurable.packaging=打包
integrated.tools.configurable.testing=测试
integrated.tools.configurable.pipenv=Pipenv
command.line.parser.error.message=实参与其值之间不应有空格

python.package.installation.notification.message={0} 将安装在选定的解释器上
python.package.and.packaging.tools.installation.notification.message=Python 打包工具和 {0} 将安装在所选解释器上

python.execute.selection.action.execute.selection.in.console=执行 Python 控制台中的选定内容
python.execute.selection.action.execute.line.in.console=执行 Python 控制台中的代码行

python.add.sdk.panel.name.conda.environment=Conda 环境
python.add.sdk.panel.name.existing.environment=现有环境
python.add.sdk.panel.name.previously.configured.interpreter=先前配置的解释器
python.add.sdk.panel.name.new.environment.using=使用此工具新建环境
python.add.sdk.panel.name.new.environment=新环境
python.add.sdk.panel.name.new.project.interpreter=新项目解释器
python.add.sdk.panel.name.pipenv.environment=Pipenv 环境
python.add.sdk.panel.name.system.interpreter=系统解释器
python.add.sdk.panel.name.virtualenv.environment=Virtualenv 环境

python.add.sdk.conda.executable.path.is.empty=Conda 可执行文件路径为空
python.add.sdk.conda.executable.not.found=找不到 Conda 可执行文件
python.add.sdk.conda.executable.path.is.not.executable=Conda 可执行文件路径不是可执行文件

python.requirements.version.label=需求版本:
python.requirements.version.separator.no.version=不指定版本
python.requirements.version.separator.strong.eq=强相等
python.requirements.version.separator.gte=大于或等于
python.requirements.version.separator.compatible=兼容版本
python.requirements.remove.unused=移除未使用的需求
python.requirements.modify.base.files=修改基本文件（使用 -r 或 --requirement 定义的文件）
python.requirements.keep.matching.specifier=如果现有版本与当前版本相匹配，则保留现有版本说明符
python.requirements.analyzing.imports.title=正在分析项目中的导入
python.requirements.action.name=同步 Python 需求
python.requirements.error.ends.with.slash=解析需求出错：文件以 '/' 符号结尾。
python.requirements.error.no.interpreter=已配置同步需求所需的解释器。
python.requirements.warning.unhandled.lines=无法分析需求文件中的条目：{0}
python.requirements.info.file.ref.dropped=基本文件中的某些需求未更新：{0}
python.requirements.balloon=同步 Python 需求

toolwindow.stripe.SciView=SciView
toolwindow.stripe.Python_Console=Python 控制台
python.folding.options.title=Python
python.long.string.literals=长字符串文字
python.long.collection.literals=长集合文字
python.sequential.comments=顺序注释
python.provide.a.qualified.name.of.a.module=提供模块的限定名称
python.input.file.doesn.t.exist=输入文件不存在
python.call.graph=调用图
python.buildout.failed.to.extract.path=无法从 {0} 提取路径
python.debugger.collection.signatures.deleted=收集的签名已被删除
python.debugger.nothing.to.delete=没有要删除的内容
python.debugger.qt.backend.auto=自动
python.debugger.settings.waiting.for.connection=正在等待连接…
python.debugger.settings.connecting.to.debugger=正在连接到调试器
python.debugger.attaching.to.process.with.pid=正在附加到 PID={0} 的进程
python.debugger.attaching=正在附加调试器
python.rename.processor.override.message=类 {1} 的方法 {0}\n\
重写了类 {2} 的方法。\n\
要重命名基方法吗?
python.rename.processor.property=是否要重命名属性 ''{0}'' 而不是其访问器函数 ''{1}''?
python.configuration.choose.target.to.run=选择要运行的目标
python.vagrant.refresh.skeletons=启动 vagrant 并刷新框架
python.concurrency.visualizer.scroll.end=滚动到结尾
python.execute.cell.in.console=在控制台中执行单元
python.template.select.file.type=选择文件类型
python.execution.is.still.running=上一个执行仍在运行

INSP.settings.pep8.ignore.errors=忽略错误
INSP.settings.pep8.ignore.errors.label=已忽略的错误:
INSP.settings.bdd.behave.specific=特定于 BDD 行为的定义不正确
INSP.settings.bdd.step.definition.arguments=步骤定义函数中的实参不正确
python.compatibility.inspection.advertiser.notifications.group.title=Python 兼容性检查广播程序
python.compatibility.inspection.advertiser.notifications.title=Python 版本兼容性

python.compatibility.inspection.advertiser.using.future.imports.warning.message=您的源代码包含 __future__ 导入。<br/>要启用代码兼容性检查吗?<br/><a href="#yes">是</a>\\&nbsp;\\&nbsp;<a href="#no">否</a>

python.compatibility.inspection.advertiser.using.six.warning.message=您的源代码导入了 'six' 软件包。<br/>要启用代码兼容性检查吗?<br/><a href="#yes">是</a>\\&nbsp;\\&nbsp;<a href="#no">否</a>

# Both placeholders are Python versions like 2.7, 3.7, etc.
python.compatibility.inspection.advertiser.version.stale.python3.version.warning.message=已为最高 {0} 的 Python 版本配置了代码兼容性检查。<br/>要为 Python {1} 启用吗?<br/><a href="#yes">是</a>\\&nbsp;\\&nbsp;<a href="#no">否</a>

python.install.framework.ensure.installed=正在确保 {0} 已安装
python.install.framework.checking.is.installed=正在检查是否已安装 {0}…
python.install.framework.installing=正在安装 {0}…
py.commandline.configure=为项目配置 Python SDK

python.task.cannot.find.python.interpreter.for.selected.module=找不到所选模块的 Python 解释器
python.unknown.project.synchronizer.this.interpreter.type.does.not.support.remote.project.creation=此解释器类型不支持创建远程项目
progress.text.connecting.to.console=正在连接到控制台…
progress.title.debugger.connection=调试器连接
python.sdk.configuration.tab.title=类
python.console.rename.message=输入新控制台名称:
python.introduce.variable.refactoring.name=引入变量

settings.completion.ml.python.display.name=Python
QFIX.pep8.edit.inspection.profile.setting=编辑检查配置文件设置

python.remote.process.starter.can.t.run.remote.interpreter=无法运行远程 Python 解释器: {0}
python.remote.interpreter.can.t.create.project.this.type=无法在远程解释器上创建此类型的项目。选择本地解释器。
dialog.message.error.on.python.side.exit.code.stderr.stdout=Python 端错误。退出代码: {0}，错误: {1}，输出: {2}
live.template.context.class=类
live.template.context.top.level=顶层

python.buildout.parsing.error.section.name.expected=应为部分名称。
python.buildout.parsing.error.key.expected=应为键。
python.buildout.parsing.error.or.expected=应为 : 或 =。
python.buildout.parsing.error.bracket.expected=应为 ]。
line.markers.popup.title.choose.super.method=选择 {0} 的 super 方法
line.markers.popup.title.choose.super.attribute=选择 {0} 的 super 特性
line.markers.popup.title.choose.subclass=选择 {0} 的子类
line.markers.popup.title.choose.overriding.method=选择 {0} 的重写方法
line.markers.tooltip.header.is.subclassed.by=被以下对象子类化:
line.markers.tooltip.has.subclasses=具有子类
line.markers.tooltip.header.is.overridden.in=在以下位置被重写:
line.markers.tooltip.has.overridden.methods=具有被重写的方法
line.markers.tooltip.overrides.method.in.class=重写 {0} 中的方法
line.markers.tooltip.overrides.attribute.in.class=重写 {0} 中的特性
python.find.module.usages.dialog.label.prefix.package=软件包
python.find.module.usages.dialog.label.prefix.module=模块
goto.superclass.choose=选择超类
python.symbol.chooser.dialog.title=选择符号
button.install.to.user.site.packages.directory=安装到用户的站点软件包目录
framework.not.supported.for.the.selected.interpreter=所选解释器不支持 {0}

action.MarkNamespacePackageDirectory.text=命名空间软件包
python.unmark.as.namespace.package=取消标记为命名空间软件包
python.unmark.as.python.namespace.package=取消标记为 Python 命名空间软件包
python.namespace.package.folder=命名空间软件包
python.python.namespace.package.folder=Python 命名空间软件包
python.namespace.packages.name=命名空间软件包
python.namespace.packages.description=命名空间软件包文件夹
dialog.title.can.t.create.package=创建软件包错误
command.name.create.new.package=创建新软件包 {0}
dialog.title.new.python.package=新建 Python 软件包
new.package.list.item.ordinary.package=软件包
new.package.list.item.namespace.package=命名空间软件包

# Python Packages toolwindow
python.toolwindow.packages.installed.label=已安装
python.toolwindow.packages.custom.repo.searched={0} (找到 {1} 个)
python.toolwindow.packages.pypi.repo.label=PyPI 仓库
python.toolwindow.packages.documentation.link=文档
python.toolwindow.packages.no.interpreter.text=选择解释器以查看所安装的软件包
python.toolwindow.packages.latest.version.label=最新
python.toolwindow.packages.install.button=安装
python.toolwindow.packages.delete.package=删除软件包
python.toolwindow.packages.search.text.placeholder=搜索更多软件包
python.toolwindow.packages.description.panel.placeholder=选择软件包以查看文档
python.toolwindow.packages.request.failed=<html><head></head><body><p class="empty_description">请求失败。</p></body></html>
python.toolwindow.packages.no.description.placeholder=<html><head></head><body><p class="empty_description">软件包作者未提供描述。</p></body></html>
python.toolwindow.packages.remote.interpreter.placeholder=<html><head></head><body><p class="empty_description">需要本地解释器才能查看软件包文档。</p></body></html>
python.toolwindow.packages.collecting.packages.task.title=正在收集软件包
python.toolwindow.packages.rst.parsing.failed=无法解析描述
python.toolwindow.packages.no.documentation=在当前仓库中找不到文档
python.toolwindow.packages.manage.repositories.action=管理仓库
python.toolwindow.packages.reload.repositories.action=重新加载所有仓库
python.toolwindow.packages.add.package.action=添加软件包
python.toolwindow.packages.add.package.from.vcs=从版本控制
python.toolwindow.packages.add.package.from.disc=从磁盘
python.toolwindow.packages.add.package.as.editable=作为 editable (-e)安装
python.toolwindow.packages.add.package.vcs.git=Git
python.toolwindow.packages.add.package.vcs.svn=Subversion
python.toolwindow.packages.add.package.vcs.hg=Mercurial
python.toolwindow.packages.add.package.vcs.bzr=Bazaar
python.toolwindow.packages.add.package.path=路径
python.toolwindow.packages.add.package.path.selector=选择文件或目录
python.toolwindow.packages.add.package.dialog.title=安装软件包
python.toolwindow.packages.load.more=… 其他 {0} 个条目。双击以显示更多。
python.toolwindow.packages.load.more.start=…

vcs.activate.virtualenv.checkbox.text=为挂钩激活 Virtualenv

notification.action.edit.settings=编辑设置
python.template.language.none=无



CONFLICT.name.obscured.by.local.definitions=名称 ''{0}'' 被局部定义掩盖
CONFLICT.name.obscured.cannot.convert=名称 ''{0}'' 被掩盖。无法转换。
CONFLICT.occurrence.pl=匹配项
INSP.GROUP.python=Python
INSP.NAME.pyproject.packages=Depencencies in pyproject.toml
INSP.poetry.package.versions.display.name=Poetry 软件包版本
INSP.settings.bdd.behave.specific=特定于 BDD 行为的定义不正确
INSP.settings.bdd.step.definition.arguments=步骤定义函数中的实参不正确
INSP.settings.pep8.ignore.errors.label=已忽略的错误:
QFIX.FAMILY.NAME.rename.element=重命名元素
QFIX.NAME.change.signature=更改签名
QFIX.NAME.implement.methods=实现 abstract 方法
QFIX.NAME.rename.element=重命名该元素
QFIX.add.import.add.import=添加 "''{0}''"
QFIX.bold.html.text=<b>{0}</b>
QFIX.change.signature.of=更改 {0} 的签名
QFIX.change.to.same.directory.import=更改为同一目录导入
QFIX.fill.paragraph=填充段落
QFIX.generate.binary.stubs=生成二进制存根
QFIX.generating.skeletons.for.binary.module=正在为二进制模块生成框架
QFIX.ignore.unresolved.reference=忽略未解析的引用
QFIX.ignore.unresolved.reference.0=忽略未解析的引用 ''{0}''
QFIX.mark.all.unresolved.attributes.of.0.as.ignored=将 ''{0}'' 所有未解析的特性标记为已忽略
QFIX.mark.as.namespace.package=将目录 ''{0}'' 标记为命名空间软件包
QFIX.pep8.edit.inspection.profile.setting=编辑检查配置文件设置
QFIX.reformat.file=重新格式化该文件
QFIX.remove.trailing.blank.lines=移除尾随的空白行
action.AnActionButton.text.show.early.releases=显示早期版本
action.AnActionButton.text.use.conda.package.manager=使用 Conda 软件包管理器
action.CleanPyc.description=删除所选目录及其子目录中已编译的字节码文件
action.CleanPyc.progress.title.cleaning.up.pyc.files=正在清理 .pyc 文件…
action.CleanPyc.status.bar.text.deleted.bytecode.files=已删除 {0} 个字节码{0, choice, 0#文件|1#文件|2#文件}
action.CleanPyc.text=清除 Python 编译文件
action.CollapsePythonTypeAnnotations.description=Collapse python type annotations
action.CollapsePythonTypeAnnotations.text=Collapse Python Type Annotations
action.CompuleQrc.text=编译 .qrc 文件
action.DumbAware.ConcurrencyToolWindowPanel.description.stop.process=停止进程
action.DumbAware.ConcurrencyToolWindowPanel.text.stop.process=停止进程
action.DumbAware.PydevConsoleRunnerImpl.description.stop.python.console=停止 Python 控制台
action.DumbAware.PydevConsoleRunnerImpl.text.stop.console=停止控制台
action.ExecuteInPyConsoleAction.description=在 Python/Django 控制台中执行选定的代码段
action.ExecuteInPyConsoleAction.text=在控制台中执行所选内容
action.ExpandPythonTypeAnnotations.description=Expand python type annotations
action.ExpandPythonTypeAnnotations.text=Expand Python Type Annotations
action.ForceStepInto.description=步入，忽略库、构造函数等步进筛选器。
action.ForceStepInto.text=强制单步执行 (_R)
action.MarkNamespacePackageDirectory.text=命名空间软件包
action.NewPythonPackage.description=在其中创建新目录和 __init__.py
action.NewPythonPackage.text=Python 软件包
action.PyConsoleRenameAction.text=重命名控制台
action.PyConvertModuleToPackage.description=创建同名的软件包，并将模块内容移至其 __init__.py
action.PyConvertModuleToPackage.text=转换为 Python 软件包
action.PyConvertPackageToModuleAction.description=创建同名模块，并将 __init__.py 的内容移至该模块
action.PyConvertPackageToModuleAction.text=转换为 Python 模块
action.PyDebugger.CustomizeDataView.text=自定义数据视图
action.PyDebugger.ViewArray.text=作为数组查看
action.PyExecuteCellAction.text=在控制台中执行单元
action.PyManagePackages.text=管理 Python 软件包…
action.PySyncPythonRequirements.description=同步 Python 要求文件与项目中使用的软件包
action.PySyncPythonRequirements.text=同步 Python 要求…
action.PythonGenerateDictionaries.text=生成 Python 拼写检查器字典
action.RunPythonToolwindowAction.text=Python 控制台
action.SetNextStatement.description=跳转到文本光标所在的行
action.SetNextStatement.text=跳转到光标(&J)
action.StepIntoMyCode.description=跳到已执行的下一行，并忽略库
action.StepIntoMyCode.text=单步执行我的代码
action.com.jetbrains.python.console.RunPythonOrDebugConsoleAction.description=允许在运行调试会话时快速运行 Python 控制台或调试控制台
action.com.jetbrains.python.console.RunPythonOrDebugConsoleAction.text=Python 或调试控制台
action.create.python.file.description=从指定的模板创建 Python 文件
action.create.python.file.title=Python 文件
action.run.file.in.python.console.description=运行 Python 控制台中的当前文件
active.sdk.dialog.link.add.interpreter.text=添加解释器
active.sdk.dialog.project.interpreter=Python 解释器:
active.sdk.dialog.project.interpreter.path.mappings=路径映射:
active.sdk.dialog.project.interpreter.path.mappings.default.project.error=打开或创建项目以配置映射
active.sdk.dialog.show.all.item=全部显示…
acton.run.file.in.python.console.title=在 Python 控制台中运行文件
advanced.setting.python.code.vision.usages.limit=Code Vision: 要搜索的最大用法数
advanced.setting.python.debugger.attach.timeout=调试器: 附加到进程连接超时
advanced.setting.python.pytest.show_summary=Pytest: 不添加 "--no-header --no-summary -q"
advanced.setting.python.pytest.swapdiff=在 Pytest 中交换实际断言和预期断言的顺序
available.to.all.projects=可用于所有项目
black.action.on.save.executable.info=Using Black executable v{0}
black.action.on.save.executable.path.not.specified=Black executable path not specified
black.action.on.save.name=Run Black
black.action.on.save.package.info=Using Black package v{0}
black.advanced.settings.panel.title=高级设置
black.advertising.service.configure.button.label=配置
black.advertising.service.dont.show.again.label=不再显示
black.advertising.service.found.in.PATH=Black formatter executable is detected in {0, choice, 0#%PATH%|1#$PATH}. Try Black formatter integration!
black.advertising.service.found.in.packages=Black formatter package is detected on the project interpreter. Try Black formatter integration!
black.advertising.service.notification.title=Black formatter integration
black.cli.args.comment=List command line arguments separated by whitespace. <a href='https://black.readthedocs.io/en/stable/usage_and_configuration/the_basics.html#command-line-options'>Learn more</a><br>Settings from pyproject.toml are applied automatically for Black v21.4.0 and higher.
black.cli.args.text.field.label=设置:
black.cli.args.validation.notification=No value passed for parameter {0}
black.configurable.name=Black
black.empty.output.error=Black formatter returned empty output
black.empty.path.to.executable.exception.text=Black executable not found or empty
black.enable.action.on.save.label=On save
black.enable.black.checkbox.label=On code reformat
black.exception.error.message=Black formatter error
black.executable.auto.detected.path=已自动检测: {0}
black.executable.label=Black executable:
black.executable.not.found=Unable to auto-detect Black executable in {0, choice, 0#%PATH%|1#$PATH}
black.execution.mode.binary=二进制
black.execution.mode.label=Execution mode:
black.execution.mode.package=打包
black.execution.mode.tooltip.text=Use either executable or package installed on the project interpreter
black.failed.to.format.on.save.error.label=Black: Failed to format file {0}
black.file.ignored.notification.label=Black: File ignored
black.file.ignored.notification.message=File {0} ignored according to --exclude or --force-exclude rules
black.format.fragment.inline.error=Black: Failed to format fragment: {0}
black.formatted.n.lines=Black: Formatted {0} {1, choice, 0#lines|1#line}
black.formatting.service.name=Black formatter
black.formatting.with.black=Formatting with Black
black.install.button.label=Install Black
black.installation.error.title=Failed to install Black formatter
black.installing.modal.title=Installing Black formatter
black.interpreter.selection.combobox.label=Python 解释器:
black.no.lines.changed=Black: No lines changed. Content is already properly formatted.
black.not.installed.error=Black formatter package is not installed on the current interpreter
black.processing.file.name=Black: Processing file {0}
black.remote.sdk.error=Package mode is not available for remote SDKs. Please use Binary mode.
black.remote.sdk.exception.text=Black formatter invocation in Package mode is not allowed on remote SDKs
black.sdk.not.configured.error=No project SDK configured for the project {0}
black.sdk.not.configured.error.title=SDK not configured
black.select.path.to.executable=Select path to Black formatter executable
black.use.section.label=Use Black formatter:
button.install.to.user.site.packages.directory=安装到用户的站点软件包目录
choose.packages.to.install=选择要安装的软件包:
code.insight.create.test=创建测试
code.insight.goto.superclass.attribute.chooser.title=选择超类特性
code.insight.ignore.packages.qfix=忽略{0,choice, 1#软件包|2#软件包}
code.insight.ignore.type.hints=忽略
code.insight.install.type.hints.action=安装存根软件包
code.insight.install.type.hints.content=它们可以使代码洞察更出色。
code.insight.select.methods.to.implement=选择实现的方法
code.insight.select.methods.to.override=选择要重写的方法
code.insight.select.target.directory=选择目标目录
code.insight.stub.checked.packages.are.not.installed.message=存根{0,choice,1#软件包|2#软件包} {1} {0,choice,1#未|2#未}安装。
code.insight.stub.forced.packages.are.not.installed.message=存根{0,choice,1#软件包|2#软件包} {1} {0,choice,1#未|2#未}安装。{0,choice,1#它|2#它们}{0,choice,1#包含|2#包含}提升代码洞察所需的类型提示。
code.insight.stub.package.advertiser.notifications.group.title=推荐使用 Python 存根软件包
code.insight.stub.packages.ignored.notification.content=建议的 {0} {1,choice,1#与|2#与}您的当前环境不兼容。\n\
{1,choice,1#此|2#这些}存根{1,choice,1#软件包|2#软件包}将被移除和忽略，直到新版本发布。
code.insight.stub.packages.install.requirements.fix.name=安装存根{0,choice,1#软件包|2#软件包}
code.insight.type.hints.are.not.installed=未安装类型提示
command.line.parser.error.message=实参与其值之间不应有空格
command.name.create.new.package=创建新软件包 {0}
commandLine.commandNotFound={0}: 找不到命令
commandLine.inspection.badArgument=实参不能具有此值。使用自动补全检查可能的值的列表。
commandLine.inspection.badCommand=命令错误或未知。确保存在此命令。
commandLine.inspection.badOption=选项错误或未知。确保存在此选项。
commandLine.inspection.excessArgument=实参过多或此处无法使用实参
commandLine.inspection.name=不正确的 CLI 语法
compile.cython.extensions.error=编译 Cython 扩展错误
compile.cython.extensions.help=运作方式
compile.cython.extensions.install=安装
compile.cython.extensions.notification=Python 调试器扩展可用
compile.cython.extensions.title=编译 Cython 扩展
conda.packaging.button.install.with.conda=通过 conda 安装
conda.packaging.button.install.with.pip=通过 pip 安装
conda.packaging.cache.update.progress=正在更新可用的 Conda 软件包列表
conda.packaging.empty.pypi.info=<html><head></head><body><p class="empty_description">在 PyPI 上找不到软件包描述。<br/>仍然可以使用 conda 安装。</p></body></html>
conda.packaging.error.rendering.description=<html><head></head><body><p class="empty_description">无法检索软件包描述。<br/>它仍然可以安装。</p></body></html>
conda.packaging.exception.non.zero=非零退出代码
conda.packaging.exception.timeout=超时
conda.packaging.install.progress=正在安装 Conda 软件包 {0}
conda.packaging.list.progress=正在读取已安装的 Conda 软件包
conda.packaging.uninstall.progress=正在卸载 Conda 软件包 {0}
conda.packaging.update.progress=正在更新 Conda 软件包 {0}
configurable.PyActiveSdkModuleConfigurable.python.interpreter.display.name=Python 解释器
configurable.PyConsoleOptionsConfigurable.child.display.name=Python 控制台
configurable.PyConsoleOptionsConfigurable.display.name=控制台
configurable.PyContentEntriesModuleConfigurable.display.name=项目结构
configurable.PyDebuggerConfigurable.display.name=Python 调试器
configurable.PyDependenciesConfigurable.display.name=项目依赖项
configurable.PyIntegratedToolsConfigurable.display.name=Python 集成工具
configurable.PyIntegratedToolsModulesConfigurable.display.name=Python 集成工具
configurable.PyLanguageCodeStyleSettingsProvider.display.name=Python
configurable.PySmartKeysOptions.display.name=Python
configurable.PyUserTypeRenderersConfigurable.display.name=Python 类型呈现器
configurable.PythonContentEntriesConfigurable.display.name=项目结构
configurable.PythonSdkEditorTab.display.name=Python SDK
configurable.choose.path.to.the.package.requirements.file=选择软件包要求文件的路径:
configurable.choose.working.directory=选择工作目录:
configurable.name.python.language=Python 语言
configurable.pipenv.auto.detected=已自动检测: {0}
configurable.select.working.directory=选择工作目录
configuring.interpreters.link=配置解释器
connecting.to.console.progress=正在连接到控制台…
connecting.to.console.title=连接控制台
console.attach.debugger=附加调试器
console.attach.debugger.description=对控制台中执行的代码启用追踪
console.cannot.connect.to.debugger=无法连接到调试器
console.changing.variable=正在更改变量
console.close.console.communication=关闭控制台通信
console.connecting.to.debugger=正在连接到调试器
console.error.connecting.debugger=连接调试器出错
console.evaluating.expression.in.console=正在控制台中对表达式求值
console.executing.code.in.console=正在控制台中执行代码…
console.executing.dataviewer.command="正在执行 DataViewer 命令"
console.getting.array=数组
console.getting.completion=补全
console.getting.documentation=文档
console.getting.frame.variables=框架变量
console.getting.from.runtime=正在从 Python 运行时获取{0}
console.getting.table.data=表数据
console.getting.variable.value=变量值
console.interrupting.execution=正在中断执行
console.new.console=新建控制台
console.new.console.description=创建新的 python 控制台
console.restarting.console=正在重启控制台
console.setting.user.type.renderers=用户类型呈现器
console.show.variables.description=显示活动控制台变量
console.show.variables.title=显示变量
console.stopping.console=正在停止控制台
console.table.failed.to.load=无法加载:
console.waiting.execution.result=正在等待执行结果
create.python.file.action.new.python.file=新建 Python 文件
create.python.file.action.python.file=Python 文件
create.python.file.action.python.stub=Python 存根
create.python.file.action.python.unit.test=Python 单元测试
create.python.file.script.action=创建 Python 脚本 {0}
current.interpreter=当前解释器: {0}
debug.notification.group=Python 调试器
debug.notification.title.connection.failed=连接 Python 调试器失败
debug.popup.title.step.into.function=步入函数
debugger.attach.to.process.failed.to.find.free.socket.port=找不到可用的套接字端口
debugger.attach.to.process.filter.names=<html>为<b>附加到进程</b>显示名称中包含这些内容的进程:</html>
debugger.connected.to.pydev.debugger.build=已连接到 pydev 调试器(内部版本号 {0})
debugger.cython.extension.gcc=命令 'gcc' 失败，退出状态为 1
debugger.cython.extension.gcc.failed=安装一个 C 编译器，以便为调试器构建 Cython 扩展。
debugger.cython.extension.gcc.not.found=x86_64-linux-gnu-gcc
debugger.cython.extension.gcc.not.found.suggestion=\n\
\n\
使用您的软件包管理器安装缺失的 <code>gcc</code>。\n\
\n\
尝试命令:\n\
<code>sudo apt install gcc</code>
debugger.cython.extension.install.python.command=<code>sudo apt-get install python{0}-dev</code>
debugger.cython.extension.non.zero.exit.code=非零退出代码 ({0}):\n\
{1}
debugger.cython.extension.permission.denied=权限被拒绝
debugger.cython.extension.python.h=Python.h: 无此文件或目录
debugger.cython.extension.python.h.not.found=\n\
\n\
使用您的软件包管理器在系统范围内为 Python 开发安装头文件和静态库。\n\
\n\
尝试命令:\n\
 {0}\n\

debugger.cython.extension.speeds.up.python.debugging=Cython 扩展加速 Python 调试
debugger.cython.please.enter.your.password.to.compile.cython.extensions=请输入密码以编译 cython 扩展:
debugger.cython.python.run.configuration.should.be.selected=应选择 Python 运行配置
debugger.data.view.close=关闭
debugger.data.view.close.selected.viewer=关闭所选查看器
debugger.data.view.close.viewer=关闭查看器
debugger.data.view.colored=已着色
debugger.data.view.colored.cells=已着色单元
debugger.data.view.connected.to.debug.session=已连接到调试会话 ''{0}''
debugger.data.view.connected.to.python.console=已连接到 Python 控制台
debugger.data.view.data=数据
debugger.data.view.empty.tab=空
debugger.data.view.empty.text=运行 Python 控制台或调试器以查看可用数据
debugger.data.view.failed.to.evaluate.expression=无法对表达式 {0} 求值
debugger.data.view.open.new.container.viewer=打开新容器查看器
debugger.data.view.resize.automatically=自动调整大小
debugger.data.view.type.is.not.supported=不支持 {0}
debugger.data.view.view.new.container=查看新容器
debugger.dataviewer.action.copy.name=复制
debugger.dataviewer.action.copy.properties.dialog.title=复制到剪贴板设置
debugger.dataviewer.action.copy.properties.include.header=包含标头
debugger.dataviewer.action.copy.properties.include.indices=包含索引
debugger.dataviewer.action.copy.properties.name=复制到剪贴板设置
debugger.dataviewer.action.copy.properties.separator=分隔符:
debugger.dataviewer.action.copy.update.message=复制到剪贴板
debugger.dataviewer.action.export.dialog.description=保存到
debugger.dataviewer.action.export.name=导出…
debugger.dataviewer.action.goto.dialog.label=行:列
debugger.dataviewer.action.goto.dialog.title=转到
debugger.dataviewer.action.open.in.editor.name=在编辑器标签页中打开
debugger.dataviewer.action.remove.filter.name=移除筛选器
debugger.dataviewer.action.set.filter.ad.controls=按 Enter 键应用
debugger.dataviewer.action.set.filter.button.set=设置
debugger.dataviewer.action.set.filter.description=筛选列 ''{0}''
debugger.dataviewer.action.set.filter.help.expression=<html>使用 <b>{0}</b> 作为 lambda 函数的变量</html>
debugger.dataviewer.action.set.filter.item.expression=表达式
debugger.dataviewer.action.set.filter.item.substring=子字符串
debugger.dataviewer.action.set.filter.name=设置筛选器…
debugger.dataviewer.action.set.filter.use.regex=使用正则表达式
debugger.dataviewer.export.error.invalid.filepath=无效文件路径
debugger.dataviewer.export.error.invalid.filepath.content=文件路径 ''{0}'' 无效
debugger.dataviewer.export.error.title=表导出失败
debugger.dataviewer.export.error.unhandled=未处理的错误
debugger.dataviewer.export.error.unhandled.content=无法导出到 ''{0}'':\n\
{1}
debugger.dataviewer.header.filter.hint={0}: {1}
debugger.dataviewer.header.filter.hint.mode.expression=表达式
debugger.dataviewer.header.filter.hint.mode.regex=正则表达式
debugger.dataviewer.header.filter.hint.mode.substring=子字符串
debugger.dataviewer.modifier.error=修饰符错误: {0}
debugger.dataviewer.notification.group.title=数据查看器错误
debugger.debug.process.running=进程正在运行
debugger.delete.signature.cache=删除缓存
debugger.error.in.test.setup.or.teardown.caption=设置或删除测试时出错
debugger.exception.breakpoint.activation.policy=激活策略
debugger.exception.breakpoint.any.exception=任何异常
debugger.exception.breakpoint.ignore.library.files=忽略库文件
debugger.exception.breakpoint.on.raise=引发时
debugger.exception.breakpoint.on.termination=终止时
debugger.exception.breakpoint.select.exception.class=选择异常类
debugger.exception.breakpoint.type=Python 异常断点
debugger.line.breakpoint.type=Python 行断点
debugger.numeric.view.as.array=作为数组查看
debugger.numeric.view.as.dataframe=作为 DataFrame 查看
debugger.numeric.view.as.series=作为系列查看
debugger.pydev.console.pause.the.process.to.use.command.line=暂停进程以使用命令行。
debugger.remote.port.out.of.boundaries=端口号超出界限
debugger.remote.starting.debug.server.at.port=正在端口 {0} 上启动调试服务器
debugger.remote.waiting.for.connection=正在等待连接
debugger.remote.waiting.for.process.connection=正在等待进程连接…
debugger.sending.close.message=正在向 Python 控制台发送关闭消息…
debugger.simplified.view.description=禁用监视类、函数和模块对象
debugger.simplified.view.text=简化变量视图
debugger.stack.frame.frame.not.available=<框架不可用>
debugger.stack.frame.return.values=返回值
debugger.stack.frame.special.variables=特殊变量
debugger.stack.frame.unable.to.display.frame.variables=无法显示框架变量
debugger.stack.frames.not.available.in.non.suspended.state=框架在未挂起的状态下不可用
debugger.stepping.filter=步进筛选器
debugger.stepping.filter.specify.pattern=指定 glob 模式(允许使用 '*'、'?' 和 '[seq]'，分号 ';' 用作名称分隔符):
debugger.stepping.no.script.filters=未配置脚本筛选器
debugger.test.failed.caption=测试失败
debugger.use.the.following.code.to.connect.to.the.debugger=使用以下代码连接到调试器: 
debugger.variables.loading.asynchronously.description=异步加载变量值
debugger.variables.loading.asynchronously.text=异步
debugger.variables.loading.on.demand.description=按需加载变量值
debugger.variables.loading.on.demand.text=按需
debugger.variables.loading.policy=变量加载策略
debugger.variables.loading.synchronously.description=同步加载变量值
debugger.variables.loading.synchronously.text=同步
debugger.variables.view.loading.timed.out=加载超时
debugger.variables.view.switch.to.loading.on.demand=切换为按需加载
debugger.variables.view.warning.message=无法加载多个变量的值  
debugger.waiting.to.finish=正在等待 Python 控制台进程结束…
debugger.warning.message=此选项可能会减慢调试器的速度
debugger.warning.wrong.debugger.version=警告: 调试器版本错误。使用 PyCharm 安装文件夹中的 pycharm-debugger.egg\n\
或执行: ''pip install pydevd-pycharm~=%{0}''
debugger.watch.return.values.description=启用监视，以查看所执行函数返回的值
debugger.watch.show.return.values=显示返回值
dialog.message.error.on.python.side.exit.code.stderr.stdout=Python 端错误。退出代码: {0}，错误: {1}，输出: {2}
dialog.title.can.t.create.package=创建软件包错误
dialog.title.new.python.package=新建 Python 软件包
dict.completion.type.text=dict key
enter.path.dialog.title=输入路径
error.in.project.generation=项目生成出错
external.documentation.column.name.module=模块名称
external.documentation.column.name.url.path.pattern=URL/路径模式
external.documentation.configure.description=模块 {0} 未配置外部文档 URL。\n\
要立即配置吗?
external.documentation.edit.documentation.url=编辑文档 URL
external.documentation.pycharm=外部文档
external.documentation.python.plugin=Python 外部文档
external.documentation.title=Python 外部文档
filetype.python.debug.remote.description=远程调试
flask.name=Flask
form.auto.import.auto.import.show.popup=显示自动导入工具提示
form.auto.import.from.module.import.name=从 <module> 导入 <name>
form.auto.import.import.module.name=导入 <module>.<name>
form.auto.import.preferred.import.style=首选的导入样式:
form.auto.import.python=Python
form.console.options.always.show.debug.console=始终显示调试控制台
form.console.options.auto.completion.enabled=自动显示运行时代码补全
form.console.options.settings.title.system.settings=常规设置
form.console.options.show.console.variables.by.default=默认显示控制台变量
form.console.options.use.command.queue=Python 控制台的命令队列
form.console.options.use.existing.console.for.run.with.python.console=为“通过 Python 控制台运行”使用现有控制台
form.console.options.use.ipython.if.available=使用 IPython(如有)
form.console.specific.options.starting.script=正在启动脚本
form.create.test.target.directory=目标目录
form.create.test.test.class.name=测试类名
form.create.test.test.file.name=测试文件名
form.data.viewer.current.slice=当前切片
form.data.viewer.dialog.show.svn.map.table.header.column.format.title=格式
form.data.viewer.format=格式:
form.debugger.attach.to.subprocess.automatically.while.debugging=调试时自动附加到子进程
form.debugger.clear.caches=清除缓存
form.debugger.clear.caches.action=清除缓存
form.debugger.collect.run.time.types.information.for.code.insight=收集运行时类型信息以获取代码洞察
form.debugger.drop.into.debugger.on.failed.tests=在失败的测试中放入调试器
form.debugger.for.attach.to.process.show.processes.with.names.containing=为“附加到进程”显示名称中包含这些内容的进程:
form.debugger.gevent.compatible=Gevent 兼容
form.debugger.pyqt.compatible=PyQt 兼容
form.debugger.remote.interpreter.docker.default.interpreter.path=python
form.debugger.save.call.signatures=保存调用签名
form.debugger.stepping.always.do.smart.step.into=始终进行智能单步执行
form.debugger.stepping.checkbox.text.do.not.step.into.library.scripts=不要单步执行库脚本
form.debugger.stepping.do.not.step.into.scripts=不单步执行脚本:
form.debugger.variables.view.user.type.renderers.append.default.children=追加默认子项
form.debugger.variables.view.user.type.renderers.apply.renderer.to.objects.of.type=将呈现器应用于以下类型的对象(完全限定名称):
form.debugger.variables.view.user.type.renderers.class.not.found=找不到类
form.debugger.variables.view.user.type.renderers.configure.renderer=配置呈现器
form.debugger.variables.view.user.type.renderers.name=呈现器名称:
form.debugger.variables.view.user.type.renderers.no.renderers=没有呈现器
form.debugger.variables.view.user.type.renderers.renderer=呈现器
form.debugger.variables.view.user.type.renderers.unnamed=未命名
form.debugger.variables.view.user.type.renderers.use.default.renderer=使用默认呈现器
form.debugger.variables.view.user.type.renderers.use.following.expression=使用以下表达式:
form.debugger.variables.view.user.type.renderers.use.list.of.expressions=使用表达式列表:
form.debugger.variables.view.user.type.renderers.variable.name=将 'self' 用作变量名称
form.debugger.variables.view.user.type.renderers.when.expanding.node=展开节点时:
form.debugger.variables.view.user.type.renderers.when.rendering.node=呈现节点时:
form.documentation.entry.available.macros=可用的宏
form.documentation.entry.insert=插入(&I)
form.documentation.entry.module.name=模块名称 (&M):
form.documentation.entry.url.path.pattern=URL/路径模式 (U):
form.edit.sdk.associate.this.virtual.environment.with.current.project=将此虚拟环境与当前项目关联(&A)
form.edit.sdk.html.href.remove.association=<html><a href=\"#\">移除关联</a>
form.edit.sdk.interpreter.path=解释器路径(&I):
form.edit.sdk.label.create.connection.pool.options.name=名称(&N):
form.edit.smart.indent.pasted.lines=智能缩进粘贴行
form.integrated.tools.analyze.python.code.in.docstrings=分析 docstring 中的 Python 代码
form.integrated.tools.default.test.runner=默认测试运行程序:
form.integrated.tools.docstring.format=Docstring 格式:
form.integrated.tools.package.requirements.file=软件包要求文件:
form.integrated.tools.path.to.pipenv.executable=Pipenv 可执行文件路径:
form.integrated.tools.render.external.documentation.for.stdlib=渲染 stdlib 的外部文档
form.integrated.tools.sphinx.working.directory=Sphinx 工作目录:
form.integrated.tools.treat.txt.files.as.restructuredtext=将 *.txt 文件视为 reStructuredText
form.introduce.field.initialize.in=初始化位置(&I)
form.introduce.name=名称(&N):
form.move.module.members.from=从:
form.move.module.members.to=到:
form.python.run.configuration.emulate.terminal.in.output.console=在输出控制台中模拟终端
form.python.run.configuration.redirect.input.from=重定向输入自:
form.python.run.configuration.run.with.python.console=使用 Python 控制台运行
form.remote.path.remote.project.location=远程项目位置:
form.test.run.configuration.params=形参:
form.test.run.configuration.specify.nosetests.command.line.options=指定 nosetest 命令行选项
form.test.run.configuration.unittest=Unittest
form.test.shared.target=目标:
form.test.shared.test=测试
form.tox.configuration.arguments=实参:
form.tox.configuration.environments.to.run=运行环境:
form.tox.configuration.runcfg.tox=tox
formatter.after.hash = '#' 之后
formatter.after.local.imports=在本地导入后面:
formatter.align.when.multiline=多行时对齐
formatter.around.eq.in.keyword.argument = 在关键字实参中的 = 周围
formatter.around.eq.in.named.parameter = 在命名形参中的 = 周围
formatter.around.multiplicative.operators=乘法运算符 (*, @, /, %)
formatter.around.power.operator=幂运算符 (**)
formatter.around.top.level.classes.and.function=围绕顶层类和函数:
formatter.around.top.level.imports = 在顶层导入后:
formatter.before.backslash = '\' 之前
formatter.before.first.method=在第一个方法前面:
formatter.before.hash = '#' 之前
formatter.braces = 大括号
formatter.collections.and.comprehensions=集合和推导
formatter.dictionary.literals=字典文字
formatter.force.new.line.after.colon=在冒号后强制换行
formatter.from.import.statements="From" Import 语句
formatter.from.import.statements.force.comma.if.multline=如有多行，强制使用尾随逗号
formatter.from.import.statements.force.parentheses.if.multiline=如有多行，强制使用括号
formatter.hang.closing.brackets=挂起右中括号
formatter.imports.panel.from.imports.always.split=始终拆分导入
formatter.imports.panel.from.imports.join.with.same.source=使用相同的源联接导入
formatter.imports.panel.from.imports.leave.as.is=保持原样
formatter.imports.panel.from.imports.structure.title="from" 导入结构
formatter.imports.panel.optimize.imports=优化 import
formatter.imports.panel.sort.by.type=在组中分别对 plain 导入和 "from" 导入进行排序
formatter.imports.panel.sort.case.insensitively=不区分大小写排序
formatter.imports.panel.sort.imports=对 import 语句排序
formatter.imports.panel.sort.names.in.from.imports=对 "from" 导入中的导入名称排序
formatter.imports.panel.title=导入
formatter.left.bracket = 左中括号
formatter.multi.clause.statements=多子句语句
formatter.panel.add.trailing.line.feed=在文件末尾添加换行
formatter.panel.dict.alignment.label=字典对齐:
formatter.panel.use.continuation.indent.for.arguments=方法调用实参
formatter.panel.use.continuation.indent.for.collection.literals=集合和推导
formatter.panel.use.continuation.indent.for.parameters=方法声明形参
formatter.panel.use.continuation.indent.for.title=为此内容使用继续缩进
formatter.single.clause.statements=单子句语句
framework.not.supported.for.the.selected.interpreter=所选解释器不支持 {0}
framework.support.python.sdk.combobox.label=Python SDK:
goto.superclass.choose=选择超类
group.PyDebugger.ViewAsGroup.text=查看方式
group.PyPackagingMenu.text=打包
group.advanced.settings.python=Python
inlay.hints.usages.text={0,choice, 0#无用法|1#1 个用法|2#{0,number}'{1,choice, |1#+}' 用法}
inlay.hints.usages.with.dynamic.text={0,choice, 0#无用法|1#1 个用法|2#{0,number} 个用法} ({1,choice, 1#1 个动态|2#{1,number} 个动态})
inlay.parameters.python.hints.blacklist.explanation=<p>To disable hints for a method or a function, use one of the following patterns:</p><ul><li><code><b>(*info)</b></code> - all functions with a single parameter whose name ends with <em>info</em><br></li><li><code><b>(a, b)</b></code> - all functions with parameters <em>a</em> and <em>b</em><br></li><li><code><b>*.put(self, key, value)</b></code> - all <em>put</em> methods with parameters <em>key</em> and <em>value</em><br></li><li><code><b>Foo.bar(self, a, b)</b></code> - method <em>bar</em> of class <em>Foo</em> with parameters <em>a</em> and <em>b</em><br></li><li><code><b>foo(\\&lt;star\\&gt;\\&lt;star\\&gt;kwargs)</b></code> - function <em>foo</em> with parameter <em>**kwargs</em><br></li></ul><p>Names or placeholders must be provided for all parameters, including the optional ones.<br>Qualified method names must include class names, or placeholders for them.<br>Use the "Do not show hints for current method" {0} action to add patterns from the editor.</p>
inlay.parameters.python.show.class.constructor.call.parameter.names=Class constructor calls
inlay.parameters.python.show.hints.for.non-literal.arguments=非文字实参
install.packages.from.pipfile=从 Pipfile 安装软件包
integrated.tools.configurable.docstrings=Docstring
integrated.tools.configurable.packaging=打包
integrated.tools.configurable.pipenv=Pipenv
integrated.tools.configurable.restructuredtext=reStructuredText
integrated.tools.configurable.testing=测试
line.markers.popup.title.choose.overriding.method=选择 {0} 的重写方法
line.markers.popup.title.choose.subclass=选择 {0} 的子类
line.markers.popup.title.choose.super.attribute=选择 {0} 的 super 特性
line.markers.popup.title.choose.super.method=选择 {0} 的 super 方法
line.markers.tooltip.has.overridden.methods=具有被重写的方法
line.markers.tooltip.has.subclasses=具有子类
line.markers.tooltip.header.is.overridden.in=在以下位置被重写:
line.markers.tooltip.header.is.subclassed.by=被以下类子类化:
line.markers.tooltip.overrides.attribute.in.class=重写 {0} 中的特性
line.markers.tooltip.overrides.method.in.class=重写 {0} 中的方法
live.template.context.class=类
live.template.context.top.level=顶层
looking.for.default.interpreter=正在查找新项目的默认解释器设置
looking.for.inner.venvs=正在查找内部虚拟环境
looking.for.previous.interpreter=正在查找以前用过的解释器
looking.for.previous.system.interpreter=正在查找以前用过的系统级解释器
looking.for.related.venv=正在查找与项目相关的虚拟环境
looking.for.shared.conda.environment=正在查找共享的 conda 环境
looking.for.system.interpreter=正在查找系统级解释器
manage.python.packages=管理 Python 软件包
new.package.list.item.namespace.package=命名空间软件包
new.package.list.item.ordinary.package=软件包
notification.action.edit.settings=编辑设置
notification.group.cython=Python 调试器原生扩展可用
notification.group.package.requirements=Python 软件包要求
notification.group.packaging=Python 打包
notification.group.packaging.toolwindow=Python 软件包
notification.group.sciview.advertiser=建议使用 Python 科学视图
pandas.completion.type.text=DataFrame: {0}
path.ends.with.whitespace.warning.message=路径以空格结尾
path.label=路径:
path.must.be.absolute.error.message=路径必须是绝对路径
path.must.not.be.empty.error.message=路径不得为空
path.to.python.interpreter.dialog.title=Python 解释器的路径
postfix.template.condition.boolean.name=布尔
postfix.template.condition.builtin.len.applicable.name=适用内置 len
postfix.template.condition.dict.name=dict
postfix.template.condition.exception.name=异常
postfix.template.condition.iterable.name=可迭代对象
postfix.template.condition.list.name=列表
postfix.template.condition.non.none.name=非 None
postfix.template.condition.number.name=数字
postfix.template.condition.set.name=集合
postfix.template.condition.string.name=字符串
postfix.template.condition.tuple.name=元组
postfix.template.provider.name=Python
progress.text.connecting.to.console=正在连接到控制台…
progress.title.debugger.connection=调试器连接
project.cannot.be.generated=无法生成项目
pure.python.project=纯 Python
py.commandline.configure=为项目配置 Python SDK
py.module.dependencies.configurable.list.title=项目取决于这些项目:
py.sdk.editor.python.interpreter.label.text=Python 解释器:
pydev.console.console.process.terminated.with.error=控制台进程因错误而终止: \n\
{0}{1}
pydev.console.console.process.terminated.with.exit.code=控制台进程终止，退出代码为 {0}，输出: {1}
pydev.console.couldnt.connect.to.console.process=无法连接到控制台进程。
pydev.console.couldnt.read.integer.value.from.stream=无法读取流中的整数值
pydev.console.debugger.connected=\n\
调试器已连接。\n\

pydev.console.python.interpreter.is.not.selected=未选择 Python 解释器。请先安装 Python 解释器。
pydev.console.runner.error.running.console=运行控制台出错
pydev.console.runner.python.console.debugger=Python 控制台调试器
pydev.console.runner.settings=设置
pydev.console.runner.unknown.error=未知错误
python.add.sdk.conda.detecting=正在检测 conda…
python.add.sdk.conda.executable.path.is.empty=Conda 可执行文件路径为空
python.add.sdk.error=错误
python.add.sdk.panel.conda.create.new=创造新环境
python.add.sdk.panel.conda.env.name=环境名称:
python.add.sdk.panel.conda.use.existing=使用现有环境
python.add.sdk.panel.load.envs=加载环境
python.add.sdk.panel.name.conda.environment=Conda 环境
python.add.sdk.panel.name.existing.environment=现有环境
python.add.sdk.panel.name.new.environment=新环境
python.add.sdk.panel.name.new.environment.using=使用此工具新建环境
python.add.sdk.panel.name.new.project.interpreter=新项目解释器
python.add.sdk.panel.name.pipenv.environment=Pipenv 环境
python.add.sdk.panel.name.previously.configured.interpreter=先前配置的解释器
python.add.sdk.panel.name.system.interpreter=系统解释器
python.add.sdk.panel.name.virtualenv.environment=Virtualenv 环境
python.add.sdk.panel.path.to.conda.field=Conda 可执行文件
python.add.sdk.panel.wait=请稍候…
python.add.sdk.python.version=Python 版本:
python.call.graph=调用图
python.cldt.checking=正在检查命令行开发者工具的安装情况
python.cldt.installing.indicator=macOS 正在安装命令行开发者工具
python.cldt.installing.skip=跳过此步骤，稍后配置解释器
python.cldt.installing.suggestion=使用命令行开发者工具安装 Python
python.cldt.installing.title=正在等待 Python 安装和解释器设置
python.cldt.required=所选 Python 需要命令行开发者工具: {0}
python.colors.braces.and.operators.braces=大括号和运算符//大括号
python.colors.braces.and.operators.brackets=大括号和运算符//中括号
python.colors.braces.and.operators.comma=大括号和运算符//逗号
python.colors.braces.and.operators.dot=大括号和运算符//点
python.colors.braces.and.operators.operation.sign=大括号和运算符//运算符号
python.colors.braces.and.operators.parentheses=大括号和运算符//圆括号
python.colors.built.in.name=内置名称
python.colors.class.definition=类定义
python.colors.decorator=装饰器
python.colors.docstring.tag=Docstring//标签
python.colors.docstring.text=Docstring//文本
python.colors.functions.function.call=函数//函数调用
python.colors.functions.function.definition=函数//函数定义
python.colors.functions.method.call=函数//方法调用
python.colors.functions.nested.function.definition=函数//嵌套函数定义
python.colors.keyword=关键字
python.colors.keyword.argument=关键字实参
python.colors.line.comment=行注释
python.colors.local.variables=局部变量
python.colors.number=数字
python.colors.parameters.parameter=形参//形参
python.colors.parameters.self.parameter=形参//'self' 形参
python.colors.python=Python
python.colors.special.names.definition=特殊名称//定义
python.colors.special.names.usage=特殊名称//用法
python.colors.string.binary.bytes=字符串//二进制(字节)
python.colors.string.escape.sequence.invalid=字符串//转义序列//无效
python.colors.string.escape.sequence.valid=字符串//转义序列//有效
python.colors.string.f.string.expression.braces=字符串//格式化字符串///表达式大括号
python.colors.string.f.string.format.specifier.start=字符串//格式化字符串//格式说明符开始
python.colors.string.f.string.type.conversion=字符串//格式化字符串///类型转换
python.colors.string.text.unicode=字符串//文本 (unicode)
python.colors.type.annotation=类型注解
python.compatibility.inspection.advertiser.notifications.group.title=建议进行 Python 兼容性检查
python.compatibility.inspection.advertiser.notifications.title=Python 版本兼容性
python.compatibility.inspection.advertiser.using.future.imports.warning.message=您的源代码包含 __future__ 导入。<br/>要启用代码兼容性检查吗?<br/><a href="#yes">是</a>\\&nbsp;\\&nbsp;<a href="#no">否</a>
python.compatibility.inspection.advertiser.using.six.warning.message=您的源代码导入了 'six' 软件包。<br/>要启用代码兼容性检查吗?<br/><a href="#yes">是</a>\\&nbsp;\\&nbsp;<a href="#no">否</a>
python.compatibility.inspection.advertiser.version.stale.python3.version.warning.message=已为最高 {0} 的 Python 版本配置了代码兼容性检查。<br/>要为 Python {1} 启用吗?<br/><a href="#yes">是</a>\\&nbsp;\\&nbsp;<a href="#no">否</a>
python.concurrency.visualizer.scroll.end=滚动到结尾
python.configuration.choose.target.to.run=选择要运行的目标
python.console=Python 控制台
python.console.command.queue.add.title={0} 命令队列
python.console.command.queue.got.it.tooltip.id=python.console.command.queue.show
python.console.command.queue.got.it.tooltip.text=命令队列弹出窗口中列出了排队等待执行的命令
python.console.command.queue.got.it.tooltip.title=控制台命令队列
python.console.command.queue.show.action.description=显示带有命令队列的窗口
python.console.command.queue.show.action.text=显示命令队列
python.console.history.root=Python 控制台
python.console.not.supported=不支持 {0} 解释器的 Python 控制台
python.console.rename.message=输入新控制台名称:
python.console.run.anything.provider=运行 Python 控制台
python.console.toolbar.action.available.non.interactive=此操作不可用于非交互式 shell 
python.debug.remote.name=PyRemoteDebug
python.debugger.attaching=正在附加调试器
python.debugger.attaching.to.process.with.pid=正在附加到 PID={0} 的进程
python.debugger.collection.signatures.deleted=收集的签名已被删除
python.debugger.nothing.to.delete=没有要删除的内容
python.debugger.qt.backend.auto=自动
python.debugger.settings.connecting.to.debugger=正在连接到调试器
python.debugger.settings.waiting.for.connection=正在等待连接…
python.execute.selection.action.execute.line.in.console=执行 Python 控制台中的代码行
python.execute.selection.action.execute.selection.in.console=在 Python 控制台中执行选区
python.facet.name=Python
python.find.module.usages.dialog.label.prefix.module=模块
python.find.module.usages.dialog.label.prefix.package=软件包
python.folding.options.title=Python
python.input.file.doesn.t.exist=输入文件不存在
python.install.framework.checking.is.installed=正在检查是否已安装 {0}…
python.install.framework.ensure.installed=正在确保 {0} 已安装
python.install.framework.installing=正在安装 {0}…
python.interpreter.banner.slogan=Python 解释器 ''{0}''
python.interpreter.label=Python 解释器:
python.interpreter.local.configurable.remove.association=移除关联
python.interpreters.add.interpreter.action.text=添加新的解释器
python.interpreters.remove.interpreter.action.text=移除解释器
python.interpreters.rename.interpreter.action.text=重命名
python.interpreters.rename.interpreter.dialog.message=新名称:
python.interpreters.rename.interpreter.dialog.title=重命名 Python 解释器
python.interpreters.show.interpreter.paths.text=显示解释器路径
python.introduce.variable.refactoring.name=引入变量
python.language.configure.label=Python 配置
python.language.run.label=运行 Python 应用程序
python.local.attach.group.name=Python
python.long.collection.literals=长集合文字
python.long.string.literals=长字符串文字
python.module.description=Python 模块用于开发 <b>Python</b> 应用程序。
python.module.description.extended=支持的技术包括 <b>Django、Google App Engine、Jinja2</b> 等。
python.module.name=Python 模块
python.namespace.package.folder=命名空间软件包
python.namespace.packages.description=命名空间软件包文件夹
python.namespace.packages.name=命名空间软件包
python.new.project.error.solution.another.sdk=选择另一个 SDK
python.new.project.install.failed.title=安装 {0} 失败
python.new.project.more.settings=更多设置(&E)
python.new.project.remote.path.not.provided=未提供远程路径
python.new.project.synchronization.not.configured.dialog.message=本地/远程同步配置不正确。\n\
{0}\n\
您可能需要手动同步本地项目和远程项目。\n\
\n\
是否要继续?\n\
\n\
选择 ''是'' 将保留配置不当的映射，选择 ''否'' 将开始手动配置过程。
python.new.project.synchronization.not.configured.dialog.title=未配置同步
python.package.and.packaging.tools.installation.notification.message=Python 打包工具和 {0} 将安装在所选解释器上
python.package.installation.notification.message={0} 将安装在选定的解释器上
python.packages.dictionary.name=Python 软件包字典
python.packages.no.details.in.repo=<html><head></head><body><p class="empty_description">无法从 {0} 读取软件包描述。</p></body></html>
python.packaging.adding.conda.channel=添加 Conda 通道
python.packaging.button.install.package=安装软件包
python.packaging.choose.packages.to.install=选择要安装的软件包
python.packaging.collapse.options=<< 收起选项
python.packaging.command.line=命令行
python.packaging.could.not.parse.response=<html><head></head><body><p class="empty_description">无法为来自 {1} 仓库的软件包 {0} 解析响应</p></body></html>
python.packaging.create.setup.author=作者
python.packaging.create.setup.author.email=作者电子邮件
python.packaging.create.setup.description=描述
python.packaging.create.setup.license=许可证
python.packaging.create.setup.package.name=软件包名称
python.packaging.create.setup.py=创建 setup.py
python.packaging.create.setup.url=URL
python.packaging.create.setup.version=版本
python.packaging.dialog.description.attempt.to.uninstall.for.one.dependent.package=您将要卸载 {1} {2, choice, 1#软件包|2#软件包}所需的 {0} 软件包。\n\
\n\
是否要继续?
python.packaging.dialog.description.attempt.to.uninstall.for.several.dependent.packages=您将要卸载其他软件包所需的软件包。\n\
\n\
{0}\n\
\n\
是否要继续?
python.packaging.dialog.description.attempt.to.uninstall.for.several.dependent.packages.single.package.description={0} -> {1}
python.packaging.enter.setup.py.task=输入 setup.py 任务名称
python.packaging.expand.options=展开选项 >>
python.packaging.failed.to.install.packages.title=无法安装软件包
python.packaging.failed.to.install.packaging.tools.title=无法安装 Python 打包工具
python.packaging.failed.to.run.task=无法运行任务: {0}
python.packaging.install=安装
python.packaging.install.packaging.tools=安装打包工具
python.packaging.install.progress=正在安装软件包 {0}
python.packaging.installing.packages=正在安装软件包…
python.packaging.installing.packaging.tools=正在安装打包工具…
python.packaging.interpreter.widget.manage.packages=管理软件包…
python.packaging.list.progress=正在读取已安装的 Python 软件包
python.packaging.loading.packages.progress.text=正在加载软件包…
python.packaging.no.tasks.found=找不到任务
python.packaging.notification.deleted=软件包 {0} 已删除
python.packaging.notification.description.details.link=详细信息…
python.packaging.notification.description.installed.all.requirements=已安装所有要求
python.packaging.notification.description.installed.packages=已安装的软件包: {0}
python.packaging.notification.description.installed.python.packaging.tools=已安装 Python 打包工具
python.packaging.notification.description.uninstalled.packages=已卸载软件包: {0}
python.packaging.notification.installed=软件包 {0} 已安装
python.packaging.notification.title.error.occurred={0}: 发生错误。
python.packaging.notification.title.install.packages.failed=安装软件包失败
python.packaging.notification.title.packages.installed.successfully=已成功安装软件包
python.packaging.notification.title.packages.uninstalled.successfully=已成功卸载软件包
python.packaging.notification.title.uninstall.packages.failed=卸载软件包失败
python.packaging.notification.update.failed=无法更新 {0}
python.packaging.notification.updated=软件包 {0} 已更新至版本 {1}
python.packaging.open.toolwindow.link=转到工具窗口
python.packaging.operation.failed.title=打包操作失败
python.packaging.progress.text.installing.specific.package=正在安装软件包 ''{0}''…
python.packaging.progress.title.installing.packages=正在安装软件包
python.packaging.progress.title.uninstalling.packages=正在卸载软件包
python.packaging.removing.conda.channel=移除 Conda 通道
python.packaging.repository.form.authorization=授权:
python.packaging.repository.form.authorization.basic=基本 HTTP
python.packaging.repository.form.authorization.none=无
python.packaging.repository.form.default.name=软件包仓库
python.packaging.repository.form.login=登录名:
python.packaging.repository.form.password=密码:
python.packaging.repository.form.url=仓库 URL:
python.packaging.repository.manage.dialog.name=Python 软件包仓库
python.packaging.run.setup.py.task=运行 setup.py 任务…
python.packaging.run.setup.task.0=运行安装任务 {0}
python.packaging.toolwindow.advertisement=在 Python 软件包工具窗口中尝试重新设计的打包支持。
python.packaging.uninstall.progress=正在卸载软件包 {0}
python.packaging.update.progress=正在更新软件包 {0}
python.packaging.warning=警告
python.project.view.py.skeletons=二进制框架
python.project.view.remote.libraries=远程库
python.project.view.typeshed.stubs=Typeshed 存根
python.project.view.user.skeletons.node=扩展定义
python.provide.a.qualified.name.of.a.module=提供模块的限定名称
python.pyproject.install.package=安装软件包 {0}
python.pyproject.install.self.as.editable=Run 'pip install -e .'
python.pyproject.install.self.as.editable.progress=Running 'pip install -e .'
python.pyproject.install.self.error=Error Running 'pip install -e .'
python.pyproject.package.completion.tail=Python 软件包
python.pyproject.package.not.installed=Package {0} is not installed
python.python.namespace.package.folder=Python 命名空间软件包
python.remote.interpreter.can.t.create.project.this.type=无法在远程解释器上创建此类型的项目。选择本地解释器。
python.remote.process.starter.can.t.run.remote.interpreter=无法运行远程 Python 解释器: {0}
python.rename.processor.override.message=类 {1} 的方法 {0}\n\
重写了类 {2} 的方法。\n\
是否要重命名基方法?
python.rename.processor.property=是否要重命名属性 ''{0}'' 而不是其访问器函数 ''{1}''?
python.requirements.action.name=同步 Python 需求
python.requirements.analyzing.imports.title=正在分析项目中的导入
python.requirements.balloon=同步 Python 需求
python.requirements.error.ends.with.slash=解析需求出错: 文件以 '/' 符号结尾。
python.requirements.error.no.interpreter=已配置同步需求所需的解释器。
python.requirements.info.file.ref.dropped=基本文件中的某些需求未更新: {0}
python.requirements.keep.matching.specifier=如果现有版本与当前版本相匹配，则保留现有版本说明符
python.requirements.modify.base.files=修改基本文件(使用 -r 或 --requirement 定义的文件)
python.requirements.remove.unused=移除未使用的需求
python.requirements.version.label=需求版本:
python.requirements.version.separator.compatible=兼容版本
python.requirements.version.separator.gte=大于或等于
python.requirements.version.separator.no.version=不指定版本
python.requirements.version.separator.strong.eq=强相等
python.requirements.warning.unhandled.lines=无法分析需求文件中的条目: {0}
python.run.anything.file.provider=运行 Python 文件
python.run.anything.pip.provider=运行 pip 命令
python.run.configuration=Python 运行配置
python.run.configuration.fragments.chooser.hint=运行 Python 脚本或模块
python.run.configuration.fragments.content.roots=将内容根添加到 PYTHONPATH
python.run.configuration.fragments.content.roots.hint=将内容根添加到 PYTHONPATH
python.run.configuration.fragments.emulate.terminal=在输出控制台中模拟终端
python.run.configuration.fragments.emulate.terminal.hint=在输出控制台中模拟终端
python.run.configuration.fragments.interpreter.field=Python 解释器
python.run.configuration.fragments.interpreter.options=解释器选项
python.run.configuration.fragments.interpreter.options.hint=Python 解释器选项
python.run.configuration.fragments.module.name.hint=模块名称
python.run.configuration.fragments.plugin.sdk.chooser.hint=Python 解释器
python.run.configuration.fragments.plugin.sdk.of.module=使用模块的 SDK
python.run.configuration.fragments.plugin.sdk.of.module.hint=选择模块
python.run.configuration.fragments.plugin.specified.interpreter=使用指定的解释器
python.run.configuration.fragments.plugin.specified.interpreter.hint=选择 Python 解释器
python.run.configuration.fragments.project=项目
python.run.configuration.fragments.project.hint=选择项目
python.run.configuration.fragments.python.group=Python
python.run.configuration.fragments.run.with.python.console=使用 Python 控制台运行
python.run.configuration.fragments.run.with.python.console.hint=在 Python 控制台中执行运行配置
python.run.configuration.fragments.script.parameters=形参
python.run.configuration.fragments.script.parameters.hint=脚本形参
python.run.configuration.fragments.script.path.hint=Python 脚本的路径
python.run.configuration.fragments.source.roots=将源根添加到 PYTHONPATH
python.run.configuration.fragments.source.roots.hint=将源根添加到 PYTHONPATH
python.run.python=Python
python.run.select.script=选择脚本
python.sdk.action.add.interpreter.based.on.target.text={0}…
python.sdk.action.add.local.interpreter.text=添加本地解释器…
python.sdk.action.add.new.interpreter.text=添加新的解释器
python.sdk.add.python.interpreter.title=添加 Python 解释器
python.sdk.admin.permissions.needed.consider.creating.venv=<html><strong>注</strong>: 您需要具备管理员权限才能为此解释器安装软件包。不妨改为按项目创建虚拟环境。</html>
python.sdk.admin.permissions.needed.consider.creating.venv.content=<strong>注</strong>: 您需要具备管理员权限才能为此解释器安装软件包。不妨改为按项目创建虚拟环境。
python.sdk.can.t.obtain.python.version=无法获取 Python 版本
python.sdk.cannot.evaluate.sdk.version.error.message=无法评估 sdk 版本
python.sdk.cannot.execute=无法执行 {0}
python.sdk.cannot.setup.sdk=无法在 {0} 设置 Python SDK。\n\
该 SDK 似乎无效。
python.sdk.choose.valid.interpreter=选择有效的 Python 解释器
python.sdk.common.options.environment=环境
python.sdk.conda.cant.create.body=错误是: ''{0}''
python.sdk.conda.cant.create.title=Conda 无法创建新环境
python.sdk.conda.env=环境
python.sdk.conda.getting.list.envs=正在获取 conda 环境列表
python.sdk.conda.no.exec=找不到 Conda 可执行文件
python.sdk.conda.path=Conda 可执行文件:
python.sdk.conda.problem.env.empty.invalid=环境名称为空或无效
python.sdk.conda.problem.env.name.used=此名称已被使用。请选择其他名称。
python.sdk.conda.problem.running=运行 Conda 时出现问题
python.sdk.configurable.name=Python SDK
python.sdk.configuration.tab.title=类
python.sdk.consider.installing.python.manually=不妨从 https://www.python.org 手动安装 Python。
python.sdk.creating.conda.environment.sentence=正在创建 conda 环境
python.sdk.creating.conda.environment.title=正在创建 Conda 环境
python.sdk.dialog.message.cannot.find.script.file.please.run.poetry.install.before.executing.scripts=找不到脚本文件\n\
请在执行脚本之前运行 'poetry install'
python.sdk.dialog.message.creating.virtual.environments.based.on.poetry.environments.not.supported=不支持基于 Poetry 环境创建虚拟环境
python.sdk.dialog.title.poetry.scripts=Poetry 脚本
python.sdk.dialog.title.setting.up.poetry.environment=正在设置 Poetry 环境
python.sdk.directory.macro.description=此目录包含为项目选择的 Python 解释器
python.sdk.directory.not.found=找不到目录 {0}
python.sdk.downloading=下载中{0}
python.sdk.empty.version.string=Python 解释器将空输出作为版本字符串返回
python.sdk.environment.yml.chooser=选择 environment.yml
python.sdk.environment.yml.label=environment.yml
python.sdk.error.invalid.interpreter.name=Python 解释器名称 ''{0}'' 无效!
python.sdk.executable.not.found.header=找不到 Python 可执行文件。选择以下选项之一:
python.sdk.executable.not.found.option.download.and.install=点击 {0} 从 python.org 下载并安装 Python ({1})
python.sdk.executable.not.found.option.install.or.brew=从 python.org 或通过 Homebrew 手动安装 Python
python.sdk.executable.not.found.option.install.with.cldt=点击 {0}，使用命令行开发者工具安装 Python: {1}
python.sdk.executable.not.found.option.specify.path=点击 {0} 以指定 {1} 在文件系统中的路径
python.sdk.failed.to.create.interpreter.title=无法创建解释器
python.sdk.failed.to.install.exit.code=退出代码 {0}
python.sdk.failed.to.install.timed.out=已超时
python.sdk.failed.to.install.title=无法安装 {0}
python.sdk.file.not.found=找不到文件 {0}
python.sdk.finish=完成
python.sdk.getting.remote.interpreter.version=正在获取远程解释器版本
python.sdk.inspection.message.poetry.interpreter.associated.with.another.project=Poetry 解释器与另一个 {0} 关联: {1}
python.sdk.inspection.message.poetry.interpreter.not.associated.with.any.project=Poetry 解释器未与任何 {0} 关联
python.sdk.inspection.message.version.outdated.latest=''{0}'' 版本 {1} 已过时(最新: {2})
python.sdk.install.requirements.from.pipenv.lock=Pipfile.lock 中的安装要求
python.sdk.installation.has.been.cancelled.title={0} 安装已被取消
python.sdk.installing=正在安装 {0}
python.sdk.installing.windows.warning=Windows 可能需要您批准后才能安装 Python。请检查任务栏。
python.sdk.intention.family.name.install.requirements.from.poetry.lock=poetry.lock 中的安装要求
python.sdk.interpreter.executable.path.title=Python 解释器可执行文件路径
python.sdk.invalid.python.sdk=无效的 Python SDK
python.sdk.new.environment.kind=新 {0} 环境
python.sdk.new.project.environment=环境:
python.sdk.new.project.environment.type=环境类型:
python.sdk.next=下一个
python.sdk.no.interpreter.configured.warning=未为此项目配置 Python 解释器
python.sdk.no.interpreter.selection=未选择 Python 解释器
python.sdk.non.zero.exit.code=Python 解释器进程以非零退出代码 {0} 退出
python.sdk.pipenv.associated.module=关联模块:
python.sdk.pipenv.associated.project=关联项目:
python.sdk.pipenv.executable=Pipenv 可执行文件:
python.sdk.pipenv.executable.not.found=找不到 Pipenv 可执行文件
python.sdk.pipenv.execution.exception.error.running.pipenv.message=运行 Pipenv 时出错
python.sdk.pipenv.execution.exception.no.pipenv.message=找不到 Pipenv
python.sdk.pipenv.execution.exception.no.project.message=找不到与此 Pipenv 环境关联的项目
python.sdk.pipenv.has.been.selected=已添加 Pipenv 解释器，选择解释器列表中的 ''{0}''
python.sdk.pipenv.pip.file.lock.not.found=找不到 Pipfile.lock
python.sdk.pipenv.pip.file.lock.out.of.date=Pipfile.lock 过期
python.sdk.pipenv.pip.file.notification.content=运行 <a href='#lock'>pipenv lock</a> 或 <a href='#update'>pipenv update</a>
python.sdk.pipenv.pip.file.notification.locking=正在锁定 Pipfile
python.sdk.pipenv.pip.file.notification.updating=正在更新 Pipenv 环境
python.sdk.pipenv.pip.file.watcher=Pipfile 观察程序
python.sdk.pipenv.quickfix.fix.pipenv.name=修复 Pipenv 解释器
python.sdk.pipenv.quickfix.use.pipenv.name=使用 Pipenv 解释器
python.sdk.pipenv.select.executable.title=选择 Pipenv 可执行文件的路径
python.sdk.poetry.action.run.script.text=运行 ''{0}''
python.sdk.poetry.associated.module=关联模块:
python.sdk.poetry.associated.project=关联项目:
python.sdk.poetry.dialog.message.poetry.interpreter.has.been.already.added=已添加 Poetry 解释器，选择 ''{0}''
python.sdk.poetry.environment.panel.title=Poetry 环境
python.sdk.poetry.executable=Poetry 可执行文件:
python.sdk.poetry.executable.not.found=找不到 Poetry 可执行文件
python.sdk.poetry.execution.exception.error.running.poetry.message=运行 Poetry 时出错
python.sdk.poetry.execution.exception.no.poetry.message=找不到 Poetry
python.sdk.poetry.execution.exception.no.project.message=找不到与此 Poetry 环境关联的项目
python.sdk.poetry.install.packages.from.toml.checkbox.text=从 pyproject.toml 安装软件包
python.sdk.poetry.pip.file.lock.not.found=找不到 poetry.lock
python.sdk.poetry.pip.file.lock.out.of.date=poetry.lock 已过期
python.sdk.poetry.pip.file.notification.content=运行 <a href='#lock'>poetry lock</a> 或 <a href='#update'>poetry update</a>
python.sdk.poetry.pip.file.notification.content.without.updating=运行 <a href='#lock'>poetry lock</a>、<a href='#noupdate'>poetry lock --no-update</a> 或 <a href='#update'>poetry update</a>
python.sdk.poetry.pip.file.notification.locking=正在锁定 poetry.lock
python.sdk.poetry.pip.file.notification.locking.without.updating=正在锁定 poetry.lock 而不更新
python.sdk.poetry.pip.file.notification.updating=正在更新 Poetry 环境
python.sdk.poetry.pip.file.watcher=pyproject.toml 观察程序
python.sdk.poetry.quickfix.fix.pipenv.name=修正 Poetry 解释器
python.sdk.poetry.quickfix.use.pipenv.name=使用 Poetry 解释器
python.sdk.poetry.select.executable.title=选择 Poetry 可执行文件的路径
python.sdk.popup.add.interpreter=添加解释器…
python.sdk.popup.interpreter.settings=解释器设置…
python.sdk.previous=上一个
python.sdk.python.interpreter.title.0=Python 解释器: {0}
python.sdk.rendering.project.default=项目默认设置
python.sdk.rendering.project.default.0=项目默认值 ({0})
python.sdk.running=正在运行 {0}
python.sdk.scanning.installed.packages=正在扫描已安装的软件包…
python.sdk.select.conda.path.title=选择 Conda 可执行文件路径
python.sdk.select.location.for.conda.title=选择 Conda 环境的位置
python.sdk.setting.up.pipenv.sentence=正在设置 pipenv 环境
python.sdk.setting.up.pipenv.title=正在设置 Pipenv 环境
python.sdk.some.installed.python.components.might.get.inconsistent.after.cancellation=取消后，某些已安装的 Python 组件可能会变得不一致。
python.sdk.switch.to=切换到 {0}
python.sdk.there.is.no.interpreter=无解释器
python.sdk.try.to.install.python.manually=尝试从 https://www.python.org 手动安装 Python。
python.sdk.unpacking.pre.generated.skeletons=正在解压缩预生成的框架…
python.sdk.updater.notifications.group.title=Python 解释器更新失败
python.sdk.updating.skeletons=正在更新框架…
python.sequential.comments=顺序注释
python.symbol.chooser.dialog.title=选择符号
python.task.cannot.find.python.interpreter.for.selected.module=找不到所选模块的 Python 解释器
python.template.language.none=无
python.template.select.file.type=选择文件类型
python.testing.cant.find.where.declared=在声明 {0} 的位置找不到文件。确保它存在于项目根中
python.testing.cant.get.importable.name=无法获得 {0} 的可导入名称。它是项目中的 Python 文件吗?
python.testing.cant.resolve=无法解析 {0}。尝试移除配置并再次生成
python.testing.pattern.can.only.be.used=模式只能用于匹配一个文件夹中的多个文件。无法对一个文件使用模式。
python.testing.provide.qualified.name=提供函数、类或模块的限定名称
python.testing.target.not.provided=未提供该目标
python.toolwindow.packages.add.package.action=添加软件包
python.toolwindow.packages.add.package.as.editable=作为 editable (-e)安装
python.toolwindow.packages.add.package.dialog.title=安装软件包
python.toolwindow.packages.add.package.from.disc=从磁盘
python.toolwindow.packages.add.package.from.vcs=从版本控制
python.toolwindow.packages.add.package.path=路径:
python.toolwindow.packages.add.package.path.selector=选择文件或目录
python.toolwindow.packages.add.package.vcs.bzr=Bazaar
python.toolwindow.packages.add.package.vcs.git=Git
python.toolwindow.packages.add.package.vcs.hg=Mercurial
python.toolwindow.packages.add.package.vcs.svn=Subversion
python.toolwindow.packages.converting.description.progress=正在读取软件包描述
python.toolwindow.packages.custom.repo.invalid={0}(授权失败)
python.toolwindow.packages.custom.repo.searched={0} (找到 {1} 个)
python.toolwindow.packages.delete.package=删除软件包
python.toolwindow.packages.description.panel.placeholder=选择软件包以查看文档
python.toolwindow.packages.documentation.link=文档
python.toolwindow.packages.documentation.local.interpreter=PyCharm 至少需要一个本地解释器才能显示软件包文档。
python.toolwindow.packages.install.link=安装
python.toolwindow.packages.installed.label=已安装
python.toolwindow.packages.latest.version.label=最新
python.toolwindow.packages.load.more=… 其他 {0} 个条目。双击以显示更多。
python.toolwindow.packages.manage.repositories.action=管理仓库
python.toolwindow.packages.no.description.placeholder=<html><head></head><body><p class="empty_description">软件包作者未提供描述。</p></body></html>
python.toolwindow.packages.no.interpreter.text=选择解释器以查看所安装的软件包
python.toolwindow.packages.reload.repositories.action=重新加载所有仓库
python.toolwindow.packages.rst.parsing.failed=无法解析描述
python.toolwindow.packages.search.text.placeholder=搜索更多软件包
python.type.annotations=类型注解
python.unknown.project.synchronizer.this.interpreter.type.does.not.support.remote.project.creation=此解释器类型不支持创建远程项目
python.unmark.as.namespace.package=取消标记为命名空间软件包
python.unmark.as.python.namespace.package=取消标记为 Python 命名空间软件包
python.unresolved.reference.inspection.install.package=安装软件包 {0}
python.vagrant.refresh.skeletons=启动 vagrant 并刷新框架
refactoring.change.signature.dialog.default.value.checkbox=在签名中使用默认值:
refactoring.change.signature.dialog.name.label=名称:
refactoring.change.signature.dialog.validation.default.missing=缺少默认值
refactoring.change.signature.dialog.validation.function.name=函数名称不正确
refactoring.change.signature.dialog.validation.multiple.double.star=不允许多个 ** 实参
refactoring.change.signature.dialog.validation.multiple.star=不允许多个 * 实参
refactoring.change.signature.dialog.validation.name.defined=名称已在作用域中定义
refactoring.change.signature.dialog.validation.parameter.missing=缺少形参名称
refactoring.change.signature.dialog.validation.parameter.name=形参名称不正确
refactoring.change.signature.error.lambda.call=文本光标位于 lambda 调用上
refactoring.change.signature.error.not.under.source.root=该函数不在源根下
refactoring.change.signature.error.tuple.parameters=该函数包含元组形参
refactoring.change.signature.error.wrong.caret.position.method.name=文本光标应置于要重构的方法的名称处
refactoring.change.signature.find.usages.of.base.class=类 {1} 的方法 {0}\n\
重写类 {2} 的方法。\n\
是否要重构基方法?
refactoring.change.signature.suggested.callSite.value=调用点的值
refactoring.change.signature.suggested.callSite.value.optional=调用点的可选值
refactoring.change.signature.usage.view.declarations.header=要重构的函数
refactoring.convert.package.to.module.error.not.empty.package=软件包“{0}”不为空
refactoring.error.directory.exists=目录“{0}”已存在
refactoring.error.file.exists=文件“{0}”已存在
refactoring.extract.parameter.dialog.title=提取形参
refactoring.extract.super.class.no.members.allowed=无法提取任何成员
refactoring.extract.super.name.0.must.be.ident=名称 ''{0}'' 无效。必须为有效的 Python 标识符
refactoring.extract.super.target.class.already.exists=此模块中已存在类 ''{0}''
refactoring.extract.super.target.path.outside.roots=该目标目录在项目外部。必须在内容根内
refactoring.introduce.field.cannot.be.used.in.static.methods=static 方法中不能使用引入字段重构
refactoring.introduce.field.not.in.class=无法引入该字段: 不在类中
refactoring.introduce.field.setup.method=setUp() 方法
refactoring.introduce.parameter.dialog.title=引入形参
refactoring.make.function.top.level.error.attribute.writes=无法移动写入实例特性的方法
refactoring.make.function.top.level.error.method.calls=无法移动调用该类其他方法的方法
refactoring.make.function.top.level.error.nonlocal.writes=无法移动包含非局部写入的函数
refactoring.make.function.top.level.error.outer.scope.reads=无法移动引用外部作用域中的名称的方法
refactoring.make.function.top.level.error.private.attributes=无法移动引用私有实例特性的方法
refactoring.make.function.top.level.error.self.reads=无法移动外部作用域中包含 "self" 形参用法的函数
refactoring.make.function.top.level.error.special.usage.of.self=无法移动包含 "self" 形参特殊用法的方法
refactoring.make.local.function.top.level.dialog.description=将局部函数 {0} 移至顶层
refactoring.make.local.function.top.level.dialog.title=使之为顶层局部函数
refactoring.make.method.top.level.dialog.description=将方法 {0} 移至顶层
refactoring.make.method.top.level.dialog.title=使之为顶层方法
refactoring.move.choose.destination.file.title=选择目标文件
refactoring.move.error.cannot.use.module.name=不能在导入中使用模块名称 ''{0}''
refactoring.move.error.destination.file.contains.class=目标文件已包含名称为 ''{0}'' 的类
refactoring.move.error.destination.file.contains.function=目标文件已包含名称为 ''{0}'' 的函数
refactoring.move.error.destination.file.contains.global.variable=目标文件已包含名称为 ''{0}'' 的全局变量
refactoring.move.module.members=移动模块成员
refactoring.move.module.members.dialog.description.class=移动类 {0}
refactoring.move.module.members.dialog.description.function=移动函数 {0}
refactoring.move.module.members.dialog.description.selection=移动所选元素
refactoring.move.module.members.dialog.description.variable=移动全局变量 {0}
refactoring.move.module.members.dialog.table.title=批量移动(&M)
refactoring.move.module.members.dialog.title=移动模块成员
refactoring.move.module.members.error.selection=无法使用所选元素执行重构
refactoring.occurrences.count={0} ({1} 个匹配项)
refactoring.pull.up.dialog.members.to.be.moved=将移动以下成员
refactoring.pull.up.dialog.move.members.to.class=将成员移至类
refactoring.pull.up.dialog.title=向上拉取成员至
refactoring.pull.up.error.cannot.perform.refactoring.no.base.classes=类 {0} 没有超类，或者所有超类都不能用于重构
refactoring.pull.up.error.cannot.perform.refactoring.not.inside.class=无法执行向上拉取成员: 不在此类中
refactoring.rename=重命名
refactoring.rename.containing.file=重命名包含文件
refactoring.rename.containing.file.entity.name=Include 文件
refactoring.rename.containing.file.title=重命名包含文件
refactoring.rename.containing.file.with.the.following.name.to=将具有以下名称的包含文件重命名为:
refactoring.rename.inheritor.class.entity.name=继承者类
refactoring.rename.inheritor.classes.with.the.following.names.to=将具有以下名称的继承者类重命名为:
refactoring.rename.inheritors=重命名继承者
refactoring.rename.inheritors.title=重命名继承者
refactoring.rename.not.valid.identifier=名称 ''{0}'' 不是有效的 Python 标识符。无法更新 ''{1}'' 中的 import 语句
refactoring.rename.parameter.entity.name=形参
refactoring.rename.parameter.in.hierarchy.to=将层次结构中的形参重命名为:
refactoring.rename.parameters.in.hierarchy=重命名层次结构中的形参
refactoring.rename.parameters.title=重命名形参
refactoring.will.not.be.accessible=您在尝试移动的成员依赖于在此重构后无法访问的 ''{0}''
remote.debug.local.host=IDE 主机名:
remote.debug.port=端口:
remote.debug.redirect.output=将输出重定向到控制台
remote.debug.server.hint=启动此调试配置以启动调试服务器。
remote.debug.server.hint1.5=更新脚本:
remote.debug.server.hint2=1. 将 pydevd-pycharm.egg 从 PyCharm 安装目录添加到 Python 路径或执行:
remote.debug.server.hint3=pip 安装 pydevd-pycharm
remote.debug.server.hint4=2. 添加以下命令以连接至调试服务器:
remote.debug.suspend.on.connect=连接后挂起
remote.interpreter.accessing.remote.interpreter.progress.title=正在访问远程解释器
remote.interpreter.configure.path.label=Python 解释器路径:
remote.interpreter.configure.path.title=选择 Python 解释器
remote.interpreter.configure.ssh.run_as_root_via_sudo.checkbox=使用此解释器通过 sudo 以根权限执行代码
remote.interpreter.configure.ssh.run_as_root_via_sudo.help=仅在通过 SSH 连接启动远程解释器时才调用 Sudo。这些文件将通过用户权限被复制到远程服务器。
remote.interpreter.configure.temp.files.path.label=PyCharm 帮助程序路径:
remote.interpreter.configure.temp.files.path.title=为 PyCharm 帮助程序选择文件夹
remote.interpreter.configure.title=配置远程 Python 解释器
remote.interpreter.default.interpreter.path=/usr/bin/python
remote.interpreter.docker.default.interpreter.path=python
remote.interpreter.failed.to.obtain.credentials=无法获取 Python SDK {0} 的连接凭据
remote.interpreter.feature.is.not.available=远程解释器功能不可用
remote.interpreter.remote.server.permissions=无法浏览远程服务器。确保您具备权限。
remote.interpreter.support.is.not.available={0} 支持不可用。\n\
请检查相应插件。
remote.interpreter.unspecified.interpreter.path=指定 Python 解释器路径
remote.interpreter.unspecified.temp.files.path=为 PyCharm 帮助程序指定路径
remote.interpreter.unsupported.python.sdk.type=不受支持的 Python SDK 类型
remote.interpreter.wsl.default.interpreter.path=/usr/bin/python
remove.elif=移除 elif…
remove.else=移除 else…
rename.python.interpreter.dialog.provide.name.error.text=为 Python 解释器提供一个名称。
rename.python.interpreter.name.already.exists.error.text=已存在同名的 Python 解释器。
rest.configuration.editor.open.output.file.in.browser.label.text=在浏览器中打开输出文件
run.configuration.remote.debug.name=Python 远程调试
run.configuration.remote.debug.visible.name=Python 调试服务器
run.configuration.show.command.line.action.name=显示调试控制台
run.configuration.type.description=启动服务器进行远程调试
run.debug.shadowing.name.import.error.open.file=显示 {0}
run.debug.shadowing.name.import.error.rename=重命名 {0}
run.debug.shadowing.name.import.error.title=看起来 {0} 隐藏了标准库文件名。这可能会导致意外的运行/调试操作行为
runcfg.autodetect.display_name=自动检测
runcfg.captions.interpreter_options_dialog=输入解释器选项
runcfg.captions.script_parameters_dialog=输入脚本形参
runcfg.doctest.display_name=Doctest
runcfg.error.message.cannot.find.python.interpreter=找不到此运行配置的 Python 解释器
runcfg.error.message.failed.to.find.free.socket.port=找不到可用的套接字端口
runcfg.error.message.python.interpreter.is.invalid.configure=请<a href="#">重新配置</a> Python 解释器
runcfg.labels.add.content.roots.to.pythonpath=将内容根添加到 PYTHONPATH
runcfg.labels.add.source.roots.to.pythonpath=将源根添加到 PYTHONPATH
runcfg.labels.custom.name=自定义
runcfg.labels.environment_variables=环境变量(&E):
runcfg.labels.execution=执行
runcfg.labels.interpreter=使用指定的解释器(&U):
runcfg.labels.interpreter_options=解释器选项(&O):
runcfg.labels.module.name=模块名称
runcfg.labels.path.mappings=路径映射
runcfg.labels.project=项目(&J):
runcfg.labels.python.interpreter=Python 解释器(&P):
runcfg.labels.script.path=脚本路径
runcfg.labels.script_parameters=形参(&P):
runcfg.labels.use.sdk.of.module=使用模块的 SDK:
runcfg.labels.working_directory=工作目录(&W):
runcfg.nosetests.config.regexPattern=正则表达式模式
runcfg.nosetests.display_name=Nosetest
runcfg.pytest.config.keywords=关键字
runcfg.pytest.config.parameters=形参
runcfg.pytest.display_name=pytest
runcfg.python_tests.config.additionalArguments=其他实参
runcfg.python_tests.config.target=目标
runcfg.python_tests.config.targetType=目标类型
runcfg.test.description=PyCharm 支持 Python 框架
runcfg.test.display_name=Python 测试
runcfg.test.suggest.name.in.path={0} ({1} 内)
runcfg.test.suggest.name.in.python={1} 的 {0}
runcfg.testing.no.test.framework=在所选解释器中未找到 {0} 运行程序
runcfg.tests.cant_rerun=无法重新运行测试，因为无法解析测试 ID。尝试删除运行配置，然后点击右键以创建新配置。
runcfg.tests.empty_suite=空套件
runcfg.tox=tox
runcfg.tox.runner=tox 运行程序
runcfg.trial.display_name=Twisted Trial
runcfg.unittest.config.pattern=模式
runcfg.unittest.display_name=Unittest
runcfg.unittest.dlg.all_in_folder_title=文件夹中的所有
runcfg.unittest.dlg.all_in_script_title=脚本
runcfg.unittest.dlg.class_label=类:
runcfg.unittest.dlg.folder_path=文件夹:
runcfg.unittest.dlg.function_label=函数:
runcfg.unittest.dlg.interpreter_options_title=解释器选项:
runcfg.unittest.dlg.method_label=方法:
runcfg.unittest.dlg.pattern=模式:
runcfg.unittest.dlg.select.folder.path=选择文件夹路径:
runcfg.unittest.dlg.select.script.path=选择脚本路径:
runcfg.unittest.dlg.test_class_title=类
runcfg.unittest.dlg.test_function_title=函数
runcfg.unittest.dlg.test_method_title=方法
runcfg.unittest.dlg.test_script_label=脚本:
runcfg.unittest.dlg.test_type_title=测试:
runcfg.unittest.no_class_name=请指定类名
runcfg.unittest.no_folder_name=请指定包含测试的文件夹
runcfg.unittest.no_method_name=请指定方法名称
runcfg.unittest.no_module_name=请指定模块的限定名称
runcfg.unittest.no_module_sdk=请选择包含有效 Python SDK 的模块
runcfg.unittest.no_script_name=请指定脚本名称
runcfg.unittest.no_sdk=请指定 Python SDK
runcfg.unittest.no_valid_sdk=请选择有效的 Python 解释器
runcfg.unittest.suggest.name.in.class={0} ({1} 内)
runcfg.unittest.suggest.name.in.folder={0} ({1} 内)
runcfg.unittest.suggest.name.in.script={0} ({1} 内)
sdk.create.venv.conda.dialog.label.interpreter=解释器:
sdk.create.venv.conda.dialog.label.location=位置:
sdk.create.venv.conda.dialog.label.python.version=Python 版本:
sdk.create.venv.dependencies.chooser=选择 requirements.txt 或 setup.py
sdk.create.venv.dependencies.label=依赖项:
sdk.create.venv.dialog.base.interpreter.label=基础解释器:
sdk.create.venv.dialog.interpreter.label=解释器:
sdk.create.venv.dialog.label.inherit.global.site.packages=继承全局站点软件包
sdk.create.venv.dialog.location.label=位置:
sdk.create.venv.environment.label=环境:
sdk.create.venv.existing.option.label=现有
sdk.create.venv.new.option.label=新建
sdk.details.dialog.error.duplicate.name=为解释器指定唯一名称
sdk.details.dialog.hide.all.virtual.envs=隐藏与其他项目关联的虚拟环境
sdk.details.dialog.show.interpreter.paths=显示所选解释器的路径
sdk.details.dialog.title=Python 解释器
sdk.details.step.add=添加…
sdk.details.step.show.all=全部显示…
sdk.edit.dialog.associate.virtual.env.current.project=关联此环境与当前项目
sdk.edit.dialog.associate.virtual.env.with.path=关联此虚拟环境与 {0}
sdk.edit.dialog.specify.interpreter.path=指定解释器路径
sdk.edit.dialog.title=编辑 Python 解释器
sdk.gen.cannot.create.skeleton.dir=无法创建框架目录 {0}
sdk.gen.cleaning.up=正在清理框架…
sdk.gen.failed.notification.title=无法刷新远程解释器的框架
sdk.gen.launching.generator=正在启动框架生成器…
sdk.gen.reloading=正在重新加载生成的框架…
sdk.gen.stubs.for.binary.modules=生成二进制模块 {0} 的存根
sdk.gen.unpacking.prebuilt=正在解压缩预构建框架…
sdk.gen.updating.interpreter=正在更新 Python 解释器
sdk.has.been.configured.as.the.project.interpreter={0} 已被配置为项目解释器
sdk.has.been.configured.notification.name=已配置 Python 解释器
sdk.paths.dialog.added.by.user.suffix=(用户已添加)
sdk.paths.dialog.reload.paths=重新加载路径列表
sdk.paths.dialog.removed.by.user.suffix=(用户已移除)
sdk.paths.dialog.title=解释器路径
sdk.scanning.installed.packages=正在扫描已安装的软件包
sdk.select.path=选择 Python 解释器
sdk.some.skeletons.failed=无法生成某些框架
sdk.updating.interpreter.paths=正在更新解释器路径…
sdk.updating.interpreter.version=正在更新解释器版本…
settings.completion.ml.python.display.name=Python
settings.default.remote.interpreter=默认 Python 远程解释器
settings.postfix.choose.class.action.name=选择类…
settings.postfix.choose.class.prompt.text=选择类
settings.postfix.enter.class.action.name=输入类名…
settings.postfix.enter.class.dialog.name=选择类
settings.postfix.enter.fully.qualified.class.name=输入完全限定类名
show.expression.type.no.expression.found=找不到表达式
smartKeys.insert.self.in.method=定义方法时插入 'self'
smartKeys.insert.type.placeholder.in.docstring.stub=在文档注释存根中插入类型占位符
smartKeys.wrap.in.parentheses.instead.of.backslash=使用括号代替反斜杠来换行
sphinx.ask.for.working.directory.label.text=Sphinx 工作目录
switch.python.interpreter=切换 Python 解释器
toolwindow.stripe.Jupyter_Variables=Jupyter 变量
toolwindow.stripe.Python_Console=Python 控制台
toolwindow.stripe.Python_Packages=Python 软件包
toolwindow.stripe.SciView=SciView
unable.to.stop=无法停止当前正在运行的进程。先手动终止此进程。
unwrap.elif=解包 elif…
unwrap.else=解包 else…
unwrap.for=解包 for…
unwrap.if=解包 if…
unwrap.try=解包 try…
unwrap.while=解包 while…
unwrap.with=解包 with…
vcs.activate.virtualenv.checkbox.text=为挂钩激活 Virtualenv
windowWithActions.closeWindow=关闭窗口
windowWithActions.stopProcess=停止当前运行的进程
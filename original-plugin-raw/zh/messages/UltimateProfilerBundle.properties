action.hprof-viewer.text=打开 Hprof 快照
action.profiler.DisableProfileOnRunToCursor.text=使用“运行到光标”禁用记录时间
action.profiler.EnableProfileOnRunToCursor.text=使用“运行到光标”记录时间
action.profiler.profileOnRunToCursor.activated.message=在下一个调试会话中，“运行到光标”时将启用性能记录。
action.profiler.profileOnRunToCursor.cant.start.message=无法记录性能\: {0}
action.profiler.profileOnRunToCursor.disabled=调试器会话可能已失败，因为性能记录器不支持 JVM。它已被自动禁用。请重新启动调试会话。
async.profiler.dump.name=异步分析器转储
async.profiler.troubleshoot.dump.is.empty=转储为空。
async.profiler.troubleshoot.dump.is.empty.0=转储为空。{0}
async.profiler.troubleshoot.dump.is.missing=缺少转储。
async.profiler.troubleshoot.duplicate.arguments=某些代理实参重复。检查分析器配置。
async.profiler.troubleshoot.failed.to.attach=无法附加分析器。
async.profiler.troubleshoot.failed.to.run.jfrsync=无法激活 JFR 同步。
async.profiler.troubleshoot.jfrsync.creation.interrupted=在 JfrSync 初始化期间，执行可能已被中断。
async.profiler.troubleshoot.jfrsync.incompatible.jdk=1.8 之前的 Java 版本不支持分析。如果您使用的是版本 11 之前的 Oracle JDK，或者版本 1.8.0_252 之前的 HotSpot JDK，请添加 -XX\:+UnlockCommercialFeatures 虚拟机选项。
async.profiler.troubleshoot.jfrsync.start.failure=开始录制时出错。
async.profiler.troubleshoot.jfrsync.start.interrupted=在 JfrSync 启动期间，执行可能已被中断。
async.profiler.troubleshoot.no.data.in.0.ms=分析器无法在 {0} 毫秒内写入数据。
async.profiler.troubleshoot.no.data.process.killed=已分析的进程是否已被强制终止?
async.profiler.troubleshoot.profiler.not.started=缺少转储。最有可能的是，分析尚未开始。
async.profiler.troubleshoot.profiler.not.started.gradle=实际进程可能是由 Gradle 生成的，而分析器无法捕获它。
async.profiler.troubleshoot.profiler.not.started.short.session=会话可能太短，无法附加分析器({0} 毫秒)。
async.profiler.troubleshoot.reasons={0} 可能的原因\:
async.profiler.troubleshoot.stopped.before.flushed=在分析器将数据刷新到快照之前，会话可能已经停止。
attach.process.current=当前
dialog.title.jfr.choose.configuration=选择 JFR 配置
download.profiler.dump.from.target.failed=无法从目标下载分析器转储
download.profiler.dump.from.target.failed.environment.missing=未提供目标环境
download.profiler.dump.from.target.progress.title=正在从目标下载分析器转储…
dtrace.configurable.settings.only.attach=此配置只能附加到正在运行的进程
dtrace.exceptions.cant.attach=无法附加分析器\: 目标进程应通过 -XX\:+PreserveFramePointer 虚拟机选项运行
dtrace.exceptions.cant.find.agent=找不到代理。设置 {0} 属性
dtrace.exceptions.details.link=点击此处了解详细信息
filetype.hprof.dump.description=Hprof 内存快照
filetype.hprof.dump.display.name=Hprof 内存快照
filetype.jfr.dump.description=Java Flight Recorder 快照
filetype.jfr.dump.display.name=JFR 快照
group.RunTab.ProfileActions.text=分析进程
hprof.action.duplicated.strings=计算重复的字符串数量
hprof.action.open.dominators=计算支配项
hprof.action.open.dominators.view=计算保留大小和最大对象
hprof.action.open.merged.paths=计算合并路径
hprof.action.open.new.tab=在新标签页中打开
hprof.action.open.references=计算引用
hprof.action.open.retained.objects=显示保留对象树
hprof.action.open.roots.view=显示 GC 根
hprof.action.open.shortest.paths=计算最短路径
hprof.action.sunburst.history.back=后退
hprof.action.sunburst.history.forward=前进
hprof.action.sunburst.history.home=返回到 ''{0}''
hprof.action.sunburst.restore=还原图表位置
hprof.classes.column.class=类
hprof.classes.column.count=计数
hprof.classes.column.retained=保留
hprof.classes.column.size=浅层
hprof.dump.name=Hprof 转储
hprof.duplicates.column.instances.count=重复项
hprof.duplicates.column.value=值
hprof.duplicates.column.waste=已浪费(字节)
hprof.duplicates.empty=找不到重复项
hprof.load.error.failed.with.message=无法打开包含消息的快照文件\:
hprof.load.error.failed.without.message=由于内部错误，无法打开快照文件
hprof.load.error.fileIsCorrupted=快照文件损坏
hprof.load.error.unsupportedFormat=不支持此类型的 HPROF 快照(错误的二进制标头\: {0})
hprof.load.error.yourkitSnapshots=YourKit 快照不受支持
hprof.merged.instances={0} {1,choice,1\#实例|2\#实例}
hprof.object.view.loading=正在加载对象…
hprof.object.view.na=不适用
hprof.object.view.of=/
hprof.object.view.static=statically from
hprof.objects.column.node=项
hprof.objects.column.retained_size=保留
hprof.objects.column.shallow_size=浅层
hprof.render.utils.modificators.gcroot=GC 根\: {0}
hprof.render.utils.modificators.static=static
hprof.render.utils.modificators.undefined=未定义
hprof.render.utils.values.null=null
hprof.status.calculate.shallow=Hprof\: 正在计算浅层大小
hprof.status.compute.dominators=Hprof\: 正在计算支配树
hprof.status.compute.duplicated.strings=Hprof\: 收集重复的字符串
hprof.status.compute.retained=Hprof\: 正在计算保留大小
hprof.status.dominators=Hprof\: 正在收集支配项
hprof.status.objects=Hprof\: 正在收集对象
hprof.status.parse=Hprof\: 正在解析文件
hprof.status.reverse=Hprof\: 正在收集引用
hprof.status.save=Hprof\: 正在保存索引
hprof.status.save.dominators=Hprof\: 正在保存支配树
hprof.stub.first.results=<显示前 %,d 个结果>
hprof.stub.null.value=null
hprof.stub.shortest.paths.truncated=<多个路径因过长而被截断>
hprof.stub.unknown=<unknown>
hprof.stub.unknown.class=<unknown class>
hprof.stub.unknown.type=<unknown type>
hprof.stub.values=<值 %,d–%,d>
hprof.sunburst.tree.others=其他(可能不完整)
hprof.tab.biggest.objects=最大对象
hprof.tab.classes=类
hprof.tab.dominators=支配项
hprof.tab.duplicated.strings=重复的字符串
hprof.tab.merged.paths=合并的路径
hprof.tab.packages=软件包
hprof.tab.references=传入引用
hprof.tab.retained.dominators=支配树
hprof.tab.retained.objects=保留对象
hprof.tab.shortest.paths=最短路径
hprof.tab.summary=摘要
hprof.tab.summary.bytes=字节总数
hprof.tab.summary.classes=类总数
hprof.tab.summary.classloaders=ClassLoader
hprof.tab.summary.instances=实例总数
hprof.tab.summary.roots=GC 根
hprof.tab.summary.thread=ID \= {0} 的线程
hprof.tab.summary.thread.loading=正在加载线程信息…
hprof.tab.summary.threadWithName=ID \= {1} 的线程 ''{0}''
jfr.cant.attach.unsupported=无法附加分析器\: 目标 VM 不支持 JFR。
jfr.cant.configure.options=无法在运行时更改 Flight Recorder 虚拟机选项。将使用现有选项。
jfr.cant.stop.profiler=无法停止分析器。请参见日志了解详细信息。
jfr.commercial.message=必须解锁商业功能才能启动目标进程的 Flight Recording。<br>您可以调用 ''jcmd {0} VM.unlock_commercial_features'' 解锁商业功能。您还可以向命令行添加 ''-XX\:+UnlockCommercialFeatures'' 并重启目标进程。<br>商业功能受二进制代码许可证保护。
jfr.commercial.url.text=了解二进制代码许可证
jfr.configurable.settings.custom.file=自定义设置文件\:
jfr.configurable.settings.label=分析设置\:
jfr.configurable.settings.radiobutton.default=默认
jfr.configurable.settings.radiobutton.profile=配置文件
jfr.configurable.settings.vm.options.comment.text=<a href\="https\://docs.oracle.com/javase/10/tools/java.htm">VM 选项列表</a>
jfr.configurable.settings.vm.options.label=分析虚拟机选项\:
jfr.cpu.sampling.events.shown.limited.message=此视图仅显示前 {0} 个事件。使用其他视图来分析完整信息。
jfr.default.settings.comment=可以在生产环境中连续使用的低开销配置，通常少于 1% 开销
jfr.dump.name=Java Flight Recorder 转储
jfr.error.no.dump.file.message=无法生成分析器转储\: 请检查 JVM 是否支持分析
jfr.event.cpu.samples.display.name=CPU 示例
jfr.event.memory.allocations.display.name=内存分配
jfr.event.wall.cpu.display.name=CPU 时间
jfr.event.wall.total.display.name=总时间
jfr.old.java.message=启动 Java Flight Recorder 至少需要 java 11
jfr.parser.result.failure.cant.parse=无法解析转储文件
jfr.parser.result.failure.file.invalid.format=无效文件格式
jfr.parser.result.failure.memory=内存不足，无法加载转储
jfr.profile.cant.attach=无法附加分析器
jfr.profile.settings.comment=适于分析的低开销配置，通常大约为 2% 开销
jfr.stacks.can.be.truncated=使用默认 Flight Recorder 虚拟机选项时，'stackdepth' 形参设置为 64。深度超过 64 帧的堆栈跟踪将被截断。
jfr.timeline.cpu.events.display.name=CPU 事件
jfr.timeline.cpu.running.event.tooltip.text=CPU 事件(运行中)
jfr.timeline.cpu.sleeping.event.tooltip.text=CPU 事件(休眠中)
jfr.timeline.memory.event.tooltip.text=内存分配事件
jfr.timeline.memory.events.display.name=内存分配事件
jfr.ui.column.field=字段
jfr.ui.column.value=值
jfr.ui.tab.events=事件
jfr.ui.tab.properties=属性
jfr.ui.tab.stack.trace=堆栈跟踪
jfr.ui.timeline.content.button.title=堆栈跟踪
jfr.ui.timeline.content.empty.text=要获取堆栈跟踪，请点击 Timeline 事件
jfr.ui.timeline.content.header.full=堆栈跟踪\: {0}，{1}
jfr.ui.timeline.content.no.data.available=没有可用的堆栈跟踪
jfr.ui.timeline.content.view.hide=隐藏堆栈跟踪视图
jfr.ui.timeline.cpu.load.label=CPU {0}
jfr.ui.timeline.filter.events.label=筛选
jfr.ui.timeline.nothing.to.filter.tooltip=没有要筛选的内容
jfr.ui.timeline.stacktrace.copy.stack=复制堆栈
jfr.ui.timeline.stacktrace.kernel={0} (内核)
jfr.ui.timeline.stacktrace.native.method={0} (本地方法)
jfr.ui.timeline.stacktrace.navigation.not.available=导航不可用，正在分析项目…
jfr.ui.timeline.stacktrace.unknown=未知帧
jfr.ui.timeline.used.heap.size=已使用 {0}/{1}
jfr.unexpected.response=来自 ''{0}'' 的意外响应\: ''{1}''。
openj9.not.supported.message=不支持使用 OpenJ9 进行分析。请考虑使用其他 JDK
profiler.attach.group.name=Java
profiler.cant.attach.error=无法将分析器附加到进程 ''{0}''\: {1}
profiler.cant.attach.scheduled.debugger=JVM 是通过定时调试器代理启动的，但分析器代理与该代理不兼容。请在运行配置设置中手动禁用该代理。
profiler.cant.attach.unknown.reason=未知原因
profiler.cant.start.error=无法使用运行配置 ''{0}'' 启动分析器\: {1}
profiler.configurable.name=Java 分析器
profiler.edit.run.configuration=编辑运行配置…
profiler.exception.cant.profile.many.forks=无法启动分析器\: 配置允许多个复刻
profiler.exception.cant.start=无法启动分析器\: 不受支持的运行配置
profiler.exceptions.ask.report=报告此错误
profiler.exceptions.configurations.patch=内部错误\: 无法修补所选配置。
profiler.kotlin.inline.frame.label=内联
profiler.unsupported.snapshot=无法打开 {0}\: 不支持此类型的快照
settings.async.profiler.agent=代理\:
settings.async.profiler.agent.options=代理选项\:
settings.async.profiler.bundled.version=已捆绑(版本\: {0})
settings.async.profiler.collect.native.calls=收集原生调用(GC 线程、JNI 调用等)
settings.async.profiler.readme=异步分析器 README.md
ui.profiler.collapse.library.calls=隐藏库调用
ui.profiler.expand.library.calls=+{0} 个库{0,choice,1\#调用|2\#调用}
ui.profiler.snapshots.folder.is.bad=快照文件夹 {0} 错误\: {1}。转储将被写入临时目录。
ui.profiler.welcome.screen=首页
ui.profiler.welcome.screen.actions.show.filterDevelopmentTools=显示开发工具
ui.profiler.welcome.screen.actions.show.highlightIdeProcesses=高亮显示 IDE 进程
ui.profiler.welcome.screen.charts.cannot.load=无法连接到目标 JVM
ui.profiler.welcome.screen.charts.clear=清除数据
ui.profiler.welcome.screen.charts.dumpThreads=获取线程转储
ui.profiler.welcome.screen.charts.gc=执行垃圾回收
ui.profiler.welcome.screen.charts.lastFiveMinute=显示过去 5 分钟
ui.profiler.welcome.screen.charts.lastMinute=显示过去 60 秒
ui.profiler.welcome.screen.charts.reshow=显示静态 CPU 和内存图表
ui.profiler.welcome.screen.charts.showAll=显示所有数据
ui.profiler.welcome.screen.processes.application=进程
ui.profiler.welcome.screen.processes.attach=附加分析器
ui.profiler.welcome.screen.processes.capture=捕获内存快照
ui.profiler.welcome.screen.processes.capturing=正在捕获内存快照
ui.profiler.welcome.screen.processes.capturing.memory.error=无法捕获进程 ''{0}'' 的内存快照
ui.profiler.welcome.screen.processes.configure=设置
ui.profiler.welcome.screen.processes.cpu=CPU
ui.profiler.welcome.screen.processes.cpuandmemory=CPU 和内存实时图表
ui.profiler.welcome.screen.processes.current=当前
ui.profiler.welcome.screen.processes.custom.attach=附加 {0}
ui.profiler.welcome.screen.processes.edit=编辑配置…
ui.profiler.welcome.screen.processes.get.thread.dump.error=无法获取进程 ''{0}'' 的线程转储
ui.profiler.welcome.screen.processes.loading=正在加载本地 Java 进程…
ui.profiler.welcome.screen.processes.locals=本地
ui.profiler.welcome.screen.processes.notfound=未找到 Java 进程
ui.profiler.welcome.screen.processes.pid=PID
ui.profiler.welcome.screen.snapshots=最近的快照
ui.profiler.welcome.screen.snapshots.folder.noFolder.text=路径不存在
ui.profiler.welcome.screen.snapshots.folder.notDirectory.text=路径不是目录
ui.profiler.welcome.screen.snapshots.folder.write.protected=文件夹没有写入权限
ui.profiler.welcome.screen.snapshots.hint=没有最近的快照。
ui.profiler.welcome.screen.snapshots.hint2=点击表中的进程或
ui.profiler.welcome.screen.snapshots.hint3=打开快照\: jfr 或 hprof 文件
ui.profiler.welcome.screen.snapshots.menu.hide.action=在最近的快照中隐藏
ui.profiler.welcome.screen.snapshots.menu.open.action=打开
ui.profiler.welcome.screen.snapshots.noFolder.comment.text=生成的分析器快照已保存到此文件夹
ui.profiler.welcome.screen.snapshots.noFolder.label.text=快照文件夹\:
ui.profiler.welcome.screen.snapshots.noFolder.title=快照文件夹
ui.profiler.welcome.screen.snapshots.open=打开快照…
ui.profiler.welcome.screen.snapshots.setFolder=更改快照文件夹…
ui.profiler.welcome.screen.threads.tab.text=转储\: {0}
ui.profiler.welcome.screen.tooltips.close=在最近的快照中隐藏
ui.profiler.welcome.screen.tooltips.size=大小\: {0}
ui.profiler.widget.header=性能
ui.profiler.widget.hide=隐藏性能微件
unsupported.profiler.snapshot.name=不支持

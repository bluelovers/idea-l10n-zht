inspection.javafx.color.component.out.of.range.problem=颜色分量必须是介于 0.0 和 1.0 (包含)之间的数值
inspection.javafx.default.tag.could.be.removed=可以移除默认属性标记
inspection.javafx.default.tag.unwrap.tag.fix.family.name=解开标记
inspection.javafx.default.tag.unwrap.tag.fix.name=解开 ''{0}''
inspection.javafx.event.handler.ambiguous.problem=事件处理程序名称不明确: 找到多个匹配的方法
inspection.javafx.event.handler.change.parameter.type=更改事件处理程序方法的形参类型
inspection.javafx.event.handler.create.options.panel=检测具有非 void 返回类型的事件处理程序方法
inspection.javafx.event.handler.incompatible.generic.parameter.problem=事件处理程序实参的泛型形参不兼容: {0} 无法从 {1} 分配
inspection.javafx.event.handler.incompatible.handler.argument=事件处理程序实参不兼容: {0} 无法从 {1} 分配
inspection.javafx.event.handler.return.type.problem=事件处理程序的返回类型应为 void
inspection.javafx.redundant.property.values.problem=特性冗余，因为它包含默认值
inspection.javafx.redundant.property.values.redundant.tag.problem=标记冗余，因为它包含默认值
inspection.javafx.unresolved.fx.id.reference.problem=未解析的 fx:id 引用
inspection.javafx.unused.imports.problem=未使用的 import

javafx.annotator.duplicate.child.added=添加了重复子项
javafx.annotator.page.language.not.specified=未指定页面语言。
javafx.annotator.property.is.read.only=属性 ''{0}'' 为只读
javafx.annotator.should.be.public=应为 public
javafx.annotator.should.be.public.or.fxml.annotated=应为 public 或用 @FXML 注解
javafx.annotator.value.not.found=找不到 {0}

javafx.app.dialog.linux.icon=Linux 图标(&L)
javafx.app.dialog.mac.icon=Mac 图标(&M)
javafx.app.dialog.windows.icon=Windows 图标(&W)

javafx.application.icons.choose.icons=选择应用程序图标
javafx.application.icons.file.should.be.inside.project.content={0} 图标文件应位于项目内容内
javafx.application.icons.icon.file.should.exist={0} 图标文件应存在
javafx.application.icons.select.icon.file.description=选择生成的应用程序的图标文件(*.{0})
javafx.application.icons.select.icon.file.title=选择图标文件

javafx.artifact.properties.editor.application.class=应用程序类(&P):
javafx.artifact.properties.editor.application.icon=应用程序图标
javafx.artifact.properties.editor.application.parameters=应用程序形参(&R):
javafx.artifact.properties.editor.build.output.level=构建输出级别:
javafx.artifact.properties.editor.choose.file.run.in.browser.description=要在浏览器中运行的所生成应用程序的参数。
javafx.artifact.properties.editor.choose.file.run.in.browser.title=选择属性文件
javafx.artifact.properties.editor.choose.file.standalone.description=要独立运行的所生成应用程序的参数。
javafx.artifact.properties.editor.choose.file.standalone.title=选择属性文件
javafx.artifact.properties.editor.choose.html.file.description=在浏览器中运行的应用程序入口点的 HTML 模板
javafx.artifact.properties.editor.choose.html.file.title=选择 HTML 文件
javafx.artifact.properties.editor.convert.css.to.bin.option=将 css 转换为 bin
javafx.artifact.properties.editor.custom.manifest.attributes=自定义清单特性
javafx.artifact.properties.editor.description=描述(&D):
javafx.artifact.properties.editor.edit.attributes.button=编辑特性(&A)
javafx.artifact.properties.editor.edit.certificates.button=编辑证书(&C)
javafx.artifact.properties.editor.edit.custom.manifest.attributes=编辑自定义清单特性
javafx.artifact.properties.editor.edit.icons.button=编辑图标(&N)
javafx.artifact.properties.editor.height=高度(&H):
javafx.artifact.properties.editor.html.parameters=HTML 参数(&L):
javafx.artifact.properties.editor.html.placeholder.id=HTML 占位符 ID(&O):
javafx.artifact.properties.editor.html.template=HTML 模板(&M):
javafx.artifact.properties.editor.native.bundle=原生捆绑包(&I):
javafx.artifact.properties.editor.signing.option=启用签名(&S)
javafx.artifact.properties.editor.title=标题(&T):
javafx.artifact.properties.editor.update.in.background.option=在后台更新(&B)
javafx.artifact.properties.editor.vendor=供应商(&V):
javafx.artifact.properties.editor.version=版本(&E):
javafx.artifact.properties.editor.width=宽度(&W):

javafx.certificates.dialog.alias.should.be.non.empty.error=别名应非空
javafx.certificates.dialog.choose.certificate.title=选择证书
javafx.certificates.dialog.keystore.file.should.exist.error=密钥存储文件应存在
javafx.certificates.dialog.passwords.should.be.set.error=应设置密码
javafx.certificates.dialog.path.to.keystore.file.error=应设置密钥存储文件的路径
javafx.certificates.dialog.select.file.with.generated.keys=选择包含生成的密钥的文件

javafx.collapse.subtag.to.attribute.intention=将标记 ''{0}'' 收起到特性
javafx.collapse.subtag.to.attribute.intention.family.name=将标记收起到特性
javafx.create.new.fxml.file.description=创建新的 FXML 文件
javafx.create.new.fxml.file.title=FXML 文件
javafx.edit.certificates.dialog.alias=别名(&A):
javafx.edit.certificates.dialog.keypass=Keypass(&E):
javafx.edit.certificates.dialog.keystore=Keystore(&Y):
javafx.edit.certificates.dialog.self.signed.radio=自签名(&S)
javafx.edit.certificates.dialog.signed.by.key.radio=通过密钥签名(&K)
javafx.edit.certificates.dialog.signed.storepass=Storepass(&P):
javafx.entry.point.javafx.app=JavaFX 应用程序
javafx.expand.attribute.to.tag.intention=将 ''{0}'' 展开到标记
javafx.expand.attribute.to.tag.intention.family.name=将特性展开到标记
javafx.failed.to.start.scene.builder.error=无法启动 SceneBuilder: {0}
javafx.field.to.property.intention.search.for.usages=正在搜索 ''{0}'' 的用法
javafx.inject.page.language.intention.family.name=指定页面语言
javafx.preloader.artifact.properties.editor.preloader.class=预加载程序类(&P):
javafx.project.sdk.setup.validator.runtime.not.configured.error=未配置 JavaFX 运行时。使用内置 JavaFX 的 JDK，或者将 JavaFX 库添加到类路径
javafx.property.rename.handler.error.message=无法重命名内置属性
javafx.property.rename.handler.error.title=无法重命名
javafx.refactoring.property.element.type.name=属性
javafx.root.tag.descriptor.cannot.resolve.class=无法解析类 {0}

javafx.scene.builder.editor.download.scene.builder.kit=下载 Scene Builder Kit
javafx.scene.builder.editor.download.javafx=下载 JavaFX
javafx.scene.builder.editor.failed.to.download.kit.error=下载 Scene Builder Kit 失败
javafx.scene.builder.editor.failed.to.open.file.error=无法打开 Scene Builder 中的文件。
javafx.scene.builder.editor.scene.builder.edit.operation=JavaFX Scene Builder 编辑操作

javafx.settings.configurable.path.to.scenebuilder=SceneBuilder 的路径(&P):
javafx.settings.configurable.scene.builder.configuration.description=选择 SceneBuilder 可执行文件的路径
javafx.settings.configurable.scene.builder.configuration.title=SceneBuilder 配置

javafx.wrap.id.with.fx.define.intention=使用 fx:define 包装“{0}”
javafx.wrap.with.fx.define.intention.family.name=使用 fx:define 包装
inspection.java.fx.event.handler.display.name=事件处理程序方法签名问题
inspection.java.fx.color.rgb.display.name=颜色分量超出范围
inspection.java.fx.redundant.property.value.display.name=JavaFX 冗余属性值
inspection.java.fx.unused.imports.display.name=JavaFX 未使用的 import
inspection.java.fx.unresolved.fx.id.reference.display.name=未解析的 fx:id 特性引用
inspection.java.fx.default.tag.display.name=不必要的默认标记
action.OpenInSceneBuilder.text=在 SceneBuilder 中打开
javafx.application.title=JavaFx 应用程序
javafx.preloader.title=JavaFx 预加载程序
intention.family.name.convert.to.javafx.property=转换为 JavaFX 属性
command.name.convert.to.javafx.property=将 ''{0}'' 转换为 JavaFX 属性
popup.title.choose.component.with.fx.id=<html>选择具有 fx:id <b>{0}<b> 的组件 </html>
intention.name.change.parameter.type.to=将 ''{0}'' 的形参类型更改为 {1}
conversion.between.unrelated.types.error=不相关类型之间的转换，{0} 转换为 {1}
unable.to.coerce.error=无法将 {0} 强制转换为 {1}
inspection.message.copy.constructor.not.found=找不到 ''{0}'' 的复制构造函数
inspection.message.fx.controller.can.only.be.applied.to.root.element='fx:controller' 只能用于根元素
unable.to.instantiate=无法实例化
spaces.not.allowed.before.property.or.expression=属性或表达式前面不允许使用空格
invalid.value.unable.to.coerce=无效值: 无法强制转换为 {0}
no.controller.specified.for.top.level.element=没有为顶层元素指定控制器
incorrect.expression.syntax=错误的表达式语法
unable.to.coerce=无法强制转换为 {0}
invalid.enumerated.value=无效的枚举值
inspection.message.fx.root.valid.only.as.root.node.fxml.document='<fx:root>' 只能作为 FXML 文档的根节点
label.selected.module.output.would.to.be.included.in.artifact=所选模块输出将被包含在工件中
dialog.title.select.module.for.artifact=选择模块
action.from.module.artifact.text=从模块…
action.from.modules.artifact.text=从模块 ''{0}''
dialog.title.choose.preloader.class=选择预加载程序类
dialog.title.choose.application.class=选择应用程序类
column.name.artifact.manifest.property.name=名称
column.name.artifact.manifest.property.value=值
java.fx.artifacts.tab.name=JavaFX
javafx.preloader.tab.name=JavaFX 预加载程序
scene.builder.editor.tab.name=Scene Builder
constant.not.found=找不到常量 ''{0}''
cannot.class.name.to.field.name=无法将 {0} 设置为字段 ''{1}''
enum.constant.not.found={1} 中没有枚举常量 ''{0}''
group.name.javafx=JavaFX
inspection.java.fx.resource.property.value.display.name=属性文件中的值与特性类型不兼容
java.version.7.or.higher.is.required.to.build.javafx.package=需要 Java 版本 7 或更高版本才能构建 JavaFX 软件包
javafx.migration.description=根据 JEP 253 修正 JavaFX API 类的 import。注意，有一些类不再是 public 类。
javafx.module.builder.description=包含 <b>JavaFX</b> 工具包的桌面应用程序。
library.controlsfx.description=用于补充核心 JavaFX 分发版的优质 UI 控件和其他工具。
library.formsfx.description=帮助开发者轻松创建表单，并在默认情况下创建设计精良、用户友好的表单。
library.validatorfx.description=力求克服其缺点且受 ControlsFX 启发的 JavaFX 验证库。
library.ikonli.description=可以在 Java 应用程序中使用的图标包。
library.bootstrapfx.description=提供与 Twitter Bootstrap 高度相似，同时为 JavaFX 独特的 CSS 风格量身定制的 CSS 样式表。
library.tilesfx.description=包含仪表板磁贴的 JavaFX 库。
javafx.create.new.application.title=JavaFX 应用程序
javafx.create.new.application.description=创建 JavaFX 应用程序类
needs.at.least.jdk.14.containing.the.jpackage.tool=至少需要包含 jpackage 工具的 JDK 14
platform.specific.package=平台特定的软件包
label.description=描述
label.vendor=供应商
label.copyright=版权
label.version=版本
label.main.class=主类
show.verbose.output.when.building.the.platform.specific.package=构建平台特定的软件包时显示详细输出
packaging.artifact.tab.name=打包
library.fxgl.description=JavaFX 游戏开发框架。
javafx.module.additional.libraries=其他库:
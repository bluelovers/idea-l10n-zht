action.create.new.jsp.tag.library.descriptor.tld.file.description=创建新 JSP 标记库描述符(.tld 文件)
action.extract.jsp.tag.text=提取 JSP 标记
action.jsp.tag.library.descriptor.text=JSP 标记库描述符
attribute.should.be.inside.custom.or.standard.action=jsp:attribute 应在标准操作或自定义操作中
attribute.should.have.empty.content={0} 的内容应为空
attribute.should.not.contain.scripting.elements=JSP 特性不应包含脚本元素
border.title.jsp=JSP
cannot.resolve.taglib.uri=无法解析包含 uri {0} 的 taglib
checkbox.add.unambiguous.imports.on.fly=动态添加明确的 import
column.name.attribute=特性
column.name.fix=修复
column.name.namespace=命名空间
column.name.tag=标记
command.name.introduce.jsp.parameter=引入 JSP 参数
configurable.name.jsp=JSP
configurable.name.jspx=JSPX
context.chooser.context.folder=上下文文件夹
context.chooser.panel.title=文件上下文
create.tagfile.attribute.family=创建标记文件特性
create.tagfile.attribute.text=创建标记文件特性 {0}
dialog.message.does.not.exist.do.you.want.to.create.it={0} 不存在。要创建吗?
dialog.message.name.should.not.be.empty=名称不应为空
dialog.message.tag.name.should.not.be.empty=标记名称不应为空
dialog.title.directory.not.exist=目录不存在
dialog.title.error=错误
dialog.title.introduce.tag.parameter=引入标记参数
dialog.title.select.location=选择位置
duplicate.attribute.error.message=特性 {0} 重复
edit.template=编辑模板(&T)…
either.uri.or.tagdir.attribute.should.be.specified=应指定 uri 或 tagdir 特性
el.declare.variable.find.acceptable.class=找到可接受的类
el.declare.variable.intention.family=声明变量作为外部数据
el.declare.variable.via.comment.annotation.intention.name=声明外部变量在注解
el.declare.variable.via.usebean.intention.name=声明外部变量作为<jsp:useBean />
enter.new.attribute.s.name=输入新特性名称(&N):
exception.during.tei.processing.occured.with.error.error.message=TEI 处理期间发生异常: {0}
fragment.attribute.should.not.have.rtexprvalue.attribute.error.message=片段特性不应具有 rtexprvalue 特性(JSP 2.0 规范，第 8.5.2 节，表 JSP8-3)
fragment.attribute.should.not.have.type.attribute.error.message=片段特性不应具有类型特性(JSP 2.0 规范，第 8.5.2 节，表 JSP8-3)
fragment.attribute.value.should.be.specified.with.jsp.attribute=片段特性值应使用 jsp:attribute 指定
inspection.message.absolute.paths.not.recommended.in.jsps=建议不要在 JSP 中使用绝对路径
inspection.message.deferred.expression.syntax.required.here=推迟表达式(#{} 语法)在此处为必填项
inspection.message.dynamic.expression.syntax.required.here=动态表达式(${} 语法)在此处为必填项
inspection.message.no.content.allowed.inside.tags.with.empty.content.type=在使用 'empty' 内容类型的标记内，不允许包含内容
inspection.message.scripting.not.allowed.inside.tags.with.scriptless.content.type=在使用 'scriptless' 内容类型的标记内，不允许使用脚本
inspection.message.unescaped.el.expression=未转义的 EL 表达式
inspection.problem.classes.from.the.default.package.must.not.be.referenced.from.jsp.file.text=不得从 JSP 文件引用默认软件包中的类
inspection.problem.jsp.file.must.not.include.itself=JSP 文件不得包含自身
intention.family.name.remove.scriptlet.s=移除 Scriptlet
intention.name.add.dynamic.prefix=添加动态前缀
intention.name.register.all.tags.from.as.safe=将 {0} 中的所有标记注册为安全
intention.name.register.as.safe.place=将 <{0} {1}=""> 注册为安全地点
intention.name.register.tag.as.safe.place=将 <{0}> 标记注册为安全地点
intention.name.replace.syntax=将 ${} 语法替换为 #{}
intention.name.replace.syntax.with=将 #{} 语法替换为 ${}
intention.name.wrap.in.jstl.escapexml.function=在 JSTL escapeXml() 函数中包装
intention.name.wrap.in.tag=在{0} <{1}> 标记中包装
invalid.reference.to.javabean.type.error.message=对 Java Bean 类型的引用无效
item.text.none.context=<无>
jsf.el.out.of.attribute=JSF EL 在特性外 #loc
jsf.method.call.is.nonstd.extension=方法调用是标准扩展 #loc
jsp.documentation.message.can.have.runtime.value=可以具有运行时值:\\&nbsp;{0}
jsp.documentation.message.custom.attribute.name=自定义特性名称
jsp.documentation.message.custom.function.name=自定义函数名称
jsp.documentation.message.custom.tag.name=自定义标记名
jsp.documentation.message.description=Description:\\&nbsp;{0}
jsp.documentation.message.example.of.use=使用示例:<br><pre>{0}</pre>
jsp.documentation.message.fragment=片段:\\&nbsp;{0}
jsp.documentation.message.required=必选:\\&nbsp;{0}
jsp.documentation.message.type=类型:\\&nbsp;{0}

jsp.import=JSP 导入
jsp.smart.key.insert.pair.greater.on.enter=在 JSP 中按 Enter 时插入对 %>
jsp.taglib.method.reference.error.class.is.not.public=类不为 public
jsp.taglib.method.reference.error.class.is.not.valid=类无效
jsp.taglib.method.reference.error.different.return.type=不同的返回类型
jsp.taglib.method.reference.error.method.should.be.public.or.static=方法应为 public 或 static
jsp.taglib.method.reference.error.no.such.method=没有这样的方法
jsp.taglib.method.reference.error.signature.is.different=签名是不同的
label.choose.jsp.context.text=已包含到
location=位置(&L):
method.does.not.match=方法 ''{0}'' 不匹配 ''{1}''
name=名称(&N):
name.from.attribute.should.be.java.lang.String=通过 name-from-attribute 定义的变量应引用 java.lang.String 类型的特性
name.from.attribute.should.be.required=通过 name-from-attribute 定义的变量应引用所需特性
name.from.attribute.should.not.be.rtexprvalue=通过 name-from-attribute 定义的变量不应引用运行时特性
namespace.alias=taglib
radio.prefer.comma.separated.import.list=首选逗号分隔的导入列表
radio.prefer.one.import.statement.per.page.directive=每个页面指令首选一条 import 语句
replace.with.jsp.comment.intention=替换为 JSP 注释
safe.tags=安全标记:
suggest.jstl.escapexml.as.fix=建议 JSTL escapeXml() 为修复(&S)
tag.should.be.used.in.tag.file.error.message=应在标记文件中使用标记
tag.should.not.be.used.in.tag.file.error.message=不应在标记文件中使用标记
template.node.jsp.files=JSP 文件
title.choose.jsp.file.text=选择 JSP 文件
title.jsp.imports.layout=JSP 导入布局
title.preview=预览
variable.name.from.attribute=通过特性 {0} 值的定义的变量
wrong.tag.data.error.message=TEI 验证错误: {0}

live.template.description.jspa=JSP 标记特性
live.template.description.jspxa=JSPX 标记特性
no.description.provided.for.tag.file=没有为标记文件提供描述
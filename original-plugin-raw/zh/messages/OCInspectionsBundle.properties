configurable.naming.convention.header.guard.style=头文件保护符样式:
configurable.naming.convention.several.rules.hint=如果一种实体类型有多个规则，将使用列表中的最后一个。
inspection.clangd.general=Clangd 错误和警告
inspection.naming.convention.edit.settings.link=编辑代码样式设置
inspection.naming.convention.rename.fix=重命名为 {0}
inspection.naming.convention.rename.header.guard.fix=将头文件保护符重命名为 {0}
inspection.context.sensitive.analysis=上下文相关分析
inspection.global.unused.analysis=全局未使用的分析
inspection.inconsistent.naming=命名不一致
inspection.modern.syntax=可以使用现代语法
inspection.loop.condition.is.not.updated=循环条件未在循环内更新
inspection.arc.issues=ARC 问题
inspection.sending.dealloc='dealloc' 直接发送
inspection.assign.in.condition.with.self=包含 'self' 的条件表达式中的 '='
inspection.usage.of.api.unavailable=使用不可用的 API
inspection.deprecated.api=使用了弃用 API
inspection.assign.in.condition=条件表达式中存在 '='
inspection.kr.unspecified.parameters=通过 K&R 未指定参数语法将参数传递至函数
inspection.hiding.non.virtual.function=隐藏了非虚拟函数
inspection.constant.conditions=恒定条件
inspection.non.localized.string=未本地化的字符串
inspection.simplifiable.statement=可简化语句
inspection.simplify=简化 {0}
inspection.replace.enable_if.with.require=将 enable_if 替换为要求
inspection.simplify.condition=简化“condition == true”
inspection.simplify.ternary=简化“condition1 ? true : condition2”
inspection.not.released.var=版本应在 'dealloc' 或其被调用方中
unused.inspection.run.in.headers=在头文件中运行检查
clang.based.inspection.arc.and.properties=ARC 和 @properties
clang.based.inspection.lexical.or.preprocessor.issue=词法或预处理程序问题
clang.based.inspection.api.notes.issue=API 说明问题
clang.based.inspection.openmp.issue=OpenMP 问题
clang.based.inspection.vtable.issue=VTable ABI 问题
clang.based.inspection.coroutines.issue=协同程序问题
clang.based.inspection.concepts.issue=概念问题
clang.based.inspection.dependency.directive.source.minimization.issue=依赖项指令源最小化问题
inspection.message.modern.syntax.can.be.used=可以使用现代语法
inspection.message.non.localized.string=未本地化的字符串: {0}
inspection.message.not.released.in.dealloc.method={0} 未在 ''dealloc'' 方法中释放
inspection.message.misses.call.to.super.dealloc.at.last.statement={0} 在最后一条语句中错过了对 [super dealloc] 的调用
intention.family.name.add.call.to.super.dealloc=将调用添加到 [super dealloc]
intention.family.name.delete.method=删除方法
inspection.message.never.used={0}{1, choice, 0#已被匹配，从未被访问|1# 从未使用}
inspection.display.name.simplifiable.statement=可简化语句
checkbox.simplify.if.true.while.false=简化“if (true)”、“while (false)”
checkbox.simplify.condition.true=简化“condition == true”
checkbox.simplify.condition1.true.condition2=简化“condition1 ? true : condition2”
checkbox.simplify.if.condition1.return.true.return.condition2=简化“if (condition1) return true; return condition2;”
intention.family.name.simplify=简化 {0}
intention.family.name.simplify.expression=简化表达式
intention.name.simplify=简化 {0}
inspection.name.unconstrained.variable.type=无约束变量类型
no.suggestions.for.properties.of.class=没有关于类 {0} 属性的建议
no.suggestions.for.members=没有关于 {0} 成员的建议

quick.fix.place.parentheses.around=将括号置于
quick.fix.send.release.message.instead.dealloc=发送“release”消息而非“dealloc”
quick.fix.append.nil.argument=追加“nil”参数
quick.fix.remove.extra.declarators=移除额外声明符
quick.fix.remove.statement=移除语句
quick.fix.remove.pure.specifier=移除纯指定符
quick.fix.change.pure.specifier=将纯指定符更改为 '= 0'
quick.fix.remove.from.base.classes.list=从基类列表中移除 ''{0}''
quick.fix.remove.redundant.cast=移除冗余转换
quick.fix.remove.initializer=移除初始值设定项
quick.fix.insert.keyword=插入 ''{0}''
quick.fix.remove.property=移除属性
quick.fix.remove.declaration=移除声明
inspection.message.unterminated.string.literal=字符串文字未终止
inspection.message.invalid.suffix.on.raw.string=原始字符串的后缀无效
quick.fix.remove.attribute=移除特性
quick.fix.remove.useless.import=移除无用的导入
quick.fix.remove.useless.include=移除无用的 include
quick.fix.optimize.imports=优化 import
quick.fix.optimize.includes=优化 include
quick.fix.change.format.specifier=更改格式说明符
quick.fix.remove.arguments=移除实参
quick.fix.copy.superclass.from.interface=从接口复制超类
quick.fix.copy.superclass.to.interface=将超类复制到接口
quick.fix.remove.superclass=移除超类
quick.fix.remove.user.defined.getter.method=移除用户定义的 getter 方法
quick.fix.remove.user.defined.setter.method=移除用户定义的 setter 方法
quick.fix.remove.superclass.reference=移除超类引用
quick.fix.remove.instance.variable.list=移除实例变量列表
quick.fix.remove.protocols.list=移除协议列表
quick.fix.remove.method.body=移除方法体
quick.fix.remove.synthesize.dynamic.statement=移除 '@synthesize'/'@dynamic' 语句
quick.fix.remove.synthesize.statement=移除 '@synthesize' 语句
quick.fix.remove.accessor=移除访问器
inspection.message.error.after.macro.substitution=宏替换后出错: 
inspection.message.was.not.declared.in={0} 未在 {1} 中声明
inspection.message.hides.non.virtual.function={0} 从 {1} 中隐藏了一个非虚拟函数
intention.name.make.function.const=设为 {0}{1, choice, 0# const|1# non-const}
quick.fix.make_default=将 {0} 设为默认值
quick.fix.add_return_statement=添加 return 语句
intentions.add.constructor.initializer.for.field=为字段添加构造函数初始值设定项
intentions.add.initializer=添加初始值设定项
intentions.add.parameters.to.constructor=将 {0} 作为参数添加到构造函数
intentions.add.parameter.initWith=作为参数添加到 'initWith…'
intentions.check.raw.string=检查原始字符串
intentions.add.super.constructor.call=添加缺少的基构造函数调用
intentions.add.super.protocol.by.class=按类采用协议
intentions.add.super.protocol.by.private.category=按私有类别采用协议
intentions.add.modifier=添加 ''{0}''
intentions.change.arc.attribute=更改 ARC 特性
intentions.change.function.signature=更改函数签名
intentions.change.type.capitalized=更改类型
intentions.change.type=更改类型
intentions.change.visibility=更改可见性
intentions.convert.id.to.instance=将 'id' 返回类型替换为 'instancetype'
intentions.replace.if.else.with.ternary=将 'if else' 替换为 '?:'
intentions.replace.ternary.with.if.else=将 '?:' 替换为 'if else'
intentions.convert.objc.literal=切换至 Objective-C 文字
intentions.convert.to.instance.variable=转换为实例变量
intentions.convert.to.property=转换为属性
intentions.convert.type=转换类型
intentions.create.matching.constructor=创建与基类匹配的构造函数
intentions.create.matching.constructor.in=在 {0} 中创建默认构造函数
intentions.create.new.matching.constructor=在 {0} 个匹配基类中创建新的构造函数
intentions.create.new.constructor=创建新的构造函数 ''{0}()''
intentions.predeclare.function=预声明 {0}
intentions.create.interface=为 {0} 创建接口
intentions.create.missing.default.switch.case=创建缺少的 default case
intentions.create.missing.switch.cases=创建缺少的 switch case
intentions.declare.method.in.interface=在接口中声明方法
intentions.declare.method.in.private.category=在私有类别中声明方法
intentions.declare.method.in=在 {0} 中声明方法
intentions.declare.property.as.readwrite=在私有类别中将属性声明为 'readwrite'
intentions.replace.and.with.or=将 '\\&\\&' 替换为 '||'
intentions.replace.or.with.and=将 '||' 替换为 '\\&\\&'
intentions.deMorgan.law=德摩根定律
intentions.declare.member.in=声明位置: 
intentions.remove.private.category.message=移除空的私有类别?
intentions.remove.private.category.title=移除私有类别
intentions.extract.category=提取此类的类别
intentions.extract.if=提取 'if'
intentions.extract.if.with.text=提取 ''if ({0})''
intentions.extract.private.category=提取此类的私有类别
intentions.extract.protocol=提取此类的协议
intentions.extract.super.class=提取超类
intentions.extract.super.protocol=提取超级协议
intentions.flip.operator=翻转 {0}
intentions.flip.operator.to=将 {0} 翻转为 {1}
intentions.flip.binary.operation=翻转二元运算
intentions.generate.property=生成属性
intentions.implement.required.methods=实现接口 ''{0}'' 的必需方法
intentions.create.implementation=创建 {0} 的实现
intentions.implement.method=实现 {0}
intentions.implement.accessor.methods=实现访问器方法
intentions.implement.accessor.methods.for=为 {0} 实现访问器方法
intentions.cast.expression=转换表达式
intentions.introduce.typedef=引入 typedef
intentions.introduce.typedef.for.type=为类型 {0} 引入 typedef
intentions.invert.if.condition=反转 'if' 条件
intentions.merge.if.else=合并 'if else'
intentions.merge.nested.ifs=合并嵌套的 'if'
intentions.add.braces.statement=将大括号添加到 ''{0}'' 语句
intentions.remove.braces.statement=从 ''{0}'' 语句中移除大括号
intentions.migrate.to.arc=迁移到 ARC
intentions.move.instance.variables=将实例变量移至实现
intentions.move.to.interface=移至接口
intentions.move.to.private.category=移至私有类别
intentions.import.predeclare.symbol=导入/预声明符号
intentions.release.variables=释放变量
intentions.remove.suppression=移除禁止
intentions.remove.subj=移除 ''{0}''
intentions.remove.unnecessary.parentheses=移除不必要的圆括号
intentions.rename.reference=重命名引用
intentions.rename.symbol=重命名符号
intentions.replace.type.with.auto=将类型替换为 'auto'
intentions.reuse.declaration=重用声明
intentions.change.superclass=更改超类
intentions.split.declaration=拆分为声明和赋值
intentions.split.function=将函数分为声明和定义
intentions.split.into.separate.declarations=拆分为单独的声明
intentions.suppress.for=对 {0} 禁止
intentions.suppress.option.for=禁止 {1} 的“{0}”
intentions.suppress.for.statement=对语句禁止
intentions.suppress.for.method=对方法/函数禁止
intentions.suppress.for.file=对文件禁止
intentions.suppress.all.for.file=禁止对文件的所有 {0} 诊断
intentions.surround.with.if.responds=用“if ([ respondsToSelector: ])”环绕
intentions.switch.property.dot.method=切换 '.' 和方法表示法
intentions.switch.to.getter.notation=切换至 getter 方法表示法
intentions.switch.to.setter.notation=切换至 setter 方法表示法
intentions.switch.to.dot.notation=切换至 '.' 表示法
intentions.synthesize.property=合成属性
intentions.wrap.with.stringFormat=使用 'stringWithFormat' 包装
intentions.insert.cast.use.modern=使用 C++ 转换运算符
intentions.split.function.progress.text=正在确定定义位置…
intentions.change.function.const.action=更改 const 限定符
intentions.change.function.volatile.action=更改 volatile 限定符
intentions.change.gcc.attribute.action=更改特性 ''{0}''
intentions.change.method.signature.add.parameters=添加形参
intentions.change.method.staticness.action=将方法设为实例/类
intentions.change.property.attribute.action=更改属性特性
intention.name.make.function.volatile=设为 {0}{1, choice, 0# volatile|1# non-volatile}
intention.name.change.type=将 {1} 的 {0, choice, 0#返回 |1#}类型更改为 ''{2}''{3}
intention.name.initialize=初始化 {0}
intention.name.remove.type.modifier=将 {0} 设为非 {1}
intention.name.add.constructor.initializer=为 {0} 添加构造函数初始值设定项
intention.name.change.superclass=将 {0} 的超类从 ''{1}'' 更改为 ''{2}''
intention.name.add.last.parameter=将最后一个 ''{0}'' 参数添加到 {1}
intention.name.remove.last.parameter=从 {1} 移除最后一个 ''{0}'' 参数
intention.name.change.signature=将 {0} 的签名更改为 ''{1}''
intention.dialog.message.existing.default.values.removed={0} 形参的现有默认值将被移除。是否继续?
intention.family.name.remove.declaration=移除 {1, choice, 0#{0}|1#的声明}
intention.name.safe.delete=安全删除 {0}
intention.family.name.safe.delete=安全删除
intention.name.remove=移除 {0}
intention.family.name.remove=移除 {0}
intention.name.leave.initializer={0}并保留初始值设定项
intention.family.name.leave.initializer={0}并保留初始值设定项
intention.name.add.type.modifier=将 {0} 设为 {1}
intention.name.reuse.previous.declaration=重用 {0} 的上一个声明
intention.name.rename=重命名 {0}
intention.name.rename.reference=重命名引用
intention.name.predeclare.protocol.class=预声明{0, choice, 0#协议 ''|1#类 ''|2#结构 ''}{1}''
intention.name.change.visibility=将 {0} 设为 {1}
intention.name.cast.expression.to=将表达式转换为 ''{0}''
intention.family.name.extract.assignment=提取赋值
intention.name.class=类
intention.name.static=static
intention.name.cpp.class=C++ 类
intention.name.create.new.category=使用 {1} 在 {0} 上新建类别
intention.name.create.new=新建 {0}
intention.name.add.suffix=添加后缀
intention.name.add.call.to.base.constructor=添加 ''{0}'' 基构造函数的调用
intention.name.make=将 {0} 设为 {1}
intention.name.choice.enable.disable=为 {2} {0, choice, 0#启用 ''|1#禁用 ''}{1}''
intention.name.add.parameters=将参数添加到 {0}
intention.name.make.class.method.instance.method=设为 ''{0}{1, choice, 0#'' 类方法|1#'' 实例方法}
intention.dialog.message.change.type.as.well=也要更改 {0} 的类型吗?
intention.family.name.convert.literal.type=转换文字类型: 添加 '@'
intention.name.call=调用 {0}
intention.name.import.which={0, choice, 0#哪一个|1#符号} ''{1}''
intention.name.import=导入 {0}
intention.name.import.from=从 {0}
intention.import.popup.title=要导入的符号
intention.import.command.name=导入 {0}
intention.name.make.function.virtual=设为 {0}::{1}{2, choice, 0# 纯虚拟|1# 虚拟}
intention.name.move.declaration=移动 {0}{1} 的声明
intention.family.name.remove.extra.initializers=移除额外初始值设定项
intention.family.name.remove.initializer=移除初始值设定项
intention.family.name.send.message=发送 ''{0}'' 消息
intention.family.name.add.return.statement=添加 return 语句
intention.family.name.simplify.condition=将条件简化为 ''{0}''
intention.name.change.format.specifier=将格式说明符更改为 ''{0}''
intention.family.name.remove.statement=移除语句
intention.family.name.remove.directive=移除指令
intention.family.name.simplify.choice=简化 {1, choice, 0#表达式|1#{0}}
intention.family.name.change.type.to.auto=将类型 ''{0}'' 更改为 ''auto''
intention.family.name.change.to.nil=更改为 'nil'
intention.name.use.constant=使用常量 ''{0}''
intention.family.name.use.enum.constant=使用枚举常量
intention.name.add=添加“{0}”
intention.family.name.add.bridge.cast=添加桥式转换
intention.family.name.make.default=将 {0} 设为默认值
inspection.message.condition.always.true=条件始终为 true
inspection.message.condition.always.false=条件始终为 false
inspection.message.condition.always.true.when.reached=条件满足后始终为 true
inspection.message.condition.always.false.when.reached=条件满足后始终为 false
inspection.message.reference.may.be.choice.null=指针可能为 {0, choice, 0#nil|1#null}
inspection.message.infinite.recursion=无限递归
inspection.message.value.never.used=从未使用值
inspection.message.file.too.complex.to.perform.context.sensitive.data.flow.analysis=此文件过于复杂，无法执行上下文相关的数据流分析
inspection.message.file.too.complex.to.perform.data.flow.analysis=此文件过于复杂，无法执行数据流分析
inspection.message.unreachable.code=不可到达的代码
inspection.message.endless.loop=无尽循环
inspection.group.name.general=常规
progress.text.evaluating.unused.symbols=正在评估未使用的符号
intention.name.delete=删除 {0}
intention.name.choice.superclass={1, choice, 0#{0} |1#}{2} 的超类 
intention.name.set.superclass=将 ''{0}'' 设为{1}
inspection.message.if.statement.has.identical.branches='if' 语句的分支相同
inspection.message.statement.can.be.simplified=此语句可以简化
inspection.message.expression.can.be.simplified.to=此表达式可以简化为 ''{0}''
inspection.option.unused.variable.initializers=警告未使用的变量初始值设定项
intention.family.name.inline.parameter=内联形参
intention.name.inline=内联 {0}
inspection.message.not.updated.in.loop=循环条件中使用的 {0} 未在循环中更新
inspection.message.address.local.variable.may.escape.function=此局部变量的地址可以转义该函数
inspection.message.may.point.to.out.of.scope.memory={0} 可能指向超出范围的内存
inspection.message.may.point.to.deallocated.memory={0} 可能指向已取消分配的内存
inspection.message.is.never.used={0} 从未使用
inspection.message.only.assigned.but.never.accessed={0}只是被分配，从未被访问
inspection.message.calls.unreachable={0} 的所有调用都不可到达

inspection.not.implements.protocol=未实现的协议
inspection.not.in.hierarchy.message=不位于层次结构消息中
inspection.hides.class.scope=隐藏的类范围
inspection.method.is.later.in.the.scope=方法声明在范围中位于后半部分
inspection.accessors.were.overridden=被重写的访问器
intentions.group=C 和 C++
intentions.group.definition=C 和 C++/定义
intentions.group.declarations=C 和 C++/声明
intentions.group.operators=C 和 C++/运算符
intentions.group.control.flow=C 和 C++/控制流
intentions.group.objc=Objective-C
inspection.message.may.point.to.invalidated.memory={0} 可能指向无效内存
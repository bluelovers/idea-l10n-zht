checkbox.simplify.condition.true=简化“condition \=\= true”
checkbox.simplify.condition1.true.condition2=简化“condition1 ? true \: condition2”
checkbox.simplify.if.condition1.return.true.return.condition2=简化“if (condition1) return true; return condition2;”
checkbox.simplify.if.true.while.false=简化“if (true)”、“while (false)”
clang.based.inspection.api.notes.issue=API 说明问题
clang.based.inspection.arc.and.properties=ARC 和 @properties
clang.based.inspection.concepts.issue=概念问题
clang.based.inspection.coroutines.issue=协程问题
clang.based.inspection.dependency.directive.source.minimization.issue=依赖项指令源最小化问题
clang.based.inspection.lexical.or.preprocessor.issue=词法或预处理程序问题
clang.based.inspection.openmp.issue=OpenMP 问题
clang.based.inspection.vtable.issue=VTable ABI 问题
configurable.naming.convention.header.guard.style=头 guard 样式\:
configurable.naming.convention.several.rules.hint=如果一种实体类型有多个规则，将使用列表中的最后一个。
dfa.batch.action.subject=分析
dfa.batch.action.title=分析全局数据流
dfa.message.preparing=正在准备 {0}…
inspection.accessors.were.overridden=被重写的访问器
inspection.arc.issues=ARC 问题
inspection.array.index.out.of.bounds.display.name=数组索引超出范围
inspection.assign.in.condition=条件表达式中存在 '\='
inspection.assign.in.condition.with.self=包含 'self' 的条件表达式中的 '\='
inspection.clangd.general=Clangd 错误和警告
inspection.constant.conditions=恒定条件
inspection.constant.function.result.display.name=常量函数结果
inspection.constant.parameter.display.name=常量形参
inspection.context.sensitive.analysis=上下文相关分析
inspection.dangling.pointer.display.name=悬空指针
inspection.deprecated.api=使用了弃用 API
inspection.dfa.group.display.name=数据流分析
inspection.display.name.simplifiable.statement=可简化语句
inspection.endless.loop.display.name=无尽循环
inspection.functions.group.display.name=函数
inspection.global.unused.analysis=全局未使用的分析
inspection.group.name.general=常规
inspection.hides.class.scope=隐藏的类作用域
inspection.hiding.non.virtual.function=隐藏了非虚拟函数
inspection.inconsistent.naming=命名不一致
inspection.infinite.recursion.display.name=无限递归
inspection.kr.unspecified.parameters=通过 K&R 未指定形参语法将实参传递至函数
inspection.local.value.escapes.scope.display.name=局部值转义作用域
inspection.loop.condition.is.not.updated=循环条件未在循环内更新
inspection.memory.leak.display.name=内存泄漏
inspection.message.address.local.object.may.escape.function=该局部临时对象的地址可以转义该函数
inspection.message.address.local.variable.may.escape.function=该{0}的地址可以转义该函数
inspection.message.allocated.memory.leaked=分配的内存已泄漏
inspection.message.calls.unreachable={0} 的所有调用都不可到达
inspection.message.condition.always.false=条件始终为 false
inspection.message.condition.always.false.when.reached=条件满足后始终为 false
inspection.message.condition.always.true=条件始终为 true
inspection.message.condition.always.true.when.reached=条件满足后始终为 true
inspection.message.endless.loop=无尽循环
inspection.message.error.after.macro.substitution=宏替换后出错\: 
inspection.message.expression.can.be.simplified.to=此表达式可以简化为 ''{0}''
inspection.message.file.too.complex.to.perform.data.flow.analysis=此文件过于复杂，无法执行数据流分析
inspection.message.hides.non.virtual.function={0} 从 {1} 中隐藏了一个非虚拟函数
inspection.message.if.statement.has.identical.branches='if' 语句的分支相同
inspection.message.infinite.recursion=无限递归
inspection.message.invalid.suffix.on.raw.string=原始字符串的后缀无效
inspection.message.is.never.used={0} 从未使用
inspection.message.may.point.to.deallocated.memory={0} 可能指向已取消分配的内存
inspection.message.may.point.to.invalidated.memory={0} 可能指向失效内存
inspection.message.may.point.to.out.of.scope.memory={0} 可能指向超出作用域的内存
inspection.message.memory.leak=函数 ''{0}'' 中分配的内存泄漏
inspection.message.modern.syntax.can.be.used=可以使用现代语法
inspection.message.never.used={0}{1, choice, 0\#已被匹配，从未被访问|1\# 从未使用}
inspection.message.non.localized.string=未本地化的字符串\: {0}
inspection.message.not.initialized.field.usage=未初始化的{0} 的用法
inspection.message.not.released.in.dealloc.method={0} 未在 ''dealloc'' 方法中释放
inspection.message.not.updated.in.loop=循环条件中使用的 {0} 未在循环中更新
inspection.message.only.assigned.but.never.accessed={0}只是被分配，从未被访问
inspection.message.reference.may.be.choice.null=指针可能为 null
inspection.message.statement.can.be.simplified=此语句可以简化
inspection.message.unreachable.code=不可到达的代码
inspection.message.unterminated.string.literal=未终止的字符串字面量
inspection.message.value.never.used=从未使用值
inspection.message.was.not.declared.in={0} 未在 {1} 中声明
inspection.method.is.later.in.the.scope=方法声明在作用域中位于后半部分
inspection.missing.return.display.name=缺少 return
inspection.modern.syntax=可以使用现代语法
inspection.name.unconstrained.variable.type=无约束变量类型
inspection.naming.convention.edit.settings.link=编辑代码样式设置
inspection.naming.convention.rename.fix=重命名为 {0}
inspection.naming.convention.rename.header.guard.fix=将头 guard 重命名为 {0}
inspection.non.localized.string=未本地化的字符串
inspection.not.implemented.functions.display.name=未实现的函数
inspection.not.implements.protocol=未实现的协议
inspection.not.in.hierarchy.message=不位于层次结构消息中
inspection.not.initialized.field.display.name=未初始化的字段
inspection.not.initialized.variable.display.name=未初始化的变量
inspection.not.released.var=版本应在 'dealloc' 或其被调用方中
inspection.null.dereference.display.name=Null 解引用
inspection.replace.enable_if.with.require=将 enable_if 替换为要求
inspection.sending.dealloc='dealloc' 直接发送
inspection.simplifiable.statement=可简化语句
inspection.simplify=简化 {0}
inspection.simplify.condition=简化“condition \=\= true”
inspection.simplify.ternary=简化“condition1 ? true \: condition2”
inspection.unreachable.calls.display.name=无法访问的函数调用
inspection.unreachable.code.display.name=不可到达的代码
inspection.unused.class.display.name=未使用的类
inspection.unused.concept.display.name=未使用的概念
inspection.unused.directive.display.name=未使用的 include 指令
inspection.unused.expression.result.display.name=未使用的表达式结果
inspection.unused.global.declaration.display.name=未使用的全局声明
inspection.unused.import.statement.display.name=未使用的 import 语句
inspection.unused.include.directive.completely.not.directly=检测未直接使用
inspection.unused.include.directive.completely.not.required=不需要检测
inspection.unused.include.directive.completely.unused=检测完全未使用
inspection.unused.instance.variable.display.name=未使用的实例变量
inspection.unused.local.variable.display.name=未使用的局部变量
inspection.unused.localization.display.name=未使用的本地化
inspection.unused.macro.display.name=未使用的宏
inspection.unused.method.display.name=未使用的方法
inspection.unused.parameter.display.name=未使用的形参
inspection.unused.property.display.name=未使用的属性
inspection.unused.struct.display.name=未使用的结构体
inspection.unused.template.parameter.display.name=未使用的模板形参
inspection.unused.type.alias.display.name=未使用的类型别名
inspection.unused.value.display.name=未使用的值
inspection.usage.of.api.unavailable=使用不可用的 API
inspections.memory.leak.allocating.functions=正在分配函数
inspections.memory.leak.deallocating.functions=正在释放函数
intention.dialog.message.change.type.as.well=是否还要更改 {0} 的类型?
intention.dialog.message.existing.default.values.removed={0} 形参的现有默认值将被移除。是否继续?
intention.family.name.add.bridge.cast=添加桥式转换
intention.family.name.add.call.to.super.dealloc=将调用添加到 [super dealloc]
intention.family.name.add.return.statement=添加 return 语句
intention.family.name.change.to.nil=更改为 'nil'
intention.family.name.change.type.to.auto=将类型 ''{0}'' 更改为 ''auto''
intention.family.name.convert.literal.type=转换字面量类型\: 添加 '@'
intention.family.name.delete.method=删除方法
intention.family.name.extract.assignment=提取赋值
intention.family.name.inline.parameter=内联形参
intention.family.name.leave.initializer={0}并保留初始值设定项
intention.family.name.make.default=将 {0} 设为默认值
intention.family.name.remove=移除 {0}
intention.family.name.remove.declaration=移除{1, choice, 0\#{0}|1\#声明\:|2\#名称\:}
intention.family.name.remove.directive=移除指令
intention.family.name.remove.extra.initializers=移除额外初始值设定项
intention.family.name.remove.initializer=移除初始值设定项
intention.family.name.remove.statement=移除语句
intention.family.name.safe.delete=安全删除
intention.family.name.send.message=发送 ''{0}'' 消息
intention.family.name.simplify=简化 {0}
intention.family.name.simplify.choice=简化 {1, choice, 0\#表达式|1\#{0}}
intention.family.name.simplify.condition=将条件简化为 ''{0}''
intention.family.name.simplify.expression=简化表达式
intention.family.name.use.enum.constant=使用枚举常量
intention.import.command.name=导入 {0}
intention.import.popup.title=要导入的符号
intention.name.add=添加“{0}”
intention.name.add.call.to.base.constructor=添加 ''{0}'' 基构造函数的调用
intention.name.add.constructor.initializer=为 {0} 添加构造函数初始值设定项
intention.name.add.last.parameter=将最后一个 ''{0}'' 形参添加到 {1}
intention.name.add.parameters=将形参添加到 {0}
intention.name.add.suffix=添加后缀
intention.name.add.type.modifier=将 {0} 设为 {1}
intention.name.call=调用 {0}
intention.name.cast.expression.to=将表达式转换为 ''{0}''
intention.name.change.format.specifier=将格式说明符更改为 ''{0}''
intention.name.change.signature=将 {0} 的签名更改为 ''{1}''
intention.name.change.superclass=将 {0} 的超类从 ''{1}'' 更改为 ''{2}''
intention.name.change.type=将 {1} 的 {0, choice, 0\#返回 |1\#}类型更改为 ''{2}''{3}
intention.name.change.visibility=将 {0} 设为 {1}
intention.name.choice.enable.disable=为 {2} {0, choice, 0\#启用 ''|1\#禁用 ''}{1}''
intention.name.choice.superclass={1, choice, 0\#{0} |1\#}{2} 的超类 
intention.name.class=类
intention.name.cpp.class=C++ 类
intention.name.create.new=新建 {0}
intention.name.create.new.category=使用 {1} 在 {0} 上新建类别
intention.name.delete=删除 {0}
intention.name.import=导入 {0}
intention.name.import.from=从 {0}
intention.name.import.which={0, choice, 0\#哪一个|1\#符号} ''{1}''
intention.name.initialize=初始化 {0}
intention.name.inline=内联{0}
intention.name.leave.initializer={0}并保留初始值设定项
intention.name.make=将{0}设为 {1}
intention.name.make.class.method.instance.method=设为 ''{0}{1, choice, 0\#'' 类方法|1\#'' 实例方法}
intention.name.make.function.const=将{0}设为{1, choice, 0\#常量|1\#非常量}
intention.name.make.function.virtual=设为 {0}\:\:{1}{2, choice, 0\# 纯虚拟|1\# 虚拟}
intention.name.make.function.volatile=将{0}设为{1, choice, 0\#易失|1\#非易失}
intention.name.move.declaration=移动 {0}{1} 的声明
intention.name.predeclare.protocol.class=预声明{0, choice, 0\#协议 ''|1\#类 ''|2\#结构体 ''}{1}''
intention.name.remove=移除 {0}
intention.name.remove.last.parameter=从 {1} 移除最后一个 ''{0}'' 形参
intention.name.remove.type.modifier=将 {0} 设为非 {1}
intention.name.rename=重命名 {0}
intention.name.rename.reference=重命名引用
intention.name.reuse.previous.declaration=重用 {0} 的上一个声明
intention.name.safe.delete=安全删除 {0}
intention.name.set.superclass=将 ''{0}'' 设为{1}
intention.name.simplify=简化 {0}
intention.name.static=static
intention.name.use.constant=使用常量 ''{0}''
intention.suffix.called.from=从函数 ''{0}'' 调用时
intention.suffix.called.from.global.scope=从全局作用域调用时
intentions.add.braces.statement=将大括号添加到 ''{0}'' 语句
intentions.add.braces.statement.family=将大括号添加到语句
intentions.add.constructor.initializer.for.field=为字段添加构造函数初始值设定项
intentions.add.initializer=添加初始值设定项
intentions.add.modifier=添加 ''{0}''
intentions.add.parameter.initWith=作为形参添加到 'initWith…'
intentions.add.parameters.to.constructor=将 ''{0}'' 作为形参添加到构造函数
intentions.add.parameters.to.constructor.family=将字段作为形参添加到构造函数
intentions.add.super.constructor.call=添加缺少的基构造函数调用
intentions.add.super.protocol.by.class=按类采用协议
intentions.add.super.protocol.by.private.category=按私有类别采用协议
intentions.cast.expression=转换表达式
intentions.change.function.const.action=更改 const 限定符
intentions.change.function.signature=更改函数签名
intentions.change.function.volatile.action=更改 volatile 限定符
intentions.change.gcc.attribute.action=更改特性 ''{0}''
intentions.change.method.signature.add.parameters=添加形参
intentions.change.property.attribute.action=更改属性特性
intentions.change.superclass=更改超类
intentions.change.type=更改类型
intentions.change.type.capitalized=更改类型
intentions.change.visibility=更改可见性
intentions.check.raw.string=检查原始字符串
intentions.convert.id.to.instance=将 'id' 返回值类型替换为 'instancetype'
intentions.convert.objc.literal=切换至 Objective-C 字面量
intentions.convert.to.instance.variable=转换为实例变量
intentions.convert.to.property=转换为属性
intentions.convert.type=转换类型
intentions.create.implementation=创建 {0} 的实现
intentions.create.interface=为 {0} 创建接口
intentions.create.matching.constructor=创建与基类匹配的构造函数
intentions.create.matching.constructor.in=在 {0} 中创建默认构造函数
intentions.create.missing.default.switch.case=创建缺少的 default case
intentions.create.missing.switch.cases=创建缺少的 switch case
intentions.create.new.constructor=创建新的构造函数 ''{0}()''
intentions.create.new.matching.constructor=在 {0} 个匹配基类中创建新的构造函数
intentions.deMorgan.law=德摩根定律
intentions.declare.member.in=声明位置\: 
intentions.declare.method.in=在 {0} 中声明方法
intentions.declare.method.in.interface=在接口中声明方法
intentions.declare.method.in.private.category=在私有类别中声明方法
intentions.declare.property.as.readwrite=在私有类别中将属性声明为 'readwrite'
intentions.extract.category=提取此类的类别
intentions.extract.if=提取 'if'
intentions.extract.if.with.text=提取 ''if ({0})''
intentions.extract.private.category=提取此类的私有类别
intentions.extract.protocol=提取此类的协议
intentions.extract.super.class=提取超类
intentions.extract.super.protocol=提取超级协议
intentions.flip.binary.operation=翻转二元运算
intentions.flip.operator=翻转 {0}
intentions.flip.operator.to=将 {0} 翻转为 {1}
intentions.generate.property=生成属性
intentions.group=C 和 C++
intentions.group.control.flow=C 和 C++/控制流
intentions.group.declarations=C 和 C++/声明
intentions.group.definition=C 和 C++/定义
intentions.group.objc=Objective-C
intentions.group.operators=C 和 C++/运算符
intentions.implement.accessor.methods=实现访问器方法
intentions.implement.accessor.methods.for=为 {0} 实现访问器方法
intentions.implement.method=实现 {0}
intentions.implement.required.methods=实现接口 ''{0}'' 的必需方法
intentions.import.predeclare.symbol=导入/预声明符号
intentions.insert.cast.use.modern=使用 C++ 转换运算符
intentions.introduce.typedef=引入 typedef
intentions.introduce.typedef.for.type=为类型 {0} 引入 typedef
intentions.invert.if.condition=反转 'if' 条件
intentions.merge.if.else=合并 'if else'
intentions.merge.nested.ifs=合并嵌套的 'if'
intentions.move.instance.variables=将实例变量移至实现
intentions.move.to.interface=移至接口
intentions.move.to.private.category=移至私有类别
intentions.predeclare.function=预声明 {0}
intentions.release.variables=释放变量
intentions.remove.braces.statement=从 ''{0}'' 语句中移除大括号
intentions.remove.braces.statement.family=从语句中移除大括号
intentions.remove.private.category.message=移除空的私有类别?
intentions.remove.private.category.title=移除私有类别
intentions.remove.subj=移除 ''{0}''
intentions.remove.suppression=移除禁止
intentions.remove.unnecessary.parentheses=移除不必要的圆括号
intentions.rename.reference=重命名引用
intentions.rename.symbol=重命名符号
intentions.replace.and.with.or=将 '\\&\\&' 替换为 '||'
intentions.replace.if.else.with.ternary=将 'if else' 替换为 '?\:'
intentions.replace.or.with.and=将 '||' 替换为 '\\&\\&'
intentions.replace.ternary.with.if.else=将 '?\:' 替换为 'if else'
intentions.replace.type.with.auto=将类型替换为 'auto'
intentions.reuse.declaration=重用声明
intentions.split.declaration=拆分为声明和赋值
intentions.split.function=将函数分为声明和定义
intentions.split.function.progress.text=正在确定定义位置…
intentions.split.into.separate.declarations=拆分为单独的声明
intentions.suppress.all.for.file=禁止对文件的所有 {0} 诊断
intentions.suppress.for=对 {0} 禁止
intentions.suppress.for.file=对文件禁止
intentions.suppress.for.method=对方法/函数禁止
intentions.suppress.for.statement=对语句禁止
intentions.suppress.option.for=禁止 {1} 的“{0}”
intentions.surround.with.if.responds=使用 "if ([ respondsToSelector\: ])" 包装
intentions.switch.property.dot.method=切换 '.' 和方法表示法
intentions.switch.to.dot.notation=切换至 '.' 表示法
intentions.switch.to.getter.notation=切换至 getter 方法表示法
intentions.switch.to.setter.notation=切换至 setter 方法表示法
intentions.synthesize.property=合成属性
intentions.wrap.with.stringFormat=使用 'stringWithFormat' 包装
no.suggestions.for.members=没有关于 {0} 成员的建议
no.suggestions.for.properties.of.class=没有关于类 {0} 属性的建议
progress.text.evaluating.unused.symbols=正在对未使用的符号求值
quick.fix.add_return_statement=添加 return 语句
quick.fix.append.nil.argument=追加“nil”实参
quick.fix.change.format.specifier=更改格式说明符
quick.fix.change.pure.specifier=将纯指定符更改为 '\= 0'
quick.fix.copy.superclass.from.interface=从接口复制超类
quick.fix.copy.superclass.to.interface=将超类复制到接口
quick.fix.insert.keyword=插入 ''{0}''
quick.fix.make_default=将 {0} 设为默认值
quick.fix.optimize.imports=优化 import
quick.fix.optimize.includes=优化 include
quick.fix.place.parentheses.around=将括号置于
quick.fix.remove.accessor=移除访问器
quick.fix.remove.arguments=移除实参
quick.fix.remove.attribute=移除特性
quick.fix.remove.declaration=移除声明
quick.fix.remove.extra.declarators=移除额外声明符
quick.fix.remove.from.base.classes.list=从基类列表中移除 ''{0}''
quick.fix.remove.initializer=移除初始值设定项
quick.fix.remove.instance.variable.list=移除实例变量列表
quick.fix.remove.method.body=移除方法体
quick.fix.remove.property=移除属性
quick.fix.remove.protocols.list=移除协议列表
quick.fix.remove.pure.specifier=移除纯指定符
quick.fix.remove.redundant.cast=移除冗余转换
quick.fix.remove.statement=移除语句
quick.fix.remove.superclass=移除超类
quick.fix.remove.superclass.reference=移除超类引用
quick.fix.remove.synthesize.dynamic.statement=移除 '@synthesize'/'@dynamic' 语句
quick.fix.remove.synthesize.statement=移除 '@synthesize' 语句
quick.fix.remove.useless.import=移除无用的导入
quick.fix.remove.useless.include=移除无用的 include
quick.fix.remove.user.defined.getter.method=移除用户定义的 getter 方法
quick.fix.remove.user.defined.setter.method=移除用户定义的 setter 方法
quick.fix.send.release.message.instead.dealloc=发送“release”消息而非“dealloc”
unused.inspection.run.in.headers=在头文件中运行检查

<html>
<body>
<p>报告不将 `infix` 修饰符作为中缀运算符的字母数字定义的用法。</p>

<ul>
<li>“用反引号包装”快速修复会在调用周围添加 <code>`</code> 符号。</li>
<li>“从中缀表达式转换”快速修复会将中缀调用转换为方法语法 <code>.method(...)</code>。</li>
<li>“从中缀类型转换”快速修复会将中缀类型转换为前缀语法 <code>Type[...]</code>。</li>
<li>“从中缀模式转换”快速修复会将中缀模式转换为前缀语法 <code>pattern(...)</code>。</li>
</ul>

<p><b>示例：</b></p>
<pre><code>
  class C:
    def op(x: Int): Int = ???
  type Or[X, Y]
  case class Pair[T](x: T, y: T)

  val c = C()
  val p = Pair(1, 2)

  c op 2
  val or: Int Or String = ???
  val _ Pair _ = p
</code></pre>

<p>应用“用反引号包装”快速修复后：</p>
<pre><code>
  class C:
    def op(x: Int): Int = ???
  type Or[X, Y]
  case class Pair[T](x: T, y: T)

  val c = C()
  val p = Pair(1, 2)

  c `op` 2
  val or: Int `Or` String = ???
  val _ `Pair` _ = p
</code></pre>

<p>在应用“从中缀表达式转换”快速修复后：</p>
<pre><code>
  class C:
    def op(x: Int): Int = ???
  type Or[X, Y]
  case class Pair[T](x: T, y: T)

  val c = C()
  val p = Pair(1, 2)

  c.op(2)
  val or: Int Or String = ???
  val _ Pair _ = p
</code></pre>

<p>应用“从中缀类型转换”快速修复后：</p>
<pre><code>
  class C:
    def op(x: Int): Int = ???
  type Or[X, Y]
  case class Pair[T](x: T, y: T)

  val c = C()
  val p = Pair(1, 2)

  c op 2
  val or: Or[Int, String] = ???
  val _ Pair _ = p
</code></pre>

<p>应用“从中缀模式转换”快速修复后：</p>
<pre><code>
  class C:
    def op(x: Int): Int = ???
  type Or[X, Y]
  case class Pair[T](x: T, y: T)

  val c = C()
  val p = Pair(1, 2)

  c op 2
  val or: Int Or String = ???
  val Pair(_, _) = p
</code></pre>
<!-- tooltip end -->
</body>
</html>

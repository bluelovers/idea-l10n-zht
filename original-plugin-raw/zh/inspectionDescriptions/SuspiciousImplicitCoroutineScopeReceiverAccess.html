<html>
<body>
<p>报告在挂起上下文中可能存在问题的隐式 <code>CoroutineScope</code> 接收器访问。</p>

<p>
  当一个挂起函数或 Lambda 从外部上下文捕获隐式 <code>CoroutineScope</code> 接收器时，可能会导致意外行为。
  这是因为捕获的作用域在挂起函数仍在运行时可能会被取消或完成。
</p>

<p>
  此检查可以检测代码在挂起函数或 Lambda 中隐式访问 <code>CoroutineScope</code> 接收器的情况，
隐式访问会创建对外部作用域的潜在危险依赖。
</p>

<p><b>示例：</b></p>
<pre><code>
class MyClass {
    fun CoroutineScope.launchJobs() {
        launch { // 可以：直接在扩展函数中使用
            doSomething()
        }
        
        suspendingFunction { // 警告：可疑的隐式 'CoroutineScope' 接收器访问
            launch { // launch 调用使用外部上下文中的隐式 CoroutineScope
                doSomethingElse()
            }
        }
    }
}
</code></pre>

<p><b>选项:</b></p>
<ul>
  <li><b>检测 CoroutineScope 子类型</b> – 启用后，该检查还将检测对 CoroutineScope 的子类型的隐式访问</li>
</ul>

<p>要解决此问题，您可以：</p>
<ul>
  <li>使用 <code>this@receiverLabel.method()</code> 明确指定接收器</li>
  <li>将作用域作为形参传递给挂起函数</li>
  <li>使用 <code>coroutineScope { }</code> 构建器创建一个与挂起函数的生命周期绑定的子作用域</li>
</ul>
</body>
</html>
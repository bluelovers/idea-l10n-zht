<html>
<body>
<p>报告源类型和目标类型不相关的 <code>typing.cast</code> 调用。</p>
<p>当源类型既不是目标类型的子类型，目标类型也不是源类型的子类型时，将报告错误。
  此类转换通常指示逻辑错误，因为一种类型的实例不能被假定为另一种类型的实例，并且 <code>typing.cast</code> 不会动态验证类型。</p>

<p>此检查甚至适用于理论上可能具有共同后代的类型。
  例如，它将标记两个同级类 <code>Left</code> 和 <code>Right</code> 之间的转换，因为它们都继承自 <code>Top</code>，但彼此之间没有直接继承关系。</p>

<p><b>示例：</b></p>
<pre><code>
from typing import cast

# 非重叠类型 — 可能是错误
<b>cast(int, "a")</b>          # 'str' -> 'int'
<b>cast(list[int], ["a"])</b>  # 'list[str]' -> 'list[int]'

# 推荐的显式逃生舱口是使用“双重转换”
cast(int, <b>cast(object, "a")</b>)  # 正常

# 合法的重叠情况
cast(int, object())    # 有效的向下转换
cast(object, 1)        # 有效的向上转换

# 但以下是无效转换，因为 <code>list</code> 不可变。 当前不受此检查支持
int_list = [1, 2, 3]
cast(list[object], int_list)
</code></pre>
<!-- tooltip end -->
<p>该检查依赖于静态类型信息；当类型未知时，不会报告警告。

  尚未考虑泛型类型的差异。</p>
</body>
</html>
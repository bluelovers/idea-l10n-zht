action.Swift.Generate.DebugDescription.description=生成 debugDescription
action.Swift.Generate.DebugDescription.text=debugDescription…
action.Swift.Generate.Description.description=生成描述
action.Swift.Generate.Description.text=description…
action.Swift.Generate.EqualsHashValue.description=生成 equals 和 hash
action.Swift.Generate.EqualsHashValue.text=equals 和 hash
action.Swift.Generate.Init.description=生成初始設定式
action.Swift.Generate.Init.text=初始設定式
action.Swift.ShowSwiftIDETest.text=執行 Swift IDE 報告
action.SwiftExtractFunction.text=提取函式…
action.SwiftGenerateDocComment.text=生成文檔註釋
action.SwiftIntroduceClosureVariable.text=提取閉包…
action.SwiftToggleErrorHints.text=顯示錯誤提示
action.SwiftToggleGlobalErrorHints.text=顯示 Swift 錯誤提示
action.SwiftToggleGlobalTypeHints.text=顯示 Swift 類型提示
action.SwiftToggleTypeHints.text=顯示類型提示
auto.import.command.name=自動匯入模組
auto.import.completion.presentation.tail.from.0=\ ({0})
auto.import.settings.checkbox.sort=import 排序
auto.import.settings.import.symbol=自動匯入具體符號
auto.import.settings.import.symbol.help=自動匯入符號時，最好新增符號本身的匯入，而不是匯入宣告該符號的整個模組
auto.import.settings.optimize.non.module=最佳化非模組匯入
auto.import.settings.optimize.non.module.help=在最佳化匯入時，將函式、結構、類別等的顯式匯入取代為其父模組的匯入
call.hierarchy.usage.in=''{0}'' 中的用法
change.info.async.throws.label=async/throws:
change.info.default.value.code.comment="預設值 = {0}"
change.info.default.value.label=預設值:
change.info.dialog.invalid.function.name.0=無效函式名稱: ''{0}''
change.info.dialog.invalid.parameter.internal.name.0=無效參數內部名稱: ''{0}''
change.info.dialog.invalid.parameter.name.0=無效參數名稱: ''{0}''
change.info.dialog.no.function.name.specified=未指定函式名稱
change.info.dialog.parameter.after.variadic.should.have.nonempty.name=可變形參後面的參數應為非空名稱
change.info.dialog.rethrows.should.have.throwing.parameter='rethrows' 函式必須有一個拋出函式參數
change.info.internal.name.label=內部名稱:
change.info.name.label=名稱:
change.info.optional.label=可選:
change.info.options.label=選項
change.info.return.type.label=返回值類型:
change.info.type.label=類型:
change.signature.0.1.will.no.longer.be.visible.from.overriding.0.in.2.3={0} ''{1}'' 在{2} ''{3}'' 的覆寫{0}中將不再可見
change.signature.0.1.with.2.visibility.wont.be.accessible.from.3.4=可見性為“{2}”的{0} ''{1}'' 將無法從{3} ''{4}'' 存取
change.signature.0.can.throw.but.thrown.errors.are.not.handled=''{0}'' 可以拋出，但是沒有處理拋出的錯誤
change.signature.0.is.async.but.not.awaited=''{0}'' 等待呼叫，但未被標記為 async
change.signature.dialog.title=更改簽名
change.signature.initializer.will.conflict.with.0.in.1.2=初始設定式將與 {1} ''{2}'' 中的 {0} 衝突
change.signature.processed.elements.header=要更改簽名的元素
change.signature.subscript.will.conflict.with.0.in.1.2=下標將與 {1} ''{2}'' 中的 {0} 衝突
change.signature.target.not.found=文字游標應位於函式、初始設定式或下標處
change.signature.title=更改簽名
code.style.blank.lines.around.class=在類型宣告周圍:
code.style.blank.lines.around.field=圍繞屬性:
code.style.blank.lines.around.field.in.protocol=在協議中的屬性周圍:
code.style.blank.lines.around.method=在方法/函式周圍:
code.style.blank.lines.around.method.in.protocol=在協議中的方法/函式周圍:
code.style.blank.lines.before.method.body=方法/函式主體之前:
code.style.code.generation.doc.comment.style=首選塊(/** */)而不是行(///)文檔註釋
code.style.code.generation.doc.comment.tag.delimiter=列表條目分隔符:
code.style.code.generation.prefer.explicit.return=首選顯式返回(&R)
code.style.code.generation.prefer.void=首選 Void 而不是 ()(&V)
code.style.code.generation.tab.title=程式碼生成
code.style.indent.directives.as.code=遵循程式碼縮排
code.style.indent.directives.children=縮排子項
code.style.indent.group.title.directives=指令
code.style.indent.method.chain=鏈式方法縮排:
code.style.indent.multiline.string.or.regex=縮排多行字串或正則表達式
code.style.spaces.after.argument.colon=方法/函式呼叫中的冒號之後
code.style.spaces.after.dictionary.literal.colon=字典文字 'key:value' 對中的冒號之後
code.style.spaces.after.dictionary.type.colon=字典類型中的冒號之後
code.style.spaces.after.operator.in.function.declarations=函式宣告中的運算符
code.style.spaces.after.semicolon=分號之後
code.style.spaces.after.superclass.colon=類型繼承子句中的冒號之後
code.style.spaces.after.type.colon=類型註解中的冒號之後
code.style.spaces.around.range.operators=範圍運算符(...、..<)
code.style.spaces.attribute.parameters=特性參數
code.style.spaces.attribute.parentheses=特性圓括號
code.style.spaces.before.argument.colon=方法/函式呼叫中的冒號之前
code.style.spaces.before.class.lbrace=類型宣告左大括號
code.style.spaces.before.dictionary.literal.colon=字典文字 'key:value' 對中的冒號之前
code.style.spaces.before.dictionary.type.colon=字典類型中的冒號之前
code.style.spaces.before.method.call.parentheses=方法/函式呼叫圓括號
code.style.spaces.before.method.lbrace=方法/函式左大括號
code.style.spaces.before.method.parentheses=方法/函式宣告圓括號
code.style.spaces.before.semicolon=分號之前
code.style.spaces.before.superclass.colon=類型繼承子句中的冒號之前
code.style.spaces.before.type.colon=類型註解中的冒號之前
code.style.spaces.closure.arrow=閉包箭頭(->)
code.style.spaces.equality.operator=相等運算符 '=='
code.style.spaces.group.title.colon=冒號周圍
code.style.spaces.group.title.in.ternary=在三元條件運算中
code.style.spaces.shift.operators=移位運算符(<<, >>)
code.style.spaces.within.empty.method.call.parentheses=空方法/函式呼叫圓括號
code.style.spaces.within.empty.method.parentheses=空方法/函式宣告圓括號
code.style.spaces.within.literal.brackets=陣列和字典文字中括號
code.style.spaces.within.method.call.parentheses=方法/函式呼叫圓括號
code.style.spaces.within.method.parentheses=方法/函式宣告圓括號
code.style.spaces.within.string.interpolations=字串內插
code.style.wrapping.align.in.columns=在列中對齊
code.style.wrapping.align.when.multiline=多行時對齊
code.style.wrapping.array.literal=陣列和字典文字
code.style.wrapping.array.new.line.after.left.bracket=在 '[' 後換行
code.style.wrapping.array.right.bracket.on.new.line=將 ']' 置於新行中
code.style.wrapping.brace.placement.class.declaration=在類型宣告中
code.style.wrapping.classes.annotation=類型宣告特性
code.style.wrapping.closure.signature.on.next.line=多行時參數在新行中
code.style.wrapping.fields.annotation=屬性特性
code.style.wrapping.group.title.closure=閉包
code.style.wrapping.group.title.condition.clauses=條件子句
code.style.wrapping.group.title.do.while='repeat … while' 語句
code.style.wrapping.group.title.guard='guard' 語句
code.style.wrapping.group.title.if='if' 語句
code.style.wrapping.group.title.method.arguments=方法/函式呼叫實參
code.style.wrapping.group.title.method.parameters=方法/函式宣告參數
code.style.wrapping.group.title.superclass.list=基類別和採用的協議列表
code.style.wrapping.group.title.ternary=三元條件運算
code.style.wrapping.group.title.try='do' 語句
code.style.wrapping.group.title.variable.groups=變數組
code.style.wrapping.guard.else='否則'
code.style.wrapping.guard.else.always=始終換行
code.style.wrapping.guard.else.never=不換行
code.style.wrapping.guard.else.wrapped=有條件換行
code.style.wrapping.keep.control.statement.in.one.line=控制語句在同一行
code.style.wrapping.keep.simple.argument.blocks.in.one.line=閉包實參在同一行
code.style.wrapping.keep.simple.blocks.in.one.line=塊和(尾隨)閉包在同一行
code.style.wrapping.keep.simple.methods.in.one.line=方法和函式在同一行
code.style.wrapping.local.variables.annotation=區域變數特性
code.style.wrapping.method.brace.placement=在方法和函式中
code.style.wrapping.method.chain.dot.on.new.line='.' 在新行
code.style.wrapping.methods.annotation=方法特性
code.style.wrapping.parameters.annotation=參數特性
code.style.wrapping.structures.in.one.line=空類型宣告在同一行
color.conditionally.non.compiled=關鍵字和指令//有條件的未編譯程式碼
color.settings.actor=類型//Actor
color.settings.anonymous.closure.parameter=關鍵字//匿名閉包參數
color.settings.argument.label=關鍵字//實參標籤
color.settings.associated.type=類型//關聯類型
color.settings.attribute.argument=特性//特性實參
color.settings.attribute.name=特性//特性名稱
color.settings.class=類型//類別
color.settings.colon=大括號和運算符//冒號
color.settings.directive=關鍵字和指令//指令
color.settings.directive.condition=關鍵字和指令//指令條件
color.settings.directive.flag=關鍵字和指令//指令標誌
color.settings.enum.case.value=關鍵字//枚舉 case 值
color.settings.external.parameter.name=關鍵字//外部參數名稱
color.settings.function.and.method.call=函式//函式和方法呼叫
color.settings.function.and.method.declaration=函式//函式和方法宣告
color.settings.inline.closure.parameter=關鍵字//內聯閉包參數
color.settings.inline.hints.error.hint=內聯提示//錯誤提示
color.settings.inline.hints.type.hint=內聯提示//類型提示
color.settings.keyword=關鍵字和指令//關鍵字
color.settings.module.name=類型//模組名稱
color.settings.nested.function.call=函式//嵌套函式呼叫
color.settings.nested.function.declaration=函式//嵌套函式宣告
color.settings.operator.sign=大括號和運算符//運算符
color.settings.property=關鍵字//屬性
color.settings.protocol=類型//協議
color.settings.self.and.super.keywords=關鍵字和指令//'self' 和 'super'
color.settings.struct.and.enum=類型//結構和枚舉
color.settings.tuple.label=關鍵字//元組標籤
color.settings.tuple.type.label=關鍵字//元組類型標籤
color.settings.type.alias=類型//類型別名
color.settings.type.parameter=類型//泛型參數
color.settings.wildcard=關鍵字//萬用字元
command.name.extract.function=提取函式
context.declaration=宣告
context.statement=語句
create.file.action=建立 Swift 檔案 {0}
create.file.description=建立新的 Swift 檔案
create.file.dialog.title=新增 Swift 檔案
create.file.kind=種類(&K):
create.file.kind.file=檔案
create.file.or.type.description=建立新的 Swift 檔案或類型
create.file.or.type.title=Swift 檔案/類型
create.file.title=Swift 檔案
create.file.type.description=建立新的 Swift 類型
create.file.type.dialog.title=新增 Swift 類型
create.file.type.dialog.title.with.kind=新增 Swift {0}
create.file.type.title=Swift 類型
create.from.usage.choose.target.type=選擇目標類型
create.from.usage.create.function.command=根據用法建立函式
create.from.usage.create.init.command=根據用法建立初始設定式
create.from.usage.create.type.command=建立新的 Swift 類型
create.from.usage.create.variable.command=根據用法建立變數
create.from.usage.location.in=({0} 中)
create.from.usage.location.new.file=新增檔案
create.from.usage.location.this.file=此文件
doc.comments.enable.markdown=啟用 Markdown 延伸模組以設定文檔註釋的格式
editor.appearance.error.hints=顯示 Swift 錯誤提示
editor.appearance.type.hints=顯示 Swift 類型提示
error.cannot.perform.refactoring=無法執行重構
error.no.expression.found=找不到表達式
extract.method.0.1.will.be.shadowed.by.2.1={0} ''{1}'' 將被 {2} ''{1}'' 遮蓋
extract.method.at.least.two.parameters.have.name.0=至少兩個參數的名稱為 ''{0}''
extract.method.cannot.extract.mutable.value=無法提取可變值
extract.method.error.cannot.determine.expr.type=無法確定所選表達式的類型
extract.method.error.cannot.determine.function.result.type=無法確定函式結果的類型
extract.method.error.cannot.determine.parameters.type=無法確定參數類型
extract.method.error.cannot.extract.expr.with.var.declarations=無法從包含變數宣告的表達式中提取
extract.method.error.cannot.extract.with.returns=無法提取程式碼段內包含返回指令的函式
extract.method.error.fragment.should.be.inside.code.block=所選程式碼段應在程式碼塊內
extract.method.error.multiple.exit.points=所選程式碼段有多個出口點。
extract.method.error.result.builder.block=無法提取結果建置器閉包中的函式
extract.method.error.should.represent.expr.or.statements=所選塊應代表一組語句或表達式
extract.method.function.0.will.conflict.with.1.2=函式 ''{0}'' 將與 {1} {2} 衝突
extract.method.method.0.will.conflict.with.1.in.2.3=方法 ''{0}'' 將與{2} ''{3}'' 中的 {1} 衝突
extract.method.title.closure=提取閉包
extract.method.title.function=提取函式
extract.method.title.method=提取方法
extract.method.variable.0.will.no.longer.be.accessible=變數 ''{0}'' 重構後不再可存取
find.usages.base.member.warning.message.default.implementation.method={0} 是對 {1} 中宣告的方法的預設實作\n\n是否要尋找協議{3, choice,1#方法|2#方法}的用法?
find.usages.base.member.warning.message.default.implementation.property={0} 是對 {1} 中宣告的屬性的預設實作\n\n是否要尋找協議{3, choice,1#屬性|2#屬性}的用法?
find.usages.base.member.warning.message.default.implementation.subscript={0} 是對 {1} 中宣告的下標的預設實作\n\n是否要尋找協議{3, choice,1#下標|2#下標}的用法?
find.usages.base.member.warning.message.implements.method={0} 實作 {1} 中宣告的方法\n\n是否要尋找協議{3,choice,1#方法|2#方法}的用法?
find.usages.base.member.warning.message.implements.property={0} 實作 {1} 中宣告的屬性\n\n是否要尋找協議{3,choice,1#屬性|2#屬性}的用法?
find.usages.base.member.warning.message.implements.subscript={0} 實作 {1} 中宣告的下標\n\n是否要尋找協議{3,choice,1#下標|2#下標}的用法?
find.usages.base.member.warning.message.override.implemented.method={0} 覆寫 {2} 中宣告的方法，並實作 {1} 中宣告的方法\n\n是否要尋找基和協議{3,choice,1#方法|2#方法}的用法?
find.usages.base.member.warning.message.override.implemented.property={0} 覆寫 {2} 中宣告的屬性，並實作 {1} 中宣告的屬性\n\n是否要尋找基和協議{3,choice,1#屬性|2#屬性}的用法?
find.usages.base.member.warning.message.override.implemented.subscript={0} 覆寫 {2} 中宣告的下標，並實作 {1} 中宣告的下標\n\n是否要尋找基和協議{3,choice,1#下標|2#下標}的用法?
find.usages.base.member.warning.message.override.method={0} 覆寫 {2} 中宣告的方法\n\n是否要尋找基{3,choice,1#方法|2#方法}的用法?
find.usages.base.member.warning.message.override.property={0} 覆寫 {2} 中宣告的屬性\n\n是否要尋找基{3,choice,1#屬性|2#屬性}的用法?
find.usages.base.member.warning.message.override.subscript={0} 覆寫 {2} 中宣告的下標\n\n是否要尋找基{3,choice,1#下標|2#下標}的用法?
find.usages.base.member.warning.title=警告
find.usages.option.search.in.not.compiled.code=顯示有條件的未編譯程式碼中的潛在用法
generate.0.title=生成 {0}
generate.cannot.generate.0.for.1=無法為 {1} 生成 {0}
generate.description.multi.string.template=多行字串
generate.description.single.string.template=單字串
generate.description.string.concatenation.template=包含串聯的多個字串(+)
generate.equals.hash=equals 和 hash
generate.equals.hash.choose.in.0=選擇要包含在 {0} 中的屬性
generate.if.statements.equals.template=多個 if 語句
generate.init.choose.properties=選擇要初始化的屬性
generate.init.choose.super.init=選擇超類別初始設定式
generate.init.init.already.exists=初始設定式已存在
generate.method.0.and.operator.function.1.are.already.defined=已定義方法 ''{0}'' 和運算符函式 ''{1}''。是否要將其刪除並繼續?
generate.method.0.and.property.1.are.already.defined=已定義方法 ''{0}'' 和屬性 ''{1}''。是否要將其刪除並繼續?
generate.method.0.is.already.defined=已定義方法 ''{0}''。是否要將其刪除並繼續?
generate.method.0.property.1.and.operator.function.2.are.already.defined=已定義方法 ''{0}''、屬性 ''{1}'' 和運算符函式 ''{2}''。是否要將其刪除並繼續?
generate.operator.function.0.is.already.defined=已定義運算符函式 ''{0}''。是否要將其刪除並繼續?
generate.preparing.generation.title=正在準備生成…
generate.property.0.and.operator.function.1.are.already.defined=已定義屬性 ''{0}'' 和運算符函式 ''{1}''。是否要將其刪除並繼續?
generate.property.0.is.already.defined=已定義屬性 ''{0}''。是否要將其刪除並繼續?
generate.single.expression.equals.template=單表達式
generate.template.title=模板(&T):
got.it.no.refactoring.in.not.compiled.code.header=重構動作不可用
got.it.no.refactoring.in.not.compiled.code.message=重構動作在有條件的未編譯程式碼中不可用。切換到不同的解析上下文以啟用周圍的 `#if directive` 分支。
got.it.search.not.compiled.code.header=有條件的未編譯程式碼中的用法
got.it.search.not.compiled.code.message=可以從“重新命名”對話框啟用在有條件的未編譯程式碼中搜尋用法。要顯示“重新命名”對話框，請再次按 {0}。
goto.base.type=基類型
goto.class.kind=類型
goto.class.kinds.title=類型
goto.super.action=選擇 {0}
goto.super.class=類別或協議
goto.super.extension.of.0={0} 的擴展
goto.super.location={0} ({1} 內)
goto.super.menu.action=超級 {0}(_U)
goto.super.typealias=類型別名或關聯類型
inheritance.relation.implements=實作 {0}
inheritance.relation.is.implemented=被實作
inheritance.relation.is.overridden=被覆寫
inheritance.relation.is.subclassed=被子類別化
inheritance.relation.overrides=覆寫 {0}
inline.0.action.1=正在內聯{0} {1}
inline.0.command.1=正在內聯{0} {1}
inline.all.invocations.and.keep.the.0=全部內聯，保留{0}(&A)
inline.all.invocations.and.remove.the.0=全部內聯，移除{0}(&A)
inline.all.references.and.keep.the.0=全部內聯，保留{0}(&A)
inline.all.references.and.remove.the.0=全部內聯，移除{0}(&A)
inline.all.typealias.and.keep.the.0=全部內聯，保留{0}(&A)
inline.all.typealias.and.remove.the.0=全部內聯，移除{0}(&A)
inline.error.cannot.access.symbol.0=無法存取符號 {0}
inline.error.cannot.resolve.symbol=無法解析符號
inline.error.function.definition.contains.no.body=函式定義不包含正文
inline.error.function.no.return.statement=函式缺少 return 語句
inline.error.implements.function.from.0=內聯方法實作方法從{0}
inline.error.inline.function.has.conditionally.compiled.code=該函式可能未正確內聯，因為它包含有條件的未編譯程式碼
inline.error.inline.function.only.in.swift.code=僅在 Swift 程式碼中支援函式內聯
inline.error.inline.recursive.function.only.on.invocations=僅在調用時才支援內聯遞迴函式
inline.error.inline.typealias.has.conditionally.compiled.code=該類型別名可能未正確內聯，因為它包含有條件的未編譯程式碼
inline.error.inline.variable.has.conditionally.compiled.code=該變數可能未正確內聯，因為它包含有條件的未編譯程式碼
inline.error.inline.variable.no.single.definition=找不到要內聯的單一定義
inline.error.inlined.expression.should.be.part.of.statement=內聯表達式應為語句的一部分
inline.error.invalid.function.arguments=函式實參無效
inline.error.is.overridden.by.function.from.0=內聯方法被來自 {0} 的方法覆寫
inline.error.not.function.call=不是函式呼叫
inline.error.overrides.associated.type.from.0=內聯的類型別名會覆寫來自 {0} 的關聯類型
inline.error.overrides.function.from.0=從{0}內聯方法覆寫方法
inline.error.unexpected.error=內聯時出現意外錯誤
inline.function.description=將函式呼叫取代為其主體
inline.function.label.kind.0.name.1=內聯{0} {1}:
inline.function.label.kind.0.name.1.2.occurrences=內聯{0} {1} 的 {2} 個呼叫:
inline.function.label.kind.0.name.1.occurence=內聯{0} {1} 的呼叫:
inline.include.doc.comments=內聯文檔註釋
inline.recursively=遞迴內聯
inline.this.invocation.only.and.keep.the.0=僅內聯此呼叫，保留{0}
inline.this.reference.only.and.keep.the.0=僅內聯此參照，保留{0}
inline.this.typealias.only.and.keep.the.0=僅內聯此用法，保留 {0}
inline.title.0=內聯{0}
inline.typealias.label.kind.0.name.1=內聯{0} {1}:
inline.typealias.label.kind.0.name.1.2.occurrences=內聯 {0} {1} 的 {2} 用法:
inline.typealias.label.kind.0.name.1.occurence=內聯 {0} {1} 的用法:
inline.variable.label.kind.0.name.1=內聯{0} {1}:
inline.variable.label.kind.0.name.1.2.occurrences=內聯{0} {1} 的 {2} 個參照:
inline.variable.label.kind.0.name.1.occurence=內聯{0} {1} 的參照:
inspection.conditionally.not.compiled.code=有條件的未編譯程式碼
inspection.missing.doc.comment.parameter.item=不符合的 doc 註釋和函式簽名
inspection.missing.doc.comment.parameter.item.error=doc 註釋中未描述參數 {0}
inspection.missing.doc.comment.parameter.item.fix=更新 doc 註釋
inspection.missing.localization=缺少本地化
inspection.missing.localization.all.languages.only=僅報告所有語言中都缺少的本地化
inspection.redundant.attribute=冗餘特性
inspection.redundant.attribute.error=''@{0}'' 冗餘
inspection.redundant.attribute.fix=移除冗餘 ''@{0}''
inspection.redundant.closure=冗餘閉包
inspection.redundant.closure.error=冗餘的閉包建立
inspection.redundant.closure.fix=內聯主體
inspection.redundant.nullable.function.type.error=''{0}'' 始終返回非 null 類型
inspection.redundant.nullable.type=冗餘的可以為 null 類型
inspection.redundant.nullable.type.error=''{0}'' 始終為非 null 類型
inspection.redundant.nullable.type.fix=移除冗餘的 '?'
inspection.redundant.return=冗餘 'return'
inspection.redundant.return.error='return' 冗餘
inspection.redundant.return.fix=移除冗餘 'return'
inspection.unnecessary.argument.list=閉包前的空實參圓括號
inspection.unnecessary.argument.list.error=實參圓括號不必要
inspection.unnecessary.argument.list.fix=移除不必要的實參圓括號
inspection.unnecessary.parentheses=不必要的圓括號
inspection.unnecessary.parentheses.error=圓括號不必要
inspection.unnecessary.parentheses.fix=移除不必要的圓括號
inspection.unnecessary.self=不必要的 'self'
inspection.unnecessary.self.error='self' 不必要
inspection.unnecessary.self.fix=移除不必要的 'self'
inspection.unnecessary.tuple.wrap=不必要的元組換行
inspection.unnecessary.tuple.wrap.error=單元素元組可被取代為類型
inspection.unnecessary.tuple.wrap.fix=將單元素元組取代為類型
intention.access.control.error.access=無法存取 {0}: 它在{2}中為{1}
intention.access.control.error.access.dynamic=無法存取 {0}: 動態成員下標在 {2} 中為 {1}
intention.access.control.error.override=無法覆寫 {0}: 它在 {2} 中為 {1}
intention.access.control.fix=在 {2} 中使{0} {1}
intention.access.control.remove.setter=從 {0} 移除 {1}
intention.add.catch.clause=新增 'catch'
intention.add.default.catch.clause=新增預設 'catch' 子句
intention.add.digit.separators=新增數字分隔符
intention.add.explicit.qualifier=新增顯式限定符
intention.add.explicit.type=新增顯式類型
intention.add.try.to.expression=將 'try' 新增到表達式
intention.add.try.to.iteration=將 'try' 新增到迭代
intention.category.swift=Swift
intention.convert.to.binary=轉換為二進制
intention.convert.to.closure.argument=轉換為閉包實參
intention.convert.to.decimal=轉換為十進制
intention.convert.to.hex=轉換為十六進制
intention.convert.to.multiline.string=轉換為多行字串文字
intention.convert.to.octal=轉換為八進制
intention.convert.to.string=轉換為單行字串文字
intention.convert.to.trailing.closure=轉換為尾隨閉包
intention.create.actor.0=建立 actor ''{0}''
intention.create.actor.0.in.new.file=在新檔案中建立 actor ''{0}''
intention.create.actor.0.nested.in.1=建立嵌套在 ''{1}'' 中的 actor ''{0}''
intention.create.class.0=建立類別 ''{0}''
intention.create.class.0.in.new.file=在新檔案中建立類別 ''{0}''
intention.create.class.0.nested.in.1=建立嵌套在 ''{1}'' 中的類別 ''{0}''
intention.create.enum.0=建立枚舉 ''{0}''
intention.create.enum.0.in.new.file=在新檔案中建立枚舉 ''{0}''
intention.create.enum.0.nested.in.1=建立嵌套在 ''{1}'' 中的枚舉 ''{0}''
intention.create.enum.case.0=建立枚舉 case ''{0}''
intention.create.global.function.0=建立全域函式 ''{0}''
intention.create.global.variable.0=建立全域變數 ''{0}''
intention.create.initializer=建立初始設定式
intention.create.local.variable.0=建立區域變數 ''{0}''
intention.create.method.0=建立方法 ''{0}''
intention.create.method.0.in.extension=建立擴展方法 ''{0}''
intention.create.new.swift.declaration=建立新的 Swift 宣告
intention.create.new.swift.type.in.a.new.file=在新檔案中新增 Swift 類型
intention.create.property.0=建立屬性 ''{0}''
intention.create.property.0.in.extension=建立擴展屬性 ''{0}''
intention.create.protocol.0=建立協議 ''{0}''
intention.create.protocol.0.in.new.file=在新檔案中建立協議 ''{0}''
intention.create.protocol.0.nested.in.1=建立嵌套在 ''{1}'' 中的協議 ''{0}''
intention.create.struct.0=建立結構 ''{0}''
intention.create.struct.0.in.new.file=在新檔案中建立結構 ''{0}''
intention.create.struct.0.nested.in.1=建立嵌套在 ''{1}'' 中的結構 ''{0}''
intention.create.type.0=建立類型 ''{0}''
intention.create.type.0.in.new.file=在新檔案中建立類型 ''{0}''
intention.create.type.0.nested.in.1=建立嵌套在 ''{1}'' 中的類型 ''{0}''
intention.create.type.method.0=建立類型方法 ''{0}''
intention.create.type.method.0.in.extension=建立擴展類型方法 ''{0}''
intention.create.type.property.0=建立類型屬性 ''{0}''
intention.create.type.property.0.in.extension=建立擴展類型屬性 ''{0}''
intention.decrease.string.escape.level=降低字串轉義級別
intention.demorgans.law=德摩根定律
intention.demorgans.law.format=將 ''{0}'' 取代為 ''{1}''
intention.extract.class.0.to.extension=將類別 ''{0}'' 提取到擴展
intention.extract.class.0.to.type.declaration=將類別 ''{0}'' 提取到類型宣告
intention.extract.conformance.to.extension.cannot.add.protocol.conformance.to.protocol=協議擴展無法符合其他協議
intention.extract.conformance.to.extension.cannot.extract.class=無法將類別繼承 ''{0}'' 提取到擴展
intention.extract.conformance.to.extension.familyName=將一致性提取到擴展
intention.extract.conformance.to.extension.type.cannot.be.local=無法在區域作用域中建立擴展
intention.extract.conformance.to.extension.type.must.be.fileprivate=類型必須至少為 fileprivate
intention.extract.enum.0.to.extension=將枚舉 ''{0}'' 提取到擴展
intention.extract.enum.0.to.type.declaration=將枚舉 ''{0}'' 提取到類型宣告
intention.extract.from.extension.to.type.declaration.error.message.title=將成員提取到其原始類型宣告
intention.extract.from.extension.to.type.declaration.familyName=將成員提取到其原始類型宣告
intention.extract.from.extension.to.type.declaration.original.analysis.on.type.not.allowed=原始類型宣告超出作用域
intention.extract.from.extension.to.type.declaration.original.type.not.found=找不到原始類型宣告
intention.extract.function.0.to.extension=將函式 ''{0}'' 提取到擴展
intention.extract.function.0.to.type.declaration=將函式 ''{0}'' 提取到類型宣告
intention.extract.initializer.to.extension=將初始設定式提取到擴展
intention.extract.initializer.to.type.declaration=將初始設定式提取到類型宣告
intention.extract.member.to.extension.cannot.extract.from.protocol=無法從協議中提取
intention.extract.member.to.extension.type.cannot.be.local=無法在區域作用域中建立擴展
intention.extract.member.to.extension.type.must.be.fileprivate=類型必須至少為 fileprivate
intention.extract.members.to.extension.error.message.title=將成員提取到擴展
intention.extract.members.to.extension.familyName=將成員提取到擴展
intention.extract.multiple.members.to.extension=將成員提取到擴展
intention.extract.multiple.members.to.type.declaration=將成員提取到類型宣告
intention.extract.property.0.to.extension=將屬性 ''{0}'' 提取到擴展
intention.extract.property.0.to.type.declaration=將屬性 ''{0}'' 提取到類型宣告
intention.extract.struct.0.to.extension=將結構 ''{0}'' 提取到擴展
intention.extract.struct.0.to.type.declaration=將結構 ''{0}'' 提取到類型宣告
intention.extract.subscript.to.extension=將下標提取到擴展
intention.extract.subscript.to.type.declaration=將下標提取到類型宣告
intention.extract.typealias.0.to.extension=將類型別名 ''{0}'' 提取到擴展
intention.extract.typealias.0.to.type.declaration=將類型別名 ''{0}'' 提取到類型宣告
intention.flip.binary.expression=翻轉二元表達式
intention.flip.binary.expression.format=翻轉 ''{0}''
intention.flip.comparison=翻轉比較
intention.flip.comparison.format=將 ''{0}'' 翻轉為 ''{1}''
intention.generate.documentation.comment=新增文檔註釋
intention.implement.members.error=類型 {0} 不符合{1} {2}
intention.implement.members.implement.missing=實作 {0} 個缺少的{0, choice,1#成員|2#成員}
intention.increase.string.escape.level=提高字串轉義級別
intention.invert.if.statement=反轉 'if' 語句
intention.join.declaration.and.assignment=聯接宣告和賦值
intention.localize.string=本地化字串
intention.localize.string.title.case=本地化字串
intention.mark.the.enclosing.function.as.throws=將 'throws' 新增到函式簽名
intention.merge.conditions=合併條件
intention.merge.else.if=合併 'else if'
intention.merge.nested.if=合併嵌套的 'if'
intention.negate.comparison=求反比較
intention.negate.comparison.format=將 ''{0}'' 求反為 ''{1}''
intention.remove.digit.separators=移除數字分隔符
intention.remove.explicit.type=移除顯式類型
intention.replace.guard.with.if=將 'guard' 取代為 'if'
intention.replace.if.with.guard=將 'if' 取代為 'guard'
intention.replace.rethrows.with.throws=將 'rethrows' 取代為 'throws'
intention.simplifyifelse.collapse.conditional.expression=摺疊條件表達式
intention.simplifyifelse.collapse.guard=摺疊 'guard'
intention.simplifyifelse.collapse.ifelse=摺疊 'if else'
intention.simplifyifelse.familyName=簡化 if-else
intention.simplifyifelse.replace.guard.with.0=將 ''guard'' 取代為 ''{0}''
intention.simplifyifelse.replace.if.else.with.0=將 ''if else'' 取代為 ''{0}''
intention.simplifyifelse.simplify=簡化
intention.simplifyifelse.simplify.guard=簡化 'guard'
intention.simplifyifelse.simplify.if.else=簡化 'if else'
intention.split.condition=拆分為單獨的條件
intention.split.declaration.and.assignment=拆分為宣告和賦值
intention.split.else.if=拆分 'else if'
intention.split.into.separate.declarations=拆分為單獨的宣告
intention.split.nested.if=拆分為嵌套的 'if'
intention.suppress.call.error.with.try=使用 'try!' 禁止此錯誤
intention.surround.with.do.catch=使用 'do/catch' 包圍
intention.swift.module.info=顯示模組資訊
intention.switch.resolve.configuration.specified=切換到 ''{0}''，將此分支設定為有效
intention.unresolved.reference.0.1=匯入 {0} ''{1}''
intention.unwrap.with.guard.let=使用 'guard let' 解包
intention.unwrap.with.if.let=使用 'if let' 解包
intention.wrong.return.type.error.void=void 函式中有意外的非 void 返回值
intention.wrong.return.type.fix=使 ''{0}'' 返回 ''{1}''
introduce.variable.declare.with.var=使用 var 宣告(&V)
introduce.variable.expression.will.be.ambiguous.without.explicit.type=表達式將不明確，<br/>無顯式類型
introduce.variable.specify.type.explicitly=顯式指定類型(&T)
notification.group.plugin.errors=Swift 語言服務失敗
optimize.imports.rearranged.imports=重新排列的 import
optimize.imports.removed.0.added.1.imports=已移除 {0} 個{0,choice,0#匯入|1#匯入|1<匯入}，已新增 {1} 個{1,choice,0#匯入|1#匯入|1<匯入}
optimize.imports.removed.0.imports=已移除 {0} 個{0,choice,0#匯入|1#匯入|1<匯入}
override.implement.elements.to.implement.chooser.title=選擇要實作的成員
override.implement.elements.to.override.chooser.title=選擇要覆寫的成員
override.implement.elements.to.override.implement.chooser.title=選擇要覆寫/實作的成員
override.implement.implement.not.allowed=無法實作
override.implement.nothing.to.implement=沒有要實作的內容
override.implement.nothing.to.override=沒有要覆寫的內容
override.implement.override.not.allowed=無法覆寫
override.implement.progress=正在處理要覆寫/實作的成員…
override.implement.show.members.to.implement.title=顯示要實作的成員
override.implement.show.no.optional.members=顯示可選成員(無可選項)
override.implement.show.only.optional.members=顯示可選成員(僅可選項)
override.implement.show.optional.member=顯示 1 個可選成員(&O)
override.implement.show.optional.members=顯示 {0} 個可選成員(&O)
refactor.0.overrides.associated.type.of.1={0} 覆寫 {1} 的關聯類型
refactor.0.overrides.declaration.in.1={0} 覆寫 {1} 中的宣告
refactor.0.overrides.initializer.of.1={0} 覆寫 {1} 的初始設定式
refactor.0.overrides.method.of.1={0} 覆寫 {1} 的方法
refactor.0.overrides.property.of.1={0} 覆寫 {1} 的屬性
refactor.0.overrides.subscript.of.1={0} 覆寫 {1} 的下標
refactor.base.declaration=重構基{0,choice,1#宣告|2#宣告}
refactor.only.current.declaration=僅重構當前宣告
refactoring.option.search.in.not.compiled.code=適用於有條件的未編譯程式碼
rename.containing.file.dialog.description=將具有以下名稱的包含檔案重命名為:
rename.containing.file.dialog.title=重新命名包含檔案
rename.containing.file.entity.name=Include 檔案
rename.error.dynamic.called.values=無法重新命名動態呼叫值
rename.error.message.renaming.swift.member.elements.in.objective.c.code.is.not.supported=不支持在 Objective-C 程式碼中重新命名 Swift 成員元素
rename.error.title=Swift - 重新命名
rename.inheritor.entity.name=繼承者
rename.inheritors=重新命名繼承者
rename.inheritors.to=將繼承者重命名為:
rename.init.is.not.supported=不支持重新命名 Swift 初始設定式
rename.related.dialog.description=將具有以下名稱的相關宣告重命名為:
rename.related.dialog.title=重新命名相關宣告
rename.related.entity.name=相關宣告
rename.self.is.not.supported=不支持重新命名自參數
rename.title=Swift 名稱重新命名
searching.for.implementations=正在搜尋實作…
searching.for.overriders=正在搜尋覆寫者…
searching.for.subclasses=正在搜尋子類別…
sourcekit.fix.it=套用 Fix-it
sourcekit.inspections=SourceKit 檢查
swift.name=Swift
syntax.error.call.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=呼叫可以拋出，但在非拋出自動閉包中執行
syntax.error.call.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=呼叫可以拋出，但未使用 'try' 標記，並且在非拋出自動閉包中執行
syntax.error.call.can.throw.in.default.argument=呼叫可以拋出，但無法從預設實參拋出錯誤
syntax.error.call.can.throw.in.property.initializer=呼叫可以拋出，但無法從屬性初始值設定拋出錯誤
syntax.error.call.can.throw.not.marked.with.try=呼叫可以拋出，但未使用 'try' 標記
syntax.error.call.can.throw.not.marked.with.try.not.exhaustive=呼叫可以拋出，但未使用 'try' 標記，並且封閉 catch 不詳盡
syntax.error.call.can.throw.not.marked.with.try.not.handled=呼叫可以拋出，但未使用 'try' 標記，並且錯誤未被處理
syntax.error.call.rethrows.function.can.only.throw.parameter.call.not.handled=呼叫可以拋出，但錯誤未被處理；被宣告為 'rethrows' 的函式只能在其參數拋出時拋出
syntax.error.call.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=呼叫可以拋出，但未使用 'try' 標記，錯誤未被處理；被宣告為 'rethrows' 的函式只能在其參數拋出時拋出
syntax.error.duplicate.platform=已指定平台 ''{0}''
syntax.error.error.is.not.handled=錯誤未被處理，因為封閉函式未被宣告為 'throws'
syntax.error.error.is.not.handled.not.exhaustive=錯誤未被處理，因為封閉 catch 不詳盡
syntax.error.errors.are.not.handled=從此處拋出的錯誤未被處理
syntax.error.errors.are.not.handled.not.exhaustive=從此處拋出的錯誤未被處理，因為封閉 catch 不詳盡
syntax.error.hashbang.line.is.allowed.only.in.the.first.line.of.the.file=僅在檔案的第一行中允許 Hashbang 行
syntax.error.hashbang.line.is.allowed.only.in.the.first.line.of.the.main.file=僅在主檔案的第一行中允許 Hashbang 行
syntax.error.hashbang.line.is.allowed.only.in.the.main.file=僅在主檔案中允許 Hashbang 行
syntax.error.interpolation.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=插值可以拋出，但在非拋出自動閉包中執行
syntax.error.interpolation.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=插值可以拋出，但未使用 'try' 標記，並且在非拋出自動閉包中執行
syntax.error.interpolation.can.throw.in.default.argument=插值可以拋出，但無法從預設實參拋出錯誤
syntax.error.interpolation.can.throw.in.property.initializer=插值可以拋出，但無法從屬性初始設定式拋出錯誤
syntax.error.interpolation.can.throw.not.marked.with.try=插值可以拋出，但未使用 'try' 標記
syntax.error.interpolation.can.throw.not.marked.with.try.not.exhaustive=插值可以拋出，但未使用 'try' 標記，並且封閉 catch 不詳盡
syntax.error.interpolation.can.throw.not.marked.with.try.not.handled=插值可以拋出，但未使用 'try' 標記，並且錯誤未被處理
syntax.error.interpolation.rethrows.function.can.only.throw.parameter.call.not.handled=插值可以拋出，但錯誤未被處理；宣告 'rethrows' 的函式只能在其參數拋出時拋出
syntax.error.interpolation.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=插值可以拋出，但未使用 'try' 標記，錯誤未被處理；宣告 'rethrows' 的函式只能在其參數拋出時拋出
syntax.error.iteration.can.throw.not.marked.with.try=迭代可以拋出，但未使用 'try' 標記
syntax.error.iteration.can.throw.not.marked.with.try.not.exhaustive=迭代可以拋出，但未使用 'try' 標記，並且封閉 catch 不詳盡
syntax.error.iteration.can.throw.not.marked.with.try.not.handled=迭代可以拋出，但未使用 'try' 標記，並且錯誤未被處理
syntax.error.operator.can.throw.not.marked.with.try=可能拋出運算符，但表達式未使用 'try' 進行標記
syntax.error.property.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=屬性存取可以拋出，但在非拋出自動閉包中執行
syntax.error.property.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=屬性存取可以拋出，但未使用 'try' 標記，並且在非拋出自動閉包中執行
syntax.error.property.can.throw.in.default.argument=屬性存取可以拋出，但無法從預設實參拋出錯誤
syntax.error.property.can.throw.in.property.initializer=屬性存取可以拋出，但無法從屬性初始設定式拋出錯誤
syntax.error.property.can.throw.not.marked.with.try=屬性存取可以拋出，但未使用 'try' 標記
syntax.error.property.can.throw.not.marked.with.try.not.exhaustive=屬性存取可以拋出，但未使用 'try' 標記，並且封閉 catch 不詳盡
syntax.error.property.can.throw.not.marked.with.try.not.handled=屬性存取可以拋出，但未使用 'try' 標記，並且錯誤未被處理
syntax.error.property.rethrows.function.can.only.throw.parameter.call.not.handled=屬性存取可以拋出，但錯誤未被處理；宣告 'rethrows' 的函式只能在其參數拋出時拋出
syntax.error.property.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=屬性存取可以拋出，但未使用 'try' 標記，錯誤未被處理；宣告 'rethrows' 的函式只能在其參數拋出時拋出
syntax.error.rethrows.function.can.only.throw.parameter.call=宣告 'rethrows' 的函式只能在其參數拋出時拋出
syntax.error.rethrows.function.must.take.a.throwing.function.argument='rethrows' 函式必須包含 throwing 函式實參
syntax.error.rethrows.is.not.allowed.in.closures=閉包中不允許 'rethrows'
syntax.error.rethrows.is.not.allowed.in.function.type.elements=只有函式宣告可以標記為 'rethrows'
syntax.error.rethrows.is.not.allowed.in.subscripts=下標中不允許 'rethrows'
syntax.error.subscript.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=下標存取可以拋出，但在非拋出自動閉包中執行
syntax.error.subscript.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=下標存取可以拋出，但未使用 'try' 標記，並且在非拋出自動閉包中執行
syntax.error.subscript.can.throw.in.default.argument=下標存取可以拋出，但無法從預設實參拋出錯誤
syntax.error.subscript.can.throw.in.property.initializer=下標存取可以拋出，但無法從屬性初始設定式拋出錯誤
syntax.error.subscript.can.throw.not.marked.with.try=下標存取可以拋出，但未使用 'try' 標記
syntax.error.subscript.can.throw.not.marked.with.try.not.exhaustive=下標存取可以拋出，但未使用 'try' 標記，並且封閉 catch 不詳盡
syntax.error.subscript.can.throw.not.marked.with.try.not.handled=下標存取可以拋出，但未使用 'try' 標記，並且錯誤未被處理
syntax.error.subscript.rethrows.function.can.only.throw.parameter.call.not.handled=下標存取可以拋出，但錯誤未被處理；宣告 'rethrows' 的函式只能在其參數拋出時拋出
syntax.error.subscript.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=下標存取可以拋出，但未使用 'try' 標記，錯誤未被處理；宣告 'rethrows' 的函式只能在其參數拋出時拋出
syntax.error.thrown.expression.type.0.does.not.conform.to.ErrorType=已拋出的表達式類型 ''{0}'' 不符合 ''{1}''
syntax.error.throws.is.not.allowed.in.subscripts=下標中不允許 'throws'
syntax.error.try.cannot.appear.to.the.right='try' 不能出現在非賦值運算符右側
syntax.error.try.cannot.appear.to.the.right.fix=向左移動 'try'
syntax.error.typealias.without.assignment=類型別名宣告缺少賦值
syntax.error.unrecognized.platform.name.0=無法識別的平台名稱 ''{0}''
syntax.error.variable.declaration.with.multiple.variables.cannot.have.explicit.getters.setters=具有多個變數的 'var' 宣告不能具有顯式 getter/setter
syntax.error.variable.declaration.with.multiple.variables.cannot.have.implicit.getter.clause=具有多個變數的 'var' 宣告不能具有隱式 getter 子句
syntax.error.variable.declaration.with.multiple.variables.cannot.have.willset.didset.clause=具有多個變數的 'var' 宣告不能具有 willSet/didSet 子句
usage.type.argument.label=實參標籤
usage.type.conditionally.not.compiled=有條件的未編譯程式碼中的潛在用法
usage.type.extension=擴展
usage.type.function.declaration=函式宣告
usage.type.key.path=鍵路徑表達式
usage.type.operator.declaration=運算符宣告
usage.type.precedence.group.declaration=優先組宣告
usage.type.raw.value=原始值
usage.type.requirement=要求中的用法
usage.type.type.alias=類型別名
usage.type.type.parameter=類型參數
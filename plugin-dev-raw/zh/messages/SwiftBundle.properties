swift.name=Swift

### formatter #############################################################################################################################

### indent
code.style.indent.group.title.directives=指令

code.style.indent.multiline.strings=縮進多行字符串
code.style.indent.directives.as.code=遵循代碼縮進
code.style.indent.directives.children=縮進子項

### spaces
code.style.spaces.group.title.colon=冒號周圍
code.style.spaces.group.title.in.ternary=在三元條件運算中

code.style.spaces.before.method.parentheses=方法/函數聲明括號
code.style.spaces.after.operator.in.function.declarations=函數聲明中的運算符
code.style.spaces.before.method.call.parentheses=方法/函數調用括號
code.style.spaces.equality.operator=相等運算符 '=='
code.style.spaces.shift.operators=移位運算符(<<, >>)
code.style.spaces.around.range.operators=範圍運算符(..., ..<)
code.style.spaces.closure.arrow=閉包箭頭(->)
code.style.spaces.attribute.parameters=特性形參
code.style.spaces.within.literal.brackets=數組和字典文字中括號
code.style.spaces.within.method.parentheses=方法/函數聲明括號
code.style.spaces.within.empty.method.parentheses=空方法/函數聲明括號
code.style.spaces.within.method.call.parentheses=方法/函數調用括號
code.style.spaces.within.empty.method.call.parentheses=空方法/函數調用括號
code.style.spaces.attribute.parentheses=特性括號
code.style.spaces.before.argument.colon=方法/函數調用中的冒號之前
code.style.spaces.after.argument.colon=方法/函數調用中的冒號之後
code.style.spaces.before.type.colon=類型註解中的冒號之前
code.style.spaces.after.type.colon=類型註解中的冒號之後
code.style.spaces.before.superclass.colon=類型繼承子句中的冒號之前
code.style.spaces.after.superclass.colon=類型繼承子句中的冒號之後
code.style.spaces.before.dictionary.type.colon=字典類型中的冒號之前
code.style.spaces.after.dictionary.type.colon=字典類型中的冒號之後
code.style.spaces.before.dictionary.literal.colon=字典文字 'key:value' 對中的冒號之前
code.style.spaces.after.dictionary.literal.colon=字典文字 'key:value' 對中的冒號之後
code.style.spaces.within.string.interpolations=字符串插值
code.style.spaces.before.class.lbrace=類型聲明左大括號
code.style.spaces.before.method.lbrace=方法/函數左大括號
code.style.spaces.before.semicolon=分號之前
code.style.spaces.after.semicolon=分號之後

### wrapping
code.style.wrapping.group.title.method.parameters=方法/函數聲明參數
code.style.wrapping.group.title.method.arguments=方法/函數調用參數
code.style.wrapping.group.title.closure=閉包
code.style.wrapping.group.title.condition.clauses=條件子句
code.style.wrapping.group.title.if='if' 語句
code.style.wrapping.group.title.guard='guard' 語句
code.style.wrapping.group.title.do.while='repeat … while' 語句
code.style.wrapping.group.title.try='do' 語句
code.style.wrapping.group.title.superclass.list=基類和採用的協議列表
code.style.wrapping.group.title.ternary=三元條件運算
code.style.wrapping.group.title.variable.groups=變量組

code.style.wrapping.align.when.multiline=多行時對齊
code.style.wrapping.align.in.columns=列中對齊
code.style.wrapping.else.on.new.line='else' 在新行
code.style.wrapping.keep.control.statement.in.one.line=控制語句在同一行
code.style.wrapping.keep.simple.methods.in.one.line=方法和函數在同一行
code.style.wrapping.keep.simple.blocks.in.one.line=塊和(尾隨)閉包在同一行
code.style.wrapping.keep.simple.argument.blocks.in.one.line=閉包參數在同一行
code.style.wrapping.structures.in.one.line=空類型聲明在同一行
code.style.wrapping.method.brace.placement=在方法和函數中
code.style.wrapping.array.literal=數組和字典文字
code.style.wrapping.array.new.line.after.left.bracket=在 '[' 後換行
code.style.wrapping.array.right.bracket.on.new.line=將 ']' 置於新行
code.style.wrapping.classes.annotation=類型聲明特性
code.style.wrapping.methods.annotation=方法特性
code.style.wrapping.fields.annotation=屬性特性
code.style.wrapping.parameters.annotation=形參特性
code.style.wrapping.local.variables.annotation=局部變量特性
code.style.wrapping.closure.signature.on.next.line=多行時參數在新行上
code.style.wrapping.brace.placement.class.declaration=在類型聲明中

### blank lines
code.style.blank.lines.around.class=在類型聲明周圍:
code.style.blank.lines.around.field.in.protocol=在協議中的屬性周圍:
code.style.blank.lines.around.field=圍繞屬性:
code.style.blank.lines.around.method.in.protocol=在協議中的方法/函數周圍:
code.style.blank.lines.around.method=在方法/函數周圍:
code.style.blank.lines.before.method.body=在方法/函數體之前:

### code generation
code.style.code.generation.tab.title=代碼生成
code.style.code.generation.prefer.void=首選 Void 而不是 ()(&V)
code.style.code.generation.prefer.explicit.return=首選顯式返回(&R)

### color scheme ##########################################################################################################################

color.settings.keyword=關鍵字和指令//關鍵字
color.settings.property=標識符//屬性
color.settings.colon=大括號和運算符//冒號
color.settings.module.name=類型//模塊名稱
color.settings.protocol=類型//協議
color.settings.class=類型//類
color.settings.actor=類型//Actor
color.settings.type.alias=類型//類型別名
color.settings.struct.and.enum=類型//結構和枚舉
color.settings.operator.sign=大括號和運算符//運算符
color.settings.enum.case.value=標識符//枚舉 case 值
color.settings.self.and.super.keywords=關鍵字和指令//'self' 和 'super'
color.settings.function.and.method.declaration=函數//函數和方法聲明
color.settings.function.and.method.call=函數//函數和方法調用
color.settings.nested.function.declaration=函數//嵌套函數聲明
color.settings.nested.function.call=函數//嵌套函數調用
color.settings.external.parameter.name=標識符//外部形參名稱
color.settings.inline.closure.parameter=標識符//內聯閉包參數
color.settings.anonymous.closure.parameter=標識符//匿名閉包參數
color.settings.wildcard=標識符//通配符
color.settings.type.parameter=類型//泛型形參
color.settings.attribute.name=特性//特性名稱
color.settings.attribute.argument=特性//特性實參
color.settings.inline.hints.type.hint=內聯提示//類型提示
color.settings.inline.hints.error.hint=內聯提示//錯誤提示
color.conditionally.non.compiled=關鍵字和指令//有條件的未編譯代碼
color.settings.directive=關鍵字和指令//指令

### navigation ############################################################################################################################

### goto super
goto.super.action=選擇 {0}
goto.super.menu.action=超級 {0}(_U)
goto.super.location={0} ({1} 內)
goto.super.typealias=類型別名或關聯類型
goto.super.class=類或協議
goto.base.type=基類型

goto.super.extension.of.0={0} 的擴展

### inheritance

inheritance.relation.overrides=重寫 {0}
inheritance.relation.implements=實現 {0}

inheritance.relation.is.implemented=被實現
inheritance.relation.is.subclassed=被子類化
inheritance.relation.is.overridden=被重寫

### find usages
find.usages.base.member.warning.title=警告

find.usages.base.member.warning.message.implements.method={0} 實現 {1} 中聲明的方法\n\n要尋找協議{3,choice,1#方法|2#方法}的用法嗎?
find.usages.base.member.warning.message.implements.subscript={0} 實現 {1} 中聲明的下標\n\n要尋找協議{3,choice,1#下標|2#下標}的用法嗎?
find.usages.base.member.warning.message.implements.property={0} 實現 {1} 中聲明的屬性\n\n要尋找協議{3,choice,1#屬性|2#屬性}的用法嗎?

find.usages.base.member.warning.message.override.method={0} 重寫 {2} 中聲明的方法\n\n要尋找基本{3,choice,1#方法|2#方法}的用法嗎?
find.usages.base.member.warning.message.override.subscript={0} 重寫 {2} 中聲明的下標\n\n要尋找基本{3,choice,1#下標|2#下標}的用法嗎?
find.usages.base.member.warning.message.override.property={0} 重寫 {2} 中聲明的屬性\n\n要尋找基本{3,choice,1#屬性|2#屬性}的用法嗎?

find.usages.base.member.warning.message.override.implemented.method={0} 重寫 {2} 中聲明的方法，並實現 {1} 中聲明的方法\n\n要尋找基本和協議{3,choice,1#方法|2#方法}的用法嗎?
find.usages.base.member.warning.message.override.implemented.subscript={0} 重寫 {2} 中聲明的下標，並實現 {1} 中聲明的下標\n\n要尋找基本和協議{3,choice,1#下標|2#下標}的用法嗎?
find.usages.base.member.warning.message.override.implemented.property={0} 重寫 {2} 中聲明的屬性，並實現 {1} 中聲明的屬性\n\n要尋找基本和協議{3,choice,1#屬性|2#屬性}的用法嗎?

find.usages.base.member.warning.message.default.implementation.method={0} 是對 {1} 中聲明的方法的預設實現\n\n要尋找協議{3, choice,1#方法|2#方法}的用法嗎?
find.usages.base.member.warning.message.default.implementation.subscript={0} 是對 {1} 中聲明的下標的預設實現\n\n要尋找協議{3, choice,1#下標|2#下標}的用法嗎?
find.usages.base.member.warning.message.default.implementation.property={0} 是對 {1} 中聲明的屬性的預設實現\n\n要尋找協議{3, choice,1#屬性|2#屬性}的用法嗎?

### usage kinds
usage.type.type.parameter=類型形參
usage.type.extension=擴展
usage.type.requirement=要求中的用法
usage.type.type.alias=類型別名
usage.type.argument.label=實參標籤
usage.type.key.path=鍵路徑表達式
usage.type.function.declaration=函數聲明
usage.type.operator.declaration=運算符聲明
usage.type.precedence.group.declaration=優先組聲明
usage.type.raw.value=原始值

### call hierarchy
call.hierarchy.usage.in=''{0}'' 中的用法


### Actions ###############################################################################################################################

action.SwiftToggleGlobalTypeHints.text=顯示 Swift 類型提示
action.SwiftToggleTypeHints.text=顯示類型提示
action.SwiftToggleGlobalErrorHints.text=顯示 Swift 錯誤提示
action.SwiftToggleErrorHints.text=顯示錯誤提示
action.SwiftIntroduceClosureVariable.text=提取閉包…
action.SwiftExtractFunction.text=提取函數…
action.SwiftGenerateDocComment.text=生成文檔註釋
action.Swift.Generate.Init.text=初始值設定項
action.Swift.Generate.Init.description=生成初始值設定項
action.Swift.Generate.Description.text=description…
action.Swift.Generate.Description.description=生成描述
action.Swift.Generate.DebugDescription.text=debugDescription…
action.Swift.Generate.DebugDescription.description=生成 debugDescription
action.Swift.Generate.EqualsHashValue.text=equals 和 hash
action.Swift.Generate.EqualsHashValue.description=生成 equals 和 hash

### code generation #######################################################################################################################

### new file dialog
create.file.title=Swift 檔案
create.file.dialog.title=新建 Swift 檔案
create.file.description=創建新的 Swift 檔案
create.file.action=創建 Swift 檔案 {0}

create.file.or.type.title=Swift 檔案/類型
create.file.or.type.description=創建新的 Swift 檔案或類型

create.file.type.title=Swift 類型
create.file.type.dialog.title=新建 Swift 類型
create.file.type.dialog.title.with.kind=新建 Swift {0}
create.file.type.description=創建新的 Swift 類型

create.file.kind=種類(&K):
create.file.kind.file=檔案

### override/implement
override.implement.nothing.to.override=沒有要重寫的內容
override.implement.nothing.to.implement=沒有要實現的內容
override.implement.override.not.allowed=無法重寫
override.implement.implement.not.allowed=無法實現
override.implement.show.members.to.implement.title=顯示要實現的成員
override.implement.elements.to.implement.chooser.title=選擇要實現的成員
override.implement.elements.to.override.chooser.title=選擇要重寫的成員
override.implement.elements.to.override.implement.chooser.title=選擇要重寫/實現的成員

override.implement.progress=正在處理要重寫/實現的成員…
override.implement.show.optional.member=顯示 1 個可選成員(&O)
override.implement.show.optional.members=顯示 {0} 個可選成員(&O)
override.implement.show.no.optional.members=顯示可選成員(無可選項)
override.implement.show.only.optional.members=顯示可選成員(僅可選項)

### generate
generate.init.init.already.exists=初始值設定項已存在
generate.init.choose.super.init=選擇超類初始值設定項
generate.init.choose.properties=選擇要初始化的屬性

generate.0.title=生成 {0}
generate.description.single.string.template=單字符串
generate.description.string.concatenation.template=包含串聯的多個字符串(+)
generate.description.multi.string.template=多行字符串
generate.template.title=模板(&T):

generate.property.0.is.already.defined=已定義屬性 ''{0}''。要將其刪除並繼續嗎?
generate.method.0.is.already.defined=已定義方法 ''{0}''。要將其刪除並繼續嗎?
generate.operator.function.0.is.already.defined=已定義運算符函數 ''{0}''。要將其刪除並繼續嗎?
generate.method.0.and.property.1.are.already.defined=已定義方法 ''{0}'' 和屬性 ''{1}''。要刪除它們並繼續嗎?
generate.method.0.and.operator.function.1.are.already.defined=已定義方法 ''{0}'' 和運算符函數 ''{1}''。要刪除它們並繼續嗎?
generate.property.0.and.operator.function.1.are.already.defined=已定義屬性 ''{0}'' 和運算符函數 ''{1}''。要刪除它們並繼續嗎?
generate.method.0.property.1.and.operator.function.2.are.already.defined=已定義方法 ''{0}''、屬性 ''{1}'' 和運算符函數 ''{2}''。要刪除它們並繼續嗎?

generate.equals.hash=equals 和 hash
generate.equals.hash.choose.in.0=選擇要包含在 {0} 中的屬性
generate.single.expression.equals.template=單表達式
generate.if.statements.equals.template=多個 if 語句

generate.cannot.generate.0.for.1=無法為 {1} 生成 {0}
generate.preparing.generation.title=正在準備生成…

### create from usage
create.from.usage.create.function.command=根據用法創建函數
create.from.usage.create.init.command=根據用法創建初始值設定項
create.from.usage.create.variable.command=根據用法創建變量
create.from.usage.create.type.command=創建新的 Swift 類型

create.from.usage.choose.target.type=選擇目標類型
create.from.usage.location.new.file=新建檔案
create.from.usage.location.this.file=此文件
create.from.usage.location.in=({0} 內)

### SourceKit #############################################################################################################################
sourcekit.fix.it=應用 Fix-it
sourcekit.inspections=SourceKit 檢查

### syntax annotators #####################################################################################################################

syntax.error.hashbang.line.is.allowed.only.in.the.first.line.of.the.main.file=僅在主檔案的第一行中允許 Hashbang 行
syntax.error.hashbang.line.is.allowed.only.in.the.first.line.of.the.file=僅在檔案的第一行中允許 Hashbang 行
syntax.error.hashbang.line.is.allowed.only.in.the.main.file=僅在主檔案中允許 Hashbang 行
syntax.error.unrecognized.platform.name.0=無法識別的平台名稱 ''{0}''
syntax.error.missing.asterisk=必須使用 '*' 處理潛在的未來平台
syntax.error.missing.asterisk.fix=添加 '*'
syntax.error.duplicate.platform=已指定平台 ''{0}''
syntax.error.typealias.without.assignment=類型別名聲明缺少賦值
syntax.error.variable.declaration.with.multiple.variables.cannot.have.explicit.getters.setters=具有多個變量的 'var' 聲明不能具有顯式 getter/setter
syntax.error.variable.declaration.with.multiple.variables.cannot.have.implicit.getter.clause=具有多個變量的 'var' 聲明不能具有隱式 getter 子句
syntax.error.variable.declaration.with.multiple.variables.cannot.have.willset.didset.clause=具有多個變量的 'var' 聲明不能具有 willSet/didSet 子句

### error handling
syntax.error.rethrows.is.not.allowed.in.function.type.elements=只有函數聲明可以標記為 'rethrows'
syntax.error.rethrows.is.not.allowed.in.subscripts=下標中不允許 'rethrows'
syntax.error.rethrows.is.not.allowed.in.closures=閉包中不允許 'rethrows'
syntax.error.rethrows.function.must.take.a.throwing.function.argument='rethrows' 函數必須包含 throwing 函數實參
syntax.error.throws.is.not.allowed.in.subscripts=下標中不允許 'throws'
syntax.error.thrown.expression.type.0.does.not.conform.to.ErrorType=已引發的表達式類型 ''{0}'' 不符合 ''{1}''
syntax.error.try.cannot.appear.to.the.right='try' 不能出現在非賦值運算符右側
syntax.error.try.cannot.appear.to.the.right.fix=向左移動 'try'

syntax.error.call.can.throw.in.property.initializer=調用可以拋出，但無法從屬性初始值設定拋出錯誤
syntax.error.call.can.throw.in.default.argument=調用可以拋出，但無法從預設實參拋出錯誤
syntax.error.call.can.throw.not.marked.with.try=調用可以拋出，但未使用 'try' 標記
syntax.error.call.can.throw.not.marked.with.try.not.handled=調用可以拋出，但未使用 'try' 標記，並且錯誤未被處理
syntax.error.call.can.throw.not.marked.with.try.not.exhaustive=調用可以拋出，但未使用 'try' 標記，並且封閉 catch 不詳盡
syntax.error.call.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=調用可以拋出，但在非拋出自動閉包中執行
syntax.error.call.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=調用可以拋出，但未使用 'try' 標記，並且在非拋出自動閉包中執行
syntax.error.operator.can.throw.not.marked.with.try=可能拋出運算符，但表達式未使用 'try' 進行標記

syntax.error.errors.are.not.handled=從此處引發的錯誤未被處理
syntax.error.errors.are.not.handled.not.exhaustive=從此處引發的錯誤未被處理，因為封閉 catch 不詳盡
syntax.error.error.is.not.handled=錯誤未被處理，因為封閉函數未聲明 'throws'
syntax.error.error.is.not.handled.not.exhaustive=錯誤未被處理，因為封閉 catch 不詳盡

syntax.error.rethrows.function.can.only.throw.parameter.call=聲明 'rethrows' 的函數只能在其參數引發時引發

### error handling fixing intentions
intention.mark.the.enclosing.function.as.throws=將 'throws' 添加到函數簽名
intention.add.try.to.expression=添加 'try'
intention.suppress.call.error.with.try=使用 'try!' 禁止此錯誤
intention.surround.with.do.catch=使用 'do/catch' 環繞
intention.add.default.catch.clause=添加預設 'catch' 子句
intention.add.catch.clause=添加 'catch'
intention.replace.rethrows.with.throws=將 'rethrows' 替換為 'throws'

### syntax/logic error fixing intentions
intention.create.new.swift.type.in.a.new.file=在新檔案中新建 Swift 類型
intention.create.new.swift.declaration=創建新的 Swift 聲明

intention.create.kind.{0}.from.usage.{1}=創建 {0} ''{1}''
intention.create.type.from.usage.{0}=創建類型 ''{0}''
intention.create.initializer=創建初始值設定項
intention.create.location.in=(在 ''{0}'' 中)
intention.create.location.in.a.new.file=(在新檔案中)
intention.create.location.in.type=(在 {0} ''{1}'' 中)
intention.create.location.nested.in.type=(嵌套在 {0} ''{1}'' 中)

intention.implement.members.error=類型 {0} 不符合 {1} {2}
intention.implement.members.implement.missing=實現 {0} 個缺少的{0, choice,1#成員|2#成員}

### access control
# suppress inspection "UnusedProperty"
intention.access.control.error.access=無法訪問 {0}: 它在 {2} 中為 {1}
# suppress inspection "UnusedProperty"
intention.access.control.error.access.dynamic=無法訪問 {0}: 動態成員下標在 {2} 中為 {1}
intention.access.control.error.override=無法重寫 {0}: 它在 {2} 中為 {1}
intention.access.control.fix=在 {2} 中使{0} {1}
intention.access.control.remove.setter=從 {0} 移除 {1}

intention.wrong.return.type.error.void=void 函數中有意外的非 void 返回值
intention.wrong.return.type.fix=使 ''{0}'' 返回 ''{1}''

### inspections ###########################################################################################################################

inspection.redundant.attribute=冗餘特性
inspection.redundant.attribute.error=''@{0}'' 冗餘
inspection.redundant.attribute.fix=移除冗餘 ''@{0}''
inspection.redundant.return=冗餘 'return'
inspection.redundant.return.error='return' 冗餘
inspection.redundant.return.fix=移除冗餘 'return'
inspection.unnecessary.argument.list=閉包前的空實參圓括號
inspection.unnecessary.argument.list.error=實參圓括號不必要
inspection.unnecessary.argument.list.fix=移除不必要的實參圓括號
inspection.unnecessary.parentheses=不必要的圓括號
inspection.unnecessary.parentheses.error=圓括號不必要
inspection.unnecessary.parentheses.fix=移除不必要的圓括號
inspection.unnecessary.self=不必要的 'self'
inspection.unnecessary.self.error='self' 不必要
inspection.unnecessary.self.fix=移除不必要的 'self'
inspection.unnecessary.tuple.wrap=不必要的元組換行
inspection.unnecessary.tuple.wrap.error=單元素元組可以替換為類型
inspection.unnecessary.tuple.wrap.fix=將單元素元組替換為類型
inspection.missing.localization=缺少本地化
inspection.missing.localization.all.languages.only=僅報告所有語言中都缺少的本地化

### refactorings ##########################################################################################################################

error.cannot.perform.refactoring=無法執行重構
error.no.expression.found=找不到表達式

### refactoring intentions
intention.replace.if.with.guard=將 'if' 替換為 'guard'
intention.replace.guard.with.if=將 'guard' 替換為 'if'
intention.add.explicit.type=添加顯式類型
intention.remove.explicit.type=移除顯式類型
intention.add.explicit.qualifier=添加顯式限定符
intention.convert.to.multiline.string=轉換為多行字符串文字
intention.convert.to.string=轉換為單行字符串文字
intention.convert.to.decimal=轉換為十進制
intention.convert.to.hex=轉換為十六進制
intention.convert.to.octal=轉換為八進制
intention.convert.to.binary=轉換為二進制
intention.convert.to.trailing.closure=轉換為尾隨閉包
intention.convert.to.closure.argument=轉換為閉包實參
intention.increase.string.escape.level=提高字符串轉義級別
intention.decrease.string.escape.level=降低字符串轉義級別
intention.add.digit.separators=添加數字分隔符
intention.remove.digit.separators=移除數字分隔符
intention.split.into.separate.declarations=拆分為單獨的聲明
intention.split.declaration.and.assignment=拆分為聲明和賦值
intention.join.declaration.and.assignment=聯接聲明和賦值
intention.merge.else.if=合併 'else if'
intention.split.else.if=拆分 'else if'
intention.invert.if.statement=反轉 'if' 語句
intention.demorganslaw=德摩根定律
intention.demorganslaw.format=將 ''{0}'' 替換為 ''{1}''
intention.merge.nested.if=合併嵌套的 'if'
intention.split.nested.if=拆分為嵌套的 if
intention.merge.conditions=合併條件
intention.split.condition=拆分為單獨的條件
intention.negate.comparison=求反比較
intention.negate.comparison.format=將 ''{0}'' 求反為 ''{1}''
intention.flip.binary.expression=翻轉二進制表達式
intention.flip.binary.expression.format=翻轉 ''{0}''
intention.flip.comparison=翻轉比較
intention.flip.comparison.format=將 ''{0}'' 翻轉為 ''{1}''
intention.localize.string=本地化字符串
intention.localize.string.title.case=本地化字符串

### extract method
extract.method.title.method=提取方法
extract.method.title.function=提取函數
extract.method.title.closure=提取閉包
extract.method.error.should.represent.expr.or.statements=所選塊應代表一組語句或表達式
extract.method.error.cannot.determine.expr.type=無法確定所選表達式的類型
extract.method.error.cannot.extract.expr.with.var.declarations=無法從包含變量聲明的表達式中提取
extract.method.error.cannot.determine.function.result.type=無法確定函數結果的類型
extract.method.error.multiple.exit.points=所選代碼段有多個出口點。
extract.method.error.cannot.extract.with.returns=無法提取代碼段內包含返回指令的函數
extract.method.error.cannot.determine.parameters.type=無法確定形參類型
extract.method.error.fragment.should.be.inside.code.block=所選代碼段應在代碼塊內
extract.method.error.result.builder.block=無法提取結果構建器閉包中的函數
extract.method.function.0.will.conflict.with.1.2=函數 ''{0}'' 將與 {1} {2} 衝突
extract.method.method.0.will.conflict.with.1.in.2.3=方法 ''{0}'' 將與{2} ''{3}'' 中的 {1} 衝突
extract.method.at.least.two.parameters.have.name.0=至少兩個形參的名稱為 ''{0}''
extract.method.variable.0.will.no.longer.be.accessible=變量 ''{0}'' 重構後不再可訪問
extract.method.cannot.extract.mutable.value=無法提取可變值
extract.method.0.1.will.be.shadowed.by.2.1={0} ''{1}'' 將被 {2} ''{1}'' 遮蓋

### introduce variable
introduce.variable.declare.with.var=使用 var 聲明(&V)
introduce.variable.specify.type.explicitly=顯式指定類型(&T)
introduce.variable.expression.will.be.ambiguous.without.explicit.type=表達式將不明確，<br/>無顯式類型

### renaming
rename.inheritors=重命名繼承者
rename.inheritors.to=將繼承者重命名為:
rename.inheritor.entity.name=繼承者

rename.init.is.not.supported=不支持重命名 Swift 初始值設定項
rename.self.is.not.supported=不支持重命名自形參
rename.title=Swift 名稱重命名

rename.related.dialog.title=重命名相關聲明
rename.related.dialog.description=將具有以下名稱的相關聲明重命名為:
rename.related.entity.name=相關聲明

rename.containing.file.dialog.title=重命名包含檔案
rename.containing.file.dialog.description=將具有以下名稱的包含檔案重命名為:
rename.containing.file.entity.name=包含檔案

rename.error.message.renaming.swift.member.elements.in.objective.c.code.is.not.supported=不支持在 Objective-C 代碼中重命名 Swift 成員元素
rename.error.title=Swift - 重命名
rename.error.dynamic.called.values=無法重命名動態調用值

### Change signature
change.signature.initializer.will.conflict.with.0.in.1.2=初始值設定項將與 {1} ''{2}'' 中的 {0} 衝突
change.signature.subscript.will.conflict.with.0.in.1.2=下標將與 {1} ''{2}'' 中的 {0} 衝突
change.signature.dialog.title=更改簽名
change.info.return.type.label=返回類型:
change.info.name.label=名稱:
change.info.internal.name.label=內部名稱:
change.info.type.label=類型:
change.info.optional.label=可選:
change.info.default.value.label=默認值:
change.signature.target.not.found=文本光標應位於函數、初始值設定項或下標處
change.signature.processed.elements.header=要更改簽名的元素
change.signature.title=更改簽名
change.signature.0.1.will.no.longer.be.visible.from.overriding.0.in.2.3={0} ''{1}'' 在{2} ''{3}'' 的重寫{0}中將不再可見
change.signature.0.1.with.2.visibility.wont.be.accessible.from.3.4=可見性為“{2}”的{0} ''{1}'' 將無法從{3} ''{4}'' 訪問
change.info.async.throws.label=async/throws:
change.info.throw.kind.label=拋出種類:
change.signature.0.can.throw.but.thrown.errors.are.not.handled=''{0}'' 可以拋出，但是沒有處理拋出的錯誤
change.signature.0.is.async.but.not.awaited=''{0}'' 等待調用，但未被標記為 async

change.info.dialog.invalid.function.name.0=無效函數名稱: ''{0}''
change.info.dialog.invalid.parameter.name.0=無效形參名稱: ''{0}''
change.info.dialog.invalid.parameter.internal.name.0=無效形參內部名稱: ''{0}''
change.info.dialog.no.function.name.specified=未指定函數名稱
change.info.dialog.parameter.after.variadic.should.have.nonempty.name=可變形參後面的形參應為非空名稱
change.info.dialog.rethrows.should.have.throwing.parameter='rethrows' 函數必須有一個拋出函數形參
change.info.default.value.code.comment="默認值 = {0}"

### super declaration refactoring
refactor.base.declaration=重構基本{0,choice,1#聲明|2#聲明}
refactor.only.current.declaration=僅重構當前聲明
refactor.0.overrides.method.of.1={0} 重寫 {1} 的方法
refactor.0.overrides.property.of.1={0} 重寫 {1} 的屬性
refactor.0.overrides.initializer.of.1={0} 重寫 {1} 的初始值設定項
refactor.0.overrides.subscript.of.1={0} 重寫 {1} 的下標
refactor.0.overrides.associated.type.of.1={0} 重寫 {1} 的關聯類型
refactor.0.overrides.declaration.in.1={0} 重寫 {1} 中的聲明
### other #################################################################################################################################

### documentation
doc.comments.enable.markdown=要想文檔註釋格式整潔，請啟用 Markdown 插件

### appearance
editor.appearance.type.hints=顯示 Swift 類型提示
editor.appearance.error.hints=顯示 Swift 錯誤提示

### actions
action.Swift.ShowSwiftIDETest.text=運行 Swift IDE 報告

### template contexts
context.declaration=聲明
context.statement=語句

color.settings.argument.label=標識符//實參標籤
color.settings.tuple.label=標識符//元組標籤
color.settings.tuple.type.label=標識符//元組類型標籤
command.name.extract.function=提取函數
color.settings.directive.condition=關鍵字和指令//指令條件
color.settings.directive.flag=關鍵字和指令//指令標誌
intention.category.swift=Swift
syntax.error.subscript.can.throw.in.property.initializer=下標訪問可以拋出，但無法從屬性初始值設定項拋出錯誤
syntax.error.property.can.throw.in.property.initializer=屬性訪問可以拋出，但無法從屬性初始值設定項拋出錯誤
syntax.error.interpolation.can.throw.in.property.initializer=插值可以拋出，但無法從屬性初始值設定項拋出錯誤
syntax.error.subscript.can.throw.in.default.argument=下標訪問可以拋出，但無法從預設實參拋出錯誤
syntax.error.property.can.throw.in.default.argument=屬性訪問可以拋出，但無法從預設實參拋出錯誤
syntax.error.interpolation.can.throw.in.default.argument=插值可以拋出，但無法從預設實參拋出錯誤
syntax.error.subscript.can.throw.not.marked.with.try=下標訪問可以拋出，但未使用 'try' 標記
syntax.error.property.can.throw.not.marked.with.try=屬性訪問可以拋出，但未使用 'try' 標記
syntax.error.interpolation.can.throw.not.marked.with.try=插值可以拋出，但未使用 'try' 標記
syntax.error.subscript.can.throw.not.marked.with.try.not.handled=下標訪問可以拋出，但未使用 'try' 標記，並且錯誤未被處理
syntax.error.property.can.throw.not.marked.with.try.not.handled=屬性訪問可以拋出，但未使用 'try' 標記，並且錯誤未被處理
syntax.error.interpolation.can.throw.not.marked.with.try.not.handled=插值可以拋出，但未使用 'try' 標記，並且錯誤未被處理
syntax.error.subscript.can.throw.not.marked.with.try.not.exhaustive=下標訪問可以拋出，但未使用 'try' 標記，並且封閉 catch 不詳盡
syntax.error.property.can.throw.not.marked.with.try.not.exhaustive=屬性訪問可以拋出，但未使用 'try' 標記，並且封閉 catch 不詳盡
syntax.error.interpolation.can.throw.not.marked.with.try.not.exhaustive=插值可以拋出，但未使用 'try' 標記，並且封閉 catch 不詳盡
syntax.error.subscript.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=下標訪問可以拋出，但在非拋出自動閉包中執行
syntax.error.property.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=屬性訪問可以拋出，但在非拋出自動閉包中執行
syntax.error.interpolation.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=插值可以拋出，但在非拋出自動閉包中執行
syntax.error.subscript.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=下標訪問可以拋出，但未使用 'try' 標記，並且在非拋出自動閉包中執行
syntax.error.property.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=屬性訪問可以拋出，但未使用 'try' 標記，並且在非拋出自動閉包中執行
syntax.error.interpolation.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=插值可以拋出，但未使用 'try' 標記，並且在非拋出自動閉包中執行
syntax.error.call.rethrows.function.can.only.throw.parameter.call.not.handled=調用可以拋出，但錯誤未被處理；聲明 'rethrows' 的函數只能在其參數拋出時拋出
syntax.error.subscript.rethrows.function.can.only.throw.parameter.call.not.handled=下標訪問可以拋出，但錯誤未被處理；聲明 'rethrows' 的函數只能在其形參拋出時拋出
syntax.error.property.rethrows.function.can.only.throw.parameter.call.not.handled=屬性訪問可以拋出，但錯誤未被處理；聲明 'rethrows' 的函數只能在其形參拋出時拋出
syntax.error.interpolation.rethrows.function.can.only.throw.parameter.call.not.handled=插值可以拋出，但錯誤未被處理；聲明 'rethrows' 的函數只能在其形參拋出時拋出
syntax.error.call.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=調用可以拋出，但未使用 'try' 標記，錯誤未被處理；聲明 'rethrows' 的函數只能在其參數拋出時拋出
syntax.error.subscript.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=下標訪問可以拋出，但未使用 'try' 標記，錯誤未被處理；聲明 'rethrows' 的函數只能在其形參拋出時拋出
syntax.error.property.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=屬性訪問可以拋出，但未使用 'try' 標記，錯誤未被處理；聲明 'rethrows' 的函數只能在其形參拋出時拋出
syntax.error.interpolation.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=插值可以拋出，但未使用 'try' 標記，錯誤未被處理；聲明 'rethrows' 的函數只能在其形參拋出時拋出
searching.for.implementations=正在搜尋實現…
searching.for.subclasses=正在搜尋子類...
searching.for.overriders=正在搜尋覆蓋者…
inspection.missing.doc.comment.parameter.item=不匹配的 doc 註釋和函數簽名
inspection.missing.doc.comment.parameter.item.error=doc 註釋中未描述形參 {0}
inspection.missing.doc.comment.parameter.item.fix=更新 doc 註釋
code.style.wrapping.method.chain.dot.on.new.line='.' 在新行
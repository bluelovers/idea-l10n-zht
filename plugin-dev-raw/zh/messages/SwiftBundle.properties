swift.name=Swift

### formatter #############################################################################################################################

### indent
code.style.indent.group.title.directives=指令

code.style.indent.multiline.strings=縮排多行字串
code.style.indent.directives.as.code=遵循程式碼縮排
code.style.indent.directives.children=縮排子項

### spaces
code.style.spaces.group.title.colon=冒號周圍
code.style.spaces.group.title.in.ternary=在三元條件運算中

code.style.spaces.before.method.parentheses=方法/函數宣告括號
code.style.spaces.after.operator.in.function.declarations=函數宣告中的運算符
code.style.spaces.before.method.call.parentheses=方法/函數調用括號
code.style.spaces.equality.operator=相等運算符 '=='
code.style.spaces.shift.operators=移位運算符(<<, >>)
code.style.spaces.around.range.operators=範圍運算符(..., ..<)
code.style.spaces.closure.arrow=閉包箭頭(->)
code.style.spaces.attribute.parameters=特性參數
code.style.spaces.within.literal.brackets=陣列和字典文字中括號
code.style.spaces.within.method.parentheses=方法/函數宣告括號
code.style.spaces.within.empty.method.parentheses=空方法/函數宣告括號
code.style.spaces.within.method.call.parentheses=方法/函數調用括號
code.style.spaces.within.empty.method.call.parentheses=空方法/函數調用括號
code.style.spaces.attribute.parentheses=特性括號
code.style.spaces.before.argument.colon=方法/函數調用中的冒號之前
code.style.spaces.after.argument.colon=方法/函數調用中的冒號之後
code.style.spaces.before.type.colon=類型註解中的冒號之前
code.style.spaces.after.type.colon=類型註解中的冒號之後
code.style.spaces.before.superclass.colon=類型繼承子句中的冒號之前
code.style.spaces.after.superclass.colon=類型繼承子句中的冒號之後
code.style.spaces.before.dictionary.type.colon=字典類型中的冒號之前
code.style.spaces.after.dictionary.type.colon=字典類型中的冒號之後
code.style.spaces.before.dictionary.literal.colon=字典文字 'key:value' 對中的冒號之前
code.style.spaces.after.dictionary.literal.colon=字典文字 'key:value' 對中的冒號之後
code.style.spaces.within.string.interpolations=字串插值
code.style.spaces.before.class.lbrace=類型宣告左大括號
code.style.spaces.before.method.lbrace=方法/函數左大括號
code.style.spaces.before.semicolon=分號之前
code.style.spaces.after.semicolon=分號之後

### wrapping
code.style.wrapping.group.title.method.parameters=方法/函數宣告參數
code.style.wrapping.group.title.method.arguments=方法/函數調用參數
code.style.wrapping.group.title.closure=閉包
code.style.wrapping.group.title.condition.clauses=條件子句
code.style.wrapping.group.title.if='if' 語句
code.style.wrapping.group.title.guard='guard' 語句
code.style.wrapping.group.title.do.while='repeat … while' 語句
code.style.wrapping.group.title.try='do' 語句
code.style.wrapping.group.title.superclass.list=基類和採用的協議列表
code.style.wrapping.group.title.ternary=三元條件運算
code.style.wrapping.group.title.variable.groups=變數組

code.style.wrapping.align.when.multiline=多行時對齊
code.style.wrapping.align.in.columns=列中對齊
code.style.wrapping.keep.control.statement.in.one.line=控制語句在同一行
code.style.wrapping.keep.simple.methods.in.one.line=方法和函數在同一行
code.style.wrapping.keep.simple.blocks.in.one.line=塊和(尾隨)閉包在同一行
code.style.wrapping.keep.simple.argument.blocks.in.one.line=閉包參數在同一行
code.style.wrapping.structures.in.one.line=空類型宣告在同一行
code.style.wrapping.method.brace.placement=在方法和函數中
code.style.wrapping.array.literal=陣列和字典文字
code.style.wrapping.array.new.line.after.left.bracket=在 '[' 後換行
code.style.wrapping.array.right.bracket.on.new.line=將 ']' 置於新行中
code.style.wrapping.classes.annotation=類型宣告特性
code.style.wrapping.methods.annotation=方法特性
code.style.wrapping.fields.annotation=屬性特性
code.style.wrapping.parameters.annotation=參數特性
code.style.wrapping.local.variables.annotation=局部變數特性
code.style.wrapping.closure.signature.on.next.line=多行時參數在新行中
code.style.wrapping.brace.placement.class.declaration=在類型宣告中

### blank lines
code.style.blank.lines.around.class=在類型宣告周圍:
code.style.blank.lines.around.field.in.protocol=在協議中的屬性周圍:
code.style.blank.lines.around.field=圍繞屬性:
code.style.blank.lines.around.method.in.protocol=在協議中的方法/函數周圍:
code.style.blank.lines.around.method=在方法/函數周圍:
code.style.blank.lines.before.method.body=方法/函數主體之前:

### code generation
code.style.code.generation.tab.title=程式碼生成
code.style.code.generation.prefer.void=首選 Void 而不是 ()(&V)
code.style.code.generation.prefer.explicit.return=首選顯式返回(&R)

### color scheme ##########################################################################################################################

color.settings.keyword=關鍵字和指令//關鍵字
color.settings.property=關鍵字//屬性
color.settings.colon=大括號和運算符//冒號
color.settings.module.name=類型//模組名稱
color.settings.protocol=類型//協議
color.settings.class=類型//類
color.settings.actor=類型//Actor
color.settings.type.alias=類型//類型別名
color.settings.struct.and.enum=類型//結構和枚舉
color.settings.operator.sign=大括號和運算符//運算符
color.settings.enum.case.value=關鍵字//枚舉 case 值
color.settings.self.and.super.keywords=關鍵字和指令//'self' 和 'super'
color.settings.function.and.method.declaration=函數//函數和方法宣告
color.settings.function.and.method.call=函數//函數和方法調用
color.settings.nested.function.declaration=函數//嵌套函數宣告
color.settings.nested.function.call=函數//嵌套函數調用
color.settings.external.parameter.name=關鍵字//外部參數名稱
color.settings.inline.closure.parameter=關鍵字//內聯閉包參數
color.settings.anonymous.closure.parameter=關鍵字//匿名閉包參數
color.settings.wildcard=關鍵字//萬用字元
color.settings.type.parameter=類型//泛型參數
color.settings.attribute.name=特性//特性名稱
color.settings.attribute.argument=特性//特性實參
color.settings.inline.hints.type.hint=內聯提示//類型提示
color.settings.inline.hints.error.hint=內聯提示//錯誤提示
color.conditionally.non.compiled=關鍵字和指令//有條件的未編譯程式碼
color.settings.directive=關鍵字和指令//指令

### navigation ############################################################################################################################

### goto super
goto.super.action=選擇 {0}
goto.super.menu.action=超級 {0}(_U)
goto.super.location={0} ({1} 內)
goto.super.typealias=類型別名或關聯類型
goto.super.class=類或協議
goto.base.type=基類型

goto.super.extension.of.0={0} 的擴展

### inheritance

inheritance.relation.overrides=覆寫 {0}
inheritance.relation.implements=實作 {0}

inheritance.relation.is.implemented=被實作
inheritance.relation.is.subclassed=被子類化
inheritance.relation.is.overridden=被覆寫

### find usages
find.usages.base.member.warning.title=警告

find.usages.base.member.warning.message.implements.method={0} 實作 {1} 中宣告的方法\n\n要尋找協議{3,choice,1#方法|2#方法}的用法嗎?
find.usages.base.member.warning.message.implements.subscript={0} 實作 {1} 中宣告的下標\n\n要尋找協議{3,choice,1#下標|2#下標}的用法嗎?
find.usages.base.member.warning.message.implements.property={0} 實作 {1} 中宣告的屬性\n\n要尋找協議{3,choice,1#屬性|2#屬性}的用法嗎?

find.usages.base.member.warning.message.override.method={0} 覆寫 {2} 中宣告的方法\n\n要尋找基本{3,choice,1#方法|2#方法}的用法嗎?
find.usages.base.member.warning.message.override.subscript={0} 覆寫 {2} 中宣告的下標\n\n要尋找基本{3,choice,1#下標|2#下標}的用法嗎?
find.usages.base.member.warning.message.override.property={0} 覆寫 {2} 中宣告的屬性\n\n要尋找基本{3,choice,1#屬性|2#屬性}的用法嗎?

find.usages.base.member.warning.message.override.implemented.method={0} 覆寫 {2} 中宣告的方法，並實作 {1} 中宣告的方法\n\n要尋找基本和協議{3,choice,1#方法|2#方法}的用法嗎?
find.usages.base.member.warning.message.override.implemented.subscript={0} 覆寫 {2} 中宣告的下標，並實作 {1} 中宣告的下標\n\n要尋找基本和協議{3,choice,1#下標|2#下標}的用法嗎?
find.usages.base.member.warning.message.override.implemented.property={0} 覆寫 {2} 中宣告的屬性，並實作 {1} 中宣告的屬性\n\n要尋找基本和協議{3,choice,1#屬性|2#屬性}的用法嗎?

find.usages.base.member.warning.message.default.implementation.method={0} 是對 {1} 中宣告的方法的預設實作\n\n要尋找協議{3, choice,1#方法|2#方法}的用法嗎?
find.usages.base.member.warning.message.default.implementation.subscript={0} 是對 {1} 中宣告的下標的預設實作\n\n要尋找協議{3, choice,1#下標|2#下標}的用法嗎?
find.usages.base.member.warning.message.default.implementation.property={0} 是對 {1} 中宣告的屬性的預設實作\n\n要尋找協議{3, choice,1#屬性|2#屬性}的用法嗎?

### usage kinds
usage.type.type.parameter=類型參數
usage.type.extension=擴展
usage.type.requirement=要求中的用法
usage.type.type.alias=類型別名
usage.type.argument.label=實參標籤
usage.type.key.path=鍵路徑表達式
usage.type.function.declaration=函數宣告
usage.type.operator.declaration=運算符宣告
usage.type.precedence.group.declaration=優先組宣告
usage.type.raw.value=原始值

### call hierarchy
call.hierarchy.usage.in=''{0}'' 中的用法


### Actions ###############################################################################################################################

action.SwiftToggleGlobalTypeHints.text=顯示 Swift 類型提示
action.SwiftToggleTypeHints.text=顯示類型提示
action.SwiftToggleGlobalErrorHints.text=顯示 Swift 錯誤提示
action.SwiftToggleErrorHints.text=顯示錯誤提示
action.SwiftIntroduceClosureVariable.text=提取閉包…
action.SwiftExtractFunction.text=提取函數…
action.SwiftGenerateDocComment.text=生成文檔註釋
action.Swift.Generate.Init.text=初始設定式
action.Swift.Generate.Init.description=生成初始設定式
action.Swift.Generate.Description.text=description…
action.Swift.Generate.Description.description=生成描述
action.Swift.Generate.DebugDescription.text=debugDescription…
action.Swift.Generate.DebugDescription.description=生成 debugDescription
action.Swift.Generate.EqualsHashValue.text=equals 和 hash
action.Swift.Generate.EqualsHashValue.description=生成 equals 和 hash

### code generation #######################################################################################################################

### new file dialog
create.file.title=Swift 檔案
create.file.dialog.title=新建 Swift 檔案
create.file.description=創建新的 Swift 檔案
create.file.action=創建 Swift 檔案 {0}

create.file.or.type.title=Swift 檔案/類型
create.file.or.type.description=創建新的 Swift 檔案或類型

create.file.type.title=Swift 類型
create.file.type.dialog.title=新建 Swift 類型
create.file.type.dialog.title.with.kind=新建 Swift {0}
create.file.type.description=創建新的 Swift 類型

create.file.kind=種類(&K):
create.file.kind.file=檔案

### override/implement
override.implement.nothing.to.override=沒有要覆寫的內容
override.implement.nothing.to.implement=沒有要實作的內容
override.implement.override.not.allowed=無法覆寫
override.implement.implement.not.allowed=無法實作
override.implement.show.members.to.implement.title=顯示要實作的成員
override.implement.elements.to.implement.chooser.title=選擇要實作的成員
override.implement.elements.to.override.chooser.title=選擇要覆寫的成員
override.implement.elements.to.override.implement.chooser.title=選擇要覆寫/實作的成員

override.implement.progress=正在處理要覆寫/實作的成員…
override.implement.show.optional.member=顯示 1 個可選成員(&O)
override.implement.show.optional.members=顯示 {0} 個可選成員(&O)
override.implement.show.no.optional.members=顯示可選成員(無可選項)
override.implement.show.only.optional.members=顯示可選成員(僅可選項)

### generate
generate.init.init.already.exists=初始設定式已存在
generate.init.choose.super.init=選擇超類初始設定式
generate.init.choose.properties=選擇要初始化的屬性

generate.0.title=生成 {0}
generate.description.single.string.template=單字串
generate.description.string.concatenation.template=包含串聯的多個字串(+)
generate.description.multi.string.template=多行字串
generate.template.title=模板(&T):

generate.property.0.is.already.defined=已定義屬性 ''{0}''。要將其刪除並繼續嗎?
generate.method.0.is.already.defined=已定義方法 ''{0}''。要將其刪除並繼續嗎?
generate.operator.function.0.is.already.defined=已定義運算符函數 ''{0}''。要將其刪除並繼續嗎?
generate.method.0.and.property.1.are.already.defined=已定義方法 ''{0}'' 和屬性 ''{1}''。要刪除它們並繼續嗎?
generate.method.0.and.operator.function.1.are.already.defined=已定義方法 ''{0}'' 和運算符函數 ''{1}''。要刪除它們並繼續嗎?
generate.property.0.and.operator.function.1.are.already.defined=已定義屬性 ''{0}'' 和運算符函數 ''{1}''。要刪除它們並繼續嗎?
generate.method.0.property.1.and.operator.function.2.are.already.defined=已定義方法 ''{0}''、屬性 ''{1}'' 和運算符函數 ''{2}''。要刪除它們並繼續嗎?

generate.equals.hash=equals 和 hash
generate.equals.hash.choose.in.0=選擇要包含在 {0} 中的屬性
generate.single.expression.equals.template=單表達式
generate.if.statements.equals.template=多個 if 語句

generate.cannot.generate.0.for.1=無法為 {1} 生成 {0}
generate.preparing.generation.title=正在準備生成…

### create from usage
create.from.usage.create.function.command=根據用法創建函數
create.from.usage.create.init.command=根據用法創建初始設定式
create.from.usage.create.variable.command=根據用法創建變數
create.from.usage.create.type.command=創建新的 Swift 類型

create.from.usage.choose.target.type=選擇目標類型
create.from.usage.location.new.file=新建檔案
create.from.usage.location.this.file=此文件
create.from.usage.location.in=({0} 中)

### SourceKit #############################################################################################################################
sourcekit.fix.it=套用 Fix-it
sourcekit.inspections=SourceKit 檢查

### syntax annotators #####################################################################################################################

syntax.error.hashbang.line.is.allowed.only.in.the.first.line.of.the.main.file=僅在主檔案的第一行中允許 Hashbang 行
syntax.error.hashbang.line.is.allowed.only.in.the.first.line.of.the.file=僅在檔案的第一行中允許 Hashbang 行
syntax.error.hashbang.line.is.allowed.only.in.the.main.file=僅在主檔案中允許 Hashbang 行
syntax.error.unrecognized.platform.name.0=無法識別的平台名稱 ''{0}''
syntax.error.duplicate.platform=已指定平台 ''{0}''
syntax.error.typealias.without.assignment=類型別名宣告缺少賦值
syntax.error.variable.declaration.with.multiple.variables.cannot.have.explicit.getters.setters=具有多個變數的 'var' 宣告不能具有顯式 getter/setter
syntax.error.variable.declaration.with.multiple.variables.cannot.have.implicit.getter.clause=具有多個變數的 'var' 宣告不能具有隱式 getter 子句
syntax.error.variable.declaration.with.multiple.variables.cannot.have.willset.didset.clause=具有多個變數的 'var' 宣告不能具有 willSet/didSet 子句

### error handling
syntax.error.rethrows.is.not.allowed.in.function.type.elements=只有函數宣告可以標記為 'rethrows'
syntax.error.rethrows.is.not.allowed.in.subscripts=下標中不允許 'rethrows'
syntax.error.rethrows.is.not.allowed.in.closures=閉包中不允許 'rethrows'
syntax.error.rethrows.function.must.take.a.throwing.function.argument='rethrows' 函數必須包含 throwing 函數實參
syntax.error.throws.is.not.allowed.in.subscripts=下標中不允許 'throws'
syntax.error.thrown.expression.type.0.does.not.conform.to.ErrorType=已引發的表達式類型 ''{0}'' 不符合 ''{1}''
syntax.error.try.cannot.appear.to.the.right='try' 不能出現在非賦值運算符右側
syntax.error.try.cannot.appear.to.the.right.fix=向左移動 'try'

syntax.error.call.can.throw.in.property.initializer=調用可以拋出，但無法從屬性初始值設定拋出錯誤
syntax.error.call.can.throw.in.default.argument=調用可以拋出，但無法從預設實參拋出錯誤
syntax.error.call.can.throw.not.marked.with.try=調用可以拋出，但未使用 'try' 標記
syntax.error.call.can.throw.not.marked.with.try.not.handled=調用可以拋出，但未使用 'try' 標記，並且錯誤未被處理
syntax.error.call.can.throw.not.marked.with.try.not.exhaustive=調用可以拋出，但未使用 'try' 標記，並且封閉 catch 不詳盡
syntax.error.call.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=調用可以拋出，但在非拋出自動閉包中執行
syntax.error.call.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=調用可以拋出，但未使用 'try' 標記，並且在非拋出自動閉包中執行
syntax.error.operator.can.throw.not.marked.with.try=可能拋出運算符，但表達式未使用 'try' 進行標記

syntax.error.errors.are.not.handled=從此處引發的錯誤未被處理
syntax.error.errors.are.not.handled.not.exhaustive=從此處引發的錯誤未被處理，因為封閉 catch 不詳盡
syntax.error.error.is.not.handled=錯誤未被處理，因為封閉函數未宣告 'throws'
syntax.error.error.is.not.handled.not.exhaustive=錯誤未被處理，因為封閉 catch 不詳盡

syntax.error.rethrows.function.can.only.throw.parameter.call=宣告 'rethrows' 的函數只能在其參數引發時引發

### error handling fixing intentions
intention.mark.the.enclosing.function.as.throws=將 'throws' 添加到函數簽名
intention.add.try.to.expression=將 'try' 添加到表達式
intention.suppress.call.error.with.try=使用 'try!' 禁止此錯誤
intention.surround.with.do.catch=使用 'do/catch' 環繞
intention.add.default.catch.clause=添加預設 'catch' 子句
intention.add.catch.clause=添加 'catch'
intention.replace.rethrows.with.throws=將 'rethrows' 取代為 'throws'

### syntax/logic error fixing intentions
intention.create.new.swift.type.in.a.new.file=在新檔案中新建 Swift 類型
intention.create.new.swift.declaration=創建新的 Swift 宣告

intention.create.kind.{0}.from.usage.{1}=創建 {0} ''{1}''
intention.create.type.from.usage.{0}=創建類型 ''{0}''
intention.create.initializer=創建初始設定式
intention.create.location.in=(在 ''{0}'' 中)
intention.create.location.in.a.new.file=(在新檔案中)
intention.create.location.in.type=(在 {0} ''{1}'' 中)
intention.create.location.nested.in.type=(嵌套在 {0} ''{1}'' 中)

intention.implement.members.error=類型 {0} 不符合 {1} {2}
intention.implement.members.implement.missing=實作 {0} 個缺少的{0, choice,1#成員|2#成員}

### access control
# suppress inspection "UnusedProperty"
intention.access.control.error.access=無法存取 {0}: 它在 {2} 中為 {1}
# suppress inspection "UnusedProperty"
intention.access.control.error.access.dynamic=無法存取 {0}: 動態成員下標在 {2} 中為 {1}
intention.access.control.error.override=無法覆寫 {0}: 它在 {2} 中為 {1}
intention.access.control.fix=在 {2} 中使{0} {1}
intention.access.control.remove.setter=從 {0} 移除 {1}

intention.wrong.return.type.error.void=void 函數中有意外的非 void 返回值
intention.wrong.return.type.fix=使 ''{0}'' 返回 ''{1}''

### inspections ###########################################################################################################################

inspection.redundant.attribute=冗餘特性
inspection.redundant.attribute.error=''@{0}'' 冗餘
inspection.redundant.attribute.fix=移除冗餘 ''@{0}''
inspection.redundant.return=冗餘 'return'
inspection.redundant.return.error='return' 冗餘
inspection.redundant.return.fix=移除冗餘 'return'
inspection.unnecessary.argument.list=閉包前的空實參圓括號
inspection.unnecessary.argument.list.error=實參圓括號不必要
inspection.unnecessary.argument.list.fix=移除不必要的實參圓括號
inspection.unnecessary.parentheses=不必要的圓括號
inspection.unnecessary.parentheses.error=圓括號不必要
inspection.unnecessary.parentheses.fix=移除不必要的圓括號
inspection.unnecessary.self=不必要的 'self'
inspection.unnecessary.self.error='self' 不必要
inspection.unnecessary.self.fix=移除不必要的 'self'
inspection.unnecessary.tuple.wrap=不必要的元組換行
inspection.unnecessary.tuple.wrap.error=單元素元組可被取代為類型
inspection.unnecessary.tuple.wrap.fix=將單元素元組取代為類型
inspection.missing.localization=缺少本地化
inspection.missing.localization.all.languages.only=僅報告所有語言中都缺少的本地化

### refactorings ##########################################################################################################################

error.cannot.perform.refactoring=無法執行重構
error.no.expression.found=找不到表達式

### refactoring intentions
intention.replace.if.with.guard=將 'if' 取代為 'guard'
intention.replace.guard.with.if=將 'guard' 取代為 'if'
intention.add.explicit.type=添加顯式類型
intention.remove.explicit.type=移除顯式類型
intention.add.explicit.qualifier=添加顯式限定符
intention.convert.to.multiline.string=轉換為多行字串文字
intention.convert.to.string=轉換為單行字串文字
intention.convert.to.decimal=轉換為十進制
intention.convert.to.hex=轉換為十六進制
intention.convert.to.octal=轉換為八進制
intention.convert.to.binary=轉換為二進制
intention.convert.to.trailing.closure=轉換為尾隨閉包
intention.convert.to.closure.argument=轉換為閉包實參
intention.increase.string.escape.level=提高字串轉義級別
intention.decrease.string.escape.level=降低字串轉義級別
intention.add.digit.separators=添加數字分隔符
intention.remove.digit.separators=移除數字分隔符
intention.split.into.separate.declarations=拆分為單獨的宣告
intention.split.declaration.and.assignment=拆分為宣告和賦值
intention.join.declaration.and.assignment=聯接宣告和賦值
intention.merge.else.if=合併 'else if'
intention.split.else.if=拆分 'else if'
intention.invert.if.statement=反轉 'if' 語句
intention.merge.nested.if=合併嵌套的 'if'
intention.split.nested.if=拆分為嵌套的 'if'
intention.merge.conditions=合併條件
intention.split.condition=拆分為單獨的條件
intention.negate.comparison=求反比較
intention.negate.comparison.format=將 ''{0}'' 求反為 ''{1}''
intention.flip.binary.expression=翻轉二元表達式
intention.flip.binary.expression.format=翻轉 ''{0}''
intention.flip.comparison=翻轉比較
intention.flip.comparison.format=將 ''{0}'' 翻轉為 ''{1}''
intention.localize.string=本地化字串
intention.localize.string.title.case=本地化字串

### extract method
extract.method.title.method=提取方法
extract.method.title.function=提取函數
extract.method.title.closure=提取閉包
extract.method.error.should.represent.expr.or.statements=所選塊應代表一組語句或表達式
extract.method.error.cannot.determine.expr.type=無法確定所選表達式的類型
extract.method.error.cannot.extract.expr.with.var.declarations=無法從包含變數宣告的表達式中提取
extract.method.error.cannot.determine.function.result.type=無法確定函數結果的類型
extract.method.error.multiple.exit.points=所選程式碼段有多個出口點。
extract.method.error.cannot.extract.with.returns=無法提取程式碼段內包含返回指令的函數
extract.method.error.cannot.determine.parameters.type=無法確定參數類型
extract.method.error.fragment.should.be.inside.code.block=所選程式碼段應在程式碼塊內
extract.method.error.result.builder.block=無法提取結果建置器閉包中的函數
extract.method.function.0.will.conflict.with.1.2=函數 ''{0}'' 將與 {1} {2} 衝突
extract.method.method.0.will.conflict.with.1.in.2.3=方法 ''{0}'' 將與{2} ''{3}'' 中的 {1} 衝突
extract.method.at.least.two.parameters.have.name.0=至少兩個參數的名稱為 ''{0}''
extract.method.variable.0.will.no.longer.be.accessible=變數 ''{0}'' 重構後不再可存取
extract.method.cannot.extract.mutable.value=無法提取可變值
extract.method.0.1.will.be.shadowed.by.2.1={0} ''{1}'' 將被 {2} ''{1}'' 遮蓋

### introduce variable
introduce.variable.declare.with.var=使用 var 宣告(&V)
introduce.variable.specify.type.explicitly=顯式指定類型(&T)
introduce.variable.expression.will.be.ambiguous.without.explicit.type=表達式將不明確，<br/>無顯式類型

### renaming
rename.inheritors=重命名繼承者
rename.inheritors.to=將繼承者重命名為:
rename.inheritor.entity.name=繼承者

rename.init.is.not.supported=不支持重命名 Swift 初始設定式
rename.self.is.not.supported=不支持重命名自參數
rename.title=Swift 名稱重命名

rename.related.dialog.title=重命名相關宣告
rename.related.dialog.description=將具有以下名稱的相關宣告重命名為:
rename.related.entity.name=相關宣告

rename.containing.file.dialog.title=重命名包含檔案
rename.containing.file.dialog.description=將具有以下名稱的包含檔案重命名為:
rename.containing.file.entity.name=Include 檔案

rename.error.message.renaming.swift.member.elements.in.objective.c.code.is.not.supported=不支持在 Objective-C 程式碼中重命名 Swift 成員元素
rename.error.title=Swift - 重命名
rename.error.dynamic.called.values=無法重命名動態調用值

### Change signature
change.signature.initializer.will.conflict.with.0.in.1.2=初始設定式將與 {1} ''{2}'' 中的 {0} 衝突
change.signature.subscript.will.conflict.with.0.in.1.2=下標將與 {1} ''{2}'' 中的 {0} 衝突
change.signature.dialog.title=更改簽名
change.info.return.type.label=返回類型:
change.info.name.label=名稱:
change.info.internal.name.label=內部名稱:
change.info.type.label=類型:
change.info.optional.label=可選:
change.info.default.value.label=預設值:
change.signature.target.not.found=文字游標應位於函數、初始設定式或下標處
change.signature.processed.elements.header=要更改簽名的元素
change.signature.title=更改簽名
change.signature.0.1.will.no.longer.be.visible.from.overriding.0.in.2.3={0} ''{1}'' 在{2} ''{3}'' 的覆寫{0}中將不再可見
change.signature.0.1.with.2.visibility.wont.be.accessible.from.3.4=可見性為“{2}”的{0} ''{1}'' 將無法從{3} ''{4}'' 存取
change.info.async.throws.label=async/throws:
change.signature.0.can.throw.but.thrown.errors.are.not.handled=''{0}'' 可以拋出，但是沒有處理拋出的錯誤
change.signature.0.is.async.but.not.awaited=''{0}'' 等待調用，但未被標記為 async

change.info.dialog.invalid.function.name.0=無效函數名稱: ''{0}''
change.info.dialog.invalid.parameter.name.0=無效參數名稱: ''{0}''
change.info.dialog.invalid.parameter.internal.name.0=無效參數內部名稱: ''{0}''
change.info.dialog.no.function.name.specified=未指定函數名稱
change.info.dialog.parameter.after.variadic.should.have.nonempty.name=可變形參後面的參數應為非空名稱
change.info.dialog.rethrows.should.have.throwing.parameter='rethrows' 函數必須有一個拋出函數參數
change.info.default.value.code.comment="預設值 = {0}"

### super declaration refactoring
refactor.base.declaration=重構基本{0,choice,1#宣告|2#宣告}
refactor.only.current.declaration=僅重構當前宣告
refactor.0.overrides.method.of.1={0} 覆寫 {1} 的方法
refactor.0.overrides.property.of.1={0} 覆寫 {1} 的屬性
refactor.0.overrides.initializer.of.1={0} 覆寫 {1} 的初始設定式
refactor.0.overrides.subscript.of.1={0} 覆寫 {1} 的下標
refactor.0.overrides.associated.type.of.1={0} 覆寫 {1} 的關聯類型
refactor.0.overrides.declaration.in.1={0} 覆寫 {1} 中的宣告
### other #################################################################################################################################

### documentation
doc.comments.enable.markdown=要想文檔註釋格式整潔，請啟用 Markdown 延伸模組

### appearance
editor.appearance.type.hints=顯示 Swift 類型提示
editor.appearance.error.hints=顯示 Swift 錯誤提示

### actions
action.Swift.ShowSwiftIDETest.text=執行 Swift IDE 報告

### template contexts
context.declaration=宣告
context.statement=語句

intention.simplifyifelse.collapse.guard=摺疊 'guard'
intention.simplifyifelse.simplify.guard=簡化 'guard'
intention.simplifyifelse.replace.guard.with.0=將 ''guard'' 取代為 ''{0}''
color.settings.argument.label=關鍵字//實參標籤
color.settings.tuple.label=關鍵字//元組標籤
color.settings.tuple.type.label=關鍵字//元組類型標籤
command.name.extract.function=提取函數
color.settings.directive.condition=關鍵字和指令//指令條件
color.settings.directive.flag=關鍵字和指令//指令標誌
intention.category.swift=Swift
syntax.error.subscript.can.throw.in.property.initializer=下標存取可以拋出，但無法從屬性初始設定式拋出錯誤
syntax.error.property.can.throw.in.property.initializer=屬性存取可以拋出，但無法從屬性初始設定式拋出錯誤
syntax.error.interpolation.can.throw.in.property.initializer=插值可以拋出，但無法從屬性初始設定式拋出錯誤
syntax.error.subscript.can.throw.in.default.argument=下標存取可以拋出，但無法從預設實參拋出錯誤
syntax.error.property.can.throw.in.default.argument=屬性存取可以拋出，但無法從預設實參拋出錯誤
syntax.error.interpolation.can.throw.in.default.argument=插值可以拋出，但無法從預設實參拋出錯誤
syntax.error.subscript.can.throw.not.marked.with.try=下標存取可以拋出，但未使用 'try' 標記
syntax.error.property.can.throw.not.marked.with.try=屬性存取可以拋出，但未使用 'try' 標記
syntax.error.interpolation.can.throw.not.marked.with.try=插值可以拋出，但未使用 'try' 標記
syntax.error.subscript.can.throw.not.marked.with.try.not.handled=下標存取可以拋出，但未使用 'try' 標記，並且錯誤未被處理
syntax.error.property.can.throw.not.marked.with.try.not.handled=屬性存取可以拋出，但未使用 'try' 標記，並且錯誤未被處理
syntax.error.interpolation.can.throw.not.marked.with.try.not.handled=插值可以拋出，但未使用 'try' 標記，並且錯誤未被處理
syntax.error.subscript.can.throw.not.marked.with.try.not.exhaustive=下標存取可以拋出，但未使用 'try' 標記，並且封閉 catch 不詳盡
syntax.error.property.can.throw.not.marked.with.try.not.exhaustive=屬性存取可以拋出，但未使用 'try' 標記，並且封閉 catch 不詳盡
syntax.error.interpolation.can.throw.not.marked.with.try.not.exhaustive=插值可以拋出，但未使用 'try' 標記，並且封閉 catch 不詳盡
syntax.error.subscript.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=下標存取可以拋出，但在非拋出自動閉包中執行
syntax.error.property.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=屬性存取可以拋出，但在非拋出自動閉包中執行
syntax.error.interpolation.can.throw.but.it.is.executed.in.a.non.throwing.autoclosure=插值可以拋出，但在非拋出自動閉包中執行
syntax.error.subscript.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=下標存取可以拋出，但未使用 'try' 標記，並且在非拋出自動閉包中執行
syntax.error.property.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=屬性存取可以拋出，但未使用 'try' 標記，並且在非拋出自動閉包中執行
syntax.error.interpolation.can.throw.but.it.is.not.marked.with.try.and.it.is.executed.in.a.non.throwing.autoclosure=插值可以拋出，但未使用 'try' 標記，並且在非拋出自動閉包中執行
syntax.error.call.rethrows.function.can.only.throw.parameter.call.not.handled=調用可以引發，但錯誤未被處理; 宣告 'rethrows' 的函數只能在其參數引發時引發
syntax.error.subscript.rethrows.function.can.only.throw.parameter.call.not.handled=下標存取可以拋出，但錯誤未被處理；宣告 'rethrows' 的函數只能在其參數拋出時拋出
syntax.error.property.rethrows.function.can.only.throw.parameter.call.not.handled=屬性存取可以拋出，但錯誤未被處理；宣告 'rethrows' 的函數只能在其參數拋出時拋出
syntax.error.interpolation.rethrows.function.can.only.throw.parameter.call.not.handled=插值可以拋出，但錯誤未被處理；宣告 'rethrows' 的函數只能在其參數拋出時拋出
syntax.error.call.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=調用可以引發，但未使用 'try' 標記，錯誤未被處理; 宣告 'rethrows' 的函數只能在其參數引發時引發
syntax.error.subscript.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=下標存取可以拋出，但未使用 'try' 標記，錯誤未被處理；宣告 'rethrows' 的函數只能在其參數拋出時拋出
syntax.error.property.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=屬性存取可以拋出，但未使用 'try' 標記，錯誤未被處理；宣告 'rethrows' 的函數只能在其參數拋出時拋出
syntax.error.interpolation.rethrows.function.can.only.throw.parameter.call.not.marked.with.try.not.handled=插值可以拋出，但未使用 'try' 標記，錯誤未被處理；宣告 'rethrows' 的函數只能在其參數拋出時拋出
searching.for.implementations=正在搜尋實作…
searching.for.subclasses=正在搜尋子類…
searching.for.overriders=正在搜尋覆寫者…
inspection.missing.doc.comment.parameter.item=不符合的 doc 註釋和函數簽名
inspection.missing.doc.comment.parameter.item.error=doc 註釋中未描述參數 {0}
inspection.missing.doc.comment.parameter.item.fix=更新 doc 註釋
intention.unwrap.with.if.let=使用 'if let' 解開
intention.unwrap.with.guard.let=使用 'guard let' 解開
code.style.indent.method.chain=鏈式方法縮排:
syntax.error.iteration.can.throw.not.marked.with.try=迭代可以拋出，但未使用 'try' 標記
syntax.error.iteration.can.throw.not.marked.with.try.not.handled=迭代可以拋出，但未使用 'try' 標記，並且錯誤未被處理
syntax.error.iteration.can.throw.not.marked.with.try.not.exhaustive=迭代可以拋出，但未使用 'try' 標記，並且封閉 catch 不詳盡
intention.add.try.to.iteration=將 'try' 添加到迭代
code.style.wrapping.method.chain.dot.on.new.line='.' 在新行
intention.generate.documentation.comment=添加文檔註釋
color.settings.associated.type=類型//關聯類型
intention.swift.module.info=顯示模組資訊
goto.class.kind=類型
goto.class.kinds.title=類型
code.style.wrapping.guard.else='否則'
code.style.wrapping.guard.else.always=始終換行
code.style.wrapping.guard.else.wrapped=有條件換行
code.style.wrapping.guard.else.never=不換行
intention.simplifyifelse.familyName=簡化 if-else
intention.simplifyifelse.collapse.conditional.expression=摺疊條件表達式
intention.simplifyifelse.collapse.ifelse=摺疊 'if else'
intention.simplifyifelse.simplify=簡化
intention.simplifyifelse.simplify.if.else=簡化 'if else'
intention.simplifyifelse.replace.if.else.with.0=將 ''if else'' 取代為 ''{0}''
notification.group.plugin.errors=Swift 語言服務失敗
intention.extract.conformance.to.extension.familyName=Extract conformance to extension
intention.extract.conformance.to.extension.cannot.extract.class=無法將類繼承 ''{0}'' 提取到擴展
intention.extract.conformance.to.extension.type.must.be.fileprivate=類型必須至少為 fileprivate
intention.extract.conformance.to.extension.type.cannot.be.local=無法在局部範圍中創建擴展
intention.extract.conformance.to.extension.cannot.add.protocol.conformance.to.protocol=協議擴展無法符合其他協議
intention.extract.members.to.extension.familyName=Extract members to extension
intention.extract.member.to.extension.type.must.be.fileprivate=類型必須至少為 fileprivate
intention.extract.member.to.extension.cannot.extract.from.protocol=無法從協議中提取
intention.extract.member.to.extension.type.cannot.be.local=無法在局部範圍中創建擴展
inline.error.unexpected.error=Unexpected error when inlining a function
intention.extract.from.extension.to.type.declaration.familyName=Extract members to type declaration
intention.extract.from.extension.to.type.declaration.original.type.not.found=Original type declaration not found
intention.extract.from.extension.to.type.declaration.original.type.not.in.same.file=Original type declaration is not in the same file
code.style.code.generation.doc.comment.tag.delimiter=List item delimiter
intention.extract.struct.0.to.extension=Extract struct ''{0}'' to extension
intention.extract.class.0.to.extension=Extract class ''{0}'' to extension
intention.extract.enum.0.to.extension=Extract enum ''{0}'' to extension
intention.extract.property.0.to.extension=Extract property ''{0}'' to extension
intention.extract.function.0.to.extension=Extract function ''{0}'' to extension
intention.extract.subscript.to.extension=Extract subscript to extension
intention.extract.initializer.to.extension=Extract initializer to extension
intention.extract.typealias.0.to.extension=Extract typealias ''{0}'' to extension
intention.extract.multiple.members.to.extension=Extract members to extension
inline.function.description=Replaces a function call with its body
intention.demorgans.law=德摩根定律
intention.demorgans.law.format=將 ''{0}'' 取代為 ''{1}''
inline.error.cannot.access.symbol.0=Cannot access symbol {0}
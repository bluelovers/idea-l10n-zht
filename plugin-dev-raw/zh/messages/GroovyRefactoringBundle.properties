introduce.variable.title=引入變數
only.in.groovy.files=此重構僅在 Groovy 檔案中可用
selected.block.should.represent.an.expression=所選塊應該代表一個表達式
refactoring.is.not.supported.in.the.current.context=當前上下文中不支持重構
refactoring.is.not.supported.in.method.parameters=閉包或方法參數中不支持重構
declare.final.checkbox=宣告 final(&F)
press.escape.to.remove.the.highlighting=按 Esc 移除高亮顯示
selected.expression.has.void.type=所選表達式有空隙類型
introduced.variable.conflicts.with.parameter.0=引入的變數與參數 {0} 衝突
introduced.variable.conflicts.with.variable.0=引入的變數與局部變數 {0} 衝突
cannot.find.a.single.definition.to.inline.local.var=無法找到內聯局部變數的單一定義
cannot.find.a.single.definition.to.inline.field=欄位沒有初始設定式
local.variable.is.lvalue=要內聯的變數在賦值中以左值形式出現
inline.local.variable.prompt.0.1=內聯局部變數 ''{0}''?
extract.method.title=提取方法
selected.block.should.represent.a.statement.set=所選塊應代表一組語句或表達式
multiple.output.values=所選程式碼段有多個輸出值
selected.block.contains.invocation.of.another.class.constructor=所選塊包含調用另一個類構造函數
specify.type.label=顯式指定返回類型(&T)
signature.preview.border.title=簽名預覽
method.is.already.defined.in.class=方法 {0} 已在類 {1} 中定義。
method.is.already.defined.in.script=方法 {0} 已在腳本 {1} 中定義。
inline.method.title=內聯方法
inline.method.border.title=內聯
inline.method.label=方法 {0}
all.invocations.and.remove.the.method=內聯所有調用並移除方法(&A)
all.invocations.in.project=內聯專案中的所有調用(&A)
this.invocation.only.and.keep.the.method=僅內聯此調用並保留方法(&T)
refactoring.cannot.be.applied.to.abstract.methods=重構不能應用於 abstract 方法
refactoring.cannot.be.applied.no.sources.attached=無法套用重構: 未附加任何源
refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow=當 return 語句中斷執行流時，不支持重構
refactoring.cannot.be.applied.to.constructors=重構不能應用於構造函數
refactoring.is.not.supported.in.parameter.initializers=參數初始設定式中不支持重構
refactoring.is.available.only.for.method.calls=重構僅適用於方法調用
method.is.not.accessible.form.context.0=不能從調用站點存取內聯方法中使用的方法 {0}
field.is.not.accessible.form.context.0=不能從調用站點存取內聯方法中使用的欄位 {0}
super.reference.is.used=內聯方法中使用的 super 調用在內聯後將無效。
variable.conflicts.with.parameter.0=所選名稱與參數 {0} 衝突
variable.conflicts.with.variable.0=所選名稱與局部變數 {0} 衝突
variable.conflicts.with.field.0=所選名稱與欄位 {0} 衝突
error.wrong.caret.position.method.name=文字游標應置於要重構的方法的名稱處。
method.duplicate=具有簽名 {0} 的方法已在 {1} 中定義
replace.setter.for.property=屬性 ''{0}'' 的預設 setter 將被覆蓋
replace.getter.for.property=屬性 ''{0}'' 的預設 getter 將被覆蓋
name.is.wrong=名稱 ''{0}'' 不正確
return.type.is.wrong=返回類型錯誤
type.for.parameter.is.incorrect=參數 ''{0}'' 的類型不正確
specify.default.value=為參數 ''{0}'' 指定預設值或初始設定式
refactored.method.will.cover.closure.property=重構的方法將覆寫 {1} 中的閉包屬性 ''{0}''
changeSignature.not.throwable.type=類型錯誤: 異常的 ''{0}''，應擴展 java.lang.Throwable
changeSignature.wrong.type.for.exception=類型錯誤: 異常的 ''{0}''
changeSignature.no.type.for.exception=指定異常的類型
no.occurrences.found=未找到符合項
class.does.not.exist.in.the.module=模組中不存在類。要創建嗎?
closure.uses.external.variables=閉包使用外部非常數變數
class.language.is.not.groovy=目標類的語言不是 Groovy
implicit.getter.will.by.overridden.by.method=屬性 {0} 的隱式 getter 將被方法 {1} 覆寫
implicit.setter.will.by.overridden.by.method=屬性 {0} 的隱式 setter 將被方法 {1} 覆寫
usage.will.be.overridden.by.method=用法 {0} 將被方法 {1} 覆寫
target.class.must.not.be.script=目標類不得為腳本
rename.is.not.applicable.to.implicit.elements=無法重命名隱式元素
rename.member=重命名 {0}
rename.property=重命名屬性 ''{0}''
cannot.introduce.field.in.script=範圍內沒有類
cannot.introduce.field.in.interface=無法在接口中引入欄位
expression.contains.errors=表達式包含錯誤
field.0.is.already.defined=欄位 {0} 已定義
access.to.created.field.0.will.be.overridden.by.method.1=對欄位 {0} 的存取將被 {1} 覆寫
final.field.cant.be.initialized.in.cur.method=無法在當前方法中初始化最終欄位
Field.cannot.be.final.because.replaced.variable.has.lhs.usages=所選變數用於寫入
field.cannot.be.initialized.in.field.declaration=無法在宣告中初始化欄位
field.cannot.be.initialized.in.constructor(s)=無法在構造函數中初始化欄位
selected.variable.is.used.for.write=所選變數用於寫入
there.is.no.method.or.closure=沒有包含方法或閉包
remove.parameter.0.no.longer.used=移除不再使用的參數 ''{0}''
convert.to.java.refactoring.name=轉換為 Java
convert.to.java.can.work.only.with.groovy=轉換為 Java 重構僅適用於 Groovy 檔案
files.to.be.converted=要轉換的檔案
converting.files.to.java=正在將檔案轉換為 Java
converting.files.to.static=正在將檔案轉換為 @CompileStatic
intention.converting.to.static=將轉換應用於 @CompileStatic
intention.converting.to.static.family=轉換為 @CompileStatic
rename.groovy.property=重命名 Groovy 屬性(&G)
reference.to.accessor.0.is.used=無法內聯對存取器 <bold>{0}<bold> 的引用。
variable.is.accessed.for.writing=變數 ''{0}'' 被存取以進行寫入
introduce.closure.parameter.elements.header=正在將參數添加到閉包
cannot.process.usage.in.language.{0}=無法處理 {0} 中的用法
you.cannot.pass.as.parameter.0.because.you.remove.1.from.base.method=您無法將 ''{0}'' 作為參數傳遞，因為您從方法中移除了與其關聯的參數 ''{1}''。您應當在參數表中取消選擇“移除不再使用的參數 ''{0}''”或取消選擇參數 ''{1}''。
selected.expression.should.not.be.lvalue=所選表達式不應位於賦值的左側
cannot.inline.0.=無法內聯 {0}
ref.0.will.not.be.resolved.outside.of.current.context=不會在當前上下文範圍外解析引用 ''{0}''
cannot.rename.property.0=無法重命名覆寫方法 <bold>''{1}''</bold> 的屬性 <bold>''{0}''</bold>
cannot.inline.reference.0=無法內聯引用 ''{0}''
cannot.rename.script.class.to.0=無法將腳本類 ''{0}'' 重命名為 ''{1}''
extract.method.dialog.explicit.return.checkbox=使用顯式 return 語句(&X)
inplace.introduce.constant.move.checkbox=移至另一個類(&M)
type.label=類型(&T):
name.label=名稱(&N):
introduce.constant.class.label=對類引入(完全限定名稱)(&C):
replace.all.occurrences.checkbox=取代所有符合項(&A)
initialize.in.label=初始化位置(&I):
initialize.in.border.title=初始化位置
initialize.in.current.method.choice=當前方法(&M)
initialize.in.field.declaration.choice=欄位宣告(&D)
initialize.in.class.constructor.choice=類構造函數(&C)
initialize.in.setup.method.choice=setUp 方法
visibility.border.title=可見性
visibility.private.choice=私有(&V)
visibility.public.choice=public(&B)
visibility.protected.choice=Protected(&O)
visibility.property.choice=屬性(&R)

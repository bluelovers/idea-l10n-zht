action.AnActionButton.description.disable.selected=停用所選項
action.AnActionButton.description.duplicate=重複
action.AnActionButton.description.enable.selected=啟用所選項
action.AnActionButton.description.export=匯出
action.AnActionButton.description.import=匯入
action.AnActionButton.text.disable.selected=停用所選項
action.AnActionButton.text.duplicate=複製
action.AnActionButton.text.enable.selected=啟用所選項
action.AnActionButton.text.export=匯出
action.AnActionButton.text.import=匯入
action.add.field.watchpoint.text=新增欄位觀察點
action.auto.variables.mode=僅顯示執行點附近的變數
action.auto.variables.mode.description=僅顯示執行點附近使用的變數
action.calculate.retained.size.info=''{0}'' 的保留物件醒目提示
action.calculate.retained.size.text=''{0}'' 的保留大小為 {1}，淺層大小為 {2}
action.calculate.retained.size.title=''{0}'' 的保留大小
action.calculate.retained.size.waiting.message=正在計算保留大小…
action.do.not.stop.if.called.from.text=從以下項調用時不要停止\: {0}
action.do.not.stop.in.class.text=不要在類別中停止\: {0}
action.failed=動作失敗
action.freeze.thread.text=凍結
action.hide.text=隱藏
action.interrupt.thread.text=中斷
action.resume.thread.text=恢復
action.stop.only.if.called.from.text=僅當從以下項調用時停止\: {0}
action.stop.only.in.class.text=僅在類別中停止\: {0}
action.stop.only.in.current.object.text=僅在當前物件中停止
action.watch.method.return.value.description=啟用觀察上次執行的方法返回值
action.watches.method.return.value.enable=顯示方法返回值
action.watches.method.return.value.unavailable.reason=目標VM不支持的功能
add.exception.breakpoint.classchooser.title=輸入異常類別
add.field.breakpoint.dialog.classchooser.title=選擇欄位的類別
add.field.breakpoint.dialog.field.chooser.title={0,choice, 0\#類別沒有欄位|1\#選擇欄位}
add.field.breakpoint.dialog.title=新增欄位監視
add.instance.filter.dialog.error.numeric.value.expected=實例 ID 應為 'long' 類型的數值
add.instance.filter.dialog.prompt=輸入實例ID\:
add.instance.filter.dialog.title=新增實例過濾器
add.method.breakpoint=新增方法中斷點
add.stepping.filter=新增步進篩選器
array.filter.node.clear.link=\ 清除
async.stacktraces.configurable.display.name=異步堆疊追蹤
breakpoint.any.exception.display.name=任何異常
breakpoint.properties.panel.option.caller.filter=呼叫方篩選器(&R)\:
breakpoint.properties.panel.option.catch.class.filters=捕捉類別過濾器\:
breakpoint.properties.panel.option.class.filters=類別篩選器(&L)\:
breakpoint.properties.panel.option.instance.filters=實例篩選器(&I)\:
breakpoint.properties.panel.option.pass.count=合格次數(&P)\:
breakpoint.property.name.class.filters=類別篩選器\:
breakpoint.property.name.instance.filters=實例過濾器\:
breakpoint.property.name.pass.count=合格次數\:
breakpoint.variant.text.line=行
breakpoint.variant.text.line.and.lambda=行和 {0,choice,1\#Lambda|2\#Lambda}
breakpoint.variant.text.line.and.lambda.uknown.count=行和 Lambda
button.add=新增
button.copy=複製
button.debugger.settings=偵錯器設定…
button.drop.anyway=不執行
button.execute.finally=執行 finally 塊
button.perform.reload.classes=執行重新載入類別(&R)
button.skip.reload.classes=跳過重新載入類別(&S)
call.tracer=呼叫追蹤器
caller.filters.dialog.title=呼叫方篩選器
cancel.emulation=取消仿真
capture.node.settings.link=\ 設定
checkbox.start.tracing=開始
checkbox.stop.tracing=停止
checkbox.tracing=追蹤
checkbox.tracking.filters=篩選器
class.filters.dialog.exclusion.filters.group=類別排除過濾器
class.filters.dialog.inclusion.filters.group=包含
class.filters.dialog.title=類別過濾器
class.pattern.not.specified=未指定類別模式
collection.history=集合歷史記錄
collection.history.tab.title={0} 的歷史記錄
collection.watchpoint.description=集合觀察點
collection.watchpoints.tab.title=Java 集合觀察點
column.name.hits=命中
column.name.instances=實例
column.name.retained.size=保留大小
column.name.shallow.size=淺層大小
column.name.time.ms=時間(毫秒)
command.name.surround.with.runtime.cast=使用執行時轉換包圍
condition=條件\:
debugger.actions.group.title=偵錯器動作
debugger.attach.group.name.java=Java
debugger.attach.group.name.java.read.only=Java 唯讀
debugger.attach.password.for.sudo=輸入密碼以使用 su 權限連線\: 
debugger.collection.visualizer.title=集合表示
debugger.collection.visualizer.title.0=集合表示\: {0}
debugger.data.views.configurable.show.title=顯示
debugger.jdi.bootstrap.error={0}。請檢查您的 JDK 安裝。
debugger.memory.agent.loading.error=無法將記憶體代理載入到虛擬機
debugger.memory.agent.timeout.error=計算超時(堆過大，記憶體代理無法在合理時間內執行此動作，建議捕獲堆傾印)
debugger.variables.not.available.in.async=變數不適用於異步堆疊框架
default.package.name=<預設>
dialog.title.exception.to.throw=要拋出的異常
dialog.title.return.value=返回值
drop.frame.error.no.information=有關框架的資訊不可用
editor.notification.alternative.source=類別{0}的替代來源
enable.tracking.for.new.instances=啟用新實例的追蹤
error.absent.exception.breakpoint.class.name=沒有異常中斷點的類別名
error.array.renderer.configurable.end.index.less.than.start=結束索引小於開始索引
error.array.renderer.configurable.start.index.less.than.zero=開始索引小於 0
error.breakpoint.file.not.found=檔案 ''{0}'' 未找到; b此檔案的中斷點將被忽略
error.cannot.create.expression.from.code.fragment=無法從程式碼段建立表達式。
error.cannot.load.breakpoint.file=無法載入檔案 ''{0}''; 此檔案的中斷點將被忽略
error.cannot.open.debugger.port=無法開啟偵錯器連接埠
error.class.circularity.error=類別迴圈錯誤\: {0}
error.class.def.not.found=找不到類別定義 \: {0}
error.class.format.error=類別格式錯誤 \: {0}
error.class.not.loaded=未載入類別\: {0}
error.compound.renderer.configurable.fqn.generic=不允許泛型類型
error.context.has.changed=上下文已經改變，動作是不可能的
error.context.not.available=上下文不可用
error.corrupt.debug.info=偵錯資訊可能已損壞\: {0}
error.debug.connector.not.found=找不到所需的連接器 ''{0}''。檢查您的 JDK 安裝。
error.debugger.already.listening=偵錯器已經在偵聽
error.early.return=早期返回時出錯\: {0}
error.evaluating.breakpoint.condition.or.action=處理虛擬機事件的問題\:\n中斷點\: ''{0}''\n錯誤\: {1}\n是否要在中斷點處停止?
error.exception.while.connecting=連線到遠端程序時出錯。\n發生異常\: {0}\n異常訊息\: {1}
error.exception.while.reloading=重新載入類別時出現異常 \: {0} \: {1}
error.executing.finally=執行 finally 塊時出錯\: {0}
error.failed.evaluating.breakpoint.condition=無法對中斷點條件求值\n''{0}''\n原因\: {1}
error.field.breakpoint.class.name.not.specified=無法新增監視點\: 未指定類別名
error.field.breakpoint.class.sources.not.found=無法為 ''{0}.{1}'' 建立欄位觀察點。\n沒有類別 ''{2}'' 的源
error.field.breakpoint.field.name.not.specified=無法新增監視點\: 未指定欄位名稱
error.field.breakpoint.field.not.found=無法為 ''{0}.{1}'' 建立欄位觀察點。\n找不到欄位 ''{2}''
error.field.not.found.in.class={1}中沒有此類別欄位{0}
error.inconsistent.debug.info=不一致的偵錯資訊
error.internal=內部錯誤
error.invalid.argument={0,choice, 1\#無效實參|2\#實參無效} 
error.invalid.breakpoint.method.not.found=在類別{0}未找到方法
error.invalid.breakpoint.missing.field.in.class=在類別 ''{1}'' 中找不到欄位 ''{0}''
error.invalid.breakpoint.no.executable.code=在類別{1}中的行{0}處找不到可執行程式碼
error.invalid.breakpoint.no.line.info=行號資訊在類別{0}不可用
error.invalid.breakpoint.source.changed=原始檔已更改或找到原始檔與中斷點的檔案不對應
error.invalid.breakpoint.source.not.found=在專案類別路徑中找到的類別{0}沒有關聯的原始檔
error.invalid.field.name=欄位名無效 ''{0}''
error.invalid.local.variable.name=無效的區域變數名''{0}''
error.invalid.stackframe=內部異常 - 無效的堆疊幀
error.invalid.type.name=無效的類型名稱''{0}''
error.io.error=I/O 錯誤
error.jdk.not.specified=JDK未指定
error.native.method.exception=所有幀和包括幀都不是原生的
error.no.debug.attach.port=要附加到未指定的連接埠
error.no.debug.listen.port=未指定的監聽連接埠
error.no.debug.process=無偵錯程序
error.no.pid=未指定 Pid
error.no.shmem.address=未指定共享記憶體地址
error.operation.canceled=動作被取消
error.operation.not.supported.by.vm=虛擬機不支持的動作\: {0}
error.pop.bottom.stackframe=無法彈出底部框架
error.pop.stackframe=彈出框架時發生錯誤\: {0}
error.running.to.cursor.no.executable.code={0}沒有可執行程式碼\:{1}
error.text.invalid.port=未指定連接埠
error.throw.exception=拋出異常時出錯\: {0}
error.unable.to.create.sapidattachingconnector=無法建立 SAPIDAttachingConnector
error.unable.to.evaluate.capture.expression=無法對捕獲鍵表達式求值\: {0}
error.unable.to.evaluate.children.expression=無法對子呈現器表達式求值
error.unable.to.evaluate.expression=無法對表達式求值
error.unable.to.evaluate.insert.expression=無法對插入鍵表達式求值\: {0}
error.unknown.host=無法連線到遠端程序。主機未知
error.unknown.host.with.address=無法連線到遠端程序。主機未知({0})
error.unsupported.class.version=不支持的類別版本 \: {0}
error.verification.error=驗證錯誤 \: {0}
error.vm.disconnected=VM斷開連線. 目標虛擬機關閉連線
evaluation.error.anonymous.class.evaluation.not.supported=不支持匿名類別求值
evaluation.error.array.collected=已收集陣列
evaluation.error.array.dimention.numeric.value.expected=數字值應為數組維度
evaluation.error.array.reference.expected=應為陣列參照
evaluation.error.array.type.expected=應為陣列類型
evaluation.error.boolean.condition.expected=條件中應為 'boolean' 值
evaluation.error.boolean.expected=應為布林值
evaluation.error.boolean.value.expected.in.condition=條件中預估值為'boolean'
evaluation.error.cannot.cast.boolean=不能將布爾轉換為''{0}''
evaluation.error.cannot.cast.char=不能將字元轉換為''{0}''
evaluation.error.cannot.cast.null=不能將null轉換為''{0}''
evaluation.error.cannot.cast.numeric=不能將數字轉換為''{0}''
evaluation.error.cannot.cast.object=不能轉換''{0}''為''{1}''
evaluation.error.cannot.evaluate.array.initializer=無法對陣列初始設定式求值
evaluation.error.cannot.evaluate.class.type=無法對類別類型求值
evaluation.error.cannot.evaluate.qualifier=無法對限定符 ''{0}'' 求值
evaluation.error.cannot.evaluate.tostring=無法對 {0}.toString() 求值
evaluation.error.cannot.find.source=找不到 {0} 的源類別
evaluation.error.cannot.find.stackframe.source=找不到當前堆疊幀的源類別
evaluation.error.cannot.initialize.array=無法初始化陣列
evaluation.error.cannot.resolve.constructor=無法解析建構函式 ''{0}''
evaluation.error.cannot.resolve.field.class=無法解析包含欄位''{0}''
evaluation.error.cannot.set.primitive.to.null=無法將基元類型設定為 null
evaluation.error.cannot.sources.for.field.class=找不到包含欄位''{0}''的類別的源
evaluation.error.class.not.loaded=類別''{0}''未載入
evaluation.error.class.or.array.expected=在對欄位 ''{0}'' 求值時應為類別或陣列類型
evaluation.error.debug.info.unavailable=偵錯資訊不可用
evaluation.error.during.indexing=索引編制期間無法求值
evaluation.error.empty.code.fragment=應為程式碼段
evaluation.error.evaluating.field=對欄位求值時出錯\: ''{0}''
evaluation.error.evaluating.method=對方法求值時出錯\: ''{0}''
evaluation.error.exception.collected=<Cause unknown as the exception has been collected>
evaluation.error.expression.info=無法提取表達式
evaluation.error.identifier.expected=預期的關鍵字不是''{0}''
evaluation.error.incompatible.array.initializer.type=初始設定式類型與陣列的組件類型不相容
evaluation.error.incompatible.types=''{0}''動作不相容的類型
evaluation.error.incompatible.variable.initializer.type=''{0}'' 的初始設定式具有不相容的類型
evaluation.error.inconsistent.debug.info=偵錯資訊不一致
evaluation.error.integer.expected=應為整數值
evaluation.error.invalid.array.dimension.expression=陣列維度無效的表達式\: {0}
evaluation.error.invalid.array.size=陣列大小無效
evaluation.error.invalid.expression=無效的表達式 \: {0}
evaluation.error.invalid.index.expression=索引表達式無效
evaluation.error.invalid.this.expression=不能取代''{1}''的''{0}''為''this''
evaluation.error.invalid.type.name=類型名稱無效\: ''{0}''
evaluation.error.lambda.evaluation.not.supported=不支持 Lambda 求值
evaluation.error.lebeled.loops.not.found=沒有標記為''{0}''為迴圈語句
evaluation.error.local.variable.declarations.not.supported=區域變數宣告不受支援。
evaluation.error.local.variable.missing=找不到區域變數''{0}''
evaluation.error.local.variable.missing.from.class.closure=在閉包類別中找不到區域變數''{0}''
evaluation.error.method.exception=方法拋出 ''{0}'' 異常。
evaluation.error.method.reference.evaluation.not.supported=不支持方法參照求值
evaluation.error.multi.dimensional.arrays.creation.not.supported=不支持建立多維陣列
evaluation.error.nested.evaluation=在對另一個方法求值期間不支持求值
evaluation.error.no.instance.field=沒有此類別實例欄位\: ''{0}''
evaluation.error.no.instance.method=沒有此類別實例方法\: ''{0}''
evaluation.error.no.stackframe=無法求值\: 堆疊幀不可用
evaluation.error.no.static.field=沒有此類別 static 欄位\: ''{0}''
evaluation.error.no.static.method=沒有此類別 static 方法\: ''{0}''
evaluation.error.not.lvalue=分配的左邊部分不是一個值
evaluation.error.not.rvalue=分配的右邊部分不是一個值
evaluation.error.numeric.expected=應為數值
evaluation.error.object.collected=已搜集物件
evaluation.error.object.is.being.initialized=物件正在初始化
evaluation.error.object.reference.expected=應為物件參照
evaluation.error.operation.not.supported=動作''{0}''不支持
evaluation.error.process.exited=無法求值\: 程序離開
evaluation.error.signature.polymorphic.call.evaluation.not.supported=不支持簽名多態呼叫評估
evaluation.error.sources.out.of.sync=源碼與執行的程式碼不對應
evaluation.error.stack.frame.unavailable=堆疊幀不可用
evaluation.error.statement.not.supported=語句 ''{0}'' 不受支援
evaluation.error.surrounded.expression.null=包圍的表達式為 null
evaluation.error.this.not.avalilable='this'是不可用的
evaluation.error.thread.collected=已收集執行緒
evaluation.error.thread.not.at.breakpoint=“暫停程序”後無法對表達式求值。請考慮使用中斷點掛起程序。
evaluation.error.thread.resumed=執行緒已被恢復
evaluation.error.type.mismatch=類型不符合
evaluation.error.unknown.expression.operand=表達式動作數未知\: {0}
evaluation.error.unknown.expression.type=表達式類型未知\: {0}
evaluation.error.unknown.method.return.type=無法解析方法返回值類型\: {0}
evaluation.error.unknown.type=無法解析類型\: {0}
evaluation.error.unsupported.declaration=宣告無效 \: {0} 僅支援區域變數宣告。
evaluation.error.unsupported.expression.type=不支持的表達式類型
evaluation.error.variable.already.declared=變數''{0}''已被宣告
evaluation.error.variable.not.declared=變數''{0}''未宣告
evaluation.warning.cannot.evaluate.on.pause=執行已暫停，無法求值
exception=異常
exception.breakpoint.console.message={1}({2})處發生異常 ''{0}''
exception.breakpoint.console.message.location.info={0}\:{1,number,\#}
exception.breakpoint.console.message.location.info.absent=沒有偵錯資訊
exception.breakpoint.console.message.with.thread.info={2}({3})處的執行緒 ''{1}'' 中發生異常 ''{0}''
exception.breakpoint.description.any=任何異常中斷點
exception.breakpoint.description.with.type={0} 的異常中斷點
exception.breakpoints.tab.title=Java異常中斷點
export.failed=匯出失敗
export.selected.capture.points.to.file=將所選捕獲點匯出到檔案…
field.watchpoint.description=欄位觀察點
field.watchpoint.property.name.access=監視存取\:
field.watchpoint.property.name.modification=監視修改\:
field.watchpoints.tab.title=Java欄位監視點
filters=篩選器…
filters.not.configured=未組態篩選器
frame.panel.async.stacktrace=異步堆疊追蹤
frame.panel.computing.frame=正在計算幀…
frame.panel.frames.not.available=幀不可用於未掛起的執行緒
frame.panel.thread.finished=執行緒已結束執行
hotswap.dialog.hang.warning=JVM 當前已被暫停。\n使用有效的第三方 JVM 代理重新載入類別可能會導致 JVM 掛起。
hotswap.dialog.reload.action.text=重新載入
hotswap.dialog.run.prompt=某些類別已被更改。立即重新載入更改的類別?
hotswap.dialog.title=重新載入已更改的類別
hotswap.dialog.title.with.session=重新載入已更改的類別 {0}
if.the.value.is.referenced.by.a.constant.field=如果該值由抽象類別的常數欄位參照，IDEA 可以使用參照欄位的名稱來另外標記從此類別參照的所有值。
import.capture.points=匯入捕獲點
instance.filters.dialog.title=實例過濾器
instances.window.show.history=InstancesWindow.ShowHistory
internal.debugger.error=內部錯誤。有關詳細資訊，請參閱日誌
internal.error.locations.of.line=從 ''{0}'' 載入偵錯資訊時發生內部錯誤。中斷點在此類別中將不可用。
invoke.completion.once.more=再次呼叫補全以檢視執行時類型變數
label.add.field.breakpoint.dialog.field.name=欄位名稱\:
label.add.field.breakpoint.dialog.fq.name=類別的完全限定名稱\:
label.add.wildcard.breakpoint.dialog.class.pattern=類別模式(&C)\:
label.add.wildcard.breakpoint.dialog.method.name=方法名稱(&M)\:
label.array.renderer.configurable.end.index=結束索引 (&D)\:
label.array.renderer.configurable.max.count1=顯示最大值 (&M)
label.array.renderer.configurable.max.count2=陣列元素
label.array.renderer.configurable.start.index=陣列開始索引 (&R)\:
label.arrays.could.not.be.tracked=無法追蹤陣列
label.base.renderer.configurable.all.overriding=對於覆蓋'toString()'方法的所有類別
label.base.renderer.configurable.alternate.view=啟用集合類別的替代檢視 (&E)
label.base.renderer.configurable.autoscroll=自動定位到新的區域變數 (&L)
label.base.renderer.configurable.classes.from.list=對於列表中的類別\:
label.base.renderer.configurable.dfa.assist=基於數據流分析預測條件值和異常
label.base.renderer.configurable.dfa.assist.gray.out=將預計不可到達的程式碼塊變灰
label.base.renderer.configurable.enable.toString=啟用 't&oString()' 物件檢視 (&O)\:
label.base.renderer.configurable.hide.null.array.elements=在陣列和集合中隱藏 null 元素(&N)
label.base.renderer.configurable.populate.throwable.stack=自動填充可拋出物件的堆疊追蹤
label.base.renderer.configurable.show.declared.type=已宣告類型 (&T)
label.base.renderer.configurable.show.fq.names=完全限定名稱 (&Q)
label.base.renderer.configurable.show.hex.value=顯示基元的十六進制值
label.base.renderer.configurable.show.object.id=物件ID (&I)
label.base.renderer.configurable.show.static.fields=static 欄位(&S)
label.base.renderer.configurable.show.static.final.fields=static final 欄位(&F)
label.base.renderer.configurable.show.strings.type=顯示字串的類型
label.base.renderer.configurable.show.synthetic.fields=合成欄位 (&Y)
label.base.renderer.configurable.show.val.fields.as.locals=$val 欄位作為區域變數(&V)
label.capture.configurable.annotations.configure=組態註解…
label.capture.configurable.capture.variables=捕獲區域變數 (可能會大大減慢執行速度)
label.capture.configurable.debugger.agent=檢測代理 (需要偵錯器重啟)
label.capture.point.at={0}.{1} 的捕獲點
label.collection.breakpoint.properties.save.history=儲存集合歷史記錄
label.compound.renderer.configurable.append.default.children=追加預設子項
label.compound.renderer.configurable.apply.to=將呈現器應用於以下類型的物件(完全限定名稱)\:
label.compound.renderer.configurable.ondemand=按需
label.compound.renderer.configurable.show.type=顯示類型和物件id
label.compound.renderer.configurable.table.header.expression=表達式
label.compound.renderer.configurable.table.header.name=名稱
label.compound.renderer.configurable.table.header.ondemand=按需
label.compound.renderer.configurable.test.can.expand=測試一個節點是否可以擴展 (可選)\:
label.compound.renderer.configurable.use.default.renderer=使用預設呈現器
label.compound.renderer.configurable.use.expression=使用以下表達式\:
label.compound.renderer.configurable.use.expression.list=使用表達式列表\:
label.compound.renderer.configurable.when.expanding=展開節點時
label.compound.renderer.configurable.when.rendering=呈現節點時
label.debugger.general.configurable.always.debug=開始使用偵錯代理執行組態
label.debugger.general.configurable.always.smart.step.into=始終進行智能步入(&L)
label.debugger.general.configurable.enable.memory.agent=附加記憶體代理
label.debugger.general.configurable.enable.memory.agent.tooltip.text=Java 偵錯器將提供有關堆中物件的其他資訊
label.debugger.general.configurable.evaluate.finally.always=總是(&A)
label.debugger.general.configurable.evaluate.finally.ask=詢問(&K)
label.debugger.general.configurable.evaluate.finally.never=從不(&E)
label.debugger.general.configurable.evaluate.finally.on.pop=對彈出幀和早期返回值上的 finally 塊求值\:
label.debugger.general.configurable.hide.stack.frames.using.step.filter=使用步進篩選器隱藏堆疊幀(&F)
label.debugger.general.configurable.kill.immediately=立即停止偵錯程序
label.debugger.general.configurable.resume.only.current.thread=只恢復當前執行緒
label.debugger.general.configurable.show.alternative.source=顯示替代源切換器
label.debugger.general.configurable.skip.classLoaders=跳過載入器 (&O)
label.debugger.general.configurable.skip.constructors=跳過建構函式 (&C)
label.debugger.general.configurable.skip.simple.getters=跳過簡單的getter (&G)
label.debugger.general.configurable.skip.synthetic.methods=跳過合成方法 (&P)
label.debugger.general.configurable.step.filters.list.header=不要進入類別 (&I)
label.debugger.hotswap.configurable.always=總是(&A)
label.debugger.hotswap.configurable.ask=詢問 (&K)
label.debugger.hotswap.configurable.compile.before.hotswap=在重新載入類別之前建置專案
label.debugger.hotswap.configurable.enable.vm.hang.warning=啟用 'JVM將掛起' 警告
label.debugger.hotswap.configurable.never=從不 (&N)
label.debugger.hotswap.configurable.reload.classes=編譯後重新載入類別\:
label.debugger.hotswap.configurable.suggest.in.editor=修改程式碼時在編輯器中建議使用熱交換
label.debugger.launching.configurable.debugger.transport=傳輸\:
label.debugger.launching.configurable.shmem=共享記憶體(&M)
label.debugger.launching.configurable.socket=&Socket 
label.exception.breakpoint.properties.panel.caught.exception=捕獲異常 (&N)
label.exception.breakpoint.properties.panel.group.notifications=通知
label.exception.breakpoint.properties.panel.uncaught.exception=未捕獲的異常 (&O)
label.field.breakpoint.properties.panel.field.access=欄位存取(&S)
label.field.breakpoint.properties.panel.field.modification=欄位修改(&M)
label.generic.debugger.parameters.patcher.configurable.port=連接埠\:
label.generic.debugger.parameters.patcher.configurable.shmem=Shared &memory ()
label.generic.debugger.parameters.patcher.configurable.shmem.address=共享記憶體地址\:
label.generic.debugger.parameters.patcher.configurable.socket=套接字(&S)
label.generic.debugger.parameters.patcher.configurable.transport=傳輸\:
label.group.watch.events=監視
label.instrumentation.tracker=插樁追蹤器\: {0}
label.method.breakpoint.properties.panel.emulated=仿真 (&U)
label.method.breakpoint.properties.panel.method.entry=方法輸入 (&Y)
label.method.breakpoint.properties.panel.method.exit=方法離開 (&X)
label.method.breakpoints.processing.classes=處理仿真方法中斷點的類別
label.method.breakpoints.setting.breakpoints=設定仿真方法中斷點
label.object.markup.dialog.mark.referenced=標記從常數欄位參照的值(&M)
label.thread.group.node=執行緒組 "{0}"@{1}
label.thread.group.node.group.collected=執行緒組“{0}”已被垃圾回收
label.thread.node="{0}"@{1}\: {2}
label.thread.node.in.group="{0}"@{1} 在組“{3}”\: {2}
label.thread.node.thread.collected=執行緒 ''{0}'' 已被垃圾回收
label.threads.view.configurable.current.thread.on.top=將當前執行緒移至頂部
label.threads.view.configurable.show.class.name=顯示類別名
label.threads.view.configurable.show.line.number=顯示行號 (&L)
label.threads.view.configurable.show.package=顯示軟體套件名稱
label.threads.view.configurable.show.prams.types=顯示方法實參類型
label.threads.view.configurable.show.source.file.name=顯示原始檔名
label.threads.view.configurable.show.stack.frames.for.synthetic.methods=顯示合成方法的堆疊幀(&F)
label.threads.view.configurable.show.thread.groups=顯示執行緒組 (&G)
label.too.many.frames.rest.truncated=幀過多，其餘幀將被截斷…
label.undefined=未定義
label.unknown.value=<未知>
label.user.renderers.configurable.renderer.name=呈現器名稱\:
line.breakpoint.description.basic.line=行中斷點
line.breakpoint.description.conditional.return=返回中斷點
line.breakpoint.description.lambda=Lambda 中斷點
line.breakpoint.display.name=行 {0,number,\#}
line.breakpoint.display.name.with.class.or.method=行 {0,number,\#} 在 {1}
line.breakpoint.display.name.with.column=行 {0,number,\#} 列 {1,number,\#}
line.breakpoint.display.name.with.column.and.class.or.method={2} 中的行 {0,number,\#} 列 {1,number,\#}
line.breakpoints.tab.title=Java行中斷點
memory.toolwindow.title=記憶體
memory.view.constructor.tracker.name=MemoryViewConstructorTracker\: {0}
message.breakpoint.skipped.during.evaluation=已跳過 {0} 處的中斷點，因為它發生在偵錯器評估內
message.breakpoint.skipped.during.stepping.in.another.thread=由於步入另一個執行緒，已跳過 {0} 處的中斷點
message.breakpoint.skipped.learn.more=故障排查指南
message.breakpoint.skipped.other.vm=已跳過 {0} 處的中斷點，因為它發生在當前 JVM 外部
message.conditional.return.breakpoint.on.android=Android 上尚不支持條件返回的中斷點，將設定一般行中斷點。
message.node.all.array.elements.null=範圍({0}, {1})的所有元素都為 null
message.node.all.elements.null=所有元素都為 null
message.node.array.elements.more=+ 其他 {0} 個
message.node.class.has.no.fields=類別沒有欄位
message.node.class.no.fields.to.display=沒有欄位顯示
message.node.debug.info.not.available=偵錯資訊不可用
message.node.elements.null.hidden=不顯示 null 元素
message.node.empty.array=空
message.node.evaluate=…求值
message.node.evaluation.not.possible=目標虛擬機未被中斷點請求暫停。在這種模式下無法對方法求值
message.node.filtered=已過濾用\:
message.node.local.variables.capture.disabled=區域變數未被捕獲，您可以在以下位置更改\:
message.node.local.variables.debug.info.not.available=變數偵錯資訊不可用
message.node.local.variables.not.captured=區域變數未被捕獲用於合成、橋接等方法
message.node.navigate=… 導覽
message.node.object.collected=物件在方法呼叫期間已被垃圾回收
message.node.open=…開啟
message.node.show.icon=… 顯示圖示
message.node.show.image=… 顯示圖片
message.node.thread.has.no.frames=執行緒沒有幀
message.node.thread.running=執行緒正在執行
message.node.toString=… toString()
message.other.threads.reached.breakpoints={0,choice,1\#另一個執行緒也到達了中斷點|2\#其他 {0} 個執行緒也到達了中斷點}
message.remote.jre.version.mismatch=目標 JRE 版本({0})與專案 JDK 版本不符合({1})，將使用 JDK 中的原始碼\: {2}
method.breakpoint.description=方法中斷點
method.breakpoint.property.name.emulated=模擬\:
method.breakpoint.property.name.watch.entry=監視條目\:
method.breakpoint.property.name.watch.exit=監視離開\:
method.breakpoints.slowness.warning=方法中斷點可能會大大減慢偵錯速度
method.breakpoints.tab.title=Java方法中斷點
method.name.not.specified=未指定方法名稱
notification.group.hotswap=熱交換已執行
notification.method.has.not.been.called=尚未呼叫方法 <b>{0}()</b>
overhead.toolwindow.title=開銷
paths.to.closest.gc.roots.for={0} 距離 GC 根最近的路徑
please.select.a.file.to.import=請選擇要匯入的檔案。
process.attach.run.configuration.type.name=附加到程序
progress.evaluating=正在對 {0} 求值
progress.hot.swap.title=熱交換
progress.hotswap.reloading=正在重新載入類別…
progress.hotswap.scanning.classes=正在掃描要重新載入的類別…
progress.hotswap.scanning.path=掃描\: {0}
progress.suffix.filtering.has.been.interrupted=(篩選已中斷)
progress.suffix.limit.has.been.reached=(已達到限制)
progress.text.errors.count=錯誤\: {0}
progress.text.shown.x.of.y=已顯示\: {0} / {1}
ref=Ref
renderer.name={0} 呈現器
rule.name.group.by.class=按類別分組
rule.name.group.by.package=按軟體套件分組
select.stack.frame=選擇堆疊幀
settings.async.annotations.configuration=異步註解組態
settings.async.execute=異步執行
settings.async.schedule=異步排程
settings.breakpoints.based=基於中斷點\:
settings.capture.column.capture.class.name=捕獲類別名
settings.capture.column.capture.key.expression=捕獲鍵表達式
settings.capture.column.capture.method.name=捕獲方法名稱
settings.capture.column.insert.class.name=插入類別名
settings.capture.column.insert.key.expression=插入鍵表達式
settings.capture.column.insert.method.name=插入方法名稱
status.app.running=應用程式正在執行
status.app.stepping=正在步入應用程式
status.breakpoint.invalid=無效
status.breakpoint.reached.in.thread=到達執行緒 {0} 中的中斷點
status.breakpoint.reached.in.thread.switch=<a href\="\#">切換執行緒</a>
status.classes.not.all.versions.reloaded=對於 {0} 個{1,choice, 1\#類別|2\#類別}(共 {1} 個)，未重新載入所有版本
status.classes.reloaded={0,number} 個{0,choice, 0\#類別|1\#類別|2\#類別}重新載入
status.connect.failed=無法建立與地址為 ''{0}'' 的目標虛擬機的連線
status.connected=已連線到地址為 ''{0}'' 的目標虛擬機
status.connecting=正在連線到地址為 ''{0}'' 的目標虛擬機
status.debug.stopped=偵錯已停止
status.disconnected=已與地址為 ''{0}'' 的目標虛擬機斷開連線
status.field.watchpoint.reached.access='{'{0}@{5}'}'.{1}將在存取{2}({3}\:{4,number,\#})
status.field.watchpoint.reached.modification='{'{0}@{7}'}'.{1} 將在 {4}({5}\:{6,number,\#})下修改。當前值 \= ''{2}''。新值 \= ''{3}''
status.generic.breakpoint.reached=已到達中斷點
status.hot.swap.completed.restart=重新啟動會話
status.hot.swap.completed.stop=停止會話
status.hot.swap.completed.with.errors=熱交換失敗
status.hot.swap.completed.with.warnings=熱交換已完成，但存在警告
status.hotswap.loaded.classes.up.to.date=已載入類別是最新的. 不需要重新載入
status.hotswap.uptodate=已載入的類別處於最新狀態。無需重新載入任何內容。
status.invalid.breakpoint.out.of.class=中斷點不屬於任何類別
status.line.breakpoint.reached=到達 {0}({1}\:{2,number,\#}) 的中斷點
status.line.breakpoint.reached.full.trace=已到達中斷點
status.listening=正在偵聽連線，地址\: {0}
status.method.entry.breakpoint.reached=方法''{0}''進入{1}({2}\:{3,number,\#})
status.method.exit.breakpoint.reached=已達到方法中斷點. 方法''{0}''即將離開{1}({2}\:{3,number,\#})
status.paused=已暫停
status.paused.in.another.thread=在另一個執行緒中暫停
status.process.resumed=恢復程序
status.process.started=程序已啟動
status.process.terminated=程序已終止
status.run.to.cursor=執行到游標
status.run.to.cursor.in=執行至 {0} 中的游標
status.static.field.watchpoint.reached.access={0}.{1} 將在 {2}({3}\:{4,number,\#})下存取
status.static.field.watchpoint.reached.modification={0}.{1} 將在 {4}({5}\:{6,number,\#})下修改。當前值 \= ''{2}''。新值 \= ''{3}''
status.step.into=步入
status.step.out=步出
status.step.over=步過
status.stepping.in=正在步入 {0}
status.stopped.at.cursor=在游標停止
status.text.no.stack.frame.for.this.instance=該實例沒有堆疊幀
status.text.select.instance.to.see.stack.frame=選擇實例以檢視堆疊幀
status.thread.blocked.by=執行緒{0}被執行緒{1}組織
status.thread.blocked.by.resume=<a href\="\#">恢復{0}</a>
status.thread.monitor=監視器
status.thread.not.started=未啟動
status.thread.running=正在執行
status.thread.sleeping=正在休眠
status.thread.undefined=未定義
status.thread.unknown=未知
status.thread.wait=等待
status.thread.zombie=僵停
status.waiting.attach=偵錯器正在等待應用程式啟動
status.waiting.attach.address=偵錯地址\: {0}
status.waiting.evaluation.result=等待直到最後一個偵錯器指令完成
stepping.filter.real.thread.name=執行緒 {0}
string.connection=''{0}''，傳輸\: ''{1}''
string.file.line.position={0}中的類別\:{1}
string.null.context=上下文為null
surround.with.runtime.type.template=((RuntimeType)expr)
text.user.renderers.configurable.no.renderers=沒有呈現器
thread.dump.coroutines.name=協程
thread.dump.during.previous.dump.evaluation.warning=之前傾印的評估仍在進行中。已獲取 Java 平台執行緒傾印。
thread.dump.progress.message=正在傾印 {0}…
thread.dump.unavailable.title=擴展傾印不可用
thread.dump.virtual.threads.name=Java 虛擬執行緒
thread.operation.interrupt.is.not.supported.by.vm=虛擬機不支持執行緒動作 'interrupt'
threads.view.configurable.display.name=自訂執行緒檢視
title.compound.renderer.configurable.choose.renderer.reference.type=呈現器參照類型
title.customize.data.views=自訂資料檢視
title.error.evaluating.breakpoint.action=中斷點動作錯誤
title.error.evaluating.breakpoint.condition=中斷點條件錯誤
title.evaluating=正在評估…
title.jdk140.unstable=VM版本警告
title.range.too.big=範圍太大了
title.set.value=設定值
title.smart.step.popup=進入的方法
tracing.class.filters=追蹤類別篩選器
transport.name.shared.memory=共享記憶體
transport.name.socket=套接字
user.renderers.configurable.button.description.copy=拷貝選擇的呈現器
user.renderers.configurable.display.name=Java類型呈現器
waiting.for.debugger.response=等待程序正常完成
warning.0=警告\! {0}
warning.filtering.may.have.side.effects=警告\: 篩選可能有副作用
warning.finally.block.detected=檢測到非空 finally 塊\:
warning.jdk140.unstable=被偵錯程序的虛擬機版本為 "1.4.0"。\nJ2SDK 1.4.0 記錄的 bug 可能會導致不穩定的偵錯器行為。\n我們建議使用 J2SDK 1.4.0_01 或更高版本。
warning.range.too.big=指定範圍太大. {0} 需要太多的資源才能執行請求的動作. 你確定你要繼續嗎?
warning.recalculate=將重新計算該值
warning.source.code.not.match=源碼與位元組碼不符合

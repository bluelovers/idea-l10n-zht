message.category.error=錯誤
message.category.warning=警告
message.category.information=資訊
message.category.statistics=統計
error.javac.out.of.memory=記憶體不足. 在 專案屬性|編譯器 設定中增加最大堆大小.
progress.loading.classes=載入類...
progress.compiling.class=編譯 {0}...
progress.parsing.file=解析 {0}...
action.compile.description.module=模組 ''{0}''
action.compile.description.selected.files=所選檔案
rebuild.lvcs.label.no.errors=''{0}''沒有錯誤
rebuild.lvcs.label.with.errors=''{0}''沒有錯誤
action.make.selected.modules.text=建置選定的模組 (_M)
message.resource.patterns.format.changed=資源模式的格式發生變化.\n\
{0} 無法轉換現有的正則表達式模式:\n\
{1}\n\
請以新格式輸入模式字串.\n\
每個資源模式可能包含以下萬用字元:\n\
? - 一個字符\n\
* - 零或更多的字符\n\
! - 否定模式 (僅在模式開始時允許)\\u4F7F用 ; (分號) 分隔資源模式;\n\
避免 "!" 帶有反斜杠 ("\")的字符.\n\
您可能還需要修改模板專案設定.\\u6309''{2}''接受輸入的模式, ''{3}''將預設模式載入新格式.
pattern.conversion.dialog.title=模式轉換
error.bad.resource.patterns=以下資源模式格式錯誤:{0}
bad.resource.patterns.dialog.title=格式不正確的資源模式
compiler.results.export.text.prefix=行 ({0})
status.compilation.aborted=編譯中止
status.all.up.to.date=所有檔案都處於最新狀態
compiler.error.failed.to.delete=無法刪除 {0}
compiler.build.messages.classes.check.uptodate=建置結果對請求的編譯範圍來說處於最新狀態。\n\
後續增量建置將不會執行任何操作。
compiler.build.messages.classes.check.outdated=建置結果對請求的編譯範圍來說已過時。\n\
後續增量建置將為更改的源編譯檔案，並移除先前建置的過時結果。
progress.updating.caches=更新快取...
compiler.content.name.rebuild=重新建置
compiler.content.name.recompile=重新編譯
compiler.content.name.make=建置
modules.classpath.title=依賴
status.compilation.completed.successfully.with.warnings=成功編譯完成{1}中 {0} {0,choice, 0#個警告|1#個警告|2#個警告}
status.compilation.completed.successfully=建置在 {0} 中成功完成
status.compilation.completed.successfully.with.warnings.and.errors=編譯完成{2}中 {0} {0,choice, 0#個錯誤|1#個錯誤|2#個錯誤} 和 {1} {1,choice, 0#個警告|1#個警告|2#個警告}
progress.executing.precompile.tasks=執行預編譯任務...
progress.executing.postcompile.tasks=執行後編譯任務...
error.chunk.modules.must.have.same.jdk=以下模組必須具有相同的JDK分配, 因為它們之間的迴圈依賴關係:\n\
{0}\n\
請更新模組設定
error.chunk.modules.must.have.same.language.level=以下模組必須具有相同的語言級別,因為它們之間存在迴圈依賴關係:\n\
{0}\n\
請更新模組設定
action.compiler.properties.text=編譯器屬性
actions.exclude.from.compile.text=從編譯中排除
java.compiler.description=Java編譯器
rmi.compiler.description=RMI編譯器
error.jdk.not.specified=沒有為{0,choice, 1#模組|2#模組} {1} 指定 SDK
error.jdk.module.names.overflow.element.ellipsis=…
dialog.message.error.jdk.not.specified.with.fixSuggestion=沒有為 {0} {1,choice, 1#模組|2#模組}指定 SDK，或其 SDK 已損壞。自動解析以下 SDK?
dialog.message.error.jdk.not.specified.with.noFix=需要手動設定:
dialog.message.action.apply.fix=自動修復
error.output.not.specified=沒有為{0,choice, 1#模組|2#模組} {1} 指定輸出路徑
compiler.javac.name=Javac
compiler.configurable.display.name=編譯器
label.option.clear.output.directory.on.rebuild=在重新建置時清除輸出目錄 (&L)
label.option.resource.patterns.text=資源模式:
error.compiler.configurable.malformed.patterns=以下資源模式格式錯誤:\n\
{0}
exclude.from.compile.table.path.column.name=路徑
exclude.from.compile.table.recursively.column.name=遞歸
no.excludes=不排除
option.use.compiler.text=使用編譯器:
java.compiler.option.additional.command.line.parameters=附加命令行參數:
java.compiler.option.generate.no.warnings=不生成警告
java.compiler.option.generate.debugging.info=生成偵錯資訊
java.compiler.option.report.deprecated=報告使用棄用的功能
javac.options.group.title=Javac 選項
rmic.option.generate.iiop.stubs=生成IIOP存根
rmic.option.enable.rmi.stubs=啟用RMI存根生成
compiler.running.dialog.title=編譯器執行中
warning.compiler.running.on.toolwindow.close=編譯器正在執行. 終止它?
add.notnull.assertions=為非空註釋的方法和參數,添加執行時斷言 (&A)

compiler.eclipse.name=Eclipse
eclipse.options.group.title=Eclipse 選項

#artifacts
packaging.element.text.output.root=<輸出根>
label.text.main.class=主類 (&M):
label.text.class.path=類路徑 (&P):
element.type.name.artifact=工件
dialog.title.choose.artifacts=選擇 Artifacts
node.text.0.directory.content=''{0}'' 目錄內容
element.type.name.library.files=庫檔案
node.text.0.compile.output=''{0}'' 編譯輸出
node.text.0.test.compile.output=''{0}'' 測試編譯輸出
node.text.0.module.sources=''{0}'' 源
element.type.name.module.source=模組源
element.type.name.module.output=模組輸出
element.type.name.module.test.output=模組測試輸出
element.type.name.directory=目錄
element.type.name.archive=檔案
artifact.type.plain=其他
build.artifacts.before.run.description.empty=編譯 Artifacts
build.artifacts.before.run.description.single=編譯 ''{0}'' artifact
build.artifacts.before.run.description.multiple=編譯 {0} artifacts
build.artifacts.before.run.selector.title=編譯 Artifacts

message.text.error.copying.file.to.file=拷貝檔案 ''{0}'' 到 ''{1}''錯誤.
message.text.xml.file.invalid=XML檔案 ''{0}'' 無效
mesage.text.deployment.descriptor.file.not.exist=部署描述符檔案 ''{0}'' 不存在
message.text.deployment.description.invalid.file=無效檔案
warning.text.file.has.been.changed=檔案在編譯期間已更改, 跳過檢查驗證

dialog.message.compilation.of.unloaded.modules.failed=專案中有未載入的模組取決於更改的檔案。<br>這些模組的編譯已完成，但出現錯誤。
dialog.title.compilation.failed=編譯失敗
button.text.checkin.handler.commit=提交 (&C)
button.text.checkin.handler.show.errors=展示錯誤 (&S)
checkbox.text.compile.affected.unloaded.modules=編譯受影響的已移除模組 (&U)

#artifacts
dialog.title.output.directory.for.artifact=Artifact輸出目錄
chooser.description.select.output.directory.for.0.artifact=選擇''{0}'' artifact的輸出目錄

#package file action
action.name.package.file=打包檔案
action.description.package.file=更新對應工件中的檔案
message.tect.package.file.io.error=IO異常:\n\
{0}
status.text.file.has.been.packaged={0, choice, 1#檔案|2#檔案} {1} {0, choice, 1#已|2#已}在 {2} 打包。
action.name.package.files=打包檔案

# validation
validation.display.name=驗證
action.name.exclude.from.validation=從驗證中排除
no.validators=沒有驗證器可用
label.option.autoshow.first.error=在編輯器中自動顯示錯誤 (&E)
label.option.display.notification.popup=在建置完成時顯示通知

java.compiler.option.prefer.target.jdk.compiler=盡可能使用模組目標JDK的編譯器
configurable.CompilerUIConfigurable.display.name=一般
configurable.AnnotationProcessorsConfigurable.display.name=註解處理器
settings.configure.annotations=設定註解(&C)…
settings.build.project.automatically=自動建置專案
settings.actions.on.save.page.build.project.on.save.checkbox=建置專案
settings.actions.on.save.page.build.project.on.save.checkbox.comment=執行/偵錯時未觸發
settings.actions.on.save.page.compiler.settings.link=編譯器設定…
settings.compile.independent.modules.in.parallel=並行編譯獨立模組
settings.rebuild.module.on.dependency.change=依賴關係更改時重新建置模組
settings.build.process.heap.size=共享建置行程堆大小(MB):
settings.user.local.build.process.heap.size=使用者本地建置行程堆大小(MB)(覆寫共享大小):
settings.shared.build.process.vm.options=共享建置過程 VM 選項:
settings.user.local.build.process.vm.options=使用者本地建置過程 VM 選項 (覆寫共享選項):
settings.auto.build.only.works.while.not.running=(僅在不執行/不偵錯時工作)
settings.parallel.module.compile.may.require.larger.heap.size=(可能需要更大的堆)
settings.warning=<html>警告!<br>如果已啟用選項“重新建置時清除輸出目錄”，存儲生成源的目錄的全部內容將在重新建置時清除。</html>
settings.use.release.option.for.cross.compilation=使用 '--release' 選項進行交叉編譯 (Java 9 及更高版本)
settings.project.bytecode.version=專案字節碼版本:
settings.per.module.bytecode.version=按模組字節碼版本:
settings.same.as.language.level=與語言級別相同
settings.all.modules.will.be.compiled.with.project.bytecode.version=所有模組都將使用專案字節碼版本進行編譯
settings.module.column=模組
settings.target.bytecode.version=目標字節碼版本
settings.recommended.in.paths=(建議在路徑中使用 '/' 進行跨平台設定)
settings.override.compiler.parameters.per.module=按模組覆寫編譯器參數:
settings.override.module.column=模組
settings.override.compilation.options.column=編譯選項
settings.additional.compilation.options=其他編譯選項也同樣適用於所有模組
settings.enable.annotation.processing=啟用註解處理
settings.annotation.processing.proc.only=在編譯 java(-proc:only 模式)之前，在單獨的步驟中執行處理器 
settings.obtain.processors.from.project.classpath=從專案類路徑獲取處理器
settings.processor.path=處理器路徑:
settings.use.processor.module.path.compiler.option.for.java.9.and.later=使用 --processor-module-path 編譯器選項 (適用於 Java 9 及更高版本)
settings.module.content.root=模組內容根
settings.module.output.directory=模組輸出目錄
settings.annotation.processors=註解處理器:
settings.compiler.will.run.all.automatically.discovered.processors=編譯器將執行所有自動發現的處理器
settings.annotation.processor.options=註解處理器選項:
settings.no.processor.specific.options.configured=未設定處理器特定選項
settings.module.path.warning=假設指定的路徑是 'module path': JAR 或包含打包 java 模組的路徑。\n\
要確保被發現並從模組路徑執行，註解處理器應打包為 java 模組並使用模組宣告中的 ServiceLoader 註冊。
settings.store.generated.sources.relative.to=存儲相對於下列位置生成的源:
settings.production.sources.directory=生產源目錄:
settings.column.option.name=選項名稱
settings.column.value=值
settings.test.sources.directory=測試源目錄:
settings.processor.fq.name=處理器 FQ 名稱
settings.validate.on.build=建置時驗證
settings.exclude.from.validation=從驗證中排除:
settings.validators=驗證器:
no.compilation.problems.found=未找到編譯問題
cannot.package.file=無法打包檔案
packaging.files=正在打包檔案
only.works.while.not.running.debugging=(僅在不執行/不偵錯時工作)
disabled.in.power.save.mode=(在省電模式下禁用)
path.to.ecj.compiler.tool=ecj 編譯器工具的路徑
choose.members=選擇成員
all.modules=<所有模組>
create.jar.from.modules=從模組創建 JAR
cannot.delete.0=無法刪除 ''{0}''
cannot.clean.0.artifact=無法清理 ''{0}'' 工件
cleaning.artifacts=正在清理工件
clean.artifacts=清理工件
0.errors.1.warnings={0} 個錯誤，{1} 個警告
compilation.finished=編譯已完成
meta.inf.manifest.mf.file.not.found.in.0=在 ''{0}'' 中未找到 META-INF/MANIFEST.MF 檔案
0.manifest.properties=''{0}'' 清單屬性:
specify.path.to.manifest.mf.file=指定 MANIFEST.MF 檔案的路徑
edit.classpath=編輯類路徑
synchronizing.output.directories=正在同步輸出目錄…
button.rebuild=重新建置
confirm.project.rebuild=確認專案重新建置
you.are.about.to.rebuild.the.whole.project=您將重新建置整個專案。\n\
執行“建置專案”?
class.can.have.more.common.super.class=類可以擁有更常見的超類
cannot.create.directory.0.1=無法創建目錄 ''{0}'': {1}
select.directory.for.meta.inf.manifest.mf.file=為 META-INF/MANIFEST.MF 檔案選擇目錄
title.new.archive=新建歸檔
enter.archive.name=輸入歸檔名稱:
action.text.move.to=移至
title.create.new.profile=創建新的設定檔案
dialog.message.profile.name=設定文件名稱
title.new.directory=新建目錄
dialog.message.enter.directory.name=輸入目錄名稱:
dialog.title.packaging.choose.module=選擇模組
dialog.title.packaging.choose.library=選擇庫
node.excluded.flag.tooltip=排除
macro.output.path=輸出路徑
button.add=添加(&A)…
eclipse.compiler.cross.platform.help.message=(建議在路徑中使用 '/' 進行跨平台設定)
eclipse.compiler.path.leave.empty.help.message=ECJ 批處理編譯器工具的路徑(若留空，則使用捆綁路徑):
eclipse.compiler.proceed.on.errors.option=遇到錯誤時繼續
progress.title.cancelling.auto.make.builds=正在取消自動生成建置
abnormal.build.process.termination=建置行程終止異常
wsl.network.connection.failure=無法建立從 WSL 到 Windows 主機的網絡連接(可能被防火牆阻止)。\n\
要了解詳細資訊，請參閱: https://jb.gg/wsl-firewall
unknown.build.process.error=未知錯誤
intention.name.make.implements=生成實作 ''{0}''
intention.name.make.extends=生成擴展 ''{0}''
classes.up.to.date.check=類最新狀態檢查

action.run.all.affected.tests.text=執行所有受影響的測試
popup.title.affected.tests.counts=已在{2}{3, choice, 0#類|1#類}中為 {4} 找到 {0} 個{1, choice, 0#測試|1#測試}

popup.title.chosen.artifact.action={0,choice,0#{0} 工件|1#|2# {0} 工件}的操作
dialog.message.output.dir.contains.source.roots=''{1}'' 工件的輸出目錄 ''{0}'' 包含專案的源根。是否繼續並將其清除?
dialog.message.output.dir.artifact= ''{0}'' 工件(''{1}'')
dialog.message.output.dirs.contain.source.roots=以下工件的輸出目錄包含源根:\n\
{0}是否繼續並清除這些目錄?
action.compiler.reference.find.usages.text=編譯器引用尋找用法
action.compiler.reference.functional.expression.search.text=編譯器引用函數表達式搜尋
action.compiler.reference.direct.inheritor.search.text=編譯器引用直接繼承者搜尋
progress.text.clearing.build.system.data=正在清除建置系統資料…
separator.choose.members.to.delete=<html>選擇已在 <b>{0}</b> 中定義的成員將其刪除
text.empty.profile=設定文件名稱不應為空
text.profile.exists=設定檔案 {0} 已存在
compiler.ui.pattern.legend.text=使用 <b>;</b> 分隔模式，使用 <b>!</b> 求反模式。已接受萬用字元: <b>?</b> \\&mdash; 僅一個符號；<b>*</b> \\&mdash; 無或更多符號；<b>/</b> \\&mdash; 路徑分隔符；<b>/**/</b> \\&mdash; 任何數量的目錄；<i>\\&lt;dir_name\\&gt;</i>:<i>\\&lt;pattern\\&gt;</i> \\&mdash; 限制為具有指定名稱的源根
notification.compiler.auto.build.failure=自動建置失敗: {0}
notification.compiler.auto.build.completed.with.errors=自動建置完成但有錯誤
dialog.title.manifest.select.main.class=選擇主類
label.unknown.value=<未知>
label.extracted.dir.presentation=已提取 ''{0}''
label.library.element.module=模組 ''{0}''
label.in.path.suffix=(在 {0} 中)
jar.text=JAR
jar.from.modules.presentable.name=來自具有依賴項的模組…
unknown.artifact.type.0=未知工件類型: {0}
unknown.element.0=未知元素: {0}
unknown.artifact.properties.0=未知工件屬性: {0}
artifact.configuration.problem.text={0, choice, 1#{1} 個工件|2#{0} 個工件}
unknown.artifact.remove.confirmation=是否要移除工件 ''{0}''?
show.content.of.included.artifacts=顯示已包含工件的內容
show.library.files=顯示庫檔案
directory.copy.element.type.name=目錄內容
extracted.directory.element.type.name=已提取目錄
file.title=檔案
action.disabled.when.per.module.working.directory.configured=設定按模組工作目錄時將禁用 ''{0}''。<br/>只指定一個工作目錄，或將測試範圍更改為一個模組。
action.disabled.in.fork.mode={0} 在復刻模式下被禁用。<br/>將復刻模式更改為 \\&lt;none\\&gt; 以{1}。
popup.title.choose.suite.to.add=選擇要添加的套件
tab.title.thread.dump=轉儲 {0}
whole.project=<整個專案>
dialog.message.jar.file.doesn.t.exist=JAR 檔案 ''{0}'' 不存在
jshell.nothing.to.execute=沒有要執行的內容
jshell.internal.error=內部錯誤
jshell.dropped.x.code.snippets=已丟棄 {0} 程式碼段
jshell.console=JShell 主控台
all.inheritors=所有({0})
label.debugger.mode=偵錯器模式(&D):
label.host=主機(&H):
label.transport=傳輸(&T):
label.port=連接埠(&P):
label.address=地址(&A):
error.no.scratch.file.associated.with.configuration=沒有與設定關聯的臨時檔案
error.associated.scratch.file.not.found=未找到關聯的臨時檔案
java.scratch=Java 草稿
configuration.for.java.scratch.files=Java 臨時檔案的設定
test.discovery.show.affected.tests=顯示受影響的測試
test.discovery.parametrized=已參數化
test.discovery.unused.test.data.tab.title=未使用的測試資料
test.discovery.tests.tab.title={0} 的測試
popup.title.debug.recent.tests=偵錯最近的測試
popup.title.run.recent.tests=執行最近的測試
shift.key=Shift
popup.advertisement.debug.with.shift.navigate.with.f4=使用 {0} 偵錯，使用 F4 導航
module.sources.set.display.name={0, choice, 0#|1#測試 }''{1}'' 模組
ArtifactPropertiesEditor.tab.validation=驗證
ArtifactPropertiesEditor.tab.post.processing=正在後處理
ArtifactPropertiesEditor.tab.pre.processing=正在預處理
reference.projectsettings.compiler.excludes=排除
reference.projectsettings.compiler.annotationProcessors=註解處理器
affected.tests.counts=\ / {0} 個{1, choice, 0#測試|1#測試}
artifacts.menu.item.all=所有工件
artifacts.menu.item.build=建置
artifacts.menu.item.clean=清理
artifacts.menu.item.rebuild=重新建置
artifacts.menu.item.edit=編輯…
error.task.0.execution.failed=任務 {0} 失敗，請參閱 idea.log 了解詳細資訊
dialog.title.choose.module=選擇模組
build.process.no.javac.found=JRE 未提供系統 java 編譯器。確保 IntelliJ IDEA 類路徑中存在 tools.jar。
build.process.no.javac.path.found=無法確定 {0} ({1})到 ''tools.jar'' 庫的路徑
build.process.no.free.debug.port=找不到可用的連接埠來偵錯建置行程
build.process.ecj.path.does.not.exist=eclipse ecj 編譯器的路徑不存在: {0}
jar.artifacts.dialog.label.directory.for.metainf=META-INF/MANIFEST.MF 的目錄(&D):
jar.artifacts.dialog.checkbox.include.tests=包含測試(&I)
jar.artifacts.dialog.label.module=模組(&M):
jar.artifacts.dialog.border.title.jar.files.from.libraries=來自庫的 JAR 檔案
jar.artifacts.dialog.radio.button.extract.to.the.target.jar=提取到目標 JAR(&E)
jar.artifacts.dialog.radio.button.copy.to.the.output.directory.and.link.via.manifest=複製到輸出目錄並通過清單鏈接(&T)
jar.artifacts.dialog.label.main.class=主類(&C):

element.with.manifest.button.create.manifest=創建清單(&C)…
element.with.manifest.button.use.existing.manifest=使用現有清單(&U)…
element.with.manifest.label.meta.inf.manifest.mf.file.not.found=找不到 META-INF/MANIFEST.MF 檔案
element.with.manifest.label.manifest.file=清單檔案(&F):

notification.group.title.jps.cannot.start.compiler=無法啟動編譯
notification.action.jps.open.configuration.dialog=設定…
notification.title.jps.cannot.start.compiler=無法啟動編譯器
notification.title.cpu.snapshot.build.has.been.captured=已捕獲建置 CPU 快照
action.show.snapshot.location.text=顯示快照位置
dialog.message.failed.to.determine.host.ip.for.wsl.jdk=無法確定 WSL JDK 的主機 IP
progress.preparing.wsl.build.environment=正在準備 WSL 建置環境…
plugins.advertiser.feature.artifact=工件

action.make.single.module.text=建置模組 ''{0}''(_M)
action.make.few.modules.text=建置模組 {0}(_M)
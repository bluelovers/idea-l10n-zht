action.com.intellij.clion.embedded.execution.wizard.GdbServerWizardAction.description=GDB 伺服器組態嚮導
action.com.intellij.clion.embedded.execution.wizard.GdbServerWizardAction.text=新增嵌入式組態…
action.com.jetbrains.cidr.embedded.stm32cubemx.update.text=使用 STM32CubeMX 更新 CMake 專案
action.intellij.clion.embedded.mcu.reset.text=重設 MCU
action.intellij.clion.embedded.run.stm32cubemx.text=通過 STM32CubeMX 開啟
border.title.connection=連線
build.configuration.executable=可執行的二進制檔案
checkbox.live.watches=實時監視
checkbox.start.monitor.after.upload=上傳後啟動監控
comment.download=<a href\="{0}">下載…</a>
compiler.implicit.include.not.found=找不到隱式 include 檔案 {0}
compiler.run.failed=無法執行編譯器\: {0} \n {1}
configurable.RtosSettingsConfigurable.display.name=RTOS 整合
connection.arguments.hint={0} 實參
console=主控台
console.rtt=RTT
console.semihosting=半托管
console.swo=SWO
cube.file.is.empty=檔名為空
cube.file.is.not.file={0} 不是檔案
cube.file.is.not.found={0} 不存在
cube.mx.editor.open=通過 STM32CubeMX 開啟
cube.mx.editor.opened=在 STM32CubeMX 中開啟
cube.mx.file.not.found=找不到檔案
cube.mx.file.not.found.description=在專案目錄 {1} 中找不到檔案 {0}。\n請在 STM32CubeMX 中執行“Generate Code”
cube.mx.file.read.error=檔案讀取錯誤
cube.mx.file.read.error.description=無法在專案目錄 {1} 中讀取 {0}\n({2})
cube.mx.file.write.error=檔案寫入錯誤
cube.mx.invalid.file.content=無效檔案內容
cube.mx.more.information.link=更多資訊
cube.mx.open.external.editor=開啟外部編輯器
cube.mx.project.sources.not.generated=沒有生成專案源。在 STM32CubeMX 中執行 'GENERATE CODE'
cube.mx.project.sources.outdated=生成的源似乎已過時。在 STM32CubeMX 中執行 'GENERATE CODE'
cube.mx.project.updated=已更新 STM32CubeMX 專案
cube.mx.wrong.ide=選擇了錯誤的目標 IDE。在“STM32CubeMX -> Project Manager”中將目標設定為 'CMake'
cube.valid.title=此 {0} 似乎有效。\n沒有可用的版本資訊。
debug.tooltip.esp32=在 ESP32 上偵錯 ''{0}''
debug.tooltip.generic=在 {1} 上偵錯 ''{0}''
debug.tooltip.jlink=將 ''{0}'' 偵錯至目標
debug.tooltip.stlink=在 ''{1}'' 上偵錯 ''{0}''
dialog.message.cmake.not.loaded=CMake 專案未載入
dialog.message.cmake.profile.not.defined=CMake 組態檔案未定義
dialog.message.debugger.not.defined=偵錯器未定義
dialog.message.device.not.found=找不到裝置
dialog.message.device.not.selected=未選擇裝置
dialog.message.failed.to.parse.project.description.json=無法解析 project_description.json\: {0} - {1}
dialog.message.failed.to.read.project.description=無法從 project_description.json 中檢索 `{0}`\: {1}
dialog.message.invalid.debugger.path=偵錯器路徑無效
dialog.message.project_description.json.not.found=未找到檔案\: project_description.json。請確保 ESP-IDF 專案正確
dialog.message.wrong.cmake.profile.name=CMake 組態檔名錯誤
dialog.title.configure.gdb.server=新的嵌入式 GDB 伺服器執行組態
dialog.title.segger.jlinkgdbserver=SEGGER J-Link GDB 伺服器
edit.configuration.action=執行/偵錯
embedded.display.name=嵌入式
embedded.gdb.server.description=使用第三方的 GDB 伺服器上傳並執行應用程式
embedded.gdb.server.title=嵌入式 GDB 伺服器
embedded.settings.fix=修正…
enable.console=啟用主控台
error.convert.generic.not.possible=無法轉換為通用偵錯伺服器 — 專案不正確或不支持 ESP-IDF
esp.idf=ESP-IDF
expected.gdbserver.name=預期名稱\: {0}
export.name.embedded.development=嵌入式開發
export.name.embedded.gdbserver.wizard=嵌入式 GDB 伺服器嚮導
file.cannot.be.executed={0} 無法執行
file.extension.not.found=找不到 .{0} 檔案。
file.is.not.valid.cube.executable={0} 不是有效的 {1} 可執行檔案
filetype.stm32cubemx.project.description=STM32CubeMX 專案
firmware.downloaded=已下載固件
freertos.heap.allocations.label=分配次數
freertos.heap.block.table.address.range.column=地址範圍
freertos.heap.block.table.details.column=詳細資訊
freertos.heap.block.table.size.column=大小
freertos.heap.free.label=釋放
freertos.heap.frees.label=釋放計數
freertos.heap.info.not.available=堆資訊僅對 HEAP_[2,4,5] 可用
freertos.heap.panel.name=FreeRTOS 堆
freertos.heap.table.address.range.column=地址範圍
freertos.heap.type.label=類型
freertos.heap.usage.label=用法
freertos.integration.enabled=FreeRTOS 整合已啟用
freertos.integration.not.full=缺少可選定義。某些功能可能不可用。
freertos.integration.sizeof.failed=無法檢索 sizeof {0}
freertos.panel.name=FreeRTOS 物件
freertos.queue.data.table.address.column=地址
freertos.queue.data.table.data.dec.column=十進制數據
freertos.queue.data.table.number.column=順序編號
freertos.queue.enable.text=新增 \#define configQUEUE_REGISTRY_SIZE > 0
freertos.queue.table.address.column=地址
freertos.queue.table.head.label=頭
freertos.queue.table.length.column=長度
freertos.queue.table.name=佇列資料
freertos.queue.table.name.column=名稱
freertos.queue.table.read.from.label=讀取自
freertos.queue.table.rx.column=RX
freertos.queue.table.size.column=條目大小
freertos.queue.table.tail.label=尾部
freertos.queue.table.tx.column=TX
freertos.queue.table.type.column=類型
freertos.queue.table.write.to.label=寫入到
freertos.task.table.event.object.column=事件物件
freertos.task.table.handle.column=任務句柄
freertos.task.table.id.column=TCB №
freertos.task.table.name=任務資料
freertos.task.table.name.column=任務名稱
freertos.task.table.priority.column=優先級
freertos.task.table.runtime.column=執行時
freertos.task.table.stack.end.label=堆疊結束
freertos.task.table.stack.hwmark.label=堆疊 HW 標記
freertos.task.table.stack.start.label=堆疊開始
freertos.task.table.stack.usage.column=堆疊使用情況
freertos.task.table.state.column=任務狀態
freertos.timer.enable.text=新增 \#define configUSE_TIMERS 1
freertos.timer.table.handle.column=期間 [Ticks]
freertos.timer.table.id.column=ID
freertos.timer.table.name=定時器資料
freertos.timer.table.name.column=名稱
freertos.timer.table.stack.usage.column=回調函式
freertos.timer.table.state.column=狀態
gdb.parameters.panel.reset.command=重設指令
gdb.parameters.panel.reset.command.field=監視器重設
gdb.parameters.reset.type.after.download=上傳後
gdb.parameters.reset.type.always=始終
gdb.parameters.reset.type.before.download=上傳前
gdb.parameters.reset.type.never=從不
gdb.servers.wizard.devices.parse.error=無法從輸入行解析裝置\: {0}，可能是 GDB 伺服器位置錯誤
gdb.servers.wizard.download.binary=上傳二進制檔案\:
gdb.servers.wizard.exception.occurred.while.executable.invoke=執行 {0} 時出現異常\:\n{1}
gdbserver.app.cannot.report.supported.devices=GDB 伺服器 {0} 無法報告支援的裝置列表。
gdbserver.cannot.report.supported.devices=GDB 伺服器無法報告支援的裝置列表。
gdbserver.progress=正在啟動 GDB 伺服器… {0}s
generic=泛型
identify.utility.version=正在識別 {0} 版本
ioc.file.not.found.comment=這可能不是 STM32CubeMX 專案。
jlink.device.dialog.button.tooltip=選擇…
jlink.device.dialog.search.textfield.empty.text=搜尋
jlink.device.dialog.search.tree.empty.text=找不到任何裝置
jlink.device.dialog.title=選擇裝置
jlink.gdb.server.displayname=Segger JLink
label.device=裝置\:
label.executable=可執行的二進制檔案\:
label.gdb=偵錯器\:
label.gdb.server.type=GDB 伺服器類型\:
label.gdbserver.port=GDB 伺服器連接埠\:
label.initial.speed=初始速度\:
label.jlink.gdb.server=Segger J-Link
label.khz=kHz
label.location=位置\:
label.name.config=名稱\:
label.pemicro=PE Micro Cyclone、Multilink 或 OpenSDA
label.port=連接埠\:
label.pyocd=PyOCD
label.qemu=QEMU 模擬器
label.reset.strategy=重設策略\:
label.st.util.gdb.server=st-util
label.stlink.gdb.server=STM32CubeIDE ST-LINK GDB 伺服器
label.swo.cpu.freq=CPU 頻率\:
label.swo.freq=頻率\:
label.swo.mask=遮罩\:
label.target=目標\:
label.tcp.ip.port=TCP/IP 連接埠\:
label.transport.interface=傳輸接口\:
label.uart=UART\:
label.unit.hz=Hz
label.unit.khz=kHz
link.label.edit=編輯…
mcu.chip.detected=檢測到晶片\: {0} (ARM {1})
mcu.communication.failure.detailed=MCU 通信故障。請檢查您的<i>執行組態</i>
mcu.is.configured=已組態 {0}。
mcu.reset.type.HALT=停止
mcu.reset.type.INIT=初始化
mcu.reset.type.NONE=無
mcu.reset.type.RUN=執行
message.expected.name=預期名稱為 {0}
message.read.error=讀取錯誤({0}\: {1})
modal.progress.title.exporting=正在匯出…
no.mcu.configured=未組態 MCU
notification.group.embedded.development=嵌入式開發
openocd.assist.button=輔助…
openocd.board.config.file.label=面板組態檔案\:
openocd.board.config.not.defined=未定義面板組態檔案
openocd.download.label=下載\:
openocd.download.run.description=使用 OpenOCD 下載並執行嵌入式應用程式
openocd.download.run.title=OpenOCD 下載並執行
openocd.gdb.port.label=GDB 連接埠\:
openocd.invalid.run.file=執行檔案 {0} 無效
openocd.is.not.valid.executable={0} 不是有效的可執行檔案
openocd.ports.should.be.different=連接埠值應不同
openocd.reset.label=重設\:
openocd.telnet.port.label=Telnet 連接埠\:
openocd.wrong.installation=OpenOCD 安裝錯誤\n找不到面板組態目錄({0})
pemicro.gdb.server.displayname=PE Micro (OpenSDA)
please.enter.port.number=請輸入介於 {0} 到 {1} 之間的 TCP 端口號
please.enter.positive.number=請輸入一個正數
port.number.auto=自動
progress.title.loading.devices=正在載入裝置…
progress.title.looking.for.installed.utility=正在尋找已安裝的實用程序
pyocd.gdb.server.displayname=PyOCD
qemu.displayname=QEMU 模擬器
queue.data.text.double.click.to.see.more=… (雙擊檢視更多內容)
radio.jtag=JTAG
radio.swd=SWD
reset.strategy.attach=附加
reset.strategy.default=預設
reset.strategy.halt=停止
reset.strategy.pre_reset=Pre-Reset
reset.strategy.under_reset=Init-Under-Reset
rtos.auto.display.name=自動
rtos.azure.display.name=Azure RTOS ThreadX
rtos.freertos.display.name=FreeRTOS
rtos.panel.selector.hint=需要支援 Python 的 GDB 7.4 或更高版本
rtos.panel.selector.label=啟用 RTOS 整合
rtos.panel.threads.hint=如果您使用的偵錯伺服器支援類似功能，則可能需要停用此選項。
rtos.panel.threads.label=啟用執行緒感知
rtos.zephyr.display.name=Zephyr
rtos.zephyr.integration.error=Zephyr 組態失敗
rtos.zephyr.thread.monitor.missing=Define CONFIG_THREAD_MONITOR 未設定
rtos.zephyr.thread.name.missing=Define CONFIG_THREAD_NAME 未設定
run.configuration.name.is.taken=執行組態名稱“{0}”已被占用
run.tooltip.esp32=監控 ESP32
run.tooltip.generic=將 ''{0}'' 上傳到 {1}
run.tooltip.jlink=將 ''{0}'' 刷寫至目標
run.tooltip.stlink=將 ''{0}'' 刷寫到 ''{1}''
segger.jlink=SEGGER J-Link
select.board.dialog.copy.and.use.action=複製到專案並使用
select.board.dialog.overwrite.file=檔案 {0} 已存在於專案中。是否覆蓋?
select.board.dialog.overwrite.title=是否覆蓋面板組態?
select.board.dialog.title=選擇面板組態檔案
set.openocd.location=請通過嵌入式開發設定對 OpenOCD 位置進行設定
show.settings.action=設定
show.toolchains.action=工具鏈
skip.board.button=跳過
st.link.gdb.server.displayname=STM32CubeIDE ST-LINK GDB 伺服器
st.link.gdbserver.not.found=找不到 ST-LINK_gdbserver
stlink.dialog.title.st.link.gdb.server.executable=ST-LINK GDB 伺服器可執行檔案
stlink.dialog.title.stm32cubeprogrammer.bin.directory=STM32CubeProgrammer bin 目錄
stlink.gdb.server.tab.name=ST-LINK GDB 伺服器
stlink.group.label.multicore=多核
stlink.group.label.swo=SWO
stlink.groupname=ST-LINK
stlink.label.apid=存取連接埠\:
stlink.label.halt=停止所有核心
stlink.label.programmer=程序員\:
stlink.label.reset.type=重設類型\:
stlink.label.shared=共享 ST-LINK
stlink.label.swo.clock.divider=SWO 時鐘分頻器\:
stlink.label.swo.cpu.frequency=CPU 頻率\:
stlink.label.verify.flash.download=驗證閃存下載
stlink.programmer.validation.warning.bin=預期目錄名稱為 {0}
stlink.programmer.validation.warning.exe=預期檔名名稱為 {0}
stlink.reset.connect.under.reset=重設時連線
stlink.reset.strategy.core=核心
stlink.reset.strategy.hardware=硬體
stlink.reset.strategy.software=軟體
stm32.cube.ide.wrong.executable=指定了錯誤的 STM32CubeIDE 可執行檔案
stm32.cube.mx.is.not.found=STM32CubeMX 未找到
stm32.cube.mx.project.generation.failure=專案生成失敗
stm32.cube.mx.project.wizard.button=繼續
stm32.cube.mx.project.wizard.cmake.fail.text=無法從 {0} 匯入。
stm32.cube.mx.project.wizard.cmake.fail.title=CMake 錯誤
stm32.cube.mx.project.wizard.html=<ol style\="margin-top\: 0;"><li>在 STM32CubeMX 中\:<ol type\="a"><li>在 <i>New Project</i> 面板中，點擊 <i>ACCESS TO MCU SELECTOR</i>。您也可以選擇 <i>ACCESS TO BOARD SELECTOR</i>。</li><li>選擇您的 MCU 或開發板。</li><li>點擊 <i>Start Project</i>。</li><li>在生成的裝置組態視窗中，組態必要的外設和中間件。</li><li>導覽到 <i>Project Manager</i> 頁籤。</li><li>從 <i>Toolchain / IDE</i> 下拉選單中選擇 <i>CMake</i>。</li><li>在 <i>Project Name</i> 欄位中輸入您的專案的名稱。</li><li>點擊 <i>GENERATE CODE</i>。</li><li>使用鍵盤快捷鍵 <i>{0}</i> 從 <i>Toolchain Folder Location</i> 欄位複製路徑。</li></ol></li><li>在 CLion 中\:<ol type\="a"><li>在此對話框頂部的<i>位置</i>欄位中輸入您複製的路徑。</li><li>點擊<i>{1}</i>。</li><li>在顯示的<i>開啟專案嚮導</i>對話框中，從列表中選擇 CMake <i>偵錯 – 偵錯</i>組態檔案，點擊<i>啟用</i>，然後點擊<i>確定</i>。</li></ol></li><li>您的 STM32CubeMX 專案現已建立完成。</li></ol>
stm32.cube.mx.project.wizard.notice=需要由 STM32CubeMX 生成一個 STM32CubeMX 專案。
stm32.cube.mx.project.wizard.open.failed.text=開啟 STM32CubeMX 專案 ''{0}'' 失敗。
stm32.cube.mx.project.wizard.open.failed.title=開啟專案
stm32cubeclt=STM32CubeCLT
stm32cubeclt.not.detected=找不到 STM32CubeCLT。請確保您已安裝相容的工具鏈。
stm32cubeclt.valid=STM32CubeCLT 似乎有效
stm32cubemx=STM32CubeMX
stm32cubemx.is.not.found=STM32CubeMX 未找到或無效。
stm32cubemx.launch=啟動 STM32CubeMX
stm32cubeprogrammer.not.found=找不到 STM32CubeProgrammer
stutil.displayname=st-util
target.device.is.not.selected=未選擇目標裝置
template.do.not.change=此檔案從模板自動生成\! 請勿更改\!
text.uart.auto=自動
tool.checking=正在檢查 {0}
tool.found=已找到
tool.location={0} 位置\:
tool.not.found=找不到
tool.test.action=測試
uart.comment=(例如 /dev/ttyS4 或 COM1)
unknown.binary=未知二進制檔案 {0}
use.board.button=使用
validation.intl.characters=Stm32CubeMX 和 OpenOCD 在“專案位置”中不支持國際字元或空格。
validation.missing.cmake.file=找不到 {0}。請確保該專案是為 CMake 生成的。
validation.missing.directory=目錄不存在。生成專案並在“位置”欄位中輸入其路徑。
wrong.gdb.server.location=GDB 伺服器位置錯誤

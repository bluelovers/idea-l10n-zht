jvm.inspections.group.name=JVM 語言

jvm.inspections.unstable.api.usage.display.name=不穩定的 API 用法
jvm.inspections.unstable.api.usage.annotations.list=不穩定的 API 註解:
jvm.inspections.unstable.api.usage.ignore.inside.imports=在匯入內忽略
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=忽略此專案中宣告的 API
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}'' 使用 @{1} 標記為不穩定
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}'' 在標記為 @{3} 的不穩定{1} ''{2}'' 中宣告
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=覆寫方法 ''{0}'' 使用 @{1} 標記為不穩定
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=覆寫方法 ''{0}'' 在標記為 @{3} 的不穩定{1} ''{2}'' 中宣告
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}'' 不穩定，因為其簽名引用了標記為 @{3} 的不穩定{1} ''{2}''

jvm.inspections.scheduled.for.removal.future.version=未來版本
jvm.inspections.scheduled.for.removal.predefined.version=版本 {0}
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}'' 已計劃從 {1} 中移除
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}'' 在已計劃從 {3} 中移除的{1} ''{2}'' 中宣告
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=覆寫方法 ''{0}'' 已計劃從 {1} 中移除
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=覆寫方法 ''{0}'' 在已計劃從 {3} 中移除的{1} ''{2}'' 中宣告
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}'' 已計劃移除，因為其簽名引用了已計劃從 {3} 中移除的{1} ''{2}''

jvm.inspections.unstable.type.used.in.signature.display.name=簽名中使用了不穩定的類型
jvm.inspections.unstable.type.used.in.class.signature.description=類必須使用 ''@{0}'' 註解標記，因為其宣告引用了不穩定的類型 ''{1}''
jvm.inspections.unstable.type.used.in.method.signature.description=方法必須使用 ''@{0}'' 註解標記，因為其簽名引用了不穩定的類型 ''{1}''
jvm.inspections.unstable.type.used.in.field.signature.description=欄位必須使用 ''@{0}'' 註解標記，因為其類型引用了不穩定的類型 ''{1}''

jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=已計劃移除的 API 上缺少 '@Deprecated' 註解
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=已計劃移除的 API 也必須使用 '@Deprecated' 註解標記
jvm.inspections.must.already.be.removed.api.display.name=API 必須已移除
jvm.inspections.must.already.be.removed.api.earlier.version.description=API 必須已在版本 {0} 中移除，但當前版本為 {1}
jvm.inspections.must.already.be.removed.api.current.version.description=API 必須在當前版本 {0} 中移除
jvm.inspections.blocking.method.problem.descriptor=在非阻塞上下文中使用阻塞調用可能會導致執行緒匱乏
jvm.inspections.blocking.method.display.name=可能在非阻塞上下文中使用阻塞調用
jvm.inspections.blocking.method.annotation.blocking=阻塞註解
jvm.inspections.blocking.method.annotation.non-blocking=非阻塞註解
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=添加阻塞註解
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=添加非阻塞註解
jvm.inspections.blocking.method.annotation.configure.empty.text=未添加註解。

jvm.inspections.api.no.extension.display.name=不應擴展類、接口或方法
jvm.inspections.api.no.extension.class.description=不得擴展類 ''{0}''
jvm.inspections.api.no.extension.interface.implement.description=不得實作接口 ''{0}''
jvm.inspections.api.no.extension.interface.extend.description=不得擴展接口 ''{0}''
jvm.inspections.api.no.extension.method.overriding.description=不得覆寫方法 ''{0}''
jvm.inspections.api.override.only.display.name=方法只能覆寫
jvm.inspections.api.override.only.description=方法 ''{0}'' 只能覆寫

jvm.inspections.dependency.display.name=非法的軟體套件依賴項
jvm.inspections.dependency.edit.rules.text=編輯依賴關係規則 "{0} "
jvm.inspections.dependency.edit.rules.family=編輯依賴關係規則
jvm.inspections.dependency.configure.button.text=設定依賴關係規則
jvm.inspections.dependency.violator.problem.descriptor=違反依賴關係規則 ''{0}.''


jvm.inspections.testonly.display.name=生產程式碼中的純測試用法
jvm.inspections.testonly.class.reference=在生產程式碼中引用純測試類
jvm.inspections.testonly.field.reference=在生產程式碼中引用純測試欄位
jvm.inspections.testonly.method.call=在生產程式碼中調用純測試方法
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting 對 @TestOnly 程式碼意義不大

jvm.inspections.string.touppercase.tolowercase.without.locale.description=在未使用國際化字串指定區域設定的情況下調用 <code>String.{0}()</code> #loc
can.t.build.uast.tree.for.file=無法為檔案建置 UAST 樹
title.uast=UAST
current.version=當前版本:
dialog.title.choose.annotation=選擇 {0}
jvm.inspection.test.failed.line.display.name=測試中失敗的行
jvm.inspections.source.to.sink.flow.display.name=不安全字串被傳遞至安全方法
jvm.inspections.junit5.converter.display.name=JUnit 4 測試可以為 JUnit 5
jvm.inspections.junit5.converter.problem.descriptor=#ref 可以為 JUnit 5 測試
jvm.inspections.junit5.converter.quickfix=遷移到 JUnit 5
jvm.inspections.junit5.converter.quickfix.presentation.text=轉換斷言
jvm.inspections.junit5.converter.quickfix.conflict.inheritor=由於存在不相容的繼承者，類 {0} 無法轉換為 JUnit 5: {1}
jvm.inspections.thread.run.display.name=調用 'Thread.run()'
jvm.inspections.serializable.class.without.serialversionuid.display.name=不帶 'serialVersionUID' 的可序列化類
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>#ref</code> 未定義 'serialVersionUID' 欄位 #loc
jvm.inspections.source.to.sink.flow.passed.unsafe=不安全字串用作安全參數
jvm.inspections.source.to.sink.flow.passed.unknown=未知字串用作安全參數
jvm.inspections.source.to.sink.flow.returned.unsafe=不安全字串返回自安全方法
jvm.inspections.source.to.sink.flow.returned.unknown=未知字串返回自安全方法
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=標記為需要驗證
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=將 ''{0}'' 標記為需要驗證
jvm.inspections.blocking.method.consider.unknown.context.blocking=考慮未知上下文阻塞
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.family=傳播安全註解
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.text=從 ''{0}'' 傳播安全註解
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.title=選擇要註解為安全的成員
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.annotate=註解除排除外的所有物件
propagated.from=標記為安全的原因:
propagated.to=要標記為安全的目標:
propagate.from.empty.text=此處將顯示標記為安全的原因
propagate.to.empty.text=此處將顯示要標記為安全的目標
jvm.inspections.blocking.method.problem.wildcard.descriptor=在{0}中使用阻塞調用可能會導致執行緒匱乏
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.unsafe.flow=不安全的流
jvm.inspections.source.to.sink.flow.assigned.unsafe=不安全的字串分配給安全變數
jvm.inspections.source.to.sink.flow.assigned.unknown=未知字串分配給安全變數
jvm.inspections.source.to.sink.flow.common.unsafe=不安全字串在安全上下文中使用
jvm.inspections.source.to.sink.flow.common.unknown=未知字串在安全上下文中使用
jvm.inspections.api.display.name=使用在設定的語言級別下不可用的 API
jvm.inspections.1.5.problem.descriptor=使用記錄為 @since {0}+ 的 API
jvm.inspections.1.7.problem.descriptor=使用自 1.6 以來通用的 API，這可能會導致 JDK {0} 出現編譯問題。
jvm.inspections.1.8.problem.descriptor=預設{0, choice, 0#|1#方法|2#方法}不會被覆寫。它會導致 JDK {1} 出現編譯問題
jvm.inspections.1.8.problem.single.descriptor=預設方法 ''{0}'' 不會被覆寫。它會導致 JDK {1} 出現編譯問題
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.command.name=標記為需要驗證
jvm.inspections.source.unsafe.to.sink.flow.preview.multiple.files=將 ''@Untainted'' 註解添加到 {0}
jvm.inspections.dependency.on.internal.display.name=對內部軟體套件的非法依賴
inspection.message.illegal.dependency.module.doesn.t.export=非法依賴: 模組 ''{0}'' 不匯出軟體套件 ''{1}''
jvm.inspections.test.frameworks.group.name=測試框架
assertequals.between.inconvertible.types.display.name='assertEquals()' 位於不可轉換類型的物件之間
jvm.inspections.assertequals.between.inconvertible.types.problem.descriptor=不可轉換類型 ''{0}'' 和 ''{1}'' 物件之間的 <code>#ref()</code> #loc
jvm.inspections.assertnotsame.between.inconvertible.types.problem.descriptor=冗餘斷言: 比較不相容的類型 ''{0}'' 和 ''{1}''
jvm.inspections.assertnotequals.between.inconvertible.types.problem.descriptor=可能的冗餘斷言: 比較不相容的類型 ''{0}'' 和 ''{1}''
jvm.inspections.junit.malformed.declaration.name=JUnit malformed declaration
jvm.inspections.junit.malformed.option.ignore.test.parameter.if.annotated.by=Ignore test parameter if it is annotated by:
jvm.inspections.junit.malformed.test.combination.descriptor=Suspicious combination of {0} and ''@{1}''
jvm.inspections.junit.malformed.repetition.number.descriptor=重複次數必須大於零
jvm.inspections.junit.malformed.nested.class.descriptor=Only non-static nested classes can serve as '@Nested' test classes
jvm.inspections.junit.malformed.extension.registration.descriptor=''{0}'' should implement ''{1}''
jvm.inspections.junit.malformed.extension.class.level.descriptor={0} should be registered at the class level
jvm.inspections.junit.malformed.param.method.source.unresolved.descriptor=無法解析目標方法源: ''{0}''
jvm.inspections.junit.malformed.param.wrapped.in.arguments.descriptor=必須在 'Arguments' 中包裝多個參數
jvm.inspections.junit.malformed.param.method.source.return.type.descriptor=方法源 ''{0}'' 必須具有以下其中一種返回類型: ''Stream<?>''、''Iterator<?>''、''Iterable<?>'' 或 ''Object[]''
jvm.inspections.junit.malformed.param.method.source.no.params.descriptor=方法源 ''{0}'' 不應有參數
jvm.inspections.junit.malformed.param.method.source.static.descriptor=方法源 ''{0}'' 必須為 static
jvm.inspections.junit.malformed.param.method.source.assignable.descriptor=No implicit conversion found to convert ''{0}'' to ''{1}''
jvm.inspections.junit.malformed.param.duplicated.enum.descriptor=重複的 'enum' 常數名稱
jvm.inspections.junit.malformed.param.unresolved.enum.descriptor=無法解析 'enum' 常數引用。
jvm.inspections.junit.malformed.param.no.value.source.is.defined.descriptor=未定義值源
jvm.inspections.junit.malformed.param.exactly.one.type.of.input.must.be.provided.descriptor=必須恰好提供一種類型的輸入
jvm.inspections.junit.malformed.param.file.source.descriptor=無法解析檔案源: ''{0}''
jvm.inspections.junit.malformed.param.null.source.cannot.provide.argument.no.params.descriptor=''@{0}'' 無法向方法提供實參，因為方法沒有參數
jvm.inspections.junit.malformed.param.null.source.cannot.provide.argument.too.many.params.descriptor=''@{0}'' 無法向方法提供實參，因為方法提供了過多參數
jvm.inspections.junit.malformed.param.empty.source.cannot.provide.argument.descriptor=''@{0}'' 無法向方法提供實參，因為方法具有不受支援的 ''{1}'' 類型的參數
jvm.inspections.junit.malformed.param.multiple.parameters.are.not.supported.by.this.source.descriptor=此源不支持多個參數
jvm.inspections.junit.malformed.param.no.sources.are.provided.descriptor=沒有提供源，套件將為空
jvm.inspections.junit.malformed.method.no.arg.void.descriptor=Method <code>#ref</code> should be a {0}, {1}, have no parameters and be of type void
jvm.inspections.junit.malformed.annotated.field.single.descriptor=Field <code>#ref</code> annotated with ''@{0}'' should be {1}
jvm.inspections.junit.malformed.annotated.field.double.descriptor=Field <code>#ref</code> annotated with ''@{0}'' should be {1} and {2}
jvm.inspections.junit.malformed.annotated.field.typed.descriptor=Field <code>#ref</code> annotated with ''@{0}'' should be of type ''{1}''
jvm.inspections.junit.malformed.annotated.field.single.typed.descriptor=Field <code>#ref</code> annotated with ''@{0}'' should be {1} and be of type ''{2}''
jvm.inspections.junit.malformed.annotated.field.double.typed.descriptor=Field <code>#ref</code> annotated with ''@{0}'' should be {1} and {2} and be of type ''{3}''
jvm.inspections.junit.malformed.annotated.method.single.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}
jvm.inspections.junit.malformed.annotated.method.double.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1} and {2}
jvm.inspections.junit.malformed.annotated.method.typed.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be of type ''{1}''
jvm.inspections.junit.malformed.annotated.method.single.typed.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1} and of type ''{2}''
jvm.inspections.junit.malformed.annotated.method.double.typed.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}, {2} and of type ''{3}''
jvm.inspections.junit.malformed.annotated.method.param.single.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should not declare parameter ''{1}''
jvm.inspections.junit.malformed.annotated.method.typed.param.single.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be of type ''{1}'' and not declare parameter ''{2}''
jvm.inspections.junit.malformed.annotated.method.single.param.single.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1} and not declare parameter ''{2}''
jvm.inspections.junit.malformed.annotated.method.double.param.single.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}, {2} and not declare parameter ''{3}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.single.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}, of type ''{2}'' and not declare parameter ''{3}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.single.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}, {2}, of type ''{3}'' and not declare parameter ''{4}''
jvm.inspections.junit.malformed.annotated.method.param.double.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should not declare parameters {1} and ''{2}''
jvm.inspections.junit.malformed.annotated.method.typed.param.double.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be of type ''{1}'' and not declare parameters {2} and ''{3}''
jvm.inspections.junit.malformed.annotated.method.single.param.double.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1} and not declare parameters ''{2}'' and ''{3}''
jvm.inspections.junit.malformed.annotated.method.double.param.double.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}, {2} and not declare parameters ''{3}'' and ''{4}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.double.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}, of type ''{2}'' and not declare parameters {3} and ''{4}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.double.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}, {2}, of type ''{3}'' and not declare parameters {4} and ''{5}''
jvm.inspections.junit.malformed.fix.method.signature=修復方法簽名
jvm.inspections.junit.malformed.fix.method.signature.descriptor=修復 ''{0}'' 方法簽名
jvm.inspections.junit.malformed.fix.field.signature=Fix field signature
jvm.inspections.junit.malformed.fix.field.signature.descriptor=Fix ''{0}'' field signature
jvm.inspections.junit.malformed.method.no.arg.descriptor=Method <code>#ref</code> should be a {0}, {1} and have no parameters
jvm.inspections.junit.malformed.annotated.suspend.function.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should not be a suspending function
jvm.inspections.junit.malformed.suspend.function.descriptor=Method <code>#ref</code> should not be a suspending function
action.find.similar.stack.call.methods.not.found=未找到類似的類別
advanced.setting.process.console.output.to.find.class.names=處理終端輸出以尋找並醒目提示類別名
allow.suppressions.fix.family.name=允許禁止
allow.suppressions.fix.text=允許這些禁止
assertequals.between.inconvertible.types.display.name='assertEquals()' 位於不可轉換類型的物件之間
can.t.build.uast.tree.for.file=無法為檔案建置 UAST 樹
checkbox.comments.and.javadoc.count.as.content=註釋和 javadoc 計為內容
current.version=當前版本\:
dialog.title.choose.annotation=選擇 {0}
group.advanced.settings.jvm=JVM 語言
ignored.suppressions=已忽略禁止\:
inspection.empty.method.delete.quickfix=刪除不必要的方法
inspection.empty.method.display.name=空方法
inspection.empty.method.problem.descriptor=方法只呼叫它的 super
inspection.empty.method.problem.descriptor1=空方法覆寫空方法
inspection.empty.method.problem.descriptor2=該方法為空
inspection.empty.method.problem.descriptor3=該方法和所有它的derivables是空的
inspection.empty.method.problem.descriptor4=此方法的所有實作都為空
inspection.message.illegal.dependency.module.doesn.t.export=非法相依\: 模組 ''{0}'' 不匯出軟體套件 ''{1}''
inspection.suppression.annotation.display.name=檢查禁止註解
inspection.suppression.annotation.problem.descriptor=註解會禁止 {0} \#loc
inspection.suppression.comment.problem.descriptor=註釋會禁止 {0} \#loc
jvm.class.filter.choose.calls=類似的日誌呼叫\:
jvm.inspection.log.guarded.display.name=日誌記錄呼叫受日誌條件保護
jvm.inspection.log.guarded.fix.family.name=解包日誌 guard 條件
jvm.inspection.log.guarded.problem.descriptor=日誌記錄呼叫受日誌條件保護 \#loc
jvm.inspection.log.guarded.warn.if.fix.possible=僅在修正可用時發出警告
jvm.inspection.log.statement.not.guarded.all.levels.option=所有日誌級別
jvm.inspection.log.statement.not.guarded.debug.level.and.lower.option=偵錯級別及更低
jvm.inspection.log.statement.not.guarded.display.name=日誌記錄呼叫不受日誌條件保護
jvm.inspection.log.statement.not.guarded.info.level.and.lower.option=資訊級別及更低
jvm.inspection.log.statement.not.guarded.log.fix.family.name=使用日誌條件包圍
jvm.inspection.log.statement.not.guarded.log.problem.descriptor=日誌記錄呼叫不受日誌記錄條件保護 \#loc
jvm.inspection.log.statement.not.guarded.trace.level.option=追蹤級別
jvm.inspection.log.statement.not.guarded.unguarded.constant.option=使用常數訊息處理不受保護的日誌記錄呼叫
jvm.inspection.log.statement.not.guarded.unguarded.constant.option.comment=處理所有不受保護的日誌呼叫，而不僅僅是那些具有非常數實參的日誌呼叫
jvm.inspection.log.statement.not.guarded.warn.level.and.lower.option=警告級別及更低
jvm.inspection.log.statement.not.guarded.warn.on.label=警告物件\:
jvm.inspection.logging.condition.disagrees.with.log.statement.display.name=日誌條件與日誌記錄呼叫不符合
jvm.inspection.logging.condition.disagrees.with.log.statement.fix.family.name=更改日誌級別
jvm.inspection.logging.condition.disagrees.with.log.statement.fix.name=更改{0, choice, 0\#條件|1\#呼叫}的級別
jvm.inspection.logging.condition.disagrees.with.log.statement.problem.descriptor=條件 ''{0}'' 的級別與日誌記錄呼叫 ''{1}'' 的級別不符合
jvm.inspection.logging.placeholder.count.matches.argument.count.display.name=佔位符數量與日誌記錄呼叫中的實參數量不符合
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.descriptor=提供的實參數量({0})少於指定的佔位符數({1}) \#loc
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.partial.descriptor=提供的實參數量({0})少於指定的佔位符數(至少 {1}) \#loc
jvm.inspection.logging.placeholder.count.matches.argument.count.incorrect.problem.descriptor=非法格式字串指定符 \#loc
jvm.inspection.logging.placeholder.count.matches.argument.count.more.problem.descriptor=提供的實參數量({0})多於指定的佔位符數({1}) \#loc
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option=SLF4J 將 Log4j 2 用作實作
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.auto=自動檢查
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.no=否
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.yes=是
jvm.inspection.logging.similar.message.display.name=不可區分的日誌記錄呼叫
jvm.inspection.logging.similar.message.problem.descriptor=類似的日誌訊息
jvm.inspection.logging.similar.message.problem.min.similar.length=相似序列的最小長度
jvm.inspection.logging.similar.message.problem.skip.on.error=不報告具有 `error` 日誌級別的呼叫
jvm.inspection.logging.string.template.as.argument.all.levels.option=所有日誌級別
jvm.inspection.logging.string.template.as.argument.debug.level.and.lower.option=偵錯級別和更低
jvm.inspection.logging.string.template.as.argument.display.name=字串模板作為日誌記錄呼叫的實參
jvm.inspection.logging.string.template.as.argument.info.level.and.lower.option=資訊級別和更低
jvm.inspection.logging.string.template.as.argument.problem.descriptor=作為 <code>\#ref()</code> 日誌記錄呼叫實參的字串模板 \#loc
jvm.inspection.logging.string.template.as.argument.quickfix.name=取代為佔位符
jvm.inspection.logging.string.template.as.argument.skip.on.only.exception=當呼叫僅在訊息實參之後以異常作為實參時不發出警告。
jvm.inspection.logging.string.template.as.argument.skip.on.primitives=僅包含具有基元類型的表達式、其包裝器或字串時不發出警告
jvm.inspection.logging.string.template.as.argument.trace.level.option=追蹤級別
jvm.inspection.logging.string.template.as.argument.warn.level.and.lower.option=警告級別和更低
jvm.inspection.logging.string.template.as.argument.warn.on.label=警告物件\:
jvm.inspection.test.failed.line.display.name=測試中失敗的行
jvm.inspections.1.5.problem.descriptor=使用記錄為 @since {0}+ 的 API
jvm.inspections.1.7.problem.descriptor=使用自 1.6 以來通用的 API，這可能會導致 JDK {0} 出現編譯問題。
jvm.inspections.1.8.problem.descriptor=預設{0, choice, 0\#|1\#方法|2\#方法}不會被覆寫。它會導致 JDK {1} 出現編譯問題
jvm.inspections.1.8.problem.single.descriptor=預設方法 ''{0}'' 不會被覆寫。它會導致 JDK {1} 出現編譯問題
jvm.inspections.api.display.name=使用在組態的語言級別下不可用的 API
jvm.inspections.api.no.extension.class.description=不得擴展類別 ''{0}''
jvm.inspections.api.no.extension.display.name=不應擴展類別、接口或方法
jvm.inspections.api.no.extension.interface.extend.description=不得擴展接口 ''{0}''
jvm.inspections.api.no.extension.interface.implement.description=不得實作接口 ''{0}''
jvm.inspections.api.no.extension.method.overriding.description=不得覆寫方法 ''{0}''
jvm.inspections.api.no.extension.on.invalid.target.class.description={0} ''{1}'' 標有 ''@ApiStatus.NonExtendable''，但無法擴展
jvm.inspections.api.no.extension.on.invalid.target.method.description=方法 ''{0}'' 標有 ''@ApiStatus.NonExtendable''，但無法被覆寫
jvm.inspections.api.no.extension.on.redundant.target.method.description=註解 '@ApiStatus.NonExtendable' 冗餘
jvm.inspections.api.override.only.description=方法 ''{0}'' 只能覆寫
jvm.inspections.api.override.only.display.name=方法只能覆寫
jvm.inspections.api.override.only.on.invalid.class.description={0} ''{1}'' 標有 ''@ApiStatus.OverrideOnly''，但無法擴展，也無法覆寫其方法
jvm.inspections.api.override.only.on.invalid.method.description=方法 ''{0}'' 標有 ''@ApiStatus.OverrideOnly''，但無法被覆寫
jvm.inspections.api.override.only.on.invalid.method.redundant.description=註解 '@ApiStatus.OverrideOnly' 冗餘
jvm.inspections.assertequals.between.inconvertible.types.problem.descriptor=<code>\#ref()</code> 位於 ''{0}'' 和 ''{1}'' 不可轉換類型的物件之間 \#loc
jvm.inspections.assertnotequals.between.inconvertible.types.problem.descriptor=可能的冗餘斷言\: 比較不相容的類型 ''{0}'' 和 ''{1}''
jvm.inspections.assertnotsame.between.inconvertible.types.problem.descriptor=冗餘斷言\: 比較不相容的類型 ''{0}'' 和 ''{1}''
jvm.inspections.blocking.method.annotation.blocking=阻塞註解\:
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=新增阻塞註解
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=新增非阻塞註解
jvm.inspections.blocking.method.annotation.non-blocking=非阻塞註解\:
jvm.inspections.blocking.method.consider.suspend.context.non.blocking=考慮 Kotlin 掛起上下文非阻塞
jvm.inspections.blocking.method.consider.unknown.context.blocking=考慮未知上下文阻塞
jvm.inspections.blocking.method.consider.unknown.context.nonblocking=考慮未知上下文非阻塞
jvm.inspections.blocking.method.display.name=可能在非阻塞上下文中使用阻塞呼叫
jvm.inspections.blocking.method.in.implicit.ctr.problem.descriptor=在非阻塞上下文中使用來自隱式建構函式呼叫的阻塞呼叫可能會導致執行緒匱乏
jvm.inspections.blocking.method.in.implicit.ctr.problem.wildcard.descriptor=在{0}中使用來自隱式建構函式呼叫的阻塞呼叫可能會導致執行緒匱乏
jvm.inspections.blocking.method.problem.descriptor=在非阻塞上下文中使用阻塞呼叫可能會導致執行緒匱乏
jvm.inspections.blocking.method.problem.wildcard.descriptor=在{0}中使用阻塞呼叫可能會導致執行緒匱乏
jvm.inspections.collection.contains.url.problem.descriptor=''{0}'' 可能包含 URL 物件 \#loc
jvm.inspections.dependency.display.name=非法的軟體套件相依項
jvm.inspections.dependency.edit.rules.family=編輯相依關係規則
jvm.inspections.dependency.edit.rules.text=編輯相依關係規則“{0}”
jvm.inspections.dependency.intention.description=開啟一個對話框以組態作用域之間的相依關係規則。
jvm.inspections.dependency.on.internal.display.name=對內部軟體套件的非法相依
jvm.inspections.dependency.violator.problem.descriptor=違反相依關係規則 ''{0}.''
jvm.inspections.equals.hashcode.called.on.url.display.name=在 'URL' 物件上呼叫 'equals()' 或 'hashCode()'
jvm.inspections.equals.hashcode.called.on.url.problem.descriptor=在 URL 物件上呼叫 ''{0}''
jvm.inspections.group.name=JVM 語言
jvm.inspections.logging.frameworks.group.name=日誌記錄
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=已計劃移除的 API 也必須使用 '@Deprecated' 註解標記
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=已計劃移除的 API 上缺少 '@Deprecated' 註解
jvm.inspections.must.already.be.removed.api.current.version.description=API 必須在當前版本 {0} 中移除
jvm.inspections.must.already.be.removed.api.display.name=API 必須已移除
jvm.inspections.must.already.be.removed.api.earlier.version.description=API 必須已在版本 {0} 中移除，但當前版本為 {1}
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}'' 在已計劃從 {3} 中移除的{1} ''{2}'' 中宣告
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}'' 已計劃從 {1} 中移除
jvm.inspections.scheduled.for.removal.future.version=未來版本
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=覆寫方法 ''{0}'' 在已計劃從 {3} 中移除的{1} ''{2}'' 中宣告
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=覆寫方法 ''{0}'' 已計劃從 {1} 中移除
jvm.inspections.scheduled.for.removal.predefined.version=版本 {0}
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}'' 已計劃移除，因為其簽名參照了已計劃從 {3} 中移除的{1} ''{2}''
jvm.inspections.serializable.class.without.serialversionuid.display.name=不帶 'serialVersionUID' 的可序列化類別
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>\#ref</code> 未定義 'serialVersionUID' 欄位 \#loc
jvm.inspections.source.to.sink.flow.assigned.unknown=未知字串分配給安全變數
jvm.inspections.source.to.sink.flow.assigned.unsafe=不安全的字串分配給安全變數
jvm.inspections.source.to.sink.flow.common.unknown=未知字串在安全上下文中使用
jvm.inspections.source.to.sink.flow.common.unsafe=不安全字串在安全上下文中使用
jvm.inspections.source.to.sink.flow.display.name=不安全字串被傳遞至安全方法
jvm.inspections.source.to.sink.flow.passed.unknown=未知字串用作安全參數
jvm.inspections.source.to.sink.flow.passed.unsafe=不安全字串用作安全參數
jvm.inspections.source.to.sink.flow.returned.unknown=未知字串返回自安全方法
jvm.inspections.source.to.sink.flow.returned.unsafe=不安全字串返回自安全方法
jvm.inspections.source.to.sink.flow.too.complex=太複雜，無法檢查字串在安全上下文中是否安全
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods=將 private 方法的參數視為安全
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods.comment=如果啟用，則 private 方法的參數會被視為安全，否則將被視為未知
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex=報告情況是否太複雜而無法檢查
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex.comment=報告由於複雜性而無法檢查的物件
jvm.inspections.source.unsafe.to.sink.flow.checked.types=檢查的類型\:
jvm.inspections.source.unsafe.to.sink.flow.config=未被污染的註解將被新增到元素 ''{0}'' 的檢查設定中
jvm.inspections.source.unsafe.to.sink.flow.depth.inside=方法內部的分析深度\:
jvm.inspections.source.unsafe.to.sink.flow.impossible=元素 ''{0}'' 不支持未被污染的註解。該元素將被跳過
jvm.inspections.source.unsafe.to.sink.flow.index.parameter=參數索引
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.command.name=標記為需要驗證
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=標記為需要驗證
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=將元素標記為需要驗證
jvm.inspections.source.unsafe.to.sink.flow.not.number=非數字
jvm.inspections.source.unsafe.to.sink.flow.place.class.column.title=上下文的類別名
jvm.inspections.source.unsafe.to.sink.flow.place.method.column.title=上下文的方法名稱正則表達式
jvm.inspections.source.unsafe.to.sink.flow.preview=新增 '@Untainted' 註解
jvm.inspections.source.unsafe.to.sink.flow.preview.propagate=顯示傳播樹
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.family=傳播樹
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.preview=開啟工具視窗以檢查安全註解的傳播
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.text=從此處顯示傳播樹
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.annotate=註解除排除外的所有物件
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.title=不安全的成員
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.unsafe.flow=不安全的流
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.arguments=參數
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.classes=類別
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.comment=這些方法會將限定符標記為 'untainted' (實參必須用逗號分隔)
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.methods=方法
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.table=清理限定符的方法\:
jvm.inspections.source.unsafe.to.sink.flow.safe.class=安全類別\:
jvm.inspections.source.unsafe.to.sink.flow.safe.class.comment=這些類別不能包含不安全的資料
jvm.inspections.source.unsafe.to.sink.flow.show.unknown.object=報告未知物件
jvm.inspections.source.unsafe.to.sink.flow.show.unsafe.object=報告不安全的物件
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations=被污染的註解\:
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations.comment=這些註解將在分析過程中用作 '@Tainted' 註解
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods=被污染的方法\:
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods.comment=這些方法被視為只返回不安全的物件
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters=被污染的參數\:
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters.comment=這些參數被視為具有 '@Tainted' 註解
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations=未被污染的註解\:
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations.comment=這些註解將在分析過程中用作 '@Untainted' 註解。如果此列表中的第一個註解存在於類別路徑中，則該註解將用於傳播。
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields=未被污染的欄位\:
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.comment=這些欄位被視為只包含安全物件
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.name=欄位名稱
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods=未被污染的方法\:
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods.comment=這些方法被視為只返回安全的物件
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters=未被污染的參數\:
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters.comment=這些參數被視為具有 '@Untainted' 註解
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments=如果接收器和實參未被污染，則認為外部方法未被污染
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments.comment=如果啟用，則當前類別外部的外部方法在其接收器和實參安全的情況下將被視為安全。在某些情況下，它不適用，但對於無狀態類別可能很有用。否則，所有外部方法都會被視為不安全
jvm.inspections.string.touppercase.tolowercase.without.locale.description=在未使用國際化字串指定區域設定的情況下呼叫 <code>String.{0}()</code> \#loc
jvm.inspections.system.get.property.display.name=對 'System.getProperty(str)' 的呼叫可以簡化
jvm.inspections.system.get.property.problem.descriptor=可以簡化 ''{0} 的呼叫 ''<code>\#ref</code>
jvm.inspections.test.case.in.product.source.display.name=產品源中的測試
jvm.inspections.test.case.in.product.source.problem.descriptor=測試用例 <code>\#ref</code> 可能應被放置在測試源樹中 \#loc
jvm.inspections.test.case.with.constructor.display.name=具有非普通建構函式的 TestCase
jvm.inspections.test.case.with.constructor.problem.descriptor=建構函式 <code>\#ref()</code> 中的初始化邏輯，而不是 'setup()' 生存期方法 \#loc
jvm.inspections.test.case.with.constructor.problem.descriptor.initializer=初始設定式中的初始化邏輯，而不是 'setup()' 生存期方法
jvm.inspections.test.case.without.test.methods.display.name=沒有測試的測試類別
jvm.inspections.test.case.without.test.methods.option=忽略具有帶測試方法的超類別的測試用例
jvm.inspections.test.case.without.test.methods.problem.descriptor=測試類別 <code>\#ref</code> 沒有測試 \#loc
jvm.inspections.test.frameworks.group.name=測試框架
jvm.inspections.test.method.in.product.source.problem.descriptor=測試方法 <code>\#ref()</code> 可能應被放置在測試源樹中 \#loc
jvm.inspections.test.method.without.assertion.display.name=不帶斷言的測試方法
jvm.inspections.test.method.without.assertion.problem.descriptor=測試方法 <code>\#ref()</code> 不包含斷言 \#loc
jvm.inspections.testonly.class.reference=在生產程式碼中參照純測試類別
jvm.inspections.testonly.display.name=生產程式碼中的純測試用法
jvm.inspections.testonly.field.reference=在生產程式碼中參照純測試欄位
jvm.inspections.testonly.method.call=在生產程式碼中呼叫純測試方法
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting 對 @TestOnly 程式碼意義不大
jvm.inspections.thread.run.display.name=呼叫 'Thread.run()'
jvm.inspections.unstable.api.usage.annotations.list=不穩定的 API 註解\:
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}'' 在標記為 @{3} 的不穩定{1} ''{2}'' 中宣告
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}'' 使用 @{1} 標記為不穩定
jvm.inspections.unstable.api.usage.display.name=不穩定的 API 用法
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=忽略此專案中宣告的 API
jvm.inspections.unstable.api.usage.ignore.inside.imports=在匯入內忽略
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=覆寫方法 ''{0}'' 在標記為 @{3} 的不穩定{1} ''{2}'' 中宣告
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=覆寫方法 ''{0}'' 使用 @{1} 標記為不穩定
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}'' 不穩定，因為其簽名參照了標記為 @{3} 的不穩定{1} ''{2}''
jvm.inspections.unstable.type.used.in.class.signature.description=類別必須使用 ''@{0}'' 註解標記，因為其宣告參照了不穩定的類型 ''{1}''
jvm.inspections.unstable.type.used.in.field.signature.description=欄位必須使用 ''@{0}'' 註解標記，因為其類型參照了不穩定的類型 ''{1}''
jvm.inspections.unstable.type.used.in.method.signature.description=方法必須使用 ''@{0}'' 註解標記，因為其簽名參照了不穩定的類型 ''{1}''
jvm.inspections.unstable.type.used.in.signature.display.name=簽名中使用了不穩定的類型
jvm.inspections.usages.of.obsolete.api.description=使用了過時的 API
jvm.inspections.usages.of.obsolete.api.display.name=ApiStatus.@Obsolete 的用法
jvm.options.general.color.descriptor.logging.string.placeholder=日誌字串//佔位符
propagated.from=傳播原因\:
propagated.to=要傳播的目標\:
remove.suppress.comment.fix.family.name=移除 //{0}
title.uast=UAST

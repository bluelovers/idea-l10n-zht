action.AnalyzeUnloadablePlugins.progress.title=正在分析延伸模組({0})
action.AnalyzeUnloadablePlugins.text=分析可移除延伸模組
action.DevKit.NewAction.text=動作
action.DevKit.NewMessageBundle.action.name.create.new.message.bundle=建立新消息捆綁包 ''{0}''
action.DevKit.NewMessageBundle.description=建立新的訊息捆綁包類別和相應的屬性檔案
action.DevKit.NewMessageBundle.error.message.do.not.put.bundle.to.impl.module=目前不建議為 .impl 模組建立單獨的捆綁包，請改為使用相應 API 模組中的捆綁包
action.DevKit.NewMessageBundle.error.message.folder.already.exists={1} 下已存在 ''{0}'' 目錄
action.DevKit.NewMessageBundle.error.message.multiple.content.roots.for.module={0} 的多個內容根
action.DevKit.NewMessageBundle.error.message.under.sources.root={0} 在來源根下
action.DevKit.NewMessageBundle.error.title.cannot.create.new.message.bundle=無法建立新消息捆綁包
action.DevKit.NewMessageBundle.label.bundle.name=捆綁包名稱\:
action.DevKit.NewMessageBundle.notification.content.cannot.create.resources.root.for.properties.file=無法為屬性檔案 {0} 建立資源根
action.DevKit.NewMessageBundle.notification.title.cannot.create.resources.root.for.properties.file=無法建立新消息捆綁包
action.DevKit.NewMessageBundle.text=訊息捆綁包
action.DevKit.NewMessageBundle.title.create.new.message.bundle=建立新消息捆綁包
action.DevKit.NewMessageBundleObject.text=訊息捆綁包
action.DevKit.NewRemoteDevModule.action.name.create.remdev.module=建立新的遠端開發模組 ''{0}''
action.DevKit.NewRemoteDevModule.error.title.cannot.create.remdev.module=無法建立新的遠端開發模組
action.DevKit.NewService.description=建立一個新的 @Service 類別來管理記憶體中的 IDE 狀態
action.DevKit.NewService.text=服務
action.DevKit.NewStartupActivity.description=建立將在專案開啟時執行的新活動
action.DevKit.NewStartupActivity.text=啟動活動
action.DevKit.NewState.description=建立一個新的 PersistentStateComponent 類別，該類將用於存儲和共享設定
action.DevKit.NewState.text=持久狀態
action.DevKit.NewToolwindow.text=工具視窗
action.DumpCleanTestData.error.source.destination.must.differ=來源根和目標根應不同
action.DumpCleanTestData.file.chooser.destination.description=將放置無醒目提示標記的副本的目錄
action.DumpCleanTestData.file.chooser.source.description=包含醒目提示測試資料的目錄
action.DumpCleanTestData.file.chooser.title=選擇目錄
action.DumpCleanTestData.text=傾印醒目提示的無標記資料
action.GenerateExternalization.text=生成外部化
action.MakeAllJarsAction.text=準備所有要部署的延伸模組
action.MakeJarAction.text=準備部署
action.NewAction.description=建立新動作
action.NewAction.text=動作
action.NewRemoteDevModule.text=遠端開發模組…
action.ShowHelpPageById.dialog.enter.help.id=輸入幫助 ID\:
action.ShowHelpPageById.dialog.title=顯示幫助頁面
action.ShowHelpPageById.text=按 ID 顯示幫助頁面
action.ShowSerializedXml.dialog.title=''{0}'' 的序列化 XML
action.ShowSerializedXml.message.cannot.find.class=找不到類別 ''{0}''
action.ShowSerializedXml.message.cannot.generate.class=無法生成類別 ''{0}''\: {1}
action.ShowSerializedXml.message.caret.must.be.at.class.identifier=文字游標應位於類別名處
action.ShowSerializedXml.text=顯示類別的序列化 XML
action.ShuffleNamesAction.text=對名稱進行重排/加擾/匿名/置換
action.TestData.Navigate.text=導覽到測試資料
action.ToggleHighlightingMarkup.text=切換預期的醒目提示標記
action.UpdateIdeFromSources.description=從當前開啟的原始碼建置 IntelliJ IDEA 的安裝，並用結果更新當前(或其他)安裝。
action.UpdateIdeFromSources.text=從原始碼更新 IDE…
action.UpdateIdeFromSourcesAction.copy.copy.new.files.text=正在複製新檔案
action.UpdateIdeFromSourcesAction.copy.delete.old.files.text=正在刪除舊檔案
action.UpdateIdeFromSourcesAction.copy.progress.text=正在將檔案複製到 IDE 發行版…
action.UpdateIdeFromSourcesAction.dialog.message.directory.not.writable=目錄 {0} 不可寫
action.UpdateIdeFromSourcesAction.error.config.or.system.directory.under.home=無法更新 {0} 安裝，因為 ''{1}'' 屬性指向它下面的目錄，並且它在更新過程中將被清除。
action.UpdateIdeFromSourcesAction.error.empty.dir=建置目錄 ''{0}'' 為空。
action.UpdateIdeFromSourcesAction.error.ide.cannot.restart=此 IDE 無法自行重啟，因此不支持從原始碼更新
action.UpdateIdeFromSourcesAction.error.no.module=在專案中找不到建置腳本模組 ''{0}''。
action.UpdateIdeFromSourcesAction.error.no.sdk=專案SDK未定義。
action.UpdateIdeFromSourcesAction.error.work.home.not.valid.ide.home={0} 不是有效的 IDE 主目錄\: {1}
action.UpdateIdeFromSourcesAction.error.work.home.not.valid.ide.home.not.directory=它不是目錄
action.UpdateIdeFromSourcesAction.error.work.home.not.valid.ide.home.not.exists=安裝目錄無效\: ''{0}'' 不存在
action.UpdateIdeFromSourcesAction.notification.action.view.debug.log=檢視偵錯日誌
action.UpdateIdeFromSourcesAction.notification.action.view.output=檢視輸出
action.UpdateIdeFromSourcesAction.notification.content=新安裝在{0}處準備。
action.UpdateIdeFromSourcesAction.notification.title=從原始碼更新
action.UpdateIdeFromSourcesAction.settings.do.not.show.description=您可以呼叫“從源設定更新 IDE”動作來更改設定
action.UpdateIdeFromSourcesAction.settings.enabled.plugins.only=僅建置已啟用的延伸模組
action.UpdateIdeFromSourcesAction.settings.installation.choose.ide.directory.title=選擇 IDE 安裝目錄
action.UpdateIdeFromSourcesAction.settings.ok.button=更新
action.UpdateIdeFromSourcesAction.settings.restart.automatically=自動重啟
action.UpdateIdeFromSourcesAction.settings.row.ide.installation=IDE 安裝\:
action.UpdateIdeFromSourcesAction.settings.title=從原始碼更新 IDE
action.UpdateIdeFromSourcesAction.task.failed.content=建置腳本完成，錯誤程式碼為 {0}
action.UpdateIdeFromSourcesAction.task.failed.title=從原始碼更新失敗
action.UpdateIdeFromSourcesAction.task.title=從原始碼更新
action.UpdateIdeFromSourcesAction.update.progress.delete=正在刪除 {0}
action.UpdateIdeFromSourcesAction.update.progress.start.script=正在執行分發建置腳本
action.UpdateIdeFromSourcesAction.update.progress.text=正在從原始碼更新 IDE…
action.UpdateIdeFromSourcesSettings.text=從原始碼設定更新 IDE…
action.create.message.bundle.title=新消息捆綁包
action.name.new.action=建立新動作
action.name.new.devkit.service=建立服務類別
action.name.new.devkit.startup.activity=建立新的 DevKit ProjectActivity
action.name.new.state.service=建立 PersistentStateComponent 類別
action.or.group.reference=動作 ID 參照
api.compose.description=用於建置精美 UI 的開源宣告式框架
api.lsp.description=實作 IDE 和語言伺服器之間的通信
category.platform.description=IntelliJ 平台模組提供的 API
category.platform.title=IntelliJ 平台
category.plugins.description=語言和框架
category.plugins.title=延伸模組
code.convert.experimental.feature.id.cannot.resolve=無法解析功能 ''{0}''
code.convert.experimental.feature.no.description=無描述
code.convert.extension.point.declaration=無法解析擴展點 ''{0}''
code.convert.notification.group.cannot.resolve=無法解析通知組 id ''{0}''
code.convert.registry.key.cannot.resolve=無法解析註冊表鍵 ''{0}''
code.convert.registry.key.no.default.value=無預設值
code.convert.registry.key.no.description=無描述
command.create.bundle.properties=建立捆綁包 .properties 檔案
command.implement.externalizable=實作可外部化
command.register.startup.activity=在 plugin.xml 中註冊 ProjectActivity
command.register.state.settings=在 plugin.xml 中註冊設定
compose.hot.reload.failed.to.download.compose.hot.reload.agent=無法下載 'Compose Hot Reload' 代理
compose.hot.reload.hot.reload.agent.has.been.saved=重新啟動您的執行組態。Compose Hot Reload 代理已儲存至 ''{0}''。
compose.hot.reload.restart.your.run.configuration=Compose Hot Reload 代理正在下載至 ''{0}''。下載完成後，請重新啟動執行組態。
create.description.file=建立描述檔案{0}
create.description.file.family.name=建立描述檔案
deployment.cleanup=清理 {0} 目錄
deployment.directory.location=選擇 {0} 目錄位置
deployment.title=延伸模組部署
deployment.view.delete=確定刪除{0}?
deployment.view.meta-inf.label={0} 路徑
deployment.view.select=選擇 {0}
descriptor.documentation.yaml.schema.display.name=檔案描述子文檔
devkit.unstable.api.usage.ignore.declared.inside.this.project=忽略此專案中宣告的不穩定 API
dialog.title.new.devkit.action=新增動作
dialog.title.new.devkit.service=新增服務
dialog.title.new.devkit.startup.activity=新增專案活動
dialog.title.new.devkit.state=新增持久狀態組件
error.cannot.resolve.extension.point=無法解析相依項中的擴展點 ''{0}''
error.cannot.resolve.extension.point.missing.dependency=缺少使用擴展點 ''{0}'' 的相依關係宣告
error.cannot.resolve.extension.point.missing.dependency.fix.family.name=新增缺少的 <depends>
error.cannot.resolve.plugin=無法解析相依項中的延伸模組 ''{0}''
error.cannot.resolve.plugin.reference.link.title=(參照\: 延伸模組相依項)
error.file.not.found=找不到檔案 
error.file.not.found.message=檔案 ''{0}'' 不存在
error.message.cannot.find.module=找不到模組 ''{0}''
error.message.cannot.find.resource.file=在模組 ''{1}'' 中找不到 ''{0}'' 檔案
error.no.plugin.xml=找不到 plugin.xml 檔案
error.occurred=出錯
error.plugin.xml.readonly=無法處理唯讀 plugin.xml 檔案\: {0}
error.plugin.xml.tag.invalid=<Invalid>
extension.point.documentation.field.required.can.be.empty.suffix=(必填，允許為空)
extension.point.documentation.field.required.suffix=(必填)
extension.point.documentation.implementation.section=擴展點實作
extension.point.documentation.link.platform.explorer=在 IntelliJ Platform Explorer 中顯示用法
file.templates=模板
file.templates.new.plugin=新延伸模組
group.DevkitNewActions.text=Plugin DevKit
group.Internal.DevKit.text=DevKit
group.PluginDeployActions.text=延伸模組部署動作
gutter.name.test.data.line.marker=測試資料
gutter.related.extension.declaration=宣告
gutter.related.navigation.choose.action=選擇一個動作
gutter.related.navigation.choose.action.group=選擇動作組
gutter.related.navigation.choose.component=選擇組件
gutter.related.navigation.choose.extension=選擇擴展
gutter.related.navigation.choose.extension.point=選擇擴展點
gutter.related.navigation.choose.listener=選擇偵聽器
gutter.related.navigation.popup.description.tooltip=描述
gutter.related.navigation.popup.template.title=選擇模板
gutter.related.navigation.popup.template.tooltip=在模板前面/後面
gutter.related.option.before.after.templates=在模板前面/後面
gutter.related.option.description=描述
gutter.related.option.name=描述/在模板前面|後面
implemented.at.runtime.dom=在執行時實作的 DOM 元素
info.message=資訊
inlay.threading.description=IntelliJ 平台執行緒處理和讀/寫鎖相關註解，例如，<code>@RequiresEdt</code>、<code>@RequiresReadLock</code>。<br><br>實驗性，僅在 IDEA 專案中啟用。
inlay.threading.name=IJ 平台執行緒處理
inspection.action.is.not.preview.friendly.display.name=欄位會阻塞意圖預覽
inspection.action.presentation.instantiated.in.ctor.display.name=動作示範的預先建立
inspection.action.presentation.instantiated.in.ctor.message=在建構函式中實例化的動作示範
inspection.can.be.dumb.aware.message=如果不存取索引，可以設為 DumbAware
inspection.can.be.dumb.aware.name=可以為 DumbAware
inspection.can.be.dumb.aware.quickfix.add.to.ignore=忽略 ''{0}''
inspection.can.be.dumb.aware.settings.ignore.classes.dialog.title=指定要忽略的類別
inspection.can.be.dumb.aware.settings.ignore.classes.title=忽略類別列表\:
inspection.cancellation.check.in.loops.display.name=迴圈中的取消檢查
inspection.cancellation.check.in.loops.message=取消檢查 ''{0}'' 應為循環體中的第一條語句
inspection.content.module.namespace.invalid=命名空間必須符合 {0}
inspection.content.module.namespace.invalid.length=命名空間長度必須介於 5 到 30 個字元之間
inspection.content.module.namespace.mismatch=所有 ''content'' 元素必須定義相同的命名空間(第一個命名空間\: ''{0}'')
inspection.content.module.namespace.missing=具有非 private 模組的 'content' 需要命名空間
inspection.content.module.namespace.missing.fix.add.family.name=新增命名空間
inspection.content.module.namespace.missing.fix.add.name=新增 ''{0}'' 命名空間
inspection.content.module.namespace.name=內容模組命名空間驗證
inspection.content.module.visibility.internal=''{0}'' 模組為 internal，並在 ''{2}'' 中的命名空間 ''{1}'' 中宣告，因此無法從在 ''{5}'' 中的命名空間 ''{4}'' 中宣告的模組 ''{3}'' 存取
inspection.content.module.visibility.internal.current.namespace.missing=''{0}'' 模組為 internal，並在 ''{2}'' 中的命名空間 ''{1}'' 中宣告，因此無法從在 ''{4}'' 中宣告但沒有命名空間的模組 ''{3}'' 存取
inspection.content.module.visibility.internal.declared.in.plugin=''{0}'' 模組為 internal，並在 ''{2}'' 中的命名空間 ''{1}'' 中宣告，因此無法從在命名空間 ''{4}'' 中宣告的延伸模組 ''{3}'' 存取
inspection.content.module.visibility.internal.declared.in.plugin.current.namespace.missing=''{0}'' 模組為 internal，並在 ''{2}'' 中的命名空間 ''{1}'' 中宣告，因此無法從已宣告但沒有命名空間的延伸模組 ''{3}'' 存取
inspection.content.module.visibility.internal.declared.in.plugin.dependency.namespace.missing=''{0}'' 模組為 internal，並在 ''{1}'' 中宣告但沒有命名空間，因此無法從在命名空間 ''{3}'' 中宣告的延伸模組 ''{2}'' 存取
inspection.content.module.visibility.internal.dependency.namespace.missing=''{0}'' 模組為 internal，並在 ''{1}'' 中宣告但沒有命名空間，因此無法從在 ''{4}'' 中的命名空間 ''{3}'' 中宣告的模組 ''{2}'' 存取
inspection.content.module.visibility.internal.fix.set.namespace.family.name=設定命名空間
inspection.content.module.visibility.internal.fix.set.namespace.to=將 ''{0}'' 中的命名空間設定為 ''{1}''
inspection.content.module.visibility.name=無法存取內容模組相依項
inspection.content.module.visibility.private=''{0}'' 模組為 private，並在延伸模組 ''{1}'' 中宣告，因此無法從在延伸模組 ''{3}'' 中宣告的模組 ''{2}'' 存取
inspection.content.module.visibility.private.accessed.from.plugin=''{0}'' 模組為 private，並在延伸模組 ''{1}'' 中宣告，因此無法從延伸模組 ''{2}'' 存取
inspection.content.module.visibility.private.fix.change.visibility.family.name=更改模組可見性
inspection.content.module.visibility.private.fix.change.visibility.to.internal.name=將模組 ''{0}'' 設為{1}
inspection.extension.class.should.be.final.and.non.public.display.name=擴展類別應為 final 和非 public
inspection.extension.class.should.be.final.text=擴展類別應為 final
inspection.extension.class.should.not.be.public.service=服務實作不應設為 public。如果服務要在其模組之外使用，請從中提取一個接口，並在 plugin.xml 中將其指定為 serviceInterface。
inspection.extension.class.should.not.be.public.text=擴展類別應為 public
inspection.extension.registered.as.component.message=一個類別不得同時註冊為擴展和組件
inspection.extension.registered.as.service.message=一個類別不得同時註冊為擴展和服務
inspection.extension.registered.as.service.or.component.display.name=註冊為服務/組件的擴展
inspection.file.equals.usage.display.name=File.equals() 用法
inspection.incorrect.parent.disposable.display.name=不正確的 parentDisposable 參數
inspection.incorrect.service.retrieving.display.name=不正確的服務檢索
inspection.incorrect.service.retrieving.mismatch.for.app.level=應用程式級服務作為專案級服務進行檢索
inspection.incorrect.service.retrieving.mismatch.for.project.level=專案級服務作為應用程式級服務進行檢索
inspection.incorrect.service.retrieving.not.registered=''{0}'' 類別未註冊為服務
inspection.insert.cancellation.check.fix.message=插入取消檢查
inspection.inspection.description.not.found.inspection.display.name=檢查描述檢查器
inspection.inspection.unspecified.actions.place.display.name=未指定的動作位置
inspection.inspection.using.gray.colors.display.name=使用新的 Color(a,a,a)
inspection.intention.description.not.found.inspection.display.name=意圖描述檢查器
inspection.keymap.xml.inspection.name=按鍵映射 XML 有效性
inspection.light.service.migration.already.annotated.message=使用 '@Service' 註解的服務類別不得在 plugin.xml 中註冊
inspection.light.service.migration.app.level.fix=使用 '@Service' 註解服務類別並從 'plugin.xml' 檔案中移除其註冊
inspection.light.service.migration.display.name=服務可被轉換為輕量服務
inspection.light.service.migration.family.name=轉換為輕量服務
inspection.light.service.migration.message=服務可被轉換為輕量服務
inspection.light.service.migration.project.level.fix=使用 '@Service(Service.Level.PROJECT)' 註解服務類別，並從 'plugin.xml' 檔案中移除其註冊
inspection.light.service.must.be.concrete.class.message=輕量服務必須為具體類別，不能為抽象類別或者為接口。\nIntelliJ 平台依靠具體的實作類別來建立和管理服務實例。如果沒有具體的實作，平台將無法建立服務的實例，並且該服務將不能供延伸模組使用。\n要解決這個問題，您應該為服務定義一個具體的實作類別，並使用 '@Service' 對其進行註解。
inspection.light.service.must.be.final.display.name=輕量服務必須為 final
inspection.light.service.must.be.final.message=輕量服務必須為 final
inspection.message.accessible.context.not.defined.for.jpanel=沒有為 JPanel 定義可存取上下文
inspection.message.field.may.prevent.intention.preview.to.work.properly=欄位可能會阻止意圖預覽正常工作
inspection.message.method.annotated.with.returns.value.annotated.with=使用 {0} 註解的方法返回使用 {1} 註解的值
inspection.message.return.value.without.path.annotation.where.expected=在應為 {0} 的位置，返回值缺少路徑註解
inspection.message.unnecessary.safe.field.annotation=不必要的 @SafeFieldForPreview註解\: 該欄位類型已被視為安全
inspection.migrate.to.opt.control.display.name=遷移到 getOptionPane()
inspection.migrate.to.opt.control.fix=轉換為 OptPane
inspection.migrate.to.opt.control.message=可自動轉換為 OptPane
inspection.mismatched.light.service.level.and.ctor.app.level.ctor.required=應用程式級服務需要一個無實參或 'kotlinx.coroutines.CoroutineScope' 類型的單參數建構函式
inspection.mismatched.light.service.level.and.ctor.display.name=輕量服務級別與建構函式之間的不符合
inspection.mismatched.light.service.level.and.ctor.project.level.required=具有接受 'Project' 類型的參數的建構函式的輕量服務必須指定 '@Service(Service.Level.PROJECT)'
inspection.mismatched.light.service.level.and.ctor.specify.project.level.fix=在 '@Service' 註解中指定 'Service.Level.PROJECT' 參數
inspection.missing.accessible.context.display.name=缺少可存取上下文
inspection.missing.recent.api.display.name=在舊 IDE 中無法使用 IntelliJ API
inspection.module.not.registered.as.plugin.content.fix.add=註冊為 ''{0}'' 延伸模組的內容模組
inspection.module.not.registered.as.plugin.content.message=''{0}'' 模組未在任何延伸模組檔案描述子中宣告為內容
inspection.module.not.registered.as.plugin.content.name=模組未在任何延伸模組中宣告為內容
inspection.non.default.constructor.display.name=服務和擴展類別的非預設建構函式
inspection.path.annotation.display.name=路徑註解用法問題
inspection.plugin.xml.dynamic.plugin.display.name=Plugin.xml 動態延伸模組驗證
inspection.plugin.xml.extension.registration.configurable.should.define.displayName.or.key.attribute=定義與 'Configurable.getDisplayName()' 實作符合的 'displayName' 或 'key' 特性
inspection.plugin.xml.extension.registration.display.name=Plugin.xml 擴展程序註冊
inspection.plugin.xml.extension.registration.intention.redundant.description.directory=指定的描述目錄與預設目錄名符合
inspection.plugin.xml.extension.registration.should.define.externalidprefix.attribute=<html>定義 externalIdPrefix 特性，請參閱<a href\='https\://plugins.jetbrains.com/docs/intellij/stub-indexes.html?from\=PluginXmlExtensionRegistrationInspection'>存根索引</a></html>
inspection.plugin.xml.extension.registration.should.define.id.attribute=定義與 'StatusBarWidgetFactory.getId()' 實作符合的 'id' 特性
inspection.plugin.xml.extension.registration.should.define.language.attribute=擴展 ''{0}'' 應定義 ''language'' 特性
inspection.plugin.xml.extension.registration.should.define.language.tag=擴展 ''{0}'' 應定義 ''language'' 標記
inspection.plugin.xml.extension.registration.should.define.language.tag.family.name=新增語言標記
inspection.plugin.xml.plugin.logo.display.name=延伸模組徽標檢查
inspection.plugin.xml.registration.check.display.name=plugin.xml 註冊檢查
inspection.plugin.xml.validity.display.name=Plugin.xml 有效性
inspection.potential.deadlock.during.service.init.display.name=服務初始化中的潛在死鎖
inspection.potential.deadlock.during.service.init.message.context=({0}在 {1}中呼叫)
inspection.potential.deadlock.during.service.init.message.context.constructor=''{0}'' 建構函式或 init 塊
inspection.potential.deadlock.during.service.init.message.context.field=''{0}'' 欄位初始設定式
inspection.potential.deadlock.during.service.init.message.context.instance.initializer=實例初始化塊
inspection.potential.deadlock.during.service.init.message.context.method=''{0}'' 方法
inspection.potential.deadlock.during.service.init.message.context.static.initializer=static 初始化塊
inspection.potential.deadlock.during.service.init.message.invoke.and.wait=請勿在服務初始化期間執行 ''invokeAndWait'' {0}
inspection.potential.deadlock.during.service.init.message.read=請勿在服務初始化期間執行讀取動作{0}
inspection.potential.deadlock.during.service.init.message.write=請勿在服務初始化期間執行寫入動作{0}
inspection.presentation.annotation.display.name=@Presentation 中的圖示路徑無效
inspection.product.modules.xml.display.name=Product-modules.xml 有效性
inspection.psi.element.concatenation.display.name=使用 PsiElement 字串表示生成新表達式是不正確的
inspection.quick.fix.get.family.name.violation.display.name=QuickFix 的 getFamilyName() 實作不得依賴於特定上下文
inspection.remote.dev.missing.runtime.dependency.fix.add=新增 ''{0}'' 相依項
inspection.remote.dev.missing.runtime.dependency.message=當前模組 ''{0}'' 的名稱以 ''{1}'' 結尾，但缺少對 ''{2}'' 的相依項
inspection.remote.dev.missing.runtime.dependency.name=缺少前端或後端執行時相依項
inspection.renamer.dialog.description=<html>是否還要重新命名檢查描述檔案並更改短名稱?<br/><b>警告\: 它可能會破壞現有的檢查組態檔案和禁止註釋。</b></html>
inspection.renamer.dialog.title=重新命名檢查描述檔案並更改短名稱
inspection.renamer.entity.name=元素
inspection.renamer.option.name=重新命名檢查描述檔案並更改短名稱
inspection.serializable.constructor.message=非預設建構函式應使用 @PropertyMapping 進行註解
inspection.serializable.ctor.display.name=可序列化類別中的非預設建構函式
inspection.simplifiable.service.retrieving.can.be.replaced.with=可被取代為 ''{0}.{1}()'' 呼叫
inspection.simplifiable.service.retrieving.display.name=可簡化的服務檢索
inspection.simplifiable.service.retrieving.replace.with=取代為 ''{0}.{1}()'' 呼叫
inspection.stateful.ep.display.name=有狀態擴展
inspection.threading.concurrency.display.name=執行緒和並發問題
inspection.threading.concurrency.option.check.missing.annotations.methods=檢查 public 方法的缺失註解
inspection.threading.concurrency.option.group.inside.requires.edt=@RequiresEdt 內的檢查\:
inspection.threading.concurrency.option.group.inside.requires.edt.check.requires.read.lock=@RequiresReadLock
inspection.threading.concurrency.option.group.inside.requires.edt.check.requires.write.lock=@RequiresWriteLock
inspection.threading.concurrency.violation.call.inside.method=使用 ''@{0}'' 註解的方法不得從使用 ''@{1}'' 註解的方法中呼叫
inspection.threading.concurrency.violation.unannotated.method.contains.call=未註解的方法呼叫了使用 ''@{0}'' 註解的方法
inspection.threading.concurrency.violation.unannotated.method.contains.call.multiple.annotations=未註解的方法呼叫了使用多線程註解的方法
inspection.token.set.in.parser.definition=ParserDefinition 中的 TokenSet 參照了非平台類別
inspection.token.set.in.parser.definition.display.name=在 ParserDefinition 中宣告了非平台 TokenSet
inspection.u.element.as.psi.display.name=UElement 作為 PsiElement 的用法
inspection.uast.hinted.visitor.adapter.hints.missing.hint=''{0}'' 未使用，因為適配器提示中未提供 ''{1}''
inspection.uast.hinted.visitor.adapter.hints.problem.display.name='UastHintedVisitorAdapter' 提示問題
inspection.uast.hinted.visitor.adapter.hints.redundant.hint=提示中提供了 ''{0}''，但該元素未在訪問者中存取
inspection.undesirable.class.usage.display.name=不需要的類別用法
inspection.unknown.id.in.meta.information.name=元資訊中的未知檢查 ID
inspection.unsafe.return.statement.visitor.display.name=不安全的 return 語句存取者
inspection.unsafe.vfs.recursion.display.name=不安全的 VFS 遞迴
inspection.use.DPI.aware.borders.display.name=使用 DPI 感知邊界
inspection.use.DPI.aware.insets.display.name=使用 DPI 感知嵌入
inspection.use.JB.color.display.name=使用 Darcula 感知 JBColor
inspection.use.intellij.virtual.threads.display.name=使用 'IntelliJVirtualThreads.ofVirtual'
inspection.use.intellij.virtual.threads.fix.family.name=取代為 'IntelliJVirtualThreads.ofVirtual()'
inspection.use.intellij.virtual.threads.message=使用 'IntelliJVirtualThreads.ofVirtual()' 代替 'Thread.ofVirtual()'
inspection.use.plugin.id.equals.display.name=使用 'PluginId\#equals(Object)'
inspection.use.primitive.types.equals.display.name=將 'PsiType\#equals(Object)' 與基元類型結合使用
inspection.use.virtual.file.equals.display.name=使用 'VirtualFile\#equals(Object)'
inspections.IncorrectParentDisposableInspection.do.not.use.as.disposable=請勿在延伸模組程式碼中將 {0} 用作可處置物件
inspections.IncorrectParentDisposableInspection.documentation.link.title=選擇可處置的父級
inspections.action.update.thread.display.name=缺少 ActionUpdateThread
inspections.action.update.thread.message=覆寫 'getActionUpdateThread' 並選擇 'EDT' 或 'BGT'
inspections.application.service.as.static.final.field.message=不得將套用程序服務分配給 static final 欄位
inspections.application.service.as.static.final.field.or.property.display.name=指定至 static final 欄位或不可變屬性的應用程式服務
inspections.awt.color.used=使用了 'java.awt.Color' 而不是 'JBColor'
inspections.awt.color.used.fix.use.jb.color.constant.family.name=轉換為 'JBColor' 常數
inspections.awt.color.used.fix.use.jb.color.fix.family.name=轉換為 'JBColor'
inspections.calling.method.should.be.rbc.annotated=呼叫方法應使用 @RequresBlockingContext 進行註解
inspections.calling.method.should.be.rbc.annotated.annotate.fix=使用 '@RequiresBlockingContext' 註解呼叫方法
inspections.calling.method.should.be.rbc.annotated.message=呼叫方法應使用 '@RequiresBlockingContext' 進行註解
inspections.component.not.registered.message={0} 未在 plugin.xml 中註冊
inspections.component.not.registered.name=組件/動作未註冊
inspections.component.not.registered.option.check.actions=檢查動作
inspections.component.not.registered.option.ignore.non.public=忽略非 public 類別
inspections.component.not.registered.quickfix.error=無法註冊 {0}
inspections.component.not.registered.quickfix.family=註冊 {0}
inspections.component.not.registered.quickfix.name=註冊 {0}
inspections.component.postfix.template.not.found.description.name=後綴模板描述檢查器
inspections.file.equals.method=請勿使用 File.equals/hashCode/compareTo，因為它們在 macOS 中不區分大小寫。請改用 FileUtil.filesEquals/fileHashCode/compareFiles。
inspections.group.code=程式碼
inspections.group.description.file=描述檔案
inspections.group.descriptor=延伸模組檔案描述子
inspections.group.name=Plugin DevKit
inspections.group.path=Plugin DevKit
inspections.incorrect.cancellation.exception.handling.display.name=取消異常處理不正確
inspections.incorrect.cancellation.exception.handling.name.logged=''{0}'' 不得記錄
inspections.incorrect.cancellation.exception.handling.name.not.rethrown=''{0}'' 必須重新拋出
inspections.incorrect.cancellation.exception.inheritor.handling.name.logged=''{0}'' 繼承者不得記錄
inspections.incorrect.cancellation.exception.inheritor.handling.name.not.rethrown=''{0}'' 繼承者必須重新拋出
inspections.incorrect.implicit.cancellation.exception.handling.name.logged=''{0}'' 不得記錄。它由 ''{1}()'' 拋出。
inspections.incorrect.implicit.cancellation.exception.handling.name.not.rethrown=''{0}'' 必須重新拋出。它由 ''{1}()'' 拋出。
inspections.incorrect.implicit.cancellation.exception.inheritor.handling.name.logged=''{0}'' 繼承者不得記錄。它由 ''{1}()'' 拋出。
inspections.incorrect.implicit.cancellation.exception.inheritor.handling.name.not.rethrown=''{0}'' 繼承者必須重新拋出。它由 ''{1}()'' 拋出。
inspections.inspection.description.optional.short.name=檢查沒有描述{0}
inspections.inspection.mapping.consistency.specify.bundle=應指定捆綁包
inspections.inspection.mapping.consistency.specify.displayName.or.key=應指定 displayName 或 key
inspections.inspection.mapping.consistency.specify.groupName.or.groupKey=應指定 groupName 或 groupKey
inspections.intention.description.no.before.after.template=意圖在 'description.html' 旁必須有 'before.*.template' 和 'after.*.template'
inspections.intention.description.not.found=意圖沒有描述
inspections.jcomponent.data.provider.display.name=JComponent 必須使用 UiDataProvider
inspections.jcomponent.data.provider.use.uidataprovider.instead.of.dataprovider=使用 UiDataProvider 而不是 DataProvider
inspections.leakable.map.key.name=映射鍵可能會泄漏
inspections.leakable.map.key.quick.fix.name=使用 ''{0}'' 進行參數化
inspections.leakable.map.key.text=考慮使用 ''String'' 代替 ''{0}'' 作為映射鍵
inspections.listener.implementation.must.not.be.disposable.name=偵聽器實作實作 'Disposable'
inspections.listener.implementation.must.not.implement.disposable=偵聽器實作不得實作 'Disposable'
inspections.message.first.argument.fs.getpath.should.be.annotated.with.nativepath=FileSystem.getPath() 的第一個實參應使用 @NativePath 註解
inspections.message.first.argument.path.of.should.be.annotated.with.multiroutingfilesystempath=Path.of() 的第一個實參應使用 @MultiRoutingFileSystemPath 或 @Filename 註解
inspections.message.more.parameters.in.fs.getpath.should.be.annotated.with.nativepath.or.filename=FileSystem.getPath() 中的 'more' 參數元素應使用 @NativePath 或 @Filename 註解
inspections.message.more.parameters.in.path.of.should.be.annotated.with.multiroutingfilesystempath.or.filename=Path.of() 中的 'more' 參數元素應使用 @MultiRoutingFileSystemPath 或 @Filename 註解
inspections.message.multiroutingfilesystempath.expected=在應使用 @MultiRoutingFileSystemPath 的上下文中使用了字串字面量
inspections.message.multiroutingfilesystempath.passed.to.nativepath.method.parameter=使用 @MultiRoutingFileSystemPath 註解的字串被傳遞給使用 @NativePath 註解的方法參數
inspections.message.nativepath.expected=在應使用 @NativePath 的上下文中使用了字串字面量
inspections.message.nativepath.passed.to.multiroutingfilesystempath.method.parameter=使用 @NativePath 註解的字串被傳遞給使用 @MultiRoutingFileSystemPath 註解的方法參數
inspections.message.nativepath.should.not.be.used.directly.constructing.path=使用 @NativePath 註解的字串不應直接在 Path 建構函式或工廠方法中使用
inspections.message.string.annotated.with.passed.to.method.parameter.annotated.with=使用 {0} 註解的字串被傳遞給使用 {1} 註解的方法參數
inspections.message.string.without.path.annotation.used.in.method.parameter.annotated.with=在使用 {0} 註解的方法參數中使用了不帶路徑註解的字串
inspections.message.string.without.path.annotation.used.in.path.resolve.method=Path.resolve() 方法中使用了不帶路徑註解的字串
inspections.meta.information.json.schema.display.name=IntelliJ 檢查元資訊
inspections.meta.information.unknown.inspection.id=未知檢查 ID ''{0}''
inspections.missing.recent.api.class.message=''{0}'' 僅從 {1} 開始方可用，但該模組的目標是 {2}。這可能導致與 {1} 之前的 IDE 出現兼容性問題。請注意，在以前的 IDE 中，此類型可能具有其他完全限定名稱。
inspections.missing.recent.api.common.message=''{0}'' 僅從 {1} 開始方可用，但該模組的目標是 {2}。這可能導致與 {1} 之前的 IDE 出現兼容性問題。
inspections.missing.recent.api.default.constructor.message=''{0}'' 的預設建構函式僅從 {1} 開始方可用，但該模組的目標是 {2}。這可能導致與 {1} 之前的 IDE 出現兼容性問題。
inspections.missing.recent.api.field.message=''{0}'' 僅從 {1} 開始方可用，但該模組的目標是 {2}。這可能導致與 {1} 之前的 IDE 出現兼容性問題。請注意，在以前的 IDE 中，此欄位可能具有不同的完全簽名。
inspections.missing.recent.api.method.message=''{0}'' 僅從 {1} 開始方可用，但該模組的目標是 {2}。這可能導致與 {1} 之前的 IDE 出現兼容性問題。請注意，在以前的 IDE 中，此方法可能具有不同的完全簽名。
inspections.missing.recent.api.overriding=''{0}'' 的覆蓋方法僅從 {1} 開始方可用，但該模組的目標是 {2}。這可能導致與 {1} 之前的 IDE 出現兼容性問題。請注意，在以前的 IDE 中，此覆蓋方法可能具有不同的簽名。
inspections.missing.recent.api.settings.invalid.build.number=無效建置號\: {0}
inspections.missing.recent.api.settings.range=延伸模組相容性範圍
inspections.missing.recent.api.settings.since=自
inspections.missing.recent.api.settings.until=至
inspections.missing.recent.api.since.until.range.all.builds=所有建置
inspections.non.default.warning.and.suffix.message={0} 不應具有包含參數 {1} 的建構函式
inspections.non.default.warning.suffix.module=(模組除外)
inspections.non.default.warning.suffix.project=(專案除外)
inspections.non.default.warning.suffix.project.or.module=(如果是在相應級別請求，則專案或模組除外)
inspections.non.default.warning.type.extension=擴展
inspections.non.default.warning.type.service=服務
inspections.path.annotation.usage.problems=路徑註解用法問題
inspections.plugin.xml.ComponentModuleRegistrationChecker.element.registered.wrong.module=元素應在定義其類別 ''{1}'' 的 ''{0}'' 模組中註冊
inspections.plugin.xml.ComponentModuleRegistrationChecker.fix.move.registration.family.name=將註冊移至正確的模組
inspections.plugin.xml.ComponentModuleRegistrationChecker.fix.move.registration.name=將註冊移至 {0}
inspections.plugin.xml.action.class.required.with.use.shortcut.of='class' 必須使用 'use-shortcut-of' 指定
inspections.plugin.xml.action.group.id.required=應指定 'id'
inspections.plugin.xml.action.must.override.method.with.use.shortcut.of=必須使用 ''use-shortcut-of'' 覆寫 {0}
inspections.plugin.xml.add.ignored.class.title=指定要忽略的類別
inspections.plugin.xml.add.vendor.tag=新增 <vendor>
inspections.plugin.xml.add.version.tag=新增 <version>
inspections.plugin.xml.anchor.must.have.relative-to-action='anchor' 必須使用 'relative-to-action' 進行指定
inspections.plugin.xml.attribute.not.used.anymore=特性 ''{0}'' 不再使用
inspections.plugin.xml.change.until.build.family.name=更正 'until-build' 特性
inspections.plugin.xml.change.until.build.name=將 ''until-build'' 更改為 ''{0}''
inspections.plugin.xml.component.interface.class.redundant=冗餘標記 'interface-class'
inspections.plugin.xml.dependency.class.located.in.wrong.package=類別 ''{0}'' 必須位於軟體套件 ''{1}'' 中
inspections.plugin.xml.dependency.descriptor.at.least.one.dependency=必須至少定義一個 <module> 或 <plugin> 相依項
inspections.plugin.xml.dependency.descriptor.cannot.use.depends=除了 <dependencies> 之外，不能使用 <depends>
inspections.plugin.xml.dependency.specify.config.file=必須指定 'config-file'
inspections.plugin.xml.dependency.superfluous.optional=多餘的宣告
inspections.plugin.xml.deprecated=已棄用
inspections.plugin.xml.deprecated.attribute=棄用的特性 ''{0}''
inspections.plugin.xml.deprecated.ep=棄用的擴展點 ''{0}''
inspections.plugin.xml.deprecated.ep.marked.for.removal=已標記為移除擴展點 ''{0}''
inspections.plugin.xml.deprecated.ep.marked.for.removal.in.version=已標記為移除版本 ''{1}'' 中的擴展點 ''{0}''
inspections.plugin.xml.deprecated.ep.use.replacement=棄用的擴展點 ''{0}''，請改用 ''{1}''
inspections.plugin.xml.deprecated.helpset=Helpset 已不再使用，請改用 'com.intellij.openapi.help.WebHelpProvider' 
inspections.plugin.xml.deprecated.implementation.detail=不再支援實作延伸模組\: 使用一般延伸模組或實作產品模組
inspections.plugin.xml.deprecated.package.attribute=不推薦且已棄用 package 特性用法，內容模組應打包到 `lib/modules/` 下的單獨 jar 檔案中。詳情請參閱特性文檔。
inspections.plugin.xml.do.not.use.template.text=不使用模板文本 ''{0}''
inspections.plugin.xml.duplicated.dependency=相依項組態檔案 ''{0}'' 重複
inspections.plugin.xml.dynamic.plugin.component.usage=由於使用組件而變成非動態的延伸模組。
inspections.plugin.xml.dynamic.plugin.component.usage.docs.link.title=遷移指南
inspections.plugin.xml.dynamic.plugin.extension.point=非動態擴展點 ''{0}''
inspections.plugin.xml.dynamic.plugin.id.required.for.group=必須為 <group> 指定 'id'
inspections.plugin.xml.dynamic.plugin.option.highlight.usages.ep=醒目提示非動態擴展點的用法
inspections.plugin.xml.dynamic.plugin.usage.of.non.dynamic.extension.point=使用非動態擴展點 ''{0}''
inspections.plugin.xml.ep.both.beanClass.and.interface='<extensionPoint>' 不得同時指定 'interface' 特性和 'beanClass' 特性
inspections.plugin.xml.ep.both.name.and.qualifiedName='<extensionPoint>' 不得同時指定 'name' 和 'qualifiedName' 特性
inspections.plugin.xml.ep.doesnt.have.with='<extensionPoint>' 沒有用於指定類別欄位類型的 '<with>' 標記
inspections.plugin.xml.ep.missing.beanClass.and.interface='<extensionPoint>' 必須指定 'interface' 特性或 'beanClass' 特性
inspections.plugin.xml.ep.missing.name.and.qualifiedName='<extensionPoint>' 必須指定 'name' 或 'qualifiedName' 特性
inspections.plugin.xml.ep.qualifiedName.superfluous=通過 'qualifiedName' 進行了不必要的宣告
inspections.plugin.xml.ep.qualifiedName.superfluous.fix=通過 'name' 宣告
inspections.plugin.xml.fix.extension.point.add.with.tag=新增 <with> 標記
inspections.plugin.xml.ignore.classes.title=註冊檢查忽略類別列表\: 
inspections.plugin.xml.inner.class.must.be.separated.with.dollar=內部類別必須用 '$' 分隔
inspections.plugin.xml.invalid.build.number=<html>無效構建版本 ''{0}'' (<a href\="https\://plugins.jetbrains.com/docs/intellij/build-number-ranges.html?from\=DevkitPluginXmlInspection">文檔</a>)</html>
inspections.plugin.xml.invalid.ep.name=名稱
inspections.plugin.xml.invalid.ep.name.description=無效的擴展點 {0} ''{1}''，只能包含拉丁字元、數字和點，不能以點開頭/結尾，每個片段都必須以小寫字母開頭，最後一個片段詞不得重複任何先前的片段
inspections.plugin.xml.invalid.ep.qualifiedName=限定名稱
inspections.plugin.xml.invalid.order.attribute=無效 'order' 特性值
inspections.plugin.xml.jetbrains.only.api=為 JetBrains 內部使用而保留的 API 的用法
inspections.plugin.xml.listener.does.not.inherit=''{0}'' 不是繼承自 ''{1}''
inspections.plugin.xml.marked.for.removal.attribute=標記為移除特性 ''{0}''
inspections.plugin.xml.module.descriptor.at.least.one.dependency=必須至少定義一個 <module> 條目
inspections.plugin.xml.must.not.contain.template.text=不得包含模板文本 ''{0}''
inspections.plugin.xml.must.use.after.before.with.relative-to-action=''{0}''|''{1}'' 與 ''relative-to-action'' 必須一起使用
inspections.plugin.xml.no.need.to.specify.itnReporter=由 JetBrains 開發的延伸模組中的異常會通過 ITNReporter 自動報告，無需顯式指定
inspections.plugin.xml.no.plugin.icon.svg.file=<html>延伸模組應提供 ''{0}'' (<a href\="https\://plugins.jetbrains.com/docs/intellij/plugin-icon-file.html?from\=PluginXmlPluginLogoInspection">文檔</a>)</html>
inspections.plugin.xml.plugin.jetbrains.no.generic.plugin.url=作為 IntelliJ IDEA 專案的一部分開發的延伸模組不應指定泛型延伸模組 url
inspections.plugin.xml.plugin.jetbrains.no.idea.version=作為 IntelliJ IDEA 專案的一部分開發的延伸模組不應指定 idea-version，因為建置腳本會自動生成
inspections.plugin.xml.plugin.jetbrains.no.version=作為 IntelliJ IDEA 專案的一部分開發的延伸模組不應指定版本
inspections.plugin.xml.plugin.jetbrains.vendor.no.email=作為 IntelliJ IDEA 專案的一部分開發的延伸模組不應指定電子郵箱
inspections.plugin.xml.plugin.jetbrains.vendor.no.url=作為 IntelliJ IDEA 專案的一部分開發的延伸模組不應指定  ''{0}'' 作為 url
inspections.plugin.xml.plugin.modules.description=每一行都是包含在單個延伸模組中的模組名稱的逗號分隔列表。
inspections.plugin.xml.plugin.modules.label=多模組延伸模組的模組\: 
inspections.plugin.xml.plugin.should.have.jetbrains.vendor=作為 IntelliJ IDEA 專案的一部分開發的延伸模組應指定 'JetBrains' 作為其供應商
inspections.plugin.xml.product.descriptor.invalid.date=日期必須為 YYYYMMDD 整數或佔位符(例如__DATE__)
inspections.plugin.xml.product.descriptor.invalid.version=版本必須為整數或佔位符(例如__VERSION__)
inspections.plugin.xml.reference.id.deprecated.use.ref=改用 'ref'
inspections.plugin.xml.service.interface.class.redundant=冗餘特性 'serviceInterface'
inspections.plugin.xml.since.build.could.not.determine.platform.version=無法確定目標平台版本，請檢查專案設定
inspections.plugin.xml.since.build.could.not.locate.main.descriptor=無法定位主 plugin.xml 檔案來確定所需的 <idea-version> 'since-build'
inspections.plugin.xml.since.build.listeners.not.available=功能僅在平台版本 {0} 或更高版本中可用，但指定的 ''since-build'' 平台為 ''{1}''
inspections.plugin.xml.since.build.listeners.os.attribute=特性 ''os'' 僅在平台版本 {0} 或更高版本中可用，但指定的 ''since-build'' 平台為 ''{1}''
inspections.plugin.xml.since.build.must.be.specified=必須指定 <idea-version> 'since-build'
inspections.plugin.xml.skipForDefaultProject.deprecated='skipForDefaultProject' 已棄用； 預設情況下，專案組件不載入到預設專案中
inspections.plugin.xml.specify.defaultExtensionNs.explicitly=顯式指定 defaultExtensionNs\="{0}"
inspections.plugin.xml.synonym.both.key.and.text='<synonym>' 不得同時指定 'key' 或 'text' 特性
inspections.plugin.xml.synonym.missing.key.and.text='<synonym>' 必須指定 'key' 或 'text' 特性
inspections.plugin.xml.third.party.plugins.must.not.use.itnReporter='com.intellij.diagnostic.ITNReporter' 報告 JetBrains 的內部處理錯誤，不應將其用於第三方延伸模組
inspections.plugin.xml.until.build.misleading.plain.number=''{2}'' 特性中的純數字可能會引起誤解。''{0}'' 與 ''{0}.0'' 的意義相同，因此該延伸模組不相容構建版本 {0}.*。最好改為指定 ''{1}''。
inspections.plugin.xml.until.build.must.be.greater.than.since.build="{0}" 必須大於 "since-build"
inspections.plugin.xml.until.build.use.asterisk.instead.of.big.number=不在 ''{1}'' 中使用 ''{0}''，改用 ''*''
inspections.plugin.xml.usage.of.experimental.api=使用通過 @{0} 標記的 API。在日後的 IDE 版本中，可能會更改或移除此類別導致兼容性問題的 API。
inspections.plugin.xml.usage.of.internal.api=使用通過 @{0} 標記的 API。不應在 IntelliJ IDEA 專案之外使用此類別 API。
inspections.plugin.xml.usage.of.obsolete.api=標記為 @{0} 的 API 的用法。不應在新程式碼中使用此類別 API。
inspections.plugin.xml.use.defaultExtensionNs=改為使用 defaultExtensionNs
inspections.plugin.xml.value.exceeds.max.length=值超過最大長度 {0}
inspections.plugin.xml.value.must.be.https.or.http.link.to.website=必須是使用 https\:// 或 http\:// 方案的有效網站鏈接
inspections.plugin.xml.value.must.have.minimum.length=值必須達到最小長度 {0}
inspections.plugin.xml.vendor.must.be.specified=必須指定 '<vendor>'
inspections.plugin.xml.vendor.specify.jetbrains=指定 JetBrains 作為供應商
inspections.plugin.xml.version.must.be.specified=必須指定 '<version>'
inspections.postfix.description.no.before.after.template=後綴模板在 'description.html' 旁必須有 'before.*.template' 和 'after.*.template'
inspections.postfix.description.not.found=後綴模板沒有描述
inspections.presentation.cannot.resolve.icon=無法解析圖示 ''{0}''
inspections.psi.element.concat.add.get.text.family.name=呼叫文本表示檢索方法
inspections.psi.element.concat.add.get.text.name=使用 ''{0}'' 呼叫
inspections.psi.element.concat.psi.element=PsiElement 到字串的可疑轉換
inspections.psi.element.concat.psi.type=PsiType 到字串的可疑轉換
inspections.quick.fix.family.name=QuickFix 的 getFamilyName() 實作不得依賴於特定上下文
inspections.registration.problems.abstract=延伸模組組件類別不得為 abstract
inspections.registration.problems.component.duplicate.interface=不允許多個具有相同 'interface-class' 的組件
inspections.registration.problems.component.incompatible.interface=組件類別不可分配給其接口類別 ''{0}''
inspections.registration.problems.incompatible.message=根據在 plugin.xml 中的註冊，該類應擴展 ''{0}''
inspections.registration.problems.missing.noarg.ctor=動作類別必須具有無實參的建構函式
inspections.registration.problems.name=組件類型不符合
inspections.registration.problems.quickfix.create.constructor=延伸模組無實參建構函式
inspections.registration.problems.quickfix.read-only=''{0}'' 為唯讀類別
inspections.stateful.extension.point.do.not.use.in.extension=請勿在擴展中將 {0} 用作欄位
inspections.stateful.extension.point.do.not.use.in.quick.fix=請勿在快速修復中將 {0} 用作欄位
inspections.stateful.extension.point.leak.psi.element=潛在的記憶體泄漏\: 請勿保持 PsiElement，改用 SmartPsiElementPointer
inspections.stateful.extension.point.leak.psi.element.quick.fix=另請參閱 LocalQuickFixOnPsiElement。
inspections.static.initialization.in.extensions.message=擴展點實作不得使用 static 初始化
inspections.static.initialization.in.extensions.name=擴展點實作中的 static 初始化
inspections.statistics.collector.not.registered.message=統計資訊收集器未在 plugin.xml 中註冊
inspections.statistics.collector.not.registered.name=統計資訊收集器未註冊
inspections.undesirable.class.use.instead=請改用 ''{0}''
inspections.unresolved.plugin.config.reference=未解析的延伸模組組態參照
inspections.unsafe.return.insert.family.name=跳過匿名/區域類別
inspections.unsafe.return.insert.visit.class.method=插入 visitClass 方法
inspections.unsafe.return.insert.visit.lambda.expression=插入 visitLambdaExpression 方法
inspections.unsafe.return.insert.visit.lambda.expression.and.class.methods=插入 visitLambdaExpression/visitClass 方法
inspections.unsafe.return.message=具有 'visitReturnStatement' 的遞迴訪問者最有可能應當專門處理匿名/區域類別 ('visitClass') 以及 lambda 表達式('visitLambdaExpression')
inspections.unsafe.vfs.recursion=從遞迴方法呼叫的 'VirtualFile.getChildren()'
inspections.unspecified.actions.place.popup.menu=未指定的動作彈出選單位置
inspections.unspecified.actions.place.toolbar=未指定的動作工具列位置
inspections.usage.uelement.as.psi=不建議將 UElement 用作 PsiElement
inspections.use.dpi.aware.empty.border.can.be.simplified=可以簡化空邊框建立
inspections.use.dpi.aware.empty.border.convert.fix.name=轉換為 'JBUI.Borders.empty(…)'
inspections.use.dpi.aware.empty.border.not.dpi.aware='EmptyBorder' 非 DPI 感知
inspections.use.dpi.aware.empty.border.simplify.fix.name=簡化
inspections.use.dpi.aware.insets.can.be.simplified=Insets 建立可以簡化
inspections.use.dpi.aware.insets.convert.fix.name=轉換為 'JBUI.insets(...)'
inspections.use.dpi.aware.insets.not.dpi.aware='Insets' 非 DPI 感知
inspections.use.dpi.aware.insets.simplify.fix.name=簡化
inspections.use.equals.description=應比較 ''{0}'' 實例是否相等，而不是是否相同
inspections.use.equals.fix.replace.equality.with.equals.family.name=將相等運算符取代為 'equals()'
inspections.use.equals.fix.replace.equality.with.equals.name=將 ''{0}'' 取代為 ''equals()''
inspections.use.equals.fix.replace.equality.with.not.equals.name=將 ''{0}'' 取代為 ''\!equals()''
inspections.use.gray.awt.color.used.name=用於灰色的 'java.awt.Color'
inspections.use.gray.fix.convert.family.name=轉換為 'Gray'
inspections.use.gray.fix.convert.name=轉換為 ''Gray._{0}''
inspections.wrap.application.service.in.supplier.quick.fix.message=將應用程式服務包裝在 'java.util.function.Supplier' 中
intellij.api.annotations.update.task.title=更新 IntelliJ API 註解 {0}
invalid.order.attribute.part=''order'' 特性值部分無效\: ''{0}''，必須為 ''first''、''last''、''before <id>'' 或 ''after <id>''
line.marker.descriptors.including.content.module.name=包含此內容模組的檔案描述子
line.marker.descriptors.including.content.module.popup.title=包含此內容模組的檔案描述子
line.marker.descriptors.including.content.module.tooltip=''{0}'' 內容模組包含在 {1} 個延伸模組 XML 檔案描述子中
line.marker.related.property.description=相關屬性
line.marker.related.property.popup.title=相關屬性
line.marker.related.property.tooltip=相關屬性
list.item.an.action=動作
list.item.applications.service=應用程式服務
list.item.applications.state=應用程式設定
list.item.background.activity=背景活動
list.item.immediate.activity=即時活動
list.item.project.service=專案服務
list.item.project.state=專案設定
list.item.toggle.action=切換動作
manifest.selection=選定的 {0} 將包含在得到的分發中
manifest.settings=清單設定
manifest.use.user.defined=使用使用者清單\: 
message.bundle.convert.advanced.setting.id.cannot.resolve=無法解析進階設定 ID ''{0}''
message.bundle.convert.toolwindow.id.cannot.resolve=無法解析工具視窗 ID ''{0}''
module.builder.github.template.link=功能齊全的 GitHub 模板
module.builder.how.to.link=如何為基於 IntelliJ 的 IDE 建置延伸模組
module.builder.title=IDE 延伸模組
module.builder.type=類型\:
module.builder.type.plugin=延伸模組
module.builder.type.theme=主題
module.description=延伸模組模組用於開發基於 <b>IntelliJ 平台</b>的 IDE 的延伸模組。<br>它們提供 <b>IntelliJ 平台延伸模組 SDK </b>和<b>執行組態</b>，用於在 IDE 中執行和偵錯延伸模組。
module.title=IntelliJ 平台延伸模組
module.wizard.gradle.plugin.xml.template.display.name=基於 Gradle 的專案中的 plugin.xml
new.action.action.name=正在建立新動作\: {0}。{1}
new.action.add.to.group=新增到組
new.action.cannot.create.class=無法建立動作類別
new.action.class.name=類別名(&C)\:
new.action.description=描述(&D)\:
new.action.dialog.title=新動作
new.action.error=無法建立動作
new.action.group.actions=動作(&I)\:
new.action.group.anchor=定位標記\:
new.action.group.anchor.=最後一個(&L)
new.action.group.anchor.after=後面(&T)
new.action.group.anchor.before=之前 (&B)
new.action.group.anchor.first=第一個(&F)
new.action.group.groups=組(&G)\:
new.action.id=動作 ID(&A)\:
new.action.invalid.class.name=動作類別名不是有效的 Java 限定名稱
new.action.invalid.id=動作 ID 不得為空
new.action.invalid.name=動作名稱不得為空
new.action.keyboard.clear=X
new.action.keyboard.clear.tooltip=清除快捷鍵
new.action.keyboard.first=第一\: 
new.action.keyboard.second=第二\: 
new.action.keyboard.shortcuts=鍵盤快捷鍵
new.action.text=名稱(&N)\:
new.menu.action.text=動作
new.menu.application.component.text=應用程式組件
new.menu.module.component.text=模組組件
new.menu.project.component.text=專案組件
notification.group.devkit.deployment=延伸模組部署已完成
notification.group.testdata=找不到測試資料檔案
notification.message.duplicate.packages.file=專案中的軟體套件列表檔案過多\:\n{0}
plugin.descriptor=IntelliJ 平台延伸模組檔案描述子
plugin.descriptor.chooser.cannot.find=找不到延伸模組檔案描述子
plugin.descriptor.chooser.popup.title=選擇延伸模組檔案描述子
plugin.xml.convert.action.or.group.cannot.resolve=無法解析{0} ''{1}''
plugin.xml.convert.action.or.group.invalid.name=<invalid name>
plugin.xml.convert.action.or.group.type.action=動作
plugin.xml.convert.action.or.group.type.action.or.group=動作或組
plugin.xml.convert.action.or.group.type.group=組
plugin.xml.convert.enum.cannot.resolve=無法解析{1}中的 ''{0}''
plugin.xml.convert.extension.order.cannot.resolve=無法解析 '''''{'0'}''''' {0} 擴展
plugin.xml.convert.extension.property.cannot.resolve=無法解析擴展點屬性 ''{0}''
plugin.xml.convert.keymap.cannot.resolve=無法解析按鍵映射 ''{0}''
plugin.xml.convert.language.id.any.language.display.name=<any language>
plugin.xml.convert.language.id.cannot.resolve=無法解析 ID 為 ''''{0}'''' 的語言
plugin.xml.convert.module.descriptor.name=無法解析源和庫根中的模組檔案描述子 ''{0}''
plugin.xml.convert.property.bundle.cannot.resolve=無法解析屬性捆綁包
plugin.xml.scopes.display.name=延伸模組檔案描述子檔案
plugin.xml.scopes.production.display.name=所有生產延伸模組檔案描述子檔案
plugins.database.description=資料庫工具視窗、主控台和 SQL
plugins.go.description=Go 語言
plugins.java.description=適用於 Java、Kotlin、Groovy 和 Scala 的 JVM 平台 API
plugins.javascript.description=JavaScript、TypeScript、JSX 和 TSX 檔案
plugins.json.description=JSON 語言和 JSON 架構驗證
plugins.kotlin.description=Kotlin 延伸模組
plugins.markdown.description=Markdown 語言和預覽 UI
plugins.php.description=PHP 語言
plugins.properties.description=屬性檔案
plugins.python.description=Python 語言
plugins.ruby.description=Ruby 語言
plugins.rust.description=Rust 語言
plugins.xml.description=XML 語言和 DOM API
plugins.yaml.description=YAML 語言
prepare.for.deployment=為部署準備延伸模組模組 ''{0}''
prepare.for.deployment.all=為部署準備所有延伸模組模組
prepare.for.deployment.task=進行延伸模組模組 ''{0}'' 部署準備
prepare.for.deployment.task.progress=正在進行部署準備
program.parameters=程式引數(&P)
progress.title.calculate.target.properties.file=正在計算目標屬性檔案
register.extension.fix.name=註冊擴展
register.extension.fix.popup.title=選擇擴展點
register.inspection.fix.family.name=註冊檢查
register.inspection.fix.name=註冊檢查 ''{0}''
registry.properties.annotator.add.description.family.name=新增描述鍵
registry.properties.annotator.add.description.text=新增 ''{0}'' 的描述鍵
registry.properties.annotator.key.no.description.key=鍵 ''{0}'' 沒有描述鍵
registry.properties.annotator.plugin.keys.use.ep=特定於延伸模組的鍵應通過 'com.intellij.registryKey' 擴展點進行註冊
registry.properties.annotator.show.ep.family.name=顯示擴展點宣告
registry.properties.annotator.show.ep.message=將此宣告複製到您的延伸模組檔案描述子 XML 中
registry.properties.annotator.show.ep.name=顯示 ''{0}'' 的擴展點宣告
registry.properties.annotator.show.ep.title=擴展點宣告
run.configuration.no.module.specified=未為組態指定延伸模組模組
run.configuration.title=延伸模組
run.configuration.type.description=延伸模組沙盒環境
sandbox.home=沙盒主頁
sandbox.home.label=沙盒主頁\: 
sandbox.no.configured=未為 IntelliJ 平台延伸模組 SDK 指定沙盒
sandbox.no.sdk=請組態 SDK
sandbox.purpose=瀏覽目錄以放置目標 IDE 的組態、系統和延伸模組
sandbox.specification=請組態沙盒
saved.message=模組 ''{1}'' 的 {0, choice, 1\#Zip|2\#JAR} 檔案儲存至 {2}
saved.message.common={0} 將儲存在所選目錄中
sdk.from.sources.scanning.roots=正在掃描根
sdk.no.idea.sdk.version.found=未能檢測出 IntelliJ 平台延伸模組 SDK 所需的 JDK 版本。
sdk.no.java.sdk.for.idea.sdk.found=找不到合適的 Java SDK 版本。除了 IntelliJ 平台延伸模組 SDK，還需要定義具有相同 Java 版本({0})的 JDK。
sdk.no.java.sdk.for.idea.sdk.found.title=未找到 Java SDK
sdk.no.specified=未為延伸模組模組 ''{0}'' 指定 SDK 
sdk.select.java.sdk=選擇要用於 IntelliJ 平台延伸模組 SDK 的 Java SDK
sdk.select.java.sdk.label=內部 Java 平台\:
sdk.select.java.sdk.title=選擇內部 Java 平台
sdk.title=IntelliJ 平台延伸模組 SDK
sdk.type.incorrect=延伸模組模組 ''{0}'' 的 SDK 類型錯誤。
sdk.type.incorrect.common=延伸模組模組的 SDK 類型錯誤
select.plugin.module.to.patch=選擇要修補的延伸模組模組
select.plugin.modules.description=選擇要準備部署的模組
select.plugin.modules.title=選擇模組
select.target.location.of.description=選擇 {0} 的目標位置
structure.sort.alphabetically.in.groups=在組中按字母順序排序
structure.sort.alphabetically.in.groups.description=在組中按字母順序排序
success.deployment.message=已成功進行延伸模組模組 ''{0}'' 部署準備
success.deployment.message.all=已成功進行所有延伸模組的部署準備
suggest.to.delete=是否刪除 ''{0}''?
testdata.confirm.create.missing.files.dialog.message=將建立以下 testdata 檔案\: \n{0}
testdata.create.dialog.title=建立 Testdata 檔案
testdata.create.missing.files=建立缺少的檔案
testdata.file.doesn.not.exist=<html>所參照的 testdata 檔案 {0} 不存在。是否要建立?</html>
testdata.goto.test.data.action.text=轉到 {0}
testdata.notification.no.test.datafiles.content=找不到類別的測試資料檔案
testdata.notification.no.test.datafiles.title=未找到測試資料檔案
testdata.popup.navigation.title=測試資料
testdata.progress.text.searching.for.test.data.files=正在搜尋 ''{0}'' 測試資料檔案…
testdata.related.navigation.group=測試資料
testdata.related.navigation.title=測試資料
testdata.searching=正在搜尋測試資料檔案
update.ide.from.sources=從源更新 IDE(&I)
update.ide.from.sources.option=從源
usage.type.module.in.content=在內容中
usage.type.module.in.dependencies=在相依項中
vm.parameters=虛擬機選項(&V)

conflicting.annotations.display.name=Guice 註解衝突
conflicting.annotations.problem.descriptor=註解 #ref 與宣告的其他註解衝突 #loc
multiple.binding.annotations.display.name=變數有多個綁定註解
multiple.binding.annotations.problem.descriptor=變數 #ref 有多個綁定註解 #loc
binding.annotation.without.inject.display.name=沒有 @Inject 的綁定註解
binding.annotation.without.inject.problem.descriptor=沒有宣告 @Inject 的綁定註解 #ref #loc
interception.annotation.without.runtime.retention.display.name=沒有執行時保留的截取註解
interception.annotation.without.runtime.retention.problem.descriptor=註解 #ref 沒有執行時保留 #loc
invalid.request.parameters.display.name=@RequestParameters 參數的類型不正確
invalid.request.parameters.problem.descriptor=標記為 #ref 的變數或參數的類型必須為 Map<String, String[]> #loc
invalid.implemented.by.display.name=@ImplementedBy 註解無效
invalid.implemented.by.problem.descriptor=#ref 類別未實作註解類別 #loc
singleton.injects.scoped.display.name=@Singleton 組件注入範圍組件
singleton.injects.scoped.problem.descriptor=範圍類別 #ref 的 @Inject 來自 @Singleton 類別 #loc
group.guice.inspections.name=Guice
session.scoped.injects.request.scoped.display.name=@SessionScoped 組件注入 @RequestScoped 組件
session.scoped.injects.request.scoped.problem.descriptor=@RequestScoped 類別 #ref 的 @Inject 來自 @SessionScoped 類別 #loc
invalid.provided.by.display.name=@ProvidedBy 註解無效
invalid.provided.by.problem.descriptor=#ref 類別未提供註解類別 #loc
uninstantiable.implemented.by.class.display.name=無法實例化的 @ImplementedBy 類別
uninstantiable.implemented.by.class.problem.descriptor=類別 #ref 不可實例化，因此不能為 @ImplementedBy #loc
uninstantiable.provided.by.class.display.name=無法實例化的 @ProvidedBy 類別
uninstantiable.provided.by.class.problem.descriptor=類別 #ref 不可實例化，因此不能為 @ProvidedBy #loc
uninstantiable.binding.display.name=無法實例化的綁定
uninstantiable.binding.problem.descriptor=類別 #ref 不可實例化，因此不可綁定 #loc
redundant.to.binding.display.name=冗餘綁定
redundant.to.binding.problem.descriptor=與類別 #ref 的綁定冗餘 #loc
redundant.to.provider.binding.display.name=冗餘提供程序綁定
redundant.to.provider.binding.problem.descriptor=與類別 #ref 的綁定冗餘 #loc
redundant.scope.binding.display.name=冗餘範圍綁定
redundant.scope.binding.problem.descriptor=與範圍 #ref 的綁定冗餘 #loc
pointless.binding.display.name=無意義的綁定
pointless.binding.problem.descriptor=綁定非必要，可以移除 #loc
unnecessary.static.injection.display.name=不必要的 static 注入
unnecessary.static.injection.problem.descriptor=類別 #ref 沒有 static @Inject 成員 #loc
multiple.injected.constructors.for.class.display.name=類別有多個 @Inject 構造函數
multiple.injected.constructors.for.class.problem.descriptor=類別 #ref 有多個 @Inject 構造函數 #loc
move.binding.scope.to.class.text=將綁定範圍移至類別
move.binding.scope.to.class.family.name=將綁定範圍移至類別
move.binding.to.class.text=將綁定類別移至類別
move.binding.to.class.family.name=將綁定移至類別
move.provider.binding.to.class.text=將提供程序綁定移至類別
move.provider.binding.to.class.family.name=將提供程序綁定移至類別
guice.intentions=Guice
new.guice.module.error=無法創建 Guice 模組
new.guice.module.action.name=創建 Guice 模組
new.guice.module.name=創建 Guice 模組: {0}。{1}
new.guice.scope.annotation.error=無法創建 Guice 範圍註解
new.guice.scope.annotation.action.name=創建 Guice 範圍註解
new.guice.binding.annotation.error=無法創建 Guice 綁定註解
new.guice.binding.annotation.action.name=創建 Guice 綁定註解
new.guice.binding.annotation.name=創建 Guice 綁定註解: {0}。{1}
new.guice.method.interceptor.error=無法創建 Guice 方法偵聽器
new.guice.method.interceptor.action.name=創建 Guice 方法偵聽器
new.guice.method.interceptor.name=創建 Guice 方法偵聽器: {0}。{1}
new.guice.provider.error=無法創建 Guice 提供程序
new.guice.provider.action.name=創建 Guice 提供程序
new.guice.provider.name=創建 Guice 提供程序: {0}。{1}
toggle.injection.required.family.name=切換注入
make.injection.optional=將註解設為可選
make.injection.mandatory=將註解設為強制
toggle.required=切換 'optional'
action.group.guice.title=Google Guice
action.group.guice.description=Google Guice 組件
delete.binding=刪除綁定
select.provided.class=選擇要提供的類別
GuiceClassAnnotator.popup.title=選擇要導航到的表達式
GuiceClassAnnotator.popup.tooltip.text=導航到 Guice 綁定表達式
gutter.choose.injected.point=選擇注入點
gutter.navigate.to.injection.point=導航到注入點
provider.class.name=提供程序類別名:
class.provided=提供的類別:
new.guice.provider=新建 Guice 提供程序
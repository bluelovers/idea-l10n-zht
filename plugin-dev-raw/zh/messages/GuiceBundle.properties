GuiceClassAnnotator.popup.title=選擇要導覽到的表達式
GuiceClassAnnotator.popup.tooltip.text=導覽到 Guice 綁定表達式
ImplicitSubclassInspection.display.forMethod.annotated=@Transactional 方法不得為 private
action.group.guice.description=Google Guice 組件
action.group.guice.title=Google Guice
binding.annotation.without.inject.display.name=沒有 @Inject 的綁定註解
binding.annotation.without.inject.problem.descriptor=沒有宣告 @Inject 的綁定註解 #ref #loc
class.provided=提供的類別:
conflicting.annotations.display.name=Guice 註解衝突
conflicting.annotations.problem.descriptor=註解 #ref 與宣告的其他註解衝突 #loc
delete.binding=刪除綁定
group.guice.inspections.name=Guice
guice.intentions=Guice
gutter.choose.injected.point=選擇注入點
gutter.navigate.to.injection.point=導覽到注入點
interception.annotation.without.runtime.retention.display.name=沒有執行時保留的截取註解
interception.annotation.without.runtime.retention.problem.descriptor=註解 #ref 沒有執行時保留 #loc
invalid.implemented.by.display.name=@ImplementedBy 註解無效
invalid.implemented.by.problem.descriptor=#ref 類別未實作註解類別 #loc
invalid.provided.by.display.name=@ProvidedBy 註解無效
invalid.provided.by.problem.descriptor=#ref 類別未提供註解類別 #loc
invalid.request.parameters.display.name=@RequestParameters 參數的類型不正確
invalid.request.parameters.problem.descriptor=標記為 #ref 的變數或參數的類型必須為 Map<String, String[]> #loc
make.injection.mandatory=將註解設為強制
make.injection.optional=將註解設為可選
move.binding.scope.to.class.family.name=將綁定作用域移至類別
move.binding.scope.to.class.text=將綁定作用域移至類別
move.binding.to.class.family.name=將綁定移至類別
move.binding.to.class.text=將綁定類別移至類別
move.provider.binding.to.class.family.name=將提供程序綁定移至類別
move.provider.binding.to.class.text=將提供程序綁定移至類別
multiple.binding.annotations.display.name=變數有多個綁定註解
multiple.binding.annotations.problem.descriptor=變數 #ref 有多個綁定註解 #loc
multiple.injected.constructors.for.class.display.name=類別有多個 @Inject 建構函式
multiple.injected.constructors.for.class.problem.descriptor=類別 #ref 有多個 @Inject 建構函式 #loc
new.guice.binding.annotation.action.name=建立 Guice 綁定註解
new.guice.binding.annotation.error=無法建立 Guice 綁定註解
new.guice.binding.annotation.name=建立 Guice 綁定註解: {0}。{1}
new.guice.method.interceptor.action.name=建立 Guice 方法攔截器
new.guice.method.interceptor.error=無法建立 Guice 方法攔截器
new.guice.method.interceptor.name=建立 Guice 方法攔截器: {0}。{1}
new.guice.module.action.name=建立 Guice 模組
new.guice.module.error=無法建立 Guice 模組
new.guice.module.name=建立 Guice 模組: {0}。{1}
new.guice.provider=新增 Guice 提供程序
new.guice.provider.action.name=建立 Guice 提供程序
new.guice.provider.error=無法建立 Guice 提供程序
new.guice.provider.name=建立 Guice 提供程序: {0}。{1}
new.guice.scope.annotation.action.name=建立 Guice 作用域註解
new.guice.scope.annotation.error=無法建立 Guice 作用域註解
pointless.binding.display.name=無意義的綁定
pointless.binding.problem.descriptor=綁定非必要，可以移除 #loc
provider.class.name=提供程序類別名:
redundant.scope.binding.display.name=冗餘作用域綁定
redundant.scope.binding.problem.descriptor=與作用域 #ref 的綁定冗餘 #loc
redundant.to.binding.display.name=冗餘綁定
redundant.to.binding.problem.descriptor=與類別 #ref 的綁定冗餘 #loc
redundant.to.provider.binding.display.name=冗餘提供程序綁定
redundant.to.provider.binding.problem.descriptor=與類別 #ref 的綁定冗餘 #loc
select.provided.class=選擇要提供的類別
session.scoped.injects.request.scoped.display.name=@SessionScoped 組件注入 @RequestScoped 組件
session.scoped.injects.request.scoped.problem.descriptor=@RequestScoped 類別 #ref 的 @Inject 來自 @SessionScoped 類別 #loc
singleton.injects.scoped.display.name=@Singleton 組件注入作用域組件
singleton.injects.scoped.problem.descriptor=作用域類別 #ref 的 @Inject 來自 @Singleton 類別 #loc
toggle.injection.required.family.name=切換注入
toggle.required=切換 'optional'
uninstantiable.binding.display.name=無法實例化的綁定
uninstantiable.binding.problem.descriptor=類別 #ref 不可實例化，因此不可綁定 #loc
uninstantiable.implemented.by.class.display.name=無法實例化的 @ImplementedBy 類別
uninstantiable.implemented.by.class.problem.descriptor=類別 #ref 不可實例化，因此不能為 @ImplementedBy #loc
uninstantiable.provided.by.class.display.name=無法實例化的 @ProvidedBy 類別
uninstantiable.provided.by.class.problem.descriptor=類別 #ref 不可實例化，因此不能為 @ProvidedBy #loc
unnecessary.static.injection.display.name=不必要的 static 注入
unnecessary.static.injection.problem.descriptor=類別 #ref 沒有 static @Inject 成員 #loc
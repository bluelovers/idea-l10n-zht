dialog.message.no.inheritors.are.selected=未選擇繼承者
progress.title.inplace.rename.appending.additional.elements=追加其他元素
progress.title.inplace.rename.preparing=正在準備重命名
extract.invalid.name.for.class.type.error={0} 名稱無效
refactoring.introduce.constant.name=引入常數
refactoring.introduce.define.name=引入 Define
refactoring.introduce.typedef.name=引入 Typedef
refactoring.introduce.variable.name=引入變數
refactoring.introduce.ivar.name=引入 Ivar
refactoring.introduce.property.name=引入屬性
refactoring.introduce.instance.variable.name=引入實例變數
refactoring.introduce.parameter.name=引入參數
refactoring.move.no.members.are.selected.error=未選擇成員
refactoring.move.members.ok.button.text=移動(&M)
refactoring.move.pull.up.ok.button.text=拉取(&U)
refactoring.move.push.down.ok.button.text=推送(&U)
refactoring.move.escalate.visibility.declare.in.interface=在接口中宣告
refactoring.move.namespace.has.no.members=命名空間“{0}”沒有要移動的成員
refactoring.move.file.has.no.members=檔案“{0}”沒有要移動的成員
refactoring.symbol.has.no.members.to.move={0} 沒有要移動的成員
refactoring.move.caret.position=文字游標應置於類內部
refactoring.move.cant.find.symbol=找不到所選類的符號
refactoring.move.members.error.no.target.class.selected=未選擇目標類
refactoring.move.members.error.class.name.invalid=類名無效
refactoring.move.members.error.not.in.project.sources={0} 不在專案內部
refactoring.move.members.error.the.same.source.and.target=源和目標類應該不同
refactoring.move.members.message.target.does.not.exist=目標類 "{0}" 尚不存在。
refactoring.extract.super.protocol.title=提取超級協議
refactoring.extract.subclass.title=提取子類
refactoring.extract.category.title=提取類別
refactoring.introduce.block.expression.represent.error=所選塊應該代表 {0}
refactoring.introduce.expressions.choose.dialog.title=表達式
refactoring.introduce.put.to.header=置於頭(&H)
refactoring.change.signature.target.symbols.panel=目標:
refactoring.rename=重命名 {0}(&R)
refactoring.rename.class.aliases=重命名類別名(&R)
refactoring.rename.associated.file=重命名關聯檔案
refactoring.introduce.constant.static.declaration=宣告 static(&S)
refactoring.ivar.inplace.introducer.generate.property=生成屬性(&P)
refactoring.ivar.inplace.introducer.declare.interface=在接口中宣告(&I)
refactoring.introducer.declare.const=宣告 const(&C)
refactoring.introducer.declare.auto=宣告 auto(&A)
refactoring.parameter.introducer.refactor.super.method=重構 super {0}(&S)
refactoring.property.introducer.make.readonly=設為唯讀(&R)
refactoring.property.introducer.generate.synthesize=生成 @synthesize(&S)
refactoring.property.introducer.generate.instance.variable=生成實例變數(&I)
refactoring.property.introducer.put.to.private.category=置於私有類別(&P)
dialog.title.choose.containing.class=選擇包含類
dialog.message.variable.must.be.const=變數“{0}”必須為常數
dialog.message.cannot.find.method.function=找不到方法/函數
dialog.message.cannot.inline.parameters.blocks=無法內聯塊的參數
dialog.message.cannot.inline.parameters.lambdas=無法內聯 lambda 的參數
dialog.message.several.call.sites.with.different.parameter.initializers=存在多個帶有不同參數初始設定式的調用站點
dialog.message.there.are.no.usages=沒有 {0} 的用法
dialog.message.cannot.inline.blocks=無法內聯塊
dialog.message.cannot.inline.protocol.method=無法內聯協議方法
dialog.message.interface.was.not.implemented=接口 {0} 未實作
dialog.message.cannot.inline.with.empty.body=無法將 {0} 和空體內聯
dialog.message.there.are.no.calls.in.project=專案中沒有 {0} 調用
dialog.message.cannot.inline.methods.with.return.statements.interrupting.execution.flow=return 語句中斷執行流時無法內聯方法
question.inline.usage=內聯 {2} 的 {0} 用法{1, choice, 0#|1#}嗎?
message.never.used={0} 從未使用
dialog.message.accessed.for.writing={0} 可寫
dialog.message.accessed.for.address=存取 {0} 以獲取地址
dialog.title.inline=內聯 {0}
button.inline.current.usage=內聯當前用法(&C)
button.inline.all.usages.file=內聯{0, choice, 0#檔案中的|1#}所有用法(&A)
button.view.usages=顯示用法(&S)
button.cancel=取消(&C)
button.inline=內聯(&I)
button.rename=重命名(&R)
button.rename.code=僅重命名程式碼用法(&C)
button.rename.all=重命名所有用法(&R)
dialog.message.must.have.initializer={0} 必須具有初始設定式

rename.reference.command.name=重命名引用
rename.reference.invalid.dialog.title=無效關鍵字
rename.reference.invalid.dialog.button.yes=繼續編輯

rename.multiple.macro.usages.message={0} 對 "{1}" 有幾種映射不同的用法。重命名可能會破壞程式碼。是否要繼續?
rename.non.code.usages.message=在註釋和非程式碼檔案中發現 {0} 個{0, choice, 1#用法|2#用法}。\n要將{0, choice, 1#其|2#其}重命名嗎?
dialog.title.extract.method=提取方法
dialog.title.extract.function=提取函數
dialog.title.extract.block.parameter=提取塊參數
dialog.title.extract.lambda.parameter=提取 Lambda 參數
dialog.message.lambdas.not.supported=當前語言標準不支持 lambda
dialog.message.lambdas.cant.extract.initializer.list=無法將初始設定式列表提取到 lambda 參數
dialog.message.lambdas.cant.extract.functional.type=無法將函數類型的表達式提取到 lambda 參數
dialog.message.lambdas.cant.extract.dependent.types=無法將具有依賴類型的表達式提取到 lambda 參數
dialog.message.cant.refactor.operators=無法重構 C++ 運算符函數
button.extract=提取
dialog.message.cannot.extract.there.are.multiple.exit.points.in.selected.code.fragment=無法提取{0}。\n所選程式碼段中有多個出口點.
dialog.message.selected.statements.should.be.inside.function.choice.or.method=選定的語句應在函數{0, choice, 0#或方法|1#}內
dialog.message.can.t.refactor.with.variable.arguments=無法重構具有可變實參的{0}
dialog.message.overrides.in.choice.which.out.project={0} 覆寫{3, choice, 0#專案外的|1#} {2} 中的 {1}。
dialog.message.do.you.want.to.proceed.refactoring=繼續進行重構?
dialog.message.do.you.want.to.refactor.base.s=重構基{0}?
label.declaration.place=宣告位置:
refactoring.rename.command.name=重命名
trying.to.rename.0.to.existing.file.name.1=試圖將 {0} 重命名為現有文件名 {1}
file.0.already.exists.in.the.project=檔案 ''{0}'' 已經存在於專案中
refactoring.rename.0.already.exists.in.1={1} 中已存在 {0}
refactoring.rename.0.already.exists.in.the.scope=範圍中已存在 {0}
dialog.message.name.invalid={0} 名稱無效
dialog.message.return.type.invalid={0} 的返回類型無效
dialog.message.no.selector.parts.for={0} 沒有選擇器部分
dialog.message.containing.class.invalid=包含類“{0}”無效
dialog.message.containing.class.outside.project=包含類“{0}”在專案之外
dialog.message.selector.part.invalid=選擇器部分 ''{0}'' 無效
dialog.message.parameter.name.invalid=參數名 ''{0}'' 無效
selected.expression.should.be.inside.a.block.statement=所選表達式應位於塊語句內
can.t.refactor.the.compound.initializer=無法重構複合初始設定式
cannot.determine.type.of.the.selected.expression=無法確定所選表達式的類型
cannot.perform.refactoring.selected.expression.has.void.type=無法執行重構，因為所選表達式具有 void 類型。
selected.expression.cannot.be.a.constant.initializer=所選表達式不能是常數初始設定式
selected.expression.should.be.inside.an.instance.method=所選表達式應位於實例方法內
selected.expression.should.be.inside.a.function.or.method=所選表達式應位於函數或方法內
can.t.introduce.parameter.to.a.function.with.default.parameter.values=無法將參數引入具有預設參數值的函數
selected.expression.should.be.inside.an.instance.method1=所選表達式應位於實例方法內
property.inplace.introducer.label.semantics=語意
declaration.must.have.one.declarator.to.introduce.the.type=宣告必須具有一個宣告器以引入類型
namespace.qualifier.should.be.resolved.to.the.class=命名空間限定符應解析為該類
the.type.is.empty=類型為空
can.t.extract.type.of.0.definition=無法提取 {0} 定義的類型
dialog.message.can.t.move.to.itself=無法將 ''{0}'' 移至自身
dialog.message.can.t.copy.to.itself=無法將 ''{0}'' 複製到自身
dialog.message.directory.already.exists.at=目錄在 ''{0}'' 已存在
dialog.message.file.already.exists.at=''{0}'' 已存在檔案
dialog.message.file.already.exists=檔案已存在
extract.dialog.button.extract=提取(&R)
escalate.visibility.member.column=成員
escalate.visibility.current.visibility.column=當前可見性
escalate.visibility.required.visibility.column=所需可見性
push.down.inheritor.column=繼承者
text.parameter.initializer.not.available.in=參數初始設定式在 {0} 中不可用: {1}。
cannot.inline.function.type=無法內聯函數類型
cannot.inline.constructor.expression=無法內聯構造函數表達式
can.t.inline.definition=無法內聯 {0} 定義
cannot.inline.the.macro.inside.another.macro.definition=無法內聯另一個巨集定義中的巨集
cannot.find.the.method.function=找不到方法/函數
there.are.usages.in.other.blocks=在其他塊中存在用法
0.was.not.initialized={0} 未初始化
there.are.several.definitions.of={0} 存在多個定義
the.address.of.is.taken={0} 的地址已被佔用
element.is.written.in.the.block={0} 寫於塊中
several.definitions.of.0={0} 存在多個定義
element.is.accessed.for.writing={0} 可寫
cannot.inline.usages.inside.the.macro.substitutions=無法內聯巨集取代內的用法
element.has.inheritor={0} 帶有繼承者{1, choice, 0#方法|1#函數}
element.inherits.method={0} 從 {1} 繼承方法
cannot.inline.method.reference.in.selector.expression=無法在 '@selector' 表達式中內聯方法引用
cannot.inline.method.reference.in.xml.file=無法在 XML 檔案中內聯方法引用
cannot.inline.method.reference.in.property.attribute=無法在屬性特性中內聯方法引用
cannot.inline.function.reference.in.non.call.expression=無法在非調用表達式中內聯函數引用
cannot.inline.usage.in.swift.code=無法在 Swift 程式碼中內聯用法
cannot.inline.recursive=無法內聯遞歸 {0} 調用
dialog.message.elements.to=要{0}的元素
top.level.namespace.placeholder=頂層命名空間

dialog.message.paramer.default.value.invalid=''{0}'' 不是表達式
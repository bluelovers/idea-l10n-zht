# ## org/jetbrains/plugins/scala/DesktopUtils.scala
title.problem.opening.web.page=開啟網頁時出現問題
html.unable.to.launch.web.browser=<html><body>無法啟動 Web 瀏覽器，請手動開啟: <br />{0}(<a href="{0}">複製到剪貼簿</a>)</body></html>

# ## org/jetbrains/plugins/scala/actions/EditPackagePrefixAction.scala
edit.package.prefix=編輯軟體套件前綴…

# ## org/jetbrains/plugins/scala/actions/MakeExplicitAction.scala
make.implicit.conversion.explicit.action.text=將隱式轉換設為顯式
make.implicit.conversion.explicit.action.description=將隱式轉換設為顯式
title.choose.implicit.conversion.method=選擇隱式轉換方法:
press.alt.enter=按 Alt+Enter
make.explicit=設為顯式
make.explicit.and.import.method=設為顯式(匯入方法)

# ## org/jetbrains/plugins/scala/actions/NewPackageObjectAction.scala
new.packageobject.menu.action.text=軟體套件物件
new.packageobject.menu.action.description=創建新的 Scala 軟體套件物件

# ## org/jetbrains/plugins/scala/actions/NewScalaTypeDefinitionAction.scala
newclass.menu.action.text=Scala 類
newclass.menu.action.description=創建新的 Scala 類
create.new.scala.class=創建新的 Scala 類
this.is.not.a.valid.scala.qualified.name=這不是有效的 Scala 限定名稱

# ## org/jetbrains/plugins/scala/actions/ScalaExpressionTypeProvider.scala
no.expression.found=找不到表達式
type.hint.table.title.type=類型
type.hint.table.title.dealiased=取消設定別名
type.hint.table.title.widened=擴大
type.hint.table.title.expected=預期
type.hint.table.title.without.implicits=無隱式
unknown.type=<未知>

# ## org/jetbrains/plugins/scala/actions/ShowTypeInfoAction.scala
type.info.text=類型資訊
type.info.description=顯示類型資訊
could.not.find.type.for.selection=找不到選擇的類型
hint.label.non.singleton=非單例
hint.label.simplified=簡化
hint.label.original=原始
hint.label.expected=預期

# ## org/jetbrains/plugins/scala/actions/ToggleTypeAwareHighlightingAction.scala
toggle.type.aware.highlighting.menu.action.text=切換類型感知高亮顯示
toggle.type.aware.highlighting.menu.action.description=切換類型感知高亮顯示

# ## org/jetbrains/plugins/scala/actions/implicitArguments/ImplicitArgumentNodes.scala
implicit.argument.is.applicable=隱式參數適用
implicit.is.diverged=隱式分叉
can.t.infer.proper.types.for.type.parameters=無法推斷類型參數的正確類型
can.t.find.implicit.argument.for.this.definition=無法找到此定義的隱式參數
no.implicits.applicable.by.type=沒有按類型適用的隱式定義
reason.prefix.applicable=適用: 
reason.prefix.diverged=分叉: 
reason.prefix.cannot.infer.type=無法推斷類型: 
reason.prefix.candidate=候選: 
problem.prefix.ambiguous=(模糊)
problem.prefix.not.found=(未找到)
location.description.parameter.of.name={0} 的參數
location.description.parameter.of.getclassnametext={0} 的參數
location.description.anonymous.class=匿名類
location.description.containing.block=包含塊
location.description.body.of.name={0} 的正文

# ## org/jetbrains/plugins/scala/actions/implicitArguments/ShowImplicitArgumentsAction.scala
show.implicit.arguments.action.text=顯示隱式實參
show.implicit.arguments.action.description=顯示隱式實參
no.implicit.arguments=無隱式實參
title.expressions=表達式
navigate=導航
implicit.arguments.for.implicit.conversion=適用於隱式轉換的隱式參數:
implicit.arguments=隱式參數:

# ## org/jetbrains/plugins/scala/actions/implicitConversions/ShowImplicitConversionsAction.scala
implicit.conversions.action.text=顯示隱式轉換
implicit.conversions.action.description=顯示隱式轉換

# ## org/jetbrains/plugins/scala/actions/internal/ScalaCollectShortTroubleshootingInfoAction.scala
scala.collect.troubleshooting.information.short.action.text=(Scala)收集簡短的故障排除資訊
scala.collect.troubleshooting.information.short.action.description=收集 Scala 延伸模組和 IntelliJ IDEA 版本，以將其快速貼上到 YouTrack
short.troubleshooting.summary.copied.to.your.clipboard.with.summary=簡短的故障排除摘要已複製到剪貼簿\n{0}

# ## org/jetbrains/plugins/scala/annotator/AnnotatorUtils.scala
# TODO unify type mismatch messages
type.mismatch.found.required=類型不符合，實際為 {0}，要求 {1}
# TODO unify type mismatch messages
type.mismatch.expected.actual=類型不符合，應為 {0}，實際為 {1}
abstract.member.not.have.private.modifier=abstract 成員可能沒有 private 修飾符
illegal.inheritance.from.sealed.kind=從密封的 {0} ''{1}'' 非法繼承

# ## org/jetbrains/plugins/scala/annotator/ByNameParameter.scala
passed.as.by.name.parameter=作為傳名參數傳遞

# ## org/jetbrains/plugins/scala/annotator/FunctionAnnotator.scala
function.must.define.type.explicitly=方法 {0} 包含 return 語句；需要結果類型
function.recursive.need.result.type=遞歸方法 {0} 需要結果類型
family.name.remove.tailrec.annotation=移除 @tailrec 註解
method.annotated.with.tailrec.is.neither.private.nor.final=使用 @tailrec 註解的方法既非私有也非最終 (因此可以覆寫)
method.annotated.with.tailrec.contains.no.recursive.calls=使用 @tailrec 註解的方法不包含任何遞歸調用
recursive.call.not.in.tail.position=遞歸調用不在尾部位置(在 @tailrec 註解的方法中)

# ## org/jetbrains/plugins/scala/annotator/OverridingAnnotator.scala
member.needs.override.modifier={0} ''{1}'' 需要覆寫修飾符
member.overrides.nothing={0} ''{1}'' 不覆寫任何內容
can.not.override.final={0} ''{1}'' 無法覆寫 final 成員
member.cannot.override.var=方法 {0} 無法覆寫可變變數
member.cannot.override.val=方法 {0} 必須為不可變的穩定值
var.cannot.override.val=變數 {0} 無法覆寫不可變值
override.types.not.conforming=覆寫類型 {0} 與基本類型 {1} 不符
regular.method.overrides.extension=方法 {0} 是一個普通方法，無法覆寫擴展方法
extension.method.overrides.regular=方法 {0} 是一個擴展方法，無法覆寫普通方法

# ## org/jetbrains/plugins/scala/annotator/ScalaAnnotator.scala
covariant.type.contravariant.position.of.method=協變類型 {0} 出現在方法 {2} 的類型 {1} 中的逆變位置
covariant.type.contravariant.position.of.value=協變類型 {0} 出現在值 {2} 的類型 {1} 中的逆變位置
covariant.type.invariant.position.of.method=協變類型 {0} 出現在方法 {2} 的類型 {1} 中的不變位置
covariant.type.invariant.position.of.value=協變類型 {0} 出現在值 {2} 的類型 {1} 中的不變位置
contravariant.type.covariant.position.of.method=逆變類型 {0} 出現在方法 {2} 的類型 {1} 中的協變位置
contravariant.type.covariant.position.of.value=逆變類型 {0} 出現在值 {2} 的類型 {1} 中的協變位置
contravariant.type.invariant.position.of.method=逆變類型 {0} 出現在方法 {2} 的類型 {1} 中的不變位置
contravariant.type.invariant.position.of.value=逆變類型 {0} 出現在值 {2} 的類型 {1} 中的不變位置

# ## org/jetbrains/plugins/scala/annotator/ScopeAnnotator.scala
id.is.already.defined=此範圍中已定義 {0}

# ## org/jetbrains/plugins/scala/annotator/TypeMismatchError.scala
# TODO unify type mismatch messages
type.mismatch.message=類型不符合。要求 {0}， 實際為 {1}

# ## org/jetbrains/plugins/scala/annotator/TypeMismatchToggleAction.scala
type.mismatch.hints.action.text=類型不符合提示
type.mismatch.hints.action.description=切換類型不符合提示

# ## org/jetbrains/plugins/scala/annotator/createFromUsage/CreateApplyQuickFix.scala
family.name.create.apply.method=創建 ''apply'' 方法
create.apply.method.in=在 {0} 中創建 ''apply'' 方法

# ## org/jetbrains/plugins/scala/annotator/createFromUsage/CreateEntityQuickFix.scala
error.message.title.create.entity.quickfix=創建實體快速修復

# ## org/jetbrains/plugins/scala/annotator/createFromUsage/CreateExtractorObjectQuickFix.scala
family.name.create.extractor.object=創建提取程序物件
create.extractor.object.named=創建提取程序物件 ''{0}''

# ## org/jetbrains/plugins/scala/annotator/createFromUsage/CreateParameterlessMethodQuickFix.scala
family.name.create.parameterless.method=創建無形參方法
create.parameterless.method.named=創建無形參方法 ''{0}''
family.name.create.variable=創建變數
create.variable.named=創建變數 ''{0}''
family.name.create.value=創建值
create.value.named=創建值 ''{0}''
family.name.create.method=創建方法
create.method.named=創建方法 ''{0}''

# ## org/jetbrains/plugins/scala/annotator/createFromUsage/CreateTypeDefinitionQuickFix.scala
family.name.create.object=創建物件
family.name.create.trait=創建特徵
family.name.create.class=創建類
family.name.create.case.class=創建案例類
create.object.named=創建物件 ''{0}''
create.trait.named=創建特徵 ''{0}''
create.class.named=創建類 ''{0}''
create.case.class.named=創建案例類 ''{0}''
choose.level.popup.title=選擇級別
new.class.location.new.file=新檔案
new.class.location.top.level.in.this.file=此檔案的頂層
new.class.location.inner.in.class={0} 中的內部
new.class.location.local.scope=局部範圍

# ## org/jetbrains/plugins/scala/annotator/createFromUsage/CreateUnapplyQuickFix.scala
family.name.create.unapply.method=創建 ''unapply'' 方法
create.unapply.method.in=在 {0} 中創建 ''unapply'' 方法

# ## org/jetbrains/plugins/scala/annotator/element/ScAnnotationAnnotator.scala
scala.meta.recompile=元程式設計已過期。點擊此處進行編譯
scala.meta.expandfailed=巨集擴展失敗: {0}

# ## org/jetbrains/plugins/scala/annotator/element/ScAssignmentAnnotator.scala
annotator.error.wrong.right.assignment.side=賦值右側錯誤
annotator.error.reassignment.to.val=重新賦值給 val
illegal.assignment.target=非法賦值目標

# ## org/jetbrains/plugins/scala/annotator/element/ScCatchBlockAnnotator.scala
# TODO unify type mismatch messages
expr.type.does.not.conform.expected.type=類型 {0} 的表達式不符合預期類型 {1}
method.is.not.member=方法 {0} 不是類型 {1} 的成員
expected.type.boolean=預期布林型態作為方法 {0} 返回類型

# ## org/jetbrains/plugins/scala/annotator/element/ScCharLiteralAnnotator.scala
missing.char.value=缺少字符值

# ## org/jetbrains/plugins/scala/annotator/element/ScClassAnnotator.scala
illegal.secondary.constructors.value.class=值類中不允許使用輔助構造函數
value.class.can.have.only.one.parameter=值類只能有一個參數
value.class.can.have.only.val.parameter=值類只能有一個非私有 val 參數
type.parameter.value.class.may.not.be.specialized=值類的類型參數可能沒有專門化
value.classes.cannot.have.nested.objects=值類不能有嵌套的類、物件或特徵
value.classes.cannot.redefine.equals.hashcode=值類無法重新定義 equals 和 hashCode
value.classes.can.have.only.defs=值類中不允許欄位定義
value.classes.may.not.be.member.of.another.class=值類不得為另一個類的成員

# ## org/jetbrains/plugins/scala/annotator/element/ScConstrBlockExprAnnotator.scala
constructor.invocation.expected=輔助構造函數必須以調用 ''this'' 開頭

# ## org/jetbrains/plugins/scala/annotator/element/ScConstructorInvocationAnnotator.scala
# TODO unify type mismatch messages
type.mismatch.default.args.expected.actual=類型不符合涉及預設實參，應為: {0}，實際為: {1}
annotator.error.class.type.required.but.found=需要類類型，但找到的是({0})
annotator.error.constructor.has.malformed.definition=構造函數的定義格式錯誤
annotator.error.no.constructor.accessible=從此處無法存取構造函數
annotator.error.cannot.resolve.overloaded.constructor=無法解析多載的構造函數 `{0}`
annotator.error.unspecified.value.parameters=未指定的值參數: {0}
annotator.error.trait.has.no.constructor={0} 是特徵；不接受構造函數實參
annotator.error.too.many.arguments.for.constructor=構造函數 {0} 的實參過多
annotator.error.missing.argument.list.for.constructor=構造函數 {0} 缺少實參列表
annotator.error.expansion.for.non.repeated.parameter=非重複參數擴展
annotator.error.positional.after.named.argument=位於命名實參後
annotator.error.parameter.specified.multiple.times=多次指定了參數
annotator.error.cannot.apply.constructor=無法套用構造函數 {0}

# ## org/jetbrains/plugins/scala/annotator/element/ScEnumCaseAnnotator.scala
annotator.error.enum.nonvariant.type.param,in.enum=無法確定枚舉類父級 {0} 的類型實參，類型參數 {1} 不變
annotator.error.enum.case.must.extend.parent=枚舉 case 必須擴展其枚舉類 {0}
annotator.error.enum.two.type.parameter.clauses=需要顯式 extends 子句，因為枚舉 case 和枚舉類都有類型參數

# ## org/jetbrains/plugins/scala/annotator/element/ScEnumeratorsAnnotator.scala
semicolon.not.allowed.here=此處不允許使用分號
remove.all.erroneous.semicolons.from.forexpression=從 for 表達式中移除所有錯誤的分號

# ## org/jetbrains/plugins/scala/annotator/element/ScExpressionAnnotator.scala
else.expected=應為 ''else''

# ## org/jetbrains/plugins/scala/annotator/element/ScForAnnotator.scala
for.pattern.bindings.require.scala3=''for'' 模式綁定中的 ''case'' 語法需要 Scala 3.0
enumerators.generator.val.keyword.found=應為模式，但找到的是 ''val''

# ## org/jetbrains/plugins/scala/annotator/element/ScForBindingAnnotator.scala
enumerators.binding.val.keyword.deprecated=枚舉器中的 ''val'' 關鍵字已棄用
enumerators.binding.case.keyword.found=應為模式，但找到的是 ''case''
remove.case=移除 ''case''
family.name.remove.case.from.enumerator=從枚舉器中移除 ''case''

# ## org/jetbrains/plugins/scala/annotator/element/ScFunctionExprAnnotator.scala
annotator.error.too.many.parameters=參數過多
annotator.error.missing.parameter.type=缺少參數類型
type.mismatch.expected=類型不符合，應為 {0}，實際為 {1}

# ## org/jetbrains/plugins/scala/annotator/element/ScFunctionalTypeElementAnnotator.scala
repeated.param.non.method=僅方法簽名中允許重複的參數。改用 `Seq`

# ## org/jetbrains/plugins/scala/annotator/element/ScImportExprAnnotator.scala
import.expr.should.be.qualified=必須限定 import 表達式

# ## org/jetbrains/plugins/scala/annotator/element/ScInterpolatedStringLiteralAnnotator.scala
cannot.resolve.in.StringContext=值 ''{0}'' 不是 StringContext 的成員

# ## org/jetbrains/plugins/scala/annotator/element/ScLiteralTypeElementAnnotator.scala
wrong.type.no.literal.types=錯誤的類型 `{0}`，使用 Scala 2.13 或帶有 `-Yliteral-types` 編譯器標誌的 Typelevel Scala 來支援文字類型
identifier.expected.but.0.found=應為關鍵字，但實際是{0}

# ## org/jetbrains/plugins/scala/annotator/element/ScMacroDefAnnotator.scala
macro.defs.must.have.explicit.return.type=巨集定義必須有顯式指定的返回類型

# ## org/jetbrains/plugins/scala/annotator/element/ScMethodInvocationAnnotator.scala
annotator.error.unspecified.value.parameters.mkstring=未指定的值參數: {0}
annotator.error.cannot.resolve.overloaded.method=無法解析多載方法
annotator.error.too.many.arguments=實參過多
annotator.error.target.does.not.take.parameters={0} 不接受參數
missing.argument.list.for.method.with.explicit.list=方法 {1} 缺少參數列表 {0}
missing.argument.list.for.method=方法 {0} 缺少參數列表
does.not.take.parameter.default.target=套用程序
annotator.error.too.many.arguments.method=方法 {0} 的實參過多
annotator.error.name.has.malformed.definition=''{0}'' 的定義格式錯誤

# ## org/jetbrains/plugins/scala/annotator/element/ScNewTemplateDefinitionAnnotator.scala
illegal.instantiation={0} ''{1}'' 為 abstract；無法實例化

# ## org/jetbrains/plugins/scala/annotator/element/ScNumericLiteralAnnotator.scala
octal.literals.removed=自 Scala 2.11 起已禁用八進制文字語法
trailing.underscore.separator=不允許使用尾隨的下劃線分隔符
illegal.underscore.separator=下劃線分隔符需要使用 Scala 2.13
long.literal.is.out.of.range=整數甚至超出 Long 類型的範圍
integer.literal.is.out.of.range=整數文字超出 Int 類型的範圍
lowercase.long.marker=小寫的 long 文字標記

# ## org/jetbrains/plugins/scala/annotator/element/ScParameterAnnotator.scala
annotator.error.parameter.without.an.owner.name=沒有所有者的參數: {0}
annotator.error.missing.type.annotation.for.parameter=參數缺少類型註解: {0}
missing.parameter.type.name=缺少參數類型: {0}
topic.parameters.may.not.be.call.by.name={0} 參數可能不是傳名調用

# ## org/jetbrains/plugins/scala/annotator/element/ScParameterizedTypeElementAnnotator.scala
unspecified.type.parameters=未指定的類型參數: {0}
too.many.type.arguments.for.typeparamowner={0}的類型實參過多，應為 {1} 個，實際為 {2} 個
type.arg.does.not.conform.to.upper.bound=類型 {0} 不符合類型參數 {2} 的上界 {1}
type.arg.does.not.conform.to.lower.bound=類型 {0} 不符合類型參數 {2} 的下界 {1}
name.does.not.take.type.arguments={0} 不接受類型實參
expected.type.constructor=應為類型構造函數 {0}
type.constructor.does.not.conform=類型構造函數 {0} 不符合 {1}
type.constructor.mismatch=類型構造函數不符合。

# ## org/jetbrains/plugins/scala/annotator/element/ScParametersAnnotator.scala
annotator.error.repeated.parameter.must.be.last=*-參數必須位於最後
annotator.error.repeated.or.default=帶 *-參數的參數部分不允許有預設實參

# ## org/jetbrains/plugins/scala/annotator/element/ScPatternAnnotator.scala
pattern.on.refinement.unchecked=細化類型中的模式符合未檢查
type.cannot.be.used.in.type.pattern=類型 {0} 不能在類型模式或 isInstanceOf 測試中使用
scrutinee.incompatible.pattern.type=Scrutinee 與模式類型不相容，實際為 {0}，要求 {1}
pattern.type.incompatible.with.expected=模式類型與預期類型不相容，實際為 {0}，要求 {1}
constructor.cannot.be.instantiated.to.expected.type=構造函數無法實例化為預期類型，實際為 {0}，要求 {1}
fruitless.type.test=fruitless type test: 類型 {0} 的值不能同時也為 {1}
erasure.warning=(但仍可能符合其擦除)
wrong.number.arguments.extractor=提取程序的實參數量錯誤，實際為 {0} 個，應為 {1} 個
wrong.number.arguments.extractor.unapplySeq=提取程序的實參數量錯誤，實際為 {0} 個，應為 {1} 個或更多
stable.identifier.required=需要穩定的關鍵字，但找到的是 {0}
better.monadic.for.invalid.pattern=實參必須有顯式類型註解

# ## org/jetbrains/plugins/scala/annotator/element/ScPatternArgumentListAnnotator.scala
vararg.pattern.must.be.last.pattern=_* 僅可用於最後一個實參

# ## org/jetbrains/plugins/scala/annotator/element/ScPatternTypeUnawareAnnotator.scala
vararg.pattern.with.colon.requires.scala3=vararg 模式中的 '':'' 語法需要使用 Scala 3.0
vararg.pattern.with.at.deprecated.since.scala3=vararg 模式中的 ''@'' 語法自 Scala 3.0 起已棄用
vararg.short.pattern.with.at.deprecated.since.scala3=_* 短模式語法自 Scala 3.0 起已棄用
family.name.replace.type.with.type.in.vararg.pattern=將 '':'' 取代為 vararg 模式中的 ''@''
family.name.replace.with.scala3.vararg.pattern=將 '':'' 語法取代為 Scala 3.0 vararg 模式
replace.with.type=取代為 ''{0}''
replace.with.scala3.wildcard.varargs=取代為 ''_: _*''
family.name.replace.old.varags.with.scala3.varargs.pattern=將 vararg 模式中的 ''_*'' 取代為 ''_: _*''

# ## org/jetbrains/plugins/scala/annotator/element/ScPolyFunctionExprAnnotator.scala
poly.function.without.parameters=多態函數 {0} 必須有一個值參數

# ## org/jetbrains/plugins/scala/annotator/element/ScReferenceAnnotator.scala
cannot.resolve=無法解析符號 {0}
cannot.resolve.overloaded=無法解析多載方法 ''{0}''
forward.reference.detected=錯誤的前向引用
cannot.resolve.apply.method=無法解析方法 {0}.apply
cannot.resolve.unapply.method=無法解析方法 {0}.unapply
annotator.error.missing.arguments.for.method=方法 {0} 缺少實參
symbol.is.inaccessible.from.this.place=無法從此處存取符號 {0}

# ## org/jetbrains/plugins/scala/annotator/element/ScReturnAnnotator.scala
return.expression.is.redundant=從 Unit 結果類型的方法返回 {0}
return.outside.method.definition=return 語句在方法定義外部

# ## org/jetbrains/plugins/scala/annotator/element/ScSelfInvocationAnnotator.scala
called.constructor.definition.must.precede=被調用的構造函數的定義必須在調用構造函數的定義前面
annotator.error.cannot.find.constructor.for.this.call=找不到此調用的構造函數

# ## org/jetbrains/plugins/scala/annotator/element/ScSimpleTypeElementAnnotator.scala
type.takes.type.parameters=類型 {0} 接受類型參數

# ## org/jetbrains/plugins/scala/annotator/element/ScStringLiteralAnnotator.scala
string.literal.is.too.long=字串文字大小超出編譯器限制
string.literal.invalid.escape.character=無效的轉義字符
string.literal.invalid.unicode.escape=無效的 unicode 轉義

# ## org/jetbrains/plugins/scala/annotator/element/ScSymbolLiteralAnnotator.scala
symbolliterals.are.deprecated=Scala 2.13 中已棄用符號文字。請改用 Symbol("{0}")。

# ## org/jetbrains/plugins/scala/annotator/element/ScTemplateDefinitionAnnotator.scala
illegal.inheritance.self.type=非法繼承，自類型 {0} 不符合 {1}
mixin.required={0} ''{1}'' 需要為 mixin，因為 ''{3}'' 中的成員 ''{2}'' 被標記為 ''abstract'' 和 ''override''，但在基類中找不到具體的實作
illegal.undefined.member=僅類可以具有已宣告但未定義的成員
illegal.inheritance.from.final.kind=從 final {0} ''{1}'' 的非法繼承
illegal.inheritance.from.value.class=從值類 {0} 非法繼承
illegal.inheritance.extends.enum=禁止擴展枚舉
trait.may.not.call.constructor=特徵 {0} 不能調用 {1} 的構造函數
trait.is.already.implemented.by.superclass=特徵 {0} 已由超類 {1} 實作，不能再次調用其構造函數
parameterised.trait.is.implemented.indirectly=參數化特徵 {0} 為間接實作，需要直接實作，以便可以傳遞實參
illegal.inheritance.multiple={0} ''{1}'' 繼承了多次
illegal.mixin={0} ''{1}'' 必須是特徵才可以混入
member.implementation.required={0} ''{1}'' 必須宣告為 abstract，或者必須在 ''{3}'' 中實作 abstract 成員 ''{2}''
object.creation.impossible.since=由於{0}，無法創建物件
member.is.not.defined={1} 中的成員 {0} 未定義

# ## org/jetbrains/plugins/scala/annotator/element/ScTraitAnnotator.scala
trait.parameter.require.scala3=特徵參數需要使用 Scala 3.0

# ## org/jetbrains/plugins/scala/annotator/element/ScNamedElementAnnotator.scala
var.cannot.be.overriden=不能覆寫可變變數

# ## org/jetbrains/plugins/scala/annotator/element/ScTypeBoundsOwnerAnnotator.scala
lower.bound.conform.to.upper=下界與上界不符

# ## org/jetbrains/plugins/scala/annotator/element/ScTypedExpressionAnnotator.scala
cannot.upcast.type.to.other.type=無法將 {0} 向上轉換為 {1}

# ## org/jetbrains/plugins/scala/annotator/element/ScUnderscoreSectionAnnotator.scala
unbound.placeholder.parameter=未綁定的佔位符參數
local.variables.must.be.initialized=局部變數必須初始化
default.init.prohibited.literal.types=文字型變數禁止預設初始化

# ## org/jetbrains/plugins/scala/annotator/element/ScValueOrVariableAnnotator.scala
annotation.ascriptions.in.pattern.definitions.require.scala3=模式定義中的註解歸屬需要使用 Scala 3.0

# ## org/jetbrains/plugins/scala/annotator/gutter/RecursiveCallLineMarkerProvider.scala
method.is.recursive=方法 ''{0}'' 為遞歸方法
method.is.tail.recursive=方法 ''{0}'' 為尾遞歸方法

# ## org/jetbrains/plugins/scala/annotator/gutter/ScalaGoToSuperActionHandler.scala
goto.super.member.chooser.title=選擇 super 成員
goto.super.class.chooser.title=選擇超類
goto.super.class.or.member.chooser.title=選擇超類/super 成員

# ## org/jetbrains/plugins/scala/annotator/gutter/ScalaLineMarkerProvider.scala
companion.class=類
companion.object=物件
companion.trait=特徵
companion.enum=枚舉
go.to.companion=轉到伴生 {0}
go.to.implementation=轉到實作
go.to.super.method=轉到 super 成員
gutter.companion=伴生
gutter.implemented=被實作成員
gutter.implementing=實作成員
gutter.overridden=被覆寫成員
gutter.overriding=覆寫成員
gutter.recursion=遞歸類型
gutter.sam=實作 SAM
has.companion=具有伴生 {0}
multiple.overriding.tooltip=多個覆寫成員
multiple.overriden.tooltip=多個被覆寫成員
scala.line.markers=Scala 行標記

# ## org/jetbrains/plugins/scala/annotator/gutter/ScalaMarkerType.scala
implements.member.prefix=實作成員
implements.member.from.prefix=成員實作自
implements.member.from.several.classes=實作 {0} 類中的成員
overrides.member.from.prefix=覆寫成員自
overrides.member.from.several.classes=覆寫 {0} 類中的成員
overrides.type.prefix=覆寫類型
overrides.type.from.super.several.classes=覆寫 {0} 類中的類型
navigation.title.super.members=選擇 {0} 的 super 成員
navigation.findUsages.title.super.members={0} 的 super 成員
navigation.title.super.types=選擇 {0} 的父類型成員
navigation.findUsages.title.super.types={0} 的父類型成員
trait.has.implementations=混合到
trait.has.several.implementations=混合到 {0} 類中
class.has.subclasses=由以下物件擴展
class.has.several.subclasses=由 {0} 個子類擴展
has.implementations=成員有多個實作
is.overridden.by=成員有多個覆寫
navigation.title.inheritors.trait=<html>選擇 <b>{0}</b> 的實作(找到 {1} 個類)</html>
navigation.findUsages.title.inheritors.trait={0} 的實作
navigation.title.inheritors.class=<html>選擇 <b>{0}</b> 的子類(找到 {1} 個類)</html>
navigation.findUsages.title.inheritors.class={0} 的子類
navigation.title.implementing.member=<html>選擇 <b>{0}</b> 的實作成員(找到 {1} 個成員)</html>
navigation.findUsages.title.implementing.member={0} 的實作成員
navigation.title.overriding.member=<html>選擇 <b>{0}</b> 的覆寫成員(找到 {1} 個成員)</html>
navigation.findUsages.title.overriding.member={0} 的覆寫成員

# ## org/jetbrains/plugins/scala/annotator/hints/HintUI.scala
type.mismatch.dot=類型不符合.

# ## org/jetbrains/plugins/scala/annotator/modifiers/ModifierChecker.scala
lazy.modifier.is.not.allowed.here=''lazy'' 修飾符僅允許用於值定義
lazy.modifier.is.not.allowed.with.param=此處不允許使用 ''lazy'' 修飾符，請改用傳名調用參數
lazy.values.may.not.be.abstract=lazy 值可能不為 abstract
final.modifier.not.with.declarations=''final'' 修飾符不能用於不完整的成員
final.modifier.not.with.trait=不允許對特徵使用 ''final'' 修飾符
final.modifier.is.redundant.with.final.parents=''final'' 修飾符對於物件或 final 類成員是冗餘的
final.modifier.is.not.allowed.here=此處不允許使用 ''final'' 修飾符
access.modifier.is.not.allowed.here=此處不允許使用 ''{0}'' 修飾符
abstract.modifier.redundant.fot.traits=''abstract'' 修飾符對於特徵是冗餘的
abstract.modifier.is.not.allowed=''abstract'' 修飾符僅允許用於類或包含 ''override'' 修飾符的定義
abstract.override.modifier.is.not.allowed=''abstract override'' 修飾符僅允許用於特徵的成員
override.modifier.is.not.allowed.for.classes=''override'' 修飾符僅允許用於類型定義成員
override.modifier.is.not.allowed=此處不允許使用 ''override'' 修飾符
sealed.modifier.is.not.allowed.here=此處不允許使用 ''sealed'' 修飾符
illegal.modifiers.combination=非法的修飾符組合: {0} 和 {1}
implicit.modifier.cannot.be.used.for.top.level.objects=''implicit'' 修飾符無法用於頂層物件
implicit.class.must.have.a.primary.constructor.with.one.argument=隱式類必須具有主構造函數，並且該構造函數恰好包含第一個參數列表中的一個實參
implicit.modifier.can.be.used.only.for=''implicit'' 修飾符只能用於值、變數、方法和類

# ## org/jetbrains/plugins/scala/annotator/package.scala
tree.mismatch.tooltip=<html><body>{0}<table><tr><td>要求 </td>{1}</tr><tr><td>實際: </td>{2}</tr></table></body></html>

# ## org/jetbrains/plugins/scala/annotator/quickfix/AddBreakoutQuickFix.scala
add.collection.breakout.argument=添加 `collection.breakOut` 實參
family.name.add.collection.breakout=添加 `collection.breakOut`

# ## org/jetbrains/plugins/scala/annotator/quickfix/AddElementToMethodCallFix.scala
add.element=添加 {0}

# ## org/jetbrains/plugins/scala/annotator/quickfix/AddReturnTypeFix.scala
add.return.type=添加返回類型

# ## org/jetbrains/plugins/scala/annotator/quickfix/ChangeTypeFix.scala
family.name.change.type=更改類型
change.type.to=將 ''{0}'' 類型更改為 ''{1}''

# ## org/jetbrains/plugins/scala/annotator/quickfix/ConvertToExplicitSymbolQuickFix.scala
convert.to.explicit.symbol=轉換為符號("{0}")
convert.to.explicit.symbol.family=轉換為顯式符號

# ## org/jetbrains/plugins/scala/annotator/quickfix/EnableTypeMismatchHints.scala
family.name.enable.type.mismatch.hints=啟用類型不符合提示

# ## org/jetbrains/plugins/scala/annotator/quickfix/ImplementMembersQuickFix.scala
implement.members.fix=實作成員

# ## org/jetbrains/plugins/scala/annotator/quickfix/ModifierQuickFix.scala
make.non.private.title=將屬性設為非私有屬性
add.modifier.fix.without.name=添加 ''{0}'' 修飾符
remove.named.modifier.fix=移除 ''{0}'' 修飾符
make.protected.fix=將屬性設為 protected
make.public.fix=將屬性設為公共屬性

# ## org/jetbrains/plugins/scala/annotator/quickfix/NumberLiteralQuickFix.scala
numeric.literal.family=數字文字
convert.to.hex.fix=將八進制文字轉換為十六進制
convert.to.long.fix=轉換為 long 文字
lowercase.long.marker.fix=將 long 文字標記轉換為大寫

# ## org/jetbrains/plugins/scala/annotator/quickfix/PullUpQuickFix.scala
pull.method.to=將方法 ''{0}'' 拉取到…
pull.value.to=將值 ''{0}'' 拉取到…
pull.variable.to=將變數 ''{0}'' 拉取到…

# ## org/jetbrains/plugins/scala/annotator/quickfix/ReportHighlightingErrorQuickFix.scala
report.highlighting.error.fix=報告高亮顯示錯誤…

# ## org/jetbrains/plugins/scala/annotator/quickfix/WrapInOptionQuickFix.scala
wrap.in.option.name=使用 Option 環繞
wrap.in.option.hint=使用 Option(...) 環繞表達式?

# ## org/jetbrains/plugins/scala/annotator/template/CaseClassWithoutParamList.scala
family.name.add.empty.parentheses=添加空圓括號
family.name.convert.to.object=轉換為物件
case.classes.without.parameter.list.not.allowed=不允許使用沒有參數列表的 case 類
case.classes.without.parameter.list.deprecated=已棄用沒有參數列表的 case 類

# ## org/jetbrains/plugins/scala/annotator/template/ImplicitParametersAnnotator.scala
no.implicit.arguments.of.type=無類型的隱式參數: {0}

# ## org/jetbrains/plugins/scala/annotator/template/PrivateBeanProperty.scala
annotator.error.bean.property.should.not.be.private=Bean 屬性不應為私有

# ## org/jetbrains/plugins/scala/annotator/template/TraitHasImplicitBound.scala
traits.cannot.have.type.parameters.with.context.bounds=特徵不能具有包含上下文邊界的類型參數
traits.cannot.have.type.parameters.with.view.bounds=特徵不能具有包含檢視邊界的類型參數

# ## org/jetbrains/plugins/scala/autoImport/quickFix/ImportExtensionMethodFix.scala
import.extension.method=匯入擴展方法...

# ## org/jetbrains/plugins/scala/autoImport/quickFix/ImportImplicitConversionFix.scala
import.with=匯入 ''{0}''
import.implicit.conversion=匯入轉換…

# ## org/jetbrains/plugins/scala/autoImport/quickFix/ImportImplicitInstanceFix.scala
import.implicit=匯入隱式…

# ## org/jetbrains/plugins/scala/autoImport/quickFix/ScalaAddImportAction.scala
import.class.chooser.title=要匯入的類
import.package.chooser.title=要匯入的軟體套件
import.something.chooser.title=要匯入的名稱
import.conversion.chooser.title=要匯入的轉換
import.implicit.chooser.title=要匯入的隱式定義
import.extension.method.chooser.title=要匯入的擴展方法
add.import.action=添加匯入操作
exclude.value.from.auto.import=從自動匯入中排除 ''{0}''

# ## org/jetbrains/plugins/scala/autoImport/quickFix/ScalaImportElementFix.scala
import.hint.text={0}? {1} Alt+Enter
import.multiple.choices=(多重選擇…)

# ## org/jetbrains/plugins/scala/autoImport/quickFix/ScalaImportGlobalMemberFix.scala
import.global.member=匯入全域成員
import.as=作為 ''{0}'' 匯入
import.with.prefix.ellipsis=通過前綴匯入…
import.with.prefix=通過前綴匯入
import.something=匯入…

# ## org/jetbrains/plugins/scala/autoImport/quickFix/ScalaImportTypeFix.scala
import.class=匯入類
import.package=匯入軟體套件

# ## org/jetbrains/plugins/scala/build/BuildToolWindowReporter.scala
report.build.toolwindow.cancel=取消建置
report.build.toolwindow.running=正在執行…
report.build.toolwindow.failed=已失敗
report.build.toolwindow.canceled=已取消
report.build.toolwindow.items=條目

# ## org/jetbrains/plugins/scala/build/ExternalSystemNotificationReporter.scala
report.build.task.canceled=任務已取消

# ## org/jetbrains/plugins/scala/build/IndicatorReporter.scala
report.build.running=建置正在執行…
report.build.completed=建置已完成
report.build.failed=建置失敗
report.failed.with.message=失敗: {0}
report.canceled=已取消
report.warning.with.message=警告: {0}
report.error.with.message=錯誤: {0}
report.building=正在建置…

# ## org/jetbrains/plugins/scala/codeInsight/intention/AddBracesIntention.scala
family.name.add.braces=添加大括號
add.braces.around.single.line.expression=在單行表達式周圍添加大括號

# ## org/jetbrains/plugins/scala/codeInsight/intention/CreateCompanionObjectIntention.scala
create.companion.object.for.class=為類創建伴生物件
family.name.create.companion.object=創建伴生物件

# ## org/jetbrains/plugins/scala/codeInsight/intention/RemoveBracesIntention.scala
family.name.remove.braces=移除大括號

# ## org/jetbrains/plugins/scala/codeInsight/intention/collections/ComparingLengthIntention.scala
family.name.comparing.length=取代為 .sizeIs

# ## org/jetbrains/plugins/scala/codeInsight/intention/collections/FilterSetContainsIntention.scala
family.name.filter.set.contains=移除篩選器中的冗餘 ''contains''

# ## org/jetbrains/plugins/scala/codeInsight/intention/collections/SomeToOptionIntention.scala
family.name.some.to.option=Some 轉換為 Option

# ## org/jetbrains/plugins/scala/codeInsight/intention/comprehension/ConvertToCurlyBracesIntention.scala
family.name.convert.to.curly.braces=轉換為大括號

# ## org/jetbrains/plugins/scala/codeInsight/intention/comprehension/ConvertToParenthesesIntention.scala
intention.for.comprehension.convert.to.parentheses=轉換為圓括號

# ## org/jetbrains/plugins/scala/codeInsight/intention/comprehension/DesugarForIntention.scala
desugar.for.comprehension=for 推導脫糖
family.name.convert.to.desugared.expression=轉換為脫糖表達式

# ## org/jetbrains/plugins/scala/codeInsight/intention/expression/ConvertFromInfixExpressionIntention.scala
family.name.convert.from.infix.expression=從中綴表達式轉換

# ## org/jetbrains/plugins/scala/codeInsight/intention/expression/ConvertParameterToUnderscoreIntention.scala
family.name.convert.parameter.to.underscore.section=將參數轉換為下劃線部分

# ## org/jetbrains/plugins/scala/codeInsight/intention/expression/ConvertToInfixExpressionIntention.scala
family.name.convert.to.infix.expression=轉換為中綴表達式

# ## org/jetbrains/plugins/scala/codeInsight/intention/expression/ConvertUnderscoreToParameterIntention.scala
family.name.convert.underscore.section.to.parameter=將下劃線部分轉換為參數

# ## org/jetbrains/plugins/scala/codeInsight/intention/expression/MakeImplicitConversionExplicit.scala
family.name.make.implicit.conversion.explicit=將隱式轉換設為顯式

# ## org/jetbrains/plugins/scala/codeInsight/intention/expression/RemoveApplyIntention.scala
family.name.remove.unnecessary.apply=移除不必要的 apply

# ## org/jetbrains/plugins/scala/codeInsight/intention/expression/RemoveUnnecessaryParenthesesIntention.scala
remove.unnecessary.parentheses=移除不必要的圓括號

# ## org/jetbrains/plugins/scala/codeInsight/intention/expression/ReplaceTypeCheckWithMatchIntention.scala
family.name.replace.type.check.with.pattern.matching=將類型檢查取代為模式符合

# ## org/jetbrains/plugins/scala/codeInsight/intention/imports/ImportAdditionalIdentifiersIntention.scala
family.name.import.additional.identifiers=匯入附加關鍵字
import.additional.identifiers.from.qualifier=從限定符匯入其他關鍵字

# ## org/jetbrains/plugins/scala/codeInsight/intention/imports/ImportAllMembersIntention.scala
family.name.import.all.members=匯入所有成員
import.all.members.of.reference=匯入 {0} 的所有成員

# ## org/jetbrains/plugins/scala/codeInsight/intention/imports/ImportStableMemberIntention.scala
family.name.import.member.with.stable.path=通過穩定路徑匯入成員
import.stable.member=匯入 {0}

# ## org/jetbrains/plugins/scala/codeInsight/intention/lists/ScalaListSplitJoinContexts.scala
intention.family.put.arguments.on.one.line=將實參放在同一行中
intention.family.put.arguments.on.separate.lines=將實參放在單獨的行中
intention.family.put.parameters.on.one.line=將參數放在同一行中
intention.family.put.parameters.on.separate.lines=將參數放在單獨的行中

# ## org/jetbrains/plugins/scala/codeInsight/intention/matcher/ConvertToTypedPatternIntention.scala
convert.to.typed.pattern=轉換為類型化模式

# ## org/jetbrains/plugins/scala/codeInsight/intention/matcher/ExpandPatternIntention.scala
family.name.expand.to.constructor.pattern=擴展到構造函數模式
expand.to.new.pattern=擴展到: {0}

# ## org/jetbrains/plugins/scala/codeInsight/intention/types/AddUnitTypeAnnotationIntention.scala
intention.add.explicit.unit.type.annotation=添加顯式 Unit 類型註解
intention.type.annotation.function.add.text=將類型註解添加到函數定義

# ## org/jetbrains/plugins/scala/codeInsight/intention/types/AdjustTypesIntention.scala
family.name.adjust.types=調整類型

# ## org/jetbrains/plugins/scala/codeInsight/intention/types/ConvertFromInfixIntention.scala
family.name.use.prefix.type.syntax=使用前綴類型語法

# ## org/jetbrains/plugins/scala/codeInsight/intention/types/ConvertImplicitBoundsToImplicitParameter.scala
family.name.convert.implicit.bounds=轉換隱式綁定
convert.view.and.context.bounds.to.implicit.parameters=將上下文邊界轉換為隱式參數

# ## org/jetbrains/plugins/scala/codeInsight/intention/types/ConvertJavaToScalaCollectionIntention.scala
convert.java.to.scala.collection.hint=使用 asScala 轉換為 Scala 集合?
convert.java.to.scala.collection.name=轉換為 Scala 集合

# ## org/jetbrains/plugins/scala/codeInsight/intention/types/ConvertScalaToJavaCollectionIntention.scala
convert.scala.to.java.collection.hint=使用 asJava 轉換為 Java 集合?
convert.scala.to.java.collection.name=轉換為 Java 集合

# ## org/jetbrains/plugins/scala/codeInsight/intention/types/ConvertToInfixIntention.scala
family.name.use.infix.type.syntax=使用中綴類型語法

# ## org/jetbrains/plugins/scala/codeInsight/intention/types/MakeTypeMoreSpecificIntention.scala
make.type.more.specific.fun=使返回類型更具體
make.type.more.specific=使宣告類型更具體

# ## org/jetbrains/plugins/scala/codeInsight/intention/types/RegenerateTypeAnnotation.scala
intention.type.annotation.regen.family=重新生成類型註解
intention.type.annotation.function.regenerate.text=重新生成函數定義的類型註解
intention.type.annotation.value.regenerate.text=重新生成值定義的類型註解
intention.type.annotation.variable.regenerate.text=重新生成變數定義的類型註解

# ## org/jetbrains/plugins/scala/codeInsight/intention/types/ToggleTypeAnnotation.scala
intention.type.annotation.toggle.family=切換類型註解
intention.type.annotation.function.remove.text=從函數定義中移除類型註解
intention.type.annotation.value.add.text=將類型註解添加到值定義
intention.type.annotation.value.remove.text=從值定義中移除類型註解
intention.type.annotation.variable.add.text=將類型註解添加到變數定義
intention.type.annotation.variable.remove.text=從變數定義中移除類型註解
intention.type.annotation.pattern.add.text=將類型註解添加到模式定義
intention.type.annotation.pattern.remove.text=從模式定義中移除類型註解
intention.type.annotation.parameter.add.text=將類型註解添加到參數
intention.type.annotation.parameter.remove.text=從參數中移除類型註解
intention.type.annotation.underscore.add.text=將類型註解添加到下劃線參數
intention.type.annotation.underscore.remove.text=從下劃線參數中移除類型註解

# ## org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaCaseClauseRemover.scala
remove.case.clause=移除 case 子句

# ## org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaCatchOrFinallyRemover.scala
remove.finally=移除 finally 塊
remove.catch=移除 catch 塊

# ## org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaInterpolatedStringUnwrapper.scala
unwrap.interpolated.string.injection=解開插值字串注入

# ## org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaMatchUnwrapper.scala
unwrap.case.clause=解開 case 子句

# ## org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaTryOrFinallyUnwrapper.scala
unwrap.finally=解開 finally

# ## org/jetbrains/plugins/scala/codeInsight/unwrap/ScalaTryWithFinallyUnwrapper.scala
unwrap.try.with.finally=解開 try / finally

# ## org/jetbrains/plugins/scala/codeInspection/caseClassParamInspection/CaseClassParamInspection.scala
val.on.case.class.param.redundant=對於 case 類主構造函數的參數而言，''val'' 修飾符冗餘

# ## org/jetbrains/plugins/scala/codeInspection/caseClassParamInspection/RemoveValQuickFix.scala
remove.val=移除 ''val''

# ## org/jetbrains/plugins/scala/codeInspection/catchAll/ReplaceDangerousCatchAllQuickFix.scala
specify.type.of.exception=指定異常類型

# ## org/jetbrains/plugins/scala/codeInspection/forwardReferenceInspection/ForwardReferenceInspection.scala
suspicious.forward.reference.template.body=類中的可疑前向引用

# ## org/jetbrains/plugins/scala/codeInspection/imports/SingleImportInspection.scala
remove.braces.from.import=移除 import 語句中的大括號

# ## org/jetbrains/plugins/scala/codeInspection/quickfix/RemoveReturnKeywordQuickFix.scala
remove.return.keyword=移除 return 關鍵字

# ## org/jetbrains/plugins/scala/codeInspection/relativeImports/RelativeImportInspection.scala
make.import.fully.qualified=將 import 設為完全限定

# ## org/jetbrains/plugins/scala/codeInspection/scaladoc/ScalaDocInlinedTagInspection.scala
delete.inlined.tag=刪除內聯標記
replace.with.wiki.syntax=將內聯標記取代為等寬的 wiki 語法

# ## org/jetbrains/plugins/scala/codeInspection/scaladoc/ScalaDocUnbalancedHeaderInspection.scala
move.text.after.header.to.new.line=將文本移動到靠近新行的標頭後面
balance.header=平衡標頭

# ## org/jetbrains/plugins/scala/codeInspection/scaladoc/ScalaDocUnclosedTagWithoutParserInspection.scala
replace.tag.with.esc.seq=將標記取代為轉義序列

# ## org/jetbrains/plugins/scala/codeInspection/scaladoc/ScalaDocUnknownParameterInspection.scala
delete.duplicating.param=刪除重複參數
delete.tag=刪除標記

# ## org/jetbrains/plugins/scala/codeInspection/scaladoc/ScalaDocUnknownTagInspection.scala
delete.unknown.tag=刪除未知標記

# ## org/jetbrains/plugins/scala/codeInspection/syntacticSimplification/FunctionTupleSyntacticSugarInspection.scala
replace.tuple.type=將 TupleN[A1, A1, ...,  AN] 取代為 (A1, A1, ...,  AN)
replace.fun.type=將 FunctionN[A1, A1, ...,  AN, R] 取代為 (A1, A1, ...,  AN) => R

# ## org/jetbrains/plugins/scala/codeInspection/syntacticSimplification/RedundantNewCaseClassInspection.scala
new.on.case.class.instantiation.redundant=移除 ''new'' 修飾符

# ## org/jetbrains/plugins/scala/codeInspection/xml/ScalaXmlUnmatchedTagInspection.scala
xml.no.opening.tag=無起始標記
xml.no.closing.tag=無結束標記
xml.delete.unmatched.tag=刪除不符合的標記
xml.rename.opening.tag=重命名起始標記
xml.rename.closing.tag=重命名結束標記

# ## org/jetbrains/plugins/scala/compilationCharts/ui/ActionPanel.scala
compilation.charts.reset.zoom.action.text=重置垂直縮放
compilation.charts.reset.zoom.action.description=重置編譯圖表的垂直縮放
compilation.charts.zoom.out.action.text=垂直縮小
compilation.charts.zoom.out.action.description=編譯圖表垂直縮小
compilation.charts.zoom.in.action.text=垂直放大
compilation.charts.zoom.in.action.description=編譯圖表垂直放大

# ## org/jetbrains/plugins/scala/compilationCharts/ui/CompilationChartsBuildToolWindowNodeFactory.scala
compilation.charts.title=圖表

# ## org/jetbrains/plugins/scala/compiler/CompileServerLauncher.scala
cannot.start.scala.compile.server=無法啟動 Scala 編譯伺服器
required.file.not.found.paths=找不到所需的檔案: {0}
can.t.find.default.jdk=找不到預設 jdk
cant.find.jdk=找不到 jdk: {0}
compile.server.terminated.unexpectedly.0.port.1.pid=編譯伺服器意外終止<br>(連接埠: {0}，pid: {1})

# ## org/jetbrains/plugins/scala/compiler/CompileServerManager.scala
scala.compile.server.title=Scala 編譯伺服器
action.run=執行(&R)
start.compile.server=啟動編譯伺服器
action.stop=停止(&S)
shutdown.compile.server=關閉編譯伺服器
action.configure=設定(&C)…
configure.compile.server=設定編譯伺服器
compile.server.stopped.due.to.inactivity=編譯伺服器因處於停用狀態而停止

# ## org/jetbrains/plugins/scala/compiler/CompileServerNotificationsService.scala
wrong.jdk.action.use.jdk=使用 JDK {0}

# ## org/jetbrains/plugins/scala/compiler/EnsureModulesHaveDifferentProdAndTestOutputsTask.scala
shared.compile.output.paths.in.scala.modules=Scala 模組中的共享編譯輸出路徑
production.and.test.output.paths.are.shared.in=生產和測試輸出路徑在以下位置共享: {0}
split.output.paths.automatically=自動拆分輸出路徑
cancel.compilation=取消編譯

# ## org/jetbrains/plugins/scala/compiler/ScalaCompileServerForm.form
# ScalaCompileServer UI
jvm.options=VM 選項(&O):
jvm.maximum.heap.size.mb=最大堆大小(MB)(&H):
jdk=JDK(&J):
minutes=分鐘
compile.server.jvm.command.line.parameters=編譯伺服器 JVM 命令行參數
compile.server.shutdown.if.idle.for=閑置以下時間時停止:
compile.server.use.for.scala=使用編譯伺服器
compile.server.parallelism=執行緒
compile.server.parallel.compilation=並行編譯獨立模組，最多

# ## org/jetbrains/plugins/scala/compiler/ScalaCompileServerForm.java
compile.server.new.project.restart=要更改行程工作目錄，必須在每次更改專案時重啟伺服器。
compile.server.use.project.home=在專案目錄中啟動行程(&P)
compile.server.description=JDK 用於實例化編譯伺服器並調用\n行程內 Java 編譯器(當 JDK 和模組 SDK 匹配時)。

# ## org/jetbrains/plugins/scala/compiler/package.scala
wrong.jdk.action.open.compile.server.settings=開啟編譯伺服器設定
unexpected.sdk.type.for.sdk=意外 sdk 類型: sdk {1} 的 ''{0}''

# ## org/jetbrains/plugins/scala/components/PluginVersionVerifier.scala
incompatible.plugin.detected=檢測到不相容的延伸模組

# ## org/jetbrains/plugins/scala/components/Scala3Disclaimer.scala
scala.3.support.is.experimental=Scala 3 支援正在積極開發中。<br>請使用 Nightly 版本來獲取新的改進。
configure.updates=設定更新…

# ## org/jetbrains/plugins/scala/components/ScalaPluginUpdater.scala
idea.is.outdated.please.update=您的 IDEA 已過時，無法對 Scala 延伸模組 {0} 分支使用。<br/>請至少將 IDEA 更新到 {1}，以使用最新的 Scala 延伸模組。
please.select.scala.plugin.update.channel=請選擇 Scala 延伸模組更新通道:
channel.stable.releases=穩定版本
channel.early.access.program=搶先體驗計劃
channel.nightly.builds=Nightly 版本

# ## org/jetbrains/plugins/scala/components/TypeAwareWidgetFactory.scala
scala.type.aware.highlighting.indicator=Scala 類型感知高亮顯示指示器
type.aware.highlighting.title=Scala 類型感知高亮顯示
click.or.press.shortcut.to.change=(點擊或按 {0} 進行更改)
click.to.change=(點擊以更改)
enabled.word=已啟用
disabled.word=已禁用

# ## org/jetbrains/plugins/scala/components/libextensions/ExtensionDownloader.scala
downloading.url=正在下載 {0}

# ## org/jetbrains/plugins/scala/components/libextensions/LibraryExtensionsManager.scala
title.searching.for.library.extensions=正在搜尋庫表達式

# ## org/jetbrains/plugins/scala/components/libextensions/ui/LibExtensionsSettingsPanelWrapper.scala
select.library.from.the.list.above=從以上列表中選擇庫
idea.will.try.to.search.for.extra.support.for.particular.libraries=IDEA 將嘗試搜尋對您專案中特定庫的額外支援
title.failed.to.load.extension.jar=無法載入擴展 JAR
no.known.extension.libraries=無已知的擴展庫
known.extension.libraries=已知擴展庫
extensions.in.selected.library=所選庫中的擴展
enable.loading.external.extensions=啟用載入外部擴展
how.to.add.custom.macro.support.help.link.title=如何添加自訂 Scala 巨集支援

# ## org/jetbrains/plugins/scala/components/libextensions/ui/PopupHelper.scala
title.extensions.available=可用的擴展
additional.support.has.been.found.popup=<p>已為您的某些庫找到了其他支援。</p><p>要啟用該支援嗎? <a href="Yes">是</a> / <a href="No">否</a></p>

# ## org/jetbrains/plugins/scala/console/ScalaLanguageConsole.scala
scala.language.console.placeholder.command.to.execute=要執行的 <{0}>

# ## org/jetbrains/plugins/scala/console/actions/RunConsoleAction.scala
scala.console.actions.scala.repl=Scala REPL
scalarepl.menu.action.text=Scala REPL…
scalarepl.menu.action.description=執行 Scala REPL

# ## org/jetbrains/plugins/scala/console/actions/ScalaConsoleCleanAction.scala
clean.scala.repl.content.menu.action.text=清除 Scala REPL 內容
clean.scala.repl.content.menu.action.description=清除 Scala REPL 內容

# ## org/jetbrains/plugins/scala/console/actions/ScalaConsoleExecuteAction.scala
execute.scala.repl.statement.menu.action.text=執行 Scala REPL 語句
execute.scala.repl.statement.menu.action.description=執行 Scala REPL 語句

# ## org/jetbrains/plugins/scala/console/actions/ScalaConsoleNewLineAction.scala
scalaconsole.new.line.in.repl=REPL 中出現新行

# ## org/jetbrains/plugins/scala/console/actions/SendSelectionToConsoleAction.scala
send.selection.to.scala.repl.menu.action.text=將選區发送到 Scala REPL
send.selection.to.scala.repl.menu.action.description=將選區发送到 Scala REPL

# ## org/jetbrains/plugins/scala/console/configuration/ScalaConsoleConfigurationType.scala
scala.console.config.display.name=Scala REPL
scala.console.config.scala.repl.run.configurations=Scala REPL 執行設定

# ## org/jetbrains/plugins/scala/console/configuration/ScalaConsoleRunConfiguration.scala
scala.console.config.module.is.not.specified=未指定模組

# ## org/jetbrains/plugins/scala/console/configuration/ScalaConsoleRunConfigurationForm.form
scala.console.config.working.directory=工作目錄:
scala.console.config.use.classpath.and.sdk.of.module=使用模組的類路徑和 SDK:

# ## org/jetbrains/plugins/scala/console/configuration/ScalaConsoleRunConfigurationForm.java
scala.console.config.vm.options=VM 選項
scala.console.config.console.arguments=控制台實參
scala.console.config.test.run.config.choose.working.directory=選擇工作目錄

# ## org/jetbrains/plugins/scala/console/configuration/ScalaSdkJLineFixer.scala
scala.console.configure.scala.sdk.classpath=設定 Scala SDK 類路徑(&C)
# parameters:
# 0 - subsystem name (e.g. Console)
# 1 - jline jar name
subsystem.requires.jline={0} 需要 {1}\n請將它添加到編譯器類路徑中

# ## org/jetbrains/plugins/scala/debugger/ScalaFrameExtraVariablesProvider.scala
debug.process.is.detached=偵錯行程已分離。

# ## org/jetbrains/plugins/scala/debugger/breakpoints/ScalaLineBreakpointType.scala
line.breakpoints.tab.title=Scala 行中斷點
breakpoint.location.constructor.of={0} 的構造函數
breakpoint.location.early.definitions.of={0} 的早期定義
breakpoint.location.line.in.containing.block=包含塊中的行
breakpoint.location.line.in.function=函數 {0} 中的行
breakpoint.location.line.in.containing.file=包含檔案中的行

# ## org/jetbrains/plugins/scala/debugger/evaluation/ScalaEvaluatorBuilder.scala
evaluation.of.object.needs.compilation=評估物件需要編譯
evaluation.of.class.needs.compilation=評估類需要編譯
evaluation.of.trait.needs.compilation=評估特徵需要編譯
evaluation.of.anonymous.class.needs.compilation=評估匿名類需要編譯
evaluation.of.type.alias.needs.compilation=評估類型別名需要編譯
evaluation.of.function.definition.needs.compilation=評估函數定義需要編譯
evaluation.of.variable.declaration.needs.compilation=評估變數宣告需要編譯
evaluation.of.lazy.val.definition.needs.compilation=評估 lazy val 定義需要編譯
evaluation.of.anonymous.function.needs.compilation=評估匿名函數需要編譯
evaluation.of.for.expression.needs.compilation=評估 for 表達式需要編譯
evaluation.of.try.statement.needs.compilation=評估 try 語句需要編譯
evaluation.of.return.statement.needs.compilation=評估 return 語句需要編譯
evaluation.of.match.statement.needs.compilation=評估 match 語句需要編譯
evaluation.of.throw.statement.needs.compilation=評估 throw 語句需要編譯
evaluation.of.xml.expression.needs.compilation=評估 xml 表達式需要編譯
evaluation.of.interpolated.string.needs.compilation=評估插值字串需要編譯
cannot.find.by.name.parameter.with.such.name=找不到具有此名稱的傳名參數: {0}
evaluation.of.expression.is.not.supported=不支持表達式評估: {0}
evaluation.of.element.is.not.supported=不支持元素評估: {0}

# ## org/jetbrains/plugins/scala/debugger/evaluation/ScalaEvaluatorBuilderUtil.scala
cannot.evaluate.imported.reference=無法評估匯入的引用
cannot.evaluate.local.method=無法評估局部方法
cannot.evaluate.parameter=無法評估參數 {0}
cannot.evaluate.method=無法評估方法 {0}
cannot.evaluate.local.object=無法評估局部物件 {0}
cannot.evaluate.local.variable=無法評估局部變數 {0}
wrong.number.of.arguments=方法 {0} 的實參數量錯誤
array.instance.is.not.found=無法評估方法 {0}: 找不到陣列實例
array.method.not.supported=不支持陣列方法
cannot.find.implicit.parameters=找不到要傳遞的隱式參數
implicit.parameters.from.dependent.objects=依賴物件中的隱式參數不受支援
implicit.conversions.from.dependent.objects=依賴物件中的隱式轉換不受支援
method.with.by-name.parameters=無評估法包含傳名參數的方法
wrong.number.of.expressions=無法評估實參: 符合的表達式的數量錯誤
tupling.not.supported=不支持元組化。請使用元組表達式。
not.used.from.for.statement=無法評估 for 語句中的變數 {0}，因為它沒有在主體中使用
cannot.find.pattern=找不到 case 子句的模式
cannot.find.expression.of.match=找不到 match 語句的表達式
invalid.case.clause=無效的 case 子句
assignent.without.expression=無法評估沒有表達式的賦值語句
unapply.without.arguments=無法從沒有實參的 unapply 提取值
pattern.doesnot.resolves.to.unapply=模式引用 {0} 不會解析為 unapply 或 unapplySeq
pattern.alternatives.cannot.bind.vars=模式替代項不能綁定變數
xml.patterns.not.supported=不支持 xml 模式
kind.of.pattern.not.supported=不支持此類模式: {0}
anon.classes.not.supported=不支持匿名類
new.expression.without.class.reference=無法評估沒有類引用的新表達式
new.expression.without.constructor.call=無法評估沒有構造函數調用的表達式
new.expression.without.template.parents=無法評估沒有模板父項的表達式
could.not.resolve.constructor=無法解析構造函數
if.statement.without.condition=無法評估沒有條件的 if 語句
if.statement.without.if.branch=無法評估沒有 if 分支的 if 語句
while.statement.without.condition=無法評估沒有條件的 while 語句
while.statement.without.body=無法評估沒有主體的 while 語句
do.statement.without.condition=無法評估沒有條件的 do 語句
do.statement.without.body=無法評估沒有主體的 do 語句
method.call.implicitly.converted.qualifier=無法評估包含隱式轉換限定符的方法調用: {0}
synchronized.statement.is.not.supported=不支持同步語句
cannot.evaluate.synthetic.method=無法評估合成方法: {0}
by.name.parameter.expected=應為傳名參數
update.method.is.not.supported=不支持更新方法
variable.definition.needs.right.hand.side=變數定義需要在右側: {0}
value.definition.needs.right.hand.side=值定義需要在右側: {0}
new.synthetic.instantiation={0} ''{1}'' 為 abstract；無法實例化
missing.type.argument.synthetic.method=在沒有顯式類型實參的情況下調用了 {0}
constructor.param.inaccessible.outside.of.constructor=在類構造函數外部無法存取構造函數參數 ''{0}''
array.constructor.unspecified.parameters=未指定的值參數: _length: Int
array.constructor.too.many.arguments=構造函數陣列(Int)的實參過多

# ## org/jetbrains/plugins/scala/debugger/evaluation/ScalaEvaluatorCompileHelper.scala
could.not.compile=無法編譯:\n{0}
compilation.failed=編譯失敗

# ## org/jetbrains/plugins/scala/debugger/evaluation/evaluator/AsInstanceOfEvaluator.scala
error.cannot.cast.value.to.type=無法將類型 ''{0}'' 的值轉換為類型 ''{1}''

# ## org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ClassOfEvaluator.scala
error.literal.type.is.not.class.type=文字類型 ({0} : {1}) 不是類類型

# ## org/jetbrains/plugins/scala/debugger/evaluation/evaluator/IsInstanceOfEvaluator.scala
error.type.cannot.be.used.in.isinstanceof={0} {1} 不能在執行時類型測試中使用
error.value.isinstanceof.reference=無法測試類型 {0} 的值是否為類型 {1} 的引用
error.isinstanceof.structural.type=未選中結構類型的執行時類型測試

# ## org/jetbrains/plugins/scala/debugger/evaluation/evaluator/NewValueClassInstanceEvaluator.scala
error.cannot.resolve.value.class.primary.constructor=無法解析值類 {0} 的主構造函數

# ## org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaBoxingEvaluator.scala
cannot.perform.boxing.conversion.for.result=無法為 {0} 執行裝箱轉換

# ## org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaCompilingEvaluator.scala
could.not.compile.generated.class=無法編譯生成的類
error.during.generated.code.invocation=生成程式碼調用時出錯:\n{0}
error.creating.evaluation.class.loader=創建評估類載入器時出錯:\n{0}
error.during.classes.definition=類定義時出錯:\n{0}

# ## org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaLiteralEvaluator.scala
unknown.type.of.literal=未知的文字類型
literal.has.null.value=文字 {0} 有 null 值

# ## org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaMethodEvaluator.scala
could.not.find.appropriate.constructor.for.name=找不到 {0} 的適用構造函數
cannot.invoke.abstract.interface.method.name=無法調用抽象接口方法 {0}
method.methodname.cannot.be.invoked.on.array=無法在陣列上調用方法 {0}

# ## org/jetbrains/plugins/scala/debugger/evaluation/evaluator/ScalaThisEvaluator.scala
outer.this.not.available=外部 `this` 不可用

# ## org/jetbrains/plugins/scala/debugger/evaluation/evaluator/compiling/GeneratedClass.scala
module.for.compilation.is.not.found=找不到編譯模組
could.not.evaluate.due.to.a.change.in.a.source.file=由於源文件中的變更而無法評估
could.not.compile.local.class.in.this.context=無法在此上下文中編譯本地類

# ## org/jetbrains/plugins/scala/debugger/filters/ScalaDebuggerSettingsConfigurable.form
friendly.collection.display.enabled=在偵錯器中友好地顯示 Scala 集合
dont.show.runtime.refs=不在偵錯器中顯示執行時引用
show.variables.from.outer.scopes.in.variables.view=在變數檢視中顯示外部範圍中的變數

# ## org/jetbrains/plugins/scala/debugger/filters/ScalaDebuggerSettingsConfigurable.java
scala.debug.caption=Scala

# ## org/jetbrains/plugins/scala/debugger/filters/ScalaSteppingConfigurable.form
scala.debug.disable.specific.methods=不單步執行具體的 Scala 類(&I)

# ## org/jetbrains/plugins/scala/debugger/ui/ScalaClassRenderer.scala
scala.class.renderer=Scala 物件

# ## org/jetbrains/plugins/scala/debugger/ui/ScalaCollectionRenderer.scala
scala.collection.renderer=Scala 集合

# ## org/jetbrains/plugins/scala/debugger/ui/ScalaRuntimeRefRenderer.scala
scala.runtime.ref.renderer=Scala 執行時引用

# ## org/jetbrains/plugins/scala/debugger/ui/descriptors.scala
could.not.find.bitmap.field=找不到位圖欄位 {0}
could.not.find.accessor.method=找不到欄位 {0} 的存取器方法
initialize.lazy.val=初始化
lazy.val.not.initialized=<not initialized>
collection.element.descriptors.evaluation.not.supported="不支持集合元素描述符的評估"

# ## org/jetbrains/plugins/scala/editor/autoimport/ScalaAutoImportOptionsProvider.scala
options.scala.display.name=Scala
auto.import.show.import.popup.for=為下列物件顯示匯入彈出視窗:
auto.import.add.unambiguous.imports.on.the.fly.for=動態添加明確的 import:
auto.import.optimize.imports.on.the.fly=動態最佳化 import
auto.import.show.popup.classes=類
auto.import.show.popup.methods=static 成員
auto.import.show.popup.conversions=隱式轉換
auto.import.show.popup.implicits=隱式定義
auto.import.show.popup.extension.methods=擴展方法
auto.import.find.more.configuration.options=在<a>程式碼樣式</a>中尋找更多設定選項

# ## org/jetbrains/plugins/scala/externalHighlighters/CompilerEventGeneratingClient.scala
highlighting.compilation.progress=高亮顯示: {0}

# ## org/jetbrains/plugins/scala/externalHighlighters/CompilerHighlightingService.scala
highlighting.compilation=錯誤/警告高亮顯示

# ## org/jetbrains/plugins/scala/externalHighlighters/ToggleCompilerHighlightingAction.scala
scala.project.settings.form.compiler.highlighting.scala2=在 Scala 中使用編譯器高亮顯示錯誤
scala.project.settings.form.compiler.highlighting.scala3=在 Scala 3 中使用編譯器高亮顯示錯誤
scala.project.settings.form.compiler.highlighting.tooltip=不使用內建的高亮顯示工具，而是直接使用來自編譯器的錯誤訊息。這樣可以更精準地高亮顯示錯誤，但可能顯示得更慢，並且可能無法進行檢查和快速修復。

# ## org/jetbrains/plugins/scala/findUsages/compilerReferences/ScalaCompilerReferenceService.scala
open.compiler.index.reader=開啟編譯器索引讀取器
index.invalidation.callback=索引作廢回調

# ## org/jetbrains/plugins/scala/findUsages/compilerReferences/SearchTargetExtractors.scala
bytecode.indices.target.sam.type=SAM 類型
bytecode.indices.target.unapply.method=apply/unapply 方法
bytecode.indices.target.for.comprehension.method=for-comprehension 方法
bytecode.indices.target.implicit.definition=隱式定義

# ## org/jetbrains/plugins/scala/findUsages/compilerReferences/compilation/JpsCompilationWatcher.scala
malformed.message.from.builder=建置器中的 messageText 格式錯誤: {0}

# ## org/jetbrains/plugins/scala/findUsages/compilerReferences/compilation/SbtCompilationWatcher.scala
failed.to.parse.offline.compilation.analysis.files=無法解析脫機編譯分析檔案。
sbt.module.added=sbt 模組已添加。
sbt.connection.failure=sbt 編譯管理工具: 連接失敗。
failed.to.parse.compilation.info.file=無法解析編譯資訊檔案 {0}
error.while.reading.sbt.compilation.info=嘗試讀取 sbt 編譯資訊檔案時出錯。

# ## org/jetbrains/plugins/scala/findUsages/compilerReferences/indices/CompilerReferenceIndexer.scala
bytecode.indices.indexing=正在為類檔案編制索引…
title.initializing.compiler.indices.writer=正在初始化編譯器索引編寫器
title.closing.compiler.indices.writer=正在關閉編譯器索引編寫器
title.invalidating.compiler.indices=正在作廢編譯器索引

# ## org/jetbrains/plugins/scala/findUsages/compilerReferences/indices/CompilerReferenceIndexerScheduler.scala
bytecode.indices.progress.title=正在索引重新編譯的類檔案…

# ## org/jetbrains/plugins/scala/findUsages/compilerReferences/search/CompilerIndicesReferencesSearcher.scala
bytecode.indices.unavailable=在編譯期間不可通過字節碼索引尋找用法。
bytecode.indices.in.progress=正在編制索引

# ## org/jetbrains/plugins/scala/findUsages/compilerReferences/search/CompilerIndicesSearcher.scala
bytecode.indices.find.usages=尋找用法
bytecode.indices.invalidated.title=失效的用法
bytecode.indices.invalidated.message=由於進行了外部更改，以下檔案中的某些用法可能已失效: {0}。

# ## org/jetbrains/plugins/scala/findUsages/compilerReferences/search/ImplicitUsagesSearchDialogs.scala
bytecode.indices.find.usages.with.title=尋找用法({0})
bytecode.indices.settings.navigate=導航到字節碼索引設定
bytecode.indices.enable.indexing=啟用字節碼索引
bytecode.indices.enable=啟用
bytecode.indices.enable.and.restart=啟用並重啟
bytecode.indices.precompile=在搜尋前預編譯使用範圍內的模組
bytecode.indices.bytecode=字節碼
bytecode.indices.settings=設定 | 字節碼索引
bytecode.indices.required=此搜尋依賴於
bytecode.indices.outdated=，但它未處於最新狀態。
bytecode.indices.incomplete=如果不進行編譯，結果可能不完整。
bytecode.indices.must.be.enabled.1=搜尋 {0} 用法需要啟用字節碼索引。
bytecode.indices.must.be.enabled.2=要啟用字節碼索引(在 IDEA 重啟後生效)嗎?

# ## org/jetbrains/plugins/scala/findUsages/compilerReferences/settings/CompilerIndicesConfigurable.scala
bytecode.indices=字節碼索引
bytecode.indices.restart.title=字節碼索引設定更新
bytecode.indices.restart.message=重啟 IDEA 以啟用字節碼索引設定中的變更?
bytecode.indices.shutdown.message=關閉 IDEA 以啟用字節碼索引設定中的變更?

# ## org/jetbrains/plugins/scala/findUsages/compilerReferences/settings/CompilerIndicesSettingsForm.form
scala.compiler.indices.settings.enable.cb=索引 .class 檔案(&I)
scala.compiler.indices.settings.invalidate.button=刪除索引(&D)
scala.compiler.indices.sbt.automatic=自動(需要 sbt shell)(&A)
scala.compiler.indices.sbt.manual=手動(&M)
# Bytecode indices settings
apply.unapply.methods=apply / unapply 方法
for.comprehension.methods=For-comprehension 方法(map、withFilter、flatMap、foreach)
add.line.to.build.sbt=向 build.sbt 中添加以下行:
add.line.to.plugins.sbt=向 project/plugins.sbt 中添加以下行:
implicit.definitions=隱式定義
port.number=端口號:
sam.types=SAM 類型
sbt.compilation.listener=sbt 編譯偵聽器設定(套用程序級)
use.indices.to.search=使用索引搜尋此物件的用法:

# ## org/jetbrains/plugins/scala/findUsages/compilerReferences/settings/CompilerIndicesSettingsForm.java
are.you.sure.you.want.to.delete.the.bytecode.indices=確定要刪除字節碼索引嗎?
delete.bytecode.indices=刪除字節碼索引

# ## org/jetbrains/plugins/scala/findUsages/factory/ScalaFindUsagesHandlerFactory.scala
find.usages.member.has.supers=成員 {0} 覆寫/實作一些基本成員。\n要尋找基本成員的用法嗎?
title.warning=警告

# ## org/jetbrains/plugins/scala/findUsages/factory/ScalaTypeDefinitionUsagesDialog.scala
find.what.members.usages.checkbox=成員的用法(&M)
find.what.implementing.type.definitions.checkbox=實作類型定義(&D)
find.what.companion.module.checkbox=伴生模組的用法(&C)
find.what.new.instances.usages=僅創建實例(&I)

# ## org/jetbrains/plugins/scala/highlighter/ScalaColorSchemeAnnotator.scala
scala.mutable.collection=可變集合
scala.immutable.collection=不可變集合
java.collection=Java 集合

# ## org/jetbrains/plugins/scala/lang/completion/ScalaCompletionUtil.scala
wrong.top.statement.declaration=錯誤的 top 語句宣告

# ## org/jetbrains/plugins/scala/lang/completion/ScalaGlobalMembersCompletionContributor.scala
to.import.method.statically.press.hotkey=要靜態匯入方法，請按 {0}

# ## org/jetbrains/plugins/scala/lang/completion/lookups/ScalaImportStaticLookupActionProvider.scala
action.import.member=匯入成員

# ## org/jetbrains/plugins/scala/lang/findUsages/ScalaFindUsagesProvider.scala
method.of.containingclass={0}/{1}
descriptive.name.anonymous=匿名

# ## org/jetbrains/plugins/scala/lang/findUsages/ScalaUsageTypeProvider.scala
usage.extractor=提取程序
usage.typed.pattern=類型化模式
usage.typed.statement=類型化語句
usage.method.apply=`apply` 方法
usage.this.reference=This 引用
usage.access.modifier=存取修飾符
usage.package.clause=軟體套件子句
usage.function.expression=函數表達式
usage.named.parameter=命名參數
usage.interpolated.string.prefix=插值字串前綴
usage.parameter.in.pattern=模式中的參數
usage.self.type=自類型
usage.type.bound=類型綁定
usage.type.alias=類型別名
usage.secondary.constructor=輔助構造函數
usage.implicit.conversion.parameter=隱式轉換/參數
usage.unresolved.implicit.conversion.parameter=未解析的隱式轉換/參數
usage.sam.interface.implementation=SAM 接口實作

# ## org/jetbrains/plugins/scala/lang/formatting/scalafmt/ScalaFmtSuggesterService.scala
scalafmt.suggester.detected.in.project=在此專案中檢測到了 Scalafmt 設定，是否啟用 scalafmt 格式化程序?
scalafmt.suggester.enable=啟用
scalafmt.suggester.dont.show=不顯示

# ## org/jetbrains/plugins/scala/lang/formatting/scalafmt/ScalafmtDynamicConfigServiceImpl.scala
# Scalafmt
scalafmt.picked.new.config=Scalafmt 選擇了新樣式設定(v{0})
scalafmt.can.not.find.config.file=無法找到設定檔案: {0}
scalafmt.can.not.find.config.file.go.to.settings=設定…
scalafmt.can.not.find.config.file.create.new=創建新檔案
scalafmt.can.not.create.config.file=無法創建設定檔案
scalafmt.config.load.errors.failed.to.load.config=無法載入 scalafmt 設定
scalafmt.config.load.errors.parse.error=解析錯誤: {0}
scalafmt.config.load.errors.cyclic.includes.detected=檢測到迴圈 include
scalafmt.config.load.actions.open.config.file=開啟設定檔案

# ## org/jetbrains/plugins/scala/lang/formatting/scalafmt/ScalafmtDynamicServiceImpl.scala
scalafmt.download=下載
scalafmt.resolve.again=再次解析
scalafmt.progress.resolving.scalafmt.version=正在解析 scalafmt 版本 {0}
scalafmt.progress.downloading.scalafmt.version=正在下載 scalafmt 版本 {0}
scalafmt.progress.resolving.scalafmt.version.cancel=停止解析
scalafmt.progress.downloading.scalafmt.version.cancel=停止下載
scalafmt.progress.version.was.downloaded=已下載 Scalafmt 版本 {0}
scalafmt.resolve.errors.cant.resolve.scalafmt.version=無法解析 scalafmt 版本 {0}
scalafmt.resolve.errors.version.is.not.downloaded.yet=尚未下載 Scalafmt 版本 `{0}`。<br>要下載嗎?
scalafmt.resolve.errors.download.is.in.progress=正在下載
scalafmt.resolve.errors.downloading.error.occurred=下載時出錯
scalafmt.resolve.errors.classpath.is.corrupted=類路徑損壞
scalafmt.resolve.errors.unknown.error=未知錯誤

# ## org/jetbrains/plugins/scala/lang/formatting/scalafmt/processors/ScalaFmtPreFormatProcessor.scala
# 0:file link;1:error message
scalafmt.format.errors.scala.file.parse.error=Scalafmt 解析錯誤({0}):<br>{1}
# 0:file link;1:error message
scalafmt.format.errors.failed.to.find.correct.surrounding.code=Scalafmt 錯誤({0}): <br>無法找到要為 scalafmt 傳遞的正確的環繞程式碼，不會執行格式化

# ## org/jetbrains/plugins/scala/lang/formatting/settings/ImportsPanel.form
imports.panel.class.count.to.use.import.with=將 import 與 ''_'' 搭配使用的類計數:
imports.panel.add.import.statement.in.closest.block=添加最接近的塊中的 import 語句
imports.panel.add.fully.qualified.imports=添加完全限定 import
imports.panel.do.not.change.path.during.optimize.imports.for.local.imports=在針對本地 import 最佳化 import 期間不更改路徑
imports.panel.sort.imports.for.optimize.imports=import 排序(用於最佳化 import):
imports.panel.lexicographically=字典順序
imports.panel.scalastyle.consistent=scalastyle 一致
imports.panel.force.scala2.in.source3=使用 -Xsource:3 時匯入語法:
# TODO
imports.panel.merge.imports.with.the.same.prefix.into.one.statement=將具有相同前綴的 import 合併到一條語句中
imports.panel.use.the.shortest.path.when.trying.to.import.reference.with.already.imported.name=在嘗試匯入具有已匯入名稱的引用時，請使用最短路徑
imports.panel.classes.to.use.only.with.prefix=僅使用指定前綴的類
imports.panel.import.layout=匯入布局
imports.panel.imports.always.marked.as.used=import 始終標記為已使用
except.for.base.package=對基礎軟體套件例外

# ## org/jetbrains/plugins/scala/lang/formatting/settings/ImportsPanel.java
# Imports panel
imports.panel.title=Import
imports.panel.add.pattern.to.use.appropriate.classes.only.with.prefix=添加模式以使用僅帶有前綴的適當的類
imports.panel.use.references.with.prefix=使用帶前綴的引用:
imports.panel.no.imports.with.prefix=沒有帶前綴的 import
imports.panel.add.package.name=添加軟體套件名
imports.panel.import.layout.manager=匯入布局管理器
imports.panel.add.import.to.always.mark.it.as.used=添加 import 以始終將其標記為已使用
imports.panel.always.mark.as.used=始終標記為已使用
imports.panel.honestly.mark.imports.as.unused=如實將 import 標記為未使用
imports.panel.base.package.help=如果基礎軟體套件為 <code>org.example.application</code>，類 <code>org.example.application.NAME</code> 應匯入為 <code>import NAME</code>

# ## org/jetbrains/plugins/scala/lang/formatting/settings/MultiLineStringCodeStylePanel.form
multi.line.string.panel.opening.quotes.on.new.line=在新行中放置左引號(&O)
multi.line.string.panel.place.closing.quotes.on.new.line.on.enter.press=在新行中按 enter 鍵時放置右引號(&C)
multi.line.string.panel.align.dangling.closing.quotes=對齊懸空的右引號(&A)
multi.line.string.panel.insert.margin.char.on.enter=在新行中按 enter 鍵時插入邊距字符(&I)
multi.line.string.panel.process.margin.on.copy.paste=在複製/貼上時去除/插入邊距(&S)
multi.line.string.panel.margin.char.value=邊距字符:
multi.line.string.panel.margin.char.indent=邊距字符縮排:

# ## org/jetbrains/plugins/scala/lang/formatting/settings/MultiLineStringCodeStylePanel.java
# Multi-line strings panel
multi.line.string.panel.title=多行字串

# ## org/jetbrains/plugins/scala/lang/formatting/settings/OtherCodeStylePanel.form
other.panel.enforce.functional.syntax.for.methods.with.unit.return.type=對具有 Unit 返回類型的方法強制執行函數語法
other.panel.reformat.on.compile=編譯時重新格式化
other.panel.replace.with.unicode.symbol=將 ''=>'' 取代為 unicode 符號
other.panel.replace.with.unicode.symbol1=將 ''->'' 取代為 unicode 符號
other.panel.replace.in.for.generator.with.unicode.symbol=將 "for" 生成器中的 ''<-'' 取代為 unicode 符號
other.panel.kind.projector.replace.lambda.with.unicode.symbol=Kind Projector: 將 ''Lambda'' 取代為 unicode 符號
other.panel.alternate.indentation.for.constructor.args.and.parameter.declarations=構造函數實參和參數宣告的備選縮排:
other.panel.spaces=Space
other.panel.implicit.value.class.prefix.suffix=隱式值類前綴/後綴

# ## org/jetbrains/plugins/scala/lang/formatting/settings/CodeGenerationPanel.java
# Code Generation panel
codegeneration.panel.title=程式碼生成

# ## org/jetbrains/plugins/scala/lang/formatting/settings/OtherCodeStylePanel.java
# Other panel
other.panel.title=其他

# ## org/jetbrains/plugins/scala/lang/formatting/settings/Scala3SettingsPanel.scala
scala3.panel.use.indentation.based.syntax=使用基於縮排的語法
scala3.panel.title=Scala 3

# ## org/jetbrains/plugins/scala/lang/formatting/settings/ScalaCodeStyleSettings.java
# align options
wrapping.and.braces.panel.extends.do.not.align=不對齊
wrapping.and.braces.panel.extends.on.first.token=在第一個令牌上
wrapping.and.braces.panel.extends.align.to.extends=對齊 ''extends''

# ## org/jetbrains/plugins/scala/lang/formatting/settings/ScalaDocFormattingPanel.scala
# Scaladoc panel
scaladoc.panel.title=ScalaDoc
scaladoc.panel.enable.scaladoc.formatting=啟用 scaladoc 格式化
scaladoc.panel.add.additional.space.for.leading.asterisk=為前導星號添加額外空格
scaladoc.panel.groups.blank.lines=空行
scaladoc.panel.groups.alignment=對齊
scaladoc.panel.groups.other=其他

# ## org/jetbrains/plugins/scala/lang/formatting/settings/ScalaFmtSettingsPanel.scala
scalafmt.default=預設
scalafmt.default.path=預設: {0}
# Code style panel
scalafmt.settings.panel.show.warnings.when.formatting.invalid.code=在嘗試格式化無效程式碼時顯示警告
scalafmt.settings.panel.use.intellij.formatter.for.code.range.formatting=使用 IntelliJ 格式化程序進行程式碼範圍格式化
scalafmt.settings.panel.use.intellij.formatter.for.code.range.formatting.warning.tooltip=使用 Scalafmt 格式化程式碼範圍可能導致程式碼不一致。<br>Scalafmt 設計為僅格式化包含 scala 程式碼的整個檔案
scalafmt.settings.panel.reformat.on.file.save=儲存時重新格式化({0})
scalafmt.settings.panel.reformat.on.file.save.tooltip=提示:使用重新格式化程式碼({0})
scalafmt.settings.panel.fallback.to.default.settings=回退到預設 IntelliJ 設定
scalafmt.settings.panel.configuration.label=設定
scalafmt.settings.panel.scalafmt.version.label=Scalafmt 版本
scalafmt.settings.panel.select.custom.scalafmt.configuration.file=選擇自訂 scalafmt 設定檔案
scalafmt.settings.panel.no.config.found.under.path.using.default=未在指定路徑下找到設定檔案
scalafmt.settings.panel.errors.cant.resolve.version=無法解析 scalafmt 版本 {0}
scalafmt.settings.panel.errors.failed.to.parse.config=無法解析設定:<br> {0}
scalafmt.settings.panel.errors.cant.find.config.file=無法找到具有以下路徑的 scalafmt 設定檔案:<br> {0}

# ## org/jetbrains/plugins/scala/lang/formatting/settings/ScalaLanguageCodeStyleSettingsProvider.scala
# Spaces
spaces.panel.simple.one.line.block.braces=簡單的單行塊大括號
spaces.panel.import.braces=匯入大括號
spaces.panel.self.type.braces=自類型大括號
spaces.panel.before.context.bound.colon.rest=在上下文邊界冒號前面(剩餘)
spaces.panel.before.context.bound.colon.leading.higher.kinded=在上下文邊界冒號前面(前導高階)
spaces.panel.before.context.bound.colon.leading=在上下文邊界冒號前面(前導)
spaces.panel.before.opening.square.bracket=在左方括號前面
spaces.panel.keep.one.line.comments.on.same.line=在同一行中保留一行註釋
spaces.panel.newline.after.annotations=在註解後面換行
spaces.panel.around.at.in.pattern.bindings=環繞模式綁定中的 ''@''
spaces.panel.inside.closure.braces=右大括號內
spaces.panel.before.colon.after.declarations.name=冒號前面，宣告的名稱後面
spaces.panel.after.colon.before.declarations.type=冒號後面，宣告的類型前面
spaces.panel.method.call.left.brace=方法調用左大括號
spaces.panel.preserve.space.before.method.parentheses=保留方法圓括號前面的空格
spaces.panel.infix.method.parentheses=中綴方法圓括號
spaces.panel.infix.operator.like.method.call.parentheses=類似於中綴運算符的方法調用圓括號
spaces.panel.infix.method.call.parentheses=中綴方法調用圓括號
spaces.panel.constructor.parameters.with.modifiers=帶修飾符的構造函數參數
# Wrapping and Braces
# custom groups
wrapping.and.braces.panel.groups.method.definition=方法定義
wrapping.and.braces.panel.groups.anonymous.method.definition=匿名方法定義
wrapping.and.braces.panel.groups.class.definition=類定義
wrapping.and.braces.panel.groups.xml.formatting=XML 格式化
wrapping.and.braces.panel.groups.tuple=元組
wrapping.and.braces.panel.groups.type.arguments=類型實參
wrapping.and.braces.panel.groups.type.parameters=類型參數
wrapping.and.braces.panel.force.braces=強制使用大括號
wrapping.and.braces.panel.force.try.braces=強制使用 ''try'' 大括號
wrapping.and.braces.panel.force.case.branch.braces=強制使用 ''case'' 分支大括號
wrapping.and.braces.panel.force.finally.braces=強制 ''finally'' 大括號
wrapping.and.braces.panel.align.tuple.elements=對齊元組元素
wrapping.and.braces.panel.do.not.indent.tuples.closing.parenthesis=不縮排元組右圓括號
wrapping.and.braces.panel.do.not.align.block.expression.parameters=不對齊塊表達式參數
wrapping.and.braces.panel.indent.braced.arguments=縮排帶大括號的實參
wrapping.and.braces.panel.simple.one.line.lambdas.in.arg.list=實參列表中簡單的單行 lambda
wrapping.and.braces.panel.keep.xml.formatting=保持 xml 格式化
wrapping.and.braces.panel.place.self.type.on.new.line=將自類型置於新行中
wrapping.and.braces.panel.align.multiline.pattern.alternatives=對齊多行模式替代項
wrapping.and.braces.panel.align.in.columns.case.branches=對齊列 ''case'' 分支
wrapping.and.braces.panel.do.not.indent.case.clause.body=不縮排 case 子句體
wrapping.and.braces.panel.match.statement=''match'' 語句
wrapping.and.braces.panel.indent.first.parameter.clause.if.on.new.line=遇到新行時縮排第一個參數子句
wrapping.and.braces.panel.indent.first.parameter.if.on.new.line=遇到新行時縮排第一個參數
wrapping.and.braces.panel.align.parameter.types.in.multiline.declarations=多行時對齊參數類型
wrapping.and.braces.panel.use.normal.indent.for.parameters=對參數使用標準縮排
wrapping.and.braces.panel.parameters.on.new.line=新行中的參數
wrapping.and.braces.panel.wrap.before.with.keyword=在 ''with'' 關鍵字前換行
wrapping.and.braces.panel.align.if.else.statements=對齊 if-else 語句
wrapping.and.braces.panel.indent=縮排
wrapping.and.braces.panel.new.line.options.no.new.line=不換行
wrapping.and.braces.panel.new.line.options.new.line.always=始終換行
wrapping.and.braces.panel.new.line.options.new.line.for.multiple.arguments=對多行實參換行
wrapping.and.braces.panel.renamed.infix.expressions=中綴表達式
wrapping.and.braces.panel.renamed.extends.with.list=extends/with 列表
wrapping.and.braces.panel.renamed.extends.keyword=extends 關鍵字
wrapping.and.braces.panel.renamed.force.yield.braces=強制使用 yield 大括號
wrapping.and.braces.panel.for.indent.yield.after.one.line.enumerators=縮排單行枚舉器後面的 yield
# Blank Lines
blank.lines.panel.around.method.in.inner.scopes=環繞內部範圍中的方法
blank.lines.panel.around.field.in.inner.scopes=環繞內部範圍中的欄位
blank.lines.panel.around.class.in.inner.scopes=環繞內部範圍中的類
scaladoc.panel.align.parameter.descriptions=對齊參數描述
scaladoc.panel.align.throws.exception.descriptions=對齊拋出異常描述
scaladoc.panel.align.return.value.description=對齊返回值描述
scaladoc.panel.align.other.tags.descriptions=對齊其他標記描述
scaladoc.panel.blank.lines.keep=保留(不移除標記之間的空白行)
scaladoc.panel.between.parameter.descriptions=在參數描述之間
scaladoc.panel.before.parameter.descriptions=在參數描述前面
scaladoc.panel.before.tags=標記之前
scaladoc.panel.after.tags=return 之後
scaladoc.panel.after.parameter.comments=在參數描述後
scaladoc.panel.preserve.spaces.in.tags=保留標記中的空格
align.list.items.content=對齊列表項內容

# ## org/jetbrains/plugins/scala/lang/formatting/settings/ScalaTabbedCodeStylePanel.scala
scala.root.code.style.panel.formatter=格式化程序:

# ## org/jetbrains/plugins/scala/lang/formatting/settings/TrailingCommaPanel.scala
# Trailing comma
trailing.comma.panel.title=尾隨逗號
trailing.comma.panel.keep=保留
trailing.comma.panel.remove.when.multiline=多行時移除
trailing.comma.panel.add.when.multiline=多行時添加
trailing.comma.panel.scope.arguments.list=實參列表
trailing.comma.panel.scope.parameters.list=參數列表
trailing.comma.panel.scope.tuple=元組
trailing.comma.panel.scope.tuple.type=元組類型
trailing.comma.panel.scope.pattern.arguments.list=模式實參列表
trailing.comma.panel.scope.type.parameters.list=類型參數列表
trailing.comma.panel.scope.import.selector=import 選擇器

# ## org/jetbrains/plugins/scala/lang/formatting/settings/TypeAnnotationsPanelBase.form
# Use for
type.annotations.panel.use.for=用於
type.annotations.panel.public.member=public 成員
type.annotations.panel.protected.member=protected 成員
type.annotations.panel.private.member=private 成員
type.annotations.panel.local.definition=本地定義
type.annotations.panel.function.literal.parameter=函數文字參數
type.annotations.panel.underscore.parameter=為參數加下劃線
# Enforce for
type.annotations.panel.enforce.for=對以下物件實施
type.annotations.panel.implicit.definition=隱式定義
type.annotations.panel.unit.type=Unit 類型
type.annotations.panel.accidental.structural.type=意外結構類型*
type.annotations.panel.accidental.structural.type.tooltip=<html>強制對值執行類型註解，它們具有推斷的結構類型，例如<br>\n<pre><code>\nval foo = Runnable {\noverride def run(): Unit = ()\ndef helper(): Unit = ()\n} // foo has inferred type Runnable { def helper(): Unit } \n</code></pre></html>
# Except when
type.annotations.panel.except.when=以下情況除外
type.annotations.panel.member.of.anonymous.class=匿名類的成員
type.annotations.panel.member.of.private.class=私有類的成員
type.annotations.panel.member.of=成員上級:
type.annotations.panel.annotated.with=註解方式:
type.annotations.panel.constant.final.val=常數(final val)
type.annotations.panel.type.is.stable=類型穩定*
type.annotations.panel.type.is.stable.tooltip=<html><body>當右側為:<br> 文字: <code>123</code>、<code>"string"</code> 等( <code>null</code> 除外)<br> Unit 表達式: <code>()</code><br> 物件創建: <code>new Foo(...)</code> (包含細化的除外: <code>new Foo() {}</code>)<br> 工廠方法調用: <code>Foo(...)</code> (遇到伴生物件時調用 <code>apply(...)</code>)<br> 空集合: <code>Seq.empty[Int]</code>、<code>Map.empty[Int, String]</code> 等。<br> Java 枚舉常數: <code>Enum.VALUE</code><br> 異常: <code>throw Exception()</code> </body></html>
type.annotations.panel.type.matches=類型符合:
type.annotations.panel.in.test.sources=測試原始碼中
type.annotations.panel.in.scala.dialect.sources=Scala 方言原始碼中*
type.annotations.panel.in.scala.dialect.sources.tooltip=*.sbt、*.sc 等

# ## org/jetbrains/plugins/scala/lang/formatting/settings/TypeAnnotationsPanelBase.java
# Type Annotations panel
type.annotations.panel.title=類型註解
type.annotations.panel.classes=類
type.annotations.panel.annotations=註解
type.annotations.panel.type.patterns=類型模式

# ## org/jetbrains/plugins/scala/lang/macros/expansion/MacroExpansionLineMarkerProvider.scala
scala.meta.expand=擴展巨集
undo.macro.expansion=撤消巨集擴展

# ## org/jetbrains/plugins/scala/lang/parser/parsing/CommonUtils.scala
wrong.pattern=錯誤模式
right.brace.expected=應為 '}'
bad.interpolated.string.injection=插值字串注入錯誤
wrong.string.literal=字串文字錯誤
end.of.string.expected=應為字串結尾

# ## org/jetbrains/plugins/scala/lang/parser/parsing/CompilationUnit.scala
package.qualID.expected=應為軟體套件限定關鍵字
semi.expected=應為 '';'' 或換行符
out.of.compilation.unit=超出編譯單元

# ## org/jetbrains/plugins/scala/lang/parser/parsing/Packaging.scala
lbrace.expected=應為 '{'
lbrace.or.colon.expected=應為 '{' 或 '':''
unreachable.error=發現意外錯誤

# ## org/jetbrains/plugins/scala/lang/parser/parsing/TopStat.scala
missing.toplevel.statement.for.annotation=註解的頂層語句缺失

# ## org/jetbrains/plugins/scala/lang/parser/parsing/base/AccessQualifier.scala
rsqbracket.expected=應為 '']''
identifier.expected=應為關鍵字

# ## org/jetbrains/plugins/scala/lang/parser/parsing/base/Extension.scala
parameter.expected=應為參數
expected.at.least.one.extension.method=應至少為一種擴展方法
expected.new.line.after.colon=冒號後應為新行
extension.method.expected=應為擴展方法

# ## org/jetbrains/plugins/scala/lang/parser/parsing/base/ImportExpr.scala
identifier.or.opening.brace.expected=應為關鍵字或左括號

# ## org/jetbrains/plugins/scala/lang/parser/parsing/base/ImportSelector.scala
identifier.or.wild.sign.expected=應為關鍵字或 ''_''

# ## org/jetbrains/plugins/scala/lang/parser/parsing/base/ImportSelectors.scala
rbrace.expected=應為 '}'
import.selector.expected=應為 import 選擇器

# ## org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Annotation.scala
wrong.annotation.expression=錯誤的註解表達式

# ## org/jetbrains/plugins/scala/lang/parser/parsing/expressions/ArgumentExprs.scala
rparenthesis.expected=應為 '')''
wrong.expression=錯誤的表達式

# ## org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Ascription.scala
annotation.or.type.expected=應為註解或類型

# ## org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Binding.scala
wrong.type=錯誤類型

# ## org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Bindings.scala
wrong.binding=錯誤參數

# ## org/jetbrains/plugins/scala/lang/parser/parsing/expressions/BlockStat.scala
wrong.declaration.in.block=塊不能包含宣告
missing.statement.for.annotation=註解的語句缺失

# ## org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Enumerator.scala
choose.expected=生成器語句中應有 ''<-''

# ## org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Expr1.scala
case.clauses.expected=應為 case 子句
while.expected=''do'' 語句中應有 while 關鍵字
enumerators.expected=''for'' 語句中應有枚舉器
condition.expected=應為布爾條件
expected.then=應為 ''then''
expected.do=應為 ''do''
expected.do.or.yield=應為 ''do'' 或 ''yield''

# ## org/jetbrains/plugins/scala/lang/parser/parsing/expressions/ExprInIndentationRegion.scala
line.is.indented.too.far.to.the.left=行向左縮排過多

# ## org/jetbrains/plugins/scala/lang/parser/parsing/expressions/NameValuePair.scala
assign.expected=應為 ''=''

# ## org/jetbrains/plugins/scala/lang/parser/parsing/expressions/Quoted.scala
type.expected=應為類型

# ## org/jetbrains/plugins/scala/lang/parser/parsing/expressions/ResultExpr.scala
fun.sign.expected=應為 ''=>''

# ## org/jetbrains/plugins/scala/lang/parser/parsing/params/FunTypeParamClause.scala
wrong.parameter=錯誤參數

# ## org/jetbrains/plugins/scala/lang/parser/parsing/params/ImplicitParamClause.scala
implicit.params.excepted=隱式參數子句必須至少有一個參數

# ## org/jetbrains/plugins/scala/lang/parser/parsing/params/ParamClause.scala
using.parameter.clause.expected=應為 ''using'' 參數子句

# ## org/jetbrains/plugins/scala/lang/parser/parsing/params/ParamClauses.scala
param.clause.expected=應為參數子句

# ## org/jetbrains/plugins/scala/lang/parser/parsing/params/TypeParam.scala
variance.annotation.not.allowed=此處不允許差異註解
context.bounds.not.allowed=此處不允許上下文邊界
view.bounds.not.allowed=此處不允許檢視邊界

# ## org/jetbrains/plugins/scala/lang/parser/parsing/params/TypesAsParamsOrParams.scala
expected.more.types=預期更多類型

# ## org/jetbrains/plugins/scala/lang/parser/parsing/patterns/CaseClause.scala
pattern.expected=應為模式

# ## org/jetbrains/plugins/scala/lang/parser/parsing/patterns/Guard.scala
wrong.postfix.expression=錯誤的後綴表達式

# ## org/jetbrains/plugins/scala/lang/parser/parsing/patterns/Pattern3.scala
wrong.type.associativity=錯誤的關聯性。所有運算符應有相同的關聯性
simple.pattern.expected=簡單模式的起始非法

# ## org/jetbrains/plugins/scala/lang/parser/parsing/statements/FunDef.scala
wrong.constr.expression=錯誤的構造函數表達式
auxiliary.constructor.may.not.have.a.type.annotation=輔助構造函數不能有類型註解
auxiliary.constructor.definition.expected=應為輔助構造函數定義

# ## org/jetbrains/plugins/scala/lang/parser/parsing/statements/PatDef.scala
expression.expected=應為表達式
expected.another.pattern=應為另一種模式

# ## org/jetbrains/plugins/scala/lang/parser/parsing/statements/ValDcl.scala
wrong.val.declaration=錯誤的值宣告

# ## org/jetbrains/plugins/scala/lang/parser/parsing/statements/VarDcl.scala
wrong.var.declaration=錯誤的變數宣告

# ## org/jetbrains/plugins/scala/lang/parser/parsing/top/QualId.scala
wrong.qual.identifier=錯誤的限定關鍵字

# ## org/jetbrains/plugins/scala/lang/parser/parsing/top/TmplDef.scala
wrong.case.modifier=錯誤的 case 修飾符。將它用於類或物件

# ## org/jetbrains/plugins/scala/lang/parser/parsing/top/params/ClassParam.scala
colon.expected=應為 '':''
parameter.type.expected=應為參數類型
val.var.expected=應為 val 或 var 關鍵字

# ## org/jetbrains/plugins/scala/lang/parser/parsing/top/template/TemplateBody.scala
def.dcl.expected=應為定義或宣告

# ## org/jetbrains/plugins/scala/lang/parser/parsing/types/ExistentialClause.scala
existential.block.expected=應為存在子句

# ## org/jetbrains/plugins/scala/lang/parser/parsing/types/ExistentialDclSeq.scala
wrong.existential.declaration=錯誤的存在宣告。它必須是類型宣告或值宣告

# ## org/jetbrains/plugins/scala/lang/parser/parsing/types/InfixType.scala
compound.type.expected=應為複合類型

# ## org/jetbrains/plugins/scala/lang/parser/parsing/types/MatchTypeSuffix.scala
match.type.cases.expected=應為 match 類型 case 子句
expected.case.on.a.new.line=應為新行中的 case

# ## org/jetbrains/plugins/scala/lang/parser/parsing/types/PolyFunOrTypeLambda.scala
type.lambda.expected=應為 ''=>>''

# ## org/jetbrains/plugins/scala/lang/parser/parsing/types/SimpleType.scala
identifier.expected.comma.found=應為關鍵字，但找到的是 '',''

# ## org/jetbrains/plugins/scala/lang/parser/parsing/types/StableId.scala
dot.expected=應為 ''.''
dot.or.cq.expected=應為 ''.'' 或類限定符

# ## org/jetbrains/plugins/scala/lang/parser/parsing/xml/AttrValue.scala
xml.attribute.end.expected=應為 xml 特性值結束分隔符

# ## org/jetbrains/plugins/scala/lang/parser/parsing/xml/Attribute.scala
xml.eq.expected=應為 ''=''
xml.attribute.value.expected=應為特性值

# ## org/jetbrains/plugins/scala/lang/parser/parsing/xml/CDSect.scala
xml.cdata.end.expected=應為 xml CData 結尾

# ## org/jetbrains/plugins/scala/lang/parser/parsing/xml/Comment.scala
xml.comment.end.expected=應為 xml 註釋結束 (''-->'')
xml.wrong.character=xml 註釋中的錯誤字符

# ## org/jetbrains/plugins/scala/lang/parser/parsing/xml/ETag.scala
xml.tag.end.expected=應為 xml 標記結尾
xml.name.expected=應為 xml 標記名稱

# ## org/jetbrains/plugins/scala/lang/parser/parsing/xml/Element.scala
xml.end.tag.expected=應為 xml 結束標記(''</'' name '>')

# ## org/jetbrains/plugins/scala/lang/parser/parsing/xml/PI.scala
xml.PI.end.expected=應為 xml 處理指令結尾

# ## org/jetbrains/plugins/scala/lang/parser/parsing/xml/ScalaExpr.scala
xml.scala.injection.end.expected=應為 xml 中的 Scala 注入結尾('}')
xml.scala.expression.expected=xml 注入中應有 Scala 表達式

# ## org/jetbrains/plugins/scala/lang/parser/parsing/xml/pattern/ScalaPatterns.scala
xml.scala.patterns.expected=xml 注入中應有 Scala 模式

# ## org/jetbrains/plugins/scala/lang/psi/api/base/types/ScTypeElement.scala
recursive.type.of.type.element=類型元素的遞歸類型
cannot.desugarize.typename=無法對 {0} 脫糖

# ## org/jetbrains/plugins/scala/lang/psi/api/expr/ScBlock.scala
cannot.find.partialfunction.class=找不到 PartialFunction 類
cannot.find.throwable.class=找不到 Throwable 類
cannot.infer.type.without.expected.type=沒有預期類型，無法推斷類型
cannot.infer.type.without.function.expected.type=沒有 scala.FunctionN 或 scala.PartialFunction 的預期類型，無法推斷類型

# ## org/jetbrains/plugins/scala/lang/psi/api/expr/ScExpression.scala
no.type.inferred=沒有為表達式 ''{0}'' 推斷出類型

# ## org/jetbrains/plugins/scala/lang/psi/api/statements/ScTypeAliasDefinition.scala
no.alias.type=無別名類型

# ## org/jetbrains/plugins/scala/lang/psi/compiled/SigFileViewProviderFactory.scala
file.type.scala.outlines=Scala 概述
could.not.decompile.file.comment=//無法反編譯 {0}

# ## org/jetbrains/plugins/scala/lang/psi/impl/base/ScConstructorInvocationImpl.scala
can.t.resolve.type=無法解析類型
java.constructors.only.have.one.parameter.section=Java 構造函數只有一個參數部分
has.no.reference=無引用

# ## org/jetbrains/plugins/scala/lang/psi/impl/base/ScInterpolatedStringLiteralImpl.scala
cannot.find.method.of.stringcontext=找不到 StringContext 的方法 {0}

# ## org/jetbrains/plugins/scala/lang/psi/impl/base/literals/ScLiteralImplBase.scala
wrong.psi.for.literal.type="用於獲取文字類型的元素錯誤"

# ## org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScConstructorPatternImpl.scala
cannot.resolve.unknown.symbol=無法解析符號

# ## org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScReferencePatternImpl.scala
cannot.define.expected.type=無法定義預期類型

# ## org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScSeqWildcardPatternImpl.scala
no.expected.type.for.wildcard.naming=萬用字元命名沒有預期的類型

# ## org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScTypedPatternImpl.scala
no.type.element.for.type.pattern=類型模式沒有類型元素
no.type.pattern=無類型模式

# ## org/jetbrains/plugins/scala/lang/psi/impl/base/patterns/ScWildcardPatternImpl.scala
cannot.determine.expected.type=無法確定預期類型

# ## org/jetbrains/plugins/scala/lang/psi/impl/base/types/ScDependentFunctionTypeElementImpl.scala
dependent.function.types.are.not.yet.supported=尚不支持依賴函數類型

# ## org/jetbrains/plugins/scala/lang/psi/impl/base/types/ScSimpleTypeElementImpl.scala
cannot.find.template.for.this.reference=找不到此引用的模板
cannot.find.enclosing.container=找不到封閉的容器
cannot.resolve.ref=無法解析引用 {0}
unknown.macro.in.type.position=類型位置中的巨集未知
recursive.non.value.type.of.type.element=類型元素的遞歸非值類型

# ## org/jetbrains/plugins/scala/lang/psi/impl/base/types/ScTypeProjectionImpl.scala
cannot.resolve.reference=無法解析引用

# ## org/jetbrains/plugins/scala/lang/psi/impl/expr/MethodInvocationImpl.scala
suitable.method.not.found=找不到適合的方法

# ## org/jetbrains/plugins/scala/lang/psi/impl/expr/ScForImpl.scala
cannot.create.expression=無法創建表達式

# ## org/jetbrains/plugins/scala/lang/psi/impl/expr/ScGenericCallImpl.scala
not.a.polymorphic.lambda=非多態 lambda。

# ## org/jetbrains/plugins/scala/lang/psi/impl/expr/ScIfImpl.scala
nothing.to.type=沒有可以計算的類型

# ## org/jetbrains/plugins/scala/lang/psi/impl/expr/ScNewTemplateDefinitionImpl.scala
empty.new.expression=空 new 表達式

# ## org/jetbrains/plugins/scala/lang/psi/impl/expr/ScParenthesisedExprImpl.scala
no.expression.in.parentheses=圓括號中無表達式

# ## org/jetbrains/plugins/scala/lang/psi/impl/expr/ScReferenceExpressionImpl.scala
no.declared.type.found=找不到宣告的類型
case.class.has.no.primary.constructor=case 類沒有主構造函數
cannot.resolve.expression=無法解析表達式

# ## org/jetbrains/plugins/scala/lang/psi/impl/expr/ScSelfInvocationImpl.scala
not.enough.parameter.sections=參數部分不足
cannot.shape.resolve.self.invocation=無法解析自我調用

# ## org/jetbrains/plugins/scala/lang/psi/impl/expr/ScSuperReferenceImpl.scala
cannot.infer.type.of.super.expression=無法推斷 `super'' 表達式的類型

# ## org/jetbrains/plugins/scala/lang/psi/impl/expr/ScThisReferenceImpl.scala
cannot.infer.type=無法推斷類型
no.clazz.type.found=找不到類類型

# ## org/jetbrains/plugins/scala/lang/psi/impl/expr/ScUnderscoreSectionImpl.scala
typed.statement.is.not.complete.for.underscore.section=下劃線部分的類型化語句不完整
failed.to.found.corresponding.underscore.section=找不到對應的下劃線部分
could.not.infer.type.of.underscore.section=無法推斷下劃線部分的類型
no.type.inferred.for.unknown.expression=沒有為此表達式推斷出類型

# ## org/jetbrains/plugins/scala/lang/psi/impl/expr/xml/ScXmlPatternImpl.scala
not.found.scala.xml.node=找不到 scala.xml.Node

# ## org/jetbrains/plugins/scala/lang/psi/impl/statements/ScFunctionImpl.scala
both.stub.and.name.identifier.node.are.null={0} 的存根和名稱關鍵字節點均為 null \n{1}
no.defined.return.type=沒有定義的返回類型

# ## org/jetbrains/plugins/scala/lang/psi/impl/statements/ScValueDeclarationImpl.scala
no.type.element.found=在 ''{0}'' 中找不到類型元素

# ## org/jetbrains/plugins/scala/lang/psi/impl/statements/ScVariableDefinitionImpl.scala
cannot.infer.type.without.an.expression=沒有表達式，無法推斷類型

# ## org/jetbrains/plugins/scala/lang/psi/impl/statements/params/ScParameterImpl.scala
wrong.stub.problem=錯誤的存根問題
wrong.type.element=錯誤的類型元素

# ## org/jetbrains/plugins/scala/lang/psi/impl/toplevel/typedef/DerivesUtil.scala
derives.type.has.no.type.parameters=無法派生 {0} ，其不含類型參數
derives.type.has.no.companion.object=無法派生 {0} ，其不含伴生物件
derives.cannot.be.unified=無法將 {0} 與 {1} 的類型實參統一
derives.not.a.class.type={0} 不是類類型，無法派生
derives.scala.class.expected=應為 Scala class/trait
derives.no.member.named.derived=派生值不是物件 {0} 的成員

# ## org/jetbrains/plugins/scala/lang/psi/impl/toplevel/typedef/ScTypeDefinitionImpl.scala
cannot.resolve.parent.class=無法解析父類

# ## org/jetbrains/plugins/scala/lang/psi/light/DummyLightTypeParam.scala
no.containing.file=未包含檔案

# ## org/jetbrains/plugins/scala/lang/psi/types/Compatibility.scala
assignment.missing.right.side=右側缺少賦值
cannot.handle.compatibility.for=無法處理 {0} 的兼容性

# ## org/jetbrains/plugins/scala/lang/psi/types/api/Variance.scala
variance.contravariant=逆變
variance.covariant=協變
variance.invariant=不變
variance.bivariant=雙變

# ## org/jetbrains/plugins/scala/lang/psi/types/result/package.scala
no.element.found=找不到元素

# ## org/jetbrains/plugins/scala/lang/rearranger/RearrangerUtils.scala
# Rearranger panel
rearranger.panel.keep.scala.style.getters.and.setters.together=scala 樣式的 getter 和 setter 保持在一起
rearranger.panel.keep.java.style.getters.and.setters.together=java 樣式的 getter 和 setter 保持在一起
rearranger.panel.split.into.unarrangeable.blocks.by.expressions=通過表達式拆分為不可排列的塊
rearranger.panel.split.into.unarrangeable.blocks.by.implicits=通過隱式拆分為不可排列的塊

# ## org/jetbrains/plugins/scala/lang/refactoring/ScalaProcessImportsRefactoringHelper.scala
processing.imports.modified.during.refactoring=正在處理重構期間修改的 import

# ## org/jetbrains/plugins/scala/lang/refactoring/changeSignature/ConflictsUtil.scala
by.name.parameters.cannot.be.used=此方法有 Java 覆寫器，無法使用值類的傳名參數。
method.is.overridden.by.class.parameter.of.class=方法被 {0} 的傳類參數覆寫。不支持將其轉換為函數定義。
updating.of.usages.of.generated.unapply=不支持對生成的 `unapply` 方法的用法進行更新
method.is.overridden.in.a.composite.pattern.definition=方法在 {0} 的複合模式定義中被覆寫。不支持將其轉換為函數定義。
method.is.overridden.in.a.composite.variable.definition=方法在 {0} 的複合變數定義中被覆寫。不支持將其轉換為函數定義。

# ## org/jetbrains/plugins/scala/lang/refactoring/changeSignature/DefaultValuesUsagePanel.scala
default.values=預設值:
add.to.definition=添加到定義
modify.method.calls=修改方法調用

# ## org/jetbrains/plugins/scala/lang/refactoring/changeSignature/ScalaChangeSignatureDialog.scala
change.signature.vararg.should.be.last.in.clause=Vararg 參數應當為參數子句中的最後一個參數
change.signature.parameters.same.name.{0}=參數的名稱相同: {0}
change.signature.add.parameter.clause=添加參數子句
change.signature.remove.parameter.clause=移除參數子句
default.value.is.missing.default.arguments=缺少預設值。預設實參將包含空值，而不是新的參數值。
default.value.is.missing.method.calls=缺少預設值。方法調用將包含空值，而不是新的參數值。
specify.result.type=指定結果類型
default.ta.settings=設定

# ## org/jetbrains/plugins/scala/lang/refactoring/changeSignature/ScalaChangeSignatureHandler.scala
error.wrong.caret.position.method.name=文字游標應置於要重構的方法的名稱處。
change.signature.not.supported.implicit.functions=隱式函數不支持更改簽名
change.signature.not.supported.implicit.parameters=具有隱式參數的函數不支持更改簽名
change.signature.not.supported.extractors=提取程序不支持更改簽名

# ## org/jetbrains/plugins/scala/lang/refactoring/changeSignature/ScalaParameterTableModelItem.scala
change.signature.specify.type.for.parameter=指定參數 ''{0}'' 的類型
parameter.could.not.be.repeated.and.by.name=參數不能同時為重複參數和傳名參數
could.not.understand.type=無法理解類型 {0}

# ## org/jetbrains/plugins/scala/lang/refactoring/extractMethod/ScalaExtractMethodDialog.java
extract.method.title=提取方法
default.ta.tooltip=設定類型註解設定

# ## org/jetbrains/plugins/scala/lang/refactoring/extractMethod/ScalaExtractMethodHandler.scala
cannot.extract.used.function.definition=不支持重構: 選區內的函數定義在所選程式碼段之外使用
extract.method.cannot.find.possible.scope=找不到所提取方法的可能範圍
extract.local.method=提取 {0} 中的局部方法
extract.method.to.object.name=將方法提取到物件 {0}
extract.method.to.class.name=將方法提取到類 {0}
extract.method.to.trait.name=將方法提取到特徵 {0}
extract.method.to.anonymous.class=將方法提取到匿名類
try.block=try 塊
constructor=構造函數
case.clause=case 子句
if.block=if 塊
def.name=def {0}
extract.local.method.in.else.block=提取 else 塊中的局部方法
val.name=val {0}
var.name=var {0}
for.statement=for 語句
while.statement=while 語句
do.statement=do 語句
function.expression=函數表達式
code.block=程式碼塊
extract.file.method=提取檔案方法
unknown.extraction=未知提取
choose.level.for.extract.method=選擇提取方法的級別

# ## org/jetbrains/plugins/scala/lang/refactoring/extractMethod/duplicates/DuplicatesUtil.scala
process.duplicates=處理重複項

# ## org/jetbrains/plugins/scala/lang/refactoring/extractTrait/ExtractSuperUtil.scala
cannot.find.package.with.name=找不到具有此名稱的軟體套件: {0}
cannot.find.directory.for.package=找不到軟體套件的目錄: {0}
class.already.exists.in.package=軟體套件 {1} 中已存在名稱為 {0} 的類

# ## org/jetbrains/plugins/scala/lang/refactoring/extractTrait/ScalaExtractTraitAction.scala
extract.trait.action.text=提取特徵…
extract.trait.action.description=從所選類提取特徵

# ## org/jetbrains/plugins/scala/lang/refactoring/extractTrait/ScalaExtractTraitDialog.java
extract.trait.title=提取特徵
extract.trait.top.label.text=從中提取特徵:
extract.trait.name=特徵名稱:
extract.trait.package.label=新特徵的軟體套件:
members.to.extract=要提取的成員
extract.abstracts=提取 abstract 項

# ## org/jetbrains/plugins/scala/lang/refactoring/extractTrait/ScalaExtractTraitHandler.scala
private.member.cannot.be.used.in.extracted.member=私有成員 {0} 無法在提取的成員 {1} 中使用
member.of.anonymous.class.cannot.be.used.in.extracted.member=匿名類的成員 {0} 無法在提取的成員 {1} 中使用
super.reference.used.in.extracted.member=提取的成員 {0} 引用了 super 成員，但提取的特徵不會有基類
type.parameters.for.self.type.not.supported=提取的特徵將以 {0} 作為自類型，但不支持識別其類型參數

# ## org/jetbrains/plugins/scala/lang/refactoring/inline/ScalaInlineHandler.scala
cannot.inline.different.files=成員在另一個檔案中宣告。不支持內聯。
cannot.inline.used.outside.class=成員在包含的類外部使用。不支持內聯。
cannot.inline.stable.reference=值用於穩定的引用，不能內聯
cannot.inline.never.used=變數從未使用。
cannot.inline.not.simple.pattern=僅簡單的模式定義支援內聯
cannot.inline.recursive.function=遞歸函數不支持內聯
cannot.inline.function.implicit.parameters=具有隱式參數的函數不支持內聯
cannot.inline.function.multiple.clauses=具有多個參數子句的函數不支持內聯
cannot.inline.function.varargs=具有 vararg 參數的函數不支持內聯
cannot.inline.implicit.element=隱式元素不支持內聯
cannot.inline.special.function=特殊函數不支持內聯
cannot.inline.generic.function=泛型函數不支持內聯
cannot.inline.notsimple.typealias=僅簡單的類型別名支援內聯
cannot.inline.value.functional.type=不支持值與函數類型內聯
cannot.inline.function.functional.parameters=不支持函數與函數參數內聯
cannot.inline.parameter=參數不支持內聯
cannot.inline.not.method.call=僅一般方法調用支援內聯

# ## org/jetbrains/plugins/scala/lang/refactoring/introduceField/ScalaIntroduceFieldDialog.java
introduce.field.title=提取欄位
field.occurrences={0} 個匹配項

# ## org/jetbrains/plugins/scala/lang/refactoring/introduceField/ScalaIntroduceFieldFromExpressionHandler.scala
cannot.refactor.not.expression=所選字串無法提取為表達式
cannot.create.field.from.this.expression=無法根據此表達式創建欄位
cannot.find.place.for.the.new.field=找不到新字段的位置
choose.class.for.introduce.field=選擇用於引入欄位的類

# ## org/jetbrains/plugins/scala/lang/refactoring/introduceParameter/ScalaIntroduceParameterDialog.scala
parameter.label.name=名稱:
parameter.label.type=類型:
parameter.label.default.value=預設值:
replace.all.occurrences=取代所有符合項

# ## org/jetbrains/plugins/scala/lang/refactoring/introduceParameter/ScalaIntroduceParameterHandler.scala
cannot.refactor.no.function=找不到用於引入參數的函數
introduce.parameter.title=引入參數
refactoring.is.not.supported.contains.return=不支持重構: 選區包含 return 語句
choose.function.for.refactoring=選擇 {0} 的函數

# ## org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/IntroduceExpressions.scala
introduce.variable.title=引入值/變數

# ## org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/IntroduceTypeAlias.scala
cannot.refactor.not.valid.type=應選擇類型元素
cannot.refactor.scope.not.found=找不到適合的類或軟體套件
choose.scope.for=選擇 {0} 的範圍
introduce.type.alias.title=引入類型別名

# ## org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/ScalaInplaceTypeAliasIntroducer.scala
command.introduce.type.alias=引入類型別名
press.hotkey.to.show.more.options=按 ctrl + alt + v 顯示帶有更多選項的對話框

# ## org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/ScalaInplaceVariableIntroducer.scala
introduce.variable.declare.as.var=變數(&V)
introduce.variable.specify.type.explicitly=指定類型
introduce.variable.identifier.is.not.valid=關鍵字無效

# ## org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/ScalaIntroduceTypeAliasDialog.java
replace.all.x.occurrences=取代全部 {0} 個匹配項
1.occurrence=(1 個匹配項)
multi.occurrences=({0} 個匹配項)
replace.occurrences.available.from.companion.class=取代伴生類 {0} 中可用的符合項

# ## org/jetbrains/plugins/scala/lang/refactoring/introduceVariable/ScalaIntroduceVariableHandler.scala
cannot.refactor.not.expression.nor.type=應選擇表達式或類型元素
press.escape.to.remove.the.highlighting=按 esc 移除高亮顯示

# ## org/jetbrains/plugins/scala/lang/refactoring/memberPullUp/ScalaPullUpProcessor.scala
pull.up.members.from=向上拉取成員自
class.to.pull.up.members.to.class=要將成員向上拉取到 {0} 的類

# ## org/jetbrains/plugins/scala/lang/refactoring/move/ScalaMoveClassesOrPackagesHandler.scala
move.to.inner.is.not.supported.title=不支持重構
move.to.inner.is.not.supported=Scala 不支持將類移動到內部
move.with.companion=與伴生物件一起移動

# ## org/jetbrains/plugins/scala/lang/refactoring/move/members/ScalaMoveMemberHandler.scala
target.0.already.contains.definition.of.1=<b>{0}</b> 已包含成員 <b>{1}</b> 的定義

# ## org/jetbrains/plugins/scala/lang/refactoring/move/members/ScalaMoveMembersDialog.scala
move.members.source.title=移動此物件中的成員:
move.members.target.title=到物件:
move.members.object.name.or.qualified.name.expected=應為 Scala 物件的名稱或限定名稱
move.members.cannot.find.object=找不到具有此名稱的物件

# ## org/jetbrains/plugins/scala/lang/refactoring/move/members/ScalaMoveMembersHandler.scala
move.members=移動成員
move.members.supported.only.stable.objects=僅穩定的物件成員支援移動重構
move.members.not.supported.implicits=隱式定義不支持移動重構
move.members.not.supported.overridden=被覆寫的定義不支持移動重構

# ## org/jetbrains/plugins/scala/lang/refactoring/rename/RenameScalaClassProcessor.scala
rename.companion.module=重命名伴生 {0}

# ## org/jetbrains/plugins/scala/lang/refactoring/rename/RenameScalaMethodProcessor.scala
rename.getters.and.setters.title=函數有同名的 getter 或 setter。是否也對它們進行重命名?

# ## org/jetbrains/plugins/scala/lang/refactoring/rename/RenameSuperMembersUtil.scala
rename.all.base.members=重命名所有基本成員
rename.base.member=重命名基本成員
rename.only.current.member=僅重命名當前成員
rename.has.multiple.base.members={0} 有多個基本成員
rename.only.in=僅在 {0} {1} 中重命名
name.implements.member.of.qualname={0} 實作 {1} 的成員
name.overrides.member.of.qualname={0} 覆寫 {1} 的成員

# ## org/jetbrains/plugins/scala/lang/refactoring/rename/inplace/ScalaInplaceRenameHandler.scala
rename.special.method.title=此方法無法重命名
rename.special.method.rename.class=重命名包含{0}
rename.cancel=取消
rename.aliased.title=不支持重命名 import 別名
rename.aliased.rename.actual=重命名實際元素

# ## org/jetbrains/plugins/scala/lang/refactoring/rename/inplace/ScalaMemberInplaceRenamer.scala
rename=重命名
could.not.perform.inplace.rename=無法執行就地重命名:\n要重命名的元素: {0} {1}\n替代: {2}\n環繞文字游標: {3}

# ## org/jetbrains/plugins/scala/lang/refactoring/ui/ScalaMemberInfoBase.scala
presentable.definition.unnamed=未命名
presentable.type.unnamed=未命名類型

# ## org/jetbrains/plugins/scala/lang/refactoring/util/ScalaRefactoringUtil.scala
only.for.scala=這僅適用於 scala 檔案
cannot.refactor.constr.expression=所選塊不應顯示為構造函數表達式
cannot.refactor.under.generic.call=泛型調用中不支持重構
cannot.refactor.arg.in.self.invocation.of.constructor=構造函數主體中的自調用實參不支持重構
cannot.refactor.named.arg=命名實參不支持重構
cannot.refactor.literal.pattern=文字模式不支持重構
cannot.refactor.class.parameter.top.level=頂層類的參數不支持重構
cannot.refactor.interpolated.string.prefix=插值字串前綴不支持重構
cannot.refactor.self.invocation=輔助構造函數中的構造函數調用不支持重構
refactoring.is.not.supported.in.guard=臨界中不支持重構，它很可能破壞程式碼結構
file.is.not.writable=檔案沒有寫入權限
cannot.extract.empty.message=重構選擇錯誤。應為完整表達式或語句的數量。
cannot.extract.self.invocation=無法提取自我調用。
cannot.extract.used.type.definition=不支持重構: 選區內的類型定義在所選程式碼段外部使用
choose.expression.for=選擇 {0} 的表達式
choose.type.element.for=選擇 {0} 的類型元素

# ## org/jetbrains/plugins/scala/lang/refactoring/util/ScalaTypeValidator.scala
introduced.typeAlias.will.conflict.with.type.name=引入的類型別名與類型名稱衝突: {0}
introduced.typeAlias.will.conflict.with.class.name=引入的類型別名與類名衝突: {0}

# ## org/jetbrains/plugins/scala/lang/refactoring/util/ScalaVariableValidator.scala
introduced.variable.will.conflict.with.local=引入的變數與局部變數衝突(或可能被其隱藏): {0}
introduced.variable.will.conflict.with.parameter=引入的變數與參數衝突(或可能被其隱藏): {0}
introduced.variable.will.conflict.with.field=引入的變數將與沒有參數的欄位或方法衝突(或可能被其隱藏): {0}
introduced.variable.will.conflict.with.class.parameter=引入的變數與類參數衝突(或可能被其隱藏): {0}

# ## org/jetbrains/plugins/scala/lang/scaladoc/generate/ScaladocAction.scala
generate.scaladoc=生成 Scaladoc
generate.scaladoc.action.text=生成 Scaladoc
generate.scaladoc.action.description=生成 scaladoc
scaladoc.noon=Scaladoc

# ## org/jetbrains/plugins/scala/lang/scaladoc/generate/ScaladocConsoleRunConfigurationForm.java
output.dir=輸出目錄
documentation.for.project={0} 文檔

# ## org/jetbrains/plugins/scala/lang/scaladoc/parser/parsing/MyScaladocParsing.scala
scaladoc.parsing.open.syntax.element=開啟語法元素
scaladoc.parsing.closing.link.tag.before.opening=結束鏈接標記在起始鏈接標記前面
scaladoc.parsing.closing.code.tag.before.opening=結束程式碼標記在起始程式碼標記前面
scaladoc.parsing.error.bad.token=錯誤: 錯誤令牌: {0}
scaladoc.parsing.header.closed.by.opening.new.one=標頭由起始新標頭結束
scaladoc.parsing.wiki.syntax.element.closed.by.message=Wiki 語法元素由 {0} 結束
scaladoc.parsing.wiki.syntax.closed.by.new.paragraph=新段落
scaladoc.parsing.wiki.syntax.closed.by.tag=標記
scaladoc.parsing.wiki.syntax.closed.by.inner.code.tag=內部程式碼標記
scaladoc.parsing.cross.tags=交叉標記
scaladoc.parsing.no.closing.element=無結束元素
scaladoc.parsing.unclosed.code.tag=未結束的程式碼標記
scaladoc.parsing.unexpected.end.of.tag.body=標記主體意外結束
scaladoc.parsing.inline.tag=內聯標記
scaladoc.parsing.missing.tag.param=缺少標記參數
scaladoc.parsing.unknown.tag=未知標記: {0}

# ## org/jetbrains/plugins/scala/lang/structureView/element/TypeAlias.scala
type.unnamed=類型未命名

# ## org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithBoldSurrounder.scala
bold.surrounder.template.description=粗體: '''' ''''

# ## org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithItalicSurrounder.scala
italic.surrounder.template.description=斜體: '' ''

# ## org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithMonospaceSurrounder.scala
monospace.surrounder.template.description=等寬: ` `

# ## org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithSubscriptSurrounder.scala
subscript.surrounder.template.description=下標: ,, ,,

# ## org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithSuperscriptSurrounder.scala
superscript.surrounder.template.description=上標: ^ ^

# ## org/jetbrains/plugins/scala/lang/surroundWith/surrounders/scaladoc/ScalaDocWithUnderlinedSurrounder.scala
underline.surrounder.template.description=下劃線: __ __

# ## org/jetbrains/plugins/scala/lang/transformation/DesugarCodeAction.scala
desugar.scala.code.in.scope=Scala程式碼脫糖({0})
scope.selection=選區
scope.file=檔案
desugar.scala.code.action.text=Scala 程式碼脫糖…
desugar.scala.code.action.description=Scala 程式碼脫糖(所選部分/整個檔案)

# ## org/jetbrains/plugins/scala/lang/transformation/SelectionDialog.scala
column.enabled=已啟用
column.transformation=轉換
desugar.group.method.invocations=方法調用
desugar.expand.apply.call=展開“apply”調用
desugar.expand.update.call=展開“update”調用
desugar.expand.unary.call=展開一元調用
desugar.expand.property.setter.call=展開屬性 setter 調用
desugar.expand.assignment.call=展開賦值調用
desugar.expand.dynamic.call=展開動態調用
desugar.canonize.infix.call=規范化 infix 調用
desugar.canonize.postfix.call=規范化後綴調用
desugar.canonize.arity.0.call=規范化 arity-0 調用
desugar.canonize.block.argument=規范化塊參數
desugar.expand.auto.tupling=展開自動編制元組
desugar.expand.vararg.argument=展開 vararg 實參
desugar.inscribe.default.arguments=寫入預設實參
desugar.expand.to.equals.call=將“==”展開為“equals”調用
desugar.group.type.annotations=類型註解
desugar.value.definition=值定義
desugar.variable.definition=變數定義
desugar.method.definition=方法定義
desugar.function.parameter=函數參數
desugar.underscore.parameter=為參數加下劃線
desugar.reference.pattern=引用模式
desugar.type.parameters=類型參數
desugar.group.types=類型
desugar.expand.function.type=展開函數類型
desugar.expand.tuple.type=展開元組類型
desugar.expand.type.alias=展開類型別名
desugar.expand.context.bound=展開上下文邊界
desugar.expand.view.bound=展開檢視邊界
desugar.substitute.anyref=取代 AnyRef
desugar.group.implicits=隱式
desugar.expand.implicit.conversion=展開隱式轉換
desugar.inscribe.implicit.parameters=寫入隱式參數
desugar.group.functions=函數
desugar.expand.placeholder.syntax=展開佔位符語法
desugar.expand.eta.expansion=展開 eta 擴展
desugar.make.eta.expansion.explicit=使 eta 擴展為顯式
desugar.expand.single.abstract.methods=擴展單一抽象方法
desugar.expand.function.instantiation=展開函數實例化
desugar.group.expressions=表達式
desugar.expand.for.comprehensions=展開 for 推導式
desugar.expand.string.interpolation=展開字串插值
desugar.expand.tuple.instantiation=展開元組實例化
desugar.group.declarations=宣告
desugar.expand.procedure.syntax=展開過程語法
desugar.make.method.return.expressions.explicit=使方法 return 表達式為顯式
desugar.add.explicit.override.modifier=添加顯式“override”修飾符
desugar.replace.underscore.section.with.default.value=將下劃線部分取代為預設值
desugar.expand.property.declaration=展開屬性宣告
desugar.expand.property.definition=展開屬性定義
desugar.convert.implicit.class.to.class.and.function=將隱式類轉換為類和函數
desugar.group.references=引用
desugar.expand.wildcard.import=展開萬用字元匯入
desugar.fully.qualify.import.expression=完全限定匯入表達式
desugar.partially.qualify.simple.reference=部分限定簡單引用
desugar.fully.qualify.reference=完全限定引用
desugar.group.general=一般
desugar.append.semicolon=附加分號
desugar.inscribe.explicit.braces=記錄顯式大括號
desugar.enforce.parentheses.in.constructor.invocation=在構造函數調用中強制括號
desugar.convert.parentheses.to.braces.in.for.comprehensions=為推導式將括號轉換為大括號
desugar.expand.macro=擴展巨集

# ## org/jetbrains/plugins/scala/overrideImplement/ScalaMemberChooser.scala
specify.return.type.explicitly=指定類型(&T)
add.override.modifier=插入 "override"(&O)
copy.scaladoc=複製 ScalaDoc(&S)

# ## org/jetbrains/plugins/scala/overrideImplement/ScalaOIUtil.scala
select.method.override=選擇要覆寫的成員
select.method.implement=選擇要實作的成員
action.implement.method=實作方法
action.override.method=覆寫方法

# ## org/jetbrains/plugins/scala/project/ScalaLibraryType.scala
library.type.scala.sdk=Scala SDK

# ## org/jetbrains/plugins/scala/project/Versions.scala
title.fetching.available.this.versions=正在提取可用的 {0} 版本

# ## org/jetbrains/plugins/scala/project/converter/ScalaProjectConverterProvider.scala
scala.facets.will.be.converted.to.scala.sdks=Scala facet 將被轉換為 Scala SDK

# ## org/jetbrains/plugins/scala/project/external/ScalaAbstractProjectDataService.scala
scala.project.data.service.scalaLibraryNotFound=無法為模組 ''{0}'' 設定 Scala SDK (找不到模組 ''{0}'' 的專案 Scala 庫 {1})

# ## org/jetbrains/plugins/scala/project/notification/AbstractNotificationProvider.scala
setup.kittitle=設定 {0}

# ## org/jetbrains/plugins/scala/project/notification/SetupJdkNotificationProvider.scala
project.jdk.is.not.defined=未定義專案 JDK
kit.title.jdk=JDK

# ## org/jetbrains/plugins/scala/project/notification/SetupScalaSdkNotificationProvider.scala
sdk.title=Scala SDK
no.kittitle.in.module=模組中沒有 {0}

# ## org/jetbrains/plugins/scala/project/notification/source/AttachSourcesUtil.java
module.libraries.attach.sources.immediately.button=附加源…
multiple.libraries.contain.file="多個庫包含檔案。<br>選擇要附加原始碼的庫。"

# ## org/jetbrains/plugins/scala/project/notification/source/ScalaAttachSourcesNotificationProvider.scala
library.sources.not.found=找不到原始碼
library.sources.not.attached=未附加原始碼
cannot.find.library.for=找不到 {0} 的庫
cannot.find.library.error.title=錯誤

# ## org/jetbrains/plugins/scala/project/sdkdetect/ScalaSdkProvider.scala
sdk.scan.title=正在定位 Scala SDK: {0}

# ## org/jetbrains/plugins/scala/project/sdkdetect/repository/BrewDetector.scala
brew.packages=Brew 軟體套件

# ## org/jetbrains/plugins/scala/project/sdkdetect/repository/CoursierDetector.scala
coursier.v1.cache=Coursier v1 快取

# ## org/jetbrains/plugins/scala/project/sdkdetect/repository/IvyDetector.scala
ivy2.cache=Ivy2 快取

# ## org/jetbrains/plugins/scala/project/sdkdetect/repository/MavenDetector.scala
maven.local.repo=Maven 本地儲存庫

# ## org/jetbrains/plugins/scala/project/sdkdetect/repository/ProjectLocalDetector.scala
local.project.libraries=本地專案庫

# ## org/jetbrains/plugins/scala/project/sdkdetect/repository/SdkmanDetector.scala
sdkman=SDKMAN!

# ## org/jetbrains/plugins/scala/project/sdkdetect/repository/SystemDetector.scala
system.wide.scala=系統範圍 Scala

# ## org/jetbrains/plugins/scala/project/sdkdetect/repository/package.scala
unresolved.artifact=未解析的工件: {0}
ambiguous.artifact.resolved=解析了模糊的工件: {0}
unknown.resolve.issues=未知的解析問題: {0}
unknown.exception=未知異常: {0}

# ## org/jetbrains/plugins/scala/project/settings/ScalaCompilerConfigurable.scala
scala.compiler=Scala 編譯器

# ## org/jetbrains/plugins/scala/project/settings/ScalaCompilerConfigurationPanel.form
# Scala compiler settings UI
incrementality.type=遞增類型(&I):

# ## org/jetbrains/plugins/scala/project/settings/ScalaCompilerProfilesPanel.scala
scala.compiler.profiles.panel.profile.name=設定文件名稱
scala.compiler.profiles.panel.move.to=移動到
scala.compiler.profiles.panel.create.new.profile=創建新的設定檔案
scala.compiler.profiles.panel.profile.should.not.be.empty=設定文件名稱不應為空
scala.compiler.profiles.panel.profile.already.exists=設定檔案 {0} 已存在

# ## org/jetbrains/plugins/scala/project/settings/ScalaCompilerSettingsPanel.form
unchecked.warnings=未檢查的警告(&U)
unchecked.warnings.tooltip=生成的程式碼取決於假設時，啟用其他警告。
deprecation.warnings=棄用警告(&D)
deprecation.warnings.tooltip=發出棄用 API 用法的警告和位置。
feature.dynamics=動態(&D)
feature.existential.types=存在類型(&E)
explain.type.errors=解釋類型錯誤(&E)
explain.type.errors.tooltip=更詳細地解釋類型錯誤
feature.warnings=功能警告(&F)
feature.warnings.tooltip=發出語言功能警告。
feature.higher.kinded.types=高階類型(&H)
feature.implicit.conversions=隱式轉換(&I)
feature.macros=巨集(&M)
optimise.bytecode=最佳化字節碼(慎用*)(&O)
optimise.bytecode.tooltip=通過對程序套用最佳化來更快地生成字節碼。可能會觸發各種編譯問題。慎用。
feature.postfix.notation=後綴運算符表示法(&P)
feature.reflective.calls=反射調用(&R)
additional.compiler.options=其他編譯器選項(&O):
compile.order=編譯順序(&O):
compiler.plugins=編譯器延伸模組
debugging.info.level=偵錯資訊級別(&L):
feature.experimental.features=實驗性功能(&X)
enable.continuations=啟用繼續(&C)
enable.specialization=啟用專用化(&S)
enable.specialization.tooltip=遵循 @specialize 註解
enable.warnings=啟用警告(&W)
enable.warnings.tooltip=生成警告
features=功能
options=選項

# ## org/jetbrains/plugins/scala/project/settings/ScalaCompilerSettingsPanel.java
compile.order.mixed=混合
compile.order.java.then.scala=先 Java，後 Scala
compile.order.scala.then.java=先 Scala，後 Java
debug.info.level.none=無
debug.info.level.source=原始碼檔案特性
debug.info.level.source.and.line.number=原始碼和行號資訊
debug.info.level.source.line.number.and.local.variable=原始碼、行號和局部變數資訊
debug.info.level.complete.no.tail.call.optimization=完整，無尾調用最佳化

# ## org/jetbrains/plugins/scala/project/template/ScalaProjectTemplate.scala
idea.based.scala.project=基於 IDEA 的 Scala 專案
module.with.a.scala.sdk=包含 Scala SDK 的模組

# ## org/jetbrains/plugins/scala/project/template/ScalaSDKStepLike.scala
package.prefix.label=軟體套件前綴:
package.prefix.example=例如 ''org.example.application''
package.prefix.help=如果軟體套件前綴為 <code>org.example.application</code>，源目錄中的 <code>PATH</code> 意味著 <code>org/example/application/PATH</code>，所以不必創建顯式 <code>org</code>、<code>example</code> 和 <code>application</code> 子目錄。

# ## org/jetbrains/plugins/scala/project/template/ScalaVersionDownloadingDialog.scala
title.download=下載
title.error.downloading.scala.libraries=下載 Scala 庫時出錯
no.versions.available.for.download=沒有可供下載的版本
downloading.scala.version=正在下載 Scala {0}
error.downloading.scala.version=下載 Scala {0} 時出錯
invalid.scala.version.format=無效的 Scala 版本格式: {0}

# ## org/jetbrains/plugins/scala/project/template/SdkSelectionDialogWrapper.scala
sdk.create.select.files=選擇適用於新 Scala SDK 的 JAR
scala.sdk.selection.button.download=下載…
scala.sdk.selection.button.browse=瀏覽…
scala.sdk.component.name.compiler.classpath=編譯器類路徑
scala.sdk.component.name.library=庫
scala.sdk.component.name.library.source=庫原始碼
scala.sdk.component.name.library.scaladoc=庫 scaladoc
# {0} - component name
scala.sdk.descriptor.contains.duplicated.files=Scala SDK 描述符包含重複的 {0} 檔案:

# ## org/jetbrains/plugins/scala/project/template/SdkTableModel.scala
sdk.table.model.location=位置
sdk.table.model.version=版本
sdk.table.model.sources=原始碼
sdk.table.model.docs=文檔

# ## org/jetbrains/plugins/scala/project/template/sdk_browse/ScalaSdkFilesChooserDescriptor.scala
title.scala.sdk.files=Scala SDK 檔案
choose.either.a.scala.sdk.directory.or.scala.jar.files=選擇 Scala SDK 目錄或 Scala jar 檔案(允許: 二進制、原始碼、文檔)

# ## org/jetbrains/plugins/scala/runner/ScalaApplicationConfigurationExtension.scala
no.program.arguments=無程序實參

# ## org/jetbrains/plugins/scala/runner/view/ScalaMainMethodParametersTable.scala
main.method.parameters.table.column.title.name=名稱
main.method.parameters.table.column.title.type=類型
main.method.parameters.table.column.title.value=值

# ## org/jetbrains/plugins/scala/runner/view/ScalaProvideMainMethodParametersDialog.scala
provide.program.arguments=提供程序實參

# ## org/jetbrains/plugins/scala/settings/ScalaEditorSmartKeysConfigurable.scala
indent.pasted.lines.at.caret=在文字游標處縮排貼上的行
insert.pair.multiline.quotes=為多行字串插入成對引號
wrap.single.expression.body=鍵入 '{' 後，使用右大括號包裝單個表達式主體
delete.closing.brace=刪除 '{' 後刪除右大括號
upgrade.to.interpolated=鍵入 ''${'' 後，將簡單字串升級為插值字串
insert.block.braces.automatically.based.on.indentation=自動添加大括號
insert.block.braces.automatically.based.on.indentation.tooltip=在編輯程式碼時，當單行塊變為多行塊時添加大括號
remove.block.braces.automatically.based.on.indentation=自動移除大括號
remove.block.braces.automatically.based.on.indentation.tooltip=在編輯程式碼時，當多行塊變為單行塊時刪除大括號
control.curly.braces.based.on.line.indents=根據縮排控制大括號:

# ## org/jetbrains/plugins/scala/settings/ScalaProjectSettings.java
scala.project.settings=Scala 專案設定

# ## org/jetbrains/plugins/scala/settings/ScalaProjectSettingsPanel.form
scala.project.settings.form.tabs.editor=編輯器
scala.project.settings.form.tabs.project.view=專案檢視
scala.project.settings.form.tabs.performance=性能
scala.project.settings.form.tabs.worksheet=工作表
scala.project.settings.form.tabs.base.packages=基礎軟體套件
scala.project.settings.form.base.package.inherit=繼承自源資料夾的軟體套件前綴
scala.project.settings.form.base.package.custom=使用自訂:
scala.project.settings.form.tabs.misc=雜項
scala.project.settings.form.tabs.updates=更新
scala.project.settings.form.tabs.extensions=擴展
scala.project.settings.form.alias.export.semantics=scala 和 scala.Predef 中的別名為:
scala.project.settings.form.collection.type.highlighting.option=集合類型高亮顯示:
scala.project.settings.form.sbt.index.ivy2.mode=本地 ivy2 快取索引模式
scala.project.settings.form.sbt.index.ivy2.mode.hint=禁用 - 完全無索引\n元資料 - 僅索引庫名稱和版本，用於 SBT 檔案依賴項補全\n類 - 也索引快取中的類名，由“添加 sbt 依賴項”快速修復使用
scala.project.settings.form.scala.meta.settings.annot212=執行 scala.meta 程序
scala.project.settings.form.scala.meta.settings.annot212.tooltip=由於二進制檔案不相容，2.12 模組中的註解必須使用基於字串的非常緩慢的序列化和重新解析。這可能會嚴重影響整體性能。
scala.project.settings.form.scala.meta.settings.modeOptions.tooltip=已啟用 - 在類型推斷期間執行所有元程序\n已禁用 - 在類型推斷期間跳過元程序\n手動 - 僅在手動擴展時執行元程序
scala.project.settings.form.scala.meta.settings.trimBodies.caption=修剪方法體由 scala.meta 擴展
scala.project.settings.form.scala.meta.settings.trimBodies.tooltip=依賴所生成方法的顯式返回類型(主體取代為 ???)。通過跳過方法體類型檢查可加快類型推斷。
scala.project.settings.form.show.type.info.on.mouse.hover=經過此時間後在滑鼠懸停時顯示類型資訊(ms)
scala.project.settings.form.error.highlighting=錯誤高亮顯示:
scala.project.settings.form.highlighting=高亮顯示
scala.project.settings.form.highlight.implicit.conversions=高亮顯示隱式轉換
scala.project.settings.form.show.hints.if.no.implicit.arguments.found=找不到隱式實參時顯示提示
scala.project.settings.form.show.hints.if.ambiguous.implicit.arguments.found=找到模糊的隱式參數時顯示提示
scala.project.settings.form.highlight.arguments.to.by.name.parameters=高亮顯示傳名參數的實參
scala.project.settings.form.include.block.expressions=包含塊表達式
scala.project.settings.form.include.literals=包含文字
scala.project.settings.form.custom.scalatest.keywords.highlighting=自訂 scalaTest 關鍵字高亮顯示
scala.project.settings.form.autocomplete=自動補全
scala.project.settings.form.ahead.of.time.completion=提前補全(參數和變數名稱)
scala.project.settings.form.use.scala.classes.priority.over.java=Scala 類的使用優先級高於 Java 類
scala.project.settings.form.code.conversion=程式碼轉換
scala.project.settings.form.convert.java.code.to.scala.on.copy.paste=複製貼上時將 Java 程式碼轉換為 Scala
scala.project.settings.form.automatically.convert.to.scala.code.without.dialog=貼上時不顯示對話框，並自動轉換為 Scala 程式碼
scala.project.settings.form.add.override.keyword.to.method.implementation=向方法實作中添加覆寫關鍵字
scala.project.settings.form.group.package.object.with.package=使用軟體套件對軟體套件物件分組(&G)
scala.project.settings.form.highlight.nodes.with.errors=高亮顯示有錯誤的節點(&H)
scala.project.settings.form.implicit.parameters.search.depth=隱式參數搜尋深度(若為無，則搜尋深度為 -1):
scala.project.settings.form.search.all.symbols=搜尋所有符號(包括局部符號)
scala.project.settings.form.disable.parsing.of.documentation.comments=禁用文檔註釋解析。對於極大的檔案，可以提高編輯器性能。(SCL-2900)
scala.project.settings.form.disable.language.injection.in.scala.files=禁用 Scala 檔案中的語言注入(注入的語言可能會對自動彈出視窗補全凍結鍵入)
scala.project.settings.form.dont.cache.compound.types=不快取複合類型(在 GC 中出現嚴重停頓的情況下使用)
scala.project.settings.form.treat.sc.files.as=將 .sc 檔案視為:
scala.project.settings.form.output.cutoff.limit=輸出截止限制:
scala.project.settings.form.output.cutoff.limit.units=行
scala.project.settings.form.delay.before.auto.run=自動執行前延遲:
scala.project.settings.form.delay.before.auto.run.units=毫秒
scala.project.settings.form.run.worksheet.in.the.compiler.process=在編譯器過程中執行工作表(僅限普通模式)
scala.project.settings.form.use.eclipse.compatibility.mode=使用“eclipse 相容”模式
scala.project.settings.form.treat.scala.scratch.files.as.worksheet.files=將 Scala 臨時檔案視為工作表檔案
scala.project.settings.form.collapse.long.output.by.default=預設摺疊長輸出
scala.project.settings.form.scalatest.default.super.class=ScalaTest 預設超類:
scala.project.settings.form.trailing.commas=尾隨逗號:
scala.project.settings.form.plugin.update.channel=更新通道:
scala.project.settings.form.check.for.updates=立即檢查
scala.project.settings.form.info=您可以始終選擇“穩定版本”或“搶先體驗計劃”以還原為更穩定的版本。

# ## org/jetbrains/plugins/scala/settings/ScalaProjectSettingsPanel.java
scala.collection.highlighting.type.none=無
scala.collection.highlighting.type.only.non.qualified=僅非限定
scala.collection.highlighting.type.all=所有
scala.plugin.chanel.nightly=Nightly 版本
scala.plugin.chanel.eap=搶先體驗計劃
scala.plugin.chanel.release=穩定版本
scala.project.settings.form.alias.definition=定義
scala.project.settings.form.alias.export=匯出
scala.project.settings.form.tabs.base.package=基礎軟體套件
scala.meta.mode.enabled=已啟用
scala.meta.mode.disabled=已禁用
scala.meta.mode.manual=手動
ivy2.indexing.mode.disabled=已禁用
ivy2.indexing.mode.metadata=元資料
ivy2.indexing.mode.classes=類
trailing.commas.mode.enabled=已啟用
trailing.commas.mode.disabled=已禁用
trailing.commas.mode.auto=自動
type.checker.built.in=內建
type.checker.compiler=編譯器
type.checker.help=<html><strong>內建</strong>: 更多功能，更快的反饋，輕量化。發現複雜程式碼中可能的虛假錯誤。<br><br><strong>編譯器</strong>: 更精確。更慢，使用更多資源，但不支持類型差異、快速修復、檢查等功能。<br><br>除非特定程式碼庫中有許多虛假錯誤，否則建議使用內建類型檢查器。</html>
script.file.mode.always.worksheet=始終為工作表
script.file.mode.ammonite.in.test.sources.otherwise.worksheet=測試原始碼中的 Ammonite，否則為工作表
script.file.mode.always.ammonite=始終選擇 Ammonite
invalid.update.channel=更新通道無效
changes.in.scalatest.highlighting.will.be.processed...=只有在新高亮顯示的檔案上，ScalaTest 中高亮顯示的變更才會正確處理。為了獲得最佳體驗，請重新啟動 Intellij IDEA
base.package.help=<html>如果基礎軟體套件為 <code>org.example.application</code>，軟體套件 <code>org.example.application.NAME</code> 應定義為<br><code>package org.example.application</code><br><code>package NAME</code></html>

# ## org/jetbrains/plugins/scala/testDiscovery/ScalaAffectedTestsInChangeListPainter.java
show.affected.tests.scala=顯示受影響的測試(scala)

# ## org/jetbrains/plugins/scala/testDiscovery/actions/DiscoveredTestsTree.java
no.tests.captured=未捕獲 {0} 的任何測試

# ## org/jetbrains/plugins/scala/testDiscovery/actions/ScalaShowAffectedTestsAction.java
show.affected.tests.action.text=顯示受影響的測試(Scala)
show.affected.tests.action.description=顯示受影響的測試(Scala)
run.all.affected.tests.scala=執行所有受影響的測試(Scala)
affected.tests.title.empty.selection=空選擇
affected.tests.title.two.tests={0} 和 {1}
affected.tests.title.more.than.two={0} 等
selected.changes=選定變更
tests.for.title={0} 的測試
open.find.usages.tool.window=開啟尋找用法工具視窗{0}

# ## org/jetbrains/plugins/scala/testingSupport/test/AbstractTestRunConfiguration.scala
test.run.config.multiple.suite.traits.detected=檢測到多個套件特徵: {0}
test.framework.is.not.specified=未指定 {0}

# ## org/jetbrains/plugins/scala/testingSupport/test/MyInheritorChooser.scala
test.config.choose.executable.classes.to.run.test=選擇用於執行 {0} 的可執行類

# ## org/jetbrains/plugins/scala/testingSupport/test/ScalaTestFrameworkCommandLineStateLike.scala
test.run.config.module.is.not.specified=未指定模組

# ## org/jetbrains/plugins/scala/testingSupport/test/munit/MUnitCommandLineState.scala
munit.command.line.state.no.tests.found=找不到測試
ensure.junit.plugin.is.enabled=請確保 JUnit 延伸模組已啟用

# ## org/jetbrains/plugins/scala/testingSupport/test/munit/MUnitConfigurationType.scala
munit.config.display.name=MUnit
munit.config.description=MUnit 測試框架執行設定

# ## org/jetbrains/plugins/scala/testingSupport/test/scalatest/ScalaTestConfigurationProducer.scala
test.in.scope.scalatest.presentable.text=''{0}'' 中的 ScalaTest

# ## org/jetbrains/plugins/scala/testingSupport/test/scalatest/ScalaTestConfigurationType.scala
scalatest.config.display.name=ScalaTest
scalatest.config.description=ScalaTest 測試框架執行設定

# ## org/jetbrains/plugins/scala/testingSupport/test/specs2/Specs2ConfigurationProducer.scala
test.in.scope.specs2.presentable.text=''{0}'' 中的 Specs2

# ## org/jetbrains/plugins/scala/testingSupport/test/specs2/Specs2ConfigurationType.scala
specs2.config.display.name=Specs2
specs2.config.description=Specs2 測試框架執行設定

# ## org/jetbrains/plugins/scala/testingSupport/test/structureView/TestNodeProvider.scala
test.node.provider.show.scala.tests=顯示 scala 測試

# ## org/jetbrains/plugins/scala/testingSupport/test/testdata/AllInPackageTestData.scala
test.run.config.test.package.not.found=找不到測試軟體套件: {0}
test.config.package.does.not.exist=軟體套件不存在
test.config.can.not.run.while.indexing.no.class.names.memorized.from.previous.iterations=編制索引時無法執行: 以前的迭代中沒有記住類名。
test.config.did.not.find.suite.classes.in.package=在軟體套件 {0} 中找不到套件類

# ## org/jetbrains/plugins/scala/testingSupport/test/testdata/ClassTestData.scala
test.run.config.test.class.not.found=找不到測試類: {0}
test.config.test.class.is.not.specified=未指定測試類
test.config.test.class.not.found.in.module=在模組 ''{1}'' 中找不到測試類 ''{0}''
test.config.no.suite.class.is.found.for.class.in.module=在模組 ''{1}'' 中找不到類 ''{0}'' 的套件類
test.config.class.is.not.inheritor.of.suite.trait=類 ''{0}'' 不是套件特徵的繼承者
test.config.clazz.is.not.a.valid.test.suite={0} 不是有效的測試套件

# ## org/jetbrains/plugins/scala/testingSupport/test/testdata/RegexpTestData.scala
test.config.failed.to.compile.pattern=無法編譯模式 {0}
test.config.no.patterns.detected=未檢測到模式
test.config.cant.run.while.indexing.no.class.names.memorized.from.previous.iterations=編制索引時無法執行: 以前的迭代中沒有記住類名。

# ## org/jetbrains/plugins/scala/testingSupport/test/testdata/SingleTestData.scala
test.config.test.name.is.not.specified=未指定測試名稱
test.config.multiple.classes.specified.for.single.test.run=為單次執行的測試指定了多個類

# ## org/jetbrains/plugins/scala/testingSupport/test/ui/RegexpPanel.scala
test.run.config.for.class.pattern=類模式
test.run.config.test.pattern=測試模式

# ## org/jetbrains/plugins/scala/testingSupport/test/ui/ScalaTestRunLineMarkerProvider.scala
scalatest.gutter.run.test=執行測試

# ## org/jetbrains/plugins/scala/testingSupport/test/ui/TestRunConfigurationForm.scala
test.run.config.test.kind=測試類型(&T):
test.run.config.test.class=測試類(&C):
test.run.config.test.name=測試名稱(&N):
test.run.config.regular.expressions=正則表達式(&X):
test.run.config.test.package=測試軟體套件(&G):
test.run.config.search.for.tests=搜尋測試:
test.run.config.use.sbt=使用 sbt(&T)
test.run.config.use.ui.with.sbt=對 sbt 使用 UI
test.run.config.print.information.messages.to.console=將訊息列印到主控台(&P)
test.run.config.choose.test.class=選擇測試類
test.run.config.test.kind.all.in.package=軟體套件中的所有
test.run.config.test.kind.class=類
test.run.config.test.kind.test.name=測試名稱
test.run.config.test.kind.regular.expression=正則表達式
test.run.config.search.scope.in.whole.project=在整個專案中
test.run.config.search.scope.in.single.module=在單個模組中
test.run.config.search.scope.across.module.dependencies=整個模組依賴項

# ## org/jetbrains/plugins/scala/testingSupport/test/utest/UTestConfigurationProducer.scala
test.in.scope.utest.presentable.text=''{0}'' 中的 UTest

# ## org/jetbrains/plugins/scala/testingSupport/test/utest/UTestConfigurationType.scala
utest.config.display.name=utest
utest.config.description=utest 測試框架執行設定

# ## org/jetbrains/plugins/scala/util/NotificationUtil.scala
default.notification.title=警告

# ## <unused>
friendly.collection.debug.start.index=集合起始索引
friendly.collection.debug.end.index=集合結束索引
friendly.collection.do.not.display.streams=不擴展流和檢視
scala.non.strict.collection.renderer=Scala 非嚴格集合
scala.plugin.update.failed=Scala 延伸模組更新失敗
switch.idea.to.eap.question=您的 IDEA 已過時，無法對 {0} 分支使用。<br/>要將 IDEA 通道切換為 EAP 嗎?
switch.yes=是
switch.not.now=以後再說
switch.ignore.this.update=忽略此更新
not.all.type.parameters.are.defined=未定義一部分類型參數。typeargs=[{0}] 和 classTypeParams=[{1}]
expected.with=應為 with
expected.parameter.clause.for.extension.method=預期擴展方法的參數子句
scgivenaliasimpl.returntype.not.yet.implemented=ScGivenAliasImpl.returnType: 尚未實作
expected.indented.package.statement=應為縮排的 package 語句
expected.indented.template.body=預期縮排模板正文
type.declaration.expected=應為類型宣告
advanced.settings=進階設定
match.type.expected=應為 match 類型
scala.3.disclaimer=Scala 3 免責宣告
conversion.is.not.available.in.it.s.own.definition=轉換定義中無法進行轉換
element.has.incompatible.type.parameter.bounds.for.type={0} 有對於 {1} 不相容的類型參數綁定
type.does.not.conform.to.type={0} 不符合 {1}
import.implicitInstance.chooser.title=選擇要匯入的隱式實例
family.name.search.implicit.instances=搜尋隱式實例
search.implicit.instances.for=搜尋 {0} 的隱式實例
choose.type.to.search=選擇要搜尋的類型
applicable.implicits.not.found=找不到適用的隱式定義
test.run.config.choose.working.directory=選擇工作目錄
sdk.build.title=正在建置 SDK
statement.expected=應為塊語句
star.expected=應為 ''*''
case.clauses.or.qualified.reference.expected=應為 case 子句或限定引用
annotation.expected=應為註解
simple.type.expected.requires=在 requires 塊中應為簡單類型
type.dcl.expected=應為類型宣告
block.expected=應為塊
type.tale.expected=簡單類型表中應有類型關鍵字
refined.type.expected=應為細化的類型
this.expected=應為 ''this'' 關鍵字
arg.expr.expected=應為實參表達式
# TODO unify type mismatch messages
expr.type.does.not.conform=表達式中的 {0} 類型不符合值宣告的類型
# TODO unify type mismatch messages
patt.type.does.not.conform.expr.type=模式 {0} 的預期類型與表達式類型 {1} 不符
title.cache.updating=正在更新快取
title.cache.creating=正在創建快取
title.cache.files.scanning=正在掃描檔案…
title.cache.files.parsing=正在解析新檔案…
title.please.wait=請稍候
title.cache.saving=正在儲存快取
title.cache.datafile.loading=正在載入快取
title.cache.files.removing=正在移除舊快取
title.cache.loading=正在載入快取
error.report.to.jetbrains.action=報告給 JetBrains
error.report.submit.label=<html>此錯誤報告將把 <b><a href="{1}{2}">{1}{2}</a></b> 處的<br>新 <b>JIRA</b> 問題 <br><b>''{0}''</b><br> 作為組件 <b>''{3}''</b> 進行創建。<br><br>請簡要描述該錯誤以及再現該問題的方式:</html>
error.report.submit.register.in.jira=<html><a href="{0}">註冊帳戶</a></html>
error.report.submit.new.issue.url=<html>您的問題已成功添加，請參閱 <br><a href="{0}">{0}</a></html>
error.report.submit.new.issue.title=問題已添加
error.report.wrong.login=用戶名或密碼無效。
error.report.canceled=已取消發送報告
error.report.error.creating.issue=創建新的 JIRA 問題時出錯
error.report.jira.issue=JetScala 問題 #{0}
error.report.dialog.title=提交錯誤
error.report.dialog.wrong.password.title=發送失敗
error.report.button.sendreport.caption=發送報告(&S)
error.report.button.cancel.caption=取消(&C)
error.report.form.not.jira=我沒有 JIRA 帳戶，以“JetScala 錯誤報告者”的名義創建問題(&I)
error.report.form.jira=我是 JIRA 使用者(&J)
error.report.form.jira.login=登錄(&L):
error.report.form.jira.password=密碼(&P):
error.report.form.jira.password.save=儲存密碼
repetitive.method.name.signature=重複的方法名稱/簽名
repetitive.method.name.signature.and.return.type=重複的方法名稱、簽名和返回類型
illegal.combination.of.modifiers=修飾符的組合非法
modifier.is.not.allowed.here.0=此處不允許使用修飾符 ''{0}''
illegal.combination.of.modifiers.abstract.and.final=修飾符 ''abstract'' 和 ''final'' 的組合非法
modifier.volatile.not.allowed.here=此處不允許使用修飾符 ''volatile''
modifier.transient.not.allowed.here=此處不允許使用修飾符 ''transient''
intarface.cannot.have.modifier.final=接口不能具有修飾符 ''final''
script.cannot.have.modifier.abstract=腳本不能具有修飾符 ''abstract''
script.cannot.have.modifier.native=腳本不能具有修飾符 ''native''
interface.must.have.no.static.method=接口不得有 static 方法
not.abstract.class.cannot.have.abstract.method=非 abstract 類不能有 abstract 方法
illegal.combination.of.modifiers.volatile.and.final=修飾符 ''volatile'' 和 ''final'' 的組合非法
variable.cannot.be.native=變數不能具有修飾符 ''native''
variable.cannot.be.abstract=變數不能具有修飾符 ''abstract''
not.abstract.class.cannot.have.method.without.body=非 abstract 類不能有無主體的方法
not.abstract.method.should.have.body=非 abstract 方法應有主體
cannot.create.class.error.text=無法創建類 ''{0}'': {1}
cannot.create.class.error.title=無法創建類
no.class.in.file.template=檔案模板中找不到類
interface.must.have.no.private.method=接口不得有私有方法
error.external=外部錯誤
Inner.methods.are.not.supported=不支持內部方法
final.class.cannot.be.extended=無法擴展 final 類
element.is.not.accessible=元素 {0} 對此位置具有私有存取權限
class.must.declared.abstract=類 ''{0}'' 必須宣告為 abstract 或實作繼承的 abstract 成員
object.must.implement=物件 ''{0}'' 必須實作未實作的方法
cannot.refactor.constructor.parameter.top.level=頂層類中的構造函數參數不支持重構
wrong.refactoring.context=當前上下文中不支持重構
operation.not.supported.in.current.block=當前塊中不支持運算
class.import.title=為類添加 import:
0.is.not.a.legal.scala.identifier=''{0}'' 不是合法的 scala 關鍵字
cannot.have.implicit.parameters.and.implicit.bounds=類型參數不能同時包含隱式參數和上下文邊界 `: ...'' 或檢視邊界 `<% ...''
block.must.end.result.expression=塊必須以結果表達式結尾
illegal.cyclic.reference=非法迴圈引用 ''{0}''
anonymous.class.must.declared.abstract=匿名類必須實作繼承的 abstract 成員
cyclic.reference.type=涉及類型 {0} 的迴圈引用非法
implicit.usage.tooltip=檢測到<html><body>隱式轉換 {0}(<b>{1}</b>): <b>{2}</b>
implicit.usage.message=檢測到隱式轉換 ''{0}({1}): {2}''。
suspicious.inference={0} 的推斷類型可疑。如果確實需要此類型，請對其進行顯式註解。
suspicious.newline=實參列表前面的換行符不推斷為分號。不妨考慮在方法名稱前使用 ''.''。
element.method=方法
label.method=方法 {0}
method.has.supers=方法 {0} 覆寫/實作某些基方法，是否也對其重命名?
remove.explicit.val=移除顯式 ''val''
maven.repository.presentable.name=Maven 儲存庫
config.display.name=設定
scala.facet.title=Scala(&L)
config.scala.libraries=設定 Scala 庫
scala.config.label=Scala 安裝目錄
scala.config.dscr=請指定 Scala 安裝目錄的路徑
scala.config.noscala.title=Scala 設定錯誤
scala.config.download.link=https://www.scala-lang.org/downloads/
scala.config.download.link.label=從這裡可以下載 Scala:
scala.config.compiler.library=Scala 編譯器庫(&I):
scala.config.sdk.library=Scala SDK 庫(&S):
scala.config.sdk.space.hint=必須使用檔案分隔符 - '';'' 分隔多個路徑
scala.config.take.compiler.from.settings=使用指定的 jar 中的 Scala 編譯器庫(&L)
scala.config.take.relative.path=使用指向專案根的相對路徑
error.scala.path.not.valid=Scala 路徑無效
scala.config.project.template.name=非 sbt
scala.config.project.template.description=用於開發 Scala 套用程序的模組
scala.config.project.settings.title=Scala 設定
scala.config.module.name=Scala 模組
scala.config.module.description=創建 Scala 模組
no.java.sdk=未設定 java SDK
cannot.compile.scala.files.no.facet=請將 Scala facet 附加到模組。
cannot.compile.scala.files.no.compiler=請指定 Scala facet 中的編譯器庫。
cannot.compile.scala.files.compiler.problem=請調整 Scala facet 中的編譯器庫: {0}。
cannot.compile.scala.files.no.sdk=請為模組 ''{0}'' 設定 Java SDK。
cannot.compile.scala.files.no.sdk.mult=請為模組 ''{0}'' 設定 Java SDK。
cannot.compile=無法編譯 Scala 檔案
debug.option=啟用偵錯堆疊跟踪
scalac.compiler.name=Scalac
javac.error.unknown.jdk.version=無法確定JDK的版本 {0}.\n更新JDK設定.
different.scala.sdk.in.modules=依賴模組必須具有相同的 Scala SDK 版本
scala.compiler.description=Scala 編譯器
jtype.is.not.found=無法編譯 Scala 檔案。\n找不到 ch.epfl.lamp.fjbg.JType 類。\n請將適當的 jar 附加到模組 ''{0}''。
scala.sdk.configuration=Scala SDK 設定
new.button.label=新建
scala.sdk.configuration.label=<html><b>Scala SDK: </b><br>選擇特定於此模組的 Scala SDK</html>
add.new.scala.lib=新建 Scala SDK
invalid.scala.sdk.path.text=指定的路徑錯誤
scala.sdk.combo.box.project.item=<無 Scala SDK>
no.scala.facet=應為 Scala facet
new.scala.facet.detected=檢測到 Scala facet
invalid.scala.sdk.path.message=Scala SDK 路徑無效
facet.create.lib.title=創建 Scala 庫
facet.create.project.lib=創建專案級 Scala 庫 ''{0}''(&P)
facet.create.application.lib=創建應用程式級 Scala 庫 ''{0}''(&A)
facet.setting.exclude.compiler.from.cp=從模組範圍中排除 Scala 編譯器庫(&P)
facet.setting.exclude.library.from.cp=從模組範圍中排除 Scala SDK 庫(&L)
file.template.group.title.scala=Scala
# class
newclass.dlg.prompt=輸入新 Scala 類的名稱
newclass.dlg.title=新建 Scala 類
newclass.command.name=創建 Scala 類
newclass.progress.text=正在創建 Scala 類 ''{0}''
# worksheet
newworksheet.dlg.prompt=輸入新 Scala 工作表的名稱
newworksheet.dlg.title=新建 Scala 工作表
newworksheet.menu.action.text=Scala 工作表
newworksheet.menu.action.description=創建新的 Scala 工作表
newworksheet.command.name=創建 Scala 工作表
newworksheet.progress.text=正在創建 Scala 工作表 ''{0}''
# object
newobject.dlg.prompt=輸入新 Scala 物件的名稱
newobject.dlg.title=新建 Scala 物件
newobject.menu.action.text=Scala 物件
newobject.menu.action.description=創建新的 Scala 物件
newobject.command.name=創建 Scala 物件
newobject.progress.text=正在創建 Scala 物件 ''{0}''
# trait
newtrait.dlg.prompt=輸入新 Scala 特徵的名稱
newtrait.dlg.title=新建 Scala 特徵
newtrait.menu.action.text=Scala 特徵
newtrait.menu.action.description=創建新的 Scala 特徵
newtrait.command.name=創建 Scala 特徵
newtrait.progress.text=正在創建 Scala 特徵 ''{0}''
scala.compiler.option.additional.command.line.parameters=Scala 編譯器的其他命令行參數
psi.decompiled.text.header=// 用於 Scala 語言的 IntelliJ API 反編譯器\n// 根據類檔案生成的存根源\n// 功能實作不可用
scala.compiler.heap.size=最大堆大小(MB):
scala.compiler.cmd.line.params=命令行參數
scala.compiler.use.deprecation=編譯 @&deprecated 註解
scala.compiler.scalac.first=先編譯 Scala 檔案(&S)
scala.compiler.show.unchecked=編譯 @unchecked 註解(&U)
scala.compiler.generate.no.warnings=不生成警告(&W)
scala.compiler.optimize=最佳化字節碼(&O)
scala.compiler.no.generics=禁止 Scala 泛型簽名(&G)
no.right.operand.found=找不到右側的操作數
cannot.resolve.infix.operator=無法解析中綴運算符
circular.dependency.detected=檢測到類型別名 ''{0}'' 的迴圈依賴關係
no.result.expression.found=找不到結果表達式
unreachable.expression=不可到達的語句
choose.inferred.or.super.type.popup.title=選擇類型
test.in.scope.specs.presentable.text=''{0}'' 中的規範
equals.between.inconvertible.types.display.name=不可轉換類型物件之間的相等測試
equals.between.inconvertible.types.description=檢測因操作數的靜態類型不可轉換而始終返回 false 的相等測試。
equals.between.inconvertible.types.problem.descriptor=在不可轉換類型 ''{0}'' 和 ''{1}'' 的物件之間的相等測試 #loc
find.usages.implementing.type.definition=實作類型定義
find.usages.companion.module=伴生模組用法
find.usages.instances.title=創建實例
introduce.typealias.search.companion=從伴生取代
introduce.typealias.search.inheritors=在繼承者中取代
introduce.field.choose.class=選擇用於引入欄位的類
extract.trait.name.not.specified=未指定特徵名稱
change.signature.not.supported.multiple.parameter.clauses=有多個參數子句的函數不支持更改簽名
change.signature.not.supported.constructors=構造函數不支持更改 Scala 簽名
parameter.not.from.function=根據參數而不是函數定義或函數表達式來評估
local.variable.from.anonymous.class=無法載入匿名類中的局部變數 {0}
invalid.expression.in.parentheses=圓括號中無效的表達式: {0}
formatted.interpolator.not.supported=Scala 2.11 不支持格式化字串插值器 f"..."
configure.type.aware.highlighting=為專案設定類型感知高亮顯示
vm.options=VM 選項:
console.arguments=控制實參:
working.directory=工作目錄:
use.classpath.and.sdk.of.module=使用模組的類路徑和 SDK:
test.run.config.sbt.runner.form.environment.variables=環境變數(&E)
scala.project.settings.form.compiler.highlighting=使用編譯器高亮顯示錯誤
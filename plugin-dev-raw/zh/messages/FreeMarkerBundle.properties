number=數字
identifier=標識符
filetype.ftl.description=FreeMarker 模板
directive.name.expected=應為指令名稱
unmatched.directive.end=指令結尾不匹配
expression.expected=應為表達式
attribute.name.expected=應為特性名稱
comment.end.expected=應為右側 '#comment' 標籤
closing.directive.expected.0=應為右側 {0} 指令
variable.name.expected=應為變量名稱
setting.name.expected=應為有效的設置名稱
no.matching.0.directive=沒有匹配的 {0} 指令
wellformedness.inspection.as.loop.variable.name.missing=缺少 'as' (循環變量名稱)
wellformedness.inspection.parent.list.of.the.items.must.not.have.as=#items 的父級 #list 不得包含 "as {0}" 形參

freemarker.inspections.group=FreeMarker
ftl.wellformedness.inspection=指令格式不正確
ftl.references.inspection=未解析的引用
ftl.calls.inspection=無效的調用指令
ftl.import.calls.inspection=未解析的外部調用
ftl.deprecated.builtins.inspection=內置已棄用
ftl.types.inspection=不正確的表達式類型
ftl.file.references.inspection=未解析的文件引用
else.should.finish.if=else 指令應當為 if 指令中的最後一項
namespace.expected=應為命名空間
error.cannot.resolve.variable.0=無法解析變量 ''{0}''
error.cannot.resolve.function.0=無法解析函數 ''{0}''
error.cannot.resolve.parameter.0.of.macro.1=無法解析宏 ''{1}'' 的形參 ''{0}''
error.cannot.resolve.field.of=無法解析類 ''{1}'' 的字段或屬性 ''{0}''
error.cannot.resolve.field=無法解析字段或屬性 ''{0}''
error.cannot.resolve.method.of=無法解析類 ''{1}'' 的方法 ''{0}''
error.cannot.resolve.method=無法解析方法 ''{0}''
error.cannot.resolve.macro=無法解析宏 ''{0}''
expression.should.have.numeric.type=表達式應為數值類型，實際為 ''{0}''
expression.unexpected.type=意外類型: ''{0}''
expression.should.have.scalar.type=表達式應為標量類型，實際為 ''{0}''
expression.should.have.array.or.collection.type=表達式應為數組或集合類型，實際為 ''{0}''
expression.should.have.hash.type=表達式應為哈希或 ''Map'' 類型，實際為 ''{0}''
expression.should.have.namespace.type=應為命名空間，實際為 ''{0}''
expression.should.have.node.type=應為節點類型，實際為 ''{0}''
expression.should.have.macro.type=應為宏類型，實際為 ''{0}''
expression.should.have.boolean.type=應為布爾類型，實際為 ''{0}''

invalid.ftl.file=不是 FreeMarker 文件
invalid.relative.path=相對路徑無效
absolute.refs.not.allowed=此處不允許絕對路徑引用
directory.expected=應為目錄

error.no.applicable.method={1} 中沒有適用於 {2} 的方法 ''{0}''
error.static.member.expected=應為 static 成員
quickfix.convert.to.instance.family=轉換為實例類型
quickfix.convert.to.instance=將 {0} 類型轉換為實例一
error.multiple.overloaded.methods=多個重載方法 {0}
ftl.should.start.file=#ftl 指令應出現在模板最開頭
default.value.should.occur.at.the.end=具有默認值的形參應出現在形參列表的末尾，應為 =
macro.function.nesting=#macro 和 #function 指令不應嵌套
unclosed.directive=未封閉指令
can.only.occur.inside=#{0} 只能出現在 #{1} 內部
can.only.occur.inside.or=#{0} 只能出現在 #{1} 或 #{2} 內部
wrong.closing.directive.name=閉合指令名稱錯誤
recover.once=#recover 指令只能出現一次
recover.inside.attempt=#recover 指令只能在 #attempt 內部發生
recover.expected=#attempt 內部應為 #recover 指令

add.implicit.variable.fix.name=在注釋中定義隱式變量
add.implicit.variable.fix.name.local=定義隱式變量(在當前文件中的注釋中)
add.implicit.variable.fix.name.module.wide=在外部定義隱式變量(全局)
add.implicit.variable.fix.name.external=在外部定義隱式變量(僅此文件)
add.implicit.toplevel.variable.fix.name=指定要從中提取頂層屬性和方法的類
add.implicit.toplevel.variable.fix.name.local=指定要從中獲取頂層屬性和方法的類(在當前文件中的注釋中)
add.implicit.toplevel.variable.fix.name.external=指定要從中提取頂層屬性和方法的類(外部)
choose.external.definitions.file=選擇外部隱式定義文件

create.macro.or.function.from.usage=根據用法創建宏或函數
create.macro.from.usage=根據用法創建宏 ''{0}''
define.implicit.macro.from.usage=定義隱式宏 ''{0}''
create.function.from.usage=根據用法創建函數 ''{0}''
define.implicit.function.from.usage=定義隱式函數 ''{0}''

create.dynamic.method.or.property=創建動態方法或屬性
create.dynamic.method=創建動態方法 ''{0}''

define.template.root.fix.name=定義模板根
define.template.root.fix.name.local=在當前文件的注釋中定義模板根
define.template.root.fix.name.module.wide=在注釋中定義模板根(全局)

variable.may.be.undefined=變量 ''{0}'' 可能未定義
undefined.mandatory.parameters=缺少必填形參: {0}
too.many.parameters=形參過多
type.mismatch=應為 ''{0}'' 類型，發現為 ''{0}''

change.macro.call.style.family=更改宏調用樣式
change.macro.call.style.to.named=將宏調用更改為命名樣式
change.macro.call.style.to.positinal=將宏調用更改為位置樣式

type.name.variable=變量
type.name.parameter=形參
type.name.macro=宏
type.name.function=函數
type.name.template=導入的模板

builtin.not.applicable=類型不匹配: 內置 ''{0}'' 不適用於 ''{1}''
unknown.builtin=未知的內置 ''{0}''
wrong.builtin.parameter.types=內置形參類型錯誤
builtin.should.have.params=內置 ''{0}'' 應具有形參
builtin.should.not.have.params=內置 ''{0}'' 不應具有形參
deprecated.builtin.usage=內置 ''{0}'' 已棄用
replace.with.0=替換為 {0}
smart.completion.inference.hint=按 {0} 可嘗試從用法中推斷類型
smart.completion.roots.hint=按 {0} 可從現有 includes/imports 中推斷根
global.completion.all.ftl.files.hint=再次按 {0} 可查看所有 FreeMarker 文件

fix.import.or.include.file=導入或包含 FreeMarker 文件
fix.include.file=包含 ''{0}''
fix.import.file=導入 ''{0}''
choose.declaration.type=選擇聲明類型
choose.declaration.type.implicit.or.explicit=要添加顯式聲明(在當前文件中)還是隱式聲明(在由 IntelliJ IDEA 自動導入的特殊文件中)?
implicit=隱式(&I)
explicit=顯式(&E)

error.format.string.syntax=格式字符串應使用語法 mminMmax，例如 m1M42
error.mixing.camelcase.lowercase=不允許在一個模板中混用駝峰拼寫法和小寫標識符

reference.inspection.cb.public.fields.are.exposed=public 字段被公開
suppress.inspection.quick.fix.name=禁止檢查
reference.inspection.unknown.enum.constant.ref=類 {0} 中的未知枚舉常量 ''#ref''
reference.inspection.accessing.non.public.class=訪問非 public 類 ''{0}''

validator.description=FreeMarker
validator.progress.text=正在檢查 FreeMarker 文件…
parsing.error.format.name.string.literal.expected=應為格式名稱字符串文字


freemarker.intentions.category=FreeMarker
loop.variable=循環變量
composite.type.unknown=未知
hash.type=哈希
namespace.type=命名空間
component.sequence.type={0} 序列
sequence.type=序列
date.type=日期
markup.output.type=標記輸出
node.type=節點
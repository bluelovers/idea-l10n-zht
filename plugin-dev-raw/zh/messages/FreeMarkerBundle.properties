number=數字
identifier=關鍵字
filetype.ftl.description=FreeMarker 模板
directive.name.expected=應為指令名稱
unmatched.directive.end=指令結尾不符合
expression.expected=應為表達式
attribute.name.expected=應為特性名稱
comment.end.expected=應為右側 '#comment' 標籤
closing.directive.expected.0=應為右側 {0} 指令
variable.name.expected=應為變數名稱
setting.name.expected=應為有效的設定名稱
no.matching.0.directive=沒有符合的 {0} 指令
wellformedness.inspection.as.loop.variable.name.missing=缺少 'as' (迴圈變數名稱)
wellformedness.inspection.parent.list.of.the.items.must.not.have.as=#items 的父級 #list 不得包含 "as {0}" 參數

freemarker.inspections.group=FreeMarker
ftl.wellformedness.inspection=指令格式不正確
ftl.references.inspection=未解析的引用
ftl.calls.inspection=無效的調用指令
ftl.import.calls.inspection=未解析的外部調用
ftl.deprecated.builtins.inspection=內建已棄用
ftl.types.inspection=不正確的表達式類型
ftl.file.references.inspection=未解析的檔案引用
else.should.finish.if=else 指令應當為 if 指令中的最後一項
namespace.expected=應為命名空間
error.cannot.resolve.variable.0=無法解析變數 ''{0}''
error.cannot.resolve.function.0=無法解析函數 ''{0}''
error.cannot.resolve.parameter.0.of.macro.1=無法解析巨集 ''{1}'' 的參數 ''{0}''
error.cannot.resolve.field.of=無法解析類 ''{1}'' 的欄位或屬性 ''{0}''
error.cannot.resolve.field=無法解析欄位或屬性 ''{0}''
error.cannot.resolve.method.of=無法解析類 ''{1}'' 的方法 ''{0}''
error.cannot.resolve.method=無法解析方法 ''{0}''
error.cannot.resolve.macro=無法解析巨集 ''{0}''
expression.should.have.numeric.type=表達式應為數值類型，實際為 ''{0}''
expression.unexpected.type=意外類型: ''{0}''
expression.should.have.scalar.type=表達式應為標量類型，實際為 ''{0}''
expression.should.have.array.or.collection.type=表達式應為數組或集合類型，實際為 ''{0}''
expression.should.have.hash.type=表達式應為哈希或 ''Map'' 類型，實際為 ''{0}''
expression.should.have.namespace.type=應為命名空間，實際為 ''{0}''
expression.should.have.node.type=應為節點類型，實際為 ''{0}''
expression.should.have.macro.type=應為巨集類型，實際為 ''{0}''
expression.should.have.boolean.type=應為布林型態，實際為 ''{0}''

invalid.ftl.file=不是 FreeMarker 檔案
invalid.relative.path=相對路徑無效
absolute.refs.not.allowed=此處不允許絕對路徑引用
directory.expected=應為目錄

error.no.applicable.method={1} 中沒有適用於 {2} 的方法 ''{0}''
error.static.member.expected=應為 static 成員
quickfix.convert.to.instance.family=轉換為實例類型
quickfix.convert.to.instance=將 {0} 類型轉換為實例一
error.multiple.overloaded.methods=多個多載方法 {0}
ftl.should.start.file=#ftl 指令應出現在模板最開頭
default.value.should.occur.at.the.end=具有預設值的參數應出現在參數列表的末尾，應為 =
macro.function.nesting=#macro 和 #function 指令不應嵌套
unclosed.directive=未閉合的指令
can.only.occur.inside=#{0} 只能出現在 #{1} 內部
can.only.occur.inside.or=#{0} 只能出現在 #{1} 或 #{2} 內部
wrong.closing.directive.name=閉合指令名稱錯誤
recover.once=#recover 指令只能出現一次
recover.inside.attempt=#recover 指令只能在 #attempt 內部發生
recover.expected=#attempt 內部應為 #recover 指令

add.implicit.variable.fix.name=在註釋中定義隱式變數
add.implicit.variable.fix.name.local=定義隱式變數(在當前檔案中的註釋中)
add.implicit.variable.fix.name.module.wide=在外部定義隱式變數(全域)
add.implicit.variable.fix.name.external=在外部定義隱式變數(僅此檔案)
add.implicit.toplevel.variable.fix.name=指定要從中提取頂層屬性和方法的類
add.implicit.toplevel.variable.fix.name.local=指定要從中獲取頂層屬性和方法的類(在當前檔案中的註釋中)
add.implicit.toplevel.variable.fix.name.external=指定要從中提取頂層屬性和方法的類(外部)
choose.external.definitions.file=選擇外部隱式定義檔案

create.macro.or.function.from.usage=根據用法創建巨集或函數
create.macro.from.usage=根據用法創建巨集 ''{0}''
define.implicit.macro.from.usage=定義隱式巨集 ''{0}''
create.function.from.usage=根據用法創建函數 ''{0}''
define.implicit.function.from.usage=定義隱式函數 ''{0}''

create.dynamic.method.or.property=創建動態方法或屬性
create.dynamic.method=創建動態方法 ''{0}''

define.template.root.fix.name=定義模板根
define.template.root.fix.name.local=在當前檔案的註釋中定義模板根
define.template.root.fix.name.module.wide=在註釋中定義模板根(全域)

variable.may.be.undefined=變數 ''{0}'' 可能未定義
undefined.mandatory.parameters=缺少必填參數: {0}
too.many.parameters=參數過多
type.mismatch=應為 ''{0}'' 類型，發現為 ''{0}''

change.macro.call.style.family=更改巨集調用樣式
change.macro.call.style.to.named=將巨集調用更改為命名樣式
change.macro.call.style.to.positinal=將巨集調用更改為位置樣式

type.name.variable=變數
type.name.parameter=參數
type.name.macro=巨集
type.name.function=函數
type.name.template=匯入的模板

builtin.not.applicable=類型不符合: 內建 ''{0}'' 不適用於 ''{1}''
unknown.builtin=未知的內建 ''{0}''
wrong.builtin.parameter.types=內建參數類型錯誤
builtin.should.have.params=內建 ''{0}'' 應具有參數
builtin.should.not.have.params=內建 ''{0}'' 不應具有參數
deprecated.builtin.usage=內建 ''{0}'' 已棄用
replace.with.0=取代為 {0}
smart.completion.inference.hint=按 {0} 可嘗試從用法中推斷類型
smart.completion.roots.hint=按 {0} 可從現有 include/import 中推斷根
global.completion.all.ftl.files.hint=再次按 {0} 可查看所有 FreeMarker 檔案

fix.import.or.include.file=匯入或包含 FreeMarker 檔案
fix.include.file=包含 ''{0}''
fix.import.file=匯入 ''{0}''
choose.declaration.type=選擇宣告類型
choose.declaration.type.implicit.or.explicit=要添加顯式宣告(在當前檔案中)還是隱式宣告(在由 IntelliJ IDEA 自動匯入的特殊檔案中)?
implicit=隱式(&I)
explicit=顯式(&E)

error.format.string.syntax=格式字串應使用語法 mminMmax，例如 m1M42
error.mixing.camelcase.lowercase=不允許在一個模板中混用駝峰式命名法和小寫關鍵字

reference.inspection.cb.public.fields.are.exposed=public 欄位被公開
suppress.inspection.quick.fix.name=禁止檢查
reference.inspection.unknown.enum.constant.ref=類 {0} 中的未知枚舉常數 ''#ref''
reference.inspection.accessing.non.public.class=存取非 public 類 ''{0}''

validator.description=FreeMarker
validator.progress.text=正在檢查 FreeMarker 檔案…
parsing.error.format.name.string.literal.expected=應為格式名稱字串文字


freemarker.intentions.category=FreeMarker
loop.variable=迴圈變數
composite.type.unknown=未知
hash.type=哈希
namespace.type=命名空間
component.sequence.type={0} 序列
sequence.type=序列
date.type=日期
markup.output.type=標記輸出
node.type=節點
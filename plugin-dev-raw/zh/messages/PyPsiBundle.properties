ACT.CMD.use.import=使用匯入的模組
ACT.from.some.module.import=匯入自…
ACT.qualify.with.module=使用匯入的模組進行限定
ANN.assign.to.none=賦值給 None
ANN.assignment.expression.as.a.target=賦值表達式不能用作此處的目標
ANN.assignment.expression.in.an.iterable=不能在推導式 iterable 中使用賦值表達式
ANN.assignment.expressions.within.a.comprehension.cannot.be.used.in.a.class.body=推導式中的賦值表達式不能在類別主體中使用
ANN.assignment.to.keyword=關鍵字賦值
ANN.async.for.outside.function=async 函式外部的 'async for'
ANN.async.with.outside.function=async 函式外部的 'async with'
ANN.await.outside.async.function=異步函式外部的 'await'
ANN.break.outside.loop='break' 在迴圈外
ANN.can.t.use.starred.expression.here=這裡不能使用星號表達式
ANN.cannot.assign.to.debug=無法賦值給 __debug__
ANN.cant.assign.to.await.expr=無法賦值給 await 表達式
ANN.cant.assign.to.call=無法賦值給函式呼叫
ANN.cant.assign.to.comprh=無法賦值給列表推導式
ANN.cant.assign.to.dict.comprh=無法賦值給字典推導式
ANN.cant.assign.to.generator=無法賦值給產生器表達式
ANN.cant.assign.to.lambda=無法賦值給 lambda
ANN.cant.assign.to.literal=無法賦值給字面量
ANN.cant.assign.to.operator=無法賦值給運算符
ANN.cant.assign.to.parens=無法賦值給 ()
ANN.cant.assign.to.set.comprh=無法賦值給集合推導式
ANN.cant.aug.assign.starred.assignment.target.must.be.in.list.or.tuple=帶星號的賦值目標必須位於列表或元組中
ANN.cant.aug.assign.to.comprh=無法對列表推導式進行增強賦值
ANN.cant.aug.assign.to.dict.comprh=無法對字典推導式進行增強賦值
ANN.cant.aug.assign.to.generator=無法對產生器表達式進行增強賦值
ANN.cant.aug.assign.to.list.or.comprh=無法對列表字面量或推導式進行增強賦值
ANN.cant.aug.assign.to.set.comprh=無法對集合推導式進行增強賦值
ANN.cant.aug.assign.to.tuple.or.generator=無法對元組字面量或產生器表達式進行增強賦值
ANN.cant.delete.call=無法刪除函式呼叫
ANN.cant.delete.literal=無法刪除字面量
ANN.continue.break.or.return.in.star.except='break'、'continue' 和 'return' 不能出現在 except* 塊中
ANN.continue.outside.loop='continue' 在迴圈外
ANN.default.except.must.be.last=預設 'except\:' 必須為最後一個
ANN.deleting.none=刪除 None
ANN.duplicate.param.name=重複的參數名稱
ANN.exception.group.in.star.except=ExceptionGroup 不能在 except* 中使用
ANN.fstrings.illegal.conversion.character=非法轉換字元 ''{0}''\: 應為 ''s''、''r''、''a'' 之一
ANN.fstrings.missing.conversion.character=應為轉換字元\: 應為 's'、'r'、'a' 之一
ANN.fstrings.single.right.brace.not.allowed.inside.fstrings=f-string 中不允許使用單個 '}'
ANN.function.cannot.be.async=函式“{0}”不能是異步函式
ANN.generator.expression.must.be.parenthesized.if.not.sole.argument=如果不是唯一實參，則必須為生成器表達式新增括號
ANN.ignore.errors.like.this=忽略這樣的錯誤
ANN.illegal.target.for.variable.annotation=變數註解的非法目標
ANN.missing.closing.quote=缺少右引號 [{0}]
ANN.missing.closing.triple.quotes=缺少右三引號
ANN.multiple.args=不允許多個 * 參數
ANN.multiple.kwargs=不允許多個 ** 參數
ANN.multiple.slash=不允許多個 / 參數
ANN.name.used.both.as.global.and.param=名稱 ''{0}'' 同時用作參數和全域變數
ANN.named.parameters.after.star=僅帶有 * 時，後面必須跟隨命名參數
ANN.named.parameters.before.slash=僅帶有 * 時，前面必須有命名參數
ANN.no.exception.to.reraise=沒有要重新引發的異常
ANN.non.default.param.after.default=預設參數後面跟隨非預設參數
ANN.non.empty.return.inside.asynchronous.generator=異步產生器內部的 'return' 非空
ANN.patterns.attribute.name.is.repeated=特性名稱 ''{0}'' 重複
ANN.patterns.double.star.pattern.cannot.be.used.outside.mapping.patterns=雙星號模式不能在映射模式之外使用
ANN.patterns.invalid.complex.number.literal=複雜數字字面量無效
ANN.patterns.key.pattern.can.only.be.value.or.literal.pattern=鍵模式只能是值模式或字面量模式
ANN.patterns.name.already.bound=名稱 ''{0}'' 已被綁定
ANN.patterns.pattern.does.not.bind.names=模式不綁定{0,choice,1\#名稱|2\#名稱} {1}
ANN.patterns.pattern.makes.remaining.alternatives.unreachable=模式使剩餘的替代項無法存取
ANN.patterns.pattern.makes.remaining.case.clauses.unreachable=模式使剩餘的 case 子句無法存取
ANN.patterns.repeated.star.pattern=重複的星號模式
ANN.patterns.single.star.pattern.cannot.be.used.outside.sequence.patterns=單星號模式不能在序列模式之外使用
ANN.positional.only.param.after.keyword=僅位置參數跟隨非僅位置參數
ANN.python.does.not.support.yield.from.inside.async.functions=Python 不支持在異步函式中使用 'yield from'
ANN.regular.param.after.keyword=正則參數在 ** 參數後面
ANN.regular.param.after.vararg=正則參數在 * 參數後面
ANN.return.outside.of.function='return' 在函式外部
ANN.slash.param.after.keyword=/ 參數必須在 ** 參數前面
ANN.slash.param.after.vararg=/ 參數必須在 * 參數前面
ANN.star.import.at.top.only=僅在模組級別允許 'import *'
ANN.starred.param.after.kwparam=* 參數在 ** 參數後面
ANN.try.except.can.not.have.except.and.star.except=Try 語句不能同時包含 except 和 except*
ANN.tuple.py3=Python 3 中不支持元組參數解包
ANN.unparenthesized.assignment.expression.statement=在表達式語句的頂層禁止使用不帶圓括號的賦值表達式
ANN.unparenthesized.assignment.expression.value=在賦值語句右側的頂層禁止使用不帶圓括號的賦值表達式
ANN.variable.annotation.cannot.be.combined.with.tuple.unpacking=變數註解不能與元組解包相結合
ANN.variable.annotation.cannot.be.used.in.assignment.with.multiple.targets=變數註解不能用於具有多個目標的賦值
ANN.yield.outside.of.function='yield' 在函式外部
INLAY.function.return=函式返回值類型
INLAY.reveal.type='reveal_type' 實參類型
INLAY.type.hints=Python 類型提示
INSP.GROUP.pandas=Pandas
INSP.GROUP.python=Python
INSP.NAME.abstract.class=無效的抽象類別定義和用法
INSP.NAME.argument.equal.default=函式實參等於預設參數值
INSP.NAME.assert.type=typing.assert_type
INSP.NAME.assignment.to.loop.or.with.parameter=賦值給 'for' 迴圈或 'with' 語句參數
INSP.NAME.attribute.outside.init=實例特性在 `__init__` 外部定義
INSP.NAME.augment.assignment=賦值可被取代為增強賦值
INSP.NAME.bad.except.clauses.order=順序錯誤的 'except' 子句
INSP.NAME.byte.literal=位元組字面量包含非 ASCII 字元
INSP.NAME.calling.non.callable=嘗試呼叫不可呼叫的物件
INSP.NAME.chained.comparisons=過於複雜的鏈式比較
INSP.NAME.check.can.be.simplified=冗餘布爾變數檢查
INSP.NAME.class.has.no.init=類別沒有 `__init__` 方法
INSP.NAME.class.var.variables=ClassVar 變數的用法無效
INSP.NAME.classic.class.usage=經典樣式類別用法
INSP.NAME.comparison.with.none=使用相等運算符與 None 進行比較
INSP.NAME.compatibility=程式碼與特定的 Python 版本不相容
INSP.NAME.coroutine.is.not.awaited=未等待協程 ''{0}''
INSP.NAME.dataclass.definition.and.usages=無效的資料類別定義和用法
INSP.NAME.decorator.outside.class=在類別的外部使用了特定於類別的裝飾器
INSP.NAME.default.argument=預設實參是可變實參
INSP.NAME.deprecated.function.class.or.module=棄用的函式、類別或模組
INSP.NAME.dict.creation=通過字典字面量可以覆寫字典建立
INSP.NAME.docstring.types=docstring 中的類型與推斷的類型不符合
INSP.NAME.dunder.slots=具有 '__slots__' 定義的無效類別用法
INSP.NAME.duplicate.keys=字典包含重複鍵
INSP.NAME.enum=無效的枚舉定義和用法
INSP.NAME.exception.not.inherit=不從標準 'Exception' 類別繼承異常
INSP.NAME.final.classes.methods.and.variables=無效的 final 類別、方法和變數用法
INSP.NAME.first.arg.assign=此方法的第一個實參被重新賦值
INSP.NAME.from.future.import=位置不當的 from __future__ import
INSP.NAME.global.undefined=全域變數並非在模組級別定義
INSP.NAME.inconsistent.indentation=縮排不一致
INSP.NAME.inconsistent.returns=不一致的 return 語句
INSP.NAME.incorrect.call.arguments=錯誤的呼叫實參
INSP.NAME.incorrect.docstring=不正確的 docstring
INSP.NAME.init.return=返回值的 __init__ 方法
INSP.NAME.invalid.cast=使用不可能的類型進行類型轉換
INSP.NAME.invalid.interpreter=無效的解釋器
INSP.NAME.invalid.usages.of.override.decorator=@override 裝飾器的無效用法
INSP.NAME.list.creation=非最優列表宣告
INSP.NAME.mandatory.encoding=未為檔案指定編碼
INSP.NAME.method.may.be.static=方法未宣告為 static
INSP.NAME.method.over=方法簽名與被覆寫方法的簽名不符合
INSP.NAME.missing.or.empty.docstring=缺失或空 docstring
INSP.NAME.missing.super.constructor=缺少對超類別 '__init__' 的呼叫
INSP.NAME.missing.type.hints=缺少函式定義的類型提示
INSP.NAME.nested.decorators=裝飾器嵌套有問題
INSP.NAME.new.init.signature=__new__ 和 __init__ 的簽名不相容
INSP.NAME.new.style.generics.type.param.syntax=新型類型參數和類型別名的無效用法
INSP.NAME.new.type=NewType 的無效用法
INSP.NAME.new.type.cannot.be.subclassed=''{0}'' 無法被子類別化
INSP.NAME.new.type.expected.class=預期類別
INSP.NAME.new.type.new.type.cannot.be.generic=NewType 不能為泛型
INSP.NAME.new.type.new.type.cannot.be.used.with=NewType 不能與 ''{0}'' 一起使用
INSP.NAME.new.type.variable.name.does.not.match.new.type.name=變數名稱 ''{0}'' 與 NewType 名稱 ''{1}'' 不符合
INSP.NAME.non.ascii=檔案包含非 ASCII 字元
INSP.NAME.none.function.assignment=分配不返回任何內容的函式呼叫
INSP.NAME.oldstyle.class=老式類別包含新式類別功能
INSP.NAME.overloads.in.regular.python.files=一般 Python 檔案中的多載
INSP.NAME.pep8.naming=PEP 8 命名約定違規
INSP.NAME.problematic.first.parameter=不正確的第一個參數
INSP.NAME.property.access=不當的屬性存取
INSP.NAME.property.definition=不正確的屬性定義
INSP.NAME.protected.member=存取類別或模組的 protected 成員
INSP.NAME.protocol.definition.and.usages=無效的協議定義和用法
INSP.NAME.pytest-parametrized=@pytest.mark.parametrize 中的不正確實參
INSP.NAME.pytest.unpassed.fixture=測試函式未請求固定例程
INSP.NAME.redeclaration=無用法的重新宣告名稱
INSP.NAME.redundant.parentheses=冗餘圓括號
INSP.NAME.relative.import=可疑的相對 import
INSP.NAME.requirements=未滿足的軟體套件要求
INSP.NAME.set.function.to.literal=函式呼叫可被取代為集合字面量
INSP.NAME.shadowing.builtins=隱藏內建名稱
INSP.NAME.single.quoted.docstring=帶單引號的 docstring
INSP.NAME.statement.effect=語句不起任何作用
INSP.NAME.str.format=字串格式設定動作中的錯誤
INSP.NAME.too.broad.exception.clauses=不明確的異常子句
INSP.NAME.trailing.semicolon=語句中的禁止尾隨分號
INSP.NAME.tuple.assignment.balance=元組賦值 balance 不正確
INSP.NAME.tuple.item.assignment=禁止元組條目賦值
INSP.NAME.type.alias.redeclaration=重新宣告的類型別名
INSP.NAME.type.checker=錯誤類型
INSP.NAME.type.hints=無效的類型提示定義和用法
INSP.NAME.typed.dict=無效的 TypedDict 定義和用法
INSP.NAME.unbound=未綁定的區域變數
INSP.NAME.unnecessary.backslash=不必要的反斜杠
INSP.NAME.unnecessary.cast=不必要的類型轉換
INSP.NAME.unreachable.code=不可到達的程式碼
INSP.NAME.unresolved.refs=未解析的參照
INSP.NAME.unused=未使用的區域符號
INSP.NAME.unused.imports=未使用的 import
INSP.NAME.wrong.super.arguments=錯誤的呼叫 super 實參
INSP.abstract.class.abstract.methods.are.allowed.in.classes.whose.metaclass.is.abcmeta=允許在元類別為 'ABCMeta' 的類別中使用抽象方法
INSP.abstract.class.add.to.superclasses=新增 ''{0}'' 至超類別
INSP.abstract.class.cannot.instantiate.abstract.class=無法實例化抽象類別 ''{0}''
INSP.abstract.class.class.must.implement.all.abstract.methods=類別 {0} 必須實作所有 abstract 方法
INSP.abstract.class.set.as.metaclass=設定 ''{0}'' 為元類別
INSP.argument.equals.to.default=實參等於預設參數值
INSP.arguments.not.declared.but.provided.by.decorator=以下實參未宣告，而是由修飾器提供\: {0}
INSP.assert.type.expected.type.got.type.instead=應為類型 ''{0}''，但實際為 ''{1}''
INSP.assignment.can.be.replaced.with.augmented.assignment=賦值可被取代為增強賦值
INSP.assignment.to.loop.or.with.parameter=已在上面的 ''for'' 迴圈或 ''with'' 語句中宣告變數 ''{0}''
INSP.async.call=協程呼叫中缺少 `await` 語法
INSP.attribute.outside.init=實例特性 {0} 在 __init__ 外部定義
INSP.auto.to.manual.field.numbering=無法從自動欄位編號切換到手動欄位規範
INSP.await.call.on.imported.untyped.function=函式 ''{0}'' 既未宣告為 ''async''，也未將返回值類型設為 ''Awaitable''
INSP.bad.except.exception.class.already.caught=已捕獲異常類別 ''{0}''
INSP.bad.except.superclass.of.exception.class.already.caught=已捕獲異常類別 ''{1}'' 的超類別 ''{0}''
INSP.byte.literal.contains.illegal.characters=位元組字面量包含的字元數超過 255 個
INSP.cant.return.value.from.init=無法從 __init__ 返回值
INSP.chained.comparisons.ignore.statements.with.constant.in.the.middle=忽略中間有常數的語句
INSP.class.has.no.init=類別沒有 __init__ 方法
INSP.class.is.not.subtype.of.class=''{0}'' 不是 ''{1}'' 的實例或子類別
INSP.class.object.is.not.callable=''{0}'' 物件不可呼叫
INSP.class.var.can.be.used.only.in.class.body='ClassVar' 只能在類別主體中使用
INSP.class.var.can.not.be.assigned.to.instance=無法通過實例賦值給類別變數 ''{0}''
INSP.class.var.can.not.be.nested='ClassVar' 無法嵌套
INSP.class.var.can.not.be.used.in.annotation.for.function.return.value=不能在函式返回值註解中使用 'ClassVar'
INSP.class.var.can.not.be.used.in.annotations.for.function.parameters=不能在函式參數註解中使用 'ClassVar'
INSP.class.var.can.not.include.type.variables='ClassVar' 參數不能包含類型變數
INSP.class.var.can.not.override.class.variable=不能使用實例變數覆寫類別變數 ''{0}'' (之前在基類別 ''{1}'' 中宣告)
INSP.class.var.can.not.override.instance.variable=不能使用類別變數覆寫實例變數 ''{0}'' (之前在基類別 ''{1}'' 中宣告)
INSP.class.var.can.only.be.parameterized.with.one.type='ClassVar' 只能使用一種類型進行參數化
INSP.class.var.is.not.allowed.here=這裡不允許使用 'ClassVar'
INSP.class.var.not.a.valid.type=不是有效的類型
INSP.classic.class.usage.old.style.class=老式類別
INSP.classic.class.usage.old.style.class.ancestors=老式類別，因為它所繼承的所有類別都是老式類別
INSP.comparison.with.none.performed.with.equality.operators=使用相等運算符執行了與 None 的比較
INSP.compatibility.basestring.type.not.available.in.py3=basestring 類型在 Python 3 中不可用
INSP.compatibility.check.for.compatibility.with.python.versions=檢查與 python 版本的兼容性\:
INSP.compatibility.feature.allow.async.and.await.as.names=允許使用 'async' 和 'await' 作為名稱
INSP.compatibility.feature.allow.backslashes.in.f-strings=允許在 f-string 的表達式部分中使用反斜杠
INSP.compatibility.feature.allow.deep.expression.nesting.in.f-strings=允許在此深度的格式說明符中嵌套表達式
INSP.compatibility.feature.allow.duplicate.kwargs=允許重複的 ** 表達式
INSP.compatibility.feature.allow.duplicate.positional.varargs=允許重複的 * 表達式
INSP.compatibility.feature.allow.keyword.arguments.after.kwargs=允許在 ** 表達式後面使用關鍵字實參
INSP.compatibility.feature.allow.new.lines.in.f-strings=允許在非三重引號的 f-string 的表達式部分中換行
INSP.compatibility.feature.allow.positional.arguments.after.expression=允許在 * 表達式後面使用位置實參
INSP.compatibility.feature.allow.quote.reuse.in.f-strings=允許在 f-string 中嵌套具有相同引號類型的字串字面量
INSP.compatibility.feature.allow.to.mix.bytes.and.non.bytes.literals=允許混合位元組字面量和非位元組字面量
INSP.compatibility.feature.allow.trailing.comma.after.kwargs=允許在 ** 表達式後面使用尾隨逗號
INSP.compatibility.feature.allow.trailing.comma.after.positional.vararg=允許在 * 表達式後面使用尾隨逗號
INSP.compatibility.feature.have.method=具有方法 {0}
INSP.compatibility.feature.have.module=具有模組 {0}
INSP.compatibility.feature.have.module.builtin=具有模組 __builtin__
INSP.compatibility.feature.have.module.builtins=具有模組內建物件
INSP.compatibility.feature.have.nonlocal.keyword=具有非本地關鍵字
INSP.compatibility.feature.have.type.long=類型為 long。請改用 int。
INSP.compatibility.feature.line.comments.in.f-strings=允許在 f-string 的表達式部分中使用註釋
INSP.compatibility.feature.support.arbitrary.expressions.as.decorator=支援任意表達式作為裝飾器
INSP.compatibility.feature.support.assignment.expressions=支援賦值表達式
INSP.compatibility.feature.support.backquotes=支援反引號，請改用 repr()
INSP.compatibility.feature.support.break.inside.finally.clause=支援在 'finally'子句內部使用 'break'
INSP.compatibility.feature.support.continue.inside.finally.clause=支援在 'finally'子句內部使用 'continue'
INSP.compatibility.feature.support.diamond.operator=支援 <>，請改用 use \!\=
INSP.compatibility.feature.support.ellipsis.outside.slices=支援在序列切片外部使用 '…'
INSP.compatibility.feature.support.long.integer.literal.suffix=支援尾隨 ''{0}''
INSP.compatibility.feature.support.match.statements=支援 match 語句
INSP.compatibility.feature.support.matrix.multiplication.operators=支援矩陣乘法運算符
INSP.compatibility.feature.support.old.style.octal.literals=支援此語法。八進制字面量需要使用 '0o' 前綴
INSP.compatibility.feature.support.parenthesized.context.expressions=支援帶圓括號的上下文表達式
INSP.compatibility.feature.support.positional.only.parameters=支援純位置參數
INSP.compatibility.feature.support.print.statement=支援此語法。print 語句已取代為 print() 函式
INSP.compatibility.feature.support.raise.with.no.arguments.outside.except.block=支援此語法。只能在 except 塊中使用不帶實參的 raise
INSP.compatibility.feature.support.return.inside.finally.clause=支援在 'finally'子句內部使用 'return'
INSP.compatibility.feature.support.starred.except.part=支援 except* 部分
INSP.compatibility.feature.support.starred.expressions.as.assignment.targets=支援將帶星號的表達式作為賦值目標
INSP.compatibility.feature.support.starred.expressions.in.dicts=支援在字典中使用帶星號的表達式
INSP.compatibility.feature.support.starred.expressions.in.subscriptions=支援在訂閱中使用帶星號的表達式
INSP.compatibility.feature.support.starred.expressions.in.tuples.lists.and.sets=支援在元組、列表和集合中使用帶星號的表達式
INSP.compatibility.feature.support.starred.expressions.in.type.annotations=支援在類型註解中使用帶星號的表達式
INSP.compatibility.feature.support.string.literal.prefix=支援 ''{0}'' 前綴
INSP.compatibility.feature.support.super.without.arguments=支援此語法。在 Python 2 中 super() 應有實參
INSP.compatibility.feature.support.this.syntax=支援此語法
INSP.compatibility.feature.support.this.syntax.in.list.comprehensions=支援在列表推導式中使用此語法
INSP.compatibility.feature.support.type.alias.statements=支援類型別名語句
INSP.compatibility.feature.support.underscores.in.numeric.literals=支援在數值字面量中使用下劃線
INSP.compatibility.feature.support.unpacking.without.parentheses.in.return.statements=支援在 return 語句中沒有圓括號的情況下解包
INSP.compatibility.feature.support.unpacking.without.parentheses.in.yield.statements=支援在 yield 語句中沒有圓括號的情況下解包
INSP.compatibility.feature.support.variable.annotations=支援變數註解
INSP.compatibility.feature.support.yield.from=支援此語法。自 Python 3.3 起可以委託給子產生器；改為對子產生器使用顯式迭代。
INSP.compatibility.inspection.unsupported.feature.prefix=Python {0,choice,1\#版本|2\#版本} {1} {0,choice,1\#|2\#}不{2}
INSP.compatibility.keyword.argument.repeated=關鍵字實參重複
INSP.compatibility.new.union.syntax.not.available.in.earlier.version=允許將聯合體類型編寫為 X | Y
INSP.compatibility.old.dict.methods.not.available.in.py3=dict.iterkeys()、dict.iteritems() 和 dict.itervalues() 方法在 Python 3 中不可用
INSP.compatibility.positional.argument.after.keyword.argument=位置實參位於關鍵字實參後面
INSP.compatibility.positional.argument.after.kwargs=位置實參位於 ** 表達式後面
INSP.compatibility.pre35.versions.do.not.allow.return.with.argument.inside.generator=Python 3.3 以下的版本不允許在產生器內部使用帶實參的 'return'。
INSP.compatibility.support.equality.signs.in.fstrings=支援在 f-string 中使用等號
INSP.compatibility.this.syntax.available.only.since.py3=此語法僅自 Python 3 起可用
INSP.dataclasses.argument.ignored.if.class.already.defines.method=如果類別已定義 ''{1}'' 方法，則忽略 ''{0}''
INSP.dataclasses.attribute.default.set.using.method=使用 ''{0}'' 設定預設值
INSP.dataclasses.attribute.lacks.type.annotation=特性 ''{0}'' 缺少類型註解
INSP.dataclasses.attribute.useless.until.post.init.declared=只有宣告 ''__post_init__'' 之後，特性 ''{0}'' 才有用
INSP.dataclasses.attrs.post.init.should.not.take.any.parameters.except.self='__attrs_post_init__' 不應接受除 'self' 以外的任何參數
INSP.dataclasses.attrs.post.init.would.not.be.called.until.init.parameter.set.to.true=只有在 'init' 參數設定為 True 後，才會呼叫 '__attrs_post_init__'
INSP.dataclasses.cannot.specify.both.default.and.default.factory=無法同時指定 'default' 和 'default_factory'
INSP.dataclasses.cannot.specify.both.default.and.factory=無法同時指定 'default' 和 'factory'
INSP.dataclasses.eq.must.be.true.if.order.true=如果 'order' 為 true，則 'eq' 必須為 true
INSP.dataclasses.field.cannot.have.default.factory=欄位不能有預設工廠
INSP.dataclasses.frozen.attribute.should.be.false.if.class.defines.setattr.or.delattr=如果類別定義 '__setattr__' 或 '__delattr__'，則 'frozen' 應為 False
INSP.dataclasses.frozen.dataclasses.can.not.inherit.non.frozen.one=凍結的資料類別不能繼承非凍結的資料類別，非凍結的資料類別也不能繼承凍結的資料類別
INSP.dataclasses.hash.ignored.if.class.already.defines.cmp.or.order.or.frozen.parameters=如果類別已定義 'cmp/order' 和 'frozen' 參數，則忽略 '__hash__'
INSP.dataclasses.method.is.ignored.if.class.already.defines.parameter=如果類別已定義 ''{1}'' 參數，則忽略 ''{0}''
INSP.dataclasses.method.should.be.called.on.attrs.instances=應對特性實例呼叫 ''{0}'' 方法
INSP.dataclasses.method.should.be.called.on.attrs.types=應對特性類型呼叫 ''{0}'' 方法
INSP.dataclasses.method.should.be.called.on.dataclass.instances=應對資料類別實例呼叫 ''{0}'' 方法
INSP.dataclasses.method.should.be.called.on.dataclass.instances.or.types=應對資料類別實例或類型呼叫 ''{0}'' 方法
INSP.dataclasses.method.should.take.only.n.parameter=''{0}'' 應僅使用 {1} 個{1,choice, 1\#參數|2\#參數}
INSP.dataclasses.mutable.attribute.default.not.allowed.use.default.factory=不允許使用可變的預設 ''{0}''。使用 ''default_factory''
INSP.dataclasses.object.attribute.read.only=''{0}'' 物件特性 ''{1}'' 為唯讀特性
INSP.dataclasses.object.could.have.no.attribute.because.it.declared.as.init.only=''{0}'' 物件不能有特性 ''{1}''，因為它被宣告為僅初始化
INSP.dataclasses.operator.not.supported.between.instances.of.class=''{1}'' 的實例之間不支持 ''{0}''
INSP.dataclasses.operator.not.supported.between.instances.of.classes=''{1}'' 和 ''{2}'' 的實例之間不支持 ''{0}''
INSP.dataclasses.order.argument.should.be.false.if.class.defines.one.of.order.methods=如果類別定義一種 order 方法，則 'order' 應為 False
INSP.dataclasses.post.init.should.take.all.init.only.variables.in.same.order.they.defined='__post_init__' 應按照定義的順序接受所有僅初始化變數
INSP.dataclasses.post.init.should.take.all.init.only.variables.including.inherited.in.same.order.they.defined='__post_init__' 應按照定義的順序接受所有僅初始化變數(包括繼承的變數)
INSP.dataclasses.post.init.would.not.be.called.until.init.parameter.set.to.true=只有在 'init' 參數設定為 True 後，才會呼叫 '__post_init__'
INSP.dataclasses.unsafe.hash.attribute.should.be.false.if.class.defines.hash=如果類別定義 '__hash__'，則 'unsafe_hash' 應為 False
INSP.decorator.receives.unexpected.builtin=此裝飾器將不會收到其所期望的可調用對象；之前呼叫的裝飾器 ''{0}'' 會返回一個特殊物件
INSP.decorators.method.only.decorator.on.method.outside.class=方法上的裝飾器 {0} 位於類別外部
INSP.default.arguments.default.argument.value.mutable=預設實參值可變
INSP.deleter.should.not.return=刪除程序不應返回值
INSP.deleter.signature.advice=刪除程序簽名應為 (self)
INSP.deprecation.abc.decorator.deprecated.use.alternative=自 Python 3.3 起已棄用 ''{0}''。改為使用 ''{1}'' 和 ''{2}''
INSP.dict.creation.this.dictionary.creation.could.be.rewritten.as.dictionary.literal=字典建立可以作為字典字面量進行覆寫
INSP.doc.param.should.be.str=doc 參數應為字串
INSP.docstring.types.change.type=將 {0} 類型從 {1} 更改為 {2}
INSP.docstring.types.dynamically.inferred.type.does.not.match.specified.type=動態推斷的類型 ''{0}'' 與指定的類型 ''{1}'' 不符合
INSP.docstring.types.fix.docstring=修正 docstring
INSP.dunder.slots.class.object.attribute.read.only=''{0}'' 物件特性 ''{1}'' 為唯讀特性
INSP.dunder.slots.name.in.slots.conflicts.with.class.variable=__slots__ 中的 ''{0}'' 與類別變數衝突
INSP.duplicate.keys.dictionary.contains.duplicate.keys=字典包含重複鍵 ''{0}''
INSP.empty.docstring=空 docstring
INSP.enum.enum.class.is.final.and.cannot.be.subclassed=枚舉類別 ''{0}'' 是 final 類別，無法被子類別化
INSP.enum.type.annotations.are.not.allowed.for.enum.members=枚舉成員不允許使用類型註解
INSP.enum.type.is.not.assignable.to.declared.type=類型 ''{0}'' 無法賦值給宣告的類型 ''{1}''
INSP.exception.inheritance.exception.does.not.inherit.from.base.exception.class=異常未從 'Exception' 基類別繼承
INSP.expected.dict.got.type=應為映射，但實際為 {0}
INSP.expected.iterable.got.type=應為迭代，得到的是 {0}
INSP.expression.can.be.simplified=可以簡化表達式
INSP.expression.is.not.callable=表達式不可呼叫
INSP.final.already.declared.name.could.not.be.redefined.as.final=已宣告的名稱無法被重新定義為 'Final'
INSP.final.can.only.be.parameterized.with.one.type='Final' 只能使用一種類型進行參數化
INSP.final.either.instance.attribute.or.class.attribute.could.be.type.hinted.as.final=實例特性或類別特性可以有類型提示 'Final'
INSP.final.final.attribute.could.not.be.overridden=''{0}'' 為 ''Final''，不能被覆寫
INSP.final.final.attribute.should.be.declared.in.class.body.or.init='Final' 特性應在類別主體或 '__init__' 中宣告
INSP.final.final.class.could.not.contain.abstract.methods='Final' 類別不能包含抽象方法
INSP.final.final.could.not.be.mixed.with.abstract.decorators='Final' 不能與抽象裝飾器混用
INSP.final.final.could.not.be.used.in.annotation.for.function.return.value=不能在函式返回值的註解中使用 'final'
INSP.final.final.could.not.be.used.in.annotations.for.function.parameters=不能在函式參數註解中使用 'Final'
INSP.final.final.could.not.be.used.inside.loop=不能在迴圈內部使用 'Final'
INSP.final.final.could.only.be.used.as.outermost.type='Final' 只能用作最外側的類型
INSP.final.final.name.should.be.initialized.with.value='Final' 名稱應使用值進行初始化
INSP.final.final.target.could.not.be.reassigned=''{0}'' 為 ''Final''，不能被重新賦值
INSP.final.if.assigned.value.omitted.there.should.be.explicit.type.argument.to.final=如果忽略所賦之值，則應有一個顯式類型實參為 'Final'
INSP.final.method.marked.as.final.should.not.be.overridden=''{0}'' 被標記為 ''@final''，不應被覆寫
INSP.final.no.need.to.mark.method.in.final.class.as.final=無需將 'Final' 類別中的方法標記為 '@final'
INSP.final.non.method.function.could.not.be.marked.as.final=非方法函式不能被標記為 '@final'
INSP.final.super.classes.are.marked.as.final.and.should.not.be.subclassed={0} {1,choice,1\#|2\#}被標記為 ''@final''，不應為子類別
INSP.first.arg.assign.method.parameter.reassigned=方法參數 ''{0}'' 已重新賦值
INSP.first.param.must.not.be.tuple=非 static 方法的第一個參數不能是元組
INSP.format.requires.mapping=格式需要映射
INSP.format.requires.no.mapping=格式無需映射
INSP.from.future.import.from.future.imports.must.occur.at.beginning.file=從 __future__ 匯入必須在檔案開頭處進行
INSP.func.property.name.mismatch=函式和裝飾器的名稱不符合；未建立屬性存取器
INSP.function.lacks.positional.argument=函式 ''{0}'' 缺乏位置實參
INSP.getter.return.smth=Getter 應返回或生成某些內容
INSP.getter.signature.advice=Getter 簽名應為 (self)
INSP.global.variable.undefined=全域變數 ''{0}'' 在模組級別未定義
INSP.incompatible.options=塊“{0}”中的格式選項不相容
INSP.inconsistent.indentation.mix.tabs.spaces=縮排不一致\: 混用制表符和空格
INSP.inconsistent.indentation.previous.line.used.spaces.this.line.uses.tabs=縮排不一致\: 上一行使用空格，此行使用制表符
INSP.inconsistent.indentation.previous.line.used.tabs.this.line.uses.spaces=縮排不一致\: 上一行使用制表符，此行使用空格
INSP.inconsistent.returns.missing.return.stmt.on.some.paths=某些路徑缺少 return 語句
INSP.inconsistent.returns.return.without.value=沒有值的 'return' 與其他路徑不一致
INSP.incorrect.arguments=實參不正確
INSP.init.incompatible.to.new=簽名不相容 __new__
INSP.interpreter.configure.python.interpreter=組態 Python 解釋器
INSP.interpreter.interpreter.settings=解釋器設定
INSP.interpreter.invalid.python.interpreter.selected.for.module=為模組選擇的 Python 解釋器無效
INSP.interpreter.invalid.python.interpreter.selected.for.project=為專案選擇的 Python 解釋器無效
INSP.interpreter.no.python.interpreter.configured.for.module=未為模組組態 Python 解釋器
INSP.interpreter.no.python.interpreter.configured.for.project=未為專案組態 Python 解釋器
INSP.interpreter.pipenv.interpreter.associated.with.another.module=Pipenv 解釋器與另一個模組關聯\: ''{0}''
INSP.interpreter.pipenv.interpreter.associated.with.another.project=Pipenv 解釋器與另一個專案關聯\: ''{0}''
INSP.interpreter.pipenv.interpreter.not.associated.with.any.module=Pipenv 解釋器未與任何模組關聯
INSP.interpreter.pipenv.interpreter.not.associated.with.any.project=Pipenv 解釋器未與任何專案關聯
INSP.interpreter.python.has.reached.its.end.life.and.is.no.longer.supported.in.python.plugin=Python {0} 已達到壽命終止日期，不再受到 Python 延伸模組支援
INSP.interpreter.python.has.reached.its.end.of.life.and.is.no.longer.supported.in.pycharm=Python {0} 已達到壽命終止日期，不再受到 PyCharm 支援
INSP.interpreter.use.interpreter=使用 {0}
INSP.interpreter.use.suggested.interpreter=使用建議的解釋器
INSP.invalid.cast.message=將類型 ''{0}'' 轉換為類型 ''{1}'' 可能是錯誤的，因為其中一個類型無法賦值給另一個類型。如果這是有意為之，請先將表達式轉換為 ''{2}''。
INSP.list.creation.this.list.creation.could.be.rewritten.as.list.literal=多步列表初始化可被取代為列表字面量
INSP.mandatory.encoding.checkbox.enable.in.python.3=在 Python 3+ 中啟用
INSP.mandatory.encoding.label.encoding.comment.format=編碼註釋格式\:
INSP.mandatory.encoding.label.select.default.encoding=選擇預設編碼\:
INSP.mandatory.encoding.no.encoding.specified.for.file=未為檔案指定編碼
INSP.manual.to.auto.field.numbering=無法從手動欄位規範切換到自動欄位編號
INSP.message.single.quoted.docstring=應對 docstring 使用帶三個雙引號的字串。
INSP.method.may.be.static=方法 <code>\#ref</code> 可能為 'static'
INSP.method.parameters.metaclass.method.first.argument.name=元類別方法第一個實參的名稱
INSP.missing.parameter.in.docstring=docstring 中的缺失參數 {0}
INSP.missing.super.constructor.message=缺少對超類別 __init__ 的呼叫
INSP.missing.type.hints.add.type.hints=新增類型提示
INSP.missing.type.hints.add.type.hints.for=為 ''{0}'' 新增類型提示
INSP.missing.type.hints.checkbox.only.when.types.are.known=僅當類型已知時(從執行時收集或推斷)
INSP.missing.type.hints.type.hinting.missing.for.function.definition=函式定義缺少類型提示
INSP.must.have.first.parameter=方法必須有第一個參數，通常叫做 ''{0}''
INSP.named.tuple=無效的 'typing.NamedTuple' 定義
INSP.new.incompatible.to.init=簽名不相容 __init__
INSP.new.style.generics.are.not.allowed.inside.type.param.bounds=在類型參數的約束和邊界內不允許使用泛型類型
INSP.new.style.generics.assignment.expressions.not.allowed=不允許在具有類型參數列表的類別、函式和類型別名的宣告內使用賦值表達式
INSP.new.style.generics.classes.with.type.param.list.should.not.extend.generic=具有顯式類型參數列表的類別不應擴展 'Generic'
INSP.new.style.generics.extending.protocol.does.not.need.parameterization=擴展 'Protocol' 不需要在具有類型參數列表的類別中進行參數化
INSP.new.style.generics.mixing.old.style.and.new.style.type.vars.not.allowed=不允許混合傳統類型變數和新型類型變數
INSP.new.style.generics.old.style.type.vars.not.allowed.in.new.style.type.aliases=新型類型別名語句中不允許使用傳統 TypeVar
INSP.new.style.type.parameter.out.of.scope=類型變數 ''{0}'' 超出作用域
INSP.no.docstring=缺失 docstring
INSP.no.format.specifier.char=缺少格式說明符
INSP.non.ascii.char.non.ascii.character.in.file.but.no.encoding.declared=檔案中有非 ASCII 字元 ''{0}''，但未宣告編碼
INSP.none.function.assignment=函式 ''{0}'' 不返回任何內容
INSP.oldstyle.class.getattribute=老式類別包含 __getattribute__ 定義
INSP.oldstyle.class.slots=老式類別包含 __slots__ 定義
INSP.oldstyle.class.super=老式類別包含對 super 方法的呼叫
INSP.overloads.at.least.two.overloads.must.be.present=至少需要存在兩個 @overload-decorated {0,choice,0\#函式|1\#方法}
INSP.overloads.final.should.be.placed.on.the.implementation='@final' 應當放在實作中
INSP.overloads.final.should.be.placed.only.on.the.first.overload='@final' 應當只放在第一個多載上
INSP.overloads.override.should.be.placed.on.the.implementation='@override' 應當放在實作中
INSP.overloads.override.should.be.placed.only.on.the.first.overload='@override' 應當只放在第一個多載上
INSP.overloads.series.overloads.should.always.be.followed.by.implementation=一系列 @overload-decorated {0,choice,0\#函式|1\#方法}後應當始終跟著一個非 @overload-ed 實作
INSP.overloads.this.overload.signature.not.compatible.with.implementation=此 @overload-decorated {0,choice,0\#函式|1\#方法}的簽名與實作不相容
INSP.overloads.use.classmethod.inconsistently=多載中 @classmethod 的使用不一致
INSP.overloads.use.staticmethod.inconsistently=多載中 @staticmethod 的使用不一致
INSP.override.missing.super.method=缺少覆寫的 super 方法
INSP.package.requirements.add.import=新增 import
INSP.package.requirements.administrator.privileges.required=需要管理員權限
INSP.package.requirements.administrator.privileges.required.button.configure=組態
INSP.package.requirements.administrator.privileges.required.button.install.anyway=仍要安裝
INSP.package.requirements.administrator.privileges.required.description=將軟體套件安裝到 ''{0}'' 需要具備管理員權限。\n\n將每個專案的虛擬環境組態為專案解釋器，\n以避免將包安裝到檔案系統的受保護區域。
INSP.package.requirements.requirement.has.been.ignored=已忽略 ''{0}''
INSP.package.requirements.requirements.file.empty=要求檔案為空
INSP.package.requirements.requirements.have.been.ignored=已忽略要求
INSP.pandas.series.values.replace.with.tolist=推薦方法 Series.to_list()
INSP.pandas.truth.value.is.ambiguous.df=DataFrame 的真值不明確
INSP.pandas.truth.value.is.ambiguous.series=Series 的真值不明確
INSP.parameter(s).unfilled=參數未填
INSP.parameter.unfilled=參數 ''{0}'' 未填
INSP.pep8.coding.style.violation=PEP 8 編碼樣式違規
INSP.pep8.ignore.base.class=忽略基類別
INSP.pep8.ignore.method.names.for.descendants.of.class=忽略類別後代的方法名稱
INSP.pep8.naming.argument.name.should.be.lowercase=實參名稱應小寫
INSP.pep8.naming.camelcase.variable.imported.as.constant=駝峰式命名法變數作為常數匯入
INSP.pep8.naming.camelcase.variable.imported.as.lowercase=駝峰式命名法變數作為小寫匯入
INSP.pep8.naming.class.names.should.use.capwords.convention=類別名應使用 CapWords 約定
INSP.pep8.naming.column.name.excluded.base.classes=已排除的基類別\:
INSP.pep8.naming.column.name.ignored.errors=已忽略的錯誤\:
INSP.pep8.naming.constant.variable.imported.as.non.constant=常數變數作為非常數匯入
INSP.pep8.naming.function.name.should.be.lowercase=函式名稱應小寫
INSP.pep8.naming.lowercase.variable.imported.as.non.lowercase=小寫變數作為非小寫匯入
INSP.pep8.naming.variable.in.function.should.be.lowercase=函式中的變數應小寫
INSP.possible.callees=可能的被呼叫方
INSP.probably.mistyped.self=你不是指 'self' 嗎?
INSP.property.cannot.be.deleted=無法刪除屬性 ''{0}''
INSP.property.cannot.be.read=無法讀取屬性 ''{0}''
INSP.property.cannot.be.set=無法設定屬性 ''{0}''
INSP.protected.member.access.to.protected.member.of.class=存取類別的 protected 成員 {0}
INSP.protected.member.access.to.protected.member.of.module=存取模組的 protected 成員 {0}
INSP.protected.member.ignore.annotations=忽略註解
INSP.protected.member.ignore.test.functions=忽略測試函式
INSP.protected.member.name.not.declared.in.all=__all__ 中未宣告 ''{0}''
INSP.protocol.all.bases.protocol.must.be.protocols=協議的所有基礎必須為協議
INSP.protocol.element.type.incompatible.with.protocol=''{0}'' 的類型與 ''{1}'' 不相容
INSP.protocol.newtype.cannot.be.used.with.protocol.classes=NewType 不能與協議類別一起使用
INSP.protocol.only.runtime.checkable.protocols.can.be.used.with.instance.class.checks=僅 @runtime_checkable 協議可以與實例和類別檢查一起使用
INSP.python.suppressor.suppress.for.class=對類別禁止
INSP.python.suppressor.suppress.for.function=對函式禁止
INSP.python.suppressor.suppress.for.statement=對語句禁止
INSP.redeclared.name=已重新宣告上文定義的無用法的 ''{0}''
INSP.redeclared.type.alias=名稱 ''{0}'' 已定義
INSP.redundant.parens.ignore.argument.of.operator=忽略 % 運算符的實參
INSP.redundant.parens.ignore.empty.lists.of.base.classes=忽略基類別的空列表
INSP.redundant.parens.ignore.tuples=忽略元組
INSP.relative.import.relative.import.outside.package=軟體套件外部的相對匯入
INSP.requirements.ignore.packages.label=已忽略的軟體套件\:
INSP.requirements.package.containing.module.not.listed.in.project.requirements=專案要求中未列出包含模組 ''{0}'' 的軟體套件
INSP.requirements.package.requirements.not.satisfied=不滿足軟體套件{1,choice,1\#要求|2\#要求} {0} {1,choice,1\#|2\#}
INSP.setter.should.not.return=setter 不應返回值
INSP.setter.signature.advice=Setter 簽名應為 (self, value)
INSP.shadowing.builtins.ignore.built.ins.label=已忽略的內建物件\:
INSP.shadowing.builtins.shadows.built.in.name=隱藏內建名稱 ''{0}''
INSP.shadowing.names=正在從外部作用域隱藏名稱
INSP.shadows.name.from.outer.scope=從外部作用域隱藏名稱 ''{0}''
INSP.signature.mismatch=方法 ''{0}'' 的簽名與類別 ''{1}'' 中基方法的簽名不符合
INSP.simplify.boolean.check.ignore.comparison.to.zero=忽略與零的比較
INSP.simplify.chained.comparison=簡化鏈式比較
INSP.statement.effect.statement.having.no.effect.can.be.replaced.with.function.call=語句似乎無效，取代為函式呼叫即可生效
INSP.statement.effect.statement.seems.to.have.no.effect=語句似乎不起任何作用
INSP.str.format.can.not.use.star.in.formats.when.using.mapping=使用映射時，格式中不能使用 '*'
INSP.str.format.key.has.no.argument=鍵 ''{0}'' 沒有相應的實參
INSP.str.format.unexpected.argument.type=意外類型{0}
INSP.str.format.unsupported.format.character.b=不受支援的格式字元 'b'
INSP.strange.arg.want.callable=奇怪實參；應為可調用對象
INSP.stub.packages=存根軟體套件廣播程序
INSP.stub.packages.compatibility=不相容的存根軟體套件
INSP.stub.packages.compatibility.ignore=忽略
INSP.stub.packages.compatibility.ignored.packages.label=已忽略的存根軟體套件\:
INSP.stub.packages.compatibility.incompatible.packages.message=存根 ''{0}'' 與原始軟體套件不相容。
INSP.stub.packages.compatibility.install=安裝
INSP.symbol.is.not.callable=''{0}'' 不可呼叫
INSP.too.broad.exception.clause=異常子句過於寬泛
INSP.too.few.args.for.fmt.string=格式字串的實參太少
INSP.too.few.keys=映射鍵太少
INSP.too.many.args.for.fmt.string=格式字串的實參太多
INSP.trailing.semicolon=語句中的尾隨分號
INSP.tuple.assignment.balance.need.more.values.to.unpack=需要更多值才能解包
INSP.tuple.assignment.balance.only.one.starred.expression.allowed.in.assignment=賦值中僅允許帶一個星號的表達式
INSP.tuple.assignment.balance.too.many.values.to.unpack=值太多，無法解包
INSP.tuples.never.assign.items=元組不支持專案賦值
INSP.type.checker.access.to.generic.instance.variables.via.class.is.ambiguous=通過類別存取泛型實例變數的方式不明確
INSP.type.checker.expected.matched.type.got.type.instead=應為類型 ''{0}'' (符合的泛型類型 ''{1}'')，但實際為 ''{2}''
INSP.type.checker.expected.type.from.dunder.set.got.type.instead=應為類型 ''{0}'' (來自 ''__set__'')，但實際為 ''{1}''
INSP.type.checker.expected.type.got.type.instead=應為類型 ''{0}''，但實際為 ''{1}''
INSP.type.checker.expected.types.prefix=可能的類型\:
INSP.type.checker.init.should.return.none=__init__ 應返回 None
INSP.type.checker.only.concrete.class.can.be.used.where.matched.protocol.expected=在應為 ''{0}'' (符合的泛型類型 ''{1}'')協議的地方，只能使用一個具體類別
INSP.type.checker.only.concrete.class.can.be.used.where.protocol.expected=在應為 ''{0}'' 協議的地方，只能使用一個具體類別
INSP.type.checker.tuple.index.out.of.range=元組索引超出範圍
INSP.type.checker.type.does.not.have.expected.attribute=類型 ''{0}'' 沒有預期的{1, choice,1\#特性|2\#特性} {2}
INSP.type.checker.typed.dict.extra.key=TypedDict ''{1}'' 的額外鍵 ''{0}''
INSP.type.checker.typed.dict.missing.keys=TypedDict ''{0}'' 缺少{1,choice,1\#鍵|2\#鍵}\: {2}
INSP.type.checker.unexpected.argument.from.paramspec=意外實參(來自 ParamSpec ''{0}'')
INSP.type.checker.unexpected.types.prefix=意外類型\:
INSP.type.checker.unfilled.parameter.for.paramspec=參數 ''{0}'' 未填(來自 ParamSpec ''{1}'')
INSP.type.checker.unfilled.vararg=參數 ''{0}'' 未填，應為 ''{1}''
INSP.type.checker.yield.from.async.generator=無法在 ''{0}'' 中使用 yield from，請改用 ''async for''
INSP.type.checker.yield.from.send.type.mismatch=應為 send 類型 ''{0}''，但實際為 ''{1}''
INSP.type.checker.yield.type.mismatch=應為 yield 類型 ''{0}''，但實際為 ''{1}''
INSP.type.hints.annotated.must.be.called.with.at.least.two.arguments=必須至少使用兩個實參呼叫 'Annotated'
INSP.type.hints.argument.to.paramspec.must.be.string.equal.to.variable.name='ParamSpec()' 的實參必須為字串，且該字串與被賦予該字串的變數名稱相同
INSP.type.hints.argument.to.typevar.must.be.string.equal.to.variable.name='TypeVar()' 的實參必須為字串，且該字串與被賦予該字串的變數名稱相同
INSP.type.hints.argument.to.typevar.tuple.must.be.string.equal.to.variable.name='TypeVarTuple()' 的實參必須為字串，且該字串與為它指定的變數名稱相同
INSP.type.hints.at.most.one.unpacked.tuple=類型實參列表最多可以有一個已解壓縮的 TypeVarTuple 或無界元組
INSP.type.hints.bivariant.type.variables.are.not.supported=不支持雙變數類型變數
INSP.type.hints.builtin.cannot.be.parameterized.directly=無法直接參數化內建 ''{0}''
INSP.type.hints.cannot.be.used.in.default.type.of.type.var=''{0}'' 不能用於 TypeVar 的預設類型
INSP.type.hints.cannot.inherit.from.generic.multiple.times=無法從 'Generic[…]' 多次繼承
INSP.type.hints.cannot.inherit.from.plain.generic=不能從普通的 'Generic' 繼承
INSP.type.hints.cannot.use.contravariant.in.return.type=逆變類型變數不能用於函式返回類型
INSP.type.hints.cannot.use.covariant.in.function.param=協變類型變數不能用於參數類型
INSP.type.hints.circular.reference=迴圈參照
INSP.type.hints.concatenate.can.only.be.used.inside.callable=在此上下文中，'Concatenate' 只能用作 'Callable' 的第一個實參
INSP.type.hints.default.type.do.not.match.bounds=TypeVar 的預設類型不是綁定的子類型
INSP.type.hints.default.type.do.not.match.constraints=TypeVar 的預設類型必須是約束類型之一
INSP.type.hints.default.type.must.be.type.expression=預設類型必須是類型表達式
INSP.type.hints.default.type.of.param.spec.must.be.param.spec.or.list.of.types=ParamSpec 的預設類型必須是 ParamSpec 類型或類型列表
INSP.type.hints.default.type.of.type.var.tuple.must.be.unpacked=TypeVarTuple 的預設類型必須已解壓縮
INSP.type.hints.default.type.refers.to.type.var.out.of.scope=此類型參數的預設類型參照了一個或多個超出作用域的類型變數
INSP.type.hints.default.type.var.cannot.follow.type.var.tuple=具有預設值的 TypeVar 不能跟隨 TypeVarTuple
INSP.type.hints.expected.a.type=應為類型
INSP.type.hints.forward.reference.in.union=具有前向參照的聯合體類型註解必須完全用引號括起來
INSP.type.hints.generic.or.protocol.should.list.all.type.variables=''Generic[...]'' 或 ''Protocol[...]'' 應列出所有類型變數({0})
INSP.type.hints.generic.type.alias.is.not.generic.or.already.parameterized=類型別名為非泛型或者已專用化
INSP.type.hints.generics.should.be.specified.through.square.brackets=泛型應通過中括號指定
INSP.type.hints.illegal.callable.format='Callable' 必須作為 'Callable[[arg, …], result]' 使用
INSP.type.hints.illegal.first.parameter='Callable' 第一個參數必須為參數表達式
INSP.type.hints.illegal.literal.parameter=可以使用字面量 int、位元組和 unicode 字串、bool、枚舉值、None、其他字面量類型或其他字面量類型的類型別名參數化 'Literal'
INSP.type.hints.invalid.type.argument=無效的類型實參
INSP.type.hints.invalid.type.expression=無效的類型表達式
INSP.type.hints.invalid.type.self=無效的類型 'self'
INSP.type.hints.literal.must.have.at.least.one.parameter='Literal' 必須至少有一個參數
INSP.type.hints.metaclass.cannot.be.generic=元類別不能為泛型
INSP.type.hints.new.type.type.cannot.be.used.in.isinstance.tests=NewType 類型不能與實例和類別檢查一起使用
INSP.type.hints.non.default.type.vars.cannot.follow.defaults=非預設 TypeVar 不能跟隨具有預設值的 TypeVar
INSP.type.hints.non.self.attribute.could.not.be.type.hinted=非 self 特性不能有類型提示
INSP.type.hints.parameterized.generics.cannot.be.used.with.instance.class.checks=參數化泛型不能與實例和類別檢查一起使用
INSP.type.hints.parameters.to.generic.must.all.be.type.variables=''{0,choice,0\#Generic|1\#Protocol}[...]' 的參數必須全部為類型變數
INSP.type.hints.parameters.to.generic.must.all.be.unique='Generic[…]' 的參數必須全部唯一
INSP.type.hints.parameters.to.generic.types.cannot.contain.more.than.one.unpacking=泛型的參數不能包含多個解壓縮
INSP.type.hints.parameters.to.generic.types.must.be.types=泛型類型的參數必須為類型
INSP.type.hints.paramspec.expects.string.literal.as.first.argument='ParamSpec()' 的第一個實參應為字串字面量
INSP.type.hints.self.use.for.cls.parameter.with.self.annotation=如果 'cls' 參數未使用 'Self' 註解，則不能使用 'Self'
INSP.type.hints.self.use.for.self.parameter.with.self.annotation=如果 'self' 參數未使用 'Self' 註解，則不能使用 'Self'
INSP.type.hints.self.use.in.staticmethod=不能在 staticmethod 中使用 'Self'
INSP.type.hints.self.use.outside.class=不能在類別外使用 'Self'
INSP.type.hints.single.typevar.constraint.not.allowed=不允許單個約束
INSP.type.hints.some.type.variables.are.already.in.use.by.outer.scope=某些類型變數({0})被外部作用域使用
INSP.type.hints.type.alias.cannot.be.parameterized=無法參數化 'TypeAlias'
INSP.type.hints.type.alias.invalid.assigned.value=類型別名的賦值必須是正確的類型
INSP.type.hints.type.alias.must.be.immediately.initialized=類型別名必須立即初始化
INSP.type.hints.type.alias.must.be.top.level.declaration=類型別名必須是頂層宣告
INSP.type.hints.type.alias.must.be.used.as.standalone.type.hint='TypeAlias' 必須用作獨立的類型提示
INSP.type.hints.type.arguments.class.is.already.parameterized=類別 ''{0}'' 已參數化
INSP.type.hints.type.arguments.do.not.match.type.parameters.of.alias=傳遞的類型實參與類型別名 ''{0}'' 的類型參數不符合
INSP.type.hints.type.arguments.do.not.match.type.parameters.of.class=傳遞的類型實參與類別 ''{1}'' 的類型實參 {0} 不符合
INSP.type.hints.type.cannot.be.used.with.instance.class.checks=''{0}'' 不能與實例和類別檢查一起使用
INSP.type.hints.type.comment.cannot.be.matched.with.unpacked.variables=類型註釋不能與解包的變數相符合
INSP.type.hints.type.hint.is.not.valid=類型提示無效或參照的表達式類型不正確
INSP.type.hints.type.parameter.is.already.in.use.by.outer.scope=類型參數 ''{0}'' 已被外部作用域使用
INSP.type.hints.type.self.not.supertype.its.class=self ''{0}'' 的類型不是其類別 ''{1}'' 的父類型
INSP.type.hints.type.signature.has.too.few.arguments=類型簽名的實參太少
INSP.type.hints.type.signature.has.too.many.arguments=類型簽名的實參太多
INSP.type.hints.type.specified.both.in.type.comment.and.annotation=同時在類型註釋和註解中指定了類型
INSP.type.hints.type.statement.incorrect.scope='type' 語句只能在模組或類別作用域內使用
INSP.type.hints.type.var.tuple.must.always.be.unpacked=TypeVarTuple 必須始終為已解壓縮
INSP.type.hints.type.variables.cannot.be.used.with.instance.class.checks=類型變數不能與實例和類別檢查一起使用
INSP.type.hints.type.variables.must.not.be.redefined=不得重新定義類型變數
INSP.type.hints.typeIs.does.not.match=TypeIs ''{0}'' 的返回值類型與第一個參數 ''{1}'' 的類型不一致
INSP.type.hints.typeIs.has.zero.parameters=使用者定義的 TypeGuard 或 TypeIs 函式必須至少有一個參數
INSP.type.hints.typed.dict.is.not.allowed.as.a.bound.for.a.type.var=不允許將 TypedDict 用作 TypeVar 的邊界
INSP.type.hints.typed.dict.type.cannot.be.used.in.isinstance.tests=TypedDict 類型不能與實例和類別檢查一起使用
INSP.type.hints.typevar.constraints.cannot.be.combined.with.bound=約束不能與 bound\=… 結合使用
INSP.type.hints.typevar.constraints.cannot.be.parametrized.by.type.variables=約束無法被類型變數參數化
INSP.type.hints.typevar.expects.string.literal.as.first.argument='TypeVar()' 的第一個實參應為字串字面量
INSP.type.hints.typevar.expression.must.be.always.directly.assigned.to.variable='TypeVar()' 表達式始終必須直接賦值給變數
INSP.type.hints.typevar.tuple.expects.string.literal.as.first.argument='TypeVarTuple()' 的第一個實參應為字串字面量
INSP.type.hints.typing.self.cannot.be.parameterized='Self' 不能參數化
INSP.type.hints.unbound.type.variable=未綁定的類型變數
INSP.typeddict.cannot.add.non.string.key.to.typeddict=無法向 TypedDict“{0}”新增非字串鍵
INSP.typeddict.cannot.overwrite.typeddict.field=無法覆蓋 TypedDict 欄位
INSP.typeddict.cannot.overwrite.typeddict.field.while.merging=合併時無法覆蓋 TypedDict 欄位 ''{0}''
INSP.typeddict.expected.a.dictionary.literal=應為字典字面量
INSP.typeddict.first.argument.has.to.match.variable.name=第一個實參必須符合變數名稱
INSP.typeddict.invalid.statement.in.typeddict.definition.expected.field.name.field.type=TypedDict 定義中的語句無效；應為 'field_name\: field_type'
INSP.typeddict.key.cannot.be.deleted=無法刪除 TypedDict ''{1}'' 的鍵 ''{0}''
INSP.typeddict.key.should.be.string=鍵應為字串
INSP.typeddict.qualifiers.cannot.be.used.outside.typeddict.definition=''{0}'' 只能在 TypedDict 定義中使用
INSP.typeddict.read.only.cannot.be.nested=ReadOnly[] 不能嵌套
INSP.typeddict.required.and.not.required.cannot.be.nested=Required[] 和 NotRequired[] 不能嵌套
INSP.typeddict.required.notrequired.must.have.exactly.one.type.argument=''{0}'' 必須只有一個類型實參
INSP.typeddict.right.hand.side.values.are.not.supported.in.typeddict=TypedDict 不支持右側值
INSP.typeddict.specifying.metaclass.not.allowed.in.typeddict=TypedDict 中不允許指定元類別
INSP.typeddict.this.operation.might.break.typeddict.consistency=此動作可能會破壞 TypedDict 一致性
INSP.typeddict.total.value.must.be.true.or.false='total' 的值必須為 True 或 False
INSP.typeddict.typeddict.cannot.have.key=TypedDict“{0}”不能具有鍵 ''{1}''
INSP.typeddict.typeddict.cannot.inherit.from.non.typeddict.base.class=TypedDict 無法從非 TypedDict 基類別繼承
INSP.typeddict.typeddict.field.is.readonly=TypedDict 鍵“{0}”為 ReadOnly
INSP.typeddict.typeddict.has.no.key=TypedDict“{0}”沒有鍵 ''{1}''
INSP.typeddict.typeddict.has.no.keys=TypedDict“{0}”沒有鍵({1})
INSP.typeddict.typeddict.key.must.be.string.literal.expected.one=TypedDict 鍵必須為字串字面量；應為({0})之一
INSP.typeddict.unexpected.argument.for.__init_subclass__.of.TypedDict=TypedDict 的 __init_subclass__ 存在意外實參 ''{0}''
INSP.typeddict.value.must.be.type=值必須為某種類型
INSP.unbound.function.too.large=函式 ''{0}'' 太大，無法分析
INSP.unbound.local.variable=區域變數 ''{0}'' 可能在賦值前參照
INSP.unbound.name.undefined=名稱 ''{0}'' 可能未定義
INSP.unbound.nonlocal.variable=非區域變數 ''{0}'' 必須綁定在外部函式作用域中
INSP.unexpected.arg=意外實參
INSP.unexpected.arg(s)=意外實參
INSP.unexpected.parameter.in.docstring=docstring 中的意外參數 {0}
INSP.unnecessary.backslash.unnecessary.backslash.in.expression=表達式中有不必要的反斜杠
INSP.unnecessary.cast.message=不必要的轉換；類型已經是 ''{0}''
INSP.unreachable.code=此程式碼不可到達
INSP.unresolved.refs.cannot.find.reference.in.type=在 ''{1}'' 中找不到參照 ''{0}''
INSP.unresolved.refs.class.does.not.define.operator=類別 ''{0}'' 未定義 ''{1}''，所以不能對其實例使用 ''{2}'' 運算符
INSP.unresolved.refs.class.object.has.no.attribute=''{0}'' 物件沒有特性 ''{1}''
INSP.unresolved.refs.ignore.references.label=已忽略的參照\:
INSP.unresolved.refs.import.resolves.to.its.containing.file=匯入解析為其包含檔案
INSP.unresolved.refs.module.not.found=找不到模組 ''{0}''
INSP.unresolved.refs.unresolved.attribute.for.class=類別 ''{1}'' 的未解析的特性參照 ''{0}''
INSP.unresolved.refs.unresolved.attribute.in.union.type=''{1}'' 的成員 ''{0}'' 沒有特性 ''{2}''
INSP.unresolved.refs.unresolved.reference=未解析的參照 ''{0}''
INSP.unsupported.format.character=格式字元 ''{0}'' 不受支援
INSP.unused.imports.try.except.import.error=包含 ''except ImportError'' 的 try 塊中的 ''{0}'' 也應在 except 塊中定義
INSP.unused.imports.unused.import.statement=未使用的 import 語句 <code>\#ref</code>
INSP.unused.locals.ignore.lambda.parameters=忽略 lambda 參數
INSP.unused.locals.ignore.range.iteration.variables=忽略範圍迭代變數
INSP.unused.locals.ignore.variables.starting.with=忽略以 '_' 開頭的變數
INSP.unused.locals.ignore.variables.used.in.tuple.unpacking=忽略元組解包中使用的變數
INSP.unused.locals.local.class.isnot.used=未使用區域類別 ''{0}''
INSP.unused.locals.local.function.isnot.used=未使用區域函式 ''{0}''
INSP.unused.locals.local.variable.isnot.used=未使用區域變數 ''{0}'' 的值
INSP.unused.locals.parameter.isnot.used=未使用參數 ''{0}'' 的值
INSP.unused.locals.replace.with.wildcard=取代為 _
INSP.unused.locals.type.alias.isnot.used=未使用本地類型別名 ''{0}''
INSP.unused.locals.type.parameter.isnot.used=類型參數 ''{0}'' 未使用
INSP.use.fixture.without.declaration.in.test.function=測試函式或 ''@pytest.mark.usefixtures'' 標記未請求固定例程 ''{0}''
INSP.usually.named=這些方法的第一個參數通常叫做 ''{0}''
INSP.usually.named.self=方法的第一個參數通常叫做 'self'
INTN.NAME.add.type.hint.for.variable=為變數新增類型提示
INTN.NAME.add.type.hints.for.function=為函式新增類型提示
INTN.NAME.convert.between.f.string.t.string=在 f-string 和 t-string 之間轉換
INTN.NAME.convert.collection.literal=將集合轉換為{0}
INTN.NAME.convert.import.qualify=將 'from module import' 轉換為 'import module'
INTN.NAME.convert.import.unqualify=將 'import module' 轉換為 'from module import'
INTN.NAME.convert.type.comment.to.variable.annotation=將類型註釋轉換為變數註解
INTN.NAME.demorgan.law=德摩根定律
INTN.NAME.flip.comparison=翻轉比較
INTN.NAME.hide.type.annotations=隱藏類型註解
INTN.NAME.insert.docstring.stub=插入 docstring 存根
INTN.NAME.join.if=聯接 'if' 語句
INTN.NAME.negate.comparison=求反比較
INTN.NAME.specify.type.in.annotation=使用註解指定參照類型
INTN.NAME.specify.type.in.docstring=指定 docstring 中參照的類型
INTN.NAME.split.if=拆分 'if' 語句
INTN.NAME.toggle.import.alias=使用 import 別名進行切換
INTN.add.import.alias=新增別名
INTN.add.import.alias.dialog.message=''{0}'' 的別名\:
INTN.add.import.alias.title=新增別名
INTN.add.import.alias.to.name=新增 ''{0}'' 的別名
INTN.add.parameters.to.docstring=向 docstring 新增參數
INTN.add.qualifier=新增 ''{0}'' 限定符
INTN.add.type.hint.for.variable=為變數 ''{0}'' 新增類型提示
INTN.add.type.hint.for.variable.PEP484.incompatible.type=類型 ''{0}'' 不能以 PEP 484 格式內聯表示
INTN.add.type.hints.for.function=為函式 ''{0}'' 新增類型提示
INTN.category.python=Python
INTN.convert.absolute.to.relative=將絕對匯入轉換為相對匯入
INTN.convert.builtin.import=將內建模組匯入轉換為支援的形式
INTN.convert.collection.literal=將{0}轉換為{1}
INTN.convert.dict.constructor.to.dict.literal=將 dict 建構函式轉換為 dict 字面量
INTN.convert.dict.literal.to.dict.constructor=將 dict 字面量轉換為 dict 建構函式
INTN.convert.except.to=將 'except exceptClass, Target' 轉換為 'except exceptClass as Target'
INTN.convert.f.string.to.t.string=將 f-string 轉換為 t-string
INTN.convert.lambda.to.function=將 lambda 轉換為函式
INTN.convert.method.to.property=將方法轉換為屬性
INTN.convert.relative.to.absolute=將相對匯入轉換為絕對匯入
INTN.convert.static.method.to.function=將 static 方法轉換為函式
INTN.convert.t.string.to.f.string=將 t-string 轉換為 f-string
INTN.convert.to.from.import=轉換為 ''from {0} import {1}''
INTN.convert.to.fstring.literal=轉換為格式化字串字面量
INTN.convert.to.plain.import=轉換為 ''import {0}''
INTN.convert.type.comment.to.variable.annotation=轉換為變數註解
INTN.convert.variadic.param=將可變形參轉換為正常參數
INTN.flip.comparison=翻轉 ''{0}''
INTN.flip.comparison.to.operator=將 ''{0}'' 翻轉為 ''{1}''
INTN.format.operator.to.method=將格式運算符轉換為 'str.format' 方法呼叫
INTN.hide.type.annotations=隱藏類型註解
INTN.insert.assertion=插入類型斷言
INTN.insert.docstring.stub=插入 docstring 存根
INTN.invert.if.condition=反轉 'if' 條件
INTN.join.if=聯接兩個 'if' 語句
INTN.multiple.usages.of.import.found=已找到 import 的多個用法
INTN.negate.comparison=將 ''{0}'' 求反為 ''{1}''
INTN.quoted.string=將帶單引號的字串轉換為帶雙引號的字串，反之亦然
INTN.quoted.string.double.to.single=將帶雙引號的字串轉換為帶單引號的字串
INTN.quoted.string.single.to.double=將帶單引號的字串轉換為帶雙引號的字串
INTN.remove.import.alias=移除別名 ''{0}''
INTN.remove.qualifier=移除 ''{0}'' 限定符
INTN.remove.qualifier.from.all.usages=從所有用法中移除限定符
INTN.remove.qualifier.from.this.name=從此名稱中移除限定符
INTN.replace.backquote.expression=取代反引號表達式
INTN.replace.list.comprehensions=將列表推導式轉換為支援的形式
INTN.replace.list.comprehensions.with.for=將列表推導式轉換為 'for' 迴圈
INTN.replace.noteq.operator=取代不等運算符
INTN.replace.octal.numeric.literal=將八進制數字字面量轉換為支援的形式
INTN.replace.plus.with.format.operator=將 + 取代為字串格式設定運算符
INTN.replace.plus.with.str.format=將 + 取代為 str.format 方法呼叫
INTN.replace.raise.statement=將 raise 語句轉換為支援的形式
INTN.replace.with.method=取代為 str.format 方法呼叫
INTN.specify.return.type.in.annotation=使用註解指定返回值類型
INTN.specify.return.type.in.docstring=指定 docstring 中的返回值類型
INTN.specify.type.in.annotation=使用註解指定參照類型
INTN.specify.type.in.docstring=指定 docstring 中的參照類型
INTN.split.if=拆分成 2 條 'if' 語句
INTN.string.concatenation.to.format=將字串串聯取代為 'str.format'
INTN.transform.into.if.else.statement=將條件表達式轉換為 'if/else' 語句
INTN.triple.quoted.string=將三引號字串轉換為帶單引號的字串
INTN.yield.from=將含有 'yield' 的顯式迭代轉換為 'yield from' 表達式
QDOC.accessor.kind=存取器類型\:
QDOC.assigned.to=賦值給\:
QDOC.attributes=特性\:
QDOC.built.in.description=內建描述
QDOC.class=類別
QDOC.class.attribute={1} 的類別特性 {0}
QDOC.copied.from=複製自\:
QDOC.directory.name=目錄“{0}”
QDOC.file.name=檔案“{0}”
QDOC.inferred.type.name=推斷類型\: {0}
QDOC.instance.attribute={1} 的實例特性 {0}
QDOC.keyword.args=關鍵字實參\:
QDOC.module.name=模組 {0}
QDOC.module.path.unknown=(模組路徑未知)
QDOC.not.defined.in.parentheses=(未定義)
QDOC.package.name=軟體套件 {0}
QDOC.parameter.name=參數“{0}”
QDOC.parameter.name.of.link={1} 的參數 {0}
QDOC.parameter.of.function.name=函式“{1}”的參數“{0}”
QDOC.parameter.of.method.name=方法“{1}”的參數“{0}”
QDOC.params=參數\:
QDOC.property.getter=屬性 getter
QDOC.property.name.of.link={1} 的屬性 {0}
QDOC.python.3.sdk.needed.to.render.docstrings=需要已組態的本地 Python 3 SDK 來呈現 docstring。
QDOC.raises=引發\:
QDOC.returns=返回值\:
QDOC.type.alias.statement.name.of.link={1} 的類型別名語句 {0}
QDOC.type.parameter.kind=種類\:
QDOC.type.parameter.name=類型參數 {0}
QDOC.type.parameter.name.of.link=類型參數 {0}/{1}
QDOC.variable.name=變數“{0}”
QFIX.NAME.add.exception.base=新增 Exception 基類別
QFIX.NAME.add.field.to.class=將欄位新增到類別
QFIX.NAME.add.method.to.class=將方法新增到類別
QFIX.NAME.add.specifier=新增格式說明符字元
QFIX.NAME.auto.import=匯入
QFIX.NAME.convert.builtin=轉換內建模組 import
QFIX.NAME.create.function.in.module=在模組中建立函式
QFIX.NAME.docstring=修正 docstring
QFIX.NAME.ignore.errors.like.this=忽略此類別錯誤
QFIX.NAME.ignore.requirements=忽略{0,choice,1\#要求|2\#要求}
QFIX.NAME.ignore.shadowed.built.in.name=忽略已被隱藏的內建名稱
QFIX.NAME.install.and.import.package=安裝並匯入軟體套件 ''{0}''
QFIX.NAME.install.requirements=安裝{0,choice,1\#要求|2\#要求}
QFIX.NAME.local.auto.import=本地匯入
QFIX.NAME.make.function=從方法中生成函式
QFIX.NAME.make.function.return.type=使函式返回推斷的類型
QFIX.NAME.make.list=將元組取代為列表
QFIX.NAME.make.static=將方法設為 static
QFIX.NAME.move.except.up=上移 except 子句
QFIX.NAME.remove.argument=移除實參
QFIX.NAME.remove.assignment=移除賦值
QFIX.NAME.remove.assignment.target=移除賦值目標
QFIX.NAME.remove.call=移除呼叫
QFIX.NAME.remove.dict.key=移除此鍵
QFIX.NAME.remove.exception.target=移除異常目標
QFIX.NAME.remove.parameter=移除參數
QFIX.NAME.remove.statement=移除語句
QFIX.NAME.remove.string.prefix=移除前綴
QFIX.NAME.remove.underscores.in.numeric=移除數字字面量中的下劃線
QFIX.NAME.remove.with.target=移除 'with' 目標
QFIX.NAME.rename.argument=重新命名實參
QFIX.NAME.rename.parameter=重新命名參數
QFIX.NAME.replace.with.true.or.false=取代為 True 或 False
QFIX.NAME.simplify.boolean.expression=簡化布爾表達式
QFIX.NAME.unpack.type.var.tuple=解壓縮 TypeVarTuple
QFIX.NAME.unresolved.reference.add.param=建立參照參數
QFIX.NAME.unresolved.reference.create.function=建立函式 ''{0}''
QFIX.NAME.update.parameters=更新參數
QFIX.action.failed=動作失敗
QFIX.add.encoding=新增編碼宣告
QFIX.add.explicit.return.none=新增顯式 'return None'
QFIX.add.field.to.class=將欄位 ''{0}'' 新增到類別 {1}
QFIX.add.field.to.class.popup.content.added.init=已將 __init__ 新增到類別 <code>{0}</code><br/>，以適應新字段 <code>{1}</code>
QFIX.add.fixture.to.test.function.parameters.list=將固定例程新增到測試函式參數
QFIX.add.from.future.import.annotations=新增 'from __future__ import annotations'
QFIX.add.global=新增全域語句
QFIX.add.imported.package.to.declared.packages=將 "{0}" 軟體套件新增到必要組件中…
QFIX.add.imported.packages.to.requirements=將匯入的軟體套件新增到需求中…
QFIX.add.intermediate.cast=新增轉換({0}, ...)
QFIX.add.method.to.class=將方法 {0}() 新增到類別 {1}
QFIX.add.parameter.self=新增參數 ''{0}''
QFIX.add.property=新增欄位的屬性
QFIX.add.qualifier=新增限定符
QFIX.add.super=新增超類別呼叫
QFIX.augment.assignment=將賦值取代為增強賦值
QFIX.auto.import.import.name=匯入 ''{0}''
QFIX.auto.import.import.this.name=匯入此名稱
QFIX.chained.comparison=簡化鏈式比較
QFIX.change.base.class=更改基類別
QFIX.classic.class.transform=從物件繼承
QFIX.convert.indents=轉換縮排
QFIX.convert.indents.to.spaces=將縮排轉換為空格
QFIX.convert.indents.to.tabs=將縮排轉換為制表符
QFIX.convert.into.async.function=轉換為異步函式
QFIX.convert.single.quoted.docstring=將 docstring 轉換為帶三個雙引號的字串形式
QFIX.convert.to.new.style=轉換為新樣式類別
QFIX.coroutine.is.not.awaited=未等待協程
QFIX.create.class=建立類別
QFIX.create.class.0=建立類別 ''{0}''
QFIX.create.class.in.module=在模組 {1} 中建立類別 ''{0}''
QFIX.create.function.in.module=在模組 {1} 中建立函式 {0}()
QFIX.create.property=建立屬性
QFIX.default.argument=取代可變預設實參
QFIX.dict.creation=取代字典建立
QFIX.docstring.add.parameter=新增 docstring 參數 ''{0}''
QFIX.docstring.insert.stub=插入 docstring
QFIX.docstring.remove.parameter=移除 docstring 參數 ''{0}''
QFIX.failed.to.add.field=<br/>無法新增欄位\!<br/><br/>
QFIX.failed.to.add.function=<br/>無法新增函式\!<br/><br/>
QFIX.failed.to.add.method=<br/>無法新增方法\!<br/><br/>
QFIX.ignore.shadowed.built.in.name=忽略隱藏的內建名稱“{0}”
QFIX.install.and.import.package=安裝並匯入軟體套件
QFIX.introduce.variable=為語句引入變數
QFIX.list.creation=取代為列表字面量
QFIX.local.auto.import.import.locally=本地{0}
QFIX.make.function.return.type=使 ''{0}'' 返回 ''{1}''
QFIX.make.public=設為 public
QFIX.move.attribute=將特性移至 __init__ 方法
QFIX.move.from.future.import=將 'from __future__ import' 移至正確位置
QFIX.optimize.imports=最佳化 import
QFIX.pandas.series.values.replace.with.tolist=將 list(Series.values) 取代為 Series.to_list()
QFIX.pandas.truth.value.is.ambiguous.emptiness.check=取代為明確的空性檢查
QFIX.pandas.truth.value.is.ambiguous.none.check=取代為明確的 None 檢查
QFIX.redundant.parentheses=移除冗餘圓括號
QFIX.remove.annotation=移除註解
QFIX.remove.argument.equal.default=移除等於預設值的實參
QFIX.remove.cast.call=移除 'cast' 呼叫
QFIX.remove.decorator=移除裝飾器
QFIX.remove.function.annotations=移除函式註解
QFIX.remove.generic.parameters=移除泛型參數
QFIX.remove.square.brackets=移除中括號
QFIX.remove.string.prefix=移除前導 {0}
QFIX.remove.trailing.semicolon=移除尾隨分號
QFIX.remove.trailing.suffix=移除尾隨後綴
QFIX.remove.type.comment=移除類型註釋
QFIX.remove.unnecessary.backslash=移除表達式中不必要的反斜杠
QFIX.rename.parameter=重命名為 ''{0}''
QFIX.rename.unresolved.reference=重新命名參照
QFIX.replace.equality=取代相等
QFIX.replace.function.set.with.literal=將函式呼叫取代為集合字面量
QFIX.replace.star.by.unpack=取代為 typing_extensions.Unpack
QFIX.replace.with.old.union.style=取代為舊式聯合體
QFIX.replace.with.return.none=取代為 'return None'
QFIX.replace.with.square.brackets=取代為中括號
QFIX.replace.with.target.name=取代為目標名稱
QFIX.replace.with.true.or.false=取代為 {0}
QFIX.replace.with.type.name=取代為類型名稱
QFIX.replace.with.typing.alias=取代為類型別名
QFIX.simplify.boolean.expression=將布爾表達式取代為 ''{0}''
QFIX.statement.effect=取代為函式呼叫
QFIX.surround.with.square.brackets=使用中括號包圍
QFIX.unresolved.reference=將 ''{0}'' 取代為 ''{1}.{0}''
QFIX.unresolved.reference.add.param=建立參數 ''{0}''
QFIX.unresolved.reference.create.function=建立函式
QFIX.use.property=使用此欄位的屬性
custom.type.mimic.name=基於 {0} 的動態類別
debugger.cleaning.signature.cache=正在清理動態收集類型的快取
element.presentation.location.string.in.class=({1}中的{0})
element.presentation.location.string.in.class.stub=({1}存根中的{0})
element.presentation.location.string.module=({0})
element.presentation.location.string.module.stub=({0}存根)
filetype.python.docstring.description=Python docstring
filetype.python.function.type.annotation.description=Python PEP-484 函式類型註釋
filetype.python.type.hint.description=Python PEP-484 類型提示
find.usages.class=類別
find.usages.function=函式
find.usages.imported.module.alias=已匯入的模組別名
find.usages.keyword.argument=關鍵字實參
find.usages.method=方法
find.usages.parameter=參數
find.usages.unnamed=<unnamed>
find.usages.variable=變數
ignore.overridden.functions=忽略被覆寫的函式
packaging.could.not.parse.relation=無法解析來自以下的關係\: {0}
python.docstring.format=docstring 格式\:
python.docstring.select.type=選擇 Docstring 類型
python.find.usages=尋找用法
python.find.usages.base.method.question=方法 {0} 覆寫類別 {1} 的方法。\n是否要尋找基方法的用法?
python.find.usages.untyped.probable.usage=(可能的)無類型用法
python.find.usages.usage.in.import.statement=在 import 語句中的用法
python.find.usages.usage.in.isinstance=在 isinstance() 中的用法
python.find.usages.usage.in.superclass.list=在超類別列表中的用法
python.find.usages.usage.in.type.hint=類型提示中的用法
refactoring.extract.method=提取方法
refactoring.extract.method.error.bad.selection=無法使用所選元素執行提取方法重構
refactoring.extract.method.error.class.level=無法在類別級別執行重構
refactoring.extract.method.error.empty.fragment=無法從空程式碼段執行重構
refactoring.extract.method.error.interrupted.execution.flow=執行流中斷時無法執行重構
refactoring.extract.method.error.local.variable.modifications=無法從程式碼段內包含區域變數修改的表達式執行重構。
refactoring.extract.method.error.local.variable.modifications.and.returns=無法從程式碼段內包含區域變數修改和返回指令的表達式執行重構
refactoring.extract.method.error.name.clash=該方法名稱與現有名稱衝突
refactoring.extract.method.error.returns=無法提取程式碼段內包含返回指令的方法
refactoring.extract.method.error.star.import=無法使用程式碼塊內的星號 import 語句執行重構
refactoring.extract.method.error.yield=無法使用程式碼塊內的 'yield' 語句執行重構
refactoring.inline.all.border.title=內聯
refactoring.inline.all.keep.declaration=內聯所有呼叫並保留宣告
refactoring.inline.all.remove.declaration=內聯所有呼叫並移除宣告
refactoring.inline.can.not.multiline.string.to.f.string=無法將多行字串內聯到 f-string
refactoring.inline.can.not.string.to.nested.f.string=無法將字串內聯到嵌套的 f-string
refactoring.inline.can.not.string.with.backslashes.or.quotes.to.f.string=無法將帶有反斜杠和引號的字串內聯到 f-string
refactoring.inline.function=內聯函式 {0}
refactoring.inline.function.async=無法內聯異步函式
refactoring.inline.function.builtin=無法內聯內建函式
refactoring.inline.function.command.name=正在內聯{0}
refactoring.inline.function.constructor=無法內聯建構函式呼叫
refactoring.inline.function.decorator=無法內聯包含裝飾器的函式
refactoring.inline.function.function.to.inline=要內聯的函式
refactoring.inline.function.generator=無法內聯產生器
refactoring.inline.function.global=無法內聯包含全域變數的函式
refactoring.inline.function.interrupts.flow=無法內聯中斷控制流的函式
refactoring.inline.function.invocations.to.be.inlined=要在 {0} 檔案中內聯的呼叫
refactoring.inline.function.is.decorator=函式 {0} 用作裝飾器，無法內聯。不會移除函式定義
refactoring.inline.function.is.overridden=無法內聯被覆蓋的方法
refactoring.inline.function.is.reference=函式 {0} 用作參照，無法內聯。不會移除函式定義
refactoring.inline.function.nested=無法內聯包含其他函式宣告的函式
refactoring.inline.function.nonlocal=無法內聯包含非區域變數的函式
refactoring.inline.function.overrides.method=無法內聯覆蓋其他方法的方法
refactoring.inline.function.self.referrent=無法內聯參照自身的函式
refactoring.inline.function.skeleton.only=無法內聯二進制模組中的函式
refactoring.inline.function.special.method=無法內聯特殊方法
refactoring.inline.function.star=無法內聯包含 * 實參的函式
refactoring.inline.function.title=內聯函式
refactoring.inline.function.uses.unpacking=函式 {0} 使用實參解包，無法內聯。不會移除函式定義
refactoring.inline.label.function=函式 {0}
refactoring.inline.label.method=方法 {0}
refactoring.inline.local.multiassignment=使用多個賦值定義
refactoring.inline.method=內聯方法 {0}
refactoring.inline.this.only=僅內聯此呼叫並保留宣告
refactoring.introduce.constant.cannot.extract.selected.expression=所選表達式無法提取為常數
refactoring.introduce.constant.dialog.title=提取常數
refactoring.introduce.constant.scope.error=已在作用域中宣告該名稱
refactoring.introduce.name.error=名稱不正確
refactoring.introduce.selection.error=無法使用所選元素執行重構
refactoring.introduce.variable.dialog.title=提取變數
refactoring.introduce.variable.scope.error=該名稱與現有變量或參數衝突
refactoring.move.module.members.error.cannot.place.elements.into.nonpython.file=無法將元素放入非 Python 檔案中
refactoring.name.label.text={0} 有 {1} 個匹配項{2, choice, 0\#|1\#}
refactoring.progress.title.updating.existing.usages=正在更新現有用法…
type.param.list.annotator.two.or.more.types.required=需要兩種或多種類型
type.param.list.annotator.type.parameter.already.defined=已在此類型參數列表中定義了名稱為 ''{0}'' 的類型參數
type.param.list.annotator.type.var.tuple.and.param.spec.can.not.have.bounds=ParamSpec 和 TypeVarTuple 不能有約束和上限
unresolved.docstring.param.reference=函式 ''{0}'' 沒有參數 ''{1}''
unresolved.import.reference=沒有名稱為 ''{0}'' 的模組

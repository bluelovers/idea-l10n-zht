action.DlvDebugger.ViewAsGroup.text=作為...查看
action.DlvRewindAction.description=向後執行程序，直到到達上一個中斷點
action.DlvRewindAction.text=後退
action.DlvToggleThreadsAction.description=顯示執行緒
action.DlvToggleThreadsAction.text=顯示執行緒
action.DlvDumpAction.text=轉儲 Goroutine
action.MergeIdenticalStacktraces.text=合併相同的堆疊跟踪
action.HideGoroutine=隱藏 goroutine
action.HideSimilarGoroutines=隱藏具有相同堆疊的所有 goroutine
action.ResetHiddenAction.text=重置隱藏的 Goroutine
action.ResetHiddenAction.description=重置隱藏的 goroutine
action.FilterStacktraces.description=僅顯示包含特定字串的堆疊
action.FilterStacktraces.task.name=篩選堆疊
action.Go.NewGoFile.description=創建新 Go 檔案
action.Go.NewGoFile.text=Go 檔案
action.GoAddContentRootFromGopath.description=將所選目錄添加到當前專案
action.GoAddContentRootFromGopath.text=將目錄添加到當前專案中
action.GoCallHierarchyPopupMenu.BaseOnThisDeclaration.text=基於此宣告
action.GoCoreDumpAction.text=開啟核心轉儲…
action.GoFmtFileAction.description=使用 go fmt 工具格式化所選檔案
action.GoFmtFileAction.text=Go Fmt 檔案
action.GoFmtProjectAction.description=使用 go fmt 工具格式化專案
action.GoFmtProjectAction.text=Go Fmt 專案
action.GoGenerateConstructorAction.description=為結構生成構造函數
action.GoGenerateConstructorAction.text=構造函數
action.GoGenerateStructFieldsFromJsonAction.description=從 JSON 生成結構欄位
action.GoGenerateStructFieldsFromJsonAction.text=JSON 中的結構欄位
action.GoGenerateTypeFromJsonAction.description=從 JSON 生成類型
action.GoGenerateTypeFromJsonAction.text=JSON 中的類型
action.GoGenerateFileAction.description=在所選檔案上執行 go generate
action.GoGenerateFileAction.text=Go Generate 檔案
action.GoGenerateGetterAction.description=為欄位生成 getter 方法
action.GoGenerateGetterAction.text=Getter
action.GoGenerateGetterSetterAction.description=為欄位生成 getter 和 setter 方法
action.GoGenerateGetterSetterAction.text=Getter 和 Setter
action.GoGenerateSetterAction.description=為欄位生成 setter 方法
action.GoGenerateSetterAction.text=Setter
action.GoIdeNewProjectAction.text=專案…
action.GoImportsFileAction.description=使用 goimports 工具最佳化所選檔案的匯入
action.GoImportsFileAction.text=Goimports 檔案
action.GoOpenProjectFromGopath.description=作為專案開啟所選目錄
action.GoOpenProjectFromGopath.text=作為專案開啟目錄
action.GoRemoveContentRootAction.description=從當前專案中移除所選內容根目錄
action.GoRemoveContentRootAction.text=分離目錄…
action.GoReplayTraceAction.text=偵錯儲存的跟踪…
action.GoVetFileAction.description=使用 go vet 工具對所選檔案或目錄執行 Lint 操作
action.GoVetFileAction.text=Go Vet 檔案
action.Vgo.NewVgoFile.description=創建 Go 模組檔案
action.Vgo.NewVgoFile.text=Go 模組檔案
action.WelcomeScreen.CreateDirectoryProject.text=新建專案
action.com.goide.vgo.actions.VgoSyncAction.description=同步 go 模組
action.com.goide.vgo.actions.VgoSyncAction.text=同步 Go 模組
action.com.goide.vgo.actions.VgoTidyAction.description=在模組中執行 `go mod tidy`
action.com.goide.vgo.actions.VgoTidyAction.text=Go Mod Tidy
action.go.fill.paragraph=填充段落
action.GoShareInPlaygroundAction.text=在 Playground 中共享
action.GoShareInPlaygroundAction.description=在 Go Playground 中共享當前檔案
action.GoShareInPlaygroundAction.error=無法在 Go Playground 中共享檔案: {0}
action.GoShareInPlaygroundAction.empty.id=Playground 返回空 ID
action.GoShareInPlaygroundAction.confirmation=您是否希望將 {0} 上傳到 Go Playground 並使之公開?
action.GoShareInPlaygroundAction.notification.text=Go Playground 中共享的檔案: <a href="{0}">{0}</a>
action.GoShareInPlaygroundAction.notification.copyUrl=將 URL 複製到剪貼簿
action.go.exclude.package.from.import.and.completion=從匯入和補全中排除 ''{0}''
action.GoIntroduceTypeAction.text=引入類型…
go.app.engine.not.gae.sdk.validation.message=App Engine 僅支援 Go 1.11 及更高版本
go.app.engine.wizard.description=創建 Go App Engine 專案以開發使用 Google App Engine 的 Go 套用程序。<br/>新模組包括 Go 中的預設設定設定和基本處理程序。
go.app.engine.wizard.name=App Engine
go.modules.wizard.name=Go
go.modules.wizard.description=創建 Go 模組專案，以開發使用 Go 模組進行依賴項管理的 Go 應用程式和庫
go.wizard.name=Go (GOPATH)
go.wizard.description=創建 Go 專案以在 GOPATH 下開發套用程序或庫
go.dep.wizard.description=創建 Dep 專案，以開發使用 Dep 作為依賴項管理工具的 Go 套用程序
go.background.task.running.title=正在執行…
go.background.task.compiling.title=正在編譯…
filetype.go.cgo.description=Cgo 檔案
go.checkin.factory.fmt.commit.anyway.question=仍要提交嗎?
go.checkin.factory.fmt.failed.message=GoFmt 在某些檔案上返回了非零程式碼。
go.checkin.factory.fmt.not.started.message=無法執行 gofmt。{0}
go.colors.and.fonts.bad.character=錯誤字符
go.colors.and.fonts.braces.and.operators.braces=大括號
go.colors.and.fonts.braces.and.operators.brackets=中括號
go.colors.and.fonts.braces.and.operators.colon=冒號
go.colors.and.fonts.braces.and.operators.comma=逗號
go.colors.and.fonts.braces.and.operators.dot=點
go.colors.and.fonts.braces.and.operators.operator=運算符
go.colors.and.fonts.braces.and.operators.parentheses=括號
go.colors.and.fonts.braces.and.operators.semicolon=分號
go.colors.and.fonts.braces.and.operators=大括號和運算符
go.colors.and.fonts.comments.block.comment=塊註釋
go.colors.and.fonts.comments.comment.keyword=註釋關鍵字
go.colors.and.fonts.comments.comment.reference=註釋引用
go.colors.and.fonts.comments.line.comment=行註釋
go.colors.and.fonts.comments=註釋
go.colors.and.fonts.comments.build.constraints=建置約束
go.colors.and.fonts.comments.build.constraints.tag=標記
go.colors.and.fonts.comments.build.constraints.parens=圓括號
go.colors.and.fonts.comments.build.constraints.operators=運算符
go.colors.and.fonts.declarations.constants.builtin.constant=內建常數
go.colors.and.fonts.declarations.constants.local.constant=局部常數
go.colors.and.fonts.declarations.constants.package.exported.constant=軟體套件匯出的常數
go.colors.and.fonts.declarations.constants.package.local.constant=軟體套件局部常數
go.colors.and.fonts.declarations.constants=常數
go.colors.and.fonts.declarations.function.parameter=函數參數
go.colors.and.fonts.declarations.functions.builtin.function=內建函數
go.colors.and.fonts.declarations.functions.exported.function=匯出的函數
go.colors.and.fonts.declarations.functions.package.local.function=軟體套件本地函數
go.colors.and.fonts.declarations.functions=函數
go.colors.and.fonts.declarations.label=標籤
go.colors.and.fonts.declarations.method.receiver=方法接收器
go.colors.and.fonts.declarations.package=軟體套件
go.colors.and.fonts.declarations.types.package.exported.interface=軟體套件匯出的接口
go.colors.and.fonts.declarations.types.package.exported.struct=軟體套件匯出的結構
go.colors.and.fonts.declarations.types.package.local.interface=軟體套件本地接口
go.colors.and.fonts.declarations.types.package.local.struct=軟體套件本地結構
go.colors.and.fonts.declarations.types.type.specification=類型規範
go.colors.and.fonts.declarations.types=類型
go.colors.and.fonts.declarations.variables.builtin.variable=內建變數
go.colors.and.fonts.declarations.variables.local.variable=局部變數
go.colors.and.fonts.declarations.variables.package.exported.variable=軟體套件匯出的變數
go.colors.and.fonts.declarations.variables.package.local.variable=軟體套件局部變數
go.colors.and.fonts.declarations.variables.reassignment.in.short.variable.declaration=短變數宣告中的重新賦值
go.colors.and.fonts.declarations.variables.scope.declared.variable=範圍宣告變數
go.colors.and.fonts.declarations.variables.shadowing.variable=陰影變數
go.colors.and.fonts.declarations.variables.struct.exported.member=結構匯出的成員
go.colors.and.fonts.declarations.variables.struct.local.member=結構本地成員
go.colors.and.fonts.declarations.variables=變數
go.colors.and.fonts.declarations=宣告
go.colors.and.fonts.identifier=關鍵字
go.colors.and.fonts.keyword=關鍵字
go.colors.and.fonts.number=數字
go.colors.and.fonts.references.function.calls.builtin.function.call=內建函數調用
go.colors.and.fonts.references.function.calls.exported.function.call=匯出的函數調用
go.colors.and.fonts.references.function.calls.local.function.call=局部函數調用
go.colors.and.fonts.references.function.calls=函數調用
go.colors.and.fonts.references.type.references.builtin.type.reference=內建類型引用
go.colors.and.fonts.references.type.references.package.exported.interface=軟體套件匯出的接口
go.colors.and.fonts.references.type.references.package.exported.struct=軟體套件匯出的結構
go.colors.and.fonts.references.type.references.package.local.interface=軟體套件本地接口
go.colors.and.fonts.references.type.references.package.local.struct=軟體套件本地結構
go.colors.and.fonts.references.type.references.type.specification=類型規範
go.colors.and.fonts.references.type.references=類型引用
go.colors.and.fonts.references.variable.calls.exported.variable.call=匯出的變數調用
go.colors.and.fonts.references.variable.calls.local.variable.call=局部變數調用
go.colors.and.fonts.references.variable.calls.package.local.variable.call=軟體套件局部變數調用
go.colors.and.fonts.references.variable.calls.struct.exported.member.call=結構匯出的成員調用
go.colors.and.fonts.references.variable.calls.struct.local.member.call=結構本地成員調用
go.colors.and.fonts.references.variable.calls=變數調用
go.colors.and.fonts.references=引用
go.colors.and.fonts.string.invalid.escape=無效的轉義
go.colors.and.fonts.string.text=文本
go.colors.and.fonts.string.valid.escape=有效的轉義
go.colors.and.fonts.string=字串
go.colors.and.fonts.declarations.struct.tags=結構標記
go.colors.and.fonts.declarations.struct.tags.key=鍵
go.colors.and.fonts.declarations.struct.tags.colon=冒號
go.colors.and.fonts.declarations.struct.tags.value=值
go.colors.and.fonts.declarations.struct.tags.arbitraryText=任意文本
go.completion.insert.if.not.nil.statement.command.name=插入 ''if value != nil {...}'' 語句
go.completion.insert.literal.command.name=插入 Go 文字
go.completion.insert.type.name.command.name=插入類型名稱
go.completion.insert.return.statement.command.name=插入 return 語句
go.completion.method.like.completion.advertisement=按 {0} 查看將表達式作為第一個實參的函數
go.completion.method.like.completion.command.name=函數的方法式補全
go.core.dump.dialog.dump.path.label=核心轉儲(&C):
go.core.dump.dialog.executable.label=可執行檔案(&E):
go.core.dump.dialog.invalid.core.dump.validation.message=該檔案不是有效的核心轉儲
go.core.dump.dialog.invalid.executable.validation.message=該檔案不是可執行檔案
go.core.dump.dialog.specify.core.dump.validation.message=指定核心轉儲
go.core.dump.dialog.specify.executable.validation.message=指定可執行檔案
go.core.dump.failed.to.start.error.message=無法為核心轉儲 {0} 啟動偵錯器: {1}
go.core.dump.session.name=核心轉儲 {0}
go.create.new.file.action.command.name=創建 Go 檔案 {0}
go.create.new.file.action.name=Go 檔案
go.create.new.file.dialog.title=新建 Go 檔案
go.create.new.file.empty.file.kind.name=空檔案
go.create.new.file.simple.application.kind.name=簡單套用程序
go.debug.show.goroutines.action.name=顯示 Goroutine
go.debug.show.threads.action.name=顯示執行緒
go.declarations.intentions.category=Go/宣告
go.dep.checking.dep.projects.task.name=檢查 Dep 專案
go.dep.enable.integration.checkbox=啟用 dep 整合
go.edit.auto.import.settings.action.name=編輯自動匯入設定
go.auto.import.and.completion.title=自動匯入和補全
go.auto.import.and.completion.add.exclude.label=輸入要從自動匯入和補全中排除的匯入路徑:
go.element.is.not.go.expression.error.hint=選區不包含 Go 表達式
go.exclude.import.path.dialog.empty.path.validation.message=匯入路徑不能為空
go.exclude.import.path.dialog.title=排除匯入路徑
go.exclude.import.path.from.completion.action.name=排除 ''{0}''
filetype.go.description=Go 檔案
go.fix.searching.for.usages.progress.title=正在搜尋用法…
go.fix.change.parameters.parameter={0,choice,0#參數|1#參數|2#參數}
go.fix.add.missing.new.line.name=添加缺少的新行
go.fix.add.comma.name=添加逗號
go.fix.add.whitespace.name=添加空格
go.fix.add.import.for.side.effects.name=副作用匯入
go.fix.add.prefix.to.comment.name=向註釋中添加 ''{0}'' 前綴
go.fix.add.return.statement.name=添加 return 語句
go.fix.change.import.sorting.settings.name=更改匯入排序設定
go.fix.change.result.parameters.result.parameter={0,choice,0#結果參數|1#結果參數|2#結果參數}
go.fix.create.directory.text=在 {1} 處創建目錄{0}
go.fix.change.parameters.name=更改參數
go.fix.change.result.parameters.in.assignment.name=更改賦值中的結果參數
go.fix.change.result.parameters.in.call.name=更改調用中的結果參數
go.fix.change.result.parameters.in.return.name=更改返回中的結果參數
go.fix.change.result.parameters.in.variable.specification.name=更改變數規範中的結果參數
go.fix.change.result.parameters.name=更改結果參數
go.fix.change.signature.from.function.type.name=從函數類型更改簽名
go.fix.change.signature.from.usage.text=從用法更改簽名
go.fix.change.signature.from.function.type.text=將{0} ''{1}'' 的簽名更改為 ({2}) ({3})
go.fix.change.signature.from.usage.add=將 ''{0}'' 作為第 {1,number,ordinal} 個{2}添加到{3} ''{4}'' 中
go.fix.change.signature.from.usage.remove=從{2} ''{3}'' 中移除第 {0,number,ordinal} 個{1}
go.fix.change.signature.from.usage.change=將{2} ''{3}'' 的第 {0,number,ordinal} 個{1}從 ''{4}'' 更改為 ''{5}''
go.fix.change.signature.from.usage.mix=將{1} ''{2}'' 的{0}更改為 ({3})
go.fix.convert.to.is.equal.name=轉換為 '=='
go.fix.delete.name=刪除 {0}
go.fix.delete.text=刪除{0} ''{1}''
go.fix.delete.range.name=刪除元素
go.fix.delete.third.index.name=刪除第三索引
go.fix.delete.blank.argument.name=刪除空白實參
go.fix.export.name=匯出
go.fix.export.field.name=匯出欄位
go.fix.replace.tilda.with.hat.name=將 '~' 取代為 '^'
go.fix.replace.assign.with.equals.name=將 ':=' 取代為 '='
go.fix.replace.equals.with.assign.name=取代為 ':='
go.fix.replace.with.nil.with.side.effects.name=取代為 nil (更改語意)
go.fix.replace.with.correct.defer.name=取代為正確的 defer 結構
go.fix.add.function.call.name=添加函數調用
go.fix.delete.redundant.index.name=刪除冗餘索引
go.fix.delete.conversion.name=刪除轉換
go.fix.delete.conversion.with.side.effects.name=刪除轉換(可能改變語意)
go.fix.disable.vendoring.in.module.text=在模組 ''{0}'' 中禁用 vendoring 試驗支援
go.fix.disable.vendoring.in.module.name=在模組中禁用 vendoring 試驗支援
go.fix.drop.suffix.text=刪除特定於單元的後綴 ''{0}''
go.fix.drop.suffix.name=刪除特定於單元的後綴
go.fix.multiple.packages.name=重命名軟體套件
go.fix.multiple.packages.text=將軟體套件重命名為 {0}
go.fix.choose.package.name=選擇軟體套件名稱
go.fix.simplify.bool.expr.name=簡化表達式
go.fix.failed.to.simplify.if.statement=無法簡化 'if' 語句
go.fix.view.all.duplicates.name=查看重複的名稱
go.fix.view.all.duplicates.text=查看 ''{0}'' 的重複名稱
go.fix.view.all.duplicates.targets.tab.text=''{0}'' 的重複項
go.fix.view.all.duplicates.targets.tool.window.title={1} 中的 {0}
go.fix.view.all.duplicates.targets.code.usages.string=已找到重複項
go.fix.add.function.block.name=添加正文
go.fix.add.keys.to.struct.literal.value.name=添加鍵並刪除零值
go.fix.add.local.var.for.expression.name=引入局部變數
go.fix.add.missing.return.value.name=添加缺少的返回值
go.fix.add.pointer.name=添加指針
go.fix.add.explicit.dereference.name=添加顯式取消引用
go.fix.always.false.if.name=移除 'if' 分支
go.fix.always.true.if.name=移除其他分支並簡化當前的 'if'
go.fix.convert.int.to.string.using.conversion.call=使用 {0} 調用將整數轉換為字串
go.fix.convert.string.to.byte.name=將字串轉換為字節
go.fix.convert.to.expected.type.name=轉換為
go.fix.convert.to.expected.type.text=轉換為 ''{0}''
go.fix.create.wrapper.type.name=創建類型
go.fix.delete.all.unused.parameters.name=刪除所有未使用的參數
go.fix.delete.ampersand.and.type.in.composite.lit.name=刪除冗餘類型
go.fix.delete.extra.expressions.name=刪除多餘的表達式
go.fix.delete.import.name=刪除匯入
go.fix.delete.parameter.names.name=刪除參數名稱
go.fix.delete.unused.parameter.name=刪除未使用的參數
go.fix.empty.signature.name=修復簽名
go.fix.exclude.from.unhandled.inspection.name=不再報告此方法/函數
go.fix.extract.empty.slice.to.var.declaration.name=取代為零切片宣告(更改語意)
go.fix.extract.to.own.declaration.name=提取到自己的宣告
go.fix.finish.call.name=完成調用表達式
go.fix.ignore.explicitly.name=顯式忽略
go.fix.ignore.explicitly.using.closure.name=使用閉包顯式忽略
go.fix.handle.error.name=處理錯誤
go.fix.ignore.unused.call.result.name=忽略未使用的調用結果
go.fix.implement.missing.methods.name=實作缺少的方法
go.fix.insert.blank.identifiers.name=將空白關鍵字插入賦值語句的左側
go.fix.navigate.to.name=導航到
go.fix.navigate.to.text=導航到 {0}
go.fix.optimize.imports.name=最佳化 import
go.fix.place.build.tag.before.package.name=在軟體套件前面放置建置標記
go.fix.remove.redundant.bool.literal.name=簡化為
go.fix.replace.with.name=取代為
go.fix.replace.with.text=取代為 ''{0}''
go.fix.rename.to.name=重命名為
go.fix.rename.to.text=重命名為 ''{0}''
go.fix.rename.all.receivers.name=重命名所有接收器
go.fix.rename.all.receivers.text=重命名所有接收器為 ''{0}'' 
go.fix.replace.expression.name=在前面追加 '\\&'
go.fix.signature.name=修復簽名
go.fix.sort.imports=import 排序
go.fix.simplify.expression.to.boolean.literal.name=簡化條件
go.fix.simplify.to.text=簡化為 ''{0}''
go.fix.simplify.something.to.text=將 ''{0}'' 簡化為 ''{1}''
go.fix.suppress.inspection.for.text=對{0}禁止
go.fix.suppress.all.inspections.for.text=禁止{0}的所有檢查
go.fix.unwrap.parens.name=取消換行括號
go.fix.convert.to.format.function.name=更改為格式設定函數
go.fix.convert.to.format.function.text=更改 ''{0}'' 為格式設定函數
go.fix.introduce.local.variable.for.expression=引入 ''{0}'' 的局部變數
go.fix.introduce.method.name=創建方法
go.fix.introduce.method.text=創建方法 ''{0}''
go.fix.introduce.function.name=創建函數
go.fix.introduce.function.text=創建函數 ''{0}''
go.fix.field.with.the.same.tag=包含相同 ''{1}'' 標籤的欄位 ''{0}''
go.fix.field.repeats.tag.with.value=欄位 ''{0}'' 重複 ''{3}'' 欄位中值為 ''{2}'' 的 ''{1}'' 標籤
go.fix.convert.int.to.rune=將整數轉換為 rune
go.fix.unpack.slice.name=解壓縮切片
go.fix.enable.gopath.indexing.name=啟用 GOPATH 索引
go.get.package.fix.family.name=執行 'go get'
go.use.gopath.from.system.environment.checkbox=使用系統環境中定義的 GOPATH
go.index.entire.gopath.checkbox=為整個 GOPATH 編制索引
go.index.entire.gopath.tooltip=禁用時，將僅對專案和 vendor 軟體套件編制索引。<br/>這樣可以提升整體性能，但無法使用 GOPATH 中的軟體套件。
go.libraries.configurable.path.source.prefix.default=[預設]
go.libraries.configurable.path.source.prefix.gopath=[GOPATH]
go.inspection.assignment.nil.without.explicit.type.message=如果沒有顯式類型，則無法分配 nil
go.inspection.assignment.to.receiver.display.name=賦值給接收器
go.inspection.bool.condition.display.name=布爾型條件
go.inspection.comment.has.no.leading.space.display.name=註釋沒有前導空格
go.inspection.comment.of.exported.element.starts.with.incorrect.name.display.name=匯出的元素的註釋以不正確的名稱開頭
go.inspection.comment.should.have.package.prefix.message=軟體套件註釋應採用 ''Package {0} ...'' 的形式
go.inspection.comment.should.be.without.article.message=註釋格式應為 ''{0} ...'' (有可選的前導條目)
go.inspection.comment.should.be.meaningful.message=註釋應有意義，否則應當移除
go.inspection.defer.go.statement.calls.recover.or.panic.directly.display.name=Defer/go 語句直接調用 'recover' 或 'panic'
go.inspection.defer.or.go.should.not.call.function.message={0} 不應直接調用 {1}
go.inspection.defer.in.loop.display.name=迴圈中的 'defer'
go.inspection.deprecated.element.display.name=棄用的元素
go.inspection.division.by.zero.display.name=除以零
go.inspection.empty.declaration.display.name=空宣告
go.inspection.empty.declaration.message=宣告 {0} 為空
go.inspection.empty.slice.declared.via.literal.display.name=使用文字宣告的空切片
go.inspection.error.string.should.not.be.capitalized.or.end.with.punctuation.display.name=錯誤字串不應大寫或以標點結尾
go.inspection.exceeded.shift.expression.display.name=已超出 shift 表達式
go.inspection.explicit.dereference.calling.method.with.receiver.message=包含接收器 {1}(類型為 {2})的調用方法 {0} 需要顯式取消引用
go.inspection.explicit.dereference.accessing.field.message=存取 {1}(類型為 {2})的欄位 {0} 需要顯式取消引用
go.inspection.exported.element.should.have.comment.display.name=匯出的元素應有註釋
go.inspection.exported.element.should.have.its.own.declaration.display.name=匯出的元素應有自己的宣告
go.inspection.extended.method.expression.syntax.before.go.1.10.message=意外的接收器類型，自 Go 1.10 起可以使用擴展的方法表達式語法
go.inspection.imported.package.name.as.name.identifier.display.name=軟體套件名稱作為名稱關鍵字匯入
go.inspection.impossible.interface.type.assertion=不可能的接口類型斷言
go.inspection.incorrect.strings.replace.count.argument.display.name=不正確的 'strings.Replace' 計數實參
go.inspection.incorrect.usage.of.printf.display.name=不正確的 'fmt.Printf' 和 'fmt.Println' 函數用法
go.inspection.incorrect.usage.of.the.errors.as.function.display.name=不正確的 'errors.As' 函數用法
go.inspection.incorrect.usage.of.the.sync.atomic.display.name=不正確的 'sync/atomic' 軟體套件用法
go.inspection.locks.mistakenly.passed.by.value=鎖通過值錯誤傳遞
go.inspection.possible.misuse.of.unsafe.pointer=可能濫用 {0}
go.inspection.invalid.conversions.of.uintptr.to.unsafe.Pointer=無效的 'uintptr' 到 'unsafe.Pointer' 轉換
go.inspection.infinite.for.loop.display.name=無限的 'for' 迴圈
go.inspection.problem.cannot.take.address=無法提取 {0} 的地址
go.inspection.problem.invalid.indirect={0} (類型 {1})的間接引用無效
go.inspection.int.to.string.conversion=整數轉換為字串類型
go.inspection.lost.cancel='context.CancelFunc' 未被調用
go.inspection.loop.closure.display.name=函數文字捕獲的迴圈變數
go.inspection.loop.closure.message=由 <code>{0}</code> 語句中的 <code>func</code> 文字捕獲的迴圈變數可能有意外值
go.inspection.malformed.build.tag.display.name=建置標記的格式錯誤
go.inspection.malformed.struct.tag.display.name=結構標記的格式錯誤
go.inspection.missing.trailing.comma.before.newline.in.composite.literal.display.name=複合文字中的換行符前缺少尾隨逗號
go.inspection.name.starts.with.package.name.display.name=名稱以軟體套件名稱開頭
go.inspection.nilness.analyzer.display.name=為零性分析器
go.inspection.non-standard.signature.for.well.known.function.names.display.name=已知函數名稱採用非標準簽名
go.inspection.receiver.has.generic.name.display.name=接收器具有泛型名稱
go.inspection.redundant.blank.argument.in.range.display.name=範圍中存在冗餘空白實參
go.inspection.redundant.comma.display.name=冗餘逗號
go.inspection.redundant.import.alias.display.name=冗餘匯入別名
go.inspection.redundant.parentheses.display.name=冗餘括號
go.inspection.redundant.second.index.in.slices.display.name=切片中存在冗餘的第二個索引
go.inspection.redundant.semicolon.display.name=冗餘分號
go.inspection.redundant.type.conversion.display.name=冗餘類型轉換
go.inspection.redundant.types.in.composite.literals.display.name=複合文字中存在冗餘類型
go.inspection.reserved.word.used.as.name.display.name=保留詞用作名稱
go.inspection.self.assignment.display.name=自賦值
go.inspection.shadowing.variable.display.name=陰影變數
go.inspection.struct.initialization.without.field.names.display.name=結構初始化沒有欄位名稱
go.inspection.struct.initialization.settings.report.for.local.type.checkbox=報告當前軟體套件中定義的類型
go.inspection.struct.initialization.settings.report.for.literals.without.type.checkbox=報告無類型的結構文字
go.inspection.struct.field.has.tag.but.is.not.exported=結構欄位 ''{0}'' 具有 ''{1}'' 標記，但未被匯出
go.inspection.type.can.be.omitted.display.name=類型可以省略
go.inspection.type.can.be.omitted.message=類型可以省略
go.inspection.unexported.return.type.of.exported.function.display.name=匯出函數的未匯出返回類型
go.inspection.unhandled.error.display.name=未處理錯誤
go.inspection.unit.specific.suffix.for.time.duration.display.name=為 'time.Duration' 使用單位特定的後綴
go.inspection.unnecessarily.exported.identifier.display.name=不必要地匯出了關鍵字
go.inspection.unreachable.code.display.name=不可到達的程式碼
go.inspection.unknown.field.message=結構文字中的欄位 {0} 未知
go.inspection.ambiguous.reference.message=不明確的引用 {0}
go.inspection.unresolved.reference.message=未解析的引用 {0}
go.inspection.unresolved.type.message=未解析的類型 {0}
go.inspection.unresolved.label.message=未解析的標籤 {0}
go.inspection.unresolved.disabled.gopath.indexing.display.name=已禁用 GOPATH 索引
go.inspection.unresolved.disabled.gopath.indexing.message=禁用 GOPATH 索引可能會阻止正確進行引用解析
go.inspection.unsorted.imports.display.name=未排序的匯入
go.inspection.unused.constant.display.name=未使用的常數
go.inspection.unused.constant.message=未使用的常數 {0}
go.inspection.unused.exported.function.display.name=未使用的匯出函數
go.inspection.unused.function.message=未使用的函數 {0}
go.inspection.unused.label.message=未使用的標籤 {0}
go.inspection.unused.exported.type.display.name=未使用的匯出類型
go.inspection.unused.function.display.name=未使用的函數
go.inspection.unused.function.or.method.call.result.display.name=未使用的函數或方法調用結果
go.inspection.unused.global.variable.display.name=未使用的全域變數
go.inspection.unused.parameter.display.name=未使用的參數
go.inspection.unused.parameter.message=未使用的參數 {0}
go.inspection.unused.type.display.name=未使用的類型
go.inspection.unused.type.message=未使用的類型 {0}
go.inspection.unused.variable.message=未使用的變數 {0}
go.inspection.usage.of.snake.case.display.name=使用了 Snake_Case(_C)
go.inspection.incorrect.call.to.unmarshal.display.name=使用錯誤的實參調用了 'Unmarshal'
go.inspection.struct.tag.value.consists.only.of.spaces=結構標籤值僅包含空格
go.inspection.suspicious.space.in.the.beginning.of.the.struct.tag.value=結構標籤值開頭有可疑的空格
go.inspection.suspicious.space.in.the.end.of.the.struct.tag.value=結構標記值末尾的可疑空格
go.inspection.suspicious.extra.space.in.struct.tag.value=結構標記值中的可疑額外空格
go.inspection.suspicious.space.in.struct.tag.value=結構標記值中的可疑空格
go.inspection.missing.closing.double.quote.character.in.value=值中缺少右雙引號字符
go.inspection.expected.opening.double.quote.character.after.colon=':' 後面應為左雙引號字符
go.inspection.expected.colon.after.key=鍵後面應為 ':'
go.inspection.key.is.empty.or.starts.from.incorrect.symbol=鍵為空或者以不正確的符號開頭
go.inspection.key.is.not.separated.by.space.from.previous.pair=鍵與上一對沒有用空格分隔
go.inspection.test.name.display.name=測試函數名稱格式錯誤
go.inspection.problem.malformed.test.name=測試名稱格式錯誤: 'Test' 後面的第一個字母不得為小寫
go.inspection.problem.malformed.benchmark.name=基準名稱格式錯誤: 'Benchmark' 後面的首字母不能小寫
go.inspection.problem.malformed.example.suffix=範例名稱格式錯誤: 後綴 {0} 必須以小寫字母開頭
go.inspection.problem.example.for.unknown.identifier=範例引用未知關鍵字: {0}
go.inspection.problem.example.for.unknown.field.or.method=範例引用未知欄位或方法:{0}。{1}
go.intention.add.comment.name=添加註釋
go.intention.add.declaration.parens.name=向宣告添加圓括號
go.intention.add.dot.import.alias.name=添加點匯入別名
go.intention.add.fmt.string.argument.name=添加格式字串實參
go.intention.add.import.alias.name=添加匯入別名
go.intention.convert.to.short.var.declaration.name=轉換為短變數宣告
go.intention.convert.to.var.declaration.name=轉換為變數宣告
go.intention.create.field.getter.and.setter.name=生成 getter 和 setter
go.intention.create.field.getter.and.setter.command.name=創建欄位存取器
go.intention.create.field.getter.name=創建 Getter
go.intention.create.field.setter.name=創建 Setter
go.intention.expand.signature.types.name=展開簽名類型
go.intention.export.name=匯出
go.intention.fill.all.fields.name=填充所有欄位
go.intention.fill.all.fields.recursively.checkbox=遞歸
go.intention.fill.all.fields.enforce.multiline.checkbox=執行多行
go.intention.fill.all.fields.command.name=填充結構
go.intention.fill.all.fields.recursively.name=遞歸填充所有欄位
go.intention.fill.fields.name=填充欄位…
go.intention.flip.binary.operator.changes.operator.text=將 ''{0}'' 翻轉為 ''{1}''
go.intention.flip.binary.operator.changes.semantics.text=翻轉 ''{0}'' (更改語意)
go.intention.flip.binary.operator.name=翻轉二進制運算符
go.intention.flip.binary.operator.text=翻轉 ''{0}''
go.intention.fmt.string.argument.bad.position.error.message=位置錯誤
go.intention.fmt.string.argument.explicit.indices.error.message=字串具有顯式索引
go.intention.fmt.string.argument.percent.with.args.error.message=字串具有帶實參的 %%
go.intention.fmt.string.argument.syntax.error.message=字串有語法錯誤
go.intention.fmt.string.argument.too.few.arguments.error.message=字串的實參太少
go.intention.fmt.string.argument.variadic.arg.error.message=字串具有 ... 實參
go.intention.fmt.string.title.error.message=無法添加 Fmt 字串實參
go.intention.generate.constructor.name=創建構造函數
go.intention.go.to.implementation.name=轉到實作
go.intention.go.to.implementation.text=轉到實作…
go.intention.go.to.super.name=轉到接口
go.intention.go.to.super.text=轉到接口…
go.intention.implement.interface.name=實作接口
go.intention.implement.interface.text=實作接口…
go.intention.invert.if.name=反轉 if
go.intention.merge.all.declarations.name=合併所有宣告
go.intention.merge.declaration.up.name=向上合併宣告
go.intention.merge.declarations.by.comma.name=通過逗號向上合併宣告
go.intention.move.to.struct.initialization.name=將欄位賦值移動到結構初始化
go.intention.negate.boolean.expression.name.recursively.suffix=遞歸
go.intention.negate.boolean.expression.name=求反表達式
go.intention.negate.boolean.expression.text=將 ''{0}'' 求反為 ''{1}''
go.intention.negate.boolean.topmost.expression.name=求反最頂端的表達式
go.intention.negate.boolean.topmost.expression.text=將最頂端的 ''{0}'' 求反為 ''{1}''
go.intention.remove.declaration.parens.name=從宣告中移除圓括號
go.intention.remove.dot.import.alias.name=移除點匯入別名
go.intention.remove.keys.from.struct.literal.value.name=從結構文本中移除鍵
go.intention.reuse.signature.types.name=重用簽名類型
go.intention.run.go.generate.name=在註釋上執行 go generate
go.intention.run.go.generate.on.file.name=在檔案上執行 go generate
go.intention.run.go.generate.on.package.name=在軟體包上執行 go generate
go.intention.run.go.generate.text=Go generate ''{0}''
go.intention.select.fields.dialog.title=選擇欄位
go.intention.specify.type.name=明確地指定類型
go.intention.split.all.declarations.name=拆分所有宣告
go.intention.split.declarations.by.comma.name=通過逗號拆分宣告
go.intention.split.declarations.name=將宣告拆分為兩個組
go.intention.chop.arguments=將實參放在單獨的行上
go.intention.chop.parameters=將參數放在單獨的行上
go.intention.chop.composite.literal.elements=將元素放在單獨的行中
go.intention.join.arguments=將實參放在同一行上
go.intention.join.parameters=將參數放在同一行上
go.intention.join.composite.literal.elements=將元素放在同一行中
go.intention.experimental.support.for.type.parameters.family.name=泛型(實驗性支援類型參數)
go.intention.experimental.support.for.type.parameters.enable.name=啟用泛型(實驗性支援類型參數)
go.intention.experimental.support.for.type.parameters.disable.name=禁用泛型(實驗性支援類型參數)
go.intention.add.tag.key=向標記添加鍵
go.intention.change.field.name.style.in.tags=更改標記中的欄位名稱樣式
go.intention.change.field.name.style.select.style=選擇欄位名稱樣式:
go.intention.change.field.name.style.command=更改標記中的欄位名稱樣式
go.intention.update.value.in.tags=更新標記中的鍵值
go.intention.generate.type.from.json=從 JSON 生成類型
go.intention.generate.struct.fields.from.json=從 JSON 生成結構欄位
go.intention.generate.struct.fields.from.json.error=JSON 頂層值應當是物件或物件陣列
go.intention.download.all.missing.modules.fix.text=將所有模組下載到模組快取
go.intention.download.single.missing.module.fix.family.name=將模組下載到模組快取
go.intention.download.single.missing.module.fix.text=將{0}下載到模組快取
go.intention.download.single.missing.module.fix.from.replacement.text=將 {0} 從 {1} 下載到模組快取
go.generate.type.from.json.dialog.title=從 JSON 生成 Go 類型
go.generate.type.from.json.dialog.json.label=將 JSON 放置在此處:
go.generate.type.from.json.dialog.ok.label=生成
go.generate.type.from.json.error.invalid.json=無法從無效的 JSON 生成 go 類型
go.generate.type.from.json.error.no.top.value=JSON 應有一個頂層值
go.generate.type.from.json.on.paste.dialog.title=從 JSON 生成 Go 類型
go.generate.type.from.json.on.paste.type.message=插入的文本似乎是 JSON。您是否希望從它生成 Go 類型?
go.generate.type.from.json.properties.on.paste.type.message=插入的文本似乎是一系列 JSON 屬性。您是否希望從它生成 Go 類型?
go.generate.type.from.json.on.paste.struct.fields.message=插入的文本似乎是 JSON。您是否希望從它生成結構欄位?
go.generate.type.from.json.properties.on.paste.struct.fields.message=插入的文本似乎是一系列 JSON 屬性。您是否希望從它生成結構欄位?
go.completion.generate.struct.fields.from.json=從 JSON 生成結構欄位…
go.completion.add.tag.key.to.all.fields=向所有欄位添加標記鍵…
go.intentions.category=Go
go.macro.bin.dirs.description=包含 Go 工具的 bin 目錄路徑
go.macro.executable.path.description=Go 可執行檔案路徑
go.macro.file.import.path.description=匯入當前檔案的路徑
go.macro.file.go.path.description=GOPATH 值
go.macro.file.go.root.description=專案 SDK 路徑
go.mozilla.rr.dialog.specify.trace.directory.validation.message=指定跟踪目錄
go.mozilla.rr.dialog.trace.directory.label=跟踪目錄(&T):
go.mozilla.rr.failed.to.start.error.message=無法為 rr 跟踪 {0} 啟動偵錯器: {1}
go.mozilla.rr.session.name=跟踪 {0}
go.navigation.progress.title=正在搜尋 {0}…
go.navigation.shadowed.method.usages.title={0} 的隱藏方法
go.navigation.go.to.shadowed.method.popup.title=方法 {0} 隱藏了 {1} 個{1,choice,0#類型|1#類型|2#類型}的方法
go.navigation.go.to.shadowed.method=轉到陰影方法
go.navigation.go.to.super.method.popup.title=方法 {0} 實作了 {1} 個{1,choice,0#接口|1#接口|2#接口}中的方法
go.navigation.go.to.super.method.find.usages.title.kind={0} 已實作的方法規範
go.navigation.go.to.super.method=轉到方法規範
go.navigation.go.to.super.popup.title=類型 {0} 實作了 {1} 個{1,choice,0#接口|1#接口|2#接口}
go.navigation.go.to.super.find.usages.title={0} 已實作的接口
go.navigation.go.to.super=轉到接口
go.navigation.go.to.type.implementation.popup.title={1} {1, choice, 0#類型|1#類型|2#類型}中實作的類型 {0}
go.navigation.go.to.method.implementation.popup.title={1} {1, choice, 0#類型|1#類型|2#類型}中實作的方法 {0}
go.navigation.go.to.implementation.find.usages.title={0} 的實作
go.navigation.go.to.implementation=轉到實作
go.navigation.go.to.shadowing.method.popup.title={1} {1, choice, 0#類型|1#類型|2#類型}中隱藏的方法 {0}
go.navigation.go.to.shadowing.method.find.usages.title={0} 的隱藏方法
go.navigation.go.to.shadowing.method=轉到隱藏方法
go.navigation.recursive.call=遞歸調用
go.notification.dep.project.out.of.sync.text=Dep 專案 {0} 不同步。
go.notification.gokpg.toml.modified.text=修改了 {0} 的 Gopkg.toml。
go.notification.go.edit.project.settings.action.text=編輯設定
go.notification.go.support.is.disabled.in.module.text=''{0}'' 中禁用 Go 支援
go.notification.go.support.enable.action.text=啟用 Go 支援
go.notification.go.setup.action.text=設定 GOROOT
go.notification.gopath.is.empty.text=GOPATH 為空
go.notification.gopath.configure.action.text=設定 GOPATH
go.notification.gopath.detected.title=檢測到 GOPATH
go.notification.gopath.detected.text=我們從您的 GOPATH 中檢測到一些庫。您可能需要在 GOPATH 設定中添加額外的庫。
go.notification.gopath.detected.configure.gopath.action.text=設定 GOPATH
go.notification.vendoring.detected.title=檢測到 Vendoring 用法
go.notification.vendoring.detected.text=<strong>vendor</strong> 目錄通常意味著專案使用 Go Vendor Experiment。選定的 Go SDK 版本支援 vendoring，但預設為禁用。您可以在專案設定中顯式啟用 Go Vendor Experiment。
go.notification.vendoring.detected.configure.go.vendor.experiment.action.text=設定 Go Vendor Experiment
go.notification.go.tool.is.missing.text=GOPATH 中缺少可執行檔案 ''{0}''。您要安裝嗎?
go.notification.go.tool.is.missing.run.go.get.text=無法在 GOPATH 中找到 ''{0}''。
go.notification.go.tool.is.missing.run.go.get.invoke.go.get.action.text=調用 ''go get {0}''
go.notification.install.go.tool.action.text=安裝 Go 工具
go.notification.add.to.gopath.action.text=添加到 GOPATH
go.notification.add.to.module.action.text=添加到模組
go.notification.create.go.mod.file.action.text=創建 'go.mod' 檔案
go.notification.dep.integration.title=Dep 整合
go.notification.dep.init.failed.title=Dep init 失敗
go.notification.dep.init.failed.configure.dep.action.text=設定 Dep
go.notification.disable.go.modules.integration.action.text=禁用 Go 模組整合
go.notification.do.not.show.action.text=不再顯示
go.notification.cgo.optimizations.are.not.disabled=CGO_CFLAGS 未設定為 '-O0 -g'，無法最佳化 cgo 程式碼。
go.notification.install.package.action.text=安裝 {0}
go.notification.modules.file.is.absent.title='go.mod' 檔案不存在
go.notification.obsolete.imports.code.style.detected.title=檢測到過時的匯入程式碼樣式設定
go.notification.review.code.style.settings.action.text=查看程式碼樣式設定
go.notification.run.dep.ensure.action.text=執行 dep ensure
go.notification.file.starts.with.underscore.text=由於名稱以 ''_'' 開頭，''{0}'' 被建置工具忽略
go.notification.file.starts.with.dot.text=由於名稱以 ''.'' 開頭，''{0}'' 被建置工具忽略
go.notification.file.does.not.match.target.system.text=''{0}'' 與目標系統不符合。檔案將被建置工具忽略。
go.notification.file.is.ignored.because.cgo.mismatch.text=由於 cgo 支援不符合，''{0}'' 被建置工具忽略
go.notification.file.is.ignored.because.os.mismatch.text=由於 OS 不符合，''{0}'' 被建置工具忽略
go.notification.file.is.ignored.because.arch.mismatch.text=由於架構不符合，''{0}'' 被建置工具忽略
go.notification.file.is.ignored.because.compiler.mismatch.text=由於編譯器不符合，''{0}'' 被建置工具忽略
go.notification.file.is.ignored.because.version.mismatch.text=由於 Go 版本不符合，''{0}'' 被建置工具忽略
go.notification.file.is.ignored.because.custom.flag.text=由於自訂標誌，''{0}'' 被建置工具忽略
go.notification.file.is.ignored.because.bad.syntax.text=由於語法錯誤，''{0}'' 被建置工具忽略
go.notification.file.is.ignored.because.non.go.file.text=由於不是 Go 檔案，''{0}'' 被建置工具忽略
go.notification.enable.cgo.support.action.text=啟用 cgo 支援
go.notification.disable.cgo.support.action.text=禁用 cgo 支援
go.notification.file.ignore.navigate.to.build.constraints.action.text=導航到建置約束
go.notification.file.ignore.navigate.to.cgo.import.action.text=導航到 cgo import
go.notification.rename.file.action.text=重命名檔案
go.notification.inspections.are.disabled.text=已禁用對此檔案進行檢查
go.notification.inspections.are.disabled.enabled.action.text=啟用檢查
go.notification.code.insight.features.are.disabled.text=程式碼洞察功能不可用
go.notification.file.exceeds.size.limit.text=檔案大小({0})超出了設定的限制({1})。{2}
go.notification.code.insight.disabled.for.vendored.files.text=庫中供應檔案的編輯程式碼洞察功能已禁用
go.notification.add.vendored.package.to.project.action.text=向專案中添加 ''{0}''
go.notification.package.was.excluded=從匯入中排除 {0}
go.notification.open.imports.settings=開啟匯入設定
go.notification.download.missing.module.successfully.done=已成功處理 {0} 個{0,choice,0#模組|1#模組|2#模組}
go.profiler.application.configurable.name=Go 分析器
go.profiler.profile.fraction.comment.text=控制設定檔案中報告的互斥爭用事件的分數。平均而言，報告 1/分數個事件。留空將使用預設分數 1。
go.profiler.profile.fraction.label.text=設定檔案分數:
go.profiler.profile.rate.cpu.comment.text=控制設定檔案中報告的 goroutine 阻止事件的分數。平均而言，分析器的目標是在程序被阻止的每個周期對一個阻止事件采樣。周期以納秒為單位進行設定。要在設定檔案中包含每個阻止事件，請將值設定為 1。留空將使用預設分析器速率 1。
go.profiler.profile.rate.label.text=設定檔案速率:
go.profiler.profile.illegal.rate.validation.message=非法分析速率: {0}
go.profiler.profile.illegal.profile.fraction.validation.message=非法分析分數: {0}
go.profiler.profile.rate.memory.comment.text=控制設定檔案中記錄和報告的記憶體分配分數。平均而言，分析器的目標是根據分配的每個字節數對一次分配進行采樣。要在設定檔案中包含分配的每個塊，請將速率設定為 1。留空將使用 512 KB 的預設速率。
go.profiler.blocking.profiler.name=阻止分析器
go.profiler.blocking.profile.prefix=阻止分析
go.profiler.cpu.profiler.name=CPU 分析器
go.profiler.cpu.profile.prefix=CPU 分析
go.profiler.memory.profiler.name=記憶體分析器
go.profiler.memory.profile.prefix=記憶體分析
go.profiler.mutex.profiler.name=Mutex 分析器
go.profiler.mutex.profile.prefix=Mutex 分析
go.profiler.not.a.pprof.profile.error=不是 pprof 設定檔案
go.profiler.cpu.time.metric.name=CPU 時間
go.profiler.parse.error=解析設定檔案時出錯: {0}
go.profiler.parse.error.eof=意外的檔案結尾
go.profiler.parse.error.empty=設定檔案為空
go.profiler.allocated.objects.metric.name=已分配的物件
go.profiler.allocated.space.metric.name=已分配的空間
go.profiler.in.use.objects.metric.name=使用中的物件
go.profiler.in.use.space.metric.name=使用中的空間
go.profiler.downloading.profiler.dump.progress.title=正在下載分析器轉儲…
go.run.configuration.environment.label=環境(&V):
go.run.configuration.go.tool.arguments.label=Go 工具實參(&G):
go.run.configuration.module.label=模組(&M):
go.run.configuration.output.directory.label=輸出目錄(&O):
go.run.configuration.program.arguments.label=程序實參(&P):
go.run.configuration.run.after.build.checkbox=建置後執行(&R)
go.run.configuration.build.on.remote.target.checkbox=在遠端目標上建置(&B)
go.run.configuration.run.kind.label=執行種類(&K):
go.run.configuration.run.with.sudo.label=通過 sudo 執行(&I)
go.run.configuration.run.with.sudo.tooltip=使用超級使用者權限執行設定
go.run.configuration.run.with.sudo.mnemonic=使用提升的權限執行(&I)
go.run.configuration.add.go.tool.argument.label=添加
go.run.configuration.target.directory.label=目錄(&D)
go.run.configuration.target.files.label=檔案(&F):
go.run.configuration.target.package.label=軟體套件路徑(&E):
go.run.configuration.test.framework=測試框架(&R):
go.run.configuration.test.kind.label=測試種類(&K):
go.run.configuration.kind.directory=目錄
go.run.configuration.kind.package=軟體套件
go.run.configuration.kind.file=檔案
go.run.configuration.test.pattern.label=模式(&T):
go.run.configuration.use.all.custom.build.tags.label=使用所有自訂建置標記(&L)
go.run.configuration.use.all.custom.build.tags.tooltip=您的設定中的所有自訂建置標記都是在建置過程中添加的(請參閱“Go | 建置標記與 Vendoring”)
go.settings.build.tags.arch.label=Arch
go.settings.build.tags.cgo.support.label=cgo 支援
go.settings.build.tags.compiler.label=編譯器
go.settings.build.tags.custom.tags.hint=<html><body><p>以空格分隔的附加標記列表。<a href="https://www.jetbrains.com/help/go/configuring-build-constraints-and-vendoring.html">可以用於</a> `go build` 指令。</p></body></html>
go.settings.build.tags.custom.tags.label=自訂標記
go.settings.build.tags.description=<html><body><p>以下選項描述編輯器的目標系統。IDE 使用這些值定義在驗證、解析和程式碼補全中使用的檔案。有關這些選項的詳細資訊，請參閱 <a href="https://golang.org/pkg/go/build/#hdr-Build_Constraints">Go 約束文檔</a>。</p></body></html>
go.settings.build.tags.display.name=建置標記 \\& Vendoring
go.settings.build.tags.group.name=編輯器約束
go.settings.build.tags.os.label=OS
go.settings.build.tags.version.label=Go 版本
go.settings.build.tags.any.sdk.value=任意
go.settings.invalid.build.tag.error=建置標記無效: ''{0}''
go.settings.default.value=預設 ({0})
go.settings.project.sdk.value=專案 SDK ({0})
go.settings.default.for.project.sdk.value=SDK ({0}) 的預設值
go.settings.enabled=啟用
go.settings.disabled=禁用
go.settings.common.suggest.parameter.names.checkbox=在補全時建議參數名稱
go.settings.common.show.auto.import.in.completion.popup.checkbox=在鍵入時建議需要附加匯入的變體
go.settings.common.indent.on.enter.in.raw.strings.checkbox=在輸入原始字串時縮排
go.settings.common.show.documentation.in.parameter.info.checkbox=在參數資訊中顯示文檔
go.settings.common.detect.go.packages.from.clipboard.checkbox=從剪貼簿檢測 go 軟體套件
go.settings.common.enable.experimental.support.for.type.parameters=啟用泛型(實驗性支援類型參數)
go.settings.common.enable.experimental.support.for.type.parameters.tooltip=當前實作基於 Type Parameters - Draft Design - Ian Lance Taylor 和 Robert Griesemer 已於 2020 年 9 月 21 日發佈。
go.settings.common.enable.experimental.support.for.type.parameters.link.title=閱讀詳細資訊。
go.settings.common.confirmation.show.options.option=顯示選項
go.settings.common.package.rename.rename.directory.option=重命名目錄
go.settings.common.package.rename.do.not.rename.directory.option=不重命名目錄
go.settings.common.directory.rename.rename.package.option=重命名軟體套件
go.settings.common.directory.rename.do.not.rename.package.option=不重命名軟體套件
go.settings.common.test.rename.corresponding.file.option=重命名相應的測試或生產檔案
go.settings.common.test.do.not.rename.corresponding.file.option=不重命名相應的測試或生產檔案
go.settings.common.directory.rename.option=重命名目錄時
go.settings.common.package.rename.option=重命名軟體套件時
go.settings.common.test.rename.option=重命名檔案時
go.settings.common.convert.json.on.paste.option=貼上 JSON 時
go.settings.common.convert.json.on.paste.convert.option=將 JSON 轉換為 Go 類型
go.settings.common.convert.json.on.paste.insert.as.is.option=照原樣插入 JSON
go.settings.completion.ml.display.name=Go
go.settings.debugger.stack.depth.name=堆疊深度
go.settings.debugger.goroutines.limit.name=Goroutines 限制
go.settings.debugger.rebuild.transitive.packages.checkbox=重新建置過渡軟體套件(&R)
go.settings.debugger.rebuild.transitive.packages.description=為了獲得更好的偵錯體驗，Delve 需要在 $GOROOT/pkg 中重新編譯最佳化的模組。
go.settings.imports.display.name=匯入
go.settings.modules.display.title=Go 模組
go.settings.sdk.unknown.version.at.path=''{0}'' 中的 Go 版本未知
go.settings.sdk.detected.notification.title=檢測到 GOROOT
go.settings.sdk.detected.notification.text=<b>{0}</b> 被自動設定為專案 SDK。您可以在 GOROOT 設定中進行更改。
go.settings.sdk.detected.notification.configure.go.sdk.action.text=設定 Go SDK
go.settings.sdk.enable.integration.label=在模組中啟用 Go 支援: 
go.settings.sdk.combo.tooltip=添加 SDK…
go.settings.sdk.add.button=添加 SDK…
go.settings.sdk.add.action.name=本地…
go.settings.sdk.add.local.title=為 Go SDK 選擇主目錄
go.settings.sdk.add.button.tooltip=添加 SDK ({0})
go.settings.sdk.download.action.name=下載…
go.settings.sdk.download.dialog.title=下載 Go SDK
go.settings.sdk.download.dialog.version.label=版本:
go.settings.sdk.download.dialog.location.label=位置:
go.settings.sdk.download.dialog.reload.versions.action.name=重新載入
go.settings.sdk.download.dialog.progress.versions.status=Go SDK 版本
go.settings.sdk.download.dialog.cannot.load.go.versions.validation.message=無法載入 SDK 版本。{0}
go.settings.sdk.download.dialog.version.is.not.specified.validation.message=指定版本。
go.settings.sdk.download.dialog.location.is.not.specified.validation.message=指定目標目錄。
go.settings.sdk.download.dialog.cannot.create.directory.validation.message=無法在給定路徑中創建目錄。
go.settings.sdk.download.progress.downloading.status=正在下載 {0} {1}
go.settings.sdk.download.progress.verifying.status=正在驗證下載的歸檔…
go.settings.sdk.download.progress.unpacking.status=正在解壓縮 SDK…
go.settings.sdk.download.progress.copying.status=正在複製 SDK…
go.settings.sdk.download.progress.copying.detailed.status=正在複製 {0}…
go.settings.sdk.download.unpacked.sdk.is.corrupted.error=解壓縮的 SDK 損壞
go.settings.sdk.download.checksum.of.downloaded.file.mismatched.error=下載的檔案的校驗和不符合
go.settings.sdk.download.could.not.get.checksum.error=無法獲取校驗和: {0}
go.settings.sdk.download.could.not.find.go.directory.in.downloaded.file.error=無法在下載的檔案中找到 go 目錄
go.settings.sdk.download.could.not.unpack.downloaded.file.error=無法解壓縮下載的檔案
go.settings.sdk.download.could.not.copy.unpacked.sdk.error=無法複製解壓縮的 SDK
go.settings.sdk.download.installed.notification.title=已安裝 {0} {1}
go.settings.sdk.download.failed.to.download.notification.title=下載 SDK 失敗
go.settings.modules.enable.integration.checkbox=啟用 Go 模組整合
go.settings.modules.choose.module.dialog.title=選擇 Go 模組
go.settings.modules.choose.module.validation.message=選擇至少一個模組
filetype.go.settings.modules.dependency.description=Go 模組依賴關係檔案
go.settings.modules.goproxy.documentation.link.title=模組下載和驗證
go.settings.modules.goproxy.tooltip=GOPROXY 指示 go 指令在下載依賴項時使用特定的代理伺服器。
go.settings.modules.environment.label=環境：
go.settings.modules.environment.context.help=GOPROXY、GOPRIVATE 和其他環境變數
go.settings.modules.sync.dependencies.fix.family.name=同步依賴關係
go.settings.modules.sync.dependencies.fix.text=同步 {0} 的依賴關係
go.settings.modules.vendoring.checkbox=自動啟用供應支援
go.settings.modules.vendoring.checkbox.tooltip=自 Go 1.14 以來被忽略。<br>在 Go 1.14 之前，每當模組包含 vendor 目錄時，都會啟用 vendoring 支援。特別是，IDE 使用 '-mod=vendor' 標誌執行 go 工具。
go.settings.modules.vendoring.documentation.link.title=如何為模組使用 vendoring
go.settings.run.configuration.invalid.env.name=非法的環境變數名稱: ''{0}''
go.settings.run.configuration.invalid.env.value=環境變量值 ''{0}'' 非法: ''{1}''
go.settings.modules.explain.environment.variable=解釋變數
go.settings.modules.add.other.environment.variable=其他
go.settings.modules.gosumdb.description=GOSUMDB 可以識別校驗和資料庫的名稱。go 指令使用它來確保下載的依賴項的校驗和沒有更改。
go.settings.modules.gosumdb.documentation.link.title=模組身份驗證失敗
go.settings.modules.goprivate.description=GOPRIVATE 列出了被視為 private 的軟體套件。在下載和驗證這些軟體套件時，go 指令不會使用代理或校驗和資料庫。
go.settings.modules.goprivate.documentation.link.title=非 public 模組的模組設定
go.settings.modules.gonoproxy.description=GONOPROXY 列出了被視為 private 的軟體套件。下載這些軟體套件時，go 指令不會使用代理。覆蓋 GOPRIVATE。
go.settings.modules.gonosumdb.description=GONOSUMDB 列出了被視為 private 的軟體套件。驗證這些軟體套件時，go 指令不會使用校驗和資料庫。覆蓋 GOPRIVATE。
go.settings.modules.gomodcache.description=GOMODCACHE 設定模組快取位置。
go.settings.modules.gomodcache.documentation.link.title=Go 1.15 發行說明
go.settings.postfix.enter.type.import.path.label=匯入路徑(&I):
go.settings.postfix.enter.type.name.label=類型名稱(&T):
go.settings.postfix.enter.type.empty.type.validation.message=指定類型名稱
go.settings.postfix.enter.type.action.name=輸入類型名稱…
go.settings.postfix.choose.type.action.name=選擇類型…
go.settings.postfix.choose.type.prompt.text=選擇類型
go.settings.vendoring.cannot.be.disabled.error.message=無法在 Go {0} 中禁用 Go Vendor Experiment
go.settings.vendoring.description=<html>\n  <head>\n    \n  </head>\n  <body>\n    <p>\n      啟用此選項後，IDE 將根據 <a href="https://golang.org/s/go15vendor">Go Vendor Experiment 提案</a>解析和補全符號。\n    </p>\n    <p>\n      此外，還將為 IDE 中的所有 go 執行設定 <strong>GO15VENDOREXPERIMENT</strong> 環境變數的相應值。\n    </p>\n  </body>\n</html>
go.settings.vendoring.enable.vendoring.checkbox=啟用 vendoring
go.settings.vendoring.group.name=供應商實驗
go.settings.vendoring.is.not.supported.error.message=Go {0} 不支持 Go Vendor Experiment
go.template.intention.add.type.hint.name=指定點類型
go.template.intention.associate.file.extension.with.go.template=關聯檔案擴展與 Go 模板
go.template.intention.extension.associated.with.template=''{0}'' 擴展已關聯 Go 模板
go.template.intention.open.file.type.settings=開啟 Go 模板檔案類型設定
go.template.intention.undo=撤消
go.unknown.type.information.hint=<未知>
group.GoTools.description=Go 外部工具
group.GoTools.text=Go 工具
go.call.hierarchy.respect.interface.calls.action.name=遵循接口調用
go.call.hierarchy.respect.interface.calls.description=遵循接口調用
go.settings.formatter.no.exceptions.empty.text=無異常
go.settings.formatter.comment.prefix.dialog.title=註釋前綴
go.settings.formatter.wrap.call.arguments=函數調用實參
go.settings.formatter.wrap.comp.lit=複合文字
go.settings.formatter.wrap.func.params=函數參數
go.settings.formatter.wrap.func.result=函數結果參數
go.settings.diff.ignore.imports.and.formatting.description=忽略匯入和格式化
go.settings.debugger.default.integer.format.label=預設整數格式:
go.executable.file.chooser.title=選擇 {0}
go.executable.file.process.icon.tooltip=正在發現 {0}
go.executable.file.invalid.path.text=無效路徑
go.executable.file.cannot.retrieve.version=無法檢索版本
go.executable.file.empty.value=<Empty>
go.fmt.add.leading.space.to.comments=向註釋添加前導空格
go.fmt.add.parentheses.for.single.import=為單個匯入添加括號
go.fmt.group.stdlib.imports=組合 stdlib 匯入
go.fmt.imports.tab.title=匯入
go.fmt.move.all.imports.in.single.declaration=將所有匯入移動到一個宣告中
go.fmt.move.all.stdlib.imports.in.single.group=將所有 stdlib 匯入移動到一個組中
go.fmt.remove.redundant.import.aliases=移除冗餘匯入別名
go.fmt.import.sorting.type=排序類型
go.fmt.use.back.quotes.for.imports=為匯入使用左引號
go.fmt.fill.paragraph.width.label=填充段落寬度: 
go.fmt.create.local.group.label=組
go.fmt.for.current.project.packages=當前專案軟體套件
go.fmt.for.imports.starting.with.prefix=匯入開頭:
go.fmt.for.imports.starting.with.prefix.comment=逗號分隔的前綴列表，與 'goimports -local' 相同
go.fmt.imports.prefix.error.title=匯入前綴錯誤
go.fmt.imports.prefix.error.empty.message=匯入前綴不能為空
go.fmt.run.gofmt.panel.border.title=執行 gofmt
go.fmt.run.gofmt.on.code.reformat.label=程式碼重新格式化時(&R)
go.debugger.disconnected.unexpectedly=偵錯器意外斷開連接
go.debugger.failed.to.compute.node.presentation=無法計算節點表示
go.debugger.connection.failed.generic.message=連接到 {0} 失敗
go.debugger.connecting.to.address.message=正在連接到 {0}…
go.debugger.connecting.to.unknown.address.message=正在連接到遠端地址…
go.debugger.cannot.retrieve.go.processes=無法檢索 Go 行程
go.debugger.install.gops.to.attach.to.go.processes=安裝 {0} 以附加到 Go 行程
go.debugger.local.attach.group.name=Go
go.debugger.breakpoint.title=Go 中斷點
go.debugger.error.breakpoint.title=Go 錯誤中斷點
go.debugger.error.breakpoint.display.text=致命錯誤
go.debugger.missing.function.name=<缺少>
go.debugger.record.and.debug.action.name=錄製並偵錯
go.debugger.record.and.debug.description=錄製並偵錯
go.debugger.record.and.debug.start.action.text=錄製並偵錯
go.debugger.record.and.debug.cannot.find.rr.message=<html>無法找到 <a href="https://rr-project.org">mozilla rr</a> 可執行檔案。請安裝並將其添加到 PATH 中。</html>
go.debugger.internal.messaging.error=內部訊息傳遞錯誤
go.debugger.cannot.connect.twice=Delve 行程不能連接兩次
go.debugger.cannot.connect.non.remote=Delve 行程無法連接，因為它未使用遠端連接
go.debugger.cannot.evaluate.expression=無法評估表達式 ''{0}'': {1}
go.debugger.cannot.get.current.goroutine=無法獲取當前 goroutine
go.debugger.go.version.is.not.officially.supported=Go {0} 不受該偵錯器的官方支援，某些功能可能無法正常使用。請升級到 Go {1} 或更高版本。
go.debugger.go.version.is.not.supported=Go {0} 不受該偵錯器的支援。請升級到 Go {1} 或更高版本。
go.debugger.no.debug.information.for.file=可執行檔案不包含 {0} 的偵錯資訊
go.debugger.cannot.find.debugger.path=無法找到 {0} 的偵錯器路徑
go.debugger.cannot.pause=無法暫停
go.debugger.recording.in.progress=正在記錄程序執行。要偵錯記錄，請等待程序終止或<a href=''{0}''>停止記錄</a>。
go.debugger.failed.to.stop.mozilla.rr.recording=無法停止 mozilla rr 記錄
go.debugger.failed.to.stop.mozilla.rr.recording.details=無法停止 mozilla rr 記錄: {0}
go.debugger.cannot.evaluate.call=無法評估調用: {0}
go.debugger.non.top.frame.selected=已選擇非頂部框架
go.debugger.missing.current.function=缺少當前函數
go.debugger.unused.functions.are.not.included.message=" (未使用的函數未包含在可執行檔案中)"
go.debugger.unused.methods.are.not.included.message=" (未使用的方法未包含在可執行檔案中)"
go.debugger.smart.step.into.failed=智能單步進入失敗: {0}
go.debugger.expression.is.not.a.function=''{0}'' 不是函數
go.debugger.expression.is.nil=''{0}'' 為零
go.debugger.cannot.retrieve.interface.value.type=無法檢索接口值的類型
go.debugger.cannot.get.current.stack=無法獲取當前堆疊
go.debugger.smart.step.into.popup.title=單步進入函數
go.debugger.renderers.binary.name=二進制
go.debugger.renderers.decimal.name=十進制
go.debugger.renderers.hex.name=十六進制
go.debugger.renderers.default.renderer.name=預設渲染器
go.debugger.computing.full.value.of.call.results.is.not.supported=不支持計算調用結果的完整值
go.debugger.cannot.calculate.value=無法計算值
go.debugger.obsolete.value=<過時>
go.debugger.cannot.calculate.string.presentation=無法計算字串表示: {0}
go.debugger.unsupported.type=<不支持的類型: {0}>
go.debugger.cannot.load.remaining.call.result.children=無法載入調用結果的剩餘子級
go.debugger.unreadable.error=\ 不可讀: {0}
go.debugger.fmt.sprintf.unsupported.format=(不支持的格式)
go.debugger.fmt.sprintf.unsupported.verb=(不支持的動詞)
go.debugger.fmt.sprintf.cannot.format.value=(無法格式化值)
go.debugger.async.stacktrace.caption=異步堆疊跟踪
go.debugger.thread=執行緒
go.debugger.goroutine=Goroutine
go.debugger.unsupported.architecture.error=僅 64 位系統和 32 位 Linux 系統支援偵錯
go.debugger.unsupported.go.version.on.darwin.arm64.error=在 darwin/arm64 上偵錯要求 Go 1.16
go.debugger.unsupported.go.arch.on.darwin.arm64.error=不支持偵錯使用 {0} 編譯的程序。對 darwin/arm64 使用 go sdk。
go.debugger.only.first.goroutines.are.shown=僅顯示第一個 {0} goroutines
go.debugger.thread.dump.error=無法獲取執行緒轉儲: {0}
go.debugger.thread.dump.display.name=轉儲 {0}
go.debugger.thread.dump.incomplete.display.name=轉儲 {0} 不完整
go.debugger.cannot.find.file=找不到檔案 {0}
go.debugger.unknown.function.name=<未知>
go.debugger.create.dump.background.task.title=正在轉儲堆疊…
go.debugger.create.dump.background.task.progress.text=正在轉儲堆疊({0})…
go.debugger.thread.dump.n.goroutines={0} {0,choice,0#goroutines|1#goroutine|2#goroutine}
go.debugger.thread.dump.n.unique.stacks={0} 唯一 {0,choice,0#堆疊|1#個堆疊|2#個stacks}
go.debugger.thread.dump.n.hidden.goroutines={0} 隱藏的 {0,choice,0#goroutines|1#goroutine|2#goroutines}
go.debugger.thread.dump.n.goroutines.matched.by.filter={0} 個 {0, choice, 0#goroutine|1#goroutine|2#goroutine} 通過篩選器符合
go.debugger.another.command.is.in.progress=正在執行另一條指令
go.debugger.thread.dump.is.in.progress=正在進行執行緒轉儲
go.debugger.and.n.more=和其他 {0} 個
go.debugger.hidden.group.name=已隱藏({0})
go.debugger.stop.remote.delve.title=停止遠端 Delve
go.debugger.stop.remote.delve.message=是否要停止遠端 Delve 實例?
go.debugger.process.terminated.stop.remote.delve.message=遠端行程已終止。是否也要停止遠端 Delve 實例?
go.debugger.kill.existing.process.title=終止遠端行程
go.debugger.kill.existing.process.message=是否要終止偵錯器所連接的遠端行程?
go.debugger.custom.delve.notification=正在使用自訂 Delve 進行偵錯: {0}
go.debugger.custom.delve.extended.notification=正在使用自訂 Delve 進行偵錯: {0}。刪除 dlv.path <a href=''customProperties''>自訂屬性</a>並重啟 IDE 以使用捆綁的 Delve。
go.remote.debug.disconnect.delve.label=斷開連接時:
go.remote.debug.disconnect.delve.option.ask=詢問
go.remote.debug.disconnect.delve.option.leave=保持執行
go.remote.debug.disconnect.delve.option.stop=停止遠端 Delve 行程
go.settings.debugger.general.section.name=Go
go.settings.debugger.dataViews.section.name=Go
go.execution.package.is.not.specified.error=未指定軟體套件
go.execution.directory.is.not.specified.error=未指定目錄
go.execution.file.is.not.specified.error=未指定檔案
go.execution.cannot.find.package.error=找不到軟體套件 <code>{0}</code>
go.execution.package.contains.several.mains.error=軟體套件 <code>{0}</code> 包含多個 <code>main</code> 函數<br>請考慮改用檔案種類
go.execution.cannot.find.directory.error=無法找到目錄 <code>{0}</code>
go.execution.run.after.build.is.not.possible.incompatible.os.error=無法在建置後執行<br>結果二進制檔案將與操作系統不相容
go.execution.run.after.build.is.not.possible.main.not.found.single.file.error=無法在建置後執行<br>'main' 檔案具有非 main 軟體套件或不包含 'main' 函數
go.execution.run.after.build.is.not.possible.main.not.found.many.files.error=無法在建置後執行<br>所選檔案都沒有 'main' 軟體套件和 'main' 函數
go.execution.file.not.found.error=找不到檔案: <code>{0}</code>
go.execution.files.must.be.in.one.directory.error=命名檔案必須全部位於一個目錄中
go.execution.not.go.file.error=檔案不是 Go 檔案: {0}
go.execution.application.run.configuration.display.name=Go 建置
go.execution.application.run.configuration.description=Go 建置執行設定
go.execution.before.run.task.name=執行 Go 指令
go.execution.before.run.task.description=執行 `{0}`
go.execution.before.run.task.supports.only.go.run.configurations.error=Go 指令任務僅支援 Go 執行設定
go.execution.before.run.task.supports.only.go.modules.error=Go 指令任務僅支援啟用了 Go 整合的模組
go.execution.before.run.task.executing.presentable.name=正在執行 `{0}`
go.execution.before.run.task.error.dialog.title=Go 指令任務
go.execution.before.run.task.edit.go.command.dialog.title=編輯 Go 指令任務
go.execution.before.run.task.empty.command.error=不允許空 Go 指令
go.execution.before.run.task.command.should.not.start.with.go.error=Go 指令不應以 'go' 開頭
go.execution.coverage.percent.statements=% 語句
go.execution.coverage.percent.files=% 檔案
go.execution.coverage.covered=已覆蓋
go.execution.coverage.engine.name=Go 覆蓋率
go.execution.coverage.cannot.run.coverage.on.directory.kind.run.configurations.error=無法在目錄種類執行設定上執行覆蓋率分析
go.execution.coverage.loading.coverage.data=正在載入覆蓋率資料…
go.execution.coverage.runner.name=Go
go.execution.coverage.downloading.coverage.report.progress.title=正在下載覆蓋率報告…
go.execution.test.collecting.build.tags.progress.title=正在收集建置標記…
go.test.creator.empty.test.file.name=空測試檔案
go.test.creator.test.for.function.name=函數測試
go.test.creator.test.for.file.name=檔案測試
go.test.creator.test.for.package.name=軟體套件測試
go.test.creator.test.for.selection.name=選擇範圍測試
go.test.creator.gotests.generation.name=測試生成
go.test.creator.gotests.no.tests.generated=未生成測試
go.test.creator.gotests.failed.to.create.test.file=無法創建測試檔案 {0}
go.test.creator.gotests.generation.failed.notification.title=測試生成失敗
go.test.creator.cannot.find.test.package.name=無法找到測試軟體套件名稱
go.test.creator.cannot.find.test.import.path=無法找到測試匯入路徑
go.test.creator.cannot.find.function.signature=無法找到函數簽名
go.test.creator.cannot.find.method.receiver=無法找到 {0} 的方法接收器
go.test.creator.cannot.find.method.receiver.type=無法找到 {0} 的方法接收器類型
go.test.creator.cannot.find.field.type=無法找到 {0} 的欄位類型
go.test.generate.table.benchmark.text=表基準
go.test.generate.table.benchmark.description=生成表基準函數
go.test.generate.table.test.text=表測試
go.test.generate.table.test.description=生成表測試函數
go.test.generate.function.description=生成 {0} 函數
go.test.generate.test.text=測試
go.test.generate.test.main.text=Test_main
go.test.generate.benchmark.text=基準
go.test.generate.example.text=範例
go.test.testify.run.configuration.name={1} 中的 {0}
go.test.testify.unknown.target.name=未知
go.test.framework.not.available.in.module.error=框架 <code>{0}</code> 在所選模組中不可用
go.test.working.directory.should.be.ancestor.of.testing.directory.error=工作目錄應當是該測試目錄的上級
go.test.testing.directory.does.not.exist.error=測試目錄不存在
go.test.non.a.package.error=<code>{0}</code> 不是軟體套件。<br>使用目錄類型執行設定，以在目錄上遞歸執行測試。
go.test.cannot.find.files.compatible.with.framework.error=無法在與 <code>{1}</code> 框架相容的 <code>{0}</code> 中找到 Go 測試檔案
go.test.file.does.not.exist.error=檔案不存在: {0}
go.test.not.go.file.error=檔案 ''{0}'' 不是 Go 檔案
go.test.framework.is.not.available.on.files.error=框架 <code>{0}</code> 在任何檔案 <code>{1}</code> 上都不可用
go.test.suggested.run.configuration.name={1} 中的 {0}
go.test.run.configuration.name=Go 測試
go.test.run.configuration.description=Go 測試執行設定
go.test.template.run.configuration.name=Go 測試
go.test.run.test.tooltip=執行測試
go.test.no.tests.were.run=未執行任何測試
go.test.cannot.run.compiling.on.directory.kind.run.configurations.error=無法在目錄種類執行設定上執行編譯
go.execution.cannot.find.target.to.compile.error=無法找到要編譯的目標
go.execution.cannot.create.temp.output.file.error=無法創建臨時輸出檔案
go.execution.cannot.create.output.file.error=無法創建輸出檔案 {0}
go.execution.cannot.create.output.file.in.error=無法在 {0} 中創建輸出檔案
go.execution.cannot.make.temporary.file.executable.error=無法使臨時檔案成為可執行檔案 {0}
go.execution.could.not.bind.remote.debugging.port.error=無法綁定遠端偵錯連接埠
go.execution.cannot.find.target.error=無法找到目標 {0}
go.execution.sdk.not.set.or.sdk.home.path.empty.for.module.error=未設定 SDK 或此模組的 SDK 主路徑為空
go.execution.can.not.run.go.local.process.error=無法執行 Go 本地行程
go.execution.failed.to.prepare.remote.environment.error=無法準備遠端環境: {0}
go.execution.outdated.go.notification.title=您的 Go 版本已過時
go.execution.outdated.go.notification.text=要完全支援所有偵錯功能，請更新 Go 版本。
go.execution.change.goroot.action.name=更改 GOROOT
go.execution.compilation.finished.with.exit.code=編譯完成，並顯示退出程式碼 $EXIT_CODE$
go.execution.compiled.binary.cannot.be.executed=無法執行已編譯的二進制檔案
go.execution.compilation.failed.notification.title=編譯失敗
go.execution.install.lldb.notification.text=使用 xcode-select --install 安裝 lldb
go.execution.go.setup.folding.placeholder=<{0} go 設定{0,choice,1#調用|2#調用}>
go.execution.remote.run.configuration.display.name=Go Remote
go.execution.remote.run.configuration.description=Go Remote
go.execution.remote.run.configuration.start.delve.text=在執行此設定之前，請按以下說明啟動您的應用程式和 Delve。<br> <br>允許 Delve 編譯您的應用程式: <br><pre>dlv debug --headless --listen=:{0} --api-version=2 --accept-multiclient</pre><br>或使用 Go {3} 或更高版本編譯該套用程序: <br><pre>go build -gcflags \"all=-N -l\" github.com/app/demo</pre><br>，然後使用以下指令在 Delve 中執行: <br><pre>dlv --listen=:{1} --headless=true --api-version=2 --accept-multiclient exec ./{2}</pre>
go.execution.remote.run.configuration.host.label=主機(&H):
go.execution.remote.run.configuration.port.label=連接埠(&P):
go.execution.sdk.is.not.specified.error=沒有為模組 <code>{0}</code> 指定 Go SDK
go.execution.module.does.not.exist.error=模組 <code>{0}</code> 在專案中不存在
go.execution.working.directory.is.not.specified.error=未指定工作目錄
go.execution.cannot.find.working.directory.error=無法找到工作目錄 <code>{0}</code>
go.execution.input.file.is.not.specified.error=未指定輸入檔案
go.execution.cannot.find.input.file.error=無法找到輸入檔案 <code>{0}</code>
go.execution.go.is.not.configured.error=沒有為此執行設定設定 Go: {0}
go.execution.run.application.tooltip=執行套用程序
go.execution.process.finished.with.exit.code={0} 已完成，退出程式碼為 {1}
go.execution.application.process.name=行程
go.execution.debugger.process.name=偵錯器
go.execution.unknown.target.delve.socket.error=無法執行 Delve。目標套接字未知。RunState: {0}
go.execution.process.interrupted=已中斷
go.execution.process.cancelled=已取消
go.execution.go.sdk.is.not.downloaded.yet=Go SDK 尚未下載
go.execution.process.finished.successfully=成功完成
go.execution.process.failed.to.run=執行失敗
go.execution.unknown.error=未知錯誤，詳情參見日誌
go.execution.enter.sudo=輸入您的 sudo 密碼:
go.import.optimizer.removed.imports=移除的 {0} 個{0,choice,1#匯入|2#匯入}
go.import.optimizer.removed.aliases=移除的 {0} 個{0,choice,1#別名|2#別名}
go.import.optimizer.removed.imports.and.aliases=移除的 {0} 個{0,choice,1#匯入|2#匯入}和 {1} 個{0,choice,1#別名|2#別名}
go.import.package.fix.family.name=匯入軟體套件
go.import.package.fix.text=匯入軟體套件
go.import.package.fix.text.no.variants=匯入軟體套件?
go.import.package.fix.text.single.variant=匯入{0}?
go.import.package.fix.text.many.variants=匯入{0}? (多個選擇…)
go.import.package.popup.title=要匯入的軟體套件
go.import.package.cannot.invoke.fix.with.ambiguous.imports.error=無法在編輯器 {0} 中對不明確的匯入調用修正。軟體套件: {1}
go.create.intermediate.variable.declaration.fix.name=創建中間變數
go.add.import.command.name=添加匯入
go.add.import.with.alias.presentation={0} 作為 {1}
go.error.parser.expected=應為 ''{0}''
go.error.parser.expected.got=應為 ''{0}''，但得到的是 ''{1}''
go.error.parser.expected.or.got=應為 ''{0}'' 或 ''{1}''，但得到的是 ''{2}''
go.error.parser.unexpected=意外的''{0}''
go.error.annotator.invalid.package.name=無效的軟體套件名稱
go.error.annotator.continue.statement.not.inside.a.for.loop='continue' 語句在 'for' 迴圈外部
go.error.annotator.break.statement.not.inside.a.for.loop.select.or.switch='break' 語句在 'for'、'select' 或 'switch' 語句外部
go.error.annotator.unexported.reference.usage=使用了未匯出的{0} ''{1}'' 
go.error.annotator.type.is.not.an.expression=類型 ''{0}'' 不是表達式
go.error.annotator.unexported.type.usage=使用未匯出類型 ''{0}''
go.error.annotator.reference.is.not.a.type={0} 不是類型
go.error.annotator.missing.key.in.map.literal=映射文字中缺少鍵
go.error.annotator.use.of.type.outside.type.switch=在類型 switch 外部使用 .(type)
go.error.annotator.invalid.type.assertion=無效的類型斷言: {0} (左側為非接口類型 {1})
go.error.annotator.invalid.type.switch.guard=無效的類型 switch 臨界: {0} (左側為非接口類型 {1})
go.error.annotator.map.key.type.is.not.comparable=無效的映射鍵類型: 必須為鍵類型完全定義比較運算符 == 和 !=
go.error.annotator.call.used.as.value.but.it.returns.nothing={0} 用作值，但它不返回任何內容
go.error.annotator.multiple.value.in.single.value.context=單值上下文中存在多值 {0}
go.error.annotator.type.aliases.are.available.since.go.1.9=類型宣告中存在意外的 '='；類型別名自 Go 1.9 以後可用
go.error.annotator.missing.function.body=缺少{0}正文
go.error.annotator.main.or.init.has.invalid.signature={0} 函數不得有實參和返回值
go.error.annotator.invalid.index.or.slice.operation=無效的操作 {0} (字串的 3 索引切片)
go.error.annotator.unexpected.end.of.statement=語法錯誤: 語句意外結束，應為 ':='、'=' 或 ','
go.error.annotator.unexpected.newline.after.if=意外換行，在 'if' 子句後應為 '{'
go.error.annotator.missing.condition.in.if.statement='if' 語句中缺少條件
go.error.annotator.semicolon.is.missing=缺少 ;
go.error.annotator.fallthrough.statement.out.of.place='fallthrough' 語句位置不當
go.error.annotator.cannot.fallthrough.final.case.in.switch=不能在 'switch' 語句的 final case 中使用 'fallthrough'
go.error.annotator.cannot.fallthrough.in.type.switch=無法在類型 switch 中使用 'fallthrough'
go.error.annotator.end.of.file.in.comment=檔案結尾位於註釋中
go.error.annotator.array.bound.must.be.a.constant.expression=無效的陣列綁定 ''{0}''，必須是一個常數表達式
go.error.annotator.array.bound.must.be.non.negative=無效的陣列綁定 ''{0}''，必須為非負
go.error.annotator.array.bound.must.be.representable.by.int.type=無效的陣列綁定 ''{0}''，該值必須可以通過 ''int'' 類型表示
go.error.annotator.invalid.argument.for.len=len 函數的實參無效
go.error.annotator.invalid.argument.for.cap=cap 函數的實參無效
go.error.annotator.cannot.declare.init.must.be.a.function=無法宣告 init，必須為函數
go.error.annotator.too.many.arguments.to.new=實參過多，無法添加新實參
go.error.annotator.cannot.make.type=無法生成 {0}
go.error.annotator.argument.is.not.a.type={0} 不是類型
go.error.annotator.missing.argument.to.make=缺少要生成的實參
go.error.annotator.non.integer.size.argument.to.make=make 函數中存在非整數大小實參
go.error.annotator.non.integer.capacity.argument.to.make=make 函數中存在非整數容量實參
go.error.annotator.missing.len.argument.to.make=make 函數中缺少 len 實參
go.error.annotator.too.many.arguments.to.make=make 函數中的實參過多
go.error.annotator.cyclic.definition.detected=檢測到迴圈定義
go.error.annotator.use.of.package.without.selector=使用無選擇器的軟體套件 ''{0}''
go.error.annotator.unexpected.assign.operator=意外的 {0}，應為 '':=''、''='' 或 '',''
go.error.annotator.invalid.constant.type=無效的常數類型
go.error.annotator.const.initializer.is.not.a.constant=常數初始設定式 ''{0}'' 不是常數
go.error.annotator.missing.value.in.const.declaration=常數宣告中缺少值
go.error.annotator.extra.expression.in.const.declaration=常數宣告中有額外表達式
go.error.annotator.conversion.in.defer.or.go={0} 需要函數調用，而不是轉換
go.error.annotator.function.not.permitted.in.defer.or.go=無法在 {0} 語句中調用此函數
go.error.annotator.parenthesized.expression.in.defer.or.go={0} 中的表達式不得使用括號
go.error.annotator.defer.or.go.requires.function.call={0} 中的表達式必須為函數調用
go.error.annotator.evaluated.but.not.used={0} 已評估但未使用
go.error.annotator.cannot.declare.in.post.statement.of.for.loop=無法在 for 迴圈的 post 語句中宣告變數
go.error.annotator.too.many.variables.in.range=範圍中的變數過多
go.error.annotator.named.and.unnamed.parameters={0} 同時具有命名參數和未命名參數 ''{1}''
go.error.annotator.named.and.unnamed.return.parameters={0} 同時具有命名和未命名的返回參數 ''{1}''
go.error.annotator.can.only.use.triple.dot.as.final.argument=只能將 '...' 用作列表中的最後一個實參
go.error.annotator.cannot.use.triple.dot.for.output.arguments=無法在輸出實參列表中使用 '...'
go.error.annotator.method.name.in.interface.cannot.be.blank=接口中的方法名稱不能為空
go.error.annotator.digit.separator.is.not.supported=從 Go 1.13 開始支援數字分隔符
go.error.annotator.binary.digits.are.not.supported=從 Go 1.13 開始支援二進制數字
go.error.annotator.octal.prefix.is.not.supported=從 Go 1.13 開始支援八進制前綴
go.error.annotator.hex.floats.are.not.supported=從 Go 1.13 開始支援十六進制浮點
go.error.annotator.closing.single.quote.expected=應為右 '
go.error.annotator.empty.rune.literal=空盧恩文字
go.error.annotator.too.many.characters.in.rune.literal=rune 文字中的字符數過多
go.error.annotator.invalid.select.assignment=select 賦值的右側必須有接收運算
go.error.annotator.invalid.select.case=Select case 必須具有接收運算、發送運算、賦值或短變數宣告
go.error.annotator.cannot.reassign.a.constant=不能重新分配常數
go.error.annotator.no.new.variables=':=' 的左側沒有新變數
go.error.annotator.assignment.count.mismatch=賦值計數不符合: {0} = {1}
go.error.annotator.cannot.assign.to.expression=無法分配給 {0}
go.error.annotator.multiple.defaults={0} 中存在多個預設值
go.error.annotator.new.line.in.string=字串中出現新行
go.error.annotator.bad.octal.escape=八進制轉義必須包含三個八進制數字，第一個數字必須小於或等於 3
go.error.annotator.invalid.hex.escape.sequence.syntax=\\x 必須後跟兩個十六進制數字
go.error.annotator.invalid.unicode.escape.sequence.syntax=\\u 必須後跟四個十六進制數字
go.error.annotator.invalid.long.unicode.escape.sequence.syntax=\\U 必須後跟八個十六進制數字
go.error.annotator.invalid.escape.sequence=無效的轉義序列
go.error.annotator.invalid.unicode.code.point=無效的 Unicode 程式碼點
go.error.annotator.invalid.embedded.type=無效的類型 {0}: 必須為 typeName 或 *typeName
go.error.annotator.embedded.type.cannot.be.a.pointer=嵌入類型不能是指針
go.error.annotator.embedded.type.cannot.be.a.pointer.to.interface=嵌入類型不能是指向接口的指針
go.error.annotator.cannot.call.pointer.method=無法在 ''{0}'' 中調用指針方法
go.error.annotator.type.parameters.are.not.supported=泛型(實驗性支援類型參數)已禁用
go.go.mod.error.annotator.no.module.statement=檔案中沒有模組語句
go.go.mod.error.annotator.multiple.module.statements=檔案中存在多個模組語句
go.go.mod.error.annotator.multiple.version.statements=檔案中存在多個 go 版本的語句
go.go.mod.error.annotator.missing.dependency=缺少依賴關係
go.go.mod.error.annotator.unresolved.dependency=未解析的依賴項
go.go.mod.error.module.version.expected=應為模組版本
go.terms.duplicate=重複
go.terms.duplicated.case=重複的 case
go.terms.duplicated.default=重複的預設值
go.terms.version.statement=版本語句
go.terms.module.statement=模組語句
go.terms.empty.declaration=空宣告
go.terms.shadowed.declaration=隱藏的宣告
go.terms.comment=註釋
go.terms.variable=變數
go.terms.method=方法
go.terms.closure=結束
go.terms.import=匯入
go.terms.parameter=參數
go.terms.receiver=接收器
go.terms.import.alias=匯入別名
go.terms.label=標籤
go.terms.package=軟體套件
go.terms.package.statement=\ package 語句
go.terms.package.capitalized=軟體套件
go.terms.map=映射
go.terms.chan=chan
go.terms.string=字串
go.terms.array=陣列
go.terms.declaration=宣告
go.terms.statement=語句
go.terms.semicolon=分號
go.terms.comma=逗號
go.terms.go.statement=go 語句
go.terms.case=case
go.terms.slice=切片
go.terms.pointer=指針
go.terms.struct=struct
go.terms.anonymous.field=匿名欄位
go.terms.type.alias=類型別名
go.terms.global.variable=全域變數
go.terms.constant=常數
go.terms.global.constant=全域常數
go.terms.field=欄位
go.terms.type=類型
go.terms.type.pluralized=類型
go.terms.interface=接口
go.terms.function=函數
go.terms.method.specification=方法規範
go.refactoring.implement.methods.command=實作{0}
go.refactoring.implement.methods.prompt=選擇要實作的接口:
go.refactoring.implement.methods.checkbox=非專案(&N)
go.refactoring.implement.methods.dummy.background.updater.task.title=正在搜尋類型…
go.refactoring.implement.methods.create.type.name=創建類型…
go.refactoring.declarations.separator=宣告
go.refactoring.exported.column.name=已匯出
go.refactoring.extract.interface.caret.should.be.inside.type.error.message=文字游標應置於要重構的類型內
go.refactoring.unexported.validation.message=未匯出的{0}將不再可以從{1}存取
go.refactoring.redeclare.validation.message={0} 將重新宣告相同名稱的 {1}
go.refactoring.less.than.one.declaration.validation.message=應至少選擇一個宣告。
go.refactoring.empty.target.directory.path.validation.message=目標目錄路徑不應為空。
go.refactoring.empty.target.file.name.validation.message=目標文件名不應為空。
go.refactoring.incorrect.file.name.validation.message=目標文件名不正確。
go.refactoring.empty.target.package.validation.message=目標軟體套件名稱不應為空。
go.refactoring.incorrect.package.name.validation.message=目標軟體套件名稱不正確。
go.refactoring.non.writable.directory.validation.message=目標目錄不可寫。
go.refactoring.non.writeable.file.validation.message=目標檔案不可寫。
go.refactoring.different.package.name.validation.message=現有檔案的軟體套件名稱不應不同。
go.refactoring.non.go.file.validation.message=目標檔案應為 Go 檔案。
go.refactoring.file.chooser.dialog.title=選擇目標目錄或檔案
go.refactoring.file.label=目標檔案:
go.refactoring.failed.to.create.directory.error.message=無法找到或創建目錄 ''{0}''
go.refactoring.failed.to.create.file.for.package.error.message=無法為軟體套件 ''{1}'' 找到或創建檔案 ''{0}''
go.refactoring.refactor.action=重構
go.refactoring.rename.action=收藏列表的新名稱
go.refactoring.inline.defined.in.goroot.error.message={0} {1} 在 GOROOT 中定義
go.refactoring.inline.no.initializer.error.message={0} {1} 沒有初始設定式
go.refactoring.inline.no.parameter.value.error.message=無法找到參數 {0} 的值
go.refactoring.inline.defined.in.multi.value.context.error.message={0} {1} 在多值上下文中定義
go.refactoring.inline.reassigned.error.message=已重新分配 {0}
go.refactoring.inline.found.usages.in.goroot.message=已在 GOROOT 中找到 ''{1}'' 的 {0, choice, 1#1 個用法|2#{0} 個用法}。
go.refactoring.inline.kept.definition.and.inlined.message=已保留定義{0, choice, 0#|1#和專案與 GOPATH 中的 1 個內聯用例|2#和專案與 GOPATH 中的 {0} 個內聯用例}。
go.refactoring.inline.cannot.inline.variadic.parameter=不支持內聯可變形參
go.refactoring.change.signature.reuse.types.checkbox=重用類型
go.refactoring.change.signature.result.parameters.tab.title=結果參數
go.refactoring.change.signature.not.legal.identifier.validation.message=''{0}'' 不是合法關鍵字。
go.refactoring.change.signature.named.and.unnamed.parameters.validation.message=無法同時使用命名參數和未命名參數。
go.refactoring.change.signature.parameter.without.type.validation.message=第 {0,number,ordinal} 個參數應具有類型。
go.refactoring.change.signature.used.multiple.times.validation.message=''{0}'' 被多次使用。
go.refactoring.change.signature.variadic.parameter.in.result.validation.message=結果中不允許使用可變形參。
go.refactoring.change.signature.variadic.is.not.last.validation.message=可變參數應始終是最後一個參數。
go.refactoring.change.signature.method.specification.and.implementations.option={0}方法規范和所有實作
go.refactoring.change.signature.current.method.option=僅{0}當前方法
go.refactoring.change.signature.target.not.found.error.message=文字游標必須位於要重構的函數或方法的名稱處
go.refactoring.change.signature.function.will.not.start.application.validation.message=函數 {0} 將不再啟動應用程式
go.refactoring.change.signature.function.will.not.perform.initialization.validation.message=函數 {0} 將不再執行初始化
go.refactoring.change.signature.renamed.parameter.validation.message.part=重命名的參數
go.refactoring.change.signature.new.parameter.validation.message.part=新參數
go.refactoring.extract.interface.rename.type.and.use.interface.radio.button=重命名原始類型並在可能的情況下使用接口(&E)
go.refactoring.extract.interface.rename.type.spec.label=將類型規範重命名為:
go.refactoring.extract.interface.unexported.method.specification.validation.message={0} {1} 不會實作未匯出的方法規範
go.refactoring.extract.interface.unexported.not.be.accessible.validation.message=未匯出的{0}將無法從{1}存取
go.refactoring.extract.interface.empty.type.name.validation.message=類型名稱不應為空。
go.refactoring.extract.interface.incorrect.type.name.validation.message=類型名稱不正確。
go.refactoring.introduce.extract.title=提取
go.refactoring.introduce.extract.function.title=提取函數
go.refactoring.introduce.extract.function.command=提取函數
go.refactoring.introduce.extract.method.command=提取方法
go.refactoring.introduce.extract.variable.command=提取變數
go.refactoring.introduce.extract.method.or.function.title=提取方法或函數
go.refactoring.introduce.write.command=在提取函數期間更新 return 語句
go.refactoring.introduce.range.contains.defer.message=所選範圍包含 'defer' 語句，該語句可能會在提取期間重新排序
go.refactoring.introduce.receiver.without.name.error.message=接收器應有名稱
go.refactoring.introduce.continue.statement.interrupts.execution.flow.error.message=當 continue 語句中斷執行流時，不支持重構
go.refactoring.introduce.label.reference.interrupts.execution.flow.error.message=當標籤引用中斷執行流時，不支持重構
go.refactoring.introduce.label.definition.selected.with.all.references.error.message=只有選擇標籤定義及其所有引用時，才支援重構
go.refactoring.introduce.does.not.return.value.error.message=表達 {0} 不返回值。
go.refactoring.introduce.not.constant.value.error.message=表達式 {0} 不是常量值。
go.refactoring.introduce.method.with.receiver.renderer=包含 {0} 接收器的方法
go.refactoring.introduce.type.dialog.title=引入類型
go.refactoring.introduce.type.command=引入類型
go.refactoring.introduce.type.chooser.title=選擇類型
go.refactoring.move.affect.initialization.order.validation.message=移動函數 {0} 可能會影響該套用程序的初始化順序
go.refactoring.move.break.initialization.validation.message=移動變數 {0} 將中斷變數 {1} 的初始化
go.refactoring.move.value.will.change.validation.message=常數 {0} 的值將更改，因為它使用 {1} 進行宣告
go.refactoring.move.function.will.not.start.application.validation.message=軟體套件 {1} 外部的函數 {0} 將不再啟動此套用程序
go.refactoring.move.type.will.not.implement.interface.validation.message=類型 {0} 將不再實作接口 {1}
go.refactoring.move.exported.function.will.not.start.application.validation.message=匯出的函數 {0} 將不再啟動應用程式
go.refactoring.move.exported.function.will.not.perform.initialization.validation.message=匯出的函數 {0} 將不再執行初始化
go.refactoring.move.type.will.become.non.local.for.method.validation.message=類型 {0} 將成為方法 {1} 的非局部類型
go.refactoring.move.required.by.validation.message={0}需要
go.refactoring.move.file.should.differ.validation.message=目標檔案應與源文件不同
go.refactoring.rename.looking.for.anonymous.field.usages.progress.title=正在尋找匿名欄位用法
go.refactoring.rename.looking.for.method.usages.progress.title=正在尋找方法用法
go.refactoring.rename.package.title=同時將軟體套件 ''{0}'' 重命名為 ''{1}''?
go.refactoring.rename.test.file.title=同時重命名測試檔案 ''{0}''?
go.refactoring.rename.production.file.title=同時重命名生產檔案 ''{0}''?
go.refactoring.rename.directory.message=同時重命名軟體套件目錄 ''{0}''?
go.refactoring.rename.current.receiver.option=僅重命名當前接收器
go.refactoring.rename.all.receivers.option=重命名所有接收器
go.find.usages.of.interface.methods.dialog.base.methods.checkbox=基方法(&B)
go.find.usages.of.interface.methods.dialog.title=尋找接口方法的用法?
go.find.usages.of.interface.methods.dialog.message=類型 ''{0}'' 實作接口，方法 ''{1}'' 覆寫方法。您是否希望尋找接口方法的用法?
go.find.usages.of.interface.methods.notification.title=正在尋找接口方法的用法
go.find.usages.of.interface.methods.notification.show.options.text=顯示選項 {0}
go.find.usages.show.usages.in.comments.text=在註釋中顯示用法
go.find.usages.show.usages.in.comments.description=在註釋中顯示元素用法
go.code.smells.commit.local.paths=提交本地路徑可能無法移植
go.init.with.zero.value=使用零值初始化
go.usage.type.return.type=返回類型
go.usage.type.parameter.declaration=參數宣告
go.usage.type.struct.initialization=結構初始化
go.usage.type.import=匯入
go.usage.type.variable.declaration=變數宣告
go.usage.type.field.declaration=欄位宣告
go.usage.type.const.declaration=常數宣告
go.usage.type.receiver=接收器
go.usage.type.type.assertion=類型斷言
go.usage.type.type.alias=類型別名
go.usage.type.type.conversion=類型轉換
go.inspection.problem.unmarshal.argument.must.be.a.pointer=此實參必須為指針類型
go.enable.template.plugin.notification.text=啟用 Go 模板以增強 html/templates 軟體套件中的突出顯示、補全和導航功能
go.enable.template.plugin.action.text=啟用延伸模組
go.install.template.plugin.notification.text=安裝 Go 模板以增強 html/templates 軟體套件中的突出顯示、補全和導航功能
go.install.template.plugin.action.text=安裝延伸模組
go.ignore.template.plugin.action.text=忽略此專案的延伸模組
go.inspection.problem.range.var.copies.lock=範圍變數 {0} 複製鎖定: {1}
go.inspection.problem.function.passes.lock.by.value={0} 通過此值傳遞鎖定: {1}
go.inspection.problem.return.copies.lock.value=返回複製鎖定值: {0}
go.inspection.problem.call.copies.lock.value=調用 {0} 將複製鎖定值: {1}
go.inspection.problem.literal.copies.lock.value=文字從 {0} 複製鎖定值: {1}
go.inspection.problem.assignment.copies.lock.value=賦值將鎖定值複製到 {0}: {1}
go.inspection.problem.variable.declaration.copies.lock.value=變數宣告將鎖定值複製到 {0}: {1}
go.inspection.problem.invalid.second.argument.to.errors.as={0} 的第二個實參必須是一個指針，該指針指向接口或指向實作錯誤接口的類型
go.inspection.problem.expression.is.too.small.for.shift={0} ({1} 位)對於 {2} 的移位太小
go.inspection.problem.method.has.non.standard.signature=方法 {0} 應包含簽名 {1}
go.inspection.problem.direct.assignment.to.atomic.value=直接賦值給原子值
go.inspection.problem.cannot.take.address.of.non.addressable.operand=無法獲取不可尋址操作數的地址
go.inspection.problem.assignment.to.method.receiver.propagates.only.to.callees=對方法接收器的賦值僅傳播到被調用方，不傳播到調用方
go.inspection.problem.assignment.to.method.receiver.doesnt.propagate=對方法接收器的賦值不傳播到其他調用
go.inspection.problem.expression.can.be.simplified.to.other={0} 可以簡化為 {1}
go.inspection.problem.condition.is.always.true.or.false=條件 {0} 始終為 {1}
go.inspection.problem.conversion.from.int.to.string=從 {0} 到 {1} 的轉換將整數值解釋為程式碼點
go.inspection.problem.expression.is.always.true.or.false=表達式 {0} 始終為 {1}
go.inspection.problem.expression.can.be.simplified=可以簡化表達式
go.inspection.problem.possible.malformed.build.comment='+build' 註釋的格式可能不正確
go.inspection.problem.wrong.location.of.build.comment='build' 註釋必須出現在軟體包子句前面，後面跟隨一個空白行
go.inspection.problem.usage.of.cgo.in.tests=不支持在測試中使用 cgo
go.inspection.problem.comment.should.start.with.whitespace=註釋應以空白開頭
go.inspection.problem.defer.is.called.in.a.for.loop=可能發生資源泄漏，在 {1} 迴圈中調用 {0}
go.inspection.problem.deprecated.is.still.used=被棄用的 {0} 仍在使用
go.inspection.problem.reference.is.deprecated=已棄用 {0}
go.inspection.problem.division.by.zero=除以零
go.inspection.problem.duplicate.case=case {0} 重複
go.inspection.problem.variable.repeated.on.left.side={0} 在 := 的左側重複
go.inspection.problem.name.redeclared.as.imported.package={0} 被重新宣告為匯入的軟體套件名稱
go.inspection.problem.name.collides.with.name.declared.in.this.package={0} 與此軟體套件中宣告的名稱衝突
go.inspection.problem.label.already.defined=已定義標籤 {0}
go.inspection.problem.duplicate.argument=實參 {0} 重複
go.inspection.problem.name.redeclared.in.this.function=此函數中重新聲明了 {0}
go.inspection.problem.duplicate.field=重複欄位 {0} 
go.inspection.problem.type.has.same.named.field.and.method=\n類型 {0} 的欄位和方法均命名為 {1}
go.inspection.problem.method.redeclared=方法重新宣告 {0}
go.inspection.problem.type.has.both.field.and.method.with.name=\n類型 {0} 的欄位和方法均命名為 {1}
go.inspection.problem.duplicate.method=方法 {0} 重複
go.inspection.problem.name.redeclared.in.this.package=此包中重新宣告的 {0}
go.inspection.problem.name.redeclared.in.this.block=此塊中重新聲明了 {0}
go.inspection.problem.bad.error.string=錯誤字串不應大寫或以標點結尾
go.inspection.problem.exported.element.should.have.comment=匯出的 {0} {1} 應有註釋，否則就是未匯出
go.inspection.problem.exported.function.with.unexported.return.type=匯出的 {0} 具有未匯出的返回類型
go.inspection.problem.exported.var.should.have.its.own.declaration=匯出的變數 {0} 應有自己的宣告
go.inspection.problem.exported.const.should.have.its.own.declaration=匯出的常數 {0} 應有自己的宣告
go.inspection.problem.missing.argument.to.conversion=缺少要轉換為 {0} 的實參: {1}
go.inspection.problem.too.many.arguments.to.conversion=要轉換為 {0} 的實參過多: {1}
go.inspection.problem.too.many.arguments.in.call={0} 調用中的實參過多
go.inspection.problem.not.enough.arguments.in.call={0} 調用中的實參不足
go.inspection.problem.name.collides.with.imported.package={0} {1} 與匯入的軟體套件名稱衝突
go.inspection.problem.impossible.type.assertion=不可能的類型斷言: {0} 未實作 {1}
go.inspection.problem.impossible.interface.assertion=從 {0} 到 {1} 的接口宣告無效。模糊: {2}
go.inspection.problem.impossible.type.switch.case=不可能的類型 swich case: {0} 未實作 {1}
go.inspection.problem.infinite.for.loop=無限的 {0} 迴圈
go.inspection.problem.cannot.convert.expression=無法將類型 {0} 的表達式轉換為類型 {1}
go.inspection.problem.cannot.convert.nil=無法將 ''nil'' 轉換為類型 {0}
go.inspection.problem.invalid.conversion=無效轉換
go.inspection.problem.cannot.slice=無法切片 {0} (類型 {1})
go.inspection.problem.type.does.not.support.indexing=無效運算: {0} (類型 {1} 不支持索引)
go.inspection.problem.invalid.low.high.indices=無效索引值，必須低值 <= 高值
go.inspection.problem.invalid.low.high.max.indices=無效索引值，必須為低值 <= 高值 <= 最大值
# 0 - index value, i.e. "-1", 1 - additional information
go.inspection.problem.invalid.slice.index=無效的切片索引 {0} ({1})
# 0 - index value, i.e. "-1", 1 - indexed container type, i.e. "array" or "string", 2 - additional information
go.inspection.problem.invalid.iterable.index=無效的 {0} 索引 {1} ({2})
go.inspection.problem.must.be.representable.by.int=值必須可由 'int' 類型表示
go.inspection.problem.must.be.of.integer.type=必須為整數型
go.inspection.problem.must.be.non.negative=必須為非整數型
go.inspection.problem.out.of.bounds.for.string={0} 字節的字串超出界限
go.inspection.problem.out.of.bounds.for.array={0} 元素的陣列超出界限
go.inspection.problem.invalid.receiver.type=無效接收器類型{0} ({1} 為 {2})
go.inspection.problem.invalid.receiver.unnamed.type=未命名類型
go.inspection.problem.invalid.receiver.interface.type=接口類型
go.inspection.problem.invalid.receiver.pointer.type=指針類型
go.inspection.problem.cannot.define.new.methods.on.non.local.type=無法在非局部類型 {0} 上定義新方法
go.inspection.problem.use.of.internal.package.is.not.allowed=不允許使用內部軟體套件
go.inspection.problem.use.of.vendored.package.is.not.allowed=不允許使用供應商提供的軟體套件
go.inspection.problem.must.be.imported.as=必須作為 {0} 匯入
go.inspection.problem.at.is.not.allowed.in.import.paths=匯入路徑中不允許 @
go.inspection.problem.cannot.import.absolute.path=無法匯入絕對路徑
go.inspection.problem.cannot.import.builtin.package=無法匯入 'builtin' 軟體套件
go.inspection.problem.non.canonical.import.path=非規範的匯入路徑: {0} 應為 {1}
go.inspection.problem.build.constraints.exclude.all.go.files=建置約束排除 {0} 中所有的 Go 檔案
go.inspection.problem.path.is.a.program.not.an.importable.package={0} 是程序，不是可匯入的軟體套件
go.inspection.problem.found.several.packages=在 {1} 中找到多個軟體套件 [{0}] 
go.inspection.problem.no.non.test.go.files=軟體套件僅包含測試 Go 檔案: {0}
go.inspection.problem.cannot.import=無法匯入 {0}
go.inspection.problem.cannot.rename.import.c=無法重命名 import 'C'
go.inspection.problem.path.imports.package.with.invalid.import.comment={0} 匯入包含無效匯入註釋的軟體套件
go.inspection.problem.path.imports.package.that.expects.canonical.import={0} 匯入需要匯入 "{1}" 的軟體套件
go.inspection.problem.invalid.composite.literal.type=無效的複合文字類型: {0}
go.inspection.problem.too.few.values=值太少
go.inspection.problem.too.many.values=值太多
go.inspection.problem.cannot.assign.value.to.blank.field=無法將值賦給空欄位
go.inspection.problem.cannot.assign.value.to.unexported.field=無法將值賦給未匯出的欄位 {0}
go.inspection.problem.missing.type.in.composite.literal=複合文字中缺少類型
go.inspection.problem.mixture.of.field=混合欄位: 值和初始設定式
go.inspection.problem.invalid.field.name=欄位名無效
go.inspection.problem.missing.expression=缺少表達式
go.inspection.problem.missing.key.in.map.literal=映射文字中缺少鍵
go.inspection.problem.duplicate.key.in.map.literal=映射文字中的鍵 {0} 重複
go.inspection.problem.cannot.convert.known.value.to.type=無法將 {0} 轉換為 {1}
go.inspection.problem.cannot.convert.value.to.type=無法將值轉換為 {0}
go.inspection.problem.index.must.be.a.non.negative.integer.constant=索引 {0} 必須是非負整數常數
go.inspection.problem.negative.index=負索引: {0}
go.inspection.problem.index.out.of.bounds=索引超出界限: {0}
go.inspection.problem.duplicate.index=重複的索引: {0}
go.inspection.problem.reference.jumps.over.declaration={0} 跳過 {1} 的宣告
go.inspection.problem.missing.return=函數末尾缺少 'return' 語句
go.inspection.problem.need.trailing.comma.in.composite.literal=複合文字中的換行符前需要尾隨逗號
go.inspection.problem.need.trailing.comma.in.parameter.list=參數列表中的換行符前面需要有尾隨逗號
go.inspection.problem.need.trailing.comma.in.argument.list=實參列表中的換行符前面需要有尾隨逗號
go.inspection.problem.multiple.packages.in.directory=目錄中有多個軟體套件: {0}
go.inspection.problem.name.starts.with.package.name=名稱以軟體套件名稱開頭
go.inspection.problem.cannot.call.non.function=無法調用類型為 {1} 的非函數 {0}
go.inspection.problem.empty.slice.declaration.via.literal=使用文字的空切片宣告
go.inspection.problem.function.does.not.take.writer=\n函數不使用 {0}，但第一個實參是 {1}
go.inspection.problem.possible.formatting.directive={0} 中可能的格式指令
go.inspection.problem.last.argument.ends.with.redundant.newline={0} 的最後一個實參以冗餘的換行符結尾
go.inspection.problem.return.value.has.a.function.type=返回值 {0} 具有函數類型
go.inspection.problem.argument.is.not.a.function.call=實參 {0} 不是函數調用
go.inspection.problem.argument.causes.recursive.call.to.string.method=實參 {0} 導致對 {1} 方法的遞歸調用
go.inspection.problem.receiver.has.generic.name=接收器具有泛型名稱
go.inspection.problem.receiver.names.are.different=接收器名稱不同
go.inspection.problem.invalid.recursive.type=無效遞歸 {0} {1}{2}
go.inspection.problem.redundant.blank.expression=冗餘 {0} 表達式
go.inspection.problem.redundant.comma=冗餘逗號
go.inspection.problem.possibly.redundant.type.conversion=類型轉換可能冗餘
go.inspection.problem.redundant.type.conversion=冗餘類型轉換
go.inspection.problem.redundant.alias=冗餘別名
go.inspection.problem.redundant.parentheses=冗餘括號
go.inspection.problem.redundant.index=冗餘索引 {0}
go.inspection.problem.redundant.semicolon=冗餘分號
go.inspection.problem.redundant.type=冗餘類型
go.inspection.problem.name.collides.with.builtin={0} {1} 與 ''builtin'' {2} 衝突
go.inspection.problem.value.is.assigned.to.itself={0} 的值被賦予本身
go.inspection.problem.self.import.is.not.allowed=不允許自我匯入
go.inspection.problem.declaration.shadows.declaration={0} 的宣告隱藏宣告
go.inspection.problem.declaration.shadows.declaration.at={0} 的宣告隱藏 {1} 處的宣告
go.inspection.problem.eliminate.snake.case=消除蛇形命名法
go.inspection.problem.use.camelcase.instead.of.snake.case=使用駝峰式命名法，不使用蛇形命名法
go.inspection.problem.mismatched.types.byte.and.string=不符合的類型: 字節和字串
go.inspection.problem.bad.count.argument.of.strings.replace={0} 的計數實參不應為 {1}
go.inspection.problem.fields.are.assigned.without.explicit.names=欄位分配時沒有顯式名稱
go.inspection.problem.wrong.example.signature=範例簽名錯誤
go.inspection.problem.wrong.test.signature=測試簽名錯誤
go.inspection.problem.cannot.use.underscore.as.value=無法將 {0} 用作值
go.inspection.problem.unhandled.error=未處理錯誤
go.inspection.problem.unit.specific.suffix=特定於單元的後綴 {0}
go.inspection.problem.unnecessarily.exported.element=不必要地匯出了 {0} {1}
go.inspection.problem.unreachable.code=不可到達的程式碼
go.inspection.problem.imports.are.not.sorted=import 未排序
go.inspection.problem.unused.result=未使用的結果: {0}
go.inspection.problem.unused.import=未使用的 import
go.inspection.problem.assignment.used.as.value={0} 作為值使用
go.inspection.problem.no.placeholders.in.format.string=格式字串中沒有佔位符
go.inspection.problem.too.many.arguments.for.format.string=格式字串的實參過多: 應為 {0}，實際為 {1}
go.inspection.problem.verb.will.ignore.flag=動詞將忽略 {0} 標誌 {1}
go.inspection.problem.verb.will.ignore.flags=動詞將忽略 {0} 標誌 {1}
go.inspection.problem.placeholder.syntax.error=佔位符語法錯誤 {0}
go.inspection.problem.this.verb.can.be.used.only.in.fmt.errorf=此動詞只能在 {0} 個調用 {1} 中使用
go.inspection.problem.this.verb.can.be.used.only.once.in.a.format.string=此動詞只能在格式字串 {0} 中使用一次
go.inspection.problem.fmt.parameter.with.non.integer.expression=使用非整數型表達式 {1}{2} 指定了{0, choice, 0#寬度|1#精度|2#謂詞}
go.inspection.problem.no.argument.for.placeholder.part=沒有{0, choice, 0#寬度|1#精度|2#動詞}的實參: 實參索引 = {1}，實參計數 = {2}{3}
go.inspection.problem.unknown.verb=未知動詞 {0}{1}
go.inspection.problem.return.value.of.placeholder.argument.has.a.function.type=佔位符實參的返回值具有函數類型 {0}
go.inspection.problem.placeholder.argument.is.not.a.function.call=佔位符實參不是函數調用 {0}
go.inspection.problem.placeholder.argument.has.wrong.type=佔位符實參 {0} 具有錯誤的類型 {1}{2}
go.inspection.problem.placeholder.argument.causes.recursive.call.to.string=佔位符實參導致對 {0} 方法 {1} 的遞歸調用
go.inspection.problem.index.zero.is.illegal=索引值 [0] 為非法的 {0}
go.inspection.problem.invalid.use.of.triple.dot=無效使用 '...'，對應參數是非可變參數
go.inspection.problem.too.many.arguments.to.return=要返回的實參太多
go.inspection.problem.not.enough.arguments.to.return=要返回的實參不足
go.inspection.problem.invalid.argument.must.be.complex.type=無效的實參 {0} (類型 {1}): 必須為複雜類型
go.inspection.problem.expression.with.type={0} (類型 {1})
go.inspection.problem.non.bool.used.as.condition=非布林值 {0} 用作條件
go.inspection.problem.cannot.range=範圍不能超過 {0}
go.inspection.problem.type.or.type={0} 或 {1}
go.inspection.problem.nil.is.not.allowed=不允許 {0}。必須為 {1}
go.inspection.problem.incompatible.types=無法將 {0} 用作類型 {1}
go.inspection.problem.incompatible.types.in.switch=switch {1} 中的 case {0} 無效
go.inspection.problem.incompatible.types.in.switch.on.expression={1} {2} 的 switch 中的 case {0} 無效
go.inspection.problem.mismatched.types=(類型 {0} 和 {1} 不符合)
go.inspection.problem.incompatible.types.some.methods.are.missing=類型未實作 {0}，因為<b color={1}>缺少某些方法: <br/>{2}</b>
go.inspection.problem.incompatible.types.ambiguous.methods=類型未實作 {0}，因為 <b color={1}>{2} 不明確</b>
go.inspection.problem.incompatible.method.has.pointer.receiver=類型未實作 {0}，因為 <b color={1}>{2} 方法有指針接收器</b>
go.inspection.problem.incompatible.need.method.have.method=類型未實作 {0}<br/><b color={1}> 需要方法: {2}<br/>具有方法: {3}</b>
go.inspection.problem.incompatible.unexported.method=類型無法實作 {0}，因為<b color={1}>類型有未匯出的方法，並且是在不同的軟體套件中定義</b>
go.inspection.problem.invalid.inc.dec.operation=無效運算: {0}(非數值類型 {1})
go.inspection.problem.cannot.assign.in.multiple.assignment=無法在多個賦值中將 {0} 賦給 {1}
go.inspection.problem.cannot.convert.nil.to.type=無法將 {0} 轉換為類型 {1}
go.inspection.problem.invalid.unary.operation=無效運算: {0}
go.inspection.problem.cannot.convert.constant=無效運算: {0} (無法將常數 {1} 轉換為類型 {2})
go.inspection.problem.operator.not.defined=無效運算: {0} (在 {2} 中未定義運算符 {1})
go.inspection.problem.receive.from.send.only.type=無效運算: {0} (從僅發送類型 {1} 接收)
go.inspection.problem.receive.from.non.chan.type=無效運算: {0} (從非 chan 類型 {1} 接收)
go.inspection.problem.send.to.non.chan.type=無效運算: {0} (发送到非 chan 類型 {1})
go.inspection.problem.send.to.receive.only.type=無效運算: {0} (发送到僅接收類型 {1})
go.inspection.problem.invalid.operation.mismatched.types=無效運算: {0}(類型 {1} 和 {2} 不符合)
go.inspection.problem.shift.count.must.be.unsigned.integer=無效運算: {0} (移位計數類型 {1}，必須為無符號整數)
go.inspection.problem.shift.count.must.be.integer=無效運算: {0} (移位計數類型 {1}，必須為整數)
go.inspection.problem.negative.shift.count=無效運算: {0} (負移位計數)
go.inspection.problem.receiver.may.be.nil.in.call=接收器 {0} 在調用中可能是 {1}
go.inspection.problem.method.call.may.lead.to.nil.pointer.dereference=方法調用 {0} 可能導致 nil 指針取消引用
go.inspection.problem.function.call.may.lead.to.nil.pointer.dereference=函數調用 {0} 可能導致 nil 指針取消引用
go.inspection.problem.accessing.field.may.lead.to.nil.pointer.dereference=存取欄位 {0} 可能導致 nil 指針取消引用
go.inspection.problem.send.may.block.because.of.nil.channel=由於 {0} 通道，發送運算可能會阻止 goroutine
go.inspection.problem.receive.may.block.because.of.nil.channel=由於 {0} 通道，接收運算可能會阻止 goroutine
go.inspection.problem.potential.nil.pointer.dereference=可能發生 nil 指針取消引用
go.inspection.problem.assignment.to.entry.may.panic.because.of.nil.map=由於 {0} 映射，賦值給某個條目可能會出現 panic
go.inspection.problem.indexing.may.panic.because.of.nil.slice=由於切片 {0}，索引可能會出現 panic
go.inspection.problem.nil.loop.is.always.skipped=總是跳過迴圈，因為 {0} 總是 {1}
go.inspection.problem.corresponding.error.may.be.not.nil={0} 可能有 {1} 或其他非預期值，因為它相應的錯誤變數可能不是 {2}
go.inspection.problem.condition.is.always.true.or.false.because.of.nil=條件始終為 {0}，因為 {1} 始終是 {2}
go.inspection.problem.condition.is.always.true.or.false.because.of.not.nil=條件始終為 {0}，因為 {1} 始終不是 {2}
go.inspection.problem.unused.dependency=未使用的依賴項
go.inspection.problem.contains=包含
go.inspection.problem.type.which.is.sync.locker=類型 %s，它是 <code>sync.Locker</code>
go.inspection.problem.type.is.sync.locker=類型 %s 為 <code>sync.Locker</code>
go.module=模組
go.modules.scratch.file.notification.text=使用模組上下文
go.run.target.executable.path.label=Go 可執行檔案: 
go.run.target.gopath.label=GOPATH: 
go.run.target.version.label=版本:
go.run.target.configure.label=Go 設定
go.run.target.run.label=執行 Go 套用程序
go.attach.directory.action.text=附加目錄 "{0}"
go.detach.directory.action.text=分離目錄 "{0}"
go.remove.else=移除 else
go.unwrap.else=解開 else
go.unwrap.for=解開 for
go.unwrap.argument=解開實參
go.unwrap.argument.description=解開 {0}
go.unwrap.if=解開 if
go.settings.global.gopath.group.name=全域 GOPATH
go.settings.project.gopath.group.name=專案 GOPATH
go.settings.module.gopath.group.name=模組 GOPATH
go.dep.executable.path.label=Dep 可執行檔案
go.quick.doc.package.label=軟體套件:
go.quick.doc.resolved.value.label=已解析的值: 
go.quick.doc.methods.label=方法:
go.settings.folding.one.line.return.checkbox=一行返回
go.settings.folding.one.line.panics.checkbox=1 行 panic
go.settings.folding.format.strings.checkbox=格式字串
go.settings.formatter.add.space.except.for.comments.label=以此開頭的註釋除外: 
go.settings.formatter.comment.prefix.cannot.be.empty.validation.message=註釋前綴不能為空
go.notification.go.root.is.not.defined.text=未定義 GOROOT
go.notification.go.root.is.incorrect.text=GOROOT 不正確
go.refactoring.split.declarations.action.text=拆分宣告
go.refactoring.split.declarations.with.iota.warning=由於 `iota`，宣告初始設定式拆分後會有不同的值
go.refactoring.merge.declarations.action.text=合併宣告
go.refactoring.merge.declarations.with.iota.warning=由於 `iota`，宣告初始設定式合併後會有不同的值
go.inlays.show.unnamed.fields.in.structure.values.option=在結構值中顯示未命名欄位
go.inlays.show.return.parameters.option=顯示返回參數
go.quick.settings.file.watchers.text=儲存時的操作…
go.quick.settings.file.watchers.description=編輯 go fmt、goimports 和其他命令行工具
go.file.watcher.go.imports.description=對 Go 檔案執行 'goimports'
go.file.watcher.go.fmt.description=對 Go 檔案執行 'go fmt'
go.file.watcher.golangci.description=在當前 Go 檔案目錄中執行 'golangci-lint'
go.before.check.in.show.fmt.error.button=詳細資訊(&D)…
go.completion.fill.all.fields.lookup.string=填充所有欄位…
go.completion.fill.selected.fields.lookup.string=填充所選欄位…
go.modules.dependency.diagram=Go 模組依賴項圖
go.converter.build.run.configuration.description='Go Build' 執行設定已更改。需要轉換現有設定。
go.converter.single.file.run.configuration.description='Run single Go file' 執行設定已移除。需要轉換現有設定。
go.converter.build.tags.description=Go 專案設定存儲機制已更改，需要更新專案及其模組。
go.converter.sdk.description=Go 專案模型已更改，請更新專案及其模組
go.converter.project.model.description=Go 專案模型已更改，請更新專案及其模組
go.inspection.options.panel.import.path=匯入路徑
go.inspection.options.panel.function.name=函數名稱
go.inspection.options.panel.string.methods=字串方法
go.inspection.options.panel.reported.functions=報告的函數/方法: 
go.inspection.options.panel.receiver=接收器
go.inspection.options.panel.method.name=方法名稱
go.inspection.options.panel.exclude=排除:
go.structure.view.show.package.structure.action.text=顯示軟體套件結構
go.structure.view.private.members.filter.text=顯示 private 成員
go.structure.view.exportability.sorter.text=按匯出性排序
go.structure.view.method.location=在 {0} 中
go.sum.generated.sources.filter.notification.text=不應編輯該檔案，因為該檔案僅供 Go 工具使用。變更可能會導致建置行程中斷。
go.modules.background.task.updating.dependencies.title=更新 Go 模組依賴項
go.modules.background.task.updating.dependencies.text=正在 {0} 個 ''go.mod'' {0,choice,0#檔案|1#檔案|2#檔案} 上執行 ''go list''…
go.modules.unknown.dependencies.notification.text=完整的模組依賴關係集合未知，某些特定於 Go 模組的功能可能不可用。
go.modules.unknown.dependencies.notification.tooltip=可能是由網絡連接問題或顯式 GOPROXY=off 導致。
go.modules.unknown.dependencies.notification.retry=重新執行 ''{0}''
go.modules.tree.structure.replaced=(已取代)
go.modules.tree.structure.replacement=取代: {0}
go.live.template.context.type.file.presentable.name=檔案
go.live.template.context.type.type.presentable.name=類型
go.live.template.context.type.block.presentable.name=塊
go.live.template.context.type.expression.presentable.name=表達式
go.live.template.context.type.tag.presentable.name=標記
go.live.template.context.type.tag.literal.presentable.name=標記文字
go.live.template.context.type.statement.presentable.name=語句
go.sdk.no.version.text=<無版本>
go.edit.settings.action.description=編輯 Go 特定的 {0}
go.new.project.step.web.group.name=Web
go.new.project.step.other.group.name=其他
project.files.and.vendor.scope.name=專案檔案和供應商
go.project.configurable.name=Go
go.inspection.discarded.context.cancel.function=應該調用取消函數，而不是將其丟棄，以避免上下文泄漏
go.inspection.function.returns.without.calling.context.cancel.function=有一個執行路徑沒有調用此取消函數，從而導致上下文泄漏
go.inspection.execution.ends.without.context.cancel.function.after.instruction=執行可能在此指令後結束而不調用 ''{0}'' 函數，從而導致上下文泄漏
go.inspection.execution.ends.without.context.cancel.function.after.statement=執行可能在此 ''{0}'' 語句後結束而不調用 ''{1}'' 函數，從而導致上下文泄漏
go.inspection.problematic.execution.path.end=有問題的執行路徑的結束
postfix.template.provider.name=Go
postfix.template.condition.error.name=錯誤
postfix.template.condition.error.expr.result.name=表達式包含錯誤結果
postfix.template.condition.array.name=陣列
postfix.template.condition.slice.name=切片
postfix.template.condition.assignable.slice.name=可分配的切片
postfix.template.condition.map.name=映射
postfix.template.condition.channel.name=通道
postfix.template.condition.builtin.len.applicable.name=適用內建 len
postfix.template.condition.builtin.cap.applicable.name=適用內建 cap
postfix.template.condition.builtin.append.applicable.name=適用內建 append
postfix.template.condition.non.void.name=非 void
postfix.template.condition.comparable.to.nil.name=與 nil 相當
postfix.template.condition.number.name=數字
postfix.template.condition.boolean.name=布爾
postfix.template.condition.string.name=字串
postfix.template.condition.floats.slice.name=float64s 的切片
postfix.template.condition.ints.slice.name=int 的切片
postfix.template.condition.strings.slice.name=字串切片
postfix.template.condition.interface.impls.slice.name=排序接口實作的切片
postfix.template.condition.expr.in.if.with.missing.block.name=缺少塊的 if 條件中的表達式
postfix.template.condition.slice.with.no.sort.name=沒有專用排序函數的切片
filetype.go.time.description=Go 時間
filetype.go.tag.description=Go 標記
go.cannot.be.represented.by.type={0} 不能由類型 {1} 表示
go.value.cannot.be.represented.by.type={0} 的值不能由類型 {1} 表示
go.go.mod.retract.not.supported=自 Go 1.16 起開始支援 'retract'
go.error.go.embed.not.supported=自 Go 1.16 起支援 go:embed
go.error.go.embed.invalid.syntax.of.paths=路徑模式語法無效
go.error.go.embed.must.be.above.var.declaration=go:embed 必須位於單個全域變數宣告的上方
go.error.go.embed.var.has.wrong.type=go:embed's 變數必須為 'string'、'[]byte' 或 'embed.FS' 類型
go.error.go.embed.invalid.path.elements=路徑不得包含 '.' 或 '..' 路徑元素，也不得以前導斜杠開頭
go.error.go.embed.unresolved.path=未解析路徑
go.error.go.embed.empty.directory=無法嵌入空目錄
go.error.go.embed.single.path.expected='string' 和 '[]byte' 類型的變數只能有一個路徑模式
go.error.go.embed.path.must.resolve.to.file='string' 和 '[]byte' 類型的變數只能嵌入一個檔案
go.error.go.embed.no.path.arguments=go:embed 後面應為路徑模式
go.error.go.embed.file.must.import.embed=包含 go:embed 的 Go 檔案必須匯入 "embed" 軟體套件
go.error.go.embed.invalid.path.pattern=路徑模式無效
go.fix.import.embed.package=匯入 "embed"
go.fix.wrap.error.handling.in.closure=在閉包內部封裝錯誤處理
go.fix.failed.to.handle.error=無法處理錯誤
go.fix.failed.to.introduce.variables.from.call=無法從調用引入變數
go.fix.failed.to.resolve.called.function.signature=無法從調用解析簽名
go.fix.call.receiver.is.not.an.expression=意外的調用接收器，不是表達式
go.inspection.fail.now.in.non.test.goroutine=非測試 goroutine 中的 'FailNow'
go.inspection.fail.now.called.from.non.test.goroutine=必須從執行測試或基準測試的 goroutine 調用此方法
go.fix.replace.and.return=取代為 ''{0}'' 和 ''return''
filetype.go.plus.build.description=Go +build 約束
filetype.go.build.description=Go:build 約束
go.error.go.build.after.package=go:build 指令必須位於 package 子句前面
go.error.go.build.non.first.element=go:build 指令必須為程式碼行的第一個元素
go.error.go.build.without.plus.build=//go:build 註釋沒有 //+build 註釋
go.error.go.build.and.plus.build.lines.dont.match=//+build 行不符合 //go:build 條件
go.error.go.build.only.one.allowed=一個檔案中只允許使用一條 //go:build 指令
go.error.go.build.expression.is.too.complex=表達式對於 //+build 行過於複雜
go.error.go.plus.build.can.be.removed=可以移除 //+build 註釋
go.error.go.plus.build.can.be.converted.to.go.build=//+build 註釋可以轉換為 //go:build 指令
go.error.invalid.double.negation=雙重求反無效
go.error.invalid.non.alphanumeric.character=非字母數字字符無效
go.fix.place.go.build.before.package=將 go:build 放在 package 前面
go.fix.add.plus.build.comments=添加 //+build 註釋
go.fix.update.plus.build.comments=更新 //+build 註釋
go.fix.remove.plus.build.comments=移除 //+build 註釋
go.fix.convert.plus.build.comments.to.go.build.directive=將 //+build 註釋轉換為 //go:build 指令
go.fmt.formatting.service.error.title=無法在 {0} 上執行 gofmt
vgo.intention.add.or.update.go.version.fix.text=在 ''go.mod'' 中將 Go 版本設定為 {0}
vgo.intention.add.or.update.go.version.fix.family.name=在 'go.mod' 中添加或更新 Go 版本
go.external.system.auto.import.is.disabled=已設定註冊表項 "external.system.auto.import.disabled"。IDE 無法正常執行。請禁用此設定並重啟 IDE。
go.inspection.problem.possibly.unused.dependency=可能未使用的依賴項
go.refactoring.introduce.generating.code.template=正在生成程式碼模板…
go.test.generate.fuzz.text=模糊處理
exportable.GoSdkList.presentable.name=已知的 Go SDK 路徑列表
exportable.vgo.presentable.name=已知的 Go 相關環境變數列表